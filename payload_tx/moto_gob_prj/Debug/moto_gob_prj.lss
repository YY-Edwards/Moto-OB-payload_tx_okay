
moto_gob_prj.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002010  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80002010  80002010  00002410  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         0000e9dc  80002010  80002010  00002410  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  80010a00  80010a00  00010e00  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       00000f4c  80010c00  80010c00  00011000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .lalign       00000004  80011b4c  80011b4c  00011f4c  2**0
                  ALLOC
  6 .dalign       00000004  00000004  00000004  00000000  2**0
                  ALLOC
  7 .data         00000a4c  00000008  80011b50  00012008  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .balign       00000004  00000a54  8001259c  00012a54  2**0
                  ALLOC
  9 .bss          000048d0  00000a58  00000a58  00000000  2**2
                  ALLOC
 10 .heap         00011cd8  00005328  00005328  00000000  2**0
                  ALLOC
 11 .comment      00000030  00000000  00000000  00012a54  2**0
                  CONTENTS, READONLY
 12 .debug_aranges 00001330  00000000  00000000  00012a88  2**3
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_pubnames 00002768  00000000  00000000  00013db8  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_info   0002986b  00000000  00000000  00016520  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_abbrev 0000640b  00000000  00000000  0003fd8b  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_line   00015d56  00000000  00000000  00046196  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_frame  000034a0  00000000  00000000  0005beec  2**2
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_str    00007346  00000000  00000000  0005f38c  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .debug_loc    0000b050  00000000  00000000  000666d2  2**0
                  CONTENTS, READONLY, DEBUGGING
 20 .debug_macinfo 0150d249  00000000  00000000  00071722  2**0
                  CONTENTS, READONLY, DEBUGGING
 21 .stack        00001000  00017000  00017000  00000000  2**0
                  ALLOC
 22 .debug_ranges 00001388  00000000  00000000  0157e970  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_start>:

  .global _start
  .type _start, @function
_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80000000:	48 1f       	lddpc	pc,80000004 <_start+0x4>
80000002:	d7 03       	nop
80000004:	80 00       	ld.sh	r0,r0[0x0]
80000006:	b0 a4       	st.b	r8[0x2],r4

80000008 <_trampoline>:

  .global _trampoline
  .type _trampoline, @function
_trampoline:
  // Jump to program start.
  rjmp    program_start
80000008:	e0 8f 10 00 	bral	80002008 <program_start>
	...

80002008 <program_start>:

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002008:	fe ff 00 04 	ld.w	pc,pc[4]
8000200c:	80 00       	ld.sh	r0,r0[0x0]
8000200e:	b0 a4       	st.b	r8[0x2],r4

Disassembly of section .text:

80002010 <DeviceInitializationStatus_brdcst_func-0x71c>:
80002010:	54 6f       	stdsp	sp[0x118],pc
80002012:	6e 65       	ld.w	r5,r7[0x18]
80002014:	20 4f       	sub	pc,4
80002016:	4b 00       	lddpc	r0,800020d4 <program_start+0xcc>
80002018:	54 6f       	stdsp	sp[0x118],pc
8000201a:	6e 65       	ld.w	r5,r7[0x18]
8000201c:	20 65       	sub	r5,6
8000201e:	72 72       	ld.w	r2,r9[0x1c]
80002020:	6f 72       	ld.w	r2,r7[0x5c]
80002022:	00 00       	add	r0,r0
80002024:	0a 0d       	add	sp,r5
80002026:	20 44       	sub	r4,4
80002028:	63 6d       	ld.w	sp,r1[0x58]
8000202a:	2d 45       	sub	r5,-44
8000202c:	6e 74       	ld.w	r4,r7[0x1c]
8000202e:	65 72       	ld.w	r2,r2[0x5c]
80002030:	20 4f       	sub	pc,4
80002032:	4b 20       	lddpc	r0,800020f8 <program_start+0xf0>
80002034:	0a 0d       	add	sp,r5
80002036:	00 00       	add	r0,r0
80002038:	0a 0d       	add	sp,r5
8000203a:	20 44       	sub	r4,4
8000203c:	63 6d       	ld.w	sp,r1[0x58]
8000203e:	2d 45       	sub	r5,-44
80002040:	78 69       	ld.w	r9,r12[0x18]
80002042:	74 20       	ld.w	r0,r10[0x8]
80002044:	4f 4b       	lddpc	r11,80002214 <program_start+0x20c>
80002046:	20 0a       	sub	r10,0
80002048:	0d 00       	ld.w	r0,r6++
8000204a:	00 00       	add	r0,r0
8000204c:	0a 0d       	add	sp,r5
8000204e:	20 44       	sub	r4,4
80002050:	63 6d       	ld.w	sp,r1[0x58]
80002052:	2d 52       	sub	r2,-43
80002054:	65 76       	ld.w	r6,r2[0x5c]
80002056:	6f 6b       	ld.w	r11,r7[0x58]
80002058:	65 20       	ld.w	r0,r2[0x48]
8000205a:	0a 0d       	add	sp,r5
8000205c:	00 00       	add	r0,r0
8000205e:	00 00       	add	r0,r0
80002060:	64 63       	ld.w	r3,r2[0x18]
80002062:	6d 20       	ld.w	r0,r6[0x48]
80002064:	4f 4b       	lddpc	r11,80002234 <program_start+0x22c>
80002066:	2d 6d       	sub	sp,-168
80002068:	6f 25       	ld.w	r5,r7[0x48]
8000206a:	58 00       	cp.w	r0,0
8000206c:	64 63       	ld.w	r3,r2[0x18]
8000206e:	6d 20       	ld.w	r0,r6[0x48]
80002070:	65 72       	ld.w	r2,r2[0x5c]
80002072:	72 6f       	ld.w	pc,r9[0x18]
80002074:	72 00       	ld.w	r0,r9[0x0]
80002076:	00 00       	add	r0,r0
80002078:	0a 0d       	add	sp,r5
8000207a:	20 44       	sub	r4,4
8000207c:	63 6d       	ld.w	sp,r1[0x58]
8000207e:	5f 62       	srmi	r2
80002080:	72 64       	ld.w	r4,r9[0x18]
80002082:	63 73       	ld.w	r3,r1[0x5c]
80002084:	74 20       	ld.w	r0,r10[0x8]
80002086:	0a 0d       	add	sp,r5
80002088:	00 00       	add	r0,r0
8000208a:	00 00       	add	r0,r0
8000208c:	0a 0d       	add	sp,r5
8000208e:	20 46       	sub	r6,4
80002090:	75 6e       	ld.w	lr,r10[0x58]
80002092:	63 74       	ld.w	r4,r1[0x5c]
80002094:	69 6f       	ld.w	pc,r4[0x58]
80002096:	6e 3a       	ld.w	r10,r7[0xc]
80002098:	20 25       	sub	r5,2
8000209a:	78 20       	ld.w	r0,r12[0x8]
8000209c:	0a 0d       	add	sp,r5
8000209e:	20 00       	sub	r0,0
800020a0:	0a 0d       	add	sp,r5
800020a2:	20 43       	sub	r3,4
800020a4:	6f 6e       	ld.w	lr,r7[0x58]
800020a6:	74 72       	ld.w	r2,r10[0x1c]
800020a8:	6f 6c       	ld.w	r12,r7[0x58]
800020aa:	54 79       	stdsp	sp[0x11c],r9
800020ac:	70 65       	ld.w	r5,r8[0x18]
800020ae:	3a 20       	mov	r0,-94
800020b0:	25 78       	sub	r8,87
800020b2:	20 0a       	sub	r10,0
800020b4:	0d 20       	ld.uh	r0,r6++
800020b6:	00 00       	add	r0,r0
800020b8:	0a 0d       	add	sp,r5
800020ba:	20 43       	sub	r3,4
800020bc:	6f 6e       	ld.w	lr,r7[0x58]
800020be:	74 72       	ld.w	r2,r10[0x1c]
800020c0:	6f 6c       	ld.w	r12,r7[0x58]
800020c2:	54 79       	stdsp	sp[0x11c],r9
800020c4:	70 65       	ld.w	r5,r8[0x18]
800020c6:	53 69       	stdsp	sp[0xd8],r9
800020c8:	7a 65       	ld.w	r5,sp[0x18]
800020ca:	3a 20       	mov	r0,-94
800020cc:	25 78       	sub	r8,87
800020ce:	20 0a       	sub	r10,0
800020d0:	0d 20       	ld.uh	r0,r6++
800020d2:	00 00       	add	r0,r0
800020d4:	0a 0d       	add	sp,r5
800020d6:	20 4d       	sub	sp,16
800020d8:	69 63       	ld.w	r3,r4[0x58]
800020da:	5f 72       	srpl	r2
800020dc:	65 70       	ld.w	r0,r2[0x5c]
800020de:	6c 79       	ld.w	r9,r6[0x1c]
800020e0:	20 0a       	sub	r10,0
800020e2:	0d 00       	ld.w	r0,r6++
800020e4:	0a 0d       	add	sp,r5
800020e6:	20 4d       	sub	sp,16
800020e8:	69 63       	ld.w	r3,r4[0x58]
800020ea:	5f 63       	srmi	r3
800020ec:	6c 6f       	ld.w	pc,r6[0x18]
800020ee:	73 65       	ld.w	r5,r9[0x58]
800020f0:	5f 6f       	srmi	pc
800020f2:	6b 20       	ld.w	r0,r5[0x48]
800020f4:	0a 0d       	add	sp,r5
800020f6:	20 00       	sub	r0,0
800020f8:	0a 0d       	add	sp,r5
800020fa:	20 4d       	sub	sp,16
800020fc:	69 63       	ld.w	r3,r4[0x58]
800020fe:	5f 74       	srpl	r4
80002100:	79 70       	ld.w	r0,r12[0x5c]
80002102:	65 3a       	ld.w	r10,r2[0x4c]
80002104:	20 25       	sub	r5,2
80002106:	78 20       	ld.w	r0,r12[0x8]
80002108:	0a 0d       	add	sp,r5
8000210a:	20 00       	sub	r0,0
8000210c:	0a 0d       	add	sp,r5
8000210e:	20 53       	sub	r3,5
80002110:	69 67       	ld.w	r7,r4[0x58]
80002112:	6e 61       	ld.w	r1,r7[0x18]
80002114:	6c 69       	ld.w	r9,r6[0x18]
80002116:	6e 67       	ld.w	r7,r7[0x18]
80002118:	5f 74       	srpl	r4
8000211a:	79 70       	ld.w	r0,r12[0x5c]
8000211c:	65 3a       	ld.w	r10,r2[0x4c]
8000211e:	20 25       	sub	r5,2
80002120:	78 20       	ld.w	r0,r12[0x8]
80002122:	0a 0d       	add	sp,r5
80002124:	20 00       	sub	r0,0
80002126:	00 00       	add	r0,r0
80002128:	0a 0d       	add	sp,r5
8000212a:	20 4d       	sub	sp,16
8000212c:	69 63       	ld.w	r3,r4[0x58]
8000212e:	5f 73       	srpl	r3
80002130:	74 61       	ld.w	r1,r10[0x18]
80002132:	74 65       	ld.w	r5,r10[0x18]
80002134:	3a 20       	mov	r0,-94
80002136:	25 78       	sub	r8,87
80002138:	20 0a       	sub	r10,0
8000213a:	0d 20       	ld.uh	r0,r6++
8000213c:	00 00       	add	r0,r0
8000213e:	00 00       	add	r0,r0
80002140:	0a 0d       	add	sp,r5
80002142:	20 47       	sub	r7,4
80002144:	61 69       	ld.w	r9,r0[0x58]
80002146:	6e 5f       	ld.w	pc,r7[0x14]
80002148:	6f 66       	ld.w	r6,r7[0x58]
8000214a:	66 73       	ld.w	r3,r3[0x1c]
8000214c:	65 74       	ld.w	r4,r2[0x5c]
8000214e:	3a 20       	mov	r0,-94
80002150:	25 78       	sub	r8,87
80002152:	20 0a       	sub	r10,0
80002154:	0d 20       	ld.uh	r0,r6++
80002156:	00 00       	add	r0,r0
80002158:	0a 0d       	add	sp,r5
8000215a:	20 4d       	sub	sp,16
8000215c:	69 63       	ld.w	r3,r4[0x58]
8000215e:	5f 66       	srmi	r6
80002160:	75 6e       	ld.w	lr,r10[0x58]
80002162:	63 74       	ld.w	r4,r1[0x5c]
80002164:	69 6f       	ld.w	pc,r4[0x58]
80002166:	6e 3a       	ld.w	r10,r7[0xc]
80002168:	20 25       	sub	r5,2
8000216a:	78 20       	ld.w	r0,r12[0x8]
8000216c:	0a 0d       	add	sp,r5
8000216e:	20 00       	sub	r0,0
80002170:	0a 0d       	add	sp,r5
80002172:	20 4d       	sub	sp,16
80002174:	69 63       	ld.w	r3,r4[0x58]
80002176:	20 65       	sub	r5,6
80002178:	72 72       	ld.w	r2,r9[0x1c]
8000217a:	6f 72       	ld.w	r2,r7[0x5c]
8000217c:	20 0a       	sub	r10,0
8000217e:	0d 00       	ld.w	r0,r6++
80002180:	0a 0d       	add	sp,r5
80002182:	20 4d       	sub	sp,16
80002184:	69 63       	ld.w	r3,r4[0x58]
80002186:	5f 44       	srge	r4
80002188:	69 73       	ld.w	r3,r4[0x5c]
8000218a:	61 62       	ld.w	r2,r0[0x58]
8000218c:	6c 65       	ld.w	r5,r6[0x18]
8000218e:	64 20       	ld.w	r0,r2[0x8]
80002190:	0a 0d       	add	sp,r5
80002192:	00 00       	add	r0,r0
80002194:	0a 0d       	add	sp,r5
80002196:	20 4d       	sub	sp,16
80002198:	69 63       	ld.w	r3,r4[0x58]
8000219a:	5f 45       	srge	r5
8000219c:	6e 61       	ld.w	r1,r7[0x18]
8000219e:	62 6c       	ld.w	r12,r1[0x18]
800021a0:	65 64       	ld.w	r4,r2[0x58]
800021a2:	20 0a       	sub	r10,0
800021a4:	0d 00       	ld.w	r0,r6++
800021a6:	00 00       	add	r0,r0
800021a8:	73 70       	ld.w	r0,r9[0x5c]
800021aa:	6b 20       	ld.w	r0,r5[0x48]
800021ac:	4f 4b       	lddpc	r11,8000237c <program_start+0x374>
800021ae:	20 2d       	sub	sp,8
800021b0:	73 74       	ld.w	r4,r9[0x5c]
800021b2:	25 32       	sub	r2,83
800021b4:	78 00       	ld.w	r0,r12[0x0]
800021b6:	00 00       	add	r0,r0
800021b8:	73 70       	ld.w	r0,r9[0x5c]
800021ba:	6b 20       	ld.w	r0,r5[0x48]
800021bc:	65 72       	ld.w	r2,r2[0x5c]
800021be:	72 6f       	ld.w	pc,r9[0x18]
800021c0:	72 00       	ld.w	r0,r9[0x0]
800021c2:	00 00       	add	r0,r0
800021c4:	73 70       	ld.w	r0,r9[0x5c]
800021c6:	6b 5f       	ld.w	pc,r5[0x54]
800021c8:	73 5f       	ld.w	pc,r9[0x54]
800021ca:	63 6c       	ld.w	r12,r1[0x58]
800021cc:	6f 73       	ld.w	r3,r7[0x5c]
800021ce:	65 20       	ld.w	r0,r2[0x48]
800021d0:	00 00       	add	r0,r0
800021d2:	00 00       	add	r0,r0
800021d4:	73 70       	ld.w	r0,r9[0x5c]
800021d6:	6b 5f       	ld.w	pc,r5[0x54]
800021d8:	73 5f       	ld.w	pc,r9[0x54]
800021da:	6f 70       	ld.w	r0,r7[0x5c]
800021dc:	65 6e       	ld.w	lr,r2[0x58]
800021de:	20 00       	sub	r0,0
800021e0:	0a 0d       	add	sp,r5
800021e2:	20 45       	sub	r5,4
800021e4:	6e 61       	ld.w	r1,r7[0x18]
800021e6:	62 6c       	ld.w	r12,r1[0x18]
800021e8:	65 5f       	ld.w	pc,r2[0x54]
800021ea:	49 41       	lddpc	r1,80002238 <program_start+0x230>
800021ec:	20 4f       	sub	pc,4
800021ee:	4b 20       	lddpc	r0,800022b4 <program_start+0x2ac>
800021f0:	0a 0d       	add	sp,r5
800021f2:	00 00       	add	r0,r0
800021f4:	0a 0d       	add	sp,r5
800021f6:	20 41       	sub	r1,4
800021f8:	74 74       	ld.w	r4,r10[0x1c]
800021fa:	65 6e       	ld.w	lr,r2[0x58]
800021fc:	75 61       	ld.w	r1,r10[0x58]
800021fe:	74 6f       	ld.w	pc,r10[0x18]
80002200:	72 5f       	ld.w	pc,r9[0x14]
80002202:	4e 75       	lddpc	r5,8000239c <program_start+0x394>
80002204:	6d 62       	ld.w	r2,r6[0x58]
80002206:	65 72       	ld.w	r2,r2[0x5c]
80002208:	3a 20       	mov	r0,-94
8000220a:	25 78       	sub	r8,87
8000220c:	20 0a       	sub	r10,0
8000220e:	0d 00       	ld.w	r0,r6++
80002210:	0a 0d       	add	sp,r5
80002212:	20 56       	sub	r6,5
80002214:	6f 6c       	ld.w	r12,r7[0x58]
80002216:	75 6d       	ld.w	sp,r10[0x58]
80002218:	65 43       	ld.w	r3,r2[0x50]
8000221a:	6f 6e       	ld.w	lr,r7[0x58]
8000221c:	74 72       	ld.w	r2,r10[0x1c]
8000221e:	6f 6c       	ld.w	r12,r7[0x58]
80002220:	3a 20       	mov	r0,-94
80002222:	25 78       	sub	r8,87
80002224:	20 0a       	sub	r10,0
80002226:	0d 00       	ld.w	r0,r6++
80002228:	0a 0d       	add	sp,r5
8000222a:	20 45       	sub	r5,4
8000222c:	6e 61       	ld.w	r1,r7[0x18]
8000222e:	62 6c       	ld.w	r12,r1[0x18]
80002230:	65 5f       	ld.w	pc,r2[0x54]
80002232:	49 41       	lddpc	r1,80002280 <program_start+0x278>
80002234:	20 65       	sub	r5,6
80002236:	72 72       	ld.w	r2,r9[0x1c]
80002238:	6f 72       	ld.w	r2,r7[0x5c]
8000223a:	20 0a       	sub	r10,0
8000223c:	0d 00       	ld.w	r0,r6++
8000223e:	00 00       	add	r0,r0
80002240:	41 75       	lddsp	r5,sp[0x5c]
80002242:	64 69       	ld.w	r9,r2[0x18]
80002244:	6f 52       	ld.w	r2,r7[0x54]
80002246:	6f 75       	ld.w	r5,r7[0x5c]
80002248:	74 69       	ld.w	r9,r10[0x18]
8000224a:	6e 67       	ld.w	r7,r7[0x18]
8000224c:	20 4f       	sub	pc,4
8000224e:	4b 00       	lddpc	r0,8000230c <program_start+0x304>
80002250:	41 75       	lddsp	r5,sp[0x5c]
80002252:	64 69       	ld.w	r9,r2[0x18]
80002254:	6f 52       	ld.w	r2,r7[0x54]
80002256:	6f 75       	ld.w	r5,r7[0x5c]
80002258:	74 69       	ld.w	r9,r10[0x18]
8000225a:	6e 67       	ld.w	r7,r7[0x18]
8000225c:	20 65       	sub	r5,6
8000225e:	72 72       	ld.w	r2,r9[0x1c]
80002260:	6f 72       	ld.w	r2,r7[0x5c]
80002262:	00 00       	add	r0,r0
80002264:	0a 0d       	add	sp,r5
80002266:	20 20       	sub	r0,2
80002268:	54 72       	stdsp	sp[0x11c],r2
8000226a:	61 6e       	ld.w	lr,r0[0x58]
8000226c:	73 6d       	ld.w	sp,r9[0x58]
8000226e:	69 74       	ld.w	r4,r4[0x5c]
80002270:	43 6f       	lddsp	pc,sp[0xd8]
80002272:	6e 74       	ld.w	r4,r7[0x1c]
80002274:	72 6f       	ld.w	pc,r9[0x18]
80002276:	6c 20       	ld.w	r0,r6[0x8]
80002278:	4f 4b       	lddpc	r11,80002448 <program_start+0x440>
8000227a:	20 0a       	sub	r10,0
8000227c:	0d 20       	ld.uh	r0,r6++
8000227e:	00 00       	add	r0,r0
80002280:	0a 0d       	add	sp,r5
80002282:	20 46       	sub	r6,4
80002284:	75 6e       	ld.w	lr,r10[0x58]
80002286:	63 74       	ld.w	r4,r1[0x5c]
80002288:	69 6f       	ld.w	pc,r4[0x58]
8000228a:	6e 3a       	ld.w	r10,r7[0xc]
8000228c:	20 25       	sub	r5,2
8000228e:	78 20       	ld.w	r0,r12[0x8]
80002290:	0a 0d       	add	sp,r5
80002292:	00 00       	add	r0,r0
80002294:	0a 0d       	add	sp,r5
80002296:	20 4d       	sub	sp,16
80002298:	6f 64       	ld.w	r4,r7[0x58]
8000229a:	65 20       	ld.w	r0,r2[0x48]
8000229c:	6f 66       	ld.w	r6,r7[0x58]
8000229e:	20 4f       	sub	pc,4
800022a0:	70 65       	ld.w	r5,r8[0x18]
800022a2:	72 61       	ld.w	r1,r9[0x18]
800022a4:	74 69       	ld.w	r9,r10[0x18]
800022a6:	6f 6e       	ld.w	lr,r7[0x58]
800022a8:	3a 20       	mov	r0,-94
800022aa:	25 78       	sub	r8,87
800022ac:	20 0a       	sub	r10,0
800022ae:	0d 00       	ld.w	r0,r6++
800022b0:	0a 0d       	add	sp,r5
800022b2:	20 53       	sub	r3,5
800022b4:	74 61       	ld.w	r1,r10[0x18]
800022b6:	74 65       	ld.w	r5,r10[0x18]
800022b8:	3a 20       	mov	r0,-94
800022ba:	25 78       	sub	r8,87
800022bc:	20 0a       	sub	r10,0
800022be:	0d 00       	ld.w	r0,r6++
800022c0:	54 72       	stdsp	sp[0x11c],r2
800022c2:	61 6e       	ld.w	lr,r0[0x58]
800022c4:	73 6d       	ld.w	sp,r9[0x58]
800022c6:	69 74       	ld.w	r4,r4[0x5c]
800022c8:	43 6f       	lddsp	pc,sp[0xd8]
800022ca:	6e 74       	ld.w	r4,r7[0x1c]
800022cc:	72 6f       	ld.w	pc,r9[0x18]
800022ce:	6c 20       	ld.w	r0,r6[0x8]
800022d0:	65 72       	ld.w	r2,r2[0x5c]
800022d2:	72 6f       	ld.w	pc,r9[0x18]
800022d4:	72 00       	ld.w	r0,r9[0x0]
800022d6:	00 00       	add	r0,r0
800022d8:	0a 0d       	add	sp,r5
800022da:	20 20       	sub	r0,2
800022dc:	53 74       	stdsp	sp[0xdc],r4
800022de:	61 6e       	ld.w	lr,r0[0x58]
800022e0:	64 62       	ld.w	r2,r2[0x18]
800022e2:	79 2d       	ld.w	sp,r12[0x48]
800022e4:	52 65       	stdsp	sp[0x98],r5
800022e6:	63 65       	ld.w	r5,r1[0x58]
800022e8:	69 76       	ld.w	r6,r4[0x5c]
800022ea:	65 20       	ld.w	r0,r2[0x48]
800022ec:	0a 0d       	add	sp,r5
800022ee:	20 00       	sub	r0,0
800022f0:	0a 0d       	add	sp,r5
800022f2:	20 20       	sub	r0,2
800022f4:	54 72       	stdsp	sp[0x11c],r2
800022f6:	61 6e       	ld.w	lr,r0[0x58]
800022f8:	73 6d       	ld.w	sp,r9[0x58]
800022fa:	69 74       	ld.w	r4,r4[0x5c]
800022fc:	20 0a       	sub	r10,0
800022fe:	0d 20       	ld.uh	r0,r6++
80002300:	00 00       	add	r0,r0
80002302:	00 00       	add	r0,r0
80002304:	0a 0d       	add	sp,r5
80002306:	20 20       	sub	r0,2
80002308:	43 61       	lddsp	r1,sp[0xd8]
8000230a:	6c 6c       	ld.w	r12,r6[0x18]
8000230c:	5f 73       	srpl	r3
8000230e:	74 61       	ld.w	r1,r10[0x18]
80002310:	74 65       	ld.w	r5,r10[0x18]
80002312:	3a 20       	mov	r0,-94
80002314:	25 78       	sub	r8,87
80002316:	20 0a       	sub	r10,0
80002318:	0d 20       	ld.uh	r0,r6++
8000231a:	00 00       	add	r0,r0
8000231c:	0a 0d       	add	sp,r5
8000231e:	20 44       	sub	r4,4
80002320:	41 54       	lddsp	r4,sp[0x54]
80002322:	41 72       	lddsp	r2,sp[0x5c]
80002324:	65 70       	ld.w	r0,r2[0x5c]
80002326:	20 4f       	sub	pc,4
80002328:	4b 20       	lddpc	r0,800023f0 <program_start+0x3e8>
8000232a:	0a 0d       	add	sp,r5
8000232c:	00 00       	add	r0,r0
8000232e:	00 00       	add	r0,r0
80002330:	0a 0d       	add	sp,r5
80002332:	20 52       	sub	r2,5
80002334:	65 73       	ld.w	r3,r2[0x5c]
80002336:	75 6c       	ld.w	r12,r10[0x58]
80002338:	74 3a       	ld.w	r10,r10[0xc]
8000233a:	20 20       	sub	r0,2
8000233c:	25 58       	sub	r8,85
8000233e:	20 0a       	sub	r10,0
80002340:	0d 00       	ld.w	r0,r6++
80002342:	00 00       	add	r0,r0
80002344:	0a 0d       	add	sp,r5
80002346:	20 44       	sub	r4,4
80002348:	41 54       	lddsp	r4,sp[0x54]
8000234a:	41 72       	lddsp	r2,sp[0x5c]
8000234c:	65 70       	ld.w	r0,r2[0x5c]
8000234e:	20 65       	sub	r5,6
80002350:	72 72       	ld.w	r2,r9[0x1c]
80002352:	6f 72       	ld.w	r2,r7[0x5c]
80002354:	20 0a       	sub	r10,0
80002356:	0d 00       	ld.w	r0,r6++
80002358:	0a 0d       	add	sp,r5
8000235a:	20 46       	sub	r6,4
8000235c:	75 6e       	ld.w	lr,r10[0x58]
8000235e:	63 3a       	ld.w	r10,r1[0x4c]
80002360:	20 20       	sub	r0,2
80002362:	25 58       	sub	r8,85
80002364:	20 0a       	sub	r10,0
80002366:	0d 00       	ld.w	r0,r6++
80002368:	0a 0d       	add	sp,r5
8000236a:	20 49       	sub	r9,4
8000236c:	44 3a       	lddsp	r10,sp[0x10c]
8000236e:	20 20       	sub	r0,2
80002370:	25 58       	sub	r8,85
80002372:	20 0a       	sub	r10,0
80002374:	0d 00       	ld.w	r0,r6++
80002376:	00 00       	add	r0,r0
80002378:	0a 0d       	add	sp,r5
8000237a:	20 43       	sub	r3,4
8000237c:	53 42       	stdsp	sp[0xd0],r2
8000237e:	4b 5f       	lddpc	pc,80002450 <program_start+0x448>
80002380:	52 58       	stdsp	sp[0x94],r8
80002382:	20 4f       	sub	pc,4
80002384:	4b 20       	lddpc	r0,8000244c <program_start+0x444>
80002386:	0a 0d       	add	sp,r5
80002388:	00 00       	add	r0,r0
8000238a:	00 00       	add	r0,r0
8000238c:	0a 0d       	add	sp,r5
8000238e:	20 53       	sub	r3,5
80002390:	65 73       	ld.w	r3,r2[0x5c]
80002392:	73 69       	ld.w	r9,r9[0x58]
80002394:	6f 6e       	ld.w	lr,r7[0x58]
80002396:	5f 49       	srge	r9
80002398:	44 3a       	lddsp	r10,sp[0x10c]
8000239a:	20 25       	sub	r5,2
8000239c:	78 20       	ld.w	r0,r12[0x8]
8000239e:	0a 0d       	add	sp,r5
800023a0:	00 00       	add	r0,r0
800023a2:	00 00       	add	r0,r0
800023a4:	0a 0d       	add	sp,r5
800023a6:	20 70       	sub	r0,7
800023a8:	61 79       	ld.w	r9,r0[0x5c]
800023aa:	6c 61       	ld.w	r1,r6[0x18]
800023ac:	6f 64       	ld.w	r4,r7[0x58]
800023ae:	5f 6c       	srmi	r12
800023b0:	65 6e       	ld.w	lr,r2[0x58]
800023b2:	67 74       	ld.w	r4,r3[0x5c]
800023b4:	68 3a       	ld.w	r10,r4[0xc]
800023b6:	20 25       	sub	r5,2
800023b8:	64 20       	ld.w	r0,r2[0x8]
800023ba:	0a 0d       	add	sp,r5
800023bc:	00 00       	add	r0,r0
800023be:	00 00       	add	r0,r0
800023c0:	0a 0d       	add	sp,r5
800023c2:	20 70       	sub	r0,7
800023c4:	61 79       	ld.w	r9,r0[0x5c]
800023c6:	6c 6f       	ld.w	pc,r6[0x18]
800023c8:	61 64       	ld.w	r4,r0[0x58]
800023ca:	5b 25       	cp.w	r5,-14
800023cc:	64 5d       	ld.w	sp,r2[0x14]
800023ce:	3a 20       	mov	r0,-94
800023d0:	25 58       	sub	r8,85
800023d2:	20 0a       	sub	r10,0
800023d4:	0d 00       	ld.w	r0,r6++
800023d6:	00 00       	add	r0,r0
800023d8:	0a 0d       	add	sp,r5
800023da:	20 53       	sub	r3,5
800023dc:	74 61       	ld.w	r1,r10[0x18]
800023de:	74 65       	ld.w	r5,r10[0x18]
800023e0:	3a 20       	mov	r0,-94
800023e2:	30 78       	mov	r8,7
800023e4:	20 25       	sub	r5,2
800023e6:	58 20       	cp.w	r0,2
800023e8:	0a 0d       	add	sp,r5
800023ea:	00 00       	add	r0,r0
800023ec:	0a 0d       	add	sp,r5
800023ee:	20 42       	sub	r2,4
800023f0:	75 74       	ld.w	r4,r10[0x5c]
800023f2:	74 6f       	ld.w	pc,r10[0x18]
800023f4:	6e 5f       	ld.w	pc,r7[0x14]
800023f6:	43 6f       	lddsp	pc,sp[0xd8]
800023f8:	6e 66       	ld.w	r6,r7[0x18]
800023fa:	69 67       	ld.w	r7,r4[0x58]
800023fc:	20 4f       	sub	pc,4
800023fe:	4b 20       	lddpc	r0,800024c4 <program_start+0x4bc>
80002400:	0a 0d       	add	sp,r5
80002402:	00 00       	add	r0,r0
80002404:	0a 0d       	add	sp,r5
80002406:	20 46       	sub	r6,4
80002408:	75 6e       	ld.w	lr,r10[0x58]
8000240a:	63 74       	ld.w	r4,r1[0x5c]
8000240c:	69 6f       	ld.w	pc,r4[0x58]
8000240e:	6e 3a       	ld.w	r10,r7[0xc]
80002410:	20 25       	sub	r5,2
80002412:	58 20       	cp.w	r0,2
80002414:	0a 0d       	add	sp,r5
80002416:	00 00       	add	r0,r0
80002418:	0a 0d       	add	sp,r5
8000241a:	20 42       	sub	r2,4
8000241c:	75 74       	ld.w	r4,r10[0x5c]
8000241e:	74 6f       	ld.w	pc,r10[0x18]
80002420:	6e 5f       	ld.w	pc,r7[0x14]
80002422:	52 65       	stdsp	sp[0x98],r5
80002424:	71 75       	ld.w	r5,r8[0x5c]
80002426:	65 73       	ld.w	r3,r2[0x5c]
80002428:	74 20       	ld.w	r0,r10[0x8]
8000242a:	65 72       	ld.w	r2,r2[0x5c]
8000242c:	72 6f       	ld.w	pc,r9[0x18]
8000242e:	72 20       	ld.w	r0,r9[0x8]
80002430:	0a 0d       	add	sp,r5
80002432:	00 00       	add	r0,r0
80002434:	0a 0d       	add	sp,r5
80002436:	20 50       	sub	r0,5
80002438:	68 79       	ld.w	r9,r4[0x1c]
8000243a:	73 69       	ld.w	r9,r9[0x58]
8000243c:	63 61       	ld.w	r1,r1[0x58]
8000243e:	6c 55       	ld.w	r5,r6[0x14]
80002440:	73 65       	ld.w	r5,r9[0x58]
80002442:	72 49       	ld.w	r9,r9[0x10]
80002444:	6e 70       	ld.w	r0,r7[0x1c]
80002446:	75 74       	ld.w	r4,r10[0x5c]
80002448:	5f 62       	srmi	r2
8000244a:	72 6f       	ld.w	pc,r9[0x18]
8000244c:	61 64       	ld.w	r4,r0[0x58]
8000244e:	63 61       	ld.w	r1,r1[0x58]
80002450:	73 74       	ld.w	r4,r9[0x5c]
80002452:	20 20       	sub	r0,2
80002454:	0a 0d       	add	sp,r5
80002456:	00 00       	add	r0,r0
80002458:	0a 0d       	add	sp,r5
8000245a:	20 50       	sub	r0,5
8000245c:	55 49       	stdsp	sp[0x150],r9
8000245e:	5f 53       	srlt	r3
80002460:	6f 75       	ld.w	r5,r7[0x5c]
80002462:	72 63       	ld.w	r3,r9[0x18]
80002464:	65 3a       	ld.w	r10,r2[0x4c]
80002466:	20 25       	sub	r5,2
80002468:	58 20       	cp.w	r0,2
8000246a:	0a 0d       	add	sp,r5
8000246c:	00 00       	add	r0,r0
8000246e:	00 00       	add	r0,r0
80002470:	0a 0d       	add	sp,r5
80002472:	20 50       	sub	r0,5
80002474:	55 49       	stdsp	sp[0x150],r9
80002476:	5f 54       	srlt	r4
80002478:	79 70       	ld.w	r0,r12[0x5c]
8000247a:	65 3a       	ld.w	r10,r2[0x4c]
8000247c:	20 25       	sub	r5,2
8000247e:	58 20       	cp.w	r0,2
80002480:	0a 0d       	add	sp,r5
80002482:	00 00       	add	r0,r0
80002484:	0a 0d       	add	sp,r5
80002486:	20 50       	sub	r0,5
80002488:	55 49       	stdsp	sp[0x150],r9
8000248a:	5f 49       	srge	r9
8000248c:	44 3a       	lddsp	r10,sp[0x10c]
8000248e:	20 25       	sub	r5,2
80002490:	58 20       	cp.w	r0,2
80002492:	0a 0d       	add	sp,r5
80002494:	00 00       	add	r0,r0
80002496:	00 00       	add	r0,r0
80002498:	0a 0d       	add	sp,r5
8000249a:	20 50       	sub	r0,5
8000249c:	55 49       	stdsp	sp[0x150],r9
8000249e:	5f 53       	srlt	r3
800024a0:	74 61       	ld.w	r1,r10[0x18]
800024a2:	74 65       	ld.w	r5,r10[0x18]
800024a4:	3a 20       	mov	r0,-94
800024a6:	25 58       	sub	r8,85
800024a8:	20 0a       	sub	r10,0
800024aa:	0d 00       	ld.w	r0,r6++
800024ac:	0a 0d       	add	sp,r5
800024ae:	20 50       	sub	r0,5
800024b0:	55 49       	stdsp	sp[0x150],r9
800024b2:	5f 53       	srlt	r3
800024b4:	74 61       	ld.w	r1,r10[0x18]
800024b6:	74 65       	ld.w	r5,r10[0x18]
800024b8:	5f 4d       	srge	sp
800024ba:	69 6e       	ld.w	lr,r4[0x58]
800024bc:	5f 56       	srlt	r6
800024be:	61 6c       	ld.w	r12,r0[0x58]
800024c0:	75 65       	ld.w	r5,r10[0x58]
800024c2:	3a 20       	mov	r0,-94
800024c4:	25 58       	sub	r8,85
800024c6:	20 0a       	sub	r10,0
800024c8:	0d 00       	ld.w	r0,r6++
800024ca:	00 00       	add	r0,r0
800024cc:	0a 0d       	add	sp,r5
800024ce:	20 50       	sub	r0,5
800024d0:	55 49       	stdsp	sp[0x150],r9
800024d2:	5f 53       	srlt	r3
800024d4:	74 61       	ld.w	r1,r10[0x18]
800024d6:	74 65       	ld.w	r5,r10[0x18]
800024d8:	5f 4d       	srge	sp
800024da:	61 78       	ld.w	r8,r0[0x5c]
800024dc:	5f 56       	srlt	r6
800024de:	61 6c       	ld.w	r12,r0[0x58]
800024e0:	75 65       	ld.w	r5,r10[0x58]
800024e2:	3a 20       	mov	r0,-94
800024e4:	25 58       	sub	r8,85
800024e6:	20 0a       	sub	r10,0
800024e8:	0d 00       	ld.w	r0,r6++
800024ea:	00 00       	add	r0,r0
800024ec:	0a 0d       	add	sp,r5
800024ee:	20 42       	sub	r2,4
800024f0:	75 74       	ld.w	r4,r10[0x5c]
800024f2:	74 6f       	ld.w	pc,r10[0x18]
800024f4:	6e 43       	ld.w	r3,r7[0x10]
800024f6:	6f 6e       	ld.w	lr,r7[0x58]
800024f8:	66 69       	ld.w	r9,r3[0x18]
800024fa:	67 5f       	ld.w	pc,r3[0x54]
800024fc:	62 72       	ld.w	r2,r1[0x1c]
800024fe:	6f 61       	ld.w	r1,r7[0x58]
80002500:	64 63       	ld.w	r3,r2[0x18]
80002502:	61 73       	ld.w	r3,r0[0x5c]
80002504:	74 20       	ld.w	r0,r10[0x8]
80002506:	20 0a       	sub	r10,0
80002508:	0d 00       	ld.w	r0,r6++
8000250a:	00 00       	add	r0,r0
8000250c:	0a 0d       	add	sp,r5
8000250e:	20 4e       	sub	lr,4
80002510:	75 6d       	ld.w	sp,r10[0x58]
80002512:	4f 66       	lddpc	r6,800026e8 <program_start+0x6e0>
80002514:	42 75       	lddsp	r5,sp[0x9c]
80002516:	74 74       	ld.w	r4,r10[0x1c]
80002518:	6f 6e       	ld.w	lr,r7[0x58]
8000251a:	73 3a       	ld.w	r10,r9[0x4c]
8000251c:	20 25       	sub	r5,2
8000251e:	64 20       	ld.w	r0,r2[0x8]
80002520:	0a 0d       	add	sp,r5
80002522:	00 00       	add	r0,r0
80002524:	0a 0d       	add	sp,r5
80002526:	20 42       	sub	r2,4
80002528:	75 74       	ld.w	r4,r10[0x5c]
8000252a:	74 6f       	ld.w	pc,r10[0x18]
8000252c:	6e 49       	ld.w	r9,r7[0x10]
8000252e:	6e 66       	ld.w	r6,r7[0x18]
80002530:	6f 53       	ld.w	r3,r7[0x54]
80002532:	74 72       	ld.w	r2,r10[0x1c]
80002534:	75 63       	ld.w	r3,r10[0x58]
80002536:	74 53       	ld.w	r3,r10[0x14]
80002538:	69 7a       	ld.w	r10,r4[0x5c]
8000253a:	65 3a       	ld.w	r10,r2[0x4c]
8000253c:	20 25       	sub	r5,2
8000253e:	78 20       	ld.w	r0,r12[0x8]
80002540:	0a 0d       	add	sp,r5
80002542:	00 00       	add	r0,r0
80002544:	0a 0d       	add	sp,r5
80002546:	20 42       	sub	r2,4
80002548:	75 74       	ld.w	r4,r10[0x5c]
8000254a:	74 6f       	ld.w	pc,r10[0x18]
8000254c:	6e 49       	ld.w	r9,r7[0x10]
8000254e:	6e 66       	ld.w	r6,r7[0x18]
80002550:	6f 5b       	ld.w	r11,r7[0x54]
80002552:	25 64       	sub	r4,86
80002554:	5d 2e       	mustr	lr
80002556:	42 74       	lddsp	r4,sp[0x9c]
80002558:	5f 49       	srge	r9
8000255a:	64 65       	ld.w	r5,r2[0x18]
8000255c:	6e 74       	ld.w	r4,r7[0x1c]
8000255e:	69 66       	ld.w	r6,r4[0x58]
80002560:	69 65       	ld.w	r5,r4[0x58]
80002562:	72 3a       	ld.w	r10,r9[0xc]
80002564:	20 25       	sub	r5,2
80002566:	78 20       	ld.w	r0,r12[0x8]
80002568:	0a 0d       	add	sp,r5
8000256a:	00 00       	add	r0,r0
8000256c:	0a 0d       	add	sp,r5
8000256e:	20 42       	sub	r2,4
80002570:	75 74       	ld.w	r4,r10[0x5c]
80002572:	74 6f       	ld.w	pc,r10[0x18]
80002574:	6e 49       	ld.w	r9,r7[0x10]
80002576:	6e 66       	ld.w	r6,r7[0x18]
80002578:	6f 5b       	ld.w	r11,r7[0x54]
8000257a:	25 64       	sub	r4,86
8000257c:	5d 2e       	mustr	lr
8000257e:	53 5f       	stdsp	sp[0xd4],pc
80002580:	50 72       	stdsp	sp[0x1c],r2
80002582:	65 73       	ld.w	r3,r2[0x5c]
80002584:	73 46       	ld.w	r6,r9[0x50]
80002586:	65 61       	ld.w	r1,r2[0x58]
80002588:	74 75       	ld.w	r5,r10[0x1c]
8000258a:	72 65       	ld.w	r5,r9[0x18]
8000258c:	3a 20       	mov	r0,-94
8000258e:	25 78       	sub	r8,87
80002590:	20 0a       	sub	r10,0
80002592:	0d 00       	ld.w	r0,r6++
80002594:	0a 0d       	add	sp,r5
80002596:	20 42       	sub	r2,4
80002598:	75 74       	ld.w	r4,r10[0x5c]
8000259a:	74 6f       	ld.w	pc,r10[0x18]
8000259c:	6e 49       	ld.w	r9,r7[0x10]
8000259e:	6e 66       	ld.w	r6,r7[0x18]
800025a0:	6f 5b       	ld.w	r11,r7[0x54]
800025a2:	25 64       	sub	r4,86
800025a4:	5d 2e       	mustr	lr
800025a6:	52 65       	stdsp	sp[0x98],r5
800025a8:	73 65       	ld.w	r5,r9[0x58]
800025aa:	72 76       	ld.w	r6,r9[0x1c]
800025ac:	65 64       	ld.w	r4,r2[0x58]
800025ae:	31 3a       	mov	r10,19
800025b0:	20 25       	sub	r5,2
800025b2:	78 20       	ld.w	r0,r12[0x8]
800025b4:	0a 0d       	add	sp,r5
800025b6:	00 00       	add	r0,r0
800025b8:	0a 0d       	add	sp,r5
800025ba:	20 42       	sub	r2,4
800025bc:	75 74       	ld.w	r4,r10[0x5c]
800025be:	74 6f       	ld.w	pc,r10[0x18]
800025c0:	6e 49       	ld.w	r9,r7[0x10]
800025c2:	6e 66       	ld.w	r6,r7[0x18]
800025c4:	6f 5b       	ld.w	r11,r7[0x54]
800025c6:	25 64       	sub	r4,86
800025c8:	5d 2e       	mustr	lr
800025ca:	4c 5f       	lddpc	pc,800026dc <program_start+0x6d4>
800025cc:	50 72       	stdsp	sp[0x1c],r2
800025ce:	65 73       	ld.w	r3,r2[0x5c]
800025d0:	73 46       	ld.w	r6,r9[0x50]
800025d2:	65 61       	ld.w	r1,r2[0x58]
800025d4:	74 75       	ld.w	r5,r10[0x1c]
800025d6:	72 65       	ld.w	r5,r9[0x18]
800025d8:	3a 20       	mov	r0,-94
800025da:	25 78       	sub	r8,87
800025dc:	20 0a       	sub	r10,0
800025de:	0d 00       	ld.w	r0,r6++
800025e0:	0a 0d       	add	sp,r5
800025e2:	20 42       	sub	r2,4
800025e4:	75 74       	ld.w	r4,r10[0x5c]
800025e6:	74 6f       	ld.w	pc,r10[0x18]
800025e8:	6e 49       	ld.w	r9,r7[0x10]
800025ea:	6e 66       	ld.w	r6,r7[0x18]
800025ec:	6f 5b       	ld.w	r11,r7[0x54]
800025ee:	25 64       	sub	r4,86
800025f0:	5d 2e       	mustr	lr
800025f2:	52 65       	stdsp	sp[0x98],r5
800025f4:	73 65       	ld.w	r5,r9[0x58]
800025f6:	72 76       	ld.w	r6,r9[0x1c]
800025f8:	65 64       	ld.w	r4,r2[0x58]
800025fa:	32 3a       	mov	r10,35
800025fc:	20 25       	sub	r5,2
800025fe:	78 20       	ld.w	r0,r12[0x8]
80002600:	0a 0d       	add	sp,r5
80002602:	00 00       	add	r0,r0
80002604:	0a 0d       	add	sp,r5
80002606:	20 44       	sub	r4,4
80002608:	4d 52       	lddpc	r2,8000275c <DeviceInitializationStatus_brdcst_func+0x30>
8000260a:	5f 43       	srge	r3
8000260c:	53 42       	stdsp	sp[0xd0],r2
8000260e:	4b 20       	lddpc	r0,800026d4 <program_start+0x6cc>
80002610:	4f 4b       	lddpc	r11,800027e0 <ToneControl_reply_func>
80002612:	20 0a       	sub	r10,0
80002614:	0d 00       	ld.w	r0,r6++
80002616:	00 00       	add	r0,r0
80002618:	0a 0d       	add	sp,r5
8000261a:	20 45       	sub	r5,4
8000261c:	6e 5f       	ld.w	pc,r7[0x14]
8000261e:	4f 42       	lddpc	r2,800027ec <ToneControl_reply_func+0xc>
80002620:	5f 45       	srge	r5
80002622:	6e 74       	ld.w	r4,r7[0x1c]
80002624:	65 72       	ld.w	r2,r2[0x5c]
80002626:	20 4f       	sub	pc,4
80002628:	4b 20       	lddpc	r0,800026f0 <program_start+0x6e8>
8000262a:	0a 0d       	add	sp,r5
8000262c:	00 00       	add	r0,r0
8000262e:	00 00       	add	r0,r0
80002630:	0a 0d       	add	sp,r5
80002632:	20 45       	sub	r5,4
80002634:	6e 5f       	ld.w	pc,r7[0x14]
80002636:	4f 42       	lddpc	r2,80002804 <ToneControl_reply_func+0x24>
80002638:	5f 45       	srge	r5
8000263a:	78 69       	ld.w	r9,r12[0x18]
8000263c:	74 20       	ld.w	r0,r10[0x8]
8000263e:	4f 4b       	lddpc	r11,8000280c <ToneControl_reply_func+0x2c>
80002640:	20 0a       	sub	r10,0
80002642:	0d 00       	ld.w	r0,r6++
80002644:	0a 0d       	add	sp,r5
80002646:	20 45       	sub	r5,4
80002648:	6e 5f       	ld.w	pc,r7[0x14]
8000264a:	4f 42       	lddpc	r2,80002818 <dcm_reply_func>
8000264c:	5f 43       	srge	r3
8000264e:	6f 6e       	ld.w	lr,r7[0x58]
80002650:	74 72       	ld.w	r2,r10[0x1c]
80002652:	6f 6c       	ld.w	r12,r7[0x58]
80002654:	3a 20       	mov	r0,-94
80002656:	25 78       	sub	r8,87
80002658:	20 0a       	sub	r10,0
8000265a:	0d 00       	ld.w	r0,r6++
8000265c:	0a 0d       	add	sp,r5
8000265e:	20 45       	sub	r5,4
80002660:	6e 5f       	ld.w	pc,r7[0x14]
80002662:	4f 42       	lddpc	r2,80002830 <dcm_reply_func+0x18>
80002664:	5f 43       	srge	r3
80002666:	6f 6e       	ld.w	lr,r7[0x58]
80002668:	74 72       	ld.w	r2,r10[0x1c]
8000266a:	6f 6c       	ld.w	r12,r7[0x58]
8000266c:	20 65       	sub	r5,6
8000266e:	72 72       	ld.w	r2,r9[0x1c]
80002670:	6f 72       	ld.w	r2,r7[0x5c]
80002672:	20 0a       	sub	r10,0
80002674:	0d 00       	ld.w	r0,r6++
80002676:	00 00       	add	r0,r0
80002678:	0a 0d       	add	sp,r5
8000267a:	20 45       	sub	r5,4
8000267c:	6e 5f       	ld.w	pc,r7[0x14]
8000267e:	4f 42       	lddpc	r2,8000284c <dcm_reply_func+0x34>
80002680:	5f 72       	srpl	r2
80002682:	65 73       	ld.w	r3,r2[0x5c]
80002684:	75 6c       	ld.w	r12,r10[0x58]
80002686:	74 3a       	ld.w	r10,r10[0xc]
80002688:	20 25       	sub	r5,2
8000268a:	78 20       	ld.w	r0,r12[0x8]
8000268c:	0a 0d       	add	sp,r5
8000268e:	00 00       	add	r0,r0
80002690:	0a 0d       	add	sp,r5
80002692:	20 45       	sub	r5,4
80002694:	6e 5f       	ld.w	pc,r7[0x14]
80002696:	4f 42       	lddpc	r2,80002864 <dcm_reply_func+0x4c>
80002698:	20 42       	sub	r2,4
8000269a:	72 6f       	ld.w	pc,r9[0x18]
8000269c:	61 64       	ld.w	r4,r0[0x58]
8000269e:	63 61       	ld.w	r1,r1[0x58]
800026a0:	73 74       	ld.w	r4,r9[0x5c]
800026a2:	20 0a       	sub	r10,0
800026a4:	0d 00       	ld.w	r0,r6++
800026a6:	00 00       	add	r0,r0
800026a8:	0a 0d       	add	sp,r5
800026aa:	20 46       	sub	r6,4
800026ac:	6f 72       	ld.w	r2,r7[0x5c]
800026ae:	77 61       	ld.w	r1,r11[0x58]
800026b0:	72 64       	ld.w	r4,r9[0x18]
800026b2:	20 44       	sub	r4,4
800026b4:	61 74       	ld.w	r4,r0[0x5c]
800026b6:	61 20       	ld.w	r0,r0[0x48]
800026b8:	52 65       	stdsp	sp[0x98],r5
800026ba:	71 75       	ld.w	r5,r8[0x5c]
800026bc:	65 73       	ld.w	r3,r2[0x5c]
800026be:	74 20       	ld.w	r0,r10[0x8]
800026c0:	0a 0d       	add	sp,r5
800026c2:	00 00       	add	r0,r0
800026c4:	0a 0d       	add	sp,r5
800026c6:	20 46       	sub	r6,4
800026c8:	6f 72       	ld.w	r2,r7[0x5c]
800026ca:	77 61       	ld.w	r1,r11[0x58]
800026cc:	72 64       	ld.w	r4,r9[0x18]
800026ce:	20 44       	sub	r4,4
800026d0:	61 74       	ld.w	r4,r0[0x5c]
800026d2:	61 20       	ld.w	r0,r0[0x48]
800026d4:	52 65       	stdsp	sp[0x98],r5
800026d6:	70 6c       	ld.w	r12,r8[0x18]
800026d8:	79 20       	ld.w	r0,r12[0x48]
800026da:	0a 0d       	add	sp,r5
800026dc:	00 00       	add	r0,r0
800026de:	00 00       	add	r0,r0
800026e0:	0a 0d       	add	sp,r5
800026e2:	20 46       	sub	r6,4
800026e4:	6f 72       	ld.w	r2,r7[0x5c]
800026e6:	77 61       	ld.w	r1,r11[0x58]
800026e8:	72 64       	ld.w	r4,r9[0x18]
800026ea:	20 44       	sub	r4,4
800026ec:	61 74       	ld.w	r4,r0[0x5c]
800026ee:	61 20       	ld.w	r0,r0[0x48]
800026f0:	42 72       	lddsp	r2,sp[0x9c]
800026f2:	6f 61       	ld.w	r1,r7[0x58]
800026f4:	64 63       	ld.w	r3,r2[0x18]
800026f6:	61 73       	ld.w	r3,r0[0x5c]
800026f8:	74 20       	ld.w	r0,r10[0x8]
800026fa:	0a 0d       	add	sp,r5
800026fc:	00 00       	add	r0,r0
800026fe:	00 00       	add	r0,r0
80002700:	58 4e       	cp.w	lr,4
80002702:	4c 5f       	lddpc	pc,80002814 <ToneControl_reply_func+0x34>
80002704:	54 58       	stdsp	sp[0x114],r8
80002706:	00 00       	add	r0,r0
80002708:	0a 0d       	add	sp,r5
8000270a:	20 63       	sub	r3,6
8000270c:	6f 75       	ld.w	r5,r7[0x5c]
8000270e:	6e 74       	ld.w	r4,r7[0x1c]
80002710:	65 72       	ld.w	r2,r2[0x5c]
80002712:	3a 20       	mov	r0,-94
80002714:	25 64       	sub	r4,86
80002716:	20 0a       	sub	r10,0
80002718:	0d 00       	ld.w	r0,r6++
8000271a:	00 00       	add	r0,r0
8000271c:	0a 0d       	add	sp,r5
8000271e:	20 77       	sub	r7,7
80002720:	3a 20       	mov	r0,-94
80002722:	0a 0d       	add	sp,r5
80002724:	00 00       	add	r0,r0
80002726:	00 00       	add	r0,r0
80002728:	52 00       	stdsp	sp[0x80],r0
	...

8000272c <DeviceInitializationStatus_brdcst_func>:
static void app_payload_tx_proc(void  * payload);

//app func--list

void DeviceInitializationStatus_brdcst_func(xcmp_fragment_t  * xcmp)
{
8000272c:	eb cd 40 80 	pushm	r7,lr
80002730:	1a 97       	mov	r7,sp
80002732:	20 1d       	sub	sp,4
80002734:	ef 4c ff fc 	st.w	r7[-4],r12
	if (xcmp->u8[4] == 0x01)
80002738:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000273c:	11 e9       	ld.ub	r9,r8[0x6]
8000273e:	30 18       	mov	r8,1
80002740:	f0 09 18 00 	cp.b	r9,r8
80002744:	c0 81       	brne	80002754 <DeviceInitializationStatus_brdcst_func+0x28>
	{
		bunchofrandomstatusflags |= 0x01;  //Need do nothing else.
80002746:	48 e8       	lddpc	r8,8000277c <DeviceInitializationStatus_brdcst_func+0x50>
80002748:	70 08       	ld.w	r8,r8[0x0]
8000274a:	10 99       	mov	r9,r8
8000274c:	a1 a9       	sbr	r9,0x0
8000274e:	48 c8       	lddpc	r8,8000277c <DeviceInitializationStatus_brdcst_func+0x50>
80002750:	91 09       	st.w	r8[0x0],r9
80002752:	c1 18       	rjmp	80002774 <DeviceInitializationStatus_brdcst_func+0x48>
	}
	else if(xcmp->u8[4] != 0x02)
80002754:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002758:	11 e9       	ld.ub	r9,r8[0x6]
8000275a:	30 28       	mov	r8,2
8000275c:	f0 09 18 00 	cp.b	r9,r8
80002760:	c0 a0       	breq	80002774 <DeviceInitializationStatus_brdcst_func+0x48>
	{
		bunchofrandomstatusflags  &= 0xFFFFFFFC; //Device Init no longer Complete.
80002762:	48 78       	lddpc	r8,8000277c <DeviceInitializationStatus_brdcst_func+0x50>
80002764:	70 08       	ld.w	r8,r8[0x0]
80002766:	10 99       	mov	r9,r8
80002768:	e0 19 ff fc 	andl	r9,0xfffc
8000276c:	48 48       	lddpc	r8,8000277c <DeviceInitializationStatus_brdcst_func+0x50>
8000276e:	91 09       	st.w	r8[0x0],r9
		xcmp_DeviceInitializationStatus_request();
80002770:	f0 1f 00 04 	mcall	80002780 <DeviceInitializationStatus_brdcst_func+0x54>
	}
}
80002774:	2f fd       	sub	sp,-4
80002776:	e3 cd 80 80 	ldm	sp++,r7,pc
8000277a:	00 00       	add	r0,r0
8000277c:	00 00       	add	r0,r0
8000277e:	0d a0       	ld.ub	r0,r6[0x2]
80002780:	80 00       	ld.sh	r0,r0[0x0]
80002782:	6b 74       	ld.w	r4,r5[0x5c]

80002784 <DeviceManagement_brdcst_func>:

void DeviceManagement_brdcst_func(xcmp_fragment_t * xcmp)
{
80002784:	eb cd 40 80 	pushm	r7,lr
80002788:	1a 97       	mov	r7,sp
8000278a:	20 2d       	sub	sp,8
8000278c:	ef 4c ff f8 	st.w	r7[-8],r12
		U8 temp = 0;
80002790:	30 08       	mov	r8,0
80002792:	ef 68 ff ff 	st.b	r7[-1],r8
		temp  = xcmp->u8[1] << 8;
80002796:	30 08       	mov	r8,0
80002798:	ef 68 ff ff 	st.b	r7[-1],r8
		temp |= xcmp->u8[2];
8000279c:	ee f8 ff f8 	ld.w	r8,r7[-8]
800027a0:	11 c9       	ld.ub	r9,r8[0x4]
800027a2:	ef 38 ff ff 	ld.ub	r8,r7[-1]
800027a6:	f3 e8 10 08 	or	r8,r9,r8
800027aa:	ef 68 ff ff 	st.b	r7[-1],r8
		//if (temp == theXNL_Ctrlr.XNL_DeviceLogicalAddress)
		{
			if (xcmp->u8[0] == 0x01)
800027ae:	ee f8 ff f8 	ld.w	r8,r7[-8]
800027b2:	11 a9       	ld.ub	r9,r8[0x2]
800027b4:	30 18       	mov	r8,1
800027b6:	f0 09 18 00 	cp.b	r9,r8
800027ba:	c0 81       	brne	800027ca <DeviceManagement_brdcst_func+0x46>
			{
				bunchofrandomstatusflags |= 0x00000002;
800027bc:	48 88       	lddpc	r8,800027dc <DeviceManagement_brdcst_func+0x58>
800027be:	70 08       	ld.w	r8,r8[0x0]
800027c0:	10 99       	mov	r9,r8
800027c2:	a1 b9       	sbr	r9,0x1
800027c4:	48 68       	lddpc	r8,800027dc <DeviceManagement_brdcst_func+0x58>
800027c6:	91 09       	st.w	r8[0x0],r9
800027c8:	c0 78       	rjmp	800027d6 <DeviceManagement_brdcst_func+0x52>
			}
			else
			{
				bunchofrandomstatusflags &= 0xFFFFFFFD;
800027ca:	48 58       	lddpc	r8,800027dc <DeviceManagement_brdcst_func+0x58>
800027cc:	70 08       	ld.w	r8,r8[0x0]
800027ce:	10 99       	mov	r9,r8
800027d0:	a1 d9       	cbr	r9,0x1
800027d2:	48 38       	lddpc	r8,800027dc <DeviceManagement_brdcst_func+0x58>
800027d4:	91 09       	st.w	r8[0x0],r9
			}
		}
}
800027d6:	2f ed       	sub	sp,-8
800027d8:	e3 cd 80 80 	ldm	sp++,r7,pc
800027dc:	00 00       	add	r0,r0
800027de:	0d a0       	ld.ub	r0,r6[0x2]

800027e0 <ToneControl_reply_func>:

void ToneControl_reply_func(xcmp_fragment_t * xcmp)
{
800027e0:	eb cd 40 80 	pushm	r7,lr
800027e4:	1a 97       	mov	r7,sp
800027e6:	20 1d       	sub	sp,4
800027e8:	ef 4c ff fc 	st.w	r7[-4],r12
	if (xcmp->u8[0] == xcmp_Res_Success)
800027ec:	ee f8 ff fc 	ld.w	r8,r7[-4]
800027f0:	11 a8       	ld.ub	r8,r8[0x2]
800027f2:	58 08       	cp.w	r8,0
800027f4:	c0 51       	brne	800027fe <ToneControl_reply_func+0x1e>
	{		
		log("Tone OK");
800027f6:	48 6c       	lddpc	r12,8000280c <ToneControl_reply_func+0x2c>
800027f8:	f0 1f 00 06 	mcall	80002810 <ToneControl_reply_func+0x30>
800027fc:	c0 48       	rjmp	80002804 <ToneControl_reply_func+0x24>
		//fl_write("/test.txt", FILE_END, (void *)"send tone ok\r\n", sizeof("send tone ok\r\n") - 1);
	}
	else
	{
		log("Tone error");
800027fe:	48 6c       	lddpc	r12,80002814 <ToneControl_reply_func+0x34>
80002800:	f0 1f 00 04 	mcall	80002810 <ToneControl_reply_func+0x30>
	}
}
80002804:	2f fd       	sub	sp,-4
80002806:	e3 cd 80 80 	ldm	sp++,r7,pc
8000280a:	00 00       	add	r0,r0
8000280c:	80 00       	ld.sh	r0,r0[0x0]
8000280e:	20 10       	sub	r0,1
80002810:	80 00       	ld.sh	r0,r0[0x0]
80002812:	a8 70       	st.h	r4[0xe],r0
80002814:	80 00       	ld.sh	r0,r0[0x0]
80002816:	20 18       	sub	r8,1

80002818 <dcm_reply_func>:

void dcm_reply_func(xcmp_fragment_t * xcmp)
{
80002818:	eb cd 40 80 	pushm	r7,lr
8000281c:	1a 97       	mov	r7,sp
8000281e:	20 1d       	sub	sp,4
80002820:	ef 4c ff fc 	st.w	r7[-4],r12
	if (xcmp->u8[0] == xcmp_Res_Success)
80002824:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002828:	11 a8       	ld.ub	r8,r8[0x2]
8000282a:	58 08       	cp.w	r8,0
8000282c:	c2 11       	brne	8000286e <dcm_reply_func+0x56>
	{
		if(xcmp->u8[1] == DCM_ENTER)
8000282e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002832:	11 b9       	ld.ub	r9,r8[0x3]
80002834:	30 18       	mov	r8,1
80002836:	f0 09 18 00 	cp.b	r9,r8
8000283a:	c0 51       	brne	80002844 <dcm_reply_func+0x2c>
		{
			log("\n\r Dcm-Enter OK \n\r");
8000283c:	49 0c       	lddpc	r12,8000287c <dcm_reply_func+0x64>
8000283e:	f0 1f 00 11 	mcall	80002880 <dcm_reply_func+0x68>
80002842:	c0 d8       	rjmp	8000285c <dcm_reply_func+0x44>
			
		}
		else if (xcmp->u8[1] == DCM_EXIT)
80002844:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002848:	11 b8       	ld.ub	r8,r8[0x3]
8000284a:	58 08       	cp.w	r8,0
8000284c:	c0 51       	brne	80002856 <dcm_reply_func+0x3e>
		{
			log("\n\r Dcm-Exit OK \n\r");
8000284e:	48 ec       	lddpc	r12,80002884 <dcm_reply_func+0x6c>
80002850:	f0 1f 00 0c 	mcall	80002880 <dcm_reply_func+0x68>
80002854:	c0 48       	rjmp	8000285c <dcm_reply_func+0x44>
		}
		else
		{
			log("\n\r Dcm-Revoke \n\r");
80002856:	48 dc       	lddpc	r12,80002888 <dcm_reply_func+0x70>
80002858:	f0 1f 00 0a 	mcall	80002880 <dcm_reply_func+0x68>
		}
		
		log("dcm OK-mo%X", xcmp->u8[3]);
8000285c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002860:	11 d8       	ld.ub	r8,r8[0x5]
80002862:	1a d8       	st.w	--sp,r8
80002864:	48 ac       	lddpc	r12,8000288c <dcm_reply_func+0x74>
80002866:	f0 1f 00 07 	mcall	80002880 <dcm_reply_func+0x68>
8000286a:	2f fd       	sub	sp,-4
8000286c:	c0 48       	rjmp	80002874 <dcm_reply_func+0x5c>
	}
	else
	{
		log("dcm error");
8000286e:	48 9c       	lddpc	r12,80002890 <dcm_reply_func+0x78>
80002870:	f0 1f 00 04 	mcall	80002880 <dcm_reply_func+0x68>
	}
}
80002874:	2f fd       	sub	sp,-4
80002876:	e3 cd 80 80 	ldm	sp++,r7,pc
8000287a:	00 00       	add	r0,r0
8000287c:	80 00       	ld.sh	r0,r0[0x0]
8000287e:	20 24       	sub	r4,2
80002880:	80 00       	ld.sh	r0,r0[0x0]
80002882:	a8 70       	st.h	r4[0xe],r0
80002884:	80 00       	ld.sh	r0,r0[0x0]
80002886:	20 38       	sub	r8,3
80002888:	80 00       	ld.sh	r0,r0[0x0]
8000288a:	20 4c       	sub	r12,4
8000288c:	80 00       	ld.sh	r0,r0[0x0]
8000288e:	20 60       	sub	r0,6
80002890:	80 00       	ld.sh	r0,r0[0x0]
80002892:	20 6c       	sub	r12,6

80002894 <dcm_brdcst_func>:


void dcm_brdcst_func(xcmp_fragment_t * xcmp)
{
80002894:	eb cd 40 80 	pushm	r7,lr
80002898:	1a 97       	mov	r7,sp
8000289a:	20 2d       	sub	sp,8
8000289c:	ef 4c ff f8 	st.w	r7[-8],r12
	
	/*point to xcmp payload*/
	DeviceControlMode_brdcst_t *ptr = (DeviceControlMode_brdcst_t* )xcmp->u8;
800028a0:	ee f8 ff f8 	ld.w	r8,r7[-8]
800028a4:	2f e8       	sub	r8,-2
800028a6:	ef 48 ff fc 	st.w	r7[-4],r8
	
	log("\n\r Dcm_brdcst \n\r");		
800028aa:	49 0c       	lddpc	r12,800028e8 <dcm_brdcst_func+0x54>
800028ac:	f0 1f 00 10 	mcall	800028ec <dcm_brdcst_func+0x58>
	log("\n\r Function: %x \n\r " ,  ptr->Function);
800028b0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800028b4:	11 88       	ld.ub	r8,r8[0x0]
800028b6:	1a d8       	st.w	--sp,r8
800028b8:	48 ec       	lddpc	r12,800028f0 <dcm_brdcst_func+0x5c>
800028ba:	f0 1f 00 0d 	mcall	800028ec <dcm_brdcst_func+0x58>
800028be:	2f fd       	sub	sp,-4
	log("\n\r ControlType: %x \n\r " ,  ptr->ControlType);
800028c0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800028c4:	11 a8       	ld.ub	r8,r8[0x2]
800028c6:	1a d8       	st.w	--sp,r8
800028c8:	48 bc       	lddpc	r12,800028f4 <dcm_brdcst_func+0x60>
800028ca:	f0 1f 00 09 	mcall	800028ec <dcm_brdcst_func+0x58>
800028ce:	2f fd       	sub	sp,-4
	log("\n\r ControlTypeSize: %x \n\r " ,  ptr->ControlTypeSize);
800028d0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800028d4:	11 98       	ld.ub	r8,r8[0x1]
800028d6:	1a d8       	st.w	--sp,r8
800028d8:	48 8c       	lddpc	r12,800028f8 <dcm_brdcst_func+0x64>
800028da:	f0 1f 00 05 	mcall	800028ec <dcm_brdcst_func+0x58>
800028de:	2f fd       	sub	sp,-4
	
	
}
800028e0:	2f ed       	sub	sp,-8
800028e2:	e3 cd 80 80 	ldm	sp++,r7,pc
800028e6:	00 00       	add	r0,r0
800028e8:	80 00       	ld.sh	r0,r0[0x0]
800028ea:	20 78       	sub	r8,7
800028ec:	80 00       	ld.sh	r0,r0[0x0]
800028ee:	a8 70       	st.h	r4[0xe],r0
800028f0:	80 00       	ld.sh	r0,r0[0x0]
800028f2:	20 8c       	sub	r12,8
800028f4:	80 00       	ld.sh	r0,r0[0x0]
800028f6:	20 a0       	sub	r0,10
800028f8:	80 00       	ld.sh	r0,r0[0x0]
800028fa:	20 b8       	sub	r8,11

800028fc <mic_reply_func>:

void mic_reply_func(xcmp_fragment_t * xcmp)
{
800028fc:	eb cd 40 80 	pushm	r7,lr
80002900:	1a 97       	mov	r7,sp
80002902:	20 2d       	sub	sp,8
80002904:	ef 4c ff f8 	st.w	r7[-8],r12
	/*point to xcmp payload*/
	MicControl_reply_t *ptr = (MicControl_reply_t* )xcmp->u8;
80002908:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000290c:	2f e8       	sub	r8,-2
8000290e:	ef 48 ff fc 	st.w	r7[-4],r8
	
	log("\n\r Mic_reply \n\r");
80002912:	4a 2c       	lddpc	r12,80002998 <mic_reply_func+0x9c>
80002914:	f0 1f 00 22 	mcall	8000299c <mic_reply_func+0xa0>
	if (ptr->Result == 0x00)
80002918:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000291c:	11 88       	ld.ub	r8,r8[0x0]
8000291e:	58 08       	cp.w	r8,0
80002920:	c3 51       	brne	8000298a <mic_reply_func+0x8e>
	{
		
		if (ptr->Function == Mic_Disable)
80002922:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002926:	11 99       	ld.ub	r9,r8[0x1]
80002928:	30 28       	mov	r8,2
8000292a:	f0 09 18 00 	cp.b	r9,r8
8000292e:	c2 51       	brne	80002978 <mic_reply_func+0x7c>
		{
		
			log("\n\r Mic_close_ok \n\r " );
80002930:	49 cc       	lddpc	r12,800029a0 <mic_reply_func+0xa4>
80002932:	f0 1f 00 1b 	mcall	8000299c <mic_reply_func+0xa0>
			log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
80002936:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000293a:	11 a8       	ld.ub	r8,r8[0x2]
8000293c:	1a d8       	st.w	--sp,r8
8000293e:	49 ac       	lddpc	r12,800029a4 <mic_reply_func+0xa8>
80002940:	f0 1f 00 17 	mcall	8000299c <mic_reply_func+0xa0>
80002944:	2f fd       	sub	sp,-4
			log("\n\r Signaling_type: %x \n\r " ,  ptr->Signaling_Type);
80002946:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000294a:	11 b8       	ld.ub	r8,r8[0x3]
8000294c:	1a d8       	st.w	--sp,r8
8000294e:	49 7c       	lddpc	r12,800029a8 <mic_reply_func+0xac>
80002950:	f0 1f 00 13 	mcall	8000299c <mic_reply_func+0xa0>
80002954:	2f fd       	sub	sp,-4
			log("\n\r Mic_state: %x \n\r " ,  ptr->Mic_State);
80002956:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000295a:	11 c8       	ld.ub	r8,r8[0x4]
8000295c:	1a d8       	st.w	--sp,r8
8000295e:	49 4c       	lddpc	r12,800029ac <mic_reply_func+0xb0>
80002960:	f0 1f 00 0f 	mcall	8000299c <mic_reply_func+0xa0>
80002964:	2f fd       	sub	sp,-4
			log("\n\r Gain_offset: %x \n\r " ,  ptr->Gain_Offset);
80002966:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000296a:	11 d8       	ld.ub	r8,r8[0x5]
8000296c:	1a d8       	st.w	--sp,r8
8000296e:	49 1c       	lddpc	r12,800029b0 <mic_reply_func+0xb4>
80002970:	f0 1f 00 0b 	mcall	8000299c <mic_reply_func+0xa0>
80002974:	2f fd       	sub	sp,-4
80002976:	c0 d8       	rjmp	80002990 <mic_reply_func+0x94>
			
		}
		else
		{
			log("\n\r Mic_function: %x \n\r ", ptr->Function );
80002978:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000297c:	11 98       	ld.ub	r8,r8[0x1]
8000297e:	1a d8       	st.w	--sp,r8
80002980:	48 dc       	lddpc	r12,800029b4 <mic_reply_func+0xb8>
80002982:	f0 1f 00 07 	mcall	8000299c <mic_reply_func+0xa0>
80002986:	2f fd       	sub	sp,-4
80002988:	c0 48       	rjmp	80002990 <mic_reply_func+0x94>
	}
	else 
	{
		
	
		log("\n\r Mic error \n\r");
8000298a:	48 cc       	lddpc	r12,800029b8 <mic_reply_func+0xbc>
8000298c:	f0 1f 00 04 	mcall	8000299c <mic_reply_func+0xa0>
		
	}
	
	
	
}
80002990:	2f ed       	sub	sp,-8
80002992:	e3 cd 80 80 	ldm	sp++,r7,pc
80002996:	00 00       	add	r0,r0
80002998:	80 00       	ld.sh	r0,r0[0x0]
8000299a:	20 d4       	sub	r4,13
8000299c:	80 00       	ld.sh	r0,r0[0x0]
8000299e:	a8 70       	st.h	r4[0xe],r0
800029a0:	80 00       	ld.sh	r0,r0[0x0]
800029a2:	20 e4       	sub	r4,14
800029a4:	80 00       	ld.sh	r0,r0[0x0]
800029a6:	20 f8       	sub	r8,15
800029a8:	80 00       	ld.sh	r0,r0[0x0]
800029aa:	21 0c       	sub	r12,16
800029ac:	80 00       	ld.sh	r0,r0[0x0]
800029ae:	21 28       	sub	r8,18
800029b0:	80 00       	ld.sh	r0,r0[0x0]
800029b2:	21 40       	sub	r0,20
800029b4:	80 00       	ld.sh	r0,r0[0x0]
800029b6:	21 58       	sub	r8,21
800029b8:	80 00       	ld.sh	r0,r0[0x0]
800029ba:	21 70       	sub	r0,23

800029bc <mic_brdcst_func>:

void mic_brdcst_func(xcmp_fragment_t * xcmp)
{
800029bc:	eb cd 40 80 	pushm	r7,lr
800029c0:	1a 97       	mov	r7,sp
800029c2:	20 2d       	sub	sp,8
800029c4:	ef 4c ff f8 	st.w	r7[-8],r12
	/*point to xcmp payload*/
	MicControl_brdcast_t *ptr = (MicControl_brdcast_t* )xcmp->u8;
800029c8:	ee f8 ff f8 	ld.w	r8,r7[-8]
800029cc:	2f e8       	sub	r8,-2
800029ce:	ef 48 ff fc 	st.w	r7[-4],r8
	//log("\n\r Mic_brdcst \n\r");		
	//log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
	//log("\n\r Signal_type: %x \n\r " ,  ptr->Signaling_Type);
	if (ptr->Mic_State == 0x00)
800029d2:	ee f8 ff fc 	ld.w	r8,r7[-4]
800029d6:	11 a8       	ld.ub	r8,r8[0x2]
800029d8:	58 08       	cp.w	r8,0
800029da:	c0 71       	brne	800029e8 <mic_brdcst_func+0x2c>
	{
		log("\n\r Mic_Disabled \n\r");	
800029dc:	49 0c       	lddpc	r12,80002a1c <mic_brdcst_func+0x60>
800029de:	f0 1f 00 11 	mcall	80002a20 <mic_brdcst_func+0x64>
		Mic_is_Enabled = 0;
800029e2:	49 19       	lddpc	r9,80002a24 <mic_brdcst_func+0x68>
800029e4:	30 08       	mov	r8,0
800029e6:	b2 88       	st.b	r9[0x0],r8
	} 
	if(ptr->Mic_State == 0x11)
800029e8:	ee f8 ff fc 	ld.w	r8,r7[-4]
800029ec:	11 a9       	ld.ub	r9,r8[0x2]
800029ee:	31 18       	mov	r8,17
800029f0:	f0 09 18 00 	cp.b	r9,r8
800029f4:	c1 11       	brne	80002a16 <mic_brdcst_func+0x5a>
	{
		log("\n\r Mic_Enabled \n\r");
800029f6:	48 dc       	lddpc	r12,80002a28 <mic_brdcst_func+0x6c>
800029f8:	f0 1f 00 0a 	mcall	80002a20 <mic_brdcst_func+0x64>
		Mic_is_Enabled = 1;
800029fc:	48 a9       	lddpc	r9,80002a24 <mic_brdcst_func+0x68>
800029fe:	30 18       	mov	r8,1
80002a00:	b2 88       	st.b	r9[0x0],r8
		
		if ((Mic_is_Enabled == 1) && (Call_Begin == 1))
80002a02:	48 98       	lddpc	r8,80002a24 <mic_brdcst_func+0x68>
80002a04:	11 88       	ld.ub	r8,r8[0x0]
80002a06:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
80002a0a:	30 18       	mov	r8,1
80002a0c:	f0 09 18 00 	cp.b	r9,r8
80002a10:	c0 31       	brne	80002a16 <mic_brdcst_func+0x5a>
80002a12:	48 78       	lddpc	r8,80002a2c <mic_brdcst_func+0x70>
80002a14:	11 88       	ld.ub	r8,r8[0x0]
	}
	//log("\n\r Mic_state: %x \n\r " ,  ptr->Mic_State);
	//log("\n\r Gain_offset: %x \n\r " ,  ptr->Gain_Offset);
			
	
}
80002a16:	2f ed       	sub	sp,-8
80002a18:	e3 cd 80 80 	ldm	sp++,r7,pc
80002a1c:	80 00       	ld.sh	r0,r0[0x0]
80002a1e:	21 80       	sub	r0,24
80002a20:	80 00       	ld.sh	r0,r0[0x0]
80002a22:	a8 70       	st.h	r4[0xe],r0
80002a24:	00 00       	add	r0,r0
80002a26:	0a 5d       	eor	sp,r5
80002a28:	80 00       	ld.sh	r0,r0[0x0]
80002a2a:	21 94       	sub	r4,25
80002a2c:	00 00       	add	r0,r0
80002a2e:	0a 5e       	eor	lr,r5

80002a30 <spk_reply_func>:

void spk_reply_func(xcmp_fragment_t * xcmp)
{
80002a30:	eb cd 40 80 	pushm	r7,lr
80002a34:	1a 97       	mov	r7,sp
80002a36:	20 1d       	sub	sp,4
80002a38:	ef 4c ff fc 	st.w	r7[-4],r12
	if (xcmp->u8[0] == xcmp_Res_Success)
80002a3c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002a40:	11 a8       	ld.ub	r8,r8[0x2]
80002a42:	58 08       	cp.w	r8,0
80002a44:	c1 21       	brne	80002a68 <spk_reply_func+0x38>
	{
		
		if(xcmp->u8[4])
80002a46:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002a4a:	11 e8       	ld.ub	r8,r8[0x6]
80002a4c:	58 08       	cp.w	r8,0
80002a4e:	c0 40       	breq	80002a56 <spk_reply_func+0x26>
		{
			Speaker_is_unmute = 1;
80002a50:	48 b9       	lddpc	r9,80002a7c <spk_reply_func+0x4c>
80002a52:	30 18       	mov	r8,1
80002a54:	b2 88       	st.b	r9[0x0],r8
			
			//Silent_flag = 1;
		}
		log("spk OK -st%2x", xcmp->u8[4] );
80002a56:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002a5a:	11 e8       	ld.ub	r8,r8[0x6]
80002a5c:	1a d8       	st.w	--sp,r8
80002a5e:	48 9c       	lddpc	r12,80002a80 <spk_reply_func+0x50>
80002a60:	f0 1f 00 09 	mcall	80002a84 <spk_reply_func+0x54>
80002a64:	2f fd       	sub	sp,-4
80002a66:	c0 78       	rjmp	80002a74 <spk_reply_func+0x44>
		
	}
	else
	{
		Speaker_is_unmute = 0;
80002a68:	48 59       	lddpc	r9,80002a7c <spk_reply_func+0x4c>
80002a6a:	30 08       	mov	r8,0
80002a6c:	b2 88       	st.b	r9[0x0],r8
		log("spk error");
80002a6e:	48 7c       	lddpc	r12,80002a88 <spk_reply_func+0x58>
80002a70:	f0 1f 00 05 	mcall	80002a84 <spk_reply_func+0x54>
	}
}
80002a74:	2f fd       	sub	sp,-4
80002a76:	e3 cd 80 80 	ldm	sp++,r7,pc
80002a7a:	00 00       	add	r0,r0
80002a7c:	00 00       	add	r0,r0
80002a7e:	0a 58       	eor	r8,r5
80002a80:	80 00       	ld.sh	r0,r0[0x0]
80002a82:	21 a8       	sub	r8,26
80002a84:	80 00       	ld.sh	r0,r0[0x0]
80002a86:	a8 70       	st.h	r4[0xe],r0
80002a88:	80 00       	ld.sh	r0,r0[0x0]
80002a8a:	21 b8       	sub	r8,27

80002a8c <spk_brdcst_func>:

void spk_brdcst_func(xcmp_fragment_t * xcmp)
{
80002a8c:	eb cd 40 80 	pushm	r7,lr
80002a90:	1a 97       	mov	r7,sp
80002a92:	20 1d       	sub	sp,4
80002a94:	ef 4c ff fc 	st.w	r7[-4],r12
	if (xcmp->u8[3] == xcmp_Res_Success)//0x0000:mute
80002a98:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002a9c:	11 d8       	ld.ub	r8,r8[0x5]
80002a9e:	58 08       	cp.w	r8,0
80002aa0:	c0 81       	brne	80002ab0 <spk_brdcst_func+0x24>
	{
		Speaker_is_unmute =0;
80002aa2:	48 99       	lddpc	r9,80002ac4 <spk_brdcst_func+0x38>
80002aa4:	30 08       	mov	r8,0
80002aa6:	b2 88       	st.b	r9[0x0],r8
		//Silent_flag = 0;
		log("spk_s_close ");
80002aa8:	48 8c       	lddpc	r12,80002ac8 <spk_brdcst_func+0x3c>
80002aaa:	f0 1f 00 09 	mcall	80002acc <spk_brdcst_func+0x40>
80002aae:	c0 78       	rjmp	80002abc <spk_brdcst_func+0x30>
		
	}
	else
	{
		//Silent_flag = 1;
		Speaker_is_unmute = 1;
80002ab0:	48 59       	lddpc	r9,80002ac4 <spk_brdcst_func+0x38>
80002ab2:	30 18       	mov	r8,1
80002ab4:	b2 88       	st.b	r9[0x0],r8
		log("spk_s_open ");	
80002ab6:	48 7c       	lddpc	r12,80002ad0 <spk_brdcst_func+0x44>
80002ab8:	f0 1f 00 05 	mcall	80002acc <spk_brdcst_func+0x40>
	}
	
	
	
	
}
80002abc:	2f fd       	sub	sp,-4
80002abe:	e3 cd 80 80 	ldm	sp++,r7,pc
80002ac2:	00 00       	add	r0,r0
80002ac4:	00 00       	add	r0,r0
80002ac6:	0a 58       	eor	r8,r5
80002ac8:	80 00       	ld.sh	r0,r0[0x0]
80002aca:	21 c4       	sub	r4,28
80002acc:	80 00       	ld.sh	r0,r0[0x0]
80002ace:	a8 70       	st.h	r4[0xe],r0
80002ad0:	80 00       	ld.sh	r0,r0[0x0]
80002ad2:	21 d4       	sub	r4,29

80002ad4 <Volume_reply_func>:


void Volume_reply_func(xcmp_fragment_t * xcmp)
{
80002ad4:	eb cd 40 80 	pushm	r7,lr
80002ad8:	1a 97       	mov	r7,sp
80002ada:	20 2d       	sub	sp,8
80002adc:	ef 4c ff f8 	st.w	r7[-8],r12
	
	/*point to xcmp payload*/
	VolumeControl_reply_t *ptr = (VolumeControl_reply_t* )xcmp->u8;
80002ae0:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002ae4:	2f e8       	sub	r8,-2
80002ae6:	ef 48 ff fc 	st.w	r7[-4],r8
	
		if (ptr->Result == xcmp_Res_Success)
80002aea:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002aee:	11 88       	ld.ub	r8,r8[0x0]
80002af0:	58 08       	cp.w	r8,0
80002af2:	c2 41       	brne	80002b3a <Volume_reply_func+0x66>
		{
			if (ptr->Function == Enable_IntelligentAudio)
80002af4:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002af8:	11 b9       	ld.ub	r9,r8[0x3]
80002afa:	31 08       	mov	r8,16
80002afc:	f0 09 18 00 	cp.b	r9,r8
80002b00:	c1 41       	brne	80002b28 <Volume_reply_func+0x54>
			{
				log("\n\r Enable_IA OK \n\r");
80002b02:	49 2c       	lddpc	r12,80002b48 <Volume_reply_func+0x74>
80002b04:	f0 1f 00 12 	mcall	80002b4c <Volume_reply_func+0x78>
				log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
80002b08:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002b0c:	11 98       	ld.ub	r8,r8[0x1]
80002b0e:	f0 09 15 08 	lsl	r9,r8,0x8
80002b12:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002b16:	11 a8       	ld.ub	r8,r8[0x2]
80002b18:	f3 e8 10 08 	or	r8,r9,r8
80002b1c:	1a d8       	st.w	--sp,r8
80002b1e:	48 dc       	lddpc	r12,80002b50 <Volume_reply_func+0x7c>
80002b20:	f0 1f 00 0b 	mcall	80002b4c <Volume_reply_func+0x78>
80002b24:	2f fd       	sub	sp,-4
80002b26:	c0 d8       	rjmp	80002b40 <Volume_reply_func+0x6c>
	
			}
			else
			{
				
				log("\n\r VolumeControl: %x \n\r", ptr->Function);
80002b28:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002b2c:	11 b8       	ld.ub	r8,r8[0x3]
80002b2e:	1a d8       	st.w	--sp,r8
80002b30:	48 9c       	lddpc	r12,80002b54 <Volume_reply_func+0x80>
80002b32:	f0 1f 00 07 	mcall	80002b4c <Volume_reply_func+0x78>
80002b36:	2f fd       	sub	sp,-4
80002b38:	c0 48       	rjmp	80002b40 <Volume_reply_func+0x6c>
			
		}
		
		else
		{
			log("\n\r Enable_IA error \n\r");
80002b3a:	48 8c       	lddpc	r12,80002b58 <Volume_reply_func+0x84>
80002b3c:	f0 1f 00 04 	mcall	80002b4c <Volume_reply_func+0x78>
		}
	
	
	
}
80002b40:	2f ed       	sub	sp,-8
80002b42:	e3 cd 80 80 	ldm	sp++,r7,pc
80002b46:	00 00       	add	r0,r0
80002b48:	80 00       	ld.sh	r0,r0[0x0]
80002b4a:	21 e0       	sub	r0,30
80002b4c:	80 00       	ld.sh	r0,r0[0x0]
80002b4e:	a8 70       	st.h	r4[0xe],r0
80002b50:	80 00       	ld.sh	r0,r0[0x0]
80002b52:	21 f4       	sub	r4,31
80002b54:	80 00       	ld.sh	r0,r0[0x0]
80002b56:	22 10       	sub	r0,33
80002b58:	80 00       	ld.sh	r0,r0[0x0]
80002b5a:	22 28       	sub	r8,34

80002b5c <Volume_brdcst_func>:

void Volume_brdcst_func(xcmp_fragment_t * xcmp)
{
80002b5c:	eb cd 40 80 	pushm	r7,lr
80002b60:	1a 97       	mov	r7,sp
80002b62:	20 2d       	sub	sp,8
80002b64:	ef 4c ff f8 	st.w	r7[-8],r12
	/*point to xcmp payload*/
	VolumeControl_brdcst_t *ptr = (VolumeControl_brdcst_t* )xcmp->u8;
80002b68:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002b6c:	2f e8       	sub	r8,-2
80002b6e:	ef 48 ff fc 	st.w	r7[-4],r8
	//log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
	
	//log("\n\r Audio_Parameter: %x \n\r", ptr->Audio_Parameter);
	
	
}
80002b72:	2f ed       	sub	sp,-8
80002b74:	e3 cd 80 80 	ldm	sp++,r7,pc

80002b78 <AudioRoutingControl_reply_func>:


void AudioRoutingControl_reply_func(xcmp_fragment_t * xcmp)
{
80002b78:	eb cd 40 80 	pushm	r7,lr
80002b7c:	1a 97       	mov	r7,sp
80002b7e:	20 1d       	sub	sp,4
80002b80:	ef 4c ff fc 	st.w	r7[-4],r12
	if (xcmp->u8[0] == xcmp_Res_Success)
80002b84:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002b88:	11 a8       	ld.ub	r8,r8[0x2]
80002b8a:	58 08       	cp.w	r8,0
80002b8c:	c0 71       	brne	80002b9a <AudioRoutingControl_reply_func+0x22>
	{
		log("AudioRouting OK");
80002b8e:	48 7c       	lddpc	r12,80002ba8 <AudioRoutingControl_reply_func+0x30>
80002b90:	f0 1f 00 07 	mcall	80002bac <AudioRoutingControl_reply_func+0x34>
		xcmp_IdleTestTone();//
80002b94:	f0 1f 00 07 	mcall	80002bb0 <AudioRoutingControl_reply_func+0x38>
80002b98:	c0 48       	rjmp	80002ba0 <AudioRoutingControl_reply_func+0x28>
		//xcmp_IdleTestTone();
		//Speaker_is_unmute = 1;
	}
	else
	{
		log("AudioRouting error");
80002b9a:	48 7c       	lddpc	r12,80002bb4 <AudioRoutingControl_reply_func+0x3c>
80002b9c:	f0 1f 00 04 	mcall	80002bac <AudioRoutingControl_reply_func+0x34>
		//log("\n\r AudioRouting result: %x \n\r", xcmp->u8[0]);
		
	}
}
80002ba0:	2f fd       	sub	sp,-4
80002ba2:	e3 cd 80 80 	ldm	sp++,r7,pc
80002ba6:	00 00       	add	r0,r0
80002ba8:	80 00       	ld.sh	r0,r0[0x0]
80002baa:	22 40       	sub	r0,36
80002bac:	80 00       	ld.sh	r0,r0[0x0]
80002bae:	a8 70       	st.h	r4[0xe],r0
80002bb0:	80 00       	ld.sh	r0,r0[0x0]
80002bb2:	6b f0       	ld.w	r0,r5[0x7c]
80002bb4:	80 00       	ld.sh	r0,r0[0x0]
80002bb6:	22 50       	sub	r0,37

80002bb8 <AudioRoutingControl_brdcst_func>:


void AudioRoutingControl_brdcst_func(xcmp_fragment_t * xcmp)
{
80002bb8:	eb cd 40 80 	pushm	r7,lr
80002bbc:	1a 97       	mov	r7,sp
80002bbe:	20 2d       	sub	sp,8
80002bc0:	ef 4c ff f8 	st.w	r7[-8],r12
	
	U16 num_routings = 0;
80002bc4:	30 08       	mov	r8,0
80002bc6:	ef 58 ff fc 	st.h	r7[-4],r8
	U8 j = 0 ;
80002bca:	30 08       	mov	r8,0
80002bcc:	ef 68 ff ff 	st.b	r7[-1],r8
	
	num_routings = ((xcmp->u8[0]<< 8) | (xcmp->u8[1]) );
80002bd0:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002bd4:	11 a8       	ld.ub	r8,r8[0x2]
80002bd6:	a9 68       	lsl	r8,0x8
80002bd8:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
80002bdc:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002be0:	11 b8       	ld.ub	r8,r8[0x3]
80002be2:	f3 e8 10 08 	or	r8,r9,r8
80002be6:	5c 88       	casts.h	r8
80002be8:	ef 58 ff fc 	st.h	r7[-4],r8
	//
	//log("\n\r Audio-Function: %x \n\r", xcmp->u8[3+j*2-1]);
	
	
	
}
80002bec:	2f ed       	sub	sp,-8
80002bee:	e3 cd 80 80 	ldm	sp++,r7,pc
80002bf2:	d7 03       	nop

80002bf4 <TransmitControl_reply_func>:




void TransmitControl_reply_func(xcmp_fragment_t * xcmp)
{
80002bf4:	eb cd 40 80 	pushm	r7,lr
80002bf8:	1a 97       	mov	r7,sp
80002bfa:	20 2d       	sub	sp,8
80002bfc:	ef 4c ff f8 	st.w	r7[-8],r12
	/*point to xcmp payload*/
	TransmitControl_reply_t *ptr = (TransmitControl_reply_t* )xcmp->u8;
80002c00:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002c04:	2f e8       	sub	r8,-2
80002c06:	ef 48 ff fc 	st.w	r7[-4],r8
	
	if (ptr->Result == xcmp_Res_Success)
80002c0a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002c0e:	11 88       	ld.ub	r8,r8[0x0]
80002c10:	58 08       	cp.w	r8,0
80002c12:	c1 d1       	brne	80002c4c <TransmitControl_reply_func+0x58>
	{
		
		log("\n\r  TransmitControl OK \n\r ");
80002c14:	49 1c       	lddpc	r12,80002c58 <TransmitControl_reply_func+0x64>
80002c16:	f0 1f 00 12 	mcall	80002c5c <TransmitControl_reply_func+0x68>
		log("\n\r Function: %x \n\r", ptr->Function);
80002c1a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002c1e:	11 98       	ld.ub	r8,r8[0x1]
80002c20:	1a d8       	st.w	--sp,r8
80002c22:	49 0c       	lddpc	r12,80002c60 <TransmitControl_reply_func+0x6c>
80002c24:	f0 1f 00 0e 	mcall	80002c5c <TransmitControl_reply_func+0x68>
80002c28:	2f fd       	sub	sp,-4
		log("\n\r Mode of Operation: %x \n\r", ptr->Mode_Of_Operation);
80002c2a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002c2e:	11 a8       	ld.ub	r8,r8[0x2]
80002c30:	1a d8       	st.w	--sp,r8
80002c32:	48 dc       	lddpc	r12,80002c64 <TransmitControl_reply_func+0x70>
80002c34:	f0 1f 00 0a 	mcall	80002c5c <TransmitControl_reply_func+0x68>
80002c38:	2f fd       	sub	sp,-4
		log("\n\r State: %x \n\r", ptr->State);
80002c3a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002c3e:	11 b8       	ld.ub	r8,r8[0x3]
80002c40:	1a d8       	st.w	--sp,r8
80002c42:	48 ac       	lddpc	r12,80002c68 <TransmitControl_reply_func+0x74>
80002c44:	f0 1f 00 06 	mcall	80002c5c <TransmitControl_reply_func+0x68>
80002c48:	2f fd       	sub	sp,-4
80002c4a:	c0 48       	rjmp	80002c52 <TransmitControl_reply_func+0x5e>
		
		//Silent_flag = 1;
	}
	else
	{
		log("TransmitControl error");
80002c4c:	48 8c       	lddpc	r12,80002c6c <TransmitControl_reply_func+0x78>
80002c4e:	f0 1f 00 04 	mcall	80002c5c <TransmitControl_reply_func+0x68>
	}
	

}
80002c52:	2f ed       	sub	sp,-8
80002c54:	e3 cd 80 80 	ldm	sp++,r7,pc
80002c58:	80 00       	ld.sh	r0,r0[0x0]
80002c5a:	22 64       	sub	r4,38
80002c5c:	80 00       	ld.sh	r0,r0[0x0]
80002c5e:	a8 70       	st.h	r4[0xe],r0
80002c60:	80 00       	ld.sh	r0,r0[0x0]
80002c62:	22 80       	sub	r0,40
80002c64:	80 00       	ld.sh	r0,r0[0x0]
80002c66:	22 94       	sub	r4,41
80002c68:	80 00       	ld.sh	r0,r0[0x0]
80002c6a:	22 b0       	sub	r0,43
80002c6c:	80 00       	ld.sh	r0,r0[0x0]
80002c6e:	22 c0       	sub	r0,44

80002c70 <TransmitControl_brdcst_func>:


void TransmitControl_brdcst_func(xcmp_fragment_t * xcmp)
{
80002c70:	eb cd 40 80 	pushm	r7,lr
80002c74:	1a 97       	mov	r7,sp
80002c76:	20 2d       	sub	sp,8
80002c78:	ef 4c ff f8 	st.w	r7[-8],r12
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	TransmitControl_brdcast_t *ptr = (TransmitControl_brdcast_t* )xcmp->u8;
80002c7c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002c80:	2f e8       	sub	r8,-2
80002c82:	ef 48 ff fc 	st.w	r7[-4],r8
	//log("\n\r  TransmitControl broadcast \n\r ");
	//log("\n\r  Mode_Of_Operation: %x \n\r ", ptr->Mode_Of_Operation );
	if (ptr->State == 0x00)
80002c86:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002c8a:	11 98       	ld.ub	r8,r8[0x1]
80002c8c:	58 08       	cp.w	r8,0
80002c8e:	c0 71       	brne	80002c9c <TransmitControl_brdcst_func+0x2c>
	{
		log("\n\r  Standby-Receive \n\r ");
80002c90:	48 bc       	lddpc	r12,80002cbc <TransmitControl_brdcst_func+0x4c>
80002c92:	f0 1f 00 0c 	mcall	80002cc0 <TransmitControl_brdcst_func+0x50>
		Radio_Transmit_State = 0;
80002c96:	48 c9       	lddpc	r9,80002cc4 <TransmitControl_brdcst_func+0x54>
80002c98:	30 08       	mov	r8,0
80002c9a:	b2 88       	st.b	r9[0x0],r8
	}
	if (ptr->State == 0x01)
80002c9c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002ca0:	11 99       	ld.ub	r9,r8[0x1]
80002ca2:	30 18       	mov	r8,1
80002ca4:	f0 09 18 00 	cp.b	r9,r8
80002ca8:	c0 71       	brne	80002cb6 <TransmitControl_brdcst_func+0x46>
	{
		log("\n\r  Transmit \n\r ");
80002caa:	48 8c       	lddpc	r12,80002cc8 <TransmitControl_brdcst_func+0x58>
80002cac:	f0 1f 00 05 	mcall	80002cc0 <TransmitControl_brdcst_func+0x50>
		Radio_Transmit_State = 1;
80002cb0:	48 59       	lddpc	r9,80002cc4 <TransmitControl_brdcst_func+0x54>
80002cb2:	30 18       	mov	r8,1
80002cb4:	b2 88       	st.b	r9[0x0],r8
	//log("\n\r  State: %x \n\r ", ptr->State );
	//log("\n\r  State_change_reason: %x \n\r ", ptr->State_change_reason );
	//
	
	
}
80002cb6:	2f ed       	sub	sp,-8
80002cb8:	e3 cd 80 80 	ldm	sp++,r7,pc
80002cbc:	80 00       	ld.sh	r0,r0[0x0]
80002cbe:	22 d8       	sub	r8,45
80002cc0:	80 00       	ld.sh	r0,r0[0x0]
80002cc2:	a8 70       	st.h	r4[0xe],r0
80002cc4:	00 00       	add	r0,r0
80002cc6:	0a 5c       	eor	r12,r5
80002cc8:	80 00       	ld.sh	r0,r0[0x0]
80002cca:	22 f0       	sub	r0,47

80002ccc <CallControl_brdcst_func>:


void CallControl_brdcst_func(xcmp_fragment_t * xcmp)
{
80002ccc:	eb cd 40 80 	pushm	r7,lr
80002cd0:	1a 97       	mov	r7,sp
80002cd2:	20 2d       	sub	sp,8
80002cd4:	ef 4c ff f8 	st.w	r7[-8],r12
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	CallControl_brdcst_t *ptr = (CallControl_brdcst_t* )xcmp->u8;
80002cd8:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002cdc:	2f e8       	sub	r8,-2
80002cde:	ef 48 ff fc 	st.w	r7[-4],r8
	//log("\n\r  CallControl brst \n\r ");
	//log("\n\r  Call_type: %x \n\r ", ptr->Calltype );
	log("\n\r  Call_state: %x \n\r ", ptr->Callstate );
80002ce2:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002ce6:	11 98       	ld.ub	r8,r8[0x1]
80002ce8:	1a d8       	st.w	--sp,r8
80002cea:	48 ec       	lddpc	r12,80002d20 <CallControl_brdcst_func+0x54>
80002cec:	f0 1f 00 0e 	mcall	80002d24 <CallControl_brdcst_func+0x58>
80002cf0:	2f fd       	sub	sp,-4
	if (ptr->Callstate == Call_Ended)//0x03
80002cf2:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002cf6:	11 99       	ld.ub	r9,r8[0x1]
80002cf8:	30 38       	mov	r8,3
80002cfa:	f0 09 18 00 	cp.b	r9,r8
80002cfe:	c0 41       	brne	80002d06 <CallControl_brdcst_func+0x3a>
	{
		//
		//xcmp_audio_route_revert();
		Call_Begin = 0;
80002d00:	48 a9       	lddpc	r9,80002d28 <CallControl_brdcst_func+0x5c>
80002d02:	30 08       	mov	r8,0
80002d04:	b2 88       	st.b	r9[0x0],r8
		
	}
	
	if (ptr->Callstate == Call_Initiated)//0x04
80002d06:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002d0a:	11 99       	ld.ub	r9,r8[0x1]
80002d0c:	30 48       	mov	r8,4
80002d0e:	f0 09 18 00 	cp.b	r9,r8
80002d12:	c0 41       	brne	80002d1a <CallControl_brdcst_func+0x4e>
	{
		Call_Begin = 1;
80002d14:	48 59       	lddpc	r9,80002d28 <CallControl_brdcst_func+0x5c>
80002d16:	30 18       	mov	r8,1
80002d18:	b2 88       	st.b	r9[0x0],r8
		//xcmp_audio_route_decoder_AMBE();

	}
	
	
}
80002d1a:	2f ed       	sub	sp,-8
80002d1c:	e3 cd 80 80 	ldm	sp++,r7,pc
80002d20:	80 00       	ld.sh	r0,r0[0x0]
80002d22:	23 04       	sub	r4,48
80002d24:	80 00       	ld.sh	r0,r0[0x0]
80002d26:	a8 70       	st.h	r4[0xe],r0
80002d28:	00 00       	add	r0,r0
80002d2a:	0a 5e       	eor	lr,r5

80002d2c <DataSession_reply_func>:



void DataSession_reply_func(xcmp_fragment_t * xcmp)
{
80002d2c:	eb cd 40 80 	pushm	r7,lr
80002d30:	1a 97       	mov	r7,sp
80002d32:	20 1d       	sub	sp,4
80002d34:	ef 4c ff fc 	st.w	r7[-4],r12
	if (xcmp->u8[0] == xcmp_Res_Success)
80002d38:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002d3c:	11 a8       	ld.ub	r8,r8[0x2]
80002d3e:	58 08       	cp.w	r8,0
80002d40:	c0 51       	brne	80002d4a <DataSession_reply_func+0x1e>
	{
		log("\n\r DATArep OK \n\r");
80002d42:	49 2c       	lddpc	r12,80002d88 <DataSession_reply_func+0x5c>
80002d44:	f0 1f 00 12 	mcall	80002d8c <DataSession_reply_func+0x60>
80002d48:	c1 c8       	rjmp	80002d80 <DataSession_reply_func+0x54>
		//log("\n\r ID: 0x %X \n\r", xcmp->u8[2]);
		
	}
	else
	{
		log("\n\r Result:  %X \n\r", xcmp->u8[0]);
80002d4a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002d4e:	11 a8       	ld.ub	r8,r8[0x2]
80002d50:	1a d8       	st.w	--sp,r8
80002d52:	49 0c       	lddpc	r12,80002d90 <DataSession_reply_func+0x64>
80002d54:	f0 1f 00 0e 	mcall	80002d8c <DataSession_reply_func+0x60>
80002d58:	2f fd       	sub	sp,-4
		log("\n\r DATArep error \n\r");
80002d5a:	48 fc       	lddpc	r12,80002d94 <DataSession_reply_func+0x68>
80002d5c:	f0 1f 00 0c 	mcall	80002d8c <DataSession_reply_func+0x60>
		log("\n\r Func:  %X \n\r", xcmp->u8[1]);
80002d60:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002d64:	11 b8       	ld.ub	r8,r8[0x3]
80002d66:	1a d8       	st.w	--sp,r8
80002d68:	48 cc       	lddpc	r12,80002d98 <DataSession_reply_func+0x6c>
80002d6a:	f0 1f 00 09 	mcall	80002d8c <DataSession_reply_func+0x60>
80002d6e:	2f fd       	sub	sp,-4
		log("\n\r ID:  %X \n\r", xcmp->u8[2]);
80002d70:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002d74:	11 c8       	ld.ub	r8,r8[0x4]
80002d76:	1a d8       	st.w	--sp,r8
80002d78:	48 9c       	lddpc	r12,80002d9c <DataSession_reply_func+0x70>
80002d7a:	f0 1f 00 05 	mcall	80002d8c <DataSession_reply_func+0x60>
80002d7e:	2f fd       	sub	sp,-4
	}
	
}
80002d80:	2f fd       	sub	sp,-4
80002d82:	e3 cd 80 80 	ldm	sp++,r7,pc
80002d86:	00 00       	add	r0,r0
80002d88:	80 00       	ld.sh	r0,r0[0x0]
80002d8a:	23 1c       	sub	r12,49
80002d8c:	80 00       	ld.sh	r0,r0[0x0]
80002d8e:	a8 70       	st.h	r4[0xe],r0
80002d90:	80 00       	ld.sh	r0,r0[0x0]
80002d92:	23 30       	sub	r0,51
80002d94:	80 00       	ld.sh	r0,r0[0x0]
80002d96:	23 44       	sub	r4,52
80002d98:	80 00       	ld.sh	r0,r0[0x0]
80002d9a:	23 58       	sub	r8,53
80002d9c:	80 00       	ld.sh	r0,r0[0x0]
80002d9e:	23 68       	sub	r8,54

80002da0 <DataSession_brdcst_func>:

void DataSession_brdcst_func(xcmp_fragment_t * xcmp)
{
80002da0:	eb cd 40 80 	pushm	r7,lr
80002da4:	1a 97       	mov	r7,sp
80002da6:	20 4d       	sub	sp,16
80002da8:	ef 4c ff f0 	st.w	r7[-16],r12
	U8 Session_number = 0;
80002dac:	30 08       	mov	r8,0
80002dae:	ef 68 ff f7 	st.b	r7[-9],r8
	U16 data_length = 0;
80002db2:	30 08       	mov	r8,0
80002db4:	ef 58 ff f8 	st.h	r7[-8],r8
	U8 i = 0;
80002db8:	30 08       	mov	r8,0
80002dba:	ef 68 ff fb 	st.b	r7[-5],r8
	/*point to xcmp payload*/
	DataSession_brdcst_t *ptr = (DataSession_brdcst_t* )xcmp->u8;
80002dbe:	ee f8 ff f0 	ld.w	r8,r7[-16]
80002dc2:	2f e8       	sub	r8,-2
80002dc4:	ef 48 ff fc 	st.w	r7[-4],r8

	if (ptr->State == CSBK_DATA_RX_Suc)
80002dc8:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002dcc:	11 89       	ld.ub	r9,r8[0x0]
80002dce:	32 48       	mov	r8,36
80002dd0:	f0 09 18 00 	cp.b	r9,r8
80002dd4:	c4 71       	brne	80002e62 <DataSession_brdcst_func+0xc2>
	{
		
		log("\n\r CSBK_RX OK \n\r");
80002dd6:	4a 9c       	lddpc	r12,80002e78 <DataSession_brdcst_func+0xd8>
80002dd8:	f0 1f 00 29 	mcall	80002e7c <DataSession_brdcst_func+0xdc>
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];
80002ddc:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002de0:	11 98       	ld.ub	r8,r8[0x1]
80002de2:	ef 68 ff f7 	st.b	r7[-9],r8
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
80002de6:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002dea:	11 a8       	ld.ub	r8,r8[0x2]
80002dec:	a9 68       	lsl	r8,0x8
80002dee:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
80002df2:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002df6:	11 b8       	ld.ub	r8,r8[0x3]
80002df8:	f3 e8 10 08 	or	r8,r9,r8
80002dfc:	5c 88       	casts.h	r8
80002dfe:	ef 58 ff f8 	st.h	r7[-8],r8

		log("\n\r Session_ID: %x \n\r",Session_number );
80002e02:	ef 38 ff f7 	ld.ub	r8,r7[-9]
80002e06:	1a d8       	st.w	--sp,r8
80002e08:	49 ec       	lddpc	r12,80002e80 <DataSession_brdcst_func+0xe0>
80002e0a:	f0 1f 00 1d 	mcall	80002e7c <DataSession_brdcst_func+0xdc>
80002e0e:	2f fd       	sub	sp,-4
		log("\n\r paylaod_length: %d \n\r",data_length );
80002e10:	ef 18 ff f8 	ld.uh	r8,r7[-8]
80002e14:	1a d8       	st.w	--sp,r8
80002e16:	49 cc       	lddpc	r12,80002e84 <DataSession_brdcst_func+0xe4>
80002e18:	f0 1f 00 19 	mcall	80002e7c <DataSession_brdcst_func+0xdc>
80002e1c:	2f fd       	sub	sp,-4
		for(i=0; i<data_length; i++)
80002e1e:	30 08       	mov	r8,0
80002e20:	ef 68 ff fb 	st.b	r7[-5],r8
80002e24:	c1 68       	rjmp	80002e50 <DataSession_brdcst_func+0xb0>
		{
			
			//log("\n\r payload[%d]: %X \n\r", i, xcmp->u8[4+i]);
			log("\n\r payload[%d]: %X \n\r", i, ptr->DataPayload.DataPayload[i]);
80002e26:	ef 38 ff fb 	ld.ub	r8,r7[-5]
80002e2a:	ee f9 ff fc 	ld.w	r9,r7[-4]
80002e2e:	f2 08 00 08 	add	r8,r9,r8
80002e32:	11 c8       	ld.ub	r8,r8[0x4]
80002e34:	10 99       	mov	r9,r8
80002e36:	ef 38 ff fb 	ld.ub	r8,r7[-5]
80002e3a:	1a d9       	st.w	--sp,r9
80002e3c:	1a d8       	st.w	--sp,r8
80002e3e:	49 3c       	lddpc	r12,80002e88 <DataSession_brdcst_func+0xe8>
80002e40:	f0 1f 00 0f 	mcall	80002e7c <DataSession_brdcst_func+0xdc>
80002e44:	2f ed       	sub	sp,-8
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);

		log("\n\r Session_ID: %x \n\r",Session_number );
		log("\n\r paylaod_length: %d \n\r",data_length );
		for(i=0; i<data_length; i++)
80002e46:	ef 38 ff fb 	ld.ub	r8,r7[-5]
80002e4a:	2f f8       	sub	r8,-1
80002e4c:	ef 68 ff fb 	st.b	r7[-5],r8
80002e50:	ef 38 ff fb 	ld.ub	r8,r7[-5]
80002e54:	ef 09 ff f8 	ld.sh	r9,r7[-8]
80002e58:	f0 09 19 00 	cp.h	r9,r8
80002e5c:	fe 9b ff e5 	brhi	80002e26 <DataSession_brdcst_func+0x86>
80002e60:	c0 98       	rjmp	80002e72 <DataSession_brdcst_func+0xd2>
		
	}
	else
	{
		//log("\n\r State: 0x %X \n\r", xcmp->u8[0]);
		log("\n\r State: 0x %X \n\r", ptr->State);
80002e62:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002e66:	11 88       	ld.ub	r8,r8[0x0]
80002e68:	1a d8       	st.w	--sp,r8
80002e6a:	48 9c       	lddpc	r12,80002e8c <DataSession_brdcst_func+0xec>
80002e6c:	f0 1f 00 04 	mcall	80002e7c <DataSession_brdcst_func+0xdc>
80002e70:	2f fd       	sub	sp,-4
		
	}
	
}
80002e72:	2f cd       	sub	sp,-16
80002e74:	e3 cd 80 80 	ldm	sp++,r7,pc
80002e78:	80 00       	ld.sh	r0,r0[0x0]
80002e7a:	23 78       	sub	r8,55
80002e7c:	80 00       	ld.sh	r0,r0[0x0]
80002e7e:	a8 70       	st.h	r4[0xe],r0
80002e80:	80 00       	ld.sh	r0,r0[0x0]
80002e82:	23 8c       	sub	r12,56
80002e84:	80 00       	ld.sh	r0,r0[0x0]
80002e86:	23 a4       	sub	r4,58
80002e88:	80 00       	ld.sh	r0,r0[0x0]
80002e8a:	23 c0       	sub	r0,60
80002e8c:	80 00       	ld.sh	r0,r0[0x0]
80002e8e:	23 d8       	sub	r8,61

80002e90 <ButtonConfig_reply_func>:

void ButtonConfig_reply_func(xcmp_fragment_t * xcmp)
{
80002e90:	eb cd 40 80 	pushm	r7,lr
80002e94:	1a 97       	mov	r7,sp
80002e96:	20 2d       	sub	sp,8
80002e98:	ef 4c ff f8 	st.w	r7[-8],r12
	/*point to xcmp payload*/
	ButtonConfig_reply_t *ptr = (ButtonConfig_reply_t* )(xcmp->u8);
80002e9c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002ea0:	2f e8       	sub	r8,-2
80002ea2:	ef 48 ff fc 	st.w	r7[-4],r8
	if (ptr->Result == xcmp_Res_Success)
80002ea6:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002eaa:	11 88       	ld.ub	r8,r8[0x0]
80002eac:	58 08       	cp.w	r8,0
80002eae:	c0 d1       	brne	80002ec8 <ButtonConfig_reply_func+0x38>
	{
		log("\n\r Button_Config OK \n\r");
80002eb0:	48 9c       	lddpc	r12,80002ed4 <ButtonConfig_reply_func+0x44>
80002eb2:	f0 1f 00 0a 	mcall	80002ed8 <ButtonConfig_reply_func+0x48>
		
		log("\n\r Function: %X \n\r" , ptr->Function );
80002eb6:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002eba:	11 98       	ld.ub	r8,r8[0x1]
80002ebc:	1a d8       	st.w	--sp,r8
80002ebe:	48 8c       	lddpc	r12,80002edc <ButtonConfig_reply_func+0x4c>
80002ec0:	f0 1f 00 06 	mcall	80002ed8 <ButtonConfig_reply_func+0x48>
80002ec4:	2f fd       	sub	sp,-4
80002ec6:	c0 48       	rjmp	80002ece <ButtonConfig_reply_func+0x3e>
		
	}
	
	else
	{
		log("\n\r Button_Request error \n\r");
80002ec8:	48 6c       	lddpc	r12,80002ee0 <ButtonConfig_reply_func+0x50>
80002eca:	f0 1f 00 04 	mcall	80002ed8 <ButtonConfig_reply_func+0x48>
	}
	
}
80002ece:	2f ed       	sub	sp,-8
80002ed0:	e3 cd 80 80 	ldm	sp++,r7,pc
80002ed4:	80 00       	ld.sh	r0,r0[0x0]
80002ed6:	23 ec       	sub	r12,62
80002ed8:	80 00       	ld.sh	r0,r0[0x0]
80002eda:	a8 70       	st.h	r4[0xe],r0
80002edc:	80 00       	ld.sh	r0,r0[0x0]
80002ede:	24 04       	sub	r4,64
80002ee0:	80 00       	ld.sh	r0,r0[0x0]
80002ee2:	24 18       	sub	r8,65

80002ee4 <Phyuserinput_brdcst_func>:


void Phyuserinput_brdcst_func(xcmp_fragment_t * xcmp)
{
80002ee4:	eb cd 40 80 	pushm	r7,lr
80002ee8:	1a 97       	mov	r7,sp
80002eea:	20 3d       	sub	sp,12
80002eec:	ef 4c ff f4 	st.w	r7[-12],r12
	U8 PUI_Source =0;
80002ef0:	30 08       	mov	r8,0
80002ef2:	ef 68 ff f8 	st.b	r7[-8],r8
	U8 PUI_Type =0;
80002ef6:	30 08       	mov	r8,0
80002ef8:	ef 68 ff f9 	st.b	r7[-7],r8
	U16 PUI_ID =0;
80002efc:	30 08       	mov	r8,0
80002efe:	ef 58 ff fa 	st.h	r7[-6],r8
	U8 PUI_State =0;
80002f02:	30 08       	mov	r8,0
80002f04:	ef 68 ff fd 	st.b	r7[-3],r8
	U8 PUI_State_Min_Value =0;
80002f08:	30 08       	mov	r8,0
80002f0a:	ef 68 ff fe 	st.b	r7[-2],r8
	U8 PUI_State_Max_Value =0;
80002f0e:	30 08       	mov	r8,0
80002f10:	ef 68 ff ff 	st.b	r7[-1],r8
	
	PUI_Source = xcmp->u8[0];
80002f14:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002f18:	11 a8       	ld.ub	r8,r8[0x2]
80002f1a:	ef 68 ff f8 	st.b	r7[-8],r8
	PUI_Type = xcmp ->u8[1];
80002f1e:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002f22:	11 b8       	ld.ub	r8,r8[0x3]
80002f24:	ef 68 ff f9 	st.b	r7[-7],r8
	PUI_ID = ((xcmp->u8[2]<<8) | xcmp->u8[3]);
80002f28:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002f2c:	11 c8       	ld.ub	r8,r8[0x4]
80002f2e:	a9 68       	lsl	r8,0x8
80002f30:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
80002f34:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002f38:	11 d8       	ld.ub	r8,r8[0x5]
80002f3a:	f3 e8 10 08 	or	r8,r9,r8
80002f3e:	5c 88       	casts.h	r8
80002f40:	ef 58 ff fa 	st.h	r7[-6],r8
	PUI_State = xcmp->u8[4];
80002f44:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002f48:	11 e8       	ld.ub	r8,r8[0x6]
80002f4a:	ef 68 ff fd 	st.b	r7[-3],r8
	PUI_State_Min_Value = xcmp->u8[5];
80002f4e:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002f52:	11 f8       	ld.ub	r8,r8[0x7]
80002f54:	ef 68 ff fe 	st.b	r7[-2],r8
	PUI_State_Max_Value = xcmp->u8[6];
80002f58:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002f5c:	f1 38 00 08 	ld.ub	r8,r8[8]
80002f60:	ef 68 ff ff 	st.b	r7[-1],r8
	
	log("\n\r PhysicalUserInput_broadcast  \n\r"  );
80002f64:	49 8c       	lddpc	r12,80002fc4 <Phyuserinput_brdcst_func+0xe0>
80002f66:	f0 1f 00 19 	mcall	80002fc8 <Phyuserinput_brdcst_func+0xe4>
	
	log("\n\r PUI_Source: %X \n\r" , PUI_Source);
80002f6a:	ef 38 ff f8 	ld.ub	r8,r7[-8]
80002f6e:	1a d8       	st.w	--sp,r8
80002f70:	49 7c       	lddpc	r12,80002fcc <Phyuserinput_brdcst_func+0xe8>
80002f72:	f0 1f 00 16 	mcall	80002fc8 <Phyuserinput_brdcst_func+0xe4>
80002f76:	2f fd       	sub	sp,-4
	log("\n\r PUI_Type: %X \n\r" , PUI_Type);
80002f78:	ef 38 ff f9 	ld.ub	r8,r7[-7]
80002f7c:	1a d8       	st.w	--sp,r8
80002f7e:	49 5c       	lddpc	r12,80002fd0 <Phyuserinput_brdcst_func+0xec>
80002f80:	f0 1f 00 12 	mcall	80002fc8 <Phyuserinput_brdcst_func+0xe4>
80002f84:	2f fd       	sub	sp,-4
	log("\n\r PUI_ID: %X \n\r" , PUI_ID);
80002f86:	ef 18 ff fa 	ld.uh	r8,r7[-6]
80002f8a:	1a d8       	st.w	--sp,r8
80002f8c:	49 2c       	lddpc	r12,80002fd4 <Phyuserinput_brdcst_func+0xf0>
80002f8e:	f0 1f 00 0f 	mcall	80002fc8 <Phyuserinput_brdcst_func+0xe4>
80002f92:	2f fd       	sub	sp,-4
	log("\n\r PUI_State: %X \n\r" , PUI_State);
80002f94:	ef 38 ff fd 	ld.ub	r8,r7[-3]
80002f98:	1a d8       	st.w	--sp,r8
80002f9a:	49 0c       	lddpc	r12,80002fd8 <Phyuserinput_brdcst_func+0xf4>
80002f9c:	f0 1f 00 0b 	mcall	80002fc8 <Phyuserinput_brdcst_func+0xe4>
80002fa0:	2f fd       	sub	sp,-4
	log("\n\r PUI_State_Min_Value: %X \n\r" , PUI_State_Min_Value);
80002fa2:	ef 38 ff fe 	ld.ub	r8,r7[-2]
80002fa6:	1a d8       	st.w	--sp,r8
80002fa8:	48 dc       	lddpc	r12,80002fdc <Phyuserinput_brdcst_func+0xf8>
80002faa:	f0 1f 00 08 	mcall	80002fc8 <Phyuserinput_brdcst_func+0xe4>
80002fae:	2f fd       	sub	sp,-4
	log("\n\r PUI_State_Max_Value: %X \n\r" , PUI_State_Max_Value);
80002fb0:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80002fb4:	1a d8       	st.w	--sp,r8
80002fb6:	48 bc       	lddpc	r12,80002fe0 <Phyuserinput_brdcst_func+0xfc>
80002fb8:	f0 1f 00 04 	mcall	80002fc8 <Phyuserinput_brdcst_func+0xe4>
80002fbc:	2f fd       	sub	sp,-4
	
	
	
	
	
}
80002fbe:	2f dd       	sub	sp,-12
80002fc0:	e3 cd 80 80 	ldm	sp++,r7,pc
80002fc4:	80 00       	ld.sh	r0,r0[0x0]
80002fc6:	24 34       	sub	r4,67
80002fc8:	80 00       	ld.sh	r0,r0[0x0]
80002fca:	a8 70       	st.h	r4[0xe],r0
80002fcc:	80 00       	ld.sh	r0,r0[0x0]
80002fce:	24 58       	sub	r8,69
80002fd0:	80 00       	ld.sh	r0,r0[0x0]
80002fd2:	24 70       	sub	r0,71
80002fd4:	80 00       	ld.sh	r0,r0[0x0]
80002fd6:	24 84       	sub	r4,72
80002fd8:	80 00       	ld.sh	r0,r0[0x0]
80002fda:	24 98       	sub	r8,73
80002fdc:	80 00       	ld.sh	r0,r0[0x0]
80002fde:	24 ac       	sub	r12,74
80002fe0:	80 00       	ld.sh	r0,r0[0x0]
80002fe2:	24 cc       	sub	r12,76

80002fe4 <ButtonConfig_brdcst_func>:


void ButtonConfig_brdcst_func(xcmp_fragment_t * xcmp)
{
80002fe4:	eb cd 40 80 	pushm	r7,lr
80002fe8:	1a 97       	mov	r7,sp
80002fea:	20 3d       	sub	sp,12
80002fec:	ef 4c ff f4 	st.w	r7[-12],r12
	U8 Num_Button =0;
80002ff0:	30 08       	mov	r8,0
80002ff2:	ef 68 ff fa 	st.b	r7[-6],r8
	U8 i = 0 ;
80002ff6:	30 08       	mov	r8,0
80002ff8:	ef 68 ff fb 	st.b	r7[-5],r8
	/*point to xcmp payload*/
	ButtonConfig_brdcst_t  *ptr = (ButtonConfig_brdcst_t* )xcmp->u8;
80002ffc:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003000:	2f e8       	sub	r8,-2
80003002:	ef 48 ff fc 	st.w	r7[-4],r8
	
	Num_Button = ptr->NumOfButtons;
80003006:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000300a:	11 98       	ld.ub	r8,r8[0x1]
8000300c:	ef 68 ff fa 	st.b	r7[-6],r8
	
	log("\n\r ButtonConfig_broadcast  \n\r"  );
80003010:	4f 0c       	lddpc	r12,800031d0 <ButtonConfig_brdcst_func+0x1ec>
80003012:	f0 1f 00 71 	mcall	800031d4 <ButtonConfig_brdcst_func+0x1f0>
	
	log("\n\r Function: %X \n\r" , ptr->Function );
80003016:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000301a:	11 88       	ld.ub	r8,r8[0x0]
8000301c:	1a d8       	st.w	--sp,r8
8000301e:	4e fc       	lddpc	r12,800031d8 <ButtonConfig_brdcst_func+0x1f4>
80003020:	f0 1f 00 6d 	mcall	800031d4 <ButtonConfig_brdcst_func+0x1f0>
80003024:	2f fd       	sub	sp,-4
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
80003026:	ef 38 ff fa 	ld.ub	r8,r7[-6]
8000302a:	1a d8       	st.w	--sp,r8
8000302c:	4e cc       	lddpc	r12,800031dc <ButtonConfig_brdcst_func+0x1f8>
8000302e:	f0 1f 00 6a 	mcall	800031d4 <ButtonConfig_brdcst_func+0x1f0>
80003032:	2f fd       	sub	sp,-4
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
80003034:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003038:	11 a8       	ld.ub	r8,r8[0x2]
8000303a:	1a d8       	st.w	--sp,r8
8000303c:	4e 9c       	lddpc	r12,800031e0 <ButtonConfig_brdcst_func+0x1fc>
8000303e:	f0 1f 00 66 	mcall	800031d4 <ButtonConfig_brdcst_func+0x1f0>
80003042:	2f fd       	sub	sp,-4
	
	for (i; i<Num_Button; i++)
80003044:	cb a8       	rjmp	800031b8 <ButtonConfig_brdcst_func+0x1d4>
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
80003046:	ef 39 ff fb 	ld.ub	r9,r7[-5]
8000304a:	ee fa ff fc 	ld.w	r10,r7[-4]
8000304e:	12 98       	mov	r8,r9
80003050:	a3 68       	lsl	r8,0x2
80003052:	12 08       	add	r8,r9
80003054:	a1 78       	lsl	r8,0x1
80003056:	f4 08 00 08 	add	r8,r10,r8
8000305a:	2f d8       	sub	r8,-3
8000305c:	11 88       	ld.ub	r8,r8[0x0]
8000305e:	f0 0a 15 08 	lsl	r10,r8,0x8
80003062:	ef 39 ff fb 	ld.ub	r9,r7[-5]
80003066:	ee fb ff fc 	ld.w	r11,r7[-4]
8000306a:	12 98       	mov	r8,r9
8000306c:	a3 68       	lsl	r8,0x2
8000306e:	12 08       	add	r8,r9
80003070:	a1 78       	lsl	r8,0x1
80003072:	f6 08 00 08 	add	r8,r11,r8
80003076:	2f c8       	sub	r8,-4
80003078:	11 88       	ld.ub	r8,r8[0x0]
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
8000307a:	f5 e8 10 09 	or	r9,r10,r8
8000307e:	ef 38 ff fb 	ld.ub	r8,r7[-5]
80003082:	1a d9       	st.w	--sp,r9
80003084:	1a d8       	st.w	--sp,r8
80003086:	4d 8c       	lddpc	r12,800031e4 <ButtonConfig_brdcst_func+0x200>
80003088:	f0 1f 00 53 	mcall	800031d4 <ButtonConfig_brdcst_func+0x1f0>
8000308c:	2f ed       	sub	sp,-8
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
8000308e:	ef 39 ff fb 	ld.ub	r9,r7[-5]
80003092:	ee fa ff fc 	ld.w	r10,r7[-4]
80003096:	12 98       	mov	r8,r9
80003098:	a3 68       	lsl	r8,0x2
8000309a:	12 08       	add	r8,r9
8000309c:	a1 78       	lsl	r8,0x1
8000309e:	f4 08 00 08 	add	r8,r10,r8
800030a2:	2f b8       	sub	r8,-5
800030a4:	11 88       	ld.ub	r8,r8[0x0]
800030a6:	f0 0a 15 08 	lsl	r10,r8,0x8
800030aa:	ef 39 ff fb 	ld.ub	r9,r7[-5]
800030ae:	ee fb ff fc 	ld.w	r11,r7[-4]
800030b2:	12 98       	mov	r8,r9
800030b4:	a3 68       	lsl	r8,0x2
800030b6:	12 08       	add	r8,r9
800030b8:	a1 78       	lsl	r8,0x1
800030ba:	f6 08 00 08 	add	r8,r11,r8
800030be:	2f a8       	sub	r8,-6
800030c0:	11 88       	ld.ub	r8,r8[0x0]
	for (i; i<Num_Button; i++)
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
800030c2:	f5 e8 10 09 	or	r9,r10,r8
800030c6:	ef 38 ff fb 	ld.ub	r8,r7[-5]
800030ca:	1a d9       	st.w	--sp,r9
800030cc:	1a d8       	st.w	--sp,r8
800030ce:	4c 7c       	lddpc	r12,800031e8 <ButtonConfig_brdcst_func+0x204>
800030d0:	f0 1f 00 41 	mcall	800031d4 <ButtonConfig_brdcst_func+0x1f0>
800030d4:	2f ed       	sub	sp,-8
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
800030d6:	ef 39 ff fb 	ld.ub	r9,r7[-5]
800030da:	ee fa ff fc 	ld.w	r10,r7[-4]
800030de:	12 98       	mov	r8,r9
800030e0:	a3 68       	lsl	r8,0x2
800030e2:	12 08       	add	r8,r9
800030e4:	a1 78       	lsl	r8,0x1
800030e6:	f4 08 00 08 	add	r8,r10,r8
800030ea:	2f 98       	sub	r8,-7
800030ec:	11 88       	ld.ub	r8,r8[0x0]
800030ee:	f0 0a 15 08 	lsl	r10,r8,0x8
800030f2:	ef 39 ff fb 	ld.ub	r9,r7[-5]
800030f6:	ee fb ff fc 	ld.w	r11,r7[-4]
800030fa:	12 98       	mov	r8,r9
800030fc:	a3 68       	lsl	r8,0x2
800030fe:	12 08       	add	r8,r9
80003100:	a1 78       	lsl	r8,0x1
80003102:	f6 08 00 08 	add	r8,r11,r8
80003106:	2f 88       	sub	r8,-8
80003108:	11 88       	ld.ub	r8,r8[0x0]
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
8000310a:	f5 e8 10 09 	or	r9,r10,r8
8000310e:	ef 38 ff fb 	ld.ub	r8,r7[-5]
80003112:	1a d9       	st.w	--sp,r9
80003114:	1a d8       	st.w	--sp,r8
80003116:	4b 6c       	lddpc	r12,800031ec <ButtonConfig_brdcst_func+0x208>
80003118:	f0 1f 00 2f 	mcall	800031d4 <ButtonConfig_brdcst_func+0x1f0>
8000311c:	2f ed       	sub	sp,-8
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
8000311e:	ef 39 ff fb 	ld.ub	r9,r7[-5]
80003122:	ee fa ff fc 	ld.w	r10,r7[-4]
80003126:	12 98       	mov	r8,r9
80003128:	a3 68       	lsl	r8,0x2
8000312a:	12 08       	add	r8,r9
8000312c:	a1 78       	lsl	r8,0x1
8000312e:	f4 08 00 08 	add	r8,r10,r8
80003132:	2f 78       	sub	r8,-9
80003134:	11 88       	ld.ub	r8,r8[0x0]
80003136:	f0 0a 15 08 	lsl	r10,r8,0x8
8000313a:	ef 39 ff fb 	ld.ub	r9,r7[-5]
8000313e:	ee fb ff fc 	ld.w	r11,r7[-4]
80003142:	12 98       	mov	r8,r9
80003144:	a3 68       	lsl	r8,0x2
80003146:	12 08       	add	r8,r9
80003148:	a1 78       	lsl	r8,0x1
8000314a:	f6 08 00 08 	add	r8,r11,r8
8000314e:	2f 68       	sub	r8,-10
80003150:	11 88       	ld.ub	r8,r8[0x0]
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
80003152:	f5 e8 10 09 	or	r9,r10,r8
80003156:	ef 38 ff fb 	ld.ub	r8,r7[-5]
8000315a:	1a d9       	st.w	--sp,r9
8000315c:	1a d8       	st.w	--sp,r8
8000315e:	4a 5c       	lddpc	r12,800031f0 <ButtonConfig_brdcst_func+0x20c>
80003160:	f0 1f 00 1d 	mcall	800031d4 <ButtonConfig_brdcst_func+0x1f0>
80003164:	2f ed       	sub	sp,-8
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
				(ptr->ButtonInfo[i].Reserved2[0]<<8) | (ptr->ButtonInfo[i].Reserved2[1]));
80003166:	ef 39 ff fb 	ld.ub	r9,r7[-5]
8000316a:	ee fa ff fc 	ld.w	r10,r7[-4]
8000316e:	12 98       	mov	r8,r9
80003170:	a3 68       	lsl	r8,0x2
80003172:	12 08       	add	r8,r9
80003174:	a1 78       	lsl	r8,0x1
80003176:	f4 08 00 08 	add	r8,r10,r8
8000317a:	2f 58       	sub	r8,-11
8000317c:	11 88       	ld.ub	r8,r8[0x0]
8000317e:	f0 0a 15 08 	lsl	r10,r8,0x8
80003182:	ef 39 ff fb 	ld.ub	r9,r7[-5]
80003186:	ee fb ff fc 	ld.w	r11,r7[-4]
8000318a:	12 98       	mov	r8,r9
8000318c:	a3 68       	lsl	r8,0x2
8000318e:	12 08       	add	r8,r9
80003190:	a1 78       	lsl	r8,0x1
80003192:	f6 08 00 08 	add	r8,r11,r8
80003196:	2f 48       	sub	r8,-12
80003198:	11 88       	ld.ub	r8,r8[0x0]
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
8000319a:	f5 e8 10 09 	or	r9,r10,r8
8000319e:	ef 38 ff fb 	ld.ub	r8,r7[-5]
800031a2:	1a d9       	st.w	--sp,r9
800031a4:	1a d8       	st.w	--sp,r8
800031a6:	49 4c       	lddpc	r12,800031f4 <ButtonConfig_brdcst_func+0x210>
800031a8:	f0 1f 00 0b 	mcall	800031d4 <ButtonConfig_brdcst_func+0x1f0>
800031ac:	2f ed       	sub	sp,-8
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
800031ae:	ef 38 ff fb 	ld.ub	r8,r7[-5]
800031b2:	2f f8       	sub	r8,-1
800031b4:	ef 68 ff fb 	st.b	r7[-5],r8
800031b8:	ef 39 ff fb 	ld.ub	r9,r7[-5]
800031bc:	ef 38 ff fa 	ld.ub	r8,r7[-6]
800031c0:	f0 09 18 00 	cp.b	r9,r8
800031c4:	fe 93 ff 41 	brlo	80003046 <ButtonConfig_brdcst_func+0x62>
		
	}
	

	
}
800031c8:	2f dd       	sub	sp,-12
800031ca:	e3 cd 80 80 	ldm	sp++,r7,pc
800031ce:	00 00       	add	r0,r0
800031d0:	80 00       	ld.sh	r0,r0[0x0]
800031d2:	24 ec       	sub	r12,78
800031d4:	80 00       	ld.sh	r0,r0[0x0]
800031d6:	a8 70       	st.h	r4[0xe],r0
800031d8:	80 00       	ld.sh	r0,r0[0x0]
800031da:	24 04       	sub	r4,64
800031dc:	80 00       	ld.sh	r0,r0[0x0]
800031de:	25 0c       	sub	r12,80
800031e0:	80 00       	ld.sh	r0,r0[0x0]
800031e2:	25 24       	sub	r4,82
800031e4:	80 00       	ld.sh	r0,r0[0x0]
800031e6:	25 44       	sub	r4,84
800031e8:	80 00       	ld.sh	r0,r0[0x0]
800031ea:	25 6c       	sub	r12,86
800031ec:	80 00       	ld.sh	r0,r0[0x0]
800031ee:	25 94       	sub	r4,89
800031f0:	80 00       	ld.sh	r0,r0[0x0]
800031f2:	25 b8       	sub	r8,91
800031f4:	80 00       	ld.sh	r0,r0[0x0]
800031f6:	25 e0       	sub	r0,94

800031f8 <SingleDetection_brdcst_func>:


void SingleDetection_brdcst_func(xcmp_fragment_t * xcmp)
{
800031f8:	eb cd 40 80 	pushm	r7,lr
800031fc:	1a 97       	mov	r7,sp
800031fe:	20 1d       	sub	sp,4
80003200:	ef 4c ff fc 	st.w	r7[-4],r12
	if (xcmp->u8[0] == 0x11)
80003204:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003208:	11 a9       	ld.ub	r9,r8[0x2]
8000320a:	31 18       	mov	r8,17
8000320c:	f0 09 18 00 	cp.b	r9,r8
80003210:	c0 41       	brne	80003218 <SingleDetection_brdcst_func+0x20>
	{
		log("\n\r DMR_CSBK OK \n\r");
80003212:	48 4c       	lddpc	r12,80003220 <SingleDetection_brdcst_func+0x28>
80003214:	f0 1f 00 04 	mcall	80003224 <SingleDetection_brdcst_func+0x2c>
		//log("\n\r Signal_type: %X \n\r", xcmp->u8[0] );
	}
	

	//;
}
80003218:	2f fd       	sub	sp,-4
8000321a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000321e:	00 00       	add	r0,r0
80003220:	80 00       	ld.sh	r0,r0[0x0]
80003222:	26 04       	sub	r4,96
80003224:	80 00       	ld.sh	r0,r0[0x0]
80003226:	a8 70       	st.h	r4[0xe],r0

80003228 <EnOB_reply_func>:



void EnOB_reply_func(xcmp_fragment_t * xcmp)
{
80003228:	eb cd 40 80 	pushm	r7,lr
8000322c:	1a 97       	mov	r7,sp
8000322e:	20 1d       	sub	sp,4
80003230:	ef 4c ff fc 	st.w	r7[-4],r12
		/*point to xcmp payload*/
	//En_OB_Control_reply_t *ptr = (En_OB_Control_reply_t* )xcmp->u8;
	//log("\n\r Xcmp_opcode: %x \n\r", xcmp->xcmp_opcode);
	
	if (xcmp->u8[0]== xcmp_Res_Success)
80003234:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003238:	11 a8       	ld.ub	r8,r8[0x2]
8000323a:	58 08       	cp.w	r8,0
8000323c:	c1 e1       	brne	80003278 <EnOB_reply_func+0x50>
	{
		if (xcmp->u8[1] == EN_OB_Enter)
8000323e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003242:	11 b9       	ld.ub	r9,r8[0x3]
80003244:	30 18       	mov	r8,1
80003246:	f0 09 18 00 	cp.b	r9,r8
8000324a:	c0 51       	brne	80003254 <EnOB_reply_func+0x2c>
		{
		
			log("\n\r En_OB_Enter OK \n\r");
8000324c:	49 2c       	lddpc	r12,80003294 <EnOB_reply_func+0x6c>
8000324e:	f0 1f 00 13 	mcall	80003298 <EnOB_reply_func+0x70>
80003252:	c1 e8       	rjmp	8000328e <EnOB_reply_func+0x66>
			
		}
		else if (xcmp->u8[1] == EN_OB_Exit )
80003254:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003258:	11 b8       	ld.ub	r8,r8[0x3]
8000325a:	58 08       	cp.w	r8,0
8000325c:	c0 51       	brne	80003266 <EnOB_reply_func+0x3e>
		{
			log("\n\r En_OB_Exit OK \n\r");
8000325e:	49 0c       	lddpc	r12,8000329c <EnOB_reply_func+0x74>
80003260:	f0 1f 00 0e 	mcall	80003298 <EnOB_reply_func+0x70>
80003264:	c1 58       	rjmp	8000328e <EnOB_reply_func+0x66>
		}
		else
		{
			
			log("\n\r En_OB_Control: %x \n\r", xcmp->u8[1]);
80003266:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000326a:	11 b8       	ld.ub	r8,r8[0x3]
8000326c:	1a d8       	st.w	--sp,r8
8000326e:	48 dc       	lddpc	r12,800032a0 <EnOB_reply_func+0x78>
80003270:	f0 1f 00 0a 	mcall	80003298 <EnOB_reply_func+0x70>
80003274:	2f fd       	sub	sp,-4
80003276:	c0 c8       	rjmp	8000328e <EnOB_reply_func+0x66>
		
	}
	
	else
	{
		log("\n\r En_OB_Control error \n\r");
80003278:	48 bc       	lddpc	r12,800032a4 <EnOB_reply_func+0x7c>
8000327a:	f0 1f 00 08 	mcall	80003298 <EnOB_reply_func+0x70>
		log("\n\r En_OB_result: %x \n\r", xcmp->u8[0]);
8000327e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003282:	11 a8       	ld.ub	r8,r8[0x2]
80003284:	1a d8       	st.w	--sp,r8
80003286:	48 9c       	lddpc	r12,800032a8 <EnOB_reply_func+0x80>
80003288:	f0 1f 00 04 	mcall	80003298 <EnOB_reply_func+0x70>
8000328c:	2f fd       	sub	sp,-4
		
	}
	
	
}
8000328e:	2f fd       	sub	sp,-4
80003290:	e3 cd 80 80 	ldm	sp++,r7,pc
80003294:	80 00       	ld.sh	r0,r0[0x0]
80003296:	26 18       	sub	r8,97
80003298:	80 00       	ld.sh	r0,r0[0x0]
8000329a:	a8 70       	st.h	r4[0xe],r0
8000329c:	80 00       	ld.sh	r0,r0[0x0]
8000329e:	26 30       	sub	r0,99
800032a0:	80 00       	ld.sh	r0,r0[0x0]
800032a2:	26 44       	sub	r4,100
800032a4:	80 00       	ld.sh	r0,r0[0x0]
800032a6:	26 5c       	sub	r12,101
800032a8:	80 00       	ld.sh	r0,r0[0x0]
800032aa:	26 78       	sub	r8,103

800032ac <EnOB_brdcst_func>:

void EnOB_brdcst_func(xcmp_fragment_t * xcmp)
{
800032ac:	eb cd 40 80 	pushm	r7,lr
800032b0:	1a 97       	mov	r7,sp
800032b2:	20 1d       	sub	sp,4
800032b4:	ef 4c ff fc 	st.w	r7[-4],r12
	
	
	log("\n\r En_OB Broadcast \n\r");
800032b8:	48 3c       	lddpc	r12,800032c4 <EnOB_brdcst_func+0x18>
800032ba:	f0 1f 00 04 	mcall	800032c8 <EnOB_brdcst_func+0x1c>
}
800032be:	2f fd       	sub	sp,-4
800032c0:	e3 cd 80 80 	ldm	sp++,r7,pc
800032c4:	80 00       	ld.sh	r0,r0[0x0]
800032c6:	26 90       	sub	r0,105
800032c8:	80 00       	ld.sh	r0,r0[0x0]
800032ca:	a8 70       	st.h	r4[0xe],r0

800032cc <FD_request_func>:



void FD_request_func(xcmp_fragment_t * xcmp)
{
800032cc:	eb cd 40 80 	pushm	r7,lr
800032d0:	1a 97       	mov	r7,sp
800032d2:	20 1d       	sub	sp,4
800032d4:	ef 4c ff fc 	st.w	r7[-4],r12
	
	log("\n\r Forward Data Request \n\r");
800032d8:	48 3c       	lddpc	r12,800032e4 <FD_request_func+0x18>
800032da:	f0 1f 00 04 	mcall	800032e8 <FD_request_func+0x1c>
	
	
}
800032de:	2f fd       	sub	sp,-4
800032e0:	e3 cd 80 80 	ldm	sp++,r7,pc
800032e4:	80 00       	ld.sh	r0,r0[0x0]
800032e6:	26 a8       	sub	r8,106
800032e8:	80 00       	ld.sh	r0,r0[0x0]
800032ea:	a8 70       	st.h	r4[0xe],r0

800032ec <FD_reply_func>:

void FD_reply_func(xcmp_fragment_t * xcmp)
{
800032ec:	eb cd 40 80 	pushm	r7,lr
800032f0:	1a 97       	mov	r7,sp
800032f2:	20 1d       	sub	sp,4
800032f4:	ef 4c ff fc 	st.w	r7[-4],r12
	
	log("\n\r Forward Data Reply \n\r");
800032f8:	48 3c       	lddpc	r12,80003304 <FD_reply_func+0x18>
800032fa:	f0 1f 00 04 	mcall	80003308 <FD_reply_func+0x1c>
	
	
}
800032fe:	2f fd       	sub	sp,-4
80003300:	e3 cd 80 80 	ldm	sp++,r7,pc
80003304:	80 00       	ld.sh	r0,r0[0x0]
80003306:	26 c4       	sub	r4,108
80003308:	80 00       	ld.sh	r0,r0[0x0]
8000330a:	a8 70       	st.h	r4[0xe],r0

8000330c <FD_brdcst_func>:

void FD_brdcst_func(xcmp_fragment_t * xcmp)
{
8000330c:	eb cd 40 80 	pushm	r7,lr
80003310:	1a 97       	mov	r7,sp
80003312:	20 1d       	sub	sp,4
80003314:	ef 4c ff fc 	st.w	r7[-4],r12
	
	
	log("\n\r Forward Data Broadcast \n\r");
80003318:	48 3c       	lddpc	r12,80003324 <FD_brdcst_func+0x18>
8000331a:	f0 1f 00 04 	mcall	80003328 <FD_brdcst_func+0x1c>
	
}
8000331e:	2f fd       	sub	sp,-4
80003320:	e3 cd 80 80 	ldm	sp++,r7,pc
80003324:	80 00       	ld.sh	r0,r0[0x0]
80003326:	26 e0       	sub	r0,110
80003328:	80 00       	ld.sh	r0,r0[0x0]
8000332a:	a8 70       	st.h	r4[0xe],r0

8000332c <app_init>:
														
		
};

void app_init(void)
{	
8000332c:	eb cd 40 80 	pushm	r7,lr
80003330:	1a 97       	mov	r7,sp
	//app_payload_rx_procPCM
	payload_init( app_payload_rx_proc , app_payload_tx_proc );	
80003332:	48 eb       	lddpc	r11,80003368 <app_init+0x3c>
80003334:	48 ec       	lddpc	r12,8000336c <app_init+0x40>
80003336:	f0 1f 00 0f 	mcall	80003370 <app_init+0x44>
	xcmp_register_app_list(the_app_list);
8000333a:	48 fc       	lddpc	r12,80003374 <app_init+0x48>
8000333c:	f0 1f 00 0f 	mcall	80003378 <app_init+0x4c>
			
	static portBASE_TYPE res = 0;
	 res = xTaskCreate(
80003340:	48 fb       	lddpc	r11,8000337c <app_init+0x50>
80003342:	30 08       	mov	r8,0
80003344:	1a d8       	st.w	--sp,r8
80003346:	30 08       	mov	r8,0
80003348:	1a d8       	st.w	--sp,r8
8000334a:	30 08       	mov	r8,0
8000334c:	1a d8       	st.w	--sp,r8
8000334e:	30 18       	mov	r8,1
80003350:	30 09       	mov	r9,0
80003352:	e0 6a 01 80 	mov	r10,384
80003356:	48 bc       	lddpc	r12,80003380 <app_init+0x54>
80003358:	f0 1f 00 0b 	mcall	80003384 <app_init+0x58>
8000335c:	2f dd       	sub	sp,-12
8000335e:	18 99       	mov	r9,r12
80003360:	48 a8       	lddpc	r8,80003388 <app_init+0x5c>
80003362:	91 09       	st.w	r8[0x0],r9
	,  NULL
	,  1
	,  NULL );
	
	
}
80003364:	e3 cd 80 80 	ldm	sp++,r7,pc
80003368:	80 00       	ld.sh	r0,r0[0x0]
8000336a:	34 c4       	mov	r4,76
8000336c:	80 00       	ld.sh	r0,r0[0x0]
8000336e:	34 64       	mov	r4,70
80003370:	80 00       	ld.sh	r0,r0[0x0]
80003372:	47 48       	lddsp	r8,sp[0x1d0]
80003374:	00 00       	add	r0,r0
80003376:	00 08       	add	r8,r0
80003378:	80 00       	ld.sh	r0,r0[0x0]
8000337a:	6b 24       	ld.w	r4,r5[0x48]
8000337c:	80 00       	ld.sh	r0,r0[0x0]
8000337e:	27 00       	sub	r0,112
80003380:	80 00       	ld.sh	r0,r0[0x0]
80003382:	33 8c       	mov	r12,56
80003384:	80 00       	ld.sh	r0,r0[0x0]
80003386:	96 9c       	ld.uh	r12,r11[0x2]
80003388:	00 00       	add	r0,r0
8000338a:	0a 74       	tst	r4,r5

8000338c <app_cfg>:

extern  char AudioData[];
extern U32 tc_tick;

static __app_Thread_(app_cfg)
{
8000338c:	eb cd 40 80 	pushm	r7,lr
80003390:	1a 97       	mov	r7,sp
80003392:	20 3d       	sub	sp,12
80003394:	ef 4c ff f4 	st.w	r7[-12],r12
	static int counter=0;
	static  U32 isAudioRouting = 0;
	static  portTickType xLastWakeTime;
	const portTickType xFrequency = 4000;//2s,2s x  2000hz = 4000
80003398:	e0 68 0f a0 	mov	r8,4000
8000339c:	ef 48 ff f8 	st.w	r7[-8],r8
	U8 Burst_ID = 0;
800033a0:	30 08       	mov	r8,0
800033a2:	ef 68 ff ff 	st.b	r7[-1],r8
	
	 xLastWakeTime = xTaskGetTickCount();
800033a6:	f0 1f 00 26 	mcall	8000343c <app_cfg+0xb0>
800033aa:	18 99       	mov	r9,r12
800033ac:	4a 58       	lddpc	r8,80003440 <app_cfg+0xb4>
800033ae:	91 09       	st.w	r8[0x0],r9
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003))//
800033b0:	4a 58       	lddpc	r8,80003444 <app_cfg+0xb8>
800033b2:	70 08       	ld.w	r8,r8[0x0]
800033b4:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
800033b8:	58 38       	cp.w	r8,3
800033ba:	c2 d1       	brne	80003414 <app_cfg+0x88>
		{	
			//if((++coun) % 3 ==0)		
			{
				
				// xcmp_audio_route_speaker();
				xcmp_IdleTestTone();
800033bc:	f0 1f 00 23 	mcall	80003448 <app_cfg+0xbc>
				//{
					////xcmp_transmit_dekeycontrol();
					//
				//}
				
				if(isAudioRouting == 0)
800033c0:	4a 38       	lddpc	r8,8000344c <app_cfg+0xc0>
800033c2:	70 08       	ld.w	r8,r8[0x0]
800033c4:	58 08       	cp.w	r8,0
800033c6:	c0 71       	brne	800033d4 <app_cfg+0x48>
				{
					xcmp_data_session();
800033c8:	f0 1f 00 22 	mcall	80003450 <app_cfg+0xc4>
					//xcmp_enter_enhanced_OB_mode();
					//xcmp_unmute_speaker();
					//Speaker_is_unmute = 1;
					//xcmp_function_mic();
					
					isAudioRouting = 1;
800033cc:	4a 08       	lddpc	r8,8000344c <app_cfg+0xc0>
800033ce:	30 19       	mov	r9,1
800033d0:	91 09       	st.w	r8[0x0],r9
800033d2:	c2 18       	rjmp	80003414 <app_cfg+0x88>
				}
				else if(isAudioRouting == 1)
800033d4:	49 e8       	lddpc	r8,8000344c <app_cfg+0xc0>
800033d6:	70 08       	ld.w	r8,r8[0x0]
800033d8:	58 18       	cp.w	r8,1
800033da:	c0 51       	brne	800033e4 <app_cfg+0x58>
					//xcmp_button_config();
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//log("\n\r time: %d \n\r", tc_tick);
					
					isAudioRouting = 2;
800033dc:	49 c8       	lddpc	r8,8000344c <app_cfg+0xc0>
800033de:	30 29       	mov	r9,2
800033e0:	91 09       	st.w	r8[0x0],r9
800033e2:	c1 98       	rjmp	80003414 <app_cfg+0x88>
					//isAudioRouting++;
				}
				else if(isAudioRouting == 2)
800033e4:	49 a8       	lddpc	r8,8000344c <app_cfg+0xc0>
800033e6:	70 08       	ld.w	r8,r8[0x0]
800033e8:	58 28       	cp.w	r8,2
800033ea:	c0 71       	brne	800033f8 <app_cfg+0x6c>
				{
					xcmp_data_session();
800033ec:	f0 1f 00 19 	mcall	80003450 <app_cfg+0xc4>
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_mute_speaker();	
					//log("\n\r time: %d \n\r", tc_tick); 
					isAudioRouting = 3;
800033f0:	49 78       	lddpc	r8,8000344c <app_cfg+0xc0>
800033f2:	30 39       	mov	r9,3
800033f4:	91 09       	st.w	r8[0x0],r9
800033f6:	c0 f8       	rjmp	80003414 <app_cfg+0x88>
					
				}
				else if(isAudioRouting == 3)
800033f8:	49 58       	lddpc	r8,8000344c <app_cfg+0xc0>
800033fa:	70 08       	ld.w	r8,r8[0x0]
800033fc:	58 38       	cp.w	r8,3
800033fe:	c0 51       	brne	80003408 <app_cfg+0x7c>
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_exit_enhanced_OB_mode();
					//xcmp_mute_speaker();
					//xcmp_enhanced_OB_mode();
					isAudioRouting = 4;
80003400:	49 38       	lddpc	r8,8000344c <app_cfg+0xc0>
80003402:	30 49       	mov	r9,4
80003404:	91 09       	st.w	r8[0x0],r9
80003406:	c0 78       	rjmp	80003414 <app_cfg+0x88>
					
				}
				else
				{
					isAudioRouting++;
80003408:	49 18       	lddpc	r8,8000344c <app_cfg+0xc0>
8000340a:	70 08       	ld.w	r8,r8[0x0]
8000340c:	f0 c9 ff ff 	sub	r9,r8,-1
80003410:	48 f8       	lddpc	r8,8000344c <app_cfg+0xc0>
80003412:	91 09       	st.w	r8[0x0],r9
				//}
			}
			
		}
		//vTaskDelay(300*2 / portTICK_RATE_MS);//300ms
		counter++;
80003414:	49 08       	lddpc	r8,80003454 <app_cfg+0xc8>
80003416:	70 08       	ld.w	r8,r8[0x0]
80003418:	f0 c9 ff ff 	sub	r9,r8,-1
8000341c:	48 e8       	lddpc	r8,80003454 <app_cfg+0xc8>
8000341e:	91 09       	st.w	r8[0x0],r9
		log("\n\r counter: %d \n\r", counter);
80003420:	48 d8       	lddpc	r8,80003454 <app_cfg+0xc8>
80003422:	70 08       	ld.w	r8,r8[0x0]
80003424:	1a d8       	st.w	--sp,r8
80003426:	48 dc       	lddpc	r12,80003458 <app_cfg+0xcc>
80003428:	f0 1f 00 0d 	mcall	8000345c <app_cfg+0xd0>
8000342c:	2f fd       	sub	sp,-4
		//log("\n\r xLastWakeTime: %d \n\r", xLastWakeTime);
		
		vTaskDelayUntil( &xLastWakeTime, 1000*2 / portTICK_RATE_MS  );//1000ms
8000342e:	e0 6b 07 d0 	mov	r11,2000
80003432:	48 4c       	lddpc	r12,80003440 <app_cfg+0xb4>
80003434:	f0 1f 00 0b 	mcall	80003460 <app_cfg+0xd4>
	}
80003438:	cb cb       	rjmp	800033b0 <app_cfg+0x24>
8000343a:	00 00       	add	r0,r0
8000343c:	80 00       	ld.sh	r0,r0[0x0]
8000343e:	9a ec       	ld.uh	r12,sp[0xc]
80003440:	00 00       	add	r0,r0
80003442:	0a 68       	and	r8,r5
80003444:	00 00       	add	r0,r0
80003446:	0d a0       	ld.ub	r0,r6[0x2]
80003448:	80 00       	ld.sh	r0,r0[0x0]
8000344a:	6b f0       	ld.w	r0,r5[0x7c]
8000344c:	00 00       	add	r0,r0
8000344e:	0a 6c       	and	r12,r5
80003450:	80 00       	ld.sh	r0,r0[0x0]
80003452:	6c 58       	ld.w	r8,r6[0x14]
80003454:	00 00       	add	r0,r0
80003456:	0a 70       	tst	r0,r5
80003458:	80 00       	ld.sh	r0,r0[0x0]
8000345a:	27 08       	sub	r8,112
8000345c:	80 00       	ld.sh	r0,r0[0x0]
8000345e:	a8 70       	st.h	r4[0xe],r0
80003460:	80 00       	ld.sh	r0,r0[0x0]
80003462:	98 64       	ld.sh	r4,r12[0xc]

80003464 <app_payload_rx_proc>:
}


static void app_payload_rx_proc(void  * payload)
{
80003464:	eb cd 40 80 	pushm	r7,lr
80003468:	1a 97       	mov	r7,sp
8000346a:	20 1d       	sub	sp,4
8000346c:	ef 4c ff fc 	st.w	r7[-4],r12
	static  U8 times_counter = 0;
	
	times_counter++;
80003470:	48 f8       	lddpc	r8,800034ac <app_payload_rx_proc+0x48>
80003472:	11 88       	ld.ub	r8,r8[0x0]
80003474:	2f f8       	sub	r8,-1
80003476:	5c 58       	castu.b	r8
80003478:	48 d9       	lddpc	r9,800034ac <app_payload_rx_proc+0x48>
8000347a:	b2 88       	st.b	r9[0x0],r8
	if (times_counter == 3)
8000347c:	48 c8       	lddpc	r8,800034ac <app_payload_rx_proc+0x48>
8000347e:	11 89       	ld.ub	r9,r8[0x0]
80003480:	30 38       	mov	r8,3
80003482:	f0 09 18 00 	cp.b	r9,r8
80003486:	c0 71       	brne	80003494 <app_payload_rx_proc+0x30>
	{
		times_counter = 0 ;
80003488:	48 99       	lddpc	r9,800034ac <app_payload_rx_proc+0x48>
8000348a:	30 08       	mov	r8,0
8000348c:	b2 88       	st.b	r9[0x0],r8
		log("\n\r w: \n\r");
8000348e:	48 9c       	lddpc	r12,800034b0 <app_payload_rx_proc+0x4c>
80003490:	f0 1f 00 09 	mcall	800034b4 <app_payload_rx_proc+0x50>
	}
	//log("\n\r w: \n\r");
	if (AMBE_tx_flag)//mic
80003494:	48 98       	lddpc	r8,800034b8 <app_payload_rx_proc+0x54>
80003496:	11 88       	ld.ub	r8,r8[0x0]
	{
		//fl_write("PCMvo.pcm", FILE_END, payload, MAX_PAYLOAD_BUFF_SIZE * 2);
	}
	
	//payload_fragment_t * ptr = (payload_fragment_t *)payload;
	set_payload_idle(payload);
80003498:	48 98       	lddpc	r8,800034bc <app_payload_rx_proc+0x58>
8000349a:	70 08       	ld.w	r8,r8[0x0]
8000349c:	ee fb ff fc 	ld.w	r11,r7[-4]
800034a0:	10 9c       	mov	r12,r8
800034a2:	f0 1f 00 08 	mcall	800034c0 <app_payload_rx_proc+0x5c>

}
800034a6:	2f fd       	sub	sp,-4
800034a8:	e3 cd 80 80 	ldm	sp++,r7,pc
800034ac:	00 00       	add	r0,r0
800034ae:	0a 64       	and	r4,r5
800034b0:	80 00       	ld.sh	r0,r0[0x0]
800034b2:	27 1c       	sub	r12,113
800034b4:	80 00       	ld.sh	r0,r0[0x0]
800034b6:	a8 70       	st.h	r4[0xe],r0
800034b8:	00 00       	add	r0,r0
800034ba:	0a 5a       	eor	r10,r5
800034bc:	00 00       	add	r0,r0
800034be:	0a 98       	mov	r8,r5
800034c0:	80 00       	ld.sh	r0,r0[0x0]
800034c2:	64 c4       	ld.w	r4,r2[0x30]

800034c4 <app_payload_tx_proc>:


static void app_payload_tx_proc(void  * payload)
{
800034c4:	eb cd 40 80 	pushm	r7,lr
800034c8:	1a 97       	mov	r7,sp
800034ca:	20 1d       	sub	sp,4
800034cc:	ef 4c ff fc 	st.w	r7[-4],r12
  log("R");
800034d0:	48 3c       	lddpc	r12,800034dc <app_payload_tx_proc+0x18>
800034d2:	f0 1f 00 04 	mcall	800034e0 <app_payload_tx_proc+0x1c>
  //
  //
  //set_payload_idle(payload);


}
800034d6:	2f fd       	sub	sp,-4
800034d8:	e3 cd 80 80 	ldm	sp++,r7,pc
800034dc:	80 00       	ld.sh	r0,r0[0x0]
800034de:	27 28       	sub	r8,114
800034e0:	80 00       	ld.sh	r0,r0[0x0]
800034e2:	a8 70       	st.h	r4[0xe],r0

800034e4 <vApplicationIdleHook>:

void vApplicationIdleHook( void )
{
800034e4:	eb cd 40 80 	pushm	r7,lr
800034e8:	1a 97       	mov	r7,sp
	/* This hook function does nothing but increment a counter. */
	ulIdleCycleCount++;
800034ea:	48 58       	lddpc	r8,800034fc <vApplicationIdleHook+0x18>
800034ec:	70 08       	ld.w	r8,r8[0x0]
800034ee:	f0 c9 ff ff 	sub	r9,r8,-1
800034f2:	48 38       	lddpc	r8,800034fc <vApplicationIdleHook+0x18>
800034f4:	91 09       	st.w	r8[0x0],r9
	
}
800034f6:	e3 cd 80 80 	ldm	sp++,r7,pc
800034fa:	00 00       	add	r0,r0
800034fc:	00 00       	add	r0,r0
800034fe:	0a 60       	and	r0,r5
80003500:	0a 2d       	rsub	sp,r5
80003502:	2d 2d       	sub	sp,-184
80003504:	2d 66       	sub	r6,-42
80003506:	6c 61       	ld.w	r1,r6[0x18]
80003508:	73 68       	ld.w	r8,r9[0x58]
8000350a:	20 65       	sub	r5,6
8000350c:	72 61       	ld.w	r1,r9[0x18]
8000350e:	73 65       	ld.w	r5,r9[0x58]
80003510:	20 66       	sub	r6,6
80003512:	61 69       	ld.w	r9,r0[0x58]
80003514:	6c 2d       	ld.w	sp,r6[0x8]
80003516:	2d 2d       	sub	sp,-184
80003518:	2d 0a       	sub	r10,-48
8000351a:	00 00       	add	r0,r0
8000351c:	0a 2d       	rsub	sp,r5
8000351e:	2d 2d       	sub	sp,-184
80003520:	2d 46       	sub	r6,-44
80003522:	6c 61       	ld.w	r1,r6[0x18]
80003524:	73 68       	ld.w	r8,r9[0x58]
80003526:	20 72       	sub	r2,7
80003528:	65 61       	ld.w	r1,r2[0x58]
8000352a:	64 20       	ld.w	r0,r2[0x8]
8000352c:	74 65       	ld.w	r5,r10[0x18]
8000352e:	73 74       	ld.w	r4,r9[0x5c]
80003530:	20 66       	sub	r6,6
80003532:	61 69       	ld.w	r9,r0[0x58]
80003534:	6c 2d       	ld.w	sp,r6[0x8]
80003536:	2d 2d       	sub	sp,-184
80003538:	2d 0a       	sub	r10,-48
8000353a:	00 00       	add	r0,r0
8000353c:	0a 2d       	rsub	sp,r5
8000353e:	2d 2d       	sub	sp,-184
80003540:	2d 46       	sub	r6,-44
80003542:	6c 61       	ld.w	r1,r6[0x18]
80003544:	73 68       	ld.w	r8,r9[0x58]
80003546:	20 72       	sub	r2,7
80003548:	65 61       	ld.w	r1,r2[0x58]
8000354a:	64 20       	ld.w	r0,r2[0x8]
8000354c:	74 65       	ld.w	r5,r10[0x18]
8000354e:	73 74       	ld.w	r4,r9[0x5c]
80003550:	20 70       	sub	r0,7
80003552:	61 73       	ld.w	r3,r0[0x5c]
80003554:	73 2d       	ld.w	sp,r9[0x48]
80003556:	2d 2d       	sub	sp,-184
80003558:	2d 0a       	sub	r10,-48
8000355a:	00 00       	add	r0,r0
8000355c:	44 46       	lddsp	r6,sp[0x110]
8000355e:	54 00       	stdsp	sp[0x100],r0
80003560:	0d 0a       	ld.w	r10,r6++
80003562:	2d 2d       	sub	sp,-184
80003564:	2d 2d       	sub	sp,-184
80003566:	76 6f       	ld.w	pc,r11[0x18]
80003568:	69 63       	ld.w	r3,r4[0x58]
8000356a:	65 20       	ld.w	r0,r2[0x48]
8000356c:	73 74       	ld.w	r4,r9[0x5c]
8000356e:	6f 72       	ld.w	r2,r7[0x5c]
80003570:	61 67       	ld.w	r7,r0[0x58]
80003572:	65 20       	ld.w	r0,r2[0x48]
80003574:	69 73       	ld.w	r3,r4[0x5c]
80003576:	20 66       	sub	r6,6
80003578:	75 6c       	ld.w	r12,r10[0x58]
8000357a:	6c 21       	ld.w	r1,r6[0x8]
8000357c:	21 21       	sub	r1,18
8000357e:	2d 2d       	sub	sp,-184
80003580:	2d 2d       	sub	sp,-184
80003582:	0d 0a       	ld.w	r10,r6++
80003584:	00 00       	add	r0,r0
	...

80003588 <data_flash_init>:
* ----------  --------  ----------  --------------------------------------------
* 10-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
void data_flash_init(void)
{
80003588:	eb cd 40 80 	pushm	r7,lr
8000358c:	1a 97       	mov	r7,sp
8000358e:	20 5d       	sub	sp,20
	U16 status = 0xff;
80003590:	e0 68 00 ff 	mov	r8,255
80003594:	ef 58 ff fe 	st.h	r7[-2],r8
		.spck_delay   = 0,
		.trans_delay  = 0,
		.stay_act     = 1,
		.spi_mode     = 0,
		.modfdis      = 1
	};
80003598:	4c 48       	lddpc	r8,800036a8 <data_flash_init+0x120>
8000359a:	ee ca 00 14 	sub	r10,r7,20
8000359e:	10 9b       	mov	r11,r8
800035a0:	f6 e8 00 00 	ld.d	r8,r11[0]
800035a4:	f4 e9 00 00 	st.d	r10[0],r8
800035a8:	f6 e8 00 08 	ld.d	r8,r11[8]
800035ac:	f4 e9 00 08 	st.d	r10[8],r8

	// Assign I/Os to SPI.
	gpio_enable_module(DF_SPI_GPIO_MAP, sizeof(DF_SPI_GPIO_MAP) / sizeof(DF_SPI_GPIO_MAP[0]));
800035b0:	30 4b       	mov	r11,4
800035b2:	4b fc       	lddpc	r12,800036ac <data_flash_init+0x124>
800035b4:	f0 1f 00 3f 	mcall	800036b0 <data_flash_init+0x128>

	// Configure PA25 as WP pin - 1: deasserted (allow write) always
	gpio_enable_gpio_pin(AVR32_PIN_PA25);
800035b8:	31 9c       	mov	r12,25
800035ba:	f0 1f 00 3f 	mcall	800036b4 <data_flash_init+0x12c>
 	gpio_set_gpio_pin(AVR32_PIN_PA25);
800035be:	31 9c       	mov	r12,25
800035c0:	f0 1f 00 3e 	mcall	800036b8 <data_flash_init+0x130>

	spi = &AVR32_SPI;
800035c4:	4b e8       	lddpc	r8,800036bc <data_flash_init+0x134>
800035c6:	fe 79 24 00 	mov	r9,-56320
800035ca:	91 09       	st.w	r8[0x0],r9

	// Initialize as master.
	spi_initMaster(spi, &spiOptions);
800035cc:	4b c8       	lddpc	r8,800036bc <data_flash_init+0x134>
800035ce:	70 08       	ld.w	r8,r8[0x0]
800035d0:	ee c9 00 14 	sub	r9,r7,20
800035d4:	12 9b       	mov	r11,r9
800035d6:	10 9c       	mov	r12,r8
800035d8:	f0 1f 00 3a 	mcall	800036c0 <data_flash_init+0x138>

	// Set selection mode: variable_ps, pcs_decode, delay.
	spi_selectionMode(spi, 0, 0, 0);
800035dc:	4b 88       	lddpc	r8,800036bc <data_flash_init+0x134>
800035de:	70 08       	ld.w	r8,r8[0x0]
800035e0:	30 09       	mov	r9,0
800035e2:	30 0a       	mov	r10,0
800035e4:	30 0b       	mov	r11,0
800035e6:	10 9c       	mov	r12,r8
800035e8:	f0 1f 00 37 	mcall	800036c4 <data_flash_init+0x13c>

	// Enable SPI.
	spi_enable(spi);
800035ec:	4b 48       	lddpc	r8,800036bc <data_flash_init+0x134>
800035ee:	70 08       	ld.w	r8,r8[0x0]
800035f0:	10 9c       	mov	r12,r8
800035f2:	f0 1f 00 36 	mcall	800036c8 <data_flash_init+0x140>

	// Initialize data flash with SPI clock Osc0.
	if (spi_setupChipReg(spi, &spiOptions, 2*FOSC0) != SPI_OK)
800035f6:	4b 28       	lddpc	r8,800036bc <data_flash_init+0x134>
800035f8:	70 08       	ld.w	r8,r8[0x0]
800035fa:	ee c9 00 14 	sub	r9,r7,20
800035fe:	e0 6a 36 00 	mov	r10,13824
80003602:	ea 1a 01 6e 	orh	r10,0x16e
80003606:	12 9b       	mov	r11,r9
80003608:	10 9c       	mov	r12,r8
8000360a:	f0 1f 00 31 	mcall	800036cc <data_flash_init+0x144>
8000360e:	18 98       	mov	r8,r12
80003610:	58 08       	cp.w	r8,0
80003612:	c0 50       	breq	8000361c <data_flash_init+0x94>
	{
		//fatal_error(FATAL_ERROR_DATA_FLASH_SPI_INIT);
		data_flash_failure = FATAL_ERROR_DATA_FLASH_SPI_INIT;
80003614:	4a f9       	lddpc	r9,800036d0 <data_flash_init+0x148>
80003616:	30 28       	mov	r8,2
80003618:	b2 88       	st.b	r9[0x0],r8
		return;
8000361a:	c4 48       	rjmp	800036a2 <data_flash_init+0x11a>
	}

	if (data_flash_check_device_id() != TRUE)
8000361c:	f0 1f 00 2e 	mcall	800036d4 <data_flash_init+0x14c>
80003620:	18 98       	mov	r8,r12
80003622:	10 99       	mov	r9,r8
80003624:	30 18       	mov	r8,1
80003626:	f0 09 18 00 	cp.b	r9,r8
8000362a:	c0 50       	breq	80003634 <data_flash_init+0xac>
	{
		//fatal_error(FATAL_ERROR_DATA_FLASH_READ_ID);
		data_flash_failure = FATAL_ERROR_DATA_FLASH_READ_ID;
8000362c:	4a 99       	lddpc	r9,800036d0 <data_flash_init+0x148>
8000362e:	30 38       	mov	r8,3
80003630:	b2 88       	st.b	r9[0x0],r8
		return;
80003632:	c3 88       	rjmp	800036a2 <data_flash_init+0x11a>
	}

	// Set STATUS reg to unprotect all sect
	send_flash_command(WRITE_ENABLE, 0, NULL, 0);
80003634:	30 09       	mov	r9,0
80003636:	30 0a       	mov	r10,0
80003638:	30 0b       	mov	r11,0
8000363a:	30 6c       	mov	r12,6
8000363c:	f0 1f 00 27 	mcall	800036d8 <data_flash_init+0x150>
	send_flash_command(WRITE_STATUS_REG_BYTE_1, 0, NULL, 0);
80003640:	30 09       	mov	r9,0
80003642:	30 0a       	mov	r10,0
80003644:	30 0b       	mov	r11,0
80003646:	30 1c       	mov	r12,1
80003648:	f0 1f 00 24 	mcall	800036d8 <data_flash_init+0x150>
	status = send_flash_command(READ_STATUS_REG, 0, NULL, 0);
8000364c:	30 09       	mov	r9,0
8000364e:	30 0a       	mov	r10,0
80003650:	30 0b       	mov	r11,0
80003652:	30 5c       	mov	r12,5
80003654:	f0 1f 00 21 	mcall	800036d8 <data_flash_init+0x150>
80003658:	18 98       	mov	r8,r12
8000365a:	5c 88       	casts.h	r8
8000365c:	ef 58 ff fe 	st.h	r7[-2],r8
	// after 5 seconds, perform a test on write and read back 0x5A5A to address 0x00001002
	// then read address 0x00001002 every 5s and report to radio with failure

	//test_data_flash(FALSE);
	//create_data_flash_test_task();
	create_data_list();
80003660:	f0 1f 00 1f 	mcall	800036dc <data_flash_init+0x154>
	
	//data_flash_read_block(LABEL_ADDRESS, 512, FLASH_BUF);
	//data_flash_read_block(LABEL_ADDRESS, 512, FLASH_BUF);
	save_voice_data(AMBE_AudioData, 600, TRUE);//1
80003664:	30 1a       	mov	r10,1
80003666:	e0 6b 02 58 	mov	r11,600
8000366a:	49 ec       	lddpc	r12,800036e0 <data_flash_init+0x158>
8000366c:	f0 1f 00 1e 	mcall	800036e4 <data_flash_init+0x15c>
	save_voice_data(&AMBE_AudioData[600], 350, TRUE);//2
80003670:	49 c8       	lddpc	r8,800036e0 <data_flash_init+0x158>
80003672:	f0 c8 fd a8 	sub	r8,r8,-600
80003676:	30 1a       	mov	r10,1
80003678:	e0 6b 01 5e 	mov	r11,350
8000367c:	10 9c       	mov	r12,r8
8000367e:	f0 1f 00 1a 	mcall	800036e4 <data_flash_init+0x15c>
	save_voice_data(&AMBE_AudioData[950], 500, TRUE);//3
80003682:	49 88       	lddpc	r8,800036e0 <data_flash_init+0x158>
80003684:	f0 c8 fc 4a 	sub	r8,r8,-950
80003688:	30 1a       	mov	r10,1
8000368a:	e0 6b 01 f4 	mov	r11,500
8000368e:	10 9c       	mov	r12,r8
80003690:	f0 1f 00 15 	mcall	800036e4 <data_flash_init+0x15c>
	//save_voice_data(&AMBE_AudioData, 1024, TRUE);//4
	//save_voice_data(&AMBE_AudioData, 1350, TRUE);//5
	////save_voice_data(&AMBE_AudioData, 600, TRUE);//9
	//
	//playback_voice_data(3);
	playback_voice_data(3);
80003694:	30 3c       	mov	r12,3
80003696:	f0 1f 00 15 	mcall	800036e8 <data_flash_init+0x160>
	playback_voice_data(20);
8000369a:	31 4c       	mov	r12,20
8000369c:	f0 1f 00 13 	mcall	800036e8 <data_flash_init+0x160>
	//playback_voice_data(5);
	//playback_voice_data(4);

	
	return;
800036a0:	d7 03       	nop
}
800036a2:	2f bd       	sub	sp,-20
800036a4:	e3 cd 80 80 	ldm	sp++,r7,pc
800036a8:	80 01       	ld.sh	r1,r0[0x0]
800036aa:	0c 04       	add	r4,r6
800036ac:	80 01       	ld.sh	r1,r0[0x0]
800036ae:	0c 14       	sub	r4,r6
800036b0:	80 00       	ld.sh	r0,r0[0x0]
800036b2:	ae 6c       	st.h	r7[0xc],r12
800036b4:	80 00       	ld.sh	r0,r0[0x0]
800036b6:	af ec       	*unknown*
800036b8:	80 00       	ld.sh	r0,r0[0x0]
800036ba:	b0 3c       	st.h	r8[0x6],r12
800036bc:	00 00       	add	r0,r0
800036be:	1f a4       	ld.ub	r4,pc[0x2]
800036c0:	80 00       	ld.sh	r0,r0[0x0]
800036c2:	79 ce       	ld.w	lr,r12[0x70]
800036c4:	80 00       	ld.sh	r0,r0[0x0]
800036c6:	7a 62       	ld.w	r2,sp[0x18]
800036c8:	80 00       	ld.sh	r0,r0[0x0]
800036ca:	7d 78       	ld.w	r8,lr[0x5c]
800036cc:	80 00       	ld.sh	r0,r0[0x0]
800036ce:	7b f8       	ld.w	r8,sp[0x7c]
800036d0:	00 00       	add	r0,r0
800036d2:	0a 78       	tst	r8,r5
800036d4:	80 00       	ld.sh	r0,r0[0x0]
800036d6:	36 ec       	mov	r12,110
800036d8:	80 00       	ld.sh	r0,r0[0x0]
800036da:	37 ac       	mov	r12,122
800036dc:	80 00       	ld.sh	r0,r0[0x0]
800036de:	3a 84       	mov	r4,-88
800036e0:	80 01       	ld.sh	r1,r0[0x0]
800036e2:	0c 84       	andn	r4,r6
800036e4:	80 00       	ld.sh	r0,r0[0x0]
800036e6:	3c 80       	mov	r0,-56
800036e8:	80 00       	ld.sh	r0,r0[0x0]
800036ea:	3f 48       	mov	r8,-12

800036ec <data_flash_check_device_id>:
* ----------  --------  ----------  --------------------------------------------
* 10-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
static Bool data_flash_check_device_id(void)
{
800036ec:	eb cd 40 80 	pushm	r7,lr
800036f0:	1a 97       	mov	r7,sp
800036f2:	20 1d       	sub	sp,4
	U16 manufacturer_device_id[2] = {0x5A5A, 0x5A5A};
800036f4:	4a 79       	lddpc	r9,80003790 <data_flash_check_device_id+0xa4>
800036f6:	ee c8 00 04 	sub	r8,r7,4
800036fa:	30 4a       	mov	r10,4
800036fc:	12 9b       	mov	r11,r9
800036fe:	10 9c       	mov	r12,r8
80003700:	f0 1f 00 25 	mcall	80003794 <data_flash_check_device_id+0xa8>

	/* DF memory check. */
	/* Select the DF memory to check. */
	spi_selectChip(spi, DF_SPI_PCS_0);
80003704:	4a 58       	lddpc	r8,80003798 <data_flash_check_device_id+0xac>
80003706:	70 08       	ld.w	r8,r8[0x0]
80003708:	30 0b       	mov	r11,0
8000370a:	10 9c       	mov	r12,r8
8000370c:	f0 1f 00 24 	mcall	8000379c <data_flash_check_device_id+0xb0>

	/* Send the Status Register Read command. */
	spi_write(spi, READ_M_D_ID);
80003710:	4a 28       	lddpc	r8,80003798 <data_flash_check_device_id+0xac>
80003712:	70 08       	ld.w	r8,r8[0x0]
80003714:	e0 6b 00 9f 	mov	r11,159
80003718:	10 9c       	mov	r12,r8
8000371a:	f0 1f 00 22 	mcall	800037a0 <data_flash_check_device_id+0xb4>

	/* Send 2 dummy byte to read the status register. */
	spi_write_dummy();
8000371e:	49 f8       	lddpc	r8,80003798 <data_flash_check_device_id+0xac>
80003720:	70 08       	ld.w	r8,r8[0x0]
80003722:	e0 6b 00 ff 	mov	r11,255
80003726:	10 9c       	mov	r12,r8
80003728:	f0 1f 00 1e 	mcall	800037a0 <data_flash_check_device_id+0xb4>
	spi_read(spi, &manufacturer_device_id[0]);
8000372c:	49 b8       	lddpc	r8,80003798 <data_flash_check_device_id+0xac>
8000372e:	70 08       	ld.w	r8,r8[0x0]
80003730:	ee c9 00 04 	sub	r9,r7,4
80003734:	12 9b       	mov	r11,r9
80003736:	10 9c       	mov	r12,r8
80003738:	f0 1f 00 1b 	mcall	800037a4 <data_flash_check_device_id+0xb8>
	spi_write_dummy();
8000373c:	49 78       	lddpc	r8,80003798 <data_flash_check_device_id+0xac>
8000373e:	70 08       	ld.w	r8,r8[0x0]
80003740:	e0 6b 00 ff 	mov	r11,255
80003744:	10 9c       	mov	r12,r8
80003746:	f0 1f 00 17 	mcall	800037a0 <data_flash_check_device_id+0xb4>
	spi_read(spi, &manufacturer_device_id[1]);
8000374a:	49 48       	lddpc	r8,80003798 <data_flash_check_device_id+0xac>
8000374c:	70 08       	ld.w	r8,r8[0x0]
8000374e:	ee c9 00 04 	sub	r9,r7,4
80003752:	2f e9       	sub	r9,-2
80003754:	12 9b       	mov	r11,r9
80003756:	10 9c       	mov	r12,r8
80003758:	f0 1f 00 13 	mcall	800037a4 <data_flash_check_device_id+0xb8>

	/* Unselect the checked DF memory. */
	spi_unselectChip(spi, DF_SPI_PCS_0);
8000375c:	48 f8       	lddpc	r8,80003798 <data_flash_check_device_id+0xac>
8000375e:	70 08       	ld.w	r8,r8[0x0]
80003760:	30 0b       	mov	r11,0
80003762:	10 9c       	mov	r12,r8
80003764:	f0 1f 00 11 	mcall	800037a8 <data_flash_check_device_id+0xbc>

	/* Unexpected device ID. */
    if ((manufacturer_device_id[0] != 0x1F) || (manufacturer_device_id[1] != 0x48))
80003768:	ef 09 ff fc 	ld.sh	r9,r7[-4]
8000376c:	31 f8       	mov	r8,31
8000376e:	f0 09 19 00 	cp.h	r9,r8
80003772:	c0 71       	brne	80003780 <data_flash_check_device_id+0x94>
80003774:	ef 09 ff fe 	ld.sh	r9,r7[-2]
80003778:	34 88       	mov	r8,72
8000377a:	f0 09 19 00 	cp.h	r9,r8
8000377e:	c0 30       	breq	80003784 <data_flash_check_device_id+0x98>
    {
    	return FALSE;
80003780:	30 08       	mov	r8,0
80003782:	c0 28       	rjmp	80003786 <data_flash_check_device_id+0x9a>
    }

    return TRUE;
80003784:	30 18       	mov	r8,1
}
80003786:	10 9c       	mov	r12,r8
80003788:	2f fd       	sub	sp,-4
8000378a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000378e:	00 00       	add	r0,r0
80003790:	80 01       	ld.sh	r1,r0[0x0]
80003792:	0c 00       	add	r0,r6
80003794:	80 00       	ld.sh	r0,r0[0x0]
80003796:	b5 62       	lsl	r2,0x14
80003798:	00 00       	add	r0,r0
8000379a:	1f a4       	ld.ub	r4,pc[0x2]
8000379c:	80 00       	ld.sh	r0,r0[0x0]
8000379e:	7a f6       	ld.w	r6,sp[0x3c]
800037a0:	80 00       	ld.sh	r0,r0[0x0]
800037a2:	7d 92       	ld.w	r2,lr[0x64]
800037a4:	80 00       	ld.sh	r0,r0[0x0]
800037a6:	7d ea       	ld.w	r10,lr[0x78]
800037a8:	80 00       	ld.sh	r0,r0[0x0]
800037aa:	7b 8e       	ld.w	lr,sp[0x60]

800037ac <send_flash_command>:
* ----------  --------  ----------  --------------------------------------------
* 10-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
U16 send_flash_command(U16 command, U32 address, U8 *data_ptr, U16 length)
{
800037ac:	eb cd 40 80 	pushm	r7,lr
800037b0:	1a 97       	mov	r7,sp
800037b2:	20 7d       	sub	sp,28
800037b4:	ef 4b ff ec 	st.w	r7[-20],r11
800037b8:	ef 4a ff e8 	st.w	r7[-24],r10
800037bc:	12 98       	mov	r8,r9
800037be:	18 99       	mov	r9,r12
800037c0:	ef 59 ff f0 	st.h	r7[-16],r9
800037c4:	ef 58 ff e4 	st.h	r7[-28],r8
	U16 status = 1;
800037c8:	30 18       	mov	r8,1
800037ca:	ef 58 ff fc 	st.h	r7[-4],r8
	U16 i = 0;
800037ce:	30 08       	mov	r8,0
800037d0:	ef 58 ff fe 	st.h	r7[-2],r8

    /* in order to call spi_write(U16* data), change 3-bytes address to 3-U16 address */
	U16 addr[3];
	addr[2] = (address & 0x00ff0000) >> 16;
800037d4:	ee f8 ff ec 	ld.w	r8,r7[-20]
800037d8:	e6 18 00 ff 	andh	r8,0xff,COH
800037dc:	b1 88       	lsr	r8,0x10
800037de:	5c 88       	casts.h	r8
800037e0:	ef 58 ff fa 	st.h	r7[-6],r8
	addr[1] = (address & 0x0000ff00) >> 8;
800037e4:	ee f8 ff ec 	ld.w	r8,r7[-20]
800037e8:	e2 18 ff 00 	andl	r8,0xff00,COH
800037ec:	a9 88       	lsr	r8,0x8
800037ee:	5c 88       	casts.h	r8
800037f0:	ef 58 ff f8 	st.h	r7[-8],r8
	addr[0] = (address & 0x000000ff);
800037f4:	ee f8 ff ec 	ld.w	r8,r7[-20]
800037f8:	5c 88       	casts.h	r8
800037fa:	5c 88       	casts.h	r8
800037fc:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
80003800:	ef 58 ff f6 	st.h	r7[-10],r8

	U16 data_u16;

	spi_selectChip(spi, DF_SPI_PCS_0);
80003804:	fe f8 02 6c 	ld.w	r8,pc[620]
80003808:	70 08       	ld.w	r8,r8[0x0]
8000380a:	30 0b       	mov	r11,0
8000380c:	10 9c       	mov	r12,r8
8000380e:	f0 1f 00 9a 	mcall	80003a74 <send_flash_command+0x2c8>

    switch (command)
80003812:	ef 18 ff f0 	ld.uh	r8,r7[-16]
80003816:	58 58       	cp.w	r8,5
80003818:	c2 30       	breq	8000385e <send_flash_command+0xb2>
8000381a:	e0 89 00 10 	brgt	8000383a <send_flash_command+0x8e>
8000381e:	58 28       	cp.w	r8,2
80003820:	c7 20       	breq	80003904 <send_flash_command+0x158>
80003822:	e0 89 00 06 	brgt	8000382e <send_flash_command+0x82>
80003826:	58 18       	cp.w	r8,1
80003828:	e0 80 01 0a 	breq	80003a3c <send_flash_command+0x290>
8000382c:	c1 69       	rjmp	80003a58 <send_flash_command+0x2ac>
8000382e:	58 38       	cp.w	r8,3
80003830:	e0 80 00 b5 	breq	8000399a <send_flash_command+0x1ee>
80003834:	58 48       	cp.w	r8,4
80003836:	c2 e0       	breq	80003892 <send_flash_command+0xe6>
80003838:	c1 09       	rjmp	80003a58 <send_flash_command+0x2ac>
8000383a:	e0 48 00 52 	cp.w	r8,82
8000383e:	c3 30       	breq	800038a4 <send_flash_command+0xf8>
80003840:	e0 89 00 08 	brgt	80003850 <send_flash_command+0xa4>
80003844:	58 68       	cp.w	r8,6
80003846:	c2 60       	breq	80003892 <send_flash_command+0xe6>
80003848:	e0 48 00 20 	cp.w	r8,32
8000384c:	c2 c0       	breq	800038a4 <send_flash_command+0xf8>
8000384e:	c0 59       	rjmp	80003a58 <send_flash_command+0x2ac>
80003850:	e0 48 00 60 	cp.w	r8,96
80003854:	c4 f0       	breq	800038f2 <send_flash_command+0x146>
80003856:	e0 48 00 d8 	cp.w	r8,216
8000385a:	c2 50       	breq	800038a4 <send_flash_command+0xf8>
8000385c:	cf e8       	rjmp	80003a58 <send_flash_command+0x2ac>
	{
		case READ_STATUS_REG:
			spi_write_byte(command);
8000385e:	ef 19 ff f0 	ld.uh	r9,r7[-16]
80003862:	fe f8 02 0e 	ld.w	r8,pc[526]
80003866:	70 08       	ld.w	r8,r8[0x0]
80003868:	12 9b       	mov	r11,r9
8000386a:	10 9c       	mov	r12,r8
8000386c:	f0 1f 00 83 	mcall	80003a78 <send_flash_command+0x2cc>
			spi_write_dummy();
80003870:	fe f8 02 00 	ld.w	r8,pc[512]
80003874:	70 08       	ld.w	r8,r8[0x0]
80003876:	e0 6b 00 ff 	mov	r11,255
8000387a:	10 9c       	mov	r12,r8
8000387c:	f0 1f 00 7f 	mcall	80003a78 <send_flash_command+0x2cc>
			spi_read_byte(&status);
80003880:	4f c8       	lddpc	r8,80003a70 <send_flash_command+0x2c4>
80003882:	70 08       	ld.w	r8,r8[0x0]
80003884:	ee c9 00 04 	sub	r9,r7,4
80003888:	12 9b       	mov	r11,r9
8000388a:	10 9c       	mov	r12,r8
8000388c:	f0 1f 00 7c 	mcall	80003a7c <send_flash_command+0x2d0>
			break;
80003890:	ce 48       	rjmp	80003a58 <send_flash_command+0x2ac>
		case WRITE_ENABLE:
		case WRITE_DISABLE:
			spi_write_byte(command);
80003892:	ef 19 ff f0 	ld.uh	r9,r7[-16]
80003896:	4f 78       	lddpc	r8,80003a70 <send_flash_command+0x2c4>
80003898:	70 08       	ld.w	r8,r8[0x0]
8000389a:	12 9b       	mov	r11,r9
8000389c:	10 9c       	mov	r12,r8
8000389e:	f0 1f 00 77 	mcall	80003a78 <send_flash_command+0x2cc>
			break;
800038a2:	cd b8       	rjmp	80003a58 <send_flash_command+0x2ac>
		case BLOCK_ERASE_4KB:
		case BLOCK_ERASE_32KB:
		case BLOCK_ERASE_64KB:
			spi_write_byte(command);
800038a4:	ef 19 ff f0 	ld.uh	r9,r7[-16]
800038a8:	4f 28       	lddpc	r8,80003a70 <send_flash_command+0x2c4>
800038aa:	70 08       	ld.w	r8,r8[0x0]
800038ac:	12 9b       	mov	r11,r9
800038ae:	10 9c       	mov	r12,r8
800038b0:	f0 1f 00 72 	mcall	80003a78 <send_flash_command+0x2cc>
			spi_write_byte(addr[2]);
800038b4:	ef 08 ff fa 	ld.sh	r8,r7[-6]
800038b8:	f3 d8 c0 10 	bfextu	r9,r8,0x0,0x10
800038bc:	4e d8       	lddpc	r8,80003a70 <send_flash_command+0x2c4>
800038be:	70 08       	ld.w	r8,r8[0x0]
800038c0:	12 9b       	mov	r11,r9
800038c2:	10 9c       	mov	r12,r8
800038c4:	f0 1f 00 6d 	mcall	80003a78 <send_flash_command+0x2cc>
			spi_write_byte(addr[1]);
800038c8:	ef 08 ff f8 	ld.sh	r8,r7[-8]
800038cc:	f3 d8 c0 10 	bfextu	r9,r8,0x0,0x10
800038d0:	4e 88       	lddpc	r8,80003a70 <send_flash_command+0x2c4>
800038d2:	70 08       	ld.w	r8,r8[0x0]
800038d4:	12 9b       	mov	r11,r9
800038d6:	10 9c       	mov	r12,r8
800038d8:	f0 1f 00 68 	mcall	80003a78 <send_flash_command+0x2cc>
			spi_write_byte(addr[0]);
800038dc:	ef 08 ff f6 	ld.sh	r8,r7[-10]
800038e0:	f3 d8 c0 10 	bfextu	r9,r8,0x0,0x10
800038e4:	4e 38       	lddpc	r8,80003a70 <send_flash_command+0x2c4>
800038e6:	70 08       	ld.w	r8,r8[0x0]
800038e8:	12 9b       	mov	r11,r9
800038ea:	10 9c       	mov	r12,r8
800038ec:	f0 1f 00 63 	mcall	80003a78 <send_flash_command+0x2cc>
			break;
800038f0:	cb 48       	rjmp	80003a58 <send_flash_command+0x2ac>
		case CHIP_ERASE:
			spi_write_byte(command);
800038f2:	ef 19 ff f0 	ld.uh	r9,r7[-16]
800038f6:	4d f8       	lddpc	r8,80003a70 <send_flash_command+0x2c4>
800038f8:	70 08       	ld.w	r8,r8[0x0]
800038fa:	12 9b       	mov	r11,r9
800038fc:	10 9c       	mov	r12,r8
800038fe:	f0 1f 00 5f 	mcall	80003a78 <send_flash_command+0x2cc>
			break;
80003902:	ca b8       	rjmp	80003a58 <send_flash_command+0x2ac>
		case BYTE_PROGRAM: /* PAGE_PROGRAM use the same value */
			spi_write_byte(command);
80003904:	ef 19 ff f0 	ld.uh	r9,r7[-16]
80003908:	4d a8       	lddpc	r8,80003a70 <send_flash_command+0x2c4>
8000390a:	70 08       	ld.w	r8,r8[0x0]
8000390c:	12 9b       	mov	r11,r9
8000390e:	10 9c       	mov	r12,r8
80003910:	f0 1f 00 5a 	mcall	80003a78 <send_flash_command+0x2cc>
			spi_write_byte(addr[2]);
80003914:	ef 08 ff fa 	ld.sh	r8,r7[-6]
80003918:	f3 d8 c0 10 	bfextu	r9,r8,0x0,0x10
8000391c:	4d 58       	lddpc	r8,80003a70 <send_flash_command+0x2c4>
8000391e:	70 08       	ld.w	r8,r8[0x0]
80003920:	12 9b       	mov	r11,r9
80003922:	10 9c       	mov	r12,r8
80003924:	f0 1f 00 55 	mcall	80003a78 <send_flash_command+0x2cc>
			spi_write_byte(addr[1]);
80003928:	ef 08 ff f8 	ld.sh	r8,r7[-8]
8000392c:	f3 d8 c0 10 	bfextu	r9,r8,0x0,0x10
80003930:	4d 08       	lddpc	r8,80003a70 <send_flash_command+0x2c4>
80003932:	70 08       	ld.w	r8,r8[0x0]
80003934:	12 9b       	mov	r11,r9
80003936:	10 9c       	mov	r12,r8
80003938:	f0 1f 00 50 	mcall	80003a78 <send_flash_command+0x2cc>
			spi_write_byte(addr[0]);
8000393c:	ef 08 ff f6 	ld.sh	r8,r7[-10]
80003940:	f3 d8 c0 10 	bfextu	r9,r8,0x0,0x10
80003944:	4c b8       	lddpc	r8,80003a70 <send_flash_command+0x2c4>
80003946:	70 08       	ld.w	r8,r8[0x0]
80003948:	12 9b       	mov	r11,r9
8000394a:	10 9c       	mov	r12,r8
8000394c:	f0 1f 00 4b 	mcall	80003a78 <send_flash_command+0x2cc>
			for (i = 0; i < length; i++)
80003950:	30 08       	mov	r8,0
80003952:	ef 58 ff fe 	st.h	r7[-2],r8
80003956:	c1 a8       	rjmp	8000398a <send_flash_command+0x1de>
			{
				data_u16 = (*data_ptr)&0x00ff;//modified by huayi
80003958:	ee f8 ff e8 	ld.w	r8,r7[-24]
8000395c:	11 88       	ld.ub	r8,r8[0x0]
8000395e:	ef 58 ff f4 	st.h	r7[-12],r8
				data_ptr++;
80003962:	ee f8 ff e8 	ld.w	r8,r7[-24]
80003966:	2f f8       	sub	r8,-1
80003968:	ef 48 ff e8 	st.w	r7[-24],r8
				spi_write_byte(data_u16);
8000396c:	ef 08 ff f4 	ld.sh	r8,r7[-12]
80003970:	f3 d8 c0 10 	bfextu	r9,r8,0x0,0x10
80003974:	4b f8       	lddpc	r8,80003a70 <send_flash_command+0x2c4>
80003976:	70 08       	ld.w	r8,r8[0x0]
80003978:	12 9b       	mov	r11,r9
8000397a:	10 9c       	mov	r12,r8
8000397c:	f0 1f 00 3f 	mcall	80003a78 <send_flash_command+0x2cc>
		case BYTE_PROGRAM: /* PAGE_PROGRAM use the same value */
			spi_write_byte(command);
			spi_write_byte(addr[2]);
			spi_write_byte(addr[1]);
			spi_write_byte(addr[0]);
			for (i = 0; i < length; i++)
80003980:	ef 08 ff fe 	ld.sh	r8,r7[-2]
80003984:	2f f8       	sub	r8,-1
80003986:	ef 58 ff fe 	st.h	r7[-2],r8
8000398a:	ef 09 ff fe 	ld.sh	r9,r7[-2]
8000398e:	ef 08 ff e4 	ld.sh	r8,r7[-28]
80003992:	f0 09 19 00 	cp.h	r9,r8
80003996:	ce 13       	brcs	80003958 <send_flash_command+0x1ac>
			{
				data_u16 = (*data_ptr)&0x00ff;//modified by huayi
				data_ptr++;
				spi_write_byte(data_u16);
			}
			break;
80003998:	c6 08       	rjmp	80003a58 <send_flash_command+0x2ac>
		case READ_ARRAY:
			spi_write_byte(command);
8000399a:	ef 19 ff f0 	ld.uh	r9,r7[-16]
8000399e:	4b 58       	lddpc	r8,80003a70 <send_flash_command+0x2c4>
800039a0:	70 08       	ld.w	r8,r8[0x0]
800039a2:	12 9b       	mov	r11,r9
800039a4:	10 9c       	mov	r12,r8
800039a6:	f0 1f 00 35 	mcall	80003a78 <send_flash_command+0x2cc>
			spi_write_byte(addr[2]);
800039aa:	ef 08 ff fa 	ld.sh	r8,r7[-6]
800039ae:	f3 d8 c0 10 	bfextu	r9,r8,0x0,0x10
800039b2:	4b 08       	lddpc	r8,80003a70 <send_flash_command+0x2c4>
800039b4:	70 08       	ld.w	r8,r8[0x0]
800039b6:	12 9b       	mov	r11,r9
800039b8:	10 9c       	mov	r12,r8
800039ba:	f0 1f 00 30 	mcall	80003a78 <send_flash_command+0x2cc>
			spi_write_byte(addr[1]);
800039be:	ef 08 ff f8 	ld.sh	r8,r7[-8]
800039c2:	f3 d8 c0 10 	bfextu	r9,r8,0x0,0x10
800039c6:	4a b8       	lddpc	r8,80003a70 <send_flash_command+0x2c4>
800039c8:	70 08       	ld.w	r8,r8[0x0]
800039ca:	12 9b       	mov	r11,r9
800039cc:	10 9c       	mov	r12,r8
800039ce:	f0 1f 00 2b 	mcall	80003a78 <send_flash_command+0x2cc>
			spi_write_byte(addr[0]);
800039d2:	ef 08 ff f6 	ld.sh	r8,r7[-10]
800039d6:	f3 d8 c0 10 	bfextu	r9,r8,0x0,0x10
800039da:	4a 68       	lddpc	r8,80003a70 <send_flash_command+0x2c4>
800039dc:	70 08       	ld.w	r8,r8[0x0]
800039de:	12 9b       	mov	r11,r9
800039e0:	10 9c       	mov	r12,r8
800039e2:	f0 1f 00 26 	mcall	80003a78 <send_flash_command+0x2cc>
			for (i = 0; i < length; i++)
800039e6:	30 08       	mov	r8,0
800039e8:	ef 58 ff fe 	st.h	r7[-2],r8
800039ec:	c2 08       	rjmp	80003a2c <send_flash_command+0x280>
			{
				spi_write_dummy();
800039ee:	4a 18       	lddpc	r8,80003a70 <send_flash_command+0x2c4>
800039f0:	70 08       	ld.w	r8,r8[0x0]
800039f2:	e0 6b 00 ff 	mov	r11,255
800039f6:	10 9c       	mov	r12,r8
800039f8:	f0 1f 00 20 	mcall	80003a78 <send_flash_command+0x2cc>
				spi_read_byte(&data_u16);
800039fc:	49 d8       	lddpc	r8,80003a70 <send_flash_command+0x2c4>
800039fe:	70 08       	ld.w	r8,r8[0x0]
80003a00:	ee c9 00 0c 	sub	r9,r7,12
80003a04:	12 9b       	mov	r11,r9
80003a06:	10 9c       	mov	r12,r8
80003a08:	f0 1f 00 1d 	mcall	80003a7c <send_flash_command+0x2d0>
				*data_ptr = (U8)data_u16;
80003a0c:	ef 08 ff f4 	ld.sh	r8,r7[-12]
80003a10:	5c 58       	castu.b	r8
80003a12:	ee f9 ff e8 	ld.w	r9,r7[-24]
80003a16:	b2 88       	st.b	r9[0x0],r8
				data_ptr++;
80003a18:	ee f8 ff e8 	ld.w	r8,r7[-24]
80003a1c:	2f f8       	sub	r8,-1
80003a1e:	ef 48 ff e8 	st.w	r7[-24],r8
		case READ_ARRAY:
			spi_write_byte(command);
			spi_write_byte(addr[2]);
			spi_write_byte(addr[1]);
			spi_write_byte(addr[0]);
			for (i = 0; i < length; i++)
80003a22:	ef 08 ff fe 	ld.sh	r8,r7[-2]
80003a26:	2f f8       	sub	r8,-1
80003a28:	ef 58 ff fe 	st.h	r7[-2],r8
80003a2c:	ef 09 ff fe 	ld.sh	r9,r7[-2]
80003a30:	ef 08 ff e4 	ld.sh	r8,r7[-28]
80003a34:	f0 09 19 00 	cp.h	r9,r8
80003a38:	cd b3       	brcs	800039ee <send_flash_command+0x242>
				spi_write_dummy();
				spi_read_byte(&data_u16);
				*data_ptr = (U8)data_u16;
				data_ptr++;
			}
			break;
80003a3a:	c0 f8       	rjmp	80003a58 <send_flash_command+0x2ac>
		case WRITE_STATUS_REG_BYTE_1:
			spi_write_byte(command);
80003a3c:	ef 19 ff f0 	ld.uh	r9,r7[-16]
80003a40:	48 c8       	lddpc	r8,80003a70 <send_flash_command+0x2c4>
80003a42:	70 08       	ld.w	r8,r8[0x0]
80003a44:	12 9b       	mov	r11,r9
80003a46:	10 9c       	mov	r12,r8
80003a48:	f0 1f 00 0c 	mcall	80003a78 <send_flash_command+0x2cc>
			spi_write_byte(UNPROTECT_ALL_SECTORS);
80003a4c:	48 98       	lddpc	r8,80003a70 <send_flash_command+0x2c4>
80003a4e:	70 08       	ld.w	r8,r8[0x0]
80003a50:	30 0b       	mov	r11,0
80003a52:	10 9c       	mov	r12,r8
80003a54:	f0 1f 00 09 	mcall	80003a78 <send_flash_command+0x2cc>
			break;
		default:
			break;
	}

	spi_unselectChip(spi, DF_SPI_PCS_0);
80003a58:	48 68       	lddpc	r8,80003a70 <send_flash_command+0x2c4>
80003a5a:	70 08       	ld.w	r8,r8[0x0]
80003a5c:	30 0b       	mov	r11,0
80003a5e:	10 9c       	mov	r12,r8
80003a60:	f0 1f 00 08 	mcall	80003a80 <send_flash_command+0x2d4>

	return status;
80003a64:	ef 08 ff fc 	ld.sh	r8,r7[-4]
}
80003a68:	10 9c       	mov	r12,r8
80003a6a:	2f 9d       	sub	sp,-28
80003a6c:	e3 cd 80 80 	ldm	sp++,r7,pc
80003a70:	00 00       	add	r0,r0
80003a72:	1f a4       	ld.ub	r4,pc[0x2]
80003a74:	80 00       	ld.sh	r0,r0[0x0]
80003a76:	7a f6       	ld.w	r6,sp[0x3c]
80003a78:	80 00       	ld.sh	r0,r0[0x0]
80003a7a:	7d 92       	ld.w	r2,lr[0x64]
80003a7c:	80 00       	ld.sh	r0,r0[0x0]
80003a7e:	7d ea       	ld.w	r10,lr[0x78]
80003a80:	80 00       	ld.sh	r0,r0[0x0]
80003a82:	7b 8e       	ld.w	lr,sp[0x60]

80003a84 <create_data_list>:
* ----------  --------  ----------  --------------------------------------------
* 20-Fri-17   Edwards    none        Initial draft
*
*******************************************************************************/
static Bool create_data_list(void)
{
80003a84:	eb cd 40 80 	pushm	r7,lr
80003a88:	1a 97       	mov	r7,sp
80003a8a:	20 7d       	sub	sp,28
	df_status_t return_code = DF_OK;
80003a8c:	30 08       	mov	r8,0
80003a8e:	ef 48 ff f0 	st.w	r7[-16],r8
	unsigned int i = 0;
80003a92:	30 08       	mov	r8,0
80003a94:	ef 48 ff f4 	st.w	r7[-12],r8
	unsigned int address =0x00000000;	
80003a98:	30 08       	mov	r8,0
80003a9a:	ef 48 ff f8 	st.w	r7[-8],r8
	char str[10];
	memset(str, 0x00, sizeof(str));
80003a9e:	ee c8 00 1c 	sub	r8,r7,28
80003aa2:	30 aa       	mov	r10,10
80003aa4:	30 0b       	mov	r11,0
80003aa6:	10 9c       	mov	r12,r8
80003aa8:	f0 1f 00 6b 	mcall	80003c54 <create_data_list+0x1d0>
80003aac:	c0 28       	rjmp	80003ab0 <create_data_list+0x2c>
							if(current_save_voice_offset > 0x7bc000){
								
								log("\r\n----voice storage is full!!!----\r\n");
								//chip erase
								return_code = data_flash_erase_block(0, DF_BLOCK_ALL);
								if(return_code == DF_ERASE_COMPLETED)goto start;
80003aae:	d7 03       	nop
	memset(str, 0x00, sizeof(str));
	
start:	

	/* bytes remained less than one page */
	return_code = data_flash_read_block(LABEL_ADDRESS, LABEL_LENGTH, str);
80003ab0:	ee c8 00 1c 	sub	r8,r7,28
80003ab4:	10 9a       	mov	r10,r8
80003ab6:	30 7b       	mov	r11,7
80003ab8:	30 0c       	mov	r12,0
80003aba:	f0 1f 00 68 	mcall	80003c58 <create_data_list+0x1d4>
80003abe:	18 98       	mov	r8,r12
80003ac0:	ef 48 ff f0 	st.w	r7[-16],r8
	if(return_code == DF_OK)
80003ac4:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003ac8:	58 08       	cp.w	r8,0
80003aca:	e0 81 00 bf 	brne	80003c48 <create_data_list+0x1c4>
	{
		if(memcmp(FlashLabel, str, sizeof(FlashLabel)-1) != 0)//compare label
80003ace:	ee c8 00 1c 	sub	r8,r7,28
80003ad2:	30 7a       	mov	r10,7
80003ad4:	10 9b       	mov	r11,r8
80003ad6:	4e 2c       	lddpc	r12,80003c5c <create_data_list+0x1d8>
80003ad8:	f0 1f 00 62 	mcall	80003c60 <create_data_list+0x1dc>
80003adc:	18 98       	mov	r8,r12
80003ade:	58 08       	cp.w	r8,0
80003ae0:	c3 f0       	breq	80003b5e <create_data_list+0xda>
		{
			//erase
			for(i; i < (VOICE_LIST_BOUNDARY/(64*1024)); i++)//8*64k
80003ae2:	c1 a8       	rjmp	80003b16 <create_data_list+0x92>
			{
				return_code = data_flash_erase_block(address, DF_BLOCK_64KB);
80003ae4:	30 3b       	mov	r11,3
80003ae6:	ee fc ff f8 	ld.w	r12,r7[-8]
80003aea:	f0 1f 00 5f 	mcall	80003c64 <create_data_list+0x1e0>
80003aee:	18 98       	mov	r8,r12
80003af0:	ef 48 ff f0 	st.w	r7[-16],r8
				if(return_code != DF_ERASE_COMPLETED)
80003af4:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003af8:	58 58       	cp.w	r8,5
80003afa:	c0 30       	breq	80003b00 <create_data_list+0x7c>
				{
					return FALSE;
80003afc:	30 08       	mov	r8,0
80003afe:	ca 68       	rjmp	80003c4a <create_data_list+0x1c6>
				}
				address+=65536;//64k*1024=65536bytes
80003b00:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003b04:	fe 38 00 00 	sub	r8,-65536
80003b08:	ef 48 ff f8 	st.w	r7[-8],r8
	if(return_code == DF_OK)
	{
		if(memcmp(FlashLabel, str, sizeof(FlashLabel)-1) != 0)//compare label
		{
			//erase
			for(i; i < (VOICE_LIST_BOUNDARY/(64*1024)); i++)//8*64k
80003b0c:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003b10:	2f f8       	sub	r8,-1
80003b12:	ef 48 ff f4 	st.w	r7[-12],r8
80003b16:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003b1a:	58 78       	cp.w	r8,7
80003b1c:	fe 98 ff e4 	brls	80003ae4 <create_data_list+0x60>
					return FALSE;
				}
				address+=65536;//64k*1024=65536bytes
			}
			//set label
			return_code = data_flash_write(FlashLabel, LABEL_ADDRESS, LABEL_LENGTH);
80003b20:	30 7a       	mov	r10,7
80003b22:	30 0b       	mov	r11,0
80003b24:	4c ec       	lddpc	r12,80003c5c <create_data_list+0x1d8>
80003b26:	f0 1f 00 51 	mcall	80003c68 <create_data_list+0x1e4>
80003b2a:	18 98       	mov	r8,r12
80003b2c:	ef 48 ff f0 	st.w	r7[-16],r8
			//set current_voice_index
			memset(str, 0x00, sizeof(str));
80003b30:	ee c8 00 1c 	sub	r8,r7,28
80003b34:	30 aa       	mov	r10,10
80003b36:	30 0b       	mov	r11,0
80003b38:	10 9c       	mov	r12,r8
80003b3a:	f0 1f 00 47 	mcall	80003c54 <create_data_list+0x1d0>
			return_code = data_flash_write(str, VOICE_NUMBERS_ADDRESS, VOICE_NUMBERS_LENGTH);
80003b3e:	ee c8 00 1c 	sub	r8,r7,28
80003b42:	30 2a       	mov	r10,2
80003b44:	30 ab       	mov	r11,10
80003b46:	10 9c       	mov	r12,r8
80003b48:	f0 1f 00 48 	mcall	80003c68 <create_data_list+0x1e4>
80003b4c:	18 98       	mov	r8,r12
80003b4e:	ef 48 ff f0 	st.w	r7[-16],r8
			if(return_code != DF_WRITE_COMPLETED)
80003b52:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003b56:	58 78       	cp.w	r8,7
80003b58:	c7 30       	breq	80003c3e <create_data_list+0x1ba>
			{
				return FALSE;
80003b5a:	30 08       	mov	r8,0
80003b5c:	c7 78       	rjmp	80003c4a <create_data_list+0x1c6>
			}									
		}
		else//success
		{	
			//Get the current voice index
			return_code = data_flash_read_block(VOICE_NUMBERS_ADDRESS, VOICE_NUMBERS_LENGTH, &current_voice_index);
80003b5e:	4c 48       	lddpc	r8,80003c6c <create_data_list+0x1e8>
80003b60:	10 9a       	mov	r10,r8
80003b62:	30 2b       	mov	r11,2
80003b64:	30 ac       	mov	r12,10
80003b66:	f0 1f 00 3d 	mcall	80003c58 <create_data_list+0x1d4>
80003b6a:	18 98       	mov	r8,r12
80003b6c:	ef 48 ff f0 	st.w	r7[-16],r8
			if(return_code == DF_OK) 
80003b70:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003b74:	58 08       	cp.w	r8,0
80003b76:	c6 21       	brne	80003c3a <create_data_list+0x1b6>
			{	
				//Calculates the offset address of the current stored voice
				if(current_voice_index != 0){
80003b78:	4b d8       	lddpc	r8,80003c6c <create_data_list+0x1e8>
80003b7a:	90 08       	ld.sh	r8,r8[0x0]
80003b7c:	58 08       	cp.w	r8,0
80003b7e:	c6 00       	breq	80003c3e <create_data_list+0x1ba>
									
					address = START_ADDRESS_OF_VOICE_INFO + ((current_voice_index -1)*VOICE_INFO_LENGTH);
80003b80:	4b b8       	lddpc	r8,80003c6c <create_data_list+0x1e8>
80003b82:	90 08       	ld.sh	r8,r8[0x0]
80003b84:	5c 78       	castu.h	r8
80003b86:	2f f8       	sub	r8,-1
80003b88:	a3 78       	lsl	r8,0x3
80003b8a:	ef 48 ff f8 	st.w	r7[-8],r8
					return_code = data_flash_read_block(address, VOICE_INFO_LENGTH, (U8 *)str);
80003b8e:	ee c8 00 1c 	sub	r8,r7,28
80003b92:	10 9a       	mov	r10,r8
80003b94:	30 8b       	mov	r11,8
80003b96:	ee fc ff f8 	ld.w	r12,r7[-8]
80003b9a:	f0 1f 00 30 	mcall	80003c58 <create_data_list+0x1d4>
80003b9e:	18 98       	mov	r8,r12
80003ba0:	ef 48 ff f0 	st.w	r7[-16],r8
					if(return_code == DF_OK)
80003ba4:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003ba8:	58 08       	cp.w	r8,0
80003baa:	c4 a1       	brne	80003c3e <create_data_list+0x1ba>
					{
						VoiceList_Info_t *ptr = (VoiceList_Info_t *)str;
80003bac:	ee c8 00 1c 	sub	r8,r7,28
80003bb0:	ef 48 ff fc 	st.w	r7[-4],r8
						if(ptr->numb == current_voice_index)
80003bb4:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003bb8:	11 89       	ld.ub	r9,r8[0x0]
80003bba:	a9 69       	lsl	r9,0x8
80003bbc:	11 98       	ld.ub	r8,r8[0x1]
80003bbe:	12 48       	or	r8,r9
80003bc0:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
80003bc4:	4a a8       	lddpc	r8,80003c6c <create_data_list+0x1e8>
80003bc6:	90 08       	ld.sh	r8,r8[0x0]
80003bc8:	f0 09 19 00 	cp.h	r9,r8
80003bcc:	c3 51       	brne	80003c36 <create_data_list+0x1b2>
						{
							current_save_voice_offset = ptr->address + ptr->offset;
80003bce:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003bd2:	11 a9       	ld.ub	r9,r8[0x2]
80003bd4:	b9 69       	lsl	r9,0x18
80003bd6:	11 ba       	ld.ub	r10,r8[0x3]
80003bd8:	b1 6a       	lsl	r10,0x10
80003bda:	f5 e9 10 09 	or	r9,r10,r9
80003bde:	11 ca       	ld.ub	r10,r8[0x4]
80003be0:	a9 6a       	lsl	r10,0x8
80003be2:	f5 e9 10 09 	or	r9,r10,r9
80003be6:	11 d8       	ld.ub	r8,r8[0x5]
80003be8:	12 48       	or	r8,r9
80003bea:	10 99       	mov	r9,r8
80003bec:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003bf0:	11 ea       	ld.ub	r10,r8[0x6]
80003bf2:	a9 6a       	lsl	r10,0x8
80003bf4:	11 f8       	ld.ub	r8,r8[0x7]
80003bf6:	14 48       	or	r8,r10
80003bf8:	5c 88       	casts.h	r8
80003bfa:	5c 78       	castu.h	r8
80003bfc:	10 09       	add	r9,r8
80003bfe:	49 d8       	lddpc	r8,80003c70 <create_data_list+0x1ec>
80003c00:	91 09       	st.w	r8[0x0],r9
							if(current_save_voice_offset > 0x7bc000){
80003c02:	49 c8       	lddpc	r8,80003c70 <create_data_list+0x1ec>
80003c04:	70 08       	ld.w	r8,r8[0x0]
80003c06:	e0 69 c0 00 	mov	r9,49152
80003c0a:	ea 19 00 7b 	orh	r9,0x7b
80003c0e:	12 38       	cp.w	r8,r9
80003c10:	e0 88 00 17 	brls	80003c3e <create_data_list+0x1ba>
								
								log("\r\n----voice storage is full!!!----\r\n");
80003c14:	49 8c       	lddpc	r12,80003c74 <create_data_list+0x1f0>
80003c16:	f0 1f 00 19 	mcall	80003c78 <create_data_list+0x1f4>
								//chip erase
								return_code = data_flash_erase_block(0, DF_BLOCK_ALL);
80003c1a:	30 4b       	mov	r11,4
80003c1c:	30 0c       	mov	r12,0
80003c1e:	f0 1f 00 12 	mcall	80003c64 <create_data_list+0x1e0>
80003c22:	18 98       	mov	r8,r12
80003c24:	ef 48 ff f0 	st.w	r7[-16],r8
								if(return_code == DF_ERASE_COMPLETED)goto start;
80003c28:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003c2c:	58 58       	cp.w	r8,5
80003c2e:	fe 90 ff 40 	breq	80003aae <create_data_list+0x2a>
								else
									return FALSE;																						
80003c32:	30 08       	mov	r8,0
80003c34:	c0 b8       	rjmp	80003c4a <create_data_list+0x1c6>
							}						
						}
						else
							return FALSE;		
80003c36:	30 08       	mov	r8,0
80003c38:	c0 98       	rjmp	80003c4a <create_data_list+0x1c6>
					}
				}
			}
			else
				return FALSE;
80003c3a:	30 08       	mov	r8,0
80003c3c:	c0 78       	rjmp	80003c4a <create_data_list+0x1c6>
		}
					
		flash_init_success_flag = 1;
80003c3e:	49 09       	lddpc	r9,80003c7c <create_data_list+0x1f8>
80003c40:	30 18       	mov	r8,1
80003c42:	b2 88       	st.b	r9[0x0],r8
		return TRUE;
80003c44:	30 18       	mov	r8,1
80003c46:	c0 28       	rjmp	80003c4a <create_data_list+0x1c6>
	}
	return FALSE;
80003c48:	30 08       	mov	r8,0

}
80003c4a:	10 9c       	mov	r12,r8
80003c4c:	2f 9d       	sub	sp,-28
80003c4e:	e3 cd 80 80 	ldm	sp++,r7,pc
80003c52:	00 00       	add	r0,r0
80003c54:	80 00       	ld.sh	r0,r0[0x0]
80003c56:	b6 aa       	st.b	r11[0x2],r10
80003c58:	80 00       	ld.sh	r0,r0[0x0]
80003c5a:	46 00       	lddsp	r0,sp[0x180]
80003c5c:	00 00       	add	r0,r0
80003c5e:	04 f4       	st.b	--r2,r4
80003c60:	80 00       	ld.sh	r0,r0[0x0]
80003c62:	b5 3c       	mul	r12,r10
80003c64:	80 00       	ld.sh	r0,r0[0x0]
80003c66:	40 ac       	lddsp	r12,sp[0x28]
80003c68:	80 00       	ld.sh	r0,r0[0x0]
80003c6a:	41 bc       	lddsp	r12,sp[0x6c]
80003c6c:	00 00       	add	r0,r0
80003c6e:	0a 7a       	tst	r10,r5
80003c70:	00 00       	add	r0,r0
80003c72:	04 fc       	st.b	--r2,r12
80003c74:	80 00       	ld.sh	r0,r0[0x0]
80003c76:	35 60       	mov	r0,86
80003c78:	80 00       	ld.sh	r0,r0[0x0]
80003c7a:	a8 70       	st.h	r4[0xe],r0
80003c7c:	00 00       	add	r0,r0
80003c7e:	0a 7c       	tst	r12,r5

80003c80 <save_voice_data>:
* ----------  --------  ----------  --------------------------------------------
* 20-Fri-17   Edwards    none        Initial draft
*
*******************************************************************************/
static Bool save_voice_data(void *data_ptr, U16 data_len, U8 voice_end_flag)
{
80003c80:	eb cd 40 80 	pushm	r7,lr
80003c84:	1a 97       	mov	r7,sp
80003c86:	20 6d       	sub	sp,24
80003c88:	ef 4c ff f0 	st.w	r7[-16],r12
80003c8c:	16 99       	mov	r9,r11
80003c8e:	14 98       	mov	r8,r10
80003c90:	ef 59 ff ec 	st.h	r7[-20],r9
80003c94:	ef 68 ff e8 	st.b	r7[-24],r8
	if(!flash_init_success_flag)return FALSE;
80003c98:	fe f8 02 94 	ld.w	r8,pc[660]
80003c9c:	11 88       	ld.ub	r8,r8[0x0]
80003c9e:	58 08       	cp.w	r8,0
80003ca0:	c0 31       	brne	80003ca6 <save_voice_data+0x26>
80003ca2:	30 08       	mov	r8,0
80003ca4:	c3 f9       	rjmp	80003f22 <save_voice_data+0x2a2>
	
	U32 address = 0;
80003ca6:	30 08       	mov	r8,0
80003ca8:	ef 48 ff f4 	st.w	r7[-12],r8
	static U32 bytes_remained = 0;
	VoiceList_Info_t *ptr = malloc(sizeof(VoiceList_Info_t));
80003cac:	30 8c       	mov	r12,8
80003cae:	f0 1f 00 a1 	mcall	80003f30 <save_voice_data+0x2b0>
80003cb2:	18 98       	mov	r8,r12
80003cb4:	ef 48 ff f8 	st.w	r7[-8],r8
	if(ptr ==NULL)return FALSE;
80003cb8:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003cbc:	58 08       	cp.w	r8,0
80003cbe:	c0 31       	brne	80003cc4 <save_voice_data+0x44>
80003cc0:	30 08       	mov	r8,0
80003cc2:	c3 09       	rjmp	80003f22 <save_voice_data+0x2a2>
	df_status_t return_code = DF_WRITE_COMPLETED;
80003cc4:	30 78       	mov	r8,7
80003cc6:	ef 48 ff fc 	st.w	r7[-4],r8
	
	bytes_remained+=data_len;//accumulate
80003cca:	ef 19 ff ec 	ld.uh	r9,r7[-20]
80003cce:	fe f8 02 66 	ld.w	r8,pc[614]
80003cd2:	70 08       	ld.w	r8,r8[0x0]
80003cd4:	10 09       	add	r9,r8
80003cd6:	fe f8 02 5e 	ld.w	r8,pc[606]
80003cda:	91 09       	st.w	r8[0x0],r9
	/* check input parameter */
	if (data_ptr == NULL || data_len > 0x1000)
80003cdc:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003ce0:	58 08       	cp.w	r8,0
80003ce2:	c0 90       	breq	80003cf4 <save_voice_data+0x74>
80003ce4:	ef 09 ff ec 	ld.sh	r9,r7[-20]
80003ce8:	e0 68 10 00 	mov	r8,4096
80003cec:	f0 09 19 00 	cp.h	r9,r8
80003cf0:	e0 88 00 0f 	brls	80003d0e <save_voice_data+0x8e>
	{
		if(ptr != NULL)
80003cf4:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003cf8:	58 08       	cp.w	r8,0
80003cfa:	c0 50       	breq	80003d04 <save_voice_data+0x84>
		free(ptr);
80003cfc:	ee fc ff f8 	ld.w	r12,r7[-8]
80003d00:	f0 1f 00 8e 	mcall	80003f38 <save_voice_data+0x2b8>
		ptr = NULL;
80003d04:	30 08       	mov	r8,0
80003d06:	ef 48 ff f8 	st.w	r7[-8],r8
		return FALSE;
80003d0a:	30 08       	mov	r8,0
80003d0c:	c0 b9       	rjmp	80003f22 <save_voice_data+0x2a2>
	}
	if(bytes_remained > 0xFFFF)//data size > 65535bytes == 64k,overout
80003d0e:	fe f8 02 26 	ld.w	r8,pc[550]
80003d12:	70 08       	ld.w	r8,r8[0x0]
80003d14:	e0 48 ff ff 	cp.w	r8,65535
80003d18:	e0 88 00 13 	brls	80003d3e <save_voice_data+0xbe>
	{
		bytes_remained = 0;
80003d1c:	fe f8 02 18 	ld.w	r8,pc[536]
80003d20:	30 09       	mov	r9,0
80003d22:	91 09       	st.w	r8[0x0],r9
		if(ptr != NULL)
80003d24:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003d28:	58 08       	cp.w	r8,0
80003d2a:	c0 50       	breq	80003d34 <save_voice_data+0xb4>
		free(ptr);
80003d2c:	ee fc ff f8 	ld.w	r12,r7[-8]
80003d30:	f0 1f 00 82 	mcall	80003f38 <save_voice_data+0x2b8>
		ptr = NULL;
80003d34:	30 08       	mov	r8,0
80003d36:	ef 48 ff f8 	st.w	r7[-8],r8
		return FALSE;
80003d3a:	30 08       	mov	r8,0
80003d3c:	cf 38       	rjmp	80003f22 <save_voice_data+0x2a2>
	}
	//save data
	if(current_save_voice_offset > DF_MAX_ADDR)//The voice data is out of bounds
80003d3e:	fe f8 01 fe 	ld.w	r8,pc[510]
80003d42:	70 08       	ld.w	r8,r8[0x0]
80003d44:	e0 69 ff ff 	mov	r9,65535
80003d48:	ea 19 00 7f 	orh	r9,0x7f
80003d4c:	12 38       	cp.w	r8,r9
80003d4e:	e0 88 00 0f 	brls	80003d6c <save_voice_data+0xec>
	{
		if(ptr != NULL)
80003d52:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003d56:	58 08       	cp.w	r8,0
80003d58:	c0 50       	breq	80003d62 <save_voice_data+0xe2>
		free(ptr);
80003d5a:	ee fc ff f8 	ld.w	r12,r7[-8]
80003d5e:	f0 1f 00 77 	mcall	80003f38 <save_voice_data+0x2b8>
		ptr = NULL;
80003d62:	30 08       	mov	r8,0
80003d64:	ef 48 ff f8 	st.w	r7[-8],r8
		return FALSE;
80003d68:	30 08       	mov	r8,0
80003d6a:	cd c8       	rjmp	80003f22 <save_voice_data+0x2a2>
		log("\r\n----voice data is Out of bounds!!!\r\n----");
	}
	return_code = data_flash_write((U8 *)data_ptr, current_save_voice_offset, data_len);
80003d6c:	ef 1a ff ec 	ld.uh	r10,r7[-20]
80003d70:	4f 38       	lddpc	r8,80003f3c <save_voice_data+0x2bc>
80003d72:	70 09       	ld.w	r9,r8[0x0]
80003d74:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003d78:	12 9b       	mov	r11,r9
80003d7a:	10 9c       	mov	r12,r8
80003d7c:	f0 1f 00 71 	mcall	80003f40 <save_voice_data+0x2c0>
80003d80:	18 98       	mov	r8,r12
80003d82:	ef 48 ff fc 	st.w	r7[-4],r8
	if(return_code != DF_WRITE_COMPLETED)
80003d86:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003d8a:	58 78       	cp.w	r8,7
80003d8c:	c0 e0       	breq	80003da8 <save_voice_data+0x128>
	{
		if(ptr != NULL)
80003d8e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003d92:	58 08       	cp.w	r8,0
80003d94:	c0 50       	breq	80003d9e <save_voice_data+0x11e>
		free(ptr);
80003d96:	ee fc ff f8 	ld.w	r12,r7[-8]
80003d9a:	f0 1f 00 68 	mcall	80003f38 <save_voice_data+0x2b8>
		ptr = NULL;
80003d9e:	30 08       	mov	r8,0
80003da0:	ef 48 ff f8 	st.w	r7[-8],r8
		return FALSE;
80003da4:	30 08       	mov	r8,0
80003da6:	cb e8       	rjmp	80003f22 <save_voice_data+0x2a2>
	}
	current_save_voice_offset+=data_len;
80003da8:	ef 19 ff ec 	ld.uh	r9,r7[-20]
80003dac:	4e 48       	lddpc	r8,80003f3c <save_voice_data+0x2bc>
80003dae:	70 08       	ld.w	r8,r8[0x0]
80003db0:	10 09       	add	r9,r8
80003db2:	4e 38       	lddpc	r8,80003f3c <save_voice_data+0x2bc>
80003db4:	91 09       	st.w	r8[0x0],r9
		
	if(voice_end_flag == TRUE)//save a voice-info into list at the end of the recording
80003db6:	ef 39 ff e8 	ld.ub	r9,r7[-24]
80003dba:	30 18       	mov	r8,1
80003dbc:	f0 09 18 00 	cp.b	r9,r8
80003dc0:	e0 81 00 a5 	brne	80003f0a <save_voice_data+0x28a>
	{
		current_voice_index++;
80003dc4:	4e 08       	lddpc	r8,80003f44 <save_voice_data+0x2c4>
80003dc6:	90 08       	ld.sh	r8,r8[0x0]
80003dc8:	2f f8       	sub	r8,-1
80003dca:	5c 88       	casts.h	r8
80003dcc:	4d e9       	lddpc	r9,80003f44 <save_voice_data+0x2c4>
80003dce:	b2 08       	st.h	r9[0x0],r8
		ptr->numb		= current_voice_index;
80003dd0:	4d d8       	lddpc	r8,80003f44 <save_voice_data+0x2c4>
80003dd2:	90 09       	ld.sh	r9,r8[0x0]
80003dd4:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003dd8:	f5 d9 c0 10 	bfextu	r10,r9,0x0,0x10
80003ddc:	a9 8a       	lsr	r10,0x8
80003dde:	5c 7a       	castu.h	r10
80003de0:	11 8b       	ld.ub	r11,r8[0x0]
80003de2:	e2 1b 00 00 	andl	r11,0x0,COH
80003de6:	f7 ea 10 0a 	or	r10,r11,r10
80003dea:	b0 8a       	st.b	r8[0x0],r10
80003dec:	5c 79       	castu.h	r9
80003dee:	f3 d9 c0 08 	bfextu	r9,r9,0x0,0x8
80003df2:	11 9a       	ld.ub	r10,r8[0x1]
80003df4:	e2 1a 00 00 	andl	r10,0x0,COH
80003df8:	f5 e9 10 09 	or	r9,r10,r9
80003dfc:	b0 99       	st.b	r8[0x1],r9
		ptr->address	= (current_save_voice_offset - bytes_remained);
80003dfe:	4d 08       	lddpc	r8,80003f3c <save_voice_data+0x2bc>
80003e00:	70 09       	ld.w	r9,r8[0x0]
80003e02:	4c d8       	lddpc	r8,80003f34 <save_voice_data+0x2b4>
80003e04:	70 08       	ld.w	r8,r8[0x0]
80003e06:	10 19       	sub	r9,r8
80003e08:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003e0c:	f2 0a 16 18 	lsr	r10,r9,0x18
80003e10:	11 ab       	ld.ub	r11,r8[0x2]
80003e12:	e2 1b 00 00 	andl	r11,0x0,COH
80003e16:	f7 ea 10 0a 	or	r10,r11,r10
80003e1a:	b0 aa       	st.b	r8[0x2],r10
80003e1c:	f2 0a 16 10 	lsr	r10,r9,0x10
80003e20:	f5 da c0 08 	bfextu	r10,r10,0x0,0x8
80003e24:	11 bb       	ld.ub	r11,r8[0x3]
80003e26:	e2 1b 00 00 	andl	r11,0x0,COH
80003e2a:	f7 ea 10 0a 	or	r10,r11,r10
80003e2e:	b0 ba       	st.b	r8[0x3],r10
80003e30:	f2 0a 16 08 	lsr	r10,r9,0x8
80003e34:	f5 da c0 08 	bfextu	r10,r10,0x0,0x8
80003e38:	11 cb       	ld.ub	r11,r8[0x4]
80003e3a:	e2 1b 00 00 	andl	r11,0x0,COH
80003e3e:	f7 ea 10 0a 	or	r10,r11,r10
80003e42:	b0 ca       	st.b	r8[0x4],r10
80003e44:	f3 d9 c0 08 	bfextu	r9,r9,0x0,0x8
80003e48:	11 da       	ld.ub	r10,r8[0x5]
80003e4a:	e2 1a 00 00 	andl	r10,0x0,COH
80003e4e:	f5 e9 10 09 	or	r9,r10,r9
80003e52:	b0 d9       	st.b	r8[0x5],r9
		ptr->offset		= bytes_remained;
80003e54:	4b 88       	lddpc	r8,80003f34 <save_voice_data+0x2b4>
80003e56:	70 08       	ld.w	r8,r8[0x0]
80003e58:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
80003e5c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003e60:	f5 d9 c0 10 	bfextu	r10,r9,0x0,0x10
80003e64:	a9 8a       	lsr	r10,0x8
80003e66:	5c 7a       	castu.h	r10
80003e68:	11 eb       	ld.ub	r11,r8[0x6]
80003e6a:	e2 1b 00 00 	andl	r11,0x0,COH
80003e6e:	f7 ea 10 0a 	or	r10,r11,r10
80003e72:	b0 ea       	st.b	r8[0x6],r10
80003e74:	5c 79       	castu.h	r9
80003e76:	f3 d9 c0 08 	bfextu	r9,r9,0x0,0x8
80003e7a:	11 fa       	ld.ub	r10,r8[0x7]
80003e7c:	e2 1a 00 00 	andl	r10,0x0,COH
80003e80:	f5 e9 10 09 	or	r9,r10,r9
80003e84:	b0 f9       	st.b	r8[0x7],r9
		
		address = START_ADDRESS_OF_VOICE_INFO + ((current_voice_index -1)*VOICE_INFO_LENGTH);
80003e86:	4b 08       	lddpc	r8,80003f44 <save_voice_data+0x2c4>
80003e88:	90 08       	ld.sh	r8,r8[0x0]
80003e8a:	5c 78       	castu.h	r8
80003e8c:	2f f8       	sub	r8,-1
80003e8e:	a3 78       	lsl	r8,0x3
80003e90:	ef 48 ff f4 	st.w	r7[-12],r8
		if(address > VOICE_LIST_BOUNDARY)//The number of messages is out of bounds
80003e94:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003e98:	e8 48 00 00 	cp.w	r8,524288
80003e9c:	e0 88 00 0f 	brls	80003eba <save_voice_data+0x23a>
		{
			if(ptr != NULL)
80003ea0:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003ea4:	58 08       	cp.w	r8,0
80003ea6:	c0 50       	breq	80003eb0 <save_voice_data+0x230>
			free(ptr);
80003ea8:	ee fc ff f8 	ld.w	r12,r7[-8]
80003eac:	f0 1f 00 23 	mcall	80003f38 <save_voice_data+0x2b8>
			ptr = NULL;
80003eb0:	30 08       	mov	r8,0
80003eb2:	ef 48 ff f8 	st.w	r7[-8],r8
			return FALSE;
80003eb6:	30 08       	mov	r8,0
80003eb8:	c3 58       	rjmp	80003f22 <save_voice_data+0x2a2>
			log("\r\n----info list is Out of bounds!!!\r\n----");
		}
		//set a voice info by current_voice_index
		return_code = data_flash_write((U8 *)ptr, address, VOICE_INFO_LENGTH);
80003eba:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003ebe:	30 8a       	mov	r10,8
80003ec0:	ee fb ff f4 	ld.w	r11,r7[-12]
80003ec4:	10 9c       	mov	r12,r8
80003ec6:	f0 1f 00 1f 	mcall	80003f40 <save_voice_data+0x2c0>
80003eca:	18 98       	mov	r8,r12
80003ecc:	ef 48 ff fc 	st.w	r7[-4],r8
		//set voice numbers
		return_code = data_flash_write(&current_voice_index, VOICE_NUMBERS_ADDRESS, VOICE_NUMBERS_LENGTH);
80003ed0:	49 d8       	lddpc	r8,80003f44 <save_voice_data+0x2c4>
80003ed2:	30 2a       	mov	r10,2
80003ed4:	30 ab       	mov	r11,10
80003ed6:	10 9c       	mov	r12,r8
80003ed8:	f0 1f 00 1a 	mcall	80003f40 <save_voice_data+0x2c0>
80003edc:	18 98       	mov	r8,r12
80003ede:	ef 48 ff fc 	st.w	r7[-4],r8
		if(return_code != DF_WRITE_COMPLETED)
80003ee2:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003ee6:	58 78       	cp.w	r8,7
80003ee8:	c0 e0       	breq	80003f04 <save_voice_data+0x284>
		{
			if(ptr != NULL)
80003eea:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003eee:	58 08       	cp.w	r8,0
80003ef0:	c0 50       	breq	80003efa <save_voice_data+0x27a>
			free(ptr);
80003ef2:	ee fc ff f8 	ld.w	r12,r7[-8]
80003ef6:	f0 1f 00 11 	mcall	80003f38 <save_voice_data+0x2b8>
			ptr = NULL;
80003efa:	30 08       	mov	r8,0
80003efc:	ef 48 ff f8 	st.w	r7[-8],r8
			return FALSE;
80003f00:	30 08       	mov	r8,0
80003f02:	c1 08       	rjmp	80003f22 <save_voice_data+0x2a2>
		}
		
		bytes_remained = 0;//reset 0		
80003f04:	48 c8       	lddpc	r8,80003f34 <save_voice_data+0x2b4>
80003f06:	30 09       	mov	r9,0
80003f08:	91 09       	st.w	r8[0x0],r9
	}
			
	if(ptr != NULL)
80003f0a:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003f0e:	58 08       	cp.w	r8,0
80003f10:	c0 50       	breq	80003f1a <save_voice_data+0x29a>
	free(ptr);
80003f12:	ee fc ff f8 	ld.w	r12,r7[-8]
80003f16:	f0 1f 00 09 	mcall	80003f38 <save_voice_data+0x2b8>
	ptr = NULL;
80003f1a:	30 08       	mov	r8,0
80003f1c:	ef 48 ff f8 	st.w	r7[-8],r8
	return TRUE;
80003f20:	30 18       	mov	r8,1

}
80003f22:	10 9c       	mov	r12,r8
80003f24:	2f ad       	sub	sp,-24
80003f26:	e3 cd 80 80 	ldm	sp++,r7,pc
80003f2a:	00 00       	add	r0,r0
80003f2c:	00 00       	add	r0,r0
80003f2e:	0a 7c       	tst	r12,r5
80003f30:	80 00       	ld.sh	r0,r0[0x0]
80003f32:	b0 f4       	st.b	r8[0x7],r4
80003f34:	00 00       	add	r0,r0
80003f36:	0a 80       	andn	r0,r5
80003f38:	80 00       	ld.sh	r0,r0[0x0]
80003f3a:	b0 e4       	st.b	r8[0x6],r4
80003f3c:	00 00       	add	r0,r0
80003f3e:	04 fc       	st.b	--r2,r12
80003f40:	80 00       	ld.sh	r0,r0[0x0]
80003f42:	41 bc       	lddsp	r12,sp[0x6c]
80003f44:	00 00       	add	r0,r0
80003f46:	0a 7a       	tst	r10,r5

80003f48 <playback_voice_data>:
*
*******************************************************************************/
U8 PLAYBACK_BUF[512];
static U8 playback_voice_data(U16 voice_index)
//static U32 read_voice_data(void *data_ptr, U16 voice_index, U8 *voice_end_flag)
{
80003f48:	eb cd 40 80 	pushm	r7,lr
80003f4c:	1a 97       	mov	r7,sp
80003f4e:	20 7d       	sub	sp,28
80003f50:	18 98       	mov	r8,r12
80003f52:	ef 58 ff e4 	st.h	r7[-28],r8
	if(!flash_init_success_flag)return FALSE;
80003f56:	4d 18       	lddpc	r8,80004098 <playback_voice_data+0x150>
80003f58:	11 88       	ld.ub	r8,r8[0x0]
80003f5a:	58 08       	cp.w	r8,0
80003f5c:	c0 31       	brne	80003f62 <playback_voice_data+0x1a>
80003f5e:	30 08       	mov	r8,0
80003f60:	c9 78       	rjmp	8000408e <playback_voice_data+0x146>
	
	/* check input parameter */
	if (voice_index >= current_voice_index)
80003f62:	4c f8       	lddpc	r8,8000409c <playback_voice_data+0x154>
80003f64:	90 08       	ld.sh	r8,r8[0x0]
80003f66:	ef 09 ff e4 	ld.sh	r9,r7[-28]
80003f6a:	f0 09 19 00 	cp.h	r9,r8
80003f6e:	c0 43       	brcs	80003f76 <playback_voice_data+0x2e>
	{
		return -1;
80003f70:	e0 68 00 ff 	mov	r8,255
80003f74:	c8 d8       	rjmp	8000408e <playback_voice_data+0x146>
	}
	df_status_t return_code = DF_OK;
80003f76:	30 08       	mov	r8,0
80003f78:	ef 48 ff f0 	st.w	r7[-16],r8
	unsigned int address =0x00000000;
80003f7c:	30 08       	mov	r8,0
80003f7e:	ef 48 ff f4 	st.w	r7[-12],r8
	char str[VOICE_INFO_LENGTH];
	memset(str, 0x00, sizeof(str));
80003f82:	ee c8 00 18 	sub	r8,r7,24
80003f86:	30 8a       	mov	r10,8
80003f88:	30 0b       	mov	r11,0
80003f8a:	10 9c       	mov	r12,r8
80003f8c:	f0 1f 00 45 	mcall	800040a0 <playback_voice_data+0x158>
	//find the voice storage info by voice_index
	address = START_ADDRESS_OF_VOICE_INFO + ((voice_index -1)*VOICE_INFO_LENGTH);
80003f90:	ef 18 ff e4 	ld.uh	r8,r7[-28]
80003f94:	2f f8       	sub	r8,-1
80003f96:	a3 78       	lsl	r8,0x3
80003f98:	ef 48 ff f4 	st.w	r7[-12],r8
	return_code = data_flash_read_block(address, VOICE_INFO_LENGTH, (U8 *)str);
80003f9c:	ee c8 00 18 	sub	r8,r7,24
80003fa0:	10 9a       	mov	r10,r8
80003fa2:	30 8b       	mov	r11,8
80003fa4:	ee fc ff f4 	ld.w	r12,r7[-12]
80003fa8:	f0 1f 00 3f 	mcall	800040a4 <playback_voice_data+0x15c>
80003fac:	18 98       	mov	r8,r12
80003fae:	ef 48 ff f0 	st.w	r7[-16],r8
	if (return_code == DF_OK)
80003fb2:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003fb6:	58 08       	cp.w	r8,0
80003fb8:	c6 91       	brne	8000408a <playback_voice_data+0x142>
	{
		U16 bytes_remained;
		VoiceList_Info_t *ptr = (VoiceList_Info_t *)str;	
80003fba:	ee c8 00 18 	sub	r8,r7,24
80003fbe:	ef 48 ff fc 	st.w	r7[-4],r8
		if(ptr->numb == voice_index)
80003fc2:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003fc6:	11 89       	ld.ub	r9,r8[0x0]
80003fc8:	a9 69       	lsl	r9,0x8
80003fca:	11 98       	ld.ub	r8,r8[0x1]
80003fcc:	12 48       	or	r8,r9
80003fce:	5c 88       	casts.h	r8
80003fd0:	ef 09 ff e4 	ld.sh	r9,r7[-28]
80003fd4:	f0 09 19 00 	cp.h	r9,r8
80003fd8:	c5 91       	brne	8000408a <playback_voice_data+0x142>
		{
			bytes_remained = ptr->offset;
80003fda:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003fde:	11 e9       	ld.ub	r9,r8[0x6]
80003fe0:	a9 69       	lsl	r9,0x8
80003fe2:	11 f8       	ld.ub	r8,r8[0x7]
80003fe4:	12 48       	or	r8,r9
80003fe6:	ef 58 ff fa 	st.h	r7[-6],r8
			address = ptr->address;
80003fea:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003fee:	11 a9       	ld.ub	r9,r8[0x2]
80003ff0:	b9 69       	lsl	r9,0x18
80003ff2:	11 ba       	ld.ub	r10,r8[0x3]
80003ff4:	b1 6a       	lsl	r10,0x10
80003ff6:	f5 e9 10 09 	or	r9,r10,r9
80003ffa:	11 ca       	ld.ub	r10,r8[0x4]
80003ffc:	a9 6a       	lsl	r10,0x8
80003ffe:	f5 e9 10 09 	or	r9,r10,r9
80004002:	11 d8       	ld.ub	r8,r8[0x5]
80004004:	12 48       	or	r8,r9
80004006:	ef 48 ff f4 	st.w	r7[-12],r8
			
			while (bytes_remained >= 1 && return_code == DF_OK)
8000400a:	c3 48       	rjmp	80004072 <playback_voice_data+0x12a>
			{
				if(bytes_remained < DF_DATA_SPACE_SIZE)//< 512bytes
8000400c:	ef 09 ff fa 	ld.sh	r9,r7[-6]
80004010:	e0 68 01 ff 	mov	r8,511
80004014:	f0 09 19 00 	cp.h	r9,r8
80004018:	e0 8b 00 11 	brhi	8000403a <playback_voice_data+0xf2>
				{
					return_code = data_flash_read_block(address, bytes_remained, PLAYBACK_BUF);
8000401c:	ef 18 ff fa 	ld.uh	r8,r7[-6]
80004020:	4a 2a       	lddpc	r10,800040a8 <playback_voice_data+0x160>
80004022:	10 9b       	mov	r11,r8
80004024:	ee fc ff f4 	ld.w	r12,r7[-12]
80004028:	f0 1f 00 1f 	mcall	800040a4 <playback_voice_data+0x15c>
8000402c:	18 98       	mov	r8,r12
8000402e:	ef 48 ff f0 	st.w	r7[-16],r8
					bytes_remained = 0;	/* end while loop */
80004032:	30 08       	mov	r8,0
80004034:	ef 58 ff fa 	st.h	r7[-6],r8
80004038:	c1 78       	rjmp	80004066 <playback_voice_data+0x11e>

				}
				else//bytes_remained > DF_DATA_SPACE_SIZE
				{
					return_code = data_flash_read_block(address, DF_DATA_SPACE_SIZE, PLAYBACK_BUF);
8000403a:	49 ca       	lddpc	r10,800040a8 <playback_voice_data+0x160>
8000403c:	e0 6b 02 00 	mov	r11,512
80004040:	ee fc ff f4 	ld.w	r12,r7[-12]
80004044:	f0 1f 00 18 	mcall	800040a4 <playback_voice_data+0x15c>
80004048:	18 98       	mov	r8,r12
8000404a:	ef 48 ff f0 	st.w	r7[-16],r8
					bytes_remained-=DF_DATA_SPACE_SIZE;
8000404e:	ef 08 ff fa 	ld.sh	r8,r7[-6]
80004052:	f0 c8 02 00 	sub	r8,r8,512
80004056:	ef 58 ff fa 	st.h	r7[-6],r8
					address+=DF_DATA_SPACE_SIZE;
8000405a:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000405e:	f0 c8 fe 00 	sub	r8,r8,-512
80004062:	ef 48 ff f4 	st.w	r7[-12],r8
					
				}
				memset(PLAYBACK_BUF, 0x00, DF_DATA_SPACE_SIZE);
80004066:	e0 6a 02 00 	mov	r10,512
8000406a:	30 0b       	mov	r11,0
8000406c:	48 fc       	lddpc	r12,800040a8 <playback_voice_data+0x160>
8000406e:	f0 1f 00 0d 	mcall	800040a0 <playback_voice_data+0x158>
		if(ptr->numb == voice_index)
		{
			bytes_remained = ptr->offset;
			address = ptr->address;
			
			while (bytes_remained >= 1 && return_code == DF_OK)
80004072:	ef 09 ff fa 	ld.sh	r9,r7[-6]
80004076:	30 08       	mov	r8,0
80004078:	f0 09 19 00 	cp.h	r9,r8
8000407c:	c0 50       	breq	80004086 <playback_voice_data+0x13e>
8000407e:	ee f8 ff f0 	ld.w	r8,r7[-16]
80004082:	58 08       	cp.w	r8,0
80004084:	cc 40       	breq	8000400c <playback_voice_data+0xc4>
					address+=DF_DATA_SPACE_SIZE;
					
				}
				memset(PLAYBACK_BUF, 0x00, DF_DATA_SPACE_SIZE);
			}
			return TRUE;	
80004086:	30 18       	mov	r8,1
80004088:	c0 38       	rjmp	8000408e <playback_voice_data+0x146>
		}
	}
	
	return -1;
8000408a:	e0 68 00 ff 	mov	r8,255
			return -1;
	}

#endif
	
}
8000408e:	10 9c       	mov	r12,r8
80004090:	2f 9d       	sub	sp,-28
80004092:	e3 cd 80 80 	ldm	sp++,r7,pc
80004096:	00 00       	add	r0,r0
80004098:	00 00       	add	r0,r0
8000409a:	0a 7c       	tst	r12,r5
8000409c:	00 00       	add	r0,r0
8000409e:	0a 7a       	tst	r10,r5
800040a0:	80 00       	ld.sh	r0,r0[0x0]
800040a2:	b6 aa       	st.b	r11[0x2],r10
800040a4:	80 00       	ld.sh	r0,r0[0x0]
800040a6:	46 00       	lddsp	r0,sp[0x180]
800040a8:	00 00       	add	r0,r0
800040aa:	1d a4       	ld.ub	r4,lr[0x2]

800040ac <data_flash_erase_block>:
* ----------  --------  ----------  --------------------------------------------
* 25-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_erase_block(U32 address, df_block_size_t block_size)
{
800040ac:	eb cd 40 80 	pushm	r7,lr
800040b0:	1a 97       	mov	r7,sp
800040b2:	20 5d       	sub	sp,20
800040b4:	ef 4c ff f0 	st.w	r7[-16],r12
800040b8:	ef 4b ff ec 	st.w	r7[-20],r11
	U16 status = 1;
800040bc:	30 18       	mov	r8,1
800040be:	ef 58 ff f4 	st.h	r7[-12],r8
	U16 erase_commond;
	df_status_t return_code = DF_ERASE_FAIL;
800040c2:	30 48       	mov	r8,4
800040c4:	ef 48 ff f8 	st.w	r7[-8],r8
	U16 count = 0; /* to monitor erase time consumption */
800040c8:	30 08       	mov	r8,0
800040ca:	ef 58 ff fe 	st.h	r7[-2],r8

	/* check input parameter */
	if (address >= DF_MAX_ADDR)
800040ce:	ee f8 ff f0 	ld.w	r8,r7[-16]
800040d2:	e0 69 ff fe 	mov	r9,65534
800040d6:	ea 19 00 7f 	orh	r9,0x7f
800040da:	12 38       	cp.w	r8,r9
800040dc:	e0 88 00 04 	brls	800040e4 <data_flash_erase_block+0x38>
	{
		return DF_INVALID_PARAM;
800040e0:	30 18       	mov	r8,1
800040e2:	c6 78       	rjmp	800041b0 <data_flash_erase_block+0x104>
	}

	/* determine erase command to be issued */
	if (block_size == DF_BLOCK_4KB)
800040e4:	ee f8 ff ec 	ld.w	r8,r7[-20]
800040e8:	58 18       	cp.w	r8,1
800040ea:	c0 51       	brne	800040f4 <data_flash_erase_block+0x48>
		erase_commond = BLOCK_ERASE_4KB;
800040ec:	32 08       	mov	r8,32
800040ee:	ef 58 ff f6 	st.h	r7[-10],r8
800040f2:	c1 58       	rjmp	8000411c <data_flash_erase_block+0x70>
	else if (block_size == DF_BLOCK_32KB)
800040f4:	ee f8 ff ec 	ld.w	r8,r7[-20]
800040f8:	58 28       	cp.w	r8,2
800040fa:	c0 51       	brne	80004104 <data_flash_erase_block+0x58>
		erase_commond = BLOCK_ERASE_32KB;
800040fc:	35 28       	mov	r8,82
800040fe:	ef 58 ff f6 	st.h	r7[-10],r8
80004102:	c0 d8       	rjmp	8000411c <data_flash_erase_block+0x70>
	else if(block_size == DF_BLOCK_64KB)
80004104:	ee f8 ff ec 	ld.w	r8,r7[-20]
80004108:	58 38       	cp.w	r8,3
8000410a:	c0 61       	brne	80004116 <data_flash_erase_block+0x6a>
		erase_commond = BLOCK_ERASE_64KB;
8000410c:	e0 68 00 d8 	mov	r8,216
80004110:	ef 58 ff f6 	st.h	r7[-10],r8
80004114:	c0 48       	rjmp	8000411c <data_flash_erase_block+0x70>
	else/*(block_size == DF_BLOCK_ALL)*/
		erase_commond = CHIP_ERASE;
80004116:	36 08       	mov	r8,96
80004118:	ef 58 ff f6 	st.h	r7[-10],r8

	status = send_flash_command(READ_STATUS_REG, 0, NULL, 0);
8000411c:	30 09       	mov	r9,0
8000411e:	30 0a       	mov	r10,0
80004120:	30 0b       	mov	r11,0
80004122:	30 5c       	mov	r12,5
80004124:	f0 1f 00 25 	mcall	800041b8 <data_flash_erase_block+0x10c>
80004128:	18 98       	mov	r8,r12
8000412a:	5c 88       	casts.h	r8
8000412c:	ef 58 ff f4 	st.h	r7[-12],r8
	if ((status & STATUS_BUSY) != 0)
80004130:	ef 18 ff f4 	ld.uh	r8,r7[-12]
80004134:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80004138:	5c 58       	castu.b	r8
8000413a:	c0 30       	breq	80004140 <data_flash_erase_block+0x94>
	{
		return DF_DEVICE_BUSY;
8000413c:	30 28       	mov	r8,2
8000413e:	c3 98       	rjmp	800041b0 <data_flash_erase_block+0x104>
	}

	/* send WRITE_ENABLE command */
	send_flash_command(WRITE_ENABLE, 0, NULL, 0);
80004140:	30 09       	mov	r9,0
80004142:	30 0a       	mov	r10,0
80004144:	30 0b       	mov	r11,0
80004146:	30 6c       	mov	r12,6
80004148:	f0 1f 00 1c 	mcall	800041b8 <data_flash_erase_block+0x10c>

	/* send BLOCK_ERASE command */
	send_flash_command(erase_commond, address, NULL, 0);
8000414c:	ef 18 ff f6 	ld.uh	r8,r7[-10]
80004150:	30 09       	mov	r9,0
80004152:	30 0a       	mov	r10,0
80004154:	ee fb ff f0 	ld.w	r11,r7[-16]
80004158:	10 9c       	mov	r12,r8
8000415a:	f0 1f 00 18 	mcall	800041b8 <data_flash_erase_block+0x10c>
	do {
		status = send_flash_command(READ_STATUS_REG, 0, NULL, 0);
8000415e:	30 09       	mov	r9,0
80004160:	30 0a       	mov	r10,0
80004162:	30 0b       	mov	r11,0
80004164:	30 5c       	mov	r12,5
80004166:	f0 1f 00 15 	mcall	800041b8 <data_flash_erase_block+0x10c>
8000416a:	18 98       	mov	r8,r12
8000416c:	5c 88       	casts.h	r8
8000416e:	ef 58 ff f4 	st.h	r7[-12],r8
		count++;
80004172:	ef 08 ff fe 	ld.sh	r8,r7[-2]
80004176:	2f f8       	sub	r8,-1
80004178:	ef 58 ff fe 	st.h	r7[-2],r8
	} while((status & STATUS_BUSY) != 0);
8000417c:	ef 18 ff f4 	ld.uh	r8,r7[-12]
80004180:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80004184:	5c 58       	castu.b	r8
80004186:	ce c1       	brne	8000415e <data_flash_erase_block+0xb2>

	/*  Check Status Register */
	if ((status & STATUS_ERASE_PROG_ERROR) != 0)
80004188:	ef 18 ff f4 	ld.uh	r8,r7[-12]
8000418c:	e2 18 00 20 	andl	r8,0x20,COH
80004190:	c0 50       	breq	8000419a <data_flash_erase_block+0xee>
	{
		return_code = DF_ERASE_FAIL;
80004192:	30 48       	mov	r8,4
80004194:	ef 48 ff f8 	st.w	r7[-8],r8
80004198:	c0 48       	rjmp	800041a0 <data_flash_erase_block+0xf4>
	}
#endif
	else
	{
		/*  Erase Successful.  */
		return_code = DF_ERASE_COMPLETED;
8000419a:	30 58       	mov	r8,5
8000419c:	ef 48 ff f8 	st.w	r7[-8],r8
	}

	/* send WRITE_DISABLE command */
	send_flash_command(WRITE_DISABLE, 0, NULL, 0);
800041a0:	30 09       	mov	r9,0
800041a2:	30 0a       	mov	r10,0
800041a4:	30 0b       	mov	r11,0
800041a6:	30 4c       	mov	r12,4
800041a8:	f0 1f 00 04 	mcall	800041b8 <data_flash_erase_block+0x10c>

	return return_code;
800041ac:	ee f8 ff f8 	ld.w	r8,r7[-8]
}
800041b0:	10 9c       	mov	r12,r8
800041b2:	2f bd       	sub	sp,-20
800041b4:	e3 cd 80 80 	ldm	sp++,r7,pc
800041b8:	80 00       	ld.sh	r0,r0[0x0]
800041ba:	37 ac       	mov	r12,122

800041bc <data_flash_write>:
* ----------  --------  ----------  --------------------------------------------
* 25-Fri-17   Edwards    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_write(U8 *data_ptr, U32 address, U16 data_length)
{
800041bc:	eb cd 40 80 	pushm	r7,lr
800041c0:	1a 97       	mov	r7,sp
800041c2:	20 7d       	sub	sp,28
800041c4:	ef 4c ff ec 	st.w	r7[-20],r12
800041c8:	ef 4b ff e8 	st.w	r7[-24],r11
800041cc:	14 98       	mov	r8,r10
800041ce:	ef 58 ff e4 	st.h	r7[-28],r8
	U32 secpos;
	U16 secoff;
	U16 secremain;
	U16 i;
	df_status_t return_code = DF_OK;
800041d2:	30 08       	mov	r8,0
800041d4:	ef 48 ff fc 	st.w	r7[-4],r8

	secpos	=	address/4096;// 0~2047 for AT25DF641 
800041d8:	ee f8 ff e8 	ld.w	r8,r7[-24]
800041dc:	ad 88       	lsr	r8,0xc
800041de:	ef 48 ff f0 	st.w	r7[-16],r8
	secoff	=	address%4096;//
800041e2:	ee f8 ff e8 	ld.w	r8,r7[-24]
800041e6:	5c 88       	casts.h	r8
800041e8:	f1 d8 c0 0c 	bfextu	r8,r8,0x0,0xc
800041ec:	ef 58 ff f6 	st.h	r7[-10],r8
	secremain	=	4096-secoff;//
800041f0:	ef 08 ff f6 	ld.sh	r8,r7[-10]
800041f4:	e0 69 10 00 	mov	r9,4096
800041f8:	10 19       	sub	r9,r8
800041fa:	ef 59 ff f8 	st.h	r7[-8],r9
	if(data_length <= secremain)secremain = data_length;//4096
800041fe:	ef 09 ff e4 	ld.sh	r9,r7[-28]
80004202:	ef 08 ff f8 	ld.sh	r8,r7[-8]
80004206:	f0 09 19 00 	cp.h	r9,r8
8000420a:	e0 8b 00 06 	brhi	80004216 <data_flash_write+0x5a>
8000420e:	ef 08 ff e4 	ld.sh	r8,r7[-28]
80004212:	ef 58 ff f8 	st.h	r7[-8],r8
	while(1)
	{
		data_flash_read_block(secpos*4096, 4096, FLASH_BUF);//
80004216:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000421a:	ad 68       	lsl	r8,0xc
8000421c:	4d 7a       	lddpc	r10,80004378 <data_flash_write+0x1bc>
8000421e:	e0 6b 10 00 	mov	r11,4096
80004222:	10 9c       	mov	r12,r8
80004224:	f0 1f 00 56 	mcall	8000437c <data_flash_write+0x1c0>
		for(i=0; i<secremain; i++)//
80004228:	30 08       	mov	r8,0
8000422a:	ef 58 ff fa 	st.h	r7[-6],r8
8000422e:	c1 38       	rjmp	80004254 <data_flash_write+0x98>
		{
			if(FLASH_BUF[secoff+i]!=0XFF)break;//
80004230:	ef 19 ff f6 	ld.uh	r9,r7[-10]
80004234:	ef 18 ff fa 	ld.uh	r8,r7[-6]
80004238:	f2 08 00 08 	add	r8,r9,r8
8000423c:	4c f9       	lddpc	r9,80004378 <data_flash_write+0x1bc>
8000423e:	f2 08 07 09 	ld.ub	r9,r9[r8]
80004242:	3f f8       	mov	r8,-1
80004244:	f0 09 18 00 	cp.b	r9,r8
80004248:	c0 e1       	brne	80004264 <data_flash_write+0xa8>
	secremain	=	4096-secoff;//
	if(data_length <= secremain)secremain = data_length;//4096
	while(1)
	{
		data_flash_read_block(secpos*4096, 4096, FLASH_BUF);//
		for(i=0; i<secremain; i++)//
8000424a:	ef 08 ff fa 	ld.sh	r8,r7[-6]
8000424e:	2f f8       	sub	r8,-1
80004250:	ef 58 ff fa 	st.h	r7[-6],r8
80004254:	ef 09 ff fa 	ld.sh	r9,r7[-6]
80004258:	ef 08 ff f8 	ld.sh	r8,r7[-8]
8000425c:	f0 09 19 00 	cp.h	r9,r8
80004260:	ce 83       	brcs	80004230 <data_flash_write+0x74>
80004262:	c0 28       	rjmp	80004266 <data_flash_write+0xaa>
		{
			if(FLASH_BUF[secoff+i]!=0XFF)break;//
80004264:	d7 03       	nop
		}
		if(i < secremain)//
80004266:	ef 09 ff fa 	ld.sh	r9,r7[-6]
8000426a:	ef 08 ff f8 	ld.sh	r8,r7[-8]
8000426e:	f0 09 19 00 	cp.h	r9,r8
80004272:	c3 72       	brcc	800042e0 <data_flash_write+0x124>
		{
			return_code = data_flash_erase_block(secpos*4096, DF_BLOCK_4KB);//
80004274:	ee f8 ff f0 	ld.w	r8,r7[-16]
80004278:	ad 68       	lsl	r8,0xc
8000427a:	30 1b       	mov	r11,1
8000427c:	10 9c       	mov	r12,r8
8000427e:	f0 1f 00 41 	mcall	80004380 <data_flash_write+0x1c4>
80004282:	18 98       	mov	r8,r12
80004284:	ef 48 ff fc 	st.w	r7[-4],r8
			for(i=0; i<secremain; i++)	   //
80004288:	30 08       	mov	r8,0
8000428a:	ef 58 ff fa 	st.h	r7[-6],r8
8000428e:	c1 58       	rjmp	800042b8 <data_flash_write+0xfc>
			{
				FLASH_BUF[i+secoff]=data_ptr[i];
80004290:	ef 19 ff fa 	ld.uh	r9,r7[-6]
80004294:	ef 18 ff f6 	ld.uh	r8,r7[-10]
80004298:	10 09       	add	r9,r8
8000429a:	ef 18 ff fa 	ld.uh	r8,r7[-6]
8000429e:	ee fa ff ec 	ld.w	r10,r7[-20]
800042a2:	f4 08 00 08 	add	r8,r10,r8
800042a6:	11 88       	ld.ub	r8,r8[0x0]
800042a8:	4b 4a       	lddpc	r10,80004378 <data_flash_write+0x1bc>
800042aa:	f4 09 0b 08 	st.b	r10[r9],r8
			if(FLASH_BUF[secoff+i]!=0XFF)break;//
		}
		if(i < secremain)//
		{
			return_code = data_flash_erase_block(secpos*4096, DF_BLOCK_4KB);//
			for(i=0; i<secremain; i++)	   //
800042ae:	ef 08 ff fa 	ld.sh	r8,r7[-6]
800042b2:	2f f8       	sub	r8,-1
800042b4:	ef 58 ff fa 	st.h	r7[-6],r8
800042b8:	ef 09 ff fa 	ld.sh	r9,r7[-6]
800042bc:	ef 08 ff f8 	ld.sh	r8,r7[-8]
800042c0:	f0 09 19 00 	cp.h	r9,r8
800042c4:	ce 63       	brcs	80004290 <data_flash_write+0xd4>
			{
				FLASH_BUF[i+secoff]=data_ptr[i];
			}
			return_code = data_flash_write_block(FLASH_BUF, secpos*4096, 4096);//
800042c6:	ee f8 ff f0 	ld.w	r8,r7[-16]
800042ca:	ad 68       	lsl	r8,0xc
800042cc:	e0 6a 10 00 	mov	r10,4096
800042d0:	10 9b       	mov	r11,r8
800042d2:	4a ac       	lddpc	r12,80004378 <data_flash_write+0x1bc>
800042d4:	f0 1f 00 2c 	mcall	80004384 <data_flash_write+0x1c8>
800042d8:	18 98       	mov	r8,r12
800042da:	ef 48 ff fc 	st.w	r7[-4],r8
800042de:	c0 d8       	rjmp	800042f8 <data_flash_write+0x13c>

		}
		else 
		{
			return_code = data_flash_write_block(data_ptr, address, secremain);//,.
800042e0:	ef 18 ff f8 	ld.uh	r8,r7[-8]
800042e4:	10 9a       	mov	r10,r8
800042e6:	ee fb ff e8 	ld.w	r11,r7[-24]
800042ea:	ee fc ff ec 	ld.w	r12,r7[-20]
800042ee:	f0 1f 00 26 	mcall	80004384 <data_flash_write+0x1c8>
800042f2:	18 98       	mov	r8,r12
800042f4:	ef 48 ff fc 	st.w	r7[-4],r8
		}
		if(data_length==secremain)break;//
800042f8:	ef 09 ff e4 	ld.sh	r9,r7[-28]
800042fc:	ef 08 ff f8 	ld.sh	r8,r7[-8]
80004300:	f0 09 19 00 	cp.h	r9,r8
80004304:	c0 71       	brne	80004312 <data_flash_write+0x156>
			if(data_length>4096)secremain=4096;	//
			else secremain=data_length;			//
		}
	}
	
	return return_code;
80004306:	ee f8 ff fc 	ld.w	r8,r7[-4]
	
}
8000430a:	10 9c       	mov	r12,r8
8000430c:	2f 9d       	sub	sp,-28
8000430e:	e3 cd 80 80 	ldm	sp++,r7,pc
			return_code = data_flash_write_block(data_ptr, address, secremain);//,.
		}
		if(data_length==secremain)break;//
		else//
		{
			secpos++;//1
80004312:	ee f8 ff f0 	ld.w	r8,r7[-16]
80004316:	2f f8       	sub	r8,-1
80004318:	ef 48 ff f0 	st.w	r7[-16],r8
			secoff=0;//0
8000431c:	30 08       	mov	r8,0
8000431e:	ef 58 ff f6 	st.h	r7[-10],r8

			data_ptr+=secremain;  //
80004322:	ef 18 ff f8 	ld.uh	r8,r7[-8]
80004326:	ee f9 ff ec 	ld.w	r9,r7[-20]
8000432a:	f2 08 00 08 	add	r8,r9,r8
8000432e:	ef 48 ff ec 	st.w	r7[-20],r8
			address+=secremain;//
80004332:	ef 18 ff f8 	ld.uh	r8,r7[-8]
80004336:	ee f9 ff e8 	ld.w	r9,r7[-24]
8000433a:	f2 08 00 08 	add	r8,r9,r8
8000433e:	ef 48 ff e8 	st.w	r7[-24],r8
			data_length-=secremain;				//
80004342:	ef 09 ff e4 	ld.sh	r9,r7[-28]
80004346:	ef 08 ff f8 	ld.sh	r8,r7[-8]
8000434a:	f2 08 01 08 	sub	r8,r9,r8
8000434e:	ef 58 ff e4 	st.h	r7[-28],r8
			if(data_length>4096)secremain=4096;	//
80004352:	ef 09 ff e4 	ld.sh	r9,r7[-28]
80004356:	e0 68 10 00 	mov	r8,4096
8000435a:	f0 09 19 00 	cp.h	r9,r8
8000435e:	e0 88 00 07 	brls	8000436c <data_flash_write+0x1b0>
80004362:	e0 68 10 00 	mov	r8,4096
80004366:	ef 58 ff f8 	st.h	r7[-8],r8
			else secremain=data_length;			//
		}
	}
8000436a:	c5 6b       	rjmp	80004216 <data_flash_write+0x5a>

			data_ptr+=secremain;  //
			address+=secremain;//
			data_length-=secremain;				//
			if(data_length>4096)secremain=4096;	//
			else secremain=data_length;			//
8000436c:	ef 08 ff e4 	ld.sh	r8,r7[-28]
80004370:	ef 58 ff f8 	st.h	r7[-8],r8
		}
	}
80004374:	c5 1b       	rjmp	80004216 <data_flash_write+0x5a>
80004376:	00 00       	add	r0,r0
80004378:	00 00       	add	r0,r0
8000437a:	0d a4       	ld.ub	r4,r6[0x2]
8000437c:	80 00       	ld.sh	r0,r0[0x0]
8000437e:	46 00       	lddsp	r0,sp[0x180]
80004380:	80 00       	ld.sh	r0,r0[0x0]
80004382:	40 ac       	lddsp	r12,sp[0x28]
80004384:	80 00       	ld.sh	r0,r0[0x0]
80004386:	43 88       	lddsp	r8,sp[0xe0]

80004388 <data_flash_write_block>:
* ----------  --------  ----------  --------------------------------------------
* 25-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_write_block(U8 *data_ptr, U32 address, U16 data_length)
{
80004388:	eb cd 40 80 	pushm	r7,lr
8000438c:	1a 97       	mov	r7,sp
8000438e:	20 6d       	sub	sp,24
80004390:	ef 4c ff f0 	st.w	r7[-16],r12
80004394:	ef 4b ff ec 	st.w	r7[-20],r11
80004398:	14 98       	mov	r8,r10
8000439a:	ef 58 ff e8 	st.h	r7[-24],r8
	df_status_t return_code = DF_WRITE_COMPLETED;
8000439e:	30 78       	mov	r8,7
800043a0:	ef 48 ff f4 	st.w	r7[-12],r8
	U32 write_addr = address;
800043a4:	ee f8 ff ec 	ld.w	r8,r7[-20]
800043a8:	ef 48 ff f8 	st.w	r7[-8],r8
	U16 bytes_remained = data_length;
800043ac:	ef 08 ff e8 	ld.sh	r8,r7[-24]
800043b0:	ef 58 ff fe 	st.h	r7[-2],r8

	while (bytes_remained >= 1 && return_code == DF_WRITE_COMPLETED)
800043b4:	c9 78       	rjmp	800044e2 <data_flash_write_block+0x15a>
	{
		if ((write_addr & 0xFF) == 0)
800043b6:	ee f8 ff f8 	ld.w	r8,r7[-8]
800043ba:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
800043be:	c3 71       	brne	8000442c <data_flash_write_block+0xa4>
		{
			/* address 256 bytes aligned */

			if (bytes_remained <= DF_PAGE_SIZE)
800043c0:	ef 09 ff fe 	ld.sh	r9,r7[-2]
800043c4:	e0 68 01 00 	mov	r8,256
800043c8:	f0 09 19 00 	cp.h	r9,r8
800043cc:	e0 8b 00 12 	brhi	800043f0 <data_flash_write_block+0x68>
			{
				/* bytes remained less than one page */
				return_code = data_flash_write_page(data_ptr, write_addr, bytes_remained);
800043d0:	ef 18 ff fe 	ld.uh	r8,r7[-2]
800043d4:	10 9a       	mov	r10,r8
800043d6:	ee fb ff f8 	ld.w	r11,r7[-8]
800043da:	ee fc ff f0 	ld.w	r12,r7[-16]
800043de:	f0 1f 00 4a 	mcall	80004504 <data_flash_write_block+0x17c>
800043e2:	18 98       	mov	r8,r12
800043e4:	ef 48 ff f4 	st.w	r7[-12],r8
				bytes_remained = 0;	/* end while loop */
800043e8:	30 08       	mov	r8,0
800043ea:	ef 58 ff fe 	st.h	r7[-2],r8
800043ee:	c7 a8       	rjmp	800044e2 <data_flash_write_block+0x15a>
			}
			else /* (bytes_remained > DF_PAGE_SIZE) */
			{
				/* bytes remained more than one page */
				return_code = data_flash_write_page(data_ptr, write_addr, DF_PAGE_SIZE);
800043f0:	e0 6a 01 00 	mov	r10,256
800043f4:	ee fb ff f8 	ld.w	r11,r7[-8]
800043f8:	ee fc ff f0 	ld.w	r12,r7[-16]
800043fc:	f0 1f 00 42 	mcall	80004504 <data_flash_write_block+0x17c>
80004400:	18 98       	mov	r8,r12
80004402:	ef 48 ff f4 	st.w	r7[-12],r8
				bytes_remained -= DF_PAGE_SIZE;
80004406:	ef 08 ff fe 	ld.sh	r8,r7[-2]
8000440a:	f0 c8 01 00 	sub	r8,r8,256
8000440e:	ef 58 ff fe 	st.h	r7[-2],r8
				data_ptr += DF_PAGE_SIZE;
80004412:	ee f8 ff f0 	ld.w	r8,r7[-16]
80004416:	f0 c8 ff 00 	sub	r8,r8,-256
8000441a:	ef 48 ff f0 	st.w	r7[-16],r8
				write_addr += DF_PAGE_SIZE;
8000441e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004422:	f0 c8 ff 00 	sub	r8,r8,-256
80004426:	ef 48 ff f8 	st.w	r7[-8],r8
8000442a:	c5 c8       	rjmp	800044e2 <data_flash_write_block+0x15a>
		}
		else
		{
			/*(write_addr & 0xFF != 0), address not 256 bytes aligned */

			if (BEYOND_PAGE_BOUNDARY(write_addr, bytes_remained) == TRUE)
8000442c:	ef 19 ff fe 	ld.uh	r9,r7[-2]
80004430:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004434:	10 09       	add	r9,r8
80004436:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000443a:	e4 18 00 7f 	andh	r8,0x7f
8000443e:	e0 18 ff 00 	andl	r8,0xff00
80004442:	f0 c8 ff 00 	sub	r8,r8,-256
80004446:	10 39       	cp.w	r9,r8
80004448:	e0 88 00 3e 	brls	800044c4 <data_flash_write_block+0x13c>
			{
				/* bytes remained exceed current page, only write data within current page */
				return_code = data_flash_write_page(data_ptr, write_addr, BYTES_TO_NEXT_PAGE_BOUNDARY(write_addr));
8000444c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004450:	5c 88       	casts.h	r8
80004452:	5c 88       	casts.h	r8
80004454:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
80004458:	e0 69 01 00 	mov	r9,256
8000445c:	f2 08 01 08 	sub	r8,r9,r8
80004460:	5c 88       	casts.h	r8
80004462:	5c 78       	castu.h	r8
80004464:	10 9a       	mov	r10,r8
80004466:	ee fb ff f8 	ld.w	r11,r7[-8]
8000446a:	ee fc ff f0 	ld.w	r12,r7[-16]
8000446e:	f0 1f 00 26 	mcall	80004504 <data_flash_write_block+0x17c>
80004472:	18 98       	mov	r8,r12
80004474:	ef 48 ff f4 	st.w	r7[-12],r8
				bytes_remained -= BYTES_TO_NEXT_PAGE_BOUNDARY(write_addr);
80004478:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000447c:	5c 88       	casts.h	r8
8000447e:	5c 88       	casts.h	r8
80004480:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
80004484:	ef 09 ff fe 	ld.sh	r9,r7[-2]
80004488:	f2 08 00 08 	add	r8,r9,r8
8000448c:	5c 88       	casts.h	r8
8000448e:	f0 c8 01 00 	sub	r8,r8,256
80004492:	ef 58 ff fe 	st.h	r7[-2],r8
				data_ptr += BYTES_TO_NEXT_PAGE_BOUNDARY(write_addr);
80004496:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000449a:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
8000449e:	e0 69 01 00 	mov	r9,256
800044a2:	f2 08 01 08 	sub	r8,r9,r8
800044a6:	ee f9 ff f0 	ld.w	r9,r7[-16]
800044aa:	f2 08 00 08 	add	r8,r9,r8
800044ae:	ef 48 ff f0 	st.w	r7[-16],r8
				write_addr += BYTES_TO_NEXT_PAGE_BOUNDARY(write_addr); /* now became 256 bytes aligned */
800044b2:	ee f8 ff f8 	ld.w	r8,r7[-8]
800044b6:	e0 18 ff 00 	andl	r8,0xff00
800044ba:	f0 c8 ff 00 	sub	r8,r8,-256
800044be:	ef 48 ff f8 	st.w	r7[-8],r8
800044c2:	c1 08       	rjmp	800044e2 <data_flash_write_block+0x15a>
			}
			else
			{
				/* bytes remained not exceed current page */
				return_code = data_flash_write_page(data_ptr, write_addr, bytes_remained);
800044c4:	ef 18 ff fe 	ld.uh	r8,r7[-2]
800044c8:	10 9a       	mov	r10,r8
800044ca:	ee fb ff f8 	ld.w	r11,r7[-8]
800044ce:	ee fc ff f0 	ld.w	r12,r7[-16]
800044d2:	f0 1f 00 0d 	mcall	80004504 <data_flash_write_block+0x17c>
800044d6:	18 98       	mov	r8,r12
800044d8:	ef 48 ff f4 	st.w	r7[-12],r8
				bytes_remained = 0; /* end while loop */
800044dc:	30 08       	mov	r8,0
800044de:	ef 58 ff fe 	st.h	r7[-2],r8
{
	df_status_t return_code = DF_WRITE_COMPLETED;
	U32 write_addr = address;
	U16 bytes_remained = data_length;

	while (bytes_remained >= 1 && return_code == DF_WRITE_COMPLETED)
800044e2:	ef 09 ff fe 	ld.sh	r9,r7[-2]
800044e6:	30 08       	mov	r8,0
800044e8:	f0 09 19 00 	cp.h	r9,r8
800044ec:	c0 60       	breq	800044f8 <data_flash_write_block+0x170>
800044ee:	ee f8 ff f4 	ld.w	r8,r7[-12]
800044f2:	58 78       	cp.w	r8,7
800044f4:	fe 90 ff 61 	breq	800043b6 <data_flash_write_block+0x2e>
				bytes_remained = 0; /* end while loop */
			}
		}
	}	/* end of while */

	return return_code;
800044f8:	ee f8 ff f4 	ld.w	r8,r7[-12]
}
800044fc:	10 9c       	mov	r12,r8
800044fe:	2f ad       	sub	sp,-24
80004500:	e3 cd 80 80 	ldm	sp++,r7,pc
80004504:	80 00       	ld.sh	r0,r0[0x0]
80004506:	45 08       	lddsp	r8,sp[0x140]

80004508 <data_flash_write_page>:
* ----------  --------  ----------  --------------------------------------------
* 25-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_write_page(U8 *data_ptr, U32 address, U16 length)
{
80004508:	eb cd 40 80 	pushm	r7,lr
8000450c:	1a 97       	mov	r7,sp
8000450e:	20 6d       	sub	sp,24
80004510:	ef 4c ff f0 	st.w	r7[-16],r12
80004514:	ef 4b ff ec 	st.w	r7[-20],r11
80004518:	14 98       	mov	r8,r10
8000451a:	ef 58 ff e8 	st.h	r7[-24],r8
	U16 status = 1;
8000451e:	30 18       	mov	r8,1
80004520:	ef 58 ff f6 	st.h	r7[-10],r8
	df_status_t return_code = DF_WRITE_FAIL;
80004524:	30 68       	mov	r8,6
80004526:	ef 48 ff f8 	st.w	r7[-8],r8
	U16 count = 0; /* to monitor write time consumption */
8000452a:	30 08       	mov	r8,0
8000452c:	ef 58 ff fe 	st.h	r7[-2],r8

	/* check input parameter */
	if (data_ptr == NULL || address >= DF_MAX_ADDR || length > DF_PAGE_SIZE)
80004530:	ee f8 ff f0 	ld.w	r8,r7[-16]
80004534:	58 08       	cp.w	r8,0
80004536:	c1 20       	breq	8000455a <data_flash_write_page+0x52>
80004538:	ee f8 ff ec 	ld.w	r8,r7[-20]
8000453c:	e0 69 ff fe 	mov	r9,65534
80004540:	ea 19 00 7f 	orh	r9,0x7f
80004544:	12 38       	cp.w	r8,r9
80004546:	e0 8b 00 0a 	brhi	8000455a <data_flash_write_page+0x52>
8000454a:	ef 09 ff e8 	ld.sh	r9,r7[-24]
8000454e:	e0 68 01 00 	mov	r8,256
80004552:	f0 09 19 00 	cp.h	r9,r8
80004556:	e0 88 00 04 	brls	8000455e <data_flash_write_page+0x56>
	{
		return DF_INVALID_PARAM;
8000455a:	30 18       	mov	r8,1
8000455c:	c4 c8       	rjmp	800045f4 <data_flash_write_page+0xec>
	}

	status = send_flash_command(READ_STATUS_REG, 0, NULL, 0);
8000455e:	30 09       	mov	r9,0
80004560:	30 0a       	mov	r10,0
80004562:	30 0b       	mov	r11,0
80004564:	30 5c       	mov	r12,5
80004566:	f0 1f 00 26 	mcall	800045fc <data_flash_write_page+0xf4>
8000456a:	18 98       	mov	r8,r12
8000456c:	5c 88       	casts.h	r8
8000456e:	ef 58 ff f6 	st.h	r7[-10],r8
	if ((status & STATUS_BUSY) != 0)
80004572:	ef 18 ff f6 	ld.uh	r8,r7[-10]
80004576:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000457a:	5c 58       	castu.b	r8
8000457c:	c0 30       	breq	80004582 <data_flash_write_page+0x7a>
	{
		return DF_DEVICE_BUSY;
8000457e:	30 28       	mov	r8,2
80004580:	c3 a8       	rjmp	800045f4 <data_flash_write_page+0xec>
	}

	/* send WRITE_ENABLE command */
	send_flash_command(WRITE_ENABLE, 0, NULL, 0);
80004582:	30 09       	mov	r9,0
80004584:	30 0a       	mov	r10,0
80004586:	30 0b       	mov	r11,0
80004588:	30 6c       	mov	r12,6
8000458a:	f0 1f 00 1d 	mcall	800045fc <data_flash_write_page+0xf4>

	/* send PAGE_PROGRAM command */
	send_flash_command(PAGE_PROGRAM, address, data_ptr, length);
8000458e:	ef 18 ff e8 	ld.uh	r8,r7[-24]
80004592:	10 99       	mov	r9,r8
80004594:	ee fa ff f0 	ld.w	r10,r7[-16]
80004598:	ee fb ff ec 	ld.w	r11,r7[-20]
8000459c:	30 2c       	mov	r12,2
8000459e:	f0 1f 00 18 	mcall	800045fc <data_flash_write_page+0xf4>
	do {
		status = send_flash_command(READ_STATUS_REG, 0, NULL, 0);
800045a2:	30 09       	mov	r9,0
800045a4:	30 0a       	mov	r10,0
800045a6:	30 0b       	mov	r11,0
800045a8:	30 5c       	mov	r12,5
800045aa:	f0 1f 00 15 	mcall	800045fc <data_flash_write_page+0xf4>
800045ae:	18 98       	mov	r8,r12
800045b0:	5c 88       	casts.h	r8
800045b2:	ef 58 ff f6 	st.h	r7[-10],r8
		count++;
800045b6:	ef 08 ff fe 	ld.sh	r8,r7[-2]
800045ba:	2f f8       	sub	r8,-1
800045bc:	ef 58 ff fe 	st.h	r7[-2],r8
	} while((status & STATUS_BUSY) != 0);
800045c0:	ef 18 ff f6 	ld.uh	r8,r7[-10]
800045c4:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800045c8:	5c 58       	castu.b	r8
800045ca:	ce c1       	brne	800045a2 <data_flash_write_page+0x9a>

	/*  Check Status Register */
	if ((status & STATUS_ERASE_PROG_ERROR) != 0)
800045cc:	ef 18 ff f6 	ld.uh	r8,r7[-10]
800045d0:	e2 18 00 20 	andl	r8,0x20,COH
800045d4:	c0 50       	breq	800045de <data_flash_write_page+0xd6>
	{
		return_code = DF_WRITE_FAIL;
800045d6:	30 68       	mov	r8,6
800045d8:	ef 48 ff f8 	st.w	r7[-8],r8
800045dc:	c0 48       	rjmp	800045e4 <data_flash_write_page+0xdc>
	}
#endif
	else
	{
		/*  Erase Successful.  */
		return_code = DF_WRITE_COMPLETED;
800045de:	30 78       	mov	r8,7
800045e0:	ef 48 ff f8 	st.w	r7[-8],r8
	}

	/* send WRITE_DISABLE command */
	send_flash_command(WRITE_DISABLE, 0, NULL, 0);
800045e4:	30 09       	mov	r9,0
800045e6:	30 0a       	mov	r10,0
800045e8:	30 0b       	mov	r11,0
800045ea:	30 4c       	mov	r12,4
800045ec:	f0 1f 00 04 	mcall	800045fc <data_flash_write_page+0xf4>

	return return_code;
800045f0:	ee f8 ff f8 	ld.w	r8,r7[-8]
}
800045f4:	10 9c       	mov	r12,r8
800045f6:	2f ad       	sub	sp,-24
800045f8:	e3 cd 80 80 	ldm	sp++,r7,pc
800045fc:	80 00       	ld.sh	r0,r0[0x0]
800045fe:	37 ac       	mov	r12,122

80004600 <data_flash_read_block>:
* ----------  --------  ----------  --------------------------------------------
* 25-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_read_block(U32 address, U16 length, U8 *data_ptr)
{
80004600:	eb cd 40 80 	pushm	r7,lr
80004604:	1a 97       	mov	r7,sp
80004606:	20 3d       	sub	sp,12
80004608:	ef 4c ff fc 	st.w	r7[-4],r12
8000460c:	16 98       	mov	r8,r11
8000460e:	ef 4a ff f4 	st.w	r7[-12],r10
80004612:	ef 58 ff f8 	st.h	r7[-8],r8
	/* check input parameter */
	if (data_ptr == NULL || address >= DF_MAX_ADDR || length > 0x1000)
80004616:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000461a:	58 08       	cp.w	r8,0
8000461c:	c1 20       	breq	80004640 <data_flash_read_block+0x40>
8000461e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004622:	e0 69 ff fe 	mov	r9,65534
80004626:	ea 19 00 7f 	orh	r9,0x7f
8000462a:	12 38       	cp.w	r8,r9
8000462c:	e0 8b 00 0a 	brhi	80004640 <data_flash_read_block+0x40>
80004630:	ef 09 ff f8 	ld.sh	r9,r7[-8]
80004634:	e0 68 10 00 	mov	r8,4096
80004638:	f0 09 19 00 	cp.h	r9,r8
8000463c:	e0 88 00 04 	brls	80004644 <data_flash_read_block+0x44>
	{
		return DF_INVALID_PARAM;
80004640:	30 18       	mov	r8,1
80004642:	c0 c8       	rjmp	8000465a <data_flash_read_block+0x5a>
	}

	send_flash_command(READ_ARRAY, address, data_ptr, length);
80004644:	ef 18 ff f8 	ld.uh	r8,r7[-8]
80004648:	10 99       	mov	r9,r8
8000464a:	ee fa ff f4 	ld.w	r10,r7[-12]
8000464e:	ee fb ff fc 	ld.w	r11,r7[-4]
80004652:	30 3c       	mov	r12,3
80004654:	f0 1f 00 04 	mcall	80004664 <data_flash_read_block+0x64>

	return DF_OK;
80004658:	30 08       	mov	r8,0
}
8000465a:	10 9c       	mov	r12,r8
8000465c:	2f dd       	sub	sp,-12
8000465e:	e3 cd 80 80 	ldm	sp++,r7,pc
80004662:	00 00       	add	r0,r0
80004664:	80 00       	ld.sh	r0,r0[0x0]
80004666:	37 ac       	mov	r12,122

80004668 <CalculateBurst>:
Calls:
Called By: phy_payload_rx
*/

volatile RxAMBEBurstType CalculateBurst(U8 vf_sn)
{
80004668:	eb cd 40 80 	pushm	r7,lr
8000466c:	1a 97       	mov	r7,sp
8000466e:	20 2d       	sub	sp,8
80004670:	18 98       	mov	r8,r12
80004672:	ef 68 ff f8 	st.b	r7[-8],r8
	U8 Burst_ID = 0;
80004676:	30 08       	mov	r8,0
80004678:	ef 68 ff ff 	st.b	r7[-1],r8
	
	switch(vf_sn)
8000467c:	ef 38 ff f8 	ld.ub	r8,r7[-8]
80004680:	20 18       	sub	r8,1
80004682:	59 18       	cp.w	r8,17
80004684:	e0 8b 00 23 	brhi	800046ca <CalculateBurst+0x62>
80004688:	49 59       	lddpc	r9,800046dc <CalculateBurst+0x74>
8000468a:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
	{
		case 0x01:
		case 0x02:
		case 0x03:
		
			Burst_ID = 0x0A;
8000468e:	30 a8       	mov	r8,10
80004690:	ef 68 ff ff 	st.b	r7[-1],r8
			return VOICEBURST_A;
80004694:	30 48       	mov	r8,4
80004696:	c1 e8       	rjmp	800046d2 <CalculateBurst+0x6a>
		
		case 0x04:
		case 0x05:
		case 0x06:
		
			Burst_ID = 0x0B;
80004698:	30 b8       	mov	r8,11
8000469a:	ef 68 ff ff 	st.b	r7[-1],r8
			return VOICEBURST_B;
8000469e:	30 58       	mov	r8,5
800046a0:	c1 98       	rjmp	800046d2 <CalculateBurst+0x6a>
		
		case 0x07:
		case 0x08:
		case 0x09:
		
			Burst_ID = 0x0C;
800046a2:	30 c8       	mov	r8,12
800046a4:	ef 68 ff ff 	st.b	r7[-1],r8
			return VOICEBURST_C;
800046a8:	30 68       	mov	r8,6
800046aa:	c1 48       	rjmp	800046d2 <CalculateBurst+0x6a>
		
		case 0x0A:
		case 0x0B:
		case 0x0C:
		
			Burst_ID = 0x0D;
800046ac:	30 d8       	mov	r8,13
800046ae:	ef 68 ff ff 	st.b	r7[-1],r8
			return VOICEBURST_D;
800046b2:	30 78       	mov	r8,7
800046b4:	c0 f8       	rjmp	800046d2 <CalculateBurst+0x6a>
		
		case 0x0D:
		case 0x0E:
		case 0x0F:
		
			Burst_ID = 0x0E;
800046b6:	30 e8       	mov	r8,14
800046b8:	ef 68 ff ff 	st.b	r7[-1],r8
			return VOICEBURST_E;
800046bc:	30 88       	mov	r8,8
800046be:	c0 a8       	rjmp	800046d2 <CalculateBurst+0x6a>
			
		case 0x10:
		case 0x11:
		case 0x12:
		
				Burst_ID = 0x0F;
800046c0:	30 f8       	mov	r8,15
800046c2:	ef 68 ff ff 	st.b	r7[-1],r8
			return VOICEBURST_F;     
800046c6:	30 98       	mov	r8,9
800046c8:	c0 58       	rjmp	800046d2 <CalculateBurst+0x6a>
		
		default:
		
			Burst_ID = 0x00;
800046ca:	30 08       	mov	r8,0
800046cc:	ef 68 ff ff 	st.b	r7[-1],r8
			return VOICE_WATING;
800046d0:	30 08       	mov	r8,0
		
	}
	
}
800046d2:	10 9c       	mov	r12,r8
800046d4:	2f ed       	sub	sp,-8
800046d6:	e3 cd 80 80 	ldm	sp++,r7,pc
800046da:	00 00       	add	r0,r0
800046dc:	80 01       	ld.sh	r1,r0[0x0]
800046de:	0c 3c       	cp.w	r12,r6
800046e0:	50 41       	stdsp	sp[0x10],r1
800046e2:	59 4c       	cp.w	r12,20
800046e4:	4f 41       	lddpc	r1,800048b4 <phy_init+0xcc>
800046e6:	44 5f       	lddsp	pc,sp[0x114]
800046e8:	52 58       	stdsp	sp[0x94],r8
	...

800046ec <payload_rx_process>:
Description: Receive the payload
Calls:
Called By:task
*/
static void payload_rx_process(void * pvParameters)
{
800046ec:	eb cd 40 80 	pushm	r7,lr
800046f0:	1a 97       	mov	r7,sp
800046f2:	20 2d       	sub	sp,8
800046f4:	ef 4c ff f8 	st.w	r7[-8],r12
	/*To store the elements in the queue*/
	U16  * payload_ptr;
		
	if(NULL ==   phy_payload_frame_rx)
800046f8:	49 08       	lddpc	r8,80004738 <payload_rx_process+0x4c>
800046fa:	70 08       	ld.w	r8,r8[0x0]
800046fc:	58 08       	cp.w	r8,0
800046fe:	c0 a1       	brne	80004712 <payload_rx_process+0x26>
	{
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
80004700:	30 4b       	mov	r11,4
80004702:	30 5c       	mov	r12,5
80004704:	f0 1f 00 0e 	mcall	8000473c <payload_rx_process+0x50>
80004708:	18 99       	mov	r9,r12
8000470a:	48 c8       	lddpc	r8,80004738 <payload_rx_process+0x4c>
8000470c:	91 09       	st.w	r8[0x0],r9
8000470e:	c0 28       	rjmp	80004712 <payload_rx_process+0x26>
		if(pdTRUE == xQueueReceive( phy_payload_frame_rx, &payload_ptr,portMAX_DELAY ))
		{			
			payload_rx_exec(payload_ptr);//app_payload_rx_proc();
		}
	
	}
80004710:	d7 03       	nop
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_rx, &payload_ptr,portMAX_DELAY ))
80004712:	48 a8       	lddpc	r8,80004738 <payload_rx_process+0x4c>
80004714:	70 08       	ld.w	r8,r8[0x0]
80004716:	ee cb 00 04 	sub	r11,r7,4
8000471a:	30 09       	mov	r9,0
8000471c:	3f fa       	mov	r10,-1
8000471e:	10 9c       	mov	r12,r8
80004720:	f0 1f 00 08 	mcall	80004740 <payload_rx_process+0x54>
80004724:	18 98       	mov	r8,r12
80004726:	58 18       	cp.w	r8,1
80004728:	cf 41       	brne	80004710 <payload_rx_process+0x24>
		{			
			payload_rx_exec(payload_ptr);//app_payload_rx_proc();
8000472a:	48 78       	lddpc	r8,80004744 <payload_rx_process+0x58>
8000472c:	70 08       	ld.w	r8,r8[0x0]
8000472e:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004732:	12 9c       	mov	r12,r9
80004734:	5d 18       	icall	r8
		}
	
	}
80004736:	ce eb       	rjmp	80004712 <payload_rx_process+0x26>
80004738:	00 00       	add	r0,r0
8000473a:	0a a0       	st.w	r5++,r0
8000473c:	80 00       	ld.sh	r0,r0[0x0]
8000473e:	8e 2c       	ld.sh	r12,r7[0x4]
80004740:	80 00       	ld.sh	r0,r0[0x0]
80004742:	91 50       	st.w	r8[0x14],r0
80004744:	00 00       	add	r0,r0
80004746:	0a 84       	andn	r4,r5

80004748 <payload_init>:
	Create the corresponding task;
Calls: xTaskCreate--freertos
Called By:app_init -- app.c
*/
void payload_init(void ( *payload_rx_func)(void * ), void ( *payload_tx_func)(void * ) )
{				
80004748:	eb cd 40 80 	pushm	r7,lr
8000474c:	1a 97       	mov	r7,sp
8000474e:	20 2d       	sub	sp,8
80004750:	ef 4c ff fc 	st.w	r7[-4],r12
80004754:	ef 4b ff f8 	st.w	r7[-8],r11
	payload_rx_exec = payload_rx_func;
80004758:	48 d8       	lddpc	r8,8000478c <payload_init+0x44>
8000475a:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000475e:	91 09       	st.w	r8[0x0],r9
	payload_tx_exec = payload_tx_func;
80004760:	48 c8       	lddpc	r8,80004790 <payload_init+0x48>
80004762:	ee f9 ff f8 	ld.w	r9,r7[-8]
80004766:	91 09       	st.w	r8[0x0],r9
	
	
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
80004768:	48 bb       	lddpc	r11,80004794 <payload_init+0x4c>
8000476a:	30 08       	mov	r8,0
8000476c:	1a d8       	st.w	--sp,r8
8000476e:	30 08       	mov	r8,0
80004770:	1a d8       	st.w	--sp,r8
80004772:	30 08       	mov	r8,0
80004774:	1a d8       	st.w	--sp,r8
80004776:	30 28       	mov	r8,2
80004778:	30 09       	mov	r9,0
8000477a:	e0 6a 04 00 	mov	r10,1024
8000477e:	48 7c       	lddpc	r12,80004798 <payload_init+0x50>
80004780:	f0 1f 00 07 	mcall	8000479c <payload_init+0x54>
80004784:	2f dd       	sub	sp,-12
	//,  2
	//,  NULL
	//);
	//
	
}
80004786:	2f ed       	sub	sp,-8
80004788:	e3 cd 80 80 	ldm	sp++,r7,pc
8000478c:	00 00       	add	r0,r0
8000478e:	0a 84       	andn	r4,r5
80004790:	00 00       	add	r0,r0
80004792:	0a 88       	andn	r8,r5
80004794:	80 00       	ld.sh	r0,r0[0x0]
80004796:	46 e0       	lddsp	r0,sp[0x1b8]
80004798:	80 00       	ld.sh	r0,r0[0x0]
8000479a:	46 ec       	lddsp	r12,sp[0x1b8]
8000479c:	80 00       	ld.sh	r0,r0[0x0]
8000479e:	96 9c       	ld.uh	r12,r11[0x2]
800047a0:	6d 6d       	ld.w	sp,r6[0x58]
800047a2:	00 00       	add	r0,r0
800047a4:	0a 0d       	add	sp,r5
800047a6:	20 78       	sub	r8,7
800047a8:	78 78       	ld.w	r8,r12[0x1c]
800047aa:	78 78       	ld.w	r8,r12[0x1c]
800047ac:	5f 51       	srlt	r1
800047ae:	51 5f       	stdsp	sp[0x54],pc
800047b0:	78 78       	ld.w	r8,r12[0x1c]
800047b2:	78 78       	ld.w	r8,r12[0x1c]
800047b4:	78 20       	ld.w	r0,r12[0x8]
800047b6:	0a 0d       	add	sp,r5
800047b8:	00 00       	add	r0,r0
800047ba:	00 00       	add	r0,r0
800047bc:	0a 0d       	add	sp,r5
800047be:	20 52       	sub	r2,5
800047c0:	61 64       	ld.w	r4,r0[0x58]
800047c2:	69 6f       	ld.w	pc,r4[0x58]
800047c4:	20 49       	sub	r9,4
800047c6:	6e 74       	ld.w	r4,r7[0x1c]
800047c8:	65 72       	ld.w	r2,r2[0x5c]
800047ca:	6e 61       	ld.w	r1,r7[0x18]
800047cc:	6c 20       	ld.w	r0,r6[0x8]
800047ce:	70 61       	ld.w	r1,r8[0x18]
800047d0:	72 61       	ld.w	r1,r9[0x18]
800047d2:	6d 65       	ld.w	r5,r6[0x58]
800047d4:	74 65       	ld.w	r5,r10[0x18]
800047d6:	72 20       	ld.w	r0,r9[0x8]
800047d8:	6c 65       	ld.w	r5,r6[0x18]
800047da:	6e 67       	ld.w	r7,r7[0x18]
800047dc:	74 68       	ld.w	r8,r10[0x18]
800047de:	20 65       	sub	r5,6
800047e0:	72 72       	ld.w	r2,r9[0x1c]
800047e2:	6f 72       	ld.w	r2,r7[0x5c]
800047e4:	20 0a       	sub	r10,0
800047e6:	0d 00       	ld.w	r0,r6++

800047e8 <phy_init>:
    register_rx_tx_func -- ssc.c
	xQueueCreate -- freertos
Called By: xnl_init -- xnl.c
*/
void phy_init( void )
{
800047e8:	eb cd 40 80 	pushm	r7,lr
800047ec:	1a 97       	mov	r7,sp
800047ee:	20 4d       	sub	sp,16
    /*initialize the SSC*/
    ssc_init();
800047f0:	f0 1f 00 34 	mcall	800048c0 <phy_init+0xd8>

    /*register the func to send/receive ssc packet*/
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
800047f4:	4b 4b       	lddpc	r11,800048c4 <phy_init+0xdc>
800047f6:	4b 5c       	lddpc	r12,800048c8 <phy_init+0xe0>
800047f8:	f0 1f 00 35 	mcall	800048cc <phy_init+0xe4>
	
	/*if enable send/receive payload(media), defined in physical.h*/	
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
800047fc:	30 4b       	mov	r11,4
800047fe:	31 ec       	mov	r12,30
80004800:	f0 1f 00 34 	mcall	800048d0 <phy_init+0xe8>
80004804:	18 99       	mov	r9,r12
80004806:	4b 48       	lddpc	r8,800048d4 <phy_init+0xec>
80004808:	91 09       	st.w	r8[0x0],r9
	phy_fragment_t * xnl_ptr = NULL;
8000480a:	30 08       	mov	r8,0
8000480c:	ef 48 ff f0 	st.w	r7[-16],r8
	for(int i= 0; i < MAX_XNL_STORE; i++ )
80004810:	30 08       	mov	r8,0
80004812:	ef 48 ff f8 	st.w	r7[-8],r8
80004816:	c1 28       	rjmp	8000483a <phy_init+0x52>
	{
		set_xnl_idle(&xnl_store[i]);
80004818:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000481c:	f0 09 15 08 	lsl	r9,r8,0x8
80004820:	4a e8       	lddpc	r8,800048d8 <phy_init+0xf0>
80004822:	10 09       	add	r9,r8
80004824:	4a c8       	lddpc	r8,800048d4 <phy_init+0xec>
80004826:	70 08       	ld.w	r8,r8[0x0]
80004828:	12 9b       	mov	r11,r9
8000482a:	10 9c       	mov	r12,r8
8000482c:	f0 1f 00 2c 	mcall	800048dc <phy_init+0xf4>
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
	
	/*if enable send/receive payload(media), defined in physical.h*/	
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
	phy_fragment_t * xnl_ptr = NULL;
	for(int i= 0; i < MAX_XNL_STORE; i++ )
80004830:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004834:	2f f8       	sub	r8,-1
80004836:	ef 48 ff f8 	st.w	r7[-8],r8
8000483a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000483e:	59 d8       	cp.w	r8,29
80004840:	fe 9a ff ec 	brle	80004818 <phy_init+0x30>
	{
		set_xnl_idle(&xnl_store[i]);
	}
		
    /*initialize the queue to send/receive xnl packet */	
    phy_xnl_frame_tx = xQueueCreate(TX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
80004844:	30 4b       	mov	r11,4
80004846:	31 4c       	mov	r12,20
80004848:	f0 1f 00 22 	mcall	800048d0 <phy_init+0xe8>
8000484c:	18 99       	mov	r9,r12
8000484e:	4a 58       	lddpc	r8,800048e0 <phy_init+0xf8>
80004850:	91 09       	st.w	r8[0x0],r9
    phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
80004852:	30 4b       	mov	r11,4
80004854:	30 ac       	mov	r12,10
80004856:	f0 1f 00 1f 	mcall	800048d0 <phy_init+0xe8>
8000485a:	18 99       	mov	r9,r12
8000485c:	4a 28       	lddpc	r8,800048e4 <phy_init+0xfc>
8000485e:	91 09       	st.w	r8[0x0],r9
	
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
80004860:	30 4b       	mov	r11,4
80004862:	30 ac       	mov	r12,10
80004864:	f0 1f 00 1b 	mcall	800048d0 <phy_init+0xe8>
80004868:	18 99       	mov	r9,r12
8000486a:	4a 08       	lddpc	r8,800048e8 <phy_init+0x100>
8000486c:	91 09       	st.w	r8[0x0],r9
	U8 * payload_ptr = NULL;
8000486e:	30 08       	mov	r8,0
80004870:	ef 48 ff f4 	st.w	r7[-12],r8
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
80004874:	30 08       	mov	r8,0
80004876:	ef 48 ff fc 	st.w	r7[-4],r8
8000487a:	c1 28       	rjmp	8000489e <phy_init+0xb6>
	{
		set_payload_idle(payload_store[i]);
8000487c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004880:	f0 09 15 09 	lsl	r9,r8,0x9
80004884:	49 a8       	lddpc	r8,800048ec <phy_init+0x104>
80004886:	10 09       	add	r9,r8
80004888:	49 88       	lddpc	r8,800048e8 <phy_init+0x100>
8000488a:	70 08       	ld.w	r8,r8[0x0]
8000488c:	12 9b       	mov	r11,r9
8000488e:	10 9c       	mov	r12,r8
80004890:	f0 1f 00 13 	mcall	800048dc <phy_init+0xf4>
    phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
	
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
	U8 * payload_ptr = NULL;
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
80004894:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004898:	2f f8       	sub	r8,-1
8000489a:	ef 48 ff fc 	st.w	r7[-4],r8
8000489e:	ee f8 ff fc 	ld.w	r8,r7[-4]
800048a2:	58 98       	cp.w	r8,9
800048a4:	fe 9a ff ec 	brle	8000487c <phy_init+0x94>
		set_payload_idle(payload_store[i]);
	}
		
	/*initialize the queue to send/receive xnl packet */
	phy_payload_frame_tx =
	xQueueCreate(TX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t));
800048a8:	e0 6b 01 00 	mov	r11,256
800048ac:	30 5c       	mov	r12,5
800048ae:	f0 1f 00 09 	mcall	800048d0 <phy_init+0xe8>
800048b2:	18 99       	mov	r9,r12
	{
		set_payload_idle(payload_store[i]);
	}
		
	/*initialize the queue to send/receive xnl packet */
	phy_payload_frame_tx =
800048b4:	48 f8       	lddpc	r8,800048f0 <phy_init+0x108>
800048b6:	91 09       	st.w	r8[0x0],r9
		
	//phy_payload_frame_rx =
	//xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
	#endif /*end if*/
	
}
800048b8:	2f cd       	sub	sp,-16
800048ba:	e3 cd 80 80 	ldm	sp++,r7,pc
800048be:	00 00       	add	r0,r0
800048c0:	80 00       	ld.sh	r0,r0[0x0]
800048c2:	67 34       	ld.w	r4,r3[0x4c]
800048c4:	80 00       	ld.sh	r0,r0[0x0]
800048c6:	4a 00       	lddpc	r0,80004944 <phy_tx+0x50>
800048c8:	80 00       	ld.sh	r0,r0[0x0]
800048ca:	4a 40       	lddpc	r0,80004958 <phy_tx+0x64>
800048cc:	80 00       	ld.sh	r0,r0[0x0]
800048ce:	67 b4       	ld.w	r4,r3[0x6c]
800048d0:	80 00       	ld.sh	r0,r0[0x0]
800048d2:	8e 2c       	ld.sh	r12,r7[0x4]
800048d4:	00 00       	add	r0,r0
800048d6:	0a 8c       	andn	r12,r5
800048d8:	00 00       	add	r0,r0
800048da:	34 ca       	mov	r10,76
800048dc:	80 00       	ld.sh	r0,r0[0x0]
800048de:	64 c4       	ld.w	r4,r2[0x30]
800048e0:	00 00       	add	r0,r0
800048e2:	0a 90       	mov	r0,r5
800048e4:	00 00       	add	r0,r0
800048e6:	0a 94       	mov	r4,r5
800048e8:	00 00       	add	r0,r0
800048ea:	0a 98       	mov	r8,r5
800048ec:	00 00       	add	r0,r0
800048ee:	20 ca       	sub	r10,12
800048f0:	00 00       	add	r0,r0
800048f2:	0a 9c       	mov	r12,r5

800048f4 <phy_tx>:
Calls:   
	xQueueSend -- freertos
Called By: xnl_tx -- xnl.c
*/
void phy_tx(phy_fragment_t * phy)
{	
800048f4:	eb cd 40 80 	pushm	r7,lr
800048f8:	1a 97       	mov	r7,sp
800048fa:	20 2d       	sub	sp,8
800048fc:	ef 4c ff f8 	st.w	r7[-8],r12
    Bool res = FALSE;
80004900:	30 08       	mov	r8,0
80004902:	ef 68 ff fd 	st.b	r7[-3],r8
	
	U16 phy_ctrl = phy->xnl_fragment.phy_header.phy_control;
80004906:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000490a:	90 08       	ld.sh	r8,r8[0x0]
8000490c:	ef 58 ff fe 	st.h	r7[-2],r8
	
	//phy_fragment_t * phy_ptr = malloc(sizeof(phy_fragment_t));
	//memcpy(phy_ptr, phy, sizeof(phy_fragment_t));
	//log("\n\r T_xcmp:%4x \n\r", phy->xnl_fragment.xnl_payload.xnl_content_data_msg.xcmp_opcode);
	//log("T_xnl-opcode:%4x", xnl->xnl_header.opcode);//log:R_xnl	
	if(XCMPXNL_DATA == (phy_ctrl & 0xF000))
80004910:	ef 18 ff fe 	ld.uh	r8,r7[-2]
80004914:	e2 18 f0 00 	andl	r8,0xf000,COH
80004918:	e0 48 40 00 	cp.w	r8,16384
8000491c:	c1 51       	brne	80004946 <phy_tx+0x52>
	{
		/*push the xnl packet to queue to send */
		if(NULL != phy_xnl_frame_tx)
8000491e:	49 b8       	lddpc	r8,80004988 <phy_tx+0x94>
80004920:	70 08       	ld.w	r8,r8[0x0]
80004922:	58 08       	cp.w	r8,0
80004924:	c2 f0       	breq	80004982 <phy_tx+0x8e>
		{
			if( pdTRUE == xQueueSend(phy_xnl_frame_tx, &phy, 0))
80004926:	49 98       	lddpc	r8,80004988 <phy_tx+0x94>
80004928:	70 08       	ld.w	r8,r8[0x0]
8000492a:	ee cb 00 08 	sub	r11,r7,8
8000492e:	30 09       	mov	r9,0
80004930:	30 0a       	mov	r10,0
80004932:	10 9c       	mov	r12,r8
80004934:	f0 1f 00 16 	mcall	8000498c <phy_tx+0x98>
80004938:	18 98       	mov	r8,r12
8000493a:	58 18       	cp.w	r8,1
8000493c:	c2 31       	brne	80004982 <phy_tx+0x8e>
			{
				res = TRUE;
8000493e:	30 18       	mov	r8,1
80004940:	ef 68 ff fd 	st.b	r7[-3],r8
80004944:	c1 f8       	rjmp	80004982 <phy_tx+0x8e>
		}
	}
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE		
	else if((SPEAKER_DATA == (phy_ctrl & 0xF000))
80004946:	ef 18 ff fe 	ld.uh	r8,r7[-2]
8000494a:	e2 18 f0 00 	andl	r8,0xf000,COH
8000494e:	e0 48 10 00 	cp.w	r8,4096
80004952:	c1 60       	breq	8000497e <phy_tx+0x8a>
	    || (MIC_DATA  == (phy_ctrl & 0xF000))
80004954:	ef 18 ff fe 	ld.uh	r8,r7[-2]
80004958:	e2 18 f0 00 	andl	r8,0xf000,COH
		}
	}
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE		
	else if((SPEAKER_DATA == (phy_ctrl & 0xF000))
8000495c:	e0 48 20 00 	cp.w	r8,8192
80004960:	c0 f0       	breq	8000497e <phy_tx+0x8a>
	    || (MIC_DATA  == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_RX == (phy_ctrl & 0xF000))
80004962:	ef 18 ff fe 	ld.uh	r8,r7[-2]
80004966:	e2 18 f0 00 	andl	r8,0xf000,COH
		}
	}
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE		
	else if((SPEAKER_DATA == (phy_ctrl & 0xF000))
8000496a:	e0 48 50 00 	cp.w	r8,20480
8000496e:	c0 80       	breq	8000497e <phy_tx+0x8a>
	    || (MIC_DATA  == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_RX == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_TX == (phy_ctrl & 0xF000))
80004970:	ef 18 ff fe 	ld.uh	r8,r7[-2]
80004974:	e2 18 f0 00 	andl	r8,0xf000,COH
		}
	}
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE		
	else if((SPEAKER_DATA == (phy_ctrl & 0xF000))
80004978:	e0 48 60 00 	cp.w	r8,24576
8000497c:	c0 31       	brne	80004982 <phy_tx+0x8e>
	    || (MIC_DATA  == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_RX == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_TX == (phy_ctrl & 0xF000))
	)
	{		
		if(NULL == phy_payload_frame_tx)
8000497e:	48 58       	lddpc	r8,80004990 <phy_tx+0x9c>
80004980:	70 08       	ld.w	r8,r8[0x0]
	
	if(res != TRUE)
	{
		//vPortFree(phy_ptr);
	}
}
80004982:	2f ed       	sub	sp,-8
80004984:	e3 cd 80 80 	ldm	sp++,r7,pc
80004988:	00 00       	add	r0,r0
8000498a:	0a 90       	mov	r0,r5
8000498c:	80 00       	ld.sh	r0,r0[0x0]
8000498e:	8f 44       	st.w	r7[0x10],r4
80004990:	00 00       	add	r0,r0
80004992:	0a 9c       	mov	r12,r5

80004994 <phy_rx>:
	xQueueSendFromISR -- freertos
Called By: phy_xnl_rx
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
80004994:	eb cd 40 80 	pushm	r7,lr
80004998:	1a 97       	mov	r7,sp
8000499a:	20 3d       	sub	sp,12
8000499c:	ef 4c ff f4 	st.w	r7[-12],r12
    /*variables are used to store the push result in interrupt*/
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
800049a0:	30 08       	mov	r8,0
800049a2:	ef 48 ff f8 	st.w	r7[-8],r8
	
	//phy_fragment_t * xx = pvPortMalloc(sizeof(phy_fragment_t));
	//memcpy(xx, phy_ptr, sizeof(phy_fragment_t));
	//set_phy_idle_isr(&phy_ptr, &xHigherPriorityTaskWoken);
	
	Bool res = FALSE;
800049a6:	30 08       	mov	r8,0
800049a8:	ef 68 ff fd 	st.b	r7[-3],r8
	
	if(NULL == phy_ptr)
800049ac:	ee f8 ff f4 	ld.w	r8,r7[-12]
800049b0:	58 08       	cp.w	r8,0
800049b2:	c1 e0       	breq	800049ee <phy_rx+0x5a>
	{
		return;
	}
	
    U16 phy_ctrl = phy_ptr->xnl_fragment.phy_header.phy_control;
800049b4:	ee f8 ff f4 	ld.w	r8,r7[-12]
800049b8:	90 08       	ld.sh	r8,r8[0x0]
800049ba:	ef 58 ff fe 	st.h	r7[-2],r8

    if (XCMPXNL_DATA == (phy_ctrl & 0xF000))
800049be:	ef 18 ff fe 	ld.uh	r8,r7[-2]
800049c2:	e2 18 f0 00 	andl	r8,0xf000,COH
800049c6:	e0 48 40 00 	cp.w	r8,16384
800049ca:	c1 31       	brne	800049f0 <phy_rx+0x5c>
    {
        /*push the xnl packet to queue*/
        if( pdTRUE == xQueueSendFromISR(
800049cc:	48 b8       	lddpc	r8,800049f8 <phy_rx+0x64>
800049ce:	70 08       	ld.w	r8,r8[0x0]
800049d0:	ee ca 00 08 	sub	r10,r7,8
800049d4:	ee cb 00 0c 	sub	r11,r7,12
800049d8:	30 09       	mov	r9,0
800049da:	10 9c       	mov	r12,r8
800049dc:	f0 1f 00 08 	mcall	800049fc <phy_rx+0x68>
800049e0:	18 98       	mov	r8,r12
800049e2:	58 18       	cp.w	r8,1
800049e4:	c0 61       	brne	800049f0 <phy_rx+0x5c>
			///*  */
			//if (xHigherPriorityTaskWoken == pdTRUE)
			//{
				//taskYIELD();
			//}
			res = TRUE;
800049e6:	30 18       	mov	r8,1
800049e8:	ef 68 ff fd 	st.b	r7[-3],r8
800049ec:	c0 28       	rjmp	800049f0 <phy_rx+0x5c>
	
	Bool res = FALSE;
	
	if(NULL == phy_ptr)
	{
		return;
800049ee:	d7 03       	nop
		}	

    }
		
 
}
800049f0:	2f dd       	sub	sp,-12
800049f2:	e3 cd 80 80 	ldm	sp++,r7,pc
800049f6:	00 00       	add	r0,r0
800049f8:	00 00       	add	r0,r0
800049fa:	0a 94       	mov	r4,r5
800049fc:	80 00       	ld.sh	r0,r0[0x0]
800049fe:	90 ac       	ld.uh	r12,r8[0x4]

80004a00 <phy_tx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_tx_func( void * ssc)
{
80004a00:	eb cd 40 80 	pushm	r7,lr
80004a04:	1a 97       	mov	r7,sp
80004a06:	20 1d       	sub	sp,4
80004a08:	ef 4c ff fc 	st.w	r7[-4],r12
    if(NULL != phy_xnl_frame_tx)
80004a0c:	48 a8       	lddpc	r8,80004a34 <phy_tx_func+0x34>
80004a0e:	70 08       	ld.w	r8,r8[0x0]
80004a10:	58 08       	cp.w	r8,0
80004a12:	c0 70       	breq	80004a20 <phy_tx_func+0x20>
    {
  	  	/*send ssc data in xnl frame*/
  	  	phy_xnl_tx(&(((ssc_fragment_t * )ssc)->xnl_channel));		
80004a14:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004a18:	2f c8       	sub	r8,-4
80004a1a:	10 9c       	mov	r12,r8
80004a1c:	f0 1f 00 07 	mcall	80004a38 <phy_tx_func+0x38>
    {
		//
		//if (ENABLE == PLAYBACK_ENABLE)
		{
			/*send ssc data in payload(media) frame*/
			phy_payload_tx(&(((ssc_fragment_t * )ssc)->payload_channel));	
80004a20:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004a24:	2f 88       	sub	r8,-8
80004a26:	10 9c       	mov	r12,r8
80004a28:	f0 1f 00 05 	mcall	80004a3c <phy_tx_func+0x3c>
	#else
	/*send idle frame*/	
	((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
	((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
	#endif /*end if*/
}
80004a2c:	2f fd       	sub	sp,-4
80004a2e:	e3 cd 80 80 	ldm	sp++,r7,pc
80004a32:	00 00       	add	r0,r0
80004a34:	00 00       	add	r0,r0
80004a36:	0a 90       	mov	r0,r5
80004a38:	80 00       	ld.sh	r0,r0[0x0]
80004a3a:	4a 80       	lddpc	r0,80004ad8 <phy_xnl_tx+0x58>
80004a3c:	80 00       	ld.sh	r0,r0[0x0]
80004a3e:	4e e8       	lddpc	r8,80004bf4 <phy_xnl_rx+0x14>

80004a40 <phy_rx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_rx_func( void * ssc)
{    
80004a40:	eb cd 40 80 	pushm	r7,lr
80004a44:	1a 97       	mov	r7,sp
80004a46:	20 1d       	sub	sp,4
80004a48:	ef 4c ff fc 	st.w	r7[-4],r12
		
	if(NULL != phy_xnl_frame_rx)
80004a4c:	48 a8       	lddpc	r8,80004a74 <phy_rx_func+0x34>
80004a4e:	70 08       	ld.w	r8,r8[0x0]
80004a50:	58 08       	cp.w	r8,0
80004a52:	c0 70       	breq	80004a60 <phy_rx_func+0x20>
	{
		/*receive ssc data in xnl frame*/
		phy_xnl_rx(&(((ssc_fragment_t * )ssc)->xnl_channel));
80004a54:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004a58:	2f c8       	sub	r8,-4
80004a5a:	10 9c       	mov	r12,r8
80004a5c:	f0 1f 00 07 	mcall	80004a78 <phy_rx_func+0x38>
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80004a60:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004a64:	2f 88       	sub	r8,-8
80004a66:	10 9c       	mov	r12,r8
80004a68:	f0 1f 00 05 	mcall	80004a7c <phy_rx_func+0x3c>
	}
	#endif /*end if*/
	
	
}
80004a6c:	2f fd       	sub	sp,-4
80004a6e:	e3 cd 80 80 	ldm	sp++,r7,pc
80004a72:	00 00       	add	r0,r0
80004a74:	00 00       	add	r0,r0
80004a76:	0a 94       	mov	r4,r5
80004a78:	80 00       	ld.sh	r0,r0[0x0]
80004a7a:	4b e0       	lddpc	r0,80004b70 <phy_xnl_tx+0xf0>
80004a7c:	80 00       	ld.sh	r0,r0[0x0]
80004a7e:	55 60       	stdsp	sp[0x158],r0

80004a80 <phy_xnl_tx>:
Calls:   
    xQueueReceiveFromISR -- freertos
Called By:phy_tx_func
*/
static void phy_xnl_tx(xnl_channel_t * xnl_tx_channel)
{
80004a80:	eb cd 40 80 	pushm	r7,lr
80004a84:	1a 97       	mov	r7,sp
80004a86:	20 2d       	sub	sp,8
80004a88:	ef 4c ff f8 	st.w	r7[-8],r12
	/*variables are used to store the push result in interrupt*/
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80004a8c:	30 08       	mov	r8,0
80004a8e:	ef 48 ff fc 	st.w	r7[-4],r8
	
	static S16 phy_tx_expexted_length = 0;
	static U8 phy_tx_index = 0;
	
	/*his is the code for handling any outgoing XNL Phy message*/
	switch(phy_tx_state)
80004a92:	4c e8       	lddpc	r8,80004bc8 <phy_xnl_tx+0x148>
80004a94:	70 08       	ld.w	r8,r8[0x0]
80004a96:	58 18       	cp.w	r8,1
80004a98:	c3 a0       	breq	80004b0c <phy_xnl_tx+0x8c>
80004a9a:	c0 53       	brcs	80004aa4 <phy_xnl_tx+0x24>
80004a9c:	58 28       	cp.w	r8,2
80004a9e:	e0 80 00 88 	breq	80004bae <phy_xnl_tx+0x12e>
80004aa2:	c9 08       	rjmp	80004bc2 <phy_xnl_tx+0x142>
	{
		/*Waiting for the send xnl packet*/
		case WAITING_FOR_PHY_TX:			
			if( pdTRUE == xQueueReceiveFromISR(
80004aa4:	4c a8       	lddpc	r8,80004bcc <phy_xnl_tx+0x14c>
80004aa6:	70 08       	ld.w	r8,r8[0x0]
80004aa8:	ee c9 00 04 	sub	r9,r7,4
80004aac:	12 9a       	mov	r10,r9
80004aae:	4c 9b       	lddpc	r11,80004bd0 <phy_xnl_tx+0x150>
80004ab0:	10 9c       	mov	r12,r8
80004ab2:	f0 1f 00 49 	mcall	80004bd4 <phy_xnl_tx+0x154>
80004ab6:	18 98       	mov	r8,r12
80004ab8:	58 18       	cp.w	r8,1
80004aba:	c2 11       	brne	80004afc <phy_xnl_tx+0x7c>
				, &phy_ptr
				, &xHigherPriorityTaskWoken 
			))
			{								
				phy_tx_expexted_length = 
				     phy_ptr->xnl_fragment.phy_header.phy_control & 0x000000FF;
80004abc:	4c 58       	lddpc	r8,80004bd0 <phy_xnl_tx+0x150>
80004abe:	70 08       	ld.w	r8,r8[0x0]
				  phy_xnl_frame_tx
				, &phy_ptr
				, &xHigherPriorityTaskWoken 
			))
			{								
				phy_tx_expexted_length = 
80004ac0:	90 08       	ld.sh	r8,r8[0x0]
80004ac2:	5c 88       	casts.h	r8
80004ac4:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
80004ac8:	4c 49       	lddpc	r9,80004bd8 <phy_xnl_tx+0x158>
80004aca:	b2 08       	st.h	r9[0x0],r8
				/*
				Handle to first fragment. Assume index to a valid fragment block.
                Points to first hWord in fragment block.
				*/
				xnl_tx_channel->dword = 
				                   phy_ptr->xnl_fragment.phy_header.phy_control;
80004acc:	4c 18       	lddpc	r8,80004bd0 <phy_xnl_tx+0x150>
80004ace:	70 08       	ld.w	r8,r8[0x0]
80004ad0:	90 08       	ld.sh	r8,r8[0x0]
				
				/*
				Handle to first fragment. Assume index to a valid fragment block.
                Points to first hWord in fragment block.
				*/
				xnl_tx_channel->dword = 
80004ad2:	f3 d8 c0 10 	bfextu	r9,r8,0x0,0x10
80004ad6:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004ada:	91 09       	st.w	r8[0x0],r9
				                   phy_ptr->xnl_fragment.phy_header.phy_control;
				
				/*Transmit 0xABCD0000 | Type/Length.*/
				xnl_tx_channel->dword |= PHYHEADER32;
80004adc:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004ae0:	70 08       	ld.w	r8,r8[0x0]
80004ae2:	10 99       	mov	r9,r8
80004ae4:	ea 19 ab cd 	orh	r9,0xabcd
80004ae8:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004aec:	91 09       	st.w	r8[0x0],r9
				
				phy_tx_index = 1;
80004aee:	4b c9       	lddpc	r9,80004bdc <phy_xnl_tx+0x15c>
80004af0:	30 18       	mov	r8,1
80004af2:	b2 88       	st.b	r9[0x0],r8
				phy_tx_state = WRITE_NEXT_DWORD;	
80004af4:	4b 58       	lddpc	r8,80004bc8 <phy_xnl_tx+0x148>
80004af6:	30 19       	mov	r9,1
80004af8:	91 09       	st.w	r8[0x0],r9
			else
			{
				/*Nothing new to transmit, send an idle frame*/
				xnl_tx_channel->dword = XNL_IDLE;
			}			
			break;
80004afa:	c6 48       	rjmp	80004bc2 <phy_xnl_tx+0x142>
				/*The new transmission has started.*/
			}
			else
			{
				/*Nothing new to transmit, send an idle frame*/
				xnl_tx_channel->dword = XNL_IDLE;
80004afc:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004b00:	e0 69 5a 5a 	mov	r9,23130
80004b04:	ea 19 ab cd 	orh	r9,0xabcd
80004b08:	91 09       	st.w	r8[0x0],r9
			}			
			break;
80004b0a:	c5 c8       	rjmp	80004bc2 <phy_xnl_tx+0x142>
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80004b0c:	4b 18       	lddpc	r8,80004bd0 <phy_xnl_tx+0x150>
80004b0e:	70 09       	ld.w	r9,r8[0x0]
80004b10:	4b 38       	lddpc	r8,80004bdc <phy_xnl_tx+0x15c>
80004b12:	11 88       	ld.ub	r8,r8[0x0]
80004b14:	10 9a       	mov	r10,r8
80004b16:	f2 0a 04 19 	ld.sh	r9,r9[r10<<0x1]
80004b1a:	5c 79       	castu.h	r9
80004b1c:	b1 69       	lsl	r9,0x10
				xnl_tx_channel->dword = XNL_IDLE;
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
80004b1e:	12 9a       	mov	r10,r9
80004b20:	ee f9 ff f8 	ld.w	r9,r7[-8]
80004b24:	93 0a       	st.w	r9[0x0],r10
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80004b26:	2f f8       	sub	r8,-1
80004b28:	5c 58       	castu.b	r8
80004b2a:	4a d9       	lddpc	r9,80004bdc <phy_xnl_tx+0x15c>
80004b2c:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
80004b2e:	4a b8       	lddpc	r8,80004bd8 <phy_xnl_tx+0x158>
80004b30:	90 08       	ld.sh	r8,r8[0x0]
80004b32:	20 28       	sub	r8,2
80004b34:	5c 88       	casts.h	r8
80004b36:	5c 88       	casts.h	r8
80004b38:	4a 89       	lddpc	r9,80004bd8 <phy_xnl_tx+0x158>
80004b3a:	b2 08       	st.h	r9[0x0],r8
			
			/*have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80004b3c:	4a 78       	lddpc	r8,80004bd8 <phy_xnl_tx+0x158>
80004b3e:	90 09       	ld.sh	r9,r8[0x0]
80004b40:	30 08       	mov	r8,0
80004b42:	f0 09 19 00 	cp.h	r9,r8
80004b46:	e0 89 00 0f 	brgt	80004b64 <phy_xnl_tx+0xe4>
			{
				/*Must immediately send 0x00BA in Slot 4.*/
				xnl_tx_channel->dword |= PHYTERMRIGHT;
80004b4a:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004b4e:	70 08       	ld.w	r8,r8[0x0]
80004b50:	10 99       	mov	r9,r8
80004b52:	e8 19 00 ba 	orl	r9,0xba
80004b56:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004b5a:	91 09       	st.w	r8[0x0],r9
				
				/*Go back to waiting.*/
				//vPortFree(phy_ptr);
				phy_tx_state = WAITING_FOR_PHY_TX;
80004b5c:	49 b8       	lddpc	r8,80004bc8 <phy_xnl_tx+0x148>
80004b5e:	30 09       	mov	r9,0
80004b60:	91 09       	st.w	r8[0x0],r9
				break;
80004b62:	c3 08       	rjmp	80004bc2 <phy_xnl_tx+0x142>
			}

			/*Have not broken. Transmit 2nd hWord.*/
			xnl_tx_channel->dword |=  phy_ptr->fragment_element[phy_tx_index++];
80004b64:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004b68:	70 0a       	ld.w	r10,r8[0x0]
80004b6a:	49 a8       	lddpc	r8,80004bd0 <phy_xnl_tx+0x150>
80004b6c:	70 09       	ld.w	r9,r8[0x0]
80004b6e:	49 c8       	lddpc	r8,80004bdc <phy_xnl_tx+0x15c>
80004b70:	11 88       	ld.ub	r8,r8[0x0]
80004b72:	10 9b       	mov	r11,r8
80004b74:	f2 0b 04 19 	ld.sh	r9,r9[r11<<0x1]
80004b78:	5c 79       	castu.h	r9
80004b7a:	12 4a       	or	r10,r9
80004b7c:	ee f9 ff f8 	ld.w	r9,r7[-8]
80004b80:	93 0a       	st.w	r9[0x0],r10
80004b82:	2f f8       	sub	r8,-1
80004b84:	5c 58       	castu.b	r8
80004b86:	49 69       	lddpc	r9,80004bdc <phy_xnl_tx+0x15c>
80004b88:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
80004b8a:	49 48       	lddpc	r8,80004bd8 <phy_xnl_tx+0x158>
80004b8c:	90 08       	ld.sh	r8,r8[0x0]
80004b8e:	20 28       	sub	r8,2
80004b90:	5c 88       	casts.h	r8
80004b92:	5c 88       	casts.h	r8
80004b94:	49 19       	lddpc	r9,80004bd8 <phy_xnl_tx+0x158>
80004b96:	b2 08       	st.h	r9[0x0],r8
			
			/*Have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80004b98:	49 08       	lddpc	r8,80004bd8 <phy_xnl_tx+0x158>
80004b9a:	90 09       	ld.sh	r9,r8[0x0]
80004b9c:	30 08       	mov	r8,0
80004b9e:	f0 09 19 00 	cp.h	r9,r8
80004ba2:	e0 89 00 0f 	brgt	80004bc0 <phy_xnl_tx+0x140>
			{
				/*Must send 0x00BA0000 next interrupt in Slot 3&4*/
				phy_tx_state = SEND_TAILED;
80004ba6:	48 98       	lddpc	r8,80004bc8 <phy_xnl_tx+0x148>
80004ba8:	30 29       	mov	r9,2
80004baa:	91 09       	st.w	r8[0x0],r9
			}
			break;
80004bac:	c0 b8       	rjmp	80004bc2 <phy_xnl_tx+0x142>

		case SEND_TAILED:
			/*send 0x00BA0000*/
			xnl_tx_channel->dword = PHYTERMLEFT;
80004bae:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004bb2:	fc 19 00 ba 	movh	r9,0xba
80004bb6:	91 09       	st.w	r8[0x0],r9
			
			/*Go back to waiting.*/	
			//vPortFree(phy_ptr);		
			phy_tx_state = WAITING_FOR_PHY_TX;		
80004bb8:	48 48       	lddpc	r8,80004bc8 <phy_xnl_tx+0x148>
80004bba:	30 09       	mov	r9,0
80004bbc:	91 09       	st.w	r8[0x0],r9
80004bbe:	c0 28       	rjmp	80004bc2 <phy_xnl_tx+0x142>
			if (phy_tx_expexted_length <= 0)
			{
				/*Must send 0x00BA0000 next interrupt in Slot 3&4*/
				phy_tx_state = SEND_TAILED;
			}
			break;
80004bc0:	d7 03       	nop
			/*This fragment finished.*/
			
		default:
			break;
	}
}
80004bc2:	2f ed       	sub	sp,-8
80004bc4:	e3 cd 80 80 	ldm	sp++,r7,pc
80004bc8:	00 00       	add	r0,r0
80004bca:	0a f4       	st.b	--r5,r4
80004bcc:	00 00       	add	r0,r0
80004bce:	0a 90       	mov	r0,r5
80004bd0:	00 00       	add	r0,r0
80004bd2:	0a f8       	st.b	--r5,r8
80004bd4:	80 00       	ld.sh	r0,r0[0x0]
80004bd6:	93 3c       	st.w	r9[0xc],r12
80004bd8:	00 00       	add	r0,r0
80004bda:	0a fc       	st.b	--r5,r12
80004bdc:	00 00       	add	r0,r0
80004bde:	0a fe       	st.b	--r5,lr

80004be0 <phy_xnl_rx>:
Calls:   
    phy_rx
Called By: phy_rx_func
*/
static void phy_xnl_rx(xnl_channel_t * xnl_rx_channel)
{
80004be0:	eb cd 40 80 	pushm	r7,lr
80004be4:	1a 97       	mov	r7,sp
80004be6:	20 3d       	sub	sp,12
80004be8:	ef 4c ff f4 	st.w	r7[-12],r12
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80004bec:	30 08       	mov	r8,0
80004bee:	ef 48 ff f8 	st.w	r7[-8],r8
	static U16 phy_check_sum = 0;

	static phy_rx_state_t  phy_rx_state = WAITING_FOR_HEADER;
	static U32 phy_rx_count = 0;

	U32 phy_dword = xnl_rx_channel->dword;	
80004bf2:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004bf6:	70 08       	ld.w	r8,r8[0x0]
80004bf8:	ef 48 ff fc 	st.w	r7[-4],r8

	phy_rx_count++;
80004bfc:	fe f8 02 c4 	ld.w	r8,pc[708]
80004c00:	70 08       	ld.w	r8,r8[0x0]
80004c02:	f0 c9 ff ff 	sub	r9,r8,-1
80004c06:	fe f8 02 ba 	ld.w	r8,pc[698]
80004c0a:	91 09       	st.w	r8[0x0],r9
	
	/*This is the code for parsing the incoming physical message.*/
	switch (phy_rx_state)
80004c0c:	fe f8 02 b8 	ld.w	r8,pc[696]
80004c10:	70 08       	ld.w	r8,r8[0x0]
80004c12:	58 18       	cp.w	r8,1
80004c14:	e0 80 00 ba 	breq	80004d88 <phy_xnl_rx+0x1a8>
80004c18:	c0 93       	brcs	80004c2a <phy_xnl_rx+0x4a>
80004c1a:	58 28       	cp.w	r8,2
80004c1c:	e0 80 00 81 	breq	80004d1e <phy_xnl_rx+0x13e>
80004c20:	58 38       	cp.w	r8,3
80004c22:	e0 80 01 24 	breq	80004e6a <phy_xnl_rx+0x28a>
80004c26:	e0 8f 01 49 	bral	80004eb8 <phy_xnl_rx+0x2d8>

        /*Waiting for something. Most frequent visit.*/		
		case WAITING_FOR_HEADER:
		
			/*Ignore Idles.*/
			if (0xABCD5A5A == phy_dword)
80004c2a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004c2e:	e0 69 5a 5a 	mov	r9,23130
80004c32:	ea 19 ab cd 	orh	r9,0xabcd
80004c36:	12 38       	cp.w	r8,r9
80004c38:	e0 80 01 37 	breq	80004ea6 <phy_xnl_rx+0x2c6>
			{
				break;
			}	

			/*Skip until Header.*/		
			if (0xABCD != (phy_dword >> 16))
80004c3c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004c40:	b1 88       	lsr	r8,0x10
80004c42:	e0 48 ab cd 	cp.w	r8,43981
80004c46:	e0 81 01 32 	brne	80004eaa <phy_xnl_rx+0x2ca>
			{			
				break;
			}
		
			/*Length excluding CSUM.*/
			phy_rx_expexted_length = (phy_dword & 0x000000FF) - 2;
80004c4a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004c4e:	5c 88       	casts.h	r8
80004c50:	5c 88       	casts.h	r8
80004c52:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
80004c56:	20 28       	sub	r8,2
80004c58:	5c 88       	casts.h	r8
80004c5a:	5c 88       	casts.h	r8
80004c5c:	fe f9 02 6c 	ld.w	r9,pc[620]
80004c60:	b2 08       	st.h	r9[0x0],r8
			
			/*Discard degenerate message.*/
			if (phy_rx_expexted_length <= 0)
80004c62:	fe f8 02 66 	ld.w	r8,pc[614]
80004c66:	90 09       	ld.sh	r9,r8[0x0]
80004c68:	30 08       	mov	r8,0
80004c6a:	f0 09 19 00 	cp.h	r9,r8
80004c6e:	e0 8a 01 20 	brle	80004eae <phy_xnl_rx+0x2ce>
			{
				break;
			}
		
			phy_rx_length = 0;
80004c72:	fe f9 02 5a 	ld.w	r9,pc[602]
80004c76:	30 08       	mov	r8,0
80004c78:	b2 08       	st.h	r9[0x0],r8
			
			//get_xnl_idle_isr(&phy_frame_ptr, &xHigherPriorityTaskWoken);
			phy_frame_ptr = get_xnl_idle_isr();
80004c7a:	fe f8 02 56 	ld.w	r8,pc[598]
80004c7e:	70 08       	ld.w	r8,r8[0x0]
80004c80:	10 9c       	mov	r12,r8
80004c82:	f0 1f 00 95 	mcall	80004ed4 <phy_xnl_rx+0x2f4>
80004c86:	18 98       	mov	r8,r12
80004c88:	10 99       	mov	r9,r8
80004c8a:	fe f8 02 4e 	ld.w	r8,pc[590]
80004c8e:	91 09       	st.w	r8[0x0],r9
			if(NULL == phy_frame_ptr)
80004c90:	fe f8 02 48 	ld.w	r8,pc[584]
80004c94:	70 08       	ld.w	r8,r8[0x0]
80004c96:	58 08       	cp.w	r8,0
80004c98:	e0 80 01 0d 	breq	80004eb2 <phy_xnl_rx+0x2d2>
			//
			//xQueueReceiveFromISR(phy_store_idle, &phy_frame_ptr, &xHigherPriorityTaskWoken);
			
			//phy_frame_ptr = pvPortMalloc(sizeof(phy_fragment_t));
					
			phy_frame_ptr->fragment_element[phy_rx_length++] = phy_dword;
80004c9c:	fe f8 02 3c 	ld.w	r8,pc[572]
80004ca0:	70 0a       	ld.w	r10,r8[0x0]
80004ca2:	fe f8 02 2a 	ld.w	r8,pc[554]
80004ca6:	90 08       	ld.sh	r8,r8[0x0]
80004ca8:	10 9b       	mov	r11,r8
80004caa:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004cae:	5c 89       	casts.h	r9
80004cb0:	f4 0b 0a 19 	st.h	r10[r11<<0x1],r9
80004cb4:	2f f8       	sub	r8,-1
80004cb6:	5c 88       	casts.h	r8
80004cb8:	fe f9 02 14 	ld.w	r9,pc[532]
80004cbc:	b2 08       	st.h	r9[0x0],r8
			
			/*time stamp*/
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
80004cbe:	fe f8 02 1a 	ld.w	r8,pc[538]
80004cc2:	70 0a       	ld.w	r10,r8[0x0]
80004cc4:	fe f8 02 08 	ld.w	r8,pc[520]
80004cc8:	90 08       	ld.sh	r8,r8[0x0]
80004cca:	10 9b       	mov	r11,r8
80004ccc:	4f d9       	lddpc	r9,80004ec0 <phy_xnl_rx+0x2e0>
80004cce:	72 09       	ld.w	r9,r9[0x0]
80004cd0:	5c 89       	casts.h	r9
80004cd2:	f4 0b 0a 19 	st.h	r10[r11<<0x1],r9
80004cd6:	2f f8       	sub	r8,-1
80004cd8:	5c 88       	casts.h	r8
80004cda:	4f d9       	lddpc	r9,80004ecc <phy_xnl_rx+0x2ec>
80004cdc:	b2 08       	st.h	r9[0x0],r8
													(phy_rx_count) & 0x0000FFFF;
			
			/*This switch tests the fragment type, and adjusts receiver state
			accordingly.*/
			/*Check frag type*/
			switch (phy_dword & 0x00000F00)
80004cde:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004ce2:	e2 18 0f 00 	andl	r8,0xf00,COH
80004ce6:	e0 48 01 00 	cp.w	r8,256
80004cea:	c0 c0       	breq	80004d02 <phy_xnl_rx+0x122>
80004cec:	e0 8b 00 05 	brhi	80004cf6 <phy_xnl_rx+0x116>
80004cf0:	58 08       	cp.w	r8,0
80004cf2:	c0 80       	breq	80004d02 <phy_xnl_rx+0x122>
80004cf4:	c0 c8       	rjmp	80004d0c <phy_xnl_rx+0x12c>
80004cf6:	e0 48 02 00 	cp.w	r8,512
80004cfa:	c0 40       	breq	80004d02 <phy_xnl_rx+0x122>
80004cfc:	e0 48 03 00 	cp.w	r8,768
80004d00:	c0 61       	brne	80004d0c <phy_xnl_rx+0x12c>
			{
				case SINGLE_FRAGMENT:  //Only Fragment.
				case FIRST_FRAGMENT:   //First of Multi-fragment.
				case MIDDLE_FRAGMENT:  //Continuing Multi-fragment.
				case LAST_FRAGMENT:    //Last Multi-fragment.
					phy_rx_state = WAITING_CHECK_SUM;
80004d02:	4f 18       	lddpc	r8,80004ec4 <phy_xnl_rx+0x2e4>
80004d04:	30 29       	mov	r9,2
80004d06:	91 09       	st.w	r8[0x0],r9
				break;
80004d08:	d7 03       	nop
				default:
					vPortFree(phy_frame_ptr);
					phy_frame_ptr = NULL;					
				break;
			}	
			break;
80004d0a:	cd 78       	rjmp	80004eb8 <phy_xnl_rx+0x2d8>
				case MIDDLE_FRAGMENT:  //Continuing Multi-fragment.
				case LAST_FRAGMENT:    //Last Multi-fragment.
					phy_rx_state = WAITING_CHECK_SUM;
				break;
				default:
					vPortFree(phy_frame_ptr);
80004d0c:	4f 38       	lddpc	r8,80004ed8 <phy_xnl_rx+0x2f8>
80004d0e:	70 08       	ld.w	r8,r8[0x0]
80004d10:	10 9c       	mov	r12,r8
80004d12:	f0 1f 00 73 	mcall	80004edc <phy_xnl_rx+0x2fc>
					phy_frame_ptr = NULL;					
80004d16:	4f 18       	lddpc	r8,80004ed8 <phy_xnl_rx+0x2f8>
80004d18:	30 09       	mov	r9,0
80004d1a:	91 09       	st.w	r8[0x0],r9
				break;
			}	
			break;
80004d1c:	cc e8       	rjmp	80004eb8 <phy_xnl_rx+0x2d8>
		Gets here on CSUM. Expect at least one hWord payload. Gets here once 
		on every fragment.*/	
		case WAITING_CHECK_SUM:
		
			/*Stores CSUM*/
			phy_check_sum  = (phy_dword & 0xFFFF0000) >> 16;
80004d1e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004d22:	b1 88       	lsr	r8,0x10
80004d24:	5c 88       	casts.h	r8
80004d26:	4e f9       	lddpc	r9,80004ee0 <phy_xnl_rx+0x300>
80004d28:	b2 08       	st.h	r9[0x0],r8
			
			/*sums in first hWord*/
			phy_check_sum += (phy_dword & 0x0000FFFF);		
80004d2a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004d2e:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
80004d32:	4e c8       	lddpc	r8,80004ee0 <phy_xnl_rx+0x300>
80004d34:	90 08       	ld.sh	r8,r8[0x0]
80004d36:	f2 08 00 08 	add	r8,r9,r8
80004d3a:	5c 88       	casts.h	r8
80004d3c:	4e 99       	lddpc	r9,80004ee0 <phy_xnl_rx+0x300>
80004d3e:	b2 08       	st.h	r9[0x0],r8
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
80004d40:	4e 68       	lddpc	r8,80004ed8 <phy_xnl_rx+0x2f8>
80004d42:	70 0a       	ld.w	r10,r8[0x0]
80004d44:	4e 28       	lddpc	r8,80004ecc <phy_xnl_rx+0x2ec>
80004d46:	90 08       	ld.sh	r8,r8[0x0]
80004d48:	10 9b       	mov	r11,r8
80004d4a:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004d4e:	5c 89       	casts.h	r9
80004d50:	f4 0b 0a 19 	st.h	r10[r11<<0x1],r9
80004d54:	2f f8       	sub	r8,-1
80004d56:	5c 88       	casts.h	r8
80004d58:	4d d9       	lddpc	r9,80004ecc <phy_xnl_rx+0x2ec>
80004d5a:	b2 08       	st.h	r9[0x0],r8
														 phy_dword & 0x0000FFFF;
					
			phy_rx_expexted_length -= 2;
80004d5c:	4d b8       	lddpc	r8,80004ec8 <phy_xnl_rx+0x2e8>
80004d5e:	90 08       	ld.sh	r8,r8[0x0]
80004d60:	20 28       	sub	r8,2
80004d62:	5c 88       	casts.h	r8
80004d64:	5c 88       	casts.h	r8
80004d66:	4d 99       	lddpc	r9,80004ec8 <phy_xnl_rx+0x2e8>
80004d68:	b2 08       	st.h	r9[0x0],r8
			
			/*Normal case for greater than one byte payloads.*/
			if (phy_rx_expexted_length > 0)
80004d6a:	4d 88       	lddpc	r8,80004ec8 <phy_xnl_rx+0x2e8>
80004d6c:	90 09       	ld.sh	r9,r8[0x0]
80004d6e:	30 08       	mov	r8,0
80004d70:	f0 09 19 00 	cp.h	r9,r8
80004d74:	e0 8a 00 06 	brle	80004d80 <phy_xnl_rx+0x1a0>
			{					  
				phy_rx_state = READING_FRAGMENT;
80004d78:	4d 38       	lddpc	r8,80004ec4 <phy_xnl_rx+0x2e4>
80004d7a:	30 19       	mov	r9,1
80004d7c:	91 09       	st.w	r8[0x0],r9
				(slot 4) to ensure alignment. [9.1.3]
				*/
				phy_rx_state = WAITING_LAST_TERM;
			}			
		
			break;
80004d7e:	c9 d8       	rjmp	80004eb8 <phy_xnl_rx+0x2d8>
	    		Note that all segments must align with a 32-bit boundary and
				beginning of each XCMP/XNL payload frame must start on slot 3
				Thus, segments of odd length must append a 0x0000 at the end
				(slot 4) to ensure alignment. [9.1.3]
				*/
				phy_rx_state = WAITING_LAST_TERM;
80004d80:	4d 18       	lddpc	r8,80004ec4 <phy_xnl_rx+0x2e4>
80004d82:	30 39       	mov	r9,3
80004d84:	91 09       	st.w	r8[0x0],r9
			}			
		
			break;
80004d86:	c9 98       	rjmp	80004eb8 <phy_xnl_rx+0x2d8>

		case READING_FRAGMENT:
			phy_check_sum += (phy_dword & 0xFFFF0000) >> 16;
80004d88:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004d8c:	b1 88       	lsr	r8,0x10
80004d8e:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
80004d92:	4d 48       	lddpc	r8,80004ee0 <phy_xnl_rx+0x300>
80004d94:	90 08       	ld.sh	r8,r8[0x0]
80004d96:	f2 08 00 08 	add	r8,r9,r8
80004d9a:	5c 88       	casts.h	r8
80004d9c:	4d 19       	lddpc	r9,80004ee0 <phy_xnl_rx+0x300>
80004d9e:	b2 08       	st.h	r9[0x0],r8
	
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
80004da0:	4c e8       	lddpc	r8,80004ed8 <phy_xnl_rx+0x2f8>
80004da2:	70 0a       	ld.w	r10,r8[0x0]
80004da4:	4c a8       	lddpc	r8,80004ecc <phy_xnl_rx+0x2ec>
80004da6:	90 08       	ld.sh	r8,r8[0x0]
80004da8:	10 9b       	mov	r11,r8
												 (phy_dword & 0xFFFF0000) >> 16;
80004daa:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004dae:	b1 89       	lsr	r9,0x10
			break;

		case READING_FRAGMENT:
			phy_check_sum += (phy_dword & 0xFFFF0000) >> 16;
	
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
80004db0:	5c 89       	casts.h	r9
80004db2:	f4 0b 0a 19 	st.h	r10[r11<<0x1],r9
80004db6:	2f f8       	sub	r8,-1
80004db8:	5c 88       	casts.h	r8
80004dba:	4c 59       	lddpc	r9,80004ecc <phy_xnl_rx+0x2ec>
80004dbc:	b2 08       	st.h	r9[0x0],r8
												 (phy_dword & 0xFFFF0000) >> 16;
	
			phy_rx_expexted_length -= 2;
80004dbe:	4c 38       	lddpc	r8,80004ec8 <phy_xnl_rx+0x2e8>
80004dc0:	90 08       	ld.sh	r8,r8[0x0]
80004dc2:	20 28       	sub	r8,2
80004dc4:	5c 88       	casts.h	r8
80004dc6:	5c 88       	casts.h	r8
80004dc8:	4c 09       	lddpc	r9,80004ec8 <phy_xnl_rx+0x2e8>
80004dca:	b2 08       	st.h	r9[0x0],r8
			if (phy_rx_expexted_length <= 0)
80004dcc:	4b f8       	lddpc	r8,80004ec8 <phy_xnl_rx+0x2e8>
80004dce:	90 09       	ld.sh	r9,r8[0x0]
80004dd0:	30 08       	mov	r8,0
80004dd2:	f0 09 19 00 	cp.h	r9,r8
80004dd6:	e0 89 00 1f 	brgt	80004e14 <phy_xnl_rx+0x234>
				Terminator should be in 2nd hWord.
				Shaoqun says useful bits not used. The packet will always end
				with $00BA. [9.1.2.8]	
				*/
				
				if ((0x000000BA == (phy_dword  & 0x0000FFFF)) 
80004dda:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004dde:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
80004de2:	e0 48 00 ba 	cp.w	r8,186
80004de6:	c0 b1       	brne	80004dfc <phy_xnl_rx+0x21c>
					&& (phy_check_sum == 0))
80004de8:	4b e8       	lddpc	r8,80004ee0 <phy_xnl_rx+0x300>
80004dea:	90 08       	ld.sh	r8,r8[0x0]
				Terminator should be in 2nd hWord.
				Shaoqun says useful bits not used. The packet will always end
				with $00BA. [9.1.2.8]	
				*/
				
				if ((0x000000BA == (phy_dword  & 0x0000FFFF)) 
80004dec:	58 08       	cp.w	r8,0
80004dee:	c0 71       	brne	80004dfc <phy_xnl_rx+0x21c>
					&& (phy_check_sum == 0))
				{
					phy_rx(phy_frame_ptr);
80004df0:	4b a8       	lddpc	r8,80004ed8 <phy_xnl_rx+0x2f8>
80004df2:	70 08       	ld.w	r8,r8[0x0]
80004df4:	10 9c       	mov	r12,r8
80004df6:	f0 1f 00 3c 	mcall	80004ee4 <phy_xnl_rx+0x304>
				Terminator should be in 2nd hWord.
				Shaoqun says useful bits not used. The packet will always end
				with $00BA. [9.1.2.8]	
				*/
				
				if ((0x000000BA == (phy_dword  & 0x0000FFFF)) 
80004dfa:	c0 98       	rjmp	80004e0c <phy_xnl_rx+0x22c>
				{
					phy_rx(phy_frame_ptr);
				}
				else
				{
					vPortFree(phy_frame_ptr);
80004dfc:	4b 78       	lddpc	r8,80004ed8 <phy_xnl_rx+0x2f8>
80004dfe:	70 08       	ld.w	r8,r8[0x0]
80004e00:	10 9c       	mov	r12,r8
80004e02:	f0 1f 00 37 	mcall	80004edc <phy_xnl_rx+0x2fc>
					phy_frame_ptr = NULL;
80004e06:	4b 58       	lddpc	r8,80004ed8 <phy_xnl_rx+0x2f8>
80004e08:	30 09       	mov	r9,0
80004e0a:	91 09       	st.w	r8[0x0],r9
				}

				phy_rx_state = WAITING_FOR_HEADER;
80004e0c:	4a e8       	lddpc	r8,80004ec4 <phy_xnl_rx+0x2e4>
80004e0e:	30 09       	mov	r9,0
80004e10:	91 09       	st.w	r8[0x0],r9
				break;
80004e12:	c5 38       	rjmp	80004eb8 <phy_xnl_rx+0x2d8>
			}
		
			/*Have not broken. 2nd hWord contains payload.*/
			phy_check_sum += (phy_dword & 0x0000FFFF);
80004e14:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004e18:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
80004e1c:	4b 18       	lddpc	r8,80004ee0 <phy_xnl_rx+0x300>
80004e1e:	90 08       	ld.sh	r8,r8[0x0]
80004e20:	f2 08 00 08 	add	r8,r9,r8
80004e24:	5c 88       	casts.h	r8
80004e26:	4a f9       	lddpc	r9,80004ee0 <phy_xnl_rx+0x300>
80004e28:	b2 08       	st.h	r9[0x0],r8
		
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
80004e2a:	4a c8       	lddpc	r8,80004ed8 <phy_xnl_rx+0x2f8>
80004e2c:	70 0a       	ld.w	r10,r8[0x0]
80004e2e:	4a 88       	lddpc	r8,80004ecc <phy_xnl_rx+0x2ec>
80004e30:	90 08       	ld.sh	r8,r8[0x0]
80004e32:	10 9b       	mov	r11,r8
80004e34:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004e38:	5c 89       	casts.h	r9
80004e3a:	f4 0b 0a 19 	st.h	r10[r11<<0x1],r9
80004e3e:	2f f8       	sub	r8,-1
80004e40:	5c 88       	casts.h	r8
80004e42:	4a 39       	lddpc	r9,80004ecc <phy_xnl_rx+0x2ec>
80004e44:	b2 08       	st.h	r9[0x0],r8
													   (phy_dword & 0x0000FFFF);
		
			phy_rx_expexted_length -= 2;
80004e46:	4a 18       	lddpc	r8,80004ec8 <phy_xnl_rx+0x2e8>
80004e48:	90 08       	ld.sh	r8,r8[0x0]
80004e4a:	20 28       	sub	r8,2
80004e4c:	5c 88       	casts.h	r8
80004e4e:	5c 88       	casts.h	r8
80004e50:	49 e9       	lddpc	r9,80004ec8 <phy_xnl_rx+0x2e8>
80004e52:	b2 08       	st.h	r9[0x0],r8
			if (phy_rx_expexted_length <= 0)
80004e54:	49 d8       	lddpc	r8,80004ec8 <phy_xnl_rx+0x2e8>
80004e56:	90 09       	ld.sh	r9,r8[0x0]
80004e58:	30 08       	mov	r8,0
80004e5a:	f0 09 19 00 	cp.h	r9,r8
80004e5e:	e0 89 00 2c 	brgt	80004eb6 <phy_xnl_rx+0x2d6>
			{
				/*All read in. Next Word should be 0x00BA0000.*/
				phy_rx_state = WAITING_LAST_TERM;
80004e62:	49 98       	lddpc	r8,80004ec4 <phy_xnl_rx+0x2e4>
80004e64:	30 39       	mov	r9,3
80004e66:	91 09       	st.w	r8[0x0],r9
			}/*else, next Word contains more payload.*/
			break;
80004e68:	c2 88       	rjmp	80004eb8 <phy_xnl_rx+0x2d8>

		/*Expecting last terminator 0x00BA0000.*/	
		case WAITING_LAST_TERM:			
			if ((0x00BA0000 == (phy_dword  & 0x00FF0000)) /*Expected found.*/
80004e6a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004e6e:	e6 18 00 ff 	andh	r8,0xff,COH
80004e72:	fc 19 00 ba 	movh	r9,0xba
80004e76:	12 38       	cp.w	r8,r9
80004e78:	c0 b1       	brne	80004e8e <phy_xnl_rx+0x2ae>
				&& (phy_check_sum == 0))/*Good checksum*/
80004e7a:	49 a8       	lddpc	r8,80004ee0 <phy_xnl_rx+0x300>
80004e7c:	90 08       	ld.sh	r8,r8[0x0]
			}/*else, next Word contains more payload.*/
			break;

		/*Expecting last terminator 0x00BA0000.*/	
		case WAITING_LAST_TERM:			
			if ((0x00BA0000 == (phy_dword  & 0x00FF0000)) /*Expected found.*/
80004e7e:	58 08       	cp.w	r8,0
80004e80:	c0 71       	brne	80004e8e <phy_xnl_rx+0x2ae>
				&& (phy_check_sum == 0))/*Good checksum*/
			{
				phy_rx(phy_frame_ptr);
80004e82:	49 68       	lddpc	r8,80004ed8 <phy_xnl_rx+0x2f8>
80004e84:	70 08       	ld.w	r8,r8[0x0]
80004e86:	10 9c       	mov	r12,r8
80004e88:	f0 1f 00 17 	mcall	80004ee4 <phy_xnl_rx+0x304>
			}/*else, next Word contains more payload.*/
			break;

		/*Expecting last terminator 0x00BA0000.*/	
		case WAITING_LAST_TERM:			
			if ((0x00BA0000 == (phy_dword  & 0x00FF0000)) /*Expected found.*/
80004e8c:	c0 98       	rjmp	80004e9e <phy_xnl_rx+0x2be>
				phy_rx(phy_frame_ptr);

			}
			else
			{
				vPortFree(phy_frame_ptr);
80004e8e:	49 38       	lddpc	r8,80004ed8 <phy_xnl_rx+0x2f8>
80004e90:	70 08       	ld.w	r8,r8[0x0]
80004e92:	10 9c       	mov	r12,r8
80004e94:	f0 1f 00 12 	mcall	80004edc <phy_xnl_rx+0x2fc>
				phy_frame_ptr = NULL;
80004e98:	49 08       	lddpc	r8,80004ed8 <phy_xnl_rx+0x2f8>
80004e9a:	30 09       	mov	r9,0
80004e9c:	91 09       	st.w	r8[0x0],r9
			}
				
			phy_rx_state = WAITING_FOR_HEADER;
80004e9e:	48 a8       	lddpc	r8,80004ec4 <phy_xnl_rx+0x2e4>
80004ea0:	30 09       	mov	r9,0
80004ea2:	91 09       	st.w	r8[0x0],r9
80004ea4:	c0 a8       	rjmp	80004eb8 <phy_xnl_rx+0x2d8>
		case WAITING_FOR_HEADER:
		
			/*Ignore Idles.*/
			if (0xABCD5A5A == phy_dword)
			{
				break;
80004ea6:	d7 03       	nop
80004ea8:	c0 88       	rjmp	80004eb8 <phy_xnl_rx+0x2d8>
			}	

			/*Skip until Header.*/		
			if (0xABCD != (phy_dword >> 16))
			{			
				break;
80004eaa:	d7 03       	nop
80004eac:	c0 68       	rjmp	80004eb8 <phy_xnl_rx+0x2d8>
			phy_rx_expexted_length = (phy_dword & 0x000000FF) - 2;
			
			/*Discard degenerate message.*/
			if (phy_rx_expexted_length <= 0)
			{
				break;
80004eae:	d7 03       	nop
80004eb0:	c0 48       	rjmp	80004eb8 <phy_xnl_rx+0x2d8>
			
			//get_xnl_idle_isr(&phy_frame_ptr, &xHigherPriorityTaskWoken);
			phy_frame_ptr = get_xnl_idle_isr();
			if(NULL == phy_frame_ptr)
			{
				break;
80004eb2:	d7 03       	nop
80004eb4:	c0 28       	rjmp	80004eb8 <phy_xnl_rx+0x2d8>
			if (phy_rx_expexted_length <= 0)
			{
				/*All read in. Next Word should be 0x00BA0000.*/
				phy_rx_state = WAITING_LAST_TERM;
			}/*else, next Word contains more payload.*/
			break;
80004eb6:	d7 03       	nop
			phy_rx_state = WAITING_FOR_HEADER;
			break;
		default:
		break;
	}/*End of phy_rx_state switch.*/
}
80004eb8:	2f dd       	sub	sp,-12
80004eba:	e3 cd 80 80 	ldm	sp++,r7,pc
80004ebe:	00 00       	add	r0,r0
80004ec0:	00 00       	add	r0,r0
80004ec2:	0a e0       	st.h	--r5,r0
80004ec4:	00 00       	add	r0,r0
80004ec6:	0a e4       	st.h	--r5,r4
80004ec8:	00 00       	add	r0,r0
80004eca:	0a e8       	st.h	--r5,r8
80004ecc:	00 00       	add	r0,r0
80004ece:	0a ea       	st.h	--r5,r10
80004ed0:	00 00       	add	r0,r0
80004ed2:	0a 8c       	andn	r12,r5
80004ed4:	80 00       	ld.sh	r0,r0[0x0]
80004ed6:	64 7c       	ld.w	r12,r2[0x1c]
80004ed8:	00 00       	add	r0,r0
80004eda:	0a ec       	st.h	--r5,r12
80004edc:	80 00       	ld.sh	r0,r0[0x0]
80004ede:	8d f4       	st.w	r6[0x3c],r4
80004ee0:	00 00       	add	r0,r0
80004ee2:	0a f0       	st.b	--r5,r0
80004ee4:	80 00       	ld.sh	r0,r0[0x0]
80004ee6:	49 94       	lddpc	r4,80004f48 <phy_payload_tx+0x60>

80004ee8 <phy_payload_tx>:
Calls: 
Called By:phy_tx_func
*/

static void phy_payload_tx(payload_channel_t * payload_tx_channel)
{
80004ee8:	eb cd 40 80 	pushm	r7,lr
80004eec:	1a 97       	mov	r7,sp
80004eee:	20 1d       	sub	sp,4
80004ef0:	ef 4c ff fc 	st.w	r7[-4],r12
	
	//static U8 frame_5_end = 0;
	//static U16 pay[256];
	
	//Send-AMBE-data
	if ((AMBE_Media == TRUE))
80004ef4:	fe f8 05 b8 	ld.w	r8,pc[1464]
80004ef8:	11 89       	ld.ub	r9,r8[0x0]
80004efa:	30 18       	mov	r8,1
80004efc:	f0 09 18 00 	cp.b	r9,r8
80004f00:	e0 81 02 c8 	brne	80005490 <phy_payload_tx+0x5a8>
	{
		A_index = (A_index >=1456) ? 0 : A_index;
80004f04:	fe f8 05 ac 	ld.w	r8,pc[1452]
80004f08:	70 08       	ld.w	r8,r8[0x0]
80004f0a:	e0 48 05 af 	cp.w	r8,1455
80004f0e:	e0 8b 00 06 	brhi	80004f1a <phy_payload_tx+0x32>
80004f12:	fe f8 05 9e 	ld.w	r8,pc[1438]
80004f16:	70 08       	ld.w	r8,r8[0x0]
80004f18:	c0 28       	rjmp	80004f1c <phy_payload_tx+0x34>
80004f1a:	30 08       	mov	r8,0
80004f1c:	fe f9 05 94 	ld.w	r9,pc[1428]
80004f20:	93 08       	st.w	r9[0x0],r8
	  //AMBE_flag
		switch(AMBEpayload_tx_state)
80004f22:	fe f8 05 92 	ld.w	r8,pc[1426]
80004f26:	70 08       	ld.w	r8,r8[0x0]
80004f28:	58 68       	cp.w	r8,6
80004f2a:	e0 8b 02 a4 	brhi	80005472 <phy_payload_tx+0x58a>
80004f2e:	fe f9 05 8a 	ld.w	r9,pc[1418]
80004f32:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
		{
			case AMBE_IDLE:
		
				if ((m_RxBurstType == VOICE_WATING) || (m_RxBurstType == VOICETERMINATOR)  || (m_RxBurstType == VOICEHEADER))
80004f36:	fe f8 05 86 	ld.w	r8,pc[1414]
80004f3a:	70 08       	ld.w	r8,r8[0x0]
80004f3c:	58 08       	cp.w	r8,0
80004f3e:	c0 b0       	breq	80004f54 <phy_payload_tx+0x6c>
80004f40:	fe f8 05 7c 	ld.w	r8,pc[1404]
80004f44:	70 08       	ld.w	r8,r8[0x0]
80004f46:	58 a8       	cp.w	r8,10
80004f48:	c0 60       	breq	80004f54 <phy_payload_tx+0x6c>
80004f4a:	fe f8 05 72 	ld.w	r8,pc[1394]
80004f4e:	70 08       	ld.w	r8,r8[0x0]
80004f50:	58 18       	cp.w	r8,1
80004f52:	c0 f1       	brne	80004f70 <phy_payload_tx+0x88>
				{
							
					payload_tx_channel->dword[0] = PAYLOADIDLE0;
80004f54:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004f58:	e0 69 5a 5a 	mov	r9,23130
80004f5c:	ea 19 ab cd 	orh	r9,0xabcd
80004f60:	91 09       	st.w	r8[0x0],r9
					payload_tx_channel->dword[1] = PAYLOADIDLE1;
80004f62:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004f66:	30 09       	mov	r9,0
80004f68:	91 19       	st.w	r8[0x4],r9
	  //AMBE_flag
		switch(AMBEpayload_tx_state)
		{
			case AMBE_IDLE:
		
				if ((m_RxBurstType == VOICE_WATING) || (m_RxBurstType == VOICETERMINATOR)  || (m_RxBurstType == VOICEHEADER))
80004f6a:	d7 03       	nop
						AMBEpayload_tx_state = AMBE_EN_FIRST;
					}

				}
				
				break;
80004f6c:	e0 8f 02 9d 	bral	800054a6 <phy_payload_tx+0x5be>
							
					payload_tx_channel->dword[0] = PAYLOADIDLE0;
					payload_tx_channel->dword[1] = PAYLOADIDLE1;
			
				}
				else if((m_RxBurstType == UNSUREDATA))
80004f70:	fe f8 05 4c 	ld.w	r8,pc[1356]
80004f74:	70 08       	ld.w	r8,r8[0x0]
80004f76:	58 38       	cp.w	r8,3
80004f78:	c0 f1       	brne	80004f96 <phy_payload_tx+0xae>
				{
					payload_tx_channel->dword[0] = AMBE_HT[0];
80004f7a:	fe f8 05 46 	ld.w	r8,pc[1350]
80004f7e:	70 09       	ld.w	r9,r8[0x0]
80004f80:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004f84:	91 09       	st.w	r8[0x0],r9
					payload_tx_channel->dword[1] = AMBE_HT[1];
80004f86:	fe f8 05 3a 	ld.w	r8,pc[1338]
80004f8a:	70 19       	ld.w	r9,r8[0x4]
80004f8c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004f90:	91 19       	st.w	r8[0x4],r9
						AMBEpayload_tx_state = AMBE_EN_FIRST;
					}

				}
				
				break;
80004f92:	e0 8f 02 8a 	bral	800054a6 <phy_payload_tx+0x5be>
				else//
				{
					
					//Radio Internal Parameter + Vocoder Bits Stream Parameter + soft decision value + 1st 20ms AMBE bits of Voice Burst A 
					//assemble 4 items into 1 Command. Send it to Radio.
					if (m_RxBurstType == RADIOINTERNAL)//
80004f96:	fe f8 05 26 	ld.w	r8,pc[1318]
80004f9a:	70 08       	ld.w	r8,r8[0x0]
80004f9c:	58 28       	cp.w	r8,2
80004f9e:	c1 a1       	brne	80004fd2 <phy_payload_tx+0xea>
					{
						//0xABCDCO32
						payload_tx_channel->dword[0] = DE_OB_PAYLOAD;//50bytes
80004fa0:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004fa4:	e0 69 c0 32 	mov	r9,49202
80004fa8:	ea 19 ab cd 	orh	r9,0xabcd
80004fac:	91 09       	st.w	r8[0x0],r9
						//0x847F
						payload_tx_channel->word[2] = RIP_PAYLOAD;
80004fae:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004fb2:	fe 78 84 7f 	mov	r8,-31617
80004fb6:	b2 28       	st.h	r9[0x4],r8
						//0xxxxx
						payload_tx_channel->word[3] = Radio_Internal_Data[0];
80004fb8:	fe f8 05 0c 	ld.w	r8,pc[1292]
80004fbc:	90 08       	ld.sh	r8,r8[0x0]
80004fbe:	5c 88       	casts.h	r8
80004fc0:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004fc4:	b2 38       	st.h	r9[0x6],r8
						
						AMBEpayload_tx_state = AMBE_DE_FIRST;
80004fc6:	fe f8 04 ee 	ld.w	r8,pc[1262]
80004fca:	30 39       	mov	r9,3
80004fcc:	91 09       	st.w	r8[0x0],r9
						AMBEpayload_tx_state = AMBE_EN_FIRST;
					}

				}
				
				break;
80004fce:	e0 8f 02 6c 	bral	800054a6 <phy_payload_tx+0x5be>
					//assemble 2 items into 1 Command. Send it to Radio.
					else//
					{
	
						//0xABCDCOOE
						payload_tx_channel->dword[0] = EN_OB_PAYLOAD;//49bits
80004fd2:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004fd6:	e0 69 c0 0e 	mov	r9,49166
80004fda:	ea 19 ab cd 	orh	r9,0xabcd
80004fde:	91 09       	st.w	r8[0x0],r9
						//0x8212
						payload_tx_channel->word[2] = VBSP_data[0];
80004fe0:	fe f8 04 e8 	ld.w	r8,pc[1256]
80004fe4:	90 08       	ld.sh	r8,r8[0x0]
80004fe6:	5c 88       	casts.h	r8
80004fe8:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004fec:	b2 28       	st.h	r9[0x4],r8
						//0xF00x
						payload_tx_channel->word[3] = VBSP_data[1];
80004fee:	fe f8 04 da 	ld.w	r8,pc[1242]
80004ff2:	90 18       	ld.sh	r8,r8[0x2]
80004ff4:	5c 88       	casts.h	r8
80004ff6:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004ffa:	b2 38       	st.h	r9[0x6],r8
						
						AMBEpayload_tx_state = AMBE_EN_FIRST;
80004ffc:	fe f8 04 b8 	ld.w	r8,pc[1208]
80005000:	30 19       	mov	r9,1
80005002:	91 09       	st.w	r8[0x0],r9
					}

				}
				
				break;
80005004:	e0 8f 02 51 	bral	800054a6 <phy_payload_tx+0x5be>
			
			case AMBE_EN_FIRST:
			
			
				//0x88F2
				payload_tx_channel->word[0] = ENCODER_PAYLOAD;//49bits
80005008:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000500c:	fe 78 88 f2 	mov	r8,-30478
80005010:	b2 08       	st.h	r9[0x0],r8
				//A_index+=2;
				//
				//AMBEpayload_tx_state = AMBE_EN_LAST;
				
			
				switch (m_RxBurstType)//
80005012:	fe f8 04 aa 	ld.w	r8,pc[1194]
80005016:	70 08       	ld.w	r8,r8[0x0]
80005018:	58 48       	cp.w	r8,4
8000501a:	c0 60       	breq	80005026 <phy_payload_tx+0x13e>
8000501c:	c7 73       	brcs	8000510a <phy_payload_tx+0x222>
8000501e:	58 98       	cp.w	r8,9
80005020:	e0 8b 00 75 	brhi	8000510a <phy_payload_tx+0x222>
80005024:	c4 78       	rjmp	800050b2 <phy_payload_tx+0x1ca>
				{
					case VOICEBURST_A:
							if (VF_SN == 1)
80005026:	fe f8 04 a6 	ld.w	r8,pc[1190]
8000502a:	11 89       	ld.ub	r9,r8[0x0]
8000502c:	30 18       	mov	r8,1
8000502e:	f0 09 18 00 	cp.b	r9,r8
80005032:	c1 41       	brne	8000505a <phy_payload_tx+0x172>
							{	
								
								
								//Place public key
								payload_tx_channel->word[1] = Public_AMBEkey[0];
80005034:	fe f8 04 9c 	ld.w	r8,pc[1180]
80005038:	90 08       	ld.sh	r8,r8[0x0]
8000503a:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000503e:	b2 18       	st.h	r9[0x2],r8
								payload_tx_channel->word[2] = Public_AMBEkey[1];
80005040:	fe f8 04 90 	ld.w	r8,pc[1168]
80005044:	90 18       	ld.sh	r8,r8[0x2]
80005046:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000504a:	b2 28       	st.h	r9[0x4],r8
								payload_tx_channel->word[3] = Public_AMBEkey[2];
8000504c:	fe f8 04 84 	ld.w	r8,pc[1156]
80005050:	90 28       	ld.sh	r8,r8[0x4]
80005052:	ee f9 ff fc 	ld.w	r9,r7[-4]
80005056:	b2 38       	st.h	r9[0x6],r8
80005058:	c2 88       	rjmp	800050a8 <phy_payload_tx+0x1c0>
							{
								
								
						
								//Encrypted AMBE data(XOR)
								payload_tx_channel->word[1] = ((Public_AMBEkey[0]) ^ (AMBEBurst_rawdata[0])) ;
8000505a:	fe f8 04 76 	ld.w	r8,pc[1142]
8000505e:	90 09       	ld.sh	r9,r8[0x0]
80005060:	fe f8 04 74 	ld.w	r8,pc[1140]
80005064:	90 08       	ld.sh	r8,r8[0x0]
80005066:	5c 88       	casts.h	r8
80005068:	f3 e8 20 08 	eor	r8,r9,r8
8000506c:	5c 88       	casts.h	r8
8000506e:	ee f9 ff fc 	ld.w	r9,r7[-4]
80005072:	b2 18       	st.h	r9[0x2],r8
								payload_tx_channel->word[2] = ((Public_AMBEkey[1]) ^ (AMBEBurst_rawdata[1])) ;
80005074:	fe f8 04 5c 	ld.w	r8,pc[1116]
80005078:	90 19       	ld.sh	r9,r8[0x2]
8000507a:	fe f8 04 5a 	ld.w	r8,pc[1114]
8000507e:	90 18       	ld.sh	r8,r8[0x2]
80005080:	5c 88       	casts.h	r8
80005082:	f3 e8 20 08 	eor	r8,r9,r8
80005086:	5c 88       	casts.h	r8
80005088:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000508c:	b2 28       	st.h	r9[0x4],r8
								payload_tx_channel->word[3] = ((Public_AMBEkey[2]) ^ (AMBEBurst_rawdata[2])) ;
8000508e:	fe f8 04 42 	ld.w	r8,pc[1090]
80005092:	90 29       	ld.sh	r9,r8[0x4]
80005094:	fe f8 04 40 	ld.w	r8,pc[1088]
80005098:	90 28       	ld.sh	r8,r8[0x4]
8000509a:	5c 88       	casts.h	r8
8000509c:	f3 e8 20 08 	eor	r8,r9,r8
800050a0:	5c 88       	casts.h	r8
800050a2:	ee f9 ff fc 	ld.w	r9,r7[-4]
800050a6:	b2 38       	st.h	r9[0x6],r8
								//payload_tx_channel->word[3] = AMBEBurst_rawdata[2];
							
						
							}
					
							AMBEpayload_tx_state = AMBE_EN_LAST;
800050a8:	fe f8 04 0c 	ld.w	r8,pc[1036]
800050ac:	30 29       	mov	r9,2
800050ae:	91 09       	st.w	r8[0x0],r9
					
						break;
800050b0:	c3 e8       	rjmp	8000512c <phy_payload_tx+0x244>
							//Encrypted AMBE data(XOR)
						
							//payload_tx_channel->word[1] = AMBEBurst_rawdata[0];
							//payload_tx_channel->word[2] = AMBEBurst_rawdata[1];
							//payload_tx_channel->word[3] = AMBEBurst_rawdata[2];
							payload_tx_channel->word[1] = ((Public_AMBEkey[0]) ^ (AMBEBurst_rawdata[0])) ;
800050b2:	fe f8 04 1e 	ld.w	r8,pc[1054]
800050b6:	90 09       	ld.sh	r9,r8[0x0]
800050b8:	fe f8 04 1c 	ld.w	r8,pc[1052]
800050bc:	90 08       	ld.sh	r8,r8[0x0]
800050be:	5c 88       	casts.h	r8
800050c0:	f3 e8 20 08 	eor	r8,r9,r8
800050c4:	5c 88       	casts.h	r8
800050c6:	ee f9 ff fc 	ld.w	r9,r7[-4]
800050ca:	b2 18       	st.h	r9[0x2],r8
							payload_tx_channel->word[2] = ((Public_AMBEkey[1]) ^ (AMBEBurst_rawdata[1])) ;
800050cc:	fe f8 04 04 	ld.w	r8,pc[1028]
800050d0:	90 19       	ld.sh	r9,r8[0x2]
800050d2:	fe f8 04 02 	ld.w	r8,pc[1026]
800050d6:	90 18       	ld.sh	r8,r8[0x2]
800050d8:	5c 88       	casts.h	r8
800050da:	f3 e8 20 08 	eor	r8,r9,r8
800050de:	5c 88       	casts.h	r8
800050e0:	ee f9 ff fc 	ld.w	r9,r7[-4]
800050e4:	b2 28       	st.h	r9[0x4],r8
							payload_tx_channel->word[3] = ((Public_AMBEkey[2]) ^ (AMBEBurst_rawdata[2])) ;
800050e6:	fe f8 03 ea 	ld.w	r8,pc[1002]
800050ea:	90 29       	ld.sh	r9,r8[0x4]
800050ec:	fe f8 03 e8 	ld.w	r8,pc[1000]
800050f0:	90 28       	ld.sh	r8,r8[0x4]
800050f2:	5c 88       	casts.h	r8
800050f4:	f3 e8 20 08 	eor	r8,r9,r8
800050f8:	5c 88       	casts.h	r8
800050fa:	ee f9 ff fc 	ld.w	r9,r7[-4]
800050fe:	b2 38       	st.h	r9[0x6],r8
						
							AMBEpayload_tx_state = AMBE_EN_LAST;
80005100:	fe f8 03 b4 	ld.w	r8,pc[948]
80005104:	30 29       	mov	r9,2
80005106:	91 09       	st.w	r8[0x0],r9
				
						break;
80005108:	c1 28       	rjmp	8000512c <phy_payload_tx+0x244>
					default://This shouldn't happen, but must check;
					
							payload_tx_channel->dword[0] = PAYLOADIDLE0;
8000510a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000510e:	e0 69 5a 5a 	mov	r9,23130
80005112:	ea 19 ab cd 	orh	r9,0xabcd
80005116:	91 09       	st.w	r8[0x0],r9
							payload_tx_channel->dword[1] = PAYLOADIDLE1;
80005118:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000511c:	30 09       	mov	r9,0
8000511e:	91 19       	st.w	r8[0x4],r9
							
							AMBEpayload_tx_state = AMBE_IDLE;
80005120:	fe f8 03 94 	ld.w	r8,pc[916]
80005124:	30 09       	mov	r9,0
80005126:	91 09       	st.w	r8[0x0],r9
				}
		
		
		
		
				break;
80005128:	e0 8f 01 bf 	bral	800054a6 <phy_payload_tx+0x5be>
8000512c:	e0 8f 01 bd 	bral	800054a6 <phy_payload_tx+0x5be>
						  1:VF1 of first Burst A after last Voice Header (49 bits).
						  2:Last 4 bits (bit 45 to bit 48) of every 49 bits AMBE Voice Frame. (72 bits@Super Frame).
					
					*/
					
					payload_tx_channel->word[0] = AMBEBurst_rawdata[3];
80005130:	fe f8 03 a4 	ld.w	r8,pc[932]
80005134:	90 38       	ld.sh	r8,r8[0x6]
80005136:	5c 88       	casts.h	r8
80005138:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000513c:	b2 08       	st.h	r9[0x0],r8
					
					
					//payload_tx_channel->word[0] = ((AMBE_AudioData[A_index]<<8) + 0x00) ;//Pad_bits
					//A_index+=1;
					
					payload_tx_channel->word[1]	= 0x00BA ; 
8000513e:	ee f9 ff fc 	ld.w	r9,r7[-4]
80005142:	e0 68 00 ba 	mov	r8,186
80005146:	b2 18       	st.h	r9[0x2],r8
					payload_tx_channel->word[2]	= 0x0000 ;
80005148:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000514c:	30 08       	mov	r8,0
8000514e:	b2 28       	st.h	r9[0x4],r8
					payload_tx_channel->word[3]	= 0x0000 ;
80005150:	ee f9 ff fc 	ld.w	r9,r7[-4]
80005154:	30 08       	mov	r8,0
80005156:	b2 38       	st.h	r9[0x6],r8
				
					AMBEpayload_tx_state = AMBE_IDLE;
80005158:	fe f8 03 5c 	ld.w	r8,pc[860]
8000515c:	30 09       	mov	r9,0
8000515e:	91 09       	st.w	r8[0x0],r9
				
				break;
80005160:	e0 8f 01 a3 	bral	800054a6 <phy_payload_tx+0x5be>
				
			case AMBE_DE_FIRST:
				
					//0xxxxx
					payload_tx_channel->word[0] = Radio_Internal_Data[1];
80005164:	fe f8 03 60 	ld.w	r8,pc[864]
80005168:	90 18       	ld.sh	r8,r8[0x2]
8000516a:	5c 88       	casts.h	r8
8000516c:	ee f9 ff fc 	ld.w	r9,r7[-4]
80005170:	b2 08       	st.h	r9[0x0],r8
					//0x8212
					payload_tx_channel->word[1] = VBSP_data[0];
80005172:	fe f8 03 56 	ld.w	r8,pc[854]
80005176:	90 08       	ld.sh	r8,r8[0x0]
80005178:	5c 88       	casts.h	r8
8000517a:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000517e:	b2 18       	st.h	r9[0x2],r8
					
					if ((m_RxBurstType == VOICEBURST_A) && (VF_SN == 1) )
80005180:	fe f8 03 3c 	ld.w	r8,pc[828]
80005184:	70 08       	ld.w	r8,r8[0x0]
80005186:	58 48       	cp.w	r8,4
80005188:	c1 21       	brne	800051ac <phy_payload_tx+0x2c4>
8000518a:	fe f8 03 42 	ld.w	r8,pc[834]
8000518e:	11 89       	ld.ub	r9,r8[0x0]
80005190:	30 18       	mov	r8,1
80005192:	f0 09 18 00 	cp.b	r9,r8
80005196:	c0 b1       	brne	800051ac <phy_payload_tx+0x2c4>
					{
						// Vocoder Bits Stream Parameter("E(bit8)" flag = 1)
						//0xF0(8+)x
						payload_tx_channel->word[2] = ((VBSP_data[1]) | (0x0100));
80005198:	fe f8 03 30 	ld.w	r8,pc[816]
8000519c:	90 18       	ld.sh	r8,r8[0x2]
8000519e:	5c 88       	casts.h	r8
800051a0:	a9 a8       	sbr	r8,0x8
800051a2:	5c 88       	casts.h	r8
800051a4:	ee f9 ff fc 	ld.w	r9,r7[-4]
800051a8:	b2 28       	st.h	r9[0x4],r8
					//0xxxxx
					payload_tx_channel->word[0] = Radio_Internal_Data[1];
					//0x8212
					payload_tx_channel->word[1] = VBSP_data[0];
					
					if ((m_RxBurstType == VOICEBURST_A) && (VF_SN == 1) )
800051aa:	c0 88       	rjmp	800051ba <phy_payload_tx+0x2d2>
						//0xF0(8+)x
						payload_tx_channel->word[2] = ((VBSP_data[1]) | (0x0100));
					}
					else
						//0xF00x
						payload_tx_channel->word[2] = (VBSP_data[1]) ;
800051ac:	fe f8 03 1c 	ld.w	r8,pc[796]
800051b0:	90 18       	ld.sh	r8,r8[0x2]
800051b2:	5c 88       	casts.h	r8
800051b4:	ee f9 ff fc 	ld.w	r9,r7[-4]
800051b8:	b2 28       	st.h	r9[0x4],r8
					
					//0x9A13
					payload_tx_channel->word[3] = SDV_PAYLOAD;
800051ba:	ee f9 ff fc 	ld.w	r9,r7[-4]
800051be:	fe 78 9a 13 	mov	r8,-26093
800051c2:	b2 38       	st.h	r9[0x6],r8
		
					AMBEpayload_tx_state = AMBE_DE_SECOND;
800051c4:	fe f8 02 f0 	ld.w	r8,pc[752]
800051c8:	30 49       	mov	r9,4
800051ca:	91 09       	st.w	r8[0x0],r9
					
				break;
800051cc:	e0 8f 01 6d 	bral	800054a6 <phy_payload_tx+0x5be>
			
			case AMBE_DE_SECOND:
					//Post back soft decision value data

						payload_tx_channel->word[0] = Soft_Decision_Data[Soft_index] ;
800051d0:	fe f8 03 08 	ld.w	r8,pc[776]
800051d4:	70 09       	ld.w	r9,r8[0x0]
800051d6:	fe f8 03 06 	ld.w	r8,pc[774]
800051da:	f0 09 04 18 	ld.sh	r8,r8[r9<<0x1]
800051de:	5c 88       	casts.h	r8
800051e0:	ee f9 ff fc 	ld.w	r9,r7[-4]
800051e4:	b2 08       	st.h	r9[0x0],r8
						payload_tx_channel->word[1] = Soft_Decision_Data[Soft_index+1] ;
800051e6:	fe f8 02 f2 	ld.w	r8,pc[754]
800051ea:	70 08       	ld.w	r8,r8[0x0]
800051ec:	f0 c9 ff ff 	sub	r9,r8,-1
800051f0:	fe f8 02 ec 	ld.w	r8,pc[748]
800051f4:	f0 09 04 18 	ld.sh	r8,r8[r9<<0x1]
800051f8:	5c 88       	casts.h	r8
800051fa:	ee f9 ff fc 	ld.w	r9,r7[-4]
800051fe:	b2 18       	st.h	r9[0x2],r8
						payload_tx_channel->word[2] = Soft_Decision_Data[Soft_index+2] ;
80005200:	fe f8 02 d8 	ld.w	r8,pc[728]
80005204:	70 08       	ld.w	r8,r8[0x0]
80005206:	f0 c9 ff fe 	sub	r9,r8,-2
8000520a:	fe f8 02 d2 	ld.w	r8,pc[722]
8000520e:	f0 09 04 18 	ld.sh	r8,r8[r9<<0x1]
80005212:	5c 88       	casts.h	r8
80005214:	ee f9 ff fc 	ld.w	r9,r7[-4]
80005218:	b2 28       	st.h	r9[0x4],r8
						payload_tx_channel->word[3] = Soft_Decision_Data[Soft_index+3] ;
8000521a:	fe f8 02 be 	ld.w	r8,pc[702]
8000521e:	70 08       	ld.w	r8,r8[0x0]
80005220:	f0 c9 ff fd 	sub	r9,r8,-3
80005224:	fe f8 02 b8 	ld.w	r8,pc[696]
80005228:	f0 09 04 18 	ld.sh	r8,r8[r9<<0x1]
8000522c:	5c 88       	casts.h	r8
8000522e:	ee f9 ff fc 	ld.w	r9,r7[-4]
80005232:	b2 38       	st.h	r9[0x6],r8
						Soft_index +=4;
80005234:	fe f8 02 a4 	ld.w	r8,pc[676]
80005238:	70 08       	ld.w	r8,r8[0x0]
8000523a:	f0 c9 ff fc 	sub	r9,r8,-4
8000523e:	fe f8 02 9a 	ld.w	r8,pc[666]
80005242:	91 09       	st.w	r8[0x0],r9
						
						if (Soft_index == 12)
80005244:	fe f8 02 94 	ld.w	r8,pc[660]
80005248:	70 08       	ld.w	r8,r8[0x0]
8000524a:	58 c8       	cp.w	r8,12
8000524c:	c0 71       	brne	8000525a <phy_payload_tx+0x372>
						{
							AMBEpayload_tx_state = AMBE_DE_THIRD;
8000524e:	fe f8 02 66 	ld.w	r8,pc[614]
80005252:	30 59       	mov	r9,5
80005254:	91 09       	st.w	r8[0x0],r9
							
						}
						else
						AMBEpayload_tx_state = AMBE_DE_SECOND;
			
				break;	
80005256:	e0 8f 01 28 	bral	800054a6 <phy_payload_tx+0x5be>
							AMBEpayload_tx_state = AMBE_DE_THIRD;
							//Soft_index = 0 ;
							
						}
						else
						AMBEpayload_tx_state = AMBE_DE_SECOND;
8000525a:	fe f8 02 5a 	ld.w	r8,pc[602]
8000525e:	30 49       	mov	r9,4
80005260:	91 09       	st.w	r8[0x0],r9
			
				break;	
80005262:	e0 8f 01 22 	bral	800054a6 <phy_payload_tx+0x5be>
				
			case AMBE_DE_THIRD:
					
					//0x xxxx
					payload_tx_channel->word[0] = Soft_Decision_Data[Soft_index] ;
80005266:	fe f8 02 72 	ld.w	r8,pc[626]
8000526a:	70 09       	ld.w	r9,r8[0x0]
8000526c:	fe f8 02 70 	ld.w	r8,pc[624]
80005270:	f0 09 04 18 	ld.sh	r8,r8[r9<<0x1]
80005274:	5c 88       	casts.h	r8
80005276:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000527a:	b2 08       	st.h	r9[0x0],r8
					Soft_index = 0 ;//
8000527c:	fe f8 02 5c 	ld.w	r8,pc[604]
80005280:	30 09       	mov	r9,0
80005282:	91 09       	st.w	r8[0x0],r9
					
					//0x8003 
					payload_tx_channel->word[1] = 0x8003;
80005284:	ee f9 ff fc 	ld.w	r9,r7[-4]
80005288:	fe 78 80 03 	mov	r8,-32765
8000528c:	b2 18       	st.h	r9[0x2],r8
					//0x88F3
					payload_tx_channel->word[2] = DECODER_PAYLOAD;
8000528e:	ee f9 ff fc 	ld.w	r9,r7[-4]
80005292:	fe 78 88 f3 	mov	r8,-30477
80005296:	b2 28       	st.h	r9[0x4],r8
				
					switch (m_RxBurstType)//
80005298:	fe f8 02 24 	ld.w	r8,pc[548]
8000529c:	70 08       	ld.w	r8,r8[0x0]
8000529e:	58 48       	cp.w	r8,4
800052a0:	c0 60       	breq	800052ac <phy_payload_tx+0x3c4>
800052a2:	c3 e3       	brcs	8000531e <phy_payload_tx+0x436>
800052a4:	58 98       	cp.w	r8,9
800052a6:	e0 8b 00 3c 	brhi	8000531e <phy_payload_tx+0x436>
800052aa:	c2 98       	rjmp	800052fc <phy_payload_tx+0x414>
					{
						case VOICEBURST_A:
								if (VF_SN == 1)
800052ac:	fe f8 02 20 	ld.w	r8,pc[544]
800052b0:	11 89       	ld.ub	r9,r8[0x0]
800052b2:	30 18       	mov	r8,1
800052b4:	f0 09 18 00 	cp.b	r9,r8
800052b8:	c1 01       	brne	800052d8 <phy_payload_tx+0x3f0>
									//if(AMBEBurst_rawdata[0] == Public_AMBEkey[0])//0X1AC3
									{
										
									
										//Pick up public key
										AMBE_DecryptionKey[0] = AMBEBurst_rawdata[0];
800052ba:	fe f8 02 1a 	ld.w	r8,pc[538]
800052be:	90 08       	ld.sh	r8,r8[0x0]
800052c0:	5c 88       	casts.h	r8
800052c2:	fe f9 02 1e 	ld.w	r9,pc[542]
800052c6:	b2 08       	st.h	r9[0x0],r8
									
										//Post back data
										payload_tx_channel->word[3] = AMBEBurst_rawdata[0] ;
800052c8:	fe f8 02 0c 	ld.w	r8,pc[524]
800052cc:	90 08       	ld.sh	r8,r8[0x0]
800052ce:	5c 88       	casts.h	r8
800052d0:	ee f9 ff fc 	ld.w	r9,r7[-4]
800052d4:	b2 38       	st.h	r9[0x6],r8
800052d6:	c0 f8       	rjmp	800052f4 <phy_payload_tx+0x40c>
								else//VF_SN==2/3
								{	
									//Decrypt AMBE data(XOR) 
									//Recover data

									payload_tx_channel->word[3] = ((AMBE_DecryptionKey[0]) ^ (AMBEBurst_rawdata[0])) ;
800052d8:	fe f8 02 08 	ld.w	r8,pc[520]
800052dc:	90 08       	ld.sh	r8,r8[0x0]
800052de:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
800052e2:	4f d8       	lddpc	r8,800054d4 <phy_payload_tx+0x5ec>
800052e4:	90 08       	ld.sh	r8,r8[0x0]
800052e6:	5c 88       	casts.h	r8
800052e8:	f3 e8 20 08 	eor	r8,r9,r8
800052ec:	5c 88       	casts.h	r8
800052ee:	ee f9 ff fc 	ld.w	r9,r7[-4]
800052f2:	b2 38       	st.h	r9[0x6],r8
									
									//payload_tx_channel->word[3] = ((AMBEBurst_rawdata[0])) ;
						
								}
					
								AMBEpayload_tx_state = AMBE_DE_LAST;
800052f4:	4f 08       	lddpc	r8,800054b4 <phy_payload_tx+0x5cc>
800052f6:	30 69       	mov	r9,6
800052f8:	91 09       	st.w	r8[0x0],r9
					
							break;
800052fa:	c2 18       	rjmp	8000533c <phy_payload_tx+0x454>
						
								//Encrypted AMBE data(XOR)
						
								//Decrypt AMBE data(XOR)
								//Recover data
								payload_tx_channel->word[3] = ((AMBE_DecryptionKey[0]) ^ (AMBEBurst_rawdata[0])) ;
800052fc:	4f 98       	lddpc	r8,800054e0 <phy_payload_tx+0x5f8>
800052fe:	90 08       	ld.sh	r8,r8[0x0]
80005300:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
80005304:	4f 48       	lddpc	r8,800054d4 <phy_payload_tx+0x5ec>
80005306:	90 08       	ld.sh	r8,r8[0x0]
80005308:	5c 88       	casts.h	r8
8000530a:	f3 e8 20 08 	eor	r8,r9,r8
8000530e:	5c 88       	casts.h	r8
80005310:	ee f9 ff fc 	ld.w	r9,r7[-4]
80005314:	b2 38       	st.h	r9[0x6],r8
								//payload_tx_channel->word[3] = ((AMBEBurst_rawdata[0])) ;
						
								AMBEpayload_tx_state = AMBE_DE_LAST;
80005316:	4e 88       	lddpc	r8,800054b4 <phy_payload_tx+0x5cc>
80005318:	30 69       	mov	r9,6
8000531a:	91 09       	st.w	r8[0x0],r9
				
							break;
8000531c:	c1 08       	rjmp	8000533c <phy_payload_tx+0x454>
						default://This shouldn't happen, but must check;
					
								payload_tx_channel->dword[0] = PAYLOADIDLE0;
8000531e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005322:	e0 69 5a 5a 	mov	r9,23130
80005326:	ea 19 ab cd 	orh	r9,0xabcd
8000532a:	91 09       	st.w	r8[0x0],r9
								payload_tx_channel->dword[1] = PAYLOADIDLE1;
8000532c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005330:	30 09       	mov	r9,0
80005332:	91 19       	st.w	r8[0x4],r9
								AMBEpayload_tx_state = AMBE_IDLE;
80005334:	4e 08       	lddpc	r8,800054b4 <phy_payload_tx+0x5cc>
80005336:	30 09       	mov	r9,0
80005338:	91 09       	st.w	r8[0x0],r9
					
							break;
					}
		
					break;
8000533a:	cb 68       	rjmp	800054a6 <phy_payload_tx+0x5be>
8000533c:	cb 58       	rjmp	800054a6 <phy_payload_tx+0x5be>
				
			case AMBE_DE_LAST:
				
					switch (m_RxBurstType)//
8000533e:	4e 08       	lddpc	r8,800054bc <phy_payload_tx+0x5d4>
80005340:	70 08       	ld.w	r8,r8[0x0]
80005342:	58 48       	cp.w	r8,4
80005344:	c0 70       	breq	80005352 <phy_payload_tx+0x46a>
80005346:	e0 83 00 85 	brlo	80005450 <phy_payload_tx+0x568>
8000534a:	58 98       	cp.w	r8,9
8000534c:	e0 8b 00 82 	brhi	80005450 <phy_payload_tx+0x568>
80005350:	c5 78       	rjmp	800053fe <phy_payload_tx+0x516>
					{
						case VOICEBURST_A:
							if (VF_SN == 1)
80005352:	4d f8       	lddpc	r8,800054cc <phy_payload_tx+0x5e4>
80005354:	11 89       	ld.ub	r9,r8[0x0]
80005356:	30 18       	mov	r8,1
80005358:	f0 09 18 00 	cp.b	r9,r8
8000535c:	c2 81       	brne	800053ac <phy_payload_tx+0x4c4>
								//if(AMBEBurst_rawdata[1] == Public_AMBEkey[1])//0X1840
								{
								
									//Pick up public key
							
									AMBE_DecryptionKey[1] = AMBEBurst_rawdata[1];
8000535e:	4d e8       	lddpc	r8,800054d4 <phy_payload_tx+0x5ec>
80005360:	90 18       	ld.sh	r8,r8[0x2]
80005362:	5c 88       	casts.h	r8
80005364:	4d f9       	lddpc	r9,800054e0 <phy_payload_tx+0x5f8>
80005366:	b2 18       	st.h	r9[0x2],r8
									AMBE_DecryptionKey[2] = AMBEBurst_rawdata[2];
80005368:	4d b8       	lddpc	r8,800054d4 <phy_payload_tx+0x5ec>
8000536a:	90 28       	ld.sh	r8,r8[0x4]
8000536c:	5c 88       	casts.h	r8
8000536e:	4d d9       	lddpc	r9,800054e0 <phy_payload_tx+0x5f8>
80005370:	b2 28       	st.h	r9[0x4],r8
									AMBE_DecryptionKey[3] = AMBEBurst_rawdata[3];
80005372:	4d 98       	lddpc	r8,800054d4 <phy_payload_tx+0x5ec>
80005374:	90 38       	ld.sh	r8,r8[0x6]
80005376:	5c 88       	casts.h	r8
80005378:	4d a9       	lddpc	r9,800054e0 <phy_payload_tx+0x5f8>
8000537a:	b2 38       	st.h	r9[0x6],r8
							
									//Post back data
									payload_tx_channel->word[0] = AMBEBurst_rawdata[1] ;
8000537c:	4d 68       	lddpc	r8,800054d4 <phy_payload_tx+0x5ec>
8000537e:	90 18       	ld.sh	r8,r8[0x2]
80005380:	5c 88       	casts.h	r8
80005382:	ee f9 ff fc 	ld.w	r9,r7[-4]
80005386:	b2 08       	st.h	r9[0x0],r8
									payload_tx_channel->word[1] = AMBEBurst_rawdata[2] ;
80005388:	4d 38       	lddpc	r8,800054d4 <phy_payload_tx+0x5ec>
8000538a:	90 28       	ld.sh	r8,r8[0x4]
8000538c:	5c 88       	casts.h	r8
8000538e:	ee f9 ff fc 	ld.w	r9,r7[-4]
80005392:	b2 18       	st.h	r9[0x2],r8
									payload_tx_channel->word[2] = AMBEBurst_rawdata[3] ;
80005394:	4d 08       	lddpc	r8,800054d4 <phy_payload_tx+0x5ec>
80005396:	90 38       	ld.sh	r8,r8[0x6]
80005398:	5c 88       	casts.h	r8
8000539a:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000539e:	b2 28       	st.h	r9[0x4],r8
									payload_tx_channel->word[3] = 0x00BA ;
800053a0:	ee f9 ff fc 	ld.w	r9,r7[-4]
800053a4:	e0 68 00 ba 	mov	r8,186
800053a8:	b2 38       	st.h	r9[0x6],r8
800053aa:	c2 68       	rjmp	800053f6 <phy_payload_tx+0x50e>
							{
							
								//Decrypt AMBE data(XOR)
								//Recover data

									payload_tx_channel->word[0] = (AMBEBurst_rawdata[1] ^ AMBE_DecryptionKey[1]);
800053ac:	4c a8       	lddpc	r8,800054d4 <phy_payload_tx+0x5ec>
800053ae:	90 18       	ld.sh	r8,r8[0x2]
800053b0:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
800053b4:	4c b8       	lddpc	r8,800054e0 <phy_payload_tx+0x5f8>
800053b6:	90 18       	ld.sh	r8,r8[0x2]
800053b8:	5c 88       	casts.h	r8
800053ba:	f3 e8 20 08 	eor	r8,r9,r8
800053be:	5c 88       	casts.h	r8
800053c0:	ee f9 ff fc 	ld.w	r9,r7[-4]
800053c4:	b2 08       	st.h	r9[0x0],r8
									payload_tx_channel->word[1] = (AMBEBurst_rawdata[2] ^ AMBE_DecryptionKey[2]);
800053c6:	4c 48       	lddpc	r8,800054d4 <phy_payload_tx+0x5ec>
800053c8:	90 28       	ld.sh	r8,r8[0x4]
800053ca:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
800053ce:	4c 58       	lddpc	r8,800054e0 <phy_payload_tx+0x5f8>
800053d0:	90 28       	ld.sh	r8,r8[0x4]
800053d2:	5c 88       	casts.h	r8
800053d4:	f3 e8 20 08 	eor	r8,r9,r8
800053d8:	5c 88       	casts.h	r8
800053da:	ee f9 ff fc 	ld.w	r9,r7[-4]
800053de:	b2 18       	st.h	r9[0x2],r8
									payload_tx_channel->word[2] = (AMBEBurst_rawdata[3]);
800053e0:	4b d8       	lddpc	r8,800054d4 <phy_payload_tx+0x5ec>
800053e2:	90 38       	ld.sh	r8,r8[0x6]
800053e4:	5c 88       	casts.h	r8
800053e6:	ee f9 ff fc 	ld.w	r9,r7[-4]
800053ea:	b2 28       	st.h	r9[0x4],r8
									
									//payload_tx_channel->word[0] = (AMBEBurst_rawdata[1]);
									//payload_tx_channel->word[1] = (AMBEBurst_rawdata[2]);
									//payload_tx_channel->word[2] = (AMBEBurst_rawdata[3]);
									
									payload_tx_channel->word[3] = 0x00BA ;
800053ec:	ee f9 ff fc 	ld.w	r9,r7[-4]
800053f0:	e0 68 00 ba 	mov	r8,186
800053f4:	b2 38       	st.h	r9[0x6],r8
							
							
							}
						
							AMBEpayload_tx_state = AMBE_IDLE;
800053f6:	4b 08       	lddpc	r8,800054b4 <phy_payload_tx+0x5cc>
800053f8:	30 09       	mov	r9,0
800053fa:	91 09       	st.w	r8[0x0],r9
						
						break;
800053fc:	c3 98       	rjmp	8000546e <phy_payload_tx+0x586>
						
							//Encrypted AMBE data(XOR)
						
							//Decrypt AMBE data(XOR)
							//Recover data
							payload_tx_channel->word[0] = (AMBEBurst_rawdata[1] ^ AMBE_DecryptionKey[1]);
800053fe:	4b 68       	lddpc	r8,800054d4 <phy_payload_tx+0x5ec>
80005400:	90 18       	ld.sh	r8,r8[0x2]
80005402:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
80005406:	4b 78       	lddpc	r8,800054e0 <phy_payload_tx+0x5f8>
80005408:	90 18       	ld.sh	r8,r8[0x2]
8000540a:	5c 88       	casts.h	r8
8000540c:	f3 e8 20 08 	eor	r8,r9,r8
80005410:	5c 88       	casts.h	r8
80005412:	ee f9 ff fc 	ld.w	r9,r7[-4]
80005416:	b2 08       	st.h	r9[0x0],r8
							payload_tx_channel->word[1] = (AMBEBurst_rawdata[2] ^ AMBE_DecryptionKey[2]);
80005418:	4a f8       	lddpc	r8,800054d4 <phy_payload_tx+0x5ec>
8000541a:	90 28       	ld.sh	r8,r8[0x4]
8000541c:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
80005420:	4b 08       	lddpc	r8,800054e0 <phy_payload_tx+0x5f8>
80005422:	90 28       	ld.sh	r8,r8[0x4]
80005424:	5c 88       	casts.h	r8
80005426:	f3 e8 20 08 	eor	r8,r9,r8
8000542a:	5c 88       	casts.h	r8
8000542c:	ee f9 ff fc 	ld.w	r9,r7[-4]
80005430:	b2 18       	st.h	r9[0x2],r8
							payload_tx_channel->word[2] = (AMBEBurst_rawdata[3]);
80005432:	4a 98       	lddpc	r8,800054d4 <phy_payload_tx+0x5ec>
80005434:	90 38       	ld.sh	r8,r8[0x6]
80005436:	5c 88       	casts.h	r8
80005438:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000543c:	b2 28       	st.h	r9[0x4],r8
							
							//payload_tx_channel->word[0] = (AMBEBurst_rawdata[1]);
							//payload_tx_channel->word[1] = (AMBEBurst_rawdata[2]);
							//payload_tx_channel->word[2] = (AMBEBurst_rawdata[3]);
							
							payload_tx_channel->word[3] = 0x00BA ;
8000543e:	ee f9 ff fc 	ld.w	r9,r7[-4]
80005442:	e0 68 00 ba 	mov	r8,186
80005446:	b2 38       	st.h	r9[0x6],r8
						
							AMBEpayload_tx_state = AMBE_IDLE;
80005448:	49 b8       	lddpc	r8,800054b4 <phy_payload_tx+0x5cc>
8000544a:	30 09       	mov	r9,0
8000544c:	91 09       	st.w	r8[0x0],r9
						
							break;
8000544e:	c1 08       	rjmp	8000546e <phy_payload_tx+0x586>
						default://This shouldn't happen, but must check;
						
							payload_tx_channel->dword[0] = PAYLOADIDLE0;
80005450:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005454:	e0 69 5a 5a 	mov	r9,23130
80005458:	ea 19 ab cd 	orh	r9,0xabcd
8000545c:	91 09       	st.w	r8[0x0],r9
							payload_tx_channel->dword[1] = PAYLOADIDLE1;
8000545e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005462:	30 09       	mov	r9,0
80005464:	91 19       	st.w	r8[0x4],r9
							AMBEpayload_tx_state = AMBE_IDLE;
80005466:	49 48       	lddpc	r8,800054b4 <phy_payload_tx+0x5cc>
80005468:	30 09       	mov	r9,0
8000546a:	91 09       	st.w	r8[0x0],r9
							
							break;
					}

				break;
8000546c:	c1 d8       	rjmp	800054a6 <phy_payload_tx+0x5be>
8000546e:	d7 03       	nop
80005470:	c1 b8       	rjmp	800054a6 <phy_payload_tx+0x5be>
		
			default:
			
					payload_tx_channel->dword[0] = PAYLOADIDLE0;
80005472:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005476:	e0 69 5a 5a 	mov	r9,23130
8000547a:	ea 19 ab cd 	orh	r9,0xabcd
8000547e:	91 09       	st.w	r8[0x0],r9
					payload_tx_channel->dword[1] = PAYLOADIDLE1;
80005480:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005484:	30 09       	mov	r9,0
80005486:	91 19       	st.w	r8[0x4],r9
					
					AMBEpayload_tx_state = AMBE_IDLE;
80005488:	48 b8       	lddpc	r8,800054b4 <phy_payload_tx+0x5cc>
8000548a:	30 09       	mov	r9,0
8000548c:	91 09       	st.w	r8[0x0],r9
8000548e:	c0 c8       	rjmp	800054a6 <phy_payload_tx+0x5be>

	}//end of Send-AMBE-data

	else
	{
		payload_tx_channel->dword[0] = PAYLOADIDLE0;
80005490:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005494:	e0 69 5a 5a 	mov	r9,23130
80005498:	ea 19 ab cd 	orh	r9,0xabcd
8000549c:	91 09       	st.w	r8[0x0],r9
		payload_tx_channel->dword[1] = PAYLOADIDLE1;
8000549e:	ee f8 ff fc 	ld.w	r8,r7[-4]
800054a2:	30 09       	mov	r9,0
800054a4:	91 19       	st.w	r8[0x4],r9

	}//end of Send-PCM-data
	
#endif

}
800054a6:	2f fd       	sub	sp,-4
800054a8:	e3 cd 80 80 	ldm	sp++,r7,pc
800054ac:	00 00       	add	r0,r0
800054ae:	0a 5b       	eor	r11,r5
800054b0:	00 00       	add	r0,r0
800054b2:	0a d4       	st.w	--r5,r4
800054b4:	00 00       	add	r0,r0
800054b6:	0a d8       	st.w	--r5,r8
800054b8:	80 01       	ld.sh	r1,r0[0x0]
800054ba:	12 34       	cp.w	r4,r9
800054bc:	00 00       	add	r0,r0
800054be:	0a a4       	st.w	r5++,r4
800054c0:	00 00       	add	r0,r0
800054c2:	0a a8       	st.w	r5++,r8
800054c4:	00 00       	add	r0,r0
800054c6:	1f b0       	ld.ub	r0,pc[0x3]
800054c8:	00 00       	add	r0,r0
800054ca:	20 ac       	sub	r12,10
800054cc:	00 00       	add	r0,r0
800054ce:	0a 5f       	eor	pc,r5
800054d0:	80 01       	ld.sh	r1,r0[0x0]
800054d2:	0c 34       	cp.w	r4,r6
800054d4:	00 00       	add	r0,r0
800054d6:	1f a8       	ld.ub	r8,pc[0x2]
800054d8:	00 00       	add	r0,r0
800054da:	0a dc       	st.w	--r5,r12
800054dc:	00 00       	add	r0,r0
800054de:	20 b0       	sub	r0,11
800054e0:	00 00       	add	r0,r0
800054e2:	1f b4       	ld.ub	r4,pc[0x3]

800054e4 <payload_rx>:




static void payload_rx(void * payload)
{
800054e4:	eb cd 40 80 	pushm	r7,lr
800054e8:	1a 97       	mov	r7,sp
800054ea:	20 2d       	sub	sp,8
800054ec:	ef 4c ff f8 	st.w	r7[-8],r12
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
800054f0:	30 08       	mov	r8,0
800054f2:	ef 48 ff fc 	st.w	r7[-4],r8
	
	//set_payload_idle(payload);
	if(NULL == phy_payload_frame_rx)
800054f6:	49 48       	lddpc	r8,80005544 <payload_rx+0x60>
800054f8:	70 08       	ld.w	r8,r8[0x0]
800054fa:	58 08       	cp.w	r8,0
800054fc:	c0 81       	brne	8000550c <payload_rx+0x28>
	{
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));		
800054fe:	30 4b       	mov	r11,4
80005500:	30 5c       	mov	r12,5
80005502:	f0 1f 00 12 	mcall	80005548 <payload_rx+0x64>
80005506:	18 99       	mov	r9,r12
80005508:	48 f8       	lddpc	r8,80005544 <payload_rx+0x60>
8000550a:	91 09       	st.w	r8[0x0],r9
	}

	if(errQUEUE_FULL == xQueueSendFromISR(phy_payload_frame_rx, &payload, &xHigherPriorityTaskWoken))
8000550c:	48 e8       	lddpc	r8,80005544 <payload_rx+0x60>
8000550e:	70 08       	ld.w	r8,r8[0x0]
80005510:	ee ca 00 04 	sub	r10,r7,4
80005514:	ee cb 00 08 	sub	r11,r7,8
80005518:	30 09       	mov	r9,0
8000551a:	10 9c       	mov	r12,r8
8000551c:	f0 1f 00 0c 	mcall	8000554c <payload_rx+0x68>
80005520:	18 98       	mov	r8,r12
80005522:	58 08       	cp.w	r8,0
80005524:	c0 c1       	brne	8000553c <payload_rx+0x58>
	//if(errQUEUE_FULL == xQueueSend(phy_payload_frame_rx, &payload, 0))
	{	//To payload_rx_process();	
		
		set_payload_idle_isr(payload);
80005526:	ee f9 ff f8 	ld.w	r9,r7[-8]
8000552a:	48 a8       	lddpc	r8,80005550 <payload_rx+0x6c>
8000552c:	70 08       	ld.w	r8,r8[0x0]
8000552e:	12 9b       	mov	r11,r9
80005530:	10 9c       	mov	r12,r8
80005532:	f0 1f 00 09 	mcall	80005554 <payload_rx+0x70>
		logFromISR("mm");
80005536:	48 9c       	lddpc	r12,80005558 <payload_rx+0x74>
80005538:	f0 1f 00 09 	mcall	8000555c <payload_rx+0x78>
			
		}
		//set_payload_idle_isr(payload);
		//logFromISR("ss");
	}
}
8000553c:	2f ed       	sub	sp,-8
8000553e:	e3 cd 80 80 	ldm	sp++,r7,pc
80005542:	00 00       	add	r0,r0
80005544:	00 00       	add	r0,r0
80005546:	0a a0       	st.w	r5++,r0
80005548:	80 00       	ld.sh	r0,r0[0x0]
8000554a:	8e 2c       	ld.sh	r12,r7[0x4]
8000554c:	80 00       	ld.sh	r0,r0[0x0]
8000554e:	90 ac       	ld.uh	r12,r8[0x4]
80005550:	00 00       	add	r0,r0
80005552:	0a 98       	mov	r8,r5
80005554:	80 00       	ld.sh	r0,r0[0x0]
80005556:	64 f0       	ld.w	r0,r2[0x3c]
80005558:	80 00       	ld.sh	r0,r0[0x0]
8000555a:	47 a0       	lddsp	r0,sp[0x1e8]
8000555c:	80 00       	ld.sh	r0,r0[0x0]
8000555e:	aa e0       	st.b	r5[0x6],r0

80005560 <phy_payload_rx>:
Description: receive payload(mdia) packet
Calls: 
Called By:phy_rx_func
*/
static void phy_payload_rx(payload_channel_t * payload_rx_channel)
{
80005560:	eb cd 40 80 	pushm	r7,lr
80005564:	1a 97       	mov	r7,sp
80005566:	20 2d       	sub	sp,8
80005568:	ef 4c ff f8 	st.w	r7[-8],r12
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
8000556c:	30 08       	mov	r8,0
8000556e:	ef 48 ff fc 	st.w	r7[-4],r8
			
	//payload_ptr_t *AMBE_payload_ptr;		
				
	
	
	if(is_first == FALSE)
80005572:	fe f8 0e 5e 	ld.w	r8,pc[3678]
80005576:	11 88       	ld.ub	r8,r8[0x0]
80005578:	58 08       	cp.w	r8,0
8000557a:	c1 01       	brne	8000559a <phy_payload_rx+0x3a>
	{
		//payload_ptr = get_payload_idle_isr();
		AMBE_payload_ptr = get_payload_idle_isr();
8000557c:	fe f8 0e 58 	ld.w	r8,pc[3672]
80005580:	70 08       	ld.w	r8,r8[0x0]
80005582:	10 9c       	mov	r12,r8
80005584:	f0 1f 03 95 	mcall	800063d8 <phy_payload_rx+0xe78>
80005588:	18 98       	mov	r8,r12
8000558a:	10 99       	mov	r9,r8
8000558c:	fe f8 0e 50 	ld.w	r8,pc[3664]
80005590:	91 09       	st.w	r8[0x0],r9
		is_first = TRUE;
80005592:	fe f9 0e 3e 	ld.w	r9,pc[3646]
80005596:	30 18       	mov	r8,1
80005598:	b2 88       	st.b	r9[0x0],r8
	}	
	
	//This is the RxMedia Phy Handler.
	switch (RxMediaState)
8000559a:	fe f8 0e 46 	ld.w	r8,pc[3654]
8000559e:	70 08       	ld.w	r8,r8[0x0]
800055a0:	58 38       	cp.w	r8,3
800055a2:	e0 80 06 ad 	breq	800062fc <phy_payload_rx+0xd9c>
800055a6:	58 48       	cp.w	r8,4
800055a8:	e0 80 01 4e 	breq	80005844 <phy_payload_rx+0x2e4>
800055ac:	58 08       	cp.w	r8,0
800055ae:	e0 81 07 0e 	brne	800063ca <phy_payload_rx+0xe6a>
	{
		case WAITINGABAB:

			
			if (payload_rx_channel->dword[0] == 0xABCD5A5A)//Ignore Idles.
800055b2:	ee f8 ff f8 	ld.w	r8,r7[-8]
800055b6:	70 08       	ld.w	r8,r8[0x0]
800055b8:	e0 69 5a 5a 	mov	r9,23130
800055bc:	ea 19 ab cd 	orh	r9,0xabcd
800055c0:	12 38       	cp.w	r8,r9
800055c2:	c0 71       	brne	800055d0 <phy_payload_rx+0x70>
			{
				m_RxBurstType = VOICE_WATING;
800055c4:	fe f8 0e 20 	ld.w	r8,pc[3616]
800055c8:	30 09       	mov	r9,0
800055ca:	91 09       	st.w	r8[0x0],r9
				//Upon receiving the idle frame, the m Rx Burst Type into an idle state in order to transmit the synchronization wait
				 break; 
800055cc:	e0 8f 06 ff 	bral	800063ca <phy_payload_rx+0xe6a>
			}
            
			if ((payload_rx_channel->dword[0]  & 0xFFFF0000) != 0xABCD0000)break; //Skip until Header. 
800055d0:	ee f8 ff f8 	ld.w	r8,r7[-8]
800055d4:	70 08       	ld.w	r8,r8[0x0]
800055d6:	e0 18 00 00 	andl	r8,0x0
800055da:	fc 19 ab cd 	movh	r9,0xabcd
800055de:	12 38       	cp.w	r8,r9
800055e0:	e0 81 06 ea 	brne	800063b4 <phy_payload_rx+0xe54>
			}
			//logFromISR("\n\r P: %X \n\r", payload_rx_channel->word[1]);//
			
			#endif
			
			RxBytesWaiting = payload_rx_channel->dword[0] & 0x000000FF;
800055e4:	ee f8 ff f8 	ld.w	r8,r7[-8]
800055e8:	70 08       	ld.w	r8,r8[0x0]
800055ea:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
800055ee:	fe f8 0d fa 	ld.w	r8,pc[3578]
800055f2:	91 09       	st.w	r8[0x0],r9
		
			if( (NULL== AMBE_payload_ptr))
800055f4:	fe f8 0d e8 	ld.w	r8,pc[3560]
800055f8:	70 08       	ld.w	r8,r8[0x0]
800055fa:	58 08       	cp.w	r8,0
800055fc:	c1 71       	brne	8000562a <phy_payload_rx+0xca>
			{
				//payload_ptr = get_payload_idle_isr();
				AMBE_payload_ptr = get_payload_idle_isr();
800055fe:	fe f8 0d d6 	ld.w	r8,pc[3542]
80005602:	70 08       	ld.w	r8,r8[0x0]
80005604:	10 9c       	mov	r12,r8
80005606:	f0 1f 03 75 	mcall	800063d8 <phy_payload_rx+0xe78>
8000560a:	18 98       	mov	r8,r12
8000560c:	10 99       	mov	r9,r8
8000560e:	fe f8 0d ce 	ld.w	r8,pc[3534]
80005612:	91 09       	st.w	r8[0x0],r9
				
				if (NULL== AMBE_payload_ptr)
80005614:	fe f8 0d c8 	ld.w	r8,pc[3528]
80005618:	70 08       	ld.w	r8,r8[0x0]
8000561a:	58 08       	cp.w	r8,0
8000561c:	c0 71       	brne	8000562a <phy_payload_rx+0xca>
				{
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//
8000561e:	fe fc 0d ce 	ld.w	r12,pc[3534]
80005622:	f0 1f 03 74 	mcall	800063f0 <phy_payload_rx+0xe90>
					break;
80005626:	e0 8f 06 d2 	bral	800063ca <phy_payload_rx+0xe6a>
			}
			
		
			/****Note AMBE stream protocol frame structure and the PCM frame structure is different*****/
					
			if ((payload_rx_channel->dword[0] & 0x0000F000 ) == PAYLOAD_DATA_ENH )//PAYLOAD_DATA_ENH (0x0c))
8000562a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000562e:	70 08       	ld.w	r8,r8[0x0]
80005630:	e2 18 f0 00 	andl	r8,0xf000,COH
80005634:	e0 48 c0 00 	cp.w	r8,49152
80005638:	e0 81 01 00 	brne	80005838 <phy_payload_rx+0x2d8>
			{
				AMBE_Media = 1;	
8000563c:	fe f9 0d b8 	ld.w	r9,pc[3512]
80005640:	30 18       	mov	r8,1
80005642:	b2 88       	st.b	r9[0x0],r8
											
				Item_ID = payload_rx_channel->byte[5];
80005644:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005648:	11 d8       	ld.ub	r8,r8[0x5]
8000564a:	fe f9 0d ae 	ld.w	r9,pc[3502]
8000564e:	b2 88       	st.b	r9[0x0],r8
				
				Item_Length = (payload_rx_channel->byte[4] & 0x7F);//7bits
80005650:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005654:	11 c8       	ld.ub	r8,r8[0x4]
80005656:	f3 d8 c0 07 	bfextu	r9,r8,0x0,0x7
8000565a:	fe f8 0d a2 	ld.w	r8,pc[3490]
8000565e:	91 09       	st.w	r8[0x0],r9
								
				switch(Item_ID)
80005660:	fe f8 0d 98 	ld.w	r8,pc[3480]
80005664:	11 88       	ld.ub	r8,r8[0x0]
80005666:	5c 58       	castu.b	r8
80005668:	e0 48 00 7f 	cp.w	r8,127
8000566c:	e0 80 00 8b 	breq	80005782 <phy_payload_rx+0x222>
80005670:	e0 89 00 07 	brgt	8000567e <phy_payload_rx+0x11e>
80005674:	59 28       	cp.w	r8,18
80005676:	c5 00       	breq	80005716 <phy_payload_rx+0x1b6>
80005678:	59 38       	cp.w	r8,19
8000567a:	c7 f0       	breq	80005778 <phy_payload_rx+0x218>
8000567c:	cb 48       	rjmp	800057e4 <phy_payload_rx+0x284>
8000567e:	f0 c8 00 f0 	sub	r8,r8,240
80005682:	58 18       	cp.w	r8,1
80005684:	e0 8b 00 b0 	brhi	800057e4 <phy_payload_rx+0x284>
					//The OB know the Call begin and discard the Voice Header
					//The OB know the Call end and discard the Voice  Terminator
					case Raw_Tx_Data_HT://0xF0
					case Raw_Rx_Data_HT://0xF1
					
							if ((payload_rx_channel->byte[6] & 0xF0 )== 0x10)//header
80005688:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000568c:	11 e8       	ld.ub	r8,r8[0x6]
8000568e:	e2 18 00 f0 	andl	r8,0xf0,COH
80005692:	59 08       	cp.w	r8,16
80005694:	c0 61       	brne	800056a0 <phy_payload_rx+0x140>
							{
								m_RxBurstType = VOICEHEADER;
80005696:	fe f8 0d 4e 	ld.w	r8,pc[3406]
8000569a:	30 19       	mov	r9,1
8000569c:	91 09       	st.w	r8[0x0],r9
8000569e:	c3 b8       	rjmp	80005714 <phy_payload_rx+0x1b4>

							}
							else if ((payload_rx_channel->byte[6] & 0xF0) == 0x20)//Terminator
800056a0:	ee f8 ff f8 	ld.w	r8,r7[-8]
800056a4:	11 e8       	ld.ub	r8,r8[0x6]
800056a6:	e2 18 00 f0 	andl	r8,0xf0,COH
800056aa:	e0 48 00 20 	cp.w	r8,32
800056ae:	c2 f1       	brne	8000570c <phy_payload_rx+0x1ac>
							{
								m_RxBurstType = VOICETERMINATOR;
800056b0:	fe f8 0d 34 	ld.w	r8,pc[3380]
800056b4:	30 a9       	mov	r9,10
800056b6:	91 09       	st.w	r8[0x0],r9
								//AMBE-data and PCM-data is not the same. AMBE is compressed data,
								//if there was a missing portion, a clear voice is difficult to extract the data.
								//It must ensure that all the data received AMBE.
								
								//0
								memset((AMBE_payload_ptr+ (RxAMBE_IsFillingNext8 +1)), 0x00, (512-(RxAMBE_IsFillingNext8 + 1)));
800056b8:	fe f8 0d 48 	ld.w	r8,pc[3400]
800056bc:	70 08       	ld.w	r8,r8[0x0]
800056be:	5c d8       	com	r8
800056c0:	f0 c9 fe 00 	sub	r9,r8,-512
800056c4:	fe f8 0d 18 	ld.w	r8,pc[3352]
800056c8:	70 0a       	ld.w	r10,r8[0x0]
800056ca:	fe f8 0d 36 	ld.w	r8,pc[3382]
800056ce:	70 08       	ld.w	r8,r8[0x0]
800056d0:	2f f8       	sub	r8,-1
800056d2:	f4 08 00 08 	add	r8,r10,r8
800056d6:	12 9a       	mov	r10,r9
800056d8:	30 0b       	mov	r11,0
800056da:	10 9c       	mov	r12,r8
800056dc:	f0 1f 03 4a 	mcall	80006404 <phy_payload_rx+0xea4>
								
								RxAMBE_IsFillingNext8 = 0;
800056e0:	fe f8 0d 20 	ld.w	r8,pc[3360]
800056e4:	30 09       	mov	r9,0
800056e6:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800056e8:	fe f8 0c f4 	ld.w	r8,pc[3316]
800056ec:	70 08       	ld.w	r8,r8[0x0]
800056ee:	10 9c       	mov	r12,r8
800056f0:	f0 1f 03 46 	mcall	80006408 <phy_payload_rx+0xea8>
								AMBE_payload_ptr = get_payload_idle_isr();
800056f4:	fe f8 0c e0 	ld.w	r8,pc[3296]
800056f8:	70 08       	ld.w	r8,r8[0x0]
800056fa:	10 9c       	mov	r12,r8
800056fc:	f0 1f 03 37 	mcall	800063d8 <phy_payload_rx+0xe78>
80005700:	18 98       	mov	r8,r12
80005702:	10 99       	mov	r9,r8
80005704:	fe f8 0c d8 	ld.w	r8,pc[3288]
80005708:	91 09       	st.w	r8[0x0],r9
8000570a:	c0 58       	rjmp	80005714 <phy_payload_rx+0x1b4>
								//logFromISR("\n\r QQ1 \n\r");
								
							}
							else//error voice
							{
								m_RxBurstType = VOICE_WATING;
8000570c:	fe f8 0c d8 	ld.w	r8,pc[3288]
80005710:	30 09       	mov	r9,0
80005712:	91 09       	st.w	r8[0x0],r9
							}
							
						break;//WAITINGABAB.
80005714:	c9 08       	rjmp	80005834 <phy_payload_rx+0x2d4>
					
		
					case Vocoder_Bit_Stream_Parameter://0x12
							
							if ((RxBytesWaiting -= 4) <= 0) break;
80005716:	fe f8 0c d2 	ld.w	r8,pc[3282]
8000571a:	70 08       	ld.w	r8,r8[0x0]
8000571c:	f0 c9 00 04 	sub	r9,r8,4
80005720:	fe f8 0c c8 	ld.w	r8,pc[3272]
80005724:	91 09       	st.w	r8[0x0],r9
80005726:	fe f8 0c c2 	ld.w	r8,pc[3266]
8000572a:	70 08       	ld.w	r8,r8[0x0]
8000572c:	58 08       	cp.w	r8,0
8000572e:	c0 21       	brne	80005732 <phy_payload_rx+0x1d2>
80005730:	c8 28       	rjmp	80005834 <phy_payload_rx+0x2d4>
					
							//Vocoder Bits Stream Parameter
							VF_SN = (payload_rx_channel->byte[7] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
80005732:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005736:	11 f8       	ld.ub	r8,r8[0x7]
80005738:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000573c:	fe f9 0c d0 	ld.w	r9,pc[3280]
80005740:	b2 88       	st.b	r9[0x0],r8
							
							VBSP_data[0] = payload_rx_channel->word[2];
80005742:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005746:	90 28       	ld.sh	r8,r8[0x4]
80005748:	fe f9 0c c8 	ld.w	r9,pc[3272]
8000574c:	b2 08       	st.h	r9[0x0],r8
							VBSP_data[1] = payload_rx_channel->word[3];
8000574e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005752:	90 38       	ld.sh	r8,r8[0x6]
80005754:	fe f9 0c bc 	ld.w	r9,pc[3260]
80005758:	b2 18       	st.h	r9[0x2],r8
							
							m_RxBurstType = CalculateBurst(VF_SN);
8000575a:	fe f8 0c b2 	ld.w	r8,pc[3250]
8000575e:	11 88       	ld.ub	r8,r8[0x0]
80005760:	10 9c       	mov	r12,r8
80005762:	f0 1f 03 2d 	mcall	80006414 <phy_payload_rx+0xeb4>
80005766:	18 99       	mov	r9,r12
80005768:	fe f8 0c 7c 	ld.w	r8,pc[3196]
8000576c:	91 09       	st.w	r8[0x0],r9
							
							RxMediaState = READING_AMBE_MEDIA;//Jump
8000576e:	fe f8 0c 72 	ld.w	r8,pc[3186]
80005772:	30 49       	mov	r9,4
80005774:	91 09       	st.w	r8[0x0],r9
							
					
						break;//Jump to READING_AMBE_MEDIA
80005776:	c5 f8       	rjmp	80005834 <phy_payload_rx+0x2d4>
							
					//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
					// or discard it to reduce payload size.	
					//This shouldn't happen, but must check.	
					case Soft_Decision_Value://0x13
						m_RxBurstType = VOICE_WATING;
80005778:	fe f8 0c 6c 	ld.w	r8,pc[3180]
8000577c:	30 09       	mov	r9,0
8000577e:	91 09       	st.w	r8[0x0],r9
						
						break;//WAITINGABAB.
80005780:	c5 a8       	rjmp	80005834 <phy_payload_rx+0x2d4>
								
					case Radio_Internal_Parameter://0x7F
							
							//logFromISR("\n\r Item_Length:%d\n\r", Item_Length);
							
							if ((RxBytesWaiting -= 4) <= 0) break;
80005782:	fe f8 0c 66 	ld.w	r8,pc[3174]
80005786:	70 08       	ld.w	r8,r8[0x0]
80005788:	f0 c9 00 04 	sub	r9,r8,4
8000578c:	fe f8 0c 5c 	ld.w	r8,pc[3164]
80005790:	91 09       	st.w	r8[0x0],r9
80005792:	fe f8 0c 56 	ld.w	r8,pc[3158]
80005796:	70 08       	ld.w	r8,r8[0x0]
80005798:	58 08       	cp.w	r8,0
8000579a:	c0 21       	brne	8000579e <phy_payload_rx+0x23e>
8000579c:	c4 c8       	rjmp	80005834 <phy_payload_rx+0x2d4>
							//Radio Internal Parameter
							Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[3];
8000579e:	fe f8 0c 7a 	ld.w	r8,pc[3194]
800057a2:	70 0a       	ld.w	r10,r8[0x0]
800057a4:	ee f8 ff f8 	ld.w	r8,r7[-8]
800057a8:	90 38       	ld.sh	r8,r8[0x6]
800057aa:	fe f9 0c 72 	ld.w	r9,pc[3186]
800057ae:	f2 0a 0a 18 	st.h	r9[r10<<0x1],r8
							RxData_IsFillingNext16 += 1; 
800057b2:	fe f8 0c 66 	ld.w	r8,pc[3174]
800057b6:	70 08       	ld.w	r8,r8[0x0]
800057b8:	f0 c9 ff ff 	sub	r9,r8,-1
800057bc:	fe f8 0c 5c 	ld.w	r8,pc[3164]
800057c0:	91 09       	st.w	r8[0x0],r9
							Item_Length -= 2 ;
800057c2:	fe f8 0c 3a 	ld.w	r8,pc[3130]
800057c6:	70 08       	ld.w	r8,r8[0x0]
800057c8:	f0 c9 00 02 	sub	r9,r8,2
800057cc:	fe f8 0c 30 	ld.w	r8,pc[3120]
800057d0:	91 09       	st.w	r8[0x0],r9
							//....................................................
							m_RxBurstType = RADIOINTERNAL;
800057d2:	fe f8 0c 12 	ld.w	r8,pc[3090]
800057d6:	30 29       	mov	r9,2
800057d8:	91 09       	st.w	r8[0x0],r9

							RxMediaState = READING_AMBE_AUX;//Jump
800057da:	fe f8 0c 06 	ld.w	r8,pc[3078]
800057de:	30 39       	mov	r9,3
800057e0:	91 09       	st.w	r8[0x0],r9
							
					
						break;//Jump to READING_AMBE_AUX
800057e2:	c2 98       	rjmp	80005834 <phy_payload_rx+0x2d4>
									
					default://0x03,0x04
						
						//((Item_ID == 0x04) || (Item_ID == 0x03) )//Unknown type data directly back hair
							//break;
							m_RxBurstType = UNSUREDATA;
800057e4:	fe f8 0c 00 	ld.w	r8,pc[3072]
800057e8:	30 39       	mov	r9,3
800057ea:	91 09       	st.w	r8[0x0],r9
							AMBE_HT[0] = payload_rx_channel->dword[0];
800057ec:	ee f8 ff f8 	ld.w	r8,r7[-8]
800057f0:	70 09       	ld.w	r9,r8[0x0]
800057f2:	fe f8 0c 2e 	ld.w	r8,pc[3118]
800057f6:	91 09       	st.w	r8[0x0],r9
							AMBE_HT[1] = payload_rx_channel->dword[1];
800057f8:	ee f8 ff f8 	ld.w	r8,r7[-8]
800057fc:	70 19       	ld.w	r9,r8[0x4]
800057fe:	fe f8 0c 22 	ld.w	r8,pc[3106]
80005802:	91 19       	st.w	r8[0x4],r9
							
							if (RxBytesWaiting == 0x00000014)
80005804:	fe f8 0b e4 	ld.w	r8,pc[3044]
80005808:	70 08       	ld.w	r8,r8[0x0]
8000580a:	59 48       	cp.w	r8,20
8000580c:	c0 51       	brne	80005816 <phy_payload_rx+0x2b6>
							{
								RxBytesWaiting = 0x18;//24 Reassigned
8000580e:	fe f8 0b da 	ld.w	r8,pc[3034]
80005812:	31 89       	mov	r9,24
80005814:	91 09       	st.w	r8[0x0],r9
								//_flag =0;
								
							}
							if (RxBytesWaiting == 0x00000010)
80005816:	fe f8 0b d2 	ld.w	r8,pc[3026]
8000581a:	70 08       	ld.w	r8,r8[0x0]
8000581c:	59 08       	cp.w	r8,16
8000581e:	c0 51       	brne	80005828 <phy_payload_rx+0x2c8>
							{
								RxBytesWaiting = 0x10;//16 Reassigned
80005820:	fe f8 0b c8 	ld.w	r8,pc[3016]
80005824:	31 09       	mov	r9,16
80005826:	91 09       	st.w	r8[0x0],r9
								//_flag =1;
							}
					
							RxMediaState = READING_AMBE_MEDIA;//Jump
80005828:	fe f8 0b b8 	ld.w	r8,pc[3000]
8000582c:	30 49       	mov	r9,4
8000582e:	91 09       	st.w	r8[0x0],r9
					
						break;//Jump to READING_AMBE_MEDIA
									
			
				}
				break;
80005830:	e0 8f 05 cd 	bral	800063ca <phy_payload_rx+0xe6a>
80005834:	e0 8f 05 cb 	bral	800063ca <phy_payload_rx+0xe6a>
			}
			
			else
			{
				AMBE_Media = 0;	
80005838:	fe f9 0b bc 	ld.w	r9,pc[3004]
8000583c:	30 08       	mov	r8,0
8000583e:	b2 88       	st.b	r9[0x0],r8
				break;
80005840:	e0 8f 05 c5 	bral	800063ca <phy_payload_rx+0xe6a>

		case READING_AMBE_MEDIA:
		
			/****AMBE-media-data ****/
		
					if ((Item_ID == Vocoder_Bit_Stream_Parameter))//PAYLOAD_DATA_ENH (0x0c))
80005844:	fe f8 0b b4 	ld.w	r8,pc[2996]
80005848:	11 88       	ld.ub	r8,r8[0x0]
8000584a:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
8000584e:	31 28       	mov	r8,18
80005850:	f0 09 18 00 	cp.b	r9,r8
80005854:	e0 81 02 07 	brne	80005c62 <phy_payload_rx+0x702>
					{
						Item_ID = payload_rx_channel->byte[1];
80005858:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000585c:	11 98       	ld.ub	r8,r8[0x1]
8000585e:	fe f9 0b 9a 	ld.w	r9,pc[2970]
80005862:	b2 88       	st.b	r9[0x0],r8
						if (Item_ID == Post_Voice_Encoder_Data)//
80005864:	fe f8 0b 94 	ld.w	r8,pc[2964]
80005868:	11 88       	ld.ub	r8,r8[0x0]
8000586a:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
8000586e:	3f 28       	mov	r8,-14
80005870:	f0 09 18 00 	cp.b	r9,r8
80005874:	e0 81 01 f1 	brne	80005c56 <phy_payload_rx+0x6f6>
						{
							AMBE_tx_flag = 1;
80005878:	fe f9 0b ac 	ld.w	r9,pc[2988]
8000587c:	30 18       	mov	r8,1
8000587e:	b2 88       	st.b	r9[0x0],r8
							
							RxBytesWaiting = ((payload_rx_channel->dword[0] & 0x7F000000) >>24);//Test calculations are correct; 8
80005880:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005884:	70 08       	ld.w	r8,r8[0x0]
80005886:	e6 18 7f 00 	andh	r8,0x7f00,COH
8000588a:	f0 09 16 18 	lsr	r9,r8,0x18
8000588e:	fe f8 0b 5a 	ld.w	r8,pc[2906]
80005892:	91 09       	st.w	r8[0x0],r9
							
							//For looping back to Radio
							AMBEBurst_rawdata[0] = payload_rx_channel->word[1];
80005894:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005898:	90 18       	ld.sh	r8,r8[0x2]
8000589a:	fe f9 0b 8e 	ld.w	r9,pc[2958]
8000589e:	b2 08       	st.h	r9[0x0],r8
							AMBEBurst_rawdata[1] = payload_rx_channel->word[2];
800058a0:	ee f8 ff f8 	ld.w	r8,r7[-8]
800058a4:	90 28       	ld.sh	r8,r8[0x4]
800058a6:	fe f9 0b 82 	ld.w	r9,pc[2946]
800058aa:	b2 18       	st.h	r9[0x2],r8
							AMBEBurst_rawdata[2] = payload_rx_channel->word[3];
800058ac:	ee f8 ff f8 	ld.w	r8,r7[-8]
800058b0:	90 38       	ld.sh	r8,r8[0x6]
800058b2:	fe f9 0b 76 	ld.w	r9,pc[2934]
800058b6:	b2 28       	st.h	r9[0x4],r8
							
							//To be tested. Also locally stored RAW-AMBER-DATA
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//1
800058b8:	fe f8 0b 24 	ld.w	r8,pc[2852]
800058bc:	70 09       	ld.w	r9,r8[0x0]
800058be:	fe f8 0b 42 	ld.w	r8,pc[2882]
800058c2:	70 08       	ld.w	r8,r8[0x0]
800058c4:	10 09       	add	r9,r8
800058c6:	ee f8 ff f8 	ld.w	r8,r7[-8]
800058ca:	11 a8       	ld.ub	r8,r8[0x2]
800058cc:	b2 88       	st.b	r9[0x0],r8
							RxAMBE_IsFillingNext8 += 1;
800058ce:	fe f8 0b 32 	ld.w	r8,pc[2866]
800058d2:	70 08       	ld.w	r8,r8[0x0]
800058d4:	f0 c9 ff ff 	sub	r9,r8,-1
800058d8:	fe f8 0b 28 	ld.w	r8,pc[2856]
800058dc:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800058de:	fe f8 0b 22 	ld.w	r8,pc[2850]
800058e2:	70 08       	ld.w	r8,r8[0x0]
800058e4:	e0 48 01 ff 	cp.w	r8,511
800058e8:	e0 88 00 22 	brls	8000592c <phy_payload_rx+0x3cc>
							{
								RxAMBE_IsFillingNext8 = 0;
800058ec:	fe f8 0b 14 	ld.w	r8,pc[2836]
800058f0:	30 09       	mov	r9,0
800058f2:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800058f4:	fe f8 0a e8 	ld.w	r8,pc[2792]
800058f8:	70 08       	ld.w	r8,r8[0x0]
800058fa:	10 9c       	mov	r12,r8
800058fc:	f0 1f 02 c3 	mcall	80006408 <phy_payload_rx+0xea8>
								AMBE_payload_ptr = get_payload_idle_isr();
80005900:	fe f8 0a d4 	ld.w	r8,pc[2772]
80005904:	70 08       	ld.w	r8,r8[0x0]
80005906:	10 9c       	mov	r12,r8
80005908:	f0 1f 02 b4 	mcall	800063d8 <phy_payload_rx+0xe78>
8000590c:	18 98       	mov	r8,r12
8000590e:	10 99       	mov	r9,r8
80005910:	fe f8 0a cc 	ld.w	r8,pc[2764]
80005914:	91 09       	st.w	r8[0x0],r9
								if(NULL == AMBE_payload_ptr)
80005916:	fe f8 0a c6 	ld.w	r8,pc[2758]
8000591a:	70 08       	ld.w	r8,r8[0x0]
8000591c:	58 08       	cp.w	r8,0
8000591e:	c0 71       	brne	8000592c <phy_payload_rx+0x3cc>
								{
									RxMediaState = WAITINGABAB;
80005920:	fe f8 0a c0 	ld.w	r8,pc[2752]
80005924:	30 09       	mov	r9,0
80005926:	91 09       	st.w	r8[0x0],r9
									break;
80005928:	e0 8f 05 51 	bral	800063ca <phy_payload_rx+0xe6a>
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
8000592c:	fe f8 0a bc 	ld.w	r8,pc[2748]
80005930:	70 08       	ld.w	r8,r8[0x0]
80005932:	f0 c9 00 01 	sub	r9,r8,1
80005936:	fe f8 0a b2 	ld.w	r8,pc[2738]
8000593a:	91 09       	st.w	r8[0x0],r9
8000593c:	fe f8 0a ac 	ld.w	r8,pc[2732]
80005940:	70 08       	ld.w	r8,r8[0x0]
80005942:	58 08       	cp.w	r8,0
80005944:	c0 71       	brne	80005952 <phy_payload_rx+0x3f2>
								RxMediaState = WAITINGABAB;
80005946:	fe f8 0a 9a 	ld.w	r8,pc[2714]
8000594a:	30 09       	mov	r9,0
8000594c:	91 09       	st.w	r8[0x0],r9
								break;
8000594e:	e0 8f 05 3e 	bral	800063ca <phy_payload_rx+0xe6a>
							}			
							
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//2
80005952:	fe f8 0a 8a 	ld.w	r8,pc[2698]
80005956:	70 09       	ld.w	r9,r8[0x0]
80005958:	fe f8 0a a8 	ld.w	r8,pc[2728]
8000595c:	70 08       	ld.w	r8,r8[0x0]
8000595e:	10 09       	add	r9,r8
80005960:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005964:	11 b8       	ld.ub	r8,r8[0x3]
80005966:	b2 88       	st.b	r9[0x0],r8
							RxAMBE_IsFillingNext8 += 1;
80005968:	fe f8 0a 98 	ld.w	r8,pc[2712]
8000596c:	70 08       	ld.w	r8,r8[0x0]
8000596e:	f0 c9 ff ff 	sub	r9,r8,-1
80005972:	fe f8 0a 8e 	ld.w	r8,pc[2702]
80005976:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80005978:	fe f8 0a 88 	ld.w	r8,pc[2696]
8000597c:	70 08       	ld.w	r8,r8[0x0]
8000597e:	e0 48 01 ff 	cp.w	r8,511
80005982:	e0 88 00 22 	brls	800059c6 <phy_payload_rx+0x466>
							{
								RxAMBE_IsFillingNext8 = 0;
80005986:	fe f8 0a 7a 	ld.w	r8,pc[2682]
8000598a:	30 09       	mov	r9,0
8000598c:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
8000598e:	fe f8 0a 4e 	ld.w	r8,pc[2638]
80005992:	70 08       	ld.w	r8,r8[0x0]
80005994:	10 9c       	mov	r12,r8
80005996:	f0 1f 02 9d 	mcall	80006408 <phy_payload_rx+0xea8>
								AMBE_payload_ptr = get_payload_idle_isr();
8000599a:	fe f8 0a 3a 	ld.w	r8,pc[2618]
8000599e:	70 08       	ld.w	r8,r8[0x0]
800059a0:	10 9c       	mov	r12,r8
800059a2:	f0 1f 02 8e 	mcall	800063d8 <phy_payload_rx+0xe78>
800059a6:	18 98       	mov	r8,r12
800059a8:	10 99       	mov	r9,r8
800059aa:	fe f8 0a 32 	ld.w	r8,pc[2610]
800059ae:	91 09       	st.w	r8[0x0],r9
								if(NULL == AMBE_payload_ptr)
800059b0:	fe f8 0a 2c 	ld.w	r8,pc[2604]
800059b4:	70 08       	ld.w	r8,r8[0x0]
800059b6:	58 08       	cp.w	r8,0
800059b8:	c0 71       	brne	800059c6 <phy_payload_rx+0x466>
								{
									RxMediaState = WAITINGABAB;
800059ba:	fe f8 0a 26 	ld.w	r8,pc[2598]
800059be:	30 09       	mov	r9,0
800059c0:	91 09       	st.w	r8[0x0],r9
									break;
800059c2:	e0 8f 05 04 	bral	800063ca <phy_payload_rx+0xe6a>
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800059c6:	fe f8 0a 22 	ld.w	r8,pc[2594]
800059ca:	70 08       	ld.w	r8,r8[0x0]
800059cc:	f0 c9 00 01 	sub	r9,r8,1
800059d0:	fe f8 0a 18 	ld.w	r8,pc[2584]
800059d4:	91 09       	st.w	r8[0x0],r9
800059d6:	fe f8 0a 12 	ld.w	r8,pc[2578]
800059da:	70 08       	ld.w	r8,r8[0x0]
800059dc:	58 08       	cp.w	r8,0
800059de:	c0 71       	brne	800059ec <phy_payload_rx+0x48c>
								RxMediaState = WAITINGABAB;
800059e0:	fe f8 0a 00 	ld.w	r8,pc[2560]
800059e4:	30 09       	mov	r9,0
800059e6:	91 09       	st.w	r8[0x0],r9
								break;
800059e8:	e0 8f 04 f1 	bral	800063ca <phy_payload_rx+0xe6a>
							}		
						
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//3
800059ec:	fe f8 09 f0 	ld.w	r8,pc[2544]
800059f0:	70 09       	ld.w	r9,r8[0x0]
800059f2:	fe f8 0a 0e 	ld.w	r8,pc[2574]
800059f6:	70 08       	ld.w	r8,r8[0x0]
800059f8:	10 09       	add	r9,r8
800059fa:	ee f8 ff f8 	ld.w	r8,r7[-8]
800059fe:	11 c8       	ld.ub	r8,r8[0x4]
80005a00:	b2 88       	st.b	r9[0x0],r8
							RxAMBE_IsFillingNext8 += 1;
80005a02:	fe f8 09 fe 	ld.w	r8,pc[2558]
80005a06:	70 08       	ld.w	r8,r8[0x0]
80005a08:	f0 c9 ff ff 	sub	r9,r8,-1
80005a0c:	fe f8 09 f4 	ld.w	r8,pc[2548]
80005a10:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80005a12:	fe f8 09 ee 	ld.w	r8,pc[2542]
80005a16:	70 08       	ld.w	r8,r8[0x0]
80005a18:	e0 48 01 ff 	cp.w	r8,511
80005a1c:	e0 88 00 22 	brls	80005a60 <phy_payload_rx+0x500>
							{
								RxAMBE_IsFillingNext8 = 0;
80005a20:	fe f8 09 e0 	ld.w	r8,pc[2528]
80005a24:	30 09       	mov	r9,0
80005a26:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80005a28:	fe f8 09 b4 	ld.w	r8,pc[2484]
80005a2c:	70 08       	ld.w	r8,r8[0x0]
80005a2e:	10 9c       	mov	r12,r8
80005a30:	f0 1f 02 76 	mcall	80006408 <phy_payload_rx+0xea8>
								AMBE_payload_ptr = get_payload_idle_isr();
80005a34:	fe f8 09 a0 	ld.w	r8,pc[2464]
80005a38:	70 08       	ld.w	r8,r8[0x0]
80005a3a:	10 9c       	mov	r12,r8
80005a3c:	f0 1f 02 67 	mcall	800063d8 <phy_payload_rx+0xe78>
80005a40:	18 98       	mov	r8,r12
80005a42:	10 99       	mov	r9,r8
80005a44:	fe f8 09 98 	ld.w	r8,pc[2456]
80005a48:	91 09       	st.w	r8[0x0],r9
								if(NULL == AMBE_payload_ptr)
80005a4a:	fe f8 09 92 	ld.w	r8,pc[2450]
80005a4e:	70 08       	ld.w	r8,r8[0x0]
80005a50:	58 08       	cp.w	r8,0
80005a52:	c0 71       	brne	80005a60 <phy_payload_rx+0x500>
								{
									RxMediaState = WAITINGABAB;
80005a54:	fe f8 09 8c 	ld.w	r8,pc[2444]
80005a58:	30 09       	mov	r9,0
80005a5a:	91 09       	st.w	r8[0x0],r9
									break;
80005a5c:	e0 8f 04 b7 	bral	800063ca <phy_payload_rx+0xe6a>
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80005a60:	fe f8 09 88 	ld.w	r8,pc[2440]
80005a64:	70 08       	ld.w	r8,r8[0x0]
80005a66:	f0 c9 00 01 	sub	r9,r8,1
80005a6a:	fe f8 09 7e 	ld.w	r8,pc[2430]
80005a6e:	91 09       	st.w	r8[0x0],r9
80005a70:	fe f8 09 78 	ld.w	r8,pc[2424]
80005a74:	70 08       	ld.w	r8,r8[0x0]
80005a76:	58 08       	cp.w	r8,0
80005a78:	c0 71       	brne	80005a86 <phy_payload_rx+0x526>
								RxMediaState = WAITINGABAB;
80005a7a:	fe f8 09 66 	ld.w	r8,pc[2406]
80005a7e:	30 09       	mov	r9,0
80005a80:	91 09       	st.w	r8[0x0],r9
								break;
80005a82:	e0 8f 04 a4 	bral	800063ca <phy_payload_rx+0xe6a>
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[5];//4
80005a86:	fe f8 09 56 	ld.w	r8,pc[2390]
80005a8a:	70 09       	ld.w	r9,r8[0x0]
80005a8c:	fe f8 09 74 	ld.w	r8,pc[2420]
80005a90:	70 08       	ld.w	r8,r8[0x0]
80005a92:	10 09       	add	r9,r8
80005a94:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005a98:	11 d8       	ld.ub	r8,r8[0x5]
80005a9a:	b2 88       	st.b	r9[0x0],r8
							RxAMBE_IsFillingNext8 += 1;
80005a9c:	fe f8 09 64 	ld.w	r8,pc[2404]
80005aa0:	70 08       	ld.w	r8,r8[0x0]
80005aa2:	f0 c9 ff ff 	sub	r9,r8,-1
80005aa6:	fe f8 09 5a 	ld.w	r8,pc[2394]
80005aaa:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80005aac:	fe f8 09 54 	ld.w	r8,pc[2388]
80005ab0:	70 08       	ld.w	r8,r8[0x0]
80005ab2:	e0 48 01 ff 	cp.w	r8,511
80005ab6:	e0 88 00 22 	brls	80005afa <phy_payload_rx+0x59a>
							{
								RxAMBE_IsFillingNext8 = 0;
80005aba:	fe f8 09 46 	ld.w	r8,pc[2374]
80005abe:	30 09       	mov	r9,0
80005ac0:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80005ac2:	fe f8 09 1a 	ld.w	r8,pc[2330]
80005ac6:	70 08       	ld.w	r8,r8[0x0]
80005ac8:	10 9c       	mov	r12,r8
80005aca:	f0 1f 02 50 	mcall	80006408 <phy_payload_rx+0xea8>
								AMBE_payload_ptr = get_payload_idle_isr();
80005ace:	fe f8 09 06 	ld.w	r8,pc[2310]
80005ad2:	70 08       	ld.w	r8,r8[0x0]
80005ad4:	10 9c       	mov	r12,r8
80005ad6:	f0 1f 02 41 	mcall	800063d8 <phy_payload_rx+0xe78>
80005ada:	18 98       	mov	r8,r12
80005adc:	10 99       	mov	r9,r8
80005ade:	fe f8 08 fe 	ld.w	r8,pc[2302]
80005ae2:	91 09       	st.w	r8[0x0],r9
								if(NULL == AMBE_payload_ptr)
80005ae4:	fe f8 08 f8 	ld.w	r8,pc[2296]
80005ae8:	70 08       	ld.w	r8,r8[0x0]
80005aea:	58 08       	cp.w	r8,0
80005aec:	c0 71       	brne	80005afa <phy_payload_rx+0x59a>
								{
									RxMediaState = WAITINGABAB;
80005aee:	fe f8 08 f2 	ld.w	r8,pc[2290]
80005af2:	30 09       	mov	r9,0
80005af4:	91 09       	st.w	r8[0x0],r9
									break;
80005af6:	e0 8f 04 6a 	bral	800063ca <phy_payload_rx+0xe6a>
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80005afa:	fe f8 08 ee 	ld.w	r8,pc[2286]
80005afe:	70 08       	ld.w	r8,r8[0x0]
80005b00:	f0 c9 00 01 	sub	r9,r8,1
80005b04:	fe f8 08 e4 	ld.w	r8,pc[2276]
80005b08:	91 09       	st.w	r8[0x0],r9
80005b0a:	fe f8 08 de 	ld.w	r8,pc[2270]
80005b0e:	70 08       	ld.w	r8,r8[0x0]
80005b10:	58 08       	cp.w	r8,0
80005b12:	c0 71       	brne	80005b20 <phy_payload_rx+0x5c0>
								RxMediaState = WAITINGABAB;
80005b14:	fe f8 08 cc 	ld.w	r8,pc[2252]
80005b18:	30 09       	mov	r9,0
80005b1a:	91 09       	st.w	r8[0x0],r9
								break;
80005b1c:	e0 8f 04 57 	bral	800063ca <phy_payload_rx+0xe6a>
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//5
80005b20:	fe f8 08 bc 	ld.w	r8,pc[2236]
80005b24:	70 09       	ld.w	r9,r8[0x0]
80005b26:	fe f8 08 da 	ld.w	r8,pc[2266]
80005b2a:	70 08       	ld.w	r8,r8[0x0]
80005b2c:	10 09       	add	r9,r8
80005b2e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005b32:	11 e8       	ld.ub	r8,r8[0x6]
80005b34:	b2 88       	st.b	r9[0x0],r8
							RxAMBE_IsFillingNext8 += 1;
80005b36:	fe f8 08 ca 	ld.w	r8,pc[2250]
80005b3a:	70 08       	ld.w	r8,r8[0x0]
80005b3c:	f0 c9 ff ff 	sub	r9,r8,-1
80005b40:	fe f8 08 c0 	ld.w	r8,pc[2240]
80005b44:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80005b46:	fe f8 08 ba 	ld.w	r8,pc[2234]
80005b4a:	70 08       	ld.w	r8,r8[0x0]
80005b4c:	e0 48 01 ff 	cp.w	r8,511
80005b50:	e0 88 00 22 	brls	80005b94 <phy_payload_rx+0x634>
							{
								RxAMBE_IsFillingNext8 = 0;
80005b54:	fe f8 08 ac 	ld.w	r8,pc[2220]
80005b58:	30 09       	mov	r9,0
80005b5a:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80005b5c:	fe f8 08 80 	ld.w	r8,pc[2176]
80005b60:	70 08       	ld.w	r8,r8[0x0]
80005b62:	10 9c       	mov	r12,r8
80005b64:	f0 1f 02 29 	mcall	80006408 <phy_payload_rx+0xea8>
								AMBE_payload_ptr = get_payload_idle_isr();
80005b68:	fe f8 08 6c 	ld.w	r8,pc[2156]
80005b6c:	70 08       	ld.w	r8,r8[0x0]
80005b6e:	10 9c       	mov	r12,r8
80005b70:	f0 1f 02 1a 	mcall	800063d8 <phy_payload_rx+0xe78>
80005b74:	18 98       	mov	r8,r12
80005b76:	10 99       	mov	r9,r8
80005b78:	fe f8 08 64 	ld.w	r8,pc[2148]
80005b7c:	91 09       	st.w	r8[0x0],r9
								if(NULL == AMBE_payload_ptr)
80005b7e:	fe f8 08 5e 	ld.w	r8,pc[2142]
80005b82:	70 08       	ld.w	r8,r8[0x0]
80005b84:	58 08       	cp.w	r8,0
80005b86:	c0 71       	brne	80005b94 <phy_payload_rx+0x634>
								{
									RxMediaState = WAITINGABAB;
80005b88:	fe f8 08 58 	ld.w	r8,pc[2136]
80005b8c:	30 09       	mov	r9,0
80005b8e:	91 09       	st.w	r8[0x0],r9
									break;
80005b90:	e0 8f 04 1d 	bral	800063ca <phy_payload_rx+0xe6a>
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80005b94:	fe f8 08 54 	ld.w	r8,pc[2132]
80005b98:	70 08       	ld.w	r8,r8[0x0]
80005b9a:	f0 c9 00 01 	sub	r9,r8,1
80005b9e:	fe f8 08 4a 	ld.w	r8,pc[2122]
80005ba2:	91 09       	st.w	r8[0x0],r9
80005ba4:	fe f8 08 44 	ld.w	r8,pc[2116]
80005ba8:	70 08       	ld.w	r8,r8[0x0]
80005baa:	58 08       	cp.w	r8,0
80005bac:	c0 71       	brne	80005bba <phy_payload_rx+0x65a>
								RxMediaState = WAITINGABAB;
80005bae:	fe f8 08 32 	ld.w	r8,pc[2098]
80005bb2:	30 09       	mov	r9,0
80005bb4:	91 09       	st.w	r8[0x0],r9
								break;
80005bb6:	e0 8f 04 0a 	bral	800063ca <phy_payload_rx+0xe6a>
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//6
80005bba:	fe f8 08 22 	ld.w	r8,pc[2082]
80005bbe:	70 09       	ld.w	r9,r8[0x0]
80005bc0:	fe f8 08 40 	ld.w	r8,pc[2112]
80005bc4:	70 08       	ld.w	r8,r8[0x0]
80005bc6:	10 09       	add	r9,r8
80005bc8:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005bcc:	11 f8       	ld.ub	r8,r8[0x7]
80005bce:	b2 88       	st.b	r9[0x0],r8
							RxAMBE_IsFillingNext8 += 1;
80005bd0:	fe f8 08 30 	ld.w	r8,pc[2096]
80005bd4:	70 08       	ld.w	r8,r8[0x0]
80005bd6:	f0 c9 ff ff 	sub	r9,r8,-1
80005bda:	fe f8 08 26 	ld.w	r8,pc[2086]
80005bde:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80005be0:	fe f8 08 20 	ld.w	r8,pc[2080]
80005be4:	70 08       	ld.w	r8,r8[0x0]
80005be6:	e0 48 01 ff 	cp.w	r8,511
80005bea:	e0 88 00 22 	brls	80005c2e <phy_payload_rx+0x6ce>
							{
								RxAMBE_IsFillingNext8 = 0;
80005bee:	fe f8 08 12 	ld.w	r8,pc[2066]
80005bf2:	30 09       	mov	r9,0
80005bf4:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80005bf6:	fe f8 07 e6 	ld.w	r8,pc[2022]
80005bfa:	70 08       	ld.w	r8,r8[0x0]
80005bfc:	10 9c       	mov	r12,r8
80005bfe:	f0 1f 02 03 	mcall	80006408 <phy_payload_rx+0xea8>
								AMBE_payload_ptr = get_payload_idle_isr();
80005c02:	fe f8 07 d2 	ld.w	r8,pc[2002]
80005c06:	70 08       	ld.w	r8,r8[0x0]
80005c08:	10 9c       	mov	r12,r8
80005c0a:	f0 1f 01 f4 	mcall	800063d8 <phy_payload_rx+0xe78>
80005c0e:	18 98       	mov	r8,r12
80005c10:	10 99       	mov	r9,r8
80005c12:	fe f8 07 ca 	ld.w	r8,pc[1994]
80005c16:	91 09       	st.w	r8[0x0],r9
								if(NULL == AMBE_payload_ptr)
80005c18:	fe f8 07 c4 	ld.w	r8,pc[1988]
80005c1c:	70 08       	ld.w	r8,r8[0x0]
80005c1e:	58 08       	cp.w	r8,0
80005c20:	c0 71       	brne	80005c2e <phy_payload_rx+0x6ce>
								{
									RxMediaState = WAITINGABAB;
80005c22:	fe f8 07 be 	ld.w	r8,pc[1982]
80005c26:	30 09       	mov	r9,0
80005c28:	91 09       	st.w	r8[0x0],r9
									break;
80005c2a:	e0 8f 03 d0 	bral	800063ca <phy_payload_rx+0xe6a>
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80005c2e:	fe f8 07 ba 	ld.w	r8,pc[1978]
80005c32:	70 08       	ld.w	r8,r8[0x0]
80005c34:	f0 c9 00 01 	sub	r9,r8,1
80005c38:	fe f8 07 b0 	ld.w	r8,pc[1968]
80005c3c:	91 09       	st.w	r8[0x0],r9
80005c3e:	fe f8 07 aa 	ld.w	r8,pc[1962]
80005c42:	70 08       	ld.w	r8,r8[0x0]
80005c44:	58 08       	cp.w	r8,0
80005c46:	e0 81 03 b9 	brne	800063b8 <phy_payload_rx+0xe58>
								RxMediaState = WAITINGABAB;
80005c4a:	fe f8 07 96 	ld.w	r8,pc[1942]
80005c4e:	30 09       	mov	r9,0
80005c50:	91 09       	st.w	r8[0x0],r9
								break;
80005c52:	e0 8f 03 bc 	bral	800063ca <phy_payload_rx+0xe6a>
							//}
							
						}
						else//error
						{
							RxMediaState = WAITINGABAB;
80005c56:	fe f8 07 8a 	ld.w	r8,pc[1930]
80005c5a:	30 09       	mov	r9,0
80005c5c:	91 09       	st.w	r8[0x0],r9
							break;
80005c5e:	e0 8f 03 b6 	bral	800063ca <phy_payload_rx+0xe6a>
						}
					}
					else if (Item_ID == Post_Voice_Encoder_Data)//(bit48~Pad-bits)
80005c62:	fe f8 07 96 	ld.w	r8,pc[1942]
80005c66:	11 88       	ld.ub	r8,r8[0x0]
80005c68:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
80005c6c:	3f 28       	mov	r8,-14
80005c6e:	f0 09 18 00 	cp.b	r9,r8
80005c72:	c6 81       	brne	80005d42 <phy_payload_rx+0x7e2>
					{
					
						AMBEBurst_rawdata[3] = payload_rx_channel->word[0];//(bit48~Pad-bits)
80005c74:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005c78:	90 08       	ld.sh	r8,r8[0x0]
80005c7a:	fe f9 07 ae 	ld.w	r9,pc[1966]
80005c7e:	b2 38       	st.h	r9[0x6],r8
						//AMBE_Per_Burst_Flag = 1;
						
						//MOTO.bitpad-bits
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//7
80005c80:	fe f8 07 5c 	ld.w	r8,pc[1884]
80005c84:	70 09       	ld.w	r9,r8[0x0]
80005c86:	fe f8 07 7a 	ld.w	r8,pc[1914]
80005c8a:	70 08       	ld.w	r8,r8[0x0]
80005c8c:	10 09       	add	r9,r8
80005c8e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005c92:	11 88       	ld.ub	r8,r8[0x0]
80005c94:	b2 88       	st.b	r9[0x0],r8
						RxAMBE_IsFillingNext8 += 1;
80005c96:	fe f8 07 6a 	ld.w	r8,pc[1898]
80005c9a:	70 08       	ld.w	r8,r8[0x0]
80005c9c:	f0 c9 ff ff 	sub	r9,r8,-1
80005ca0:	fe f8 07 60 	ld.w	r8,pc[1888]
80005ca4:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80005ca6:	fe f8 07 5a 	ld.w	r8,pc[1882]
80005caa:	70 08       	ld.w	r8,r8[0x0]
80005cac:	e0 48 01 ff 	cp.w	r8,511
80005cb0:	e0 88 00 22 	brls	80005cf4 <phy_payload_rx+0x794>
						{
							RxAMBE_IsFillingNext8 = 0;
80005cb4:	fe f8 07 4c 	ld.w	r8,pc[1868]
80005cb8:	30 09       	mov	r9,0
80005cba:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80005cbc:	fe f8 07 20 	ld.w	r8,pc[1824]
80005cc0:	70 08       	ld.w	r8,r8[0x0]
80005cc2:	10 9c       	mov	r12,r8
80005cc4:	f0 1f 01 d1 	mcall	80006408 <phy_payload_rx+0xea8>
							AMBE_payload_ptr = get_payload_idle_isr();
80005cc8:	fe f8 07 0c 	ld.w	r8,pc[1804]
80005ccc:	70 08       	ld.w	r8,r8[0x0]
80005cce:	10 9c       	mov	r12,r8
80005cd0:	f0 1f 01 c2 	mcall	800063d8 <phy_payload_rx+0xe78>
80005cd4:	18 98       	mov	r8,r12
80005cd6:	10 99       	mov	r9,r8
80005cd8:	fe f8 07 04 	ld.w	r8,pc[1796]
80005cdc:	91 09       	st.w	r8[0x0],r9
							if(NULL == AMBE_payload_ptr)
80005cde:	fe f8 06 fe 	ld.w	r8,pc[1790]
80005ce2:	70 08       	ld.w	r8,r8[0x0]
80005ce4:	58 08       	cp.w	r8,0
80005ce6:	c0 71       	brne	80005cf4 <phy_payload_rx+0x794>
							{
								RxMediaState = WAITINGABAB;
80005ce8:	fe f8 06 f8 	ld.w	r8,pc[1784]
80005cec:	30 09       	mov	r9,0
80005cee:	91 09       	st.w	r8[0x0],r9
								break;
80005cf0:	e0 8f 03 6d 	bral	800063ca <phy_payload_rx+0xe6a>
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80005cf4:	fe f8 06 f4 	ld.w	r8,pc[1780]
80005cf8:	70 08       	ld.w	r8,r8[0x0]
80005cfa:	f0 c9 00 01 	sub	r9,r8,1
80005cfe:	fe f8 06 ea 	ld.w	r8,pc[1770]
80005d02:	91 09       	st.w	r8[0x0],r9
80005d04:	fe f8 06 e4 	ld.w	r8,pc[1764]
80005d08:	70 08       	ld.w	r8,r8[0x0]
80005d0a:	58 08       	cp.w	r8,0
80005d0c:	c0 71       	brne	80005d1a <phy_payload_rx+0x7ba>
							RxMediaState = WAITINGABAB;
80005d0e:	fe f8 06 d2 	ld.w	r8,pc[1746]
80005d12:	30 09       	mov	r9,0
80005d14:	91 09       	st.w	r8[0x0],r9
							break;
80005d16:	e0 8f 03 5a 	bral	800063ca <phy_payload_rx+0xe6a>
						}	
						
						if ((RxBytesWaiting -= 1) <= 0){//AMBE Vocoder Bits Stream(bit59~63),
80005d1a:	fe f8 06 ce 	ld.w	r8,pc[1742]
80005d1e:	70 08       	ld.w	r8,r8[0x0]
80005d20:	f0 c9 00 01 	sub	r9,r8,1
80005d24:	fe f8 06 c4 	ld.w	r8,pc[1732]
80005d28:	91 09       	st.w	r8[0x0],r9
80005d2a:	fe f8 06 be 	ld.w	r8,pc[1726]
80005d2e:	70 08       	ld.w	r8,r8[0x0]
80005d30:	58 08       	cp.w	r8,0
80005d32:	e0 81 03 45 	brne	800063bc <phy_payload_rx+0xe5c>
							RxMediaState = WAITINGABAB;
80005d36:	fe f8 06 aa 	ld.w	r8,pc[1706]
80005d3a:	30 09       	mov	r9,0
80005d3c:	91 09       	st.w	r8[0x0],r9
							break;
80005d3e:	e0 8f 03 46 	bral	800063ca <phy_payload_rx+0xe6a>
						}	
						
								
					}
					else if (Item_ID == Pre_Voice_Decoder_Data)//bit16~bit63
80005d42:	fe f8 06 b6 	ld.w	r8,pc[1718]
80005d46:	11 88       	ld.ub	r8,r8[0x0]
80005d48:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
80005d4c:	3f 38       	mov	r8,-13
80005d4e:	f0 09 18 00 	cp.b	r9,r8
80005d52:	e0 81 01 a9 	brne	800060a4 <phy_payload_rx+0xb44>
					{
						//
						//For looping back to Radio
						AMBEBurst_rawdata[1] = payload_rx_channel->word[0];
80005d56:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005d5a:	90 08       	ld.sh	r8,r8[0x0]
80005d5c:	fe f9 06 cc 	ld.w	r9,pc[1740]
80005d60:	b2 18       	st.h	r9[0x2],r8
						AMBEBurst_rawdata[2] = payload_rx_channel->word[1];
80005d62:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005d66:	90 18       	ld.sh	r8,r8[0x2]
80005d68:	fe f9 06 c0 	ld.w	r9,pc[1728]
80005d6c:	b2 28       	st.h	r9[0x4],r8
						AMBEBurst_rawdata[3] = payload_rx_channel->word[2];
80005d6e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005d72:	90 28       	ld.sh	r8,r8[0x4]
80005d74:	fe f9 06 b4 	ld.w	r9,pc[1716]
80005d78:	b2 38       	st.h	r9[0x6],r8
						//if((m_RxBurstType == VOICEBURST_A) && (VF_SN == 1))
						//logFromISR("\n\r Pre_rx:%X\n\r", payload_rx_channel->word[2]);
						
						//To be tested. Also locally stored RAW-AMBER-DATA
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//3
80005d7a:	fe f8 06 62 	ld.w	r8,pc[1634]
80005d7e:	70 09       	ld.w	r9,r8[0x0]
80005d80:	fe f8 06 80 	ld.w	r8,pc[1664]
80005d84:	70 08       	ld.w	r8,r8[0x0]
80005d86:	10 09       	add	r9,r8
80005d88:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005d8c:	11 88       	ld.ub	r8,r8[0x0]
80005d8e:	b2 88       	st.b	r9[0x0],r8
						RxAMBE_IsFillingNext8 += 1;
80005d90:	fe f8 06 70 	ld.w	r8,pc[1648]
80005d94:	70 08       	ld.w	r8,r8[0x0]
80005d96:	f0 c9 ff ff 	sub	r9,r8,-1
80005d9a:	fe f8 06 66 	ld.w	r8,pc[1638]
80005d9e:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80005da0:	fe f8 06 60 	ld.w	r8,pc[1632]
80005da4:	70 08       	ld.w	r8,r8[0x0]
80005da6:	e0 48 01 ff 	cp.w	r8,511
80005daa:	e0 88 00 22 	brls	80005dee <phy_payload_rx+0x88e>
						{
							RxAMBE_IsFillingNext8 = 0;
80005dae:	fe f8 06 52 	ld.w	r8,pc[1618]
80005db2:	30 09       	mov	r9,0
80005db4:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80005db6:	fe f8 06 26 	ld.w	r8,pc[1574]
80005dba:	70 08       	ld.w	r8,r8[0x0]
80005dbc:	10 9c       	mov	r12,r8
80005dbe:	f0 1f 01 93 	mcall	80006408 <phy_payload_rx+0xea8>
							AMBE_payload_ptr = get_payload_idle_isr();
80005dc2:	fe f8 06 12 	ld.w	r8,pc[1554]
80005dc6:	70 08       	ld.w	r8,r8[0x0]
80005dc8:	10 9c       	mov	r12,r8
80005dca:	f0 1f 01 84 	mcall	800063d8 <phy_payload_rx+0xe78>
80005dce:	18 98       	mov	r8,r12
80005dd0:	10 99       	mov	r9,r8
80005dd2:	fe f8 06 0a 	ld.w	r8,pc[1546]
80005dd6:	91 09       	st.w	r8[0x0],r9
							if(NULL == AMBE_payload_ptr)
80005dd8:	fe f8 06 04 	ld.w	r8,pc[1540]
80005ddc:	70 08       	ld.w	r8,r8[0x0]
80005dde:	58 08       	cp.w	r8,0
80005de0:	c0 71       	brne	80005dee <phy_payload_rx+0x88e>
							{
								RxMediaState = WAITINGABAB;
80005de2:	fe f8 05 fe 	ld.w	r8,pc[1534]
80005de6:	30 09       	mov	r9,0
80005de8:	91 09       	st.w	r8[0x0],r9
								break;
80005dea:	e0 8f 02 f0 	bral	800063ca <phy_payload_rx+0xe6a>
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80005dee:	fe f8 05 fa 	ld.w	r8,pc[1530]
80005df2:	70 08       	ld.w	r8,r8[0x0]
80005df4:	f0 c9 00 01 	sub	r9,r8,1
80005df8:	fe f8 05 f0 	ld.w	r8,pc[1520]
80005dfc:	91 09       	st.w	r8[0x0],r9
80005dfe:	fe f8 05 ea 	ld.w	r8,pc[1514]
80005e02:	70 08       	ld.w	r8,r8[0x0]
80005e04:	58 08       	cp.w	r8,0
80005e06:	c0 71       	brne	80005e14 <phy_payload_rx+0x8b4>
							RxMediaState = WAITINGABAB;
80005e08:	fe f8 05 d8 	ld.w	r8,pc[1496]
80005e0c:	30 09       	mov	r9,0
80005e0e:	91 09       	st.w	r8[0x0],r9
							break;
80005e10:	e0 8f 02 dd 	bral	800063ca <phy_payload_rx+0xe6a>
						}
						
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[1];//4
80005e14:	fe f8 05 c8 	ld.w	r8,pc[1480]
80005e18:	70 09       	ld.w	r9,r8[0x0]
80005e1a:	fe f8 05 e6 	ld.w	r8,pc[1510]
80005e1e:	70 08       	ld.w	r8,r8[0x0]
80005e20:	10 09       	add	r9,r8
80005e22:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005e26:	11 98       	ld.ub	r8,r8[0x1]
80005e28:	b2 88       	st.b	r9[0x0],r8
						RxAMBE_IsFillingNext8 += 1;
80005e2a:	fe f8 05 d6 	ld.w	r8,pc[1494]
80005e2e:	70 08       	ld.w	r8,r8[0x0]
80005e30:	f0 c9 ff ff 	sub	r9,r8,-1
80005e34:	fe f8 05 cc 	ld.w	r8,pc[1484]
80005e38:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80005e3a:	fe f8 05 c6 	ld.w	r8,pc[1478]
80005e3e:	70 08       	ld.w	r8,r8[0x0]
80005e40:	e0 48 01 ff 	cp.w	r8,511
80005e44:	e0 88 00 22 	brls	80005e88 <phy_payload_rx+0x928>
						{
							RxAMBE_IsFillingNext8 = 0;
80005e48:	fe f8 05 b8 	ld.w	r8,pc[1464]
80005e4c:	30 09       	mov	r9,0
80005e4e:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80005e50:	fe f8 05 8c 	ld.w	r8,pc[1420]
80005e54:	70 08       	ld.w	r8,r8[0x0]
80005e56:	10 9c       	mov	r12,r8
80005e58:	f0 1f 01 6c 	mcall	80006408 <phy_payload_rx+0xea8>
							AMBE_payload_ptr = get_payload_idle_isr();
80005e5c:	fe f8 05 78 	ld.w	r8,pc[1400]
80005e60:	70 08       	ld.w	r8,r8[0x0]
80005e62:	10 9c       	mov	r12,r8
80005e64:	f0 1f 01 5d 	mcall	800063d8 <phy_payload_rx+0xe78>
80005e68:	18 98       	mov	r8,r12
80005e6a:	10 99       	mov	r9,r8
80005e6c:	fe f8 05 70 	ld.w	r8,pc[1392]
80005e70:	91 09       	st.w	r8[0x0],r9
							if(NULL == AMBE_payload_ptr)
80005e72:	fe f8 05 6a 	ld.w	r8,pc[1386]
80005e76:	70 08       	ld.w	r8,r8[0x0]
80005e78:	58 08       	cp.w	r8,0
80005e7a:	c0 71       	brne	80005e88 <phy_payload_rx+0x928>
							{
								RxMediaState = WAITINGABAB;
80005e7c:	fe f8 05 64 	ld.w	r8,pc[1380]
80005e80:	30 09       	mov	r9,0
80005e82:	91 09       	st.w	r8[0x0],r9
								break;
80005e84:	e0 8f 02 a3 	bral	800063ca <phy_payload_rx+0xe6a>
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80005e88:	fe f8 05 60 	ld.w	r8,pc[1376]
80005e8c:	70 08       	ld.w	r8,r8[0x0]
80005e8e:	f0 c9 00 01 	sub	r9,r8,1
80005e92:	fe f8 05 56 	ld.w	r8,pc[1366]
80005e96:	91 09       	st.w	r8[0x0],r9
80005e98:	fe f8 05 50 	ld.w	r8,pc[1360]
80005e9c:	70 08       	ld.w	r8,r8[0x0]
80005e9e:	58 08       	cp.w	r8,0
80005ea0:	c0 71       	brne	80005eae <phy_payload_rx+0x94e>
							RxMediaState = WAITINGABAB;
80005ea2:	fe f8 05 3e 	ld.w	r8,pc[1342]
80005ea6:	30 09       	mov	r9,0
80005ea8:	91 09       	st.w	r8[0x0],r9
							break;
80005eaa:	e0 8f 02 90 	bral	800063ca <phy_payload_rx+0xe6a>
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//5
80005eae:	fe f8 05 2e 	ld.w	r8,pc[1326]
80005eb2:	70 09       	ld.w	r9,r8[0x0]
80005eb4:	fe f8 05 4c 	ld.w	r8,pc[1356]
80005eb8:	70 08       	ld.w	r8,r8[0x0]
80005eba:	10 09       	add	r9,r8
80005ebc:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005ec0:	11 a8       	ld.ub	r8,r8[0x2]
80005ec2:	b2 88       	st.b	r9[0x0],r8
						RxAMBE_IsFillingNext8 += 1;
80005ec4:	fe f8 05 3c 	ld.w	r8,pc[1340]
80005ec8:	70 08       	ld.w	r8,r8[0x0]
80005eca:	f0 c9 ff ff 	sub	r9,r8,-1
80005ece:	fe f8 05 32 	ld.w	r8,pc[1330]
80005ed2:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80005ed4:	fe f8 05 2c 	ld.w	r8,pc[1324]
80005ed8:	70 08       	ld.w	r8,r8[0x0]
80005eda:	e0 48 01 ff 	cp.w	r8,511
80005ede:	e0 88 00 22 	brls	80005f22 <phy_payload_rx+0x9c2>
						{
							RxAMBE_IsFillingNext8 = 0;
80005ee2:	fe f8 05 1e 	ld.w	r8,pc[1310]
80005ee6:	30 09       	mov	r9,0
80005ee8:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80005eea:	fe f8 04 f2 	ld.w	r8,pc[1266]
80005eee:	70 08       	ld.w	r8,r8[0x0]
80005ef0:	10 9c       	mov	r12,r8
80005ef2:	f0 1f 01 46 	mcall	80006408 <phy_payload_rx+0xea8>
							AMBE_payload_ptr = get_payload_idle_isr();
80005ef6:	fe f8 04 de 	ld.w	r8,pc[1246]
80005efa:	70 08       	ld.w	r8,r8[0x0]
80005efc:	10 9c       	mov	r12,r8
80005efe:	f0 1f 01 37 	mcall	800063d8 <phy_payload_rx+0xe78>
80005f02:	18 98       	mov	r8,r12
80005f04:	10 99       	mov	r9,r8
80005f06:	fe f8 04 d6 	ld.w	r8,pc[1238]
80005f0a:	91 09       	st.w	r8[0x0],r9
							if(NULL == AMBE_payload_ptr)
80005f0c:	fe f8 04 d0 	ld.w	r8,pc[1232]
80005f10:	70 08       	ld.w	r8,r8[0x0]
80005f12:	58 08       	cp.w	r8,0
80005f14:	c0 71       	brne	80005f22 <phy_payload_rx+0x9c2>
							{
								RxMediaState = WAITINGABAB;
80005f16:	fe f8 04 ca 	ld.w	r8,pc[1226]
80005f1a:	30 09       	mov	r9,0
80005f1c:	91 09       	st.w	r8[0x0],r9
								break;
80005f1e:	e0 8f 02 56 	bral	800063ca <phy_payload_rx+0xe6a>
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80005f22:	fe f8 04 c6 	ld.w	r8,pc[1222]
80005f26:	70 08       	ld.w	r8,r8[0x0]
80005f28:	f0 c9 00 01 	sub	r9,r8,1
80005f2c:	fe f8 04 bc 	ld.w	r8,pc[1212]
80005f30:	91 09       	st.w	r8[0x0],r9
80005f32:	fe f8 04 b6 	ld.w	r8,pc[1206]
80005f36:	70 08       	ld.w	r8,r8[0x0]
80005f38:	58 08       	cp.w	r8,0
80005f3a:	c0 71       	brne	80005f48 <phy_payload_rx+0x9e8>
							RxMediaState = WAITINGABAB;
80005f3c:	fe f8 04 a4 	ld.w	r8,pc[1188]
80005f40:	30 09       	mov	r9,0
80005f42:	91 09       	st.w	r8[0x0],r9
							break;
80005f44:	e0 8f 02 43 	bral	800063ca <phy_payload_rx+0xe6a>
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//6
80005f48:	fe f8 04 94 	ld.w	r8,pc[1172]
80005f4c:	70 09       	ld.w	r9,r8[0x0]
80005f4e:	fe f8 04 b2 	ld.w	r8,pc[1202]
80005f52:	70 08       	ld.w	r8,r8[0x0]
80005f54:	10 09       	add	r9,r8
80005f56:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005f5a:	11 b8       	ld.ub	r8,r8[0x3]
80005f5c:	b2 88       	st.b	r9[0x0],r8
						RxAMBE_IsFillingNext8 += 1;
80005f5e:	fe f8 04 a2 	ld.w	r8,pc[1186]
80005f62:	70 08       	ld.w	r8,r8[0x0]
80005f64:	f0 c9 ff ff 	sub	r9,r8,-1
80005f68:	fe f8 04 98 	ld.w	r8,pc[1176]
80005f6c:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80005f6e:	fe f8 04 92 	ld.w	r8,pc[1170]
80005f72:	70 08       	ld.w	r8,r8[0x0]
80005f74:	e0 48 01 ff 	cp.w	r8,511
80005f78:	e0 88 00 22 	brls	80005fbc <phy_payload_rx+0xa5c>
						{
							RxAMBE_IsFillingNext8 = 0;
80005f7c:	fe f8 04 84 	ld.w	r8,pc[1156]
80005f80:	30 09       	mov	r9,0
80005f82:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80005f84:	fe f8 04 58 	ld.w	r8,pc[1112]
80005f88:	70 08       	ld.w	r8,r8[0x0]
80005f8a:	10 9c       	mov	r12,r8
80005f8c:	f0 1f 01 1f 	mcall	80006408 <phy_payload_rx+0xea8>
							AMBE_payload_ptr = get_payload_idle_isr();
80005f90:	fe f8 04 44 	ld.w	r8,pc[1092]
80005f94:	70 08       	ld.w	r8,r8[0x0]
80005f96:	10 9c       	mov	r12,r8
80005f98:	f0 1f 01 10 	mcall	800063d8 <phy_payload_rx+0xe78>
80005f9c:	18 98       	mov	r8,r12
80005f9e:	10 99       	mov	r9,r8
80005fa0:	fe f8 04 3c 	ld.w	r8,pc[1084]
80005fa4:	91 09       	st.w	r8[0x0],r9
							if(NULL == AMBE_payload_ptr)
80005fa6:	fe f8 04 36 	ld.w	r8,pc[1078]
80005faa:	70 08       	ld.w	r8,r8[0x0]
80005fac:	58 08       	cp.w	r8,0
80005fae:	c0 71       	brne	80005fbc <phy_payload_rx+0xa5c>
							{
								RxMediaState = WAITINGABAB;
80005fb0:	fe f8 04 30 	ld.w	r8,pc[1072]
80005fb4:	30 09       	mov	r9,0
80005fb6:	91 09       	st.w	r8[0x0],r9
								break;
80005fb8:	e0 8f 02 09 	bral	800063ca <phy_payload_rx+0xe6a>
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80005fbc:	fe f8 04 2c 	ld.w	r8,pc[1068]
80005fc0:	70 08       	ld.w	r8,r8[0x0]
80005fc2:	f0 c9 00 01 	sub	r9,r8,1
80005fc6:	fe f8 04 22 	ld.w	r8,pc[1058]
80005fca:	91 09       	st.w	r8[0x0],r9
80005fcc:	fe f8 04 1c 	ld.w	r8,pc[1052]
80005fd0:	70 08       	ld.w	r8,r8[0x0]
80005fd2:	58 08       	cp.w	r8,0
80005fd4:	c0 71       	brne	80005fe2 <phy_payload_rx+0xa82>
							RxMediaState = WAITINGABAB;
80005fd6:	fe f8 04 0a 	ld.w	r8,pc[1034]
80005fda:	30 09       	mov	r9,0
80005fdc:	91 09       	st.w	r8[0x0],r9
							break;
80005fde:	e0 8f 01 f6 	bral	800063ca <phy_payload_rx+0xe6a>
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//7
80005fe2:	fe f8 03 fa 	ld.w	r8,pc[1018]
80005fe6:	70 09       	ld.w	r9,r8[0x0]
80005fe8:	fe f8 04 18 	ld.w	r8,pc[1048]
80005fec:	70 08       	ld.w	r8,r8[0x0]
80005fee:	10 09       	add	r9,r8
80005ff0:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005ff4:	11 c8       	ld.ub	r8,r8[0x4]
80005ff6:	b2 88       	st.b	r9[0x0],r8
						RxAMBE_IsFillingNext8 += 1;
80005ff8:	fe f8 04 08 	ld.w	r8,pc[1032]
80005ffc:	70 08       	ld.w	r8,r8[0x0]
80005ffe:	f0 c9 ff ff 	sub	r9,r8,-1
80006002:	fe f8 03 fe 	ld.w	r8,pc[1022]
80006006:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80006008:	fe f8 03 f8 	ld.w	r8,pc[1016]
8000600c:	70 08       	ld.w	r8,r8[0x0]
8000600e:	e0 48 01 ff 	cp.w	r8,511
80006012:	e0 88 00 22 	brls	80006056 <phy_payload_rx+0xaf6>
						{
							RxAMBE_IsFillingNext8 = 0;
80006016:	fe f8 03 ea 	ld.w	r8,pc[1002]
8000601a:	30 09       	mov	r9,0
8000601c:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
8000601e:	fe f8 03 be 	ld.w	r8,pc[958]
80006022:	70 08       	ld.w	r8,r8[0x0]
80006024:	10 9c       	mov	r12,r8
80006026:	f0 1f 00 f9 	mcall	80006408 <phy_payload_rx+0xea8>
							AMBE_payload_ptr = get_payload_idle_isr();
8000602a:	fe f8 03 aa 	ld.w	r8,pc[938]
8000602e:	70 08       	ld.w	r8,r8[0x0]
80006030:	10 9c       	mov	r12,r8
80006032:	f0 1f 00 ea 	mcall	800063d8 <phy_payload_rx+0xe78>
80006036:	18 98       	mov	r8,r12
80006038:	10 99       	mov	r9,r8
8000603a:	fe f8 03 a2 	ld.w	r8,pc[930]
8000603e:	91 09       	st.w	r8[0x0],r9
							if(NULL == AMBE_payload_ptr)
80006040:	fe f8 03 9c 	ld.w	r8,pc[924]
80006044:	70 08       	ld.w	r8,r8[0x0]
80006046:	58 08       	cp.w	r8,0
80006048:	c0 71       	brne	80006056 <phy_payload_rx+0xaf6>
							{
								RxMediaState = WAITINGABAB;
8000604a:	fe f8 03 96 	ld.w	r8,pc[918]
8000604e:	30 09       	mov	r9,0
80006050:	91 09       	st.w	r8[0x0],r9
								break;
80006052:	e0 8f 01 bc 	bral	800063ca <phy_payload_rx+0xe6a>
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80006056:	fe f8 03 92 	ld.w	r8,pc[914]
8000605a:	70 08       	ld.w	r8,r8[0x0]
8000605c:	f0 c9 00 01 	sub	r9,r8,1
80006060:	fe f8 03 88 	ld.w	r8,pc[904]
80006064:	91 09       	st.w	r8[0x0],r9
80006066:	fe f8 03 82 	ld.w	r8,pc[898]
8000606a:	70 08       	ld.w	r8,r8[0x0]
8000606c:	58 08       	cp.w	r8,0
8000606e:	c0 71       	brne	8000607c <phy_payload_rx+0xb1c>
							RxMediaState = WAITINGABAB;
80006070:	fe f8 03 70 	ld.w	r8,pc[880]
80006074:	30 09       	mov	r9,0
80006076:	91 09       	st.w	r8[0x0],r9
							break;
80006078:	e0 8f 01 a9 	bral	800063ca <phy_payload_rx+0xe6a>
						}
						
						//AMBE Vocoder Bits Stream(bit59~63),
						if ((RxBytesWaiting -= 1) <= 0){
8000607c:	fe f8 03 6c 	ld.w	r8,pc[876]
80006080:	70 08       	ld.w	r8,r8[0x0]
80006082:	f0 c9 00 01 	sub	r9,r8,1
80006086:	fe f8 03 62 	ld.w	r8,pc[866]
8000608a:	91 09       	st.w	r8[0x0],r9
8000608c:	fe f8 03 5c 	ld.w	r8,pc[860]
80006090:	70 08       	ld.w	r8,r8[0x0]
80006092:	58 08       	cp.w	r8,0
80006094:	e0 81 01 96 	brne	800063c0 <phy_payload_rx+0xe60>
							
							//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
							//or discard it to reduce payload size.
							
							RxMediaState = WAITINGABAB;
80006098:	fe f8 03 48 	ld.w	r8,pc[840]
8000609c:	30 09       	mov	r9,0
8000609e:	91 09       	st.w	r8[0x0],r9
							break;
800060a0:	e0 8f 01 95 	bral	800063ca <phy_payload_rx+0xe6a>
						}	
						
					}
					else if ((Item_ID == 0x04)  ||  (Item_ID == 0x03))//Unknown type data directly back hair
800060a4:	fe f8 03 54 	ld.w	r8,pc[852]
800060a8:	11 88       	ld.ub	r8,r8[0x0]
800060aa:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
800060ae:	30 48       	mov	r8,4
800060b0:	f0 09 18 00 	cp.b	r9,r8
800060b4:	c0 a0       	breq	800060c8 <phy_payload_rx+0xb68>
800060b6:	fe f8 03 42 	ld.w	r8,pc[834]
800060ba:	11 88       	ld.ub	r8,r8[0x0]
800060bc:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
800060c0:	30 38       	mov	r8,3
800060c2:	f0 09 18 00 	cp.b	r9,r8
800060c6:	c2 51       	brne	80006110 <phy_payload_rx+0xbb0>
					{
						AMBE_HT[0] = payload_rx_channel->dword[0];
800060c8:	ee f8 ff f8 	ld.w	r8,r7[-8]
800060cc:	70 09       	ld.w	r9,r8[0x0]
800060ce:	fe f8 03 52 	ld.w	r8,pc[850]
800060d2:	91 09       	st.w	r8[0x0],r9
						AMBE_HT[1] = payload_rx_channel->dword[1];				
800060d4:	ee f8 ff f8 	ld.w	r8,r7[-8]
800060d8:	70 19       	ld.w	r9,r8[0x4]
800060da:	fe f8 03 46 	ld.w	r8,pc[838]
800060de:	91 19       	st.w	r8[0x4],r9
						
						if ((RxBytesWaiting -= 8) <= 0)//Consider two cases 0xABCDC014 and 0xABCDC010
800060e0:	fe f8 03 08 	ld.w	r8,pc[776]
800060e4:	70 08       	ld.w	r8,r8[0x0]
800060e6:	f0 c9 00 08 	sub	r9,r8,8
800060ea:	fe f8 02 fe 	ld.w	r8,pc[766]
800060ee:	91 09       	st.w	r8[0x0],r9
800060f0:	fe f8 02 f8 	ld.w	r8,pc[760]
800060f4:	70 08       	ld.w	r8,r8[0x0]
800060f6:	58 08       	cp.w	r8,0
800060f8:	e0 81 01 66 	brne	800063c4 <phy_payload_rx+0xe64>
						{
					
							RxBytesWaiting = 0;
800060fc:	fe f8 02 ec 	ld.w	r8,pc[748]
80006100:	30 09       	mov	r9,0
80006102:	91 09       	st.w	r8[0x0],r9
							RxMediaState = WAITINGABAB;
80006104:	fe f8 02 dc 	ld.w	r8,pc[732]
80006108:	30 09       	mov	r9,0
8000610a:	91 09       	st.w	r8[0x0],r9
							break;
8000610c:	e0 8f 01 5f 	bral	800063ca <phy_payload_rx+0xe6a>
			
						}
						break;

					}
					else if (Item_ID == Soft_Decision_Value)
80006110:	fe f8 02 e8 	ld.w	r8,pc[744]
80006114:	11 88       	ld.ub	r8,r8[0x0]
80006116:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
8000611a:	31 38       	mov	r8,19
8000611c:	f0 09 18 00 	cp.b	r9,r8
80006120:	e0 81 00 ea 	brne	800062f4 <phy_payload_rx+0xd94>
					{							
						if (SDV_Index == 12)
80006124:	fe f8 03 08 	ld.w	r8,pc[776]
80006128:	11 89       	ld.ub	r9,r8[0x0]
8000612a:	30 c8       	mov	r8,12
8000612c:	f0 09 18 00 	cp.b	r9,r8
80006130:	e0 81 00 b4 	brne	80006298 <phy_payload_rx+0xd38>
						{
							Soft_Decision_Data[SDV_Index]= payload_rx_channel->word[0];
80006134:	fe f8 02 f8 	ld.w	r8,pc[760]
80006138:	11 88       	ld.ub	r8,r8[0x0]
8000613a:	10 9a       	mov	r10,r8
8000613c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80006140:	90 08       	ld.sh	r8,r8[0x0]
80006142:	fe f9 02 ee 	ld.w	r9,pc[750]
80006146:	f2 0a 0a 18 	st.h	r9[r10<<0x1],r8
							
							SDV_Index = 0;
8000614a:	fe f9 02 e2 	ld.w	r9,pc[738]
8000614e:	30 08       	mov	r8,0
80006150:	b2 88       	st.b	r9[0x0],r8
								
							if (payload_rx_channel->byte[5] == Pre_Voice_Decoder_Data )//0xF3
80006152:	ee f8 ff f8 	ld.w	r8,r7[-8]
80006156:	11 d9       	ld.ub	r9,r8[0x5]
80006158:	3f 38       	mov	r8,-13
8000615a:	f0 09 18 00 	cp.b	r9,r8
8000615e:	e0 81 00 99 	brne	80006290 <phy_payload_rx+0xd30>
							{
									Item_ID = Pre_Voice_Decoder_Data;
80006162:	fe f9 02 96 	ld.w	r9,pc[662]
80006166:	3f 38       	mov	r8,-13
80006168:	b2 88       	st.b	r9[0x0],r8
									RxBytesWaiting = (payload_rx_channel->byte[4] & 0x7F);//Test calculations are correct; 8
8000616a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000616e:	11 c8       	ld.ub	r8,r8[0x4]
80006170:	f3 d8 c0 07 	bfextu	r9,r8,0x0,0x7
80006174:	fe f8 02 74 	ld.w	r8,pc[628]
80006178:	91 09       	st.w	r8[0x0],r9
									AMBE_rx_flag = 1;//AMBE
8000617a:	fe f9 02 ba 	ld.w	r9,pc[698]
8000617e:	30 18       	mov	r8,1
80006180:	b2 88       	st.b	r9[0x0],r8
		
									AMBEBurst_rawdata[0] = payload_rx_channel->word[3];//
80006182:	ee f8 ff f8 	ld.w	r8,r7[-8]
80006186:	90 38       	ld.sh	r8,r8[0x6]
80006188:	fe f9 02 a0 	ld.w	r9,pc[672]
8000618c:	b2 08       	st.h	r9[0x0],r8
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//1
8000618e:	fe f8 02 4e 	ld.w	r8,pc[590]
80006192:	70 09       	ld.w	r9,r8[0x0]
80006194:	fe f8 02 6c 	ld.w	r8,pc[620]
80006198:	70 08       	ld.w	r8,r8[0x0]
8000619a:	10 09       	add	r9,r8
8000619c:	ee f8 ff f8 	ld.w	r8,r7[-8]
800061a0:	11 e8       	ld.ub	r8,r8[0x6]
800061a2:	b2 88       	st.b	r9[0x0],r8
									RxAMBE_IsFillingNext8 += 1;
800061a4:	fe f8 02 5c 	ld.w	r8,pc[604]
800061a8:	70 08       	ld.w	r8,r8[0x0]
800061aa:	f0 c9 ff ff 	sub	r9,r8,-1
800061ae:	fe f8 02 52 	ld.w	r8,pc[594]
800061b2:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800061b4:	fe f8 02 4c 	ld.w	r8,pc[588]
800061b8:	70 08       	ld.w	r8,r8[0x0]
800061ba:	e0 48 01 ff 	cp.w	r8,511
800061be:	e0 88 00 1e 	brls	800061fa <phy_payload_rx+0xc9a>
									{
										RxAMBE_IsFillingNext8 = 0;
800061c2:	fe f8 02 3e 	ld.w	r8,pc[574]
800061c6:	30 09       	mov	r9,0
800061c8:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
800061ca:	fe f8 02 12 	ld.w	r8,pc[530]
800061ce:	70 08       	ld.w	r8,r8[0x0]
800061d0:	10 9c       	mov	r12,r8
800061d2:	f0 1f 00 8e 	mcall	80006408 <phy_payload_rx+0xea8>
										AMBE_payload_ptr = get_payload_idle_isr();
800061d6:	fe f8 01 fe 	ld.w	r8,pc[510]
800061da:	70 08       	ld.w	r8,r8[0x0]
800061dc:	10 9c       	mov	r12,r8
800061de:	f0 1f 00 7f 	mcall	800063d8 <phy_payload_rx+0xe78>
800061e2:	18 98       	mov	r8,r12
800061e4:	10 99       	mov	r9,r8
800061e6:	4f e8       	lddpc	r8,800063dc <phy_payload_rx+0xe7c>
800061e8:	91 09       	st.w	r8[0x0],r9
										if(NULL == AMBE_payload_ptr)
800061ea:	4f d8       	lddpc	r8,800063dc <phy_payload_rx+0xe7c>
800061ec:	70 08       	ld.w	r8,r8[0x0]
800061ee:	58 08       	cp.w	r8,0
800061f0:	c0 51       	brne	800061fa <phy_payload_rx+0xc9a>
										{
											RxMediaState = WAITINGABAB;
800061f2:	4f c8       	lddpc	r8,800063e0 <phy_payload_rx+0xe80>
800061f4:	30 09       	mov	r9,0
800061f6:	91 09       	st.w	r8[0x0],r9
											break;
800061f8:	ce 98       	rjmp	800063ca <phy_payload_rx+0xe6a>
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
800061fa:	4f c8       	lddpc	r8,800063e8 <phy_payload_rx+0xe88>
800061fc:	70 08       	ld.w	r8,r8[0x0]
800061fe:	f0 c9 00 01 	sub	r9,r8,1
80006202:	4f a8       	lddpc	r8,800063e8 <phy_payload_rx+0xe88>
80006204:	91 09       	st.w	r8[0x0],r9
80006206:	4f 98       	lddpc	r8,800063e8 <phy_payload_rx+0xe88>
80006208:	70 08       	ld.w	r8,r8[0x0]
8000620a:	58 08       	cp.w	r8,0
8000620c:	c0 51       	brne	80006216 <phy_payload_rx+0xcb6>
										RxMediaState = WAITINGABAB;
8000620e:	4f 58       	lddpc	r8,800063e0 <phy_payload_rx+0xe80>
80006210:	30 09       	mov	r9,0
80006212:	91 09       	st.w	r8[0x0],r9
										break;
80006214:	cd b8       	rjmp	800063ca <phy_payload_rx+0xe6a>
									}
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//2
80006216:	4f 28       	lddpc	r8,800063dc <phy_payload_rx+0xe7c>
80006218:	70 09       	ld.w	r9,r8[0x0]
8000621a:	4f a8       	lddpc	r8,80006400 <phy_payload_rx+0xea0>
8000621c:	70 08       	ld.w	r8,r8[0x0]
8000621e:	10 09       	add	r9,r8
80006220:	ee f8 ff f8 	ld.w	r8,r7[-8]
80006224:	11 f8       	ld.ub	r8,r8[0x7]
80006226:	b2 88       	st.b	r9[0x0],r8
									RxAMBE_IsFillingNext8 += 1;
80006228:	4f 68       	lddpc	r8,80006400 <phy_payload_rx+0xea0>
8000622a:	70 08       	ld.w	r8,r8[0x0]
8000622c:	f0 c9 ff ff 	sub	r9,r8,-1
80006230:	4f 48       	lddpc	r8,80006400 <phy_payload_rx+0xea0>
80006232:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80006234:	4f 38       	lddpc	r8,80006400 <phy_payload_rx+0xea0>
80006236:	70 08       	ld.w	r8,r8[0x0]
80006238:	e0 48 01 ff 	cp.w	r8,511
8000623c:	e0 88 00 1b 	brls	80006272 <phy_payload_rx+0xd12>
									{
										RxAMBE_IsFillingNext8 = 0;
80006240:	4f 08       	lddpc	r8,80006400 <phy_payload_rx+0xea0>
80006242:	30 09       	mov	r9,0
80006244:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
80006246:	4e 68       	lddpc	r8,800063dc <phy_payload_rx+0xe7c>
80006248:	70 08       	ld.w	r8,r8[0x0]
8000624a:	10 9c       	mov	r12,r8
8000624c:	f0 1f 00 6f 	mcall	80006408 <phy_payload_rx+0xea8>
										AMBE_payload_ptr = get_payload_idle_isr();
80006250:	4e 18       	lddpc	r8,800063d4 <phy_payload_rx+0xe74>
80006252:	70 08       	ld.w	r8,r8[0x0]
80006254:	10 9c       	mov	r12,r8
80006256:	f0 1f 00 61 	mcall	800063d8 <phy_payload_rx+0xe78>
8000625a:	18 98       	mov	r8,r12
8000625c:	10 99       	mov	r9,r8
8000625e:	4e 08       	lddpc	r8,800063dc <phy_payload_rx+0xe7c>
80006260:	91 09       	st.w	r8[0x0],r9
										if(NULL == AMBE_payload_ptr)
80006262:	4d f8       	lddpc	r8,800063dc <phy_payload_rx+0xe7c>
80006264:	70 08       	ld.w	r8,r8[0x0]
80006266:	58 08       	cp.w	r8,0
80006268:	c0 51       	brne	80006272 <phy_payload_rx+0xd12>
										{
											RxMediaState = WAITINGABAB;
8000626a:	4d e8       	lddpc	r8,800063e0 <phy_payload_rx+0xe80>
8000626c:	30 09       	mov	r9,0
8000626e:	91 09       	st.w	r8[0x0],r9
											break;
80006270:	ca d8       	rjmp	800063ca <phy_payload_rx+0xe6a>
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
80006272:	4d e8       	lddpc	r8,800063e8 <phy_payload_rx+0xe88>
80006274:	70 08       	ld.w	r8,r8[0x0]
80006276:	f0 c9 00 01 	sub	r9,r8,1
8000627a:	4d c8       	lddpc	r8,800063e8 <phy_payload_rx+0xe88>
8000627c:	91 09       	st.w	r8[0x0],r9
8000627e:	4d b8       	lddpc	r8,800063e8 <phy_payload_rx+0xe88>
80006280:	70 08       	ld.w	r8,r8[0x0]
80006282:	58 08       	cp.w	r8,0
80006284:	e0 81 00 a2 	brne	800063c8 <phy_payload_rx+0xe68>
										RxMediaState = WAITINGABAB;
80006288:	4d 68       	lddpc	r8,800063e0 <phy_payload_rx+0xe80>
8000628a:	30 09       	mov	r9,0
8000628c:	91 09       	st.w	r8[0x0],r9
										break;
8000628e:	c9 e8       	rjmp	800063ca <phy_payload_rx+0xe6a>
									}
									
							}
							else
							RxMediaState = WAITINGABAB;
80006290:	4d 48       	lddpc	r8,800063e0 <phy_payload_rx+0xe80>
80006292:	30 09       	mov	r9,0
80006294:	91 09       	st.w	r8[0x0],r9
							Soft_Decision_Data[SDV_Index+3]	  = payload_rx_channel->word[3];
							SDV_Index +=4;
									
						}
							
							break;
80006296:	c9 a8       	rjmp	800063ca <phy_payload_rx+0xe6a>
								
						}
						else
						{
									
							Soft_Decision_Data[SDV_Index]	  = payload_rx_channel->word[0];
80006298:	4e 58       	lddpc	r8,8000642c <phy_payload_rx+0xecc>
8000629a:	11 88       	ld.ub	r8,r8[0x0]
8000629c:	10 9a       	mov	r10,r8
8000629e:	ee f8 ff f8 	ld.w	r8,r7[-8]
800062a2:	90 08       	ld.sh	r8,r8[0x0]
800062a4:	4e 39       	lddpc	r9,80006430 <phy_payload_rx+0xed0>
800062a6:	f2 0a 0a 18 	st.h	r9[r10<<0x1],r8
							Soft_Decision_Data[SDV_Index+1]	  = payload_rx_channel->word[1];
800062aa:	4e 18       	lddpc	r8,8000642c <phy_payload_rx+0xecc>
800062ac:	11 88       	ld.ub	r8,r8[0x0]
800062ae:	f0 ca ff ff 	sub	r10,r8,-1
800062b2:	ee f8 ff f8 	ld.w	r8,r7[-8]
800062b6:	90 18       	ld.sh	r8,r8[0x2]
800062b8:	4d e9       	lddpc	r9,80006430 <phy_payload_rx+0xed0>
800062ba:	f2 0a 0a 18 	st.h	r9[r10<<0x1],r8
							Soft_Decision_Data[SDV_Index+2]	  = payload_rx_channel->word[2];
800062be:	4d c8       	lddpc	r8,8000642c <phy_payload_rx+0xecc>
800062c0:	11 88       	ld.ub	r8,r8[0x0]
800062c2:	f0 ca ff fe 	sub	r10,r8,-2
800062c6:	ee f8 ff f8 	ld.w	r8,r7[-8]
800062ca:	90 28       	ld.sh	r8,r8[0x4]
800062cc:	4d 99       	lddpc	r9,80006430 <phy_payload_rx+0xed0>
800062ce:	f2 0a 0a 18 	st.h	r9[r10<<0x1],r8
							Soft_Decision_Data[SDV_Index+3]	  = payload_rx_channel->word[3];
800062d2:	4d 78       	lddpc	r8,8000642c <phy_payload_rx+0xecc>
800062d4:	11 88       	ld.ub	r8,r8[0x0]
800062d6:	f0 ca ff fd 	sub	r10,r8,-3
800062da:	ee f8 ff f8 	ld.w	r8,r7[-8]
800062de:	90 38       	ld.sh	r8,r8[0x6]
800062e0:	4d 49       	lddpc	r9,80006430 <phy_payload_rx+0xed0>
800062e2:	f2 0a 0a 18 	st.h	r9[r10<<0x1],r8
							SDV_Index +=4;
800062e6:	4d 28       	lddpc	r8,8000642c <phy_payload_rx+0xecc>
800062e8:	11 88       	ld.ub	r8,r8[0x0]
800062ea:	2f c8       	sub	r8,-4
800062ec:	5c 58       	castu.b	r8
800062ee:	4d 09       	lddpc	r9,8000642c <phy_payload_rx+0xecc>
800062f0:	b2 88       	st.b	r9[0x0],r8
									
						}
							
							break;
800062f2:	c6 c8       	rjmp	800063ca <phy_payload_rx+0xe6a>
					}
					
					else
					{
						
						RxMediaState  = WAITINGABAB;
800062f4:	4b b8       	lddpc	r8,800063e0 <phy_payload_rx+0xe80>
800062f6:	30 09       	mov	r9,0
800062f8:	91 09       	st.w	r8[0x0],r9
						break;
800062fa:	c6 88       	rjmp	800063ca <phy_payload_rx+0xe6a>
			
			break;//End of READING_AMBE_MEDIA.

        case READING_AMBE_AUX:
			
				Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[0];
800062fc:	4c 78       	lddpc	r8,80006418 <phy_payload_rx+0xeb8>
800062fe:	70 0a       	ld.w	r10,r8[0x0]
80006300:	ee f8 ff f8 	ld.w	r8,r7[-8]
80006304:	90 08       	ld.sh	r8,r8[0x0]
80006306:	4c 69       	lddpc	r9,8000641c <phy_payload_rx+0xebc>
80006308:	f2 0a 0a 18 	st.h	r9[r10<<0x1],r8
				RxData_IsFillingNext16 += 1;
8000630c:	4c 38       	lddpc	r8,80006418 <phy_payload_rx+0xeb8>
8000630e:	70 08       	ld.w	r8,r8[0x0]
80006310:	f0 c9 ff ff 	sub	r9,r8,-1
80006314:	4c 18       	lddpc	r8,80006418 <phy_payload_rx+0xeb8>
80006316:	91 09       	st.w	r8[0x0],r9
			
				if ((Item_Length -= 2) <= 0)
80006318:	4b 98       	lddpc	r8,800063fc <phy_payload_rx+0xe9c>
8000631a:	70 08       	ld.w	r8,r8[0x0]
8000631c:	f0 c9 00 02 	sub	r9,r8,2
80006320:	4b 78       	lddpc	r8,800063fc <phy_payload_rx+0xe9c>
80006322:	91 09       	st.w	r8[0x0],r9
80006324:	4b 68       	lddpc	r8,800063fc <phy_payload_rx+0xe9c>
80006326:	70 08       	ld.w	r8,r8[0x0]
80006328:	58 08       	cp.w	r8,0
8000632a:	c3 e1       	brne	800063a6 <phy_payload_rx+0xe46>
				{
					RxData_IsFillingNext16 = 0;
8000632c:	4b b8       	lddpc	r8,80006418 <phy_payload_rx+0xeb8>
8000632e:	30 09       	mov	r9,0
80006330:	91 09       	st.w	r8[0x0],r9
				
					if (payload_rx_channel->word[1] == 0x8212 )
80006332:	ee f8 ff f8 	ld.w	r8,r7[-8]
80006336:	90 19       	ld.sh	r9,r8[0x2]
80006338:	fe 78 82 12 	mov	r8,-32238
8000633c:	f0 09 19 00 	cp.h	r9,r8
80006340:	c2 f1       	brne	8000639e <phy_payload_rx+0xe3e>
					{
						//Item_ID = Vocoder_Bit_Stream_Parameter;
						//Vocoder Bits Stream Parameter
						//Its value ranges from 1 to 18 for one voice superframe contains 6 voice bursts
						// and each burst contains 3 VFs.
						VF_SN = (payload_rx_channel->byte[5] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
80006342:	ee f8 ff f8 	ld.w	r8,r7[-8]
80006346:	11 d8       	ld.ub	r8,r8[0x5]
80006348:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000634c:	4b 09       	lddpc	r9,8000640c <phy_payload_rx+0xeac>
8000634e:	b2 88       	st.b	r9[0x0],r8
							
						VBSP_data[0] = payload_rx_channel->word[1];
80006350:	ee f8 ff f8 	ld.w	r8,r7[-8]
80006354:	90 18       	ld.sh	r8,r8[0x2]
80006356:	4a f9       	lddpc	r9,80006410 <phy_payload_rx+0xeb0>
80006358:	b2 08       	st.h	r9[0x0],r8
						VBSP_data[1] = payload_rx_channel->word[2];
8000635a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000635e:	90 28       	ld.sh	r8,r8[0x4]
80006360:	4a c9       	lddpc	r9,80006410 <phy_payload_rx+0xeb0>
80006362:	b2 18       	st.h	r9[0x2],r8
							
						m_RxBurstType = CalculateBurst(VF_SN);
80006364:	4a a8       	lddpc	r8,8000640c <phy_payload_rx+0xeac>
80006366:	11 88       	ld.ub	r8,r8[0x0]
80006368:	10 9c       	mov	r12,r8
8000636a:	f0 1f 00 2b 	mcall	80006414 <phy_payload_rx+0xeb4>
8000636e:	18 99       	mov	r9,r12
80006370:	49 d8       	lddpc	r8,800063e4 <phy_payload_rx+0xe84>
80006372:	91 09       	st.w	r8[0x0],r9
						
						if (payload_rx_channel->byte[7] == Soft_Decision_Value)//0x13
80006374:	ee f8 ff f8 	ld.w	r8,r7[-8]
80006378:	11 f9       	ld.ub	r9,r8[0x7]
8000637a:	31 38       	mov	r8,19
8000637c:	f0 09 18 00 	cp.b	r9,r8
80006380:	c0 81       	brne	80006390 <phy_payload_rx+0xe30>
						{
							Item_ID = Soft_Decision_Value;	
80006382:	49 e9       	lddpc	r9,800063f8 <phy_payload_rx+0xe98>
80006384:	31 38       	mov	r8,19
80006386:	b2 88       	st.b	r9[0x0],r8
							RxBytesWaiting = ((payload_rx_channel->dword[1] & 0x00007F00) >>24);//Test calculations are correct; 26
80006388:	49 88       	lddpc	r8,800063e8 <phy_payload_rx+0xe88>
8000638a:	30 09       	mov	r9,0
8000638c:	91 09       	st.w	r8[0x0],r9
8000638e:	c0 48       	rjmp	80006396 <phy_payload_rx+0xe36>
						}
						else
						{//error
								RxMediaState = WAITINGABAB;//Jump
80006390:	49 48       	lddpc	r8,800063e0 <phy_payload_rx+0xe80>
80006392:	30 09       	mov	r9,0
80006394:	91 09       	st.w	r8[0x0],r9
						}
							
						RxMediaState = READING_AMBE_MEDIA;//Jump
80006396:	49 38       	lddpc	r8,800063e0 <phy_payload_rx+0xe80>
80006398:	30 49       	mov	r9,4
8000639a:	91 09       	st.w	r8[0x0],r9
8000639c:	c1 78       	rjmp	800063ca <phy_payload_rx+0xe6a>
					}
					else
					{
						RxMediaState = WAITINGABAB;//Jump
8000639e:	49 18       	lddpc	r8,800063e0 <phy_payload_rx+0xe80>
800063a0:	30 09       	mov	r9,0
800063a2:	91 09       	st.w	r8[0x0],r9
800063a4:	c1 38       	rjmp	800063ca <phy_payload_rx+0xe6a>
					}

				}
				else
				{//
					logFromISR("\n\r Radio Internal parameter length error \n\r");
800063a6:	4a 5c       	lddpc	r12,80006438 <phy_payload_rx+0xed8>
800063a8:	f0 1f 00 12 	mcall	800063f0 <phy_payload_rx+0xe90>
					RxMediaState = WAITINGABAB;//Jump
800063ac:	48 d8       	lddpc	r8,800063e0 <phy_payload_rx+0xe80>
800063ae:	30 09       	mov	r9,0
800063b0:	91 09       	st.w	r8[0x0],r9
800063b2:	c0 c8       	rjmp	800063ca <phy_payload_rx+0xe6a>
				m_RxBurstType = VOICE_WATING;
				//Upon receiving the idle frame, the m Rx Burst Type into an idle state in order to transmit the synchronization wait
				 break; 
			}
            
			if ((payload_rx_channel->dword[0]  & 0xFFFF0000) != 0xABCD0000)break; //Skip until Header. 
800063b4:	d7 03       	nop
800063b6:	c0 a8       	rjmp	800063ca <phy_payload_rx+0xe6a>
						RxMediaState  = WAITINGABAB;
						break;
					}
			
			
			break;//End of READING_AMBE_MEDIA.
800063b8:	d7 03       	nop
800063ba:	c0 88       	rjmp	800063ca <phy_payload_rx+0xe6a>
800063bc:	d7 03       	nop
800063be:	c0 68       	rjmp	800063ca <phy_payload_rx+0xe6a>
800063c0:	d7 03       	nop
800063c2:	c0 48       	rjmp	800063ca <phy_payload_rx+0xe6a>
							RxBytesWaiting = 0;
							RxMediaState = WAITINGABAB;
							break;
			
						}
						break;
800063c4:	d7 03       	nop
800063c6:	c0 28       	rjmp	800063ca <phy_payload_rx+0xe6a>
							Soft_Decision_Data[SDV_Index+3]	  = payload_rx_channel->word[3];
							SDV_Index +=4;
									
						}
							
							break;
800063c8:	d7 03       	nop

#endif
		case BGFORCERESET: //Do nothing.
		break;
	}//End of RxMedia Phy Handler.
}
800063ca:	2f ed       	sub	sp,-8
800063cc:	e3 cd 80 80 	ldm	sp++,r7,pc
800063d0:	00 00       	add	r0,r0
800063d2:	0a b0       	st.h	r5++,r0
800063d4:	00 00       	add	r0,r0
800063d6:	0a 98       	mov	r8,r5
800063d8:	80 00       	ld.sh	r0,r0[0x0]
800063da:	64 7c       	ld.w	r12,r2[0x1c]
800063dc:	00 00       	add	r0,r0
800063de:	0a b4       	st.h	r5++,r4
800063e0:	00 00       	add	r0,r0
800063e2:	0a b8       	st.h	r5++,r8
800063e4:	00 00       	add	r0,r0
800063e6:	0a a4       	st.w	r5++,r4
800063e8:	00 00       	add	r0,r0
800063ea:	0a bc       	st.h	r5++,r12
800063ec:	80 00       	ld.sh	r0,r0[0x0]
800063ee:	47 a4       	lddsp	r4,sp[0x1e8]
800063f0:	80 00       	ld.sh	r0,r0[0x0]
800063f2:	aa e0       	st.b	r5[0x6],r0
800063f4:	00 00       	add	r0,r0
800063f6:	0a 5b       	eor	r11,r5
800063f8:	00 00       	add	r0,r0
800063fa:	0a c0       	st.b	r5++,r0
800063fc:	00 00       	add	r0,r0
800063fe:	0a c4       	st.b	r5++,r4
80006400:	00 00       	add	r0,r0
80006402:	0a c8       	st.b	r5++,r8
80006404:	80 00       	ld.sh	r0,r0[0x0]
80006406:	b6 aa       	st.b	r11[0x2],r10
80006408:	80 00       	ld.sh	r0,r0[0x0]
8000640a:	54 e4       	stdsp	sp[0x138],r4
8000640c:	00 00       	add	r0,r0
8000640e:	0a 5f       	eor	pc,r5
80006410:	00 00       	add	r0,r0
80006412:	20 ac       	sub	r12,10
80006414:	80 00       	ld.sh	r0,r0[0x0]
80006416:	46 68       	lddsp	r8,sp[0x198]
80006418:	00 00       	add	r0,r0
8000641a:	0a cc       	st.b	r5++,r12
8000641c:	00 00       	add	r0,r0
8000641e:	1f b0       	ld.ub	r0,pc[0x3]
80006420:	00 00       	add	r0,r0
80006422:	0a a8       	st.w	r5++,r8
80006424:	00 00       	add	r0,r0
80006426:	0a 5a       	eor	r10,r5
80006428:	00 00       	add	r0,r0
8000642a:	1f a8       	ld.ub	r8,pc[0x2]
8000642c:	00 00       	add	r0,r0
8000642e:	0a d0       	st.w	--r5,r0
80006430:	00 00       	add	r0,r0
80006432:	20 b0       	sub	r0,11
80006434:	00 00       	add	r0,r0
80006436:	0a 59       	eor	r9,r5
80006438:	80 00       	ld.sh	r0,r0[0x0]
8000643a:	47 bc       	lddsp	r12,sp[0x1ec]

8000643c <get_idle_store>:
#endif /*end if*/

void * get_idle_store(xQueueHandle store)
{
8000643c:	eb cd 40 80 	pushm	r7,lr
80006440:	1a 97       	mov	r7,sp
80006442:	20 2d       	sub	sp,8
80006444:	ef 4c ff f8 	st.w	r7[-8],r12
	void * ptr = NULL;
80006448:	30 08       	mov	r8,0
8000644a:	ef 48 ff fc 	st.w	r7[-4],r8

	if(pdTRUE == xQueueReceive(store, &ptr, 0))
8000644e:	ee c8 00 04 	sub	r8,r7,4
80006452:	30 09       	mov	r9,0
80006454:	30 0a       	mov	r10,0
80006456:	10 9b       	mov	r11,r8
80006458:	ee fc ff f8 	ld.w	r12,r7[-8]
8000645c:	f0 1f 00 07 	mcall	80006478 <get_idle_store+0x3c>
80006460:	18 98       	mov	r8,r12
80006462:	58 18       	cp.w	r8,1
80006464:	c0 41       	brne	8000646c <get_idle_store+0x30>
	{
		return ptr;
80006466:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000646a:	c0 28       	rjmp	8000646e <get_idle_store+0x32>
	}
	else
	{
		return NULL;
8000646c:	30 08       	mov	r8,0
	}
}
8000646e:	10 9c       	mov	r12,r8
80006470:	2f ed       	sub	sp,-8
80006472:	e3 cd 80 80 	ldm	sp++,r7,pc
80006476:	00 00       	add	r0,r0
80006478:	80 00       	ld.sh	r0,r0[0x0]
8000647a:	91 50       	st.w	r8[0x14],r0

8000647c <get_idle_store_isr>:

void * get_idle_store_isr(xQueueHandle store)
{
8000647c:	eb cd 40 80 	pushm	r7,lr
80006480:	1a 97       	mov	r7,sp
80006482:	20 3d       	sub	sp,12
80006484:	ef 4c ff f4 	st.w	r7[-12],r12
	void * ptr = NULL;
80006488:	30 08       	mov	r8,0
8000648a:	ef 48 ff fc 	st.w	r7[-4],r8
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
8000648e:	30 08       	mov	r8,0
80006490:	ef 48 ff f8 	st.w	r7[-8],r8
	
	if(pdTRUE == xQueueReceiveFromISR(store, &ptr, &xHigherPriorityTaskWoken))
80006494:	ee c9 00 08 	sub	r9,r7,8
80006498:	ee c8 00 04 	sub	r8,r7,4
8000649c:	12 9a       	mov	r10,r9
8000649e:	10 9b       	mov	r11,r8
800064a0:	ee fc ff f4 	ld.w	r12,r7[-12]
800064a4:	f0 1f 00 07 	mcall	800064c0 <get_idle_store_isr+0x44>
800064a8:	18 98       	mov	r8,r12
800064aa:	58 18       	cp.w	r8,1
800064ac:	c0 41       	brne	800064b4 <get_idle_store_isr+0x38>
	{
		return ptr;
800064ae:	ee f8 ff fc 	ld.w	r8,r7[-4]
800064b2:	c0 28       	rjmp	800064b6 <get_idle_store_isr+0x3a>
	}
	else
	{
		return NULL;
800064b4:	30 08       	mov	r8,0
	}
}
800064b6:	10 9c       	mov	r12,r8
800064b8:	2f dd       	sub	sp,-12
800064ba:	e3 cd 80 80 	ldm	sp++,r7,pc
800064be:	00 00       	add	r0,r0
800064c0:	80 00       	ld.sh	r0,r0[0x0]
800064c2:	93 3c       	st.w	r9[0xc],r12

800064c4 <set_idle_store>:


void set_idle_store(xQueueHandle store, void * ptr)
{
800064c4:	eb cd 40 80 	pushm	r7,lr
800064c8:	1a 97       	mov	r7,sp
800064ca:	20 2d       	sub	sp,8
800064cc:	ef 4c ff fc 	st.w	r7[-4],r12
800064d0:	ef 4b ff f8 	st.w	r7[-8],r11
	xQueueSend(store, &ptr, 0);
800064d4:	ee c8 00 08 	sub	r8,r7,8
800064d8:	30 09       	mov	r9,0
800064da:	30 0a       	mov	r10,0
800064dc:	10 9b       	mov	r11,r8
800064de:	ee fc ff fc 	ld.w	r12,r7[-4]
800064e2:	f0 1f 00 03 	mcall	800064ec <set_idle_store+0x28>
}
800064e6:	2f ed       	sub	sp,-8
800064e8:	e3 cd 80 80 	ldm	sp++,r7,pc
800064ec:	80 00       	ld.sh	r0,r0[0x0]
800064ee:	8f 44       	st.w	r7[0x10],r4

800064f0 <set_idle_store_isr>:

void set_idle_store_isr(xQueueHandle store, void * ptr)
{
800064f0:	eb cd 40 80 	pushm	r7,lr
800064f4:	1a 97       	mov	r7,sp
800064f6:	20 3d       	sub	sp,12
800064f8:	ef 4c ff f8 	st.w	r7[-8],r12
800064fc:	ef 4b ff f4 	st.w	r7[-12],r11
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80006500:	30 08       	mov	r8,0
80006502:	ef 48 ff fc 	st.w	r7[-4],r8
	xQueueSendFromISR(store, &ptr, &xHigherPriorityTaskWoken);
80006506:	ee ca 00 04 	sub	r10,r7,4
8000650a:	ee c8 00 0c 	sub	r8,r7,12
8000650e:	30 09       	mov	r9,0
80006510:	10 9b       	mov	r11,r8
80006512:	ee fc ff f8 	ld.w	r12,r7[-8]
80006516:	f0 1f 00 03 	mcall	80006520 <set_idle_store_isr+0x30>
}
8000651a:	2f dd       	sub	sp,-12
8000651c:	e3 cd 80 80 	ldm	sp++,r7,pc
80006520:	80 00       	ld.sh	r0,r0[0x0]
80006522:	90 ac       	ld.uh	r12,r8[0x4]

80006524 <pdca_int_handler>:
    void (*phy_rx_exec)(void *)--callback function for receive SSC data 
Called By: interrupt
*/
__attribute__((__interrupt__))
static void pdca_int_handler(void)
{
80006524:	eb cd 40 80 	pushm	r7,lr
80006528:	1a 97       	mov	r7,sp
    
	//intStartCount = Get_system_register(AVR32_COUNT);
	
	/*Toggle Index*/
    BufferIndex ^= 0x01;
8000652a:	4a 98       	lddpc	r8,800065cc <pdca_int_handler+0xa8>
8000652c:	11 88       	ld.ub	r8,r8[0x0]
8000652e:	5c 58       	castu.b	r8
80006530:	ec 18 00 01 	eorl	r8,0x1
80006534:	5c 58       	castu.b	r8
80006536:	4a 69       	lddpc	r9,800065cc <pdca_int_handler+0xa8>
80006538:	b2 88       	st.b	r9[0x0],r8
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
8000653a:	fe 79 00 40 	mov	r9,-65472
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);
8000653e:	4a 48       	lddpc	r8,800065cc <pdca_int_handler+0xa8>
80006540:	11 88       	ld.ub	r8,r8[0x0]
80006542:	5c 58       	castu.b	r8
80006544:	a3 68       	lsl	r8,0x2
80006546:	2f f8       	sub	r8,-1
80006548:	f0 0a 15 02 	lsl	r10,r8,0x2
8000654c:	4a 18       	lddpc	r8,800065d0 <pdca_int_handler+0xac>
8000654e:	f4 08 00 08 	add	r8,r10,r8
	
	/*Toggle Index*/
    BufferIndex ^= 0x01;
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
80006552:	93 38       	st.w	r9[0xc],r8
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80006554:	fe 78 00 40 	mov	r8,-65472
80006558:	30 39       	mov	r9,3
8000655a:	91 49       	st.w	r8[0x10],r9

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
8000655c:	fe 79 00 00 	mov	r9,-65536
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);
80006560:	49 b8       	lddpc	r8,800065cc <pdca_int_handler+0xa8>
80006562:	11 88       	ld.ub	r8,r8[0x0]
80006564:	5c 58       	castu.b	r8
80006566:	a3 68       	lsl	r8,0x2
80006568:	2f f8       	sub	r8,-1
8000656a:	f0 0a 15 02 	lsl	r10,r8,0x2
8000656e:	49 a8       	lddpc	r8,800065d4 <pdca_int_handler+0xb0>
80006570:	f4 08 00 08 	add	r8,r10,r8
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
80006574:	93 38       	st.w	r9[0xc],r8
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80006576:	fe 78 00 00 	mov	r8,-65536
8000657a:	30 39       	mov	r9,3
8000657c:	91 49       	st.w	r8[0x10],r9
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr;
8000657e:	fe 78 00 00 	mov	r8,-65536
80006582:	70 b8       	ld.w	r8,r8[0x2c]
	
	/*receive SSC data*/
    if(phy_rx_exec != NULL)phy_rx_exec((void *)&RxBuffer[BufferIndex]);
80006584:	49 58       	lddpc	r8,800065d8 <pdca_int_handler+0xb4>
80006586:	70 08       	ld.w	r8,r8[0x0]
80006588:	58 08       	cp.w	r8,0
8000658a:	c0 d0       	breq	800065a4 <pdca_int_handler+0x80>
8000658c:	49 38       	lddpc	r8,800065d8 <pdca_int_handler+0xb4>
8000658e:	70 09       	ld.w	r9,r8[0x0]
80006590:	48 f8       	lddpc	r8,800065cc <pdca_int_handler+0xa8>
80006592:	11 88       	ld.ub	r8,r8[0x0]
80006594:	5c 58       	castu.b	r8
80006596:	f0 0a 15 04 	lsl	r10,r8,0x4
8000659a:	48 f8       	lddpc	r8,800065d4 <pdca_int_handler+0xb0>
8000659c:	f4 08 00 08 	add	r8,r10,r8
800065a0:	10 9c       	mov	r12,r8
800065a2:	5d 19       	icall	r9

    /*transmit SSC data*/

	if(phy_tx_exec != NULL)phy_tx_exec((void *)&TxBuffer[BufferIndex]);//phy_tx_func, phy_rx_func
800065a4:	48 e8       	lddpc	r8,800065dc <pdca_int_handler+0xb8>
800065a6:	70 08       	ld.w	r8,r8[0x0]
800065a8:	58 08       	cp.w	r8,0
800065aa:	c0 d0       	breq	800065c4 <pdca_int_handler+0xa0>
800065ac:	48 c8       	lddpc	r8,800065dc <pdca_int_handler+0xb8>
800065ae:	70 09       	ld.w	r9,r8[0x0]
800065b0:	48 78       	lddpc	r8,800065cc <pdca_int_handler+0xa8>
800065b2:	11 88       	ld.ub	r8,r8[0x0]
800065b4:	5c 58       	castu.b	r8
800065b6:	f0 0a 15 04 	lsl	r10,r8,0x4
800065ba:	48 68       	lddpc	r8,800065d0 <pdca_int_handler+0xac>
800065bc:	f4 08 00 08 	add	r8,r10,r8
800065c0:	10 9c       	mov	r12,r8
800065c2:	5d 19       	icall	r9

	
	//intDuration = Get_system_register(AVR32_COUNT) - intStartCount;
	
	
}/*End of pdca_int_handler.*/
800065c4:	e3 cd 40 80 	ldm	sp++,r7,lr
800065c8:	d6 03       	rete
800065ca:	00 00       	add	r0,r0
800065cc:	00 00       	add	r0,r0
800065ce:	52 d0       	stdsp	sp[0xb4],r0
800065d0:	00 00       	add	r0,r0
800065d2:	52 f8       	stdsp	sp[0xbc],r8
800065d4:	00 00       	add	r0,r0
800065d6:	52 d8       	stdsp	sp[0xb4],r8
800065d8:	00 00       	add	r0,r0
800065da:	0b 00       	ld.w	r0,r5++
800065dc:	00 00       	add	r0,r0
800065de:	0b 04       	ld.w	r4,r5++

800065e0 <local_start_SSC>:
    Before using the SSC transmitter, the PIO controller must be configured to 
    dedicate the SSC,transmitter I/O lines to the SSC peripheral mode. [23.6.1]
Called By: void ssc_init(void) -- ssc.c
*/
void local_start_SSC(void)
{
800065e0:	eb cd 40 80 	pushm	r7,lr
800065e4:	1a 97       	mov	r7,sp
    /*Assign GPIO to SSC.
    gpio_enable_module
    gpio_enable_module_pin*/
    AVR32_GPIO.port[1].pmr0c = 0x00000DC0;
800065e6:	fe 78 10 00 	mov	r8,-61440
800065ea:	e0 69 0d c0 	mov	r9,3520
800065ee:	f1 49 01 18 	st.w	r8[280],r9
    AVR32_GPIO.port[1].pmr1c = 0x00000DC0;
800065f2:	fe 78 10 00 	mov	r8,-61440
800065f6:	e0 69 0d c0 	mov	r9,3520
800065fa:	f1 49 01 28 	st.w	r8[296],r9
    AVR32_GPIO.port[1].gperc = 0x00000DC0;
800065fe:	fe 78 10 00 	mov	r8,-61440
80006602:	e0 69 0d c0 	mov	r9,3520
80006606:	f1 49 01 08 	st.w	r8[264],r9

    /*Software reset SSC*/
    (&AVR32_SSC)->cr = AVR32_SSC_CR_SWRST_MASK;
8000660a:	fe 78 34 00 	mov	r8,-52224
8000660e:	e0 69 80 00 	mov	r9,32768
80006612:	91 09       	st.w	r8[0x0],r9
    (&AVR32_SSC)->cmr 
80006614:	fe 78 34 00 	mov	r8,-52224
80006618:	30 09       	mov	r9,0
8000661a:	91 19       	st.w	r8[0x4],r9
                     = AVR32_SSC_CMR_DIV_NOT_ACTIVE << AVR32_SSC_CMR_DIV_OFFSET;

    /*For Slave*/
    (&AVR32_SSC)->tcmr =
8000661c:	fe 78 34 00 	mov	r8,-52224
80006620:	e0 69 04 21 	mov	r9,1057
80006624:	ea 19 3f 20 	orh	r9,0x3f20
80006628:	91 69       	st.w	r8[0x18],r9
	    | 32 << AVR32_SSC_TCMR_STTDLY_OFFSET
	    | 63 << AVR32_SSC_TCMR_PERIOD_OFFSET;


    /*For Slave*/
    (&AVR32_SSC)->tfmr = 31 << AVR32_SSC_TFMR_DATLEN_OFFSET 
8000662a:	fe 78 34 00 	mov	r8,-52224
8000662e:	e0 69 02 9f 	mov	r9,671
80006632:	ea 19 01 00 	orh	r9,0x100
80006636:	91 79       	st.w	r8[0x1c],r9
	    | 0 << AVR32_SSC_TFMR_FSDEN_OFFSET
	    | 1 << AVR32_SSC_TFMR_FSEDGE_OFFSET;

	/*For Slave*/

	(&AVR32_SSC)->rcmr = AVR32_SSC_RCMR_CKS_RK_PIN << AVR32_SSC_RCMR_CKS_OFFSET
80006638:	fe 78 34 00 	mov	r8,-52224
8000663c:	e0 69 04 02 	mov	r9,1026
80006640:	ea 19 3f 20 	orh	r9,0x3f20
80006644:	91 49       	st.w	r8[0x10],r9
	    | 0 << AVR32_SSC_RCMR_STOP_OFFSET
	    | 32 << AVR32_SSC_RCMR_STTDLY_OFFSET
	    | 63 << AVR32_SSC_RCMR_PERIOD_OFFSET;

	/*For Slave*/
	(&AVR32_SSC)->rfmr = 31 << AVR32_SSC_RFMR_DATLEN_OFFSET
80006646:	fe 78 34 00 	mov	r8,-52224
8000664a:	e0 69 02 9f 	mov	r9,671
8000664e:	ea 19 01 00 	orh	r9,0x100
80006652:	91 59       	st.w	r8[0x14],r9
	    | 1 << AVR32_SSC_RFMR_MSBF_OFFSET
	    | 2 << AVR32_SSC_RFMR_DATNB_OFFSET
	    | 0 << AVR32_SSC_RFMR_FSLEN_OFFSET
	    | AVR32_SSC_RFMR_FSOS_INPUT_ONLY << AVR32_SSC_RFMR_FSOS_OFFSET
	    | 1 << AVR32_SSC_RFMR_FSEDGE_OFFSET;
}/*End of local_start_SSC.*/
80006654:	e3 cd 80 80 	ldm	sp++,r7,pc

80006658 <local_start_PDC>:
Function: local_start_PDC
Description: none
Called By: void ssc_init(void) -- ssc.c
*/
void local_start_PDC(void)
{
80006658:	eb cd 40 80 	pushm	r7,lr
8000665c:	1a 97       	mov	r7,sp
    /*Toggle Index*/	
    BufferIndex = 1;
8000665e:	4b 39       	lddpc	r9,80006728 <local_start_PDC+0xd0>
80006660:	30 18       	mov	r8,1
80006662:	b2 88       	st.b	r9[0x0],r8
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
80006664:	fe 78 00 00 	mov	r8,-65536
80006668:	30 79       	mov	r9,7
8000666a:	91 99       	st.w	r8[0x24],r9
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
8000666c:	fe 78 00 00 	mov	r8,-65536
80006670:	70 b8       	ld.w	r8,r8[0x2c]
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
80006672:	fe 78 00 00 	mov	r8,-65536
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
80006676:	4a e9       	lddpc	r9,8000672c <local_start_PDC+0xd4>
80006678:	2f c9       	sub	r9,-4
    BufferIndex = 1;
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
8000667a:	91 09       	st.w	r8[0x0],r9
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
8000667c:	fe 78 00 00 	mov	r8,-65536
80006680:	30 39       	mov	r9,3
80006682:	91 29       	st.w	r8[0x8],r9
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
80006684:	fe 78 00 00 	mov	r8,-65536
80006688:	30 19       	mov	r9,1
8000668a:	91 19       	st.w	r8[0x4],r9
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
8000668c:	fe 78 00 00 	mov	r8,-65536
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
80006690:	4a 79       	lddpc	r9,8000672c <local_start_PDC+0xd4>
80006692:	2e c9       	sub	r9,-20
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
80006694:	91 39       	st.w	r8[0xc],r9
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80006696:	fe 78 00 00 	mov	r8,-65536
8000669a:	30 39       	mov	r9,3
8000669c:	91 49       	st.w	r8[0x10],r9
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mr = AVR32_PDCA_WORD;
8000669e:	fe 78 00 00 	mov	r8,-65536
800066a2:	30 29       	mov	r9,2
800066a4:	91 69       	st.w	r8[0x18],r9

	TxBuffer[0].xnl_channel.dword = XNL_IDLE;
800066a6:	4a 38       	lddpc	r8,80006730 <local_start_PDC+0xd8>
800066a8:	e0 69 5a 5a 	mov	r9,23130
800066ac:	ea 19 ab cd 	orh	r9,0xabcd
800066b0:	91 19       	st.w	r8[0x4],r9
	TxBuffer[0].payload_channel.dword[0] = PAYLOADIDLE0;
800066b2:	4a 08       	lddpc	r8,80006730 <local_start_PDC+0xd8>
800066b4:	e0 69 5a 5a 	mov	r9,23130
800066b8:	ea 19 ab cd 	orh	r9,0xabcd
800066bc:	91 29       	st.w	r8[0x8],r9
	TxBuffer[0].payload_channel.dword[1] = PAYLOADIDLE1;
800066be:	49 d8       	lddpc	r8,80006730 <local_start_PDC+0xd8>
800066c0:	30 09       	mov	r9,0
800066c2:	91 39       	st.w	r8[0xc],r9
	TxBuffer[1].xnl_channel.dword = XNL_IDLE;
800066c4:	49 b8       	lddpc	r8,80006730 <local_start_PDC+0xd8>
800066c6:	e0 69 5a 5a 	mov	r9,23130
800066ca:	ea 19 ab cd 	orh	r9,0xabcd
800066ce:	91 59       	st.w	r8[0x14],r9
	TxBuffer[1].payload_channel.dword[0] = PAYLOADIDLE0;
800066d0:	49 88       	lddpc	r8,80006730 <local_start_PDC+0xd8>
800066d2:	e0 69 5a 5a 	mov	r9,23130
800066d6:	ea 19 ab cd 	orh	r9,0xabcd
800066da:	91 69       	st.w	r8[0x18],r9
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;
800066dc:	49 58       	lddpc	r8,80006730 <local_start_PDC+0xd8>
800066de:	30 09       	mov	r9,0
800066e0:	91 79       	st.w	r8[0x1c],r9

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
800066e2:	fe 78 00 40 	mov	r8,-65472
800066e6:	30 79       	mov	r9,7
800066e8:	91 99       	st.w	r8[0x24],r9
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
800066ea:	fe 78 00 40 	mov	r8,-65472
800066ee:	70 b8       	ld.w	r8,r8[0x2c]
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
800066f0:	fe 78 00 40 	mov	r8,-65472
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
800066f4:	48 f9       	lddpc	r9,80006730 <local_start_PDC+0xd8>
800066f6:	2f c9       	sub	r9,-4
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
800066f8:	91 09       	st.w	r8[0x0],r9
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
800066fa:	fe 78 00 40 	mov	r8,-65472
800066fe:	30 39       	mov	r9,3
80006700:	91 29       	st.w	r8[0x8],r9
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
80006702:	fe 78 00 40 	mov	r8,-65472
80006706:	30 79       	mov	r9,7
80006708:	91 19       	st.w	r8[0x4],r9
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
8000670a:	fe 78 00 40 	mov	r8,-65472
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
8000670e:	48 99       	lddpc	r9,80006730 <local_start_PDC+0xd8>
80006710:	2e c9       	sub	r9,-20
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
80006712:	91 39       	st.w	r8[0xc],r9
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80006714:	fe 78 00 40 	mov	r8,-65472
80006718:	30 39       	mov	r9,3
8000671a:	91 49       	st.w	r8[0x10],r9
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mr = AVR32_PDCA_WORD;
8000671c:	fe 78 00 40 	mov	r8,-65472
80006720:	30 29       	mov	r9,2
80006722:	91 69       	st.w	r8[0x18],r9
}/*End of local_start_PDC.*/
80006724:	e3 cd 80 80 	ldm	sp++,r7,pc
80006728:	00 00       	add	r0,r0
8000672a:	52 d0       	stdsp	sp[0xb4],r0
8000672c:	00 00       	add	r0,r0
8000672e:	52 d8       	stdsp	sp[0xb4],r8
80006730:	00 00       	add	r0,r0
80006732:	52 f8       	stdsp	sp[0xbc],r8

80006734 <ssc_init>:
    local_start_SSC -- ssc.c
    local_start_PDC -- ssc.c
Called By: phy_init -- physical.c
*/
void ssc_init(void)
{		
80006734:	eb cd 40 80 	pushm	r7,lr
80006738:	1a 97       	mov	r7,sp
    /*Set up PB01 to watch FS.*/
    AVR32_GPIO.port[1].oderc = 0x00000002;	
8000673a:	fe 78 10 00 	mov	r8,-61440
8000673e:	30 29       	mov	r9,2
80006740:	f1 49 01 48 	st.w	r8[328],r9
    AVR32_GPIO.port[1].gpers = 0x00000002;
80006744:	fe 78 10 00 	mov	r8,-61440
80006748:	30 29       	mov	r9,2
8000674a:	f1 49 01 04 	st.w	r8[260],r9

    /*Waits for radio to start making FSYNC.*/
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
8000674e:	fe 78 10 00 	mov	r8,-61440
80006752:	f0 f8 01 60 	ld.w	r8,r8[352]
80006756:	e2 18 00 02 	andl	r8,0x2,COH
8000675a:	cf a0       	breq	8000674e <ssc_init+0x1a>
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
8000675c:	fe 78 10 00 	mov	r8,-61440
80006760:	f0 f8 01 60 	ld.w	r8,r8[352]
80006764:	e2 18 00 02 	andl	r8,0x2,COH
80006768:	cf a1       	brne	8000675c <ssc_init+0x28>
				
    INTC_register_interrupt (
8000676a:	30 3a       	mov	r10,3
8000676c:	36 0b       	mov	r11,96
8000676e:	48 ec       	lddpc	r12,800067a4 <ssc_init+0x70>
80006770:	f0 1f 00 0e 	mcall	800067a8 <ssc_init+0x74>
        , AVR32_PDCA_IRQ_0
        , AVR32_INTC_INT3
    );
				
    /*config the SSC*/
    local_start_SSC();
80006774:	f0 1f 00 0e 	mcall	800067ac <ssc_init+0x78>

    /*config the PDCA*/
    local_start_PDC();
80006778:	f0 1f 00 0e 	mcall	800067b0 <ssc_init+0x7c>
		
    /*Start the SSC Physical Layer.*/

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
8000677c:	fe 78 00 00 	mov	r8,-65536
80006780:	30 19       	mov	r9,1
80006782:	91 59       	st.w	r8[0x14],r9
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80006784:	fe 78 00 40 	mov	r8,-65472
80006788:	30 19       	mov	r9,1
8000678a:	91 59       	st.w	r8[0x14],r9
    (&AVR32_SSC)->cr = AVR32_SSC_CR_RXEN_MASK | AVR32_SSC_CR_TXEN_MASK;
8000678c:	fe 78 34 00 	mov	r8,-52224
80006790:	e0 69 01 01 	mov	r9,257
80006794:	91 09       	st.w	r8[0x0],r9
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->ier = 
80006796:	fe 78 00 00 	mov	r8,-65536
8000679a:	30 19       	mov	r9,1
8000679c:	91 89       	st.w	r8[0x20],r9
                                                            AVR32_PDCA_RCZ_MASK;
}/*End of ssc_init.*/
8000679e:	e3 cd 80 80 	ldm	sp++,r7,pc
800067a2:	00 00       	add	r0,r0
800067a4:	80 00       	ld.sh	r0,r0[0x0]
800067a6:	65 24       	ld.w	r4,r2[0x48]
800067a8:	80 00       	ld.sh	r0,r0[0x0]
800067aa:	78 a4       	ld.w	r4,r12[0x28]
800067ac:	80 00       	ld.sh	r0,r0[0x0]
800067ae:	65 e0       	ld.w	r0,r2[0x78]
800067b0:	80 00       	ld.sh	r0,r0[0x0]
800067b2:	66 58       	ld.w	r8,r3[0x14]

800067b4 <register_rx_tx_func>:
	void ( *tx_exec)(void *) -- send ssc function
Description: register the rx function(callback function)
Called By: phy_init -- physical.c
*/
void register_rx_tx_func(void (*rx_exec)(void *),  void ( *tx_exec)(void *))
{
800067b4:	eb cd 40 80 	pushm	r7,lr
800067b8:	1a 97       	mov	r7,sp
800067ba:	20 2d       	sub	sp,8
800067bc:	ef 4c ff fc 	st.w	r7[-4],r12
800067c0:	ef 4b ff f8 	st.w	r7[-8],r11
	 phy_rx_exec = rx_exec;
800067c4:	ee f9 ff fc 	ld.w	r9,r7[-4]
800067c8:	48 58       	lddpc	r8,800067dc <register_rx_tx_func+0x28>
800067ca:	91 09       	st.w	r8[0x0],r9
	 phy_tx_exec = tx_exec;//phy_tx_func, phy_rx_func
800067cc:	ee f9 ff f8 	ld.w	r9,r7[-8]
800067d0:	48 48       	lddpc	r8,800067e0 <register_rx_tx_func+0x2c>
800067d2:	91 09       	st.w	r8[0x0],r9
	 
}/*End of register_tx_rx_func.*/
800067d4:	2f ed       	sub	sp,-8
800067d6:	e3 cd 80 80 	ldm	sp++,r7,pc
800067da:	00 00       	add	r0,r0
800067dc:	00 00       	add	r0,r0
800067de:	0b 00       	ld.w	r0,r5++
800067e0:	00 00       	add	r0,r0
800067e2:	0b 04       	ld.w	r4,r5++
800067e4:	58 43       	cp.w	r3,4
800067e6:	4d 50       	lddpc	r0,80006938 <xcmp_exec_func+0x60>
800067e8:	5f 52       	srlt	r2
800067ea:	58 00       	cp.w	r0,0

800067ec <xcmp_tx>:
Calls:   
	xnl_tx -- xnl.c
Called By: ...
*/
static void xcmp_tx( xcmp_fragment_t * xcmp, U8 payload_len)
{
800067ec:	eb cd 40 80 	pushm	r7,lr
800067f0:	1a 97       	mov	r7,sp
800067f2:	fa cd 01 08 	sub	sp,sp,264
800067f6:	ef 4c fe fc 	st.w	r7[-260],r12
800067fa:	16 98       	mov	r8,r11
800067fc:	ef 68 fe f8 	st.b	r7[-264],r8
	Length :xnl length + checksum
	= checksum + xnl header + xcmp opcode + xcmp payload
	= 0x02 + 0x0C + 0x02 + xcmp payload
	= 0x10 + xcmp payload
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | ( 0x10 + payload_len);
80006800:	ef 38 fe f8 	ld.ub	r8,r7[-264]
80006804:	2f 08       	sub	r8,-16
80006806:	5c 88       	casts.h	r8
80006808:	5c 88       	casts.h	r8
8000680a:	af a8       	sbr	r8,0xe
8000680c:	5c 88       	casts.h	r8
8000680e:	ef 58 ff 00 	st.h	r7[-256],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE; 
80006812:	3f f8       	mov	r8,-1
80006814:	ef 58 ff 02 	st.h	r7[-254],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG;
80006818:	30 b8       	mov	r8,11
8000681a:	ef 58 ff 04 	st.h	r7[-252],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;	
8000681e:	3f f8       	mov	r8,-1
80006820:	ef 58 ff 06 	st.h	r7[-250],r8
	xnl_frame.xnl_header.destination = DEFAULT_VALUE;
80006824:	3f f8       	mov	r8,-1
80006826:	ef 58 ff 08 	st.h	r7[-248],r8
	xnl_frame.xnl_header.source = DEFAULT_VALUE;	
8000682a:	3f f8       	mov	r8,-1
8000682c:	ef 58 ff 0a 	st.h	r7[-246],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80006830:	3f f8       	mov	r8,-1
80006832:	ef 58 ff 0c 	st.h	r7[-244],r8
	
	/*insert xcmp frame data*/
	memcpy(&xnl_frame.xnl_payload.xnl_content_data_msg, xcmp, payload_len + 2);
80006836:	ef 38 fe f8 	ld.ub	r8,r7[-264]
8000683a:	2f e8       	sub	r8,-2
8000683c:	10 99       	mov	r9,r8
8000683e:	ee c8 01 00 	sub	r8,r7,256
80006842:	2f 08       	sub	r8,-16
80006844:	12 9a       	mov	r10,r9
80006846:	ee fb fe fc 	ld.w	r11,r7[-260]
8000684a:	10 9c       	mov	r12,r8
8000684c:	f0 1f 00 09 	mcall	80006870 <xcmp_tx+0x84>
	xnl_frame.xnl_header.payload_length = payload_len + 2;	
80006850:	ef 38 fe f8 	ld.ub	r8,r7[-264]
80006854:	2f e8       	sub	r8,-2
80006856:	5c 88       	casts.h	r8
80006858:	5c 88       	casts.h	r8
8000685a:	ef 58 ff 0e 	st.h	r7[-242],r8
	
	/* send xnl frame*/	
	xnl_tx(&xnl_frame);
8000685e:	ee c8 01 00 	sub	r8,r7,256
80006862:	10 9c       	mov	r12,r8
80006864:	f0 1f 00 04 	mcall	80006874 <xcmp_tx+0x88>
}
80006868:	2b ed       	sub	sp,-264
8000686a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000686e:	00 00       	add	r0,r0
80006870:	80 00       	ld.sh	r0,r0[0x0]
80006872:	b5 62       	lsl	r2,0x14
80006874:	80 00       	ld.sh	r0,r0[0x0]
80006876:	72 64       	ld.w	r4,r9[0x18]

80006878 <xcmp_rx>:
Calls:   
	xQueueSend -- xnl.c
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
80006878:	eb cd 40 c0 	pushm	r6-r7,lr
8000687c:	1a 97       	mov	r7,sp
8000687e:	20 1d       	sub	sp,4
80006880:	ee c6 ff f4 	sub	r6,r7,-12
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
80006884:	49 08       	lddpc	r8,800068c4 <xcmp_rx+0x4c>
80006886:	70 08       	ld.w	r8,r8[0x0]
80006888:	10 9c       	mov	r12,r8
8000688a:	f0 1f 00 10 	mcall	800068c8 <xcmp_rx+0x50>
8000688e:	18 98       	mov	r8,r12
80006890:	ef 48 ff fc 	st.w	r7[-4],r8
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
80006894:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006898:	58 08       	cp.w	r8,0
8000689a:	c1 20       	breq	800068be <xcmp_rx+0x46>
	{
		memcpy(xcmp_ptr, &xcmp, sizeof(xcmp_fragment_t));				
8000689c:	ee f8 ff fc 	ld.w	r8,r7[-4]
800068a0:	e0 6a 00 ca 	mov	r10,202
800068a4:	0c 9b       	mov	r11,r6
800068a6:	10 9c       	mov	r12,r8
800068a8:	f0 1f 00 09 	mcall	800068cc <xcmp_rx+0x54>
		xQueueSend(xcmp_frame_rx, &xcmp_ptr, 0);	
800068ac:	48 98       	lddpc	r8,800068d0 <xcmp_rx+0x58>
800068ae:	70 08       	ld.w	r8,r8[0x0]
800068b0:	ee cb 00 04 	sub	r11,r7,4
800068b4:	30 09       	mov	r9,0
800068b6:	30 0a       	mov	r10,0
800068b8:	10 9c       	mov	r12,r8
800068ba:	f0 1f 00 07 	mcall	800068d4 <xcmp_rx+0x5c>
	}	
}
800068be:	2f fd       	sub	sp,-4
800068c0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800068c4:	00 00       	add	r0,r0
800068c6:	0a 8c       	andn	r12,r5
800068c8:	80 00       	ld.sh	r0,r0[0x0]
800068ca:	64 3c       	ld.w	r12,r2[0xc]
800068cc:	80 00       	ld.sh	r0,r0[0x0]
800068ce:	b5 62       	lsl	r2,0x14
800068d0:	00 00       	add	r0,r0
800068d2:	0b 08       	ld.w	r8,r5++
800068d4:	80 00       	ld.sh	r0,r0[0x0]
800068d6:	8f 44       	st.w	r7[0x10],r4

800068d8 <xcmp_exec_func>:
Description: Perform XCMP corresponding functions
Calls:   
Called By: xcmp_rx_process--task
*/
static void xcmp_exec_func(app_exec_t * exec, xcmp_fragment_t * xcmp)
{
800068d8:	eb cd 40 80 	pushm	r7,lr
800068dc:	1a 97       	mov	r7,sp
800068de:	20 2d       	sub	sp,8
800068e0:	ef 4c ff fc 	st.w	r7[-4],r12
800068e4:	ef 4b ff f8 	st.w	r7[-8],r11
	/*The message types*/
	switch(xcmp->xcmp_opcode & 0xF000)
800068e8:	ee f8 ff f8 	ld.w	r8,r7[-8]
800068ec:	90 08       	ld.sh	r8,r8[0x0]
800068ee:	5c 78       	castu.h	r8
800068f0:	e2 18 f0 00 	andl	r8,0xf000,COH
800068f4:	e0 48 80 00 	cp.w	r8,32768
800068f8:	c1 50       	breq	80006922 <xcmp_exec_func+0x4a>
800068fa:	e0 48 b0 00 	cp.w	r8,45056
800068fe:	c1 e0       	breq	8000693a <xcmp_exec_func+0x62>
80006900:	58 08       	cp.w	r8,0
80006902:	c2 91       	brne	80006954 <xcmp_exec_func+0x7c>
	{
		case XCMP_REQUEST:
			if(NULL != exec->xcmp_rx_req)
80006904:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006908:	70 08       	ld.w	r8,r8[0x0]
8000690a:	58 08       	cp.w	r8,0
8000690c:	c0 80       	breq	8000691c <xcmp_exec_func+0x44>
			{
				exec->xcmp_rx_req(xcmp);
8000690e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006912:	70 08       	ld.w	r8,r8[0x0]
80006914:	ee fc ff f8 	ld.w	r12,r7[-8]
80006918:	5d 18       	icall	r8
			{
				/*No function to register the request message*/
				/*send not supported opcode to radio */
				xcmp_opcode_not_supported();
			}
			break;
8000691a:	c1 d8       	rjmp	80006954 <xcmp_exec_func+0x7c>
			}
			else 
			{
				/*No function to register the request message*/
				/*send not supported opcode to radio */
				xcmp_opcode_not_supported();
8000691c:	f0 1f 00 10 	mcall	8000695c <xcmp_exec_func+0x84>
			}
			break;
80006920:	c1 a8       	rjmp	80006954 <xcmp_exec_func+0x7c>
			
		case XCMP_REPLY:		
			if(NULL != exec->xcmp_rx_reply)
80006922:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006926:	70 18       	ld.w	r8,r8[0x4]
80006928:	58 08       	cp.w	r8,0
8000692a:	c1 40       	breq	80006952 <xcmp_exec_func+0x7a>
			{
				exec->xcmp_rx_reply(xcmp);
8000692c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006930:	70 18       	ld.w	r8,r8[0x4]
80006932:	ee fc ff f8 	ld.w	r12,r7[-8]
80006936:	5d 18       	icall	r8
			}
			break;
80006938:	c0 e8       	rjmp	80006954 <xcmp_exec_func+0x7c>
			
		case XCMP_BRDCAST:	
			if(NULL != exec->xcmp_rx_brdcst)
8000693a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000693e:	70 28       	ld.w	r8,r8[0x8]
80006940:	58 08       	cp.w	r8,0
80006942:	c0 90       	breq	80006954 <xcmp_exec_func+0x7c>
			{
				exec->xcmp_rx_brdcst(xcmp);
80006944:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006948:	70 28       	ld.w	r8,r8[0x8]
8000694a:	ee fc ff f8 	ld.w	r12,r7[-8]
8000694e:	5d 18       	icall	r8
80006950:	c0 28       	rjmp	80006954 <xcmp_exec_func+0x7c>
		case XCMP_REPLY:		
			if(NULL != exec->xcmp_rx_reply)
			{
				exec->xcmp_rx_reply(xcmp);
			}
			break;
80006952:	d7 03       	nop
			break;
			
		default:
			break;
	}
}
80006954:	2f ed       	sub	sp,-8
80006956:	e3 cd 80 80 	ldm	sp++,r7,pc
8000695a:	00 00       	add	r0,r0
8000695c:	80 00       	ld.sh	r0,r0[0x0]
8000695e:	6b 44       	ld.w	r4,r5[0x50]

80006960 <xcmp_rx_process>:
Calls: xQueueReceive -- freertos
	xcmp_exec_func
Called By: task
*/
static void xcmp_rx_process(void * pvParameters)
{
80006960:	eb cd 40 80 	pushm	r7,lr
80006964:	1a 97       	mov	r7,sp
80006966:	fa cd 00 d4 	sub	sp,sp,212
8000696a:	ef 4c ff 2c 	st.w	r7[-212],r12
8000696e:	c0 28       	rjmp	80006972 <xcmp_rx_process+0x12>
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
		}

	}
80006970:	d7 03       	nop
	xcmp_fragment_t xcmp;
	xcmp_fragment_t * ptr;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//10ms
80006972:	4c 88       	lddpc	r8,80006a90 <xcmp_rx_process+0x130>
80006974:	70 08       	ld.w	r8,r8[0x0]
80006976:	ee cb 00 d0 	sub	r11,r7,208
8000697a:	30 09       	mov	r9,0
8000697c:	31 4a       	mov	r10,20
8000697e:	10 9c       	mov	r12,r8
80006980:	f0 1f 00 45 	mcall	80006a94 <xcmp_rx_process+0x134>
80006984:	18 98       	mov	r8,r12
80006986:	58 18       	cp.w	r8,1
80006988:	cf 41       	brne	80006970 <xcmp_rx_process+0x10>
		{									
			if(NULL == ptr)
8000698a:	ee f8 ff 30 	ld.w	r8,r7[-208]
8000698e:	58 08       	cp.w	r8,0
80006990:	c0 31       	brne	80006996 <xcmp_rx_process+0x36>
			{
				continue;
80006992:	d7 03       	nop
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
		}

	}
80006994:	ce fb       	rjmp	80006972 <xcmp_rx_process+0x12>
				continue;
			}
			
			//log("\n\r R_xcmp : %4x \n\r",ptr->xcmp_opcode);//log:R_xcmp	
						
			switch(ptr->xcmp_opcode & 0x0FFF)
80006996:	ee f8 ff 30 	ld.w	r8,r7[-208]
8000699a:	90 08       	ld.sh	r8,r8[0x0]
8000699c:	5c 78       	castu.h	r8
8000699e:	f1 d8 c0 0c 	bfextu	r8,r8,0x0,0xc
800069a2:	59 c8       	cp.w	r8,28
800069a4:	c2 70       	breq	800069f2 <xcmp_rx_process+0x92>
800069a6:	e0 89 00 07 	brgt	800069b4 <xcmp_rx_process+0x54>
800069aa:	58 e8       	cp.w	r8,14
800069ac:	c0 e0       	breq	800069c8 <xcmp_rx_process+0x68>
800069ae:	58 f8       	cp.w	r8,15
800069b0:	c1 30       	breq	800069d6 <xcmp_rx_process+0x76>
800069b2:	c3 58       	rjmp	80006a1c <xcmp_rx_process+0xbc>
800069b4:	e0 48 01 09 	cp.w	r8,265
800069b8:	c2 40       	breq	80006a00 <xcmp_rx_process+0xa0>
800069ba:	e0 48 01 0a 	cp.w	r8,266
800069be:	c2 80       	breq	80006a0e <xcmp_rx_process+0xae>
800069c0:	e0 48 00 2c 	cp.w	r8,44
800069c4:	c1 00       	breq	800069e4 <xcmp_rx_process+0x84>
800069c6:	c2 b8       	rjmp	80006a1c <xcmp_rx_process+0xbc>
			{
				case RADIO_STATUS:				
					xcmp_exec_func(&radio_status, ptr);
800069c8:	ee f8 ff 30 	ld.w	r8,r7[-208]
800069cc:	10 9b       	mov	r11,r8
800069ce:	4b 3c       	lddpc	r12,80006a98 <xcmp_rx_process+0x138>
800069d0:	f0 1f 00 33 	mcall	80006a9c <xcmp_rx_process+0x13c>
					break;
800069d4:	c5 58       	rjmp	80006a7e <xcmp_rx_process+0x11e>
					
				case VERSION_INFORMATION:
					xcmp_exec_func(&version_information, ptr);
800069d6:	ee f8 ff 30 	ld.w	r8,r7[-208]
800069da:	10 9b       	mov	r11,r8
800069dc:	4b 1c       	lddpc	r12,80006aa0 <xcmp_rx_process+0x140>
800069de:	f0 1f 00 30 	mcall	80006a9c <xcmp_rx_process+0x13c>
					break;
800069e2:	c4 e8       	rjmp	80006a7e <xcmp_rx_process+0x11e>
					
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
800069e4:	ee f8 ff 30 	ld.w	r8,r7[-208]
800069e8:	10 9b       	mov	r11,r8
800069ea:	4a fc       	lddpc	r12,80006aa4 <xcmp_rx_process+0x144>
800069ec:	f0 1f 00 2c 	mcall	80006a9c <xcmp_rx_process+0x13c>
					break;
800069f0:	c4 78       	rjmp	80006a7e <xcmp_rx_process+0x11e>
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
800069f2:	ee f8 ff 30 	ld.w	r8,r7[-208]
800069f6:	10 9b       	mov	r11,r8
800069f8:	4a cc       	lddpc	r12,80006aa8 <xcmp_rx_process+0x148>
800069fa:	f0 1f 00 29 	mcall	80006a9c <xcmp_rx_process+0x13c>
						, ptr);
					break;
800069fe:	c4 08       	rjmp	80006a7e <xcmp_rx_process+0x11e>
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
80006a00:	ee f8 ff 30 	ld.w	r8,r7[-208]
80006a04:	10 9b       	mov	r11,r8
80006a06:	4a ac       	lddpc	r12,80006aac <xcmp_rx_process+0x14c>
80006a08:	f0 1f 00 25 	mcall	80006a9c <xcmp_rx_process+0x13c>
					break;
80006a0c:	c3 98       	rjmp	80006a7e <xcmp_rx_process+0x11e>
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
80006a0e:	ee f8 ff 30 	ld.w	r8,r7[-208]
80006a12:	10 9b       	mov	r11,r8
80006a14:	4a 7c       	lddpc	r12,80006ab0 <xcmp_rx_process+0x150>
80006a16:	f0 1f 00 22 	mcall	80006a9c <xcmp_rx_process+0x13c>
					break;
80006a1a:	c3 28       	rjmp	80006a7e <xcmp_rx_process+0x11e>
					
				default:
				
					/*the xcmp message not in order list*/
					/*over the length of the list*/
					if((0x0400 != (ptr->xcmp_opcode & 0x0400)) 
80006a1c:	ee f8 ff 30 	ld.w	r8,r7[-208]
80006a20:	90 08       	ld.sh	r8,r8[0x0]
80006a22:	5c 78       	castu.h	r8
80006a24:	e2 18 04 00 	andl	r8,0x400,COH
80006a28:	c0 b0       	breq	80006a3e <xcmp_rx_process+0xde>
						|| (MAX_APP_FUNC <= (ptr->xcmp_opcode & 0x00FF))
80006a2a:	ee f8 ff 30 	ld.w	r8,r7[-208]
80006a2e:	90 08       	ld.sh	r8,r8[0x0]
80006a30:	5c 78       	castu.h	r8
80006a32:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
					
				default:
				
					/*the xcmp message not in order list*/
					/*over the length of the list*/
					if((0x0400 != (ptr->xcmp_opcode & 0x0400)) 
80006a36:	e0 48 00 68 	cp.w	r8,104
80006a3a:	e0 8a 00 0c 	brle	80006a52 <xcmp_rx_process+0xf2>
						|| (MAX_APP_FUNC <= (ptr->xcmp_opcode & 0x00FF))
					)
					{
						/*xcmp request*/
						if( XCMP_REQUEST == (ptr->xcmp_opcode & 0xF000))
80006a3e:	ee f8 ff 30 	ld.w	r8,r7[-208]
80006a42:	90 08       	ld.sh	r8,r8[0x0]
80006a44:	5c 78       	castu.h	r8
80006a46:	e2 18 f0 00 	andl	r8,0xf000,COH
80006a4a:	c1 91       	brne	80006a7c <xcmp_rx_process+0x11c>
						{
							/*send not supported opcode to raido */
							xcmp_opcode_not_supported();
80006a4c:	f0 1f 00 1a 	mcall	80006ab4 <xcmp_rx_process+0x154>
					
				default:
				
					/*the xcmp message not in order list*/
					/*over the length of the list*/
					if((0x0400 != (ptr->xcmp_opcode & 0x0400)) 
80006a50:	c1 78       	rjmp	80006a7e <xcmp_rx_process+0x11e>
							xcmp_opcode_not_supported();
						}
					}
					else
					{					
						xcmp_exec_func( &app_list[ptr->xcmp_opcode & 0x00FF]
80006a52:	ee fa ff 30 	ld.w	r10,r7[-208]
80006a56:	49 98       	lddpc	r8,80006ab8 <xcmp_rx_process+0x158>
80006a58:	70 0b       	ld.w	r11,r8[0x0]
80006a5a:	ee f8 ff 30 	ld.w	r8,r7[-208]
80006a5e:	90 08       	ld.sh	r8,r8[0x0]
80006a60:	5c 78       	castu.h	r8
80006a62:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
80006a66:	12 98       	mov	r8,r9
80006a68:	a1 78       	lsl	r8,0x1
80006a6a:	12 08       	add	r8,r9
80006a6c:	a3 68       	lsl	r8,0x2
80006a6e:	f6 08 00 08 	add	r8,r11,r8
80006a72:	14 9b       	mov	r11,r10
80006a74:	10 9c       	mov	r12,r8
80006a76:	f0 1f 00 0a 	mcall	80006a9c <xcmp_rx_process+0x13c>
80006a7a:	c0 28       	rjmp	80006a7e <xcmp_rx_process+0x11e>
					
				default:
				
					/*the xcmp message not in order list*/
					/*over the length of the list*/
					if((0x0400 != (ptr->xcmp_opcode & 0x0400)) 
80006a7c:	d7 03       	nop
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
80006a7e:	ee f9 ff 30 	ld.w	r9,r7[-208]
80006a82:	48 f8       	lddpc	r8,80006abc <xcmp_rx_process+0x15c>
80006a84:	70 08       	ld.w	r8,r8[0x0]
80006a86:	12 9b       	mov	r11,r9
80006a88:	10 9c       	mov	r12,r8
80006a8a:	f0 1f 00 0e 	mcall	80006ac0 <xcmp_rx_process+0x160>
		}

	}
80006a8e:	c7 2b       	rjmp	80006972 <xcmp_rx_process+0x12>
80006a90:	00 00       	add	r0,r0
80006a92:	0b 08       	ld.w	r8,r5++
80006a94:	80 00       	ld.sh	r0,r0[0x0]
80006a96:	91 50       	st.w	r8[0x14],r0
80006a98:	00 00       	add	r0,r0
80006a9a:	0b 0c       	ld.w	r12,r5++
80006a9c:	80 00       	ld.sh	r0,r0[0x0]
80006a9e:	68 d8       	ld.w	r8,r4[0x34]
80006aa0:	00 00       	add	r0,r0
80006aa2:	0b 18       	ld.sh	r8,r5++
80006aa4:	00 00       	add	r0,r0
80006aa6:	0b 24       	ld.uh	r4,r5++
80006aa8:	00 00       	add	r0,r0
80006aaa:	0b 30       	ld.ub	r0,r5++
80006aac:	00 00       	add	r0,r0
80006aae:	0b 3c       	ld.ub	r12,r5++
80006ab0:	00 00       	add	r0,r0
80006ab2:	0b 48       	ld.w	r8,--r5
80006ab4:	80 00       	ld.sh	r0,r0[0x0]
80006ab6:	6b 44       	ld.w	r4,r5[0x50]
80006ab8:	00 00       	add	r0,r0
80006aba:	53 18       	stdsp	sp[0xc4],r8
80006abc:	00 00       	add	r0,r0
80006abe:	0a 8c       	andn	r12,r5
80006ac0:	80 00       	ld.sh	r0,r0[0x0]
80006ac2:	64 c4       	ld.w	r4,r2[0x30]

80006ac4 <xcmp_init>:
	xQueueCreate -- freertos
	xTaskCreate -- freertos
Called By: main -- main.c
*/
void xcmp_init(void)
{
80006ac4:	eb cd 40 80 	pushm	r7,lr
80006ac8:	1a 97       	mov	r7,sp
	/*initialize the xnl*/
	xnl_init();
80006aca:	f0 1f 00 0f 	mcall	80006b04 <xcmp_init+0x40>
	
	/*register the xcmp function(callback function)*/
	xnl_register_xcmp_func( xcmp_rx );
80006ace:	48 fc       	lddpc	r12,80006b08 <xcmp_init+0x44>
80006ad0:	f0 1f 00 0f 	mcall	80006b0c <xcmp_init+0x48>
	
	/*initialize the queue*/
	//xcmp_frame_rx = xQueueCreate(10, sizeof(xcmp_fragment_t *));
	
	xcmp_frame_rx = xQueueCreate(20, sizeof(xcmp_fragment_t *));
80006ad4:	30 4b       	mov	r11,4
80006ad6:	31 4c       	mov	r12,20
80006ad8:	f0 1f 00 0e 	mcall	80006b10 <xcmp_init+0x4c>
80006adc:	18 99       	mov	r9,r12
80006ade:	48 e8       	lddpc	r8,80006b14 <xcmp_init+0x50>
80006ae0:	91 09       	st.w	r8[0x0],r9
	/*create task*/	
	/*this task is used to execute xcmp message*/
	xTaskCreate(
80006ae2:	48 eb       	lddpc	r11,80006b18 <xcmp_init+0x54>
80006ae4:	30 08       	mov	r8,0
80006ae6:	1a d8       	st.w	--sp,r8
80006ae8:	30 08       	mov	r8,0
80006aea:	1a d8       	st.w	--sp,r8
80006aec:	30 08       	mov	r8,0
80006aee:	1a d8       	st.w	--sp,r8
80006af0:	30 38       	mov	r8,3
80006af2:	30 09       	mov	r9,0
80006af4:	e0 6a 01 80 	mov	r10,384
80006af8:	48 9c       	lddpc	r12,80006b1c <xcmp_init+0x58>
80006afa:	f0 1f 00 0a 	mcall	80006b20 <xcmp_init+0x5c>
80006afe:	2f dd       	sub	sp,-12
	,  384
	,  NULL
	,  tskXCMP_PRIORITY
	,  NULL
	);
}
80006b00:	e3 cd 80 80 	ldm	sp++,r7,pc
80006b04:	80 00       	ld.sh	r0,r0[0x0]
80006b06:	75 50       	ld.w	r0,r10[0x54]
80006b08:	80 00       	ld.sh	r0,r0[0x0]
80006b0a:	68 78       	ld.w	r8,r4[0x1c]
80006b0c:	80 00       	ld.sh	r0,r0[0x0]
80006b0e:	72 44       	ld.w	r4,r9[0x10]
80006b10:	80 00       	ld.sh	r0,r0[0x0]
80006b12:	8e 2c       	ld.sh	r12,r7[0x4]
80006b14:	00 00       	add	r0,r0
80006b16:	0b 08       	ld.w	r8,r5++
80006b18:	80 00       	ld.sh	r0,r0[0x0]
80006b1a:	67 e4       	ld.w	r4,r3[0x78]
80006b1c:	80 00       	ld.sh	r0,r0[0x0]
80006b1e:	69 60       	ld.w	r0,r4[0x58]
80006b20:	80 00       	ld.sh	r0,r0[0x0]
80006b22:	96 9c       	ld.uh	r12,r11[0x2]

80006b24 <xcmp_register_app_list>:
Description: register the app list
Calls: 
Called By: app_init -- app.c
*/
void xcmp_register_app_list(void * list)
{
80006b24:	eb cd 40 80 	pushm	r7,lr
80006b28:	1a 97       	mov	r7,sp
80006b2a:	20 1d       	sub	sp,4
80006b2c:	ef 4c ff fc 	st.w	r7[-4],r12
	app_list = (app_exec_t *)list;
80006b30:	ee f9 ff fc 	ld.w	r9,r7[-4]
80006b34:	48 38       	lddpc	r8,80006b40 <xcmp_register_app_list+0x1c>
80006b36:	91 09       	st.w	r8[0x0],r9
}
80006b38:	2f fd       	sub	sp,-4
80006b3a:	e3 cd 80 80 	ldm	sp++,r7,pc
80006b3e:	00 00       	add	r0,r0
80006b40:	00 00       	add	r0,r0
80006b42:	53 18       	stdsp	sp[0xc4],r8

80006b44 <xcmp_opcode_not_supported>:
Description: register the app list
Calls: xcmp_tx
Called By:...
*/
void xcmp_opcode_not_supported( void )
{
80006b44:	eb cd 40 80 	pushm	r7,lr
80006b48:	1a 97       	mov	r7,sp
80006b4a:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REPLY;
80006b4e:	fe 78 80 00 	mov	r8,-32768
80006b52:	ef 58 ff 36 	st.h	r7[-202],r8
	
	/*The radio does not support this opcode.*/
	xcmp_farme.u8[0] = xcmp_Res_Opcode_Not_Supported;
80006b56:	30 38       	mov	r8,3
80006b58:	ef 68 ff 38 	st.b	r7[-200],r8
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, 1);
80006b5c:	ee c8 00 ca 	sub	r8,r7,202
80006b60:	30 1b       	mov	r11,1
80006b62:	10 9c       	mov	r12,r8
80006b64:	f0 1f 00 03 	mcall	80006b70 <xcmp_opcode_not_supported+0x2c>
}
80006b68:	2c dd       	sub	sp,-204
80006b6a:	e3 cd 80 80 	ldm	sp++,r7,pc
80006b6e:	00 00       	add	r0,r0
80006b70:	80 00       	ld.sh	r0,r0[0x0]
80006b72:	67 ec       	ld.w	r12,r3[0x78]

80006b74 <xcmp_DeviceInitializationStatus_request>:
Description: send device initialization status request
Calls: xcmp_tx
Called By:...
*/
void xcmp_DeviceInitializationStatus_request(void)
{
80006b74:	eb cd 40 80 	pushm	r7,lr
80006b78:	1a 97       	mov	r7,sp
80006b7a:	fa cd 00 d0 	sub	sp,sp,208
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
		
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_BRDCAST | DEVICE_INITIALIZATION_STATUS;
80006b7e:	fe 78 b4 00 	mov	r8,-19456
80006b82:	ef 58 ff 32 	st.h	r7[-206],r8
	
	/*point to xcmp payload*/
	DeviceInitializationStatus_brdcst_t * ptr 
						 = (DeviceInitializationStatus_brdcst_t *)xcmp_farme.u8;
80006b86:	ee c8 00 ce 	sub	r8,r7,206
80006b8a:	2f e8       	sub	r8,-2
80006b8c:	ef 48 ff fc 	st.w	r7[-4],r8
	
	/*xcmp version 8.1.0.5*///
	ptr->XCMPVersion[0] = 0x08;
80006b90:	ee f9 ff fc 	ld.w	r9,r7[-4]
80006b94:	30 88       	mov	r8,8
80006b96:	b2 88       	st.b	r9[0x0],r8
	ptr->XCMPVersion[1] = 0x01;
80006b98:	ee f9 ff fc 	ld.w	r9,r7[-4]
80006b9c:	30 18       	mov	r8,1
80006b9e:	b2 98       	st.b	r9[0x1],r8
	ptr->XCMPVersion[2] = 0x00;
80006ba0:	ee f9 ff fc 	ld.w	r9,r7[-4]
80006ba4:	30 08       	mov	r8,0
80006ba6:	b2 a8       	st.b	r9[0x2],r8
	ptr->XCMPVersion[3] = 0x05;
80006ba8:	ee f9 ff fc 	ld.w	r9,r7[-4]
80006bac:	30 58       	mov	r8,5
80006bae:	b2 b8       	st.b	r9[0x3],r8
	/*
	0x00:
	This is the message that the device sends at power up or after a reset. It 
	will give the initial status and capabilities for the device.
	*/
	ptr->DeviceInitType = 0x00;
80006bb0:	ee f9 ff fc 	ld.w	r9,r7[-4]
80006bb4:	30 08       	mov	r8,0
80006bb6:	b2 c8       	st.b	r9[0x4],r8
	types of devices may provide a set of services to the radio system, but do 
	not have the ability to be the master.
	
	0x07:OptionBoard,3rd party Option Board-based application.
	*/
	ptr->DeviceStatusInfo.DeviceType = 0x07;
80006bb8:	ee f9 ff fc 	ld.w	r9,r7[-4]
80006bbc:	30 78       	mov	r8,7
80006bbe:	b2 d8       	st.b	r9[0x5],r8
	
	/*Power Up Success, Device has powered up with no errors*/
	ptr->DeviceStatusInfo.DeviceStatus[0] = 0x00;
80006bc0:	ee f9 ff fc 	ld.w	r9,r7[-4]
80006bc4:	30 08       	mov	r8,0
80006bc6:	b2 e8       	st.b	r9[0x6],r8
	ptr->DeviceStatusInfo.DeviceStatus[1] = 0x00;
80006bc8:	ee f9 ff fc 	ld.w	r9,r7[-4]
80006bcc:	30 08       	mov	r8,0
80006bce:	b2 f8       	st.b	r9[0x7],r8
	
	/*
	This number is the size of the Device Descriptor data structure with a 
	maximum size not exceeding 255 bytes.
	*/
	ptr->DeviceStatusInfo.DeviceDescriptorSize = 0x00;
80006bd0:	ee f9 ff fc 	ld.w	r9,r7[-4]
80006bd4:	30 08       	mov	r8,0
80006bd6:	f3 68 00 08 	st.b	r9[8],r8
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme
80006bda:	ee c8 00 ce 	sub	r8,r7,206
80006bde:	30 9b       	mov	r11,9
80006be0:	10 9c       	mov	r12,r8
80006be2:	f0 1f 00 03 	mcall	80006bec <xcmp_DeviceInitializationStatus_request+0x78>
		, sizeof(DeviceInitializationStatus_brdcst_t) - MAX_DEVICE_DESC_SIZE);
}
80006be6:	2c cd       	sub	sp,-208
80006be8:	e3 cd 80 80 	ldm	sp++,r7,pc
80006bec:	80 00       	ld.sh	r0,r0[0x0]
80006bee:	67 ec       	ld.w	r12,r3[0x78]

80006bf0 <xcmp_IdleTestTone>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_IdleTestTone(void)
{
80006bf0:	eb cd 40 80 	pushm	r7,lr
80006bf4:	1a 97       	mov	r7,sp
80006bf6:	fa cd 00 d0 	sub	sp,sp,208
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | TONE_CONTROL;
80006bfa:	e0 68 04 09 	mov	r8,1033
80006bfe:	ef 58 ff 32 	st.h	r7[-206],r8
	
	/*point to xcmp payload*/
	ToneControl_req_t * ptr = (ToneControl_req_t *)xcmp_farme.u8;
80006c02:	ee c8 00 ce 	sub	r8,r7,206
80006c06:	2f e8       	sub	r8,-2
80006c08:	ef 48 ff fc 	st.w	r7[-4],r8
	
	/*Starts the specific tone*/	
	ptr->Function = Tone_Start;
80006c0c:	ee f9 ff fc 	ld.w	r9,r7[-4]
80006c10:	30 18       	mov	r8,1
80006c12:	b2 88       	st.b	r9[0x0],r8
	
	/*This tone shall be sounded when radio landed on a priority channel*/
	ptr->ToneIdentifier[0] = (Priority_Beep >> 8) & 0xFF;
80006c14:	ee f9 ff fc 	ld.w	r9,r7[-4]
80006c18:	30 08       	mov	r8,0
80006c1a:	b2 98       	st.b	r9[0x1],r8
	ptr->ToneIdentifier[1] = Priority_Beep & 0xFF;
80006c1c:	ee f9 ff fc 	ld.w	r9,r7[-4]
80006c20:	30 c8       	mov	r8,12
80006c22:	b2 a8       	st.b	r9[0x2],r8
	
	/*
	The alert tone is played according to any rules for alert tones, given the 
	current volume setting. Settings for this field are 8 to 255 (0x08 ?0xFF).
	*/
	ptr->ToneVolumeControl = Current_Volume;
80006c24:	ee f9 ff fc 	ld.w	r9,r7[-4]
80006c28:	30 08       	mov	r8,0
80006c2a:	b2 b8       	st.b	r9[0x3],r8
	
	/*clear reserved*/
	memset(ptr->Reserved, 0, 8);
80006c2c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006c30:	2f c8       	sub	r8,-4
80006c32:	30 8a       	mov	r10,8
80006c34:	30 0b       	mov	r11,0
80006c36:	10 9c       	mov	r12,r8
80006c38:	f0 1f 00 06 	mcall	80006c50 <xcmp_IdleTestTone+0x60>
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(ToneControl_req_t));
80006c3c:	ee c8 00 ce 	sub	r8,r7,206
80006c40:	30 cb       	mov	r11,12
80006c42:	10 9c       	mov	r12,r8
80006c44:	f0 1f 00 04 	mcall	80006c54 <xcmp_IdleTestTone+0x64>
}
80006c48:	2c cd       	sub	sp,-208
80006c4a:	e3 cd 80 80 	ldm	sp++,r7,pc
80006c4e:	00 00       	add	r0,r0
80006c50:	80 00       	ld.sh	r0,r0[0x0]
80006c52:	b6 aa       	st.b	r11[0x2],r10
80006c54:	80 00       	ld.sh	r0,r0[0x0]
80006c56:	67 ec       	ld.w	r12,r3[0x78]

80006c58 <xcmp_data_session>:
Description: send data-session request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_data_session(void)
{
80006c58:	eb cd 40 80 	pushm	r7,lr
80006c5c:	1a 97       	mov	r7,sp
80006c5e:	fa cd 00 d0 	sub	sp,sp,208
	//U8 *DMR_Raw_Data= &DataPayload[0];
	U8 i =0;
80006c62:	30 08       	mov	r8,0
80006c64:	ef 68 ff fb 	st.b	r7[-5],r8
	//U8 SizeofAddress = Remote_Mototrbo_Address_Size;// 3;//
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | AUDIO_DATA_REQUEST;
80006c68:	e0 68 04 1d 	mov	r8,1053
80006c6c:	ef 58 ff 30 	st.h	r7[-208],r8
	
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
80006c70:	ee c8 00 d0 	sub	r8,r7,208
80006c74:	2f e8       	sub	r8,-2
80006c76:	ef 48 ff fc 	st.w	r7[-4],r8
	//ptr->DataDefinition.Dest_Address.Remote_Address[3] = 0x02;//ID:2
	//
	//ptr->DataDefinition.Dest_Address.Remote_Port_Com[0] = (Remote_Port >>8) & 0xFF;//0x00
	//ptr->DataDefinition.Dest_Address.Remote_Port_Com[1] = Remote_Port & 0xFF;//0x00
	
	ptr->Function = Single_Data_Uint;//0x01
80006c7a:	ee f9 ff fc 	ld.w	r9,r7[-4]
80006c7e:	30 18       	mov	r8,1
80006c80:	b2 88       	st.b	r9[0x0],r8
	
	ptr->DataDefinition.Data_Protocol_Version = DMR_CSBK_Data;//0x70
80006c82:	ee f9 ff fc 	ld.w	r9,r7[-4]
80006c86:	37 08       	mov	r8,112
80006c88:	b2 98       	st.b	r9[0x1],r8
	
	ptr->DataDefinition.Dest_Address.Remote_Address_Type = Remote_Mototrbo_Address;//0x01
80006c8a:	ee f9 ff fc 	ld.w	r9,r7[-4]
80006c8e:	30 18       	mov	r8,1
80006c90:	b2 a8       	st.b	r9[0x2],r8
	
	ptr->DataDefinition.Dest_Address.Remote_Address_Size = Remote_Mototrbo_Address_Size;//0x03
80006c92:	ee f9 ff fc 	ld.w	r9,r7[-4]
80006c96:	30 38       	mov	r8,3
80006c98:	b2 b8       	st.b	r9[0x3],r8
	
	ptr->DataDefinition.Dest_Address.Remote_Address[0] = 0x00;
80006c9a:	ee f9 ff fc 	ld.w	r9,r7[-4]
80006c9e:	30 08       	mov	r8,0
80006ca0:	b2 c8       	st.b	r9[0x4],r8
	ptr->DataDefinition.Dest_Address.Remote_Address[1] = 0x00;
80006ca2:	ee f9 ff fc 	ld.w	r9,r7[-4]
80006ca6:	30 08       	mov	r8,0
80006ca8:	b2 d8       	st.b	r9[0x5],r8
	ptr->DataDefinition.Dest_Address.Remote_Address[2] = 0x02;//ID:2
80006caa:	ee f9 ff fc 	ld.w	r9,r7[-4]
80006cae:	30 28       	mov	r8,2
80006cb0:	b2 e8       	st.b	r9[0x6],r8
	
	ptr->DataDefinition.Dest_Address.Remote_Port_Com[0] = (Remote_Port >>8) & 0xFF;//0x00
80006cb2:	ee f9 ff fc 	ld.w	r9,r7[-4]
80006cb6:	34 08       	mov	r8,64
80006cb8:	b2 f8       	st.b	r9[0x7],r8
	ptr->DataDefinition.Dest_Address.Remote_Port_Com[1] = Remote_Port & 0xFF;//0x00
80006cba:	ee f9 ff fc 	ld.w	r9,r7[-4]
80006cbe:	36 18       	mov	r8,97
80006cc0:	f3 68 00 08 	st.b	r9[8],r8
	    ////
    ////}
	//
	
	//
	ptr->DataPayload.Session_ID_Number = Session_ID;//0x00
80006cc4:	ee f9 ff fc 	ld.w	r9,r7[-4]
80006cc8:	30 08       	mov	r8,0
80006cca:	f3 68 00 09 	st.b	r9[9],r8
	
	ptr->DataPayload.DataPayload_Length[0] =(sizeof(DataPayload) >> 8) & 0xFF ;//
80006cce:	ee f9 ff fc 	ld.w	r9,r7[-4]
80006cd2:	30 08       	mov	r8,0
80006cd4:	f3 68 00 0a 	st.b	r9[10],r8
	ptr->DataPayload.DataPayload_Length[1] =sizeof(DataPayload) & 0xFF  ;//
80006cd8:	ee f9 ff fc 	ld.w	r9,r7[-4]
80006cdc:	31 48       	mov	r8,20
80006cde:	f3 68 00 0b 	st.b	r9[11],r8
	
	for (i=0; i< sizeof(DataPayload) ; i++)
80006ce2:	30 08       	mov	r8,0
80006ce4:	ef 68 ff fb 	st.b	r7[-5],r8
80006ce8:	c1 38       	rjmp	80006d0e <xcmp_data_session+0xb6>
	{
	
		ptr->DataPayload.DataPayload[i] = DataPayload[i];//
80006cea:	ef 39 ff fb 	ld.ub	r9,r7[-5]
80006cee:	ef 38 ff fb 	ld.ub	r8,r7[-5]
80006cf2:	49 0a       	lddpc	r10,80006d30 <xcmp_data_session+0xd8>
80006cf4:	f4 08 07 08 	ld.ub	r8,r10[r8]
80006cf8:	ee fa ff fc 	ld.w	r10,r7[-4]
80006cfc:	f4 09 00 09 	add	r9,r10,r9
80006d00:	f3 68 00 0c 	st.b	r9[12],r8
	ptr->DataPayload.Session_ID_Number = Session_ID;//0x00
	
	ptr->DataPayload.DataPayload_Length[0] =(sizeof(DataPayload) >> 8) & 0xFF ;//
	ptr->DataPayload.DataPayload_Length[1] =sizeof(DataPayload) & 0xFF  ;//
	
	for (i=0; i< sizeof(DataPayload) ; i++)
80006d04:	ef 38 ff fb 	ld.ub	r8,r7[-5]
80006d08:	2f f8       	sub	r8,-1
80006d0a:	ef 68 ff fb 	st.b	r7[-5],r8
80006d0e:	ef 39 ff fb 	ld.ub	r9,r7[-5]
80006d12:	31 38       	mov	r8,19
80006d14:	f0 09 18 00 	cp.b	r9,r8
80006d18:	fe 98 ff e9 	brls	80006cea <xcmp_data_session+0x92>
		ptr->DataPayload.DataPayload[i] = DataPayload[i];//
		
	}
	
	/*send xcmp frame*///
	xcmp_tx( &xcmp_farme, sizeof(DataSession_req_t));
80006d1c:	ee c8 00 d0 	sub	r8,r7,208
80006d20:	32 0b       	mov	r11,32
80006d22:	10 9c       	mov	r12,r8
80006d24:	f0 1f 00 04 	mcall	80006d34 <xcmp_data_session+0xdc>
}
80006d28:	2c cd       	sub	sp,-208
80006d2a:	e3 cd 80 80 	ldm	sp++,r7,pc
80006d2e:	00 00       	add	r0,r0
80006d30:	00 00       	add	r0,r0
80006d32:	05 00       	ld.w	r0,r2++
80006d34:	80 00       	ld.sh	r0,r0[0x0]
80006d36:	67 ec       	ld.w	r12,r3[0x78]
80006d38:	63 6f       	ld.w	pc,r1[0x58]
80006d3a:	6e 6e       	ld.w	lr,r7[0x18]
80006d3c:	65 63       	ld.w	r3,r2[0x58]
80006d3e:	74 65       	ld.w	r5,r10[0x18]
80006d40:	64 20       	ld.w	r0,r2[0x8]
80006d42:	66 69       	ld.w	r9,r3[0x18]
80006d44:	6e 69       	ld.w	r9,r7[0x18]
80006d46:	73 68       	ld.w	r8,r9[0x58]
80006d48:	00 00       	add	r0,r0
80006d4a:	00 00       	add	r0,r0
80006d4c:	58 4e       	cp.w	lr,4
80006d4e:	4c 5f       	lddpc	pc,80006e60 <check_sum+0x58>
80006d50:	52 58       	stdsp	sp[0x94],r8
80006d52:	00 00       	add	r0,r0
80006d54:	58 4e       	cp.w	lr,4
80006d56:	4c 5f       	lddpc	pc,80006e68 <check_sum+0x60>
80006d58:	54 58       	stdsp	sp[0x114],r8
	...

80006d5c <encipher>:
Calls:   
Called By: xnl_device_auth_reply_func
Output: U32 *const w
*/
static void encipher(U32 *const v, U32 *const w, const U32 *const k)
{
80006d5c:	eb cd 40 ef 	pushm	r0-r3,r5-r7,lr
80006d60:	1a 97       	mov	r7,sp
80006d62:	20 4d       	sub	sp,16
80006d64:	ef 4c ff fc 	st.w	r7[-4],r12
80006d68:	ef 4b ff f8 	st.w	r7[-8],r11
80006d6c:	ef 4a ff f4 	st.w	r7[-12],r10
	register U32 y=v[0], z=v[1], sum=0;
80006d70:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006d74:	70 06       	ld.w	r6,r8[0x0]
80006d76:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006d7a:	2f c8       	sub	r8,-4
80006d7c:	70 0e       	ld.w	lr,r8[0x0]
80006d7e:	30 05       	mov	r5,0
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
80006d80:	ee f8 ff f4 	ld.w	r8,r7[-12]
80006d84:	70 08       	ld.w	r8,r8[0x0]
80006d86:	ef 48 ff f0 	st.w	r7[-16],r8
80006d8a:	ee f8 ff f4 	ld.w	r8,r7[-12]
80006d8e:	2f c8       	sub	r8,-4
80006d90:	70 00       	ld.w	r0,r8[0x0]
80006d92:	ee f8 ff f4 	ld.w	r8,r7[-12]
80006d96:	2f 88       	sub	r8,-8
80006d98:	70 01       	ld.w	r1,r8[0x0]
80006d9a:	ee f8 ff f4 	ld.w	r8,r7[-12]
80006d9e:	2f 48       	sub	r8,-12
80006da0:	70 02       	ld.w	r2,r8[0x0]
	register U32 n=32;
80006da2:	32 03       	mov	r3,32

	while(n-->0)
80006da4:	c2 08       	rjmp	80006de4 <encipher+0x88>
	{
		sum += authDelta;		
80006da6:	49 88       	lddpc	r8,80006e04 <encipher+0xa8>
80006da8:	70 08       	ld.w	r8,r8[0x0]
80006daa:	10 05       	add	r5,r8
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
80006dac:	fc 08 15 04 	lsl	r8,lr,0x4
80006db0:	ee fa ff f0 	ld.w	r10,r7[-16]
80006db4:	f0 0a 00 09 	add	r9,r8,r10
80006db8:	fc 05 00 08 	add	r8,lr,r5
80006dbc:	10 59       	eor	r9,r8
80006dbe:	fc 08 16 05 	lsr	r8,lr,0x5
80006dc2:	00 08       	add	r8,r0
80006dc4:	f3 e8 20 08 	eor	r8,r9,r8
80006dc8:	10 06       	add	r6,r8
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
80006dca:	ec 08 15 04 	lsl	r8,r6,0x4
80006dce:	f0 01 00 09 	add	r9,r8,r1
80006dd2:	ec 05 00 08 	add	r8,r6,r5
80006dd6:	10 59       	eor	r9,r8
80006dd8:	ec 08 16 05 	lsr	r8,r6,0x5
80006ddc:	04 08       	add	r8,r2
80006dde:	f3 e8 20 08 	eor	r8,r9,r8
80006de2:	10 0e       	add	lr,r8
{
	register U32 y=v[0], z=v[1], sum=0;
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
80006de4:	58 03       	cp.w	r3,0
80006de6:	5f 18       	srne	r8
80006de8:	5c 58       	castu.b	r8
80006dea:	20 13       	sub	r3,1
80006dec:	58 08       	cp.w	r8,0
80006dee:	cd c1       	brne	80006da6 <encipher+0x4a>
		sum += authDelta;		
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
	}

	w[0]=y; w[1]=z;
80006df0:	ee f8 ff f8 	ld.w	r8,r7[-8]
80006df4:	91 06       	st.w	r8[0x0],r6
80006df6:	ee f8 ff f8 	ld.w	r8,r7[-8]
80006dfa:	2f c8       	sub	r8,-4
80006dfc:	91 0e       	st.w	r8[0x0],lr
}
80006dfe:	2f cd       	sub	sp,-16
80006e00:	e3 cd 80 ef 	ldm	sp++,r0-r3,r5-r7,pc
80006e04:	80 01       	ld.sh	r1,r0[0x0]
80006e06:	12 60       	and	r0,r9

80006e08 <check_sum>:
Calls:   
Called By: xnl_tx
Return:U16
*/
static U16 check_sum (xnl_fragment_t * xnl)
{
80006e08:	eb cd 40 80 	pushm	r7,lr
80006e0c:	1a 97       	mov	r7,sp
80006e0e:	20 4d       	sub	sp,16
80006e10:	ef 4c ff f0 	st.w	r7[-16],r12
	*/	
	U16  sumScratch;
	U32  indextohWord;
	S32  hWordswithinFrag;
	
	sumScratch = 0;
80006e14:	30 08       	mov	r8,0
80006e16:	ef 58 ff f6 	st.h	r7[-10],r8
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
80006e1a:	ee f8 ff f0 	ld.w	r8,r7[-16]
80006e1e:	90 08       	ld.sh	r8,r8[0x0]
80006e20:	5c 78       	castu.h	r8
80006e22:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
80006e26:	20 28       	sub	r8,2
80006e28:	ef 48 ff fc 	st.w	r7[-4],r8
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
80006e2c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006e30:	f3 d8 c0 01 	bfextu	r9,r8,0x0,0x1
80006e34:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006e38:	f2 08 00 08 	add	r8,r9,r8
80006e3c:	a1 58       	asr	r8,0x1
80006e3e:	ef 48 ff fc 	st.w	r7[-4],r8
	indextohWord = 2;
80006e42:	30 28       	mov	r8,2
80006e44:	ef 48 ff f8 	st.w	r7[-8],r8
	while (hWordswithinFrag > 0)
80006e48:	c1 98       	rjmp	80006e7a <check_sum+0x72>
	{
		sumScratch += *((U16*)xnl + indextohWord);
80006e4a:	ee f9 ff f0 	ld.w	r9,r7[-16]
80006e4e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80006e52:	a1 78       	lsl	r8,0x1
80006e54:	f2 08 00 08 	add	r8,r9,r8
80006e58:	90 08       	ld.sh	r8,r8[0x0]
80006e5a:	ef 09 ff f6 	ld.sh	r9,r7[-10]
80006e5e:	f2 08 00 08 	add	r8,r9,r8
80006e62:	ef 58 ff f6 	st.h	r7[-10],r8
		indextohWord     += 1;
80006e66:	ee f8 ff f8 	ld.w	r8,r7[-8]
80006e6a:	2f f8       	sub	r8,-1
80006e6c:	ef 48 ff f8 	st.w	r7[-8],r8
		hWordswithinFrag -= 1;
80006e70:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006e74:	20 18       	sub	r8,1
80006e76:	ef 48 ff fc 	st.w	r7[-4],r8
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
80006e7a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006e7e:	58 08       	cp.w	r8,0
80006e80:	fe 99 ff e5 	brgt	80006e4a <check_sum+0x42>
		sumScratch += *((U16*)xnl + indextohWord);
		indextohWord     += 1;
		hWordswithinFrag -= 1;
	}
	
	return -sumScratch;
80006e84:	ef 08 ff f6 	ld.sh	r8,r7[-10]
80006e88:	5c 38       	neg	r8
80006e8a:	5c 88       	casts.h	r8
}
80006e8c:	10 9c       	mov	r12,r8
80006e8e:	2f cd       	sub	sp,-16
80006e90:	e3 cd 80 80 	ldm	sp++,r7,pc

80006e94 <xnl_send_device_master_query>:
Description: send device_master_query to connect radio.
Calls:xnl_tx
Call By:xnl_init
*/
static void xnl_send_device_master_query(void)
{
80006e94:	eb cd 40 80 	pushm	r7,lr
80006e98:	1a 97       	mov	r7,sp
80006e9a:	fa cd 01 00 	sub	sp,sp,256
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80006e9e:	e0 68 40 0e 	mov	r8,16398
80006ea2:	ef 58 ff 00 	st.h	r7[-256],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80006ea6:	3f f8       	mov	r8,-1
80006ea8:	ef 58 ff 02 	st.h	r7[-254],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_MASTER_QUERY;
80006eac:	30 38       	mov	r8,3
80006eae:	ef 58 ff 04 	st.h	r7[-252],r8
	
	/*The initial value*/
	xnl_frame.xnl_header.flags = 0;
80006eb2:	30 08       	mov	r8,0
80006eb4:	ef 58 ff 06 	st.h	r7[-250],r8
	
	/*XNL address of the master device, if known;otherwise 0x0000*/
	xnl_frame.xnl_header.destination = 0;
80006eb8:	30 08       	mov	r8,0
80006eba:	ef 58 ff 08 	st.h	r7[-248],r8
	
	/*XNL address, if assigned; otherwise 0x0000*/
	xnl_frame.xnl_header.source = 0;
80006ebe:	30 08       	mov	r8,0
80006ec0:	ef 58 ff 0a 	st.h	r7[-246],r8
	
	/*No transaction ID required for this message*/
	xnl_frame.xnl_header.transaction_id = 0;
80006ec4:	30 08       	mov	r8,0
80006ec6:	ef 58 ff 0c 	st.h	r7[-244],r8
	
	/*This message contains no payload*/
	xnl_frame.xnl_header.payload_length = 0;
80006eca:	30 08       	mov	r8,0
80006ecc:	ef 58 ff 0e 	st.h	r7[-242],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
80006ed0:	ee c8 01 00 	sub	r8,r7,256
80006ed4:	10 9c       	mov	r12,r8
80006ed6:	f0 1f 00 03 	mcall	80006ee0 <xnl_send_device_master_query+0x4c>
}
80006eda:	2c 0d       	sub	sp,-256
80006edc:	e3 cd 80 80 	ldm	sp++,r7,pc
80006ee0:	80 00       	ld.sh	r0,r0[0x0]
80006ee2:	72 64       	ld.w	r4,r9[0x18]

80006ee4 <xnl_master_status_brdcst_func>:
Description: process while receive master status boardcast.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_master_status_brdcst_func(xnl_fragment_t * xnl)
{	
80006ee4:	eb cd 40 80 	pushm	r7,lr
80006ee8:	1a 97       	mov	r7,sp
80006eea:	fa cd 01 04 	sub	sp,sp,260
80006eee:	ef 4c fe fc 	st.w	r7[-260],r12
	not an XNL_DATA_MSG has been sent out. This will indicate to a connecting 
	device that it has missed messages. The XNL header will contain the 
	master?XNL address. 5.4.1
	*/
	
	if(xnl_information.is_connected)
80006ef2:	49 c8       	lddpc	r8,80006f60 <xnl_master_status_brdcst_func+0x7c>
80006ef4:	11 88       	ld.ub	r8,r8[0x0]
80006ef6:	5c 58       	castu.b	r8
80006ef8:	c2 f1       	brne	80006f56 <xnl_master_status_brdcst_func+0x72>
	{
		return;	
	}
		
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);	
80006efa:	49 b8       	lddpc	r8,80006f64 <xnl_master_status_brdcst_func+0x80>
80006efc:	70 08       	ld.w	r8,r8[0x0]
80006efe:	30 09       	mov	r9,0
80006f00:	30 0a       	mov	r10,0
80006f02:	30 0b       	mov	r11,0
80006f04:	10 9c       	mov	r12,r8
80006f06:	f0 1f 00 19 	mcall	80006f68 <xnl_master_status_brdcst_func+0x84>

	//log("xnl-ma:%4x", xnl->xnl_header.source);
	/*get the master adderss from this message*/	
	xnl_information.master_address = xnl->xnl_header.source;	
80006f0a:	ee f8 fe fc 	ld.w	r8,r7[-260]
80006f0e:	90 58       	ld.sh	r8,r8[0xa]
80006f10:	49 49       	lddpc	r9,80006f60 <xnl_master_status_brdcst_func+0x7c>
80006f12:	b2 18       	st.h	r9[0x2],r8
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80006f14:	e0 68 40 0e 	mov	r8,16398
80006f18:	ef 58 ff 00 	st.h	r7[-256],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80006f1c:	3f f8       	mov	r8,-1
80006f1e:	ef 58 ff 02 	st.h	r7[-254],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_AUTH_KEY_REQUEST;
80006f22:	30 48       	mov	r8,4
80006f24:	ef 58 ff 04 	st.h	r7[-252],r8
		
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/	
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
80006f28:	3f f8       	mov	r8,-1
80006f2a:	ef 58 ff 06 	st.h	r7[-250],r8
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
80006f2e:	48 d8       	lddpc	r8,80006f60 <xnl_master_status_brdcst_func+0x7c>
80006f30:	90 18       	ld.sh	r8,r8[0x2]
80006f32:	5c 88       	casts.h	r8
80006f34:	ef 58 ff 08 	st.h	r7[-248],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.source = DEFAULT_VALUE;
80006f38:	3f f8       	mov	r8,-1
80006f3a:	ef 58 ff 0a 	st.h	r7[-246],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80006f3e:	3f f8       	mov	r8,-1
80006f40:	ef 58 ff 0c 	st.h	r7[-244],r8
		
	xnl_frame.xnl_header.payload_length = 0;
80006f44:	30 08       	mov	r8,0
80006f46:	ef 58 ff 0e 	st.h	r7[-242],r8
	
	/*send XNL message*/	
	xnl_tx(&xnl_frame);
80006f4a:	ee c8 01 00 	sub	r8,r7,256
80006f4e:	10 9c       	mov	r12,r8
80006f50:	f0 1f 00 07 	mcall	80006f6c <xnl_master_status_brdcst_func+0x88>
80006f54:	c0 28       	rjmp	80006f58 <xnl_master_status_brdcst_func+0x74>
	master?XNL address. 5.4.1
	*/
	
	if(xnl_information.is_connected)
	{
		return;	
80006f56:	d7 03       	nop
		
	xnl_frame.xnl_header.payload_length = 0;
	
	/*send XNL message*/	
	xnl_tx(&xnl_frame);
}
80006f58:	2b fd       	sub	sp,-260
80006f5a:	e3 cd 80 80 	ldm	sp++,r7,pc
80006f5e:	00 00       	add	r0,r0
80006f60:	00 00       	add	r0,r0
80006f62:	0b 54       	ld.sh	r4,--r5
80006f64:	00 00       	add	r0,r0
80006f66:	0b 68       	ld.uh	r8,--r5
80006f68:	80 00       	ld.sh	r0,r0[0x0]
80006f6a:	8f 44       	st.w	r7[0x10],r4
80006f6c:	80 00       	ld.sh	r0,r0[0x0]
80006f6e:	72 64       	ld.w	r4,r9[0x18]

80006f70 <xnl_device_auth_reply_func>:
Description: process while receive device auth reply.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_auth_reply_func(xnl_fragment_t * xnl)
{
80006f70:	eb cd 40 80 	pushm	r7,lr
80006f74:	1a 97       	mov	r7,sp
80006f76:	fa cd 01 14 	sub	sp,sp,276
80006f7a:	ef 4c fe ec 	st.w	r7[-276],r12
	the receiving device and will be used to authenticate the connection 
	request. 5.4.4
	*/
	//log("R_xnl-opcode:%4x", xnl->xnl_header.opcode);
	
	if(xnl_information.is_connected)
80006f7e:	4c 78       	lddpc	r8,80007098 <xnl_device_auth_reply_func+0x128>
80006f80:	11 88       	ld.ub	r8,r8[0x0]
80006f82:	5c 58       	castu.b	r8
80006f84:	e0 81 00 86 	brne	80007090 <xnl_device_auth_reply_func+0x120>
	{
		return;		
	}
	
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);
80006f88:	4c 58       	lddpc	r8,8000709c <xnl_device_auth_reply_func+0x12c>
80006f8a:	70 08       	ld.w	r8,r8[0x0]
80006f8c:	30 09       	mov	r9,0
80006f8e:	30 0a       	mov	r10,0
80006f90:	30 0b       	mov	r11,0
80006f92:	10 9c       	mov	r12,r8
80006f94:	f0 1f 00 43 	mcall	800070a0 <xnl_device_auth_reply_func+0x130>

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
80006f98:	ee f8 fe ec 	ld.w	r8,r7[-276]
80006f9c:	f1 08 00 10 	ld.sh	r8,r8[16]
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
80006fa0:	4b e9       	lddpc	r9,80007098 <xnl_device_auth_reply_func+0x128>
80006fa2:	b2 28       	st.h	r9[0x4],r8
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
	
	/*Get Array of values to be encrypted into an aligned 2X32bits.*/
	v_vector[0] =
	  (xnl->xnl_payload.xnl_content_device_auth_key_reply
80006fa4:	ee f8 fe ec 	ld.w	r8,r7[-276]
80006fa8:	f1 38 00 12 	ld.ub	r8,r8[18]
	  .unencrypted_authentication_value[0])<<24	  
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
80006fac:	f0 09 15 18 	lsl	r9,r8,0x18
80006fb0:	ee f8 fe ec 	ld.w	r8,r7[-276]
80006fb4:	f1 38 00 13 	ld.ub	r8,r8[19]
	  .unencrypted_authentication_value[1])<<16	  
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
80006fb8:	b1 68       	lsl	r8,0x10
80006fba:	10 49       	or	r9,r8
80006fbc:	ee f8 fe ec 	ld.w	r8,r7[-276]
80006fc0:	f1 38 00 14 	ld.ub	r8,r8[20]
	  .unencrypted_authentication_value[2])<<8	  
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
80006fc4:	a9 68       	lsl	r8,0x8
80006fc6:	10 49       	or	r9,r8
80006fc8:	ee f8 fe ec 	ld.w	r8,r7[-276]
80006fcc:	f1 38 00 15 	ld.ub	r8,r8[21]
	xnl_information.device_address = 
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
	
	/*Get Array of values to be encrypted into an aligned 2X32bits.*/
	v_vector[0] =
	  (xnl->xnl_payload.xnl_content_device_auth_key_reply
80006fd0:	f3 e8 10 08 	or	r8,r9,r8
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
	
	/*Get Array of values to be encrypted into an aligned 2X32bits.*/
	v_vector[0] =
80006fd4:	ef 48 ff f8 	st.w	r7[-8],r8
	  .unencrypted_authentication_value[2])<<8	  
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[3]);
	
	v_vector[1] =
	  (xnl->xnl_payload.xnl_content_device_auth_key_reply
80006fd8:	ee f8 fe ec 	ld.w	r8,r7[-276]
80006fdc:	f1 38 00 16 	ld.ub	r8,r8[22]
	  .unencrypted_authentication_value[4])<<24
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
80006fe0:	f0 09 15 18 	lsl	r9,r8,0x18
80006fe4:	ee f8 fe ec 	ld.w	r8,r7[-276]
80006fe8:	f1 38 00 17 	ld.ub	r8,r8[23]
	   .unencrypted_authentication_value[5])<<16
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
80006fec:	b1 68       	lsl	r8,0x10
80006fee:	10 49       	or	r9,r8
80006ff0:	ee f8 fe ec 	ld.w	r8,r7[-276]
80006ff4:	f1 38 00 18 	ld.ub	r8,r8[24]
	   .unencrypted_authentication_value[6])<<8
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
80006ff8:	a9 68       	lsl	r8,0x8
80006ffa:	10 49       	or	r9,r8
80006ffc:	ee f8 fe ec 	ld.w	r8,r7[-276]
80007000:	f1 38 00 19 	ld.ub	r8,r8[25]
	  .unencrypted_authentication_value[2])<<8	  
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[3]);
	
	v_vector[1] =
	  (xnl->xnl_payload.xnl_content_device_auth_key_reply
80007004:	f3 e8 10 08 	or	r8,r9,r8
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[2])<<8	  
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[3]);
	
	v_vector[1] =
80007008:	ef 48 ff fc 	st.w	r7[-4],r8
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	   .unencrypted_authentication_value[6])<<8
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	   .unencrypted_authentication_value[7]);
	
	encipher(&v_vector[0], &w_vector[0], &authKey[0]);
8000700c:	ee c9 00 10 	sub	r9,r7,16
80007010:	ee c8 00 08 	sub	r8,r7,8
80007014:	4a 4a       	lddpc	r10,800070a4 <xnl_device_auth_reply_func+0x134>
80007016:	12 9b       	mov	r11,r9
80007018:	10 9c       	mov	r12,r8
8000701a:	f0 1f 00 24 	mcall	800070a8 <xnl_device_auth_reply_func+0x138>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :24 + 2(xnl length(24) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 24 + 2;
8000701e:	e0 68 40 1a 	mov	r8,16410
80007022:	ef 58 fe f0 	st.h	r7[-272],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80007026:	3f f8       	mov	r8,-1
80007028:	ef 58 fe f2 	st.h	r7[-270],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_CONN_REQUEST;
8000702c:	30 68       	mov	r8,6
8000702e:	ef 58 fe f4 	st.h	r7[-268],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
80007032:	3f f8       	mov	r8,-1
80007034:	ef 58 fe f6 	st.h	r7[-266],r8
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
80007038:	49 88       	lddpc	r8,80007098 <xnl_device_auth_reply_func+0x128>
8000703a:	90 18       	ld.sh	r8,r8[0x2]
8000703c:	5c 88       	casts.h	r8
8000703e:	ef 58 fe f8 	st.h	r7[-264],r8
	message here, and all will receive the same DEVICE_CONN_REPLY. Not real 
	sure what's going to happen with multiple conrol heads, etc. One suspects 
	the Rocket Scientists will eventually figure this out, and demand a 
	transaction ID based on Device Type in the XNL_DEVICE_AUTH_KEY_REQUEST.
	*/
	xnl_frame.xnl_header.source = xnl_information.device_address;
80007042:	49 68       	lddpc	r8,80007098 <xnl_device_auth_reply_func+0x128>
80007044:	90 28       	ld.sh	r8,r8[0x4]
80007046:	5c 88       	casts.h	r8
80007048:	ef 58 fe fa 	st.h	r7[-262],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
8000704c:	3f f8       	mov	r8,-1
8000704e:	ef 58 fe fc 	st.h	r7[-260],r8
	
    /*his message contains 12 payload bytes*/	
	xnl_frame.xnl_header.payload_length = 0x000C;
80007052:	30 c8       	mov	r8,12
80007054:	ef 58 fe fe 	st.h	r7[-258],r8
	
	/*No Preferred XNL Address*/
	xnl_frame.xnl_payload.xnl_content_device_conn_req.preferred_xnl_address = 
80007058:	30 08       	mov	r8,0
8000705a:	ef 58 ff 00 	st.h	r7[-256],r8
	XCMP/XNL Development Specification Section 4.5.3.2.1.
	Same as in MOTOTRBO?XCMP/XNL Development Specification?
	evice_type--Option Board(0x07)
	authentication_index--Option Board(0x02)
	*/	
	xnl_frame.xnl_payload.xnl_content_device_conn_req.device_type = 0x07;
8000705e:	30 78       	mov	r8,7
80007060:	ef 68 ff 02 	st.b	r7[-254],r8
	xnl_frame.xnl_payload.xnl_content_device_conn_req.authentication_index =
80007064:	30 28       	mov	r8,2
80007066:	ef 68 ff 03 	st.b	r7[-253],r8
	                                                                       0x02;
		
	//We know encrypted array happens to be aligned to 32-bit boundary.
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
8000706a:	ee c8 01 10 	sub	r8,r7,272
8000706e:	2e c8       	sub	r8,-20
	                         .encrypted_authentication_value[0])) = w_vector[0];
80007070:	ee f9 ff f0 	ld.w	r9,r7[-16]
	xnl_frame.xnl_payload.xnl_content_device_conn_req.device_type = 0x07;
	xnl_frame.xnl_payload.xnl_content_device_conn_req.authentication_index =
	                                                                       0x02;
		
	//We know encrypted array happens to be aligned to 32-bit boundary.
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
80007074:	91 09       	st.w	r8[0x0],r9
	                         .encrypted_authentication_value[0])) = w_vector[0];
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
80007076:	ee c8 01 10 	sub	r8,r7,272
8000707a:	2e c8       	sub	r8,-20
8000707c:	2f c8       	sub	r8,-4
	                         .encrypted_authentication_value[4])) = w_vector[1];
8000707e:	ee f9 ff f4 	ld.w	r9,r7[-12]
	                                                                       0x02;
		
	//We know encrypted array happens to be aligned to 32-bit boundary.
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
	                         .encrypted_authentication_value[0])) = w_vector[0];
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
80007082:	91 09       	st.w	r8[0x0],r9
	                         .encrypted_authentication_value[4])) = w_vector[1];
	
	/*send XNL message*/
	xnl_tx(&xnl_frame);
80007084:	ee c8 01 10 	sub	r8,r7,272
80007088:	10 9c       	mov	r12,r8
8000708a:	f0 1f 00 09 	mcall	800070ac <xnl_device_auth_reply_func+0x13c>
8000708e:	c0 28       	rjmp	80007092 <xnl_device_auth_reply_func+0x122>
	*/
	//log("R_xnl-opcode:%4x", xnl->xnl_header.opcode);
	
	if(xnl_information.is_connected)
	{
		return;		
80007090:	d7 03       	nop
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
	                         .encrypted_authentication_value[4])) = w_vector[1];
	
	/*send XNL message*/
	xnl_tx(&xnl_frame);
}
80007092:	2b bd       	sub	sp,-276
80007094:	e3 cd 80 80 	ldm	sp++,r7,pc
80007098:	00 00       	add	r0,r0
8000709a:	0b 54       	ld.sh	r4,--r5
8000709c:	00 00       	add	r0,r0
8000709e:	0b 68       	ld.uh	r8,--r5
800070a0:	80 00       	ld.sh	r0,r0[0x0]
800070a2:	8f 44       	st.w	r7[0x10],r4
800070a4:	80 01       	ld.sh	r1,r0[0x0]
800070a6:	12 50       	eor	r0,r9
800070a8:	80 00       	ld.sh	r0,r0[0x0]
800070aa:	6d 5c       	ld.w	r12,r6[0x54]
800070ac:	80 00       	ld.sh	r0,r0[0x0]
800070ae:	72 64       	ld.w	r4,r9[0x18]

800070b0 <xnl_device_conn_reply_func>:
Description: process while receive device conn reply.
Calls:xSemaphoreGive--freestos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_conn_reply_func(xnl_fragment_t * xnl)
{
800070b0:	eb cd 40 80 	pushm	r7,lr
800070b4:	1a 97       	mov	r7,sp
800070b6:	20 1d       	sub	sp,4
800070b8:	ef 4c ff fc 	st.w	r7[-4],r12
	transaction ID and an 8-byte encrypted value that the device can use to 
	authenticate the master. XCMP/XNL Development Guide 5.4.6
	*/
	
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);
800070bc:	49 b8       	lddpc	r8,80007128 <xnl_device_conn_reply_func+0x78>
800070be:	70 08       	ld.w	r8,r8[0x0]
800070c0:	30 09       	mov	r9,0
800070c2:	30 0a       	mov	r10,0
800070c4:	30 0b       	mov	r11,0
800070c6:	10 9c       	mov	r12,r8
800070c8:	f0 1f 00 19 	mcall	8000712c <xnl_device_conn_reply_func+0x7c>

	/*Test result code*/
	if((xnl->xnl_payload.xnl_content_device_conn_reply.result_base & 0x0000FF00)
800070cc:	ee f8 ff fc 	ld.w	r8,r7[-4]
800070d0:	f1 08 00 10 	ld.sh	r8,r8[16]
800070d4:	5c 78       	castu.h	r8
800070d6:	e2 18 ff 00 	andl	r8,0xff00,COH
800070da:	e0 48 01 00 	cp.w	r8,256
800070de:	c0 60       	breq	800070ea <xnl_device_conn_reply_func+0x3a>
		/*
		Rejected. The device must retry the authentication process at this 
		point by sending out a new AUTH_KEY_REQUEST message. XCMP/XNL 
		Development Guide Section 5.2.3
		*/
		xnl_master_status_brdcst_func(xnl);			
800070e0:	ee fc ff fc 	ld.w	r12,r7[-4]
800070e4:	f0 1f 00 13 	mcall	80007130 <xnl_device_conn_reply_func+0x80>
800070e8:	c1 c8       	rjmp	80007120 <xnl_device_conn_reply_func+0x70>
	}
	else
	{
		/*connection accepted*/		
		/*Record Transaction ID Base*/
		xnl_information.transaction_id =  
800070ea:	ee f8 ff fc 	ld.w	r8,r7[-4]
800070ee:	f1 08 00 10 	ld.sh	r8,r8[16]
800070f2:	5c 78       	castu.h	r8
800070f4:	a9 68       	lsl	r8,0x8
800070f6:	5c 88       	casts.h	r8
800070f8:	48 f9       	lddpc	r9,80007134 <xnl_device_conn_reply_func+0x84>
800070fa:	b2 48       	st.h	r9[0x8],r8
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
800070fc:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007100:	f1 08 00 14 	ld.sh	r8,r8[20]
		xnl_information.transaction_id =  
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
80007104:	48 c9       	lddpc	r9,80007134 <xnl_device_conn_reply_func+0x84>
80007106:	b2 38       	st.h	r9[0x6],r8
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
80007108:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000710c:	f1 08 00 12 	ld.sh	r8,r8[18]
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
80007110:	48 99       	lddpc	r9,80007134 <xnl_device_conn_reply_func+0x84>
80007112:	b2 28       	st.h	r9[0x4],r8
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
		
		/*connect finish*/
		xnl_information.is_connected = TRUE;
80007114:	48 89       	lddpc	r9,80007134 <xnl_device_conn_reply_func+0x84>
80007116:	30 18       	mov	r8,1
80007118:	b2 88       	st.b	r9[0x0],r8
		
		log("connected finish");
8000711a:	48 8c       	lddpc	r12,80007138 <xnl_device_conn_reply_func+0x88>
8000711c:	f0 1f 00 08 	mcall	8000713c <xnl_device_conn_reply_func+0x8c>
	}
	
	//xcmp_audio_route_speaker();
	
}
80007120:	2f fd       	sub	sp,-4
80007122:	e3 cd 80 80 	ldm	sp++,r7,pc
80007126:	00 00       	add	r0,r0
80007128:	00 00       	add	r0,r0
8000712a:	0b 68       	ld.uh	r8,--r5
8000712c:	80 00       	ld.sh	r0,r0[0x0]
8000712e:	8f 44       	st.w	r7[0x10],r4
80007130:	80 00       	ld.sh	r0,r0[0x0]
80007132:	6e e4       	ld.w	r4,r7[0x38]
80007134:	00 00       	add	r0,r0
80007136:	0b 54       	ld.sh	r4,--r5
80007138:	80 00       	ld.sh	r0,r0[0x0]
8000713a:	6d 38       	ld.w	r8,r6[0x4c]
8000713c:	80 00       	ld.sh	r0,r0[0x0]
8000713e:	a8 70       	st.h	r4[0xe],r0

80007140 <xnl_send_msg_ack>:
Description: send data message ack.
Calls:xnl_tx
Register:xnl_data_msg_func
*/
static void xnl_send_msg_ack(xnl_header_t * hdr)
{	
80007140:	eb cd 40 80 	pushm	r7,lr
80007144:	1a 97       	mov	r7,sp
80007146:	fa cd 01 04 	sub	sp,sp,260
8000714a:	ef 4c fe fc 	st.w	r7[-260],r12
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
8000714e:	e0 68 40 0e 	mov	r8,16398
80007152:	ef 58 ff 00 	st.h	r7[-256],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80007156:	3f f8       	mov	r8,-1
80007158:	ef 58 ff 02 	st.h	r7[-254],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG_ACK;
8000715c:	30 c8       	mov	r8,12
8000715e:	ef 58 ff 04 	st.h	r7[-252],r8
	
	/*Turn around Flags.*/	
	xnl_frame.xnl_header.flags = hdr->flags;
80007162:	ee f8 fe fc 	ld.w	r8,r7[-260]
80007166:	90 18       	ld.sh	r8,r8[0x2]
80007168:	ef 58 ff 06 	st.h	r7[-250],r8
	
	/*ACK Destination Address is Source of XNL_Message.*/
	xnl_frame.xnl_header.destination = hdr->source;
8000716c:	ee f8 fe fc 	ld.w	r8,r7[-260]
80007170:	90 38       	ld.sh	r8,r8[0x6]
80007172:	ef 58 ff 08 	st.h	r7[-248],r8
	
	/*ACK Source Address is my address.*/
	xnl_frame.xnl_header.source = hdr->destination;
80007176:	ee f8 fe fc 	ld.w	r8,r7[-260]
8000717a:	90 28       	ld.sh	r8,r8[0x4]
8000717c:	ef 58 ff 0a 	st.h	r7[-246],r8
	
	/*Turn around Transaction ID.*/
	xnl_frame.xnl_header.transaction_id = hdr->transaction_id;
80007180:	ee f8 fe fc 	ld.w	r8,r7[-260]
80007184:	90 48       	ld.sh	r8,r8[0x8]
80007186:	ef 58 ff 0c 	st.h	r7[-244],r8
	xnl_frame.xnl_header.payload_length = 0;
8000718a:	30 08       	mov	r8,0
8000718c:	ef 58 ff 0e 	st.h	r7[-242],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
80007190:	ee c8 01 00 	sub	r8,r7,256
80007194:	10 9c       	mov	r12,r8
80007196:	f0 1f 00 03 	mcall	800071a0 <xnl_send_msg_ack+0x60>
}
8000719a:	2b fd       	sub	sp,-260
8000719c:	e3 cd 80 80 	ldm	sp++,r7,pc
800071a0:	80 00       	ld.sh	r0,r0[0x0]
800071a2:	72 64       	ld.w	r4,r9[0x18]

800071a4 <xnl_data_msg_func>:
Description: process while receive data message.
Calls:xnl_send_msg_ack, xcmp_exec(function in xcmp)
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_data_msg_func(xnl_fragment_t * xnl)
{
800071a4:	eb cd 40 c0 	pushm	r6-r7,lr
800071a8:	1a 97       	mov	r7,sp
800071aa:	20 1d       	sub	sp,4
800071ac:	ef 4c ff fc 	st.w	r7[-4],r12
	If cannot schedule ACK, just leave without processing message; 
	XNL will retry again, and hopefully our Tx resources will then be free. If 
	ACK has been scheduled. It most likely is already owned by the 
	transmitter, but possibly is waiting in Queue with immediate timeout.
	 */
	xnl_send_msg_ack(&xnl->xnl_header);
800071b0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800071b4:	2f c8       	sub	r8,-4
800071b6:	10 9c       	mov	r12,r8
800071b8:	f0 1f 00 0b 	mcall	800071e4 <xnl_data_msg_func+0x40>
	
	/*exec xcmp function*/
	xcmp_exec(xnl->xnl_payload.xnl_content_data_msg);//xcmp_rx
800071bc:	48 b8       	lddpc	r8,800071e8 <xnl_data_msg_func+0x44>
800071be:	70 06       	ld.w	r6,r8[0x0]
800071c0:	ee f9 ff fc 	ld.w	r9,r7[-4]
800071c4:	fa cd 00 cc 	sub	sp,sp,204
800071c8:	1a 98       	mov	r8,sp
800071ca:	2f 09       	sub	r9,-16
800071cc:	e0 6a 00 ca 	mov	r10,202
800071d0:	12 9b       	mov	r11,r9
800071d2:	10 9c       	mov	r12,r8
800071d4:	f0 1f 00 06 	mcall	800071ec <xnl_data_msg_func+0x48>
800071d8:	5d 16       	icall	r6
800071da:	fa cd ff 34 	sub	sp,sp,-204
}
800071de:	2f fd       	sub	sp,-4
800071e0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800071e4:	80 00       	ld.sh	r0,r0[0x0]
800071e6:	71 40       	ld.w	r0,r8[0x50]
800071e8:	00 00       	add	r0,r0
800071ea:	0b 60       	ld.uh	r0,--r5
800071ec:	80 00       	ld.sh	r0,r0[0x0]
800071ee:	b5 62       	lsl	r2,0x14

800071f0 <xnl_get_msg_ack_func>:
Description: process while receive msg ack.
Calls:xSemaphoreGive--freertos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
800071f0:	eb cd 40 80 	pushm	r7,lr
800071f4:	1a 97       	mov	r7,sp
800071f6:	20 2d       	sub	sp,8
800071f8:	ef 4c ff f8 	st.w	r7[-8],r12
	U16 DestinationAddress;
	U16 TransactionID;
	
	DestinationAddress = xnl->xnl_header.destination;
800071fc:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007200:	90 48       	ld.sh	r8,r8[0x8]
80007202:	ef 58 ff fc 	st.h	r7[-4],r8
	/*No timeout*/		
	 //One relationship is controlled by a state machine, only the current MSG received the ACK, 
	//then the program will clear the current MSG sending address and out of standby and will jump to the sending state.
	if (DestinationAddress == xnl_information.device_address )
80007206:	48 d8       	lddpc	r8,80007238 <xnl_get_msg_ack_func+0x48>
80007208:	90 28       	ld.sh	r8,r8[0x4]
8000720a:	5c 88       	casts.h	r8
8000720c:	ef 09 ff fc 	ld.sh	r9,r7[-4]
80007210:	f0 09 19 00 	cp.h	r9,r8
80007214:	c0 e1       	brne	80007230 <xnl_get_msg_ack_func+0x40>
	{
		//The ack is for me.
		
		TransactionID = xnl->xnl_header.transaction_id;
80007216:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000721a:	90 68       	ld.sh	r8,r8[0xc]
8000721c:	ef 58 ff fe 	st.h	r7[-2],r8
		xSemaphoreGive(xnl_timeout_semphr);	
80007220:	48 78       	lddpc	r8,8000723c <xnl_get_msg_ack_func+0x4c>
80007222:	70 08       	ld.w	r8,r8[0x0]
80007224:	30 09       	mov	r9,0
80007226:	30 0a       	mov	r10,0
80007228:	30 0b       	mov	r11,0
8000722a:	10 9c       	mov	r12,r8
8000722c:	f0 1f 00 05 	mcall	80007240 <xnl_get_msg_ack_func+0x50>
	}
	
	
	
	//xSemaphoreGive(xnl_timeout_semphr);	
}
80007230:	2f ed       	sub	sp,-8
80007232:	e3 cd 80 80 	ldm	sp++,r7,pc
80007236:	00 00       	add	r0,r0
80007238:	00 00       	add	r0,r0
8000723a:	0b 54       	ld.sh	r4,--r5
8000723c:	00 00       	add	r0,r0
8000723e:	0b 68       	ld.uh	r8,--r5
80007240:	80 00       	ld.sh	r0,r0[0x0]
80007242:	8f 44       	st.w	r7[0x10],r4

80007244 <xnl_register_xcmp_func>:
/**
Function: xnl_register_xcmp_func
Description: register the xcmp function(callback function)
*/
void xnl_register_xcmp_func( void ( *func)(xnl_content_data_msg_t))
{
80007244:	eb cd 40 80 	pushm	r7,lr
80007248:	1a 97       	mov	r7,sp
8000724a:	20 1d       	sub	sp,4
8000724c:	ef 4c ff fc 	st.w	r7[-4],r12
	 xcmp_exec = func;
80007250:	48 48       	lddpc	r8,80007260 <xnl_register_xcmp_func+0x1c>
80007252:	ee f9 ff fc 	ld.w	r9,r7[-4]
80007256:	91 09       	st.w	r8[0x0],r9
}
80007258:	2f fd       	sub	sp,-4
8000725a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000725e:	00 00       	add	r0,r0
80007260:	00 00       	add	r0,r0
80007262:	0b 60       	ld.uh	r0,--r5

80007264 <xnl_tx>:
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
{
80007264:	eb cd 40 80 	pushm	r7,lr
80007268:	1a 97       	mov	r7,sp
8000726a:	20 3d       	sub	sp,12
8000726c:	ef 4c ff f4 	st.w	r7[-12],r12
	/*variables are used to store the push result in interrupt*/
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80007270:	30 08       	mov	r8,0
80007272:	ef 48 ff fc 	st.w	r7[-4],r8
	message that is sent. The same value should be used for all retries.
	*/
	static U8 flags = 0;
	
	/*If the value is DEFAULT_VALUE, the value will be modified*/
	if(DEFAULT_VALUE == xnl->xnl_header.flags)
80007276:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000727a:	90 39       	ld.sh	r9,r8[0x6]
8000727c:	3f f8       	mov	r8,-1
8000727e:	f0 09 19 00 	cp.h	r9,r8
80007282:	c1 01       	brne	800072a2 <xnl_tx+0x3e>
	{
		xnl->xnl_header.flags =  0x0100 | ((++flags) & 0x07);
80007284:	4b a8       	lddpc	r8,8000736c <xnl_tx+0x108>
80007286:	11 88       	ld.ub	r8,r8[0x0]
80007288:	2f f8       	sub	r8,-1
8000728a:	5c 58       	castu.b	r8
8000728c:	4b 89       	lddpc	r9,8000736c <xnl_tx+0x108>
8000728e:	b2 88       	st.b	r9[0x0],r8
80007290:	4b 78       	lddpc	r8,8000736c <xnl_tx+0x108>
80007292:	11 88       	ld.ub	r8,r8[0x0]
80007294:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
80007298:	a9 a8       	sbr	r8,0x8
8000729a:	5c 88       	casts.h	r8
8000729c:	ee f9 ff f4 	ld.w	r9,r7[-12]
800072a0:	b2 38       	st.h	r9[0x6],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.destination)
800072a2:	ee f8 ff f4 	ld.w	r8,r7[-12]
800072a6:	90 49       	ld.sh	r9,r8[0x8]
800072a8:	3f f8       	mov	r8,-1
800072aa:	f0 09 19 00 	cp.h	r9,r8
800072ae:	c0 71       	brne	800072bc <xnl_tx+0x58>
	{		
		/*Use actual Master address.*/
		xnl->xnl_header.destination = xnl_information.master_address;
800072b0:	4b 08       	lddpc	r8,80007370 <xnl_tx+0x10c>
800072b2:	90 18       	ld.sh	r8,r8[0x2]
800072b4:	5c 88       	casts.h	r8
800072b6:	ee f9 ff f4 	ld.w	r9,r7[-12]
800072ba:	b2 48       	st.h	r9[0x8],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.source)
800072bc:	ee f8 ff f4 	ld.w	r8,r7[-12]
800072c0:	90 59       	ld.sh	r9,r8[0xa]
800072c2:	3f f8       	mov	r8,-1
800072c4:	f0 09 19 00 	cp.h	r9,r8
800072c8:	c0 71       	brne	800072d6 <xnl_tx+0x72>
	{
		/*Use Temporary address.*/	
		xnl->xnl_header.source = xnl_information.device_address;
800072ca:	4a a8       	lddpc	r8,80007370 <xnl_tx+0x10c>
800072cc:	90 28       	ld.sh	r8,r8[0x4]
800072ce:	5c 88       	casts.h	r8
800072d0:	ee f9 ff f4 	ld.w	r9,r7[-12]
800072d4:	b2 58       	st.h	r9[0xa],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
800072d6:	ee f8 ff f4 	ld.w	r8,r7[-12]
800072da:	90 69       	ld.sh	r9,r8[0xc]
800072dc:	3f f8       	mov	r8,-1
800072de:	f0 09 19 00 	cp.h	r9,r8
800072e2:	c1 a1       	brne	80007316 <xnl_tx+0xb2>
	{		
		xnl->xnl_header.transaction_id = 
		  ((++xnl_information.transaction_id) & 0xFF) 
800072e4:	4a 38       	lddpc	r8,80007370 <xnl_tx+0x10c>
800072e6:	90 48       	ld.sh	r8,r8[0x8]
800072e8:	5c 88       	casts.h	r8
800072ea:	2f f8       	sub	r8,-1
800072ec:	5c 88       	casts.h	r8
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
800072ee:	4a 19       	lddpc	r9,80007370 <xnl_tx+0x10c>
800072f0:	b2 48       	st.h	r9[0x8],r8
		  ((++xnl_information.transaction_id) & 0xFF) 
800072f2:	4a 08       	lddpc	r8,80007370 <xnl_tx+0x10c>
800072f4:	90 48       	ld.sh	r8,r8[0x8]
800072f6:	5c 88       	casts.h	r8
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
800072f8:	5c 88       	casts.h	r8
800072fa:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
800072fe:	49 d9       	lddpc	r9,80007370 <xnl_tx+0x10c>
80007300:	92 49       	ld.sh	r9,r9[0x8]
80007302:	5c 89       	casts.h	r9
80007304:	5c 89       	casts.h	r9
80007306:	e0 19 ff 00 	andl	r9,0xff00
8000730a:	5c 89       	casts.h	r9
8000730c:	12 48       	or	r8,r9
8000730e:	5c 88       	casts.h	r8
80007310:	ee f9 ff f4 	ld.w	r9,r7[-12]
80007314:	b2 68       	st.h	r9[0xc],r8
		  ((++xnl_information.transaction_id) & 0xFF) 
		| (xnl_information.transaction_id & 0xFF00);
	}
	
	/*count check sum */
	xnl->phy_header.check_sum = check_sum( xnl );
80007316:	ee fc ff f4 	ld.w	r12,r7[-12]
8000731a:	f0 1f 00 17 	mcall	80007374 <xnl_tx+0x110>
8000731e:	18 98       	mov	r8,r12
80007320:	5c 88       	casts.h	r8
80007322:	ee f9 ff f4 	ld.w	r9,r7[-12]
80007326:	b2 18       	st.h	r9[0x2],r8
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
80007328:	49 48       	lddpc	r8,80007378 <xnl_tx+0x114>
8000732a:	70 08       	ld.w	r8,r8[0x0]
8000732c:	10 9c       	mov	r12,r8
8000732e:	f0 1f 00 14 	mcall	8000737c <xnl_tx+0x118>
80007332:	18 98       	mov	r8,r12
80007334:	ef 48 ff f8 	st.w	r7[-8],r8
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
80007338:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000733c:	58 08       	cp.w	r8,0
8000733e:	c1 30       	breq	80007364 <xnl_tx+0x100>
	{
		memcpy(ptr, xnl, sizeof(xnl_fragment_t));
80007340:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007344:	e0 6a 01 00 	mov	r10,256
80007348:	ee fb ff f4 	ld.w	r11,r7[-12]
8000734c:	10 9c       	mov	r12,r8
8000734e:	f0 1f 00 0d 	mcall	80007380 <xnl_tx+0x11c>
	
		/*push to queue and send*/
		
		//log("ptr -%8x", ptr);
		
		xQueueSend(xnl_frame_tx, &ptr, 0);
80007352:	48 d8       	lddpc	r8,80007384 <xnl_tx+0x120>
80007354:	70 08       	ld.w	r8,r8[0x0]
80007356:	ee cb 00 08 	sub	r11,r7,8
8000735a:	30 09       	mov	r9,0
8000735c:	30 0a       	mov	r10,0
8000735e:	10 9c       	mov	r12,r8
80007360:	f0 1f 00 0a 	mcall	80007388 <xnl_tx+0x124>
		//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
		
		//vPortFree(ptr);
	}
}
80007364:	2f dd       	sub	sp,-12
80007366:	e3 cd 80 80 	ldm	sp++,r7,pc
8000736a:	00 00       	add	r0,r0
8000736c:	00 00       	add	r0,r0
8000736e:	0b 78       	ld.ub	r8,--r5
80007370:	00 00       	add	r0,r0
80007372:	0b 54       	ld.sh	r4,--r5
80007374:	80 00       	ld.sh	r0,r0[0x0]
80007376:	6e 08       	ld.w	r8,r7[0x0]
80007378:	00 00       	add	r0,r0
8000737a:	0a 8c       	andn	r12,r5
8000737c:	80 00       	ld.sh	r0,r0[0x0]
8000737e:	64 3c       	ld.w	r12,r2[0xc]
80007380:	80 00       	ld.sh	r0,r0[0x0]
80007382:	b5 62       	lsl	r2,0x14
80007384:	00 00       	add	r0,r0
80007386:	0b 64       	ld.uh	r4,--r5
80007388:	80 00       	ld.sh	r0,r0[0x0]
8000738a:	8f 44       	st.w	r7[0x10],r4

8000738c <xnl_tx_process>:
	xSemaphoreTake--freertos 
	phy_tx -- physical.c
Called By: task
*/
static void xnl_tx_process(void * pvParameters)
{
8000738c:	eb cd 40 80 	pushm	r7,lr
80007390:	1a 97       	mov	r7,sp
80007392:	20 1d       	sub	sp,4
80007394:	ef 4c ff fc 	st.w	r7[-4],r12
	static  xnl_fragment_t * ptr;//
	
	
	for(;;)
	{		
		switch(xnl_tx_state)
80007398:	4b 68       	lddpc	r8,80007470 <xnl_tx_process+0xe4>
8000739a:	70 08       	ld.w	r8,r8[0x0]
8000739c:	58 08       	cp.w	r8,0
8000739e:	c0 40       	breq	800073a6 <xnl_tx_process+0x1a>
800073a0:	58 18       	cp.w	r8,1
800073a2:	c3 10       	breq	80007404 <xnl_tx_process+0x78>
				}
				break;
			default:
				break;
		}
	}
800073a4:	cf ab       	rjmp	80007398 <xnl_tx_process+0xc>
	for(;;)
	{		
		switch(xnl_tx_state)
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
800073a6:	4b 48       	lddpc	r8,80007474 <xnl_tx_process+0xe8>
800073a8:	70 08       	ld.w	r8,r8[0x0]
800073aa:	30 09       	mov	r9,0
800073ac:	3f fa       	mov	r10,-1
800073ae:	4b 3b       	lddpc	r11,80007478 <xnl_tx_process+0xec>
800073b0:	10 9c       	mov	r12,r8
800073b2:	f0 1f 00 33 	mcall	8000747c <xnl_tx_process+0xf0>
800073b6:	18 98       	mov	r8,r12
800073b8:	58 18       	cp.w	r8,1
800073ba:	c2 41       	brne	80007402 <xnl_tx_process+0x76>
					, portMAX_DELAY ))
				{				
					if(NULL == ptr)
800073bc:	4a f8       	lddpc	r8,80007478 <xnl_tx_process+0xec>
800073be:	70 08       	ld.w	r8,r8[0x0]
800073c0:	58 08       	cp.w	r8,0
800073c2:	c0 21       	brne	800073c6 <xnl_tx_process+0x3a>
					{
						break;
800073c4:	c5 48       	rjmp	8000746c <xnl_tx_process+0xe0>
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
800073c6:	4a d8       	lddpc	r8,80007478 <xnl_tx_process+0xec>
800073c8:	70 08       	ld.w	r8,r8[0x0]
800073ca:	90 28       	ld.sh	r8,r8[0x4]
800073cc:	58 08       	cp.w	r8,0
800073ce:	c0 71       	brne	800073dc <xnl_tx_process+0x50>
					{
						/*invalid XNL opcode*/
						vPortFree(ptr);
800073d0:	4a a8       	lddpc	r8,80007478 <xnl_tx_process+0xec>
800073d2:	70 08       	ld.w	r8,r8[0x0]
800073d4:	10 9c       	mov	r12,r8
800073d6:	f0 1f 00 2b 	mcall	80007480 <xnl_tx_process+0xf4>
						break;
800073da:	c4 98       	rjmp	8000746c <xnl_tx_process+0xe0>
					}
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
800073dc:	4a 78       	lddpc	r8,80007478 <xnl_tx_process+0xec>
800073de:	70 08       	ld.w	r8,r8[0x0]
800073e0:	10 9c       	mov	r12,r8
800073e2:	f0 1f 00 29 	mcall	80007484 <xnl_tx_process+0xf8>
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;
800073e6:	4a 98       	lddpc	r8,80007488 <xnl_tx_process+0xfc>
800073e8:	30 19       	mov	r9,1
800073ea:	91 09       	st.w	r8[0x0],r9
					
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
800073ec:	4a 88       	lddpc	r8,8000748c <xnl_tx_process+0x100>
800073ee:	70 08       	ld.w	r8,r8[0x0]
800073f0:	30 09       	mov	r9,0
800073f2:	30 0a       	mov	r10,0
800073f4:	30 0b       	mov	r11,0
800073f6:	10 9c       	mov	r12,r8
800073f8:	f0 1f 00 21 	mcall	8000747c <xnl_tx_process+0xf0>
					xnl_tx_state = WAITING_FOR_REPLY;
800073fc:	49 d8       	lddpc	r8,80007470 <xnl_tx_process+0xe4>
800073fe:	30 19       	mov	r9,1
80007400:	91 09       	st.w	r8[0x0],r9
				}
				break;
80007402:	c3 58       	rjmp	8000746c <xnl_tx_process+0xe0>
			
			/*wait XNL reply*/			
			case WAITING_FOR_REPLY://ACKdata/control
				if(pdTRUE == xSemaphoreTake( xnl_timeout_semphr
80007404:	4a 28       	lddpc	r8,8000748c <xnl_tx_process+0x100>
80007406:	70 08       	ld.w	r8,r8[0x0]
80007408:	30 09       	mov	r9,0
8000740a:	36 4a       	mov	r10,100
8000740c:	30 0b       	mov	r11,0
8000740e:	10 9c       	mov	r12,r8
80007410:	f0 1f 00 1b 	mcall	8000747c <xnl_tx_process+0xf0>
80007414:	18 98       	mov	r8,r12
80007416:	58 18       	cp.w	r8,1
80007418:	c0 d1       	brne	80007432 <xnl_tx_process+0xa6>
					, ( portTickType )50*2/ portTICK_RATE_MS))//ADK500ms,freertos
				{
					/*No timeout*/
					//vPortFree(ptr);	
					set_xnl_idle(ptr);			
8000741a:	49 88       	lddpc	r8,80007478 <xnl_tx_process+0xec>
8000741c:	70 09       	ld.w	r9,r8[0x0]
8000741e:	49 d8       	lddpc	r8,80007490 <xnl_tx_process+0x104>
80007420:	70 08       	ld.w	r8,r8[0x0]
80007422:	12 9b       	mov	r11,r9
80007424:	10 9c       	mov	r12,r8
80007426:	f0 1f 00 1c 	mcall	80007494 <xnl_tx_process+0x108>
					xnl_tx_state = WAITING_FOR_TX;
8000742a:	49 28       	lddpc	r8,80007470 <xnl_tx_process+0xe4>
8000742c:	30 09       	mov	r9,0
8000742e:	91 09       	st.w	r8[0x0],r9
				}
				break;
			default:
				break;
		}
	}
80007430:	cb 4b       	rjmp	80007398 <xnl_tx_process+0xc>
					xnl_tx_state = WAITING_FOR_TX;
				}
				else
				{
					/*time out*/
					if(xnl_send_times <= MIN_RESEND_TIMES)
80007432:	49 68       	lddpc	r8,80007488 <xnl_tx_process+0xfc>
80007434:	70 08       	ld.w	r8,r8[0x0]
80007436:	58 38       	cp.w	r8,3
80007438:	e0 89 00 0e 	brgt	80007454 <xnl_tx_process+0xc8>
					{
						/*If times smaller than A supermarket, then resend the 
						instructions*/
						phy_tx((phy_fragment_t *)ptr);
8000743c:	48 f8       	lddpc	r8,80007478 <xnl_tx_process+0xec>
8000743e:	70 08       	ld.w	r8,r8[0x0]
80007440:	10 9c       	mov	r12,r8
80007442:	f0 1f 00 11 	mcall	80007484 <xnl_tx_process+0xf8>
						xnl_send_times++;
80007446:	49 18       	lddpc	r8,80007488 <xnl_tx_process+0xfc>
80007448:	70 08       	ld.w	r8,r8[0x0]
8000744a:	f0 c9 ff ff 	sub	r9,r8,-1
8000744e:	48 f8       	lddpc	r8,80007488 <xnl_tx_process+0xfc>
80007450:	91 09       	st.w	r8[0x0],r9
				}
				break;
			default:
				break;
		}
	}
80007452:	ca 3b       	rjmp	80007398 <xnl_tx_process+0xc>
					}
					else
					{
						//can not send data, disconnected						
						//vPortFree(ptr);	
						set_xnl_idle(ptr);									
80007454:	48 98       	lddpc	r8,80007478 <xnl_tx_process+0xec>
80007456:	70 09       	ld.w	r9,r8[0x0]
80007458:	48 e8       	lddpc	r8,80007490 <xnl_tx_process+0x104>
8000745a:	70 08       	ld.w	r8,r8[0x0]
8000745c:	12 9b       	mov	r11,r9
8000745e:	10 9c       	mov	r12,r8
80007460:	f0 1f 00 0d 	mcall	80007494 <xnl_tx_process+0x108>
						xnl_tx_state = WAITING_FOR_TX;
80007464:	48 38       	lddpc	r8,80007470 <xnl_tx_process+0xe4>
80007466:	30 09       	mov	r9,0
80007468:	91 09       	st.w	r8[0x0],r9
				}
				break;
			default:
				break;
		}
	}
8000746a:	c9 7b       	rjmp	80007398 <xnl_tx_process+0xc>
8000746c:	c9 6b       	rjmp	80007398 <xnl_tx_process+0xc>
8000746e:	00 00       	add	r0,r0
80007470:	00 00       	add	r0,r0
80007472:	0b 6c       	ld.uh	r12,--r5
80007474:	00 00       	add	r0,r0
80007476:	0b 64       	ld.uh	r4,--r5
80007478:	00 00       	add	r0,r0
8000747a:	0b 70       	ld.ub	r0,--r5
8000747c:	80 00       	ld.sh	r0,r0[0x0]
8000747e:	91 50       	st.w	r8[0x14],r0
80007480:	80 00       	ld.sh	r0,r0[0x0]
80007482:	8d f4       	st.w	r6[0x3c],r4
80007484:	80 00       	ld.sh	r0,r0[0x0]
80007486:	48 f4       	lddpc	r4,800074c0 <xnl_rx+0x28>
80007488:	00 00       	add	r0,r0
8000748a:	0b 74       	ld.ub	r4,--r5
8000748c:	00 00       	add	r0,r0
8000748e:	0b 68       	ld.uh	r8,--r5
80007490:	00 00       	add	r0,r0
80007492:	0a 8c       	andn	r12,r5
80007494:	80 00       	ld.sh	r0,r0[0x0]
80007496:	64 c4       	ld.w	r4,r2[0x30]

80007498 <xnl_rx>:
Description: Receive the XNL and perform the corresponding functions
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
80007498:	eb cd 40 80 	pushm	r7,lr
8000749c:	1a 97       	mov	r7,sp
8000749e:	20 1d       	sub	sp,4
800074a0:	ef 4c ff fc 	st.w	r7[-4],r12
	if(xnl->xnl_header.opcode > 0x0C)	
800074a4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800074a8:	90 29       	ld.sh	r9,r8[0x4]
800074aa:	30 c8       	mov	r8,12
800074ac:	f0 09 19 00 	cp.h	r9,r8
800074b0:	e0 8b 00 18 	brhi	800074e0 <xnl_rx+0x48>
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
800074b4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800074b8:	90 28       	ld.sh	r8,r8[0x4]
800074ba:	f3 d8 c0 10 	bfextu	r9,r8,0x0,0x10
800074be:	48 b8       	lddpc	r8,800074e8 <xnl_rx+0x50>
800074c0:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
800074c4:	58 08       	cp.w	r8,0
800074c6:	c0 e0       	breq	800074e2 <xnl_rx+0x4a>
	{
		//log("\n\r R_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:R_xnl
		/*execute the function in list*/
		xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec(xnl);
800074c8:	ee f8 ff fc 	ld.w	r8,r7[-4]
800074cc:	90 28       	ld.sh	r8,r8[0x4]
800074ce:	f3 d8 c0 10 	bfextu	r9,r8,0x0,0x10
800074d2:	48 68       	lddpc	r8,800074e8 <xnl_rx+0x50>
800074d4:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
800074d8:	ee fc ff fc 	ld.w	r12,r7[-4]
800074dc:	5d 18       	icall	r8
800074de:	c0 28       	rjmp	800074e2 <xnl_rx+0x4a>
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
	{
		return;
800074e0:	d7 03       	nop
	{
		//log("\n\r R_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:R_xnl
		/*execute the function in list*/
		xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec(xnl);
	}
}
800074e2:	2f fd       	sub	sp,-4
800074e4:	e3 cd 80 80 	ldm	sp++,r7,pc
800074e8:	00 00       	add	r0,r0
800074ea:	05 14       	ld.sh	r4,r2++

800074ec <xnl_rx_process>:
Description: Receive the XNL
Calls: 
Called By:task
*/
static void xnl_rx_process(void * pvParameters)
{
800074ec:	eb cd 40 80 	pushm	r7,lr
800074f0:	1a 97       	mov	r7,sp
800074f2:	20 2d       	sub	sp,8
800074f4:	ef 4c ff f8 	st.w	r7[-8],r12
800074f8:	c0 48       	rjmp	80007500 <xnl_rx_process+0x14>
				
				//vPortFree(xnl_ptr);
			}			
		}
		
	}
800074fa:	d7 03       	nop
800074fc:	c0 28       	rjmp	80007500 <xnl_rx_process+0x14>
800074fe:	d7 03       	nop
	/*To ptr the elements in the queue*/
	xnl_fragment_t * xnl_ptr;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
80007500:	48 f8       	lddpc	r8,8000753c <xnl_rx_process+0x50>
80007502:	70 08       	ld.w	r8,r8[0x0]
80007504:	ee cb 00 04 	sub	r11,r7,4
80007508:	30 09       	mov	r9,0
8000750a:	3f fa       	mov	r10,-1
8000750c:	10 9c       	mov	r12,r8
8000750e:	f0 1f 00 0d 	mcall	80007540 <xnl_rx_process+0x54>
80007512:	18 98       	mov	r8,r12
80007514:	58 18       	cp.w	r8,1
80007516:	cf 21       	brne	800074fa <xnl_rx_process+0xe>
		, portMAX_DELAY ))
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
80007518:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000751c:	58 08       	cp.w	r8,0
8000751e:	cf 00       	breq	800074fe <xnl_rx_process+0x12>
			{
				xnl_rx(xnl_ptr);
80007520:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007524:	10 9c       	mov	r12,r8
80007526:	f0 1f 00 08 	mcall	80007544 <xnl_rx_process+0x58>
				set_xnl_idle(xnl_ptr);
8000752a:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000752e:	48 78       	lddpc	r8,80007548 <xnl_rx_process+0x5c>
80007530:	70 08       	ld.w	r8,r8[0x0]
80007532:	12 9b       	mov	r11,r9
80007534:	10 9c       	mov	r12,r8
80007536:	f0 1f 00 06 	mcall	8000754c <xnl_rx_process+0x60>
				
				//vPortFree(xnl_ptr);
			}			
		}
		
	}
8000753a:	ce 3b       	rjmp	80007500 <xnl_rx_process+0x14>
8000753c:	00 00       	add	r0,r0
8000753e:	0a 94       	mov	r4,r5
80007540:	80 00       	ld.sh	r0,r0[0x0]
80007542:	91 50       	st.w	r8[0x14],r0
80007544:	80 00       	ld.sh	r0,r0[0x0]
80007546:	74 98       	ld.w	r8,r10[0x24]
80007548:	00 00       	add	r0,r0
8000754a:	0a 8c       	andn	r12,r5
8000754c:	80 00       	ld.sh	r0,r0[0x0]
8000754e:	64 c4       	ld.w	r4,r2[0x30]

80007550 <xnl_init>:
	xTaskCreate--freertos
	xnl_send_device_master_query
Called By:xcmp_init -- xcmp.c
*/
void xnl_init(void)
{
80007550:	eb cd 40 80 	pushm	r7,lr
80007554:	1a 97       	mov	r7,sp
	/*initialize the physical layer*/
	phy_init();
80007556:	f0 1f 00 21 	mcall	800075d8 <xnl_init+0x88>
	
	xnl_information.is_connected = FALSE;
8000755a:	4a 19       	lddpc	r9,800075dc <xnl_init+0x8c>
8000755c:	30 08       	mov	r8,0
8000755e:	b2 88       	st.b	r9[0x0],r8

	/*initialize the semaphore and queue*/
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
80007560:	30 0b       	mov	r11,0
80007562:	30 1c       	mov	r12,1
80007564:	f0 1f 00 1f 	mcall	800075e0 <xnl_init+0x90>
80007568:	18 99       	mov	r9,r12
8000756a:	49 f8       	lddpc	r8,800075e4 <xnl_init+0x94>
8000756c:	91 09       	st.w	r8[0x0],r9
8000756e:	49 e8       	lddpc	r8,800075e4 <xnl_init+0x94>
80007570:	70 08       	ld.w	r8,r8[0x0]
80007572:	58 08       	cp.w	r8,0
80007574:	c0 90       	breq	80007586 <xnl_init+0x36>
80007576:	49 c8       	lddpc	r8,800075e4 <xnl_init+0x94>
80007578:	70 08       	ld.w	r8,r8[0x0]
8000757a:	30 09       	mov	r9,0
8000757c:	30 0a       	mov	r10,0
8000757e:	30 0b       	mov	r11,0
80007580:	10 9c       	mov	r12,r8
80007582:	f0 1f 00 1a 	mcall	800075e8 <xnl_init+0x98>
	//xnl_frame_tx = xQueueCreate(10, sizeof(xnl_fragment_t *)); 
	
	xnl_frame_tx = xQueueCreate(20, sizeof(xnl_fragment_t *)); //xnl_frame_tx
80007586:	30 4b       	mov	r11,4
80007588:	31 4c       	mov	r12,20
8000758a:	f0 1f 00 16 	mcall	800075e0 <xnl_init+0x90>
8000758e:	18 99       	mov	r9,r12
80007590:	49 78       	lddpc	r8,800075ec <xnl_init+0x9c>
80007592:	91 09       	st.w	r8[0x0],r9
		
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
80007594:	49 7b       	lddpc	r11,800075f0 <xnl_init+0xa0>
80007596:	30 08       	mov	r8,0
80007598:	1a d8       	st.w	--sp,r8
8000759a:	30 08       	mov	r8,0
8000759c:	1a d8       	st.w	--sp,r8
8000759e:	30 08       	mov	r8,0
800075a0:	1a d8       	st.w	--sp,r8
800075a2:	30 38       	mov	r8,3
800075a4:	30 09       	mov	r9,0
800075a6:	e0 6a 02 00 	mov	r10,512
800075aa:	49 3c       	lddpc	r12,800075f4 <xnl_init+0xa4>
800075ac:	f0 1f 00 13 	mcall	800075f8 <xnl_init+0xa8>
800075b0:	2f dd       	sub	sp,-12
	,  tskXNL_PRIORITY //+ 1
	,  NULL
	);
	
	/*this task is used to send xnl message*/
	xTaskCreate(
800075b2:	49 3b       	lddpc	r11,800075fc <xnl_init+0xac>
800075b4:	30 08       	mov	r8,0
800075b6:	1a d8       	st.w	--sp,r8
800075b8:	30 08       	mov	r8,0
800075ba:	1a d8       	st.w	--sp,r8
800075bc:	30 08       	mov	r8,0
800075be:	1a d8       	st.w	--sp,r8
800075c0:	30 38       	mov	r8,3
800075c2:	30 09       	mov	r9,0
800075c4:	e0 6a 03 20 	mov	r10,800
800075c8:	48 ec       	lddpc	r12,80007600 <xnl_init+0xb0>
800075ca:	f0 1f 00 0c 	mcall	800075f8 <xnl_init+0xa8>
800075ce:	2f dd       	sub	sp,-12
	,  tskXNL_PRIORITY//+1
	,  NULL
	);
	
	/*send device_master_query to connect radio*/	
	xnl_send_device_master_query();
800075d0:	f0 1f 00 0d 	mcall	80007604 <xnl_init+0xb4>
}
800075d4:	e3 cd 80 80 	ldm	sp++,r7,pc
800075d8:	80 00       	ld.sh	r0,r0[0x0]
800075da:	47 e8       	lddsp	r8,sp[0x1f8]
800075dc:	00 00       	add	r0,r0
800075de:	0b 54       	ld.sh	r4,--r5
800075e0:	80 00       	ld.sh	r0,r0[0x0]
800075e2:	8e 2c       	ld.sh	r12,r7[0x4]
800075e4:	00 00       	add	r0,r0
800075e6:	0b 68       	ld.uh	r8,--r5
800075e8:	80 00       	ld.sh	r0,r0[0x0]
800075ea:	8f 44       	st.w	r7[0x10],r4
800075ec:	00 00       	add	r0,r0
800075ee:	0b 64       	ld.uh	r4,--r5
800075f0:	80 00       	ld.sh	r0,r0[0x0]
800075f2:	6d 4c       	ld.w	r12,r6[0x50]
800075f4:	80 00       	ld.sh	r0,r0[0x0]
800075f6:	74 ec       	ld.w	r12,r10[0x38]
800075f8:	80 00       	ld.sh	r0,r0[0x0]
800075fa:	96 9c       	ld.uh	r12,r11[0x2]
800075fc:	80 00       	ld.sh	r0,r0[0x0]
800075fe:	6d 54       	ld.w	r4,r6[0x54]
80007600:	80 00       	ld.sh	r0,r0[0x0]
80007602:	73 8c       	ld.w	r12,r9[0x60]
80007604:	80 00       	ld.sh	r0,r0[0x0]
80007606:	6e 94       	ld.w	r4,r7[0x24]

80007608 <local_start_pll0>:
//In the SSC description, Master Clock (MCK) is the bus clock of the peripheral bus to which the
//SSC is connected. [23.6.2]
//Switch to clock Osc0 (crystal)
//start PLL0 and switch main clock to PLL0 output
void local_start_pll0(void)
{
80007608:	eb cd 40 80 	pushm	r7,lr
8000760c:	1a 97       	mov	r7,sp
	//pm_switch_to_osc0(pm, 12000000, 3);
	//    pm_enable_osc0_crystal(pm, 12000000);
	//         pm_set_osc0_mode(pm,AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);  0x00000007
	//    pm_enable_clk0(pm, 3);
	//         pm_enable_clk0_no_wait(pm, 3);
	(&AVR32_PM)->oscctrl0 = 0x00000307;
8000760e:	fe 78 0c 00 	mov	r8,-62464
80007612:	e0 69 03 07 	mov	r9,775
80007616:	91 a9       	st.w	r8[0x28],r9
	(&AVR32_PM)->mcctrl   = 0x00000004;
80007618:	fe 78 0c 00 	mov	r8,-62464
8000761c:	30 49       	mov	r9,4
8000761e:	91 09       	st.w	r8[0x0],r9
	//         pm_wait_for_clk0_ready(pm);
	while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
80007620:	fe 78 0c 00 	mov	r8,-62464
80007624:	71 58       	ld.w	r8,r8[0x54]
80007626:	e2 18 00 80 	andl	r8,0x80,COH
8000762a:	cf b0       	breq	80007620 <local_start_pll0+0x18>
	//    pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);
	(&AVR32_PM)->mcctrl   = 0x00000005;
8000762c:	fe 78 0c 00 	mov	r8,-62464
80007630:	30 59       	mov	r9,5
80007632:	91 09       	st.w	r8[0x0],r9
	//pm_pll_set_option(pm, 0, //PLL number 0
	//                        1, //freq Set to 1 for VCO frequency range 80-180MHz
	//                        1, //div2 Divide the PLL output frequency by 2
	//                        0);//0 to enable the Wide-Bandith Mode
	//pm_pll_enable(pm,0);
	(&AVR32_PM)->pll[0] = 0x1007010D;
80007634:	fe 78 0c 00 	mov	r8,-62464
80007638:	e0 69 01 0d 	mov	r9,269
8000763c:	ea 19 10 07 	orh	r9,0x1007
80007640:	91 89       	st.w	r8[0x20],r9


	//pm_wait_for_pll0_locked(pm);
	while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_LOCK0_MASK));
80007642:	fe 78 0c 00 	mov	r8,-62464
80007646:	71 58       	ld.w	r8,r8[0x54]
80007648:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000764c:	cf b0       	breq	80007642 <local_start_pll0+0x3a>
	//             0,  //Bus A select = 0 (PBA clock = 48MHz/2 = 24MHz).
	//             0,  //B clock divisor enable = 0
	//             0,  //Bus B select = 0
	//             0,  //HS Bus clock divisor enable = 0
	//             0); //HS Bus select = 0
	(&AVR32_PM)->cksel = 0x00800000;
8000764e:	fe 78 0c 00 	mov	r8,-62464
80007652:	fc 19 00 80 	movh	r9,0x80
80007656:	91 19       	st.w	r8[0x4],r9

	//flashc_set_wait_state(1);
	AVR32_FLASHC.fcr = 0x00000040;
80007658:	fe 68 14 00 	mov	r8,-125952
8000765c:	34 09       	mov	r9,64
8000765e:	91 09       	st.w	r8[0x0],r9

	//pm_switch_to_clock(pm, AVR32_PM_MCSEL_PLL0);
	(&AVR32_PM)->mcctrl   = 0x00000006;
80007660:	fe 78 0c 00 	mov	r8,-62464
80007664:	30 69       	mov	r9,6
80007666:	91 09       	st.w	r8[0x0],r9


	AVR32_HMATRIX.mcfg[AVR32_HMATRIX_MASTER_CPU_INSTRUCTION] = 0x1;
80007668:	fe 68 10 00 	mov	r8,-126976
8000766c:	30 19       	mov	r9,1
8000766e:	91 19       	st.w	r8[0x4],r9
}
80007670:	e3 cd 80 80 	ldm	sp++,r7,pc

80007674 <_tc_interrupt>:
volatile U32 tc_tick = 0;

//brief Default interrupt handler.
__attribute__((__interrupt__))
static void _tc_interrupt(void)
 {
80007674:	eb cd 40 80 	pushm	r7,lr
80007678:	1a 97       	mov	r7,sp
	// Increment the 10ms seconds counter
	tc_tick++;
8000767a:	48 88       	lddpc	r8,80007698 <_tc_interrupt+0x24>
8000767c:	70 08       	ld.w	r8,r8[0x0]
8000767e:	f0 c9 ff ff 	sub	r9,r8,-1
80007682:	48 68       	lddpc	r8,80007698 <_tc_interrupt+0x24>
80007684:	91 09       	st.w	r8[0x0],r9
	/*
	 * TODO: Place a breakpoint here and watch the update of tc_tick variable
	 * in the Watch Window.
	 */
	// Clear the interrupt flag. This is a side effect of reading the TC SR.
	tc_read_sr(EXAMPLE_TC, EXAMPLE_TC_CHANNEL);
80007686:	30 1b       	mov	r11,1
80007688:	fe 7c 38 00 	mov	r12,-51200
8000768c:	f0 1f 00 04 	mcall	8000769c <_tc_interrupt+0x28>
	
}
80007690:	e3 cd 40 80 	ldm	sp++,r7,lr
80007694:	d6 03       	rete
80007696:	00 00       	add	r0,r0
80007698:	00 00       	add	r0,r0
8000769a:	0b 7c       	ld.ub	r12,--r5
8000769c:	80 00       	ld.sh	r0,r0[0x0]
8000769e:	81 de       	st.w	r0[0x34],lr

800076a0 <local_start_timer>:
//	SSC_TX_DATA_ENABLE		AVR32_TC_A0_0_0_PIN					[32 PortB Pin  0 00000001 Func 0]
//	MAKO_TX					AVR32_SSC_TX_DATA_0_PIN				[42 PortB Pin 10 00000400 Func 0]
//	MAKO_RX					AVR32_SSC_RX_DATA_0_PIN				[39 PortB Pin  7 00000080 Func 0]
//
void local_start_timer(void)
{
800076a0:	eb cd 40 80 	pushm	r7,lr
800076a4:	1a 97       	mov	r7,sp
	//Route CLK to Timer
	AVR32_GPIO.port[0].pmr0s = 0x00100000;
800076a6:	fe 78 10 00 	mov	r8,-61440
800076aa:	fc 19 00 10 	movh	r9,0x10
800076ae:	91 59       	st.w	r8[0x14],r9
	AVR32_GPIO.port[0].pmr1c = 0x00100000;
800076b0:	fe 78 10 00 	mov	r8,-61440
800076b4:	fc 19 00 10 	movh	r9,0x10
800076b8:	91 a9       	st.w	r8[0x28],r9
	AVR32_GPIO.port[0].gperc = 0x00100000;
800076ba:	fe 78 10 00 	mov	r8,-61440
800076be:	fc 19 00 10 	movh	r9,0x10
800076c2:	91 29       	st.w	r8[0x8],r9
	//Route FS and Tri-State to Timer.
	AVR32_GPIO.port[1].pmr0c = 0x00000003;
800076c4:	fe 78 10 00 	mov	r8,-61440
800076c8:	30 39       	mov	r9,3
800076ca:	f1 49 01 18 	st.w	r8[280],r9
	AVR32_GPIO.port[1].pmr1c = 0x00000003;
800076ce:	fe 78 10 00 	mov	r8,-61440
800076d2:	30 39       	mov	r9,3
800076d4:	f1 49 01 28 	st.w	r8[296],r9
	AVR32_GPIO.port[1].gperc = 0x00000003;
800076d8:	fe 78 10 00 	mov	r8,-61440
800076dc:	30 39       	mov	r9,3
800076de:	f1 49 01 08 	st.w	r8[264],r9

	(&AVR32_TC)->bmr = 4;
800076e2:	fe 78 38 00 	mov	r8,-51200
800076e6:	30 49       	mov	r9,4
800076e8:	f1 49 00 c4 	st.w	r8[196],r9
	(&AVR32_TC)->channel[0].cmr =
800076ec:	fe 78 38 00 	mov	r8,-51200
800076f0:	e0 69 91 0d 	mov	r9,37133
800076f4:	ea 19 00 52 	orh	r9,0x52
800076f8:	91 19       	st.w	r8[0x4],r9
	1                          << AVR32_TC_CLKI_OFFSET     |
	AVR32_TC_TCCLKS_XC0        << AVR32_TC_TCCLKS_OFFSET;



	(&AVR32_TC)->channel[0].ra = 32;
800076fa:	fe 78 38 00 	mov	r8,-51200
800076fe:	32 09       	mov	r9,32
80007700:	91 59       	st.w	r8[0x14],r9
	(&AVR32_TC)->channel[0].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
80007702:	fe 78 38 00 	mov	r8,-51200
80007706:	30 59       	mov	r9,5
80007708:	91 09       	st.w	r8[0x0],r9
}
8000770a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000770e:	d7 03       	nop

80007710 <tc_init>:
 * - fPBA/8 is used as clock source for TC
 * - Enables RC compare match interrupt
 * \param tc Base address of the TC module
 */
void tc_init()
{
80007710:	eb cd 40 80 	pushm	r7,lr
80007714:	1a 97       	mov	r7,sp
80007716:	20 1d       	sub	sp,4

	volatile avr32_tc_t * tc = EXAMPLE_TC;
80007718:	fe 78 38 00 	mov	r8,-51200
8000771c:	ef 48 ff fc 	st.w	r7[-4],r8
	
	INTC_register_interrupt(&_tc_interrupt, AVR32_TC_IRQ1, AVR32_INTC_INT2);
80007720:	30 2a       	mov	r10,2
80007722:	e0 6b 01 c1 	mov	r11,449
80007726:	48 fc       	lddpc	r12,80007760 <tc_init+0x50>
80007728:	f0 1f 00 0f 	mcall	80007764 <tc_init+0x54>
		.cpas  = 0,
		.lovrs = 0,
		.covfs = 0
	};
	// Initialize the timer/counter.
	tc_init_waveform(tc, &waveform_opt);
8000772c:	48 fb       	lddpc	r11,80007768 <tc_init+0x58>
8000772e:	ee fc ff fc 	ld.w	r12,r7[-4]
80007732:	f0 1f 00 0f 	mcall	8000776c <tc_init+0x5c>
	 * We want: (1 / (fPBA / 8)) * RC = 10 ms, hence RC = (fPBA / 8) / 100
	 * to get an interrupt every 10 ms.
	 */
	//tc_write_rc(tc, EXAMPLE_TC_CHANNEL, (sysclk_get_pba_hz() / 8 / 100));
	
	tc_write_rc(tc, EXAMPLE_TC_CHANNEL, ((FOSC0*2) / 8 / 100));
80007736:	e0 6a 75 30 	mov	r10,30000
8000773a:	30 1b       	mov	r11,1
8000773c:	ee fc ff fc 	ld.w	r12,r7[-4]
80007740:	f0 1f 00 0c 	mcall	80007770 <tc_init+0x60>
	
	//tc_write_rc(tc, EXAMPLE_TC_CHANNEL, (FOSC0 / 8 / 100000));
	
	
	// configure the timer interrupt
	tc_configure_interrupts(tc, EXAMPLE_TC_CHANNEL, &tc_interrupt);
80007744:	48 ca       	lddpc	r10,80007774 <tc_init+0x64>
80007746:	30 1b       	mov	r11,1
80007748:	ee fc ff fc 	ld.w	r12,r7[-4]
8000774c:	f0 1f 00 0b 	mcall	80007778 <tc_init+0x68>
	// Start the timer/counter.
	tc_start(tc, EXAMPLE_TC_CHANNEL);
80007750:	30 1b       	mov	r11,1
80007752:	ee fc ff fc 	ld.w	r12,r7[-4]
80007756:	f0 1f 00 0a 	mcall	8000777c <tc_init+0x6c>
8000775a:	2f fd       	sub	sp,-4
8000775c:	e3 cd 80 80 	ldm	sp++,r7,pc
80007760:	80 00       	ld.sh	r0,r0[0x0]
80007762:	76 74       	ld.w	r4,r11[0x1c]
80007764:	80 00       	ld.sh	r0,r0[0x0]
80007766:	78 a4       	ld.w	r4,r12[0x28]
80007768:	80 01       	ld.sh	r1,r0[0x0]
8000776a:	12 64       	and	r4,r9
8000776c:	80 00       	ld.sh	r0,r0[0x0]
8000776e:	80 50       	ld.sh	r0,r0[0xa]
80007770:	80 00       	ld.sh	r0,r0[0x0]
80007772:	82 18       	ld.sh	r8,r1[0x2]
80007774:	80 01       	ld.sh	r1,r0[0x0]
80007776:	12 6c       	and	r12,r9
80007778:	80 00       	ld.sh	r0,r0[0x0]
8000777a:	7e 68       	ld.w	r8,pc[0x18]
8000777c:	80 00       	ld.sh	r0,r0[0x0]
8000777e:	81 a4       	st.w	r0[0x28],r4

80007780 <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
80007780:	eb cd 40 80 	pushm	r7,lr
80007784:	1a 97       	mov	r7,sp
	// Catch unregistered interrupts.
	while (true);
80007786:	c0 08       	rjmp	80007786 <_unhandled_interrupt+0x6>

80007788 <_get_interrupt_handler>:
 *
 * \return Interrupt handler to execute.
 */
__int_handler _get_interrupt_handler(uint32_t int_level);
__int_handler _get_interrupt_handler(uint32_t int_level)
{
80007788:	eb cd 40 80 	pushm	r7,lr
8000778c:	1a 97       	mov	r7,sp
8000778e:	20 3d       	sub	sp,12
80007790:	ef 4c ff f4 	st.w	r7[-12],r12
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
80007794:	fe 78 08 00 	mov	r8,-63488
80007798:	ee f9 ff f4 	ld.w	r9,r7[-12]
8000779c:	f2 09 11 03 	rsub	r9,r9,3
800077a0:	28 09       	sub	r9,-128
800077a2:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
800077a6:	ef 48 ff f8 	st.w	r7[-8],r8
	uint32_t int_req = AVR32_INTC.irr[int_grp];
800077aa:	fe 78 08 00 	mov	r8,-63488
800077ae:	ee f9 ff f8 	ld.w	r9,r7[-8]
800077b2:	2c 09       	sub	r9,-64
800077b4:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
800077b8:	ef 48 ff fc 	st.w	r7[-4],r8
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	
	return (int_req)
800077bc:	ee f8 ff fc 	ld.w	r8,r7[-4]
800077c0:	58 08       	cp.w	r8,0
800077c2:	c1 30       	breq	800077e8 <_get_interrupt_handler+0x60>
		? _int_handler_table[int_grp]._int_line_handler_table[32
800077c4:	ee f9 ff f8 	ld.w	r9,r7[-8]
800077c8:	48 b8       	lddpc	r8,800077f4 <_get_interrupt_handler+0x6c>
800077ca:	a1 79       	lsl	r9,0x1
800077cc:	2f f9       	sub	r9,-1
800077ce:	f0 09 03 29 	ld.w	r9,r8[r9<<0x2]
800077d2:	ee f8 ff fc 	ld.w	r8,r7[-4]
800077d6:	f0 08 12 00 	clz	r8,r8
800077da:	f0 08 11 1f 	rsub	r8,r8,31
			- clz(int_req) - 1]
800077de:	a3 68       	lsl	r8,0x2
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	
	return (int_req)
		? _int_handler_table[int_grp]._int_line_handler_table[32
800077e0:	f2 08 00 08 	add	r8,r9,r8
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	
	return (int_req)
800077e4:	70 08       	ld.w	r8,r8[0x0]
800077e6:	c0 28       	rjmp	800077ea <_get_interrupt_handler+0x62>
800077e8:	30 08       	mov	r8,0
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
800077ea:	10 9c       	mov	r12,r8
800077ec:	2f dd       	sub	sp,-12
800077ee:	e3 cd 80 80 	ldm	sp++,r7,pc
800077f2:	00 00       	add	r0,r0
800077f4:	80 01       	ld.sh	r1,r0[0x0]
800077f6:	12 70       	tst	r0,r9

800077f8 <INTC_init_evba>:
 * \internal
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
800077f8:	eb cd 40 80 	pushm	r7,lr
800077fc:	1a 97       	mov	r7,sp
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
800077fe:	48 38       	lddpc	r8,80007808 <INTC_init_evba+0x10>
80007800:	e3 b8 00 01 	mtsr	0x4,r8
}
80007804:	e3 cd 80 80 	ldm	sp++,r7,pc
80007808:	80 01       	ld.sh	r1,r0[0x0]
8000780a:	0a 00       	add	r0,r5

8000780c <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
8000780c:	eb cd 40 80 	pushm	r7,lr
80007810:	1a 97       	mov	r7,sp
80007812:	20 2d       	sub	sp,8
	uint32_t int_grp, int_req;

	INTC_init_evba();
80007814:	f0 1f 00 1f 	mcall	80007890 <INTC_init_interrupts+0x84>

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
80007818:	30 08       	mov	r8,0
8000781a:	ef 48 ff f8 	st.w	r7[-8],r8
8000781e:	c3 18       	rjmp	80007880 <INTC_init_interrupts+0x74>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80007820:	30 08       	mov	r8,0
80007822:	ef 48 ff fc 	st.w	r7[-4],r8
80007826:	c1 48       	rjmp	8000784e <INTC_init_interrupts+0x42>
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
80007828:	ee f9 ff f8 	ld.w	r9,r7[-8]
8000782c:	49 a8       	lddpc	r8,80007894 <INTC_init_interrupts+0x88>
8000782e:	a1 79       	lsl	r9,0x1
80007830:	2f f9       	sub	r9,-1
80007832:	f0 09 03 29 	ld.w	r9,r8[r9<<0x2]
80007836:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000783a:	a3 68       	lsl	r8,0x2
8000783c:	f2 08 00 08 	add	r8,r9,r8
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80007840:	49 69       	lddpc	r9,80007898 <INTC_init_interrupts+0x8c>
80007842:	91 09       	st.w	r8[0x0],r9
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
80007844:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007848:	2f f8       	sub	r8,-1
8000784a:	ef 48 ff fc 	st.w	r7[-4],r8
	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
8000784e:	ee f9 ff f8 	ld.w	r9,r7[-8]
80007852:	49 18       	lddpc	r8,80007894 <INTC_init_interrupts+0x88>
80007854:	f0 09 03 39 	ld.w	r9,r8[r9<<0x3]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80007858:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000785c:	10 39       	cp.w	r9,r8
8000785e:	fe 9b ff e5 	brhi	80007828 <INTC_init_interrupts+0x1c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80007862:	fe 78 08 00 	mov	r8,-63488
80007866:	ee f9 ff f8 	ld.w	r9,r7[-8]
8000786a:	48 db       	lddpc	r11,8000789c <INTC_init_interrupts+0x90>
8000786c:	48 da       	lddpc	r10,800078a0 <INTC_init_interrupts+0x94>
8000786e:	f6 0a 01 0a 	sub	r10,r11,r10
80007872:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
80007876:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000787a:	2f f8       	sub	r8,-1
8000787c:	ef 48 ff f8 	st.w	r7[-8],r8
80007880:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007884:	59 28       	cp.w	r8,18
80007886:	fe 98 ff cd 	brls	80007820 <INTC_init_interrupts+0x14>
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
	}
}
8000788a:	2f ed       	sub	sp,-8
8000788c:	e3 cd 80 80 	ldm	sp++,r7,pc
80007890:	80 00       	ld.sh	r0,r0[0x0]
80007892:	77 f8       	ld.w	r8,r11[0x7c]
80007894:	80 01       	ld.sh	r1,r0[0x0]
80007896:	12 70       	tst	r0,r9
80007898:	80 00       	ld.sh	r0,r0[0x0]
8000789a:	77 80       	ld.w	r0,r11[0x60]
8000789c:	80 01       	ld.sh	r1,r0[0x0]
8000789e:	0b 04       	ld.w	r4,r5++
800078a0:	80 01       	ld.sh	r1,r0[0x0]
800078a2:	0a 00       	add	r0,r5

800078a4 <INTC_register_interrupt>:
 *          be effective.
 *
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
800078a4:	eb cd 40 80 	pushm	r7,lr
800078a8:	1a 97       	mov	r7,sp
800078aa:	20 4d       	sub	sp,16
800078ac:	ef 4c ff f8 	st.w	r7[-8],r12
800078b0:	ef 4b ff f4 	st.w	r7[-12],r11
800078b4:	ef 4a ff f0 	st.w	r7[-16],r10
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
800078b8:	ee f8 ff f4 	ld.w	r8,r7[-12]
800078bc:	a5 98       	lsr	r8,0x5
800078be:	ef 48 ff fc 	st.w	r7[-4],r8

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
800078c2:	ee f9 ff fc 	ld.w	r9,r7[-4]
800078c6:	4a 78       	lddpc	r8,80007960 <INTC_register_interrupt+0xbc>
800078c8:	a1 79       	lsl	r9,0x1
800078ca:	2f f9       	sub	r9,-1
800078cc:	f0 09 03 29 	ld.w	r9,r8[r9<<0x2]
800078d0:	ee f8 ff f4 	ld.w	r8,r7[-12]
800078d4:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
800078d8:	a3 68       	lsl	r8,0x2
800078da:	f2 08 00 08 	add	r8,r9,r8
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
800078de:	ee f9 ff f8 	ld.w	r9,r7[-8]
800078e2:	91 09       	st.w	r8[0x0],r9
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
800078e4:	ee f8 ff f0 	ld.w	r8,r7[-16]
800078e8:	58 08       	cp.w	r8,0
800078ea:	c0 c1       	brne	80007902 <INTC_register_interrupt+0x5e>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
800078ec:	fe 78 08 00 	mov	r8,-63488
800078f0:	ee f9 ff fc 	ld.w	r9,r7[-4]
800078f4:	49 cb       	lddpc	r11,80007964 <INTC_register_interrupt+0xc0>
800078f6:	49 da       	lddpc	r10,80007968 <INTC_register_interrupt+0xc4>
800078f8:	f6 0a 01 0a 	sub	r10,r11,r10
800078fc:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
80007900:	c2 d8       	rjmp	8000795a <INTC_register_interrupt+0xb6>
	} else if (int_level == AVR32_INTC_INT1) {
80007902:	ee f8 ff f0 	ld.w	r8,r7[-16]
80007906:	58 18       	cp.w	r8,1
80007908:	c0 d1       	brne	80007922 <INTC_register_interrupt+0x7e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
8000790a:	fe 78 08 00 	mov	r8,-63488
8000790e:	ee f9 ff fc 	ld.w	r9,r7[-4]
80007912:	49 7b       	lddpc	r11,8000796c <INTC_register_interrupt+0xc8>
80007914:	49 5a       	lddpc	r10,80007968 <INTC_register_interrupt+0xc4>
80007916:	f6 0a 01 0a 	sub	r10,r11,r10
8000791a:	bf aa       	sbr	r10,0x1e
8000791c:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
80007920:	c1 d8       	rjmp	8000795a <INTC_register_interrupt+0xb6>
	} else if (int_level == AVR32_INTC_INT2) {
80007922:	ee f8 ff f0 	ld.w	r8,r7[-16]
80007926:	58 28       	cp.w	r8,2
80007928:	c0 d1       	brne	80007942 <INTC_register_interrupt+0x9e>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
8000792a:	fe 78 08 00 	mov	r8,-63488
8000792e:	ee f9 ff fc 	ld.w	r9,r7[-4]
80007932:	49 0b       	lddpc	r11,80007970 <INTC_register_interrupt+0xcc>
80007934:	48 da       	lddpc	r10,80007968 <INTC_register_interrupt+0xc4>
80007936:	f6 0a 01 0a 	sub	r10,r11,r10
8000793a:	bf ba       	sbr	r10,0x1f
8000793c:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
80007940:	c0 d8       	rjmp	8000795a <INTC_register_interrupt+0xb6>
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
80007942:	fe 78 08 00 	mov	r8,-63488
80007946:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000794a:	48 bb       	lddpc	r11,80007974 <INTC_register_interrupt+0xd0>
8000794c:	48 7a       	lddpc	r10,80007968 <INTC_register_interrupt+0xc4>
8000794e:	f6 0a 01 0a 	sub	r10,r11,r10
80007952:	ea 1a c0 00 	orh	r10,0xc000
80007956:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
	}
}
8000795a:	2f cd       	sub	sp,-16
8000795c:	e3 cd 80 80 	ldm	sp++,r7,pc
80007960:	80 01       	ld.sh	r1,r0[0x0]
80007962:	12 70       	tst	r0,r9
80007964:	80 01       	ld.sh	r1,r0[0x0]
80007966:	0b 04       	ld.w	r4,r5++
80007968:	80 01       	ld.sh	r1,r0[0x0]
8000796a:	0a 00       	add	r0,r5
8000796c:	80 01       	ld.sh	r1,r0[0x0]
8000796e:	0b 12       	ld.sh	r2,r5++
80007970:	80 01       	ld.sh	r1,r0[0x0]
80007972:	0b 20       	ld.uh	r0,r5++
80007974:	80 01       	ld.sh	r1,r0[0x0]
80007976:	0b 2e       	ld.uh	lr,r5++

80007978 <getBaudDiv>:
 * \return Divider or error code.
 *   \retval >=0  Success.
 *   \retval  <0  Error.
 */
static int getBaudDiv(const spi_options_t *options, unsigned int pba_hz)
{
80007978:	eb cd 40 80 	pushm	r7,lr
8000797c:	1a 97       	mov	r7,sp
8000797e:	20 3d       	sub	sp,12
80007980:	ef 4c ff f8 	st.w	r7[-8],r12
80007984:	ef 4b ff f4 	st.w	r7[-12],r11
  int baudDiv = (pba_hz + options->baudrate / 2) / options->baudrate;
80007988:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000798c:	70 18       	ld.w	r8,r8[0x4]
8000798e:	f0 09 16 01 	lsr	r9,r8,0x1
80007992:	ee f8 ff f4 	ld.w	r8,r7[-12]
80007996:	f2 08 00 08 	add	r8,r9,r8
8000799a:	ee f9 ff f8 	ld.w	r9,r7[-8]
8000799e:	72 19       	ld.w	r9,r9[0x4]
800079a0:	f0 09 0d 08 	divu	r8,r8,r9
800079a4:	ef 48 ff fc 	st.w	r7[-4],r8

  if (baudDiv <= 0 || baudDiv > 255) {
800079a8:	ee f8 ff fc 	ld.w	r8,r7[-4]
800079ac:	58 08       	cp.w	r8,0
800079ae:	e0 8a 00 08 	brle	800079be <getBaudDiv+0x46>
800079b2:	ee f8 ff fc 	ld.w	r8,r7[-4]
800079b6:	e0 48 00 ff 	cp.w	r8,255
800079ba:	e0 8a 00 04 	brle	800079c2 <getBaudDiv+0x4a>
    return -1;
800079be:	3f f8       	mov	r8,-1
800079c0:	c0 38       	rjmp	800079c6 <getBaudDiv+0x4e>
  }

  return baudDiv;
800079c2:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
800079c6:	10 9c       	mov	r12,r8
800079c8:	2f dd       	sub	sp,-12
800079ca:	e3 cd 80 80 	ldm	sp++,r7,pc

800079ce <spi_initMaster>:
  return SPI_OK;
}


spi_status_t spi_initMaster(volatile avr32_spi_t *spi, const spi_options_t *options)
{
800079ce:	eb cd 40 80 	pushm	r7,lr
800079d2:	1a 97       	mov	r7,sp
800079d4:	20 3d       	sub	sp,12
800079d6:	ef 4c ff f8 	st.w	r7[-8],r12
800079da:	ef 4b ff f4 	st.w	r7[-12],r11
  u_avr32_spi_mr_t u_avr32_spi_mr;

  if (options->modfdis > 1) {
800079de:	ee f8 ff f4 	ld.w	r8,r7[-12]
800079e2:	f1 39 00 0d 	ld.ub	r9,r8[13]
800079e6:	30 18       	mov	r8,1
800079e8:	f0 09 18 00 	cp.b	r9,r8
800079ec:	e0 88 00 04 	brls	800079f4 <spi_initMaster+0x26>
    return SPI_ERROR_ARGUMENT;
800079f0:	30 28       	mov	r8,2
800079f2:	c3 48       	rjmp	80007a5a <spi_initMaster+0x8c>
  }

  // Reset.
  spi->cr = AVR32_SPI_CR_SWRST_MASK;
800079f4:	ee f8 ff f8 	ld.w	r8,r7[-8]
800079f8:	e0 69 00 80 	mov	r9,128
800079fc:	91 09       	st.w	r8[0x0],r9

  // Master Mode.
  u_avr32_spi_mr.mr = spi->mr;
800079fe:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007a02:	70 18       	ld.w	r8,r8[0x4]
80007a04:	ef 48 ff fc 	st.w	r7[-4],r8
  u_avr32_spi_mr.MR.mstr = 1;
80007a08:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007a0c:	30 19       	mov	r9,1
80007a0e:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
80007a12:	ef 48 ff fc 	st.w	r7[-4],r8
  u_avr32_spi_mr.MR.modfdis = options->modfdis;
80007a16:	ee f8 ff f4 	ld.w	r8,r7[-12]
80007a1a:	f1 38 00 0d 	ld.ub	r8,r8[13]
80007a1e:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007a22:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
80007a26:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007a2a:	f1 d9 d0 81 	bfins	r8,r9,0x4,0x1
80007a2e:	ef 48 ff fc 	st.w	r7[-4],r8
  u_avr32_spi_mr.MR.llb = 0;
80007a32:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007a36:	30 09       	mov	r9,0
80007a38:	f1 d9 d0 e1 	bfins	r8,r9,0x7,0x1
80007a3c:	ef 48 ff fc 	st.w	r7[-4],r8
  u_avr32_spi_mr.MR.pcs = (1 << AVR32_SPI_MR_PCS_SIZE) - 1;
80007a40:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007a44:	30 f9       	mov	r9,15
80007a46:	f1 d9 d2 04 	bfins	r8,r9,0x10,0x4
80007a4a:	ef 48 ff fc 	st.w	r7[-4],r8
  spi->mr = u_avr32_spi_mr.mr;
80007a4e:	ee f9 ff fc 	ld.w	r9,r7[-4]
80007a52:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007a56:	91 19       	st.w	r8[0x4],r9

  return SPI_OK;
80007a58:	30 08       	mov	r8,0
}
80007a5a:	10 9c       	mov	r12,r8
80007a5c:	2f dd       	sub	sp,-12
80007a5e:	e3 cd 80 80 	ldm	sp++,r7,pc

80007a62 <spi_selectionMode>:

spi_status_t spi_selectionMode(volatile avr32_spi_t *spi,
                               unsigned char variable_ps,
                               unsigned char pcs_decode,
                               unsigned char delay)
{
80007a62:	eb cd 40 80 	pushm	r7,lr
80007a66:	1a 97       	mov	r7,sp
80007a68:	20 5d       	sub	sp,20
80007a6a:	ef 4c ff f8 	st.w	r7[-8],r12
80007a6e:	12 98       	mov	r8,r9
80007a70:	16 99       	mov	r9,r11
80007a72:	ef 69 ff f4 	st.b	r7[-12],r9
80007a76:	14 99       	mov	r9,r10
80007a78:	ef 69 ff f0 	st.b	r7[-16],r9
80007a7c:	ef 68 ff ec 	st.b	r7[-20],r8
  u_avr32_spi_mr_t u_avr32_spi_mr;

  if (variable_ps > 1 ||
80007a80:	ef 39 ff f4 	ld.ub	r9,r7[-12]
80007a84:	30 18       	mov	r8,1
80007a86:	f0 09 18 00 	cp.b	r9,r8
80007a8a:	e0 8b 00 09 	brhi	80007a9c <spi_selectionMode+0x3a>
80007a8e:	ef 39 ff f0 	ld.ub	r9,r7[-16]
80007a92:	30 18       	mov	r8,1
80007a94:	f0 09 18 00 	cp.b	r9,r8
80007a98:	e0 88 00 04 	brls	80007aa0 <spi_selectionMode+0x3e>
      pcs_decode > 1) {
    return SPI_ERROR_ARGUMENT;
80007a9c:	30 28       	mov	r8,2
80007a9e:	c2 88       	rjmp	80007aee <spi_selectionMode+0x8c>
  }

  u_avr32_spi_mr.mr = spi->mr;
80007aa0:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007aa4:	70 18       	ld.w	r8,r8[0x4]
80007aa6:	ef 48 ff fc 	st.w	r7[-4],r8
  u_avr32_spi_mr.MR.ps = variable_ps;
80007aaa:	ef 38 ff f4 	ld.ub	r8,r7[-12]
80007aae:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007ab2:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
80007ab6:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007aba:	f1 d9 d0 21 	bfins	r8,r9,0x1,0x1
80007abe:	ef 48 ff fc 	st.w	r7[-4],r8
  u_avr32_spi_mr.MR.pcsdec = pcs_decode;
80007ac2:	ef 38 ff f0 	ld.ub	r8,r7[-16]
80007ac6:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007aca:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
80007ace:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007ad2:	f1 d9 d0 41 	bfins	r8,r9,0x2,0x1
80007ad6:	ef 48 ff fc 	st.w	r7[-4],r8
  u_avr32_spi_mr.MR.dlybcs = delay;
80007ada:	ef 38 ff ec 	ld.ub	r8,r7[-20]
80007ade:	ef 68 ff fc 	st.b	r7[-4],r8
  spi->mr = u_avr32_spi_mr.mr;
80007ae2:	ee f9 ff fc 	ld.w	r9,r7[-4]
80007ae6:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007aea:	91 19       	st.w	r8[0x4],r9

  return SPI_OK;
80007aec:	30 08       	mov	r8,0
}
80007aee:	10 9c       	mov	r12,r8
80007af0:	2f bd       	sub	sp,-20
80007af2:	e3 cd 80 80 	ldm	sp++,r7,pc

80007af6 <spi_selectChip>:


spi_status_t spi_selectChip(volatile avr32_spi_t *spi, unsigned char chip)
{
80007af6:	eb cd 40 80 	pushm	r7,lr
80007afa:	1a 97       	mov	r7,sp
80007afc:	20 2d       	sub	sp,8
80007afe:	ef 4c ff fc 	st.w	r7[-4],r12
80007b02:	16 98       	mov	r8,r11
80007b04:	ef 68 ff f8 	st.b	r7[-8],r8
   */
  while (pdFALSE == xSemaphoreTake(xSPIMutex, 20));
#endif

  // Assert all lines; no peripheral is selected.
  spi->mr |= AVR32_SPI_MR_PCS_MASK;
80007b08:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007b0c:	70 18       	ld.w	r8,r8[0x4]
80007b0e:	10 99       	mov	r9,r8
80007b10:	ea 19 00 0f 	orh	r9,0xf
80007b14:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007b18:	91 19       	st.w	r8[0x4],r9

  if (spi->mr & AVR32_SPI_MR_PCSDEC_MASK) {
80007b1a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007b1e:	70 18       	ld.w	r8,r8[0x4]
80007b20:	e2 18 00 04 	andl	r8,0x4,COH
80007b24:	c1 90       	breq	80007b56 <spi_selectChip+0x60>
    // The signal is decoded; allow up to 15 chips.
    if (chip > 14) {
80007b26:	ef 39 ff f8 	ld.ub	r9,r7[-8]
80007b2a:	30 e8       	mov	r8,14
80007b2c:	f0 09 18 00 	cp.b	r9,r8
80007b30:	e0 88 00 04 	brls	80007b38 <spi_selectChip+0x42>
      return SPI_ERROR_ARGUMENT;
80007b34:	30 28       	mov	r8,2
80007b36:	c2 88       	rjmp	80007b86 <spi_selectChip+0x90>
    }

    spi->mr &= ~AVR32_SPI_MR_PCS_MASK | (chip << AVR32_SPI_MR_PCS_OFFSET);
80007b38:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007b3c:	70 19       	ld.w	r9,r8[0x4]
80007b3e:	ef 38 ff f8 	ld.ub	r8,r7[-8]
80007b42:	b1 68       	lsl	r8,0x10
80007b44:	ea 18 ff f0 	orh	r8,0xfff0
80007b48:	e8 18 ff ff 	orl	r8,0xffff
80007b4c:	10 69       	and	r9,r8
80007b4e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007b52:	91 19       	st.w	r8[0x4],r9
80007b54:	c1 88       	rjmp	80007b84 <spi_selectChip+0x8e>
  } else {
    if (chip > 3) {
80007b56:	ef 39 ff f8 	ld.ub	r9,r7[-8]
80007b5a:	30 38       	mov	r8,3
80007b5c:	f0 09 18 00 	cp.b	r9,r8
80007b60:	e0 88 00 04 	brls	80007b68 <spi_selectChip+0x72>
      return SPI_ERROR_ARGUMENT;
80007b64:	30 28       	mov	r8,2
80007b66:	c1 08       	rjmp	80007b86 <spi_selectChip+0x90>
    }

    spi->mr &= ~(1 << (AVR32_SPI_MR_PCS_OFFSET + chip));
80007b68:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007b6c:	70 19       	ld.w	r9,r8[0x4]
80007b6e:	ef 38 ff f8 	ld.ub	r8,r7[-8]
80007b72:	2f 08       	sub	r8,-16
80007b74:	30 1a       	mov	r10,1
80007b76:	f4 08 09 48 	lsl	r8,r10,r8
80007b7a:	5c d8       	com	r8
80007b7c:	10 69       	and	r9,r8
80007b7e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007b82:	91 19       	st.w	r8[0x4],r9
  }

  return SPI_OK;
80007b84:	30 08       	mov	r8,0
}
80007b86:	10 9c       	mov	r12,r8
80007b88:	2f ed       	sub	sp,-8
80007b8a:	e3 cd 80 80 	ldm	sp++,r7,pc

80007b8e <spi_unselectChip>:


spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, unsigned char chip)
{
80007b8e:	eb cd 40 80 	pushm	r7,lr
80007b92:	1a 97       	mov	r7,sp
80007b94:	20 3d       	sub	sp,12
80007b96:	ef 4c ff f8 	st.w	r7[-8],r12
80007b9a:	16 98       	mov	r8,r11
80007b9c:	ef 68 ff f4 	st.b	r7[-12],r8
  unsigned int timeout = SPI_TIMEOUT;
80007ba0:	e0 68 27 10 	mov	r8,10000
80007ba4:	ef 48 ff fc 	st.w	r7[-4],r8

  while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
80007ba8:	c0 f8       	rjmp	80007bc6 <spi_unselectChip+0x38>
    if (!timeout--) {
80007baa:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007bae:	58 08       	cp.w	r8,0
80007bb0:	5f 08       	sreq	r8
80007bb2:	5c 58       	castu.b	r8
80007bb4:	ee f9 ff fc 	ld.w	r9,r7[-4]
80007bb8:	20 19       	sub	r9,1
80007bba:	ef 49 ff fc 	st.w	r7[-4],r9
80007bbe:	58 08       	cp.w	r8,0
80007bc0:	c0 30       	breq	80007bc6 <spi_unselectChip+0x38>
      return SPI_ERROR_TIMEOUT;
80007bc2:	30 18       	mov	r8,1
80007bc4:	c1 68       	rjmp	80007bf0 <spi_unselectChip+0x62>

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, unsigned char chip)
{
  unsigned int timeout = SPI_TIMEOUT;

  while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
80007bc6:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007bca:	70 48       	ld.w	r8,r8[0x10]
80007bcc:	e2 18 02 00 	andl	r8,0x200,COH
80007bd0:	ce d0       	breq	80007baa <spi_unselectChip+0x1c>
      return SPI_ERROR_TIMEOUT;
    }
  }

  // Assert all lines; no peripheral is selected.
  spi->mr |= AVR32_SPI_MR_PCS_MASK;
80007bd2:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007bd6:	70 18       	ld.w	r8,r8[0x4]
80007bd8:	10 99       	mov	r9,r8
80007bda:	ea 19 00 0f 	orh	r9,0xf
80007bde:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007be2:	91 19       	st.w	r8[0x4],r9

  // Last transfer, so deassert the current NPCS if CSAAT is set.
  spi->cr = AVR32_SPI_CR_LASTXFER_MASK;
80007be4:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007be8:	fc 19 01 00 	movh	r9,0x100
80007bec:	91 09       	st.w	r8[0x0],r9

#ifdef FREERTOS_USED
  xSemaphoreGive(xSPIMutex);
#endif

  return SPI_OK;
80007bee:	30 08       	mov	r8,0
}
80007bf0:	10 9c       	mov	r12,r8
80007bf2:	2f dd       	sub	sp,-12
80007bf4:	e3 cd 80 80 	ldm	sp++,r7,pc

80007bf8 <spi_setupChipReg>:


spi_status_t spi_setupChipReg(volatile avr32_spi_t *spi,
                              const spi_options_t *options,
                              unsigned int pba_hz)
{
80007bf8:	eb cd 40 80 	pushm	r7,lr
80007bfc:	1a 97       	mov	r7,sp
80007bfe:	20 5d       	sub	sp,20
80007c00:	ef 4c ff f4 	st.w	r7[-12],r12
80007c04:	ef 4b ff f0 	st.w	r7[-16],r11
80007c08:	ef 4a ff ec 	st.w	r7[-20],r10
  u_avr32_spi_csr_t u_avr32_spi_csr;

  if (options->spi_mode > 3 ||
80007c0c:	ee f8 ff f0 	ld.w	r8,r7[-16]
80007c10:	f1 39 00 0c 	ld.ub	r9,r8[12]
80007c14:	30 38       	mov	r8,3
80007c16:	f0 09 18 00 	cp.b	r9,r8
80007c1a:	e0 8b 00 1d 	brhi	80007c54 <spi_setupChipReg+0x5c>
      options->stay_act > 1 ||
80007c1e:	ee f8 ff f0 	ld.w	r8,r7[-16]
80007c22:	f1 39 00 0b 	ld.ub	r9,r8[11]
                              const spi_options_t *options,
                              unsigned int pba_hz)
{
  u_avr32_spi_csr_t u_avr32_spi_csr;

  if (options->spi_mode > 3 ||
80007c26:	30 18       	mov	r8,1
80007c28:	f0 09 18 00 	cp.b	r9,r8
80007c2c:	e0 8b 00 14 	brhi	80007c54 <spi_setupChipReg+0x5c>
      options->stay_act > 1 ||
      options->bits < 8 || options->bits > 16) {
80007c30:	ee f8 ff f0 	ld.w	r8,r7[-16]
80007c34:	f1 39 00 08 	ld.ub	r9,r8[8]
                              const spi_options_t *options,
                              unsigned int pba_hz)
{
  u_avr32_spi_csr_t u_avr32_spi_csr;

  if (options->spi_mode > 3 ||
80007c38:	30 78       	mov	r8,7
80007c3a:	f0 09 18 00 	cp.b	r9,r8
80007c3e:	e0 88 00 0b 	brls	80007c54 <spi_setupChipReg+0x5c>
      options->stay_act > 1 ||
      options->bits < 8 || options->bits > 16) {
80007c42:	ee f8 ff f0 	ld.w	r8,r7[-16]
80007c46:	f1 39 00 08 	ld.ub	r9,r8[8]
                              const spi_options_t *options,
                              unsigned int pba_hz)
{
  u_avr32_spi_csr_t u_avr32_spi_csr;

  if (options->spi_mode > 3 ||
80007c4a:	31 08       	mov	r8,16
80007c4c:	f0 09 18 00 	cp.b	r9,r8
80007c50:	e0 88 00 04 	brls	80007c58 <spi_setupChipReg+0x60>
      options->stay_act > 1 ||
      options->bits < 8 || options->bits > 16) {
    return SPI_ERROR_ARGUMENT;
80007c54:	30 28       	mov	r8,2
80007c56:	c8 b8       	rjmp	80007d6c <spi_setupChipReg+0x174>
  }

  int baudDiv = getBaudDiv(options, pba_hz);
80007c58:	ee fb ff ec 	ld.w	r11,r7[-20]
80007c5c:	ee fc ff f0 	ld.w	r12,r7[-16]
80007c60:	f0 1f 00 45 	mcall	80007d74 <spi_setupChipReg+0x17c>
80007c64:	18 98       	mov	r8,r12
80007c66:	ef 48 ff fc 	st.w	r7[-4],r8

  if (baudDiv < 0) {
80007c6a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007c6e:	58 08       	cp.w	r8,0
80007c70:	c0 34       	brge	80007c76 <spi_setupChipReg+0x7e>
    return SPI_ERROR_ARGUMENT;
80007c72:	30 28       	mov	r8,2
80007c74:	c7 c8       	rjmp	80007d6c <spi_setupChipReg+0x174>
  }

  // Will use CSR0 offsets; these are the same for CSR0 to CSR3.
  u_avr32_spi_csr.csr = 0;
80007c76:	30 08       	mov	r8,0
80007c78:	ef 48 ff f8 	st.w	r7[-8],r8
  u_avr32_spi_csr.CSR.cpol = options->spi_mode >> 1;
80007c7c:	ee f8 ff f0 	ld.w	r8,r7[-16]
80007c80:	f1 38 00 0c 	ld.ub	r8,r8[12]
80007c84:	a1 98       	lsr	r8,0x1
80007c86:	5c 58       	castu.b	r8
80007c88:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007c8c:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
80007c90:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007c94:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
80007c98:	ef 48 ff f8 	st.w	r7[-8],r8
  u_avr32_spi_csr.CSR.ncpha = (options->spi_mode & 0x1) ^ 0x1;
80007c9c:	ee f8 ff f0 	ld.w	r8,r7[-16]
80007ca0:	f1 38 00 0c 	ld.ub	r8,r8[12]
80007ca4:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007ca8:	5f 08       	sreq	r8
80007caa:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
80007cae:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007cb2:	f1 d9 d0 21 	bfins	r8,r9,0x1,0x1
80007cb6:	ef 48 ff f8 	st.w	r7[-8],r8
  u_avr32_spi_csr.CSR.csaat = options->stay_act;
80007cba:	ee f8 ff f0 	ld.w	r8,r7[-16]
80007cbe:	f1 38 00 0b 	ld.ub	r8,r8[11]
80007cc2:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007cc6:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
80007cca:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007cce:	f1 d9 d0 61 	bfins	r8,r9,0x3,0x1
80007cd2:	ef 48 ff f8 	st.w	r7[-8],r8
  u_avr32_spi_csr.CSR.bits = options->bits - 8;
80007cd6:	ee f8 ff f0 	ld.w	r8,r7[-16]
80007cda:	f1 38 00 08 	ld.ub	r8,r8[8]
80007cde:	20 88       	sub	r8,8
80007ce0:	5c 58       	castu.b	r8
80007ce2:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
80007ce6:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
80007cea:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007cee:	f1 d9 d0 84 	bfins	r8,r9,0x4,0x4
80007cf2:	ef 48 ff f8 	st.w	r7[-8],r8
  u_avr32_spi_csr.CSR.scbr = baudDiv;
80007cf6:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007cfa:	5c 58       	castu.b	r8
80007cfc:	ef 68 ff fa 	st.b	r7[-6],r8
  u_avr32_spi_csr.CSR.dlybs = options->spck_delay;
80007d00:	ee f8 ff f0 	ld.w	r8,r7[-16]
80007d04:	f1 38 00 09 	ld.ub	r8,r8[9]
80007d08:	ef 68 ff f9 	st.b	r7[-7],r8
  u_avr32_spi_csr.CSR.dlybct = options->trans_delay;
80007d0c:	ee f8 ff f0 	ld.w	r8,r7[-16]
80007d10:	f1 38 00 0a 	ld.ub	r8,r8[10]
80007d14:	ef 68 ff f8 	st.b	r7[-8],r8

  switch(options->reg) {
80007d18:	ee f8 ff f0 	ld.w	r8,r7[-16]
80007d1c:	11 88       	ld.ub	r8,r8[0x0]
80007d1e:	58 18       	cp.w	r8,1
80007d20:	c1 10       	breq	80007d42 <spi_setupChipReg+0x14a>
80007d22:	e0 89 00 05 	brgt	80007d2c <spi_setupChipReg+0x134>
80007d26:	58 08       	cp.w	r8,0
80007d28:	c0 70       	breq	80007d36 <spi_setupChipReg+0x13e>
80007d2a:	c1 e8       	rjmp	80007d66 <spi_setupChipReg+0x16e>
80007d2c:	58 28       	cp.w	r8,2
80007d2e:	c1 00       	breq	80007d4e <spi_setupChipReg+0x156>
80007d30:	58 38       	cp.w	r8,3
80007d32:	c1 40       	breq	80007d5a <spi_setupChipReg+0x162>
80007d34:	c1 98       	rjmp	80007d66 <spi_setupChipReg+0x16e>
    case 0:
      spi->csr0 = u_avr32_spi_csr.csr;
80007d36:	ee f9 ff f8 	ld.w	r9,r7[-8]
80007d3a:	ee f8 ff f4 	ld.w	r8,r7[-12]
80007d3e:	91 c9       	st.w	r8[0x30],r9
      break;
80007d40:	c1 58       	rjmp	80007d6a <spi_setupChipReg+0x172>
    case 1:
      spi->csr1 = u_avr32_spi_csr.csr;
80007d42:	ee f9 ff f8 	ld.w	r9,r7[-8]
80007d46:	ee f8 ff f4 	ld.w	r8,r7[-12]
80007d4a:	91 d9       	st.w	r8[0x34],r9
      break;
80007d4c:	c0 f8       	rjmp	80007d6a <spi_setupChipReg+0x172>
    case 2:
      spi->csr2 = u_avr32_spi_csr.csr;
80007d4e:	ee f9 ff f8 	ld.w	r9,r7[-8]
80007d52:	ee f8 ff f4 	ld.w	r8,r7[-12]
80007d56:	91 e9       	st.w	r8[0x38],r9
      break;
80007d58:	c0 98       	rjmp	80007d6a <spi_setupChipReg+0x172>
    case 3:
      spi->csr3 = u_avr32_spi_csr.csr;
80007d5a:	ee f9 ff f8 	ld.w	r9,r7[-8]
80007d5e:	ee f8 ff f4 	ld.w	r8,r7[-12]
80007d62:	91 f9       	st.w	r8[0x3c],r9
      break;
80007d64:	c0 38       	rjmp	80007d6a <spi_setupChipReg+0x172>
    default:
      return SPI_ERROR_ARGUMENT;
80007d66:	30 28       	mov	r8,2
80007d68:	c0 28       	rjmp	80007d6c <spi_setupChipReg+0x174>
      while(1);
    }
  }
#endif

  return SPI_OK;
80007d6a:	30 08       	mov	r8,0
}
80007d6c:	10 9c       	mov	r12,r8
80007d6e:	2f bd       	sub	sp,-20
80007d70:	e3 cd 80 80 	ldm	sp++,r7,pc
80007d74:	80 00       	ld.sh	r0,r0[0x0]
80007d76:	79 78       	ld.w	r8,r12[0x5c]

80007d78 <spi_enable>:


void spi_enable(volatile avr32_spi_t *spi)
{
80007d78:	eb cd 40 80 	pushm	r7,lr
80007d7c:	1a 97       	mov	r7,sp
80007d7e:	20 1d       	sub	sp,4
80007d80:	ef 4c ff fc 	st.w	r7[-4],r12
  spi->cr = AVR32_SPI_CR_SPIEN_MASK;
80007d84:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007d88:	30 19       	mov	r9,1
80007d8a:	91 09       	st.w	r8[0x0],r9
}
80007d8c:	2f fd       	sub	sp,-4
80007d8e:	e3 cd 80 80 	ldm	sp++,r7,pc

80007d92 <spi_write>:
  return ((spi->sr & AVR32_SPI_SR_TDRE_MASK) != 0);
}


spi_status_t spi_write(volatile avr32_spi_t *spi, unsigned short data)
{
80007d92:	eb cd 40 80 	pushm	r7,lr
80007d96:	1a 97       	mov	r7,sp
80007d98:	20 3d       	sub	sp,12
80007d9a:	ef 4c ff f8 	st.w	r7[-8],r12
80007d9e:	16 98       	mov	r8,r11
80007da0:	ef 58 ff f4 	st.h	r7[-12],r8
  unsigned int timeout = SPI_TIMEOUT;
80007da4:	e0 68 27 10 	mov	r8,10000
80007da8:	ef 48 ff fc 	st.w	r7[-4],r8

  while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80007dac:	c0 f8       	rjmp	80007dca <spi_write+0x38>
    if (!timeout--) {
80007dae:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007db2:	58 08       	cp.w	r8,0
80007db4:	5f 08       	sreq	r8
80007db6:	5c 58       	castu.b	r8
80007db8:	ee f9 ff fc 	ld.w	r9,r7[-4]
80007dbc:	20 19       	sub	r9,1
80007dbe:	ef 49 ff fc 	st.w	r7[-4],r9
80007dc2:	58 08       	cp.w	r8,0
80007dc4:	c0 30       	breq	80007dca <spi_write+0x38>
      return SPI_ERROR_TIMEOUT;
80007dc6:	30 18       	mov	r8,1
80007dc8:	c0 d8       	rjmp	80007de2 <spi_write+0x50>

spi_status_t spi_write(volatile avr32_spi_t *spi, unsigned short data)
{
  unsigned int timeout = SPI_TIMEOUT;

  while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80007dca:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007dce:	70 48       	ld.w	r8,r8[0x10]
80007dd0:	e2 18 00 02 	andl	r8,0x2,COH
80007dd4:	ce d0       	breq	80007dae <spi_write+0x1c>
    if (!timeout--) {
      return SPI_ERROR_TIMEOUT;
    }
  }

  spi->tdr = data << AVR32_SPI_TDR_TD_OFFSET;
80007dd6:	ef 19 ff f4 	ld.uh	r9,r7[-12]
80007dda:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007dde:	91 39       	st.w	r8[0xc],r9

  return SPI_OK;
80007de0:	30 08       	mov	r8,0
}
80007de2:	10 9c       	mov	r12,r8
80007de4:	2f dd       	sub	sp,-12
80007de6:	e3 cd 80 80 	ldm	sp++,r7,pc

80007dea <spi_read>:
  return ((spi->sr & AVR32_SPI_SR_RDRF_MASK) != 0);
}


spi_status_t spi_read(volatile avr32_spi_t *spi, unsigned short *data)
{
80007dea:	eb cd 40 80 	pushm	r7,lr
80007dee:	1a 97       	mov	r7,sp
80007df0:	20 3d       	sub	sp,12
80007df2:	ef 4c ff f8 	st.w	r7[-8],r12
80007df6:	ef 4b ff f4 	st.w	r7[-12],r11
  unsigned int timeout = SPI_TIMEOUT;
80007dfa:	e0 68 27 10 	mov	r8,10000
80007dfe:	ef 48 ff fc 	st.w	r7[-4],r8

  while ((spi->sr & (AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) !=
80007e02:	c0 f8       	rjmp	80007e20 <spi_read+0x36>
         (AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) {
    if (!timeout--) {
80007e04:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007e08:	58 08       	cp.w	r8,0
80007e0a:	5f 08       	sreq	r8
80007e0c:	5c 58       	castu.b	r8
80007e0e:	ee f9 ff fc 	ld.w	r9,r7[-4]
80007e12:	20 19       	sub	r9,1
80007e14:	ef 49 ff fc 	st.w	r7[-4],r9
80007e18:	58 08       	cp.w	r8,0
80007e1a:	c0 30       	breq	80007e20 <spi_read+0x36>
      return SPI_ERROR_TIMEOUT;
80007e1c:	30 18       	mov	r8,1
80007e1e:	c1 18       	rjmp	80007e40 <spi_read+0x56>

spi_status_t spi_read(volatile avr32_spi_t *spi, unsigned short *data)
{
  unsigned int timeout = SPI_TIMEOUT;

  while ((spi->sr & (AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) !=
80007e20:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007e24:	70 48       	ld.w	r8,r8[0x10]
80007e26:	e2 18 02 01 	andl	r8,0x201,COH
80007e2a:	e0 48 02 01 	cp.w	r8,513
80007e2e:	ce b1       	brne	80007e04 <spi_read+0x1a>
    if (!timeout--) {
      return SPI_ERROR_TIMEOUT;
    }
  }

  *data = spi->rdr >> AVR32_SPI_RDR_RD_OFFSET;
80007e30:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007e34:	70 28       	ld.w	r8,r8[0x8]
80007e36:	5c 88       	casts.h	r8
80007e38:	ee f9 ff f4 	ld.w	r9,r7[-12]
80007e3c:	b2 08       	st.h	r9[0x0],r8

  return SPI_OK;
80007e3e:	30 08       	mov	r8,0
}
80007e40:	10 9c       	mov	r12,r8
80007e42:	2f dd       	sub	sp,-12
80007e44:	e3 cd 80 80 	ldm	sp++,r7,pc

80007e48 <cpu_irq_is_enabled_flags>:

	return flags;
}

static inline bool cpu_irq_is_enabled_flags(irqflags_t flags)
{
80007e48:	eb cd 40 80 	pushm	r7,lr
80007e4c:	1a 97       	mov	r7,sp
80007e4e:	20 1d       	sub	sp,4
80007e50:	ef 4c ff fc 	st.w	r7[-4],r12
	return !(flags & AVR32_SR_GM_MASK);
80007e54:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007e58:	e6 18 00 01 	andh	r8,0x1,COH
80007e5c:	5f 08       	sreq	r8
80007e5e:	5c 58       	castu.b	r8
}
80007e60:	10 9c       	mov	r12,r8
80007e62:	2f fd       	sub	sp,-4
80007e64:	e3 cd 80 80 	ldm	sp++,r7,pc

80007e68 <tc_configure_interrupts>:
  return tc->channel[channel].imr;
}


int tc_configure_interrupts(volatile avr32_tc_t *tc, unsigned int channel, const tc_interrupt_t *bitfield)
{
80007e68:	eb cd 40 80 	pushm	r7,lr
80007e6c:	1a 97       	mov	r7,sp
80007e6e:	20 4d       	sub	sp,16
80007e70:	ef 4c ff f8 	st.w	r7[-8],r12
80007e74:	ef 4b ff f4 	st.w	r7[-12],r11
80007e78:	ef 4a ff f0 	st.w	r7[-16],r10
  bool global_interrupt_enabled = Is_global_interrupt_enabled();
80007e7c:	e1 b8 00 00 	mfsr	r8,0x0
80007e80:	10 9c       	mov	r12,r8
80007e82:	f0 1f 00 73 	mcall	8000804c <tc_configure_interrupts+0x1e4>
80007e86:	18 98       	mov	r8,r12
80007e88:	ef 68 ff ff 	st.b	r7[-1],r8

  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80007e8c:	ee f8 ff f4 	ld.w	r8,r7[-12]
80007e90:	58 28       	cp.w	r8,2
80007e92:	e0 88 00 04 	brls	80007e9a <tc_configure_interrupts+0x32>
    return TC_INVALID_ARGUMENT;
80007e96:	3f f8       	mov	r8,-1
80007e98:	cd 68       	rjmp	80008044 <tc_configure_interrupts+0x1dc>

  // Enable the appropriate interrupts.
  tc->channel[channel].ier = bitfield->etrgs << AVR32_TC_ETRGS_OFFSET |
80007e9a:	ee fb ff f4 	ld.w	r11,r7[-12]
80007e9e:	ee f8 ff f0 	ld.w	r8,r7[-16]
80007ea2:	70 08       	ld.w	r8,r8[0x0]
80007ea4:	f1 d8 c0 e1 	bfextu	r8,r8,0x7,0x1
80007ea8:	5c 58       	castu.b	r8
80007eaa:	f0 09 15 07 	lsl	r9,r8,0x7
                             bitfield->ldrbs << AVR32_TC_LDRBS_OFFSET |
80007eae:	ee f8 ff f0 	ld.w	r8,r7[-16]
80007eb2:	70 08       	ld.w	r8,r8[0x0]
80007eb4:	f1 d8 c0 c1 	bfextu	r8,r8,0x6,0x1
80007eb8:	5c 58       	castu.b	r8
80007eba:	a7 68       	lsl	r8,0x6
80007ebc:	10 49       	or	r9,r8
                             bitfield->ldras << AVR32_TC_LDRAS_OFFSET |
80007ebe:	ee f8 ff f0 	ld.w	r8,r7[-16]
80007ec2:	70 08       	ld.w	r8,r8[0x0]
80007ec4:	f1 d8 c0 a1 	bfextu	r8,r8,0x5,0x1
80007ec8:	5c 58       	castu.b	r8
80007eca:	a5 78       	lsl	r8,0x5
80007ecc:	10 49       	or	r9,r8
                             bitfield->cpcs << AVR32_TC_CPCS_OFFSET |
80007ece:	ee f8 ff f0 	ld.w	r8,r7[-16]
80007ed2:	70 08       	ld.w	r8,r8[0x0]
80007ed4:	f1 d8 c0 81 	bfextu	r8,r8,0x4,0x1
80007ed8:	5c 58       	castu.b	r8
80007eda:	a5 68       	lsl	r8,0x4
80007edc:	10 49       	or	r9,r8
                             bitfield->cpbs << AVR32_TC_CPBS_OFFSET |
80007ede:	ee f8 ff f0 	ld.w	r8,r7[-16]
80007ee2:	70 08       	ld.w	r8,r8[0x0]
80007ee4:	f1 d8 c0 61 	bfextu	r8,r8,0x3,0x1
80007ee8:	5c 58       	castu.b	r8
80007eea:	a3 78       	lsl	r8,0x3
80007eec:	10 49       	or	r9,r8
                             bitfield->cpas << AVR32_TC_CPAS_OFFSET |
80007eee:	ee f8 ff f0 	ld.w	r8,r7[-16]
80007ef2:	70 08       	ld.w	r8,r8[0x0]
80007ef4:	f1 d8 c0 41 	bfextu	r8,r8,0x2,0x1
80007ef8:	5c 58       	castu.b	r8
80007efa:	a3 68       	lsl	r8,0x2
80007efc:	10 49       	or	r9,r8
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
80007efe:	ee f8 ff f0 	ld.w	r8,r7[-16]
80007f02:	70 08       	ld.w	r8,r8[0x0]
80007f04:	f1 d8 c0 21 	bfextu	r8,r8,0x1,0x1
80007f08:	5c 58       	castu.b	r8
80007f0a:	a1 78       	lsl	r8,0x1
80007f0c:	10 49       	or	r9,r8
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;
80007f0e:	ee f8 ff f0 	ld.w	r8,r7[-16]
80007f12:	70 08       	ld.w	r8,r8[0x0]
80007f14:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007f18:	5c 58       	castu.b	r8
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
    return TC_INVALID_ARGUMENT;

  // Enable the appropriate interrupts.
  tc->channel[channel].ier = bitfield->etrgs << AVR32_TC_ETRGS_OFFSET |
80007f1a:	f3 e8 10 08 	or	r8,r9,r8
80007f1e:	10 99       	mov	r9,r8
80007f20:	ee fa ff f8 	ld.w	r10,r7[-8]
80007f24:	f6 08 15 06 	lsl	r8,r11,0x6
80007f28:	f4 08 00 08 	add	r8,r10,r8
80007f2c:	2d c8       	sub	r8,-36
80007f2e:	91 09       	st.w	r8[0x0],r9
                             bitfield->cpas << AVR32_TC_CPAS_OFFSET |
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;

  // Disable the appropriate interrupts.
  if (global_interrupt_enabled) Disable_global_interrupt();
80007f30:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80007f34:	30 08       	mov	r8,0
80007f36:	f0 09 18 00 	cp.b	r9,r8
80007f3a:	c0 20       	breq	80007f3e <tc_configure_interrupts+0xd6>
80007f3c:	d3 03       	ssrf	0x10
  tc->channel[channel].idr = (~bitfield->etrgs & 1) << AVR32_TC_ETRGS_OFFSET |
80007f3e:	ee fb ff f4 	ld.w	r11,r7[-12]
80007f42:	ee f8 ff f0 	ld.w	r8,r7[-16]
80007f46:	70 08       	ld.w	r8,r8[0x0]
80007f48:	f1 d8 c0 e1 	bfextu	r8,r8,0x7,0x1
80007f4c:	5c 58       	castu.b	r8
80007f4e:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007f52:	c0 41       	brne	80007f5a <tc_configure_interrupts+0xf2>
80007f54:	e0 69 00 80 	mov	r9,128
80007f58:	c0 28       	rjmp	80007f5c <tc_configure_interrupts+0xf4>
80007f5a:	30 09       	mov	r9,0
                             (~bitfield->ldrbs & 1) << AVR32_TC_LDRBS_OFFSET |
80007f5c:	ee f8 ff f0 	ld.w	r8,r7[-16]
80007f60:	70 08       	ld.w	r8,r8[0x0]
80007f62:	f1 d8 c0 c1 	bfextu	r8,r8,0x6,0x1
80007f66:	5c 58       	castu.b	r8
80007f68:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007f6c:	c0 31       	brne	80007f72 <tc_configure_interrupts+0x10a>
80007f6e:	34 08       	mov	r8,64
80007f70:	c0 28       	rjmp	80007f74 <tc_configure_interrupts+0x10c>
80007f72:	30 08       	mov	r8,0
80007f74:	10 49       	or	r9,r8
                             (~bitfield->ldras & 1) << AVR32_TC_LDRAS_OFFSET |
80007f76:	ee f8 ff f0 	ld.w	r8,r7[-16]
80007f7a:	70 08       	ld.w	r8,r8[0x0]
80007f7c:	f1 d8 c0 a1 	bfextu	r8,r8,0x5,0x1
80007f80:	5c 58       	castu.b	r8
80007f82:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007f86:	c0 31       	brne	80007f8c <tc_configure_interrupts+0x124>
80007f88:	32 08       	mov	r8,32
80007f8a:	c0 28       	rjmp	80007f8e <tc_configure_interrupts+0x126>
80007f8c:	30 08       	mov	r8,0
80007f8e:	10 49       	or	r9,r8
                             (~bitfield->cpcs & 1) << AVR32_TC_CPCS_OFFSET |
80007f90:	ee f8 ff f0 	ld.w	r8,r7[-16]
80007f94:	70 08       	ld.w	r8,r8[0x0]
80007f96:	f1 d8 c0 81 	bfextu	r8,r8,0x4,0x1
80007f9a:	5c 58       	castu.b	r8
80007f9c:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007fa0:	c0 31       	brne	80007fa6 <tc_configure_interrupts+0x13e>
80007fa2:	31 08       	mov	r8,16
80007fa4:	c0 28       	rjmp	80007fa8 <tc_configure_interrupts+0x140>
80007fa6:	30 08       	mov	r8,0
80007fa8:	10 49       	or	r9,r8
                             (~bitfield->cpbs & 1) << AVR32_TC_CPBS_OFFSET |
80007faa:	ee f8 ff f0 	ld.w	r8,r7[-16]
80007fae:	70 08       	ld.w	r8,r8[0x0]
80007fb0:	f1 d8 c0 61 	bfextu	r8,r8,0x3,0x1
80007fb4:	5c 58       	castu.b	r8
80007fb6:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007fba:	c0 31       	brne	80007fc0 <tc_configure_interrupts+0x158>
80007fbc:	30 88       	mov	r8,8
80007fbe:	c0 28       	rjmp	80007fc2 <tc_configure_interrupts+0x15a>
80007fc0:	30 08       	mov	r8,0
80007fc2:	10 49       	or	r9,r8
                             (~bitfield->cpas & 1) << AVR32_TC_CPAS_OFFSET |
80007fc4:	ee f8 ff f0 	ld.w	r8,r7[-16]
80007fc8:	70 08       	ld.w	r8,r8[0x0]
80007fca:	f1 d8 c0 41 	bfextu	r8,r8,0x2,0x1
80007fce:	5c 58       	castu.b	r8
80007fd0:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007fd4:	c0 31       	brne	80007fda <tc_configure_interrupts+0x172>
80007fd6:	30 48       	mov	r8,4
80007fd8:	c0 28       	rjmp	80007fdc <tc_configure_interrupts+0x174>
80007fda:	30 08       	mov	r8,0
80007fdc:	10 49       	or	r9,r8
                             (~bitfield->lovrs & 1) << AVR32_TC_LOVRS_OFFSET |
80007fde:	ee f8 ff f0 	ld.w	r8,r7[-16]
80007fe2:	70 08       	ld.w	r8,r8[0x0]
80007fe4:	f1 d8 c0 21 	bfextu	r8,r8,0x1,0x1
80007fe8:	5c 58       	castu.b	r8
80007fea:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007fee:	c0 31       	brne	80007ff4 <tc_configure_interrupts+0x18c>
80007ff0:	30 28       	mov	r8,2
80007ff2:	c0 28       	rjmp	80007ff6 <tc_configure_interrupts+0x18e>
80007ff4:	30 08       	mov	r8,0
80007ff6:	10 49       	or	r9,r8
                             (~bitfield->covfs & 1) << AVR32_TC_COVFS_OFFSET;
80007ff8:	ee f8 ff f0 	ld.w	r8,r7[-16]
80007ffc:	70 08       	ld.w	r8,r8[0x0]
80007ffe:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80008002:	5c 58       	castu.b	r8
80008004:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80008008:	5f 08       	sreq	r8
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;

  // Disable the appropriate interrupts.
  if (global_interrupt_enabled) Disable_global_interrupt();
  tc->channel[channel].idr = (~bitfield->etrgs & 1) << AVR32_TC_ETRGS_OFFSET |
8000800a:	f3 e8 10 08 	or	r8,r9,r8
8000800e:	10 99       	mov	r9,r8
80008010:	ee fa ff f8 	ld.w	r10,r7[-8]
80008014:	f6 08 15 06 	lsl	r8,r11,0x6
80008018:	f4 08 00 08 	add	r8,r10,r8
8000801c:	2d 88       	sub	r8,-40
8000801e:	91 09       	st.w	r8[0x0],r9
                             (~bitfield->cpcs & 1) << AVR32_TC_CPCS_OFFSET |
                             (~bitfield->cpbs & 1) << AVR32_TC_CPBS_OFFSET |
                             (~bitfield->cpas & 1) << AVR32_TC_CPAS_OFFSET |
                             (~bitfield->lovrs & 1) << AVR32_TC_LOVRS_OFFSET |
                             (~bitfield->covfs & 1) << AVR32_TC_COVFS_OFFSET;
  tc->channel[channel].sr;
80008020:	ee f8 ff f4 	ld.w	r8,r7[-12]
80008024:	ee f9 ff f8 	ld.w	r9,r7[-8]
80008028:	a1 78       	lsl	r8,0x1
8000802a:	2f f8       	sub	r8,-1
8000802c:	a5 78       	lsl	r8,0x5
8000802e:	f2 08 00 08 	add	r8,r9,r8
80008032:	70 08       	ld.w	r8,r8[0x0]
  if (global_interrupt_enabled) Enable_global_interrupt();
80008034:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80008038:	30 08       	mov	r8,0
8000803a:	f0 09 18 00 	cp.b	r9,r8
8000803e:	c0 20       	breq	80008042 <tc_configure_interrupts+0x1da>
80008040:	d5 03       	csrf	0x10

  return 0;
80008042:	30 08       	mov	r8,0
}
80008044:	10 9c       	mov	r12,r8
80008046:	2f cd       	sub	sp,-16
80008048:	e3 cd 80 80 	ldm	sp++,r7,pc
8000804c:	80 00       	ld.sh	r0,r0[0x0]
8000804e:	7e 48       	ld.w	r8,pc[0x10]

80008050 <tc_init_waveform>:
  return 0;
}


int tc_init_waveform(volatile avr32_tc_t *tc, const tc_waveform_opt_t *opt)
{
80008050:	eb cd 40 80 	pushm	r7,lr
80008054:	1a 97       	mov	r7,sp
80008056:	20 2d       	sub	sp,8
80008058:	ef 4c ff fc 	st.w	r7[-4],r12
8000805c:	ef 4b ff f8 	st.w	r7[-8],r11
  // Check for valid input.
  if (opt->channel >= TC_NUMBER_OF_CHANNELS)
80008060:	ee f8 ff f8 	ld.w	r8,r7[-8]
80008064:	70 08       	ld.w	r8,r8[0x0]
80008066:	58 28       	cp.w	r8,2
80008068:	e0 88 00 04 	brls	80008070 <tc_init_waveform+0x20>
    return TC_INVALID_ARGUMENT;
8000806c:	3f f8       	mov	r8,-1
8000806e:	c9 78       	rjmp	8000819c <tc_init_waveform+0x14c>

  // GENERATE SIGNALS: Waveform operating mode.
  tc->channel[opt->channel].cmr = opt->bswtrg << AVR32_TC_BSWTRG_OFFSET |
80008070:	ee f8 ff f8 	ld.w	r8,r7[-8]
80008074:	70 09       	ld.w	r9,r8[0x0]
80008076:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000807a:	70 18       	ld.w	r8,r8[0x4]
8000807c:	f1 d8 c3 c2 	bfextu	r8,r8,0x1e,0x2
80008080:	5c 58       	castu.b	r8
80008082:	f0 0a 15 1e 	lsl	r10,r8,0x1e
                                  opt->beevt << AVR32_TC_BEEVT_OFFSET |
80008086:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000808a:	70 18       	ld.w	r8,r8[0x4]
8000808c:	f1 d8 c3 82 	bfextu	r8,r8,0x1c,0x2
80008090:	5c 58       	castu.b	r8
80008092:	bd 68       	lsl	r8,0x1c
80008094:	10 4a       	or	r10,r8
                                  opt->bcpc << AVR32_TC_BCPC_OFFSET |
80008096:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000809a:	70 18       	ld.w	r8,r8[0x4]
8000809c:	f1 d8 c3 42 	bfextu	r8,r8,0x1a,0x2
800080a0:	5c 58       	castu.b	r8
800080a2:	bb 68       	lsl	r8,0x1a
800080a4:	10 4a       	or	r10,r8
                                  opt->bcpb << AVR32_TC_BCPB_OFFSET |
800080a6:	ee f8 ff f8 	ld.w	r8,r7[-8]
800080aa:	70 18       	ld.w	r8,r8[0x4]
800080ac:	f1 d8 c3 02 	bfextu	r8,r8,0x18,0x2
800080b0:	5c 58       	castu.b	r8
800080b2:	b9 68       	lsl	r8,0x18
800080b4:	10 4a       	or	r10,r8
                                  opt->aswtrg << AVR32_TC_ASWTRG_OFFSET |
800080b6:	ee f8 ff f8 	ld.w	r8,r7[-8]
800080ba:	70 18       	ld.w	r8,r8[0x4]
800080bc:	f1 d8 c2 c2 	bfextu	r8,r8,0x16,0x2
800080c0:	5c 58       	castu.b	r8
800080c2:	b7 68       	lsl	r8,0x16
800080c4:	10 4a       	or	r10,r8
                                  opt->aeevt << AVR32_TC_AEEVT_OFFSET |
800080c6:	ee f8 ff f8 	ld.w	r8,r7[-8]
800080ca:	70 18       	ld.w	r8,r8[0x4]
800080cc:	f1 d8 c2 82 	bfextu	r8,r8,0x14,0x2
800080d0:	5c 58       	castu.b	r8
800080d2:	b5 68       	lsl	r8,0x14
800080d4:	10 4a       	or	r10,r8
                                  opt->acpc << AVR32_TC_ACPC_OFFSET |
800080d6:	ee f8 ff f8 	ld.w	r8,r7[-8]
800080da:	70 18       	ld.w	r8,r8[0x4]
800080dc:	f1 d8 c2 42 	bfextu	r8,r8,0x12,0x2
800080e0:	5c 58       	castu.b	r8
800080e2:	b3 68       	lsl	r8,0x12
800080e4:	10 4a       	or	r10,r8
                                  opt->acpa << AVR32_TC_ACPA_OFFSET |
800080e6:	ee f8 ff f8 	ld.w	r8,r7[-8]
800080ea:	70 18       	ld.w	r8,r8[0x4]
800080ec:	f1 d8 c2 02 	bfextu	r8,r8,0x10,0x2
800080f0:	5c 58       	castu.b	r8
800080f2:	b1 68       	lsl	r8,0x10
800080f4:	f5 e8 10 08 	or	r8,r10,r8
                                  1 << AVR32_TC_WAVE_OFFSET |
800080f8:	10 9a       	mov	r10,r8
800080fa:	af ba       	sbr	r10,0xf
                                  opt->wavsel << AVR32_TC_WAVSEL_OFFSET |
800080fc:	ee f8 ff f8 	ld.w	r8,r7[-8]
80008100:	70 18       	ld.w	r8,r8[0x4]
80008102:	f1 d8 c1 a2 	bfextu	r8,r8,0xd,0x2
80008106:	5c 58       	castu.b	r8
80008108:	ad 78       	lsl	r8,0xd
8000810a:	10 4a       	or	r10,r8
                                  opt->enetrg << AVR32_TC_ENETRG_OFFSET |
8000810c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80008110:	70 18       	ld.w	r8,r8[0x4]
80008112:	f1 d8 c1 81 	bfextu	r8,r8,0xc,0x1
80008116:	5c 58       	castu.b	r8
80008118:	ad 68       	lsl	r8,0xc
8000811a:	10 4a       	or	r10,r8
                                  opt->eevt << AVR32_TC_EEVT_OFFSET |
8000811c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80008120:	70 18       	ld.w	r8,r8[0x4]
80008122:	f1 d8 c1 42 	bfextu	r8,r8,0xa,0x2
80008126:	5c 58       	castu.b	r8
80008128:	ab 68       	lsl	r8,0xa
8000812a:	10 4a       	or	r10,r8
                                  opt->eevtedg << AVR32_TC_EEVTEDG_OFFSET |
8000812c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80008130:	70 18       	ld.w	r8,r8[0x4]
80008132:	f1 d8 c1 02 	bfextu	r8,r8,0x8,0x2
80008136:	5c 58       	castu.b	r8
80008138:	a9 68       	lsl	r8,0x8
8000813a:	10 4a       	or	r10,r8
                                  opt->cpcdis << AVR32_TC_CPCDIS_OFFSET |
8000813c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80008140:	70 18       	ld.w	r8,r8[0x4]
80008142:	f1 d8 c0 e1 	bfextu	r8,r8,0x7,0x1
80008146:	5c 58       	castu.b	r8
80008148:	a7 78       	lsl	r8,0x7
8000814a:	10 4a       	or	r10,r8
                                  opt->cpcstop << AVR32_TC_CPCSTOP_OFFSET |
8000814c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80008150:	70 18       	ld.w	r8,r8[0x4]
80008152:	f1 d8 c0 c1 	bfextu	r8,r8,0x6,0x1
80008156:	5c 58       	castu.b	r8
80008158:	a7 68       	lsl	r8,0x6
8000815a:	10 4a       	or	r10,r8
                                  opt->burst << AVR32_TC_BURST_OFFSET |
8000815c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80008160:	70 18       	ld.w	r8,r8[0x4]
80008162:	f1 d8 c0 82 	bfextu	r8,r8,0x4,0x2
80008166:	5c 58       	castu.b	r8
80008168:	a5 68       	lsl	r8,0x4
8000816a:	10 4a       	or	r10,r8
                                  opt->clki << AVR32_TC_CLKI_OFFSET |
8000816c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80008170:	70 18       	ld.w	r8,r8[0x4]
80008172:	f1 d8 c0 61 	bfextu	r8,r8,0x3,0x1
80008176:	5c 58       	castu.b	r8
80008178:	a3 78       	lsl	r8,0x3
8000817a:	10 4a       	or	r10,r8
                                  opt->tcclks << AVR32_TC_TCCLKS_OFFSET;
8000817c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80008180:	70 18       	ld.w	r8,r8[0x4]
80008182:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
80008186:	5c 58       	castu.b	r8
  // Check for valid input.
  if (opt->channel >= TC_NUMBER_OF_CHANNELS)
    return TC_INVALID_ARGUMENT;

  // GENERATE SIGNALS: Waveform operating mode.
  tc->channel[opt->channel].cmr = opt->bswtrg << AVR32_TC_BSWTRG_OFFSET |
80008188:	f5 e8 10 08 	or	r8,r10,r8
8000818c:	10 9a       	mov	r10,r8
8000818e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008192:	a5 69       	lsl	r9,0x4
80008194:	2f f9       	sub	r9,-1
80008196:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
                                  opt->cpcstop << AVR32_TC_CPCSTOP_OFFSET |
                                  opt->burst << AVR32_TC_BURST_OFFSET |
                                  opt->clki << AVR32_TC_CLKI_OFFSET |
                                  opt->tcclks << AVR32_TC_TCCLKS_OFFSET;

  return 0;
8000819a:	30 08       	mov	r8,0
}
8000819c:	10 9c       	mov	r12,r8
8000819e:	2f ed       	sub	sp,-8
800081a0:	e3 cd 80 80 	ldm	sp++,r7,pc

800081a4 <tc_start>:


int tc_start(volatile avr32_tc_t *tc, unsigned int channel)
{
800081a4:	eb cd 40 80 	pushm	r7,lr
800081a8:	1a 97       	mov	r7,sp
800081aa:	20 2d       	sub	sp,8
800081ac:	ef 4c ff fc 	st.w	r7[-4],r12
800081b0:	ef 4b ff f8 	st.w	r7[-8],r11
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
800081b4:	ee f8 ff f8 	ld.w	r8,r7[-8]
800081b8:	58 28       	cp.w	r8,2
800081ba:	e0 88 00 04 	brls	800081c2 <tc_start+0x1e>
    return TC_INVALID_ARGUMENT;
800081be:	3f f8       	mov	r8,-1
800081c0:	c0 b8       	rjmp	800081d6 <tc_start+0x32>

  // Enable, reset and start the selected timer/counter channel.
  tc->channel[channel].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
800081c2:	ee f8 ff f8 	ld.w	r8,r7[-8]
800081c6:	ee f9 ff fc 	ld.w	r9,r7[-4]
800081ca:	a7 68       	lsl	r8,0x6
800081cc:	f2 08 00 08 	add	r8,r9,r8
800081d0:	30 59       	mov	r9,5
800081d2:	91 09       	st.w	r8[0x0],r9

  return 0;
800081d4:	30 08       	mov	r8,0
}
800081d6:	10 9c       	mov	r12,r8
800081d8:	2f ed       	sub	sp,-8
800081da:	e3 cd 80 80 	ldm	sp++,r7,pc

800081de <tc_read_sr>:
  tc->bcr = AVR32_TC_BCR_SYNC_MASK;
}


int tc_read_sr(volatile avr32_tc_t *tc, unsigned int channel)
{
800081de:	eb cd 40 80 	pushm	r7,lr
800081e2:	1a 97       	mov	r7,sp
800081e4:	20 2d       	sub	sp,8
800081e6:	ef 4c ff fc 	st.w	r7[-4],r12
800081ea:	ef 4b ff f8 	st.w	r7[-8],r11
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
800081ee:	ee f8 ff f8 	ld.w	r8,r7[-8]
800081f2:	58 28       	cp.w	r8,2
800081f4:	e0 88 00 04 	brls	800081fc <tc_read_sr+0x1e>
    return TC_INVALID_ARGUMENT;
800081f8:	3f f8       	mov	r8,-1
800081fa:	c0 b8       	rjmp	80008210 <tc_read_sr+0x32>

  return tc->channel[channel].sr;
800081fc:	ee f8 ff f8 	ld.w	r8,r7[-8]
80008200:	ee f9 ff fc 	ld.w	r9,r7[-4]
80008204:	a1 78       	lsl	r8,0x1
80008206:	2f f8       	sub	r8,-1
80008208:	a5 78       	lsl	r8,0x5
8000820a:	f2 08 00 08 	add	r8,r9,r8
8000820e:	70 08       	ld.w	r8,r8[0x0]
}
80008210:	10 9c       	mov	r12,r8
80008212:	2f ed       	sub	sp,-8
80008214:	e3 cd 80 80 	ldm	sp++,r7,pc

80008218 <tc_write_rc>:
  return value;
}


int tc_write_rc(volatile avr32_tc_t *tc, unsigned int channel, unsigned short value)
{
80008218:	eb cd 40 80 	pushm	r7,lr
8000821c:	1a 97       	mov	r7,sp
8000821e:	20 3d       	sub	sp,12
80008220:	ef 4c ff fc 	st.w	r7[-4],r12
80008224:	ef 4b ff f8 	st.w	r7[-8],r11
80008228:	14 98       	mov	r8,r10
8000822a:	ef 58 ff f4 	st.h	r7[-12],r8
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
8000822e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80008232:	58 28       	cp.w	r8,2
80008234:	e0 88 00 04 	brls	8000823c <tc_write_rc+0x24>
    return TC_INVALID_ARGUMENT;
80008238:	3f f8       	mov	r8,-1
8000823a:	c2 78       	rjmp	80008288 <tc_write_rc+0x70>

  // This function is only available in WAVEFORM mode.
  if (Tst_bits(tc->channel[channel].cmr, AVR32_TC_WAVE_MASK))
8000823c:	ee f9 ff f8 	ld.w	r9,r7[-8]
80008240:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008244:	a5 69       	lsl	r9,0x4
80008246:	2f f9       	sub	r9,-1
80008248:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
8000824c:	e2 18 80 00 	andl	r8,0x8000,COH
80008250:	c1 a0       	breq	80008284 <tc_write_rc+0x6c>
    Wr_bitfield(tc->channel[channel].rc, AVR32_TC_RC_MASK, value);
80008252:	ee f8 ff f8 	ld.w	r8,r7[-8]
80008256:	ee f9 ff f8 	ld.w	r9,r7[-8]
8000825a:	ee fa ff fc 	ld.w	r10,r7[-4]
8000825e:	a7 69       	lsl	r9,0x6
80008260:	f4 09 00 09 	add	r9,r10,r9
80008264:	2e 49       	sub	r9,-28
80008266:	72 09       	ld.w	r9,r9[0x0]
80008268:	12 9a       	mov	r10,r9
8000826a:	e0 1a 00 00 	andl	r10,0x0
8000826e:	ef 19 ff f4 	ld.uh	r9,r7[-12]
80008272:	f5 e9 10 09 	or	r9,r10,r9
80008276:	ee fa ff fc 	ld.w	r10,r7[-4]
8000827a:	a7 68       	lsl	r8,0x6
8000827c:	f4 08 00 08 	add	r8,r10,r8
80008280:	2e 48       	sub	r8,-28
80008282:	91 09       	st.w	r8[0x0],r9

  return value;
80008284:	ef 18 ff f4 	ld.uh	r8,r7[-12]
}
80008288:	10 9c       	mov	r12,r8
8000828a:	2f dd       	sub	sp,-12
8000828c:	e3 cd 80 80 	ldm	sp++,r7,pc

80008290 <cpu_irq_is_enabled_flags>:

	return flags;
}

static inline bool cpu_irq_is_enabled_flags(irqflags_t flags)
{
80008290:	eb cd 40 80 	pushm	r7,lr
80008294:	1a 97       	mov	r7,sp
80008296:	20 1d       	sub	sp,4
80008298:	ef 4c ff fc 	st.w	r7[-4],r12
	return !(flags & AVR32_SR_GM_MASK);
8000829c:	ee f8 ff fc 	ld.w	r8,r7[-4]
800082a0:	e6 18 00 01 	andh	r8,0x1,COH
800082a4:	5f 08       	sreq	r8
800082a6:	5c 58       	castu.b	r8
}
800082a8:	10 9c       	mov	r12,r8
800082aa:	2f fd       	sub	sp,-4
800082ac:	e3 cd 80 80 	ldm	sp++,r7,pc

800082b0 <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
800082b0:	eb cd 40 80 	pushm	r7,lr
800082b4:	1a 97       	mov	r7,sp
800082b6:	20 7d       	sub	sp,28
800082b8:	ef 4c ff ec 	st.w	r7[-20],r12
800082bc:	ef 4b ff e8 	st.w	r7[-24],r11
800082c0:	ef 4a ff e4 	st.w	r7[-28],r10
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
800082c4:	ee f8 ff e8 	ld.w	r8,r7[-24]
800082c8:	f0 09 15 04 	lsl	r9,r8,0x4
800082cc:	ee f8 ff e4 	ld.w	r8,r7[-28]
800082d0:	10 39       	cp.w	r9,r8
800082d2:	e0 8b 00 04 	brhi	800082da <usart_set_async_baudrate+0x2a>
800082d6:	31 08       	mov	r8,16
800082d8:	c0 28       	rjmp	800082dc <usart_set_async_baudrate+0x2c>
800082da:	30 88       	mov	r8,8
800082dc:	ef 48 ff f0 	st.w	r7[-16],r8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
800082e0:	ee f8 ff e4 	ld.w	r8,r7[-28]
800082e4:	f0 09 15 03 	lsl	r9,r8,0x3
800082e8:	ee fa ff f0 	ld.w	r10,r7[-16]
800082ec:	ee f8 ff e8 	ld.w	r8,r7[-24]
800082f0:	f4 08 02 48 	mul	r8,r10,r8
800082f4:	a1 98       	lsr	r8,0x1
800082f6:	f2 08 00 08 	add	r8,r9,r8
800082fa:	ee fa ff f0 	ld.w	r10,r7[-16]
800082fe:	ee f9 ff e8 	ld.w	r9,r7[-24]
80008302:	f4 09 02 49 	mul	r9,r10,r9
80008306:	f0 09 0d 08 	divu	r8,r8,r9
8000830a:	ef 48 ff f4 	st.w	r7[-12],r8
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
8000830e:	ee f8 ff f4 	ld.w	r8,r7[-12]
80008312:	a3 98       	lsr	r8,0x3
80008314:	ef 48 ff f8 	st.w	r7[-8],r8
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);
80008318:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000831c:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
80008320:	ef 48 ff fc 	st.w	r7[-4],r8

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
80008324:	ee f8 ff f8 	ld.w	r8,r7[-8]
80008328:	58 08       	cp.w	r8,0
8000832a:	c0 70       	breq	80008338 <usart_set_async_baudrate+0x88>
8000832c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80008330:	e0 48 ff ff 	cp.w	r8,65535
80008334:	e0 88 00 04 	brls	8000833c <usart_set_async_baudrate+0x8c>
    return USART_INVALID_INPUT;
80008338:	30 18       	mov	r8,1
8000833a:	c2 08       	rjmp	8000837a <usart_set_async_baudrate+0xca>

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
8000833c:	ee f8 ff ec 	ld.w	r8,r7[-20]
80008340:	70 18       	ld.w	r8,r8[0x4]
80008342:	10 99       	mov	r9,r8
80008344:	e4 19 ff f7 	andh	r9,0xfff7
80008348:	e0 19 fe cf 	andl	r9,0xfecf
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
8000834c:	ee f8 ff f0 	ld.w	r8,r7[-16]
80008350:	59 08       	cp.w	r8,16
80008352:	c0 40       	breq	8000835a <usart_set_async_baudrate+0xaa>
80008354:	e8 68 00 00 	mov	r8,524288
80008358:	c0 28       	rjmp	8000835c <usart_set_async_baudrate+0xac>
8000835a:	30 08       	mov	r8,0
8000835c:	10 49       	or	r9,r8
8000835e:	ee f8 ff ec 	ld.w	r8,r7[-20]
80008362:	91 19       	st.w	r8[0x4],r9
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
                fp << AVR32_USART_BRGR_FP_OFFSET;
80008364:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008368:	f0 09 15 10 	lsl	r9,r8,0x10
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
8000836c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80008370:	10 49       	or	r9,r8
80008372:	ee f8 ff ec 	ld.w	r8,r7[-20]
80008376:	91 89       	st.w	r8[0x20],r9
                fp << AVR32_USART_BRGR_FP_OFFSET;

  return USART_SUCCESS;
80008378:	30 08       	mov	r8,0
}
8000837a:	10 9c       	mov	r12,r8
8000837c:	2f 9d       	sub	sp,-28
8000837e:	e3 cd 80 80 	ldm	sp++,r7,pc
80008382:	d7 03       	nop

80008384 <usart_reset>:
 */
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
80008384:	eb cd 40 80 	pushm	r7,lr
80008388:	1a 97       	mov	r7,sp
8000838a:	20 2d       	sub	sp,8
8000838c:	ef 4c ff f8 	st.w	r7[-8],r12
  bool global_interrupt_enabled = cpu_irq_is_enabled();
80008390:	e1 b8 00 00 	mfsr	r8,0x0
80008394:	10 9c       	mov	r12,r8
80008396:	f0 1f 00 18 	mcall	800083f4 <usart_reset+0x70>
8000839a:	18 98       	mov	r8,r12
8000839c:	ef 68 ff ff 	st.b	r7[-1],r8

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
800083a0:	ef 39 ff ff 	ld.ub	r9,r7[-1]
800083a4:	30 08       	mov	r8,0
800083a6:	f0 09 18 00 	cp.b	r9,r8
800083aa:	c0 20       	breq	800083ae <usart_reset+0x2a>
800083ac:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
800083ae:	ee f8 ff f8 	ld.w	r8,r7[-8]
800083b2:	3f f9       	mov	r9,-1
800083b4:	91 39       	st.w	r8[0xc],r9
  usart->csr;
800083b6:	ee f8 ff f8 	ld.w	r8,r7[-8]
800083ba:	70 58       	ld.w	r8,r8[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
800083bc:	ef 39 ff ff 	ld.ub	r9,r7[-1]
800083c0:	30 08       	mov	r8,0
800083c2:	f0 09 18 00 	cp.b	r9,r8
800083c6:	c0 20       	breq	800083ca <usart_reset+0x46>
800083c8:	d5 03       	csrf	0x10

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
800083ca:	ee f8 ff f8 	ld.w	r8,r7[-8]
800083ce:	30 09       	mov	r9,0
800083d0:	91 19       	st.w	r8[0x4],r9
  usart->rtor = 0;
800083d2:	ee f8 ff f8 	ld.w	r8,r7[-8]
800083d6:	30 09       	mov	r9,0
800083d8:	91 99       	st.w	r8[0x24],r9
  usart->ttgr = 0;
800083da:	ee f8 ff f8 	ld.w	r8,r7[-8]
800083de:	30 09       	mov	r9,0
800083e0:	91 a9       	st.w	r8[0x28],r9

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
800083e2:	ee f8 ff f8 	ld.w	r8,r7[-8]
800083e6:	ea 69 61 0c 	mov	r9,680204
800083ea:	91 09       	st.w	r8[0x0],r9
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
800083ec:	2f ed       	sub	sp,-8
800083ee:	e3 cd 80 80 	ldm	sp++,r7,pc
800083f2:	00 00       	add	r0,r0
800083f4:	80 00       	ld.sh	r0,r0[0x0]
800083f6:	82 90       	ld.uh	r0,r1[0x2]

800083f8 <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
800083f8:	eb cd 40 80 	pushm	r7,lr
800083fc:	1a 97       	mov	r7,sp
800083fe:	20 3d       	sub	sp,12
80008400:	ef 4c ff fc 	st.w	r7[-4],r12
80008404:	ef 4b ff f8 	st.w	r7[-8],r11
80008408:	ef 4a ff f4 	st.w	r7[-12],r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
8000840c:	ee fc ff fc 	ld.w	r12,r7[-4]
80008410:	f0 1f 00 54 	mcall	80008560 <usart_init_rs232+0x168>

  // Check input values.
  if (!opt || // Null pointer.
80008414:	ee f8 ff f8 	ld.w	r8,r7[-8]
80008418:	58 08       	cp.w	r8,0
8000841a:	c3 90       	breq	8000848c <usart_init_rs232+0x94>
      opt->charlength < 5 || opt->charlength > 9 ||
8000841c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80008420:	11 c9       	ld.ub	r9,r8[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80008422:	30 48       	mov	r8,4
80008424:	f0 09 18 00 	cp.b	r9,r8
80008428:	e0 88 00 32 	brls	8000848c <usart_init_rs232+0x94>
      opt->charlength < 5 || opt->charlength > 9 ||
8000842c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80008430:	11 c9       	ld.ub	r9,r8[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80008432:	30 98       	mov	r8,9
80008434:	f0 09 18 00 	cp.b	r9,r8
80008438:	e0 8b 00 2a 	brhi	8000848c <usart_init_rs232+0x94>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
8000843c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80008440:	11 d9       	ld.ub	r9,r8[0x5]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80008442:	30 78       	mov	r8,7
80008444:	f0 09 18 00 	cp.b	r9,r8
80008448:	e0 8b 00 22 	brhi	8000848c <usart_init_rs232+0x94>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
      opt->stopbits > 2 + 255 ||
8000844c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80008450:	90 39       	ld.sh	r9,r8[0x6]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80008452:	e0 68 01 01 	mov	r8,257
80008456:	f0 09 19 00 	cp.h	r9,r8
8000845a:	e0 8b 00 19 	brhi	8000848c <usart_init_rs232+0x94>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
8000845e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80008462:	f1 39 00 08 	ld.ub	r9,r8[8]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80008466:	30 38       	mov	r8,3
80008468:	f0 09 18 00 	cp.b	r9,r8
8000846c:	e0 8b 00 10 	brhi	8000848c <usart_init_rs232+0x94>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
80008470:	ee f9 ff f4 	ld.w	r9,r7[-12]
80008474:	ee f8 ff f8 	ld.w	r8,r7[-8]
80008478:	70 08       	ld.w	r8,r8[0x0]
8000847a:	12 9a       	mov	r10,r9
8000847c:	10 9b       	mov	r11,r8
8000847e:	ee fc ff fc 	ld.w	r12,r7[-4]
80008482:	f0 1f 00 39 	mcall	80008564 <usart_init_rs232+0x16c>
80008486:	18 98       	mov	r8,r12
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80008488:	58 18       	cp.w	r8,1
8000848a:	c0 31       	brne	80008490 <usart_init_rs232+0x98>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;
8000848c:	30 18       	mov	r8,1
8000848e:	c6 48       	rjmp	80008556 <usart_init_rs232+0x15e>

  if (opt->charlength == 9)
80008490:	ee f8 ff f8 	ld.w	r8,r7[-8]
80008494:	11 c9       	ld.ub	r9,r8[0x4]
80008496:	30 98       	mov	r8,9
80008498:	f0 09 18 00 	cp.b	r9,r8
8000849c:	c0 a1       	brne	800084b0 <usart_init_rs232+0xb8>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
8000849e:	ee f8 ff fc 	ld.w	r8,r7[-4]
800084a2:	70 18       	ld.w	r8,r8[0x4]
800084a4:	10 99       	mov	r9,r8
800084a6:	b1 b9       	sbr	r9,0x11
800084a8:	ee f8 ff fc 	ld.w	r8,r7[-4]
800084ac:	91 19       	st.w	r8[0x4],r9
800084ae:	c0 d8       	rjmp	800084c8 <usart_init_rs232+0xd0>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
800084b0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800084b4:	70 19       	ld.w	r9,r8[0x4]
800084b6:	ee f8 ff f8 	ld.w	r8,r7[-8]
800084ba:	11 c8       	ld.ub	r8,r8[0x4]
800084bc:	20 58       	sub	r8,5
800084be:	a7 68       	lsl	r8,0x6
800084c0:	10 49       	or	r9,r8
800084c2:	ee f8 ff fc 	ld.w	r8,r7[-4]
800084c6:	91 19       	st.w	r8[0x4],r9
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
800084c8:	ee f8 ff fc 	ld.w	r8,r7[-4]
800084cc:	70 19       	ld.w	r9,r8[0x4]
800084ce:	ee f8 ff f8 	ld.w	r8,r7[-8]
800084d2:	11 d8       	ld.ub	r8,r8[0x5]
800084d4:	f0 0a 15 09 	lsl	r10,r8,0x9
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;
800084d8:	ee f8 ff f8 	ld.w	r8,r7[-8]
800084dc:	f1 38 00 08 	ld.ub	r8,r8[8]
800084e0:	af 68       	lsl	r8,0xe
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
800084e2:	f5 e8 10 08 	or	r8,r10,r8
800084e6:	10 49       	or	r9,r8
800084e8:	ee f8 ff fc 	ld.w	r8,r7[-4]
800084ec:	91 19       	st.w	r8[0x4],r9
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
800084ee:	ee f8 ff f8 	ld.w	r8,r7[-8]
800084f2:	90 39       	ld.sh	r9,r8[0x6]
800084f4:	30 28       	mov	r8,2
800084f6:	f0 09 19 00 	cp.h	r9,r8
800084fa:	e0 88 00 14 	brls	80008522 <usart_init_rs232+0x12a>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
800084fe:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008502:	70 18       	ld.w	r8,r8[0x4]
80008504:	10 99       	mov	r9,r8
80008506:	ad b9       	sbr	r9,0xd
80008508:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000850c:	91 19       	st.w	r8[0x4],r9
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
8000850e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80008512:	90 38       	ld.sh	r8,r8[0x6]
80008514:	5c 78       	castu.h	r8
80008516:	20 28       	sub	r8,2
80008518:	10 99       	mov	r9,r8
8000851a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000851e:	91 a9       	st.w	r8[0x28],r9
80008520:	c0 d8       	rjmp	8000853a <usart_init_rs232+0x142>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
80008522:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008526:	70 19       	ld.w	r9,r8[0x4]
80008528:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000852c:	90 38       	ld.sh	r8,r8[0x6]
8000852e:	5c 78       	castu.h	r8
80008530:	ad 68       	lsl	r8,0xc
80008532:	10 49       	or	r9,r8
80008534:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008538:	91 19       	st.w	r8[0x4],r9

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
8000853a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000853e:	70 18       	ld.w	r8,r8[0x4]
80008540:	10 99       	mov	r9,r8
80008542:	e0 19 ff f0 	andl	r9,0xfff0
80008546:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000854a:	91 19       	st.w	r8[0x4],r9
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
8000854c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008550:	35 09       	mov	r9,80
80008552:	91 09       	st.w	r8[0x0],r9
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
80008554:	30 08       	mov	r8,0
}
80008556:	10 9c       	mov	r12,r8
80008558:	2f dd       	sub	sp,-12
8000855a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000855e:	00 00       	add	r0,r0
80008560:	80 00       	ld.sh	r0,r0[0x0]
80008562:	83 84       	st.w	r1[0x20],r4
80008564:	80 00       	ld.sh	r0,r0[0x0]
80008566:	82 b0       	ld.uh	r0,r1[0x6]

80008568 <usart_write_char>:
  return USART_SUCCESS;
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
80008568:	eb cd 40 80 	pushm	r7,lr
8000856c:	1a 97       	mov	r7,sp
8000856e:	20 3d       	sub	sp,12
80008570:	ef 4c ff f8 	st.w	r7[-8],r12
80008574:	ef 4b ff f4 	st.w	r7[-12],r11
80008578:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000857c:	ef 48 ff fc 	st.w	r7[-4],r8
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
80008580:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008584:	70 58       	ld.w	r8,r8[0x14]
80008586:	e2 18 00 02 	andl	r8,0x2,COH
8000858a:	5f 18       	srne	r8
  if (usart_tx_ready(usart))
8000858c:	58 08       	cp.w	r8,0
8000858e:	c0 a0       	breq	800085a2 <usart_write_char+0x3a>
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
80008590:	ee f8 ff f4 	ld.w	r8,r7[-12]
80008594:	f3 d8 c0 09 	bfextu	r9,r8,0x0,0x9
80008598:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000859c:	91 79       	st.w	r8[0x1c],r9
    return USART_SUCCESS;
8000859e:	30 08       	mov	r8,0
800085a0:	c0 28       	rjmp	800085a4 <usart_write_char+0x3c>
  }
  else
    return USART_TX_BUSY;
800085a2:	30 28       	mov	r8,2
}
800085a4:	10 9c       	mov	r12,r8
800085a6:	2f dd       	sub	sp,-12
800085a8:	e3 cd 80 80 	ldm	sp++,r7,pc

800085ac <usart_putchar>:


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
800085ac:	eb cd 40 80 	pushm	r7,lr
800085b0:	1a 97       	mov	r7,sp
800085b2:	20 3d       	sub	sp,12
800085b4:	ef 4c ff f8 	st.w	r7[-8],r12
800085b8:	ef 4b ff f4 	st.w	r7[-12],r11
  int timeout = USART_DEFAULT_TIMEOUT;
800085bc:	e0 68 27 10 	mov	r8,10000
800085c0:	ef 48 ff fc 	st.w	r7[-4],r8

  do
  {
    if (!timeout--) return USART_FAILURE;
800085c4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800085c8:	58 08       	cp.w	r8,0
800085ca:	5f 08       	sreq	r8
800085cc:	5c 58       	castu.b	r8
800085ce:	ee f9 ff fc 	ld.w	r9,r7[-4]
800085d2:	20 19       	sub	r9,1
800085d4:	ef 49 ff fc 	st.w	r7[-4],r9
800085d8:	58 08       	cp.w	r8,0
800085da:	c0 30       	breq	800085e0 <usart_putchar+0x34>
800085dc:	3f f8       	mov	r8,-1
800085de:	c0 b8       	rjmp	800085f4 <usart_putchar+0x48>
  } while (usart_write_char(usart, c) != USART_SUCCESS);
800085e0:	ee fb ff f4 	ld.w	r11,r7[-12]
800085e4:	ee fc ff f8 	ld.w	r12,r7[-8]
800085e8:	f0 1f 00 05 	mcall	800085fc <usart_putchar+0x50>
800085ec:	18 98       	mov	r8,r12
800085ee:	58 08       	cp.w	r8,0
800085f0:	ce a1       	brne	800085c4 <usart_putchar+0x18>

  return USART_SUCCESS;
800085f2:	30 08       	mov	r8,0
}
800085f4:	10 9c       	mov	r12,r8
800085f6:	2f dd       	sub	sp,-12
800085f8:	e3 cd 80 80 	ldm	sp++,r7,pc
800085fc:	80 00       	ld.sh	r0,r0[0x0]
800085fe:	85 68       	st.w	r2[0x18],r8

80008600 <usart_read_char>:


int usart_read_char(volatile avr32_usart_t *usart, int *c)
{
80008600:	eb cd 40 80 	pushm	r7,lr
80008604:	1a 97       	mov	r7,sp
80008606:	20 3d       	sub	sp,12
80008608:	ef 4c ff f8 	st.w	r7[-8],r12
8000860c:	ef 4b ff f4 	st.w	r7[-12],r11
  // Check for errors: frame, parity and overrun. In RS485 mode, a parity error
  // would mean that an address char has been received.
  if (usart->csr & (AVR32_USART_CSR_OVRE_MASK |
80008610:	ee f8 ff f8 	ld.w	r8,r7[-8]
80008614:	70 58       	ld.w	r8,r8[0x14]
80008616:	e2 18 00 e0 	andl	r8,0xe0,COH
8000861a:	c0 30       	breq	80008620 <usart_read_char+0x20>
                    AVR32_USART_CSR_FRAME_MASK |
                    AVR32_USART_CSR_PARE_MASK))
    return USART_RX_ERROR;
8000861c:	30 48       	mov	r8,4
8000861e:	c1 68       	rjmp	8000864a <usart_read_char+0x4a>
80008620:	ee f8 ff f8 	ld.w	r8,r7[-8]
80008624:	ef 48 ff fc 	st.w	r7[-4],r8
 *
 * \return \c 1 if the USART Receive Holding Register is full, otherwise \c 0.
 */
__always_inline static int usart_test_hit(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_RXRDY_MASK) != 0;
80008628:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000862c:	70 58       	ld.w	r8,r8[0x14]
8000862e:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1

  // No error; if we really did receive a char, read it and return SUCCESS.
  if (usart_test_hit(usart))
80008632:	c0 b0       	breq	80008648 <usart_read_char+0x48>
  {
    *c = (usart->rhr & AVR32_USART_RHR_RXCHR_MASK) >> AVR32_USART_RHR_RXCHR_OFFSET;
80008634:	ee f8 ff f8 	ld.w	r8,r7[-8]
80008638:	70 68       	ld.w	r8,r8[0x18]
8000863a:	f3 d8 c0 09 	bfextu	r9,r8,0x0,0x9
8000863e:	ee f8 ff f4 	ld.w	r8,r7[-12]
80008642:	91 09       	st.w	r8[0x0],r9
    return USART_SUCCESS;
80008644:	30 08       	mov	r8,0
80008646:	c0 28       	rjmp	8000864a <usart_read_char+0x4a>
  }
  else
    return USART_RX_EMPTY;
80008648:	30 38       	mov	r8,3
}
8000864a:	10 9c       	mov	r12,r8
8000864c:	2f dd       	sub	sp,-12
8000864e:	e3 cd 80 80 	ldm	sp++,r7,pc
80008652:	d7 03       	nop

80008654 <usart_getchar>:


int usart_getchar(volatile avr32_usart_t *usart)
{
80008654:	eb cd 40 80 	pushm	r7,lr
80008658:	1a 97       	mov	r7,sp
8000865a:	20 3d       	sub	sp,12
8000865c:	ef 4c ff f4 	st.w	r7[-12],r12
  int c, ret;

  while ((ret = usart_read_char(usart, &c)) == USART_RX_EMPTY);
80008660:	ee c8 00 08 	sub	r8,r7,8
80008664:	10 9b       	mov	r11,r8
80008666:	ee fc ff f4 	ld.w	r12,r7[-12]
8000866a:	f0 1f 00 0b 	mcall	80008694 <usart_getchar+0x40>
8000866e:	18 98       	mov	r8,r12
80008670:	ef 48 ff fc 	st.w	r7[-4],r8
80008674:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008678:	58 38       	cp.w	r8,3
8000867a:	cf 30       	breq	80008660 <usart_getchar+0xc>

  if (ret == USART_RX_ERROR)
8000867c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008680:	58 48       	cp.w	r8,4
80008682:	c0 31       	brne	80008688 <usart_getchar+0x34>
    return USART_FAILURE;
80008684:	3f f8       	mov	r8,-1
80008686:	c0 38       	rjmp	8000868c <usart_getchar+0x38>

  return c;
80008688:	ee f8 ff f8 	ld.w	r8,r7[-8]
}
8000868c:	10 9c       	mov	r12,r8
8000868e:	2f dd       	sub	sp,-12
80008690:	e3 cd 80 80 	ldm	sp++,r7,pc
80008694:	80 00       	ld.sh	r0,r0[0x0]
80008696:	86 00       	ld.sh	r0,r3[0x0]

80008698 <usart_write_line>:


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
80008698:	eb cd 40 80 	pushm	r7,lr
8000869c:	1a 97       	mov	r7,sp
8000869e:	20 2d       	sub	sp,8
800086a0:	ef 4c ff fc 	st.w	r7[-4],r12
800086a4:	ef 4b ff f8 	st.w	r7[-8],r11
  while (*string != '\0')
800086a8:	c0 e8       	rjmp	800086c4 <usart_write_line+0x2c>
    usart_putchar(usart, *string++);
800086aa:	ee f8 ff f8 	ld.w	r8,r7[-8]
800086ae:	11 88       	ld.ub	r8,r8[0x0]
800086b0:	ee f9 ff f8 	ld.w	r9,r7[-8]
800086b4:	2f f9       	sub	r9,-1
800086b6:	ef 49 ff f8 	st.w	r7[-8],r9
800086ba:	10 9b       	mov	r11,r8
800086bc:	ee fc ff fc 	ld.w	r12,r7[-4]
800086c0:	f0 1f 00 05 	mcall	800086d4 <usart_write_line+0x3c>
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
800086c4:	ee f8 ff f8 	ld.w	r8,r7[-8]
800086c8:	11 88       	ld.ub	r8,r8[0x0]
800086ca:	58 08       	cp.w	r8,0
800086cc:	ce f1       	brne	800086aa <usart_write_line+0x12>
    usart_putchar(usart, *string++);
}
800086ce:	2f ed       	sub	sp,-8
800086d0:	e3 cd 80 80 	ldm	sp++,r7,pc
800086d4:	80 00       	ld.sh	r0,r0[0x0]
800086d6:	85 ac       	st.w	r2[0x28],r12

800086d8 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
800086d8:	eb cd 40 80 	pushm	r7,lr
800086dc:	1a 97       	mov	r7,sp
800086de:	20 1d       	sub	sp,4
800086e0:	ef 4c ff fc 	st.w	r7[-4],r12
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
800086e4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800086e8:	2f 88       	sub	r8,-8
800086ea:	10 99       	mov	r9,r8
800086ec:	ee f8 ff fc 	ld.w	r8,r7[-4]
800086f0:	91 19       	st.w	r8[0x4],r9

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
800086f2:	ee f8 ff fc 	ld.w	r8,r7[-4]
800086f6:	3f f9       	mov	r9,-1
800086f8:	91 29       	st.w	r8[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
800086fa:	ee f8 ff fc 	ld.w	r8,r7[-4]
800086fe:	2f 88       	sub	r8,-8
80008700:	10 99       	mov	r9,r8
80008702:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008706:	91 39       	st.w	r8[0xc],r9
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
80008708:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000870c:	2f 88       	sub	r8,-8
8000870e:	10 99       	mov	r9,r8
80008710:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008714:	91 49       	st.w	r8[0x10],r9

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
80008716:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000871a:	30 09       	mov	r9,0
8000871c:	91 09       	st.w	r8[0x0],r9
}
8000871e:	2f fd       	sub	sp,-4
80008720:	e3 cd 80 80 	ldm	sp++,r7,pc

80008724 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
80008724:	eb cd 40 80 	pushm	r7,lr
80008728:	1a 97       	mov	r7,sp
8000872a:	20 1d       	sub	sp,4
8000872c:	ef 4c ff fc 	st.w	r7[-4],r12
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
80008730:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008734:	30 09       	mov	r9,0
80008736:	91 49       	st.w	r8[0x10],r9
}
80008738:	2f fd       	sub	sp,-4
8000873a:	e3 cd 80 80 	ldm	sp++,r7,pc

8000873e <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
8000873e:	eb cd 40 80 	pushm	r7,lr
80008742:	1a 97       	mov	r7,sp
80008744:	20 3d       	sub	sp,12
80008746:	ef 4c ff f8 	st.w	r7[-8],r12
8000874a:	ef 4b ff f4 	st.w	r7[-12],r11

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
8000874e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80008752:	70 18       	ld.w	r8,r8[0x4]
80008754:	ef 48 ff fc 	st.w	r7[-4],r8

	pxNewListItem->pxNext = pxIndex->pxNext;
80008758:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000875c:	70 19       	ld.w	r9,r8[0x4]
8000875e:	ee f8 ff f4 	ld.w	r8,r7[-12]
80008762:	91 19       	st.w	r8[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
80008764:	ee f8 ff f8 	ld.w	r8,r7[-8]
80008768:	70 19       	ld.w	r9,r8[0x4]
8000876a:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000876e:	91 29       	st.w	r8[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80008770:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008774:	70 18       	ld.w	r8,r8[0x4]
80008776:	ee f9 ff f4 	ld.w	r9,r7[-12]
8000877a:	91 29       	st.w	r8[0x8],r9
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
8000877c:	ee f9 ff f4 	ld.w	r9,r7[-12]
80008780:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008784:	91 19       	st.w	r8[0x4],r9
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
80008786:	ee f9 ff f4 	ld.w	r9,r7[-12]
8000878a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000878e:	91 19       	st.w	r8[0x4],r9

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80008790:	ee f8 ff f4 	ld.w	r8,r7[-12]
80008794:	ee f9 ff f8 	ld.w	r9,r7[-8]
80008798:	91 49       	st.w	r8[0x10],r9

	( pxList->uxNumberOfItems )++;
8000879a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000879e:	70 08       	ld.w	r8,r8[0x0]
800087a0:	f0 c9 ff ff 	sub	r9,r8,-1
800087a4:	ee f8 ff f8 	ld.w	r8,r7[-8]
800087a8:	91 09       	st.w	r8[0x0],r9
}
800087aa:	2f dd       	sub	sp,-12
800087ac:	e3 cd 80 80 	ldm	sp++,r7,pc

800087b0 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
800087b0:	eb cd 40 80 	pushm	r7,lr
800087b4:	1a 97       	mov	r7,sp
800087b6:	20 4d       	sub	sp,16
800087b8:	ef 4c ff f4 	st.w	r7[-12],r12
800087bc:	ef 4b ff f0 	st.w	r7[-16],r11
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
800087c0:	ee f8 ff f0 	ld.w	r8,r7[-16]
800087c4:	70 08       	ld.w	r8,r8[0x0]
800087c6:	ef 48 ff fc 	st.w	r7[-4],r8
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
800087ca:	ee f8 ff fc 	ld.w	r8,r7[-4]
800087ce:	5b f8       	cp.w	r8,-1
800087d0:	c0 71       	brne	800087de <vListInsert+0x2e>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
800087d2:	ee f8 ff f4 	ld.w	r8,r7[-12]
800087d6:	70 48       	ld.w	r8,r8[0x10]
800087d8:	ef 48 ff f8 	st.w	r7[-8],r8
800087dc:	c1 58       	rjmp	80008806 <vListInsert+0x56>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
800087de:	ee f8 ff f4 	ld.w	r8,r7[-12]
800087e2:	2f 88       	sub	r8,-8
800087e4:	ef 48 ff f8 	st.w	r7[-8],r8
800087e8:	c0 68       	rjmp	800087f4 <vListInsert+0x44>
800087ea:	ee f8 ff f8 	ld.w	r8,r7[-8]
800087ee:	70 18       	ld.w	r8,r8[0x4]
800087f0:	ef 48 ff f8 	st.w	r7[-8],r8
800087f4:	ee f8 ff f8 	ld.w	r8,r7[-8]
800087f8:	70 18       	ld.w	r8,r8[0x4]
800087fa:	70 09       	ld.w	r9,r8[0x0]
800087fc:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008800:	10 39       	cp.w	r9,r8
80008802:	fe 98 ff f4 	brls	800087ea <vListInsert+0x3a>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
80008806:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000880a:	70 19       	ld.w	r9,r8[0x4]
8000880c:	ee f8 ff f0 	ld.w	r8,r7[-16]
80008810:	91 19       	st.w	r8[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80008812:	ee f8 ff f0 	ld.w	r8,r7[-16]
80008816:	70 18       	ld.w	r8,r8[0x4]
80008818:	ee f9 ff f0 	ld.w	r9,r7[-16]
8000881c:	91 29       	st.w	r8[0x8],r9
	pxNewListItem->pxPrevious = pxIterator;
8000881e:	ee f8 ff f0 	ld.w	r8,r7[-16]
80008822:	ee f9 ff f8 	ld.w	r9,r7[-8]
80008826:	91 29       	st.w	r8[0x8],r9
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
80008828:	ee f9 ff f0 	ld.w	r9,r7[-16]
8000882c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80008830:	91 19       	st.w	r8[0x4],r9

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80008832:	ee f8 ff f0 	ld.w	r8,r7[-16]
80008836:	ee f9 ff f4 	ld.w	r9,r7[-12]
8000883a:	91 49       	st.w	r8[0x10],r9

	( pxList->uxNumberOfItems )++;
8000883c:	ee f8 ff f4 	ld.w	r8,r7[-12]
80008840:	70 08       	ld.w	r8,r8[0x0]
80008842:	f0 c9 ff ff 	sub	r9,r8,-1
80008846:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000884a:	91 09       	st.w	r8[0x0],r9
}
8000884c:	2f cd       	sub	sp,-16
8000884e:	e3 cd 80 80 	ldm	sp++,r7,pc

80008852 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
80008852:	eb cd 40 80 	pushm	r7,lr
80008856:	1a 97       	mov	r7,sp
80008858:	20 2d       	sub	sp,8
8000885a:	ef 4c ff f8 	st.w	r7[-8],r12
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
8000885e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80008862:	70 18       	ld.w	r8,r8[0x4]
80008864:	ee f9 ff f8 	ld.w	r9,r7[-8]
80008868:	72 29       	ld.w	r9,r9[0x8]
8000886a:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
8000886c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80008870:	70 28       	ld.w	r8,r8[0x8]
80008872:	ee f9 ff f8 	ld.w	r9,r7[-8]
80008876:	72 19       	ld.w	r9,r9[0x4]
80008878:	91 19       	st.w	r8[0x4],r9

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
8000887a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000887e:	70 48       	ld.w	r8,r8[0x10]
80008880:	ef 48 ff fc 	st.w	r7[-4],r8

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
80008884:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008888:	70 19       	ld.w	r9,r8[0x4]
8000888a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000888e:	10 39       	cp.w	r9,r8
80008890:	c0 71       	brne	8000889e <vListRemove+0x4c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
80008892:	ee f8 ff f8 	ld.w	r8,r7[-8]
80008896:	70 29       	ld.w	r9,r8[0x8]
80008898:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000889c:	91 19       	st.w	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
8000889e:	ee f8 ff f8 	ld.w	r8,r7[-8]
800088a2:	30 09       	mov	r9,0
800088a4:	91 49       	st.w	r8[0x10],r9
	( pxList->uxNumberOfItems )--;
800088a6:	ee f8 ff fc 	ld.w	r8,r7[-4]
800088aa:	70 08       	ld.w	r8,r8[0x0]
800088ac:	f0 c9 00 01 	sub	r9,r8,1
800088b0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800088b4:	91 09       	st.w	r8[0x0],r9
}
800088b6:	2f ed       	sub	sp,-8
800088b8:	e3 cd 80 80 	ldm	sp++,r7,pc

800088bc <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
800088bc:	eb cd 40 80 	pushm	r7,lr
800088c0:	1a 97       	mov	r7,sp
800088c2:	20 1d       	sub	sp,4
800088c4:	ef 4c ff fc 	st.w	r7[-4],r12
	vTaskSuspendAll();
800088c8:	f0 1f 00 03 	mcall	800088d4 <__malloc_lock+0x18>
}
800088cc:	2f fd       	sub	sp,-4
800088ce:	e3 cd 80 80 	ldm	sp++,r7,pc
800088d2:	00 00       	add	r0,r0
800088d4:	80 00       	ld.sh	r0,r0[0x0]
800088d6:	99 a8       	st.w	r12[0x28],r8

800088d8 <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
800088d8:	eb cd 40 80 	pushm	r7,lr
800088dc:	1a 97       	mov	r7,sp
800088de:	20 1d       	sub	sp,4
800088e0:	ef 4c ff fc 	st.w	r7[-4],r12
	xTaskResumeAll();
800088e4:	f0 1f 00 03 	mcall	800088f0 <__malloc_unlock+0x18>
}
800088e8:	2f fd       	sub	sp,-4
800088ea:	e3 cd 80 80 	ldm	sp++,r7,pc
800088ee:	00 00       	add	r0,r0
800088f0:	80 00       	ld.sh	r0,r0[0x0]
800088f2:	99 c4       	st.w	r12[0x30],r4

800088f4 <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
800088f4:	eb cd 00 ff 	pushm	r0-r7
800088f8:	e0 68 05 48 	mov	r8,1352
800088fc:	ea 18 00 00 	orh	r8,0x0
80008900:	70 00       	ld.w	r0,r8[0x0]
80008902:	1a d0       	st.w	--sp,r0
80008904:	7a 90       	ld.w	r0,sp[0x24]
80008906:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
8000890a:	58 10       	cp.w	r0,1
8000890c:	e0 8b 00 08 	brhi	8000891c <LABEL_INT_SKIP_SAVE_CONTEXT_237>
80008910:	e0 68 0c 28 	mov	r8,3112
80008914:	ea 18 00 00 	orh	r8,0x0
80008918:	70 00       	ld.w	r0,r8[0x0]
8000891a:	81 0d       	st.w	r0[0x0],sp

8000891c <LABEL_INT_SKIP_SAVE_CONTEXT_237>:
	#if( configTICK_USE_TC==1 )
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Clear the interrupt flag. */
		prvClearCcInt();
8000891c:	f0 1f 00 12 	mcall	80008964 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
80008920:	f0 1f 00 12 	mcall	80008968 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
		vTaskIncrementTick();
80008924:	f0 1f 00 12 	mcall	8000896c <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x1c>
	portEXIT_CRITICAL();
80008928:	f0 1f 00 12 	mcall	80008970 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
8000892c:	7a 90       	ld.w	r0,sp[0x24]
8000892e:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80008932:	58 10       	cp.w	r0,1
80008934:	e0 8b 00 0e 	brhi	80008950 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>
80008938:	f0 1f 00 0c 	mcall	80008968 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
8000893c:	f0 1f 00 0e 	mcall	80008974 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x24>
80008940:	f0 1f 00 0c 	mcall	80008970 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>
80008944:	e0 68 0c 28 	mov	r8,3112
80008948:	ea 18 00 00 	orh	r8,0x0
8000894c:	70 00       	ld.w	r0,r8[0x0]
8000894e:	60 0d       	ld.w	sp,r0[0x0]

80008950 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>:
80008950:	1b 00       	ld.w	r0,sp++
80008952:	e0 68 05 48 	mov	r8,1352
80008956:	ea 18 00 00 	orh	r8,0x0
8000895a:	91 00       	st.w	r8[0x0],r0
8000895c:	e3 cd 00 ff 	ldm	sp++,r0-r7
80008960:	d6 03       	rete
80008962:	00 00       	add	r0,r0
80008964:	80 00       	ld.sh	r0,r0[0x0]
80008966:	8c 60       	ld.sh	r0,r6[0xc]
80008968:	80 00       	ld.sh	r0,r0[0x0]
8000896a:	8a 10       	ld.sh	r0,r5[0x2]
8000896c:	80 00       	ld.sh	r0,r0[0x0]
8000896e:	9b 1c       	st.w	sp[0x4],r12
80008970:	80 00       	ld.sh	r0,r0[0x0]
80008972:	8a 2c       	ld.sh	r12,r5[0x4]
80008974:	80 00       	ld.sh	r0,r0[0x0]
80008976:	9c 7c       	ld.sh	r12,lr[0xe]

80008978 <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
80008978:	20 6d       	sub	sp,24
8000897a:	eb cd 00 ff 	pushm	r0-r7
8000897e:	fa c7 ff c0 	sub	r7,sp,-64
80008982:	ee f0 ff f8 	ld.w	r0,r7[-8]
80008986:	ef 40 ff e0 	st.w	r7[-32],r0
8000898a:	ee f0 ff fc 	ld.w	r0,r7[-4]
8000898e:	ef 40 ff e4 	st.w	r7[-28],r0
80008992:	eb c7 5f 00 	stm	--r7,r8-r12,lr
80008996:	e0 68 05 48 	mov	r8,1352
8000899a:	ea 18 00 00 	orh	r8,0x0
8000899e:	70 00       	ld.w	r0,r8[0x0]
800089a0:	1a d0       	st.w	--sp,r0
800089a2:	f0 1f 00 1a 	mcall	80008a08 <LABEL_RET_SCALL_263+0x14>
800089a6:	e0 68 0c 28 	mov	r8,3112
800089aa:	ea 18 00 00 	orh	r8,0x0
800089ae:	70 00       	ld.w	r0,r8[0x0]
800089b0:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
800089b2:	f0 1f 00 17 	mcall	80008a0c <LABEL_RET_SCALL_263+0x18>
	portRESTORE_CONTEXT_SCALL();
800089b6:	e0 68 0c 28 	mov	r8,3112
800089ba:	ea 18 00 00 	orh	r8,0x0
800089be:	70 00       	ld.w	r0,r8[0x0]
800089c0:	60 0d       	ld.w	sp,r0[0x0]
800089c2:	1b 00       	ld.w	r0,sp++
800089c4:	e0 68 05 48 	mov	r8,1352
800089c8:	ea 18 00 00 	orh	r8,0x0
800089cc:	91 00       	st.w	r8[0x0],r0
800089ce:	fa c7 ff d8 	sub	r7,sp,-40
800089d2:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
800089d6:	ee f0 ff e0 	ld.w	r0,r7[-32]
800089da:	e0 61 05 48 	mov	r1,1352
800089de:	ea 11 00 00 	orh	r1,0x0
800089e2:	62 02       	ld.w	r2,r1[0x0]
800089e4:	58 02       	cp.w	r2,0
800089e6:	c0 70       	breq	800089f4 <LABEL_RET_SCALL_263>
800089e8:	e4 c2 00 01 	sub	r2,r2,1
800089ec:	83 02       	st.w	r1[0x0],r2
800089ee:	58 02       	cp.w	r2,0
800089f0:	c0 21       	brne	800089f4 <LABEL_RET_SCALL_263>
800089f2:	b1 c0       	cbr	r0,0x10

800089f4 <LABEL_RET_SCALL_263>:
800089f4:	ef 40 ff f8 	st.w	r7[-8],r0
800089f8:	ee f0 ff e4 	ld.w	r0,r7[-28]
800089fc:	ef 40 ff fc 	st.w	r7[-4],r0
80008a00:	e3 cd 00 ff 	ldm	sp++,r0-r7
80008a04:	2f ad       	sub	sp,-24
80008a06:	d6 13       	rets
80008a08:	80 00       	ld.sh	r0,r0[0x0]
80008a0a:	8a 10       	ld.sh	r0,r5[0x2]
80008a0c:	80 00       	ld.sh	r0,r0[0x0]
80008a0e:	9c 7c       	ld.sh	r12,lr[0xe]

80008a10 <vPortEnterCritical>:
/* The code generated by the GCC compiler uses the stack in different ways at
different optimisation levels.  The interrupt flags can therefore not always
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
80008a10:	eb cd 40 80 	pushm	r7,lr
80008a14:	1a 97       	mov	r7,sp
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
80008a16:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
80008a18:	48 48       	lddpc	r8,80008a28 <vPortEnterCritical+0x18>
80008a1a:	70 08       	ld.w	r8,r8[0x0]
80008a1c:	f0 c9 ff ff 	sub	r9,r8,-1
80008a20:	48 28       	lddpc	r8,80008a28 <vPortEnterCritical+0x18>
80008a22:	91 09       	st.w	r8[0x0],r9
}
80008a24:	e3 cd 80 80 	ldm	sp++,r7,pc
80008a28:	00 00       	add	r0,r0
80008a2a:	05 48       	ld.w	r8,--r2

80008a2c <vPortExitCritical>:
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
80008a2c:	eb cd 40 80 	pushm	r7,lr
80008a30:	1a 97       	mov	r7,sp
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
80008a32:	48 98       	lddpc	r8,80008a54 <vPortExitCritical+0x28>
80008a34:	70 08       	ld.w	r8,r8[0x0]
80008a36:	58 08       	cp.w	r8,0
80008a38:	c0 c0       	breq	80008a50 <vPortExitCritical+0x24>
	{
		ulCriticalNesting--;
80008a3a:	48 78       	lddpc	r8,80008a54 <vPortExitCritical+0x28>
80008a3c:	70 08       	ld.w	r8,r8[0x0]
80008a3e:	f0 c9 00 01 	sub	r9,r8,1
80008a42:	48 58       	lddpc	r8,80008a54 <vPortExitCritical+0x28>
80008a44:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
80008a46:	48 48       	lddpc	r8,80008a54 <vPortExitCritical+0x28>
80008a48:	70 08       	ld.w	r8,r8[0x0]
80008a4a:	58 08       	cp.w	r8,0
80008a4c:	c0 21       	brne	80008a50 <vPortExitCritical+0x24>
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
80008a4e:	d5 03       	csrf	0x10
		}
	}
}
80008a50:	e3 cd 80 80 	ldm	sp++,r7,pc
80008a54:	00 00       	add	r0,r0
80008a56:	05 48       	ld.w	r8,--r2

80008a58 <pxPortInitialiseStack>:
 * portSAVE_CONTEXT had been called.
 *
 * See header file for description.
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
80008a58:	eb cd 40 80 	pushm	r7,lr
80008a5c:	1a 97       	mov	r7,sp
80008a5e:	20 3d       	sub	sp,12
80008a60:	ef 4c ff fc 	st.w	r7[-4],r12
80008a64:	ef 4b ff f8 	st.w	r7[-8],r11
80008a68:	ef 4a ff f4 	st.w	r7[-12],r10
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
80008a6c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008a70:	20 48       	sub	r8,4
80008a72:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x08080808;					/* R8 */
80008a76:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008a7a:	e0 69 08 08 	mov	r9,2056
80008a7e:	ea 19 08 08 	orh	r9,0x808
80008a82:	91 09       	st.w	r8[0x0],r9
80008a84:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008a88:	20 48       	sub	r8,4
80008a8a:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x09090909;					/* R9 */
80008a8e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008a92:	e0 69 09 09 	mov	r9,2313
80008a96:	ea 19 09 09 	orh	r9,0x909
80008a9a:	91 09       	st.w	r8[0x0],r9
80008a9c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008aa0:	20 48       	sub	r8,4
80008aa2:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0A0A0A0A;					/* R10 */
80008aa6:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008aaa:	e0 69 0a 0a 	mov	r9,2570
80008aae:	ea 19 0a 0a 	orh	r9,0xa0a
80008ab2:	91 09       	st.w	r8[0x0],r9
80008ab4:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008ab8:	20 48       	sub	r8,4
80008aba:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0B0B0B0B;					/* R11 */
80008abe:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008ac2:	e0 69 0b 0b 	mov	r9,2827
80008ac6:	ea 19 0b 0b 	orh	r9,0xb0b
80008aca:	91 09       	st.w	r8[0x0],r9
80008acc:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008ad0:	20 48       	sub	r8,4
80008ad2:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pvParameters;					/* R12 */
80008ad6:	ee f9 ff f4 	ld.w	r9,r7[-12]
80008ada:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008ade:	91 09       	st.w	r8[0x0],r9
80008ae0:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008ae4:	20 48       	sub	r8,4
80008ae6:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xDEADBEEF;					/* R14/LR */
80008aea:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008aee:	e0 69 be ef 	mov	r9,48879
80008af2:	ea 19 de ad 	orh	r9,0xdead
80008af6:	91 09       	st.w	r8[0x0],r9
80008af8:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008afc:	20 48       	sub	r8,4
80008afe:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
80008b02:	ee f9 ff f8 	ld.w	r9,r7[-8]
80008b06:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008b0a:	91 09       	st.w	r8[0x0],r9
80008b0c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008b10:	20 48       	sub	r8,4
80008b12:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) portINITIAL_SR;				/* SR */
80008b16:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008b1a:	fc 19 00 40 	movh	r9,0x40
80008b1e:	91 09       	st.w	r8[0x0],r9
80008b20:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008b24:	20 48       	sub	r8,4
80008b26:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xFF0000FF;					/* R0 */
80008b2a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008b2e:	e0 69 00 ff 	mov	r9,255
80008b32:	ea 19 ff 00 	orh	r9,0xff00
80008b36:	91 09       	st.w	r8[0x0],r9
80008b38:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008b3c:	20 48       	sub	r8,4
80008b3e:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x01010101;					/* R1 */
80008b42:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008b46:	e0 69 01 01 	mov	r9,257
80008b4a:	ea 19 01 01 	orh	r9,0x101
80008b4e:	91 09       	st.w	r8[0x0],r9
80008b50:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008b54:	20 48       	sub	r8,4
80008b56:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x02020202;					/* R2 */
80008b5a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008b5e:	e0 69 02 02 	mov	r9,514
80008b62:	ea 19 02 02 	orh	r9,0x202
80008b66:	91 09       	st.w	r8[0x0],r9
80008b68:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008b6c:	20 48       	sub	r8,4
80008b6e:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x03030303;					/* R3 */
80008b72:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008b76:	e0 69 03 03 	mov	r9,771
80008b7a:	ea 19 03 03 	orh	r9,0x303
80008b7e:	91 09       	st.w	r8[0x0],r9
80008b80:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008b84:	20 48       	sub	r8,4
80008b86:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x04040404;					/* R4 */
80008b8a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008b8e:	e0 69 04 04 	mov	r9,1028
80008b92:	ea 19 04 04 	orh	r9,0x404
80008b96:	91 09       	st.w	r8[0x0],r9
80008b98:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008b9c:	20 48       	sub	r8,4
80008b9e:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x05050505;					/* R5 */
80008ba2:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008ba6:	e0 69 05 05 	mov	r9,1285
80008baa:	ea 19 05 05 	orh	r9,0x505
80008bae:	91 09       	st.w	r8[0x0],r9
80008bb0:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008bb4:	20 48       	sub	r8,4
80008bb6:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x06060606;					/* R6 */
80008bba:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008bbe:	e0 69 06 06 	mov	r9,1542
80008bc2:	ea 19 06 06 	orh	r9,0x606
80008bc6:	91 09       	st.w	r8[0x0],r9
80008bc8:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008bcc:	20 48       	sub	r8,4
80008bce:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x07070707;					/* R7 */
80008bd2:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008bd6:	e0 69 07 07 	mov	r9,1799
80008bda:	ea 19 07 07 	orh	r9,0x707
80008bde:	91 09       	st.w	r8[0x0],r9
80008be0:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008be4:	20 48       	sub	r8,4
80008be6:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack = ( portSTACK_TYPE ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
80008bea:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008bee:	30 09       	mov	r9,0
80008bf0:	91 09       	st.w	r8[0x0],r9

	return pxTopOfStack;
80008bf2:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
80008bf6:	10 9c       	mov	r12,r8
80008bf8:	2f dd       	sub	sp,-12
80008bfa:	e3 cd 80 80 	ldm	sp++,r7,pc
80008bfe:	d7 03       	nop

80008c00 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
80008c00:	eb cd 40 80 	pushm	r7,lr
80008c04:	1a 97       	mov	r7,sp
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();
80008c06:	f0 1f 00 10 	mcall	80008c44 <xPortStartScheduler+0x44>

	/* Start the first task. */
	portRESTORE_CONTEXT();
80008c0a:	e0 68 0c 28 	mov	r8,3112
80008c0e:	ea 18 00 00 	orh	r8,0x0
80008c12:	70 00       	ld.w	r0,r8[0x0]
80008c14:	60 0d       	ld.w	sp,r0[0x0]
80008c16:	1b 00       	ld.w	r0,sp++
80008c18:	e0 68 05 48 	mov	r8,1352
80008c1c:	ea 18 00 00 	orh	r8,0x0
80008c20:	91 00       	st.w	r8[0x0],r0
80008c22:	e3 cd 00 ff 	ldm	sp++,r0-r7
80008c26:	2f ed       	sub	sp,-8
80008c28:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
80008c2c:	fa f0 ff e0 	ld.w	r0,sp[-32]
80008c30:	e3 b0 00 00 	mtsr	0x0,r0
80008c34:	fa f0 ff dc 	ld.w	r0,sp[-36]
80008c38:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
80008c3c:	30 08       	mov	r8,0
}
80008c3e:	10 9c       	mov	r12,r8
80008c40:	e3 cd 80 80 	ldm	sp++,r7,pc
80008c44:	80 00       	ld.sh	r0,r0[0x0]
80008c46:	8c 74       	ld.sh	r4,r6[0xe]

80008c48 <prvScheduleFirstTick>:

/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
80008c48:	eb cd 40 80 	pushm	r7,lr
80008c4c:	1a 97       	mov	r7,sp
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);//cause!!!
80008c4e:	e0 68 5d c0 	mov	r8,24000
80008c52:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
80008c56:	30 08       	mov	r8,0
80008c58:	e3 b8 00 42 	mtsr	0x108,r8
	}
80008c5c:	e3 cd 80 80 	ldm	sp++,r7,pc

80008c60 <prvClearCcInt>:

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
80008c60:	eb cd 40 80 	pushm	r7,lr
80008c64:	1a 97       	mov	r7,sp
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
80008c66:	e1 b8 00 43 	mfsr	r8,0x10c
80008c6a:	e3 b8 00 43 	mtsr	0x10c,r8
	}
80008c6e:	e3 cd 80 80 	ldm	sp++,r7,pc
80008c72:	d7 03       	nop

80008c74 <prvSetupTimerInterrupt>:
#endif
/*-----------------------------------------------------------*/

/* Setup the timer to generate the tick interrupts. */
static void prvSetupTimerInterrupt(void)
{
80008c74:	eb cd 40 80 	pushm	r7,lr
80008c78:	1a 97       	mov	r7,sp
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
80008c7a:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
80008c7c:	30 0a       	mov	r10,0
80008c7e:	30 0b       	mov	r11,0
80008c80:	48 4c       	lddpc	r12,80008c90 <prvSetupTimerInterrupt+0x1c>
80008c82:	f0 1f 00 05 	mcall	80008c94 <prvSetupTimerInterrupt+0x20>
		prvScheduleFirstTick();
80008c86:	f0 1f 00 05 	mcall	80008c98 <prvSetupTimerInterrupt+0x24>
	}
	#endif
}
80008c8a:	e3 cd 80 80 	ldm	sp++,r7,pc
80008c8e:	00 00       	add	r0,r0
80008c90:	80 00       	ld.sh	r0,r0[0x0]
80008c92:	88 f4       	ld.uh	r4,r4[0xe]
80008c94:	80 00       	ld.sh	r0,r0[0x0]
80008c96:	78 a4       	ld.w	r4,r12[0x28]
80008c98:	80 00       	ld.sh	r0,r0[0x0]
80008c9a:	8c 48       	ld.sh	r8,r6[0x8]

80008c9c <_read>:
/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
{
80008c9c:	eb cd 40 80 	pushm	r7,lr
80008ca0:	1a 97       	mov	r7,sp
80008ca2:	20 5d       	sub	sp,20
80008ca4:	ef 4c ff f4 	st.w	r7[-12],r12
80008ca8:	ef 4b ff f0 	st.w	r7[-16],r11
80008cac:	ef 4a ff ec 	st.w	r7[-20],r10
  int nChars = 0;
80008cb0:	30 08       	mov	r8,0
80008cb2:	ef 48 ff f8 	st.w	r7[-8],r8

  if (file != 0)
80008cb6:	ee f8 ff f4 	ld.w	r8,r7[-12]
80008cba:	58 08       	cp.w	r8,0
80008cbc:	c2 40       	breq	80008d04 <_read+0x68>
    return -1;
80008cbe:	3f f8       	mov	r8,-1
80008cc0:	c2 b8       	rjmp	80008d16 <_read+0x7a>

  for (; len > 0; --len)
  {
    int c = usart_getchar(stdio_usart_base);
80008cc2:	49 88       	lddpc	r8,80008d20 <_read+0x84>
80008cc4:	70 08       	ld.w	r8,r8[0x0]
80008cc6:	10 9c       	mov	r12,r8
80008cc8:	f0 1f 00 17 	mcall	80008d24 <_read+0x88>
80008ccc:	18 98       	mov	r8,r12
80008cce:	ef 48 ff fc 	st.w	r7[-4],r8
    if (c < 0)
80008cd2:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008cd6:	58 08       	cp.w	r8,0
80008cd8:	c1 c5       	brlt	80008d10 <_read+0x74>
      break;

    *ptr++ = c;
80008cda:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008cde:	5c 58       	castu.b	r8
80008ce0:	ee f9 ff f0 	ld.w	r9,r7[-16]
80008ce4:	b2 88       	st.b	r9[0x0],r8
80008ce6:	ee f8 ff f0 	ld.w	r8,r7[-16]
80008cea:	2f f8       	sub	r8,-1
80008cec:	ef 48 ff f0 	st.w	r7[-16],r8
    ++nChars;
80008cf0:	ee f8 ff f8 	ld.w	r8,r7[-8]
80008cf4:	2f f8       	sub	r8,-1
80008cf6:	ef 48 ff f8 	st.w	r7[-8],r8
  int nChars = 0;

  if (file != 0)
    return -1;

  for (; len > 0; --len)
80008cfa:	ee f8 ff ec 	ld.w	r8,r7[-20]
80008cfe:	20 18       	sub	r8,1
80008d00:	ef 48 ff ec 	st.w	r7[-20],r8
80008d04:	ee f8 ff ec 	ld.w	r8,r7[-20]
80008d08:	58 08       	cp.w	r8,0
80008d0a:	fe 99 ff dc 	brgt	80008cc2 <_read+0x26>
80008d0e:	c0 28       	rjmp	80008d12 <_read+0x76>
  {
    int c = usart_getchar(stdio_usart_base);
    if (c < 0)
      break;
80008d10:	d7 03       	nop

    *ptr++ = c;
    ++nChars;
  }

  return nChars;
80008d12:	ee f8 ff f8 	ld.w	r8,r7[-8]
}
80008d16:	10 9c       	mov	r12,r8
80008d18:	2f bd       	sub	sp,-20
80008d1a:	e3 cd 80 80 	ldm	sp++,r7,pc
80008d1e:	00 00       	add	r0,r0
80008d20:	00 00       	add	r0,r0
80008d22:	53 1c       	stdsp	sp[0xc4],r12
80008d24:	80 00       	ld.sh	r0,r0[0x0]
80008d26:	86 54       	ld.sh	r4,r3[0xa]

80008d28 <_write>:
 * 1 and 2 is stdout and stderr which goes to usart
 * 3 is framebuffer
 */
int __attribute__((weak))
_write (int file, char * ptr, int len)
{
80008d28:	eb cd 40 80 	pushm	r7,lr
80008d2c:	1a 97       	mov	r7,sp
80008d2e:	20 4d       	sub	sp,16
80008d30:	ef 4c ff f8 	st.w	r7[-8],r12
80008d34:	ef 4b ff f4 	st.w	r7[-12],r11
80008d38:	ef 4a ff f0 	st.w	r7[-16],r10
  int nChars = 0;
80008d3c:	30 08       	mov	r8,0
80008d3e:	ef 48 ff fc 	st.w	r7[-4],r8

  if ( (file != 1)
80008d42:	ee f8 ff f8 	ld.w	r8,r7[-8]
80008d46:	58 18       	cp.w	r8,1
80008d48:	c2 90       	breq	80008d9a <_write+0x72>
80008d4a:	ee f8 ff f8 	ld.w	r8,r7[-8]
80008d4e:	58 28       	cp.w	r8,2
80008d50:	c2 50       	breq	80008d9a <_write+0x72>
80008d52:	ee f8 ff f8 	ld.w	r8,r7[-8]
80008d56:	58 38       	cp.w	r8,3
80008d58:	c2 10       	breq	80008d9a <_write+0x72>
       && (file != 2) && (file!=3))
    return -1;
80008d5a:	3f f8       	mov	r8,-1
80008d5c:	c2 58       	rjmp	80008da6 <_write+0x7e>

  for (; len != 0; --len)
  {
    if (usart_putchar(stdio_usart_base, *ptr++) < 0)
80008d5e:	ee f8 ff f4 	ld.w	r8,r7[-12]
80008d62:	11 88       	ld.ub	r8,r8[0x0]
80008d64:	10 99       	mov	r9,r8
80008d66:	ee f8 ff f4 	ld.w	r8,r7[-12]
80008d6a:	2f f8       	sub	r8,-1
80008d6c:	ef 48 ff f4 	st.w	r7[-12],r8
80008d70:	49 08       	lddpc	r8,80008db0 <_write+0x88>
80008d72:	70 08       	ld.w	r8,r8[0x0]
80008d74:	12 9b       	mov	r11,r9
80008d76:	10 9c       	mov	r12,r8
80008d78:	f0 1f 00 0f 	mcall	80008db4 <_write+0x8c>
80008d7c:	18 98       	mov	r8,r12
80008d7e:	58 08       	cp.w	r8,0
80008d80:	c0 34       	brge	80008d86 <_write+0x5e>
    {
      return -1;
80008d82:	3f f8       	mov	r8,-1
80008d84:	c1 18       	rjmp	80008da6 <_write+0x7e>
    }

    ++nChars;
80008d86:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008d8a:	2f f8       	sub	r8,-1
80008d8c:	ef 48 ff fc 	st.w	r7[-4],r8

  if ( (file != 1)
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80008d90:	ee f8 ff f0 	ld.w	r8,r7[-16]
80008d94:	20 18       	sub	r8,1
80008d96:	ef 48 ff f0 	st.w	r7[-16],r8
80008d9a:	ee f8 ff f0 	ld.w	r8,r7[-16]
80008d9e:	58 08       	cp.w	r8,0
80008da0:	cd f1       	brne	80008d5e <_write+0x36>
    }

    ++nChars;
  }

  return nChars;
80008da2:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
80008da6:	10 9c       	mov	r12,r8
80008da8:	2f cd       	sub	sp,-16
80008daa:	e3 cd 80 80 	ldm	sp++,r7,pc
80008dae:	00 00       	add	r0,r0
80008db0:	00 00       	add	r0,r0
80008db2:	53 1c       	stdsp	sp[0xc4],r12
80008db4:	80 00       	ld.sh	r0,r0[0x0]
80008db6:	85 ac       	st.w	r2[0x28],r12

80008db8 <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
80008db8:	eb cd 40 80 	pushm	r7,lr
80008dbc:	1a 97       	mov	r7,sp
80008dbe:	20 2d       	sub	sp,8
80008dc0:	ef 4c ff f8 	st.w	r7[-8],r12
void *pvReturn;

	vTaskSuspendAll();
80008dc4:	f0 1f 00 09 	mcall	80008de8 <pvPortMalloc+0x30>
	{
		pvReturn = malloc( xWantedSize );
80008dc8:	ee fc ff f8 	ld.w	r12,r7[-8]
80008dcc:	f0 1f 00 08 	mcall	80008dec <pvPortMalloc+0x34>
80008dd0:	18 98       	mov	r8,r12
80008dd2:	ef 48 ff fc 	st.w	r7[-4],r8
	}
	xTaskResumeAll();
80008dd6:	f0 1f 00 07 	mcall	80008df0 <pvPortMalloc+0x38>
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
80008dda:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
80008dde:	10 9c       	mov	r12,r8
80008de0:	2f ed       	sub	sp,-8
80008de2:	e3 cd 80 80 	ldm	sp++,r7,pc
80008de6:	00 00       	add	r0,r0
80008de8:	80 00       	ld.sh	r0,r0[0x0]
80008dea:	99 a8       	st.w	r12[0x28],r8
80008dec:	80 00       	ld.sh	r0,r0[0x0]
80008dee:	b0 f4       	st.b	r8[0x7],r4
80008df0:	80 00       	ld.sh	r0,r0[0x0]
80008df2:	99 c4       	st.w	r12[0x30],r4

80008df4 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
80008df4:	eb cd 40 80 	pushm	r7,lr
80008df8:	1a 97       	mov	r7,sp
80008dfa:	20 1d       	sub	sp,4
80008dfc:	ef 4c ff fc 	st.w	r7[-4],r12
	if( pv )
80008e00:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008e04:	58 08       	cp.w	r8,0
80008e06:	c0 90       	breq	80008e18 <vPortFree+0x24>
	{
		vTaskSuspendAll();
80008e08:	f0 1f 00 06 	mcall	80008e20 <vPortFree+0x2c>
		{
			free( pv );
80008e0c:	ee fc ff fc 	ld.w	r12,r7[-4]
80008e10:	f0 1f 00 05 	mcall	80008e24 <vPortFree+0x30>
		}
		xTaskResumeAll();
80008e14:	f0 1f 00 05 	mcall	80008e28 <vPortFree+0x34>
	}
}
80008e18:	2f fd       	sub	sp,-4
80008e1a:	e3 cd 80 80 	ldm	sp++,r7,pc
80008e1e:	00 00       	add	r0,r0
80008e20:	80 00       	ld.sh	r0,r0[0x0]
80008e22:	99 a8       	st.w	r12[0x28],r8
80008e24:	80 00       	ld.sh	r0,r0[0x0]
80008e26:	b0 e4       	st.b	r8[0x6],r4
80008e28:	80 00       	ld.sh	r0,r0[0x0]
80008e2a:	99 c4       	st.w	r12[0x30],r4

80008e2c <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
80008e2c:	eb cd 40 80 	pushm	r7,lr
80008e30:	1a 97       	mov	r7,sp
80008e32:	20 5d       	sub	sp,20
80008e34:	ef 4c ff f0 	st.w	r7[-16],r12
80008e38:	ef 4b ff ec 	st.w	r7[-20],r11
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
80008e3c:	30 08       	mov	r8,0
80008e3e:	ef 48 ff fc 	st.w	r7[-4],r8

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
80008e42:	ee f8 ff f0 	ld.w	r8,r7[-16]
80008e46:	58 08       	cp.w	r8,0
80008e48:	c7 20       	breq	80008f2c <xQueueCreate+0x100>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
80008e4a:	34 cc       	mov	r12,76
80008e4c:	f0 1f 00 3b 	mcall	80008f38 <xQueueCreate+0x10c>
80008e50:	18 98       	mov	r8,r12
80008e52:	ef 48 ff f4 	st.w	r7[-12],r8
		if( pxNewQueue != NULL )
80008e56:	ee f8 ff f4 	ld.w	r8,r7[-12]
80008e5a:	58 08       	cp.w	r8,0
80008e5c:	c6 80       	breq	80008f2c <xQueueCreate+0x100>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
80008e5e:	ee f9 ff f0 	ld.w	r9,r7[-16]
80008e62:	ee f8 ff ec 	ld.w	r8,r7[-20]
80008e66:	f2 08 02 48 	mul	r8,r9,r8
80008e6a:	2f f8       	sub	r8,-1
80008e6c:	ef 48 ff f8 	st.w	r7[-8],r8

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
80008e70:	ee fc ff f8 	ld.w	r12,r7[-8]
80008e74:	f0 1f 00 31 	mcall	80008f38 <xQueueCreate+0x10c>
80008e78:	18 98       	mov	r8,r12
80008e7a:	10 99       	mov	r9,r8
80008e7c:	ee f8 ff f4 	ld.w	r8,r7[-12]
80008e80:	91 09       	st.w	r8[0x0],r9
			if( pxNewQueue->pcHead != NULL )
80008e82:	ee f8 ff f4 	ld.w	r8,r7[-12]
80008e86:	70 08       	ld.w	r8,r8[0x0]
80008e88:	58 08       	cp.w	r8,0
80008e8a:	c4 d0       	breq	80008f24 <xQueueCreate+0xf8>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
80008e8c:	ee f8 ff f4 	ld.w	r8,r7[-12]
80008e90:	70 09       	ld.w	r9,r8[0x0]
80008e92:	ee fa ff f0 	ld.w	r10,r7[-16]
80008e96:	ee f8 ff ec 	ld.w	r8,r7[-20]
80008e9a:	f4 08 02 48 	mul	r8,r10,r8
80008e9e:	10 09       	add	r9,r8
80008ea0:	ee f8 ff f4 	ld.w	r8,r7[-12]
80008ea4:	91 19       	st.w	r8[0x4],r9
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
80008ea6:	ee f8 ff f4 	ld.w	r8,r7[-12]
80008eaa:	30 09       	mov	r9,0
80008eac:	91 e9       	st.w	r8[0x38],r9
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
80008eae:	ee f8 ff f4 	ld.w	r8,r7[-12]
80008eb2:	70 09       	ld.w	r9,r8[0x0]
80008eb4:	ee f8 ff f4 	ld.w	r8,r7[-12]
80008eb8:	91 29       	st.w	r8[0x8],r9
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
80008eba:	ee f8 ff f4 	ld.w	r8,r7[-12]
80008ebe:	70 09       	ld.w	r9,r8[0x0]
80008ec0:	ee f8 ff f0 	ld.w	r8,r7[-16]
80008ec4:	f0 ca 00 01 	sub	r10,r8,1
80008ec8:	ee f8 ff ec 	ld.w	r8,r7[-20]
80008ecc:	f4 08 02 48 	mul	r8,r10,r8
80008ed0:	10 09       	add	r9,r8
80008ed2:	ee f8 ff f4 	ld.w	r8,r7[-12]
80008ed6:	91 39       	st.w	r8[0xc],r9
				pxNewQueue->uxLength = uxQueueLength;
80008ed8:	ee f8 ff f4 	ld.w	r8,r7[-12]
80008edc:	ee f9 ff f0 	ld.w	r9,r7[-16]
80008ee0:	91 f9       	st.w	r8[0x3c],r9
				pxNewQueue->uxItemSize = uxItemSize;
80008ee2:	ee f8 ff f4 	ld.w	r8,r7[-12]
80008ee6:	ee f9 ff ec 	ld.w	r9,r7[-20]
80008eea:	f1 49 00 40 	st.w	r8[64],r9
				pxNewQueue->xRxLock = queueUNLOCKED;
80008eee:	ee f8 ff f4 	ld.w	r8,r7[-12]
80008ef2:	3f f9       	mov	r9,-1
80008ef4:	f1 49 00 44 	st.w	r8[68],r9
				pxNewQueue->xTxLock = queueUNLOCKED;
80008ef8:	ee f8 ff f4 	ld.w	r8,r7[-12]
80008efc:	3f f9       	mov	r9,-1
80008efe:	f1 49 00 48 	st.w	r8[72],r9

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
80008f02:	ee f8 ff f4 	ld.w	r8,r7[-12]
80008f06:	2f 08       	sub	r8,-16
80008f08:	10 9c       	mov	r12,r8
80008f0a:	f0 1f 00 0d 	mcall	80008f3c <xQueueCreate+0x110>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
80008f0e:	ee f8 ff f4 	ld.w	r8,r7[-12]
80008f12:	2d c8       	sub	r8,-36
80008f14:	10 9c       	mov	r12,r8
80008f16:	f0 1f 00 0a 	mcall	80008f3c <xQueueCreate+0x110>

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
80008f1a:	ee f8 ff f4 	ld.w	r8,r7[-12]
80008f1e:	ef 48 ff fc 	st.w	r7[-4],r8
80008f22:	c0 58       	rjmp	80008f2c <xQueueCreate+0x100>
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
80008f24:	ee fc ff f4 	ld.w	r12,r7[-12]
80008f28:	f0 1f 00 06 	mcall	80008f40 <xQueueCreate+0x114>
		}
	}

	configASSERT( xReturn );

	return xReturn;
80008f2c:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
80008f30:	10 9c       	mov	r12,r8
80008f32:	2f bd       	sub	sp,-20
80008f34:	e3 cd 80 80 	ldm	sp++,r7,pc
80008f38:	80 00       	ld.sh	r0,r0[0x0]
80008f3a:	8d b8       	st.w	r6[0x2c],r8
80008f3c:	80 00       	ld.sh	r0,r0[0x0]
80008f3e:	86 d8       	ld.uh	r8,r3[0xa]
80008f40:	80 00       	ld.sh	r0,r0[0x0]
80008f42:	8d f4       	st.w	r6[0x3c],r4

80008f44 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
80008f44:	eb cd 40 80 	pushm	r7,lr
80008f48:	1a 97       	mov	r7,sp
80008f4a:	20 7d       	sub	sp,28
80008f4c:	ef 4c ff f0 	st.w	r7[-16],r12
80008f50:	ef 4b ff ec 	st.w	r7[-20],r11
80008f54:	ef 4a ff e8 	st.w	r7[-24],r10
80008f58:	ef 49 ff e4 	st.w	r7[-28],r9
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
80008f5c:	30 08       	mov	r8,0
80008f5e:	ef 48 ff fc 	st.w	r7[-4],r8
80008f62:	c0 28       	rjmp	80008f66 <xQueueGenericSend+0x22>
			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
80008f64:	d7 03       	nop
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
80008f66:	f0 1f 00 47 	mcall	80009080 <xQueueGenericSend+0x13c>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80008f6a:	ee f8 ff f0 	ld.w	r8,r7[-16]
80008f6e:	70 e9       	ld.w	r9,r8[0x38]
80008f70:	ee f8 ff f0 	ld.w	r8,r7[-16]
80008f74:	70 f8       	ld.w	r8,r8[0x3c]
80008f76:	10 39       	cp.w	r9,r8
80008f78:	c1 c2       	brcc	80008fb0 <xQueueGenericSend+0x6c>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80008f7a:	ee fa ff e4 	ld.w	r10,r7[-28]
80008f7e:	ee fb ff ec 	ld.w	r11,r7[-20]
80008f82:	ee fc ff f0 	ld.w	r12,r7[-16]
80008f86:	f0 1f 00 40 	mcall	80009084 <xQueueGenericSend+0x140>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80008f8a:	ee f8 ff f0 	ld.w	r8,r7[-16]
80008f8e:	70 98       	ld.w	r8,r8[0x24]
80008f90:	58 08       	cp.w	r8,0
80008f92:	c0 b0       	breq	80008fa8 <xQueueGenericSend+0x64>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
80008f94:	ee f8 ff f0 	ld.w	r8,r7[-16]
80008f98:	2d c8       	sub	r8,-36
80008f9a:	10 9c       	mov	r12,r8
80008f9c:	f0 1f 00 3b 	mcall	80009088 <xQueueGenericSend+0x144>
80008fa0:	18 98       	mov	r8,r12
80008fa2:	58 18       	cp.w	r8,1
80008fa4:	c0 21       	brne	80008fa8 <xQueueGenericSend+0x64>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
80008fa6:	d7 33       	scall
					}
				}

				taskEXIT_CRITICAL();
80008fa8:	f0 1f 00 39 	mcall	8000908c <xQueueGenericSend+0x148>

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
80008fac:	30 18       	mov	r8,1
80008fae:	c6 58       	rjmp	80009078 <xQueueGenericSend+0x134>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
80008fb0:	ee f8 ff e8 	ld.w	r8,r7[-24]
80008fb4:	58 08       	cp.w	r8,0
80008fb6:	c0 51       	brne	80008fc0 <xQueueGenericSend+0x7c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80008fb8:	f0 1f 00 35 	mcall	8000908c <xQueueGenericSend+0x148>

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
80008fbc:	30 08       	mov	r8,0
80008fbe:	c5 d8       	rjmp	80009078 <xQueueGenericSend+0x134>
				}
				else if( xEntryTimeSet == pdFALSE )
80008fc0:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008fc4:	58 08       	cp.w	r8,0
80008fc6:	c0 91       	brne	80008fd8 <xQueueGenericSend+0x94>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80008fc8:	ee c8 00 0c 	sub	r8,r7,12
80008fcc:	10 9c       	mov	r12,r8
80008fce:	f0 1f 00 31 	mcall	80009090 <xQueueGenericSend+0x14c>
					xEntryTimeSet = pdTRUE;
80008fd2:	30 18       	mov	r8,1
80008fd4:	ef 48 ff fc 	st.w	r7[-4],r8
				}
			}
		}
		taskEXIT_CRITICAL();
80008fd8:	f0 1f 00 2d 	mcall	8000908c <xQueueGenericSend+0x148>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80008fdc:	f0 1f 00 2e 	mcall	80009094 <xQueueGenericSend+0x150>
		prvLockQueue( pxQueue );
80008fe0:	f0 1f 00 28 	mcall	80009080 <xQueueGenericSend+0x13c>
80008fe4:	ee f8 ff f0 	ld.w	r8,r7[-16]
80008fe8:	71 18       	ld.w	r8,r8[0x44]
80008fea:	5b f8       	cp.w	r8,-1
80008fec:	c0 61       	brne	80008ff8 <xQueueGenericSend+0xb4>
80008fee:	ee f8 ff f0 	ld.w	r8,r7[-16]
80008ff2:	30 09       	mov	r9,0
80008ff4:	f1 49 00 44 	st.w	r8[68],r9
80008ff8:	ee f8 ff f0 	ld.w	r8,r7[-16]
80008ffc:	71 28       	ld.w	r8,r8[0x48]
80008ffe:	5b f8       	cp.w	r8,-1
80009000:	c0 61       	brne	8000900c <xQueueGenericSend+0xc8>
80009002:	ee f8 ff f0 	ld.w	r8,r7[-16]
80009006:	30 09       	mov	r9,0
80009008:	f1 49 00 48 	st.w	r8[72],r9
8000900c:	f0 1f 00 20 	mcall	8000908c <xQueueGenericSend+0x148>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80009010:	ee c9 00 18 	sub	r9,r7,24
80009014:	ee c8 00 0c 	sub	r8,r7,12
80009018:	12 9b       	mov	r11,r9
8000901a:	10 9c       	mov	r12,r8
8000901c:	f0 1f 00 1f 	mcall	80009098 <xQueueGenericSend+0x154>
80009020:	18 98       	mov	r8,r12
80009022:	58 08       	cp.w	r8,0
80009024:	c2 31       	brne	8000906a <xQueueGenericSend+0x126>
		{
			if( prvIsQueueFull( pxQueue ) )
80009026:	ee fc ff f0 	ld.w	r12,r7[-16]
8000902a:	f0 1f 00 1d 	mcall	8000909c <xQueueGenericSend+0x158>
8000902e:	18 98       	mov	r8,r12
80009030:	58 08       	cp.w	r8,0
80009032:	c1 50       	breq	8000905c <xQueueGenericSend+0x118>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
80009034:	ee f9 ff e8 	ld.w	r9,r7[-24]
80009038:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000903c:	2f 08       	sub	r8,-16
8000903e:	12 9b       	mov	r11,r9
80009040:	10 9c       	mov	r12,r8
80009042:	f0 1f 00 18 	mcall	800090a0 <xQueueGenericSend+0x15c>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
80009046:	ee fc ff f0 	ld.w	r12,r7[-16]
8000904a:	f0 1f 00 17 	mcall	800090a4 <xQueueGenericSend+0x160>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
8000904e:	f0 1f 00 17 	mcall	800090a8 <xQueueGenericSend+0x164>
80009052:	18 98       	mov	r8,r12
80009054:	58 08       	cp.w	r8,0
80009056:	c8 71       	brne	80008f64 <xQueueGenericSend+0x20>
				{
					portYIELD_WITHIN_API();
80009058:	d7 33       	scall
			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
8000905a:	c8 6b       	rjmp	80008f66 <xQueueGenericSend+0x22>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
8000905c:	ee fc ff f0 	ld.w	r12,r7[-16]
80009060:	f0 1f 00 11 	mcall	800090a4 <xQueueGenericSend+0x160>
				( void ) xTaskResumeAll();
80009064:	f0 1f 00 11 	mcall	800090a8 <xQueueGenericSend+0x164>
			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
80009068:	c7 fb       	rjmp	80008f66 <xQueueGenericSend+0x22>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
8000906a:	ee fc ff f0 	ld.w	r12,r7[-16]
8000906e:	f0 1f 00 0e 	mcall	800090a4 <xQueueGenericSend+0x160>
			( void ) xTaskResumeAll();
80009072:	f0 1f 00 0e 	mcall	800090a8 <xQueueGenericSend+0x164>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
80009076:	30 08       	mov	r8,0
		}
	}
}
80009078:	10 9c       	mov	r12,r8
8000907a:	2f 9d       	sub	sp,-28
8000907c:	e3 cd 80 80 	ldm	sp++,r7,pc
80009080:	80 00       	ld.sh	r0,r0[0x0]
80009082:	8a 10       	ld.sh	r0,r5[0x2]
80009084:	80 00       	ld.sh	r0,r0[0x0]
80009086:	93 e0       	st.w	r9[0x38],r0
80009088:	80 00       	ld.sh	r0,r0[0x0]
8000908a:	9d ac       	st.w	lr[0x28],r12
8000908c:	80 00       	ld.sh	r0,r0[0x0]
8000908e:	8a 2c       	ld.sh	r12,r5[0x4]
80009090:	80 00       	ld.sh	r0,r0[0x0]
80009092:	9e 7c       	ld.sh	r12,pc[0xe]
80009094:	80 00       	ld.sh	r0,r0[0x0]
80009096:	99 a8       	st.w	r12[0x28],r8
80009098:	80 00       	ld.sh	r0,r0[0x0]
8000909a:	9e ac       	ld.uh	r12,pc[0x4]
8000909c:	80 00       	ld.sh	r0,r0[0x0]
8000909e:	96 58       	ld.sh	r8,r11[0xa]
800090a0:	80 00       	ld.sh	r0,r0[0x0]
800090a2:	9d 2c       	st.w	lr[0x8],r12
800090a4:	80 00       	ld.sh	r0,r0[0x0]
800090a6:	95 50       	st.w	r10[0x14],r0
800090a8:	80 00       	ld.sh	r0,r0[0x0]
800090aa:	99 c4       	st.w	r12[0x30],r4

800090ac <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
800090ac:	eb cd 40 80 	pushm	r7,lr
800090b0:	1a 97       	mov	r7,sp
800090b2:	20 6d       	sub	sp,24
800090b4:	ef 4c ff f4 	st.w	r7[-12],r12
800090b8:	ef 4b ff f0 	st.w	r7[-16],r11
800090bc:	ef 4a ff ec 	st.w	r7[-20],r10
800090c0:	ef 49 ff e8 	st.w	r7[-24],r9
	/* Similar to xQueueGenericSend, except we don't block if there is no room
	in the queue.  Also we don't directly wake a task that was blocked on a
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
800090c4:	30 08       	mov	r8,0
800090c6:	ef 48 ff fc 	st.w	r7[-4],r8
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
800090ca:	ee f8 ff f4 	ld.w	r8,r7[-12]
800090ce:	70 e9       	ld.w	r9,r8[0x38]
800090d0:	ee f8 ff f4 	ld.w	r8,r7[-12]
800090d4:	70 f8       	ld.w	r8,r8[0x3c]
800090d6:	10 39       	cp.w	r9,r8
800090d8:	c2 e2       	brcc	80009134 <xQueueGenericSendFromISR+0x88>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
800090da:	ee fa ff e8 	ld.w	r10,r7[-24]
800090de:	ee fb ff f0 	ld.w	r11,r7[-16]
800090e2:	ee fc ff f4 	ld.w	r12,r7[-12]
800090e6:	f0 1f 00 19 	mcall	80009148 <xQueueGenericSendFromISR+0x9c>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
800090ea:	ee f8 ff f4 	ld.w	r8,r7[-12]
800090ee:	71 28       	ld.w	r8,r8[0x48]
800090f0:	5b f8       	cp.w	r8,-1
800090f2:	c1 41       	brne	8000911a <xQueueGenericSendFromISR+0x6e>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800090f4:	ee f8 ff f4 	ld.w	r8,r7[-12]
800090f8:	70 98       	ld.w	r8,r8[0x24]
800090fa:	58 08       	cp.w	r8,0
800090fc:	c1 80       	breq	8000912c <xQueueGenericSendFromISR+0x80>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
800090fe:	ee f8 ff f4 	ld.w	r8,r7[-12]
80009102:	2d c8       	sub	r8,-36
80009104:	10 9c       	mov	r12,r8
80009106:	f0 1f 00 12 	mcall	8000914c <xQueueGenericSendFromISR+0xa0>
8000910a:	18 98       	mov	r8,r12
8000910c:	58 08       	cp.w	r8,0
8000910e:	c0 f0       	breq	8000912c <xQueueGenericSendFromISR+0x80>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
80009110:	ee f8 ff ec 	ld.w	r8,r7[-20]
80009114:	30 19       	mov	r9,1
80009116:	91 09       	st.w	r8[0x0],r9
80009118:	c0 a8       	rjmp	8000912c <xQueueGenericSendFromISR+0x80>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
8000911a:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000911e:	71 28       	ld.w	r8,r8[0x48]
80009120:	f0 c9 ff ff 	sub	r9,r8,-1
80009124:	ee f8 ff f4 	ld.w	r8,r7[-12]
80009128:	f1 49 00 48 	st.w	r8[72],r9
			}

			xReturn = pdPASS;
8000912c:	30 18       	mov	r8,1
8000912e:	ef 48 ff f8 	st.w	r7[-8],r8
80009132:	c0 48       	rjmp	8000913a <xQueueGenericSendFromISR+0x8e>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
80009134:	30 08       	mov	r8,0
80009136:	ef 48 ff f8 	st.w	r7[-8],r8
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
8000913a:	ee f8 ff f8 	ld.w	r8,r7[-8]
}
8000913e:	10 9c       	mov	r12,r8
80009140:	2f ad       	sub	sp,-24
80009142:	e3 cd 80 80 	ldm	sp++,r7,pc
80009146:	00 00       	add	r0,r0
80009148:	80 00       	ld.sh	r0,r0[0x0]
8000914a:	93 e0       	st.w	r9[0x38],r0
8000914c:	80 00       	ld.sh	r0,r0[0x0]
8000914e:	9d ac       	st.w	lr[0x28],r12

80009150 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
80009150:	eb cd 40 80 	pushm	r7,lr
80009154:	1a 97       	mov	r7,sp
80009156:	20 8d       	sub	sp,32
80009158:	ef 4c ff ec 	st.w	r7[-20],r12
8000915c:	ef 4b ff e8 	st.w	r7[-24],r11
80009160:	ef 4a ff e4 	st.w	r7[-28],r10
80009164:	ef 49 ff e0 	st.w	r7[-32],r9
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
80009168:	30 08       	mov	r8,0
8000916a:	ef 48 ff f8 	st.w	r7[-8],r8
8000916e:	c0 28       	rjmp	80009172 <xQueueGenericReceive+0x22>
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
80009170:	d7 03       	nop
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
80009172:	f0 1f 00 66 	mcall	80009308 <xQueueGenericReceive+0x1b8>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80009176:	ee f8 ff ec 	ld.w	r8,r7[-20]
8000917a:	70 e8       	ld.w	r8,r8[0x38]
8000917c:	58 08       	cp.w	r8,0
8000917e:	c4 c0       	breq	80009216 <xQueueGenericReceive+0xc6>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
80009180:	ee f8 ff ec 	ld.w	r8,r7[-20]
80009184:	70 38       	ld.w	r8,r8[0xc]
80009186:	ef 48 ff fc 	st.w	r7[-4],r8

				prvCopyDataFromQueue( pxQueue, pvBuffer );
8000918a:	ee fb ff e8 	ld.w	r11,r7[-24]
8000918e:	ee fc ff ec 	ld.w	r12,r7[-20]
80009192:	f0 1f 00 5f 	mcall	8000930c <xQueueGenericReceive+0x1bc>

				if( xJustPeeking == pdFALSE )
80009196:	ee f8 ff e0 	ld.w	r8,r7[-32]
8000919a:	58 08       	cp.w	r8,0
8000919c:	c2 51       	brne	800091e6 <xQueueGenericReceive+0x96>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
8000919e:	ee f8 ff ec 	ld.w	r8,r7[-20]
800091a2:	70 e8       	ld.w	r8,r8[0x38]
800091a4:	f0 c9 00 01 	sub	r9,r8,1
800091a8:	ee f8 ff ec 	ld.w	r8,r7[-20]
800091ac:	91 e9       	st.w	r8[0x38],r9

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
800091ae:	ee f8 ff ec 	ld.w	r8,r7[-20]
800091b2:	70 08       	ld.w	r8,r8[0x0]
800091b4:	58 08       	cp.w	r8,0
800091b6:	c0 81       	brne	800091c6 <xQueueGenericReceive+0x76>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
800091b8:	f0 1f 00 56 	mcall	80009310 <xQueueGenericReceive+0x1c0>
800091bc:	18 98       	mov	r8,r12
800091be:	10 99       	mov	r9,r8
800091c0:	ee f8 ff ec 	ld.w	r8,r7[-20]
800091c4:	91 19       	st.w	r8[0x4],r9
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
800091c6:	ee f8 ff ec 	ld.w	r8,r7[-20]
800091ca:	70 48       	ld.w	r8,r8[0x10]
800091cc:	58 08       	cp.w	r8,0
800091ce:	c2 00       	breq	8000920e <xQueueGenericReceive+0xbe>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
800091d0:	ee f8 ff ec 	ld.w	r8,r7[-20]
800091d4:	2f 08       	sub	r8,-16
800091d6:	10 9c       	mov	r12,r8
800091d8:	f0 1f 00 4f 	mcall	80009314 <xQueueGenericReceive+0x1c4>
800091dc:	18 98       	mov	r8,r12
800091de:	58 18       	cp.w	r8,1
800091e0:	c1 71       	brne	8000920e <xQueueGenericReceive+0xbe>
						{
							portYIELD_WITHIN_API();
800091e2:	d7 33       	scall
800091e4:	c1 58       	rjmp	8000920e <xQueueGenericReceive+0xbe>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
800091e6:	ee f8 ff ec 	ld.w	r8,r7[-20]
800091ea:	ee f9 ff fc 	ld.w	r9,r7[-4]
800091ee:	91 39       	st.w	r8[0xc],r9

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800091f0:	ee f8 ff ec 	ld.w	r8,r7[-20]
800091f4:	70 98       	ld.w	r8,r8[0x24]
800091f6:	58 08       	cp.w	r8,0
800091f8:	c0 b0       	breq	8000920e <xQueueGenericReceive+0xbe>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
800091fa:	ee f8 ff ec 	ld.w	r8,r7[-20]
800091fe:	2d c8       	sub	r8,-36
80009200:	10 9c       	mov	r12,r8
80009202:	f0 1f 00 45 	mcall	80009314 <xQueueGenericReceive+0x1c4>
80009206:	18 98       	mov	r8,r12
80009208:	58 08       	cp.w	r8,0
8000920a:	c0 20       	breq	8000920e <xQueueGenericReceive+0xbe>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
8000920c:	d7 33       	scall
						}
					}

				}

				taskEXIT_CRITICAL();
8000920e:	f0 1f 00 43 	mcall	80009318 <xQueueGenericReceive+0x1c8>
				return pdPASS;
80009212:	30 18       	mov	r8,1
80009214:	c7 58       	rjmp	800092fe <xQueueGenericReceive+0x1ae>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
80009216:	ee f8 ff e4 	ld.w	r8,r7[-28]
8000921a:	58 08       	cp.w	r8,0
8000921c:	c0 51       	brne	80009226 <xQueueGenericReceive+0xd6>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
8000921e:	f0 1f 00 3f 	mcall	80009318 <xQueueGenericReceive+0x1c8>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
80009222:	30 08       	mov	r8,0
80009224:	c6 d8       	rjmp	800092fe <xQueueGenericReceive+0x1ae>
				}
				else if( xEntryTimeSet == pdFALSE )
80009226:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000922a:	58 08       	cp.w	r8,0
8000922c:	c0 91       	brne	8000923e <xQueueGenericReceive+0xee>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
8000922e:	ee c8 00 10 	sub	r8,r7,16
80009232:	10 9c       	mov	r12,r8
80009234:	f0 1f 00 3a 	mcall	8000931c <xQueueGenericReceive+0x1cc>
					xEntryTimeSet = pdTRUE;
80009238:	30 18       	mov	r8,1
8000923a:	ef 48 ff f8 	st.w	r7[-8],r8
				}
			}
		}
		taskEXIT_CRITICAL();
8000923e:	f0 1f 00 37 	mcall	80009318 <xQueueGenericReceive+0x1c8>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80009242:	f0 1f 00 38 	mcall	80009320 <xQueueGenericReceive+0x1d0>
		prvLockQueue( pxQueue );
80009246:	f0 1f 00 31 	mcall	80009308 <xQueueGenericReceive+0x1b8>
8000924a:	ee f8 ff ec 	ld.w	r8,r7[-20]
8000924e:	71 18       	ld.w	r8,r8[0x44]
80009250:	5b f8       	cp.w	r8,-1
80009252:	c0 61       	brne	8000925e <xQueueGenericReceive+0x10e>
80009254:	ee f8 ff ec 	ld.w	r8,r7[-20]
80009258:	30 09       	mov	r9,0
8000925a:	f1 49 00 44 	st.w	r8[68],r9
8000925e:	ee f8 ff ec 	ld.w	r8,r7[-20]
80009262:	71 28       	ld.w	r8,r8[0x48]
80009264:	5b f8       	cp.w	r8,-1
80009266:	c0 61       	brne	80009272 <xQueueGenericReceive+0x122>
80009268:	ee f8 ff ec 	ld.w	r8,r7[-20]
8000926c:	30 09       	mov	r9,0
8000926e:	f1 49 00 48 	st.w	r8[72],r9
80009272:	f0 1f 00 2a 	mcall	80009318 <xQueueGenericReceive+0x1c8>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80009276:	ee c9 00 1c 	sub	r9,r7,28
8000927a:	ee c8 00 10 	sub	r8,r7,16
8000927e:	12 9b       	mov	r11,r9
80009280:	10 9c       	mov	r12,r8
80009282:	f0 1f 00 29 	mcall	80009324 <xQueueGenericReceive+0x1d4>
80009286:	18 98       	mov	r8,r12
80009288:	58 08       	cp.w	r8,0
8000928a:	c3 31       	brne	800092f0 <xQueueGenericReceive+0x1a0>
		{
			if( prvIsQueueEmpty( pxQueue ) )
8000928c:	ee fc ff ec 	ld.w	r12,r7[-20]
80009290:	f0 1f 00 26 	mcall	80009328 <xQueueGenericReceive+0x1d8>
80009294:	18 98       	mov	r8,r12
80009296:	58 08       	cp.w	r8,0
80009298:	c2 50       	breq	800092e2 <xQueueGenericReceive+0x192>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
8000929a:	ee f8 ff ec 	ld.w	r8,r7[-20]
8000929e:	70 08       	ld.w	r8,r8[0x0]
800092a0:	58 08       	cp.w	r8,0
800092a2:	c0 b1       	brne	800092b8 <xQueueGenericReceive+0x168>
					{
						portENTER_CRITICAL();
800092a4:	f0 1f 00 19 	mcall	80009308 <xQueueGenericReceive+0x1b8>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
800092a8:	ee f8 ff ec 	ld.w	r8,r7[-20]
800092ac:	70 18       	ld.w	r8,r8[0x4]
800092ae:	10 9c       	mov	r12,r8
800092b0:	f0 1f 00 1f 	mcall	8000932c <xQueueGenericReceive+0x1dc>
						}
						portEXIT_CRITICAL();
800092b4:	f0 1f 00 19 	mcall	80009318 <xQueueGenericReceive+0x1c8>
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
800092b8:	ee f9 ff e4 	ld.w	r9,r7[-28]
800092bc:	ee f8 ff ec 	ld.w	r8,r7[-20]
800092c0:	2d c8       	sub	r8,-36
800092c2:	12 9b       	mov	r11,r9
800092c4:	10 9c       	mov	r12,r8
800092c6:	f0 1f 00 1b 	mcall	80009330 <xQueueGenericReceive+0x1e0>
				prvUnlockQueue( pxQueue );
800092ca:	ee fc ff ec 	ld.w	r12,r7[-20]
800092ce:	f0 1f 00 1a 	mcall	80009334 <xQueueGenericReceive+0x1e4>
				if( !xTaskResumeAll() )
800092d2:	f0 1f 00 1a 	mcall	80009338 <xQueueGenericReceive+0x1e8>
800092d6:	18 98       	mov	r8,r12
800092d8:	58 08       	cp.w	r8,0
800092da:	fe 91 ff 4b 	brne	80009170 <xQueueGenericReceive+0x20>
				{
					portYIELD_WITHIN_API();
800092de:	d7 33       	scall
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
800092e0:	c4 9b       	rjmp	80009172 <xQueueGenericReceive+0x22>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
800092e2:	ee fc ff ec 	ld.w	r12,r7[-20]
800092e6:	f0 1f 00 14 	mcall	80009334 <xQueueGenericReceive+0x1e4>
				( void ) xTaskResumeAll();
800092ea:	f0 1f 00 14 	mcall	80009338 <xQueueGenericReceive+0x1e8>
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
800092ee:	c4 2b       	rjmp	80009172 <xQueueGenericReceive+0x22>
				( void ) xTaskResumeAll();
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
800092f0:	ee fc ff ec 	ld.w	r12,r7[-20]
800092f4:	f0 1f 00 10 	mcall	80009334 <xQueueGenericReceive+0x1e4>
			( void ) xTaskResumeAll();
800092f8:	f0 1f 00 10 	mcall	80009338 <xQueueGenericReceive+0x1e8>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
800092fc:	30 08       	mov	r8,0
		}
	}
}
800092fe:	10 9c       	mov	r12,r8
80009300:	2f 8d       	sub	sp,-32
80009302:	e3 cd 80 80 	ldm	sp++,r7,pc
80009306:	00 00       	add	r0,r0
80009308:	80 00       	ld.sh	r0,r0[0x0]
8000930a:	8a 10       	ld.sh	r0,r5[0x2]
8000930c:	80 00       	ld.sh	r0,r0[0x0]
8000930e:	94 e4       	ld.uh	r4,r10[0xc]
80009310:	80 00       	ld.sh	r0,r0[0x0]
80009312:	a2 bc       	st.b	r1[0x3],r12
80009314:	80 00       	ld.sh	r0,r0[0x0]
80009316:	9d ac       	st.w	lr[0x28],r12
80009318:	80 00       	ld.sh	r0,r0[0x0]
8000931a:	8a 2c       	ld.sh	r12,r5[0x4]
8000931c:	80 00       	ld.sh	r0,r0[0x0]
8000931e:	9e 7c       	ld.sh	r12,pc[0xe]
80009320:	80 00       	ld.sh	r0,r0[0x0]
80009322:	99 a8       	st.w	r12[0x28],r8
80009324:	80 00       	ld.sh	r0,r0[0x0]
80009326:	9e ac       	ld.uh	r12,pc[0x4]
80009328:	80 00       	ld.sh	r0,r0[0x0]
8000932a:	96 20       	ld.sh	r0,r11[0x4]
8000932c:	80 00       	ld.sh	r0,r0[0x0]
8000932e:	a2 dc       	st.b	r1[0x5],r12
80009330:	80 00       	ld.sh	r0,r0[0x0]
80009332:	9d 2c       	st.w	lr[0x8],r12
80009334:	80 00       	ld.sh	r0,r0[0x0]
80009336:	95 50       	st.w	r10[0x14],r0
80009338:	80 00       	ld.sh	r0,r0[0x0]
8000933a:	99 c4       	st.w	r12[0x30],r4

8000933c <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
8000933c:	eb cd 40 80 	pushm	r7,lr
80009340:	1a 97       	mov	r7,sp
80009342:	20 5d       	sub	sp,20
80009344:	ef 4c ff f4 	st.w	r7[-12],r12
80009348:	ef 4b ff f0 	st.w	r7[-16],r11
8000934c:	ef 4a ff ec 	st.w	r7[-20],r10

	configASSERT( pxQueue );
	configASSERT( pxTaskWoken );
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
80009350:	30 08       	mov	r8,0
80009352:	ef 48 ff fc 	st.w	r7[-4],r8
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80009356:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000935a:	70 e8       	ld.w	r8,r8[0x38]
8000935c:	58 08       	cp.w	r8,0
8000935e:	c3 40       	breq	800093c6 <xQueueReceiveFromISR+0x8a>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
80009360:	ee fb ff f0 	ld.w	r11,r7[-16]
80009364:	ee fc ff f4 	ld.w	r12,r7[-12]
80009368:	f0 1f 00 1c 	mcall	800093d8 <xQueueReceiveFromISR+0x9c>
			--( pxQueue->uxMessagesWaiting );
8000936c:	ee f8 ff f4 	ld.w	r8,r7[-12]
80009370:	70 e8       	ld.w	r8,r8[0x38]
80009372:	f0 c9 00 01 	sub	r9,r8,1
80009376:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000937a:	91 e9       	st.w	r8[0x38],r9

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
8000937c:	ee f8 ff f4 	ld.w	r8,r7[-12]
80009380:	71 18       	ld.w	r8,r8[0x44]
80009382:	5b f8       	cp.w	r8,-1
80009384:	c1 41       	brne	800093ac <xQueueReceiveFromISR+0x70>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80009386:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000938a:	70 48       	ld.w	r8,r8[0x10]
8000938c:	58 08       	cp.w	r8,0
8000938e:	c1 80       	breq	800093be <xQueueReceiveFromISR+0x82>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80009390:	ee f8 ff f4 	ld.w	r8,r7[-12]
80009394:	2f 08       	sub	r8,-16
80009396:	10 9c       	mov	r12,r8
80009398:	f0 1f 00 11 	mcall	800093dc <xQueueReceiveFromISR+0xa0>
8000939c:	18 98       	mov	r8,r12
8000939e:	58 08       	cp.w	r8,0
800093a0:	c0 f0       	breq	800093be <xQueueReceiveFromISR+0x82>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
800093a2:	ee f8 ff ec 	ld.w	r8,r7[-20]
800093a6:	30 19       	mov	r9,1
800093a8:	91 09       	st.w	r8[0x0],r9
800093aa:	c0 a8       	rjmp	800093be <xQueueReceiveFromISR+0x82>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
800093ac:	ee f8 ff f4 	ld.w	r8,r7[-12]
800093b0:	71 18       	ld.w	r8,r8[0x44]
800093b2:	f0 c9 ff ff 	sub	r9,r8,-1
800093b6:	ee f8 ff f4 	ld.w	r8,r7[-12]
800093ba:	f1 49 00 44 	st.w	r8[68],r9
			}

			xReturn = pdPASS;
800093be:	30 18       	mov	r8,1
800093c0:	ef 48 ff f8 	st.w	r7[-8],r8
800093c4:	c0 48       	rjmp	800093cc <xQueueReceiveFromISR+0x90>
		}
		else
		{
			xReturn = pdFAIL;
800093c6:	30 08       	mov	r8,0
800093c8:	ef 48 ff f8 	st.w	r7[-8],r8
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
800093cc:	ee f8 ff f8 	ld.w	r8,r7[-8]
}
800093d0:	10 9c       	mov	r12,r8
800093d2:	2f bd       	sub	sp,-20
800093d4:	e3 cd 80 80 	ldm	sp++,r7,pc
800093d8:	80 00       	ld.sh	r0,r0[0x0]
800093da:	94 e4       	ld.uh	r4,r10[0xc]
800093dc:	80 00       	ld.sh	r0,r0[0x0]
800093de:	9d ac       	st.w	lr[0x28],r12

800093e0 <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
800093e0:	eb cd 40 80 	pushm	r7,lr
800093e4:	1a 97       	mov	r7,sp
800093e6:	20 3d       	sub	sp,12
800093e8:	ef 4c ff fc 	st.w	r7[-4],r12
800093ec:	ef 4b ff f8 	st.w	r7[-8],r11
800093f0:	ef 4a ff f4 	st.w	r7[-12],r10
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
800093f4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800093f8:	71 08       	ld.w	r8,r8[0x40]
800093fa:	58 08       	cp.w	r8,0
800093fc:	c1 11       	brne	8000941e <prvCopyDataToQueue+0x3e>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
800093fe:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009402:	70 08       	ld.w	r8,r8[0x0]
80009404:	58 08       	cp.w	r8,0
80009406:	c5 f1       	brne	800094c4 <prvCopyDataToQueue+0xe4>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
80009408:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000940c:	70 18       	ld.w	r8,r8[0x4]
8000940e:	10 9c       	mov	r12,r8
80009410:	f0 1f 00 33 	mcall	800094dc <prvCopyDataToQueue+0xfc>
				pxQueue->pxMutexHolder = NULL;
80009414:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009418:	30 09       	mov	r9,0
8000941a:	91 19       	st.w	r8[0x4],r9
8000941c:	c5 48       	rjmp	800094c4 <prvCopyDataToQueue+0xe4>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
8000941e:	ee f8 ff f4 	ld.w	r8,r7[-12]
80009422:	58 08       	cp.w	r8,0
80009424:	c2 61       	brne	80009470 <prvCopyDataToQueue+0x90>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80009426:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000942a:	71 09       	ld.w	r9,r8[0x40]
8000942c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009430:	70 28       	ld.w	r8,r8[0x8]
80009432:	12 9a       	mov	r10,r9
80009434:	ee fb ff f8 	ld.w	r11,r7[-8]
80009438:	10 9c       	mov	r12,r8
8000943a:	f0 1f 00 2a 	mcall	800094e0 <prvCopyDataToQueue+0x100>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
8000943e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009442:	70 29       	ld.w	r9,r8[0x8]
80009444:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009448:	71 08       	ld.w	r8,r8[0x40]
8000944a:	10 09       	add	r9,r8
8000944c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009450:	91 29       	st.w	r8[0x8],r9
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
80009452:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009456:	70 29       	ld.w	r9,r8[0x8]
80009458:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000945c:	70 18       	ld.w	r8,r8[0x4]
8000945e:	10 39       	cp.w	r9,r8
80009460:	c3 23       	brcs	800094c4 <prvCopyDataToQueue+0xe4>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
80009462:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009466:	70 09       	ld.w	r9,r8[0x0]
80009468:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000946c:	91 29       	st.w	r8[0x8],r9
8000946e:	c2 b8       	rjmp	800094c4 <prvCopyDataToQueue+0xe4>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80009470:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009474:	71 09       	ld.w	r9,r8[0x40]
80009476:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000947a:	70 38       	ld.w	r8,r8[0xc]
8000947c:	12 9a       	mov	r10,r9
8000947e:	ee fb ff f8 	ld.w	r11,r7[-8]
80009482:	10 9c       	mov	r12,r8
80009484:	f0 1f 00 17 	mcall	800094e0 <prvCopyDataToQueue+0x100>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
80009488:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000948c:	70 39       	ld.w	r9,r8[0xc]
8000948e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009492:	71 08       	ld.w	r8,r8[0x40]
80009494:	5c 38       	neg	r8
80009496:	10 09       	add	r9,r8
80009498:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000949c:	91 39       	st.w	r8[0xc],r9
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
8000949e:	ee f8 ff fc 	ld.w	r8,r7[-4]
800094a2:	70 39       	ld.w	r9,r8[0xc]
800094a4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800094a8:	70 08       	ld.w	r8,r8[0x0]
800094aa:	10 39       	cp.w	r9,r8
800094ac:	c0 c2       	brcc	800094c4 <prvCopyDataToQueue+0xe4>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
800094ae:	ee f8 ff fc 	ld.w	r8,r7[-4]
800094b2:	70 19       	ld.w	r9,r8[0x4]
800094b4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800094b8:	71 08       	ld.w	r8,r8[0x40]
800094ba:	5c 38       	neg	r8
800094bc:	10 09       	add	r9,r8
800094be:	ee f8 ff fc 	ld.w	r8,r7[-4]
800094c2:	91 39       	st.w	r8[0xc],r9
		}
	}

	++( pxQueue->uxMessagesWaiting );
800094c4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800094c8:	70 e8       	ld.w	r8,r8[0x38]
800094ca:	f0 c9 ff ff 	sub	r9,r8,-1
800094ce:	ee f8 ff fc 	ld.w	r8,r7[-4]
800094d2:	91 e9       	st.w	r8[0x38],r9
}
800094d4:	2f dd       	sub	sp,-12
800094d6:	e3 cd 80 80 	ldm	sp++,r7,pc
800094da:	00 00       	add	r0,r0
800094dc:	80 00       	ld.sh	r0,r0[0x0]
800094de:	a3 b0       	sbr	r0,0x3
800094e0:	80 00       	ld.sh	r0,r0[0x0]
800094e2:	b5 62       	lsl	r2,0x14

800094e4 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
800094e4:	eb cd 40 80 	pushm	r7,lr
800094e8:	1a 97       	mov	r7,sp
800094ea:	20 2d       	sub	sp,8
800094ec:	ef 4c ff fc 	st.w	r7[-4],r12
800094f0:	ef 4b ff f8 	st.w	r7[-8],r11
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
800094f4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800094f8:	70 08       	ld.w	r8,r8[0x0]
800094fa:	58 08       	cp.w	r8,0
800094fc:	c2 50       	breq	80009546 <prvCopyDataFromQueue+0x62>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
800094fe:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009502:	70 39       	ld.w	r9,r8[0xc]
80009504:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009508:	71 08       	ld.w	r8,r8[0x40]
8000950a:	10 09       	add	r9,r8
8000950c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009510:	91 39       	st.w	r8[0xc],r9
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
80009512:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009516:	70 39       	ld.w	r9,r8[0xc]
80009518:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000951c:	70 18       	ld.w	r8,r8[0x4]
8000951e:	10 39       	cp.w	r9,r8
80009520:	c0 73       	brcs	8000952e <prvCopyDataFromQueue+0x4a>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
80009522:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009526:	70 09       	ld.w	r9,r8[0x0]
80009528:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000952c:	91 39       	st.w	r8[0xc],r9
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
8000952e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009532:	71 09       	ld.w	r9,r8[0x40]
80009534:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009538:	70 38       	ld.w	r8,r8[0xc]
8000953a:	12 9a       	mov	r10,r9
8000953c:	10 9b       	mov	r11,r8
8000953e:	ee fc ff f8 	ld.w	r12,r7[-8]
80009542:	f0 1f 00 03 	mcall	8000954c <prvCopyDataFromQueue+0x68>
	}
}
80009546:	2f ed       	sub	sp,-8
80009548:	e3 cd 80 80 	ldm	sp++,r7,pc
8000954c:	80 00       	ld.sh	r0,r0[0x0]
8000954e:	b5 62       	lsl	r2,0x14

80009550 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
80009550:	eb cd 40 80 	pushm	r7,lr
80009554:	1a 97       	mov	r7,sp
80009556:	20 1d       	sub	sp,4
80009558:	ef 4c ff fc 	st.w	r7[-4],r12

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
8000955c:	f0 1f 00 2d 	mcall	80009610 <prvUnlockQueue+0xc0>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80009560:	c1 a8       	rjmp	80009594 <prvUnlockQueue+0x44>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80009562:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009566:	70 98       	ld.w	r8,r8[0x24]
80009568:	58 08       	cp.w	r8,0
8000956a:	c1 c0       	breq	800095a2 <prvUnlockQueue+0x52>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
8000956c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009570:	2d c8       	sub	r8,-36
80009572:	10 9c       	mov	r12,r8
80009574:	f0 1f 00 28 	mcall	80009614 <prvUnlockQueue+0xc4>
80009578:	18 98       	mov	r8,r12
8000957a:	58 08       	cp.w	r8,0
8000957c:	c0 30       	breq	80009582 <prvUnlockQueue+0x32>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
8000957e:	f0 1f 00 27 	mcall	80009618 <prvUnlockQueue+0xc8>
				}

				--( pxQueue->xTxLock );
80009582:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009586:	71 28       	ld.w	r8,r8[0x48]
80009588:	f0 c9 00 01 	sub	r9,r8,1
8000958c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009590:	f1 49 00 48 	st.w	r8[72],r9
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80009594:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009598:	71 28       	ld.w	r8,r8[0x48]
8000959a:	58 08       	cp.w	r8,0
8000959c:	fe 99 ff e3 	brgt	80009562 <prvUnlockQueue+0x12>
800095a0:	c0 28       	rjmp	800095a4 <prvUnlockQueue+0x54>

				--( pxQueue->xTxLock );
			}
			else
			{
				break;
800095a2:	d7 03       	nop
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
800095a4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800095a8:	3f f9       	mov	r9,-1
800095aa:	f1 49 00 48 	st.w	r8[72],r9
	}
	taskEXIT_CRITICAL();
800095ae:	f0 1f 00 1c 	mcall	8000961c <prvUnlockQueue+0xcc>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
800095b2:	f0 1f 00 18 	mcall	80009610 <prvUnlockQueue+0xc0>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
800095b6:	c1 a8       	rjmp	800095ea <prvUnlockQueue+0x9a>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
800095b8:	ee f8 ff fc 	ld.w	r8,r7[-4]
800095bc:	70 48       	ld.w	r8,r8[0x10]
800095be:	58 08       	cp.w	r8,0
800095c0:	c1 c0       	breq	800095f8 <prvUnlockQueue+0xa8>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
800095c2:	ee f8 ff fc 	ld.w	r8,r7[-4]
800095c6:	2f 08       	sub	r8,-16
800095c8:	10 9c       	mov	r12,r8
800095ca:	f0 1f 00 13 	mcall	80009614 <prvUnlockQueue+0xc4>
800095ce:	18 98       	mov	r8,r12
800095d0:	58 08       	cp.w	r8,0
800095d2:	c0 30       	breq	800095d8 <prvUnlockQueue+0x88>
				{
					vTaskMissedYield();
800095d4:	f0 1f 00 11 	mcall	80009618 <prvUnlockQueue+0xc8>
				}

				--( pxQueue->xRxLock );
800095d8:	ee f8 ff fc 	ld.w	r8,r7[-4]
800095dc:	71 18       	ld.w	r8,r8[0x44]
800095de:	f0 c9 00 01 	sub	r9,r8,1
800095e2:	ee f8 ff fc 	ld.w	r8,r7[-4]
800095e6:	f1 49 00 44 	st.w	r8[68],r9
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
800095ea:	ee f8 ff fc 	ld.w	r8,r7[-4]
800095ee:	71 18       	ld.w	r8,r8[0x44]
800095f0:	58 08       	cp.w	r8,0
800095f2:	fe 99 ff e3 	brgt	800095b8 <prvUnlockQueue+0x68>
800095f6:	c0 28       	rjmp	800095fa <prvUnlockQueue+0xaa>

				--( pxQueue->xRxLock );
			}
			else
			{
				break;
800095f8:	d7 03       	nop
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
800095fa:	ee f8 ff fc 	ld.w	r8,r7[-4]
800095fe:	3f f9       	mov	r9,-1
80009600:	f1 49 00 44 	st.w	r8[68],r9
	}
	taskEXIT_CRITICAL();
80009604:	f0 1f 00 06 	mcall	8000961c <prvUnlockQueue+0xcc>
}
80009608:	2f fd       	sub	sp,-4
8000960a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000960e:	00 00       	add	r0,r0
80009610:	80 00       	ld.sh	r0,r0[0x0]
80009612:	8a 10       	ld.sh	r0,r5[0x2]
80009614:	80 00       	ld.sh	r0,r0[0x0]
80009616:	9d ac       	st.w	lr[0x28],r12
80009618:	80 00       	ld.sh	r0,r0[0x0]
8000961a:	9f 64       	st.w	pc[0x18],r4
8000961c:	80 00       	ld.sh	r0,r0[0x0]
8000961e:	8a 2c       	ld.sh	r12,r5[0x4]

80009620 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
80009620:	eb cd 40 80 	pushm	r7,lr
80009624:	1a 97       	mov	r7,sp
80009626:	20 2d       	sub	sp,8
80009628:	ef 4c ff f8 	st.w	r7[-8],r12
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
8000962c:	f0 1f 00 09 	mcall	80009650 <prvIsQueueEmpty+0x30>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
80009630:	ee f8 ff f8 	ld.w	r8,r7[-8]
80009634:	70 e8       	ld.w	r8,r8[0x38]
80009636:	58 08       	cp.w	r8,0
80009638:	5f 08       	sreq	r8
8000963a:	ef 48 ff fc 	st.w	r7[-4],r8
	taskEXIT_CRITICAL();
8000963e:	f0 1f 00 06 	mcall	80009654 <prvIsQueueEmpty+0x34>

	return xReturn;
80009642:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
80009646:	10 9c       	mov	r12,r8
80009648:	2f ed       	sub	sp,-8
8000964a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000964e:	00 00       	add	r0,r0
80009650:	80 00       	ld.sh	r0,r0[0x0]
80009652:	8a 10       	ld.sh	r0,r5[0x2]
80009654:	80 00       	ld.sh	r0,r0[0x0]
80009656:	8a 2c       	ld.sh	r12,r5[0x4]

80009658 <prvIsQueueFull>:
	return xReturn;
}
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
80009658:	eb cd 40 80 	pushm	r7,lr
8000965c:	1a 97       	mov	r7,sp
8000965e:	20 2d       	sub	sp,8
80009660:	ef 4c ff f8 	st.w	r7[-8],r12
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80009664:	f0 1f 00 0a 	mcall	8000968c <prvIsQueueFull+0x34>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
80009668:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000966c:	70 e9       	ld.w	r9,r8[0x38]
8000966e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80009672:	70 f8       	ld.w	r8,r8[0x3c]
80009674:	10 39       	cp.w	r9,r8
80009676:	5f 08       	sreq	r8
80009678:	ef 48 ff fc 	st.w	r7[-4],r8
	taskEXIT_CRITICAL();
8000967c:	f0 1f 00 05 	mcall	80009690 <prvIsQueueFull+0x38>

	return xReturn;
80009680:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
80009684:	10 9c       	mov	r12,r8
80009686:	2f ed       	sub	sp,-8
80009688:	e3 cd 80 80 	ldm	sp++,r7,pc
8000968c:	80 00       	ld.sh	r0,r0[0x0]
8000968e:	8a 10       	ld.sh	r0,r5[0x2]
80009690:	80 00       	ld.sh	r0,r0[0x0]
80009692:	8a 2c       	ld.sh	r12,r5[0x4]
80009694:	49 44       	lddpc	r4,800096e4 <xTaskGenericCreate+0x48>
80009696:	4c 45       	lddpc	r5,800097a4 <xTaskGenericCreate+0x108>
80009698:	00 00       	add	r0,r0
	...

8000969c <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
8000969c:	eb cd 40 c0 	pushm	r6-r7,lr
800096a0:	1a 97       	mov	r7,sp
800096a2:	20 8d       	sub	sp,32
800096a4:	ee c6 ff f4 	sub	r6,r7,-12
800096a8:	ef 4c ff f0 	st.w	r7[-16],r12
800096ac:	ef 4b ff ec 	st.w	r7[-20],r11
800096b0:	ef 49 ff e4 	st.w	r7[-28],r9
800096b4:	ef 48 ff e0 	st.w	r7[-32],r8
800096b8:	14 98       	mov	r8,r10
800096ba:	ef 58 ff e8 	st.h	r7[-24],r8
	configASSERT( pxTaskCode );
	configASSERT( ( uxPriority < configMAX_PRIORITIES ) );

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
800096be:	ef 18 ff e8 	ld.uh	r8,r7[-24]
800096c2:	6c 1b       	ld.w	r11,r6[0x4]
800096c4:	10 9c       	mov	r12,r8
800096c6:	f0 1f 00 5a 	mcall	8000982c <xTaskGenericCreate+0x190>
800096ca:	18 98       	mov	r8,r12
800096cc:	ef 48 ff f8 	st.w	r7[-8],r8

	if( pxNewTCB != NULL )
800096d0:	ee f8 ff f8 	ld.w	r8,r7[-8]
800096d4:	58 08       	cp.w	r8,0
800096d6:	e0 80 00 92 	breq	800097fa <xTaskGenericCreate+0x15e>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
800096da:	ee f8 ff f8 	ld.w	r8,r7[-8]
800096de:	70 c9       	ld.w	r9,r8[0x30]
800096e0:	ef 18 ff e8 	ld.uh	r8,r7[-24]
800096e4:	20 18       	sub	r8,1
800096e6:	a3 68       	lsl	r8,0x2
800096e8:	f2 08 00 08 	add	r8,r9,r8
800096ec:	ef 48 ff fc 	st.w	r7[-4],r8
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
800096f0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800096f4:	e0 18 ff fc 	andl	r8,0xfffc
800096f8:	ef 48 ff fc 	st.w	r7[-4],r8
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
800096fc:	ef 18 ff e8 	ld.uh	r8,r7[-24]
80009700:	6c 29       	ld.w	r9,r6[0x8]
80009702:	ee fa ff e0 	ld.w	r10,r7[-32]
80009706:	ee fb ff ec 	ld.w	r11,r7[-20]
8000970a:	ee fc ff f8 	ld.w	r12,r7[-8]
8000970e:	f0 1f 00 49 	mcall	80009830 <xTaskGenericCreate+0x194>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
80009712:	ee fa ff e4 	ld.w	r10,r7[-28]
80009716:	ee fb ff f0 	ld.w	r11,r7[-16]
8000971a:	ee fc ff fc 	ld.w	r12,r7[-4]
8000971e:	f0 1f 00 46 	mcall	80009834 <xTaskGenericCreate+0x198>
80009722:	18 98       	mov	r8,r12
80009724:	10 99       	mov	r9,r8
80009726:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000972a:	91 09       	st.w	r8[0x0],r9
		#endif

		/* Check the alignment of the initialised stack. */
		configASSERT( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
8000972c:	6c 08       	ld.w	r8,r6[0x0]
8000972e:	58 08       	cp.w	r8,0
80009730:	c0 50       	breq	8000973a <xTaskGenericCreate+0x9e>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
80009732:	6c 08       	ld.w	r8,r6[0x0]
80009734:	ee f9 ff f8 	ld.w	r9,r7[-8]
80009738:	91 09       	st.w	r8[0x0],r9
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
8000973a:	f0 1f 00 40 	mcall	80009838 <xTaskGenericCreate+0x19c>
		{
			uxCurrentNumberOfTasks++;
8000973e:	4c 08       	lddpc	r8,8000983c <xTaskGenericCreate+0x1a0>
80009740:	70 08       	ld.w	r8,r8[0x0]
80009742:	f0 c9 ff ff 	sub	r9,r8,-1
80009746:	4b e8       	lddpc	r8,8000983c <xTaskGenericCreate+0x1a0>
80009748:	91 09       	st.w	r8[0x0],r9
			if( pxCurrentTCB == NULL )
8000974a:	4b e8       	lddpc	r8,80009840 <xTaskGenericCreate+0x1a4>
8000974c:	70 08       	ld.w	r8,r8[0x0]
8000974e:	58 08       	cp.w	r8,0
80009750:	c0 c1       	brne	80009768 <xTaskGenericCreate+0xcc>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
80009752:	4b c8       	lddpc	r8,80009840 <xTaskGenericCreate+0x1a4>
80009754:	ee f9 ff f8 	ld.w	r9,r7[-8]
80009758:	91 09       	st.w	r8[0x0],r9

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
8000975a:	4b 98       	lddpc	r8,8000983c <xTaskGenericCreate+0x1a0>
8000975c:	70 08       	ld.w	r8,r8[0x0]
8000975e:	58 18       	cp.w	r8,1
80009760:	c1 41       	brne	80009788 <xTaskGenericCreate+0xec>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
80009762:	f0 1f 00 39 	mcall	80009844 <xTaskGenericCreate+0x1a8>
80009766:	c1 18       	rjmp	80009788 <xTaskGenericCreate+0xec>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
80009768:	4b 88       	lddpc	r8,80009848 <xTaskGenericCreate+0x1ac>
8000976a:	70 08       	ld.w	r8,r8[0x0]
8000976c:	58 08       	cp.w	r8,0
8000976e:	c0 d1       	brne	80009788 <xTaskGenericCreate+0xec>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
80009770:	4b 48       	lddpc	r8,80009840 <xTaskGenericCreate+0x1a4>
80009772:	70 08       	ld.w	r8,r8[0x0]
80009774:	70 b9       	ld.w	r9,r8[0x2c]
80009776:	ee f8 ff e0 	ld.w	r8,r7[-32]
8000977a:	10 39       	cp.w	r9,r8
8000977c:	e0 8b 00 06 	brhi	80009788 <xTaskGenericCreate+0xec>
					{
						pxCurrentTCB = pxNewTCB;
80009780:	4b 08       	lddpc	r8,80009840 <xTaskGenericCreate+0x1a4>
80009782:	ee f9 ff f8 	ld.w	r9,r7[-8]
80009786:	91 09       	st.w	r8[0x0],r9
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
80009788:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000978c:	70 b9       	ld.w	r9,r8[0x2c]
8000978e:	4b 08       	lddpc	r8,8000984c <xTaskGenericCreate+0x1b0>
80009790:	70 08       	ld.w	r8,r8[0x0]
80009792:	10 39       	cp.w	r9,r8
80009794:	e0 88 00 07 	brls	800097a2 <xTaskGenericCreate+0x106>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
80009798:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000979c:	70 b9       	ld.w	r9,r8[0x2c]
8000979e:	4a c8       	lddpc	r8,8000984c <xTaskGenericCreate+0x1b0>
800097a0:	91 09       	st.w	r8[0x0],r9
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
800097a2:	4a c8       	lddpc	r8,80009850 <xTaskGenericCreate+0x1b4>
800097a4:	70 08       	ld.w	r8,r8[0x0]
800097a6:	f0 c9 ff ff 	sub	r9,r8,-1
800097aa:	4a a8       	lddpc	r8,80009850 <xTaskGenericCreate+0x1b4>
800097ac:	91 09       	st.w	r8[0x0],r9

			prvAddTaskToReadyQueue( pxNewTCB );
800097ae:	ee f8 ff f8 	ld.w	r8,r7[-8]
800097b2:	70 b9       	ld.w	r9,r8[0x2c]
800097b4:	4a 88       	lddpc	r8,80009854 <xTaskGenericCreate+0x1b8>
800097b6:	70 08       	ld.w	r8,r8[0x0]
800097b8:	10 39       	cp.w	r9,r8
800097ba:	e0 88 00 07 	brls	800097c8 <xTaskGenericCreate+0x12c>
800097be:	ee f8 ff f8 	ld.w	r8,r7[-8]
800097c2:	70 b9       	ld.w	r9,r8[0x2c]
800097c4:	4a 48       	lddpc	r8,80009854 <xTaskGenericCreate+0x1b8>
800097c6:	91 09       	st.w	r8[0x0],r9
800097c8:	ee f8 ff f8 	ld.w	r8,r7[-8]
800097cc:	f0 ca ff fc 	sub	r10,r8,-4
800097d0:	ee f8 ff f8 	ld.w	r8,r7[-8]
800097d4:	70 b9       	ld.w	r9,r8[0x2c]
800097d6:	12 98       	mov	r8,r9
800097d8:	a3 68       	lsl	r8,0x2
800097da:	12 08       	add	r8,r9
800097dc:	a3 68       	lsl	r8,0x2
800097de:	10 99       	mov	r9,r8
800097e0:	49 e8       	lddpc	r8,80009858 <xTaskGenericCreate+0x1bc>
800097e2:	f2 08 00 08 	add	r8,r9,r8
800097e6:	14 9b       	mov	r11,r10
800097e8:	10 9c       	mov	r12,r8
800097ea:	f0 1f 00 1d 	mcall	8000985c <xTaskGenericCreate+0x1c0>

			xReturn = pdPASS;
800097ee:	30 18       	mov	r8,1
800097f0:	ef 48 ff f4 	st.w	r7[-12],r8
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
800097f4:	f0 1f 00 1b 	mcall	80009860 <xTaskGenericCreate+0x1c4>
800097f8:	c0 48       	rjmp	80009800 <xTaskGenericCreate+0x164>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
800097fa:	3f f8       	mov	r8,-1
800097fc:	ef 48 ff f4 	st.w	r7[-12],r8
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
80009800:	ee f8 ff f4 	ld.w	r8,r7[-12]
80009804:	58 18       	cp.w	r8,1
80009806:	c0 d1       	brne	80009820 <xTaskGenericCreate+0x184>
	{
		if( xSchedulerRunning != pdFALSE )
80009808:	49 08       	lddpc	r8,80009848 <xTaskGenericCreate+0x1ac>
8000980a:	70 08       	ld.w	r8,r8[0x0]
8000980c:	58 08       	cp.w	r8,0
8000980e:	c0 90       	breq	80009820 <xTaskGenericCreate+0x184>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
80009810:	48 c8       	lddpc	r8,80009840 <xTaskGenericCreate+0x1a4>
80009812:	70 08       	ld.w	r8,r8[0x0]
80009814:	70 b9       	ld.w	r9,r8[0x2c]
80009816:	ee f8 ff e0 	ld.w	r8,r7[-32]
8000981a:	10 39       	cp.w	r9,r8
8000981c:	c0 22       	brcc	80009820 <xTaskGenericCreate+0x184>
			{
				portYIELD_WITHIN_API();
8000981e:	d7 33       	scall
			}
		}
	}

	return xReturn;
80009820:	ee f8 ff f4 	ld.w	r8,r7[-12]
}
80009824:	10 9c       	mov	r12,r8
80009826:	2f 8d       	sub	sp,-32
80009828:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000982c:	80 00       	ld.sh	r0,r0[0x0]
8000982e:	a1 fc       	*unknown*
80009830:	80 00       	ld.sh	r0,r0[0x0]
80009832:	9f a8       	st.w	pc[0x28],r8
80009834:	80 00       	ld.sh	r0,r0[0x0]
80009836:	8a 58       	ld.sh	r8,r5[0xa]
80009838:	80 00       	ld.sh	r0,r0[0x0]
8000983a:	8a 10       	ld.sh	r0,r5[0x2]
8000983c:	00 00       	add	r0,r0
8000983e:	0d 3c       	ld.ub	r12,r6++
80009840:	00 00       	add	r0,r0
80009842:	0c 28       	rsub	r8,r6
80009844:	80 00       	ld.sh	r0,r0[0x0]
80009846:	a0 50       	st.h	r0[0xa],r0
80009848:	00 00       	add	r0,r0
8000984a:	0d 4c       	ld.w	r12,--r6
8000984c:	00 00       	add	r0,r0
8000984e:	0d 44       	ld.w	r4,--r6
80009850:	00 00       	add	r0,r0
80009852:	0d 60       	ld.uh	r0,--r6
80009854:	00 00       	add	r0,r0
80009856:	0d 48       	ld.w	r8,--r6
80009858:	00 00       	add	r0,r0
8000985a:	0c 2c       	rsub	r12,r6
8000985c:	80 00       	ld.sh	r0,r0[0x0]
8000985e:	87 3e       	st.w	r3[0xc],lr
80009860:	80 00       	ld.sh	r0,r0[0x0]
80009862:	8a 2c       	ld.sh	r12,r5[0x4]

80009864 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
80009864:	eb cd 40 80 	pushm	r7,lr
80009868:	1a 97       	mov	r7,sp
8000986a:	20 5d       	sub	sp,20
8000986c:	ef 4c ff f0 	st.w	r7[-16],r12
80009870:	ef 4b ff ec 	st.w	r7[-20],r11
	portTickType xTimeToWake;
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
80009874:	30 08       	mov	r8,0
80009876:	ef 48 ff fc 	st.w	r7[-4],r8

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0 ) );

		vTaskSuspendAll();
8000987a:	f0 1f 00 2d 	mcall	8000992c <vTaskDelayUntil+0xc8>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
8000987e:	ee f8 ff f0 	ld.w	r8,r7[-16]
80009882:	70 09       	ld.w	r9,r8[0x0]
80009884:	ee f8 ff ec 	ld.w	r8,r7[-20]
80009888:	f2 08 00 08 	add	r8,r9,r8
8000988c:	ef 48 ff f4 	st.w	r7[-12],r8

			if( xTickCount < *pxPreviousWakeTime )
80009890:	ee f8 ff f0 	ld.w	r8,r7[-16]
80009894:	70 09       	ld.w	r9,r8[0x0]
80009896:	4a 78       	lddpc	r8,80009930 <vTaskDelayUntil+0xcc>
80009898:	70 08       	ld.w	r8,r8[0x0]
8000989a:	10 39       	cp.w	r9,r8
8000989c:	e0 88 00 15 	brls	800098c6 <vTaskDelayUntil+0x62>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
800098a0:	ee f8 ff f0 	ld.w	r8,r7[-16]
800098a4:	70 09       	ld.w	r9,r8[0x0]
800098a6:	ee f8 ff f4 	ld.w	r8,r7[-12]
800098aa:	10 39       	cp.w	r9,r8
800098ac:	e0 88 00 1f 	brls	800098ea <vTaskDelayUntil+0x86>
800098b0:	4a 08       	lddpc	r8,80009930 <vTaskDelayUntil+0xcc>
800098b2:	70 08       	ld.w	r8,r8[0x0]
800098b4:	ee f9 ff f4 	ld.w	r9,r7[-12]
800098b8:	10 39       	cp.w	r9,r8
800098ba:	e0 88 00 18 	brls	800098ea <vTaskDelayUntil+0x86>
				{
					xShouldDelay = pdTRUE;
800098be:	30 18       	mov	r8,1
800098c0:	ef 48 ff fc 	st.w	r7[-4],r8
800098c4:	c1 38       	rjmp	800098ea <vTaskDelayUntil+0x86>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
800098c6:	ee f8 ff f0 	ld.w	r8,r7[-16]
800098ca:	70 09       	ld.w	r9,r8[0x0]
800098cc:	ee f8 ff f4 	ld.w	r8,r7[-12]
800098d0:	10 39       	cp.w	r9,r8
800098d2:	e0 8b 00 09 	brhi	800098e4 <vTaskDelayUntil+0x80>
800098d6:	49 78       	lddpc	r8,80009930 <vTaskDelayUntil+0xcc>
800098d8:	70 08       	ld.w	r8,r8[0x0]
800098da:	ee f9 ff f4 	ld.w	r9,r7[-12]
800098de:	10 39       	cp.w	r9,r8
800098e0:	e0 88 00 05 	brls	800098ea <vTaskDelayUntil+0x86>
				{
					xShouldDelay = pdTRUE;
800098e4:	30 18       	mov	r8,1
800098e6:	ef 48 ff fc 	st.w	r7[-4],r8
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
800098ea:	ee f8 ff f0 	ld.w	r8,r7[-16]
800098ee:	ee f9 ff f4 	ld.w	r9,r7[-12]
800098f2:	91 09       	st.w	r8[0x0],r9

			if( xShouldDelay != pdFALSE )
800098f4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800098f8:	58 08       	cp.w	r8,0
800098fa:	c0 b0       	breq	80009910 <vTaskDelayUntil+0xac>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800098fc:	48 e8       	lddpc	r8,80009934 <vTaskDelayUntil+0xd0>
800098fe:	70 08       	ld.w	r8,r8[0x0]
80009900:	2f c8       	sub	r8,-4
80009902:	10 9c       	mov	r12,r8
80009904:	f0 1f 00 0d 	mcall	80009938 <vTaskDelayUntil+0xd4>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
80009908:	ee fc ff f4 	ld.w	r12,r7[-12]
8000990c:	f0 1f 00 0c 	mcall	8000993c <vTaskDelayUntil+0xd8>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
80009910:	f0 1f 00 0c 	mcall	80009940 <vTaskDelayUntil+0xdc>
80009914:	18 98       	mov	r8,r12
80009916:	ef 48 ff f8 	st.w	r7[-8],r8

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
8000991a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000991e:	58 08       	cp.w	r8,0
80009920:	c0 21       	brne	80009924 <vTaskDelayUntil+0xc0>
		{
			portYIELD_WITHIN_API();
80009922:	d7 33       	scall
		}
	}
80009924:	2f bd       	sub	sp,-20
80009926:	e3 cd 80 80 	ldm	sp++,r7,pc
8000992a:	00 00       	add	r0,r0
8000992c:	80 00       	ld.sh	r0,r0[0x0]
8000992e:	99 a8       	st.w	r12[0x28],r8
80009930:	00 00       	add	r0,r0
80009932:	0d 40       	ld.w	r0,--r6
80009934:	00 00       	add	r0,r0
80009936:	0c 28       	rsub	r8,r6
80009938:	80 00       	ld.sh	r0,r0[0x0]
8000993a:	88 52       	ld.sh	r2,r4[0xa]
8000993c:	80 00       	ld.sh	r0,r0[0x0]
8000993e:	a1 7c       	lsl	r12,0x1
80009940:	80 00       	ld.sh	r0,r0[0x0]
80009942:	99 c4       	st.w	r12[0x30],r4

80009944 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
80009944:	eb cd 40 80 	pushm	r7,lr
80009948:	1a 97       	mov	r7,sp
8000994a:	20 1d       	sub	sp,4
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
8000994c:	49 1b       	lddpc	r11,80009990 <vTaskStartScheduler+0x4c>
8000994e:	30 08       	mov	r8,0
80009950:	1a d8       	st.w	--sp,r8
80009952:	30 08       	mov	r8,0
80009954:	1a d8       	st.w	--sp,r8
80009956:	30 08       	mov	r8,0
80009958:	1a d8       	st.w	--sp,r8
8000995a:	30 08       	mov	r8,0
8000995c:	30 09       	mov	r9,0
8000995e:	e0 6a 01 00 	mov	r10,256
80009962:	48 dc       	lddpc	r12,80009994 <vTaskStartScheduler+0x50>
80009964:	f0 1f 00 0d 	mcall	80009998 <vTaskStartScheduler+0x54>
80009968:	2f dd       	sub	sp,-12
8000996a:	18 98       	mov	r8,r12
8000996c:	ef 48 ff fc 	st.w	r7[-4],r8
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
80009970:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009974:	58 18       	cp.w	r8,1
80009976:	c0 a1       	brne	8000998a <vTaskStartScheduler+0x46>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
80009978:	d3 03       	ssrf	0x10

		xSchedulerRunning = pdTRUE;
8000997a:	48 98       	lddpc	r8,8000999c <vTaskStartScheduler+0x58>
8000997c:	30 19       	mov	r9,1
8000997e:	91 09       	st.w	r8[0x0],r9
		xTickCount = ( portTickType ) 0;
80009980:	48 88       	lddpc	r8,800099a0 <vTaskStartScheduler+0x5c>
80009982:	30 09       	mov	r9,0
80009984:	91 09       	st.w	r8[0x0],r9
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
80009986:	f0 1f 00 08 	mcall	800099a4 <vTaskStartScheduler+0x60>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
8000998a:	2f fd       	sub	sp,-4
8000998c:	e3 cd 80 80 	ldm	sp++,r7,pc
80009990:	80 00       	ld.sh	r0,r0[0x0]
80009992:	96 94       	ld.uh	r4,r11[0x2]
80009994:	80 00       	ld.sh	r0,r0[0x0]
80009996:	9f 78       	st.w	pc[0x1c],r8
80009998:	80 00       	ld.sh	r0,r0[0x0]
8000999a:	96 9c       	ld.uh	r12,r11[0x2]
8000999c:	00 00       	add	r0,r0
8000999e:	0d 4c       	ld.w	r12,--r6
800099a0:	00 00       	add	r0,r0
800099a2:	0d 40       	ld.w	r0,--r6
800099a4:	80 00       	ld.sh	r0,r0[0x0]
800099a6:	8c 00       	ld.sh	r0,r6[0x0]

800099a8 <vTaskSuspendAll>:
	vPortEndScheduler();
}
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
800099a8:	eb cd 40 80 	pushm	r7,lr
800099ac:	1a 97       	mov	r7,sp
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
800099ae:	48 58       	lddpc	r8,800099c0 <vTaskSuspendAll+0x18>
800099b0:	70 08       	ld.w	r8,r8[0x0]
800099b2:	f0 c9 ff ff 	sub	r9,r8,-1
800099b6:	48 38       	lddpc	r8,800099c0 <vTaskSuspendAll+0x18>
800099b8:	91 09       	st.w	r8[0x0],r9
}
800099ba:	e3 cd 80 80 	ldm	sp++,r7,pc
800099be:	00 00       	add	r0,r0
800099c0:	00 00       	add	r0,r0
800099c2:	0d 50       	ld.sh	r0,--r6

800099c4 <xTaskResumeAll>:
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
800099c4:	eb cd 40 c0 	pushm	r6-r7,lr
800099c8:	1a 97       	mov	r7,sp
800099ca:	20 2d       	sub	sp,8
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
800099cc:	30 08       	mov	r8,0
800099ce:	ef 48 ff f8 	st.w	r7[-8],r8
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
800099d2:	f0 1f 00 3a 	mcall	80009ab8 <xTaskResumeAll+0xf4>
	{
		--uxSchedulerSuspended;
800099d6:	4b a8       	lddpc	r8,80009abc <xTaskResumeAll+0xf8>
800099d8:	70 08       	ld.w	r8,r8[0x0]
800099da:	f0 c9 00 01 	sub	r9,r8,1
800099de:	4b 88       	lddpc	r8,80009abc <xTaskResumeAll+0xf8>
800099e0:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
800099e2:	4b 78       	lddpc	r8,80009abc <xTaskResumeAll+0xf8>
800099e4:	70 08       	ld.w	r8,r8[0x0]
800099e6:	58 08       	cp.w	r8,0
800099e8:	c5 f1       	brne	80009aa6 <xTaskResumeAll+0xe2>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
800099ea:	4b 68       	lddpc	r8,80009ac0 <xTaskResumeAll+0xfc>
800099ec:	70 08       	ld.w	r8,r8[0x0]
800099ee:	58 08       	cp.w	r8,0
800099f0:	c5 b0       	breq	80009aa6 <xTaskResumeAll+0xe2>
			{
				portBASE_TYPE xYieldRequired = pdFALSE;
800099f2:	30 08       	mov	r8,0
800099f4:	ef 48 ff fc 	st.w	r7[-4],r8

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
800099f8:	c3 08       	rjmp	80009a58 <xTaskResumeAll+0x94>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
800099fa:	4b 38       	lddpc	r8,80009ac4 <xTaskResumeAll+0x100>
800099fc:	70 38       	ld.w	r8,r8[0xc]
800099fe:	70 38       	ld.w	r8,r8[0xc]
80009a00:	10 96       	mov	r6,r8
					vListRemove( &( pxTCB->xEventListItem ) );
80009a02:	ec c8 ff e8 	sub	r8,r6,-24
80009a06:	10 9c       	mov	r12,r8
80009a08:	f0 1f 00 30 	mcall	80009ac8 <xTaskResumeAll+0x104>
					vListRemove( &( pxTCB->xGenericListItem ) );
80009a0c:	ec c8 ff fc 	sub	r8,r6,-4
80009a10:	10 9c       	mov	r12,r8
80009a12:	f0 1f 00 2e 	mcall	80009ac8 <xTaskResumeAll+0x104>
					prvAddTaskToReadyQueue( pxTCB );
80009a16:	6c b9       	ld.w	r9,r6[0x2c]
80009a18:	4a d8       	lddpc	r8,80009acc <xTaskResumeAll+0x108>
80009a1a:	70 08       	ld.w	r8,r8[0x0]
80009a1c:	10 39       	cp.w	r9,r8
80009a1e:	e0 88 00 05 	brls	80009a28 <xTaskResumeAll+0x64>
80009a22:	6c b9       	ld.w	r9,r6[0x2c]
80009a24:	4a a8       	lddpc	r8,80009acc <xTaskResumeAll+0x108>
80009a26:	91 09       	st.w	r8[0x0],r9
80009a28:	ec ca ff fc 	sub	r10,r6,-4
80009a2c:	6c b9       	ld.w	r9,r6[0x2c]
80009a2e:	12 98       	mov	r8,r9
80009a30:	a3 68       	lsl	r8,0x2
80009a32:	12 08       	add	r8,r9
80009a34:	a3 68       	lsl	r8,0x2
80009a36:	10 99       	mov	r9,r8
80009a38:	4a 68       	lddpc	r8,80009ad0 <xTaskResumeAll+0x10c>
80009a3a:	f2 08 00 08 	add	r8,r9,r8
80009a3e:	14 9b       	mov	r11,r10
80009a40:	10 9c       	mov	r12,r8
80009a42:	f0 1f 00 25 	mcall	80009ad4 <xTaskResumeAll+0x110>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80009a46:	6c b9       	ld.w	r9,r6[0x2c]
80009a48:	4a 48       	lddpc	r8,80009ad8 <xTaskResumeAll+0x114>
80009a4a:	70 08       	ld.w	r8,r8[0x0]
80009a4c:	70 b8       	ld.w	r8,r8[0x2c]
80009a4e:	10 39       	cp.w	r9,r8
80009a50:	c0 43       	brcs	80009a58 <xTaskResumeAll+0x94>
					{
						xYieldRequired = pdTRUE;
80009a52:	30 18       	mov	r8,1
80009a54:	ef 48 ff fc 	st.w	r7[-4],r8
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80009a58:	49 b8       	lddpc	r8,80009ac4 <xTaskResumeAll+0x100>
80009a5a:	70 08       	ld.w	r8,r8[0x0]
80009a5c:	58 08       	cp.w	r8,0
80009a5e:	cc e1       	brne	800099fa <xTaskResumeAll+0x36>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80009a60:	49 f8       	lddpc	r8,80009adc <xTaskResumeAll+0x118>
80009a62:	70 08       	ld.w	r8,r8[0x0]
80009a64:	58 08       	cp.w	r8,0
80009a66:	c1 10       	breq	80009a88 <xTaskResumeAll+0xc4>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80009a68:	c0 98       	rjmp	80009a7a <xTaskResumeAll+0xb6>
					{
						vTaskIncrementTick();
80009a6a:	f0 1f 00 1e 	mcall	80009ae0 <xTaskResumeAll+0x11c>
						--uxMissedTicks;
80009a6e:	49 c8       	lddpc	r8,80009adc <xTaskResumeAll+0x118>
80009a70:	70 08       	ld.w	r8,r8[0x0]
80009a72:	f0 c9 00 01 	sub	r9,r8,1
80009a76:	49 a8       	lddpc	r8,80009adc <xTaskResumeAll+0x118>
80009a78:	91 09       	st.w	r8[0x0],r9
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80009a7a:	49 98       	lddpc	r8,80009adc <xTaskResumeAll+0x118>
80009a7c:	70 08       	ld.w	r8,r8[0x0]
80009a7e:	58 08       	cp.w	r8,0
80009a80:	cf 51       	brne	80009a6a <xTaskResumeAll+0xa6>
					/* As we have processed some ticks it is appropriate to yield
					to ensure the highest priority task that is ready to run is
					the task actually running. */
					#if configUSE_PREEMPTION == 1
					{
						xYieldRequired = pdTRUE;
80009a82:	30 18       	mov	r8,1
80009a84:	ef 48 ff fc 	st.w	r7[-4],r8
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
80009a88:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009a8c:	58 18       	cp.w	r8,1
80009a8e:	c0 50       	breq	80009a98 <xTaskResumeAll+0xd4>
80009a90:	49 58       	lddpc	r8,80009ae4 <xTaskResumeAll+0x120>
80009a92:	70 08       	ld.w	r8,r8[0x0]
80009a94:	58 18       	cp.w	r8,1
80009a96:	c0 81       	brne	80009aa6 <xTaskResumeAll+0xe2>
				{
					xAlreadyYielded = pdTRUE;
80009a98:	30 18       	mov	r8,1
80009a9a:	ef 48 ff f8 	st.w	r7[-8],r8
					xMissedYield = pdFALSE;
80009a9e:	49 28       	lddpc	r8,80009ae4 <xTaskResumeAll+0x120>
80009aa0:	30 09       	mov	r9,0
80009aa2:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
80009aa4:	d7 33       	scall
				}
			}
		}
	}
	taskEXIT_CRITICAL();
80009aa6:	f0 1f 00 11 	mcall	80009ae8 <xTaskResumeAll+0x124>

	return xAlreadyYielded;
80009aaa:	ee f8 ff f8 	ld.w	r8,r7[-8]
}
80009aae:	10 9c       	mov	r12,r8
80009ab0:	2f ed       	sub	sp,-8
80009ab2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80009ab6:	00 00       	add	r0,r0
80009ab8:	80 00       	ld.sh	r0,r0[0x0]
80009aba:	8a 10       	ld.sh	r0,r5[0x2]
80009abc:	00 00       	add	r0,r0
80009abe:	0d 50       	ld.sh	r0,--r6
80009ac0:	00 00       	add	r0,r0
80009ac2:	0d 3c       	ld.ub	r12,r6++
80009ac4:	00 00       	add	r0,r0
80009ac6:	0c fc       	st.b	--r6,r12
80009ac8:	80 00       	ld.sh	r0,r0[0x0]
80009aca:	88 52       	ld.sh	r2,r4[0xa]
80009acc:	00 00       	add	r0,r0
80009ace:	0d 48       	ld.w	r8,--r6
80009ad0:	00 00       	add	r0,r0
80009ad2:	0c 2c       	rsub	r12,r6
80009ad4:	80 00       	ld.sh	r0,r0[0x0]
80009ad6:	87 3e       	st.w	r3[0xc],lr
80009ad8:	00 00       	add	r0,r0
80009ada:	0c 28       	rsub	r8,r6
80009adc:	00 00       	add	r0,r0
80009ade:	0d 54       	ld.sh	r4,--r6
80009ae0:	80 00       	ld.sh	r0,r0[0x0]
80009ae2:	9b 1c       	st.w	sp[0x4],r12
80009ae4:	00 00       	add	r0,r0
80009ae6:	0d 58       	ld.sh	r8,--r6
80009ae8:	80 00       	ld.sh	r0,r0[0x0]
80009aea:	8a 2c       	ld.sh	r12,r5[0x4]

80009aec <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
80009aec:	eb cd 40 80 	pushm	r7,lr
80009af0:	1a 97       	mov	r7,sp
80009af2:	20 1d       	sub	sp,4
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
80009af4:	f0 1f 00 07 	mcall	80009b10 <xTaskGetTickCount+0x24>
	{
		xTicks = xTickCount;
80009af8:	48 78       	lddpc	r8,80009b14 <xTaskGetTickCount+0x28>
80009afa:	70 08       	ld.w	r8,r8[0x0]
80009afc:	ef 48 ff fc 	st.w	r7[-4],r8
	}
	taskEXIT_CRITICAL();
80009b00:	f0 1f 00 06 	mcall	80009b18 <xTaskGetTickCount+0x2c>

	return xTicks;
80009b04:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
80009b08:	10 9c       	mov	r12,r8
80009b0a:	2f fd       	sub	sp,-4
80009b0c:	e3 cd 80 80 	ldm	sp++,r7,pc
80009b10:	80 00       	ld.sh	r0,r0[0x0]
80009b12:	8a 10       	ld.sh	r0,r5[0x2]
80009b14:	00 00       	add	r0,r0
80009b16:	0d 40       	ld.w	r0,--r6
80009b18:	80 00       	ld.sh	r0,r0[0x0]
80009b1a:	8a 2c       	ld.sh	r12,r5[0x4]

80009b1c <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
80009b1c:	eb cd 40 80 	pushm	r7,lr
80009b20:	1a 97       	mov	r7,sp
80009b22:	20 3d       	sub	sp,12
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80009b24:	4c b8       	lddpc	r8,80009c50 <vTaskIncrementTick+0x134>
80009b26:	70 08       	ld.w	r8,r8[0x0]
80009b28:	58 08       	cp.w	r8,0
80009b2a:	e0 81 00 89 	brne	80009c3c <vTaskIncrementTick+0x120>
	{
		++xTickCount;
80009b2e:	4c a8       	lddpc	r8,80009c54 <vTaskIncrementTick+0x138>
80009b30:	70 08       	ld.w	r8,r8[0x0]
80009b32:	f0 c9 ff ff 	sub	r9,r8,-1
80009b36:	4c 88       	lddpc	r8,80009c54 <vTaskIncrementTick+0x138>
80009b38:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
80009b3a:	4c 78       	lddpc	r8,80009c54 <vTaskIncrementTick+0x138>
80009b3c:	70 08       	ld.w	r8,r8[0x0]
80009b3e:	58 08       	cp.w	r8,0
80009b40:	c2 71       	brne	80009b8e <vTaskIncrementTick+0x72>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
80009b42:	4c 68       	lddpc	r8,80009c58 <vTaskIncrementTick+0x13c>
80009b44:	70 08       	ld.w	r8,r8[0x0]
80009b46:	ef 48 ff f8 	st.w	r7[-8],r8
			pxDelayedTaskList = pxOverflowDelayedTaskList;
80009b4a:	4c 58       	lddpc	r8,80009c5c <vTaskIncrementTick+0x140>
80009b4c:	70 09       	ld.w	r9,r8[0x0]
80009b4e:	4c 38       	lddpc	r8,80009c58 <vTaskIncrementTick+0x13c>
80009b50:	91 09       	st.w	r8[0x0],r9
			pxOverflowDelayedTaskList = pxTemp;
80009b52:	4c 38       	lddpc	r8,80009c5c <vTaskIncrementTick+0x140>
80009b54:	ee f9 ff f8 	ld.w	r9,r7[-8]
80009b58:	91 09       	st.w	r8[0x0],r9
			xNumOfOverflows++;
80009b5a:	4c 28       	lddpc	r8,80009c60 <vTaskIncrementTick+0x144>
80009b5c:	70 08       	ld.w	r8,r8[0x0]
80009b5e:	f0 c9 ff ff 	sub	r9,r8,-1
80009b62:	4c 08       	lddpc	r8,80009c60 <vTaskIncrementTick+0x144>
80009b64:	91 09       	st.w	r8[0x0],r9

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
80009b66:	4b d8       	lddpc	r8,80009c58 <vTaskIncrementTick+0x13c>
80009b68:	70 08       	ld.w	r8,r8[0x0]
80009b6a:	70 08       	ld.w	r8,r8[0x0]
80009b6c:	58 08       	cp.w	r8,0
80009b6e:	c0 51       	brne	80009b78 <vTaskIncrementTick+0x5c>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
80009b70:	4b d8       	lddpc	r8,80009c64 <vTaskIncrementTick+0x148>
80009b72:	3f f9       	mov	r9,-1
80009b74:	91 09       	st.w	r8[0x0],r9
80009b76:	c0 c8       	rjmp	80009b8e <vTaskIncrementTick+0x72>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
80009b78:	4b 88       	lddpc	r8,80009c58 <vTaskIncrementTick+0x13c>
80009b7a:	70 08       	ld.w	r8,r8[0x0]
80009b7c:	70 38       	ld.w	r8,r8[0xc]
80009b7e:	70 38       	ld.w	r8,r8[0xc]
80009b80:	ef 48 ff f4 	st.w	r7[-12],r8
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
80009b84:	ee f8 ff f4 	ld.w	r8,r7[-12]
80009b88:	70 19       	ld.w	r9,r8[0x4]
80009b8a:	4b 78       	lddpc	r8,80009c64 <vTaskIncrementTick+0x148>
80009b8c:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
80009b8e:	4b 28       	lddpc	r8,80009c54 <vTaskIncrementTick+0x138>
80009b90:	70 09       	ld.w	r9,r8[0x0]
80009b92:	4b 58       	lddpc	r8,80009c64 <vTaskIncrementTick+0x148>
80009b94:	70 08       	ld.w	r8,r8[0x0]
80009b96:	10 39       	cp.w	r9,r8
80009b98:	c5 83       	brcs	80009c48 <vTaskIncrementTick+0x12c>
80009b9a:	4b 08       	lddpc	r8,80009c58 <vTaskIncrementTick+0x13c>
80009b9c:	70 08       	ld.w	r8,r8[0x0]
80009b9e:	70 08       	ld.w	r8,r8[0x0]
80009ba0:	58 08       	cp.w	r8,0
80009ba2:	c0 51       	brne	80009bac <vTaskIncrementTick+0x90>
80009ba4:	4b 08       	lddpc	r8,80009c64 <vTaskIncrementTick+0x148>
80009ba6:	3f f9       	mov	r9,-1
80009ba8:	91 09       	st.w	r8[0x0],r9
80009baa:	c4 f8       	rjmp	80009c48 <vTaskIncrementTick+0x12c>
80009bac:	4a b8       	lddpc	r8,80009c58 <vTaskIncrementTick+0x13c>
80009bae:	70 08       	ld.w	r8,r8[0x0]
80009bb0:	70 38       	ld.w	r8,r8[0xc]
80009bb2:	70 38       	ld.w	r8,r8[0xc]
80009bb4:	ef 48 ff f4 	st.w	r7[-12],r8
80009bb8:	ee f8 ff f4 	ld.w	r8,r7[-12]
80009bbc:	70 18       	ld.w	r8,r8[0x4]
80009bbe:	ef 48 ff fc 	st.w	r7[-4],r8
80009bc2:	4a 58       	lddpc	r8,80009c54 <vTaskIncrementTick+0x138>
80009bc4:	70 09       	ld.w	r9,r8[0x0]
80009bc6:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009bca:	10 39       	cp.w	r9,r8
80009bcc:	c0 62       	brcc	80009bd8 <vTaskIncrementTick+0xbc>
80009bce:	4a 68       	lddpc	r8,80009c64 <vTaskIncrementTick+0x148>
80009bd0:	ee f9 ff fc 	ld.w	r9,r7[-4]
80009bd4:	91 09       	st.w	r8[0x0],r9
80009bd6:	c3 98       	rjmp	80009c48 <vTaskIncrementTick+0x12c>
80009bd8:	ee f8 ff f4 	ld.w	r8,r7[-12]
80009bdc:	2f c8       	sub	r8,-4
80009bde:	10 9c       	mov	r12,r8
80009be0:	f0 1f 00 22 	mcall	80009c68 <vTaskIncrementTick+0x14c>
80009be4:	ee f8 ff f4 	ld.w	r8,r7[-12]
80009be8:	70 a8       	ld.w	r8,r8[0x28]
80009bea:	58 08       	cp.w	r8,0
80009bec:	c0 70       	breq	80009bfa <vTaskIncrementTick+0xde>
80009bee:	ee f8 ff f4 	ld.w	r8,r7[-12]
80009bf2:	2e 88       	sub	r8,-24
80009bf4:	10 9c       	mov	r12,r8
80009bf6:	f0 1f 00 1d 	mcall	80009c68 <vTaskIncrementTick+0x14c>
80009bfa:	ee f8 ff f4 	ld.w	r8,r7[-12]
80009bfe:	70 b9       	ld.w	r9,r8[0x2c]
80009c00:	49 b8       	lddpc	r8,80009c6c <vTaskIncrementTick+0x150>
80009c02:	70 08       	ld.w	r8,r8[0x0]
80009c04:	10 39       	cp.w	r9,r8
80009c06:	e0 88 00 07 	brls	80009c14 <vTaskIncrementTick+0xf8>
80009c0a:	ee f8 ff f4 	ld.w	r8,r7[-12]
80009c0e:	70 b9       	ld.w	r9,r8[0x2c]
80009c10:	49 78       	lddpc	r8,80009c6c <vTaskIncrementTick+0x150>
80009c12:	91 09       	st.w	r8[0x0],r9
80009c14:	ee f8 ff f4 	ld.w	r8,r7[-12]
80009c18:	f0 ca ff fc 	sub	r10,r8,-4
80009c1c:	ee f8 ff f4 	ld.w	r8,r7[-12]
80009c20:	70 b9       	ld.w	r9,r8[0x2c]
80009c22:	12 98       	mov	r8,r9
80009c24:	a3 68       	lsl	r8,0x2
80009c26:	12 08       	add	r8,r9
80009c28:	a3 68       	lsl	r8,0x2
80009c2a:	10 99       	mov	r9,r8
80009c2c:	49 18       	lddpc	r8,80009c70 <vTaskIncrementTick+0x154>
80009c2e:	f2 08 00 08 	add	r8,r9,r8
80009c32:	14 9b       	mov	r11,r10
80009c34:	10 9c       	mov	r12,r8
80009c36:	f0 1f 00 10 	mcall	80009c74 <vTaskIncrementTick+0x158>
80009c3a:	cb 0b       	rjmp	80009b9a <vTaskIncrementTick+0x7e>
	}
	else
	{
		++uxMissedTicks;
80009c3c:	48 f8       	lddpc	r8,80009c78 <vTaskIncrementTick+0x15c>
80009c3e:	70 08       	ld.w	r8,r8[0x0]
80009c40:	f0 c9 ff ff 	sub	r9,r8,-1
80009c44:	48 d8       	lddpc	r8,80009c78 <vTaskIncrementTick+0x15c>
80009c46:	91 09       	st.w	r8[0x0],r9
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
80009c48:	2f dd       	sub	sp,-12
80009c4a:	e3 cd 80 80 	ldm	sp++,r7,pc
80009c4e:	00 00       	add	r0,r0
80009c50:	00 00       	add	r0,r0
80009c52:	0d 50       	ld.sh	r0,--r6
80009c54:	00 00       	add	r0,r0
80009c56:	0d 40       	ld.w	r0,--r6
80009c58:	00 00       	add	r0,r0
80009c5a:	0c f4       	st.b	--r6,r4
80009c5c:	00 00       	add	r0,r0
80009c5e:	0c f8       	st.b	--r6,r8
80009c60:	00 00       	add	r0,r0
80009c62:	0d 5c       	ld.sh	r12,--r6
80009c64:	00 00       	add	r0,r0
80009c66:	05 4c       	ld.w	r12,--r2
80009c68:	80 00       	ld.sh	r0,r0[0x0]
80009c6a:	88 52       	ld.sh	r2,r4[0xa]
80009c6c:	00 00       	add	r0,r0
80009c6e:	0d 48       	ld.w	r8,--r6
80009c70:	00 00       	add	r0,r0
80009c72:	0c 2c       	rsub	r12,r6
80009c74:	80 00       	ld.sh	r0,r0[0x0]
80009c76:	87 3e       	st.w	r3[0xc],lr
80009c78:	00 00       	add	r0,r0
80009c7a:	0d 54       	ld.sh	r4,--r6

80009c7c <vTaskSwitchContext>:

#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
80009c7c:	eb cd 40 80 	pushm	r7,lr
80009c80:	1a 97       	mov	r7,sp
80009c82:	20 1d       	sub	sp,4
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
80009c84:	4a 58       	lddpc	r8,80009d18 <vTaskSwitchContext+0x9c>
80009c86:	70 08       	ld.w	r8,r8[0x0]
80009c88:	58 08       	cp.w	r8,0
80009c8a:	c0 c0       	breq	80009ca2 <vTaskSwitchContext+0x26>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
80009c8c:	4a 48       	lddpc	r8,80009d1c <vTaskSwitchContext+0xa0>
80009c8e:	30 19       	mov	r9,1
80009c90:	91 09       	st.w	r8[0x0],r9
80009c92:	c3 f8       	rjmp	80009d10 <vTaskSwitchContext+0x94>

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80009c94:	4a 38       	lddpc	r8,80009d20 <vTaskSwitchContext+0xa4>
80009c96:	70 08       	ld.w	r8,r8[0x0]
80009c98:	f0 c9 00 01 	sub	r9,r8,1
80009c9c:	4a 18       	lddpc	r8,80009d20 <vTaskSwitchContext+0xa4>
80009c9e:	91 09       	st.w	r8[0x0],r9
80009ca0:	c0 28       	rjmp	80009ca4 <vTaskSwitchContext+0x28>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80009ca2:	d7 03       	nop
80009ca4:	49 f8       	lddpc	r8,80009d20 <vTaskSwitchContext+0xa4>
80009ca6:	70 09       	ld.w	r9,r8[0x0]
80009ca8:	12 98       	mov	r8,r9
80009caa:	a3 68       	lsl	r8,0x2
80009cac:	12 08       	add	r8,r9
80009cae:	a3 68       	lsl	r8,0x2
80009cb0:	10 99       	mov	r9,r8
80009cb2:	49 d8       	lddpc	r8,80009d24 <vTaskSwitchContext+0xa8>
80009cb4:	f2 08 00 08 	add	r8,r9,r8
80009cb8:	70 08       	ld.w	r8,r8[0x0]
80009cba:	58 08       	cp.w	r8,0
80009cbc:	ce c0       	breq	80009c94 <vTaskSwitchContext+0x18>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
80009cbe:	49 98       	lddpc	r8,80009d20 <vTaskSwitchContext+0xa4>
80009cc0:	70 09       	ld.w	r9,r8[0x0]
80009cc2:	12 98       	mov	r8,r9
80009cc4:	a3 68       	lsl	r8,0x2
80009cc6:	12 08       	add	r8,r9
80009cc8:	a3 68       	lsl	r8,0x2
80009cca:	10 99       	mov	r9,r8
80009ccc:	49 68       	lddpc	r8,80009d24 <vTaskSwitchContext+0xa8>
80009cce:	f2 08 00 08 	add	r8,r9,r8
80009cd2:	ef 48 ff fc 	st.w	r7[-4],r8
80009cd6:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009cda:	70 18       	ld.w	r8,r8[0x4]
80009cdc:	70 19       	ld.w	r9,r8[0x4]
80009cde:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009ce2:	91 19       	st.w	r8[0x4],r9
80009ce4:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009ce8:	70 19       	ld.w	r9,r8[0x4]
80009cea:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009cee:	2f 88       	sub	r8,-8
80009cf0:	10 39       	cp.w	r9,r8
80009cf2:	c0 81       	brne	80009d02 <vTaskSwitchContext+0x86>
80009cf4:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009cf8:	70 18       	ld.w	r8,r8[0x4]
80009cfa:	70 19       	ld.w	r9,r8[0x4]
80009cfc:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009d00:	91 19       	st.w	r8[0x4],r9
80009d02:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009d06:	70 18       	ld.w	r8,r8[0x4]
80009d08:	70 38       	ld.w	r8,r8[0xc]
80009d0a:	10 99       	mov	r9,r8
80009d0c:	48 78       	lddpc	r8,80009d28 <vTaskSwitchContext+0xac>
80009d0e:	91 09       	st.w	r8[0x0],r9

		traceTASK_SWITCHED_IN();
		vWriteTraceToBuffer();
	}
}
80009d10:	2f fd       	sub	sp,-4
80009d12:	e3 cd 80 80 	ldm	sp++,r7,pc
80009d16:	00 00       	add	r0,r0
80009d18:	00 00       	add	r0,r0
80009d1a:	0d 50       	ld.sh	r0,--r6
80009d1c:	00 00       	add	r0,r0
80009d1e:	0d 58       	ld.sh	r8,--r6
80009d20:	00 00       	add	r0,r0
80009d22:	0d 48       	ld.w	r8,--r6
80009d24:	00 00       	add	r0,r0
80009d26:	0c 2c       	rsub	r12,r6
80009d28:	00 00       	add	r0,r0
80009d2a:	0c 28       	rsub	r8,r6

80009d2c <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
80009d2c:	eb cd 40 80 	pushm	r7,lr
80009d30:	1a 97       	mov	r7,sp
80009d32:	20 3d       	sub	sp,12
80009d34:	ef 4c ff f8 	st.w	r7[-8],r12
80009d38:	ef 4b ff f4 	st.w	r7[-12],r11
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
80009d3c:	49 58       	lddpc	r8,80009d90 <vTaskPlaceOnEventList+0x64>
80009d3e:	70 08       	ld.w	r8,r8[0x0]
80009d40:	2e 88       	sub	r8,-24
80009d42:	10 9b       	mov	r11,r8
80009d44:	ee fc ff f8 	ld.w	r12,r7[-8]
80009d48:	f0 1f 00 13 	mcall	80009d94 <vTaskPlaceOnEventList+0x68>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80009d4c:	49 18       	lddpc	r8,80009d90 <vTaskPlaceOnEventList+0x64>
80009d4e:	70 08       	ld.w	r8,r8[0x0]
80009d50:	2f c8       	sub	r8,-4
80009d52:	10 9c       	mov	r12,r8
80009d54:	f0 1f 00 11 	mcall	80009d98 <vTaskPlaceOnEventList+0x6c>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
80009d58:	ee f8 ff f4 	ld.w	r8,r7[-12]
80009d5c:	5b f8       	cp.w	r8,-1
80009d5e:	c0 91       	brne	80009d70 <vTaskPlaceOnEventList+0x44>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80009d60:	48 c8       	lddpc	r8,80009d90 <vTaskPlaceOnEventList+0x64>
80009d62:	70 08       	ld.w	r8,r8[0x0]
80009d64:	2f c8       	sub	r8,-4
80009d66:	10 9b       	mov	r11,r8
80009d68:	48 dc       	lddpc	r12,80009d9c <vTaskPlaceOnEventList+0x70>
80009d6a:	f0 1f 00 0e 	mcall	80009da0 <vTaskPlaceOnEventList+0x74>
80009d6e:	c0 d8       	rjmp	80009d88 <vTaskPlaceOnEventList+0x5c>
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
80009d70:	48 d8       	lddpc	r8,80009da4 <vTaskPlaceOnEventList+0x78>
80009d72:	70 09       	ld.w	r9,r8[0x0]
80009d74:	ee f8 ff f4 	ld.w	r8,r7[-12]
80009d78:	f2 08 00 08 	add	r8,r9,r8
80009d7c:	ef 48 ff fc 	st.w	r7[-4],r8
			prvAddCurrentTaskToDelayedList( xTimeToWake );
80009d80:	ee fc ff fc 	ld.w	r12,r7[-4]
80009d84:	f0 1f 00 09 	mcall	80009da8 <vTaskPlaceOnEventList+0x7c>
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
	}
	#endif
}
80009d88:	2f dd       	sub	sp,-12
80009d8a:	e3 cd 80 80 	ldm	sp++,r7,pc
80009d8e:	00 00       	add	r0,r0
80009d90:	00 00       	add	r0,r0
80009d92:	0c 28       	rsub	r8,r6
80009d94:	80 00       	ld.sh	r0,r0[0x0]
80009d96:	87 b0       	st.w	r3[0x2c],r0
80009d98:	80 00       	ld.sh	r0,r0[0x0]
80009d9a:	88 52       	ld.sh	r2,r4[0xa]
80009d9c:	00 00       	add	r0,r0
80009d9e:	0d 28       	ld.uh	r8,r6++
80009da0:	80 00       	ld.sh	r0,r0[0x0]
80009da2:	87 3e       	st.w	r3[0xc],lr
80009da4:	00 00       	add	r0,r0
80009da6:	0d 40       	ld.w	r0,--r6
80009da8:	80 00       	ld.sh	r0,r0[0x0]
80009daa:	a1 7c       	lsl	r12,0x1

80009dac <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
80009dac:	eb cd 40 80 	pushm	r7,lr
80009db0:	1a 97       	mov	r7,sp
80009db2:	20 3d       	sub	sp,12
80009db4:	ef 4c ff f4 	st.w	r7[-12],r12
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
80009db8:	ee f8 ff f4 	ld.w	r8,r7[-12]
80009dbc:	70 38       	ld.w	r8,r8[0xc]
80009dbe:	70 38       	ld.w	r8,r8[0xc]
80009dc0:	ef 48 ff f8 	st.w	r7[-8],r8
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
80009dc4:	ee f8 ff f8 	ld.w	r8,r7[-8]
80009dc8:	2e 88       	sub	r8,-24
80009dca:	10 9c       	mov	r12,r8
80009dcc:	f0 1f 00 25 	mcall	80009e60 <xTaskRemoveFromEventList+0xb4>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80009dd0:	4a 58       	lddpc	r8,80009e64 <xTaskRemoveFromEventList+0xb8>
80009dd2:	70 08       	ld.w	r8,r8[0x0]
80009dd4:	58 08       	cp.w	r8,0
80009dd6:	c2 81       	brne	80009e26 <xTaskRemoveFromEventList+0x7a>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
80009dd8:	ee f8 ff f8 	ld.w	r8,r7[-8]
80009ddc:	2f c8       	sub	r8,-4
80009dde:	10 9c       	mov	r12,r8
80009de0:	f0 1f 00 20 	mcall	80009e60 <xTaskRemoveFromEventList+0xb4>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
80009de4:	ee f8 ff f8 	ld.w	r8,r7[-8]
80009de8:	70 b9       	ld.w	r9,r8[0x2c]
80009dea:	4a 08       	lddpc	r8,80009e68 <xTaskRemoveFromEventList+0xbc>
80009dec:	70 08       	ld.w	r8,r8[0x0]
80009dee:	10 39       	cp.w	r9,r8
80009df0:	e0 88 00 07 	brls	80009dfe <xTaskRemoveFromEventList+0x52>
80009df4:	ee f8 ff f8 	ld.w	r8,r7[-8]
80009df8:	70 b9       	ld.w	r9,r8[0x2c]
80009dfa:	49 c8       	lddpc	r8,80009e68 <xTaskRemoveFromEventList+0xbc>
80009dfc:	91 09       	st.w	r8[0x0],r9
80009dfe:	ee f8 ff f8 	ld.w	r8,r7[-8]
80009e02:	f0 ca ff fc 	sub	r10,r8,-4
80009e06:	ee f8 ff f8 	ld.w	r8,r7[-8]
80009e0a:	70 b9       	ld.w	r9,r8[0x2c]
80009e0c:	12 98       	mov	r8,r9
80009e0e:	a3 68       	lsl	r8,0x2
80009e10:	12 08       	add	r8,r9
80009e12:	a3 68       	lsl	r8,0x2
80009e14:	10 99       	mov	r9,r8
80009e16:	49 68       	lddpc	r8,80009e6c <xTaskRemoveFromEventList+0xc0>
80009e18:	f2 08 00 08 	add	r8,r9,r8
80009e1c:	14 9b       	mov	r11,r10
80009e1e:	10 9c       	mov	r12,r8
80009e20:	f0 1f 00 14 	mcall	80009e70 <xTaskRemoveFromEventList+0xc4>
80009e24:	c0 88       	rjmp	80009e34 <xTaskRemoveFromEventList+0x88>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
80009e26:	ee f8 ff f8 	ld.w	r8,r7[-8]
80009e2a:	2e 88       	sub	r8,-24
80009e2c:	10 9b       	mov	r11,r8
80009e2e:	49 2c       	lddpc	r12,80009e74 <xTaskRemoveFromEventList+0xc8>
80009e30:	f0 1f 00 10 	mcall	80009e70 <xTaskRemoveFromEventList+0xc4>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
80009e34:	ee f8 ff f8 	ld.w	r8,r7[-8]
80009e38:	70 b9       	ld.w	r9,r8[0x2c]
80009e3a:	49 08       	lddpc	r8,80009e78 <xTaskRemoveFromEventList+0xcc>
80009e3c:	70 08       	ld.w	r8,r8[0x0]
80009e3e:	70 b8       	ld.w	r8,r8[0x2c]
80009e40:	10 39       	cp.w	r9,r8
80009e42:	c0 53       	brcs	80009e4c <xTaskRemoveFromEventList+0xa0>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
80009e44:	30 18       	mov	r8,1
80009e46:	ef 48 ff fc 	st.w	r7[-4],r8
80009e4a:	c0 48       	rjmp	80009e52 <xTaskRemoveFromEventList+0xa6>
	}
	else
	{
		xReturn = pdFALSE;
80009e4c:	30 08       	mov	r8,0
80009e4e:	ef 48 ff fc 	st.w	r7[-4],r8
	}

	return xReturn;
80009e52:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
80009e56:	10 9c       	mov	r12,r8
80009e58:	2f dd       	sub	sp,-12
80009e5a:	e3 cd 80 80 	ldm	sp++,r7,pc
80009e5e:	00 00       	add	r0,r0
80009e60:	80 00       	ld.sh	r0,r0[0x0]
80009e62:	88 52       	ld.sh	r2,r4[0xa]
80009e64:	00 00       	add	r0,r0
80009e66:	0d 50       	ld.sh	r0,--r6
80009e68:	00 00       	add	r0,r0
80009e6a:	0d 48       	ld.w	r8,--r6
80009e6c:	00 00       	add	r0,r0
80009e6e:	0c 2c       	rsub	r12,r6
80009e70:	80 00       	ld.sh	r0,r0[0x0]
80009e72:	87 3e       	st.w	r3[0xc],lr
80009e74:	00 00       	add	r0,r0
80009e76:	0c fc       	st.b	--r6,r12
80009e78:	00 00       	add	r0,r0
80009e7a:	0c 28       	rsub	r8,r6

80009e7c <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
80009e7c:	eb cd 40 80 	pushm	r7,lr
80009e80:	1a 97       	mov	r7,sp
80009e82:	20 1d       	sub	sp,4
80009e84:	ef 4c ff fc 	st.w	r7[-4],r12
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
80009e88:	48 78       	lddpc	r8,80009ea4 <vTaskSetTimeOutState+0x28>
80009e8a:	70 09       	ld.w	r9,r8[0x0]
80009e8c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009e90:	91 09       	st.w	r8[0x0],r9
	pxTimeOut->xTimeOnEntering = xTickCount;
80009e92:	48 68       	lddpc	r8,80009ea8 <vTaskSetTimeOutState+0x2c>
80009e94:	70 09       	ld.w	r9,r8[0x0]
80009e96:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009e9a:	91 19       	st.w	r8[0x4],r9
}
80009e9c:	2f fd       	sub	sp,-4
80009e9e:	e3 cd 80 80 	ldm	sp++,r7,pc
80009ea2:	00 00       	add	r0,r0
80009ea4:	00 00       	add	r0,r0
80009ea6:	0d 5c       	ld.sh	r12,--r6
80009ea8:	00 00       	add	r0,r0
80009eaa:	0d 40       	ld.w	r0,--r6

80009eac <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
80009eac:	eb cd 40 80 	pushm	r7,lr
80009eb0:	1a 97       	mov	r7,sp
80009eb2:	20 3d       	sub	sp,12
80009eb4:	ef 4c ff f8 	st.w	r7[-8],r12
80009eb8:	ef 4b ff f4 	st.w	r7[-12],r11
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
80009ebc:	f0 1f 00 25 	mcall	80009f50 <xTaskCheckForTimeOut+0xa4>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
80009ec0:	ee f8 ff f4 	ld.w	r8,r7[-12]
80009ec4:	70 08       	ld.w	r8,r8[0x0]
80009ec6:	5b f8       	cp.w	r8,-1
80009ec8:	c0 51       	brne	80009ed2 <xTaskCheckForTimeOut+0x26>
			{
				xReturn = pdFALSE;
80009eca:	30 08       	mov	r8,0
80009ecc:	ef 48 ff fc 	st.w	r7[-4],r8
80009ed0:	c3 88       	rjmp	80009f40 <xTaskCheckForTimeOut+0x94>
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
80009ed2:	ee f8 ff f8 	ld.w	r8,r7[-8]
80009ed6:	70 09       	ld.w	r9,r8[0x0]
80009ed8:	49 f8       	lddpc	r8,80009f54 <xTaskCheckForTimeOut+0xa8>
80009eda:	70 08       	ld.w	r8,r8[0x0]
80009edc:	10 39       	cp.w	r9,r8
80009ede:	c0 d0       	breq	80009ef8 <xTaskCheckForTimeOut+0x4c>
80009ee0:	ee f8 ff f8 	ld.w	r8,r7[-8]
80009ee4:	70 19       	ld.w	r9,r8[0x4]
80009ee6:	49 d8       	lddpc	r8,80009f58 <xTaskCheckForTimeOut+0xac>
80009ee8:	70 08       	ld.w	r8,r8[0x0]
80009eea:	10 39       	cp.w	r9,r8
80009eec:	e0 8b 00 06 	brhi	80009ef8 <xTaskCheckForTimeOut+0x4c>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
80009ef0:	30 18       	mov	r8,1
80009ef2:	ef 48 ff fc 	st.w	r7[-4],r8
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
80009ef6:	c2 58       	rjmp	80009f40 <xTaskCheckForTimeOut+0x94>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
80009ef8:	49 88       	lddpc	r8,80009f58 <xTaskCheckForTimeOut+0xac>
80009efa:	70 09       	ld.w	r9,r8[0x0]
80009efc:	ee f8 ff f8 	ld.w	r8,r7[-8]
80009f00:	70 18       	ld.w	r8,r8[0x4]
80009f02:	10 19       	sub	r9,r8
80009f04:	ee f8 ff f4 	ld.w	r8,r7[-12]
80009f08:	70 08       	ld.w	r8,r8[0x0]
80009f0a:	10 39       	cp.w	r9,r8
80009f0c:	c1 72       	brcc	80009f3a <xTaskCheckForTimeOut+0x8e>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
80009f0e:	ee f8 ff f4 	ld.w	r8,r7[-12]
80009f12:	70 09       	ld.w	r9,r8[0x0]
80009f14:	ee f8 ff f8 	ld.w	r8,r7[-8]
80009f18:	70 1a       	ld.w	r10,r8[0x4]
80009f1a:	49 08       	lddpc	r8,80009f58 <xTaskCheckForTimeOut+0xac>
80009f1c:	70 08       	ld.w	r8,r8[0x0]
80009f1e:	f4 08 01 08 	sub	r8,r10,r8
80009f22:	10 09       	add	r9,r8
80009f24:	ee f8 ff f4 	ld.w	r8,r7[-12]
80009f28:	91 09       	st.w	r8[0x0],r9
			vTaskSetTimeOutState( pxTimeOut );
80009f2a:	ee fc ff f8 	ld.w	r12,r7[-8]
80009f2e:	f0 1f 00 0c 	mcall	80009f5c <xTaskCheckForTimeOut+0xb0>
			xReturn = pdFALSE;
80009f32:	30 08       	mov	r8,0
80009f34:	ef 48 ff fc 	st.w	r7[-4],r8
80009f38:	c0 48       	rjmp	80009f40 <xTaskCheckForTimeOut+0x94>
		}
		else
		{
			xReturn = pdTRUE;
80009f3a:	30 18       	mov	r8,1
80009f3c:	ef 48 ff fc 	st.w	r7[-4],r8
		}
	}
	taskEXIT_CRITICAL();
80009f40:	f0 1f 00 08 	mcall	80009f60 <xTaskCheckForTimeOut+0xb4>

	return xReturn;
80009f44:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
80009f48:	10 9c       	mov	r12,r8
80009f4a:	2f dd       	sub	sp,-12
80009f4c:	e3 cd 80 80 	ldm	sp++,r7,pc
80009f50:	80 00       	ld.sh	r0,r0[0x0]
80009f52:	8a 10       	ld.sh	r0,r5[0x2]
80009f54:	00 00       	add	r0,r0
80009f56:	0d 5c       	ld.sh	r12,--r6
80009f58:	00 00       	add	r0,r0
80009f5a:	0d 40       	ld.w	r0,--r6
80009f5c:	80 00       	ld.sh	r0,r0[0x0]
80009f5e:	9e 7c       	ld.sh	r12,pc[0xe]
80009f60:	80 00       	ld.sh	r0,r0[0x0]
80009f62:	8a 2c       	ld.sh	r12,r5[0x4]

80009f64 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
80009f64:	eb cd 40 80 	pushm	r7,lr
80009f68:	1a 97       	mov	r7,sp
	xMissedYield = pdTRUE;
80009f6a:	48 38       	lddpc	r8,80009f74 <vTaskMissedYield+0x10>
80009f6c:	30 19       	mov	r9,1
80009f6e:	91 09       	st.w	r8[0x0],r9
}
80009f70:	e3 cd 80 80 	ldm	sp++,r7,pc
80009f74:	00 00       	add	r0,r0
80009f76:	0d 58       	ld.sh	r8,--r6

80009f78 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
80009f78:	eb cd 40 80 	pushm	r7,lr
80009f7c:	1a 97       	mov	r7,sp
80009f7e:	20 1d       	sub	sp,4
80009f80:	ef 4c ff fc 	st.w	r7[-4],r12
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
80009f84:	f0 1f 00 06 	mcall	80009f9c <prvIdleTask+0x24>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80009f88:	48 68       	lddpc	r8,80009fa0 <prvIdleTask+0x28>
80009f8a:	70 08       	ld.w	r8,r8[0x0]
80009f8c:	58 18       	cp.w	r8,1
80009f8e:	e0 88 00 03 	brls	80009f94 <prvIdleTask+0x1c>
			{
				taskYIELD();
80009f92:	d7 33       	scall
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
80009f94:	f0 1f 00 04 	mcall	80009fa4 <prvIdleTask+0x2c>
		}
		#endif
	}
80009f98:	cf 6b       	rjmp	80009f84 <prvIdleTask+0xc>
80009f9a:	00 00       	add	r0,r0
80009f9c:	80 00       	ld.sh	r0,r0[0x0]
80009f9e:	a0 e4       	st.b	r0[0x6],r4
80009fa0:	00 00       	add	r0,r0
80009fa2:	0c 2c       	rsub	r12,r6
80009fa4:	80 00       	ld.sh	r0,r0[0x0]
80009fa6:	34 e4       	mov	r4,78

80009fa8 <prvInitialiseTCBVariables>:
 *----------------------------------------------------------*/



static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
{
80009fa8:	eb cd 40 80 	pushm	r7,lr
80009fac:	1a 97       	mov	r7,sp
80009fae:	20 5d       	sub	sp,20
80009fb0:	ef 4c ff fc 	st.w	r7[-4],r12
80009fb4:	ef 4b ff f8 	st.w	r7[-8],r11
80009fb8:	ef 4a ff f4 	st.w	r7[-12],r10
80009fbc:	ef 49 ff f0 	st.w	r7[-16],r9
80009fc0:	ef 58 ff ec 	st.h	r7[-20],r8
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
80009fc4:	ee f9 ff f8 	ld.w	r9,r7[-8]
80009fc8:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009fcc:	2c c8       	sub	r8,-52
80009fce:	31 0a       	mov	r10,16
80009fd0:	12 9b       	mov	r11,r9
80009fd2:	10 9c       	mov	r12,r8
80009fd4:	f0 1f 00 1d 	mcall	8000a048 <prvInitialiseTCBVariables+0xa0>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
80009fd8:	ee f9 ff fc 	ld.w	r9,r7[-4]
80009fdc:	30 08       	mov	r8,0
80009fde:	f3 68 00 43 	st.b	r9[67],r8

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= configMAX_PRIORITIES )
80009fe2:	ee f8 ff f4 	ld.w	r8,r7[-12]
80009fe6:	58 78       	cp.w	r8,7
80009fe8:	e0 88 00 05 	brls	80009ff2 <prvInitialiseTCBVariables+0x4a>
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
80009fec:	30 78       	mov	r8,7
80009fee:	ef 48 ff f4 	st.w	r7[-12],r8
	}

	pxTCB->uxPriority = uxPriority;
80009ff2:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009ff6:	ee f9 ff f4 	ld.w	r9,r7[-12]
80009ffa:	91 b9       	st.w	r8[0x2c],r9
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
80009ffc:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000a000:	ee f9 ff f4 	ld.w	r9,r7[-12]
8000a004:	f1 49 00 44 	st.w	r8[68],r9
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
8000a008:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000a00c:	2f c8       	sub	r8,-4
8000a00e:	10 9c       	mov	r12,r8
8000a010:	f0 1f 00 0f 	mcall	8000a04c <prvInitialiseTCBVariables+0xa4>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
8000a014:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000a018:	2e 88       	sub	r8,-24
8000a01a:	10 9c       	mov	r12,r8
8000a01c:	f0 1f 00 0c 	mcall	8000a04c <prvInitialiseTCBVariables+0xa4>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
8000a020:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000a024:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000a028:	91 49       	st.w	r8[0x10],r9

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
8000a02a:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000a02e:	f0 09 11 08 	rsub	r9,r8,8
8000a032:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000a036:	91 69       	st.w	r8[0x18],r9
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
8000a038:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000a03c:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000a040:	91 99       	st.w	r8[0x24],r9
	{
		( void ) xRegions;
		( void ) usStackDepth;
	}
	#endif
}
8000a042:	2f bd       	sub	sp,-20
8000a044:	e3 cd 80 80 	ldm	sp++,r7,pc
8000a048:	80 00       	ld.sh	r0,r0[0x0]
8000a04a:	b9 ec       	*unknown*
8000a04c:	80 00       	ld.sh	r0,r0[0x0]
8000a04e:	87 24       	st.w	r3[0x8],r4

8000a050 <prvInitialiseTaskLists>:
	}
	/*-----------------------------------------------------------*/
#endif

static void prvInitialiseTaskLists( void )
{
8000a050:	eb cd 40 80 	pushm	r7,lr
8000a054:	1a 97       	mov	r7,sp
8000a056:	20 1d       	sub	sp,4
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
8000a058:	30 08       	mov	r8,0
8000a05a:	ef 48 ff fc 	st.w	r7[-4],r8
8000a05e:	c1 38       	rjmp	8000a084 <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
8000a060:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000a064:	12 98       	mov	r8,r9
8000a066:	a3 68       	lsl	r8,0x2
8000a068:	12 08       	add	r8,r9
8000a06a:	a3 68       	lsl	r8,0x2
8000a06c:	10 99       	mov	r9,r8
8000a06e:	49 58       	lddpc	r8,8000a0c0 <prvInitialiseTaskLists+0x70>
8000a070:	f2 08 00 08 	add	r8,r9,r8
8000a074:	10 9c       	mov	r12,r8
8000a076:	f0 1f 00 14 	mcall	8000a0c4 <prvInitialiseTaskLists+0x74>

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
8000a07a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000a07e:	2f f8       	sub	r8,-1
8000a080:	ef 48 ff fc 	st.w	r7[-4],r8
8000a084:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000a088:	58 78       	cp.w	r8,7
8000a08a:	fe 98 ff eb 	brls	8000a060 <prvInitialiseTaskLists+0x10>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
8000a08e:	48 fc       	lddpc	r12,8000a0c8 <prvInitialiseTaskLists+0x78>
8000a090:	f0 1f 00 0d 	mcall	8000a0c4 <prvInitialiseTaskLists+0x74>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
8000a094:	48 ec       	lddpc	r12,8000a0cc <prvInitialiseTaskLists+0x7c>
8000a096:	f0 1f 00 0c 	mcall	8000a0c4 <prvInitialiseTaskLists+0x74>
	vListInitialise( ( xList * ) &xPendingReadyList );
8000a09a:	48 ec       	lddpc	r12,8000a0d0 <prvInitialiseTaskLists+0x80>
8000a09c:	f0 1f 00 0a 	mcall	8000a0c4 <prvInitialiseTaskLists+0x74>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
8000a0a0:	48 dc       	lddpc	r12,8000a0d4 <prvInitialiseTaskLists+0x84>
8000a0a2:	f0 1f 00 09 	mcall	8000a0c4 <prvInitialiseTaskLists+0x74>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
8000a0a6:	48 dc       	lddpc	r12,8000a0d8 <prvInitialiseTaskLists+0x88>
8000a0a8:	f0 1f 00 07 	mcall	8000a0c4 <prvInitialiseTaskLists+0x74>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
8000a0ac:	48 c8       	lddpc	r8,8000a0dc <prvInitialiseTaskLists+0x8c>
8000a0ae:	48 79       	lddpc	r9,8000a0c8 <prvInitialiseTaskLists+0x78>
8000a0b0:	91 09       	st.w	r8[0x0],r9
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
8000a0b2:	48 c8       	lddpc	r8,8000a0e0 <prvInitialiseTaskLists+0x90>
8000a0b4:	48 69       	lddpc	r9,8000a0cc <prvInitialiseTaskLists+0x7c>
8000a0b6:	91 09       	st.w	r8[0x0],r9
}
8000a0b8:	2f fd       	sub	sp,-4
8000a0ba:	e3 cd 80 80 	ldm	sp++,r7,pc
8000a0be:	00 00       	add	r0,r0
8000a0c0:	00 00       	add	r0,r0
8000a0c2:	0c 2c       	rsub	r12,r6
8000a0c4:	80 00       	ld.sh	r0,r0[0x0]
8000a0c6:	86 d8       	ld.uh	r8,r3[0xa]
8000a0c8:	00 00       	add	r0,r0
8000a0ca:	0c cc       	st.b	r6++,r12
8000a0cc:	00 00       	add	r0,r0
8000a0ce:	0c e0       	st.h	--r6,r0
8000a0d0:	00 00       	add	r0,r0
8000a0d2:	0c fc       	st.b	--r6,r12
8000a0d4:	00 00       	add	r0,r0
8000a0d6:	0d 10       	ld.sh	r0,r6++
8000a0d8:	00 00       	add	r0,r0
8000a0da:	0d 28       	ld.uh	r8,r6++
8000a0dc:	00 00       	add	r0,r0
8000a0de:	0c f4       	st.b	--r6,r4
8000a0e0:	00 00       	add	r0,r0
8000a0e2:	0c f8       	st.b	--r6,r8

8000a0e4 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
8000a0e4:	eb cd 40 80 	pushm	r7,lr
8000a0e8:	1a 97       	mov	r7,sp
8000a0ea:	20 2d       	sub	sp,8
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
8000a0ec:	49 b8       	lddpc	r8,8000a158 <prvCheckTasksWaitingTermination+0x74>
8000a0ee:	70 08       	ld.w	r8,r8[0x0]
8000a0f0:	58 08       	cp.w	r8,0
8000a0f2:	c2 f0       	breq	8000a150 <prvCheckTasksWaitingTermination+0x6c>
		{
			vTaskSuspendAll();
8000a0f4:	f0 1f 00 1a 	mcall	8000a15c <prvCheckTasksWaitingTermination+0x78>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
8000a0f8:	49 a8       	lddpc	r8,8000a160 <prvCheckTasksWaitingTermination+0x7c>
8000a0fa:	70 08       	ld.w	r8,r8[0x0]
8000a0fc:	58 08       	cp.w	r8,0
8000a0fe:	5f 08       	sreq	r8
8000a100:	ef 48 ff f8 	st.w	r7[-8],r8
			xTaskResumeAll();
8000a104:	f0 1f 00 18 	mcall	8000a164 <prvCheckTasksWaitingTermination+0x80>

			if( xListIsEmpty == pdFALSE )
8000a108:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000a10c:	58 08       	cp.w	r8,0
8000a10e:	c2 11       	brne	8000a150 <prvCheckTasksWaitingTermination+0x6c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
8000a110:	f0 1f 00 16 	mcall	8000a168 <prvCheckTasksWaitingTermination+0x84>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
8000a114:	49 38       	lddpc	r8,8000a160 <prvCheckTasksWaitingTermination+0x7c>
8000a116:	2f 88       	sub	r8,-8
8000a118:	70 18       	ld.w	r8,r8[0x4]
8000a11a:	70 38       	ld.w	r8,r8[0xc]
8000a11c:	ef 48 ff fc 	st.w	r7[-4],r8
					vListRemove( &( pxTCB->xGenericListItem ) );
8000a120:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000a124:	2f c8       	sub	r8,-4
8000a126:	10 9c       	mov	r12,r8
8000a128:	f0 1f 00 11 	mcall	8000a16c <prvCheckTasksWaitingTermination+0x88>
					--uxCurrentNumberOfTasks;
8000a12c:	49 18       	lddpc	r8,8000a170 <prvCheckTasksWaitingTermination+0x8c>
8000a12e:	70 08       	ld.w	r8,r8[0x0]
8000a130:	f0 c9 00 01 	sub	r9,r8,1
8000a134:	48 f8       	lddpc	r8,8000a170 <prvCheckTasksWaitingTermination+0x8c>
8000a136:	91 09       	st.w	r8[0x0],r9
					--uxTasksDeleted;
8000a138:	48 88       	lddpc	r8,8000a158 <prvCheckTasksWaitingTermination+0x74>
8000a13a:	70 08       	ld.w	r8,r8[0x0]
8000a13c:	f0 c9 00 01 	sub	r9,r8,1
8000a140:	48 68       	lddpc	r8,8000a158 <prvCheckTasksWaitingTermination+0x74>
8000a142:	91 09       	st.w	r8[0x0],r9
				}
				taskEXIT_CRITICAL();
8000a144:	f0 1f 00 0c 	mcall	8000a174 <prvCheckTasksWaitingTermination+0x90>

				prvDeleteTCB( pxTCB );
8000a148:	ee fc ff fc 	ld.w	r12,r7[-4]
8000a14c:	f0 1f 00 0b 	mcall	8000a178 <prvCheckTasksWaitingTermination+0x94>
			}
		}
	}
	#endif
}
8000a150:	2f ed       	sub	sp,-8
8000a152:	e3 cd 80 80 	ldm	sp++,r7,pc
8000a156:	00 00       	add	r0,r0
8000a158:	00 00       	add	r0,r0
8000a15a:	0d 24       	ld.uh	r4,r6++
8000a15c:	80 00       	ld.sh	r0,r0[0x0]
8000a15e:	99 a8       	st.w	r12[0x28],r8
8000a160:	00 00       	add	r0,r0
8000a162:	0d 10       	ld.sh	r0,r6++
8000a164:	80 00       	ld.sh	r0,r0[0x0]
8000a166:	99 c4       	st.w	r12[0x30],r4
8000a168:	80 00       	ld.sh	r0,r0[0x0]
8000a16a:	8a 10       	ld.sh	r0,r5[0x2]
8000a16c:	80 00       	ld.sh	r0,r0[0x0]
8000a16e:	88 52       	ld.sh	r2,r4[0xa]
8000a170:	00 00       	add	r0,r0
8000a172:	0d 3c       	ld.ub	r12,r6++
8000a174:	80 00       	ld.sh	r0,r0[0x0]
8000a176:	8a 2c       	ld.sh	r12,r5[0x4]
8000a178:	80 00       	ld.sh	r0,r0[0x0]
8000a17a:	a2 90       	st.b	r1[0x1],r0

8000a17c <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
8000a17c:	eb cd 40 80 	pushm	r7,lr
8000a180:	1a 97       	mov	r7,sp
8000a182:	20 1d       	sub	sp,4
8000a184:	ef 4c ff fc 	st.w	r7[-4],r12
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
8000a188:	49 78       	lddpc	r8,8000a1e4 <prvAddCurrentTaskToDelayedList+0x68>
8000a18a:	70 08       	ld.w	r8,r8[0x0]
8000a18c:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000a190:	91 19       	st.w	r8[0x4],r9

	if( xTimeToWake < xTickCount )
8000a192:	49 68       	lddpc	r8,8000a1e8 <prvAddCurrentTaskToDelayedList+0x6c>
8000a194:	70 08       	ld.w	r8,r8[0x0]
8000a196:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000a19a:	10 39       	cp.w	r9,r8
8000a19c:	c0 c2       	brcc	8000a1b4 <prvAddCurrentTaskToDelayedList+0x38>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
8000a19e:	49 28       	lddpc	r8,8000a1e4 <prvAddCurrentTaskToDelayedList+0x68>
8000a1a0:	70 08       	ld.w	r8,r8[0x0]
8000a1a2:	f0 c9 ff fc 	sub	r9,r8,-4
8000a1a6:	49 28       	lddpc	r8,8000a1ec <prvAddCurrentTaskToDelayedList+0x70>
8000a1a8:	70 08       	ld.w	r8,r8[0x0]
8000a1aa:	12 9b       	mov	r11,r9
8000a1ac:	10 9c       	mov	r12,r8
8000a1ae:	f0 1f 00 11 	mcall	8000a1f0 <prvAddCurrentTaskToDelayedList+0x74>
8000a1b2:	c1 58       	rjmp	8000a1dc <prvAddCurrentTaskToDelayedList+0x60>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
8000a1b4:	48 c8       	lddpc	r8,8000a1e4 <prvAddCurrentTaskToDelayedList+0x68>
8000a1b6:	70 08       	ld.w	r8,r8[0x0]
8000a1b8:	f0 c9 ff fc 	sub	r9,r8,-4
8000a1bc:	48 e8       	lddpc	r8,8000a1f4 <prvAddCurrentTaskToDelayedList+0x78>
8000a1be:	70 08       	ld.w	r8,r8[0x0]
8000a1c0:	12 9b       	mov	r11,r9
8000a1c2:	10 9c       	mov	r12,r8
8000a1c4:	f0 1f 00 0b 	mcall	8000a1f0 <prvAddCurrentTaskToDelayedList+0x74>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
8000a1c8:	48 c8       	lddpc	r8,8000a1f8 <prvAddCurrentTaskToDelayedList+0x7c>
8000a1ca:	70 08       	ld.w	r8,r8[0x0]
8000a1cc:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000a1d0:	10 39       	cp.w	r9,r8
8000a1d2:	c0 52       	brcc	8000a1dc <prvAddCurrentTaskToDelayedList+0x60>
		{
			xNextTaskUnblockTime = xTimeToWake;
8000a1d4:	48 98       	lddpc	r8,8000a1f8 <prvAddCurrentTaskToDelayedList+0x7c>
8000a1d6:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000a1da:	91 09       	st.w	r8[0x0],r9
		}
	}
}
8000a1dc:	2f fd       	sub	sp,-4
8000a1de:	e3 cd 80 80 	ldm	sp++,r7,pc
8000a1e2:	00 00       	add	r0,r0
8000a1e4:	00 00       	add	r0,r0
8000a1e6:	0c 28       	rsub	r8,r6
8000a1e8:	00 00       	add	r0,r0
8000a1ea:	0d 40       	ld.w	r0,--r6
8000a1ec:	00 00       	add	r0,r0
8000a1ee:	0c f8       	st.b	--r6,r8
8000a1f0:	80 00       	ld.sh	r0,r0[0x0]
8000a1f2:	87 b0       	st.w	r3[0x2c],r0
8000a1f4:	00 00       	add	r0,r0
8000a1f6:	0c f4       	st.b	--r6,r4
8000a1f8:	00 00       	add	r0,r0
8000a1fa:	05 4c       	ld.w	r12,--r2

8000a1fc <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer )
{
8000a1fc:	eb cd 40 80 	pushm	r7,lr
8000a200:	1a 97       	mov	r7,sp
8000a202:	20 3d       	sub	sp,12
8000a204:	18 98       	mov	r8,r12
8000a206:	ef 4b ff f4 	st.w	r7[-12],r11
8000a20a:	ef 58 ff f8 	st.h	r7[-8],r8
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
8000a20e:	34 8c       	mov	r12,72
8000a210:	f0 1f 00 1d 	mcall	8000a284 <prvAllocateTCBAndStack+0x88>
8000a214:	18 98       	mov	r8,r12
8000a216:	ef 48 ff fc 	st.w	r7[-4],r8

	if( pxNewTCB != NULL )
8000a21a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000a21e:	58 08       	cp.w	r8,0
8000a220:	c2 c0       	breq	8000a278 <prvAllocateTCBAndStack+0x7c>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
8000a222:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000a226:	58 08       	cp.w	r8,0
8000a228:	c0 91       	brne	8000a23a <prvAllocateTCBAndStack+0x3e>
8000a22a:	ef 18 ff f8 	ld.uh	r8,r7[-8]
8000a22e:	a3 68       	lsl	r8,0x2
8000a230:	10 9c       	mov	r12,r8
8000a232:	f0 1f 00 15 	mcall	8000a284 <prvAllocateTCBAndStack+0x88>
8000a236:	18 98       	mov	r8,r12
8000a238:	c0 38       	rjmp	8000a23e <prvAllocateTCBAndStack+0x42>
8000a23a:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000a23e:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000a242:	93 c8       	st.w	r9[0x30],r8

		if( pxNewTCB->pxStack == NULL )
8000a244:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000a248:	70 c8       	ld.w	r8,r8[0x30]
8000a24a:	58 08       	cp.w	r8,0
8000a24c:	c0 91       	brne	8000a25e <prvAllocateTCBAndStack+0x62>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
8000a24e:	ee fc ff fc 	ld.w	r12,r7[-4]
8000a252:	f0 1f 00 0e 	mcall	8000a288 <prvAllocateTCBAndStack+0x8c>
			pxNewTCB = NULL;
8000a256:	30 08       	mov	r8,0
8000a258:	ef 48 ff fc 	st.w	r7[-4],r8
8000a25c:	c0 e8       	rjmp	8000a278 <prvAllocateTCBAndStack+0x7c>
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
8000a25e:	ef 18 ff f8 	ld.uh	r8,r7[-8]
8000a262:	f0 09 15 02 	lsl	r9,r8,0x2
8000a266:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000a26a:	70 c8       	ld.w	r8,r8[0x30]
8000a26c:	12 9a       	mov	r10,r9
8000a26e:	e0 6b 00 a5 	mov	r11,165
8000a272:	10 9c       	mov	r12,r8
8000a274:	f0 1f 00 06 	mcall	8000a28c <prvAllocateTCBAndStack+0x90>
		}
	}

	return pxNewTCB;
8000a278:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
8000a27c:	10 9c       	mov	r12,r8
8000a27e:	2f dd       	sub	sp,-12
8000a280:	e3 cd 80 80 	ldm	sp++,r7,pc
8000a284:	80 00       	ld.sh	r0,r0[0x0]
8000a286:	8d b8       	st.w	r6[0x2c],r8
8000a288:	80 00       	ld.sh	r0,r0[0x0]
8000a28a:	8d f4       	st.w	r6[0x3c],r4
8000a28c:	80 00       	ld.sh	r0,r0[0x0]
8000a28e:	b6 aa       	st.b	r11[0x2],r10

8000a290 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_vTaskDelete == 1 ) || ( INCLUDE_vTaskCleanUpResources == 1 ) )

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
8000a290:	eb cd 40 80 	pushm	r7,lr
8000a294:	1a 97       	mov	r7,sp
8000a296:	20 1d       	sub	sp,4
8000a298:	ef 4c ff fc 	st.w	r7[-4],r12
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
8000a29c:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000a2a0:	70 c8       	ld.w	r8,r8[0x30]
8000a2a2:	10 9c       	mov	r12,r8
8000a2a4:	f0 1f 00 05 	mcall	8000a2b8 <prvDeleteTCB+0x28>
		vPortFree( pxTCB );
8000a2a8:	ee fc ff fc 	ld.w	r12,r7[-4]
8000a2ac:	f0 1f 00 03 	mcall	8000a2b8 <prvDeleteTCB+0x28>
	}
8000a2b0:	2f fd       	sub	sp,-4
8000a2b2:	e3 cd 80 80 	ldm	sp++,r7,pc
8000a2b6:	00 00       	add	r0,r0
8000a2b8:	80 00       	ld.sh	r0,r0[0x0]
8000a2ba:	8d f4       	st.w	r6[0x3c],r4

8000a2bc <xTaskGetCurrentTaskHandle>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )

	xTaskHandle xTaskGetCurrentTaskHandle( void )
	{
8000a2bc:	eb cd 40 80 	pushm	r7,lr
8000a2c0:	1a 97       	mov	r7,sp
8000a2c2:	20 1d       	sub	sp,4
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
8000a2c4:	48 58       	lddpc	r8,8000a2d8 <xTaskGetCurrentTaskHandle+0x1c>
8000a2c6:	70 08       	ld.w	r8,r8[0x0]
8000a2c8:	ef 48 ff fc 	st.w	r7[-4],r8

		return xReturn;
8000a2cc:	ee f8 ff fc 	ld.w	r8,r7[-4]
	}
8000a2d0:	10 9c       	mov	r12,r8
8000a2d2:	2f fd       	sub	sp,-4
8000a2d4:	e3 cd 80 80 	ldm	sp++,r7,pc
8000a2d8:	00 00       	add	r0,r0
8000a2da:	0c 28       	rsub	r8,r6

8000a2dc <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
8000a2dc:	eb cd 40 80 	pushm	r7,lr
8000a2e0:	1a 97       	mov	r7,sp
8000a2e2:	20 2d       	sub	sp,8
8000a2e4:	ef 4c ff f8 	st.w	r7[-8],r12
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
8000a2e8:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000a2ec:	ef 48 ff fc 	st.w	r7[-4],r8

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
8000a2f0:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000a2f4:	70 b9       	ld.w	r9,r8[0x2c]
8000a2f6:	4a a8       	lddpc	r8,8000a39c <vTaskPriorityInherit+0xc0>
8000a2f8:	70 08       	ld.w	r8,r8[0x0]
8000a2fa:	70 b8       	ld.w	r8,r8[0x2c]
8000a2fc:	10 39       	cp.w	r9,r8
8000a2fe:	c4 c2       	brcc	8000a396 <vTaskPriorityInherit+0xba>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
8000a300:	4a 78       	lddpc	r8,8000a39c <vTaskPriorityInherit+0xc0>
8000a302:	70 08       	ld.w	r8,r8[0x0]
8000a304:	70 b8       	ld.w	r8,r8[0x2c]
8000a306:	f0 09 11 08 	rsub	r9,r8,8
8000a30a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000a30e:	91 69       	st.w	r8[0x18],r9

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
8000a310:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000a314:	70 5a       	ld.w	r10,r8[0x14]
8000a316:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000a31a:	70 b9       	ld.w	r9,r8[0x2c]
8000a31c:	12 98       	mov	r8,r9
8000a31e:	a3 68       	lsl	r8,0x2
8000a320:	12 08       	add	r8,r9
8000a322:	a3 68       	lsl	r8,0x2
8000a324:	10 99       	mov	r9,r8
8000a326:	49 f8       	lddpc	r8,8000a3a0 <vTaskPriorityInherit+0xc4>
8000a328:	f2 08 00 08 	add	r8,r9,r8
8000a32c:	10 3a       	cp.w	r10,r8
8000a32e:	c2 e1       	brne	8000a38a <vTaskPriorityInherit+0xae>
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
8000a330:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000a334:	2f c8       	sub	r8,-4
8000a336:	10 9c       	mov	r12,r8
8000a338:	f0 1f 00 1b 	mcall	8000a3a4 <vTaskPriorityInherit+0xc8>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
8000a33c:	49 88       	lddpc	r8,8000a39c <vTaskPriorityInherit+0xc0>
8000a33e:	70 08       	ld.w	r8,r8[0x0]
8000a340:	70 b9       	ld.w	r9,r8[0x2c]
8000a342:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000a346:	91 b9       	st.w	r8[0x2c],r9
				prvAddTaskToReadyQueue( pxTCB );
8000a348:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000a34c:	70 b9       	ld.w	r9,r8[0x2c]
8000a34e:	49 78       	lddpc	r8,8000a3a8 <vTaskPriorityInherit+0xcc>
8000a350:	70 08       	ld.w	r8,r8[0x0]
8000a352:	10 39       	cp.w	r9,r8
8000a354:	e0 88 00 07 	brls	8000a362 <vTaskPriorityInherit+0x86>
8000a358:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000a35c:	70 b9       	ld.w	r9,r8[0x2c]
8000a35e:	49 38       	lddpc	r8,8000a3a8 <vTaskPriorityInherit+0xcc>
8000a360:	91 09       	st.w	r8[0x0],r9
8000a362:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000a366:	f0 ca ff fc 	sub	r10,r8,-4
8000a36a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000a36e:	70 b9       	ld.w	r9,r8[0x2c]
8000a370:	12 98       	mov	r8,r9
8000a372:	a3 68       	lsl	r8,0x2
8000a374:	12 08       	add	r8,r9
8000a376:	a3 68       	lsl	r8,0x2
8000a378:	10 99       	mov	r9,r8
8000a37a:	48 a8       	lddpc	r8,8000a3a0 <vTaskPriorityInherit+0xc4>
8000a37c:	f2 08 00 08 	add	r8,r9,r8
8000a380:	14 9b       	mov	r11,r10
8000a382:	10 9c       	mov	r12,r8
8000a384:	f0 1f 00 0a 	mcall	8000a3ac <vTaskPriorityInherit+0xd0>
8000a388:	c0 78       	rjmp	8000a396 <vTaskPriorityInherit+0xba>
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
8000a38a:	48 58       	lddpc	r8,8000a39c <vTaskPriorityInherit+0xc0>
8000a38c:	70 08       	ld.w	r8,r8[0x0]
8000a38e:	70 b9       	ld.w	r9,r8[0x2c]
8000a390:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000a394:	91 b9       	st.w	r8[0x2c],r9
			}
		}
	}
8000a396:	2f ed       	sub	sp,-8
8000a398:	e3 cd 80 80 	ldm	sp++,r7,pc
8000a39c:	00 00       	add	r0,r0
8000a39e:	0c 28       	rsub	r8,r6
8000a3a0:	00 00       	add	r0,r0
8000a3a2:	0c 2c       	rsub	r12,r6
8000a3a4:	80 00       	ld.sh	r0,r0[0x0]
8000a3a6:	88 52       	ld.sh	r2,r4[0xa]
8000a3a8:	00 00       	add	r0,r0
8000a3aa:	0d 48       	ld.w	r8,--r6
8000a3ac:	80 00       	ld.sh	r0,r0[0x0]
8000a3ae:	87 3e       	st.w	r3[0xc],lr

8000a3b0 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
8000a3b0:	eb cd 40 80 	pushm	r7,lr
8000a3b4:	1a 97       	mov	r7,sp
8000a3b6:	20 2d       	sub	sp,8
8000a3b8:	ef 4c ff f8 	st.w	r7[-8],r12
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
8000a3bc:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000a3c0:	ef 48 ff fc 	st.w	r7[-4],r8

		if( pxMutexHolder != NULL )
8000a3c4:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000a3c8:	58 08       	cp.w	r8,0
8000a3ca:	c3 d0       	breq	8000a444 <vTaskPriorityDisinherit+0x94>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
8000a3cc:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000a3d0:	70 b9       	ld.w	r9,r8[0x2c]
8000a3d2:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000a3d6:	71 18       	ld.w	r8,r8[0x44]
8000a3d8:	10 39       	cp.w	r9,r8
8000a3da:	c3 50       	breq	8000a444 <vTaskPriorityDisinherit+0x94>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
8000a3dc:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000a3e0:	2f c8       	sub	r8,-4
8000a3e2:	10 9c       	mov	r12,r8
8000a3e4:	f0 1f 00 1a 	mcall	8000a44c <vTaskPriorityDisinherit+0x9c>

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
8000a3e8:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000a3ec:	71 19       	ld.w	r9,r8[0x44]
8000a3ee:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000a3f2:	91 b9       	st.w	r8[0x2c],r9
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
8000a3f4:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000a3f8:	70 b8       	ld.w	r8,r8[0x2c]
8000a3fa:	f0 09 11 08 	rsub	r9,r8,8
8000a3fe:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000a402:	91 69       	st.w	r8[0x18],r9
				prvAddTaskToReadyQueue( pxTCB );
8000a404:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000a408:	70 b9       	ld.w	r9,r8[0x2c]
8000a40a:	49 28       	lddpc	r8,8000a450 <vTaskPriorityDisinherit+0xa0>
8000a40c:	70 08       	ld.w	r8,r8[0x0]
8000a40e:	10 39       	cp.w	r9,r8
8000a410:	e0 88 00 07 	brls	8000a41e <vTaskPriorityDisinherit+0x6e>
8000a414:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000a418:	70 b9       	ld.w	r9,r8[0x2c]
8000a41a:	48 e8       	lddpc	r8,8000a450 <vTaskPriorityDisinherit+0xa0>
8000a41c:	91 09       	st.w	r8[0x0],r9
8000a41e:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000a422:	f0 ca ff fc 	sub	r10,r8,-4
8000a426:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000a42a:	70 b9       	ld.w	r9,r8[0x2c]
8000a42c:	12 98       	mov	r8,r9
8000a42e:	a3 68       	lsl	r8,0x2
8000a430:	12 08       	add	r8,r9
8000a432:	a3 68       	lsl	r8,0x2
8000a434:	10 99       	mov	r9,r8
8000a436:	48 88       	lddpc	r8,8000a454 <vTaskPriorityDisinherit+0xa4>
8000a438:	f2 08 00 08 	add	r8,r9,r8
8000a43c:	14 9b       	mov	r11,r10
8000a43e:	10 9c       	mov	r12,r8
8000a440:	f0 1f 00 06 	mcall	8000a458 <vTaskPriorityDisinherit+0xa8>
			}
		}
	}
8000a444:	2f ed       	sub	sp,-8
8000a446:	e3 cd 80 80 	ldm	sp++,r7,pc
8000a44a:	00 00       	add	r0,r0
8000a44c:	80 00       	ld.sh	r0,r0[0x0]
8000a44e:	88 52       	ld.sh	r2,r4[0xa]
8000a450:	00 00       	add	r0,r0
8000a452:	0d 48       	ld.w	r8,--r6
8000a454:	00 00       	add	r0,r0
8000a456:	0c 2c       	rsub	r12,r6
8000a458:	80 00       	ld.sh	r0,r0[0x0]
8000a45a:	87 3e       	st.w	r3[0xc],lr
8000a45c:	4c 4f       	lddpc	pc,8000a56c <PrintDec+0xa0>
8000a45e:	47 00       	lddsp	r0,sp[0x1c0]
8000a460:	49 20       	lddpc	r0,8000a4a8 <PrintChar+0x10>
8000a462:	6e 65       	ld.w	r5,r7[0x18]
8000a464:	65 64       	ld.w	r4,r2[0x58]
8000a466:	20 66       	sub	r6,6
8000a468:	6c 6f       	ld.w	pc,r6[0x18]
8000a46a:	61 74       	ld.w	r4,r0[0x5c]
8000a46c:	2e 00       	sub	r0,-32
8000a46e:	00 00       	add	r0,r0
8000a470:	49 20       	lddpc	r0,8000a4b8 <PrintChar+0x20>
8000a472:	6e 65       	ld.w	r5,r7[0x18]
8000a474:	65 64       	ld.w	r4,r2[0x58]
8000a476:	20 72       	sub	r2,7
8000a478:	65 6c       	ld.w	r12,r2[0x58]
8000a47a:	61 78       	ld.w	r8,r0[0x5c]
8000a47c:	2e 00       	sub	r0,-32
8000a47e:	00 00       	add	r0,r0
8000a480:	25 73       	sub	r3,87
8000a482:	25 73       	sub	r3,87
8000a484:	00 00       	add	r0,r0
8000a486:	00 00       	add	r0,r0
8000a488:	25 73       	sub	r3,87
8000a48a:	25 63       	sub	r3,86
8000a48c:	00 00       	add	r0,r0
8000a48e:	00 00       	add	r0,r0
8000a490:	25 73       	sub	r3,87
8000a492:	0d 0a       	ld.w	r10,r6++
8000a494:	00 00       	add	r0,r0
	...

8000a498 <PrintChar>:

	
static void task_log(void * pvParameters);

char *  PrintChar(char c, char * str)
{
8000a498:	eb cd 40 80 	pushm	r7,lr
8000a49c:	1a 97       	mov	r7,sp
8000a49e:	20 2d       	sub	sp,8
8000a4a0:	18 98       	mov	r8,r12
8000a4a2:	ef 4b ff f8 	st.w	r7[-8],r11
8000a4a6:	ef 68 ff fc 	st.b	r7[-4],r8
	*str++ = c;
8000a4aa:	ee f9 ff f8 	ld.w	r9,r7[-8]
8000a4ae:	ef 38 ff fc 	ld.ub	r8,r7[-4]
8000a4b2:	b2 88       	st.b	r9[0x0],r8
8000a4b4:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000a4b8:	2f f8       	sub	r8,-1
8000a4ba:	ef 48 ff f8 	st.w	r7[-8],r8
	return str;
8000a4be:	ee f8 ff f8 	ld.w	r8,r7[-8]
}
8000a4c2:	10 9c       	mov	r12,r8
8000a4c4:	2f ed       	sub	sp,-8
8000a4c6:	e3 cd 80 80 	ldm	sp++,r7,pc
8000a4ca:	d7 03       	nop

8000a4cc <PrintDec>:

char * PrintDec(int i, char len, char * str)
{
8000a4cc:	eb cd 40 80 	pushm	r7,lr
8000a4d0:	1a 97       	mov	r7,sp
8000a4d2:	20 cd       	sub	sp,48
8000a4d4:	ef 4c ff d8 	st.w	r7[-40],r12
8000a4d8:	16 98       	mov	r8,r11
8000a4da:	ef 4a ff d0 	st.w	r7[-48],r10
8000a4de:	ef 68 ff d4 	st.b	r7[-44],r8
	char * p = str;
8000a4e2:	ee f8 ff d0 	ld.w	r8,r7[-48]
8000a4e6:	ef 48 ff e8 	st.w	r7[-24],r8
	
	int sign = i>=0 ? 0 : 1;
8000a4ea:	ee f8 ff d8 	ld.w	r8,r7[-40]
8000a4ee:	bf 98       	lsr	r8,0x1f
8000a4f0:	ef 48 ff ec 	st.w	r7[-20],r8
	char s[10];
	memset(s, 0 , 10);
8000a4f4:	ee c8 00 24 	sub	r8,r7,36
8000a4f8:	30 aa       	mov	r10,10
8000a4fa:	30 0b       	mov	r11,0
8000a4fc:	10 9c       	mov	r12,r8
8000a4fe:	f0 1f 00 61 	mcall	8000a680 <PrintDec+0x1b4>
	int cnt=0;
8000a502:	30 08       	mov	r8,0
8000a504:	ef 48 ff f0 	st.w	r7[-16],r8
	if(sign)
8000a508:	ee f8 ff ec 	ld.w	r8,r7[-20]
8000a50c:	58 08       	cp.w	r8,0
8000a50e:	c0 f0       	breq	8000a52c <PrintDec+0x60>
	{
		*p++ = '-';
8000a510:	ee f9 ff e8 	ld.w	r9,r7[-24]
8000a514:	32 d8       	mov	r8,45
8000a516:	b2 88       	st.b	r9[0x0],r8
8000a518:	ee f8 ff e8 	ld.w	r8,r7[-24]
8000a51c:	2f f8       	sub	r8,-1
8000a51e:	ef 48 ff e8 	st.w	r7[-24],r8
		i = -i;
8000a522:	ee f8 ff d8 	ld.w	r8,r7[-40]
8000a526:	5c 38       	neg	r8
8000a528:	ef 48 ff d8 	st.w	r7[-40],r8
	}
	
	if(i == 0 )s[cnt++] = '0';
8000a52c:	ee f8 ff d8 	ld.w	r8,r7[-40]
8000a530:	58 08       	cp.w	r8,0
8000a532:	c0 d1       	brne	8000a54c <PrintDec+0x80>
8000a534:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000a538:	ee 08 00 09 	add	r9,r7,r8
8000a53c:	33 08       	mov	r8,48
8000a53e:	f3 68 ff dc 	st.b	r9[-36],r8
8000a542:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000a546:	2f f8       	sub	r8,-1
8000a548:	ef 48 ff f0 	st.w	r7[-16],r8
	
	int ten = i%10;
8000a54c:	ee f9 ff d8 	ld.w	r9,r7[-40]
8000a550:	e0 68 66 67 	mov	r8,26215
8000a554:	ea 18 66 66 	orh	r8,0x6666
8000a558:	f2 08 04 4a 	muls.d	r10,r9,r8
8000a55c:	f6 0a 14 02 	asr	r10,r11,0x2
8000a560:	f2 08 14 1f 	asr	r8,r9,0x1f
8000a564:	10 1a       	sub	r10,r8
8000a566:	14 98       	mov	r8,r10
8000a568:	a3 68       	lsl	r8,0x2
8000a56a:	14 08       	add	r8,r10
8000a56c:	a1 78       	lsl	r8,0x1
8000a56e:	f2 08 01 08 	sub	r8,r9,r8
8000a572:	ef 48 ff f4 	st.w	r7[-12],r8
	while(i)
8000a576:	c3 58       	rjmp	8000a5e0 <PrintDec+0x114>
	{
		s[cnt] = ten+'0';
8000a578:	ee f9 ff f0 	ld.w	r9,r7[-16]
8000a57c:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000a580:	5c 58       	castu.b	r8
8000a582:	2d 08       	sub	r8,-48
8000a584:	5c 58       	castu.b	r8
8000a586:	ee 09 00 09 	add	r9,r7,r9
8000a58a:	f3 68 ff dc 	st.b	r9[-36],r8
		cnt++;
8000a58e:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000a592:	2f f8       	sub	r8,-1
8000a594:	ef 48 ff f0 	st.w	r7[-16],r8
		i /= 10;
8000a598:	ee fa ff d8 	ld.w	r10,r7[-40]
8000a59c:	e0 68 66 67 	mov	r8,26215
8000a5a0:	ea 18 66 66 	orh	r8,0x6666
8000a5a4:	f4 08 04 48 	muls.d	r8,r10,r8
8000a5a8:	a3 49       	asr	r9,0x2
8000a5aa:	f4 08 14 1f 	asr	r8,r10,0x1f
8000a5ae:	f2 08 01 08 	sub	r8,r9,r8
8000a5b2:	ef 48 ff d8 	st.w	r7[-40],r8
		ten = i%10;
8000a5b6:	ee f9 ff d8 	ld.w	r9,r7[-40]
8000a5ba:	e0 68 66 67 	mov	r8,26215
8000a5be:	ea 18 66 66 	orh	r8,0x6666
8000a5c2:	f2 08 04 4a 	muls.d	r10,r9,r8
8000a5c6:	f6 0a 14 02 	asr	r10,r11,0x2
8000a5ca:	f2 08 14 1f 	asr	r8,r9,0x1f
8000a5ce:	10 1a       	sub	r10,r8
8000a5d0:	14 98       	mov	r8,r10
8000a5d2:	a3 68       	lsl	r8,0x2
8000a5d4:	14 08       	add	r8,r10
8000a5d6:	a1 78       	lsl	r8,0x1
8000a5d8:	f2 08 01 08 	sub	r8,r9,r8
8000a5dc:	ef 48 ff f4 	st.w	r7[-12],r8
	}
	
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
8000a5e0:	ee f8 ff d8 	ld.w	r8,r7[-40]
8000a5e4:	58 08       	cp.w	r8,0
8000a5e6:	cc 91       	brne	8000a578 <PrintDec+0xac>
		cnt++;
		i /= 10;
		ten = i%10;
	}
	
	if(len - cnt > 0 )
8000a5e8:	ef 39 ff d4 	ld.ub	r9,r7[-44]
8000a5ec:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000a5f0:	f2 08 01 08 	sub	r8,r9,r8
8000a5f4:	58 08       	cp.w	r8,0
8000a5f6:	e0 8a 00 3a 	brle	8000a66a <PrintDec+0x19e>
	{
		char num = len - cnt;
8000a5fa:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000a5fe:	5c 58       	castu.b	r8
8000a600:	ef 39 ff d4 	ld.ub	r9,r7[-44]
8000a604:	10 19       	sub	r9,r8
8000a606:	ef 69 ff fb 	st.b	r7[-5],r9
		for(int i = 0; i < num; i++)
8000a60a:	30 08       	mov	r8,0
8000a60c:	ef 48 ff fc 	st.w	r7[-4],r8
8000a610:	c1 28       	rjmp	8000a634 <PrintDec+0x168>
		{
			s[cnt++] = '0';
8000a612:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000a616:	ee 08 00 09 	add	r9,r7,r8
8000a61a:	33 08       	mov	r8,48
8000a61c:	f3 68 ff dc 	st.b	r9[-36],r8
8000a620:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000a624:	2f f8       	sub	r8,-1
8000a626:	ef 48 ff f0 	st.w	r7[-16],r8
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
8000a62a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000a62e:	2f f8       	sub	r8,-1
8000a630:	ef 48 ff fc 	st.w	r7[-4],r8
8000a634:	ef 39 ff fb 	ld.ub	r9,r7[-5]
8000a638:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000a63c:	10 39       	cp.w	r9,r8
8000a63e:	fe 99 ff ea 	brgt	8000a612 <PrintDec+0x146>
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
8000a642:	c1 48       	rjmp	8000a66a <PrintDec+0x19e>
	*p++ = s[--cnt];
8000a644:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000a648:	20 18       	sub	r8,1
8000a64a:	ef 48 ff f0 	st.w	r7[-16],r8
8000a64e:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000a652:	ee 08 00 08 	add	r8,r7,r8
8000a656:	f1 38 ff dc 	ld.ub	r8,r8[-36]
8000a65a:	ee f9 ff e8 	ld.w	r9,r7[-24]
8000a65e:	b2 88       	st.b	r9[0x0],r8
8000a660:	ee f8 ff e8 	ld.w	r8,r7[-24]
8000a664:	2f f8       	sub	r8,-1
8000a666:	ef 48 ff e8 	st.w	r7[-24],r8
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
8000a66a:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000a66e:	58 08       	cp.w	r8,0
8000a670:	fe 99 ff ea 	brgt	8000a644 <PrintDec+0x178>
	*p++ = s[--cnt];
	
	return str;
8000a674:	ee f8 ff d0 	ld.w	r8,r7[-48]
}
8000a678:	10 9c       	mov	r12,r8
8000a67a:	2f 4d       	sub	sp,-48
8000a67c:	e3 cd 80 80 	ldm	sp++,r7,pc
8000a680:	80 00       	ld.sh	r0,r0[0x0]
8000a682:	b6 aa       	st.b	r11[0x2],r10

8000a684 <PrintHex>:

char * PrintHex(int i,char len, char * str)
{
8000a684:	eb cd 40 80 	pushm	r7,lr
8000a688:	1a 97       	mov	r7,sp
8000a68a:	20 ad       	sub	sp,40
8000a68c:	ef 4c ff e0 	st.w	r7[-32],r12
8000a690:	16 98       	mov	r8,r11
8000a692:	ef 4a ff d8 	st.w	r7[-40],r10
8000a696:	ef 68 ff dc 	st.b	r7[-36],r8
	char * p = str;
8000a69a:	ee f8 ff d8 	ld.w	r8,r7[-40]
8000a69e:	ef 48 ff f0 	st.w	r7[-16],r8
	char s[12];
	memset(s, 0 , 12);
8000a6a2:	ee c8 00 1c 	sub	r8,r7,28
8000a6a6:	30 ca       	mov	r10,12
8000a6a8:	30 0b       	mov	r11,0
8000a6aa:	10 9c       	mov	r12,r8
8000a6ac:	f0 1f 00 53 	mcall	8000a7f8 <PrintHex+0x174>
	int cnt=0;
8000a6b0:	30 08       	mov	r8,0
8000a6b2:	ef 48 ff f4 	st.w	r7[-12],r8
	
	if(i)
8000a6b6:	ee f8 ff e0 	ld.w	r8,r7[-32]
8000a6ba:	58 08       	cp.w	r8,0
8000a6bc:	c2 d0       	breq	8000a716 <PrintHex+0x92>
	while(i)
8000a6be:	c2 78       	rjmp	8000a70c <PrintHex+0x88>
	{
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
8000a6c0:	ee f9 ff f4 	ld.w	r9,r7[-12]
8000a6c4:	ee f8 ff e0 	ld.w	r8,r7[-32]
8000a6c8:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
8000a6cc:	58 98       	cp.w	r8,9
8000a6ce:	e0 8a 00 0a 	brle	8000a6e2 <PrintHex+0x5e>
8000a6d2:	ee f8 ff e0 	ld.w	r8,r7[-32]
8000a6d6:	5c 58       	castu.b	r8
8000a6d8:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
8000a6dc:	2c 98       	sub	r8,-55
8000a6de:	5c 58       	castu.b	r8
8000a6e0:	c0 88       	rjmp	8000a6f0 <PrintHex+0x6c>
8000a6e2:	ee f8 ff e0 	ld.w	r8,r7[-32]
8000a6e6:	5c 58       	castu.b	r8
8000a6e8:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
8000a6ec:	2d 08       	sub	r8,-48
8000a6ee:	5c 58       	castu.b	r8
8000a6f0:	ee 09 00 09 	add	r9,r7,r9
8000a6f4:	f3 68 ff e4 	st.b	r9[-28],r8
8000a6f8:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000a6fc:	2f f8       	sub	r8,-1
8000a6fe:	ef 48 ff f4 	st.w	r7[-12],r8
		i = (i >> 4 ) & 0x0FFFFFFF;
8000a702:	ee f8 ff e0 	ld.w	r8,r7[-32]
8000a706:	a5 88       	lsr	r8,0x4
8000a708:	ef 48 ff e0 	st.w	r7[-32],r8
	char s[12];
	memset(s, 0 , 12);
	int cnt=0;
	
	if(i)
	while(i)
8000a70c:	ee f8 ff e0 	ld.w	r8,r7[-32]
8000a710:	58 08       	cp.w	r8,0
8000a712:	cd 71       	brne	8000a6c0 <PrintHex+0x3c>
8000a714:	c0 d8       	rjmp	8000a72e <PrintHex+0xaa>
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
		i = (i >> 4 ) & 0x0FFFFFFF;
		//i >>= 4
	}
	else
	s[cnt++] = '0';
8000a716:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000a71a:	ee 08 00 09 	add	r9,r7,r8
8000a71e:	33 08       	mov	r8,48
8000a720:	f3 68 ff e4 	st.b	r9[-28],r8
8000a724:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000a728:	2f f8       	sub	r8,-1
8000a72a:	ef 48 ff f4 	st.w	r7[-12],r8
	
	if(len - cnt > 0 )
8000a72e:	ef 39 ff dc 	ld.ub	r9,r7[-36]
8000a732:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000a736:	f2 08 01 08 	sub	r8,r9,r8
8000a73a:	58 08       	cp.w	r8,0
8000a73c:	e0 8a 00 26 	brle	8000a788 <PrintHex+0x104>
	{
		char num = len - cnt;
8000a740:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000a744:	5c 58       	castu.b	r8
8000a746:	ef 39 ff dc 	ld.ub	r9,r7[-36]
8000a74a:	10 19       	sub	r9,r8
8000a74c:	ef 69 ff fb 	st.b	r7[-5],r9
		for(int i = 0; i < num; i++)
8000a750:	30 08       	mov	r8,0
8000a752:	ef 48 ff fc 	st.w	r7[-4],r8
8000a756:	c1 28       	rjmp	8000a77a <PrintHex+0xf6>
		{
			s[cnt++] = '0';
8000a758:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000a75c:	ee 08 00 09 	add	r9,r7,r8
8000a760:	33 08       	mov	r8,48
8000a762:	f3 68 ff e4 	st.b	r9[-28],r8
8000a766:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000a76a:	2f f8       	sub	r8,-1
8000a76c:	ef 48 ff f4 	st.w	r7[-12],r8
	s[cnt++] = '0';
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
8000a770:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000a774:	2f f8       	sub	r8,-1
8000a776:	ef 48 ff fc 	st.w	r7[-4],r8
8000a77a:	ef 39 ff fb 	ld.ub	r9,r7[-5]
8000a77e:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000a782:	10 39       	cp.w	r9,r8
8000a784:	fe 99 ff ea 	brgt	8000a758 <PrintHex+0xd4>
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
8000a788:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000a78c:	ee 08 00 09 	add	r9,r7,r8
8000a790:	37 88       	mov	r8,120
8000a792:	f3 68 ff e4 	st.b	r9[-28],r8
8000a796:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000a79a:	2f f8       	sub	r8,-1
8000a79c:	ef 48 ff f4 	st.w	r7[-12],r8
	s[cnt++] = '0';
8000a7a0:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000a7a4:	ee 08 00 09 	add	r9,r7,r8
8000a7a8:	33 08       	mov	r8,48
8000a7aa:	f3 68 ff e4 	st.b	r9[-28],r8
8000a7ae:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000a7b2:	2f f8       	sub	r8,-1
8000a7b4:	ef 48 ff f4 	st.w	r7[-12],r8
	
	while(cnt>0)
8000a7b8:	c1 48       	rjmp	8000a7e0 <PrintHex+0x15c>
	*p++ = s[--cnt];
8000a7ba:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000a7be:	20 18       	sub	r8,1
8000a7c0:	ef 48 ff f4 	st.w	r7[-12],r8
8000a7c4:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000a7c8:	ee 08 00 08 	add	r8,r7,r8
8000a7cc:	f1 38 ff e4 	ld.ub	r8,r8[-28]
8000a7d0:	ee f9 ff f0 	ld.w	r9,r7[-16]
8000a7d4:	b2 88       	st.b	r9[0x0],r8
8000a7d6:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000a7da:	2f f8       	sub	r8,-1
8000a7dc:	ef 48 ff f0 	st.w	r7[-16],r8
	}
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
8000a7e0:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000a7e4:	58 08       	cp.w	r8,0
8000a7e6:	fe 99 ff ea 	brgt	8000a7ba <PrintHex+0x136>
	*p++ = s[--cnt];
		
	return str;
8000a7ea:	ee f8 ff d8 	ld.w	r8,r7[-40]
}
8000a7ee:	10 9c       	mov	r12,r8
8000a7f0:	2f 6d       	sub	sp,-40
8000a7f2:	e3 cd 80 80 	ldm	sp++,r7,pc
8000a7f6:	00 00       	add	r0,r0
8000a7f8:	80 00       	ld.sh	r0,r0[0x0]
8000a7fa:	b6 aa       	st.b	r11[0x2],r10

8000a7fc <log_init>:

void log_init(void)
{
8000a7fc:	eb cd 40 80 	pushm	r7,lr
8000a800:	1a 97       	mov	r7,sp
		.stopbits     = USART_1_STOPBIT,
		.channelmode  = USART_NORMAL_CHMODE
	};

	// Assign GPIO to USART.
	gpio_enable_module(USART_GPIO_MAP,
8000a802:	30 2b       	mov	r11,2
8000a804:	49 2c       	lddpc	r12,8000a84c <log_init+0x50>
8000a806:	f0 1f 00 13 	mcall	8000a850 <log_init+0x54>
	sizeof(USART_GPIO_MAP) / sizeof(USART_GPIO_MAP[0]));

	// Initialize USART in RS232 mode.
	usart_init_rs232(EXAMPLE_USART, &USART_OPTIONS, EXAMPLE_TARGET_PBACLK_FREQ_HZ);		
8000a80a:	e0 6a 36 00 	mov	r10,13824
8000a80e:	ea 1a 01 6e 	orh	r10,0x16e
8000a812:	49 1b       	lddpc	r11,8000a854 <log_init+0x58>
8000a814:	fe 7c 18 00 	mov	r12,-59392
8000a818:	f0 1f 00 10 	mcall	8000a858 <log_init+0x5c>
			
	logQueue  = xQueueCreate(50, sizeof(char *));
8000a81c:	30 4b       	mov	r11,4
8000a81e:	33 2c       	mov	r12,50
8000a820:	f0 1f 00 0f 	mcall	8000a85c <log_init+0x60>
8000a824:	18 99       	mov	r9,r12
8000a826:	48 f8       	lddpc	r8,8000a860 <log_init+0x64>
8000a828:	91 09       	st.w	r8[0x0],r9
	
	xTaskCreate(
8000a82a:	48 fb       	lddpc	r11,8000a864 <log_init+0x68>
8000a82c:	30 08       	mov	r8,0
8000a82e:	1a d8       	st.w	--sp,r8
8000a830:	30 08       	mov	r8,0
8000a832:	1a d8       	st.w	--sp,r8
8000a834:	30 08       	mov	r8,0
8000a836:	1a d8       	st.w	--sp,r8
8000a838:	30 28       	mov	r8,2
8000a83a:	30 09       	mov	r9,0
8000a83c:	e0 6a 01 80 	mov	r10,384
8000a840:	48 ac       	lddpc	r12,8000a868 <log_init+0x6c>
8000a842:	f0 1f 00 0b 	mcall	8000a86c <log_init+0x70>
8000a846:	2f dd       	sub	sp,-12
	,  384
	,  NULL
	,  tskLOG_PRIORITY
	,  NULL );
	
}
8000a848:	e3 cd 80 80 	ldm	sp++,r7,pc
8000a84c:	80 01       	ld.sh	r1,r0[0x0]
8000a84e:	15 a8       	ld.ub	r8,r10[0x2]
8000a850:	80 00       	ld.sh	r0,r0[0x0]
8000a852:	ae 6c       	st.h	r7[0xc],r12
8000a854:	80 01       	ld.sh	r1,r0[0x0]
8000a856:	15 b8       	ld.ub	r8,r10[0x3]
8000a858:	80 00       	ld.sh	r0,r0[0x0]
8000a85a:	83 f8       	st.w	r1[0x3c],r8
8000a85c:	80 00       	ld.sh	r0,r0[0x0]
8000a85e:	8e 2c       	ld.sh	r12,r7[0x4]
8000a860:	00 00       	add	r0,r0
8000a862:	53 20       	stdsp	sp[0xc8],r0
8000a864:	80 00       	ld.sh	r0,r0[0x0]
8000a866:	a4 5c       	st.h	r2[0xa],r12
8000a868:	80 00       	ld.sh	r0,r0[0x0]
8000a86a:	ad 4c       	asr	r12,0xc
8000a86c:	80 00       	ld.sh	r0,r0[0x0]
8000a86e:	96 9c       	ld.uh	r12,r11[0x2]

8000a870 <log>:

int log(char * content, ...)
{
8000a870:	eb cd 40 c0 	pushm	r6-r7,lr
8000a874:	1a 97       	mov	r7,sp
8000a876:	fa cd 02 28 	sub	sp,sp,552
8000a87a:	ee c6 ff f4 	sub	r6,r7,-12
8000a87e:	ef 4c fd d8 	st.w	r7[-552],r12
	
	
	char logTmp[MAX_LOG_LINE_SIZE];
	memset(logTmp, '\0', MAX_LOG_LINE_SIZE);	
8000a882:	ee c8 01 1c 	sub	r8,r7,284
8000a886:	e0 6a 01 00 	mov	r10,256
8000a88a:	30 0b       	mov	r11,0
8000a88c:	10 9c       	mov	r12,r8
8000a88e:	f0 1f 00 84 	mcall	8000aa9c <log+0x22c>
	
	int len = 0 ;
8000a892:	30 08       	mov	r8,0
8000a894:	ef 48 ff e4 	st.w	r7[-28],r8
	

	va_list arg_ptr;
	char* str = content;
8000a898:	ee f8 fd d8 	ld.w	r8,r7[-552]
8000a89c:	ef 48 ff e8 	st.w	r7[-24],r8
	int x;
	char y;
	float f;
	//char* s;
	char length= 0;
8000a8a0:	30 08       	mov	r8,0
8000a8a2:	ef 68 ff fb 	st.b	r7[-5],r8
		
	va_start(arg_ptr, content);
8000a8a6:	ec c8 00 00 	sub	r8,r6,0
8000a8aa:	ef 48 fe e0 	st.w	r7[-288],r8
		//str += 4;
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
8000a8ae:	ee c8 02 24 	sub	r8,r7,548
8000a8b2:	ef 48 ff fc 	st.w	r7[-4],r8
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
8000a8b6:	e0 6a 01 00 	mov	r10,256
8000a8ba:	30 0b       	mov	r11,0
8000a8bc:	ee fc ff fc 	ld.w	r12,r7[-4]
8000a8c0:	f0 1f 00 77 	mcall	8000aa9c <log+0x22c>
			
					if(*str == '%')
8000a8c4:	ee f8 ff e8 	ld.w	r8,r7[-24]
8000a8c8:	11 89       	ld.ub	r9,r8[0x0]
8000a8ca:	32 58       	mov	r8,37
8000a8cc:	f0 09 18 00 	cp.b	r9,r8
8000a8d0:	e0 81 00 9a 	brne	8000aa04 <log+0x194>
					{
						static char lench = 0;
						lench =*(str + 1);
8000a8d4:	ee f8 ff e8 	ld.w	r8,r7[-24]
8000a8d8:	2f f8       	sub	r8,-1
8000a8da:	11 88       	ld.ub	r8,r8[0x0]
8000a8dc:	4f 19       	lddpc	r9,8000aaa0 <log+0x230>
8000a8de:	b2 88       	st.b	r9[0x0],r8
						if((lench >= '0') &&  (lench <= '9'))
8000a8e0:	4f 08       	lddpc	r8,8000aaa0 <log+0x230>
8000a8e2:	11 89       	ld.ub	r9,r8[0x0]
8000a8e4:	32 f8       	mov	r8,47
8000a8e6:	f0 09 18 00 	cp.b	r9,r8
8000a8ea:	e0 88 00 14 	brls	8000a912 <log+0xa2>
8000a8ee:	4e d8       	lddpc	r8,8000aaa0 <log+0x230>
8000a8f0:	11 89       	ld.ub	r9,r8[0x0]
8000a8f2:	33 98       	mov	r8,57
8000a8f4:	f0 09 18 00 	cp.b	r9,r8
8000a8f8:	e0 8b 00 0d 	brhi	8000a912 <log+0xa2>
						{
							len = *(++str) - '0';
8000a8fc:	ee f8 ff e8 	ld.w	r8,r7[-24]
8000a900:	2f f8       	sub	r8,-1
8000a902:	ef 48 ff e8 	st.w	r7[-24],r8
8000a906:	ee f8 ff e8 	ld.w	r8,r7[-24]
8000a90a:	11 88       	ld.ub	r8,r8[0x0]
8000a90c:	23 08       	sub	r8,48
8000a90e:	ef 48 ff e4 	st.w	r7[-28],r8
						}
						
						str++;
8000a912:	ee f8 ff e8 	ld.w	r8,r7[-24]
8000a916:	2f f8       	sub	r8,-1
8000a918:	ef 48 ff e8 	st.w	r7[-24],r8
						
						switch(*(str))
8000a91c:	ee f8 ff e8 	ld.w	r8,r7[-24]
8000a920:	11 88       	ld.ub	r8,r8[0x0]
8000a922:	22 58       	sub	r8,37
8000a924:	e0 48 00 53 	cp.w	r8,83
8000a928:	e0 8b 00 55 	brhi	8000a9d2 <log+0x162>
8000a92c:	4d e9       	lddpc	r9,8000aaa4 <log+0x234>
8000a92e:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
						{
							case('i'):
							case('I'):
							case('d'):
							case('D'):
							x = va_arg(arg_ptr,int);
8000a932:	ee f8 fe e0 	ld.w	r8,r7[-288]
8000a936:	f0 c9 ff fc 	sub	r9,r8,-4
8000a93a:	ef 49 fe e0 	st.w	r7[-288],r9
8000a93e:	70 08       	ld.w	r8,r8[0x0]
8000a940:	ef 48 ff ec 	st.w	r7[-20],r8
							strTmp = PrintDec(x, len, strTmp);
8000a944:	ee f8 ff e4 	ld.w	r8,r7[-28]
8000a948:	5c 58       	castu.b	r8
8000a94a:	ee fa ff fc 	ld.w	r10,r7[-4]
8000a94e:	10 9b       	mov	r11,r8
8000a950:	ee fc ff ec 	ld.w	r12,r7[-20]
8000a954:	f0 1f 00 55 	mcall	8000aaa8 <log+0x238>
8000a958:	18 98       	mov	r8,r12
8000a95a:	ef 48 ff fc 	st.w	r7[-4],r8
							break;
8000a95e:	c3 d8       	rjmp	8000a9d8 <log+0x168>
							
							case('f')://
							case('F'):
							//f = va_arg(arg_ptr,int);
							//strTmp = PrintDec(x, len, strTmp);
							log("I need float.");
8000a960:	4d 3c       	lddpc	r12,8000aaac <log+0x23c>
8000a962:	f0 1f 00 54 	mcall	8000aab0 <log+0x240>
							break;
8000a966:	c3 98       	rjmp	8000a9d8 <log+0x168>
							
							
							case('x'):
							case('X'):
							x = va_arg(arg_ptr,int);
8000a968:	ee f8 fe e0 	ld.w	r8,r7[-288]
8000a96c:	f0 c9 ff fc 	sub	r9,r8,-4
8000a970:	ef 49 fe e0 	st.w	r7[-288],r9
8000a974:	70 08       	ld.w	r8,r8[0x0]
8000a976:	ef 48 ff ec 	st.w	r7[-20],r8
							PrintHex(x,len, strTmp);
8000a97a:	ee f8 ff e4 	ld.w	r8,r7[-28]
8000a97e:	5c 58       	castu.b	r8
8000a980:	ee fa ff fc 	ld.w	r10,r7[-4]
8000a984:	10 9b       	mov	r11,r8
8000a986:	ee fc ff ec 	ld.w	r12,r7[-20]
8000a98a:	f0 1f 00 4b 	mcall	8000aab4 <log+0x244>
							break;
8000a98e:	c2 58       	rjmp	8000a9d8 <log+0x168>
							
							case('c'):
							case('C'):
							y = va_arg(arg_ptr,int);
8000a990:	ee f8 fe e0 	ld.w	r8,r7[-288]
8000a994:	f0 c9 ff fc 	sub	r9,r8,-4
8000a998:	ef 49 fe e0 	st.w	r7[-288],r9
8000a99c:	70 08       	ld.w	r8,r8[0x0]
8000a99e:	ef 68 ff f3 	st.b	r7[-13],r8
							PrintChar(y, strTmp);
8000a9a2:	ef 38 ff f3 	ld.ub	r8,r7[-13]
8000a9a6:	ee fb ff fc 	ld.w	r11,r7[-4]
8000a9aa:	10 9c       	mov	r12,r8
8000a9ac:	f0 1f 00 43 	mcall	8000aab8 <log+0x248>
							break;
8000a9b0:	c1 48       	rjmp	8000a9d8 <log+0x168>
							
							case('s'):
							case('S'):
							strTmp = va_arg(arg_ptr,char*);
8000a9b2:	ee f8 fe e0 	ld.w	r8,r7[-288]
8000a9b6:	f0 c9 ff fc 	sub	r9,r8,-4
8000a9ba:	ef 49 fe e0 	st.w	r7[-288],r9
8000a9be:	70 08       	ld.w	r8,r8[0x0]
8000a9c0:	ef 48 ff fc 	st.w	r7[-4],r8
							//PrintStr(s);
							break;
8000a9c4:	c0 a8       	rjmp	8000a9d8 <log+0x168>
							
							case('%'):
							PrintChar('%', strTmp);
8000a9c6:	ee fb ff fc 	ld.w	r11,r7[-4]
8000a9ca:	32 5c       	mov	r12,37
8000a9cc:	f0 1f 00 3b 	mcall	8000aab8 <log+0x248>
							//PrintChar('%');
							break;
8000a9d0:	c0 48       	rjmp	8000a9d8 <log+0x168>
							
							default:
							log("I need relax.");
8000a9d2:	4b bc       	lddpc	r12,8000aabc <log+0x24c>
8000a9d4:	f0 1f 00 37 	mcall	8000aab0 <log+0x240>
						}
						str++;
8000a9d8:	ee f8 ff e8 	ld.w	r8,r7[-24]
8000a9dc:	2f f8       	sub	r8,-1
8000a9de:	ef 48 ff e8 	st.w	r7[-24],r8
						
						length = sprintf(logTmp,"%s%s",logTmp,strTmp );
8000a9e2:	ee c8 01 1c 	sub	r8,r7,284
8000a9e6:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000a9ea:	1a d9       	st.w	--sp,r9
8000a9ec:	ee c9 01 1c 	sub	r9,r7,284
8000a9f0:	1a d9       	st.w	--sp,r9
8000a9f2:	4b 4b       	lddpc	r11,8000aac0 <log+0x250>
8000a9f4:	10 9c       	mov	r12,r8
8000a9f6:	f0 1f 00 34 	mcall	8000aac4 <log+0x254>
8000a9fa:	2f ed       	sub	sp,-8
8000a9fc:	18 98       	mov	r8,r12
8000a9fe:	ef 68 ff fb 	st.b	r7[-5],r8
8000aa02:	c1 88       	rjmp	8000aa32 <log+0x1c2>
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
8000aa04:	ee f8 ff e8 	ld.w	r8,r7[-24]
8000aa08:	11 88       	ld.ub	r8,r8[0x0]
8000aa0a:	10 99       	mov	r9,r8
8000aa0c:	ee f8 ff e8 	ld.w	r8,r7[-24]
8000aa10:	2f f8       	sub	r8,-1
8000aa12:	ef 48 ff e8 	st.w	r7[-24],r8
8000aa16:	ee c8 01 1c 	sub	r8,r7,284
8000aa1a:	1a d9       	st.w	--sp,r9
8000aa1c:	ee c9 01 1c 	sub	r9,r7,284
8000aa20:	1a d9       	st.w	--sp,r9
8000aa22:	4a ab       	lddpc	r11,8000aac8 <log+0x258>
8000aa24:	10 9c       	mov	r12,r8
8000aa26:	f0 1f 00 28 	mcall	8000aac4 <log+0x254>
8000aa2a:	2f ed       	sub	sp,-8
8000aa2c:	18 98       	mov	r8,r12
8000aa2e:	ef 68 ff fb 	st.b	r7[-5],r8
			
			
			
	}while(*str != '\0');
8000aa32:	ee f8 ff e8 	ld.w	r8,r7[-24]
8000aa36:	11 88       	ld.ub	r8,r8[0x0]
8000aa38:	58 08       	cp.w	r8,0
8000aa3a:	fe 91 ff 3a 	brne	8000a8ae <log+0x3e>
		
		
				
	va_end(arg_ptr);
	//while(1)		
	length = sprintf(logTmp,"%s\r\n",logTmp);
8000aa3e:	ee c8 01 1c 	sub	r8,r7,284
8000aa42:	ee c9 01 1c 	sub	r9,r7,284
8000aa46:	1a d9       	st.w	--sp,r9
8000aa48:	4a 1b       	lddpc	r11,8000aacc <log+0x25c>
8000aa4a:	10 9c       	mov	r12,r8
8000aa4c:	f0 1f 00 1e 	mcall	8000aac4 <log+0x254>
8000aa50:	2f fd       	sub	sp,-4
8000aa52:	18 98       	mov	r8,r12
8000aa54:	ef 68 ff fb 	st.b	r7[-5],r8
	
	char * p = pvPortMalloc(length+1);
8000aa58:	ef 38 ff fb 	ld.ub	r8,r7[-5]
8000aa5c:	2f f8       	sub	r8,-1
8000aa5e:	10 9c       	mov	r12,r8
8000aa60:	f0 1f 00 1c 	mcall	8000aad0 <log+0x260>
8000aa64:	18 98       	mov	r8,r12
8000aa66:	ef 48 fe dc 	st.w	r7[-292],r8
	memcpy(p, logTmp, length+1);
8000aa6a:	ef 38 ff fb 	ld.ub	r8,r7[-5]
8000aa6e:	2f f8       	sub	r8,-1
8000aa70:	10 9a       	mov	r10,r8
8000aa72:	ee f8 fe dc 	ld.w	r8,r7[-292]
8000aa76:	ee c9 01 1c 	sub	r9,r7,284
8000aa7a:	12 9b       	mov	r11,r9
8000aa7c:	10 9c       	mov	r12,r8
8000aa7e:	f0 1f 00 16 	mcall	8000aad4 <log+0x264>
	//
	//usart_write_line(EXAMPLE_USART, logTmp)
	
	xQueueSend( logQueue, &p, 5);
8000aa82:	49 68       	lddpc	r8,8000aad8 <log+0x268>
8000aa84:	70 08       	ld.w	r8,r8[0x0]
8000aa86:	ee cb 01 24 	sub	r11,r7,292
8000aa8a:	30 09       	mov	r9,0
8000aa8c:	30 5a       	mov	r10,5
8000aa8e:	10 9c       	mov	r12,r8
8000aa90:	f0 1f 00 13 	mcall	8000aadc <log+0x26c>
	
	
}
8000aa94:	fe 3d fd d8 	sub	sp,-552
8000aa98:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000aa9c:	80 00       	ld.sh	r0,r0[0x0]
8000aa9e:	b6 aa       	st.b	r11[0x2],r10
8000aaa0:	00 00       	add	r0,r0
8000aaa2:	0d 65       	ld.uh	r5,--r6
8000aaa4:	80 01       	ld.sh	r1,r0[0x0]
8000aaa6:	13 08       	ld.w	r8,r9++
8000aaa8:	80 00       	ld.sh	r0,r0[0x0]
8000aaaa:	a4 cc       	st.b	r2[0x4],r12
8000aaac:	80 00       	ld.sh	r0,r0[0x0]
8000aaae:	a4 60       	st.h	r2[0xc],r0
8000aab0:	80 00       	ld.sh	r0,r0[0x0]
8000aab2:	a8 70       	st.h	r4[0xe],r0
8000aab4:	80 00       	ld.sh	r0,r0[0x0]
8000aab6:	a6 84       	st.b	r3[0x0],r4
8000aab8:	80 00       	ld.sh	r0,r0[0x0]
8000aaba:	a4 98       	st.b	r2[0x1],r8
8000aabc:	80 00       	ld.sh	r0,r0[0x0]
8000aabe:	a4 70       	st.h	r2[0xe],r0
8000aac0:	80 00       	ld.sh	r0,r0[0x0]
8000aac2:	a4 80       	st.b	r2[0x0],r0
8000aac4:	80 00       	ld.sh	r0,r0[0x0]
8000aac6:	b9 98       	lsr	r8,0x19
8000aac8:	80 00       	ld.sh	r0,r0[0x0]
8000aaca:	a4 88       	st.b	r2[0x0],r8
8000aacc:	80 00       	ld.sh	r0,r0[0x0]
8000aace:	a4 90       	st.b	r2[0x1],r0
8000aad0:	80 00       	ld.sh	r0,r0[0x0]
8000aad2:	8d b8       	st.w	r6[0x2c],r8
8000aad4:	80 00       	ld.sh	r0,r0[0x0]
8000aad6:	b5 62       	lsl	r2,0x14
8000aad8:	00 00       	add	r0,r0
8000aada:	53 20       	stdsp	sp[0xc8],r0
8000aadc:	80 00       	ld.sh	r0,r0[0x0]
8000aade:	8f 44       	st.w	r7[0x10],r4

8000aae0 <logFromISR>:
	
	
int logFromISR(char * content, ...)
	{
8000aae0:	eb cd 40 c0 	pushm	r6-r7,lr
8000aae4:	1a 97       	mov	r7,sp
8000aae6:	fa cd 02 24 	sub	sp,sp,548
8000aaea:	ee c6 ff f4 	sub	r6,r7,-12
8000aaee:	ef 4c fd dc 	st.w	r7[-548],r12
		
		
		char logTmp[MAX_LOG_LINE_SIZE];
		memset(logTmp, '\0', MAX_LOG_LINE_SIZE);
8000aaf2:	ee c8 01 14 	sub	r8,r7,276
8000aaf6:	e0 6a 01 00 	mov	r10,256
8000aafa:	30 0b       	mov	r11,0
8000aafc:	10 9c       	mov	r12,r8
8000aafe:	f0 1f 00 84 	mcall	8000ad0c <logFromISR+0x22c>
		
		int len = 0 ;
8000ab02:	30 08       	mov	r8,0
8000ab04:	ef 48 ff ec 	st.w	r7[-20],r8
		

		va_list arg_ptr;
		char* str = content;
8000ab08:	ee f8 fd dc 	ld.w	r8,r7[-548]
8000ab0c:	ef 48 ff f0 	st.w	r7[-16],r8
		int x;
		char y;
		//char* s;
		char length= 0;
8000ab10:	30 08       	mov	r8,0
8000ab12:	ef 68 ff fb 	st.b	r7[-5],r8
		
		va_start(arg_ptr, content);
8000ab16:	ec c8 00 00 	sub	r8,r6,0
8000ab1a:	ef 48 fe e8 	st.w	r7[-280],r8
		//str += 4;
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
8000ab1e:	ee c8 02 20 	sub	r8,r7,544
8000ab22:	ef 48 ff fc 	st.w	r7[-4],r8
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
8000ab26:	e0 6a 01 00 	mov	r10,256
8000ab2a:	30 0b       	mov	r11,0
8000ab2c:	ee fc ff fc 	ld.w	r12,r7[-4]
8000ab30:	f0 1f 00 77 	mcall	8000ad0c <logFromISR+0x22c>
			
			if(*str == '%')
8000ab34:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000ab38:	11 89       	ld.ub	r9,r8[0x0]
8000ab3a:	32 58       	mov	r8,37
8000ab3c:	f0 09 18 00 	cp.b	r9,r8
8000ab40:	e0 81 00 96 	brne	8000ac6c <logFromISR+0x18c>
			{
				static char lench = 0;
				lench =*(str + 1);
8000ab44:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000ab48:	2f f8       	sub	r8,-1
8000ab4a:	11 88       	ld.ub	r8,r8[0x0]
8000ab4c:	4f 19       	lddpc	r9,8000ad10 <logFromISR+0x230>
8000ab4e:	b2 88       	st.b	r9[0x0],r8
				if((lench >= '0') &&  (lench <= '9'))
8000ab50:	4f 08       	lddpc	r8,8000ad10 <logFromISR+0x230>
8000ab52:	11 89       	ld.ub	r9,r8[0x0]
8000ab54:	32 f8       	mov	r8,47
8000ab56:	f0 09 18 00 	cp.b	r9,r8
8000ab5a:	e0 88 00 14 	brls	8000ab82 <logFromISR+0xa2>
8000ab5e:	4e d8       	lddpc	r8,8000ad10 <logFromISR+0x230>
8000ab60:	11 89       	ld.ub	r9,r8[0x0]
8000ab62:	33 98       	mov	r8,57
8000ab64:	f0 09 18 00 	cp.b	r9,r8
8000ab68:	e0 8b 00 0d 	brhi	8000ab82 <logFromISR+0xa2>
				{
					len = *(++str) - '0';
8000ab6c:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000ab70:	2f f8       	sub	r8,-1
8000ab72:	ef 48 ff f0 	st.w	r7[-16],r8
8000ab76:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000ab7a:	11 88       	ld.ub	r8,r8[0x0]
8000ab7c:	23 08       	sub	r8,48
8000ab7e:	ef 48 ff ec 	st.w	r7[-20],r8
				}
				
				str++;
8000ab82:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000ab86:	2f f8       	sub	r8,-1
8000ab88:	ef 48 ff f0 	st.w	r7[-16],r8
				
				switch(*(str))
8000ab8c:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000ab90:	11 88       	ld.ub	r8,r8[0x0]
8000ab92:	22 58       	sub	r8,37
8000ab94:	e0 48 00 53 	cp.w	r8,83
8000ab98:	e0 8b 00 51 	brhi	8000ac3a <logFromISR+0x15a>
8000ab9c:	4d e9       	lddpc	r9,8000ad14 <logFromISR+0x234>
8000ab9e:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
				{
					case('d'):
					case('D'):
					x = va_arg(arg_ptr,int);
8000aba2:	ee f8 fe e8 	ld.w	r8,r7[-280]
8000aba6:	f0 c9 ff fc 	sub	r9,r8,-4
8000abaa:	ef 49 fe e8 	st.w	r7[-280],r9
8000abae:	70 08       	ld.w	r8,r8[0x0]
8000abb0:	ef 48 ff f4 	st.w	r7[-12],r8
					strTmp = PrintDec(x, len, strTmp);
8000abb4:	ee f8 ff ec 	ld.w	r8,r7[-20]
8000abb8:	5c 58       	castu.b	r8
8000abba:	ee fa ff fc 	ld.w	r10,r7[-4]
8000abbe:	10 9b       	mov	r11,r8
8000abc0:	ee fc ff f4 	ld.w	r12,r7[-12]
8000abc4:	f0 1f 00 55 	mcall	8000ad18 <logFromISR+0x238>
8000abc8:	18 98       	mov	r8,r12
8000abca:	ef 48 ff fc 	st.w	r7[-4],r8
					break;
8000abce:	c3 98       	rjmp	8000ac40 <logFromISR+0x160>
					case('x'):
					case('X'):
					x = va_arg(arg_ptr,int);
8000abd0:	ee f8 fe e8 	ld.w	r8,r7[-280]
8000abd4:	f0 c9 ff fc 	sub	r9,r8,-4
8000abd8:	ef 49 fe e8 	st.w	r7[-280],r9
8000abdc:	70 08       	ld.w	r8,r8[0x0]
8000abde:	ef 48 ff f4 	st.w	r7[-12],r8
					PrintHex(x,len, strTmp);
8000abe2:	ee f8 ff ec 	ld.w	r8,r7[-20]
8000abe6:	5c 58       	castu.b	r8
8000abe8:	ee fa ff fc 	ld.w	r10,r7[-4]
8000abec:	10 9b       	mov	r11,r8
8000abee:	ee fc ff f4 	ld.w	r12,r7[-12]
8000abf2:	f0 1f 00 4b 	mcall	8000ad1c <logFromISR+0x23c>
					break;
8000abf6:	c2 58       	rjmp	8000ac40 <logFromISR+0x160>
					case('c'):
					case('C'):
					y = va_arg(arg_ptr,int);
8000abf8:	ee f8 fe e8 	ld.w	r8,r7[-280]
8000abfc:	f0 c9 ff fc 	sub	r9,r8,-4
8000ac00:	ef 49 fe e8 	st.w	r7[-280],r9
8000ac04:	70 08       	ld.w	r8,r8[0x0]
8000ac06:	ef 68 ff fa 	st.b	r7[-6],r8
					PrintChar(y, strTmp);
8000ac0a:	ef 38 ff fa 	ld.ub	r8,r7[-6]
8000ac0e:	ee fb ff fc 	ld.w	r11,r7[-4]
8000ac12:	10 9c       	mov	r12,r8
8000ac14:	f0 1f 00 43 	mcall	8000ad20 <logFromISR+0x240>
					break;
8000ac18:	c1 48       	rjmp	8000ac40 <logFromISR+0x160>
					case('s'):
					case('S'):
					strTmp = va_arg(arg_ptr,char*);
8000ac1a:	ee f8 fe e8 	ld.w	r8,r7[-280]
8000ac1e:	f0 c9 ff fc 	sub	r9,r8,-4
8000ac22:	ef 49 fe e8 	st.w	r7[-280],r9
8000ac26:	70 08       	ld.w	r8,r8[0x0]
8000ac28:	ef 48 ff fc 	st.w	r7[-4],r8
					//PrintStr(s);
					break;
8000ac2c:	c0 a8       	rjmp	8000ac40 <logFromISR+0x160>
					case('%'):
					PrintChar('%', strTmp);
8000ac2e:	ee fb ff fc 	ld.w	r11,r7[-4]
8000ac32:	32 5c       	mov	r12,37
8000ac34:	f0 1f 00 3b 	mcall	8000ad20 <logFromISR+0x240>
					//PrintChar('%');
					break;
8000ac38:	c0 48       	rjmp	8000ac40 <logFromISR+0x160>
					default:
					log("I need relax.");
8000ac3a:	4b bc       	lddpc	r12,8000ad24 <logFromISR+0x244>
8000ac3c:	f0 1f 00 3b 	mcall	8000ad28 <logFromISR+0x248>
				}
				str++;
8000ac40:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000ac44:	2f f8       	sub	r8,-1
8000ac46:	ef 48 ff f0 	st.w	r7[-16],r8
				
				length = sprintf(logTmp,"%s%s",logTmp,strTmp );
8000ac4a:	ee c8 01 14 	sub	r8,r7,276
8000ac4e:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000ac52:	1a d9       	st.w	--sp,r9
8000ac54:	ee c9 01 14 	sub	r9,r7,276
8000ac58:	1a d9       	st.w	--sp,r9
8000ac5a:	4b 5b       	lddpc	r11,8000ad2c <logFromISR+0x24c>
8000ac5c:	10 9c       	mov	r12,r8
8000ac5e:	f0 1f 00 35 	mcall	8000ad30 <logFromISR+0x250>
8000ac62:	2f ed       	sub	sp,-8
8000ac64:	18 98       	mov	r8,r12
8000ac66:	ef 68 ff fb 	st.b	r7[-5],r8
8000ac6a:	c1 88       	rjmp	8000ac9a <logFromISR+0x1ba>
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
8000ac6c:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000ac70:	11 88       	ld.ub	r8,r8[0x0]
8000ac72:	10 99       	mov	r9,r8
8000ac74:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000ac78:	2f f8       	sub	r8,-1
8000ac7a:	ef 48 ff f0 	st.w	r7[-16],r8
8000ac7e:	ee c8 01 14 	sub	r8,r7,276
8000ac82:	1a d9       	st.w	--sp,r9
8000ac84:	ee c9 01 14 	sub	r9,r7,276
8000ac88:	1a d9       	st.w	--sp,r9
8000ac8a:	4a bb       	lddpc	r11,8000ad34 <logFromISR+0x254>
8000ac8c:	10 9c       	mov	r12,r8
8000ac8e:	f0 1f 00 29 	mcall	8000ad30 <logFromISR+0x250>
8000ac92:	2f ed       	sub	sp,-8
8000ac94:	18 98       	mov	r8,r12
8000ac96:	ef 68 ff fb 	st.b	r7[-5],r8
			
			
			
		}while(*str != '\0');
8000ac9a:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000ac9e:	11 88       	ld.ub	r8,r8[0x0]
8000aca0:	58 08       	cp.w	r8,0
8000aca2:	fe 91 ff 3e 	brne	8000ab1e <logFromISR+0x3e>
		
		
		
		va_end(arg_ptr);
		//while(1)
		length = sprintf(logTmp,"%s\r\n",logTmp);
8000aca6:	ee c8 01 14 	sub	r8,r7,276
8000acaa:	ee c9 01 14 	sub	r9,r7,276
8000acae:	1a d9       	st.w	--sp,r9
8000acb0:	4a 2b       	lddpc	r11,8000ad38 <logFromISR+0x258>
8000acb2:	10 9c       	mov	r12,r8
8000acb4:	f0 1f 00 1f 	mcall	8000ad30 <logFromISR+0x250>
8000acb8:	2f fd       	sub	sp,-4
8000acba:	18 98       	mov	r8,r12
8000acbc:	ef 68 ff fb 	st.b	r7[-5],r8
		
		char * p = pvPortMalloc(length+1);
8000acc0:	ef 38 ff fb 	ld.ub	r8,r7[-5]
8000acc4:	2f f8       	sub	r8,-1
8000acc6:	10 9c       	mov	r12,r8
8000acc8:	f0 1f 00 1d 	mcall	8000ad3c <logFromISR+0x25c>
8000accc:	18 98       	mov	r8,r12
8000acce:	ef 48 fe e4 	st.w	r7[-284],r8
		memcpy(p, logTmp, length+1);
8000acd2:	ef 38 ff fb 	ld.ub	r8,r7[-5]
8000acd6:	2f f8       	sub	r8,-1
8000acd8:	10 9a       	mov	r10,r8
8000acda:	ee f8 fe e4 	ld.w	r8,r7[-284]
8000acde:	ee c9 01 14 	sub	r9,r7,276
8000ace2:	12 9b       	mov	r11,r9
8000ace4:	10 9c       	mov	r12,r8
8000ace6:	f0 1f 00 17 	mcall	8000ad40 <logFromISR+0x260>
		//
		portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
8000acea:	30 08       	mov	r8,0
8000acec:	ef 48 fe e0 	st.w	r7[-288],r8
		
		//usart_write_line(EXAMPLE_USART, p);
		//vPortFree(p);
		xQueueSendFromISR( logQueue, &p, &xHigherPriorityTaskWoken );
8000acf0:	49 58       	lddpc	r8,8000ad44 <logFromISR+0x264>
8000acf2:	70 08       	ld.w	r8,r8[0x0]
8000acf4:	ee ca 01 20 	sub	r10,r7,288
8000acf8:	ee cb 01 1c 	sub	r11,r7,284
8000acfc:	30 09       	mov	r9,0
8000acfe:	10 9c       	mov	r12,r8
8000ad00:	f0 1f 00 12 	mcall	8000ad48 <logFromISR+0x268>
		
		//if (xHigherPriorityTaskWoken == pdTRUE)
		//{
			////taskYIELD();
		//}
	}
8000ad04:	fe 3d fd dc 	sub	sp,-548
8000ad08:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000ad0c:	80 00       	ld.sh	r0,r0[0x0]
8000ad0e:	b6 aa       	st.b	r11[0x2],r10
8000ad10:	00 00       	add	r0,r0
8000ad12:	0d 64       	ld.uh	r4,--r6
8000ad14:	80 01       	ld.sh	r1,r0[0x0]
8000ad16:	14 58       	eor	r8,r10
8000ad18:	80 00       	ld.sh	r0,r0[0x0]
8000ad1a:	a4 cc       	st.b	r2[0x4],r12
8000ad1c:	80 00       	ld.sh	r0,r0[0x0]
8000ad1e:	a6 84       	st.b	r3[0x0],r4
8000ad20:	80 00       	ld.sh	r0,r0[0x0]
8000ad22:	a4 98       	st.b	r2[0x1],r8
8000ad24:	80 00       	ld.sh	r0,r0[0x0]
8000ad26:	a4 70       	st.h	r2[0xe],r0
8000ad28:	80 00       	ld.sh	r0,r0[0x0]
8000ad2a:	a8 70       	st.h	r4[0xe],r0
8000ad2c:	80 00       	ld.sh	r0,r0[0x0]
8000ad2e:	a4 80       	st.b	r2[0x0],r0
8000ad30:	80 00       	ld.sh	r0,r0[0x0]
8000ad32:	b9 98       	lsr	r8,0x19
8000ad34:	80 00       	ld.sh	r0,r0[0x0]
8000ad36:	a4 88       	st.b	r2[0x0],r8
8000ad38:	80 00       	ld.sh	r0,r0[0x0]
8000ad3a:	a4 90       	st.b	r2[0x1],r0
8000ad3c:	80 00       	ld.sh	r0,r0[0x0]
8000ad3e:	8d b8       	st.w	r6[0x2c],r8
8000ad40:	80 00       	ld.sh	r0,r0[0x0]
8000ad42:	b5 62       	lsl	r2,0x14
8000ad44:	00 00       	add	r0,r0
8000ad46:	53 20       	stdsp	sp[0xc8],r0
8000ad48:	80 00       	ld.sh	r0,r0[0x0]
8000ad4a:	90 ac       	ld.uh	r12,r8[0x4]

8000ad4c <task_log>:
	
static void task_log(void * pvParameters)
{
8000ad4c:	eb cd 40 80 	pushm	r7,lr
8000ad50:	1a 97       	mov	r7,sp
8000ad52:	20 2d       	sub	sp,8
8000ad54:	ef 4c ff f8 	st.w	r7[-8],r12
8000ad58:	c0 48       	rjmp	8000ad60 <task_log+0x14>
				vPortFree(str);
			}
			
		}

	}
8000ad5a:	d7 03       	nop
8000ad5c:	c0 28       	rjmp	8000ad60 <task_log+0x14>
8000ad5e:	d7 03       	nop
{
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
8000ad60:	48 f8       	lddpc	r8,8000ad9c <task_log+0x50>
8000ad62:	70 08       	ld.w	r8,r8[0x0]
8000ad64:	ee cb 00 04 	sub	r11,r7,4
8000ad68:	30 09       	mov	r9,0
8000ad6a:	3f fa       	mov	r10,-1
8000ad6c:	10 9c       	mov	r12,r8
8000ad6e:	f0 1f 00 0d 	mcall	8000ada0 <task_log+0x54>
8000ad72:	18 98       	mov	r8,r12
8000ad74:	58 18       	cp.w	r8,1
8000ad76:	cf 21       	brne	8000ad5a <task_log+0xe>
		{
			if( NULL != str)
8000ad78:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000ad7c:	58 08       	cp.w	r8,0
8000ad7e:	cf 00       	breq	8000ad5e <task_log+0x12>
			{
				usart_write_line(EXAMPLE_USART, str);
8000ad80:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000ad84:	10 9b       	mov	r11,r8
8000ad86:	fe 7c 18 00 	mov	r12,-59392
8000ad8a:	f0 1f 00 07 	mcall	8000ada4 <task_log+0x58>
				vPortFree(str);
8000ad8e:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000ad92:	10 9c       	mov	r12,r8
8000ad94:	f0 1f 00 05 	mcall	8000ada8 <task_log+0x5c>
			}
			
		}

	}
8000ad98:	ce 4b       	rjmp	8000ad60 <task_log+0x14>
8000ad9a:	00 00       	add	r0,r0
8000ad9c:	00 00       	add	r0,r0
8000ad9e:	53 20       	stdsp	sp[0xc8],r0
8000ada0:	80 00       	ld.sh	r0,r0[0x0]
8000ada2:	91 50       	st.w	r8[0x14],r0
8000ada4:	80 00       	ld.sh	r0,r0[0x0]
8000ada6:	86 98       	ld.uh	r8,r3[0x2]
8000ada8:	80 00       	ld.sh	r0,r0[0x0]
8000adaa:	8d f4       	st.w	r6[0x3c],r4
8000adac:	2d 2d       	sub	sp,-184
8000adae:	2d 2d       	sub	sp,-184
8000adb0:	73 74       	ld.w	r4,r9[0x5c]
8000adb2:	61 72       	ld.w	r2,r0[0x5c]
8000adb4:	74 20       	ld.w	r0,r10[0x8]
8000adb6:	64 65       	ld.w	r5,r2[0x18]
8000adb8:	62 75       	ld.w	r5,r1[0x1c]
8000adba:	67 a3       	ld.w	r3,r3[0x68]
8000adbc:	ac 20       	st.h	r6[0x4],r0
8000adbe:	79 6f       	ld.w	pc,r12[0x58]
8000adc0:	79 6f       	ld.w	pc,r12[0x58]
8000adc2:	2d 2d       	sub	sp,-184
8000adc4:	2d 2d       	sub	sp,-184
	...

8000adc8 <main>:
//#include "fs/fs.h"
#include "rtc/rtc.h"
#include "data_flash/data_flash.h"

int main(void)
{
8000adc8:	eb cd 40 80 	pushm	r7,lr
8000adcc:	1a 97       	mov	r7,sp
	//Force SSC_TX_DATA_ENABLE Disabled as soon as possible.
	AVR32_GPIO.port[1].ovrs  =  0x00000001;  //Value will be high.
8000adce:	fe 78 10 00 	mov	r8,-61440
8000add2:	30 19       	mov	r9,1
8000add4:	f1 49 01 54 	st.w	r8[340],r9
	AVR32_GPIO.port[1].oders =  0x00000001;  //Output Driver will be Enabled.
8000add8:	fe 78 10 00 	mov	r8,-61440
8000addc:	30 19       	mov	r9,1
8000adde:	f1 49 01 44 	st.w	r8[324],r9
	AVR32_GPIO.port[1].gpers =  0x00000001;  //Enable as GPIO.
8000ade2:	fe 78 10 00 	mov	r8,-61440
8000ade6:	30 19       	mov	r9,1
8000ade8:	f1 49 01 04 	st.w	r8[260],r9
	
	Disable_global_interrupt();
8000adec:	d3 03       	ssrf	0x10
	local_start_pll0();
8000adee:	f0 1f 00 15 	mcall	8000ae40 <main+0x78>
		
	INTC_init_interrupts();
8000adf2:	f0 1f 00 15 	mcall	8000ae44 <main+0x7c>
	
	log_init();		
8000adf6:	f0 1f 00 15 	mcall	8000ae48 <main+0x80>
	log("----start debug yoyo----");	
8000adfa:	49 5c       	lddpc	r12,8000ae4c <main+0x84>
8000adfc:	f0 1f 00 15 	mcall	8000ae50 <main+0x88>
	
	data_flash_init();
8000ae00:	f0 1f 00 15 	mcall	8000ae54 <main+0x8c>
		
	//rtc_init();
	
	//fs_init();//65795,RadioOBSD

	tc_init();	
8000ae04:	f0 1f 00 15 	mcall	8000ae58 <main+0x90>
			
	xcmp_init();
8000ae08:	f0 1f 00 15 	mcall	8000ae5c <main+0x94>
	
	app_init();
8000ae0c:	f0 1f 00 15 	mcall	8000ae60 <main+0x98>
		
	while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
8000ae10:	fe 78 10 00 	mov	r8,-61440
8000ae14:	f0 f8 01 60 	ld.w	r8,r8[352]
8000ae18:	e2 18 00 02 	andl	r8,0x2,COH
8000ae1c:	cf a0       	breq	8000ae10 <main+0x48>
	while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
8000ae1e:	fe 78 10 00 	mov	r8,-61440
8000ae22:	f0 f8 01 60 	ld.w	r8,r8[352]
8000ae26:	e2 18 00 02 	andl	r8,0x2,COH
8000ae2a:	cf a1       	brne	8000ae1e <main+0x56>
	local_start_timer();
8000ae2c:	f0 1f 00 0e 	mcall	8000ae64 <main+0x9c>
	
	Enable_global_interrupt();
8000ae30:	d5 03       	csrf	0x10
	
	vTaskStartScheduler();		
8000ae32:	f0 1f 00 0e 	mcall	8000ae68 <main+0xa0>
	return 0;
8000ae36:	30 08       	mov	r8,0
}
8000ae38:	10 9c       	mov	r12,r8
8000ae3a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000ae3e:	00 00       	add	r0,r0
8000ae40:	80 00       	ld.sh	r0,r0[0x0]
8000ae42:	76 08       	ld.w	r8,r11[0x0]
8000ae44:	80 00       	ld.sh	r0,r0[0x0]
8000ae46:	78 0c       	ld.w	r12,r12[0x0]
8000ae48:	80 00       	ld.sh	r0,r0[0x0]
8000ae4a:	a7 fc       	*unknown*
8000ae4c:	80 00       	ld.sh	r0,r0[0x0]
8000ae4e:	ad ac       	sbr	r12,0xc
8000ae50:	80 00       	ld.sh	r0,r0[0x0]
8000ae52:	a8 70       	st.h	r4[0xe],r0
8000ae54:	80 00       	ld.sh	r0,r0[0x0]
8000ae56:	35 88       	mov	r8,88
8000ae58:	80 00       	ld.sh	r0,r0[0x0]
8000ae5a:	77 10       	ld.w	r0,r11[0x44]
8000ae5c:	80 00       	ld.sh	r0,r0[0x0]
8000ae5e:	6a c4       	ld.w	r4,r5[0x30]
8000ae60:	80 00       	ld.sh	r0,r0[0x0]
8000ae62:	33 2c       	mov	r12,50
8000ae64:	80 00       	ld.sh	r0,r0[0x0]
8000ae66:	76 a0       	ld.w	r0,r11[0x28]
8000ae68:	80 00       	ld.sh	r0,r0[0x0]
8000ae6a:	99 44       	st.w	r12[0x10],r4

8000ae6c <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
8000ae6c:	eb cd 40 80 	pushm	r7,lr
8000ae70:	1a 97       	mov	r7,sp
8000ae72:	20 4d       	sub	sp,16
8000ae74:	ef 4c ff f4 	st.w	r7[-12],r12
8000ae78:	ef 4b ff f0 	st.w	r7[-16],r11
	uint32_t status = GPIO_SUCCESS;
8000ae7c:	30 08       	mov	r8,0
8000ae7e:	ef 48 ff f8 	st.w	r7[-8],r8
	uint32_t i;

	for (i = 0; i < size; i++) {
8000ae82:	30 08       	mov	r8,0
8000ae84:	ef 48 ff fc 	st.w	r7[-4],r8
8000ae88:	c1 c8       	rjmp	8000aec0 <gpio_enable_module+0x54>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
8000ae8a:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000ae8e:	70 19       	ld.w	r9,r8[0x4]
8000ae90:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000ae94:	70 08       	ld.w	r8,r8[0x0]
8000ae96:	12 9b       	mov	r11,r9
8000ae98:	10 9c       	mov	r12,r8
8000ae9a:	f0 1f 00 10 	mcall	8000aed8 <gpio_enable_module+0x6c>
8000ae9e:	18 98       	mov	r8,r12
8000aea0:	ee f9 ff f8 	ld.w	r9,r7[-8]
8000aea4:	f3 e8 10 08 	or	r8,r9,r8
8000aea8:	ef 48 ff f8 	st.w	r7[-8],r8
		gpiomap++;
8000aeac:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000aeb0:	2f 88       	sub	r8,-8
8000aeb2:	ef 48 ff f4 	st.w	r7[-12],r8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
8000aeb6:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000aeba:	2f f8       	sub	r8,-1
8000aebc:	ef 48 ff fc 	st.w	r7[-4],r8
8000aec0:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000aec4:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000aec8:	10 39       	cp.w	r9,r8
8000aeca:	ce 03       	brcs	8000ae8a <gpio_enable_module+0x1e>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
8000aecc:	ee f8 ff f8 	ld.w	r8,r7[-8]
}
8000aed0:	10 9c       	mov	r12,r8
8000aed2:	2f cd       	sub	sp,-16
8000aed4:	e3 cd 80 80 	ldm	sp++,r7,pc
8000aed8:	80 00       	ld.sh	r0,r0[0x0]
8000aeda:	ae dc       	st.b	r7[0x5],r12

8000aedc <gpio_enable_module_pin>:
 * \param function The pin function.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
8000aedc:	eb cd 40 80 	pushm	r7,lr
8000aee0:	1a 97       	mov	r7,sp
8000aee2:	20 3d       	sub	sp,12
8000aee4:	ef 4c ff f8 	st.w	r7[-8],r12
8000aee8:	ef 4b ff f4 	st.w	r7[-12],r11
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
8000aeec:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000aef0:	a5 98       	lsr	r8,0x5
8000aef2:	a9 68       	lsl	r8,0x8
8000aef4:	e0 28 f0 00 	sub	r8,61440
8000aef8:	ef 48 ff fc 	st.w	r7[-4],r8

	/* Enable the correct function. */
	switch (function) {
8000aefc:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000af00:	58 18       	cp.w	r8,1
8000af02:	c1 e0       	breq	8000af3e <gpio_enable_module_pin+0x62>
8000af04:	c0 63       	brcs	8000af10 <gpio_enable_module_pin+0x34>
8000af06:	58 28       	cp.w	r8,2
8000af08:	c3 20       	breq	8000af6c <gpio_enable_module_pin+0x90>
8000af0a:	58 38       	cp.w	r8,3
8000af0c:	c4 70       	breq	8000af9a <gpio_enable_module_pin+0xbe>
8000af0e:	c5 d8       	rjmp	8000afc8 <gpio_enable_module_pin+0xec>
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
8000af10:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000af14:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000af18:	30 19       	mov	r9,1
8000af1a:	f2 08 09 48 	lsl	r8,r9,r8
8000af1e:	10 99       	mov	r9,r8
8000af20:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000af24:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
8000af26:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000af2a:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000af2e:	30 19       	mov	r9,1
8000af30:	f2 08 09 48 	lsl	r8,r9,r8
8000af34:	10 99       	mov	r9,r8
8000af36:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000af3a:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
8000af3c:	c4 88       	rjmp	8000afcc <gpio_enable_module_pin+0xf0>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
8000af3e:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000af42:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000af46:	30 19       	mov	r9,1
8000af48:	f2 08 09 48 	lsl	r8,r9,r8
8000af4c:	10 99       	mov	r9,r8
8000af4e:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000af52:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
8000af54:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000af58:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000af5c:	30 19       	mov	r9,1
8000af5e:	f2 08 09 48 	lsl	r8,r9,r8
8000af62:	10 99       	mov	r9,r8
8000af64:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000af68:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
8000af6a:	c3 18       	rjmp	8000afcc <gpio_enable_module_pin+0xf0>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
8000af6c:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000af70:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000af74:	30 19       	mov	r9,1
8000af76:	f2 08 09 48 	lsl	r8,r9,r8
8000af7a:	10 99       	mov	r9,r8
8000af7c:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000af80:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
8000af82:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000af86:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000af8a:	30 19       	mov	r9,1
8000af8c:	f2 08 09 48 	lsl	r8,r9,r8
8000af90:	10 99       	mov	r9,r8
8000af92:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000af96:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
8000af98:	c1 a8       	rjmp	8000afcc <gpio_enable_module_pin+0xf0>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
8000af9a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000af9e:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000afa2:	30 19       	mov	r9,1
8000afa4:	f2 08 09 48 	lsl	r8,r9,r8
8000afa8:	10 99       	mov	r9,r8
8000afaa:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000afae:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
8000afb0:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000afb4:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000afb8:	30 19       	mov	r9,1
8000afba:	f2 08 09 48 	lsl	r8,r9,r8
8000afbe:	10 99       	mov	r9,r8
8000afc0:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000afc4:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
8000afc6:	c0 38       	rjmp	8000afcc <gpio_enable_module_pin+0xf0>
		gpio_port->pmr2s = 1 << (pin & 0x1F);
		break;
#endif

	default:
		return GPIO_INVALID_ARGUMENT;
8000afc8:	30 18       	mov	r8,1
8000afca:	c0 d8       	rjmp	8000afe4 <gpio_enable_module_pin+0x108>
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
8000afcc:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000afd0:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000afd4:	30 19       	mov	r9,1
8000afd6:	f2 08 09 48 	lsl	r8,r9,r8
8000afda:	10 99       	mov	r9,r8
8000afdc:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000afe0:	91 29       	st.w	r8[0x8],r9

	return GPIO_SUCCESS;
8000afe2:	30 08       	mov	r8,0
}
8000afe4:	10 9c       	mov	r12,r8
8000afe6:	2f dd       	sub	sp,-12
8000afe8:	e3 cd 80 80 	ldm	sp++,r7,pc

8000afec <gpio_enable_gpio_pin>:
 *            GPIO mode of PX21, AVR32_PIN_PX21 can be used. Module pins such as
 *            AVR32_PWM_3_PIN for PWM channel 3 can also be used to release
 *            module pins for GPIO.
 */
void gpio_enable_gpio_pin(uint32_t pin)
{
8000afec:	eb cd 40 80 	pushm	r7,lr
8000aff0:	1a 97       	mov	r7,sp
8000aff2:	20 2d       	sub	sp,8
8000aff4:	ef 4c ff f8 	st.w	r7[-8],r12
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
8000aff8:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000affc:	a5 98       	lsr	r8,0x5
8000affe:	a9 68       	lsl	r8,0x8
8000b000:	e0 28 f0 00 	sub	r8,61440
8000b004:	ef 48 ff fc 	st.w	r7[-4],r8
	
	gpio_port->oderc = 1 << (pin & 0x1F);
8000b008:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000b00c:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000b010:	30 19       	mov	r9,1
8000b012:	f2 08 09 48 	lsl	r8,r9,r8
8000b016:	10 99       	mov	r9,r8
8000b018:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000b01c:	f1 49 00 48 	st.w	r8[72],r9
	gpio_port->gpers = 1 << (pin & 0x1F);
8000b020:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000b024:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000b028:	30 19       	mov	r9,1
8000b02a:	f2 08 09 48 	lsl	r8,r9,r8
8000b02e:	10 99       	mov	r9,r8
8000b030:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000b034:	91 19       	st.w	r8[0x4],r9
}
8000b036:	2f ed       	sub	sp,-8
8000b038:	e3 cd 80 80 	ldm	sp++,r7,pc

8000b03c <gpio_set_gpio_pin>:
/** \brief Drives a GPIO pin to 1.
 *
 * \param pin The pin number.
 */
void gpio_set_gpio_pin(uint32_t pin)
{
8000b03c:	eb cd 40 80 	pushm	r7,lr
8000b040:	1a 97       	mov	r7,sp
8000b042:	20 2d       	sub	sp,8
8000b044:	ef 4c ff f8 	st.w	r7[-8],r12
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
8000b048:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000b04c:	a5 98       	lsr	r8,0x5
8000b04e:	a9 68       	lsl	r8,0x8
8000b050:	e0 28 f0 00 	sub	r8,61440
8000b054:	ef 48 ff fc 	st.w	r7[-4],r8
	
	/* Value to be driven on the I/O line: 1. */
	gpio_port->ovrs  = 1 << (pin & 0x1F);																				
8000b058:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000b05c:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000b060:	30 19       	mov	r9,1
8000b062:	f2 08 09 48 	lsl	r8,r9,r8
8000b066:	10 99       	mov	r9,r8
8000b068:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000b06c:	f1 49 00 54 	st.w	r8[84],r9
	/* The GPIO output driver is enabled for that pin. */ 
	gpio_port->oders = 1 << (pin & 0x1F);
8000b070:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000b074:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000b078:	30 19       	mov	r9,1
8000b07a:	f2 08 09 48 	lsl	r8,r9,r8
8000b07e:	10 99       	mov	r9,r8
8000b080:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000b084:	f1 49 00 44 	st.w	r8[68],r9
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
8000b088:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000b08c:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000b090:	30 19       	mov	r9,1
8000b092:	f2 08 09 48 	lsl	r8,r9,r8
8000b096:	10 99       	mov	r9,r8
8000b098:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000b09c:	91 19       	st.w	r8[0x4],r9
}
8000b09e:	2f ed       	sub	sp,-8
8000b0a0:	e3 cd 80 80 	ldm	sp++,r7,pc

8000b0a4 <_stext>:

  .global _stext
  .type _stext, @function
_stext:
  // Set initial stack pointer.
  lda.w   sp, _estack
8000b0a4:	e0 7d 80 00 	mov	sp,98304

  // Set up EVBA so interrupts can be enabled.
  lda.w   r0, _evba
  mtsr    AVR32_EVBA, r0
8000b0a8:	fe c0 a6 a8 	sub	r0,pc,-22872

  // Enable the exception processing.
  csrf    AVR32_SR_EM_OFFSET
8000b0ac:	e3 b0 00 01 	mtsr	0x4,r0

  // Load initialized data having a global lifetime from the data LMA.
  lda.w   r0, _data
  lda.w   r1, _edata
8000b0b0:	d5 53       	csrf	0x15
  cp      r0, r1
8000b0b2:	30 80       	mov	r0,8
  brhs    idata_load_loop_end
8000b0b4:	e0 61 0a 58 	mov	r1,2648
  lda.w   r2, _data_lma
idata_load_loop:
  ld.d    r4, r2++
8000b0b8:	02 30       	cp.w	r0,r1
  st.d    r0++, r4
8000b0ba:	c0 72       	brcc	8000b0c8 <idata_load_loop_end>
  cp      r0, r1
8000b0bc:	fe c2 95 6c 	sub	r2,pc,-27284

8000b0c0 <idata_load_loop>:
  brlo    idata_load_loop
idata_load_loop_end:

  // Clear uninitialized data having a global lifetime in the blank static storage section.
  lda.w   r0, __bss_start
8000b0c0:	a5 05       	ld.d	r4,r2++
  lda.w   r1, _end
8000b0c2:	a1 24       	st.d	r0++,r4
  cp      r0, r1
8000b0c4:	02 30       	cp.w	r0,r1
  brhs    udata_clear_loop_end
8000b0c6:	cf d3       	brcs	8000b0c0 <idata_load_loop>

8000b0c8 <idata_load_loop_end>:
  mov     r2, 0
8000b0c8:	e0 60 0a 58 	mov	r0,2648
  mov     r3, 0
udata_clear_loop:
  st.d    r0++, r2
8000b0cc:	e0 61 53 28 	mov	r1,21288
  cp      r0, r1
  brlo    udata_clear_loop
8000b0d0:	02 30       	cp.w	r0,r1
  // Safety: Set the default "return" @ to the exit routine address.
  lda.w   lr, exit
#endif

  // Start the show.
  lda.w   pc, main
8000b0d2:	c0 62       	brcc	8000b0de <udata_clear_loop_end>
8000b0d4:	30 02       	mov	r2,0
8000b0d6:	30 03       	mov	r3,0

8000b0d8 <udata_clear_loop>:
8000b0d8:	a1 22       	st.d	r0++,r2
8000b0da:	02 30       	cp.w	r0,r1
8000b0dc:	cf e3       	brcs	8000b0d8 <udata_clear_loop>

8000b0de <udata_clear_loop_end>:
8000b0de:	fe cf 03 16 	sub	pc,pc,790
8000b0e2:	d7 03       	nop

8000b0e4 <free>:
8000b0e4:	d4 01       	pushm	lr
8000b0e6:	e0 68 0a 50 	mov	r8,2640
8000b0ea:	18 9b       	mov	r11,r12
8000b0ec:	70 0c       	ld.w	r12,r8[0x0]
8000b0ee:	e0 a0 1e 7f 	rcall	8000edec <_free_r>
8000b0f2:	d8 02       	popm	pc

8000b0f4 <malloc>:
8000b0f4:	d4 01       	pushm	lr
8000b0f6:	e0 68 0a 50 	mov	r8,2640
8000b0fa:	18 9b       	mov	r11,r12
8000b0fc:	70 0c       	ld.w	r12,r8[0x0]
8000b0fe:	c0 3c       	rcall	8000b104 <_malloc_r>
8000b100:	d8 02       	popm	pc
8000b102:	d7 03       	nop

8000b104 <_malloc_r>:
8000b104:	d4 31       	pushm	r0-r7,lr
8000b106:	f6 c8 ff f5 	sub	r8,r11,-11
8000b10a:	18 95       	mov	r5,r12
8000b10c:	10 97       	mov	r7,r8
8000b10e:	e0 17 ff f8 	andl	r7,0xfff8
8000b112:	59 68       	cp.w	r8,22
8000b114:	f9 b7 08 10 	movls	r7,16
8000b118:	16 37       	cp.w	r7,r11
8000b11a:	5f 38       	srlo	r8
8000b11c:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
8000b120:	c0 50       	breq	8000b12a <_malloc_r+0x26>
8000b122:	30 c8       	mov	r8,12
8000b124:	99 38       	st.w	r12[0xc],r8
8000b126:	e0 8f 01 fa 	bral	8000b51a <_malloc_r+0x416>
8000b12a:	fe b0 eb c9 	rcall	800088bc <__malloc_lock>
8000b12e:	e0 47 01 f7 	cp.w	r7,503
8000b132:	e0 8b 00 1d 	brhi	8000b16c <_malloc_r+0x68>
8000b136:	ee 03 16 03 	lsr	r3,r7,0x3
8000b13a:	e0 68 05 50 	mov	r8,1360
8000b13e:	f0 03 00 38 	add	r8,r8,r3<<0x3
8000b142:	70 36       	ld.w	r6,r8[0xc]
8000b144:	10 36       	cp.w	r6,r8
8000b146:	c0 61       	brne	8000b152 <_malloc_r+0x4e>
8000b148:	ec c8 ff f8 	sub	r8,r6,-8
8000b14c:	70 36       	ld.w	r6,r8[0xc]
8000b14e:	10 36       	cp.w	r6,r8
8000b150:	c0 c0       	breq	8000b168 <_malloc_r+0x64>
8000b152:	6c 18       	ld.w	r8,r6[0x4]
8000b154:	e0 18 ff fc 	andl	r8,0xfffc
8000b158:	6c 3a       	ld.w	r10,r6[0xc]
8000b15a:	ec 08 00 09 	add	r9,r6,r8
8000b15e:	0a 9c       	mov	r12,r5
8000b160:	6c 28       	ld.w	r8,r6[0x8]
8000b162:	95 28       	st.w	r10[0x8],r8
8000b164:	91 3a       	st.w	r8[0xc],r10
8000b166:	c4 78       	rjmp	8000b1f4 <_malloc_r+0xf0>
8000b168:	2f e3       	sub	r3,-2
8000b16a:	c4 d8       	rjmp	8000b204 <_malloc_r+0x100>
8000b16c:	ee 03 16 09 	lsr	r3,r7,0x9
8000b170:	c0 41       	brne	8000b178 <_malloc_r+0x74>
8000b172:	ee 03 16 03 	lsr	r3,r7,0x3
8000b176:	c2 68       	rjmp	8000b1c2 <_malloc_r+0xbe>
8000b178:	58 43       	cp.w	r3,4
8000b17a:	e0 8b 00 06 	brhi	8000b186 <_malloc_r+0x82>
8000b17e:	ee 03 16 06 	lsr	r3,r7,0x6
8000b182:	2c 83       	sub	r3,-56
8000b184:	c1 f8       	rjmp	8000b1c2 <_malloc_r+0xbe>
8000b186:	59 43       	cp.w	r3,20
8000b188:	e0 8b 00 04 	brhi	8000b190 <_malloc_r+0x8c>
8000b18c:	2a 53       	sub	r3,-91
8000b18e:	c1 a8       	rjmp	8000b1c2 <_malloc_r+0xbe>
8000b190:	e0 43 00 54 	cp.w	r3,84
8000b194:	e0 8b 00 06 	brhi	8000b1a0 <_malloc_r+0x9c>
8000b198:	ee 03 16 0c 	lsr	r3,r7,0xc
8000b19c:	29 23       	sub	r3,-110
8000b19e:	c1 28       	rjmp	8000b1c2 <_malloc_r+0xbe>
8000b1a0:	e0 43 01 54 	cp.w	r3,340
8000b1a4:	e0 8b 00 06 	brhi	8000b1b0 <_malloc_r+0xac>
8000b1a8:	ee 03 16 0f 	lsr	r3,r7,0xf
8000b1ac:	28 93       	sub	r3,-119
8000b1ae:	c0 a8       	rjmp	8000b1c2 <_malloc_r+0xbe>
8000b1b0:	e0 43 05 54 	cp.w	r3,1364
8000b1b4:	e0 88 00 04 	brls	8000b1bc <_malloc_r+0xb8>
8000b1b8:	37 e3       	mov	r3,126
8000b1ba:	c0 48       	rjmp	8000b1c2 <_malloc_r+0xbe>
8000b1bc:	ee 03 16 12 	lsr	r3,r7,0x12
8000b1c0:	28 43       	sub	r3,-124
8000b1c2:	e0 6a 05 50 	mov	r10,1360
8000b1c6:	f4 03 00 3a 	add	r10,r10,r3<<0x3
8000b1ca:	74 36       	ld.w	r6,r10[0xc]
8000b1cc:	c1 98       	rjmp	8000b1fe <_malloc_r+0xfa>
8000b1ce:	6c 19       	ld.w	r9,r6[0x4]
8000b1d0:	e0 19 ff fc 	andl	r9,0xfffc
8000b1d4:	f2 07 01 0b 	sub	r11,r9,r7
8000b1d8:	58 fb       	cp.w	r11,15
8000b1da:	e0 8a 00 04 	brle	8000b1e2 <_malloc_r+0xde>
8000b1de:	20 13       	sub	r3,1
8000b1e0:	c1 18       	rjmp	8000b202 <_malloc_r+0xfe>
8000b1e2:	6c 38       	ld.w	r8,r6[0xc]
8000b1e4:	58 0b       	cp.w	r11,0
8000b1e6:	c0 b5       	brlt	8000b1fc <_malloc_r+0xf8>
8000b1e8:	6c 2a       	ld.w	r10,r6[0x8]
8000b1ea:	ec 09 00 09 	add	r9,r6,r9
8000b1ee:	0a 9c       	mov	r12,r5
8000b1f0:	91 2a       	st.w	r8[0x8],r10
8000b1f2:	95 38       	st.w	r10[0xc],r8
8000b1f4:	72 18       	ld.w	r8,r9[0x4]
8000b1f6:	a1 a8       	sbr	r8,0x0
8000b1f8:	93 18       	st.w	r9[0x4],r8
8000b1fa:	cb c8       	rjmp	8000b372 <_malloc_r+0x26e>
8000b1fc:	10 96       	mov	r6,r8
8000b1fe:	14 36       	cp.w	r6,r10
8000b200:	ce 71       	brne	8000b1ce <_malloc_r+0xca>
8000b202:	2f f3       	sub	r3,-1
8000b204:	e0 6a 05 50 	mov	r10,1360
8000b208:	f4 cc ff f8 	sub	r12,r10,-8
8000b20c:	78 26       	ld.w	r6,r12[0x8]
8000b20e:	18 36       	cp.w	r6,r12
8000b210:	c6 c0       	breq	8000b2e8 <_malloc_r+0x1e4>
8000b212:	6c 19       	ld.w	r9,r6[0x4]
8000b214:	e0 19 ff fc 	andl	r9,0xfffc
8000b218:	f2 07 01 08 	sub	r8,r9,r7
8000b21c:	58 f8       	cp.w	r8,15
8000b21e:	e0 89 00 8f 	brgt	8000b33c <_malloc_r+0x238>
8000b222:	99 3c       	st.w	r12[0xc],r12
8000b224:	99 2c       	st.w	r12[0x8],r12
8000b226:	58 08       	cp.w	r8,0
8000b228:	c0 55       	brlt	8000b232 <_malloc_r+0x12e>
8000b22a:	ec 09 00 09 	add	r9,r6,r9
8000b22e:	0a 9c       	mov	r12,r5
8000b230:	ce 2b       	rjmp	8000b1f4 <_malloc_r+0xf0>
8000b232:	e0 49 01 ff 	cp.w	r9,511
8000b236:	e0 8b 00 13 	brhi	8000b25c <_malloc_r+0x158>
8000b23a:	a3 99       	lsr	r9,0x3
8000b23c:	f4 09 00 38 	add	r8,r10,r9<<0x3
8000b240:	70 2b       	ld.w	r11,r8[0x8]
8000b242:	8d 38       	st.w	r6[0xc],r8
8000b244:	8d 2b       	st.w	r6[0x8],r11
8000b246:	97 36       	st.w	r11[0xc],r6
8000b248:	91 26       	st.w	r8[0x8],r6
8000b24a:	a3 49       	asr	r9,0x2
8000b24c:	74 18       	ld.w	r8,r10[0x4]
8000b24e:	30 1b       	mov	r11,1
8000b250:	f6 09 09 49 	lsl	r9,r11,r9
8000b254:	f1 e9 10 09 	or	r9,r8,r9
8000b258:	95 19       	st.w	r10[0x4],r9
8000b25a:	c4 78       	rjmp	8000b2e8 <_malloc_r+0x1e4>
8000b25c:	f2 0a 16 09 	lsr	r10,r9,0x9
8000b260:	58 4a       	cp.w	r10,4
8000b262:	e0 8b 00 07 	brhi	8000b270 <_malloc_r+0x16c>
8000b266:	f2 0a 16 06 	lsr	r10,r9,0x6
8000b26a:	2c 8a       	sub	r10,-56
8000b26c:	c2 08       	rjmp	8000b2ac <_malloc_r+0x1a8>
8000b26e:	d7 03       	nop
8000b270:	59 4a       	cp.w	r10,20
8000b272:	e0 8b 00 04 	brhi	8000b27a <_malloc_r+0x176>
8000b276:	2a 5a       	sub	r10,-91
8000b278:	c1 a8       	rjmp	8000b2ac <_malloc_r+0x1a8>
8000b27a:	e0 4a 00 54 	cp.w	r10,84
8000b27e:	e0 8b 00 06 	brhi	8000b28a <_malloc_r+0x186>
8000b282:	f2 0a 16 0c 	lsr	r10,r9,0xc
8000b286:	29 2a       	sub	r10,-110
8000b288:	c1 28       	rjmp	8000b2ac <_malloc_r+0x1a8>
8000b28a:	e0 4a 01 54 	cp.w	r10,340
8000b28e:	e0 8b 00 06 	brhi	8000b29a <_malloc_r+0x196>
8000b292:	f2 0a 16 0f 	lsr	r10,r9,0xf
8000b296:	28 9a       	sub	r10,-119
8000b298:	c0 a8       	rjmp	8000b2ac <_malloc_r+0x1a8>
8000b29a:	e0 4a 05 54 	cp.w	r10,1364
8000b29e:	e0 88 00 04 	brls	8000b2a6 <_malloc_r+0x1a2>
8000b2a2:	37 ea       	mov	r10,126
8000b2a4:	c0 48       	rjmp	8000b2ac <_malloc_r+0x1a8>
8000b2a6:	f2 0a 16 12 	lsr	r10,r9,0x12
8000b2aa:	28 4a       	sub	r10,-124
8000b2ac:	e0 6b 05 50 	mov	r11,1360
8000b2b0:	f6 0a 00 34 	add	r4,r11,r10<<0x3
8000b2b4:	68 28       	ld.w	r8,r4[0x8]
8000b2b6:	08 38       	cp.w	r8,r4
8000b2b8:	c0 e1       	brne	8000b2d4 <_malloc_r+0x1d0>
8000b2ba:	76 19       	ld.w	r9,r11[0x4]
8000b2bc:	a3 4a       	asr	r10,0x2
8000b2be:	30 1e       	mov	lr,1
8000b2c0:	fc 0a 09 4a 	lsl	r10,lr,r10
8000b2c4:	f3 ea 10 0a 	or	r10,r9,r10
8000b2c8:	10 99       	mov	r9,r8
8000b2ca:	97 1a       	st.w	r11[0x4],r10
8000b2cc:	c0 a8       	rjmp	8000b2e0 <_malloc_r+0x1dc>
8000b2ce:	70 28       	ld.w	r8,r8[0x8]
8000b2d0:	08 38       	cp.w	r8,r4
8000b2d2:	c0 60       	breq	8000b2de <_malloc_r+0x1da>
8000b2d4:	70 1a       	ld.w	r10,r8[0x4]
8000b2d6:	e0 1a ff fc 	andl	r10,0xfffc
8000b2da:	14 39       	cp.w	r9,r10
8000b2dc:	cf 93       	brcs	8000b2ce <_malloc_r+0x1ca>
8000b2de:	70 39       	ld.w	r9,r8[0xc]
8000b2e0:	8d 39       	st.w	r6[0xc],r9
8000b2e2:	8d 28       	st.w	r6[0x8],r8
8000b2e4:	91 36       	st.w	r8[0xc],r6
8000b2e6:	93 26       	st.w	r9[0x8],r6
8000b2e8:	e6 08 14 02 	asr	r8,r3,0x2
8000b2ec:	30 1b       	mov	r11,1
8000b2ee:	e0 64 05 50 	mov	r4,1360
8000b2f2:	f6 08 09 4b 	lsl	r11,r11,r8
8000b2f6:	68 18       	ld.w	r8,r4[0x4]
8000b2f8:	10 3b       	cp.w	r11,r8
8000b2fa:	e0 8b 00 6b 	brhi	8000b3d0 <_malloc_r+0x2cc>
8000b2fe:	f7 e8 00 09 	and	r9,r11,r8
8000b302:	c0 b1       	brne	8000b318 <_malloc_r+0x214>
8000b304:	e0 13 ff fc 	andl	r3,0xfffc
8000b308:	a1 7b       	lsl	r11,0x1
8000b30a:	2f c3       	sub	r3,-4
8000b30c:	c0 38       	rjmp	8000b312 <_malloc_r+0x20e>
8000b30e:	2f c3       	sub	r3,-4
8000b310:	a1 7b       	lsl	r11,0x1
8000b312:	f7 e8 00 09 	and	r9,r11,r8
8000b316:	cf c0       	breq	8000b30e <_malloc_r+0x20a>
8000b318:	e8 03 00 3e 	add	lr,r4,r3<<0x3
8000b31c:	06 92       	mov	r2,r3
8000b31e:	1c 91       	mov	r1,lr
8000b320:	62 36       	ld.w	r6,r1[0xc]
8000b322:	c2 e8       	rjmp	8000b37e <_malloc_r+0x27a>
8000b324:	6c 1a       	ld.w	r10,r6[0x4]
8000b326:	e0 1a ff fc 	andl	r10,0xfffc
8000b32a:	f4 07 01 08 	sub	r8,r10,r7
8000b32e:	58 f8       	cp.w	r8,15
8000b330:	e0 8a 00 15 	brle	8000b35a <_malloc_r+0x256>
8000b334:	6c 3a       	ld.w	r10,r6[0xc]
8000b336:	6c 29       	ld.w	r9,r6[0x8]
8000b338:	95 29       	st.w	r10[0x8],r9
8000b33a:	93 3a       	st.w	r9[0xc],r10
8000b33c:	0e 99       	mov	r9,r7
8000b33e:	ec 07 00 07 	add	r7,r6,r7
8000b342:	a1 a9       	sbr	r9,0x0
8000b344:	99 37       	st.w	r12[0xc],r7
8000b346:	99 27       	st.w	r12[0x8],r7
8000b348:	8d 19       	st.w	r6[0x4],r9
8000b34a:	ee 08 09 08 	st.w	r7[r8],r8
8000b34e:	8f 2c       	st.w	r7[0x8],r12
8000b350:	8f 3c       	st.w	r7[0xc],r12
8000b352:	a1 a8       	sbr	r8,0x0
8000b354:	0a 9c       	mov	r12,r5
8000b356:	8f 18       	st.w	r7[0x4],r8
8000b358:	c0 d8       	rjmp	8000b372 <_malloc_r+0x26e>
8000b35a:	6c 39       	ld.w	r9,r6[0xc]
8000b35c:	58 08       	cp.w	r8,0
8000b35e:	c0 f5       	brlt	8000b37c <_malloc_r+0x278>
8000b360:	ec 0a 00 0a 	add	r10,r6,r10
8000b364:	74 18       	ld.w	r8,r10[0x4]
8000b366:	a1 a8       	sbr	r8,0x0
8000b368:	0a 9c       	mov	r12,r5
8000b36a:	95 18       	st.w	r10[0x4],r8
8000b36c:	6c 28       	ld.w	r8,r6[0x8]
8000b36e:	93 28       	st.w	r9[0x8],r8
8000b370:	91 39       	st.w	r8[0xc],r9
8000b372:	fe b0 ea b3 	rcall	800088d8 <__malloc_unlock>
8000b376:	ec cc ff f8 	sub	r12,r6,-8
8000b37a:	d8 32       	popm	r0-r7,pc
8000b37c:	12 96       	mov	r6,r9
8000b37e:	02 36       	cp.w	r6,r1
8000b380:	cd 21       	brne	8000b324 <_malloc_r+0x220>
8000b382:	2f f2       	sub	r2,-1
8000b384:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
8000b388:	c0 30       	breq	8000b38e <_malloc_r+0x28a>
8000b38a:	2f 81       	sub	r1,-8
8000b38c:	cc ab       	rjmp	8000b320 <_malloc_r+0x21c>
8000b38e:	1c 98       	mov	r8,lr
8000b390:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
8000b394:	c0 81       	brne	8000b3a4 <_malloc_r+0x2a0>
8000b396:	68 19       	ld.w	r9,r4[0x4]
8000b398:	f6 08 11 ff 	rsub	r8,r11,-1
8000b39c:	f3 e8 00 08 	and	r8,r9,r8
8000b3a0:	89 18       	st.w	r4[0x4],r8
8000b3a2:	c0 78       	rjmp	8000b3b0 <_malloc_r+0x2ac>
8000b3a4:	f0 c9 00 08 	sub	r9,r8,8
8000b3a8:	20 13       	sub	r3,1
8000b3aa:	70 08       	ld.w	r8,r8[0x0]
8000b3ac:	12 38       	cp.w	r8,r9
8000b3ae:	cf 10       	breq	8000b390 <_malloc_r+0x28c>
8000b3b0:	a1 7b       	lsl	r11,0x1
8000b3b2:	68 18       	ld.w	r8,r4[0x4]
8000b3b4:	10 3b       	cp.w	r11,r8
8000b3b6:	e0 8b 00 0d 	brhi	8000b3d0 <_malloc_r+0x2cc>
8000b3ba:	58 0b       	cp.w	r11,0
8000b3bc:	c0 a0       	breq	8000b3d0 <_malloc_r+0x2cc>
8000b3be:	04 93       	mov	r3,r2
8000b3c0:	c0 38       	rjmp	8000b3c6 <_malloc_r+0x2c2>
8000b3c2:	2f c3       	sub	r3,-4
8000b3c4:	a1 7b       	lsl	r11,0x1
8000b3c6:	f7 e8 00 09 	and	r9,r11,r8
8000b3ca:	ca 71       	brne	8000b318 <_malloc_r+0x214>
8000b3cc:	cf bb       	rjmp	8000b3c2 <_malloc_r+0x2be>
8000b3ce:	d7 03       	nop
8000b3d0:	68 23       	ld.w	r3,r4[0x8]
8000b3d2:	66 12       	ld.w	r2,r3[0x4]
8000b3d4:	e0 12 ff fc 	andl	r2,0xfffc
8000b3d8:	0e 32       	cp.w	r2,r7
8000b3da:	5f 39       	srlo	r9
8000b3dc:	e4 07 01 08 	sub	r8,r2,r7
8000b3e0:	58 f8       	cp.w	r8,15
8000b3e2:	5f aa       	srle	r10
8000b3e4:	f5 e9 10 09 	or	r9,r10,r9
8000b3e8:	e0 80 00 9a 	breq	8000b51c <_malloc_r+0x418>
8000b3ec:	e0 68 0d 70 	mov	r8,3440
8000b3f0:	70 01       	ld.w	r1,r8[0x0]
8000b3f2:	e0 68 09 5c 	mov	r8,2396
8000b3f6:	2f 01       	sub	r1,-16
8000b3f8:	70 08       	ld.w	r8,r8[0x0]
8000b3fa:	0e 01       	add	r1,r7
8000b3fc:	5b f8       	cp.w	r8,-1
8000b3fe:	c0 40       	breq	8000b406 <_malloc_r+0x302>
8000b400:	28 11       	sub	r1,-127
8000b402:	e0 11 ff 80 	andl	r1,0xff80
8000b406:	02 9b       	mov	r11,r1
8000b408:	0a 9c       	mov	r12,r5
8000b40a:	e0 a0 02 b7 	rcall	8000b978 <_sbrk_r>
8000b40e:	18 96       	mov	r6,r12
8000b410:	5b fc       	cp.w	r12,-1
8000b412:	c7 50       	breq	8000b4fc <_malloc_r+0x3f8>
8000b414:	e6 02 00 08 	add	r8,r3,r2
8000b418:	10 3c       	cp.w	r12,r8
8000b41a:	c0 32       	brcc	8000b420 <_malloc_r+0x31c>
8000b41c:	08 33       	cp.w	r3,r4
8000b41e:	c6 f1       	brne	8000b4fc <_malloc_r+0x3f8>
8000b420:	e0 6a 0d 74 	mov	r10,3444
8000b424:	74 09       	ld.w	r9,r10[0x0]
8000b426:	e2 09 00 09 	add	r9,r1,r9
8000b42a:	95 09       	st.w	r10[0x0],r9
8000b42c:	10 36       	cp.w	r6,r8
8000b42e:	c0 a1       	brne	8000b442 <_malloc_r+0x33e>
8000b430:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
8000b434:	c0 71       	brne	8000b442 <_malloc_r+0x33e>
8000b436:	e2 02 00 02 	add	r2,r1,r2
8000b43a:	68 28       	ld.w	r8,r4[0x8]
8000b43c:	a1 a2       	sbr	r2,0x0
8000b43e:	91 12       	st.w	r8[0x4],r2
8000b440:	c4 f8       	rjmp	8000b4de <_malloc_r+0x3da>
8000b442:	e0 6a 09 5c 	mov	r10,2396
8000b446:	74 0b       	ld.w	r11,r10[0x0]
8000b448:	5b fb       	cp.w	r11,-1
8000b44a:	c0 31       	brne	8000b450 <_malloc_r+0x34c>
8000b44c:	95 06       	st.w	r10[0x0],r6
8000b44e:	c0 78       	rjmp	8000b45c <_malloc_r+0x358>
8000b450:	ec 09 00 09 	add	r9,r6,r9
8000b454:	e0 6a 0d 74 	mov	r10,3444
8000b458:	10 19       	sub	r9,r8
8000b45a:	95 09       	st.w	r10[0x0],r9
8000b45c:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
8000b460:	f0 09 11 08 	rsub	r9,r8,8
8000b464:	58 08       	cp.w	r8,0
8000b466:	f2 08 17 10 	movne	r8,r9
8000b46a:	ed d8 e1 06 	addne	r6,r6,r8
8000b46e:	28 08       	sub	r8,-128
8000b470:	ec 01 00 01 	add	r1,r6,r1
8000b474:	0a 9c       	mov	r12,r5
8000b476:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
8000b47a:	f0 01 01 01 	sub	r1,r8,r1
8000b47e:	02 9b       	mov	r11,r1
8000b480:	e0 a0 02 7c 	rcall	8000b978 <_sbrk_r>
8000b484:	e0 68 0d 74 	mov	r8,3444
8000b488:	5b fc       	cp.w	r12,-1
8000b48a:	ec 0c 17 00 	moveq	r12,r6
8000b48e:	f9 b1 00 00 	moveq	r1,0
8000b492:	70 09       	ld.w	r9,r8[0x0]
8000b494:	0c 1c       	sub	r12,r6
8000b496:	89 26       	st.w	r4[0x8],r6
8000b498:	02 0c       	add	r12,r1
8000b49a:	12 01       	add	r1,r9
8000b49c:	a1 ac       	sbr	r12,0x0
8000b49e:	91 01       	st.w	r8[0x0],r1
8000b4a0:	8d 1c       	st.w	r6[0x4],r12
8000b4a2:	08 33       	cp.w	r3,r4
8000b4a4:	c1 d0       	breq	8000b4de <_malloc_r+0x3da>
8000b4a6:	58 f2       	cp.w	r2,15
8000b4a8:	e0 8b 00 05 	brhi	8000b4b2 <_malloc_r+0x3ae>
8000b4ac:	30 18       	mov	r8,1
8000b4ae:	8d 18       	st.w	r6[0x4],r8
8000b4b0:	c2 68       	rjmp	8000b4fc <_malloc_r+0x3f8>
8000b4b2:	30 59       	mov	r9,5
8000b4b4:	20 c2       	sub	r2,12
8000b4b6:	e0 12 ff f8 	andl	r2,0xfff8
8000b4ba:	e6 02 00 08 	add	r8,r3,r2
8000b4be:	91 29       	st.w	r8[0x8],r9
8000b4c0:	91 19       	st.w	r8[0x4],r9
8000b4c2:	66 18       	ld.w	r8,r3[0x4]
8000b4c4:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000b4c8:	e5 e8 10 08 	or	r8,r2,r8
8000b4cc:	87 18       	st.w	r3[0x4],r8
8000b4ce:	58 f2       	cp.w	r2,15
8000b4d0:	e0 88 00 07 	brls	8000b4de <_malloc_r+0x3da>
8000b4d4:	e6 cb ff f8 	sub	r11,r3,-8
8000b4d8:	0a 9c       	mov	r12,r5
8000b4da:	e0 a0 1c 89 	rcall	8000edec <_free_r>
8000b4de:	e0 69 0d 6c 	mov	r9,3436
8000b4e2:	72 0a       	ld.w	r10,r9[0x0]
8000b4e4:	e0 68 0d 74 	mov	r8,3444
8000b4e8:	70 08       	ld.w	r8,r8[0x0]
8000b4ea:	14 38       	cp.w	r8,r10
8000b4ec:	f3 f8 ba 00 	st.whi	r9[0x0],r8
8000b4f0:	e0 69 0d 68 	mov	r9,3432
8000b4f4:	72 0a       	ld.w	r10,r9[0x0]
8000b4f6:	14 38       	cp.w	r8,r10
8000b4f8:	f3 f8 ba 00 	st.whi	r9[0x0],r8
8000b4fc:	68 28       	ld.w	r8,r4[0x8]
8000b4fe:	70 18       	ld.w	r8,r8[0x4]
8000b500:	e0 18 ff fc 	andl	r8,0xfffc
8000b504:	0e 38       	cp.w	r8,r7
8000b506:	5f 39       	srlo	r9
8000b508:	0e 18       	sub	r8,r7
8000b50a:	58 f8       	cp.w	r8,15
8000b50c:	5f aa       	srle	r10
8000b50e:	f5 e9 10 09 	or	r9,r10,r9
8000b512:	c0 50       	breq	8000b51c <_malloc_r+0x418>
8000b514:	0a 9c       	mov	r12,r5
8000b516:	fe b0 e9 e1 	rcall	800088d8 <__malloc_unlock>
8000b51a:	d8 3a       	popm	r0-r7,pc,r12=0
8000b51c:	68 26       	ld.w	r6,r4[0x8]
8000b51e:	a1 a8       	sbr	r8,0x0
8000b520:	0e 99       	mov	r9,r7
8000b522:	a1 a9       	sbr	r9,0x0
8000b524:	8d 19       	st.w	r6[0x4],r9
8000b526:	ec 07 00 07 	add	r7,r6,r7
8000b52a:	0a 9c       	mov	r12,r5
8000b52c:	89 27       	st.w	r4[0x8],r7
8000b52e:	8f 18       	st.w	r7[0x4],r8
8000b530:	fe b0 e9 d4 	rcall	800088d8 <__malloc_unlock>
8000b534:	ec cc ff f8 	sub	r12,r6,-8
8000b538:	d8 32       	popm	r0-r7,pc
8000b53a:	d7 03       	nop

8000b53c <memcmp>:
8000b53c:	d4 01       	pushm	lr
8000b53e:	30 08       	mov	r8,0
8000b540:	c0 d8       	rjmp	8000b55a <memcmp+0x1e>
8000b542:	f8 08 07 0e 	ld.ub	lr,r12[r8]
8000b546:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000b54a:	20 1a       	sub	r10,1
8000b54c:	2f f8       	sub	r8,-1
8000b54e:	f2 0e 18 00 	cp.b	lr,r9
8000b552:	c0 40       	breq	8000b55a <memcmp+0x1e>
8000b554:	fc 09 01 0c 	sub	r12,lr,r9
8000b558:	d8 02       	popm	pc
8000b55a:	58 0a       	cp.w	r10,0
8000b55c:	cf 31       	brne	8000b542 <memcmp+0x6>
8000b55e:	14 9c       	mov	r12,r10
8000b560:	d8 02       	popm	pc

8000b562 <memcpy>:
8000b562:	58 8a       	cp.w	r10,8
8000b564:	c2 f5       	brlt	8000b5c2 <memcpy+0x60>
8000b566:	f9 eb 10 09 	or	r9,r12,r11
8000b56a:	e2 19 00 03 	andl	r9,0x3,COH
8000b56e:	e0 81 00 97 	brne	8000b69c <memcpy+0x13a>
8000b572:	e0 4a 00 20 	cp.w	r10,32
8000b576:	c3 b4       	brge	8000b5ec <memcpy+0x8a>
8000b578:	f4 08 14 02 	asr	r8,r10,0x2
8000b57c:	f0 09 11 08 	rsub	r9,r8,8
8000b580:	fe 09 00 2f 	add	pc,pc,r9<<0x2
8000b584:	76 69       	ld.w	r9,r11[0x18]
8000b586:	99 69       	st.w	r12[0x18],r9
8000b588:	76 59       	ld.w	r9,r11[0x14]
8000b58a:	99 59       	st.w	r12[0x14],r9
8000b58c:	76 49       	ld.w	r9,r11[0x10]
8000b58e:	99 49       	st.w	r12[0x10],r9
8000b590:	76 39       	ld.w	r9,r11[0xc]
8000b592:	99 39       	st.w	r12[0xc],r9
8000b594:	76 29       	ld.w	r9,r11[0x8]
8000b596:	99 29       	st.w	r12[0x8],r9
8000b598:	76 19       	ld.w	r9,r11[0x4]
8000b59a:	99 19       	st.w	r12[0x4],r9
8000b59c:	76 09       	ld.w	r9,r11[0x0]
8000b59e:	99 09       	st.w	r12[0x0],r9
8000b5a0:	f6 08 00 2b 	add	r11,r11,r8<<0x2
8000b5a4:	f8 08 00 28 	add	r8,r12,r8<<0x2
8000b5a8:	e0 1a 00 03 	andl	r10,0x3
8000b5ac:	f4 0a 11 04 	rsub	r10,r10,4
8000b5b0:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
8000b5b4:	17 a9       	ld.ub	r9,r11[0x2]
8000b5b6:	b0 a9       	st.b	r8[0x2],r9
8000b5b8:	17 99       	ld.ub	r9,r11[0x1]
8000b5ba:	b0 99       	st.b	r8[0x1],r9
8000b5bc:	17 89       	ld.ub	r9,r11[0x0]
8000b5be:	b0 89       	st.b	r8[0x0],r9
8000b5c0:	5e fc       	retal	r12
8000b5c2:	f4 0a 11 09 	rsub	r10,r10,9
8000b5c6:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
8000b5ca:	17 f9       	ld.ub	r9,r11[0x7]
8000b5cc:	b8 f9       	st.b	r12[0x7],r9
8000b5ce:	17 e9       	ld.ub	r9,r11[0x6]
8000b5d0:	b8 e9       	st.b	r12[0x6],r9
8000b5d2:	17 d9       	ld.ub	r9,r11[0x5]
8000b5d4:	b8 d9       	st.b	r12[0x5],r9
8000b5d6:	17 c9       	ld.ub	r9,r11[0x4]
8000b5d8:	b8 c9       	st.b	r12[0x4],r9
8000b5da:	17 b9       	ld.ub	r9,r11[0x3]
8000b5dc:	b8 b9       	st.b	r12[0x3],r9
8000b5de:	17 a9       	ld.ub	r9,r11[0x2]
8000b5e0:	b8 a9       	st.b	r12[0x2],r9
8000b5e2:	17 99       	ld.ub	r9,r11[0x1]
8000b5e4:	b8 99       	st.b	r12[0x1],r9
8000b5e6:	17 89       	ld.ub	r9,r11[0x0]
8000b5e8:	b8 89       	st.b	r12[0x0],r9
8000b5ea:	5e fc       	retal	r12
8000b5ec:	eb cd 40 c0 	pushm	r6-r7,lr
8000b5f0:	18 99       	mov	r9,r12
8000b5f2:	22 0a       	sub	r10,32
8000b5f4:	b7 07       	ld.d	r6,r11++
8000b5f6:	b3 26       	st.d	r9++,r6
8000b5f8:	b7 07       	ld.d	r6,r11++
8000b5fa:	b3 26       	st.d	r9++,r6
8000b5fc:	b7 07       	ld.d	r6,r11++
8000b5fe:	b3 26       	st.d	r9++,r6
8000b600:	b7 07       	ld.d	r6,r11++
8000b602:	b3 26       	st.d	r9++,r6
8000b604:	22 0a       	sub	r10,32
8000b606:	cf 74       	brge	8000b5f4 <memcpy+0x92>
8000b608:	2f 0a       	sub	r10,-16
8000b60a:	c0 65       	brlt	8000b616 <memcpy+0xb4>
8000b60c:	b7 07       	ld.d	r6,r11++
8000b60e:	b3 26       	st.d	r9++,r6
8000b610:	b7 07       	ld.d	r6,r11++
8000b612:	b3 26       	st.d	r9++,r6
8000b614:	21 0a       	sub	r10,16
8000b616:	5c 3a       	neg	r10
8000b618:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
8000b61c:	d7 03       	nop
8000b61e:	d7 03       	nop
8000b620:	f7 36 00 0e 	ld.ub	r6,r11[14]
8000b624:	f3 66 00 0e 	st.b	r9[14],r6
8000b628:	f7 36 00 0d 	ld.ub	r6,r11[13]
8000b62c:	f3 66 00 0d 	st.b	r9[13],r6
8000b630:	f7 36 00 0c 	ld.ub	r6,r11[12]
8000b634:	f3 66 00 0c 	st.b	r9[12],r6
8000b638:	f7 36 00 0b 	ld.ub	r6,r11[11]
8000b63c:	f3 66 00 0b 	st.b	r9[11],r6
8000b640:	f7 36 00 0a 	ld.ub	r6,r11[10]
8000b644:	f3 66 00 0a 	st.b	r9[10],r6
8000b648:	f7 36 00 09 	ld.ub	r6,r11[9]
8000b64c:	f3 66 00 09 	st.b	r9[9],r6
8000b650:	f7 36 00 08 	ld.ub	r6,r11[8]
8000b654:	f3 66 00 08 	st.b	r9[8],r6
8000b658:	f7 36 00 07 	ld.ub	r6,r11[7]
8000b65c:	f3 66 00 07 	st.b	r9[7],r6
8000b660:	f7 36 00 06 	ld.ub	r6,r11[6]
8000b664:	f3 66 00 06 	st.b	r9[6],r6
8000b668:	f7 36 00 05 	ld.ub	r6,r11[5]
8000b66c:	f3 66 00 05 	st.b	r9[5],r6
8000b670:	f7 36 00 04 	ld.ub	r6,r11[4]
8000b674:	f3 66 00 04 	st.b	r9[4],r6
8000b678:	f7 36 00 03 	ld.ub	r6,r11[3]
8000b67c:	f3 66 00 03 	st.b	r9[3],r6
8000b680:	f7 36 00 02 	ld.ub	r6,r11[2]
8000b684:	f3 66 00 02 	st.b	r9[2],r6
8000b688:	f7 36 00 01 	ld.ub	r6,r11[1]
8000b68c:	f3 66 00 01 	st.b	r9[1],r6
8000b690:	f7 36 00 00 	ld.ub	r6,r11[0]
8000b694:	f3 66 00 00 	st.b	r9[0],r6
8000b698:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000b69c:	20 1a       	sub	r10,1
8000b69e:	f6 0a 07 09 	ld.ub	r9,r11[r10]
8000b6a2:	f8 0a 0b 09 	st.b	r12[r10],r9
8000b6a6:	cf b1       	brne	8000b69c <memcpy+0x13a>
8000b6a8:	5e fc       	retal	r12

8000b6aa <memset>:
8000b6aa:	18 98       	mov	r8,r12
8000b6ac:	c0 38       	rjmp	8000b6b2 <memset+0x8>
8000b6ae:	10 cb       	st.b	r8++,r11
8000b6b0:	20 1a       	sub	r10,1
8000b6b2:	58 0a       	cp.w	r10,0
8000b6b4:	cf d1       	brne	8000b6ae <memset+0x4>
8000b6b6:	5e fc       	retal	r12

8000b6b8 <_realloc_r>:
8000b6b8:	d4 31       	pushm	r0-r7,lr
8000b6ba:	20 1d       	sub	sp,4
8000b6bc:	16 94       	mov	r4,r11
8000b6be:	18 92       	mov	r2,r12
8000b6c0:	14 9b       	mov	r11,r10
8000b6c2:	58 04       	cp.w	r4,0
8000b6c4:	c0 51       	brne	8000b6ce <_realloc_r+0x16>
8000b6c6:	fe b0 fd 1f 	rcall	8000b104 <_malloc_r>
8000b6ca:	18 95       	mov	r5,r12
8000b6cc:	c5 39       	rjmp	8000b972 <_realloc_r+0x2ba>
8000b6ce:	50 0a       	stdsp	sp[0x0],r10
8000b6d0:	fe b0 e8 f6 	rcall	800088bc <__malloc_lock>
8000b6d4:	40 0b       	lddsp	r11,sp[0x0]
8000b6d6:	f6 c8 ff f5 	sub	r8,r11,-11
8000b6da:	e8 c1 00 08 	sub	r1,r4,8
8000b6de:	10 96       	mov	r6,r8
8000b6e0:	62 1c       	ld.w	r12,r1[0x4]
8000b6e2:	e0 16 ff f8 	andl	r6,0xfff8
8000b6e6:	59 68       	cp.w	r8,22
8000b6e8:	f9 b6 08 10 	movls	r6,16
8000b6ec:	16 36       	cp.w	r6,r11
8000b6ee:	5f 38       	srlo	r8
8000b6f0:	f1 e6 13 f8 	or	r8,r8,r6>>0x1f
8000b6f4:	c0 50       	breq	8000b6fe <_realloc_r+0x46>
8000b6f6:	30 c8       	mov	r8,12
8000b6f8:	30 05       	mov	r5,0
8000b6fa:	85 38       	st.w	r2[0xc],r8
8000b6fc:	c3 b9       	rjmp	8000b972 <_realloc_r+0x2ba>
8000b6fe:	18 90       	mov	r0,r12
8000b700:	e0 10 ff fc 	andl	r0,0xfffc
8000b704:	0c 30       	cp.w	r0,r6
8000b706:	e0 84 01 0b 	brge	8000b91c <_realloc_r+0x264>
8000b70a:	e0 68 05 50 	mov	r8,1360
8000b70e:	e2 00 00 09 	add	r9,r1,r0
8000b712:	70 25       	ld.w	r5,r8[0x8]
8000b714:	0a 39       	cp.w	r9,r5
8000b716:	c0 90       	breq	8000b728 <_realloc_r+0x70>
8000b718:	72 1a       	ld.w	r10,r9[0x4]
8000b71a:	a1 ca       	cbr	r10,0x0
8000b71c:	f2 0a 00 0a 	add	r10,r9,r10
8000b720:	74 1a       	ld.w	r10,r10[0x4]
8000b722:	ed ba 00 00 	bld	r10,0x0
8000b726:	c2 20       	breq	8000b76a <_realloc_r+0xb2>
8000b728:	72 1a       	ld.w	r10,r9[0x4]
8000b72a:	e0 1a ff fc 	andl	r10,0xfffc
8000b72e:	f4 00 00 03 	add	r3,r10,r0
8000b732:	0a 39       	cp.w	r9,r5
8000b734:	c1 31       	brne	8000b75a <_realloc_r+0xa2>
8000b736:	ec c7 ff f0 	sub	r7,r6,-16
8000b73a:	0e 33       	cp.w	r3,r7
8000b73c:	c1 95       	brlt	8000b76e <_realloc_r+0xb6>
8000b73e:	e2 06 00 09 	add	r9,r1,r6
8000b742:	0c 13       	sub	r3,r6
8000b744:	a1 a3       	sbr	r3,0x0
8000b746:	93 13       	st.w	r9[0x4],r3
8000b748:	91 29       	st.w	r8[0x8],r9
8000b74a:	04 9c       	mov	r12,r2
8000b74c:	62 18       	ld.w	r8,r1[0x4]
8000b74e:	08 95       	mov	r5,r4
8000b750:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000b754:	10 46       	or	r6,r8
8000b756:	83 16       	st.w	r1[0x4],r6
8000b758:	c0 b9       	rjmp	8000b96e <_realloc_r+0x2b6>
8000b75a:	0c 33       	cp.w	r3,r6
8000b75c:	c0 95       	brlt	8000b76e <_realloc_r+0xb6>
8000b75e:	72 28       	ld.w	r8,r9[0x8]
8000b760:	02 97       	mov	r7,r1
8000b762:	72 39       	ld.w	r9,r9[0xc]
8000b764:	93 28       	st.w	r9[0x8],r8
8000b766:	91 39       	st.w	r8[0xc],r9
8000b768:	cd c8       	rjmp	8000b920 <_realloc_r+0x268>
8000b76a:	30 0a       	mov	r10,0
8000b76c:	14 99       	mov	r9,r10
8000b76e:	ed bc 00 00 	bld	r12,0x0
8000b772:	e0 80 00 95 	breq	8000b89c <_realloc_r+0x1e4>
8000b776:	62 07       	ld.w	r7,r1[0x0]
8000b778:	e2 07 01 07 	sub	r7,r1,r7
8000b77c:	6e 1c       	ld.w	r12,r7[0x4]
8000b77e:	e0 1c ff fc 	andl	r12,0xfffc
8000b782:	58 09       	cp.w	r9,0
8000b784:	c5 60       	breq	8000b830 <_realloc_r+0x178>
8000b786:	f8 00 00 03 	add	r3,r12,r0
8000b78a:	0a 39       	cp.w	r9,r5
8000b78c:	c4 81       	brne	8000b81c <_realloc_r+0x164>
8000b78e:	14 03       	add	r3,r10
8000b790:	ec c9 ff f0 	sub	r9,r6,-16
8000b794:	12 33       	cp.w	r3,r9
8000b796:	c4 d5       	brlt	8000b830 <_realloc_r+0x178>
8000b798:	6e 3a       	ld.w	r10,r7[0xc]
8000b79a:	6e 29       	ld.w	r9,r7[0x8]
8000b79c:	95 29       	st.w	r10[0x8],r9
8000b79e:	93 3a       	st.w	r9[0xc],r10
8000b7a0:	ee c5 ff f8 	sub	r5,r7,-8
8000b7a4:	e0 ca 00 04 	sub	r10,r0,4
8000b7a8:	e0 4a 00 24 	cp.w	r10,36
8000b7ac:	e0 8b 00 25 	brhi	8000b7f6 <_realloc_r+0x13e>
8000b7b0:	0a 99       	mov	r9,r5
8000b7b2:	59 3a       	cp.w	r10,19
8000b7b4:	e0 88 00 1a 	brls	8000b7e8 <_realloc_r+0x130>
8000b7b8:	09 09       	ld.w	r9,r4++
8000b7ba:	8b 09       	st.w	r5[0x0],r9
8000b7bc:	09 09       	ld.w	r9,r4++
8000b7be:	8f 39       	st.w	r7[0xc],r9
8000b7c0:	ee c9 ff f0 	sub	r9,r7,-16
8000b7c4:	59 ba       	cp.w	r10,27
8000b7c6:	e0 88 00 11 	brls	8000b7e8 <_realloc_r+0x130>
8000b7ca:	09 0b       	ld.w	r11,r4++
8000b7cc:	93 0b       	st.w	r9[0x0],r11
8000b7ce:	09 09       	ld.w	r9,r4++
8000b7d0:	8f 59       	st.w	r7[0x14],r9
8000b7d2:	ee c9 ff e8 	sub	r9,r7,-24
8000b7d6:	e0 4a 00 24 	cp.w	r10,36
8000b7da:	c0 71       	brne	8000b7e8 <_realloc_r+0x130>
8000b7dc:	09 0a       	ld.w	r10,r4++
8000b7de:	93 0a       	st.w	r9[0x0],r10
8000b7e0:	ee c9 ff e0 	sub	r9,r7,-32
8000b7e4:	09 0a       	ld.w	r10,r4++
8000b7e6:	8f 7a       	st.w	r7[0x1c],r10
8000b7e8:	09 0a       	ld.w	r10,r4++
8000b7ea:	12 aa       	st.w	r9++,r10
8000b7ec:	68 0a       	ld.w	r10,r4[0x0]
8000b7ee:	93 0a       	st.w	r9[0x0],r10
8000b7f0:	68 1a       	ld.w	r10,r4[0x4]
8000b7f2:	93 1a       	st.w	r9[0x4],r10
8000b7f4:	c0 78       	rjmp	8000b802 <_realloc_r+0x14a>
8000b7f6:	50 08       	stdsp	sp[0x0],r8
8000b7f8:	08 9b       	mov	r11,r4
8000b7fa:	0a 9c       	mov	r12,r5
8000b7fc:	e0 a0 1d 9b 	rcall	8000f332 <memmove>
8000b800:	40 08       	lddsp	r8,sp[0x0]
8000b802:	ee 06 00 09 	add	r9,r7,r6
8000b806:	0c 13       	sub	r3,r6
8000b808:	a1 a3       	sbr	r3,0x0
8000b80a:	93 13       	st.w	r9[0x4],r3
8000b80c:	91 29       	st.w	r8[0x8],r9
8000b80e:	04 9c       	mov	r12,r2
8000b810:	6e 18       	ld.w	r8,r7[0x4]
8000b812:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000b816:	10 46       	or	r6,r8
8000b818:	8f 16       	st.w	r7[0x4],r6
8000b81a:	ca a8       	rjmp	8000b96e <_realloc_r+0x2b6>
8000b81c:	14 03       	add	r3,r10
8000b81e:	0c 33       	cp.w	r3,r6
8000b820:	c0 85       	brlt	8000b830 <_realloc_r+0x178>
8000b822:	72 28       	ld.w	r8,r9[0x8]
8000b824:	72 39       	ld.w	r9,r9[0xc]
8000b826:	93 28       	st.w	r9[0x8],r8
8000b828:	91 39       	st.w	r8[0xc],r9
8000b82a:	6e 28       	ld.w	r8,r7[0x8]
8000b82c:	6e 39       	ld.w	r9,r7[0xc]
8000b82e:	c0 78       	rjmp	8000b83c <_realloc_r+0x184>
8000b830:	f8 00 00 03 	add	r3,r12,r0
8000b834:	0c 33       	cp.w	r3,r6
8000b836:	c3 35       	brlt	8000b89c <_realloc_r+0x1e4>
8000b838:	6e 39       	ld.w	r9,r7[0xc]
8000b83a:	6e 28       	ld.w	r8,r7[0x8]
8000b83c:	93 28       	st.w	r9[0x8],r8
8000b83e:	91 39       	st.w	r8[0xc],r9
8000b840:	e0 ca 00 04 	sub	r10,r0,4
8000b844:	ee cc ff f8 	sub	r12,r7,-8
8000b848:	e0 4a 00 24 	cp.w	r10,36
8000b84c:	e0 8b 00 24 	brhi	8000b894 <_realloc_r+0x1dc>
8000b850:	59 3a       	cp.w	r10,19
8000b852:	e0 88 00 1a 	brls	8000b886 <_realloc_r+0x1ce>
8000b856:	09 08       	ld.w	r8,r4++
8000b858:	99 08       	st.w	r12[0x0],r8
8000b85a:	09 08       	ld.w	r8,r4++
8000b85c:	8f 38       	st.w	r7[0xc],r8
8000b85e:	ee cc ff f0 	sub	r12,r7,-16
8000b862:	59 ba       	cp.w	r10,27
8000b864:	e0 88 00 11 	brls	8000b886 <_realloc_r+0x1ce>
8000b868:	09 08       	ld.w	r8,r4++
8000b86a:	99 08       	st.w	r12[0x0],r8
8000b86c:	09 08       	ld.w	r8,r4++
8000b86e:	8f 58       	st.w	r7[0x14],r8
8000b870:	ee cc ff e8 	sub	r12,r7,-24
8000b874:	e0 4a 00 24 	cp.w	r10,36
8000b878:	c0 71       	brne	8000b886 <_realloc_r+0x1ce>
8000b87a:	09 08       	ld.w	r8,r4++
8000b87c:	99 08       	st.w	r12[0x0],r8
8000b87e:	ee cc ff e0 	sub	r12,r7,-32
8000b882:	09 08       	ld.w	r8,r4++
8000b884:	8f 78       	st.w	r7[0x1c],r8
8000b886:	09 08       	ld.w	r8,r4++
8000b888:	18 a8       	st.w	r12++,r8
8000b88a:	68 08       	ld.w	r8,r4[0x0]
8000b88c:	99 08       	st.w	r12[0x0],r8
8000b88e:	68 18       	ld.w	r8,r4[0x4]
8000b890:	99 18       	st.w	r12[0x4],r8
8000b892:	c4 78       	rjmp	8000b920 <_realloc_r+0x268>
8000b894:	08 9b       	mov	r11,r4
8000b896:	e0 a0 1d 4e 	rcall	8000f332 <memmove>
8000b89a:	c4 38       	rjmp	8000b920 <_realloc_r+0x268>
8000b89c:	04 9c       	mov	r12,r2
8000b89e:	fe b0 fc 33 	rcall	8000b104 <_malloc_r>
8000b8a2:	18 95       	mov	r5,r12
8000b8a4:	c3 a0       	breq	8000b918 <_realloc_r+0x260>
8000b8a6:	62 18       	ld.w	r8,r1[0x4]
8000b8a8:	f8 c9 00 08 	sub	r9,r12,8
8000b8ac:	a1 c8       	cbr	r8,0x0
8000b8ae:	e2 08 00 08 	add	r8,r1,r8
8000b8b2:	10 39       	cp.w	r9,r8
8000b8b4:	c0 71       	brne	8000b8c2 <_realloc_r+0x20a>
8000b8b6:	72 13       	ld.w	r3,r9[0x4]
8000b8b8:	02 97       	mov	r7,r1
8000b8ba:	e0 13 ff fc 	andl	r3,0xfffc
8000b8be:	00 03       	add	r3,r0
8000b8c0:	c3 08       	rjmp	8000b920 <_realloc_r+0x268>
8000b8c2:	e0 ca 00 04 	sub	r10,r0,4
8000b8c6:	e0 4a 00 24 	cp.w	r10,36
8000b8ca:	e0 8b 00 20 	brhi	8000b90a <_realloc_r+0x252>
8000b8ce:	08 99       	mov	r9,r4
8000b8d0:	18 98       	mov	r8,r12
8000b8d2:	59 3a       	cp.w	r10,19
8000b8d4:	e0 88 00 14 	brls	8000b8fc <_realloc_r+0x244>
8000b8d8:	13 0b       	ld.w	r11,r9++
8000b8da:	10 ab       	st.w	r8++,r11
8000b8dc:	13 0b       	ld.w	r11,r9++
8000b8de:	10 ab       	st.w	r8++,r11
8000b8e0:	59 ba       	cp.w	r10,27
8000b8e2:	e0 88 00 0d 	brls	8000b8fc <_realloc_r+0x244>
8000b8e6:	13 0b       	ld.w	r11,r9++
8000b8e8:	10 ab       	st.w	r8++,r11
8000b8ea:	13 0b       	ld.w	r11,r9++
8000b8ec:	10 ab       	st.w	r8++,r11
8000b8ee:	e0 4a 00 24 	cp.w	r10,36
8000b8f2:	c0 51       	brne	8000b8fc <_realloc_r+0x244>
8000b8f4:	13 0a       	ld.w	r10,r9++
8000b8f6:	10 aa       	st.w	r8++,r10
8000b8f8:	13 0a       	ld.w	r10,r9++
8000b8fa:	10 aa       	st.w	r8++,r10
8000b8fc:	13 0a       	ld.w	r10,r9++
8000b8fe:	10 aa       	st.w	r8++,r10
8000b900:	72 0a       	ld.w	r10,r9[0x0]
8000b902:	91 0a       	st.w	r8[0x0],r10
8000b904:	72 19       	ld.w	r9,r9[0x4]
8000b906:	91 19       	st.w	r8[0x4],r9
8000b908:	c0 48       	rjmp	8000b910 <_realloc_r+0x258>
8000b90a:	08 9b       	mov	r11,r4
8000b90c:	e0 a0 1d 13 	rcall	8000f332 <memmove>
8000b910:	08 9b       	mov	r11,r4
8000b912:	04 9c       	mov	r12,r2
8000b914:	e0 a0 1a 6c 	rcall	8000edec <_free_r>
8000b918:	04 9c       	mov	r12,r2
8000b91a:	c2 a8       	rjmp	8000b96e <_realloc_r+0x2b6>
8000b91c:	00 93       	mov	r3,r0
8000b91e:	02 97       	mov	r7,r1
8000b920:	e6 06 01 09 	sub	r9,r3,r6
8000b924:	6e 18       	ld.w	r8,r7[0x4]
8000b926:	58 f9       	cp.w	r9,15
8000b928:	e0 88 00 16 	brls	8000b954 <_realloc_r+0x29c>
8000b92c:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000b930:	ed e8 10 08 	or	r8,r6,r8
8000b934:	8f 18       	st.w	r7[0x4],r8
8000b936:	12 98       	mov	r8,r9
8000b938:	a1 a8       	sbr	r8,0x0
8000b93a:	ee 06 00 0b 	add	r11,r7,r6
8000b93e:	f6 09 00 09 	add	r9,r11,r9
8000b942:	97 18       	st.w	r11[0x4],r8
8000b944:	72 18       	ld.w	r8,r9[0x4]
8000b946:	a1 a8       	sbr	r8,0x0
8000b948:	2f 8b       	sub	r11,-8
8000b94a:	93 18       	st.w	r9[0x4],r8
8000b94c:	04 9c       	mov	r12,r2
8000b94e:	e0 a0 1a 4f 	rcall	8000edec <_free_r>
8000b952:	c0 b8       	rjmp	8000b968 <_realloc_r+0x2b0>
8000b954:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000b958:	e7 e8 10 08 	or	r8,r3,r8
8000b95c:	8f 18       	st.w	r7[0x4],r8
8000b95e:	ee 03 00 03 	add	r3,r7,r3
8000b962:	66 18       	ld.w	r8,r3[0x4]
8000b964:	a1 a8       	sbr	r8,0x0
8000b966:	87 18       	st.w	r3[0x4],r8
8000b968:	04 9c       	mov	r12,r2
8000b96a:	ee c5 ff f8 	sub	r5,r7,-8
8000b96e:	fe b0 e7 b5 	rcall	800088d8 <__malloc_unlock>
8000b972:	0a 9c       	mov	r12,r5
8000b974:	2f fd       	sub	sp,-4
8000b976:	d8 32       	popm	r0-r7,pc

8000b978 <_sbrk_r>:
8000b978:	d4 21       	pushm	r4-r7,lr
8000b97a:	30 08       	mov	r8,0
8000b97c:	18 97       	mov	r7,r12
8000b97e:	e0 66 53 24 	mov	r6,21284
8000b982:	16 9c       	mov	r12,r11
8000b984:	8d 08       	st.w	r6[0x0],r8
8000b986:	c9 1c       	rcall	8000baa8 <_sbrk>
8000b988:	5b fc       	cp.w	r12,-1
8000b98a:	c0 51       	brne	8000b994 <_sbrk_r+0x1c>
8000b98c:	6c 08       	ld.w	r8,r6[0x0]
8000b98e:	58 08       	cp.w	r8,0
8000b990:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b994:	d8 22       	popm	r4-r7,pc
8000b996:	d7 03       	nop

8000b998 <sprintf>:
8000b998:	d4 01       	pushm	lr
8000b99a:	21 7d       	sub	sp,92
8000b99c:	e0 68 ff ff 	mov	r8,65535
8000b9a0:	ea 18 7f ff 	orh	r8,0x7fff
8000b9a4:	50 58       	stdsp	sp[0x14],r8
8000b9a6:	50 28       	stdsp	sp[0x8],r8
8000b9a8:	e0 68 02 08 	mov	r8,520
8000b9ac:	ba 68       	st.h	sp[0xc],r8
8000b9ae:	3f f8       	mov	r8,-1
8000b9b0:	ba 78       	st.h	sp[0xe],r8
8000b9b2:	e0 68 0a 50 	mov	r8,2640
8000b9b6:	50 4c       	stdsp	sp[0x10],r12
8000b9b8:	16 9a       	mov	r10,r11
8000b9ba:	50 0c       	stdsp	sp[0x0],r12
8000b9bc:	fa c9 ff a0 	sub	r9,sp,-96
8000b9c0:	70 0c       	ld.w	r12,r8[0x0]
8000b9c2:	1a 9b       	mov	r11,sp
8000b9c4:	e0 a0 02 26 	rcall	8000be10 <_vfprintf_r>
8000b9c8:	30 09       	mov	r9,0
8000b9ca:	40 08       	lddsp	r8,sp[0x0]
8000b9cc:	b0 89       	st.b	r8[0x0],r9
8000b9ce:	2e 9d       	sub	sp,-92
8000b9d0:	d8 02       	popm	pc
8000b9d2:	d7 03       	nop

8000b9d4 <strlen>:
8000b9d4:	30 09       	mov	r9,0
8000b9d6:	18 98       	mov	r8,r12
8000b9d8:	c0 28       	rjmp	8000b9dc <strlen+0x8>
8000b9da:	2f f8       	sub	r8,-1
8000b9dc:	11 8a       	ld.ub	r10,r8[0x0]
8000b9de:	f2 0a 18 00 	cp.b	r10,r9
8000b9e2:	cf c1       	brne	8000b9da <strlen+0x6>
8000b9e4:	f0 0c 01 0c 	sub	r12,r8,r12
8000b9e8:	5e fc       	retal	r12
8000b9ea:	d7 03       	nop

8000b9ec <strncpy>:
8000b9ec:	30 08       	mov	r8,0
8000b9ee:	10 3a       	cp.w	r10,r8
8000b9f0:	5e 0c       	reteq	r12
8000b9f2:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000b9f6:	f8 08 0b 09 	st.b	r12[r8],r9
8000b9fa:	2f f8       	sub	r8,-1
8000b9fc:	58 09       	cp.w	r9,0
8000b9fe:	cf 81       	brne	8000b9ee <strncpy+0x2>
8000ba00:	10 3a       	cp.w	r10,r8
8000ba02:	5e 0c       	reteq	r12
8000ba04:	f8 08 0b 09 	st.b	r12[r8],r9
8000ba08:	2f f8       	sub	r8,-1
8000ba0a:	cf bb       	rjmp	8000ba00 <strncpy+0x14>

8000ba0c <_close>:
8000ba0c:	30 28       	mov	r8,2
8000ba0e:	d6 73       	breakpoint
8000ba10:	3f fc       	mov	r12,-1
8000ba12:	35 8b       	mov	r11,88
8000ba14:	58 0c       	cp.w	r12,0
8000ba16:	5e 4c       	retge	r12
8000ba18:	e0 6a 53 24 	mov	r10,21284
8000ba1c:	95 0b       	st.w	r10[0x0],r11
8000ba1e:	5e fc       	retal	r12

8000ba20 <_lseek>:
8000ba20:	30 58       	mov	r8,5
8000ba22:	d6 73       	breakpoint
8000ba24:	3f fc       	mov	r12,-1
8000ba26:	35 8b       	mov	r11,88
8000ba28:	58 0c       	cp.w	r12,0
8000ba2a:	5e 4c       	retge	r12
8000ba2c:	e0 6a 53 24 	mov	r10,21284
8000ba30:	95 0b       	st.w	r10[0x0],r11
8000ba32:	5e fc       	retal	r12

8000ba34 <isatty>:
8000ba34:	30 b8       	mov	r8,11
8000ba36:	d6 73       	breakpoint
8000ba38:	3f fc       	mov	r12,-1
8000ba3a:	35 8b       	mov	r11,88
8000ba3c:	58 0c       	cp.w	r12,0
8000ba3e:	5e 4c       	retge	r12
8000ba40:	e0 6a 53 24 	mov	r10,21284
8000ba44:	95 0b       	st.w	r10[0x0],r11
8000ba46:	5e fc       	retal	r12

8000ba48 <_fstat_host>:
8000ba48:	30 98       	mov	r8,9
8000ba4a:	d6 73       	breakpoint
8000ba4c:	3f fc       	mov	r12,-1
8000ba4e:	35 8b       	mov	r11,88
8000ba50:	58 0c       	cp.w	r12,0
8000ba52:	5e 4c       	retge	r12
8000ba54:	e0 6a 53 24 	mov	r10,21284
8000ba58:	95 0b       	st.w	r10[0x0],r11
8000ba5a:	5e fc       	retal	r12

8000ba5c <_fstat>:
8000ba5c:	d4 21       	pushm	r4-r7,lr
8000ba5e:	21 0d       	sub	sp,64
8000ba60:	16 97       	mov	r7,r11
8000ba62:	1a 9b       	mov	r11,sp
8000ba64:	cf 2f       	rcall	8000ba48 <_fstat_host>
8000ba66:	c0 34       	brge	8000ba6c <_fstat+0x10>
8000ba68:	3f fc       	mov	r12,-1
8000ba6a:	c1 c8       	rjmp	8000baa2 <_fstat+0x46>
8000ba6c:	40 08       	lddsp	r8,sp[0x0]
8000ba6e:	ae 08       	st.h	r7[0x0],r8
8000ba70:	40 18       	lddsp	r8,sp[0x4]
8000ba72:	ae 18       	st.h	r7[0x2],r8
8000ba74:	40 28       	lddsp	r8,sp[0x8]
8000ba76:	8f 18       	st.w	r7[0x4],r8
8000ba78:	40 38       	lddsp	r8,sp[0xc]
8000ba7a:	ae 48       	st.h	r7[0x8],r8
8000ba7c:	40 48       	lddsp	r8,sp[0x10]
8000ba7e:	ae 58       	st.h	r7[0xa],r8
8000ba80:	40 58       	lddsp	r8,sp[0x14]
8000ba82:	ae 68       	st.h	r7[0xc],r8
8000ba84:	40 68       	lddsp	r8,sp[0x18]
8000ba86:	ae 78       	st.h	r7[0xe],r8
8000ba88:	40 88       	lddsp	r8,sp[0x20]
8000ba8a:	8f 48       	st.w	r7[0x10],r8
8000ba8c:	40 a8       	lddsp	r8,sp[0x28]
8000ba8e:	8f b8       	st.w	r7[0x2c],r8
8000ba90:	40 c8       	lddsp	r8,sp[0x30]
8000ba92:	8f c8       	st.w	r7[0x30],r8
8000ba94:	40 d8       	lddsp	r8,sp[0x34]
8000ba96:	8f 58       	st.w	r7[0x14],r8
8000ba98:	40 e8       	lddsp	r8,sp[0x38]
8000ba9a:	30 0c       	mov	r12,0
8000ba9c:	8f 78       	st.w	r7[0x1c],r8
8000ba9e:	40 f8       	lddsp	r8,sp[0x3c]
8000baa0:	8f 98       	st.w	r7[0x24],r8
8000baa2:	2f 0d       	sub	sp,-64
8000baa4:	d8 22       	popm	r4-r7,pc
8000baa6:	d7 03       	nop

8000baa8 <_sbrk>:
8000baa8:	d4 01       	pushm	lr
8000baaa:	e0 68 0d 9c 	mov	r8,3484
8000baae:	70 09       	ld.w	r9,r8[0x0]
8000bab0:	58 09       	cp.w	r9,0
8000bab2:	c0 41       	brne	8000baba <_sbrk+0x12>
8000bab4:	e0 69 53 28 	mov	r9,21288
8000bab8:	91 09       	st.w	r8[0x0],r9
8000baba:	e0 69 0d 9c 	mov	r9,3484
8000babe:	e0 7a 70 00 	mov	r10,94208
8000bac2:	72 08       	ld.w	r8,r9[0x0]
8000bac4:	f0 0c 00 0c 	add	r12,r8,r12
8000bac8:	14 3c       	cp.w	r12,r10
8000baca:	e0 8b 00 04 	brhi	8000bad2 <_sbrk+0x2a>
8000bace:	93 0c       	st.w	r9[0x0],r12
8000bad0:	c0 68       	rjmp	8000badc <_sbrk+0x34>
8000bad2:	e0 a0 18 15 	rcall	8000eafc <__errno>
8000bad6:	30 c8       	mov	r8,12
8000bad8:	99 08       	st.w	r12[0x0],r8
8000bada:	3f f8       	mov	r8,-1
8000badc:	10 9c       	mov	r12,r8
8000bade:	d8 02       	popm	pc

8000bae0 <get_arg>:
8000bae0:	d4 31       	pushm	r0-r7,lr
8000bae2:	20 8d       	sub	sp,32
8000bae4:	fa c4 ff bc 	sub	r4,sp,-68
8000bae8:	50 4b       	stdsp	sp[0x10],r11
8000baea:	68 2e       	ld.w	lr,r4[0x8]
8000baec:	50 58       	stdsp	sp[0x14],r8
8000baee:	12 96       	mov	r6,r9
8000baf0:	7c 0b       	ld.w	r11,lr[0x0]
8000baf2:	70 05       	ld.w	r5,r8[0x0]
8000baf4:	50 6e       	stdsp	sp[0x18],lr
8000baf6:	58 0b       	cp.w	r11,0
8000baf8:	f4 0b 17 00 	moveq	r11,r10
8000bafc:	68 03       	ld.w	r3,r4[0x0]
8000bafe:	68 11       	ld.w	r1,r4[0x4]
8000bb00:	40 49       	lddsp	r9,sp[0x10]
8000bb02:	30 08       	mov	r8,0
8000bb04:	c2 89       	rjmp	8000bd54 <get_arg+0x274>
8000bb06:	2f fb       	sub	r11,-1
8000bb08:	32 5c       	mov	r12,37
8000bb0a:	17 8a       	ld.ub	r10,r11[0x0]
8000bb0c:	f8 0a 18 00 	cp.b	r10,r12
8000bb10:	5f 1e       	srne	lr
8000bb12:	f0 0a 18 00 	cp.b	r10,r8
8000bb16:	5f 1c       	srne	r12
8000bb18:	fd ec 00 0c 	and	r12,lr,r12
8000bb1c:	f0 0c 18 00 	cp.b	r12,r8
8000bb20:	cf 31       	brne	8000bb06 <get_arg+0x26>
8000bb22:	58 0a       	cp.w	r10,0
8000bb24:	e0 80 01 25 	breq	8000bd6e <get_arg+0x28e>
8000bb28:	30 0c       	mov	r12,0
8000bb2a:	3f fa       	mov	r10,-1
8000bb2c:	18 90       	mov	r0,r12
8000bb2e:	50 3a       	stdsp	sp[0xc],r10
8000bb30:	18 94       	mov	r4,r12
8000bb32:	18 92       	mov	r2,r12
8000bb34:	f8 0c 00 3c 	add	r12,r12,r12<<0x3
8000bb38:	16 97       	mov	r7,r11
8000bb3a:	50 7c       	stdsp	sp[0x1c],r12
8000bb3c:	fe cc a2 a4 	sub	r12,pc,-23900
8000bb40:	0f 3a       	ld.ub	r10,r7++
8000bb42:	f8 0a 07 0e 	ld.ub	lr,r12[r10]
8000bb46:	40 7c       	lddsp	r12,sp[0x1c]
8000bb48:	1c 0c       	add	r12,lr
8000bb4a:	fe ce a3 7a 	sub	lr,pc,-23686
8000bb4e:	fc 0c 07 0e 	ld.ub	lr,lr[r12]
8000bb52:	20 1e       	sub	lr,1
8000bb54:	50 0e       	stdsp	sp[0x0],lr
8000bb56:	fe ce a3 f2 	sub	lr,pc,-23566
8000bb5a:	fc 0c 07 0c 	ld.ub	r12,lr[r12]
8000bb5e:	50 7c       	stdsp	sp[0x1c],r12
8000bb60:	40 0c       	lddsp	r12,sp[0x0]
8000bb62:	58 7c       	cp.w	r12,7
8000bb64:	e0 8b 00 f1 	brhi	8000bd46 <get_arg+0x266>
8000bb68:	fe ce a5 a4 	sub	lr,pc,-23132
8000bb6c:	fc 0c 03 2f 	ld.w	pc,lr[r12<<0x2]
8000bb70:	36 8b       	mov	r11,104
8000bb72:	f6 0a 18 00 	cp.b	r10,r11
8000bb76:	e0 80 00 e8 	breq	8000bd46 <get_arg+0x266>
8000bb7a:	37 1b       	mov	r11,113
8000bb7c:	f6 0a 18 00 	cp.b	r10,r11
8000bb80:	c0 70       	breq	8000bb8e <get_arg+0xae>
8000bb82:	34 cb       	mov	r11,76
8000bb84:	f6 0a 18 00 	cp.b	r10,r11
8000bb88:	c0 51       	brne	8000bb92 <get_arg+0xb2>
8000bb8a:	a3 b4       	sbr	r4,0x3
8000bb8c:	cd d8       	rjmp	8000bd46 <get_arg+0x266>
8000bb8e:	a5 b4       	sbr	r4,0x5
8000bb90:	cd b8       	rjmp	8000bd46 <get_arg+0x266>
8000bb92:	08 9a       	mov	r10,r4
8000bb94:	0e 9b       	mov	r11,r7
8000bb96:	a5 aa       	sbr	r10,0x4
8000bb98:	17 3c       	ld.ub	r12,r11++
8000bb9a:	a5 b4       	sbr	r4,0x5
8000bb9c:	36 ce       	mov	lr,108
8000bb9e:	fc 0c 18 00 	cp.b	r12,lr
8000bba2:	e0 80 00 d3 	breq	8000bd48 <get_arg+0x268>
8000bba6:	14 94       	mov	r4,r10
8000bba8:	cc f8       	rjmp	8000bd46 <get_arg+0x266>
8000bbaa:	eb d5 c0 05 	bfextu	r5,r5,0x0,0x5
8000bbae:	36 7c       	mov	r12,103
8000bbb0:	f8 0a 18 00 	cp.b	r10,r12
8000bbb4:	e0 8b 00 27 	brhi	8000bc02 <get_arg+0x122>
8000bbb8:	36 5b       	mov	r11,101
8000bbba:	f6 0a 18 00 	cp.b	r10,r11
8000bbbe:	c4 82       	brcc	8000bc4e <get_arg+0x16e>
8000bbc0:	34 fb       	mov	r11,79
8000bbc2:	f6 0a 18 00 	cp.b	r10,r11
8000bbc6:	c4 80       	breq	8000bc56 <get_arg+0x176>
8000bbc8:	e0 8b 00 0c 	brhi	8000bbe0 <get_arg+0x100>
8000bbcc:	34 5b       	mov	r11,69
8000bbce:	f6 0a 18 00 	cp.b	r10,r11
8000bbd2:	c3 e0       	breq	8000bc4e <get_arg+0x16e>
8000bbd4:	34 7b       	mov	r11,71
8000bbd6:	f6 0a 18 00 	cp.b	r10,r11
8000bbda:	c3 a0       	breq	8000bc4e <get_arg+0x16e>
8000bbdc:	34 4b       	mov	r11,68
8000bbde:	c0 88       	rjmp	8000bbee <get_arg+0x10e>
8000bbe0:	35 8b       	mov	r11,88
8000bbe2:	f6 0a 18 00 	cp.b	r10,r11
8000bbe6:	c2 c0       	breq	8000bc3e <get_arg+0x15e>
8000bbe8:	e0 8b 00 07 	brhi	8000bbf6 <get_arg+0x116>
8000bbec:	35 5b       	mov	r11,85
8000bbee:	f6 0a 18 00 	cp.b	r10,r11
8000bbf2:	c3 51       	brne	8000bc5c <get_arg+0x17c>
8000bbf4:	c3 18       	rjmp	8000bc56 <get_arg+0x176>
8000bbf6:	36 3b       	mov	r11,99
8000bbf8:	f6 0a 18 00 	cp.b	r10,r11
8000bbfc:	c2 f0       	breq	8000bc5a <get_arg+0x17a>
8000bbfe:	36 4b       	mov	r11,100
8000bc00:	c0 e8       	rjmp	8000bc1c <get_arg+0x13c>
8000bc02:	37 0b       	mov	r11,112
8000bc04:	f6 0a 18 00 	cp.b	r10,r11
8000bc08:	c2 50       	breq	8000bc52 <get_arg+0x172>
8000bc0a:	e0 8b 00 0d 	brhi	8000bc24 <get_arg+0x144>
8000bc0e:	36 eb       	mov	r11,110
8000bc10:	f6 0a 18 00 	cp.b	r10,r11
8000bc14:	c1 f0       	breq	8000bc52 <get_arg+0x172>
8000bc16:	e0 8b 00 14 	brhi	8000bc3e <get_arg+0x15e>
8000bc1a:	36 9b       	mov	r11,105
8000bc1c:	f6 0a 18 00 	cp.b	r10,r11
8000bc20:	c1 e1       	brne	8000bc5c <get_arg+0x17c>
8000bc22:	c0 e8       	rjmp	8000bc3e <get_arg+0x15e>
8000bc24:	37 5b       	mov	r11,117
8000bc26:	f6 0a 18 00 	cp.b	r10,r11
8000bc2a:	c0 a0       	breq	8000bc3e <get_arg+0x15e>
8000bc2c:	37 8b       	mov	r11,120
8000bc2e:	f6 0a 18 00 	cp.b	r10,r11
8000bc32:	c0 60       	breq	8000bc3e <get_arg+0x15e>
8000bc34:	37 3b       	mov	r11,115
8000bc36:	f6 0a 18 00 	cp.b	r10,r11
8000bc3a:	c1 11       	brne	8000bc5c <get_arg+0x17c>
8000bc3c:	c0 b8       	rjmp	8000bc52 <get_arg+0x172>
8000bc3e:	ed b4 00 04 	bld	r4,0x4
8000bc42:	c0 a0       	breq	8000bc56 <get_arg+0x176>
8000bc44:	ed b4 00 05 	bld	r4,0x5
8000bc48:	c0 91       	brne	8000bc5a <get_arg+0x17a>
8000bc4a:	30 20       	mov	r0,2
8000bc4c:	c0 88       	rjmp	8000bc5c <get_arg+0x17c>
8000bc4e:	30 40       	mov	r0,4
8000bc50:	c0 68       	rjmp	8000bc5c <get_arg+0x17c>
8000bc52:	30 30       	mov	r0,3
8000bc54:	c0 48       	rjmp	8000bc5c <get_arg+0x17c>
8000bc56:	30 10       	mov	r0,1
8000bc58:	c0 28       	rjmp	8000bc5c <get_arg+0x17c>
8000bc5a:	30 00       	mov	r0,0
8000bc5c:	40 3b       	lddsp	r11,sp[0xc]
8000bc5e:	5b fb       	cp.w	r11,-1
8000bc60:	c0 40       	breq	8000bc68 <get_arg+0x188>
8000bc62:	e2 0b 09 20 	st.w	r1[r11<<0x2],r0
8000bc66:	c7 08       	rjmp	8000bd46 <get_arg+0x266>
8000bc68:	58 60       	cp.w	r0,6
8000bc6a:	e0 8b 00 6e 	brhi	8000bd46 <get_arg+0x266>
8000bc6e:	6c 0a       	ld.w	r10,r6[0x0]
8000bc70:	ea cc ff ff 	sub	r12,r5,-1
8000bc74:	fe ce a6 90 	sub	lr,pc,-22896
8000bc78:	fc 00 03 2f 	ld.w	pc,lr[r0<<0x2]
8000bc7c:	f4 cb ff f8 	sub	r11,r10,-8
8000bc80:	8d 0b       	st.w	r6[0x0],r11
8000bc82:	f4 ea 00 00 	ld.d	r10,r10[0]
8000bc86:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
8000bc8a:	c0 f8       	rjmp	8000bca8 <get_arg+0x1c8>
8000bc8c:	f4 cb ff fc 	sub	r11,r10,-4
8000bc90:	8d 0b       	st.w	r6[0x0],r11
8000bc92:	74 0a       	ld.w	r10,r10[0x0]
8000bc94:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
8000bc98:	c0 88       	rjmp	8000bca8 <get_arg+0x1c8>
8000bc9a:	f4 cb ff f8 	sub	r11,r10,-8
8000bc9e:	8d 0b       	st.w	r6[0x0],r11
8000bca0:	f4 ea 00 00 	ld.d	r10,r10[0]
8000bca4:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
8000bca8:	0e 9b       	mov	r11,r7
8000bcaa:	18 95       	mov	r5,r12
8000bcac:	c4 e8       	rjmp	8000bd48 <get_arg+0x268>
8000bcae:	62 0a       	ld.w	r10,r1[0x0]
8000bcb0:	5b fa       	cp.w	r10,-1
8000bcb2:	c0 b1       	brne	8000bcc8 <get_arg+0x1e8>
8000bcb4:	50 19       	stdsp	sp[0x4],r9
8000bcb6:	50 28       	stdsp	sp[0x8],r8
8000bcb8:	e0 6a 00 80 	mov	r10,128
8000bcbc:	30 0b       	mov	r11,0
8000bcbe:	02 9c       	mov	r12,r1
8000bcc0:	fe b0 fc f5 	rcall	8000b6aa <memset>
8000bcc4:	40 28       	lddsp	r8,sp[0x8]
8000bcc6:	40 19       	lddsp	r9,sp[0x4]
8000bcc8:	e4 cc 00 01 	sub	r12,r2,1
8000bccc:	0e 9b       	mov	r11,r7
8000bcce:	50 3c       	stdsp	sp[0xc],r12
8000bcd0:	f2 0c 0c 49 	max	r9,r9,r12
8000bcd4:	c3 a8       	rjmp	8000bd48 <get_arg+0x268>
8000bcd6:	62 0a       	ld.w	r10,r1[0x0]
8000bcd8:	5b fa       	cp.w	r10,-1
8000bcda:	c0 b1       	brne	8000bcf0 <get_arg+0x210>
8000bcdc:	50 19       	stdsp	sp[0x4],r9
8000bcde:	50 28       	stdsp	sp[0x8],r8
8000bce0:	e0 6a 00 80 	mov	r10,128
8000bce4:	30 0b       	mov	r11,0
8000bce6:	02 9c       	mov	r12,r1
8000bce8:	fe b0 fc e1 	rcall	8000b6aa <memset>
8000bcec:	40 28       	lddsp	r8,sp[0x8]
8000bcee:	40 19       	lddsp	r9,sp[0x4]
8000bcf0:	20 12       	sub	r2,1
8000bcf2:	30 0a       	mov	r10,0
8000bcf4:	0e 9b       	mov	r11,r7
8000bcf6:	e2 02 09 2a 	st.w	r1[r2<<0x2],r10
8000bcfa:	f2 02 0c 49 	max	r9,r9,r2
8000bcfe:	c2 58       	rjmp	8000bd48 <get_arg+0x268>
8000bd00:	16 97       	mov	r7,r11
8000bd02:	6c 0a       	ld.w	r10,r6[0x0]
8000bd04:	f4 cb ff fc 	sub	r11,r10,-4
8000bd08:	8d 0b       	st.w	r6[0x0],r11
8000bd0a:	74 0a       	ld.w	r10,r10[0x0]
8000bd0c:	0e 9b       	mov	r11,r7
8000bd0e:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
8000bd12:	2f f5       	sub	r5,-1
8000bd14:	c1 a8       	rjmp	8000bd48 <get_arg+0x268>
8000bd16:	f4 c2 00 30 	sub	r2,r10,48
8000bd1a:	c0 68       	rjmp	8000bd26 <get_arg+0x246>
8000bd1c:	e4 02 00 22 	add	r2,r2,r2<<0x2
8000bd20:	2f f7       	sub	r7,-1
8000bd22:	f4 02 00 12 	add	r2,r10,r2<<0x1
8000bd26:	0f 8a       	ld.ub	r10,r7[0x0]
8000bd28:	58 0a       	cp.w	r10,0
8000bd2a:	c0 e0       	breq	8000bd46 <get_arg+0x266>
8000bd2c:	23 0a       	sub	r10,48
8000bd2e:	58 9a       	cp.w	r10,9
8000bd30:	fe 98 ff f6 	brls	8000bd1c <get_arg+0x23c>
8000bd34:	c0 98       	rjmp	8000bd46 <get_arg+0x266>
8000bd36:	2f f7       	sub	r7,-1
8000bd38:	0f 8a       	ld.ub	r10,r7[0x0]
8000bd3a:	58 0a       	cp.w	r10,0
8000bd3c:	c0 50       	breq	8000bd46 <get_arg+0x266>
8000bd3e:	23 0a       	sub	r10,48
8000bd40:	58 9a       	cp.w	r10,9
8000bd42:	fe 98 ff fa 	brls	8000bd36 <get_arg+0x256>
8000bd46:	0e 9b       	mov	r11,r7
8000bd48:	40 7c       	lddsp	r12,sp[0x1c]
8000bd4a:	30 ba       	mov	r10,11
8000bd4c:	f4 0c 18 00 	cp.b	r12,r10
8000bd50:	fe 91 fe f2 	brne	8000bb34 <get_arg+0x54>
8000bd54:	40 42       	lddsp	r2,sp[0x10]
8000bd56:	17 8c       	ld.ub	r12,r11[0x0]
8000bd58:	0a 32       	cp.w	r2,r5
8000bd5a:	5f 4a       	srge	r10
8000bd5c:	f0 0c 18 00 	cp.b	r12,r8
8000bd60:	5f 1c       	srne	r12
8000bd62:	f9 ea 00 0a 	and	r10,r12,r10
8000bd66:	f0 0a 18 00 	cp.b	r10,r8
8000bd6a:	fe 91 fe cf 	brne	8000bb08 <get_arg+0x28>
8000bd6e:	30 08       	mov	r8,0
8000bd70:	40 4e       	lddsp	lr,sp[0x10]
8000bd72:	17 8a       	ld.ub	r10,r11[0x0]
8000bd74:	e2 05 00 21 	add	r1,r1,r5<<0x2
8000bd78:	f0 0a 18 00 	cp.b	r10,r8
8000bd7c:	fc 09 17 10 	movne	r9,lr
8000bd80:	e6 05 00 38 	add	r8,r3,r5<<0x3
8000bd84:	06 9e       	mov	lr,r3
8000bd86:	c2 a8       	rjmp	8000bdda <get_arg+0x2fa>
8000bd88:	62 0a       	ld.w	r10,r1[0x0]
8000bd8a:	58 3a       	cp.w	r10,3
8000bd8c:	c1 e0       	breq	8000bdc8 <get_arg+0x2e8>
8000bd8e:	e0 89 00 07 	brgt	8000bd9c <get_arg+0x2bc>
8000bd92:	58 1a       	cp.w	r10,1
8000bd94:	c1 a0       	breq	8000bdc8 <get_arg+0x2e8>
8000bd96:	58 2a       	cp.w	r10,2
8000bd98:	c1 81       	brne	8000bdc8 <get_arg+0x2e8>
8000bd9a:	c0 58       	rjmp	8000bda4 <get_arg+0x2c4>
8000bd9c:	58 5a       	cp.w	r10,5
8000bd9e:	c0 c0       	breq	8000bdb6 <get_arg+0x2d6>
8000bda0:	c0 b5       	brlt	8000bdb6 <get_arg+0x2d6>
8000bda2:	c1 38       	rjmp	8000bdc8 <get_arg+0x2e8>
8000bda4:	6c 0a       	ld.w	r10,r6[0x0]
8000bda6:	f4 cc ff f8 	sub	r12,r10,-8
8000bdaa:	8d 0c       	st.w	r6[0x0],r12
8000bdac:	f4 e2 00 00 	ld.d	r2,r10[0]
8000bdb0:	f0 e3 00 00 	st.d	r8[0],r2
8000bdb4:	c1 08       	rjmp	8000bdd4 <get_arg+0x2f4>
8000bdb6:	6c 0a       	ld.w	r10,r6[0x0]
8000bdb8:	f4 cc ff f8 	sub	r12,r10,-8
8000bdbc:	8d 0c       	st.w	r6[0x0],r12
8000bdbe:	f4 e2 00 00 	ld.d	r2,r10[0]
8000bdc2:	f0 e3 00 00 	st.d	r8[0],r2
8000bdc6:	c0 78       	rjmp	8000bdd4 <get_arg+0x2f4>
8000bdc8:	6c 0a       	ld.w	r10,r6[0x0]
8000bdca:	f4 cc ff fc 	sub	r12,r10,-4
8000bdce:	8d 0c       	st.w	r6[0x0],r12
8000bdd0:	74 0a       	ld.w	r10,r10[0x0]
8000bdd2:	91 0a       	st.w	r8[0x0],r10
8000bdd4:	2f f5       	sub	r5,-1
8000bdd6:	2f 88       	sub	r8,-8
8000bdd8:	2f c1       	sub	r1,-4
8000bdda:	12 35       	cp.w	r5,r9
8000bddc:	fe 9a ff d6 	brle	8000bd88 <get_arg+0x2a8>
8000bde0:	1c 93       	mov	r3,lr
8000bde2:	40 52       	lddsp	r2,sp[0x14]
8000bde4:	40 6e       	lddsp	lr,sp[0x18]
8000bde6:	85 05       	st.w	r2[0x0],r5
8000bde8:	9d 0b       	st.w	lr[0x0],r11
8000bdea:	40 4b       	lddsp	r11,sp[0x10]
8000bdec:	e6 0b 00 3c 	add	r12,r3,r11<<0x3
8000bdf0:	2f 8d       	sub	sp,-32
8000bdf2:	d8 32       	popm	r0-r7,pc

8000bdf4 <__sprint_r>:
8000bdf4:	d4 21       	pushm	r4-r7,lr
8000bdf6:	14 97       	mov	r7,r10
8000bdf8:	74 28       	ld.w	r8,r10[0x8]
8000bdfa:	58 08       	cp.w	r8,0
8000bdfc:	c0 41       	brne	8000be04 <__sprint_r+0x10>
8000bdfe:	95 18       	st.w	r10[0x4],r8
8000be00:	10 9c       	mov	r12,r8
8000be02:	d8 22       	popm	r4-r7,pc
8000be04:	e0 a0 18 ba 	rcall	8000ef78 <__sfvwrite_r>
8000be08:	30 08       	mov	r8,0
8000be0a:	8f 18       	st.w	r7[0x4],r8
8000be0c:	8f 28       	st.w	r7[0x8],r8
8000be0e:	d8 22       	popm	r4-r7,pc

8000be10 <_vfprintf_r>:
8000be10:	d4 31       	pushm	r0-r7,lr
8000be12:	fa cd 06 bc 	sub	sp,sp,1724
8000be16:	51 09       	stdsp	sp[0x40],r9
8000be18:	16 91       	mov	r1,r11
8000be1a:	14 97       	mov	r7,r10
8000be1c:	18 95       	mov	r5,r12
8000be1e:	e0 a0 1a 1d 	rcall	8000f258 <_localeconv_r>
8000be22:	78 0c       	ld.w	r12,r12[0x0]
8000be24:	50 cc       	stdsp	sp[0x30],r12
8000be26:	58 05       	cp.w	r5,0
8000be28:	c0 70       	breq	8000be36 <_vfprintf_r+0x26>
8000be2a:	6a 68       	ld.w	r8,r5[0x18]
8000be2c:	58 08       	cp.w	r8,0
8000be2e:	c0 41       	brne	8000be36 <_vfprintf_r+0x26>
8000be30:	0a 9c       	mov	r12,r5
8000be32:	e0 a0 17 43 	rcall	8000ecb8 <__sinit>
8000be36:	fe c8 a4 8e 	sub	r8,pc,-23410
8000be3a:	10 31       	cp.w	r1,r8
8000be3c:	c0 31       	brne	8000be42 <_vfprintf_r+0x32>
8000be3e:	6a 01       	ld.w	r1,r5[0x0]
8000be40:	c0 c8       	rjmp	8000be58 <_vfprintf_r+0x48>
8000be42:	fe c8 a4 7a 	sub	r8,pc,-23430
8000be46:	10 31       	cp.w	r1,r8
8000be48:	c0 31       	brne	8000be4e <_vfprintf_r+0x3e>
8000be4a:	6a 11       	ld.w	r1,r5[0x4]
8000be4c:	c0 68       	rjmp	8000be58 <_vfprintf_r+0x48>
8000be4e:	fe c8 a4 66 	sub	r8,pc,-23450
8000be52:	10 31       	cp.w	r1,r8
8000be54:	eb f1 00 02 	ld.weq	r1,r5[0x8]
8000be58:	82 68       	ld.sh	r8,r1[0xc]
8000be5a:	ed b8 00 03 	bld	r8,0x3
8000be5e:	c0 41       	brne	8000be66 <_vfprintf_r+0x56>
8000be60:	62 48       	ld.w	r8,r1[0x10]
8000be62:	58 08       	cp.w	r8,0
8000be64:	c0 71       	brne	8000be72 <_vfprintf_r+0x62>
8000be66:	02 9b       	mov	r11,r1
8000be68:	0a 9c       	mov	r12,r5
8000be6a:	e0 a0 0f 5d 	rcall	8000dd24 <__swsetup_r>
8000be6e:	e0 81 0f 54 	brne	8000dd16 <_vfprintf_r+0x1f06>
8000be72:	82 68       	ld.sh	r8,r1[0xc]
8000be74:	10 99       	mov	r9,r8
8000be76:	e2 19 00 1a 	andl	r9,0x1a,COH
8000be7a:	58 a9       	cp.w	r9,10
8000be7c:	c3 c1       	brne	8000bef4 <_vfprintf_r+0xe4>
8000be7e:	82 79       	ld.sh	r9,r1[0xe]
8000be80:	30 0a       	mov	r10,0
8000be82:	f4 09 19 00 	cp.h	r9,r10
8000be86:	c3 75       	brlt	8000bef4 <_vfprintf_r+0xe4>
8000be88:	a1 d8       	cbr	r8,0x1
8000be8a:	fb 58 05 d0 	st.h	sp[1488],r8
8000be8e:	62 88       	ld.w	r8,r1[0x20]
8000be90:	fb 48 05 e4 	st.w	sp[1508],r8
8000be94:	62 a8       	ld.w	r8,r1[0x28]
8000be96:	fb 48 05 ec 	st.w	sp[1516],r8
8000be9a:	fa c8 ff bc 	sub	r8,sp,-68
8000be9e:	fb 48 05 d4 	st.w	sp[1492],r8
8000bea2:	fb 48 05 c4 	st.w	sp[1476],r8
8000bea6:	e0 68 04 00 	mov	r8,1024
8000beaa:	fb 48 05 d8 	st.w	sp[1496],r8
8000beae:	fb 48 05 cc 	st.w	sp[1484],r8
8000beb2:	30 08       	mov	r8,0
8000beb4:	fb 59 05 d2 	st.h	sp[1490],r9
8000beb8:	0e 9a       	mov	r10,r7
8000beba:	41 09       	lddsp	r9,sp[0x40]
8000bebc:	fa c7 fa 3c 	sub	r7,sp,-1476
8000bec0:	fb 48 05 dc 	st.w	sp[1500],r8
8000bec4:	0a 9c       	mov	r12,r5
8000bec6:	0e 9b       	mov	r11,r7
8000bec8:	ca 4f       	rcall	8000be10 <_vfprintf_r>
8000beca:	50 bc       	stdsp	sp[0x2c],r12
8000becc:	c0 95       	brlt	8000bede <_vfprintf_r+0xce>
8000bece:	0e 9b       	mov	r11,r7
8000bed0:	0a 9c       	mov	r12,r5
8000bed2:	e0 a0 16 1b 	rcall	8000eb08 <_fflush_r>
8000bed6:	40 be       	lddsp	lr,sp[0x2c]
8000bed8:	f9 be 01 ff 	movne	lr,-1
8000bedc:	50 be       	stdsp	sp[0x2c],lr
8000bede:	fb 08 05 d0 	ld.sh	r8,sp[1488]
8000bee2:	ed b8 00 06 	bld	r8,0x6
8000bee6:	e0 81 0f 1a 	brne	8000dd1a <_vfprintf_r+0x1f0a>
8000beea:	82 68       	ld.sh	r8,r1[0xc]
8000beec:	a7 a8       	sbr	r8,0x6
8000beee:	a2 68       	st.h	r1[0xc],r8
8000bef0:	e0 8f 0f 15 	bral	8000dd1a <_vfprintf_r+0x1f0a>
8000bef4:	30 08       	mov	r8,0
8000bef6:	fb 48 06 b4 	st.w	sp[1716],r8
8000befa:	fb 48 06 90 	st.w	sp[1680],r8
8000befe:	fb 48 06 8c 	st.w	sp[1676],r8
8000bf02:	fb 48 06 b0 	st.w	sp[1712],r8
8000bf06:	30 08       	mov	r8,0
8000bf08:	30 09       	mov	r9,0
8000bf0a:	50 a7       	stdsp	sp[0x28],r7
8000bf0c:	50 78       	stdsp	sp[0x1c],r8
8000bf0e:	fa c3 f9 e0 	sub	r3,sp,-1568
8000bf12:	3f f8       	mov	r8,-1
8000bf14:	50 59       	stdsp	sp[0x14],r9
8000bf16:	fb 43 06 88 	st.w	sp[1672],r3
8000bf1a:	fb 48 05 44 	st.w	sp[1348],r8
8000bf1e:	12 9c       	mov	r12,r9
8000bf20:	50 69       	stdsp	sp[0x18],r9
8000bf22:	50 d9       	stdsp	sp[0x34],r9
8000bf24:	50 e9       	stdsp	sp[0x38],r9
8000bf26:	50 b9       	stdsp	sp[0x2c],r9
8000bf28:	12 97       	mov	r7,r9
8000bf2a:	0a 94       	mov	r4,r5
8000bf2c:	40 a2       	lddsp	r2,sp[0x28]
8000bf2e:	32 5a       	mov	r10,37
8000bf30:	30 08       	mov	r8,0
8000bf32:	c0 28       	rjmp	8000bf36 <_vfprintf_r+0x126>
8000bf34:	2f f2       	sub	r2,-1
8000bf36:	05 89       	ld.ub	r9,r2[0x0]
8000bf38:	f0 09 18 00 	cp.b	r9,r8
8000bf3c:	5f 1b       	srne	r11
8000bf3e:	f4 09 18 00 	cp.b	r9,r10
8000bf42:	5f 19       	srne	r9
8000bf44:	f3 eb 00 0b 	and	r11,r9,r11
8000bf48:	f0 0b 18 00 	cp.b	r11,r8
8000bf4c:	cf 41       	brne	8000bf34 <_vfprintf_r+0x124>
8000bf4e:	40 ab       	lddsp	r11,sp[0x28]
8000bf50:	e4 0b 01 06 	sub	r6,r2,r11
8000bf54:	c1 e0       	breq	8000bf90 <_vfprintf_r+0x180>
8000bf56:	fa f8 06 90 	ld.w	r8,sp[1680]
8000bf5a:	0c 08       	add	r8,r6
8000bf5c:	87 0b       	st.w	r3[0x0],r11
8000bf5e:	fb 48 06 90 	st.w	sp[1680],r8
8000bf62:	87 16       	st.w	r3[0x4],r6
8000bf64:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000bf68:	2f f8       	sub	r8,-1
8000bf6a:	fb 48 06 8c 	st.w	sp[1676],r8
8000bf6e:	58 78       	cp.w	r8,7
8000bf70:	e0 89 00 04 	brgt	8000bf78 <_vfprintf_r+0x168>
8000bf74:	2f 83       	sub	r3,-8
8000bf76:	c0 a8       	rjmp	8000bf8a <_vfprintf_r+0x17a>
8000bf78:	fa ca f9 78 	sub	r10,sp,-1672
8000bf7c:	02 9b       	mov	r11,r1
8000bf7e:	08 9c       	mov	r12,r4
8000bf80:	c3 af       	rcall	8000bdf4 <__sprint_r>
8000bf82:	e0 81 0e c6 	brne	8000dd0e <_vfprintf_r+0x1efe>
8000bf86:	fa c3 f9 e0 	sub	r3,sp,-1568
8000bf8a:	40 ba       	lddsp	r10,sp[0x2c]
8000bf8c:	0c 0a       	add	r10,r6
8000bf8e:	50 ba       	stdsp	sp[0x2c],r10
8000bf90:	05 89       	ld.ub	r9,r2[0x0]
8000bf92:	30 08       	mov	r8,0
8000bf94:	f0 09 18 00 	cp.b	r9,r8
8000bf98:	e0 80 0e aa 	breq	8000dcec <_vfprintf_r+0x1edc>
8000bf9c:	30 09       	mov	r9,0
8000bf9e:	fb 68 06 bb 	st.b	sp[1723],r8
8000bfa2:	0e 96       	mov	r6,r7
8000bfa4:	e4 c8 ff ff 	sub	r8,r2,-1
8000bfa8:	3f fe       	mov	lr,-1
8000bfaa:	50 93       	stdsp	sp[0x24],r3
8000bfac:	50 41       	stdsp	sp[0x10],r1
8000bfae:	0e 93       	mov	r3,r7
8000bfb0:	04 91       	mov	r1,r2
8000bfb2:	50 89       	stdsp	sp[0x20],r9
8000bfb4:	50 a8       	stdsp	sp[0x28],r8
8000bfb6:	50 2e       	stdsp	sp[0x8],lr
8000bfb8:	50 39       	stdsp	sp[0xc],r9
8000bfba:	12 95       	mov	r5,r9
8000bfbc:	12 90       	mov	r0,r9
8000bfbe:	10 97       	mov	r7,r8
8000bfc0:	08 92       	mov	r2,r4
8000bfc2:	c0 78       	rjmp	8000bfd0 <_vfprintf_r+0x1c0>
8000bfc4:	3f fc       	mov	r12,-1
8000bfc6:	08 97       	mov	r7,r4
8000bfc8:	50 2c       	stdsp	sp[0x8],r12
8000bfca:	c0 38       	rjmp	8000bfd0 <_vfprintf_r+0x1c0>
8000bfcc:	30 0b       	mov	r11,0
8000bfce:	50 3b       	stdsp	sp[0xc],r11
8000bfd0:	0f 38       	ld.ub	r8,r7++
8000bfd2:	c0 28       	rjmp	8000bfd6 <_vfprintf_r+0x1c6>
8000bfd4:	12 90       	mov	r0,r9
8000bfd6:	f0 c9 00 20 	sub	r9,r8,32
8000bfda:	e0 49 00 58 	cp.w	r9,88
8000bfde:	e0 8b 0a 30 	brhi	8000d43e <_vfprintf_r+0x162e>
8000bfe2:	fe ca a9 e2 	sub	r10,pc,-22046
8000bfe6:	f4 09 03 2f 	ld.w	pc,r10[r9<<0x2]
8000bfea:	50 a7       	stdsp	sp[0x28],r7
8000bfec:	50 80       	stdsp	sp[0x20],r0
8000bfee:	0c 97       	mov	r7,r6
8000bff0:	04 94       	mov	r4,r2
8000bff2:	06 96       	mov	r6,r3
8000bff4:	02 92       	mov	r2,r1
8000bff6:	fe c9 a7 ba 	sub	r9,pc,-22598
8000bffa:	40 93       	lddsp	r3,sp[0x24]
8000bffc:	10 90       	mov	r0,r8
8000bffe:	40 41       	lddsp	r1,sp[0x10]
8000c000:	50 d9       	stdsp	sp[0x34],r9
8000c002:	e0 8f 08 8e 	bral	8000d11e <_vfprintf_r+0x130e>
8000c006:	30 08       	mov	r8,0
8000c008:	fb 39 06 bb 	ld.ub	r9,sp[1723]
8000c00c:	f0 09 18 00 	cp.b	r9,r8
8000c010:	ce 01       	brne	8000bfd0 <_vfprintf_r+0x1c0>
8000c012:	32 08       	mov	r8,32
8000c014:	c6 e8       	rjmp	8000c0f0 <_vfprintf_r+0x2e0>
8000c016:	a1 a5       	sbr	r5,0x0
8000c018:	cd cb       	rjmp	8000bfd0 <_vfprintf_r+0x1c0>
8000c01a:	0f 89       	ld.ub	r9,r7[0x0]
8000c01c:	f2 c8 00 30 	sub	r8,r9,48
8000c020:	58 98       	cp.w	r8,9
8000c022:	e0 8b 00 1d 	brhi	8000c05c <_vfprintf_r+0x24c>
8000c026:	ee c8 ff ff 	sub	r8,r7,-1
8000c02a:	30 0b       	mov	r11,0
8000c02c:	23 09       	sub	r9,48
8000c02e:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
8000c032:	f2 0b 00 1b 	add	r11,r9,r11<<0x1
8000c036:	11 39       	ld.ub	r9,r8++
8000c038:	f2 ca 00 30 	sub	r10,r9,48
8000c03c:	58 9a       	cp.w	r10,9
8000c03e:	fe 98 ff f7 	brls	8000c02c <_vfprintf_r+0x21c>
8000c042:	e0 49 00 24 	cp.w	r9,36
8000c046:	cc 31       	brne	8000bfcc <_vfprintf_r+0x1bc>
8000c048:	e0 4b 00 20 	cp.w	r11,32
8000c04c:	e0 89 0e 60 	brgt	8000dd0c <_vfprintf_r+0x1efc>
8000c050:	20 1b       	sub	r11,1
8000c052:	fa f9 06 b4 	ld.w	r9,sp[1716]
8000c056:	12 3b       	cp.w	r11,r9
8000c058:	c0 95       	brlt	8000c06a <_vfprintf_r+0x25a>
8000c05a:	c1 08       	rjmp	8000c07a <_vfprintf_r+0x26a>
8000c05c:	fa f9 06 b4 	ld.w	r9,sp[1716]
8000c060:	ec ca ff ff 	sub	r10,r6,-1
8000c064:	12 36       	cp.w	r6,r9
8000c066:	c1 f5       	brlt	8000c0a4 <_vfprintf_r+0x294>
8000c068:	c2 68       	rjmp	8000c0b4 <_vfprintf_r+0x2a4>
8000c06a:	fa ce f9 44 	sub	lr,sp,-1724
8000c06e:	10 97       	mov	r7,r8
8000c070:	fc 0b 00 3b 	add	r11,lr,r11<<0x3
8000c074:	f6 f0 fd 88 	ld.w	r0,r11[-632]
8000c078:	c3 58       	rjmp	8000c0e2 <_vfprintf_r+0x2d2>
8000c07a:	10 97       	mov	r7,r8
8000c07c:	fa c8 f9 50 	sub	r8,sp,-1712
8000c080:	1a d8       	st.w	--sp,r8
8000c082:	fa c8 fa b8 	sub	r8,sp,-1352
8000c086:	1a d8       	st.w	--sp,r8
8000c088:	fa c8 fb b4 	sub	r8,sp,-1100
8000c08c:	02 9a       	mov	r10,r1
8000c08e:	1a d8       	st.w	--sp,r8
8000c090:	04 9c       	mov	r12,r2
8000c092:	fa c8 f9 40 	sub	r8,sp,-1728
8000c096:	fa c9 ff b4 	sub	r9,sp,-76
8000c09a:	fe b0 fd 23 	rcall	8000bae0 <get_arg>
8000c09e:	2f dd       	sub	sp,-12
8000c0a0:	78 00       	ld.w	r0,r12[0x0]
8000c0a2:	c2 08       	rjmp	8000c0e2 <_vfprintf_r+0x2d2>
8000c0a4:	fa cc f9 44 	sub	r12,sp,-1724
8000c0a8:	14 96       	mov	r6,r10
8000c0aa:	f8 03 00 38 	add	r8,r12,r3<<0x3
8000c0ae:	f0 f0 fd 88 	ld.w	r0,r8[-632]
8000c0b2:	c1 88       	rjmp	8000c0e2 <_vfprintf_r+0x2d2>
8000c0b4:	41 08       	lddsp	r8,sp[0x40]
8000c0b6:	59 f9       	cp.w	r9,31
8000c0b8:	e0 89 00 11 	brgt	8000c0da <_vfprintf_r+0x2ca>
8000c0bc:	f0 cb ff fc 	sub	r11,r8,-4
8000c0c0:	51 0b       	stdsp	sp[0x40],r11
8000c0c2:	70 00       	ld.w	r0,r8[0x0]
8000c0c4:	fa cb f9 44 	sub	r11,sp,-1724
8000c0c8:	f6 09 00 38 	add	r8,r11,r9<<0x3
8000c0cc:	f1 40 fd 88 	st.w	r8[-632],r0
8000c0d0:	2f f9       	sub	r9,-1
8000c0d2:	14 96       	mov	r6,r10
8000c0d4:	fb 49 06 b4 	st.w	sp[1716],r9
8000c0d8:	c0 58       	rjmp	8000c0e2 <_vfprintf_r+0x2d2>
8000c0da:	70 00       	ld.w	r0,r8[0x0]
8000c0dc:	14 96       	mov	r6,r10
8000c0de:	2f c8       	sub	r8,-4
8000c0e0:	51 08       	stdsp	sp[0x40],r8
8000c0e2:	58 00       	cp.w	r0,0
8000c0e4:	fe 94 ff 76 	brge	8000bfd0 <_vfprintf_r+0x1c0>
8000c0e8:	5c 30       	neg	r0
8000c0ea:	a3 a5       	sbr	r5,0x2
8000c0ec:	c7 2b       	rjmp	8000bfd0 <_vfprintf_r+0x1c0>
8000c0ee:	32 b8       	mov	r8,43
8000c0f0:	fb 68 06 bb 	st.b	sp[1723],r8
8000c0f4:	c6 eb       	rjmp	8000bfd0 <_vfprintf_r+0x1c0>
8000c0f6:	0f 38       	ld.ub	r8,r7++
8000c0f8:	e0 48 00 2a 	cp.w	r8,42
8000c0fc:	c0 30       	breq	8000c102 <_vfprintf_r+0x2f2>
8000c0fe:	30 09       	mov	r9,0
8000c100:	c7 98       	rjmp	8000c1f2 <_vfprintf_r+0x3e2>
8000c102:	0f 88       	ld.ub	r8,r7[0x0]
8000c104:	f0 c9 00 30 	sub	r9,r8,48
8000c108:	58 99       	cp.w	r9,9
8000c10a:	e0 8b 00 1f 	brhi	8000c148 <_vfprintf_r+0x338>
8000c10e:	ee c4 ff ff 	sub	r4,r7,-1
8000c112:	30 0b       	mov	r11,0
8000c114:	23 08       	sub	r8,48
8000c116:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
8000c11a:	f0 0b 00 1b 	add	r11,r8,r11<<0x1
8000c11e:	09 38       	ld.ub	r8,r4++
8000c120:	f0 c9 00 30 	sub	r9,r8,48
8000c124:	58 99       	cp.w	r9,9
8000c126:	fe 98 ff f7 	brls	8000c114 <_vfprintf_r+0x304>
8000c12a:	e0 48 00 24 	cp.w	r8,36
8000c12e:	fe 91 ff 4f 	brne	8000bfcc <_vfprintf_r+0x1bc>
8000c132:	e0 4b 00 20 	cp.w	r11,32
8000c136:	e0 89 0d eb 	brgt	8000dd0c <_vfprintf_r+0x1efc>
8000c13a:	20 1b       	sub	r11,1
8000c13c:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c140:	10 3b       	cp.w	r11,r8
8000c142:	c0 a5       	brlt	8000c156 <_vfprintf_r+0x346>
8000c144:	c1 18       	rjmp	8000c166 <_vfprintf_r+0x356>
8000c146:	d7 03       	nop
8000c148:	fa fa 06 b4 	ld.w	r10,sp[1716]
8000c14c:	ec c9 ff ff 	sub	r9,r6,-1
8000c150:	14 36       	cp.w	r6,r10
8000c152:	c1 f5       	brlt	8000c190 <_vfprintf_r+0x380>
8000c154:	c2 88       	rjmp	8000c1a4 <_vfprintf_r+0x394>
8000c156:	fa ca f9 44 	sub	r10,sp,-1724
8000c15a:	f4 0b 00 3b 	add	r11,r10,r11<<0x3
8000c15e:	f6 fb fd 88 	ld.w	r11,r11[-632]
8000c162:	50 2b       	stdsp	sp[0x8],r11
8000c164:	c3 c8       	rjmp	8000c1dc <_vfprintf_r+0x3cc>
8000c166:	fa c8 f9 50 	sub	r8,sp,-1712
8000c16a:	1a d8       	st.w	--sp,r8
8000c16c:	fa c8 fa b8 	sub	r8,sp,-1352
8000c170:	1a d8       	st.w	--sp,r8
8000c172:	fa c8 fb b4 	sub	r8,sp,-1100
8000c176:	02 9a       	mov	r10,r1
8000c178:	1a d8       	st.w	--sp,r8
8000c17a:	04 9c       	mov	r12,r2
8000c17c:	fa c8 f9 40 	sub	r8,sp,-1728
8000c180:	fa c9 ff b4 	sub	r9,sp,-76
8000c184:	fe b0 fc ae 	rcall	8000bae0 <get_arg>
8000c188:	2f dd       	sub	sp,-12
8000c18a:	78 0c       	ld.w	r12,r12[0x0]
8000c18c:	50 2c       	stdsp	sp[0x8],r12
8000c18e:	c2 78       	rjmp	8000c1dc <_vfprintf_r+0x3cc>
8000c190:	12 96       	mov	r6,r9
8000c192:	0e 94       	mov	r4,r7
8000c194:	fa c9 f9 44 	sub	r9,sp,-1724
8000c198:	f2 03 00 38 	add	r8,r9,r3<<0x3
8000c19c:	f0 f8 fd 88 	ld.w	r8,r8[-632]
8000c1a0:	50 28       	stdsp	sp[0x8],r8
8000c1a2:	c1 d8       	rjmp	8000c1dc <_vfprintf_r+0x3cc>
8000c1a4:	41 08       	lddsp	r8,sp[0x40]
8000c1a6:	59 fa       	cp.w	r10,31
8000c1a8:	e0 89 00 14 	brgt	8000c1d0 <_vfprintf_r+0x3c0>
8000c1ac:	f0 cb ff fc 	sub	r11,r8,-4
8000c1b0:	70 08       	ld.w	r8,r8[0x0]
8000c1b2:	51 0b       	stdsp	sp[0x40],r11
8000c1b4:	50 28       	stdsp	sp[0x8],r8
8000c1b6:	fa c6 f9 44 	sub	r6,sp,-1724
8000c1ba:	40 2e       	lddsp	lr,sp[0x8]
8000c1bc:	ec 0a 00 38 	add	r8,r6,r10<<0x3
8000c1c0:	f1 4e fd 88 	st.w	r8[-632],lr
8000c1c4:	2f fa       	sub	r10,-1
8000c1c6:	0e 94       	mov	r4,r7
8000c1c8:	fb 4a 06 b4 	st.w	sp[1716],r10
8000c1cc:	12 96       	mov	r6,r9
8000c1ce:	c0 78       	rjmp	8000c1dc <_vfprintf_r+0x3cc>
8000c1d0:	70 0c       	ld.w	r12,r8[0x0]
8000c1d2:	0e 94       	mov	r4,r7
8000c1d4:	2f c8       	sub	r8,-4
8000c1d6:	50 2c       	stdsp	sp[0x8],r12
8000c1d8:	12 96       	mov	r6,r9
8000c1da:	51 08       	stdsp	sp[0x40],r8
8000c1dc:	40 2b       	lddsp	r11,sp[0x8]
8000c1de:	58 0b       	cp.w	r11,0
8000c1e0:	fe 95 fe f2 	brlt	8000bfc4 <_vfprintf_r+0x1b4>
8000c1e4:	08 97       	mov	r7,r4
8000c1e6:	cf 5a       	rjmp	8000bfd0 <_vfprintf_r+0x1c0>
8000c1e8:	f2 09 00 29 	add	r9,r9,r9<<0x2
8000c1ec:	0f 38       	ld.ub	r8,r7++
8000c1ee:	f4 09 00 19 	add	r9,r10,r9<<0x1
8000c1f2:	f0 ca 00 30 	sub	r10,r8,48
8000c1f6:	58 9a       	cp.w	r10,9
8000c1f8:	fe 98 ff f8 	brls	8000c1e8 <_vfprintf_r+0x3d8>
8000c1fc:	3f fa       	mov	r10,-1
8000c1fe:	f2 0a 0c 49 	max	r9,r9,r10
8000c202:	50 29       	stdsp	sp[0x8],r9
8000c204:	ce 9a       	rjmp	8000bfd6 <_vfprintf_r+0x1c6>
8000c206:	a7 b5       	sbr	r5,0x7
8000c208:	ce 4a       	rjmp	8000bfd0 <_vfprintf_r+0x1c0>
8000c20a:	30 09       	mov	r9,0
8000c20c:	23 08       	sub	r8,48
8000c20e:	f2 09 00 29 	add	r9,r9,r9<<0x2
8000c212:	f0 09 00 19 	add	r9,r8,r9<<0x1
8000c216:	0f 38       	ld.ub	r8,r7++
8000c218:	f0 ca 00 30 	sub	r10,r8,48
8000c21c:	58 9a       	cp.w	r10,9
8000c21e:	fe 98 ff f7 	brls	8000c20c <_vfprintf_r+0x3fc>
8000c222:	e0 48 00 24 	cp.w	r8,36
8000c226:	fe 91 fe d7 	brne	8000bfd4 <_vfprintf_r+0x1c4>
8000c22a:	e0 49 00 20 	cp.w	r9,32
8000c22e:	e0 89 0d 6f 	brgt	8000dd0c <_vfprintf_r+0x1efc>
8000c232:	f2 c3 00 01 	sub	r3,r9,1
8000c236:	30 19       	mov	r9,1
8000c238:	50 39       	stdsp	sp[0xc],r9
8000c23a:	cc ba       	rjmp	8000bfd0 <_vfprintf_r+0x1c0>
8000c23c:	a3 b5       	sbr	r5,0x3
8000c23e:	cc 9a       	rjmp	8000bfd0 <_vfprintf_r+0x1c0>
8000c240:	a7 a5       	sbr	r5,0x6
8000c242:	cc 7a       	rjmp	8000bfd0 <_vfprintf_r+0x1c0>
8000c244:	0a 98       	mov	r8,r5
8000c246:	a5 b5       	sbr	r5,0x5
8000c248:	a5 a8       	sbr	r8,0x4
8000c24a:	0f 89       	ld.ub	r9,r7[0x0]
8000c24c:	36 ce       	mov	lr,108
8000c24e:	fc 09 18 00 	cp.b	r9,lr
8000c252:	f7 b7 00 ff 	subeq	r7,-1
8000c256:	f0 05 17 10 	movne	r5,r8
8000c25a:	cb ba       	rjmp	8000bfd0 <_vfprintf_r+0x1c0>
8000c25c:	a5 b5       	sbr	r5,0x5
8000c25e:	cb 9a       	rjmp	8000bfd0 <_vfprintf_r+0x1c0>
8000c260:	50 a7       	stdsp	sp[0x28],r7
8000c262:	50 80       	stdsp	sp[0x20],r0
8000c264:	0c 97       	mov	r7,r6
8000c266:	10 90       	mov	r0,r8
8000c268:	06 96       	mov	r6,r3
8000c26a:	04 94       	mov	r4,r2
8000c26c:	40 93       	lddsp	r3,sp[0x24]
8000c26e:	02 92       	mov	r2,r1
8000c270:	0e 99       	mov	r9,r7
8000c272:	40 41       	lddsp	r1,sp[0x10]
8000c274:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c278:	40 3c       	lddsp	r12,sp[0xc]
8000c27a:	58 0c       	cp.w	r12,0
8000c27c:	c1 d0       	breq	8000c2b6 <_vfprintf_r+0x4a6>
8000c27e:	10 36       	cp.w	r6,r8
8000c280:	c0 64       	brge	8000c28c <_vfprintf_r+0x47c>
8000c282:	fa cb f9 44 	sub	r11,sp,-1724
8000c286:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000c28a:	c1 d8       	rjmp	8000c2c4 <_vfprintf_r+0x4b4>
8000c28c:	fa c8 f9 50 	sub	r8,sp,-1712
8000c290:	1a d8       	st.w	--sp,r8
8000c292:	fa c8 fa b8 	sub	r8,sp,-1352
8000c296:	1a d8       	st.w	--sp,r8
8000c298:	fa c8 fb b4 	sub	r8,sp,-1100
8000c29c:	1a d8       	st.w	--sp,r8
8000c29e:	fa c8 f9 40 	sub	r8,sp,-1728
8000c2a2:	fa c9 ff b4 	sub	r9,sp,-76
8000c2a6:	04 9a       	mov	r10,r2
8000c2a8:	0c 9b       	mov	r11,r6
8000c2aa:	08 9c       	mov	r12,r4
8000c2ac:	fe b0 fc 1a 	rcall	8000bae0 <get_arg>
8000c2b0:	2f dd       	sub	sp,-12
8000c2b2:	19 b8       	ld.ub	r8,r12[0x3]
8000c2b4:	c2 28       	rjmp	8000c2f8 <_vfprintf_r+0x4e8>
8000c2b6:	2f f7       	sub	r7,-1
8000c2b8:	10 39       	cp.w	r9,r8
8000c2ba:	c0 84       	brge	8000c2ca <_vfprintf_r+0x4ba>
8000c2bc:	fa ca f9 44 	sub	r10,sp,-1724
8000c2c0:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000c2c4:	ed 38 fd 8b 	ld.ub	r8,r6[-629]
8000c2c8:	c1 88       	rjmp	8000c2f8 <_vfprintf_r+0x4e8>
8000c2ca:	41 09       	lddsp	r9,sp[0x40]
8000c2cc:	59 f8       	cp.w	r8,31
8000c2ce:	e0 89 00 12 	brgt	8000c2f2 <_vfprintf_r+0x4e2>
8000c2d2:	f2 ca ff fc 	sub	r10,r9,-4
8000c2d6:	51 0a       	stdsp	sp[0x40],r10
8000c2d8:	72 09       	ld.w	r9,r9[0x0]
8000c2da:	fa c6 f9 44 	sub	r6,sp,-1724
8000c2de:	ec 08 00 3a 	add	r10,r6,r8<<0x3
8000c2e2:	2f f8       	sub	r8,-1
8000c2e4:	f5 49 fd 88 	st.w	r10[-632],r9
8000c2e8:	fb 48 06 b4 	st.w	sp[1716],r8
8000c2ec:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
8000c2f0:	c0 48       	rjmp	8000c2f8 <_vfprintf_r+0x4e8>
8000c2f2:	13 b8       	ld.ub	r8,r9[0x3]
8000c2f4:	2f c9       	sub	r9,-4
8000c2f6:	51 09       	stdsp	sp[0x40],r9
8000c2f8:	fb 68 06 60 	st.b	sp[1632],r8
8000c2fc:	30 0e       	mov	lr,0
8000c2fe:	30 08       	mov	r8,0
8000c300:	30 12       	mov	r2,1
8000c302:	fb 68 06 bb 	st.b	sp[1723],r8
8000c306:	50 2e       	stdsp	sp[0x8],lr
8000c308:	e0 8f 08 ad 	bral	8000d462 <_vfprintf_r+0x1652>
8000c30c:	50 a7       	stdsp	sp[0x28],r7
8000c30e:	50 80       	stdsp	sp[0x20],r0
8000c310:	0c 97       	mov	r7,r6
8000c312:	04 94       	mov	r4,r2
8000c314:	06 96       	mov	r6,r3
8000c316:	02 92       	mov	r2,r1
8000c318:	40 93       	lddsp	r3,sp[0x24]
8000c31a:	10 90       	mov	r0,r8
8000c31c:	40 41       	lddsp	r1,sp[0x10]
8000c31e:	a5 a5       	sbr	r5,0x4
8000c320:	c0 a8       	rjmp	8000c334 <_vfprintf_r+0x524>
8000c322:	50 a7       	stdsp	sp[0x28],r7
8000c324:	50 80       	stdsp	sp[0x20],r0
8000c326:	0c 97       	mov	r7,r6
8000c328:	04 94       	mov	r4,r2
8000c32a:	06 96       	mov	r6,r3
8000c32c:	02 92       	mov	r2,r1
8000c32e:	40 93       	lddsp	r3,sp[0x24]
8000c330:	10 90       	mov	r0,r8
8000c332:	40 41       	lddsp	r1,sp[0x10]
8000c334:	ed b5 00 05 	bld	r5,0x5
8000c338:	c5 11       	brne	8000c3da <_vfprintf_r+0x5ca>
8000c33a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c33e:	40 3c       	lddsp	r12,sp[0xc]
8000c340:	58 0c       	cp.w	r12,0
8000c342:	c1 e0       	breq	8000c37e <_vfprintf_r+0x56e>
8000c344:	10 36       	cp.w	r6,r8
8000c346:	c0 64       	brge	8000c352 <_vfprintf_r+0x542>
8000c348:	fa cb f9 44 	sub	r11,sp,-1724
8000c34c:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000c350:	c2 08       	rjmp	8000c390 <_vfprintf_r+0x580>
8000c352:	fa c8 f9 50 	sub	r8,sp,-1712
8000c356:	1a d8       	st.w	--sp,r8
8000c358:	fa c8 fa b8 	sub	r8,sp,-1352
8000c35c:	0c 9b       	mov	r11,r6
8000c35e:	1a d8       	st.w	--sp,r8
8000c360:	fa c8 fb b4 	sub	r8,sp,-1100
8000c364:	1a d8       	st.w	--sp,r8
8000c366:	fa c9 ff b4 	sub	r9,sp,-76
8000c36a:	fa c8 f9 40 	sub	r8,sp,-1728
8000c36e:	04 9a       	mov	r10,r2
8000c370:	08 9c       	mov	r12,r4
8000c372:	fe b0 fb b7 	rcall	8000bae0 <get_arg>
8000c376:	2f dd       	sub	sp,-12
8000c378:	78 1b       	ld.w	r11,r12[0x4]
8000c37a:	78 09       	ld.w	r9,r12[0x0]
8000c37c:	c2 b8       	rjmp	8000c3d2 <_vfprintf_r+0x5c2>
8000c37e:	ee ca ff ff 	sub	r10,r7,-1
8000c382:	10 37       	cp.w	r7,r8
8000c384:	c0 b4       	brge	8000c39a <_vfprintf_r+0x58a>
8000c386:	fa c9 f9 44 	sub	r9,sp,-1724
8000c38a:	14 97       	mov	r7,r10
8000c38c:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000c390:	ec fb fd 8c 	ld.w	r11,r6[-628]
8000c394:	ec f9 fd 88 	ld.w	r9,r6[-632]
8000c398:	c1 d8       	rjmp	8000c3d2 <_vfprintf_r+0x5c2>
8000c39a:	41 09       	lddsp	r9,sp[0x40]
8000c39c:	59 f8       	cp.w	r8,31
8000c39e:	e0 89 00 14 	brgt	8000c3c6 <_vfprintf_r+0x5b6>
8000c3a2:	f2 cb ff f8 	sub	r11,r9,-8
8000c3a6:	51 0b       	stdsp	sp[0x40],r11
8000c3a8:	fa c6 f9 44 	sub	r6,sp,-1724
8000c3ac:	72 1b       	ld.w	r11,r9[0x4]
8000c3ae:	ec 08 00 3c 	add	r12,r6,r8<<0x3
8000c3b2:	72 09       	ld.w	r9,r9[0x0]
8000c3b4:	f9 4b fd 8c 	st.w	r12[-628],r11
8000c3b8:	f9 49 fd 88 	st.w	r12[-632],r9
8000c3bc:	2f f8       	sub	r8,-1
8000c3be:	14 97       	mov	r7,r10
8000c3c0:	fb 48 06 b4 	st.w	sp[1716],r8
8000c3c4:	c0 78       	rjmp	8000c3d2 <_vfprintf_r+0x5c2>
8000c3c6:	f2 c8 ff f8 	sub	r8,r9,-8
8000c3ca:	72 1b       	ld.w	r11,r9[0x4]
8000c3cc:	14 97       	mov	r7,r10
8000c3ce:	51 08       	stdsp	sp[0x40],r8
8000c3d0:	72 09       	ld.w	r9,r9[0x0]
8000c3d2:	16 98       	mov	r8,r11
8000c3d4:	fa e9 00 00 	st.d	sp[0],r8
8000c3d8:	ca e8       	rjmp	8000c534 <_vfprintf_r+0x724>
8000c3da:	ed b5 00 04 	bld	r5,0x4
8000c3de:	c1 71       	brne	8000c40c <_vfprintf_r+0x5fc>
8000c3e0:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c3e4:	40 3e       	lddsp	lr,sp[0xc]
8000c3e6:	58 0e       	cp.w	lr,0
8000c3e8:	c0 80       	breq	8000c3f8 <_vfprintf_r+0x5e8>
8000c3ea:	10 36       	cp.w	r6,r8
8000c3ec:	c6 94       	brge	8000c4be <_vfprintf_r+0x6ae>
8000c3ee:	fa cc f9 44 	sub	r12,sp,-1724
8000c3f2:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000c3f6:	c8 28       	rjmp	8000c4fa <_vfprintf_r+0x6ea>
8000c3f8:	ee ca ff ff 	sub	r10,r7,-1
8000c3fc:	10 37       	cp.w	r7,r8
8000c3fe:	e0 84 00 81 	brge	8000c500 <_vfprintf_r+0x6f0>
8000c402:	fa cb f9 44 	sub	r11,sp,-1724
8000c406:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000c40a:	c7 78       	rjmp	8000c4f8 <_vfprintf_r+0x6e8>
8000c40c:	ed b5 00 06 	bld	r5,0x6
8000c410:	c4 b1       	brne	8000c4a6 <_vfprintf_r+0x696>
8000c412:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c416:	40 3c       	lddsp	r12,sp[0xc]
8000c418:	58 0c       	cp.w	r12,0
8000c41a:	c1 d0       	breq	8000c454 <_vfprintf_r+0x644>
8000c41c:	10 36       	cp.w	r6,r8
8000c41e:	c0 64       	brge	8000c42a <_vfprintf_r+0x61a>
8000c420:	fa cb f9 44 	sub	r11,sp,-1724
8000c424:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000c428:	c1 f8       	rjmp	8000c466 <_vfprintf_r+0x656>
8000c42a:	fa c8 f9 50 	sub	r8,sp,-1712
8000c42e:	1a d8       	st.w	--sp,r8
8000c430:	fa c8 fa b8 	sub	r8,sp,-1352
8000c434:	1a d8       	st.w	--sp,r8
8000c436:	fa c8 fb b4 	sub	r8,sp,-1100
8000c43a:	1a d8       	st.w	--sp,r8
8000c43c:	fa c8 f9 40 	sub	r8,sp,-1728
8000c440:	fa c9 ff b4 	sub	r9,sp,-76
8000c444:	04 9a       	mov	r10,r2
8000c446:	0c 9b       	mov	r11,r6
8000c448:	08 9c       	mov	r12,r4
8000c44a:	fe b0 fb 4b 	rcall	8000bae0 <get_arg>
8000c44e:	2f dd       	sub	sp,-12
8000c450:	98 18       	ld.sh	r8,r12[0x2]
8000c452:	c2 68       	rjmp	8000c49e <_vfprintf_r+0x68e>
8000c454:	ee ca ff ff 	sub	r10,r7,-1
8000c458:	10 37       	cp.w	r7,r8
8000c45a:	c0 94       	brge	8000c46c <_vfprintf_r+0x65c>
8000c45c:	fa c9 f9 44 	sub	r9,sp,-1724
8000c460:	14 97       	mov	r7,r10
8000c462:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000c466:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000c46a:	c1 a8       	rjmp	8000c49e <_vfprintf_r+0x68e>
8000c46c:	41 09       	lddsp	r9,sp[0x40]
8000c46e:	59 f8       	cp.w	r8,31
8000c470:	e0 89 00 13 	brgt	8000c496 <_vfprintf_r+0x686>
8000c474:	f2 cb ff fc 	sub	r11,r9,-4
8000c478:	51 0b       	stdsp	sp[0x40],r11
8000c47a:	72 09       	ld.w	r9,r9[0x0]
8000c47c:	fa c6 f9 44 	sub	r6,sp,-1724
8000c480:	ec 08 00 3b 	add	r11,r6,r8<<0x3
8000c484:	2f f8       	sub	r8,-1
8000c486:	f7 49 fd 88 	st.w	r11[-632],r9
8000c48a:	fb 48 06 b4 	st.w	sp[1716],r8
8000c48e:	14 97       	mov	r7,r10
8000c490:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
8000c494:	c0 58       	rjmp	8000c49e <_vfprintf_r+0x68e>
8000c496:	92 18       	ld.sh	r8,r9[0x2]
8000c498:	14 97       	mov	r7,r10
8000c49a:	2f c9       	sub	r9,-4
8000c49c:	51 09       	stdsp	sp[0x40],r9
8000c49e:	50 18       	stdsp	sp[0x4],r8
8000c4a0:	bf 58       	asr	r8,0x1f
8000c4a2:	50 08       	stdsp	sp[0x0],r8
8000c4a4:	c4 88       	rjmp	8000c534 <_vfprintf_r+0x724>
8000c4a6:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c4aa:	40 3c       	lddsp	r12,sp[0xc]
8000c4ac:	58 0c       	cp.w	r12,0
8000c4ae:	c1 d0       	breq	8000c4e8 <_vfprintf_r+0x6d8>
8000c4b0:	10 36       	cp.w	r6,r8
8000c4b2:	c0 64       	brge	8000c4be <_vfprintf_r+0x6ae>
8000c4b4:	fa cb f9 44 	sub	r11,sp,-1724
8000c4b8:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000c4bc:	c1 f8       	rjmp	8000c4fa <_vfprintf_r+0x6ea>
8000c4be:	fa c8 f9 50 	sub	r8,sp,-1712
8000c4c2:	1a d8       	st.w	--sp,r8
8000c4c4:	fa c8 fa b8 	sub	r8,sp,-1352
8000c4c8:	0c 9b       	mov	r11,r6
8000c4ca:	1a d8       	st.w	--sp,r8
8000c4cc:	fa c8 fb b4 	sub	r8,sp,-1100
8000c4d0:	04 9a       	mov	r10,r2
8000c4d2:	1a d8       	st.w	--sp,r8
8000c4d4:	08 9c       	mov	r12,r4
8000c4d6:	fa c8 f9 40 	sub	r8,sp,-1728
8000c4da:	fa c9 ff b4 	sub	r9,sp,-76
8000c4de:	fe b0 fb 01 	rcall	8000bae0 <get_arg>
8000c4e2:	2f dd       	sub	sp,-12
8000c4e4:	78 0b       	ld.w	r11,r12[0x0]
8000c4e6:	c2 48       	rjmp	8000c52e <_vfprintf_r+0x71e>
8000c4e8:	ee ca ff ff 	sub	r10,r7,-1
8000c4ec:	10 37       	cp.w	r7,r8
8000c4ee:	c0 94       	brge	8000c500 <_vfprintf_r+0x6f0>
8000c4f0:	fa c9 f9 44 	sub	r9,sp,-1724
8000c4f4:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000c4f8:	14 97       	mov	r7,r10
8000c4fa:	ec fb fd 88 	ld.w	r11,r6[-632]
8000c4fe:	c1 88       	rjmp	8000c52e <_vfprintf_r+0x71e>
8000c500:	41 09       	lddsp	r9,sp[0x40]
8000c502:	59 f8       	cp.w	r8,31
8000c504:	e0 89 00 11 	brgt	8000c526 <_vfprintf_r+0x716>
8000c508:	f2 cb ff fc 	sub	r11,r9,-4
8000c50c:	51 0b       	stdsp	sp[0x40],r11
8000c50e:	fa c6 f9 44 	sub	r6,sp,-1724
8000c512:	72 0b       	ld.w	r11,r9[0x0]
8000c514:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000c518:	f3 4b fd 88 	st.w	r9[-632],r11
8000c51c:	2f f8       	sub	r8,-1
8000c51e:	14 97       	mov	r7,r10
8000c520:	fb 48 06 b4 	st.w	sp[1716],r8
8000c524:	c0 58       	rjmp	8000c52e <_vfprintf_r+0x71e>
8000c526:	72 0b       	ld.w	r11,r9[0x0]
8000c528:	14 97       	mov	r7,r10
8000c52a:	2f c9       	sub	r9,-4
8000c52c:	51 09       	stdsp	sp[0x40],r9
8000c52e:	50 1b       	stdsp	sp[0x4],r11
8000c530:	bf 5b       	asr	r11,0x1f
8000c532:	50 0b       	stdsp	sp[0x0],r11
8000c534:	fa ea 00 00 	ld.d	r10,sp[0]
8000c538:	58 0a       	cp.w	r10,0
8000c53a:	5c 2b       	cpc	r11
8000c53c:	c0 e4       	brge	8000c558 <_vfprintf_r+0x748>
8000c53e:	30 08       	mov	r8,0
8000c540:	fa ea 00 00 	ld.d	r10,sp[0]
8000c544:	30 09       	mov	r9,0
8000c546:	f0 0a 01 0a 	sub	r10,r8,r10
8000c54a:	f2 0b 01 4b 	sbc	r11,r9,r11
8000c54e:	32 d8       	mov	r8,45
8000c550:	fa eb 00 00 	st.d	sp[0],r10
8000c554:	fb 68 06 bb 	st.b	sp[1723],r8
8000c558:	30 18       	mov	r8,1
8000c55a:	e0 8f 06 fa 	bral	8000d34e <_vfprintf_r+0x153e>
8000c55e:	50 a7       	stdsp	sp[0x28],r7
8000c560:	50 80       	stdsp	sp[0x20],r0
8000c562:	0c 97       	mov	r7,r6
8000c564:	04 94       	mov	r4,r2
8000c566:	06 96       	mov	r6,r3
8000c568:	02 92       	mov	r2,r1
8000c56a:	40 93       	lddsp	r3,sp[0x24]
8000c56c:	10 90       	mov	r0,r8
8000c56e:	40 41       	lddsp	r1,sp[0x10]
8000c570:	0e 99       	mov	r9,r7
8000c572:	ed b5 00 03 	bld	r5,0x3
8000c576:	c4 11       	brne	8000c5f8 <_vfprintf_r+0x7e8>
8000c578:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c57c:	40 3a       	lddsp	r10,sp[0xc]
8000c57e:	58 0a       	cp.w	r10,0
8000c580:	c1 90       	breq	8000c5b2 <_vfprintf_r+0x7a2>
8000c582:	10 36       	cp.w	r6,r8
8000c584:	c6 45       	brlt	8000c64c <_vfprintf_r+0x83c>
8000c586:	fa c8 f9 50 	sub	r8,sp,-1712
8000c58a:	1a d8       	st.w	--sp,r8
8000c58c:	fa c8 fa b8 	sub	r8,sp,-1352
8000c590:	1a d8       	st.w	--sp,r8
8000c592:	fa c8 fb b4 	sub	r8,sp,-1100
8000c596:	0c 9b       	mov	r11,r6
8000c598:	1a d8       	st.w	--sp,r8
8000c59a:	04 9a       	mov	r10,r2
8000c59c:	fa c8 f9 40 	sub	r8,sp,-1728
8000c5a0:	fa c9 ff b4 	sub	r9,sp,-76
8000c5a4:	08 9c       	mov	r12,r4
8000c5a6:	fe b0 fa 9d 	rcall	8000bae0 <get_arg>
8000c5aa:	2f dd       	sub	sp,-12
8000c5ac:	78 16       	ld.w	r6,r12[0x4]
8000c5ae:	50 76       	stdsp	sp[0x1c],r6
8000c5b0:	c4 88       	rjmp	8000c640 <_vfprintf_r+0x830>
8000c5b2:	2f f7       	sub	r7,-1
8000c5b4:	10 39       	cp.w	r9,r8
8000c5b6:	c0 c4       	brge	8000c5ce <_vfprintf_r+0x7be>
8000c5b8:	fa ce f9 44 	sub	lr,sp,-1724
8000c5bc:	fc 06 00 36 	add	r6,lr,r6<<0x3
8000c5c0:	ec fc fd 8c 	ld.w	r12,r6[-628]
8000c5c4:	50 7c       	stdsp	sp[0x1c],r12
8000c5c6:	ec f6 fd 88 	ld.w	r6,r6[-632]
8000c5ca:	50 56       	stdsp	sp[0x14],r6
8000c5cc:	c6 68       	rjmp	8000c698 <_vfprintf_r+0x888>
8000c5ce:	41 09       	lddsp	r9,sp[0x40]
8000c5d0:	59 f8       	cp.w	r8,31
8000c5d2:	e0 89 00 10 	brgt	8000c5f2 <_vfprintf_r+0x7e2>
8000c5d6:	f2 ca ff f8 	sub	r10,r9,-8
8000c5da:	72 1b       	ld.w	r11,r9[0x4]
8000c5dc:	51 0a       	stdsp	sp[0x40],r10
8000c5de:	72 09       	ld.w	r9,r9[0x0]
8000c5e0:	fa ca f9 44 	sub	r10,sp,-1724
8000c5e4:	50 7b       	stdsp	sp[0x1c],r11
8000c5e6:	50 59       	stdsp	sp[0x14],r9
8000c5e8:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000c5ec:	40 5b       	lddsp	r11,sp[0x14]
8000c5ee:	40 7a       	lddsp	r10,sp[0x1c]
8000c5f0:	c4 78       	rjmp	8000c67e <_vfprintf_r+0x86e>
8000c5f2:	72 18       	ld.w	r8,r9[0x4]
8000c5f4:	50 78       	stdsp	sp[0x1c],r8
8000c5f6:	c4 c8       	rjmp	8000c68e <_vfprintf_r+0x87e>
8000c5f8:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c5fc:	40 3e       	lddsp	lr,sp[0xc]
8000c5fe:	58 0e       	cp.w	lr,0
8000c600:	c2 30       	breq	8000c646 <_vfprintf_r+0x836>
8000c602:	10 36       	cp.w	r6,r8
8000c604:	c0 94       	brge	8000c616 <_vfprintf_r+0x806>
8000c606:	fa cc f9 44 	sub	r12,sp,-1724
8000c60a:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000c60e:	ec fb fd 8c 	ld.w	r11,r6[-628]
8000c612:	50 7b       	stdsp	sp[0x1c],r11
8000c614:	cd 9b       	rjmp	8000c5c6 <_vfprintf_r+0x7b6>
8000c616:	fa c8 f9 50 	sub	r8,sp,-1712
8000c61a:	1a d8       	st.w	--sp,r8
8000c61c:	fa c8 fa b8 	sub	r8,sp,-1352
8000c620:	04 9a       	mov	r10,r2
8000c622:	1a d8       	st.w	--sp,r8
8000c624:	fa c8 fb b4 	sub	r8,sp,-1100
8000c628:	0c 9b       	mov	r11,r6
8000c62a:	1a d8       	st.w	--sp,r8
8000c62c:	08 9c       	mov	r12,r4
8000c62e:	fa c8 f9 40 	sub	r8,sp,-1728
8000c632:	fa c9 ff b4 	sub	r9,sp,-76
8000c636:	fe b0 fa 55 	rcall	8000bae0 <get_arg>
8000c63a:	2f dd       	sub	sp,-12
8000c63c:	78 1a       	ld.w	r10,r12[0x4]
8000c63e:	50 7a       	stdsp	sp[0x1c],r10
8000c640:	78 0c       	ld.w	r12,r12[0x0]
8000c642:	50 5c       	stdsp	sp[0x14],r12
8000c644:	c2 a8       	rjmp	8000c698 <_vfprintf_r+0x888>
8000c646:	2f f7       	sub	r7,-1
8000c648:	10 39       	cp.w	r9,r8
8000c64a:	c0 94       	brge	8000c65c <_vfprintf_r+0x84c>
8000c64c:	fa c9 f9 44 	sub	r9,sp,-1724
8000c650:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000c654:	ec f8 fd 8c 	ld.w	r8,r6[-628]
8000c658:	50 78       	stdsp	sp[0x1c],r8
8000c65a:	cb 6b       	rjmp	8000c5c6 <_vfprintf_r+0x7b6>
8000c65c:	41 09       	lddsp	r9,sp[0x40]
8000c65e:	59 f8       	cp.w	r8,31
8000c660:	e0 89 00 15 	brgt	8000c68a <_vfprintf_r+0x87a>
8000c664:	f2 ca ff f8 	sub	r10,r9,-8
8000c668:	72 16       	ld.w	r6,r9[0x4]
8000c66a:	72 09       	ld.w	r9,r9[0x0]
8000c66c:	51 0a       	stdsp	sp[0x40],r10
8000c66e:	50 59       	stdsp	sp[0x14],r9
8000c670:	fa ce f9 44 	sub	lr,sp,-1724
8000c674:	50 76       	stdsp	sp[0x1c],r6
8000c676:	fc 08 00 39 	add	r9,lr,r8<<0x3
8000c67a:	40 5b       	lddsp	r11,sp[0x14]
8000c67c:	0c 9a       	mov	r10,r6
8000c67e:	f2 eb fd 88 	st.d	r9[-632],r10
8000c682:	2f f8       	sub	r8,-1
8000c684:	fb 48 06 b4 	st.w	sp[1716],r8
8000c688:	c0 88       	rjmp	8000c698 <_vfprintf_r+0x888>
8000c68a:	72 1c       	ld.w	r12,r9[0x4]
8000c68c:	50 7c       	stdsp	sp[0x1c],r12
8000c68e:	f2 c8 ff f8 	sub	r8,r9,-8
8000c692:	51 08       	stdsp	sp[0x40],r8
8000c694:	72 09       	ld.w	r9,r9[0x0]
8000c696:	50 59       	stdsp	sp[0x14],r9
8000c698:	40 5b       	lddsp	r11,sp[0x14]
8000c69a:	40 7a       	lddsp	r10,sp[0x1c]
8000c69c:	e0 a0 19 54 	rcall	8000f944 <__isinfd>
8000c6a0:	18 96       	mov	r6,r12
8000c6a2:	c1 70       	breq	8000c6d0 <_vfprintf_r+0x8c0>
8000c6a4:	30 08       	mov	r8,0
8000c6a6:	30 09       	mov	r9,0
8000c6a8:	40 5b       	lddsp	r11,sp[0x14]
8000c6aa:	40 7a       	lddsp	r10,sp[0x1c]
8000c6ac:	e0 a0 1d a8 	rcall	800101fc <__avr32_f64_cmp_lt>
8000c6b0:	c0 40       	breq	8000c6b8 <_vfprintf_r+0x8a8>
8000c6b2:	32 d8       	mov	r8,45
8000c6b4:	fb 68 06 bb 	st.b	sp[1723],r8
8000c6b8:	fe c8 ae 68 	sub	r8,pc,-20888
8000c6bc:	fe c6 ae 68 	sub	r6,pc,-20888
8000c6c0:	a7 d5       	cbr	r5,0x7
8000c6c2:	e0 40 00 47 	cp.w	r0,71
8000c6c6:	f0 06 17 a0 	movle	r6,r8
8000c6ca:	30 32       	mov	r2,3
8000c6cc:	e0 8f 06 ce 	bral	8000d468 <_vfprintf_r+0x1658>
8000c6d0:	40 5b       	lddsp	r11,sp[0x14]
8000c6d2:	40 7a       	lddsp	r10,sp[0x1c]
8000c6d4:	e0 a0 19 4d 	rcall	8000f96e <__isnand>
8000c6d8:	c0 e0       	breq	8000c6f4 <_vfprintf_r+0x8e4>
8000c6da:	50 26       	stdsp	sp[0x8],r6
8000c6dc:	fe c8 ae 84 	sub	r8,pc,-20860
8000c6e0:	fe c6 ae 84 	sub	r6,pc,-20860
8000c6e4:	a7 d5       	cbr	r5,0x7
8000c6e6:	e0 40 00 47 	cp.w	r0,71
8000c6ea:	f0 06 17 a0 	movle	r6,r8
8000c6ee:	30 32       	mov	r2,3
8000c6f0:	e0 8f 06 c2 	bral	8000d474 <_vfprintf_r+0x1664>
8000c6f4:	40 2a       	lddsp	r10,sp[0x8]
8000c6f6:	5b fa       	cp.w	r10,-1
8000c6f8:	c0 41       	brne	8000c700 <_vfprintf_r+0x8f0>
8000c6fa:	30 69       	mov	r9,6
8000c6fc:	50 29       	stdsp	sp[0x8],r9
8000c6fe:	c1 18       	rjmp	8000c720 <_vfprintf_r+0x910>
8000c700:	e0 40 00 47 	cp.w	r0,71
8000c704:	5f 09       	sreq	r9
8000c706:	e0 40 00 67 	cp.w	r0,103
8000c70a:	5f 08       	sreq	r8
8000c70c:	f3 e8 10 08 	or	r8,r9,r8
8000c710:	f8 08 18 00 	cp.b	r8,r12
8000c714:	c0 60       	breq	8000c720 <_vfprintf_r+0x910>
8000c716:	40 28       	lddsp	r8,sp[0x8]
8000c718:	58 08       	cp.w	r8,0
8000c71a:	f9 b8 00 01 	moveq	r8,1
8000c71e:	50 28       	stdsp	sp[0x8],r8
8000c720:	40 78       	lddsp	r8,sp[0x1c]
8000c722:	40 59       	lddsp	r9,sp[0x14]
8000c724:	fa e9 06 94 	st.d	sp[1684],r8
8000c728:	a9 a5       	sbr	r5,0x8
8000c72a:	fa f8 06 94 	ld.w	r8,sp[1684]
8000c72e:	58 08       	cp.w	r8,0
8000c730:	c0 65       	brlt	8000c73c <_vfprintf_r+0x92c>
8000c732:	40 5e       	lddsp	lr,sp[0x14]
8000c734:	30 0c       	mov	r12,0
8000c736:	50 6e       	stdsp	sp[0x18],lr
8000c738:	50 9c       	stdsp	sp[0x24],r12
8000c73a:	c0 78       	rjmp	8000c748 <_vfprintf_r+0x938>
8000c73c:	40 5b       	lddsp	r11,sp[0x14]
8000c73e:	32 da       	mov	r10,45
8000c740:	ee 1b 80 00 	eorh	r11,0x8000
8000c744:	50 9a       	stdsp	sp[0x24],r10
8000c746:	50 6b       	stdsp	sp[0x18],r11
8000c748:	e0 40 00 46 	cp.w	r0,70
8000c74c:	5f 09       	sreq	r9
8000c74e:	e0 40 00 66 	cp.w	r0,102
8000c752:	5f 08       	sreq	r8
8000c754:	f3 e8 10 08 	or	r8,r9,r8
8000c758:	50 48       	stdsp	sp[0x10],r8
8000c75a:	c0 40       	breq	8000c762 <_vfprintf_r+0x952>
8000c75c:	40 22       	lddsp	r2,sp[0x8]
8000c75e:	30 39       	mov	r9,3
8000c760:	c1 08       	rjmp	8000c780 <_vfprintf_r+0x970>
8000c762:	e0 40 00 45 	cp.w	r0,69
8000c766:	5f 09       	sreq	r9
8000c768:	e0 40 00 65 	cp.w	r0,101
8000c76c:	5f 08       	sreq	r8
8000c76e:	40 22       	lddsp	r2,sp[0x8]
8000c770:	10 49       	or	r9,r8
8000c772:	2f f2       	sub	r2,-1
8000c774:	40 46       	lddsp	r6,sp[0x10]
8000c776:	ec 09 18 00 	cp.b	r9,r6
8000c77a:	fb f2 00 02 	ld.weq	r2,sp[0x8]
8000c77e:	30 29       	mov	r9,2
8000c780:	fa c8 f9 5c 	sub	r8,sp,-1700
8000c784:	1a d8       	st.w	--sp,r8
8000c786:	fa c8 f9 54 	sub	r8,sp,-1708
8000c78a:	1a d8       	st.w	--sp,r8
8000c78c:	fa c8 f9 4c 	sub	r8,sp,-1716
8000c790:	08 9c       	mov	r12,r4
8000c792:	1a d8       	st.w	--sp,r8
8000c794:	04 98       	mov	r8,r2
8000c796:	40 9b       	lddsp	r11,sp[0x24]
8000c798:	40 aa       	lddsp	r10,sp[0x28]
8000c79a:	e0 a0 0b c3 	rcall	8000df20 <_dtoa_r>
8000c79e:	e0 40 00 47 	cp.w	r0,71
8000c7a2:	5f 19       	srne	r9
8000c7a4:	e0 40 00 67 	cp.w	r0,103
8000c7a8:	5f 18       	srne	r8
8000c7aa:	18 96       	mov	r6,r12
8000c7ac:	2f dd       	sub	sp,-12
8000c7ae:	f3 e8 00 08 	and	r8,r9,r8
8000c7b2:	c0 41       	brne	8000c7ba <_vfprintf_r+0x9aa>
8000c7b4:	ed b5 00 00 	bld	r5,0x0
8000c7b8:	c3 01       	brne	8000c818 <_vfprintf_r+0xa08>
8000c7ba:	ec 02 00 0e 	add	lr,r6,r2
8000c7be:	50 3e       	stdsp	sp[0xc],lr
8000c7c0:	40 4c       	lddsp	r12,sp[0x10]
8000c7c2:	58 0c       	cp.w	r12,0
8000c7c4:	c1 50       	breq	8000c7ee <_vfprintf_r+0x9de>
8000c7c6:	0d 89       	ld.ub	r9,r6[0x0]
8000c7c8:	33 08       	mov	r8,48
8000c7ca:	f0 09 18 00 	cp.b	r9,r8
8000c7ce:	c0 b1       	brne	8000c7e4 <_vfprintf_r+0x9d4>
8000c7d0:	30 08       	mov	r8,0
8000c7d2:	30 09       	mov	r9,0
8000c7d4:	40 6b       	lddsp	r11,sp[0x18]
8000c7d6:	40 7a       	lddsp	r10,sp[0x1c]
8000c7d8:	e0 a0 1c cb 	rcall	8001016e <__avr32_f64_cmp_eq>
8000c7dc:	fb b2 00 01 	rsubeq	r2,1
8000c7e0:	fb f2 0b ab 	st.weq	sp[0x6ac],r2
8000c7e4:	40 3b       	lddsp	r11,sp[0xc]
8000c7e6:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000c7ea:	10 0b       	add	r11,r8
8000c7ec:	50 3b       	stdsp	sp[0xc],r11
8000c7ee:	40 6b       	lddsp	r11,sp[0x18]
8000c7f0:	30 08       	mov	r8,0
8000c7f2:	30 09       	mov	r9,0
8000c7f4:	40 7a       	lddsp	r10,sp[0x1c]
8000c7f6:	e0 a0 1c bc 	rcall	8001016e <__avr32_f64_cmp_eq>
8000c7fa:	c0 90       	breq	8000c80c <_vfprintf_r+0x9fc>
8000c7fc:	40 3a       	lddsp	r10,sp[0xc]
8000c7fe:	fb 4a 06 a4 	st.w	sp[1700],r10
8000c802:	c0 58       	rjmp	8000c80c <_vfprintf_r+0x9fc>
8000c804:	10 c9       	st.b	r8++,r9
8000c806:	fb 48 06 a4 	st.w	sp[1700],r8
8000c80a:	c0 28       	rjmp	8000c80e <_vfprintf_r+0x9fe>
8000c80c:	33 09       	mov	r9,48
8000c80e:	fa f8 06 a4 	ld.w	r8,sp[1700]
8000c812:	40 3e       	lddsp	lr,sp[0xc]
8000c814:	1c 38       	cp.w	r8,lr
8000c816:	cf 73       	brcs	8000c804 <_vfprintf_r+0x9f4>
8000c818:	e0 40 00 47 	cp.w	r0,71
8000c81c:	5f 09       	sreq	r9
8000c81e:	e0 40 00 67 	cp.w	r0,103
8000c822:	5f 08       	sreq	r8
8000c824:	f3 e8 10 08 	or	r8,r9,r8
8000c828:	fa f9 06 a4 	ld.w	r9,sp[1700]
8000c82c:	0c 19       	sub	r9,r6
8000c82e:	50 69       	stdsp	sp[0x18],r9
8000c830:	58 08       	cp.w	r8,0
8000c832:	c0 b0       	breq	8000c848 <_vfprintf_r+0xa38>
8000c834:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000c838:	5b d8       	cp.w	r8,-3
8000c83a:	c0 55       	brlt	8000c844 <_vfprintf_r+0xa34>
8000c83c:	40 2c       	lddsp	r12,sp[0x8]
8000c83e:	18 38       	cp.w	r8,r12
8000c840:	e0 8a 00 6a 	brle	8000c914 <_vfprintf_r+0xb04>
8000c844:	20 20       	sub	r0,2
8000c846:	c0 58       	rjmp	8000c850 <_vfprintf_r+0xa40>
8000c848:	e0 40 00 65 	cp.w	r0,101
8000c84c:	e0 89 00 46 	brgt	8000c8d8 <_vfprintf_r+0xac8>
8000c850:	fa fb 06 ac 	ld.w	r11,sp[1708]
8000c854:	fb 60 06 9c 	st.b	sp[1692],r0
8000c858:	20 1b       	sub	r11,1
8000c85a:	fb 4b 06 ac 	st.w	sp[1708],r11
8000c85e:	c0 47       	brpl	8000c866 <_vfprintf_r+0xa56>
8000c860:	5c 3b       	neg	r11
8000c862:	32 d8       	mov	r8,45
8000c864:	c0 28       	rjmp	8000c868 <_vfprintf_r+0xa58>
8000c866:	32 b8       	mov	r8,43
8000c868:	fb 68 06 9d 	st.b	sp[1693],r8
8000c86c:	58 9b       	cp.w	r11,9
8000c86e:	e0 8a 00 1d 	brle	8000c8a8 <_vfprintf_r+0xa98>
8000c872:	fa c9 fa 35 	sub	r9,sp,-1483
8000c876:	30 aa       	mov	r10,10
8000c878:	12 98       	mov	r8,r9
8000c87a:	0e 9c       	mov	r12,r7
8000c87c:	0c 92       	mov	r2,r6
8000c87e:	f6 0a 0c 06 	divs	r6,r11,r10
8000c882:	0e 9b       	mov	r11,r7
8000c884:	2d 0b       	sub	r11,-48
8000c886:	10 fb       	st.b	--r8,r11
8000c888:	0c 9b       	mov	r11,r6
8000c88a:	58 96       	cp.w	r6,9
8000c88c:	fe 99 ff f9 	brgt	8000c87e <_vfprintf_r+0xa6e>
8000c890:	2d 0b       	sub	r11,-48
8000c892:	18 97       	mov	r7,r12
8000c894:	04 96       	mov	r6,r2
8000c896:	10 fb       	st.b	--r8,r11
8000c898:	fa ca f9 62 	sub	r10,sp,-1694
8000c89c:	c0 38       	rjmp	8000c8a2 <_vfprintf_r+0xa92>
8000c89e:	11 3b       	ld.ub	r11,r8++
8000c8a0:	14 cb       	st.b	r10++,r11
8000c8a2:	12 38       	cp.w	r8,r9
8000c8a4:	cf d3       	brcs	8000c89e <_vfprintf_r+0xa8e>
8000c8a6:	c0 98       	rjmp	8000c8b8 <_vfprintf_r+0xaa8>
8000c8a8:	2d 0b       	sub	r11,-48
8000c8aa:	33 08       	mov	r8,48
8000c8ac:	fb 6b 06 9f 	st.b	sp[1695],r11
8000c8b0:	fb 68 06 9e 	st.b	sp[1694],r8
8000c8b4:	fa ca f9 60 	sub	r10,sp,-1696
8000c8b8:	fa c8 f9 64 	sub	r8,sp,-1692
8000c8bc:	f4 08 01 08 	sub	r8,r10,r8
8000c8c0:	50 e8       	stdsp	sp[0x38],r8
8000c8c2:	10 92       	mov	r2,r8
8000c8c4:	40 6b       	lddsp	r11,sp[0x18]
8000c8c6:	16 02       	add	r2,r11
8000c8c8:	58 1b       	cp.w	r11,1
8000c8ca:	e0 89 00 05 	brgt	8000c8d4 <_vfprintf_r+0xac4>
8000c8ce:	ed b5 00 00 	bld	r5,0x0
8000c8d2:	c3 51       	brne	8000c93c <_vfprintf_r+0xb2c>
8000c8d4:	2f f2       	sub	r2,-1
8000c8d6:	c3 38       	rjmp	8000c93c <_vfprintf_r+0xb2c>
8000c8d8:	e0 40 00 66 	cp.w	r0,102
8000c8dc:	c1 c1       	brne	8000c914 <_vfprintf_r+0xb04>
8000c8de:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000c8e2:	58 02       	cp.w	r2,0
8000c8e4:	e0 8a 00 0c 	brle	8000c8fc <_vfprintf_r+0xaec>
8000c8e8:	40 2a       	lddsp	r10,sp[0x8]
8000c8ea:	58 0a       	cp.w	r10,0
8000c8ec:	c0 41       	brne	8000c8f4 <_vfprintf_r+0xae4>
8000c8ee:	ed b5 00 00 	bld	r5,0x0
8000c8f2:	c2 51       	brne	8000c93c <_vfprintf_r+0xb2c>
8000c8f4:	2f f2       	sub	r2,-1
8000c8f6:	40 29       	lddsp	r9,sp[0x8]
8000c8f8:	12 02       	add	r2,r9
8000c8fa:	c0 b8       	rjmp	8000c910 <_vfprintf_r+0xb00>
8000c8fc:	40 28       	lddsp	r8,sp[0x8]
8000c8fe:	58 08       	cp.w	r8,0
8000c900:	c0 61       	brne	8000c90c <_vfprintf_r+0xafc>
8000c902:	ed b5 00 00 	bld	r5,0x0
8000c906:	c0 30       	breq	8000c90c <_vfprintf_r+0xafc>
8000c908:	30 12       	mov	r2,1
8000c90a:	c1 98       	rjmp	8000c93c <_vfprintf_r+0xb2c>
8000c90c:	40 22       	lddsp	r2,sp[0x8]
8000c90e:	2f e2       	sub	r2,-2
8000c910:	36 60       	mov	r0,102
8000c912:	c1 58       	rjmp	8000c93c <_vfprintf_r+0xb2c>
8000c914:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000c918:	40 6e       	lddsp	lr,sp[0x18]
8000c91a:	1c 32       	cp.w	r2,lr
8000c91c:	c0 65       	brlt	8000c928 <_vfprintf_r+0xb18>
8000c91e:	ed b5 00 00 	bld	r5,0x0
8000c922:	f7 b2 00 ff 	subeq	r2,-1
8000c926:	c0 a8       	rjmp	8000c93a <_vfprintf_r+0xb2a>
8000c928:	e4 08 11 02 	rsub	r8,r2,2
8000c92c:	40 6c       	lddsp	r12,sp[0x18]
8000c92e:	58 02       	cp.w	r2,0
8000c930:	f0 02 17 a0 	movle	r2,r8
8000c934:	f9 b2 09 01 	movgt	r2,1
8000c938:	18 02       	add	r2,r12
8000c93a:	36 70       	mov	r0,103
8000c93c:	40 9b       	lddsp	r11,sp[0x24]
8000c93e:	58 0b       	cp.w	r11,0
8000c940:	e0 80 05 94 	breq	8000d468 <_vfprintf_r+0x1658>
8000c944:	32 d8       	mov	r8,45
8000c946:	fb 68 06 bb 	st.b	sp[1723],r8
8000c94a:	e0 8f 05 93 	bral	8000d470 <_vfprintf_r+0x1660>
8000c94e:	50 a7       	stdsp	sp[0x28],r7
8000c950:	04 94       	mov	r4,r2
8000c952:	0c 97       	mov	r7,r6
8000c954:	02 92       	mov	r2,r1
8000c956:	06 96       	mov	r6,r3
8000c958:	40 41       	lddsp	r1,sp[0x10]
8000c95a:	40 93       	lddsp	r3,sp[0x24]
8000c95c:	0e 99       	mov	r9,r7
8000c95e:	ed b5 00 05 	bld	r5,0x5
8000c962:	c4 81       	brne	8000c9f2 <_vfprintf_r+0xbe2>
8000c964:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c968:	40 3e       	lddsp	lr,sp[0xc]
8000c96a:	58 0e       	cp.w	lr,0
8000c96c:	c1 d0       	breq	8000c9a6 <_vfprintf_r+0xb96>
8000c96e:	10 36       	cp.w	r6,r8
8000c970:	c0 64       	brge	8000c97c <_vfprintf_r+0xb6c>
8000c972:	fa cc f9 44 	sub	r12,sp,-1724
8000c976:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000c97a:	c1 d8       	rjmp	8000c9b4 <_vfprintf_r+0xba4>
8000c97c:	fa c8 f9 50 	sub	r8,sp,-1712
8000c980:	1a d8       	st.w	--sp,r8
8000c982:	fa c8 fa b8 	sub	r8,sp,-1352
8000c986:	04 9a       	mov	r10,r2
8000c988:	1a d8       	st.w	--sp,r8
8000c98a:	fa c8 fb b4 	sub	r8,sp,-1100
8000c98e:	0c 9b       	mov	r11,r6
8000c990:	1a d8       	st.w	--sp,r8
8000c992:	08 9c       	mov	r12,r4
8000c994:	fa c8 f9 40 	sub	r8,sp,-1728
8000c998:	fa c9 ff b4 	sub	r9,sp,-76
8000c99c:	fe b0 f8 a2 	rcall	8000bae0 <get_arg>
8000c9a0:	2f dd       	sub	sp,-12
8000c9a2:	78 0a       	ld.w	r10,r12[0x0]
8000c9a4:	c2 08       	rjmp	8000c9e4 <_vfprintf_r+0xbd4>
8000c9a6:	2f f7       	sub	r7,-1
8000c9a8:	10 39       	cp.w	r9,r8
8000c9aa:	c0 84       	brge	8000c9ba <_vfprintf_r+0xbaa>
8000c9ac:	fa cb f9 44 	sub	r11,sp,-1724
8000c9b0:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000c9b4:	ec fa fd 88 	ld.w	r10,r6[-632]
8000c9b8:	c1 68       	rjmp	8000c9e4 <_vfprintf_r+0xbd4>
8000c9ba:	41 09       	lddsp	r9,sp[0x40]
8000c9bc:	59 f8       	cp.w	r8,31
8000c9be:	e0 89 00 10 	brgt	8000c9de <_vfprintf_r+0xbce>
8000c9c2:	f2 ca ff fc 	sub	r10,r9,-4
8000c9c6:	51 0a       	stdsp	sp[0x40],r10
8000c9c8:	fa c6 f9 44 	sub	r6,sp,-1724
8000c9cc:	72 0a       	ld.w	r10,r9[0x0]
8000c9ce:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000c9d2:	f3 4a fd 88 	st.w	r9[-632],r10
8000c9d6:	2f f8       	sub	r8,-1
8000c9d8:	fb 48 06 b4 	st.w	sp[1716],r8
8000c9dc:	c0 48       	rjmp	8000c9e4 <_vfprintf_r+0xbd4>
8000c9de:	72 0a       	ld.w	r10,r9[0x0]
8000c9e0:	2f c9       	sub	r9,-4
8000c9e2:	51 09       	stdsp	sp[0x40],r9
8000c9e4:	40 be       	lddsp	lr,sp[0x2c]
8000c9e6:	1c 98       	mov	r8,lr
8000c9e8:	95 1e       	st.w	r10[0x4],lr
8000c9ea:	bf 58       	asr	r8,0x1f
8000c9ec:	95 08       	st.w	r10[0x0],r8
8000c9ee:	fe 9f fa 9f 	bral	8000bf2c <_vfprintf_r+0x11c>
8000c9f2:	ed b5 00 04 	bld	r5,0x4
8000c9f6:	c4 80       	breq	8000ca86 <_vfprintf_r+0xc76>
8000c9f8:	e2 15 00 40 	andl	r5,0x40,COH
8000c9fc:	c4 50       	breq	8000ca86 <_vfprintf_r+0xc76>
8000c9fe:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000ca02:	40 3c       	lddsp	r12,sp[0xc]
8000ca04:	58 0c       	cp.w	r12,0
8000ca06:	c1 d0       	breq	8000ca40 <_vfprintf_r+0xc30>
8000ca08:	10 36       	cp.w	r6,r8
8000ca0a:	c0 64       	brge	8000ca16 <_vfprintf_r+0xc06>
8000ca0c:	fa cb f9 44 	sub	r11,sp,-1724
8000ca10:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000ca14:	c1 d8       	rjmp	8000ca4e <_vfprintf_r+0xc3e>
8000ca16:	fa c8 f9 50 	sub	r8,sp,-1712
8000ca1a:	1a d8       	st.w	--sp,r8
8000ca1c:	fa c8 fa b8 	sub	r8,sp,-1352
8000ca20:	04 9a       	mov	r10,r2
8000ca22:	1a d8       	st.w	--sp,r8
8000ca24:	fa c8 fb b4 	sub	r8,sp,-1100
8000ca28:	0c 9b       	mov	r11,r6
8000ca2a:	1a d8       	st.w	--sp,r8
8000ca2c:	08 9c       	mov	r12,r4
8000ca2e:	fa c8 f9 40 	sub	r8,sp,-1728
8000ca32:	fa c9 ff b4 	sub	r9,sp,-76
8000ca36:	fe b0 f8 55 	rcall	8000bae0 <get_arg>
8000ca3a:	2f dd       	sub	sp,-12
8000ca3c:	78 0a       	ld.w	r10,r12[0x0]
8000ca3e:	c2 08       	rjmp	8000ca7e <_vfprintf_r+0xc6e>
8000ca40:	2f f7       	sub	r7,-1
8000ca42:	10 39       	cp.w	r9,r8
8000ca44:	c0 84       	brge	8000ca54 <_vfprintf_r+0xc44>
8000ca46:	fa ca f9 44 	sub	r10,sp,-1724
8000ca4a:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000ca4e:	ec fa fd 88 	ld.w	r10,r6[-632]
8000ca52:	c1 68       	rjmp	8000ca7e <_vfprintf_r+0xc6e>
8000ca54:	41 09       	lddsp	r9,sp[0x40]
8000ca56:	59 f8       	cp.w	r8,31
8000ca58:	e0 89 00 10 	brgt	8000ca78 <_vfprintf_r+0xc68>
8000ca5c:	f2 ca ff fc 	sub	r10,r9,-4
8000ca60:	51 0a       	stdsp	sp[0x40],r10
8000ca62:	fa c6 f9 44 	sub	r6,sp,-1724
8000ca66:	72 0a       	ld.w	r10,r9[0x0]
8000ca68:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000ca6c:	f3 4a fd 88 	st.w	r9[-632],r10
8000ca70:	2f f8       	sub	r8,-1
8000ca72:	fb 48 06 b4 	st.w	sp[1716],r8
8000ca76:	c0 48       	rjmp	8000ca7e <_vfprintf_r+0xc6e>
8000ca78:	72 0a       	ld.w	r10,r9[0x0]
8000ca7a:	2f c9       	sub	r9,-4
8000ca7c:	51 09       	stdsp	sp[0x40],r9
8000ca7e:	40 be       	lddsp	lr,sp[0x2c]
8000ca80:	b4 0e       	st.h	r10[0x0],lr
8000ca82:	fe 9f fa 55 	bral	8000bf2c <_vfprintf_r+0x11c>
8000ca86:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000ca8a:	40 3c       	lddsp	r12,sp[0xc]
8000ca8c:	58 0c       	cp.w	r12,0
8000ca8e:	c1 d0       	breq	8000cac8 <_vfprintf_r+0xcb8>
8000ca90:	10 36       	cp.w	r6,r8
8000ca92:	c0 64       	brge	8000ca9e <_vfprintf_r+0xc8e>
8000ca94:	fa cb f9 44 	sub	r11,sp,-1724
8000ca98:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000ca9c:	c1 d8       	rjmp	8000cad6 <_vfprintf_r+0xcc6>
8000ca9e:	fa c8 f9 50 	sub	r8,sp,-1712
8000caa2:	1a d8       	st.w	--sp,r8
8000caa4:	fa c8 fa b8 	sub	r8,sp,-1352
8000caa8:	04 9a       	mov	r10,r2
8000caaa:	1a d8       	st.w	--sp,r8
8000caac:	fa c8 fb b4 	sub	r8,sp,-1100
8000cab0:	0c 9b       	mov	r11,r6
8000cab2:	1a d8       	st.w	--sp,r8
8000cab4:	08 9c       	mov	r12,r4
8000cab6:	fa c8 f9 40 	sub	r8,sp,-1728
8000caba:	fa c9 ff b4 	sub	r9,sp,-76
8000cabe:	fe b0 f8 11 	rcall	8000bae0 <get_arg>
8000cac2:	2f dd       	sub	sp,-12
8000cac4:	78 0a       	ld.w	r10,r12[0x0]
8000cac6:	c2 08       	rjmp	8000cb06 <_vfprintf_r+0xcf6>
8000cac8:	2f f7       	sub	r7,-1
8000caca:	10 39       	cp.w	r9,r8
8000cacc:	c0 84       	brge	8000cadc <_vfprintf_r+0xccc>
8000cace:	fa ca f9 44 	sub	r10,sp,-1724
8000cad2:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000cad6:	ec fa fd 88 	ld.w	r10,r6[-632]
8000cada:	c1 68       	rjmp	8000cb06 <_vfprintf_r+0xcf6>
8000cadc:	41 09       	lddsp	r9,sp[0x40]
8000cade:	59 f8       	cp.w	r8,31
8000cae0:	e0 89 00 10 	brgt	8000cb00 <_vfprintf_r+0xcf0>
8000cae4:	f2 ca ff fc 	sub	r10,r9,-4
8000cae8:	51 0a       	stdsp	sp[0x40],r10
8000caea:	fa c6 f9 44 	sub	r6,sp,-1724
8000caee:	72 0a       	ld.w	r10,r9[0x0]
8000caf0:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000caf4:	f3 4a fd 88 	st.w	r9[-632],r10
8000caf8:	2f f8       	sub	r8,-1
8000cafa:	fb 48 06 b4 	st.w	sp[1716],r8
8000cafe:	c0 48       	rjmp	8000cb06 <_vfprintf_r+0xcf6>
8000cb00:	72 0a       	ld.w	r10,r9[0x0]
8000cb02:	2f c9       	sub	r9,-4
8000cb04:	51 09       	stdsp	sp[0x40],r9
8000cb06:	40 be       	lddsp	lr,sp[0x2c]
8000cb08:	95 0e       	st.w	r10[0x0],lr
8000cb0a:	fe 9f fa 11 	bral	8000bf2c <_vfprintf_r+0x11c>
8000cb0e:	50 a7       	stdsp	sp[0x28],r7
8000cb10:	50 80       	stdsp	sp[0x20],r0
8000cb12:	0c 97       	mov	r7,r6
8000cb14:	04 94       	mov	r4,r2
8000cb16:	06 96       	mov	r6,r3
8000cb18:	02 92       	mov	r2,r1
8000cb1a:	40 93       	lddsp	r3,sp[0x24]
8000cb1c:	10 90       	mov	r0,r8
8000cb1e:	40 41       	lddsp	r1,sp[0x10]
8000cb20:	a5 a5       	sbr	r5,0x4
8000cb22:	c0 a8       	rjmp	8000cb36 <_vfprintf_r+0xd26>
8000cb24:	50 a7       	stdsp	sp[0x28],r7
8000cb26:	50 80       	stdsp	sp[0x20],r0
8000cb28:	0c 97       	mov	r7,r6
8000cb2a:	04 94       	mov	r4,r2
8000cb2c:	06 96       	mov	r6,r3
8000cb2e:	02 92       	mov	r2,r1
8000cb30:	40 93       	lddsp	r3,sp[0x24]
8000cb32:	10 90       	mov	r0,r8
8000cb34:	40 41       	lddsp	r1,sp[0x10]
8000cb36:	ed b5 00 05 	bld	r5,0x5
8000cb3a:	c5 d1       	brne	8000cbf4 <_vfprintf_r+0xde4>
8000cb3c:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000cb40:	40 3c       	lddsp	r12,sp[0xc]
8000cb42:	58 0c       	cp.w	r12,0
8000cb44:	c2 60       	breq	8000cb90 <_vfprintf_r+0xd80>
8000cb46:	10 36       	cp.w	r6,r8
8000cb48:	c0 a4       	brge	8000cb5c <_vfprintf_r+0xd4c>
8000cb4a:	fa cb f9 44 	sub	r11,sp,-1724
8000cb4e:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000cb52:	ec e8 fd 88 	ld.d	r8,r6[-632]
8000cb56:	fa e9 00 00 	st.d	sp[0],r8
8000cb5a:	c1 88       	rjmp	8000cb8a <_vfprintf_r+0xd7a>
8000cb5c:	fa c8 f9 50 	sub	r8,sp,-1712
8000cb60:	1a d8       	st.w	--sp,r8
8000cb62:	fa c8 fa b8 	sub	r8,sp,-1352
8000cb66:	04 9a       	mov	r10,r2
8000cb68:	1a d8       	st.w	--sp,r8
8000cb6a:	0c 9b       	mov	r11,r6
8000cb6c:	fa c8 fb b4 	sub	r8,sp,-1100
8000cb70:	08 9c       	mov	r12,r4
8000cb72:	1a d8       	st.w	--sp,r8
8000cb74:	fa c8 f9 40 	sub	r8,sp,-1728
8000cb78:	fa c9 ff b4 	sub	r9,sp,-76
8000cb7c:	fe b0 f7 b2 	rcall	8000bae0 <get_arg>
8000cb80:	2f dd       	sub	sp,-12
8000cb82:	f8 ea 00 00 	ld.d	r10,r12[0]
8000cb86:	fa eb 00 00 	st.d	sp[0],r10
8000cb8a:	30 08       	mov	r8,0
8000cb8c:	e0 8f 03 de 	bral	8000d348 <_vfprintf_r+0x1538>
8000cb90:	ee ca ff ff 	sub	r10,r7,-1
8000cb94:	10 37       	cp.w	r7,r8
8000cb96:	c0 b4       	brge	8000cbac <_vfprintf_r+0xd9c>
8000cb98:	fa c9 f9 44 	sub	r9,sp,-1724
8000cb9c:	14 97       	mov	r7,r10
8000cb9e:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000cba2:	ec ea fd 88 	ld.d	r10,r6[-632]
8000cba6:	fa eb 00 00 	st.d	sp[0],r10
8000cbaa:	c1 88       	rjmp	8000cbda <_vfprintf_r+0xdca>
8000cbac:	41 09       	lddsp	r9,sp[0x40]
8000cbae:	59 f8       	cp.w	r8,31
8000cbb0:	e0 89 00 18 	brgt	8000cbe0 <_vfprintf_r+0xdd0>
8000cbb4:	f2 e6 00 00 	ld.d	r6,r9[0]
8000cbb8:	f2 cb ff f8 	sub	r11,r9,-8
8000cbbc:	fa e7 00 00 	st.d	sp[0],r6
8000cbc0:	51 0b       	stdsp	sp[0x40],r11
8000cbc2:	fa c6 f9 44 	sub	r6,sp,-1724
8000cbc6:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000cbca:	fa e6 00 00 	ld.d	r6,sp[0]
8000cbce:	f2 e7 fd 88 	st.d	r9[-632],r6
8000cbd2:	2f f8       	sub	r8,-1
8000cbd4:	14 97       	mov	r7,r10
8000cbd6:	fb 48 06 b4 	st.w	sp[1716],r8
8000cbda:	40 38       	lddsp	r8,sp[0xc]
8000cbdc:	e0 8f 03 b6 	bral	8000d348 <_vfprintf_r+0x1538>
8000cbe0:	f2 e6 00 00 	ld.d	r6,r9[0]
8000cbe4:	40 38       	lddsp	r8,sp[0xc]
8000cbe6:	fa e7 00 00 	st.d	sp[0],r6
8000cbea:	2f 89       	sub	r9,-8
8000cbec:	14 97       	mov	r7,r10
8000cbee:	51 09       	stdsp	sp[0x40],r9
8000cbf0:	e0 8f 03 ac 	bral	8000d348 <_vfprintf_r+0x1538>
8000cbf4:	ed b5 00 04 	bld	r5,0x4
8000cbf8:	c1 61       	brne	8000cc24 <_vfprintf_r+0xe14>
8000cbfa:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000cbfe:	40 3e       	lddsp	lr,sp[0xc]
8000cc00:	58 0e       	cp.w	lr,0
8000cc02:	c0 80       	breq	8000cc12 <_vfprintf_r+0xe02>
8000cc04:	10 36       	cp.w	r6,r8
8000cc06:	c6 74       	brge	8000ccd4 <_vfprintf_r+0xec4>
8000cc08:	fa cc f9 44 	sub	r12,sp,-1724
8000cc0c:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000cc10:	c8 08       	rjmp	8000cd10 <_vfprintf_r+0xf00>
8000cc12:	ee ca ff ff 	sub	r10,r7,-1
8000cc16:	10 37       	cp.w	r7,r8
8000cc18:	c7 f4       	brge	8000cd16 <_vfprintf_r+0xf06>
8000cc1a:	fa cb f9 44 	sub	r11,sp,-1724
8000cc1e:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000cc22:	c7 68       	rjmp	8000cd0e <_vfprintf_r+0xefe>
8000cc24:	ed b5 00 06 	bld	r5,0x6
8000cc28:	c4 a1       	brne	8000ccbc <_vfprintf_r+0xeac>
8000cc2a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000cc2e:	40 3c       	lddsp	r12,sp[0xc]
8000cc30:	58 0c       	cp.w	r12,0
8000cc32:	c1 d0       	breq	8000cc6c <_vfprintf_r+0xe5c>
8000cc34:	10 36       	cp.w	r6,r8
8000cc36:	c0 64       	brge	8000cc42 <_vfprintf_r+0xe32>
8000cc38:	fa cb f9 44 	sub	r11,sp,-1724
8000cc3c:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000cc40:	c1 f8       	rjmp	8000cc7e <_vfprintf_r+0xe6e>
8000cc42:	fa c8 f9 50 	sub	r8,sp,-1712
8000cc46:	1a d8       	st.w	--sp,r8
8000cc48:	fa c8 fa b8 	sub	r8,sp,-1352
8000cc4c:	1a d8       	st.w	--sp,r8
8000cc4e:	fa c8 fb b4 	sub	r8,sp,-1100
8000cc52:	1a d8       	st.w	--sp,r8
8000cc54:	fa c8 f9 40 	sub	r8,sp,-1728
8000cc58:	fa c9 ff b4 	sub	r9,sp,-76
8000cc5c:	04 9a       	mov	r10,r2
8000cc5e:	0c 9b       	mov	r11,r6
8000cc60:	08 9c       	mov	r12,r4
8000cc62:	fe b0 f7 3f 	rcall	8000bae0 <get_arg>
8000cc66:	2f dd       	sub	sp,-12
8000cc68:	98 18       	ld.sh	r8,r12[0x2]
8000cc6a:	c2 68       	rjmp	8000ccb6 <_vfprintf_r+0xea6>
8000cc6c:	ee ca ff ff 	sub	r10,r7,-1
8000cc70:	10 37       	cp.w	r7,r8
8000cc72:	c0 94       	brge	8000cc84 <_vfprintf_r+0xe74>
8000cc74:	fa c9 f9 44 	sub	r9,sp,-1724
8000cc78:	14 97       	mov	r7,r10
8000cc7a:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000cc7e:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000cc82:	c1 a8       	rjmp	8000ccb6 <_vfprintf_r+0xea6>
8000cc84:	41 09       	lddsp	r9,sp[0x40]
8000cc86:	59 f8       	cp.w	r8,31
8000cc88:	e0 89 00 13 	brgt	8000ccae <_vfprintf_r+0xe9e>
8000cc8c:	f2 cb ff fc 	sub	r11,r9,-4
8000cc90:	51 0b       	stdsp	sp[0x40],r11
8000cc92:	72 09       	ld.w	r9,r9[0x0]
8000cc94:	fa c6 f9 44 	sub	r6,sp,-1724
8000cc98:	ec 08 00 3b 	add	r11,r6,r8<<0x3
8000cc9c:	2f f8       	sub	r8,-1
8000cc9e:	f7 49 fd 88 	st.w	r11[-632],r9
8000cca2:	fb 48 06 b4 	st.w	sp[1716],r8
8000cca6:	14 97       	mov	r7,r10
8000cca8:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
8000ccac:	c0 58       	rjmp	8000ccb6 <_vfprintf_r+0xea6>
8000ccae:	92 18       	ld.sh	r8,r9[0x2]
8000ccb0:	14 97       	mov	r7,r10
8000ccb2:	2f c9       	sub	r9,-4
8000ccb4:	51 09       	stdsp	sp[0x40],r9
8000ccb6:	5c 78       	castu.h	r8
8000ccb8:	50 18       	stdsp	sp[0x4],r8
8000ccba:	c4 68       	rjmp	8000cd46 <_vfprintf_r+0xf36>
8000ccbc:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000ccc0:	40 3c       	lddsp	r12,sp[0xc]
8000ccc2:	58 0c       	cp.w	r12,0
8000ccc4:	c1 d0       	breq	8000ccfe <_vfprintf_r+0xeee>
8000ccc6:	10 36       	cp.w	r6,r8
8000ccc8:	c0 64       	brge	8000ccd4 <_vfprintf_r+0xec4>
8000ccca:	fa cb f9 44 	sub	r11,sp,-1724
8000ccce:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000ccd2:	c1 f8       	rjmp	8000cd10 <_vfprintf_r+0xf00>
8000ccd4:	fa c8 f9 50 	sub	r8,sp,-1712
8000ccd8:	1a d8       	st.w	--sp,r8
8000ccda:	fa c8 fa b8 	sub	r8,sp,-1352
8000ccde:	0c 9b       	mov	r11,r6
8000cce0:	1a d8       	st.w	--sp,r8
8000cce2:	fa c8 fb b4 	sub	r8,sp,-1100
8000cce6:	04 9a       	mov	r10,r2
8000cce8:	1a d8       	st.w	--sp,r8
8000ccea:	08 9c       	mov	r12,r4
8000ccec:	fa c8 f9 40 	sub	r8,sp,-1728
8000ccf0:	fa c9 ff b4 	sub	r9,sp,-76
8000ccf4:	fe b0 f6 f6 	rcall	8000bae0 <get_arg>
8000ccf8:	2f dd       	sub	sp,-12
8000ccfa:	78 0b       	ld.w	r11,r12[0x0]
8000ccfc:	c2 48       	rjmp	8000cd44 <_vfprintf_r+0xf34>
8000ccfe:	ee ca ff ff 	sub	r10,r7,-1
8000cd02:	10 37       	cp.w	r7,r8
8000cd04:	c0 94       	brge	8000cd16 <_vfprintf_r+0xf06>
8000cd06:	fa c9 f9 44 	sub	r9,sp,-1724
8000cd0a:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000cd0e:	14 97       	mov	r7,r10
8000cd10:	ec fb fd 88 	ld.w	r11,r6[-632]
8000cd14:	c1 88       	rjmp	8000cd44 <_vfprintf_r+0xf34>
8000cd16:	41 09       	lddsp	r9,sp[0x40]
8000cd18:	59 f8       	cp.w	r8,31
8000cd1a:	e0 89 00 11 	brgt	8000cd3c <_vfprintf_r+0xf2c>
8000cd1e:	f2 cb ff fc 	sub	r11,r9,-4
8000cd22:	51 0b       	stdsp	sp[0x40],r11
8000cd24:	fa c6 f9 44 	sub	r6,sp,-1724
8000cd28:	72 0b       	ld.w	r11,r9[0x0]
8000cd2a:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000cd2e:	f3 4b fd 88 	st.w	r9[-632],r11
8000cd32:	2f f8       	sub	r8,-1
8000cd34:	14 97       	mov	r7,r10
8000cd36:	fb 48 06 b4 	st.w	sp[1716],r8
8000cd3a:	c0 58       	rjmp	8000cd44 <_vfprintf_r+0xf34>
8000cd3c:	72 0b       	ld.w	r11,r9[0x0]
8000cd3e:	14 97       	mov	r7,r10
8000cd40:	2f c9       	sub	r9,-4
8000cd42:	51 09       	stdsp	sp[0x40],r9
8000cd44:	50 1b       	stdsp	sp[0x4],r11
8000cd46:	30 0e       	mov	lr,0
8000cd48:	50 0e       	stdsp	sp[0x0],lr
8000cd4a:	1c 98       	mov	r8,lr
8000cd4c:	e0 8f 02 fe 	bral	8000d348 <_vfprintf_r+0x1538>
8000cd50:	50 a7       	stdsp	sp[0x28],r7
8000cd52:	50 80       	stdsp	sp[0x20],r0
8000cd54:	0c 97       	mov	r7,r6
8000cd56:	04 94       	mov	r4,r2
8000cd58:	06 96       	mov	r6,r3
8000cd5a:	02 92       	mov	r2,r1
8000cd5c:	40 93       	lddsp	r3,sp[0x24]
8000cd5e:	40 41       	lddsp	r1,sp[0x10]
8000cd60:	0e 99       	mov	r9,r7
8000cd62:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000cd66:	40 3c       	lddsp	r12,sp[0xc]
8000cd68:	58 0c       	cp.w	r12,0
8000cd6a:	c1 d0       	breq	8000cda4 <_vfprintf_r+0xf94>
8000cd6c:	10 36       	cp.w	r6,r8
8000cd6e:	c0 64       	brge	8000cd7a <_vfprintf_r+0xf6a>
8000cd70:	fa cb f9 44 	sub	r11,sp,-1724
8000cd74:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000cd78:	c1 d8       	rjmp	8000cdb2 <_vfprintf_r+0xfa2>
8000cd7a:	fa c8 f9 50 	sub	r8,sp,-1712
8000cd7e:	1a d8       	st.w	--sp,r8
8000cd80:	fa c8 fa b8 	sub	r8,sp,-1352
8000cd84:	1a d8       	st.w	--sp,r8
8000cd86:	fa c8 fb b4 	sub	r8,sp,-1100
8000cd8a:	1a d8       	st.w	--sp,r8
8000cd8c:	fa c9 ff b4 	sub	r9,sp,-76
8000cd90:	fa c8 f9 40 	sub	r8,sp,-1728
8000cd94:	04 9a       	mov	r10,r2
8000cd96:	0c 9b       	mov	r11,r6
8000cd98:	08 9c       	mov	r12,r4
8000cd9a:	fe b0 f6 a3 	rcall	8000bae0 <get_arg>
8000cd9e:	2f dd       	sub	sp,-12
8000cda0:	78 09       	ld.w	r9,r12[0x0]
8000cda2:	c2 18       	rjmp	8000cde4 <_vfprintf_r+0xfd4>
8000cda4:	2f f7       	sub	r7,-1
8000cda6:	10 39       	cp.w	r9,r8
8000cda8:	c0 84       	brge	8000cdb8 <_vfprintf_r+0xfa8>
8000cdaa:	fa ca f9 44 	sub	r10,sp,-1724
8000cdae:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000cdb2:	ec f9 fd 88 	ld.w	r9,r6[-632]
8000cdb6:	c1 78       	rjmp	8000cde4 <_vfprintf_r+0xfd4>
8000cdb8:	41 09       	lddsp	r9,sp[0x40]
8000cdba:	59 f8       	cp.w	r8,31
8000cdbc:	e0 89 00 10 	brgt	8000cddc <_vfprintf_r+0xfcc>
8000cdc0:	f2 ca ff fc 	sub	r10,r9,-4
8000cdc4:	51 0a       	stdsp	sp[0x40],r10
8000cdc6:	fa c6 f9 44 	sub	r6,sp,-1724
8000cdca:	72 09       	ld.w	r9,r9[0x0]
8000cdcc:	ec 08 00 3a 	add	r10,r6,r8<<0x3
8000cdd0:	f5 49 fd 88 	st.w	r10[-632],r9
8000cdd4:	2f f8       	sub	r8,-1
8000cdd6:	fb 48 06 b4 	st.w	sp[1716],r8
8000cdda:	c0 58       	rjmp	8000cde4 <_vfprintf_r+0xfd4>
8000cddc:	f2 c8 ff fc 	sub	r8,r9,-4
8000cde0:	51 08       	stdsp	sp[0x40],r8
8000cde2:	72 09       	ld.w	r9,r9[0x0]
8000cde4:	33 08       	mov	r8,48
8000cde6:	fb 68 06 b8 	st.b	sp[1720],r8
8000cdea:	37 88       	mov	r8,120
8000cdec:	30 0e       	mov	lr,0
8000cdee:	fb 68 06 b9 	st.b	sp[1721],r8
8000cdf2:	fe cc b5 92 	sub	r12,pc,-19054
8000cdf6:	50 19       	stdsp	sp[0x4],r9
8000cdf8:	a1 b5       	sbr	r5,0x1
8000cdfa:	50 0e       	stdsp	sp[0x0],lr
8000cdfc:	50 dc       	stdsp	sp[0x34],r12
8000cdfe:	30 28       	mov	r8,2
8000ce00:	37 80       	mov	r0,120
8000ce02:	e0 8f 02 a3 	bral	8000d348 <_vfprintf_r+0x1538>
8000ce06:	50 a7       	stdsp	sp[0x28],r7
8000ce08:	50 80       	stdsp	sp[0x20],r0
8000ce0a:	10 90       	mov	r0,r8
8000ce0c:	30 08       	mov	r8,0
8000ce0e:	fb 68 06 bb 	st.b	sp[1723],r8
8000ce12:	0c 97       	mov	r7,r6
8000ce14:	04 94       	mov	r4,r2
8000ce16:	06 96       	mov	r6,r3
8000ce18:	02 92       	mov	r2,r1
8000ce1a:	40 93       	lddsp	r3,sp[0x24]
8000ce1c:	40 41       	lddsp	r1,sp[0x10]
8000ce1e:	0e 99       	mov	r9,r7
8000ce20:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000ce24:	40 3b       	lddsp	r11,sp[0xc]
8000ce26:	58 0b       	cp.w	r11,0
8000ce28:	c1 d0       	breq	8000ce62 <_vfprintf_r+0x1052>
8000ce2a:	10 36       	cp.w	r6,r8
8000ce2c:	c0 64       	brge	8000ce38 <_vfprintf_r+0x1028>
8000ce2e:	fa ca f9 44 	sub	r10,sp,-1724
8000ce32:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000ce36:	c1 d8       	rjmp	8000ce70 <_vfprintf_r+0x1060>
8000ce38:	fa c8 f9 50 	sub	r8,sp,-1712
8000ce3c:	1a d8       	st.w	--sp,r8
8000ce3e:	fa c8 fa b8 	sub	r8,sp,-1352
8000ce42:	1a d8       	st.w	--sp,r8
8000ce44:	fa c8 fb b4 	sub	r8,sp,-1100
8000ce48:	0c 9b       	mov	r11,r6
8000ce4a:	1a d8       	st.w	--sp,r8
8000ce4c:	04 9a       	mov	r10,r2
8000ce4e:	fa c8 f9 40 	sub	r8,sp,-1728
8000ce52:	fa c9 ff b4 	sub	r9,sp,-76
8000ce56:	08 9c       	mov	r12,r4
8000ce58:	fe b0 f6 44 	rcall	8000bae0 <get_arg>
8000ce5c:	2f dd       	sub	sp,-12
8000ce5e:	78 06       	ld.w	r6,r12[0x0]
8000ce60:	c2 08       	rjmp	8000cea0 <_vfprintf_r+0x1090>
8000ce62:	2f f7       	sub	r7,-1
8000ce64:	10 39       	cp.w	r9,r8
8000ce66:	c0 84       	brge	8000ce76 <_vfprintf_r+0x1066>
8000ce68:	fa c9 f9 44 	sub	r9,sp,-1724
8000ce6c:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000ce70:	ec f6 fd 88 	ld.w	r6,r6[-632]
8000ce74:	c1 68       	rjmp	8000cea0 <_vfprintf_r+0x1090>
8000ce76:	41 09       	lddsp	r9,sp[0x40]
8000ce78:	59 f8       	cp.w	r8,31
8000ce7a:	e0 89 00 10 	brgt	8000ce9a <_vfprintf_r+0x108a>
8000ce7e:	f2 ca ff fc 	sub	r10,r9,-4
8000ce82:	51 0a       	stdsp	sp[0x40],r10
8000ce84:	72 06       	ld.w	r6,r9[0x0]
8000ce86:	fa ce f9 44 	sub	lr,sp,-1724
8000ce8a:	fc 08 00 39 	add	r9,lr,r8<<0x3
8000ce8e:	f3 46 fd 88 	st.w	r9[-632],r6
8000ce92:	2f f8       	sub	r8,-1
8000ce94:	fb 48 06 b4 	st.w	sp[1716],r8
8000ce98:	c0 48       	rjmp	8000cea0 <_vfprintf_r+0x1090>
8000ce9a:	72 06       	ld.w	r6,r9[0x0]
8000ce9c:	2f c9       	sub	r9,-4
8000ce9e:	51 09       	stdsp	sp[0x40],r9
8000cea0:	40 2c       	lddsp	r12,sp[0x8]
8000cea2:	58 0c       	cp.w	r12,0
8000cea4:	c1 05       	brlt	8000cec4 <_vfprintf_r+0x10b4>
8000cea6:	18 9a       	mov	r10,r12
8000cea8:	30 0b       	mov	r11,0
8000ceaa:	0c 9c       	mov	r12,r6
8000ceac:	e0 a0 12 38 	rcall	8000f31c <memchr>
8000ceb0:	e0 80 02 df 	breq	8000d46e <_vfprintf_r+0x165e>
8000ceb4:	f8 06 01 02 	sub	r2,r12,r6
8000ceb8:	40 2b       	lddsp	r11,sp[0x8]
8000ceba:	16 32       	cp.w	r2,r11
8000cebc:	e0 89 02 d9 	brgt	8000d46e <_vfprintf_r+0x165e>
8000cec0:	e0 8f 02 d4 	bral	8000d468 <_vfprintf_r+0x1658>
8000cec4:	30 0a       	mov	r10,0
8000cec6:	0c 9c       	mov	r12,r6
8000cec8:	50 2a       	stdsp	sp[0x8],r10
8000ceca:	fe b0 f5 85 	rcall	8000b9d4 <strlen>
8000cece:	18 92       	mov	r2,r12
8000ced0:	e0 8f 02 d2 	bral	8000d474 <_vfprintf_r+0x1664>
8000ced4:	50 a7       	stdsp	sp[0x28],r7
8000ced6:	50 80       	stdsp	sp[0x20],r0
8000ced8:	0c 97       	mov	r7,r6
8000ceda:	04 94       	mov	r4,r2
8000cedc:	06 96       	mov	r6,r3
8000cede:	02 92       	mov	r2,r1
8000cee0:	40 93       	lddsp	r3,sp[0x24]
8000cee2:	10 90       	mov	r0,r8
8000cee4:	40 41       	lddsp	r1,sp[0x10]
8000cee6:	a5 a5       	sbr	r5,0x4
8000cee8:	c0 a8       	rjmp	8000cefc <_vfprintf_r+0x10ec>
8000ceea:	50 a7       	stdsp	sp[0x28],r7
8000ceec:	50 80       	stdsp	sp[0x20],r0
8000ceee:	0c 97       	mov	r7,r6
8000cef0:	04 94       	mov	r4,r2
8000cef2:	06 96       	mov	r6,r3
8000cef4:	02 92       	mov	r2,r1
8000cef6:	40 93       	lddsp	r3,sp[0x24]
8000cef8:	10 90       	mov	r0,r8
8000cefa:	40 41       	lddsp	r1,sp[0x10]
8000cefc:	ed b5 00 05 	bld	r5,0x5
8000cf00:	c5 61       	brne	8000cfac <_vfprintf_r+0x119c>
8000cf02:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000cf06:	40 39       	lddsp	r9,sp[0xc]
8000cf08:	58 09       	cp.w	r9,0
8000cf0a:	c2 10       	breq	8000cf4c <_vfprintf_r+0x113c>
8000cf0c:	10 36       	cp.w	r6,r8
8000cf0e:	c0 74       	brge	8000cf1c <_vfprintf_r+0x110c>
8000cf10:	fa c8 f9 44 	sub	r8,sp,-1724
8000cf14:	f0 06 00 36 	add	r6,r8,r6<<0x3
8000cf18:	c2 38       	rjmp	8000cf5e <_vfprintf_r+0x114e>
8000cf1a:	d7 03       	nop
8000cf1c:	fa c8 f9 50 	sub	r8,sp,-1712
8000cf20:	1a d8       	st.w	--sp,r8
8000cf22:	fa c8 fa b8 	sub	r8,sp,-1352
8000cf26:	1a d8       	st.w	--sp,r8
8000cf28:	fa c8 fb b4 	sub	r8,sp,-1100
8000cf2c:	1a d8       	st.w	--sp,r8
8000cf2e:	fa c8 f9 40 	sub	r8,sp,-1728
8000cf32:	fa c9 ff b4 	sub	r9,sp,-76
8000cf36:	04 9a       	mov	r10,r2
8000cf38:	0c 9b       	mov	r11,r6
8000cf3a:	08 9c       	mov	r12,r4
8000cf3c:	fe b0 f5 d2 	rcall	8000bae0 <get_arg>
8000cf40:	2f dd       	sub	sp,-12
8000cf42:	f8 e8 00 00 	ld.d	r8,r12[0]
8000cf46:	fa e9 00 00 	st.d	sp[0],r8
8000cf4a:	c2 e8       	rjmp	8000cfa6 <_vfprintf_r+0x1196>
8000cf4c:	ee ca ff ff 	sub	r10,r7,-1
8000cf50:	10 37       	cp.w	r7,r8
8000cf52:	c0 b4       	brge	8000cf68 <_vfprintf_r+0x1158>
8000cf54:	fa c8 f9 44 	sub	r8,sp,-1724
8000cf58:	14 97       	mov	r7,r10
8000cf5a:	f0 06 00 36 	add	r6,r8,r6<<0x3
8000cf5e:	ec ea fd 88 	ld.d	r10,r6[-632]
8000cf62:	fa eb 00 00 	st.d	sp[0],r10
8000cf66:	c2 08       	rjmp	8000cfa6 <_vfprintf_r+0x1196>
8000cf68:	41 09       	lddsp	r9,sp[0x40]
8000cf6a:	59 f8       	cp.w	r8,31
8000cf6c:	e0 89 00 16 	brgt	8000cf98 <_vfprintf_r+0x1188>
8000cf70:	f2 e6 00 00 	ld.d	r6,r9[0]
8000cf74:	f2 cb ff f8 	sub	r11,r9,-8
8000cf78:	fa e7 00 00 	st.d	sp[0],r6
8000cf7c:	51 0b       	stdsp	sp[0x40],r11
8000cf7e:	fa c6 f9 44 	sub	r6,sp,-1724
8000cf82:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000cf86:	fa e6 00 00 	ld.d	r6,sp[0]
8000cf8a:	f2 e7 fd 88 	st.d	r9[-632],r6
8000cf8e:	2f f8       	sub	r8,-1
8000cf90:	14 97       	mov	r7,r10
8000cf92:	fb 48 06 b4 	st.w	sp[1716],r8
8000cf96:	c0 88       	rjmp	8000cfa6 <_vfprintf_r+0x1196>
8000cf98:	f2 e6 00 00 	ld.d	r6,r9[0]
8000cf9c:	2f 89       	sub	r9,-8
8000cf9e:	fa e7 00 00 	st.d	sp[0],r6
8000cfa2:	51 09       	stdsp	sp[0x40],r9
8000cfa4:	14 97       	mov	r7,r10
8000cfa6:	30 18       	mov	r8,1
8000cfa8:	e0 8f 01 d0 	bral	8000d348 <_vfprintf_r+0x1538>
8000cfac:	ed b5 00 04 	bld	r5,0x4
8000cfb0:	c1 61       	brne	8000cfdc <_vfprintf_r+0x11cc>
8000cfb2:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000cfb6:	40 3e       	lddsp	lr,sp[0xc]
8000cfb8:	58 0e       	cp.w	lr,0
8000cfba:	c0 80       	breq	8000cfca <_vfprintf_r+0x11ba>
8000cfbc:	10 36       	cp.w	r6,r8
8000cfbe:	c6 74       	brge	8000d08c <_vfprintf_r+0x127c>
8000cfc0:	fa cc f9 44 	sub	r12,sp,-1724
8000cfc4:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000cfc8:	c8 08       	rjmp	8000d0c8 <_vfprintf_r+0x12b8>
8000cfca:	ee ca ff ff 	sub	r10,r7,-1
8000cfce:	10 37       	cp.w	r7,r8
8000cfd0:	c7 f4       	brge	8000d0ce <_vfprintf_r+0x12be>
8000cfd2:	fa cb f9 44 	sub	r11,sp,-1724
8000cfd6:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000cfda:	c7 68       	rjmp	8000d0c6 <_vfprintf_r+0x12b6>
8000cfdc:	ed b5 00 06 	bld	r5,0x6
8000cfe0:	c4 a1       	brne	8000d074 <_vfprintf_r+0x1264>
8000cfe2:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000cfe6:	40 3c       	lddsp	r12,sp[0xc]
8000cfe8:	58 0c       	cp.w	r12,0
8000cfea:	c1 d0       	breq	8000d024 <_vfprintf_r+0x1214>
8000cfec:	10 36       	cp.w	r6,r8
8000cfee:	c0 64       	brge	8000cffa <_vfprintf_r+0x11ea>
8000cff0:	fa cb f9 44 	sub	r11,sp,-1724
8000cff4:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000cff8:	c1 f8       	rjmp	8000d036 <_vfprintf_r+0x1226>
8000cffa:	fa c8 f9 50 	sub	r8,sp,-1712
8000cffe:	1a d8       	st.w	--sp,r8
8000d000:	fa c8 fa b8 	sub	r8,sp,-1352
8000d004:	1a d8       	st.w	--sp,r8
8000d006:	fa c8 fb b4 	sub	r8,sp,-1100
8000d00a:	1a d8       	st.w	--sp,r8
8000d00c:	fa c8 f9 40 	sub	r8,sp,-1728
8000d010:	fa c9 ff b4 	sub	r9,sp,-76
8000d014:	04 9a       	mov	r10,r2
8000d016:	0c 9b       	mov	r11,r6
8000d018:	08 9c       	mov	r12,r4
8000d01a:	fe b0 f5 63 	rcall	8000bae0 <get_arg>
8000d01e:	2f dd       	sub	sp,-12
8000d020:	98 18       	ld.sh	r8,r12[0x2]
8000d022:	c2 68       	rjmp	8000d06e <_vfprintf_r+0x125e>
8000d024:	ee ca ff ff 	sub	r10,r7,-1
8000d028:	10 37       	cp.w	r7,r8
8000d02a:	c0 94       	brge	8000d03c <_vfprintf_r+0x122c>
8000d02c:	fa c9 f9 44 	sub	r9,sp,-1724
8000d030:	14 97       	mov	r7,r10
8000d032:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000d036:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000d03a:	c1 a8       	rjmp	8000d06e <_vfprintf_r+0x125e>
8000d03c:	41 09       	lddsp	r9,sp[0x40]
8000d03e:	59 f8       	cp.w	r8,31
8000d040:	e0 89 00 13 	brgt	8000d066 <_vfprintf_r+0x1256>
8000d044:	f2 cb ff fc 	sub	r11,r9,-4
8000d048:	51 0b       	stdsp	sp[0x40],r11
8000d04a:	72 09       	ld.w	r9,r9[0x0]
8000d04c:	fa c6 f9 44 	sub	r6,sp,-1724
8000d050:	ec 08 00 3b 	add	r11,r6,r8<<0x3
8000d054:	2f f8       	sub	r8,-1
8000d056:	f7 49 fd 88 	st.w	r11[-632],r9
8000d05a:	fb 48 06 b4 	st.w	sp[1716],r8
8000d05e:	14 97       	mov	r7,r10
8000d060:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
8000d064:	c0 58       	rjmp	8000d06e <_vfprintf_r+0x125e>
8000d066:	92 18       	ld.sh	r8,r9[0x2]
8000d068:	14 97       	mov	r7,r10
8000d06a:	2f c9       	sub	r9,-4
8000d06c:	51 09       	stdsp	sp[0x40],r9
8000d06e:	5c 78       	castu.h	r8
8000d070:	50 18       	stdsp	sp[0x4],r8
8000d072:	c4 68       	rjmp	8000d0fe <_vfprintf_r+0x12ee>
8000d074:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000d078:	40 3c       	lddsp	r12,sp[0xc]
8000d07a:	58 0c       	cp.w	r12,0
8000d07c:	c1 d0       	breq	8000d0b6 <_vfprintf_r+0x12a6>
8000d07e:	10 36       	cp.w	r6,r8
8000d080:	c0 64       	brge	8000d08c <_vfprintf_r+0x127c>
8000d082:	fa cb f9 44 	sub	r11,sp,-1724
8000d086:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000d08a:	c1 f8       	rjmp	8000d0c8 <_vfprintf_r+0x12b8>
8000d08c:	fa c8 f9 50 	sub	r8,sp,-1712
8000d090:	1a d8       	st.w	--sp,r8
8000d092:	fa c8 fa b8 	sub	r8,sp,-1352
8000d096:	0c 9b       	mov	r11,r6
8000d098:	1a d8       	st.w	--sp,r8
8000d09a:	fa c8 fb b4 	sub	r8,sp,-1100
8000d09e:	04 9a       	mov	r10,r2
8000d0a0:	1a d8       	st.w	--sp,r8
8000d0a2:	08 9c       	mov	r12,r4
8000d0a4:	fa c8 f9 40 	sub	r8,sp,-1728
8000d0a8:	fa c9 ff b4 	sub	r9,sp,-76
8000d0ac:	fe b0 f5 1a 	rcall	8000bae0 <get_arg>
8000d0b0:	2f dd       	sub	sp,-12
8000d0b2:	78 0b       	ld.w	r11,r12[0x0]
8000d0b4:	c2 48       	rjmp	8000d0fc <_vfprintf_r+0x12ec>
8000d0b6:	ee ca ff ff 	sub	r10,r7,-1
8000d0ba:	10 37       	cp.w	r7,r8
8000d0bc:	c0 94       	brge	8000d0ce <_vfprintf_r+0x12be>
8000d0be:	fa c9 f9 44 	sub	r9,sp,-1724
8000d0c2:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000d0c6:	14 97       	mov	r7,r10
8000d0c8:	ec fb fd 88 	ld.w	r11,r6[-632]
8000d0cc:	c1 88       	rjmp	8000d0fc <_vfprintf_r+0x12ec>
8000d0ce:	41 09       	lddsp	r9,sp[0x40]
8000d0d0:	59 f8       	cp.w	r8,31
8000d0d2:	e0 89 00 11 	brgt	8000d0f4 <_vfprintf_r+0x12e4>
8000d0d6:	f2 cb ff fc 	sub	r11,r9,-4
8000d0da:	51 0b       	stdsp	sp[0x40],r11
8000d0dc:	fa c6 f9 44 	sub	r6,sp,-1724
8000d0e0:	72 0b       	ld.w	r11,r9[0x0]
8000d0e2:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000d0e6:	f3 4b fd 88 	st.w	r9[-632],r11
8000d0ea:	2f f8       	sub	r8,-1
8000d0ec:	14 97       	mov	r7,r10
8000d0ee:	fb 48 06 b4 	st.w	sp[1716],r8
8000d0f2:	c0 58       	rjmp	8000d0fc <_vfprintf_r+0x12ec>
8000d0f4:	72 0b       	ld.w	r11,r9[0x0]
8000d0f6:	14 97       	mov	r7,r10
8000d0f8:	2f c9       	sub	r9,-4
8000d0fa:	51 09       	stdsp	sp[0x40],r9
8000d0fc:	50 1b       	stdsp	sp[0x4],r11
8000d0fe:	30 0e       	mov	lr,0
8000d100:	30 18       	mov	r8,1
8000d102:	50 0e       	stdsp	sp[0x0],lr
8000d104:	c2 29       	rjmp	8000d348 <_vfprintf_r+0x1538>
8000d106:	50 a7       	stdsp	sp[0x28],r7
8000d108:	50 80       	stdsp	sp[0x20],r0
8000d10a:	0c 97       	mov	r7,r6
8000d10c:	04 94       	mov	r4,r2
8000d10e:	06 96       	mov	r6,r3
8000d110:	02 92       	mov	r2,r1
8000d112:	fe cc b8 b2 	sub	r12,pc,-18254
8000d116:	40 93       	lddsp	r3,sp[0x24]
8000d118:	10 90       	mov	r0,r8
8000d11a:	40 41       	lddsp	r1,sp[0x10]
8000d11c:	50 dc       	stdsp	sp[0x34],r12
8000d11e:	ed b5 00 05 	bld	r5,0x5
8000d122:	c5 51       	brne	8000d1cc <_vfprintf_r+0x13bc>
8000d124:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000d128:	40 3b       	lddsp	r11,sp[0xc]
8000d12a:	58 0b       	cp.w	r11,0
8000d12c:	c2 20       	breq	8000d170 <_vfprintf_r+0x1360>
8000d12e:	10 36       	cp.w	r6,r8
8000d130:	c0 a4       	brge	8000d144 <_vfprintf_r+0x1334>
8000d132:	fa ca f9 44 	sub	r10,sp,-1724
8000d136:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000d13a:	ec e8 fd 88 	ld.d	r8,r6[-632]
8000d13e:	fa e9 00 00 	st.d	sp[0],r8
8000d142:	cf 28       	rjmp	8000d326 <_vfprintf_r+0x1516>
8000d144:	fa c8 f9 50 	sub	r8,sp,-1712
8000d148:	1a d8       	st.w	--sp,r8
8000d14a:	fa c8 fa b8 	sub	r8,sp,-1352
8000d14e:	04 9a       	mov	r10,r2
8000d150:	1a d8       	st.w	--sp,r8
8000d152:	0c 9b       	mov	r11,r6
8000d154:	fa c8 fb b4 	sub	r8,sp,-1100
8000d158:	08 9c       	mov	r12,r4
8000d15a:	1a d8       	st.w	--sp,r8
8000d15c:	fa c8 f9 40 	sub	r8,sp,-1728
8000d160:	fa c9 ff b4 	sub	r9,sp,-76
8000d164:	fe b0 f4 be 	rcall	8000bae0 <get_arg>
8000d168:	2f dd       	sub	sp,-12
8000d16a:	f8 ea 00 00 	ld.d	r10,r12[0]
8000d16e:	c0 c8       	rjmp	8000d186 <_vfprintf_r+0x1376>
8000d170:	ee ca ff ff 	sub	r10,r7,-1
8000d174:	10 37       	cp.w	r7,r8
8000d176:	c0 b4       	brge	8000d18c <_vfprintf_r+0x137c>
8000d178:	fa c9 f9 44 	sub	r9,sp,-1724
8000d17c:	14 97       	mov	r7,r10
8000d17e:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000d182:	ec ea fd 88 	ld.d	r10,r6[-632]
8000d186:	fa eb 00 00 	st.d	sp[0],r10
8000d18a:	cc e8       	rjmp	8000d326 <_vfprintf_r+0x1516>
8000d18c:	41 09       	lddsp	r9,sp[0x40]
8000d18e:	59 f8       	cp.w	r8,31
8000d190:	e0 89 00 16 	brgt	8000d1bc <_vfprintf_r+0x13ac>
8000d194:	f2 e6 00 00 	ld.d	r6,r9[0]
8000d198:	f2 cb ff f8 	sub	r11,r9,-8
8000d19c:	fa e7 00 00 	st.d	sp[0],r6
8000d1a0:	51 0b       	stdsp	sp[0x40],r11
8000d1a2:	fa c6 f9 44 	sub	r6,sp,-1724
8000d1a6:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000d1aa:	fa e6 00 00 	ld.d	r6,sp[0]
8000d1ae:	f2 e7 fd 88 	st.d	r9[-632],r6
8000d1b2:	2f f8       	sub	r8,-1
8000d1b4:	14 97       	mov	r7,r10
8000d1b6:	fb 48 06 b4 	st.w	sp[1716],r8
8000d1ba:	cb 68       	rjmp	8000d326 <_vfprintf_r+0x1516>
8000d1bc:	f2 e6 00 00 	ld.d	r6,r9[0]
8000d1c0:	2f 89       	sub	r9,-8
8000d1c2:	fa e7 00 00 	st.d	sp[0],r6
8000d1c6:	51 09       	stdsp	sp[0x40],r9
8000d1c8:	14 97       	mov	r7,r10
8000d1ca:	ca e8       	rjmp	8000d326 <_vfprintf_r+0x1516>
8000d1cc:	ed b5 00 04 	bld	r5,0x4
8000d1d0:	c1 71       	brne	8000d1fe <_vfprintf_r+0x13ee>
8000d1d2:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000d1d6:	40 3e       	lddsp	lr,sp[0xc]
8000d1d8:	58 0e       	cp.w	lr,0
8000d1da:	c0 80       	breq	8000d1ea <_vfprintf_r+0x13da>
8000d1dc:	10 36       	cp.w	r6,r8
8000d1de:	c6 94       	brge	8000d2b0 <_vfprintf_r+0x14a0>
8000d1e0:	fa cc f9 44 	sub	r12,sp,-1724
8000d1e4:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000d1e8:	c8 28       	rjmp	8000d2ec <_vfprintf_r+0x14dc>
8000d1ea:	ee ca ff ff 	sub	r10,r7,-1
8000d1ee:	10 37       	cp.w	r7,r8
8000d1f0:	e0 84 00 81 	brge	8000d2f2 <_vfprintf_r+0x14e2>
8000d1f4:	fa cb f9 44 	sub	r11,sp,-1724
8000d1f8:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000d1fc:	c7 78       	rjmp	8000d2ea <_vfprintf_r+0x14da>
8000d1fe:	ed b5 00 06 	bld	r5,0x6
8000d202:	c4 b1       	brne	8000d298 <_vfprintf_r+0x1488>
8000d204:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000d208:	40 3c       	lddsp	r12,sp[0xc]
8000d20a:	58 0c       	cp.w	r12,0
8000d20c:	c1 d0       	breq	8000d246 <_vfprintf_r+0x1436>
8000d20e:	10 36       	cp.w	r6,r8
8000d210:	c0 64       	brge	8000d21c <_vfprintf_r+0x140c>
8000d212:	fa cb f9 44 	sub	r11,sp,-1724
8000d216:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000d21a:	c1 f8       	rjmp	8000d258 <_vfprintf_r+0x1448>
8000d21c:	fa c8 f9 50 	sub	r8,sp,-1712
8000d220:	1a d8       	st.w	--sp,r8
8000d222:	fa c8 fa b8 	sub	r8,sp,-1352
8000d226:	1a d8       	st.w	--sp,r8
8000d228:	fa c8 fb b4 	sub	r8,sp,-1100
8000d22c:	1a d8       	st.w	--sp,r8
8000d22e:	fa c8 f9 40 	sub	r8,sp,-1728
8000d232:	fa c9 ff b4 	sub	r9,sp,-76
8000d236:	04 9a       	mov	r10,r2
8000d238:	0c 9b       	mov	r11,r6
8000d23a:	08 9c       	mov	r12,r4
8000d23c:	fe b0 f4 52 	rcall	8000bae0 <get_arg>
8000d240:	2f dd       	sub	sp,-12
8000d242:	98 18       	ld.sh	r8,r12[0x2]
8000d244:	c2 78       	rjmp	8000d292 <_vfprintf_r+0x1482>
8000d246:	ee ca ff ff 	sub	r10,r7,-1
8000d24a:	10 37       	cp.w	r7,r8
8000d24c:	c0 a4       	brge	8000d260 <_vfprintf_r+0x1450>
8000d24e:	fa c9 f9 44 	sub	r9,sp,-1724
8000d252:	14 97       	mov	r7,r10
8000d254:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000d258:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000d25c:	c1 b8       	rjmp	8000d292 <_vfprintf_r+0x1482>
8000d25e:	d7 03       	nop
8000d260:	41 09       	lddsp	r9,sp[0x40]
8000d262:	59 f8       	cp.w	r8,31
8000d264:	e0 89 00 13 	brgt	8000d28a <_vfprintf_r+0x147a>
8000d268:	f2 cb ff fc 	sub	r11,r9,-4
8000d26c:	51 0b       	stdsp	sp[0x40],r11
8000d26e:	72 09       	ld.w	r9,r9[0x0]
8000d270:	fa c6 f9 44 	sub	r6,sp,-1724
8000d274:	ec 08 00 3b 	add	r11,r6,r8<<0x3
8000d278:	2f f8       	sub	r8,-1
8000d27a:	f7 49 fd 88 	st.w	r11[-632],r9
8000d27e:	fb 48 06 b4 	st.w	sp[1716],r8
8000d282:	14 97       	mov	r7,r10
8000d284:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
8000d288:	c0 58       	rjmp	8000d292 <_vfprintf_r+0x1482>
8000d28a:	92 18       	ld.sh	r8,r9[0x2]
8000d28c:	14 97       	mov	r7,r10
8000d28e:	2f c9       	sub	r9,-4
8000d290:	51 09       	stdsp	sp[0x40],r9
8000d292:	5c 78       	castu.h	r8
8000d294:	50 18       	stdsp	sp[0x4],r8
8000d296:	c4 68       	rjmp	8000d322 <_vfprintf_r+0x1512>
8000d298:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000d29c:	40 3c       	lddsp	r12,sp[0xc]
8000d29e:	58 0c       	cp.w	r12,0
8000d2a0:	c1 d0       	breq	8000d2da <_vfprintf_r+0x14ca>
8000d2a2:	10 36       	cp.w	r6,r8
8000d2a4:	c0 64       	brge	8000d2b0 <_vfprintf_r+0x14a0>
8000d2a6:	fa cb f9 44 	sub	r11,sp,-1724
8000d2aa:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000d2ae:	c1 f8       	rjmp	8000d2ec <_vfprintf_r+0x14dc>
8000d2b0:	fa c8 f9 50 	sub	r8,sp,-1712
8000d2b4:	1a d8       	st.w	--sp,r8
8000d2b6:	fa c8 fa b8 	sub	r8,sp,-1352
8000d2ba:	0c 9b       	mov	r11,r6
8000d2bc:	1a d8       	st.w	--sp,r8
8000d2be:	fa c8 fb b4 	sub	r8,sp,-1100
8000d2c2:	04 9a       	mov	r10,r2
8000d2c4:	1a d8       	st.w	--sp,r8
8000d2c6:	08 9c       	mov	r12,r4
8000d2c8:	fa c8 f9 40 	sub	r8,sp,-1728
8000d2cc:	fa c9 ff b4 	sub	r9,sp,-76
8000d2d0:	fe b0 f4 08 	rcall	8000bae0 <get_arg>
8000d2d4:	2f dd       	sub	sp,-12
8000d2d6:	78 0b       	ld.w	r11,r12[0x0]
8000d2d8:	c2 48       	rjmp	8000d320 <_vfprintf_r+0x1510>
8000d2da:	ee ca ff ff 	sub	r10,r7,-1
8000d2de:	10 37       	cp.w	r7,r8
8000d2e0:	c0 94       	brge	8000d2f2 <_vfprintf_r+0x14e2>
8000d2e2:	fa c9 f9 44 	sub	r9,sp,-1724
8000d2e6:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000d2ea:	14 97       	mov	r7,r10
8000d2ec:	ec fb fd 88 	ld.w	r11,r6[-632]
8000d2f0:	c1 88       	rjmp	8000d320 <_vfprintf_r+0x1510>
8000d2f2:	41 09       	lddsp	r9,sp[0x40]
8000d2f4:	59 f8       	cp.w	r8,31
8000d2f6:	e0 89 00 11 	brgt	8000d318 <_vfprintf_r+0x1508>
8000d2fa:	f2 cb ff fc 	sub	r11,r9,-4
8000d2fe:	51 0b       	stdsp	sp[0x40],r11
8000d300:	fa c6 f9 44 	sub	r6,sp,-1724
8000d304:	72 0b       	ld.w	r11,r9[0x0]
8000d306:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000d30a:	f3 4b fd 88 	st.w	r9[-632],r11
8000d30e:	2f f8       	sub	r8,-1
8000d310:	14 97       	mov	r7,r10
8000d312:	fb 48 06 b4 	st.w	sp[1716],r8
8000d316:	c0 58       	rjmp	8000d320 <_vfprintf_r+0x1510>
8000d318:	72 0b       	ld.w	r11,r9[0x0]
8000d31a:	14 97       	mov	r7,r10
8000d31c:	2f c9       	sub	r9,-4
8000d31e:	51 09       	stdsp	sp[0x40],r9
8000d320:	50 1b       	stdsp	sp[0x4],r11
8000d322:	30 0e       	mov	lr,0
8000d324:	50 0e       	stdsp	sp[0x0],lr
8000d326:	40 08       	lddsp	r8,sp[0x0]
8000d328:	40 1c       	lddsp	r12,sp[0x4]
8000d32a:	18 48       	or	r8,r12
8000d32c:	5f 19       	srne	r9
8000d32e:	0a 98       	mov	r8,r5
8000d330:	eb e9 00 09 	and	r9,r5,r9
8000d334:	a1 b8       	sbr	r8,0x1
8000d336:	58 09       	cp.w	r9,0
8000d338:	c0 70       	breq	8000d346 <_vfprintf_r+0x1536>
8000d33a:	10 95       	mov	r5,r8
8000d33c:	fb 60 06 b9 	st.b	sp[1721],r0
8000d340:	33 08       	mov	r8,48
8000d342:	fb 68 06 b8 	st.b	sp[1720],r8
8000d346:	30 28       	mov	r8,2
8000d348:	30 09       	mov	r9,0
8000d34a:	fb 69 06 bb 	st.b	sp[1723],r9
8000d34e:	0a 99       	mov	r9,r5
8000d350:	a7 d9       	cbr	r9,0x7
8000d352:	40 2b       	lddsp	r11,sp[0x8]
8000d354:	40 16       	lddsp	r6,sp[0x4]
8000d356:	58 0b       	cp.w	r11,0
8000d358:	5f 1a       	srne	r10
8000d35a:	f2 05 17 40 	movge	r5,r9
8000d35e:	fa c2 f9 78 	sub	r2,sp,-1672
8000d362:	40 09       	lddsp	r9,sp[0x0]
8000d364:	0c 49       	or	r9,r6
8000d366:	5f 19       	srne	r9
8000d368:	f5 e9 10 09 	or	r9,r10,r9
8000d36c:	c5 c0       	breq	8000d424 <_vfprintf_r+0x1614>
8000d36e:	30 19       	mov	r9,1
8000d370:	f2 08 18 00 	cp.b	r8,r9
8000d374:	c0 60       	breq	8000d380 <_vfprintf_r+0x1570>
8000d376:	30 29       	mov	r9,2
8000d378:	f2 08 18 00 	cp.b	r8,r9
8000d37c:	c0 41       	brne	8000d384 <_vfprintf_r+0x1574>
8000d37e:	c3 c8       	rjmp	8000d3f6 <_vfprintf_r+0x15e6>
8000d380:	04 96       	mov	r6,r2
8000d382:	c3 08       	rjmp	8000d3e2 <_vfprintf_r+0x15d2>
8000d384:	04 96       	mov	r6,r2
8000d386:	fa e8 00 00 	ld.d	r8,sp[0]
8000d38a:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
8000d38e:	2d 0a       	sub	r10,-48
8000d390:	0c fa       	st.b	--r6,r10
8000d392:	f0 0b 16 03 	lsr	r11,r8,0x3
8000d396:	f2 0c 16 03 	lsr	r12,r9,0x3
8000d39a:	f7 e9 11 db 	or	r11,r11,r9<<0x1d
8000d39e:	18 99       	mov	r9,r12
8000d3a0:	16 98       	mov	r8,r11
8000d3a2:	58 08       	cp.w	r8,0
8000d3a4:	5c 29       	cpc	r9
8000d3a6:	cf 21       	brne	8000d38a <_vfprintf_r+0x157a>
8000d3a8:	fa e9 00 00 	st.d	sp[0],r8
8000d3ac:	ed b5 00 00 	bld	r5,0x0
8000d3b0:	c4 51       	brne	8000d43a <_vfprintf_r+0x162a>
8000d3b2:	33 09       	mov	r9,48
8000d3b4:	f2 0a 18 00 	cp.b	r10,r9
8000d3b8:	c4 10       	breq	8000d43a <_vfprintf_r+0x162a>
8000d3ba:	0c f9       	st.b	--r6,r9
8000d3bc:	c3 f8       	rjmp	8000d43a <_vfprintf_r+0x162a>
8000d3be:	fa ea 00 00 	ld.d	r10,sp[0]
8000d3c2:	30 a8       	mov	r8,10
8000d3c4:	30 09       	mov	r9,0
8000d3c6:	e0 a0 1a 0d 	rcall	800107e0 <__avr32_umod64>
8000d3ca:	30 a8       	mov	r8,10
8000d3cc:	2d 0a       	sub	r10,-48
8000d3ce:	30 09       	mov	r9,0
8000d3d0:	ac 8a       	st.b	r6[0x0],r10
8000d3d2:	fa ea 00 00 	ld.d	r10,sp[0]
8000d3d6:	e0 a0 18 d3 	rcall	8001057c <__avr32_udiv64>
8000d3da:	16 99       	mov	r9,r11
8000d3dc:	14 98       	mov	r8,r10
8000d3de:	fa e9 00 00 	st.d	sp[0],r8
8000d3e2:	20 16       	sub	r6,1
8000d3e4:	fa ea 00 00 	ld.d	r10,sp[0]
8000d3e8:	58 9a       	cp.w	r10,9
8000d3ea:	5c 2b       	cpc	r11
8000d3ec:	fe 9b ff e9 	brhi	8000d3be <_vfprintf_r+0x15ae>
8000d3f0:	1b f8       	ld.ub	r8,sp[0x7]
8000d3f2:	2d 08       	sub	r8,-48
8000d3f4:	c2 08       	rjmp	8000d434 <_vfprintf_r+0x1624>
8000d3f6:	04 96       	mov	r6,r2
8000d3f8:	fa e8 00 00 	ld.d	r8,sp[0]
8000d3fc:	f5 d8 c0 04 	bfextu	r10,r8,0x0,0x4
8000d400:	40 de       	lddsp	lr,sp[0x34]
8000d402:	fc 0a 07 0a 	ld.ub	r10,lr[r10]
8000d406:	0c fa       	st.b	--r6,r10
8000d408:	f2 0b 16 04 	lsr	r11,r9,0x4
8000d40c:	f0 0a 16 04 	lsr	r10,r8,0x4
8000d410:	f5 e9 11 ca 	or	r10,r10,r9<<0x1c
8000d414:	16 99       	mov	r9,r11
8000d416:	14 98       	mov	r8,r10
8000d418:	58 08       	cp.w	r8,0
8000d41a:	5c 29       	cpc	r9
8000d41c:	cf 01       	brne	8000d3fc <_vfprintf_r+0x15ec>
8000d41e:	fa e9 00 00 	st.d	sp[0],r8
8000d422:	c0 c8       	rjmp	8000d43a <_vfprintf_r+0x162a>
8000d424:	58 08       	cp.w	r8,0
8000d426:	c0 91       	brne	8000d438 <_vfprintf_r+0x1628>
8000d428:	ed b5 00 00 	bld	r5,0x0
8000d42c:	c0 61       	brne	8000d438 <_vfprintf_r+0x1628>
8000d42e:	fa c6 f9 79 	sub	r6,sp,-1671
8000d432:	33 08       	mov	r8,48
8000d434:	ac 88       	st.b	r6[0x0],r8
8000d436:	c0 28       	rjmp	8000d43a <_vfprintf_r+0x162a>
8000d438:	04 96       	mov	r6,r2
8000d43a:	0c 12       	sub	r2,r6
8000d43c:	c1 c8       	rjmp	8000d474 <_vfprintf_r+0x1664>
8000d43e:	50 a7       	stdsp	sp[0x28],r7
8000d440:	50 80       	stdsp	sp[0x20],r0
8000d442:	40 93       	lddsp	r3,sp[0x24]
8000d444:	0c 97       	mov	r7,r6
8000d446:	10 90       	mov	r0,r8
8000d448:	04 94       	mov	r4,r2
8000d44a:	40 41       	lddsp	r1,sp[0x10]
8000d44c:	58 08       	cp.w	r8,0
8000d44e:	e0 80 04 4f 	breq	8000dcec <_vfprintf_r+0x1edc>
8000d452:	fb 68 06 60 	st.b	sp[1632],r8
8000d456:	30 0c       	mov	r12,0
8000d458:	30 08       	mov	r8,0
8000d45a:	30 12       	mov	r2,1
8000d45c:	fb 68 06 bb 	st.b	sp[1723],r8
8000d460:	50 2c       	stdsp	sp[0x8],r12
8000d462:	fa c6 f9 a0 	sub	r6,sp,-1632
8000d466:	c0 78       	rjmp	8000d474 <_vfprintf_r+0x1664>
8000d468:	30 0b       	mov	r11,0
8000d46a:	50 2b       	stdsp	sp[0x8],r11
8000d46c:	c0 48       	rjmp	8000d474 <_vfprintf_r+0x1664>
8000d46e:	40 22       	lddsp	r2,sp[0x8]
8000d470:	30 0a       	mov	r10,0
8000d472:	50 2a       	stdsp	sp[0x8],r10
8000d474:	40 29       	lddsp	r9,sp[0x8]
8000d476:	e4 09 0c 49 	max	r9,r2,r9
8000d47a:	fb 38 06 bb 	ld.ub	r8,sp[1723]
8000d47e:	50 39       	stdsp	sp[0xc],r9
8000d480:	0a 9e       	mov	lr,r5
8000d482:	30 09       	mov	r9,0
8000d484:	e2 1e 00 02 	andl	lr,0x2,COH
8000d488:	f2 08 18 00 	cp.b	r8,r9
8000d48c:	fb f8 10 03 	ld.wne	r8,sp[0xc]
8000d490:	f7 b8 01 ff 	subne	r8,-1
8000d494:	fb f8 1a 03 	st.wne	sp[0xc],r8
8000d498:	0a 9b       	mov	r11,r5
8000d49a:	58 0e       	cp.w	lr,0
8000d49c:	fb fc 10 03 	ld.wne	r12,sp[0xc]
8000d4a0:	f7 bc 01 fe 	subne	r12,-2
8000d4a4:	fb fc 1a 03 	st.wne	sp[0xc],r12
8000d4a8:	e2 1b 00 84 	andl	r11,0x84,COH
8000d4ac:	50 fe       	stdsp	sp[0x3c],lr
8000d4ae:	50 9b       	stdsp	sp[0x24],r11
8000d4b0:	c4 71       	brne	8000d53e <_vfprintf_r+0x172e>
8000d4b2:	40 8a       	lddsp	r10,sp[0x20]
8000d4b4:	40 39       	lddsp	r9,sp[0xc]
8000d4b6:	12 1a       	sub	r10,r9
8000d4b8:	50 4a       	stdsp	sp[0x10],r10
8000d4ba:	58 0a       	cp.w	r10,0
8000d4bc:	e0 89 00 20 	brgt	8000d4fc <_vfprintf_r+0x16ec>
8000d4c0:	c3 f8       	rjmp	8000d53e <_vfprintf_r+0x172e>
8000d4c2:	2f 09       	sub	r9,-16
8000d4c4:	2f f8       	sub	r8,-1
8000d4c6:	fe ce bc 4e 	sub	lr,pc,-17330
8000d4ca:	31 0c       	mov	r12,16
8000d4cc:	fb 49 06 90 	st.w	sp[1680],r9
8000d4d0:	87 0e       	st.w	r3[0x0],lr
8000d4d2:	87 1c       	st.w	r3[0x4],r12
8000d4d4:	fb 48 06 8c 	st.w	sp[1676],r8
8000d4d8:	58 78       	cp.w	r8,7
8000d4da:	e0 89 00 04 	brgt	8000d4e2 <_vfprintf_r+0x16d2>
8000d4de:	2f 83       	sub	r3,-8
8000d4e0:	c0 b8       	rjmp	8000d4f6 <_vfprintf_r+0x16e6>
8000d4e2:	fa ca f9 78 	sub	r10,sp,-1672
8000d4e6:	02 9b       	mov	r11,r1
8000d4e8:	08 9c       	mov	r12,r4
8000d4ea:	fe b0 f4 85 	rcall	8000bdf4 <__sprint_r>
8000d4ee:	e0 81 04 10 	brne	8000dd0e <_vfprintf_r+0x1efe>
8000d4f2:	fa c3 f9 e0 	sub	r3,sp,-1568
8000d4f6:	40 4b       	lddsp	r11,sp[0x10]
8000d4f8:	21 0b       	sub	r11,16
8000d4fa:	50 4b       	stdsp	sp[0x10],r11
8000d4fc:	fa f9 06 90 	ld.w	r9,sp[1680]
8000d500:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000d504:	fe ca bc 8c 	sub	r10,pc,-17268
8000d508:	40 4e       	lddsp	lr,sp[0x10]
8000d50a:	59 0e       	cp.w	lr,16
8000d50c:	fe 99 ff db 	brgt	8000d4c2 <_vfprintf_r+0x16b2>
8000d510:	1c 09       	add	r9,lr
8000d512:	2f f8       	sub	r8,-1
8000d514:	87 0a       	st.w	r3[0x0],r10
8000d516:	fb 49 06 90 	st.w	sp[1680],r9
8000d51a:	87 1e       	st.w	r3[0x4],lr
8000d51c:	fb 48 06 8c 	st.w	sp[1676],r8
8000d520:	58 78       	cp.w	r8,7
8000d522:	e0 89 00 04 	brgt	8000d52a <_vfprintf_r+0x171a>
8000d526:	2f 83       	sub	r3,-8
8000d528:	c0 b8       	rjmp	8000d53e <_vfprintf_r+0x172e>
8000d52a:	fa ca f9 78 	sub	r10,sp,-1672
8000d52e:	02 9b       	mov	r11,r1
8000d530:	08 9c       	mov	r12,r4
8000d532:	fe b0 f4 61 	rcall	8000bdf4 <__sprint_r>
8000d536:	e0 81 03 ec 	brne	8000dd0e <_vfprintf_r+0x1efe>
8000d53a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000d53e:	30 09       	mov	r9,0
8000d540:	fb 38 06 bb 	ld.ub	r8,sp[1723]
8000d544:	f2 08 18 00 	cp.b	r8,r9
8000d548:	c1 f0       	breq	8000d586 <_vfprintf_r+0x1776>
8000d54a:	fa f8 06 90 	ld.w	r8,sp[1680]
8000d54e:	fa c9 f9 45 	sub	r9,sp,-1723
8000d552:	2f f8       	sub	r8,-1
8000d554:	87 09       	st.w	r3[0x0],r9
8000d556:	fb 48 06 90 	st.w	sp[1680],r8
8000d55a:	30 19       	mov	r9,1
8000d55c:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000d560:	87 19       	st.w	r3[0x4],r9
8000d562:	2f f8       	sub	r8,-1
8000d564:	fb 48 06 8c 	st.w	sp[1676],r8
8000d568:	58 78       	cp.w	r8,7
8000d56a:	e0 89 00 04 	brgt	8000d572 <_vfprintf_r+0x1762>
8000d56e:	2f 83       	sub	r3,-8
8000d570:	c0 b8       	rjmp	8000d586 <_vfprintf_r+0x1776>
8000d572:	fa ca f9 78 	sub	r10,sp,-1672
8000d576:	02 9b       	mov	r11,r1
8000d578:	08 9c       	mov	r12,r4
8000d57a:	fe b0 f4 3d 	rcall	8000bdf4 <__sprint_r>
8000d57e:	e0 81 03 c8 	brne	8000dd0e <_vfprintf_r+0x1efe>
8000d582:	fa c3 f9 e0 	sub	r3,sp,-1568
8000d586:	40 fc       	lddsp	r12,sp[0x3c]
8000d588:	58 0c       	cp.w	r12,0
8000d58a:	c1 f0       	breq	8000d5c8 <_vfprintf_r+0x17b8>
8000d58c:	fa f8 06 90 	ld.w	r8,sp[1680]
8000d590:	fa c9 f9 48 	sub	r9,sp,-1720
8000d594:	2f e8       	sub	r8,-2
8000d596:	87 09       	st.w	r3[0x0],r9
8000d598:	fb 48 06 90 	st.w	sp[1680],r8
8000d59c:	30 29       	mov	r9,2
8000d59e:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000d5a2:	87 19       	st.w	r3[0x4],r9
8000d5a4:	2f f8       	sub	r8,-1
8000d5a6:	fb 48 06 8c 	st.w	sp[1676],r8
8000d5aa:	58 78       	cp.w	r8,7
8000d5ac:	e0 89 00 04 	brgt	8000d5b4 <_vfprintf_r+0x17a4>
8000d5b0:	2f 83       	sub	r3,-8
8000d5b2:	c0 b8       	rjmp	8000d5c8 <_vfprintf_r+0x17b8>
8000d5b4:	fa ca f9 78 	sub	r10,sp,-1672
8000d5b8:	02 9b       	mov	r11,r1
8000d5ba:	08 9c       	mov	r12,r4
8000d5bc:	fe b0 f4 1c 	rcall	8000bdf4 <__sprint_r>
8000d5c0:	e0 81 03 a7 	brne	8000dd0e <_vfprintf_r+0x1efe>
8000d5c4:	fa c3 f9 e0 	sub	r3,sp,-1568
8000d5c8:	40 9b       	lddsp	r11,sp[0x24]
8000d5ca:	e0 4b 00 80 	cp.w	r11,128
8000d5ce:	c4 71       	brne	8000d65c <_vfprintf_r+0x184c>
8000d5d0:	40 8a       	lddsp	r10,sp[0x20]
8000d5d2:	40 39       	lddsp	r9,sp[0xc]
8000d5d4:	12 1a       	sub	r10,r9
8000d5d6:	50 4a       	stdsp	sp[0x10],r10
8000d5d8:	58 0a       	cp.w	r10,0
8000d5da:	e0 89 00 20 	brgt	8000d61a <_vfprintf_r+0x180a>
8000d5de:	c3 f8       	rjmp	8000d65c <_vfprintf_r+0x184c>
8000d5e0:	2f 09       	sub	r9,-16
8000d5e2:	2f f8       	sub	r8,-1
8000d5e4:	fe ce bd 5c 	sub	lr,pc,-17060
8000d5e8:	31 0c       	mov	r12,16
8000d5ea:	fb 49 06 90 	st.w	sp[1680],r9
8000d5ee:	87 0e       	st.w	r3[0x0],lr
8000d5f0:	87 1c       	st.w	r3[0x4],r12
8000d5f2:	fb 48 06 8c 	st.w	sp[1676],r8
8000d5f6:	58 78       	cp.w	r8,7
8000d5f8:	e0 89 00 04 	brgt	8000d600 <_vfprintf_r+0x17f0>
8000d5fc:	2f 83       	sub	r3,-8
8000d5fe:	c0 b8       	rjmp	8000d614 <_vfprintf_r+0x1804>
8000d600:	fa ca f9 78 	sub	r10,sp,-1672
8000d604:	02 9b       	mov	r11,r1
8000d606:	08 9c       	mov	r12,r4
8000d608:	fe b0 f3 f6 	rcall	8000bdf4 <__sprint_r>
8000d60c:	e0 81 03 81 	brne	8000dd0e <_vfprintf_r+0x1efe>
8000d610:	fa c3 f9 e0 	sub	r3,sp,-1568
8000d614:	40 4b       	lddsp	r11,sp[0x10]
8000d616:	21 0b       	sub	r11,16
8000d618:	50 4b       	stdsp	sp[0x10],r11
8000d61a:	fa f9 06 90 	ld.w	r9,sp[1680]
8000d61e:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000d622:	fe ca bd 9a 	sub	r10,pc,-16998
8000d626:	40 4e       	lddsp	lr,sp[0x10]
8000d628:	59 0e       	cp.w	lr,16
8000d62a:	fe 99 ff db 	brgt	8000d5e0 <_vfprintf_r+0x17d0>
8000d62e:	1c 09       	add	r9,lr
8000d630:	2f f8       	sub	r8,-1
8000d632:	87 0a       	st.w	r3[0x0],r10
8000d634:	fb 49 06 90 	st.w	sp[1680],r9
8000d638:	87 1e       	st.w	r3[0x4],lr
8000d63a:	fb 48 06 8c 	st.w	sp[1676],r8
8000d63e:	58 78       	cp.w	r8,7
8000d640:	e0 89 00 04 	brgt	8000d648 <_vfprintf_r+0x1838>
8000d644:	2f 83       	sub	r3,-8
8000d646:	c0 b8       	rjmp	8000d65c <_vfprintf_r+0x184c>
8000d648:	fa ca f9 78 	sub	r10,sp,-1672
8000d64c:	02 9b       	mov	r11,r1
8000d64e:	08 9c       	mov	r12,r4
8000d650:	fe b0 f3 d2 	rcall	8000bdf4 <__sprint_r>
8000d654:	e0 81 03 5d 	brne	8000dd0e <_vfprintf_r+0x1efe>
8000d658:	fa c3 f9 e0 	sub	r3,sp,-1568
8000d65c:	40 2c       	lddsp	r12,sp[0x8]
8000d65e:	04 1c       	sub	r12,r2
8000d660:	50 2c       	stdsp	sp[0x8],r12
8000d662:	58 0c       	cp.w	r12,0
8000d664:	e0 89 00 20 	brgt	8000d6a4 <_vfprintf_r+0x1894>
8000d668:	c3 f8       	rjmp	8000d6e6 <_vfprintf_r+0x18d6>
8000d66a:	2f 09       	sub	r9,-16
8000d66c:	2f f8       	sub	r8,-1
8000d66e:	fe cb bd e6 	sub	r11,pc,-16922
8000d672:	31 0a       	mov	r10,16
8000d674:	fb 49 06 90 	st.w	sp[1680],r9
8000d678:	87 0b       	st.w	r3[0x0],r11
8000d67a:	87 1a       	st.w	r3[0x4],r10
8000d67c:	fb 48 06 8c 	st.w	sp[1676],r8
8000d680:	58 78       	cp.w	r8,7
8000d682:	e0 89 00 04 	brgt	8000d68a <_vfprintf_r+0x187a>
8000d686:	2f 83       	sub	r3,-8
8000d688:	c0 b8       	rjmp	8000d69e <_vfprintf_r+0x188e>
8000d68a:	fa ca f9 78 	sub	r10,sp,-1672
8000d68e:	02 9b       	mov	r11,r1
8000d690:	08 9c       	mov	r12,r4
8000d692:	fe b0 f3 b1 	rcall	8000bdf4 <__sprint_r>
8000d696:	e0 81 03 3c 	brne	8000dd0e <_vfprintf_r+0x1efe>
8000d69a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000d69e:	40 29       	lddsp	r9,sp[0x8]
8000d6a0:	21 09       	sub	r9,16
8000d6a2:	50 29       	stdsp	sp[0x8],r9
8000d6a4:	fa f9 06 90 	ld.w	r9,sp[1680]
8000d6a8:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000d6ac:	fe ca be 24 	sub	r10,pc,-16860
8000d6b0:	40 2e       	lddsp	lr,sp[0x8]
8000d6b2:	59 0e       	cp.w	lr,16
8000d6b4:	fe 99 ff db 	brgt	8000d66a <_vfprintf_r+0x185a>
8000d6b8:	1c 09       	add	r9,lr
8000d6ba:	2f f8       	sub	r8,-1
8000d6bc:	87 0a       	st.w	r3[0x0],r10
8000d6be:	fb 49 06 90 	st.w	sp[1680],r9
8000d6c2:	87 1e       	st.w	r3[0x4],lr
8000d6c4:	fb 48 06 8c 	st.w	sp[1676],r8
8000d6c8:	58 78       	cp.w	r8,7
8000d6ca:	e0 89 00 04 	brgt	8000d6d2 <_vfprintf_r+0x18c2>
8000d6ce:	2f 83       	sub	r3,-8
8000d6d0:	c0 b8       	rjmp	8000d6e6 <_vfprintf_r+0x18d6>
8000d6d2:	fa ca f9 78 	sub	r10,sp,-1672
8000d6d6:	02 9b       	mov	r11,r1
8000d6d8:	08 9c       	mov	r12,r4
8000d6da:	fe b0 f3 8d 	rcall	8000bdf4 <__sprint_r>
8000d6de:	e0 81 03 18 	brne	8000dd0e <_vfprintf_r+0x1efe>
8000d6e2:	fa c3 f9 e0 	sub	r3,sp,-1568
8000d6e6:	ed b5 00 08 	bld	r5,0x8
8000d6ea:	c0 b0       	breq	8000d700 <_vfprintf_r+0x18f0>
8000d6ec:	fa f8 06 90 	ld.w	r8,sp[1680]
8000d6f0:	87 12       	st.w	r3[0x4],r2
8000d6f2:	87 06       	st.w	r3[0x0],r6
8000d6f4:	f0 02 00 02 	add	r2,r8,r2
8000d6f8:	fb 42 06 90 	st.w	sp[1680],r2
8000d6fc:	e0 8f 01 d4 	bral	8000daa4 <_vfprintf_r+0x1c94>
8000d700:	e0 40 00 65 	cp.w	r0,101
8000d704:	e0 8a 01 d6 	brle	8000dab0 <_vfprintf_r+0x1ca0>
8000d708:	30 08       	mov	r8,0
8000d70a:	30 09       	mov	r9,0
8000d70c:	40 5b       	lddsp	r11,sp[0x14]
8000d70e:	40 7a       	lddsp	r10,sp[0x1c]
8000d710:	e0 a0 15 2f 	rcall	8001016e <__avr32_f64_cmp_eq>
8000d714:	c7 90       	breq	8000d806 <_vfprintf_r+0x19f6>
8000d716:	fa f8 06 90 	ld.w	r8,sp[1680]
8000d71a:	fe c9 be a6 	sub	r9,pc,-16730
8000d71e:	2f f8       	sub	r8,-1
8000d720:	87 09       	st.w	r3[0x0],r9
8000d722:	fb 48 06 90 	st.w	sp[1680],r8
8000d726:	30 19       	mov	r9,1
8000d728:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000d72c:	87 19       	st.w	r3[0x4],r9
8000d72e:	2f f8       	sub	r8,-1
8000d730:	fb 48 06 8c 	st.w	sp[1676],r8
8000d734:	58 78       	cp.w	r8,7
8000d736:	e0 89 00 05 	brgt	8000d740 <_vfprintf_r+0x1930>
8000d73a:	2f 83       	sub	r3,-8
8000d73c:	c0 c8       	rjmp	8000d754 <_vfprintf_r+0x1944>
8000d73e:	d7 03       	nop
8000d740:	fa ca f9 78 	sub	r10,sp,-1672
8000d744:	02 9b       	mov	r11,r1
8000d746:	08 9c       	mov	r12,r4
8000d748:	fe b0 f3 56 	rcall	8000bdf4 <__sprint_r>
8000d74c:	e0 81 02 e1 	brne	8000dd0e <_vfprintf_r+0x1efe>
8000d750:	fa c3 f9 e0 	sub	r3,sp,-1568
8000d754:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000d758:	40 6c       	lddsp	r12,sp[0x18]
8000d75a:	18 38       	cp.w	r8,r12
8000d75c:	c0 55       	brlt	8000d766 <_vfprintf_r+0x1956>
8000d75e:	ed b5 00 00 	bld	r5,0x0
8000d762:	e0 81 02 6b 	brne	8000dc38 <_vfprintf_r+0x1e28>
8000d766:	fa f8 06 90 	ld.w	r8,sp[1680]
8000d76a:	2f f8       	sub	r8,-1
8000d76c:	40 cb       	lddsp	r11,sp[0x30]
8000d76e:	fb 48 06 90 	st.w	sp[1680],r8
8000d772:	30 19       	mov	r9,1
8000d774:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000d778:	87 0b       	st.w	r3[0x0],r11
8000d77a:	2f f8       	sub	r8,-1
8000d77c:	87 19       	st.w	r3[0x4],r9
8000d77e:	fb 48 06 8c 	st.w	sp[1676],r8
8000d782:	58 78       	cp.w	r8,7
8000d784:	e0 89 00 04 	brgt	8000d78c <_vfprintf_r+0x197c>
8000d788:	2f 83       	sub	r3,-8
8000d78a:	c0 b8       	rjmp	8000d7a0 <_vfprintf_r+0x1990>
8000d78c:	fa ca f9 78 	sub	r10,sp,-1672
8000d790:	02 9b       	mov	r11,r1
8000d792:	08 9c       	mov	r12,r4
8000d794:	fe b0 f3 30 	rcall	8000bdf4 <__sprint_r>
8000d798:	e0 81 02 bb 	brne	8000dd0e <_vfprintf_r+0x1efe>
8000d79c:	fa c3 f9 e0 	sub	r3,sp,-1568
8000d7a0:	40 66       	lddsp	r6,sp[0x18]
8000d7a2:	20 16       	sub	r6,1
8000d7a4:	58 06       	cp.w	r6,0
8000d7a6:	e0 89 00 1d 	brgt	8000d7e0 <_vfprintf_r+0x19d0>
8000d7aa:	e0 8f 02 47 	bral	8000dc38 <_vfprintf_r+0x1e28>
8000d7ae:	2f 09       	sub	r9,-16
8000d7b0:	2f f8       	sub	r8,-1
8000d7b2:	fb 49 06 90 	st.w	sp[1680],r9
8000d7b6:	87 02       	st.w	r3[0x0],r2
8000d7b8:	87 10       	st.w	r3[0x4],r0
8000d7ba:	fb 48 06 8c 	st.w	sp[1676],r8
8000d7be:	58 78       	cp.w	r8,7
8000d7c0:	e0 89 00 04 	brgt	8000d7c8 <_vfprintf_r+0x19b8>
8000d7c4:	2f 83       	sub	r3,-8
8000d7c6:	c0 b8       	rjmp	8000d7dc <_vfprintf_r+0x19cc>
8000d7c8:	fa ca f9 78 	sub	r10,sp,-1672
8000d7cc:	02 9b       	mov	r11,r1
8000d7ce:	08 9c       	mov	r12,r4
8000d7d0:	fe b0 f3 12 	rcall	8000bdf4 <__sprint_r>
8000d7d4:	e0 81 02 9d 	brne	8000dd0e <_vfprintf_r+0x1efe>
8000d7d8:	fa c3 f9 e0 	sub	r3,sp,-1568
8000d7dc:	21 06       	sub	r6,16
8000d7de:	c0 48       	rjmp	8000d7e6 <_vfprintf_r+0x19d6>
8000d7e0:	fe c2 bf 58 	sub	r2,pc,-16552
8000d7e4:	31 00       	mov	r0,16
8000d7e6:	fa f9 06 90 	ld.w	r9,sp[1680]
8000d7ea:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000d7ee:	fe ca bf 66 	sub	r10,pc,-16538
8000d7f2:	59 06       	cp.w	r6,16
8000d7f4:	fe 99 ff dd 	brgt	8000d7ae <_vfprintf_r+0x199e>
8000d7f8:	0c 09       	add	r9,r6
8000d7fa:	87 0a       	st.w	r3[0x0],r10
8000d7fc:	fb 49 06 90 	st.w	sp[1680],r9
8000d800:	2f f8       	sub	r8,-1
8000d802:	87 16       	st.w	r3[0x4],r6
8000d804:	c5 39       	rjmp	8000daaa <_vfprintf_r+0x1c9a>
8000d806:	fa fa 06 ac 	ld.w	r10,sp[1708]
8000d80a:	58 0a       	cp.w	r10,0
8000d80c:	e0 89 00 92 	brgt	8000d930 <_vfprintf_r+0x1b20>
8000d810:	fa f8 06 90 	ld.w	r8,sp[1680]
8000d814:	fe c9 bf a0 	sub	r9,pc,-16480
8000d818:	2f f8       	sub	r8,-1
8000d81a:	87 09       	st.w	r3[0x0],r9
8000d81c:	fb 48 06 90 	st.w	sp[1680],r8
8000d820:	30 19       	mov	r9,1
8000d822:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000d826:	87 19       	st.w	r3[0x4],r9
8000d828:	2f f8       	sub	r8,-1
8000d82a:	fb 48 06 8c 	st.w	sp[1676],r8
8000d82e:	58 78       	cp.w	r8,7
8000d830:	e0 89 00 04 	brgt	8000d838 <_vfprintf_r+0x1a28>
8000d834:	2f 83       	sub	r3,-8
8000d836:	c0 b8       	rjmp	8000d84c <_vfprintf_r+0x1a3c>
8000d838:	fa ca f9 78 	sub	r10,sp,-1672
8000d83c:	02 9b       	mov	r11,r1
8000d83e:	08 9c       	mov	r12,r4
8000d840:	fe b0 f2 da 	rcall	8000bdf4 <__sprint_r>
8000d844:	e0 81 02 65 	brne	8000dd0e <_vfprintf_r+0x1efe>
8000d848:	fa c3 f9 e0 	sub	r3,sp,-1568
8000d84c:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000d850:	58 08       	cp.w	r8,0
8000d852:	c0 81       	brne	8000d862 <_vfprintf_r+0x1a52>
8000d854:	40 6a       	lddsp	r10,sp[0x18]
8000d856:	58 0a       	cp.w	r10,0
8000d858:	c0 51       	brne	8000d862 <_vfprintf_r+0x1a52>
8000d85a:	ed b5 00 00 	bld	r5,0x0
8000d85e:	e0 81 01 ed 	brne	8000dc38 <_vfprintf_r+0x1e28>
8000d862:	40 c9       	lddsp	r9,sp[0x30]
8000d864:	fa f8 06 90 	ld.w	r8,sp[1680]
8000d868:	2f f8       	sub	r8,-1
8000d86a:	87 09       	st.w	r3[0x0],r9
8000d86c:	fb 48 06 90 	st.w	sp[1680],r8
8000d870:	30 19       	mov	r9,1
8000d872:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000d876:	87 19       	st.w	r3[0x4],r9
8000d878:	2f f8       	sub	r8,-1
8000d87a:	fb 48 06 8c 	st.w	sp[1676],r8
8000d87e:	58 78       	cp.w	r8,7
8000d880:	e0 89 00 04 	brgt	8000d888 <_vfprintf_r+0x1a78>
8000d884:	2f 83       	sub	r3,-8
8000d886:	c0 b8       	rjmp	8000d89c <_vfprintf_r+0x1a8c>
8000d888:	fa ca f9 78 	sub	r10,sp,-1672
8000d88c:	02 9b       	mov	r11,r1
8000d88e:	08 9c       	mov	r12,r4
8000d890:	fe b0 f2 b2 	rcall	8000bdf4 <__sprint_r>
8000d894:	e0 81 02 3d 	brne	8000dd0e <_vfprintf_r+0x1efe>
8000d898:	fa c3 f9 e0 	sub	r3,sp,-1568
8000d89c:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000d8a0:	5c 32       	neg	r2
8000d8a2:	58 02       	cp.w	r2,0
8000d8a4:	e0 89 00 1d 	brgt	8000d8de <_vfprintf_r+0x1ace>
8000d8a8:	c3 d8       	rjmp	8000d922 <_vfprintf_r+0x1b12>
8000d8aa:	2f 09       	sub	r9,-16
8000d8ac:	2f f8       	sub	r8,-1
8000d8ae:	31 0e       	mov	lr,16
8000d8b0:	fb 49 06 90 	st.w	sp[1680],r9
8000d8b4:	87 00       	st.w	r3[0x0],r0
8000d8b6:	87 1e       	st.w	r3[0x4],lr
8000d8b8:	fb 48 06 8c 	st.w	sp[1676],r8
8000d8bc:	58 78       	cp.w	r8,7
8000d8be:	e0 89 00 04 	brgt	8000d8c6 <_vfprintf_r+0x1ab6>
8000d8c2:	2f 83       	sub	r3,-8
8000d8c4:	c0 b8       	rjmp	8000d8da <_vfprintf_r+0x1aca>
8000d8c6:	fa ca f9 78 	sub	r10,sp,-1672
8000d8ca:	02 9b       	mov	r11,r1
8000d8cc:	08 9c       	mov	r12,r4
8000d8ce:	fe b0 f2 93 	rcall	8000bdf4 <__sprint_r>
8000d8d2:	e0 81 02 1e 	brne	8000dd0e <_vfprintf_r+0x1efe>
8000d8d6:	fa c3 f9 e0 	sub	r3,sp,-1568
8000d8da:	21 02       	sub	r2,16
8000d8dc:	c0 38       	rjmp	8000d8e2 <_vfprintf_r+0x1ad2>
8000d8de:	fe c0 c0 56 	sub	r0,pc,-16298
8000d8e2:	fa f9 06 90 	ld.w	r9,sp[1680]
8000d8e6:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000d8ea:	fe ca c0 62 	sub	r10,pc,-16286
8000d8ee:	59 02       	cp.w	r2,16
8000d8f0:	fe 99 ff dd 	brgt	8000d8aa <_vfprintf_r+0x1a9a>
8000d8f4:	04 09       	add	r9,r2
8000d8f6:	2f f8       	sub	r8,-1
8000d8f8:	87 0a       	st.w	r3[0x0],r10
8000d8fa:	fb 49 06 90 	st.w	sp[1680],r9
8000d8fe:	87 12       	st.w	r3[0x4],r2
8000d900:	fb 48 06 8c 	st.w	sp[1676],r8
8000d904:	58 78       	cp.w	r8,7
8000d906:	e0 89 00 04 	brgt	8000d90e <_vfprintf_r+0x1afe>
8000d90a:	2f 83       	sub	r3,-8
8000d90c:	c0 b8       	rjmp	8000d922 <_vfprintf_r+0x1b12>
8000d90e:	fa ca f9 78 	sub	r10,sp,-1672
8000d912:	02 9b       	mov	r11,r1
8000d914:	08 9c       	mov	r12,r4
8000d916:	fe b0 f2 6f 	rcall	8000bdf4 <__sprint_r>
8000d91a:	e0 81 01 fa 	brne	8000dd0e <_vfprintf_r+0x1efe>
8000d91e:	fa c3 f9 e0 	sub	r3,sp,-1568
8000d922:	40 6c       	lddsp	r12,sp[0x18]
8000d924:	fa f8 06 90 	ld.w	r8,sp[1680]
8000d928:	87 06       	st.w	r3[0x0],r6
8000d92a:	87 1c       	st.w	r3[0x4],r12
8000d92c:	18 08       	add	r8,r12
8000d92e:	cb 98       	rjmp	8000daa0 <_vfprintf_r+0x1c90>
8000d930:	fa f9 06 90 	ld.w	r9,sp[1680]
8000d934:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000d938:	40 6b       	lddsp	r11,sp[0x18]
8000d93a:	16 3a       	cp.w	r10,r11
8000d93c:	c6 f5       	brlt	8000da1a <_vfprintf_r+0x1c0a>
8000d93e:	16 09       	add	r9,r11
8000d940:	2f f8       	sub	r8,-1
8000d942:	87 06       	st.w	r3[0x0],r6
8000d944:	fb 49 06 90 	st.w	sp[1680],r9
8000d948:	87 1b       	st.w	r3[0x4],r11
8000d94a:	fb 48 06 8c 	st.w	sp[1676],r8
8000d94e:	58 78       	cp.w	r8,7
8000d950:	e0 89 00 04 	brgt	8000d958 <_vfprintf_r+0x1b48>
8000d954:	2f 83       	sub	r3,-8
8000d956:	c0 b8       	rjmp	8000d96c <_vfprintf_r+0x1b5c>
8000d958:	fa ca f9 78 	sub	r10,sp,-1672
8000d95c:	02 9b       	mov	r11,r1
8000d95e:	08 9c       	mov	r12,r4
8000d960:	fe b0 f2 4a 	rcall	8000bdf4 <__sprint_r>
8000d964:	e0 81 01 d5 	brne	8000dd0e <_vfprintf_r+0x1efe>
8000d968:	fa c3 f9 e0 	sub	r3,sp,-1568
8000d96c:	fa f6 06 ac 	ld.w	r6,sp[1708]
8000d970:	40 6a       	lddsp	r10,sp[0x18]
8000d972:	14 16       	sub	r6,r10
8000d974:	58 06       	cp.w	r6,0
8000d976:	e0 89 00 1c 	brgt	8000d9ae <_vfprintf_r+0x1b9e>
8000d97a:	c3 d8       	rjmp	8000d9f4 <_vfprintf_r+0x1be4>
8000d97c:	2f 09       	sub	r9,-16
8000d97e:	2f f8       	sub	r8,-1
8000d980:	fb 49 06 90 	st.w	sp[1680],r9
8000d984:	87 02       	st.w	r3[0x0],r2
8000d986:	87 10       	st.w	r3[0x4],r0
8000d988:	fb 48 06 8c 	st.w	sp[1676],r8
8000d98c:	58 78       	cp.w	r8,7
8000d98e:	e0 89 00 04 	brgt	8000d996 <_vfprintf_r+0x1b86>
8000d992:	2f 83       	sub	r3,-8
8000d994:	c0 b8       	rjmp	8000d9aa <_vfprintf_r+0x1b9a>
8000d996:	fa ca f9 78 	sub	r10,sp,-1672
8000d99a:	02 9b       	mov	r11,r1
8000d99c:	08 9c       	mov	r12,r4
8000d99e:	fe b0 f2 2b 	rcall	8000bdf4 <__sprint_r>
8000d9a2:	e0 81 01 b6 	brne	8000dd0e <_vfprintf_r+0x1efe>
8000d9a6:	fa c3 f9 e0 	sub	r3,sp,-1568
8000d9aa:	21 06       	sub	r6,16
8000d9ac:	c0 48       	rjmp	8000d9b4 <_vfprintf_r+0x1ba4>
8000d9ae:	fe c2 c1 26 	sub	r2,pc,-16090
8000d9b2:	31 00       	mov	r0,16
8000d9b4:	fa f9 06 90 	ld.w	r9,sp[1680]
8000d9b8:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000d9bc:	fe ca c1 34 	sub	r10,pc,-16076
8000d9c0:	59 06       	cp.w	r6,16
8000d9c2:	fe 99 ff dd 	brgt	8000d97c <_vfprintf_r+0x1b6c>
8000d9c6:	0c 09       	add	r9,r6
8000d9c8:	2f f8       	sub	r8,-1
8000d9ca:	87 0a       	st.w	r3[0x0],r10
8000d9cc:	fb 49 06 90 	st.w	sp[1680],r9
8000d9d0:	87 16       	st.w	r3[0x4],r6
8000d9d2:	fb 48 06 8c 	st.w	sp[1676],r8
8000d9d6:	58 78       	cp.w	r8,7
8000d9d8:	e0 89 00 04 	brgt	8000d9e0 <_vfprintf_r+0x1bd0>
8000d9dc:	2f 83       	sub	r3,-8
8000d9de:	c0 b8       	rjmp	8000d9f4 <_vfprintf_r+0x1be4>
8000d9e0:	fa ca f9 78 	sub	r10,sp,-1672
8000d9e4:	02 9b       	mov	r11,r1
8000d9e6:	08 9c       	mov	r12,r4
8000d9e8:	fe b0 f2 06 	rcall	8000bdf4 <__sprint_r>
8000d9ec:	e0 81 01 91 	brne	8000dd0e <_vfprintf_r+0x1efe>
8000d9f0:	fa c3 f9 e0 	sub	r3,sp,-1568
8000d9f4:	ed b5 00 00 	bld	r5,0x0
8000d9f8:	e0 81 01 20 	brne	8000dc38 <_vfprintf_r+0x1e28>
8000d9fc:	40 c9       	lddsp	r9,sp[0x30]
8000d9fe:	fa f8 06 90 	ld.w	r8,sp[1680]
8000da02:	2f f8       	sub	r8,-1
8000da04:	87 09       	st.w	r3[0x0],r9
8000da06:	fb 48 06 90 	st.w	sp[1680],r8
8000da0a:	30 19       	mov	r9,1
8000da0c:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000da10:	87 19       	st.w	r3[0x4],r9
8000da12:	2f f8       	sub	r8,-1
8000da14:	fb 48 06 8c 	st.w	sp[1676],r8
8000da18:	c0 29       	rjmp	8000dc1c <_vfprintf_r+0x1e0c>
8000da1a:	14 09       	add	r9,r10
8000da1c:	2f f8       	sub	r8,-1
8000da1e:	fb 49 06 90 	st.w	sp[1680],r9
8000da22:	87 06       	st.w	r3[0x0],r6
8000da24:	87 1a       	st.w	r3[0x4],r10
8000da26:	fb 48 06 8c 	st.w	sp[1676],r8
8000da2a:	58 78       	cp.w	r8,7
8000da2c:	e0 89 00 04 	brgt	8000da34 <_vfprintf_r+0x1c24>
8000da30:	2f 83       	sub	r3,-8
8000da32:	c0 b8       	rjmp	8000da48 <_vfprintf_r+0x1c38>
8000da34:	fa ca f9 78 	sub	r10,sp,-1672
8000da38:	02 9b       	mov	r11,r1
8000da3a:	08 9c       	mov	r12,r4
8000da3c:	fe b0 f1 dc 	rcall	8000bdf4 <__sprint_r>
8000da40:	e0 81 01 67 	brne	8000dd0e <_vfprintf_r+0x1efe>
8000da44:	fa c3 f9 e0 	sub	r3,sp,-1568
8000da48:	40 c8       	lddsp	r8,sp[0x30]
8000da4a:	87 08       	st.w	r3[0x0],r8
8000da4c:	fa f8 06 90 	ld.w	r8,sp[1680]
8000da50:	2f f8       	sub	r8,-1
8000da52:	30 19       	mov	r9,1
8000da54:	fb 48 06 90 	st.w	sp[1680],r8
8000da58:	87 19       	st.w	r3[0x4],r9
8000da5a:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000da5e:	2f f8       	sub	r8,-1
8000da60:	fb 48 06 8c 	st.w	sp[1676],r8
8000da64:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000da68:	58 78       	cp.w	r8,7
8000da6a:	e0 89 00 04 	brgt	8000da72 <_vfprintf_r+0x1c62>
8000da6e:	2f 83       	sub	r3,-8
8000da70:	c0 b8       	rjmp	8000da86 <_vfprintf_r+0x1c76>
8000da72:	fa ca f9 78 	sub	r10,sp,-1672
8000da76:	02 9b       	mov	r11,r1
8000da78:	08 9c       	mov	r12,r4
8000da7a:	fe b0 f1 bd 	rcall	8000bdf4 <__sprint_r>
8000da7e:	e0 81 01 48 	brne	8000dd0e <_vfprintf_r+0x1efe>
8000da82:	fa c3 f9 e0 	sub	r3,sp,-1568
8000da86:	04 06       	add	r6,r2
8000da88:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000da8c:	87 06       	st.w	r3[0x0],r6
8000da8e:	fa f9 06 90 	ld.w	r9,sp[1680]
8000da92:	40 66       	lddsp	r6,sp[0x18]
8000da94:	40 6e       	lddsp	lr,sp[0x18]
8000da96:	10 16       	sub	r6,r8
8000da98:	f2 08 01 08 	sub	r8,r9,r8
8000da9c:	87 16       	st.w	r3[0x4],r6
8000da9e:	1c 08       	add	r8,lr
8000daa0:	fb 48 06 90 	st.w	sp[1680],r8
8000daa4:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000daa8:	2f f8       	sub	r8,-1
8000daaa:	fb 48 06 8c 	st.w	sp[1676],r8
8000daae:	cb 78       	rjmp	8000dc1c <_vfprintf_r+0x1e0c>
8000dab0:	40 6c       	lddsp	r12,sp[0x18]
8000dab2:	58 1c       	cp.w	r12,1
8000dab4:	e0 89 00 06 	brgt	8000dac0 <_vfprintf_r+0x1cb0>
8000dab8:	ed b5 00 00 	bld	r5,0x0
8000dabc:	e0 81 00 85 	brne	8000dbc6 <_vfprintf_r+0x1db6>
8000dac0:	fa f8 06 90 	ld.w	r8,sp[1680]
8000dac4:	2f f8       	sub	r8,-1
8000dac6:	30 19       	mov	r9,1
8000dac8:	fb 48 06 90 	st.w	sp[1680],r8
8000dacc:	87 06       	st.w	r3[0x0],r6
8000dace:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000dad2:	87 19       	st.w	r3[0x4],r9
8000dad4:	2f f8       	sub	r8,-1
8000dad6:	fb 48 06 8c 	st.w	sp[1676],r8
8000dada:	58 78       	cp.w	r8,7
8000dadc:	e0 89 00 04 	brgt	8000dae4 <_vfprintf_r+0x1cd4>
8000dae0:	2f 83       	sub	r3,-8
8000dae2:	c0 b8       	rjmp	8000daf8 <_vfprintf_r+0x1ce8>
8000dae4:	fa ca f9 78 	sub	r10,sp,-1672
8000dae8:	02 9b       	mov	r11,r1
8000daea:	08 9c       	mov	r12,r4
8000daec:	fe b0 f1 84 	rcall	8000bdf4 <__sprint_r>
8000daf0:	e0 81 01 0f 	brne	8000dd0e <_vfprintf_r+0x1efe>
8000daf4:	fa c3 f9 e0 	sub	r3,sp,-1568
8000daf8:	fa f8 06 90 	ld.w	r8,sp[1680]
8000dafc:	2f f8       	sub	r8,-1
8000dafe:	40 cb       	lddsp	r11,sp[0x30]
8000db00:	fb 48 06 90 	st.w	sp[1680],r8
8000db04:	30 19       	mov	r9,1
8000db06:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000db0a:	87 0b       	st.w	r3[0x0],r11
8000db0c:	2f f8       	sub	r8,-1
8000db0e:	87 19       	st.w	r3[0x4],r9
8000db10:	fb 48 06 8c 	st.w	sp[1676],r8
8000db14:	58 78       	cp.w	r8,7
8000db16:	e0 89 00 05 	brgt	8000db20 <_vfprintf_r+0x1d10>
8000db1a:	2f 83       	sub	r3,-8
8000db1c:	c0 c8       	rjmp	8000db34 <_vfprintf_r+0x1d24>
8000db1e:	d7 03       	nop
8000db20:	fa ca f9 78 	sub	r10,sp,-1672
8000db24:	02 9b       	mov	r11,r1
8000db26:	08 9c       	mov	r12,r4
8000db28:	fe b0 f1 66 	rcall	8000bdf4 <__sprint_r>
8000db2c:	e0 81 00 f1 	brne	8000dd0e <_vfprintf_r+0x1efe>
8000db30:	fa c3 f9 e0 	sub	r3,sp,-1568
8000db34:	30 08       	mov	r8,0
8000db36:	30 09       	mov	r9,0
8000db38:	40 5b       	lddsp	r11,sp[0x14]
8000db3a:	40 7a       	lddsp	r10,sp[0x1c]
8000db3c:	e0 a0 13 19 	rcall	8001016e <__avr32_f64_cmp_eq>
8000db40:	40 68       	lddsp	r8,sp[0x18]
8000db42:	20 18       	sub	r8,1
8000db44:	58 0c       	cp.w	r12,0
8000db46:	c0 d1       	brne	8000db60 <_vfprintf_r+0x1d50>
8000db48:	2f f6       	sub	r6,-1
8000db4a:	87 18       	st.w	r3[0x4],r8
8000db4c:	87 06       	st.w	r3[0x0],r6
8000db4e:	fa f6 06 90 	ld.w	r6,sp[1680]
8000db52:	10 06       	add	r6,r8
8000db54:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000db58:	fb 46 06 90 	st.w	sp[1680],r6
8000db5c:	2f f8       	sub	r8,-1
8000db5e:	c3 18       	rjmp	8000dbc0 <_vfprintf_r+0x1db0>
8000db60:	10 96       	mov	r6,r8
8000db62:	58 08       	cp.w	r8,0
8000db64:	e0 89 00 1c 	brgt	8000db9c <_vfprintf_r+0x1d8c>
8000db68:	c4 b8       	rjmp	8000dbfe <_vfprintf_r+0x1dee>
8000db6a:	2f 09       	sub	r9,-16
8000db6c:	2f f8       	sub	r8,-1
8000db6e:	fb 49 06 90 	st.w	sp[1680],r9
8000db72:	87 02       	st.w	r3[0x0],r2
8000db74:	87 10       	st.w	r3[0x4],r0
8000db76:	fb 48 06 8c 	st.w	sp[1676],r8
8000db7a:	58 78       	cp.w	r8,7
8000db7c:	e0 89 00 04 	brgt	8000db84 <_vfprintf_r+0x1d74>
8000db80:	2f 83       	sub	r3,-8
8000db82:	c0 b8       	rjmp	8000db98 <_vfprintf_r+0x1d88>
8000db84:	fa ca f9 78 	sub	r10,sp,-1672
8000db88:	02 9b       	mov	r11,r1
8000db8a:	08 9c       	mov	r12,r4
8000db8c:	fe b0 f1 34 	rcall	8000bdf4 <__sprint_r>
8000db90:	e0 81 00 bf 	brne	8000dd0e <_vfprintf_r+0x1efe>
8000db94:	fa c3 f9 e0 	sub	r3,sp,-1568
8000db98:	21 06       	sub	r6,16
8000db9a:	c0 48       	rjmp	8000dba2 <_vfprintf_r+0x1d92>
8000db9c:	fe c2 c3 14 	sub	r2,pc,-15596
8000dba0:	31 00       	mov	r0,16
8000dba2:	fa f9 06 90 	ld.w	r9,sp[1680]
8000dba6:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000dbaa:	fe ca c3 22 	sub	r10,pc,-15582
8000dbae:	59 06       	cp.w	r6,16
8000dbb0:	fe 99 ff dd 	brgt	8000db6a <_vfprintf_r+0x1d5a>
8000dbb4:	0c 09       	add	r9,r6
8000dbb6:	87 0a       	st.w	r3[0x0],r10
8000dbb8:	fb 49 06 90 	st.w	sp[1680],r9
8000dbbc:	2f f8       	sub	r8,-1
8000dbbe:	87 16       	st.w	r3[0x4],r6
8000dbc0:	fb 48 06 8c 	st.w	sp[1676],r8
8000dbc4:	c0 e8       	rjmp	8000dbe0 <_vfprintf_r+0x1dd0>
8000dbc6:	fa f8 06 90 	ld.w	r8,sp[1680]
8000dbca:	2f f8       	sub	r8,-1
8000dbcc:	30 19       	mov	r9,1
8000dbce:	fb 48 06 90 	st.w	sp[1680],r8
8000dbd2:	87 06       	st.w	r3[0x0],r6
8000dbd4:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000dbd8:	87 19       	st.w	r3[0x4],r9
8000dbda:	2f f8       	sub	r8,-1
8000dbdc:	fb 48 06 8c 	st.w	sp[1676],r8
8000dbe0:	58 78       	cp.w	r8,7
8000dbe2:	e0 89 00 04 	brgt	8000dbea <_vfprintf_r+0x1dda>
8000dbe6:	2f 83       	sub	r3,-8
8000dbe8:	c0 b8       	rjmp	8000dbfe <_vfprintf_r+0x1dee>
8000dbea:	fa ca f9 78 	sub	r10,sp,-1672
8000dbee:	02 9b       	mov	r11,r1
8000dbf0:	08 9c       	mov	r12,r4
8000dbf2:	fe b0 f1 01 	rcall	8000bdf4 <__sprint_r>
8000dbf6:	e0 81 00 8c 	brne	8000dd0e <_vfprintf_r+0x1efe>
8000dbfa:	fa c3 f9 e0 	sub	r3,sp,-1568
8000dbfe:	40 ea       	lddsp	r10,sp[0x38]
8000dc00:	fa f8 06 90 	ld.w	r8,sp[1680]
8000dc04:	14 08       	add	r8,r10
8000dc06:	fa c9 f9 64 	sub	r9,sp,-1692
8000dc0a:	fb 48 06 90 	st.w	sp[1680],r8
8000dc0e:	87 1a       	st.w	r3[0x4],r10
8000dc10:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000dc14:	87 09       	st.w	r3[0x0],r9
8000dc16:	2f f8       	sub	r8,-1
8000dc18:	fb 48 06 8c 	st.w	sp[1676],r8
8000dc1c:	58 78       	cp.w	r8,7
8000dc1e:	e0 89 00 04 	brgt	8000dc26 <_vfprintf_r+0x1e16>
8000dc22:	2f 83       	sub	r3,-8
8000dc24:	c0 a8       	rjmp	8000dc38 <_vfprintf_r+0x1e28>
8000dc26:	fa ca f9 78 	sub	r10,sp,-1672
8000dc2a:	02 9b       	mov	r11,r1
8000dc2c:	08 9c       	mov	r12,r4
8000dc2e:	fe b0 f0 e3 	rcall	8000bdf4 <__sprint_r>
8000dc32:	c6 e1       	brne	8000dd0e <_vfprintf_r+0x1efe>
8000dc34:	fa c3 f9 e0 	sub	r3,sp,-1568
8000dc38:	e2 15 00 04 	andl	r5,0x4,COH
8000dc3c:	c3 f0       	breq	8000dcba <_vfprintf_r+0x1eaa>
8000dc3e:	40 86       	lddsp	r6,sp[0x20]
8000dc40:	40 39       	lddsp	r9,sp[0xc]
8000dc42:	12 16       	sub	r6,r9
8000dc44:	58 06       	cp.w	r6,0
8000dc46:	e0 89 00 1a 	brgt	8000dc7a <_vfprintf_r+0x1e6a>
8000dc4a:	c3 88       	rjmp	8000dcba <_vfprintf_r+0x1eaa>
8000dc4c:	2f 09       	sub	r9,-16
8000dc4e:	2f f8       	sub	r8,-1
8000dc50:	fb 49 06 90 	st.w	sp[1680],r9
8000dc54:	87 05       	st.w	r3[0x0],r5
8000dc56:	87 12       	st.w	r3[0x4],r2
8000dc58:	fb 48 06 8c 	st.w	sp[1676],r8
8000dc5c:	58 78       	cp.w	r8,7
8000dc5e:	e0 89 00 04 	brgt	8000dc66 <_vfprintf_r+0x1e56>
8000dc62:	2f 83       	sub	r3,-8
8000dc64:	c0 98       	rjmp	8000dc76 <_vfprintf_r+0x1e66>
8000dc66:	00 9a       	mov	r10,r0
8000dc68:	02 9b       	mov	r11,r1
8000dc6a:	08 9c       	mov	r12,r4
8000dc6c:	fe b0 f0 c4 	rcall	8000bdf4 <__sprint_r>
8000dc70:	c4 f1       	brne	8000dd0e <_vfprintf_r+0x1efe>
8000dc72:	fa c3 f9 e0 	sub	r3,sp,-1568
8000dc76:	21 06       	sub	r6,16
8000dc78:	c0 68       	rjmp	8000dc84 <_vfprintf_r+0x1e74>
8000dc7a:	fe c5 c4 02 	sub	r5,pc,-15358
8000dc7e:	31 02       	mov	r2,16
8000dc80:	fa c0 f9 78 	sub	r0,sp,-1672
8000dc84:	fa f9 06 90 	ld.w	r9,sp[1680]
8000dc88:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000dc8c:	fe ca c4 14 	sub	r10,pc,-15340
8000dc90:	59 06       	cp.w	r6,16
8000dc92:	fe 99 ff dd 	brgt	8000dc4c <_vfprintf_r+0x1e3c>
8000dc96:	0c 09       	add	r9,r6
8000dc98:	2f f8       	sub	r8,-1
8000dc9a:	87 0a       	st.w	r3[0x0],r10
8000dc9c:	87 16       	st.w	r3[0x4],r6
8000dc9e:	fb 49 06 90 	st.w	sp[1680],r9
8000dca2:	fb 48 06 8c 	st.w	sp[1676],r8
8000dca6:	58 78       	cp.w	r8,7
8000dca8:	e0 8a 00 09 	brle	8000dcba <_vfprintf_r+0x1eaa>
8000dcac:	fa ca f9 78 	sub	r10,sp,-1672
8000dcb0:	02 9b       	mov	r11,r1
8000dcb2:	08 9c       	mov	r12,r4
8000dcb4:	fe b0 f0 a0 	rcall	8000bdf4 <__sprint_r>
8000dcb8:	c2 b1       	brne	8000dd0e <_vfprintf_r+0x1efe>
8000dcba:	40 bc       	lddsp	r12,sp[0x2c]
8000dcbc:	40 36       	lddsp	r6,sp[0xc]
8000dcbe:	40 8e       	lddsp	lr,sp[0x20]
8000dcc0:	ec 0e 0c 48 	max	r8,r6,lr
8000dcc4:	10 0c       	add	r12,r8
8000dcc6:	50 bc       	stdsp	sp[0x2c],r12
8000dcc8:	fa f8 06 90 	ld.w	r8,sp[1680]
8000dccc:	58 08       	cp.w	r8,0
8000dcce:	c0 80       	breq	8000dcde <_vfprintf_r+0x1ece>
8000dcd0:	fa ca f9 78 	sub	r10,sp,-1672
8000dcd4:	02 9b       	mov	r11,r1
8000dcd6:	08 9c       	mov	r12,r4
8000dcd8:	fe b0 f0 8e 	rcall	8000bdf4 <__sprint_r>
8000dcdc:	c1 91       	brne	8000dd0e <_vfprintf_r+0x1efe>
8000dcde:	30 0b       	mov	r11,0
8000dce0:	fa c3 f9 e0 	sub	r3,sp,-1568
8000dce4:	fb 4b 06 8c 	st.w	sp[1676],r11
8000dce8:	fe 9f f1 22 	bral	8000bf2c <_vfprintf_r+0x11c>
8000dcec:	08 95       	mov	r5,r4
8000dcee:	fa f8 06 90 	ld.w	r8,sp[1680]
8000dcf2:	58 08       	cp.w	r8,0
8000dcf4:	c0 80       	breq	8000dd04 <_vfprintf_r+0x1ef4>
8000dcf6:	08 9c       	mov	r12,r4
8000dcf8:	fa ca f9 78 	sub	r10,sp,-1672
8000dcfc:	02 9b       	mov	r11,r1
8000dcfe:	fe b0 f0 7b 	rcall	8000bdf4 <__sprint_r>
8000dd02:	c0 61       	brne	8000dd0e <_vfprintf_r+0x1efe>
8000dd04:	30 08       	mov	r8,0
8000dd06:	fb 48 06 8c 	st.w	sp[1676],r8
8000dd0a:	c0 28       	rjmp	8000dd0e <_vfprintf_r+0x1efe>
8000dd0c:	40 41       	lddsp	r1,sp[0x10]
8000dd0e:	82 68       	ld.sh	r8,r1[0xc]
8000dd10:	ed b8 00 06 	bld	r8,0x6
8000dd14:	c0 31       	brne	8000dd1a <_vfprintf_r+0x1f0a>
8000dd16:	3f fa       	mov	r10,-1
8000dd18:	50 ba       	stdsp	sp[0x2c],r10
8000dd1a:	40 bc       	lddsp	r12,sp[0x2c]
8000dd1c:	fe 3d f9 44 	sub	sp,-1724
8000dd20:	d8 32       	popm	r0-r7,pc
8000dd22:	d7 03       	nop

8000dd24 <__swsetup_r>:
8000dd24:	d4 21       	pushm	r4-r7,lr
8000dd26:	e0 68 0a 50 	mov	r8,2640
8000dd2a:	18 96       	mov	r6,r12
8000dd2c:	16 97       	mov	r7,r11
8000dd2e:	70 0c       	ld.w	r12,r8[0x0]
8000dd30:	58 0c       	cp.w	r12,0
8000dd32:	c0 60       	breq	8000dd3e <__swsetup_r+0x1a>
8000dd34:	78 68       	ld.w	r8,r12[0x18]
8000dd36:	58 08       	cp.w	r8,0
8000dd38:	c0 31       	brne	8000dd3e <__swsetup_r+0x1a>
8000dd3a:	e0 a0 07 bf 	rcall	8000ecb8 <__sinit>
8000dd3e:	fe c8 c3 96 	sub	r8,pc,-15466
8000dd42:	10 37       	cp.w	r7,r8
8000dd44:	c0 61       	brne	8000dd50 <__swsetup_r+0x2c>
8000dd46:	e0 68 0a 50 	mov	r8,2640
8000dd4a:	70 08       	ld.w	r8,r8[0x0]
8000dd4c:	70 07       	ld.w	r7,r8[0x0]
8000dd4e:	c1 28       	rjmp	8000dd72 <__swsetup_r+0x4e>
8000dd50:	fe c8 c3 88 	sub	r8,pc,-15480
8000dd54:	10 37       	cp.w	r7,r8
8000dd56:	c0 61       	brne	8000dd62 <__swsetup_r+0x3e>
8000dd58:	e0 68 0a 50 	mov	r8,2640
8000dd5c:	70 08       	ld.w	r8,r8[0x0]
8000dd5e:	70 17       	ld.w	r7,r8[0x4]
8000dd60:	c0 98       	rjmp	8000dd72 <__swsetup_r+0x4e>
8000dd62:	fe c8 c3 7a 	sub	r8,pc,-15494
8000dd66:	10 37       	cp.w	r7,r8
8000dd68:	c0 51       	brne	8000dd72 <__swsetup_r+0x4e>
8000dd6a:	e0 68 0a 50 	mov	r8,2640
8000dd6e:	70 08       	ld.w	r8,r8[0x0]
8000dd70:	70 27       	ld.w	r7,r8[0x8]
8000dd72:	8e 68       	ld.sh	r8,r7[0xc]
8000dd74:	ed b8 00 03 	bld	r8,0x3
8000dd78:	c1 e0       	breq	8000ddb4 <__swsetup_r+0x90>
8000dd7a:	ed b8 00 04 	bld	r8,0x4
8000dd7e:	c3 e1       	brne	8000ddfa <__swsetup_r+0xd6>
8000dd80:	ed b8 00 02 	bld	r8,0x2
8000dd84:	c1 51       	brne	8000ddae <__swsetup_r+0x8a>
8000dd86:	6e db       	ld.w	r11,r7[0x34]
8000dd88:	58 0b       	cp.w	r11,0
8000dd8a:	c0 a0       	breq	8000dd9e <__swsetup_r+0x7a>
8000dd8c:	ee c8 ff bc 	sub	r8,r7,-68
8000dd90:	10 3b       	cp.w	r11,r8
8000dd92:	c0 40       	breq	8000dd9a <__swsetup_r+0x76>
8000dd94:	0c 9c       	mov	r12,r6
8000dd96:	e0 a0 08 2b 	rcall	8000edec <_free_r>
8000dd9a:	30 08       	mov	r8,0
8000dd9c:	8f d8       	st.w	r7[0x34],r8
8000dd9e:	8e 68       	ld.sh	r8,r7[0xc]
8000dda0:	e0 18 ff db 	andl	r8,0xffdb
8000dda4:	ae 68       	st.h	r7[0xc],r8
8000dda6:	30 08       	mov	r8,0
8000dda8:	8f 18       	st.w	r7[0x4],r8
8000ddaa:	6e 48       	ld.w	r8,r7[0x10]
8000ddac:	8f 08       	st.w	r7[0x0],r8
8000ddae:	8e 68       	ld.sh	r8,r7[0xc]
8000ddb0:	a3 b8       	sbr	r8,0x3
8000ddb2:	ae 68       	st.h	r7[0xc],r8
8000ddb4:	6e 48       	ld.w	r8,r7[0x10]
8000ddb6:	58 08       	cp.w	r8,0
8000ddb8:	c0 b1       	brne	8000ddce <__swsetup_r+0xaa>
8000ddba:	8e 68       	ld.sh	r8,r7[0xc]
8000ddbc:	e2 18 02 80 	andl	r8,0x280,COH
8000ddc0:	e0 48 02 00 	cp.w	r8,512
8000ddc4:	c0 50       	breq	8000ddce <__swsetup_r+0xaa>
8000ddc6:	0c 9c       	mov	r12,r6
8000ddc8:	0e 9b       	mov	r11,r7
8000ddca:	e0 a0 0a 4b 	rcall	8000f260 <__smakebuf_r>
8000ddce:	8e 69       	ld.sh	r9,r7[0xc]
8000ddd0:	f1 d9 c0 01 	bfextu	r8,r9,0x0,0x1
8000ddd4:	c0 70       	breq	8000dde2 <__swsetup_r+0xbe>
8000ddd6:	30 08       	mov	r8,0
8000ddd8:	8f 28       	st.w	r7[0x8],r8
8000ddda:	6e 58       	ld.w	r8,r7[0x14]
8000dddc:	5c 38       	neg	r8
8000ddde:	8f 68       	st.w	r7[0x18],r8
8000dde0:	c0 68       	rjmp	8000ddec <__swsetup_r+0xc8>
8000dde2:	ed b9 00 01 	bld	r9,0x1
8000dde6:	ef f8 10 05 	ld.wne	r8,r7[0x14]
8000ddea:	8f 28       	st.w	r7[0x8],r8
8000ddec:	6e 48       	ld.w	r8,r7[0x10]
8000ddee:	58 08       	cp.w	r8,0
8000ddf0:	c0 61       	brne	8000ddfc <__swsetup_r+0xd8>
8000ddf2:	8e 68       	ld.sh	r8,r7[0xc]
8000ddf4:	ed b8 00 07 	bld	r8,0x7
8000ddf8:	c0 21       	brne	8000ddfc <__swsetup_r+0xd8>
8000ddfa:	dc 2a       	popm	r4-r7,pc,r12=-1
8000ddfc:	d8 2a       	popm	r4-r7,pc,r12=0
8000ddfe:	d7 03       	nop

8000de00 <quorem>:
8000de00:	d4 31       	pushm	r0-r7,lr
8000de02:	20 2d       	sub	sp,8
8000de04:	18 97       	mov	r7,r12
8000de06:	78 48       	ld.w	r8,r12[0x10]
8000de08:	76 46       	ld.w	r6,r11[0x10]
8000de0a:	0c 38       	cp.w	r8,r6
8000de0c:	c0 34       	brge	8000de12 <quorem+0x12>
8000de0e:	30 0c       	mov	r12,0
8000de10:	c8 58       	rjmp	8000df1a <quorem+0x11a>
8000de12:	ec c2 ff fc 	sub	r2,r6,-4
8000de16:	f6 c3 ff ec 	sub	r3,r11,-20
8000de1a:	f6 02 03 29 	ld.w	r9,r11[r2<<0x2]
8000de1e:	f8 02 03 2c 	ld.w	r12,r12[r2<<0x2]
8000de22:	2f f9       	sub	r9,-1
8000de24:	20 16       	sub	r6,1
8000de26:	f8 09 0d 08 	divu	r8,r12,r9
8000de2a:	f6 02 00 22 	add	r2,r11,r2<<0x2
8000de2e:	ee c4 ff ec 	sub	r4,r7,-20
8000de32:	10 95       	mov	r5,r8
8000de34:	58 08       	cp.w	r8,0
8000de36:	c4 10       	breq	8000deb8 <quorem+0xb8>
8000de38:	30 09       	mov	r9,0
8000de3a:	06 9a       	mov	r10,r3
8000de3c:	08 98       	mov	r8,r4
8000de3e:	12 91       	mov	r1,r9
8000de40:	50 0b       	stdsp	sp[0x0],r11
8000de42:	70 0e       	ld.w	lr,r8[0x0]
8000de44:	b1 8e       	lsr	lr,0x10
8000de46:	50 1e       	stdsp	sp[0x4],lr
8000de48:	15 0e       	ld.w	lr,r10++
8000de4a:	fc 00 16 10 	lsr	r0,lr,0x10
8000de4e:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000de52:	ea 0e 03 41 	mac	r1,r5,lr
8000de56:	fd d1 c0 10 	bfextu	lr,r1,0x0,0x10
8000de5a:	b1 81       	lsr	r1,0x10
8000de5c:	40 1b       	lddsp	r11,sp[0x4]
8000de5e:	ea 00 02 40 	mul	r0,r5,r0
8000de62:	e2 00 00 00 	add	r0,r1,r0
8000de66:	e3 d0 c0 10 	bfextu	r1,r0,0x0,0x10
8000de6a:	02 1b       	sub	r11,r1
8000de6c:	50 1b       	stdsp	sp[0x4],r11
8000de6e:	70 0b       	ld.w	r11,r8[0x0]
8000de70:	e3 db c0 10 	bfextu	r1,r11,0x0,0x10
8000de74:	02 09       	add	r9,r1
8000de76:	f2 0e 01 0e 	sub	lr,r9,lr
8000de7a:	b0 1e       	st.h	r8[0x2],lr
8000de7c:	fc 09 14 10 	asr	r9,lr,0x10
8000de80:	40 1e       	lddsp	lr,sp[0x4]
8000de82:	fc 09 00 09 	add	r9,lr,r9
8000de86:	b0 09       	st.h	r8[0x0],r9
8000de88:	e0 01 16 10 	lsr	r1,r0,0x10
8000de8c:	2f c8       	sub	r8,-4
8000de8e:	b1 49       	asr	r9,0x10
8000de90:	04 3a       	cp.w	r10,r2
8000de92:	fe 98 ff d8 	brls	8000de42 <quorem+0x42>
8000de96:	40 0b       	lddsp	r11,sp[0x0]
8000de98:	58 0c       	cp.w	r12,0
8000de9a:	c0 f1       	brne	8000deb8 <quorem+0xb8>
8000de9c:	ec c8 ff fb 	sub	r8,r6,-5
8000dea0:	ee 08 00 28 	add	r8,r7,r8<<0x2
8000dea4:	c0 28       	rjmp	8000dea8 <quorem+0xa8>
8000dea6:	20 16       	sub	r6,1
8000dea8:	20 48       	sub	r8,4
8000deaa:	08 38       	cp.w	r8,r4
8000deac:	e0 88 00 05 	brls	8000deb6 <quorem+0xb6>
8000deb0:	70 09       	ld.w	r9,r8[0x0]
8000deb2:	58 09       	cp.w	r9,0
8000deb4:	cf 90       	breq	8000dea6 <quorem+0xa6>
8000deb6:	8f 46       	st.w	r7[0x10],r6
8000deb8:	0e 9c       	mov	r12,r7
8000deba:	e0 a0 0a d2 	rcall	8000f45e <__mcmp>
8000debe:	c2 d5       	brlt	8000df18 <quorem+0x118>
8000dec0:	2f f5       	sub	r5,-1
8000dec2:	08 98       	mov	r8,r4
8000dec4:	30 09       	mov	r9,0
8000dec6:	07 0b       	ld.w	r11,r3++
8000dec8:	f6 0a 16 10 	lsr	r10,r11,0x10
8000decc:	70 0c       	ld.w	r12,r8[0x0]
8000dece:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000ded2:	f8 0e 16 10 	lsr	lr,r12,0x10
8000ded6:	14 1e       	sub	lr,r10
8000ded8:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000dedc:	16 1a       	sub	r10,r11
8000dede:	12 0a       	add	r10,r9
8000dee0:	b0 1a       	st.h	r8[0x2],r10
8000dee2:	b1 4a       	asr	r10,0x10
8000dee4:	fc 0a 00 09 	add	r9,lr,r10
8000dee8:	b0 09       	st.h	r8[0x0],r9
8000deea:	2f c8       	sub	r8,-4
8000deec:	b1 49       	asr	r9,0x10
8000deee:	04 33       	cp.w	r3,r2
8000def0:	fe 98 ff eb 	brls	8000dec6 <quorem+0xc6>
8000def4:	ec c8 ff fb 	sub	r8,r6,-5
8000def8:	ee 08 03 29 	ld.w	r9,r7[r8<<0x2]
8000defc:	58 09       	cp.w	r9,0
8000defe:	c0 d1       	brne	8000df18 <quorem+0x118>
8000df00:	ee 08 00 28 	add	r8,r7,r8<<0x2
8000df04:	c0 28       	rjmp	8000df08 <quorem+0x108>
8000df06:	20 16       	sub	r6,1
8000df08:	20 48       	sub	r8,4
8000df0a:	08 38       	cp.w	r8,r4
8000df0c:	e0 88 00 05 	brls	8000df16 <quorem+0x116>
8000df10:	70 09       	ld.w	r9,r8[0x0]
8000df12:	58 09       	cp.w	r9,0
8000df14:	cf 90       	breq	8000df06 <quorem+0x106>
8000df16:	8f 46       	st.w	r7[0x10],r6
8000df18:	0a 9c       	mov	r12,r5
8000df1a:	2f ed       	sub	sp,-8
8000df1c:	d8 32       	popm	r0-r7,pc
8000df1e:	d7 03       	nop

8000df20 <_dtoa_r>:
8000df20:	d4 31       	pushm	r0-r7,lr
8000df22:	21 ad       	sub	sp,104
8000df24:	fa c4 ff 74 	sub	r4,sp,-140
8000df28:	18 97       	mov	r7,r12
8000df2a:	16 95       	mov	r5,r11
8000df2c:	68 2c       	ld.w	r12,r4[0x8]
8000df2e:	50 c9       	stdsp	sp[0x30],r9
8000df30:	68 16       	ld.w	r6,r4[0x4]
8000df32:	68 09       	ld.w	r9,r4[0x0]
8000df34:	50 e8       	stdsp	sp[0x38],r8
8000df36:	14 94       	mov	r4,r10
8000df38:	51 2c       	stdsp	sp[0x48],r12
8000df3a:	fa e5 00 08 	st.d	sp[8],r4
8000df3e:	51 59       	stdsp	sp[0x54],r9
8000df40:	6e 95       	ld.w	r5,r7[0x24]
8000df42:	58 05       	cp.w	r5,0
8000df44:	c0 91       	brne	8000df56 <_dtoa_r+0x36>
8000df46:	31 0c       	mov	r12,16
8000df48:	fe b0 e8 d6 	rcall	8000b0f4 <malloc>
8000df4c:	99 35       	st.w	r12[0xc],r5
8000df4e:	8f 9c       	st.w	r7[0x24],r12
8000df50:	99 15       	st.w	r12[0x4],r5
8000df52:	99 25       	st.w	r12[0x8],r5
8000df54:	99 05       	st.w	r12[0x0],r5
8000df56:	6e 99       	ld.w	r9,r7[0x24]
8000df58:	72 08       	ld.w	r8,r9[0x0]
8000df5a:	58 08       	cp.w	r8,0
8000df5c:	c0 f0       	breq	8000df7a <_dtoa_r+0x5a>
8000df5e:	72 1a       	ld.w	r10,r9[0x4]
8000df60:	91 1a       	st.w	r8[0x4],r10
8000df62:	30 1a       	mov	r10,1
8000df64:	72 19       	ld.w	r9,r9[0x4]
8000df66:	f4 09 09 49 	lsl	r9,r10,r9
8000df6a:	10 9b       	mov	r11,r8
8000df6c:	91 29       	st.w	r8[0x8],r9
8000df6e:	0e 9c       	mov	r12,r7
8000df70:	e0 a0 0a 90 	rcall	8000f490 <_Bfree>
8000df74:	6e 98       	ld.w	r8,r7[0x24]
8000df76:	30 09       	mov	r9,0
8000df78:	91 09       	st.w	r8[0x0],r9
8000df7a:	40 28       	lddsp	r8,sp[0x8]
8000df7c:	10 94       	mov	r4,r8
8000df7e:	58 08       	cp.w	r8,0
8000df80:	c0 64       	brge	8000df8c <_dtoa_r+0x6c>
8000df82:	f1 d8 c0 1f 	bfextu	r8,r8,0x0,0x1f
8000df86:	50 28       	stdsp	sp[0x8],r8
8000df88:	30 18       	mov	r8,1
8000df8a:	c0 28       	rjmp	8000df8e <_dtoa_r+0x6e>
8000df8c:	30 08       	mov	r8,0
8000df8e:	8d 08       	st.w	r6[0x0],r8
8000df90:	fc 1c 7f f0 	movh	r12,0x7ff0
8000df94:	40 26       	lddsp	r6,sp[0x8]
8000df96:	0c 98       	mov	r8,r6
8000df98:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000df9c:	18 38       	cp.w	r8,r12
8000df9e:	c2 01       	brne	8000dfde <_dtoa_r+0xbe>
8000dfa0:	e0 68 27 0f 	mov	r8,9999
8000dfa4:	41 5b       	lddsp	r11,sp[0x54]
8000dfa6:	97 08       	st.w	r11[0x0],r8
8000dfa8:	40 3a       	lddsp	r10,sp[0xc]
8000dfaa:	58 0a       	cp.w	r10,0
8000dfac:	c0 71       	brne	8000dfba <_dtoa_r+0x9a>
8000dfae:	ed d6 c0 14 	bfextu	r6,r6,0x0,0x14
8000dfb2:	c0 41       	brne	8000dfba <_dtoa_r+0x9a>
8000dfb4:	fe cc c6 1c 	sub	r12,pc,-14820
8000dfb8:	c0 38       	rjmp	8000dfbe <_dtoa_r+0x9e>
8000dfba:	fe cc c6 16 	sub	r12,pc,-14826
8000dfbe:	41 29       	lddsp	r9,sp[0x48]
8000dfc0:	58 09       	cp.w	r9,0
8000dfc2:	e0 80 05 9a 	breq	8000eaf6 <_dtoa_r+0xbd6>
8000dfc6:	f8 c8 ff fd 	sub	r8,r12,-3
8000dfca:	f8 c9 ff f8 	sub	r9,r12,-8
8000dfce:	11 8b       	ld.ub	r11,r8[0x0]
8000dfd0:	30 0a       	mov	r10,0
8000dfd2:	41 25       	lddsp	r5,sp[0x48]
8000dfd4:	f4 0b 18 00 	cp.b	r11,r10
8000dfd8:	f2 08 17 10 	movne	r8,r9
8000dfdc:	c1 68       	rjmp	8000e008 <_dtoa_r+0xe8>
8000dfde:	fa ea 00 08 	ld.d	r10,sp[8]
8000dfe2:	30 08       	mov	r8,0
8000dfe4:	fa eb 00 3c 	st.d	sp[60],r10
8000dfe8:	30 09       	mov	r9,0
8000dfea:	e0 a0 10 c2 	rcall	8001016e <__avr32_f64_cmp_eq>
8000dfee:	c1 00       	breq	8000e00e <_dtoa_r+0xee>
8000dff0:	30 18       	mov	r8,1
8000dff2:	41 5a       	lddsp	r10,sp[0x54]
8000dff4:	95 08       	st.w	r10[0x0],r8
8000dff6:	fe cc c7 82 	sub	r12,pc,-14462
8000dffa:	41 29       	lddsp	r9,sp[0x48]
8000dffc:	f8 08 00 08 	add	r8,r12,r8
8000e000:	58 09       	cp.w	r9,0
8000e002:	e0 80 05 7a 	breq	8000eaf6 <_dtoa_r+0xbd6>
8000e006:	12 95       	mov	r5,r9
8000e008:	8b 08       	st.w	r5[0x0],r8
8000e00a:	e0 8f 05 76 	bral	8000eaf6 <_dtoa_r+0xbd6>
8000e00e:	fa c8 ff 9c 	sub	r8,sp,-100
8000e012:	fa c9 ff a0 	sub	r9,sp,-96
8000e016:	fa ea 00 3c 	ld.d	r10,sp[60]
8000e01a:	0e 9c       	mov	r12,r7
8000e01c:	eb d6 c2 8b 	bfextu	r5,r6,0x14,0xb
8000e020:	e0 a0 0a 8a 	rcall	8000f534 <__d2b>
8000e024:	18 93       	mov	r3,r12
8000e026:	58 05       	cp.w	r5,0
8000e028:	c0 d0       	breq	8000e042 <_dtoa_r+0x122>
8000e02a:	fa ea 00 3c 	ld.d	r10,sp[60]
8000e02e:	30 04       	mov	r4,0
8000e030:	f1 db c0 14 	bfextu	r8,r11,0x0,0x14
8000e034:	ea c5 03 ff 	sub	r5,r5,1023
8000e038:	10 9b       	mov	r11,r8
8000e03a:	51 74       	stdsp	sp[0x5c],r4
8000e03c:	ea 1b 3f f0 	orh	r11,0x3ff0
8000e040:	c2 58       	rjmp	8000e08a <_dtoa_r+0x16a>
8000e042:	41 88       	lddsp	r8,sp[0x60]
8000e044:	41 9c       	lddsp	r12,sp[0x64]
8000e046:	10 0c       	add	r12,r8
8000e048:	f8 c5 fb ce 	sub	r5,r12,-1074
8000e04c:	e0 45 00 20 	cp.w	r5,32
8000e050:	e0 8a 00 0e 	brle	8000e06c <_dtoa_r+0x14c>
8000e054:	f8 cc fb ee 	sub	r12,r12,-1042
8000e058:	40 3b       	lddsp	r11,sp[0xc]
8000e05a:	ea 08 11 40 	rsub	r8,r5,64
8000e05e:	f6 0c 0a 4c 	lsr	r12,r11,r12
8000e062:	ec 08 09 46 	lsl	r6,r6,r8
8000e066:	0c 4c       	or	r12,r6
8000e068:	c0 78       	rjmp	8000e076 <_dtoa_r+0x156>
8000e06a:	d7 03       	nop
8000e06c:	ea 0c 11 20 	rsub	r12,r5,32
8000e070:	40 3a       	lddsp	r10,sp[0xc]
8000e072:	f4 0c 09 4c 	lsl	r12,r10,r12
8000e076:	e0 a0 10 08 	rcall	80010086 <__avr32_u32_to_f64>
8000e07a:	fc 18 fe 10 	movh	r8,0xfe10
8000e07e:	30 19       	mov	r9,1
8000e080:	ea c5 04 33 	sub	r5,r5,1075
8000e084:	f0 0b 00 0b 	add	r11,r8,r11
8000e088:	51 79       	stdsp	sp[0x5c],r9
8000e08a:	30 08       	mov	r8,0
8000e08c:	fc 19 3f f8 	movh	r9,0x3ff8
8000e090:	e0 a0 0e 90 	rcall	8000fdb0 <__avr32_f64_sub>
8000e094:	e0 68 43 61 	mov	r8,17249
8000e098:	ea 18 63 6f 	orh	r8,0x636f
8000e09c:	e0 69 87 a7 	mov	r9,34727
8000e0a0:	ea 19 3f d2 	orh	r9,0x3fd2
8000e0a4:	e0 a0 0d 9a 	rcall	8000fbd8 <__avr32_f64_mul>
8000e0a8:	e0 68 c8 b3 	mov	r8,51379
8000e0ac:	ea 18 8b 60 	orh	r8,0x8b60
8000e0b0:	e0 69 8a 28 	mov	r9,35368
8000e0b4:	ea 19 3f c6 	orh	r9,0x3fc6
8000e0b8:	e0 a0 0f 4a 	rcall	8000ff4c <__avr32_f64_add>
8000e0bc:	0a 9c       	mov	r12,r5
8000e0be:	14 90       	mov	r0,r10
8000e0c0:	16 91       	mov	r1,r11
8000e0c2:	e0 a0 0f e6 	rcall	8001008e <__avr32_s32_to_f64>
8000e0c6:	e0 68 79 fb 	mov	r8,31227
8000e0ca:	ea 18 50 9f 	orh	r8,0x509f
8000e0ce:	e0 69 44 13 	mov	r9,17427
8000e0d2:	ea 19 3f d3 	orh	r9,0x3fd3
8000e0d6:	e0 a0 0d 81 	rcall	8000fbd8 <__avr32_f64_mul>
8000e0da:	14 98       	mov	r8,r10
8000e0dc:	16 99       	mov	r9,r11
8000e0de:	00 9a       	mov	r10,r0
8000e0e0:	02 9b       	mov	r11,r1
8000e0e2:	e0 a0 0f 35 	rcall	8000ff4c <__avr32_f64_add>
8000e0e6:	14 90       	mov	r0,r10
8000e0e8:	16 91       	mov	r1,r11
8000e0ea:	e0 a0 0f bb 	rcall	80010060 <__avr32_f64_to_s32>
8000e0ee:	30 08       	mov	r8,0
8000e0f0:	18 96       	mov	r6,r12
8000e0f2:	30 09       	mov	r9,0
8000e0f4:	00 9a       	mov	r10,r0
8000e0f6:	02 9b       	mov	r11,r1
8000e0f8:	e0 a0 10 82 	rcall	800101fc <__avr32_f64_cmp_lt>
8000e0fc:	c0 c0       	breq	8000e114 <_dtoa_r+0x1f4>
8000e0fe:	0c 9c       	mov	r12,r6
8000e100:	e0 a0 0f c7 	rcall	8001008e <__avr32_s32_to_f64>
8000e104:	14 98       	mov	r8,r10
8000e106:	16 99       	mov	r9,r11
8000e108:	00 9a       	mov	r10,r0
8000e10a:	02 9b       	mov	r11,r1
8000e10c:	e0 a0 10 31 	rcall	8001016e <__avr32_f64_cmp_eq>
8000e110:	f7 b6 00 01 	subeq	r6,1
8000e114:	59 66       	cp.w	r6,22
8000e116:	e0 88 00 05 	brls	8000e120 <_dtoa_r+0x200>
8000e11a:	30 18       	mov	r8,1
8000e11c:	51 48       	stdsp	sp[0x50],r8
8000e11e:	c1 38       	rjmp	8000e144 <_dtoa_r+0x224>
8000e120:	fe c8 c6 c4 	sub	r8,pc,-14652
8000e124:	fa ea 00 3c 	ld.d	r10,sp[60]
8000e128:	f0 06 02 38 	ld.d	r8,r8[r6<<0x3]
8000e12c:	e0 a0 10 68 	rcall	800101fc <__avr32_f64_cmp_lt>
8000e130:	f9 b4 00 00 	moveq	r4,0
8000e134:	fb f4 0a 14 	st.weq	sp[0x50],r4
8000e138:	f7 b6 01 01 	subne	r6,1
8000e13c:	f9 bc 01 00 	movne	r12,0
8000e140:	fb fc 1a 14 	st.wne	sp[0x50],r12
8000e144:	41 90       	lddsp	r0,sp[0x64]
8000e146:	20 10       	sub	r0,1
8000e148:	0a 10       	sub	r0,r5
8000e14a:	c0 46       	brmi	8000e152 <_dtoa_r+0x232>
8000e14c:	50 40       	stdsp	sp[0x10],r0
8000e14e:	30 00       	mov	r0,0
8000e150:	c0 48       	rjmp	8000e158 <_dtoa_r+0x238>
8000e152:	30 0b       	mov	r11,0
8000e154:	5c 30       	neg	r0
8000e156:	50 4b       	stdsp	sp[0x10],r11
8000e158:	ec 02 11 00 	rsub	r2,r6,0
8000e15c:	58 06       	cp.w	r6,0
8000e15e:	fb fa 40 04 	ld.wge	r10,sp[0x10]
8000e162:	f5 d6 e4 0a 	addge	r10,r10,r6
8000e166:	fb fa 4a 04 	st.wge	sp[0x10],r10
8000e16a:	fb f6 4a 11 	st.wge	sp[0x44],r6
8000e16e:	f9 b2 04 00 	movge	r2,0
8000e172:	e1 d6 e5 10 	sublt	r0,r0,r6
8000e176:	f9 b9 05 00 	movlt	r9,0
8000e17a:	fb f9 5a 11 	st.wlt	sp[0x44],r9
8000e17e:	40 c8       	lddsp	r8,sp[0x30]
8000e180:	58 98       	cp.w	r8,9
8000e182:	e0 8b 00 20 	brhi	8000e1c2 <_dtoa_r+0x2a2>
8000e186:	58 58       	cp.w	r8,5
8000e188:	f9 b4 0a 01 	movle	r4,1
8000e18c:	fb f5 90 0c 	ld.wgt	r5,sp[0x30]
8000e190:	f7 b5 09 04 	subgt	r5,4
8000e194:	fb f5 9a 0c 	st.wgt	sp[0x30],r5
8000e198:	f9 b4 09 00 	movgt	r4,0
8000e19c:	40 cc       	lddsp	r12,sp[0x30]
8000e19e:	58 3c       	cp.w	r12,3
8000e1a0:	c2 d0       	breq	8000e1fa <_dtoa_r+0x2da>
8000e1a2:	e0 89 00 05 	brgt	8000e1ac <_dtoa_r+0x28c>
8000e1a6:	58 2c       	cp.w	r12,2
8000e1a8:	c1 01       	brne	8000e1c8 <_dtoa_r+0x2a8>
8000e1aa:	c1 88       	rjmp	8000e1da <_dtoa_r+0x2ba>
8000e1ac:	40 cb       	lddsp	r11,sp[0x30]
8000e1ae:	58 4b       	cp.w	r11,4
8000e1b0:	c0 60       	breq	8000e1bc <_dtoa_r+0x29c>
8000e1b2:	58 5b       	cp.w	r11,5
8000e1b4:	c0 a1       	brne	8000e1c8 <_dtoa_r+0x2a8>
8000e1b6:	30 1a       	mov	r10,1
8000e1b8:	50 da       	stdsp	sp[0x34],r10
8000e1ba:	c2 28       	rjmp	8000e1fe <_dtoa_r+0x2de>
8000e1bc:	30 19       	mov	r9,1
8000e1be:	50 d9       	stdsp	sp[0x34],r9
8000e1c0:	c0 f8       	rjmp	8000e1de <_dtoa_r+0x2be>
8000e1c2:	30 08       	mov	r8,0
8000e1c4:	30 14       	mov	r4,1
8000e1c6:	50 c8       	stdsp	sp[0x30],r8
8000e1c8:	3f f5       	mov	r5,-1
8000e1ca:	30 1c       	mov	r12,1
8000e1cc:	30 0b       	mov	r11,0
8000e1ce:	50 95       	stdsp	sp[0x24],r5
8000e1d0:	50 dc       	stdsp	sp[0x34],r12
8000e1d2:	0a 91       	mov	r1,r5
8000e1d4:	31 28       	mov	r8,18
8000e1d6:	50 eb       	stdsp	sp[0x38],r11
8000e1d8:	c2 08       	rjmp	8000e218 <_dtoa_r+0x2f8>
8000e1da:	30 0a       	mov	r10,0
8000e1dc:	50 da       	stdsp	sp[0x34],r10
8000e1de:	40 e9       	lddsp	r9,sp[0x38]
8000e1e0:	58 09       	cp.w	r9,0
8000e1e2:	e0 89 00 07 	brgt	8000e1f0 <_dtoa_r+0x2d0>
8000e1e6:	30 18       	mov	r8,1
8000e1e8:	50 98       	stdsp	sp[0x24],r8
8000e1ea:	10 91       	mov	r1,r8
8000e1ec:	50 e8       	stdsp	sp[0x38],r8
8000e1ee:	c1 58       	rjmp	8000e218 <_dtoa_r+0x2f8>
8000e1f0:	40 e5       	lddsp	r5,sp[0x38]
8000e1f2:	50 95       	stdsp	sp[0x24],r5
8000e1f4:	0a 91       	mov	r1,r5
8000e1f6:	0a 98       	mov	r8,r5
8000e1f8:	c1 08       	rjmp	8000e218 <_dtoa_r+0x2f8>
8000e1fa:	30 0c       	mov	r12,0
8000e1fc:	50 dc       	stdsp	sp[0x34],r12
8000e1fe:	40 eb       	lddsp	r11,sp[0x38]
8000e200:	ec 0b 00 0b 	add	r11,r6,r11
8000e204:	50 9b       	stdsp	sp[0x24],r11
8000e206:	16 98       	mov	r8,r11
8000e208:	2f f8       	sub	r8,-1
8000e20a:	58 08       	cp.w	r8,0
8000e20c:	e0 89 00 05 	brgt	8000e216 <_dtoa_r+0x2f6>
8000e210:	10 91       	mov	r1,r8
8000e212:	30 18       	mov	r8,1
8000e214:	c0 28       	rjmp	8000e218 <_dtoa_r+0x2f8>
8000e216:	10 91       	mov	r1,r8
8000e218:	30 09       	mov	r9,0
8000e21a:	6e 9a       	ld.w	r10,r7[0x24]
8000e21c:	95 19       	st.w	r10[0x4],r9
8000e21e:	30 49       	mov	r9,4
8000e220:	c0 68       	rjmp	8000e22c <_dtoa_r+0x30c>
8000e222:	d7 03       	nop
8000e224:	6a 1a       	ld.w	r10,r5[0x4]
8000e226:	a1 79       	lsl	r9,0x1
8000e228:	2f fa       	sub	r10,-1
8000e22a:	8b 1a       	st.w	r5[0x4],r10
8000e22c:	6e 95       	ld.w	r5,r7[0x24]
8000e22e:	f2 ca ff ec 	sub	r10,r9,-20
8000e232:	10 3a       	cp.w	r10,r8
8000e234:	fe 98 ff f8 	brls	8000e224 <_dtoa_r+0x304>
8000e238:	6a 1b       	ld.w	r11,r5[0x4]
8000e23a:	0e 9c       	mov	r12,r7
8000e23c:	e0 a0 09 44 	rcall	8000f4c4 <_Balloc>
8000e240:	58 e1       	cp.w	r1,14
8000e242:	5f 88       	srls	r8
8000e244:	8b 0c       	st.w	r5[0x0],r12
8000e246:	f1 e4 00 04 	and	r4,r8,r4
8000e24a:	6e 98       	ld.w	r8,r7[0x24]
8000e24c:	70 08       	ld.w	r8,r8[0x0]
8000e24e:	50 88       	stdsp	sp[0x20],r8
8000e250:	e0 80 01 82 	breq	8000e554 <_dtoa_r+0x634>
8000e254:	58 06       	cp.w	r6,0
8000e256:	e0 8a 00 43 	brle	8000e2dc <_dtoa_r+0x3bc>
8000e25a:	f3 d6 c0 04 	bfextu	r9,r6,0x0,0x4
8000e25e:	fe c8 c8 02 	sub	r8,pc,-14334
8000e262:	f0 09 02 34 	ld.d	r4,r8[r9<<0x3]
8000e266:	fa e5 00 18 	st.d	sp[24],r4
8000e26a:	ec 04 14 04 	asr	r4,r6,0x4
8000e26e:	ed b4 00 04 	bld	r4,0x4
8000e272:	c0 30       	breq	8000e278 <_dtoa_r+0x358>
8000e274:	30 25       	mov	r5,2
8000e276:	c1 08       	rjmp	8000e296 <_dtoa_r+0x376>
8000e278:	fe c8 c7 54 	sub	r8,pc,-14508
8000e27c:	f0 e8 00 20 	ld.d	r8,r8[32]
8000e280:	fa ea 00 3c 	ld.d	r10,sp[60]
8000e284:	e9 d4 c0 04 	bfextu	r4,r4,0x0,0x4
8000e288:	e0 a0 0f ee 	rcall	80010264 <__avr32_f64_div>
8000e28c:	30 35       	mov	r5,3
8000e28e:	14 98       	mov	r8,r10
8000e290:	16 99       	mov	r9,r11
8000e292:	fa e9 00 08 	st.d	sp[8],r8
8000e296:	fe cc c7 72 	sub	r12,pc,-14478
8000e29a:	50 a3       	stdsp	sp[0x28],r3
8000e29c:	0c 93       	mov	r3,r6
8000e29e:	18 96       	mov	r6,r12
8000e2a0:	c0 f8       	rjmp	8000e2be <_dtoa_r+0x39e>
8000e2a2:	fa ea 00 18 	ld.d	r10,sp[24]
8000e2a6:	ed b4 00 00 	bld	r4,0x0
8000e2aa:	c0 81       	brne	8000e2ba <_dtoa_r+0x39a>
8000e2ac:	ec e8 00 00 	ld.d	r8,r6[0]
8000e2b0:	2f f5       	sub	r5,-1
8000e2b2:	e0 a0 0c 93 	rcall	8000fbd8 <__avr32_f64_mul>
8000e2b6:	fa eb 00 18 	st.d	sp[24],r10
8000e2ba:	a1 54       	asr	r4,0x1
8000e2bc:	2f 86       	sub	r6,-8
8000e2be:	58 04       	cp.w	r4,0
8000e2c0:	cf 11       	brne	8000e2a2 <_dtoa_r+0x382>
8000e2c2:	fa e8 00 18 	ld.d	r8,sp[24]
8000e2c6:	fa ea 00 08 	ld.d	r10,sp[8]
8000e2ca:	06 96       	mov	r6,r3
8000e2cc:	e0 a0 0f cc 	rcall	80010264 <__avr32_f64_div>
8000e2d0:	40 a3       	lddsp	r3,sp[0x28]
8000e2d2:	14 98       	mov	r8,r10
8000e2d4:	16 99       	mov	r9,r11
8000e2d6:	fa e9 00 08 	st.d	sp[8],r8
8000e2da:	c2 f8       	rjmp	8000e338 <_dtoa_r+0x418>
8000e2dc:	ec 08 11 00 	rsub	r8,r6,0
8000e2e0:	c0 31       	brne	8000e2e6 <_dtoa_r+0x3c6>
8000e2e2:	30 25       	mov	r5,2
8000e2e4:	c2 a8       	rjmp	8000e338 <_dtoa_r+0x418>
8000e2e6:	fe cc c7 c2 	sub	r12,pc,-14398
8000e2ea:	f0 04 14 04 	asr	r4,r8,0x4
8000e2ee:	50 1c       	stdsp	sp[0x4],r12
8000e2f0:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
8000e2f4:	fe c9 c8 98 	sub	r9,pc,-14184
8000e2f8:	fa ea 00 3c 	ld.d	r10,sp[60]
8000e2fc:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000e300:	e0 a0 0c 6c 	rcall	8000fbd8 <__avr32_f64_mul>
8000e304:	40 1c       	lddsp	r12,sp[0x4]
8000e306:	50 63       	stdsp	sp[0x18],r3
8000e308:	30 25       	mov	r5,2
8000e30a:	0c 93       	mov	r3,r6
8000e30c:	fa eb 00 08 	st.d	sp[8],r10
8000e310:	18 96       	mov	r6,r12
8000e312:	c0 f8       	rjmp	8000e330 <_dtoa_r+0x410>
8000e314:	fa ea 00 08 	ld.d	r10,sp[8]
8000e318:	ed b4 00 00 	bld	r4,0x0
8000e31c:	c0 81       	brne	8000e32c <_dtoa_r+0x40c>
8000e31e:	ec e8 00 00 	ld.d	r8,r6[0]
8000e322:	2f f5       	sub	r5,-1
8000e324:	e0 a0 0c 5a 	rcall	8000fbd8 <__avr32_f64_mul>
8000e328:	fa eb 00 08 	st.d	sp[8],r10
8000e32c:	a1 54       	asr	r4,0x1
8000e32e:	2f 86       	sub	r6,-8
8000e330:	58 04       	cp.w	r4,0
8000e332:	cf 11       	brne	8000e314 <_dtoa_r+0x3f4>
8000e334:	06 96       	mov	r6,r3
8000e336:	40 63       	lddsp	r3,sp[0x18]
8000e338:	41 4a       	lddsp	r10,sp[0x50]
8000e33a:	58 0a       	cp.w	r10,0
8000e33c:	c2 a0       	breq	8000e390 <_dtoa_r+0x470>
8000e33e:	fa e8 00 08 	ld.d	r8,sp[8]
8000e342:	58 01       	cp.w	r1,0
8000e344:	5f 94       	srgt	r4
8000e346:	fa e9 00 18 	st.d	sp[24],r8
8000e34a:	30 08       	mov	r8,0
8000e34c:	fc 19 3f f0 	movh	r9,0x3ff0
8000e350:	fa ea 00 18 	ld.d	r10,sp[24]
8000e354:	e0 a0 0f 54 	rcall	800101fc <__avr32_f64_cmp_lt>
8000e358:	f9 bc 00 00 	moveq	r12,0
8000e35c:	f9 bc 01 01 	movne	r12,1
8000e360:	e9 ec 00 0c 	and	r12,r4,r12
8000e364:	c1 60       	breq	8000e390 <_dtoa_r+0x470>
8000e366:	40 98       	lddsp	r8,sp[0x24]
8000e368:	58 08       	cp.w	r8,0
8000e36a:	e0 8a 00 f1 	brle	8000e54c <_dtoa_r+0x62c>
8000e36e:	30 08       	mov	r8,0
8000e370:	fc 19 40 24 	movh	r9,0x4024
8000e374:	ec c4 00 01 	sub	r4,r6,1
8000e378:	fa ea 00 18 	ld.d	r10,sp[24]
8000e37c:	2f f5       	sub	r5,-1
8000e37e:	50 64       	stdsp	sp[0x18],r4
8000e380:	e0 a0 0c 2c 	rcall	8000fbd8 <__avr32_f64_mul>
8000e384:	40 94       	lddsp	r4,sp[0x24]
8000e386:	14 98       	mov	r8,r10
8000e388:	16 99       	mov	r9,r11
8000e38a:	fa e9 00 08 	st.d	sp[8],r8
8000e38e:	c0 38       	rjmp	8000e394 <_dtoa_r+0x474>
8000e390:	50 66       	stdsp	sp[0x18],r6
8000e392:	02 94       	mov	r4,r1
8000e394:	0a 9c       	mov	r12,r5
8000e396:	e0 a0 0e 7c 	rcall	8001008e <__avr32_s32_to_f64>
8000e39a:	fa e8 00 08 	ld.d	r8,sp[8]
8000e39e:	e0 a0 0c 1d 	rcall	8000fbd8 <__avr32_f64_mul>
8000e3a2:	30 08       	mov	r8,0
8000e3a4:	fc 19 40 1c 	movh	r9,0x401c
8000e3a8:	e0 a0 0d d2 	rcall	8000ff4c <__avr32_f64_add>
8000e3ac:	14 98       	mov	r8,r10
8000e3ae:	16 99       	mov	r9,r11
8000e3b0:	fa e9 00 28 	st.d	sp[40],r8
8000e3b4:	fc 18 fc c0 	movh	r8,0xfcc0
8000e3b8:	40 a5       	lddsp	r5,sp[0x28]
8000e3ba:	10 05       	add	r5,r8
8000e3bc:	50 a5       	stdsp	sp[0x28],r5
8000e3be:	58 04       	cp.w	r4,0
8000e3c0:	c2 11       	brne	8000e402 <_dtoa_r+0x4e2>
8000e3c2:	fa ea 00 08 	ld.d	r10,sp[8]
8000e3c6:	30 08       	mov	r8,0
8000e3c8:	fc 19 40 14 	movh	r9,0x4014
8000e3cc:	e0 a0 0c f2 	rcall	8000fdb0 <__avr32_f64_sub>
8000e3d0:	40 bc       	lddsp	r12,sp[0x2c]
8000e3d2:	fa eb 00 08 	st.d	sp[8],r10
8000e3d6:	14 98       	mov	r8,r10
8000e3d8:	16 99       	mov	r9,r11
8000e3da:	18 9a       	mov	r10,r12
8000e3dc:	0a 9b       	mov	r11,r5
8000e3de:	e0 a0 0f 0f 	rcall	800101fc <__avr32_f64_cmp_lt>
8000e3e2:	e0 81 02 54 	brne	8000e88a <_dtoa_r+0x96a>
8000e3e6:	0a 98       	mov	r8,r5
8000e3e8:	40 b9       	lddsp	r9,sp[0x2c]
8000e3ea:	ee 18 80 00 	eorh	r8,0x8000
8000e3ee:	fa ea 00 08 	ld.d	r10,sp[8]
8000e3f2:	10 95       	mov	r5,r8
8000e3f4:	12 98       	mov	r8,r9
8000e3f6:	0a 99       	mov	r9,r5
8000e3f8:	e0 a0 0f 02 	rcall	800101fc <__avr32_f64_cmp_lt>
8000e3fc:	e0 81 02 3e 	brne	8000e878 <_dtoa_r+0x958>
8000e400:	ca 68       	rjmp	8000e54c <_dtoa_r+0x62c>
8000e402:	fe c9 c9 a6 	sub	r9,pc,-13914
8000e406:	e8 c8 00 01 	sub	r8,r4,1
8000e40a:	40 d5       	lddsp	r5,sp[0x34]
8000e40c:	58 05       	cp.w	r5,0
8000e40e:	c4 f0       	breq	8000e4ac <_dtoa_r+0x58c>
8000e410:	30 0c       	mov	r12,0
8000e412:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000e416:	51 3c       	stdsp	sp[0x4c],r12
8000e418:	30 0a       	mov	r10,0
8000e41a:	fc 1b 3f e0 	movh	r11,0x3fe0
8000e41e:	e0 a0 0f 23 	rcall	80010264 <__avr32_f64_div>
8000e422:	fa e8 00 28 	ld.d	r8,sp[40]
8000e426:	40 85       	lddsp	r5,sp[0x20]
8000e428:	e0 a0 0c c4 	rcall	8000fdb0 <__avr32_f64_sub>
8000e42c:	fa eb 00 28 	st.d	sp[40],r10
8000e430:	fa ea 00 08 	ld.d	r10,sp[8]
8000e434:	e0 a0 0e 16 	rcall	80010060 <__avr32_f64_to_s32>
8000e438:	51 6c       	stdsp	sp[0x58],r12
8000e43a:	e0 a0 0e 2a 	rcall	8001008e <__avr32_s32_to_f64>
8000e43e:	14 98       	mov	r8,r10
8000e440:	16 99       	mov	r9,r11
8000e442:	fa ea 00 08 	ld.d	r10,sp[8]
8000e446:	e0 a0 0c b5 	rcall	8000fdb0 <__avr32_f64_sub>
8000e44a:	fa eb 00 08 	st.d	sp[8],r10
8000e44e:	41 68       	lddsp	r8,sp[0x58]
8000e450:	2d 08       	sub	r8,-48
8000e452:	0a c8       	st.b	r5++,r8
8000e454:	41 39       	lddsp	r9,sp[0x4c]
8000e456:	2f f9       	sub	r9,-1
8000e458:	51 39       	stdsp	sp[0x4c],r9
8000e45a:	fa e8 00 28 	ld.d	r8,sp[40]
8000e45e:	e0 a0 0e cf 	rcall	800101fc <__avr32_f64_cmp_lt>
8000e462:	e0 81 03 39 	brne	8000ead4 <_dtoa_r+0xbb4>
8000e466:	fa e8 00 08 	ld.d	r8,sp[8]
8000e46a:	30 0a       	mov	r10,0
8000e46c:	fc 1b 3f f0 	movh	r11,0x3ff0
8000e470:	e0 a0 0c a0 	rcall	8000fdb0 <__avr32_f64_sub>
8000e474:	fa e8 00 28 	ld.d	r8,sp[40]
8000e478:	e0 a0 0e c2 	rcall	800101fc <__avr32_f64_cmp_lt>
8000e47c:	fa ea 00 28 	ld.d	r10,sp[40]
8000e480:	30 08       	mov	r8,0
8000e482:	fc 19 40 24 	movh	r9,0x4024
8000e486:	e0 81 00 da 	brne	8000e63a <_dtoa_r+0x71a>
8000e48a:	41 3c       	lddsp	r12,sp[0x4c]
8000e48c:	08 3c       	cp.w	r12,r4
8000e48e:	c5 f4       	brge	8000e54c <_dtoa_r+0x62c>
8000e490:	e0 a0 0b a4 	rcall	8000fbd8 <__avr32_f64_mul>
8000e494:	30 08       	mov	r8,0
8000e496:	fa eb 00 28 	st.d	sp[40],r10
8000e49a:	fc 19 40 24 	movh	r9,0x4024
8000e49e:	fa ea 00 08 	ld.d	r10,sp[8]
8000e4a2:	e0 a0 0b 9b 	rcall	8000fbd8 <__avr32_f64_mul>
8000e4a6:	fa eb 00 08 	st.d	sp[8],r10
8000e4aa:	cc 3b       	rjmp	8000e430 <_dtoa_r+0x510>
8000e4ac:	40 85       	lddsp	r5,sp[0x20]
8000e4ae:	08 05       	add	r5,r4
8000e4b0:	f2 08 02 3a 	ld.d	r10,r9[r8<<0x3]
8000e4b4:	51 35       	stdsp	sp[0x4c],r5
8000e4b6:	fa e8 00 28 	ld.d	r8,sp[40]
8000e4ba:	40 85       	lddsp	r5,sp[0x20]
8000e4bc:	e0 a0 0b 8e 	rcall	8000fbd8 <__avr32_f64_mul>
8000e4c0:	fa eb 00 28 	st.d	sp[40],r10
8000e4c4:	fa ea 00 08 	ld.d	r10,sp[8]
8000e4c8:	e0 a0 0d cc 	rcall	80010060 <__avr32_f64_to_s32>
8000e4cc:	51 6c       	stdsp	sp[0x58],r12
8000e4ce:	e0 a0 0d e0 	rcall	8001008e <__avr32_s32_to_f64>
8000e4d2:	14 98       	mov	r8,r10
8000e4d4:	16 99       	mov	r9,r11
8000e4d6:	fa ea 00 08 	ld.d	r10,sp[8]
8000e4da:	e0 a0 0c 6b 	rcall	8000fdb0 <__avr32_f64_sub>
8000e4de:	fa eb 00 08 	st.d	sp[8],r10
8000e4e2:	41 68       	lddsp	r8,sp[0x58]
8000e4e4:	2d 08       	sub	r8,-48
8000e4e6:	0a c8       	st.b	r5++,r8
8000e4e8:	41 3c       	lddsp	r12,sp[0x4c]
8000e4ea:	18 35       	cp.w	r5,r12
8000e4ec:	c2 81       	brne	8000e53c <_dtoa_r+0x61c>
8000e4ee:	30 08       	mov	r8,0
8000e4f0:	fc 19 3f e0 	movh	r9,0x3fe0
8000e4f4:	fa ea 00 28 	ld.d	r10,sp[40]
8000e4f8:	e0 a0 0d 2a 	rcall	8000ff4c <__avr32_f64_add>
8000e4fc:	40 85       	lddsp	r5,sp[0x20]
8000e4fe:	fa e8 00 08 	ld.d	r8,sp[8]
8000e502:	08 05       	add	r5,r4
8000e504:	e0 a0 0e 7c 	rcall	800101fc <__avr32_f64_cmp_lt>
8000e508:	e0 81 00 99 	brne	8000e63a <_dtoa_r+0x71a>
8000e50c:	fa e8 00 28 	ld.d	r8,sp[40]
8000e510:	30 0a       	mov	r10,0
8000e512:	fc 1b 3f e0 	movh	r11,0x3fe0
8000e516:	e0 a0 0c 4d 	rcall	8000fdb0 <__avr32_f64_sub>
8000e51a:	14 98       	mov	r8,r10
8000e51c:	16 99       	mov	r9,r11
8000e51e:	fa ea 00 08 	ld.d	r10,sp[8]
8000e522:	e0 a0 0e 6d 	rcall	800101fc <__avr32_f64_cmp_lt>
8000e526:	c1 30       	breq	8000e54c <_dtoa_r+0x62c>
8000e528:	33 09       	mov	r9,48
8000e52a:	0a 98       	mov	r8,r5
8000e52c:	11 7a       	ld.ub	r10,--r8
8000e52e:	f2 0a 18 00 	cp.b	r10,r9
8000e532:	e0 81 02 d1 	brne	8000ead4 <_dtoa_r+0xbb4>
8000e536:	10 95       	mov	r5,r8
8000e538:	cf 9b       	rjmp	8000e52a <_dtoa_r+0x60a>
8000e53a:	d7 03       	nop
8000e53c:	30 08       	mov	r8,0
8000e53e:	fc 19 40 24 	movh	r9,0x4024
8000e542:	e0 a0 0b 4b 	rcall	8000fbd8 <__avr32_f64_mul>
8000e546:	fa eb 00 08 	st.d	sp[8],r10
8000e54a:	cb db       	rjmp	8000e4c4 <_dtoa_r+0x5a4>
8000e54c:	fa ea 00 3c 	ld.d	r10,sp[60]
8000e550:	fa eb 00 08 	st.d	sp[8],r10
8000e554:	58 e6       	cp.w	r6,14
8000e556:	5f ab       	srle	r11
8000e558:	41 8a       	lddsp	r10,sp[0x60]
8000e55a:	30 08       	mov	r8,0
8000e55c:	f4 09 11 ff 	rsub	r9,r10,-1
8000e560:	f7 e9 03 f9 	and	r9,r11,r9>>0x1f
8000e564:	f0 09 18 00 	cp.b	r9,r8
8000e568:	e0 80 00 82 	breq	8000e66c <_dtoa_r+0x74c>
8000e56c:	40 ea       	lddsp	r10,sp[0x38]
8000e56e:	58 01       	cp.w	r1,0
8000e570:	5f a9       	srle	r9
8000e572:	f3 ea 03 f9 	and	r9,r9,r10>>0x1f
8000e576:	fe ca cb 1a 	sub	r10,pc,-13542
8000e57a:	f4 06 02 34 	ld.d	r4,r10[r6<<0x3]
8000e57e:	fa e5 00 10 	st.d	sp[16],r4
8000e582:	f0 09 18 00 	cp.b	r9,r8
8000e586:	c1 40       	breq	8000e5ae <_dtoa_r+0x68e>
8000e588:	58 01       	cp.w	r1,0
8000e58a:	e0 81 01 77 	brne	8000e878 <_dtoa_r+0x958>
8000e58e:	30 08       	mov	r8,0
8000e590:	fc 19 40 14 	movh	r9,0x4014
8000e594:	08 9a       	mov	r10,r4
8000e596:	0a 9b       	mov	r11,r5
8000e598:	e0 a0 0b 20 	rcall	8000fbd8 <__avr32_f64_mul>
8000e59c:	fa e8 00 08 	ld.d	r8,sp[8]
8000e5a0:	e0 a0 0d fa 	rcall	80010194 <__avr32_f64_cmp_ge>
8000e5a4:	e0 81 01 6a 	brne	8000e878 <_dtoa_r+0x958>
8000e5a8:	02 92       	mov	r2,r1
8000e5aa:	e0 8f 01 72 	bral	8000e88e <_dtoa_r+0x96e>
8000e5ae:	40 85       	lddsp	r5,sp[0x20]
8000e5b0:	30 14       	mov	r4,1
8000e5b2:	fa e8 00 10 	ld.d	r8,sp[16]
8000e5b6:	fa ea 00 08 	ld.d	r10,sp[8]
8000e5ba:	e0 a0 0e 55 	rcall	80010264 <__avr32_f64_div>
8000e5be:	e0 a0 0d 51 	rcall	80010060 <__avr32_f64_to_s32>
8000e5c2:	18 92       	mov	r2,r12
8000e5c4:	e0 a0 0d 65 	rcall	8001008e <__avr32_s32_to_f64>
8000e5c8:	fa e8 00 10 	ld.d	r8,sp[16]
8000e5cc:	e0 a0 0b 06 	rcall	8000fbd8 <__avr32_f64_mul>
8000e5d0:	14 98       	mov	r8,r10
8000e5d2:	16 99       	mov	r9,r11
8000e5d4:	fa ea 00 08 	ld.d	r10,sp[8]
8000e5d8:	e0 a0 0b ec 	rcall	8000fdb0 <__avr32_f64_sub>
8000e5dc:	fa eb 00 08 	st.d	sp[8],r10
8000e5e0:	e4 c8 ff d0 	sub	r8,r2,-48
8000e5e4:	0a c8       	st.b	r5++,r8
8000e5e6:	fc 19 40 24 	movh	r9,0x4024
8000e5ea:	30 08       	mov	r8,0
8000e5ec:	02 34       	cp.w	r4,r1
8000e5ee:	c3 31       	brne	8000e654 <_dtoa_r+0x734>
8000e5f0:	fa e8 00 08 	ld.d	r8,sp[8]
8000e5f4:	e0 a0 0c ac 	rcall	8000ff4c <__avr32_f64_add>
8000e5f8:	16 91       	mov	r1,r11
8000e5fa:	14 90       	mov	r0,r10
8000e5fc:	14 98       	mov	r8,r10
8000e5fe:	02 99       	mov	r9,r1
8000e600:	fa ea 00 10 	ld.d	r10,sp[16]
8000e604:	e0 a0 0d fc 	rcall	800101fc <__avr32_f64_cmp_lt>
8000e608:	c1 a1       	brne	8000e63c <_dtoa_r+0x71c>
8000e60a:	fa e8 00 10 	ld.d	r8,sp[16]
8000e60e:	00 9a       	mov	r10,r0
8000e610:	02 9b       	mov	r11,r1
8000e612:	e0 a0 0d ae 	rcall	8001016e <__avr32_f64_cmp_eq>
8000e616:	e0 80 02 5e 	breq	8000ead2 <_dtoa_r+0xbb2>
8000e61a:	e5 d2 c0 01 	bfextu	r2,r2,0x0,0x1
8000e61e:	c0 f1       	brne	8000e63c <_dtoa_r+0x71c>
8000e620:	e0 8f 02 59 	bral	8000ead2 <_dtoa_r+0xbb2>
8000e624:	40 8a       	lddsp	r10,sp[0x20]
8000e626:	14 38       	cp.w	r8,r10
8000e628:	c0 30       	breq	8000e62e <_dtoa_r+0x70e>
8000e62a:	10 95       	mov	r5,r8
8000e62c:	c0 98       	rjmp	8000e63e <_dtoa_r+0x71e>
8000e62e:	33 08       	mov	r8,48
8000e630:	40 89       	lddsp	r9,sp[0x20]
8000e632:	2f f6       	sub	r6,-1
8000e634:	b2 88       	st.b	r9[0x0],r8
8000e636:	40 88       	lddsp	r8,sp[0x20]
8000e638:	c0 88       	rjmp	8000e648 <_dtoa_r+0x728>
8000e63a:	40 66       	lddsp	r6,sp[0x18]
8000e63c:	33 99       	mov	r9,57
8000e63e:	0a 98       	mov	r8,r5
8000e640:	11 7a       	ld.ub	r10,--r8
8000e642:	f2 0a 18 00 	cp.b	r10,r9
8000e646:	ce f0       	breq	8000e624 <_dtoa_r+0x704>
8000e648:	50 66       	stdsp	sp[0x18],r6
8000e64a:	11 89       	ld.ub	r9,r8[0x0]
8000e64c:	2f f9       	sub	r9,-1
8000e64e:	b0 89       	st.b	r8[0x0],r9
8000e650:	e0 8f 02 42 	bral	8000ead4 <_dtoa_r+0xbb4>
8000e654:	e0 a0 0a c2 	rcall	8000fbd8 <__avr32_f64_mul>
8000e658:	2f f4       	sub	r4,-1
8000e65a:	fa eb 00 08 	st.d	sp[8],r10
8000e65e:	30 08       	mov	r8,0
8000e660:	30 09       	mov	r9,0
8000e662:	e0 a0 0d 86 	rcall	8001016e <__avr32_f64_cmp_eq>
8000e666:	ca 60       	breq	8000e5b2 <_dtoa_r+0x692>
8000e668:	e0 8f 02 35 	bral	8000ead2 <_dtoa_r+0xbb2>
8000e66c:	40 d8       	lddsp	r8,sp[0x34]
8000e66e:	58 08       	cp.w	r8,0
8000e670:	c0 51       	brne	8000e67a <_dtoa_r+0x75a>
8000e672:	04 98       	mov	r8,r2
8000e674:	00 95       	mov	r5,r0
8000e676:	40 d4       	lddsp	r4,sp[0x34]
8000e678:	c3 78       	rjmp	8000e6e6 <_dtoa_r+0x7c6>
8000e67a:	40 c5       	lddsp	r5,sp[0x30]
8000e67c:	58 15       	cp.w	r5,1
8000e67e:	e0 89 00 0f 	brgt	8000e69c <_dtoa_r+0x77c>
8000e682:	41 74       	lddsp	r4,sp[0x5c]
8000e684:	58 04       	cp.w	r4,0
8000e686:	c0 40       	breq	8000e68e <_dtoa_r+0x76e>
8000e688:	f4 c9 fb cd 	sub	r9,r10,-1075
8000e68c:	c0 48       	rjmp	8000e694 <_dtoa_r+0x774>
8000e68e:	41 99       	lddsp	r9,sp[0x64]
8000e690:	f2 09 11 36 	rsub	r9,r9,54
8000e694:	04 98       	mov	r8,r2
8000e696:	00 95       	mov	r5,r0
8000e698:	c1 c8       	rjmp	8000e6d0 <_dtoa_r+0x7b0>
8000e69a:	d7 03       	nop
8000e69c:	e2 c8 00 01 	sub	r8,r1,1
8000e6a0:	58 01       	cp.w	r1,0
8000e6a2:	e0 05 17 40 	movge	r5,r0
8000e6a6:	e2 09 17 40 	movge	r9,r1
8000e6aa:	e1 d1 e5 15 	sublt	r5,r0,r1
8000e6ae:	f9 b9 05 00 	movlt	r9,0
8000e6b2:	10 32       	cp.w	r2,r8
8000e6b4:	e5 d8 e4 18 	subge	r8,r2,r8
8000e6b8:	f1 d2 e5 18 	sublt	r8,r8,r2
8000e6bc:	e5 d8 e5 02 	addlt	r2,r2,r8
8000e6c0:	fb fc 50 11 	ld.wlt	r12,sp[0x44]
8000e6c4:	f9 d8 e5 0c 	addlt	r12,r12,r8
8000e6c8:	fb fc 5a 11 	st.wlt	sp[0x44],r12
8000e6cc:	f9 b8 05 00 	movlt	r8,0
8000e6d0:	40 4b       	lddsp	r11,sp[0x10]
8000e6d2:	12 0b       	add	r11,r9
8000e6d4:	50 08       	stdsp	sp[0x0],r8
8000e6d6:	50 4b       	stdsp	sp[0x10],r11
8000e6d8:	12 00       	add	r0,r9
8000e6da:	30 1b       	mov	r11,1
8000e6dc:	0e 9c       	mov	r12,r7
8000e6de:	e0 a0 08 a7 	rcall	8000f82c <__i2b>
8000e6e2:	40 08       	lddsp	r8,sp[0x0]
8000e6e4:	18 94       	mov	r4,r12
8000e6e6:	40 4a       	lddsp	r10,sp[0x10]
8000e6e8:	58 05       	cp.w	r5,0
8000e6ea:	5f 99       	srgt	r9
8000e6ec:	58 0a       	cp.w	r10,0
8000e6ee:	5f 9a       	srgt	r10
8000e6f0:	f5 e9 00 09 	and	r9,r10,r9
8000e6f4:	c0 80       	breq	8000e704 <_dtoa_r+0x7e4>
8000e6f6:	40 4c       	lddsp	r12,sp[0x10]
8000e6f8:	f8 05 0d 49 	min	r9,r12,r5
8000e6fc:	12 1c       	sub	r12,r9
8000e6fe:	12 10       	sub	r0,r9
8000e700:	50 4c       	stdsp	sp[0x10],r12
8000e702:	12 15       	sub	r5,r9
8000e704:	58 02       	cp.w	r2,0
8000e706:	e0 8a 00 27 	brle	8000e754 <_dtoa_r+0x834>
8000e70a:	40 db       	lddsp	r11,sp[0x34]
8000e70c:	58 0b       	cp.w	r11,0
8000e70e:	c1 d0       	breq	8000e748 <_dtoa_r+0x828>
8000e710:	58 08       	cp.w	r8,0
8000e712:	e0 8a 00 17 	brle	8000e740 <_dtoa_r+0x820>
8000e716:	10 9a       	mov	r10,r8
8000e718:	50 08       	stdsp	sp[0x0],r8
8000e71a:	08 9b       	mov	r11,r4
8000e71c:	0e 9c       	mov	r12,r7
8000e71e:	e0 a0 08 cd 	rcall	8000f8b8 <__pow5mult>
8000e722:	06 9a       	mov	r10,r3
8000e724:	18 9b       	mov	r11,r12
8000e726:	18 94       	mov	r4,r12
8000e728:	0e 9c       	mov	r12,r7
8000e72a:	e0 a0 08 01 	rcall	8000f72c <__multiply>
8000e72e:	18 99       	mov	r9,r12
8000e730:	06 9b       	mov	r11,r3
8000e732:	50 19       	stdsp	sp[0x4],r9
8000e734:	0e 9c       	mov	r12,r7
8000e736:	e0 a0 06 ad 	rcall	8000f490 <_Bfree>
8000e73a:	40 19       	lddsp	r9,sp[0x4]
8000e73c:	40 08       	lddsp	r8,sp[0x0]
8000e73e:	12 93       	mov	r3,r9
8000e740:	e4 08 01 0a 	sub	r10,r2,r8
8000e744:	c0 80       	breq	8000e754 <_dtoa_r+0x834>
8000e746:	c0 28       	rjmp	8000e74a <_dtoa_r+0x82a>
8000e748:	04 9a       	mov	r10,r2
8000e74a:	06 9b       	mov	r11,r3
8000e74c:	0e 9c       	mov	r12,r7
8000e74e:	e0 a0 08 b5 	rcall	8000f8b8 <__pow5mult>
8000e752:	18 93       	mov	r3,r12
8000e754:	30 1b       	mov	r11,1
8000e756:	0e 9c       	mov	r12,r7
8000e758:	e0 a0 08 6a 	rcall	8000f82c <__i2b>
8000e75c:	41 1a       	lddsp	r10,sp[0x44]
8000e75e:	18 92       	mov	r2,r12
8000e760:	58 0a       	cp.w	r10,0
8000e762:	e0 8a 00 07 	brle	8000e770 <_dtoa_r+0x850>
8000e766:	18 9b       	mov	r11,r12
8000e768:	0e 9c       	mov	r12,r7
8000e76a:	e0 a0 08 a7 	rcall	8000f8b8 <__pow5mult>
8000e76e:	18 92       	mov	r2,r12
8000e770:	40 c9       	lddsp	r9,sp[0x30]
8000e772:	58 19       	cp.w	r9,1
8000e774:	e0 89 00 14 	brgt	8000e79c <_dtoa_r+0x87c>
8000e778:	40 38       	lddsp	r8,sp[0xc]
8000e77a:	58 08       	cp.w	r8,0
8000e77c:	c1 01       	brne	8000e79c <_dtoa_r+0x87c>
8000e77e:	40 29       	lddsp	r9,sp[0x8]
8000e780:	f1 d9 c0 14 	bfextu	r8,r9,0x0,0x14
8000e784:	c0 c1       	brne	8000e79c <_dtoa_r+0x87c>
8000e786:	12 98       	mov	r8,r9
8000e788:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000e78c:	c0 80       	breq	8000e79c <_dtoa_r+0x87c>
8000e78e:	40 4c       	lddsp	r12,sp[0x10]
8000e790:	30 1b       	mov	r11,1
8000e792:	2f fc       	sub	r12,-1
8000e794:	2f f0       	sub	r0,-1
8000e796:	50 4c       	stdsp	sp[0x10],r12
8000e798:	50 6b       	stdsp	sp[0x18],r11
8000e79a:	c0 38       	rjmp	8000e7a0 <_dtoa_r+0x880>
8000e79c:	30 0a       	mov	r10,0
8000e79e:	50 6a       	stdsp	sp[0x18],r10
8000e7a0:	41 19       	lddsp	r9,sp[0x44]
8000e7a2:	58 09       	cp.w	r9,0
8000e7a4:	c0 31       	brne	8000e7aa <_dtoa_r+0x88a>
8000e7a6:	30 1c       	mov	r12,1
8000e7a8:	c0 98       	rjmp	8000e7ba <_dtoa_r+0x89a>
8000e7aa:	64 48       	ld.w	r8,r2[0x10]
8000e7ac:	2f c8       	sub	r8,-4
8000e7ae:	e4 08 03 2c 	ld.w	r12,r2[r8<<0x2]
8000e7b2:	e0 a0 05 df 	rcall	8000f370 <__hi0bits>
8000e7b6:	f8 0c 11 20 	rsub	r12,r12,32
8000e7ba:	40 4b       	lddsp	r11,sp[0x10]
8000e7bc:	f8 0b 00 08 	add	r8,r12,r11
8000e7c0:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000e7c4:	c0 c0       	breq	8000e7dc <_dtoa_r+0x8bc>
8000e7c6:	f0 08 11 20 	rsub	r8,r8,32
8000e7ca:	58 48       	cp.w	r8,4
8000e7cc:	e0 8a 00 06 	brle	8000e7d8 <_dtoa_r+0x8b8>
8000e7d0:	20 48       	sub	r8,4
8000e7d2:	10 0b       	add	r11,r8
8000e7d4:	50 4b       	stdsp	sp[0x10],r11
8000e7d6:	c0 78       	rjmp	8000e7e4 <_dtoa_r+0x8c4>
8000e7d8:	58 48       	cp.w	r8,4
8000e7da:	c0 70       	breq	8000e7e8 <_dtoa_r+0x8c8>
8000e7dc:	40 4a       	lddsp	r10,sp[0x10]
8000e7de:	2e 48       	sub	r8,-28
8000e7e0:	10 0a       	add	r10,r8
8000e7e2:	50 4a       	stdsp	sp[0x10],r10
8000e7e4:	10 00       	add	r0,r8
8000e7e6:	10 05       	add	r5,r8
8000e7e8:	58 00       	cp.w	r0,0
8000e7ea:	e0 8a 00 08 	brle	8000e7fa <_dtoa_r+0x8da>
8000e7ee:	06 9b       	mov	r11,r3
8000e7f0:	00 9a       	mov	r10,r0
8000e7f2:	0e 9c       	mov	r12,r7
8000e7f4:	e0 a0 07 58 	rcall	8000f6a4 <__lshift>
8000e7f8:	18 93       	mov	r3,r12
8000e7fa:	40 49       	lddsp	r9,sp[0x10]
8000e7fc:	58 09       	cp.w	r9,0
8000e7fe:	e0 8a 00 08 	brle	8000e80e <_dtoa_r+0x8ee>
8000e802:	04 9b       	mov	r11,r2
8000e804:	12 9a       	mov	r10,r9
8000e806:	0e 9c       	mov	r12,r7
8000e808:	e0 a0 07 4e 	rcall	8000f6a4 <__lshift>
8000e80c:	18 92       	mov	r2,r12
8000e80e:	41 48       	lddsp	r8,sp[0x50]
8000e810:	58 08       	cp.w	r8,0
8000e812:	c1 b0       	breq	8000e848 <_dtoa_r+0x928>
8000e814:	04 9b       	mov	r11,r2
8000e816:	06 9c       	mov	r12,r3
8000e818:	e0 a0 06 23 	rcall	8000f45e <__mcmp>
8000e81c:	c1 64       	brge	8000e848 <_dtoa_r+0x928>
8000e81e:	06 9b       	mov	r11,r3
8000e820:	30 09       	mov	r9,0
8000e822:	30 aa       	mov	r10,10
8000e824:	0e 9c       	mov	r12,r7
8000e826:	e0 a0 08 0b 	rcall	8000f83c <__multadd>
8000e82a:	20 16       	sub	r6,1
8000e82c:	18 93       	mov	r3,r12
8000e82e:	40 dc       	lddsp	r12,sp[0x34]
8000e830:	58 0c       	cp.w	r12,0
8000e832:	c0 31       	brne	8000e838 <_dtoa_r+0x918>
8000e834:	40 91       	lddsp	r1,sp[0x24]
8000e836:	c0 98       	rjmp	8000e848 <_dtoa_r+0x928>
8000e838:	08 9b       	mov	r11,r4
8000e83a:	40 91       	lddsp	r1,sp[0x24]
8000e83c:	30 09       	mov	r9,0
8000e83e:	30 aa       	mov	r10,10
8000e840:	0e 9c       	mov	r12,r7
8000e842:	e0 a0 07 fd 	rcall	8000f83c <__multadd>
8000e846:	18 94       	mov	r4,r12
8000e848:	58 01       	cp.w	r1,0
8000e84a:	5f a9       	srle	r9
8000e84c:	40 cb       	lddsp	r11,sp[0x30]
8000e84e:	58 2b       	cp.w	r11,2
8000e850:	5f 98       	srgt	r8
8000e852:	f3 e8 00 08 	and	r8,r9,r8
8000e856:	c2 50       	breq	8000e8a0 <_dtoa_r+0x980>
8000e858:	58 01       	cp.w	r1,0
8000e85a:	c1 11       	brne	8000e87c <_dtoa_r+0x95c>
8000e85c:	04 9b       	mov	r11,r2
8000e85e:	02 99       	mov	r9,r1
8000e860:	30 5a       	mov	r10,5
8000e862:	0e 9c       	mov	r12,r7
8000e864:	e0 a0 07 ec 	rcall	8000f83c <__multadd>
8000e868:	18 92       	mov	r2,r12
8000e86a:	18 9b       	mov	r11,r12
8000e86c:	06 9c       	mov	r12,r3
8000e86e:	e0 a0 05 f8 	rcall	8000f45e <__mcmp>
8000e872:	e0 89 00 0f 	brgt	8000e890 <_dtoa_r+0x970>
8000e876:	c0 38       	rjmp	8000e87c <_dtoa_r+0x95c>
8000e878:	30 02       	mov	r2,0
8000e87a:	04 94       	mov	r4,r2
8000e87c:	40 ea       	lddsp	r10,sp[0x38]
8000e87e:	30 09       	mov	r9,0
8000e880:	5c da       	com	r10
8000e882:	40 85       	lddsp	r5,sp[0x20]
8000e884:	50 6a       	stdsp	sp[0x18],r10
8000e886:	50 49       	stdsp	sp[0x10],r9
8000e888:	c0 f9       	rjmp	8000eaa6 <_dtoa_r+0xb86>
8000e88a:	08 92       	mov	r2,r4
8000e88c:	40 66       	lddsp	r6,sp[0x18]
8000e88e:	04 94       	mov	r4,r2
8000e890:	2f f6       	sub	r6,-1
8000e892:	50 66       	stdsp	sp[0x18],r6
8000e894:	33 18       	mov	r8,49
8000e896:	40 85       	lddsp	r5,sp[0x20]
8000e898:	0a c8       	st.b	r5++,r8
8000e89a:	30 08       	mov	r8,0
8000e89c:	50 48       	stdsp	sp[0x10],r8
8000e89e:	c0 49       	rjmp	8000eaa6 <_dtoa_r+0xb86>
8000e8a0:	40 dc       	lddsp	r12,sp[0x34]
8000e8a2:	58 0c       	cp.w	r12,0
8000e8a4:	e0 80 00 b5 	breq	8000ea0e <_dtoa_r+0xaee>
8000e8a8:	58 05       	cp.w	r5,0
8000e8aa:	e0 8a 00 08 	brle	8000e8ba <_dtoa_r+0x99a>
8000e8ae:	08 9b       	mov	r11,r4
8000e8b0:	0a 9a       	mov	r10,r5
8000e8b2:	0e 9c       	mov	r12,r7
8000e8b4:	e0 a0 06 f8 	rcall	8000f6a4 <__lshift>
8000e8b8:	18 94       	mov	r4,r12
8000e8ba:	40 6b       	lddsp	r11,sp[0x18]
8000e8bc:	58 0b       	cp.w	r11,0
8000e8be:	c0 31       	brne	8000e8c4 <_dtoa_r+0x9a4>
8000e8c0:	08 9c       	mov	r12,r4
8000e8c2:	c1 38       	rjmp	8000e8e8 <_dtoa_r+0x9c8>
8000e8c4:	68 1b       	ld.w	r11,r4[0x4]
8000e8c6:	0e 9c       	mov	r12,r7
8000e8c8:	e0 a0 05 fe 	rcall	8000f4c4 <_Balloc>
8000e8cc:	68 4a       	ld.w	r10,r4[0x10]
8000e8ce:	18 95       	mov	r5,r12
8000e8d0:	e8 cb ff f4 	sub	r11,r4,-12
8000e8d4:	2f ea       	sub	r10,-2
8000e8d6:	2f 4c       	sub	r12,-12
8000e8d8:	a3 6a       	lsl	r10,0x2
8000e8da:	fe b0 e6 44 	rcall	8000b562 <memcpy>
8000e8de:	0a 9b       	mov	r11,r5
8000e8e0:	30 1a       	mov	r10,1
8000e8e2:	0e 9c       	mov	r12,r7
8000e8e4:	e0 a0 06 e0 	rcall	8000f6a4 <__lshift>
8000e8e8:	50 44       	stdsp	sp[0x10],r4
8000e8ea:	40 3a       	lddsp	r10,sp[0xc]
8000e8ec:	30 19       	mov	r9,1
8000e8ee:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
8000e8f2:	18 94       	mov	r4,r12
8000e8f4:	50 da       	stdsp	sp[0x34],r10
8000e8f6:	40 85       	lddsp	r5,sp[0x20]
8000e8f8:	50 99       	stdsp	sp[0x24],r9
8000e8fa:	50 26       	stdsp	sp[0x8],r6
8000e8fc:	50 e1       	stdsp	sp[0x38],r1
8000e8fe:	04 9b       	mov	r11,r2
8000e900:	06 9c       	mov	r12,r3
8000e902:	fe b0 fa 7f 	rcall	8000de00 <quorem>
8000e906:	40 4b       	lddsp	r11,sp[0x10]
8000e908:	f8 c0 ff d0 	sub	r0,r12,-48
8000e90c:	06 9c       	mov	r12,r3
8000e90e:	e0 a0 05 a8 	rcall	8000f45e <__mcmp>
8000e912:	08 9a       	mov	r10,r4
8000e914:	50 6c       	stdsp	sp[0x18],r12
8000e916:	04 9b       	mov	r11,r2
8000e918:	0e 9c       	mov	r12,r7
8000e91a:	e0 a0 06 5d 	rcall	8000f5d4 <__mdiff>
8000e91e:	18 91       	mov	r1,r12
8000e920:	78 38       	ld.w	r8,r12[0xc]
8000e922:	58 08       	cp.w	r8,0
8000e924:	c0 30       	breq	8000e92a <_dtoa_r+0xa0a>
8000e926:	30 16       	mov	r6,1
8000e928:	c0 68       	rjmp	8000e934 <_dtoa_r+0xa14>
8000e92a:	18 9b       	mov	r11,r12
8000e92c:	06 9c       	mov	r12,r3
8000e92e:	e0 a0 05 98 	rcall	8000f45e <__mcmp>
8000e932:	18 96       	mov	r6,r12
8000e934:	0e 9c       	mov	r12,r7
8000e936:	02 9b       	mov	r11,r1
8000e938:	e0 a0 05 ac 	rcall	8000f490 <_Bfree>
8000e93c:	40 cc       	lddsp	r12,sp[0x30]
8000e93e:	ed ec 10 08 	or	r8,r6,r12
8000e942:	c0 d1       	brne	8000e95c <_dtoa_r+0xa3c>
8000e944:	40 db       	lddsp	r11,sp[0x34]
8000e946:	58 0b       	cp.w	r11,0
8000e948:	c0 a1       	brne	8000e95c <_dtoa_r+0xa3c>
8000e94a:	40 26       	lddsp	r6,sp[0x8]
8000e94c:	e0 40 00 39 	cp.w	r0,57
8000e950:	c3 00       	breq	8000e9b0 <_dtoa_r+0xa90>
8000e952:	40 6a       	lddsp	r10,sp[0x18]
8000e954:	58 0a       	cp.w	r10,0
8000e956:	e0 89 00 24 	brgt	8000e99e <_dtoa_r+0xa7e>
8000e95a:	c2 f8       	rjmp	8000e9b8 <_dtoa_r+0xa98>
8000e95c:	40 69       	lddsp	r9,sp[0x18]
8000e95e:	58 09       	cp.w	r9,0
8000e960:	c0 85       	brlt	8000e970 <_dtoa_r+0xa50>
8000e962:	12 98       	mov	r8,r9
8000e964:	40 cc       	lddsp	r12,sp[0x30]
8000e966:	18 48       	or	r8,r12
8000e968:	c1 d1       	brne	8000e9a2 <_dtoa_r+0xa82>
8000e96a:	40 db       	lddsp	r11,sp[0x34]
8000e96c:	58 0b       	cp.w	r11,0
8000e96e:	c1 a1       	brne	8000e9a2 <_dtoa_r+0xa82>
8000e970:	0c 99       	mov	r9,r6
8000e972:	40 26       	lddsp	r6,sp[0x8]
8000e974:	58 09       	cp.w	r9,0
8000e976:	e0 8a 00 21 	brle	8000e9b8 <_dtoa_r+0xa98>
8000e97a:	06 9b       	mov	r11,r3
8000e97c:	30 1a       	mov	r10,1
8000e97e:	0e 9c       	mov	r12,r7
8000e980:	e0 a0 06 92 	rcall	8000f6a4 <__lshift>
8000e984:	04 9b       	mov	r11,r2
8000e986:	18 93       	mov	r3,r12
8000e988:	e0 a0 05 6b 	rcall	8000f45e <__mcmp>
8000e98c:	e0 89 00 06 	brgt	8000e998 <_dtoa_r+0xa78>
8000e990:	c1 41       	brne	8000e9b8 <_dtoa_r+0xa98>
8000e992:	ed b0 00 00 	bld	r0,0x0
8000e996:	c1 11       	brne	8000e9b8 <_dtoa_r+0xa98>
8000e998:	e0 40 00 39 	cp.w	r0,57
8000e99c:	c0 a0       	breq	8000e9b0 <_dtoa_r+0xa90>
8000e99e:	2f f0       	sub	r0,-1
8000e9a0:	c0 c8       	rjmp	8000e9b8 <_dtoa_r+0xa98>
8000e9a2:	58 06       	cp.w	r6,0
8000e9a4:	e0 8a 00 0c 	brle	8000e9bc <_dtoa_r+0xa9c>
8000e9a8:	40 26       	lddsp	r6,sp[0x8]
8000e9aa:	e0 40 00 39 	cp.w	r0,57
8000e9ae:	c0 41       	brne	8000e9b6 <_dtoa_r+0xa96>
8000e9b0:	33 98       	mov	r8,57
8000e9b2:	0a c8       	st.b	r5++,r8
8000e9b4:	c6 78       	rjmp	8000ea82 <_dtoa_r+0xb62>
8000e9b6:	2f f0       	sub	r0,-1
8000e9b8:	0a c0       	st.b	r5++,r0
8000e9ba:	c7 58       	rjmp	8000eaa4 <_dtoa_r+0xb84>
8000e9bc:	0a c0       	st.b	r5++,r0
8000e9be:	40 9a       	lddsp	r10,sp[0x24]
8000e9c0:	40 e9       	lddsp	r9,sp[0x38]
8000e9c2:	12 3a       	cp.w	r10,r9
8000e9c4:	c4 30       	breq	8000ea4a <_dtoa_r+0xb2a>
8000e9c6:	06 9b       	mov	r11,r3
8000e9c8:	30 09       	mov	r9,0
8000e9ca:	30 aa       	mov	r10,10
8000e9cc:	0e 9c       	mov	r12,r7
8000e9ce:	e0 a0 07 37 	rcall	8000f83c <__multadd>
8000e9d2:	40 48       	lddsp	r8,sp[0x10]
8000e9d4:	18 93       	mov	r3,r12
8000e9d6:	08 38       	cp.w	r8,r4
8000e9d8:	c0 91       	brne	8000e9ea <_dtoa_r+0xaca>
8000e9da:	10 9b       	mov	r11,r8
8000e9dc:	30 09       	mov	r9,0
8000e9de:	30 aa       	mov	r10,10
8000e9e0:	0e 9c       	mov	r12,r7
8000e9e2:	e0 a0 07 2d 	rcall	8000f83c <__multadd>
8000e9e6:	50 4c       	stdsp	sp[0x10],r12
8000e9e8:	c0 e8       	rjmp	8000ea04 <_dtoa_r+0xae4>
8000e9ea:	40 4b       	lddsp	r11,sp[0x10]
8000e9ec:	30 09       	mov	r9,0
8000e9ee:	30 aa       	mov	r10,10
8000e9f0:	0e 9c       	mov	r12,r7
8000e9f2:	e0 a0 07 25 	rcall	8000f83c <__multadd>
8000e9f6:	08 9b       	mov	r11,r4
8000e9f8:	50 4c       	stdsp	sp[0x10],r12
8000e9fa:	30 09       	mov	r9,0
8000e9fc:	30 aa       	mov	r10,10
8000e9fe:	0e 9c       	mov	r12,r7
8000ea00:	e0 a0 07 1e 	rcall	8000f83c <__multadd>
8000ea04:	18 94       	mov	r4,r12
8000ea06:	40 9c       	lddsp	r12,sp[0x24]
8000ea08:	2f fc       	sub	r12,-1
8000ea0a:	50 9c       	stdsp	sp[0x24],r12
8000ea0c:	c7 9b       	rjmp	8000e8fe <_dtoa_r+0x9de>
8000ea0e:	30 18       	mov	r8,1
8000ea10:	06 90       	mov	r0,r3
8000ea12:	40 85       	lddsp	r5,sp[0x20]
8000ea14:	08 93       	mov	r3,r4
8000ea16:	0c 94       	mov	r4,r6
8000ea18:	10 96       	mov	r6,r8
8000ea1a:	04 9b       	mov	r11,r2
8000ea1c:	00 9c       	mov	r12,r0
8000ea1e:	fe b0 f9 f1 	rcall	8000de00 <quorem>
8000ea22:	2d 0c       	sub	r12,-48
8000ea24:	0a cc       	st.b	r5++,r12
8000ea26:	02 36       	cp.w	r6,r1
8000ea28:	c0 a4       	brge	8000ea3c <_dtoa_r+0xb1c>
8000ea2a:	00 9b       	mov	r11,r0
8000ea2c:	30 09       	mov	r9,0
8000ea2e:	30 aa       	mov	r10,10
8000ea30:	0e 9c       	mov	r12,r7
8000ea32:	2f f6       	sub	r6,-1
8000ea34:	e0 a0 07 04 	rcall	8000f83c <__multadd>
8000ea38:	18 90       	mov	r0,r12
8000ea3a:	cf 0b       	rjmp	8000ea1a <_dtoa_r+0xafa>
8000ea3c:	08 96       	mov	r6,r4
8000ea3e:	30 0b       	mov	r11,0
8000ea40:	06 94       	mov	r4,r3
8000ea42:	50 4b       	stdsp	sp[0x10],r11
8000ea44:	00 93       	mov	r3,r0
8000ea46:	18 90       	mov	r0,r12
8000ea48:	c0 28       	rjmp	8000ea4c <_dtoa_r+0xb2c>
8000ea4a:	40 26       	lddsp	r6,sp[0x8]
8000ea4c:	06 9b       	mov	r11,r3
8000ea4e:	30 1a       	mov	r10,1
8000ea50:	0e 9c       	mov	r12,r7
8000ea52:	e0 a0 06 29 	rcall	8000f6a4 <__lshift>
8000ea56:	04 9b       	mov	r11,r2
8000ea58:	18 93       	mov	r3,r12
8000ea5a:	e0 a0 05 02 	rcall	8000f45e <__mcmp>
8000ea5e:	e0 89 00 12 	brgt	8000ea82 <_dtoa_r+0xb62>
8000ea62:	c1 b1       	brne	8000ea98 <_dtoa_r+0xb78>
8000ea64:	e1 d0 c0 01 	bfextu	r0,r0,0x0,0x1
8000ea68:	c0 d1       	brne	8000ea82 <_dtoa_r+0xb62>
8000ea6a:	c1 78       	rjmp	8000ea98 <_dtoa_r+0xb78>
8000ea6c:	40 89       	lddsp	r9,sp[0x20]
8000ea6e:	12 38       	cp.w	r8,r9
8000ea70:	c0 30       	breq	8000ea76 <_dtoa_r+0xb56>
8000ea72:	10 95       	mov	r5,r8
8000ea74:	c0 88       	rjmp	8000ea84 <_dtoa_r+0xb64>
8000ea76:	2f f6       	sub	r6,-1
8000ea78:	50 66       	stdsp	sp[0x18],r6
8000ea7a:	33 18       	mov	r8,49
8000ea7c:	40 8c       	lddsp	r12,sp[0x20]
8000ea7e:	b8 88       	st.b	r12[0x0],r8
8000ea80:	c1 38       	rjmp	8000eaa6 <_dtoa_r+0xb86>
8000ea82:	33 9a       	mov	r10,57
8000ea84:	0a 98       	mov	r8,r5
8000ea86:	11 79       	ld.ub	r9,--r8
8000ea88:	f4 09 18 00 	cp.b	r9,r10
8000ea8c:	cf 00       	breq	8000ea6c <_dtoa_r+0xb4c>
8000ea8e:	2f f9       	sub	r9,-1
8000ea90:	b0 89       	st.b	r8[0x0],r9
8000ea92:	c0 98       	rjmp	8000eaa4 <_dtoa_r+0xb84>
8000ea94:	10 95       	mov	r5,r8
8000ea96:	c0 28       	rjmp	8000ea9a <_dtoa_r+0xb7a>
8000ea98:	33 09       	mov	r9,48
8000ea9a:	0a 98       	mov	r8,r5
8000ea9c:	11 7a       	ld.ub	r10,--r8
8000ea9e:	f2 0a 18 00 	cp.b	r10,r9
8000eaa2:	cf 90       	breq	8000ea94 <_dtoa_r+0xb74>
8000eaa4:	50 66       	stdsp	sp[0x18],r6
8000eaa6:	04 9b       	mov	r11,r2
8000eaa8:	0e 9c       	mov	r12,r7
8000eaaa:	e0 a0 04 f3 	rcall	8000f490 <_Bfree>
8000eaae:	58 04       	cp.w	r4,0
8000eab0:	c1 20       	breq	8000ead4 <_dtoa_r+0xbb4>
8000eab2:	40 4b       	lddsp	r11,sp[0x10]
8000eab4:	08 3b       	cp.w	r11,r4
8000eab6:	5f 19       	srne	r9
8000eab8:	58 0b       	cp.w	r11,0
8000eaba:	5f 18       	srne	r8
8000eabc:	f3 e8 00 08 	and	r8,r9,r8
8000eac0:	c0 40       	breq	8000eac8 <_dtoa_r+0xba8>
8000eac2:	0e 9c       	mov	r12,r7
8000eac4:	e0 a0 04 e6 	rcall	8000f490 <_Bfree>
8000eac8:	08 9b       	mov	r11,r4
8000eaca:	0e 9c       	mov	r12,r7
8000eacc:	e0 a0 04 e2 	rcall	8000f490 <_Bfree>
8000ead0:	c0 28       	rjmp	8000ead4 <_dtoa_r+0xbb4>
8000ead2:	50 66       	stdsp	sp[0x18],r6
8000ead4:	0e 9c       	mov	r12,r7
8000ead6:	06 9b       	mov	r11,r3
8000ead8:	e0 a0 04 dc 	rcall	8000f490 <_Bfree>
8000eadc:	30 08       	mov	r8,0
8000eade:	aa 88       	st.b	r5[0x0],r8
8000eae0:	40 68       	lddsp	r8,sp[0x18]
8000eae2:	41 5a       	lddsp	r10,sp[0x54]
8000eae4:	2f f8       	sub	r8,-1
8000eae6:	41 29       	lddsp	r9,sp[0x48]
8000eae8:	95 08       	st.w	r10[0x0],r8
8000eaea:	40 8c       	lddsp	r12,sp[0x20]
8000eaec:	58 09       	cp.w	r9,0
8000eaee:	fb f8 10 12 	ld.wne	r8,sp[0x48]
8000eaf2:	f1 f5 1a 00 	st.wne	r8[0x0],r5
8000eaf6:	2e 6d       	sub	sp,-104
8000eaf8:	d8 32       	popm	r0-r7,pc
8000eafa:	d7 03       	nop

8000eafc <__errno>:
8000eafc:	e0 68 0a 50 	mov	r8,2640
8000eb00:	70 0c       	ld.w	r12,r8[0x0]
8000eb02:	2f 4c       	sub	r12,-12
8000eb04:	5e fc       	retal	r12
8000eb06:	d7 03       	nop

8000eb08 <_fflush_r>:
8000eb08:	d4 21       	pushm	r4-r7,lr
8000eb0a:	16 97       	mov	r7,r11
8000eb0c:	18 96       	mov	r6,r12
8000eb0e:	76 48       	ld.w	r8,r11[0x10]
8000eb10:	58 08       	cp.w	r8,0
8000eb12:	c7 f0       	breq	8000ec10 <_fflush_r+0x108>
8000eb14:	58 0c       	cp.w	r12,0
8000eb16:	c0 50       	breq	8000eb20 <_fflush_r+0x18>
8000eb18:	78 68       	ld.w	r8,r12[0x18]
8000eb1a:	58 08       	cp.w	r8,0
8000eb1c:	c0 21       	brne	8000eb20 <_fflush_r+0x18>
8000eb1e:	cc dc       	rcall	8000ecb8 <__sinit>
8000eb20:	fe c8 d1 78 	sub	r8,pc,-11912
8000eb24:	10 37       	cp.w	r7,r8
8000eb26:	c0 31       	brne	8000eb2c <_fflush_r+0x24>
8000eb28:	6c 07       	ld.w	r7,r6[0x0]
8000eb2a:	c0 c8       	rjmp	8000eb42 <_fflush_r+0x3a>
8000eb2c:	fe c8 d1 64 	sub	r8,pc,-11932
8000eb30:	10 37       	cp.w	r7,r8
8000eb32:	c0 31       	brne	8000eb38 <_fflush_r+0x30>
8000eb34:	6c 17       	ld.w	r7,r6[0x4]
8000eb36:	c0 68       	rjmp	8000eb42 <_fflush_r+0x3a>
8000eb38:	fe c8 d1 50 	sub	r8,pc,-11952
8000eb3c:	10 37       	cp.w	r7,r8
8000eb3e:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000eb42:	8e 6a       	ld.sh	r10,r7[0xc]
8000eb44:	14 98       	mov	r8,r10
8000eb46:	ed ba 00 03 	bld	r10,0x3
8000eb4a:	c4 20       	breq	8000ebce <_fflush_r+0xc6>
8000eb4c:	ab ba       	sbr	r10,0xb
8000eb4e:	ae 6a       	st.h	r7[0xc],r10
8000eb50:	6e 18       	ld.w	r8,r7[0x4]
8000eb52:	58 08       	cp.w	r8,0
8000eb54:	e0 89 00 06 	brgt	8000eb60 <_fflush_r+0x58>
8000eb58:	6f 08       	ld.w	r8,r7[0x40]
8000eb5a:	58 08       	cp.w	r8,0
8000eb5c:	e0 8a 00 5a 	brle	8000ec10 <_fflush_r+0x108>
8000eb60:	6e b8       	ld.w	r8,r7[0x2c]
8000eb62:	58 08       	cp.w	r8,0
8000eb64:	c5 60       	breq	8000ec10 <_fflush_r+0x108>
8000eb66:	e2 1a 10 00 	andl	r10,0x1000,COH
8000eb6a:	c0 30       	breq	8000eb70 <_fflush_r+0x68>
8000eb6c:	6f 55       	ld.w	r5,r7[0x54]
8000eb6e:	c0 f8       	rjmp	8000eb8c <_fflush_r+0x84>
8000eb70:	30 19       	mov	r9,1
8000eb72:	6e 8b       	ld.w	r11,r7[0x20]
8000eb74:	0c 9c       	mov	r12,r6
8000eb76:	5d 18       	icall	r8
8000eb78:	18 95       	mov	r5,r12
8000eb7a:	5b fc       	cp.w	r12,-1
8000eb7c:	c0 81       	brne	8000eb8c <_fflush_r+0x84>
8000eb7e:	6c 38       	ld.w	r8,r6[0xc]
8000eb80:	59 d8       	cp.w	r8,29
8000eb82:	c4 70       	breq	8000ec10 <_fflush_r+0x108>
8000eb84:	8e 68       	ld.sh	r8,r7[0xc]
8000eb86:	a7 a8       	sbr	r8,0x6
8000eb88:	ae 68       	st.h	r7[0xc],r8
8000eb8a:	d8 22       	popm	r4-r7,pc
8000eb8c:	8e 68       	ld.sh	r8,r7[0xc]
8000eb8e:	ed b8 00 02 	bld	r8,0x2
8000eb92:	c0 91       	brne	8000eba4 <_fflush_r+0x9c>
8000eb94:	6e 18       	ld.w	r8,r7[0x4]
8000eb96:	10 15       	sub	r5,r8
8000eb98:	6e d8       	ld.w	r8,r7[0x34]
8000eb9a:	58 08       	cp.w	r8,0
8000eb9c:	ef f8 10 10 	ld.wne	r8,r7[0x40]
8000eba0:	eb d8 e1 15 	subne	r5,r5,r8
8000eba4:	6e b8       	ld.w	r8,r7[0x2c]
8000eba6:	0c 9c       	mov	r12,r6
8000eba8:	30 09       	mov	r9,0
8000ebaa:	0a 9a       	mov	r10,r5
8000ebac:	6e 8b       	ld.w	r11,r7[0x20]
8000ebae:	5d 18       	icall	r8
8000ebb0:	8e 68       	ld.sh	r8,r7[0xc]
8000ebb2:	0a 3c       	cp.w	r12,r5
8000ebb4:	c2 61       	brne	8000ec00 <_fflush_r+0xf8>
8000ebb6:	ab d8       	cbr	r8,0xb
8000ebb8:	30 0c       	mov	r12,0
8000ebba:	6e 49       	ld.w	r9,r7[0x10]
8000ebbc:	ae 68       	st.h	r7[0xc],r8
8000ebbe:	8f 1c       	st.w	r7[0x4],r12
8000ebc0:	8f 09       	st.w	r7[0x0],r9
8000ebc2:	ed b8 00 0c 	bld	r8,0xc
8000ebc6:	c2 51       	brne	8000ec10 <_fflush_r+0x108>
8000ebc8:	ef 45 00 54 	st.w	r7[84],r5
8000ebcc:	d8 22       	popm	r4-r7,pc
8000ebce:	6e 45       	ld.w	r5,r7[0x10]
8000ebd0:	58 05       	cp.w	r5,0
8000ebd2:	c1 f0       	breq	8000ec10 <_fflush_r+0x108>
8000ebd4:	6e 04       	ld.w	r4,r7[0x0]
8000ebd6:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
8000ebda:	8f 05       	st.w	r7[0x0],r5
8000ebdc:	f9 b8 01 00 	movne	r8,0
8000ebe0:	ef f8 00 05 	ld.weq	r8,r7[0x14]
8000ebe4:	0a 14       	sub	r4,r5
8000ebe6:	8f 28       	st.w	r7[0x8],r8
8000ebe8:	c1 18       	rjmp	8000ec0a <_fflush_r+0x102>
8000ebea:	08 99       	mov	r9,r4
8000ebec:	0a 9a       	mov	r10,r5
8000ebee:	6e a8       	ld.w	r8,r7[0x28]
8000ebf0:	6e 8b       	ld.w	r11,r7[0x20]
8000ebf2:	0c 9c       	mov	r12,r6
8000ebf4:	5d 18       	icall	r8
8000ebf6:	18 14       	sub	r4,r12
8000ebf8:	58 0c       	cp.w	r12,0
8000ebfa:	e0 89 00 07 	brgt	8000ec08 <_fflush_r+0x100>
8000ebfe:	8e 68       	ld.sh	r8,r7[0xc]
8000ec00:	a7 a8       	sbr	r8,0x6
8000ec02:	3f fc       	mov	r12,-1
8000ec04:	ae 68       	st.h	r7[0xc],r8
8000ec06:	d8 22       	popm	r4-r7,pc
8000ec08:	18 05       	add	r5,r12
8000ec0a:	58 04       	cp.w	r4,0
8000ec0c:	fe 99 ff ef 	brgt	8000ebea <_fflush_r+0xe2>
8000ec10:	d8 2a       	popm	r4-r7,pc,r12=0
8000ec12:	d7 03       	nop

8000ec14 <__sfp_lock_acquire>:
8000ec14:	5e fc       	retal	r12

8000ec16 <__sfp_lock_release>:
8000ec16:	5e fc       	retal	r12

8000ec18 <_cleanup_r>:
8000ec18:	d4 01       	pushm	lr
8000ec1a:	fe cb f0 c6 	sub	r11,pc,-3898
8000ec1e:	e0 a0 02 f7 	rcall	8000f20c <_fwalk>
8000ec22:	d8 02       	popm	pc

8000ec24 <__sfmoreglue>:
8000ec24:	d4 21       	pushm	r4-r7,lr
8000ec26:	16 95       	mov	r5,r11
8000ec28:	f6 06 10 5c 	mul	r6,r11,92
8000ec2c:	ec cb ff f4 	sub	r11,r6,-12
8000ec30:	fe b0 e2 6a 	rcall	8000b104 <_malloc_r>
8000ec34:	18 97       	mov	r7,r12
8000ec36:	c0 90       	breq	8000ec48 <__sfmoreglue+0x24>
8000ec38:	99 15       	st.w	r12[0x4],r5
8000ec3a:	30 0b       	mov	r11,0
8000ec3c:	2f 4c       	sub	r12,-12
8000ec3e:	0c 9a       	mov	r10,r6
8000ec40:	8f 2c       	st.w	r7[0x8],r12
8000ec42:	8f 0b       	st.w	r7[0x0],r11
8000ec44:	fe b0 e5 33 	rcall	8000b6aa <memset>
8000ec48:	0e 9c       	mov	r12,r7
8000ec4a:	d8 22       	popm	r4-r7,pc

8000ec4c <__sfp>:
8000ec4c:	d4 21       	pushm	r4-r7,lr
8000ec4e:	fe c8 d2 42 	sub	r8,pc,-11710
8000ec52:	18 96       	mov	r6,r12
8000ec54:	70 07       	ld.w	r7,r8[0x0]
8000ec56:	6e 68       	ld.w	r8,r7[0x18]
8000ec58:	58 08       	cp.w	r8,0
8000ec5a:	c0 31       	brne	8000ec60 <__sfp+0x14>
8000ec5c:	0e 9c       	mov	r12,r7
8000ec5e:	c2 dc       	rcall	8000ecb8 <__sinit>
8000ec60:	ee c7 ff 28 	sub	r7,r7,-216
8000ec64:	30 05       	mov	r5,0
8000ec66:	6e 2c       	ld.w	r12,r7[0x8]
8000ec68:	6e 18       	ld.w	r8,r7[0x4]
8000ec6a:	c0 68       	rjmp	8000ec76 <__sfp+0x2a>
8000ec6c:	98 69       	ld.sh	r9,r12[0xc]
8000ec6e:	ea 09 19 00 	cp.h	r9,r5
8000ec72:	c1 10       	breq	8000ec94 <__sfp+0x48>
8000ec74:	2a 4c       	sub	r12,-92
8000ec76:	20 18       	sub	r8,1
8000ec78:	cf a7       	brpl	8000ec6c <__sfp+0x20>
8000ec7a:	6e 08       	ld.w	r8,r7[0x0]
8000ec7c:	58 08       	cp.w	r8,0
8000ec7e:	c0 61       	brne	8000ec8a <__sfp+0x3e>
8000ec80:	30 4b       	mov	r11,4
8000ec82:	0c 9c       	mov	r12,r6
8000ec84:	cd 0f       	rcall	8000ec24 <__sfmoreglue>
8000ec86:	8f 0c       	st.w	r7[0x0],r12
8000ec88:	c0 30       	breq	8000ec8e <__sfp+0x42>
8000ec8a:	6e 07       	ld.w	r7,r7[0x0]
8000ec8c:	ce db       	rjmp	8000ec66 <__sfp+0x1a>
8000ec8e:	30 c8       	mov	r8,12
8000ec90:	8d 38       	st.w	r6[0xc],r8
8000ec92:	d8 22       	popm	r4-r7,pc
8000ec94:	30 08       	mov	r8,0
8000ec96:	f9 48 00 4c 	st.w	r12[76],r8
8000ec9a:	99 08       	st.w	r12[0x0],r8
8000ec9c:	99 28       	st.w	r12[0x8],r8
8000ec9e:	99 18       	st.w	r12[0x4],r8
8000eca0:	99 48       	st.w	r12[0x10],r8
8000eca2:	99 58       	st.w	r12[0x14],r8
8000eca4:	99 68       	st.w	r12[0x18],r8
8000eca6:	99 d8       	st.w	r12[0x34],r8
8000eca8:	99 e8       	st.w	r12[0x38],r8
8000ecaa:	f9 48 00 48 	st.w	r12[72],r8
8000ecae:	3f f8       	mov	r8,-1
8000ecb0:	b8 78       	st.h	r12[0xe],r8
8000ecb2:	30 18       	mov	r8,1
8000ecb4:	b8 68       	st.h	r12[0xc],r8
8000ecb6:	d8 22       	popm	r4-r7,pc

8000ecb8 <__sinit>:
8000ecb8:	d4 21       	pushm	r4-r7,lr
8000ecba:	18 96       	mov	r6,r12
8000ecbc:	78 67       	ld.w	r7,r12[0x18]
8000ecbe:	58 07       	cp.w	r7,0
8000ecc0:	c4 91       	brne	8000ed52 <__sinit+0x9a>
8000ecc2:	fe c8 00 aa 	sub	r8,pc,170
8000ecc6:	30 15       	mov	r5,1
8000ecc8:	99 a8       	st.w	r12[0x28],r8
8000ecca:	f9 47 00 d8 	st.w	r12[216],r7
8000ecce:	f9 47 00 dc 	st.w	r12[220],r7
8000ecd2:	f9 47 00 e0 	st.w	r12[224],r7
8000ecd6:	99 65       	st.w	r12[0x18],r5
8000ecd8:	cb af       	rcall	8000ec4c <__sfp>
8000ecda:	8d 0c       	st.w	r6[0x0],r12
8000ecdc:	0c 9c       	mov	r12,r6
8000ecde:	cb 7f       	rcall	8000ec4c <__sfp>
8000ece0:	8d 1c       	st.w	r6[0x4],r12
8000ece2:	0c 9c       	mov	r12,r6
8000ece4:	cb 4f       	rcall	8000ec4c <__sfp>
8000ece6:	6c 09       	ld.w	r9,r6[0x0]
8000ece8:	30 48       	mov	r8,4
8000ecea:	93 07       	st.w	r9[0x0],r7
8000ecec:	b2 68       	st.h	r9[0xc],r8
8000ecee:	93 17       	st.w	r9[0x4],r7
8000ecf0:	93 27       	st.w	r9[0x8],r7
8000ecf2:	6c 18       	ld.w	r8,r6[0x4]
8000ecf4:	b2 77       	st.h	r9[0xe],r7
8000ecf6:	93 47       	st.w	r9[0x10],r7
8000ecf8:	93 57       	st.w	r9[0x14],r7
8000ecfa:	93 67       	st.w	r9[0x18],r7
8000ecfc:	93 89       	st.w	r9[0x20],r9
8000ecfe:	91 07       	st.w	r8[0x0],r7
8000ed00:	91 17       	st.w	r8[0x4],r7
8000ed02:	91 27       	st.w	r8[0x8],r7
8000ed04:	fe ce f3 24 	sub	lr,pc,-3292
8000ed08:	fe cb f3 54 	sub	r11,pc,-3244
8000ed0c:	93 9e       	st.w	r9[0x24],lr
8000ed0e:	93 ab       	st.w	r9[0x28],r11
8000ed10:	fe ca f3 7c 	sub	r10,pc,-3204
8000ed14:	fe c4 f3 88 	sub	r4,pc,-3192
8000ed18:	93 ba       	st.w	r9[0x2c],r10
8000ed1a:	93 c4       	st.w	r9[0x30],r4
8000ed1c:	30 99       	mov	r9,9
8000ed1e:	b0 69       	st.h	r8[0xc],r9
8000ed20:	b0 75       	st.h	r8[0xe],r5
8000ed22:	91 c4       	st.w	r8[0x30],r4
8000ed24:	91 47       	st.w	r8[0x10],r7
8000ed26:	91 57       	st.w	r8[0x14],r7
8000ed28:	91 67       	st.w	r8[0x18],r7
8000ed2a:	91 88       	st.w	r8[0x20],r8
8000ed2c:	91 9e       	st.w	r8[0x24],lr
8000ed2e:	91 ab       	st.w	r8[0x28],r11
8000ed30:	91 ba       	st.w	r8[0x2c],r10
8000ed32:	8d 2c       	st.w	r6[0x8],r12
8000ed34:	31 28       	mov	r8,18
8000ed36:	99 07       	st.w	r12[0x0],r7
8000ed38:	b8 68       	st.h	r12[0xc],r8
8000ed3a:	99 17       	st.w	r12[0x4],r7
8000ed3c:	99 27       	st.w	r12[0x8],r7
8000ed3e:	30 28       	mov	r8,2
8000ed40:	b8 78       	st.h	r12[0xe],r8
8000ed42:	99 c4       	st.w	r12[0x30],r4
8000ed44:	99 67       	st.w	r12[0x18],r7
8000ed46:	99 9e       	st.w	r12[0x24],lr
8000ed48:	99 ab       	st.w	r12[0x28],r11
8000ed4a:	99 ba       	st.w	r12[0x2c],r10
8000ed4c:	99 47       	st.w	r12[0x10],r7
8000ed4e:	99 57       	st.w	r12[0x14],r7
8000ed50:	99 8c       	st.w	r12[0x20],r12
8000ed52:	d8 22       	popm	r4-r7,pc

8000ed54 <_malloc_trim_r>:
8000ed54:	d4 21       	pushm	r4-r7,lr
8000ed56:	16 95       	mov	r5,r11
8000ed58:	18 97       	mov	r7,r12
8000ed5a:	fe b0 cd b1 	rcall	800088bc <__malloc_lock>
8000ed5e:	e0 64 05 50 	mov	r4,1360
8000ed62:	68 28       	ld.w	r8,r4[0x8]
8000ed64:	70 16       	ld.w	r6,r8[0x4]
8000ed66:	e0 16 ff fc 	andl	r6,0xfffc
8000ed6a:	ec c8 ff 91 	sub	r8,r6,-111
8000ed6e:	f0 05 01 05 	sub	r5,r8,r5
8000ed72:	e0 15 ff 80 	andl	r5,0xff80
8000ed76:	ea c5 00 80 	sub	r5,r5,128
8000ed7a:	e0 45 00 7f 	cp.w	r5,127
8000ed7e:	e0 8a 00 25 	brle	8000edc8 <_malloc_trim_r+0x74>
8000ed82:	30 0b       	mov	r11,0
8000ed84:	0e 9c       	mov	r12,r7
8000ed86:	fe b0 e5 f9 	rcall	8000b978 <_sbrk_r>
8000ed8a:	68 28       	ld.w	r8,r4[0x8]
8000ed8c:	0c 08       	add	r8,r6
8000ed8e:	10 3c       	cp.w	r12,r8
8000ed90:	c1 c1       	brne	8000edc8 <_malloc_trim_r+0x74>
8000ed92:	ea 0b 11 00 	rsub	r11,r5,0
8000ed96:	0e 9c       	mov	r12,r7
8000ed98:	fe b0 e5 f0 	rcall	8000b978 <_sbrk_r>
8000ed9c:	5b fc       	cp.w	r12,-1
8000ed9e:	c1 91       	brne	8000edd0 <_malloc_trim_r+0x7c>
8000eda0:	30 0b       	mov	r11,0
8000eda2:	0e 9c       	mov	r12,r7
8000eda4:	fe b0 e5 ea 	rcall	8000b978 <_sbrk_r>
8000eda8:	68 28       	ld.w	r8,r4[0x8]
8000edaa:	f8 08 01 09 	sub	r9,r12,r8
8000edae:	58 f9       	cp.w	r9,15
8000edb0:	e0 8a 00 0c 	brle	8000edc8 <_malloc_trim_r+0x74>
8000edb4:	a1 a9       	sbr	r9,0x0
8000edb6:	91 19       	st.w	r8[0x4],r9
8000edb8:	e0 68 09 5c 	mov	r8,2396
8000edbc:	70 09       	ld.w	r9,r8[0x0]
8000edbe:	e0 68 0d 74 	mov	r8,3444
8000edc2:	f8 09 01 09 	sub	r9,r12,r9
8000edc6:	91 09       	st.w	r8[0x0],r9
8000edc8:	0e 9c       	mov	r12,r7
8000edca:	fe b0 cd 87 	rcall	800088d8 <__malloc_unlock>
8000edce:	d8 2a       	popm	r4-r7,pc,r12=0
8000edd0:	68 28       	ld.w	r8,r4[0x8]
8000edd2:	0a 16       	sub	r6,r5
8000edd4:	a1 a6       	sbr	r6,0x0
8000edd6:	91 16       	st.w	r8[0x4],r6
8000edd8:	e0 68 0d 74 	mov	r8,3444
8000eddc:	70 09       	ld.w	r9,r8[0x0]
8000edde:	0a 19       	sub	r9,r5
8000ede0:	0e 9c       	mov	r12,r7
8000ede2:	91 09       	st.w	r8[0x0],r9
8000ede4:	fe b0 cd 7a 	rcall	800088d8 <__malloc_unlock>
8000ede8:	da 2a       	popm	r4-r7,pc,r12=1
8000edea:	d7 03       	nop

8000edec <_free_r>:
8000edec:	d4 21       	pushm	r4-r7,lr
8000edee:	16 96       	mov	r6,r11
8000edf0:	18 97       	mov	r7,r12
8000edf2:	58 0b       	cp.w	r11,0
8000edf4:	e0 80 00 c0 	breq	8000ef74 <_free_r+0x188>
8000edf8:	fe b0 cd 62 	rcall	800088bc <__malloc_lock>
8000edfc:	20 86       	sub	r6,8
8000edfe:	e0 6a 05 50 	mov	r10,1360
8000ee02:	6c 18       	ld.w	r8,r6[0x4]
8000ee04:	74 2e       	ld.w	lr,r10[0x8]
8000ee06:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
8000ee0a:	a1 c8       	cbr	r8,0x0
8000ee0c:	ec 08 00 09 	add	r9,r6,r8
8000ee10:	72 1b       	ld.w	r11,r9[0x4]
8000ee12:	e0 1b ff fc 	andl	r11,0xfffc
8000ee16:	1c 39       	cp.w	r9,lr
8000ee18:	c1 e1       	brne	8000ee54 <_free_r+0x68>
8000ee1a:	f6 08 00 08 	add	r8,r11,r8
8000ee1e:	58 0c       	cp.w	r12,0
8000ee20:	c0 81       	brne	8000ee30 <_free_r+0x44>
8000ee22:	6c 09       	ld.w	r9,r6[0x0]
8000ee24:	12 16       	sub	r6,r9
8000ee26:	12 08       	add	r8,r9
8000ee28:	6c 3b       	ld.w	r11,r6[0xc]
8000ee2a:	6c 29       	ld.w	r9,r6[0x8]
8000ee2c:	97 29       	st.w	r11[0x8],r9
8000ee2e:	93 3b       	st.w	r9[0xc],r11
8000ee30:	10 99       	mov	r9,r8
8000ee32:	95 26       	st.w	r10[0x8],r6
8000ee34:	a1 a9       	sbr	r9,0x0
8000ee36:	8d 19       	st.w	r6[0x4],r9
8000ee38:	e0 69 09 58 	mov	r9,2392
8000ee3c:	72 09       	ld.w	r9,r9[0x0]
8000ee3e:	12 38       	cp.w	r8,r9
8000ee40:	c0 63       	brcs	8000ee4c <_free_r+0x60>
8000ee42:	e0 68 0d 70 	mov	r8,3440
8000ee46:	0e 9c       	mov	r12,r7
8000ee48:	70 0b       	ld.w	r11,r8[0x0]
8000ee4a:	c8 5f       	rcall	8000ed54 <_malloc_trim_r>
8000ee4c:	0e 9c       	mov	r12,r7
8000ee4e:	fe b0 cd 45 	rcall	800088d8 <__malloc_unlock>
8000ee52:	d8 22       	popm	r4-r7,pc
8000ee54:	93 1b       	st.w	r9[0x4],r11
8000ee56:	58 0c       	cp.w	r12,0
8000ee58:	c0 30       	breq	8000ee5e <_free_r+0x72>
8000ee5a:	30 0c       	mov	r12,0
8000ee5c:	c1 08       	rjmp	8000ee7c <_free_r+0x90>
8000ee5e:	6c 0e       	ld.w	lr,r6[0x0]
8000ee60:	f4 c5 ff f8 	sub	r5,r10,-8
8000ee64:	1c 16       	sub	r6,lr
8000ee66:	1c 08       	add	r8,lr
8000ee68:	6c 2e       	ld.w	lr,r6[0x8]
8000ee6a:	0a 3e       	cp.w	lr,r5
8000ee6c:	f9 bc 00 01 	moveq	r12,1
8000ee70:	ed f5 10 03 	ld.wne	r5,r6[0xc]
8000ee74:	eb fe 1a 02 	st.wne	r5[0x8],lr
8000ee78:	fd f5 1a 03 	st.wne	lr[0xc],r5
8000ee7c:	f2 0b 00 0e 	add	lr,r9,r11
8000ee80:	7c 1e       	ld.w	lr,lr[0x4]
8000ee82:	ed be 00 00 	bld	lr,0x0
8000ee86:	c1 40       	breq	8000eeae <_free_r+0xc2>
8000ee88:	16 08       	add	r8,r11
8000ee8a:	58 0c       	cp.w	r12,0
8000ee8c:	c0 d1       	brne	8000eea6 <_free_r+0xba>
8000ee8e:	e0 6e 05 50 	mov	lr,1360
8000ee92:	72 2b       	ld.w	r11,r9[0x8]
8000ee94:	2f 8e       	sub	lr,-8
8000ee96:	1c 3b       	cp.w	r11,lr
8000ee98:	c0 71       	brne	8000eea6 <_free_r+0xba>
8000ee9a:	97 36       	st.w	r11[0xc],r6
8000ee9c:	97 26       	st.w	r11[0x8],r6
8000ee9e:	8d 2b       	st.w	r6[0x8],r11
8000eea0:	8d 3b       	st.w	r6[0xc],r11
8000eea2:	30 1c       	mov	r12,1
8000eea4:	c0 58       	rjmp	8000eeae <_free_r+0xc2>
8000eea6:	72 2b       	ld.w	r11,r9[0x8]
8000eea8:	72 39       	ld.w	r9,r9[0xc]
8000eeaa:	93 2b       	st.w	r9[0x8],r11
8000eeac:	97 39       	st.w	r11[0xc],r9
8000eeae:	10 99       	mov	r9,r8
8000eeb0:	ec 08 09 08 	st.w	r6[r8],r8
8000eeb4:	a1 a9       	sbr	r9,0x0
8000eeb6:	8d 19       	st.w	r6[0x4],r9
8000eeb8:	58 0c       	cp.w	r12,0
8000eeba:	c5 a1       	brne	8000ef6e <_free_r+0x182>
8000eebc:	e0 48 01 ff 	cp.w	r8,511
8000eec0:	e0 8b 00 13 	brhi	8000eee6 <_free_r+0xfa>
8000eec4:	a3 98       	lsr	r8,0x3
8000eec6:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000eeca:	72 2b       	ld.w	r11,r9[0x8]
8000eecc:	8d 39       	st.w	r6[0xc],r9
8000eece:	8d 2b       	st.w	r6[0x8],r11
8000eed0:	97 36       	st.w	r11[0xc],r6
8000eed2:	93 26       	st.w	r9[0x8],r6
8000eed4:	a3 48       	asr	r8,0x2
8000eed6:	74 19       	ld.w	r9,r10[0x4]
8000eed8:	30 1b       	mov	r11,1
8000eeda:	f6 08 09 48 	lsl	r8,r11,r8
8000eede:	f3 e8 10 08 	or	r8,r9,r8
8000eee2:	95 18       	st.w	r10[0x4],r8
8000eee4:	c4 58       	rjmp	8000ef6e <_free_r+0x182>
8000eee6:	f0 0b 16 09 	lsr	r11,r8,0x9
8000eeea:	58 4b       	cp.w	r11,4
8000eeec:	e0 8b 00 06 	brhi	8000eef8 <_free_r+0x10c>
8000eef0:	f0 0b 16 06 	lsr	r11,r8,0x6
8000eef4:	2c 8b       	sub	r11,-56
8000eef6:	c2 08       	rjmp	8000ef36 <_free_r+0x14a>
8000eef8:	59 4b       	cp.w	r11,20
8000eefa:	e0 8b 00 04 	brhi	8000ef02 <_free_r+0x116>
8000eefe:	2a 5b       	sub	r11,-91
8000ef00:	c1 b8       	rjmp	8000ef36 <_free_r+0x14a>
8000ef02:	e0 4b 00 54 	cp.w	r11,84
8000ef06:	e0 8b 00 06 	brhi	8000ef12 <_free_r+0x126>
8000ef0a:	f0 0b 16 0c 	lsr	r11,r8,0xc
8000ef0e:	29 2b       	sub	r11,-110
8000ef10:	c1 38       	rjmp	8000ef36 <_free_r+0x14a>
8000ef12:	e0 4b 01 54 	cp.w	r11,340
8000ef16:	e0 8b 00 06 	brhi	8000ef22 <_free_r+0x136>
8000ef1a:	f0 0b 16 0f 	lsr	r11,r8,0xf
8000ef1e:	28 9b       	sub	r11,-119
8000ef20:	c0 b8       	rjmp	8000ef36 <_free_r+0x14a>
8000ef22:	e0 4b 05 54 	cp.w	r11,1364
8000ef26:	e0 88 00 05 	brls	8000ef30 <_free_r+0x144>
8000ef2a:	37 eb       	mov	r11,126
8000ef2c:	c0 58       	rjmp	8000ef36 <_free_r+0x14a>
8000ef2e:	d7 03       	nop
8000ef30:	f0 0b 16 12 	lsr	r11,r8,0x12
8000ef34:	28 4b       	sub	r11,-124
8000ef36:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
8000ef3a:	78 29       	ld.w	r9,r12[0x8]
8000ef3c:	18 39       	cp.w	r9,r12
8000ef3e:	c0 e1       	brne	8000ef5a <_free_r+0x16e>
8000ef40:	74 18       	ld.w	r8,r10[0x4]
8000ef42:	a3 4b       	asr	r11,0x2
8000ef44:	30 1c       	mov	r12,1
8000ef46:	f8 0b 09 4b 	lsl	r11,r12,r11
8000ef4a:	f1 eb 10 0b 	or	r11,r8,r11
8000ef4e:	12 98       	mov	r8,r9
8000ef50:	95 1b       	st.w	r10[0x4],r11
8000ef52:	c0 a8       	rjmp	8000ef66 <_free_r+0x17a>
8000ef54:	72 29       	ld.w	r9,r9[0x8]
8000ef56:	18 39       	cp.w	r9,r12
8000ef58:	c0 60       	breq	8000ef64 <_free_r+0x178>
8000ef5a:	72 1a       	ld.w	r10,r9[0x4]
8000ef5c:	e0 1a ff fc 	andl	r10,0xfffc
8000ef60:	14 38       	cp.w	r8,r10
8000ef62:	cf 93       	brcs	8000ef54 <_free_r+0x168>
8000ef64:	72 38       	ld.w	r8,r9[0xc]
8000ef66:	8d 38       	st.w	r6[0xc],r8
8000ef68:	8d 29       	st.w	r6[0x8],r9
8000ef6a:	93 36       	st.w	r9[0xc],r6
8000ef6c:	91 26       	st.w	r8[0x8],r6
8000ef6e:	0e 9c       	mov	r12,r7
8000ef70:	fe b0 cc b4 	rcall	800088d8 <__malloc_unlock>
8000ef74:	d8 22       	popm	r4-r7,pc
8000ef76:	d7 03       	nop

8000ef78 <__sfvwrite_r>:
8000ef78:	d4 31       	pushm	r0-r7,lr
8000ef7a:	20 3d       	sub	sp,12
8000ef7c:	14 94       	mov	r4,r10
8000ef7e:	18 95       	mov	r5,r12
8000ef80:	16 97       	mov	r7,r11
8000ef82:	74 28       	ld.w	r8,r10[0x8]
8000ef84:	58 08       	cp.w	r8,0
8000ef86:	e0 80 01 40 	breq	8000f206 <__sfvwrite_r+0x28e>
8000ef8a:	96 68       	ld.sh	r8,r11[0xc]
8000ef8c:	ed b8 00 03 	bld	r8,0x3
8000ef90:	c0 41       	brne	8000ef98 <__sfvwrite_r+0x20>
8000ef92:	76 48       	ld.w	r8,r11[0x10]
8000ef94:	58 08       	cp.w	r8,0
8000ef96:	c0 c1       	brne	8000efae <__sfvwrite_r+0x36>
8000ef98:	0e 9b       	mov	r11,r7
8000ef9a:	0a 9c       	mov	r12,r5
8000ef9c:	fe b0 f6 c4 	rcall	8000dd24 <__swsetup_r>
8000efa0:	c0 70       	breq	8000efae <__sfvwrite_r+0x36>
8000efa2:	8e 68       	ld.sh	r8,r7[0xc]
8000efa4:	a7 a8       	sbr	r8,0x6
8000efa6:	ae 68       	st.h	r7[0xc],r8
8000efa8:	30 98       	mov	r8,9
8000efaa:	8b 38       	st.w	r5[0xc],r8
8000efac:	c2 b9       	rjmp	8000f202 <__sfvwrite_r+0x28a>
8000efae:	8e 63       	ld.sh	r3,r7[0xc]
8000efb0:	68 00       	ld.w	r0,r4[0x0]
8000efb2:	06 96       	mov	r6,r3
8000efb4:	e2 16 00 02 	andl	r6,0x2,COH
8000efb8:	c2 10       	breq	8000effa <__sfvwrite_r+0x82>
8000efba:	30 03       	mov	r3,0
8000efbc:	e0 62 04 00 	mov	r2,1024
8000efc0:	06 96       	mov	r6,r3
8000efc2:	c0 48       	rjmp	8000efca <__sfvwrite_r+0x52>
8000efc4:	60 03       	ld.w	r3,r0[0x0]
8000efc6:	60 16       	ld.w	r6,r0[0x4]
8000efc8:	2f 80       	sub	r0,-8
8000efca:	58 06       	cp.w	r6,0
8000efcc:	cf c0       	breq	8000efc4 <__sfvwrite_r+0x4c>
8000efce:	e0 46 04 00 	cp.w	r6,1024
8000efd2:	ec 09 17 80 	movls	r9,r6
8000efd6:	e4 09 17 b0 	movhi	r9,r2
8000efda:	06 9a       	mov	r10,r3
8000efdc:	6e a8       	ld.w	r8,r7[0x28]
8000efde:	6e 8b       	ld.w	r11,r7[0x20]
8000efe0:	0a 9c       	mov	r12,r5
8000efe2:	5d 18       	icall	r8
8000efe4:	18 16       	sub	r6,r12
8000efe6:	58 0c       	cp.w	r12,0
8000efe8:	e0 8a 01 0a 	brle	8000f1fc <__sfvwrite_r+0x284>
8000efec:	68 28       	ld.w	r8,r4[0x8]
8000efee:	18 18       	sub	r8,r12
8000eff0:	89 28       	st.w	r4[0x8],r8
8000eff2:	e0 80 01 0a 	breq	8000f206 <__sfvwrite_r+0x28e>
8000eff6:	18 03       	add	r3,r12
8000eff8:	ce 9b       	rjmp	8000efca <__sfvwrite_r+0x52>
8000effa:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
8000effe:	c0 70       	breq	8000f00c <__sfvwrite_r+0x94>
8000f000:	50 06       	stdsp	sp[0x0],r6
8000f002:	0c 93       	mov	r3,r6
8000f004:	0c 91       	mov	r1,r6
8000f006:	50 15       	stdsp	sp[0x4],r5
8000f008:	08 92       	mov	r2,r4
8000f00a:	c9 c8       	rjmp	8000f142 <__sfvwrite_r+0x1ca>
8000f00c:	06 96       	mov	r6,r3
8000f00e:	08 91       	mov	r1,r4
8000f010:	c0 48       	rjmp	8000f018 <__sfvwrite_r+0xa0>
8000f012:	60 03       	ld.w	r3,r0[0x0]
8000f014:	60 16       	ld.w	r6,r0[0x4]
8000f016:	2f 80       	sub	r0,-8
8000f018:	58 06       	cp.w	r6,0
8000f01a:	cf c0       	breq	8000f012 <__sfvwrite_r+0x9a>
8000f01c:	8e 68       	ld.sh	r8,r7[0xc]
8000f01e:	6e 24       	ld.w	r4,r7[0x8]
8000f020:	10 99       	mov	r9,r8
8000f022:	e2 19 02 00 	andl	r9,0x200,COH
8000f026:	c5 50       	breq	8000f0d0 <__sfvwrite_r+0x158>
8000f028:	08 36       	cp.w	r6,r4
8000f02a:	c4 43       	brcs	8000f0b2 <__sfvwrite_r+0x13a>
8000f02c:	10 99       	mov	r9,r8
8000f02e:	e2 19 04 80 	andl	r9,0x480,COH
8000f032:	c4 00       	breq	8000f0b2 <__sfvwrite_r+0x13a>
8000f034:	6e 4b       	ld.w	r11,r7[0x10]
8000f036:	6e 09       	ld.w	r9,r7[0x0]
8000f038:	16 19       	sub	r9,r11
8000f03a:	50 09       	stdsp	sp[0x0],r9
8000f03c:	6e 59       	ld.w	r9,r7[0x14]
8000f03e:	10 9c       	mov	r12,r8
8000f040:	f2 09 00 1a 	add	r10,r9,r9<<0x1
8000f044:	30 28       	mov	r8,2
8000f046:	f4 08 0c 08 	divs	r8,r10,r8
8000f04a:	fa e9 00 04 	st.d	sp[4],r8
8000f04e:	10 94       	mov	r4,r8
8000f050:	40 09       	lddsp	r9,sp[0x0]
8000f052:	e2 1c 04 00 	andl	r12,0x400,COH
8000f056:	2f f9       	sub	r9,-1
8000f058:	0c 09       	add	r9,r6
8000f05a:	12 38       	cp.w	r8,r9
8000f05c:	f2 04 17 30 	movlo	r4,r9
8000f060:	58 0c       	cp.w	r12,0
8000f062:	c1 10       	breq	8000f084 <__sfvwrite_r+0x10c>
8000f064:	08 9b       	mov	r11,r4
8000f066:	0a 9c       	mov	r12,r5
8000f068:	fe b0 e0 4e 	rcall	8000b104 <_malloc_r>
8000f06c:	18 92       	mov	r2,r12
8000f06e:	c1 40       	breq	8000f096 <__sfvwrite_r+0x11e>
8000f070:	40 0a       	lddsp	r10,sp[0x0]
8000f072:	6e 4b       	ld.w	r11,r7[0x10]
8000f074:	fe b0 e2 77 	rcall	8000b562 <memcpy>
8000f078:	8e 68       	ld.sh	r8,r7[0xc]
8000f07a:	e0 18 fb 7f 	andl	r8,0xfb7f
8000f07e:	a7 b8       	sbr	r8,0x7
8000f080:	ae 68       	st.h	r7[0xc],r8
8000f082:	c0 d8       	rjmp	8000f09c <__sfvwrite_r+0x124>
8000f084:	08 9a       	mov	r10,r4
8000f086:	0a 9c       	mov	r12,r5
8000f088:	fe b0 e3 18 	rcall	8000b6b8 <_realloc_r>
8000f08c:	18 92       	mov	r2,r12
8000f08e:	c0 71       	brne	8000f09c <__sfvwrite_r+0x124>
8000f090:	6e 4b       	ld.w	r11,r7[0x10]
8000f092:	0a 9c       	mov	r12,r5
8000f094:	ca ce       	rcall	8000edec <_free_r>
8000f096:	30 c8       	mov	r8,12
8000f098:	8b 38       	st.w	r5[0xc],r8
8000f09a:	cb 18       	rjmp	8000f1fc <__sfvwrite_r+0x284>
8000f09c:	40 0a       	lddsp	r10,sp[0x0]
8000f09e:	40 09       	lddsp	r9,sp[0x0]
8000f0a0:	e8 0a 01 0a 	sub	r10,r4,r10
8000f0a4:	e4 09 00 08 	add	r8,r2,r9
8000f0a8:	8f 54       	st.w	r7[0x14],r4
8000f0aa:	8f 2a       	st.w	r7[0x8],r10
8000f0ac:	8f 08       	st.w	r7[0x0],r8
8000f0ae:	8f 42       	st.w	r7[0x10],r2
8000f0b0:	0c 94       	mov	r4,r6
8000f0b2:	08 36       	cp.w	r6,r4
8000f0b4:	ec 04 17 30 	movlo	r4,r6
8000f0b8:	06 9b       	mov	r11,r3
8000f0ba:	08 9a       	mov	r10,r4
8000f0bc:	6e 0c       	ld.w	r12,r7[0x0]
8000f0be:	c3 ad       	rcall	8000f332 <memmove>
8000f0c0:	6e 08       	ld.w	r8,r7[0x0]
8000f0c2:	08 08       	add	r8,r4
8000f0c4:	8f 08       	st.w	r7[0x0],r8
8000f0c6:	6e 28       	ld.w	r8,r7[0x8]
8000f0c8:	08 18       	sub	r8,r4
8000f0ca:	0c 94       	mov	r4,r6
8000f0cc:	8f 28       	st.w	r7[0x8],r8
8000f0ce:	c2 e8       	rjmp	8000f12a <__sfvwrite_r+0x1b2>
8000f0d0:	08 36       	cp.w	r6,r4
8000f0d2:	5f ba       	srhi	r10
8000f0d4:	6e 0c       	ld.w	r12,r7[0x0]
8000f0d6:	6e 48       	ld.w	r8,r7[0x10]
8000f0d8:	10 3c       	cp.w	r12,r8
8000f0da:	5f b8       	srhi	r8
8000f0dc:	f5 e8 00 08 	and	r8,r10,r8
8000f0e0:	f2 08 18 00 	cp.b	r8,r9
8000f0e4:	c0 d0       	breq	8000f0fe <__sfvwrite_r+0x186>
8000f0e6:	06 9b       	mov	r11,r3
8000f0e8:	08 9a       	mov	r10,r4
8000f0ea:	c2 4d       	rcall	8000f332 <memmove>
8000f0ec:	6e 08       	ld.w	r8,r7[0x0]
8000f0ee:	08 08       	add	r8,r4
8000f0f0:	0e 9b       	mov	r11,r7
8000f0f2:	8f 08       	st.w	r7[0x0],r8
8000f0f4:	0a 9c       	mov	r12,r5
8000f0f6:	fe b0 fd 09 	rcall	8000eb08 <_fflush_r>
8000f0fa:	c1 80       	breq	8000f12a <__sfvwrite_r+0x1b2>
8000f0fc:	c8 08       	rjmp	8000f1fc <__sfvwrite_r+0x284>
8000f0fe:	6e 59       	ld.w	r9,r7[0x14]
8000f100:	12 36       	cp.w	r6,r9
8000f102:	c0 a3       	brcs	8000f116 <__sfvwrite_r+0x19e>
8000f104:	6e a8       	ld.w	r8,r7[0x28]
8000f106:	06 9a       	mov	r10,r3
8000f108:	6e 8b       	ld.w	r11,r7[0x20]
8000f10a:	0a 9c       	mov	r12,r5
8000f10c:	5d 18       	icall	r8
8000f10e:	18 94       	mov	r4,r12
8000f110:	e0 89 00 0d 	brgt	8000f12a <__sfvwrite_r+0x1b2>
8000f114:	c7 48       	rjmp	8000f1fc <__sfvwrite_r+0x284>
8000f116:	0c 9a       	mov	r10,r6
8000f118:	06 9b       	mov	r11,r3
8000f11a:	c0 cd       	rcall	8000f332 <memmove>
8000f11c:	6e 08       	ld.w	r8,r7[0x0]
8000f11e:	0c 08       	add	r8,r6
8000f120:	0c 94       	mov	r4,r6
8000f122:	8f 08       	st.w	r7[0x0],r8
8000f124:	6e 28       	ld.w	r8,r7[0x8]
8000f126:	0c 18       	sub	r8,r6
8000f128:	8f 28       	st.w	r7[0x8],r8
8000f12a:	62 28       	ld.w	r8,r1[0x8]
8000f12c:	08 18       	sub	r8,r4
8000f12e:	83 28       	st.w	r1[0x8],r8
8000f130:	c6 b0       	breq	8000f206 <__sfvwrite_r+0x28e>
8000f132:	08 16       	sub	r6,r4
8000f134:	08 03       	add	r3,r4
8000f136:	c7 1b       	rjmp	8000f018 <__sfvwrite_r+0xa0>
8000f138:	60 03       	ld.w	r3,r0[0x0]
8000f13a:	60 11       	ld.w	r1,r0[0x4]
8000f13c:	30 08       	mov	r8,0
8000f13e:	2f 80       	sub	r0,-8
8000f140:	50 08       	stdsp	sp[0x0],r8
8000f142:	58 01       	cp.w	r1,0
8000f144:	cf a0       	breq	8000f138 <__sfvwrite_r+0x1c0>
8000f146:	40 0a       	lddsp	r10,sp[0x0]
8000f148:	58 0a       	cp.w	r10,0
8000f14a:	c1 41       	brne	8000f172 <__sfvwrite_r+0x1fa>
8000f14c:	e2 c6 ff ff 	sub	r6,r1,-1
8000f150:	02 9a       	mov	r10,r1
8000f152:	30 ab       	mov	r11,10
8000f154:	06 9c       	mov	r12,r3
8000f156:	ce 3c       	rcall	8000f31c <memchr>
8000f158:	f8 c8 ff ff 	sub	r8,r12,-1
8000f15c:	58 0c       	cp.w	r12,0
8000f15e:	f1 d3 e1 16 	subne	r6,r8,r3
8000f162:	f9 b9 01 01 	movne	r9,1
8000f166:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000f16a:	f9 b8 00 01 	moveq	r8,1
8000f16e:	fb f8 0a 00 	st.weq	sp[0x0],r8
8000f172:	02 36       	cp.w	r6,r1
8000f174:	ec 04 17 80 	movls	r4,r6
8000f178:	e2 04 17 b0 	movhi	r4,r1
8000f17c:	6e 59       	ld.w	r9,r7[0x14]
8000f17e:	6e 25       	ld.w	r5,r7[0x8]
8000f180:	f2 05 00 05 	add	r5,r9,r5
8000f184:	0a 34       	cp.w	r4,r5
8000f186:	5f 9a       	srgt	r10
8000f188:	6e 0c       	ld.w	r12,r7[0x0]
8000f18a:	6e 48       	ld.w	r8,r7[0x10]
8000f18c:	10 3c       	cp.w	r12,r8
8000f18e:	5f b8       	srhi	r8
8000f190:	f5 e8 00 08 	and	r8,r10,r8
8000f194:	30 0a       	mov	r10,0
8000f196:	f4 08 18 00 	cp.b	r8,r10
8000f19a:	c0 d0       	breq	8000f1b4 <__sfvwrite_r+0x23c>
8000f19c:	06 9b       	mov	r11,r3
8000f19e:	0a 9a       	mov	r10,r5
8000f1a0:	cc 9c       	rcall	8000f332 <memmove>
8000f1a2:	6e 08       	ld.w	r8,r7[0x0]
8000f1a4:	0a 08       	add	r8,r5
8000f1a6:	0e 9b       	mov	r11,r7
8000f1a8:	8f 08       	st.w	r7[0x0],r8
8000f1aa:	40 1c       	lddsp	r12,sp[0x4]
8000f1ac:	fe b0 fc ae 	rcall	8000eb08 <_fflush_r>
8000f1b0:	c1 70       	breq	8000f1de <__sfvwrite_r+0x266>
8000f1b2:	c2 58       	rjmp	8000f1fc <__sfvwrite_r+0x284>
8000f1b4:	12 34       	cp.w	r4,r9
8000f1b6:	c0 a5       	brlt	8000f1ca <__sfvwrite_r+0x252>
8000f1b8:	6e a8       	ld.w	r8,r7[0x28]
8000f1ba:	06 9a       	mov	r10,r3
8000f1bc:	6e 8b       	ld.w	r11,r7[0x20]
8000f1be:	40 1c       	lddsp	r12,sp[0x4]
8000f1c0:	5d 18       	icall	r8
8000f1c2:	18 95       	mov	r5,r12
8000f1c4:	e0 89 00 0d 	brgt	8000f1de <__sfvwrite_r+0x266>
8000f1c8:	c1 a8       	rjmp	8000f1fc <__sfvwrite_r+0x284>
8000f1ca:	08 9a       	mov	r10,r4
8000f1cc:	06 9b       	mov	r11,r3
8000f1ce:	cb 2c       	rcall	8000f332 <memmove>
8000f1d0:	6e 08       	ld.w	r8,r7[0x0]
8000f1d2:	08 08       	add	r8,r4
8000f1d4:	08 95       	mov	r5,r4
8000f1d6:	8f 08       	st.w	r7[0x0],r8
8000f1d8:	6e 28       	ld.w	r8,r7[0x8]
8000f1da:	08 18       	sub	r8,r4
8000f1dc:	8f 28       	st.w	r7[0x8],r8
8000f1de:	0a 16       	sub	r6,r5
8000f1e0:	c0 71       	brne	8000f1ee <__sfvwrite_r+0x276>
8000f1e2:	0e 9b       	mov	r11,r7
8000f1e4:	40 1c       	lddsp	r12,sp[0x4]
8000f1e6:	fe b0 fc 91 	rcall	8000eb08 <_fflush_r>
8000f1ea:	c0 91       	brne	8000f1fc <__sfvwrite_r+0x284>
8000f1ec:	50 06       	stdsp	sp[0x0],r6
8000f1ee:	64 28       	ld.w	r8,r2[0x8]
8000f1f0:	0a 18       	sub	r8,r5
8000f1f2:	85 28       	st.w	r2[0x8],r8
8000f1f4:	c0 90       	breq	8000f206 <__sfvwrite_r+0x28e>
8000f1f6:	0a 11       	sub	r1,r5
8000f1f8:	0a 03       	add	r3,r5
8000f1fa:	ca 4b       	rjmp	8000f142 <__sfvwrite_r+0x1ca>
8000f1fc:	8e 68       	ld.sh	r8,r7[0xc]
8000f1fe:	a7 a8       	sbr	r8,0x6
8000f200:	ae 68       	st.h	r7[0xc],r8
8000f202:	3f fc       	mov	r12,-1
8000f204:	c0 28       	rjmp	8000f208 <__sfvwrite_r+0x290>
8000f206:	30 0c       	mov	r12,0
8000f208:	2f dd       	sub	sp,-12
8000f20a:	d8 32       	popm	r0-r7,pc

8000f20c <_fwalk>:
8000f20c:	d4 31       	pushm	r0-r7,lr
8000f20e:	30 05       	mov	r5,0
8000f210:	16 91       	mov	r1,r11
8000f212:	f8 c7 ff 28 	sub	r7,r12,-216
8000f216:	0a 92       	mov	r2,r5
8000f218:	fe b0 fc fe 	rcall	8000ec14 <__sfp_lock_acquire>
8000f21c:	3f f3       	mov	r3,-1
8000f21e:	c1 68       	rjmp	8000f24a <_fwalk+0x3e>
8000f220:	6e 26       	ld.w	r6,r7[0x8]
8000f222:	6e 14       	ld.w	r4,r7[0x4]
8000f224:	2f 46       	sub	r6,-12
8000f226:	c0 c8       	rjmp	8000f23e <_fwalk+0x32>
8000f228:	8c 08       	ld.sh	r8,r6[0x0]
8000f22a:	e4 08 19 00 	cp.h	r8,r2
8000f22e:	c0 70       	breq	8000f23c <_fwalk+0x30>
8000f230:	8c 18       	ld.sh	r8,r6[0x2]
8000f232:	e6 08 19 00 	cp.h	r8,r3
8000f236:	c0 30       	breq	8000f23c <_fwalk+0x30>
8000f238:	5d 11       	icall	r1
8000f23a:	18 45       	or	r5,r12
8000f23c:	2a 46       	sub	r6,-92
8000f23e:	20 14       	sub	r4,1
8000f240:	ec cc 00 0c 	sub	r12,r6,12
8000f244:	58 04       	cp.w	r4,0
8000f246:	cf 14       	brge	8000f228 <_fwalk+0x1c>
8000f248:	6e 07       	ld.w	r7,r7[0x0]
8000f24a:	58 07       	cp.w	r7,0
8000f24c:	ce a1       	brne	8000f220 <_fwalk+0x14>
8000f24e:	fe b0 fc e4 	rcall	8000ec16 <__sfp_lock_release>
8000f252:	0a 9c       	mov	r12,r5
8000f254:	d8 32       	popm	r0-r7,pc
8000f256:	d7 03       	nop

8000f258 <_localeconv_r>:
8000f258:	fe cc d8 48 	sub	r12,pc,-10168
8000f25c:	5e fc       	retal	r12
8000f25e:	d7 03       	nop

8000f260 <__smakebuf_r>:
8000f260:	d4 21       	pushm	r4-r7,lr
8000f262:	20 fd       	sub	sp,60
8000f264:	96 68       	ld.sh	r8,r11[0xc]
8000f266:	16 97       	mov	r7,r11
8000f268:	18 96       	mov	r6,r12
8000f26a:	e2 18 00 02 	andl	r8,0x2,COH
8000f26e:	c3 d1       	brne	8000f2e8 <__smakebuf_r+0x88>
8000f270:	96 7b       	ld.sh	r11,r11[0xe]
8000f272:	f0 0b 19 00 	cp.h	r11,r8
8000f276:	c0 55       	brlt	8000f280 <__smakebuf_r+0x20>
8000f278:	1a 9a       	mov	r10,sp
8000f27a:	e0 a0 04 75 	rcall	8000fb64 <_fstat_r>
8000f27e:	c0 f4       	brge	8000f29c <__smakebuf_r+0x3c>
8000f280:	8e 65       	ld.sh	r5,r7[0xc]
8000f282:	0a 98       	mov	r8,r5
8000f284:	ab b8       	sbr	r8,0xb
8000f286:	e2 15 00 80 	andl	r5,0x80,COH
8000f28a:	ae 68       	st.h	r7[0xc],r8
8000f28c:	30 04       	mov	r4,0
8000f28e:	e0 68 04 00 	mov	r8,1024
8000f292:	f9 b5 01 40 	movne	r5,64
8000f296:	f0 05 17 00 	moveq	r5,r8
8000f29a:	c1 c8       	rjmp	8000f2d2 <__smakebuf_r+0x72>
8000f29c:	40 18       	lddsp	r8,sp[0x4]
8000f29e:	e2 18 f0 00 	andl	r8,0xf000,COH
8000f2a2:	e0 48 20 00 	cp.w	r8,8192
8000f2a6:	5f 04       	sreq	r4
8000f2a8:	e0 48 80 00 	cp.w	r8,32768
8000f2ac:	c0 e1       	brne	8000f2c8 <__smakebuf_r+0x68>
8000f2ae:	6e b9       	ld.w	r9,r7[0x2c]
8000f2b0:	fe c8 f9 1c 	sub	r8,pc,-1764
8000f2b4:	10 39       	cp.w	r9,r8
8000f2b6:	c0 91       	brne	8000f2c8 <__smakebuf_r+0x68>
8000f2b8:	8e 68       	ld.sh	r8,r7[0xc]
8000f2ba:	e0 65 04 00 	mov	r5,1024
8000f2be:	ab a8       	sbr	r8,0xa
8000f2c0:	ef 45 00 50 	st.w	r7[80],r5
8000f2c4:	ae 68       	st.h	r7[0xc],r8
8000f2c6:	c0 68       	rjmp	8000f2d2 <__smakebuf_r+0x72>
8000f2c8:	8e 68       	ld.sh	r8,r7[0xc]
8000f2ca:	e0 65 04 00 	mov	r5,1024
8000f2ce:	ab b8       	sbr	r8,0xb
8000f2d0:	ae 68       	st.h	r7[0xc],r8
8000f2d2:	0a 9b       	mov	r11,r5
8000f2d4:	0c 9c       	mov	r12,r6
8000f2d6:	fe b0 df 17 	rcall	8000b104 <_malloc_r>
8000f2da:	8e 68       	ld.sh	r8,r7[0xc]
8000f2dc:	c0 d1       	brne	8000f2f6 <__smakebuf_r+0x96>
8000f2de:	ed b8 00 09 	bld	r8,0x9
8000f2e2:	c1 b0       	breq	8000f318 <__smakebuf_r+0xb8>
8000f2e4:	a1 b8       	sbr	r8,0x1
8000f2e6:	ae 68       	st.h	r7[0xc],r8
8000f2e8:	ee c8 ff b9 	sub	r8,r7,-71
8000f2ec:	8f 48       	st.w	r7[0x10],r8
8000f2ee:	8f 08       	st.w	r7[0x0],r8
8000f2f0:	30 18       	mov	r8,1
8000f2f2:	8f 58       	st.w	r7[0x14],r8
8000f2f4:	c1 28       	rjmp	8000f318 <__smakebuf_r+0xb8>
8000f2f6:	a7 b8       	sbr	r8,0x7
8000f2f8:	8f 4c       	st.w	r7[0x10],r12
8000f2fa:	ae 68       	st.h	r7[0xc],r8
8000f2fc:	8f 55       	st.w	r7[0x14],r5
8000f2fe:	fe c8 06 e6 	sub	r8,pc,1766
8000f302:	8f 0c       	st.w	r7[0x0],r12
8000f304:	8d a8       	st.w	r6[0x28],r8
8000f306:	58 04       	cp.w	r4,0
8000f308:	c0 80       	breq	8000f318 <__smakebuf_r+0xb8>
8000f30a:	8e 7c       	ld.sh	r12,r7[0xe]
8000f30c:	fe b0 e3 94 	rcall	8000ba34 <isatty>
8000f310:	c0 40       	breq	8000f318 <__smakebuf_r+0xb8>
8000f312:	8e 68       	ld.sh	r8,r7[0xc]
8000f314:	a1 a8       	sbr	r8,0x0
8000f316:	ae 68       	st.h	r7[0xc],r8
8000f318:	2f 1d       	sub	sp,-60
8000f31a:	d8 22       	popm	r4-r7,pc

8000f31c <memchr>:
8000f31c:	f7 db c0 08 	bfextu	r11,r11,0x0,0x8
8000f320:	c0 68       	rjmp	8000f32c <memchr+0x10>
8000f322:	20 1a       	sub	r10,1
8000f324:	19 88       	ld.ub	r8,r12[0x0]
8000f326:	16 38       	cp.w	r8,r11
8000f328:	5e 0c       	reteq	r12
8000f32a:	2f fc       	sub	r12,-1
8000f32c:	58 0a       	cp.w	r10,0
8000f32e:	cf a1       	brne	8000f322 <memchr+0x6>
8000f330:	5e fa       	retal	r10

8000f332 <memmove>:
8000f332:	d4 01       	pushm	lr
8000f334:	18 3b       	cp.w	r11,r12
8000f336:	c1 92       	brcc	8000f368 <memmove+0x36>
8000f338:	f6 0a 00 09 	add	r9,r11,r10
8000f33c:	12 3c       	cp.w	r12,r9
8000f33e:	c1 52       	brcc	8000f368 <memmove+0x36>
8000f340:	f8 0a 00 0b 	add	r11,r12,r10
8000f344:	30 08       	mov	r8,0
8000f346:	c0 68       	rjmp	8000f352 <memmove+0x20>
8000f348:	f2 08 07 0e 	ld.ub	lr,r9[r8]
8000f34c:	20 1a       	sub	r10,1
8000f34e:	f6 08 0b 0e 	st.b	r11[r8],lr
8000f352:	20 18       	sub	r8,1
8000f354:	58 0a       	cp.w	r10,0
8000f356:	cf 91       	brne	8000f348 <memmove+0x16>
8000f358:	d8 02       	popm	pc
8000f35a:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000f35e:	20 1a       	sub	r10,1
8000f360:	f8 08 0b 09 	st.b	r12[r8],r9
8000f364:	2f f8       	sub	r8,-1
8000f366:	c0 28       	rjmp	8000f36a <memmove+0x38>
8000f368:	30 08       	mov	r8,0
8000f36a:	58 0a       	cp.w	r10,0
8000f36c:	cf 71       	brne	8000f35a <memmove+0x28>
8000f36e:	d8 02       	popm	pc

8000f370 <__hi0bits>:
8000f370:	18 98       	mov	r8,r12
8000f372:	e0 1c 00 00 	andl	r12,0x0
8000f376:	f0 09 15 10 	lsl	r9,r8,0x10
8000f37a:	58 0c       	cp.w	r12,0
8000f37c:	f2 08 17 00 	moveq	r8,r9
8000f380:	f9 bc 00 10 	moveq	r12,16
8000f384:	f9 bc 01 00 	movne	r12,0
8000f388:	10 9a       	mov	r10,r8
8000f38a:	f0 09 15 08 	lsl	r9,r8,0x8
8000f38e:	e6 1a ff 00 	andh	r10,0xff00,COH
8000f392:	f7 bc 00 f8 	subeq	r12,-8
8000f396:	f2 08 17 00 	moveq	r8,r9
8000f39a:	10 9a       	mov	r10,r8
8000f39c:	f0 09 15 04 	lsl	r9,r8,0x4
8000f3a0:	e6 1a f0 00 	andh	r10,0xf000,COH
8000f3a4:	f7 bc 00 fc 	subeq	r12,-4
8000f3a8:	f2 08 17 00 	moveq	r8,r9
8000f3ac:	10 9a       	mov	r10,r8
8000f3ae:	f0 09 15 02 	lsl	r9,r8,0x2
8000f3b2:	e6 1a c0 00 	andh	r10,0xc000,COH
8000f3b6:	f7 bc 00 fe 	subeq	r12,-2
8000f3ba:	f2 08 17 00 	moveq	r8,r9
8000f3be:	58 08       	cp.w	r8,0
8000f3c0:	5e 5c       	retlt	r12
8000f3c2:	ed b8 00 1e 	bld	r8,0x1e
8000f3c6:	f9 bc 01 20 	movne	r12,32
8000f3ca:	f7 bc 00 ff 	subeq	r12,-1
8000f3ce:	5e fc       	retal	r12

8000f3d0 <__lo0bits>:
8000f3d0:	18 99       	mov	r9,r12
8000f3d2:	78 08       	ld.w	r8,r12[0x0]
8000f3d4:	f9 d8 c0 03 	bfextu	r12,r8,0x0,0x3
8000f3d8:	c1 50       	breq	8000f402 <__lo0bits+0x32>
8000f3da:	ed b8 00 00 	bld	r8,0x0
8000f3de:	c0 21       	brne	8000f3e2 <__lo0bits+0x12>
8000f3e0:	5e fd       	retal	0
8000f3e2:	10 9b       	mov	r11,r8
8000f3e4:	f0 0a 16 01 	lsr	r10,r8,0x1
8000f3e8:	e2 1b 00 02 	andl	r11,0x2,COH
8000f3ec:	a3 88       	lsr	r8,0x2
8000f3ee:	58 0b       	cp.w	r11,0
8000f3f0:	f3 fa 1a 00 	st.wne	r9[0x0],r10
8000f3f4:	f9 bc 01 01 	movne	r12,1
8000f3f8:	f3 f8 0a 00 	st.weq	r9[0x0],r8
8000f3fc:	f9 bc 00 02 	moveq	r12,2
8000f400:	5e fc       	retal	r12
8000f402:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8000f406:	f0 0b 16 10 	lsr	r11,r8,0x10
8000f40a:	58 0a       	cp.w	r10,0
8000f40c:	f6 08 17 00 	moveq	r8,r11
8000f410:	f9 bc 00 10 	moveq	r12,16
8000f414:	f7 d8 c0 08 	bfextu	r11,r8,0x0,0x8
8000f418:	f0 0a 16 08 	lsr	r10,r8,0x8
8000f41c:	58 0b       	cp.w	r11,0
8000f41e:	f7 bc 00 f8 	subeq	r12,-8
8000f422:	f4 08 17 00 	moveq	r8,r10
8000f426:	f7 d8 c0 04 	bfextu	r11,r8,0x0,0x4
8000f42a:	f0 0a 16 04 	lsr	r10,r8,0x4
8000f42e:	58 0b       	cp.w	r11,0
8000f430:	f7 bc 00 fc 	subeq	r12,-4
8000f434:	f4 08 17 00 	moveq	r8,r10
8000f438:	f7 d8 c0 02 	bfextu	r11,r8,0x0,0x2
8000f43c:	f0 0a 16 02 	lsr	r10,r8,0x2
8000f440:	58 0b       	cp.w	r11,0
8000f442:	f7 bc 00 fe 	subeq	r12,-2
8000f446:	f4 08 17 00 	moveq	r8,r10
8000f44a:	ed b8 00 00 	bld	r8,0x0
8000f44e:	c0 60       	breq	8000f45a <__lo0bits+0x8a>
8000f450:	a1 98       	lsr	r8,0x1
8000f452:	c0 31       	brne	8000f458 <__lo0bits+0x88>
8000f454:	32 0c       	mov	r12,32
8000f456:	5e fc       	retal	r12
8000f458:	2f fc       	sub	r12,-1
8000f45a:	93 08       	st.w	r9[0x0],r8
8000f45c:	5e fc       	retal	r12

8000f45e <__mcmp>:
8000f45e:	d4 01       	pushm	lr
8000f460:	18 98       	mov	r8,r12
8000f462:	76 49       	ld.w	r9,r11[0x10]
8000f464:	78 4c       	ld.w	r12,r12[0x10]
8000f466:	12 1c       	sub	r12,r9
8000f468:	c1 31       	brne	8000f48e <__mcmp+0x30>
8000f46a:	2f b9       	sub	r9,-5
8000f46c:	a3 69       	lsl	r9,0x2
8000f46e:	12 0b       	add	r11,r9
8000f470:	f0 09 00 09 	add	r9,r8,r9
8000f474:	2e c8       	sub	r8,-20
8000f476:	13 4e       	ld.w	lr,--r9
8000f478:	17 4a       	ld.w	r10,--r11
8000f47a:	14 3e       	cp.w	lr,r10
8000f47c:	c0 60       	breq	8000f488 <__mcmp+0x2a>
8000f47e:	f9 bc 03 ff 	movlo	r12,-1
8000f482:	f9 bc 02 01 	movhs	r12,1
8000f486:	d8 02       	popm	pc
8000f488:	10 39       	cp.w	r9,r8
8000f48a:	fe 9b ff f6 	brhi	8000f476 <__mcmp+0x18>
8000f48e:	d8 02       	popm	pc

8000f490 <_Bfree>:
8000f490:	d4 21       	pushm	r4-r7,lr
8000f492:	18 97       	mov	r7,r12
8000f494:	16 95       	mov	r5,r11
8000f496:	78 96       	ld.w	r6,r12[0x24]
8000f498:	58 06       	cp.w	r6,0
8000f49a:	c0 91       	brne	8000f4ac <_Bfree+0x1c>
8000f49c:	31 0c       	mov	r12,16
8000f49e:	fe b0 de 2b 	rcall	8000b0f4 <malloc>
8000f4a2:	99 36       	st.w	r12[0xc],r6
8000f4a4:	8f 9c       	st.w	r7[0x24],r12
8000f4a6:	99 16       	st.w	r12[0x4],r6
8000f4a8:	99 26       	st.w	r12[0x8],r6
8000f4aa:	99 06       	st.w	r12[0x0],r6
8000f4ac:	58 05       	cp.w	r5,0
8000f4ae:	c0 90       	breq	8000f4c0 <_Bfree+0x30>
8000f4b0:	6a 19       	ld.w	r9,r5[0x4]
8000f4b2:	6e 98       	ld.w	r8,r7[0x24]
8000f4b4:	70 38       	ld.w	r8,r8[0xc]
8000f4b6:	f0 09 03 2a 	ld.w	r10,r8[r9<<0x2]
8000f4ba:	8b 0a       	st.w	r5[0x0],r10
8000f4bc:	f0 09 09 25 	st.w	r8[r9<<0x2],r5
8000f4c0:	d8 22       	popm	r4-r7,pc
8000f4c2:	d7 03       	nop

8000f4c4 <_Balloc>:
8000f4c4:	d4 21       	pushm	r4-r7,lr
8000f4c6:	18 97       	mov	r7,r12
8000f4c8:	16 96       	mov	r6,r11
8000f4ca:	78 95       	ld.w	r5,r12[0x24]
8000f4cc:	58 05       	cp.w	r5,0
8000f4ce:	c0 91       	brne	8000f4e0 <_Balloc+0x1c>
8000f4d0:	31 0c       	mov	r12,16
8000f4d2:	fe b0 de 11 	rcall	8000b0f4 <malloc>
8000f4d6:	99 35       	st.w	r12[0xc],r5
8000f4d8:	8f 9c       	st.w	r7[0x24],r12
8000f4da:	99 15       	st.w	r12[0x4],r5
8000f4dc:	99 25       	st.w	r12[0x8],r5
8000f4de:	99 05       	st.w	r12[0x0],r5
8000f4e0:	6e 95       	ld.w	r5,r7[0x24]
8000f4e2:	6a 38       	ld.w	r8,r5[0xc]
8000f4e4:	58 08       	cp.w	r8,0
8000f4e6:	c0 b1       	brne	8000f4fc <_Balloc+0x38>
8000f4e8:	31 0a       	mov	r10,16
8000f4ea:	30 4b       	mov	r11,4
8000f4ec:	0e 9c       	mov	r12,r7
8000f4ee:	e0 a0 02 9b 	rcall	8000fa24 <_calloc_r>
8000f4f2:	8b 3c       	st.w	r5[0xc],r12
8000f4f4:	6e 98       	ld.w	r8,r7[0x24]
8000f4f6:	70 3c       	ld.w	r12,r8[0xc]
8000f4f8:	58 0c       	cp.w	r12,0
8000f4fa:	c1 b0       	breq	8000f530 <_Balloc+0x6c>
8000f4fc:	6e 98       	ld.w	r8,r7[0x24]
8000f4fe:	70 38       	ld.w	r8,r8[0xc]
8000f500:	f0 06 00 28 	add	r8,r8,r6<<0x2
8000f504:	70 0c       	ld.w	r12,r8[0x0]
8000f506:	58 0c       	cp.w	r12,0
8000f508:	c0 40       	breq	8000f510 <_Balloc+0x4c>
8000f50a:	78 09       	ld.w	r9,r12[0x0]
8000f50c:	91 09       	st.w	r8[0x0],r9
8000f50e:	c0 e8       	rjmp	8000f52a <_Balloc+0x66>
8000f510:	0e 9c       	mov	r12,r7
8000f512:	30 17       	mov	r7,1
8000f514:	0e 9b       	mov	r11,r7
8000f516:	ee 06 09 47 	lsl	r7,r7,r6
8000f51a:	ee ca ff fb 	sub	r10,r7,-5
8000f51e:	a3 6a       	lsl	r10,0x2
8000f520:	e0 a0 02 82 	rcall	8000fa24 <_calloc_r>
8000f524:	c0 60       	breq	8000f530 <_Balloc+0x6c>
8000f526:	99 16       	st.w	r12[0x4],r6
8000f528:	99 27       	st.w	r12[0x8],r7
8000f52a:	30 08       	mov	r8,0
8000f52c:	99 38       	st.w	r12[0xc],r8
8000f52e:	99 48       	st.w	r12[0x10],r8
8000f530:	d8 22       	popm	r4-r7,pc
8000f532:	d7 03       	nop

8000f534 <__d2b>:
8000f534:	d4 31       	pushm	r0-r7,lr
8000f536:	20 2d       	sub	sp,8
8000f538:	16 93       	mov	r3,r11
8000f53a:	12 96       	mov	r6,r9
8000f53c:	10 95       	mov	r5,r8
8000f53e:	14 92       	mov	r2,r10
8000f540:	30 1b       	mov	r11,1
8000f542:	cc 1f       	rcall	8000f4c4 <_Balloc>
8000f544:	f3 d3 c0 14 	bfextu	r9,r3,0x0,0x14
8000f548:	50 09       	stdsp	sp[0x0],r9
8000f54a:	f1 d3 c0 1f 	bfextu	r8,r3,0x0,0x1f
8000f54e:	b5 a9       	sbr	r9,0x14
8000f550:	f0 01 16 14 	lsr	r1,r8,0x14
8000f554:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000f558:	18 94       	mov	r4,r12
8000f55a:	58 02       	cp.w	r2,0
8000f55c:	c1 d0       	breq	8000f596 <__d2b+0x62>
8000f55e:	fa cc ff f8 	sub	r12,sp,-8
8000f562:	18 d2       	st.w	--r12,r2
8000f564:	c3 6f       	rcall	8000f3d0 <__lo0bits>
8000f566:	40 18       	lddsp	r8,sp[0x4]
8000f568:	c0 d0       	breq	8000f582 <__d2b+0x4e>
8000f56a:	40 09       	lddsp	r9,sp[0x0]
8000f56c:	f8 0a 11 20 	rsub	r10,r12,32
8000f570:	f2 0a 09 4a 	lsl	r10,r9,r10
8000f574:	f5 e8 10 08 	or	r8,r10,r8
8000f578:	89 58       	st.w	r4[0x14],r8
8000f57a:	f2 0c 0a 49 	lsr	r9,r9,r12
8000f57e:	50 09       	stdsp	sp[0x0],r9
8000f580:	c0 28       	rjmp	8000f584 <__d2b+0x50>
8000f582:	89 58       	st.w	r4[0x14],r8
8000f584:	40 08       	lddsp	r8,sp[0x0]
8000f586:	58 08       	cp.w	r8,0
8000f588:	f9 b3 01 02 	movne	r3,2
8000f58c:	f9 b3 00 01 	moveq	r3,1
8000f590:	89 68       	st.w	r4[0x18],r8
8000f592:	89 43       	st.w	r4[0x10],r3
8000f594:	c0 88       	rjmp	8000f5a4 <__d2b+0x70>
8000f596:	1a 9c       	mov	r12,sp
8000f598:	c1 cf       	rcall	8000f3d0 <__lo0bits>
8000f59a:	30 13       	mov	r3,1
8000f59c:	40 08       	lddsp	r8,sp[0x0]
8000f59e:	2e 0c       	sub	r12,-32
8000f5a0:	89 43       	st.w	r4[0x10],r3
8000f5a2:	89 58       	st.w	r4[0x14],r8
8000f5a4:	58 01       	cp.w	r1,0
8000f5a6:	c0 90       	breq	8000f5b8 <__d2b+0x84>
8000f5a8:	e2 c1 04 33 	sub	r1,r1,1075
8000f5ac:	18 01       	add	r1,r12
8000f5ae:	8d 01       	st.w	r6[0x0],r1
8000f5b0:	f8 0c 11 35 	rsub	r12,r12,53
8000f5b4:	8b 0c       	st.w	r5[0x0],r12
8000f5b6:	c0 c8       	rjmp	8000f5ce <__d2b+0x9a>
8000f5b8:	e6 c8 ff fc 	sub	r8,r3,-4
8000f5bc:	f8 cc 04 32 	sub	r12,r12,1074
8000f5c0:	a5 73       	lsl	r3,0x5
8000f5c2:	8d 0c       	st.w	r6[0x0],r12
8000f5c4:	e8 08 03 2c 	ld.w	r12,r4[r8<<0x2]
8000f5c8:	cd 4e       	rcall	8000f370 <__hi0bits>
8000f5ca:	18 13       	sub	r3,r12
8000f5cc:	8b 03       	st.w	r5[0x0],r3
8000f5ce:	08 9c       	mov	r12,r4
8000f5d0:	2f ed       	sub	sp,-8
8000f5d2:	d8 32       	popm	r0-r7,pc

8000f5d4 <__mdiff>:
8000f5d4:	d4 31       	pushm	r0-r7,lr
8000f5d6:	74 48       	ld.w	r8,r10[0x10]
8000f5d8:	76 45       	ld.w	r5,r11[0x10]
8000f5da:	16 97       	mov	r7,r11
8000f5dc:	14 96       	mov	r6,r10
8000f5de:	10 15       	sub	r5,r8
8000f5e0:	c1 31       	brne	8000f606 <__mdiff+0x32>
8000f5e2:	2f b8       	sub	r8,-5
8000f5e4:	ee ce ff ec 	sub	lr,r7,-20
8000f5e8:	a3 68       	lsl	r8,0x2
8000f5ea:	f4 08 00 0b 	add	r11,r10,r8
8000f5ee:	ee 08 00 08 	add	r8,r7,r8
8000f5f2:	11 4a       	ld.w	r10,--r8
8000f5f4:	17 49       	ld.w	r9,--r11
8000f5f6:	12 3a       	cp.w	r10,r9
8000f5f8:	c0 30       	breq	8000f5fe <__mdiff+0x2a>
8000f5fa:	c0 e2       	brcc	8000f616 <__mdiff+0x42>
8000f5fc:	c0 78       	rjmp	8000f60a <__mdiff+0x36>
8000f5fe:	1c 38       	cp.w	r8,lr
8000f600:	fe 9b ff f9 	brhi	8000f5f2 <__mdiff+0x1e>
8000f604:	c4 98       	rjmp	8000f696 <__mdiff+0xc2>
8000f606:	58 05       	cp.w	r5,0
8000f608:	c0 64       	brge	8000f614 <__mdiff+0x40>
8000f60a:	0e 98       	mov	r8,r7
8000f60c:	30 15       	mov	r5,1
8000f60e:	0c 97       	mov	r7,r6
8000f610:	10 96       	mov	r6,r8
8000f612:	c0 28       	rjmp	8000f616 <__mdiff+0x42>
8000f614:	30 05       	mov	r5,0
8000f616:	6e 1b       	ld.w	r11,r7[0x4]
8000f618:	c5 6f       	rcall	8000f4c4 <_Balloc>
8000f61a:	6e 49       	ld.w	r9,r7[0x10]
8000f61c:	6c 44       	ld.w	r4,r6[0x10]
8000f61e:	99 35       	st.w	r12[0xc],r5
8000f620:	2f b4       	sub	r4,-5
8000f622:	f2 c5 ff fb 	sub	r5,r9,-5
8000f626:	ec 04 00 24 	add	r4,r6,r4<<0x2
8000f62a:	ee 05 00 25 	add	r5,r7,r5<<0x2
8000f62e:	2e c6       	sub	r6,-20
8000f630:	2e c7       	sub	r7,-20
8000f632:	f8 c8 ff ec 	sub	r8,r12,-20
8000f636:	30 0a       	mov	r10,0
8000f638:	0f 0e       	ld.w	lr,r7++
8000f63a:	0d 0b       	ld.w	r11,r6++
8000f63c:	fc 02 16 10 	lsr	r2,lr,0x10
8000f640:	f6 03 16 10 	lsr	r3,r11,0x10
8000f644:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000f648:	e4 03 01 03 	sub	r3,r2,r3
8000f64c:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000f650:	fc 0b 01 0b 	sub	r11,lr,r11
8000f654:	f6 0a 00 0a 	add	r10,r11,r10
8000f658:	b0 1a       	st.h	r8[0x2],r10
8000f65a:	b1 4a       	asr	r10,0x10
8000f65c:	e6 0a 00 0a 	add	r10,r3,r10
8000f660:	b0 0a       	st.h	r8[0x0],r10
8000f662:	2f c8       	sub	r8,-4
8000f664:	b1 4a       	asr	r10,0x10
8000f666:	08 36       	cp.w	r6,r4
8000f668:	ce 83       	brcs	8000f638 <__mdiff+0x64>
8000f66a:	c0 d8       	rjmp	8000f684 <__mdiff+0xb0>
8000f66c:	0f 0b       	ld.w	r11,r7++
8000f66e:	f6 0e 16 10 	lsr	lr,r11,0x10
8000f672:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000f676:	16 0a       	add	r10,r11
8000f678:	b0 1a       	st.h	r8[0x2],r10
8000f67a:	b1 4a       	asr	r10,0x10
8000f67c:	1c 0a       	add	r10,lr
8000f67e:	b0 0a       	st.h	r8[0x0],r10
8000f680:	2f c8       	sub	r8,-4
8000f682:	b1 4a       	asr	r10,0x10
8000f684:	0a 37       	cp.w	r7,r5
8000f686:	cf 33       	brcs	8000f66c <__mdiff+0x98>
8000f688:	c0 28       	rjmp	8000f68c <__mdiff+0xb8>
8000f68a:	20 19       	sub	r9,1
8000f68c:	11 4a       	ld.w	r10,--r8
8000f68e:	58 0a       	cp.w	r10,0
8000f690:	cf d0       	breq	8000f68a <__mdiff+0xb6>
8000f692:	99 49       	st.w	r12[0x10],r9
8000f694:	d8 32       	popm	r0-r7,pc
8000f696:	30 0b       	mov	r11,0
8000f698:	c1 6f       	rcall	8000f4c4 <_Balloc>
8000f69a:	30 18       	mov	r8,1
8000f69c:	99 48       	st.w	r12[0x10],r8
8000f69e:	30 08       	mov	r8,0
8000f6a0:	99 58       	st.w	r12[0x14],r8
8000f6a2:	d8 32       	popm	r0-r7,pc

8000f6a4 <__lshift>:
8000f6a4:	d4 31       	pushm	r0-r7,lr
8000f6a6:	16 97       	mov	r7,r11
8000f6a8:	76 46       	ld.w	r6,r11[0x10]
8000f6aa:	f4 02 14 05 	asr	r2,r10,0x5
8000f6ae:	2f f6       	sub	r6,-1
8000f6b0:	14 93       	mov	r3,r10
8000f6b2:	18 94       	mov	r4,r12
8000f6b4:	04 06       	add	r6,r2
8000f6b6:	76 1b       	ld.w	r11,r11[0x4]
8000f6b8:	6e 28       	ld.w	r8,r7[0x8]
8000f6ba:	c0 38       	rjmp	8000f6c0 <__lshift+0x1c>
8000f6bc:	2f fb       	sub	r11,-1
8000f6be:	a1 78       	lsl	r8,0x1
8000f6c0:	10 36       	cp.w	r6,r8
8000f6c2:	fe 99 ff fd 	brgt	8000f6bc <__lshift+0x18>
8000f6c6:	08 9c       	mov	r12,r4
8000f6c8:	cf ee       	rcall	8000f4c4 <_Balloc>
8000f6ca:	30 09       	mov	r9,0
8000f6cc:	18 95       	mov	r5,r12
8000f6ce:	f8 c8 ff ec 	sub	r8,r12,-20
8000f6d2:	12 9a       	mov	r10,r9
8000f6d4:	c0 38       	rjmp	8000f6da <__lshift+0x36>
8000f6d6:	10 aa       	st.w	r8++,r10
8000f6d8:	2f f9       	sub	r9,-1
8000f6da:	04 39       	cp.w	r9,r2
8000f6dc:	cf d5       	brlt	8000f6d6 <__lshift+0x32>
8000f6de:	6e 4b       	ld.w	r11,r7[0x10]
8000f6e0:	e7 d3 c0 05 	bfextu	r3,r3,0x0,0x5
8000f6e4:	2f bb       	sub	r11,-5
8000f6e6:	ee c9 ff ec 	sub	r9,r7,-20
8000f6ea:	ee 0b 00 2b 	add	r11,r7,r11<<0x2
8000f6ee:	58 03       	cp.w	r3,0
8000f6f0:	c1 30       	breq	8000f716 <__lshift+0x72>
8000f6f2:	e6 0c 11 20 	rsub	r12,r3,32
8000f6f6:	30 0a       	mov	r10,0
8000f6f8:	72 02       	ld.w	r2,r9[0x0]
8000f6fa:	e4 03 09 42 	lsl	r2,r2,r3
8000f6fe:	04 4a       	or	r10,r2
8000f700:	10 aa       	st.w	r8++,r10
8000f702:	13 0a       	ld.w	r10,r9++
8000f704:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000f708:	16 39       	cp.w	r9,r11
8000f70a:	cf 73       	brcs	8000f6f8 <__lshift+0x54>
8000f70c:	91 0a       	st.w	r8[0x0],r10
8000f70e:	58 0a       	cp.w	r10,0
8000f710:	c0 70       	breq	8000f71e <__lshift+0x7a>
8000f712:	2f f6       	sub	r6,-1
8000f714:	c0 58       	rjmp	8000f71e <__lshift+0x7a>
8000f716:	13 0a       	ld.w	r10,r9++
8000f718:	10 aa       	st.w	r8++,r10
8000f71a:	16 39       	cp.w	r9,r11
8000f71c:	cf d3       	brcs	8000f716 <__lshift+0x72>
8000f71e:	08 9c       	mov	r12,r4
8000f720:	20 16       	sub	r6,1
8000f722:	0e 9b       	mov	r11,r7
8000f724:	8b 46       	st.w	r5[0x10],r6
8000f726:	cb 5e       	rcall	8000f490 <_Bfree>
8000f728:	0a 9c       	mov	r12,r5
8000f72a:	d8 32       	popm	r0-r7,pc

8000f72c <__multiply>:
8000f72c:	d4 31       	pushm	r0-r7,lr
8000f72e:	20 2d       	sub	sp,8
8000f730:	76 49       	ld.w	r9,r11[0x10]
8000f732:	74 48       	ld.w	r8,r10[0x10]
8000f734:	16 96       	mov	r6,r11
8000f736:	14 95       	mov	r5,r10
8000f738:	10 39       	cp.w	r9,r8
8000f73a:	ec 08 17 50 	movlt	r8,r6
8000f73e:	ea 06 17 50 	movlt	r6,r5
8000f742:	f0 05 17 50 	movlt	r5,r8
8000f746:	6c 28       	ld.w	r8,r6[0x8]
8000f748:	76 43       	ld.w	r3,r11[0x10]
8000f74a:	74 42       	ld.w	r2,r10[0x10]
8000f74c:	76 1b       	ld.w	r11,r11[0x4]
8000f74e:	e4 03 00 07 	add	r7,r2,r3
8000f752:	10 37       	cp.w	r7,r8
8000f754:	f7 bb 09 ff 	subgt	r11,-1
8000f758:	cb 6e       	rcall	8000f4c4 <_Balloc>
8000f75a:	ee c4 ff fb 	sub	r4,r7,-5
8000f75e:	f8 c9 ff ec 	sub	r9,r12,-20
8000f762:	f8 04 00 24 	add	r4,r12,r4<<0x2
8000f766:	30 0a       	mov	r10,0
8000f768:	12 98       	mov	r8,r9
8000f76a:	c0 28       	rjmp	8000f76e <__multiply+0x42>
8000f76c:	10 aa       	st.w	r8++,r10
8000f76e:	08 38       	cp.w	r8,r4
8000f770:	cf e3       	brcs	8000f76c <__multiply+0x40>
8000f772:	2f b3       	sub	r3,-5
8000f774:	2f b2       	sub	r2,-5
8000f776:	ec 03 00 23 	add	r3,r6,r3<<0x2
8000f77a:	ea 02 00 22 	add	r2,r5,r2<<0x2
8000f77e:	ec cb ff ec 	sub	r11,r6,-20
8000f782:	50 12       	stdsp	sp[0x4],r2
8000f784:	ea ca ff ec 	sub	r10,r5,-20
8000f788:	c4 48       	rjmp	8000f810 <__multiply+0xe4>
8000f78a:	94 95       	ld.uh	r5,r10[0x2]
8000f78c:	58 05       	cp.w	r5,0
8000f78e:	c2 00       	breq	8000f7ce <__multiply+0xa2>
8000f790:	12 98       	mov	r8,r9
8000f792:	16 96       	mov	r6,r11
8000f794:	30 0e       	mov	lr,0
8000f796:	50 09       	stdsp	sp[0x0],r9
8000f798:	0d 02       	ld.w	r2,r6++
8000f79a:	e4 00 16 10 	lsr	r0,r2,0x10
8000f79e:	70 01       	ld.w	r1,r8[0x0]
8000f7a0:	70 09       	ld.w	r9,r8[0x0]
8000f7a2:	b1 81       	lsr	r1,0x10
8000f7a4:	e5 d2 c0 10 	bfextu	r2,r2,0x0,0x10
8000f7a8:	e0 05 03 41 	mac	r1,r0,r5
8000f7ac:	ab 32       	mul	r2,r5
8000f7ae:	e1 d9 c0 10 	bfextu	r0,r9,0x0,0x10
8000f7b2:	00 02       	add	r2,r0
8000f7b4:	e4 0e 00 0e 	add	lr,r2,lr
8000f7b8:	b0 1e       	st.h	r8[0x2],lr
8000f7ba:	b1 8e       	lsr	lr,0x10
8000f7bc:	1c 01       	add	r1,lr
8000f7be:	b0 01       	st.h	r8[0x0],r1
8000f7c0:	e2 0e 16 10 	lsr	lr,r1,0x10
8000f7c4:	2f c8       	sub	r8,-4
8000f7c6:	06 36       	cp.w	r6,r3
8000f7c8:	ce 83       	brcs	8000f798 <__multiply+0x6c>
8000f7ca:	40 09       	lddsp	r9,sp[0x0]
8000f7cc:	91 0e       	st.w	r8[0x0],lr
8000f7ce:	94 86       	ld.uh	r6,r10[0x0]
8000f7d0:	58 06       	cp.w	r6,0
8000f7d2:	c1 d0       	breq	8000f80c <__multiply+0xe0>
8000f7d4:	72 02       	ld.w	r2,r9[0x0]
8000f7d6:	12 98       	mov	r8,r9
8000f7d8:	16 9e       	mov	lr,r11
8000f7da:	30 05       	mov	r5,0
8000f7dc:	b0 12       	st.h	r8[0x2],r2
8000f7de:	1d 01       	ld.w	r1,lr++
8000f7e0:	90 82       	ld.uh	r2,r8[0x0]
8000f7e2:	e1 d1 c0 10 	bfextu	r0,r1,0x0,0x10
8000f7e6:	ad 30       	mul	r0,r6
8000f7e8:	e0 02 00 02 	add	r2,r0,r2
8000f7ec:	e4 05 00 05 	add	r5,r2,r5
8000f7f0:	b0 05       	st.h	r8[0x0],r5
8000f7f2:	b1 85       	lsr	r5,0x10
8000f7f4:	b1 81       	lsr	r1,0x10
8000f7f6:	2f c8       	sub	r8,-4
8000f7f8:	ad 31       	mul	r1,r6
8000f7fa:	90 92       	ld.uh	r2,r8[0x2]
8000f7fc:	e2 02 00 02 	add	r2,r1,r2
8000f800:	0a 02       	add	r2,r5
8000f802:	e4 05 16 10 	lsr	r5,r2,0x10
8000f806:	06 3e       	cp.w	lr,r3
8000f808:	ce a3       	brcs	8000f7dc <__multiply+0xb0>
8000f80a:	91 02       	st.w	r8[0x0],r2
8000f80c:	2f ca       	sub	r10,-4
8000f80e:	2f c9       	sub	r9,-4
8000f810:	40 18       	lddsp	r8,sp[0x4]
8000f812:	10 3a       	cp.w	r10,r8
8000f814:	cb b3       	brcs	8000f78a <__multiply+0x5e>
8000f816:	c0 28       	rjmp	8000f81a <__multiply+0xee>
8000f818:	20 17       	sub	r7,1
8000f81a:	58 07       	cp.w	r7,0
8000f81c:	e0 8a 00 05 	brle	8000f826 <__multiply+0xfa>
8000f820:	09 48       	ld.w	r8,--r4
8000f822:	58 08       	cp.w	r8,0
8000f824:	cf a0       	breq	8000f818 <__multiply+0xec>
8000f826:	99 47       	st.w	r12[0x10],r7
8000f828:	2f ed       	sub	sp,-8
8000f82a:	d8 32       	popm	r0-r7,pc

8000f82c <__i2b>:
8000f82c:	d4 21       	pushm	r4-r7,lr
8000f82e:	16 97       	mov	r7,r11
8000f830:	30 1b       	mov	r11,1
8000f832:	c4 9e       	rcall	8000f4c4 <_Balloc>
8000f834:	30 19       	mov	r9,1
8000f836:	99 57       	st.w	r12[0x14],r7
8000f838:	99 49       	st.w	r12[0x10],r9
8000f83a:	d8 22       	popm	r4-r7,pc

8000f83c <__multadd>:
8000f83c:	d4 31       	pushm	r0-r7,lr
8000f83e:	30 08       	mov	r8,0
8000f840:	12 95       	mov	r5,r9
8000f842:	16 97       	mov	r7,r11
8000f844:	18 96       	mov	r6,r12
8000f846:	76 44       	ld.w	r4,r11[0x10]
8000f848:	f6 c9 ff ec 	sub	r9,r11,-20
8000f84c:	72 0b       	ld.w	r11,r9[0x0]
8000f84e:	f6 0c 16 10 	lsr	r12,r11,0x10
8000f852:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000f856:	f4 0c 02 4c 	mul	r12,r10,r12
8000f85a:	f4 0b 03 45 	mac	r5,r10,r11
8000f85e:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
8000f862:	b1 85       	lsr	r5,0x10
8000f864:	18 05       	add	r5,r12
8000f866:	ea 0c 15 10 	lsl	r12,r5,0x10
8000f86a:	f8 0b 00 0b 	add	r11,r12,r11
8000f86e:	12 ab       	st.w	r9++,r11
8000f870:	2f f8       	sub	r8,-1
8000f872:	b1 85       	lsr	r5,0x10
8000f874:	08 38       	cp.w	r8,r4
8000f876:	ce b5       	brlt	8000f84c <__multadd+0x10>
8000f878:	58 05       	cp.w	r5,0
8000f87a:	c1 c0       	breq	8000f8b2 <__multadd+0x76>
8000f87c:	6e 28       	ld.w	r8,r7[0x8]
8000f87e:	10 34       	cp.w	r4,r8
8000f880:	c1 35       	brlt	8000f8a6 <__multadd+0x6a>
8000f882:	6e 1b       	ld.w	r11,r7[0x4]
8000f884:	0c 9c       	mov	r12,r6
8000f886:	2f fb       	sub	r11,-1
8000f888:	c1 ee       	rcall	8000f4c4 <_Balloc>
8000f88a:	6e 4a       	ld.w	r10,r7[0x10]
8000f88c:	ee cb ff f4 	sub	r11,r7,-12
8000f890:	18 93       	mov	r3,r12
8000f892:	2f ea       	sub	r10,-2
8000f894:	2f 4c       	sub	r12,-12
8000f896:	a3 6a       	lsl	r10,0x2
8000f898:	fe b0 de 65 	rcall	8000b562 <memcpy>
8000f89c:	0e 9b       	mov	r11,r7
8000f89e:	0c 9c       	mov	r12,r6
8000f8a0:	fe b0 fd f8 	rcall	8000f490 <_Bfree>
8000f8a4:	06 97       	mov	r7,r3
8000f8a6:	e8 c8 ff ff 	sub	r8,r4,-1
8000f8aa:	2f b4       	sub	r4,-5
8000f8ac:	8f 48       	st.w	r7[0x10],r8
8000f8ae:	ee 04 09 25 	st.w	r7[r4<<0x2],r5
8000f8b2:	0e 9c       	mov	r12,r7
8000f8b4:	d8 32       	popm	r0-r7,pc
8000f8b6:	d7 03       	nop

8000f8b8 <__pow5mult>:
8000f8b8:	d4 31       	pushm	r0-r7,lr
8000f8ba:	14 96       	mov	r6,r10
8000f8bc:	18 97       	mov	r7,r12
8000f8be:	16 94       	mov	r4,r11
8000f8c0:	f1 da c0 02 	bfextu	r8,r10,0x0,0x2
8000f8c4:	c0 90       	breq	8000f8d6 <__pow5mult+0x1e>
8000f8c6:	20 18       	sub	r8,1
8000f8c8:	fe c9 de 78 	sub	r9,pc,-8584
8000f8cc:	f2 08 03 2a 	ld.w	r10,r9[r8<<0x2]
8000f8d0:	30 09       	mov	r9,0
8000f8d2:	cb 5f       	rcall	8000f83c <__multadd>
8000f8d4:	18 94       	mov	r4,r12
8000f8d6:	a3 46       	asr	r6,0x2
8000f8d8:	c3 40       	breq	8000f940 <__pow5mult+0x88>
8000f8da:	6e 95       	ld.w	r5,r7[0x24]
8000f8dc:	58 05       	cp.w	r5,0
8000f8de:	c0 91       	brne	8000f8f0 <__pow5mult+0x38>
8000f8e0:	31 0c       	mov	r12,16
8000f8e2:	fe b0 dc 09 	rcall	8000b0f4 <malloc>
8000f8e6:	99 35       	st.w	r12[0xc],r5
8000f8e8:	8f 9c       	st.w	r7[0x24],r12
8000f8ea:	99 15       	st.w	r12[0x4],r5
8000f8ec:	99 25       	st.w	r12[0x8],r5
8000f8ee:	99 05       	st.w	r12[0x0],r5
8000f8f0:	6e 93       	ld.w	r3,r7[0x24]
8000f8f2:	66 25       	ld.w	r5,r3[0x8]
8000f8f4:	58 05       	cp.w	r5,0
8000f8f6:	c0 c1       	brne	8000f90e <__pow5mult+0x56>
8000f8f8:	e0 6b 02 71 	mov	r11,625
8000f8fc:	0e 9c       	mov	r12,r7
8000f8fe:	c9 7f       	rcall	8000f82c <__i2b>
8000f900:	87 2c       	st.w	r3[0x8],r12
8000f902:	30 08       	mov	r8,0
8000f904:	18 95       	mov	r5,r12
8000f906:	99 08       	st.w	r12[0x0],r8
8000f908:	c0 38       	rjmp	8000f90e <__pow5mult+0x56>
8000f90a:	06 9c       	mov	r12,r3
8000f90c:	18 95       	mov	r5,r12
8000f90e:	ed b6 00 00 	bld	r6,0x0
8000f912:	c0 b1       	brne	8000f928 <__pow5mult+0x70>
8000f914:	08 9b       	mov	r11,r4
8000f916:	0a 9a       	mov	r10,r5
8000f918:	0e 9c       	mov	r12,r7
8000f91a:	c0 9f       	rcall	8000f72c <__multiply>
8000f91c:	08 9b       	mov	r11,r4
8000f91e:	18 93       	mov	r3,r12
8000f920:	0e 9c       	mov	r12,r7
8000f922:	06 94       	mov	r4,r3
8000f924:	fe b0 fd b6 	rcall	8000f490 <_Bfree>
8000f928:	a1 56       	asr	r6,0x1
8000f92a:	c0 b0       	breq	8000f940 <__pow5mult+0x88>
8000f92c:	6a 03       	ld.w	r3,r5[0x0]
8000f92e:	58 03       	cp.w	r3,0
8000f930:	ce d1       	brne	8000f90a <__pow5mult+0x52>
8000f932:	0a 9a       	mov	r10,r5
8000f934:	0a 9b       	mov	r11,r5
8000f936:	0e 9c       	mov	r12,r7
8000f938:	cf ae       	rcall	8000f72c <__multiply>
8000f93a:	8b 0c       	st.w	r5[0x0],r12
8000f93c:	99 03       	st.w	r12[0x0],r3
8000f93e:	ce 7b       	rjmp	8000f90c <__pow5mult+0x54>
8000f940:	08 9c       	mov	r12,r4
8000f942:	d8 32       	popm	r0-r7,pc

8000f944 <__isinfd>:
8000f944:	14 98       	mov	r8,r10
8000f946:	fc 19 7f f0 	movh	r9,0x7ff0
8000f94a:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000f94e:	f0 0b 11 00 	rsub	r11,r8,0
8000f952:	f7 e8 10 08 	or	r8,r11,r8
8000f956:	f5 e8 13 f8 	or	r8,r10,r8>>0x1f
8000f95a:	f2 08 01 08 	sub	r8,r9,r8
8000f95e:	f0 0c 11 00 	rsub	r12,r8,0
8000f962:	f9 e8 10 08 	or	r8,r12,r8
8000f966:	f0 0c 14 1f 	asr	r12,r8,0x1f
8000f96a:	2f fc       	sub	r12,-1
8000f96c:	5e fc       	retal	r12

8000f96e <__isnand>:
8000f96e:	14 98       	mov	r8,r10
8000f970:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000f974:	f0 0c 11 00 	rsub	r12,r8,0
8000f978:	10 4c       	or	r12,r8
8000f97a:	fc 18 7f f0 	movh	r8,0x7ff0
8000f97e:	f5 ec 13 fc 	or	r12,r10,r12>>0x1f
8000f982:	f0 0c 01 0c 	sub	r12,r8,r12
8000f986:	bf 9c       	lsr	r12,0x1f
8000f988:	5e fc       	retal	r12
8000f98a:	d7 03       	nop

8000f98c <__sclose>:
8000f98c:	d4 01       	pushm	lr
8000f98e:	96 7b       	ld.sh	r11,r11[0xe]
8000f990:	c7 6c       	rcall	8000fa7c <_close_r>
8000f992:	d8 02       	popm	pc

8000f994 <__sseek>:
8000f994:	d4 21       	pushm	r4-r7,lr
8000f996:	16 97       	mov	r7,r11
8000f998:	96 7b       	ld.sh	r11,r11[0xe]
8000f99a:	cf 7c       	rcall	8000fb88 <_lseek_r>
8000f99c:	8e 68       	ld.sh	r8,r7[0xc]
8000f99e:	10 99       	mov	r9,r8
8000f9a0:	ad c8       	cbr	r8,0xc
8000f9a2:	ad a9       	sbr	r9,0xc
8000f9a4:	5b fc       	cp.w	r12,-1
8000f9a6:	ef f8 0c 06 	st.heq	r7[0xc],r8
8000f9aa:	ef f9 1c 06 	st.hne	r7[0xc],r9
8000f9ae:	ef fc 1a 15 	st.wne	r7[0x54],r12
8000f9b2:	d8 22       	popm	r4-r7,pc

8000f9b4 <__swrite>:
8000f9b4:	d4 21       	pushm	r4-r7,lr
8000f9b6:	96 68       	ld.sh	r8,r11[0xc]
8000f9b8:	16 97       	mov	r7,r11
8000f9ba:	14 95       	mov	r5,r10
8000f9bc:	12 94       	mov	r4,r9
8000f9be:	e2 18 01 00 	andl	r8,0x100,COH
8000f9c2:	18 96       	mov	r6,r12
8000f9c4:	c0 50       	breq	8000f9ce <__swrite+0x1a>
8000f9c6:	30 29       	mov	r9,2
8000f9c8:	30 0a       	mov	r10,0
8000f9ca:	96 7b       	ld.sh	r11,r11[0xe]
8000f9cc:	cd ec       	rcall	8000fb88 <_lseek_r>
8000f9ce:	8e 68       	ld.sh	r8,r7[0xc]
8000f9d0:	ad c8       	cbr	r8,0xc
8000f9d2:	08 99       	mov	r9,r4
8000f9d4:	0a 9a       	mov	r10,r5
8000f9d6:	8e 7b       	ld.sh	r11,r7[0xe]
8000f9d8:	0c 9c       	mov	r12,r6
8000f9da:	ae 68       	st.h	r7[0xc],r8
8000f9dc:	c1 0c       	rcall	8000f9fc <_write_r>
8000f9de:	d8 22       	popm	r4-r7,pc

8000f9e0 <__sread>:
8000f9e0:	d4 21       	pushm	r4-r7,lr
8000f9e2:	16 97       	mov	r7,r11
8000f9e4:	96 7b       	ld.sh	r11,r11[0xe]
8000f9e6:	ce 5c       	rcall	8000fbb0 <_read_r>
8000f9e8:	c0 65       	brlt	8000f9f4 <__sread+0x14>
8000f9ea:	6f 58       	ld.w	r8,r7[0x54]
8000f9ec:	18 08       	add	r8,r12
8000f9ee:	ef 48 00 54 	st.w	r7[84],r8
8000f9f2:	d8 22       	popm	r4-r7,pc
8000f9f4:	8e 68       	ld.sh	r8,r7[0xc]
8000f9f6:	ad c8       	cbr	r8,0xc
8000f9f8:	ae 68       	st.h	r7[0xc],r8
8000f9fa:	d8 22       	popm	r4-r7,pc

8000f9fc <_write_r>:
8000f9fc:	d4 21       	pushm	r4-r7,lr
8000f9fe:	16 98       	mov	r8,r11
8000fa00:	18 97       	mov	r7,r12
8000fa02:	10 9c       	mov	r12,r8
8000fa04:	30 08       	mov	r8,0
8000fa06:	14 9b       	mov	r11,r10
8000fa08:	e0 66 53 24 	mov	r6,21284
8000fa0c:	12 9a       	mov	r10,r9
8000fa0e:	8d 08       	st.w	r6[0x0],r8
8000fa10:	fe b0 c9 8c 	rcall	80008d28 <_write>
8000fa14:	5b fc       	cp.w	r12,-1
8000fa16:	c0 51       	brne	8000fa20 <_write_r+0x24>
8000fa18:	6c 08       	ld.w	r8,r6[0x0]
8000fa1a:	58 08       	cp.w	r8,0
8000fa1c:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000fa20:	d8 22       	popm	r4-r7,pc
8000fa22:	d7 03       	nop

8000fa24 <_calloc_r>:
8000fa24:	d4 21       	pushm	r4-r7,lr
8000fa26:	f4 0b 02 4b 	mul	r11,r10,r11
8000fa2a:	fe b0 db 6d 	rcall	8000b104 <_malloc_r>
8000fa2e:	18 97       	mov	r7,r12
8000fa30:	c2 30       	breq	8000fa76 <_calloc_r+0x52>
8000fa32:	f8 fa ff fc 	ld.w	r10,r12[-4]
8000fa36:	e0 1a ff fc 	andl	r10,0xfffc
8000fa3a:	20 4a       	sub	r10,4
8000fa3c:	e0 4a 00 24 	cp.w	r10,36
8000fa40:	e0 8b 00 18 	brhi	8000fa70 <_calloc_r+0x4c>
8000fa44:	18 98       	mov	r8,r12
8000fa46:	59 3a       	cp.w	r10,19
8000fa48:	e0 88 00 0f 	brls	8000fa66 <_calloc_r+0x42>
8000fa4c:	30 09       	mov	r9,0
8000fa4e:	10 a9       	st.w	r8++,r9
8000fa50:	10 a9       	st.w	r8++,r9
8000fa52:	59 ba       	cp.w	r10,27
8000fa54:	e0 88 00 09 	brls	8000fa66 <_calloc_r+0x42>
8000fa58:	10 a9       	st.w	r8++,r9
8000fa5a:	10 a9       	st.w	r8++,r9
8000fa5c:	e0 4a 00 24 	cp.w	r10,36
8000fa60:	c0 31       	brne	8000fa66 <_calloc_r+0x42>
8000fa62:	10 a9       	st.w	r8++,r9
8000fa64:	10 a9       	st.w	r8++,r9
8000fa66:	30 09       	mov	r9,0
8000fa68:	10 a9       	st.w	r8++,r9
8000fa6a:	91 19       	st.w	r8[0x4],r9
8000fa6c:	91 09       	st.w	r8[0x0],r9
8000fa6e:	c0 48       	rjmp	8000fa76 <_calloc_r+0x52>
8000fa70:	30 0b       	mov	r11,0
8000fa72:	fe b0 de 1c 	rcall	8000b6aa <memset>
8000fa76:	0e 9c       	mov	r12,r7
8000fa78:	d8 22       	popm	r4-r7,pc
8000fa7a:	d7 03       	nop

8000fa7c <_close_r>:
8000fa7c:	d4 21       	pushm	r4-r7,lr
8000fa7e:	30 08       	mov	r8,0
8000fa80:	18 97       	mov	r7,r12
8000fa82:	e0 66 53 24 	mov	r6,21284
8000fa86:	16 9c       	mov	r12,r11
8000fa88:	8d 08       	st.w	r6[0x0],r8
8000fa8a:	fe b0 df c1 	rcall	8000ba0c <_close>
8000fa8e:	5b fc       	cp.w	r12,-1
8000fa90:	c0 51       	brne	8000fa9a <_close_r+0x1e>
8000fa92:	6c 08       	ld.w	r8,r6[0x0]
8000fa94:	58 08       	cp.w	r8,0
8000fa96:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000fa9a:	d8 22       	popm	r4-r7,pc

8000fa9c <_fclose_r>:
8000fa9c:	d4 21       	pushm	r4-r7,lr
8000fa9e:	18 96       	mov	r6,r12
8000faa0:	16 97       	mov	r7,r11
8000faa2:	58 0b       	cp.w	r11,0
8000faa4:	c0 31       	brne	8000faaa <_fclose_r+0xe>
8000faa6:	16 95       	mov	r5,r11
8000faa8:	c5 38       	rjmp	8000fb4e <_fclose_r+0xb2>
8000faaa:	fe b0 f8 b5 	rcall	8000ec14 <__sfp_lock_acquire>
8000faae:	58 06       	cp.w	r6,0
8000fab0:	c0 70       	breq	8000fabe <_fclose_r+0x22>
8000fab2:	6c 68       	ld.w	r8,r6[0x18]
8000fab4:	58 08       	cp.w	r8,0
8000fab6:	c0 41       	brne	8000fabe <_fclose_r+0x22>
8000fab8:	0c 9c       	mov	r12,r6
8000faba:	fe b0 f8 ff 	rcall	8000ecb8 <__sinit>
8000fabe:	fe c8 e1 16 	sub	r8,pc,-7914
8000fac2:	10 37       	cp.w	r7,r8
8000fac4:	c0 31       	brne	8000faca <_fclose_r+0x2e>
8000fac6:	6c 07       	ld.w	r7,r6[0x0]
8000fac8:	c0 c8       	rjmp	8000fae0 <_fclose_r+0x44>
8000faca:	fe c8 e1 02 	sub	r8,pc,-7934
8000face:	10 37       	cp.w	r7,r8
8000fad0:	c0 31       	brne	8000fad6 <_fclose_r+0x3a>
8000fad2:	6c 17       	ld.w	r7,r6[0x4]
8000fad4:	c0 68       	rjmp	8000fae0 <_fclose_r+0x44>
8000fad6:	fe c8 e0 ee 	sub	r8,pc,-7954
8000fada:	10 37       	cp.w	r7,r8
8000fadc:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000fae0:	8e 69       	ld.sh	r9,r7[0xc]
8000fae2:	30 08       	mov	r8,0
8000fae4:	f0 09 19 00 	cp.h	r9,r8
8000fae8:	c0 51       	brne	8000faf2 <_fclose_r+0x56>
8000faea:	fe b0 f8 96 	rcall	8000ec16 <__sfp_lock_release>
8000faee:	30 05       	mov	r5,0
8000faf0:	c2 f8       	rjmp	8000fb4e <_fclose_r+0xb2>
8000faf2:	0e 9b       	mov	r11,r7
8000faf4:	0c 9c       	mov	r12,r6
8000faf6:	fe b0 f8 09 	rcall	8000eb08 <_fflush_r>
8000fafa:	6e c8       	ld.w	r8,r7[0x30]
8000fafc:	18 95       	mov	r5,r12
8000fafe:	58 08       	cp.w	r8,0
8000fb00:	c0 60       	breq	8000fb0c <_fclose_r+0x70>
8000fb02:	6e 8b       	ld.w	r11,r7[0x20]
8000fb04:	0c 9c       	mov	r12,r6
8000fb06:	5d 18       	icall	r8
8000fb08:	f9 b5 05 ff 	movlt	r5,-1
8000fb0c:	8e 68       	ld.sh	r8,r7[0xc]
8000fb0e:	ed b8 00 07 	bld	r8,0x7
8000fb12:	c0 51       	brne	8000fb1c <_fclose_r+0x80>
8000fb14:	6e 4b       	ld.w	r11,r7[0x10]
8000fb16:	0c 9c       	mov	r12,r6
8000fb18:	fe b0 f9 6a 	rcall	8000edec <_free_r>
8000fb1c:	6e db       	ld.w	r11,r7[0x34]
8000fb1e:	58 0b       	cp.w	r11,0
8000fb20:	c0 a0       	breq	8000fb34 <_fclose_r+0x98>
8000fb22:	ee c8 ff bc 	sub	r8,r7,-68
8000fb26:	10 3b       	cp.w	r11,r8
8000fb28:	c0 40       	breq	8000fb30 <_fclose_r+0x94>
8000fb2a:	0c 9c       	mov	r12,r6
8000fb2c:	fe b0 f9 60 	rcall	8000edec <_free_r>
8000fb30:	30 08       	mov	r8,0
8000fb32:	8f d8       	st.w	r7[0x34],r8
8000fb34:	6f 2b       	ld.w	r11,r7[0x48]
8000fb36:	58 0b       	cp.w	r11,0
8000fb38:	c0 70       	breq	8000fb46 <_fclose_r+0xaa>
8000fb3a:	0c 9c       	mov	r12,r6
8000fb3c:	fe b0 f9 58 	rcall	8000edec <_free_r>
8000fb40:	30 08       	mov	r8,0
8000fb42:	ef 48 00 48 	st.w	r7[72],r8
8000fb46:	30 08       	mov	r8,0
8000fb48:	ae 68       	st.h	r7[0xc],r8
8000fb4a:	fe b0 f8 66 	rcall	8000ec16 <__sfp_lock_release>
8000fb4e:	0a 9c       	mov	r12,r5
8000fb50:	d8 22       	popm	r4-r7,pc
8000fb52:	d7 03       	nop

8000fb54 <fclose>:
8000fb54:	d4 01       	pushm	lr
8000fb56:	e0 68 0a 50 	mov	r8,2640
8000fb5a:	18 9b       	mov	r11,r12
8000fb5c:	70 0c       	ld.w	r12,r8[0x0]
8000fb5e:	c9 ff       	rcall	8000fa9c <_fclose_r>
8000fb60:	d8 02       	popm	pc
8000fb62:	d7 03       	nop

8000fb64 <_fstat_r>:
8000fb64:	d4 21       	pushm	r4-r7,lr
8000fb66:	16 98       	mov	r8,r11
8000fb68:	18 97       	mov	r7,r12
8000fb6a:	10 9c       	mov	r12,r8
8000fb6c:	30 08       	mov	r8,0
8000fb6e:	e0 66 53 24 	mov	r6,21284
8000fb72:	14 9b       	mov	r11,r10
8000fb74:	8d 08       	st.w	r6[0x0],r8
8000fb76:	fe b0 df 73 	rcall	8000ba5c <_fstat>
8000fb7a:	5b fc       	cp.w	r12,-1
8000fb7c:	c0 51       	brne	8000fb86 <_fstat_r+0x22>
8000fb7e:	6c 08       	ld.w	r8,r6[0x0]
8000fb80:	58 08       	cp.w	r8,0
8000fb82:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000fb86:	d8 22       	popm	r4-r7,pc

8000fb88 <_lseek_r>:
8000fb88:	d4 21       	pushm	r4-r7,lr
8000fb8a:	16 98       	mov	r8,r11
8000fb8c:	18 97       	mov	r7,r12
8000fb8e:	10 9c       	mov	r12,r8
8000fb90:	30 08       	mov	r8,0
8000fb92:	14 9b       	mov	r11,r10
8000fb94:	e0 66 53 24 	mov	r6,21284
8000fb98:	12 9a       	mov	r10,r9
8000fb9a:	8d 08       	st.w	r6[0x0],r8
8000fb9c:	fe b0 df 42 	rcall	8000ba20 <_lseek>
8000fba0:	5b fc       	cp.w	r12,-1
8000fba2:	c0 51       	brne	8000fbac <_lseek_r+0x24>
8000fba4:	6c 08       	ld.w	r8,r6[0x0]
8000fba6:	58 08       	cp.w	r8,0
8000fba8:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000fbac:	d8 22       	popm	r4-r7,pc
8000fbae:	d7 03       	nop

8000fbb0 <_read_r>:
8000fbb0:	d4 21       	pushm	r4-r7,lr
8000fbb2:	16 98       	mov	r8,r11
8000fbb4:	18 97       	mov	r7,r12
8000fbb6:	10 9c       	mov	r12,r8
8000fbb8:	30 08       	mov	r8,0
8000fbba:	14 9b       	mov	r11,r10
8000fbbc:	e0 66 53 24 	mov	r6,21284
8000fbc0:	12 9a       	mov	r10,r9
8000fbc2:	8d 08       	st.w	r6[0x0],r8
8000fbc4:	fe b0 c8 6c 	rcall	80008c9c <_read>
8000fbc8:	5b fc       	cp.w	r12,-1
8000fbca:	c0 51       	brne	8000fbd4 <_read_r+0x24>
8000fbcc:	6c 08       	ld.w	r8,r6[0x0]
8000fbce:	58 08       	cp.w	r8,0
8000fbd0:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000fbd4:	d8 22       	popm	r4-r7,pc
8000fbd6:	d7 03       	nop

8000fbd8 <__avr32_f64_mul>:
8000fbd8:	f5 eb 10 1c 	or	r12,r10,r11<<0x1
8000fbdc:	e0 80 00 dc 	breq	8000fd94 <__avr32_f64_mul_op1_zero>
8000fbe0:	d4 21       	pushm	r4-r7,lr
8000fbe2:	f7 e9 20 0e 	eor	lr,r11,r9
8000fbe6:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000fbea:	30 15       	mov	r5,1
8000fbec:	c4 30       	breq	8000fc72 <__avr32_f64_mul_op1_subnormal>
8000fbee:	ab 6b       	lsl	r11,0xa
8000fbf0:	f7 ea 13 6b 	or	r11,r11,r10>>0x16
8000fbf4:	ab 6a       	lsl	r10,0xa
8000fbf6:	f7 d5 d3 c2 	bfins	r11,r5,0x1e,0x2
8000fbfa:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000fbfe:	c5 c0       	breq	8000fcb6 <__avr32_f64_mul_op2_subnormal>
8000fc00:	a1 78       	lsl	r8,0x1
8000fc02:	5c f9       	rol	r9
8000fc04:	f3 d5 d2 ab 	bfins	r9,r5,0x15,0xb
8000fc08:	e0 47 07 ff 	cp.w	r7,2047
8000fc0c:	c7 70       	breq	8000fcfa <__avr32_f64_mul_op_nan_or_inf>
8000fc0e:	e0 46 07 ff 	cp.w	r6,2047
8000fc12:	c7 40       	breq	8000fcfa <__avr32_f64_mul_op_nan_or_inf>
8000fc14:	ee 06 00 0c 	add	r12,r7,r6
8000fc18:	e0 2c 03 fe 	sub	r12,1022
8000fc1c:	f6 08 06 44 	mulu.d	r4,r11,r8
8000fc20:	f4 09 07 44 	macu.d	r4,r10,r9
8000fc24:	f4 08 06 46 	mulu.d	r6,r10,r8
8000fc28:	f6 09 06 4a 	mulu.d	r10,r11,r9
8000fc2c:	08 07       	add	r7,r4
8000fc2e:	f4 05 00 4a 	adc	r10,r10,r5
8000fc32:	5c 0b       	acr	r11
8000fc34:	ed bb 00 14 	bld	r11,0x14
8000fc38:	c0 50       	breq	8000fc42 <__avr32_f64_mul+0x6a>
8000fc3a:	a1 77       	lsl	r7,0x1
8000fc3c:	5c fa       	rol	r10
8000fc3e:	5c fb       	rol	r11
8000fc40:	20 1c       	sub	r12,1
8000fc42:	58 0c       	cp.w	r12,0
8000fc44:	e0 8a 00 6f 	brle	8000fd22 <__avr32_f64_mul_res_subnormal>
8000fc48:	e0 4c 07 ff 	cp.w	r12,2047
8000fc4c:	e0 84 00 9c 	brge	8000fd84 <__avr32_f64_mul_res_inf>
8000fc50:	f7 dc d2 8b 	bfins	r11,r12,0x14,0xb
8000fc54:	ed ea 11 f6 	or	r6,r6,r10<<0x1f
8000fc58:	ef e6 12 17 	or	r7,r7,r6>>0x1
8000fc5c:	ee 17 80 00 	eorh	r7,0x8000
8000fc60:	f1 b7 04 20 	satu	r7,0x1
8000fc64:	0e 0a       	add	r10,r7
8000fc66:	5c 0b       	acr	r11
8000fc68:	ed be 00 1f 	bld	lr,0x1f
8000fc6c:	ef bb 00 1f 	bst	r11,0x1f
8000fc70:	d8 22       	popm	r4-r7,pc

8000fc72 <__avr32_f64_mul_op1_subnormal>:
8000fc72:	e4 1b 00 0f 	andh	r11,0xf
8000fc76:	f4 0c 12 00 	clz	r12,r10
8000fc7a:	f6 06 12 00 	clz	r6,r11
8000fc7e:	f7 bc 03 e1 	sublo	r12,-31
8000fc82:	f8 06 17 30 	movlo	r6,r12
8000fc86:	f7 b6 02 01 	subhs	r6,1
8000fc8a:	e0 46 00 20 	cp.w	r6,32
8000fc8e:	c0 d4       	brge	8000fca8 <__avr32_f64_mul_op1_subnormal+0x36>
8000fc90:	ec 0c 11 20 	rsub	r12,r6,32
8000fc94:	f6 06 09 4b 	lsl	r11,r11,r6
8000fc98:	f4 0c 0a 4c 	lsr	r12,r10,r12
8000fc9c:	18 4b       	or	r11,r12
8000fc9e:	f4 06 09 4a 	lsl	r10,r10,r6
8000fca2:	20 b6       	sub	r6,11
8000fca4:	0c 17       	sub	r7,r6
8000fca6:	ca ab       	rjmp	8000fbfa <__avr32_f64_mul+0x22>
8000fca8:	f4 06 09 4b 	lsl	r11,r10,r6
8000fcac:	c6 40       	breq	8000fd74 <__avr32_f64_mul_res_zero>
8000fcae:	30 0a       	mov	r10,0
8000fcb0:	20 b6       	sub	r6,11
8000fcb2:	0c 17       	sub	r7,r6
8000fcb4:	ca 3b       	rjmp	8000fbfa <__avr32_f64_mul+0x22>

8000fcb6 <__avr32_f64_mul_op2_subnormal>:
8000fcb6:	e4 19 00 0f 	andh	r9,0xf
8000fcba:	f0 0c 12 00 	clz	r12,r8
8000fcbe:	f2 05 12 00 	clz	r5,r9
8000fcc2:	f7 bc 03 ea 	sublo	r12,-22
8000fcc6:	f8 05 17 30 	movlo	r5,r12
8000fcca:	f7 b5 02 0a 	subhs	r5,10
8000fcce:	e0 45 00 20 	cp.w	r5,32
8000fcd2:	c0 d4       	brge	8000fcec <__avr32_f64_mul_op2_subnormal+0x36>
8000fcd4:	ea 0c 11 20 	rsub	r12,r5,32
8000fcd8:	f2 05 09 49 	lsl	r9,r9,r5
8000fcdc:	f0 0c 0a 4c 	lsr	r12,r8,r12
8000fce0:	18 49       	or	r9,r12
8000fce2:	f0 05 09 48 	lsl	r8,r8,r5
8000fce6:	20 25       	sub	r5,2
8000fce8:	0a 16       	sub	r6,r5
8000fcea:	c8 fb       	rjmp	8000fc08 <__avr32_f64_mul+0x30>
8000fcec:	f0 05 09 49 	lsl	r9,r8,r5
8000fcf0:	c4 20       	breq	8000fd74 <__avr32_f64_mul_res_zero>
8000fcf2:	30 08       	mov	r8,0
8000fcf4:	20 25       	sub	r5,2
8000fcf6:	0a 16       	sub	r6,r5
8000fcf8:	c8 8b       	rjmp	8000fc08 <__avr32_f64_mul+0x30>

8000fcfa <__avr32_f64_mul_op_nan_or_inf>:
8000fcfa:	e4 19 00 0f 	andh	r9,0xf
8000fcfe:	e4 1b 00 0f 	andh	r11,0xf
8000fd02:	14 4b       	or	r11,r10
8000fd04:	10 49       	or	r9,r8
8000fd06:	e0 47 07 ff 	cp.w	r7,2047
8000fd0a:	c0 91       	brne	8000fd1c <__avr32_f64_mul_op1_not_naninf>
8000fd0c:	58 0b       	cp.w	r11,0
8000fd0e:	c3 81       	brne	8000fd7e <__avr32_f64_mul_res_nan>
8000fd10:	e0 46 07 ff 	cp.w	r6,2047
8000fd14:	c3 81       	brne	8000fd84 <__avr32_f64_mul_res_inf>
8000fd16:	58 09       	cp.w	r9,0
8000fd18:	c3 60       	breq	8000fd84 <__avr32_f64_mul_res_inf>
8000fd1a:	c3 28       	rjmp	8000fd7e <__avr32_f64_mul_res_nan>

8000fd1c <__avr32_f64_mul_op1_not_naninf>:
8000fd1c:	58 09       	cp.w	r9,0
8000fd1e:	c3 30       	breq	8000fd84 <__avr32_f64_mul_res_inf>
8000fd20:	c2 f8       	rjmp	8000fd7e <__avr32_f64_mul_res_nan>

8000fd22 <__avr32_f64_mul_res_subnormal>:
8000fd22:	5c 3c       	neg	r12
8000fd24:	2f fc       	sub	r12,-1
8000fd26:	f1 bc 04 c0 	satu	r12,0x6
8000fd2a:	e0 4c 00 20 	cp.w	r12,32
8000fd2e:	c1 14       	brge	8000fd50 <__avr32_f64_mul_res_subnormal+0x2e>
8000fd30:	f8 08 11 20 	rsub	r8,r12,32
8000fd34:	0e 46       	or	r6,r7
8000fd36:	ee 0c 0a 47 	lsr	r7,r7,r12
8000fd3a:	f4 08 09 49 	lsl	r9,r10,r8
8000fd3e:	12 47       	or	r7,r9
8000fd40:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000fd44:	f6 08 09 49 	lsl	r9,r11,r8
8000fd48:	12 4a       	or	r10,r9
8000fd4a:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000fd4e:	c8 3b       	rjmp	8000fc54 <__avr32_f64_mul+0x7c>
8000fd50:	f8 08 11 20 	rsub	r8,r12,32
8000fd54:	f9 b9 00 00 	moveq	r9,0
8000fd58:	c0 30       	breq	8000fd5e <__avr32_f64_mul_res_subnormal+0x3c>
8000fd5a:	f6 08 09 49 	lsl	r9,r11,r8
8000fd5e:	0e 46       	or	r6,r7
8000fd60:	ed ea 10 16 	or	r6,r6,r10<<0x1
8000fd64:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000fd68:	f3 ea 10 07 	or	r7,r9,r10
8000fd6c:	f6 0c 0a 4a 	lsr	r10,r11,r12
8000fd70:	30 0b       	mov	r11,0
8000fd72:	c7 1b       	rjmp	8000fc54 <__avr32_f64_mul+0x7c>

8000fd74 <__avr32_f64_mul_res_zero>:
8000fd74:	1c 9b       	mov	r11,lr
8000fd76:	e6 1b 80 00 	andh	r11,0x8000,COH
8000fd7a:	30 0a       	mov	r10,0
8000fd7c:	d8 22       	popm	r4-r7,pc

8000fd7e <__avr32_f64_mul_res_nan>:
8000fd7e:	3f fb       	mov	r11,-1
8000fd80:	3f fa       	mov	r10,-1
8000fd82:	d8 22       	popm	r4-r7,pc

8000fd84 <__avr32_f64_mul_res_inf>:
8000fd84:	f0 6b 00 00 	mov	r11,-1048576
8000fd88:	ed be 00 1f 	bld	lr,0x1f
8000fd8c:	ef bb 00 1f 	bst	r11,0x1f
8000fd90:	30 0a       	mov	r10,0
8000fd92:	d8 22       	popm	r4-r7,pc

8000fd94 <__avr32_f64_mul_op1_zero>:
8000fd94:	f7 e9 20 0b 	eor	r11,r11,r9
8000fd98:	e6 1b 80 00 	andh	r11,0x8000,COH
8000fd9c:	f9 d9 c2 8b 	bfextu	r12,r9,0x14,0xb
8000fda0:	e0 4c 07 ff 	cp.w	r12,2047
8000fda4:	5e 1c       	retne	r12
8000fda6:	3f fa       	mov	r10,-1
8000fda8:	3f fb       	mov	r11,-1
8000fdaa:	5e fc       	retal	r12

8000fdac <__avr32_f64_sub_from_add>:
8000fdac:	ee 19 80 00 	eorh	r9,0x8000

8000fdb0 <__avr32_f64_sub>:
8000fdb0:	f7 e9 20 0c 	eor	r12,r11,r9
8000fdb4:	e0 86 00 ca 	brmi	8000ff48 <__avr32_f64_add_from_sub>
8000fdb8:	eb cd 40 e0 	pushm	r5-r7,lr
8000fdbc:	16 9c       	mov	r12,r11
8000fdbe:	e6 1c 80 00 	andh	r12,0x8000,COH
8000fdc2:	bf db       	cbr	r11,0x1f
8000fdc4:	bf d9       	cbr	r9,0x1f
8000fdc6:	10 3a       	cp.w	r10,r8
8000fdc8:	f2 0b 13 00 	cpc	r11,r9
8000fdcc:	c0 92       	brcc	8000fdde <__avr32_f64_sub+0x2e>
8000fdce:	16 97       	mov	r7,r11
8000fdd0:	12 9b       	mov	r11,r9
8000fdd2:	0e 99       	mov	r9,r7
8000fdd4:	14 97       	mov	r7,r10
8000fdd6:	10 9a       	mov	r10,r8
8000fdd8:	0e 98       	mov	r8,r7
8000fdda:	ee 1c 80 00 	eorh	r12,0x8000
8000fdde:	f6 07 16 14 	lsr	r7,r11,0x14
8000fde2:	ab 7b       	lsl	r11,0xb
8000fde4:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000fde8:	ab 7a       	lsl	r10,0xb
8000fdea:	bf bb       	sbr	r11,0x1f
8000fdec:	f2 06 16 14 	lsr	r6,r9,0x14
8000fdf0:	c4 40       	breq	8000fe78 <__avr32_f64_sub_opL_subnormal>
8000fdf2:	ab 79       	lsl	r9,0xb
8000fdf4:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000fdf8:	ab 78       	lsl	r8,0xb
8000fdfa:	bf b9       	sbr	r9,0x1f

8000fdfc <__avr32_f64_sub_opL_subnormal_done>:
8000fdfc:	e0 47 07 ff 	cp.w	r7,2047
8000fe00:	c4 f0       	breq	8000fe9e <__avr32_f64_sub_opH_nan_or_inf>
8000fe02:	0e 26       	rsub	r6,r7
8000fe04:	c1 20       	breq	8000fe28 <__avr32_f64_sub_shift_done>
8000fe06:	ec 05 11 20 	rsub	r5,r6,32
8000fe0a:	e0 46 00 20 	cp.w	r6,32
8000fe0e:	c7 c2       	brcc	8000ff06 <__avr32_f64_sub_longshift>
8000fe10:	f0 05 09 4e 	lsl	lr,r8,r5
8000fe14:	f2 05 09 45 	lsl	r5,r9,r5
8000fe18:	f0 06 0a 48 	lsr	r8,r8,r6
8000fe1c:	f2 06 0a 49 	lsr	r9,r9,r6
8000fe20:	0a 48       	or	r8,r5
8000fe22:	58 0e       	cp.w	lr,0
8000fe24:	5f 1e       	srne	lr
8000fe26:	1c 48       	or	r8,lr

8000fe28 <__avr32_f64_sub_shift_done>:
8000fe28:	10 1a       	sub	r10,r8
8000fe2a:	f6 09 01 4b 	sbc	r11,r11,r9
8000fe2e:	f6 06 12 00 	clz	r6,r11
8000fe32:	c0 e0       	breq	8000fe4e <__avr32_f64_sub_longnormalize_done>
8000fe34:	c7 83       	brcs	8000ff24 <__avr32_f64_sub_longnormalize>
8000fe36:	ec 0e 11 20 	rsub	lr,r6,32
8000fe3a:	f6 06 09 4b 	lsl	r11,r11,r6
8000fe3e:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000fe42:	1c 4b       	or	r11,lr
8000fe44:	f4 06 09 4a 	lsl	r10,r10,r6
8000fe48:	0c 17       	sub	r7,r6
8000fe4a:	e0 8a 00 39 	brle	8000febc <__avr32_f64_sub_subnormal_result>

8000fe4e <__avr32_f64_sub_longnormalize_done>:
8000fe4e:	f4 09 15 15 	lsl	r9,r10,0x15
8000fe52:	ab 9a       	lsr	r10,0xb
8000fe54:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000fe58:	ab 9b       	lsr	r11,0xb
8000fe5a:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000fe5e:	18 4b       	or	r11,r12

8000fe60 <__avr32_f64_sub_round>:
8000fe60:	fc 17 80 00 	movh	r7,0x8000
8000fe64:	ed ba 00 00 	bld	r10,0x0
8000fe68:	f7 b7 01 ff 	subne	r7,-1
8000fe6c:	0e 39       	cp.w	r9,r7
8000fe6e:	5f 29       	srhs	r9
8000fe70:	12 0a       	add	r10,r9
8000fe72:	5c 0b       	acr	r11
8000fe74:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000fe78 <__avr32_f64_sub_opL_subnormal>:
8000fe78:	ab 79       	lsl	r9,0xb
8000fe7a:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000fe7e:	ab 78       	lsl	r8,0xb
8000fe80:	f3 e8 10 0e 	or	lr,r9,r8
8000fe84:	f9 b6 01 01 	movne	r6,1
8000fe88:	ee 0e 11 00 	rsub	lr,r7,0
8000fe8c:	f9 b7 00 01 	moveq	r7,1
8000fe90:	ef bb 00 1f 	bst	r11,0x1f
8000fe94:	f7 ea 10 0e 	or	lr,r11,r10
8000fe98:	f9 b7 00 00 	moveq	r7,0
8000fe9c:	cb 0b       	rjmp	8000fdfc <__avr32_f64_sub_opL_subnormal_done>

8000fe9e <__avr32_f64_sub_opH_nan_or_inf>:
8000fe9e:	bf db       	cbr	r11,0x1f
8000fea0:	f7 ea 10 0e 	or	lr,r11,r10
8000fea4:	c0 81       	brne	8000feb4 <__avr32_f64_sub_return_nan>
8000fea6:	e0 46 07 ff 	cp.w	r6,2047
8000feaa:	c0 50       	breq	8000feb4 <__avr32_f64_sub_return_nan>
8000feac:	f9 e7 11 4b 	or	r11,r12,r7<<0x14
8000feb0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000feb4 <__avr32_f64_sub_return_nan>:
8000feb4:	3f fa       	mov	r10,-1
8000feb6:	3f fb       	mov	r11,-1
8000feb8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000febc <__avr32_f64_sub_subnormal_result>:
8000febc:	5c 37       	neg	r7
8000febe:	2f f7       	sub	r7,-1
8000fec0:	f1 b7 04 c0 	satu	r7,0x6
8000fec4:	e0 47 00 20 	cp.w	r7,32
8000fec8:	c1 14       	brge	8000feea <__avr32_f64_sub_subnormal_result+0x2e>
8000feca:	ee 08 11 20 	rsub	r8,r7,32
8000fece:	f4 08 09 49 	lsl	r9,r10,r8
8000fed2:	5f 16       	srne	r6
8000fed4:	f4 07 0a 4a 	lsr	r10,r10,r7
8000fed8:	0c 4a       	or	r10,r6
8000feda:	f6 08 09 49 	lsl	r9,r11,r8
8000fede:	f5 e9 10 0a 	or	r10,r10,r9
8000fee2:	f4 07 0a 4b 	lsr	r11,r10,r7
8000fee6:	30 07       	mov	r7,0
8000fee8:	cb 3b       	rjmp	8000fe4e <__avr32_f64_sub_longnormalize_done>
8000feea:	ee 08 11 40 	rsub	r8,r7,64
8000feee:	f6 08 09 49 	lsl	r9,r11,r8
8000fef2:	14 49       	or	r9,r10
8000fef4:	5f 16       	srne	r6
8000fef6:	f6 07 0a 4a 	lsr	r10,r11,r7
8000fefa:	0c 4a       	or	r10,r6
8000fefc:	30 0b       	mov	r11,0
8000fefe:	30 07       	mov	r7,0
8000ff00:	ca 7b       	rjmp	8000fe4e <__avr32_f64_sub_longnormalize_done>
8000ff02:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000ff06 <__avr32_f64_sub_longshift>:
8000ff06:	f1 b6 04 c0 	satu	r6,0x6
8000ff0a:	f0 0e 17 00 	moveq	lr,r8
8000ff0e:	c0 40       	breq	8000ff16 <__avr32_f64_sub_longshift+0x10>
8000ff10:	f2 05 09 4e 	lsl	lr,r9,r5
8000ff14:	10 4e       	or	lr,r8
8000ff16:	f2 06 0a 48 	lsr	r8,r9,r6
8000ff1a:	30 09       	mov	r9,0
8000ff1c:	58 0e       	cp.w	lr,0
8000ff1e:	5f 1e       	srne	lr
8000ff20:	1c 48       	or	r8,lr
8000ff22:	c8 3b       	rjmp	8000fe28 <__avr32_f64_sub_shift_done>

8000ff24 <__avr32_f64_sub_longnormalize>:
8000ff24:	f4 06 12 00 	clz	r6,r10
8000ff28:	f9 b7 03 00 	movlo	r7,0
8000ff2c:	f9 b6 03 00 	movlo	r6,0
8000ff30:	f9 bc 03 00 	movlo	r12,0
8000ff34:	f7 b6 02 e0 	subhs	r6,-32
8000ff38:	f4 06 09 4b 	lsl	r11,r10,r6
8000ff3c:	30 0a       	mov	r10,0
8000ff3e:	0c 17       	sub	r7,r6
8000ff40:	fe 9a ff be 	brle	8000febc <__avr32_f64_sub_subnormal_result>
8000ff44:	c8 5b       	rjmp	8000fe4e <__avr32_f64_sub_longnormalize_done>
8000ff46:	d7 03       	nop

8000ff48 <__avr32_f64_add_from_sub>:
8000ff48:	ee 19 80 00 	eorh	r9,0x8000

8000ff4c <__avr32_f64_add>:
8000ff4c:	f7 e9 20 0c 	eor	r12,r11,r9
8000ff50:	fe 96 ff 2e 	brmi	8000fdac <__avr32_f64_sub_from_add>
8000ff54:	eb cd 40 e0 	pushm	r5-r7,lr
8000ff58:	16 9c       	mov	r12,r11
8000ff5a:	e6 1c 80 00 	andh	r12,0x8000,COH
8000ff5e:	bf db       	cbr	r11,0x1f
8000ff60:	bf d9       	cbr	r9,0x1f
8000ff62:	12 3b       	cp.w	r11,r9
8000ff64:	c0 72       	brcc	8000ff72 <__avr32_f64_add+0x26>
8000ff66:	16 97       	mov	r7,r11
8000ff68:	12 9b       	mov	r11,r9
8000ff6a:	0e 99       	mov	r9,r7
8000ff6c:	14 97       	mov	r7,r10
8000ff6e:	10 9a       	mov	r10,r8
8000ff70:	0e 98       	mov	r8,r7
8000ff72:	30 0e       	mov	lr,0
8000ff74:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000ff78:	f7 db c0 14 	bfextu	r11,r11,0x0,0x14
8000ff7c:	b5 ab       	sbr	r11,0x14
8000ff7e:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000ff82:	c6 20       	breq	80010046 <__avr32_f64_add_op2_subnormal>
8000ff84:	f3 d9 c0 14 	bfextu	r9,r9,0x0,0x14
8000ff88:	b5 a9       	sbr	r9,0x14
8000ff8a:	e0 47 07 ff 	cp.w	r7,2047
8000ff8e:	c2 80       	breq	8000ffde <__avr32_f64_add_opH_nan_or_inf>
8000ff90:	0e 26       	rsub	r6,r7
8000ff92:	c1 20       	breq	8000ffb6 <__avr32_f64_add_shift_done>
8000ff94:	e0 46 00 36 	cp.w	r6,54
8000ff98:	c1 52       	brcc	8000ffc2 <__avr32_f64_add_res_of_done>
8000ff9a:	ec 05 11 20 	rsub	r5,r6,32
8000ff9e:	e0 46 00 20 	cp.w	r6,32
8000ffa2:	c3 52       	brcc	8001000c <__avr32_f64_add_longshift>
8000ffa4:	f0 05 09 4e 	lsl	lr,r8,r5
8000ffa8:	f2 05 09 45 	lsl	r5,r9,r5
8000ffac:	f0 06 0a 48 	lsr	r8,r8,r6
8000ffb0:	f2 06 0a 49 	lsr	r9,r9,r6
8000ffb4:	0a 48       	or	r8,r5

8000ffb6 <__avr32_f64_add_shift_done>:
8000ffb6:	10 0a       	add	r10,r8
8000ffb8:	f6 09 00 4b 	adc	r11,r11,r9
8000ffbc:	ed bb 00 15 	bld	r11,0x15
8000ffc0:	c3 40       	breq	80010028 <__avr32_f64_add_res_of>

8000ffc2 <__avr32_f64_add_res_of_done>:
8000ffc2:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000ffc6:	18 4b       	or	r11,r12

8000ffc8 <__avr32_f64_add_round>:
8000ffc8:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
8000ffcc:	18 4e       	or	lr,r12
8000ffce:	ee 1e 80 00 	eorh	lr,0x8000
8000ffd2:	f1 be 04 20 	satu	lr,0x1
8000ffd6:	1c 0a       	add	r10,lr
8000ffd8:	5c 0b       	acr	r11
8000ffda:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000ffde <__avr32_f64_add_opH_nan_or_inf>:
8000ffde:	b5 cb       	cbr	r11,0x14
8000ffe0:	f7 ea 10 0e 	or	lr,r11,r10
8000ffe4:	c1 01       	brne	80010004 <__avr32_f64_add_return_nan>
8000ffe6:	e0 46 07 ff 	cp.w	r6,2047
8000ffea:	c0 30       	breq	8000fff0 <__avr32_f64_add_opL_nan_or_inf>
8000ffec:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000fff0 <__avr32_f64_add_opL_nan_or_inf>:
8000fff0:	b5 c9       	cbr	r9,0x14
8000fff2:	f3 e8 10 0e 	or	lr,r9,r8
8000fff6:	c0 71       	brne	80010004 <__avr32_f64_add_return_nan>
8000fff8:	30 0a       	mov	r10,0
8000fffa:	fc 1b 7f f0 	movh	r11,0x7ff0
8000fffe:	18 4b       	or	r11,r12
80010000:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

80010004 <__avr32_f64_add_return_nan>:
80010004:	3f fa       	mov	r10,-1
80010006:	3f fb       	mov	r11,-1
80010008:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8001000c <__avr32_f64_add_longshift>:
8001000c:	f1 b6 04 c0 	satu	r6,0x6
80010010:	f0 0e 17 00 	moveq	lr,r8
80010014:	c0 60       	breq	80010020 <__avr32_f64_add_longshift+0x14>
80010016:	f2 05 09 4e 	lsl	lr,r9,r5
8001001a:	58 08       	cp.w	r8,0
8001001c:	5f 18       	srne	r8
8001001e:	10 4e       	or	lr,r8
80010020:	f2 06 0a 48 	lsr	r8,r9,r6
80010024:	30 09       	mov	r9,0
80010026:	cc 8b       	rjmp	8000ffb6 <__avr32_f64_add_shift_done>

80010028 <__avr32_f64_add_res_of>:
80010028:	fd ee 10 1e 	or	lr,lr,lr<<0x1
8001002c:	a1 9b       	lsr	r11,0x1
8001002e:	5d 0a       	ror	r10
80010030:	5d 0e       	ror	lr
80010032:	2f f7       	sub	r7,-1
80010034:	e0 47 07 ff 	cp.w	r7,2047
80010038:	f9 ba 00 00 	moveq	r10,0
8001003c:	f9 bb 00 00 	moveq	r11,0
80010040:	f9 be 00 00 	moveq	lr,0
80010044:	cb fb       	rjmp	8000ffc2 <__avr32_f64_add_res_of_done>

80010046 <__avr32_f64_add_op2_subnormal>:
80010046:	30 16       	mov	r6,1
80010048:	58 07       	cp.w	r7,0
8001004a:	ca 01       	brne	8000ff8a <__avr32_f64_add+0x3e>
8001004c:	b5 cb       	cbr	r11,0x14
8001004e:	10 0a       	add	r10,r8
80010050:	f6 09 00 4b 	adc	r11,r11,r9
80010054:	18 4b       	or	r11,r12
80010056:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8001005a:	d7 03       	nop

8001005c <__avr32_f64_to_u32>:
8001005c:	58 0b       	cp.w	r11,0
8001005e:	5e 6d       	retmi	0

80010060 <__avr32_f64_to_s32>:
80010060:	f6 0c 15 01 	lsl	r12,r11,0x1
80010064:	b5 9c       	lsr	r12,0x15
80010066:	e0 2c 03 ff 	sub	r12,1023
8001006a:	5e 3d       	retlo	0
8001006c:	f8 0c 11 1f 	rsub	r12,r12,31
80010070:	16 99       	mov	r9,r11
80010072:	ab 7b       	lsl	r11,0xb
80010074:	bf bb       	sbr	r11,0x1f
80010076:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8001007a:	f6 0c 0a 4b 	lsr	r11,r11,r12
8001007e:	a1 79       	lsl	r9,0x1
80010080:	5e 2b       	reths	r11
80010082:	5c 3b       	neg	r11
80010084:	5e fb       	retal	r11

80010086 <__avr32_u32_to_f64>:
80010086:	f8 cb 00 00 	sub	r11,r12,0
8001008a:	30 0c       	mov	r12,0
8001008c:	c0 38       	rjmp	80010092 <__avr32_s32_to_f64+0x4>

8001008e <__avr32_s32_to_f64>:
8001008e:	18 9b       	mov	r11,r12
80010090:	5c 4b       	abs	r11
80010092:	30 0a       	mov	r10,0
80010094:	5e 0b       	reteq	r11
80010096:	d4 01       	pushm	lr
80010098:	e0 69 04 1e 	mov	r9,1054
8001009c:	f6 08 12 00 	clz	r8,r11
800100a0:	c1 70       	breq	800100ce <__avr32_s32_to_f64+0x40>
800100a2:	c0 c3       	brcs	800100ba <__avr32_s32_to_f64+0x2c>
800100a4:	f0 0e 11 20 	rsub	lr,r8,32
800100a8:	f6 08 09 4b 	lsl	r11,r11,r8
800100ac:	f4 0e 0a 4e 	lsr	lr,r10,lr
800100b0:	1c 4b       	or	r11,lr
800100b2:	f4 08 09 4a 	lsl	r10,r10,r8
800100b6:	10 19       	sub	r9,r8
800100b8:	c0 b8       	rjmp	800100ce <__avr32_s32_to_f64+0x40>
800100ba:	f4 08 12 00 	clz	r8,r10
800100be:	f9 b8 03 00 	movlo	r8,0
800100c2:	f7 b8 02 e0 	subhs	r8,-32
800100c6:	f4 08 09 4b 	lsl	r11,r10,r8
800100ca:	30 0a       	mov	r10,0
800100cc:	10 19       	sub	r9,r8
800100ce:	58 09       	cp.w	r9,0
800100d0:	e0 89 00 30 	brgt	80010130 <__avr32_s32_to_f64+0xa2>
800100d4:	5c 39       	neg	r9
800100d6:	2f f9       	sub	r9,-1
800100d8:	e0 49 00 36 	cp.w	r9,54
800100dc:	c0 43       	brcs	800100e4 <__avr32_s32_to_f64+0x56>
800100de:	30 0b       	mov	r11,0
800100e0:	30 0a       	mov	r10,0
800100e2:	c2 68       	rjmp	8001012e <__avr32_s32_to_f64+0xa0>
800100e4:	2f 69       	sub	r9,-10
800100e6:	f2 08 11 20 	rsub	r8,r9,32
800100ea:	e0 49 00 20 	cp.w	r9,32
800100ee:	c0 b2       	brcc	80010104 <__avr32_s32_to_f64+0x76>
800100f0:	f4 08 09 4e 	lsl	lr,r10,r8
800100f4:	f6 08 09 48 	lsl	r8,r11,r8
800100f8:	f4 09 0a 4a 	lsr	r10,r10,r9
800100fc:	f6 09 0a 4b 	lsr	r11,r11,r9
80010100:	10 4b       	or	r11,r8
80010102:	c0 88       	rjmp	80010112 <__avr32_s32_to_f64+0x84>
80010104:	f6 08 09 4e 	lsl	lr,r11,r8
80010108:	14 4e       	or	lr,r10
8001010a:	16 9a       	mov	r10,r11
8001010c:	30 0b       	mov	r11,0
8001010e:	f4 09 0a 4a 	lsr	r10,r10,r9
80010112:	ed ba 00 00 	bld	r10,0x0
80010116:	c0 92       	brcc	80010128 <__avr32_s32_to_f64+0x9a>
80010118:	1c 7e       	tst	lr,lr
8001011a:	c0 41       	brne	80010122 <__avr32_s32_to_f64+0x94>
8001011c:	ed ba 00 01 	bld	r10,0x1
80010120:	c0 42       	brcc	80010128 <__avr32_s32_to_f64+0x9a>
80010122:	2f fa       	sub	r10,-1
80010124:	f7 bb 02 ff 	subhs	r11,-1
80010128:	5c fc       	rol	r12
8001012a:	5d 0b       	ror	r11
8001012c:	5d 0a       	ror	r10
8001012e:	d8 02       	popm	pc
80010130:	e0 68 03 ff 	mov	r8,1023
80010134:	ed ba 00 0b 	bld	r10,0xb
80010138:	f7 b8 00 ff 	subeq	r8,-1
8001013c:	10 0a       	add	r10,r8
8001013e:	5c 0b       	acr	r11
80010140:	f7 b9 03 fe 	sublo	r9,-2
80010144:	e0 49 07 ff 	cp.w	r9,2047
80010148:	c0 55       	brlt	80010152 <__avr32_s32_to_f64+0xc4>
8001014a:	30 0a       	mov	r10,0
8001014c:	fc 1b ff e0 	movh	r11,0xffe0
80010150:	c0 c8       	rjmp	80010168 <__floatsidf_return_op1>
80010152:	ed bb 00 1f 	bld	r11,0x1f
80010156:	f7 b9 01 01 	subne	r9,1
8001015a:	ab 9a       	lsr	r10,0xb
8001015c:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
80010160:	a1 7b       	lsl	r11,0x1
80010162:	ab 9b       	lsr	r11,0xb
80010164:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

80010168 <__floatsidf_return_op1>:
80010168:	a1 7c       	lsl	r12,0x1
8001016a:	5d 0b       	ror	r11
8001016c:	d8 02       	popm	pc

8001016e <__avr32_f64_cmp_eq>:
8001016e:	10 3a       	cp.w	r10,r8
80010170:	f2 0b 13 00 	cpc	r11,r9
80010174:	c0 80       	breq	80010184 <__avr32_f64_cmp_eq+0x16>
80010176:	a1 7b       	lsl	r11,0x1
80010178:	a1 79       	lsl	r9,0x1
8001017a:	14 4b       	or	r11,r10
8001017c:	12 4b       	or	r11,r9
8001017e:	10 4b       	or	r11,r8
80010180:	5e 0f       	reteq	1
80010182:	5e fd       	retal	0
80010184:	a1 7b       	lsl	r11,0x1
80010186:	fc 1c ff e0 	movh	r12,0xffe0
8001018a:	58 0a       	cp.w	r10,0
8001018c:	f8 0b 13 00 	cpc	r11,r12
80010190:	5e 8f       	retls	1
80010192:	5e fd       	retal	0

80010194 <__avr32_f64_cmp_ge>:
80010194:	1a de       	st.w	--sp,lr
80010196:	1a d7       	st.w	--sp,r7
80010198:	a1 7b       	lsl	r11,0x1
8001019a:	5f 3c       	srlo	r12
8001019c:	a1 79       	lsl	r9,0x1
8001019e:	5f 37       	srlo	r7
800101a0:	5c fc       	rol	r12
800101a2:	fc 1e ff e0 	movh	lr,0xffe0
800101a6:	58 0a       	cp.w	r10,0
800101a8:	fc 0b 13 00 	cpc	r11,lr
800101ac:	e0 8b 00 1d 	brhi	800101e6 <__avr32_f64_cmp_ge+0x52>
800101b0:	58 08       	cp.w	r8,0
800101b2:	fc 09 13 00 	cpc	r9,lr
800101b6:	e0 8b 00 18 	brhi	800101e6 <__avr32_f64_cmp_ge+0x52>
800101ba:	58 0b       	cp.w	r11,0
800101bc:	f5 ba 00 00 	subfeq	r10,0
800101c0:	c1 50       	breq	800101ea <__avr32_f64_cmp_ge+0x56>
800101c2:	1b 07       	ld.w	r7,sp++
800101c4:	1b 0e       	ld.w	lr,sp++
800101c6:	58 3c       	cp.w	r12,3
800101c8:	c0 a0       	breq	800101dc <__avr32_f64_cmp_ge+0x48>
800101ca:	58 1c       	cp.w	r12,1
800101cc:	c0 33       	brcs	800101d2 <__avr32_f64_cmp_ge+0x3e>
800101ce:	5e 0f       	reteq	1
800101d0:	5e 1d       	retne	0
800101d2:	10 3a       	cp.w	r10,r8
800101d4:	f2 0b 13 00 	cpc	r11,r9
800101d8:	5e 2f       	reths	1
800101da:	5e 3d       	retlo	0
800101dc:	14 38       	cp.w	r8,r10
800101de:	f6 09 13 00 	cpc	r9,r11
800101e2:	5e 2f       	reths	1
800101e4:	5e 3d       	retlo	0
800101e6:	1b 07       	ld.w	r7,sp++
800101e8:	d8 0a       	popm	pc,r12=0
800101ea:	58 17       	cp.w	r7,1
800101ec:	5f 0c       	sreq	r12
800101ee:	58 09       	cp.w	r9,0
800101f0:	f5 b8 00 00 	subfeq	r8,0
800101f4:	1b 07       	ld.w	r7,sp++
800101f6:	1b 0e       	ld.w	lr,sp++
800101f8:	5e 0f       	reteq	1
800101fa:	5e fc       	retal	r12

800101fc <__avr32_f64_cmp_lt>:
800101fc:	1a de       	st.w	--sp,lr
800101fe:	1a d7       	st.w	--sp,r7
80010200:	a1 7b       	lsl	r11,0x1
80010202:	5f 3c       	srlo	r12
80010204:	a1 79       	lsl	r9,0x1
80010206:	5f 37       	srlo	r7
80010208:	5c fc       	rol	r12
8001020a:	fc 1e ff e0 	movh	lr,0xffe0
8001020e:	58 0a       	cp.w	r10,0
80010210:	fc 0b 13 00 	cpc	r11,lr
80010214:	e0 8b 00 1d 	brhi	8001024e <__avr32_f64_cmp_lt+0x52>
80010218:	58 08       	cp.w	r8,0
8001021a:	fc 09 13 00 	cpc	r9,lr
8001021e:	e0 8b 00 18 	brhi	8001024e <__avr32_f64_cmp_lt+0x52>
80010222:	58 0b       	cp.w	r11,0
80010224:	f5 ba 00 00 	subfeq	r10,0
80010228:	c1 50       	breq	80010252 <__avr32_f64_cmp_lt+0x56>
8001022a:	1b 07       	ld.w	r7,sp++
8001022c:	1b 0e       	ld.w	lr,sp++
8001022e:	58 3c       	cp.w	r12,3
80010230:	c0 a0       	breq	80010244 <__avr32_f64_cmp_lt+0x48>
80010232:	58 1c       	cp.w	r12,1
80010234:	c0 33       	brcs	8001023a <__avr32_f64_cmp_lt+0x3e>
80010236:	5e 0d       	reteq	0
80010238:	5e 1f       	retne	1
8001023a:	10 3a       	cp.w	r10,r8
8001023c:	f2 0b 13 00 	cpc	r11,r9
80010240:	5e 2d       	reths	0
80010242:	5e 3f       	retlo	1
80010244:	14 38       	cp.w	r8,r10
80010246:	f6 09 13 00 	cpc	r9,r11
8001024a:	5e 2d       	reths	0
8001024c:	5e 3f       	retlo	1
8001024e:	1b 07       	ld.w	r7,sp++
80010250:	d8 0a       	popm	pc,r12=0
80010252:	58 17       	cp.w	r7,1
80010254:	5f 1c       	srne	r12
80010256:	58 09       	cp.w	r9,0
80010258:	f5 b8 00 00 	subfeq	r8,0
8001025c:	1b 07       	ld.w	r7,sp++
8001025e:	1b 0e       	ld.w	lr,sp++
80010260:	5e 0d       	reteq	0
80010262:	5e fc       	retal	r12

80010264 <__avr32_f64_div>:
80010264:	eb cd 40 ff 	pushm	r0-r7,lr
80010268:	f7 e9 20 0e 	eor	lr,r11,r9
8001026c:	f6 07 16 14 	lsr	r7,r11,0x14
80010270:	a9 7b       	lsl	r11,0x9
80010272:	f7 ea 13 7b 	or	r11,r11,r10>>0x17
80010276:	a9 7a       	lsl	r10,0x9
80010278:	bd bb       	sbr	r11,0x1d
8001027a:	e4 1b 3f ff 	andh	r11,0x3fff
8001027e:	ab d7       	cbr	r7,0xb
80010280:	e0 80 00 cc 	breq	80010418 <__avr32_f64_div_round_subnormal+0x54>
80010284:	e0 47 07 ff 	cp.w	r7,2047
80010288:	e0 84 00 b5 	brge	800103f2 <__avr32_f64_div_round_subnormal+0x2e>
8001028c:	f2 06 16 14 	lsr	r6,r9,0x14
80010290:	a9 79       	lsl	r9,0x9
80010292:	f3 e8 13 79 	or	r9,r9,r8>>0x17
80010296:	a9 78       	lsl	r8,0x9
80010298:	bd b9       	sbr	r9,0x1d
8001029a:	e4 19 3f ff 	andh	r9,0x3fff
8001029e:	ab d6       	cbr	r6,0xb
800102a0:	e0 80 00 e2 	breq	80010464 <__avr32_f64_div_round_subnormal+0xa0>
800102a4:	e0 46 07 ff 	cp.w	r6,2047
800102a8:	e0 84 00 b2 	brge	8001040c <__avr32_f64_div_round_subnormal+0x48>
800102ac:	0c 17       	sub	r7,r6
800102ae:	fe 37 fc 01 	sub	r7,-1023
800102b2:	fc 1c 80 00 	movh	r12,0x8000
800102b6:	f8 03 16 01 	lsr	r3,r12,0x1
800102ba:	e9 d9 c3 62 	bfextu	r4,r9,0x1b,0x2
800102be:	5c d4       	com	r4
800102c0:	e7 d4 d3 82 	bfins	r3,r4,0x1c,0x2
800102c4:	e6 09 06 44 	mulu.d	r4,r3,r9
800102c8:	f8 05 01 25 	sub	r5,r12,r5<<0x2
800102cc:	e6 05 06 44 	mulu.d	r4,r3,r5
800102d0:	ea 03 15 02 	lsl	r3,r5,0x2
800102d4:	e6 09 06 44 	mulu.d	r4,r3,r9
800102d8:	f8 05 01 25 	sub	r5,r12,r5<<0x2
800102dc:	e6 05 06 44 	mulu.d	r4,r3,r5
800102e0:	ea 03 15 02 	lsl	r3,r5,0x2
800102e4:	e6 09 06 44 	mulu.d	r4,r3,r9
800102e8:	f8 05 01 25 	sub	r5,r12,r5<<0x2
800102ec:	e6 05 06 44 	mulu.d	r4,r3,r5
800102f0:	ea 03 15 02 	lsl	r3,r5,0x2
800102f4:	e6 08 06 40 	mulu.d	r0,r3,r8
800102f8:	e4 09 07 40 	macu.d	r0,r2,r9
800102fc:	e6 09 06 44 	mulu.d	r4,r3,r9
80010300:	02 04       	add	r4,r1
80010302:	5c 05       	acr	r5
80010304:	a3 65       	lsl	r5,0x2
80010306:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8001030a:	a3 64       	lsl	r4,0x2
8001030c:	5c 34       	neg	r4
8001030e:	f8 05 01 45 	sbc	r5,r12,r5
80010312:	e6 04 06 40 	mulu.d	r0,r3,r4
80010316:	e4 05 07 40 	macu.d	r0,r2,r5
8001031a:	e6 05 06 44 	mulu.d	r4,r3,r5
8001031e:	02 04       	add	r4,r1
80010320:	5c 05       	acr	r5
80010322:	ea 03 15 02 	lsl	r3,r5,0x2
80010326:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8001032a:	e8 02 15 02 	lsl	r2,r4,0x2
8001032e:	e6 08 06 40 	mulu.d	r0,r3,r8
80010332:	e4 09 07 40 	macu.d	r0,r2,r9
80010336:	e6 09 06 44 	mulu.d	r4,r3,r9
8001033a:	02 04       	add	r4,r1
8001033c:	5c 05       	acr	r5
8001033e:	a3 65       	lsl	r5,0x2
80010340:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
80010344:	a3 64       	lsl	r4,0x2
80010346:	5c 34       	neg	r4
80010348:	f8 05 01 45 	sbc	r5,r12,r5
8001034c:	e6 04 06 40 	mulu.d	r0,r3,r4
80010350:	e4 05 07 40 	macu.d	r0,r2,r5
80010354:	e6 05 06 44 	mulu.d	r4,r3,r5
80010358:	02 04       	add	r4,r1
8001035a:	5c 05       	acr	r5
8001035c:	ea 03 15 02 	lsl	r3,r5,0x2
80010360:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
80010364:	e8 02 15 02 	lsl	r2,r4,0x2
80010368:	e6 0a 06 40 	mulu.d	r0,r3,r10
8001036c:	e4 0b 07 40 	macu.d	r0,r2,r11
80010370:	e6 0b 06 42 	mulu.d	r2,r3,r11
80010374:	02 02       	add	r2,r1
80010376:	5c 03       	acr	r3
80010378:	ed b3 00 1c 	bld	r3,0x1c
8001037c:	c0 90       	breq	8001038e <__avr32_f64_div+0x12a>
8001037e:	a1 72       	lsl	r2,0x1
80010380:	5c f3       	rol	r3
80010382:	20 17       	sub	r7,1
80010384:	a3 9a       	lsr	r10,0x3
80010386:	f5 eb 11 da 	or	r10,r10,r11<<0x1d
8001038a:	a3 9b       	lsr	r11,0x3
8001038c:	c0 58       	rjmp	80010396 <__avr32_f64_div+0x132>
8001038e:	a5 8a       	lsr	r10,0x4
80010390:	f5 eb 11 ca 	or	r10,r10,r11<<0x1c
80010394:	a5 8b       	lsr	r11,0x4
80010396:	58 07       	cp.w	r7,0
80010398:	e0 8a 00 8b 	brle	800104ae <__avr32_f64_div_res_subnormal>
8001039c:	e0 12 ff 00 	andl	r2,0xff00
800103a0:	e8 12 00 80 	orl	r2,0x80
800103a4:	e6 08 06 40 	mulu.d	r0,r3,r8
800103a8:	e4 09 07 40 	macu.d	r0,r2,r9
800103ac:	e4 08 06 44 	mulu.d	r4,r2,r8
800103b0:	e6 09 06 48 	mulu.d	r8,r3,r9
800103b4:	00 05       	add	r5,r0
800103b6:	f0 01 00 48 	adc	r8,r8,r1
800103ba:	5c 09       	acr	r9
800103bc:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
800103c0:	58 04       	cp.w	r4,0
800103c2:	5c 25       	cpc	r5

800103c4 <__avr32_f64_div_round_subnormal>:
800103c4:	f4 08 13 00 	cpc	r8,r10
800103c8:	f6 09 13 00 	cpc	r9,r11
800103cc:	5f 36       	srlo	r6
800103ce:	f8 06 17 00 	moveq	r6,r12
800103d2:	e4 0a 16 08 	lsr	r10,r2,0x8
800103d6:	f5 e3 11 8a 	or	r10,r10,r3<<0x18
800103da:	e6 0b 16 08 	lsr	r11,r3,0x8
800103de:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
800103e2:	ed be 00 1f 	bld	lr,0x1f
800103e6:	ef bb 00 1f 	bst	r11,0x1f
800103ea:	0c 0a       	add	r10,r6
800103ec:	5c 0b       	acr	r11
800103ee:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
800103f2:	e4 1b 00 0f 	andh	r11,0xf
800103f6:	14 4b       	or	r11,r10
800103f8:	e0 81 00 a7 	brne	80010546 <__avr32_f64_div_res_subnormal+0x98>
800103fc:	f2 06 16 14 	lsr	r6,r9,0x14
80010400:	ab d6       	cbr	r6,0xb
80010402:	e0 46 07 ff 	cp.w	r6,2047
80010406:	e0 81 00 a4 	brne	8001054e <__avr32_f64_div_res_subnormal+0xa0>
8001040a:	c9 e8       	rjmp	80010546 <__avr32_f64_div_res_subnormal+0x98>
8001040c:	e4 19 00 0f 	andh	r9,0xf
80010410:	10 49       	or	r9,r8
80010412:	e0 81 00 9a 	brne	80010546 <__avr32_f64_div_res_subnormal+0x98>
80010416:	c9 28       	rjmp	8001053a <__avr32_f64_div_res_subnormal+0x8c>
80010418:	a3 7b       	lsl	r11,0x3
8001041a:	f7 ea 13 db 	or	r11,r11,r10>>0x1d
8001041e:	a3 7a       	lsl	r10,0x3
80010420:	f5 eb 10 04 	or	r4,r10,r11
80010424:	e0 80 00 a0 	breq	80010564 <__avr32_f64_div_op1_zero>
80010428:	f6 04 12 00 	clz	r4,r11
8001042c:	c1 70       	breq	8001045a <__avr32_f64_div_round_subnormal+0x96>
8001042e:	c0 c3       	brcs	80010446 <__avr32_f64_div_round_subnormal+0x82>
80010430:	e8 05 11 20 	rsub	r5,r4,32
80010434:	f6 04 09 4b 	lsl	r11,r11,r4
80010438:	f4 05 0a 45 	lsr	r5,r10,r5
8001043c:	0a 4b       	or	r11,r5
8001043e:	f4 04 09 4a 	lsl	r10,r10,r4
80010442:	08 17       	sub	r7,r4
80010444:	c0 b8       	rjmp	8001045a <__avr32_f64_div_round_subnormal+0x96>
80010446:	f4 04 12 00 	clz	r4,r10
8001044a:	f9 b4 03 00 	movlo	r4,0
8001044e:	f7 b4 02 e0 	subhs	r4,-32
80010452:	f4 04 09 4b 	lsl	r11,r10,r4
80010456:	30 0a       	mov	r10,0
80010458:	08 17       	sub	r7,r4
8001045a:	a3 8a       	lsr	r10,0x2
8001045c:	f5 eb 11 ea 	or	r10,r10,r11<<0x1e
80010460:	a3 8b       	lsr	r11,0x2
80010462:	c1 1b       	rjmp	80010284 <__avr32_f64_div+0x20>
80010464:	a3 79       	lsl	r9,0x3
80010466:	f3 e8 13 d9 	or	r9,r9,r8>>0x1d
8001046a:	a3 78       	lsl	r8,0x3
8001046c:	f3 e8 10 04 	or	r4,r9,r8
80010470:	c6 f0       	breq	8001054e <__avr32_f64_div_res_subnormal+0xa0>
80010472:	f2 04 12 00 	clz	r4,r9
80010476:	c1 70       	breq	800104a4 <__avr32_f64_div_round_subnormal+0xe0>
80010478:	c0 c3       	brcs	80010490 <__avr32_f64_div_round_subnormal+0xcc>
8001047a:	e8 05 11 20 	rsub	r5,r4,32
8001047e:	f2 04 09 49 	lsl	r9,r9,r4
80010482:	f0 05 0a 45 	lsr	r5,r8,r5
80010486:	0a 49       	or	r9,r5
80010488:	f0 04 09 48 	lsl	r8,r8,r4
8001048c:	08 16       	sub	r6,r4
8001048e:	c0 b8       	rjmp	800104a4 <__avr32_f64_div_round_subnormal+0xe0>
80010490:	f0 04 12 00 	clz	r4,r8
80010494:	f9 b4 03 00 	movlo	r4,0
80010498:	f7 b4 02 e0 	subhs	r4,-32
8001049c:	f0 04 09 49 	lsl	r9,r8,r4
800104a0:	30 08       	mov	r8,0
800104a2:	08 16       	sub	r6,r4
800104a4:	a3 88       	lsr	r8,0x2
800104a6:	f1 e9 11 e8 	or	r8,r8,r9<<0x1e
800104aa:	a3 89       	lsr	r9,0x2
800104ac:	cf ca       	rjmp	800102a4 <__avr32_f64_div+0x40>

800104ae <__avr32_f64_div_res_subnormal>:
800104ae:	5c 37       	neg	r7
800104b0:	2f f7       	sub	r7,-1
800104b2:	f1 b7 04 c0 	satu	r7,0x6
800104b6:	e0 47 00 20 	cp.w	r7,32
800104ba:	c1 54       	brge	800104e4 <__avr32_f64_div_res_subnormal+0x36>
800104bc:	ee 06 11 20 	rsub	r6,r7,32
800104c0:	e4 07 0a 42 	lsr	r2,r2,r7
800104c4:	e6 06 09 4c 	lsl	r12,r3,r6
800104c8:	18 42       	or	r2,r12
800104ca:	e6 07 0a 43 	lsr	r3,r3,r7
800104ce:	f4 06 09 41 	lsl	r1,r10,r6
800104d2:	f4 07 0a 4a 	lsr	r10,r10,r7
800104d6:	f6 06 09 4c 	lsl	r12,r11,r6
800104da:	18 4a       	or	r10,r12
800104dc:	f6 07 0a 4b 	lsr	r11,r11,r7
800104e0:	30 00       	mov	r0,0
800104e2:	c1 58       	rjmp	8001050c <__avr32_f64_div_res_subnormal+0x5e>
800104e4:	ee 06 11 20 	rsub	r6,r7,32
800104e8:	f9 b0 00 00 	moveq	r0,0
800104ec:	f9 bc 00 00 	moveq	r12,0
800104f0:	c0 50       	breq	800104fa <__avr32_f64_div_res_subnormal+0x4c>
800104f2:	f4 06 09 40 	lsl	r0,r10,r6
800104f6:	f6 06 09 4c 	lsl	r12,r11,r6
800104fa:	e6 07 0a 42 	lsr	r2,r3,r7
800104fe:	30 03       	mov	r3,0
80010500:	f4 07 0a 41 	lsr	r1,r10,r7
80010504:	18 41       	or	r1,r12
80010506:	f6 07 0a 4a 	lsr	r10,r11,r7
8001050a:	30 0b       	mov	r11,0
8001050c:	e0 12 ff 00 	andl	r2,0xff00
80010510:	e8 12 00 80 	orl	r2,0x80
80010514:	e6 08 06 46 	mulu.d	r6,r3,r8
80010518:	e4 09 07 46 	macu.d	r6,r2,r9
8001051c:	e4 08 06 44 	mulu.d	r4,r2,r8
80010520:	e6 09 06 48 	mulu.d	r8,r3,r9
80010524:	0c 05       	add	r5,r6
80010526:	f0 07 00 48 	adc	r8,r8,r7
8001052a:	5c 09       	acr	r9
8001052c:	30 07       	mov	r7,0
8001052e:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
80010532:	00 34       	cp.w	r4,r0
80010534:	e2 05 13 00 	cpc	r5,r1
80010538:	c4 6b       	rjmp	800103c4 <__avr32_f64_div_round_subnormal>
8001053a:	1c 9b       	mov	r11,lr
8001053c:	e6 1b 80 00 	andh	r11,0x8000,COH
80010540:	30 0a       	mov	r10,0
80010542:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
80010546:	3f fb       	mov	r11,-1
80010548:	30 0a       	mov	r10,0
8001054a:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8001054e:	f5 eb 10 04 	or	r4,r10,r11
80010552:	c0 90       	breq	80010564 <__avr32_f64_div_op1_zero>
80010554:	1c 9b       	mov	r11,lr
80010556:	e6 1b 80 00 	andh	r11,0x8000,COH
8001055a:	ea 1b 7f f0 	orh	r11,0x7ff0
8001055e:	30 0a       	mov	r10,0
80010560:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc

80010564 <__avr32_f64_div_op1_zero>:
80010564:	f1 e9 10 15 	or	r5,r8,r9<<0x1
80010568:	ce f0       	breq	80010546 <__avr32_f64_div_res_subnormal+0x98>
8001056a:	e9 d9 c2 8b 	bfextu	r4,r9,0x14,0xb
8001056e:	e0 44 07 ff 	cp.w	r4,2047
80010572:	ce 41       	brne	8001053a <__avr32_f64_div_res_subnormal+0x8c>
80010574:	f1 e9 10 c5 	or	r5,r8,r9<<0xc
80010578:	ce 10       	breq	8001053a <__avr32_f64_div_res_subnormal+0x8c>
8001057a:	ce 6b       	rjmp	80010546 <__avr32_f64_div_res_subnormal+0x98>

8001057c <__avr32_udiv64>:
8001057c:	d4 31       	pushm	r0-r7,lr
8001057e:	1a 97       	mov	r7,sp
80010580:	20 3d       	sub	sp,12
80010582:	10 9c       	mov	r12,r8
80010584:	12 9e       	mov	lr,r9
80010586:	14 93       	mov	r3,r10
80010588:	58 09       	cp.w	r9,0
8001058a:	e0 81 00 bd 	brne	80010704 <__avr32_udiv64+0x188>
8001058e:	16 38       	cp.w	r8,r11
80010590:	e0 88 00 40 	brls	80010610 <__avr32_udiv64+0x94>
80010594:	f0 08 12 00 	clz	r8,r8
80010598:	c0 d0       	breq	800105b2 <__avr32_udiv64+0x36>
8001059a:	f6 08 09 4b 	lsl	r11,r11,r8
8001059e:	f0 09 11 20 	rsub	r9,r8,32
800105a2:	f8 08 09 4c 	lsl	r12,r12,r8
800105a6:	f4 09 0a 49 	lsr	r9,r10,r9
800105aa:	f4 08 09 43 	lsl	r3,r10,r8
800105ae:	f3 eb 10 0b 	or	r11,r9,r11
800105b2:	f8 0e 16 10 	lsr	lr,r12,0x10
800105b6:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
800105ba:	f6 0e 0d 00 	divu	r0,r11,lr
800105be:	e6 0b 16 10 	lsr	r11,r3,0x10
800105c2:	00 99       	mov	r9,r0
800105c4:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
800105c8:	e0 0a 02 48 	mul	r8,r0,r10
800105cc:	10 3b       	cp.w	r11,r8
800105ce:	c0 a2       	brcc	800105e2 <__avr32_udiv64+0x66>
800105d0:	20 19       	sub	r9,1
800105d2:	18 0b       	add	r11,r12
800105d4:	18 3b       	cp.w	r11,r12
800105d6:	c0 63       	brcs	800105e2 <__avr32_udiv64+0x66>
800105d8:	10 3b       	cp.w	r11,r8
800105da:	f7 b9 03 01 	sublo	r9,1
800105de:	f7 dc e3 0b 	addcs	r11,r11,r12
800105e2:	f6 08 01 01 	sub	r1,r11,r8
800105e6:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
800105ea:	e2 0e 0d 00 	divu	r0,r1,lr
800105ee:	e7 e1 11 03 	or	r3,r3,r1<<0x10
800105f2:	00 98       	mov	r8,r0
800105f4:	e0 0a 02 4a 	mul	r10,r0,r10
800105f8:	14 33       	cp.w	r3,r10
800105fa:	c0 82       	brcc	8001060a <__avr32_udiv64+0x8e>
800105fc:	20 18       	sub	r8,1
800105fe:	18 03       	add	r3,r12
80010600:	18 33       	cp.w	r3,r12
80010602:	c0 43       	brcs	8001060a <__avr32_udiv64+0x8e>
80010604:	14 33       	cp.w	r3,r10
80010606:	f7 b8 03 01 	sublo	r8,1
8001060a:	f1 e9 11 08 	or	r8,r8,r9<<0x10
8001060e:	cd f8       	rjmp	800107cc <__avr32_udiv64+0x250>
80010610:	58 08       	cp.w	r8,0
80010612:	c0 51       	brne	8001061c <__avr32_udiv64+0xa0>
80010614:	30 19       	mov	r9,1
80010616:	f2 08 0d 08 	divu	r8,r9,r8
8001061a:	10 9c       	mov	r12,r8
8001061c:	f8 06 12 00 	clz	r6,r12
80010620:	c0 41       	brne	80010628 <__avr32_udiv64+0xac>
80010622:	18 1b       	sub	r11,r12
80010624:	30 19       	mov	r9,1
80010626:	c4 08       	rjmp	800106a6 <__avr32_udiv64+0x12a>
80010628:	ec 01 11 20 	rsub	r1,r6,32
8001062c:	f4 01 0a 49 	lsr	r9,r10,r1
80010630:	f8 06 09 4c 	lsl	r12,r12,r6
80010634:	f6 06 09 48 	lsl	r8,r11,r6
80010638:	f6 01 0a 41 	lsr	r1,r11,r1
8001063c:	f3 e8 10 08 	or	r8,r9,r8
80010640:	f8 03 16 10 	lsr	r3,r12,0x10
80010644:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
80010648:	e2 03 0d 00 	divu	r0,r1,r3
8001064c:	f0 0b 16 10 	lsr	r11,r8,0x10
80010650:	00 9e       	mov	lr,r0
80010652:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
80010656:	e0 05 02 49 	mul	r9,r0,r5
8001065a:	12 3b       	cp.w	r11,r9
8001065c:	c0 a2       	brcc	80010670 <__avr32_udiv64+0xf4>
8001065e:	20 1e       	sub	lr,1
80010660:	18 0b       	add	r11,r12
80010662:	18 3b       	cp.w	r11,r12
80010664:	c0 63       	brcs	80010670 <__avr32_udiv64+0xf4>
80010666:	12 3b       	cp.w	r11,r9
80010668:	f7 be 03 01 	sublo	lr,1
8001066c:	f7 dc e3 0b 	addcs	r11,r11,r12
80010670:	12 1b       	sub	r11,r9
80010672:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
80010676:	f6 03 0d 02 	divu	r2,r11,r3
8001067a:	f1 e3 11 08 	or	r8,r8,r3<<0x10
8001067e:	04 99       	mov	r9,r2
80010680:	e4 05 02 4b 	mul	r11,r2,r5
80010684:	16 38       	cp.w	r8,r11
80010686:	c0 a2       	brcc	8001069a <__avr32_udiv64+0x11e>
80010688:	20 19       	sub	r9,1
8001068a:	18 08       	add	r8,r12
8001068c:	18 38       	cp.w	r8,r12
8001068e:	c0 63       	brcs	8001069a <__avr32_udiv64+0x11e>
80010690:	16 38       	cp.w	r8,r11
80010692:	f7 b9 03 01 	sublo	r9,1
80010696:	f1 dc e3 08 	addcs	r8,r8,r12
8001069a:	f4 06 09 43 	lsl	r3,r10,r6
8001069e:	f0 0b 01 0b 	sub	r11,r8,r11
800106a2:	f3 ee 11 09 	or	r9,r9,lr<<0x10
800106a6:	f8 06 16 10 	lsr	r6,r12,0x10
800106aa:	fd dc c0 10 	bfextu	lr,r12,0x0,0x10
800106ae:	f6 06 0d 00 	divu	r0,r11,r6
800106b2:	e6 0b 16 10 	lsr	r11,r3,0x10
800106b6:	00 9a       	mov	r10,r0
800106b8:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
800106bc:	e0 0e 02 48 	mul	r8,r0,lr
800106c0:	10 3b       	cp.w	r11,r8
800106c2:	c0 a2       	brcc	800106d6 <__avr32_udiv64+0x15a>
800106c4:	20 1a       	sub	r10,1
800106c6:	18 0b       	add	r11,r12
800106c8:	18 3b       	cp.w	r11,r12
800106ca:	c0 63       	brcs	800106d6 <__avr32_udiv64+0x15a>
800106cc:	10 3b       	cp.w	r11,r8
800106ce:	f7 ba 03 01 	sublo	r10,1
800106d2:	f7 dc e3 0b 	addcs	r11,r11,r12
800106d6:	f6 08 01 01 	sub	r1,r11,r8
800106da:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
800106de:	e2 06 0d 00 	divu	r0,r1,r6
800106e2:	e7 e1 11 03 	or	r3,r3,r1<<0x10
800106e6:	00 98       	mov	r8,r0
800106e8:	e0 0e 02 4b 	mul	r11,r0,lr
800106ec:	16 33       	cp.w	r3,r11
800106ee:	c0 82       	brcc	800106fe <__avr32_udiv64+0x182>
800106f0:	20 18       	sub	r8,1
800106f2:	18 03       	add	r3,r12
800106f4:	18 33       	cp.w	r3,r12
800106f6:	c0 43       	brcs	800106fe <__avr32_udiv64+0x182>
800106f8:	16 33       	cp.w	r3,r11
800106fa:	f7 b8 03 01 	sublo	r8,1
800106fe:	f1 ea 11 08 	or	r8,r8,r10<<0x10
80010702:	c6 98       	rjmp	800107d4 <__avr32_udiv64+0x258>
80010704:	16 39       	cp.w	r9,r11
80010706:	e0 8b 00 65 	brhi	800107d0 <__avr32_udiv64+0x254>
8001070a:	f2 09 12 00 	clz	r9,r9
8001070e:	c0 b1       	brne	80010724 <__avr32_udiv64+0x1a8>
80010710:	10 3a       	cp.w	r10,r8
80010712:	5f 2a       	srhs	r10
80010714:	1c 3b       	cp.w	r11,lr
80010716:	5f b8       	srhi	r8
80010718:	10 4a       	or	r10,r8
8001071a:	f2 0a 18 00 	cp.b	r10,r9
8001071e:	c5 90       	breq	800107d0 <__avr32_udiv64+0x254>
80010720:	30 18       	mov	r8,1
80010722:	c5 98       	rjmp	800107d4 <__avr32_udiv64+0x258>
80010724:	f0 09 09 46 	lsl	r6,r8,r9
80010728:	f2 03 11 20 	rsub	r3,r9,32
8001072c:	fc 09 09 4e 	lsl	lr,lr,r9
80010730:	f0 03 0a 48 	lsr	r8,r8,r3
80010734:	f6 09 09 4c 	lsl	r12,r11,r9
80010738:	f4 03 0a 42 	lsr	r2,r10,r3
8001073c:	ef 46 ff f4 	st.w	r7[-12],r6
80010740:	f6 03 0a 43 	lsr	r3,r11,r3
80010744:	18 42       	or	r2,r12
80010746:	f1 ee 10 0c 	or	r12,r8,lr
8001074a:	f8 01 16 10 	lsr	r1,r12,0x10
8001074e:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
80010752:	e6 01 0d 04 	divu	r4,r3,r1
80010756:	e4 03 16 10 	lsr	r3,r2,0x10
8001075a:	08 9e       	mov	lr,r4
8001075c:	e7 e5 11 03 	or	r3,r3,r5<<0x10
80010760:	e8 06 02 48 	mul	r8,r4,r6
80010764:	10 33       	cp.w	r3,r8
80010766:	c0 a2       	brcc	8001077a <__avr32_udiv64+0x1fe>
80010768:	20 1e       	sub	lr,1
8001076a:	18 03       	add	r3,r12
8001076c:	18 33       	cp.w	r3,r12
8001076e:	c0 63       	brcs	8001077a <__avr32_udiv64+0x1fe>
80010770:	10 33       	cp.w	r3,r8
80010772:	f7 be 03 01 	sublo	lr,1
80010776:	e7 dc e3 03 	addcs	r3,r3,r12
8001077a:	10 13       	sub	r3,r8
8001077c:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
80010780:	e6 01 0d 00 	divu	r0,r3,r1
80010784:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
80010788:	00 98       	mov	r8,r0
8001078a:	e0 06 02 46 	mul	r6,r0,r6
8001078e:	0c 3b       	cp.w	r11,r6
80010790:	c0 a2       	brcc	800107a4 <__avr32_udiv64+0x228>
80010792:	20 18       	sub	r8,1
80010794:	18 0b       	add	r11,r12
80010796:	18 3b       	cp.w	r11,r12
80010798:	c0 63       	brcs	800107a4 <__avr32_udiv64+0x228>
8001079a:	0c 3b       	cp.w	r11,r6
8001079c:	f7 dc e3 0b 	addcs	r11,r11,r12
800107a0:	f7 b8 03 01 	sublo	r8,1
800107a4:	f1 ee 11 08 	or	r8,r8,lr<<0x10
800107a8:	ee f4 ff f4 	ld.w	r4,r7[-12]
800107ac:	0c 1b       	sub	r11,r6
800107ae:	f0 04 06 42 	mulu.d	r2,r8,r4
800107b2:	06 95       	mov	r5,r3
800107b4:	16 35       	cp.w	r5,r11
800107b6:	e0 8b 00 0a 	brhi	800107ca <__avr32_udiv64+0x24e>
800107ba:	5f 0b       	sreq	r11
800107bc:	f4 09 09 49 	lsl	r9,r10,r9
800107c0:	12 32       	cp.w	r2,r9
800107c2:	5f b9       	srhi	r9
800107c4:	f7 e9 00 09 	and	r9,r11,r9
800107c8:	c0 60       	breq	800107d4 <__avr32_udiv64+0x258>
800107ca:	20 18       	sub	r8,1
800107cc:	30 09       	mov	r9,0
800107ce:	c0 38       	rjmp	800107d4 <__avr32_udiv64+0x258>
800107d0:	30 09       	mov	r9,0
800107d2:	12 98       	mov	r8,r9
800107d4:	10 9a       	mov	r10,r8
800107d6:	12 93       	mov	r3,r9
800107d8:	10 92       	mov	r2,r8
800107da:	12 9b       	mov	r11,r9
800107dc:	2f dd       	sub	sp,-12
800107de:	d8 32       	popm	r0-r7,pc

800107e0 <__avr32_umod64>:
800107e0:	d4 31       	pushm	r0-r7,lr
800107e2:	1a 97       	mov	r7,sp
800107e4:	20 3d       	sub	sp,12
800107e6:	10 9c       	mov	r12,r8
800107e8:	12 95       	mov	r5,r9
800107ea:	14 9e       	mov	lr,r10
800107ec:	16 91       	mov	r1,r11
800107ee:	16 96       	mov	r6,r11
800107f0:	58 09       	cp.w	r9,0
800107f2:	e0 81 00 81 	brne	800108f4 <__avr32_umod64+0x114>
800107f6:	16 38       	cp.w	r8,r11
800107f8:	e0 88 00 12 	brls	8001081c <__avr32_umod64+0x3c>
800107fc:	f0 08 12 00 	clz	r8,r8
80010800:	c4 e0       	breq	8001089c <__avr32_umod64+0xbc>
80010802:	f6 08 09 46 	lsl	r6,r11,r8
80010806:	f8 08 09 4c 	lsl	r12,r12,r8
8001080a:	f0 0b 11 20 	rsub	r11,r8,32
8001080e:	f4 08 09 4e 	lsl	lr,r10,r8
80010812:	f4 0b 0a 4b 	lsr	r11,r10,r11
80010816:	f7 e6 10 06 	or	r6,r11,r6
8001081a:	c4 18       	rjmp	8001089c <__avr32_umod64+0xbc>
8001081c:	58 08       	cp.w	r8,0
8001081e:	c0 51       	brne	80010828 <__avr32_umod64+0x48>
80010820:	30 19       	mov	r9,1
80010822:	f2 08 0d 08 	divu	r8,r9,r8
80010826:	10 9c       	mov	r12,r8
80010828:	f8 08 12 00 	clz	r8,r12
8001082c:	c0 31       	brne	80010832 <__avr32_umod64+0x52>
8001082e:	18 16       	sub	r6,r12
80010830:	c3 68       	rjmp	8001089c <__avr32_umod64+0xbc>
80010832:	f0 03 11 20 	rsub	r3,r8,32
80010836:	f4 03 0a 4b 	lsr	r11,r10,r3
8001083a:	f8 08 09 4c 	lsl	r12,r12,r8
8001083e:	ec 08 09 49 	lsl	r9,r6,r8
80010842:	ec 03 0a 43 	lsr	r3,r6,r3
80010846:	f7 e9 10 09 	or	r9,r11,r9
8001084a:	f8 05 16 10 	lsr	r5,r12,0x10
8001084e:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
80010852:	e6 05 0d 02 	divu	r2,r3,r5
80010856:	f2 0e 16 10 	lsr	lr,r9,0x10
8001085a:	ec 02 02 4b 	mul	r11,r6,r2
8001085e:	fd e3 11 0e 	or	lr,lr,r3<<0x10
80010862:	16 3e       	cp.w	lr,r11
80010864:	c0 72       	brcc	80010872 <__avr32_umod64+0x92>
80010866:	18 0e       	add	lr,r12
80010868:	18 3e       	cp.w	lr,r12
8001086a:	c0 43       	brcs	80010872 <__avr32_umod64+0x92>
8001086c:	16 3e       	cp.w	lr,r11
8001086e:	fd dc e3 0e 	addcs	lr,lr,r12
80010872:	fc 0b 01 03 	sub	r3,lr,r11
80010876:	f3 d9 c0 10 	bfextu	r9,r9,0x0,0x10
8001087a:	e6 05 0d 02 	divu	r2,r3,r5
8001087e:	f3 e3 11 09 	or	r9,r9,r3<<0x10
80010882:	a5 36       	mul	r6,r2
80010884:	0c 39       	cp.w	r9,r6
80010886:	c0 72       	brcc	80010894 <__avr32_umod64+0xb4>
80010888:	18 09       	add	r9,r12
8001088a:	18 39       	cp.w	r9,r12
8001088c:	c0 43       	brcs	80010894 <__avr32_umod64+0xb4>
8001088e:	0c 39       	cp.w	r9,r6
80010890:	f3 dc e3 09 	addcs	r9,r9,r12
80010894:	f2 06 01 06 	sub	r6,r9,r6
80010898:	f4 08 09 4e 	lsl	lr,r10,r8
8001089c:	f8 0a 16 10 	lsr	r10,r12,0x10
800108a0:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
800108a4:	ec 0a 0d 02 	divu	r2,r6,r10
800108a8:	fc 09 16 10 	lsr	r9,lr,0x10
800108ac:	ea 02 02 4b 	mul	r11,r5,r2
800108b0:	f3 e3 11 09 	or	r9,r9,r3<<0x10
800108b4:	16 39       	cp.w	r9,r11
800108b6:	c0 72       	brcc	800108c4 <__avr32_umod64+0xe4>
800108b8:	18 09       	add	r9,r12
800108ba:	18 39       	cp.w	r9,r12
800108bc:	c0 43       	brcs	800108c4 <__avr32_umod64+0xe4>
800108be:	16 39       	cp.w	r9,r11
800108c0:	f3 dc e3 09 	addcs	r9,r9,r12
800108c4:	f2 0b 01 0b 	sub	r11,r9,r11
800108c8:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
800108cc:	f6 0a 0d 0a 	divu	r10,r11,r10
800108d0:	fd eb 11 0e 	or	lr,lr,r11<<0x10
800108d4:	ea 0a 02 4a 	mul	r10,r5,r10
800108d8:	14 3e       	cp.w	lr,r10
800108da:	c0 72       	brcc	800108e8 <__avr32_umod64+0x108>
800108dc:	18 0e       	add	lr,r12
800108de:	18 3e       	cp.w	lr,r12
800108e0:	c0 43       	brcs	800108e8 <__avr32_umod64+0x108>
800108e2:	14 3e       	cp.w	lr,r10
800108e4:	fd dc e3 0e 	addcs	lr,lr,r12
800108e8:	fc 0a 01 0a 	sub	r10,lr,r10
800108ec:	30 0b       	mov	r11,0
800108ee:	f4 08 0a 4a 	lsr	r10,r10,r8
800108f2:	c7 b8       	rjmp	800109e8 <__avr32_umod64+0x208>
800108f4:	16 39       	cp.w	r9,r11
800108f6:	e0 8b 00 79 	brhi	800109e8 <__avr32_umod64+0x208>
800108fa:	f2 09 12 00 	clz	r9,r9
800108fe:	c1 21       	brne	80010922 <__avr32_umod64+0x142>
80010900:	10 3a       	cp.w	r10,r8
80010902:	5f 2b       	srhs	r11
80010904:	0a 31       	cp.w	r1,r5
80010906:	5f ba       	srhi	r10
80010908:	f7 ea 10 0a 	or	r10,r11,r10
8001090c:	f2 0a 18 00 	cp.b	r10,r9
80010910:	c0 60       	breq	8001091c <__avr32_umod64+0x13c>
80010912:	fc 08 01 0c 	sub	r12,lr,r8
80010916:	e2 05 01 46 	sbc	r6,r1,r5
8001091a:	18 9e       	mov	lr,r12
8001091c:	0c 9b       	mov	r11,r6
8001091e:	1c 9a       	mov	r10,lr
80010920:	c6 48       	rjmp	800109e8 <__avr32_umod64+0x208>
80010922:	ea 09 09 4c 	lsl	r12,r5,r9
80010926:	f2 06 11 20 	rsub	r6,r9,32
8001092a:	f6 09 09 4b 	lsl	r11,r11,r9
8001092e:	f0 09 09 42 	lsl	r2,r8,r9
80010932:	ef 46 ff f4 	st.w	r7[-12],r6
80010936:	f0 06 0a 48 	lsr	r8,r8,r6
8001093a:	18 48       	or	r8,r12
8001093c:	e2 06 0a 4c 	lsr	r12,r1,r6
80010940:	f4 09 09 43 	lsl	r3,r10,r9
80010944:	fd d8 c0 10 	bfextu	lr,r8,0x0,0x10
80010948:	f4 06 0a 4a 	lsr	r10,r10,r6
8001094c:	16 4a       	or	r10,r11
8001094e:	f0 0b 16 10 	lsr	r11,r8,0x10
80010952:	f8 0b 0d 04 	divu	r4,r12,r11
80010956:	f4 0c 16 10 	lsr	r12,r10,0x10
8001095a:	08 91       	mov	r1,r4
8001095c:	f9 e5 11 0c 	or	r12,r12,r5<<0x10
80010960:	e8 0e 02 46 	mul	r6,r4,lr
80010964:	0c 3c       	cp.w	r12,r6
80010966:	c0 a2       	brcc	8001097a <__avr32_umod64+0x19a>
80010968:	20 11       	sub	r1,1
8001096a:	10 0c       	add	r12,r8
8001096c:	10 3c       	cp.w	r12,r8
8001096e:	c0 63       	brcs	8001097a <__avr32_umod64+0x19a>
80010970:	0c 3c       	cp.w	r12,r6
80010972:	f7 b1 03 01 	sublo	r1,1
80010976:	f9 d8 e3 0c 	addcs	r12,r12,r8
8001097a:	0c 1c       	sub	r12,r6
8001097c:	f5 da c0 10 	bfextu	r10,r10,0x0,0x10
80010980:	f8 0b 0d 04 	divu	r4,r12,r11
80010984:	f5 e5 11 0b 	or	r11,r10,r5<<0x10
80010988:	08 96       	mov	r6,r4
8001098a:	e8 0e 02 4e 	mul	lr,r4,lr
8001098e:	1c 3b       	cp.w	r11,lr
80010990:	c0 a2       	brcc	800109a4 <__avr32_umod64+0x1c4>
80010992:	20 16       	sub	r6,1
80010994:	10 0b       	add	r11,r8
80010996:	10 3b       	cp.w	r11,r8
80010998:	c0 63       	brcs	800109a4 <__avr32_umod64+0x1c4>
8001099a:	1c 3b       	cp.w	r11,lr
8001099c:	f7 b6 03 01 	sublo	r6,1
800109a0:	f7 d8 e3 0b 	addcs	r11,r11,r8
800109a4:	ed e1 11 01 	or	r1,r6,r1<<0x10
800109a8:	1c 1b       	sub	r11,lr
800109aa:	e2 02 06 40 	mulu.d	r0,r1,r2
800109ae:	00 9e       	mov	lr,r0
800109b0:	02 9c       	mov	r12,r1
800109b2:	16 3c       	cp.w	r12,r11
800109b4:	e0 8b 00 08 	brhi	800109c4 <__avr32_umod64+0x1e4>
800109b8:	5f 06       	sreq	r6
800109ba:	06 30       	cp.w	r0,r3
800109bc:	5f ba       	srhi	r10
800109be:	ed ea 00 0a 	and	r10,r6,r10
800109c2:	c0 60       	breq	800109ce <__avr32_umod64+0x1ee>
800109c4:	fc 02 01 04 	sub	r4,lr,r2
800109c8:	f8 08 01 4c 	sbc	r12,r12,r8
800109cc:	08 9e       	mov	lr,r4
800109ce:	e6 0e 01 0a 	sub	r10,r3,lr
800109d2:	f6 0c 01 4c 	sbc	r12,r11,r12
800109d6:	ee f1 ff f4 	ld.w	r1,r7[-12]
800109da:	f8 09 0a 4b 	lsr	r11,r12,r9
800109de:	f4 09 0a 4a 	lsr	r10,r10,r9
800109e2:	f8 01 09 4c 	lsl	r12,r12,r1
800109e6:	18 4a       	or	r10,r12
800109e8:	2f dd       	sub	sp,-12
800109ea:	d8 32       	popm	r0-r7,pc

Disassembly of section .exception:

80010a00 <_evba>:
_evba:

        .org  0x000
        // Unrecoverable Exception.
_handle_Unrecoverable_Exception:
        rjmp $
80010a00:	c0 08       	rjmp	80010a00 <_evba>
	...

80010a04 <_handle_TLB_Multiple_Hit>:

        .org  0x004
        // TLB Multiple Hit: UNUSED IN AVR32UC.
_handle_TLB_Multiple_Hit:
        rjmp $
80010a04:	c0 08       	rjmp	80010a04 <_handle_TLB_Multiple_Hit>
	...

80010a08 <_handle_Bus_Error_Data_Fetch>:

        .org  0x008
        // Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
        rjmp $
80010a08:	c0 08       	rjmp	80010a08 <_handle_Bus_Error_Data_Fetch>
	...

80010a0c <_handle_Bus_Error_Instruction_Fetch>:

        .org  0x00C
         // Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
        rjmp $
80010a0c:	c0 08       	rjmp	80010a0c <_handle_Bus_Error_Instruction_Fetch>
	...

80010a10 <_handle_NMI>:

        .org  0x010
        // NMI.
_handle_NMI:
        rjmp $
80010a10:	c0 08       	rjmp	80010a10 <_handle_NMI>
	...

80010a14 <_handle_Instruction_Address>:

        .org  0x014
        // Instruction Address.
_handle_Instruction_Address:
        rjmp $
80010a14:	c0 08       	rjmp	80010a14 <_handle_Instruction_Address>
	...

80010a18 <_handle_ITLB_Protection>:

        .org  0x018
        // ITLB Protection.
_handle_ITLB_Protection:
        rjmp $
80010a18:	c0 08       	rjmp	80010a18 <_handle_ITLB_Protection>
	...

80010a1c <_handle_Breakpoint>:

        .org  0x01C
        // Breakpoint.
_handle_Breakpoint:
        rjmp $
80010a1c:	c0 08       	rjmp	80010a1c <_handle_Breakpoint>
	...

80010a20 <_handle_Illegal_Opcode>:

        .org  0x020
        // Illegal Opcode.
_handle_Illegal_Opcode:
        rjmp $
80010a20:	c0 08       	rjmp	80010a20 <_handle_Illegal_Opcode>
	...

80010a24 <_handle_Unimplemented_Instruction>:

        .org  0x024
        // Unimplemented Instruction.
_handle_Unimplemented_Instruction:
        rjmp $
80010a24:	c0 08       	rjmp	80010a24 <_handle_Unimplemented_Instruction>
	...

80010a28 <_handle_Privilege_Violation>:

        .org  0x028
        // Privilege Violation.
_handle_Privilege_Violation:
        rjmp $
80010a28:	c0 08       	rjmp	80010a28 <_handle_Privilege_Violation>
	...

80010a2c <_handle_Floating_Point>:

        .org  0x02C
        // Floating-Point: UNUSED IN AVR32UC.
_handle_Floating_Point:
        rjmp $
80010a2c:	c0 08       	rjmp	80010a2c <_handle_Floating_Point>
	...

80010a30 <_handle_Coprocessor_Absent>:

        .org  0x030
        // Coprocessor Absent: UNUSED IN AVR32UC.
_handle_Coprocessor_Absent:
        rjmp $
80010a30:	c0 08       	rjmp	80010a30 <_handle_Coprocessor_Absent>
	...

80010a34 <_handle_Data_Address_Read>:

        .org  0x034
        // Data Address (Read).
_handle_Data_Address_Read:
        rjmp $
80010a34:	c0 08       	rjmp	80010a34 <_handle_Data_Address_Read>
	...

80010a38 <_handle_Data_Address_Write>:

        .org  0x038
        // Data Address (Write).
_handle_Data_Address_Write:
        rjmp $
80010a38:	c0 08       	rjmp	80010a38 <_handle_Data_Address_Write>
	...

80010a3c <_handle_DTLB_Protection_Read>:

        .org  0x03C
        // DTLB Protection (Read).
_handle_DTLB_Protection_Read:
        rjmp $
80010a3c:	c0 08       	rjmp	80010a3c <_handle_DTLB_Protection_Read>
	...

80010a40 <_handle_DTLB_Protection_Write>:

        .org  0x040
        // DTLB Protection (Write).
_handle_DTLB_Protection_Write:
        rjmp $
80010a40:	c0 08       	rjmp	80010a40 <_handle_DTLB_Protection_Write>
	...

80010a44 <_handle_DTLB_Modified>:

        .org  0x044
        // DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
        rjmp $
80010a44:	c0 08       	rjmp	80010a44 <_handle_DTLB_Modified>
	...

80010a50 <_handle_ITLB_Miss>:

        .org  0x050
        // ITLB Miss: UNUSED IN AVR32UC.
_handle_ITLB_Miss:
        rjmp $
80010a50:	c0 08       	rjmp	80010a50 <_handle_ITLB_Miss>
	...

80010a60 <_handle_DTLB_Miss_Read>:

        .org  0x060
        // DTLB Miss (Read): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Read:
        rjmp $
80010a60:	c0 08       	rjmp	80010a60 <_handle_DTLB_Miss_Read>
	...

80010a70 <_handle_DTLB_Miss_Write>:

        .org  0x070
        // DTLB Miss (Write): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Write:
        rjmp $
80010a70:	c0 08       	rjmp	80010a70 <_handle_DTLB_Miss_Write>
	...

80010b00 <_handle_Supervisor_Call>:

        .org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
80010b00:	49 3f       	lddpc	pc,80010b4c <ipr_val+0x10>
80010b02:	d7 03       	nop

80010b04 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
80010b04:	30 0c       	mov	r12,0
80010b06:	fe b0 b6 41 	rcall	80007788 <_get_interrupt_handler>
80010b0a:	58 0c       	cp.w	r12,0
80010b0c:	f8 0f 17 10 	movne	pc,r12
80010b10:	d6 03       	rete

80010b12 <_int1>:
80010b12:	30 1c       	mov	r12,1
80010b14:	fe b0 b6 3a 	rcall	80007788 <_get_interrupt_handler>
80010b18:	58 0c       	cp.w	r12,0
80010b1a:	f8 0f 17 10 	movne	pc,r12
80010b1e:	d6 03       	rete

80010b20 <_int2>:
80010b20:	30 2c       	mov	r12,2
80010b22:	fe b0 b6 33 	rcall	80007788 <_get_interrupt_handler>
80010b26:	58 0c       	cp.w	r12,0
80010b28:	f8 0f 17 10 	movne	pc,r12
80010b2c:	d6 03       	rete

80010b2e <_int3>:
80010b2e:	30 3c       	mov	r12,3
80010b30:	fe b0 b6 2c 	rcall	80007788 <_get_interrupt_handler>
80010b34:	58 0c       	cp.w	r12,0
80010b36:	f8 0f 17 10 	movne	pc,r12
80010b3a:	d6 03       	rete

80010b3c <ipr_val>:
80010b3c:	00 00 01 04 40 00 01 12 80 00 01 20 c0 00 01 2e     ....@...... ....
80010b4c:	80 00 89 78 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ...x............
80010b5c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
80010b6c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
80010b7c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
80010b8c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
80010b9c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
80010bac:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
80010bbc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
80010bcc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
80010bdc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
80010bec:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
80010bfc:	d7 03 d7 03                                         ....
