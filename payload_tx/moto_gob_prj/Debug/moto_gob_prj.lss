
moto_gob_prj.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        0000200c  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  8000200c  8000200c  0000240c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         0000da24  8000200c  8000200c  0000240c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  8000fc00  8000fc00  00010000  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       00009670  8000fe00  8000fe00  00010200  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .dalign       00000004  00000004  00000004  00000000  2**0
                  ALLOC
  6 .data         00000a34  00000008  80019470  00019c08  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .balign       00000004  00000a3c  80019ea4  0001a63c  2**0
                  ALLOC
  8 .bss          00003bf0  00000a40  00000a40  00000000  2**2
                  ALLOC
  9 .heap         000129d0  00004630  00004630  00000000  2**0
                  ALLOC
 10 .comment      00000030  00000000  00000000  0001a63c  2**0
                  CONTENTS, READONLY
 11 .debug_aranges 00001620  00000000  00000000  0001a670  2**3
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_pubnames 00002ade  00000000  00000000  0001bc90  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_info   0002ea31  00000000  00000000  0001e76e  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_abbrev 00007853  00000000  00000000  0004d19f  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_line   0000df89  00000000  00000000  000549f2  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_frame  00003cdc  00000000  00000000  0006297c  2**2
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_str    00008011  00000000  00000000  00066658  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_loc    000120a0  00000000  00000000  0006e669  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .stack        00001000  00017000  00017000  00000000  2**0
                  ALLOC
 20 .debug_ranges 00001718  00000000  00000000  00080710  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_start>:

  .global _start
  .type _start, @function
_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80000000:	48 1f       	lddpc	pc,80000004 <_start+0x4>
80000002:	d7 03       	nop
80000004:	80 00       	ld.sh	r0,r0[0x0]
80000006:	9f ac       	st.w	pc[0x28],r12

80000008 <_trampoline>:

  .global _trampoline
  .type _trampoline, @function
_trampoline:
  // Jump to program start.
  rjmp    program_start
80000008:	e0 8f 10 00 	bral	80002008 <program_start>
	...

80002008 <program_start>:

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002008:	fe cf 80 5c 	sub	pc,pc,-32676

Disassembly of section .text:

8000200c <DeviceManagement_brdcst_func>:
8000200c:	19 a9       	ld.ub	r9,r12[0x2]
8000200e:	30 18       	mov	r8,1
		U8 temp = 0;
		temp  = xcmp->u8[1] << 8;
		temp |= xcmp->u8[2];
		//if (temp == theXNL_Ctrlr.XNL_DeviceLogicalAddress)
		{
			if (xcmp->u8[0] == 0x01)
80002010:	f0 09 18 00 	cp.b	r9,r8
80002014:	c0 61       	brne	80002020 <DeviceManagement_brdcst_func+0x14>
			{
				bunchofrandomstatusflags |= 0x00000002;
80002016:	48 68       	lddpc	r8,8000202c <DeviceManagement_brdcst_func+0x20>
80002018:	70 09       	ld.w	r9,r8[0x0]
8000201a:	a1 b9       	sbr	r9,0x1
8000201c:	91 09       	st.w	r8[0x0],r9
8000201e:	5e fc       	retal	r12
			}
			else
			{
				bunchofrandomstatusflags &= 0xFFFFFFFD;
80002020:	48 38       	lddpc	r8,8000202c <DeviceManagement_brdcst_func+0x20>
80002022:	70 09       	ld.w	r9,r8[0x0]
80002024:	a1 d9       	cbr	r9,0x1
80002026:	91 09       	st.w	r8[0x0],r9
80002028:	5e fc       	retal	r12
8000202a:	00 00       	add	r0,r0
8000202c:	00 00       	add	r0,r0
8000202e:	12 cc       	st.b	r9++,r12

80002030 <mic_brdcst_func>:
	//log("\n\r Signal_type: %x \n\r " ,  ptr->Signaling_Type);
	//log("\n\r Mic_state: %x \n\r " ,  ptr->Mic_State);
	//log("\n\r Gain_offset: %x \n\r " ,  ptr->Gain_Offset);
			
	
}
80002030:	5e fc       	retal	r12

80002032 <TransmitControl_brdcst_func>:
	//log("\n\r  State: %x \n\r ", ptr->State );
	//log("\n\r  State_change_reason: %x \n\r ", ptr->State_change_reason );
	//
	
	
}
80002032:	5e fc       	retal	r12

80002034 <vApplicationIdleHook>:
}

void vApplicationIdleHook( void )
{
	/* This hook function does nothing but increment a counter. */
	ulIdleCycleCount++;
80002034:	48 38       	lddpc	r8,80002040 <vApplicationIdleHook+0xc>
80002036:	70 09       	ld.w	r9,r8[0x0]
80002038:	2f f9       	sub	r9,-1
8000203a:	91 09       	st.w	r8[0x0],r9
	
}
8000203c:	5e fc       	retal	r12
8000203e:	00 00       	add	r0,r0
80002040:	00 00       	add	r0,r0
80002042:	0a 58       	eor	r8,r5

80002044 <app_init>:
														
		
};

void app_init(void)
{	
80002044:	d4 01       	pushm	lr
	payload_init( app_payload_rx_proc , app_payload_tx_proc );	
80002046:	48 cb       	lddpc	r11,80002074 <app_init+0x30>
80002048:	48 cc       	lddpc	r12,80002078 <app_init+0x34>
8000204a:	f0 1f 00 0d 	mcall	8000207c <app_init+0x38>
	xcmp_register_app_list(the_app_list);
8000204e:	48 dc       	lddpc	r12,80002080 <app_init+0x3c>
80002050:	f0 1f 00 0d 	mcall	80002084 <app_init+0x40>
			
	static portBASE_TYPE res = 0;
	 res = xTaskCreate(
80002054:	30 09       	mov	r9,0
80002056:	1a d9       	st.w	--sp,r9
80002058:	1a d9       	st.w	--sp,r9
8000205a:	1a d9       	st.w	--sp,r9
8000205c:	30 18       	mov	r8,1
8000205e:	e0 6a 01 80 	mov	r10,384
80002062:	48 ab       	lddpc	r11,80002088 <app_init+0x44>
80002064:	48 ac       	lddpc	r12,8000208c <app_init+0x48>
80002066:	f0 1f 00 0b 	mcall	80002090 <app_init+0x4c>
8000206a:	48 b8       	lddpc	r8,80002094 <app_init+0x50>
8000206c:	91 0c       	st.w	r8[0x0],r12
8000206e:	2f dd       	sub	sp,-12
	,  NULL
	,  1
	,  NULL );
	
	
}
80002070:	d8 02       	popm	pc
80002072:	00 00       	add	r0,r0
80002074:	80 00       	ld.sh	r0,r0[0x0]
80002076:	28 8c       	sub	r12,-120
80002078:	80 00       	ld.sh	r0,r0[0x0]
8000207a:	28 b8       	sub	r8,-117
8000207c:	80 00       	ld.sh	r0,r0[0x0]
8000207e:	39 78       	mov	r8,-105
80002080:	00 00       	add	r0,r0
80002082:	00 08       	add	r8,r0
80002084:	80 00       	ld.sh	r0,r0[0x0]
80002086:	4d e4       	lddpc	r4,800021fc <ButtonConfig_brdcst_func+0x64>
80002088:	80 00       	ld.sh	r0,r0[0x0]
8000208a:	fe 00       	*unknown*
8000208c:	80 00       	ld.sh	r0,r0[0x0]
8000208e:	27 cc       	sub	r12,124
80002090:	80 00       	ld.sh	r0,r0[0x0]
80002092:	96 e0       	ld.uh	r0,r11[0xc]
80002094:	00 00       	add	r0,r0
80002096:	0a 50       	eor	r0,r5

80002098 <FD_brdcst_func>:
	
	
}

void FD_brdcst_func(xcmp_fragment_t * xcmp)
{
80002098:	d4 01       	pushm	lr
	
	
	log("\n\r Forward Data Broadcast \n\r");
8000209a:	48 3c       	lddpc	r12,800020a4 <FD_brdcst_func+0xc>
8000209c:	f0 1f 00 03 	mcall	800020a8 <FD_brdcst_func+0x10>
	
}
800020a0:	d8 02       	popm	pc
800020a2:	00 00       	add	r0,r0
800020a4:	80 00       	ld.sh	r0,r0[0x0]
800020a6:	fe 08       	*unknown*
800020a8:	80 00       	ld.sh	r0,r0[0x0]
800020aa:	9a a4       	ld.uh	r4,sp[0x4]

800020ac <FD_reply_func>:
	
	
}

void FD_reply_func(xcmp_fragment_t * xcmp)
{
800020ac:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Reply \n\r");
800020ae:	48 3c       	lddpc	r12,800020b8 <FD_reply_func+0xc>
800020b0:	f0 1f 00 03 	mcall	800020bc <FD_reply_func+0x10>
	
	
}
800020b4:	d8 02       	popm	pc
800020b6:	00 00       	add	r0,r0
800020b8:	80 00       	ld.sh	r0,r0[0x0]
800020ba:	fe 28 80 00 	sub	r8,-98304
800020be:	9a a4       	ld.uh	r4,sp[0x4]

800020c0 <FD_request_func>:
}



void FD_request_func(xcmp_fragment_t * xcmp)
{
800020c0:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Request \n\r");
800020c2:	48 3c       	lddpc	r12,800020cc <FD_request_func+0xc>
800020c4:	f0 1f 00 03 	mcall	800020d0 <FD_request_func+0x10>
	
	
}
800020c8:	d8 02       	popm	pc
800020ca:	00 00       	add	r0,r0
800020cc:	80 00       	ld.sh	r0,r0[0x0]
800020ce:	fe 44 80 00 	cp.w	r4,-98304
800020d2:	9a a4       	ld.uh	r4,sp[0x4]

800020d4 <EnOB_brdcst_func>:
	
	
}

void EnOB_brdcst_func(xcmp_fragment_t * xcmp)
{
800020d4:	d4 01       	pushm	lr
	
	
	log("\n\r En_OB Broadcast \n\r");
800020d6:	48 3c       	lddpc	r12,800020e0 <EnOB_brdcst_func+0xc>
800020d8:	f0 1f 00 03 	mcall	800020e4 <EnOB_brdcst_func+0x10>
}
800020dc:	d8 02       	popm	pc
800020de:	00 00       	add	r0,r0
800020e0:	80 00       	ld.sh	r0,r0[0x0]
800020e2:	fe 60 80 00 	mov	r0,-98304
800020e6:	9a a4       	ld.uh	r4,sp[0x4]

800020e8 <EnOB_reply_func>:
}



void EnOB_reply_func(xcmp_fragment_t * xcmp)
{
800020e8:	eb cd 40 80 	pushm	r7,lr
800020ec:	18 97       	mov	r7,r12
		/*point to xcmp payload*/
	//En_OB_Control_reply_t *ptr = (En_OB_Control_reply_t* )xcmp->u8;
	//log("\n\r Xcmp_opcode: %x \n\r", xcmp->xcmp_opcode);
	
	if (xcmp->u8[0]== xcmp_Res_Success)
800020ee:	19 a9       	ld.ub	r9,r12[0x2]
800020f0:	30 08       	mov	r8,0
800020f2:	f0 09 18 00 	cp.b	r9,r8
800020f6:	c1 91       	brne	80002128 <EnOB_reply_func+0x40>
	{
		if (xcmp->u8[1] == EN_OB_Enter)
800020f8:	19 b8       	ld.ub	r8,r12[0x3]
800020fa:	30 19       	mov	r9,1
800020fc:	f2 08 18 00 	cp.b	r8,r9
80002100:	c0 61       	brne	8000210c <EnOB_reply_func+0x24>
		{
		
			log("\n\r En_OB_Enter OK \n\r");
80002102:	49 0c       	lddpc	r12,80002140 <EnOB_reply_func+0x58>
80002104:	f0 1f 00 10 	mcall	80002144 <EnOB_reply_func+0x5c>
80002108:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else if (xcmp->u8[1] == EN_OB_Exit )
8000210c:	58 08       	cp.w	r8,0
8000210e:	c0 61       	brne	8000211a <EnOB_reply_func+0x32>
		{
			log("\n\r En_OB_Exit OK \n\r");
80002110:	48 ec       	lddpc	r12,80002148 <EnOB_reply_func+0x60>
80002112:	f0 1f 00 0d 	mcall	80002144 <EnOB_reply_func+0x5c>
80002116:	e3 cd 80 80 	ldm	sp++,r7,pc
		}
		else
		{
			
			log("\n\r En_OB_Control: %x \n\r", xcmp->u8[1]);
8000211a:	1a d8       	st.w	--sp,r8
8000211c:	48 cc       	lddpc	r12,8000214c <EnOB_reply_func+0x64>
8000211e:	f0 1f 00 0a 	mcall	80002144 <EnOB_reply_func+0x5c>
80002122:	2f fd       	sub	sp,-4
80002124:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r En_OB_Control error \n\r");
80002128:	48 ac       	lddpc	r12,80002150 <EnOB_reply_func+0x68>
8000212a:	f0 1f 00 07 	mcall	80002144 <EnOB_reply_func+0x5c>
		log("\n\r En_OB_result: %x \n\r", xcmp->u8[0]);
8000212e:	0f a8       	ld.ub	r8,r7[0x2]
80002130:	1a d8       	st.w	--sp,r8
80002132:	48 9c       	lddpc	r12,80002154 <EnOB_reply_func+0x6c>
80002134:	f0 1f 00 04 	mcall	80002144 <EnOB_reply_func+0x5c>
80002138:	2f fd       	sub	sp,-4
8000213a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000213e:	00 00       	add	r0,r0
80002140:	80 00       	ld.sh	r0,r0[0x0]
80002142:	fe 78 80 00 	mov	r8,-32768
80002146:	9a a4       	ld.uh	r4,sp[0x4]
80002148:	80 00       	ld.sh	r0,r0[0x0]
8000214a:	fe 90 80 00 	breq	7fff214a <_estack+0x7ffda14a>
8000214e:	fe a4       	*unknown*
80002150:	80 00       	ld.sh	r0,r0[0x0]
80002152:	fe bc       	*unknown*
80002154:	80 00       	ld.sh	r0,r0[0x0]
80002156:	fe d8 eb cd 	satsub.w	r8,pc,-5171

80002158 <SingleDetection_brdcst_func>:
	
}


void SingleDetection_brdcst_func(xcmp_fragment_t * xcmp)
{
80002158:	eb cd 40 80 	pushm	r7,lr
8000215c:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == 0x11)
8000215e:	19 a9       	ld.ub	r9,r12[0x2]
80002160:	31 18       	mov	r8,17
80002162:	f0 09 18 00 	cp.b	r9,r8
80002166:	c0 61       	brne	80002172 <SingleDetection_brdcst_func+0x1a>
	{
		log("\n\r DMR_CSBK OK \n\r");
80002168:	48 8c       	lddpc	r12,80002188 <SingleDetection_brdcst_func+0x30>
8000216a:	f0 1f 00 09 	mcall	8000218c <SingleDetection_brdcst_func+0x34>
8000216e:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	//if(xcmp->u8[1] == 0x11)
	else
	{
		log("SIGBRCST error");
80002172:	48 8c       	lddpc	r12,80002190 <SingleDetection_brdcst_func+0x38>
80002174:	f0 1f 00 06 	mcall	8000218c <SingleDetection_brdcst_func+0x34>
		log("\n\r Signal_type: %X \n\r", xcmp->u8[0] );
80002178:	0f a8       	ld.ub	r8,r7[0x2]
8000217a:	1a d8       	st.w	--sp,r8
8000217c:	48 6c       	lddpc	r12,80002194 <SingleDetection_brdcst_func+0x3c>
8000217e:	f0 1f 00 04 	mcall	8000218c <SingleDetection_brdcst_func+0x34>
80002182:	2f fd       	sub	sp,-4
80002184:	e3 cd 80 80 	ldm	sp++,r7,pc
80002188:	80 00       	ld.sh	r0,r0[0x0]
8000218a:	fe f0 80 00 	ld.w	r0,pc[-32768]
8000218e:	9a a4       	ld.uh	r4,sp[0x4]
80002190:	80 00       	ld.sh	r0,r0[0x0]
80002192:	ff 04 80 00 	ld.sh	r4,pc[-32768]
80002196:	ff 14 d4 31 	ld.uh	r4,pc[-11215]

80002198 <ButtonConfig_brdcst_func>:
	
}


void ButtonConfig_brdcst_func(xcmp_fragment_t * xcmp)
{
80002198:	d4 31       	pushm	r0-r7,lr
	U8 Num_Button =0;
	U8 i = 0 ;
	/*point to xcmp payload*/
	ButtonConfig_brdcst_t  *ptr = (ButtonConfig_brdcst_t* )xcmp->u8;
8000219a:	f8 c7 ff fe 	sub	r7,r12,-2
	
	Num_Button = ptr->NumOfButtons;
8000219e:	0f 95       	ld.ub	r5,r7[0x1]
	
	log("\n\r ButtonConfig_broadcast  \n\r"  );
800021a0:	4a bc       	lddpc	r12,8000224c <ButtonConfig_brdcst_func+0xb4>
800021a2:	f0 1f 00 2c 	mcall	80002250 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r Function: %X \n\r" , ptr->Function );
800021a6:	0f 88       	ld.ub	r8,r7[0x0]
800021a8:	1a d8       	st.w	--sp,r8
800021aa:	4a bc       	lddpc	r12,80002254 <ButtonConfig_brdcst_func+0xbc>
800021ac:	f0 1f 00 29 	mcall	80002250 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
800021b0:	1a d5       	st.w	--sp,r5
800021b2:	4a ac       	lddpc	r12,80002258 <ButtonConfig_brdcst_func+0xc0>
800021b4:	f0 1f 00 27 	mcall	80002250 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
800021b8:	0f a8       	ld.ub	r8,r7[0x2]
800021ba:	1a d8       	st.w	--sp,r8
800021bc:	4a 8c       	lddpc	r12,8000225c <ButtonConfig_brdcst_func+0xc4>
800021be:	f0 1f 00 25 	mcall	80002250 <ButtonConfig_brdcst_func+0xb8>
	
	for (i; i<Num_Button; i++)
800021c2:	2f dd       	sub	sp,-12
800021c4:	58 05       	cp.w	r5,0
800021c6:	c4 10       	breq	80002248 <ButtonConfig_brdcst_func+0xb0>
800021c8:	30 06       	mov	r6,0
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
800021ca:	4a 64       	lddpc	r4,80002260 <ButtonConfig_brdcst_func+0xc8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
800021cc:	4a 63       	lddpc	r3,80002264 <ButtonConfig_brdcst_func+0xcc>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
800021ce:	4a 72       	lddpc	r2,80002268 <ButtonConfig_brdcst_func+0xd0>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
800021d0:	4a 71       	lddpc	r1,8000226c <ButtonConfig_brdcst_func+0xd4>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
800021d2:	4a 80       	lddpc	r0,80002270 <ButtonConfig_brdcst_func+0xd8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
800021d4:	0f b9       	ld.ub	r9,r7[0x3]
800021d6:	0f c8       	ld.ub	r8,r7[0x4]
800021d8:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800021dc:	1a d8       	st.w	--sp,r8
800021de:	1a d6       	st.w	--sp,r6
800021e0:	08 9c       	mov	r12,r4
800021e2:	f0 1f 00 1c 	mcall	80002250 <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
800021e6:	0f d9       	ld.ub	r9,r7[0x5]
800021e8:	0f e8       	ld.ub	r8,r7[0x6]
800021ea:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800021ee:	1a d8       	st.w	--sp,r8
800021f0:	1a d6       	st.w	--sp,r6
800021f2:	06 9c       	mov	r12,r3
800021f4:	f0 1f 00 17 	mcall	80002250 <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
800021f8:	0f f9       	ld.ub	r9,r7[0x7]
800021fa:	ef 38 00 08 	ld.ub	r8,r7[8]
800021fe:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002202:	1a d8       	st.w	--sp,r8
80002204:	1a d6       	st.w	--sp,r6
80002206:	04 9c       	mov	r12,r2
80002208:	f0 1f 00 12 	mcall	80002250 <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
8000220c:	ef 39 00 09 	ld.ub	r9,r7[9]
80002210:	ef 38 00 0a 	ld.ub	r8,r7[10]
80002214:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002218:	1a d8       	st.w	--sp,r8
8000221a:	1a d6       	st.w	--sp,r6
8000221c:	02 9c       	mov	r12,r1
8000221e:	f0 1f 00 0d 	mcall	80002250 <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
80002222:	2f 8d       	sub	sp,-32
80002224:	ef 39 00 0b 	ld.ub	r9,r7[11]
80002228:	ef 38 00 0c 	ld.ub	r8,r7[12]
8000222c:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002230:	1a d8       	st.w	--sp,r8
80002232:	1a d6       	st.w	--sp,r6
80002234:	00 9c       	mov	r12,r0
80002236:	f0 1f 00 07 	mcall	80002250 <ButtonConfig_brdcst_func+0xb8>
8000223a:	2f f6       	sub	r6,-1
8000223c:	2f 67       	sub	r7,-10
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
8000223e:	2f ed       	sub	sp,-8
80002240:	ec 05 18 00 	cp.b	r5,r6
80002244:	fe 9b ff c8 	brhi	800021d4 <ButtonConfig_brdcst_func+0x3c>
80002248:	d8 32       	popm	r0-r7,pc
8000224a:	00 00       	add	r0,r0
8000224c:	80 00       	ld.sh	r0,r0[0x0]
8000224e:	ff 2c 80 00 	ld.sb	r12,pc[-32768]
80002252:	9a a4       	ld.uh	r4,sp[0x4]
80002254:	80 00       	ld.sh	r0,r0[0x0]
80002256:	ff 4c 80 00 	st.w	pc[-32768],r12
8000225a:	ff 60 80 00 	st.b	pc[-32768],r0
8000225e:	ff 78 80 00 	stcond	pc[-32768],r8
80002262:	ff 98       	*unknown*
80002264:	80 00       	ld.sh	r0,r0[0x0]
80002266:	ff c0       	*unknown*
80002268:	80 00       	ld.sh	r0,r0[0x0]
8000226a:	ff e8 80 01 	sthh.w	r1[r0],pc:b,r8:b
8000226e:	00 0c       	add	r12,r0
80002270:	80 01       	ld.sh	r1,r0[0x0]
80002272:	00 34       	cp.w	r4,r0

80002274 <Phyuserinput_brdcst_func>:
	
}


void Phyuserinput_brdcst_func(xcmp_fragment_t * xcmp)
{
80002274:	eb cd 40 fc 	pushm	r2-r7,lr
	U16 PUI_ID =0;
	U8 PUI_State =0;
	U8 PUI_State_Min_Value =0;
	U8 PUI_State_Max_Value =0;
	
	PUI_Source = xcmp->u8[0];
80002278:	19 a6       	ld.ub	r6,r12[0x2]
	PUI_Type = xcmp ->u8[1];
8000227a:	19 b5       	ld.ub	r5,r12[0x3]
	PUI_ID = ((xcmp->u8[2]<<8) | xcmp->u8[3]);
8000227c:	19 c7       	ld.ub	r7,r12[0x4]
8000227e:	19 d8       	ld.ub	r8,r12[0x5]
80002280:	f1 e7 10 87 	or	r7,r8,r7<<0x8
	PUI_State = xcmp->u8[4];
80002284:	19 e4       	ld.ub	r4,r12[0x6]
	PUI_State_Min_Value = xcmp->u8[5];
80002286:	19 f3       	ld.ub	r3,r12[0x7]
	PUI_State_Max_Value = xcmp->u8[6];
80002288:	f9 32 00 08 	ld.ub	r2,r12[8]
	
	log("\n\r PhysicalUserInput_broadcast  \n\r"  );
8000228c:	49 0c       	lddpc	r12,800022cc <Phyuserinput_brdcst_func+0x58>
8000228e:	f0 1f 00 11 	mcall	800022d0 <Phyuserinput_brdcst_func+0x5c>
	
	log("\n\r PUI_Source: %X \n\r" , PUI_Source);
80002292:	1a d6       	st.w	--sp,r6
80002294:	49 0c       	lddpc	r12,800022d4 <Phyuserinput_brdcst_func+0x60>
80002296:	f0 1f 00 0f 	mcall	800022d0 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_Type: %X \n\r" , PUI_Type);
8000229a:	1a d5       	st.w	--sp,r5
8000229c:	48 fc       	lddpc	r12,800022d8 <Phyuserinput_brdcst_func+0x64>
8000229e:	f0 1f 00 0d 	mcall	800022d0 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_ID: %X \n\r" , PUI_ID);
800022a2:	5c 77       	castu.h	r7
800022a4:	1a d7       	st.w	--sp,r7
800022a6:	48 ec       	lddpc	r12,800022dc <Phyuserinput_brdcst_func+0x68>
800022a8:	f0 1f 00 0a 	mcall	800022d0 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_State: %X \n\r" , PUI_State);
800022ac:	1a d4       	st.w	--sp,r4
800022ae:	48 dc       	lddpc	r12,800022e0 <Phyuserinput_brdcst_func+0x6c>
800022b0:	f0 1f 00 08 	mcall	800022d0 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_State_Min_Value: %X \n\r" , PUI_State_Min_Value);
800022b4:	1a d3       	st.w	--sp,r3
800022b6:	48 cc       	lddpc	r12,800022e4 <Phyuserinput_brdcst_func+0x70>
800022b8:	f0 1f 00 06 	mcall	800022d0 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_State_Max_Value: %X \n\r" , PUI_State_Max_Value);
800022bc:	1a d2       	st.w	--sp,r2
800022be:	48 bc       	lddpc	r12,800022e8 <Phyuserinput_brdcst_func+0x74>
800022c0:	f0 1f 00 04 	mcall	800022d0 <Phyuserinput_brdcst_func+0x5c>
800022c4:	2f ad       	sub	sp,-24
	
	
	
	
	
}
800022c6:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800022ca:	00 00       	add	r0,r0
800022cc:	80 01       	ld.sh	r1,r0[0x0]
800022ce:	00 58       	eor	r8,r0
800022d0:	80 00       	ld.sh	r0,r0[0x0]
800022d2:	9a a4       	ld.uh	r4,sp[0x4]
800022d4:	80 01       	ld.sh	r1,r0[0x0]
800022d6:	00 7c       	tst	r12,r0
800022d8:	80 01       	ld.sh	r1,r0[0x0]
800022da:	00 94       	mov	r4,r0
800022dc:	80 01       	ld.sh	r1,r0[0x0]
800022de:	00 a8       	st.w	r0++,r8
800022e0:	80 01       	ld.sh	r1,r0[0x0]
800022e2:	00 bc       	st.h	r0++,r12
800022e4:	80 01       	ld.sh	r1,r0[0x0]
800022e6:	00 d0       	st.w	--r0,r0
800022e8:	80 01       	ld.sh	r1,r0[0x0]
800022ea:	00 f0       	st.b	--r0,r0

800022ec <ButtonConfig_reply_func>:
	}
	
}

void ButtonConfig_reply_func(xcmp_fragment_t * xcmp)
{
800022ec:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	ButtonConfig_reply_t *ptr = (ButtonConfig_reply_t* )(xcmp->u8);
800022f0:	f8 c7 ff fe 	sub	r7,r12,-2
	if (ptr->Result == xcmp_Res_Success)
800022f4:	0f 89       	ld.ub	r9,r7[0x0]
800022f6:	30 08       	mov	r8,0
800022f8:	f0 09 18 00 	cp.b	r9,r8
800022fc:	c0 c1       	brne	80002314 <ButtonConfig_reply_func+0x28>
	{
		log("\n\r Button_Config OK \n\r");
800022fe:	48 9c       	lddpc	r12,80002320 <ButtonConfig_reply_func+0x34>
80002300:	f0 1f 00 09 	mcall	80002324 <ButtonConfig_reply_func+0x38>
		
		log("\n\r Function: %X \n\r" , ptr->Function );
80002304:	0f 98       	ld.ub	r8,r7[0x1]
80002306:	1a d8       	st.w	--sp,r8
80002308:	48 8c       	lddpc	r12,80002328 <ButtonConfig_reply_func+0x3c>
8000230a:	f0 1f 00 07 	mcall	80002324 <ButtonConfig_reply_func+0x38>
8000230e:	2f fd       	sub	sp,-4
80002310:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r Button_Request error \n\r");
80002314:	48 6c       	lddpc	r12,8000232c <ButtonConfig_reply_func+0x40>
80002316:	f0 1f 00 04 	mcall	80002324 <ButtonConfig_reply_func+0x38>
8000231a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000231e:	00 00       	add	r0,r0
80002320:	80 01       	ld.sh	r1,r0[0x0]
80002322:	01 10       	ld.sh	r0,r0++
80002324:	80 00       	ld.sh	r0,r0[0x0]
80002326:	9a a4       	ld.uh	r4,sp[0x4]
80002328:	80 00       	ld.sh	r0,r0[0x0]
8000232a:	ff 4c 80 01 	st.w	pc[-32767],r12
8000232e:	01 28       	ld.uh	r8,r0++

80002330 <DataSession_brdcst_func>:
	}
	
}

void DataSession_brdcst_func(xcmp_fragment_t * xcmp)
{
80002330:	d4 21       	pushm	r4-r7,lr
	U8 Session_number = 0;
	U16 data_length = 0;
	U8 i = 0;
	/*point to xcmp payload*/
	DataSession_brdcst_t *ptr = (DataSession_brdcst_t* )xcmp->u8;
80002332:	f8 c6 ff fe 	sub	r6,r12,-2

	if (ptr->State == CSBK_DATA_RX_Suc)
80002336:	0d 88       	ld.ub	r8,r6[0x0]
80002338:	32 49       	mov	r9,36
8000233a:	f2 08 18 00 	cp.b	r8,r9
8000233e:	c2 91       	brne	80002390 <DataSession_brdcst_func+0x60>
	{
		
		log("\n\r CSBK_RX OK \n\r");
80002340:	49 7c       	lddpc	r12,8000239c <DataSession_brdcst_func+0x6c>
80002342:	f0 1f 00 18 	mcall	800023a0 <DataSession_brdcst_func+0x70>
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
80002346:	0d a5       	ld.ub	r5,r6[0x2]
80002348:	0d b8       	ld.ub	r8,r6[0x3]
8000234a:	f1 e5 10 85 	or	r5,r8,r5<<0x8
8000234e:	5c 85       	casts.h	r5

		log("\n\r Session_ID: %x \n\r",Session_number );
80002350:	0d 98       	ld.ub	r8,r6[0x1]
80002352:	1a d8       	st.w	--sp,r8
80002354:	49 4c       	lddpc	r12,800023a4 <DataSession_brdcst_func+0x74>
80002356:	f0 1f 00 13 	mcall	800023a0 <DataSession_brdcst_func+0x70>
		log("\n\r paylaod_length: %d \n\r",data_length );
8000235a:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
8000235e:	1a d8       	st.w	--sp,r8
80002360:	49 2c       	lddpc	r12,800023a8 <DataSession_brdcst_func+0x78>
80002362:	f0 1f 00 10 	mcall	800023a0 <DataSession_brdcst_func+0x70>
		for(i=0; i<data_length; i++)
80002366:	2f ed       	sub	sp,-8
80002368:	58 05       	cp.w	r5,0
8000236a:	c1 80       	breq	8000239a <DataSession_brdcst_func+0x6a>
8000236c:	30 07       	mov	r7,0
		{
			
			//log("\n\r payload[%d]: %X \n\r", i, xcmp->u8[4+i]);
			log("\n\r payload[%d]: %X \n\r", i, ptr->DataPayload.DataPayload[i]);
8000236e:	49 04       	lddpc	r4,800023ac <DataSession_brdcst_func+0x7c>
80002370:	ec 07 00 08 	add	r8,r6,r7
80002374:	11 c8       	ld.ub	r8,r8[0x4]
80002376:	1a d8       	st.w	--sp,r8
80002378:	1a d7       	st.w	--sp,r7
8000237a:	08 9c       	mov	r12,r4
8000237c:	f0 1f 00 09 	mcall	800023a0 <DataSession_brdcst_func+0x70>
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);

		log("\n\r Session_ID: %x \n\r",Session_number );
		log("\n\r paylaod_length: %d \n\r",data_length );
		for(i=0; i<data_length; i++)
80002380:	2f f7       	sub	r7,-1
80002382:	5c 57       	castu.b	r7
80002384:	2f ed       	sub	sp,-8
80002386:	ee 05 19 00 	cp.h	r5,r7
8000238a:	fe 9b ff f3 	brhi	80002370 <DataSession_brdcst_func+0x40>
8000238e:	d8 22       	popm	r4-r7,pc
		
	}
	else
	{
		//log("\n\r State: 0x %X \n\r", xcmp->u8[0]);
		log("\n\r State: 0x %X \n\r", ptr->State);
80002390:	1a d8       	st.w	--sp,r8
80002392:	48 8c       	lddpc	r12,800023b0 <DataSession_brdcst_func+0x80>
80002394:	f0 1f 00 03 	mcall	800023a0 <DataSession_brdcst_func+0x70>
80002398:	2f fd       	sub	sp,-4
8000239a:	d8 22       	popm	r4-r7,pc
8000239c:	80 01       	ld.sh	r1,r0[0x0]
8000239e:	01 44       	ld.w	r4,--r0
800023a0:	80 00       	ld.sh	r0,r0[0x0]
800023a2:	9a a4       	ld.uh	r4,sp[0x4]
800023a4:	80 01       	ld.sh	r1,r0[0x0]
800023a6:	01 58       	ld.sh	r8,--r0
800023a8:	80 01       	ld.sh	r1,r0[0x0]
800023aa:	01 70       	ld.ub	r0,--r0
800023ac:	80 01       	ld.sh	r1,r0[0x0]
800023ae:	01 8c       	ld.ub	r12,r0[0x0]
800023b0:	80 01       	ld.sh	r1,r0[0x0]
800023b2:	01 a4       	ld.ub	r4,r0[0x2]

800023b4 <DataSession_reply_func>:
	
}


void DataSession_reply_func(xcmp_fragment_t * xcmp)
{
800023b4:	eb cd 40 80 	pushm	r7,lr
800023b8:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
800023ba:	19 a8       	ld.ub	r8,r12[0x2]
800023bc:	58 08       	cp.w	r8,0
800023be:	c0 61       	brne	800023ca <DataSession_reply_func+0x16>
	{
		log("\n\r DATArep OK \n\r");
800023c0:	48 dc       	lddpc	r12,800023f4 <DataSession_reply_func+0x40>
800023c2:	f0 1f 00 0e 	mcall	800023f8 <DataSession_reply_func+0x44>
800023c6:	e3 cd 80 80 	ldm	sp++,r7,pc
		//log("\n\r ID: 0x %X \n\r", xcmp->u8[2]);
		
	}
	else
	{
		log("\n\r Result:  %X \n\r", xcmp->u8[0]);
800023ca:	1a d8       	st.w	--sp,r8
800023cc:	48 cc       	lddpc	r12,800023fc <DataSession_reply_func+0x48>
800023ce:	f0 1f 00 0b 	mcall	800023f8 <DataSession_reply_func+0x44>
		log("\n\r DATArep error \n\r");
800023d2:	48 cc       	lddpc	r12,80002400 <DataSession_reply_func+0x4c>
800023d4:	f0 1f 00 09 	mcall	800023f8 <DataSession_reply_func+0x44>
		log("\n\r Func:  %X \n\r", xcmp->u8[1]);
800023d8:	0f b8       	ld.ub	r8,r7[0x3]
800023da:	1a d8       	st.w	--sp,r8
800023dc:	48 ac       	lddpc	r12,80002404 <DataSession_reply_func+0x50>
800023de:	f0 1f 00 07 	mcall	800023f8 <DataSession_reply_func+0x44>
		log("\n\r ID:  %X \n\r", xcmp->u8[2]);
800023e2:	0f c8       	ld.ub	r8,r7[0x4]
800023e4:	1a d8       	st.w	--sp,r8
800023e6:	48 9c       	lddpc	r12,80002408 <DataSession_reply_func+0x54>
800023e8:	f0 1f 00 04 	mcall	800023f8 <DataSession_reply_func+0x44>
800023ec:	2f dd       	sub	sp,-12
800023ee:	e3 cd 80 80 	ldm	sp++,r7,pc
800023f2:	00 00       	add	r0,r0
800023f4:	80 01       	ld.sh	r1,r0[0x0]
800023f6:	01 b8       	ld.ub	r8,r0[0x3]
800023f8:	80 00       	ld.sh	r0,r0[0x0]
800023fa:	9a a4       	ld.uh	r4,sp[0x4]
800023fc:	80 01       	ld.sh	r1,r0[0x0]
800023fe:	01 cc       	ld.ub	r12,r0[0x4]
80002400:	80 01       	ld.sh	r1,r0[0x0]
80002402:	01 e0       	ld.ub	r0,r0[0x6]
80002404:	80 01       	ld.sh	r1,r0[0x0]
80002406:	01 f4       	ld.ub	r4,r0[0x7]
80002408:	80 01       	ld.sh	r1,r0[0x0]
8000240a:	02 04       	add	r4,r1

8000240c <TransmitControl_reply_func>:




void TransmitControl_reply_func(xcmp_fragment_t * xcmp)
{
8000240c:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	TransmitControl_reply_t *ptr = (TransmitControl_reply_t* )xcmp->u8;
80002410:	f8 c7 ff fe 	sub	r7,r12,-2
	
	if (ptr->Result == xcmp_Res_Success)
80002414:	0f 89       	ld.ub	r9,r7[0x0]
80002416:	30 08       	mov	r8,0
80002418:	f0 09 18 00 	cp.b	r9,r8
8000241c:	c2 21       	brne	80002460 <TransmitControl_reply_func+0x54>
	{
		
		log("\n\r  TransmitControl OK \n\r ");
8000241e:	49 4c       	lddpc	r12,8000246c <TransmitControl_reply_func+0x60>
80002420:	f0 1f 00 14 	mcall	80002470 <TransmitControl_reply_func+0x64>
		log("\n\r Function: %x \n\r", ptr->Function);
80002424:	0f 98       	ld.ub	r8,r7[0x1]
80002426:	1a d8       	st.w	--sp,r8
80002428:	49 3c       	lddpc	r12,80002474 <TransmitControl_reply_func+0x68>
8000242a:	f0 1f 00 12 	mcall	80002470 <TransmitControl_reply_func+0x64>
		log("\n\r Mode of Operation: %x \n\r", ptr->Mode_Of_Operation);
8000242e:	0f a8       	ld.ub	r8,r7[0x2]
80002430:	1a d8       	st.w	--sp,r8
80002432:	49 2c       	lddpc	r12,80002478 <TransmitControl_reply_func+0x6c>
80002434:	f0 1f 00 0f 	mcall	80002470 <TransmitControl_reply_func+0x64>
		log("\n\r State: %x \n\r", ptr->State);
80002438:	0f b8       	ld.ub	r8,r7[0x3]
8000243a:	1a d8       	st.w	--sp,r8
8000243c:	49 0c       	lddpc	r12,8000247c <TransmitControl_reply_func+0x70>
8000243e:	f0 1f 00 0d 	mcall	80002470 <TransmitControl_reply_func+0x64>
		
		if (ptr->Function == KEY_UP)
80002442:	0f 98       	ld.ub	r8,r7[0x1]
80002444:	2f dd       	sub	sp,-12
80002446:	30 19       	mov	r9,1
80002448:	f2 08 18 00 	cp.b	r8,r9
8000244c:	c0 d0       	breq	80002466 <TransmitControl_reply_func+0x5a>
		{
			//is_unmute = 1;
		}
		else if (ptr->Function ==DE_KEY)
8000244e:	30 29       	mov	r9,2
80002450:	f2 08 18 00 	cp.b	r8,r9
80002454:	c0 91       	brne	80002466 <TransmitControl_reply_func+0x5a>
		{
			is_unmute = 0;
80002456:	30 09       	mov	r9,0
80002458:	48 a8       	lddpc	r8,80002480 <TransmitControl_reply_func+0x74>
8000245a:	b0 89       	st.b	r8[0x0],r9
8000245c:	e3 cd 80 80 	ldm	sp++,r7,pc
		
		//Silent_flag = 1;
	}
	else
	{
		log("TransmitControl error");
80002460:	48 9c       	lddpc	r12,80002484 <TransmitControl_reply_func+0x78>
80002462:	f0 1f 00 04 	mcall	80002470 <TransmitControl_reply_func+0x64>
80002466:	e3 cd 80 80 	ldm	sp++,r7,pc
8000246a:	00 00       	add	r0,r0
8000246c:	80 01       	ld.sh	r1,r0[0x0]
8000246e:	02 14       	sub	r4,r1
80002470:	80 00       	ld.sh	r0,r0[0x0]
80002472:	9a a4       	ld.uh	r4,sp[0x4]
80002474:	80 01       	ld.sh	r1,r0[0x0]
80002476:	02 30       	cp.w	r0,r1
80002478:	80 01       	ld.sh	r1,r0[0x0]
8000247a:	02 44       	or	r4,r1
8000247c:	80 01       	ld.sh	r1,r0[0x0]
8000247e:	02 60       	and	r0,r1
80002480:	00 00       	add	r0,r0
80002482:	0a 4d       	or	sp,r5
80002484:	80 01       	ld.sh	r1,r0[0x0]
80002486:	02 70       	tst	r0,r1

80002488 <AudioRoutingControl_brdcst_func>:
	}
}


void AudioRoutingControl_brdcst_func(xcmp_fragment_t * xcmp)
{
80002488:	eb cd 40 f8 	pushm	r3-r7,lr
8000248c:	18 96       	mov	r6,r12
	
	U16 num_routings = 0;
	U8 j = 0 ;
	
	num_routings = ((xcmp->u8[0]<< 8) | (xcmp->u8[1]) );
8000248e:	19 a5       	ld.ub	r5,r12[0x2]
80002490:	19 b8       	ld.ub	r8,r12[0x3]
80002492:	f1 e5 10 85 	or	r5,r8,r5<<0x8
80002496:	5c 85       	casts.h	r5
	log("\n\r num_routings: %d \n\r", num_routings);
80002498:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
8000249c:	1a d8       	st.w	--sp,r8
8000249e:	49 6c       	lddpc	r12,800024f4 <AudioRoutingControl_brdcst_func+0x6c>
800024a0:	f0 1f 00 16 	mcall	800024f8 <AudioRoutingControl_brdcst_func+0x70>
	
	for(j = 0; j< num_routings ; j++ )
800024a4:	2f fd       	sub	sp,-4
800024a6:	58 05       	cp.w	r5,0
800024a8:	c0 31       	brne	800024ae <AudioRoutingControl_brdcst_func+0x26>
800024aa:	30 07       	mov	r7,0
800024ac:	c1 98       	rjmp	800024de <AudioRoutingControl_brdcst_func+0x56>
800024ae:	30 07       	mov	r7,0
	{
		
		
		log("\n\r Audio-Input: %x \n\r", xcmp->u8[2+j*2]);
800024b0:	49 34       	lddpc	r4,800024fc <AudioRoutingControl_brdcst_func+0x74>
		log("\n\r Audio-Output: %x \n\r", xcmp->u8[3+j*2]);
800024b2:	49 43       	lddpc	r3,80002500 <AudioRoutingControl_brdcst_func+0x78>
	
	for(j = 0; j< num_routings ; j++ )
	{
		
		
		log("\n\r Audio-Input: %x \n\r", xcmp->u8[2+j*2]);
800024b4:	ec 07 00 18 	add	r8,r6,r7<<0x1
800024b8:	11 c8       	ld.ub	r8,r8[0x4]
800024ba:	1a d8       	st.w	--sp,r8
800024bc:	08 9c       	mov	r12,r4
800024be:	f0 1f 00 0f 	mcall	800024f8 <AudioRoutingControl_brdcst_func+0x70>
		log("\n\r Audio-Output: %x \n\r", xcmp->u8[3+j*2]);
800024c2:	ec 07 00 18 	add	r8,r6,r7<<0x1
800024c6:	11 d8       	ld.ub	r8,r8[0x5]
800024c8:	1a d8       	st.w	--sp,r8
800024ca:	06 9c       	mov	r12,r3
800024cc:	f0 1f 00 0b 	mcall	800024f8 <AudioRoutingControl_brdcst_func+0x70>
	U8 j = 0 ;
	
	num_routings = ((xcmp->u8[0]<< 8) | (xcmp->u8[1]) );
	log("\n\r num_routings: %d \n\r", num_routings);
	
	for(j = 0; j< num_routings ; j++ )
800024d0:	2f f7       	sub	r7,-1
800024d2:	5c 57       	castu.b	r7
800024d4:	2f ed       	sub	sp,-8
800024d6:	ee 05 19 00 	cp.h	r5,r7
800024da:	fe 9b ff ed 	brhi	800024b4 <AudioRoutingControl_brdcst_func+0x2c>
		log("\n\r Audio-Output: %x \n\r", xcmp->u8[3+j*2]);
		
		
	}
	
	log("\n\r Audio-Function: %x \n\r", xcmp->u8[3+j*2-1]);
800024de:	ec 07 00 17 	add	r7,r6,r7<<0x1
800024e2:	0f c8       	ld.ub	r8,r7[0x4]
800024e4:	1a d8       	st.w	--sp,r8
800024e6:	48 8c       	lddpc	r12,80002504 <AudioRoutingControl_brdcst_func+0x7c>
800024e8:	f0 1f 00 04 	mcall	800024f8 <AudioRoutingControl_brdcst_func+0x70>
800024ec:	2f fd       	sub	sp,-4
	
	
	
}
800024ee:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
800024f2:	00 00       	add	r0,r0
800024f4:	80 01       	ld.sh	r1,r0[0x0]
800024f6:	02 88       	andn	r8,r1
800024f8:	80 00       	ld.sh	r0,r0[0x0]
800024fa:	9a a4       	ld.uh	r4,sp[0x4]
800024fc:	80 01       	ld.sh	r1,r0[0x0]
800024fe:	02 a0       	st.w	r1++,r0
80002500:	80 01       	ld.sh	r1,r0[0x0]
80002502:	02 b8       	st.h	r1++,r8
80002504:	80 01       	ld.sh	r1,r0[0x0]
80002506:	02 d0       	st.w	--r1,r0

80002508 <AudioRoutingControl_reply_func>:
	
}


void AudioRoutingControl_reply_func(xcmp_fragment_t * xcmp)
{
80002508:	eb cd 40 80 	pushm	r7,lr
8000250c:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
8000250e:	19 a9       	ld.ub	r9,r12[0x2]
80002510:	30 08       	mov	r8,0
80002512:	f0 09 18 00 	cp.b	r9,r8
80002516:	c0 61       	brne	80002522 <AudioRoutingControl_reply_func+0x1a>
	{
		log("AudioRouting OK");
80002518:	48 8c       	lddpc	r12,80002538 <AudioRoutingControl_reply_func+0x30>
8000251a:	f0 1f 00 09 	mcall	8000253c <AudioRoutingControl_reply_func+0x34>
8000251e:	e3 cd 80 80 	ldm	sp++,r7,pc
		//is_unmute = 1;
	}
	else
	{
		log("AudioRouting error");
80002522:	48 8c       	lddpc	r12,80002540 <AudioRoutingControl_reply_func+0x38>
80002524:	f0 1f 00 06 	mcall	8000253c <AudioRoutingControl_reply_func+0x34>
		log("\n\r AudioRouting result: %x \n\r", xcmp->u8[0]);
80002528:	0f a8       	ld.ub	r8,r7[0x2]
8000252a:	1a d8       	st.w	--sp,r8
8000252c:	48 6c       	lddpc	r12,80002544 <AudioRoutingControl_reply_func+0x3c>
8000252e:	f0 1f 00 04 	mcall	8000253c <AudioRoutingControl_reply_func+0x34>
80002532:	2f fd       	sub	sp,-4
80002534:	e3 cd 80 80 	ldm	sp++,r7,pc
80002538:	80 01       	ld.sh	r1,r0[0x0]
8000253a:	02 ec       	st.h	--r1,r12
8000253c:	80 00       	ld.sh	r0,r0[0x0]
8000253e:	9a a4       	ld.uh	r4,sp[0x4]
80002540:	80 01       	ld.sh	r1,r0[0x0]
80002542:	02 fc       	st.b	--r1,r12
80002544:	80 01       	ld.sh	r1,r0[0x0]
80002546:	03 10       	ld.sh	r0,r1++

80002548 <Volume_brdcst_func>:
	
	
}

void Volume_brdcst_func(xcmp_fragment_t * xcmp)
{
80002548:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	VolumeControl_brdcst_t *ptr = (VolumeControl_brdcst_t* )xcmp->u8;
8000254c:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
80002550:	0f 89       	ld.ub	r9,r7[0x0]
80002552:	0f 98       	ld.ub	r8,r7[0x1]
80002554:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002558:	1a d8       	st.w	--sp,r8
8000255a:	48 6c       	lddpc	r12,80002570 <Volume_brdcst_func+0x28>
8000255c:	f0 1f 00 06 	mcall	80002574 <Volume_brdcst_func+0x2c>
	
	log("\n\r Audio_Parameter: %x \n\r", ptr->Audio_Parameter);
80002560:	0f b8       	ld.ub	r8,r7[0x3]
80002562:	1a d8       	st.w	--sp,r8
80002564:	48 5c       	lddpc	r12,80002578 <Volume_brdcst_func+0x30>
80002566:	f0 1f 00 04 	mcall	80002574 <Volume_brdcst_func+0x2c>
8000256a:	2f ed       	sub	sp,-8
	
	
}
8000256c:	e3 cd 80 80 	ldm	sp++,r7,pc
80002570:	80 01       	ld.sh	r1,r0[0x0]
80002572:	03 30       	ld.ub	r0,r1++
80002574:	80 00       	ld.sh	r0,r0[0x0]
80002576:	9a a4       	ld.uh	r4,sp[0x4]
80002578:	80 01       	ld.sh	r1,r0[0x0]
8000257a:	03 4c       	ld.w	r12,--r1

8000257c <Volume_reply_func>:
	
}


void Volume_reply_func(xcmp_fragment_t * xcmp)
{
8000257c:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	VolumeControl_reply_t *ptr = (VolumeControl_reply_t* )xcmp->u8;
80002580:	f8 c7 ff fe 	sub	r7,r12,-2
	
		if (ptr->Result == xcmp_Res_Success)
80002584:	0f 89       	ld.ub	r9,r7[0x0]
80002586:	30 08       	mov	r8,0
80002588:	f0 09 18 00 	cp.b	r9,r8
8000258c:	c1 b1       	brne	800025c2 <Volume_reply_func+0x46>
		{
			if (ptr->Function == Enable_IntelligentAudio)
8000258e:	0f b8       	ld.ub	r8,r7[0x3]
80002590:	31 09       	mov	r9,16
80002592:	f2 08 18 00 	cp.b	r8,r9
80002596:	c0 f1       	brne	800025b4 <Volume_reply_func+0x38>
			{
				log("\n\r Enable_IA OK \n\r");
80002598:	48 dc       	lddpc	r12,800025cc <Volume_reply_func+0x50>
8000259a:	f0 1f 00 0e 	mcall	800025d0 <Volume_reply_func+0x54>
				log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
8000259e:	0f 99       	ld.ub	r9,r7[0x1]
800025a0:	0f a8       	ld.ub	r8,r7[0x2]
800025a2:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800025a6:	1a d8       	st.w	--sp,r8
800025a8:	48 bc       	lddpc	r12,800025d4 <Volume_reply_func+0x58>
800025aa:	f0 1f 00 0a 	mcall	800025d0 <Volume_reply_func+0x54>
800025ae:	2f fd       	sub	sp,-4
800025b0:	e3 cd 80 80 	ldm	sp++,r7,pc
	
			}
			else
			{
				
				log("\n\r VolumeControl: %x \n\r", ptr->Function);
800025b4:	1a d8       	st.w	--sp,r8
800025b6:	48 9c       	lddpc	r12,800025d8 <Volume_reply_func+0x5c>
800025b8:	f0 1f 00 06 	mcall	800025d0 <Volume_reply_func+0x54>
800025bc:	2f fd       	sub	sp,-4
800025be:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		
		else
		{
			log("\n\r Enable_IA error \n\r");
800025c2:	48 7c       	lddpc	r12,800025dc <Volume_reply_func+0x60>
800025c4:	f0 1f 00 03 	mcall	800025d0 <Volume_reply_func+0x54>
800025c8:	e3 cd 80 80 	ldm	sp++,r7,pc
800025cc:	80 01       	ld.sh	r1,r0[0x0]
800025ce:	03 68       	ld.uh	r8,--r1
800025d0:	80 00       	ld.sh	r0,r0[0x0]
800025d2:	9a a4       	ld.uh	r4,sp[0x4]
800025d4:	80 01       	ld.sh	r1,r0[0x0]
800025d6:	03 30       	ld.ub	r0,r1++
800025d8:	80 01       	ld.sh	r1,r0[0x0]
800025da:	03 7c       	ld.ub	r12,--r1
800025dc:	80 01       	ld.sh	r1,r0[0x0]
800025de:	03 94       	ld.ub	r4,r1[0x1]

800025e0 <spk_brdcst_func>:
		log("spk error");
	}
}

void spk_brdcst_func(xcmp_fragment_t * xcmp)
{
800025e0:	d4 01       	pushm	lr
	if (xcmp->u8[3] == xcmp_Res_Success)//0x0000:mute
800025e2:	19 d9       	ld.ub	r9,r12[0x5]
800025e4:	30 08       	mov	r8,0
800025e6:	f0 09 18 00 	cp.b	r9,r8
800025ea:	c0 91       	brne	800025fc <spk_brdcst_func+0x1c>
	{
		is_unmute =0;
800025ec:	48 89       	lddpc	r9,8000260c <spk_brdcst_func+0x2c>
800025ee:	b2 88       	st.b	r9[0x0],r8
		Silent_flag = 0;
800025f0:	48 89       	lddpc	r9,80002610 <spk_brdcst_func+0x30>
800025f2:	b2 88       	st.b	r9[0x0],r8
		log("spk_s_close ");
800025f4:	48 8c       	lddpc	r12,80002614 <spk_brdcst_func+0x34>
800025f6:	f0 1f 00 09 	mcall	80002618 <spk_brdcst_func+0x38>
800025fa:	d8 02       	popm	pc
		
		
	}
	else
	{
		Silent_flag = 1;
800025fc:	30 19       	mov	r9,1
800025fe:	48 58       	lddpc	r8,80002610 <spk_brdcst_func+0x30>
80002600:	b0 89       	st.b	r8[0x0],r9
		//is_unmute = 1;
		log("spk_s_open ");
80002602:	48 7c       	lddpc	r12,8000261c <spk_brdcst_func+0x3c>
80002604:	f0 1f 00 05 	mcall	80002618 <spk_brdcst_func+0x38>
80002608:	d8 02       	popm	pc
8000260a:	00 00       	add	r0,r0
8000260c:	00 00       	add	r0,r0
8000260e:	0a 4d       	or	sp,r5
80002610:	00 00       	add	r0,r0
80002612:	0a 54       	eor	r4,r5
80002614:	80 01       	ld.sh	r1,r0[0x0]
80002616:	03 ac       	ld.ub	r12,r1[0x2]
80002618:	80 00       	ld.sh	r0,r0[0x0]
8000261a:	9a a4       	ld.uh	r4,sp[0x4]
8000261c:	80 01       	ld.sh	r1,r0[0x0]
8000261e:	03 bc       	ld.ub	r12,r1[0x3]

80002620 <spk_reply_func>:
			
	
}

void spk_reply_func(xcmp_fragment_t * xcmp)
{
80002620:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
80002622:	19 a9       	ld.ub	r9,r12[0x2]
80002624:	30 08       	mov	r8,0
80002626:	f0 09 18 00 	cp.b	r9,r8
8000262a:	c0 f1       	brne	80002648 <spk_reply_func+0x28>
	{
		
		if(xcmp->u8[4])
8000262c:	19 e9       	ld.ub	r9,r12[0x6]
8000262e:	f0 09 18 00 	cp.b	r9,r8
80002632:	c0 40       	breq	8000263a <spk_reply_func+0x1a>
		{
			is_unmute = 1;
80002634:	30 19       	mov	r9,1
80002636:	48 78       	lddpc	r8,80002650 <spk_reply_func+0x30>
80002638:	b0 89       	st.b	r8[0x0],r9
			
			//Silent_flag = 1;
		}
		log("spk OK -st%2x", xcmp->u8[4] );
8000263a:	19 e8       	ld.ub	r8,r12[0x6]
8000263c:	1a d8       	st.w	--sp,r8
8000263e:	48 6c       	lddpc	r12,80002654 <spk_reply_func+0x34>
80002640:	f0 1f 00 06 	mcall	80002658 <spk_reply_func+0x38>
80002644:	2f fd       	sub	sp,-4
80002646:	d8 02       	popm	pc
		
	}
	else
	{
		log("spk error");
80002648:	48 5c       	lddpc	r12,8000265c <spk_reply_func+0x3c>
8000264a:	f0 1f 00 04 	mcall	80002658 <spk_reply_func+0x38>
8000264e:	d8 02       	popm	pc
80002650:	00 00       	add	r0,r0
80002652:	0a 4d       	or	sp,r5
80002654:	80 01       	ld.sh	r1,r0[0x0]
80002656:	03 c8       	ld.ub	r8,r1[0x4]
80002658:	80 00       	ld.sh	r0,r0[0x0]
8000265a:	9a a4       	ld.uh	r4,sp[0x4]
8000265c:	80 01       	ld.sh	r1,r0[0x0]
8000265e:	03 d8       	ld.ub	r8,r1[0x5]

80002660 <mic_reply_func>:
	
	
}

void mic_reply_func(xcmp_fragment_t * xcmp)
{
80002660:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_reply_t *ptr = (MicControl_reply_t* )xcmp->u8;
80002664:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Mic_reply \n\r");
80002668:	49 ac       	lddpc	r12,800026d0 <mic_reply_func+0x70>
8000266a:	f0 1f 00 1b 	mcall	800026d4 <mic_reply_func+0x74>
	if (ptr->Result == 0x00)
8000266e:	0f 89       	ld.ub	r9,r7[0x0]
80002670:	30 08       	mov	r8,0
80002672:	f0 09 18 00 	cp.b	r9,r8
80002676:	c2 71       	brne	800026c4 <mic_reply_func+0x64>
	{
		
		if (ptr->Function == Mic_Disable)
80002678:	0f 98       	ld.ub	r8,r7[0x1]
8000267a:	30 29       	mov	r9,2
8000267c:	f2 08 18 00 	cp.b	r8,r9
80002680:	c1 b1       	brne	800026b6 <mic_reply_func+0x56>
		{
		
			log("\n\r Mic_close_ok \n\r " );
80002682:	49 6c       	lddpc	r12,800026d8 <mic_reply_func+0x78>
80002684:	f0 1f 00 14 	mcall	800026d4 <mic_reply_func+0x74>
			log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
80002688:	0f a8       	ld.ub	r8,r7[0x2]
8000268a:	1a d8       	st.w	--sp,r8
8000268c:	49 4c       	lddpc	r12,800026dc <mic_reply_func+0x7c>
8000268e:	f0 1f 00 12 	mcall	800026d4 <mic_reply_func+0x74>
			log("\n\r Signaling_type: %x \n\r " ,  ptr->Signaling_Type);
80002692:	0f b8       	ld.ub	r8,r7[0x3]
80002694:	1a d8       	st.w	--sp,r8
80002696:	49 3c       	lddpc	r12,800026e0 <mic_reply_func+0x80>
80002698:	f0 1f 00 0f 	mcall	800026d4 <mic_reply_func+0x74>
			log("\n\r Mic_state: %x \n\r " ,  ptr->Mic_State);
8000269c:	0f c8       	ld.ub	r8,r7[0x4]
8000269e:	1a d8       	st.w	--sp,r8
800026a0:	49 1c       	lddpc	r12,800026e4 <mic_reply_func+0x84>
800026a2:	f0 1f 00 0d 	mcall	800026d4 <mic_reply_func+0x74>
			log("\n\r Gain_offset: %x \n\r " ,  ptr->Gain_Offset);
800026a6:	0f d8       	ld.ub	r8,r7[0x5]
800026a8:	1a d8       	st.w	--sp,r8
800026aa:	49 0c       	lddpc	r12,800026e8 <mic_reply_func+0x88>
800026ac:	f0 1f 00 0a 	mcall	800026d4 <mic_reply_func+0x74>
800026b0:	2f cd       	sub	sp,-16
800026b2:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else
		{
			log("\n\r Mic_function: %x \n\r ", ptr->Function );
800026b6:	1a d8       	st.w	--sp,r8
800026b8:	48 dc       	lddpc	r12,800026ec <mic_reply_func+0x8c>
800026ba:	f0 1f 00 07 	mcall	800026d4 <mic_reply_func+0x74>
800026be:	2f fd       	sub	sp,-4
800026c0:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else 
	{
		
	
		log("\n\r Mic error \n\r");
800026c4:	48 bc       	lddpc	r12,800026f0 <mic_reply_func+0x90>
800026c6:	f0 1f 00 04 	mcall	800026d4 <mic_reply_func+0x74>
800026ca:	e3 cd 80 80 	ldm	sp++,r7,pc
800026ce:	00 00       	add	r0,r0
800026d0:	80 01       	ld.sh	r1,r0[0x0]
800026d2:	03 e4       	ld.ub	r4,r1[0x6]
800026d4:	80 00       	ld.sh	r0,r0[0x0]
800026d6:	9a a4       	ld.uh	r4,sp[0x4]
800026d8:	80 01       	ld.sh	r1,r0[0x0]
800026da:	03 f4       	ld.ub	r4,r1[0x7]
800026dc:	80 01       	ld.sh	r1,r0[0x0]
800026de:	04 08       	add	r8,r2
800026e0:	80 01       	ld.sh	r1,r0[0x0]
800026e2:	04 1c       	sub	r12,r2
800026e4:	80 01       	ld.sh	r1,r0[0x0]
800026e6:	04 38       	cp.w	r8,r2
800026e8:	80 01       	ld.sh	r1,r0[0x0]
800026ea:	04 50       	eor	r0,r2
800026ec:	80 01       	ld.sh	r1,r0[0x0]
800026ee:	04 68       	and	r8,r2
800026f0:	80 01       	ld.sh	r1,r0[0x0]
800026f2:	04 80       	andn	r0,r2

800026f4 <dcm_brdcst_func>:
	}
}


void dcm_brdcst_func(xcmp_fragment_t * xcmp)
{
800026f4:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	DeviceControlMode_brdcst_t *ptr = (DeviceControlMode_brdcst_t* )xcmp->u8;
800026f8:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Dcm_brdcst \n\r");		
800026fc:	48 bc       	lddpc	r12,80002728 <dcm_brdcst_func+0x34>
800026fe:	f0 1f 00 0c 	mcall	8000272c <dcm_brdcst_func+0x38>
	log("\n\r Function: %x \n\r " ,  ptr->Function);
80002702:	0f 88       	ld.ub	r8,r7[0x0]
80002704:	1a d8       	st.w	--sp,r8
80002706:	48 bc       	lddpc	r12,80002730 <dcm_brdcst_func+0x3c>
80002708:	f0 1f 00 09 	mcall	8000272c <dcm_brdcst_func+0x38>
	log("\n\r ControlType: %x \n\r " ,  ptr->ControlType);
8000270c:	0f a8       	ld.ub	r8,r7[0x2]
8000270e:	1a d8       	st.w	--sp,r8
80002710:	48 9c       	lddpc	r12,80002734 <dcm_brdcst_func+0x40>
80002712:	f0 1f 00 07 	mcall	8000272c <dcm_brdcst_func+0x38>
	log("\n\r ControlTypeSize: %x \n\r " ,  ptr->ControlTypeSize);
80002716:	0f 98       	ld.ub	r8,r7[0x1]
80002718:	1a d8       	st.w	--sp,r8
8000271a:	48 8c       	lddpc	r12,80002738 <dcm_brdcst_func+0x44>
8000271c:	f0 1f 00 04 	mcall	8000272c <dcm_brdcst_func+0x38>
80002720:	2f dd       	sub	sp,-12
	
	
}
80002722:	e3 cd 80 80 	ldm	sp++,r7,pc
80002726:	00 00       	add	r0,r0
80002728:	80 01       	ld.sh	r1,r0[0x0]
8000272a:	04 90       	mov	r0,r2
8000272c:	80 00       	ld.sh	r0,r0[0x0]
8000272e:	9a a4       	ld.uh	r4,sp[0x4]
80002730:	80 01       	ld.sh	r1,r0[0x0]
80002732:	04 a4       	st.w	r2++,r4
80002734:	80 01       	ld.sh	r1,r0[0x0]
80002736:	04 b8       	st.h	r2++,r8
80002738:	80 01       	ld.sh	r1,r0[0x0]
8000273a:	04 d0       	st.w	--r2,r0

8000273c <dcm_reply_func>:
		log("Tone error");
	}
}

void dcm_reply_func(xcmp_fragment_t * xcmp)
{
8000273c:	eb cd 40 80 	pushm	r7,lr
80002740:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
80002742:	19 a9       	ld.ub	r9,r12[0x2]
80002744:	30 08       	mov	r8,0
80002746:	f0 09 18 00 	cp.b	r9,r8
8000274a:	c1 b1       	brne	80002780 <dcm_reply_func+0x44>
	{
		if(xcmp->u8[1] == DCM_ENTER)
8000274c:	19 b8       	ld.ub	r8,r12[0x3]
8000274e:	30 19       	mov	r9,1
80002750:	f2 08 18 00 	cp.b	r8,r9
80002754:	c0 51       	brne	8000275e <dcm_reply_func+0x22>
		{
			log("\n\r Dcm-Enter OK \n\r");
80002756:	48 ec       	lddpc	r12,8000278c <dcm_reply_func+0x50>
80002758:	f0 1f 00 0e 	mcall	80002790 <dcm_reply_func+0x54>
8000275c:	c0 a8       	rjmp	80002770 <dcm_reply_func+0x34>
			
		}
		else if (xcmp->u8[1] == DCM_EXIT)
8000275e:	58 08       	cp.w	r8,0
80002760:	c0 51       	brne	8000276a <dcm_reply_func+0x2e>
		{
			log("\n\r Dcm-Exit OK \n\r");
80002762:	48 dc       	lddpc	r12,80002794 <dcm_reply_func+0x58>
80002764:	f0 1f 00 0b 	mcall	80002790 <dcm_reply_func+0x54>
80002768:	c0 48       	rjmp	80002770 <dcm_reply_func+0x34>
		}
		else
		{
			log("\n\r Dcm-Revoke \n\r");
8000276a:	48 cc       	lddpc	r12,80002798 <dcm_reply_func+0x5c>
8000276c:	f0 1f 00 09 	mcall	80002790 <dcm_reply_func+0x54>
		}
		
		log("dcm OK-mo%X", xcmp->u8[3]);
80002770:	0f d8       	ld.ub	r8,r7[0x5]
80002772:	1a d8       	st.w	--sp,r8
80002774:	48 ac       	lddpc	r12,8000279c <dcm_reply_func+0x60>
80002776:	f0 1f 00 07 	mcall	80002790 <dcm_reply_func+0x54>
8000277a:	2f fd       	sub	sp,-4
8000277c:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		log("dcm error");
80002780:	48 8c       	lddpc	r12,800027a0 <dcm_reply_func+0x64>
80002782:	f0 1f 00 04 	mcall	80002790 <dcm_reply_func+0x54>
80002786:	e3 cd 80 80 	ldm	sp++,r7,pc
8000278a:	00 00       	add	r0,r0
8000278c:	80 01       	ld.sh	r1,r0[0x0]
8000278e:	04 ec       	st.h	--r2,r12
80002790:	80 00       	ld.sh	r0,r0[0x0]
80002792:	9a a4       	ld.uh	r4,sp[0x4]
80002794:	80 01       	ld.sh	r1,r0[0x0]
80002796:	05 00       	ld.w	r0,r2++
80002798:	80 01       	ld.sh	r1,r0[0x0]
8000279a:	05 14       	ld.sh	r4,r2++
8000279c:	80 01       	ld.sh	r1,r0[0x0]
8000279e:	05 28       	ld.uh	r8,r2++
800027a0:	80 01       	ld.sh	r1,r0[0x0]
800027a2:	05 34       	ld.ub	r4,r2++

800027a4 <ToneControl_reply_func>:
			}
		}
}

void ToneControl_reply_func(xcmp_fragment_t * xcmp)
{
800027a4:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
800027a6:	19 a9       	ld.ub	r9,r12[0x2]
800027a8:	30 08       	mov	r8,0
800027aa:	f0 09 18 00 	cp.b	r9,r8
800027ae:	c0 51       	brne	800027b8 <ToneControl_reply_func+0x14>
	{		
		log("Tone OK");
800027b0:	48 4c       	lddpc	r12,800027c0 <ToneControl_reply_func+0x1c>
800027b2:	f0 1f 00 05 	mcall	800027c4 <ToneControl_reply_func+0x20>
800027b6:	d8 02       	popm	pc
		//fl_write("/test.txt", FILE_END, (void *)"send tone ok\r\n", sizeof("send tone ok\r\n") - 1);
	}
	else
	{
		log("Tone error");
800027b8:	48 4c       	lddpc	r12,800027c8 <ToneControl_reply_func+0x24>
800027ba:	f0 1f 00 03 	mcall	800027c4 <ToneControl_reply_func+0x20>
800027be:	d8 02       	popm	pc
800027c0:	80 01       	ld.sh	r1,r0[0x0]
800027c2:	05 40       	ld.w	r0,--r2
800027c4:	80 00       	ld.sh	r0,r0[0x0]
800027c6:	9a a4       	ld.uh	r4,sp[0x4]
800027c8:	80 01       	ld.sh	r1,r0[0x0]
800027ca:	05 48       	ld.w	r8,--r2

800027cc <app_cfg>:

extern  char AudioData[];
extern U32 tc_tick;

static __app_Thread_(app_cfg)
{
800027cc:	d4 31       	pushm	r0-r7,lr
	static  U32 isAudioRouting = 0;
	static  portTickType xLastWakeTime;
	const portTickType xFrequency = 4000;//2s,2s x  2000hz = 4000
	U8 Burst_ID = 0;
	
	 xLastWakeTime = xTaskGetTickCount();
800027ce:	f0 1f 00 22 	mcall	80002854 <app_cfg+0x88>
800027d2:	4a 28       	lddpc	r8,80002858 <app_cfg+0x8c>
800027d4:	91 0c       	st.w	r8[0x0],r12
		
	for(;;)
	{
		//if((++coun) % 200 ==0)
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003))//
800027d6:	4a 27       	lddpc	r7,8000285c <app_cfg+0x90>
				{
					//xcmp_transmit_dekeycontrol();
					
				}
				
				if(isAudioRouting == 0)
800027d8:	4a 26       	lddpc	r6,80002860 <app_cfg+0x94>
						//
						//
					//}
				//
				//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
				log("\n\r un: %d \n\r", is_unmute);
800027da:	4a 35       	lddpc	r5,80002864 <app_cfg+0x98>
800027dc:	4a 34       	lddpc	r4,80002868 <app_cfg+0x9c>
				//log("\n\r S_flag: %d \n\r", Silent_flag);
				//log("\n\r Tend_flag: %d \n\r", Terminator_Flag);
			
				log("\n\r AMBE_flag: %d \n\r", AMBE_flag);
800027de:	4a 43       	lddpc	r3,8000286c <app_cfg+0xa0>
800027e0:	4a 42       	lddpc	r2,80002870 <app_cfg+0xa4>
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_exit_enhanced_OB_mode();
					//xcmp_mute_speaker();
					//xcmp_enhanced_OB_mode();
					isAudioRouting = 4;
800027e2:	30 41       	mov	r1,4
					//xcmp_button_config();
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//log("\n\r time: %d \n\r", tc_tick);
					
					isAudioRouting = 2;
800027e4:	30 20       	mov	r0,2
	 xLastWakeTime = xTaskGetTickCount();
		
	for(;;)
	{
		//if((++coun) % 200 ==0)
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003))//
800027e6:	6e 08       	ld.w	r8,r7[0x0]
800027e8:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
800027ec:	58 38       	cp.w	r8,3
800027ee:	c2 d1       	brne	80002848 <app_cfg+0x7c>
				{
					//xcmp_transmit_dekeycontrol();
					
				}
				
				if(isAudioRouting == 0)
800027f0:	6c 08       	ld.w	r8,r6[0x0]
800027f2:	58 08       	cp.w	r8,0
800027f4:	c0 61       	brne	80002800 <app_cfg+0x34>
				{
					//xcmp_data_session();
					//xcmp_audio_route_mic();
					//xcmp_button_config();
					//xcmp_audio_route_speaker();
					xcmp_enter_device_control_mode();//3
800027f6:	f0 1f 00 20 	mcall	80002874 <app_cfg+0xa8>
					//xcmp_unmute_speaker();
					
					//is_unmute = 1;
					//xcmp_function_mic();
					
					isAudioRouting = 1;
800027fa:	30 18       	mov	r8,1
800027fc:	8d 08       	st.w	r6[0x0],r8
800027fe:	c1 58       	rjmp	80002828 <app_cfg+0x5c>
				}
				else if(isAudioRouting == 1)
80002800:	58 18       	cp.w	r8,1
80002802:	c0 51       	brne	8000280c <app_cfg+0x40>
				{
					//xcmp_function_mic();
					//xcmp_data_session();
				   // xcmp_transmit_control();
					//xcmp_volume_control();
					xcmp_enter_enhanced_OB_mode();
80002804:	f0 1f 00 1d 	mcall	80002878 <app_cfg+0xac>
					//xcmp_button_config();
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//log("\n\r time: %d \n\r", tc_tick);
					
					isAudioRouting = 2;
80002808:	8d 00       	st.w	r6[0x0],r0
8000280a:	c0 f8       	rjmp	80002828 <app_cfg+0x5c>
					//isAudioRouting++;
				}
				else if(isAudioRouting == 2)
8000280c:	58 28       	cp.w	r8,2
8000280e:	c0 61       	brne	8000281a <app_cfg+0x4e>
				{
					
					//xcmp_volume_control();
					//xcmp_data_session();
					xcmp_audio_route_AMBE();
80002810:	f0 1f 00 1b 	mcall	8000287c <app_cfg+0xb0>
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_mute_speaker();	
					//log("\n\r time: %d \n\r", tc_tick); 
					isAudioRouting = 3;
80002814:	30 38       	mov	r8,3
80002816:	8d 08       	st.w	r6[0x0],r8
80002818:	c0 88       	rjmp	80002828 <app_cfg+0x5c>
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_exit_enhanced_OB_mode();
					//xcmp_mute_speaker();
					//xcmp_enhanced_OB_mode();
					isAudioRouting = 4;
8000281a:	58 38       	cp.w	r8,3
8000281c:	ed f1 0a 00 	st.weq	r6[0x0],r1
					
				}
				else
				{
					isAudioRouting++;
80002820:	f7 b8 01 ff 	subne	r8,-1
80002824:	ed f8 1a 00 	st.wne	r6[0x0],r8
						//
						//
					//}
				//
				//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
				log("\n\r un: %d \n\r", is_unmute);
80002828:	09 88       	ld.ub	r8,r4[0x0]
8000282a:	1a d8       	st.w	--sp,r8
8000282c:	0a 9c       	mov	r12,r5
8000282e:	f0 1f 00 15 	mcall	80002880 <app_cfg+0xb4>
				//log("\n\r S_flag: %d \n\r", Silent_flag);
				//log("\n\r Tend_flag: %d \n\r", Terminator_Flag);
			
				log("\n\r AMBE_flag: %d \n\r", AMBE_flag);
80002832:	05 88       	ld.ub	r8,r2[0x0]
80002834:	1a d8       	st.w	--sp,r8
80002836:	06 9c       	mov	r12,r3
80002838:	f0 1f 00 12 	mcall	80002880 <app_cfg+0xb4>
				//log("\n\r VF_SN: %x \n\r",  VF_SN);
				//log("\n\r time: %d \n\r", tc_tick);
				
				if(isAudioRouting  == 6)
8000283c:	2f ed       	sub	sp,-8
8000283e:	6c 08       	ld.w	r8,r6[0x0]
80002840:	58 68       	cp.w	r8,6
80002842:	c0 31       	brne	80002848 <app_cfg+0x7c>
					
					//xcmp_audio_route_speaker();
					//xcmp_enter_device_control_mode();//3
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					xcmp_exit_device_control_mode();
80002844:	f0 1f 00 10 	mcall	80002884 <app_cfg+0xb8>
			//log("testtime:%d", now->second);
		}
		//vTaskDelay(300*2 / portTICK_RATE_MS);//300ms
		//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
		
		vTaskDelayUntil( &xLastWakeTime, 2000*2 / portTICK_RATE_MS  );//2000ms
80002848:	e0 6b 0f a0 	mov	r11,4000
8000284c:	48 3c       	lddpc	r12,80002858 <app_cfg+0x8c>
8000284e:	f0 1f 00 0f 	mcall	80002888 <app_cfg+0xbc>
	}
80002852:	cc ab       	rjmp	800027e6 <app_cfg+0x1a>
80002854:	80 00       	ld.sh	r0,r0[0x0]
80002856:	94 18       	ld.sh	r8,r10[0x2]
80002858:	00 00       	add	r0,r0
8000285a:	0a 48       	or	r8,r5
8000285c:	00 00       	add	r0,r0
8000285e:	12 cc       	st.b	r9++,r12
80002860:	00 00       	add	r0,r0
80002862:	0a 40       	or	r0,r5
80002864:	80 01       	ld.sh	r1,r0[0x0]
80002866:	05 54       	ld.sh	r4,--r2
80002868:	00 00       	add	r0,r0
8000286a:	0a 4d       	or	sp,r5
8000286c:	80 01       	ld.sh	r1,r0[0x0]
8000286e:	05 64       	ld.uh	r4,--r2
80002870:	00 00       	add	r0,r0
80002872:	0a 44       	or	r4,r5
80002874:	80 00       	ld.sh	r0,r0[0x0]
80002876:	4e 68       	lddpc	r8,80002a0c <SD_LowLevel_Init+0x74>
80002878:	80 00       	ld.sh	r0,r0[0x0]
8000287a:	4e e0       	lddpc	r0,80002a30 <SD_ReadByte+0x20>
8000287c:	80 00       	ld.sh	r0,r0[0x0]
8000287e:	4e 94       	lddpc	r4,80002a20 <SD_ReadByte+0x10>
80002880:	80 00       	ld.sh	r0,r0[0x0]
80002882:	9a a4       	ld.uh	r4,sp[0x4]
80002884:	80 00       	ld.sh	r0,r0[0x0]
80002886:	4e 38       	lddpc	r8,80002a10 <SD_ReadByte>
80002888:	80 00       	ld.sh	r0,r0[0x0]
8000288a:	95 80       	st.w	r10[0x20],r0

8000288c <app_payload_tx_proc>:

}


static void app_payload_tx_proc(void  * payload)
{
8000288c:	eb cd 40 80 	pushm	r7,lr
80002890:	18 97       	mov	r7,r12
  log("R");
80002892:	48 6c       	lddpc	r12,800028a8 <app_payload_tx_proc+0x1c>
80002894:	f0 1f 00 06 	mcall	800028ac <app_payload_tx_proc+0x20>
  //fl_write("voice.dat", FILE_END, payload, MAX_PAYLOAD_BUFF_SIZE * 2);
  
  //vTaskDelay(100);
  
  //payload_fragment_t * ptr = (payload_fragment_t *)payload;
  set_payload_idle(payload);
80002898:	48 68       	lddpc	r8,800028b0 <app_payload_tx_proc+0x24>
8000289a:	70 0c       	ld.w	r12,r8[0x0]
8000289c:	0e 9b       	mov	r11,r7
8000289e:	f0 1f 00 06 	mcall	800028b4 <app_payload_tx_proc+0x28>

//

}
800028a2:	e3 cd 80 80 	ldm	sp++,r7,pc
800028a6:	00 00       	add	r0,r0
800028a8:	80 01       	ld.sh	r1,r0[0x0]
800028aa:	05 78       	ld.ub	r8,--r2
800028ac:	80 00       	ld.sh	r0,r0[0x0]
800028ae:	9a a4       	ld.uh	r4,sp[0x4]
800028b0:	00 00       	add	r0,r0
800028b2:	0f a8       	ld.ub	r8,r7[0x2]
800028b4:	80 00       	ld.sh	r0,r0[0x0]
800028b6:	3a 50       	mov	r0,-91

800028b8 <app_payload_rx_proc>:
	}
}


static void app_payload_rx_proc(void  * payload)
{
800028b8:	eb cd 40 80 	pushm	r7,lr
800028bc:	18 97       	mov	r7,r12
	log("\n\r w: \n\r");
800028be:	49 0c       	lddpc	r12,800028fc <app_payload_rx_proc+0x44>
800028c0:	f0 1f 00 10 	mcall	80002900 <app_payload_rx_proc+0x48>
	if (AMBE_flag)
800028c4:	49 08       	lddpc	r8,80002904 <app_payload_rx_proc+0x4c>
800028c6:	11 89       	ld.ub	r9,r8[0x0]
800028c8:	30 08       	mov	r8,0
800028ca:	f0 09 18 00 	cp.b	r9,r8
800028ce:	c0 90       	breq	800028e0 <app_payload_rx_proc+0x28>
	{
		fl_write("AMBEvo.bit", FILE_END, payload, MAX_PAYLOAD_BUFF_SIZE * 2);
800028d0:	e0 69 02 00 	mov	r9,512
800028d4:	0e 9a       	mov	r10,r7
800028d6:	3f fb       	mov	r11,-1
800028d8:	48 cc       	lddpc	r12,80002908 <app_payload_rx_proc+0x50>
800028da:	f0 1f 00 0d 	mcall	8000290c <app_payload_rx_proc+0x54>
800028de:	c0 88       	rjmp	800028ee <app_payload_rx_proc+0x36>
	}
	else
	{
		fl_write("PCMvo.pcm", FILE_END, payload, MAX_PAYLOAD_BUFF_SIZE * 2);
800028e0:	e0 69 02 00 	mov	r9,512
800028e4:	0e 9a       	mov	r10,r7
800028e6:	3f fb       	mov	r11,-1
800028e8:	48 ac       	lddpc	r12,80002910 <app_payload_rx_proc+0x58>
800028ea:	f0 1f 00 09 	mcall	8000290c <app_payload_rx_proc+0x54>
	}
	
	//payload_fragment_t * ptr = (payload_fragment_t *)payload;
	set_payload_idle(payload);
800028ee:	48 a8       	lddpc	r8,80002914 <app_payload_rx_proc+0x5c>
800028f0:	70 0c       	ld.w	r12,r8[0x0]
800028f2:	0e 9b       	mov	r11,r7
800028f4:	f0 1f 00 09 	mcall	80002918 <app_payload_rx_proc+0x60>

}
800028f8:	e3 cd 80 80 	ldm	sp++,r7,pc
800028fc:	80 01       	ld.sh	r1,r0[0x0]
800028fe:	05 7c       	ld.ub	r12,--r2
80002900:	80 00       	ld.sh	r0,r0[0x0]
80002902:	9a a4       	ld.uh	r4,sp[0x4]
80002904:	00 00       	add	r0,r0
80002906:	0a 44       	or	r4,r5
80002908:	80 01       	ld.sh	r1,r0[0x0]
8000290a:	05 88       	ld.ub	r8,r2[0x0]
8000290c:	80 00       	ld.sh	r0,r0[0x0]
8000290e:	35 38       	mov	r8,83
80002910:	80 01       	ld.sh	r1,r0[0x0]
80002912:	05 94       	ld.ub	r4,r2[0x1]
80002914:	00 00       	add	r0,r0
80002916:	0f a8       	ld.ub	r8,r7[0x2]
80002918:	80 00       	ld.sh	r0,r0[0x0]
8000291a:	3a 50       	mov	r0,-91

8000291c <DeviceInitializationStatus_brdcst_func>:
static void app_payload_tx_proc(void  * payload);

//app func--list

void DeviceInitializationStatus_brdcst_func(xcmp_fragment_t  * xcmp)
{
8000291c:	d4 01       	pushm	lr
	if (xcmp->u8[4] == 0x01)
8000291e:	19 e8       	ld.ub	r8,r12[0x6]
80002920:	30 19       	mov	r9,1
80002922:	f2 08 18 00 	cp.b	r8,r9
80002926:	c0 61       	brne	80002932 <DeviceInitializationStatus_brdcst_func+0x16>
	{
		bunchofrandomstatusflags |= 0x01;  //Need do nothing else.
80002928:	48 98       	lddpc	r8,8000294c <DeviceInitializationStatus_brdcst_func+0x30>
8000292a:	70 09       	ld.w	r9,r8[0x0]
8000292c:	a1 a9       	sbr	r9,0x0
8000292e:	91 09       	st.w	r8[0x0],r9
80002930:	d8 02       	popm	pc
	}
	else if(xcmp->u8[4] != 0x02)
80002932:	30 29       	mov	r9,2
80002934:	f2 08 18 00 	cp.b	r8,r9
80002938:	c0 80       	breq	80002948 <DeviceInitializationStatus_brdcst_func+0x2c>
	{
		bunchofrandomstatusflags  &= 0xFFFFFFFC; //Device Init no longer Complete.
8000293a:	48 58       	lddpc	r8,8000294c <DeviceInitializationStatus_brdcst_func+0x30>
8000293c:	70 09       	ld.w	r9,r8[0x0]
8000293e:	e0 19 ff fc 	andl	r9,0xfffc
80002942:	91 09       	st.w	r8[0x0],r9
		xcmp_DeviceInitializationStatus_request();
80002944:	f0 1f 00 03 	mcall	80002950 <DeviceInitializationStatus_brdcst_func+0x34>
80002948:	d8 02       	popm	pc
8000294a:	00 00       	add	r0,r0
8000294c:	00 00       	add	r0,r0
8000294e:	12 cc       	st.b	r9++,r12
80002950:	80 00       	ld.sh	r0,r0[0x0]
80002952:	4f 04       	lddpc	r4,80002b10 <SD_WriteByte+0x48>

80002954 <SD_SPI_SetSpeed>:
	
}


void SD_SPI_SetSpeed(uint16_t SPI_BaudRatePrescaler)
{
80002954:	d4 01       	pushm	lr
 

	spi->csr0 = (spi->csr0 & (uint16_t)0x00FF) |SPI_BaudRatePrescaler;
80002956:	48 78       	lddpc	r8,80002970 <SD_SPI_SetSpeed+0x1c>
80002958:	70 09       	ld.w	r9,r8[0x0]
8000295a:	72 ca       	ld.w	r10,r9[0x30]
8000295c:	5c 7c       	castu.h	r12
8000295e:	f5 da c0 08 	bfextu	r10,r10,0x0,0x8
80002962:	f9 ea 10 0a 	or	r10,r12,r10
80002966:	93 ca       	st.w	r9[0x30],r10


 
    spi_enable(spi); /*!< SD_SPI enable */
80002968:	70 0c       	ld.w	r12,r8[0x0]
8000296a:	f0 1f 00 03 	mcall	80002974 <SD_SPI_SetSpeed+0x20>
	
 
}
8000296e:	d8 02       	popm	pc
80002970:	00 00       	add	r0,r0
80002972:	12 d0       	st.w	--r9,r0
80002974:	80 00       	ld.sh	r0,r0[0x0]
80002976:	5c 68       	casts.b	r8

80002978 <SD_SPI_SetSpeedHi>:

	
}

void SD_SPI_SetSpeedHi(void)
{
80002978:	d4 01       	pushm	lr

	SD_SPI_SetSpeed(0x0100);//baudDiv=1
8000297a:	e0 6c 01 00 	mov	r12,256
8000297e:	f0 1f 00 02 	mcall	80002984 <SD_SPI_SetSpeedHi+0xc>

}
80002982:	d8 02       	popm	pc
80002984:	80 00       	ld.sh	r0,r0[0x0]
80002986:	29 54       	sub	r4,-107

80002988 <SD_SPI_SetSpeedLow>:
	
 
}

void SD_SPI_SetSpeedLow(void)
{
80002988:	d4 01       	pushm	lr


	SD_SPI_SetSpeed(0xFF00);//baudDiv=255
8000298a:	e0 6c ff 00 	mov	r12,65280
8000298e:	f0 1f 00 02 	mcall	80002994 <SD_SPI_SetSpeedLow+0xc>


	
}
80002992:	d8 02       	popm	pc
80002994:	80 00       	ld.sh	r0,r0[0x0]
80002996:	29 54       	sub	r4,-107

80002998 <SD_LowLevel_Init>:
  * @   SD
  * @   
  * @ 
***------------------------------------------------------*/
void SD_LowLevel_Init(void)
{
80002998:	eb cd 40 c0 	pushm	r6-r7,lr
8000299c:	20 4d       	sub	sp,16
		.spck_delay   = 0,
		.trans_delay  = 0,
		.stay_act     = 1,
		.spi_mode     = 0,
		.modfdis      = 1
	};
8000299e:	49 58       	lddpc	r8,800029f0 <SD_LowLevel_Init+0x58>
800029a0:	1a 96       	mov	r6,sp
800029a2:	f0 ea 00 00 	ld.d	r10,r8[0]
800029a6:	fa eb 00 00 	st.d	sp[0],r10
800029aa:	f0 e8 00 08 	ld.d	r8,r8[8]
800029ae:	fa e9 00 08 	st.d	sp[8],r8

	// Assign I/Os to SPI.
	gpio_enable_module(SD_SPI_GPIO_MAP, sizeof(SD_SPI_GPIO_MAP) / sizeof(SD_SPI_GPIO_MAP[0]));
800029b2:	30 4b       	mov	r11,4
800029b4:	49 0c       	lddpc	r12,800029f4 <SD_LowLevel_Init+0x5c>
800029b6:	f0 1f 00 11 	mcall	800029f8 <SD_LowLevel_Init+0x60>

	spi = &AVR32_SPI;
800029ba:	49 17       	lddpc	r7,800029fc <SD_LowLevel_Init+0x64>
800029bc:	fe 7c 24 00 	mov	r12,-56320
800029c0:	8f 0c       	st.w	r7[0x0],r12

	// Initialize as master.
	spi_initMaster(spi, &spiOptions);
800029c2:	1a 9b       	mov	r11,sp
800029c4:	f0 1f 00 0f 	mcall	80002a00 <SD_LowLevel_Init+0x68>

	// Set selection mode: variable_ps, pcs_decode, delay.
	spi_selectionMode(spi, 0, 0, 0);
800029c8:	30 09       	mov	r9,0
800029ca:	12 9a       	mov	r10,r9
800029cc:	12 9b       	mov	r11,r9
800029ce:	6e 0c       	ld.w	r12,r7[0x0]
800029d0:	f0 1f 00 0d 	mcall	80002a04 <SD_LowLevel_Init+0x6c>

	// Enable SPI.
	spi_enable(spi);
800029d4:	6e 0c       	ld.w	r12,r7[0x0]
800029d6:	f0 1f 00 0d 	mcall	80002a08 <SD_LowLevel_Init+0x70>

	// Initialize data flash with SPI clock PBA.
	if (spi_setupChipReg(spi, &spiOptions, SPI_Clock_PBA) != SPI_OK)
800029da:	e0 6a 36 00 	mov	r10,13824
800029de:	ea 1a 01 6e 	orh	r10,0x16e
800029e2:	1a 9b       	mov	r11,sp
800029e4:	6e 0c       	ld.w	r12,r7[0x0]
800029e6:	f0 1f 00 0a 	mcall	80002a0c <SD_LowLevel_Init+0x74>
	return;
	}


	
}
800029ea:	2f cd       	sub	sp,-16
800029ec:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800029f0:	80 01       	ld.sh	r1,r0[0x0]
800029f2:	05 b4       	ld.ub	r4,r2[0x3]
800029f4:	80 01       	ld.sh	r1,r0[0x0]
800029f6:	05 c4       	ld.ub	r4,r2[0x4]
800029f8:	80 00       	ld.sh	r0,r0[0x0]
800029fa:	9f 44       	st.w	pc[0x10],r4
800029fc:	00 00       	add	r0,r0
800029fe:	12 d0       	st.w	--r9,r0
80002a00:	80 00       	ld.sh	r0,r0[0x0]
80002a02:	5a d0       	cp.w	r0,-19
80002a04:	80 00       	ld.sh	r0,r0[0x0]
80002a06:	5b 08       	cp.w	r8,-16
80002a08:	80 00       	ld.sh	r0,r0[0x0]
80002a0a:	5c 68       	casts.b	r8
80002a0c:	80 00       	ld.sh	r0,r0[0x0]
80002a0e:	5b a6       	cp.w	r6,-6

80002a10 <SD_ReadByte>:
  * @   SD
  * @    
  * @  The received byte
***------------------------------------------------------*/  
uint8_t SD_ReadByte(void)
{
80002a10:	eb cd 40 c0 	pushm	r6-r7,lr
  unsigned short *Data ;

  //
  spi_selectChip(spi, SD_SPI_PCS_0);
80002a14:	48 b7       	lddpc	r7,80002a40 <SD_ReadByte+0x30>
80002a16:	30 0b       	mov	r11,0
80002a18:	6e 0c       	ld.w	r12,r7[0x0]
80002a1a:	f0 1f 00 0b 	mcall	80002a44 <SD_ReadByte+0x34>
  
  /*!< Send the byte */

  spi_write(spi,  SD_DUMMY_BYTE);
80002a1e:	e0 6b 00 ff 	mov	r11,255
80002a22:	6e 0c       	ld.w	r12,r7[0x0]
80002a24:	f0 1f 00 09 	mcall	80002a48 <SD_ReadByte+0x38>
  
  /*!< Return the byte read from the SPI bus */ 

   spi_read(spi, Data);
80002a28:	30 06       	mov	r6,0
80002a2a:	0c 9b       	mov	r11,r6
80002a2c:	6e 0c       	ld.w	r12,r7[0x0]
80002a2e:	f0 1f 00 08 	mcall	80002a4c <SD_ReadByte+0x3c>

  /*!< Return the shifted data */
  
  spi_unselectChip(spi, SD_SPI_PCS_0);
80002a32:	0c 9b       	mov	r11,r6
80002a34:	6e 0c       	ld.w	r12,r7[0x0]
80002a36:	f0 1f 00 07 	mcall	80002a50 <SD_ReadByte+0x40>
  
  return (uint8_t)(*Data);//
}
80002a3a:	0d 9c       	ld.ub	r12,r6[0x1]
80002a3c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002a40:	00 00       	add	r0,r0
80002a42:	12 d0       	st.w	--r9,r0
80002a44:	80 00       	ld.sh	r0,r0[0x0]
80002a46:	5b 34       	cp.w	r4,-13
80002a48:	80 00       	ld.sh	r0,r0[0x0]
80002a4a:	5c 6e       	casts.b	lr
80002a4c:	80 00       	ld.sh	r0,r0[0x0]
80002a4e:	5c 8a       	casts.h	r10
80002a50:	80 00       	ld.sh	r0,r0[0x0]
80002a52:	5b 80       	cp.w	r0,-8

80002a54 <SD_GetResponse>:
  * @retval The SD Response: 
  *         - SD_RESPONSE_FAILURE: Sequence failed
  *         - SD_RESPONSE_NO_ERROR: Sequence succeed
  */
SD_Error SD_GetResponse(uint8_t Response)
{
80002a54:	eb cd 40 c0 	pushm	r6-r7,lr
80002a58:	18 96       	mov	r6,r12
80002a5a:	e0 67 8f ff 	mov	r7,36863
  uint32_t Count = 0x8FFF;

  /*!< Check if response is got or a timeout is happen */
  while ((SD_ReadByte() != Response) && Count)
80002a5e:	c0 28       	rjmp	80002a62 <SD_GetResponse+0xe>
  {
    Count--;
80002a60:	20 17       	sub	r7,1
SD_Error SD_GetResponse(uint8_t Response)
{
  uint32_t Count = 0x8FFF;

  /*!< Check if response is got or a timeout is happen */
  while ((SD_ReadByte() != Response) && Count)
80002a62:	f0 1f 00 09 	mcall	80002a84 <SD_GetResponse+0x30>
80002a66:	ec 0c 18 00 	cp.b	r12,r6
80002a6a:	c0 40       	breq	80002a72 <SD_GetResponse+0x1e>
80002a6c:	58 07       	cp.w	r7,0
80002a6e:	cf 91       	brne	80002a60 <SD_GetResponse+0xc>
80002a70:	c0 58       	rjmp	80002a7a <SD_GetResponse+0x26>
  {
    Count--;
  }
  if (Count == 0)
80002a72:	58 07       	cp.w	r7,0
80002a74:	c0 30       	breq	80002a7a <SD_GetResponse+0x26>
80002a76:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
80002a7a:	e0 6c 00 ff 	mov	r12,255
  else
  {
    /*!< Right response got */
    return SD_RESPONSE_NO_ERROR;
  }
}
80002a7e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002a82:	00 00       	add	r0,r0
80002a84:	80 00       	ld.sh	r0,r0[0x0]
80002a86:	2a 10       	sub	r0,-95

80002a88 <SD_GetDataResponse>:
  *         - status 101: Data rejected due to a crc error
  *         - status 110: Data rejected due to a Write error.
  *         - status 111: Data rejected due to other error.
  */
uint8_t SD_GetDataResponse(void)
{
80002a88:	eb cd 40 f8 	pushm	r3-r7,lr
80002a8c:	30 06       	mov	r6,0
  {
    /*!< Read resonse */
    response = SD_ReadByte();
    /*!< Mask unused bits */
    response &= 0x1F;
    switch (response)
80002a8e:	30 b5       	mov	r5,11
80002a90:	30 d4       	mov	r4,13
80002a92:	30 53       	mov	r3,5
  uint8_t response, rvalue;

  while (i <= 64)
  {
    /*!< Read resonse */
    response = SD_ReadByte();
80002a94:	f0 1f 00 0c 	mcall	80002ac4 <SD_GetDataResponse+0x3c>
    /*!< Mask unused bits */
    response &= 0x1F;
80002a98:	ef dc c0 05 	bfextu	r7,r12,0x0,0x5
    switch (response)
80002a9c:	ea 07 18 00 	cp.b	r7,r5
80002aa0:	c0 e0       	breq	80002abc <SD_GetDataResponse+0x34>
80002aa2:	e8 07 18 00 	cp.b	r7,r4
80002aa6:	c0 b0       	breq	80002abc <SD_GetDataResponse+0x34>
80002aa8:	e6 07 18 00 	cp.b	r7,r3
80002aac:	c0 50       	breq	80002ab6 <SD_GetDataResponse+0x2e>
    }
    /*!< Exit loop in case of data ok */
    if (rvalue == SD_DATA_OK)
      break;
    /*!< Increment loop counter */
    i++;
80002aae:	2f f6       	sub	r6,-1
uint8_t SD_GetDataResponse(void)
{
  uint32_t i = 0;
  uint8_t response, rvalue;

  while (i <= 64)
80002ab0:	e0 46 00 41 	cp.w	r6,65
80002ab4:	cf 01       	brne	80002a94 <SD_GetDataResponse+0xc>
    /*!< Increment loop counter */
    i++;
  }

  /*!< Wait null data */
  while (SD_ReadByte() == 0);
80002ab6:	f0 1f 00 04 	mcall	80002ac4 <SD_GetDataResponse+0x3c>
80002aba:	cf e0       	breq	80002ab6 <SD_GetDataResponse+0x2e>

  /*!< Return response */
  return response;
}
80002abc:	0e 9c       	mov	r12,r7
80002abe:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80002ac2:	00 00       	add	r0,r0
80002ac4:	80 00       	ld.sh	r0,r0[0x0]
80002ac6:	2a 10       	sub	r0,-95

80002ac8 <SD_WriteByte>:
  * @brief  Write a byte on the SD.
  * @param  Data: byte to send.
  * @retval None
  */
uint8_t SD_WriteByte(uint8_t Data)
{
80002ac8:	eb cd 40 c0 	pushm	r6-r7,lr
80002acc:	20 1d       	sub	sp,4
80002ace:	ba 8c       	st.b	sp[0x0],r12
  uint8_t temp;
  
  //
  spi_selectChip(spi, SD_SPI_PCS_0);
80002ad0:	48 c7       	lddpc	r7,80002b00 <SD_WriteByte+0x38>
80002ad2:	30 0b       	mov	r11,0
80002ad4:	6e 0c       	ld.w	r12,r7[0x0]
80002ad6:	f0 1f 00 0c 	mcall	80002b04 <SD_WriteByte+0x3c>
  
  /*!< Send the byte */
  spi_write(spi,  (U16)Data);
80002ada:	1b 8b       	ld.ub	r11,sp[0x0]
80002adc:	6e 0c       	ld.w	r12,r7[0x0]
80002ade:	f0 1f 00 0b 	mcall	80002b08 <SD_WriteByte+0x40>
  

  /*!< Wait to receive a byte*/

  temp = spi_read(spi, (U16*)&Data);
80002ae2:	1a 9b       	mov	r11,sp
80002ae4:	6e 0c       	ld.w	r12,r7[0x0]
80002ae6:	f0 1f 00 0a 	mcall	80002b0c <SD_WriteByte+0x44>
80002aea:	18 96       	mov	r6,r12
  
  spi_unselectChip(spi, SD_SPI_PCS_0);
80002aec:	30 0b       	mov	r11,0
80002aee:	6e 0c       	ld.w	r12,r7[0x0]
80002af0:	f0 1f 00 08 	mcall	80002b10 <SD_WriteByte+0x48>
  
  /*!< Return the byte read from the SPI bus */ 
  return  temp;
    
}
80002af4:	f9 d6 c0 08 	bfextu	r12,r6,0x0,0x8
80002af8:	2f fd       	sub	sp,-4
80002afa:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002afe:	00 00       	add	r0,r0
80002b00:	00 00       	add	r0,r0
80002b02:	12 d0       	st.w	--r9,r0
80002b04:	80 00       	ld.sh	r0,r0[0x0]
80002b06:	5b 34       	cp.w	r4,-13
80002b08:	80 00       	ld.sh	r0,r0[0x0]
80002b0a:	5c 6e       	casts.b	lr
80002b0c:	80 00       	ld.sh	r0,r0[0x0]
80002b0e:	5c 8a       	casts.h	r10
80002b10:	80 00       	ld.sh	r0,r0[0x0]
80002b12:	5b 80       	cp.w	r0,-8

80002b14 <SD_SendCmd>:
  * @param  Arg: 
  * @param  Crc: CRC
  * @retval None
  */
void SD_SendCmd(uint8_t Cmd, uint32_t Arg, uint8_t Crc)
{
80002b14:	eb cd 40 c0 	pushm	r6-r7,lr
80002b18:	20 2d       	sub	sp,8
  uint32_t i = 0x00;
  
  uint8_t Frame[6];

  Frame[0] = (Cmd | 0x40); /*!< Construct byte 1 */
80002b1a:	a7 ac       	sbr	r12,0x6
80002b1c:	ba 8c       	st.b	sp[0x0],r12
  
  Frame[1] = (uint8_t)(Arg >> 24); /*!< Construct byte 2 */
80002b1e:	f6 08 16 18 	lsr	r8,r11,0x18
80002b22:	ba 98       	st.b	sp[0x1],r8
  
  Frame[2] = (uint8_t)(Arg >> 16); /*!< Construct byte 3 */
80002b24:	f6 08 16 10 	lsr	r8,r11,0x10
80002b28:	ba a8       	st.b	sp[0x2],r8
  
  Frame[3] = (uint8_t)(Arg >> 8); /*!< Construct byte 4 */
80002b2a:	f6 08 16 08 	lsr	r8,r11,0x8
80002b2e:	ba b8       	st.b	sp[0x3],r8
  
  Frame[4] = (uint8_t)(Arg); /*!< Construct byte 5 */
80002b30:	ba cb       	st.b	sp[0x4],r11
  
  Frame[5] = (Crc); /*!< Construct CRC: byte 6 */
80002b32:	ba da       	st.b	sp[0x5],r10
80002b34:	1a 97       	mov	r7,sp
  * @param  Cmd: .
  * @param  Arg: 
  * @param  Crc: CRC
  * @retval None
  */
void SD_SendCmd(uint8_t Cmd, uint32_t Arg, uint8_t Crc)
80002b36:	fa c6 ff fa 	sub	r6,sp,-6
  Frame[5] = (Crc); /*!< Construct CRC: byte 6 */
  
  for (i = 0; i < 6; i++)
  {

	SD_WriteByte(Frame[i]); /*!< Send the Cmd bytes */
80002b3a:	0f 3c       	ld.ub	r12,r7++
80002b3c:	f0 1f 00 04 	mcall	80002b4c <SD_SendCmd+0x38>
  
  Frame[4] = (uint8_t)(Arg); /*!< Construct byte 5 */
  
  Frame[5] = (Crc); /*!< Construct CRC: byte 6 */
  
  for (i = 0; i < 6; i++)
80002b40:	0c 37       	cp.w	r7,r6
80002b42:	cf c1       	brne	80002b3a <SD_SendCmd+0x26>
  {

	SD_WriteByte(Frame[i]); /*!< Send the Cmd bytes */

  }
}
80002b44:	2f ed       	sub	sp,-8
80002b46:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002b4a:	00 00       	add	r0,r0
80002b4c:	80 00       	ld.sh	r0,r0[0x0]
80002b4e:	2a c8       	sub	r8,-84

80002b50 <SD_GoIdleState>:
  * @   SD
  * @    
  * @  
***------------------------------------------------------*/
SD_Error SD_GoIdleState(void)
{
80002b50:	d4 31       	pushm	r0-r7,lr
  uint8_t r1;
  SD_Error Status = SD_RESPONSE_NO_ERROR;
  uint16_t n2,n;

  /* CS */
  SD_CS_LOW();
80002b52:	31 8c       	mov	r12,24
80002b54:	f0 1f 00 6a 	mcall	80002cfc <SD_GoIdleState+0x1ac>
  
  /* CM0SDSPI */
  SD_SendCmd(SD_CMD_GO_IDLE_STATE, 0, 0x95);
80002b58:	e0 6a 00 95 	mov	r10,149
80002b5c:	30 0b       	mov	r11,0
80002b5e:	16 9c       	mov	r12,r11
80002b60:	f0 1f 00 68 	mcall	80002d00 <SD_GoIdleState+0x1b0>
  
  /* 0x01 */
  if (SD_GetResponse  (SD_IN_IDLE_STATE))
80002b64:	30 1c       	mov	r12,1
80002b66:	f0 1f 00 68 	mcall	80002d04 <SD_GoIdleState+0x1b4>
80002b6a:	e0 81 00 a8 	brne	80002cba <SD_GoIdleState+0x16a>
    return SD_RESPONSE_FAILURE;
  }

  
  /*CMD8*/
  SD_SendCmd(8, 0x1AA, 0x87);
80002b6e:	e0 6a 00 87 	mov	r10,135
80002b72:	e0 6b 01 aa 	mov	r11,426
80002b76:	30 8c       	mov	r12,8
80002b78:	f0 1f 00 62 	mcall	80002d00 <SD_GoIdleState+0x1b0>
80002b7c:	e0 67 00 c8 	mov	r7,200

  /*  */
  TimeOut = 200;
  while (((r1 = SD_ReadByte()) == 0xFF) && TimeOut)
80002b80:	3f f6       	mov	r6,-1
80002b82:	c0 38       	rjmp	80002b88 <SD_GoIdleState+0x38>
  {
    TimeOut--;
80002b84:	20 17       	sub	r7,1
80002b86:	5c 87       	casts.h	r7
  /*CMD8*/
  SD_SendCmd(8, 0x1AA, 0x87);

  /*  */
  TimeOut = 200;
  while (((r1 = SD_ReadByte()) == 0xFF) && TimeOut)
80002b88:	f0 1f 00 60 	mcall	80002d08 <SD_GoIdleState+0x1b8>
80002b8c:	ec 0c 18 00 	cp.b	r12,r6
80002b90:	c0 41       	brne	80002b98 <SD_GoIdleState+0x48>
80002b92:	58 07       	cp.w	r7,0
80002b94:	cf 81       	brne	80002b84 <SD_GoIdleState+0x34>
80002b96:	c2 68       	rjmp	80002be2 <SD_GoIdleState+0x92>
  {
    TimeOut--;
  }

  if(r1 == 0x05) 
80002b98:	30 58       	mov	r8,5
80002b9a:	f0 0c 18 00 	cp.b	r12,r8
80002b9e:	c2 21       	brne	80002be2 <SD_GoIdleState+0x92>
80002ba0:	c9 48       	rjmp	80002cc8 <SD_GoIdleState+0x178>
    TimeOut = 0;
    /*----------SD-----------*/
    do
    {
      /* CS*/
      SD_CS_HIGH();
80002ba2:	08 9c       	mov	r12,r4
80002ba4:	f0 1f 00 5a 	mcall	80002d0c <SD_GoIdleState+0x1bc>
      
      /* 0xFF */
      SD_WriteByte(SD_DUMMY_BYTE);
80002ba8:	06 9c       	mov	r12,r3
80002baa:	f0 1f 00 5a 	mcall	80002d10 <SD_GoIdleState+0x1c0>
      
      /* CS */
      SD_CS_LOW();
80002bae:	08 9c       	mov	r12,r4
80002bb0:	f0 1f 00 53 	mcall	80002cfc <SD_GoIdleState+0x1ac>
      
      /* CMD10x00*/
      SD_SendCmd(SD_CMD_SEND_OP_COND, 0, 0xFF);
80002bb4:	06 9a       	mov	r10,r3
80002bb6:	0a 9b       	mov	r11,r5
80002bb8:	02 9c       	mov	r12,r1
80002bba:	f0 1f 00 52 	mcall	80002d00 <SD_GoIdleState+0x1b0>
      /* error Response0x00 */
      TimeOut++;
80002bbe:	2f f6       	sub	r6,-1
80002bc0:	5c 86       	casts.h	r6
    
      if(TimeOut == 0x00F0)
80002bc2:	e4 06 19 00 	cp.h	r6,r2
80002bc6:	c0 60       	breq	80002bd2 <SD_GoIdleState+0x82>
      {
        break;
      }
  	
  	Status = SD_GetResponse(SD_RESPONSE_NO_ERROR);	
80002bc8:	0a 9c       	mov	r12,r5
80002bca:	f0 1f 00 4f 	mcall	80002d04 <SD_GoIdleState+0x1b4>
80002bce:	18 97       	mov	r7,r12
    }
    while (Status);
80002bd0:	ce 91       	brne	80002ba2 <SD_GoIdleState+0x52>
    
    /* CS */
    SD_CS_HIGH();
80002bd2:	31 8c       	mov	r12,24
80002bd4:	f0 1f 00 4e 	mcall	80002d0c <SD_GoIdleState+0x1bc>
    
    /*dummy byte 0xFF */
    SD_WriteByte(SD_DUMMY_BYTE);    
80002bd8:	e0 6c 00 ff 	mov	r12,255
80002bdc:	f0 1f 00 4d 	mcall	80002d10 <SD_GoIdleState+0x1c0>
80002be0:	c6 f8       	rjmp	80002cbe <SD_GoIdleState+0x16e>
    r1 = 1;

    /* SD5 */
    for(n=0; n<5; n++)
    {
      SD_ReadByte();
80002be2:	f0 1f 00 4a 	mcall	80002d08 <SD_GoIdleState+0x1b8>
80002be6:	f0 1f 00 49 	mcall	80002d08 <SD_GoIdleState+0x1b8>
80002bea:	f0 1f 00 48 	mcall	80002d08 <SD_GoIdleState+0x1b8>
80002bee:	f0 1f 00 47 	mcall	80002d08 <SD_GoIdleState+0x1b8>
80002bf2:	f0 1f 00 46 	mcall	80002d08 <SD_GoIdleState+0x1b8>
    }
  
    /* CS */
    SD_CS_HIGH();
80002bf6:	31 8c       	mov	r12,24
80002bf8:	f0 1f 00 45 	mcall	80002d0c <SD_GoIdleState+0x1bc>
    SD_WriteByte(SD_DUMMY_BYTE);
80002bfc:	e0 6c 00 ff 	mov	r12,255
80002c00:	f0 1f 00 44 	mcall	80002d10 <SD_GoIdleState+0x1c0>
    /* CS */
    SD_CS_LOW();
80002c04:	31 8c       	mov	r12,24
80002c06:	f0 1f 00 3e 	mcall	80002cfc <SD_GoIdleState+0x1ac>
    SD_WriteByte(SD_DUMMY_BYTE);
80002c0a:	e0 6c 00 ff 	mov	r12,255
80002c0e:	f0 1f 00 41 	mcall	80002d10 <SD_GoIdleState+0x1c0>
    SD_WriteByte(SD_DUMMY_BYTE);
80002c12:	e0 6c 00 ff 	mov	r12,255
80002c16:	f0 1f 00 3f 	mcall	80002d10 <SD_GoIdleState+0x1c0>
80002c1a:	e0 64 00 ff 	mov	r4,255
    n=0xff;
  
    do
    {
	  /* CMD55 */
      SD_SendCmd(55, 0, 0xFF);
80002c1e:	08 91       	mov	r1,r4
80002c20:	30 02       	mov	r2,0
      for(n2=0; n2<0x08;n2++)
      {
       r1= SD_ReadByte();
       if(r1 !=1)
80002c22:	30 15       	mov	r5,1
  
    do
    {
	  /* CMD55 */
      SD_SendCmd(55, 0, 0xFF);
      for(n2=0; n2<0x08;n2++)
80002c24:	30 83       	mov	r3,8

      }
	   /* CMD41 */
      SD_SendCmd(41, 0x40000000, 0);
  
      for(n2=0; n2<0xff;n2++)
80002c26:	e0 66 00 ff 	mov	r6,255
    n=0xff;
  
    do
    {
	  /* CMD55 */
      SD_SendCmd(55, 0, 0xFF);
80002c2a:	02 9a       	mov	r10,r1
80002c2c:	04 9b       	mov	r11,r2
80002c2e:	33 7c       	mov	r12,55
80002c30:	f0 1f 00 34 	mcall	80002d00 <SD_GoIdleState+0x1b0>
80002c34:	04 97       	mov	r7,r2
      for(n2=0; n2<0x08;n2++)
      {
       r1= SD_ReadByte();
80002c36:	f0 1f 00 35 	mcall	80002d08 <SD_GoIdleState+0x1b8>
       if(r1 !=1)
80002c3a:	f8 05 18 00 	cp.b	r5,r12
80002c3e:	f9 b4 01 00 	movne	r4,0
  
    do
    {
	  /* CMD55 */
      SD_SendCmd(55, 0, 0xFF);
      for(n2=0; n2<0x08;n2++)
80002c42:	2f f7       	sub	r7,-1
80002c44:	5c 87       	casts.h	r7
80002c46:	e6 07 19 00 	cp.h	r7,r3
80002c4a:	cf 61       	brne	80002c36 <SD_GoIdleState+0xe6>
80002c4c:	08 90       	mov	r0,r4
80002c4e:	5c 80       	casts.h	r0
		   n=0;
	   }

      }
	   /* CMD41 */
      SD_SendCmd(41, 0x40000000, 0);
80002c50:	04 9a       	mov	r10,r2
80002c52:	fc 1b 40 00 	movh	r11,0x4000
80002c56:	32 9c       	mov	r12,41
80002c58:	f0 1f 00 2a 	mcall	80002d00 <SD_GoIdleState+0x1b0>
80002c5c:	04 97       	mov	r7,r2
  
      for(n2=0; n2<0xff;n2++)
      {
       r1= SD_ReadByte();
80002c5e:	f0 1f 00 2b 	mcall	80002d08 <SD_GoIdleState+0x1b8>
       if(r1 ==0)break;
80002c62:	c3 00       	breq	80002cc2 <SD_GoIdleState+0x172>

      }
	   /* CMD41 */
      SD_SendCmd(41, 0x40000000, 0);
  
      for(n2=0; n2<0xff;n2++)
80002c64:	2f f7       	sub	r7,-1
80002c66:	5c 87       	casts.h	r7
80002c68:	ec 07 19 00 	cp.h	r7,r6
80002c6c:	cf 91       	brne	80002c5e <SD_GoIdleState+0x10e>
      {
       r1= SD_ReadByte();
       if(r1 ==0)break;
      }
      n--;
80002c6e:	e0 c4 00 01 	sub	r4,r0,1
80002c72:	5c 84       	casts.h	r4
    }while((r1!=0)&&(n>0));
80002c74:	30 08       	mov	r8,0
80002c76:	f0 0c 18 00 	cp.b	r12,r8
80002c7a:	5f 1a       	srne	r10
80002c7c:	30 09       	mov	r9,0
80002c7e:	f2 04 19 00 	cp.h	r4,r9
80002c82:	5f 19       	srne	r9
80002c84:	f5 e9 00 09 	and	r9,r10,r9
80002c88:	f0 09 18 00 	cp.b	r9,r8
80002c8c:	cc f1       	brne	80002c2a <SD_GoIdleState+0xda>

    if(n==0)
80002c8e:	58 04       	cp.w	r4,0
80002c90:	c1 50       	breq	80002cba <SD_GoIdleState+0x16a>
      //printf("\r\n SDHC\n");
    }
    else
    {
	  /* CMD58 */
      SD_SendCmd(58, 0, 0);
80002c92:	30 0a       	mov	r10,0
80002c94:	14 9b       	mov	r11,r10
80002c96:	33 ac       	mov	r12,58
80002c98:	f0 1f 00 1a 	mcall	80002d00 <SD_GoIdleState+0x1b0>
      for(n=0;n<5;n++)
      {
      r1 = SD_ReadByte();
80002c9c:	f0 1f 00 1b 	mcall	80002d08 <SD_GoIdleState+0x1b8>
80002ca0:	f0 1f 00 1a 	mcall	80002d08 <SD_GoIdleState+0x1b8>
80002ca4:	f0 1f 00 19 	mcall	80002d08 <SD_GoIdleState+0x1b8>
80002ca8:	f0 1f 00 18 	mcall	80002d08 <SD_GoIdleState+0x1b8>
80002cac:	f0 1f 00 17 	mcall	80002d08 <SD_GoIdleState+0x1b8>
      }
	  flag_SDHC = 1;
80002cb0:	30 19       	mov	r9,1
80002cb2:	49 98       	lddpc	r8,80002d14 <SD_GoIdleState+0x1c4>
80002cb4:	b0 89       	st.b	r8[0x0],r9
80002cb6:	30 07       	mov	r7,0
80002cb8:	c0 38       	rjmp	80002cbe <SD_GoIdleState+0x16e>
80002cba:	e0 67 00 ff 	mov	r7,255
    //printf("\n\r SD cards inint Done.");
  }  
  */
    
  return Status;
}
80002cbe:	0e 9c       	mov	r12,r7
80002cc0:	d8 32       	popm	r0-r7,pc
      for(n2=0; n2<0xff;n2++)
      {
       r1= SD_ReadByte();
       if(r1 ==0)break;
      }
      n--;
80002cc2:	20 14       	sub	r4,1
80002cc4:	5c 84       	casts.h	r4
80002cc6:	ce 4b       	rjmp	80002c8e <SD_GoIdleState+0x13e>
    TimeOut = 0;
    /*----------SD-----------*/
    do
    {
      /* CS*/
      SD_CS_HIGH();
80002cc8:	31 8c       	mov	r12,24
80002cca:	f0 1f 00 11 	mcall	80002d0c <SD_GoIdleState+0x1bc>
      
      /* 0xFF */
      SD_WriteByte(SD_DUMMY_BYTE);
80002cce:	e0 6c 00 ff 	mov	r12,255
80002cd2:	f0 1f 00 10 	mcall	80002d10 <SD_GoIdleState+0x1c0>
      
      /* CS */
      SD_CS_LOW();
80002cd6:	31 8c       	mov	r12,24
80002cd8:	f0 1f 00 09 	mcall	80002cfc <SD_GoIdleState+0x1ac>
      
      /* CMD10x00*/
      SD_SendCmd(SD_CMD_SEND_OP_COND, 0, 0xFF);
80002cdc:	e0 6a 00 ff 	mov	r10,255
80002ce0:	30 0b       	mov	r11,0
80002ce2:	30 1c       	mov	r12,1
80002ce4:	f0 1f 00 07 	mcall	80002d00 <SD_GoIdleState+0x1b0>
80002ce8:	30 16       	mov	r6,1
      if(TimeOut == 0x00F0)
      {
        break;
      }
  	
  	Status = SD_GetResponse(SD_RESPONSE_NO_ERROR);	
80002cea:	30 05       	mov	r5,0
    TimeOut = 0;
    /*----------SD-----------*/
    do
    {
      /* CS*/
      SD_CS_HIGH();
80002cec:	31 84       	mov	r4,24
      
      /* 0xFF */
      SD_WriteByte(SD_DUMMY_BYTE);
80002cee:	e0 63 00 ff 	mov	r3,255
      
      /* CS */
      SD_CS_LOW();
      
      /* CMD10x00*/
      SD_SendCmd(SD_CMD_SEND_OP_COND, 0, 0xFF);
80002cf2:	0c 91       	mov	r1,r6
      /* error Response0x00 */
      TimeOut++;
    
      if(TimeOut == 0x00F0)
80002cf4:	e0 62 00 f0 	mov	r2,240
80002cf8:	c6 8b       	rjmp	80002bc8 <SD_GoIdleState+0x78>
80002cfa:	00 00       	add	r0,r0
80002cfc:	80 00       	ld.sh	r0,r0[0x0]
80002cfe:	9f 90       	st.w	pc[0x24],r0
80002d00:	80 00       	ld.sh	r0,r0[0x0]
80002d02:	2b 14       	sub	r4,-79
80002d04:	80 00       	ld.sh	r0,r0[0x0]
80002d06:	2a 54       	sub	r4,-91
80002d08:	80 00       	ld.sh	r0,r0[0x0]
80002d0a:	2a 10       	sub	r0,-95
80002d0c:	80 00       	ld.sh	r0,r0[0x0]
80002d0e:	9f 74       	st.w	pc[0x1c],r4
80002d10:	80 00       	ld.sh	r0,r0[0x0]
80002d12:	2a c8       	sub	r8,-84
80002d14:	00 00       	add	r0,r0
80002d16:	0a 68       	and	r8,r5

80002d18 <SD_GetCIDRegister>:
  * @retval The SD Response: 
  *         - SD_RESPONSE_FAILURE: Sequence failed
  *         - SD_RESPONSE_NO_ERROR: Sequence succeed
  */
SD_Error SD_GetCIDRegister(SD_CID* SD_cid)
{
80002d18:	eb cd 40 e0 	pushm	r5-r7,lr
80002d1c:	20 4d       	sub	sp,16
80002d1e:	18 97       	mov	r7,r12
  uint32_t i = 0;
  SD_Error rvalue = SD_RESPONSE_FAILURE;
  uint8_t CID_Tab[16];
  
  /*!< SD chip select low */
  SD_CS_LOW();
80002d20:	31 8c       	mov	r12,24
80002d22:	f0 1f 00 44 	mcall	80002e30 <SD_GetCIDRegister+0x118>
  
  /*!< Send CMD10 (CID register) */
  SD_SendCmd(SD_CMD_SEND_CID, 0, 0xFF);
80002d26:	e0 6a 00 ff 	mov	r10,255
80002d2a:	30 0b       	mov	r11,0
80002d2c:	30 ac       	mov	r12,10
80002d2e:	f0 1f 00 42 	mcall	80002e34 <SD_GetCIDRegister+0x11c>
  
  /*!< Wait for response in the R1 format (0x00 is no errors) */
  if (!SD_GetResponse(SD_RESPONSE_NO_ERROR))
80002d32:	30 0c       	mov	r12,0
80002d34:	f0 1f 00 41 	mcall	80002e38 <SD_GetCIDRegister+0x120>
80002d38:	c0 40       	breq	80002d40 <SD_GetCIDRegister+0x28>
80002d3a:	e0 66 00 ff 	mov	r6,255
80002d3e:	c1 78       	rjmp	80002d6c <SD_GetCIDRegister+0x54>
  {
    if (!SD_GetResponse(SD_START_DATA_SINGLE_BLOCK_READ))
80002d40:	e0 6c 00 fe 	mov	r12,254
80002d44:	f0 1f 00 3d 	mcall	80002e38 <SD_GetCIDRegister+0x120>
80002d48:	c0 91       	brne	80002d5a <SD_GetCIDRegister+0x42>
80002d4a:	1a 96       	mov	r6,sp
  * @param  SD_cid: pointer on an CID register structure
  * @retval The SD Response: 
  *         - SD_RESPONSE_FAILURE: Sequence failed
  *         - SD_RESPONSE_NO_ERROR: Sequence succeed
  */
SD_Error SD_GetCIDRegister(SD_CID* SD_cid)
80002d4c:	fa c5 ff f0 	sub	r5,sp,-16
    if (!SD_GetResponse(SD_START_DATA_SINGLE_BLOCK_READ))
    {
      /*!< Store CID register value on CID_Tab */
      for (i = 0; i < 16; i++)
      {
        CID_Tab[i] = SD_ReadByte();
80002d50:	f0 1f 00 3b 	mcall	80002e3c <SD_GetCIDRegister+0x124>
80002d54:	0c cc       	st.b	r6++,r12
  if (!SD_GetResponse(SD_RESPONSE_NO_ERROR))
  {
    if (!SD_GetResponse(SD_START_DATA_SINGLE_BLOCK_READ))
    {
      /*!< Store CID register value on CID_Tab */
      for (i = 0; i < 16; i++)
80002d56:	0a 36       	cp.w	r6,r5
80002d58:	cf c1       	brne	80002d50 <SD_GetCIDRegister+0x38>
      {
        CID_Tab[i] = SD_ReadByte();
      }
    }
    /*!< Get CRC bytes (not really needed by us, but required by SD) */
    SD_WriteByte(SD_DUMMY_BYTE);
80002d5a:	e0 6c 00 ff 	mov	r12,255
80002d5e:	f0 1f 00 39 	mcall	80002e40 <SD_GetCIDRegister+0x128>
    SD_WriteByte(SD_DUMMY_BYTE);
80002d62:	e0 6c 00 ff 	mov	r12,255
80002d66:	f0 1f 00 37 	mcall	80002e40 <SD_GetCIDRegister+0x128>
80002d6a:	30 06       	mov	r6,0
    /*!< Set response value to success */
    rvalue = SD_RESPONSE_NO_ERROR;
  }
  /*!< SD chip select high */
  SD_CS_HIGH();
80002d6c:	31 8c       	mov	r12,24
80002d6e:	f0 1f 00 36 	mcall	80002e44 <SD_GetCIDRegister+0x12c>
  /*!< Send dummy byte: 8 Clock pulses of delay */
  SD_WriteByte(SD_DUMMY_BYTE);
80002d72:	e0 6c 00 ff 	mov	r12,255
80002d76:	f0 1f 00 33 	mcall	80002e40 <SD_GetCIDRegister+0x128>

  /*!< Byte 0 */
  SD_cid->ManufacturerID = CID_Tab[0];
80002d7a:	1b 88       	ld.ub	r8,sp[0x0]
80002d7c:	ae 88       	st.b	r7[0x0],r8

  /*!< Byte 1 */
  SD_cid->OEM_AppliID = CID_Tab[1] << 8;
80002d7e:	fb 28 00 01 	ld.sb	r8,sp[1]
80002d82:	a9 68       	lsl	r8,0x8
80002d84:	ae 18       	st.h	r7[0x2],r8

  /*!< Byte 2 */
  SD_cid->OEM_AppliID |= CID_Tab[2];
80002d86:	8e 19       	ld.sh	r9,r7[0x2]
80002d88:	1b a8       	ld.ub	r8,sp[0x2]
80002d8a:	f3 e8 10 08 	or	r8,r9,r8
80002d8e:	ae 18       	st.h	r7[0x2],r8

  /*!< Byte 3 */
  SD_cid->ProdName1 = CID_Tab[3] << 24;
80002d90:	1b b8       	ld.ub	r8,sp[0x3]
80002d92:	b9 68       	lsl	r8,0x18
80002d94:	8f 18       	st.w	r7[0x4],r8

  /*!< Byte 4 */
  SD_cid->ProdName1 |= CID_Tab[4] << 16;
80002d96:	6e 18       	ld.w	r8,r7[0x4]
80002d98:	1b c9       	ld.ub	r9,sp[0x4]
80002d9a:	f1 e9 11 08 	or	r8,r8,r9<<0x10
80002d9e:	8f 18       	st.w	r7[0x4],r8

  /*!< Byte 5 */
  SD_cid->ProdName1 |= CID_Tab[5] << 8;
80002da0:	6e 18       	ld.w	r8,r7[0x4]
80002da2:	1b d9       	ld.ub	r9,sp[0x5]
80002da4:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002da8:	8f 18       	st.w	r7[0x4],r8

  /*!< Byte 6 */
  SD_cid->ProdName1 |= CID_Tab[6];
80002daa:	6e 18       	ld.w	r8,r7[0x4]
80002dac:	1b e9       	ld.ub	r9,sp[0x6]
80002dae:	f3 e8 10 08 	or	r8,r9,r8
80002db2:	8f 18       	st.w	r7[0x4],r8

  /*!< Byte 7 */
  SD_cid->ProdName2 = CID_Tab[7];
80002db4:	1b f8       	ld.ub	r8,sp[0x7]
80002db6:	ef 68 00 08 	st.b	r7[8],r8

  /*!< Byte 8 */
  SD_cid->ProdRev = CID_Tab[8];
80002dba:	fb 38 00 08 	ld.ub	r8,sp[8]
80002dbe:	ef 68 00 09 	st.b	r7[9],r8

  /*!< Byte 9 */
  SD_cid->ProdSN = CID_Tab[9] << 24;
80002dc2:	fb 38 00 09 	ld.ub	r8,sp[9]
80002dc6:	b9 68       	lsl	r8,0x18
80002dc8:	8f 38       	st.w	r7[0xc],r8

  /*!< Byte 10 */
  SD_cid->ProdSN |= CID_Tab[10] << 16;
80002dca:	6e 38       	ld.w	r8,r7[0xc]
80002dcc:	fb 39 00 0a 	ld.ub	r9,sp[10]
80002dd0:	f1 e9 11 08 	or	r8,r8,r9<<0x10
80002dd4:	8f 38       	st.w	r7[0xc],r8

  /*!< Byte 11 */
  SD_cid->ProdSN |= CID_Tab[11] << 8;
80002dd6:	6e 38       	ld.w	r8,r7[0xc]
80002dd8:	fb 39 00 0b 	ld.ub	r9,sp[11]
80002ddc:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002de0:	8f 38       	st.w	r7[0xc],r8

  /*!< Byte 12 */
  SD_cid->ProdSN |= CID_Tab[12];
80002de2:	6e 38       	ld.w	r8,r7[0xc]
80002de4:	fb 39 00 0c 	ld.ub	r9,sp[12]
80002de8:	f3 e8 10 08 	or	r8,r9,r8
80002dec:	8f 38       	st.w	r7[0xc],r8

  /*!< Byte 13 */
  SD_cid->Reserved1 |= (CID_Tab[13] & 0xF0) >> 4;
80002dee:	ef 39 00 10 	ld.ub	r9,r7[16]
80002df2:	fb 38 00 0d 	ld.ub	r8,sp[13]
80002df6:	f3 e8 12 49 	or	r9,r9,r8>>0x4
80002dfa:	ef 69 00 10 	st.b	r7[16],r9
  SD_cid->ManufactDate = (CID_Tab[13] & 0x0F) << 8;
80002dfe:	a9 68       	lsl	r8,0x8
80002e00:	e2 18 0f 00 	andl	r8,0xf00,COH
80002e04:	ef 58 00 12 	st.h	r7[18],r8

  /*!< Byte 14 */
  SD_cid->ManufactDate |= CID_Tab[14];
80002e08:	ef 09 00 12 	ld.sh	r9,r7[18]
80002e0c:	fb 38 00 0e 	ld.ub	r8,sp[14]
80002e10:	f3 e8 10 08 	or	r8,r9,r8
80002e14:	ef 58 00 12 	st.h	r7[18],r8

  /*!< Byte 15 */
  SD_cid->CID_CRC = (CID_Tab[15] & 0xFE) >> 1;
80002e18:	fb 38 00 0f 	ld.ub	r8,sp[15]
80002e1c:	a1 98       	lsr	r8,0x1
80002e1e:	ef 68 00 14 	st.b	r7[20],r8
  SD_cid->Reserved2 = 1;
80002e22:	30 18       	mov	r8,1
80002e24:	ef 68 00 15 	st.b	r7[21],r8

  /*!< Return the reponse */
  return rvalue;
}
80002e28:	0c 9c       	mov	r12,r6
80002e2a:	2f cd       	sub	sp,-16
80002e2c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80002e30:	80 00       	ld.sh	r0,r0[0x0]
80002e32:	9f 90       	st.w	pc[0x24],r0
80002e34:	80 00       	ld.sh	r0,r0[0x0]
80002e36:	2b 14       	sub	r4,-79
80002e38:	80 00       	ld.sh	r0,r0[0x0]
80002e3a:	2a 54       	sub	r4,-91
80002e3c:	80 00       	ld.sh	r0,r0[0x0]
80002e3e:	2a 10       	sub	r0,-95
80002e40:	80 00       	ld.sh	r0,r0[0x0]
80002e42:	2a c8       	sub	r8,-84
80002e44:	80 00       	ld.sh	r0,r0[0x0]
80002e46:	9f 74       	st.w	pc[0x1c],r4

80002e48 <SD_WriteMultiBlocks>:
  * @retval The SD Response: 
  *         - SD_RESPONSE_FAILURE: Sequence failed
  *         - SD_RESPONSE_NO_ERROR: Sequence succeed
  */
SD_Error SD_WriteMultiBlocks(uint8_t* pBuffer, uint32_t WriteAddr, uint16_t BlockSize, uint32_t NumberOfBlocks)
{
80002e48:	d4 31       	pushm	r0-r7,lr
80002e4a:	18 95       	mov	r5,r12
80002e4c:	16 93       	mov	r3,r11
80002e4e:	14 96       	mov	r6,r10
80002e50:	12 94       	mov	r4,r9
  uint32_t i = 0, Offset = 0;
  SD_Error rvalue = SD_RESPONSE_FAILURE;

  /*!< SD chip select low */
  SD_CS_LOW();
80002e52:	31 8c       	mov	r12,24
80002e54:	f0 1f 00 27 	mcall	80002ef0 <SD_WriteMultiBlocks+0xa8>
80002e58:	e0 67 00 ff 	mov	r7,255
  /*!< Data transfer */
  while (NumberOfBlocks--)
  {
    if(flag_SDHC == 1)
80002e5c:	4a 60       	lddpc	r0,80002ef4 <SD_WriteMultiBlocks+0xac>
        SD_SendCmd(SD_CMD_WRITE_SINGLE_BLOCK, (WriteAddr + Offset)/512, 0xFF);
    }
    else
    {
        /*!< Send CMD24 (SD_CMD_WRITE_SINGLE_BLOCK) to write blocks */
        SD_SendCmd(SD_CMD_WRITE_SINGLE_BLOCK, WriteAddr + Offset, 0xFF);
80002e5e:	0e 92       	mov	r2,r7
    /*!< Send dummy byte */
    SD_WriteByte(SD_DUMMY_BYTE);
    /*!< Send the data token to signify the start of the data */
    SD_WriteByte(SD_START_DATA_SINGLE_BLOCK_WRITE);
    /*!< Write the block data to SD : write count data by block */
    for (i = 0; i < BlockSize; i++)
80002e60:	5c 76       	castu.h	r6
    Offset += 512;
    /*!< Put CRC bytes (not really needed by us, but required by SD) */
    SD_ReadByte();
    SD_ReadByte();
    /*!< Read data response */
    if (SD_GetDataResponse() == SD_DATA_OK)
80002e62:	30 51       	mov	r1,5
  SD_Error rvalue = SD_RESPONSE_FAILURE;

  /*!< SD chip select low */
  SD_CS_LOW();
  /*!< Data transfer */
  while (NumberOfBlocks--)
80002e64:	c3 a8       	rjmp	80002ed8 <SD_WriteMultiBlocks+0x90>
  {
    if(flag_SDHC == 1)
80002e66:	01 88       	ld.ub	r8,r0[0x0]
80002e68:	30 19       	mov	r9,1
80002e6a:	f2 08 18 00 	cp.b	r8,r9
80002e6e:	c0 81       	brne	80002e7e <SD_WriteMultiBlocks+0x36>
    {
        /* Send CMD24 (MSD_WRITE_BLOCK) to write blocks */
        SD_SendCmd(SD_CMD_WRITE_SINGLE_BLOCK, (WriteAddr + Offset)/512, 0xFF);
80002e70:	04 9a       	mov	r10,r2
80002e72:	e6 0b 16 09 	lsr	r11,r3,0x9
80002e76:	31 8c       	mov	r12,24
80002e78:	f0 1f 00 20 	mcall	80002ef8 <SD_WriteMultiBlocks+0xb0>
80002e7c:	c0 68       	rjmp	80002e88 <SD_WriteMultiBlocks+0x40>
    }
    else
    {
        /*!< Send CMD24 (SD_CMD_WRITE_SINGLE_BLOCK) to write blocks */
        SD_SendCmd(SD_CMD_WRITE_SINGLE_BLOCK, WriteAddr + Offset, 0xFF);
80002e7e:	04 9a       	mov	r10,r2
80002e80:	06 9b       	mov	r11,r3
80002e82:	31 8c       	mov	r12,24
80002e84:	f0 1f 00 1d 	mcall	80002ef8 <SD_WriteMultiBlocks+0xb0>
    }
    /*!< Check if the SD acknowledged the write block command: R1 response (0x00: no errors) */
    if (SD_GetResponse(SD_RESPONSE_NO_ERROR))
80002e88:	30 0c       	mov	r12,0
80002e8a:	f0 1f 00 1d 	mcall	80002efc <SD_WriteMultiBlocks+0xb4>
80002e8e:	c0 40       	breq	80002e96 <SD_WriteMultiBlocks+0x4e>
80002e90:	e0 67 00 ff 	mov	r7,255
80002e94:	c2 b8       	rjmp	80002eea <SD_WriteMultiBlocks+0xa2>
    {
      return SD_RESPONSE_FAILURE;
    }
    /*!< Send dummy byte */
    SD_WriteByte(SD_DUMMY_BYTE);
80002e96:	04 9c       	mov	r12,r2
80002e98:	f0 1f 00 1a 	mcall	80002f00 <SD_WriteMultiBlocks+0xb8>
    /*!< Send the data token to signify the start of the data */
    SD_WriteByte(SD_START_DATA_SINGLE_BLOCK_WRITE);
80002e9c:	e0 6c 00 fe 	mov	r12,254
80002ea0:	f0 1f 00 18 	mcall	80002f00 <SD_WriteMultiBlocks+0xb8>
    /*!< Write the block data to SD : write count data by block */
    for (i = 0; i < BlockSize; i++)
80002ea4:	58 06       	cp.w	r6,0
80002ea6:	c0 a0       	breq	80002eba <SD_WriteMultiBlocks+0x72>
80002ea8:	30 07       	mov	r7,0
    {
      /*!< Send the pointed byte */
      SD_WriteByte(*pBuffer);
80002eaa:	ea 07 07 0c 	ld.ub	r12,r5[r7]
80002eae:	f0 1f 00 15 	mcall	80002f00 <SD_WriteMultiBlocks+0xb8>
    /*!< Send dummy byte */
    SD_WriteByte(SD_DUMMY_BYTE);
    /*!< Send the data token to signify the start of the data */
    SD_WriteByte(SD_START_DATA_SINGLE_BLOCK_WRITE);
    /*!< Write the block data to SD : write count data by block */
    for (i = 0; i < BlockSize; i++)
80002eb2:	2f f7       	sub	r7,-1
80002eb4:	0c 37       	cp.w	r7,r6
80002eb6:	cf a3       	brcs	80002eaa <SD_WriteMultiBlocks+0x62>
80002eb8:	0c 05       	add	r5,r6
      pBuffer++;
    }
    /*!< Set next write address */
    Offset += 512;
    /*!< Put CRC bytes (not really needed by us, but required by SD) */
    SD_ReadByte();
80002eba:	f0 1f 00 13 	mcall	80002f04 <SD_WriteMultiBlocks+0xbc>
    SD_ReadByte();
80002ebe:	f0 1f 00 12 	mcall	80002f04 <SD_WriteMultiBlocks+0xbc>
    /*!< Read data response */
    if (SD_GetDataResponse() == SD_DATA_OK)
80002ec2:	f0 1f 00 12 	mcall	80002f08 <SD_WriteMultiBlocks+0xc0>
80002ec6:	f8 01 18 00 	cp.b	r1,r12
80002eca:	f9 b7 00 00 	moveq	r7,0
80002ece:	e4 07 17 10 	movne	r7,r2
80002ed2:	20 14       	sub	r4,1
80002ed4:	e6 c3 fe 00 	sub	r3,r3,-512
  SD_Error rvalue = SD_RESPONSE_FAILURE;

  /*!< SD chip select low */
  SD_CS_LOW();
  /*!< Data transfer */
  while (NumberOfBlocks--)
80002ed8:	58 04       	cp.w	r4,0
80002eda:	cc 61       	brne	80002e66 <SD_WriteMultiBlocks+0x1e>
      /*!< Set response value to failure */
      rvalue = SD_RESPONSE_FAILURE;
    }
  }
  /*!< SD chip select high */
  SD_CS_HIGH();
80002edc:	31 8c       	mov	r12,24
80002ede:	f0 1f 00 0c 	mcall	80002f0c <SD_WriteMultiBlocks+0xc4>
  /*!< Send dummy byte: 8 Clock pulses of delay */
  SD_WriteByte(SD_DUMMY_BYTE);
80002ee2:	e0 6c 00 ff 	mov	r12,255
80002ee6:	f0 1f 00 07 	mcall	80002f00 <SD_WriteMultiBlocks+0xb8>
  /*!< Returns the reponse */
  return rvalue;
}
80002eea:	0e 9c       	mov	r12,r7
80002eec:	d8 32       	popm	r0-r7,pc
80002eee:	00 00       	add	r0,r0
80002ef0:	80 00       	ld.sh	r0,r0[0x0]
80002ef2:	9f 90       	st.w	pc[0x24],r0
80002ef4:	00 00       	add	r0,r0
80002ef6:	0a 68       	and	r8,r5
80002ef8:	80 00       	ld.sh	r0,r0[0x0]
80002efa:	2b 14       	sub	r4,-79
80002efc:	80 00       	ld.sh	r0,r0[0x0]
80002efe:	2a 54       	sub	r4,-91
80002f00:	80 00       	ld.sh	r0,r0[0x0]
80002f02:	2a c8       	sub	r8,-84
80002f04:	80 00       	ld.sh	r0,r0[0x0]
80002f06:	2a 10       	sub	r0,-95
80002f08:	80 00       	ld.sh	r0,r0[0x0]
80002f0a:	2a 88       	sub	r8,-88
80002f0c:	80 00       	ld.sh	r0,r0[0x0]
80002f0e:	9f 74       	st.w	pc[0x1c],r4

80002f10 <SD_WriteBlock>:
  * @retval The SD Response: 
  *         - SD_RESPONSE_FAILURE: Sequence failed
  *         - SD_RESPONSE_NO_ERROR: Sequence succeed
  */
SD_Error SD_WriteBlock(uint8_t* pBuffer, uint32_t WriteAddr, uint16_t BlockSize)
{
80002f10:	eb cd 40 e0 	pushm	r5-r7,lr
80002f14:	18 95       	mov	r5,r12
80002f16:	16 97       	mov	r7,r11
80002f18:	14 96       	mov	r6,r10
  uint32_t i = 0;
  SD_Error rvalue = SD_RESPONSE_FAILURE;

  /*!< SD chip select low */
  SD_CS_LOW();
80002f1a:	31 8c       	mov	r12,24
80002f1c:	f0 1f 00 1f 	mcall	80002f98 <SD_WriteBlock+0x88>

  if(flag_SDHC == 1)
80002f20:	49 f8       	lddpc	r8,80002f9c <SD_WriteBlock+0x8c>
80002f22:	11 89       	ld.ub	r9,r8[0x0]
80002f24:	30 18       	mov	r8,1
80002f26:	f0 09 18 00 	cp.b	r9,r8
80002f2a:	c0 21       	brne	80002f2e <SD_WriteBlock+0x1e>
  {
  	WriteAddr = WriteAddr/512;
80002f2c:	a9 97       	lsr	r7,0x9
  }
  /*!< Send CMD24 (SD_CMD_WRITE_SINGLE_BLOCK) to write multiple block */
  SD_SendCmd(SD_CMD_WRITE_SINGLE_BLOCK, WriteAddr, 0xFF);
80002f2e:	e0 6a 00 ff 	mov	r10,255
80002f32:	0e 9b       	mov	r11,r7
80002f34:	31 8c       	mov	r12,24
80002f36:	f0 1f 00 1b 	mcall	80002fa0 <SD_WriteBlock+0x90>
  
  /*!< Check if the SD acknowledged the write block command: R1 response (0x00: no errors) */
  if (!SD_GetResponse(SD_RESPONSE_NO_ERROR))
80002f3a:	30 0c       	mov	r12,0
80002f3c:	f0 1f 00 1a 	mcall	80002fa4 <SD_WriteBlock+0x94>
80002f40:	c1 f1       	brne	80002f7e <SD_WriteBlock+0x6e>
  {
    /*!< Send a dummy byte */
    SD_WriteByte(SD_DUMMY_BYTE);
80002f42:	e0 6c 00 ff 	mov	r12,255
80002f46:	f0 1f 00 19 	mcall	80002fa8 <SD_WriteBlock+0x98>

    /*!< Send the data token to signify the start of the data */
    SD_WriteByte(0xFE);
80002f4a:	e0 6c 00 fe 	mov	r12,254
80002f4e:	f0 1f 00 17 	mcall	80002fa8 <SD_WriteBlock+0x98>

    /*!< Write the block data to SD : write count data by block */
    for (i = 0; i < BlockSize; i++)
80002f52:	5c 76       	castu.h	r6
80002f54:	c0 90       	breq	80002f66 <SD_WriteBlock+0x56>
80002f56:	30 07       	mov	r7,0
    {
      /*!< Send the pointed byte */
      SD_WriteByte(*pBuffer);
80002f58:	ea 07 07 0c 	ld.ub	r12,r5[r7]
80002f5c:	f0 1f 00 13 	mcall	80002fa8 <SD_WriteBlock+0x98>

    /*!< Send the data token to signify the start of the data */
    SD_WriteByte(0xFE);

    /*!< Write the block data to SD : write count data by block */
    for (i = 0; i < BlockSize; i++)
80002f60:	2f f7       	sub	r7,-1
80002f62:	0c 37       	cp.w	r7,r6
80002f64:	cf a3       	brcs	80002f58 <SD_WriteBlock+0x48>
      SD_WriteByte(*pBuffer);
      /*!< Point to the next location where the byte read will be saved */
      pBuffer++;
    }
    /*!< Put CRC bytes (not really needed by us, but required by SD) */
    SD_ReadByte();
80002f66:	f0 1f 00 12 	mcall	80002fac <SD_WriteBlock+0x9c>
    SD_ReadByte();
80002f6a:	f0 1f 00 11 	mcall	80002fac <SD_WriteBlock+0x9c>

    /*!< Read data response */
    if (SD_GetDataResponse() == SD_DATA_OK)
80002f6e:	f0 1f 00 11 	mcall	80002fb0 <SD_WriteBlock+0xa0>
80002f72:	30 58       	mov	r8,5
80002f74:	f0 0c 18 00 	cp.b	r12,r8
80002f78:	c0 31       	brne	80002f7e <SD_WriteBlock+0x6e>
80002f7a:	30 07       	mov	r7,0
80002f7c:	c0 38       	rjmp	80002f82 <SD_WriteBlock+0x72>
80002f7e:	e0 67 00 ff 	mov	r7,255
    {
      rvalue = SD_RESPONSE_NO_ERROR;
    }
  }
  /*!< SD chip select high */
  SD_CS_HIGH();
80002f82:	31 8c       	mov	r12,24
80002f84:	f0 1f 00 0c 	mcall	80002fb4 <SD_WriteBlock+0xa4>
  /*!< Send dummy byte: 8 Clock pulses of delay */
  SD_WriteByte(SD_DUMMY_BYTE);
80002f88:	e0 6c 00 ff 	mov	r12,255
80002f8c:	f0 1f 00 07 	mcall	80002fa8 <SD_WriteBlock+0x98>

  /*!< Returns the reponse */
  return rvalue;
}
80002f90:	0e 9c       	mov	r12,r7
80002f92:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80002f96:	00 00       	add	r0,r0
80002f98:	80 00       	ld.sh	r0,r0[0x0]
80002f9a:	9f 90       	st.w	pc[0x24],r0
80002f9c:	00 00       	add	r0,r0
80002f9e:	0a 68       	and	r8,r5
80002fa0:	80 00       	ld.sh	r0,r0[0x0]
80002fa2:	2b 14       	sub	r4,-79
80002fa4:	80 00       	ld.sh	r0,r0[0x0]
80002fa6:	2a 54       	sub	r4,-91
80002fa8:	80 00       	ld.sh	r0,r0[0x0]
80002faa:	2a c8       	sub	r8,-84
80002fac:	80 00       	ld.sh	r0,r0[0x0]
80002fae:	2a 10       	sub	r0,-95
80002fb0:	80 00       	ld.sh	r0,r0[0x0]
80002fb2:	2a 88       	sub	r8,-88
80002fb4:	80 00       	ld.sh	r0,r0[0x0]
80002fb6:	9f 74       	st.w	pc[0x1c],r4

80002fb8 <SD_ReadMultiBlocks>:
  * @retval The SD Response:
  *         - SD_RESPONSE_FAILURE: Sequence failed
  *         - SD_RESPONSE_NO_ERROR: Sequence succeed
  */
SD_Error SD_ReadMultiBlocks(uint8_t* pBuffer, uint32_t ReadAddr, uint16_t BlockSize, uint32_t NumberOfBlocks)
{
80002fb8:	d4 31       	pushm	r0-r7,lr
80002fba:	20 1d       	sub	sp,4
80002fbc:	18 95       	mov	r5,r12
80002fbe:	50 0b       	stdsp	sp[0x0],r11
80002fc0:	14 96       	mov	r6,r10
80002fc2:	12 94       	mov	r4,r9
  uint32_t i = 0, Offset = 0;
  SD_Error rvalue = SD_RESPONSE_FAILURE;
  
  /*!< SD chip select low */
  SD_CS_LOW();
80002fc4:	31 8c       	mov	r12,24
80002fc6:	f0 1f 00 27 	mcall	80003060 <SD_ReadMultiBlocks+0xa8>
80002fca:	e0 67 00 ff 	mov	r7,255
80002fce:	30 02       	mov	r2,0
  /*!< Data transfer */
  while (NumberOfBlocks--)
  {
    if(flag_SDHC == 1)
80002fd0:	4a 53       	lddpc	r3,80003064 <SD_ReadMultiBlocks+0xac>
        SD_SendCmd (SD_CMD_READ_SINGLE_BLOCK,(ReadAddr + Offset)/512, 0xFF);
    }
    else
    {
        /*!< Send CMD17 (SD_CMD_READ_SINGLE_BLOCK) to read one block */
        SD_SendCmd (SD_CMD_READ_SINGLE_BLOCK, ReadAddr + Offset, 0xFF);
80002fd2:	0e 90       	mov	r0,r7
    }
    /*!< Check if the SD acknowledged the read block command: R1 response (0x00: no errors) */
    if (SD_GetResponse(SD_RESPONSE_NO_ERROR))
80002fd4:	04 91       	mov	r1,r2
    }
    /*!< Now look for the data token to signify the start of the data */
    if (!SD_GetResponse(SD_START_DATA_SINGLE_BLOCK_READ))
    {
      /*!< Read the SD block data : read NumByteToRead data */
      for (i = 0; i < BlockSize; i++)
80002fd6:	5c 76       	castu.h	r6
  SD_Error rvalue = SD_RESPONSE_FAILURE;
  
  /*!< SD chip select low */
  SD_CS_LOW();
  /*!< Data transfer */
  while (NumberOfBlocks--)
80002fd8:	c3 78       	rjmp	80003046 <SD_ReadMultiBlocks+0x8e>
  {
    if(flag_SDHC == 1)
80002fda:	07 88       	ld.ub	r8,r3[0x0]
80002fdc:	30 19       	mov	r9,1
80002fde:	f2 08 18 00 	cp.b	r8,r9
80002fe2:	c0 a1       	brne	80002ff6 <SD_ReadMultiBlocks+0x3e>
    {
        /*!< Send CMD17 (SD_CMD_READ_SINGLE_BLOCK) to read one block */
        SD_SendCmd (SD_CMD_READ_SINGLE_BLOCK,(ReadAddr + Offset)/512, 0xFF);
80002fe4:	40 08       	lddsp	r8,sp[0x0]
80002fe6:	e4 08 00 0b 	add	r11,r2,r8
80002fea:	00 9a       	mov	r10,r0
80002fec:	a9 9b       	lsr	r11,0x9
80002fee:	31 1c       	mov	r12,17
80002ff0:	f0 1f 00 1e 	mcall	80003068 <SD_ReadMultiBlocks+0xb0>
80002ff4:	c0 88       	rjmp	80003004 <SD_ReadMultiBlocks+0x4c>
    }
    else
    {
        /*!< Send CMD17 (SD_CMD_READ_SINGLE_BLOCK) to read one block */
        SD_SendCmd (SD_CMD_READ_SINGLE_BLOCK, ReadAddr + Offset, 0xFF);
80002ff6:	00 9a       	mov	r10,r0
80002ff8:	40 09       	lddsp	r9,sp[0x0]
80002ffa:	e4 09 00 0b 	add	r11,r2,r9
80002ffe:	31 1c       	mov	r12,17
80003000:	f0 1f 00 1a 	mcall	80003068 <SD_ReadMultiBlocks+0xb0>
    }
    /*!< Check if the SD acknowledged the read block command: R1 response (0x00: no errors) */
    if (SD_GetResponse(SD_RESPONSE_NO_ERROR))
80003004:	02 9c       	mov	r12,r1
80003006:	f0 1f 00 1a 	mcall	8000306c <SD_ReadMultiBlocks+0xb4>
8000300a:	c0 40       	breq	80003012 <SD_ReadMultiBlocks+0x5a>
8000300c:	e0 67 00 ff 	mov	r7,255
80003010:	c2 48       	rjmp	80003058 <SD_ReadMultiBlocks+0xa0>
    {
      return  SD_RESPONSE_FAILURE;
    }
    /*!< Now look for the data token to signify the start of the data */
    if (!SD_GetResponse(SD_START_DATA_SINGLE_BLOCK_READ))
80003012:	e0 6c 00 fe 	mov	r12,254
80003016:	f0 1f 00 16 	mcall	8000306c <SD_ReadMultiBlocks+0xb4>
8000301a:	c0 30       	breq	80003020 <SD_ReadMultiBlocks+0x68>
8000301c:	00 97       	mov	r7,r0
8000301e:	c1 38       	rjmp	80003044 <SD_ReadMultiBlocks+0x8c>
    {
      /*!< Read the SD block data : read NumByteToRead data */
      for (i = 0; i < BlockSize; i++)
80003020:	58 06       	cp.w	r6,0
80003022:	c0 a0       	breq	80003036 <SD_ReadMultiBlocks+0x7e>
80003024:	02 97       	mov	r7,r1
      {
        /*!< Read the pointed data */
        *pBuffer = SD_ReadByte();
80003026:	f0 1f 00 13 	mcall	80003070 <SD_ReadMultiBlocks+0xb8>
8000302a:	ea 07 0b 0c 	st.b	r5[r7],r12
    }
    /*!< Now look for the data token to signify the start of the data */
    if (!SD_GetResponse(SD_START_DATA_SINGLE_BLOCK_READ))
    {
      /*!< Read the SD block data : read NumByteToRead data */
      for (i = 0; i < BlockSize; i++)
8000302e:	2f f7       	sub	r7,-1
80003030:	0c 37       	cp.w	r7,r6
80003032:	cf a3       	brcs	80003026 <SD_ReadMultiBlocks+0x6e>
80003034:	0c 05       	add	r5,r6
        *pBuffer = SD_ReadByte();
        /*!< Point to the next location where the byte read will be saved */
        pBuffer++;
      }
      /*!< Set next read address*/
      Offset += 512;
80003036:	e4 c2 fe 00 	sub	r2,r2,-512
      /*!< get CRC bytes (not really needed by us, but required by SD) */
      SD_ReadByte();
8000303a:	f0 1f 00 0e 	mcall	80003070 <SD_ReadMultiBlocks+0xb8>
      SD_ReadByte();
8000303e:	f0 1f 00 0d 	mcall	80003070 <SD_ReadMultiBlocks+0xb8>
80003042:	02 97       	mov	r7,r1
80003044:	20 14       	sub	r4,1
  SD_Error rvalue = SD_RESPONSE_FAILURE;
  
  /*!< SD chip select low */
  SD_CS_LOW();
  /*!< Data transfer */
  while (NumberOfBlocks--)
80003046:	58 04       	cp.w	r4,0
80003048:	cc 91       	brne	80002fda <SD_ReadMultiBlocks+0x22>
      /*!< Set response value to failure */
      rvalue = SD_RESPONSE_FAILURE;
    }
  }
  /*!< SD chip select high */
  SD_CS_HIGH();
8000304a:	31 8c       	mov	r12,24
8000304c:	f0 1f 00 0a 	mcall	80003074 <SD_ReadMultiBlocks+0xbc>
  /*!< Send dummy byte: 8 Clock pulses of delay */
  SD_WriteByte(SD_DUMMY_BYTE);
80003050:	e0 6c 00 ff 	mov	r12,255
80003054:	f0 1f 00 09 	mcall	80003078 <SD_ReadMultiBlocks+0xc0>
  /*!< Returns the reponse */
  return rvalue;
}
80003058:	0e 9c       	mov	r12,r7
8000305a:	2f fd       	sub	sp,-4
8000305c:	d8 32       	popm	r0-r7,pc
8000305e:	00 00       	add	r0,r0
80003060:	80 00       	ld.sh	r0,r0[0x0]
80003062:	9f 90       	st.w	pc[0x24],r0
80003064:	00 00       	add	r0,r0
80003066:	0a 68       	and	r8,r5
80003068:	80 00       	ld.sh	r0,r0[0x0]
8000306a:	2b 14       	sub	r4,-79
8000306c:	80 00       	ld.sh	r0,r0[0x0]
8000306e:	2a 54       	sub	r4,-91
80003070:	80 00       	ld.sh	r0,r0[0x0]
80003072:	2a 10       	sub	r0,-95
80003074:	80 00       	ld.sh	r0,r0[0x0]
80003076:	9f 74       	st.w	pc[0x1c],r4
80003078:	80 00       	ld.sh	r0,r0[0x0]
8000307a:	2a c8       	sub	r8,-84

8000307c <SD_ReadBlock>:
  * @retval The SD Response:
  *         - SD_RESPONSE_FAILURE: Sequence failed
  *         - SD_RESPONSE_NO_ERROR: Sequence succeed
  */
SD_Error SD_ReadBlock(uint8_t* pBuffer, uint32_t ReadAddr, uint16_t BlockSize)
{
8000307c:	eb cd 40 e0 	pushm	r5-r7,lr
80003080:	18 95       	mov	r5,r12
80003082:	16 97       	mov	r7,r11
80003084:	14 96       	mov	r6,r10
  uint32_t i = 0;
  SD_Error rvalue = SD_RESPONSE_FAILURE;

  /*!< SD chip select low */
  SD_CS_LOW();
80003086:	31 8c       	mov	r12,24
80003088:	f0 1f 00 1a 	mcall	800030f0 <SD_ReadBlock+0x74>
  
if(flag_SDHC == 1)
8000308c:	49 a8       	lddpc	r8,800030f4 <SD_ReadBlock+0x78>
8000308e:	11 89       	ld.ub	r9,r8[0x0]
80003090:	30 18       	mov	r8,1
80003092:	f0 09 18 00 	cp.b	r9,r8
80003096:	c0 21       	brne	8000309a <SD_ReadBlock+0x1e>
{
	ReadAddr = ReadAddr/512;
80003098:	a9 97       	lsr	r7,0x9
}
  /*!< Send CMD17 (SD_CMD_READ_SINGLE_BLOCK) to read one block */
  SD_SendCmd(SD_CMD_READ_SINGLE_BLOCK, ReadAddr, 0xFF);
8000309a:	e0 6a 00 ff 	mov	r10,255
8000309e:	0e 9b       	mov	r11,r7
800030a0:	31 1c       	mov	r12,17
800030a2:	f0 1f 00 16 	mcall	800030f8 <SD_ReadBlock+0x7c>
  
  /*!< Check if the SD acknowledged the read block command: R1 response (0x00: no errors) */
  if (!SD_GetResponse(SD_RESPONSE_NO_ERROR))
800030a6:	30 0c       	mov	r12,0
800030a8:	f0 1f 00 15 	mcall	800030fc <SD_ReadBlock+0x80>
800030ac:	c1 61       	brne	800030d8 <SD_ReadBlock+0x5c>
  {
    /*!< Now look for the data token to signify the start of the data */
    if (!SD_GetResponse(SD_START_DATA_SINGLE_BLOCK_READ))
800030ae:	e0 6c 00 fe 	mov	r12,254
800030b2:	f0 1f 00 13 	mcall	800030fc <SD_ReadBlock+0x80>
800030b6:	c1 11       	brne	800030d8 <SD_ReadBlock+0x5c>
    {
      /*!< Read the SD block data : read NumByteToRead data */
      for (i = 0; i < BlockSize; i++)
800030b8:	5c 76       	castu.h	r6
800030ba:	c0 90       	breq	800030cc <SD_ReadBlock+0x50>
800030bc:	30 07       	mov	r7,0
      {
        /*!< Save the received data */
        *pBuffer = SD_ReadByte();
800030be:	f0 1f 00 11 	mcall	80003100 <SD_ReadBlock+0x84>
800030c2:	ea 07 0b 0c 	st.b	r5[r7],r12
  {
    /*!< Now look for the data token to signify the start of the data */
    if (!SD_GetResponse(SD_START_DATA_SINGLE_BLOCK_READ))
    {
      /*!< Read the SD block data : read NumByteToRead data */
      for (i = 0; i < BlockSize; i++)
800030c6:	2f f7       	sub	r7,-1
800030c8:	0c 37       	cp.w	r7,r6
800030ca:	cf a3       	brcs	800030be <SD_ReadBlock+0x42>
       
        /*!< Point to the next location where the byte read will be saved */
        pBuffer++;
      }
      /*!< Get CRC bytes (not really needed by us, but required by SD) */
      SD_ReadByte();
800030cc:	f0 1f 00 0d 	mcall	80003100 <SD_ReadBlock+0x84>
      SD_ReadByte();
800030d0:	f0 1f 00 0c 	mcall	80003100 <SD_ReadBlock+0x84>
800030d4:	30 07       	mov	r7,0
800030d6:	c0 38       	rjmp	800030dc <SD_ReadBlock+0x60>
800030d8:	e0 67 00 ff 	mov	r7,255
      /*!< Set response value to success */
      rvalue = SD_RESPONSE_NO_ERROR;
    }
  }
  /*!< SD chip select high */
  SD_CS_HIGH();
800030dc:	31 8c       	mov	r12,24
800030de:	f0 1f 00 0a 	mcall	80003104 <SD_ReadBlock+0x88>
  
  /*!< Send dummy byte: 8 Clock pulses of delay */
  SD_WriteByte(SD_DUMMY_BYTE);
800030e2:	e0 6c 00 ff 	mov	r12,255
800030e6:	f0 1f 00 09 	mcall	80003108 <SD_ReadBlock+0x8c>
  
  /*!< Returns the reponse */
  return rvalue;
}
800030ea:	0e 9c       	mov	r12,r7
800030ec:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800030f0:	80 00       	ld.sh	r0,r0[0x0]
800030f2:	9f 90       	st.w	pc[0x24],r0
800030f4:	00 00       	add	r0,r0
800030f6:	0a 68       	and	r8,r5
800030f8:	80 00       	ld.sh	r0,r0[0x0]
800030fa:	2b 14       	sub	r4,-79
800030fc:	80 00       	ld.sh	r0,r0[0x0]
800030fe:	2a 54       	sub	r4,-91
80003100:	80 00       	ld.sh	r0,r0[0x0]
80003102:	2a 10       	sub	r0,-95
80003104:	80 00       	ld.sh	r0,r0[0x0]
80003106:	9f 74       	st.w	pc[0x1c],r4
80003108:	80 00       	ld.sh	r0,r0[0x0]
8000310a:	2a c8       	sub	r8,-84

8000310c <SD_Init>:
  * @   SD
  * @   
  * @ 
***------------------------------------------------------*/
SD_Error SD_Init(void)
{
8000310c:	eb cd 40 f8 	pushm	r3-r7,lr
  uint32_t TimeOut, i = 0;
  SD_Error Status = SD_RESPONSE_NO_ERROR;

  /* SD_SPI,SPI */
  SD_LowLevel_Init(); 
80003110:	f0 1f 00 11 	mcall	80003154 <SD_Init+0x48>

  /*SD_SPI*/
  SD_SPI_SetSpeedLow();
80003114:	f0 1f 00 11 	mcall	80003158 <SD_Init+0x4c>
80003118:	30 05       	mov	r5,0
  TimeOut = 0;
  do
  {
	  
    /* SDCS*/
    SD_CS_HIGH();
8000311a:	31 84       	mov	r4,24
8000311c:	0a 93       	mov	r3,r5

    /*!< Rise CS and MOSI for 80 clocks cycles */
	/* CS100xFF,80*/
    for (i = 0; i <= 9; i++)
    {
      SD_WriteByte(SD_DUMMY_BYTE);
8000311e:	e0 66 00 ff 	mov	r6,255
  TimeOut = 0;
  do
  {
	  
    /* SDCS*/
    SD_CS_HIGH();
80003122:	08 9c       	mov	r12,r4
80003124:	f0 1f 00 0e 	mcall	8000315c <SD_Init+0x50>
80003128:	06 97       	mov	r7,r3

    /*!< Rise CS and MOSI for 80 clocks cycles */
	/* CS100xFF,80*/
    for (i = 0; i <= 9; i++)
    {
      SD_WriteByte(SD_DUMMY_BYTE);
8000312a:	0c 9c       	mov	r12,r6
8000312c:	f0 1f 00 0d 	mcall	80003160 <SD_Init+0x54>
    /* SDCS*/
    SD_CS_HIGH();

    /*!< Rise CS and MOSI for 80 clocks cycles */
	/* CS100xFF,80*/
    for (i = 0; i <= 9; i++)
80003130:	2f f7       	sub	r7,-1
80003132:	58 a7       	cp.w	r7,10
80003134:	cf b1       	brne	8000312a <SD_Init+0x1e>
    {
      SD_WriteByte(SD_DUMMY_BYTE);
    }    
    
	Status = SD_GoIdleState();
80003136:	f0 1f 00 0c 	mcall	80003164 <SD_Init+0x58>
8000313a:	18 97       	mov	r7,r12

    if(TimeOut > 6)
8000313c:	58 75       	cp.w	r5,7
8000313e:	c0 50       	breq	80003148 <SD_Init+0x3c>
    {
      break;
    }
    TimeOut++;
  }while(Status);
80003140:	58 0c       	cp.w	r12,0
80003142:	c0 30       	breq	80003148 <SD_Init+0x3c>

    if(TimeOut > 6)
    {
      break;
    }
    TimeOut++;
80003144:	2f f5       	sub	r5,-1
80003146:	ce eb       	rjmp	80003122 <SD_Init+0x16>
  }while(Status);


   /*SD_SPI*/
  SD_SPI_SetSpeedHi();
80003148:	f0 1f 00 08 	mcall	80003168 <SD_Init+0x5c>
  return (Status);
}
8000314c:	0e 9c       	mov	r12,r7
8000314e:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80003152:	00 00       	add	r0,r0
80003154:	80 00       	ld.sh	r0,r0[0x0]
80003156:	29 98       	sub	r8,-103
80003158:	80 00       	ld.sh	r0,r0[0x0]
8000315a:	29 88       	sub	r8,-104
8000315c:	80 00       	ld.sh	r0,r0[0x0]
8000315e:	9f 74       	st.w	pc[0x1c],r4
80003160:	80 00       	ld.sh	r0,r0[0x0]
80003162:	2a c8       	sub	r8,-84
80003164:	80 00       	ld.sh	r0,r0[0x0]
80003166:	2b 50       	sub	r0,-75
80003168:	80 00       	ld.sh	r0,r0[0x0]
8000316a:	29 78       	sub	r8,-105

8000316c <SD_GetCSDRegister>:
  * @retval The SD Response: 
  *         - SD_RESPONSE_FAILURE: Sequence failed
  *         - SD_RESPONSE_NO_ERROR: Sequence succeed
  */
SD_Error SD_GetCSDRegister(SD_CSD* SD_csd)
{
8000316c:	eb cd 40 e0 	pushm	r5-r7,lr
80003170:	20 9d       	sub	sp,36
80003172:	18 97       	mov	r7,r12
  uint8_t CSD_Tab[16];
  uint32_t CardCapacity;
  static uint32_t times = 0;

  /*!< SD chip select low */
  SD_CS_LOW();
80003174:	31 8c       	mov	r12,24
80003176:	f0 1f 00 a6 	mcall	8000340c <SD_GetCSDRegister+0x2a0>
  /*!< Send CMD9 (CSD register) or CMD10(CSD register) */
  SD_SendCmd(SD_CMD_SEND_CSD, 0, 0xFF);
8000317a:	e0 6a 00 ff 	mov	r10,255
8000317e:	30 0b       	mov	r11,0
80003180:	30 9c       	mov	r12,9
80003182:	f0 1f 00 a4 	mcall	80003410 <SD_GetCSDRegister+0x2a4>
  /*!< Wait for response in the R1 format (0x00 is no errors) */
  if (!SD_GetResponse(SD_RESPONSE_NO_ERROR))
80003186:	30 0c       	mov	r12,0
80003188:	f0 1f 00 a3 	mcall	80003414 <SD_GetCSDRegister+0x2a8>
8000318c:	c0 40       	breq	80003194 <SD_GetCSDRegister+0x28>
8000318e:	e0 6c 00 ff 	mov	r12,255
80003192:	c3 99       	rjmp	80003404 <SD_GetCSDRegister+0x298>
  {
    if (!SD_GetResponse(SD_START_DATA_SINGLE_BLOCK_READ))
80003194:	e0 6c 00 fe 	mov	r12,254
80003198:	f0 1f 00 9f 	mcall	80003414 <SD_GetCSDRegister+0x2a8>
8000319c:	c0 a1       	brne	800031b0 <SD_GetCSDRegister+0x44>
8000319e:	fa c6 ff ec 	sub	r6,sp,-20
  * @param  SD_csd: pointer on an SCD register structure
  * @retval The SD Response: 
  *         - SD_RESPONSE_FAILURE: Sequence failed
  *         - SD_RESPONSE_NO_ERROR: Sequence succeed
  */
SD_Error SD_GetCSDRegister(SD_CSD* SD_csd)
800031a2:	fa c5 ff dc 	sub	r5,sp,-36
    if (!SD_GetResponse(SD_START_DATA_SINGLE_BLOCK_READ))
    {
      for (i = 0; i < 16; i++)
      {
        /*!< Store CSD register value on CSD_Tab */
        CSD_Tab[i] = SD_ReadByte();
800031a6:	f0 1f 00 9d 	mcall	80003418 <SD_GetCSDRegister+0x2ac>
800031aa:	0c cc       	st.b	r6++,r12
  /*!< Wait for response in the R1 format (0x00 is no errors) */
  if (!SD_GetResponse(SD_RESPONSE_NO_ERROR))
  {
    if (!SD_GetResponse(SD_START_DATA_SINGLE_BLOCK_READ))
    {
      for (i = 0; i < 16; i++)
800031ac:	0a 36       	cp.w	r6,r5
800031ae:	cf c1       	brne	800031a6 <SD_GetCSDRegister+0x3a>
          //printf("\n\r CSD_Tab[%d] 0x%X", i, CSD_Tab[i]);
        }
      }
    }
    /*!< Get CRC bytes (not really needed by us, but required by SD) */
    SD_WriteByte(SD_DUMMY_BYTE);
800031b0:	e0 6c 00 ff 	mov	r12,255
800031b4:	f0 1f 00 9a 	mcall	8000341c <SD_GetCSDRegister+0x2b0>
    SD_WriteByte(SD_DUMMY_BYTE);
800031b8:	e0 6c 00 ff 	mov	r12,255
800031bc:	f0 1f 00 98 	mcall	8000341c <SD_GetCSDRegister+0x2b0>
  else
  {
     return rvalue;
  }
  /*!< SD chip select high */
  SD_CS_HIGH();
800031c0:	31 8c       	mov	r12,24
800031c2:	f0 1f 00 98 	mcall	80003420 <SD_GetCSDRegister+0x2b4>
  /*!< Send dummy byte: 8 Clock pulses of delay */
  SD_WriteByte(SD_DUMMY_BYTE);
800031c6:	e0 6c 00 ff 	mov	r12,255
800031ca:	f0 1f 00 95 	mcall	8000341c <SD_GetCSDRegister+0x2b0>

  /*!< Byte 0 */
  SD_csd->CSDStruct = (CSD_Tab[0] & 0xC0) >> 6;
800031ce:	fb 38 00 14 	ld.ub	r8,sp[20]
800031d2:	f0 09 16 06 	lsr	r9,r8,0x6
800031d6:	ae 89       	st.b	r7[0x0],r9
  SD_csd->SysSpecVersion = (CSD_Tab[0] & 0x3C) >> 2;
800031d8:	f3 d8 c0 44 	bfextu	r9,r8,0x2,0x4
800031dc:	ae 99       	st.b	r7[0x1],r9
  SD_csd->Reserved1 = CSD_Tab[0] & 0x03;
800031de:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
800031e2:	ae a8       	st.b	r7[0x2],r8

  if(0 == times)
800031e4:	fe f8 02 40 	ld.w	r8,pc[576]
800031e8:	70 08       	ld.w	r8,r8[0x0]
800031ea:	58 08       	cp.w	r8,0
800031ec:	c0 f1       	brne	8000320a <SD_GetCSDRegister+0x9e>
  {
    if(SD_csd->CSDStruct == 1)
800031ee:	0f 89       	ld.ub	r9,r7[0x0]
800031f0:	30 18       	mov	r8,1
800031f2:	f0 09 18 00 	cp.b	r9,r8
800031f6:	c0 61       	brne	80003202 <SD_GetCSDRegister+0x96>
    {
      //printf("\n\r SDHC CSD Version 2.0 Acess AS SD High Capacity.");
      flag_SDHC = 1;
800031f8:	10 99       	mov	r9,r8
800031fa:	fe f8 02 2e 	ld.w	r8,pc[558]
800031fe:	b0 89       	st.b	r8[0x0],r9
80003200:	c0 58       	rjmp	8000320a <SD_GetCSDRegister+0x9e>
    }
	else
	{
      //printf("\n\r SDSC CSD Version 1.0 Acess AS SD Standard Capacity.");	
      flag_SDHC = 0;
80003202:	30 09       	mov	r9,0
80003204:	fe f8 02 24 	ld.w	r8,pc[548]
80003208:	b0 89       	st.b	r8[0x0],r9
	}
  }

  /*!< Byte 1 */
  SD_csd->TAAC = CSD_Tab[1];
8000320a:	fb 38 00 15 	ld.ub	r8,sp[21]
8000320e:	ae b8       	st.b	r7[0x3],r8

  /*!< Byte 2 */
  SD_csd->NSAC = CSD_Tab[2];
80003210:	fb 38 00 16 	ld.ub	r8,sp[22]
80003214:	ae c8       	st.b	r7[0x4],r8

  /*!< Byte 3 */
  SD_csd->MaxBusClkFrec = CSD_Tab[3];
80003216:	fb 38 00 17 	ld.ub	r8,sp[23]
8000321a:	ae d8       	st.b	r7[0x5],r8

  /*!< Byte 4 */
  SD_csd->CardComdClasses = CSD_Tab[4] << 4;
8000321c:	fb 38 00 18 	ld.ub	r8,sp[24]
80003220:	a5 68       	lsl	r8,0x4
80003222:	ae 38       	st.h	r7[0x6],r8

  /*!< Byte 5 */
  SD_csd->CardComdClasses |= (CSD_Tab[5] & 0xF0) >> 4;
80003224:	8e 39       	ld.sh	r9,r7[0x6]
80003226:	fb 38 00 19 	ld.ub	r8,sp[25]
8000322a:	f3 e8 12 49 	or	r9,r9,r8>>0x4
8000322e:	ae 39       	st.h	r7[0x6],r9
  SD_csd->RdBlockLen = CSD_Tab[5] & 0x0F;
80003230:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
80003234:	ef 68 00 08 	st.b	r7[8],r8

  /*!< Byte 6 */
  SD_csd->PartBlockRead = (CSD_Tab[6] & 0x80) >> 7;
80003238:	fb 38 00 1a 	ld.ub	r8,sp[26]
8000323c:	f0 09 16 07 	lsr	r9,r8,0x7
80003240:	ef 69 00 09 	st.b	r7[9],r9
  SD_csd->WrBlockMisalign = (CSD_Tab[6] & 0x40) >> 6;
80003244:	f3 d8 c0 c1 	bfextu	r9,r8,0x6,0x1
80003248:	ef 69 00 0a 	st.b	r7[10],r9
  SD_csd->RdBlockMisalign = (CSD_Tab[6] & 0x20) >> 5;
8000324c:	f3 d8 c0 a1 	bfextu	r9,r8,0x5,0x1
80003250:	ef 69 00 0b 	st.b	r7[11],r9
  SD_csd->DSRImpl = (CSD_Tab[6] & 0x10) >> 4;
80003254:	f3 d8 c0 81 	bfextu	r9,r8,0x4,0x1
80003258:	ef 69 00 0c 	st.b	r7[12],r9
  SD_csd->Reserved2 = 0; /*!< Reserved */
8000325c:	30 09       	mov	r9,0
8000325e:	ef 69 00 0d 	st.b	r7[13],r9

  if(flag_SDHC == 0)
80003262:	4f 2a       	lddpc	r10,80003428 <SD_GetCSDRegister+0x2bc>
80003264:	15 8a       	ld.ub	r10,r10[0x0]
80003266:	f2 0a 18 00 	cp.b	r10,r9
8000326a:	c1 21       	brne	8000328e <SD_GetCSDRegister+0x122>
  {
    SD_csd->DeviceSize = (CSD_Tab[6] & 0x03) << 10;
8000326c:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
80003270:	ab 68       	lsl	r8,0xa
80003272:	8f 48       	st.w	r7[0x10],r8
  
    /*!< Byte 7 */
    SD_csd->DeviceSize |= (CSD_Tab[7]) << 2;
80003274:	6e 48       	ld.w	r8,r7[0x10]
80003276:	fb 39 00 1b 	ld.ub	r9,sp[27]
8000327a:	f1 e9 10 28 	or	r8,r8,r9<<0x2
8000327e:	8f 48       	st.w	r7[0x10],r8
  
    /*!< Byte 8 */
    SD_csd->DeviceSize |= (CSD_Tab[8] & 0xC0) >> 6;
80003280:	6e 48       	ld.w	r8,r7[0x10]
80003282:	fb 39 00 1c 	ld.ub	r9,sp[28]
80003286:	f1 e9 12 68 	or	r8,r8,r9>>0x6
8000328a:	8f 48       	st.w	r7[0x10],r8
8000328c:	c1 38       	rjmp	800032b2 <SD_GetCSDRegister+0x146>
  }
  else
  {
    SD_csd->DeviceSize = (CSD_Tab[7] & 0x3F) << 16;
8000328e:	fb 38 00 1b 	ld.ub	r8,sp[27]
80003292:	f1 d8 c0 06 	bfextu	r8,r8,0x0,0x6
80003296:	b1 68       	lsl	r8,0x10
80003298:	8f 48       	st.w	r7[0x10],r8
    /* Byte 7 */
    SD_csd->DeviceSize += (CSD_Tab[8]) << 8;
8000329a:	6e 49       	ld.w	r9,r7[0x10]
8000329c:	fb 38 00 1c 	ld.ub	r8,sp[28]
800032a0:	a9 68       	lsl	r8,0x8
800032a2:	12 08       	add	r8,r9
800032a4:	8f 48       	st.w	r7[0x10],r8
    /* Byte 8 */
    SD_csd->DeviceSize += CSD_Tab[9] ;
800032a6:	6e 48       	ld.w	r8,r7[0x10]
800032a8:	fb 39 00 1d 	ld.ub	r9,sp[29]
800032ac:	f2 08 00 08 	add	r8,r9,r8
800032b0:	8f 48       	st.w	r7[0x10],r8
  }    

  SD_csd->MaxRdCurrentVDDMin = (CSD_Tab[8] & 0x38) >> 3;
800032b2:	fb 38 00 1c 	ld.ub	r8,sp[28]
800032b6:	f3 d8 c0 63 	bfextu	r9,r8,0x3,0x3
800032ba:	ef 69 00 14 	st.b	r7[20],r9
  SD_csd->MaxRdCurrentVDDMax = (CSD_Tab[8] & 0x07);
800032be:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
800032c2:	ef 68 00 15 	st.b	r7[21],r8

  /*!< Byte 9 */
  SD_csd->MaxWrCurrentVDDMin = (CSD_Tab[9] & 0xE0) >> 5;
800032c6:	fb 38 00 1d 	ld.ub	r8,sp[29]
800032ca:	f0 09 16 05 	lsr	r9,r8,0x5
800032ce:	ef 69 00 16 	st.b	r7[22],r9
  SD_csd->MaxWrCurrentVDDMax = (CSD_Tab[9] & 0x1C) >> 2;
800032d2:	f3 d8 c0 43 	bfextu	r9,r8,0x2,0x3
800032d6:	ef 69 00 17 	st.b	r7[23],r9
  SD_csd->DeviceSizeMul = (CSD_Tab[9] & 0x03) << 1;
800032da:	a1 78       	lsl	r8,0x1
800032dc:	e2 18 00 06 	andl	r8,0x6,COH
800032e0:	ef 68 00 18 	st.b	r7[24],r8
  /*!< Byte 10 */
  SD_csd->DeviceSizeMul |= (CSD_Tab[10] & 0x80) >> 7;
800032e4:	ef 39 00 18 	ld.ub	r9,r7[24]
800032e8:	fb 38 00 1e 	ld.ub	r8,sp[30]
800032ec:	f3 e8 12 79 	or	r9,r9,r8>>0x7
800032f0:	ef 69 00 18 	st.b	r7[24],r9
    
  SD_csd->EraseGrSize = (CSD_Tab[10] & 0x40) >> 6;
800032f4:	f3 d8 c0 c1 	bfextu	r9,r8,0x6,0x1
800032f8:	ef 69 00 19 	st.b	r7[25],r9
  SD_csd->EraseGrMul = (CSD_Tab[10] & 0x3F) << 1;
800032fc:	a1 78       	lsl	r8,0x1
800032fe:	e2 18 00 7e 	andl	r8,0x7e,COH
80003302:	ef 68 00 1a 	st.b	r7[26],r8

  /*!< Byte 11 */
  SD_csd->EraseGrMul |= (CSD_Tab[11] & 0x80) >> 7;
80003306:	ef 39 00 1a 	ld.ub	r9,r7[26]
8000330a:	fb 38 00 1f 	ld.ub	r8,sp[31]
8000330e:	f3 e8 12 79 	or	r9,r9,r8>>0x7
80003312:	ef 69 00 1a 	st.b	r7[26],r9
  SD_csd->WrProtectGrSize = (CSD_Tab[11] & 0x7F);
80003316:	f1 d8 c0 07 	bfextu	r8,r8,0x0,0x7
8000331a:	ef 68 00 1b 	st.b	r7[27],r8

  /*!< Byte 12 */
  SD_csd->WrProtectGrEnable = (CSD_Tab[12] & 0x80) >> 7;
8000331e:	fb 38 00 20 	ld.ub	r8,sp[32]
80003322:	f0 09 16 07 	lsr	r9,r8,0x7
80003326:	ef 69 00 1c 	st.b	r7[28],r9
  SD_csd->ManDeflECC = (CSD_Tab[12] & 0x60) >> 5;
8000332a:	f3 d8 c0 a2 	bfextu	r9,r8,0x5,0x2
8000332e:	ef 69 00 1d 	st.b	r7[29],r9
  SD_csd->WrSpeedFact = (CSD_Tab[12] & 0x1C) >> 2;
80003332:	f3 d8 c0 43 	bfextu	r9,r8,0x2,0x3
80003336:	ef 69 00 1e 	st.b	r7[30],r9
  SD_csd->MaxWrBlockLen = (CSD_Tab[12] & 0x03) << 2;
8000333a:	a3 68       	lsl	r8,0x2
8000333c:	e2 18 00 0c 	andl	r8,0xc,COH
80003340:	ef 68 00 1f 	st.b	r7[31],r8

  /*!< Byte 13 */
  SD_csd->MaxWrBlockLen |= (CSD_Tab[13] & 0xC0) >> 6;
80003344:	ef 39 00 1f 	ld.ub	r9,r7[31]
80003348:	fb 38 00 21 	ld.ub	r8,sp[33]
8000334c:	f3 e8 12 69 	or	r9,r9,r8>>0x6
80003350:	ef 69 00 1f 	st.b	r7[31],r9
  SD_csd->WriteBlockPaPartial = (CSD_Tab[13] & 0x20) >> 5;
80003354:	f3 d8 c0 a1 	bfextu	r9,r8,0x5,0x1
80003358:	ef 69 00 20 	st.b	r7[32],r9
  SD_csd->Reserved3 = 0;
8000335c:	30 09       	mov	r9,0
8000335e:	ef 69 00 21 	st.b	r7[33],r9
  SD_csd->ContentProtectAppli = (CSD_Tab[13] & 0x01);
80003362:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80003366:	ef 68 00 22 	st.b	r7[34],r8

  /*!< Byte 14 */
  SD_csd->FileFormatGrouop = (CSD_Tab[14] & 0x80) >> 7;
8000336a:	fb 38 00 22 	ld.ub	r8,sp[34]
8000336e:	f0 09 16 07 	lsr	r9,r8,0x7
80003372:	ef 69 00 23 	st.b	r7[35],r9
  SD_csd->CopyFlag = (CSD_Tab[14] & 0x40) >> 6;
80003376:	f3 d8 c0 c1 	bfextu	r9,r8,0x6,0x1
8000337a:	ef 69 00 24 	st.b	r7[36],r9
  SD_csd->PermWrProtect = (CSD_Tab[14] & 0x20) >> 5;
8000337e:	f3 d8 c0 a1 	bfextu	r9,r8,0x5,0x1
80003382:	ef 69 00 25 	st.b	r7[37],r9
  SD_csd->TempWrProtect = (CSD_Tab[14] & 0x10) >> 4;
80003386:	f3 d8 c0 81 	bfextu	r9,r8,0x4,0x1
8000338a:	ef 69 00 26 	st.b	r7[38],r9
  SD_csd->FileFormat = (CSD_Tab[14] & 0x0C) >> 2;
8000338e:	f3 d8 c0 42 	bfextu	r9,r8,0x2,0x2
80003392:	ef 69 00 27 	st.b	r7[39],r9
  SD_csd->ECC = (CSD_Tab[14] & 0x03);
80003396:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
8000339a:	ef 68 00 28 	st.b	r7[40],r8

  /*!< Byte 15 */
  SD_csd->CSD_CRC = (CSD_Tab[15] & 0xFE) >> 1;
8000339e:	fb 38 00 23 	ld.ub	r8,sp[35]
800033a2:	a1 98       	lsr	r8,0x1
800033a4:	ef 68 00 29 	st.b	r7[41],r8
  SD_csd->Reserved4 = 1;
800033a8:	30 18       	mov	r8,1
800033aa:	ef 68 00 2a 	st.b	r7[42],r8

  if(times < 3)
800033ae:	49 e8       	lddpc	r8,80003424 <SD_GetCSDRegister+0x2b8>
800033b0:	70 08       	ld.w	r8,r8[0x0]
800033b2:	58 28       	cp.w	r8,2
800033b4:	e0 88 00 04 	brls	800033bc <SD_GetCSDRegister+0x250>
800033b8:	30 0c       	mov	r12,0
800033ba:	c2 58       	rjmp	80003404 <SD_GetCSDRegister+0x298>
  {
    if(flag_SDHC ==1)
800033bc:	49 b9       	lddpc	r9,80003428 <SD_GetCSDRegister+0x2bc>
800033be:	13 8a       	ld.ub	r10,r9[0x0]
800033c0:	30 19       	mov	r9,1
800033c2:	f2 0a 18 00 	cp.b	r10,r9
800033c6:	c0 51       	brne	800033d0 <SD_GetCSDRegister+0x264>
    {
	  /* SDHC memory capacity = (C_SIZE+1) * 512K byte */
      //SD_csd->DeviceSizeMul = 8 ;
      
      CardCapacity = (SD_csd->DeviceSize + 1)*512;
800033c8:	6e 49       	ld.w	r9,r7[0x10]
800033ca:	2f f9       	sub	r9,-1
800033cc:	a9 79       	lsl	r9,0x9
800033ce:	c0 c8       	rjmp	800033e6 <SD_GetCSDRegister+0x27a>
      
    }

    else
    {
      CardCapacity = (SD_csd->DeviceSize + 1);
800033d0:	6e 4a       	ld.w	r10,r7[0x10]
800033d2:	2f fa       	sub	r10,-1
      CardCapacity *= (1 << (SD_csd->DeviceSizeMul + 2));
800033d4:	ef 39 00 18 	ld.ub	r9,r7[24]
800033d8:	2f e9       	sub	r9,-2
800033da:	f4 09 09 4a 	lsl	r10,r10,r9
      CardCapacity *= (1<<SD_csd->RdBlockLen);
800033de:	ef 39 00 08 	ld.ub	r9,r7[8]
800033e2:	f4 09 09 49 	lsl	r9,r10,r9
      //printf("\n\r SD CardBlockSize %d CardCapacity %d M.", (1<<SD_csd->RdBlockLen), 
            //CardCapacity / 1024 / 1024);
    }
    
  if(times == 0)
800033e6:	58 08       	cp.w	r8,0
800033e8:	c0 91       	brne	800033fa <SD_GetCSDRegister+0x28e>
    {
	    uint8_t str[20];
        sprintf((char *)&str[0], " SD Card Size %dM. ", CardCapacity / 1024 / 1024);
800033ea:	b5 89       	lsr	r9,0x14
800033ec:	1a d9       	st.w	--sp,r9
800033ee:	49 0b       	lddpc	r11,8000342c <SD_GetCSDRegister+0x2c0>
800033f0:	fa cc ff fc 	sub	r12,sp,-4
800033f4:	f0 1f 00 0f 	mcall	80003430 <SD_GetCSDRegister+0x2c4>
800033f8:	2f fd       	sub	sp,-4
//	    LCD_DisplayStringLine(LCD_LINE_0, str);
    }
	times++;
800033fa:	48 b8       	lddpc	r8,80003424 <SD_GetCSDRegister+0x2b8>
800033fc:	70 09       	ld.w	r9,r8[0x0]
800033fe:	2f f9       	sub	r9,-1
80003400:	91 09       	st.w	r8[0x0],r9
80003402:	30 0c       	mov	r12,0
  }
  /*!< Return the reponse */
  return rvalue;
}
80003404:	2f 7d       	sub	sp,-36
80003406:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000340a:	00 00       	add	r0,r0
8000340c:	80 00       	ld.sh	r0,r0[0x0]
8000340e:	9f 90       	st.w	pc[0x24],r0
80003410:	80 00       	ld.sh	r0,r0[0x0]
80003412:	2b 14       	sub	r4,-79
80003414:	80 00       	ld.sh	r0,r0[0x0]
80003416:	2a 54       	sub	r4,-91
80003418:	80 00       	ld.sh	r0,r0[0x0]
8000341a:	2a 10       	sub	r0,-95
8000341c:	80 00       	ld.sh	r0,r0[0x0]
8000341e:	2a c8       	sub	r8,-84
80003420:	80 00       	ld.sh	r0,r0[0x0]
80003422:	9f 74       	st.w	pc[0x1c],r4
80003424:	00 00       	add	r0,r0
80003426:	0a 64       	and	r4,r5
80003428:	00 00       	add	r0,r0
8000342a:	0a 68       	and	r8,r5
8000342c:	80 01       	ld.sh	r1,r0[0x0]
8000342e:	05 a0       	ld.ub	r0,r2[0x2]
80003430:	80 00       	ld.sh	r0,r0[0x0]
80003432:	a8 a0       	st.b	r4[0x2],r0

80003434 <SD_GetCardInfo>:
  * @   
  * @   
  * @ 
***------------------------------------------------------*/
SD_Error SD_GetCardInfo(SD_CardInfo *cardinfo)
{
80003434:	eb cd 40 c0 	pushm	r6-r7,lr
80003438:	18 97       	mov	r7,r12
  static uint32_t i = 0;
  SD_Error status = SD_RESPONSE_FAILURE;

  status = SD_GetCSDRegister(&(cardinfo->SD_csd));
8000343a:	18 96       	mov	r6,r12
8000343c:	f0 1f 00 12 	mcall	80003484 <SD_GetCardInfo+0x50>
  if(SD_RESPONSE_FAILURE == status)
80003440:	e0 4c 00 ff 	cp.w	r12,255
80003444:	c0 41       	brne	8000344c <SD_GetCardInfo+0x18>
  {
    status = SD_GetCSDRegister(&(cardinfo->SD_csd));
80003446:	0e 9c       	mov	r12,r7
80003448:	f0 1f 00 0f 	mcall	80003484 <SD_GetCardInfo+0x50>
  }
  status = SD_GetCIDRegister(&(cardinfo->SD_cid));
8000344c:	ee cc ff d4 	sub	r12,r7,-44
80003450:	f0 1f 00 0e 	mcall	80003488 <SD_GetCardInfo+0x54>
  
  if (flag_SDHC = 1)
80003454:	30 19       	mov	r9,1
80003456:	48 e8       	lddpc	r8,8000348c <SD_GetCardInfo+0x58>
80003458:	b0 89       	st.b	r8[0x0],r9
  {
	  
	  /* SDHC memory capacity = (C_SIZE+1) * 512K byte */
	  
	  cardinfo->CardCapacity = (cardinfo->SD_csd.DeviceSize + 1) ; 
8000345a:	6e 48       	ld.w	r8,r7[0x10]
8000345c:	2f f8       	sub	r8,-1
8000345e:	ef 48 00 44 	st.w	r7[68],r8
	  cardinfo->CardBlockSize = 1 << (cardinfo->SD_csd.RdBlockLen);
80003462:	ef 39 00 08 	ld.ub	r9,r7[8]
80003466:	30 1a       	mov	r10,1
80003468:	f4 09 09 49 	lsl	r9,r10,r9
8000346c:	ef 49 00 48 	st.w	r7[72],r9
	  cardinfo->CardCapacity *= cardinfo->CardBlockSize; 
80003470:	f2 08 02 48 	mul	r8,r9,r8
80003474:	ef 48 00 44 	st.w	r7[68],r8
  {
  
    //printf("\n\r SD CardBlockSize %d CardCapacity %d M", cardinfo->CardBlockSize, 
            //cardinfo->CardCapacity / 1024 / 1024);
  }
  i++; 
80003478:	48 68       	lddpc	r8,80003490 <SD_GetCardInfo+0x5c>
8000347a:	70 09       	ld.w	r9,r8[0x0]
8000347c:	14 09       	add	r9,r10
8000347e:	91 09       	st.w	r8[0x0],r9
  
  /*!< Returns the reponse */
  return status;
}
80003480:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80003484:	80 00       	ld.sh	r0,r0[0x0]
80003486:	31 6c       	mov	r12,22
80003488:	80 00       	ld.sh	r0,r0[0x0]
8000348a:	2d 18       	sub	r8,-47
8000348c:	00 00       	add	r0,r0
8000348e:	0a 68       	and	r8,r5
80003490:	00 00       	add	r0,r0
80003492:	0a 60       	and	r0,r5

80003494 <SD_GetSectorCount>:
	}while(t<0XFFFFFF);//
	return SD_RESPONSE_FAILURE ;
}

uint32_t SD_GetSectorCount(void)
{
80003494:	d4 01       	pushm	lr
80003496:	21 3d       	sub	sp,76
	
	
	uint32_t  static temp;
	
	
	SD_GetCardInfo(&sdinfo);
80003498:	1a 9c       	mov	r12,sp
8000349a:	f0 1f 00 05 	mcall	800034ac <SD_GetSectorCount+0x18>
	
	temp = sdinfo.CardCapacity;
	
	temp = temp*(1024/512);//:1sector=512byte
8000349e:	41 1c       	lddsp	r12,sp[0x44]
800034a0:	a1 7c       	lsl	r12,0x1
800034a2:	48 48       	lddpc	r8,800034b0 <SD_GetSectorCount+0x1c>
800034a4:	91 0c       	st.w	r8[0x0],r12
	
	return (temp);
	
	

}
800034a6:	2e dd       	sub	sp,-76
800034a8:	d8 02       	popm	pc
800034aa:	00 00       	add	r0,r0
800034ac:	80 00       	ld.sh	r0,r0[0x0]
800034ae:	34 34       	mov	r4,67
800034b0:	00 00       	add	r0,r0
800034b2:	0a 5c       	eor	r12,r5

800034b4 <MAL_WriteDisk>:
* Output         :
* Return         : SD_ErrorStarus: SD Card Error code.
******************************************************************************************/

MAL_ErrorStarus MAL_WriteDisk(void *writebuff, uint32_t sector, uint32_t blockByteSize, uint8_t count)
{
800034b4:	d4 01       	pushm	lr
	
	
	if(count == 1)
800034b6:	30 18       	mov	r8,1
800034b8:	f0 09 18 00 	cp.b	r9,r8
800034bc:	c0 71       	brne	800034ca <MAL_WriteDisk+0x16>
	{
		
		if(SD_WriteBlock(writebuff, (sector*BLOCK_BYTE_SIZE), blockByteSize)==SD_RESPONSE_NO_ERROR)//1
800034be:	5c 7a       	castu.h	r10
800034c0:	a9 7b       	lsl	r11,0x9
800034c2:	f0 1f 00 07 	mcall	800034dc <MAL_WriteDisk+0x28>
800034c6:	c0 91       	brne	800034d8 <MAL_WriteDisk+0x24>
800034c8:	c0 68       	rjmp	800034d4 <MAL_WriteDisk+0x20>
		
	}
	else
	{
		
		if(SD_WriteMultiBlocks(writebuff, (sector*BLOCK_BYTE_SIZE), blockByteSize, count)==SD_RESPONSE_NO_ERROR)
800034ca:	5c 7a       	castu.h	r10
800034cc:	a9 7b       	lsl	r11,0x9
800034ce:	f0 1f 00 05 	mcall	800034e0 <MAL_WriteDisk+0x2c>
800034d2:	c0 31       	brne	800034d8 <MAL_WriteDisk+0x24>
800034d4:	30 4c       	mov	r12,4
800034d6:	d8 02       	popm	pc
800034d8:	30 3c       	mov	r12,3
	
	return WRITE_DATA_ERR;
	
	
	
}
800034da:	d8 02       	popm	pc
800034dc:	80 00       	ld.sh	r0,r0[0x0]
800034de:	2f 10       	sub	r0,-15
800034e0:	80 00       	ld.sh	r0,r0[0x0]
800034e2:	2e 48       	sub	r8,-28

800034e4 <MAL_ReadDisk>:
* Output         :
* Return         : SD_ErrorStarus: SD Card Error code.
******************************************************************************************/

MAL_ErrorStarus MAL_ReadDisk(void *readbuff, uint32_t sector, uint32_t blockByteSize, uint8_t count)
{
800034e4:	d4 01       	pushm	lr
	
	
	if(count == 1)
800034e6:	30 18       	mov	r8,1
800034e8:	f0 09 18 00 	cp.b	r9,r8
800034ec:	c0 71       	brne	800034fa <MAL_ReadDisk+0x16>
	{
		
		if(SD_ReadBlock(readbuff, (sector*BLOCK_BYTE_SIZE), blockByteSize)==SD_RESPONSE_NO_ERROR)//1
800034ee:	5c 7a       	castu.h	r10
800034f0:	a9 7b       	lsl	r11,0x9
800034f2:	f0 1f 00 07 	mcall	8000350c <MAL_ReadDisk+0x28>
800034f6:	c0 91       	brne	80003508 <MAL_ReadDisk+0x24>
800034f8:	c0 68       	rjmp	80003504 <MAL_ReadDisk+0x20>
		
	}
	else
	{
		
		if(SD_ReadMultiBlocks(readbuff, (sector*BLOCK_BYTE_SIZE), blockByteSize, count)==SD_RESPONSE_NO_ERROR)
800034fa:	5c 7a       	castu.h	r10
800034fc:	a9 7b       	lsl	r11,0x9
800034fe:	f0 1f 00 05 	mcall	80003510 <MAL_ReadDisk+0x2c>
80003502:	c0 31       	brne	80003508 <MAL_ReadDisk+0x24>
80003504:	30 8c       	mov	r12,8
80003506:	d8 02       	popm	pc
80003508:	30 7c       	mov	r12,7
	
	return READ_DATA_ERR;
	
		
	
}
8000350a:	d8 02       	popm	pc
8000350c:	80 00       	ld.sh	r0,r0[0x0]
8000350e:	30 7c       	mov	r12,7
80003510:	80 00       	ld.sh	r0,r0[0x0]
80003512:	2f b8       	sub	r8,-5

80003514 <MAL_InitConfig>:
* Output         : None
* Return         : SDConfigStatus:SD Card initiation code
*******************************************************************************/

uint16_t MAL_InitConfig(void)
{
80003514:	d4 01       	pushm	lr
80003516:	21 3d       	sub	sp,76
	uint16_t status = SDConfig_OK;
        
    SD_CardInfo cardinfo;

      if(!(SD_Init()))
80003518:	f0 1f 00 06 	mcall	80003530 <MAL_InitConfig+0x1c>
8000351c:	c0 30       	breq	80003522 <MAL_InitConfig+0xe>
8000351e:	30 1c       	mov	r12,1
80003520:	c0 58       	rjmp	8000352a <MAL_InitConfig+0x16>
      {
        
			if(SD_GetCardInfo(&cardinfo)==0) /*SD */
80003522:	1a 9c       	mov	r12,sp
80003524:	f0 1f 00 04 	mcall	80003534 <MAL_InitConfig+0x20>
80003528:	5f 1c       	srne	r12
			return status;//
      
      }    

        return SDConfig_FALL;
}
8000352a:	2e dd       	sub	sp,-76
8000352c:	d8 02       	popm	pc
8000352e:	00 00       	add	r0,r0
80003530:	80 00       	ld.sh	r0,r0[0x0]
80003532:	31 0c       	mov	r12,16
80003534:	80 00       	ld.sh	r0,r0[0x0]
80003536:	34 34       	mov	r4,67

80003538 <fl_write>:
	}
}


void fl_write(void * path, S32 offset, void * buffer, U32 length)
{
80003538:	eb cd 40 f8 	pushm	r3-r7,lr
8000353c:	20 2d       	sub	sp,8
8000353e:	18 95       	mov	r5,r12
80003540:	16 94       	mov	r4,r11
80003542:	14 93       	mov	r3,r10
80003544:	12 96       	mov	r6,r9
	
	fl_write_t * fl_write_ptr = pvPortMalloc(sizeof(fl_write_t));
80003546:	34 cc       	mov	r12,76
80003548:	f0 1f 00 16 	mcall	800035a0 <fl_write+0x68>
8000354c:	18 97       	mov	r7,r12
	
	sprintf(fl_write_ptr->path, "%s", path);
8000354e:	0a 9b       	mov	r11,r5
80003550:	f0 1f 00 15 	mcall	800035a4 <fl_write+0x6c>
	fl_write_ptr->offset = offset;
80003554:	ef 44 00 40 	st.w	r7[64],r4
	fl_write_ptr->length = length;	
80003558:	ef 46 00 44 	st.w	r7[68],r6
	
	fl_write_ptr->buffer = pvPortMalloc(length);
8000355c:	0c 9c       	mov	r12,r6
8000355e:	f0 1f 00 11 	mcall	800035a0 <fl_write+0x68>
80003562:	ef 4c 00 48 	st.w	r7[72],r12
	memcpy(fl_write_ptr->buffer, buffer, length);
80003566:	0c 9a       	mov	r10,r6
80003568:	06 9b       	mov	r11,r3
8000356a:	f0 1f 00 10 	mcall	800035a8 <fl_write+0x70>
	
	fl_oper_t fl_oper;
	
	fl_oper.opcode = FL_WRITE;
8000356e:	e0 68 40 00 	mov	r8,16384
80003572:	ba 08       	st.h	sp[0x0],r8
	fl_oper.payload = fl_write_ptr;
80003574:	50 17       	stdsp	sp[0x4],r7
	
	if(pdTRUE != xQueueSend( fl_oper_queue, &fl_oper, 0 ))
80003576:	48 e8       	lddpc	r8,800035ac <fl_write+0x74>
80003578:	70 0c       	ld.w	r12,r8[0x0]
8000357a:	30 09       	mov	r9,0
8000357c:	12 9a       	mov	r10,r9
8000357e:	1a 9b       	mov	r11,sp
80003580:	f0 1f 00 0c 	mcall	800035b0 <fl_write+0x78>
80003584:	58 1c       	cp.w	r12,1
80003586:	c0 a0       	breq	8000359a <fl_write+0x62>
	{
		vPortFree(fl_write_ptr->buffer);
80003588:	6f 2c       	ld.w	r12,r7[0x48]
8000358a:	f0 1f 00 0b 	mcall	800035b4 <fl_write+0x7c>
		vPortFree(fl_write_ptr);
8000358e:	0e 9c       	mov	r12,r7
80003590:	f0 1f 00 09 	mcall	800035b4 <fl_write+0x7c>
		log("\n\r fsmm \n\r");//man...SPI_PBA
80003594:	48 9c       	lddpc	r12,800035b8 <fl_write+0x80>
80003596:	f0 1f 00 0a 	mcall	800035bc <fl_write+0x84>
	}
	
}
8000359a:	2f ed       	sub	sp,-8
8000359c:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
800035a0:	80 00       	ld.sh	r0,r0[0x0]
800035a2:	8b 60       	st.w	r5[0x18],r0
800035a4:	80 00       	ld.sh	r0,r0[0x0]
800035a6:	a8 dc       	st.b	r4[0x5],r12
800035a8:	80 00       	ld.sh	r0,r0[0x0]
800035aa:	a4 6a       	st.h	r2[0xc],r10
800035ac:	00 00       	add	r0,r0
800035ae:	0d 40       	ld.w	r0,--r6
800035b0:	80 00       	ld.sh	r0,r0[0x0]
800035b2:	8e b4       	ld.uh	r4,r7[0x6]
800035b4:	80 00       	ld.sh	r0,r0[0x0]
800035b6:	8b 38       	st.w	r5[0xc],r8
800035b8:	80 01       	ld.sh	r1,r0[0x0]
800035ba:	05 e8       	ld.ub	r8,r2[0x6]
800035bc:	80 00       	ld.sh	r0,r0[0x0]
800035be:	9a a4       	ld.uh	r4,sp[0x4]

800035c0 <fl_write_func>:
	f_mount(NULL, "/", 1);		
	return fs_ok;
}

fs_err_t fl_write_func(void * path, S32 offset, void * buffer, U32 length)
{	
800035c0:	d4 31       	pushm	r0-r7,lr
800035c2:	20 1d       	sub	sp,4
800035c4:	18 97       	mov	r7,r12
800035c6:	16 96       	mov	r6,r11
800035c8:	14 94       	mov	r4,r10
800035ca:	12 95       	mov	r5,r9
	if(f_mount(&fs, "/", 1) != FR_OK)
800035cc:	30 1a       	mov	r10,1
800035ce:	4c 7b       	lddpc	r11,800036e8 <fl_write_func+0x128>
800035d0:	4c 7c       	lddpc	r12,800036ec <fl_write_func+0x12c>
800035d2:	f0 1f 00 48 	mcall	800036f0 <fl_write_func+0x130>
800035d6:	e0 81 00 86 	brne	800036e2 <fl_write_func+0x122>
	{
		return amount_err;
	}
	
	FRESULT res	= f_open (&fl, path, FA_WRITE | FA_OPEN_ALWAYS);
800035da:	0e 91       	mov	r1,r7
800035dc:	31 2a       	mov	r10,18
800035de:	0e 9b       	mov	r11,r7
800035e0:	4c 5c       	lddpc	r12,800036f4 <fl_write_func+0x134>
800035e2:	f0 1f 00 46 	mcall	800036f8 <fl_write_func+0x138>
	if(FR_NO_PATH == res)
800035e6:	58 5c       	cp.w	r12,5
800035e8:	c5 91       	brne	8000369a <fl_write_func+0xda>
	{
		if ( f_opendir(&dirs, "/") != FR_OK)
800035ea:	4c 0b       	lddpc	r11,800036e8 <fl_write_func+0x128>
800035ec:	4c 4c       	lddpc	r12,800036fc <fl_write_func+0x13c>
800035ee:	f0 1f 00 45 	mcall	80003700 <fl_write_func+0x140>
800035f2:	c0 80       	breq	80003602 <fl_write_func+0x42>
		{
			f_mount(NULL, "/", 1);
800035f4:	30 1a       	mov	r10,1
800035f6:	4b db       	lddpc	r11,800036e8 <fl_write_func+0x128>
800035f8:	30 0c       	mov	r12,0
800035fa:	f0 1f 00 3e 	mcall	800036f0 <fl_write_func+0x130>
800035fe:	30 6c       	mov	r12,6
			return fs_err;
80003600:	c7 28       	rjmp	800036e4 <fl_write_func+0x124>
		}
		
		static char filename[MAX_PATH_LENGTH], path_bk[MAX_PATH_LENGTH];		
		memcpy(path_bk, path, strlen(path));
80003602:	0e 9c       	mov	r12,r7
80003604:	f0 1f 00 40 	mcall	80003704 <fl_write_func+0x144>
80003608:	4c 03       	lddpc	r3,80003708 <fl_write_func+0x148>
8000360a:	18 9a       	mov	r10,r12
8000360c:	0e 9b       	mov	r11,r7
8000360e:	06 9c       	mov	r12,r3
80003610:	f0 1f 00 3f 	mcall	8000370c <fl_write_func+0x14c>
				
		char * dir = strtok(path_bk,"/");
80003614:	4b 57       	lddpc	r7,800036e8 <fl_write_func+0x128>
80003616:	0e 9b       	mov	r11,r7
80003618:	06 9c       	mov	r12,r3
8000361a:	f0 1f 00 3e 	mcall	80003710 <fl_write_func+0x150>
		sprintf(filename,"//%s", dir);		
8000361e:	1a dc       	st.w	--sp,r12
80003620:	4b db       	lddpc	r11,80003714 <fl_write_func+0x154>
80003622:	4b ec       	lddpc	r12,80003718 <fl_write_func+0x158>
80003624:	f0 1f 00 3e 	mcall	8000371c <fl_write_func+0x15c>
		dir = strtok(NULL,"/");
80003628:	0e 9b       	mov	r11,r7
8000362a:	30 0c       	mov	r12,0
8000362c:	f0 1f 00 39 	mcall	80003710 <fl_write_func+0x150>
80003630:	18 97       	mov	r7,r12
		while(TRUE)
		{
			if(NULL != dir)
80003632:	2f fd       	sub	sp,-4
80003634:	58 0c       	cp.w	r12,0
80003636:	c2 50       	breq	80003680 <fl_write_func+0xc0>
			{				
				res = f_mkdir(filename);
80003638:	4b 83       	lddpc	r3,80003718 <fl_write_func+0x158>
				if((res == FR_OK) || (res == FR_EXIST))
8000363a:	30 02       	mov	r2,0
				{					
					sprintf(filename,"%s//%s", filename, dir);
8000363c:	4b 90       	lddpc	r0,80003720 <fl_write_func+0x160>
		dir = strtok(NULL,"/");
		while(TRUE)
		{
			if(NULL != dir)
			{				
				res = f_mkdir(filename);
8000363e:	06 9c       	mov	r12,r3
80003640:	f0 1f 00 39 	mcall	80003724 <fl_write_func+0x164>
				if((res == FR_OK) || (res == FR_EXIST))
80003644:	5f 09       	sreq	r9
80003646:	58 8c       	cp.w	r12,8
80003648:	5f 08       	sreq	r8
8000364a:	f3 e8 10 08 	or	r8,r9,r8
8000364e:	e4 08 18 00 	cp.b	r8,r2
80003652:	c1 00       	breq	80003672 <fl_write_func+0xb2>
				{					
					sprintf(filename,"%s//%s", filename, dir);
80003654:	1a d7       	st.w	--sp,r7
80003656:	1a d3       	st.w	--sp,r3
80003658:	00 9b       	mov	r11,r0
8000365a:	06 9c       	mov	r12,r3
8000365c:	f0 1f 00 30 	mcall	8000371c <fl_write_func+0x15c>
					dir = strtok(NULL,"/");					
80003660:	4a 2b       	lddpc	r11,800036e8 <fl_write_func+0x128>
80003662:	30 0c       	mov	r12,0
80003664:	f0 1f 00 2b 	mcall	80003710 <fl_write_func+0x150>
80003668:	18 97       	mov	r7,r12
		char * dir = strtok(path_bk,"/");
		sprintf(filename,"//%s", dir);		
		dir = strtok(NULL,"/");
		while(TRUE)
		{
			if(NULL != dir)
8000366a:	2f ed       	sub	sp,-8
8000366c:	58 0c       	cp.w	r12,0
8000366e:	ce 81       	brne	8000363e <fl_write_func+0x7e>
80003670:	c0 88       	rjmp	80003680 <fl_write_func+0xc0>
					sprintf(filename,"%s//%s", filename, dir);
					dir = strtok(NULL,"/");					
				}
				else
				{
					f_mount(NULL, "/", 1);	
80003672:	30 1a       	mov	r10,1
80003674:	49 db       	lddpc	r11,800036e8 <fl_write_func+0x128>
80003676:	30 0c       	mov	r12,0
80003678:	f0 1f 00 1e 	mcall	800036f0 <fl_write_func+0x130>
8000367c:	30 4c       	mov	r12,4
					return new_dir_err;
8000367e:	c3 38       	rjmp	800036e4 <fl_write_func+0x124>
				}
				
			}
			else
			{
				res	= f_open (&fl, path, FA_WRITE | FA_OPEN_ALWAYS);
80003680:	31 2a       	mov	r10,18
80003682:	02 9b       	mov	r11,r1
80003684:	49 cc       	lddpc	r12,800036f4 <fl_write_func+0x134>
80003686:	f0 1f 00 1d 	mcall	800036f8 <fl_write_func+0x138>
				if(res != FR_OK)
8000368a:	c1 10       	breq	800036ac <fl_write_func+0xec>
				{					
					f_mount(NULL, "/", 1);	
8000368c:	30 1a       	mov	r10,1
8000368e:	49 7b       	lddpc	r11,800036e8 <fl_write_func+0x128>
80003690:	30 0c       	mov	r12,0
80003692:	f0 1f 00 18 	mcall	800036f0 <fl_write_func+0x130>
80003696:	30 3c       	mov	r12,3
					return open_fl_err;
80003698:	c2 68       	rjmp	800036e4 <fl_write_func+0x124>
				}
				break;
			}
		}
	}
	else if(res != FR_OK)
8000369a:	58 0c       	cp.w	r12,0
8000369c:	c0 80       	breq	800036ac <fl_write_func+0xec>
	{
		f_mount(NULL, "/", 1);
8000369e:	30 1a       	mov	r10,1
800036a0:	49 2b       	lddpc	r11,800036e8 <fl_write_func+0x128>
800036a2:	30 0c       	mov	r12,0
800036a4:	f0 1f 00 13 	mcall	800036f0 <fl_write_func+0x130>
800036a8:	30 3c       	mov	r12,3
		return open_fl_err;
800036aa:	c1 d8       	rjmp	800036e4 <fl_write_func+0x124>
	}
	
	if(offset == FILE_END)
800036ac:	5b f6       	cp.w	r6,-1
800036ae:	c0 61       	brne	800036ba <fl_write_func+0xfa>
	{
		f_lseek(&fl, fl.fsize);
800036b0:	49 1c       	lddpc	r12,800036f4 <fl_write_func+0x134>
800036b2:	78 3b       	ld.w	r11,r12[0xc]
800036b4:	f0 1f 00 1d 	mcall	80003728 <fl_write_func+0x168>
800036b8:	c0 58       	rjmp	800036c2 <fl_write_func+0x102>
	}
	else
	{
		f_lseek(&fl, offset);
800036ba:	0c 9b       	mov	r11,r6
800036bc:	48 ec       	lddpc	r12,800036f4 <fl_write_func+0x134>
800036be:	f0 1f 00 1b 	mcall	80003728 <fl_write_func+0x168>
	}
	
	UINT w;
	f_write (&fl, buffer, length, &w );
800036c2:	48 d7       	lddpc	r7,800036f4 <fl_write_func+0x134>
800036c4:	1a 99       	mov	r9,sp
800036c6:	0a 9a       	mov	r10,r5
800036c8:	08 9b       	mov	r11,r4
800036ca:	0e 9c       	mov	r12,r7
800036cc:	f0 1f 00 18 	mcall	8000372c <fl_write_func+0x16c>

	f_close (&fl);
800036d0:	0e 9c       	mov	r12,r7
800036d2:	f0 1f 00 18 	mcall	80003730 <fl_write_func+0x170>
		
	f_mount(NULL, "/", 1);	
800036d6:	30 1a       	mov	r10,1
800036d8:	48 4b       	lddpc	r11,800036e8 <fl_write_func+0x128>
800036da:	30 0c       	mov	r12,0
800036dc:	f0 1f 00 05 	mcall	800036f0 <fl_write_func+0x130>
800036e0:	c0 28       	rjmp	800036e4 <fl_write_func+0x124>
}
800036e2:	30 2c       	mov	r12,2
800036e4:	2f fd       	sub	sp,-4
800036e6:	d8 32       	popm	r0-r7,pc
800036e8:	80 01       	ld.sh	r1,r0[0x0]
800036ea:	05 e4       	ld.ub	r4,r2[0x6]
800036ec:	00 00       	add	r0,r0
800036ee:	0a 70       	tst	r0,r5
800036f0:	80 00       	ld.sh	r0,r0[0x0]
800036f2:	70 d0       	ld.w	r0,r8[0x34]
800036f4:	00 00       	add	r0,r0
800036f6:	0d 48       	ld.w	r8,--r6
800036f8:	80 00       	ld.sh	r0,r0[0x0]
800036fa:	80 9c       	ld.uh	r12,r0[0x2]
800036fc:	00 00       	add	r0,r0
800036fe:	0c e0       	st.h	--r6,r0
80003700:	80 00       	ld.sh	r0,r0[0x0]
80003702:	7e 60       	ld.w	r0,pc[0x18]
80003704:	80 00       	ld.sh	r0,r0[0x0]
80003706:	a8 ee       	st.b	r4[0x6],lr
80003708:	00 00       	add	r0,r0
8000370a:	0d 00       	ld.w	r0,r6++
8000370c:	80 00       	ld.sh	r0,r0[0x0]
8000370e:	a4 6a       	st.h	r2[0xc],r10
80003710:	80 00       	ld.sh	r0,r0[0x0]
80003712:	a9 24       	st.d	r4++,r4
80003714:	80 01       	ld.sh	r1,r0[0x0]
80003716:	05 f4       	ld.ub	r4,r2[0x7]
80003718:	00 00       	add	r0,r0
8000371a:	0c a0       	st.w	r6++,r0
8000371c:	80 00       	ld.sh	r0,r0[0x0]
8000371e:	a8 a0       	st.b	r4[0x2],r0
80003720:	80 01       	ld.sh	r1,r0[0x0]
80003722:	05 fc       	ld.ub	r12,r2[0x7]
80003724:	80 00       	ld.sh	r0,r0[0x0]
80003726:	7e e4       	ld.w	r4,pc[0x38]
80003728:	80 00       	ld.sh	r0,r0[0x0]
8000372a:	83 3c       	st.w	r1[0xc],r12
8000372c:	80 00       	ld.sh	r0,r0[0x0]
8000372e:	85 f0       	st.w	r2[0x3c],r0
80003730:	80 00       	ld.sh	r0,r0[0x0]
80003732:	72 1c       	ld.w	r12,r9[0x4]

80003734 <fl_oper_process>:


static void fl_oper_process(void * pvParameters)
{
80003734:	eb cd 40 f8 	pushm	r3-r7,lr
	fl_oper_t * fl_oper = pvPortMalloc(sizeof(fl_oper_t));
80003738:	30 8c       	mov	r12,8
8000373a:	f0 1f 00 17 	mcall	80003794 <fl_oper_process+0x60>
8000373e:	18 97       	mov	r7,r12
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( fl_oper_queue, fl_oper, portMAX_DELAY ))
80003740:	49 66       	lddpc	r6,80003798 <fl_oper_process+0x64>
80003742:	30 05       	mov	r5,0
80003744:	3f f4       	mov	r4,-1
		{  
			switch(fl_oper->opcode)
80003746:	e0 63 40 00 	mov	r3,16384
static void fl_oper_process(void * pvParameters)
{
	fl_oper_t * fl_oper = pvPortMalloc(sizeof(fl_oper_t));
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( fl_oper_queue, fl_oper, portMAX_DELAY ))
8000374a:	6c 0c       	ld.w	r12,r6[0x0]
8000374c:	0a 99       	mov	r9,r5
8000374e:	08 9a       	mov	r10,r4
80003750:	0e 9b       	mov	r11,r7
80003752:	f0 1f 00 13 	mcall	8000379c <fl_oper_process+0x68>
80003756:	58 1c       	cp.w	r12,1
80003758:	cf 91       	brne	8000374a <fl_oper_process+0x16>
		{  
			switch(fl_oper->opcode)
8000375a:	8e 08       	ld.sh	r8,r7[0x0]
8000375c:	e6 08 19 00 	cp.h	r8,r3
80003760:	c1 31       	brne	80003786 <fl_oper_process+0x52>
			{
			case FL_WRITE:
			
				if(NULL != fl_oper->payload)
80003762:	6e 1c       	ld.w	r12,r7[0x4]
80003764:	58 0c       	cp.w	r12,0
80003766:	cf 20       	breq	8000374a <fl_oper_process+0x16>
				{
					if(NULL != ((fl_write_t *)(fl_oper->payload))->buffer)
80003768:	79 2a       	ld.w	r10,r12[0x48]
8000376a:	58 0a       	cp.w	r10,0
8000376c:	c0 90       	breq	8000377e <fl_oper_process+0x4a>
					{
						fl_write_func(((fl_write_t *)(fl_oper->payload))->path
8000376e:	79 19       	ld.w	r9,r12[0x44]
80003770:	79 0b       	ld.w	r11,r12[0x40]
80003772:	f0 1f 00 0c 	mcall	800037a0 <fl_oper_process+0x6c>
							, ((fl_write_t *)(fl_oper->payload))->offset
							, ((fl_write_t *)(fl_oper->payload))->buffer
							, ((fl_write_t *)(fl_oper->payload))->length);
						
						vPortFree(((fl_write_t *)(fl_oper->payload))->buffer);
80003776:	6e 18       	ld.w	r8,r7[0x4]
80003778:	71 2c       	ld.w	r12,r8[0x48]
8000377a:	f0 1f 00 0b 	mcall	800037a4 <fl_oper_process+0x70>
					}
					vPortFree(fl_oper->payload);					
8000377e:	6e 1c       	ld.w	r12,r7[0x4]
80003780:	f0 1f 00 09 	mcall	800037a4 <fl_oper_process+0x70>
80003784:	ce 3b       	rjmp	8000374a <fl_oper_process+0x16>
				}
				break;
								
			default:
				if(NULL != fl_oper->payload)
80003786:	6e 1c       	ld.w	r12,r7[0x4]
80003788:	58 0c       	cp.w	r12,0
8000378a:	ce 00       	breq	8000374a <fl_oper_process+0x16>
				{
					vPortFree(fl_oper->payload);
8000378c:	f0 1f 00 06 	mcall	800037a4 <fl_oper_process+0x70>
80003790:	cd db       	rjmp	8000374a <fl_oper_process+0x16>
80003792:	00 00       	add	r0,r0
80003794:	80 00       	ld.sh	r0,r0[0x0]
80003796:	8b 60       	st.w	r5[0x18],r0
80003798:	00 00       	add	r0,r0
8000379a:	0d 40       	ld.w	r0,--r6
8000379c:	80 00       	ld.sh	r0,r0[0x0]
8000379e:	8c a8       	ld.uh	r8,r6[0x4]
800037a0:	80 00       	ld.sh	r0,r0[0x0]
800037a2:	35 c0       	mov	r0,92
800037a4:	80 00       	ld.sh	r0,r0[0x0]
800037a6:	8b 38       	st.w	r5[0xc],r8

800037a8 <disk_init>:
APP_RES_OKDISK_OPERATION_ERRORSDFILE_OPERATION_ERROR
*/
//

fs_err_t disk_init(void)
{
800037a8:	d4 01       	pushm	lr
800037aa:	20 3d       	sub	sp,12
	char str[MAX_DISK_LABEL_SIZE];
	
	/*initialize disk*/
	if(MAL_InitConfig())
800037ac:	f0 1f 00 41 	mcall	800038b0 <disk_init+0x108>
800037b0:	5c 8c       	casts.h	r12
800037b2:	c0 30       	breq	800037b8 <disk_init+0x10>
800037b4:	30 1c       	mov	r12,1
800037b6:	c7 a8       	rjmp	800038aa <disk_init+0x102>
	{
		return disk_err;
	}	
		
	if(f_mount(&fs, "/", 1) != FR_OK)
800037b8:	30 1a       	mov	r10,1
800037ba:	4b fb       	lddpc	r11,800038b4 <disk_init+0x10c>
800037bc:	4b fc       	lddpc	r12,800038b8 <disk_init+0x110>
800037be:	f0 1f 00 40 	mcall	800038bc <disk_init+0x114>
800037c2:	c0 30       	breq	800037c8 <disk_init+0x20>
800037c4:	30 2c       	mov	r12,2
800037c6:	c7 28       	rjmp	800038aa <disk_init+0x102>
	{
		return amount_err;
	}
	
	FRESULT res = f_getfree("/", &clust, &pfs);
800037c8:	4b ea       	lddpc	r10,800038c0 <disk_init+0x118>
800037ca:	4b fb       	lddpc	r11,800038c4 <disk_init+0x11c>
800037cc:	4b ac       	lddpc	r12,800038b4 <disk_init+0x10c>
800037ce:	f0 1f 00 3f 	mcall	800038c8 <disk_init+0x120>
	if(res == FR_NO_FILESYSTEM) 
800037d2:	58 dc       	cp.w	r12,13
800037d4:	c1 41       	brne	800037fc <disk_init+0x54>
	{
		/* Create a file system on the drive */
		res = f_mkfs (0, 0, 4096);
800037d6:	e0 6a 10 00 	mov	r10,4096
800037da:	30 0b       	mov	r11,0
800037dc:	16 9c       	mov	r12,r11
800037de:	f0 1f 00 3c 	mcall	800038cc <disk_init+0x124>
		if( f_getfree("/", &clust, &pfs) != FR_OK)
800037e2:	4b 8a       	lddpc	r10,800038c0 <disk_init+0x118>
800037e4:	4b 8b       	lddpc	r11,800038c4 <disk_init+0x11c>
800037e6:	4b 4c       	lddpc	r12,800038b4 <disk_init+0x10c>
800037e8:	f0 1f 00 38 	mcall	800038c8 <disk_init+0x120>
800037ec:	c1 10       	breq	8000380e <disk_init+0x66>
		{
			f_mount(NULL, "/", 1);	
800037ee:	30 1a       	mov	r10,1
800037f0:	4b 1b       	lddpc	r11,800038b4 <disk_init+0x10c>
800037f2:	30 0c       	mov	r12,0
800037f4:	f0 1f 00 32 	mcall	800038bc <disk_init+0x114>
800037f8:	30 5c       	mov	r12,5
			return no_fs;
800037fa:	c5 88       	rjmp	800038aa <disk_init+0x102>
		}
	}
	else if(res != FR_OK)
800037fc:	58 0c       	cp.w	r12,0
800037fe:	c0 80       	breq	8000380e <disk_init+0x66>
	{
		f_mount(NULL, "/", 1);
80003800:	30 1a       	mov	r10,1
80003802:	4a db       	lddpc	r11,800038b4 <disk_init+0x10c>
80003804:	30 0c       	mov	r12,0
80003806:	f0 1f 00 2e 	mcall	800038bc <disk_init+0x114>
8000380a:	30 6c       	mov	r12,6
		return fs_err;
8000380c:	c4 f8       	rjmp	800038aa <disk_init+0x102>
	}
	
	
	//pdisk->freecap = ((clust*(pfs->csize)/1024/1024)*512);
	
	memset(str,0,MAX_DISK_LABEL_SIZE);
8000380e:	1a 9b       	mov	r11,sp
80003810:	30 08       	mov	r8,0
80003812:	30 09       	mov	r9,0
80003814:	fa e9 00 00 	st.d	sp[0],r8
80003818:	30 0a       	mov	r10,0
8000381a:	50 2a       	stdsp	sp[0x8],r10
	if(f_getlabel("/", str, 0) != FR_OK)
8000381c:	4a 6c       	lddpc	r12,800038b4 <disk_init+0x10c>
8000381e:	f0 1f 00 2d 	mcall	800038d0 <disk_init+0x128>
80003822:	c0 80       	breq	80003832 <disk_init+0x8a>
	{
		f_mount(NULL, "/", 1);
80003824:	30 1a       	mov	r10,1
80003826:	4a 4b       	lddpc	r11,800038b4 <disk_init+0x10c>
80003828:	30 0c       	mov	r12,0
8000382a:	f0 1f 00 25 	mcall	800038bc <disk_init+0x114>
8000382e:	30 6c       	mov	r12,6
		return fs_err;
80003830:	c3 d8       	rjmp	800038aa <disk_init+0x102>
	}
		
	if(memcmp(DiskLabel, str, sizeof(DiskLabel) - 1) != 0)
80003832:	30 7a       	mov	r10,7
80003834:	1a 9b       	mov	r11,sp
80003836:	4a 8c       	lddpc	r12,800038d4 <disk_init+0x12c>
80003838:	f0 1f 00 28 	mcall	800038d8 <disk_init+0x130>
8000383c:	c0 c0       	breq	80003854 <disk_init+0xac>
	{
		if(f_setlabel("MOTOREC") != FR_OK)
8000383e:	4a 8c       	lddpc	r12,800038dc <disk_init+0x134>
80003840:	f0 1f 00 28 	mcall	800038e0 <disk_init+0x138>
80003844:	c0 80       	breq	80003854 <disk_init+0xac>
		{
			f_mount(NULL, "/", 1);
80003846:	30 1a       	mov	r10,1
80003848:	49 bb       	lddpc	r11,800038b4 <disk_init+0x10c>
8000384a:	30 0c       	mov	r12,0
8000384c:	f0 1f 00 1c 	mcall	800038bc <disk_init+0x114>
80003850:	30 6c       	mov	r12,6
			return fs_err;
80003852:	c2 c8       	rjmp	800038aa <disk_init+0x102>
		}
	}
			
	if ( f_opendir(&dirs, "/") == FR_OK)
80003854:	49 8b       	lddpc	r11,800038b4 <disk_init+0x10c>
80003856:	4a 4c       	lddpc	r12,800038e4 <disk_init+0x13c>
80003858:	f0 1f 00 24 	mcall	800038e8 <disk_init+0x140>
8000385c:	c2 11       	brne	8000389e <disk_init+0xf6>
	{
		if(f_open(&fl, "sys.ini", FA_CREATE_ALWAYS | FA_WRITE) == FR_OK )
8000385e:	30 aa       	mov	r10,10
80003860:	4a 3b       	lddpc	r11,800038ec <disk_init+0x144>
80003862:	4a 4c       	lddpc	r12,800038f0 <disk_init+0x148>
80003864:	f0 1f 00 24 	mcall	800038f4 <disk_init+0x14c>
80003868:	c1 41       	brne	80003890 <disk_init+0xe8>
		{
			f_close(&fl);
8000386a:	4a 2c       	lddpc	r12,800038f0 <disk_init+0x148>
8000386c:	f0 1f 00 23 	mcall	800038f8 <disk_init+0x150>
		{
			f_mount(NULL, "/", 1);
			return fs_err;
		}
				
		f_mkdir("/REC");			
80003870:	4a 3c       	lddpc	r12,800038fc <disk_init+0x154>
80003872:	f0 1f 00 24 	mcall	80003900 <disk_init+0x158>
		f_mkdir("/REC/ZONE01");			
80003876:	4a 4c       	lddpc	r12,80003904 <disk_init+0x15c>
80003878:	f0 1f 00 22 	mcall	80003900 <disk_init+0x158>
		f_mkdir("/REC/ZONE01/CH01");		
8000387c:	4a 3c       	lddpc	r12,80003908 <disk_init+0x160>
8000387e:	f0 1f 00 21 	mcall	80003900 <disk_init+0x158>
	{
		f_mount(NULL, "/", 1);
		return fs_err;
	}
	
	f_mount(NULL, "/", 1);		
80003882:	30 1a       	mov	r10,1
80003884:	48 cb       	lddpc	r11,800038b4 <disk_init+0x10c>
80003886:	30 0c       	mov	r12,0
80003888:	f0 1f 00 0d 	mcall	800038bc <disk_init+0x114>
8000388c:	30 0c       	mov	r12,0
	return fs_ok;
8000388e:	c0 e8       	rjmp	800038aa <disk_init+0x102>
		{
			f_close(&fl);
		}
		else 
		{
			f_mount(NULL, "/", 1);
80003890:	30 1a       	mov	r10,1
80003892:	48 9b       	lddpc	r11,800038b4 <disk_init+0x10c>
80003894:	30 0c       	mov	r12,0
80003896:	f0 1f 00 0a 	mcall	800038bc <disk_init+0x114>
8000389a:	30 6c       	mov	r12,6
			return fs_err;
8000389c:	c0 78       	rjmp	800038aa <disk_init+0x102>
		f_mkdir("/REC/ZONE01");			
		f_mkdir("/REC/ZONE01/CH01");		
	}
	else 
	{
		f_mount(NULL, "/", 1);
8000389e:	30 1a       	mov	r10,1
800038a0:	48 5b       	lddpc	r11,800038b4 <disk_init+0x10c>
800038a2:	30 0c       	mov	r12,0
800038a4:	f0 1f 00 06 	mcall	800038bc <disk_init+0x114>
800038a8:	30 6c       	mov	r12,6
		return fs_err;
	}
	
	f_mount(NULL, "/", 1);		
	return fs_ok;
}
800038aa:	2f dd       	sub	sp,-12
800038ac:	d8 02       	popm	pc
800038ae:	00 00       	add	r0,r0
800038b0:	80 00       	ld.sh	r0,r0[0x0]
800038b2:	35 14       	mov	r4,81
800038b4:	80 01       	ld.sh	r1,r0[0x0]
800038b6:	05 e4       	ld.ub	r4,r2[0x6]
800038b8:	00 00       	add	r0,r0
800038ba:	0a 70       	tst	r0,r5
800038bc:	80 00       	ld.sh	r0,r0[0x0]
800038be:	70 d0       	ld.w	r0,r8[0x34]
800038c0:	00 00       	add	r0,r0
800038c2:	0d 44       	ld.w	r4,--r6
800038c4:	00 00       	add	r0,r0
800038c6:	0a 6c       	and	r12,r5
800038c8:	80 00       	ld.sh	r0,r0[0x0]
800038ca:	82 50       	ld.sh	r0,r1[0xa]
800038cc:	80 00       	ld.sh	r0,r0[0x0]
800038ce:	65 94       	ld.w	r4,r2[0x64]
800038d0:	80 00       	ld.sh	r0,r0[0x0]
800038d2:	77 cc       	ld.w	r12,r11[0x70]
800038d4:	00 00       	add	r0,r0
800038d6:	04 f4       	st.b	--r2,r4
800038d8:	80 00       	ld.sh	r0,r0[0x0]
800038da:	a4 44       	st.h	r2[0x8],r4
800038dc:	80 01       	ld.sh	r1,r0[0x0]
800038de:	06 04       	add	r4,r3
800038e0:	80 00       	ld.sh	r0,r0[0x0]
800038e2:	79 18       	ld.w	r8,r12[0x44]
800038e4:	00 00       	add	r0,r0
800038e6:	0c e0       	st.h	--r6,r0
800038e8:	80 00       	ld.sh	r0,r0[0x0]
800038ea:	7e 60       	ld.w	r0,pc[0x18]
800038ec:	80 01       	ld.sh	r1,r0[0x0]
800038ee:	06 0c       	add	r12,r3
800038f0:	00 00       	add	r0,r0
800038f2:	0d 48       	ld.w	r8,--r6
800038f4:	80 00       	ld.sh	r0,r0[0x0]
800038f6:	80 9c       	ld.uh	r12,r0[0x2]
800038f8:	80 00       	ld.sh	r0,r0[0x0]
800038fa:	72 1c       	ld.w	r12,r9[0x4]
800038fc:	80 01       	ld.sh	r1,r0[0x0]
800038fe:	06 14       	sub	r4,r3
80003900:	80 00       	ld.sh	r0,r0[0x0]
80003902:	7e e4       	ld.w	r4,pc[0x38]
80003904:	80 01       	ld.sh	r1,r0[0x0]
80003906:	06 1c       	sub	r12,r3
80003908:	80 01       	ld.sh	r1,r0[0x0]
8000390a:	06 28       	rsub	r8,r3

8000390c <fs_init>:
	}
	
}

fs_err_t fs_init(void)
{
8000390c:	eb cd 40 80 	pushm	r7,lr
	fs_err_t res = disk_init();
80003910:	f0 1f 00 0d 	mcall	80003944 <fs_init+0x38>
80003914:	18 97       	mov	r7,r12
	if( fs_ok ==  res)
80003916:	c1 31       	brne	8000393c <fs_init+0x30>
	{
		fl_oper_queue = xQueueCreate(50, sizeof(fl_oper_t)); //50*512bytes = 25k
80003918:	30 8b       	mov	r11,8
8000391a:	33 2c       	mov	r12,50
8000391c:	f0 1f 00 0b 	mcall	80003948 <fs_init+0x3c>
80003920:	48 b8       	lddpc	r8,8000394c <fs_init+0x40>
80003922:	91 0c       	st.w	r8[0x0],r12
		
		/*create a task for files operation*/
		xTaskCreate(
80003924:	30 09       	mov	r9,0
80003926:	1a d9       	st.w	--sp,r9
80003928:	1a d9       	st.w	--sp,r9
8000392a:	1a d9       	st.w	--sp,r9
8000392c:	30 28       	mov	r8,2
8000392e:	e0 6a 02 00 	mov	r10,512
80003932:	48 8b       	lddpc	r11,80003950 <fs_init+0x44>
80003934:	48 8c       	lddpc	r12,80003954 <fs_init+0x48>
80003936:	f0 1f 00 09 	mcall	80003958 <fs_init+0x4c>
		,  NULL
		,  2//1
		,  NULL
		);		
		
		return fs_ok;		
8000393a:	2f dd       	sub	sp,-12
	}
	else
	{
		return res;
	}
}
8000393c:	0e 9c       	mov	r12,r7
8000393e:	e3 cd 80 80 	ldm	sp++,r7,pc
80003942:	00 00       	add	r0,r0
80003944:	80 00       	ld.sh	r0,r0[0x0]
80003946:	37 a8       	mov	r8,122
80003948:	80 00       	ld.sh	r0,r0[0x0]
8000394a:	90 0c       	ld.sh	r12,r8[0x0]
8000394c:	00 00       	add	r0,r0
8000394e:	0d 40       	ld.w	r0,--r6
80003950:	80 01       	ld.sh	r1,r0[0x0]
80003952:	06 3c       	cp.w	r12,r3
80003954:	80 00       	ld.sh	r0,r0[0x0]
80003956:	37 34       	mov	r4,115
80003958:	80 00       	ld.sh	r0,r0[0x0]
8000395a:	96 e0       	ld.uh	r0,r11[0xc]

8000395c <CalculateBurst>:
Calls:
Called By: phy_payload_rx
*/

volatile RxAMBEBurstType CalculateBurst(U8 vf_sn)
{
8000395c:	20 1c       	sub	r12,1
8000395e:	5c 5c       	castu.b	r12
80003960:	31 18       	mov	r8,17
80003962:	f0 0c 18 00 	cp.b	r12,r8
80003966:	e0 88 00 03 	brls	8000396c <CalculateBurst+0x10>
8000396a:	5e fd       	retal	0
8000396c:	48 28       	lddpc	r8,80003974 <CalculateBurst+0x18>
8000396e:	f0 0c 03 2c 	ld.w	r12,r8[r12<<0x2]
			Burst_ID = 0x00;
			return VOICE_WATING;
		
	}
	
}
80003972:	5e fc       	retal	r12
80003974:	80 01       	ld.sh	r1,r0[0x0]
80003976:	06 54       	eor	r4,r3

80003978 <payload_init>:
	Create the corresponding task;
Calls: xTaskCreate--freertos
Called By:app_init -- app.c
*/
void payload_init(void ( *payload_rx_func)(void * ), void ( *payload_tx_func)(void * ) )
{				
80003978:	d4 01       	pushm	lr
	payload_rx_exec = payload_rx_func;
8000397a:	48 98       	lddpc	r8,8000399c <payload_init+0x24>
8000397c:	91 0c       	st.w	r8[0x0],r12
	payload_tx_exec = payload_tx_func;
8000397e:	48 98       	lddpc	r8,800039a0 <payload_init+0x28>
80003980:	91 0b       	st.w	r8[0x0],r11
	
	
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
80003982:	30 09       	mov	r9,0
80003984:	1a d9       	st.w	--sp,r9
80003986:	1a d9       	st.w	--sp,r9
80003988:	1a d9       	st.w	--sp,r9
8000398a:	30 28       	mov	r8,2
8000398c:	e0 6a 04 00 	mov	r10,1024
80003990:	48 5b       	lddpc	r11,800039a4 <payload_init+0x2c>
80003992:	48 6c       	lddpc	r12,800039a8 <payload_init+0x30>
80003994:	f0 1f 00 06 	mcall	800039ac <payload_init+0x34>
80003998:	2f dd       	sub	sp,-12
	
	
	
	
	
}
8000399a:	d8 02       	popm	pc
8000399c:	00 00       	add	r0,r0
8000399e:	0f 70       	ld.ub	r0,--r7
800039a0:	00 00       	add	r0,r0
800039a2:	0f 74       	ld.ub	r4,--r7
800039a4:	80 01       	ld.sh	r1,r0[0x0]
800039a6:	06 9c       	mov	r12,r3
800039a8:	80 00       	ld.sh	r0,r0[0x0]
800039aa:	39 b0       	mov	r0,-101
800039ac:	80 00       	ld.sh	r0,r0[0x0]
800039ae:	96 e0       	ld.uh	r0,r11[0xc]

800039b0 <payload_rx_process>:
Description: Receive the payload
Calls:
Called By:task
*/
static void payload_rx_process(void * pvParameters)
{
800039b0:	eb cd 40 f8 	pushm	r3-r7,lr
800039b4:	20 1d       	sub	sp,4
	/*To store the elements in the queue*/
	U16  * payload_ptr;
		
	if(NULL ==   phy_payload_frame_rx)
800039b6:	48 e8       	lddpc	r8,800039ec <payload_rx_process+0x3c>
800039b8:	70 08       	ld.w	r8,r8[0x0]
800039ba:	58 08       	cp.w	r8,0
800039bc:	c0 71       	brne	800039ca <payload_rx_process+0x1a>
	{
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
800039be:	30 4b       	mov	r11,4
800039c0:	30 5c       	mov	r12,5
800039c2:	f0 1f 00 0c 	mcall	800039f0 <payload_rx_process+0x40>
800039c6:	48 a8       	lddpc	r8,800039ec <payload_rx_process+0x3c>
800039c8:	91 0c       	st.w	r8[0x0],r12
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_rx, &payload_ptr,portMAX_DELAY ))
800039ca:	48 96       	lddpc	r6,800039ec <payload_rx_process+0x3c>
800039cc:	30 05       	mov	r5,0
800039ce:	3f f4       	mov	r4,-1
		{			
			payload_rx_exec(payload_ptr);//app_payload_rx_proc();
800039d0:	48 93       	lddpc	r3,800039f4 <payload_rx_process+0x44>
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_rx, &payload_ptr,portMAX_DELAY ))
800039d2:	6c 0c       	ld.w	r12,r6[0x0]
800039d4:	0a 99       	mov	r9,r5
800039d6:	08 9a       	mov	r10,r4
800039d8:	1a 9b       	mov	r11,sp
800039da:	f0 1f 00 08 	mcall	800039f8 <payload_rx_process+0x48>
800039de:	58 1c       	cp.w	r12,1
800039e0:	cf 91       	brne	800039d2 <payload_rx_process+0x22>
		{			
			payload_rx_exec(payload_ptr);//app_payload_rx_proc();
800039e2:	66 08       	ld.w	r8,r3[0x0]
800039e4:	40 0c       	lddsp	r12,sp[0x0]
800039e6:	5d 18       	icall	r8
800039e8:	cf 5b       	rjmp	800039d2 <payload_rx_process+0x22>
800039ea:	00 00       	add	r0,r0
800039ec:	00 00       	add	r0,r0
800039ee:	0f 8c       	ld.ub	r12,r7[0x0]
800039f0:	80 00       	ld.sh	r0,r0[0x0]
800039f2:	90 0c       	ld.sh	r12,r8[0x0]
800039f4:	00 00       	add	r0,r0
800039f6:	0f 70       	ld.ub	r0,--r7
800039f8:	80 00       	ld.sh	r0,r0[0x0]
800039fa:	8c a8       	ld.uh	r8,r6[0x4]

800039fc <set_idle_store_isr>:
{
	xQueueSend(store, &ptr, 0);
}

void set_idle_store_isr(xQueueHandle store, void * ptr)
{
800039fc:	d4 01       	pushm	lr
800039fe:	20 2d       	sub	sp,8
80003a00:	50 0b       	stdsp	sp[0x0],r11
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80003a02:	30 09       	mov	r9,0
80003a04:	fa ca ff f8 	sub	r10,sp,-8
80003a08:	14 d9       	st.w	--r10,r9
	xQueueSendFromISR(store, &ptr, &xHigherPriorityTaskWoken);
80003a0a:	1a 9b       	mov	r11,sp
80003a0c:	f0 1f 00 02 	mcall	80003a14 <set_idle_store_isr+0x18>
}
80003a10:	2f ed       	sub	sp,-8
80003a12:	d8 02       	popm	pc
80003a14:	80 00       	ld.sh	r0,r0[0x0]
80003a16:	8e 64       	ld.sh	r4,r7[0xc]

80003a18 <phy_rx>:
	xQueueSendFromISR -- freertos
Called By: phy_xnl_rx
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
80003a18:	d4 01       	pushm	lr
80003a1a:	20 2d       	sub	sp,8
80003a1c:	50 0c       	stdsp	sp[0x0],r12
	//memcpy(xx, phy_ptr, sizeof(phy_fragment_t));
	//set_phy_idle_isr(&phy_ptr, &xHigherPriorityTaskWoken);
	
	Bool res = FALSE;
	
	if(NULL == phy_ptr)
80003a1e:	58 0c       	cp.w	r12,0
80003a20:	c1 10       	breq	80003a42 <phy_rx+0x2a>
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
    /*variables are used to store the push result in interrupt*/
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80003a22:	30 08       	mov	r8,0
80003a24:	50 18       	stdsp	sp[0x4],r8
	if(NULL == phy_ptr)
	{
		return;
	}
	
    U16 phy_ctrl = phy_ptr->xnl_fragment.phy_header.phy_control;
80003a26:	98 88       	ld.uh	r8,r12[0x0]
80003a28:	e2 18 f0 00 	andl	r8,0xf000,COH
80003a2c:	e0 48 40 00 	cp.w	r8,16384
80003a30:	c0 91       	brne	80003a42 <phy_rx+0x2a>

    if (XCMPXNL_DATA == (phy_ctrl & 0xF000))
    {
        /*push the xnl packet to queue*/
        if( pdTRUE == xQueueSendFromISR(
80003a32:	48 68       	lddpc	r8,80003a48 <phy_rx+0x30>
80003a34:	70 0c       	ld.w	r12,r8[0x0]
80003a36:	30 09       	mov	r9,0
80003a38:	fa ca ff fc 	sub	r10,sp,-4
80003a3c:	1a 9b       	mov	r11,sp
80003a3e:	f0 1f 00 04 	mcall	80003a4c <phy_rx+0x34>
		}	

    }
		
 
}
80003a42:	2f ed       	sub	sp,-8
80003a44:	d8 02       	popm	pc
80003a46:	00 00       	add	r0,r0
80003a48:	00 00       	add	r0,r0
80003a4a:	0f cc       	ld.ub	r12,r7[0x4]
80003a4c:	80 00       	ld.sh	r0,r0[0x0]
80003a4e:	8e 64       	ld.sh	r4,r7[0xc]

80003a50 <set_idle_store>:
	}
}


void set_idle_store(xQueueHandle store, void * ptr)
{
80003a50:	eb cd 40 80 	pushm	r7,lr
80003a54:	20 1d       	sub	sp,4
80003a56:	fa c7 ff fc 	sub	r7,sp,-4
80003a5a:	0e db       	st.w	--r7,r11
	xQueueSend(store, &ptr, 0);
80003a5c:	30 09       	mov	r9,0
80003a5e:	12 9a       	mov	r10,r9
80003a60:	1a 9b       	mov	r11,sp
80003a62:	f0 1f 00 03 	mcall	80003a6c <set_idle_store+0x1c>
}
80003a66:	2f fd       	sub	sp,-4
80003a68:	e3 cd 80 80 	ldm	sp++,r7,pc
80003a6c:	80 00       	ld.sh	r0,r0[0x0]
80003a6e:	8e b4       	ld.uh	r4,r7[0x6]

80003a70 <phy_tx>:
Calls:   
	xQueueSend -- freertos
Called By: xnl_tx -- xnl.c
*/
void phy_tx(phy_fragment_t * phy)
{	
80003a70:	d4 01       	pushm	lr
80003a72:	20 1d       	sub	sp,4
80003a74:	50 0c       	stdsp	sp[0x0],r12
	
	//phy_fragment_t * phy_ptr = malloc(sizeof(phy_fragment_t));
	//memcpy(phy_ptr, phy, sizeof(phy_fragment_t));
	//log("\n\r T_xcmp:%4x \n\r", phy->xnl_fragment.xnl_payload.xnl_content_data_msg.xcmp_opcode);
	//log("T_xnl-opcode:%4x", xnl->xnl_header.opcode);//log:R_xnl	
	if(XCMPXNL_DATA == (phy_ctrl & 0xF000))
80003a76:	98 88       	ld.uh	r8,r12[0x0]
80003a78:	e2 18 f0 00 	andl	r8,0xf000,COH
80003a7c:	e0 48 40 00 	cp.w	r8,16384
80003a80:	c0 d1       	brne	80003a9a <phy_tx+0x2a>
	{
		/*push the xnl packet to queue to send */
		if(NULL != phy_xnl_frame_tx)
80003a82:	49 08       	lddpc	r8,80003ac0 <phy_tx+0x50>
80003a84:	70 08       	ld.w	r8,r8[0x0]
80003a86:	58 08       	cp.w	r8,0
80003a88:	c1 a0       	breq	80003abc <phy_tx+0x4c>
		{
			if( pdTRUE == xQueueSend(phy_xnl_frame_tx, &phy, 0))
80003a8a:	48 e8       	lddpc	r8,80003ac0 <phy_tx+0x50>
80003a8c:	70 0c       	ld.w	r12,r8[0x0]
80003a8e:	30 09       	mov	r9,0
80003a90:	12 9a       	mov	r10,r9
80003a92:	1a 9b       	mov	r11,sp
80003a94:	f0 1f 00 0c 	mcall	80003ac4 <phy_tx+0x54>
80003a98:	c1 28       	rjmp	80003abc <phy_tx+0x4c>
		}
	}
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE		
	else if((SPEAKER_DATA == (phy_ctrl & 0xF000))
80003a9a:	e0 48 10 00 	cp.w	r8,4096
80003a9e:	5f 0a       	sreq	r10
80003aa0:	e0 48 20 00 	cp.w	r8,8192
80003aa4:	5f 09       	sreq	r9
80003aa6:	f5 e9 10 09 	or	r9,r10,r9
80003aaa:	c0 71       	brne	80003ab8 <phy_tx+0x48>
80003aac:	e0 48 50 00 	cp.w	r8,20480
80003ab0:	c0 40       	breq	80003ab8 <phy_tx+0x48>
80003ab2:	e0 48 60 00 	cp.w	r8,24576
80003ab6:	c0 31       	brne	80003abc <phy_tx+0x4c>
	    || (MIC_DATA  == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_RX == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_TX == (phy_ctrl & 0xF000))
	)
	{		
		if(NULL == phy_payload_frame_tx)
80003ab8:	48 48       	lddpc	r8,80003ac8 <phy_tx+0x58>
80003aba:	70 08       	ld.w	r8,r8[0x0]
	
	if(res != TRUE)
	{
		//vPortFree(phy_ptr);
	}
}
80003abc:	2f fd       	sub	sp,-4
80003abe:	d8 02       	popm	pc
80003ac0:	00 00       	add	r0,r0
80003ac2:	0f e0       	ld.ub	r0,r7[0x6]
80003ac4:	80 00       	ld.sh	r0,r0[0x0]
80003ac6:	8e b4       	ld.uh	r4,r7[0x6]
80003ac8:	00 00       	add	r0,r0
80003aca:	0f c4       	ld.ub	r4,r7[0x4]

80003acc <get_idle_store_isr>:
		return NULL;
	}
}

void * get_idle_store_isr(xQueueHandle store)
{
80003acc:	d4 01       	pushm	lr
80003ace:	20 2d       	sub	sp,8
	void * ptr = NULL;
80003ad0:	30 08       	mov	r8,0
80003ad2:	50 18       	stdsp	sp[0x4],r8
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80003ad4:	50 08       	stdsp	sp[0x0],r8
	
	if(pdTRUE == xQueueReceiveFromISR(store, &ptr, &xHigherPriorityTaskWoken))
80003ad6:	1a 9a       	mov	r10,sp
80003ad8:	fa cb ff fc 	sub	r11,sp,-4
80003adc:	f0 1f 00 05 	mcall	80003af0 <get_idle_store_isr+0x24>
80003ae0:	58 1c       	cp.w	r12,1
80003ae2:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80003ae6:	fb fc 00 01 	ld.weq	r12,sp[0x4]
	}
	else
	{
		return NULL;
	}
}
80003aea:	2f ed       	sub	sp,-8
80003aec:	d8 02       	popm	pc
80003aee:	00 00       	add	r0,r0
80003af0:	80 00       	ld.sh	r0,r0[0x0]
80003af2:	8b b8       	st.w	r5[0x2c],r8

80003af4 <phy_tx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_tx_func( void * ssc)
{
80003af4:	eb cd 40 c0 	pushm	r6-r7,lr
80003af8:	20 1d       	sub	sp,4
80003afa:	18 97       	mov	r7,r12
    if(NULL != phy_xnl_frame_tx)
80003afc:	fe f8 05 54 	ld.w	r8,pc[1364]
80003b00:	70 08       	ld.w	r8,r8[0x0]
80003b02:	58 08       	cp.w	r8,0
80003b04:	c7 40       	breq	80003bec <phy_tx_func+0xf8>
    {
  	  	/*send ssc data in xnl frame*/
  	  	phy_xnl_tx(&(((ssc_fragment_t * )ssc)->xnl_channel));		
80003b06:	18 96       	mov	r6,r12
Called By:phy_tx_func
*/
static void phy_xnl_tx(xnl_channel_t * xnl_tx_channel)
{
	/*variables are used to store the push result in interrupt*/
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80003b08:	30 08       	mov	r8,0
80003b0a:	50 08       	stdsp	sp[0x0],r8
	
	static S16 phy_tx_expexted_length = 0;
	static U8 phy_tx_index = 0;
	
	/*his is the code for handling any outgoing XNL Phy message*/
	switch(phy_tx_state)
80003b0c:	fe f8 05 48 	ld.w	r8,pc[1352]
80003b10:	70 08       	ld.w	r8,r8[0x0]
80003b12:	58 18       	cp.w	r8,1
80003b14:	c2 90       	breq	80003b66 <phy_tx_func+0x72>
80003b16:	c0 43       	brcs	80003b1e <phy_tx_func+0x2a>
80003b18:	58 28       	cp.w	r8,2
80003b1a:	c6 91       	brne	80003bec <phy_tx_func+0xf8>
80003b1c:	c6 18       	rjmp	80003bde <phy_tx_func+0xea>
	{
		/*Waiting for the send xnl packet*/
		case WAITING_FOR_PHY_TX:			
			if( pdTRUE == xQueueReceiveFromISR(
80003b1e:	fe f8 05 32 	ld.w	r8,pc[1330]
80003b22:	70 0c       	ld.w	r12,r8[0x0]
80003b24:	1a 9a       	mov	r10,sp
80003b26:	fe fb 05 32 	ld.w	r11,pc[1330]
80003b2a:	f0 1f 01 4d 	mcall	8000405c <phy_tx_func+0x568>
80003b2e:	58 1c       	cp.w	r12,1
80003b30:	c1 51       	brne	80003b5a <phy_tx_func+0x66>
				  phy_xnl_frame_tx
				, &phy_ptr
				, &xHigherPriorityTaskWoken 
			))
			{								
				phy_tx_expexted_length = 
80003b32:	fe f8 05 26 	ld.w	r8,pc[1318]
80003b36:	70 08       	ld.w	r8,r8[0x0]
80003b38:	11 9a       	ld.ub	r10,r8[0x1]
80003b3a:	fe f9 05 26 	ld.w	r9,pc[1318]
80003b3e:	b2 0a       	st.h	r9[0x0],r10
				*/
				xnl_tx_channel->dword = 
				                   phy_ptr->xnl_fragment.phy_header.phy_control;
				
				/*Transmit 0xABCD0000 | Type/Length.*/
				xnl_tx_channel->dword |= PHYHEADER32;
80003b40:	90 88       	ld.uh	r8,r8[0x0]
80003b42:	ea 18 ab cd 	orh	r8,0xabcd
80003b46:	8f 18       	st.w	r7[0x4],r8
				
				phy_tx_index = 1;
80003b48:	30 19       	mov	r9,1
80003b4a:	fe f8 05 1a 	ld.w	r8,pc[1306]
80003b4e:	b0 89       	st.b	r8[0x0],r9
				phy_tx_state = WRITE_NEXT_DWORD;	
80003b50:	30 19       	mov	r9,1
80003b52:	fe f8 05 02 	ld.w	r8,pc[1282]
80003b56:	91 09       	st.w	r8[0x0],r9
80003b58:	c4 a8       	rjmp	80003bec <phy_tx_func+0xf8>
				/*The new transmission has started.*/
			}
			else
			{
				/*Nothing new to transmit, send an idle frame*/
				xnl_tx_channel->dword = XNL_IDLE;
80003b5a:	e0 68 5a 5a 	mov	r8,23130
80003b5e:	ea 18 ab cd 	orh	r8,0xabcd
80003b62:	8f 18       	st.w	r7[0x4],r8
80003b64:	c4 48       	rjmp	80003bec <phy_tx_func+0xf8>
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80003b66:	fe f9 04 fe 	ld.w	r9,pc[1278]
80003b6a:	13 88       	ld.ub	r8,r9[0x0]
				xnl_tx_channel->dword = XNL_IDLE;
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
80003b6c:	fe fa 04 ec 	ld.w	r10,pc[1260]
80003b70:	74 0a       	ld.w	r10,r10[0x0]
80003b72:	f4 08 05 1a 	ld.uh	r10,r10[r8<<0x1]
80003b76:	b1 6a       	lsl	r10,0x10
80003b78:	99 1a       	st.w	r12[0x4],r10
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80003b7a:	2f f8       	sub	r8,-1
80003b7c:	5c 58       	castu.b	r8
80003b7e:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
80003b80:	fe fa 04 e0 	ld.w	r10,pc[1248]
80003b84:	94 09       	ld.sh	r9,r10[0x0]
80003b86:	20 29       	sub	r9,2
80003b88:	b4 09       	st.h	r10[0x0],r9
			
			/*have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80003b8a:	30 0a       	mov	r10,0
80003b8c:	f4 09 19 00 	cp.h	r9,r10
80003b90:	e0 89 00 0b 	brgt	80003ba6 <phy_tx_func+0xb2>
			{
				/*Must immediately send 0x00BA in Slot 4.*/
				xnl_tx_channel->dword |= PHYTERMRIGHT;
80003b94:	78 18       	ld.w	r8,r12[0x4]
80003b96:	e8 18 00 ba 	orl	r8,0xba
80003b9a:	99 18       	st.w	r12[0x4],r8
				
				/*Go back to waiting.*/
				//vPortFree(phy_ptr);
				phy_tx_state = WAITING_FOR_PHY_TX;
80003b9c:	30 09       	mov	r9,0
80003b9e:	fe f8 04 b6 	ld.w	r8,pc[1206]
80003ba2:	91 09       	st.w	r8[0x0],r9
80003ba4:	c2 48       	rjmp	80003bec <phy_tx_func+0xf8>
				break;
			}

			/*Have not broken. Transmit 2nd hWord.*/
			xnl_tx_channel->dword |=  phy_ptr->fragment_element[phy_tx_index++];
80003ba6:	fe f9 04 b2 	ld.w	r9,pc[1202]
80003baa:	72 09       	ld.w	r9,r9[0x0]
80003bac:	f2 08 05 19 	ld.uh	r9,r9[r8<<0x1]
80003bb0:	78 1a       	ld.w	r10,r12[0x4]
80003bb2:	f5 e9 10 09 	or	r9,r10,r9
80003bb6:	99 19       	st.w	r12[0x4],r9
80003bb8:	2f f8       	sub	r8,-1
80003bba:	fe f9 04 aa 	ld.w	r9,pc[1194]
80003bbe:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
80003bc0:	fe f9 04 a0 	ld.w	r9,pc[1184]
80003bc4:	92 08       	ld.sh	r8,r9[0x0]
80003bc6:	20 28       	sub	r8,2
80003bc8:	b2 08       	st.h	r9[0x0],r8
			
			/*Have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80003bca:	30 09       	mov	r9,0
80003bcc:	f2 08 19 00 	cp.h	r8,r9
80003bd0:	e0 89 00 0e 	brgt	80003bec <phy_tx_func+0xf8>
			{
				/*Must send 0x00BA0000 next interrupt in Slot 3&4*/
				phy_tx_state = SEND_TAILED;
80003bd4:	30 29       	mov	r9,2
80003bd6:	fe f8 04 7e 	ld.w	r8,pc[1150]
80003bda:	91 09       	st.w	r8[0x0],r9
80003bdc:	c0 88       	rjmp	80003bec <phy_tx_func+0xf8>
			}
			break;

		case SEND_TAILED:
			/*send 0x00BA0000*/
			xnl_tx_channel->dword = PHYTERMLEFT;
80003bde:	fc 18 00 ba 	movh	r8,0xba
80003be2:	99 18       	st.w	r12[0x4],r8
			
			/*Go back to waiting.*/	
			//vPortFree(phy_ptr);		
			phy_tx_state = WAITING_FOR_PHY_TX;		
80003be4:	30 09       	mov	r9,0
80003be6:	fe f8 04 6e 	ld.w	r8,pc[1134]
80003bea:	91 09       	st.w	r8[0x0],r9
	static U32 i = 0;
	//static U8 frame_5_end = 0;
	//static U16 pay[256];
	
	//Send-AMBE-data
	if (AMBE_flag)
80003bec:	fe f8 04 7c 	ld.w	r8,pc[1148]
80003bf0:	11 89       	ld.ub	r9,r8[0x0]
80003bf2:	30 08       	mov	r8,0
80003bf4:	f0 09 18 00 	cp.b	r9,r8
80003bf8:	e0 80 00 c6 	breq	80003d84 <phy_tx_func+0x290>
	{

	  //AMBE_flag
		switch(payload_tx_state)
80003bfc:	fe f8 04 70 	ld.w	r8,pc[1136]
80003c00:	11 88       	ld.ub	r8,r8[0x0]
80003c02:	30 19       	mov	r9,1
80003c04:	f2 08 18 00 	cp.b	r8,r9
80003c08:	c3 e0       	breq	80003c84 <phy_tx_func+0x190>
80003c0a:	c0 73       	brcs	80003c18 <phy_tx_func+0x124>
80003c0c:	30 29       	mov	r9,2
80003c0e:	f2 08 18 00 	cp.b	r8,r9
80003c12:	e0 81 02 1b 	brne	80004048 <phy_tx_func+0x554>
80003c16:	c9 28       	rjmp	80003d3a <phy_tx_func+0x246>
		{
			case 0:
		
				if ((m_RxBurstType == VOICE_WATING) || (m_RxBurstType == VOICETERMINATOR)  || (m_RxBurstType == VOICEHEADER))
80003c18:	fe f8 04 58 	ld.w	r8,pc[1112]
80003c1c:	70 08       	ld.w	r8,r8[0x0]
80003c1e:	58 08       	cp.w	r8,0
80003c20:	c0 b0       	breq	80003c36 <phy_tx_func+0x142>
80003c22:	fe f8 04 4e 	ld.w	r8,pc[1102]
80003c26:	70 08       	ld.w	r8,r8[0x0]
80003c28:	58 98       	cp.w	r8,9
80003c2a:	c0 60       	breq	80003c36 <phy_tx_func+0x142>
80003c2c:	fe f8 04 44 	ld.w	r8,pc[1092]
80003c30:	70 08       	ld.w	r8,r8[0x0]
80003c32:	58 18       	cp.w	r8,1
80003c34:	c0 a1       	brne	80003c48 <phy_tx_func+0x154>
				{
							
					payload_tx_channel->dword[0] = PAYLOADIDLE0;
80003c36:	e0 68 5a 5a 	mov	r8,23130
80003c3a:	ea 18 ab cd 	orh	r8,0xabcd
80003c3e:	8f 28       	st.w	r7[0x8],r8
					payload_tx_channel->dword[1] = PAYLOADIDLE1;
80003c40:	30 08       	mov	r8,0
80003c42:	8f 38       	st.w	r7[0xc],r8
80003c44:	e0 8f 02 02 	bral	80004048 <phy_tx_func+0x554>
			
				}
				else if((m_RxBurstType == UNSUREDATA))
80003c48:	fe f8 04 28 	ld.w	r8,pc[1064]
80003c4c:	70 08       	ld.w	r8,r8[0x0]
80003c4e:	58 28       	cp.w	r8,2
80003c50:	c0 91       	brne	80003c62 <phy_tx_func+0x16e>
				{
					payload_tx_channel->dword[0] = AMBE_HT[0];
80003c52:	fe f8 04 22 	ld.w	r8,pc[1058]
80003c56:	70 09       	ld.w	r9,r8[0x0]
80003c58:	8f 29       	st.w	r7[0x8],r9
					payload_tx_channel->dword[1] = AMBE_HT[1];
80003c5a:	70 18       	ld.w	r8,r8[0x4]
80003c5c:	8f 38       	st.w	r7[0xc],r8
80003c5e:	e0 8f 01 f5 	bral	80004048 <phy_tx_func+0x554>
				}
				else
				{
					payload_tx_state = 1;
80003c62:	30 19       	mov	r9,1
80003c64:	fe f8 04 08 	ld.w	r8,pc[1032]
80003c68:	b0 89       	st.b	r8[0x0],r9
					
					//0xABCDCOOE
					payload_tx_channel->dword[0] = EN_OB_PAYLOAD;//49bits
80003c6a:	e0 68 c0 0e 	mov	r8,49166
80003c6e:	ea 18 ab cd 	orh	r8,0xabcd
80003c72:	8f 28       	st.w	r7[0x8],r8
					//0x8212
					payload_tx_channel->word[2] = VBSP_data[0];
80003c74:	fe f8 04 04 	ld.w	r8,pc[1028]
80003c78:	90 09       	ld.sh	r9,r8[0x0]
80003c7a:	ae 69       	st.h	r7[0xc],r9
					//0xF00x
					payload_tx_channel->word[3] = VBSP_data[1];
80003c7c:	90 18       	ld.sh	r8,r8[0x2]
80003c7e:	ae 78       	st.h	r7[0xe],r8
80003c80:	e0 8f 01 e4 	bral	80004048 <phy_tx_func+0x554>
				break;
			
			case 1:
			
				//0x88F2
				payload_tx_channel->word[0] = ENCODER_PAYLOAD;//49bits
80003c84:	fe 78 88 f2 	mov	r8,-30478
80003c88:	ae 48       	st.h	r7[0x8],r8
			
				switch (m_RxBurstType)//
80003c8a:	fe f8 03 e6 	ld.w	r8,pc[998]
80003c8e:	70 08       	ld.w	r8,r8[0x0]
80003c90:	58 38       	cp.w	r8,3
80003c92:	c0 60       	breq	80003c9e <phy_tx_func+0x1aa>
80003c94:	c4 73       	brcs	80003d22 <phy_tx_func+0x22e>
80003c96:	58 88       	cp.w	r8,8
80003c98:	e0 8b 00 45 	brhi	80003d22 <phy_tx_func+0x22e>
80003c9c:	c2 a8       	rjmp	80003cf0 <phy_tx_func+0x1fc>
				{
					case VOICEBURST_A:
							if (VF_SN == 1)
80003c9e:	fe f8 03 de 	ld.w	r8,pc[990]
80003ca2:	11 89       	ld.ub	r9,r8[0x0]
80003ca4:	30 18       	mov	r8,1
80003ca6:	f0 09 18 00 	cp.b	r9,r8
80003caa:	c0 a1       	brne	80003cbe <phy_tx_func+0x1ca>
							{	
								//Place public key
								payload_tx_channel->word[1] = Public_AMBEkey[0];
80003cac:	fe f8 03 d4 	ld.w	r8,pc[980]
80003cb0:	90 09       	ld.sh	r9,r8[0x0]
80003cb2:	ae 59       	st.h	r7[0xa],r9
								payload_tx_channel->word[2] = Public_AMBEkey[1];
80003cb4:	90 19       	ld.sh	r9,r8[0x2]
80003cb6:	ae 69       	st.h	r7[0xc],r9
								payload_tx_channel->word[3] = Public_AMBEkey[2];
80003cb8:	90 28       	ld.sh	r8,r8[0x4]
80003cba:	ae 78       	st.h	r7[0xe],r8
80003cbc:	c1 48       	rjmp	80003ce4 <phy_tx_func+0x1f0>
								//logFromISR("\n\r MMQ \n\r");
							}
							else//VF_SN==2/3
							{
								//Encrypted AMBE data(XOR)
								payload_tx_channel->word[1] = ((Public_AMBEkey[0]) ^ (AMBEBurst_rawdata[0])) ;
80003cbe:	fe f9 03 c6 	ld.w	r9,pc[966]
80003cc2:	92 0b       	ld.sh	r11,r9[0x0]
80003cc4:	fe f8 03 bc 	ld.w	r8,pc[956]
80003cc8:	90 0a       	ld.sh	r10,r8[0x0]
80003cca:	f7 ea 20 0a 	eor	r10,r11,r10
80003cce:	ae 5a       	st.h	r7[0xa],r10
								payload_tx_channel->word[2] = ((Public_AMBEkey[1]) ^ (AMBEBurst_rawdata[1])) ;
80003cd0:	92 1b       	ld.sh	r11,r9[0x2]
80003cd2:	90 1a       	ld.sh	r10,r8[0x2]
80003cd4:	f7 ea 20 0a 	eor	r10,r11,r10
80003cd8:	ae 6a       	st.h	r7[0xc],r10
								payload_tx_channel->word[3] = ((Public_AMBEkey[2]) ^ (AMBEBurst_rawdata[2])) ;
80003cda:	92 29       	ld.sh	r9,r9[0x4]
80003cdc:	90 28       	ld.sh	r8,r8[0x4]
80003cde:	f3 e8 20 08 	eor	r8,r9,r8
80003ce2:	ae 78       	st.h	r7[0xe],r8
								//payload_tx_channel->word[2] = AMBEBurst_rawdata[1];
								//payload_tx_channel->word[3] = AMBEBurst_rawdata[2];
						
							}
					
							payload_tx_state = 2;
80003ce4:	30 29       	mov	r9,2
80003ce6:	fe f8 03 86 	ld.w	r8,pc[902]
80003cea:	b0 89       	st.b	r8[0x0],r9
80003cec:	e0 8f 01 ae 	bral	80004048 <phy_tx_func+0x554>
							//Encrypted AMBE data(XOR)
						
							//payload_tx_channel->word[1] = AMBEBurst_rawdata[0];
							//payload_tx_channel->word[2] = AMBEBurst_rawdata[1];
							//payload_tx_channel->word[3] = AMBEBurst_rawdata[2];
							payload_tx_channel->word[1] = ((Public_AMBEkey[0]) ^ (AMBEBurst_rawdata[0])) ;
80003cf0:	fe f9 03 94 	ld.w	r9,pc[916]
80003cf4:	92 0b       	ld.sh	r11,r9[0x0]
80003cf6:	fe f8 03 8a 	ld.w	r8,pc[906]
80003cfa:	90 0a       	ld.sh	r10,r8[0x0]
80003cfc:	f7 ea 20 0a 	eor	r10,r11,r10
80003d00:	ae 5a       	st.h	r7[0xa],r10
							payload_tx_channel->word[2] = ((Public_AMBEkey[1]) ^ (AMBEBurst_rawdata[1])) ;
80003d02:	92 1b       	ld.sh	r11,r9[0x2]
80003d04:	90 1a       	ld.sh	r10,r8[0x2]
80003d06:	f7 ea 20 0a 	eor	r10,r11,r10
80003d0a:	ae 6a       	st.h	r7[0xc],r10
							payload_tx_channel->word[3] = ((Public_AMBEkey[2]) ^ (AMBEBurst_rawdata[2])) ;
80003d0c:	92 29       	ld.sh	r9,r9[0x4]
80003d0e:	90 28       	ld.sh	r8,r8[0x4]
80003d10:	f3 e8 20 08 	eor	r8,r9,r8
80003d14:	ae 78       	st.h	r7[0xe],r8
						
							payload_tx_state = 2;
80003d16:	30 29       	mov	r9,2
80003d18:	fe f8 03 54 	ld.w	r8,pc[852]
80003d1c:	b0 89       	st.b	r8[0x0],r9
80003d1e:	e0 8f 01 95 	bral	80004048 <phy_tx_func+0x554>
				
						break;
					default://This shouldn't happen, but must check;
					
							payload_tx_channel->dword[0] = PAYLOADIDLE0;
80003d22:	e0 68 5a 5a 	mov	r8,23130
80003d26:	ea 18 ab cd 	orh	r8,0xabcd
80003d2a:	8f 28       	st.w	r7[0x8],r8
							payload_tx_channel->dword[1] = PAYLOADIDLE1;
80003d2c:	30 08       	mov	r8,0
80003d2e:	8f 38       	st.w	r7[0xc],r8
							payload_tx_state = 0;
80003d30:	fe f9 03 3c 	ld.w	r9,pc[828]
80003d34:	b2 88       	st.b	r9[0x0],r8
80003d36:	e0 8f 01 89 	bral	80004048 <phy_tx_func+0x554>
			
			case 2:
					//Encrypted AMBE data(XOR)
					//payload_tx_channel->word[0] = AMBEBurst_rawdata[3];
				
					if ((m_RxBurstType == VOICEBURST_A) && (VF_SN == 1))
80003d3a:	fe f8 03 36 	ld.w	r8,pc[822]
80003d3e:	70 08       	ld.w	r8,r8[0x0]
80003d40:	58 38       	cp.w	r8,3
80003d42:	c0 d1       	brne	80003d5c <phy_tx_func+0x268>
80003d44:	fe f8 03 38 	ld.w	r8,pc[824]
80003d48:	11 89       	ld.ub	r9,r8[0x0]
80003d4a:	30 18       	mov	r8,1
80003d4c:	f0 09 18 00 	cp.b	r9,r8
80003d50:	c0 61       	brne	80003d5c <phy_tx_func+0x268>
					{
						payload_tx_channel->word[0]	= ((Public_AMBEkey[3])) ;
80003d52:	fe f8 03 2e 	ld.w	r8,pc[814]
80003d56:	90 38       	ld.sh	r8,r8[0x6]
80003d58:	ae 48       	st.h	r7[0x8],r8
80003d5a:	c0 a8       	rjmp	80003d6e <phy_tx_func+0x27a>
					}
					else{
					
						payload_tx_channel->word[0]	= ((Public_AMBEkey[3]) ^ (AMBEBurst_rawdata[3])) ;
80003d5c:	fe f8 03 28 	ld.w	r8,pc[808]
80003d60:	90 39       	ld.sh	r9,r8[0x6]
80003d62:	fe f8 03 1e 	ld.w	r8,pc[798]
80003d66:	90 38       	ld.sh	r8,r8[0x6]
80003d68:	f3 e8 20 08 	eor	r8,r9,r8
80003d6c:	ae 48       	st.h	r7[0x8],r8
					
					}
					payload_tx_channel->word[1]	= 0x00BA ; 
80003d6e:	e0 68 00 ba 	mov	r8,186
80003d72:	ae 58       	st.h	r7[0xa],r8
					payload_tx_channel->word[2]	= 0x0000 ;
80003d74:	30 08       	mov	r8,0
80003d76:	ae 68       	st.h	r7[0xc],r8
					payload_tx_channel->word[3]	= 0x0000 ;
80003d78:	ae 78       	st.h	r7[0xe],r8
				
					payload_tx_state = 0;
80003d7a:	fe f9 02 f2 	ld.w	r9,pc[754]
80003d7e:	b2 88       	st.b	r9[0x0],r8
80003d80:	e0 8f 01 64 	bral	80004048 <phy_tx_func+0x554>

#if 1
else//Send-PCM-data40bytes/2.5ms.
{
	
	index = (index >=30240) ? 0 : index;
80003d84:	fe f8 03 04 	ld.w	r8,pc[772]
80003d88:	70 08       	ld.w	r8,r8[0x0]
80003d8a:	e0 48 76 20 	cp.w	r8,30240
80003d8e:	f9 b8 02 00 	movhs	r8,0
80003d92:	fe f9 02 f6 	ld.w	r9,pc[758]
80003d96:	93 08       	st.w	r9[0x0],r8
	
	if(is_unmute == 1)counter++;
80003d98:	fe f8 02 f4 	ld.w	r8,pc[756]
80003d9c:	11 89       	ld.ub	r9,r8[0x0]
80003d9e:	30 18       	mov	r8,1
80003da0:	f0 09 18 00 	cp.b	r9,r8
80003da4:	c0 61       	brne	80003db0 <phy_tx_func+0x2bc>
80003da6:	fe f8 02 ea 	ld.w	r8,pc[746]
80003daa:	70 09       	ld.w	r9,r8[0x0]
80003dac:	2f f9       	sub	r9,-1
80003dae:	91 09       	st.w	r8[0x0],r9
	
	switch(payload_tx_state)
80003db0:	fe f8 02 bc 	ld.w	r8,pc[700]
80003db4:	11 88       	ld.ub	r8,r8[0x0]
80003db6:	30 19       	mov	r9,1
80003db8:	f2 08 18 00 	cp.b	r8,r9
80003dbc:	c3 60       	breq	80003e28 <phy_tx_func+0x334>
80003dbe:	c0 73       	brcs	80003dcc <phy_tx_func+0x2d8>
80003dc0:	30 29       	mov	r9,2
80003dc2:	f2 08 18 00 	cp.b	r8,r9
80003dc6:	e0 81 01 3e 	brne	80004042 <phy_tx_func+0x54e>
80003dca:	c7 c8       	rjmp	80003ec2 <phy_tx_func+0x3ce>
	{
		case 0:
		
			payload_tx_channel->dword[0] = PAYLOADIDLE0;
80003dcc:	e0 68 5a 5a 	mov	r8,23130
80003dd0:	ea 18 ab cd 	orh	r8,0xabcd
80003dd4:	8f 28       	st.w	r7[0x8],r8
			payload_tx_channel->dword[1] = PAYLOADIDLE1;
80003dd6:	30 08       	mov	r8,0
80003dd8:	8f 38       	st.w	r7[0xc],r8
		
			if(((counter % 20 )== 0) && (counter != 0) &&(is_unmute == 1))//20*125us = 2.5ms.
80003dda:	fe f8 02 b6 	ld.w	r8,pc[694]
80003dde:	70 08       	ld.w	r8,r8[0x0]
80003de0:	e0 6b cc cd 	mov	r11,52429
80003de4:	ea 1b cc cc 	orh	r11,0xcccc
80003de8:	f0 0b 06 4a 	mulu.d	r10,r8,r11
80003dec:	f6 09 16 04 	lsr	r9,r11,0x4
80003df0:	f2 09 00 29 	add	r9,r9,r9<<0x2
80003df4:	f0 09 01 29 	sub	r9,r8,r9<<0x2
80003df8:	c1 21       	brne	80003e1c <phy_tx_func+0x328>
80003dfa:	58 08       	cp.w	r8,0
80003dfc:	c1 00       	breq	80003e1c <phy_tx_func+0x328>
80003dfe:	fe f8 02 8e 	ld.w	r8,pc[654]
80003e02:	11 89       	ld.ub	r9,r8[0x0]
80003e04:	30 18       	mov	r8,1
80003e06:	f0 09 18 00 	cp.b	r9,r8
80003e0a:	c0 91       	brne	80003e1c <phy_tx_func+0x328>
			{
				payload_tx_state = 1;
80003e0c:	10 99       	mov	r9,r8
80003e0e:	fe f8 02 5e 	ld.w	r8,pc[606]
80003e12:	b0 89       	st.b	r8[0x0],r9
				//payload_tx_state = 0;
				frame_number = 0;
80003e14:	30 09       	mov	r9,0
80003e16:	fe f8 02 7e 	ld.w	r8,pc[638]
80003e1a:	b0 89       	st.b	r8[0x0],r9
	
			}
		
			send_num++;
80003e1c:	fe f8 02 7c 	ld.w	r8,pc[636]
80003e20:	70 09       	ld.w	r9,r8[0x0]
80003e22:	2f f9       	sub	r9,-1
80003e24:	91 09       	st.w	r8[0x0],r9
80003e26:	c1 19       	rjmp	80004048 <phy_tx_func+0x554>
			break;
		
		case 1:
		
	
			payload_tx_channel->word[0] = 0xABCD; 
80003e28:	fe 78 ab cd 	mov	r8,-21555
80003e2c:	ae 48       	st.h	r7[0x8],r8
		
			if(frame_number == 0)
80003e2e:	fe f8 02 66 	ld.w	r8,pc[614]
80003e32:	11 89       	ld.ub	r9,r8[0x0]
80003e34:	30 08       	mov	r8,0
80003e36:	f0 09 18 00 	cp.b	r9,r8
80003e3a:	c1 b1       	brne	80003e70 <phy_tx_func+0x37c>
			{
				if (Silent_flag == 1)
80003e3c:	fe f8 02 60 	ld.w	r8,pc[608]
80003e40:	11 89       	ld.ub	r9,r8[0x0]
80003e42:	30 18       	mov	r8,1
80003e44:	f0 09 18 00 	cp.b	r9,r8
80003e48:	c0 91       	brne	80003e5a <phy_tx_func+0x366>
				{
					//44betes-4bytes= 40bytes
					expexted_length = 0x2C;//One Descriptor Indicator
80003e4a:	32 c9       	mov	r9,44
80003e4c:	fe f8 02 54 	ld.w	r8,pc[596]
80003e50:	b0 09       	st.h	r8[0x0],r9
					payload_tx_channel->word[1] = 0x102C;//44betes-4bytes= 40bytes
80003e52:	e0 68 10 2c 	mov	r8,4140
80003e56:	ae 58       	st.h	r7[0xa],r8
80003e58:	c0 88       	rjmp	80003e68 <phy_tx_func+0x374>
				}
				
				else
				{
					//first frame
					expexted_length = 0x2A;
80003e5a:	32 a9       	mov	r9,42
80003e5c:	fe f8 02 44 	ld.w	r8,pc[580]
80003e60:	b0 09       	st.h	r8[0x0],r9
					payload_tx_channel->word[1] = 0x102A;//42-2= 40 bytes;	
80003e62:	e0 68 10 2a 	mov	r8,4138
80003e66:	ae 58       	st.h	r7[0xa],r8
				}
				
					last_frame = TRUE;
80003e68:	30 19       	mov	r9,1
80003e6a:	fe f8 02 3a 	ld.w	r8,pc[570]
80003e6e:	b0 89       	st.b	r8[0x0],r9
			//
			//
			//}
			//else//
			
			if (Silent_flag == 1)//
80003e70:	fe f8 02 2c 	ld.w	r8,pc[556]
80003e74:	11 89       	ld.ub	r9,r8[0x0]
80003e76:	30 18       	mov	r8,1
80003e78:	f0 09 18 00 	cp.b	r9,r8
80003e7c:	c0 61       	brne	80003e88 <phy_tx_func+0x394>
			{
			
				payload_tx_channel->word[2] = 0x0001;//Array Descriptor Length
80003e7e:	30 18       	mov	r8,1
80003e80:	ae 68       	st.h	r7[0xc],r8
				payload_tx_channel->word[3] =  0x0004;//Silent Descriptor Indicator
80003e82:	30 48       	mov	r8,4
80003e84:	ae 78       	st.h	r7[0xe],r8
80003e86:	c1 38       	rjmp	80003eac <phy_tx_func+0x3b8>

			}
			else
			{
			
				payload_tx_channel->word[2] = 0x0000;
80003e88:	30 08       	mov	r8,0
80003e8a:	ae 68       	st.h	r7[0xc],r8
				payload_tx_channel->word[3] =  ((AudioData[index]<<8 )+ AudioData[index+1] );
80003e8c:	4f f8       	lddpc	r8,80004088 <phy_tx_func+0x594>
80003e8e:	70 09       	ld.w	r9,r8[0x0]
80003e90:	fe fa 02 18 	ld.w	r10,pc[536]
80003e94:	f4 09 00 0b 	add	r11,r10,r9
80003e98:	17 9b       	ld.ub	r11,r11[0x1]
80003e9a:	f4 09 07 09 	ld.ub	r9,r10[r9]
80003e9e:	a9 69       	lsl	r9,0x8
80003ea0:	f6 09 00 09 	add	r9,r11,r9
80003ea4:	ae 79       	st.h	r7[0xe],r9
				index+=2;
80003ea6:	70 09       	ld.w	r9,r8[0x0]
80003ea8:	2f e9       	sub	r9,-2
80003eaa:	91 09       	st.w	r8[0x0],r9
			
			}
		
			expexted_length -= 4;
80003eac:	4f d8       	lddpc	r8,800040a0 <phy_tx_func+0x5ac>
80003eae:	90 09       	ld.sh	r9,r8[0x0]
80003eb0:	20 49       	sub	r9,4
80003eb2:	b0 09       	st.h	r8[0x0],r9
		
			//frame_number++;
			payload_tx_state = 2;
80003eb4:	30 29       	mov	r9,2
80003eb6:	4e e8       	lddpc	r8,8000406c <phy_tx_func+0x578>
80003eb8:	b0 89       	st.b	r8[0x0],r9
		
			i = 0;
80003eba:	30 09       	mov	r9,0
80003ebc:	4f c8       	lddpc	r8,800040ac <phy_tx_func+0x5b8>
80003ebe:	91 09       	st.w	r8[0x0],r9
80003ec0:	cc 48       	rjmp	80004048 <phy_tx_func+0x554>
		
			break;
		
		case 2:
		
			if(expexted_length <= 0)
80003ec2:	4f 88       	lddpc	r8,800040a0 <phy_tx_func+0x5ac>
80003ec4:	90 09       	ld.sh	r9,r8[0x0]
80003ec6:	30 08       	mov	r8,0
80003ec8:	f0 09 19 00 	cp.h	r9,r8
80003ecc:	e0 89 00 12 	brgt	80003ef0 <phy_tx_func+0x3fc>
			{
				//last word 0x00BA
				payload_tx_state = last_frame ? 0 : 1;
80003ed0:	4f 58       	lddpc	r8,800040a4 <phy_tx_func+0x5b0>
80003ed2:	11 89       	ld.ub	r9,r8[0x0]
80003ed4:	30 08       	mov	r8,0
80003ed6:	f0 09 18 00 	cp.b	r9,r8
80003eda:	5f 09       	sreq	r9
80003edc:	4e 48       	lddpc	r8,8000406c <phy_tx_func+0x578>
80003ede:	b0 89       	st.b	r8[0x0],r9
				payload_tx_channel->word[0] = 0x00BA;
80003ee0:	e0 68 00 ba 	mov	r8,186
80003ee4:	ae 48       	st.h	r7[0x8],r8
				payload_tx_channel->word[1] = 0x0000;
80003ee6:	30 08       	mov	r8,0
80003ee8:	ae 58       	st.h	r7[0xa],r8
				payload_tx_channel->word[2] = 0x0000;
80003eea:	ae 68       	st.h	r7[0xc],r8
				payload_tx_channel->word[3] = 0x0000;
80003eec:	ae 78       	st.h	r7[0xe],r8
80003eee:	ca d8       	rjmp	80004048 <phy_tx_func+0x554>
				break;
			}
		
			if(Silent_flag == 1)
80003ef0:	4e b8       	lddpc	r8,8000409c <phy_tx_func+0x5a8>
80003ef2:	11 89       	ld.ub	r9,r8[0x0]
80003ef4:	30 18       	mov	r8,1
80003ef6:	f0 09 18 00 	cp.b	r9,r8
80003efa:	c0 41       	brne	80003f02 <phy_tx_func+0x40e>
			{
				payload_tx_channel->word[0] =  0x0000;
80003efc:	30 08       	mov	r8,0
80003efe:	ae 48       	st.h	r7[0x8],r8
80003f00:	c1 08       	rjmp	80003f20 <phy_tx_func+0x42c>
			}
			else
			{
				//payload_tx_channel->word[0] = AudioData[index++] + (AudioData[index++] << 8);
				payload_tx_channel->word[0] =  ((AudioData[index]<<8 )+ AudioData[index+1] );
80003f02:	4e 28       	lddpc	r8,80004088 <phy_tx_func+0x594>
80003f04:	70 09       	ld.w	r9,r8[0x0]
80003f06:	4e 9a       	lddpc	r10,800040a8 <phy_tx_func+0x5b4>
80003f08:	f4 09 00 0b 	add	r11,r10,r9
80003f0c:	17 9b       	ld.ub	r11,r11[0x1]
80003f0e:	f4 09 07 09 	ld.ub	r9,r10[r9]
80003f12:	a9 69       	lsl	r9,0x8
80003f14:	f6 09 00 09 	add	r9,r11,r9
80003f18:	ae 49       	st.h	r7[0x8],r9
				index+=2;
80003f1a:	70 09       	ld.w	r9,r8[0x0]
80003f1c:	2f e9       	sub	r9,-2
80003f1e:	91 09       	st.w	r8[0x0],r9
			
			}

			expexted_length -= 2;
80003f20:	4e 09       	lddpc	r9,800040a0 <phy_tx_func+0x5ac>
80003f22:	92 08       	ld.sh	r8,r9[0x0]
80003f24:	20 28       	sub	r8,2
80003f26:	b2 08       	st.h	r9[0x0],r8
			if(expexted_length <= 0)
80003f28:	30 09       	mov	r9,0
80003f2a:	f2 08 19 00 	cp.h	r8,r9
80003f2e:	e0 89 00 11 	brgt	80003f50 <phy_tx_func+0x45c>
			{
				//last word 0x00BA
				payload_tx_state = last_frame ? 0 : 1;
80003f32:	4d d8       	lddpc	r8,800040a4 <phy_tx_func+0x5b0>
80003f34:	11 89       	ld.ub	r9,r8[0x0]
80003f36:	30 08       	mov	r8,0
80003f38:	f0 09 18 00 	cp.b	r9,r8
80003f3c:	5f 09       	sreq	r9
80003f3e:	4c c8       	lddpc	r8,8000406c <phy_tx_func+0x578>
80003f40:	b0 89       	st.b	r8[0x0],r9
				payload_tx_channel->word[1] = 0x00BA;
80003f42:	e0 68 00 ba 	mov	r8,186
80003f46:	ae 58       	st.h	r7[0xa],r8
				payload_tx_channel->word[2] = 0x0000;
80003f48:	30 08       	mov	r8,0
80003f4a:	ae 68       	st.h	r7[0xc],r8
				payload_tx_channel->word[3] = 0x0000;
80003f4c:	ae 78       	st.h	r7[0xe],r8
80003f4e:	c7 d8       	rjmp	80004048 <phy_tx_func+0x554>
				break;
			}
		
			if(Silent_flag == 1)
80003f50:	4d 38       	lddpc	r8,8000409c <phy_tx_func+0x5a8>
80003f52:	11 89       	ld.ub	r9,r8[0x0]
80003f54:	30 18       	mov	r8,1
80003f56:	f0 09 18 00 	cp.b	r9,r8
80003f5a:	c0 41       	brne	80003f62 <phy_tx_func+0x46e>
			{
				payload_tx_channel->word[1] =  0x0000;
80003f5c:	30 08       	mov	r8,0
80003f5e:	ae 58       	st.h	r7[0xa],r8
80003f60:	c1 08       	rjmp	80003f80 <phy_tx_func+0x48c>
			}
			else
			{
			
				payload_tx_channel->word[1] =  ((AudioData[index]<<8 )+ AudioData[index+1] );
80003f62:	4c a8       	lddpc	r8,80004088 <phy_tx_func+0x594>
80003f64:	70 09       	ld.w	r9,r8[0x0]
80003f66:	4d 1a       	lddpc	r10,800040a8 <phy_tx_func+0x5b4>
80003f68:	f4 09 00 0b 	add	r11,r10,r9
80003f6c:	17 9b       	ld.ub	r11,r11[0x1]
80003f6e:	f4 09 07 09 	ld.ub	r9,r10[r9]
80003f72:	a9 69       	lsl	r9,0x8
80003f74:	f6 09 00 09 	add	r9,r11,r9
80003f78:	ae 59       	st.h	r7[0xa],r9
				index+=2;
80003f7a:	70 09       	ld.w	r9,r8[0x0]
80003f7c:	2f e9       	sub	r9,-2
80003f7e:	91 09       	st.w	r8[0x0],r9
			}
			//payload_tx_channel->word[1] =  ((AudioData[index]<<8 )+ AudioData[index+1] );
		
			expexted_length -= 2;
80003f80:	4c 89       	lddpc	r9,800040a0 <phy_tx_func+0x5ac>
80003f82:	92 08       	ld.sh	r8,r9[0x0]
80003f84:	20 28       	sub	r8,2
80003f86:	b2 08       	st.h	r9[0x0],r8
			if(expexted_length <= 0)
80003f88:	30 09       	mov	r9,0
80003f8a:	f2 08 19 00 	cp.h	r8,r9
80003f8e:	e0 89 00 10 	brgt	80003fae <phy_tx_func+0x4ba>
			{
				//last word 0x00BA
				payload_tx_state = last_frame ? 0 : 1;
80003f92:	4c 58       	lddpc	r8,800040a4 <phy_tx_func+0x5b0>
80003f94:	11 89       	ld.ub	r9,r8[0x0]
80003f96:	30 08       	mov	r8,0
80003f98:	f0 09 18 00 	cp.b	r9,r8
80003f9c:	5f 09       	sreq	r9
80003f9e:	4b 48       	lddpc	r8,8000406c <phy_tx_func+0x578>
80003fa0:	b0 89       	st.b	r8[0x0],r9
				payload_tx_channel->word[2] = 0x00BA;
80003fa2:	e0 68 00 ba 	mov	r8,186
80003fa6:	ae 68       	st.h	r7[0xc],r8
				payload_tx_channel->word[3] = 0x0000;
80003fa8:	30 08       	mov	r8,0
80003faa:	ae 78       	st.h	r7[0xe],r8
80003fac:	c4 e8       	rjmp	80004048 <phy_tx_func+0x554>
				break;
			}
		
			if(Silent_flag == 1)
80003fae:	4b c8       	lddpc	r8,8000409c <phy_tx_func+0x5a8>
80003fb0:	11 89       	ld.ub	r9,r8[0x0]
80003fb2:	30 18       	mov	r8,1
80003fb4:	f0 09 18 00 	cp.b	r9,r8
80003fb8:	c0 41       	brne	80003fc0 <phy_tx_func+0x4cc>
			{
				payload_tx_channel->word[2] =  0x0000;
80003fba:	30 08       	mov	r8,0
80003fbc:	ae 68       	st.h	r7[0xc],r8
80003fbe:	c1 08       	rjmp	80003fde <phy_tx_func+0x4ea>
			}
			else
			{
			
				payload_tx_channel->word[2] =  ((AudioData[index]<<8 )+ AudioData[index+1] );
80003fc0:	4b 28       	lddpc	r8,80004088 <phy_tx_func+0x594>
80003fc2:	70 09       	ld.w	r9,r8[0x0]
80003fc4:	4b 9a       	lddpc	r10,800040a8 <phy_tx_func+0x5b4>
80003fc6:	f4 09 00 0b 	add	r11,r10,r9
80003fca:	17 9b       	ld.ub	r11,r11[0x1]
80003fcc:	f4 09 07 09 	ld.ub	r9,r10[r9]
80003fd0:	a9 69       	lsl	r9,0x8
80003fd2:	f6 09 00 09 	add	r9,r11,r9
80003fd6:	ae 69       	st.h	r7[0xc],r9
				index+=2;
80003fd8:	70 09       	ld.w	r9,r8[0x0]
80003fda:	2f e9       	sub	r9,-2
80003fdc:	91 09       	st.w	r8[0x0],r9
			}
			//payload_tx_channel->word[2] =  ((AudioData[index]<<8 )+ AudioData[index+1] );
		
			expexted_length -= 2;
80003fde:	4b 19       	lddpc	r9,800040a0 <phy_tx_func+0x5ac>
80003fe0:	92 08       	ld.sh	r8,r9[0x0]
80003fe2:	20 28       	sub	r8,2
80003fe4:	b2 08       	st.h	r9[0x0],r8
			if(expexted_length <= 0)
80003fe6:	30 09       	mov	r9,0
80003fe8:	f2 08 19 00 	cp.h	r8,r9
80003fec:	e0 89 00 0e 	brgt	80004008 <phy_tx_func+0x514>
			{
				//last word 0x00BA
				payload_tx_state = last_frame ? 0 : 1;
80003ff0:	4a d8       	lddpc	r8,800040a4 <phy_tx_func+0x5b0>
80003ff2:	11 89       	ld.ub	r9,r8[0x0]
80003ff4:	30 08       	mov	r8,0
80003ff6:	f0 09 18 00 	cp.b	r9,r8
80003ffa:	5f 09       	sreq	r9
80003ffc:	49 c8       	lddpc	r8,8000406c <phy_tx_func+0x578>
80003ffe:	b0 89       	st.b	r8[0x0],r9
				payload_tx_channel->word[3] = 0x00BA;
80004000:	e0 68 00 ba 	mov	r8,186
80004004:	ae 78       	st.h	r7[0xe],r8
80004006:	c2 18       	rjmp	80004048 <phy_tx_func+0x554>
				break;
			}
		
			if(Silent_flag == 1)
80004008:	4a 58       	lddpc	r8,8000409c <phy_tx_func+0x5a8>
8000400a:	11 89       	ld.ub	r9,r8[0x0]
8000400c:	30 18       	mov	r8,1
8000400e:	f0 09 18 00 	cp.b	r9,r8
80004012:	c0 41       	brne	8000401a <phy_tx_func+0x526>
			{
				payload_tx_channel->word[3] =  0x0000;
80004014:	30 08       	mov	r8,0
80004016:	ae 78       	st.h	r7[0xe],r8
80004018:	c1 08       	rjmp	80004038 <phy_tx_func+0x544>
			}
			else
			{
			
				payload_tx_channel->word[3] =  ((AudioData[index]<<8 )+ AudioData[index+1] );
8000401a:	49 c8       	lddpc	r8,80004088 <phy_tx_func+0x594>
8000401c:	70 09       	ld.w	r9,r8[0x0]
8000401e:	4a 3a       	lddpc	r10,800040a8 <phy_tx_func+0x5b4>
80004020:	f4 09 00 0b 	add	r11,r10,r9
80004024:	17 9b       	ld.ub	r11,r11[0x1]
80004026:	f4 09 07 09 	ld.ub	r9,r10[r9]
8000402a:	a9 69       	lsl	r9,0x8
8000402c:	f6 09 00 09 	add	r9,r11,r9
80004030:	ae 79       	st.h	r7[0xe],r9
				index+=2;
80004032:	70 09       	ld.w	r9,r8[0x0]
80004034:	2f e9       	sub	r9,-2
80004036:	91 09       	st.w	r8[0x0],r9
			}
		
			//payload_tx_channel->word[3] =  ((AudioData[index]<<8 )+ AudioData[index+1] );
		
			expexted_length -= 2;
80004038:	49 a8       	lddpc	r8,800040a0 <phy_tx_func+0x5ac>
8000403a:	90 09       	ld.sh	r9,r8[0x0]
8000403c:	20 29       	sub	r9,2
8000403e:	b0 09       	st.h	r8[0x0],r9
80004040:	c0 48       	rjmp	80004048 <phy_tx_func+0x554>
		
			break;
		
		default:
			payload_tx_state = 0;
80004042:	30 09       	mov	r9,0
80004044:	48 a8       	lddpc	r8,8000406c <phy_tx_func+0x578>
80004046:	b0 89       	st.b	r8[0x0],r9
	#else
	/*send idle frame*/	
	((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
	((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
	#endif /*end if*/
}
80004048:	2f fd       	sub	sp,-4
8000404a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000404e:	00 00       	add	r0,r0
80004050:	00 00       	add	r0,r0
80004052:	0f e0       	ld.ub	r0,r7[0x6]
80004054:	00 00       	add	r0,r0
80004056:	0f ac       	ld.ub	r12,r7[0x2]
80004058:	00 00       	add	r0,r0
8000405a:	0f 78       	ld.ub	r8,--r7
8000405c:	80 00       	ld.sh	r0,r0[0x0]
8000405e:	8b b8       	st.w	r5[0x2c],r8
80004060:	00 00       	add	r0,r0
80004062:	0f ca       	ld.ub	r10,r7[0x4]
80004064:	00 00       	add	r0,r0
80004066:	0f c1       	ld.ub	r1,r7[0x4]
80004068:	00 00       	add	r0,r0
8000406a:	0a 44       	or	r4,r5
8000406c:	00 00       	add	r0,r0
8000406e:	0f c2       	ld.ub	r2,r7[0x4]
80004070:	00 00       	add	r0,r0
80004072:	0f 80       	ld.ub	r0,r7[0x0]
80004074:	00 00       	add	r0,r0
80004076:	0f b0       	ld.ub	r0,r7[0x3]
80004078:	00 00       	add	r0,r0
8000407a:	13 cc       	ld.ub	r12,r9[0x4]
8000407c:	00 00       	add	r0,r0
8000407e:	0a 4c       	or	r12,r5
80004080:	80 01       	ld.sh	r1,r0[0x0]
80004082:	06 4c       	or	r12,r3
80004084:	00 00       	add	r0,r0
80004086:	12 d4       	st.w	--r9,r4
80004088:	00 00       	add	r0,r0
8000408a:	0f a0       	ld.ub	r0,r7[0x2]
8000408c:	00 00       	add	r0,r0
8000408e:	0a 4d       	or	sp,r5
80004090:	00 00       	add	r0,r0
80004092:	0f e4       	ld.ub	r4,r7[0x6]
80004094:	00 00       	add	r0,r0
80004096:	0f c0       	ld.ub	r0,r7[0x4]
80004098:	00 00       	add	r0,r0
8000409a:	0f d8       	ld.ub	r8,r7[0x5]
8000409c:	00 00       	add	r0,r0
8000409e:	0a 54       	eor	r4,r5
800040a0:	00 00       	add	r0,r0
800040a2:	0f f0       	ld.ub	r0,r7[0x7]
800040a4:	00 00       	add	r0,r0
800040a6:	0f 88       	ld.ub	r8,r7[0x0]
800040a8:	80 01       	ld.sh	r1,r0[0x0]
800040aa:	06 a8       	st.w	r3++,r8
800040ac:	00 00       	add	r0,r0
800040ae:	0f f4       	ld.ub	r4,r7[0x7]

800040b0 <get_idle_store>:
	}//End of RxMedia Phy Handler.
}
#endif /*end if*/

void * get_idle_store(xQueueHandle store)
{
800040b0:	d4 01       	pushm	lr
800040b2:	20 1d       	sub	sp,4
	void * ptr = NULL;
800040b4:	30 0a       	mov	r10,0
800040b6:	fa cb ff fc 	sub	r11,sp,-4
800040ba:	16 da       	st.w	--r11,r10

	if(pdTRUE == xQueueReceive(store, &ptr, 0))
800040bc:	14 99       	mov	r9,r10
800040be:	1a 9b       	mov	r11,sp
800040c0:	f0 1f 00 05 	mcall	800040d4 <get_idle_store+0x24>
800040c4:	58 1c       	cp.w	r12,1
800040c6:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
800040ca:	fb fc 00 00 	ld.weq	r12,sp[0x0]
	}
	else
	{
		return NULL;
	}
}
800040ce:	2f fd       	sub	sp,-4
800040d0:	d8 02       	popm	pc
800040d2:	00 00       	add	r0,r0
800040d4:	80 00       	ld.sh	r0,r0[0x0]
800040d6:	8c a8       	ld.uh	r8,r6[0x4]

800040d8 <phy_init>:
    register_rx_tx_func -- ssc.c
	xQueueCreate -- freertos
Called By: xnl_init -- xnl.c
*/
void phy_init( void )
{
800040d8:	eb cd 40 e0 	pushm	r5-r7,lr
    /*initialize the SSC*/
    ssc_init();
800040dc:	f0 1f 00 21 	mcall	80004160 <phy_init+0x88>

    /*register the func to send/receive ssc packet*/
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
800040e0:	4a 1b       	lddpc	r11,80004164 <phy_init+0x8c>
800040e2:	4a 2c       	lddpc	r12,80004168 <phy_init+0x90>
800040e4:	f0 1f 00 22 	mcall	8000416c <phy_init+0x94>
	
	/*if enable send/receive payload(media), defined in physical.h*/	
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
800040e8:	30 4b       	mov	r11,4
800040ea:	31 ec       	mov	r12,30
800040ec:	f0 1f 00 21 	mcall	80004170 <phy_init+0x98>
800040f0:	4a 18       	lddpc	r8,80004174 <phy_init+0x9c>
800040f2:	91 0c       	st.w	r8[0x0],r12
800040f4:	30 07       	mov	r7,0
	phy_fragment_t * xnl_ptr = NULL;
	for(int i= 0; i < MAX_XNL_STORE; i++ )
	{
		set_xnl_idle(&xnl_store[i]);
800040f6:	10 96       	mov	r6,r8
800040f8:	4a 05       	lddpc	r5,80004178 <phy_init+0xa0>
800040fa:	6c 0c       	ld.w	r12,r6[0x0]
800040fc:	ea 07 00 0b 	add	r11,r5,r7
80004100:	f0 1f 00 1f 	mcall	8000417c <phy_init+0xa4>
80004104:	ee c7 ff 00 	sub	r7,r7,-256
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
	
	/*if enable send/receive payload(media), defined in physical.h*/	
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
	phy_fragment_t * xnl_ptr = NULL;
	for(int i= 0; i < MAX_XNL_STORE; i++ )
80004108:	e0 47 1e 00 	cp.w	r7,7680
8000410c:	cf 71       	brne	800040fa <phy_init+0x22>
	{
		set_xnl_idle(&xnl_store[i]);
	}
		
    /*initialize the queue to send/receive xnl packet */	
    phy_xnl_frame_tx = xQueueCreate(TX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
8000410e:	30 4b       	mov	r11,4
80004110:	31 4c       	mov	r12,20
80004112:	f0 1f 00 18 	mcall	80004170 <phy_init+0x98>
80004116:	49 b8       	lddpc	r8,80004180 <phy_init+0xa8>
80004118:	91 0c       	st.w	r8[0x0],r12
    phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
8000411a:	30 4b       	mov	r11,4
8000411c:	30 ac       	mov	r12,10
8000411e:	f0 1f 00 15 	mcall	80004170 <phy_init+0x98>
80004122:	49 98       	lddpc	r8,80004184 <phy_init+0xac>
80004124:	91 0c       	st.w	r8[0x0],r12
	
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
80004126:	30 4b       	mov	r11,4
80004128:	30 ac       	mov	r12,10
8000412a:	f0 1f 00 12 	mcall	80004170 <phy_init+0x98>
8000412e:	49 78       	lddpc	r8,80004188 <phy_init+0xb0>
80004130:	91 0c       	st.w	r8[0x0],r12
80004132:	30 07       	mov	r7,0
	U8 * payload_ptr = NULL;
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
	{
		set_payload_idle(payload_store[i]);
80004134:	10 96       	mov	r6,r8
80004136:	49 65       	lddpc	r5,8000418c <phy_init+0xb4>
80004138:	6c 0c       	ld.w	r12,r6[0x0]
8000413a:	ea 07 00 0b 	add	r11,r5,r7
8000413e:	f0 1f 00 10 	mcall	8000417c <phy_init+0xa4>
80004142:	ee c7 fe 00 	sub	r7,r7,-512
    phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
	
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
	U8 * payload_ptr = NULL;
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
80004146:	e0 47 14 00 	cp.w	r7,5120
8000414a:	cf 71       	brne	80004138 <phy_init+0x60>
		set_payload_idle(payload_store[i]);
	}
		
	/*initialize the queue to send/receive xnl packet */
	phy_payload_frame_tx =
	xQueueCreate(TX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t));
8000414c:	e0 6b 01 00 	mov	r11,256
80004150:	30 5c       	mov	r12,5
80004152:	f0 1f 00 08 	mcall	80004170 <phy_init+0x98>
	{
		set_payload_idle(payload_store[i]);
	}
		
	/*initialize the queue to send/receive xnl packet */
	phy_payload_frame_tx =
80004156:	48 f8       	lddpc	r8,80004190 <phy_init+0xb8>
80004158:	91 0c       	st.w	r8[0x0],r12
		
	//phy_payload_frame_rx =
	//xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
	#endif /*end if*/
	
}
8000415a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000415e:	00 00       	add	r0,r0
80004160:	80 00       	ld.sh	r0,r0[0x0]
80004162:	4d 7c       	lddpc	r12,800042bc <phy_rx_func+0xc8>
80004164:	80 00       	ld.sh	r0,r0[0x0]
80004166:	3a f4       	mov	r4,-81
80004168:	80 00       	ld.sh	r0,r0[0x0]
8000416a:	41 f4       	lddsp	r4,sp[0x7c]
8000416c:	80 00       	ld.sh	r0,r0[0x0]
8000416e:	4d 68       	lddpc	r8,800042c4 <phy_rx_func+0xd0>
80004170:	80 00       	ld.sh	r0,r0[0x0]
80004172:	90 0c       	ld.sh	r12,r8[0x0]
80004174:	00 00       	add	r0,r0
80004176:	0f b8       	ld.ub	r8,r7[0x3]
80004178:	00 00       	add	r0,r0
8000417a:	27 d0       	sub	r0,125
8000417c:	80 00       	ld.sh	r0,r0[0x0]
8000417e:	3a 50       	mov	r0,-91
80004180:	00 00       	add	r0,r0
80004182:	0f e0       	ld.ub	r0,r7[0x6]
80004184:	00 00       	add	r0,r0
80004186:	0f cc       	ld.ub	r12,r7[0x4]
80004188:	00 00       	add	r0,r0
8000418a:	0f a8       	ld.ub	r8,r7[0x2]
8000418c:	00 00       	add	r0,r0
8000418e:	13 d0       	ld.ub	r0,r9[0x5]
80004190:	00 00       	add	r0,r0
80004192:	0f c4       	ld.ub	r4,r7[0x4]

80004194 <payload_rx>:




static void payload_rx(void * payload)
{
80004194:	d4 01       	pushm	lr
80004196:	20 2d       	sub	sp,8
80004198:	50 0c       	stdsp	sp[0x0],r12
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
8000419a:	30 08       	mov	r8,0
8000419c:	50 18       	stdsp	sp[0x4],r8
	
	//set_payload_idle(payload);
	if(NULL == phy_payload_frame_rx)
8000419e:	48 f8       	lddpc	r8,800041d8 <payload_rx+0x44>
800041a0:	70 08       	ld.w	r8,r8[0x0]
800041a2:	58 08       	cp.w	r8,0
800041a4:	c0 71       	brne	800041b2 <payload_rx+0x1e>
	{
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));		
800041a6:	30 4b       	mov	r11,4
800041a8:	30 5c       	mov	r12,5
800041aa:	f0 1f 00 0d 	mcall	800041dc <payload_rx+0x48>
800041ae:	48 b8       	lddpc	r8,800041d8 <payload_rx+0x44>
800041b0:	91 0c       	st.w	r8[0x0],r12
	}

	if(errQUEUE_FULL == xQueueSendFromISR(phy_payload_frame_rx, &payload, &xHigherPriorityTaskWoken))
800041b2:	48 a8       	lddpc	r8,800041d8 <payload_rx+0x44>
800041b4:	70 0c       	ld.w	r12,r8[0x0]
800041b6:	30 09       	mov	r9,0
800041b8:	fa ca ff fc 	sub	r10,sp,-4
800041bc:	1a 9b       	mov	r11,sp
800041be:	f0 1f 00 09 	mcall	800041e0 <payload_rx+0x4c>
800041c2:	c0 91       	brne	800041d4 <payload_rx+0x40>
	//if(errQUEUE_FULL == xQueueSend(phy_payload_frame_rx, &payload, 0))
	{	//To payload_rx_process();	
		
		set_payload_idle_isr(payload);
800041c4:	48 88       	lddpc	r8,800041e4 <payload_rx+0x50>
800041c6:	70 0c       	ld.w	r12,r8[0x0]
800041c8:	40 0b       	lddsp	r11,sp[0x0]
800041ca:	f0 1f 00 08 	mcall	800041e8 <payload_rx+0x54>
		logFromISR("mm");
800041ce:	48 8c       	lddpc	r12,800041ec <payload_rx+0x58>
800041d0:	f0 1f 00 08 	mcall	800041f0 <payload_rx+0x5c>
			
		}
		//set_payload_idle_isr(payload);
		//logFromISR("ss");
	}
}
800041d4:	2f ed       	sub	sp,-8
800041d6:	d8 02       	popm	pc
800041d8:	00 00       	add	r0,r0
800041da:	0f 8c       	ld.ub	r12,r7[0x0]
800041dc:	80 00       	ld.sh	r0,r0[0x0]
800041de:	90 0c       	ld.sh	r12,r8[0x0]
800041e0:	80 00       	ld.sh	r0,r0[0x0]
800041e2:	8e 64       	ld.sh	r4,r7[0xc]
800041e4:	00 00       	add	r0,r0
800041e6:	0f a8       	ld.ub	r8,r7[0x2]
800041e8:	80 00       	ld.sh	r0,r0[0x0]
800041ea:	39 fc       	mov	r12,-97
800041ec:	80 01       	ld.sh	r1,r0[0x0]
800041ee:	8a 58       	ld.sh	r8,r5[0xa]
800041f0:	80 00       	ld.sh	r0,r0[0x0]
800041f2:	9c 30       	ld.sh	r0,lr[0x6]

800041f4 <phy_rx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_rx_func( void * ssc)
{    
800041f4:	eb cd 40 e0 	pushm	r5-r7,lr
800041f8:	18 97       	mov	r7,r12
		
	if(NULL != phy_xnl_frame_rx)
800041fa:	fe f8 09 c6 	ld.w	r8,pc[2502]
800041fe:	70 08       	ld.w	r8,r8[0x0]
80004200:	58 08       	cp.w	r8,0
80004202:	e0 80 01 05 	breq	8000440c <phy_rx_func+0x218>
	static U16 phy_check_sum = 0;

	static phy_rx_state_t  phy_rx_state = WAITING_FOR_HEADER;
	static U32 phy_rx_count = 0;

	U32 phy_dword = xnl_rx_channel->dword;	
80004206:	78 16       	ld.w	r6,r12[0x4]

	phy_rx_count++;
80004208:	fe f8 09 bc 	ld.w	r8,pc[2492]
8000420c:	70 09       	ld.w	r9,r8[0x0]
8000420e:	2f f9       	sub	r9,-1
80004210:	91 09       	st.w	r8[0x0],r9
	
	/*This is the code for parsing the incoming physical message.*/
	switch (phy_rx_state)
80004212:	fe f8 09 b6 	ld.w	r8,pc[2486]
80004216:	70 08       	ld.w	r8,r8[0x0]
80004218:	58 18       	cp.w	r8,1
8000421a:	e0 80 00 84 	breq	80004322 <phy_rx_func+0x12e>
8000421e:	c0 73       	brcs	8000422c <phy_rx_func+0x38>
80004220:	58 28       	cp.w	r8,2
80004222:	c5 b0       	breq	800042d8 <phy_rx_func+0xe4>
80004224:	58 38       	cp.w	r8,3
80004226:	e0 81 00 f3 	brne	8000440c <phy_rx_func+0x218>
8000422a:	cd 38       	rjmp	800043d0 <phy_rx_func+0x1dc>

        /*Waiting for something. Most frequent visit.*/		
		case WAITING_FOR_HEADER:
		
			/*Ignore Idles.*/
			if (0xABCD5A5A == phy_dword)
8000422c:	e0 6a 5a 5a 	mov	r10,23130
80004230:	ea 1a ab cd 	orh	r10,0xabcd
80004234:	14 36       	cp.w	r6,r10
80004236:	e0 80 00 eb 	breq	8000440c <phy_rx_func+0x218>
			{
				break;
			}	

			/*Skip until Header.*/		
			if (0xABCD != (phy_dword >> 16))
8000423a:	ec 08 16 10 	lsr	r8,r6,0x10
8000423e:	e0 48 ab cd 	cp.w	r8,43981
80004242:	e0 81 00 e5 	brne	8000440c <phy_rx_func+0x218>
			{			
				break;
			}
		
			/*Length excluding CSUM.*/
			phy_rx_expexted_length = (phy_dword & 0x000000FF) - 2;
80004246:	eb d6 b0 10 	bfexts	r5,r6,0x0,0x10
8000424a:	f1 d5 c0 08 	bfextu	r8,r5,0x0,0x8
8000424e:	20 28       	sub	r8,2
80004250:	fe f9 09 7c 	ld.w	r9,pc[2428]
80004254:	b2 08       	st.h	r9[0x0],r8
			
			/*Discard degenerate message.*/
			if (phy_rx_expexted_length <= 0)
80004256:	30 09       	mov	r9,0
80004258:	f2 08 19 00 	cp.h	r8,r9
8000425c:	e0 8a 00 d8 	brle	8000440c <phy_rx_func+0x218>
			{
				break;
			}
		
			phy_rx_length = 0;
80004260:	fe f8 09 70 	ld.w	r8,pc[2416]
80004264:	b0 09       	st.h	r8[0x0],r9
			
			//get_xnl_idle_isr(&phy_frame_ptr, &xHigherPriorityTaskWoken);
			phy_frame_ptr = get_xnl_idle_isr();
80004266:	fe f8 09 6e 	ld.w	r8,pc[2414]
8000426a:	70 0c       	ld.w	r12,r8[0x0]
8000426c:	f0 1f 02 5b 	mcall	80004bd8 <phy_rx_func+0x9e4>
80004270:	fe f8 09 6c 	ld.w	r8,pc[2412]
80004274:	91 0c       	st.w	r8[0x0],r12
			if(NULL == phy_frame_ptr)
80004276:	58 0c       	cp.w	r12,0
80004278:	e0 80 00 ca 	breq	8000440c <phy_rx_func+0x218>
			//
			//xQueueReceiveFromISR(phy_store_idle, &phy_frame_ptr, &xHigherPriorityTaskWoken);
			
			//phy_frame_ptr = pvPortMalloc(sizeof(phy_fragment_t));
					
			phy_frame_ptr->fragment_element[phy_rx_length++] = phy_dword;
8000427c:	fe f8 09 54 	ld.w	r8,pc[2388]
80004280:	90 09       	ld.sh	r9,r8[0x0]
80004282:	f8 09 0a 15 	st.h	r12[r9<<0x1],r5
80004286:	2f f9       	sub	r9,-1
80004288:	5c 89       	casts.h	r9
			
			/*time stamp*/
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
8000428a:	fe fa 09 52 	ld.w	r10,pc[2386]
8000428e:	74 0a       	ld.w	r10,r10[0x0]
80004290:	fe fb 09 34 	ld.w	r11,pc[2356]
80004294:	76 0b       	ld.w	r11,r11[0x0]
80004296:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
8000429a:	2f f9       	sub	r9,-1
8000429c:	b0 09       	st.h	r8[0x0],r9
													(phy_rx_count) & 0x0000FFFF;
			
			/*This switch tests the fragment type, and adjusts receiver state
			accordingly.*/
			/*Check frag type*/
			switch (phy_dword & 0x00000F00)
8000429e:	e2 16 0f 00 	andl	r6,0xf00,COH
800042a2:	e0 46 01 00 	cp.w	r6,256
800042a6:	c0 c0       	breq	800042be <phy_rx_func+0xca>
800042a8:	e0 8b 00 05 	brhi	800042b2 <phy_rx_func+0xbe>
800042ac:	58 06       	cp.w	r6,0
800042ae:	c0 80       	breq	800042be <phy_rx_func+0xca>
800042b0:	c0 c8       	rjmp	800042c8 <phy_rx_func+0xd4>
800042b2:	e0 46 02 00 	cp.w	r6,512
800042b6:	c0 40       	breq	800042be <phy_rx_func+0xca>
800042b8:	e0 46 03 00 	cp.w	r6,768
800042bc:	c0 61       	brne	800042c8 <phy_rx_func+0xd4>
			{
				case SINGLE_FRAGMENT:  //Only Fragment.
				case FIRST_FRAGMENT:   //First of Multi-fragment.
				case MIDDLE_FRAGMENT:  //Continuing Multi-fragment.
				case LAST_FRAGMENT:    //Last Multi-fragment.
					phy_rx_state = WAITING_CHECK_SUM;
800042be:	30 29       	mov	r9,2
800042c0:	fe f8 09 08 	ld.w	r8,pc[2312]
800042c4:	91 09       	st.w	r8[0x0],r9
800042c6:	ca 38       	rjmp	8000440c <phy_rx_func+0x218>
				break;
				default:
					vPortFree(phy_frame_ptr);
800042c8:	fe f6 09 14 	ld.w	r6,pc[2324]
800042cc:	6c 0c       	ld.w	r12,r6[0x0]
800042ce:	f0 1f 02 45 	mcall	80004be0 <phy_rx_func+0x9ec>
					phy_frame_ptr = NULL;					
800042d2:	30 08       	mov	r8,0
800042d4:	8d 08       	st.w	r6[0x0],r8
800042d6:	c9 b8       	rjmp	8000440c <phy_rx_func+0x218>
		
			/*Stores CSUM*/
			phy_check_sum  = (phy_dword & 0xFFFF0000) >> 16;
			
			/*sums in first hWord*/
			phy_check_sum += (phy_dword & 0x0000FFFF);		
800042d8:	f5 d6 b0 10 	bfexts	r10,r6,0x0,0x10
800042dc:	b1 86       	lsr	r6,0x10
800042de:	14 06       	add	r6,r10
800042e0:	fe f8 09 04 	ld.w	r8,pc[2308]
800042e4:	b0 06       	st.h	r8[0x0],r6
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
800042e6:	fe f8 08 ea 	ld.w	r8,pc[2282]
800042ea:	90 09       	ld.sh	r9,r8[0x0]
800042ec:	fe fb 08 f0 	ld.w	r11,pc[2288]
800042f0:	76 0b       	ld.w	r11,r11[0x0]
800042f2:	f6 09 0a 1a 	st.h	r11[r9<<0x1],r10
800042f6:	2f f9       	sub	r9,-1
800042f8:	b0 09       	st.h	r8[0x0],r9
														 phy_dword & 0x0000FFFF;
					
			phy_rx_expexted_length -= 2;
800042fa:	fe f9 08 d2 	ld.w	r9,pc[2258]
800042fe:	92 08       	ld.sh	r8,r9[0x0]
80004300:	20 28       	sub	r8,2
80004302:	b2 08       	st.h	r9[0x0],r8
			
			/*Normal case for greater than one byte payloads.*/
			if (phy_rx_expexted_length > 0)
80004304:	30 09       	mov	r9,0
80004306:	f2 08 19 00 	cp.h	r8,r9
8000430a:	e0 8a 00 07 	brle	80004318 <phy_rx_func+0x124>
			{					  
				phy_rx_state = READING_FRAGMENT;
8000430e:	30 19       	mov	r9,1
80004310:	fe f8 08 b8 	ld.w	r8,pc[2232]
80004314:	91 09       	st.w	r8[0x0],r9
80004316:	c7 b8       	rjmp	8000440c <phy_rx_func+0x218>
	    		Note that all segments must align with a 32-bit boundary and
				beginning of each XCMP/XNL payload frame must start on slot 3
				Thus, segments of odd length must append a 0x0000 at the end
				(slot 4) to ensure alignment. [9.1.3]
				*/
				phy_rx_state = WAITING_LAST_TERM;
80004318:	30 39       	mov	r9,3
8000431a:	fe f8 08 ae 	ld.w	r8,pc[2222]
8000431e:	91 09       	st.w	r8[0x0],r9
80004320:	c7 68       	rjmp	8000440c <phy_rx_func+0x218>
			}			
		
			break;

		case READING_FRAGMENT:
			phy_check_sum += (phy_dword & 0xFFFF0000) >> 16;
80004322:	ec 0a 14 10 	asr	r10,r6,0x10
80004326:	fe f8 08 be 	ld.w	r8,pc[2238]
8000432a:	90 09       	ld.sh	r9,r8[0x0]
8000432c:	14 09       	add	r9,r10
8000432e:	b0 09       	st.h	r8[0x0],r9
	
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
80004330:	fe f9 08 a0 	ld.w	r9,pc[2208]
80004334:	92 08       	ld.sh	r8,r9[0x0]
80004336:	fe fb 08 a6 	ld.w	r11,pc[2214]
8000433a:	76 0b       	ld.w	r11,r11[0x0]
8000433c:	f6 08 0a 1a 	st.h	r11[r8<<0x1],r10
80004340:	2f f8       	sub	r8,-1
80004342:	5c 88       	casts.h	r8
80004344:	b2 08       	st.h	r9[0x0],r8
												 (phy_dword & 0xFFFF0000) >> 16;
	
			phy_rx_expexted_length -= 2;
80004346:	fe fa 08 86 	ld.w	r10,pc[2182]
8000434a:	94 09       	ld.sh	r9,r10[0x0]
8000434c:	20 29       	sub	r9,2
8000434e:	b4 09       	st.h	r10[0x0],r9
			if (phy_rx_expexted_length <= 0)
80004350:	30 0a       	mov	r10,0
80004352:	f4 09 19 00 	cp.h	r9,r10
80004356:	e0 89 00 1f 	brgt	80004394 <phy_rx_func+0x1a0>
				Terminator should be in 2nd hWord.
				Shaoqun says useful bits not used. The packet will always end
				with $00BA. [9.1.2.8]	
				*/
				
				if ((0x000000BA == (phy_dword  & 0x0000FFFF)) 
8000435a:	ed d6 c0 10 	bfextu	r6,r6,0x0,0x10
8000435e:	e0 46 00 ba 	cp.w	r6,186
80004362:	c0 d1       	brne	8000437c <phy_rx_func+0x188>
80004364:	fe f8 08 80 	ld.w	r8,pc[2176]
80004368:	90 09       	ld.sh	r9,r8[0x0]
8000436a:	f4 09 19 00 	cp.h	r9,r10
8000436e:	c0 71       	brne	8000437c <phy_rx_func+0x188>
					&& (phy_check_sum == 0))
				{
					phy_rx(phy_frame_ptr);
80004370:	fe f8 08 6c 	ld.w	r8,pc[2156]
80004374:	70 0c       	ld.w	r12,r8[0x0]
80004376:	f0 1f 02 1d 	mcall	80004be8 <phy_rx_func+0x9f4>
8000437a:	c0 88       	rjmp	8000438a <phy_rx_func+0x196>
				}
				else
				{
					vPortFree(phy_frame_ptr);
8000437c:	fe f6 08 60 	ld.w	r6,pc[2144]
80004380:	6c 0c       	ld.w	r12,r6[0x0]
80004382:	f0 1f 02 18 	mcall	80004be0 <phy_rx_func+0x9ec>
					phy_frame_ptr = NULL;
80004386:	30 08       	mov	r8,0
80004388:	8d 08       	st.w	r6[0x0],r8
				}

				phy_rx_state = WAITING_FOR_HEADER;
8000438a:	30 09       	mov	r9,0
8000438c:	fe f8 08 3c 	ld.w	r8,pc[2108]
80004390:	91 09       	st.w	r8[0x0],r9
80004392:	c3 d8       	rjmp	8000440c <phy_rx_func+0x218>
				break;
			}
		
			/*Have not broken. 2nd hWord contains payload.*/
			phy_check_sum += (phy_dword & 0x0000FFFF);
80004394:	5c 86       	casts.h	r6
80004396:	fe f9 08 4e 	ld.w	r9,pc[2126]
8000439a:	92 0a       	ld.sh	r10,r9[0x0]
8000439c:	0c 0a       	add	r10,r6
8000439e:	b2 0a       	st.h	r9[0x0],r10
		
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
800043a0:	fe f9 08 3c 	ld.w	r9,pc[2108]
800043a4:	72 09       	ld.w	r9,r9[0x0]
800043a6:	f2 08 0a 16 	st.h	r9[r8<<0x1],r6
800043aa:	2f f8       	sub	r8,-1
800043ac:	fe f9 08 24 	ld.w	r9,pc[2084]
800043b0:	b2 08       	st.h	r9[0x0],r8
													   (phy_dword & 0x0000FFFF);
		
			phy_rx_expexted_length -= 2;
800043b2:	fe f9 08 1a 	ld.w	r9,pc[2074]
800043b6:	92 08       	ld.sh	r8,r9[0x0]
800043b8:	20 28       	sub	r8,2
800043ba:	b2 08       	st.h	r9[0x0],r8
			if (phy_rx_expexted_length <= 0)
800043bc:	30 09       	mov	r9,0
800043be:	f2 08 19 00 	cp.h	r8,r9
800043c2:	e0 89 00 25 	brgt	8000440c <phy_rx_func+0x218>
			{
				/*All read in. Next Word should be 0x00BA0000.*/
				phy_rx_state = WAITING_LAST_TERM;
800043c6:	30 39       	mov	r9,3
800043c8:	fe f8 08 00 	ld.w	r8,pc[2048]
800043cc:	91 09       	st.w	r8[0x0],r9
800043ce:	c1 f8       	rjmp	8000440c <phy_rx_func+0x218>
			}/*else, next Word contains more payload.*/
			break;

		/*Expecting last terminator 0x00BA0000.*/	
		case WAITING_LAST_TERM:			
			if ((0x00BA0000 == (phy_dword  & 0x00FF0000)) /*Expected found.*/
800043d0:	e6 16 00 ff 	andh	r6,0xff,COH
800043d4:	fc 19 00 ba 	movh	r9,0xba
800043d8:	12 36       	cp.w	r6,r9
800043da:	c0 e1       	brne	800043f6 <phy_rx_func+0x202>
800043dc:	fe f8 08 08 	ld.w	r8,pc[2056]
800043e0:	90 09       	ld.sh	r9,r8[0x0]
800043e2:	30 08       	mov	r8,0
800043e4:	f0 09 19 00 	cp.h	r9,r8
800043e8:	c0 71       	brne	800043f6 <phy_rx_func+0x202>
				&& (phy_check_sum == 0))/*Good checksum*/
			{
				phy_rx(phy_frame_ptr);
800043ea:	fe f8 07 f2 	ld.w	r8,pc[2034]
800043ee:	70 0c       	ld.w	r12,r8[0x0]
800043f0:	f0 1f 01 fe 	mcall	80004be8 <phy_rx_func+0x9f4>
800043f4:	c0 88       	rjmp	80004404 <phy_rx_func+0x210>

			}
			else
			{
				vPortFree(phy_frame_ptr);
800043f6:	fe f6 07 e6 	ld.w	r6,pc[2022]
800043fa:	6c 0c       	ld.w	r12,r6[0x0]
800043fc:	f0 1f 01 f9 	mcall	80004be0 <phy_rx_func+0x9ec>
				phy_frame_ptr = NULL;
80004400:	30 08       	mov	r8,0
80004402:	8d 08       	st.w	r6[0x0],r8
			}
				
			phy_rx_state = WAITING_FOR_HEADER;
80004404:	30 09       	mov	r9,0
80004406:	fe f8 07 c2 	ld.w	r8,pc[1986]
8000440a:	91 09       	st.w	r8[0x0],r9
			
	//payload_ptr_t *AMBE_payload_ptr;		
				
	
	
	if(is_first == FALSE)
8000440c:	fe f8 07 e0 	ld.w	r8,pc[2016]
80004410:	11 89       	ld.ub	r9,r8[0x0]
80004412:	30 08       	mov	r8,0
80004414:	f0 09 18 00 	cp.b	r9,r8
80004418:	c1 31       	brne	8000443e <phy_rx_func+0x24a>
	{
		payload_ptr = get_payload_idle_isr();
8000441a:	fe f6 07 d6 	ld.w	r6,pc[2006]
8000441e:	6c 0c       	ld.w	r12,r6[0x0]
80004420:	f0 1f 01 ee 	mcall	80004bd8 <phy_rx_func+0x9e4>
80004424:	fe f8 07 d0 	ld.w	r8,pc[2000]
80004428:	91 0c       	st.w	r8[0x0],r12
		AMBE_payload_ptr = get_payload_idle_isr();
8000442a:	6c 0c       	ld.w	r12,r6[0x0]
8000442c:	f0 1f 01 eb 	mcall	80004bd8 <phy_rx_func+0x9e4>
80004430:	fe f8 07 c8 	ld.w	r8,pc[1992]
80004434:	91 0c       	st.w	r8[0x0],r12
		is_first = TRUE;
80004436:	30 19       	mov	r9,1
80004438:	fe f8 07 b4 	ld.w	r8,pc[1972]
8000443c:	b0 89       	st.b	r8[0x0],r9
	}	
	
	//This is the RxMedia Phy Handler.
	switch (RxMediaState)
8000443e:	fe f8 07 be 	ld.w	r8,pc[1982]
80004442:	70 08       	ld.w	r8,r8[0x0]
80004444:	58 28       	cp.w	r8,2
80004446:	e0 80 01 67 	breq	80004714 <phy_rx_func+0x520>
8000444a:	58 38       	cp.w	r8,3
8000444c:	e0 80 02 25 	breq	80004896 <phy_rx_func+0x6a2>
80004450:	58 08       	cp.w	r8,0
80004452:	e0 81 03 b5 	brne	80004bbc <phy_rx_func+0x9c8>
	{
		case WAITINGABAB:

			
			if (payload_rx_channel->dword[0] == 0xABCD5A5A)//Ignore Idles.
80004456:	6e 28       	ld.w	r8,r7[0x8]
80004458:	e0 6a 5a 5a 	mov	r10,23130
8000445c:	ea 1a ab cd 	orh	r10,0xabcd
80004460:	14 38       	cp.w	r8,r10
80004462:	c0 71       	brne	80004470 <phy_rx_func+0x27c>
			{
				m_RxBurstType = VOICE_WATING;
80004464:	30 09       	mov	r9,0
80004466:	fe f8 07 9a 	ld.w	r8,pc[1946]
8000446a:	91 09       	st.w	r8[0x0],r9
8000446c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
				//Upon receiving the idle frame, the m Rx Burst Type into an idle state in order to transmit the synchronization wait
				 break; 
			}
            
			if ((payload_rx_channel->dword[0]  & 0xFFFF0000) != 0xABCD0000)break; //Skip until Header. 
80004470:	10 99       	mov	r9,r8
80004472:	e0 19 00 00 	andl	r9,0x0
80004476:	fc 1a ab cd 	movh	r10,0xabcd
8000447a:	14 39       	cp.w	r9,r10
8000447c:	e0 81 03 a0 	brne	80004bbc <phy_rx_func+0x9c8>
			}
			//logFromISR("\n\r P: %X \n\r", payload_rx_channel->word[1]);//
			
			#endif
			
			RxBytesWaiting = payload_rx_channel->dword[0] & 0x000000FF;
80004480:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
80004484:	fe f9 07 80 	ld.w	r9,pc[1920]
80004488:	93 08       	st.w	r9[0x0],r8
		
			if((NULL== payload_ptr) || (NULL== AMBE_payload_ptr))
8000448a:	fe f8 07 6a 	ld.w	r8,pc[1898]
8000448e:	70 08       	ld.w	r8,r8[0x0]
80004490:	58 08       	cp.w	r8,0
80004492:	c0 60       	breq	8000449e <phy_rx_func+0x2aa>
80004494:	fe f8 07 64 	ld.w	r8,pc[1892]
80004498:	70 08       	ld.w	r8,r8[0x0]
8000449a:	58 08       	cp.w	r8,0
8000449c:	c1 61       	brne	800044c8 <phy_rx_func+0x2d4>
			{
				payload_ptr = get_payload_idle_isr();
8000449e:	fe f6 07 52 	ld.w	r6,pc[1874]
800044a2:	6c 0c       	ld.w	r12,r6[0x0]
800044a4:	f0 1f 01 cd 	mcall	80004bd8 <phy_rx_func+0x9e4>
800044a8:	fe f5 07 4c 	ld.w	r5,pc[1868]
800044ac:	8b 0c       	st.w	r5[0x0],r12
				AMBE_payload_ptr = get_payload_idle_isr();
800044ae:	6c 0c       	ld.w	r12,r6[0x0]
800044b0:	f0 1f 01 ca 	mcall	80004bd8 <phy_rx_func+0x9e4>
800044b4:	fe f8 07 44 	ld.w	r8,pc[1860]
800044b8:	91 0c       	st.w	r8[0x0],r12
				
				if((NULL== payload_ptr) || (NULL== AMBE_payload_ptr))
800044ba:	6a 08       	ld.w	r8,r5[0x0]
800044bc:	58 08       	cp.w	r8,0
800044be:	e0 80 03 7f 	breq	80004bbc <phy_rx_func+0x9c8>
800044c2:	58 0c       	cp.w	r12,0
800044c4:	e0 80 03 7c 	breq	80004bbc <phy_rx_func+0x9c8>
			}
			
		
			/****Note AMBE stream protocol frame structure and the PCM frame structure is different*****/
					
			if ((payload_rx_channel->dword[0] & 0x0000F000 ) == PAYLOAD_DATA_ENH )//PAYLOAD_DATA_ENH (0x0c))
800044c8:	6e 28       	ld.w	r8,r7[0x8]
800044ca:	e2 18 f0 00 	andl	r8,0xf000,COH
800044ce:	e0 48 c0 00 	cp.w	r8,49152
800044d2:	e0 81 00 8e 	brne	800045ee <phy_rx_func+0x3fa>
			{
				AMBE_flag = 1;
800044d6:	30 19       	mov	r9,1
800044d8:	fe f8 07 30 	ld.w	r8,pc[1840]
800044dc:	b0 89       	st.b	r8[0x0],r9
								
				Item_ID = payload_rx_channel->byte[5];
800044de:	ef 39 00 0d 	ld.ub	r9,r7[13]
800044e2:	fe f8 07 2a 	ld.w	r8,pc[1834]
800044e6:	b0 89       	st.b	r8[0x0],r9
				
				VF_SN = payload_rx_channel->byte[7];//This parameter is very important to the loop back Radio, as a reference.
800044e8:	ef 3c 00 0f 	ld.ub	r12,r7[15]
800044ec:	fe f9 07 24 	ld.w	r9,pc[1828]
800044f0:	b2 8c       	st.b	r9[0x0],r12
					
				//The OB know the Call begin and discard the Voice Header
				//The OB know the Call end and discard the Voice  Terminator			
				if (Item_ID == Raw_Tx_Data_HT)
800044f2:	11 89       	ld.ub	r9,r8[0x0]
800044f4:	3f 08       	mov	r8,-16
800044f6:	f0 09 18 00 	cp.b	r9,r8
800044fa:	c2 b1       	brne	80004550 <phy_rx_func+0x35c>
				{
					//HT_index = 0;
					//AMBE_HT[0] = payload_rx_channel->dword[0];
					//AMBE_HT[1] = payload_rx_channel->dword[1];
					//
					if ((payload_rx_channel->byte[6] & 0xF0 )== 0x10)//header
800044fc:	ef 38 00 0e 	ld.ub	r8,r7[14]
80004500:	e2 18 00 f0 	andl	r8,0xf0,COH
80004504:	59 08       	cp.w	r8,16
80004506:	c0 71       	brne	80004514 <phy_rx_func+0x320>
					{
						m_RxBurstType = VOICEHEADER;		
80004508:	30 19       	mov	r9,1
8000450a:	fe f8 06 f6 	ld.w	r8,pc[1782]
8000450e:	91 09       	st.w	r8[0x0],r9
80004510:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

					}
					else if ((payload_rx_channel->byte[6] & 0xF0) == 0x20)//Terminator
80004514:	e0 48 00 20 	cp.w	r8,32
80004518:	c1 61       	brne	80004544 <phy_rx_func+0x350>
					{
						m_RxBurstType = VOICETERMINATOR;
8000451a:	30 99       	mov	r9,9
8000451c:	fe f8 06 e4 	ld.w	r8,pc[1764]
80004520:	91 09       	st.w	r8[0x0],r9
						//In order to complete the save data AMBE stream to SDcard.
						//AMBE-data and PCM-data is not the same. AMBE is compressed data,
						//if there was a missing portion, a clear voice is difficult to extract the data. 
						//It must ensure that all the data received AMBE.
						RxAMBE_IsFillingNext8 = 0;
80004522:	30 09       	mov	r9,0
80004524:	fe f8 06 f0 	ld.w	r8,pc[1776]
80004528:	91 09       	st.w	r8[0x0],r9
						payload_rx(AMBE_payload_ptr);//0
8000452a:	fe f7 06 ce 	ld.w	r7,pc[1742]
8000452e:	6e 0c       	ld.w	r12,r7[0x0]
80004530:	f0 1f 01 ba 	mcall	80004c18 <phy_rx_func+0xa24>
						AMBE_payload_ptr = get_payload_idle_isr();
80004534:	fe f8 06 bc 	ld.w	r8,pc[1724]
80004538:	70 0c       	ld.w	r12,r8[0x0]
8000453a:	f0 1f 01 a8 	mcall	80004bd8 <phy_rx_func+0x9e4>
8000453e:	8f 0c       	st.w	r7[0x0],r12
80004540:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						//logFromISR("\n\r QQ1 \n\r");
						
					}
					else//error voice
					{
						m_RxBurstType = VOICE_WATING;
80004544:	30 09       	mov	r9,0
80004546:	fe f8 06 ba 	ld.w	r8,pc[1722]
8000454a:	91 09       	st.w	r8[0x0],r9
8000454c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					
					break;//WAITINGABAB.
		
						
				}
				else if (Item_ID == Vocoder_Bit_Stream_Parameter)//Vocoder Bits Stream Parameter
80004550:	fe f8 06 bc 	ld.w	r8,pc[1724]
80004554:	11 89       	ld.ub	r9,r8[0x0]
80004556:	31 28       	mov	r8,18
80004558:	f0 09 18 00 	cp.b	r9,r8
8000455c:	c0 d1       	brne	80004576 <phy_rx_func+0x382>
				{	
						
						VBSP_data[0] = payload_rx_channel->word[2];
8000455e:	8e 69       	ld.sh	r9,r7[0xc]
80004560:	fe f8 06 bc 	ld.w	r8,pc[1724]
80004564:	b0 09       	st.h	r8[0x0],r9
						VBSP_data[1] = payload_rx_channel->word[3];
80004566:	8e 79       	ld.sh	r9,r7[0xe]
80004568:	b0 19       	st.h	r8[0x2],r9
						m_RxBurstType = CalculateBurst(VF_SN);
8000456a:	f0 1f 01 ae 	mcall	80004c20 <phy_rx_func+0xa2c>
8000456e:	fe f8 06 92 	ld.w	r8,pc[1682]
80004572:	91 0c       	st.w	r8[0x0],r12
80004574:	c3 78       	rjmp	800045e2 <phy_rx_func+0x3ee>

				}
				else if ((Item_ID == 0x04) || (Item_ID == 0x03) )//Unknown type data directly back hair
80004576:	fe f8 06 96 	ld.w	r8,pc[1686]
8000457a:	11 89       	ld.ub	r9,r8[0x0]
8000457c:	30 48       	mov	r8,4
8000457e:	f0 09 18 00 	cp.b	r9,r8
80004582:	c0 80       	breq	80004592 <phy_rx_func+0x39e>
80004584:	fe f8 06 88 	ld.w	r8,pc[1672]
80004588:	11 89       	ld.ub	r9,r8[0x0]
8000458a:	30 38       	mov	r8,3
8000458c:	f0 09 18 00 	cp.b	r9,r8
80004590:	c1 c1       	brne	800045c8 <phy_rx_func+0x3d4>
				{
					//break;
					m_RxBurstType = UNSUREDATA;
80004592:	30 29       	mov	r9,2
80004594:	fe f8 06 6c 	ld.w	r8,pc[1644]
80004598:	91 09       	st.w	r8[0x0],r9
					AMBE_HT[0] = payload_rx_channel->dword[0];
8000459a:	6e 29       	ld.w	r9,r7[0x8]
8000459c:	fe f8 06 88 	ld.w	r8,pc[1672]
800045a0:	91 09       	st.w	r8[0x0],r9
					AMBE_HT[1] = payload_rx_channel->dword[1];
800045a2:	6e 39       	ld.w	r9,r7[0xc]
800045a4:	91 19       	st.w	r8[0x4],r9
					
					if (RxBytesWaiting == 0x00000014)
800045a6:	fe f8 06 5e 	ld.w	r8,pc[1630]
800045aa:	70 08       	ld.w	r8,r8[0x0]
800045ac:	59 48       	cp.w	r8,20
800045ae:	c0 61       	brne	800045ba <phy_rx_func+0x3c6>
					{
						RxBytesWaiting = 0x18;//24 Reassigned
800045b0:	31 89       	mov	r9,24
800045b2:	fe f8 06 52 	ld.w	r8,pc[1618]
800045b6:	91 09       	st.w	r8[0x0],r9
800045b8:	c1 58       	rjmp	800045e2 <phy_rx_func+0x3ee>
						//_flag =0;
							
					}
					if (RxBytesWaiting == 0x00000010)
800045ba:	59 08       	cp.w	r8,16
800045bc:	c1 31       	brne	800045e2 <phy_rx_func+0x3ee>
					{
						RxBytesWaiting = 0x10;//16 Reassigned
800045be:	31 09       	mov	r9,16
800045c0:	fe f8 06 44 	ld.w	r8,pc[1604]
800045c4:	91 09       	st.w	r8[0x0],r9
800045c6:	c0 e8       	rjmp	800045e2 <phy_rx_func+0x3ee>
					
				}
				else
				{
					
					logFromISR("\n\r Item_ID:%x \n\r", payload_rx_channel->word[2]);
800045c8:	8e e8       	ld.uh	r8,r7[0xc]
800045ca:	1a d8       	st.w	--sp,r8
800045cc:	fe fc 06 5c 	ld.w	r12,pc[1628]
800045d0:	f0 1f 01 97 	mcall	80004c2c <phy_rx_func+0xa38>
					logFromISR("\n\r Axiba \n\r");
800045d4:	fe fc 06 5c 	ld.w	r12,pc[1628]
800045d8:	f0 1f 01 95 	mcall	80004c2c <phy_rx_func+0xa38>
800045dc:	2f fd       	sub	sp,-4
800045de:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					//Radio Internal Parameter(0x7F):
					//The OB should use the route back this item to radio without change content.
					break;
				}
				
				RxMediaState = READING_AMBE_MEDIA;//Jump
800045e2:	30 39       	mov	r9,3
800045e4:	fe f8 06 18 	ld.w	r8,pc[1560]
800045e8:	91 09       	st.w	r8[0x0],r9
800045ea:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
			else//PCM-media-data
			{	
				//logFromISR("\n\r RX:%x \n\r", payload_rx_channel->dword[0]);
				//SPEAKER_DATA or  //MIC_DATA
				if (((payload_rx_channel->dword[0] & 0x0000F000 ) != SPEAKER_DATA ) 
800045ee:	e0 48 10 00 	cp.w	r8,4096
800045f2:	5f 19       	srne	r9
800045f4:	e0 48 20 00 	cp.w	r8,8192
800045f8:	5f 18       	srne	r8
800045fa:	f3 e8 00 08 	and	r8,r9,r8
800045fe:	e0 81 02 df 	brne	80004bbc <phy_rx_func+0x9c8>
					&& ((payload_rx_channel->dword[0] & 0x0000F000 ) != MIC_DATA ))break;
				
				AMBE_flag = 0;
80004602:	fe f9 06 06 	ld.w	r9,pc[1542]
80004606:	b2 88       	st.b	r9[0x0],r8
				
				Item_ID = 0;//To make sure your save PCM data.
80004608:	fe f9 06 04 	ld.w	r9,pc[1540]
8000460c:	b2 88       	st.b	r9[0x0],r8
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
8000460e:	6e 28       	ld.w	r8,r7[0x8]
80004610:	e2 18 0f 00 	andl	r8,0xf00,COH
80004614:	58 18       	cp.w	r8,1
80004616:	e0 8b 00 4d 	brhi	800046b0 <phy_rx_func+0x4bc>
				
				if ((payload_rx_channel->dword[0]  & 0x00000F00) <= 1){  //Frag type must process Array Discriptor.
				//The first word of the media access payload must be the Array descriptor length. And the
				//unit of the length is in word (16-bit). The length field itself does not count into the length.
				//When there is no array descriptor, the length must be set to zero.[9.1.4.1]
				if ((RxBytesWaiting -= 4) <= 0) break;          //Nothing beyond this Phy buffer. Keep looking for Header
8000461a:	fe f9 05 ea 	ld.w	r9,pc[1514]
8000461e:	72 08       	ld.w	r8,r9[0x0]
80004620:	20 48       	sub	r8,4
80004622:	93 08       	st.w	r9[0x0],r8
80004624:	e0 80 02 cc 	breq	80004bbc <phy_rx_func+0x9c8>
				ArrayDiscLength = payload_rx_channel->word[2];
80004628:	8e 68       	ld.sh	r8,r7[0xc]
8000462a:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8000462e:	fe f9 06 06 	ld.w	r9,pc[1542]
80004632:	93 0a       	st.w	r9[0x0],r10
				
				switch (ArrayDiscLength){
80004634:	30 09       	mov	r9,0
80004636:	f2 08 19 00 	cp.h	r8,r9
8000463a:	c0 70       	breq	80004648 <phy_rx_func+0x454>
8000463c:	30 19       	mov	r9,1
8000463e:	f2 08 19 00 	cp.h	r8,r9
80004642:	e0 81 02 bd 	brne	80004bbc <phy_rx_func+0x9c8>
80004646:	c2 68       	rjmp	80004692 <phy_rx_func+0x49e>
					case 0:          //The usual case. Remaining word in Phy buffer is Audio.
								
						payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
80004648:	fe f8 05 f0 	ld.w	r8,pc[1520]
8000464c:	70 0a       	ld.w	r10,r8[0x0]
8000464e:	fe f9 05 a6 	ld.w	r9,pc[1446]
80004652:	72 09       	ld.w	r9,r9[0x0]
80004654:	8e 7b       	ld.sh	r11,r7[0xe]
80004656:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
						RxMedia_IsFillingNext16 += 1;
8000465a:	70 09       	ld.w	r9,r8[0x0]
8000465c:	2f f9       	sub	r9,-1
8000465e:	91 09       	st.w	r8[0x0],r9
						if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80004660:	e0 49 00 ff 	cp.w	r9,255
80004664:	e0 88 00 11 	brls	80004686 <phy_rx_func+0x492>
						{
							RxMedia_IsFillingNext16 = 0;	
80004668:	30 09       	mov	r9,0
8000466a:	91 09       	st.w	r8[0x0],r9
							payload_rx(payload_ptr);	
8000466c:	fe f7 05 88 	ld.w	r7,pc[1416]
80004670:	6e 0c       	ld.w	r12,r7[0x0]
80004672:	f0 1f 01 6a 	mcall	80004c18 <phy_rx_func+0xa24>
							payload_ptr = get_payload_idle_isr();
80004676:	fe f8 05 7a 	ld.w	r8,pc[1402]
8000467a:	70 0c       	ld.w	r12,r8[0x0]
8000467c:	f0 1f 01 57 	mcall	80004bd8 <phy_rx_func+0x9e4>
80004680:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == payload_ptr)
80004682:	e0 80 02 9d 	breq	80004bbc <phy_rx_func+0x9c8>
							{
								break;
							}				
						}
							RxMediaState = READINGMEDIA;
80004686:	30 29       	mov	r9,2
80004688:	fe f8 05 74 	ld.w	r8,pc[1396]
8000468c:	91 09       	st.w	r8[0x0],r9
8000468e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80004692:	8e 79       	ld.sh	r9,r7[0xe]
80004694:	30 38       	mov	r8,3
80004696:	f0 09 19 00 	cp.h	r9,r8
8000469a:	c0 51       	brne	800046a4 <phy_rx_func+0x4b0>
				
					case 1: //The next usual case.
							//In general case, add code to process single word Array descriptor.
							if (payload_rx_channel->word[3] == 0x0003)//Stream Terminator
							{
								Terminator_Flag = 1;
8000469c:	30 19       	mov	r9,1
8000469e:	fe f8 05 9e 	ld.w	r8,pc[1438]
800046a2:	b0 89       	st.b	r8[0x0],r9
							{
								//Terminator_Flag = 0;
							}
					
					
							RxMediaState = READINGMEDIA;
800046a4:	30 29       	mov	r9,2
800046a6:	fe f8 05 56 	ld.w	r8,pc[1366]
800046aa:	91 09       	st.w	r8[0x0],r9
800046ac:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
				break;
				}
		
				//Code gets here on Middle or last Fragment. No Array descriptor.
				if (RxBytesWaiting < 2) break;//This shouldn't happen, but must check.
800046b0:	fe f8 05 54 	ld.w	r8,pc[1364]
800046b4:	70 08       	ld.w	r8,r8[0x0]
800046b6:	58 18       	cp.w	r8,1
800046b8:	e0 88 02 82 	brls	80004bbc <phy_rx_func+0x9c8>
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->dword[1] & 0x0000FFFF;
800046bc:	fe f8 05 7c 	ld.w	r8,pc[1404]
800046c0:	70 0a       	ld.w	r10,r8[0x0]
800046c2:	fe f9 05 32 	ld.w	r9,pc[1330]
800046c6:	72 09       	ld.w	r9,r9[0x0]
800046c8:	6e 3b       	ld.w	r11,r7[0xc]
800046ca:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
800046ce:	70 09       	ld.w	r9,r8[0x0]
800046d0:	2f f9       	sub	r9,-1
800046d2:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800046d4:	e0 49 00 ff 	cp.w	r9,255
800046d8:	e0 88 00 11 	brls	800046fa <phy_rx_func+0x506>
				{
					RxMedia_IsFillingNext16 = 0;
800046dc:	30 09       	mov	r9,0
800046de:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);
800046e0:	fe f7 05 14 	ld.w	r7,pc[1300]
800046e4:	6e 0c       	ld.w	r12,r7[0x0]
800046e6:	f0 1f 01 4d 	mcall	80004c18 <phy_rx_func+0xa24>
								payload_ptr = get_payload_idle_isr();
800046ea:	fe f8 05 06 	ld.w	r8,pc[1286]
800046ee:	70 0c       	ld.w	r12,r8[0x0]
800046f0:	f0 1f 01 3a 	mcall	80004bd8 <phy_rx_func+0x9e4>
800046f4:	8f 0c       	st.w	r7[0x0],r12
													if(NULL == payload_ptr)
800046f6:	e0 80 02 63 	breq	80004bbc <phy_rx_func+0x9c8>
													{
														break;
													}
				}
				if ((RxBytesWaiting -= 2) <= 0) break;  //This shouldn't happen, but must check;
800046fa:	fe f9 05 0a 	ld.w	r9,pc[1290]
800046fe:	72 08       	ld.w	r8,r9[0x0]
80004700:	20 28       	sub	r8,2
80004702:	93 08       	st.w	r9[0x0],r8
80004704:	e0 80 02 5c 	breq	80004bbc <phy_rx_func+0x9c8>
				RxMediaState = READINGMEDIA;
80004708:	30 29       	mov	r9,2
8000470a:	fe f8 04 f2 	ld.w	r8,pc[1266]
8000470e:	91 09       	st.w	r8[0x0],r9
80004710:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
		case READINGMEDIA:
				
			/***PCM-media-data ****/
			{
				
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[0];
80004714:	fe f8 05 24 	ld.w	r8,pc[1316]
80004718:	70 0a       	ld.w	r10,r8[0x0]
8000471a:	fe f9 04 da 	ld.w	r9,pc[1242]
8000471e:	72 09       	ld.w	r9,r9[0x0]
80004720:	8e 4b       	ld.sh	r11,r7[0x8]
80004722:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;	
80004726:	70 09       	ld.w	r9,r8[0x0]
80004728:	2f f9       	sub	r9,-1
8000472a:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
8000472c:	e0 49 00 ff 	cp.w	r9,255
80004730:	e0 88 00 16 	brls	8000475c <phy_rx_func+0x568>
					{
							RxMedia_IsFillingNext16 = 0;
80004734:	30 09       	mov	r9,0
80004736:	91 09       	st.w	r8[0x0],r9
							payload_rx(payload_ptr);
80004738:	fe f6 04 bc 	ld.w	r6,pc[1212]
8000473c:	6c 0c       	ld.w	r12,r6[0x0]
8000473e:	f0 1f 01 37 	mcall	80004c18 <phy_rx_func+0xa24>
							payload_ptr = get_payload_idle_isr();
80004742:	fe f8 04 ae 	ld.w	r8,pc[1198]
80004746:	70 0c       	ld.w	r12,r8[0x0]
80004748:	f0 1f 01 24 	mcall	80004bd8 <phy_rx_func+0x9e4>
8000474c:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == payload_ptr)
8000474e:	c0 71       	brne	8000475c <phy_rx_func+0x568>
							{
								RxMediaState = WAITINGABAB;
80004750:	30 09       	mov	r9,0
80004752:	fe f8 04 aa 	ld.w	r8,pc[1194]
80004756:	91 09       	st.w	r8[0x0],r9
80004758:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
					}
				if ((RxBytesWaiting -= 2) <= 0)
8000475c:	fe f9 04 a8 	ld.w	r9,pc[1192]
80004760:	72 08       	ld.w	r8,r9[0x0]
80004762:	20 28       	sub	r8,2
80004764:	93 08       	st.w	r9[0x0],r8
80004766:	c0 71       	brne	80004774 <phy_rx_func+0x580>
				{
					RxMediaState = WAITINGABAB;
80004768:	30 09       	mov	r9,0
8000476a:	fe f8 04 92 	ld.w	r8,pc[1170]
8000476e:	91 09       	st.w	r8[0x0],r9
80004770:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[1];
80004774:	fe f8 04 c4 	ld.w	r8,pc[1220]
80004778:	70 0a       	ld.w	r10,r8[0x0]
8000477a:	fe f9 04 7a 	ld.w	r9,pc[1146]
8000477e:	72 09       	ld.w	r9,r9[0x0]
80004780:	8e 5b       	ld.sh	r11,r7[0xa]
80004782:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80004786:	70 09       	ld.w	r9,r8[0x0]
80004788:	2f f9       	sub	r9,-1
8000478a:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
8000478c:	e0 49 00 ff 	cp.w	r9,255
80004790:	e0 88 00 16 	brls	800047bc <phy_rx_func+0x5c8>
						{
							RxMedia_IsFillingNext16 = 0;
80004794:	30 09       	mov	r9,0
80004796:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);
80004798:	fe f6 04 5c 	ld.w	r6,pc[1116]
8000479c:	6c 0c       	ld.w	r12,r6[0x0]
8000479e:	f0 1f 01 1f 	mcall	80004c18 <phy_rx_func+0xa24>
								payload_ptr = get_payload_idle_isr();
800047a2:	fe f8 04 4e 	ld.w	r8,pc[1102]
800047a6:	70 0c       	ld.w	r12,r8[0x0]
800047a8:	f0 1f 01 0c 	mcall	80004bd8 <phy_rx_func+0x9e4>
800047ac:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == payload_ptr)
800047ae:	c0 71       	brne	800047bc <phy_rx_func+0x5c8>
								{
									RxMediaState = WAITINGABAB;
800047b0:	30 09       	mov	r9,0
800047b2:	fe f8 04 4a 	ld.w	r8,pc[1098]
800047b6:	91 09       	st.w	r8[0x0],r9
800047b8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
						}
				if ((RxBytesWaiting -= 2) <= 0){
800047bc:	fe f9 04 48 	ld.w	r9,pc[1096]
800047c0:	72 08       	ld.w	r8,r9[0x0]
800047c2:	20 28       	sub	r8,2
800047c4:	93 08       	st.w	r9[0x0],r8
800047c6:	c0 71       	brne	800047d4 <phy_rx_func+0x5e0>
					RxMediaState = WAITINGABAB;
800047c8:	30 09       	mov	r9,0
800047ca:	fe f8 04 32 	ld.w	r8,pc[1074]
800047ce:	91 09       	st.w	r8[0x0],r9
800047d0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}

				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[2];
800047d4:	fe f8 04 64 	ld.w	r8,pc[1124]
800047d8:	70 0a       	ld.w	r10,r8[0x0]
800047da:	fe f9 04 1a 	ld.w	r9,pc[1050]
800047de:	72 09       	ld.w	r9,r9[0x0]
800047e0:	8e 6b       	ld.sh	r11,r7[0xc]
800047e2:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
800047e6:	70 09       	ld.w	r9,r8[0x0]
800047e8:	2f f9       	sub	r9,-1
800047ea:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800047ec:	e0 49 00 ff 	cp.w	r9,255
800047f0:	e0 88 00 16 	brls	8000481c <phy_rx_func+0x628>
						{
							RxMedia_IsFillingNext16 = 0;
800047f4:	30 09       	mov	r9,0
800047f6:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);
800047f8:	fe f6 03 fc 	ld.w	r6,pc[1020]
800047fc:	6c 0c       	ld.w	r12,r6[0x0]
800047fe:	f0 1f 01 07 	mcall	80004c18 <phy_rx_func+0xa24>
									payload_ptr = get_payload_idle_isr();
80004802:	fe f8 03 ee 	ld.w	r8,pc[1006]
80004806:	70 0c       	ld.w	r12,r8[0x0]
80004808:	f0 1f 00 f4 	mcall	80004bd8 <phy_rx_func+0x9e4>
8000480c:	8d 0c       	st.w	r6[0x0],r12
									if(NULL == payload_ptr)
8000480e:	c0 71       	brne	8000481c <phy_rx_func+0x628>
									{
										RxMediaState = WAITINGABAB;
80004810:	30 09       	mov	r9,0
80004812:	fe f8 03 ea 	ld.w	r8,pc[1002]
80004816:	91 09       	st.w	r8[0x0],r9
80004818:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
						}
				if ((RxBytesWaiting -= 2) <= 0){
8000481c:	fe f9 03 e8 	ld.w	r9,pc[1000]
80004820:	72 08       	ld.w	r8,r9[0x0]
80004822:	20 28       	sub	r8,2
80004824:	93 08       	st.w	r9[0x0],r8
80004826:	c0 71       	brne	80004834 <phy_rx_func+0x640>
					RxMediaState = WAITINGABAB;
80004828:	30 09       	mov	r9,0
8000482a:	fe f8 03 d2 	ld.w	r8,pc[978]
8000482e:	91 09       	st.w	r8[0x0],r9
80004830:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
80004834:	fe f8 04 04 	ld.w	r8,pc[1028]
80004838:	70 0a       	ld.w	r10,r8[0x0]
8000483a:	fe f9 03 ba 	ld.w	r9,pc[954]
8000483e:	72 09       	ld.w	r9,r9[0x0]
80004840:	8e 7b       	ld.sh	r11,r7[0xe]
80004842:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80004846:	70 09       	ld.w	r9,r8[0x0]
80004848:	2f f9       	sub	r9,-1
8000484a:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
8000484c:	e0 49 00 ff 	cp.w	r9,255
80004850:	e0 88 00 16 	brls	8000487c <phy_rx_func+0x688>
						{
							RxMedia_IsFillingNext16 = 0;
80004854:	30 09       	mov	r9,0
80004856:	91 09       	st.w	r8[0x0],r9
							payload_rx(payload_ptr);
80004858:	fe f7 03 9c 	ld.w	r7,pc[924]
8000485c:	6e 0c       	ld.w	r12,r7[0x0]
8000485e:	f0 1f 00 ef 	mcall	80004c18 <phy_rx_func+0xa24>
							payload_ptr = get_payload_idle_isr();
80004862:	fe f8 03 8e 	ld.w	r8,pc[910]
80004866:	70 0c       	ld.w	r12,r8[0x0]
80004868:	f0 1f 00 dc 	mcall	80004bd8 <phy_rx_func+0x9e4>
8000486c:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == payload_ptr)
8000486e:	c0 71       	brne	8000487c <phy_rx_func+0x688>
							{
								RxMediaState = WAITINGABAB;
80004870:	30 09       	mov	r9,0
80004872:	fe f8 03 8a 	ld.w	r8,pc[906]
80004876:	91 09       	st.w	r8[0x0],r9
80004878:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
				if ((RxBytesWaiting -= 2) <= 0){
8000487c:	fe f9 03 88 	ld.w	r9,pc[904]
80004880:	72 08       	ld.w	r8,r9[0x0]
80004882:	20 28       	sub	r8,2
80004884:	93 08       	st.w	r9[0x0],r8
80004886:	e0 81 01 9b 	brne	80004bbc <phy_rx_func+0x9c8>
					RxMediaState = WAITINGABAB;
8000488a:	30 09       	mov	r9,0
8000488c:	fe f8 03 70 	ld.w	r8,pc[880]
80004890:	91 09       	st.w	r8[0x0],r9
80004892:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			}
			break; //End of READINGMEDIA.

		case READING_AMBE_MEDIA:
			
					if ((Item_ID == Vocoder_Bit_Stream_Parameter))//PAYLOAD_DATA_ENH (0x0c))
80004896:	fe f8 03 76 	ld.w	r8,pc[886]
8000489a:	11 89       	ld.ub	r9,r8[0x0]
8000489c:	31 28       	mov	r8,18
8000489e:	f0 09 18 00 	cp.b	r9,r8
800048a2:	e0 81 01 32 	brne	80004b06 <phy_rx_func+0x912>
					{
						Item_ID = payload_rx_channel->byte[1];
800048a6:	ef 39 00 09 	ld.ub	r9,r7[9]
800048aa:	fe f8 03 62 	ld.w	r8,pc[866]
800048ae:	b0 89       	st.b	r8[0x0],r9
						if (Item_ID == Post_Voice_Encoder_Data)
800048b0:	11 89       	ld.ub	r9,r8[0x0]
800048b2:	3f 28       	mov	r8,-14
800048b4:	f0 09 18 00 	cp.b	r9,r8
800048b8:	e0 81 01 22 	brne	80004afc <phy_rx_func+0x908>
						{
							
							RxBytesWaiting = ((payload_rx_channel->dword[0] & 0x7F000000) >>24);//Test calculations are correct; 8
800048bc:	6e 29       	ld.w	r9,r7[0x8]
800048be:	f3 d9 c3 07 	bfextu	r9,r9,0x18,0x7
800048c2:	fe f8 03 42 	ld.w	r8,pc[834]
800048c6:	91 09       	st.w	r8[0x0],r9
							
							//For looping back to Radio
							AMBEBurst_rawdata[0] = payload_rx_channel->word[1];
800048c8:	8e 59       	ld.sh	r9,r7[0xa]
800048ca:	fe f8 03 76 	ld.w	r8,pc[886]
800048ce:	b0 09       	st.h	r8[0x0],r9
							AMBEBurst_rawdata[1] = payload_rx_channel->word[2];
800048d0:	8e 69       	ld.sh	r9,r7[0xc]
800048d2:	b0 19       	st.h	r8[0x2],r9
							AMBEBurst_rawdata[2] = payload_rx_channel->word[3];
800048d4:	8e 79       	ld.sh	r9,r7[0xe]
800048d6:	b0 29       	st.h	r8[0x4],r9
							
							//To be tested. Also locally stored RAW-AMBER-DATA
							
							//bytes
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//1
800048d8:	fe f8 03 3c 	ld.w	r8,pc[828]
800048dc:	fe f9 03 1c 	ld.w	r9,pc[796]
800048e0:	72 0a       	ld.w	r10,r9[0x0]
800048e2:	70 09       	ld.w	r9,r8[0x0]
800048e4:	ef 3b 00 0a 	ld.ub	r11,r7[10]
800048e8:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
800048ec:	70 09       	ld.w	r9,r8[0x0]
800048ee:	2f f9       	sub	r9,-1
800048f0:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800048f2:	e0 49 01 ff 	cp.w	r9,511
800048f6:	e0 88 00 16 	brls	80004922 <phy_rx_func+0x72e>
							{
								RxAMBE_IsFillingNext8 = 0;
800048fa:	30 09       	mov	r9,0
800048fc:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800048fe:	fe f6 02 fa 	ld.w	r6,pc[762]
80004902:	6c 0c       	ld.w	r12,r6[0x0]
80004904:	f0 1f 00 c5 	mcall	80004c18 <phy_rx_func+0xa24>
								AMBE_payload_ptr = get_payload_idle_isr();
80004908:	fe f8 02 e8 	ld.w	r8,pc[744]
8000490c:	70 0c       	ld.w	r12,r8[0x0]
8000490e:	f0 1f 00 b3 	mcall	80004bd8 <phy_rx_func+0x9e4>
80004912:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80004914:	c0 71       	brne	80004922 <phy_rx_func+0x72e>
								{
									RxMediaState = WAITINGABAB;
80004916:	30 09       	mov	r9,0
80004918:	fe f8 02 e4 	ld.w	r8,pc[740]
8000491c:	91 09       	st.w	r8[0x0],r9
8000491e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80004922:	fe f9 02 e2 	ld.w	r9,pc[738]
80004926:	72 08       	ld.w	r8,r9[0x0]
80004928:	20 18       	sub	r8,1
8000492a:	93 08       	st.w	r9[0x0],r8
8000492c:	c0 71       	brne	8000493a <phy_rx_func+0x746>
								RxMediaState = WAITINGABAB;
8000492e:	30 09       	mov	r9,0
80004930:	fe f8 02 cc 	ld.w	r8,pc[716]
80004934:	91 09       	st.w	r8[0x0],r9
80004936:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}			
							
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//2
8000493a:	fe f8 02 da 	ld.w	r8,pc[730]
8000493e:	fe f9 02 ba 	ld.w	r9,pc[698]
80004942:	72 0a       	ld.w	r10,r9[0x0]
80004944:	70 09       	ld.w	r9,r8[0x0]
80004946:	ef 3b 00 0b 	ld.ub	r11,r7[11]
8000494a:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
8000494e:	70 09       	ld.w	r9,r8[0x0]
80004950:	2f f9       	sub	r9,-1
80004952:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80004954:	e0 49 01 ff 	cp.w	r9,511
80004958:	e0 88 00 16 	brls	80004984 <phy_rx_func+0x790>
							{
								RxAMBE_IsFillingNext8 = 0;
8000495c:	30 09       	mov	r9,0
8000495e:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80004960:	fe f6 02 98 	ld.w	r6,pc[664]
80004964:	6c 0c       	ld.w	r12,r6[0x0]
80004966:	f0 1f 00 ad 	mcall	80004c18 <phy_rx_func+0xa24>
								AMBE_payload_ptr = get_payload_idle_isr();
8000496a:	fe f8 02 86 	ld.w	r8,pc[646]
8000496e:	70 0c       	ld.w	r12,r8[0x0]
80004970:	f0 1f 00 9a 	mcall	80004bd8 <phy_rx_func+0x9e4>
80004974:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80004976:	c0 71       	brne	80004984 <phy_rx_func+0x790>
								{
									RxMediaState = WAITINGABAB;
80004978:	30 09       	mov	r9,0
8000497a:	fe f8 02 82 	ld.w	r8,pc[642]
8000497e:	91 09       	st.w	r8[0x0],r9
80004980:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80004984:	fe f9 02 80 	ld.w	r9,pc[640]
80004988:	72 08       	ld.w	r8,r9[0x0]
8000498a:	20 18       	sub	r8,1
8000498c:	93 08       	st.w	r9[0x0],r8
8000498e:	c0 71       	brne	8000499c <phy_rx_func+0x7a8>
								RxMediaState = WAITINGABAB;
80004990:	30 09       	mov	r9,0
80004992:	fe f8 02 6a 	ld.w	r8,pc[618]
80004996:	91 09       	st.w	r8[0x0],r9
80004998:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}		
						
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//3
8000499c:	fe f8 02 78 	ld.w	r8,pc[632]
800049a0:	fe f9 02 58 	ld.w	r9,pc[600]
800049a4:	72 0a       	ld.w	r10,r9[0x0]
800049a6:	70 09       	ld.w	r9,r8[0x0]
800049a8:	ef 3b 00 0c 	ld.ub	r11,r7[12]
800049ac:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
800049b0:	70 09       	ld.w	r9,r8[0x0]
800049b2:	2f f9       	sub	r9,-1
800049b4:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800049b6:	e0 49 01 ff 	cp.w	r9,511
800049ba:	e0 88 00 16 	brls	800049e6 <phy_rx_func+0x7f2>
							{
								RxAMBE_IsFillingNext8 = 0;
800049be:	30 09       	mov	r9,0
800049c0:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800049c2:	fe f6 02 36 	ld.w	r6,pc[566]
800049c6:	6c 0c       	ld.w	r12,r6[0x0]
800049c8:	f0 1f 00 94 	mcall	80004c18 <phy_rx_func+0xa24>
								AMBE_payload_ptr = get_payload_idle_isr();
800049cc:	fe f8 02 24 	ld.w	r8,pc[548]
800049d0:	70 0c       	ld.w	r12,r8[0x0]
800049d2:	f0 1f 00 82 	mcall	80004bd8 <phy_rx_func+0x9e4>
800049d6:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
800049d8:	c0 71       	brne	800049e6 <phy_rx_func+0x7f2>
								{
									RxMediaState = WAITINGABAB;
800049da:	30 09       	mov	r9,0
800049dc:	fe f8 02 20 	ld.w	r8,pc[544]
800049e0:	91 09       	st.w	r8[0x0],r9
800049e2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800049e6:	fe f9 02 1e 	ld.w	r9,pc[542]
800049ea:	72 08       	ld.w	r8,r9[0x0]
800049ec:	20 18       	sub	r8,1
800049ee:	93 08       	st.w	r9[0x0],r8
800049f0:	c0 71       	brne	800049fe <phy_rx_func+0x80a>
								RxMediaState = WAITINGABAB;
800049f2:	30 09       	mov	r9,0
800049f4:	fe f8 02 08 	ld.w	r8,pc[520]
800049f8:	91 09       	st.w	r8[0x0],r9
800049fa:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[5];//4
800049fe:	fe f8 02 16 	ld.w	r8,pc[534]
80004a02:	4f e9       	lddpc	r9,80004bf8 <phy_rx_func+0xa04>
80004a04:	72 0a       	ld.w	r10,r9[0x0]
80004a06:	70 09       	ld.w	r9,r8[0x0]
80004a08:	ef 3b 00 0d 	ld.ub	r11,r7[13]
80004a0c:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80004a10:	70 09       	ld.w	r9,r8[0x0]
80004a12:	2f f9       	sub	r9,-1
80004a14:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80004a16:	e0 49 01 ff 	cp.w	r9,511
80004a1a:	e0 88 00 13 	brls	80004a40 <phy_rx_func+0x84c>
							{
								RxAMBE_IsFillingNext8 = 0;
80004a1e:	30 09       	mov	r9,0
80004a20:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80004a22:	4f 66       	lddpc	r6,80004bf8 <phy_rx_func+0xa04>
80004a24:	6c 0c       	ld.w	r12,r6[0x0]
80004a26:	f0 1f 00 7d 	mcall	80004c18 <phy_rx_func+0xa24>
								AMBE_payload_ptr = get_payload_idle_isr();
80004a2a:	4f 28       	lddpc	r8,80004bf0 <phy_rx_func+0x9fc>
80004a2c:	70 0c       	ld.w	r12,r8[0x0]
80004a2e:	f0 1f 00 6b 	mcall	80004bd8 <phy_rx_func+0x9e4>
80004a32:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80004a34:	c0 61       	brne	80004a40 <phy_rx_func+0x84c>
								{
									RxMediaState = WAITINGABAB;
80004a36:	30 09       	mov	r9,0
80004a38:	4f 18       	lddpc	r8,80004bfc <phy_rx_func+0xa08>
80004a3a:	91 09       	st.w	r8[0x0],r9
80004a3c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80004a40:	4f 19       	lddpc	r9,80004c04 <phy_rx_func+0xa10>
80004a42:	72 08       	ld.w	r8,r9[0x0]
80004a44:	20 18       	sub	r8,1
80004a46:	93 08       	st.w	r9[0x0],r8
80004a48:	c0 61       	brne	80004a54 <phy_rx_func+0x860>
								RxMediaState = WAITINGABAB;
80004a4a:	30 09       	mov	r9,0
80004a4c:	4e c8       	lddpc	r8,80004bfc <phy_rx_func+0xa08>
80004a4e:	91 09       	st.w	r8[0x0],r9
80004a50:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//5
80004a54:	4f 08       	lddpc	r8,80004c14 <phy_rx_func+0xa20>
80004a56:	4e 99       	lddpc	r9,80004bf8 <phy_rx_func+0xa04>
80004a58:	72 0a       	ld.w	r10,r9[0x0]
80004a5a:	70 09       	ld.w	r9,r8[0x0]
80004a5c:	ef 3b 00 0e 	ld.ub	r11,r7[14]
80004a60:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80004a64:	70 09       	ld.w	r9,r8[0x0]
80004a66:	2f f9       	sub	r9,-1
80004a68:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80004a6a:	e0 49 01 ff 	cp.w	r9,511
80004a6e:	e0 88 00 13 	brls	80004a94 <phy_rx_func+0x8a0>
							{
								RxAMBE_IsFillingNext8 = 0;
80004a72:	30 09       	mov	r9,0
80004a74:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80004a76:	4e 16       	lddpc	r6,80004bf8 <phy_rx_func+0xa04>
80004a78:	6c 0c       	ld.w	r12,r6[0x0]
80004a7a:	f0 1f 00 68 	mcall	80004c18 <phy_rx_func+0xa24>
								AMBE_payload_ptr = get_payload_idle_isr();
80004a7e:	4d d8       	lddpc	r8,80004bf0 <phy_rx_func+0x9fc>
80004a80:	70 0c       	ld.w	r12,r8[0x0]
80004a82:	f0 1f 00 56 	mcall	80004bd8 <phy_rx_func+0x9e4>
80004a86:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80004a88:	c0 61       	brne	80004a94 <phy_rx_func+0x8a0>
								{
									RxMediaState = WAITINGABAB;
80004a8a:	30 09       	mov	r9,0
80004a8c:	4d c8       	lddpc	r8,80004bfc <phy_rx_func+0xa08>
80004a8e:	91 09       	st.w	r8[0x0],r9
80004a90:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80004a94:	4d c9       	lddpc	r9,80004c04 <phy_rx_func+0xa10>
80004a96:	72 08       	ld.w	r8,r9[0x0]
80004a98:	20 18       	sub	r8,1
80004a9a:	93 08       	st.w	r9[0x0],r8
80004a9c:	c0 61       	brne	80004aa8 <phy_rx_func+0x8b4>
								RxMediaState = WAITINGABAB;
80004a9e:	30 09       	mov	r9,0
80004aa0:	4d 78       	lddpc	r8,80004bfc <phy_rx_func+0xa08>
80004aa2:	91 09       	st.w	r8[0x0],r9
80004aa4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//6
80004aa8:	4d b8       	lddpc	r8,80004c14 <phy_rx_func+0xa20>
80004aaa:	4d 49       	lddpc	r9,80004bf8 <phy_rx_func+0xa04>
80004aac:	72 0a       	ld.w	r10,r9[0x0]
80004aae:	70 09       	ld.w	r9,r8[0x0]
80004ab0:	ef 3b 00 0f 	ld.ub	r11,r7[15]
80004ab4:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80004ab8:	70 09       	ld.w	r9,r8[0x0]
80004aba:	2f f9       	sub	r9,-1
80004abc:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80004abe:	e0 49 01 ff 	cp.w	r9,511
80004ac2:	e0 88 00 13 	brls	80004ae8 <phy_rx_func+0x8f4>
							{
								RxAMBE_IsFillingNext8 = 0;
80004ac6:	30 09       	mov	r9,0
80004ac8:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80004aca:	4c c7       	lddpc	r7,80004bf8 <phy_rx_func+0xa04>
80004acc:	6e 0c       	ld.w	r12,r7[0x0]
80004ace:	f0 1f 00 53 	mcall	80004c18 <phy_rx_func+0xa24>
								AMBE_payload_ptr = get_payload_idle_isr();
80004ad2:	4c 88       	lddpc	r8,80004bf0 <phy_rx_func+0x9fc>
80004ad4:	70 0c       	ld.w	r12,r8[0x0]
80004ad6:	f0 1f 00 41 	mcall	80004bd8 <phy_rx_func+0x9e4>
80004ada:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == AMBE_payload_ptr)
80004adc:	c0 61       	brne	80004ae8 <phy_rx_func+0x8f4>
								{
									RxMediaState = WAITINGABAB;
80004ade:	30 09       	mov	r9,0
80004ae0:	4c 78       	lddpc	r8,80004bfc <phy_rx_func+0xa08>
80004ae2:	91 09       	st.w	r8[0x0],r9
80004ae4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80004ae8:	4c 79       	lddpc	r9,80004c04 <phy_rx_func+0xa10>
80004aea:	72 08       	ld.w	r8,r9[0x0]
80004aec:	20 18       	sub	r8,1
80004aee:	93 08       	st.w	r9[0x0],r8
80004af0:	c6 61       	brne	80004bbc <phy_rx_func+0x9c8>
								RxMediaState = WAITINGABAB;
80004af2:	30 09       	mov	r9,0
80004af4:	4c 28       	lddpc	r8,80004bfc <phy_rx_func+0xa08>
80004af6:	91 09       	st.w	r8[0x0],r9
80004af8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							//}
							
						}
						else//error
						{
							RxMediaState = WAITINGABAB;
80004afc:	30 09       	mov	r9,0
80004afe:	4c 08       	lddpc	r8,80004bfc <phy_rx_func+0xa08>
80004b00:	91 09       	st.w	r8[0x0],r9
80004b02:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
					}
					else if (Item_ID == Post_Voice_Encoder_Data)//(bit48~Pad-bits)
80004b06:	4c 28       	lddpc	r8,80004c0c <phy_rx_func+0xa18>
80004b08:	11 89       	ld.ub	r9,r8[0x0]
80004b0a:	3f 28       	mov	r8,-14
80004b0c:	f0 09 18 00 	cp.b	r9,r8
80004b10:	c3 81       	brne	80004b80 <phy_rx_func+0x98c>
					{
						
						
						AMBEBurst_rawdata[3] = payload_rx_channel->word[0];//(bit48~Pad-bits)
80004b12:	8e 49       	ld.sh	r9,r7[0x8]
80004b14:	4c b8       	lddpc	r8,80004c40 <phy_rx_func+0xa4c>
80004b16:	b0 39       	st.h	r8[0x6],r9
						//AMBE_Per_Burst_Flag = 1;
						
						//MOTO.bitpad-bits
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//7
80004b18:	4b f8       	lddpc	r8,80004c14 <phy_rx_func+0xa20>
80004b1a:	4b 89       	lddpc	r9,80004bf8 <phy_rx_func+0xa04>
80004b1c:	72 0a       	ld.w	r10,r9[0x0]
80004b1e:	70 09       	ld.w	r9,r8[0x0]
80004b20:	ef 3b 00 08 	ld.ub	r11,r7[8]
80004b24:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80004b28:	70 09       	ld.w	r9,r8[0x0]
80004b2a:	2f f9       	sub	r9,-1
80004b2c:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80004b2e:	e0 49 01 ff 	cp.w	r9,511
80004b32:	e0 88 00 13 	brls	80004b58 <phy_rx_func+0x964>
						{
							RxAMBE_IsFillingNext8 = 0;
80004b36:	30 09       	mov	r9,0
80004b38:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80004b3a:	4b 07       	lddpc	r7,80004bf8 <phy_rx_func+0xa04>
80004b3c:	6e 0c       	ld.w	r12,r7[0x0]
80004b3e:	f0 1f 00 37 	mcall	80004c18 <phy_rx_func+0xa24>
							AMBE_payload_ptr = get_payload_idle_isr();
80004b42:	4a c8       	lddpc	r8,80004bf0 <phy_rx_func+0x9fc>
80004b44:	70 0c       	ld.w	r12,r8[0x0]
80004b46:	f0 1f 00 25 	mcall	80004bd8 <phy_rx_func+0x9e4>
80004b4a:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
80004b4c:	c0 61       	brne	80004b58 <phy_rx_func+0x964>
							{
								RxMediaState = WAITINGABAB;
80004b4e:	30 09       	mov	r9,0
80004b50:	4a b8       	lddpc	r8,80004bfc <phy_rx_func+0xa08>
80004b52:	91 09       	st.w	r8[0x0],r9
80004b54:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80004b58:	4a b9       	lddpc	r9,80004c04 <phy_rx_func+0xa10>
80004b5a:	72 08       	ld.w	r8,r9[0x0]
80004b5c:	20 18       	sub	r8,1
80004b5e:	93 08       	st.w	r9[0x0],r8
80004b60:	c0 61       	brne	80004b6c <phy_rx_func+0x978>
							RxMediaState = WAITINGABAB;
80004b62:	30 09       	mov	r9,0
80004b64:	4a 68       	lddpc	r8,80004bfc <phy_rx_func+0xa08>
80004b66:	91 09       	st.w	r8[0x0],r9
80004b68:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
						if ((RxBytesWaiting -= 1) <= 0){//AMBE Vocoder Bits Stream(bit59~63),
80004b6c:	20 18       	sub	r8,1
80004b6e:	4a 69       	lddpc	r9,80004c04 <phy_rx_func+0xa10>
80004b70:	93 08       	st.w	r9[0x0],r8
80004b72:	58 08       	cp.w	r8,0
80004b74:	c2 41       	brne	80004bbc <phy_rx_func+0x9c8>
							RxMediaState = WAITINGABAB;
80004b76:	30 09       	mov	r9,0
80004b78:	4a 18       	lddpc	r8,80004bfc <phy_rx_func+0xa08>
80004b7a:	91 09       	st.w	r8[0x0],r9
80004b7c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						*******************/
						
								
					}
					
					else if ((Item_ID == 0x04)  ||  (Item_ID == 0x03))//Unknown type data directly back hair
80004b80:	4a 38       	lddpc	r8,80004c0c <phy_rx_func+0xa18>
80004b82:	11 89       	ld.ub	r9,r8[0x0]
80004b84:	30 48       	mov	r8,4
80004b86:	f0 09 18 00 	cp.b	r9,r8
80004b8a:	c0 70       	breq	80004b98 <phy_rx_func+0x9a4>
80004b8c:	4a 08       	lddpc	r8,80004c0c <phy_rx_func+0xa18>
80004b8e:	11 89       	ld.ub	r9,r8[0x0]
80004b90:	30 38       	mov	r8,3
80004b92:	f0 09 18 00 	cp.b	r9,r8
80004b96:	c1 01       	brne	80004bb6 <phy_rx_func+0x9c2>
					{
						AMBE_HT[0] = payload_rx_channel->dword[0];
80004b98:	6e 29       	ld.w	r9,r7[0x8]
80004b9a:	4a 38       	lddpc	r8,80004c24 <phy_rx_func+0xa30>
80004b9c:	91 09       	st.w	r8[0x0],r9
						AMBE_HT[1] = payload_rx_channel->dword[1];				
80004b9e:	6e 39       	ld.w	r9,r7[0xc]
80004ba0:	91 19       	st.w	r8[0x4],r9
						
						if ((RxBytesWaiting -= 8) <= 0)//Consider two cases 0xABCDC014 and 0xABCDC010
80004ba2:	49 99       	lddpc	r9,80004c04 <phy_rx_func+0xa10>
80004ba4:	72 08       	ld.w	r8,r9[0x0]
80004ba6:	20 88       	sub	r8,8
80004ba8:	93 08       	st.w	r9[0x0],r8
80004baa:	c0 91       	brne	80004bbc <phy_rx_func+0x9c8>
						{
					
							RxBytesWaiting = 0;
80004bac:	93 08       	st.w	r9[0x0],r8
							RxMediaState = WAITINGABAB;
80004bae:	49 49       	lddpc	r9,80004bfc <phy_rx_func+0xa08>
80004bb0:	93 08       	st.w	r9[0x0],r8
80004bb2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					//}
					
					else
					{
						
						RxMediaState  = WAITINGABAB;
80004bb6:	30 09       	mov	r9,0
80004bb8:	49 18       	lddpc	r8,80004bfc <phy_rx_func+0xa08>
80004bba:	91 09       	st.w	r8[0x0],r9
80004bbc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80004bc0:	00 00       	add	r0,r0
80004bc2:	0f cc       	ld.ub	r12,r7[0x4]
80004bc4:	00 00       	add	r0,r0
80004bc6:	0f e8       	ld.ub	r8,r7[0x6]
80004bc8:	00 00       	add	r0,r0
80004bca:	0f bc       	ld.ub	r12,r7[0x3]
80004bcc:	00 00       	add	r0,r0
80004bce:	0f a4       	ld.ub	r4,r7[0x2]
80004bd0:	00 00       	add	r0,r0
80004bd2:	0f 9a       	ld.ub	r10,r7[0x1]
80004bd4:	00 00       	add	r0,r0
80004bd6:	0f b8       	ld.ub	r8,r7[0x3]
80004bd8:	80 00       	ld.sh	r0,r0[0x0]
80004bda:	3a cc       	mov	r12,-84
80004bdc:	00 00       	add	r0,r0
80004bde:	0f ec       	ld.ub	r12,r7[0x6]
80004be0:	80 00       	ld.sh	r0,r0[0x0]
80004be2:	8b 38       	st.w	r5[0xc],r8
80004be4:	00 00       	add	r0,r0
80004be6:	0f c8       	ld.ub	r8,r7[0x4]
80004be8:	80 00       	ld.sh	r0,r0[0x0]
80004bea:	3a 18       	mov	r8,-95
80004bec:	00 00       	add	r0,r0
80004bee:	0f d0       	ld.ub	r0,r7[0x5]
80004bf0:	00 00       	add	r0,r0
80004bf2:	0f a8       	ld.ub	r8,r7[0x2]
80004bf4:	00 00       	add	r0,r0
80004bf6:	0f 84       	ld.ub	r4,r7[0x0]
80004bf8:	00 00       	add	r0,r0
80004bfa:	0f 7c       	ld.ub	r12,--r7
80004bfc:	00 00       	add	r0,r0
80004bfe:	0f dc       	ld.ub	r12,r7[0x5]
80004c00:	00 00       	add	r0,r0
80004c02:	0f 80       	ld.ub	r0,r7[0x0]
80004c04:	00 00       	add	r0,r0
80004c06:	0f 94       	ld.ub	r4,r7[0x1]
80004c08:	00 00       	add	r0,r0
80004c0a:	0a 44       	or	r4,r5
80004c0c:	00 00       	add	r0,r0
80004c0e:	0f 98       	ld.ub	r8,r7[0x1]
80004c10:	00 00       	add	r0,r0
80004c12:	0a 4c       	or	r12,r5
80004c14:	00 00       	add	r0,r0
80004c16:	0f 90       	ld.ub	r0,r7[0x1]
80004c18:	80 00       	ld.sh	r0,r0[0x0]
80004c1a:	41 94       	lddsp	r4,sp[0x64]
80004c1c:	00 00       	add	r0,r0
80004c1e:	13 cc       	ld.ub	r12,r9[0x4]
80004c20:	80 00       	ld.sh	r0,r0[0x0]
80004c22:	39 5c       	mov	r12,-107
80004c24:	00 00       	add	r0,r0
80004c26:	0f b0       	ld.ub	r0,r7[0x3]
80004c28:	80 01       	ld.sh	r1,r0[0x0]
80004c2a:	8a 5c       	ld.sh	r12,r5[0xa]
80004c2c:	80 00       	ld.sh	r0,r0[0x0]
80004c2e:	9c 30       	ld.sh	r0,lr[0x6]
80004c30:	80 01       	ld.sh	r1,r0[0x0]
80004c32:	8a 70       	ld.sh	r0,r5[0xe]
80004c34:	00 00       	add	r0,r0
80004c36:	0f 9c       	ld.ub	r12,r7[0x1]
80004c38:	00 00       	add	r0,r0
80004c3a:	0f d4       	ld.ub	r4,r7[0x5]
80004c3c:	00 00       	add	r0,r0
80004c3e:	0a 55       	eor	r5,r5
80004c40:	00 00       	add	r0,r0
80004c42:	12 d4       	st.w	--r9,r4

80004c44 <pdca_int_handler>:
    void (*phy_rx_exec)(void *)--callback function for receive SSC data 
Called By: interrupt
*/
__attribute__((__interrupt__))
static void pdca_int_handler(void)
{
80004c44:	d4 01       	pushm	lr
    
	//intStartCount = Get_system_register(AVR32_COUNT);
	
	/*Toggle Index*/
    BufferIndex ^= 0x01;
80004c46:	49 88       	lddpc	r8,80004ca4 <pdca_int_handler+0x60>
80004c48:	11 89       	ld.ub	r9,r8[0x0]
80004c4a:	ec 19 00 01 	eorl	r9,0x1
80004c4e:	b0 89       	st.b	r8[0x0],r9
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);
80004c50:	11 89       	ld.ub	r9,r8[0x0]
80004c52:	a5 69       	lsl	r9,0x4
80004c54:	2f c9       	sub	r9,-4
80004c56:	49 5a       	lddpc	r10,80004ca8 <pdca_int_handler+0x64>
80004c58:	14 09       	add	r9,r10
	
	/*Toggle Index*/
    BufferIndex ^= 0x01;
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
80004c5a:	fe 7a 00 40 	mov	r10,-65472
80004c5e:	95 39       	st.w	r10[0xc],r9
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80004c60:	30 39       	mov	r9,3
80004c62:	95 49       	st.w	r10[0x10],r9

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);
80004c64:	11 8a       	ld.ub	r10,r8[0x0]
80004c66:	a5 6a       	lsl	r10,0x4
80004c68:	2f ca       	sub	r10,-4
80004c6a:	49 18       	lddpc	r8,80004cac <pdca_int_handler+0x68>
80004c6c:	10 0a       	add	r10,r8
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
80004c6e:	fe 78 00 00 	mov	r8,-65536
80004c72:	91 3a       	st.w	r8[0xc],r10
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80004c74:	91 49       	st.w	r8[0x10],r9
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr;
80004c76:	70 b8       	ld.w	r8,r8[0x2c]
	
	/*receive SSC data*/
    if(phy_rx_exec != NULL)phy_rx_exec((void *)&RxBuffer[BufferIndex]);
80004c78:	48 e8       	lddpc	r8,80004cb0 <pdca_int_handler+0x6c>
80004c7a:	70 08       	ld.w	r8,r8[0x0]
80004c7c:	58 08       	cp.w	r8,0
80004c7e:	c0 70       	breq	80004c8c <pdca_int_handler+0x48>
80004c80:	48 99       	lddpc	r9,80004ca4 <pdca_int_handler+0x60>
80004c82:	13 89       	ld.ub	r9,r9[0x0]
80004c84:	a5 69       	lsl	r9,0x4
80004c86:	48 ac       	lddpc	r12,80004cac <pdca_int_handler+0x68>
80004c88:	12 0c       	add	r12,r9
80004c8a:	5d 18       	icall	r8

    /*transmit SSC data*/

	if(phy_tx_exec != NULL)phy_tx_exec((void *)&TxBuffer[BufferIndex]);//phy_tx_func, phy_rx_func
80004c8c:	48 a8       	lddpc	r8,80004cb4 <pdca_int_handler+0x70>
80004c8e:	70 08       	ld.w	r8,r8[0x0]
80004c90:	58 08       	cp.w	r8,0
80004c92:	c0 70       	breq	80004ca0 <pdca_int_handler+0x5c>
80004c94:	48 49       	lddpc	r9,80004ca4 <pdca_int_handler+0x60>
80004c96:	13 89       	ld.ub	r9,r9[0x0]
80004c98:	a5 69       	lsl	r9,0x4
80004c9a:	48 4c       	lddpc	r12,80004ca8 <pdca_int_handler+0x64>
80004c9c:	12 0c       	add	r12,r9
80004c9e:	5d 18       	icall	r8

	
	//intDuration = Get_system_register(AVR32_COUNT) - intStartCount;
	
	
}/*End of pdca_int_handler.*/
80004ca0:	d4 02       	popm	lr
80004ca2:	d6 03       	rete
80004ca4:	00 00       	add	r0,r0
80004ca6:	45 d4       	lddsp	r4,sp[0x174]
80004ca8:	00 00       	add	r0,r0
80004caa:	45 fc       	lddsp	r12,sp[0x17c]
80004cac:	00 00       	add	r0,r0
80004cae:	45 dc       	lddsp	r12,sp[0x174]
80004cb0:	00 00       	add	r0,r0
80004cb2:	0f f8       	ld.ub	r8,r7[0x7]
80004cb4:	00 00       	add	r0,r0
80004cb6:	0f fc       	ld.ub	r12,r7[0x7]

80004cb8 <local_start_SSC>:
void local_start_SSC(void)
{
    /*Assign GPIO to SSC.
    gpio_enable_module
    gpio_enable_module_pin*/
    AVR32_GPIO.port[1].pmr0c = 0x00000DC0;
80004cb8:	fe 78 10 00 	mov	r8,-61440
80004cbc:	e0 69 0d c0 	mov	r9,3520
80004cc0:	f1 49 01 18 	st.w	r8[280],r9
    AVR32_GPIO.port[1].pmr1c = 0x00000DC0;
80004cc4:	f1 49 01 28 	st.w	r8[296],r9
    AVR32_GPIO.port[1].gperc = 0x00000DC0;
80004cc8:	f1 49 01 08 	st.w	r8[264],r9

    /*Software reset SSC*/
    (&AVR32_SSC)->cr = AVR32_SSC_CR_SWRST_MASK;
80004ccc:	fe 78 34 00 	mov	r8,-52224
80004cd0:	e0 69 80 00 	mov	r9,32768
80004cd4:	91 09       	st.w	r8[0x0],r9
    (&AVR32_SSC)->cmr 
80004cd6:	30 09       	mov	r9,0
80004cd8:	91 19       	st.w	r8[0x4],r9
                     = AVR32_SSC_CMR_DIV_NOT_ACTIVE << AVR32_SSC_CMR_DIV_OFFSET;

    /*For Slave*/
    (&AVR32_SSC)->tcmr =
80004cda:	e0 69 04 21 	mov	r9,1057
80004cde:	ea 19 3f 20 	orh	r9,0x3f20
80004ce2:	91 69       	st.w	r8[0x18],r9
	    | 32 << AVR32_SSC_TCMR_STTDLY_OFFSET
	    | 63 << AVR32_SSC_TCMR_PERIOD_OFFSET;


    /*For Slave*/
    (&AVR32_SSC)->tfmr = 31 << AVR32_SSC_TFMR_DATLEN_OFFSET 
80004ce4:	e0 69 02 9f 	mov	r9,671
80004ce8:	ea 19 01 00 	orh	r9,0x100
80004cec:	91 79       	st.w	r8[0x1c],r9
	    | 0 << AVR32_SSC_TFMR_FSDEN_OFFSET
	    | 1 << AVR32_SSC_TFMR_FSEDGE_OFFSET;

	/*For Slave*/

	(&AVR32_SSC)->rcmr = AVR32_SSC_RCMR_CKS_RK_PIN << AVR32_SSC_RCMR_CKS_OFFSET
80004cee:	e0 6a 04 02 	mov	r10,1026
80004cf2:	ea 1a 3f 20 	orh	r10,0x3f20
80004cf6:	91 4a       	st.w	r8[0x10],r10
	    | 0 << AVR32_SSC_RCMR_STOP_OFFSET
	    | 32 << AVR32_SSC_RCMR_STTDLY_OFFSET
	    | 63 << AVR32_SSC_RCMR_PERIOD_OFFSET;

	/*For Slave*/
	(&AVR32_SSC)->rfmr = 31 << AVR32_SSC_RFMR_DATLEN_OFFSET
80004cf8:	91 59       	st.w	r8[0x14],r9
	    | 1 << AVR32_SSC_RFMR_MSBF_OFFSET
	    | 2 << AVR32_SSC_RFMR_DATNB_OFFSET
	    | 0 << AVR32_SSC_RFMR_FSLEN_OFFSET
	    | AVR32_SSC_RFMR_FSOS_INPUT_ONLY << AVR32_SSC_RFMR_FSOS_OFFSET
	    | 1 << AVR32_SSC_RFMR_FSEDGE_OFFSET;
}/*End of local_start_SSC.*/
80004cfa:	5e fc       	retal	r12

80004cfc <local_start_PDC>:
Function: local_start_PDC
Description: none
Called By: void ssc_init(void) -- ssc.c
*/
void local_start_PDC(void)
{
80004cfc:	d4 01       	pushm	lr
    /*Toggle Index*/	
    BufferIndex = 1;
80004cfe:	30 19       	mov	r9,1
80004d00:	49 78       	lddpc	r8,80004d5c <local_start_PDC+0x60>
80004d02:	b0 89       	st.b	r8[0x0],r9
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
80004d04:	fe 78 00 00 	mov	r8,-65536
80004d08:	30 7b       	mov	r11,7
80004d0a:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
80004d0c:	70 b9       	ld.w	r9,r8[0x2c]
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
80004d0e:	49 59       	lddpc	r9,80004d60 <local_start_PDC+0x64>
80004d10:	f2 ca ff fc 	sub	r10,r9,-4
    BufferIndex = 1;
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
80004d14:	91 0a       	st.w	r8[0x0],r10
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
80004d16:	30 3a       	mov	r10,3
80004d18:	91 2a       	st.w	r8[0x8],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
80004d1a:	30 1c       	mov	r12,1
80004d1c:	91 1c       	st.w	r8[0x4],r12
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
80004d1e:	2e c9       	sub	r9,-20
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
80004d20:	91 39       	st.w	r8[0xc],r9
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80004d22:	91 4a       	st.w	r8[0x10],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80004d24:	30 2c       	mov	r12,2
80004d26:	91 6c       	st.w	r8[0x18],r12

	TxBuffer[0].xnl_channel.dword = XNL_IDLE;
80004d28:	48 f9       	lddpc	r9,80004d64 <local_start_PDC+0x68>
80004d2a:	e0 68 5a 5a 	mov	r8,23130
80004d2e:	ea 18 ab cd 	orh	r8,0xabcd
80004d32:	93 18       	st.w	r9[0x4],r8
	TxBuffer[0].payload_channel.dword[0] = PAYLOADIDLE0;
80004d34:	93 28       	st.w	r9[0x8],r8
	TxBuffer[0].payload_channel.dword[1] = PAYLOADIDLE1;
80004d36:	30 0e       	mov	lr,0
80004d38:	93 3e       	st.w	r9[0xc],lr
	TxBuffer[1].xnl_channel.dword = XNL_IDLE;
80004d3a:	93 58       	st.w	r9[0x14],r8
	TxBuffer[1].payload_channel.dword[0] = PAYLOADIDLE0;
80004d3c:	93 68       	st.w	r9[0x18],r8
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;
80004d3e:	93 7e       	st.w	r9[0x1c],lr

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
80004d40:	fe 78 00 40 	mov	r8,-65472
80004d44:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
80004d46:	70 be       	ld.w	lr,r8[0x2c]
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
80004d48:	f2 ce ff fc 	sub	lr,r9,-4
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
80004d4c:	91 0e       	st.w	r8[0x0],lr
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
80004d4e:	91 2a       	st.w	r8[0x8],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
80004d50:	91 1b       	st.w	r8[0x4],r11
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
80004d52:	2e c9       	sub	r9,-20
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
80004d54:	91 39       	st.w	r8[0xc],r9
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80004d56:	91 4a       	st.w	r8[0x10],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80004d58:	91 6c       	st.w	r8[0x18],r12
}/*End of local_start_PDC.*/
80004d5a:	d8 02       	popm	pc
80004d5c:	00 00       	add	r0,r0
80004d5e:	45 d4       	lddsp	r4,sp[0x174]
80004d60:	00 00       	add	r0,r0
80004d62:	45 dc       	lddsp	r12,sp[0x174]
80004d64:	00 00       	add	r0,r0
80004d66:	45 fc       	lddsp	r12,sp[0x17c]

80004d68 <register_rx_tx_func>:
Description: register the rx function(callback function)
Called By: phy_init -- physical.c
*/
void register_rx_tx_func(void (*rx_exec)(void *),  void ( *tx_exec)(void *))
{
	 phy_rx_exec = rx_exec;
80004d68:	48 38       	lddpc	r8,80004d74 <register_rx_tx_func+0xc>
80004d6a:	91 0c       	st.w	r8[0x0],r12
	 phy_tx_exec = tx_exec;//phy_tx_func, phy_rx_func
80004d6c:	48 38       	lddpc	r8,80004d78 <register_rx_tx_func+0x10>
80004d6e:	91 0b       	st.w	r8[0x0],r11
	 
}/*End of register_tx_rx_func.*/
80004d70:	5e fc       	retal	r12
80004d72:	00 00       	add	r0,r0
80004d74:	00 00       	add	r0,r0
80004d76:	0f f8       	ld.ub	r8,r7[0x7]
80004d78:	00 00       	add	r0,r0
80004d7a:	0f fc       	ld.ub	r12,r7[0x7]

80004d7c <ssc_init>:
    local_start_SSC -- ssc.c
    local_start_PDC -- ssc.c
Called By: phy_init -- physical.c
*/
void ssc_init(void)
{		
80004d7c:	d4 01       	pushm	lr
    /*Set up PB03 to watch FS.*/
    AVR32_GPIO.port[1].oderc = 0x00000002;
80004d7e:	fe 78 10 00 	mov	r8,-61440
80004d82:	30 29       	mov	r9,2
80004d84:	f1 49 01 48 	st.w	r8[328],r9
    AVR32_GPIO.port[1].gpers = 0x00000002;
80004d88:	f1 49 01 04 	st.w	r8[260],r9

    /*Waits for radio to start making FSYNC.*/
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
80004d8c:	10 99       	mov	r9,r8
80004d8e:	f2 f8 01 60 	ld.w	r8,r9[352]
80004d92:	e2 18 00 02 	andl	r8,0x2,COH
80004d96:	cf c0       	breq	80004d8e <ssc_init+0x12>
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
80004d98:	fe 79 10 00 	mov	r9,-61440
80004d9c:	f2 f8 01 60 	ld.w	r8,r9[352]
80004da0:	e2 18 00 02 	andl	r8,0x2,COH
80004da4:	cf c1       	brne	80004d9c <ssc_init+0x20>
				
    INTC_register_interrupt (
80004da6:	30 3a       	mov	r10,3
80004da8:	36 0b       	mov	r11,96
80004daa:	48 bc       	lddpc	r12,80004dd4 <ssc_init+0x58>
80004dac:	f0 1f 00 0b 	mcall	80004dd8 <ssc_init+0x5c>
        , AVR32_PDCA_IRQ_0
        , AVR32_INTC_INT3
    );
				
    /*config the SSC*/
    local_start_SSC();
80004db0:	f0 1f 00 0b 	mcall	80004ddc <ssc_init+0x60>

    /*config the PDCA*/
    local_start_PDC();
80004db4:	f0 1f 00 0b 	mcall	80004de0 <ssc_init+0x64>
		
    /*Start the SSC Physical Layer.*/

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80004db8:	fe 79 00 00 	mov	r9,-65536
80004dbc:	30 18       	mov	r8,1
80004dbe:	93 58       	st.w	r9[0x14],r8
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80004dc0:	fe 7a 00 40 	mov	r10,-65472
80004dc4:	95 58       	st.w	r10[0x14],r8
    (&AVR32_SSC)->cr = AVR32_SSC_CR_RXEN_MASK | AVR32_SSC_CR_TXEN_MASK;
80004dc6:	e0 6b 01 01 	mov	r11,257
80004dca:	fe 7a 34 00 	mov	r10,-52224
80004dce:	95 0b       	st.w	r10[0x0],r11
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->ier = 
80004dd0:	93 88       	st.w	r9[0x20],r8
                                                            AVR32_PDCA_RCZ_MASK;
}/*End of ssc_init.*/
80004dd2:	d8 02       	popm	pc
80004dd4:	80 00       	ld.sh	r0,r0[0x0]
80004dd6:	4c 44       	lddpc	r4,80004ee4 <xcmp_enter_enhanced_OB_mode+0x4>
80004dd8:	80 00       	ld.sh	r0,r0[0x0]
80004dda:	59 c4       	cp.w	r4,28
80004ddc:	80 00       	ld.sh	r0,r0[0x0]
80004dde:	4c b8       	lddpc	r8,80004f08 <xcmp_DeviceInitializationStatus_request+0x4>
80004de0:	80 00       	ld.sh	r0,r0[0x0]
80004de2:	4c fc       	lddpc	r12,80004f1c <xcmp_DeviceInitializationStatus_request+0x18>

80004de4 <xcmp_register_app_list>:
Calls: 
Called By: app_init -- app.c
*/
void xcmp_register_app_list(void * list)
{
	app_list = (app_exec_t *)list;
80004de4:	48 28       	lddpc	r8,80004dec <xcmp_register_app_list+0x8>
80004de6:	91 0c       	st.w	r8[0x0],r12
}
80004de8:	5e fc       	retal	r12
80004dea:	00 00       	add	r0,r0
80004dec:	00 00       	add	r0,r0
80004dee:	46 1c       	lddsp	r12,sp[0x184]

80004df0 <xcmp_tx>:
Calls:   
	xnl_tx -- xnl.c
Called By: ...
*/
static void xcmp_tx( xcmp_fragment_t * xcmp, U8 payload_len)
{
80004df0:	eb cd 40 80 	pushm	r7,lr
80004df4:	fa cd 01 00 	sub	sp,sp,256
80004df8:	16 97       	mov	r7,r11
	Length :xnl length + checksum
	= checksum + xnl header + xcmp opcode + xcmp payload
	= 0x02 + 0x0C + 0x02 + xcmp payload
	= 0x10 + xcmp payload
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | ( 0x10 + payload_len);
80004dfa:	16 98       	mov	r8,r11
80004dfc:	2f 08       	sub	r8,-16
80004dfe:	af a8       	sbr	r8,0xe
80004e00:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE; 
80004e02:	3f f8       	mov	r8,-1
80004e04:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG;
80004e06:	30 b9       	mov	r9,11
80004e08:	ba 29       	st.h	sp[0x4],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;	
80004e0a:	ba 38       	st.h	sp[0x6],r8
	xnl_frame.xnl_header.destination = DEFAULT_VALUE;
80004e0c:	ba 48       	st.h	sp[0x8],r8
	xnl_frame.xnl_header.source = DEFAULT_VALUE;	
80004e0e:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80004e10:	ba 68       	st.h	sp[0xc],r8
	
	/*insert xcmp frame data*/
	memcpy(&xnl_frame.xnl_payload.xnl_content_data_msg, xcmp, payload_len + 2);
80004e12:	f6 ca ff fe 	sub	r10,r11,-2
80004e16:	18 9b       	mov	r11,r12
80004e18:	fa cc ff f0 	sub	r12,sp,-16
80004e1c:	f0 1f 00 05 	mcall	80004e30 <xcmp_tx+0x40>
	xnl_frame.xnl_header.payload_length = payload_len + 2;	
80004e20:	2f e7       	sub	r7,-2
80004e22:	ba 77       	st.h	sp[0xe],r7
	
	/* send xnl frame*/	
	xnl_tx(&xnl_frame);
80004e24:	1a 9c       	mov	r12,sp
80004e26:	f0 1f 00 04 	mcall	80004e34 <xcmp_tx+0x44>
}
80004e2a:	2c 0d       	sub	sp,-256
80004e2c:	e3 cd 80 80 	ldm	sp++,r7,pc
80004e30:	80 00       	ld.sh	r0,r0[0x0]
80004e32:	a4 6a       	st.h	r2[0xc],r10
80004e34:	80 00       	ld.sh	r0,r0[0x0]
80004e36:	52 ac       	stdsp	sp[0xa8],r12

80004e38 <xcmp_exit_device_control_mode>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_exit_device_control_mode(void)
{
80004e38:	d4 01       	pushm	lr
80004e3a:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DEVICE_CONTROL_MODE;
80004e3e:	e0 68 04 21 	mov	r8,1057
80004e42:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceControlMode_req_t * ptr = (DeviceControlMode_req_t *)xcmp_farme.u8;
80004e44:	fa c8 ff fc 	sub	r8,sp,-4
	
	ptr->Function = DCM_EXIT;
80004e48:	30 09       	mov	r9,0
80004e4a:	b0 89       	st.b	r8[0x0],r9
	ptr->ControlTypeSize = 1;
80004e4c:	30 19       	mov	r9,1
80004e4e:	b0 99       	st.b	r8[0x1],r9
	ptr->ControlType = 0x03;//DCM_SPEAKER_CTRL;
80004e50:	30 39       	mov	r9,3
80004e52:	b0 a9       	st.b	r8[0x2],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(DeviceControlMode_req_t));
80004e54:	30 3b       	mov	r11,3
80004e56:	fa cc ff fe 	sub	r12,sp,-2
80004e5a:	f0 1f 00 03 	mcall	80004e64 <xcmp_exit_device_control_mode+0x2c>
}
80004e5e:	2c dd       	sub	sp,-204
80004e60:	d8 02       	popm	pc
80004e62:	00 00       	add	r0,r0
80004e64:	80 00       	ld.sh	r0,r0[0x0]
80004e66:	4d f0       	lddpc	r0,80004fe0 <xcmp_init+0x30>

80004e68 <xcmp_enter_device_control_mode>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_enter_device_control_mode(void)
{
80004e68:	d4 01       	pushm	lr
80004e6a:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DEVICE_CONTROL_MODE;
80004e6e:	e0 68 04 21 	mov	r8,1057
80004e72:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceControlMode_req_t * ptr = (DeviceControlMode_req_t *)xcmp_farme.u8;
80004e74:	fa c8 ff fc 	sub	r8,sp,-4
	
	ptr->Function = DCM_ENTER;
80004e78:	30 19       	mov	r9,1
80004e7a:	b0 89       	st.b	r8[0x0],r9
	ptr->ControlTypeSize = 1;
80004e7c:	b0 99       	st.b	r8[0x1],r9
	ptr->ControlType = 0x03;// 0xEB;//user-input
80004e7e:	30 39       	mov	r9,3
80004e80:	b0 a9       	st.b	r8[0x2],r9
	//ptr->ControlType = DCM_SPEAKER_CTRL;
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(DeviceControlMode_req_t));
80004e82:	30 3b       	mov	r11,3
80004e84:	fa cc ff fe 	sub	r12,sp,-2
80004e88:	f0 1f 00 02 	mcall	80004e90 <xcmp_enter_device_control_mode+0x28>
}
80004e8c:	2c dd       	sub	sp,-204
80004e8e:	d8 02       	popm	pc
80004e90:	80 00       	ld.sh	r0,r0[0x0]
80004e92:	4d f0       	lddpc	r0,8000500c <xcmp_rx_process+0x8>

80004e94 <xcmp_audio_route_AMBE>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_audio_route_AMBE(void)
{
80004e94:	d4 01       	pushm	lr
80004e96:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | AUDIO_ROUTING_CONTROL;
80004e9a:	e0 68 04 14 	mov	r8,1044
80004e9e:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	AudioRoutingControl_req_t * ptr = (AudioRoutingControl_req_t *)xcmp_farme.u8;
80004ea0:	fa c8 ff fc 	sub	r8,sp,-4
	
	ptr->Function = Routing_Func_Update_Source;
80004ea4:	30 19       	mov	r9,1
80004ea6:	b0 89       	st.b	r8[0x0],r9
	
	
	unsigned short NumberofRoutings = 4;//2;
	ptr->NumberofRoutings[0] = (NumberofRoutings >> 8) & 0xFF;
80004ea8:	30 09       	mov	r9,0
80004eaa:	b0 99       	st.b	r8[0x1],r9
	ptr->NumberofRoutings[1] =  NumberofRoutings & 0xFF;
80004eac:	30 49       	mov	r9,4
80004eae:	b0 a9       	st.b	r8[0x2],r9
	
	//ptr->RoutingData[0].audioInput = IN_Microphone;//Post_AMBE_Encoder;//IN_Pre_Speaker_Audio_Data;//IN_Microphone;//IN_Option_Board;
	//ptr->RoutingData[0].audioOutput = OUT_Option_Board;//Post_AMBE_Encoder;//OUT_Microphone_Data;//
	//
	ptr->RoutingData[0].audioInput = Post_AMBE_Encoder;//IN_Option_Board;
80004eb0:	30 fa       	mov	r10,15
80004eb2:	b0 ba       	st.b	r8[0x3],r10
	ptr->RoutingData[0].audioOutput = OUT_Option_Board;// OUT_Speaker;
80004eb4:	30 c9       	mov	r9,12
80004eb6:	b0 c9       	st.b	r8[0x4],r9
	ptr->RoutingData[1].audioInput = IN_Option_Board;//IN_Option_Board;
80004eb8:	b0 d9       	st.b	r8[0x5],r9
	ptr->RoutingData[1].audioOutput = Post_AMBE_Encoder;// OUT_Speaker;
80004eba:	b0 ea       	st.b	r8[0x6],r10

	
	ptr->RoutingData[2].audioInput = Tx_Voice_Header;//IN_Option_Board;
80004ebc:	31 1a       	mov	r10,17
80004ebe:	b0 fa       	st.b	r8[0x7],r10
	ptr->RoutingData[2].audioOutput = OUT_Option_Board;// OUT_Speaker;
80004ec0:	f1 69 00 08 	st.b	r8[8],r9
	//ptr->RoutingData[3].audioInput = IN_Option_Board;//IN_Option_Board;
	//ptr->RoutingData[3].audioOutput = Tx_Voice_Header;// OUT_Speaker;
	
	ptr->RoutingData[3].audioInput = Tx_Voice_Terminator;//IN_Option_Board;
80004ec4:	31 3a       	mov	r10,19
80004ec6:	f1 6a 00 09 	st.b	r8[9],r10
	ptr->RoutingData[3].audioOutput = OUT_Option_Board;// OUT_Speaker;
80004eca:	f1 69 00 0a 	st.b	r8[10],r9
	
	//ptr->RoutingData[1].audioInput = IN_Option_Board;
	//ptr->RoutingData[1].audioOutput = OUT_Microphone_Data;//OUT_Speaker;//
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(AudioRoutingControl_req_t) - (MAX_ROUTING_CTR - NumberofRoutings) * sizeof(RoutingData_t));
80004ece:	30 bb       	mov	r11,11
80004ed0:	fa cc ff fe 	sub	r12,sp,-2
80004ed4:	f0 1f 00 02 	mcall	80004edc <xcmp_audio_route_AMBE+0x48>
}
80004ed8:	2c dd       	sub	sp,-204
80004eda:	d8 02       	popm	pc
80004edc:	80 00       	ld.sh	r0,r0[0x0]
80004ede:	4d f0       	lddpc	r0,80005058 <xcmp_rx_process+0x54>

80004ee0 <xcmp_enter_enhanced_OB_mode>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_enter_enhanced_OB_mode(void)
{
80004ee0:	d4 01       	pushm	lr
80004ee2:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | EN_OB_CONTROL;
80004ee6:	e0 68 04 65 	mov	r8,1125
80004eea:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	En_OB_Control_req_t * ptr = (En_OB_Control_req_t *)xcmp_farme.u8;
	
	ptr->Function = EN_OB_Enter;
80004eec:	fa cc ff fe 	sub	r12,sp,-2
80004ef0:	30 18       	mov	r8,1
80004ef2:	b8 a8       	st.b	r12[0x2],r8
		
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(En_OB_Control_req_t));
80004ef4:	30 1b       	mov	r11,1
80004ef6:	f0 1f 00 03 	mcall	80004f00 <xcmp_enter_enhanced_OB_mode+0x20>
}
80004efa:	2c dd       	sub	sp,-204
80004efc:	d8 02       	popm	pc
80004efe:	00 00       	add	r0,r0
80004f00:	80 00       	ld.sh	r0,r0[0x0]
80004f02:	4d f0       	lddpc	r0,8000507c <xcmp_rx_process+0x78>

80004f04 <xcmp_DeviceInitializationStatus_request>:
Description: send device initialization status request
Calls: xcmp_tx
Called By:...
*/
void xcmp_DeviceInitializationStatus_request(void)
{
80004f04:	d4 01       	pushm	lr
80004f06:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
		
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_BRDCAST | DEVICE_INITIALIZATION_STATUS;
80004f0a:	fe 78 b4 00 	mov	r8,-19456
80004f0e:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceInitializationStatus_brdcst_t * ptr 
						 = (DeviceInitializationStatus_brdcst_t *)xcmp_farme.u8;
80004f10:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*xcmp version 8.1.0.5*///
	ptr->XCMPVersion[0] = 0x08;
80004f14:	30 89       	mov	r9,8
80004f16:	b0 89       	st.b	r8[0x0],r9
	ptr->XCMPVersion[1] = 0x01;
80004f18:	30 19       	mov	r9,1
80004f1a:	b0 99       	st.b	r8[0x1],r9
	ptr->XCMPVersion[2] = 0x00;
80004f1c:	30 09       	mov	r9,0
80004f1e:	b0 a9       	st.b	r8[0x2],r9
	ptr->XCMPVersion[3] = 0x05;
80004f20:	30 5a       	mov	r10,5
80004f22:	b0 ba       	st.b	r8[0x3],r10
	/*
	0x00:
	This is the message that the device sends at power up or after a reset. It 
	will give the initial status and capabilities for the device.
	*/
	ptr->DeviceInitType = 0x00;
80004f24:	b0 c9       	st.b	r8[0x4],r9
	types of devices may provide a set of services to the radio system, but do 
	not have the ability to be the master.
	
	0x07:OptionBoard,3rd party Option Board-based application.
	*/
	ptr->DeviceStatusInfo.DeviceType = 0x07;
80004f26:	30 7a       	mov	r10,7
80004f28:	b0 da       	st.b	r8[0x5],r10
	
	/*Power Up Success, Device has powered up with no errors*/
	ptr->DeviceStatusInfo.DeviceStatus[0] = 0x00;
80004f2a:	b0 e9       	st.b	r8[0x6],r9
	ptr->DeviceStatusInfo.DeviceStatus[1] = 0x00;
80004f2c:	b0 f9       	st.b	r8[0x7],r9
	
	/*
	This number is the size of the Device Descriptor data structure with a 
	maximum size not exceeding 255 bytes.
	*/
	ptr->DeviceStatusInfo.DeviceDescriptorSize = 0x00;
80004f2e:	f1 69 00 08 	st.b	r8[8],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme
80004f32:	30 9b       	mov	r11,9
80004f34:	fa cc ff fe 	sub	r12,sp,-2
80004f38:	f0 1f 00 02 	mcall	80004f40 <xcmp_DeviceInitializationStatus_request+0x3c>
		, sizeof(DeviceInitializationStatus_brdcst_t) - MAX_DEVICE_DESC_SIZE);
}
80004f3c:	2c dd       	sub	sp,-204
80004f3e:	d8 02       	popm	pc
80004f40:	80 00       	ld.sh	r0,r0[0x0]
80004f42:	4d f0       	lddpc	r0,800050bc <xcmp_rx_process+0xb8>

80004f44 <xcmp_opcode_not_supported>:
Description: register the app list
Calls: xcmp_tx
Called By:...
*/
void xcmp_opcode_not_supported( void )
{
80004f44:	d4 01       	pushm	lr
80004f46:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REPLY;
80004f4a:	fe 78 80 00 	mov	r8,-32768
80004f4e:	ba 18       	st.h	sp[0x2],r8
	
	/*The radio does not support this opcode.*/
	xcmp_farme.u8[0] = xcmp_Res_Opcode_Not_Supported;
80004f50:	30 38       	mov	r8,3
80004f52:	ba c8       	st.b	sp[0x4],r8
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, 1);
80004f54:	30 1b       	mov	r11,1
80004f56:	fa cc ff fe 	sub	r12,sp,-2
80004f5a:	f0 1f 00 03 	mcall	80004f64 <xcmp_opcode_not_supported+0x20>
}
80004f5e:	2c dd       	sub	sp,-204
80004f60:	d8 02       	popm	pc
80004f62:	00 00       	add	r0,r0
80004f64:	80 00       	ld.sh	r0,r0[0x0]
80004f66:	4d f0       	lddpc	r0,800050e0 <xcmp_rx_process+0xdc>

80004f68 <xcmp_exec_func>:
Description: Perform XCMP corresponding functions
Calls:   
Called By: xcmp_rx_process--task
*/
static void xcmp_exec_func(app_exec_t * exec, xcmp_fragment_t * xcmp)
{
80004f68:	d4 01       	pushm	lr
	/*The message types*/
	switch(xcmp->xcmp_opcode & 0xF000)
80004f6a:	96 88       	ld.uh	r8,r11[0x0]
80004f6c:	e2 18 f0 00 	andl	r8,0xf000,COH
80004f70:	e0 48 80 00 	cp.w	r8,32768
80004f74:	c0 f0       	breq	80004f92 <xcmp_exec_func+0x2a>
80004f76:	e0 48 b0 00 	cp.w	r8,45056
80004f7a:	c1 20       	breq	80004f9e <xcmp_exec_func+0x36>
80004f7c:	58 08       	cp.w	r8,0
80004f7e:	c1 51       	brne	80004fa8 <xcmp_exec_func+0x40>
	{
		case XCMP_REQUEST:
			if(NULL != exec->xcmp_rx_req)
80004f80:	78 08       	ld.w	r8,r12[0x0]
80004f82:	58 08       	cp.w	r8,0
80004f84:	c0 40       	breq	80004f8c <xcmp_exec_func+0x24>
			{
				exec->xcmp_rx_req(xcmp);
80004f86:	16 9c       	mov	r12,r11
80004f88:	5d 18       	icall	r8
80004f8a:	d8 02       	popm	pc
			}
			else 
			{
				/*No function to register the request message*/
				/*send not supported opcode to raido */
				xcmp_opcode_not_supported();
80004f8c:	f0 1f 00 08 	mcall	80004fac <xcmp_exec_func+0x44>
80004f90:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_REPLY:		
			if(NULL != exec->xcmp_rx_reply)
80004f92:	78 18       	ld.w	r8,r12[0x4]
80004f94:	58 08       	cp.w	r8,0
80004f96:	c0 90       	breq	80004fa8 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_reply(xcmp);
80004f98:	16 9c       	mov	r12,r11
80004f9a:	5d 18       	icall	r8
80004f9c:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_BRDCAST:	
			if(NULL != exec->xcmp_rx_brdcst)
80004f9e:	78 28       	ld.w	r8,r12[0x8]
80004fa0:	58 08       	cp.w	r8,0
80004fa2:	c0 30       	breq	80004fa8 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_brdcst(xcmp);
80004fa4:	16 9c       	mov	r12,r11
80004fa6:	5d 18       	icall	r8
80004fa8:	d8 02       	popm	pc
80004faa:	00 00       	add	r0,r0
80004fac:	80 00       	ld.sh	r0,r0[0x0]
80004fae:	4f 44       	lddpc	r4,8000517c <xnl_get_msg_ack_func+0x24>

80004fb0 <xcmp_init>:
	xQueueCreate -- freertos
	xTaskCreate -- freertos
Called By: main -- main.c
*/
void xcmp_init(void)
{
80004fb0:	d4 01       	pushm	lr
	/*initialize the xnl*/
	xnl_init();
80004fb2:	f0 1f 00 0d 	mcall	80004fe4 <xcmp_init+0x34>
	
	/*register the xcmp function(callback function)*/
	xnl_register_xcmp_func( xcmp_rx );
80004fb6:	48 dc       	lddpc	r12,80004fe8 <xcmp_init+0x38>
80004fb8:	f0 1f 00 0d 	mcall	80004fec <xcmp_init+0x3c>
	
	/*initialize the queue*/
	//xcmp_frame_rx = xQueueCreate(10, sizeof(xcmp_fragment_t *));
	
	xcmp_frame_rx = xQueueCreate(20, sizeof(xcmp_fragment_t *));
80004fbc:	30 4b       	mov	r11,4
80004fbe:	31 4c       	mov	r12,20
80004fc0:	f0 1f 00 0c 	mcall	80004ff0 <xcmp_init+0x40>
80004fc4:	48 c8       	lddpc	r8,80004ff4 <xcmp_init+0x44>
80004fc6:	91 0c       	st.w	r8[0x0],r12
	/*create task*/	
	/*this task is used to execute xcmp message*/
	xTaskCreate(
80004fc8:	30 09       	mov	r9,0
80004fca:	1a d9       	st.w	--sp,r9
80004fcc:	1a d9       	st.w	--sp,r9
80004fce:	1a d9       	st.w	--sp,r9
80004fd0:	30 38       	mov	r8,3
80004fd2:	e0 6a 01 80 	mov	r10,384
80004fd6:	48 9b       	lddpc	r11,80004ff8 <xcmp_init+0x48>
80004fd8:	48 9c       	lddpc	r12,80004ffc <xcmp_init+0x4c>
80004fda:	f0 1f 00 0a 	mcall	80005000 <xcmp_init+0x50>
80004fde:	2f dd       	sub	sp,-12
	,  384
	,  NULL
	,  tskXCMP_PRIORITY
	,  NULL
	);
}
80004fe0:	d8 02       	popm	pc
80004fe2:	00 00       	add	r0,r0
80004fe4:	80 00       	ld.sh	r0,r0[0x0]
80004fe6:	53 90       	stdsp	sp[0xe4],r0
80004fe8:	80 00       	ld.sh	r0,r0[0x0]
80004fea:	51 00       	stdsp	sp[0x40],r0
80004fec:	80 00       	ld.sh	r0,r0[0x0]
80004fee:	51 4c       	stdsp	sp[0x50],r12
80004ff0:	80 00       	ld.sh	r0,r0[0x0]
80004ff2:	90 0c       	ld.sh	r12,r8[0x0]
80004ff4:	00 00       	add	r0,r0
80004ff6:	10 0c       	add	r12,r8
80004ff8:	80 01       	ld.sh	r1,r0[0x0]
80004ffa:	8a 7c       	ld.sh	r12,r5[0xe]
80004ffc:	80 00       	ld.sh	r0,r0[0x0]
80004ffe:	50 04       	stdsp	sp[0x0],r4
80005000:	80 00       	ld.sh	r0,r0[0x0]
80005002:	96 e0       	ld.uh	r0,r11[0xc]

80005004 <xcmp_rx_process>:
Calls: xQueueReceive -- freerots
	xcmp_exec_func
Called By: task
*/
static void xcmp_rx_process(void * pvParameters)
{
80005004:	d4 31       	pushm	r0-r7,lr
80005006:	20 1d       	sub	sp,4
	xcmp_fragment_t xcmp;
	xcmp_fragment_t * ptr;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//10ms
80005008:	4b 16       	lddpc	r6,800050cc <xcmp_rx_process+0xc8>
8000500a:	30 05       	mov	r5,0
8000500c:	31 44       	mov	r4,20
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
8000500e:	4b 13       	lddpc	r3,800050d0 <xcmp_rx_process+0xcc>
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
					break;
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
80005010:	4b 12       	lddpc	r2,800050d4 <xcmp_rx_process+0xd0>
						, ptr);
					break;
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
80005012:	4b 21       	lddpc	r1,800050d8 <xcmp_rx_process+0xd4>
					break;
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
80005014:	4b 20       	lddpc	r0,800050dc <xcmp_rx_process+0xd8>
	xcmp_fragment_t xcmp;
	xcmp_fragment_t * ptr;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//10ms
80005016:	6c 0c       	ld.w	r12,r6[0x0]
80005018:	0a 99       	mov	r9,r5
8000501a:	08 9a       	mov	r10,r4
8000501c:	1a 9b       	mov	r11,sp
8000501e:	f0 1f 00 31 	mcall	800050e0 <xcmp_rx_process+0xdc>
80005022:	58 1c       	cp.w	r12,1
80005024:	cf 91       	brne	80005016 <xcmp_rx_process+0x12>
		{									
			if(NULL == ptr)
80005026:	40 0b       	lddsp	r11,sp[0x0]
80005028:	58 0b       	cp.w	r11,0
8000502a:	cf 60       	breq	80005016 <xcmp_rx_process+0x12>
				continue;
			}
			
			//log("\n\r R_xcmp : %4x \n\r",ptr->xcmp_opcode);//log:R_xcmp	
						
			switch(ptr->xcmp_opcode & 0x0FFF)
8000502c:	96 0a       	ld.sh	r10,r11[0x0]
8000502e:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
80005032:	f1 d9 c0 0c 	bfextu	r8,r9,0x0,0xc
80005036:	59 c8       	cp.w	r8,28
80005038:	c1 e0       	breq	80005074 <xcmp_rx_process+0x70>
8000503a:	e0 89 00 07 	brgt	80005048 <xcmp_rx_process+0x44>
8000503e:	58 e8       	cp.w	r8,14
80005040:	c0 e0       	breq	8000505c <xcmp_rx_process+0x58>
80005042:	58 f8       	cp.w	r8,15
80005044:	c2 41       	brne	8000508c <xcmp_rx_process+0x88>
80005046:	c0 f8       	rjmp	80005064 <xcmp_rx_process+0x60>
80005048:	e0 48 01 09 	cp.w	r8,265
8000504c:	c1 80       	breq	8000507c <xcmp_rx_process+0x78>
8000504e:	e0 48 01 0a 	cp.w	r8,266
80005052:	c1 90       	breq	80005084 <xcmp_rx_process+0x80>
80005054:	e0 48 00 2c 	cp.w	r8,44
80005058:	c1 a1       	brne	8000508c <xcmp_rx_process+0x88>
8000505a:	c0 98       	rjmp	8000506c <xcmp_rx_process+0x68>
			{
				case RADIO_STATUS:				
					xcmp_exec_func(&radio_status, ptr);
8000505c:	4a 2c       	lddpc	r12,800050e4 <xcmp_rx_process+0xe0>
8000505e:	f0 1f 00 23 	mcall	800050e8 <xcmp_rx_process+0xe4>
					break;
80005062:	c2 f8       	rjmp	800050c0 <xcmp_rx_process+0xbc>
					
				case VERSION_INFORMATION:
					xcmp_exec_func(&version_information, ptr);
80005064:	4a 2c       	lddpc	r12,800050ec <xcmp_rx_process+0xe8>
80005066:	f0 1f 00 21 	mcall	800050e8 <xcmp_rx_process+0xe4>
					break;
8000506a:	c2 b8       	rjmp	800050c0 <xcmp_rx_process+0xbc>
					
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
8000506c:	4a 1c       	lddpc	r12,800050f0 <xcmp_rx_process+0xec>
8000506e:	f0 1f 00 1f 	mcall	800050e8 <xcmp_rx_process+0xe4>
					break;
80005072:	c2 78       	rjmp	800050c0 <xcmp_rx_process+0xbc>
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
80005074:	04 9c       	mov	r12,r2
80005076:	f0 1f 00 1d 	mcall	800050e8 <xcmp_rx_process+0xe4>
						, ptr);
					break;
8000507a:	c2 38       	rjmp	800050c0 <xcmp_rx_process+0xbc>
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
8000507c:	02 9c       	mov	r12,r1
8000507e:	f0 1f 00 1b 	mcall	800050e8 <xcmp_rx_process+0xe4>
					break;
80005082:	c1 f8       	rjmp	800050c0 <xcmp_rx_process+0xbc>
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
80005084:	00 9c       	mov	r12,r0
80005086:	f0 1f 00 19 	mcall	800050e8 <xcmp_rx_process+0xe4>
					break;
8000508a:	c1 b8       	rjmp	800050c0 <xcmp_rx_process+0xbc>
					
				default:
				
					/*the xcmp message not in order list*/
					/*over the length of the list*/
					if((0x0400 != (ptr->xcmp_opcode & 0x0400)) 
8000508c:	12 98       	mov	r8,r9
8000508e:	e2 18 04 00 	andl	r8,0x400,COH
80005092:	c0 70       	breq	800050a0 <xcmp_rx_process+0x9c>
80005094:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
80005098:	e0 48 00 68 	cp.w	r8,104
8000509c:	e0 8a 00 08 	brle	800050ac <xcmp_rx_process+0xa8>
						|| (MAX_APP_FUNC <= (ptr->xcmp_opcode & 0x00FF))
					)
					{
						/*xcmp request*/
						if( XCMP_REQUEST == (ptr->xcmp_opcode & 0xF000))
800050a0:	e2 19 f0 00 	andl	r9,0xf000,COH
800050a4:	c0 e1       	brne	800050c0 <xcmp_rx_process+0xbc>
						{
							/*send not supported opcode to raido */
							xcmp_opcode_not_supported();
800050a6:	f0 1f 00 14 	mcall	800050f4 <xcmp_rx_process+0xf0>
800050aa:	c0 b8       	rjmp	800050c0 <xcmp_rx_process+0xbc>
						}
					}
					else
					{					
						xcmp_exec_func( &app_list[ptr->xcmp_opcode & 0x00FF]
800050ac:	f9 da c0 08 	bfextu	r12,r10,0x0,0x8
800050b0:	f8 0c 00 1c 	add	r12,r12,r12<<0x1
800050b4:	49 19       	lddpc	r9,800050f8 <xcmp_rx_process+0xf4>
800050b6:	72 08       	ld.w	r8,r9[0x0]
800050b8:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800050bc:	f0 1f 00 0b 	mcall	800050e8 <xcmp_rx_process+0xe4>
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
800050c0:	66 0c       	ld.w	r12,r3[0x0]
800050c2:	40 0b       	lddsp	r11,sp[0x0]
800050c4:	f0 1f 00 0e 	mcall	800050fc <xcmp_rx_process+0xf8>
800050c8:	ca 7b       	rjmp	80005016 <xcmp_rx_process+0x12>
800050ca:	00 00       	add	r0,r0
800050cc:	00 00       	add	r0,r0
800050ce:	10 0c       	add	r12,r8
800050d0:	00 00       	add	r0,r0
800050d2:	0f b8       	ld.ub	r8,r7[0x3]
800050d4:	00 00       	add	r0,r0
800050d6:	10 1c       	sub	r12,r8
800050d8:	00 00       	add	r0,r0
800050da:	10 10       	sub	r0,r8
800050dc:	00 00       	add	r0,r0
800050de:	10 28       	rsub	r8,r8
800050e0:	80 00       	ld.sh	r0,r0[0x0]
800050e2:	8c a8       	ld.uh	r8,r6[0x4]
800050e4:	00 00       	add	r0,r0
800050e6:	10 40       	or	r0,r8
800050e8:	80 00       	ld.sh	r0,r0[0x0]
800050ea:	4f 68       	lddpc	r8,800052c0 <xnl_tx+0x14>
800050ec:	00 00       	add	r0,r0
800050ee:	10 00       	add	r0,r8
800050f0:	00 00       	add	r0,r0
800050f2:	10 34       	cp.w	r4,r8
800050f4:	80 00       	ld.sh	r0,r0[0x0]
800050f6:	4f 44       	lddpc	r4,800052c4 <xnl_tx+0x18>
800050f8:	00 00       	add	r0,r0
800050fa:	46 1c       	lddsp	r12,sp[0x184]
800050fc:	80 00       	ld.sh	r0,r0[0x0]
800050fe:	3a 50       	mov	r0,-91

80005100 <xcmp_rx>:
Calls:   
	xQueueSend -- xnl.c
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
80005100:	eb cd 40 90 	pushm	r4,r7,lr
80005104:	20 1d       	sub	sp,4
80005106:	fa c4 ff f0 	sub	r4,sp,-16
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
8000510a:	48 c8       	lddpc	r8,80005138 <xcmp_rx+0x38>
8000510c:	70 0c       	ld.w	r12,r8[0x0]
8000510e:	f0 1f 00 0c 	mcall	8000513c <xcmp_rx+0x3c>
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
80005112:	c1 00       	breq	80005132 <xcmp_rx+0x32>
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
80005114:	fa c7 ff fc 	sub	r7,sp,-4
80005118:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
	{
		memcpy(xcmp_ptr, &xcmp, sizeof(xcmp_fragment_t));				
8000511a:	e0 6a 00 ca 	mov	r10,202
8000511e:	08 9b       	mov	r11,r4
80005120:	f0 1f 00 08 	mcall	80005140 <xcmp_rx+0x40>
		xQueueSend(xcmp_frame_rx, &xcmp_ptr, 0);	
80005124:	48 88       	lddpc	r8,80005144 <xcmp_rx+0x44>
80005126:	70 0c       	ld.w	r12,r8[0x0]
80005128:	30 09       	mov	r9,0
8000512a:	12 9a       	mov	r10,r9
8000512c:	1a 9b       	mov	r11,sp
8000512e:	f0 1f 00 07 	mcall	80005148 <xcmp_rx+0x48>
	}	
}
80005132:	2f fd       	sub	sp,-4
80005134:	e3 cd 80 90 	ldm	sp++,r4,r7,pc
80005138:	00 00       	add	r0,r0
8000513a:	0f b8       	ld.ub	r8,r7[0x3]
8000513c:	80 00       	ld.sh	r0,r0[0x0]
8000513e:	40 b0       	lddsp	r0,sp[0x2c]
80005140:	80 00       	ld.sh	r0,r0[0x0]
80005142:	a4 6a       	st.h	r2[0xc],r10
80005144:	00 00       	add	r0,r0
80005146:	10 0c       	add	r12,r8
80005148:	80 00       	ld.sh	r0,r0[0x0]
8000514a:	8e b4       	ld.uh	r4,r7[0x6]

8000514c <xnl_register_xcmp_func>:
Function: xnl_register_xcmp_func
Description: register the xcmp function(callback function)
*/
void xnl_register_xcmp_func( void ( *func)(xnl_content_data_msg_t))
{
	 xcmp_exec = func;
8000514c:	48 28       	lddpc	r8,80005154 <xnl_register_xcmp_func+0x8>
8000514e:	91 0c       	st.w	r8[0x0],r12
}
80005150:	5e fc       	retal	r12
80005152:	00 00       	add	r0,r0
80005154:	00 00       	add	r0,r0
80005156:	10 70       	tst	r0,r8

80005158 <xnl_get_msg_ack_func>:
Description: process while receive msg ack.
Calls:xSemaphoreGive--freertos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
80005158:	d4 01       	pushm	lr
	
	DestinationAddress = xnl->xnl_header.destination;
	/*No timeout*/		
	 //One relationship is controlled by a state machine, only the current MSG received the ACK, 
	//then the program will clear the current MSG sending address and out of standby and will jump to the sending state.
	if (DestinationAddress == xnl_information.device_address )
8000515a:	48 88       	lddpc	r8,80005178 <xnl_get_msg_ack_func+0x20>
8000515c:	90 28       	ld.sh	r8,r8[0x4]
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
	U16 DestinationAddress;
	U16 TransactionID;
	
	DestinationAddress = xnl->xnl_header.destination;
8000515e:	98 49       	ld.sh	r9,r12[0x8]
80005160:	f0 09 19 00 	cp.h	r9,r8
80005164:	c0 81       	brne	80005174 <xnl_get_msg_ack_func+0x1c>
	if (DestinationAddress == xnl_information.device_address )
	{
		//The ack is for me.
		
		TransactionID = xnl->xnl_header.transaction_id;
		xSemaphoreGive(xnl_timeout_semphr);	
80005166:	48 68       	lddpc	r8,8000517c <xnl_get_msg_ack_func+0x24>
80005168:	70 0c       	ld.w	r12,r8[0x0]
8000516a:	30 09       	mov	r9,0
8000516c:	12 9a       	mov	r10,r9
8000516e:	12 9b       	mov	r11,r9
80005170:	f0 1f 00 04 	mcall	80005180 <xnl_get_msg_ack_func+0x28>
80005174:	d8 02       	popm	pc
80005176:	00 00       	add	r0,r0
80005178:	00 00       	add	r0,r0
8000517a:	10 50       	eor	r0,r8
8000517c:	00 00       	add	r0,r0
8000517e:	10 4c       	or	r12,r8
80005180:	80 00       	ld.sh	r0,r0[0x0]
80005182:	8e b4       	ld.uh	r4,r7[0x6]

80005184 <xnl_tx_process>:
	xSemaphoreTake--freertos 
	phy_tx -- physical.c
Called By: task
*/
static void xnl_tx_process(void * pvParameters)
{
80005184:	d4 31       	pushm	r0-r7,lr
	static  xnl_fragment_t * ptr;//
	
	
	for(;;)
	{		
		switch(xnl_tx_state)
80005186:	4a 86       	lddpc	r6,80005224 <xnl_tx_process+0xa0>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
80005188:	4a 82       	lddpc	r2,80005228 <xnl_tx_process+0xa4>
8000518a:	4a 94       	lddpc	r4,8000522c <xnl_tx_process+0xa8>
8000518c:	30 07       	mov	r7,0
8000518e:	3f f1       	mov	r1,-1
					if(NULL == ptr)
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
80005190:	30 00       	mov	r0,0
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;
80005192:	4a 85       	lddpc	r5,80005230 <xnl_tx_process+0xac>
					
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
80005194:	4a 83       	lddpc	r3,80005234 <xnl_tx_process+0xb0>
	static  xnl_fragment_t * ptr;//
	
	
	for(;;)
	{		
		switch(xnl_tx_state)
80005196:	6c 08       	ld.w	r8,r6[0x0]
80005198:	58 08       	cp.w	r8,0
8000519a:	c0 40       	breq	800051a2 <xnl_tx_process+0x1e>
8000519c:	58 18       	cp.w	r8,1
8000519e:	cf d1       	brne	80005198 <xnl_tx_process+0x14>
800051a0:	c2 08       	rjmp	800051e0 <xnl_tx_process+0x5c>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
800051a2:	64 0c       	ld.w	r12,r2[0x0]
800051a4:	0e 99       	mov	r9,r7
800051a6:	02 9a       	mov	r10,r1
800051a8:	08 9b       	mov	r11,r4
800051aa:	f0 1f 00 24 	mcall	80005238 <xnl_tx_process+0xb4>
800051ae:	58 1c       	cp.w	r12,1
800051b0:	cf 31       	brne	80005196 <xnl_tx_process+0x12>
					, portMAX_DELAY ))
				{				
					if(NULL == ptr)
800051b2:	68 0c       	ld.w	r12,r4[0x0]
800051b4:	58 0c       	cp.w	r12,0
800051b6:	cf 00       	breq	80005196 <xnl_tx_process+0x12>
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
800051b8:	98 28       	ld.sh	r8,r12[0x4]
800051ba:	e0 08 19 00 	cp.h	r8,r0
800051be:	c0 41       	brne	800051c6 <xnl_tx_process+0x42>
					{
						/*invalid XNL opcode*/
						vPortFree(ptr);
800051c0:	f0 1f 00 1f 	mcall	8000523c <xnl_tx_process+0xb8>
						break;
800051c4:	ce 9b       	rjmp	80005196 <xnl_tx_process+0x12>
					}
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
800051c6:	f0 1f 00 1f 	mcall	80005240 <xnl_tx_process+0xbc>
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;
800051ca:	30 18       	mov	r8,1
800051cc:	8b 08       	st.w	r5[0x0],r8
					
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
800051ce:	66 0c       	ld.w	r12,r3[0x0]
800051d0:	0e 99       	mov	r9,r7
800051d2:	0e 9a       	mov	r10,r7
800051d4:	0e 9b       	mov	r11,r7
800051d6:	f0 1f 00 19 	mcall	80005238 <xnl_tx_process+0xb4>
					xnl_tx_state = WAITING_FOR_REPLY;
800051da:	30 18       	mov	r8,1
800051dc:	8d 08       	st.w	r6[0x0],r8
800051de:	cd cb       	rjmp	80005196 <xnl_tx_process+0x12>
				}
				break;
			
			/*wait XNL reply*/			
			case WAITING_FOR_REPLY://ACKdata/control
				if(pdTRUE == xSemaphoreTake( xnl_timeout_semphr
800051e0:	66 0c       	ld.w	r12,r3[0x0]
800051e2:	0e 99       	mov	r9,r7
800051e4:	36 4a       	mov	r10,100
800051e6:	0e 9b       	mov	r11,r7
800051e8:	f0 1f 00 14 	mcall	80005238 <xnl_tx_process+0xb4>
800051ec:	58 1c       	cp.w	r12,1
800051ee:	c0 81       	brne	800051fe <xnl_tx_process+0x7a>
					, ( portTickType )50*2/ portTICK_RATE_MS))//ADK500ms,freertos
				{
					/*No timeout*/
					//vPortFree(ptr);	
					set_xnl_idle(ptr);			
800051f0:	49 58       	lddpc	r8,80005244 <xnl_tx_process+0xc0>
800051f2:	70 0c       	ld.w	r12,r8[0x0]
800051f4:	68 0b       	ld.w	r11,r4[0x0]
800051f6:	f0 1f 00 15 	mcall	80005248 <xnl_tx_process+0xc4>
					xnl_tx_state = WAITING_FOR_TX;
800051fa:	8d 07       	st.w	r6[0x0],r7
800051fc:	cc db       	rjmp	80005196 <xnl_tx_process+0x12>
				}
				else
				{
					/*time out*/
					if(xnl_send_times <= MIN_RESEND_TIMES)
800051fe:	6a 08       	ld.w	r8,r5[0x0]
80005200:	58 38       	cp.w	r8,3
80005202:	e0 89 00 09 	brgt	80005214 <xnl_tx_process+0x90>
					{
						/*If times smaller than A supermarket, then resend the 
						instructions*/
						phy_tx((phy_fragment_t *)ptr);
80005206:	68 0c       	ld.w	r12,r4[0x0]
80005208:	f0 1f 00 0e 	mcall	80005240 <xnl_tx_process+0xbc>
						xnl_send_times++;
8000520c:	6a 08       	ld.w	r8,r5[0x0]
8000520e:	2f f8       	sub	r8,-1
80005210:	8b 08       	st.w	r5[0x0],r8
80005212:	cc 2b       	rjmp	80005196 <xnl_tx_process+0x12>
					}
					else
					{
						//can not send data, disconnected						
						//vPortFree(ptr);	
						set_xnl_idle(ptr);									
80005214:	48 c8       	lddpc	r8,80005244 <xnl_tx_process+0xc0>
80005216:	70 0c       	ld.w	r12,r8[0x0]
80005218:	68 0b       	ld.w	r11,r4[0x0]
8000521a:	f0 1f 00 0c 	mcall	80005248 <xnl_tx_process+0xc4>
						xnl_tx_state = WAITING_FOR_TX;
8000521e:	8d 07       	st.w	r6[0x0],r7
80005220:	cb bb       	rjmp	80005196 <xnl_tx_process+0x12>
80005222:	00 00       	add	r0,r0
80005224:	00 00       	add	r0,r0
80005226:	10 64       	and	r4,r8
80005228:	00 00       	add	r0,r0
8000522a:	10 60       	and	r0,r8
8000522c:	00 00       	add	r0,r0
8000522e:	10 5c       	eor	r12,r8
80005230:	00 00       	add	r0,r0
80005232:	10 68       	and	r8,r8
80005234:	00 00       	add	r0,r0
80005236:	10 4c       	or	r12,r8
80005238:	80 00       	ld.sh	r0,r0[0x0]
8000523a:	8c a8       	ld.uh	r8,r6[0x4]
8000523c:	80 00       	ld.sh	r0,r0[0x0]
8000523e:	8b 38       	st.w	r5[0xc],r8
80005240:	80 00       	ld.sh	r0,r0[0x0]
80005242:	3a 70       	mov	r0,-89
80005244:	00 00       	add	r0,r0
80005246:	0f b8       	ld.ub	r8,r7[0x3]
80005248:	80 00       	ld.sh	r0,r0[0x0]
8000524a:	3a 50       	mov	r0,-91

8000524c <xnl_rx_process>:
Description: Receive the XNL
Calls: 
Called By:task
*/
static void xnl_rx_process(void * pvParameters)
{
8000524c:	eb cd 40 fe 	pushm	r1-r7,lr
80005250:	20 1d       	sub	sp,4
	/*To ptr the elements in the queue*/
	xnl_fragment_t * xnl_ptr;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
80005252:	49 26       	lddpc	r6,80005298 <xnl_rx_process+0x4c>
80005254:	30 05       	mov	r5,0
80005256:	3f f4       	mov	r4,-1
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
80005258:	30 c3       	mov	r3,12
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
8000525a:	49 11       	lddpc	r1,8000529c <xnl_rx_process+0x50>
	if(xnl->xnl_header.opcode > 0x0C)	
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
8000525c:	49 12       	lddpc	r2,800052a0 <xnl_rx_process+0x54>
	/*To ptr the elements in the queue*/
	xnl_fragment_t * xnl_ptr;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
8000525e:	6c 0c       	ld.w	r12,r6[0x0]
80005260:	0a 99       	mov	r9,r5
80005262:	08 9a       	mov	r10,r4
80005264:	1a 9b       	mov	r11,sp
80005266:	f0 1f 00 10 	mcall	800052a4 <xnl_rx_process+0x58>
8000526a:	58 1c       	cp.w	r12,1
8000526c:	cf 91       	brne	8000525e <xnl_rx_process+0x12>
		, portMAX_DELAY ))
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
8000526e:	40 0c       	lddsp	r12,sp[0x0]
80005270:	58 0c       	cp.w	r12,0
80005272:	cf 60       	breq	8000525e <xnl_rx_process+0x12>
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
80005274:	98 28       	ld.sh	r8,r12[0x4]
80005276:	e6 08 19 00 	cp.h	r8,r3
8000527a:	e0 8b 00 0a 	brhi	8000528e <xnl_rx_process+0x42>
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
8000527e:	5c 78       	castu.h	r8
80005280:	e4 08 03 29 	ld.w	r9,r2[r8<<0x2]
80005284:	58 09       	cp.w	r9,0
80005286:	c0 40       	breq	8000528e <xnl_rx_process+0x42>
	{
		//log("\n\r R_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:R_xnl
		/*execute the function in list*/
		xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec(xnl);
80005288:	e4 08 03 28 	ld.w	r8,r2[r8<<0x2]
8000528c:	5d 18       	icall	r8
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
8000528e:	62 0c       	ld.w	r12,r1[0x0]
80005290:	40 0b       	lddsp	r11,sp[0x0]
80005292:	f0 1f 00 06 	mcall	800052a8 <xnl_rx_process+0x5c>
80005296:	ce 4b       	rjmp	8000525e <xnl_rx_process+0x12>
80005298:	00 00       	add	r0,r0
8000529a:	0f cc       	ld.ub	r12,r7[0x4]
8000529c:	00 00       	add	r0,r0
8000529e:	0f b8       	ld.ub	r8,r7[0x3]
800052a0:	00 00       	add	r0,r0
800052a2:	04 fc       	st.b	--r2,r12
800052a4:	80 00       	ld.sh	r0,r0[0x0]
800052a6:	8c a8       	ld.uh	r8,r6[0x4]
800052a8:	80 00       	ld.sh	r0,r0[0x0]
800052aa:	3a 50       	mov	r0,-91

800052ac <xnl_tx>:
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
{
800052ac:	eb cd 40 c0 	pushm	r6-r7,lr
800052b0:	20 1d       	sub	sp,4
800052b2:	18 96       	mov	r6,r12
	message that is sent. The same value should be used for all retries.
	*/
	static U8 flags = 0;
	
	/*If the value is DEFAULT_VALUE, the value will be modified*/
	if(DEFAULT_VALUE == xnl->xnl_header.flags)
800052b4:	98 39       	ld.sh	r9,r12[0x6]
800052b6:	3f f8       	mov	r8,-1
800052b8:	f0 09 19 00 	cp.h	r9,r8
800052bc:	c0 a1       	brne	800052d0 <xnl_tx+0x24>
	{
		xnl->xnl_header.flags =  0x0100 | ((++flags) & 0x07);
800052be:	4a e9       	lddpc	r9,80005374 <xnl_tx+0xc8>
800052c0:	13 88       	ld.ub	r8,r9[0x0]
800052c2:	2f f8       	sub	r8,-1
800052c4:	5c 58       	castu.b	r8
800052c6:	b2 88       	st.b	r9[0x0],r8
800052c8:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
800052cc:	a9 a8       	sbr	r8,0x8
800052ce:	b8 38       	st.h	r12[0x6],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.destination)
800052d0:	8c 49       	ld.sh	r9,r6[0x8]
800052d2:	3f f8       	mov	r8,-1
800052d4:	f0 09 19 00 	cp.h	r9,r8
800052d8:	c0 41       	brne	800052e0 <xnl_tx+0x34>
	{		
		/*Use actual Master address.*/
		xnl->xnl_header.destination = xnl_information.master_address;
800052da:	4a 88       	lddpc	r8,80005378 <xnl_tx+0xcc>
800052dc:	90 18       	ld.sh	r8,r8[0x2]
800052de:	ac 48       	st.h	r6[0x8],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.source)
800052e0:	8c 59       	ld.sh	r9,r6[0xa]
800052e2:	3f f8       	mov	r8,-1
800052e4:	f0 09 19 00 	cp.h	r9,r8
800052e8:	c0 41       	brne	800052f0 <xnl_tx+0x44>
	{
		/*Use Temporary address.*/	
		xnl->xnl_header.source = xnl_information.device_address;
800052ea:	4a 48       	lddpc	r8,80005378 <xnl_tx+0xcc>
800052ec:	90 28       	ld.sh	r8,r8[0x4]
800052ee:	ac 58       	st.h	r6[0xa],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
800052f0:	8c 69       	ld.sh	r9,r6[0xc]
800052f2:	3f f8       	mov	r8,-1
800052f4:	f0 09 19 00 	cp.h	r9,r8
800052f8:	c0 e1       	brne	80005314 <xnl_tx+0x68>
	{		
		xnl->xnl_header.transaction_id = 
		  ((++xnl_information.transaction_id) & 0xFF) 
800052fa:	4a 08       	lddpc	r8,80005378 <xnl_tx+0xcc>
800052fc:	90 49       	ld.sh	r9,r8[0x8]
800052fe:	2f f9       	sub	r9,-1
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
80005300:	b0 49       	st.h	r8[0x8],r9
		  ((++xnl_information.transaction_id) & 0xFF) 
80005302:	90 4a       	ld.sh	r10,r8[0x8]
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
80005304:	90 49       	ld.sh	r9,r8[0x8]
80005306:	e0 19 ff 00 	andl	r9,0xff00
8000530a:	f1 da c0 08 	bfextu	r8,r10,0x0,0x8
8000530e:	f3 e8 10 08 	or	r8,r9,r8
80005312:	ac 68       	st.h	r6[0xc],r8
	U16  sumScratch;
	U32  indextohWord;
	S32  hWordswithinFrag;
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
80005314:	0d 98       	ld.ub	r8,r6[0x1]
80005316:	20 28       	sub	r8,2
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
80005318:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
8000531c:	10 0c       	add	r12,r8
8000531e:	a1 5c       	asr	r12,0x1
	indextohWord = 2;
	while (hWordswithinFrag > 0)
80005320:	58 0c       	cp.w	r12,0
80005322:	e0 89 00 04 	brgt	8000532a <xnl_tx+0x7e>
80005326:	30 09       	mov	r9,0
80005328:	c0 d8       	rjmp	80005342 <xnl_tx+0x96>
8000532a:	ec ca ff fc 	sub	r10,r6,-4
Parameters: xnl_fragment_t * 
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
8000532e:	2f ec       	sub	r12,-2
80005330:	30 09       	mov	r9,0
80005332:	30 28       	mov	r8,2
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
	{
		sumScratch += *((U16*)xnl + indextohWord);
80005334:	15 1b       	ld.sh	r11,r10++
80005336:	f6 09 00 09 	add	r9,r11,r9
8000533a:	5c 89       	casts.h	r9
		indextohWord     += 1;
8000533c:	2f f8       	sub	r8,-1
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
8000533e:	18 38       	cp.w	r8,r12
80005340:	cf a1       	brne	80005334 <xnl_tx+0x88>
		  ((++xnl_information.transaction_id) & 0xFF) 
		| (xnl_information.transaction_id & 0xFF00);
	}
	
	/*count check sum */
	xnl->phy_header.check_sum = check_sum( xnl );
80005342:	5c 39       	neg	r9
80005344:	ac 19       	st.h	r6[0x2],r9
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
80005346:	48 e8       	lddpc	r8,8000537c <xnl_tx+0xd0>
80005348:	70 0c       	ld.w	r12,r8[0x0]
8000534a:	f0 1f 00 0e 	mcall	80005380 <xnl_tx+0xd4>
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
8000534e:	c1 00       	breq	8000536e <xnl_tx+0xc2>
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
80005350:	fa c7 ff fc 	sub	r7,sp,-4
80005354:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
	{
		memcpy(ptr, xnl, sizeof(xnl_fragment_t));
80005356:	e0 6a 01 00 	mov	r10,256
8000535a:	0c 9b       	mov	r11,r6
8000535c:	f0 1f 00 0a 	mcall	80005384 <xnl_tx+0xd8>
	
		/*push to queue and send*/
		
		//log("ptr -%8x", ptr);
		
		xQueueSend(xnl_frame_tx, &ptr, 0);
80005360:	48 a8       	lddpc	r8,80005388 <xnl_tx+0xdc>
80005362:	70 0c       	ld.w	r12,r8[0x0]
80005364:	30 09       	mov	r9,0
80005366:	12 9a       	mov	r10,r9
80005368:	1a 9b       	mov	r11,sp
8000536a:	f0 1f 00 09 	mcall	8000538c <xnl_tx+0xe0>
		//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
		
		//vPortFree(ptr);
	}
}
8000536e:	2f fd       	sub	sp,-4
80005370:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005374:	00 00       	add	r0,r0
80005376:	10 6c       	and	r12,r8
80005378:	00 00       	add	r0,r0
8000537a:	10 50       	eor	r0,r8
8000537c:	00 00       	add	r0,r0
8000537e:	0f b8       	ld.ub	r8,r7[0x3]
80005380:	80 00       	ld.sh	r0,r0[0x0]
80005382:	40 b0       	lddsp	r0,sp[0x2c]
80005384:	80 00       	ld.sh	r0,r0[0x0]
80005386:	a4 6a       	st.h	r2[0xc],r10
80005388:	00 00       	add	r0,r0
8000538a:	10 60       	and	r0,r8
8000538c:	80 00       	ld.sh	r0,r0[0x0]
8000538e:	8e b4       	ld.uh	r4,r7[0x6]

80005390 <xnl_init>:
	xTaskCreate--freertos
	xnl_send_device_master_query
Called By:xcmp_init -- xcmp.c
*/
void xnl_init(void)
{
80005390:	eb cd 40 80 	pushm	r7,lr
80005394:	fa cd 01 00 	sub	sp,sp,256
	/*initialize the physical layer*/
	phy_init();
80005398:	f0 1f 00 27 	mcall	80005434 <xnl_init+0xa4>
	
	xnl_information.is_connected = FALSE;
8000539c:	30 09       	mov	r9,0
8000539e:	4a 78       	lddpc	r8,80005438 <xnl_init+0xa8>
800053a0:	b0 89       	st.b	r8[0x0],r9

	/*initialize the semaphore and queue*/
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
800053a2:	30 0b       	mov	r11,0
800053a4:	30 1c       	mov	r12,1
800053a6:	f0 1f 00 26 	mcall	8000543c <xnl_init+0xac>
800053aa:	4a 68       	lddpc	r8,80005440 <xnl_init+0xb0>
800053ac:	91 0c       	st.w	r8[0x0],r12
800053ae:	70 08       	ld.w	r8,r8[0x0]
800053b0:	58 08       	cp.w	r8,0
800053b2:	c0 80       	breq	800053c2 <xnl_init+0x32>
800053b4:	4a 38       	lddpc	r8,80005440 <xnl_init+0xb0>
800053b6:	70 0c       	ld.w	r12,r8[0x0]
800053b8:	30 09       	mov	r9,0
800053ba:	12 9a       	mov	r10,r9
800053bc:	12 9b       	mov	r11,r9
800053be:	f0 1f 00 22 	mcall	80005444 <xnl_init+0xb4>
	//xnl_frame_tx = xQueueCreate(10, sizeof(xnl_fragment_t *)); 
	
	xnl_frame_tx = xQueueCreate(20, sizeof(xnl_fragment_t *)); //xnl_frame_tx
800053c2:	30 4b       	mov	r11,4
800053c4:	31 4c       	mov	r12,20
800053c6:	f0 1f 00 1e 	mcall	8000543c <xnl_init+0xac>
800053ca:	4a 08       	lddpc	r8,80005448 <xnl_init+0xb8>
800053cc:	91 0c       	st.w	r8[0x0],r12
		
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
800053ce:	30 07       	mov	r7,0
800053d0:	1a d7       	st.w	--sp,r7
800053d2:	1a d7       	st.w	--sp,r7
800053d4:	1a d7       	st.w	--sp,r7
800053d6:	30 38       	mov	r8,3
800053d8:	0e 99       	mov	r9,r7
800053da:	e0 6a 02 00 	mov	r10,512
800053de:	49 cb       	lddpc	r11,8000544c <xnl_init+0xbc>
800053e0:	49 cc       	lddpc	r12,80005450 <xnl_init+0xc0>
800053e2:	f0 1f 00 1d 	mcall	80005454 <xnl_init+0xc4>
	,  tskXNL_PRIORITY //+ 1
	,  NULL
	);
	
	/*this task is used to send xnl message*/
	xTaskCreate(
800053e6:	1a d7       	st.w	--sp,r7
800053e8:	1a d7       	st.w	--sp,r7
800053ea:	1a d7       	st.w	--sp,r7
800053ec:	30 38       	mov	r8,3
800053ee:	0e 99       	mov	r9,r7
800053f0:	e0 6a 03 20 	mov	r10,800
800053f4:	49 9b       	lddpc	r11,80005458 <xnl_init+0xc8>
800053f6:	49 ac       	lddpc	r12,8000545c <xnl_init+0xcc>
800053f8:	f0 1f 00 17 	mcall	80005454 <xnl_init+0xc4>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
800053fc:	e0 68 40 0e 	mov	r8,16398
80005400:	fb 58 00 18 	st.h	sp[24],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80005404:	3f f8       	mov	r8,-1
80005406:	fb 58 00 1a 	st.h	sp[26],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_MASTER_QUERY;
8000540a:	30 38       	mov	r8,3
8000540c:	fb 58 00 1c 	st.h	sp[28],r8
	
	/*The initial value*/
	xnl_frame.xnl_header.flags = 0;
80005410:	fb 57 00 1e 	st.h	sp[30],r7
	
	/*XNL address of the master device, if known;otherwise 0x0000*/
	xnl_frame.xnl_header.destination = 0;
80005414:	fb 57 00 20 	st.h	sp[32],r7
	
	/*XNL address, if assigned; otherwise 0x0000*/
	xnl_frame.xnl_header.source = 0;
80005418:	fb 57 00 22 	st.h	sp[34],r7
	
	/*No transaction ID required for this message*/
	xnl_frame.xnl_header.transaction_id = 0;
8000541c:	fb 57 00 24 	st.h	sp[36],r7
	
	/*This message contains no payload*/
	xnl_frame.xnl_header.payload_length = 0;
80005420:	fb 57 00 26 	st.h	sp[38],r7

	/*send XNL message*/
	xnl_tx(&xnl_frame);
80005424:	fa cc ff e8 	sub	r12,sp,-24
80005428:	f0 1f 00 0e 	mcall	80005460 <xnl_init+0xd0>
8000542c:	2f ad       	sub	sp,-24
	,  NULL
	);
	
	/*send device_master_query to connect radio*/	
	xnl_send_device_master_query();
}
8000542e:	2c 0d       	sub	sp,-256
80005430:	e3 cd 80 80 	ldm	sp++,r7,pc
80005434:	80 00       	ld.sh	r0,r0[0x0]
80005436:	40 d8       	lddsp	r8,sp[0x34]
80005438:	00 00       	add	r0,r0
8000543a:	10 50       	eor	r0,r8
8000543c:	80 00       	ld.sh	r0,r0[0x0]
8000543e:	90 0c       	ld.sh	r12,r8[0x0]
80005440:	00 00       	add	r0,r0
80005442:	10 4c       	or	r12,r8
80005444:	80 00       	ld.sh	r0,r0[0x0]
80005446:	8e b4       	ld.uh	r4,r7[0x6]
80005448:	00 00       	add	r0,r0
8000544a:	10 60       	and	r0,r8
8000544c:	80 01       	ld.sh	r1,r0[0x0]
8000544e:	8a 84       	ld.uh	r4,r5[0x0]
80005450:	80 00       	ld.sh	r0,r0[0x0]
80005452:	52 4c       	stdsp	sp[0x90],r12
80005454:	80 00       	ld.sh	r0,r0[0x0]
80005456:	96 e0       	ld.uh	r0,r11[0xc]
80005458:	80 00       	ld.sh	r0,r0[0x0]
8000545a:	fe 00       	*unknown*
8000545c:	80 00       	ld.sh	r0,r0[0x0]
8000545e:	51 84       	stdsp	sp[0x60],r4
80005460:	80 00       	ld.sh	r0,r0[0x0]
80005462:	52 ac       	stdsp	sp[0xa8],r12

80005464 <xnl_data_msg_func>:
Description: process while receive data message.
Calls:xnl_send_msg_ack, xcmp_exec(function in xcmp)
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_data_msg_func(xnl_fragment_t * xnl)
{
80005464:	eb cd 40 80 	pushm	r7,lr
80005468:	fa cd 01 00 	sub	sp,sp,256
8000546c:	18 97       	mov	r7,r12
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
8000546e:	e0 68 40 0e 	mov	r8,16398
80005472:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80005474:	3f f8       	mov	r8,-1
80005476:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG_ACK;
80005478:	30 c8       	mov	r8,12
8000547a:	ba 28       	st.h	sp[0x4],r8
	
	/*Turn around Flags.*/	
	xnl_frame.xnl_header.flags = hdr->flags;
8000547c:	98 38       	ld.sh	r8,r12[0x6]
8000547e:	ba 38       	st.h	sp[0x6],r8
	
	/*ACK Destination Address is Source of XNL_Message.*/
	xnl_frame.xnl_header.destination = hdr->source;
80005480:	98 58       	ld.sh	r8,r12[0xa]
80005482:	ba 48       	st.h	sp[0x8],r8
	
	/*ACK Source Address is my address.*/
	xnl_frame.xnl_header.source = hdr->destination;
80005484:	98 48       	ld.sh	r8,r12[0x8]
80005486:	ba 58       	st.h	sp[0xa],r8
	
	/*Turn around Transaction ID.*/
	xnl_frame.xnl_header.transaction_id = hdr->transaction_id;
80005488:	98 68       	ld.sh	r8,r12[0xc]
8000548a:	ba 68       	st.h	sp[0xc],r8
	xnl_frame.xnl_header.payload_length = 0;
8000548c:	30 08       	mov	r8,0
8000548e:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
80005490:	1a 9c       	mov	r12,sp
80005492:	f0 1f 00 0a 	mcall	800054b8 <xnl_data_msg_func+0x54>
	transmitter, but possibly is waiting in Queue with immediate timeout.
	 */
	xnl_send_msg_ack(&xnl->xnl_header);
	
	/*exec xcmp function*/
	xcmp_exec(xnl->xnl_payload.xnl_content_data_msg);//xcmp_rx
80005496:	fa cd 00 cc 	sub	sp,sp,204
8000549a:	e0 6a 00 ca 	mov	r10,202
8000549e:	ee cb ff f0 	sub	r11,r7,-16
800054a2:	1a 9c       	mov	r12,sp
800054a4:	f0 1f 00 06 	mcall	800054bc <xnl_data_msg_func+0x58>
800054a8:	48 68       	lddpc	r8,800054c0 <xnl_data_msg_func+0x5c>
800054aa:	70 08       	ld.w	r8,r8[0x0]
800054ac:	5d 18       	icall	r8
800054ae:	fa cd ff 34 	sub	sp,sp,-204
}
800054b2:	2c 0d       	sub	sp,-256
800054b4:	e3 cd 80 80 	ldm	sp++,r7,pc
800054b8:	80 00       	ld.sh	r0,r0[0x0]
800054ba:	52 ac       	stdsp	sp[0xa8],r12
800054bc:	80 00       	ld.sh	r0,r0[0x0]
800054be:	a4 6a       	st.h	r2[0xc],r10
800054c0:	00 00       	add	r0,r0
800054c2:	10 70       	tst	r0,r8

800054c4 <xnl_device_auth_reply_func>:
Description: process while receive device auth reply.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_auth_reply_func(xnl_fragment_t * xnl)
{
800054c4:	d4 21       	pushm	r4-r7,lr
800054c6:	fa cd 01 00 	sub	sp,sp,256
800054ca:	18 97       	mov	r7,r12
	the receiving device and will be used to authenticate the connection 
	request. 5.4.4
	*/
	//log("R_xnl-opcode:%4x", xnl->xnl_header.opcode);
	
	if(xnl_information.is_connected)
800054cc:	4c 28       	lddpc	r8,800055d4 <xnl_device_auth_reply_func+0x110>
800054ce:	11 88       	ld.ub	r8,r8[0x0]
800054d0:	58 08       	cp.w	r8,0
800054d2:	c7 e1       	brne	800055ce <xnl_device_auth_reply_func+0x10a>
	{
		return;		
	}
	
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);
800054d4:	4c 18       	lddpc	r8,800055d8 <xnl_device_auth_reply_func+0x114>
800054d6:	70 0c       	ld.w	r12,r8[0x0]
800054d8:	30 09       	mov	r9,0
800054da:	12 9a       	mov	r10,r9
800054dc:	12 9b       	mov	r11,r9
800054de:	f0 1f 00 40 	mcall	800055dc <xnl_device_auth_reply_func+0x118>

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
800054e2:	ef 09 00 10 	ld.sh	r9,r7[16]
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
800054e6:	4b c8       	lddpc	r8,800055d4 <xnl_device_auth_reply_func+0x110>
800054e8:	b0 29       	st.h	r8[0x4],r9
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
	
	/*Get Array of values to be encrypted into an aligned 2X32bits.*/
	v_vector[0] =
800054ea:	ef 39 00 12 	ld.ub	r9,r7[18]
800054ee:	ef 38 00 13 	ld.ub	r8,r7[19]
800054f2:	b1 68       	lsl	r8,0x10
800054f4:	f1 e9 11 89 	or	r9,r8,r9<<0x18
800054f8:	ef 38 00 15 	ld.ub	r8,r7[21]
800054fc:	f3 e8 10 08 	or	r8,r9,r8
80005500:	ef 39 00 14 	ld.ub	r9,r7[20]
80005504:	f1 e9 10 89 	or	r9,r8,r9<<0x8
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[2])<<8	  
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[3]);
	
	v_vector[1] =
80005508:	ef 3a 00 16 	ld.ub	r10,r7[22]
8000550c:	ef 38 00 17 	ld.ub	r8,r7[23]
80005510:	b1 68       	lsl	r8,0x10
80005512:	f1 ea 11 8a 	or	r10,r8,r10<<0x18
80005516:	ef 38 00 19 	ld.ub	r8,r7[25]
8000551a:	f5 e8 10 08 	or	r8,r10,r8
8000551e:	ef 3a 00 18 	ld.ub	r10,r7[24]
80005522:	f1 ea 10 88 	or	r8,r8,r10<<0x8
80005526:	30 0a       	mov	r10,0
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
80005528:	e0 64 79 b9 	mov	r4,31161
8000552c:	ea 14 9e 37 	orh	r4,0x9e37
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
80005530:	e0 65 45 07 	mov	r5,17671
80005534:	ea 15 8a bd 	orh	r5,0x8abd
80005538:	e0 66 f9 3d 	mov	r6,63805
8000553c:	ea 16 99 68 	orh	r6,0x9968
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
80005540:	e0 6e b8 cf 	mov	lr,47311
80005544:	ea 1e 36 83 	orh	lr,0x3683
80005548:	e0 67 aa 1c 	mov	r7,43548
8000554c:	ea 17 9c 36 	orh	r7,0x9c36
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
80005550:	08 0a       	add	r10,r4
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
80005552:	f4 08 00 0c 	add	r12,r10,r8
80005556:	f0 0b 15 04 	lsl	r11,r8,0x4
8000555a:	0a 0b       	add	r11,r5
8000555c:	f9 eb 20 0b 	eor	r11,r12,r11
80005560:	f0 0c 16 05 	lsr	r12,r8,0x5
80005564:	0c 0c       	add	r12,r6
80005566:	18 5b       	eor	r11,r12
80005568:	16 09       	add	r9,r11
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
8000556a:	f2 0c 15 04 	lsl	r12,r9,0x4
8000556e:	1c 0c       	add	r12,lr
80005570:	f2 0b 16 05 	lsr	r11,r9,0x5
80005574:	0e 0b       	add	r11,r7
80005576:	f9 eb 20 0b 	eor	r11,r12,r11
8000557a:	f2 0a 00 0c 	add	r12,r9,r10
8000557e:	18 5b       	eor	r11,r12
80005580:	16 08       	add	r8,r11
{
	register U32 y=v[0], z=v[1], sum=0;
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
80005582:	e0 6b 37 20 	mov	r11,14112
80005586:	ea 1b c6 ef 	orh	r11,0xc6ef
8000558a:	16 3a       	cp.w	r10,r11
8000558c:	ce 21       	brne	80005550 <xnl_device_auth_reply_func+0x8c>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :24 + 2(xnl length(24) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 24 + 2;
8000558e:	e0 6a 40 1a 	mov	r10,16410
80005592:	ba 0a       	st.h	sp[0x0],r10
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80005594:	3f fa       	mov	r10,-1
80005596:	ba 1a       	st.h	sp[0x2],r10
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_CONN_REQUEST;
80005598:	30 6b       	mov	r11,6
8000559a:	ba 2b       	st.h	sp[0x4],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
8000559c:	ba 3a       	st.h	sp[0x6],r10
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
8000559e:	48 eb       	lddpc	r11,800055d4 <xnl_device_auth_reply_func+0x110>
800055a0:	96 1c       	ld.sh	r12,r11[0x2]
800055a2:	ba 4c       	st.h	sp[0x8],r12
	message here, and all will receive the same DEVICE_CONN_REPLY. Not real 
	sure what's going to happen with multiple conrol heads, etc. One suspects 
	the Rocket Scientists will eventually figure this out, and demand a 
	transaction ID based on Device Type in the XNL_DEVICE_AUTH_KEY_REQUEST.
	*/
	xnl_frame.xnl_header.source = xnl_information.device_address;
800055a4:	96 2b       	ld.sh	r11,r11[0x4]
800055a6:	ba 5b       	st.h	sp[0xa],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
800055a8:	ba 6a       	st.h	sp[0xc],r10
	
    /*his message contains 12 payload bytes*/	
	xnl_frame.xnl_header.payload_length = 0x000C;
800055aa:	30 ca       	mov	r10,12
800055ac:	ba 7a       	st.h	sp[0xe],r10
	
	/*No Preferred XNL Address*/
	xnl_frame.xnl_payload.xnl_content_device_conn_req.preferred_xnl_address = 
800055ae:	30 0a       	mov	r10,0
800055b0:	fb 5a 00 10 	st.h	sp[16],r10
	XCMP/XNL Development Specification Section 4.5.3.2.1.
	Same as in MOTOTRBO?XCMP/XNL Development Specification?
	evice_type--Option Board(0x07)
	authentication_index--Option Board(0x02)
	*/	
	xnl_frame.xnl_payload.xnl_content_device_conn_req.device_type = 0x07;
800055b4:	30 7a       	mov	r10,7
800055b6:	fb 6a 00 12 	st.b	sp[18],r10
	xnl_frame.xnl_payload.xnl_content_device_conn_req.authentication_index =
800055ba:	30 2a       	mov	r10,2
800055bc:	fb 6a 00 13 	st.b	sp[19],r10
	                                                                       0x02;
		
	//We know encrypted array happens to be aligned to 32-bit boundary.
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
800055c0:	fa ca ff ec 	sub	r10,sp,-20
800055c4:	95 09       	st.w	r10[0x0],r9
	                         .encrypted_authentication_value[0])) = w_vector[0];
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
800055c6:	95 18       	st.w	r10[0x4],r8
	                         .encrypted_authentication_value[4])) = w_vector[1];
	
	/*send XNL message*/
	xnl_tx(&xnl_frame);
800055c8:	1a 9c       	mov	r12,sp
800055ca:	f0 1f 00 06 	mcall	800055e0 <xnl_device_auth_reply_func+0x11c>
}
800055ce:	2c 0d       	sub	sp,-256
800055d0:	d8 22       	popm	r4-r7,pc
800055d2:	00 00       	add	r0,r0
800055d4:	00 00       	add	r0,r0
800055d6:	10 50       	eor	r0,r8
800055d8:	00 00       	add	r0,r0
800055da:	10 4c       	or	r12,r8
800055dc:	80 00       	ld.sh	r0,r0[0x0]
800055de:	8e b4       	ld.uh	r4,r7[0x6]
800055e0:	80 00       	ld.sh	r0,r0[0x0]
800055e2:	52 ac       	stdsp	sp[0xa8],r12

800055e4 <xnl_master_status_brdcst_func>:
Description: process while receive master status boardcast.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_master_status_brdcst_func(xnl_fragment_t * xnl)
{	
800055e4:	eb cd 40 80 	pushm	r7,lr
800055e8:	fa cd 01 00 	sub	sp,sp,256
800055ec:	18 97       	mov	r7,r12
	not an XNL_DATA_MSG has been sent out. This will indicate to a connecting 
	device that it has missed messages. The XNL header will contain the 
	master?XNL address. 5.4.1
	*/
	
	if(xnl_information.is_connected)
800055ee:	49 28       	lddpc	r8,80005634 <xnl_master_status_brdcst_func+0x50>
800055f0:	11 88       	ld.ub	r8,r8[0x0]
800055f2:	58 08       	cp.w	r8,0
800055f4:	c1 c1       	brne	8000562c <xnl_master_status_brdcst_func+0x48>
	{
		return;	
	}
		
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);	
800055f6:	49 18       	lddpc	r8,80005638 <xnl_master_status_brdcst_func+0x54>
800055f8:	70 0c       	ld.w	r12,r8[0x0]
800055fa:	30 09       	mov	r9,0
800055fc:	12 9a       	mov	r10,r9
800055fe:	12 9b       	mov	r11,r9
80005600:	f0 1f 00 0f 	mcall	8000563c <xnl_master_status_brdcst_func+0x58>

	//log("xnl-ma:%4x", xnl->xnl_header.source);
	/*get the master adderss from this message*/	
	xnl_information.master_address = xnl->xnl_header.source;	
80005604:	8e 58       	ld.sh	r8,r7[0xa]
80005606:	48 c9       	lddpc	r9,80005634 <xnl_master_status_brdcst_func+0x50>
80005608:	b2 18       	st.h	r9[0x2],r8
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
8000560a:	e0 68 40 0e 	mov	r8,16398
8000560e:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80005610:	3f f8       	mov	r8,-1
80005612:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_AUTH_KEY_REQUEST;
80005614:	30 4a       	mov	r10,4
80005616:	ba 2a       	st.h	sp[0x4],r10
		
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/	
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
80005618:	ba 38       	st.h	sp[0x6],r8
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
8000561a:	92 19       	ld.sh	r9,r9[0x2]
8000561c:	ba 49       	st.h	sp[0x8],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.source = DEFAULT_VALUE;
8000561e:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80005620:	ba 68       	st.h	sp[0xc],r8
		
	xnl_frame.xnl_header.payload_length = 0;
80005622:	30 08       	mov	r8,0
80005624:	ba 78       	st.h	sp[0xe],r8
	
	/*send XNL message*/	
	xnl_tx(&xnl_frame);
80005626:	1a 9c       	mov	r12,sp
80005628:	f0 1f 00 06 	mcall	80005640 <xnl_master_status_brdcst_func+0x5c>
}
8000562c:	2c 0d       	sub	sp,-256
8000562e:	e3 cd 80 80 	ldm	sp++,r7,pc
80005632:	00 00       	add	r0,r0
80005634:	00 00       	add	r0,r0
80005636:	10 50       	eor	r0,r8
80005638:	00 00       	add	r0,r0
8000563a:	10 4c       	or	r12,r8
8000563c:	80 00       	ld.sh	r0,r0[0x0]
8000563e:	8e b4       	ld.uh	r4,r7[0x6]
80005640:	80 00       	ld.sh	r0,r0[0x0]
80005642:	52 ac       	stdsp	sp[0xa8],r12

80005644 <xnl_device_conn_reply_func>:
Description: process while receive device conn reply.
Calls:xSemaphoreGive--freestos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_conn_reply_func(xnl_fragment_t * xnl)
{
80005644:	eb cd 40 80 	pushm	r7,lr
80005648:	18 97       	mov	r7,r12
	transaction ID and an 8-byte encrypted value that the device can use to 
	authenticate the master. XCMP/XNL Development Guide 5.4.6
	*/
	
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);
8000564a:	49 38       	lddpc	r8,80005694 <xnl_device_conn_reply_func+0x50>
8000564c:	70 0c       	ld.w	r12,r8[0x0]
8000564e:	30 09       	mov	r9,0
80005650:	12 9a       	mov	r10,r9
80005652:	12 9b       	mov	r11,r9
80005654:	f0 1f 00 11 	mcall	80005698 <xnl_device_conn_reply_func+0x54>

	/*Test result code*/
	if((xnl->xnl_payload.xnl_content_device_conn_reply.result_base & 0x0000FF00)
80005658:	ef 18 00 10 	ld.uh	r8,r7[16]
8000565c:	10 99       	mov	r9,r8
8000565e:	e2 19 ff 00 	andl	r9,0xff00,COH
80005662:	e0 49 01 00 	cp.w	r9,256
80005666:	c0 60       	breq	80005672 <xnl_device_conn_reply_func+0x2e>
		/*
		Rejected. The device must retry the authentication process at this 
		point by sending out a new AUTH_KEY_REQUEST message. XCMP/XNL 
		Development Guide Section 5.2.3
		*/
		xnl_master_status_brdcst_func(xnl);			
80005668:	0e 9c       	mov	r12,r7
8000566a:	f0 1f 00 0d 	mcall	8000569c <xnl_device_conn_reply_func+0x58>
8000566e:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/*connection accepted*/		
		/*Record Transaction ID Base*/
		xnl_information.transaction_id =  
80005672:	a9 68       	lsl	r8,0x8
80005674:	48 b9       	lddpc	r9,800056a0 <xnl_device_conn_reply_func+0x5c>
80005676:	b2 48       	st.h	r9[0x8],r8
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
80005678:	ef 08 00 14 	ld.sh	r8,r7[20]
		xnl_information.transaction_id =  
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
8000567c:	b2 38       	st.h	r9[0x6],r8
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
8000567e:	ef 08 00 12 	ld.sh	r8,r7[18]
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
80005682:	b2 28       	st.h	r9[0x4],r8
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
		
		/*connect finish*/
		xnl_information.is_connected = TRUE;
80005684:	30 18       	mov	r8,1
80005686:	b2 88       	st.b	r9[0x0],r8
		
		log("connected finish");
80005688:	48 7c       	lddpc	r12,800056a4 <xnl_device_conn_reply_func+0x60>
8000568a:	f0 1f 00 08 	mcall	800056a8 <xnl_device_conn_reply_func+0x64>
8000568e:	e3 cd 80 80 	ldm	sp++,r7,pc
80005692:	00 00       	add	r0,r0
80005694:	00 00       	add	r0,r0
80005696:	10 4c       	or	r12,r8
80005698:	80 00       	ld.sh	r0,r0[0x0]
8000569a:	8e b4       	ld.uh	r4,r7[0x6]
8000569c:	80 00       	ld.sh	r0,r0[0x0]
8000569e:	55 e4       	stdsp	sp[0x178],r4
800056a0:	00 00       	add	r0,r0
800056a2:	10 50       	eor	r0,r8
800056a4:	80 01       	ld.sh	r1,r0[0x0]
800056a6:	8a 8c       	ld.uh	r12,r5[0x0]
800056a8:	80 00       	ld.sh	r0,r0[0x0]
800056aa:	9a a4       	ld.uh	r4,sp[0x4]

800056ac <local_start_pll0>:
	//pm_switch_to_osc0(pm, 12000000, 3);
	//    pm_enable_osc0_crystal(pm, 12000000);
	//         pm_set_osc0_mode(pm,AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);  0x00000007
	//    pm_enable_clk0(pm, 3);
	//         pm_enable_clk0_no_wait(pm, 3);
	(&AVR32_PM)->oscctrl0 = 0x00000307;
800056ac:	fe 78 0c 00 	mov	r8,-62464
800056b0:	e0 69 03 07 	mov	r9,775
800056b4:	91 a9       	st.w	r8[0x28],r9
	(&AVR32_PM)->mcctrl   = 0x00000004;
800056b6:	30 49       	mov	r9,4
800056b8:	91 09       	st.w	r8[0x0],r9
	//         pm_wait_for_clk0_ready(pm);
	while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
800056ba:	71 59       	ld.w	r9,r8[0x54]
800056bc:	e2 19 00 80 	andl	r9,0x80,COH
800056c0:	cf d0       	breq	800056ba <local_start_pll0+0xe>
	//    pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);
	(&AVR32_PM)->mcctrl   = 0x00000005;
800056c2:	fe 78 0c 00 	mov	r8,-62464
800056c6:	30 59       	mov	r9,5
800056c8:	91 09       	st.w	r8[0x0],r9
	//pm_pll_set_option(pm, 0, //PLL number 0
	//                        1, //freq Set to 1 for VCO frequency range 80-180MHz
	//                        1, //div2 Divide the PLL output frequency by 2
	//                        0);//0 to enable the Wide-Bandith Mode
	//pm_pll_enable(pm,0);
	(&AVR32_PM)->pll[0] = 0x1007010D;
800056ca:	e0 69 01 0d 	mov	r9,269
800056ce:	ea 19 10 07 	orh	r9,0x1007
800056d2:	91 89       	st.w	r8[0x20],r9


	//pm_wait_for_pll0_locked(pm);
	while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_LOCK0_MASK));
800056d4:	71 59       	ld.w	r9,r8[0x54]
800056d6:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
800056da:	cf d0       	breq	800056d4 <local_start_pll0+0x28>
	//             0,  //Bus A select = 0 (PBA clock = 48MHz/2 = 24MHz).
	//             0,  //B clock divisor enable = 0
	//             0,  //Bus B select = 0
	//             0,  //HS Bus clock divisor enable = 0
	//             0); //HS Bus select = 0
	(&AVR32_PM)->cksel = 0x00800000;
800056dc:	fe 78 0c 00 	mov	r8,-62464
800056e0:	fc 19 00 80 	movh	r9,0x80
800056e4:	91 19       	st.w	r8[0x4],r9

	//flashc_set_wait_state(1);
	AVR32_FLASHC.fcr = 0x00000040;
800056e6:	34 0a       	mov	r10,64
800056e8:	fe 69 14 00 	mov	r9,-125952
800056ec:	93 0a       	st.w	r9[0x0],r10

	//pm_switch_to_clock(pm, AVR32_PM_MCSEL_PLL0);
	(&AVR32_PM)->mcctrl   = 0x00000006;
800056ee:	30 69       	mov	r9,6
800056f0:	91 09       	st.w	r8[0x0],r9


	AVR32_HMATRIX.mcfg[AVR32_HMATRIX_MASTER_CPU_INSTRUCTION] = 0x1;
800056f2:	30 19       	mov	r9,1
800056f4:	fe 68 10 00 	mov	r8,-126976
800056f8:	91 19       	st.w	r8[0x4],r9
}
800056fa:	5e fc       	retal	r12

800056fc <read_a_byte>:
*/
U32 read_a_byte(U32 subaddress, S8 *datareceived)
{
	U32 TWI_Status = 0;

	AVR32_TWI.cr   =  AVR32_TWI_CR_MSEN_MASK | AVR32_TWI_CR_SVDIS_MASK;
800056fc:	fe 78 2c 00 	mov	r8,-54272
80005700:	32 49       	mov	r9,36
80005702:	91 09       	st.w	r8[0x0],r9
	AVR32_TWI.mmr  =  PCF8563_ADDRESS        << AVR32_TWI_MMR_DADR_OFFSET   |
80005704:	e0 69 11 00 	mov	r9,4352
80005708:	ea 19 00 51 	orh	r9,0x51
8000570c:	91 19       	st.w	r8[0x4],r9
	PCF8563_ADDR_LGT		<< AVR32_TWI_MMR_IADRSZ_OFFSET |
	1					<< AVR32_TWI_MMR_MREAD_OFFSET;
	AVR32_TWI.iadr =  subaddress;
8000570e:	91 3c       	st.w	r8[0xc],r12

	AVR32_TWI.cr   =  AVR32_TWI_START_MASK | AVR32_TWI_STOP_MASK;
80005710:	30 39       	mov	r9,3
80005712:	91 09       	st.w	r8[0x0],r9

	do
	{
		TWI_Status =  AVR32_TWI.sr & 0x00000102;
80005714:	70 8c       	ld.w	r12,r8[0x20]
80005716:	e2 1c 01 02 	andl	r12,0x102,COH
	}
	while (TWI_Status == 0);
8000571a:	cf d0       	breq	80005714 <read_a_byte+0x18>

	if (!(TWI_Status & 0x00000100))
8000571c:	18 98       	mov	r8,r12
8000571e:	e2 18 01 00 	andl	r8,0x100,COH
80005722:	c0 51       	brne	8000572c <read_a_byte+0x30>
	{
		*datareceived = AVR32_TWI.rhr;
80005724:	fe 78 2c 00 	mov	r8,-54272
80005728:	70 c8       	ld.w	r8,r8[0x30]
8000572a:	b6 88       	st.b	r11[0x0],r8
	}
	while ((AVR32_TWI.sr & 0x00000001) == 0x00000000); //Wait for complete.
8000572c:	fe 78 2c 00 	mov	r8,-54272
80005730:	70 89       	ld.w	r9,r8[0x20]
80005732:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
80005736:	cf d0       	breq	80005730 <read_a_byte+0x34>
	return (TWI_Status);
}
80005738:	5e fc       	retal	r12
8000573a:	d7 03       	nop

8000573c <rtc_read_time>:
Calls: 
    my_writeabyte
Return:rtc_err_t
*/
rtc_err_t rtc_read_time(date_time_t * t)
{	
8000573c:	eb cd 40 e0 	pushm	r5-r7,lr
80005740:	20 2d       	sub	sp,8
80005742:	18 97       	mov	r7,r12
	if(NULL != rtc_mutex)
80005744:	4c 28       	lddpc	r8,8000584c <rtc_read_time+0x110>
80005746:	70 08       	ld.w	r8,r8[0x0]
80005748:	58 08       	cp.w	r8,0
8000574a:	c0 31       	brne	80005750 <rtc_read_time+0x14>
8000574c:	30 3c       	mov	r12,3
8000574e:	c7 b8       	rjmp	80005844 <rtc_read_time+0x108>
	{
		/*See if we can obtain the semaphore. If the semaphore is not available wait aways to see if it becomes free*/
		xSemaphoreTake( rtc_mutex, portMAX_DELAY);
80005750:	4b f6       	lddpc	r6,8000584c <rtc_read_time+0x110>
80005752:	6c 0c       	ld.w	r12,r6[0x0]
80005754:	30 09       	mov	r9,0
80005756:	3f fa       	mov	r10,-1
80005758:	12 9b       	mov	r11,r9
8000575a:	f0 1f 00 3e 	mcall	80005850 <rtc_read_time+0x114>
	int RTC_Status;
	
	unsigned char time[8];
	
	/*read second*/
	res = read_a_byte(0x02, &time[0]);	
8000575e:	1a 9b       	mov	r11,sp
80005760:	30 2c       	mov	r12,2
80005762:	f0 1f 00 3d 	mcall	80005854 <rtc_read_time+0x118>
	t->second = ((time[0] & 0x7F) >> 4) * 10 + (time[0] & 0x0F);
80005766:	1b 88       	ld.ub	r8,sp[0x0]
80005768:	f3 d8 c0 83 	bfextu	r9,r8,0x4,0x3
8000576c:	f2 09 00 29 	add	r9,r9,r9<<0x2
80005770:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
80005774:	f0 09 00 19 	add	r9,r8,r9<<0x1
80005778:	ae f9       	st.b	r7[0x7],r9
	
	/*read minute*/
	res = read_a_byte(0x03, &time[1]);
8000577a:	fa cb ff ff 	sub	r11,sp,-1
8000577e:	30 3c       	mov	r12,3
80005780:	f0 1f 00 35 	mcall	80005854 <rtc_read_time+0x118>
	t->minute = ((time[1] & 0x7F) >> 4) * 10 + (time[1] & 0x0F);
80005784:	1b 98       	ld.ub	r8,sp[0x1]
80005786:	f3 d8 c0 83 	bfextu	r9,r8,0x4,0x3
8000578a:	f2 09 00 29 	add	r9,r9,r9<<0x2
8000578e:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
80005792:	f0 09 00 19 	add	r9,r8,r9<<0x1
80005796:	ae e9       	st.b	r7[0x6],r9
	
	/*read hour*/
	res = read_a_byte(0x04, &time[2]);
80005798:	fa cb ff fe 	sub	r11,sp,-2
8000579c:	30 4c       	mov	r12,4
8000579e:	f0 1f 00 2e 	mcall	80005854 <rtc_read_time+0x118>
	t->hour = ((time[2] & 0x3F) >> 4) * 10 + (time[2] & 0x0F);
800057a2:	1b a8       	ld.ub	r8,sp[0x2]
800057a4:	f3 d8 c0 82 	bfextu	r9,r8,0x4,0x2
800057a8:	f2 09 00 29 	add	r9,r9,r9<<0x2
800057ac:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
800057b0:	f0 09 00 19 	add	r9,r8,r9<<0x1
800057b4:	ae d9       	st.b	r7[0x5],r9
	
	/*read day*/
	res = read_a_byte(0x05, &time[3]);
800057b6:	fa cb ff fd 	sub	r11,sp,-3
800057ba:	30 5c       	mov	r12,5
800057bc:	f0 1f 00 26 	mcall	80005854 <rtc_read_time+0x118>
	t->day = ((time[3] & 0x3F) >> 4) * 10 + (time[3] & 0x0F);
800057c0:	1b b8       	ld.ub	r8,sp[0x3]
800057c2:	f3 d8 c0 82 	bfextu	r9,r8,0x4,0x2
800057c6:	f2 09 00 29 	add	r9,r9,r9<<0x2
800057ca:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
800057ce:	f0 09 00 19 	add	r9,r8,r9<<0x1
800057d2:	ae b9       	st.b	r7[0x3],r9
	
	/*read week*/
	res = read_a_byte(0x06, &time[4]);
800057d4:	fa cb ff fc 	sub	r11,sp,-4
800057d8:	30 6c       	mov	r12,6
800057da:	f0 1f 00 1f 	mcall	80005854 <rtc_read_time+0x118>
	t->week = (time[4] & 0x0F);
800057de:	1b c8       	ld.ub	r8,sp[0x4]
800057e0:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
800057e4:	ae c8       	st.b	r7[0x4],r8
	
	/*read month*/
	res = read_a_byte(0x07, &time[5]);
800057e6:	fa cb ff fb 	sub	r11,sp,-5
800057ea:	30 7c       	mov	r12,7
800057ec:	f0 1f 00 1a 	mcall	80005854 <rtc_read_time+0x118>
	t->month = ((time[5] & 0x1F) >> 4) * 10 + (time[5] & 0x0F);
800057f0:	1b d8       	ld.ub	r8,sp[0x5]
800057f2:	f3 d8 c0 81 	bfextu	r9,r8,0x4,0x1
800057f6:	f2 0a 15 02 	lsl	r10,r9,0x2
800057fa:	14 09       	add	r9,r10
800057fc:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
80005800:	f0 09 00 18 	add	r8,r8,r9<<0x1
80005804:	ae a8       	st.b	r7[0x2],r8
	
	/*read year*/
	res = read_a_byte(0x08, &time[6]);
80005806:	fa cb ff fa 	sub	r11,sp,-6
8000580a:	30 8c       	mov	r12,8
8000580c:	f0 1f 00 12 	mcall	80005854 <rtc_read_time+0x118>
80005810:	18 95       	mov	r5,r12
	t->year = ((time[6] & 0xFF) >> 4) * 10 + (time[6] & 0x0F) + 2000;
80005812:	1b e9       	ld.ub	r9,sp[0x6]
80005814:	f1 d9 c0 04 	bfextu	r8,r9,0x0,0x4
80005818:	f0 c8 f8 30 	sub	r8,r8,-2000
8000581c:	a5 89       	lsr	r9,0x4
8000581e:	f2 09 10 0a 	mul	r9,r9,10
80005822:	12 08       	add	r8,r9
80005824:	5c 78       	castu.h	r8
80005826:	30 0b       	mov	r11,0
80005828:	f0 09 16 08 	lsr	r9,r8,0x8
8000582c:	ae 89       	st.b	r7[0x0],r9
8000582e:	ae 98       	st.b	r7[0x1],r8
	
	/*finished accessing the shared resource.Release the semaphore.*/	
	xSemaphoreGive(rtc_mutex);	
80005830:	6c 0c       	ld.w	r12,r6[0x0]
80005832:	16 99       	mov	r9,r11
80005834:	16 9a       	mov	r10,r11
80005836:	f0 1f 00 09 	mcall	80005858 <rtc_read_time+0x11c>
		
	if(res)
8000583a:	58 05       	cp.w	r5,0
8000583c:	f9 bc 01 00 	movne	r12,0
80005840:	f9 bc 00 02 	moveq	r12,2
	{
		return rtc_success;
	}

	return rtc_write_err;
}
80005844:	2f ed       	sub	sp,-8
80005846:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000584a:	00 00       	add	r0,r0
8000584c:	00 00       	add	r0,r0
8000584e:	10 80       	andn	r0,r8
80005850:	80 00       	ld.sh	r0,r0[0x0]
80005852:	8c a8       	ld.uh	r8,r6[0x4]
80005854:	80 00       	ld.sh	r0,r0[0x0]
80005856:	56 fc       	stdsp	sp[0x1bc],r12
80005858:	80 00       	ld.sh	r0,r0[0x0]
8000585a:	8e b4       	ld.uh	r4,r7[0x6]

8000585c <getTime>:
Description: define now
Calls:
Return:date_time_t *
*/
date_time_t * getTime(void)
{
8000585c:	eb cd 40 80 	pushm	r7,lr
	rtc_read_time(&date_time);
80005860:	48 47       	lddpc	r7,80005870 <getTime+0x14>
80005862:	0e 9c       	mov	r12,r7
80005864:	f0 1f 00 04 	mcall	80005874 <getTime+0x18>
	return &date_time;
80005868:	0e 9c       	mov	r12,r7
8000586a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000586e:	00 00       	add	r0,r0
80005870:	00 00       	add	r0,r0
80005872:	10 78       	tst	r8,r8
80005874:	80 00       	ld.sh	r0,r0[0x0]
80005876:	57 3c       	stdsp	sp[0x1cc],r12

80005878 <rtc_init>:
    PCF8563_init
Called By: ..
Return:rtc_err_t
*/
rtc_err_t rtc_init(void)
{
80005878:	eb cd 40 c0 	pushm	r6-r7,lr
8000587c:	20 3d       	sub	sp,12
	/* Create the mutex semaphore to guard a shared RTC(TWI).*/	
	rtc_mutex = xSemaphoreCreateMutex();
8000587e:	f0 1f 00 1a 	mcall	800058e4 <rtc_init+0x6c>
80005882:	49 a8       	lddpc	r8,800058e8 <rtc_init+0x70>
80005884:	91 0c       	st.w	r8[0x0],r12
	
	if(NULL != rtc_mutex)
80005886:	70 08       	ld.w	r8,r8[0x0]
80005888:	58 08       	cp.w	r8,0
8000588a:	c0 31       	brne	80005890 <rtc_init+0x18>
8000588c:	30 3c       	mov	r12,3
8000588e:	c2 78       	rjmp	800058dc <rtc_init+0x64>
	{
		/*See if we can obtain the semaphore. If the semaphore is not available wait aways to see if it becomes free*/
		xSemaphoreTake( rtc_mutex, portMAX_DELAY);
80005890:	49 66       	lddpc	r6,800058e8 <rtc_init+0x70>
80005892:	6c 0c       	ld.w	r12,r6[0x0]
80005894:	30 09       	mov	r9,0
80005896:	3f fa       	mov	r10,-1
80005898:	12 9b       	mov	r11,r9
8000589a:	f0 1f 00 15 	mcall	800058ec <rtc_init+0x74>
	
	/*twi_package_t packet, packet_received*/
	static int status;

	/*TWI gpio pins configuration*/	
	gpio_enable_module(TWI_GPIO_MAP, sizeof(TWI_GPIO_MAP) / sizeof(TWI_GPIO_MAP[0]));
8000589e:	30 2b       	mov	r11,2
800058a0:	49 4c       	lddpc	r12,800058f0 <rtc_init+0x78>
800058a2:	f0 1f 00 15 	mcall	800058f4 <rtc_init+0x7c>
	
	/* options settings*/
	opt.pba_hz = RTC_PBACLK_FREQ_HZ;//FOSC0;24Mhz
800058a6:	e0 68 36 00 	mov	r8,13824
800058aa:	ea 18 01 6e 	orh	r8,0x16e
800058ae:	50 08       	stdsp	sp[0x0],r8
	opt.speed  = TWI_SPEED;//200Khz
800058b0:	e2 78 0d 40 	mov	r8,200000
800058b4:	50 18       	stdsp	sp[0x4],r8
	opt.chip   = PCF8563_ADDRESS;
800058b6:	35 18       	mov	r8,81
800058b8:	fb 68 00 08 	st.b	sp[8],r8

	/*initialize TWI driver with options*/
	status = twi_master_init(&AVR32_TWI, &opt);
800058bc:	1a 9b       	mov	r11,sp
800058be:	fe 7c 2c 00 	mov	r12,-54272
800058c2:	f0 1f 00 0e 	mcall	800058f8 <rtc_init+0x80>
800058c6:	48 e7       	lddpc	r7,800058fc <rtc_init+0x84>
800058c8:	8f 0c       	st.w	r7[0x0],r12
	
	/*finished accessing the shared resource.Release the semaphore.*/
	xSemaphoreGive(rtc_mutex);		
800058ca:	6c 0c       	ld.w	r12,r6[0x0]
800058cc:	30 09       	mov	r9,0
800058ce:	12 9a       	mov	r10,r9
800058d0:	12 9b       	mov	r11,r9
800058d2:	f0 1f 00 0c 	mcall	80005900 <rtc_init+0x88>
800058d6:	6e 08       	ld.w	r8,r7[0x0]
800058d8:	58 08       	cp.w	r8,0
800058da:	5f 1c       	srne	r12
	{
		return rtc_success;
	}
		
	return rtc_init_err;
}
800058dc:	2f dd       	sub	sp,-12
800058de:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800058e2:	00 00       	add	r0,r0
800058e4:	80 00       	ld.sh	r0,r0[0x0]
800058e6:	8f b4       	st.w	r7[0x2c],r4
800058e8:	00 00       	add	r0,r0
800058ea:	10 80       	andn	r0,r8
800058ec:	80 00       	ld.sh	r0,r0[0x0]
800058ee:	8c a8       	ld.uh	r8,r6[0x4]
800058f0:	80 01       	ld.sh	r1,r0[0x0]
800058f2:	8a a0       	ld.uh	r0,r5[0x4]
800058f4:	80 00       	ld.sh	r0,r0[0x0]
800058f6:	9f 44       	st.w	pc[0x10],r4
800058f8:	80 00       	ld.sh	r0,r0[0x0]
800058fa:	5f 64       	srmi	r4
800058fc:	00 00       	add	r0,r0
800058fe:	10 74       	tst	r4,r8
80005900:	80 00       	ld.sh	r0,r0[0x0]
80005902:	8e b4       	ld.uh	r4,r7[0x6]

80005904 <local_start_timer>:
//	MAKO_RX					AVR32_SSC_RX_DATA_0_PIN				[39 PortB Pin  7 00000080 Func 0]
//
void local_start_timer(void)
{
	//Route CLK to Timer
	AVR32_GPIO.port[0].pmr0s = 0x00100000;
80005904:	fe 78 10 00 	mov	r8,-61440
80005908:	fc 19 00 10 	movh	r9,0x10
8000590c:	91 59       	st.w	r8[0x14],r9
	AVR32_GPIO.port[0].pmr1c = 0x00100000;
8000590e:	91 a9       	st.w	r8[0x28],r9
	AVR32_GPIO.port[0].gperc = 0x00100000;
80005910:	91 29       	st.w	r8[0x8],r9
	//Route FS and Tri-State to Timer.
	AVR32_GPIO.port[1].pmr0c = 0x00000003;
80005912:	30 39       	mov	r9,3
80005914:	f1 49 01 18 	st.w	r8[280],r9
	AVR32_GPIO.port[1].pmr1c = 0x00000003;
80005918:	f1 49 01 28 	st.w	r8[296],r9
	AVR32_GPIO.port[1].gperc = 0x00000003;
8000591c:	f1 49 01 08 	st.w	r8[264],r9

	(&AVR32_TC)->bmr = 4;
80005920:	fe 78 38 00 	mov	r8,-51200
80005924:	30 49       	mov	r9,4
80005926:	f1 49 00 c4 	st.w	r8[196],r9
	(&AVR32_TC)->channel[0].cmr =
8000592a:	e0 69 91 0d 	mov	r9,37133
8000592e:	ea 19 00 52 	orh	r9,0x52
80005932:	91 19       	st.w	r8[0x4],r9
	1                          << AVR32_TC_CLKI_OFFSET     |
	AVR32_TC_TCCLKS_XC0        << AVR32_TC_TCCLKS_OFFSET;



	(&AVR32_TC)->channel[0].ra = 32;
80005934:	32 09       	mov	r9,32
80005936:	91 59       	st.w	r8[0x14],r9
	(&AVR32_TC)->channel[0].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
80005938:	30 59       	mov	r9,5
8000593a:	91 09       	st.w	r8[0x0],r9
}
8000593c:	5e fc       	retal	r12
8000593e:	d7 03       	nop

80005940 <tc_init>:
 * - fPBA/8 is used as clock source for TC
 * - Enables RC compare match interrupt
 * \param tc Base address of the TC module
 */
void tc_init()
{
80005940:	d4 01       	pushm	lr

	volatile avr32_tc_t * tc = EXAMPLE_TC;
	
	INTC_register_interrupt(&_tc_interrupt, AVR32_TC_IRQ1, AVR32_INTC_INT2);
80005942:	30 2a       	mov	r10,2
80005944:	e0 6b 01 c1 	mov	r11,449
80005948:	48 ec       	lddpc	r12,80005980 <tc_init+0x40>
8000594a:	f0 1f 00 0f 	mcall	80005984 <tc_init+0x44>
		.cpas  = 0,
		.lovrs = 0,
		.covfs = 0
	};
	// Initialize the timer/counter.
	tc_init_waveform(tc, &waveform_opt);
8000594e:	48 fb       	lddpc	r11,80005988 <tc_init+0x48>
80005950:	fe 7c 38 00 	mov	r12,-51200
80005954:	f0 1f 00 0e 	mcall	8000598c <tc_init+0x4c>
	 * We want: (1 / (fPBA / 8)) * RC = 10 ms, hence RC = (fPBA / 8) / 100
	 * to get an interrupt every 10 ms.
	 */
	//tc_write_rc(tc, EXAMPLE_TC_CHANNEL, (sysclk_get_pba_hz() / 8 / 100));
	
	tc_write_rc(tc, EXAMPLE_TC_CHANNEL, ((FOSC0*2) / 8 / 100));
80005958:	e0 6a 75 30 	mov	r10,30000
8000595c:	30 1b       	mov	r11,1
8000595e:	fe 7c 38 00 	mov	r12,-51200
80005962:	f0 1f 00 0c 	mcall	80005990 <tc_init+0x50>
	
	//tc_write_rc(tc, EXAMPLE_TC_CHANNEL, (FOSC0 / 8 / 100000));
	
	
	// configure the timer interrupt
	tc_configure_interrupts(tc, EXAMPLE_TC_CHANNEL, &tc_interrupt);
80005966:	48 ca       	lddpc	r10,80005994 <tc_init+0x54>
80005968:	30 1b       	mov	r11,1
8000596a:	fe 7c 38 00 	mov	r12,-51200
8000596e:	f0 1f 00 0b 	mcall	80005998 <tc_init+0x58>
	// Start the timer/counter.
	tc_start(tc, EXAMPLE_TC_CHANNEL);
80005972:	30 1b       	mov	r11,1
80005974:	fe 7c 38 00 	mov	r12,-51200
80005978:	f0 1f 00 09 	mcall	8000599c <tc_init+0x5c>
8000597c:	d8 02       	popm	pc
8000597e:	00 00       	add	r0,r0
80005980:	80 00       	ld.sh	r0,r0[0x0]
80005982:	59 a0       	cp.w	r0,26
80005984:	80 00       	ld.sh	r0,r0[0x0]
80005986:	59 c4       	cp.w	r4,28
80005988:	80 01       	ld.sh	r1,r0[0x0]
8000598a:	8a b4       	ld.uh	r4,r5[0x6]
8000598c:	80 00       	ld.sh	r0,r0[0x0]
8000598e:	5c aa       	swap.h	r10
80005990:	80 00       	ld.sh	r0,r0[0x0]
80005992:	5d 6a       	*unknown*
80005994:	80 01       	ld.sh	r1,r0[0x0]
80005996:	8a b0       	ld.uh	r0,r5[0x6]
80005998:	80 00       	ld.sh	r0,r0[0x0]
8000599a:	5d 9e       	*unknown*
8000599c:	80 00       	ld.sh	r0,r0[0x0]
8000599e:	5d 46       	*unknown*

800059a0 <_tc_interrupt>:
volatile U32 tc_tick = 0;

//brief Default interrupt handler.
__attribute__((__interrupt__))
static void _tc_interrupt(void)
 {
800059a0:	d4 01       	pushm	lr
	// Increment the 10ms seconds counter
	tc_tick++;
800059a2:	48 68       	lddpc	r8,800059b8 <_tc_interrupt+0x18>
800059a4:	70 09       	ld.w	r9,r8[0x0]
800059a6:	2f f9       	sub	r9,-1
800059a8:	91 09       	st.w	r8[0x0],r9
	/*
	 * TODO: Place a breakpoint here and watch the update of tc_tick variable
	 * in the Watch Window.
	 */
	// Clear the interrupt flag. This is a side effect of reading the TC SR.
	tc_read_sr(EXAMPLE_TC, EXAMPLE_TC_CHANNEL);
800059aa:	30 1b       	mov	r11,1
800059ac:	fe 7c 38 00 	mov	r12,-51200
800059b0:	f0 1f 00 03 	mcall	800059bc <_tc_interrupt+0x1c>
	
}
800059b4:	d4 02       	popm	lr
800059b6:	d6 03       	rete
800059b8:	00 00       	add	r0,r0
800059ba:	10 84       	andn	r4,r8
800059bc:	80 00       	ld.sh	r0,r0[0x0]
800059be:	5d 58       	*unknown*

800059c0 <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
800059c0:	c0 08       	rjmp	800059c0 <_unhandled_interrupt>
800059c2:	d7 03       	nop

800059c4 <INTC_register_interrupt>:
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
800059c4:	f6 08 16 05 	lsr	r8,r11,0x5

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
800059c8:	49 99       	lddpc	r9,80005a2c <INTC_register_interrupt+0x68>
800059ca:	f2 08 00 39 	add	r9,r9,r8<<0x3
800059ce:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
800059d2:	72 19       	ld.w	r9,r9[0x4]
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
800059d4:	f2 0b 09 2c 	st.w	r9[r11<<0x2],r12
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
800059d8:	58 0a       	cp.w	r10,0
800059da:	c0 91       	brne	800059ec <INTC_register_interrupt+0x28>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
800059dc:	49 59       	lddpc	r9,80005a30 <INTC_register_interrupt+0x6c>
800059de:	49 6a       	lddpc	r10,80005a34 <INTC_register_interrupt+0x70>
800059e0:	12 1a       	sub	r10,r9
800059e2:	fe 79 08 00 	mov	r9,-63488
800059e6:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800059ea:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT1) {
800059ec:	58 1a       	cp.w	r10,1
800059ee:	c0 a1       	brne	80005a02 <INTC_register_interrupt+0x3e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
800059f0:	49 09       	lddpc	r9,80005a30 <INTC_register_interrupt+0x6c>
800059f2:	49 2a       	lddpc	r10,80005a38 <INTC_register_interrupt+0x74>
800059f4:	12 1a       	sub	r10,r9
800059f6:	bf aa       	sbr	r10,0x1e
800059f8:	fe 79 08 00 	mov	r9,-63488
800059fc:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80005a00:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT2) {
80005a02:	58 2a       	cp.w	r10,2
80005a04:	c0 a1       	brne	80005a18 <INTC_register_interrupt+0x54>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
80005a06:	48 b9       	lddpc	r9,80005a30 <INTC_register_interrupt+0x6c>
80005a08:	48 da       	lddpc	r10,80005a3c <INTC_register_interrupt+0x78>
80005a0a:	12 1a       	sub	r10,r9
80005a0c:	bf ba       	sbr	r10,0x1f
80005a0e:	fe 79 08 00 	mov	r9,-63488
80005a12:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80005a16:	5e fc       	retal	r12
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
80005a18:	48 69       	lddpc	r9,80005a30 <INTC_register_interrupt+0x6c>
80005a1a:	48 aa       	lddpc	r10,80005a40 <INTC_register_interrupt+0x7c>
80005a1c:	12 1a       	sub	r10,r9
80005a1e:	ea 1a c0 00 	orh	r10,0xc000
80005a22:	fe 79 08 00 	mov	r9,-63488
80005a26:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80005a2a:	5e fc       	retal	r12
80005a2c:	80 01       	ld.sh	r1,r0[0x0]
80005a2e:	8a bc       	ld.uh	r12,r5[0x6]
80005a30:	80 00       	ld.sh	r0,r0[0x0]
80005a32:	fc 00       	*unknown*
80005a34:	80 00       	ld.sh	r0,r0[0x0]
80005a36:	fd 04 80 00 	ld.sh	r4,lr[-32768]
80005a3a:	fd 12 80 00 	ld.uh	r2,lr[-32768]
80005a3e:	fd 20 80 00 	ld.sb	r0,lr[-32768]
80005a42:	fd 2e d4 21 	ld.sb	lr,lr[-11231]

80005a44 <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
80005a44:	d4 21       	pushm	r4-r7,lr
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
80005a46:	49 18       	lddpc	r8,80005a88 <INTC_init_interrupts+0x44>
80005a48:	e3 b8 00 01 	mtsr	0x4,r8
80005a4c:	49 0e       	lddpc	lr,80005a8c <INTC_init_interrupts+0x48>
80005a4e:	30 07       	mov	r7,0
80005a50:	0e 94       	mov	r4,r7
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80005a52:	49 0c       	lddpc	r12,80005a90 <INTC_init_interrupts+0x4c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80005a54:	49 05       	lddpc	r5,80005a94 <INTC_init_interrupts+0x50>
80005a56:	10 15       	sub	r5,r8
80005a58:	fe 76 08 00 	mov	r6,-63488
80005a5c:	c1 08       	rjmp	80005a7c <INTC_init_interrupts+0x38>
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
80005a5e:	08 98       	mov	r8,r4
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
80005a60:	7c 1b       	ld.w	r11,lr[0x4]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80005a62:	7c 0a       	ld.w	r10,lr[0x0]
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80005a64:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
80005a68:	2f f8       	sub	r8,-1

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80005a6a:	10 3a       	cp.w	r10,r8
80005a6c:	fe 9b ff fc 	brhi	80005a64 <INTC_init_interrupts+0x20>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80005a70:	ec 07 09 25 	st.w	r6[r7<<0x2],r5
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
80005a74:	2f f7       	sub	r7,-1
80005a76:	2f 8e       	sub	lr,-8
80005a78:	59 37       	cp.w	r7,19
80005a7a:	c0 50       	breq	80005a84 <INTC_init_interrupts+0x40>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80005a7c:	7c 08       	ld.w	r8,lr[0x0]
80005a7e:	58 08       	cp.w	r8,0
80005a80:	ce f1       	brne	80005a5e <INTC_init_interrupts+0x1a>
80005a82:	cf 7b       	rjmp	80005a70 <INTC_init_interrupts+0x2c>
80005a84:	d8 22       	popm	r4-r7,pc
80005a86:	00 00       	add	r0,r0
80005a88:	80 00       	ld.sh	r0,r0[0x0]
80005a8a:	fc 00       	*unknown*
80005a8c:	80 01       	ld.sh	r1,r0[0x0]
80005a8e:	8a bc       	ld.uh	r12,r5[0x6]
80005a90:	80 00       	ld.sh	r0,r0[0x0]
80005a92:	59 c0       	cp.w	r0,28
80005a94:	80 00       	ld.sh	r0,r0[0x0]
80005a96:	fd 04 fe 78 	ld.sh	r4,lr[-392]

80005a98 <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
80005a98:	fe 78 08 00 	mov	r8,-63488
80005a9c:	e0 69 00 83 	mov	r9,131
80005aa0:	f2 0c 01 0c 	sub	r12,r9,r12
80005aa4:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
80005aa8:	f2 ca ff c0 	sub	r10,r9,-64
80005aac:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	
	return (int_req)
80005ab0:	58 08       	cp.w	r8,0
80005ab2:	c0 21       	brne	80005ab6 <_get_interrupt_handler+0x1e>
80005ab4:	5e fd       	retal	0
		? _int_handler_table[int_grp]._int_line_handler_table[32
80005ab6:	f0 08 12 00 	clz	r8,r8
80005aba:	48 5a       	lddpc	r10,80005acc <_get_interrupt_handler+0x34>
80005abc:	f4 09 00 39 	add	r9,r10,r9<<0x3
80005ac0:	f0 08 11 1f 	rsub	r8,r8,31
80005ac4:	72 19       	ld.w	r9,r9[0x4]
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	
	return (int_req)
80005ac6:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
80005aca:	5e fc       	retal	r12
80005acc:	80 01       	ld.sh	r1,r0[0x0]
80005ace:	8a bc       	ld.uh	r12,r5[0x6]

80005ad0 <spi_initMaster>:

spi_status_t spi_initMaster(volatile avr32_spi_t *spi, const spi_options_t *options)
{
  u_avr32_spi_mr_t u_avr32_spi_mr;

  if (options->modfdis > 1) {
80005ad0:	f7 39 00 0d 	ld.ub	r9,r11[13]
80005ad4:	30 18       	mov	r8,1
80005ad6:	f0 09 18 00 	cp.b	r9,r8
80005ada:	e0 88 00 04 	brls	80005ae2 <spi_initMaster+0x12>
80005ade:	30 2c       	mov	r12,2
80005ae0:	5e fc       	retal	r12
    return SPI_ERROR_ARGUMENT;
  }

  // Reset.
  spi->cr = AVR32_SPI_CR_SWRST_MASK;
80005ae2:	e0 68 00 80 	mov	r8,128
80005ae6:	99 08       	st.w	r12[0x0],r8

  // Master Mode.
  u_avr32_spi_mr.mr = spi->mr;
80005ae8:	78 18       	ld.w	r8,r12[0x4]
  u_avr32_spi_mr.MR.mstr = 1;
80005aea:	30 19       	mov	r9,1
80005aec:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
  u_avr32_spi_mr.MR.modfdis = options->modfdis;
80005af0:	f7 39 00 0d 	ld.ub	r9,r11[13]
80005af4:	f1 d9 d0 81 	bfins	r8,r9,0x4,0x1
  u_avr32_spi_mr.MR.llb = 0;
80005af8:	30 09       	mov	r9,0
80005afa:	f1 d9 d0 e1 	bfins	r8,r9,0x7,0x1
  u_avr32_spi_mr.MR.pcs = (1 << AVR32_SPI_MR_PCS_SIZE) - 1;
80005afe:	30 fa       	mov	r10,15
80005b00:	f1 da d2 04 	bfins	r8,r10,0x10,0x4
  spi->mr = u_avr32_spi_mr.mr;
80005b04:	99 18       	st.w	r12[0x4],r8
80005b06:	5e f9       	retal	r9

80005b08 <spi_selectionMode>:

spi_status_t spi_selectionMode(volatile avr32_spi_t *spi,
                               unsigned char variable_ps,
                               unsigned char pcs_decode,
                               unsigned char delay)
{
80005b08:	d4 01       	pushm	lr
  u_avr32_spi_mr_t u_avr32_spi_mr;

  if (variable_ps > 1 ||
80005b0a:	30 18       	mov	r8,1
80005b0c:	f0 0b 18 00 	cp.b	r11,r8
80005b10:	5f be       	srhi	lr
80005b12:	f0 0a 18 00 	cp.b	r10,r8
80005b16:	5f b8       	srhi	r8
80005b18:	fd e8 10 08 	or	r8,lr,r8
80005b1c:	c0 30       	breq	80005b22 <spi_selectionMode+0x1a>
80005b1e:	30 2c       	mov	r12,2
80005b20:	d8 02       	popm	pc
      pcs_decode > 1) {
    return SPI_ERROR_ARGUMENT;
  }

  u_avr32_spi_mr.mr = spi->mr;
80005b22:	78 18       	ld.w	r8,r12[0x4]
  u_avr32_spi_mr.MR.ps = variable_ps;
80005b24:	f1 db d0 21 	bfins	r8,r11,0x1,0x1
  u_avr32_spi_mr.MR.pcsdec = pcs_decode;
80005b28:	f1 da d0 41 	bfins	r8,r10,0x2,0x1
  u_avr32_spi_mr.MR.dlybcs = delay;
80005b2c:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8
  spi->mr = u_avr32_spi_mr.mr;
80005b30:	99 18       	st.w	r12[0x4],r8
80005b32:	d8 0a       	popm	pc,r12=0

80005b34 <spi_selectChip>:
   */
  while (pdFALSE == xSemaphoreTake(xSPIMutex, 20));
#endif

  // Assert all lines; no peripheral is selected.
  spi->mr |= AVR32_SPI_MR_PCS_MASK;
80005b34:	78 18       	ld.w	r8,r12[0x4]
80005b36:	ea 18 00 0f 	orh	r8,0xf
80005b3a:	99 18       	st.w	r12[0x4],r8

  if (spi->mr & AVR32_SPI_MR_PCSDEC_MASK) {
80005b3c:	78 18       	ld.w	r8,r12[0x4]
80005b3e:	e2 18 00 04 	andl	r8,0x4,COH
80005b42:	c0 f0       	breq	80005b60 <spi_selectChip+0x2c>
    // The signal is decoded; allow up to 15 chips.
    if (chip > 14) {
80005b44:	30 e8       	mov	r8,14
80005b46:	f0 0b 18 00 	cp.b	r11,r8
80005b4a:	e0 8b 00 19 	brhi	80005b7c <spi_selectChip+0x48>
      return SPI_ERROR_ARGUMENT;
    }

    spi->mr &= ~AVR32_SPI_MR_PCS_MASK | (chip << AVR32_SPI_MR_PCS_OFFSET);
80005b4e:	78 18       	ld.w	r8,r12[0x4]
80005b50:	b1 6b       	lsl	r11,0x10
80005b52:	ea 1b ff f0 	orh	r11,0xfff0
80005b56:	e8 1b ff ff 	orl	r11,0xffff
80005b5a:	10 6b       	and	r11,r8
80005b5c:	99 1b       	st.w	r12[0x4],r11
80005b5e:	5e fd       	retal	0
  } else {
    if (chip > 3) {
80005b60:	30 38       	mov	r8,3
80005b62:	f0 0b 18 00 	cp.b	r11,r8
80005b66:	e0 8b 00 0b 	brhi	80005b7c <spi_selectChip+0x48>
      return SPI_ERROR_ARGUMENT;
    }

    spi->mr &= ~(1 << (AVR32_SPI_MR_PCS_OFFSET + chip));
80005b6a:	78 18       	ld.w	r8,r12[0x4]
80005b6c:	2f 0b       	sub	r11,-16
80005b6e:	30 19       	mov	r9,1
80005b70:	f2 0b 09 4b 	lsl	r11,r9,r11
80005b74:	5c db       	com	r11
80005b76:	10 6b       	and	r11,r8
80005b78:	99 1b       	st.w	r12[0x4],r11
80005b7a:	5e fd       	retal	0
80005b7c:	30 2c       	mov	r12,2
  }

  return SPI_OK;
}
80005b7e:	5e fc       	retal	r12

80005b80 <spi_unselectChip>:


spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, unsigned char chip)
{
80005b80:	e0 68 27 10 	mov	r8,10000
  unsigned int timeout = SPI_TIMEOUT;

  while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
80005b84:	c0 58       	rjmp	80005b8e <spi_unselectChip+0xe>
    if (!timeout--) {
80005b86:	58 08       	cp.w	r8,0
80005b88:	c0 21       	brne	80005b8c <spi_unselectChip+0xc>
80005b8a:	5e ff       	retal	1
80005b8c:	20 18       	sub	r8,1

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, unsigned char chip)
{
  unsigned int timeout = SPI_TIMEOUT;

  while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
80005b8e:	78 49       	ld.w	r9,r12[0x10]
80005b90:	e2 19 02 00 	andl	r9,0x200,COH
80005b94:	cf 90       	breq	80005b86 <spi_unselectChip+0x6>
      return SPI_ERROR_TIMEOUT;
    }
  }

  // Assert all lines; no peripheral is selected.
  spi->mr |= AVR32_SPI_MR_PCS_MASK;
80005b96:	78 18       	ld.w	r8,r12[0x4]
80005b98:	ea 18 00 0f 	orh	r8,0xf
80005b9c:	99 18       	st.w	r12[0x4],r8

  // Last transfer, so deassert the current NPCS if CSAAT is set.
  spi->cr = AVR32_SPI_CR_LASTXFER_MASK;
80005b9e:	fc 18 01 00 	movh	r8,0x100
80005ba2:	99 08       	st.w	r12[0x0],r8
80005ba4:	5e fd       	retal	0

80005ba6 <spi_setupChipReg>:


spi_status_t spi_setupChipReg(volatile avr32_spi_t *spi,
                              const spi_options_t *options,
                              unsigned int pba_hz)
{
80005ba6:	eb cd 40 c0 	pushm	r6-r7,lr
  u_avr32_spi_csr_t u_avr32_spi_csr;

  if (options->spi_mode > 3 ||
80005baa:	f7 38 00 0c 	ld.ub	r8,r11[12]
80005bae:	30 39       	mov	r9,3
80005bb0:	f2 08 18 00 	cp.b	r8,r9
80005bb4:	e0 8b 00 57 	brhi	80005c62 <spi_setupChipReg+0xbc>
      options->stay_act > 1 ||
80005bb8:	f7 39 00 0b 	ld.ub	r9,r11[11]
                              const spi_options_t *options,
                              unsigned int pba_hz)
{
  u_avr32_spi_csr_t u_avr32_spi_csr;

  if (options->spi_mode > 3 ||
80005bbc:	30 1e       	mov	lr,1
80005bbe:	fc 09 18 00 	cp.b	r9,lr
80005bc2:	e0 8b 00 50 	brhi	80005c62 <spi_setupChipReg+0xbc>
      options->stay_act > 1 ||
      options->bits < 8 || options->bits > 16) {
80005bc6:	f7 3e 00 08 	ld.ub	lr,r11[8]
                              const spi_options_t *options,
                              unsigned int pba_hz)
{
  u_avr32_spi_csr_t u_avr32_spi_csr;

  if (options->spi_mode > 3 ||
80005bca:	30 77       	mov	r7,7
80005bcc:	ee 0e 18 00 	cp.b	lr,r7
80005bd0:	e0 88 00 49 	brls	80005c62 <spi_setupChipReg+0xbc>
80005bd4:	31 07       	mov	r7,16
80005bd6:	ee 0e 18 00 	cp.b	lr,r7
80005bda:	e0 8b 00 44 	brhi	80005c62 <spi_setupChipReg+0xbc>
 *   \retval >=0  Success.
 *   \retval  <0  Error.
 */
static int getBaudDiv(const spi_options_t *options, unsigned int pba_hz)
{
  int baudDiv = (pba_hz + options->baudrate / 2) / options->baudrate;
80005bde:	76 17       	ld.w	r7,r11[0x4]
80005be0:	ee 06 16 01 	lsr	r6,r7,0x1
80005be4:	0c 0a       	add	r10,r6
80005be6:	f4 07 0d 06 	divu	r6,r10,r7

  if (baudDiv <= 0 || baudDiv > 255) {
80005bea:	ec c7 00 01 	sub	r7,r6,1
80005bee:	e0 47 00 fe 	cp.w	r7,254
80005bf2:	e0 8b 00 38 	brhi	80005c62 <spi_setupChipReg+0xbc>
 *   \retval >=0  Success.
 *   \retval  <0  Error.
 */
static int getBaudDiv(const spi_options_t *options, unsigned int pba_hz)
{
  int baudDiv = (pba_hz + options->baudrate / 2) / options->baudrate;
80005bf6:	0c 97       	mov	r7,r6
    return SPI_ERROR_ARGUMENT;
  }

  int baudDiv = getBaudDiv(options, pba_hz);

  if (baudDiv < 0) {
80005bf8:	58 06       	cp.w	r6,0
80005bfa:	c3 45       	brlt	80005c62 <spi_setupChipReg+0xbc>
    return SPI_ERROR_ARGUMENT;
  }

  // Will use CSR0 offsets; these are the same for CSR0 to CSR3.
  u_avr32_spi_csr.csr = 0;
80005bfc:	30 0a       	mov	r10,0
  u_avr32_spi_csr.CSR.cpol = options->spi_mode >> 1;
80005bfe:	f0 06 16 01 	lsr	r6,r8,0x1
80005c02:	f5 d6 d0 01 	bfins	r10,r6,0x0,0x1
  u_avr32_spi_csr.CSR.ncpha = (options->spi_mode & 0x1) ^ 0x1;
80005c06:	ec 18 00 01 	eorl	r8,0x1
80005c0a:	f5 d8 d0 21 	bfins	r10,r8,0x1,0x1
  u_avr32_spi_csr.CSR.csaat = options->stay_act;
80005c0e:	f5 d9 d0 61 	bfins	r10,r9,0x3,0x1
  u_avr32_spi_csr.CSR.bits = options->bits - 8;
80005c12:	20 8e       	sub	lr,8
80005c14:	f5 de d0 84 	bfins	r10,lr,0x4,0x4
  u_avr32_spi_csr.CSR.scbr = baudDiv;
80005c18:	f5 d7 d1 08 	bfins	r10,r7,0x8,0x8
  u_avr32_spi_csr.CSR.dlybs = options->spck_delay;
80005c1c:	f7 38 00 09 	ld.ub	r8,r11[9]
80005c20:	f5 d8 d2 08 	bfins	r10,r8,0x10,0x8
  u_avr32_spi_csr.CSR.dlybct = options->trans_delay;
80005c24:	f7 38 00 0a 	ld.ub	r8,r11[10]
80005c28:	f5 d8 d3 08 	bfins	r10,r8,0x18,0x8

  switch(options->reg) {
80005c2c:	17 88       	ld.ub	r8,r11[0x0]
80005c2e:	30 19       	mov	r9,1
80005c30:	f2 08 18 00 	cp.b	r8,r9
80005c34:	c0 e0       	breq	80005c50 <spi_setupChipReg+0xaa>
80005c36:	c0 a3       	brcs	80005c4a <spi_setupChipReg+0xa4>
80005c38:	30 29       	mov	r9,2
80005c3a:	f2 08 18 00 	cp.b	r8,r9
80005c3e:	c0 c0       	breq	80005c56 <spi_setupChipReg+0xb0>
80005c40:	30 39       	mov	r9,3
80005c42:	f2 08 18 00 	cp.b	r8,r9
80005c46:	c0 e1       	brne	80005c62 <spi_setupChipReg+0xbc>
80005c48:	c0 a8       	rjmp	80005c5c <spi_setupChipReg+0xb6>
    case 0:
      spi->csr0 = u_avr32_spi_csr.csr;
80005c4a:	99 ca       	st.w	r12[0x30],r10
80005c4c:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
      break;
    case 1:
      spi->csr1 = u_avr32_spi_csr.csr;
80005c50:	99 da       	st.w	r12[0x34],r10
80005c52:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
      break;
    case 2:
      spi->csr2 = u_avr32_spi_csr.csr;
80005c56:	99 ea       	st.w	r12[0x38],r10
80005c58:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
      break;
    case 3:
      spi->csr3 = u_avr32_spi_csr.csr;
80005c5c:	99 fa       	st.w	r12[0x3c],r10
80005c5e:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
      break;
80005c62:	30 2c       	mov	r12,2
    }
  }
#endif

  return SPI_OK;
}
80005c64:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

80005c68 <spi_enable>:


void spi_enable(volatile avr32_spi_t *spi)
{
  spi->cr = AVR32_SPI_CR_SPIEN_MASK;
80005c68:	30 18       	mov	r8,1
80005c6a:	99 08       	st.w	r12[0x0],r8
}
80005c6c:	5e fc       	retal	r12

80005c6e <spi_write>:
  return ((spi->sr & AVR32_SPI_SR_TDRE_MASK) != 0);
}


spi_status_t spi_write(volatile avr32_spi_t *spi, unsigned short data)
{
80005c6e:	e0 68 27 10 	mov	r8,10000
  unsigned int timeout = SPI_TIMEOUT;

  while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80005c72:	c0 58       	rjmp	80005c7c <spi_write+0xe>
    if (!timeout--) {
80005c74:	58 08       	cp.w	r8,0
80005c76:	c0 21       	brne	80005c7a <spi_write+0xc>
80005c78:	5e ff       	retal	1
80005c7a:	20 18       	sub	r8,1

spi_status_t spi_write(volatile avr32_spi_t *spi, unsigned short data)
{
  unsigned int timeout = SPI_TIMEOUT;

  while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80005c7c:	78 49       	ld.w	r9,r12[0x10]
80005c7e:	e2 19 00 02 	andl	r9,0x2,COH
80005c82:	cf 90       	breq	80005c74 <spi_write+0x6>
    if (!timeout--) {
      return SPI_ERROR_TIMEOUT;
    }
  }

  spi->tdr = data << AVR32_SPI_TDR_TD_OFFSET;
80005c84:	5c 7b       	castu.h	r11
80005c86:	99 3b       	st.w	r12[0xc],r11
80005c88:	5e fd       	retal	0

80005c8a <spi_read>:
  return ((spi->sr & AVR32_SPI_SR_RDRF_MASK) != 0);
}


spi_status_t spi_read(volatile avr32_spi_t *spi, unsigned short *data)
{
80005c8a:	e0 68 27 10 	mov	r8,10000
  unsigned int timeout = SPI_TIMEOUT;

  while ((spi->sr & (AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) !=
80005c8e:	c0 58       	rjmp	80005c98 <spi_read+0xe>
         (AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) {
    if (!timeout--) {
80005c90:	58 08       	cp.w	r8,0
80005c92:	c0 21       	brne	80005c96 <spi_read+0xc>
80005c94:	5e ff       	retal	1
80005c96:	20 18       	sub	r8,1

spi_status_t spi_read(volatile avr32_spi_t *spi, unsigned short *data)
{
  unsigned int timeout = SPI_TIMEOUT;

  while ((spi->sr & (AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) !=
80005c98:	78 49       	ld.w	r9,r12[0x10]
80005c9a:	e2 19 02 01 	andl	r9,0x201,COH
80005c9e:	e0 49 02 01 	cp.w	r9,513
80005ca2:	cf 71       	brne	80005c90 <spi_read+0x6>
    if (!timeout--) {
      return SPI_ERROR_TIMEOUT;
    }
  }

  *data = spi->rdr >> AVR32_SPI_RDR_RD_OFFSET;
80005ca4:	78 28       	ld.w	r8,r12[0x8]
80005ca6:	b6 08       	st.h	r11[0x0],r8
80005ca8:	5e fd       	retal	0

80005caa <tc_init_waveform>:


int tc_init_waveform(volatile avr32_tc_t *tc, const tc_waveform_opt_t *opt)
{
  // Check for valid input.
  if (opt->channel >= TC_NUMBER_OF_CHANNELS)
80005caa:	76 09       	ld.w	r9,r11[0x0]
80005cac:	58 29       	cp.w	r9,2
80005cae:	e0 88 00 03 	brls	80005cb4 <tc_init_waveform+0xa>
80005cb2:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  // GENERATE SIGNALS: Waveform operating mode.
  tc->channel[opt->channel].cmr = opt->bswtrg << AVR32_TC_BSWTRG_OFFSET |
80005cb4:	76 18       	ld.w	r8,r11[0x4]
80005cb6:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
80005cba:	af ba       	sbr	r10,0xf
80005cbc:	10 9b       	mov	r11,r8
80005cbe:	e6 1b c0 00 	andh	r11,0xc000,COH
80005cc2:	16 4a       	or	r10,r11
80005cc4:	10 9b       	mov	r11,r8
80005cc6:	e6 1b 30 00 	andh	r11,0x3000,COH
80005cca:	16 4a       	or	r10,r11
80005ccc:	10 9b       	mov	r11,r8
80005cce:	e6 1b 0c 00 	andh	r11,0xc00,COH
80005cd2:	16 4a       	or	r10,r11
80005cd4:	10 9b       	mov	r11,r8
80005cd6:	e6 1b 03 00 	andh	r11,0x300,COH
80005cda:	16 4a       	or	r10,r11
80005cdc:	10 9b       	mov	r11,r8
80005cde:	e6 1b 00 c0 	andh	r11,0xc0,COH
80005ce2:	16 4a       	or	r10,r11
80005ce4:	10 9b       	mov	r11,r8
80005ce6:	e6 1b 00 30 	andh	r11,0x30,COH
80005cea:	16 4a       	or	r10,r11
80005cec:	10 9b       	mov	r11,r8
80005cee:	e6 1b 00 0c 	andh	r11,0xc,COH
80005cf2:	16 4a       	or	r10,r11
80005cf4:	10 9b       	mov	r11,r8
80005cf6:	e6 1b 00 03 	andh	r11,0x3,COH
80005cfa:	16 4a       	or	r10,r11
80005cfc:	10 9b       	mov	r11,r8
80005cfe:	e2 1b 60 00 	andl	r11,0x6000,COH
80005d02:	16 4a       	or	r10,r11
80005d04:	f7 d8 c1 81 	bfextu	r11,r8,0xc,0x1
80005d08:	f5 eb 10 ca 	or	r10,r10,r11<<0xc
80005d0c:	10 9b       	mov	r11,r8
80005d0e:	e2 1b 0c 00 	andl	r11,0xc00,COH
80005d12:	16 4a       	or	r10,r11
80005d14:	10 9b       	mov	r11,r8
80005d16:	e2 1b 03 00 	andl	r11,0x300,COH
80005d1a:	16 4a       	or	r10,r11
80005d1c:	f7 d8 c0 e1 	bfextu	r11,r8,0x7,0x1
80005d20:	f5 eb 10 7a 	or	r10,r10,r11<<0x7
80005d24:	f7 d8 c0 c1 	bfextu	r11,r8,0x6,0x1
80005d28:	f5 eb 10 6a 	or	r10,r10,r11<<0x6
80005d2c:	10 9b       	mov	r11,r8
80005d2e:	e2 1b 00 30 	andl	r11,0x30,COH
80005d32:	16 4a       	or	r10,r11
80005d34:	f1 d8 c0 61 	bfextu	r8,r8,0x3,0x1
80005d38:	f5 e8 10 38 	or	r8,r10,r8<<0x3
80005d3c:	a5 69       	lsl	r9,0x4
80005d3e:	2f f9       	sub	r9,-1
80005d40:	f8 09 09 28 	st.w	r12[r9<<0x2],r8
80005d44:	5e fd       	retal	0

80005d46 <tc_start>:


int tc_start(volatile avr32_tc_t *tc, unsigned int channel)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80005d46:	58 2b       	cp.w	r11,2
80005d48:	e0 88 00 03 	brls	80005d4e <tc_start+0x8>
80005d4c:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  // Enable, reset and start the selected timer/counter channel.
  tc->channel[channel].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
80005d4e:	a7 6b       	lsl	r11,0x6
80005d50:	16 0c       	add	r12,r11
80005d52:	30 58       	mov	r8,5
80005d54:	99 08       	st.w	r12[0x0],r8
80005d56:	5e fd       	retal	0

80005d58 <tc_read_sr>:


int tc_read_sr(volatile avr32_tc_t *tc, unsigned int channel)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80005d58:	58 2b       	cp.w	r11,2
80005d5a:	e0 88 00 03 	brls	80005d60 <tc_read_sr+0x8>
80005d5e:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  return tc->channel[channel].sr;
80005d60:	a7 6b       	lsl	r11,0x6
80005d62:	2e 0b       	sub	r11,-32
80005d64:	16 0c       	add	r12,r11
80005d66:	78 0c       	ld.w	r12,r12[0x0]
}
80005d68:	5e fc       	retal	r12

80005d6a <tc_write_rc>:


int tc_write_rc(volatile avr32_tc_t *tc, unsigned int channel, unsigned short value)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80005d6a:	58 2b       	cp.w	r11,2
80005d6c:	e0 88 00 03 	brls	80005d72 <tc_write_rc+0x8>
80005d70:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  // This function is only available in WAVEFORM mode.
  if (Tst_bits(tc->channel[channel].cmr, AVR32_TC_WAVE_MASK))
80005d72:	f6 08 15 04 	lsl	r8,r11,0x4
80005d76:	2f f8       	sub	r8,-1
80005d78:	f8 08 03 28 	ld.w	r8,r12[r8<<0x2]
80005d7c:	e2 18 80 00 	andl	r8,0x8000,COH
80005d80:	c0 c0       	breq	80005d98 <tc_write_rc+0x2e>
    Wr_bitfield(tc->channel[channel].rc, AVR32_TC_RC_MASK, value);
80005d82:	a7 6b       	lsl	r11,0x6
80005d84:	16 0c       	add	r12,r11
80005d86:	2e 4c       	sub	r12,-28
80005d88:	78 08       	ld.w	r8,r12[0x0]
80005d8a:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
80005d8e:	e0 18 00 00 	andl	r8,0x0
80005d92:	f3 e8 10 08 	or	r8,r9,r8
80005d96:	99 08       	st.w	r12[0x0],r8

  return value;
80005d98:	f9 da c0 10 	bfextu	r12,r10,0x0,0x10
}
80005d9c:	5e fc       	retal	r12

80005d9e <tc_configure_interrupts>:
  return tc->channel[channel].imr;
}


int tc_configure_interrupts(volatile avr32_tc_t *tc, unsigned int channel, const tc_interrupt_t *bitfield)
{
80005d9e:	eb cd 40 fc 	pushm	r2-r7,lr
  bool global_interrupt_enabled = Is_global_interrupt_enabled();
80005da2:	e1 b9 00 00 	mfsr	r9,0x0

  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80005da6:	58 2b       	cp.w	r11,2
80005da8:	e0 88 00 04 	brls	80005db0 <tc_configure_interrupts+0x12>
80005dac:	e3 cf c0 fc 	ldm	sp++,r2-r7,pc,r12=-1
	return flags;
}

static inline bool cpu_irq_is_enabled_flags(irqflags_t flags)
{
	return !(flags & AVR32_SR_GM_MASK);
80005db0:	ee 19 00 01 	eorh	r9,0x1
80005db4:	f3 d9 c2 01 	bfextu	r9,r9,0x10,0x1
    return TC_INVALID_ARGUMENT;

  // Enable the appropriate interrupts.
  tc->channel[channel].ier = bitfield->etrgs << AVR32_TC_ETRGS_OFFSET |
80005db8:	74 08       	ld.w	r8,r10[0x0]
80005dba:	ef d8 c0 e1 	bfextu	r7,r8,0x7,0x1
80005dbe:	fd d8 c0 c1 	bfextu	lr,r8,0x6,0x1
80005dc2:	a7 6e       	lsl	lr,0x6
80005dc4:	fd e7 10 7e 	or	lr,lr,r7<<0x7
80005dc8:	ef d8 c0 01 	bfextu	r7,r8,0x0,0x1
80005dcc:	0e 4e       	or	lr,r7
80005dce:	ef d8 c0 a1 	bfextu	r7,r8,0x5,0x1
80005dd2:	fd e7 10 5e 	or	lr,lr,r7<<0x5
80005dd6:	ef d8 c0 81 	bfextu	r7,r8,0x4,0x1
80005dda:	fd e7 10 4e 	or	lr,lr,r7<<0x4
80005dde:	ef d8 c0 61 	bfextu	r7,r8,0x3,0x1
80005de2:	fd e7 10 3e 	or	lr,lr,r7<<0x3
80005de6:	ef d8 c0 41 	bfextu	r7,r8,0x2,0x1
80005dea:	fd e7 10 2e 	or	lr,lr,r7<<0x2
80005dee:	f1 d8 c0 21 	bfextu	r8,r8,0x1,0x1
80005df2:	fd e8 10 18 	or	r8,lr,r8<<0x1
80005df6:	f6 0e 15 06 	lsl	lr,r11,0x6
80005dfa:	f8 0e 00 0e 	add	lr,r12,lr
80005dfe:	2d ce       	sub	lr,-36
80005e00:	9d 08       	st.w	lr[0x0],r8
                             bitfield->cpas << AVR32_TC_CPAS_OFFSET |
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;

  // Disable the appropriate interrupts.
  if (global_interrupt_enabled) Disable_global_interrupt();
80005e02:	58 09       	cp.w	r9,0
80005e04:	c0 20       	breq	80005e08 <tc_configure_interrupts+0x6a>
80005e06:	d3 03       	ssrf	0x10
  tc->channel[channel].idr = (~bitfield->etrgs & 1) << AVR32_TC_ETRGS_OFFSET |
80005e08:	74 08       	ld.w	r8,r10[0x0]
80005e0a:	f1 d8 c0 e1 	bfextu	r8,r8,0x7,0x1
80005e0e:	e0 65 00 80 	mov	r5,128
80005e12:	f9 b5 01 00 	movne	r5,0
                             (~bitfield->ldrbs & 1) << AVR32_TC_LDRBS_OFFSET |
80005e16:	74 08       	ld.w	r8,r10[0x0]
80005e18:	f1 d8 c0 c1 	bfextu	r8,r8,0x6,0x1
80005e1c:	f9 b4 00 40 	moveq	r4,64
80005e20:	f9 b4 01 00 	movne	r4,0
                             (~bitfield->ldras & 1) << AVR32_TC_LDRAS_OFFSET |
80005e24:	74 08       	ld.w	r8,r10[0x0]
80005e26:	f1 d8 c0 a1 	bfextu	r8,r8,0x5,0x1
80005e2a:	f9 b3 00 20 	moveq	r3,32
80005e2e:	f9 b3 01 00 	movne	r3,0
                             (~bitfield->cpcs & 1) << AVR32_TC_CPCS_OFFSET |
80005e32:	74 08       	ld.w	r8,r10[0x0]
80005e34:	f1 d8 c0 81 	bfextu	r8,r8,0x4,0x1
80005e38:	f9 b2 00 10 	moveq	r2,16
80005e3c:	f9 b2 01 00 	movne	r2,0
                             (~bitfield->cpbs & 1) << AVR32_TC_CPBS_OFFSET |
80005e40:	74 08       	ld.w	r8,r10[0x0]
80005e42:	f1 d8 c0 61 	bfextu	r8,r8,0x3,0x1
80005e46:	f9 b6 00 08 	moveq	r6,8
80005e4a:	f9 b6 01 00 	movne	r6,0
                             (~bitfield->cpas & 1) << AVR32_TC_CPAS_OFFSET |
80005e4e:	74 08       	ld.w	r8,r10[0x0]
80005e50:	f1 d8 c0 41 	bfextu	r8,r8,0x2,0x1
80005e54:	f9 b7 00 04 	moveq	r7,4
80005e58:	f9 b7 01 00 	movne	r7,0
                             (~bitfield->lovrs & 1) << AVR32_TC_LOVRS_OFFSET |
80005e5c:	74 08       	ld.w	r8,r10[0x0]
80005e5e:	f1 d8 c0 21 	bfextu	r8,r8,0x1,0x1
80005e62:	f9 be 00 02 	moveq	lr,2
80005e66:	f9 be 01 00 	movne	lr,0
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;

  // Disable the appropriate interrupts.
  if (global_interrupt_enabled) Disable_global_interrupt();
  tc->channel[channel].idr = (~bitfield->etrgs & 1) << AVR32_TC_ETRGS_OFFSET |
80005e6a:	74 08       	ld.w	r8,r10[0x0]
80005e6c:	ec 18 00 01 	eorl	r8,0x1
80005e70:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80005e74:	eb e8 10 08 	or	r8,r5,r8
80005e78:	08 48       	or	r8,r4
80005e7a:	06 48       	or	r8,r3
80005e7c:	04 48       	or	r8,r2
80005e7e:	0c 48       	or	r8,r6
80005e80:	0e 48       	or	r8,r7
80005e82:	1c 48       	or	r8,lr
80005e84:	f6 0a 15 06 	lsl	r10,r11,0x6
80005e88:	f8 0a 00 0a 	add	r10,r12,r10
80005e8c:	2d 8a       	sub	r10,-40
80005e8e:	95 08       	st.w	r10[0x0],r8
                             (~bitfield->cpcs & 1) << AVR32_TC_CPCS_OFFSET |
                             (~bitfield->cpbs & 1) << AVR32_TC_CPBS_OFFSET |
                             (~bitfield->cpas & 1) << AVR32_TC_CPAS_OFFSET |
                             (~bitfield->lovrs & 1) << AVR32_TC_LOVRS_OFFSET |
                             (~bitfield->covfs & 1) << AVR32_TC_COVFS_OFFSET;
  tc->channel[channel].sr;
80005e90:	a7 6b       	lsl	r11,0x6
80005e92:	2e 0b       	sub	r11,-32
80005e94:	16 0c       	add	r12,r11
80005e96:	78 08       	ld.w	r8,r12[0x0]
  if (global_interrupt_enabled) Enable_global_interrupt();
80005e98:	58 09       	cp.w	r9,0
80005e9a:	c0 31       	brne	80005ea0 <tc_configure_interrupts+0x102>
80005e9c:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0
80005ea0:	d5 03       	csrf	0x10
80005ea2:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0
80005ea6:	d7 03       	nop

80005ea8 <twi_master_interrupt_handler>:
/*! \brief TWI interrupt handler.
 */
ISR(twi_master_interrupt_handler, CONF_TWI_IRQ_GROUP, CONF_TWI_IRQ_LEVEL)
{
	// get masked status register value
	int status = twi_inst->sr & twi_it_mask;
80005ea8:	4a 78       	lddpc	r8,80005f44 <twi_master_interrupt_handler+0x9c>
80005eaa:	70 08       	ld.w	r8,r8[0x0]
80005eac:	70 89       	ld.w	r9,r8[0x20]
80005eae:	4a 7a       	lddpc	r10,80005f48 <twi_master_interrupt_handler+0xa0>
80005eb0:	74 0a       	ld.w	r10,r10[0x0]
80005eb2:	f5 e9 00 09 	and	r9,r10,r9

	// this is a NACK
	if (status & AVR32_TWI_SR_NACK_MASK) {
80005eb6:	12 9a       	mov	r10,r9
80005eb8:	e2 1a 01 00 	andl	r10,0x100,COH
80005ebc:	c3 91       	brne	80005f2e <twi_master_interrupt_handler+0x86>
		goto nack;
	}
	// this is a RXRDY
	else if (status & AVR32_TWI_SR_RXRDY_MASK) {
80005ebe:	12 9a       	mov	r10,r9
80005ec0:	e2 1a 00 02 	andl	r10,0x2,COH
80005ec4:	c1 70       	breq	80005ef2 <twi_master_interrupt_handler+0x4a>
		// get data from Receive Holding Register
		*twi_rx_data = twi_inst->rhr;
80005ec6:	4a 29       	lddpc	r9,80005f4c <twi_master_interrupt_handler+0xa4>
80005ec8:	72 0a       	ld.w	r10,r9[0x0]
80005eca:	70 cb       	ld.w	r11,r8[0x30]
80005ecc:	b4 8b       	st.b	r10[0x0],r11
		twi_rx_data++;
80005ece:	72 0a       	ld.w	r10,r9[0x0]
80005ed0:	2f fa       	sub	r10,-1
80005ed2:	93 0a       	st.w	r9[0x0],r10
		// last byte to receive
		if (--twi_rx_nb_bytes == 1) {
80005ed4:	49 f9       	lddpc	r9,80005f50 <twi_master_interrupt_handler+0xa8>
80005ed6:	72 0a       	ld.w	r10,r9[0x0]
80005ed8:	20 1a       	sub	r10,1
80005eda:	93 0a       	st.w	r9[0x0],r10
80005edc:	72 09       	ld.w	r9,r9[0x0]
			// set stop bit
			twi_inst->cr = AVR32_TWI_STOP_MASK;
80005ede:	58 19       	cp.w	r9,1
80005ee0:	f9 b9 00 02 	moveq	r9,2
80005ee4:	f1 f9 0a 00 	st.weq	r8[0x0],r9
		}
		// receive complete
		if (twi_rx_nb_bytes == 0) {
80005ee8:	49 a9       	lddpc	r9,80005f50 <twi_master_interrupt_handler+0xa8>
80005eea:	72 09       	ld.w	r9,r9[0x0]
80005eec:	58 09       	cp.w	r9,0
80005eee:	c2 30       	breq	80005f34 <twi_master_interrupt_handler+0x8c>
80005ef0:	d6 03       	rete
			// finish the receive operation
			goto complete;
		}
	}
	// this is a TXRDY
	else if (status & AVR32_TWI_SR_TXRDY_MASK) {
80005ef2:	12 9a       	mov	r10,r9
80005ef4:	e2 1a 00 04 	andl	r10,0x4,COH
80005ef8:	c1 70       	breq	80005f26 <twi_master_interrupt_handler+0x7e>
		// decrease transmitted bytes number
		twi_tx_nb_bytes--;
80005efa:	49 79       	lddpc	r9,80005f54 <twi_master_interrupt_handler+0xac>
80005efc:	72 0a       	ld.w	r10,r9[0x0]
80005efe:	20 1a       	sub	r10,1
80005f00:	93 0a       	st.w	r9[0x0],r10
		// no more bytes to transmit
		if (twi_tx_nb_bytes <= 0) {
80005f02:	72 09       	ld.w	r9,r9[0x0]
80005f04:	58 09       	cp.w	r9,0
80005f06:	e0 89 00 0a 	brgt	80005f1a <twi_master_interrupt_handler+0x72>
			// enable TXCOMP IT and unmask all others IT
			twi_it_mask = AVR32_TWI_IER_TXCOMP_MASK;
80005f0a:	49 09       	lddpc	r9,80005f48 <twi_master_interrupt_handler+0xa0>
80005f0c:	30 1a       	mov	r10,1
80005f0e:	93 0a       	st.w	r9[0x0],r10
			twi_inst->idr = ~0UL;
80005f10:	3f fa       	mov	r10,-1
80005f12:	91 aa       	st.w	r8[0x28],r10
			twi_inst->ier = twi_it_mask;
80005f14:	72 09       	ld.w	r9,r9[0x0]
80005f16:	91 99       	st.w	r8[0x24],r9
80005f18:	d6 03       	rete
		} else {
			// put the byte in the Transmit Holding Register
			twi_inst->thr = *twi_tx_data++;
80005f1a:	49 0a       	lddpc	r10,80005f58 <twi_master_interrupt_handler+0xb0>
80005f1c:	74 09       	ld.w	r9,r10[0x0]
80005f1e:	13 3b       	ld.ub	r11,r9++
80005f20:	91 db       	st.w	r8[0x34],r11
80005f22:	95 09       	st.w	r10[0x0],r9
80005f24:	d6 03       	rete
		}
	}
	// this is a TXCOMP
	else if (status & AVR32_TWI_SR_TXCOMP_MASK) {
80005f26:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
80005f2a:	c0 51       	brne	80005f34 <twi_master_interrupt_handler+0x8c>
80005f2c:	d6 03       	rete
	}

	return;

nack:
	twi_nack = true;
80005f2e:	30 1a       	mov	r10,1
80005f30:	48 b9       	lddpc	r9,80005f5c <twi_master_interrupt_handler+0xb4>
80005f32:	b2 8a       	st.b	r9[0x0],r10

complete:
	// disable all interrupts
	twi_inst->idr = ~0UL;
80005f34:	3f f9       	mov	r9,-1
80005f36:	91 a9       	st.w	r8[0x28],r9
	twi_inst->sr;
80005f38:	70 88       	ld.w	r8,r8[0x20]
	twi_busy = false;
80005f3a:	30 09       	mov	r9,0
80005f3c:	48 98       	lddpc	r8,80005f60 <twi_master_interrupt_handler+0xb8>
80005f3e:	b0 89       	st.b	r8[0x0],r9
80005f40:	d6 03       	rete
80005f42:	00 00       	add	r0,r0
80005f44:	00 00       	add	r0,r0
80005f46:	11 3c       	ld.ub	r12,r8++
80005f48:	00 00       	add	r0,r0
80005f4a:	11 38       	ld.ub	r8,r8++
80005f4c:	00 00       	add	r0,r0
80005f4e:	11 48       	ld.w	r8,--r8
80005f50:	00 00       	add	r0,r0
80005f52:	11 44       	ld.w	r4,--r8
80005f54:	00 00       	add	r0,r0
80005f56:	11 34       	ld.ub	r4,r8++
80005f58:	00 00       	add	r0,r0
80005f5a:	11 40       	ld.w	r0,--r8
80005f5c:	00 00       	add	r0,r0
80005f5e:	11 31       	ld.ub	r1,r8++
80005f60:	00 00       	add	r0,r0
80005f62:	11 30       	ld.ub	r0,r8++

80005f64 <twi_master_init>:
	return TWI_SUCCESS;
}


int twi_master_init(volatile avr32_twi_t *twi, const twi_options_t *opt)
{
80005f64:	eb cd 40 e0 	pushm	r5-r7,lr
80005f68:	18 97       	mov	r7,r12
80005f6a:	16 95       	mov	r5,r11
	irqflags_t flags = sysreg_read(AVR32_SR);
80005f6c:	e1 b8 00 00 	mfsr	r8,0x0
	int status = TWI_SUCCESS;

	// Set pointer to TWIM instance for IT
	twi_inst = twi;
80005f70:	49 f9       	lddpc	r9,80005fec <twi_master_init+0x88>
80005f72:	93 0c       	st.w	r9[0x0],r12

	// Disable TWI interrupts
	cpu_irq_disable();
80005f74:	d3 03       	ssrf	0x10
	twi->idr = ~0UL;
80005f76:	3f f9       	mov	r9,-1
80005f78:	99 a9       	st.w	r12[0x28],r9
	twi->sr;
80005f7a:	78 89       	ld.w	r9,r12[0x20]

	// Reset TWI
	twi->cr = AVR32_TWI_CR_SWRST_MASK;
80005f7c:	e0 69 00 80 	mov	r9,128
80005f80:	99 09       	st.w	r12[0x0],r9
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80005f82:	e6 18 00 01 	andh	r8,0x1,COH
80005f86:	c0 21       	brne	80005f8a <twi_master_init+0x26>
      cpu_irq_enable();
80005f88:	d5 03       	csrf	0x10
	cpu_irq_restore(flags);

	// Dummy read in SR
	twi->sr;
80005f8a:	6e 88       	ld.w	r8,r7[0x20]

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80005f8c:	e1 b6 00 00 	mfsr	r6,0x0
	cpu_irq_disable();
80005f90:	d3 03       	ssrf	0x10
	
	// register Register twim_master_interrupt_handler interrupt
	// on level CONF_TWI_IRQ_LEVEL
	flags = cpu_irq_save();

	irq_register_handler(&twi_master_interrupt_handler, CONF_TWI_IRQ_LINE, CONF_TWI_IRQ_LEVEL);
80005f92:	30 3a       	mov	r10,3
80005f94:	e0 6b 01 60 	mov	r11,352
80005f98:	49 6c       	lddpc	r12,80005ff0 <twi_master_init+0x8c>
80005f9a:	f0 1f 00 17 	mcall	80005ff4 <twi_master_init+0x90>
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80005f9e:	e6 16 00 01 	andh	r6,0x1,COH
80005fa2:	c0 21       	brne	80005fa6 <twi_master_init+0x42>
      cpu_irq_enable();
80005fa4:	d5 03       	csrf	0x10
		unsigned long pba_hz)
{
	unsigned int ckdiv = 0;
	unsigned int c_lh_div;

	c_lh_div = pba_hz / (speed * 2) - 4;
80005fa6:	6a 19       	ld.w	r9,r5[0x4]
80005fa8:	a1 79       	lsl	r9,0x1
80005faa:	6a 08       	ld.w	r8,r5[0x0]
80005fac:	f0 09 0d 08 	divu	r8,r8,r9
80005fb0:	20 48       	sub	r8,4

	// cldiv must fit in 8 bits, ckdiv must fit in 3 bits
	while ((c_lh_div > 0xFF) && (ckdiv < 0x7)) {
80005fb2:	e0 48 00 ff 	cp.w	r8,255
80005fb6:	e0 8b 00 04 	brhi	80005fbe <twi_master_init+0x5a>
80005fba:	30 09       	mov	r9,0
80005fbc:	c0 f8       	rjmp	80005fda <twi_master_init+0x76>
80005fbe:	30 09       	mov	r9,0
80005fc0:	30 0c       	mov	r12,0
		// increase clock divider
		ckdiv++;
80005fc2:	2f f9       	sub	r9,-1

		// divide cldiv value
		c_lh_div /= 2;
80005fc4:	a1 98       	lsr	r8,0x1
	unsigned int c_lh_div;

	c_lh_div = pba_hz / (speed * 2) - 4;

	// cldiv must fit in 8 bits, ckdiv must fit in 3 bits
	while ((c_lh_div > 0xFF) && (ckdiv < 0x7)) {
80005fc6:	e0 48 00 ff 	cp.w	r8,255
80005fca:	5f bb       	srhi	r11
80005fcc:	58 69       	cp.w	r9,6
80005fce:	5f 8a       	srls	r10
80005fd0:	f7 ea 00 0a 	and	r10,r11,r10
80005fd4:	f8 0a 18 00 	cp.b	r10,r12
80005fd8:	cf 51       	brne	80005fc2 <twi_master_init+0x5e>
		// divide cldiv value
		c_lh_div /= 2;
	}

	// set clock waveform generator register
	twi->cwgr = ((c_lh_div << AVR32_TWI_CWGR_CLDIV_OFFSET) |
80005fda:	b1 69       	lsl	r9,0x10
80005fdc:	f3 e8 10 89 	or	r9,r9,r8<<0x8
80005fe0:	f3 e8 10 08 	or	r8,r9,r8
80005fe4:	8f 48       	st.w	r7[0x10],r8

	//Probe the component
	//status = twi_probe(twi, opt->chip);

	return status;
}
80005fe6:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
80005fea:	00 00       	add	r0,r0
80005fec:	00 00       	add	r0,r0
80005fee:	11 3c       	ld.ub	r12,r8++
80005ff0:	80 00       	ld.sh	r0,r0[0x0]
80005ff2:	5e a8       	retle	r8
80005ff4:	80 00       	ld.sh	r0,r0[0x0]
80005ff6:	59 c4       	cp.w	r4,28

80005ff8 <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
80005ff8:	d4 01       	pushm	lr
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
80005ffa:	f6 08 15 04 	lsl	r8,r11,0x4
80005ffe:	14 38       	cp.w	r8,r10
80006000:	f9 b8 08 10 	movls	r8,16
80006004:	f9 b8 0b 08 	movhi	r8,8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
80006008:	f0 0b 02 4b 	mul	r11,r8,r11
8000600c:	f6 09 16 01 	lsr	r9,r11,0x1
80006010:	f2 0a 00 3a 	add	r10,r9,r10<<0x3
80006014:	f4 0b 0d 0a 	divu	r10,r10,r11
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
80006018:	f4 09 16 03 	lsr	r9,r10,0x3
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
8000601c:	f2 cb 00 01 	sub	r11,r9,1
80006020:	e0 4b ff fe 	cp.w	r11,65534
80006024:	e0 88 00 03 	brls	8000602a <usart_set_async_baudrate+0x32>
80006028:	da 0a       	popm	pc,r12=1
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
8000602a:	78 1b       	ld.w	r11,r12[0x4]
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
8000602c:	e8 6e 00 00 	mov	lr,524288
80006030:	59 08       	cp.w	r8,16
80006032:	fc 08 17 10 	movne	r8,lr
80006036:	f9 b8 00 00 	moveq	r8,0
8000603a:	e4 1b ff f7 	andh	r11,0xfff7
8000603e:	e0 1b fe cf 	andl	r11,0xfecf
80006042:	16 48       	or	r8,r11
80006044:	99 18       	st.w	r12[0x4],r8
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
80006046:	f5 da c0 03 	bfextu	r10,r10,0x0,0x3
8000604a:	f3 ea 11 09 	or	r9,r9,r10<<0x10
8000604e:	99 89       	st.w	r12[0x20],r9
80006050:	d8 0a       	popm	pc,r12=0

80006052 <usart_write_char>:
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
80006052:	78 58       	ld.w	r8,r12[0x14]
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
  if (usart_tx_ready(usart))
80006054:	e2 18 00 02 	andl	r8,0x2,COH
80006058:	c0 31       	brne	8000605e <usart_write_char+0xc>
8000605a:	30 2c       	mov	r12,2
8000605c:	5e fc       	retal	r12
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
8000605e:	f7 db c0 09 	bfextu	r11,r11,0x0,0x9
80006062:	99 7b       	st.w	r12[0x1c],r11
80006064:	5e fd       	retal	0
80006066:	d7 03       	nop

80006068 <usart_putchar>:
    return USART_TX_BUSY;
}


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
80006068:	eb cd 40 e0 	pushm	r5-r7,lr
8000606c:	18 96       	mov	r6,r12
8000606e:	16 95       	mov	r5,r11
80006070:	e0 67 27 0f 	mov	r7,9999
80006074:	c0 68       	rjmp	80006080 <usart_putchar+0x18>
  int timeout = USART_DEFAULT_TIMEOUT;

  do
  {
    if (!timeout--) return USART_FAILURE;
80006076:	58 07       	cp.w	r7,0
80006078:	c0 31       	brne	8000607e <usart_putchar+0x16>
8000607a:	e3 cf c0 e0 	ldm	sp++,r5-r7,pc,r12=-1
8000607e:	20 17       	sub	r7,1
  } while (usart_write_char(usart, c) != USART_SUCCESS);
80006080:	0a 9b       	mov	r11,r5
80006082:	0c 9c       	mov	r12,r6
80006084:	f0 1f 00 03 	mcall	80006090 <usart_putchar+0x28>
80006088:	cf 71       	brne	80006076 <usart_putchar+0xe>

  return USART_SUCCESS;
}
8000608a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000608e:	00 00       	add	r0,r0
80006090:	80 00       	ld.sh	r0,r0[0x0]
80006092:	60 52       	ld.w	r2,r0[0x14]

80006094 <usart_read_char>:

int usart_read_char(volatile avr32_usart_t *usart, int *c)
{
  // Check for errors: frame, parity and overrun. In RS485 mode, a parity error
  // would mean that an address char has been received.
  if (usart->csr & (AVR32_USART_CSR_OVRE_MASK |
80006094:	78 58       	ld.w	r8,r12[0x14]
80006096:	e2 18 00 e0 	andl	r8,0xe0,COH
8000609a:	c0 30       	breq	800060a0 <usart_read_char+0xc>
8000609c:	30 4c       	mov	r12,4
8000609e:	5e fc       	retal	r12
 *
 * \return \c 1 if the USART Receive Holding Register is full, otherwise \c 0.
 */
__always_inline static int usart_test_hit(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_RXRDY_MASK) != 0;
800060a0:	78 58       	ld.w	r8,r12[0x14]
                    AVR32_USART_CSR_FRAME_MASK |
                    AVR32_USART_CSR_PARE_MASK))
    return USART_RX_ERROR;

  // No error; if we really did receive a char, read it and return SUCCESS.
  if (usart_test_hit(usart))
800060a2:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800060a6:	c0 31       	brne	800060ac <usart_read_char+0x18>
800060a8:	30 3c       	mov	r12,3
800060aa:	5e fc       	retal	r12
  {
    *c = (usart->rhr & AVR32_USART_RHR_RXCHR_MASK) >> AVR32_USART_RHR_RXCHR_OFFSET;
800060ac:	78 68       	ld.w	r8,r12[0x18]
800060ae:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
800060b2:	97 08       	st.w	r11[0x0],r8
800060b4:	5e fd       	retal	0
800060b6:	d7 03       	nop

800060b8 <usart_getchar>:
    return USART_RX_EMPTY;
}


int usart_getchar(volatile avr32_usart_t *usart)
{
800060b8:	eb cd 40 c0 	pushm	r6-r7,lr
800060bc:	20 1d       	sub	sp,4
800060be:	18 96       	mov	r6,r12
  int c, ret;

  while ((ret = usart_read_char(usart, &c)) == USART_RX_EMPTY);
800060c0:	1a 97       	mov	r7,sp
800060c2:	1a 9b       	mov	r11,sp
800060c4:	0c 9c       	mov	r12,r6
800060c6:	f0 1f 00 07 	mcall	800060e0 <usart_getchar+0x28>
800060ca:	58 3c       	cp.w	r12,3
800060cc:	cf b0       	breq	800060c2 <usart_getchar+0xa>

  if (ret == USART_RX_ERROR)
800060ce:	58 4c       	cp.w	r12,4
800060d0:	f9 bc 00 ff 	moveq	r12,-1
    return USART_FAILURE;

  return c;
800060d4:	fb fc 10 00 	ld.wne	r12,sp[0x0]
}
800060d8:	2f fd       	sub	sp,-4
800060da:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800060de:	00 00       	add	r0,r0
800060e0:	80 00       	ld.sh	r0,r0[0x0]
800060e2:	60 94       	ld.w	r4,r0[0x24]

800060e4 <usart_write_line>:


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
800060e4:	eb cd 40 c0 	pushm	r6-r7,lr
800060e8:	18 96       	mov	r6,r12
800060ea:	16 97       	mov	r7,r11
  while (*string != '\0')
800060ec:	17 8b       	ld.ub	r11,r11[0x0]
800060ee:	58 0b       	cp.w	r11,0
800060f0:	c0 80       	breq	80006100 <usart_write_line+0x1c>
    usart_putchar(usart, *string++);
800060f2:	2f f7       	sub	r7,-1
800060f4:	0c 9c       	mov	r12,r6
800060f6:	f0 1f 00 04 	mcall	80006104 <usart_write_line+0x20>
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
800060fa:	0f 8b       	ld.ub	r11,r7[0x0]
800060fc:	58 0b       	cp.w	r11,0
800060fe:	cf a1       	brne	800060f2 <usart_write_line+0xe>
80006100:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006104:	80 00       	ld.sh	r0,r0[0x0]
80006106:	60 68       	ld.w	r8,r0[0x18]

80006108 <usart_reset>:
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
80006108:	e1 b8 00 00 	mfsr	r8,0x0

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
8000610c:	e6 18 00 01 	andh	r8,0x1,COH
80006110:	c0 71       	brne	8000611e <usart_reset+0x16>
80006112:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
80006114:	3f f8       	mov	r8,-1
80006116:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80006118:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
8000611a:	d5 03       	csrf	0x10
8000611c:	c0 48       	rjmp	80006124 <usart_reset+0x1c>
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
  usart->idr = 0xFFFFFFFF;
8000611e:	3f f8       	mov	r8,-1
80006120:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80006122:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
80006124:	30 08       	mov	r8,0
80006126:	99 18       	st.w	r12[0x4],r8
  usart->rtor = 0;
80006128:	99 98       	st.w	r12[0x24],r8
  usart->ttgr = 0;
8000612a:	99 a8       	st.w	r12[0x28],r8

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
8000612c:	ea 68 61 0c 	mov	r8,680204
80006130:	99 08       	st.w	r12[0x0],r8
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
80006132:	5e fc       	retal	r12

80006134 <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
80006134:	eb cd 40 e0 	pushm	r5-r7,lr
80006138:	18 96       	mov	r6,r12
8000613a:	16 97       	mov	r7,r11
8000613c:	14 95       	mov	r5,r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
8000613e:	f0 1f 00 2f 	mcall	800061f8 <usart_init_rs232+0xc4>

  // Check input values.
  if (!opt || // Null pointer.
80006142:	58 07       	cp.w	r7,0
80006144:	c5 80       	breq	800061f4 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
80006146:	0f c8       	ld.ub	r8,r7[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80006148:	30 49       	mov	r9,4
8000614a:	f2 08 18 00 	cp.b	r8,r9
8000614e:	e0 88 00 53 	brls	800061f4 <usart_init_rs232+0xc0>
80006152:	30 99       	mov	r9,9
80006154:	f2 08 18 00 	cp.b	r8,r9
80006158:	e0 8b 00 4e 	brhi	800061f4 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
8000615c:	0f d9       	ld.ub	r9,r7[0x5]
8000615e:	30 78       	mov	r8,7
80006160:	f0 09 18 00 	cp.b	r9,r8
80006164:	e0 8b 00 48 	brhi	800061f4 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
80006168:	8e 39       	ld.sh	r9,r7[0x6]
8000616a:	e0 68 01 01 	mov	r8,257
8000616e:	f0 09 19 00 	cp.h	r9,r8
80006172:	e0 8b 00 41 	brhi	800061f4 <usart_init_rs232+0xc0>
      opt->channelmode > 3 ||
80006176:	ef 39 00 08 	ld.ub	r9,r7[8]
8000617a:	30 38       	mov	r8,3
8000617c:	f0 09 18 00 	cp.b	r9,r8
80006180:	e0 8b 00 3a 	brhi	800061f4 <usart_init_rs232+0xc0>
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
80006184:	0a 9a       	mov	r10,r5
80006186:	6e 0b       	ld.w	r11,r7[0x0]
80006188:	0c 9c       	mov	r12,r6
8000618a:	f0 1f 00 1d 	mcall	800061fc <usart_init_rs232+0xc8>
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
8000618e:	58 1c       	cp.w	r12,1
80006190:	c3 20       	breq	800061f4 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;

  if (opt->charlength == 9)
80006192:	0f c8       	ld.ub	r8,r7[0x4]
80006194:	30 99       	mov	r9,9
80006196:	f2 08 18 00 	cp.b	r8,r9
8000619a:	c0 51       	brne	800061a4 <usart_init_rs232+0x70>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
8000619c:	6c 18       	ld.w	r8,r6[0x4]
8000619e:	b1 b8       	sbr	r8,0x11
800061a0:	8d 18       	st.w	r6[0x4],r8
800061a2:	c0 68       	rjmp	800061ae <usart_init_rs232+0x7a>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
800061a4:	6c 19       	ld.w	r9,r6[0x4]
800061a6:	20 58       	sub	r8,5
800061a8:	f3 e8 10 68 	or	r8,r9,r8<<0x6
800061ac:	8d 18       	st.w	r6[0x4],r8
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
800061ae:	6c 19       	ld.w	r9,r6[0x4]
800061b0:	ef 3a 00 08 	ld.ub	r10,r7[8]
800061b4:	0f d8       	ld.ub	r8,r7[0x5]
800061b6:	a9 78       	lsl	r8,0x9
800061b8:	f1 ea 10 e8 	or	r8,r8,r10<<0xe
800061bc:	12 48       	or	r8,r9
800061be:	8d 18       	st.w	r6[0x4],r8
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
800061c0:	8e 38       	ld.sh	r8,r7[0x6]
800061c2:	30 29       	mov	r9,2
800061c4:	f2 08 19 00 	cp.h	r8,r9
800061c8:	e0 88 00 09 	brls	800061da <usart_init_rs232+0xa6>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
800061cc:	6c 18       	ld.w	r8,r6[0x4]
800061ce:	ad b8       	sbr	r8,0xd
800061d0:	8d 18       	st.w	r6[0x4],r8
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
800061d2:	8e b8       	ld.uh	r8,r7[0x6]
800061d4:	20 28       	sub	r8,2
800061d6:	8d a8       	st.w	r6[0x28],r8
800061d8:	c0 68       	rjmp	800061e4 <usart_init_rs232+0xb0>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
800061da:	6c 19       	ld.w	r9,r6[0x4]
800061dc:	5c 78       	castu.h	r8
800061de:	f3 e8 10 c8 	or	r8,r9,r8<<0xc
800061e2:	8d 18       	st.w	r6[0x4],r8

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
800061e4:	6c 18       	ld.w	r8,r6[0x4]
800061e6:	e0 18 ff f0 	andl	r8,0xfff0
800061ea:	8d 18       	st.w	r6[0x4],r8
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
800061ec:	35 08       	mov	r8,80
800061ee:	8d 08       	st.w	r6[0x0],r8
800061f0:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
800061f4:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
800061f8:	80 00       	ld.sh	r0,r0[0x0]
800061fa:	61 08       	ld.w	r8,r0[0x40]
800061fc:	80 00       	ld.sh	r0,r0[0x0]
800061fe:	5f f8       	sral	r8

80006200 <disk_status>:


	return RES_OK;

	
}
80006200:	5e fd       	retal	0

80006202 <disk_initialize>:
	//}
	//return STA_NOINIT;

	return stat;
	
}
80006202:	5e fd       	retal	0

80006204 <get_fattime>:
	
}
#endif

DWORD get_fattime(void)
{
80006204:	d4 01       	pushm	lr
	DWORD current_time = 0;
	date_time_t *t = now();
80006206:	f0 1f 00 0e 	mcall	8000623c <get_fattime+0x38>

	current_time = (t->year - 1980) << 25;
8000620a:	19 89       	ld.ub	r9,r12[0x0]
8000620c:	19 98       	ld.ub	r8,r12[0x1]
8000620e:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80006212:	f0 c8 07 bc 	sub	r8,r8,1980
80006216:	b9 78       	lsl	r8,0x19
	current_time += t->month << 21;
80006218:	19 aa       	ld.ub	r10,r12[0x2]
8000621a:	b5 7a       	lsl	r10,0x15
8000621c:	19 b9       	ld.ub	r9,r12[0x3]
8000621e:	b1 69       	lsl	r9,0x10
80006220:	12 0a       	add	r10,r9
	current_time += t->day << 16;
80006222:	19 f9       	ld.ub	r9,r12[0x7]
80006224:	a1 99       	lsr	r9,0x1
80006226:	12 0a       	add	r10,r9
	current_time += t->hour << 11;
80006228:	19 d9       	ld.ub	r9,r12[0x5]
8000622a:	ab 79       	lsl	r9,0xb
8000622c:	12 0a       	add	r10,r9
	current_time += t->minute << 5;
8000622e:	19 e9       	ld.ub	r9,r12[0x6]
80006230:	a5 79       	lsl	r9,0x5
80006232:	f4 09 00 0c 	add	r12,r10,r9
	current_time += t->second / 2;
	
	return current_time;
80006236:	10 0c       	add	r12,r8
80006238:	d8 02       	popm	pc
8000623a:	00 00       	add	r0,r0
8000623c:	80 00       	ld.sh	r0,r0[0x0]
8000623e:	58 5c       	cp.w	r12,5

80006240 <disk_ioctl>:
DRESULT disk_ioctl (
	BYTE pdrv,		/* Physical drive nmuber (0..) */
	BYTE cmd,		/* Control code */
	void *buff		/* Buffer to send/receive control data */
)
{
80006240:	eb cd 40 80 	pushm	r7,lr
80006244:	14 97       	mov	r7,r10
	
	DRESULT res = RES_OK ;
	
	switch (cmd)
80006246:	30 18       	mov	r8,1
80006248:	f0 0b 18 00 	cp.b	r11,r8
8000624c:	c1 a0       	breq	80006280 <disk_ioctl+0x40>
8000624e:	58 0b       	cp.w	r11,0
80006250:	c0 c0       	breq	80006268 <disk_ioctl+0x28>
80006252:	30 28       	mov	r8,2
80006254:	f0 0b 18 00 	cp.b	r11,r8
80006258:	c0 a0       	breq	8000626c <disk_ioctl+0x2c>
8000625a:	30 38       	mov	r8,3
8000625c:	f0 0b 18 00 	cp.b	r11,r8
80006260:	c0 b0       	breq	80006276 <disk_ioctl+0x36>
80006262:	30 4c       	mov	r12,4
80006264:	e3 cd 80 80 	ldm	sp++,r7,pc
80006268:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
	  
			break;
	  
		case GET_SECTOR_SIZE:
		
			*(WORD*)buff = 512;
8000626c:	e0 68 02 00 	mov	r8,512
80006270:	b4 08       	st.h	r10[0x0],r8
80006272:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
		
			break;	
		
		case GET_BLOCK_SIZE:
		
			*(WORD*)buff = 512;
80006276:	e0 68 02 00 	mov	r8,512
8000627a:	b4 08       	st.h	r10[0x0],r8
8000627c:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
		
			break;
		
		case GET_SECTOR_COUNT:
		
			*(DWORD*)buff = SD_GetSectorCount();
80006280:	f0 1f 00 03 	mcall	8000628c <disk_ioctl+0x4c>
80006284:	8f 0c       	st.w	r7[0x0],r12
80006286:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
8000628a:	00 00       	add	r0,r0
8000628c:	80 00       	ld.sh	r0,r0[0x0]
8000628e:	34 94       	mov	r4,73

80006290 <disk_write>:
	BYTE pdrv,			/* Physical drive nmuber to identify the drive */
	const BYTE *buff,	/* Data to be written */
	DWORD sector,		/* Sector address in LBA */
	UINT count			/* Number of sectors to write */
)
{
80006290:	d4 01       	pushm	lr
80006292:	16 9c       	mov	r12,r11
80006294:	14 9b       	mov	r11,r10


	*******************************/

	
	 if(MAL_WriteDisk(buff, sector, BLOCK_BYTE_SIZE, count)==WRITE_DATA_SUCCESS)
80006296:	5c 59       	castu.b	r9
80006298:	e0 6a 02 00 	mov	r10,512
8000629c:	f0 1f 00 03 	mcall	800062a8 <disk_write+0x18>
800062a0:	58 4c       	cp.w	r12,4
	 return RES_ERROR;
	



}
800062a2:	5f 1c       	srne	r12
800062a4:	d8 02       	popm	pc
800062a6:	00 00       	add	r0,r0
800062a8:	80 00       	ld.sh	r0,r0[0x0]
800062aa:	34 b4       	mov	r4,75

800062ac <disk_read>:
	BYTE pdrv,		/* Physical drive nmuber to identify the drive */
	BYTE *buff,		/* Data buffer to store read data */
	DWORD sector,	/* Sector address in LBA */
	UINT count		/* Number of sectors to read */
)
{
800062ac:	d4 01       	pushm	lr
800062ae:	16 9c       	mov	r12,r11
800062b0:	14 9b       	mov	r11,r10

	***********************************/

	

	if(MAL_ReadDisk(buff, sector, BLOCK_BYTE_SIZE, count)==READ_DATA_SUCCESS)
800062b2:	5c 59       	castu.b	r9
800062b4:	e0 6a 02 00 	mov	r10,512
800062b8:	f0 1f 00 03 	mcall	800062c4 <disk_read+0x18>
800062bc:	58 8c       	cp.w	r12,8
   		return RES_ERROR;




}
800062be:	5f 1c       	srne	r12
800062c0:	d8 02       	popm	pc
800062c2:	00 00       	add	r0,r0
800062c4:	80 00       	ld.sh	r0,r0[0x0]
800062c6:	34 e4       	mov	r4,78

800062c8 <mem_cpy>:
		*(int*)d = *(int*)s;
		d += sizeof (int); s += sizeof (int);
		cnt -= sizeof (int);
	}
#endif
	while (cnt--)
800062c8:	58 0a       	cp.w	r10,0
800062ca:	5e 0c       	reteq	r12
800062cc:	30 08       	mov	r8,0
		*d++ = *s++;
800062ce:	f6 08 07 09 	ld.ub	r9,r11[r8]
800062d2:	f8 08 0b 09 	st.b	r12[r8],r9
800062d6:	2f f8       	sub	r8,-1
		*(int*)d = *(int*)s;
		d += sizeof (int); s += sizeof (int);
		cnt -= sizeof (int);
	}
#endif
	while (cnt--)
800062d8:	14 38       	cp.w	r8,r10
800062da:	cf a1       	brne	800062ce <mem_cpy+0x6>
800062dc:	5e fc       	retal	r12

800062de <mem_set>:
/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
800062de:	58 0a       	cp.w	r10,0
800062e0:	5e 0c       	reteq	r12
		*d++ = (BYTE)val;
800062e2:	18 cb       	st.b	r12++,r11
800062e4:	20 1a       	sub	r10,1
/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
800062e6:	cf e1       	brne	800062e2 <mem_set+0x4>
800062e8:	5e fc       	retal	r12

800062ea <chk_chr>:
	return r;
}

/* Check if chr is contained in the string */
static
int chk_chr (const char* str, int chr) {
800062ea:	18 98       	mov	r8,r12
	while (*str && *str != chr) str++;
800062ec:	19 8c       	ld.ub	r12,r12[0x0]
800062ee:	58 0c       	cp.w	r12,0
800062f0:	5e 0c       	reteq	r12
800062f2:	16 3c       	cp.w	r12,r11
800062f4:	5e 0c       	reteq	r12
800062f6:	2f f8       	sub	r8,-1
800062f8:	11 8c       	ld.ub	r12,r8[0x0]
800062fa:	58 0c       	cp.w	r12,0
800062fc:	5e 0c       	reteq	r12
800062fe:	16 3c       	cp.w	r12,r11
80006300:	cf b1       	brne	800062f6 <chk_chr+0xc>
	return *str;
}
80006302:	5e fc       	retal	r12

80006304 <clust2sect>:
DWORD clust2sect (	/* !=0:Sector number, 0:Failed (invalid cluster#) */
	FATFS* fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
80006304:	20 2b       	sub	r11,2
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
80006306:	78 58       	ld.w	r8,r12[0x14]
80006308:	20 28       	sub	r8,2
8000630a:	10 3b       	cp.w	r11,r8
8000630c:	c0 23       	brcs	80006310 <clust2sect+0xc>
8000630e:	5e fd       	retal	0
	return clst * fs->csize + fs->database;
80006310:	19 a8       	ld.ub	r8,r12[0x2]
80006312:	b1 3b       	mul	r11,r8
80006314:	78 a8       	ld.w	r8,r12[0x28]
80006316:	f6 08 00 0c 	add	r12,r11,r8
}
8000631a:	5e fc       	retal	r12

8000631c <clmt_clust>:
)
{
	DWORD cl, ncl, *tbl;


	tbl = fp->cltbl + 1;	/* Top of CLMT */
8000631c:	78 9a       	ld.w	r10,r12[0x24]
8000631e:	2f ca       	sub	r10,-4
	cl = ofs / SS(fp->fs) / fp->fs->csize;	/* Cluster order from top of the file */
80006320:	78 08       	ld.w	r8,r12[0x0]
80006322:	11 a8       	ld.ub	r8,r8[0x2]
	for (;;) {
		ncl = *tbl++;			/* Number of cluters in the fragment */
80006324:	74 0c       	ld.w	r12,r10[0x0]
		if (!ncl) return 0;		/* End of table? (error) */
80006326:	58 0c       	cp.w	r12,0
80006328:	c1 80       	breq	80006358 <clmt_clust+0x3c>
{
	DWORD cl, ncl, *tbl;


	tbl = fp->cltbl + 1;	/* Top of CLMT */
	cl = ofs / SS(fp->fs) / fp->fs->csize;	/* Cluster order from top of the file */
8000632a:	f6 09 16 09 	lsr	r9,r11,0x9
8000632e:	f2 08 0d 08 	divu	r8,r9,r8
80006332:	10 99       	mov	r9,r8
	for (;;) {
		ncl = *tbl++;			/* Number of cluters in the fragment */
80006334:	2f ca       	sub	r10,-4
		if (!ncl) return 0;		/* End of table? (error) */
		if (cl < ncl) break;	/* In this fragment? */
80006336:	18 38       	cp.w	r8,r12
80006338:	c0 82       	brcc	80006348 <clmt_clust+0x2c>
8000633a:	c0 b8       	rjmp	80006350 <clmt_clust+0x34>
		cl -= ncl; tbl++;		/* Next fragment */
8000633c:	18 19       	sub	r9,r12
/* FAT handling - Convert offset into cluster with link map table        */
/*-----------------------------------------------------------------------*/

#if _USE_FASTSEEK
static
DWORD clmt_clust (	/* <2:Error, >=2:Cluster number */
8000633e:	2f 8a       	sub	r10,-8
	tbl = fp->cltbl + 1;	/* Top of CLMT */
	cl = ofs / SS(fp->fs) / fp->fs->csize;	/* Cluster order from top of the file */
	for (;;) {
		ncl = *tbl++;			/* Number of cluters in the fragment */
		if (!ncl) return 0;		/* End of table? (error) */
		if (cl < ncl) break;	/* In this fragment? */
80006340:	12 38       	cp.w	r8,r9
80006342:	e0 8b 00 07 	brhi	80006350 <clmt_clust+0x34>
80006346:	10 9c       	mov	r12,r8


	tbl = fp->cltbl + 1;	/* Top of CLMT */
	cl = ofs / SS(fp->fs) / fp->fs->csize;	/* Cluster order from top of the file */
	for (;;) {
		ncl = *tbl++;			/* Number of cluters in the fragment */
80006348:	74 18       	ld.w	r8,r10[0x4]
		if (!ncl) return 0;		/* End of table? (error) */
8000634a:	58 08       	cp.w	r8,0
8000634c:	cf 81       	brne	8000633c <clmt_clust+0x20>
8000634e:	c0 58       	rjmp	80006358 <clmt_clust+0x3c>
		if (cl < ncl) break;	/* In this fragment? */
		cl -= ncl; tbl++;		/* Next fragment */
	}
	return cl + *tbl;	/* Return the cluster number */
80006350:	74 0c       	ld.w	r12,r10[0x0]
80006352:	f2 0c 00 0c 	add	r12,r9,r12
80006356:	5e fc       	retal	r12
80006358:	5e fd       	retal	0

8000635a <ld_clust>:
	const BYTE* dir	/* Pointer to the SFN entry */
)
{
	DWORD cl;

	cl = LD_WORD(dir + DIR_FstClusLO);
8000635a:	f7 39 00 1b 	ld.ub	r9,r11[27]
8000635e:	f7 38 00 1a 	ld.ub	r8,r11[26]
80006362:	f1 e9 10 88 	or	r8,r8,r9<<0x8
	if (fs->fs_type == FS_FAT32)
80006366:	19 8a       	ld.ub	r10,r12[0x0]
80006368:	30 39       	mov	r9,3
8000636a:	f2 0a 18 00 	cp.b	r10,r9
8000636e:	c0 91       	brne	80006380 <ld_clust+0x26>
		cl |= (DWORD)LD_WORD(dir + DIR_FstClusHI) << 16;
80006370:	f7 3a 00 15 	ld.ub	r10,r11[21]
80006374:	f7 39 00 14 	ld.ub	r9,r11[20]
80006378:	f3 ea 10 89 	or	r9,r9,r10<<0x8
8000637c:	f1 e9 11 08 	or	r8,r8,r9<<0x10

	return cl;
}
80006380:	5e f8       	retal	r8

80006382 <st_clust>:
void st_clust (
	BYTE* dir,	/* Pointer to the SFN entry */
	DWORD cl	/* Value to be set */
)
{
	ST_WORD(dir + DIR_FstClusLO, cl);
80006382:	f9 6b 00 1a 	st.b	r12[26],r11
80006386:	f1 db c1 08 	bfextu	r8,r11,0x8,0x8
8000638a:	f9 68 00 1b 	st.b	r12[27],r8
	ST_WORD(dir + DIR_FstClusHI, cl >> 16);
8000638e:	b1 8b       	lsr	r11,0x10
80006390:	f9 6b 00 14 	st.b	r12[20],r11
80006394:	a9 8b       	lsr	r11,0x8
80006396:	f9 6b 00 15 	st.b	r12[21],r11
}
8000639a:	5e fc       	retal	r12

8000639c <get_ldnumber>:

static
int get_ldnumber (		/* Returns logical drive number (-1:invalid drive) */
	const TCHAR** path	/* Pointer to pointer to the path name */
)
{
8000639c:	d4 21       	pushm	r4-r7,lr
	char c;
	TCHAR tc;
#endif


	if (*path) {	/* If the pointer is not a null */
8000639e:	78 05       	ld.w	r5,r12[0x0]
800063a0:	58 05       	cp.w	r5,0
800063a2:	c5 50       	breq	8000644c <get_ldnumber+0xb0>
		for (tt = *path; (UINT)*tt >= (_USE_LFN ? ' ' : '!') && *tt != ':'; tt++) ;	/* Find ':' in the path */
800063a4:	0b 84       	ld.ub	r4,r5[0x0]
800063a6:	32 08       	mov	r8,32
800063a8:	f0 04 18 00 	cp.b	r4,r8
800063ac:	5f b9       	srhi	r9
800063ae:	33 a8       	mov	r8,58
800063b0:	f0 04 18 00 	cp.b	r4,r8
800063b4:	5f 18       	srne	r8
800063b6:	f3 e8 00 08 	and	r8,r9,r8
800063ba:	c0 41       	brne	800063c2 <get_ldnumber+0x26>
800063bc:	08 99       	mov	r9,r4
800063be:	0a 98       	mov	r8,r5
800063c0:	c1 28       	rjmp	800063e4 <get_ldnumber+0x48>
800063c2:	0a 98       	mov	r8,r5
800063c4:	32 06       	mov	r6,32
800063c6:	33 a7       	mov	r7,58
800063c8:	30 0e       	mov	lr,0
800063ca:	2f f8       	sub	r8,-1
800063cc:	11 89       	ld.ub	r9,r8[0x0]
800063ce:	ec 09 18 00 	cp.b	r9,r6
800063d2:	5f bb       	srhi	r11
800063d4:	ee 09 18 00 	cp.b	r9,r7
800063d8:	5f 1a       	srne	r10
800063da:	f7 ea 00 0a 	and	r10,r11,r10
800063de:	fc 0a 18 00 	cp.b	r10,lr
800063e2:	cf 41       	brne	800063ca <get_ldnumber+0x2e>
		if (*tt == ':') {	/* If a ':' is exist in the path name */
800063e4:	33 aa       	mov	r10,58
800063e6:	f4 09 18 00 	cp.b	r9,r10
800063ea:	c0 30       	breq	800063f0 <get_ldnumber+0x54>
800063ec:	30 04       	mov	r4,0
800063ee:	c3 08       	rjmp	8000644e <get_ldnumber+0xb2>
			tp = *path;
			i = *tp++ - '0'; 
800063f0:	23 04       	sub	r4,48
			if (i < 10 && tp == tt) {	/* Is there a numeric drive id? */
800063f2:	58 94       	cp.w	r4,9
800063f4:	5f 8a       	srls	r10
800063f6:	ea c9 ff ff 	sub	r9,r5,-1
800063fa:	12 38       	cp.w	r8,r9
800063fc:	5f 09       	sreq	r9
800063fe:	f5 e9 00 09 	and	r9,r10,r9
80006402:	c0 60       	breq	8000640e <get_ldnumber+0x72>
				if (i < _VOLUMES) {	/* If a drive id is found, get the value and strip it */
80006404:	58 04       	cp.w	r4,0
80006406:	c2 31       	brne	8000644c <get_ldnumber+0xb0>
					vol = (int)i;
					*path = ++tt;
80006408:	2f f8       	sub	r8,-1
8000640a:	99 08       	st.w	r12[0x0],r8
8000640c:	c2 18       	rjmp	8000644e <get_ldnumber+0xb2>
				}
			}
#if _STR_VOLUME_ID
			 else {	/* No numeric drive number, find string drive id */
				i = 0; tt++;
8000640e:	2f f8       	sub	r8,-1
				do {
					sp = str[i]; tp = *path;
80006410:	49 17       	lddpc	r7,80006454 <get_ldnumber+0xb8>
					do {	/* Compare a string drive id with path name */
						c = *sp++; tc = *tp++;
						if (IsLower(tc)) tc -= 0x20;
80006412:	31 96       	mov	r6,25
					} while (c && (TCHAR)c == tc);
80006414:	30 0e       	mov	lr,0
			 else {	/* No numeric drive number, find string drive id */
				i = 0; tt++;
				do {
					sp = str[i]; tp = *path;
					do {	/* Compare a string drive id with path name */
						c = *sp++; tc = *tp++;
80006416:	0f 3a       	ld.ub	r10,r7++
80006418:	0b 39       	ld.ub	r9,r5++
						if (IsLower(tc)) tc -= 0x20;
8000641a:	f2 cb 00 61 	sub	r11,r9,97
8000641e:	ec 0b 18 00 	cp.b	r11,r6
80006422:	e0 8b 00 03 	brhi	80006428 <get_ldnumber+0x8c>
80006426:	22 09       	sub	r9,32
					} while (c && (TCHAR)c == tc);
80006428:	fc 0a 18 00 	cp.b	r10,lr
8000642c:	5f 1b       	srne	r11
8000642e:	f2 0a 18 00 	cp.b	r10,r9
80006432:	5f 09       	sreq	r9
80006434:	f7 e9 00 09 	and	r9,r11,r9
80006438:	fc 09 18 00 	cp.b	r9,lr
8000643c:	ce d1       	brne	80006416 <get_ldnumber+0x7a>
				} while ((c || tp != tt) && ++i < _VOLUMES);	/* Repeat for each id until pattern match */
				if (i < _VOLUMES) {	/* If a drive id is found, get the value and strip it */
8000643e:	10 35       	cp.w	r5,r8
80006440:	5f 19       	srne	r9
80006442:	12 4b       	or	r11,r9
80006444:	c0 41       	brne	8000644c <get_ldnumber+0xb0>
					vol = (int)i;
					*path = tt;
80006446:	99 08       	st.w	r12[0x0],r8
80006448:	30 04       	mov	r4,0
8000644a:	c0 28       	rjmp	8000644e <get_ldnumber+0xb2>
8000644c:	3f f4       	mov	r4,-1
#else
		vol = 0;		/* Drive 0 */
#endif
	}
	return vol;
}
8000644e:	08 9c       	mov	r12,r4
80006450:	d8 22       	popm	r4-r7,pc
80006452:	00 00       	add	r0,r0
80006454:	80 01       	ld.sh	r1,r0[0x0]
80006456:	8b 80       	st.w	r5[0x20],r0

80006458 <sync_window>:
#if !_FS_READONLY
static
FRESULT sync_window (	/* FR_OK:succeeded, !=0:error */
	FATFS* fs		/* File system object */
)
{
80006458:	eb cd 40 f8 	pushm	r3-r7,lr
8000645c:	18 97       	mov	r7,r12
	DWORD wsect;
	UINT nf;
	FRESULT res = FR_OK;


	if (fs->wflag) {	/* Write back the sector if it is dirty */
8000645e:	19 c9       	ld.ub	r9,r12[0x4]
80006460:	30 08       	mov	r8,0
80006462:	f0 09 18 00 	cp.b	r9,r8
80006466:	c2 60       	breq	800064b2 <sync_window+0x5a>
		wsect = fs->winsect;	/* Current sector number */
80006468:	78 b6       	ld.w	r6,r12[0x2c]
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK) {
8000646a:	f8 c4 ff d0 	sub	r4,r12,-48
8000646e:	30 19       	mov	r9,1
80006470:	0c 9a       	mov	r10,r6
80006472:	08 9b       	mov	r11,r4
80006474:	19 9c       	ld.ub	r12,r12[0x1]
80006476:	f0 1f 00 11 	mcall	800064b8 <sync_window+0x60>
8000647a:	c0 30       	breq	80006480 <sync_window+0x28>
8000647c:	e3 cf 90 f8 	ldm	sp++,r3-r7,pc,r12=1
			res = FR_DISK_ERR;
		} else {
			fs->wflag = 0;
80006480:	30 08       	mov	r8,0
80006482:	ae c8       	st.b	r7[0x4],r8
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
80006484:	6e 89       	ld.w	r9,r7[0x20]
80006486:	ec 09 01 09 	sub	r9,r6,r9
8000648a:	6e 68       	ld.w	r8,r7[0x18]
8000648c:	10 39       	cp.w	r9,r8
8000648e:	c1 22       	brcc	800064b2 <sync_window+0x5a>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
80006490:	0f b5       	ld.ub	r5,r7[0x3]
80006492:	58 15       	cp.w	r5,1
80006494:	e0 88 00 0f 	brls	800064b2 <sync_window+0x5a>
					wsect += fs->fsize;
					disk_write(fs->drv, fs->win, wsect, 1);
80006498:	30 13       	mov	r3,1
			res = FR_DISK_ERR;
		} else {
			fs->wflag = 0;
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
					wsect += fs->fsize;
8000649a:	6e 68       	ld.w	r8,r7[0x18]
8000649c:	10 06       	add	r6,r8
					disk_write(fs->drv, fs->win, wsect, 1);
8000649e:	06 99       	mov	r9,r3
800064a0:	0c 9a       	mov	r10,r6
800064a2:	08 9b       	mov	r11,r4
800064a4:	0f 9c       	ld.ub	r12,r7[0x1]
800064a6:	f0 1f 00 05 	mcall	800064b8 <sync_window+0x60>
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK) {
			res = FR_DISK_ERR;
		} else {
			fs->wflag = 0;
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
800064aa:	20 15       	sub	r5,1
800064ac:	58 15       	cp.w	r5,1
800064ae:	fe 9b ff f6 	brhi	8000649a <sync_window+0x42>
800064b2:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
800064b6:	00 00       	add	r0,r0
800064b8:	80 00       	ld.sh	r0,r0[0x0]
800064ba:	62 90       	ld.w	r0,r1[0x24]

800064bc <sync_fs>:
#if !_FS_READONLY
static
FRESULT sync_fs (	/* FR_OK:succeeded, !=0:error */
	FATFS* fs		/* File system object */
)
{
800064bc:	eb cd 40 e0 	pushm	r5-r7,lr
800064c0:	18 96       	mov	r6,r12
	FRESULT res;


	res = sync_window(fs);
800064c2:	f0 1f 00 31 	mcall	80006584 <sync_fs+0xc8>
800064c6:	18 97       	mov	r7,r12
	if (res == FR_OK) {
800064c8:	c5 a1       	brne	8000657c <sync_fs+0xc0>
		/* Update FSInfo sector if needed */
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag == 1) {
800064ca:	0d 89       	ld.ub	r9,r6[0x0]
800064cc:	30 38       	mov	r8,3
800064ce:	f0 09 18 00 	cp.b	r9,r8
800064d2:	c4 e1       	brne	8000656e <sync_fs+0xb2>
800064d4:	0d d9       	ld.ub	r9,r6[0x5]
800064d6:	30 18       	mov	r8,1
800064d8:	f0 09 18 00 	cp.b	r9,r8
800064dc:	c4 91       	brne	8000656e <sync_fs+0xb2>
			/* Create FSInfo structure */
			mem_set(fs->win, 0, SS(fs));
800064de:	ec c5 ff d0 	sub	r5,r6,-48
800064e2:	e0 6a 02 00 	mov	r10,512
800064e6:	30 0b       	mov	r11,0
800064e8:	0a 9c       	mov	r12,r5
800064ea:	f0 1f 00 28 	mcall	80006588 <sync_fs+0xcc>
			ST_WORD(fs->win + BS_55AA, 0xAA55);
800064ee:	35 58       	mov	r8,85
800064f0:	ed 68 02 2e 	st.b	r6[558],r8
800064f4:	3a a8       	mov	r8,-86
800064f6:	ed 68 02 2f 	st.b	r6[559],r8
			ST_DWORD(fs->win + FSI_LeadSig, 0x41615252);
800064fa:	35 28       	mov	r8,82
800064fc:	ed 68 00 30 	st.b	r6[48],r8
80006500:	ed 68 00 31 	st.b	r6[49],r8
80006504:	36 18       	mov	r8,97
80006506:	ed 68 00 32 	st.b	r6[50],r8
8000650a:	34 19       	mov	r9,65
8000650c:	ed 69 00 33 	st.b	r6[51],r9
			ST_DWORD(fs->win + FSI_StrucSig, 0x61417272);
80006510:	37 2a       	mov	r10,114
80006512:	ed 6a 02 14 	st.b	r6[532],r10
80006516:	ed 6a 02 15 	st.b	r6[533],r10
8000651a:	ed 69 02 16 	st.b	r6[534],r9
8000651e:	ed 68 02 17 	st.b	r6[535],r8
			ST_DWORD(fs->win + FSI_Free_Count, fs->free_clust);
80006522:	6c 48       	ld.w	r8,r6[0x10]
80006524:	ed 68 02 18 	st.b	r6[536],r8
80006528:	f3 d8 c1 08 	bfextu	r9,r8,0x8,0x8
8000652c:	ed 69 02 19 	st.b	r6[537],r9
80006530:	f0 09 16 10 	lsr	r9,r8,0x10
80006534:	ed 69 02 1a 	st.b	r6[538],r9
80006538:	b9 88       	lsr	r8,0x18
8000653a:	ed 68 02 1b 	st.b	r6[539],r8
			ST_DWORD(fs->win + FSI_Nxt_Free, fs->last_clust);
8000653e:	6c 38       	ld.w	r8,r6[0xc]
80006540:	ed 68 02 1c 	st.b	r6[540],r8
80006544:	f3 d8 c1 08 	bfextu	r9,r8,0x8,0x8
80006548:	ed 69 02 1d 	st.b	r6[541],r9
8000654c:	f0 09 16 10 	lsr	r9,r8,0x10
80006550:	ed 69 02 1e 	st.b	r6[542],r9
80006554:	b9 88       	lsr	r8,0x18
80006556:	ed 68 02 1f 	st.b	r6[543],r8
			/* Write it into the FSInfo sector */
			fs->winsect = fs->volbase + 1;
8000655a:	6c 7a       	ld.w	r10,r6[0x1c]
8000655c:	2f fa       	sub	r10,-1
8000655e:	8d ba       	st.w	r6[0x2c],r10
			disk_write(fs->drv, fs->win, fs->winsect, 1);
80006560:	30 19       	mov	r9,1
80006562:	0a 9b       	mov	r11,r5
80006564:	0d 9c       	ld.ub	r12,r6[0x1]
80006566:	f0 1f 00 0a 	mcall	8000658c <sync_fs+0xd0>
			fs->fsi_flag = 0;
8000656a:	30 08       	mov	r8,0
8000656c:	ac d8       	st.b	r6[0x5],r8
		}
		/* Make sure that no pending write process in the physical drive */
		if (disk_ioctl(fs->drv, CTRL_SYNC, 0) != RES_OK)
8000656e:	30 0a       	mov	r10,0
80006570:	14 9b       	mov	r11,r10
80006572:	0d 9c       	ld.ub	r12,r6[0x1]
80006574:	f0 1f 00 07 	mcall	80006590 <sync_fs+0xd4>
80006578:	f9 b7 01 01 	movne	r7,1
			res = FR_DISK_ERR;
	}

	return res;
}
8000657c:	0e 9c       	mov	r12,r7
8000657e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80006582:	00 00       	add	r0,r0
80006584:	80 00       	ld.sh	r0,r0[0x0]
80006586:	64 58       	ld.w	r8,r2[0x14]
80006588:	80 00       	ld.sh	r0,r0[0x0]
8000658a:	62 de       	ld.w	lr,r1[0x34]
8000658c:	80 00       	ld.sh	r0,r0[0x0]
8000658e:	62 90       	ld.w	r0,r1[0x24]
80006590:	80 00       	ld.sh	r0,r0[0x0]
80006592:	62 40       	ld.w	r0,r1[0x10]

80006594 <f_mkfs>:
FRESULT f_mkfs (
	const TCHAR* path,	/* Logical drive number */
	BYTE sfd,			/* Partitioning rule 0:FDISK, 1:SFD */
	UINT au				/* Size of allocation unit in unit of byte or sector */
)
{
80006594:	d4 31       	pushm	r0-r7,lr
80006596:	20 ad       	sub	sp,40
80006598:	50 7c       	stdsp	sp[0x1c],r12
8000659a:	16 97       	mov	r7,r11
8000659c:	14 96       	mov	r6,r10
	DWORD eb[2];
#endif


	/* Check mounted drive and clear work area */
	if (sfd > 1) return FR_INVALID_PARAMETER;
8000659e:	30 18       	mov	r8,1
800065a0:	f0 0b 18 00 	cp.b	r11,r8
800065a4:	e0 88 00 05 	brls	800065ae <f_mkfs+0x1a>
800065a8:	31 3c       	mov	r12,19
800065aa:	e0 8f 03 16 	bral	80006bd6 <f_mkfs+0x642>
	vol = get_ldnumber(&path);
800065ae:	fa cc ff e4 	sub	r12,sp,-28
800065b2:	f0 1f 01 8e 	mcall	80006be8 <f_mkfs+0x654>
	if (vol < 0) return FR_INVALID_DRIVE;
800065b6:	c0 44       	brge	800065be <f_mkfs+0x2a>
800065b8:	30 bc       	mov	r12,11
800065ba:	e0 8f 03 0e 	bral	80006bd6 <f_mkfs+0x642>
	fs = FatFs[vol];
800065be:	fe f8 06 2e 	ld.w	r8,pc[1582]
800065c2:	f0 0c 03 25 	ld.w	r5,r8[r12<<0x2]
	if (!fs) return FR_NOT_ENABLED;
800065c6:	58 05       	cp.w	r5,0
800065c8:	c0 41       	brne	800065d0 <f_mkfs+0x3c>
800065ca:	30 cc       	mov	r12,12
800065cc:	e0 8f 03 05 	bral	80006bd6 <f_mkfs+0x642>
	fs->fs_type = 0;
800065d0:	30 08       	mov	r8,0
800065d2:	aa 88       	st.b	r5[0x0],r8
	pdrv = LD2PD(vol);	/* Physical drive */
	part = LD2PT(vol);	/* Partition (0:auto detect, 1-4:get from partition table)*/

	/* Get disk statics */
	stat = disk_initialize(pdrv);
800065d4:	e9 dc c0 08 	bfextu	r4,r12,0x0,0x8
800065d8:	08 9c       	mov	r12,r4
800065da:	f0 1f 01 86 	mcall	80006bf0 <f_mkfs+0x65c>
	if (stat & STA_NOINIT) return FR_NOT_READY;
800065de:	f1 dc c0 01 	bfextu	r8,r12,0x0,0x1
800065e2:	c0 40       	breq	800065ea <f_mkfs+0x56>
800065e4:	30 3c       	mov	r12,3
800065e6:	e0 8f 02 f8 	bral	80006bd6 <f_mkfs+0x642>
	if (stat & STA_PROTECT) return FR_WRITE_PROTECTED;
800065ea:	e2 1c 00 04 	andl	r12,0x4,COH
800065ee:	c0 40       	breq	800065f6 <f_mkfs+0x62>
800065f0:	30 ac       	mov	r12,10
800065f2:	e0 8f 02 f2 	bral	80006bd6 <f_mkfs+0x642>
		if (!tbl[4]) return FR_MKFS_ABORTED;	/* No partition? */
		b_vol = LD_DWORD(tbl + 8);	/* Volume start sector */
		n_vol = LD_DWORD(tbl + 12);	/* Volume size */
	} else {
		/* Create a partition in this function */
		if (disk_ioctl(pdrv, GET_SECTOR_COUNT, &n_vol) != RES_OK || n_vol < 128)
800065f6:	fa ca ff e0 	sub	r10,sp,-32
800065fa:	30 1b       	mov	r11,1
800065fc:	08 9c       	mov	r12,r4
800065fe:	f0 1f 01 7e 	mcall	80006bf4 <f_mkfs+0x660>
80006602:	e0 81 02 e7 	brne	80006bd0 <f_mkfs+0x63c>
80006606:	40 89       	lddsp	r9,sp[0x20]
80006608:	e0 49 00 7f 	cp.w	r9,127
8000660c:	e0 88 02 e2 	brls	80006bd0 <f_mkfs+0x63c>
			return FR_DISK_ERR;
		b_vol = (sfd) ? 0 : 63;		/* Volume start sector */
80006610:	58 07       	cp.w	r7,0
80006612:	f9 b1 01 00 	movne	r1,0
80006616:	f9 b1 00 3f 	moveq	r1,63
		n_vol -= b_vol;				/* Volume size */
8000661a:	02 19       	sub	r9,r1
8000661c:	50 89       	stdsp	sp[0x20],r9
	}

	if (au & (au - 1)) au = 0;
8000661e:	ec c8 00 01 	sub	r8,r6,1
80006622:	0c 68       	and	r8,r6
80006624:	c0 31       	brne	8000662a <f_mkfs+0x96>
	if (!au) {						/* AU auto selection */
80006626:	58 06       	cp.w	r6,0
80006628:	c1 a1       	brne	8000665c <f_mkfs+0xc8>
		vs = n_vol / (2000 / (SS(fs) / 512));
8000662a:	e0 6b 4d d3 	mov	r11,19923
8000662e:	ea 1b 10 62 	orh	r11,0x1062
80006632:	f2 0b 06 4a 	mulu.d	r10,r9,r11
80006636:	f6 0c 16 07 	lsr	r12,r11,0x7
		for (i = 0; vs < vst[i]; i++) ;
8000663a:	e0 4c 04 00 	cp.w	r12,1024
8000663e:	c0 33       	brcs	80006644 <f_mkfs+0xb0>
80006640:	30 08       	mov	r8,0
80006642:	c0 98       	rjmp	80006654 <f_mkfs+0xc0>
80006644:	fe fa 05 b4 	ld.w	r10,pc[1460]
80006648:	2f ea       	sub	r10,-2
8000664a:	30 08       	mov	r8,0
8000664c:	2f f8       	sub	r8,-1
8000664e:	15 2b       	ld.uh	r11,r10++
80006650:	16 3c       	cp.w	r12,r11
80006652:	cf d3       	brcs	8000664c <f_mkfs+0xb8>
		au = cst[i];
80006654:	fe fa 05 a8 	ld.w	r10,pc[1448]
80006658:	f4 08 05 16 	ld.uh	r6,r10[r8<<0x1]
	}
	if (au >= _MIN_SS) au /= SS(fs);	/* Number of sectors per cluster */
8000665c:	e0 46 01 ff 	cp.w	r6,511
80006660:	e0 88 00 03 	brls	80006666 <f_mkfs+0xd2>
80006664:	a9 96       	lsr	r6,0x9
	if (!au) au = 1;
80006666:	58 06       	cp.w	r6,0
80006668:	f9 b6 00 01 	moveq	r6,1
8000666c:	e0 60 00 80 	mov	r0,128
80006670:	00 36       	cp.w	r6,r0
80006672:	ec 00 17 80 	movls	r0,r6
	if (au > 128) au = 128;

	/* Pre-compute number of clusters and FAT sub-type */
	n_clst = n_vol / au;
80006676:	f2 00 0d 0a 	divu	r10,r9,r0
8000667a:	14 98       	mov	r8,r10
	fmt = FS_FAT12;
	if (n_clst >= MIN_FAT16) fmt = FS_FAT16;
8000667c:	e0 4a 0f f6 	cp.w	r10,4086
80006680:	f9 b3 03 01 	movlo	r3,1
80006684:	f9 b3 02 02 	movhs	r3,2
	if (n_clst >= MIN_FAT32) fmt = FS_FAT32;
80006688:	e0 4a ff f5 	cp.w	r10,65525
8000668c:	e0 88 00 04 	brls	80006694 <f_mkfs+0x100>
80006690:	30 33       	mov	r3,3
80006692:	c0 58       	rjmp	8000669c <f_mkfs+0x108>

	/* Determine offset and size of FAT structure */
	if (fmt == FS_FAT32) {
80006694:	30 3a       	mov	r10,3
80006696:	f4 03 18 00 	cp.b	r3,r10
8000669a:	c0 a1       	brne	800066ae <f_mkfs+0x11a>
		n_fat = ((n_clst * 4) + 8 + SS(fs) - 1) / SS(fs);
8000669c:	a3 68       	lsl	r8,0x2
8000669e:	f0 c2 fd f9 	sub	r2,r8,-519
800066a2:	a9 92       	lsr	r2,0x9
800066a4:	30 0b       	mov	r11,0
800066a6:	50 2b       	stdsp	sp[0x8],r11
800066a8:	32 0a       	mov	r10,32
800066aa:	50 0a       	stdsp	sp[0x0],r10
800066ac:	c1 68       	rjmp	800066d8 <f_mkfs+0x144>
		n_rsv = 32;
		n_dir = 0;
	} else {
		n_fat = (fmt == FS_FAT12) ? (n_clst * 3 + 1) / 2 + 3 : (n_clst * 2) + 4;
800066ae:	30 1a       	mov	r10,1
800066b0:	f4 03 18 00 	cp.b	r3,r10
800066b4:	c0 81       	brne	800066c4 <f_mkfs+0x130>
800066b6:	f0 08 00 18 	add	r8,r8,r8<<0x1
800066ba:	f0 c2 ff ff 	sub	r2,r8,-1
800066be:	a1 92       	lsr	r2,0x1
800066c0:	2f d2       	sub	r2,-3
800066c2:	c0 48       	rjmp	800066ca <f_mkfs+0x136>
800066c4:	2f e8       	sub	r8,-2
800066c6:	f0 02 15 01 	lsl	r2,r8,0x1
		n_fat = (n_fat + SS(fs) - 1) / SS(fs);
800066ca:	e4 c2 fe 01 	sub	r2,r2,-511
800066ce:	a9 92       	lsr	r2,0x9
800066d0:	32 08       	mov	r8,32
800066d2:	50 28       	stdsp	sp[0x8],r8
800066d4:	30 1c       	mov	r12,1
800066d6:	50 0c       	stdsp	sp[0x0],r12
		n_rsv = 1;
		n_dir = (DWORD)N_ROOTDIR * SZ_DIRE / SS(fs);
	}
	b_fat = b_vol + n_rsv;				/* FAT area start sector */
800066d8:	40 0b       	lddsp	r11,sp[0x0]
800066da:	02 0b       	add	r11,r1
800066dc:	50 1b       	stdsp	sp[0x4],r11
	b_dir = b_fat + n_fat * N_FATS;		/* Directory area start sector */
	b_data = b_dir + n_dir;				/* Data area start sector */
800066de:	40 26       	lddsp	r6,sp[0x8]
800066e0:	04 06       	add	r6,r2
800066e2:	16 06       	add	r6,r11
	if (n_vol < b_data + au - b_vol) return FR_MKFS_ABORTED;	/* Too small volume */
800066e4:	e0 01 01 08 	sub	r8,r0,r1
800066e8:	0c 08       	add	r8,r6
800066ea:	10 39       	cp.w	r9,r8
800066ec:	e0 83 02 74 	brlo	80006bd4 <f_mkfs+0x640>

	/* Align data start sector to erase block boundary (for flash memory media) */
	if (disk_ioctl(pdrv, GET_BLOCK_SIZE, &n) != RES_OK || !n || n > 32768) n = 1;
800066f0:	fa ca ff dc 	sub	r10,sp,-36
800066f4:	30 3b       	mov	r11,3
800066f6:	08 9c       	mov	r12,r4
800066f8:	f0 1f 01 3f 	mcall	80006bf4 <f_mkfs+0x660>
800066fc:	c0 81       	brne	8000670c <f_mkfs+0x178>
800066fe:	40 98       	lddsp	r8,sp[0x24]
80006700:	58 08       	cp.w	r8,0
80006702:	c0 50       	breq	8000670c <f_mkfs+0x178>
80006704:	e0 48 80 00 	cp.w	r8,32768
80006708:	e0 88 00 04 	brls	80006710 <f_mkfs+0x17c>
8000670c:	30 18       	mov	r8,1
8000670e:	50 98       	stdsp	sp[0x24],r8
	n = (b_data + n - 1) & ~(n - 1);	/* Next nearest erase block from current data start */
80006710:	40 98       	lddsp	r8,sp[0x24]
	n = (n - b_data) / N_FATS;
80006712:	f0 c9 00 01 	sub	r9,r8,1
80006716:	0c 09       	add	r9,r6
80006718:	5c 38       	neg	r8
8000671a:	f3 e8 00 08 	and	r8,r9,r8
8000671e:	f0 06 01 06 	sub	r6,r8,r6
80006722:	50 96       	stdsp	sp[0x24],r6
	if (fmt == FS_FAT32) {		/* FAT32: Move FAT offset */
80006724:	30 38       	mov	r8,3
80006726:	f0 03 18 00 	cp.b	r3,r8
8000672a:	c1 d1       	brne	80006764 <f_mkfs+0x1d0>
		n_rsv += n;
8000672c:	40 0a       	lddsp	r10,sp[0x0]
8000672e:	0c 0a       	add	r10,r6
80006730:	50 0a       	stdsp	sp[0x0],r10
		b_fat += n;
80006732:	40 19       	lddsp	r9,sp[0x4]
80006734:	0c 09       	add	r9,r6
80006736:	50 19       	stdsp	sp[0x4],r9
	} else {					/* FAT12/16: Expand FAT size */
		n_fat += n;
	}

	/* Determine number of clusters and final check of validity of the FAT sub-type */
	n_clst = (n_vol - n_rsv - n_fat * N_FATS - n_dir) / au;
80006738:	40 88       	lddsp	r8,sp[0x20]
8000673a:	f0 0a 01 0b 	sub	r11,r8,r10
8000673e:	04 1b       	sub	r11,r2
80006740:	40 2c       	lddsp	r12,sp[0x8]
80006742:	18 1b       	sub	r11,r12
80006744:	f6 00 0d 0a 	divu	r10,r11,r0
80006748:	50 4a       	stdsp	sp[0x10],r10
	if (   (fmt == FS_FAT16 && n_clst < MIN_FAT16)
		|| (fmt == FS_FAT32 && n_clst < MIN_FAT32))
8000674a:	30 39       	mov	r9,3
8000674c:	f2 03 18 00 	cp.b	r3,r9
80006750:	5f 0b       	sreq	r11
80006752:	50 3b       	stdsp	sp[0xc],r11
		n_fat += n;
	}

	/* Determine number of clusters and final check of validity of the FAT sub-type */
	n_clst = (n_vol - n_rsv - n_fat * N_FATS - n_dir) / au;
	if (   (fmt == FS_FAT16 && n_clst < MIN_FAT16)
80006754:	e0 4a ff f5 	cp.w	r10,65525
80006758:	5f 89       	srls	r9
8000675a:	f7 e9 00 09 	and	r9,r11,r9
8000675e:	e0 81 02 3b 	brne	80006bd4 <f_mkfs+0x640>
80006762:	c1 a8       	rjmp	80006796 <f_mkfs+0x202>
	n = (n - b_data) / N_FATS;
	if (fmt == FS_FAT32) {		/* FAT32: Move FAT offset */
		n_rsv += n;
		b_fat += n;
	} else {					/* FAT12/16: Expand FAT size */
		n_fat += n;
80006764:	0c 02       	add	r2,r6
	}

	/* Determine number of clusters and final check of validity of the FAT sub-type */
	n_clst = (n_vol - n_rsv - n_fat * N_FATS - n_dir) / au;
80006766:	40 88       	lddsp	r8,sp[0x20]
80006768:	40 0a       	lddsp	r10,sp[0x0]
8000676a:	f0 0a 01 0b 	sub	r11,r8,r10
8000676e:	04 1b       	sub	r11,r2
80006770:	40 29       	lddsp	r9,sp[0x8]
80006772:	12 1b       	sub	r11,r9
80006774:	f6 00 0d 0a 	divu	r10,r11,r0
80006778:	50 4a       	stdsp	sp[0x10],r10
	if (   (fmt == FS_FAT16 && n_clst < MIN_FAT16)
8000677a:	30 29       	mov	r9,2
8000677c:	f2 03 18 00 	cp.b	r3,r9
80006780:	5f 0a       	sreq	r10
80006782:	40 4c       	lddsp	r12,sp[0x10]
80006784:	e0 4c 0f f5 	cp.w	r12,4085
80006788:	5f 89       	srls	r9
8000678a:	f5 e9 00 09 	and	r9,r10,r9
8000678e:	e0 80 02 26 	breq	80006bda <f_mkfs+0x646>
80006792:	e0 8f 02 21 	bral	80006bd4 <f_mkfs+0x640>
		|| (fmt == FS_FAT32 && n_clst < MIN_FAT32))
		return FR_MKFS_ABORTED;

	/* Determine system ID in the partition table */
	if (fmt == FS_FAT32) {
80006796:	40 3b       	lddsp	r11,sp[0xc]
80006798:	58 0b       	cp.w	r11,0
8000679a:	c0 30       	breq	800067a0 <f_mkfs+0x20c>
8000679c:	30 c6       	mov	r6,12
8000679e:	c1 28       	rjmp	800067c2 <f_mkfs+0x22e>
		sys = 0x0C;		/* FAT32X */
	} else {
		if (fmt == FS_FAT12 && n_vol < 0x10000) {
800067a0:	30 19       	mov	r9,1
800067a2:	f2 03 18 00 	cp.b	r3,r9
800067a6:	c0 71       	brne	800067b4 <f_mkfs+0x220>
800067a8:	e0 48 ff ff 	cp.w	r8,65535
800067ac:	e0 8b 00 0a 	brhi	800067c0 <f_mkfs+0x22c>
800067b0:	30 16       	mov	r6,1
800067b2:	c0 88       	rjmp	800067c2 <f_mkfs+0x22e>
			sys = 0x01;	/* FAT12(<65536) */
		} else {
			sys = (n_vol < 0x10000) ? 0x04 : 0x06;	/* FAT16(<65536) : FAT12/16(>=65536) */
800067b4:	e0 48 ff ff 	cp.w	r8,65535
800067b8:	e0 8b 00 04 	brhi	800067c0 <f_mkfs+0x22c>
800067bc:	30 46       	mov	r6,4
800067be:	c0 28       	rjmp	800067c2 <f_mkfs+0x22e>
800067c0:	30 66       	mov	r6,6
		tbl[4] = sys;
		if (disk_write(pdrv, fs->win, 0, 1) != RES_OK)	/* Write it to teh MBR */
			return FR_DISK_ERR;
		md = 0xF8;
	} else {
		if (sfd) {	/* No partition table (SFD) */
800067c2:	58 07       	cp.w	r7,0
800067c4:	c0 40       	breq	800067cc <f_mkfs+0x238>
800067c6:	e0 67 00 f0 	mov	r7,240
800067ca:	c5 68       	rjmp	80006876 <f_mkfs+0x2e2>
			md = 0xF0;
		} else {	/* Create partition table (FDISK) */
			mem_set(fs->win, 0, SS(fs));
800067cc:	ea ca ff d0 	sub	r10,r5,-48
800067d0:	50 5a       	stdsp	sp[0x14],r10
800067d2:	e0 6a 02 00 	mov	r10,512
800067d6:	30 0b       	mov	r11,0
800067d8:	40 5c       	lddsp	r12,sp[0x14]
800067da:	f0 1f 01 0a 	mcall	80006c00 <f_mkfs+0x66c>
			tbl = fs->win + MBR_Table;	/* Create partition table for single partition in the drive */
800067de:	ea c8 fe 12 	sub	r8,r5,-494
			tbl[1] = 1;						/* Partition start head */
800067e2:	30 19       	mov	r9,1
800067e4:	b0 99       	st.b	r8[0x1],r9
			tbl[2] = 1;						/* Partition start sector */
800067e6:	b0 a9       	st.b	r8[0x2],r9
			tbl[3] = 0;						/* Partition start cylinder */
800067e8:	30 09       	mov	r9,0
800067ea:	b0 b9       	st.b	r8[0x3],r9
			tbl[4] = sys;					/* System type */
800067ec:	b0 c6       	st.b	r8[0x4],r6
			tbl[5] = 254;					/* Partition end head */
800067ee:	3f ea       	mov	r10,-2
800067f0:	b0 da       	st.b	r8[0x5],r10
			n = (b_vol + n_vol) / 63 / 255;
800067f2:	40 8b       	lddsp	r11,sp[0x20]
800067f4:	e2 0b 00 0b 	add	r11,r1,r11
800067f8:	e0 6a 56 5b 	mov	r10,22107
800067fc:	ea 1a 05 15 	orh	r10,0x515
80006800:	f6 0a 06 46 	mulu.d	r6,r11,r10
80006804:	0e 9c       	mov	r12,r7
80006806:	f6 0c 01 0a 	sub	r10,r11,r12
8000680a:	a1 9a       	lsr	r10,0x1
8000680c:	f4 0c 00 07 	add	r7,r10,r12
80006810:	ee 0a 16 0d 	lsr	r10,r7,0xd
80006814:	50 9a       	stdsp	sp[0x24],r10
			tbl[6] = (BYTE)(n >> 2 | 63);	/* Partition end sector */
80006816:	ee 0b 16 0f 	lsr	r11,r7,0xf
8000681a:	16 97       	mov	r7,r11
8000681c:	e8 17 00 3f 	orl	r7,0x3f
80006820:	b0 e7       	st.b	r8[0x6],r7
			tbl[7] = (BYTE)n;				/* End cylinder */
80006822:	40 9a       	lddsp	r10,sp[0x24]
80006824:	b0 fa       	st.b	r8[0x7],r10
			ST_DWORD(tbl + 8, 63);			/* Partition start in LBA */
80006826:	33 fa       	mov	r10,63
80006828:	f1 6a 00 08 	st.b	r8[8],r10
8000682c:	f1 69 00 09 	st.b	r8[9],r9
80006830:	f1 69 00 0a 	st.b	r8[10],r9
80006834:	f1 69 00 0b 	st.b	r8[11],r9
			ST_DWORD(tbl + 12, n_vol);		/* Partition size in LBA */
80006838:	40 89       	lddsp	r9,sp[0x20]
8000683a:	f1 69 00 0c 	st.b	r8[12],r9
8000683e:	fb 39 00 22 	ld.ub	r9,sp[34]
80006842:	f1 69 00 0d 	st.b	r8[13],r9
80006846:	fb 19 00 20 	ld.uh	r9,sp[32]
8000684a:	f1 69 00 0e 	st.b	r8[14],r9
8000684e:	fb 39 00 20 	ld.ub	r9,sp[32]
80006852:	f1 69 00 0f 	st.b	r8[15],r9
			ST_WORD(fs->win + BS_55AA, 0xAA55);	/* MBR signature */
80006856:	35 58       	mov	r8,85
80006858:	eb 68 02 2e 	st.b	r5[558],r8
8000685c:	3a a8       	mov	r8,-86
8000685e:	eb 68 02 2f 	st.b	r5[559],r8
			if (disk_write(pdrv, fs->win, 0, 1) != RES_OK)	/* Write it to the MBR */
80006862:	30 19       	mov	r9,1
80006864:	30 0a       	mov	r10,0
80006866:	40 5b       	lddsp	r11,sp[0x14]
80006868:	08 9c       	mov	r12,r4
8000686a:	f0 1f 00 e7 	mcall	80006c04 <f_mkfs+0x670>
8000686e:	e0 81 01 b1 	brne	80006bd0 <f_mkfs+0x63c>
80006872:	e0 67 00 f8 	mov	r7,248
			md = 0xF8;
		}
	}

	/* Create BPB in the VBR */
	tbl = fs->win;							/* Clear sector */
80006876:	ea c6 ff d0 	sub	r6,r5,-48
	mem_set(tbl, 0, SS(fs));
8000687a:	e0 6a 02 00 	mov	r10,512
8000687e:	30 0b       	mov	r11,0
80006880:	0c 9c       	mov	r12,r6
80006882:	f0 1f 00 e0 	mcall	80006c00 <f_mkfs+0x66c>
	mem_cpy(tbl, "\xEB\xFE\x90" "MSDOS5.0", 11);/* Boot jump code, OEM name */
80006886:	30 ba       	mov	r10,11
80006888:	fe fb 03 80 	ld.w	r11,pc[896]
8000688c:	0c 9c       	mov	r12,r6
8000688e:	f0 1f 00 e0 	mcall	80006c0c <f_mkfs+0x678>
	i = SS(fs);								/* Sector size */
	ST_WORD(tbl + BPB_BytsPerSec, i);
80006892:	ea ca ff c5 	sub	r10,r5,-59
80006896:	50 5a       	stdsp	sp[0x14],r10
80006898:	30 08       	mov	r8,0
8000689a:	b4 88       	st.b	r10[0x0],r8
8000689c:	30 28       	mov	r8,2
8000689e:	ed 68 00 0c 	st.b	r6[12],r8
	tbl[BPB_SecPerClus] = (BYTE)au;			/* Sectors per cluster */
800068a2:	ed 60 00 0d 	st.b	r6[13],r0
	ST_WORD(tbl + BPB_RsvdSecCnt, n_rsv);	/* Reserved sectors */
800068a6:	40 09       	lddsp	r9,sp[0x0]
800068a8:	ed 69 00 0e 	st.b	r6[14],r9
800068ac:	f1 d9 c1 08 	bfextu	r8,r9,0x8,0x8
800068b0:	ed 68 00 0f 	st.b	r6[15],r8
	tbl[BPB_NumFATs] = N_FATS;				/* Number of FATs */
800068b4:	30 18       	mov	r8,1
800068b6:	ed 68 00 10 	st.b	r6[16],r8
	i = (fmt == FS_FAT32) ? 0 : N_ROOTDIR;	/* Number of root directory entries */
800068ba:	e0 68 02 00 	mov	r8,512
800068be:	40 3c       	lddsp	r12,sp[0xc]
800068c0:	58 0c       	cp.w	r12,0
800068c2:	f9 b8 01 00 	movne	r8,0
	ST_WORD(tbl + BPB_RootEntCnt, i);
800068c6:	ed 68 00 11 	st.b	r6[17],r8
800068ca:	58 08       	cp.w	r8,0
800068cc:	f9 b8 01 02 	movne	r8,2
800068d0:	f9 b8 00 00 	moveq	r8,0
800068d4:	ed 68 00 12 	st.b	r6[18],r8
	if (n_vol < 0x10000) {					/* Number of total sectors */
800068d8:	40 88       	lddsp	r8,sp[0x20]
800068da:	e0 48 ff ff 	cp.w	r8,65535
800068de:	e0 8b 00 09 	brhi	800068f0 <f_mkfs+0x35c>
		ST_WORD(tbl + BPB_TotSec16, n_vol);
800068e2:	ed 68 00 13 	st.b	r6[19],r8
800068e6:	fb 38 00 22 	ld.ub	r8,sp[34]
800068ea:	ed 68 00 14 	st.b	r6[20],r8
800068ee:	c0 f8       	rjmp	8000690c <f_mkfs+0x378>
	} else {
		ST_DWORD(tbl + BPB_TotSec32, n_vol);
800068f0:	ed 68 00 20 	st.b	r6[32],r8
800068f4:	fb 38 00 22 	ld.ub	r8,sp[34]
800068f8:	ed 68 00 21 	st.b	r6[33],r8
800068fc:	fb 18 00 20 	ld.uh	r8,sp[32]
80006900:	ed 68 00 22 	st.b	r6[34],r8
80006904:	fb 38 00 20 	ld.ub	r8,sp[32]
80006908:	ed 68 00 23 	st.b	r6[35],r8
	}
	tbl[BPB_Media] = md;					/* Media descriptor */
8000690c:	ed 67 00 15 	st.b	r6[21],r7
	ST_WORD(tbl + BPB_SecPerTrk, 63);		/* Number of sectors per track */
80006910:	33 f8       	mov	r8,63
80006912:	ed 68 00 18 	st.b	r6[24],r8
80006916:	30 08       	mov	r8,0
80006918:	ed 68 00 19 	st.b	r6[25],r8
	ST_WORD(tbl + BPB_NumHeads, 255);		/* Number of heads */
8000691c:	3f f9       	mov	r9,-1
8000691e:	ed 69 00 1a 	st.b	r6[26],r9
80006922:	ed 68 00 1b 	st.b	r6[27],r8
	ST_DWORD(tbl + BPB_HiddSec, b_vol);		/* Hidden sectors */
80006926:	ed 61 00 1c 	st.b	r6[28],r1
8000692a:	30 08       	mov	r8,0
8000692c:	ed 68 00 1d 	st.b	r6[29],r8
80006930:	e2 08 16 10 	lsr	r8,r1,0x10
80006934:	ed 68 00 1e 	st.b	r6[30],r8
80006938:	e2 08 16 18 	lsr	r8,r1,0x18
8000693c:	ed 68 00 1f 	st.b	r6[31],r8
	n = GET_FATTIME();						/* Use current time as VSN */
80006940:	f0 1f 00 b4 	mcall	80006c10 <f_mkfs+0x67c>
80006944:	50 9c       	stdsp	sp[0x24],r12
	if (fmt == FS_FAT32) {
80006946:	40 3a       	lddsp	r10,sp[0xc]
80006948:	58 0a       	cp.w	r10,0
8000694a:	c3 f0       	breq	800069c8 <f_mkfs+0x434>
		ST_DWORD(tbl + BS_VolID32, n);		/* VSN */
8000694c:	ed 6c 00 43 	st.b	r6[67],r12
80006950:	fb 38 00 26 	ld.ub	r8,sp[38]
80006954:	ed 68 00 44 	st.b	r6[68],r8
80006958:	fb 18 00 24 	ld.uh	r8,sp[36]
8000695c:	ed 68 00 45 	st.b	r6[69],r8
80006960:	fb 38 00 24 	ld.ub	r8,sp[36]
80006964:	ed 68 00 46 	st.b	r6[70],r8
		ST_DWORD(tbl + BPB_FATSz32, n_fat);	/* Number of sectors per FAT */
80006968:	ed 62 00 24 	st.b	r6[36],r2
8000696c:	f1 d2 c1 08 	bfextu	r8,r2,0x8,0x8
80006970:	ed 68 00 25 	st.b	r6[37],r8
80006974:	e4 08 16 10 	lsr	r8,r2,0x10
80006978:	ed 68 00 26 	st.b	r6[38],r8
8000697c:	e4 08 16 18 	lsr	r8,r2,0x18
80006980:	ed 68 00 27 	st.b	r6[39],r8
		ST_DWORD(tbl + BPB_RootClus, 2);	/* Root directory start cluster (2) */
80006984:	30 28       	mov	r8,2
80006986:	ed 68 00 2c 	st.b	r6[44],r8
8000698a:	30 08       	mov	r8,0
8000698c:	ed 68 00 2d 	st.b	r6[45],r8
80006990:	ed 68 00 2e 	st.b	r6[46],r8
80006994:	ed 68 00 2f 	st.b	r6[47],r8
		ST_WORD(tbl + BPB_FSInfo, 1);		/* FSINFO record offset (VBR + 1) */
80006998:	30 19       	mov	r9,1
8000699a:	ed 69 00 30 	st.b	r6[48],r9
8000699e:	ed 68 00 31 	st.b	r6[49],r8
		ST_WORD(tbl + BPB_BkBootSec, 6);	/* Backup boot record offset (VBR + 6) */
800069a2:	30 69       	mov	r9,6
800069a4:	ed 69 00 32 	st.b	r6[50],r9
800069a8:	ed 68 00 33 	st.b	r6[51],r8
		tbl[BS_DrvNum32] = 0x80;			/* Drive number */
800069ac:	38 08       	mov	r8,-128
800069ae:	ed 68 00 40 	st.b	r6[64],r8
		tbl[BS_BootSig32] = 0x29;			/* Extended boot signature */
800069b2:	32 98       	mov	r8,41
800069b4:	ed 68 00 42 	st.b	r6[66],r8
		mem_cpy(tbl + BS_VolLab32, "NO NAME    " "FAT32   ", 19);	/* Volume label, FAT signature */
800069b8:	31 3a       	mov	r10,19
800069ba:	fe fb 02 5a 	ld.w	r11,pc[602]
800069be:	ec cc ff b9 	sub	r12,r6,-71
800069c2:	f0 1f 00 93 	mcall	80006c0c <f_mkfs+0x678>
800069c6:	c2 28       	rjmp	80006a0a <f_mkfs+0x476>
	} else {
		ST_DWORD(tbl + BS_VolID, n);		/* VSN */
800069c8:	ed 6c 00 27 	st.b	r6[39],r12
800069cc:	fb 38 00 26 	ld.ub	r8,sp[38]
800069d0:	ed 68 00 28 	st.b	r6[40],r8
800069d4:	fb 18 00 24 	ld.uh	r8,sp[36]
800069d8:	ed 68 00 29 	st.b	r6[41],r8
800069dc:	fb 38 00 24 	ld.ub	r8,sp[36]
800069e0:	ed 68 00 2a 	st.b	r6[42],r8
		ST_WORD(tbl + BPB_FATSz16, n_fat);	/* Number of sectors per FAT */
800069e4:	ed 62 00 16 	st.b	r6[22],r2
800069e8:	f1 d2 c1 08 	bfextu	r8,r2,0x8,0x8
800069ec:	ed 68 00 17 	st.b	r6[23],r8
		tbl[BS_DrvNum] = 0x80;				/* Drive number */
800069f0:	38 08       	mov	r8,-128
800069f2:	ed 68 00 24 	st.b	r6[36],r8
		tbl[BS_BootSig] = 0x29;				/* Extended boot signature */
800069f6:	32 98       	mov	r8,41
800069f8:	ed 68 00 26 	st.b	r6[38],r8
		mem_cpy(tbl + BS_VolLab, "NO NAME    " "FAT     ", 19);	/* Volume label, FAT signature */
800069fc:	31 3a       	mov	r10,19
800069fe:	fe fb 02 1a 	ld.w	r11,pc[538]
80006a02:	ec cc ff d5 	sub	r12,r6,-43
80006a06:	f0 1f 00 82 	mcall	80006c0c <f_mkfs+0x678>
	}
	ST_WORD(tbl + BS_55AA, 0xAA55);			/* Signature (Offset is fixed here regardless of sector size) */
80006a0a:	ec c9 fe 02 	sub	r9,r6,-510
80006a0e:	50 69       	stdsp	sp[0x18],r9
80006a10:	35 58       	mov	r8,85
80006a12:	b2 88       	st.b	r9[0x0],r8
80006a14:	ec c8 fe 01 	sub	r8,r6,-511
80006a18:	50 08       	stdsp	sp[0x0],r8
80006a1a:	3a a8       	mov	r8,-86
80006a1c:	40 0c       	lddsp	r12,sp[0x0]
80006a1e:	b8 88       	st.b	r12[0x0],r8
	if (disk_write(pdrv, tbl, b_vol, 1) != RES_OK)	/* Write it to the VBR sector */
80006a20:	30 19       	mov	r9,1
80006a22:	02 9a       	mov	r10,r1
80006a24:	0c 9b       	mov	r11,r6
80006a26:	08 9c       	mov	r12,r4
80006a28:	f0 1f 00 77 	mcall	80006c04 <f_mkfs+0x670>
80006a2c:	e0 81 00 d2 	brne	80006bd0 <f_mkfs+0x63c>
		return FR_DISK_ERR;
	if (fmt == FS_FAT32)					/* Write it to the backup VBR if needed (VBR + 6) */
80006a30:	40 3b       	lddsp	r11,sp[0xc]
80006a32:	58 0b       	cp.w	r11,0
80006a34:	c0 80       	breq	80006a44 <f_mkfs+0x4b0>
		disk_write(pdrv, tbl, b_vol + 6, 1);
80006a36:	30 19       	mov	r9,1
80006a38:	e2 ca ff fa 	sub	r10,r1,-6
80006a3c:	0c 9b       	mov	r11,r6
80006a3e:	08 9c       	mov	r12,r4
80006a40:	f0 1f 00 71 	mcall	80006c04 <f_mkfs+0x670>

	/* Initialize FAT area */
	wsect = b_fat;
	for (i = 0; i < N_FATS; i++) {		/* Initialize each FAT copy */
		mem_set(tbl, 0, SS(fs));			/* 1st sector of the FAT  */
80006a44:	e0 6a 02 00 	mov	r10,512
80006a48:	30 0b       	mov	r11,0
80006a4a:	0c 9c       	mov	r12,r6
80006a4c:	f0 1f 00 6d 	mcall	80006c00 <f_mkfs+0x66c>
		n = md;								/* Media descriptor byte */
		if (fmt != FS_FAT32) {
80006a50:	30 38       	mov	r8,3
80006a52:	f0 03 18 00 	cp.b	r3,r8
80006a56:	c1 d0       	breq	80006a90 <f_mkfs+0x4fc>
			n |= (fmt == FS_FAT12) ? 0x00FFFF00 : 0xFFFFFF00;
80006a58:	30 18       	mov	r8,1
80006a5a:	fe 7a ff 00 	mov	r10,-256
80006a5e:	e0 69 ff 00 	mov	r9,65280
80006a62:	ea 19 00 ff 	orh	r9,0xff
80006a66:	e6 08 18 00 	cp.b	r8,r3
80006a6a:	f2 08 17 00 	moveq	r8,r9
80006a6e:	f4 08 17 10 	movne	r8,r10
80006a72:	f1 e7 10 07 	or	r7,r8,r7
80006a76:	50 97       	stdsp	sp[0x24],r7
			ST_DWORD(tbl + 0, n);			/* Reserve cluster #0-1 (FAT12/16) */
80006a78:	eb 67 00 30 	st.b	r5[48],r7
80006a7c:	fb 38 00 26 	ld.ub	r8,sp[38]
80006a80:	ac 98       	st.b	r6[0x1],r8
80006a82:	fb 18 00 24 	ld.uh	r8,sp[36]
80006a86:	ac a8       	st.b	r6[0x2],r8
80006a88:	fb 38 00 24 	ld.ub	r8,sp[36]
80006a8c:	ac b8       	st.b	r6[0x3],r8
80006a8e:	c1 f8       	rjmp	80006acc <f_mkfs+0x538>
		} else {
			n |= 0xFFFFFF00;
80006a90:	ea 17 ff ff 	orh	r7,0xffff
80006a94:	e8 17 ff 00 	orl	r7,0xff00
80006a98:	50 97       	stdsp	sp[0x24],r7
			ST_DWORD(tbl + 0, n);			/* Reserve cluster #0-1 (FAT32) */
80006a9a:	eb 67 00 30 	st.b	r5[48],r7
80006a9e:	fb 38 00 26 	ld.ub	r8,sp[38]
80006aa2:	ac 98       	st.b	r6[0x1],r8
80006aa4:	fb 18 00 24 	ld.uh	r8,sp[36]
80006aa8:	ac a8       	st.b	r6[0x2],r8
80006aaa:	fb 38 00 24 	ld.ub	r8,sp[36]
80006aae:	ac b8       	st.b	r6[0x3],r8
			ST_DWORD(tbl + 4, 0xFFFFFFFF);
80006ab0:	3f f8       	mov	r8,-1
80006ab2:	ac c8       	st.b	r6[0x4],r8
80006ab4:	ac d8       	st.b	r6[0x5],r8
80006ab6:	ac e8       	st.b	r6[0x6],r8
80006ab8:	ac f8       	st.b	r6[0x7],r8
			ST_DWORD(tbl + 8, 0x0FFFFFFF);	/* Reserve cluster #2 for root directory */
80006aba:	ed 68 00 08 	st.b	r6[8],r8
80006abe:	ed 68 00 09 	st.b	r6[9],r8
80006ac2:	ed 68 00 0a 	st.b	r6[10],r8
80006ac6:	30 f8       	mov	r8,15
80006ac8:	40 5a       	lddsp	r10,sp[0x14]
80006aca:	b4 88       	st.b	r10[0x0],r8
		}
		if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
80006acc:	30 19       	mov	r9,1
80006ace:	40 1a       	lddsp	r10,sp[0x4]
80006ad0:	0c 9b       	mov	r11,r6
80006ad2:	08 9c       	mov	r12,r4
80006ad4:	f0 1f 00 4c 	mcall	80006c04 <f_mkfs+0x670>
80006ad8:	c7 c1       	brne	80006bd0 <f_mkfs+0x63c>
80006ada:	40 13       	lddsp	r3,sp[0x4]
80006adc:	2f f3       	sub	r3,-1
			return FR_DISK_ERR;
		mem_set(tbl, 0, SS(fs));			/* Fill following FAT entries with zero */
80006ade:	e0 6a 02 00 	mov	r10,512
80006ae2:	30 0b       	mov	r11,0
80006ae4:	0c 9c       	mov	r12,r6
80006ae6:	f0 1f 00 47 	mcall	80006c00 <f_mkfs+0x66c>
		for (n = 1; n < n_fat; n++) {		/* This loop may take a time on FAT32 volume due to many single sector writes */
80006aea:	30 18       	mov	r8,1
80006aec:	50 98       	stdsp	sp[0x24],r8
80006aee:	10 32       	cp.w	r2,r8
80006af0:	e0 88 00 11 	brls	80006b12 <f_mkfs+0x57e>
			if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
80006af4:	10 97       	mov	r7,r8
80006af6:	0e 99       	mov	r9,r7
80006af8:	06 9a       	mov	r10,r3
80006afa:	0c 9b       	mov	r11,r6
80006afc:	08 9c       	mov	r12,r4
80006afe:	f0 1f 00 42 	mcall	80006c04 <f_mkfs+0x670>
80006b02:	c6 71       	brne	80006bd0 <f_mkfs+0x63c>
80006b04:	2f f3       	sub	r3,-1
			ST_DWORD(tbl + 8, 0x0FFFFFFF);	/* Reserve cluster #2 for root directory */
		}
		if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
			return FR_DISK_ERR;
		mem_set(tbl, 0, SS(fs));			/* Fill following FAT entries with zero */
		for (n = 1; n < n_fat; n++) {		/* This loop may take a time on FAT32 volume due to many single sector writes */
80006b06:	40 98       	lddsp	r8,sp[0x24]
80006b08:	2f f8       	sub	r8,-1
80006b0a:	50 98       	stdsp	sp[0x24],r8
80006b0c:	10 32       	cp.w	r2,r8
80006b0e:	fe 9b ff f4 	brhi	80006af6 <f_mkfs+0x562>
				return FR_DISK_ERR;
		}
	}

	/* Initialize root directory */
	i = (fmt == FS_FAT32) ? au : (UINT)n_dir;
80006b12:	40 29       	lddsp	r9,sp[0x8]
80006b14:	40 38       	lddsp	r8,sp[0xc]
80006b16:	58 08       	cp.w	r8,0
80006b18:	f2 00 17 00 	moveq	r0,r9
	do {
		if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
80006b1c:	30 12       	mov	r2,1
80006b1e:	06 9a       	mov	r10,r3
80006b20:	f4 c7 ff ff 	sub	r7,r10,-1
80006b24:	04 99       	mov	r9,r2
80006b26:	0c 9b       	mov	r11,r6
80006b28:	08 9c       	mov	r12,r4
80006b2a:	f0 1f 00 37 	mcall	80006c04 <f_mkfs+0x670>
80006b2e:	c5 11       	brne	80006bd0 <f_mkfs+0x63c>
			return FR_DISK_ERR;
	} while (--i);
80006b30:	20 10       	sub	r0,1
80006b32:	c0 30       	breq	80006b38 <f_mkfs+0x5a4>
80006b34:	0e 9a       	mov	r10,r7
80006b36:	cf 5b       	rjmp	80006b20 <f_mkfs+0x58c>
		disk_ioctl(pdrv, CTRL_TRIM, eb);
	}
#endif

	/* Create FSINFO if needed */
	if (fmt == FS_FAT32) {
80006b38:	40 3c       	lddsp	r12,sp[0xc]
80006b3a:	58 0c       	cp.w	r12,0
80006b3c:	c4 30       	breq	80006bc2 <f_mkfs+0x62e>
		ST_DWORD(tbl + FSI_LeadSig, 0x41615252);
80006b3e:	35 28       	mov	r8,82
80006b40:	eb 68 00 30 	st.b	r5[48],r8
80006b44:	ac 98       	st.b	r6[0x1],r8
80006b46:	36 18       	mov	r8,97
80006b48:	ac a8       	st.b	r6[0x2],r8
80006b4a:	34 19       	mov	r9,65
80006b4c:	ac b9       	st.b	r6[0x3],r9
		ST_DWORD(tbl + FSI_StrucSig, 0x61417272);
80006b4e:	37 2a       	mov	r10,114
80006b50:	ed 6a 01 e4 	st.b	r6[484],r10
80006b54:	ed 6a 01 e5 	st.b	r6[485],r10
80006b58:	ed 69 01 e6 	st.b	r6[486],r9
80006b5c:	ed 68 01 e7 	st.b	r6[487],r8
		ST_DWORD(tbl + FSI_Free_Count, n_clst - 1);	/* Number of free clusters */
80006b60:	40 48       	lddsp	r8,sp[0x10]
80006b62:	20 18       	sub	r8,1
80006b64:	ed 68 01 e8 	st.b	r6[488],r8
80006b68:	40 48       	lddsp	r8,sp[0x10]
80006b6a:	20 18       	sub	r8,1
80006b6c:	f1 d8 c1 08 	bfextu	r8,r8,0x8,0x8
80006b70:	ed 68 01 e9 	st.b	r6[489],r8
80006b74:	40 48       	lddsp	r8,sp[0x10]
80006b76:	20 18       	sub	r8,1
80006b78:	f0 09 16 10 	lsr	r9,r8,0x10
80006b7c:	ed 69 01 ea 	st.b	r6[490],r9
80006b80:	b9 88       	lsr	r8,0x18
80006b82:	ed 68 01 eb 	st.b	r6[491],r8
		ST_DWORD(tbl + FSI_Nxt_Free, 2);			/* Last allocated cluster# */
80006b86:	30 28       	mov	r8,2
80006b88:	ed 68 01 ec 	st.b	r6[492],r8
80006b8c:	30 08       	mov	r8,0
80006b8e:	ed 68 01 ed 	st.b	r6[493],r8
80006b92:	ed 68 01 ee 	st.b	r6[494],r8
80006b96:	ed 68 01 ef 	st.b	r6[495],r8
		ST_WORD(tbl + BS_55AA, 0xAA55);
80006b9a:	35 58       	mov	r8,85
80006b9c:	40 6b       	lddsp	r11,sp[0x18]
80006b9e:	b6 88       	st.b	r11[0x0],r8
80006ba0:	3a a8       	mov	r8,-86
80006ba2:	40 0a       	lddsp	r10,sp[0x0]
80006ba4:	b4 88       	st.b	r10[0x0],r8
		disk_write(pdrv, tbl, b_vol + 1, 1);	/* Write original (VBR + 1) */
80006ba6:	30 19       	mov	r9,1
80006ba8:	e2 09 00 0a 	add	r10,r1,r9
80006bac:	0c 9b       	mov	r11,r6
80006bae:	08 9c       	mov	r12,r4
80006bb0:	f0 1f 00 15 	mcall	80006c04 <f_mkfs+0x670>
		disk_write(pdrv, tbl, b_vol + 7, 1);	/* Write backup (VBR + 7) */
80006bb4:	30 19       	mov	r9,1
80006bb6:	e2 ca ff f9 	sub	r10,r1,-7
80006bba:	0c 9b       	mov	r11,r6
80006bbc:	08 9c       	mov	r12,r4
80006bbe:	f0 1f 00 12 	mcall	80006c04 <f_mkfs+0x670>
	}

	return (disk_ioctl(pdrv, CTRL_SYNC, 0) == RES_OK) ? FR_OK : FR_DISK_ERR;
80006bc2:	30 0a       	mov	r10,0
80006bc4:	14 9b       	mov	r11,r10
80006bc6:	08 9c       	mov	r12,r4
80006bc8:	f0 1f 00 0b 	mcall	80006bf4 <f_mkfs+0x660>
80006bcc:	5f 1c       	srne	r12
80006bce:	c0 48       	rjmp	80006bd6 <f_mkfs+0x642>
80006bd0:	30 1c       	mov	r12,1
80006bd2:	c0 28       	rjmp	80006bd6 <f_mkfs+0x642>
80006bd4:	30 ec       	mov	r12,14
}
80006bd6:	2f 6d       	sub	sp,-40
80006bd8:	d8 32       	popm	r0-r7,pc
	}

	/* Determine number of clusters and final check of validity of the FAT sub-type */
	n_clst = (n_vol - n_rsv - n_fat * N_FATS - n_dir) / au;
	if (   (fmt == FS_FAT16 && n_clst < MIN_FAT16)
		|| (fmt == FS_FAT32 && n_clst < MIN_FAT32))
80006bda:	30 39       	mov	r9,3
80006bdc:	f2 03 18 00 	cp.b	r3,r9
80006be0:	5f 09       	sreq	r9
80006be2:	50 39       	stdsp	sp[0xc],r9
80006be4:	fe 9f fd d9 	bral	80006796 <f_mkfs+0x202>
80006be8:	80 00       	ld.sh	r0,r0[0x0]
80006bea:	63 9c       	ld.w	r12,r1[0x64]
80006bec:	00 00       	add	r0,r0
80006bee:	11 50       	ld.sh	r0,--r8
80006bf0:	80 00       	ld.sh	r0,r0[0x0]
80006bf2:	62 02       	ld.w	r2,r1[0x0]
80006bf4:	80 00       	ld.sh	r0,r0[0x0]
80006bf6:	62 40       	ld.w	r0,r1[0x10]
80006bf8:	80 01       	ld.sh	r1,r0[0x0]
80006bfa:	8b 6a       	st.w	r5[0x18],r10
80006bfc:	80 01       	ld.sh	r1,r0[0x0]
80006bfe:	8b 54       	st.w	r5[0x14],r4
80006c00:	80 00       	ld.sh	r0,r0[0x0]
80006c02:	62 de       	ld.w	lr,r1[0x34]
80006c04:	80 00       	ld.sh	r0,r0[0x0]
80006c06:	62 90       	ld.w	r0,r1[0x24]
80006c08:	80 01       	ld.sh	r1,r0[0x0]
80006c0a:	8b 84       	st.w	r5[0x20],r4
80006c0c:	80 00       	ld.sh	r0,r0[0x0]
80006c0e:	62 c8       	ld.w	r8,r1[0x30]
80006c10:	80 00       	ld.sh	r0,r0[0x0]
80006c12:	62 04       	ld.w	r4,r1[0x0]
80006c14:	80 01       	ld.sh	r1,r0[0x0]
80006c16:	8b 90       	st.w	r5[0x24],r0
80006c18:	80 01       	ld.sh	r1,r0[0x0]
80006c1a:	8b a4       	st.w	r5[0x28],r4

80006c1c <validate>:

static
FRESULT validate (	/* FR_OK(0): The object is valid, !=0: Invalid */
	void* obj		/* Pointer to the object FIL/DIR to check validity */
)
{
80006c1c:	d4 01       	pushm	lr
	FIL *fil = (FIL*)obj;	/* Assuming offset of .fs and .id in the FIL/DIR structure is identical */


	if (!fil || !fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id || (disk_status(fil->fs->drv) & STA_NOINIT))
80006c1e:	58 0c       	cp.w	r12,0
80006c20:	c1 40       	breq	80006c48 <validate+0x2c>
80006c22:	78 08       	ld.w	r8,r12[0x0]
80006c24:	58 08       	cp.w	r8,0
80006c26:	c1 10       	breq	80006c48 <validate+0x2c>
80006c28:	11 8a       	ld.ub	r10,r8[0x0]
80006c2a:	30 09       	mov	r9,0
80006c2c:	f2 0a 18 00 	cp.b	r10,r9
80006c30:	c0 c0       	breq	80006c48 <validate+0x2c>
80006c32:	90 3a       	ld.sh	r10,r8[0x6]
80006c34:	98 29       	ld.sh	r9,r12[0x4]
80006c36:	f2 0a 19 00 	cp.h	r10,r9
80006c3a:	c0 71       	brne	80006c48 <validate+0x2c>
80006c3c:	11 9c       	ld.ub	r12,r8[0x1]
80006c3e:	f0 1f 00 04 	mcall	80006c4c <validate+0x30>
80006c42:	f9 dc c0 01 	bfextu	r12,r12,0x0,0x1
80006c46:	c0 20       	breq	80006c4a <validate+0x2e>
80006c48:	30 9c       	mov	r12,9
		return FR_INVALID_OBJECT;

	ENTER_FF(fil->fs);		/* Lock file system */

	return FR_OK;
}
80006c4a:	d8 02       	popm	pc
80006c4c:	80 00       	ld.sh	r0,r0[0x0]
80006c4e:	62 00       	ld.w	r0,r1[0x0]

80006c50 <move_window>:
static
FRESULT move_window (	/* FR_OK(0):succeeded, !=0:error */
	FATFS* fs,		/* File system object */
	DWORD sector	/* Sector number to make appearance in the fs->win[] */
)
{
80006c50:	eb cd 40 e0 	pushm	r5-r7,lr
80006c54:	18 97       	mov	r7,r12
80006c56:	16 95       	mov	r5,r11
	FRESULT res = FR_OK;


	if (sector != fs->winsect) {	/* Window offset changed? */
80006c58:	78 b8       	ld.w	r8,r12[0x2c]
80006c5a:	16 38       	cp.w	r8,r11
80006c5c:	c0 31       	brne	80006c62 <move_window+0x12>
80006c5e:	30 06       	mov	r6,0
80006c60:	c1 18       	rjmp	80006c82 <move_window+0x32>
#if !_FS_READONLY
		res = sync_window(fs);		/* Write-back changes */
80006c62:	f0 1f 00 0a 	mcall	80006c88 <move_window+0x38>
80006c66:	18 96       	mov	r6,r12
#endif
		if (res == FR_OK) {			/* Fill sector window with new data */
80006c68:	c0 d1       	brne	80006c82 <move_window+0x32>
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
80006c6a:	30 19       	mov	r9,1
80006c6c:	0a 9a       	mov	r10,r5
80006c6e:	ee cb ff d0 	sub	r11,r7,-48
80006c72:	0f 9c       	ld.ub	r12,r7[0x1]
80006c74:	f0 1f 00 06 	mcall	80006c8c <move_window+0x3c>
80006c78:	f9 b6 01 01 	movne	r6,1
80006c7c:	f9 b5 01 ff 	movne	r5,-1
				sector = 0xFFFFFFFF;	/* Invalidate window if data is not reliable */
				res = FR_DISK_ERR;
			}
			fs->winsect = sector;
80006c80:	8f b5       	st.w	r7[0x2c],r5
		}
	}
	return res;
}
80006c82:	0c 9c       	mov	r12,r6
80006c84:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80006c88:	80 00       	ld.sh	r0,r0[0x0]
80006c8a:	64 58       	ld.w	r8,r2[0x14]
80006c8c:	80 00       	ld.sh	r0,r0[0x0]
80006c8e:	62 ac       	ld.w	r12,r1[0x28]

80006c90 <check_fs>:
static
BYTE check_fs (	/* 0:Valid FAT-BS, 1:Valid BS but not FAT, 2:Not a BS, 3:Disk error */
	FATFS* fs,	/* File system object */
	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
)
{
80006c90:	eb cd 40 80 	pushm	r7,lr
80006c94:	18 97       	mov	r7,r12
	fs->wflag = 0; fs->winsect = 0xFFFFFFFF;	/* Invaidate window */
80006c96:	30 08       	mov	r8,0
80006c98:	b8 c8       	st.b	r12[0x4],r8
80006c9a:	3f f8       	mov	r8,-1
80006c9c:	99 b8       	st.w	r12[0x2c],r8
	if (move_window(fs, sect) != FR_OK)			/* Load boot record */
80006c9e:	f0 1f 00 23 	mcall	80006d28 <check_fs+0x98>
80006ca2:	c0 40       	breq	80006caa <check_fs+0x1a>
80006ca4:	30 3c       	mov	r12,3
80006ca6:	e3 cd 80 80 	ldm	sp++,r7,pc
		return 3;

	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)	/* Check boot record signature (always placed at offset 510 even if the sector size is >512) */
80006caa:	ef 39 02 2f 	ld.ub	r9,r7[559]
80006cae:	ef 38 02 2e 	ld.ub	r8,r7[558]
80006cb2:	f1 e9 10 89 	or	r9,r8,r9<<0x8
80006cb6:	fe 78 aa 55 	mov	r8,-21931
80006cba:	f0 09 19 00 	cp.h	r9,r8
80006cbe:	c0 40       	breq	80006cc6 <check_fs+0x36>
80006cc0:	30 2c       	mov	r12,2
80006cc2:	e3 cd 80 80 	ldm	sp++,r7,pc
		return 2;

	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)		/* Check "FAT" string */
80006cc6:	ef 39 00 69 	ld.ub	r9,r7[105]
80006cca:	ef 38 00 68 	ld.ub	r8,r7[104]
80006cce:	b1 68       	lsl	r8,0x10
80006cd0:	f1 e9 11 88 	or	r8,r8,r9<<0x18
80006cd4:	ef 39 00 66 	ld.ub	r9,r7[102]
80006cd8:	12 48       	or	r8,r9
80006cda:	ef 39 00 67 	ld.ub	r9,r7[103]
80006cde:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80006ce2:	f1 d8 c0 18 	bfextu	r8,r8,0x0,0x18
80006ce6:	e0 69 41 46 	mov	r9,16710
80006cea:	ea 19 00 54 	orh	r9,0x54
80006cee:	12 38       	cp.w	r8,r9
80006cf0:	c0 31       	brne	80006cf6 <check_fs+0x66>
80006cf2:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
80006cf6:	ef 39 00 85 	ld.ub	r9,r7[133]
80006cfa:	ef 38 00 84 	ld.ub	r8,r7[132]
80006cfe:	b1 68       	lsl	r8,0x10
80006d00:	f1 e9 11 88 	or	r8,r8,r9<<0x18
80006d04:	ef 39 00 82 	ld.ub	r9,r7[130]
80006d08:	12 48       	or	r8,r9
80006d0a:	ef 39 00 83 	ld.ub	r9,r7[131]
80006d0e:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80006d12:	f1 d8 c0 18 	bfextu	r8,r8,0x0,0x18
80006d16:	e0 69 41 46 	mov	r9,16710
80006d1a:	ea 19 00 54 	orh	r9,0x54
80006d1e:	12 38       	cp.w	r8,r9
80006d20:	5f 1c       	srne	r12
		return 0;
	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
		return 0;

	return 1;
}
80006d22:	e3 cd 80 80 	ldm	sp++,r7,pc
80006d26:	00 00       	add	r0,r0
80006d28:	80 00       	ld.sh	r0,r0[0x0]
80006d2a:	6c 50       	ld.w	r0,r6[0x14]

80006d2c <find_volume>:
FRESULT find_volume (	/* FR_OK(0): successful, !=0: any error occurred */
	FATFS** rfs,		/* Pointer to pointer to the found file system object */
	const TCHAR** path,	/* Pointer to pointer to the path name (drive number) */
	BYTE wmode			/* !=0: Check write protection for write access */
)
{
80006d2c:	eb cd 40 fb 	pushm	r0-r1,r3-r7,lr
80006d30:	20 4d       	sub	sp,16
80006d32:	18 95       	mov	r5,r12
80006d34:	14 94       	mov	r4,r10
	FATFS *fs;
	UINT i;


	/* Get logical drive number from the path name */
	*rfs = 0;
80006d36:	30 08       	mov	r8,0
80006d38:	99 08       	st.w	r12[0x0],r8
	vol = get_ldnumber(path);
80006d3a:	16 9c       	mov	r12,r11
80006d3c:	f0 1f 00 de 	mcall	800070b4 <find_volume+0x388>
80006d40:	18 96       	mov	r6,r12
	if (vol < 0) return FR_INVALID_DRIVE;
80006d42:	c0 34       	brge	80006d48 <find_volume+0x1c>
80006d44:	30 bc       	mov	r12,11
80006d46:	ca a9       	rjmp	8000709a <find_volume+0x36e>

	/* Check if the file system object is valid or not */
	fs = FatFs[vol];					/* Get pointer to the file system object */
80006d48:	fe f8 03 70 	ld.w	r8,pc[880]
80006d4c:	f0 0c 03 27 	ld.w	r7,r8[r12<<0x2]
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
80006d50:	58 07       	cp.w	r7,0
80006d52:	c0 31       	brne	80006d58 <find_volume+0x2c>
80006d54:	30 cc       	mov	r12,12
80006d56:	ca 29       	rjmp	8000709a <find_volume+0x36e>

	ENTER_FF(fs);						/* Lock the volume */
	*rfs = fs;							/* Return pointer to the file system object */
80006d58:	8b 07       	st.w	r5[0x0],r7

	if (fs->fs_type) {					/* If the volume has been mounted */
80006d5a:	0f 89       	ld.ub	r9,r7[0x0]
80006d5c:	30 08       	mov	r8,0
80006d5e:	f0 09 18 00 	cp.b	r9,r8
80006d62:	c0 f0       	breq	80006d80 <find_volume+0x54>
		stat = disk_status(fs->drv);
80006d64:	0f 9c       	ld.ub	r12,r7[0x1]
80006d66:	f0 1f 00 d6 	mcall	800070bc <find_volume+0x390>
		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized */
80006d6a:	f1 dc c0 01 	bfextu	r8,r12,0x0,0x1
80006d6e:	c0 91       	brne	80006d80 <find_volume+0x54>
			if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check write protection if needed */
80006d70:	58 04       	cp.w	r4,0
80006d72:	e0 80 01 91 	breq	80007094 <find_volume+0x368>
80006d76:	e2 1c 00 04 	andl	r12,0x4,COH
80006d7a:	e0 81 01 8b 	brne	80007090 <find_volume+0x364>
80006d7e:	c8 b9       	rjmp	80007094 <find_volume+0x368>
	}

	/* The file system object is not valid. */
	/* Following code attempts to mount the volume. (analyze BPB and initialize the fs object) */

	fs->fs_type = 0;					/* Clear the file system object */
80006d80:	30 08       	mov	r8,0
80006d82:	ae 88       	st.b	r7[0x0],r8
	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
80006d84:	f9 d6 c0 08 	bfextu	r12,r6,0x0,0x8
80006d88:	ae 9c       	st.b	r7[0x1],r12
	stat = disk_initialize(fs->drv);	/* Initialize the physical drive */
80006d8a:	f0 1f 00 ce 	mcall	800070c0 <find_volume+0x394>
	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
80006d8e:	f1 dc c0 01 	bfextu	r8,r12,0x0,0x1
80006d92:	c0 30       	breq	80006d98 <find_volume+0x6c>
80006d94:	30 3c       	mov	r12,3
80006d96:	c8 29       	rjmp	8000709a <find_volume+0x36e>
		return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
	if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check disk write protection if needed */
80006d98:	58 04       	cp.w	r4,0
80006d9a:	c0 50       	breq	80006da4 <find_volume+0x78>
80006d9c:	e2 1c 00 04 	andl	r12,0x4,COH
80006da0:	e0 81 01 78 	brne	80007090 <find_volume+0x364>
	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &SS(fs)) != RES_OK
		|| SS(fs) < _MIN_SS || SS(fs) > _MAX_SS) return FR_DISK_ERR;
#endif
	/* Find an FAT partition on the drive. Supports only generic partitioning, FDISK and SFD. */
	bsect = 0;
	fmt = check_fs(fs, bsect);					/* Load sector 0 and check if it is an FAT boot sector as SFD */
80006da4:	30 0b       	mov	r11,0
80006da6:	0e 9c       	mov	r12,r7
80006da8:	f0 1f 00 c7 	mcall	800070c4 <find_volume+0x398>
	if (fmt == 1 || (!fmt && (LD2PT(vol)))) {	/* Not an FAT boot sector or forced partition number */
80006dac:	30 18       	mov	r8,1
80006dae:	f0 0c 18 00 	cp.b	r12,r8
80006db2:	c0 30       	breq	80006db8 <find_volume+0x8c>
80006db4:	30 05       	mov	r5,0
80006db6:	c3 48       	rjmp	80006e1e <find_volume+0xf2>
80006db8:	1a 96       	mov	r6,sp
80006dba:	1a 9a       	mov	r10,sp
80006dbc:	e0 68 01 be 	mov	r8,446
		for (i = 0; i < 4; i++) {			/* Get partition offset */
			pt = fs->win + MBR_Table + i * SZ_PTE;
			br[i] = pt[4] ? LD_DWORD(&pt[8]) : 0;
80006dc0:	30 0c       	mov	r12,0
80006dc2:	30 04       	mov	r4,0
	/* Find an FAT partition on the drive. Supports only generic partitioning, FDISK and SFD. */
	bsect = 0;
	fmt = check_fs(fs, bsect);					/* Load sector 0 and check if it is an FAT boot sector as SFD */
	if (fmt == 1 || (!fmt && (LD2PT(vol)))) {	/* Not an FAT boot sector or forced partition number */
		for (i = 0; i < 4; i++) {			/* Get partition offset */
			pt = fs->win + MBR_Table + i * SZ_PTE;
80006dc4:	f0 c9 ff d0 	sub	r9,r8,-48
80006dc8:	ee 09 00 09 	add	r9,r7,r9
			br[i] = pt[4] ? LD_DWORD(&pt[8]) : 0;
80006dcc:	13 cb       	ld.ub	r11,r9[0x4]
80006dce:	f8 0b 18 00 	cp.b	r11,r12
80006dd2:	c0 31       	brne	80006dd8 <find_volume+0xac>
80006dd4:	08 99       	mov	r9,r4
80006dd6:	c0 f8       	rjmp	80006df4 <find_volume+0xc8>
80006dd8:	f3 35 00 0b 	ld.ub	r5,r9[11]
80006ddc:	f3 3b 00 0a 	ld.ub	r11,r9[10]
80006de0:	b1 6b       	lsl	r11,0x10
80006de2:	f7 e5 11 8b 	or	r11,r11,r5<<0x18
80006de6:	f3 35 00 08 	ld.ub	r5,r9[8]
80006dea:	0a 4b       	or	r11,r5
80006dec:	f3 39 00 09 	ld.ub	r9,r9[9]
80006df0:	f7 e9 10 89 	or	r9,r11,r9<<0x8
80006df4:	14 a9       	st.w	r10++,r9
80006df6:	2f 08       	sub	r8,-16
#endif
	/* Find an FAT partition on the drive. Supports only generic partitioning, FDISK and SFD. */
	bsect = 0;
	fmt = check_fs(fs, bsect);					/* Load sector 0 and check if it is an FAT boot sector as SFD */
	if (fmt == 1 || (!fmt && (LD2PT(vol)))) {	/* Not an FAT boot sector or forced partition number */
		for (i = 0; i < 4; i++) {			/* Get partition offset */
80006df8:	e0 48 01 fe 	cp.w	r8,510
80006dfc:	ce 41       	brne	80006dc4 <find_volume+0x98>
/*-----------------------------------------------------------------------*/
/* Find logical drive and check if the volume is mounted                 */
/*-----------------------------------------------------------------------*/

static
FRESULT find_volume (	/* FR_OK(0): successful, !=0: any error occurred */
80006dfe:	fa c4 ff f0 	sub	r4,sp,-16
		}
		i = LD2PT(vol);						/* Partition number: 0:auto, 1-4:forced */
		if (i) i--;
		do {								/* Find an FAT volume */
			bsect = br[i];
			fmt = bsect ? check_fs(fs, bsect) : 2;	/* Check the partition */
80006e02:	30 23       	mov	r3,2
			br[i] = pt[4] ? LD_DWORD(&pt[8]) : 0;
		}
		i = LD2PT(vol);						/* Partition number: 0:auto, 1-4:forced */
		if (i) i--;
		do {								/* Find an FAT volume */
			bsect = br[i];
80006e04:	6c 05       	ld.w	r5,r6[0x0]
			fmt = bsect ? check_fs(fs, bsect) : 2;	/* Check the partition */
80006e06:	58 05       	cp.w	r5,0
80006e08:	c0 31       	brne	80006e0e <find_volume+0xe2>
80006e0a:	06 9c       	mov	r12,r3
80006e0c:	c0 68       	rjmp	80006e18 <find_volume+0xec>
80006e0e:	0a 9b       	mov	r11,r5
80006e10:	0e 9c       	mov	r12,r7
80006e12:	f0 1f 00 ad 	mcall	800070c4 <find_volume+0x398>
		} while (!LD2PT(vol) && fmt && ++i < 4);
80006e16:	c0 d0       	breq	80006e30 <find_volume+0x104>
80006e18:	2f c6       	sub	r6,-4
80006e1a:	08 36       	cp.w	r6,r4
80006e1c:	cf 41       	brne	80006e04 <find_volume+0xd8>
	}
	if (fmt == 3) return FR_DISK_ERR;		/* An error occured in the disk I/O layer */
80006e1e:	30 38       	mov	r8,3
80006e20:	f0 0c 18 00 	cp.b	r12,r8
80006e24:	c0 31       	brne	80006e2a <find_volume+0xfe>
80006e26:	30 1c       	mov	r12,1
80006e28:	c3 99       	rjmp	8000709a <find_volume+0x36e>
	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
80006e2a:	58 0c       	cp.w	r12,0
80006e2c:	e0 81 01 36 	brne	80007098 <find_volume+0x36c>

	/* An FAT volume is found. Following code initializes the file system object */

	if (LD_WORD(fs->win + BPB_BytsPerSec) != SS(fs))	/* (BPB_BytsPerSec must be equal to the physical sector size) */
80006e30:	ef 39 00 3c 	ld.ub	r9,r7[60]
80006e34:	ef 38 00 3b 	ld.ub	r8,r7[59]
80006e38:	f1 e9 10 89 	or	r9,r8,r9<<0x8
80006e3c:	e0 68 02 00 	mov	r8,512
80006e40:	f0 09 19 00 	cp.h	r9,r8
80006e44:	e0 81 01 2a 	brne	80007098 <find_volume+0x36c>
		return FR_NO_FILESYSTEM;

	fasize = LD_WORD(fs->win + BPB_FATSz16);			/* Number of sectors per FAT */
80006e48:	ef 39 00 47 	ld.ub	r9,r7[71]
80006e4c:	ef 38 00 46 	ld.ub	r8,r7[70]
80006e50:	f1 e9 10 88 	or	r8,r8,r9<<0x8
	if (!fasize) fasize = LD_DWORD(fs->win + BPB_FATSz32);
80006e54:	c1 01       	brne	80006e74 <find_volume+0x148>
80006e56:	ef 39 00 57 	ld.ub	r9,r7[87]
80006e5a:	ef 38 00 56 	ld.ub	r8,r7[86]
80006e5e:	b1 68       	lsl	r8,0x10
80006e60:	f1 e9 11 89 	or	r9,r8,r9<<0x18
80006e64:	ef 38 00 54 	ld.ub	r8,r7[84]
80006e68:	f3 e8 10 08 	or	r8,r9,r8
80006e6c:	ef 39 00 55 	ld.ub	r9,r7[85]
80006e70:	f1 e9 10 88 	or	r8,r8,r9<<0x8
	fs->fsize = fasize;
80006e74:	8f 68       	st.w	r7[0x18],r8

	fs->n_fats = fs->win[BPB_NumFATs];					/* Number of FAT copies */
80006e76:	ef 39 00 40 	ld.ub	r9,r7[64]
80006e7a:	ae b9       	st.b	r7[0x3],r9
	if (fs->n_fats != 1 && fs->n_fats != 2)				/* (Must be 1 or 2) */
80006e7c:	f2 cb 00 01 	sub	r11,r9,1
80006e80:	30 1a       	mov	r10,1
80006e82:	f4 0b 18 00 	cp.b	r11,r10
80006e86:	e0 8b 01 09 	brhi	80007098 <find_volume+0x36c>
		return FR_NO_FILESYSTEM;
	fasize *= fs->n_fats;								/* Number of sectors for FAT area */

	fs->csize = fs->win[BPB_SecPerClus];				/* Number of sectors per cluster */
80006e8a:	ef 3a 00 3d 	ld.ub	r10,r7[61]
80006e8e:	ae aa       	st.b	r7[0x2],r10
	if (!fs->csize || (fs->csize & (fs->csize - 1)))	/* (Must be power of 2) */
80006e90:	58 0a       	cp.w	r10,0
80006e92:	e0 80 01 03 	breq	80007098 <find_volume+0x36c>
80006e96:	f4 cb 00 01 	sub	r11,r10,1
80006e9a:	14 6b       	and	r11,r10
80006e9c:	e0 81 00 fe 	brne	80007098 <find_volume+0x36c>
		return FR_NO_FILESYSTEM;

	fs->n_rootdir = LD_WORD(fs->win + BPB_RootEntCnt);	/* Number of root directory entries */
80006ea0:	ef 3c 00 42 	ld.ub	r12,r7[66]
80006ea4:	ef 3b 00 41 	ld.ub	r11,r7[65]
80006ea8:	f7 ec 10 8b 	or	r11,r11,r12<<0x8
80006eac:	5c 8b       	casts.h	r11
80006eae:	ae 4b       	st.h	r7[0x8],r11
	if (fs->n_rootdir % (SS(fs) / SZ_DIRE))				/* (Must be sector aligned) */
80006eb0:	f9 db c0 04 	bfextu	r12,r11,0x0,0x4
80006eb4:	e0 81 00 f2 	brne	80007098 <find_volume+0x36c>
		return FR_NO_FILESYSTEM;

	tsect = LD_WORD(fs->win + BPB_TotSec16);			/* Number of sectors on the volume */
80006eb8:	ef 36 00 44 	ld.ub	r6,r7[68]
80006ebc:	ef 3c 00 43 	ld.ub	r12,r7[67]
80006ec0:	f9 e6 10 8c 	or	r12,r12,r6<<0x8
	if (!tsect) tsect = LD_DWORD(fs->win + BPB_TotSec32);
80006ec4:	c1 01       	brne	80006ee4 <find_volume+0x1b8>
80006ec6:	ef 36 00 53 	ld.ub	r6,r7[83]
80006eca:	ef 3c 00 52 	ld.ub	r12,r7[82]
80006ece:	b1 6c       	lsl	r12,0x10
80006ed0:	f9 e6 11 86 	or	r6,r12,r6<<0x18
80006ed4:	ef 3c 00 50 	ld.ub	r12,r7[80]
80006ed8:	ed ec 10 0c 	or	r12,r6,r12
80006edc:	ef 36 00 51 	ld.ub	r6,r7[81]
80006ee0:	f9 e6 10 8c 	or	r12,r12,r6<<0x8

	nrsv = LD_WORD(fs->win + BPB_RsvdSecCnt);			/* Number of reserved sectors */
80006ee4:	ef 34 00 3f 	ld.ub	r4,r7[63]
80006ee8:	ef 36 00 3e 	ld.ub	r6,r7[62]
80006eec:	ed e4 10 86 	or	r6,r6,r4<<0x8
80006ef0:	5c 86       	casts.h	r6
	if (!nrsv) return FR_NO_FILESYSTEM;					/* (Must not be 0) */
80006ef2:	e0 80 00 d3 	breq	80007098 <find_volume+0x36c>
	fs->fsize = fasize;

	fs->n_fats = fs->win[BPB_NumFATs];					/* Number of FAT copies */
	if (fs->n_fats != 1 && fs->n_fats != 2)				/* (Must be 1 or 2) */
		return FR_NO_FILESYSTEM;
	fasize *= fs->n_fats;								/* Number of sectors for FAT area */
80006ef6:	b3 38       	mul	r8,r9

	nrsv = LD_WORD(fs->win + BPB_RsvdSecCnt);			/* Number of reserved sectors */
	if (!nrsv) return FR_NO_FILESYSTEM;					/* (Must not be 0) */

	/* Determine the FAT sub type */
	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIRE);	/* RSV + FAT + DIR */
80006ef8:	e7 d6 c0 10 	bfextu	r3,r6,0x0,0x10
80006efc:	e9 db c0 8c 	bfextu	r4,r11,0x4,0xc
80006f00:	06 04       	add	r4,r3
80006f02:	10 04       	add	r4,r8
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
80006f04:	08 3c       	cp.w	r12,r4
80006f06:	e0 83 00 c9 	brlo	80007098 <find_volume+0x36c>
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
80006f0a:	f8 04 01 01 	sub	r1,r12,r4
80006f0e:	e2 0a 0d 00 	divu	r0,r1,r10
80006f12:	00 99       	mov	r9,r0
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
80006f14:	58 00       	cp.w	r0,0
80006f16:	e0 80 00 c1 	breq	80007098 <find_volume+0x36c>
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
80006f1a:	e0 40 0f f6 	cp.w	r0,4086
80006f1e:	f9 b6 03 01 	movlo	r6,1
80006f22:	f9 b6 02 02 	movhs	r6,2
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
80006f26:	e0 40 ff f5 	cp.w	r0,65525
80006f2a:	e0 8b 00 bb 	brhi	800070a0 <find_volume+0x374>

	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
80006f2e:	2f e9       	sub	r9,-2
80006f30:	8f 59       	st.w	r7[0x14],r9
	fs->volbase = bsect;								/* Volume start sector */
80006f32:	8f 75       	st.w	r7[0x1c],r5
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
80006f34:	ea 03 00 03 	add	r3,r5,r3
80006f38:	8f 83       	st.w	r7[0x20],r3
	fs->database = bsect + sysect;						/* Data start sector */
80006f3a:	0a 04       	add	r4,r5
80006f3c:	8f a4       	st.w	r7[0x28],r4
	if (fmt == FS_FAT32) {
80006f3e:	30 3a       	mov	r10,3
80006f40:	f4 06 18 00 	cp.b	r6,r10
80006f44:	c1 61       	brne	80006f70 <find_volume+0x244>
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
80006f46:	58 0b       	cp.w	r11,0
80006f48:	e0 81 00 a8 	brne	80007098 <find_volume+0x36c>
		fs->dirbase = LD_DWORD(fs->win + BPB_RootClus);	/* Root directory start cluster */
80006f4c:	ef 3a 00 5f 	ld.ub	r10,r7[95]
80006f50:	ef 38 00 5e 	ld.ub	r8,r7[94]
80006f54:	b1 68       	lsl	r8,0x10
80006f56:	f1 ea 11 8a 	or	r10,r8,r10<<0x18
80006f5a:	ef 38 00 5c 	ld.ub	r8,r7[92]
80006f5e:	f5 e8 10 08 	or	r8,r10,r8
80006f62:	ef 3a 00 5d 	ld.ub	r10,r7[93]
80006f66:	f1 ea 10 88 	or	r8,r8,r10<<0x8
80006f6a:	8f 98       	st.w	r7[0x24],r8
		szbfat = fs->n_fatent * 4;						/* (Needed FAT size) */
80006f6c:	a3 69       	lsl	r9,0x2
80006f6e:	c1 38       	rjmp	80006f94 <find_volume+0x268>
	} else {
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
80006f70:	58 0b       	cp.w	r11,0
80006f72:	e0 80 00 93 	breq	80007098 <find_volume+0x36c>
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
80006f76:	06 08       	add	r8,r3
80006f78:	8f 98       	st.w	r7[0x24],r8
		szbfat = (fmt == FS_FAT16) ?					/* (Needed FAT size) */
80006f7a:	30 28       	mov	r8,2
80006f7c:	f0 06 18 00 	cp.b	r6,r8
80006f80:	c0 31       	brne	80006f86 <find_volume+0x25a>
80006f82:	a1 79       	lsl	r9,0x1
80006f84:	c0 88       	rjmp	80006f94 <find_volume+0x268>
80006f86:	f2 09 00 18 	add	r8,r9,r9<<0x1
80006f8a:	a1 98       	lsr	r8,0x1
80006f8c:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
80006f90:	f0 09 00 09 	add	r9,r8,r9
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
	}
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than the size needed) */
80006f94:	f2 c8 fe 01 	sub	r8,r9,-511
80006f98:	a9 98       	lsr	r8,0x9
80006f9a:	6e 69       	ld.w	r9,r7[0x18]
80006f9c:	10 39       	cp.w	r9,r8
80006f9e:	c7 d3       	brcs	80007098 <find_volume+0x36c>
		return FR_NO_FILESYSTEM;

#if !_FS_READONLY
	/* Initialize cluster allocation information */
	fs->last_clust = fs->free_clust = 0xFFFFFFFF;
80006fa0:	3f f8       	mov	r8,-1
80006fa2:	8f 48       	st.w	r7[0x10],r8
80006fa4:	8f 38       	st.w	r7[0xc],r8

	/* Get fsinfo if available */
	fs->fsi_flag = 0x80;
80006fa6:	38 08       	mov	r8,-128
80006fa8:	ae d8       	st.b	r7[0x5],r8
#if (_FS_NOFSINFO & 3) != 3
	if (fmt == FS_FAT32				/* Enable FSINFO only if FAT32 and BPB_FSInfo == 1 */
80006faa:	30 38       	mov	r8,3
80006fac:	f0 06 18 00 	cp.b	r6,r8
80006fb0:	c6 81       	brne	80007080 <find_volume+0x354>
		&& LD_WORD(fs->win + BPB_FSInfo) == 1
80006fb2:	ef 39 00 61 	ld.ub	r9,r7[97]
80006fb6:	ef 38 00 60 	ld.ub	r8,r7[96]
80006fba:	f1 e9 10 89 	or	r9,r8,r9<<0x8
80006fbe:	30 18       	mov	r8,1
80006fc0:	f0 09 19 00 	cp.h	r9,r8
80006fc4:	c5 e1       	brne	80007080 <find_volume+0x354>
		&& move_window(fs, bsect + 1) == FR_OK)
80006fc6:	ea cb ff ff 	sub	r11,r5,-1
80006fca:	0e 9c       	mov	r12,r7
80006fcc:	f0 1f 00 3f 	mcall	800070c8 <find_volume+0x39c>
	fs->last_clust = fs->free_clust = 0xFFFFFFFF;

	/* Get fsinfo if available */
	fs->fsi_flag = 0x80;
#if (_FS_NOFSINFO & 3) != 3
	if (fmt == FS_FAT32				/* Enable FSINFO only if FAT32 and BPB_FSInfo == 1 */
80006fd0:	c5 81       	brne	80007080 <find_volume+0x354>
		&& LD_WORD(fs->win + BPB_FSInfo) == 1
		&& move_window(fs, bsect + 1) == FR_OK)
	{
		fs->fsi_flag = 0;
80006fd2:	30 08       	mov	r8,0
80006fd4:	ae d8       	st.b	r7[0x5],r8
		if (LD_WORD(fs->win + BS_55AA) == 0xAA55	/* Load FSINFO data if available */
80006fd6:	ef 39 02 2f 	ld.ub	r9,r7[559]
80006fda:	ef 38 02 2e 	ld.ub	r8,r7[558]
80006fde:	f1 e9 10 89 	or	r9,r8,r9<<0x8
80006fe2:	fe 78 aa 55 	mov	r8,-21931
80006fe6:	f0 09 19 00 	cp.h	r9,r8
80006fea:	c4 b1       	brne	80007080 <find_volume+0x354>
			&& LD_DWORD(fs->win + FSI_LeadSig) == 0x41615252
80006fec:	ef 39 00 33 	ld.ub	r9,r7[51]
80006ff0:	ef 38 00 32 	ld.ub	r8,r7[50]
80006ff4:	b1 68       	lsl	r8,0x10
80006ff6:	f1 e9 11 89 	or	r9,r8,r9<<0x18
80006ffa:	ef 38 00 30 	ld.ub	r8,r7[48]
80006ffe:	f3 e8 10 08 	or	r8,r9,r8
80007002:	ef 39 00 31 	ld.ub	r9,r7[49]
80007006:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000700a:	e0 69 52 52 	mov	r9,21074
8000700e:	ea 19 41 61 	orh	r9,0x4161
80007012:	12 38       	cp.w	r8,r9
80007014:	c3 61       	brne	80007080 <find_volume+0x354>
			&& LD_DWORD(fs->win + FSI_StrucSig) == 0x61417272)
80007016:	ef 39 02 17 	ld.ub	r9,r7[535]
8000701a:	ef 38 02 16 	ld.ub	r8,r7[534]
8000701e:	b1 68       	lsl	r8,0x10
80007020:	f1 e9 11 89 	or	r9,r8,r9<<0x18
80007024:	ef 38 02 14 	ld.ub	r8,r7[532]
80007028:	f3 e8 10 08 	or	r8,r9,r8
8000702c:	ef 39 02 15 	ld.ub	r9,r7[533]
80007030:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80007034:	e0 69 72 72 	mov	r9,29298
80007038:	ea 19 61 41 	orh	r9,0x6141
8000703c:	12 38       	cp.w	r8,r9
8000703e:	c2 11       	brne	80007080 <find_volume+0x354>
		{
#if (_FS_NOFSINFO & 1) == 0
			fs->free_clust = LD_DWORD(fs->win + FSI_Free_Count);
80007040:	ef 39 02 1b 	ld.ub	r9,r7[539]
80007044:	ef 38 02 1a 	ld.ub	r8,r7[538]
80007048:	b1 68       	lsl	r8,0x10
8000704a:	f1 e9 11 89 	or	r9,r8,r9<<0x18
8000704e:	ef 38 02 18 	ld.ub	r8,r7[536]
80007052:	f3 e8 10 08 	or	r8,r9,r8
80007056:	ef 39 02 19 	ld.ub	r9,r7[537]
8000705a:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000705e:	8f 48       	st.w	r7[0x10],r8
#endif
#if (_FS_NOFSINFO & 2) == 0
			fs->last_clust = LD_DWORD(fs->win + FSI_Nxt_Free);
80007060:	ef 39 02 1f 	ld.ub	r9,r7[543]
80007064:	ef 38 02 1e 	ld.ub	r8,r7[542]
80007068:	b1 68       	lsl	r8,0x10
8000706a:	f1 e9 11 89 	or	r9,r8,r9<<0x18
8000706e:	ef 38 02 1c 	ld.ub	r8,r7[540]
80007072:	f3 e8 10 08 	or	r8,r9,r8
80007076:	ef 39 02 1d 	ld.ub	r9,r7[541]
8000707a:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000707e:	8f 38       	st.w	r7[0xc],r8
#endif
		}
	}
#endif
#endif
	fs->fs_type = fmt;	/* FAT sub-type */
80007080:	ae 86       	st.b	r7[0x0],r6
	fs->id = ++Fsid;	/* File system mount ID */
80007082:	49 39       	lddpc	r9,800070cc <find_volume+0x3a0>
80007084:	92 08       	ld.sh	r8,r9[0x0]
80007086:	2f f8       	sub	r8,-1
80007088:	b2 08       	st.h	r9[0x0],r8
8000708a:	ae 38       	st.h	r7[0x6],r8
8000708c:	30 0c       	mov	r12,0
#endif
#if _FS_LOCK			/* Clear file lock semaphores */
	clear_lock(fs);
#endif

	return FR_OK;
8000708e:	c0 68       	rjmp	8000709a <find_volume+0x36e>
80007090:	30 ac       	mov	r12,10
80007092:	c0 48       	rjmp	8000709a <find_volume+0x36e>
80007094:	30 0c       	mov	r12,0
80007096:	c0 28       	rjmp	8000709a <find_volume+0x36e>
80007098:	30 dc       	mov	r12,13
}
8000709a:	2f cd       	sub	sp,-16
8000709c:	e3 cd 80 fb 	ldm	sp++,r0-r1,r3-r7,pc
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;

	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
800070a0:	2f e9       	sub	r9,-2
800070a2:	8f 59       	st.w	r7[0x14],r9
	fs->volbase = bsect;								/* Volume start sector */
800070a4:	8f 75       	st.w	r7[0x1c],r5
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
800070a6:	ea 03 00 03 	add	r3,r5,r3
800070aa:	8f 83       	st.w	r7[0x20],r3
	fs->database = bsect + sysect;						/* Data start sector */
800070ac:	0a 04       	add	r4,r5
800070ae:	8f a4       	st.w	r7[0x28],r4
800070b0:	30 36       	mov	r6,3
800070b2:	c4 ab       	rjmp	80006f46 <find_volume+0x21a>
800070b4:	80 00       	ld.sh	r0,r0[0x0]
800070b6:	63 9c       	ld.w	r12,r1[0x64]
800070b8:	00 00       	add	r0,r0
800070ba:	11 50       	ld.sh	r0,--r8
800070bc:	80 00       	ld.sh	r0,r0[0x0]
800070be:	62 00       	ld.w	r0,r1[0x0]
800070c0:	80 00       	ld.sh	r0,r0[0x0]
800070c2:	62 02       	ld.w	r2,r1[0x0]
800070c4:	80 00       	ld.sh	r0,r0[0x0]
800070c6:	6c 90       	ld.w	r0,r6[0x24]
800070c8:	80 00       	ld.sh	r0,r0[0x0]
800070ca:	6c 50       	ld.w	r0,r6[0x14]
800070cc:	00 00       	add	r0,r0
800070ce:	11 4c       	ld.w	r12,--r8

800070d0 <f_mount>:
FRESULT f_mount (
	FATFS* fs,			/* Pointer to the file system object (NULL:unmount)*/
	const TCHAR* path,	/* Logical drive number to be mounted/unmounted */
	BYTE opt			/* 0:Do not mount (delayed mount), 1:Mount immediately */
)
{
800070d0:	eb cd 40 40 	pushm	r6,lr
800070d4:	20 3d       	sub	sp,12
800070d6:	50 1c       	stdsp	sp[0x4],r12
800070d8:	50 0b       	stdsp	sp[0x0],r11
800070da:	14 96       	mov	r6,r10
	FATFS *cfs;
	int vol;
	FRESULT res;
	const TCHAR *rp = path;
800070dc:	fa cc ff f4 	sub	r12,sp,-12
800070e0:	18 db       	st.w	--r12,r11


	vol = get_ldnumber(&rp);
800070e2:	f0 1f 00 1a 	mcall	80007148 <f_mount+0x78>
	if (vol < 0) return FR_INVALID_DRIVE;
800070e6:	c0 34       	brge	800070ec <f_mount+0x1c>
800070e8:	30 bc       	mov	r12,11
800070ea:	c2 58       	rjmp	80007134 <f_mount+0x64>
	cfs = FatFs[vol];					/* Pointer to fs object */
800070ec:	49 88       	lddpc	r8,8000714c <f_mount+0x7c>
800070ee:	f0 0c 03 28 	ld.w	r8,r8[r12<<0x2]
		clear_lock(cfs);
#endif
#if _FS_REENTRANT						/* Discard sync object of the current volume */
		if (!ff_del_syncobj(cfs->sobj)) return FR_INT_ERR;
#endif
		cfs->fs_type = 0;				/* Clear old fs object */
800070f2:	58 08       	cp.w	r8,0
800070f4:	f9 b9 01 00 	movne	r9,0
800070f8:	f1 f9 1e 00 	st.bne	r8[0x0],r9
	}

	if (fs) {
800070fc:	40 18       	lddsp	r8,sp[0x4]
800070fe:	58 08       	cp.w	r8,0
80007100:	c1 d0       	breq	8000713a <f_mount+0x6a>
		fs->fs_type = 0;				/* Clear new fs object */
80007102:	30 09       	mov	r9,0
80007104:	b0 89       	st.b	r8[0x0],r9
#if _FS_REENTRANT						/* Create sync object for the new volume */
		if (!ff_cre_syncobj((BYTE)vol, &fs->sobj)) return FR_INT_ERR;
#endif
	}
	FatFs[vol] = fs;					/* Register new fs object */
80007106:	40 18       	lddsp	r8,sp[0x4]
80007108:	49 1a       	lddpc	r10,8000714c <f_mount+0x7c>
8000710a:	f4 0c 09 28 	st.w	r10[r12<<0x2],r8

	if (!fs || opt != 1) return FR_OK;	/* Do not mount now, it will be mounted later */
8000710e:	58 08       	cp.w	r8,0
80007110:	5f 0a       	sreq	r10
80007112:	30 18       	mov	r8,1
80007114:	f0 06 18 00 	cp.b	r6,r8
80007118:	5f 18       	srne	r8
8000711a:	f5 e8 10 08 	or	r8,r10,r8
8000711e:	f2 08 18 00 	cp.b	r8,r9
80007122:	c0 30       	breq	80007128 <f_mount+0x58>
80007124:	30 0c       	mov	r12,0
80007126:	c0 78       	rjmp	80007134 <f_mount+0x64>

	res = find_volume(&fs, &path, 0);	/* Force mounted the volume */
80007128:	30 0a       	mov	r10,0
8000712a:	1a 9b       	mov	r11,sp
8000712c:	fa cc ff fc 	sub	r12,sp,-4
80007130:	f0 1f 00 08 	mcall	80007150 <f_mount+0x80>
	LEAVE_FF(fs, res);
}
80007134:	2f dd       	sub	sp,-12
80007136:	e3 cd 80 40 	ldm	sp++,r6,pc
		fs->fs_type = 0;				/* Clear new fs object */
#if _FS_REENTRANT						/* Create sync object for the new volume */
		if (!ff_cre_syncobj((BYTE)vol, &fs->sobj)) return FR_INT_ERR;
#endif
	}
	FatFs[vol] = fs;					/* Register new fs object */
8000713a:	30 08       	mov	r8,0
8000713c:	48 49       	lddpc	r9,8000714c <f_mount+0x7c>
8000713e:	f2 0c 09 28 	st.w	r9[r12<<0x2],r8
80007142:	10 9c       	mov	r12,r8
80007144:	cf 8b       	rjmp	80007134 <f_mount+0x64>
80007146:	00 00       	add	r0,r0
80007148:	80 00       	ld.sh	r0,r0[0x0]
8000714a:	63 9c       	ld.w	r12,r1[0x64]
8000714c:	00 00       	add	r0,r0
8000714e:	11 50       	ld.sh	r0,--r8
80007150:	80 00       	ld.sh	r0,r0[0x0]
80007152:	6d 2c       	ld.w	r12,r6[0x48]

80007154 <f_sync>:
/*-----------------------------------------------------------------------*/

FRESULT f_sync (
	FIL* fp		/* Pointer to the file object */
)
{
80007154:	eb cd 40 c0 	pushm	r6-r7,lr
80007158:	18 97       	mov	r7,r12
	FRESULT res;
	DWORD tm;
	BYTE *dir;


	res = validate(fp);					/* Check validity of the object */
8000715a:	f0 1f 00 2b 	mcall	80007204 <f_sync+0xb0>
	if (res == FR_OK) {
8000715e:	c5 11       	brne	80007200 <f_sync+0xac>
		if (fp->flag & FA__WRITTEN) {	/* Is there any change to the file? */
80007160:	0f e8       	ld.ub	r8,r7[0x6]
80007162:	10 99       	mov	r9,r8
80007164:	e2 19 00 20 	andl	r9,0x20,COH
80007168:	c4 c0       	breq	80007200 <f_sync+0xac>
#if !_FS_TINY
			if (fp->flag & FA__DIRTY) {	/* Write-back cached data if needed */
8000716a:	e2 18 00 40 	andl	r8,0x40,COH
8000716e:	c0 f0       	breq	8000718c <f_sync+0x38>
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
80007170:	6e 08       	ld.w	r8,r7[0x0]
80007172:	30 19       	mov	r9,1
80007174:	6e 6a       	ld.w	r10,r7[0x18]
80007176:	ee cb ff d8 	sub	r11,r7,-40
8000717a:	11 9c       	ld.ub	r12,r8[0x1]
8000717c:	f0 1f 00 23 	mcall	80007208 <f_sync+0xb4>
80007180:	c0 30       	breq	80007186 <f_sync+0x32>
80007182:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
					LEAVE_FF(fp->fs, FR_DISK_ERR);
				fp->flag &= ~FA__DIRTY;
80007186:	0f e8       	ld.ub	r8,r7[0x6]
80007188:	a7 c8       	cbr	r8,0x6
8000718a:	ae e8       	st.b	r7[0x6],r8
			}
#endif
			/* Update the directory entry */
			res = move_window(fp->fs, fp->dir_sect);
8000718c:	6e 7b       	ld.w	r11,r7[0x1c]
8000718e:	6e 0c       	ld.w	r12,r7[0x0]
80007190:	f0 1f 00 1f 	mcall	8000720c <f_sync+0xb8>
			if (res == FR_OK) {
80007194:	c3 61       	brne	80007200 <f_sync+0xac>
				dir = fp->dir_ptr;
80007196:	6e 86       	ld.w	r6,r7[0x20]
				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
80007198:	ec c8 ff f5 	sub	r8,r6,-11
8000719c:	11 89       	ld.ub	r9,r8[0x0]
8000719e:	a5 b9       	sbr	r9,0x5
800071a0:	b0 89       	st.b	r8[0x0],r9
				ST_DWORD(dir + DIR_FileSize, fp->fsize);	/* Update file size */
800071a2:	6e 38       	ld.w	r8,r7[0xc]
800071a4:	ed 68 00 1c 	st.b	r6[28],r8
800071a8:	ef 38 00 0e 	ld.ub	r8,r7[14]
800071ac:	ed 68 00 1d 	st.b	r6[29],r8
800071b0:	8e e8       	ld.uh	r8,r7[0xc]
800071b2:	ed 68 00 1e 	st.b	r6[30],r8
800071b6:	ef 38 00 0c 	ld.ub	r8,r7[12]
800071ba:	ed 68 00 1f 	st.b	r6[31],r8
				st_clust(dir, fp->sclust);					/* Update start cluster */
800071be:	6e 4b       	ld.w	r11,r7[0x10]
800071c0:	0c 9c       	mov	r12,r6
800071c2:	f0 1f 00 14 	mcall	80007210 <f_sync+0xbc>
				tm = GET_FATTIME();							/* Update modified time */
800071c6:	f0 1f 00 14 	mcall	80007214 <f_sync+0xc0>
				ST_DWORD(dir + DIR_WrtTime, tm);
800071ca:	ed 6c 00 16 	st.b	r6[22],r12
800071ce:	f1 dc c1 08 	bfextu	r8,r12,0x8,0x8
800071d2:	ed 68 00 17 	st.b	r6[23],r8
800071d6:	f8 08 16 10 	lsr	r8,r12,0x10
800071da:	ed 68 00 18 	st.b	r6[24],r8
800071de:	b9 8c       	lsr	r12,0x18
800071e0:	ed 6c 00 19 	st.b	r6[25],r12
				ST_WORD(dir + DIR_LstAccDate, 0);
800071e4:	30 08       	mov	r8,0
800071e6:	ed 68 00 12 	st.b	r6[18],r8
800071ea:	ed 68 00 13 	st.b	r6[19],r8
				fp->flag &= ~FA__WRITTEN;
800071ee:	0f e8       	ld.ub	r8,r7[0x6]
800071f0:	a5 d8       	cbr	r8,0x5
800071f2:	ae e8       	st.b	r7[0x6],r8
				fp->fs->wflag = 1;
800071f4:	6e 08       	ld.w	r8,r7[0x0]
800071f6:	30 19       	mov	r9,1
800071f8:	b0 c9       	st.b	r8[0x4],r9
				res = sync_fs(fp->fs);
800071fa:	6e 0c       	ld.w	r12,r7[0x0]
800071fc:	f0 1f 00 07 	mcall	80007218 <f_sync+0xc4>
			}
		}
	}

	LEAVE_FF(fp->fs, res);
}
80007200:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80007204:	80 00       	ld.sh	r0,r0[0x0]
80007206:	6c 1c       	ld.w	r12,r6[0x4]
80007208:	80 00       	ld.sh	r0,r0[0x0]
8000720a:	62 90       	ld.w	r0,r1[0x24]
8000720c:	80 00       	ld.sh	r0,r0[0x0]
8000720e:	6c 50       	ld.w	r0,r6[0x14]
80007210:	80 00       	ld.sh	r0,r0[0x0]
80007212:	63 82       	ld.w	r2,r1[0x60]
80007214:	80 00       	ld.sh	r0,r0[0x0]
80007216:	62 04       	ld.w	r4,r1[0x0]
80007218:	80 00       	ld.sh	r0,r0[0x0]
8000721a:	64 bc       	ld.w	r12,r2[0x2c]

8000721c <f_close>:
/*-----------------------------------------------------------------------*/

FRESULT f_close (
	FIL *fp		/* Pointer to the file object to be closed */
)
{
8000721c:	eb cd 40 80 	pushm	r7,lr
80007220:	18 97       	mov	r7,r12
	FRESULT res;


#if !_FS_READONLY
	res = f_sync(fp);					/* Flush cached data */
80007222:	f0 1f 00 07 	mcall	8000723c <f_close+0x20>
	if (res == FR_OK)
80007226:	c0 81       	brne	80007236 <f_close+0x1a>
#endif
	{
		res = validate(fp);				/* Lock volume */
80007228:	0e 9c       	mov	r12,r7
8000722a:	f0 1f 00 06 	mcall	80007240 <f_close+0x24>
#endif
#if _FS_LOCK
			res = dec_lock(fp->lockid);	/* Decrement file open counter */
			if (res == FR_OK)
#endif
				fp->fs = 0;				/* Invalidate file object */
8000722e:	f9 b8 00 00 	moveq	r8,0
80007232:	ef f8 0a 00 	st.weq	r7[0x0],r8
			unlock_fs(fs, FR_OK);		/* Unlock volume */
#endif
		}
	}
	return res;
}
80007236:	e3 cd 80 80 	ldm	sp++,r7,pc
8000723a:	00 00       	add	r0,r0
8000723c:	80 00       	ld.sh	r0,r0[0x0]
8000723e:	71 54       	ld.w	r4,r8[0x54]
80007240:	80 00       	ld.sh	r0,r0[0x0]
80007242:	6c 1c       	ld.w	r12,r6[0x4]

80007244 <put_fat>:
FRESULT put_fat (	/* FR_OK(0):succeeded, !=0:error */
	FATFS* fs,		/* File system object */
	DWORD clst,		/* FAT index number (cluster number) to be changed */
	DWORD val		/* New value to be set to the entry */
)
{
80007244:	d4 21       	pushm	r4-r7,lr
80007246:	18 97       	mov	r7,r12
80007248:	16 96       	mov	r6,r11
8000724a:	14 95       	mov	r5,r10
	UINT bc;
	BYTE *p;
	FRESULT res;


	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
8000724c:	58 1b       	cp.w	r11,1
8000724e:	e0 88 00 90 	brls	8000736e <put_fat+0x12a>
80007252:	78 58       	ld.w	r8,r12[0x14]
80007254:	10 3b       	cp.w	r11,r8
80007256:	e0 82 00 8c 	brhs	8000736e <put_fat+0x12a>
		res = FR_INT_ERR;

	} else {
		switch (fs->fs_type) {
8000725a:	19 88       	ld.ub	r8,r12[0x0]
8000725c:	30 29       	mov	r9,2
8000725e:	f2 08 18 00 	cp.b	r8,r9
80007262:	c4 d0       	breq	800072fc <put_fat+0xb8>
80007264:	30 39       	mov	r9,3
80007266:	f2 08 18 00 	cp.b	r8,r9
8000726a:	c5 e0       	breq	80007326 <put_fat+0xe2>
8000726c:	30 19       	mov	r9,1
8000726e:	f2 08 18 00 	cp.b	r8,r9
80007272:	c7 e1       	brne	8000736e <put_fat+0x12a>
		case FS_FAT12 :
			bc = (UINT)clst; bc += bc / 2;
80007274:	f6 04 16 01 	lsr	r4,r11,0x1
80007278:	16 04       	add	r4,r11
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
8000727a:	e8 0b 16 09 	lsr	r11,r4,0x9
8000727e:	78 88       	ld.w	r8,r12[0x20]
80007280:	10 0b       	add	r11,r8
80007282:	f0 1f 00 3d 	mcall	80007374 <put_fat+0x130>
			if (res != FR_OK) break;
80007286:	c7 51       	brne	80007370 <put_fat+0x12c>
			p = &fs->win[bc++ % SS(fs)];
80007288:	f1 d4 c0 09 	bfextu	r8,r4,0x0,0x9
8000728c:	2f f4       	sub	r4,-1
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
8000728e:	ed d6 c0 01 	bfextu	r6,r6,0x0,0x1
80007292:	c0 d0       	breq	800072ac <put_fat+0x68>
80007294:	ee 08 00 09 	add	r9,r7,r8
80007298:	f3 39 00 30 	ld.ub	r9,r9[48]
8000729c:	f5 d5 c0 08 	bfextu	r10,r5,0x0,0x8
800072a0:	f3 d9 c0 04 	bfextu	r9,r9,0x0,0x4
800072a4:	f3 ea 10 49 	or	r9,r9,r10<<0x4
800072a8:	5c 59       	castu.b	r9
800072aa:	c0 38       	rjmp	800072b0 <put_fat+0x6c>
800072ac:	f3 d5 c0 08 	bfextu	r9,r5,0x0,0x8
800072b0:	ee 08 00 08 	add	r8,r7,r8
800072b4:	f1 69 00 30 	st.b	r8[48],r9
			fs->wflag = 1;
800072b8:	30 18       	mov	r8,1
800072ba:	ae c8       	st.b	r7[0x4],r8
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
800072bc:	e8 0b 16 09 	lsr	r11,r4,0x9
800072c0:	6e 88       	ld.w	r8,r7[0x20]
800072c2:	10 0b       	add	r11,r8
800072c4:	0e 9c       	mov	r12,r7
800072c6:	f0 1f 00 2c 	mcall	80007374 <put_fat+0x130>
			if (res != FR_OK) break;
800072ca:	c5 31       	brne	80007370 <put_fat+0x12c>
			p = &fs->win[bc % SS(fs)];
800072cc:	e9 d4 c0 09 	bfextu	r4,r4,0x0,0x9
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
800072d0:	58 06       	cp.w	r6,0
800072d2:	c0 40       	breq	800072da <put_fat+0x96>
800072d4:	eb d5 c0 88 	bfextu	r5,r5,0x4,0x8
800072d8:	c0 b8       	rjmp	800072ee <put_fat+0xaa>
800072da:	ee 04 00 08 	add	r8,r7,r4
800072de:	f1 38 00 30 	ld.ub	r8,r8[48]
800072e2:	eb d5 c1 04 	bfextu	r5,r5,0x8,0x4
800072e6:	e2 18 00 f0 	andl	r8,0xf0,COH
800072ea:	f1 e5 10 05 	or	r5,r8,r5
800072ee:	ee 04 00 04 	add	r4,r7,r4
800072f2:	e9 65 00 30 	st.b	r4[48],r5
			fs->wflag = 1;
800072f6:	30 18       	mov	r8,1
800072f8:	ae c8       	st.b	r7[0x4],r8
			break;
800072fa:	d8 22       	popm	r4-r7,pc

		case FS_FAT16 :
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
800072fc:	a9 8b       	lsr	r11,0x8
800072fe:	78 88       	ld.w	r8,r12[0x20]
80007300:	10 0b       	add	r11,r8
80007302:	f0 1f 00 1d 	mcall	80007374 <put_fat+0x130>
			if (res != FR_OK) break;
80007306:	c3 51       	brne	80007370 <put_fat+0x12c>
			p = &fs->win[clst * 2 % SS(fs)];
80007308:	a1 76       	lsl	r6,0x1
8000730a:	ed d6 c0 09 	bfextu	r6,r6,0x0,0x9
			ST_WORD(p, (WORD)val);
8000730e:	ee 06 00 08 	add	r8,r7,r6
80007312:	f1 65 00 30 	st.b	r8[48],r5
80007316:	10 96       	mov	r6,r8
80007318:	eb d5 c1 08 	bfextu	r5,r5,0x8,0x8
8000731c:	f1 65 00 31 	st.b	r8[49],r5
			fs->wflag = 1;
80007320:	30 18       	mov	r8,1
80007322:	ae c8       	st.b	r7[0x4],r8
			break;
80007324:	d8 22       	popm	r4-r7,pc

		case FS_FAT32 :
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
80007326:	a7 9b       	lsr	r11,0x7
80007328:	78 88       	ld.w	r8,r12[0x20]
8000732a:	10 0b       	add	r11,r8
8000732c:	f0 1f 00 12 	mcall	80007374 <put_fat+0x130>
			if (res != FR_OK) break;
80007330:	c2 01       	brne	80007370 <put_fat+0x12c>
			p = &fs->win[clst * 4 % SS(fs)];
80007332:	a3 66       	lsl	r6,0x2
80007334:	ed d6 c0 09 	bfextu	r6,r6,0x0,0x9
80007338:	ec c8 ff d0 	sub	r8,r6,-48
8000733c:	ee 08 00 08 	add	r8,r7,r8
			val |= LD_DWORD(p) & 0xF0000000;
80007340:	f0 c9 ff fd 	sub	r9,r8,-3
80007344:	13 8a       	ld.ub	r10,r9[0x0]
80007346:	b9 6a       	lsl	r10,0x18
80007348:	ee 06 00 06 	add	r6,r7,r6
8000734c:	e6 1a f0 00 	andh	r10,0xf000,COH
80007350:	f5 e5 10 05 	or	r5,r10,r5
			ST_DWORD(p, val);
80007354:	ed 65 00 30 	st.b	r6[48],r5
80007358:	f5 d5 c1 08 	bfextu	r10,r5,0x8,0x8
8000735c:	b0 9a       	st.b	r8[0x1],r10
8000735e:	ea 0a 16 10 	lsr	r10,r5,0x10
80007362:	b0 aa       	st.b	r8[0x2],r10
80007364:	b9 85       	lsr	r5,0x18
80007366:	b2 85       	st.b	r9[0x0],r5
			fs->wflag = 1;
80007368:	30 18       	mov	r8,1
8000736a:	ae c8       	st.b	r7[0x4],r8
			break;
8000736c:	d8 22       	popm	r4-r7,pc
8000736e:	30 2c       	mov	r12,2
			res = FR_INT_ERR;
		}
	}

	return res;
}
80007370:	d8 22       	popm	r4-r7,pc
80007372:	00 00       	add	r0,r0
80007374:	80 00       	ld.sh	r0,r0[0x0]
80007376:	6c 50       	ld.w	r0,r6[0x14]

80007378 <get_fat>:

DWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Internal error, 2..0x0FFFFFFF:Cluster status */
	FATFS* fs,	/* File system object */
	DWORD clst	/* FAT index number (cluster number) to get the value */
)
{
80007378:	d4 21       	pushm	r4-r7,lr
8000737a:	18 97       	mov	r7,r12
8000737c:	16 96       	mov	r6,r11
	UINT wc, bc;
	BYTE *p;
	DWORD val;


	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
8000737e:	58 1b       	cp.w	r11,1
80007380:	e0 88 00 69 	brls	80007452 <get_fat+0xda>
80007384:	78 58       	ld.w	r8,r12[0x14]
80007386:	10 3b       	cp.w	r11,r8
80007388:	c6 52       	brcc	80007452 <get_fat+0xda>
		val = 1;	/* Internal error */

	} else {
		val = 0xFFFFFFFF;	/* Default value falls on disk error */

		switch (fs->fs_type) {
8000738a:	19 88       	ld.ub	r8,r12[0x0]
8000738c:	30 29       	mov	r9,2
8000738e:	f2 08 18 00 	cp.b	r8,r9
80007392:	c3 10       	breq	800073f4 <get_fat+0x7c>
80007394:	30 39       	mov	r9,3
80007396:	f2 08 18 00 	cp.b	r8,r9
8000739a:	c4 00       	breq	8000741a <get_fat+0xa2>
8000739c:	30 19       	mov	r9,1
8000739e:	f2 08 18 00 	cp.b	r8,r9
800073a2:	c5 81       	brne	80007452 <get_fat+0xda>
		case FS_FAT12 :
			bc = (UINT)clst; bc += bc / 2;
800073a4:	f6 05 16 01 	lsr	r5,r11,0x1
800073a8:	16 05       	add	r5,r11
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
800073aa:	ea 0b 16 09 	lsr	r11,r5,0x9
800073ae:	78 88       	ld.w	r8,r12[0x20]
800073b0:	10 0b       	add	r11,r8
800073b2:	f0 1f 00 2a 	mcall	80007458 <get_fat+0xe0>
800073b6:	c4 f1       	brne	80007454 <get_fat+0xdc>
			wc = fs->win[bc++ % SS(fs)];
800073b8:	f1 d5 c0 09 	bfextu	r8,r5,0x0,0x9
800073bc:	ee 08 00 08 	add	r8,r7,r8
800073c0:	f1 34 00 30 	ld.ub	r4,r8[48]
800073c4:	2f f5       	sub	r5,-1
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
800073c6:	ea 0b 16 09 	lsr	r11,r5,0x9
800073ca:	6e 88       	ld.w	r8,r7[0x20]
800073cc:	10 0b       	add	r11,r8
800073ce:	0e 9c       	mov	r12,r7
800073d0:	f0 1f 00 22 	mcall	80007458 <get_fat+0xe0>
800073d4:	c4 01       	brne	80007454 <get_fat+0xdc>
			wc |= fs->win[bc % SS(fs)] << 8;
800073d6:	eb d5 c0 09 	bfextu	r5,r5,0x0,0x9
800073da:	0a 07       	add	r7,r5
800073dc:	ef 3c 00 30 	ld.ub	r12,r7[48]
800073e0:	e9 ec 10 8c 	or	r12,r4,r12<<0x8
			val = clst & 1 ? wc >> 4 : (wc & 0xFFF);
800073e4:	ed d6 c0 01 	bfextu	r6,r6,0x0,0x1
800073e8:	c0 30       	breq	800073ee <get_fat+0x76>
800073ea:	a5 8c       	lsr	r12,0x4
800073ec:	d8 22       	popm	r4-r7,pc
800073ee:	f9 dc c0 0c 	bfextu	r12,r12,0x0,0xc
800073f2:	d8 22       	popm	r4-r7,pc
			break;

		case FS_FAT16 :
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))) != FR_OK) break;
800073f4:	a9 8b       	lsr	r11,0x8
800073f6:	78 88       	ld.w	r8,r12[0x20]
800073f8:	10 0b       	add	r11,r8
800073fa:	f0 1f 00 18 	mcall	80007458 <get_fat+0xe0>
800073fe:	c2 b1       	brne	80007454 <get_fat+0xdc>
			p = &fs->win[clst * 2 % SS(fs)];
80007400:	a1 76       	lsl	r6,0x1
80007402:	ed d6 c0 09 	bfextu	r6,r6,0x0,0x9
			val = LD_WORD(p);
80007406:	ee 06 00 08 	add	r8,r7,r6
8000740a:	10 97       	mov	r7,r8
8000740c:	f1 3c 00 31 	ld.ub	r12,r8[49]
80007410:	f1 38 00 30 	ld.ub	r8,r8[48]
80007414:	f1 ec 10 8c 	or	r12,r8,r12<<0x8
			break;
80007418:	d8 22       	popm	r4-r7,pc

		case FS_FAT32 :
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
8000741a:	a7 9b       	lsr	r11,0x7
8000741c:	78 88       	ld.w	r8,r12[0x20]
8000741e:	10 0b       	add	r11,r8
80007420:	f0 1f 00 0e 	mcall	80007458 <get_fat+0xe0>
80007424:	c1 81       	brne	80007454 <get_fat+0xdc>
			p = &fs->win[clst * 4 % SS(fs)];
80007426:	a3 66       	lsl	r6,0x2
80007428:	ed d6 c0 09 	bfextu	r6,r6,0x0,0x9
8000742c:	ec c8 ff d0 	sub	r8,r6,-48
80007430:	ee 08 00 08 	add	r8,r7,r8
			val = LD_DWORD(p) & 0x0FFFFFFF;
80007434:	11 a9       	ld.ub	r9,r8[0x2]
80007436:	11 bc       	ld.ub	r12,r8[0x3]
80007438:	b9 6c       	lsl	r12,0x18
8000743a:	f9 e9 11 0c 	or	r12,r12,r9<<0x10
8000743e:	11 98       	ld.ub	r8,r8[0x1]
80007440:	f9 e8 10 8c 	or	r12,r12,r8<<0x8
80007444:	0c 07       	add	r7,r6
80007446:	ef 38 00 30 	ld.ub	r8,r7[48]
8000744a:	10 4c       	or	r12,r8
8000744c:	f9 dc c0 1c 	bfextu	r12,r12,0x0,0x1c
			break;
80007450:	d8 22       	popm	r4-r7,pc
80007452:	da 2a       	popm	r4-r7,pc,r12=1
80007454:	dc 2a       	popm	r4-r7,pc,r12=-1
80007456:	00 00       	add	r0,r0
80007458:	80 00       	ld.sh	r0,r0[0x0]
8000745a:	6c 50       	ld.w	r0,r6[0x14]

8000745c <dir_sdi>:
static
FRESULT dir_sdi (	/* FR_OK(0):succeeded, !=0:error */
	DIR* dp,		/* Pointer to directory object */
	UINT idx		/* Index of directory table */
)
{
8000745c:	eb cd 40 f8 	pushm	r3-r7,lr
80007460:	18 96       	mov	r6,r12
80007462:	16 95       	mov	r5,r11
	DWORD clst, sect;
	UINT ic;


	dp->index = (WORD)idx;	/* Current index */
80007464:	ac 3b       	st.h	r6[0x6],r11
	clst = dp->sclust;		/* Table start cluster (0:root) */
80007466:	78 28       	ld.w	r8,r12[0x8]
	if (clst == 1 || clst >= dp->fs->n_fatent)	/* Check start cluster range */
80007468:	58 18       	cp.w	r8,1
8000746a:	c4 c0       	breq	80007502 <dir_sdi+0xa6>
8000746c:	78 09       	ld.w	r9,r12[0x0]
8000746e:	72 5a       	ld.w	r10,r9[0x14]
80007470:	14 38       	cp.w	r8,r10
80007472:	c4 82       	brcc	80007502 <dir_sdi+0xa6>
		return FR_INT_ERR;
	if (!clst && dp->fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
80007474:	58 08       	cp.w	r8,0
80007476:	c0 f1       	brne	80007494 <dir_sdi+0x38>
80007478:	13 8b       	ld.ub	r11,r9[0x0]
8000747a:	30 3a       	mov	r10,3
8000747c:	f4 0b 18 00 	cp.b	r11,r10
80007480:	c0 41       	brne	80007488 <dir_sdi+0x2c>
		clst = dp->fs->dirbase;
80007482:	72 97       	ld.w	r7,r9[0x24]

	if (clst == 0) {	/* Static table (root-directory in FAT12/16) */
80007484:	58 07       	cp.w	r7,0
80007486:	c0 81       	brne	80007496 <dir_sdi+0x3a>
		if (idx >= dp->fs->n_rootdir)	/* Is index out of range? */
80007488:	92 ca       	ld.uh	r10,r9[0x8]
8000748a:	14 35       	cp.w	r5,r10
8000748c:	c3 b2       	brcc	80007502 <dir_sdi+0xa6>
			return FR_INT_ERR;
		sect = dp->fs->dirbase;
8000748e:	72 9c       	ld.w	r12,r9[0x24]
80007490:	10 97       	mov	r7,r8
80007492:	c2 68       	rjmp	800074de <dir_sdi+0x82>
80007494:	10 97       	mov	r7,r8
	}
	else {				/* Dynamic table (root-directory in FAT32 or sub-directory) */
		ic = SS(dp->fs) / SZ_DIRE * dp->fs->csize;	/* Entries per cluster */
80007496:	13 a4       	ld.ub	r4,r9[0x2]
80007498:	a5 64       	lsl	r4,0x4
		while (idx >= ic) {	/* Follow cluster chain */
8000749a:	08 35       	cp.w	r5,r4
8000749c:	c1 d3       	brcs	800074d6 <dir_sdi+0x7a>
/*-----------------------------------------------------------------------*/
/* Directory handling - Set directory index                              */
/*-----------------------------------------------------------------------*/

static
FRESULT dir_sdi (	/* FR_OK(0):succeeded, !=0:error */
8000749e:	e8 03 11 00 	rsub	r3,r4,0
800074a2:	08 15       	sub	r5,r4
		sect = dp->fs->dirbase;
	}
	else {				/* Dynamic table (root-directory in FAT32 or sub-directory) */
		ic = SS(dp->fs) / SZ_DIRE * dp->fs->csize;	/* Entries per cluster */
		while (idx >= ic) {	/* Follow cluster chain */
			clst = get_fat(dp->fs, clst);				/* Get next cluster */
800074a4:	0e 9b       	mov	r11,r7
800074a6:	6c 0c       	ld.w	r12,r6[0x0]
800074a8:	f0 1f 00 18 	mcall	80007508 <dir_sdi+0xac>
800074ac:	18 97       	mov	r7,r12
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
800074ae:	5b fc       	cp.w	r12,-1
800074b0:	c0 31       	brne	800074b6 <dir_sdi+0x5a>
800074b2:	e3 cf 90 f8 	ldm	sp++,r3-r7,pc,r12=1
			if (clst < 2 || clst >= dp->fs->n_fatent)	/* Reached to end of table or internal error */
800074b6:	58 1c       	cp.w	r12,1
800074b8:	e0 88 00 25 	brls	80007502 <dir_sdi+0xa6>
800074bc:	6c 08       	ld.w	r8,r6[0x0]
800074be:	70 58       	ld.w	r8,r8[0x14]
800074c0:	10 3c       	cp.w	r12,r8
800074c2:	c2 02       	brcc	80007502 <dir_sdi+0xa6>
800074c4:	ea 03 00 08 	add	r8,r5,r3
			return FR_INT_ERR;
		sect = dp->fs->dirbase;
	}
	else {				/* Dynamic table (root-directory in FAT32 or sub-directory) */
		ic = SS(dp->fs) / SZ_DIRE * dp->fs->csize;	/* Entries per cluster */
		while (idx >= ic) {	/* Follow cluster chain */
800074c8:	f0 04 00 09 	add	r9,r8,r4
800074cc:	12 34       	cp.w	r4,r9
800074ce:	e0 8b 00 04 	brhi	800074d6 <dir_sdi+0x7a>
800074d2:	10 95       	mov	r5,r8
800074d4:	ce 8b       	rjmp	800074a4 <dir_sdi+0x48>
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
			if (clst < 2 || clst >= dp->fs->n_fatent)	/* Reached to end of table or internal error */
				return FR_INT_ERR;
			idx -= ic;
		}
		sect = clust2sect(dp->fs, clst);
800074d6:	0e 9b       	mov	r11,r7
800074d8:	6c 0c       	ld.w	r12,r6[0x0]
800074da:	f0 1f 00 0d 	mcall	8000750c <dir_sdi+0xb0>
	}
	dp->clust = clst;	/* Current cluster# */
800074de:	8d 37       	st.w	r6[0xc],r7
	if (!sect) return FR_INT_ERR;
800074e0:	58 0c       	cp.w	r12,0
800074e2:	c1 00       	breq	80007502 <dir_sdi+0xa6>
	dp->sect = sect + idx / (SS(dp->fs) / SZ_DIRE);					/* Sector# of the directory entry */
800074e4:	ea 08 16 04 	lsr	r8,r5,0x4
800074e8:	f0 0c 00 0c 	add	r12,r8,r12
800074ec:	8d 4c       	st.w	r6[0x10],r12
	dp->dir = dp->fs->win + (idx % (SS(dp->fs) / SZ_DIRE)) * SZ_DIRE;	/* Ptr to the entry in the sector */
800074ee:	6c 08       	ld.w	r8,r6[0x0]
800074f0:	2d 08       	sub	r8,-48
800074f2:	eb d5 c0 04 	bfextu	r5,r5,0x0,0x4
800074f6:	a5 75       	lsl	r5,0x5
800074f8:	f0 05 00 05 	add	r5,r8,r5
800074fc:	8d 55       	st.w	r6[0x14],r5
800074fe:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0

	return FR_OK;
80007502:	30 2c       	mov	r12,2
}
80007504:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80007508:	80 00       	ld.sh	r0,r0[0x0]
8000750a:	73 78       	ld.w	r8,r9[0x5c]
8000750c:	80 00       	ld.sh	r0,r0[0x0]
8000750e:	63 04       	ld.w	r4,r1[0x40]

80007510 <create_chain>:
static
DWORD create_chain (	/* 0:No free cluster, 1:Internal error, 0xFFFFFFFF:Disk error, >=2:New cluster# */
	FATFS* fs,			/* File system object */
	DWORD clst			/* Cluster# to stretch, 0:Create a new chain */
)
{
80007510:	eb cd 40 fc 	pushm	r2-r7,lr
80007514:	18 96       	mov	r6,r12
80007516:	16 92       	mov	r2,r11
	DWORD cs, ncl, scl;
	FRESULT res;


	if (clst == 0) {		/* Create a new chain */
80007518:	58 0b       	cp.w	r11,0
8000751a:	c0 81       	brne	8000752a <create_chain+0x1a>
		scl = fs->last_clust;			/* Get suggested start point */
8000751c:	78 35       	ld.w	r5,r12[0xc]
		if (!scl || scl >= fs->n_fatent) scl = 1;
8000751e:	58 05       	cp.w	r5,0
80007520:	c1 10       	breq	80007542 <create_chain+0x32>
80007522:	78 58       	ld.w	r8,r12[0x14]
80007524:	10 35       	cp.w	r5,r8
80007526:	c0 e2       	brcc	80007542 <create_chain+0x32>
80007528:	c0 e8       	rjmp	80007544 <create_chain+0x34>
	}
	else {					/* Stretch the current chain */
		cs = get_fat(fs, clst);			/* Check the cluster status */
8000752a:	f0 1f 00 2c 	mcall	800075d8 <create_chain+0xc8>
		if (cs < 2) return 1;			/* Invalid value */
8000752e:	58 1c       	cp.w	r12,1
80007530:	e0 88 00 4f 	brls	800075ce <create_chain+0xbe>
		if (cs == 0xFFFFFFFF) return cs;	/* A disk error occurred */
80007534:	5b fc       	cp.w	r12,-1
80007536:	c4 f0       	breq	800075d4 <create_chain+0xc4>
		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
80007538:	6c 58       	ld.w	r8,r6[0x14]
8000753a:	10 3c       	cp.w	r12,r8
8000753c:	c4 c3       	brcs	800075d4 <create_chain+0xc4>
8000753e:	04 95       	mov	r5,r2
80007540:	c0 28       	rjmp	80007544 <create_chain+0x34>
80007542:	30 15       	mov	r5,1
80007544:	0a 97       	mov	r7,r5
	ncl = scl;				/* Start cluster */
	for (;;) {
		ncl++;							/* Next cluster */
		if (ncl >= fs->n_fatent) {		/* Check wrap around */
			ncl = 2;
			if (ncl > scl) return 0;	/* No free cluster */
80007546:	30 23       	mov	r3,2
		}
		cs = get_fat(fs, ncl);			/* Get the cluster status */
		if (cs == 0) break;				/* Found a free cluster */
		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
80007548:	30 04       	mov	r4,0
		scl = clst;
	}

	ncl = scl;				/* Start cluster */
	for (;;) {
		ncl++;							/* Next cluster */
8000754a:	2f f7       	sub	r7,-1
		if (ncl >= fs->n_fatent) {		/* Check wrap around */
8000754c:	6c 58       	ld.w	r8,r6[0x14]
8000754e:	10 37       	cp.w	r7,r8
80007550:	c0 53       	brcs	8000755a <create_chain+0x4a>
			ncl = 2;
			if (ncl > scl) return 0;	/* No free cluster */
80007552:	58 15       	cp.w	r5,1
80007554:	e0 88 00 3f 	brls	800075d2 <create_chain+0xc2>
80007558:	06 97       	mov	r7,r3
		}
		cs = get_fat(fs, ncl);			/* Get the cluster status */
8000755a:	0e 9b       	mov	r11,r7
8000755c:	0c 9c       	mov	r12,r6
8000755e:	f0 1f 00 1f 	mcall	800075d8 <create_chain+0xc8>
		if (cs == 0) break;				/* Found a free cluster */
80007562:	c0 d0       	breq	8000757c <create_chain+0x6c>
		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
80007564:	5b fc       	cp.w	r12,-1
80007566:	5f 09       	sreq	r9
80007568:	58 1c       	cp.w	r12,1
8000756a:	5f 08       	sreq	r8
8000756c:	f3 e8 10 08 	or	r8,r9,r8
80007570:	e8 08 18 00 	cp.b	r8,r4
80007574:	c3 01       	brne	800075d4 <create_chain+0xc4>
			return cs;
		if (ncl == scl) return 0;		/* No free cluster */
80007576:	0a 37       	cp.w	r7,r5
80007578:	ce 91       	brne	8000754a <create_chain+0x3a>
8000757a:	c2 c8       	rjmp	800075d2 <create_chain+0xc2>
8000757c:	0e 95       	mov	r5,r7
	}

	res = put_fat(fs, ncl, 0x0FFFFFFF);	/* Mark the new cluster "last link" */
8000757e:	e0 6a ff ff 	mov	r10,65535
80007582:	ea 1a 0f ff 	orh	r10,0xfff
80007586:	0e 9b       	mov	r11,r7
80007588:	0c 9c       	mov	r12,r6
8000758a:	f0 1f 00 15 	mcall	800075dc <create_chain+0xcc>
	if (res == FR_OK && clst != 0) {
8000758e:	5f 09       	sreq	r9
80007590:	58 02       	cp.w	r2,0
80007592:	5f 18       	srne	r8
80007594:	f3 e8 00 08 	and	r8,r9,r8
80007598:	c0 60       	breq	800075a4 <create_chain+0x94>
		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
8000759a:	0e 9a       	mov	r10,r7
8000759c:	04 9b       	mov	r11,r2
8000759e:	0c 9c       	mov	r12,r6
800075a0:	f0 1f 00 0f 	mcall	800075dc <create_chain+0xcc>
	}
	if (res == FR_OK) {
800075a4:	58 0c       	cp.w	r12,0
800075a6:	c1 01       	brne	800075c6 <create_chain+0xb6>
		fs->last_clust = ncl;			/* Update FSINFO */
800075a8:	8d 35       	st.w	r6[0xc],r5
		if (fs->free_clust != 0xFFFFFFFF) {
800075aa:	6c 48       	ld.w	r8,r6[0x10]
800075ac:	5b f8       	cp.w	r8,-1
800075ae:	c0 41       	brne	800075b6 <create_chain+0xa6>
800075b0:	0e 9c       	mov	r12,r7
800075b2:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
			fs->free_clust--;
800075b6:	20 18       	sub	r8,1
800075b8:	8d 48       	st.w	r6[0x10],r8
			fs->fsi_flag |= 1;
800075ba:	0d d8       	ld.ub	r8,r6[0x5]
800075bc:	a1 a8       	sbr	r8,0x0
800075be:	ac d8       	st.b	r6[0x5],r8
800075c0:	0e 9c       	mov	r12,r7
800075c2:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
		}
	} else {
		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
800075c6:	58 1c       	cp.w	r12,1
800075c8:	c0 31       	brne	800075ce <create_chain+0xbe>
800075ca:	e3 cf c0 fc 	ldm	sp++,r2-r7,pc,r12=-1
800075ce:	e3 cf 90 fc 	ldm	sp++,r2-r7,pc,r12=1
800075d2:	30 0c       	mov	r12,0
	}

	return ncl;		/* Return new cluster number or error code */
}
800075d4:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800075d8:	80 00       	ld.sh	r0,r0[0x0]
800075da:	73 78       	ld.w	r8,r9[0x5c]
800075dc:	80 00       	ld.sh	r0,r0[0x0]
800075de:	72 44       	ld.w	r4,r9[0x10]

800075e0 <dir_next>:
static
FRESULT dir_next (	/* FR_OK(0):succeeded, FR_NO_FILE:End of table, FR_DENIED:Could not stretch */
	DIR* dp,		/* Pointer to the directory object */
	int stretch		/* 0: Do not stretch table, 1: Stretch table if needed */
)
{
800075e0:	eb cd 40 fc 	pushm	r2-r7,lr
800075e4:	18 97       	mov	r7,r12
800075e6:	16 96       	mov	r6,r11
#if !_FS_READONLY
	UINT c;
#endif


	i = dp->index + 1;
800075e8:	98 b5       	ld.uh	r5,r12[0x6]
800075ea:	2f f5       	sub	r5,-1
	if (!(i & 0xFFFF) || !dp->sect)	/* Report EOT when index has reached 65535 */
800075ec:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
800075f0:	c6 d0       	breq	800076ca <dir_next+0xea>
800075f2:	78 48       	ld.w	r8,r12[0x10]
800075f4:	58 08       	cp.w	r8,0
800075f6:	c6 a0       	breq	800076ca <dir_next+0xea>
		return FR_NO_FILE;

	if (!(i % (SS(dp->fs) / SZ_DIRE))) {	/* Sector changed? */
800075f8:	e9 d5 c0 04 	bfextu	r4,r5,0x0,0x4
800075fc:	c5 e1       	brne	800076b8 <dir_next+0xd8>
		dp->sect++;					/* Next sector */
800075fe:	2f f8       	sub	r8,-1
80007600:	99 48       	st.w	r12[0x10],r8

		if (!dp->clust) {		/* Static table */
80007602:	78 3b       	ld.w	r11,r12[0xc]
80007604:	58 0b       	cp.w	r11,0
80007606:	c0 61       	brne	80007612 <dir_next+0x32>
			if (i >= dp->fs->n_rootdir)	/* Report EOT if it reached end of static table */
80007608:	78 08       	ld.w	r8,r12[0x0]
8000760a:	90 c8       	ld.uh	r8,r8[0x8]
8000760c:	10 35       	cp.w	r5,r8
8000760e:	c5 53       	brcs	800076b8 <dir_next+0xd8>
80007610:	c5 d8       	rjmp	800076ca <dir_next+0xea>
				return FR_NO_FILE;
		}
		else {					/* Dynamic table */
			if (((i / (SS(dp->fs) / SZ_DIRE)) & (dp->fs->csize - 1)) == 0) {	/* Cluster changed? */
80007612:	78 0c       	ld.w	r12,r12[0x0]
80007614:	19 a8       	ld.ub	r8,r12[0x2]
80007616:	20 18       	sub	r8,1
80007618:	f1 e5 02 48 	and	r8,r8,r5>>0x4
8000761c:	c4 e1       	brne	800076b8 <dir_next+0xd8>
				clst = get_fat(dp->fs, dp->clust);				/* Get next cluster */
8000761e:	f0 1f 00 30 	mcall	800076dc <dir_next+0xfc>
80007622:	18 93       	mov	r3,r12
				if (clst <= 1) return FR_INT_ERR;
80007624:	58 1c       	cp.w	r12,1
80007626:	e0 88 00 55 	brls	800076d0 <dir_next+0xf0>
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
8000762a:	5b fc       	cp.w	r12,-1
8000762c:	c5 50       	breq	800076d6 <dir_next+0xf6>
				if (clst >= dp->fs->n_fatent) {					/* If it reached end of dynamic table, */
8000762e:	6e 0c       	ld.w	r12,r7[0x0]
80007630:	78 58       	ld.w	r8,r12[0x14]
80007632:	10 33       	cp.w	r3,r8
80007634:	c3 c3       	brcs	800076ac <dir_next+0xcc>
#if !_FS_READONLY
					if (!stretch) return FR_NO_FILE;			/* If do not stretch, report EOT */
80007636:	58 06       	cp.w	r6,0
80007638:	c4 90       	breq	800076ca <dir_next+0xea>
					clst = create_chain(dp->fs, dp->clust);		/* Stretch cluster chain */
8000763a:	6e 3b       	ld.w	r11,r7[0xc]
8000763c:	f0 1f 00 29 	mcall	800076e0 <dir_next+0x100>
80007640:	18 93       	mov	r3,r12
					if (clst == 0) return FR_DENIED;			/* No free cluster */
80007642:	c0 41       	brne	8000764a <dir_next+0x6a>
80007644:	30 7c       	mov	r12,7
80007646:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
					if (clst == 1) return FR_INT_ERR;
8000764a:	58 1c       	cp.w	r12,1
8000764c:	c4 20       	breq	800076d0 <dir_next+0xf0>
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
8000764e:	5b fc       	cp.w	r12,-1
80007650:	c4 30       	breq	800076d6 <dir_next+0xf6>
					/* Clean-up stretched table */
					if (sync_window(dp->fs)) return FR_DISK_ERR;/* Flush disk access window */
80007652:	6e 0c       	ld.w	r12,r7[0x0]
80007654:	f0 1f 00 24 	mcall	800076e4 <dir_next+0x104>
80007658:	c3 f1       	brne	800076d6 <dir_next+0xf6>
					mem_set(dp->fs->win, 0, SS(dp->fs));		/* Clear window buffer */
8000765a:	6e 0c       	ld.w	r12,r7[0x0]
8000765c:	e0 6a 02 00 	mov	r10,512
80007660:	30 0b       	mov	r11,0
80007662:	2d 0c       	sub	r12,-48
80007664:	f0 1f 00 21 	mcall	800076e8 <dir_next+0x108>
					dp->fs->winsect = clust2sect(dp->fs, clst);	/* Cluster start sector */
80007668:	6e 06       	ld.w	r6,r7[0x0]
8000766a:	06 9b       	mov	r11,r3
8000766c:	0c 9c       	mov	r12,r6
8000766e:	f0 1f 00 20 	mcall	800076ec <dir_next+0x10c>
80007672:	8d bc       	st.w	r6[0x2c],r12
					for (c = 0; c < dp->fs->csize; c++) {		/* Fill the new cluster with 0 */
80007674:	6e 08       	ld.w	r8,r7[0x0]
80007676:	11 aa       	ld.ub	r10,r8[0x2]
80007678:	30 09       	mov	r9,0
8000767a:	f2 0a 18 00 	cp.b	r10,r9
8000767e:	c0 31       	brne	80007684 <dir_next+0xa4>
80007680:	30 06       	mov	r6,0
80007682:	c1 28       	rjmp	800076a6 <dir_next+0xc6>
80007684:	30 06       	mov	r6,0
						dp->fs->wflag = 1;
80007686:	30 12       	mov	r2,1
80007688:	b0 c2       	st.b	r8[0x4],r2
						if (sync_window(dp->fs)) return FR_DISK_ERR;
8000768a:	6e 0c       	ld.w	r12,r7[0x0]
8000768c:	f0 1f 00 16 	mcall	800076e4 <dir_next+0x104>
80007690:	c2 31       	brne	800076d6 <dir_next+0xf6>
						dp->fs->winsect++;
80007692:	6e 08       	ld.w	r8,r7[0x0]
80007694:	70 b9       	ld.w	r9,r8[0x2c]
80007696:	2f f9       	sub	r9,-1
80007698:	91 b9       	st.w	r8[0x2c],r9
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
					/* Clean-up stretched table */
					if (sync_window(dp->fs)) return FR_DISK_ERR;/* Flush disk access window */
					mem_set(dp->fs->win, 0, SS(dp->fs));		/* Clear window buffer */
					dp->fs->winsect = clust2sect(dp->fs, clst);	/* Cluster start sector */
					for (c = 0; c < dp->fs->csize; c++) {		/* Fill the new cluster with 0 */
8000769a:	2f f6       	sub	r6,-1
8000769c:	6e 08       	ld.w	r8,r7[0x0]
8000769e:	11 a9       	ld.ub	r9,r8[0x2]
800076a0:	0c 39       	cp.w	r9,r6
800076a2:	fe 9b ff f3 	brhi	80007688 <dir_next+0xa8>
						dp->fs->wflag = 1;
						if (sync_window(dp->fs)) return FR_DISK_ERR;
						dp->fs->winsect++;
					}
					dp->fs->winsect -= c;						/* Rewind window offset */
800076a6:	70 b9       	ld.w	r9,r8[0x2c]
800076a8:	0c 19       	sub	r9,r6
800076aa:	91 b9       	st.w	r8[0x2c],r9
#else
					if (!stretch) return FR_NO_FILE;			/* If do not stretch, report EOT (this is to suppress warning) */
					return FR_NO_FILE;							/* Report EOT */
#endif
				}
				dp->clust = clst;				/* Initialize data for new cluster */
800076ac:	8f 33       	st.w	r7[0xc],r3
				dp->sect = clust2sect(dp->fs, clst);
800076ae:	06 9b       	mov	r11,r3
800076b0:	6e 0c       	ld.w	r12,r7[0x0]
800076b2:	f0 1f 00 0f 	mcall	800076ec <dir_next+0x10c>
800076b6:	8f 4c       	st.w	r7[0x10],r12
			}
		}
	}

	dp->index = (WORD)i;	/* Current index */
800076b8:	ae 35       	st.h	r7[0x6],r5
	dp->dir = dp->fs->win + (i % (SS(dp->fs) / SZ_DIRE)) * SZ_DIRE;	/* Current entry in the window */
800076ba:	6e 08       	ld.w	r8,r7[0x0]
800076bc:	2d 08       	sub	r8,-48
800076be:	a5 74       	lsl	r4,0x5
800076c0:	f0 04 00 04 	add	r4,r8,r4
800076c4:	8f 54       	st.w	r7[0x14],r4
800076c6:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0

	return FR_OK;
800076ca:	30 4c       	mov	r12,4
800076cc:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800076d0:	30 2c       	mov	r12,2
800076d2:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800076d6:	e3 cf 90 fc 	ldm	sp++,r2-r7,pc,r12=1
800076da:	00 00       	add	r0,r0
800076dc:	80 00       	ld.sh	r0,r0[0x0]
800076de:	73 78       	ld.w	r8,r9[0x5c]
800076e0:	80 00       	ld.sh	r0,r0[0x0]
800076e2:	75 10       	ld.w	r0,r10[0x44]
800076e4:	80 00       	ld.sh	r0,r0[0x0]
800076e6:	64 58       	ld.w	r8,r2[0x14]
800076e8:	80 00       	ld.sh	r0,r0[0x0]
800076ea:	62 de       	ld.w	lr,r1[0x34]
800076ec:	80 00       	ld.sh	r0,r0[0x0]
800076ee:	63 04       	ld.w	r4,r1[0x40]

800076f0 <remove_chain>:
static
FRESULT remove_chain (	/* FR_OK(0):succeeded, !=0:error */
	FATFS* fs,			/* File system object */
	DWORD clst			/* Cluster# to remove a chain from */
)
{
800076f0:	d4 21       	pushm	r4-r7,lr
800076f2:	18 97       	mov	r7,r12
800076f4:	16 95       	mov	r5,r11
	DWORD nxt;
#if _USE_TRIM
	DWORD scl = clst, ecl = clst, rt[2];
#endif

	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
800076f6:	58 1b       	cp.w	r11,1
800076f8:	e0 88 00 26 	brls	80007744 <remove_chain+0x54>
800076fc:	78 58       	ld.w	r8,r12[0x14]
800076fe:	10 3b       	cp.w	r11,r8
80007700:	c2 22       	brcc	80007744 <remove_chain+0x54>
		while (clst < fs->n_fatent) {			/* Not a last link? */
			nxt = get_fat(fs, clst);			/* Get cluster status */
			if (nxt == 0) break;				/* Empty cluster? */
			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
80007702:	30 04       	mov	r4,0
		res = FR_INT_ERR;

	} else {
		res = FR_OK;
		while (clst < fs->n_fatent) {			/* Not a last link? */
			nxt = get_fat(fs, clst);			/* Get cluster status */
80007704:	0a 9b       	mov	r11,r5
80007706:	0e 9c       	mov	r12,r7
80007708:	f0 1f 00 10 	mcall	80007748 <remove_chain+0x58>
8000770c:	18 96       	mov	r6,r12
			if (nxt == 0) break;				/* Empty cluster? */
8000770e:	c0 21       	brne	80007712 <remove_chain+0x22>
80007710:	d8 2a       	popm	r4-r7,pc,r12=0
			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
80007712:	58 1c       	cp.w	r12,1
80007714:	c1 80       	breq	80007744 <remove_chain+0x54>
			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
80007716:	5b fc       	cp.w	r12,-1
80007718:	c0 21       	brne	8000771c <remove_chain+0x2c>
8000771a:	da 2a       	popm	r4-r7,pc,r12=1
			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
8000771c:	08 9a       	mov	r10,r4
8000771e:	0a 9b       	mov	r11,r5
80007720:	0e 9c       	mov	r12,r7
80007722:	f0 1f 00 0b 	mcall	8000774c <remove_chain+0x5c>
			if (res != FR_OK) break;
80007726:	c1 01       	brne	80007746 <remove_chain+0x56>
			if (fs->free_clust != 0xFFFFFFFF) {	/* Update FSINFO */
80007728:	6e 48       	ld.w	r8,r7[0x10]
8000772a:	5b f8       	cp.w	r8,-1
8000772c:	c0 60       	breq	80007738 <remove_chain+0x48>
				fs->free_clust++;
8000772e:	2f f8       	sub	r8,-1
80007730:	8f 48       	st.w	r7[0x10],r8
				fs->fsi_flag |= 1;
80007732:	0f d8       	ld.ub	r8,r7[0x5]
80007734:	a1 a8       	sbr	r8,0x0
80007736:	ae d8       	st.b	r7[0x5],r8
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
		res = FR_INT_ERR;

	} else {
		res = FR_OK;
		while (clst < fs->n_fatent) {			/* Not a last link? */
80007738:	6e 58       	ld.w	r8,r7[0x14]
8000773a:	0c 38       	cp.w	r8,r6
8000773c:	e0 88 00 05 	brls	80007746 <remove_chain+0x56>
80007740:	0c 95       	mov	r5,r6
80007742:	ce 1b       	rjmp	80007704 <remove_chain+0x14>
80007744:	30 2c       	mov	r12,2
			clst = nxt;	/* Next cluster */
		}
	}

	return res;
}
80007746:	d8 22       	popm	r4-r7,pc
80007748:	80 00       	ld.sh	r0,r0[0x0]
8000774a:	73 78       	ld.w	r8,r9[0x5c]
8000774c:	80 00       	ld.sh	r0,r0[0x0]
8000774e:	72 44       	ld.w	r4,r9[0x10]

80007750 <dir_read>:
static
FRESULT dir_read (
	DIR* dp,		/* Pointer to the directory object */
	int vol			/* Filtered by 0:file/directory or 1:volume label */
)
{
80007750:	eb cd 40 fe 	pushm	r1-r7,lr
80007754:	18 97       	mov	r7,r12
80007756:	16 91       	mov	r1,r11
80007758:	30 4c       	mov	r12,4
					dp->lfn_idx = 0xFFFF;		/* It has no LFN. */
				break;
			}
		}
#else		/* Non LFN configuration */
		if (c != DDEM && (_FS_RPATH || c != '.') && a != AM_LFN && (int)((a & ~AM_ARC) == AM_VOL) == vol)	/* Is it a valid entry? */
8000775a:	3e 56       	mov	r6,-27
8000775c:	32 e5       	mov	r5,46
8000775e:	30 04       	mov	r4,0
80007760:	30 f2       	mov	r2,15
			break;
#endif
		res = dir_next(dp, 0);				/* Next entry */
80007762:	30 03       	mov	r3,0
#if _USE_LFN
	BYTE ord = 0xFF, sum = 0xFF;
#endif

	res = FR_NO_FILE;
	while (dp->sect) {
80007764:	c2 58       	rjmp	800077ae <dir_read+0x5e>
		res = move_window(dp->fs, dp->sect);
80007766:	6e 0c       	ld.w	r12,r7[0x0]
80007768:	f0 1f 00 17 	mcall	800077c4 <dir_read+0x74>
		if (res != FR_OK) break;
8000776c:	c2 61       	brne	800077b8 <dir_read+0x68>
		dir = dp->dir;					/* Ptr to the directory entry of current index */
8000776e:	6e 59       	ld.w	r9,r7[0x14]
		c = dir[DIR_Name];
80007770:	13 88       	ld.ub	r8,r9[0x0]
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
80007772:	58 08       	cp.w	r8,0
80007774:	c2 60       	breq	800077c0 <dir_read+0x70>
		a = dir[DIR_Attr] & AM_MASK;
80007776:	f3 3a 00 0b 	ld.ub	r10,r9[11]
					dp->lfn_idx = 0xFFFF;		/* It has no LFN. */
				break;
			}
		}
#else		/* Non LFN configuration */
		if (c != DDEM && (_FS_RPATH || c != '.') && a != AM_LFN && (int)((a & ~AM_ARC) == AM_VOL) == vol)	/* Is it a valid entry? */
8000777a:	ec 08 18 00 	cp.b	r8,r6
8000777e:	5f 19       	srne	r9
80007780:	ea 08 18 00 	cp.b	r8,r5
80007784:	5f 18       	srne	r8
80007786:	f3 e8 00 08 	and	r8,r9,r8
8000778a:	e8 08 18 00 	cp.b	r8,r4
8000778e:	c0 b0       	breq	800077a4 <dir_read+0x54>
		res = move_window(dp->fs, dp->sect);
		if (res != FR_OK) break;
		dir = dp->dir;					/* Ptr to the directory entry of current index */
		c = dir[DIR_Name];
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
		a = dir[DIR_Attr] & AM_MASK;
80007790:	f1 da c0 06 	bfextu	r8,r10,0x0,0x6
					dp->lfn_idx = 0xFFFF;		/* It has no LFN. */
				break;
			}
		}
#else		/* Non LFN configuration */
		if (c != DDEM && (_FS_RPATH || c != '.') && a != AM_LFN && (int)((a & ~AM_ARC) == AM_VOL) == vol)	/* Is it a valid entry? */
80007794:	e4 08 18 00 	cp.b	r8,r2
80007798:	c0 60       	breq	800077a4 <dir_read+0x54>
8000779a:	a5 d8       	cbr	r8,0x5
8000779c:	58 88       	cp.w	r8,8
8000779e:	5f 08       	sreq	r8
800077a0:	02 38       	cp.w	r8,r1
800077a2:	c0 d0       	breq	800077bc <dir_read+0x6c>
			break;
#endif
		res = dir_next(dp, 0);				/* Next entry */
800077a4:	06 9b       	mov	r11,r3
800077a6:	0e 9c       	mov	r12,r7
800077a8:	f0 1f 00 08 	mcall	800077c8 <dir_read+0x78>
		if (res != FR_OK) break;
800077ac:	c0 61       	brne	800077b8 <dir_read+0x68>
#if _USE_LFN
	BYTE ord = 0xFF, sum = 0xFF;
#endif

	res = FR_NO_FILE;
	while (dp->sect) {
800077ae:	6e 4b       	ld.w	r11,r7[0x10]
800077b0:	58 0b       	cp.w	r11,0
800077b2:	cd a1       	brne	80007766 <dir_read+0x16>
#endif
		res = dir_next(dp, 0);				/* Next entry */
		if (res != FR_OK) break;
	}

	if (res != FR_OK) dp->sect = 0;
800077b4:	58 0c       	cp.w	r12,0
800077b6:	c0 30       	breq	800077bc <dir_read+0x6c>
800077b8:	30 08       	mov	r8,0
800077ba:	8f 48       	st.w	r7[0x10],r8

	return res;
}
800077bc:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
#endif
		res = dir_next(dp, 0);				/* Next entry */
		if (res != FR_OK) break;
	}

	if (res != FR_OK) dp->sect = 0;
800077c0:	30 4c       	mov	r12,4
800077c2:	cf bb       	rjmp	800077b8 <dir_read+0x68>
800077c4:	80 00       	ld.sh	r0,r0[0x0]
800077c6:	6c 50       	ld.w	r0,r6[0x14]
800077c8:	80 00       	ld.sh	r0,r0[0x0]
800077ca:	75 e0       	ld.w	r0,r10[0x78]

800077cc <f_getlabel>:
FRESULT f_getlabel (
	const TCHAR* path,	/* Path name of the logical drive number */
	TCHAR* label,		/* Pointer to a buffer to return the volume label */
	DWORD* vsn			/* Pointer to a variable to return the volume serial number */
)
{
800077cc:	d4 21       	pushm	r4-r7,lr
800077ce:	20 9d       	sub	sp,36
800077d0:	50 0c       	stdsp	sp[0x0],r12
800077d2:	16 96       	mov	r6,r11
800077d4:	14 95       	mov	r5,r10
	WCHAR w;
#endif


	/* Get logical drive number */
	res = find_volume(&dj.fs, &path, 0);
800077d6:	30 0a       	mov	r10,0
800077d8:	1a 9b       	mov	r11,sp
800077da:	fa cc ff fc 	sub	r12,sp,-4
800077de:	f0 1f 00 30 	mcall	8000789c <f_getlabel+0xd0>
800077e2:	18 97       	mov	r7,r12

	/* Get volume label */
	if (res == FR_OK && label) {
800077e4:	5f 09       	sreq	r9
800077e6:	58 06       	cp.w	r6,0
800077e8:	5f 18       	srne	r8
800077ea:	f3 e8 00 08 	and	r8,r9,r8
800077ee:	c2 d0       	breq	80007848 <f_getlabel+0x7c>
		dj.sclust = 0;					/* Open root directory */
800077f0:	30 0b       	mov	r11,0
800077f2:	50 3b       	stdsp	sp[0xc],r11
		res = dir_sdi(&dj, 0);
800077f4:	fa cc ff fc 	sub	r12,sp,-4
800077f8:	f0 1f 00 2a 	mcall	800078a0 <f_getlabel+0xd4>
800077fc:	18 97       	mov	r7,r12
		if (res == FR_OK) {
800077fe:	c4 c1       	brne	80007896 <f_getlabel+0xca>
			res = dir_read(&dj, 1);		/* Get an entry with AM_VOL */
80007800:	30 1b       	mov	r11,1
80007802:	fa cc ff fc 	sub	r12,sp,-4
80007806:	f0 1f 00 28 	mcall	800078a4 <f_getlabel+0xd8>
8000780a:	18 94       	mov	r4,r12
			if (res == FR_OK) {			/* A volume label is exist */
8000780c:	c1 81       	brne	8000783c <f_getlabel+0x70>
					if (IsDBCS1(w) && i < 11 && IsDBCS2(dj.dir[i]))
						w = w << 8 | dj.dir[i++];
					label[j++] = ff_convert(w, 1);	/* OEM -> Unicode */
				} while (j < 11);
#else
				mem_cpy(label, dj.dir, 11);
8000780e:	30 ba       	mov	r10,11
80007810:	40 6b       	lddsp	r11,sp[0x18]
80007812:	0c 9c       	mov	r12,r6
80007814:	f0 1f 00 25 	mcall	800078a8 <f_getlabel+0xdc>
#endif
				j = 11;
				do {
					label[j] = 0;
80007818:	30 08       	mov	r8,0
8000781a:	ed 68 00 0b 	st.b	r6[11],r8
8000781e:	2f 66       	sub	r6,-10
80007820:	30 b8       	mov	r8,11
					if (!j) break;
				} while (label[--j] == ' ');
80007822:	32 0a       	mov	r10,32
#else
				mem_cpy(label, dj.dir, 11);
#endif
				j = 11;
				do {
					label[j] = 0;
80007824:	30 0b       	mov	r11,0
80007826:	c0 58       	rjmp	80007830 <f_getlabel+0x64>
80007828:	ac 8b       	st.b	r6[0x0],r11
8000782a:	20 16       	sub	r6,1
					if (!j) break;
8000782c:	58 08       	cp.w	r8,0
8000782e:	c0 c0       	breq	80007846 <f_getlabel+0x7a>
				} while (label[--j] == ' ');
80007830:	20 18       	sub	r8,1
80007832:	0d 89       	ld.ub	r9,r6[0x0]
80007834:	f4 09 18 00 	cp.b	r9,r10
80007838:	cf 80       	breq	80007828 <f_getlabel+0x5c>
8000783a:	c0 68       	rjmp	80007846 <f_getlabel+0x7a>
			}
			if (res == FR_NO_FILE) {	/* No label, return nul string */
8000783c:	58 4c       	cp.w	r12,4
8000783e:	c0 41       	brne	80007846 <f_getlabel+0x7a>
				label[0] = 0;
80007840:	30 08       	mov	r8,0
80007842:	ac 88       	st.b	r6[0x0],r8
80007844:	c0 28       	rjmp	80007848 <f_getlabel+0x7c>
80007846:	08 97       	mov	r7,r4
			}
		}
	}

	/* Get volume serial number */
	if (res == FR_OK && vsn) {
80007848:	58 07       	cp.w	r7,0
8000784a:	5f 09       	sreq	r9
8000784c:	58 05       	cp.w	r5,0
8000784e:	5f 18       	srne	r8
80007850:	f3 e8 00 08 	and	r8,r9,r8
80007854:	c2 10       	breq	80007896 <f_getlabel+0xca>
		res = move_window(dj.fs, dj.fs->volbase);
80007856:	40 1c       	lddsp	r12,sp[0x4]
80007858:	78 7b       	ld.w	r11,r12[0x1c]
8000785a:	f0 1f 00 15 	mcall	800078ac <f_getlabel+0xe0>
8000785e:	18 97       	mov	r7,r12
		if (res == FR_OK) {
80007860:	c1 b1       	brne	80007896 <f_getlabel+0xca>
			i = dj.fs->fs_type == FS_FAT32 ? BS_VolID32 : BS_VolID;
80007862:	40 19       	lddsp	r9,sp[0x4]
80007864:	13 8a       	ld.ub	r10,r9[0x0]
80007866:	30 38       	mov	r8,3
80007868:	f0 0a 18 00 	cp.b	r10,r8
8000786c:	f9 b8 00 43 	moveq	r8,67
80007870:	f9 b8 01 27 	movne	r8,39
			*vsn = LD_DWORD(&dj.fs->win[i]);
80007874:	f2 08 00 08 	add	r8,r9,r8
80007878:	f1 3a 00 33 	ld.ub	r10,r8[51]
8000787c:	f1 39 00 32 	ld.ub	r9,r8[50]
80007880:	b1 69       	lsl	r9,0x10
80007882:	f3 ea 11 89 	or	r9,r9,r10<<0x18
80007886:	f1 3a 00 30 	ld.ub	r10,r8[48]
8000788a:	14 49       	or	r9,r10
8000788c:	f1 38 00 31 	ld.ub	r8,r8[49]
80007890:	f3 e8 10 88 	or	r8,r9,r8<<0x8
80007894:	8b 08       	st.w	r5[0x0],r8
		}
	}

	LEAVE_FF(dj.fs, res);
}
80007896:	0e 9c       	mov	r12,r7
80007898:	2f 7d       	sub	sp,-36
8000789a:	d8 22       	popm	r4-r7,pc
8000789c:	80 00       	ld.sh	r0,r0[0x0]
8000789e:	6d 2c       	ld.w	r12,r6[0x48]
800078a0:	80 00       	ld.sh	r0,r0[0x0]
800078a2:	74 5c       	ld.w	r12,r10[0x14]
800078a4:	80 00       	ld.sh	r0,r0[0x0]
800078a6:	77 50       	ld.w	r0,r11[0x54]
800078a8:	80 00       	ld.sh	r0,r0[0x0]
800078aa:	62 c8       	ld.w	r8,r1[0x30]
800078ac:	80 00       	ld.sh	r0,r0[0x0]
800078ae:	6c 50       	ld.w	r0,r6[0x14]

800078b0 <dir_alloc>:
static
FRESULT dir_alloc (	/* FR_OK(0):succeeded, !=0:error */
	DIR* dp,		/* Pointer to the directory object */
	UINT nent		/* Number of contiguous entries to allocate (1-21) */
)
{
800078b0:	eb cd 40 fe 	pushm	r1-r7,lr
800078b4:	18 97       	mov	r7,r12
800078b6:	16 92       	mov	r2,r11
	FRESULT res;
	UINT n;


	res = dir_sdi(dp, 0);
800078b8:	30 0b       	mov	r11,0
800078ba:	f0 1f 00 15 	mcall	8000790c <dir_alloc+0x5c>
	if (res == FR_OK) {
800078be:	c2 21       	brne	80007902 <dir_alloc+0x52>
800078c0:	30 05       	mov	r5,0
		n = 0;
		do {
			res = move_window(dp->fs, dp->sect);
			if (res != FR_OK) break;
			if (dp->dir[0] == DDEM || dp->dir[0] == 0) {	/* Is it a free entry? */
800078c2:	3e 54       	mov	r4,-27
800078c4:	30 06       	mov	r6,0
800078c6:	0a 91       	mov	r1,r5
				if (++n == nent) break;	/* A block of contiguous free entries is found */
			} else {
				n = 0;					/* Not a blank entry. Restart to search */
			}
			res = dir_next(dp, 1);		/* Next entry with table stretch enabled */
800078c8:	30 13       	mov	r3,1

	res = dir_sdi(dp, 0);
	if (res == FR_OK) {
		n = 0;
		do {
			res = move_window(dp->fs, dp->sect);
800078ca:	6e 4b       	ld.w	r11,r7[0x10]
800078cc:	6e 0c       	ld.w	r12,r7[0x0]
800078ce:	f0 1f 00 11 	mcall	80007910 <dir_alloc+0x60>
			if (res != FR_OK) break;
800078d2:	c1 81       	brne	80007902 <dir_alloc+0x52>
			if (dp->dir[0] == DDEM || dp->dir[0] == 0) {	/* Is it a free entry? */
800078d4:	6e 58       	ld.w	r8,r7[0x14]
800078d6:	11 88       	ld.ub	r8,r8[0x0]
800078d8:	e8 08 18 00 	cp.b	r8,r4
800078dc:	5f 09       	sreq	r9
800078de:	ec 08 18 00 	cp.b	r8,r6
800078e2:	5f 08       	sreq	r8
800078e4:	f3 e8 10 08 	or	r8,r9,r8
800078e8:	ec 08 18 00 	cp.b	r8,r6
800078ec:	c0 31       	brne	800078f2 <dir_alloc+0x42>
800078ee:	02 95       	mov	r5,r1
800078f0:	c0 48       	rjmp	800078f8 <dir_alloc+0x48>
				if (++n == nent) break;	/* A block of contiguous free entries is found */
800078f2:	2f f5       	sub	r5,-1
800078f4:	04 35       	cp.w	r5,r2
800078f6:	c0 90       	breq	80007908 <dir_alloc+0x58>
			} else {
				n = 0;					/* Not a blank entry. Restart to search */
			}
			res = dir_next(dp, 1);		/* Next entry with table stretch enabled */
800078f8:	06 9b       	mov	r11,r3
800078fa:	0e 9c       	mov	r12,r7
800078fc:	f0 1f 00 06 	mcall	80007914 <dir_alloc+0x64>
		} while (res == FR_OK);
80007900:	ce 50       	breq	800078ca <dir_alloc+0x1a>
	}
	if (res == FR_NO_FILE) res = FR_DENIED;	/* No directory entry to allocate */
80007902:	58 4c       	cp.w	r12,4
80007904:	f9 bc 00 07 	moveq	r12,7
	return res;
}
80007908:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
8000790c:	80 00       	ld.sh	r0,r0[0x0]
8000790e:	74 5c       	ld.w	r12,r10[0x14]
80007910:	80 00       	ld.sh	r0,r0[0x0]
80007912:	6c 50       	ld.w	r0,r6[0x14]
80007914:	80 00       	ld.sh	r0,r0[0x0]
80007916:	75 e0       	ld.w	r0,r10[0x78]

80007918 <f_setlabel>:
/*-----------------------------------------------------------------------*/

FRESULT f_setlabel (
	const TCHAR* label	/* Pointer to the volume label to set */
)
{
80007918:	d4 31       	pushm	r0-r7,lr
8000791a:	20 cd       	sub	sp,48
8000791c:	50 0c       	stdsp	sp[0x0],r12
	WCHAR w;
	DWORD tm;


	/* Get logical drive number */
	res = find_volume(&dj.fs, &label, 1);
8000791e:	30 1a       	mov	r10,1
80007920:	1a 9b       	mov	r11,sp
80007922:	fa cc ff f0 	sub	r12,sp,-16
80007926:	f0 1f 00 8b 	mcall	80007b50 <f_setlabel+0x238>
	if (res) LEAVE_FF(dj.fs, res);
8000792a:	e0 81 01 08 	brne	80007b3a <f_setlabel+0x222>

	/* Create a volume label in directory form */
	vn[0] = 0;
8000792e:	30 08       	mov	r8,0
80007930:	ba c8       	st.b	sp[0x4],r8
	for (sl = 0; label[sl]; sl++) ;				/* Get name length */
80007932:	40 0a       	lddsp	r10,sp[0x0]
80007934:	15 89       	ld.ub	r9,r10[0x0]
80007936:	f0 09 18 00 	cp.b	r9,r8
8000793a:	e0 80 00 90 	breq	80007a5a <f_setlabel+0x142>
8000793e:	30 07       	mov	r7,0
80007940:	2f f7       	sub	r7,-1
80007942:	f4 07 07 09 	ld.ub	r9,r10[r7]
80007946:	f0 09 18 00 	cp.b	r9,r8
8000794a:	cf b1       	brne	80007940 <f_setlabel+0x28>
8000794c:	0e 98       	mov	r8,r7
	for ( ; sl && label[sl - 1] == ' '; sl--) ;	/* Remove trailing spaces */
8000794e:	58 07       	cp.w	r7,0
80007950:	e0 80 00 85 	breq	80007a5a <f_setlabel+0x142>
80007954:	f4 07 00 09 	add	r9,r10,r7
80007958:	f3 3b ff ff 	ld.ub	r11,r9[-1]
8000795c:	32 09       	mov	r9,32
8000795e:	f2 0b 18 00 	cp.b	r11,r9
80007962:	e0 81 00 ee 	brne	80007b3e <f_setlabel+0x226>
80007966:	20 28       	sub	r8,2
80007968:	f4 08 00 08 	add	r8,r10,r8
8000796c:	12 9a       	mov	r10,r9
8000796e:	20 17       	sub	r7,1
80007970:	c7 50       	breq	80007a5a <f_setlabel+0x142>
80007972:	11 89       	ld.ub	r9,r8[0x0]
80007974:	20 18       	sub	r8,1
80007976:	f4 09 18 00 	cp.b	r9,r10
8000797a:	cf a0       	breq	8000796e <f_setlabel+0x56>
8000797c:	ce 18       	rjmp	80007b3e <f_setlabel+0x226>
		i = j = 0;
		do {
#if _USE_LFN && _LFN_UNICODE
			w = ff_convert(ff_wtoupper(label[i++]), 0);
#else
			w = (BYTE)label[i++];
8000797e:	40 08       	lddsp	r8,sp[0x0]
80007980:	f0 04 07 06 	ld.ub	r6,r8[r4]
80007984:	2f f4       	sub	r4,-1
			if (IsDBCS1(w))
80007986:	ec c9 ff 81 	sub	r9,r6,-127
8000798a:	e4 09 18 00 	cp.b	r9,r2
8000798e:	e0 8b 00 24 	brhi	800079d6 <f_setlabel+0xbe>
				w = (j < 10 && i < sl && IsDBCS2(label[i])) ? w << 8 | (BYTE)label[i++] : 0;
80007992:	58 95       	cp.w	r5,9
80007994:	5f 8a       	srls	r10
80007996:	0e 34       	cp.w	r4,r7
80007998:	5f 39       	srlo	r9
8000799a:	f5 e9 00 09 	and	r9,r10,r9
8000799e:	e2 09 18 00 	cp.b	r9,r1
800079a2:	e0 80 00 c9 	breq	80007b34 <f_setlabel+0x21c>
800079a6:	f0 04 07 08 	ld.ub	r8,r8[r4]
800079aa:	f0 c9 00 40 	sub	r9,r8,64
800079ae:	33 eb       	mov	r11,62
800079b0:	f6 09 18 00 	cp.b	r9,r11
800079b4:	5f 8a       	srls	r10
800079b6:	f0 c9 00 80 	sub	r9,r8,128
800079ba:	37 eb       	mov	r11,126
800079bc:	f6 09 18 00 	cp.b	r9,r11
800079c0:	5f 89       	srls	r9
800079c2:	f5 e9 10 09 	or	r9,r10,r9
800079c6:	e2 09 18 00 	cp.b	r9,r1
800079ca:	e0 80 00 b5 	breq	80007b34 <f_setlabel+0x21c>
800079ce:	f1 e6 10 86 	or	r6,r8,r6<<0x8
800079d2:	5c 86       	casts.h	r6
800079d4:	2f f4       	sub	r4,-1
#if _USE_LFN
			w = ff_convert(ff_wtoupper(ff_convert(w, 1)), 0);
#else
			if (IsLower(w)) w -= 0x20;			/* To upper ASCII characters */
800079d6:	ec c8 00 61 	sub	r8,r6,97
800079da:	31 9a       	mov	r10,25
800079dc:	f4 08 19 00 	cp.h	r8,r10
800079e0:	e0 8b 00 04 	brhi	800079e8 <f_setlabel+0xd0>
800079e4:	22 06       	sub	r6,32
800079e6:	5c 86       	casts.h	r6
#else
			if (!_DF1S && w >= 0x80) w = 0;		/* Reject extended characters (ASCII cfg) */
#endif
#endif
#endif
			if (!w || chk_chr("\"*+,.:;<=>\?[]|\x7F", w) || j >= (UINT)((w >= 0x100) ? 10 : 11)) /* Reject invalid characters for volume label */
800079e8:	58 06       	cp.w	r6,0
800079ea:	e0 80 00 a5 	breq	80007b34 <f_setlabel+0x21c>
800079ee:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
800079f2:	00 9c       	mov	r12,r0
800079f4:	f0 1f 00 58 	mcall	80007b54 <f_setlabel+0x23c>
800079f8:	e0 81 00 9e 	brne	80007b34 <f_setlabel+0x21c>
800079fc:	ec 03 19 00 	cp.h	r3,r6
80007a00:	f9 b8 03 0a 	movlo	r8,10
80007a04:	f9 b8 02 0b 	movhs	r8,11
80007a08:	10 35       	cp.w	r5,r8
80007a0a:	e0 82 00 95 	brhs	80007b34 <f_setlabel+0x21c>
				LEAVE_FF(dj.fs, FR_INVALID_NAME);
			if (w >= 0x100) vn[j++] = (BYTE)(w >> 8);
80007a0e:	e6 06 19 00 	cp.h	r6,r3
80007a12:	e0 88 00 0a 	brls	80007a26 <f_setlabel+0x10e>
80007a16:	fa c8 ff d0 	sub	r8,sp,-48
80007a1a:	0a 08       	add	r8,r5
80007a1c:	f3 d6 c1 08 	bfextu	r9,r6,0x8,0x8
80007a20:	f1 69 ff d4 	st.b	r8[-44],r9
80007a24:	2f f5       	sub	r5,-1
			vn[j++] = (BYTE)w;
80007a26:	fa c8 ff d0 	sub	r8,sp,-48
80007a2a:	0a 08       	add	r8,r5
80007a2c:	f1 66 ff d4 	st.b	r8[-44],r6
80007a30:	2f f5       	sub	r5,-1
		} while (i < sl);
80007a32:	0e 34       	cp.w	r4,r7
80007a34:	ca 53       	brcs	8000797e <f_setlabel+0x66>
		while (j < 11) vn[j++] = ' ';	/* Fill remaining name field */
80007a36:	58 a5       	cp.w	r5,10
80007a38:	e0 8b 00 0c 	brhi	80007a50 <f_setlabel+0x138>
80007a3c:	fa c9 ff fc 	sub	r9,sp,-4
80007a40:	f2 05 00 08 	add	r8,r9,r5
80007a44:	32 09       	mov	r9,32
80007a46:	10 c9       	st.b	r8++,r9
80007a48:	2f f5       	sub	r5,-1
80007a4a:	58 a5       	cp.w	r5,10
80007a4c:	fe 98 ff fd 	brls	80007a46 <f_setlabel+0x12e>
		if (vn[0] == DDEM) LEAVE_FF(dj.fs, FR_INVALID_NAME);	/* Reject illegal name (heading DDEM) */
80007a50:	3e 58       	mov	r8,-27
80007a52:	1b c9       	ld.ub	r9,sp[0x4]
80007a54:	f0 09 18 00 	cp.b	r9,r8
80007a58:	c6 e0       	breq	80007b34 <f_setlabel+0x21c>
	}

	/* Set volume label */
	dj.sclust = 0;					/* Open root directory */
80007a5a:	30 0b       	mov	r11,0
80007a5c:	50 6b       	stdsp	sp[0x18],r11
	res = dir_sdi(&dj, 0);
80007a5e:	fa cc ff f0 	sub	r12,sp,-16
80007a62:	f0 1f 00 3e 	mcall	80007b58 <f_setlabel+0x240>
80007a66:	18 97       	mov	r7,r12
	if (res == FR_OK) {
80007a68:	c6 81       	brne	80007b38 <f_setlabel+0x220>
		res = dir_read(&dj, 1);		/* Get an entry with AM_VOL */
80007a6a:	30 1b       	mov	r11,1
80007a6c:	fa cc ff f0 	sub	r12,sp,-16
80007a70:	f0 1f 00 3b 	mcall	80007b5c <f_setlabel+0x244>
		if (res == FR_OK) {			/* A volume label is found */
80007a74:	c2 a1       	brne	80007ac8 <f_setlabel+0x1b0>
			if (vn[0]) {
80007a76:	30 08       	mov	r8,0
80007a78:	1b c9       	ld.ub	r9,sp[0x4]
80007a7a:	f0 09 18 00 	cp.b	r9,r8
80007a7e:	c1 b0       	breq	80007ab4 <f_setlabel+0x19c>
				mem_cpy(dj.dir, vn, 11);	/* Change the volume label name */
80007a80:	30 ba       	mov	r10,11
80007a82:	fa cb ff fc 	sub	r11,sp,-4
80007a86:	40 9c       	lddsp	r12,sp[0x24]
80007a88:	f0 1f 00 36 	mcall	80007b60 <f_setlabel+0x248>
				tm = GET_FATTIME();
80007a8c:	f0 1f 00 36 	mcall	80007b64 <f_setlabel+0x24c>
				ST_DWORD(dj.dir + DIR_WrtTime, tm);
80007a90:	40 98       	lddsp	r8,sp[0x24]
80007a92:	f1 6c 00 16 	st.b	r8[22],r12
80007a96:	f3 dc c1 08 	bfextu	r9,r12,0x8,0x8
80007a9a:	40 98       	lddsp	r8,sp[0x24]
80007a9c:	f1 69 00 17 	st.b	r8[23],r9
80007aa0:	f8 09 16 10 	lsr	r9,r12,0x10
80007aa4:	40 98       	lddsp	r8,sp[0x24]
80007aa6:	f1 69 00 18 	st.b	r8[24],r9
80007aaa:	b9 8c       	lsr	r12,0x18
80007aac:	40 98       	lddsp	r8,sp[0x24]
80007aae:	f1 6c 00 19 	st.b	r8[25],r12
80007ab2:	c0 48       	rjmp	80007aba <f_setlabel+0x1a2>
			} else {
				dj.dir[0] = DDEM;			/* Remove the volume label */
80007ab4:	3e 59       	mov	r9,-27
80007ab6:	40 98       	lddsp	r8,sp[0x24]
80007ab8:	b0 89       	st.b	r8[0x0],r9
			}
			dj.fs->wflag = 1;
80007aba:	30 19       	mov	r9,1
80007abc:	40 48       	lddsp	r8,sp[0x10]
80007abe:	b0 c9       	st.b	r8[0x4],r9
			res = sync_fs(dj.fs);
80007ac0:	40 4c       	lddsp	r12,sp[0x10]
80007ac2:	f0 1f 00 2a 	mcall	80007b68 <f_setlabel+0x250>
80007ac6:	c3 a8       	rjmp	80007b3a <f_setlabel+0x222>
		} else {					/* No volume label is found or error */
			if (res == FR_NO_FILE) {
80007ac8:	58 4c       	cp.w	r12,4
80007aca:	c3 81       	brne	80007b3a <f_setlabel+0x222>
				res = FR_OK;
				if (vn[0]) {				/* Create volume label as new */
80007acc:	30 08       	mov	r8,0
80007ace:	1b c9       	ld.ub	r9,sp[0x4]
80007ad0:	f0 09 18 00 	cp.b	r9,r8
80007ad4:	c3 20       	breq	80007b38 <f_setlabel+0x220>
					res = dir_alloc(&dj, 1);	/* Allocate an entry for volume label */
80007ad6:	30 1b       	mov	r11,1
80007ad8:	fa cc ff f0 	sub	r12,sp,-16
80007adc:	f0 1f 00 24 	mcall	80007b6c <f_setlabel+0x254>
					if (res == FR_OK) {
80007ae0:	c2 d1       	brne	80007b3a <f_setlabel+0x222>
						mem_set(dj.dir, 0, SZ_DIRE);	/* Set volume label */
80007ae2:	32 0a       	mov	r10,32
80007ae4:	30 0b       	mov	r11,0
80007ae6:	40 9c       	lddsp	r12,sp[0x24]
80007ae8:	f0 1f 00 22 	mcall	80007b70 <f_setlabel+0x258>
						mem_cpy(dj.dir, vn, 11);
80007aec:	30 ba       	mov	r10,11
80007aee:	fa cb ff fc 	sub	r11,sp,-4
80007af2:	40 9c       	lddsp	r12,sp[0x24]
80007af4:	f0 1f 00 1b 	mcall	80007b60 <f_setlabel+0x248>
						dj.dir[DIR_Attr] = AM_VOL;
80007af8:	30 89       	mov	r9,8
80007afa:	40 98       	lddsp	r8,sp[0x24]
80007afc:	f1 69 00 0b 	st.b	r8[11],r9
						tm = GET_FATTIME();
80007b00:	f0 1f 00 19 	mcall	80007b64 <f_setlabel+0x24c>
						ST_DWORD(dj.dir + DIR_WrtTime, tm);
80007b04:	40 98       	lddsp	r8,sp[0x24]
80007b06:	f1 6c 00 16 	st.b	r8[22],r12
80007b0a:	f3 dc c1 08 	bfextu	r9,r12,0x8,0x8
80007b0e:	40 98       	lddsp	r8,sp[0x24]
80007b10:	f1 69 00 17 	st.b	r8[23],r9
80007b14:	f8 09 16 10 	lsr	r9,r12,0x10
80007b18:	40 98       	lddsp	r8,sp[0x24]
80007b1a:	f1 69 00 18 	st.b	r8[24],r9
80007b1e:	b9 8c       	lsr	r12,0x18
80007b20:	40 98       	lddsp	r8,sp[0x24]
80007b22:	f1 6c 00 19 	st.b	r8[25],r12
						dj.fs->wflag = 1;
80007b26:	30 19       	mov	r9,1
80007b28:	40 48       	lddsp	r8,sp[0x10]
80007b2a:	b0 c9       	st.b	r8[0x4],r9
						res = sync_fs(dj.fs);
80007b2c:	40 4c       	lddsp	r12,sp[0x10]
80007b2e:	f0 1f 00 0f 	mcall	80007b68 <f_setlabel+0x250>
80007b32:	c0 48       	rjmp	80007b3a <f_setlabel+0x222>
80007b34:	30 6c       	mov	r12,6
80007b36:	c0 28       	rjmp	80007b3a <f_setlabel+0x222>
80007b38:	0e 9c       	mov	r12,r7
			}
		}
	}

	LEAVE_FF(dj.fs, res);
}
80007b3a:	2f 4d       	sub	sp,-48
80007b3c:	d8 32       	popm	r0-r7,pc
						mem_cpy(dj.dir, vn, 11);
						dj.dir[DIR_Attr] = AM_VOL;
						tm = GET_FATTIME();
						ST_DWORD(dj.dir + DIR_WrtTime, tm);
						dj.fs->wflag = 1;
						res = sync_fs(dj.fs);
80007b3e:	30 05       	mov	r5,0
80007b40:	0a 94       	mov	r4,r5
		do {
#if _USE_LFN && _LFN_UNICODE
			w = ff_convert(ff_wtoupper(label[i++]), 0);
#else
			w = (BYTE)label[i++];
			if (IsDBCS1(w))
80007b42:	37 d2       	mov	r2,125
				w = (j < 10 && i < sl && IsDBCS2(label[i])) ? w << 8 | (BYTE)label[i++] : 0;
80007b44:	30 01       	mov	r1,0
#else
			if (!_DF1S && w >= 0x80) w = 0;		/* Reject extended characters (ASCII cfg) */
#endif
#endif
#endif
			if (!w || chk_chr("\"*+,.:;<=>\?[]|\x7F", w) || j >= (UINT)((w >= 0x100) ? 10 : 11)) /* Reject invalid characters for volume label */
80007b46:	48 c0       	lddpc	r0,80007b74 <f_setlabel+0x25c>
80007b48:	e0 63 00 ff 	mov	r3,255
80007b4c:	c1 9b       	rjmp	8000797e <f_setlabel+0x66>
80007b4e:	00 00       	add	r0,r0
80007b50:	80 00       	ld.sh	r0,r0[0x0]
80007b52:	6d 2c       	ld.w	r12,r6[0x48]
80007b54:	80 00       	ld.sh	r0,r0[0x0]
80007b56:	62 ea       	ld.w	r10,r1[0x38]
80007b58:	80 00       	ld.sh	r0,r0[0x0]
80007b5a:	74 5c       	ld.w	r12,r10[0x14]
80007b5c:	80 00       	ld.sh	r0,r0[0x0]
80007b5e:	77 50       	ld.w	r0,r11[0x54]
80007b60:	80 00       	ld.sh	r0,r0[0x0]
80007b62:	62 c8       	ld.w	r8,r1[0x30]
80007b64:	80 00       	ld.sh	r0,r0[0x0]
80007b66:	62 04       	ld.w	r4,r1[0x0]
80007b68:	80 00       	ld.sh	r0,r0[0x0]
80007b6a:	64 bc       	ld.w	r12,r2[0x2c]
80007b6c:	80 00       	ld.sh	r0,r0[0x0]
80007b6e:	78 b0       	ld.w	r0,r12[0x2c]
80007b70:	80 00       	ld.sh	r0,r0[0x0]
80007b72:	62 de       	ld.w	lr,r1[0x34]
80007b74:	80 01       	ld.sh	r1,r0[0x0]
80007b76:	8b b8       	st.w	r5[0x2c],r8

80007b78 <dir_register>:
#if !_FS_READONLY
static
FRESULT dir_register (	/* FR_OK:succeeded, FR_DENIED:no free entry or too many SFN collision, FR_DISK_ERR:disk error */
	DIR* dp				/* Target directory with object name to be created */
)
{
80007b78:	eb cd 40 c0 	pushm	r6-r7,lr
80007b7c:	18 96       	mov	r6,r12
				res = dir_next(dp, 0);	/* Next entry */
			} while (res == FR_OK && --nent);
		}
	}
#else	/* Non LFN configuration */
	res = dir_alloc(dp, 1);		/* Allocate an entry for SFN */
80007b7e:	30 1b       	mov	r11,1
80007b80:	f0 1f 00 0d 	mcall	80007bb4 <dir_register+0x3c>
80007b84:	18 97       	mov	r7,r12
#endif

	if (res == FR_OK) {				/* Set SFN entry */
80007b86:	c1 41       	brne	80007bae <dir_register+0x36>
		res = move_window(dp->fs, dp->sect);
80007b88:	6c 4b       	ld.w	r11,r6[0x10]
80007b8a:	6c 0c       	ld.w	r12,r6[0x0]
80007b8c:	f0 1f 00 0b 	mcall	80007bb8 <dir_register+0x40>
80007b90:	18 97       	mov	r7,r12
		if (res == FR_OK) {
80007b92:	c0 e1       	brne	80007bae <dir_register+0x36>
			mem_set(dp->dir, 0, SZ_DIRE);	/* Clean the entry */
80007b94:	32 0a       	mov	r10,32
80007b96:	30 0b       	mov	r11,0
80007b98:	6c 5c       	ld.w	r12,r6[0x14]
80007b9a:	f0 1f 00 09 	mcall	80007bbc <dir_register+0x44>
			mem_cpy(dp->dir, dp->fn, 11);	/* Put SFN */
80007b9e:	30 ba       	mov	r10,11
80007ba0:	6c 6b       	ld.w	r11,r6[0x18]
80007ba2:	6c 5c       	ld.w	r12,r6[0x14]
80007ba4:	f0 1f 00 07 	mcall	80007bc0 <dir_register+0x48>
#if _USE_LFN
			dp->dir[DIR_NTres] = dp->fn[NSFLAG] & (NS_BODY | NS_EXT);	/* Put NT flag */
#endif
			dp->fs->wflag = 1;
80007ba8:	6c 08       	ld.w	r8,r6[0x0]
80007baa:	30 19       	mov	r9,1
80007bac:	b0 c9       	st.b	r8[0x4],r9
		}
	}

	return res;
}
80007bae:	0e 9c       	mov	r12,r7
80007bb0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80007bb4:	80 00       	ld.sh	r0,r0[0x0]
80007bb6:	78 b0       	ld.w	r0,r12[0x2c]
80007bb8:	80 00       	ld.sh	r0,r0[0x0]
80007bba:	6c 50       	ld.w	r0,r6[0x14]
80007bbc:	80 00       	ld.sh	r0,r0[0x0]
80007bbe:	62 de       	ld.w	lr,r1[0x34]
80007bc0:	80 00       	ld.sh	r0,r0[0x0]
80007bc2:	62 c8       	ld.w	r8,r1[0x30]

80007bc4 <follow_path>:
static
FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
	DIR* dp,			/* Directory object to return last directory and found object */
	const TCHAR* path	/* Full-path string to find a file or directory */
)
{
80007bc4:	d4 31       	pushm	r0-r7,lr
80007bc6:	20 3d       	sub	sp,12
80007bc8:	18 92       	mov	r2,r12
80007bca:	16 97       	mov	r7,r11
		path++;	dp->sclust = 0;				/* Strip it and start from the root directory */
	} else {								/* No heading separator */
		dp->sclust = dp->fs->cdir;			/* Start from the current directory */
	}
#else
	if (*path == '/' || *path == '\\')		/* Strip heading separator if exist */
80007bcc:	17 88       	ld.ub	r8,r11[0x0]
80007bce:	32 f9       	mov	r9,47
80007bd0:	f2 08 18 00 	cp.b	r8,r9
80007bd4:	5f 09       	sreq	r9
80007bd6:	35 ca       	mov	r10,92
80007bd8:	f4 08 18 00 	cp.b	r8,r10
80007bdc:	5f 08       	sreq	r8
80007bde:	f3 e8 10 08 	or	r8,r9,r8
		path++;
80007be2:	f7 b7 01 ff 	subne	r7,-1
	dp->sclust = 0;							/* Always start from the root directory */
80007be6:	30 08       	mov	r8,0
80007be8:	99 28       	st.w	r12[0x8],r8
#endif

	if ((UINT)*path < ' ') {				/* Null path name is the origin directory itself */
80007bea:	0f 89       	ld.ub	r9,r7[0x0]
80007bec:	31 f8       	mov	r8,31
80007bee:	f0 09 18 00 	cp.b	r9,r8
80007bf2:	e0 8b 00 08 	brhi	80007c02 <follow_path+0x3e>
		res = dir_sdi(dp, 0);
80007bf6:	30 0b       	mov	r11,0
80007bf8:	f0 1f 00 93 	mcall	80007e44 <follow_path+0x280>
		dp->dir = 0;
80007bfc:	30 08       	mov	r8,0
80007bfe:	85 58       	st.w	r2[0x14],r8
80007c00:	c1 49       	rjmp	80007e28 <follow_path+0x264>
	BYTE b, c, d, *sfn;
	UINT ni, si, i;
	const char *p;

	/* Create file name in directory form */
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Skip duplicated separator */
80007c02:	32 f4       	mov	r4,47
80007c04:	35 c3       	mov	r3,92
80007c06:	30 06       	mov	r6,0
80007c08:	0f 88       	ld.ub	r8,r7[0x0]
80007c0a:	e8 08 18 00 	cp.b	r8,r4
80007c0e:	5f 09       	sreq	r9
80007c10:	e6 08 18 00 	cp.b	r8,r3
80007c14:	5f 08       	sreq	r8
80007c16:	f3 e8 10 08 	or	r8,r9,r8
80007c1a:	ec 08 18 00 	cp.b	r8,r6
80007c1e:	c0 e0       	breq	80007c3a <follow_path+0x76>
80007c20:	2f f7       	sub	r7,-1
80007c22:	0f 88       	ld.ub	r8,r7[0x0]
80007c24:	e8 08 18 00 	cp.b	r8,r4
80007c28:	5f 09       	sreq	r9
80007c2a:	e6 08 18 00 	cp.b	r8,r3
80007c2e:	5f 08       	sreq	r8
80007c30:	f3 e8 10 08 	or	r8,r9,r8
80007c34:	ec 08 18 00 	cp.b	r8,r6
80007c38:	cf 41       	brne	80007c20 <follow_path+0x5c>
	sfn = dp->fn;
80007c3a:	64 6a       	ld.w	r10,r2[0x18]
80007c3c:	50 2a       	stdsp	sp[0x8],r10
	mem_set(sfn, ' ', 11);
80007c3e:	30 ba       	mov	r10,11
80007c40:	32 0b       	mov	r11,32
80007c42:	40 2c       	lddsp	r12,sp[0x8]
80007c44:	f0 1f 00 81 	mcall	80007e48 <follow_path+0x284>
80007c48:	30 89       	mov	r9,8
80007c4a:	50 09       	stdsp	sp[0x0],r9
80007c4c:	30 08       	mov	r8,0
80007c4e:	50 18       	stdsp	sp[0x4],r8
80007c50:	10 90       	mov	r0,r8
80007c52:	10 91       	mov	r1,r8
#endif
#endif
		}
		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false at SBCS cfg.) */
			d = (BYTE)p[si++];			/* Get 2nd byte */
			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
80007c54:	0e 95       	mov	r5,r7
		sfn[NSFLAG] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
		return FR_OK;
	}
#endif
	for (;;) {
		c = (BYTE)p[si++];
80007c56:	ea 01 07 07 	ld.ub	r7,r5[r1]
80007c5a:	2f f1       	sub	r1,-1
		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
80007c5c:	32 09       	mov	r9,32
80007c5e:	f2 07 18 00 	cp.b	r7,r9
80007c62:	5f 88       	srls	r8
80007c64:	e8 07 18 00 	cp.b	r7,r4
80007c68:	5f 09       	sreq	r9
80007c6a:	f1 e9 10 09 	or	r9,r8,r9
80007c6e:	ec 09 18 00 	cp.b	r9,r6
80007c72:	c7 51       	brne	80007d5c <follow_path+0x198>
80007c74:	e6 07 18 00 	cp.b	r7,r3
80007c78:	c7 20       	breq	80007d5c <follow_path+0x198>
		if (c == '.' || i >= ni) {
80007c7a:	32 e8       	mov	r8,46
80007c7c:	f0 07 18 00 	cp.b	r7,r8
80007c80:	5f 09       	sreq	r9
80007c82:	40 0a       	lddsp	r10,sp[0x0]
80007c84:	14 30       	cp.w	r0,r10
80007c86:	5f 28       	srhs	r8
80007c88:	f3 e8 10 08 	or	r8,r9,r8
80007c8c:	ec 08 18 00 	cp.b	r8,r6
80007c90:	c1 50       	breq	80007cba <follow_path+0xf6>
			if (ni != 8 || c != '.') return FR_INVALID_NAME;
80007c92:	58 8a       	cp.w	r10,8
80007c94:	5f 19       	srne	r9
80007c96:	32 e8       	mov	r8,46
80007c98:	f0 07 18 00 	cp.b	r7,r8
80007c9c:	5f 18       	srne	r8
80007c9e:	f3 e8 10 08 	or	r8,r9,r8
80007ca2:	ec 08 18 00 	cp.b	r8,r6
80007ca6:	e0 81 00 be 	brne	80007e22 <follow_path+0x25e>
			i = 8; ni = 11;
			b <<= 2; continue;
80007caa:	40 18       	lddsp	r8,sp[0x4]
80007cac:	a3 68       	lsl	r8,0x2
80007cae:	5c 58       	castu.b	r8
80007cb0:	50 18       	stdsp	sp[0x4],r8
80007cb2:	30 ba       	mov	r10,11
80007cb4:	50 0a       	stdsp	sp[0x0],r10
80007cb6:	30 80       	mov	r0,8
80007cb8:	cc fb       	rjmp	80007c56 <follow_path+0x92>
		}
		if (c >= 0x80) {				/* Extended character? */
80007cba:	ec 07 18 00 	cp.b	r7,r6
80007cbe:	c0 54       	brge	80007cc8 <follow_path+0x104>
			b |= 3;						/* Eliminate NT flag */
80007cc0:	40 18       	lddsp	r8,sp[0x4]
80007cc2:	e8 18 00 03 	orl	r8,0x3
80007cc6:	50 18       	stdsp	sp[0x4],r8
#if !_DF1S
			return FR_INVALID_NAME;		/* Reject extended characters (ASCII cfg) */
#endif
#endif
		}
		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false at SBCS cfg.) */
80007cc8:	0e 98       	mov	r8,r7
80007cca:	28 18       	sub	r8,-127
80007ccc:	37 da       	mov	r10,125
80007cce:	f4 08 18 00 	cp.b	r8,r10
80007cd2:	e0 8b 00 23 	brhi	80007d18 <follow_path+0x154>
			d = (BYTE)p[si++];			/* Get 2nd byte */
80007cd6:	ea 01 07 08 	ld.ub	r8,r5[r1]
			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
80007cda:	f0 c9 00 40 	sub	r9,r8,64
80007cde:	33 ea       	mov	r10,62
80007ce0:	f4 09 18 00 	cp.b	r9,r10
80007ce4:	5f b9       	srhi	r9
80007ce6:	f0 cb 00 80 	sub	r11,r8,128
80007cea:	37 ea       	mov	r10,126
80007cec:	f4 0b 18 00 	cp.b	r11,r10
80007cf0:	5f ba       	srhi	r10
80007cf2:	14 69       	and	r9,r10
80007cf4:	ec 09 18 00 	cp.b	r9,r6
80007cf8:	e0 81 00 95 	brne	80007e22 <follow_path+0x25e>
80007cfc:	40 09       	lddsp	r9,sp[0x0]
80007cfe:	20 19       	sub	r9,1
80007d00:	12 30       	cp.w	r0,r9
80007d02:	e0 82 00 90 	brhs	80007e22 <follow_path+0x25e>
			return FR_INVALID_NAME;		/* Reject extended characters (ASCII cfg) */
#endif
#endif
		}
		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false at SBCS cfg.) */
			d = (BYTE)p[si++];			/* Get 2nd byte */
80007d06:	2f f1       	sub	r1,-1
			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
				return FR_INVALID_NAME;
			sfn[i++] = c;
80007d08:	40 29       	lddsp	r9,sp[0x8]
80007d0a:	f2 00 0b 07 	st.b	r9[r0],r7
80007d0e:	2f f0       	sub	r0,-1
			sfn[i++] = d;
80007d10:	f2 00 0b 08 	st.b	r9[r0],r8
80007d14:	2f f0       	sub	r0,-1
80007d16:	ca 0b       	rjmp	80007c56 <follow_path+0x92>
		} else {						/* SBC */
			if (chk_chr("\"*+,:;<=>\?[]|\x7F", c))	/* Reject illegal chrs for SFN */
80007d18:	0e 9b       	mov	r11,r7
80007d1a:	4c dc       	lddpc	r12,80007e4c <follow_path+0x288>
80007d1c:	f0 1f 00 4d 	mcall	80007e50 <follow_path+0x28c>
80007d20:	e0 81 00 81 	brne	80007e22 <follow_path+0x25e>
				return FR_INVALID_NAME;
			if (IsUpper(c)) {			/* ASCII large capital? */
80007d24:	0e 98       	mov	r8,r7
80007d26:	24 18       	sub	r8,65
80007d28:	31 99       	mov	r9,25
80007d2a:	f2 08 18 00 	cp.b	r8,r9
80007d2e:	e0 8b 00 06 	brhi	80007d3a <follow_path+0x176>
				b |= 2;
80007d32:	40 18       	lddsp	r8,sp[0x4]
80007d34:	a1 b8       	sbr	r8,0x1
80007d36:	50 18       	stdsp	sp[0x4],r8
80007d38:	c0 d8       	rjmp	80007d52 <follow_path+0x18e>
			} else {
				if (IsLower(c)) {		/* ASCII small capital? */
80007d3a:	0e 98       	mov	r8,r7
80007d3c:	26 18       	sub	r8,97
80007d3e:	31 9a       	mov	r10,25
80007d40:	f4 08 18 00 	cp.b	r8,r10
80007d44:	e0 8b 00 07 	brhi	80007d52 <follow_path+0x18e>
					b |= 1; c -= 0x20;
80007d48:	40 19       	lddsp	r9,sp[0x4]
80007d4a:	a1 a9       	sbr	r9,0x0
80007d4c:	50 19       	stdsp	sp[0x4],r9
80007d4e:	22 07       	sub	r7,32
80007d50:	5c 57       	castu.b	r7
				}
			}
			sfn[i++] = c;
80007d52:	40 28       	lddsp	r8,sp[0x8]
80007d54:	f0 00 0b 07 	st.b	r8[r0],r7
80007d58:	2f f0       	sub	r0,-1
80007d5a:	c7 eb       	rjmp	80007c56 <follow_path+0x92>
80007d5c:	0a 97       	mov	r7,r5
		}
	}
	*path = &p[si];						/* Return pointer to the next segment */
	c = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
80007d5e:	58 08       	cp.w	r8,0
80007d60:	f9 b8 01 04 	movne	r8,4
80007d64:	f9 b8 00 00 	moveq	r8,0

	if (!i) return FR_INVALID_NAME;		/* Reject nul string */
80007d68:	58 00       	cp.w	r0,0
80007d6a:	c5 c0       	breq	80007e22 <follow_path+0x25e>
	if (sfn[0] == DDEM) sfn[0] = RDDEM;	/* When first character collides with DDEM, replace it with RDDEM */
80007d6c:	40 29       	lddsp	r9,sp[0x8]
80007d6e:	13 8a       	ld.ub	r10,r9[0x0]
80007d70:	3e 59       	mov	r9,-27
80007d72:	f2 0a 18 00 	cp.b	r10,r9
80007d76:	f9 b9 00 05 	moveq	r9,5
80007d7a:	fb fa 00 02 	ld.weq	r10,sp[0x8]
80007d7e:	f5 f9 0e 00 	st.beq	r10[0x0],r9

	if (ni == 8) b <<= 2;
80007d82:	40 09       	lddsp	r9,sp[0x0]
80007d84:	58 89       	cp.w	r9,8
80007d86:	c0 51       	brne	80007d90 <follow_path+0x1cc>
80007d88:	40 19       	lddsp	r9,sp[0x4]
80007d8a:	a3 69       	lsl	r9,0x2
80007d8c:	5c 59       	castu.b	r9
80007d8e:	50 19       	stdsp	sp[0x4],r9
	if ((b & 0x03) == 0x01) c |= NS_EXT;	/* NT flag (Name extension has only small capital) */
80007d90:	40 19       	lddsp	r9,sp[0x4]
80007d92:	f5 d9 c0 02 	bfextu	r10,r9,0x0,0x2
80007d96:	58 1a       	cp.w	r10,1
80007d98:	c0 21       	brne	80007d9c <follow_path+0x1d8>
80007d9a:	a5 a8       	sbr	r8,0x4
	if ((b & 0x0C) == 0x04) c |= NS_BODY;	/* NT flag (Name body has only small capital) */
80007d9c:	e2 19 00 0c 	andl	r9,0xc,COH
80007da0:	58 49       	cp.w	r9,4
80007da2:	c0 21       	brne	80007da6 <follow_path+0x1e2>
80007da4:	a3 b8       	sbr	r8,0x3

	sfn[NSFLAG] = c;		/* Store NT flag, File name is created */
80007da6:	40 2a       	lddsp	r10,sp[0x8]
80007da8:	f5 68 00 0b 	st.b	r10[11],r8
	BYTE c, *dir;
#if _USE_LFN
	BYTE a, ord, sum;
#endif

	res = dir_sdi(dp, 0);			/* Rewind directory object */
80007dac:	30 0b       	mov	r11,0
80007dae:	04 9c       	mov	r12,r2
80007db0:	f0 1f 00 25 	mcall	80007e44 <follow_path+0x280>
	if (res != FR_OK) return res;
80007db4:	c2 11       	brne	80007df6 <follow_path+0x232>

#if _USE_LFN
	ord = sum = 0xFF; dp->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
#endif
	do {
		res = move_window(dp->fs, dp->sect);
80007db6:	64 4b       	ld.w	r11,r2[0x10]
80007db8:	64 0c       	ld.w	r12,r2[0x0]
80007dba:	f0 1f 00 27 	mcall	80007e54 <follow_path+0x290>
		if (res != FR_OK) break;
80007dbe:	c1 c1       	brne	80007df6 <follow_path+0x232>
		dir = dp->dir;					/* Ptr to the directory entry of current index */
80007dc0:	64 59       	ld.w	r9,r2[0x14]
		c = dir[DIR_Name];
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
80007dc2:	13 88       	ld.ub	r8,r9[0x0]
80007dc4:	ec 08 18 00 	cp.b	r8,r6
80007dc8:	c3 90       	breq	80007e3a <follow_path+0x276>
				if (!(dp->fn[NSFLAG] & NS_LOSS) && !mem_cmp(dir, dp->fn, 11)) break;	/* SFN matched? */
				ord = 0xFF; dp->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
			}
		}
#else		/* Non LFN configuration */
		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dp->fn, 11)) /* Is it a valid entry? */
80007dca:	f3 38 00 0b 	ld.ub	r8,r9[11]
80007dce:	e2 18 00 08 	andl	r8,0x8,COH
80007dd2:	c0 d1       	brne	80007dec <follow_path+0x228>
80007dd4:	64 65       	ld.w	r5,r2[0x18]
80007dd6:	c0 48       	rjmp	80007dde <follow_path+0x21a>
80007dd8:	2f f8       	sub	r8,-1
static
int mem_cmp (const void* dst, const void* src, UINT cnt) {
	const BYTE *d = (const BYTE *)dst, *s = (const BYTE *)src;
	int r = 0;

	while (cnt-- && (r = *d++ - *s++) == 0) ;
80007dda:	58 b8       	cp.w	r8,11
80007ddc:	c2 80       	breq	80007e2c <follow_path+0x268>
80007dde:	f2 08 07 0b 	ld.ub	r11,r9[r8]
80007de2:	ea 08 07 0a 	ld.ub	r10,r5[r8]
80007de6:	f4 0b 18 00 	cp.b	r11,r10
80007dea:	cf 70       	breq	80007dd8 <follow_path+0x214>
		}
#else		/* Non LFN configuration */
		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dp->fn, 11)) /* Is it a valid entry? */
			break;
#endif
		res = dir_next(dp, 0);		/* Next entry */
80007dec:	30 0b       	mov	r11,0
80007dee:	04 9c       	mov	r12,r2
80007df0:	f0 1f 00 1a 	mcall	80007e58 <follow_path+0x294>
	} while (res == FR_OK);
80007df4:	ce 10       	breq	80007db6 <follow_path+0x1f2>
	} else {								/* Follow path */
		for (;;) {
			res = create_name(dp, &path);	/* Get a segment name of the path */
			if (res != FR_OK) break;
			res = dir_find(dp);				/* Find an object with the sagment name */
			ns = dp->fn[NSFLAG];
80007df6:	64 68       	ld.w	r8,r2[0x18]
80007df8:	f1 38 00 0b 	ld.ub	r8,r8[11]
			if (res != FR_OK) {				/* Failed to find the object */
				if (res == FR_NO_FILE) {	/* Object is not found */
80007dfc:	58 4c       	cp.w	r12,4
80007dfe:	c1 51       	brne	80007e28 <follow_path+0x264>
					if (_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exist, */
						dp->sclust = 0; dp->dir = 0;	/* it is the root directory and stay there */
						if (!(ns & NS_LAST)) continue;	/* Continue to follow if not last segment */
						res = FR_OK;					/* Ended at the root directroy. Function completed. */
					} else {							/* Could not find the object */
						if (!(ns & NS_LAST)) res = FR_NO_PATH;	/* Adjust error code if not last segment */
80007e00:	e2 18 00 04 	andl	r8,0x4,COH
80007e04:	c1 10       	breq	80007e26 <follow_path+0x262>
80007e06:	30 4c       	mov	r12,4
80007e08:	c1 08       	rjmp	80007e28 <follow_path+0x264>
					}
				}
				break;
			}
			if (ns & NS_LAST) break;			/* Last segment matched. Function completed. */
			dir = dp->dir;						/* Follow the sub-directory */
80007e0a:	64 5b       	ld.w	r11,r2[0x14]
			if (!(dir[DIR_Attr] & AM_DIR)) {	/* It is not a sub-directory and cannot follow */
80007e0c:	f7 38 00 0b 	ld.ub	r8,r11[11]
80007e10:	e2 18 00 10 	andl	r8,0x10,COH
80007e14:	c0 90       	breq	80007e26 <follow_path+0x262>
				}
			}
			sfn[i++] = c;
		}
	}
	*path = &p[si];						/* Return pointer to the next segment */
80007e16:	02 07       	add	r7,r1
			if (ns & NS_LAST) break;			/* Last segment matched. Function completed. */
			dir = dp->dir;						/* Follow the sub-directory */
			if (!(dir[DIR_Attr] & AM_DIR)) {	/* It is not a sub-directory and cannot follow */
				res = FR_NO_PATH; break;
			}
			dp->sclust = ld_clust(dp->fs, dir);
80007e18:	64 0c       	ld.w	r12,r2[0x0]
80007e1a:	f0 1f 00 11 	mcall	80007e5c <follow_path+0x298>
80007e1e:	85 2c       	st.w	r2[0x8],r12
		}
80007e20:	cf 4a       	rjmp	80007c08 <follow_path+0x44>
80007e22:	30 6c       	mov	r12,6
80007e24:	c0 28       	rjmp	80007e28 <follow_path+0x264>
80007e26:	30 5c       	mov	r12,5
	}

	return res;
}
80007e28:	2f dd       	sub	sp,-12
80007e2a:	d8 32       	popm	r0-r7,pc
	} else {								/* Follow path */
		for (;;) {
			res = create_name(dp, &path);	/* Get a segment name of the path */
			if (res != FR_OK) break;
			res = dir_find(dp);				/* Find an object with the sagment name */
			ns = dp->fn[NSFLAG];
80007e2c:	64 68       	ld.w	r8,r2[0x18]
80007e2e:	f1 38 00 0b 	ld.ub	r8,r8[11]
80007e32:	e2 18 00 04 	andl	r8,0x4,COH
80007e36:	ce a0       	breq	80007e0a <follow_path+0x246>
80007e38:	cf 8b       	rjmp	80007e28 <follow_path+0x264>
80007e3a:	64 68       	ld.w	r8,r2[0x18]
80007e3c:	f1 38 00 0b 	ld.ub	r8,r8[11]
80007e40:	ce 0b       	rjmp	80007e00 <follow_path+0x23c>
80007e42:	00 00       	add	r0,r0
80007e44:	80 00       	ld.sh	r0,r0[0x0]
80007e46:	74 5c       	ld.w	r12,r10[0x14]
80007e48:	80 00       	ld.sh	r0,r0[0x0]
80007e4a:	62 de       	ld.w	lr,r1[0x34]
80007e4c:	80 01       	ld.sh	r1,r0[0x0]
80007e4e:	8b c8       	st.w	r5[0x30],r8
80007e50:	80 00       	ld.sh	r0,r0[0x0]
80007e52:	62 ea       	ld.w	r10,r1[0x38]
80007e54:	80 00       	ld.sh	r0,r0[0x0]
80007e56:	6c 50       	ld.w	r0,r6[0x14]
80007e58:	80 00       	ld.sh	r0,r0[0x0]
80007e5a:	75 e0       	ld.w	r0,r10[0x78]
80007e5c:	80 00       	ld.sh	r0,r0[0x0]
80007e5e:	63 5a       	ld.w	r10,r1[0x54]

80007e60 <f_opendir>:

FRESULT f_opendir (
	DIR* dp,			/* Pointer to directory object to create */
	const TCHAR* path	/* Pointer to the directory path */
)
{
80007e60:	eb cd 40 80 	pushm	r7,lr
80007e64:	20 5d       	sub	sp,20
80007e66:	18 97       	mov	r7,r12
80007e68:	50 0b       	stdsp	sp[0x0],r11
	FRESULT res;
	FATFS* fs;
	DEFINE_NAMEBUF;


	if (!dp) return FR_INVALID_OBJECT;
80007e6a:	58 0c       	cp.w	r12,0
80007e6c:	c0 31       	brne	80007e72 <f_opendir+0x12>
80007e6e:	30 9c       	mov	r12,9
80007e70:	c2 d8       	rjmp	80007eca <f_opendir+0x6a>

	/* Get logical drive number */
	res = find_volume(&fs, &path, 0);
80007e72:	30 0a       	mov	r10,0
80007e74:	1a 9b       	mov	r11,sp
80007e76:	fa cc ff f0 	sub	r12,sp,-16
80007e7a:	f0 1f 00 17 	mcall	80007ed4 <f_opendir+0x74>
	if (res == FR_OK) {
80007e7e:	c2 41       	brne	80007ec6 <f_opendir+0x66>
		dp->fs = fs;
80007e80:	40 48       	lddsp	r8,sp[0x10]
80007e82:	8f 08       	st.w	r7[0x0],r8
		INIT_BUF(*dp);
80007e84:	fa c8 ff fc 	sub	r8,sp,-4
80007e88:	8f 68       	st.w	r7[0x18],r8
		res = follow_path(dp, path);			/* Follow the path to the directory */
80007e8a:	40 0b       	lddsp	r11,sp[0x0]
80007e8c:	0e 9c       	mov	r12,r7
80007e8e:	f0 1f 00 13 	mcall	80007ed8 <f_opendir+0x78>
		FREE_BUF();
		if (res == FR_OK) {						/* Follow completed */
80007e92:	c1 61       	brne	80007ebe <f_opendir+0x5e>
			if (dp->dir) {						/* It is not the origin directory itself */
80007e94:	6e 5b       	ld.w	r11,r7[0x14]
80007e96:	58 0b       	cp.w	r11,0
80007e98:	c0 c0       	breq	80007eb0 <f_opendir+0x50>
				if (dp->dir[DIR_Attr] & AM_DIR)	/* The object is a sub directory */
80007e9a:	f7 38 00 0b 	ld.ub	r8,r11[11]
80007e9e:	e2 18 00 10 	andl	r8,0x10,COH
80007ea2:	c0 31       	brne	80007ea8 <f_opendir+0x48>
80007ea4:	30 5c       	mov	r12,5
80007ea6:	c0 e8       	rjmp	80007ec2 <f_opendir+0x62>
					dp->sclust = ld_clust(fs, dp->dir);
80007ea8:	40 4c       	lddsp	r12,sp[0x10]
80007eaa:	f0 1f 00 0d 	mcall	80007edc <f_opendir+0x7c>
80007eae:	8f 2c       	st.w	r7[0x8],r12
				else							/* The object is a file */
					res = FR_NO_PATH;
			}
			if (res == FR_OK) {
				dp->id = fs->id;
80007eb0:	40 48       	lddsp	r8,sp[0x10]
80007eb2:	90 38       	ld.sh	r8,r8[0x6]
80007eb4:	ae 28       	st.h	r7[0x4],r8
				res = dir_sdi(dp, 0);			/* Rewind directory */
80007eb6:	30 0b       	mov	r11,0
80007eb8:	0e 9c       	mov	r12,r7
80007eba:	f0 1f 00 0a 	mcall	80007ee0 <f_opendir+0x80>
					}
				}
#endif
			}
		}
		if (res == FR_NO_FILE) res = FR_NO_PATH;
80007ebe:	58 4c       	cp.w	r12,4
80007ec0:	c0 80       	breq	80007ed0 <f_opendir+0x70>
	}
	if (res != FR_OK) dp->fs = 0;		/* Invalidate the directory object if function faild */
80007ec2:	58 0c       	cp.w	r12,0
80007ec4:	c0 30       	breq	80007eca <f_opendir+0x6a>
80007ec6:	30 08       	mov	r8,0
80007ec8:	8f 08       	st.w	r7[0x0],r8

	LEAVE_FF(fs, res);
}
80007eca:	2f bd       	sub	sp,-20
80007ecc:	e3 cd 80 80 	ldm	sp++,r7,pc
#endif
			}
		}
		if (res == FR_NO_FILE) res = FR_NO_PATH;
	}
	if (res != FR_OK) dp->fs = 0;		/* Invalidate the directory object if function faild */
80007ed0:	30 5c       	mov	r12,5
80007ed2:	cf ab       	rjmp	80007ec6 <f_opendir+0x66>
80007ed4:	80 00       	ld.sh	r0,r0[0x0]
80007ed6:	6d 2c       	ld.w	r12,r6[0x48]
80007ed8:	80 00       	ld.sh	r0,r0[0x0]
80007eda:	7b c4       	ld.w	r4,sp[0x70]
80007edc:	80 00       	ld.sh	r0,r0[0x0]
80007ede:	63 5a       	ld.w	r10,r1[0x54]
80007ee0:	80 00       	ld.sh	r0,r0[0x0]
80007ee2:	74 5c       	ld.w	r12,r10[0x14]

80007ee4 <f_mkdir>:
/*-----------------------------------------------------------------------*/

FRESULT f_mkdir (
	const TCHAR* path		/* Pointer to the directory path */
)
{
80007ee4:	d4 31       	pushm	r0-r7,lr
80007ee6:	21 0d       	sub	sp,64
80007ee8:	50 4c       	stdsp	sp[0x10],r12
	FRESULT res;
	DIR dj;
	BYTE *dir, n;
	DWORD dsc, dcl, pcl, tm = GET_FATTIME();
80007eea:	f0 1f 00 61 	mcall	8000806c <f_mkdir+0x188>
80007eee:	18 95       	mov	r5,r12
	DEFINE_NAMEBUF;


	/* Get logical drive number */
	res = find_volume(&dj.fs, &path, 1);
80007ef0:	30 1a       	mov	r10,1
80007ef2:	fa cb ff f0 	sub	r11,sp,-16
80007ef6:	fa cc ff e0 	sub	r12,sp,-32
80007efa:	f0 1f 00 5e 	mcall	80008070 <f_mkdir+0x18c>
80007efe:	18 97       	mov	r7,r12
	if (res == FR_OK) {
80007f00:	c0 30       	breq	80007f06 <f_mkdir+0x22>
80007f02:	18 96       	mov	r6,r12
80007f04:	ca 78       	rjmp	80008052 <f_mkdir+0x16e>
		INIT_BUF(dj);
80007f06:	fa c8 ff ec 	sub	r8,sp,-20
80007f0a:	50 e8       	stdsp	sp[0x38],r8
		res = follow_path(&dj, path);			/* Follow the file path */
80007f0c:	40 4b       	lddsp	r11,sp[0x10]
80007f0e:	fa cc ff e0 	sub	r12,sp,-32
80007f12:	f0 1f 00 59 	mcall	80008074 <f_mkdir+0x190>
80007f16:	18 96       	mov	r6,r12
		if (res == FR_OK) res = FR_EXIST;		/* Any object with same name is already existing */
80007f18:	c0 31       	brne	80007f1e <f_mkdir+0x3a>
80007f1a:	30 86       	mov	r6,8
80007f1c:	c9 b8       	rjmp	80008052 <f_mkdir+0x16e>
		if (_FS_RPATH && res == FR_NO_FILE && (dj.fn[NSFLAG] & NS_DOT))
			res = FR_INVALID_NAME;
		if (res == FR_NO_FILE) {				/* Can create a new directory */
80007f1e:	58 4c       	cp.w	r12,4
80007f20:	e0 81 00 99 	brne	80008052 <f_mkdir+0x16e>
			dcl = create_chain(dj.fs, 0);		/* Allocate a cluster for the new directory table */
80007f24:	30 0b       	mov	r11,0
80007f26:	40 8c       	lddsp	r12,sp[0x20]
80007f28:	f0 1f 00 54 	mcall	80008078 <f_mkdir+0x194>
80007f2c:	18 92       	mov	r2,r12
			res = FR_OK;
			if (dcl == 0) res = FR_DENIED;		/* No space to allocate a new cluster */
80007f2e:	c0 31       	brne	80007f34 <f_mkdir+0x50>
80007f30:	30 77       	mov	r7,7
80007f32:	c0 88       	rjmp	80007f42 <f_mkdir+0x5e>
			if (dcl == 1) res = FR_INT_ERR;
80007f34:	58 1c       	cp.w	r12,1
80007f36:	c0 31       	brne	80007f3c <f_mkdir+0x58>
80007f38:	30 27       	mov	r7,2
80007f3a:	c6 c8       	rjmp	80008012 <f_mkdir+0x12e>
			if (dcl == 0xFFFFFFFF) res = FR_DISK_ERR;
80007f3c:	5b fc       	cp.w	r12,-1
80007f3e:	e0 80 00 8d 	breq	80008058 <f_mkdir+0x174>
			if (res == FR_OK)					/* Flush FAT */
80007f42:	58 07       	cp.w	r7,0
80007f44:	c6 71       	brne	80008012 <f_mkdir+0x12e>
				res = sync_window(dj.fs);
80007f46:	40 8c       	lddsp	r12,sp[0x20]
80007f48:	f0 1f 00 4d 	mcall	8000807c <f_mkdir+0x198>
80007f4c:	18 97       	mov	r7,r12
			if (res == FR_OK) {					/* Initialize the new directory table */
80007f4e:	c6 21       	brne	80008012 <f_mkdir+0x12e>
				dsc = clust2sect(dj.fs, dcl);
80007f50:	40 87       	lddsp	r7,sp[0x20]
80007f52:	04 9b       	mov	r11,r2
80007f54:	0e 9c       	mov	r12,r7
80007f56:	f0 1f 00 4b 	mcall	80008080 <f_mkdir+0x19c>
80007f5a:	18 94       	mov	r4,r12
				dir = dj.fs->win;
80007f5c:	ee c3 ff d0 	sub	r3,r7,-48
				mem_set(dir, 0, SS(dj.fs));
80007f60:	e0 6a 02 00 	mov	r10,512
80007f64:	30 0b       	mov	r11,0
80007f66:	06 9c       	mov	r12,r3
80007f68:	f0 1f 00 47 	mcall	80008084 <f_mkdir+0x1a0>
				mem_set(dir + DIR_Name, ' ', 11);	/* Create "." entry */
80007f6c:	30 ba       	mov	r10,11
80007f6e:	32 0b       	mov	r11,32
80007f70:	06 9c       	mov	r12,r3
80007f72:	f0 1f 00 45 	mcall	80008084 <f_mkdir+0x1a0>
				dir[DIR_Name] = '.';
80007f76:	32 e6       	mov	r6,46
80007f78:	ef 66 00 30 	st.b	r7[48],r6
				dir[DIR_Attr] = AM_DIR;
80007f7c:	31 08       	mov	r8,16
80007f7e:	e7 68 00 0b 	st.b	r3[11],r8
				ST_DWORD(dir + DIR_WrtTime, tm);
80007f82:	f1 d5 c0 08 	bfextu	r8,r5,0x0,0x8
80007f86:	50 38       	stdsp	sp[0xc],r8
80007f88:	e7 68 00 16 	st.b	r3[22],r8
80007f8c:	f1 d5 c1 08 	bfextu	r8,r5,0x8,0x8
80007f90:	50 28       	stdsp	sp[0x8],r8
80007f92:	e7 68 00 17 	st.b	r3[23],r8
80007f96:	f1 d5 c2 08 	bfextu	r8,r5,0x10,0x8
80007f9a:	50 18       	stdsp	sp[0x4],r8
80007f9c:	e7 68 00 18 	st.b	r3[24],r8
80007fa0:	b9 85       	lsr	r5,0x18
80007fa2:	50 05       	stdsp	sp[0x0],r5
80007fa4:	e7 65 00 19 	st.b	r3[25],r5
				st_clust(dir, dcl);
80007fa8:	04 9b       	mov	r11,r2
80007faa:	06 9c       	mov	r12,r3
80007fac:	f0 1f 00 37 	mcall	80008088 <f_mkdir+0x1a4>
				mem_cpy(dir + SZ_DIRE, dir, SZ_DIRE); 	/* Create ".." entry */
80007fb0:	2b 07       	sub	r7,-80
80007fb2:	32 0a       	mov	r10,32
80007fb4:	06 9b       	mov	r11,r3
80007fb6:	0e 9c       	mov	r12,r7
80007fb8:	f0 1f 00 35 	mcall	8000808c <f_mkdir+0x1a8>
				dir[SZ_DIRE + 1] = '.'; pcl = dj.sclust;
80007fbc:	e7 66 00 21 	st.b	r3[33],r6
80007fc0:	40 ab       	lddsp	r11,sp[0x28]
				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
80007fc2:	40 88       	lddsp	r8,sp[0x20]
80007fc4:	11 8a       	ld.ub	r10,r8[0x0]
80007fc6:	30 39       	mov	r9,3
80007fc8:	f2 0a 18 00 	cp.b	r10,r9
80007fcc:	c0 51       	brne	80007fd6 <f_mkdir+0xf2>
80007fce:	70 98       	ld.w	r8,r8[0x24]
80007fd0:	16 38       	cp.w	r8,r11
80007fd2:	f9 bb 00 00 	moveq	r11,0
					pcl = 0;
				st_clust(dir + SZ_DIRE, pcl);
80007fd6:	0e 9c       	mov	r12,r7
80007fd8:	f0 1f 00 2c 	mcall	80008088 <f_mkdir+0x1a4>
				for (n = dj.fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
80007fdc:	40 88       	lddsp	r8,sp[0x20]
80007fde:	11 a6       	ld.ub	r6,r8[0x2]
80007fe0:	58 06       	cp.w	r6,0
80007fe2:	c3 d0       	breq	8000805c <f_mkdir+0x178>
					dj.fs->winsect = dsc++;
					dj.fs->wflag = 1;
80007fe4:	30 15       	mov	r5,1
					res = sync_window(dj.fs);
					if (res != FR_OK) break;
					mem_set(dir, 0, SS(dj.fs));
80007fe6:	e0 61 02 00 	mov	r1,512
80007fea:	30 00       	mov	r0,0
				dir[SZ_DIRE + 1] = '.'; pcl = dj.sclust;
				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
					pcl = 0;
				st_clust(dir + SZ_DIRE, pcl);
				for (n = dj.fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
					dj.fs->winsect = dsc++;
80007fec:	40 88       	lddsp	r8,sp[0x20]
80007fee:	91 b4       	st.w	r8[0x2c],r4
80007ff0:	2f f4       	sub	r4,-1
					dj.fs->wflag = 1;
80007ff2:	40 88       	lddsp	r8,sp[0x20]
80007ff4:	b0 c5       	st.b	r8[0x4],r5
					res = sync_window(dj.fs);
80007ff6:	40 8c       	lddsp	r12,sp[0x20]
80007ff8:	f0 1f 00 21 	mcall	8000807c <f_mkdir+0x198>
					if (res != FR_OK) break;
80007ffc:	c0 a1       	brne	80008010 <f_mkdir+0x12c>
					mem_set(dir, 0, SS(dj.fs));
80007ffe:	02 9a       	mov	r10,r1
80008000:	00 9b       	mov	r11,r0
80008002:	06 9c       	mov	r12,r3
80008004:	f0 1f 00 20 	mcall	80008084 <f_mkdir+0x1a0>
				mem_cpy(dir + SZ_DIRE, dir, SZ_DIRE); 	/* Create ".." entry */
				dir[SZ_DIRE + 1] = '.'; pcl = dj.sclust;
				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
					pcl = 0;
				st_clust(dir + SZ_DIRE, pcl);
				for (n = dj.fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
80008008:	20 16       	sub	r6,1
8000800a:	5c 56       	castu.b	r6
8000800c:	cf 01       	brne	80007fec <f_mkdir+0x108>
8000800e:	c2 78       	rjmp	8000805c <f_mkdir+0x178>
80008010:	18 97       	mov	r7,r12
80008012:	0e 96       	mov	r6,r7
					mem_set(dir, 0, SS(dj.fs));
				}
			}
			if (res == FR_OK) res = dir_register(&dj);	/* Register the object to the directoy */
			if (res != FR_OK) {
				remove_chain(dj.fs, dcl);			/* Could not register, remove cluster chain */
80008014:	04 9b       	mov	r11,r2
80008016:	40 8c       	lddsp	r12,sp[0x20]
80008018:	f0 1f 00 1e 	mcall	80008090 <f_mkdir+0x1ac>
8000801c:	c1 b8       	rjmp	80008052 <f_mkdir+0x16e>
			} else {
				dir = dj.dir;
8000801e:	40 dc       	lddsp	r12,sp[0x34]
				dir[DIR_Attr] = AM_DIR;				/* Attribute */
80008020:	31 08       	mov	r8,16
80008022:	f9 68 00 0b 	st.b	r12[11],r8
				ST_DWORD(dir + DIR_WrtTime, tm);	/* Created time */
80008026:	40 38       	lddsp	r8,sp[0xc]
80008028:	f9 68 00 16 	st.b	r12[22],r8
8000802c:	40 28       	lddsp	r8,sp[0x8]
8000802e:	f9 68 00 17 	st.b	r12[23],r8
80008032:	40 18       	lddsp	r8,sp[0x4]
80008034:	f9 68 00 18 	st.b	r12[24],r8
80008038:	40 08       	lddsp	r8,sp[0x0]
8000803a:	f9 68 00 19 	st.b	r12[25],r8
				st_clust(dir, dcl);					/* Table start cluster */
8000803e:	04 9b       	mov	r11,r2
80008040:	f0 1f 00 12 	mcall	80008088 <f_mkdir+0x1a4>
				dj.fs->wflag = 1;
80008044:	30 19       	mov	r9,1
80008046:	40 88       	lddsp	r8,sp[0x20]
80008048:	b0 c9       	st.b	r8[0x4],r9
				res = sync_fs(dj.fs);
8000804a:	40 8c       	lddsp	r12,sp[0x20]
8000804c:	f0 1f 00 12 	mcall	80008094 <f_mkdir+0x1b0>
80008050:	18 96       	mov	r6,r12
		}
		FREE_BUF();
	}

	LEAVE_FF(dj.fs, res);
}
80008052:	0c 9c       	mov	r12,r6
80008054:	2f 0d       	sub	sp,-64
80008056:	d8 32       	popm	r0-r7,pc
				dir = dj.dir;
				dir[DIR_Attr] = AM_DIR;				/* Attribute */
				ST_DWORD(dir + DIR_WrtTime, tm);	/* Created time */
				st_clust(dir, dcl);					/* Table start cluster */
				dj.fs->wflag = 1;
				res = sync_fs(dj.fs);
80008058:	30 17       	mov	r7,1
8000805a:	cd cb       	rjmp	80008012 <f_mkdir+0x12e>
					res = sync_window(dj.fs);
					if (res != FR_OK) break;
					mem_set(dir, 0, SS(dj.fs));
				}
			}
			if (res == FR_OK) res = dir_register(&dj);	/* Register the object to the directoy */
8000805c:	fa cc ff e0 	sub	r12,sp,-32
80008060:	f0 1f 00 0e 	mcall	80008098 <f_mkdir+0x1b4>
80008064:	18 96       	mov	r6,r12
			if (res != FR_OK) {
80008066:	cd c0       	breq	8000801e <f_mkdir+0x13a>
80008068:	cd 6b       	rjmp	80008014 <f_mkdir+0x130>
8000806a:	00 00       	add	r0,r0
8000806c:	80 00       	ld.sh	r0,r0[0x0]
8000806e:	62 04       	ld.w	r4,r1[0x0]
80008070:	80 00       	ld.sh	r0,r0[0x0]
80008072:	6d 2c       	ld.w	r12,r6[0x48]
80008074:	80 00       	ld.sh	r0,r0[0x0]
80008076:	7b c4       	ld.w	r4,sp[0x70]
80008078:	80 00       	ld.sh	r0,r0[0x0]
8000807a:	75 10       	ld.w	r0,r10[0x44]
8000807c:	80 00       	ld.sh	r0,r0[0x0]
8000807e:	64 58       	ld.w	r8,r2[0x14]
80008080:	80 00       	ld.sh	r0,r0[0x0]
80008082:	63 04       	ld.w	r4,r1[0x40]
80008084:	80 00       	ld.sh	r0,r0[0x0]
80008086:	62 de       	ld.w	lr,r1[0x34]
80008088:	80 00       	ld.sh	r0,r0[0x0]
8000808a:	63 82       	ld.w	r2,r1[0x60]
8000808c:	80 00       	ld.sh	r0,r0[0x0]
8000808e:	62 c8       	ld.w	r8,r1[0x30]
80008090:	80 00       	ld.sh	r0,r0[0x0]
80008092:	76 f0       	ld.w	r0,r11[0x3c]
80008094:	80 00       	ld.sh	r0,r0[0x0]
80008096:	64 bc       	ld.w	r12,r2[0x2c]
80008098:	80 00       	ld.sh	r0,r0[0x0]
8000809a:	7b 78       	ld.w	r8,sp[0x5c]

8000809c <f_open>:
FRESULT f_open (
	FIL* fp,			/* Pointer to the blank file object */
	const TCHAR* path,	/* Pointer to the file name */
	BYTE mode			/* Access mode and file open mode flags */
)
{
8000809c:	eb cd 40 fc 	pushm	r2-r7,lr
800080a0:	20 cd       	sub	sp,48
800080a2:	18 97       	mov	r7,r12
800080a4:	50 0b       	stdsp	sp[0x0],r11
#if !_FS_READONLY
	DWORD dw, cl;
#endif


	if (!fp) return FR_INVALID_OBJECT;
800080a6:	58 0c       	cp.w	r12,0
800080a8:	c0 31       	brne	800080ae <f_open+0x12>
800080aa:	30 96       	mov	r6,9
800080ac:	cb 68       	rjmp	80008218 <f_open+0x17c>
	fp->fs = 0;			/* Clear file object */
800080ae:	30 08       	mov	r8,0
800080b0:	99 08       	st.w	r12[0x0],r8

	/* Get logical drive number */
#if !_FS_READONLY
	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
800080b2:	eb da c0 05 	bfextu	r5,r10,0x0,0x5
	res = find_volume(&dj.fs, &path, (BYTE)(mode & ~FA_READ));
800080b6:	0a 93       	mov	r3,r5
800080b8:	e2 1a 00 1e 	andl	r10,0x1e,COH
800080bc:	1a 9b       	mov	r11,sp
800080be:	fa cc ff f0 	sub	r12,sp,-16
800080c2:	f0 1f 00 5c 	mcall	80008230 <f_open+0x194>
800080c6:	18 96       	mov	r6,r12
#else
	mode &= FA_READ;
	res = find_volume(&dj.fs, &path, 0);
#endif
	if (res == FR_OK) {
800080c8:	e0 81 00 a8 	brne	80008218 <f_open+0x17c>
		INIT_BUF(dj);
800080cc:	fa c8 ff fc 	sub	r8,sp,-4
800080d0:	50 a8       	stdsp	sp[0x28],r8
		res = follow_path(&dj, path);	/* Follow the file path */
800080d2:	40 0b       	lddsp	r11,sp[0x0]
800080d4:	fa cc ff f0 	sub	r12,sp,-16
800080d8:	f0 1f 00 57 	mcall	80008234 <f_open+0x198>
		dir = dj.dir;
800080dc:	40 94       	lddsp	r4,sp[0x24]
#if !_FS_READONLY	/* R/W configuration */
		if (res == FR_OK) {
800080de:	c0 41       	brne	800080e6 <f_open+0x4a>
			if (!dir)	/* Default directory itself */
800080e0:	58 04       	cp.w	r4,0
800080e2:	f9 bc 00 06 	moveq	r12,6
			else
				res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
#endif
		}
		/* Create or Open a file */
		if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
800080e6:	06 98       	mov	r8,r3
800080e8:	e2 18 00 1c 	andl	r8,0x1c,COH
800080ec:	c5 f0       	breq	800081aa <f_open+0x10e>
			if (res != FR_OK) {					/* No file, create new */
800080ee:	58 0c       	cp.w	r12,0
800080f0:	c0 d0       	breq	8000810a <f_open+0x6e>
				if (res == FR_NO_FILE)			/* There is no file to open, create a new entry */
800080f2:	58 4c       	cp.w	r12,4
800080f4:	e0 81 00 91 	brne	80008216 <f_open+0x17a>
#if _FS_LOCK
					res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
#else
					res = dir_register(&dj);
800080f8:	fa cc ff f0 	sub	r12,sp,-16
800080fc:	f0 1f 00 4f 	mcall	80008238 <f_open+0x19c>
#endif
				mode |= FA_CREATE_ALWAYS;		/* File is created */
				dir = dj.dir;					/* New entry */
80008100:	40 94       	lddsp	r4,sp[0x24]
				} else {
					if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
						res = FR_EXIST;
				}
			}
			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
80008102:	e0 81 00 8a 	brne	80008216 <f_open+0x17a>
#if _FS_LOCK
					res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
#else
					res = dir_register(&dj);
#endif
				mode |= FA_CREATE_ALWAYS;		/* File is created */
80008106:	a3 b5       	sbr	r5,0x3
80008108:	c0 c8       	rjmp	80008120 <f_open+0x84>
				dir = dj.dir;					/* New entry */
			}
			else {								/* Any object is already existing */
				if (dir[DIR_Attr] & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
8000810a:	e9 38 00 0b 	ld.ub	r8,r4[11]
8000810e:	e2 18 00 11 	andl	r8,0x11,COH
80008112:	c0 30       	breq	80008118 <f_open+0x7c>
80008114:	30 7c       	mov	r12,7
80008116:	c8 08       	rjmp	80008216 <f_open+0x17a>
					res = FR_DENIED;
				} else {
					if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
80008118:	e2 13 00 04 	andl	r3,0x4,COH
8000811c:	e0 81 00 82 	brne	80008220 <f_open+0x184>
						res = FR_EXIST;
				}
			}
			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
80008120:	0a 98       	mov	r8,r5
80008122:	e2 18 00 08 	andl	r8,0x8,COH
80008126:	c7 f0       	breq	80008224 <f_open+0x188>
				dw = GET_FATTIME();
80008128:	f0 1f 00 45 	mcall	8000823c <f_open+0x1a0>
				ST_DWORD(dir + DIR_CrtTime, dw);/* Set created time */
8000812c:	f5 dc c0 08 	bfextu	r10,r12,0x0,0x8
80008130:	e9 6a 00 0e 	st.b	r4[14],r10
80008134:	f3 dc c1 08 	bfextu	r9,r12,0x8,0x8
80008138:	e9 69 00 0f 	st.b	r4[15],r9
8000813c:	f1 dc c2 08 	bfextu	r8,r12,0x10,0x8
80008140:	e9 68 00 10 	st.b	r4[16],r8
80008144:	b9 8c       	lsr	r12,0x18
80008146:	e9 6c 00 11 	st.b	r4[17],r12
				ST_DWORD(dir + DIR_WrtTime, dw);/* Set modified time */
8000814a:	e9 6a 00 16 	st.b	r4[22],r10
8000814e:	e9 69 00 17 	st.b	r4[23],r9
80008152:	e9 68 00 18 	st.b	r4[24],r8
80008156:	e9 6c 00 19 	st.b	r4[25],r12
				dir[DIR_Attr] = 0;				/* Reset attribute */
8000815a:	30 08       	mov	r8,0
8000815c:	e9 68 00 0b 	st.b	r4[11],r8
				ST_DWORD(dir + DIR_FileSize, 0);/* Reset file size */
80008160:	e9 68 00 1c 	st.b	r4[28],r8
80008164:	e9 68 00 1d 	st.b	r4[29],r8
80008168:	e9 68 00 1e 	st.b	r4[30],r8
8000816c:	e9 68 00 1f 	st.b	r4[31],r8
				cl = ld_clust(dj.fs, dir);		/* Get cluster chain */
80008170:	08 9b       	mov	r11,r4
80008172:	40 4c       	lddsp	r12,sp[0x10]
80008174:	f0 1f 00 33 	mcall	80008240 <f_open+0x1a4>
80008178:	18 93       	mov	r3,r12
				st_clust(dir, 0);				/* Reset cluster */
8000817a:	30 0b       	mov	r11,0
8000817c:	08 9c       	mov	r12,r4
8000817e:	f0 1f 00 32 	mcall	80008244 <f_open+0x1a8>
				dj.fs->wflag = 1;
80008182:	30 19       	mov	r9,1
80008184:	40 48       	lddsp	r8,sp[0x10]
80008186:	b0 c9       	st.b	r8[0x4],r9
				if (cl) {						/* Remove the cluster chain if exist */
80008188:	58 03       	cp.w	r3,0
8000818a:	c4 d0       	breq	80008224 <f_open+0x188>
					dw = dj.fs->winsect;
8000818c:	40 4c       	lddsp	r12,sp[0x10]
8000818e:	78 b2       	ld.w	r2,r12[0x2c]
					res = remove_chain(dj.fs, cl);
80008190:	06 9b       	mov	r11,r3
80008192:	f0 1f 00 2e 	mcall	80008248 <f_open+0x1ac>
					if (res == FR_OK) {
80008196:	c4 01       	brne	80008216 <f_open+0x17a>
						dj.fs->last_clust = cl - 1;	/* Reuse the cluster hole */
80008198:	20 13       	sub	r3,1
8000819a:	40 48       	lddsp	r8,sp[0x10]
8000819c:	91 33       	st.w	r8[0xc],r3
						res = move_window(dj.fs, dw);
8000819e:	04 9b       	mov	r11,r2
800081a0:	40 4c       	lddsp	r12,sp[0x10]
800081a2:	f0 1f 00 2b 	mcall	8000824c <f_open+0x1b0>
					if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
						res = FR_DENIED;
				}
			}
		}
		if (res == FR_OK) {
800081a6:	c1 40       	breq	800081ce <f_open+0x132>
800081a8:	c3 78       	rjmp	80008216 <f_open+0x17a>
					}
				}
			}
		}
		else {	/* Open an existing file */
			if (res == FR_OK) {					/* Following succeeded */
800081aa:	58 0c       	cp.w	r12,0
800081ac:	c3 51       	brne	80008216 <f_open+0x17a>
				if (dir[DIR_Attr] & AM_DIR) {	/* It is a directory */
800081ae:	e9 38 00 0b 	ld.ub	r8,r4[11]
800081b2:	10 99       	mov	r9,r8
800081b4:	e2 19 00 10 	andl	r9,0x10,COH
800081b8:	c0 30       	breq	800081be <f_open+0x122>
800081ba:	30 4c       	mov	r12,4
800081bc:	c2 d8       	rjmp	80008216 <f_open+0x17a>
					res = FR_NO_FILE;
				} else {
					if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
800081be:	e2 13 00 02 	andl	r3,0x2,COH
800081c2:	c3 10       	breq	80008224 <f_open+0x188>
800081c4:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800081c8:	c2 e0       	breq	80008224 <f_open+0x188>
800081ca:	30 7c       	mov	r12,7
800081cc:	c2 58       	rjmp	80008216 <f_open+0x17a>
				}
			}
		}
		if (res == FR_OK) {
			if (mode & FA_CREATE_ALWAYS)		/* Set file change flag if created or overwritten */
				mode |= FA__WRITTEN;
800081ce:	a5 b5       	sbr	r5,0x5
			fp->dir_sect = dj.fs->winsect;		/* Pointer to the directory entry */
800081d0:	40 43       	lddsp	r3,sp[0x10]
800081d2:	66 b8       	ld.w	r8,r3[0x2c]
800081d4:	8f 78       	st.w	r7[0x1c],r8
			fp->dir_ptr = dir;
800081d6:	8f 84       	st.w	r7[0x20],r4
		}
#endif
		FREE_BUF();

		if (res == FR_OK) {
			fp->flag = mode;					/* File access mode */
800081d8:	ae e5       	st.b	r7[0x6],r5
			fp->err = 0;						/* Clear error flag */
800081da:	30 08       	mov	r8,0
800081dc:	ae f8       	st.b	r7[0x7],r8
			fp->sclust = ld_clust(dj.fs, dir);	/* File start cluster */
800081de:	08 9b       	mov	r11,r4
800081e0:	06 9c       	mov	r12,r3
800081e2:	f0 1f 00 18 	mcall	80008240 <f_open+0x1a4>
800081e6:	8f 4c       	st.w	r7[0x10],r12
			fp->fsize = LD_DWORD(dir + DIR_FileSize);	/* File size */
800081e8:	e9 39 00 1f 	ld.ub	r9,r4[31]
800081ec:	e9 38 00 1e 	ld.ub	r8,r4[30]
800081f0:	b1 68       	lsl	r8,0x10
800081f2:	f1 e9 11 88 	or	r8,r8,r9<<0x18
800081f6:	e9 39 00 1c 	ld.ub	r9,r4[28]
800081fa:	12 48       	or	r8,r9
800081fc:	e9 39 00 1d 	ld.ub	r9,r4[29]
80008200:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80008204:	8f 38       	st.w	r7[0xc],r8
			fp->fptr = 0;						/* File pointer */
80008206:	30 08       	mov	r8,0
80008208:	8f 28       	st.w	r7[0x8],r8
			fp->dsect = 0;
8000820a:	8f 68       	st.w	r7[0x18],r8
#if _USE_FASTSEEK
			fp->cltbl = 0;						/* Normal seek mode */
8000820c:	8f 98       	st.w	r7[0x24],r8
#endif
			fp->fs = dj.fs;	 					/* Validate file object */
8000820e:	8f 03       	st.w	r7[0x0],r3
			fp->id = fp->fs->id;
80008210:	86 38       	ld.sh	r8,r3[0x6]
80008212:	ae 28       	st.h	r7[0x4],r8
80008214:	c0 28       	rjmp	80008218 <f_open+0x17c>
80008216:	18 96       	mov	r6,r12
		}
	}

	LEAVE_FF(dj.fs, res);
}
80008218:	0c 9c       	mov	r12,r6
8000821a:	2f 4d       	sub	sp,-48
8000821c:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
			fp->dsect = 0;
#if _USE_FASTSEEK
			fp->cltbl = 0;						/* Normal seek mode */
#endif
			fp->fs = dj.fs;	 					/* Validate file object */
			fp->id = fp->fs->id;
80008220:	30 8c       	mov	r12,8
80008222:	cf ab       	rjmp	80008216 <f_open+0x17a>
						res = FR_DENIED;
				}
			}
		}
		if (res == FR_OK) {
			if (mode & FA_CREATE_ALWAYS)		/* Set file change flag if created or overwritten */
80008224:	0a 98       	mov	r8,r5
80008226:	e2 18 00 08 	andl	r8,0x8,COH
8000822a:	cd 30       	breq	800081d0 <f_open+0x134>
8000822c:	cd 1b       	rjmp	800081ce <f_open+0x132>
8000822e:	00 00       	add	r0,r0
80008230:	80 00       	ld.sh	r0,r0[0x0]
80008232:	6d 2c       	ld.w	r12,r6[0x48]
80008234:	80 00       	ld.sh	r0,r0[0x0]
80008236:	7b c4       	ld.w	r4,sp[0x70]
80008238:	80 00       	ld.sh	r0,r0[0x0]
8000823a:	7b 78       	ld.w	r8,sp[0x5c]
8000823c:	80 00       	ld.sh	r0,r0[0x0]
8000823e:	62 04       	ld.w	r4,r1[0x0]
80008240:	80 00       	ld.sh	r0,r0[0x0]
80008242:	63 5a       	ld.w	r10,r1[0x54]
80008244:	80 00       	ld.sh	r0,r0[0x0]
80008246:	63 82       	ld.w	r2,r1[0x60]
80008248:	80 00       	ld.sh	r0,r0[0x0]
8000824a:	76 f0       	ld.w	r0,r11[0x3c]
8000824c:	80 00       	ld.sh	r0,r0[0x0]
8000824e:	6c 50       	ld.w	r0,r6[0x14]

80008250 <f_getfree>:
FRESULT f_getfree (
	const TCHAR* path,	/* Path name of the logical drive number */
	DWORD* nclst,		/* Pointer to a variable to return number of free clusters */
	FATFS** fatfs		/* Pointer to return pointer to corresponding file system object */
)
{
80008250:	d4 31       	pushm	r0-r7,lr
80008252:	20 2d       	sub	sp,8
80008254:	fa c7 ff f8 	sub	r7,sp,-8
80008258:	0e dc       	st.w	--r7,r12
8000825a:	16 90       	mov	r0,r11
8000825c:	14 96       	mov	r6,r10
	UINT i;
	BYTE fat, *p;


	/* Get logical drive number */
	res = find_volume(fatfs, &path, 0);
8000825e:	30 0a       	mov	r10,0
80008260:	0e 9b       	mov	r11,r7
80008262:	0c 9c       	mov	r12,r6
80008264:	f0 1f 00 33 	mcall	80008330 <f_getfree+0xe0>
80008268:	18 93       	mov	r3,r12
	fs = *fatfs;
8000826a:	6c 06       	ld.w	r6,r6[0x0]
	if (res == FR_OK) {
8000826c:	c5 f1       	brne	8000832a <f_getfree+0xda>
		/* If free_clust is valid, return it without full cluster scan */
		if (fs->free_clust <= fs->n_fatent - 2) {
8000826e:	6c 48       	ld.w	r8,r6[0x10]
80008270:	6c 57       	ld.w	r7,r6[0x14]
80008272:	ee c9 00 02 	sub	r9,r7,2
80008276:	12 38       	cp.w	r8,r9
80008278:	e0 8b 00 04 	brhi	80008280 <f_getfree+0x30>
			*nclst = fs->free_clust;
8000827c:	81 08       	st.w	r0[0x0],r8
8000827e:	c5 68       	rjmp	8000832a <f_getfree+0xda>
		} else {
			/* Get number of free clusters */
			fat = fs->fs_type;
80008280:	0d 84       	ld.ub	r4,r6[0x0]
			nfree = 0;
			if (fat == FS_FAT12) {	/* Sector unalighed entries: Search FAT via regular routine. */
80008282:	30 18       	mov	r8,1
80008284:	f0 04 18 00 	cp.b	r4,r8
80008288:	c1 71       	brne	800082b6 <f_getfree+0x66>
8000828a:	30 27       	mov	r7,2
8000828c:	30 05       	mov	r5,0
				clst = 2;
				do {
					stat = get_fat(fs, clst);
8000828e:	0e 9b       	mov	r11,r7
80008290:	0c 9c       	mov	r12,r6
80008292:	f0 1f 00 29 	mcall	80008334 <f_getfree+0xe4>
					if (stat == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }
80008296:	5b fc       	cp.w	r12,-1
80008298:	c0 31       	brne	8000829e <f_getfree+0x4e>
8000829a:	30 1c       	mov	r12,1
8000829c:	c4 28       	rjmp	80008320 <f_getfree+0xd0>
					if (stat == 1) { res = FR_INT_ERR; break; }
8000829e:	58 1c       	cp.w	r12,1
800082a0:	c0 31       	brne	800082a6 <f_getfree+0x56>
800082a2:	30 2c       	mov	r12,2
800082a4:	c3 e8       	rjmp	80008320 <f_getfree+0xd0>
					if (stat == 0) nfree++;
800082a6:	58 0c       	cp.w	r12,0
800082a8:	f7 b5 00 ff 	subeq	r5,-1
				} while (++clst < fs->n_fatent);
800082ac:	2f f7       	sub	r7,-1
800082ae:	6c 58       	ld.w	r8,r6[0x14]
800082b0:	10 37       	cp.w	r7,r8
800082b2:	ce e3       	brcs	8000828e <f_getfree+0x3e>
800082b4:	c3 58       	rjmp	8000831e <f_getfree+0xce>
			} else {				/* Sector alighed entries: Accelerate the FAT search. */
				clst = fs->n_fatent; sect = fs->fatbase;
800082b6:	6c 81       	ld.w	r1,r6[0x20]
				i = 0; p = 0;
				do {
					if (!i) {
						res = move_window(fs, sect++);
						if (res != FR_OK) break;
						p = fs->win;
800082b8:	30 08       	mov	r8,0
800082ba:	10 99       	mov	r9,r8
800082bc:	10 95       	mov	r5,r8
			} else {				/* Sector alighed entries: Accelerate the FAT search. */
				clst = fs->n_fatent; sect = fs->fatbase;
				i = 0; p = 0;
				do {
					if (!i) {
						res = move_window(fs, sect++);
800082be:	ec ca ff d0 	sub	r10,r6,-48
800082c2:	50 0a       	stdsp	sp[0x0],r10
						if (res != FR_OK) break;
						p = fs->win;
						i = SS(fs);
					}
					if (fat == FS_FAT16) {
800082c4:	30 22       	mov	r2,2
				} while (++clst < fs->n_fatent);
			} else {				/* Sector alighed entries: Accelerate the FAT search. */
				clst = fs->n_fatent; sect = fs->fatbase;
				i = 0; p = 0;
				do {
					if (!i) {
800082c6:	58 09       	cp.w	r9,0
800082c8:	c0 a1       	brne	800082dc <f_getfree+0x8c>
						res = move_window(fs, sect++);
800082ca:	02 9b       	mov	r11,r1
800082cc:	0c 9c       	mov	r12,r6
800082ce:	f0 1f 00 1b 	mcall	80008338 <f_getfree+0xe8>
						if (res != FR_OK) break;
800082d2:	c2 71       	brne	80008320 <f_getfree+0xd0>
			} else {				/* Sector alighed entries: Accelerate the FAT search. */
				clst = fs->n_fatent; sect = fs->fatbase;
				i = 0; p = 0;
				do {
					if (!i) {
						res = move_window(fs, sect++);
800082d4:	2f f1       	sub	r1,-1
800082d6:	40 08       	lddsp	r8,sp[0x0]
800082d8:	e0 69 02 00 	mov	r9,512
						if (res != FR_OK) break;
						p = fs->win;
						i = SS(fs);
					}
					if (fat == FS_FAT16) {
800082dc:	e4 04 18 00 	cp.b	r4,r2
800082e0:	c0 d1       	brne	800082fa <f_getfree+0xaa>
						if (LD_WORD(p) == 0) nfree++;
800082e2:	11 9b       	ld.ub	r11,r8[0x1]
800082e4:	11 8a       	ld.ub	r10,r8[0x0]
800082e6:	f5 eb 10 8a 	or	r10,r10,r11<<0x8
800082ea:	30 0b       	mov	r11,0
800082ec:	f6 0a 19 00 	cp.h	r10,r11
800082f0:	f7 b5 00 ff 	subeq	r5,-1
						p += 2; i -= 2;
800082f4:	2f e8       	sub	r8,-2
800082f6:	20 29       	sub	r9,2
800082f8:	c1 18       	rjmp	8000831a <f_getfree+0xca>
					} else {
						if ((LD_DWORD(p) & 0x0FFFFFFF) == 0) nfree++;
800082fa:	11 bb       	ld.ub	r11,r8[0x3]
800082fc:	11 aa       	ld.ub	r10,r8[0x2]
800082fe:	b1 6a       	lsl	r10,0x10
80008300:	f5 eb 11 8a 	or	r10,r10,r11<<0x18
80008304:	11 8b       	ld.ub	r11,r8[0x0]
80008306:	16 4a       	or	r10,r11
80008308:	11 9b       	ld.ub	r11,r8[0x1]
8000830a:	f5 eb 10 8a 	or	r10,r10,r11<<0x8
8000830e:	f5 da c0 1c 	bfextu	r10,r10,0x0,0x1c
80008312:	f7 b5 00 ff 	subeq	r5,-1
						p += 4; i -= 4;
80008316:	2f c8       	sub	r8,-4
80008318:	20 49       	sub	r9,4
					}
				} while (--clst);
8000831a:	20 17       	sub	r7,1
8000831c:	cd 51       	brne	800082c6 <f_getfree+0x76>
8000831e:	06 9c       	mov	r12,r3
			}
			fs->free_clust = nfree;	/* free_clust is valid */
80008320:	8d 45       	st.w	r6[0x10],r5
			fs->fsi_flag |= 1;		/* FSInfo is to be updated */
80008322:	0d d8       	ld.ub	r8,r6[0x5]
80008324:	a1 a8       	sbr	r8,0x0
80008326:	ac d8       	st.b	r6[0x5],r8
			*nclst = nfree;			/* Return the free clusters */
80008328:	81 05       	st.w	r0[0x0],r5
		}
	}
	LEAVE_FF(fs, res);
}
8000832a:	2f ed       	sub	sp,-8
8000832c:	d8 32       	popm	r0-r7,pc
8000832e:	00 00       	add	r0,r0
80008330:	80 00       	ld.sh	r0,r0[0x0]
80008332:	6d 2c       	ld.w	r12,r6[0x48]
80008334:	80 00       	ld.sh	r0,r0[0x0]
80008336:	73 78       	ld.w	r8,r9[0x5c]
80008338:	80 00       	ld.sh	r0,r0[0x0]
8000833a:	6c 50       	ld.w	r0,r6[0x14]

8000833c <f_lseek>:

FRESULT f_lseek (
	FIL* fp,		/* Pointer to the file object */
	DWORD ofs		/* File pointer from top of file */
)
{
8000833c:	d4 31       	pushm	r0-r7,lr
8000833e:	18 97       	mov	r7,r12
80008340:	16 95       	mov	r5,r11
#if _USE_FASTSEEK
	DWORD cl, pcl, ncl, tcl, dsc, tlen, ulen, *tbl;
#endif


	res = validate(fp);					/* Check validity of the object */
80008342:	f0 1f 00 a5 	mcall	800085d4 <f_lseek+0x298>
80008346:	18 96       	mov	r6,r12
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
80008348:	e0 81 01 44 	brne	800085d0 <f_lseek+0x294>
	if (fp->err)						/* Check error */
8000834c:	0f f8       	ld.ub	r8,r7[0x7]
8000834e:	58 08       	cp.w	r8,0
80008350:	c0 30       	breq	80008356 <f_lseek+0x1a>
		LEAVE_FF(fp->fs, (FRESULT)fp->err);
80008352:	10 96       	mov	r6,r8
80008354:	c3 e9       	rjmp	800085d0 <f_lseek+0x294>

#if _USE_FASTSEEK
	if (fp->cltbl) {	/* Fast seek */
80008356:	6e 93       	ld.w	r3,r7[0x24]
80008358:	58 03       	cp.w	r3,0
8000835a:	e0 80 00 85 	breq	80008464 <f_lseek+0x128>
		if (ofs == CREATE_LINKMAP) {	/* Create CLMT */
8000835e:	5b f5       	cp.w	r5,-1
80008360:	c3 71       	brne	800083ce <f_lseek+0x92>
			tbl = fp->cltbl;
			tlen = *tbl++; ulen = 2;	/* Given table size and required table size */
80008362:	07 00       	ld.w	r0,r3++
			cl = fp->sclust;			/* Top of the chain */
80008364:	6e 41       	ld.w	r1,r7[0x10]
			if (cl) {
80008366:	58 01       	cp.w	r1,0
80008368:	c2 80       	breq	800083b8 <f_lseek+0x7c>
8000836a:	30 22       	mov	r2,2
8000836c:	02 95       	mov	r5,r1
8000836e:	30 04       	mov	r4,0
				do {
					/* Get a fragment */
					tcl = cl; ncl = 0; ulen += 2;	/* Top, length and used items */
					do {
						pcl = cl; ncl++;
						cl = get_fat(fp->fs, cl);
80008370:	0a 9b       	mov	r11,r5
80008372:	6e 0c       	ld.w	r12,r7[0x0]
80008374:	f0 1f 00 99 	mcall	800085d8 <f_lseek+0x29c>
						if (cl <= 1) ABORT(fp->fs, FR_INT_ERR);
80008378:	58 1c       	cp.w	r12,1
8000837a:	e0 8b 00 06 	brhi	80008386 <f_lseek+0x4a>
8000837e:	30 28       	mov	r8,2
80008380:	ae f8       	st.b	r7[0x7],r8
80008382:	30 26       	mov	r6,2
80008384:	c2 69       	rjmp	800085d0 <f_lseek+0x294>
						if (cl == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
80008386:	5b fc       	cp.w	r12,-1
80008388:	c0 51       	brne	80008392 <f_lseek+0x56>
8000838a:	30 18       	mov	r8,1
8000838c:	ae f8       	st.b	r7[0x7],r8
8000838e:	30 16       	mov	r6,1
80008390:	c2 09       	rjmp	800085d0 <f_lseek+0x294>
			if (cl) {
				do {
					/* Get a fragment */
					tcl = cl; ncl = 0; ulen += 2;	/* Top, length and used items */
					do {
						pcl = cl; ncl++;
80008392:	2f f4       	sub	r4,-1
						cl = get_fat(fp->fs, cl);
						if (cl <= 1) ABORT(fp->fs, FR_INT_ERR);
						if (cl == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
					} while (cl == pcl + 1);
80008394:	2f f5       	sub	r5,-1
80008396:	0a 3c       	cp.w	r12,r5
80008398:	c0 31       	brne	8000839e <f_lseek+0x62>
8000839a:	18 95       	mov	r5,r12
8000839c:	ce ab       	rjmp	80008370 <f_lseek+0x34>
8000839e:	18 98       	mov	r8,r12
			tlen = *tbl++; ulen = 2;	/* Given table size and required table size */
			cl = fp->sclust;			/* Top of the chain */
			if (cl) {
				do {
					/* Get a fragment */
					tcl = cl; ncl = 0; ulen += 2;	/* Top, length and used items */
800083a0:	2f e2       	sub	r2,-2
						pcl = cl; ncl++;
						cl = get_fat(fp->fs, cl);
						if (cl <= 1) ABORT(fp->fs, FR_INT_ERR);
						if (cl == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
					} while (cl == pcl + 1);
					if (ulen <= tlen) {		/* Store the length and top of the fragment */
800083a2:	04 30       	cp.w	r0,r2
800083a4:	c0 33       	brcs	800083aa <f_lseek+0x6e>
						*tbl++ = ncl; *tbl++ = tcl;
800083a6:	06 a4       	st.w	r3++,r4
800083a8:	06 a1       	st.w	r3++,r1
					}
				} while (cl < fp->fs->n_fatent);	/* Repeat until end of chain */
800083aa:	6e 09       	ld.w	r9,r7[0x0]
800083ac:	72 59       	ld.w	r9,r9[0x14]
800083ae:	10 39       	cp.w	r9,r8
800083b0:	e0 88 00 05 	brls	800083ba <f_lseek+0x7e>
800083b4:	18 91       	mov	r1,r12
800083b6:	cd bb       	rjmp	8000836c <f_lseek+0x30>
800083b8:	30 22       	mov	r2,2
			}
			*fp->cltbl = ulen;	/* Number of items used */
800083ba:	6e 98       	ld.w	r8,r7[0x24]
800083bc:	91 02       	st.w	r8[0x0],r2
			if (ulen <= tlen)
800083be:	00 32       	cp.w	r2,r0
800083c0:	f9 b6 0b 11 	movhi	r6,17
				*tbl = 0;		/* Terminate table */
800083c4:	f9 b8 08 00 	movls	r8,0
800083c8:	e7 f8 8a 00 	st.wls	r3[0x0],r8
800083cc:	c0 29       	rjmp	800085d0 <f_lseek+0x294>
800083ce:	6e 34       	ld.w	r4,r7[0xc]
800083d0:	08 35       	cp.w	r5,r4
800083d2:	e8 05 17 b0 	movhi	r5,r4
				res = FR_NOT_ENOUGH_CORE;	/* Given table size is smaller than required */

		} else {						/* Fast seek */
			if (ofs > fp->fsize)		/* Clip offset at the file size */
				ofs = fp->fsize;
			fp->fptr = ofs;				/* Set file pointer */
800083d6:	8f 25       	st.w	r7[0x8],r5
			if (ofs) {
800083d8:	58 05       	cp.w	r5,0
800083da:	e0 80 00 fb 	breq	800085d0 <f_lseek+0x294>
				fp->clust = clmt_clust(fp, ofs - 1);
800083de:	ea c4 00 01 	sub	r4,r5,1
800083e2:	08 9b       	mov	r11,r4
800083e4:	0e 9c       	mov	r12,r7
800083e6:	f0 1f 00 7e 	mcall	800085dc <f_lseek+0x2a0>
800083ea:	18 9b       	mov	r11,r12
800083ec:	8f 5c       	st.w	r7[0x14],r12
				dsc = clust2sect(fp->fs, fp->clust);
800083ee:	6e 05       	ld.w	r5,r7[0x0]
800083f0:	0a 9c       	mov	r12,r5
800083f2:	f0 1f 00 7c 	mcall	800085e0 <f_lseek+0x2a4>
				if (!dsc) ABORT(fp->fs, FR_INT_ERR);
800083f6:	c0 51       	brne	80008400 <f_lseek+0xc4>
800083f8:	30 28       	mov	r8,2
800083fa:	ae f8       	st.b	r7[0x7],r8
800083fc:	30 26       	mov	r6,2
800083fe:	ce 98       	rjmp	800085d0 <f_lseek+0x294>
				dsc += (ofs - 1) / SS(fp->fs) & (fp->fs->csize - 1);
80008400:	0b a9       	ld.ub	r9,r5[0x2]
				if (fp->fptr % SS(fp->fs) && dsc != fp->dsect) {	/* Refill sector cache if needed */
80008402:	6e 28       	ld.w	r8,r7[0x8]
80008404:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
80008408:	e0 80 00 e4 	breq	800085d0 <f_lseek+0x294>
			fp->fptr = ofs;				/* Set file pointer */
			if (ofs) {
				fp->clust = clmt_clust(fp, ofs - 1);
				dsc = clust2sect(fp->fs, fp->clust);
				if (!dsc) ABORT(fp->fs, FR_INT_ERR);
				dsc += (ofs - 1) / SS(fp->fs) & (fp->fs->csize - 1);
8000840c:	20 19       	sub	r9,1
8000840e:	f3 e4 02 94 	and	r4,r9,r4>>0x9
80008412:	f8 04 00 04 	add	r4,r12,r4
				if (fp->fptr % SS(fp->fs) && dsc != fp->dsect) {	/* Refill sector cache if needed */
80008416:	6e 6a       	ld.w	r10,r7[0x18]
80008418:	08 3a       	cp.w	r10,r4
8000841a:	e0 80 00 db 	breq	800085d0 <f_lseek+0x294>
#if !_FS_TINY
#if !_FS_READONLY
					if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
8000841e:	0f e8       	ld.ub	r8,r7[0x6]
80008420:	e2 18 00 40 	andl	r8,0x40,COH
80008424:	c0 f0       	breq	80008442 <f_lseek+0x106>
						if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
80008426:	30 19       	mov	r9,1
80008428:	ee cb ff d8 	sub	r11,r7,-40
8000842c:	0b 9c       	ld.ub	r12,r5[0x1]
8000842e:	f0 1f 00 6e 	mcall	800085e4 <f_lseek+0x2a8>
80008432:	c0 50       	breq	8000843c <f_lseek+0x100>
							ABORT(fp->fs, FR_DISK_ERR);
80008434:	30 18       	mov	r8,1
80008436:	ae f8       	st.b	r7[0x7],r8
80008438:	30 16       	mov	r6,1
8000843a:	cc b8       	rjmp	800085d0 <f_lseek+0x294>
						fp->flag &= ~FA__DIRTY;
8000843c:	0f e8       	ld.ub	r8,r7[0x6]
8000843e:	a7 c8       	cbr	r8,0x6
80008440:	ae e8       	st.b	r7[0x6],r8
					}
#endif
					if (disk_read(fp->fs->drv, fp->buf, dsc, 1) != RES_OK)	/* Load current sector */
80008442:	6e 08       	ld.w	r8,r7[0x0]
80008444:	30 19       	mov	r9,1
80008446:	08 9a       	mov	r10,r4
80008448:	ee cb ff d8 	sub	r11,r7,-40
8000844c:	11 9c       	ld.ub	r12,r8[0x1]
8000844e:	f0 1f 00 67 	mcall	800085e8 <f_lseek+0x2ac>
						ABORT(fp->fs, FR_DISK_ERR);
80008452:	f9 b8 01 01 	movne	r8,1
80008456:	ef f8 1e 07 	st.bne	r7[0x7],r8
8000845a:	f9 b6 01 01 	movne	r6,1
#endif
					fp->dsect = dsc;
8000845e:	ef f4 0a 06 	st.weq	r7[0x18],r4
80008462:	cb 78       	rjmp	800085d0 <f_lseek+0x294>

	/* Normal Seek */
	{
		if (ofs > fp->fsize					/* In read-only mode, clip offset with the file size */
#if !_FS_READONLY
			 && !(fp->flag & FA_WRITE)
80008464:	6e 34       	ld.w	r4,r7[0xc]
	} else
#endif

	/* Normal Seek */
	{
		if (ofs > fp->fsize					/* In read-only mode, clip offset with the file size */
80008466:	08 35       	cp.w	r5,r4
80008468:	e0 88 00 06 	brls	80008474 <f_lseek+0x138>
#if !_FS_READONLY
			 && !(fp->flag & FA_WRITE)
8000846c:	0f e8       	ld.ub	r8,r7[0x6]
8000846e:	e2 18 00 02 	andl	r8,0x2,COH
80008472:	c0 20       	breq	80008476 <f_lseek+0x13a>
80008474:	0a 94       	mov	r4,r5
#endif
			) ofs = fp->fsize;

		ifptr = fp->fptr;
80008476:	6e 29       	ld.w	r9,r7[0x8]
		fp->fptr = nsect = 0;
80008478:	30 08       	mov	r8,0
8000847a:	8f 28       	st.w	r7[0x8],r8
		if (ofs) {
8000847c:	58 04       	cp.w	r4,0
8000847e:	e0 80 00 a9 	breq	800085d0 <f_lseek+0x294>
			bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
80008482:	6e 08       	ld.w	r8,r7[0x0]
80008484:	11 a5       	ld.ub	r5,r8[0x2]
80008486:	a9 75       	lsl	r5,0x9
			if (ifptr > 0 &&
80008488:	58 09       	cp.w	r9,0
8000848a:	c1 30       	breq	800084b0 <f_lseek+0x174>
				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
8000848c:	20 19       	sub	r9,1

		ifptr = fp->fptr;
		fp->fptr = nsect = 0;
		if (ofs) {
			bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
			if (ifptr > 0 &&
8000848e:	e8 cb 00 01 	sub	r11,r4,1
80008492:	f6 05 0d 0a 	divu	r10,r11,r5
80008496:	14 9b       	mov	r11,r10
80008498:	f2 05 0d 02 	divu	r2,r9,r5
8000849c:	04 3b       	cp.w	r11,r2
8000849e:	c0 93       	brcs	800084b0 <f_lseek+0x174>
				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
				fp->fptr = (ifptr - 1) & ~(bcs - 1);	/* start from the current cluster */
800084a0:	ea 08 11 00 	rsub	r8,r5,0
800084a4:	f1 e9 00 09 	and	r9,r8,r9
800084a8:	8f 29       	st.w	r7[0x8],r9
				ofs -= fp->fptr;
800084aa:	12 14       	sub	r4,r9
				clst = fp->clust;
800084ac:	6e 5c       	ld.w	r12,r7[0x14]

		ifptr = fp->fptr;
		fp->fptr = nsect = 0;
		if (ofs) {
			bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
			if (ifptr > 0 &&
800084ae:	c1 68       	rjmp	800084da <f_lseek+0x19e>
				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
				fp->fptr = (ifptr - 1) & ~(bcs - 1);	/* start from the current cluster */
				ofs -= fp->fptr;
				clst = fp->clust;
			} else {									/* When seek to back cluster, */
				clst = fp->sclust;						/* start from the first cluster */
800084b0:	6e 4c       	ld.w	r12,r7[0x10]
#if !_FS_READONLY
				if (clst == 0) {						/* If no cluster chain, create a new chain */
800084b2:	58 0c       	cp.w	r12,0
800084b4:	c1 21       	brne	800084d8 <f_lseek+0x19c>
					clst = create_chain(fp->fs, 0);
800084b6:	30 0b       	mov	r11,0
800084b8:	10 9c       	mov	r12,r8
800084ba:	f0 1f 00 4d 	mcall	800085ec <f_lseek+0x2b0>
					if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
800084be:	58 1c       	cp.w	r12,1
800084c0:	c0 51       	brne	800084ca <f_lseek+0x18e>
800084c2:	30 28       	mov	r8,2
800084c4:	ae f8       	st.b	r7[0x7],r8
800084c6:	30 26       	mov	r6,2
800084c8:	c8 48       	rjmp	800085d0 <f_lseek+0x294>
					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
800084ca:	5b fc       	cp.w	r12,-1
800084cc:	c0 51       	brne	800084d6 <f_lseek+0x19a>
800084ce:	30 18       	mov	r8,1
800084d0:	ae f8       	st.b	r7[0x7],r8
800084d2:	30 16       	mov	r6,1
800084d4:	c7 e8       	rjmp	800085d0 <f_lseek+0x294>
					fp->sclust = clst;
800084d6:	8f 4c       	st.w	r7[0x10],r12
				}
#endif
				fp->clust = clst;
800084d8:	8f 5c       	st.w	r7[0x14],r12
			}
			if (clst != 0) {
800084da:	58 0c       	cp.w	r12,0
800084dc:	c4 80       	breq	8000856c <f_lseek+0x230>
				while (ofs > bcs) {						/* Cluster following loop */
800084de:	0a 34       	cp.w	r4,r5
800084e0:	e0 88 00 32 	brls	80008544 <f_lseek+0x208>
#if _FS_MINIMIZE <= 2
/*-----------------------------------------------------------------------*/
/* Seek File R/W Pointer                                                 */
/*-----------------------------------------------------------------------*/

FRESULT f_lseek (
800084e4:	ea 03 11 00 	rsub	r3,r5,0
800084e8:	0a 14       	sub	r4,r5
				fp->clust = clst;
			}
			if (clst != 0) {
				while (ofs > bcs) {						/* Cluster following loop */
#if !_FS_READONLY
					if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
800084ea:	0f e8       	ld.ub	r8,r7[0x6]
800084ec:	e2 18 00 02 	andl	r8,0x2,COH
800084f0:	c0 70       	breq	800084fe <f_lseek+0x1c2>
						clst = create_chain(fp->fs, clst);	/* Force stretch if in write mode */
800084f2:	18 9b       	mov	r11,r12
800084f4:	6e 0c       	ld.w	r12,r7[0x0]
800084f6:	f0 1f 00 3e 	mcall	800085ec <f_lseek+0x2b0>
						if (clst == 0) {				/* When disk gets full, clip file size */
800084fa:	c0 61       	brne	80008506 <f_lseek+0x1ca>
800084fc:	c2 38       	rjmp	80008542 <f_lseek+0x206>
							ofs = bcs; break;
						}
					} else
#endif
						clst = get_fat(fp->fs, clst);	/* Follow cluster chain if not in write mode */
800084fe:	18 9b       	mov	r11,r12
80008500:	6e 0c       	ld.w	r12,r7[0x0]
80008502:	f0 1f 00 36 	mcall	800085d8 <f_lseek+0x29c>
					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
80008506:	5b fc       	cp.w	r12,-1
80008508:	c0 51       	brne	80008512 <f_lseek+0x1d6>
8000850a:	30 18       	mov	r8,1
8000850c:	ae f8       	st.b	r7[0x7],r8
8000850e:	30 16       	mov	r6,1
80008510:	c6 08       	rjmp	800085d0 <f_lseek+0x294>
					if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
80008512:	58 1c       	cp.w	r12,1
80008514:	e0 88 00 06 	brls	80008520 <f_lseek+0x1e4>
80008518:	6e 08       	ld.w	r8,r7[0x0]
8000851a:	70 58       	ld.w	r8,r8[0x14]
8000851c:	10 3c       	cp.w	r12,r8
8000851e:	c0 53       	brcs	80008528 <f_lseek+0x1ec>
80008520:	30 28       	mov	r8,2
80008522:	ae f8       	st.b	r7[0x7],r8
80008524:	30 26       	mov	r6,2
80008526:	c5 58       	rjmp	800085d0 <f_lseek+0x294>
					fp->clust = clst;
80008528:	8f 5c       	st.w	r7[0x14],r12
					fp->fptr += bcs;
8000852a:	6e 28       	ld.w	r8,r7[0x8]
8000852c:	0a 08       	add	r8,r5
8000852e:	8f 28       	st.w	r7[0x8],r8
80008530:	e8 03 00 08 	add	r8,r4,r3
				}
#endif
				fp->clust = clst;
			}
			if (clst != 0) {
				while (ofs > bcs) {						/* Cluster following loop */
80008534:	f0 05 00 09 	add	r9,r8,r5
80008538:	0a 39       	cp.w	r9,r5
8000853a:	e0 88 00 05 	brls	80008544 <f_lseek+0x208>
8000853e:	10 94       	mov	r4,r8
80008540:	cd 5b       	rjmp	800084ea <f_lseek+0x1ae>
80008542:	0a 94       	mov	r4,r5
					if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
					fp->clust = clst;
					fp->fptr += bcs;
					ofs -= bcs;
				}
				fp->fptr += ofs;
80008544:	6e 28       	ld.w	r8,r7[0x8]
80008546:	08 08       	add	r8,r4
80008548:	8f 28       	st.w	r7[0x8],r8
				if (ofs % SS(fp->fs)) {
8000854a:	f1 d4 c0 09 	bfextu	r8,r4,0x0,0x9
8000854e:	c0 f0       	breq	8000856c <f_lseek+0x230>
					nsect = clust2sect(fp->fs, clst);	/* Current sector */
80008550:	18 9b       	mov	r11,r12
80008552:	6e 0c       	ld.w	r12,r7[0x0]
80008554:	f0 1f 00 23 	mcall	800085e0 <f_lseek+0x2a4>
					if (!nsect) ABORT(fp->fs, FR_INT_ERR);
80008558:	c0 51       	brne	80008562 <f_lseek+0x226>
8000855a:	30 28       	mov	r8,2
8000855c:	ae f8       	st.b	r7[0x7],r8
8000855e:	30 26       	mov	r6,2
80008560:	c3 88       	rjmp	800085d0 <f_lseek+0x294>
					nsect += ofs / SS(fp->fs);
80008562:	e8 05 16 09 	lsr	r5,r4,0x9
80008566:	f8 05 00 05 	add	r5,r12,r5
8000856a:	c0 28       	rjmp	8000856e <f_lseek+0x232>
8000856c:	30 05       	mov	r5,0
				}
			}
		}
		if (fp->fptr % SS(fp->fs) && nsect != fp->dsect) {	/* Fill sector cache if needed */
8000856e:	6e 28       	ld.w	r8,r7[0x8]
80008570:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
80008574:	c2 50       	breq	800085be <f_lseek+0x282>
80008576:	6e 6a       	ld.w	r10,r7[0x18]
80008578:	0a 3a       	cp.w	r10,r5
8000857a:	c2 20       	breq	800085be <f_lseek+0x282>
#if !_FS_TINY
#if !_FS_READONLY
			if (fp->flag & FA__DIRTY) {			/* Write-back dirty sector cache */
8000857c:	0f e8       	ld.ub	r8,r7[0x6]
8000857e:	e2 18 00 40 	andl	r8,0x40,COH
80008582:	c1 00       	breq	800085a2 <f_lseek+0x266>
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
80008584:	6e 08       	ld.w	r8,r7[0x0]
80008586:	30 19       	mov	r9,1
80008588:	ee cb ff d8 	sub	r11,r7,-40
8000858c:	11 9c       	ld.ub	r12,r8[0x1]
8000858e:	f0 1f 00 16 	mcall	800085e4 <f_lseek+0x2a8>
80008592:	c0 50       	breq	8000859c <f_lseek+0x260>
					ABORT(fp->fs, FR_DISK_ERR);
80008594:	30 18       	mov	r8,1
80008596:	ae f8       	st.b	r7[0x7],r8
80008598:	30 16       	mov	r6,1
8000859a:	c1 b8       	rjmp	800085d0 <f_lseek+0x294>
				fp->flag &= ~FA__DIRTY;
8000859c:	0f e8       	ld.ub	r8,r7[0x6]
8000859e:	a7 c8       	cbr	r8,0x6
800085a0:	ae e8       	st.b	r7[0x6],r8
			}
#endif
			if (disk_read(fp->fs->drv, fp->buf, nsect, 1) != RES_OK)	/* Fill sector cache */
800085a2:	6e 08       	ld.w	r8,r7[0x0]
800085a4:	30 19       	mov	r9,1
800085a6:	0a 9a       	mov	r10,r5
800085a8:	ee cb ff d8 	sub	r11,r7,-40
800085ac:	11 9c       	ld.ub	r12,r8[0x1]
800085ae:	f0 1f 00 0f 	mcall	800085e8 <f_lseek+0x2ac>
800085b2:	c0 50       	breq	800085bc <f_lseek+0x280>
				ABORT(fp->fs, FR_DISK_ERR);
800085b4:	30 18       	mov	r8,1
800085b6:	ae f8       	st.b	r7[0x7],r8
800085b8:	30 16       	mov	r6,1
800085ba:	c0 b8       	rjmp	800085d0 <f_lseek+0x294>
#endif
			fp->dsect = nsect;
800085bc:	8f 65       	st.w	r7[0x18],r5
		}
#if !_FS_READONLY
		if (fp->fptr > fp->fsize) {			/* Set file change flag if the file size is extended */
800085be:	6e 28       	ld.w	r8,r7[0x8]
800085c0:	6e 39       	ld.w	r9,r7[0xc]
800085c2:	12 38       	cp.w	r8,r9
800085c4:	e0 88 00 06 	brls	800085d0 <f_lseek+0x294>
			fp->fsize = fp->fptr;
800085c8:	8f 38       	st.w	r7[0xc],r8
			fp->flag |= FA__WRITTEN;
800085ca:	0f e8       	ld.ub	r8,r7[0x6]
800085cc:	a5 b8       	sbr	r8,0x5
800085ce:	ae e8       	st.b	r7[0x6],r8
		}
#endif
	}

	LEAVE_FF(fp->fs, res);
}
800085d0:	0c 9c       	mov	r12,r6
800085d2:	d8 32       	popm	r0-r7,pc
800085d4:	80 00       	ld.sh	r0,r0[0x0]
800085d6:	6c 1c       	ld.w	r12,r6[0x4]
800085d8:	80 00       	ld.sh	r0,r0[0x0]
800085da:	73 78       	ld.w	r8,r9[0x5c]
800085dc:	80 00       	ld.sh	r0,r0[0x0]
800085de:	63 1c       	ld.w	r12,r1[0x44]
800085e0:	80 00       	ld.sh	r0,r0[0x0]
800085e2:	63 04       	ld.w	r4,r1[0x40]
800085e4:	80 00       	ld.sh	r0,r0[0x0]
800085e6:	62 90       	ld.w	r0,r1[0x24]
800085e8:	80 00       	ld.sh	r0,r0[0x0]
800085ea:	62 ac       	ld.w	r12,r1[0x28]
800085ec:	80 00       	ld.sh	r0,r0[0x0]
800085ee:	75 10       	ld.w	r0,r10[0x44]

800085f0 <f_write>:
	FIL* fp,			/* Pointer to the file object */
	const void *buff,	/* Pointer to the data to be written */
	UINT btw,			/* Number of bytes to write */
	UINT* bw			/* Pointer to number of bytes written */
)
{
800085f0:	d4 31       	pushm	r0-r7,lr
800085f2:	20 3d       	sub	sp,12
800085f4:	18 97       	mov	r7,r12
800085f6:	16 93       	mov	r3,r11
800085f8:	14 96       	mov	r6,r10
800085fa:	12 94       	mov	r4,r9
	UINT wcnt, cc;
	const BYTE *wbuff = (const BYTE*)buff;
	BYTE csect;


	*bw = 0;	/* Clear write byte counter */
800085fc:	30 08       	mov	r8,0
800085fe:	93 08       	st.w	r9[0x0],r8

	res = validate(fp);						/* Check validity */
80008600:	f0 1f 00 6d 	mcall	800087b4 <f_write+0x1c4>
80008604:	18 92       	mov	r2,r12
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
80008606:	e0 81 00 d3 	brne	800087ac <f_write+0x1bc>
	if (fp->err)							/* Check error */
8000860a:	0f f8       	ld.ub	r8,r7[0x7]
8000860c:	58 08       	cp.w	r8,0
8000860e:	c0 30       	breq	80008614 <f_write+0x24>
		LEAVE_FF(fp->fs, (FRESULT)fp->err);
80008610:	10 92       	mov	r2,r8
80008612:	cc d8       	rjmp	800087ac <f_write+0x1bc>
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
80008614:	0f e8       	ld.ub	r8,r7[0x6]
80008616:	e2 18 00 02 	andl	r8,0x2,COH
8000861a:	c0 31       	brne	80008620 <f_write+0x30>
8000861c:	30 72       	mov	r2,7
8000861e:	cc 78       	rjmp	800087ac <f_write+0x1bc>
		LEAVE_FF(fp->fs, FR_DENIED);
	if (fp->fptr + btw < fp->fptr) btw = 0;	/* File size cannot reach 4GB */
80008620:	6e 28       	ld.w	r8,r7[0x8]
80008622:	ec 08 00 09 	add	r9,r6,r8
80008626:	12 38       	cp.w	r8,r9
80008628:	e0 8b 00 ba 	brhi	8000879c <f_write+0x1ac>

	for ( ;  btw;							/* Repeat until all data written */
8000862c:	58 06       	cp.w	r6,0
8000862e:	e0 80 00 b7 	breq	8000879c <f_write+0x1ac>
#if _FS_TINY
			if (fp->fs->winsect == fp->dsect && sync_window(fp->fs))	/* Write-back sector cache */
				ABORT(fp->fs, FR_DISK_ERR);
#else
			if (fp->flag & FA__DIRTY) {		/* Write-back sector cache */
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
80008632:	ee c8 ff d8 	sub	r8,r7,-40
80008636:	50 18       	stdsp	sp[0x4],r8
					mem_cpy(fp->fs->win, wbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), SS(fp->fs));
					fp->fs->wflag = 0;
				}
#else
				if (fp->dsect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
					mem_cpy(fp->buf, wbuff + ((fp->dsect - sect) * SS(fp->fs)), SS(fp->fs));
80008638:	50 08       	stdsp	sp[0x0],r8
			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
			if (!csect) {					/* On the cluster boundary? */
				if (fp->fptr == 0) {		/* On the top of the file? */
					clst = fp->sclust;		/* Follow from the origin */
					if (clst == 0)			/* When no cluster is allocated, */
						clst = create_chain(fp->fs, 0);	/* Create a new cluster chain */
8000863a:	50 2c       	stdsp	sp[0x8],r12
8000863c:	0c 95       	mov	r5,r6
		LEAVE_FF(fp->fs, FR_DENIED);
	if (fp->fptr + btw < fp->fptr) btw = 0;	/* File size cannot reach 4GB */

	for ( ;  btw;							/* Repeat until all data written */
		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
		if ((fp->fptr % SS(fp->fs)) == 0) {	/* On the sector boundary? */
8000863e:	6e 2b       	ld.w	r11,r7[0x8]
80008640:	f1 db c0 09 	bfextu	r8,r11,0x0,0x9
80008644:	e0 81 00 8c 	brne	8000875c <f_write+0x16c>
			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
80008648:	6e 08       	ld.w	r8,r7[0x0]
8000864a:	11 a6       	ld.ub	r6,r8[0x2]
8000864c:	20 16       	sub	r6,1
8000864e:	ed eb 02 96 	and	r6,r6,r11>>0x9
80008652:	5c 56       	castu.b	r6
			if (!csect) {					/* On the cluster boundary? */
80008654:	c2 91       	brne	800086a6 <f_write+0xb6>
				if (fp->fptr == 0) {		/* On the top of the file? */
80008656:	58 0b       	cp.w	r11,0
80008658:	c0 81       	brne	80008668 <f_write+0x78>
					clst = fp->sclust;		/* Follow from the origin */
8000865a:	6e 4c       	ld.w	r12,r7[0x10]
					if (clst == 0)			/* When no cluster is allocated, */
8000865c:	58 0c       	cp.w	r12,0
8000865e:	c1 31       	brne	80008684 <f_write+0x94>
						clst = create_chain(fp->fs, 0);	/* Create a new cluster chain */
80008660:	10 9c       	mov	r12,r8
80008662:	f0 1f 00 56 	mcall	800087b8 <f_write+0x1c8>
80008666:	c0 c8       	rjmp	8000867e <f_write+0x8e>
				} else {					/* Middle or end of the file */
#if _USE_FASTSEEK
					if (fp->cltbl)
80008668:	6e 99       	ld.w	r9,r7[0x24]
8000866a:	58 09       	cp.w	r9,0
8000866c:	c0 50       	breq	80008676 <f_write+0x86>
						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
8000866e:	0e 9c       	mov	r12,r7
80008670:	f0 1f 00 53 	mcall	800087bc <f_write+0x1cc>
80008674:	c0 58       	rjmp	8000867e <f_write+0x8e>
					else
#endif
						clst = create_chain(fp->fs, fp->clust);	/* Follow or stretch cluster chain on the FAT */
80008676:	6e 5b       	ld.w	r11,r7[0x14]
80008678:	10 9c       	mov	r12,r8
8000867a:	f0 1f 00 50 	mcall	800087b8 <f_write+0x1c8>
				}
				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
8000867e:	58 0c       	cp.w	r12,0
80008680:	e0 80 00 8b 	breq	80008796 <f_write+0x1a6>
				if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
80008684:	58 1c       	cp.w	r12,1
80008686:	c0 51       	brne	80008690 <f_write+0xa0>
80008688:	30 28       	mov	r8,2
8000868a:	ae f8       	st.b	r7[0x7],r8
8000868c:	30 22       	mov	r2,2
8000868e:	c8 f8       	rjmp	800087ac <f_write+0x1bc>
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
80008690:	5b fc       	cp.w	r12,-1
80008692:	c0 51       	brne	8000869c <f_write+0xac>
80008694:	30 18       	mov	r8,1
80008696:	ae f8       	st.b	r7[0x7],r8
80008698:	30 12       	mov	r2,1
8000869a:	c8 98       	rjmp	800087ac <f_write+0x1bc>
				fp->clust = clst;			/* Update current cluster */
8000869c:	8f 5c       	st.w	r7[0x14],r12
				if (fp->sclust == 0) fp->sclust = clst;	/* Set start cluster if the first write */
8000869e:	6e 48       	ld.w	r8,r7[0x10]
800086a0:	58 08       	cp.w	r8,0
800086a2:	ef fc 0a 04 	st.weq	r7[0x10],r12
			}
#if _FS_TINY
			if (fp->fs->winsect == fp->dsect && sync_window(fp->fs))	/* Write-back sector cache */
				ABORT(fp->fs, FR_DISK_ERR);
#else
			if (fp->flag & FA__DIRTY) {		/* Write-back sector cache */
800086a6:	0f e8       	ld.ub	r8,r7[0x6]
800086a8:	e2 18 00 40 	andl	r8,0x40,COH
800086ac:	c1 00       	breq	800086cc <f_write+0xdc>
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
800086ae:	6e 08       	ld.w	r8,r7[0x0]
800086b0:	30 19       	mov	r9,1
800086b2:	6e 6a       	ld.w	r10,r7[0x18]
800086b4:	40 1b       	lddsp	r11,sp[0x4]
800086b6:	11 9c       	ld.ub	r12,r8[0x1]
800086b8:	f0 1f 00 42 	mcall	800087c0 <f_write+0x1d0>
800086bc:	c0 50       	breq	800086c6 <f_write+0xd6>
					ABORT(fp->fs, FR_DISK_ERR);
800086be:	30 18       	mov	r8,1
800086c0:	ae f8       	st.b	r7[0x7],r8
800086c2:	30 12       	mov	r2,1
800086c4:	c7 48       	rjmp	800087ac <f_write+0x1bc>
				fp->flag &= ~FA__DIRTY;
800086c6:	0f e8       	ld.ub	r8,r7[0x6]
800086c8:	a7 c8       	cbr	r8,0x6
800086ca:	ae e8       	st.b	r7[0x6],r8
			}
#endif
			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
800086cc:	6e 01       	ld.w	r1,r7[0x0]
800086ce:	6e 5b       	ld.w	r11,r7[0x14]
800086d0:	02 9c       	mov	r12,r1
800086d2:	f0 1f 00 3d 	mcall	800087c4 <f_write+0x1d4>
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
800086d6:	c0 51       	brne	800086e0 <f_write+0xf0>
800086d8:	30 28       	mov	r8,2
800086da:	ae f8       	st.b	r7[0x7],r8
800086dc:	30 22       	mov	r2,2
800086de:	c6 78       	rjmp	800087ac <f_write+0x1bc>
			sect += csect;
800086e0:	f8 06 00 00 	add	r0,r12,r6
			cc = btw / SS(fp->fs);			/* When remaining bytes >= sector size, */
800086e4:	ea 02 16 09 	lsr	r2,r5,0x9
			if (cc) {						/* Write maximum contiguous sectors directly */
800086e8:	c2 70       	breq	80008736 <f_write+0x146>
				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
800086ea:	03 a9       	ld.ub	r9,r1[0x2]
800086ec:	e4 06 00 08 	add	r8,r2,r6
					cc = fp->fs->csize - csect;
800086f0:	12 38       	cp.w	r8,r9
800086f2:	f3 d6 eb 12 	subhi	r2,r9,r6
				if (disk_write(fp->fs->drv, wbuff, sect, cc) != RES_OK)
800086f6:	04 99       	mov	r9,r2
800086f8:	00 9a       	mov	r10,r0
800086fa:	06 9b       	mov	r11,r3
800086fc:	03 9c       	ld.ub	r12,r1[0x1]
800086fe:	f0 1f 00 31 	mcall	800087c0 <f_write+0x1d0>
80008702:	c0 50       	breq	8000870c <f_write+0x11c>
					ABORT(fp->fs, FR_DISK_ERR);
80008704:	30 18       	mov	r8,1
80008706:	ae f8       	st.b	r7[0x7],r8
80008708:	30 12       	mov	r2,1
8000870a:	c5 18       	rjmp	800087ac <f_write+0x1bc>
				if (fp->fs->winsect - sect < cc) {	/* Refill sector cache if it gets invalidated by the direct write */
					mem_cpy(fp->fs->win, wbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), SS(fp->fs));
					fp->fs->wflag = 0;
				}
#else
				if (fp->dsect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
8000870c:	6e 6b       	ld.w	r11,r7[0x18]
8000870e:	f6 00 01 00 	sub	r0,r11,r0
80008712:	00 32       	cp.w	r2,r0
80008714:	e0 88 00 0e 	brls	80008730 <f_write+0x140>
					mem_cpy(fp->buf, wbuff + ((fp->dsect - sect) * SS(fp->fs)), SS(fp->fs));
80008718:	e0 0b 15 09 	lsl	r11,r0,0x9
8000871c:	e0 6a 02 00 	mov	r10,512
80008720:	e6 0b 00 0b 	add	r11,r3,r11
80008724:	40 0c       	lddsp	r12,sp[0x0]
80008726:	f0 1f 00 29 	mcall	800087c8 <f_write+0x1d8>
					fp->flag &= ~FA__DIRTY;
8000872a:	0f e8       	ld.ub	r8,r7[0x6]
8000872c:	a7 c8       	cbr	r8,0x6
8000872e:	ae e8       	st.b	r7[0x6],r8
				}
#endif
#endif
				wcnt = SS(fp->fs) * cc;		/* Number of bytes transferred */
80008730:	e4 06 15 09 	lsl	r6,r2,0x9
				continue;
80008734:	c2 78       	rjmp	80008782 <f_write+0x192>
			if (fp->fptr >= fp->fsize) {	/* Avoid silly cache filling at growing edge */
				if (sync_window(fp->fs)) ABORT(fp->fs, FR_DISK_ERR);
				fp->fs->winsect = sect;
			}
#else
			if (fp->dsect != sect) {		/* Fill sector cache with file data */
80008736:	6e 68       	ld.w	r8,r7[0x18]
80008738:	00 38       	cp.w	r8,r0
8000873a:	c1 00       	breq	8000875a <f_write+0x16a>
				if (fp->fptr < fp->fsize &&
8000873c:	6e 29       	ld.w	r9,r7[0x8]
8000873e:	6e 38       	ld.w	r8,r7[0xc]
80008740:	10 39       	cp.w	r9,r8
80008742:	c0 c2       	brcc	8000875a <f_write+0x16a>
					disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)
80008744:	30 19       	mov	r9,1
80008746:	00 9a       	mov	r10,r0
80008748:	40 1b       	lddsp	r11,sp[0x4]
8000874a:	03 9c       	ld.ub	r12,r1[0x1]
8000874c:	f0 1f 00 20 	mcall	800087cc <f_write+0x1dc>
				if (sync_window(fp->fs)) ABORT(fp->fs, FR_DISK_ERR);
				fp->fs->winsect = sect;
			}
#else
			if (fp->dsect != sect) {		/* Fill sector cache with file data */
				if (fp->fptr < fp->fsize &&
80008750:	c0 50       	breq	8000875a <f_write+0x16a>
					disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)
						ABORT(fp->fs, FR_DISK_ERR);
80008752:	30 18       	mov	r8,1
80008754:	ae f8       	st.b	r7[0x7],r8
80008756:	30 12       	mov	r2,1
80008758:	c2 a8       	rjmp	800087ac <f_write+0x1bc>
			}
#endif
			fp->dsect = sect;
8000875a:	8f 60       	st.w	r7[0x18],r0
		}
		wcnt = SS(fp->fs) - ((UINT)fp->fptr % SS(fp->fs));/* Put partial sector into file I/O buffer */
8000875c:	6e 2c       	ld.w	r12,r7[0x8]
8000875e:	f9 dc c0 09 	bfextu	r12,r12,0x0,0x9
80008762:	e0 66 02 00 	mov	r6,512
80008766:	18 16       	sub	r6,r12
80008768:	0c 35       	cp.w	r5,r6
8000876a:	ea 06 17 80 	movls	r6,r5
		if (move_window(fp->fs, fp->dsect) != FR_OK)	/* Move sector window */
			ABORT(fp->fs, FR_DISK_ERR);
		mem_cpy(&fp->fs->win[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
		fp->fs->wflag = 1;
#else
		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
8000876e:	0c 9a       	mov	r10,r6
80008770:	06 9b       	mov	r11,r3
80008772:	40 08       	lddsp	r8,sp[0x0]
80008774:	f0 0c 00 0c 	add	r12,r8,r12
80008778:	f0 1f 00 14 	mcall	800087c8 <f_write+0x1d8>
		fp->flag |= FA__DIRTY;
8000877c:	0f e8       	ld.ub	r8,r7[0x6]
8000877e:	a7 a8       	sbr	r8,0x6
80008780:	ae e8       	st.b	r7[0x6],r8
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
	if (fp->fptr + btw < fp->fptr) btw = 0;	/* File size cannot reach 4GB */

	for ( ;  btw;							/* Repeat until all data written */
		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
80008782:	6e 28       	ld.w	r8,r7[0x8]
80008784:	0c 08       	add	r8,r6
80008786:	8f 28       	st.w	r7[0x8],r8
80008788:	68 08       	ld.w	r8,r4[0x0]
8000878a:	0c 08       	add	r8,r6
8000878c:	89 08       	st.w	r4[0x0],r8
8000878e:	0c 15       	sub	r5,r6
		LEAVE_FF(fp->fs, (FRESULT)fp->err);
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
	if (fp->fptr + btw < fp->fptr) btw = 0;	/* File size cannot reach 4GB */

	for ( ;  btw;							/* Repeat until all data written */
80008790:	c0 50       	breq	8000879a <f_write+0x1aa>
		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
80008792:	0c 03       	add	r3,r6
80008794:	c5 5b       	rjmp	8000863e <f_write+0x4e>
80008796:	40 22       	lddsp	r2,sp[0x8]
80008798:	c0 28       	rjmp	8000879c <f_write+0x1ac>
8000879a:	40 22       	lddsp	r2,sp[0x8]
		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
		fp->flag |= FA__DIRTY;
#endif
	}

	if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;	/* Update file size if needed */
8000879c:	6e 28       	ld.w	r8,r7[0x8]
8000879e:	6e 39       	ld.w	r9,r7[0xc]
800087a0:	12 38       	cp.w	r8,r9
800087a2:	ef f8 ba 03 	st.whi	r7[0xc],r8
	fp->flag |= FA__WRITTEN;						/* Set file change flag */
800087a6:	0f e8       	ld.ub	r8,r7[0x6]
800087a8:	a5 b8       	sbr	r8,0x5
800087aa:	ae e8       	st.b	r7[0x6],r8

	LEAVE_FF(fp->fs, FR_OK);
}
800087ac:	04 9c       	mov	r12,r2
800087ae:	2f dd       	sub	sp,-12
800087b0:	d8 32       	popm	r0-r7,pc
800087b2:	00 00       	add	r0,r0
800087b4:	80 00       	ld.sh	r0,r0[0x0]
800087b6:	6c 1c       	ld.w	r12,r6[0x4]
800087b8:	80 00       	ld.sh	r0,r0[0x0]
800087ba:	75 10       	ld.w	r0,r10[0x44]
800087bc:	80 00       	ld.sh	r0,r0[0x0]
800087be:	63 1c       	ld.w	r12,r1[0x44]
800087c0:	80 00       	ld.sh	r0,r0[0x0]
800087c2:	62 90       	ld.w	r0,r1[0x24]
800087c4:	80 00       	ld.sh	r0,r0[0x0]
800087c6:	63 04       	ld.w	r4,r1[0x40]
800087c8:	80 00       	ld.sh	r0,r0[0x0]
800087ca:	62 c8       	ld.w	r8,r1[0x30]
800087cc:	80 00       	ld.sh	r0,r0[0x0]
800087ce:	62 ac       	ld.w	r12,r1[0x28]

800087d0 <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
800087d0:	f8 c8 ff f8 	sub	r8,r12,-8
800087d4:	99 18       	st.w	r12[0x4],r8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
800087d6:	3f f9       	mov	r9,-1
800087d8:	99 29       	st.w	r12[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
800087da:	99 38       	st.w	r12[0xc],r8
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
800087dc:	99 48       	st.w	r12[0x10],r8

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
800087de:	30 08       	mov	r8,0
800087e0:	99 08       	st.w	r12[0x0],r8
}
800087e2:	5e fc       	retal	r12

800087e4 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
800087e4:	30 08       	mov	r8,0
800087e6:	99 48       	st.w	r12[0x10],r8
}
800087e8:	5e fc       	retal	r12

800087ea <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
800087ea:	78 18       	ld.w	r8,r12[0x4]

	pxNewListItem->pxNext = pxIndex->pxNext;
800087ec:	70 19       	ld.w	r9,r8[0x4]
800087ee:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
800087f0:	78 19       	ld.w	r9,r12[0x4]
800087f2:	97 29       	st.w	r11[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
800087f4:	70 19       	ld.w	r9,r8[0x4]
800087f6:	93 2b       	st.w	r9[0x8],r11
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
800087f8:	91 1b       	st.w	r8[0x4],r11
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
800087fa:	99 1b       	st.w	r12[0x4],r11

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
800087fc:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
800087fe:	78 08       	ld.w	r8,r12[0x0]
80008800:	2f f8       	sub	r8,-1
80008802:	99 08       	st.w	r12[0x0],r8
}
80008804:	5e fc       	retal	r12

80008806 <vListInsert>:
{
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
80008806:	76 0a       	ld.w	r10,r11[0x0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
80008808:	5b fa       	cp.w	r10,-1
8000880a:	c0 31       	brne	80008810 <vListInsert+0xa>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
8000880c:	78 48       	ld.w	r8,r12[0x10]
8000880e:	c0 c8       	rjmp	80008826 <vListInsert+0x20>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
80008810:	f8 c8 ff f8 	sub	r8,r12,-8
80008814:	70 19       	ld.w	r9,r8[0x4]
80008816:	72 09       	ld.w	r9,r9[0x0]
80008818:	12 3a       	cp.w	r10,r9
8000881a:	c0 63       	brcs	80008826 <vListInsert+0x20>
8000881c:	70 18       	ld.w	r8,r8[0x4]
8000881e:	70 19       	ld.w	r9,r8[0x4]
80008820:	72 09       	ld.w	r9,r9[0x0]
80008822:	12 3a       	cp.w	r10,r9
80008824:	cf c2       	brcc	8000881c <vListInsert+0x16>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
80008826:	70 19       	ld.w	r9,r8[0x4]
80008828:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
8000882a:	93 2b       	st.w	r9[0x8],r11
	pxNewListItem->pxPrevious = pxIterator;
8000882c:	97 28       	st.w	r11[0x8],r8
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
8000882e:	91 1b       	st.w	r8[0x4],r11

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80008830:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80008832:	78 08       	ld.w	r8,r12[0x0]
80008834:	2f f8       	sub	r8,-1
80008836:	99 08       	st.w	r12[0x0],r8
}
80008838:	5e fc       	retal	r12

8000883a <vListRemove>:

void vListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
8000883a:	78 18       	ld.w	r8,r12[0x4]
8000883c:	78 29       	ld.w	r9,r12[0x8]
8000883e:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
80008840:	78 28       	ld.w	r8,r12[0x8]
80008842:	78 19       	ld.w	r9,r12[0x4]
80008844:	91 19       	st.w	r8[0x4],r9

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
80008846:	78 48       	ld.w	r8,r12[0x10]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
80008848:	70 19       	ld.w	r9,r8[0x4]
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
8000884a:	18 39       	cp.w	r9,r12
8000884c:	f9 f9 00 02 	ld.weq	r9,r12[0x8]
80008850:	f1 f9 0a 01 	st.weq	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
80008854:	30 09       	mov	r9,0
80008856:	99 49       	st.w	r12[0x10],r9
	( pxList->uxNumberOfItems )--;
80008858:	70 09       	ld.w	r9,r8[0x0]
8000885a:	20 19       	sub	r9,1
8000885c:	91 09       	st.w	r8[0x0],r9
}
8000885e:	5e fc       	retal	r12

80008860 <pxPortInitialiseStack>:
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x08080808;					/* R8 */
80008860:	e0 68 08 08 	mov	r8,2056
80008864:	ea 18 08 08 	orh	r8,0x808
80008868:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x09090909;					/* R9 */
8000886a:	e0 68 09 09 	mov	r8,2313
8000886e:	ea 18 09 09 	orh	r8,0x909
80008872:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0A0A0A0A;					/* R10 */
80008874:	e0 68 0a 0a 	mov	r8,2570
80008878:	ea 18 0a 0a 	orh	r8,0xa0a
8000887c:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0B0B0B0B;					/* R11 */
8000887e:	e0 68 0b 0b 	mov	r8,2827
80008882:	ea 18 0b 0b 	orh	r8,0xb0b
80008886:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pvParameters;					/* R12 */
80008888:	18 da       	st.w	--r12,r10
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xDEADBEEF;					/* R14/LR */
8000888a:	e0 68 be ef 	mov	r8,48879
8000888e:	ea 18 de ad 	orh	r8,0xdead
80008892:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
80008894:	18 db       	st.w	--r12,r11
	*pxTopOfStack-- = ( portSTACK_TYPE ) portINITIAL_SR;				/* SR */
80008896:	fc 18 00 40 	movh	r8,0x40
8000889a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xFF0000FF;					/* R0 */
8000889c:	e0 68 00 ff 	mov	r8,255
800088a0:	ea 18 ff 00 	orh	r8,0xff00
800088a4:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x01010101;					/* R1 */
800088a6:	e0 68 01 01 	mov	r8,257
800088aa:	ea 18 01 01 	orh	r8,0x101
800088ae:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x02020202;					/* R2 */
800088b0:	e0 68 02 02 	mov	r8,514
800088b4:	ea 18 02 02 	orh	r8,0x202
800088b8:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x03030303;					/* R3 */
800088ba:	e0 68 03 03 	mov	r8,771
800088be:	ea 18 03 03 	orh	r8,0x303
800088c2:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x04040404;					/* R4 */
800088c4:	e0 68 04 04 	mov	r8,1028
800088c8:	ea 18 04 04 	orh	r8,0x404
800088cc:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x05050505;					/* R5 */
800088ce:	e0 68 05 05 	mov	r8,1285
800088d2:	ea 18 05 05 	orh	r8,0x505
800088d6:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x06060606;					/* R6 */
800088d8:	e0 68 06 06 	mov	r8,1542
800088dc:	ea 18 06 06 	orh	r8,0x606
800088e0:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x07070707;					/* R7 */
800088e2:	e0 68 07 07 	mov	r8,1799
800088e6:	ea 18 07 07 	orh	r8,0x707
800088ea:	18 d8       	st.w	--r12,r8
	*pxTopOfStack = ( portSTACK_TYPE ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
800088ec:	30 08       	mov	r8,0
800088ee:	18 d8       	st.w	--r12,r8

	return pxTopOfStack;
}
800088f0:	5e fc       	retal	r12
800088f2:	d7 03       	nop

800088f4 <vPortEnterCritical>:
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
800088f4:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
800088f6:	48 38       	lddpc	r8,80008900 <vPortEnterCritical+0xc>
800088f8:	70 09       	ld.w	r9,r8[0x0]
800088fa:	2f f9       	sub	r9,-1
800088fc:	91 09       	st.w	r8[0x0],r9
}
800088fe:	5e fc       	retal	r12
80008900:	00 00       	add	r0,r0
80008902:	05 30       	ld.ub	r0,r2++

80008904 <xPortStartScheduler>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
80008904:	d4 01       	pushm	lr
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
80008906:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
80008908:	30 0a       	mov	r10,0
8000890a:	14 9b       	mov	r11,r10
8000890c:	49 2c       	lddpc	r12,80008954 <xPortStartScheduler+0x50>
8000890e:	f0 1f 00 13 	mcall	80008958 <xPortStartScheduler+0x54>
/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);//cause!!!
80008912:	e0 68 5d c0 	mov	r8,24000
80008916:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
8000891a:	30 08       	mov	r8,0
8000891c:	e3 b8 00 42 	mtsr	0x108,r8
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Start the first task. */
	portRESTORE_CONTEXT();
80008920:	e0 68 12 24 	mov	r8,4644
80008924:	ea 18 00 00 	orh	r8,0x0
80008928:	70 00       	ld.w	r0,r8[0x0]
8000892a:	60 0d       	ld.w	sp,r0[0x0]
8000892c:	1b 00       	ld.w	r0,sp++
8000892e:	e0 68 05 30 	mov	r8,1328
80008932:	ea 18 00 00 	orh	r8,0x0
80008936:	91 00       	st.w	r8[0x0],r0
80008938:	e3 cd 00 ff 	ldm	sp++,r0-r7
8000893c:	2f ed       	sub	sp,-8
8000893e:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
80008942:	fa f0 ff e0 	ld.w	r0,sp[-32]
80008946:	e3 b0 00 00 	mtsr	0x0,r0
8000894a:	fa f0 ff dc 	ld.w	r0,sp[-36]
8000894e:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
}
80008952:	d8 0a       	popm	pc,r12=0
80008954:	80 00       	ld.sh	r0,r0[0x0]
80008956:	8a 20       	ld.sh	r0,r5[0x4]
80008958:	80 00       	ld.sh	r0,r0[0x0]
8000895a:	59 c4       	cp.w	r4,28

8000895c <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
8000895c:	20 6d       	sub	sp,24
8000895e:	eb cd 00 ff 	pushm	r0-r7
80008962:	fa c7 ff c0 	sub	r7,sp,-64
80008966:	ee f0 ff f8 	ld.w	r0,r7[-8]
8000896a:	ef 40 ff e0 	st.w	r7[-32],r0
8000896e:	ee f0 ff fc 	ld.w	r0,r7[-4]
80008972:	ef 40 ff e4 	st.w	r7[-28],r0
80008976:	eb c7 5f 00 	stm	--r7,r8-r12,lr
8000897a:	e0 68 05 30 	mov	r8,1328
8000897e:	ea 18 00 00 	orh	r8,0x0
80008982:	70 00       	ld.w	r0,r8[0x0]
80008984:	1a d0       	st.w	--sp,r0
80008986:	f0 1f 00 1a 	mcall	800089ec <LABEL_RET_SCALL_263+0x14>
8000898a:	e0 68 12 24 	mov	r8,4644
8000898e:	ea 18 00 00 	orh	r8,0x0
80008992:	70 00       	ld.w	r0,r8[0x0]
80008994:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
80008996:	f0 1f 00 17 	mcall	800089f0 <LABEL_RET_SCALL_263+0x18>
	portRESTORE_CONTEXT_SCALL();
8000899a:	e0 68 12 24 	mov	r8,4644
8000899e:	ea 18 00 00 	orh	r8,0x0
800089a2:	70 00       	ld.w	r0,r8[0x0]
800089a4:	60 0d       	ld.w	sp,r0[0x0]
800089a6:	1b 00       	ld.w	r0,sp++
800089a8:	e0 68 05 30 	mov	r8,1328
800089ac:	ea 18 00 00 	orh	r8,0x0
800089b0:	91 00       	st.w	r8[0x0],r0
800089b2:	fa c7 ff d8 	sub	r7,sp,-40
800089b6:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
800089ba:	ee f0 ff e0 	ld.w	r0,r7[-32]
800089be:	e0 61 05 30 	mov	r1,1328
800089c2:	ea 11 00 00 	orh	r1,0x0
800089c6:	62 02       	ld.w	r2,r1[0x0]
800089c8:	58 02       	cp.w	r2,0
800089ca:	c0 70       	breq	800089d8 <LABEL_RET_SCALL_263>
800089cc:	e4 c2 00 01 	sub	r2,r2,1
800089d0:	83 02       	st.w	r1[0x0],r2
800089d2:	58 02       	cp.w	r2,0
800089d4:	c0 21       	brne	800089d8 <LABEL_RET_SCALL_263>
800089d6:	b1 c0       	cbr	r0,0x10

800089d8 <LABEL_RET_SCALL_263>:
800089d8:	ef 40 ff f8 	st.w	r7[-8],r0
800089dc:	ee f0 ff e4 	ld.w	r0,r7[-28]
800089e0:	ef 40 ff fc 	st.w	r7[-4],r0
800089e4:	e3 cd 00 ff 	ldm	sp++,r0-r7
800089e8:	2f ad       	sub	sp,-24
800089ea:	d6 13       	rets
800089ec:	80 00       	ld.sh	r0,r0[0x0]
800089ee:	88 f4       	ld.uh	r4,r4[0xe]
800089f0:	80 00       	ld.sh	r0,r0[0x0]
800089f2:	90 90       	ld.uh	r0,r8[0x2]

800089f4 <prvClearCcInt>:
		Set_system_register(AVR32_COUNT, 0);
	}

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
800089f4:	e1 b8 00 43 	mfsr	r8,0x10c
800089f8:	e3 b8 00 43 	mtsr	0x10c,r8
	}
800089fc:	5e fc       	retal	r12
800089fe:	d7 03       	nop

80008a00 <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
80008a00:	48 78       	lddpc	r8,80008a1c <vPortExitCritical+0x1c>
80008a02:	70 08       	ld.w	r8,r8[0x0]
80008a04:	58 08       	cp.w	r8,0
80008a06:	5e 0c       	reteq	r12
	{
		ulCriticalNesting--;
80008a08:	48 58       	lddpc	r8,80008a1c <vPortExitCritical+0x1c>
80008a0a:	70 09       	ld.w	r9,r8[0x0]
80008a0c:	20 19       	sub	r9,1
80008a0e:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
80008a10:	70 08       	ld.w	r8,r8[0x0]
80008a12:	58 08       	cp.w	r8,0
80008a14:	5e 1c       	retne	r12
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
80008a16:	d5 03       	csrf	0x10
80008a18:	5e fc       	retal	r12
80008a1a:	00 00       	add	r0,r0
80008a1c:	00 00       	add	r0,r0
80008a1e:	05 30       	ld.ub	r0,r2++

80008a20 <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
80008a20:	eb cd 00 ff 	pushm	r0-r7
80008a24:	e0 68 05 30 	mov	r8,1328
80008a28:	ea 18 00 00 	orh	r8,0x0
80008a2c:	70 00       	ld.w	r0,r8[0x0]
80008a2e:	1a d0       	st.w	--sp,r0
80008a30:	7a 90       	ld.w	r0,sp[0x24]
80008a32:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80008a36:	58 10       	cp.w	r0,1
80008a38:	e0 8b 00 08 	brhi	80008a48 <LABEL_INT_SKIP_SAVE_CONTEXT_237>
80008a3c:	e0 68 12 24 	mov	r8,4644
80008a40:	ea 18 00 00 	orh	r8,0x0
80008a44:	70 00       	ld.w	r0,r8[0x0]
80008a46:	81 0d       	st.w	r0[0x0],sp

80008a48 <LABEL_INT_SKIP_SAVE_CONTEXT_237>:
	#if( configTICK_USE_TC==1 )
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Clear the interrupt flag. */
		prvClearCcInt();
80008a48:	f0 1f 00 12 	mcall	80008a90 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
80008a4c:	f0 1f 00 12 	mcall	80008a94 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
		vTaskIncrementTick();
80008a50:	f0 1f 00 12 	mcall	80008a98 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x1c>
	portEXIT_CRITICAL();
80008a54:	f0 1f 00 12 	mcall	80008a9c <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
80008a58:	7a 90       	ld.w	r0,sp[0x24]
80008a5a:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80008a5e:	58 10       	cp.w	r0,1
80008a60:	e0 8b 00 0e 	brhi	80008a7c <LABEL_INT_SKIP_RESTORE_CONTEXT_254>
80008a64:	f0 1f 00 0c 	mcall	80008a94 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
80008a68:	f0 1f 00 0e 	mcall	80008aa0 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x24>
80008a6c:	f0 1f 00 0c 	mcall	80008a9c <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>
80008a70:	e0 68 12 24 	mov	r8,4644
80008a74:	ea 18 00 00 	orh	r8,0x0
80008a78:	70 00       	ld.w	r0,r8[0x0]
80008a7a:	60 0d       	ld.w	sp,r0[0x0]

80008a7c <LABEL_INT_SKIP_RESTORE_CONTEXT_254>:
80008a7c:	1b 00       	ld.w	r0,sp++
80008a7e:	e0 68 05 30 	mov	r8,1328
80008a82:	ea 18 00 00 	orh	r8,0x0
80008a86:	91 00       	st.w	r8[0x0],r0
80008a88:	e3 cd 00 ff 	ldm	sp++,r0-r7
80008a8c:	d6 03       	rete
80008a8e:	00 00       	add	r0,r0
80008a90:	80 00       	ld.sh	r0,r0[0x0]
80008a92:	89 f4       	st.w	r4[0x3c],r4
80008a94:	80 00       	ld.sh	r0,r0[0x0]
80008a96:	88 f4       	ld.uh	r4,r4[0xe]
80008a98:	80 00       	ld.sh	r0,r0[0x0]
80008a9a:	92 94       	ld.uh	r4,r9[0x2]
80008a9c:	80 00       	ld.sh	r0,r0[0x0]
80008a9e:	8a 00       	ld.sh	r0,r5[0x0]
80008aa0:	80 00       	ld.sh	r0,r0[0x0]
80008aa2:	90 90       	ld.uh	r0,r8[0x2]

80008aa4 <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
80008aa4:	d4 01       	pushm	lr
	vTaskSuspendAll();
80008aa6:	f0 1f 00 02 	mcall	80008aac <__malloc_lock+0x8>
}
80008aaa:	d8 02       	popm	pc
80008aac:	80 00       	ld.sh	r0,r0[0x0]
80008aae:	90 80       	ld.uh	r0,r8[0x0]

80008ab0 <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
80008ab0:	d4 01       	pushm	lr
	xTaskResumeAll();
80008ab2:	f0 1f 00 02 	mcall	80008ab8 <__malloc_unlock+0x8>
}
80008ab6:	d8 02       	popm	pc
80008ab8:	80 00       	ld.sh	r0,r0[0x0]
80008aba:	94 3c       	ld.sh	r12,r10[0x6]

80008abc <_read>:
/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
{
80008abc:	d4 21       	pushm	r4-r7,lr
80008abe:	16 95       	mov	r5,r11
80008ac0:	14 96       	mov	r6,r10
  int nChars = 0;

  if (file != 0)
80008ac2:	58 0c       	cp.w	r12,0
80008ac4:	c0 30       	breq	80008aca <_read+0xe>
80008ac6:	3f f7       	mov	r7,-1
80008ac8:	c1 48       	rjmp	80008af0 <_read+0x34>
    return -1;

  for (; len > 0; --len)
80008aca:	58 0a       	cp.w	r10,0
80008acc:	e0 89 00 04 	brgt	80008ad4 <_read+0x18>
80008ad0:	30 07       	mov	r7,0
80008ad2:	c0 f8       	rjmp	80008af0 <_read+0x34>
80008ad4:	30 07       	mov	r7,0
  {
    int c = usart_getchar(stdio_usart_base);
80008ad6:	48 84       	lddpc	r4,80008af4 <_read+0x38>
80008ad8:	68 0c       	ld.w	r12,r4[0x0]
80008ada:	f0 1f 00 08 	mcall	80008af8 <_read+0x3c>
    if (c < 0)
80008ade:	c0 95       	brlt	80008af0 <_read+0x34>
      break;

    *ptr++ = c;
80008ae0:	ea 07 0b 0c 	st.b	r5[r7],r12
    ++nChars;
80008ae4:	2f f7       	sub	r7,-1

/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
80008ae6:	ec 07 01 08 	sub	r8,r6,r7
  int nChars = 0;

  if (file != 0)
    return -1;

  for (; len > 0; --len)
80008aea:	58 08       	cp.w	r8,0
80008aec:	fe 99 ff f6 	brgt	80008ad8 <_read+0x1c>
    *ptr++ = c;
    ++nChars;
  }

  return nChars;
}
80008af0:	0e 9c       	mov	r12,r7
80008af2:	d8 22       	popm	r4-r7,pc
80008af4:	00 00       	add	r0,r0
80008af6:	46 20       	lddsp	r0,sp[0x188]
80008af8:	80 00       	ld.sh	r0,r0[0x0]
80008afa:	60 b8       	ld.w	r8,r0[0x2c]

80008afc <_write>:
 * 1 and 2 is stdout and stderr which goes to usart
 * 3 is framebuffer
 */
int __attribute__((weak))
_write (int file, char * ptr, int len)
{
80008afc:	d4 21       	pushm	r4-r7,lr
80008afe:	16 95       	mov	r5,r11
80008b00:	14 96       	mov	r6,r10
  int nChars = 0;

  if ( (file != 1)
80008b02:	20 1c       	sub	r12,1
80008b04:	58 2c       	cp.w	r12,2
80008b06:	e0 8b 00 12 	brhi	80008b2a <_write+0x2e>
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80008b0a:	58 0a       	cp.w	r10,0
80008b0c:	c0 31       	brne	80008b12 <_write+0x16>
80008b0e:	30 07       	mov	r7,0
80008b10:	c0 e8       	rjmp	80008b2c <_write+0x30>
80008b12:	30 07       	mov	r7,0
  {
    if (usart_putchar(stdio_usart_base, *ptr++) < 0)
80008b14:	48 74       	lddpc	r4,80008b30 <_write+0x34>
80008b16:	68 0c       	ld.w	r12,r4[0x0]
80008b18:	ea 07 07 0b 	ld.ub	r11,r5[r7]
80008b1c:	f0 1f 00 06 	mcall	80008b34 <_write+0x38>
80008b20:	c0 55       	brlt	80008b2a <_write+0x2e>
    {
      return -1;
    }

    ++nChars;
80008b22:	2f f7       	sub	r7,-1

  if ( (file != 1)
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80008b24:	0e 36       	cp.w	r6,r7
80008b26:	cf 81       	brne	80008b16 <_write+0x1a>
80008b28:	c0 28       	rjmp	80008b2c <_write+0x30>
80008b2a:	3f f7       	mov	r7,-1

    ++nChars;
  }

  return nChars;
}
80008b2c:	0e 9c       	mov	r12,r7
80008b2e:	d8 22       	popm	r4-r7,pc
80008b30:	00 00       	add	r0,r0
80008b32:	46 20       	lddsp	r0,sp[0x188]
80008b34:	80 00       	ld.sh	r0,r0[0x0]
80008b36:	60 68       	ld.w	r8,r0[0x18]

80008b38 <vPortFree>:
	return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
80008b38:	eb cd 40 80 	pushm	r7,lr
80008b3c:	18 97       	mov	r7,r12
	if( pv )
80008b3e:	58 0c       	cp.w	r12,0
80008b40:	c0 80       	breq	80008b50 <vPortFree+0x18>
	{
		vTaskSuspendAll();
80008b42:	f0 1f 00 05 	mcall	80008b54 <vPortFree+0x1c>
		{
			free( pv );
80008b46:	0e 9c       	mov	r12,r7
80008b48:	f0 1f 00 04 	mcall	80008b58 <vPortFree+0x20>
		}
		xTaskResumeAll();
80008b4c:	f0 1f 00 04 	mcall	80008b5c <vPortFree+0x24>
80008b50:	e3 cd 80 80 	ldm	sp++,r7,pc
80008b54:	80 00       	ld.sh	r0,r0[0x0]
80008b56:	90 80       	ld.uh	r0,r8[0x0]
80008b58:	80 00       	ld.sh	r0,r0[0x0]
80008b5a:	9f ec       	st.w	pc[0x38],r12
80008b5c:	80 00       	ld.sh	r0,r0[0x0]
80008b5e:	94 3c       	ld.sh	r12,r10[0x6]

80008b60 <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
80008b60:	eb cd 40 80 	pushm	r7,lr
80008b64:	18 97       	mov	r7,r12
void *pvReturn;

	vTaskSuspendAll();
80008b66:	f0 1f 00 06 	mcall	80008b7c <pvPortMalloc+0x1c>
	{
		pvReturn = malloc( xWantedSize );
80008b6a:	0e 9c       	mov	r12,r7
80008b6c:	f0 1f 00 05 	mcall	80008b80 <pvPortMalloc+0x20>
80008b70:	18 97       	mov	r7,r12
	}
	xTaskResumeAll();
80008b72:	f0 1f 00 05 	mcall	80008b84 <pvPortMalloc+0x24>
		}
	}
	#endif

	return pvReturn;
}
80008b76:	0e 9c       	mov	r12,r7
80008b78:	e3 cd 80 80 	ldm	sp++,r7,pc
80008b7c:	80 00       	ld.sh	r0,r0[0x0]
80008b7e:	90 80       	ld.uh	r0,r8[0x0]
80008b80:	80 00       	ld.sh	r0,r0[0x0]
80008b82:	9f fc       	st.w	pc[0x3c],r12
80008b84:	80 00       	ld.sh	r0,r0[0x0]
80008b86:	94 3c       	ld.sh	r12,r10[0x6]

80008b88 <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
80008b88:	d4 01       	pushm	lr
80008b8a:	16 98       	mov	r8,r11
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
80008b8c:	78 09       	ld.w	r9,r12[0x0]
80008b8e:	58 09       	cp.w	r9,0
80008b90:	c1 10       	breq	80008bb2 <prvCopyDataFromQueue+0x2a>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
80008b92:	78 3a       	ld.w	r10,r12[0xc]
80008b94:	79 09       	ld.w	r9,r12[0x40]
80008b96:	f4 09 00 09 	add	r9,r10,r9
80008b9a:	99 39       	st.w	r12[0xc],r9
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
80008b9c:	78 1a       	ld.w	r10,r12[0x4]
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
80008b9e:	14 39       	cp.w	r9,r10
80008ba0:	f9 f9 20 00 	ld.wcc	r9,r12[0x0]
80008ba4:	f9 f9 2a 03 	st.wcc	r12[0xc],r9
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
80008ba8:	79 0a       	ld.w	r10,r12[0x40]
80008baa:	78 3b       	ld.w	r11,r12[0xc]
80008bac:	10 9c       	mov	r12,r8
80008bae:	f0 1f 00 02 	mcall	80008bb4 <prvCopyDataFromQueue+0x2c>
80008bb2:	d8 02       	popm	pc
80008bb4:	80 00       	ld.sh	r0,r0[0x0]
80008bb6:	a4 6a       	st.h	r2[0xc],r10

80008bb8 <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
80008bb8:	eb cd 40 c0 	pushm	r6-r7,lr
80008bbc:	18 97       	mov	r7,r12
80008bbe:	14 96       	mov	r6,r10
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80008bc0:	78 e8       	ld.w	r8,r12[0x38]
80008bc2:	58 08       	cp.w	r8,0
80008bc4:	c0 31       	brne	80008bca <xQueueReceiveFromISR+0x12>
80008bc6:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
80008bca:	f0 1f 00 0e 	mcall	80008c00 <xQueueReceiveFromISR+0x48>
			--( pxQueue->uxMessagesWaiting );
80008bce:	6e e8       	ld.w	r8,r7[0x38]
80008bd0:	20 18       	sub	r8,1
80008bd2:	8f e8       	st.w	r7[0x38],r8

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
80008bd4:	6f 18       	ld.w	r8,r7[0x44]
80008bd6:	5b f8       	cp.w	r8,-1
80008bd8:	c0 d1       	brne	80008bf2 <xQueueReceiveFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80008bda:	6e 48       	ld.w	r8,r7[0x10]
80008bdc:	58 08       	cp.w	r8,0
80008bde:	c0 f0       	breq	80008bfc <xQueueReceiveFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80008be0:	ee cc ff f0 	sub	r12,r7,-16
80008be4:	f0 1f 00 08 	mcall	80008c04 <xQueueReceiveFromISR+0x4c>
80008be8:	c0 a0       	breq	80008bfc <xQueueReceiveFromISR+0x44>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
80008bea:	30 1c       	mov	r12,1
80008bec:	8d 0c       	st.w	r6[0x0],r12
80008bee:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
80008bf2:	2f f8       	sub	r8,-1
80008bf4:	ef 48 00 44 	st.w	r7[68],r8
80008bf8:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80008bfc:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80008c00:	80 00       	ld.sh	r0,r0[0x0]
80008c02:	8b 88       	st.w	r5[0x20],r8
80008c04:	80 00       	ld.sh	r0,r0[0x0]
80008c06:	92 18       	ld.sh	r8,r9[0x2]

80008c08 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
80008c08:	eb cd 40 c0 	pushm	r6-r7,lr
80008c0c:	18 97       	mov	r7,r12

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
80008c0e:	f0 1f 00 23 	mcall	80008c98 <prvUnlockQueue+0x90>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80008c12:	6f 28       	ld.w	r8,r7[0x48]
80008c14:	58 08       	cp.w	r8,0
80008c16:	e0 8a 00 18 	brle	80008c46 <prvUnlockQueue+0x3e>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80008c1a:	6e 98       	ld.w	r8,r7[0x24]
80008c1c:	58 08       	cp.w	r8,0
80008c1e:	c1 40       	breq	80008c46 <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80008c20:	ee c6 ff dc 	sub	r6,r7,-36
80008c24:	c0 48       	rjmp	80008c2c <prvUnlockQueue+0x24>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80008c26:	6e 98       	ld.w	r8,r7[0x24]
80008c28:	58 08       	cp.w	r8,0
80008c2a:	c0 e0       	breq	80008c46 <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80008c2c:	0c 9c       	mov	r12,r6
80008c2e:	f0 1f 00 1c 	mcall	80008c9c <prvUnlockQueue+0x94>
80008c32:	c0 30       	breq	80008c38 <prvUnlockQueue+0x30>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
80008c34:	f0 1f 00 1b 	mcall	80008ca0 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xTxLock );
80008c38:	6f 28       	ld.w	r8,r7[0x48]
80008c3a:	20 18       	sub	r8,1
80008c3c:	ef 48 00 48 	st.w	r7[72],r8
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80008c40:	58 08       	cp.w	r8,0
80008c42:	fe 99 ff f2 	brgt	80008c26 <prvUnlockQueue+0x1e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
80008c46:	3f f8       	mov	r8,-1
80008c48:	ef 48 00 48 	st.w	r7[72],r8
	}
	taskEXIT_CRITICAL();
80008c4c:	f0 1f 00 16 	mcall	80008ca4 <prvUnlockQueue+0x9c>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
80008c50:	f0 1f 00 12 	mcall	80008c98 <prvUnlockQueue+0x90>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80008c54:	6f 18       	ld.w	r8,r7[0x44]
80008c56:	58 08       	cp.w	r8,0
80008c58:	e0 8a 00 18 	brle	80008c88 <prvUnlockQueue+0x80>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80008c5c:	6e 48       	ld.w	r8,r7[0x10]
80008c5e:	58 08       	cp.w	r8,0
80008c60:	c1 40       	breq	80008c88 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80008c62:	ee c6 ff f0 	sub	r6,r7,-16
80008c66:	c0 48       	rjmp	80008c6e <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80008c68:	6e 48       	ld.w	r8,r7[0x10]
80008c6a:	58 08       	cp.w	r8,0
80008c6c:	c0 e0       	breq	80008c88 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80008c6e:	0c 9c       	mov	r12,r6
80008c70:	f0 1f 00 0b 	mcall	80008c9c <prvUnlockQueue+0x94>
80008c74:	c0 30       	breq	80008c7a <prvUnlockQueue+0x72>
				{
					vTaskMissedYield();
80008c76:	f0 1f 00 0b 	mcall	80008ca0 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xRxLock );
80008c7a:	6f 18       	ld.w	r8,r7[0x44]
80008c7c:	20 18       	sub	r8,1
80008c7e:	ef 48 00 44 	st.w	r7[68],r8
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80008c82:	58 08       	cp.w	r8,0
80008c84:	fe 99 ff f2 	brgt	80008c68 <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
80008c88:	3f f8       	mov	r8,-1
80008c8a:	ef 48 00 44 	st.w	r7[68],r8
	}
	taskEXIT_CRITICAL();
80008c8e:	f0 1f 00 06 	mcall	80008ca4 <prvUnlockQueue+0x9c>
}
80008c92:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80008c96:	00 00       	add	r0,r0
80008c98:	80 00       	ld.sh	r0,r0[0x0]
80008c9a:	88 f4       	ld.uh	r4,r4[0xe]
80008c9c:	80 00       	ld.sh	r0,r0[0x0]
80008c9e:	92 18       	ld.sh	r8,r9[0x2]
80008ca0:	80 00       	ld.sh	r0,r0[0x0]
80008ca2:	91 24       	st.w	r8[0x8],r4
80008ca4:	80 00       	ld.sh	r0,r0[0x0]
80008ca6:	8a 00       	ld.sh	r0,r5[0x0]

80008ca8 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
80008ca8:	d4 31       	pushm	r0-r7,lr
80008caa:	20 5d       	sub	sp,20
80008cac:	18 97       	mov	r7,r12
80008cae:	50 0b       	stdsp	sp[0x0],r11
80008cb0:	50 2a       	stdsp	sp[0x8],r10
80008cb2:	50 19       	stdsp	sp[0x4],r9
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80008cb4:	f8 c2 ff dc 	sub	r2,r12,-36
80008cb8:	30 05       	mov	r5,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80008cba:	fa c4 ff f4 	sub	r4,sp,-12
80008cbe:	30 10       	mov	r0,1

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80008cc0:	0a 91       	mov	r1,r5

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80008cc2:	fa c3 ff f8 	sub	r3,sp,-8
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
80008cc6:	f0 1f 00 3e 	mcall	80008dbc <xQueueGenericReceive+0x114>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80008cca:	6e e8       	ld.w	r8,r7[0x38]
80008ccc:	58 08       	cp.w	r8,0
80008cce:	c2 a0       	breq	80008d22 <xQueueGenericReceive+0x7a>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
80008cd0:	6e 36       	ld.w	r6,r7[0xc]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
80008cd2:	40 0b       	lddsp	r11,sp[0x0]
80008cd4:	0e 9c       	mov	r12,r7
80008cd6:	f0 1f 00 3b 	mcall	80008dc0 <xQueueGenericReceive+0x118>

				if( xJustPeeking == pdFALSE )
80008cda:	40 18       	lddsp	r8,sp[0x4]
80008cdc:	58 08       	cp.w	r8,0
80008cde:	c1 51       	brne	80008d08 <xQueueGenericReceive+0x60>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
80008ce0:	6e e8       	ld.w	r8,r7[0x38]
80008ce2:	20 18       	sub	r8,1
80008ce4:	8f e8       	st.w	r7[0x38],r8

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80008ce6:	6e 08       	ld.w	r8,r7[0x0]
80008ce8:	58 08       	cp.w	r8,0
80008cea:	c0 41       	brne	80008cf2 <xQueueGenericReceive+0x4a>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
80008cec:	f0 1f 00 36 	mcall	80008dc4 <xQueueGenericReceive+0x11c>
80008cf0:	8f 1c       	st.w	r7[0x4],r12
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80008cf2:	6e 48       	ld.w	r8,r7[0x10]
80008cf4:	58 08       	cp.w	r8,0
80008cf6:	c1 20       	breq	80008d1a <xQueueGenericReceive+0x72>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
80008cf8:	ee cc ff f0 	sub	r12,r7,-16
80008cfc:	f0 1f 00 33 	mcall	80008dc8 <xQueueGenericReceive+0x120>
80008d00:	58 1c       	cp.w	r12,1
80008d02:	c0 c1       	brne	80008d1a <xQueueGenericReceive+0x72>
						{
							portYIELD_WITHIN_API();
80008d04:	d7 33       	scall
80008d06:	c0 a8       	rjmp	80008d1a <xQueueGenericReceive+0x72>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
80008d08:	8f 36       	st.w	r7[0xc],r6

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80008d0a:	6e 98       	ld.w	r8,r7[0x24]
80008d0c:	58 08       	cp.w	r8,0
80008d0e:	c0 60       	breq	80008d1a <xQueueGenericReceive+0x72>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80008d10:	04 9c       	mov	r12,r2
80008d12:	f0 1f 00 2e 	mcall	80008dc8 <xQueueGenericReceive+0x120>
80008d16:	c0 20       	breq	80008d1a <xQueueGenericReceive+0x72>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
80008d18:	d7 33       	scall
						}
					}

				}

				taskEXIT_CRITICAL();
80008d1a:	f0 1f 00 2d 	mcall	80008dcc <xQueueGenericReceive+0x124>
80008d1e:	30 1c       	mov	r12,1
				return pdPASS;
80008d20:	c4 c8       	rjmp	80008db8 <xQueueGenericReceive+0x110>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
80008d22:	40 28       	lddsp	r8,sp[0x8]
80008d24:	58 08       	cp.w	r8,0
80008d26:	c0 51       	brne	80008d30 <xQueueGenericReceive+0x88>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80008d28:	f0 1f 00 29 	mcall	80008dcc <xQueueGenericReceive+0x124>
80008d2c:	30 0c       	mov	r12,0
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
80008d2e:	c4 58       	rjmp	80008db8 <xQueueGenericReceive+0x110>
				}
				else if( xEntryTimeSet == pdFALSE )
80008d30:	58 05       	cp.w	r5,0
80008d32:	c0 51       	brne	80008d3c <xQueueGenericReceive+0x94>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80008d34:	08 9c       	mov	r12,r4
80008d36:	f0 1f 00 27 	mcall	80008dd0 <xQueueGenericReceive+0x128>
80008d3a:	00 95       	mov	r5,r0
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80008d3c:	f0 1f 00 24 	mcall	80008dcc <xQueueGenericReceive+0x124>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80008d40:	f0 1f 00 25 	mcall	80008dd4 <xQueueGenericReceive+0x12c>
		prvLockQueue( pxQueue );
80008d44:	f0 1f 00 1e 	mcall	80008dbc <xQueueGenericReceive+0x114>
80008d48:	6f 18       	ld.w	r8,r7[0x44]
80008d4a:	5b f8       	cp.w	r8,-1
80008d4c:	ef f1 0a 11 	st.weq	r7[0x44],r1
80008d50:	6f 28       	ld.w	r8,r7[0x48]
80008d52:	5b f8       	cp.w	r8,-1
80008d54:	ef f1 0a 12 	st.weq	r7[0x48],r1
80008d58:	f0 1f 00 1d 	mcall	80008dcc <xQueueGenericReceive+0x124>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80008d5c:	06 9b       	mov	r11,r3
80008d5e:	08 9c       	mov	r12,r4
80008d60:	f0 1f 00 1e 	mcall	80008dd8 <xQueueGenericReceive+0x130>
80008d64:	c2 41       	brne	80008dac <xQueueGenericReceive+0x104>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80008d66:	f0 1f 00 16 	mcall	80008dbc <xQueueGenericReceive+0x114>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
80008d6a:	6e e6       	ld.w	r6,r7[0x38]
	taskEXIT_CRITICAL();
80008d6c:	f0 1f 00 18 	mcall	80008dcc <xQueueGenericReceive+0x124>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
80008d70:	58 06       	cp.w	r6,0
80008d72:	c1 71       	brne	80008da0 <xQueueGenericReceive+0xf8>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80008d74:	6e 08       	ld.w	r8,r7[0x0]
80008d76:	58 08       	cp.w	r8,0
80008d78:	c0 81       	brne	80008d88 <xQueueGenericReceive+0xe0>
					{
						portENTER_CRITICAL();
80008d7a:	f0 1f 00 11 	mcall	80008dbc <xQueueGenericReceive+0x114>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
80008d7e:	6e 1c       	ld.w	r12,r7[0x4]
80008d80:	f0 1f 00 17 	mcall	80008ddc <xQueueGenericReceive+0x134>
						}
						portEXIT_CRITICAL();
80008d84:	f0 1f 00 12 	mcall	80008dcc <xQueueGenericReceive+0x124>
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80008d88:	40 2b       	lddsp	r11,sp[0x8]
80008d8a:	04 9c       	mov	r12,r2
80008d8c:	f0 1f 00 15 	mcall	80008de0 <xQueueGenericReceive+0x138>
				prvUnlockQueue( pxQueue );
80008d90:	0e 9c       	mov	r12,r7
80008d92:	f0 1f 00 15 	mcall	80008de4 <xQueueGenericReceive+0x13c>
				if( !xTaskResumeAll() )
80008d96:	f0 1f 00 15 	mcall	80008de8 <xQueueGenericReceive+0x140>
80008d9a:	c9 61       	brne	80008cc6 <xQueueGenericReceive+0x1e>
				{
					portYIELD_WITHIN_API();
80008d9c:	d7 33       	scall
80008d9e:	c9 4b       	rjmp	80008cc6 <xQueueGenericReceive+0x1e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80008da0:	0e 9c       	mov	r12,r7
80008da2:	f0 1f 00 11 	mcall	80008de4 <xQueueGenericReceive+0x13c>
				( void ) xTaskResumeAll();
80008da6:	f0 1f 00 11 	mcall	80008de8 <xQueueGenericReceive+0x140>
80008daa:	c8 eb       	rjmp	80008cc6 <xQueueGenericReceive+0x1e>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
80008dac:	0e 9c       	mov	r12,r7
80008dae:	f0 1f 00 0e 	mcall	80008de4 <xQueueGenericReceive+0x13c>
			( void ) xTaskResumeAll();
80008db2:	f0 1f 00 0e 	mcall	80008de8 <xQueueGenericReceive+0x140>
80008db6:	30 0c       	mov	r12,0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
80008db8:	2f bd       	sub	sp,-20
80008dba:	d8 32       	popm	r0-r7,pc
80008dbc:	80 00       	ld.sh	r0,r0[0x0]
80008dbe:	88 f4       	ld.uh	r4,r4[0xe]
80008dc0:	80 00       	ld.sh	r0,r0[0x0]
80008dc2:	8b 88       	st.w	r5[0x20],r8
80008dc4:	80 00       	ld.sh	r0,r0[0x0]
80008dc6:	91 30       	st.w	r8[0xc],r0
80008dc8:	80 00       	ld.sh	r0,r0[0x0]
80008dca:	92 18       	ld.sh	r8,r9[0x2]
80008dcc:	80 00       	ld.sh	r0,r0[0x0]
80008dce:	8a 00       	ld.sh	r0,r5[0x0]
80008dd0:	80 00       	ld.sh	r0,r0[0x0]
80008dd2:	91 0c       	st.w	r8[0x0],r12
80008dd4:	80 00       	ld.sh	r0,r0[0x0]
80008dd6:	90 80       	ld.uh	r0,r8[0x0]
80008dd8:	80 00       	ld.sh	r0,r0[0x0]
80008dda:	93 a8       	st.w	r9[0x28],r8
80008ddc:	80 00       	ld.sh	r0,r0[0x0]
80008dde:	91 94       	st.w	r8[0x24],r4
80008de0:	80 00       	ld.sh	r0,r0[0x0]
80008de2:	96 00       	ld.sh	r0,r11[0x0]
80008de4:	80 00       	ld.sh	r0,r0[0x0]
80008de6:	8c 08       	ld.sh	r8,r6[0x0]
80008de8:	80 00       	ld.sh	r0,r0[0x0]
80008dea:	94 3c       	ld.sh	r12,r10[0x6]

80008dec <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
80008dec:	eb cd 40 80 	pushm	r7,lr
80008df0:	18 97       	mov	r7,r12
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
80008df2:	79 08       	ld.w	r8,r12[0x40]
80008df4:	58 08       	cp.w	r8,0
80008df6:	c0 a1       	brne	80008e0a <prvCopyDataToQueue+0x1e>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80008df8:	78 08       	ld.w	r8,r12[0x0]
80008dfa:	58 08       	cp.w	r8,0
80008dfc:	c2 b1       	brne	80008e52 <prvCopyDataToQueue+0x66>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
80008dfe:	78 1c       	ld.w	r12,r12[0x4]
80008e00:	f0 1f 00 17 	mcall	80008e5c <prvCopyDataToQueue+0x70>
				pxQueue->pxMutexHolder = NULL;
80008e04:	30 08       	mov	r8,0
80008e06:	8f 18       	st.w	r7[0x4],r8
80008e08:	c2 58       	rjmp	80008e52 <prvCopyDataToQueue+0x66>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
80008e0a:	58 0a       	cp.w	r10,0
80008e0c:	c1 01       	brne	80008e2c <prvCopyDataToQueue+0x40>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80008e0e:	10 9a       	mov	r10,r8
80008e10:	78 2c       	ld.w	r12,r12[0x8]
80008e12:	f0 1f 00 14 	mcall	80008e60 <prvCopyDataToQueue+0x74>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
80008e16:	6e 29       	ld.w	r9,r7[0x8]
80008e18:	6f 08       	ld.w	r8,r7[0x40]
80008e1a:	f2 08 00 08 	add	r8,r9,r8
80008e1e:	8f 28       	st.w	r7[0x8],r8
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
80008e20:	6e 19       	ld.w	r9,r7[0x4]
80008e22:	12 38       	cp.w	r8,r9
80008e24:	c1 73       	brcs	80008e52 <prvCopyDataToQueue+0x66>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
80008e26:	6e 08       	ld.w	r8,r7[0x0]
80008e28:	8f 28       	st.w	r7[0x8],r8
80008e2a:	c1 48       	rjmp	80008e52 <prvCopyDataToQueue+0x66>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80008e2c:	10 9a       	mov	r10,r8
80008e2e:	78 3c       	ld.w	r12,r12[0xc]
80008e30:	f0 1f 00 0c 	mcall	80008e60 <prvCopyDataToQueue+0x74>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
80008e34:	6f 08       	ld.w	r8,r7[0x40]
80008e36:	6e 39       	ld.w	r9,r7[0xc]
80008e38:	f2 08 01 08 	sub	r8,r9,r8
80008e3c:	8f 38       	st.w	r7[0xc],r8
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
80008e3e:	6e 09       	ld.w	r9,r7[0x0]
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
80008e40:	12 38       	cp.w	r8,r9
80008e42:	ef f8 30 10 	ld.wcs	r8,r7[0x40]
80008e46:	ef f9 30 01 	ld.wcs	r9,r7[0x4]
80008e4a:	f3 d8 e3 19 	subcs	r9,r9,r8
80008e4e:	ef f9 3a 03 	st.wcs	r7[0xc],r9
		}
	}

	++( pxQueue->uxMessagesWaiting );
80008e52:	6e e8       	ld.w	r8,r7[0x38]
80008e54:	2f f8       	sub	r8,-1
80008e56:	8f e8       	st.w	r7[0x38],r8
}
80008e58:	e3 cd 80 80 	ldm	sp++,r7,pc
80008e5c:	80 00       	ld.sh	r0,r0[0x0]
80008e5e:	91 3c       	st.w	r8[0xc],r12
80008e60:	80 00       	ld.sh	r0,r0[0x0]
80008e62:	a4 6a       	st.h	r2[0xc],r10

80008e64 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
80008e64:	eb cd 40 c0 	pushm	r6-r7,lr
80008e68:	18 97       	mov	r7,r12
80008e6a:	14 96       	mov	r6,r10
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80008e6c:	78 ec       	ld.w	r12,r12[0x38]
80008e6e:	6e f8       	ld.w	r8,r7[0x3c]
80008e70:	10 3c       	cp.w	r12,r8
80008e72:	c0 33       	brcs	80008e78 <xQueueGenericSendFromISR+0x14>
80008e74:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80008e78:	12 9a       	mov	r10,r9
80008e7a:	0e 9c       	mov	r12,r7
80008e7c:	f0 1f 00 0c 	mcall	80008eac <xQueueGenericSendFromISR+0x48>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
80008e80:	6f 28       	ld.w	r8,r7[0x48]
80008e82:	5b f8       	cp.w	r8,-1
80008e84:	c0 d1       	brne	80008e9e <xQueueGenericSendFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80008e86:	6e 98       	ld.w	r8,r7[0x24]
80008e88:	58 08       	cp.w	r8,0
80008e8a:	c0 f0       	breq	80008ea8 <xQueueGenericSendFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80008e8c:	ee cc ff dc 	sub	r12,r7,-36
80008e90:	f0 1f 00 08 	mcall	80008eb0 <xQueueGenericSendFromISR+0x4c>
80008e94:	c0 a0       	breq	80008ea8 <xQueueGenericSendFromISR+0x44>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
80008e96:	30 1c       	mov	r12,1
80008e98:	8d 0c       	st.w	r6[0x0],r12
80008e9a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
80008e9e:	2f f8       	sub	r8,-1
80008ea0:	ef 48 00 48 	st.w	r7[72],r8
80008ea4:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80008ea8:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80008eac:	80 00       	ld.sh	r0,r0[0x0]
80008eae:	8d ec       	st.w	r6[0x38],r12
80008eb0:	80 00       	ld.sh	r0,r0[0x0]
80008eb2:	92 18       	ld.sh	r8,r9[0x2]

80008eb4 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
80008eb4:	d4 31       	pushm	r0-r7,lr
80008eb6:	20 5d       	sub	sp,20
80008eb8:	18 97       	mov	r7,r12
80008eba:	50 0b       	stdsp	sp[0x0],r11
80008ebc:	50 2a       	stdsp	sp[0x8],r10
80008ebe:	50 19       	stdsp	sp[0x4],r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
80008ec0:	f8 c0 ff f0 	sub	r0,r12,-16
80008ec4:	30 04       	mov	r4,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80008ec6:	fa c3 ff f4 	sub	r3,sp,-12

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80008eca:	08 91       	mov	r1,r4

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80008ecc:	fa c2 ff f8 	sub	r2,sp,-8
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
80008ed0:	f0 1f 00 2f 	mcall	80008f8c <xQueueGenericSend+0xd8>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80008ed4:	6e e9       	ld.w	r9,r7[0x38]
80008ed6:	6e f8       	ld.w	r8,r7[0x3c]
80008ed8:	10 39       	cp.w	r9,r8
80008eda:	c1 42       	brcc	80008f02 <xQueueGenericSend+0x4e>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80008edc:	40 1a       	lddsp	r10,sp[0x4]
80008ede:	40 0b       	lddsp	r11,sp[0x0]
80008ee0:	0e 9c       	mov	r12,r7
80008ee2:	f0 1f 00 2c 	mcall	80008f90 <xQueueGenericSend+0xdc>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80008ee6:	6e 98       	ld.w	r8,r7[0x24]
80008ee8:	58 08       	cp.w	r8,0
80008eea:	c0 80       	breq	80008efa <xQueueGenericSend+0x46>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
80008eec:	ee cc ff dc 	sub	r12,r7,-36
80008ef0:	f0 1f 00 29 	mcall	80008f94 <xQueueGenericSend+0xe0>
80008ef4:	58 1c       	cp.w	r12,1
80008ef6:	c0 21       	brne	80008efa <xQueueGenericSend+0x46>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
80008ef8:	d7 33       	scall
					}
				}

				taskEXIT_CRITICAL();
80008efa:	f0 1f 00 28 	mcall	80008f98 <xQueueGenericSend+0xe4>
80008efe:	30 1c       	mov	r12,1

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
80008f00:	c4 38       	rjmp	80008f86 <xQueueGenericSend+0xd2>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
80008f02:	40 28       	lddsp	r8,sp[0x8]
80008f04:	58 08       	cp.w	r8,0
80008f06:	c0 51       	brne	80008f10 <xQueueGenericSend+0x5c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80008f08:	f0 1f 00 24 	mcall	80008f98 <xQueueGenericSend+0xe4>
80008f0c:	30 0c       	mov	r12,0

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
80008f0e:	c3 c8       	rjmp	80008f86 <xQueueGenericSend+0xd2>
				}
				else if( xEntryTimeSet == pdFALSE )
80008f10:	58 04       	cp.w	r4,0
80008f12:	c0 51       	brne	80008f1c <xQueueGenericSend+0x68>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80008f14:	06 9c       	mov	r12,r3
80008f16:	f0 1f 00 22 	mcall	80008f9c <xQueueGenericSend+0xe8>
80008f1a:	30 14       	mov	r4,1
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80008f1c:	f0 1f 00 1f 	mcall	80008f98 <xQueueGenericSend+0xe4>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80008f20:	f0 1f 00 20 	mcall	80008fa0 <xQueueGenericSend+0xec>
		prvLockQueue( pxQueue );
80008f24:	f0 1f 00 1a 	mcall	80008f8c <xQueueGenericSend+0xd8>
80008f28:	6f 18       	ld.w	r8,r7[0x44]
80008f2a:	5b f8       	cp.w	r8,-1
80008f2c:	ef f1 0a 11 	st.weq	r7[0x44],r1
80008f30:	6f 28       	ld.w	r8,r7[0x48]
80008f32:	5b f8       	cp.w	r8,-1
80008f34:	ef f1 0a 12 	st.weq	r7[0x48],r1
80008f38:	f0 1f 00 18 	mcall	80008f98 <xQueueGenericSend+0xe4>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80008f3c:	04 9b       	mov	r11,r2
80008f3e:	06 9c       	mov	r12,r3
80008f40:	f0 1f 00 19 	mcall	80008fa4 <xQueueGenericSend+0xf0>
80008f44:	c1 b1       	brne	80008f7a <xQueueGenericSend+0xc6>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80008f46:	f0 1f 00 12 	mcall	80008f8c <xQueueGenericSend+0xd8>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
80008f4a:	6e e5       	ld.w	r5,r7[0x38]
80008f4c:	6e f6       	ld.w	r6,r7[0x3c]
	taskEXIT_CRITICAL();
80008f4e:	f0 1f 00 13 	mcall	80008f98 <xQueueGenericSend+0xe4>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
80008f52:	0c 35       	cp.w	r5,r6
80008f54:	c0 d1       	brne	80008f6e <xQueueGenericSend+0xba>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
80008f56:	40 2b       	lddsp	r11,sp[0x8]
80008f58:	00 9c       	mov	r12,r0
80008f5a:	f0 1f 00 14 	mcall	80008fa8 <xQueueGenericSend+0xf4>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
80008f5e:	0e 9c       	mov	r12,r7
80008f60:	f0 1f 00 13 	mcall	80008fac <xQueueGenericSend+0xf8>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
80008f64:	f0 1f 00 13 	mcall	80008fb0 <xQueueGenericSend+0xfc>
80008f68:	cb 41       	brne	80008ed0 <xQueueGenericSend+0x1c>
				{
					portYIELD_WITHIN_API();
80008f6a:	d7 33       	scall
80008f6c:	cb 2b       	rjmp	80008ed0 <xQueueGenericSend+0x1c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80008f6e:	0e 9c       	mov	r12,r7
80008f70:	f0 1f 00 0f 	mcall	80008fac <xQueueGenericSend+0xf8>
				( void ) xTaskResumeAll();
80008f74:	f0 1f 00 0f 	mcall	80008fb0 <xQueueGenericSend+0xfc>
80008f78:	ca cb       	rjmp	80008ed0 <xQueueGenericSend+0x1c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
80008f7a:	0e 9c       	mov	r12,r7
80008f7c:	f0 1f 00 0c 	mcall	80008fac <xQueueGenericSend+0xf8>
			( void ) xTaskResumeAll();
80008f80:	f0 1f 00 0c 	mcall	80008fb0 <xQueueGenericSend+0xfc>
80008f84:	30 0c       	mov	r12,0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
80008f86:	2f bd       	sub	sp,-20
80008f88:	d8 32       	popm	r0-r7,pc
80008f8a:	00 00       	add	r0,r0
80008f8c:	80 00       	ld.sh	r0,r0[0x0]
80008f8e:	88 f4       	ld.uh	r4,r4[0xe]
80008f90:	80 00       	ld.sh	r0,r0[0x0]
80008f92:	8d ec       	st.w	r6[0x38],r12
80008f94:	80 00       	ld.sh	r0,r0[0x0]
80008f96:	92 18       	ld.sh	r8,r9[0x2]
80008f98:	80 00       	ld.sh	r0,r0[0x0]
80008f9a:	8a 00       	ld.sh	r0,r5[0x0]
80008f9c:	80 00       	ld.sh	r0,r0[0x0]
80008f9e:	91 0c       	st.w	r8[0x0],r12
80008fa0:	80 00       	ld.sh	r0,r0[0x0]
80008fa2:	90 80       	ld.uh	r0,r8[0x0]
80008fa4:	80 00       	ld.sh	r0,r0[0x0]
80008fa6:	93 a8       	st.w	r9[0x28],r8
80008fa8:	80 00       	ld.sh	r0,r0[0x0]
80008faa:	96 00       	ld.sh	r0,r11[0x0]
80008fac:	80 00       	ld.sh	r0,r0[0x0]
80008fae:	8c 08       	ld.sh	r8,r6[0x0]
80008fb0:	80 00       	ld.sh	r0,r0[0x0]
80008fb2:	94 3c       	ld.sh	r12,r10[0x6]

80008fb4 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	xQueueHandle xQueueCreateMutex( void )
	{
80008fb4:	eb cd 40 c0 	pushm	r6-r7,lr
	xQUEUE *pxNewQueue;

		/* Allocate the new queue structure. */
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
80008fb8:	34 cc       	mov	r12,76
80008fba:	f0 1f 00 12 	mcall	80009000 <xQueueCreateMutex+0x4c>
80008fbe:	18 97       	mov	r7,r12
		if( pxNewQueue != NULL )
80008fc0:	c1 d0       	breq	80008ffa <xQueueCreateMutex+0x46>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
80008fc2:	30 06       	mov	r6,0
80008fc4:	99 16       	st.w	r12[0x4],r6
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
80008fc6:	99 06       	st.w	r12[0x0],r6

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
80008fc8:	99 26       	st.w	r12[0x8],r6
			pxNewQueue->pcReadFrom = NULL;
80008fca:	99 36       	st.w	r12[0xc],r6

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
80008fcc:	99 e6       	st.w	r12[0x38],r6
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
80008fce:	30 18       	mov	r8,1
80008fd0:	99 f8       	st.w	r12[0x3c],r8
			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
80008fd2:	f9 46 00 40 	st.w	r12[64],r6
			pxNewQueue->xRxLock = queueUNLOCKED;
80008fd6:	3f f8       	mov	r8,-1
80008fd8:	f9 48 00 44 	st.w	r12[68],r8
			pxNewQueue->xTxLock = queueUNLOCKED;
80008fdc:	f9 48 00 48 	st.w	r12[72],r8

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
80008fe0:	2f 0c       	sub	r12,-16
80008fe2:	f0 1f 00 09 	mcall	80009004 <xQueueCreateMutex+0x50>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
80008fe6:	ee cc ff dc 	sub	r12,r7,-36
80008fea:	f0 1f 00 07 	mcall	80009004 <xQueueCreateMutex+0x50>

			/* Start with the semaphore in the expected state. */
			xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
80008fee:	0c 99       	mov	r9,r6
80008ff0:	0c 9a       	mov	r10,r6
80008ff2:	0c 9b       	mov	r11,r6
80008ff4:	0e 9c       	mov	r12,r7
80008ff6:	f0 1f 00 05 	mcall	80009008 <xQueueCreateMutex+0x54>
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
80008ffa:	0e 9c       	mov	r12,r7
80008ffc:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80009000:	80 00       	ld.sh	r0,r0[0x0]
80009002:	8b 60       	st.w	r5[0x18],r0
80009004:	80 00       	ld.sh	r0,r0[0x0]
80009006:	87 d0       	st.w	r3[0x34],r0
80009008:	80 00       	ld.sh	r0,r0[0x0]
8000900a:	8e b4       	ld.uh	r4,r7[0x6]

8000900c <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
8000900c:	d4 21       	pushm	r4-r7,lr
8000900e:	18 97       	mov	r7,r12
80009010:	16 96       	mov	r6,r11
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
80009012:	58 0c       	cp.w	r12,0
80009014:	c2 f0       	breq	80009072 <xQueueCreate+0x66>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
80009016:	34 cc       	mov	r12,76
80009018:	f0 1f 00 17 	mcall	80009074 <xQueueCreate+0x68>
8000901c:	18 95       	mov	r5,r12
		if( pxNewQueue != NULL )
8000901e:	c2 a0       	breq	80009072 <xQueueCreate+0x66>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
80009020:	ec 07 02 44 	mul	r4,r6,r7

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
80009024:	e8 cc ff ff 	sub	r12,r4,-1
80009028:	f0 1f 00 13 	mcall	80009074 <xQueueCreate+0x68>
8000902c:	8b 0c       	st.w	r5[0x0],r12
			if( pxNewQueue->pcHead != NULL )
8000902e:	c1 e0       	breq	8000906a <xQueueCreate+0x5e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
80009030:	f8 04 00 04 	add	r4,r12,r4
80009034:	8b 14       	st.w	r5[0x4],r4
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
80009036:	30 08       	mov	r8,0
80009038:	8b e8       	st.w	r5[0x38],r8
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
8000903a:	8b 2c       	st.w	r5[0x8],r12
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
8000903c:	ee c8 00 01 	sub	r8,r7,1
80009040:	ad 38       	mul	r8,r6
80009042:	10 0c       	add	r12,r8
80009044:	8b 3c       	st.w	r5[0xc],r12
				pxNewQueue->uxLength = uxQueueLength;
80009046:	8b f7       	st.w	r5[0x3c],r7
				pxNewQueue->uxItemSize = uxItemSize;
80009048:	eb 46 00 40 	st.w	r5[64],r6
				pxNewQueue->xRxLock = queueUNLOCKED;
8000904c:	3f f8       	mov	r8,-1
8000904e:	eb 48 00 44 	st.w	r5[68],r8
				pxNewQueue->xTxLock = queueUNLOCKED;
80009052:	eb 48 00 48 	st.w	r5[72],r8

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
80009056:	ea cc ff f0 	sub	r12,r5,-16
8000905a:	f0 1f 00 08 	mcall	80009078 <xQueueCreate+0x6c>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
8000905e:	ea cc ff dc 	sub	r12,r5,-36
80009062:	f0 1f 00 06 	mcall	80009078 <xQueueCreate+0x6c>
80009066:	0a 9c       	mov	r12,r5
80009068:	d8 22       	popm	r4-r7,pc
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
8000906a:	0a 9c       	mov	r12,r5
8000906c:	f0 1f 00 04 	mcall	8000907c <xQueueCreate+0x70>
80009070:	d8 2a       	popm	r4-r7,pc,r12=0
80009072:	d8 2a       	popm	r4-r7,pc,r12=0
80009074:	80 00       	ld.sh	r0,r0[0x0]
80009076:	8b 60       	st.w	r5[0x18],r0
80009078:	80 00       	ld.sh	r0,r0[0x0]
8000907a:	87 d0       	st.w	r3[0x34],r0
8000907c:	80 00       	ld.sh	r0,r0[0x0]
8000907e:	8b 38       	st.w	r5[0xc],r8

80009080 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
80009080:	48 38       	lddpc	r8,8000908c <vTaskSuspendAll+0xc>
80009082:	70 09       	ld.w	r9,r8[0x0]
80009084:	2f f9       	sub	r9,-1
80009086:	91 09       	st.w	r8[0x0],r9
}
80009088:	5e fc       	retal	r12
8000908a:	00 00       	add	r0,r0
8000908c:	00 00       	add	r0,r0
8000908e:	12 54       	eor	r4,r9

80009090 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
80009090:	49 a8       	lddpc	r8,800090f8 <vTaskSwitchContext+0x68>
80009092:	70 08       	ld.w	r8,r8[0x0]
80009094:	58 08       	cp.w	r8,0
80009096:	c0 b1       	brne	800090ac <vTaskSwitchContext+0x1c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80009098:	49 98       	lddpc	r8,800090fc <vTaskSwitchContext+0x6c>
8000909a:	70 08       	ld.w	r8,r8[0x0]
8000909c:	f0 08 00 28 	add	r8,r8,r8<<0x2
800090a0:	49 89       	lddpc	r9,80009100 <vTaskSwitchContext+0x70>
800090a2:	f2 08 03 28 	ld.w	r8,r9[r8<<0x2]
800090a6:	58 08       	cp.w	r8,0
800090a8:	c0 60       	breq	800090b4 <vTaskSwitchContext+0x24>
800090aa:	c1 18       	rjmp	800090cc <vTaskSwitchContext+0x3c>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
800090ac:	30 19       	mov	r9,1
800090ae:	49 68       	lddpc	r8,80009104 <vTaskSwitchContext+0x74>
800090b0:	91 09       	st.w	r8[0x0],r9
800090b2:	5e fc       	retal	r12

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
800090b4:	49 28       	lddpc	r8,800090fc <vTaskSwitchContext+0x6c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
800090b6:	49 3a       	lddpc	r10,80009100 <vTaskSwitchContext+0x70>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
800090b8:	70 09       	ld.w	r9,r8[0x0]
800090ba:	20 19       	sub	r9,1
800090bc:	91 09       	st.w	r8[0x0],r9

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
800090be:	70 09       	ld.w	r9,r8[0x0]
800090c0:	f2 09 00 29 	add	r9,r9,r9<<0x2
800090c4:	f4 09 03 29 	ld.w	r9,r10[r9<<0x2]
800090c8:	58 09       	cp.w	r9,0
800090ca:	cf 70       	breq	800090b8 <vTaskSwitchContext+0x28>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
800090cc:	48 c8       	lddpc	r8,800090fc <vTaskSwitchContext+0x6c>
800090ce:	70 08       	ld.w	r8,r8[0x0]
800090d0:	f0 08 00 28 	add	r8,r8,r8<<0x2
800090d4:	48 b9       	lddpc	r9,80009100 <vTaskSwitchContext+0x70>
800090d6:	f2 08 00 28 	add	r8,r9,r8<<0x2
800090da:	70 19       	ld.w	r9,r8[0x4]
800090dc:	72 19       	ld.w	r9,r9[0x4]
800090de:	91 19       	st.w	r8[0x4],r9
800090e0:	f0 ca ff f8 	sub	r10,r8,-8
800090e4:	14 39       	cp.w	r9,r10
800090e6:	f3 f9 00 01 	ld.weq	r9,r9[0x4]
800090ea:	f1 f9 0a 01 	st.weq	r8[0x4],r9
800090ee:	70 18       	ld.w	r8,r8[0x4]
800090f0:	70 39       	ld.w	r9,r8[0xc]
800090f2:	48 68       	lddpc	r8,80009108 <vTaskSwitchContext+0x78>
800090f4:	91 09       	st.w	r8[0x0],r9
800090f6:	5e fc       	retal	r12
800090f8:	00 00       	add	r0,r0
800090fa:	12 54       	eor	r4,r9
800090fc:	00 00       	add	r0,r0
800090fe:	12 8c       	andn	r12,r9
80009100:	00 00       	add	r0,r0
80009102:	11 70       	ld.ub	r0,--r8
80009104:	00 00       	add	r0,r0
80009106:	12 74       	tst	r4,r9
80009108:	00 00       	add	r0,r0
8000910a:	12 24       	rsub	r4,r9

8000910c <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
8000910c:	48 48       	lddpc	r8,8000911c <vTaskSetTimeOutState+0x10>
8000910e:	70 08       	ld.w	r8,r8[0x0]
80009110:	99 08       	st.w	r12[0x0],r8
	pxTimeOut->xTimeOnEntering = xTickCount;
80009112:	48 48       	lddpc	r8,80009120 <vTaskSetTimeOutState+0x14>
80009114:	70 08       	ld.w	r8,r8[0x0]
80009116:	99 18       	st.w	r12[0x4],r8
}
80009118:	5e fc       	retal	r12
8000911a:	00 00       	add	r0,r0
8000911c:	00 00       	add	r0,r0
8000911e:	11 68       	ld.uh	r8,--r8
80009120:	00 00       	add	r0,r0
80009122:	12 50       	eor	r0,r9

80009124 <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
80009124:	30 19       	mov	r9,1
80009126:	48 28       	lddpc	r8,8000912c <vTaskMissedYield+0x8>
80009128:	91 09       	st.w	r8[0x0],r9
}
8000912a:	5e fc       	retal	r12
8000912c:	00 00       	add	r0,r0
8000912e:	12 74       	tst	r4,r9

80009130 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
80009130:	48 28       	lddpc	r8,80009138 <xTaskGetCurrentTaskHandle+0x8>
80009132:	70 0c       	ld.w	r12,r8[0x0]

		return xReturn;
	}
80009134:	5e fc       	retal	r12
80009136:	00 00       	add	r0,r0
80009138:	00 00       	add	r0,r0
8000913a:	12 24       	rsub	r4,r9

8000913c <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
8000913c:	eb cd 40 c0 	pushm	r6-r7,lr
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
80009140:	58 0c       	cp.w	r12,0
80009142:	c1 f0       	breq	80009180 <vTaskPriorityDisinherit+0x44>

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
80009144:	18 97       	mov	r7,r12

		if( pxMutexHolder != NULL )
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
80009146:	78 b9       	ld.w	r9,r12[0x2c]
80009148:	79 18       	ld.w	r8,r12[0x44]
8000914a:	10 39       	cp.w	r9,r8
8000914c:	c1 a0       	breq	80009180 <vTaskPriorityDisinherit+0x44>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
8000914e:	f8 c6 ff fc 	sub	r6,r12,-4
80009152:	0c 9c       	mov	r12,r6
80009154:	f0 1f 00 0c 	mcall	80009184 <vTaskPriorityDisinherit+0x48>

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
80009158:	6f 1c       	ld.w	r12,r7[0x44]
8000915a:	8f bc       	st.w	r7[0x2c],r12
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
8000915c:	f8 08 11 08 	rsub	r8,r12,8
80009160:	8f 68       	st.w	r7[0x18],r8
				prvAddTaskToReadyQueue( pxTCB );
80009162:	48 a8       	lddpc	r8,80009188 <vTaskPriorityDisinherit+0x4c>
80009164:	70 08       	ld.w	r8,r8[0x0]
80009166:	10 3c       	cp.w	r12,r8
80009168:	e0 88 00 04 	brls	80009170 <vTaskPriorityDisinherit+0x34>
8000916c:	48 78       	lddpc	r8,80009188 <vTaskPriorityDisinherit+0x4c>
8000916e:	91 0c       	st.w	r8[0x0],r12
80009170:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80009174:	0c 9b       	mov	r11,r6
80009176:	48 68       	lddpc	r8,8000918c <vTaskPriorityDisinherit+0x50>
80009178:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
8000917c:	f0 1f 00 05 	mcall	80009190 <vTaskPriorityDisinherit+0x54>
80009180:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80009184:	80 00       	ld.sh	r0,r0[0x0]
80009186:	88 3a       	ld.sh	r10,r4[0x6]
80009188:	00 00       	add	r0,r0
8000918a:	12 8c       	andn	r12,r9
8000918c:	00 00       	add	r0,r0
8000918e:	11 70       	ld.ub	r0,--r8
80009190:	80 00       	ld.sh	r0,r0[0x0]
80009192:	87 ea       	st.w	r3[0x38],r10

80009194 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
80009194:	eb cd 40 c0 	pushm	r6-r7,lr
80009198:	18 97       	mov	r7,r12
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
8000919a:	49 b8       	lddpc	r8,80009204 <vTaskPriorityInherit+0x70>
8000919c:	70 08       	ld.w	r8,r8[0x0]
8000919e:	78 b9       	ld.w	r9,r12[0x2c]
800091a0:	70 b8       	ld.w	r8,r8[0x2c]
800091a2:	10 39       	cp.w	r9,r8
800091a4:	c2 d2       	brcc	800091fe <vTaskPriorityInherit+0x6a>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
800091a6:	49 88       	lddpc	r8,80009204 <vTaskPriorityInherit+0x70>
800091a8:	70 08       	ld.w	r8,r8[0x0]
800091aa:	70 b8       	ld.w	r8,r8[0x2c]
800091ac:	f0 08 11 08 	rsub	r8,r8,8
800091b0:	99 68       	st.w	r12[0x18],r8

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
800091b2:	f2 09 00 28 	add	r8,r9,r9<<0x2
800091b6:	49 59       	lddpc	r9,80009208 <vTaskPriorityInherit+0x74>
800091b8:	f2 08 00 28 	add	r8,r9,r8<<0x2
800091bc:	78 59       	ld.w	r9,r12[0x14]
800091be:	10 39       	cp.w	r9,r8
800091c0:	c1 b1       	brne	800091f6 <vTaskPriorityInherit+0x62>
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
800091c2:	f8 c6 ff fc 	sub	r6,r12,-4
800091c6:	0c 9c       	mov	r12,r6
800091c8:	f0 1f 00 11 	mcall	8000920c <vTaskPriorityInherit+0x78>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
800091cc:	48 e8       	lddpc	r8,80009204 <vTaskPriorityInherit+0x70>
800091ce:	70 08       	ld.w	r8,r8[0x0]
800091d0:	70 bc       	ld.w	r12,r8[0x2c]
800091d2:	8f bc       	st.w	r7[0x2c],r12
				prvAddTaskToReadyQueue( pxTCB );
800091d4:	48 f8       	lddpc	r8,80009210 <vTaskPriorityInherit+0x7c>
800091d6:	70 08       	ld.w	r8,r8[0x0]
800091d8:	10 3c       	cp.w	r12,r8
800091da:	e0 88 00 04 	brls	800091e2 <vTaskPriorityInherit+0x4e>
800091de:	48 d8       	lddpc	r8,80009210 <vTaskPriorityInherit+0x7c>
800091e0:	91 0c       	st.w	r8[0x0],r12
800091e2:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800091e6:	0c 9b       	mov	r11,r6
800091e8:	48 88       	lddpc	r8,80009208 <vTaskPriorityInherit+0x74>
800091ea:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800091ee:	f0 1f 00 0a 	mcall	80009214 <vTaskPriorityInherit+0x80>
800091f2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
800091f6:	48 48       	lddpc	r8,80009204 <vTaskPriorityInherit+0x70>
800091f8:	70 08       	ld.w	r8,r8[0x0]
800091fa:	70 b8       	ld.w	r8,r8[0x2c]
800091fc:	99 b8       	st.w	r12[0x2c],r8
800091fe:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80009202:	00 00       	add	r0,r0
80009204:	00 00       	add	r0,r0
80009206:	12 24       	rsub	r4,r9
80009208:	00 00       	add	r0,r0
8000920a:	11 70       	ld.ub	r0,--r8
8000920c:	80 00       	ld.sh	r0,r0[0x0]
8000920e:	88 3a       	ld.sh	r10,r4[0x6]
80009210:	00 00       	add	r0,r0
80009212:	12 8c       	andn	r12,r9
80009214:	80 00       	ld.sh	r0,r0[0x0]
80009216:	87 ea       	st.w	r3[0x38],r10

80009218 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
80009218:	eb cd 40 c0 	pushm	r6-r7,lr
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
8000921c:	78 38       	ld.w	r8,r12[0xc]
8000921e:	70 37       	ld.w	r7,r8[0xc]
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
80009220:	ee c6 ff e8 	sub	r6,r7,-24
80009224:	0c 9c       	mov	r12,r6
80009226:	f0 1f 00 15 	mcall	80009278 <xTaskRemoveFromEventList+0x60>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
8000922a:	49 58       	lddpc	r8,8000927c <xTaskRemoveFromEventList+0x64>
8000922c:	70 08       	ld.w	r8,r8[0x0]
8000922e:	58 08       	cp.w	r8,0
80009230:	c1 71       	brne	8000925e <xTaskRemoveFromEventList+0x46>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
80009232:	ee c6 ff fc 	sub	r6,r7,-4
80009236:	0c 9c       	mov	r12,r6
80009238:	f0 1f 00 10 	mcall	80009278 <xTaskRemoveFromEventList+0x60>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
8000923c:	6e bc       	ld.w	r12,r7[0x2c]
8000923e:	49 18       	lddpc	r8,80009280 <xTaskRemoveFromEventList+0x68>
80009240:	70 08       	ld.w	r8,r8[0x0]
80009242:	10 3c       	cp.w	r12,r8
80009244:	e0 88 00 04 	brls	8000924c <xTaskRemoveFromEventList+0x34>
80009248:	48 e8       	lddpc	r8,80009280 <xTaskRemoveFromEventList+0x68>
8000924a:	91 0c       	st.w	r8[0x0],r12
8000924c:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80009250:	0c 9b       	mov	r11,r6
80009252:	48 d8       	lddpc	r8,80009284 <xTaskRemoveFromEventList+0x6c>
80009254:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80009258:	f0 1f 00 0c 	mcall	80009288 <xTaskRemoveFromEventList+0x70>
8000925c:	c0 58       	rjmp	80009266 <xTaskRemoveFromEventList+0x4e>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
8000925e:	0c 9b       	mov	r11,r6
80009260:	48 bc       	lddpc	r12,8000928c <xTaskRemoveFromEventList+0x74>
80009262:	f0 1f 00 0a 	mcall	80009288 <xTaskRemoveFromEventList+0x70>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
80009266:	48 b8       	lddpc	r8,80009290 <xTaskRemoveFromEventList+0x78>
80009268:	70 08       	ld.w	r8,r8[0x0]
8000926a:	6e b9       	ld.w	r9,r7[0x2c]
8000926c:	70 b8       	ld.w	r8,r8[0x2c]
8000926e:	10 39       	cp.w	r9,r8
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
80009270:	5f 2c       	srhs	r12
80009272:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80009276:	00 00       	add	r0,r0
80009278:	80 00       	ld.sh	r0,r0[0x0]
8000927a:	88 3a       	ld.sh	r10,r4[0x6]
8000927c:	00 00       	add	r0,r0
8000927e:	12 54       	eor	r4,r9
80009280:	00 00       	add	r0,r0
80009282:	12 8c       	andn	r12,r9
80009284:	00 00       	add	r0,r0
80009286:	11 70       	ld.ub	r0,--r8
80009288:	80 00       	ld.sh	r0,r0[0x0]
8000928a:	87 ea       	st.w	r3[0x38],r10
8000928c:	00 00       	add	r0,r0
8000928e:	12 28       	rsub	r8,r9
80009290:	00 00       	add	r0,r0
80009292:	12 24       	rsub	r4,r9

80009294 <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
80009294:	eb cd 40 fc 	pushm	r2-r7,lr
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80009298:	4b 98       	lddpc	r8,8000937c <vTaskIncrementTick+0xe8>
8000929a:	70 08       	ld.w	r8,r8[0x0]
8000929c:	58 08       	cp.w	r8,0
8000929e:	c6 91       	brne	80009370 <vTaskIncrementTick+0xdc>
	{
		++xTickCount;
800092a0:	4b 88       	lddpc	r8,80009380 <vTaskIncrementTick+0xec>
800092a2:	70 09       	ld.w	r9,r8[0x0]
800092a4:	2f f9       	sub	r9,-1
800092a6:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
800092a8:	70 08       	ld.w	r8,r8[0x0]
800092aa:	58 08       	cp.w	r8,0
800092ac:	c1 a1       	brne	800092e0 <vTaskIncrementTick+0x4c>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
800092ae:	4b 68       	lddpc	r8,80009384 <vTaskIncrementTick+0xf0>
800092b0:	70 0a       	ld.w	r10,r8[0x0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
800092b2:	4b 69       	lddpc	r9,80009388 <vTaskIncrementTick+0xf4>
800092b4:	72 0b       	ld.w	r11,r9[0x0]
800092b6:	91 0b       	st.w	r8[0x0],r11
			pxOverflowDelayedTaskList = pxTemp;
800092b8:	93 0a       	st.w	r9[0x0],r10
			xNumOfOverflows++;
800092ba:	4b 59       	lddpc	r9,8000938c <vTaskIncrementTick+0xf8>
800092bc:	72 0a       	ld.w	r10,r9[0x0]
800092be:	2f fa       	sub	r10,-1
800092c0:	93 0a       	st.w	r9[0x0],r10

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
800092c2:	70 08       	ld.w	r8,r8[0x0]
800092c4:	70 08       	ld.w	r8,r8[0x0]
800092c6:	58 08       	cp.w	r8,0
800092c8:	c0 51       	brne	800092d2 <vTaskIncrementTick+0x3e>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
800092ca:	3f f9       	mov	r9,-1
800092cc:	4b 18       	lddpc	r8,80009390 <vTaskIncrementTick+0xfc>
800092ce:	91 09       	st.w	r8[0x0],r9
800092d0:	c0 88       	rjmp	800092e0 <vTaskIncrementTick+0x4c>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
800092d2:	4a d8       	lddpc	r8,80009384 <vTaskIncrementTick+0xf0>
800092d4:	70 08       	ld.w	r8,r8[0x0]
800092d6:	70 38       	ld.w	r8,r8[0xc]
800092d8:	70 38       	ld.w	r8,r8[0xc]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
800092da:	70 19       	ld.w	r9,r8[0x4]
800092dc:	4a d8       	lddpc	r8,80009390 <vTaskIncrementTick+0xfc>
800092de:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
800092e0:	4a 88       	lddpc	r8,80009380 <vTaskIncrementTick+0xec>
800092e2:	70 09       	ld.w	r9,r8[0x0]
800092e4:	4a b8       	lddpc	r8,80009390 <vTaskIncrementTick+0xfc>
800092e6:	70 08       	ld.w	r8,r8[0x0]
800092e8:	10 39       	cp.w	r9,r8
800092ea:	c4 73       	brcs	80009378 <vTaskIncrementTick+0xe4>
800092ec:	4a 68       	lddpc	r8,80009384 <vTaskIncrementTick+0xf0>
800092ee:	70 08       	ld.w	r8,r8[0x0]
800092f0:	70 08       	ld.w	r8,r8[0x0]
800092f2:	58 08       	cp.w	r8,0
800092f4:	c0 c0       	breq	8000930c <vTaskIncrementTick+0x78>
800092f6:	4a 48       	lddpc	r8,80009384 <vTaskIncrementTick+0xf0>
800092f8:	70 08       	ld.w	r8,r8[0x0]
800092fa:	70 38       	ld.w	r8,r8[0xc]
800092fc:	70 37       	ld.w	r7,r8[0xc]
800092fe:	6e 18       	ld.w	r8,r7[0x4]
80009300:	4a 09       	lddpc	r9,80009380 <vTaskIncrementTick+0xec>
80009302:	72 09       	ld.w	r9,r9[0x0]
80009304:	12 38       	cp.w	r8,r9
80009306:	e0 88 00 14 	brls	8000932e <vTaskIncrementTick+0x9a>
8000930a:	c0 e8       	rjmp	80009326 <vTaskIncrementTick+0x92>
8000930c:	3f f9       	mov	r9,-1
8000930e:	4a 18       	lddpc	r8,80009390 <vTaskIncrementTick+0xfc>
80009310:	91 09       	st.w	r8[0x0],r9
80009312:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80009316:	6a 08       	ld.w	r8,r5[0x0]
80009318:	70 38       	ld.w	r8,r8[0xc]
8000931a:	70 37       	ld.w	r7,r8[0xc]
8000931c:	6e 18       	ld.w	r8,r7[0x4]
8000931e:	64 09       	ld.w	r9,r2[0x0]
80009320:	12 38       	cp.w	r8,r9
80009322:	e0 88 00 0a 	brls	80009336 <vTaskIncrementTick+0xa2>
80009326:	49 b9       	lddpc	r9,80009390 <vTaskIncrementTick+0xfc>
80009328:	93 08       	st.w	r9[0x0],r8
8000932a:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
8000932e:	49 a4       	lddpc	r4,80009394 <vTaskIncrementTick+0x100>
80009330:	49 a3       	lddpc	r3,80009398 <vTaskIncrementTick+0x104>
80009332:	49 55       	lddpc	r5,80009384 <vTaskIncrementTick+0xf0>
80009334:	49 32       	lddpc	r2,80009380 <vTaskIncrementTick+0xec>
80009336:	ee c6 ff fc 	sub	r6,r7,-4
8000933a:	0c 9c       	mov	r12,r6
8000933c:	f0 1f 00 18 	mcall	8000939c <vTaskIncrementTick+0x108>
80009340:	6e a8       	ld.w	r8,r7[0x28]
80009342:	58 08       	cp.w	r8,0
80009344:	c0 50       	breq	8000934e <vTaskIncrementTick+0xba>
80009346:	ee cc ff e8 	sub	r12,r7,-24
8000934a:	f0 1f 00 15 	mcall	8000939c <vTaskIncrementTick+0x108>
8000934e:	6e bc       	ld.w	r12,r7[0x2c]
80009350:	68 08       	ld.w	r8,r4[0x0]
80009352:	10 3c       	cp.w	r12,r8
80009354:	e9 fc ba 00 	st.whi	r4[0x0],r12
80009358:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
8000935c:	0c 9b       	mov	r11,r6
8000935e:	e6 0c 00 2c 	add	r12,r3,r12<<0x2
80009362:	f0 1f 00 10 	mcall	800093a0 <vTaskIncrementTick+0x10c>
80009366:	6a 08       	ld.w	r8,r5[0x0]
80009368:	70 08       	ld.w	r8,r8[0x0]
8000936a:	58 08       	cp.w	r8,0
8000936c:	cd 51       	brne	80009316 <vTaskIncrementTick+0x82>
8000936e:	cc fb       	rjmp	8000930c <vTaskIncrementTick+0x78>
	}
	else
	{
		++uxMissedTicks;
80009370:	48 d8       	lddpc	r8,800093a4 <vTaskIncrementTick+0x110>
80009372:	70 09       	ld.w	r9,r8[0x0]
80009374:	2f f9       	sub	r9,-1
80009376:	91 09       	st.w	r8[0x0],r9
80009378:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
8000937c:	00 00       	add	r0,r0
8000937e:	12 54       	eor	r4,r9
80009380:	00 00       	add	r0,r0
80009382:	12 50       	eor	r0,r9
80009384:	00 00       	add	r0,r0
80009386:	11 5c       	ld.sh	r12,--r8
80009388:	00 00       	add	r0,r0
8000938a:	11 6c       	ld.uh	r12,--r8
8000938c:	00 00       	add	r0,r0
8000938e:	11 68       	ld.uh	r8,--r8
80009390:	00 00       	add	r0,r0
80009392:	05 34       	ld.ub	r4,r2++
80009394:	00 00       	add	r0,r0
80009396:	12 8c       	andn	r12,r9
80009398:	00 00       	add	r0,r0
8000939a:	11 70       	ld.ub	r0,--r8
8000939c:	80 00       	ld.sh	r0,r0[0x0]
8000939e:	88 3a       	ld.sh	r10,r4[0x6]
800093a0:	80 00       	ld.sh	r0,r0[0x0]
800093a2:	87 ea       	st.w	r3[0x38],r10
800093a4:	00 00       	add	r0,r0
800093a6:	11 54       	ld.sh	r4,--r8

800093a8 <xTaskCheckForTimeOut>:
	pxTimeOut->xTimeOnEntering = xTickCount;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
800093a8:	eb cd 40 c0 	pushm	r6-r7,lr
800093ac:	18 97       	mov	r7,r12
800093ae:	16 96       	mov	r6,r11
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
800093b0:	f0 1f 00 15 	mcall	80009404 <xTaskCheckForTimeOut+0x5c>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
800093b4:	6c 08       	ld.w	r8,r6[0x0]
800093b6:	5b f8       	cp.w	r8,-1
800093b8:	c0 31       	brne	800093be <xTaskCheckForTimeOut+0x16>
800093ba:	30 07       	mov	r7,0
800093bc:	c1 f8       	rjmp	800093fa <xTaskCheckForTimeOut+0x52>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
800093be:	49 39       	lddpc	r9,80009408 <xTaskCheckForTimeOut+0x60>
800093c0:	72 09       	ld.w	r9,r9[0x0]
800093c2:	6e 0a       	ld.w	r10,r7[0x0]
800093c4:	12 3a       	cp.w	r10,r9
800093c6:	c0 70       	breq	800093d4 <xTaskCheckForTimeOut+0x2c>
800093c8:	49 19       	lddpc	r9,8000940c <xTaskCheckForTimeOut+0x64>
800093ca:	72 09       	ld.w	r9,r9[0x0]
800093cc:	6e 1a       	ld.w	r10,r7[0x4]
800093ce:	12 3a       	cp.w	r10,r9
800093d0:	e0 88 00 14 	brls	800093f8 <xTaskCheckForTimeOut+0x50>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
800093d4:	48 e9       	lddpc	r9,8000940c <xTaskCheckForTimeOut+0x64>
800093d6:	72 0a       	ld.w	r10,r9[0x0]
800093d8:	6e 19       	ld.w	r9,r7[0x4]
800093da:	12 1a       	sub	r10,r9
800093dc:	14 38       	cp.w	r8,r10
800093de:	e0 88 00 0d 	brls	800093f8 <xTaskCheckForTimeOut+0x50>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
800093e2:	48 ba       	lddpc	r10,8000940c <xTaskCheckForTimeOut+0x64>
800093e4:	74 0a       	ld.w	r10,r10[0x0]
800093e6:	14 19       	sub	r9,r10
800093e8:	f2 08 00 08 	add	r8,r9,r8
800093ec:	8d 08       	st.w	r6[0x0],r8
			vTaskSetTimeOutState( pxTimeOut );
800093ee:	0e 9c       	mov	r12,r7
800093f0:	f0 1f 00 08 	mcall	80009410 <xTaskCheckForTimeOut+0x68>
800093f4:	30 07       	mov	r7,0
800093f6:	c0 28       	rjmp	800093fa <xTaskCheckForTimeOut+0x52>
800093f8:	30 17       	mov	r7,1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
800093fa:	f0 1f 00 07 	mcall	80009414 <xTaskCheckForTimeOut+0x6c>

	return xReturn;
}
800093fe:	0e 9c       	mov	r12,r7
80009400:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80009404:	80 00       	ld.sh	r0,r0[0x0]
80009406:	88 f4       	ld.uh	r4,r4[0xe]
80009408:	00 00       	add	r0,r0
8000940a:	11 68       	ld.uh	r8,--r8
8000940c:	00 00       	add	r0,r0
8000940e:	12 50       	eor	r0,r9
80009410:	80 00       	ld.sh	r0,r0[0x0]
80009412:	91 0c       	st.w	r8[0x0],r12
80009414:	80 00       	ld.sh	r0,r0[0x0]
80009416:	8a 00       	ld.sh	r0,r5[0x0]

80009418 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
80009418:	eb cd 40 80 	pushm	r7,lr
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
8000941c:	f0 1f 00 05 	mcall	80009430 <xTaskGetTickCount+0x18>
	{
		xTicks = xTickCount;
80009420:	48 58       	lddpc	r8,80009434 <xTaskGetTickCount+0x1c>
80009422:	70 07       	ld.w	r7,r8[0x0]
	}
	taskEXIT_CRITICAL();
80009424:	f0 1f 00 05 	mcall	80009438 <xTaskGetTickCount+0x20>

	return xTicks;
}
80009428:	0e 9c       	mov	r12,r7
8000942a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000942e:	00 00       	add	r0,r0
80009430:	80 00       	ld.sh	r0,r0[0x0]
80009432:	88 f4       	ld.uh	r4,r4[0xe]
80009434:	00 00       	add	r0,r0
80009436:	12 50       	eor	r0,r9
80009438:	80 00       	ld.sh	r0,r0[0x0]
8000943a:	8a 00       	ld.sh	r0,r5[0x0]

8000943c <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
8000943c:	eb cd 40 fe 	pushm	r1-r7,lr
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
80009440:	f0 1f 00 2c 	mcall	800094f0 <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;
80009444:	4a c8       	lddpc	r8,800094f4 <xTaskResumeAll+0xb8>
80009446:	70 09       	ld.w	r9,r8[0x0]
80009448:	20 19       	sub	r9,1
8000944a:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
8000944c:	70 08       	ld.w	r8,r8[0x0]
8000944e:	58 08       	cp.w	r8,0
80009450:	c4 91       	brne	800094e2 <xTaskResumeAll+0xa6>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
80009452:	4a a8       	lddpc	r8,800094f8 <xTaskResumeAll+0xbc>
80009454:	70 08       	ld.w	r8,r8[0x0]
80009456:	58 08       	cp.w	r8,0
80009458:	c4 50       	breq	800094e2 <xTaskResumeAll+0xa6>
8000945a:	30 04       	mov	r4,0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
8000945c:	4a 85       	lddpc	r5,800094fc <xTaskResumeAll+0xc0>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
8000945e:	4a 93       	lddpc	r3,80009500 <xTaskResumeAll+0xc4>
80009460:	4a 92       	lddpc	r2,80009504 <xTaskResumeAll+0xc8>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80009462:	4a a1       	lddpc	r1,80009508 <xTaskResumeAll+0xcc>
80009464:	c1 e8       	rjmp	800094a0 <xTaskResumeAll+0x64>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
80009466:	6a 38       	ld.w	r8,r5[0xc]
80009468:	70 37       	ld.w	r7,r8[0xc]
					vListRemove( &( pxTCB->xEventListItem ) );
8000946a:	ee cc ff e8 	sub	r12,r7,-24
8000946e:	f0 1f 00 28 	mcall	8000950c <xTaskResumeAll+0xd0>
					vListRemove( &( pxTCB->xGenericListItem ) );
80009472:	ee c6 ff fc 	sub	r6,r7,-4
80009476:	0c 9c       	mov	r12,r6
80009478:	f0 1f 00 25 	mcall	8000950c <xTaskResumeAll+0xd0>
					prvAddTaskToReadyQueue( pxTCB );
8000947c:	6e bc       	ld.w	r12,r7[0x2c]
8000947e:	66 08       	ld.w	r8,r3[0x0]
80009480:	10 3c       	cp.w	r12,r8
80009482:	e7 fc ba 00 	st.whi	r3[0x0],r12
80009486:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
8000948a:	0c 9b       	mov	r11,r6
8000948c:	e4 0c 00 2c 	add	r12,r2,r12<<0x2
80009490:	f0 1f 00 20 	mcall	80009510 <xTaskResumeAll+0xd4>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80009494:	62 08       	ld.w	r8,r1[0x0]
80009496:	6e b9       	ld.w	r9,r7[0x2c]
80009498:	70 b8       	ld.w	r8,r8[0x2c]
8000949a:	10 39       	cp.w	r9,r8
8000949c:	f9 b4 02 01 	movhs	r4,1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
800094a0:	6a 08       	ld.w	r8,r5[0x0]
800094a2:	58 08       	cp.w	r8,0
800094a4:	ce 11       	brne	80009466 <xTaskResumeAll+0x2a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
800094a6:	49 c8       	lddpc	r8,80009514 <xTaskResumeAll+0xd8>
800094a8:	70 08       	ld.w	r8,r8[0x0]
800094aa:	58 08       	cp.w	r8,0
800094ac:	c0 f0       	breq	800094ca <xTaskResumeAll+0x8e>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
800094ae:	49 a8       	lddpc	r8,80009514 <xTaskResumeAll+0xd8>
800094b0:	70 08       	ld.w	r8,r8[0x0]
800094b2:	58 08       	cp.w	r8,0
800094b4:	c1 10       	breq	800094d6 <xTaskResumeAll+0x9a>
					{
						vTaskIncrementTick();
						--uxMissedTicks;
800094b6:	49 87       	lddpc	r7,80009514 <xTaskResumeAll+0xd8>
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
800094b8:	f0 1f 00 18 	mcall	80009518 <xTaskResumeAll+0xdc>
						--uxMissedTicks;
800094bc:	6e 08       	ld.w	r8,r7[0x0]
800094be:	20 18       	sub	r8,1
800094c0:	8f 08       	st.w	r7[0x0],r8
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
800094c2:	6e 08       	ld.w	r8,r7[0x0]
800094c4:	58 08       	cp.w	r8,0
800094c6:	cf 91       	brne	800094b8 <xTaskResumeAll+0x7c>
800094c8:	c0 78       	rjmp	800094d6 <xTaskResumeAll+0x9a>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
800094ca:	58 14       	cp.w	r4,1
800094cc:	c0 50       	breq	800094d6 <xTaskResumeAll+0x9a>
800094ce:	49 48       	lddpc	r8,8000951c <xTaskResumeAll+0xe0>
800094d0:	70 08       	ld.w	r8,r8[0x0]
800094d2:	58 18       	cp.w	r8,1
800094d4:	c0 71       	brne	800094e2 <xTaskResumeAll+0xa6>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
800094d6:	30 09       	mov	r9,0
800094d8:	49 18       	lddpc	r8,8000951c <xTaskResumeAll+0xe0>
800094da:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
800094dc:	d7 33       	scall
800094de:	30 17       	mov	r7,1
800094e0:	c0 28       	rjmp	800094e4 <xTaskResumeAll+0xa8>
800094e2:	30 07       	mov	r7,0
				}
			}
		}
	}
	taskEXIT_CRITICAL();
800094e4:	f0 1f 00 0f 	mcall	80009520 <xTaskResumeAll+0xe4>

	return xAlreadyYielded;
}
800094e8:	0e 9c       	mov	r12,r7
800094ea:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
800094ee:	00 00       	add	r0,r0
800094f0:	80 00       	ld.sh	r0,r0[0x0]
800094f2:	88 f4       	ld.uh	r4,r4[0xe]
800094f4:	00 00       	add	r0,r0
800094f6:	12 54       	eor	r4,r9
800094f8:	00 00       	add	r0,r0
800094fa:	12 70       	tst	r0,r9
800094fc:	00 00       	add	r0,r0
800094fe:	12 28       	rsub	r8,r9
80009500:	00 00       	add	r0,r0
80009502:	12 8c       	andn	r12,r9
80009504:	00 00       	add	r0,r0
80009506:	11 70       	ld.ub	r0,--r8
80009508:	00 00       	add	r0,r0
8000950a:	12 24       	rsub	r4,r9
8000950c:	80 00       	ld.sh	r0,r0[0x0]
8000950e:	88 3a       	ld.sh	r10,r4[0x6]
80009510:	80 00       	ld.sh	r0,r0[0x0]
80009512:	87 ea       	st.w	r3[0x38],r10
80009514:	00 00       	add	r0,r0
80009516:	11 54       	ld.sh	r4,--r8
80009518:	80 00       	ld.sh	r0,r0[0x0]
8000951a:	92 94       	ld.uh	r4,r9[0x2]
8000951c:	00 00       	add	r0,r0
8000951e:	12 74       	tst	r4,r9
80009520:	80 00       	ld.sh	r0,r0[0x0]
80009522:	8a 00       	ld.sh	r0,r5[0x0]

80009524 <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
80009524:	eb cd 40 80 	pushm	r7,lr
80009528:	18 97       	mov	r7,r12
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
8000952a:	49 08       	lddpc	r8,80009568 <prvAddCurrentTaskToDelayedList+0x44>
8000952c:	70 08       	ld.w	r8,r8[0x0]
8000952e:	91 1c       	st.w	r8[0x4],r12

	if( xTimeToWake < xTickCount )
80009530:	48 f8       	lddpc	r8,8000956c <prvAddCurrentTaskToDelayedList+0x48>
80009532:	70 08       	ld.w	r8,r8[0x0]
80009534:	10 3c       	cp.w	r12,r8
80009536:	c0 a2       	brcc	8000954a <prvAddCurrentTaskToDelayedList+0x26>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80009538:	48 c8       	lddpc	r8,80009568 <prvAddCurrentTaskToDelayedList+0x44>
8000953a:	70 0b       	ld.w	r11,r8[0x0]
8000953c:	48 d8       	lddpc	r8,80009570 <prvAddCurrentTaskToDelayedList+0x4c>
8000953e:	70 0c       	ld.w	r12,r8[0x0]
80009540:	2f cb       	sub	r11,-4
80009542:	f0 1f 00 0d 	mcall	80009574 <prvAddCurrentTaskToDelayedList+0x50>
80009546:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
8000954a:	48 88       	lddpc	r8,80009568 <prvAddCurrentTaskToDelayedList+0x44>
8000954c:	70 0b       	ld.w	r11,r8[0x0]
8000954e:	48 b8       	lddpc	r8,80009578 <prvAddCurrentTaskToDelayedList+0x54>
80009550:	70 0c       	ld.w	r12,r8[0x0]
80009552:	2f cb       	sub	r11,-4
80009554:	f0 1f 00 08 	mcall	80009574 <prvAddCurrentTaskToDelayedList+0x50>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
80009558:	48 98       	lddpc	r8,8000957c <prvAddCurrentTaskToDelayedList+0x58>
8000955a:	70 08       	ld.w	r8,r8[0x0]
8000955c:	10 37       	cp.w	r7,r8
8000955e:	c0 32       	brcc	80009564 <prvAddCurrentTaskToDelayedList+0x40>
		{
			xNextTaskUnblockTime = xTimeToWake;
80009560:	48 78       	lddpc	r8,8000957c <prvAddCurrentTaskToDelayedList+0x58>
80009562:	91 07       	st.w	r8[0x0],r7
80009564:	e3 cd 80 80 	ldm	sp++,r7,pc
80009568:	00 00       	add	r0,r0
8000956a:	12 24       	rsub	r4,r9
8000956c:	00 00       	add	r0,r0
8000956e:	12 50       	eor	r0,r9
80009570:	00 00       	add	r0,r0
80009572:	11 6c       	ld.uh	r12,--r8
80009574:	80 00       	ld.sh	r0,r0[0x0]
80009576:	88 06       	ld.sh	r6,r4[0x0]
80009578:	00 00       	add	r0,r0
8000957a:	11 5c       	ld.sh	r12,--r8
8000957c:	00 00       	add	r0,r0
8000957e:	05 34       	ld.ub	r4,r2++

80009580 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
80009580:	eb cd 40 c0 	pushm	r6-r7,lr
80009584:	18 96       	mov	r6,r12
80009586:	16 97       	mov	r7,r11
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0 ) );

		vTaskSuspendAll();
80009588:	f0 1f 00 18 	mcall	800095e8 <vTaskDelayUntil+0x68>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
8000958c:	6c 08       	ld.w	r8,r6[0x0]
8000958e:	10 07       	add	r7,r8

			if( xTickCount < *pxPreviousWakeTime )
80009590:	49 79       	lddpc	r9,800095ec <vTaskDelayUntil+0x6c>
80009592:	72 09       	ld.w	r9,r9[0x0]
80009594:	12 38       	cp.w	r8,r9
80009596:	e0 88 00 0c 	brls	800095ae <vTaskDelayUntil+0x2e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
8000959a:	0e 38       	cp.w	r8,r7
8000959c:	e0 88 00 22 	brls	800095e0 <vTaskDelayUntil+0x60>
800095a0:	49 38       	lddpc	r8,800095ec <vTaskDelayUntil+0x6c>
800095a2:	70 08       	ld.w	r8,r8[0x0]
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
800095a4:	8d 07       	st.w	r6[0x0],r7

			if( xShouldDelay != pdFALSE )
800095a6:	10 37       	cp.w	r7,r8
800095a8:	e0 88 00 14 	brls	800095d0 <vTaskDelayUntil+0x50>
800095ac:	c0 a8       	rjmp	800095c0 <vTaskDelayUntil+0x40>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
800095ae:	0e 38       	cp.w	r8,r7
800095b0:	e0 8b 00 16 	brhi	800095dc <vTaskDelayUntil+0x5c>
800095b4:	48 e8       	lddpc	r8,800095ec <vTaskDelayUntil+0x6c>
800095b6:	70 08       	ld.w	r8,r8[0x0]
800095b8:	10 37       	cp.w	r7,r8
800095ba:	e0 8b 00 11 	brhi	800095dc <vTaskDelayUntil+0x5c>
800095be:	c1 18       	rjmp	800095e0 <vTaskDelayUntil+0x60>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800095c0:	48 c8       	lddpc	r8,800095f0 <vTaskDelayUntil+0x70>
800095c2:	70 0c       	ld.w	r12,r8[0x0]
800095c4:	2f cc       	sub	r12,-4
800095c6:	f0 1f 00 0c 	mcall	800095f4 <vTaskDelayUntil+0x74>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
800095ca:	0e 9c       	mov	r12,r7
800095cc:	f0 1f 00 0b 	mcall	800095f8 <vTaskDelayUntil+0x78>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
800095d0:	f0 1f 00 0b 	mcall	800095fc <vTaskDelayUntil+0x7c>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
800095d4:	c0 81       	brne	800095e4 <vTaskDelayUntil+0x64>
		{
			portYIELD_WITHIN_API();
800095d6:	d7 33       	scall
800095d8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
800095dc:	8d 07       	st.w	r6[0x0],r7
800095de:	cf 1b       	rjmp	800095c0 <vTaskDelayUntil+0x40>
800095e0:	8d 07       	st.w	r6[0x0],r7
800095e2:	cf 7b       	rjmp	800095d0 <vTaskDelayUntil+0x50>
800095e4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800095e8:	80 00       	ld.sh	r0,r0[0x0]
800095ea:	90 80       	ld.uh	r0,r8[0x0]
800095ec:	00 00       	add	r0,r0
800095ee:	12 50       	eor	r0,r9
800095f0:	00 00       	add	r0,r0
800095f2:	12 24       	rsub	r4,r9
800095f4:	80 00       	ld.sh	r0,r0[0x0]
800095f6:	88 3a       	ld.sh	r10,r4[0x6]
800095f8:	80 00       	ld.sh	r0,r0[0x0]
800095fa:	95 24       	st.w	r10[0x8],r4
800095fc:	80 00       	ld.sh	r0,r0[0x0]
800095fe:	94 3c       	ld.sh	r12,r10[0x6]

80009600 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
80009600:	eb cd 40 c0 	pushm	r6-r7,lr
80009604:	16 96       	mov	r6,r11
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
80009606:	48 e7       	lddpc	r7,8000963c <vTaskPlaceOnEventList+0x3c>
80009608:	6e 0b       	ld.w	r11,r7[0x0]
8000960a:	2e 8b       	sub	r11,-24
8000960c:	f0 1f 00 0d 	mcall	80009640 <vTaskPlaceOnEventList+0x40>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80009610:	6e 0c       	ld.w	r12,r7[0x0]
80009612:	2f cc       	sub	r12,-4
80009614:	f0 1f 00 0c 	mcall	80009644 <vTaskPlaceOnEventList+0x44>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
80009618:	5b f6       	cp.w	r6,-1
8000961a:	c0 81       	brne	8000962a <vTaskPlaceOnEventList+0x2a>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
8000961c:	6e 0b       	ld.w	r11,r7[0x0]
8000961e:	2f cb       	sub	r11,-4
80009620:	48 ac       	lddpc	r12,80009648 <vTaskPlaceOnEventList+0x48>
80009622:	f0 1f 00 0b 	mcall	8000964c <vTaskPlaceOnEventList+0x4c>
80009626:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
8000962a:	48 a8       	lddpc	r8,80009650 <vTaskPlaceOnEventList+0x50>
8000962c:	70 0c       	ld.w	r12,r8[0x0]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
8000962e:	ec 0c 00 0c 	add	r12,r6,r12
80009632:	f0 1f 00 09 	mcall	80009654 <vTaskPlaceOnEventList+0x54>
80009636:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000963a:	00 00       	add	r0,r0
8000963c:	00 00       	add	r0,r0
8000963e:	12 24       	rsub	r4,r9
80009640:	80 00       	ld.sh	r0,r0[0x0]
80009642:	88 06       	ld.sh	r6,r4[0x0]
80009644:	80 00       	ld.sh	r0,r0[0x0]
80009646:	88 3a       	ld.sh	r10,r4[0x6]
80009648:	00 00       	add	r0,r0
8000964a:	12 78       	tst	r8,r9
8000964c:	80 00       	ld.sh	r0,r0[0x0]
8000964e:	87 ea       	st.w	r3[0x38],r10
80009650:	00 00       	add	r0,r0
80009652:	12 50       	eor	r0,r9
80009654:	80 00       	ld.sh	r0,r0[0x0]
80009656:	95 24       	st.w	r10[0x8],r4

80009658 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
80009658:	eb cd 40 f8 	pushm	r3-r7,lr
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
8000965c:	49 67       	lddpc	r7,800096b4 <prvIdleTask+0x5c>
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
8000965e:	49 74       	lddpc	r4,800096b8 <prvIdleTask+0x60>

				taskENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					--uxCurrentNumberOfTasks;
80009660:	49 73       	lddpc	r3,800096bc <prvIdleTask+0x64>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80009662:	49 85       	lddpc	r5,800096c0 <prvIdleTask+0x68>
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80009664:	6e 08       	ld.w	r8,r7[0x0]
80009666:	58 08       	cp.w	r8,0
80009668:	c1 e0       	breq	800096a4 <prvIdleTask+0x4c>
		{
			vTaskSuspendAll();
8000966a:	f0 1f 00 17 	mcall	800096c4 <prvIdleTask+0x6c>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
8000966e:	68 06       	ld.w	r6,r4[0x0]
			xTaskResumeAll();
80009670:	f0 1f 00 16 	mcall	800096c8 <prvIdleTask+0x70>

			if( xListIsEmpty == pdFALSE )
80009674:	58 06       	cp.w	r6,0
80009676:	c1 70       	breq	800096a4 <prvIdleTask+0x4c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
80009678:	f0 1f 00 15 	mcall	800096cc <prvIdleTask+0x74>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
8000967c:	68 38       	ld.w	r8,r4[0xc]
8000967e:	70 36       	ld.w	r6,r8[0xc]
					vListRemove( &( pxTCB->xGenericListItem ) );
80009680:	ec cc ff fc 	sub	r12,r6,-4
80009684:	f0 1f 00 13 	mcall	800096d0 <prvIdleTask+0x78>
					--uxCurrentNumberOfTasks;
80009688:	66 08       	ld.w	r8,r3[0x0]
8000968a:	20 18       	sub	r8,1
8000968c:	87 08       	st.w	r3[0x0],r8
					--uxTasksDeleted;
8000968e:	6e 08       	ld.w	r8,r7[0x0]
80009690:	20 18       	sub	r8,1
80009692:	8f 08       	st.w	r7[0x0],r8
				}
				taskEXIT_CRITICAL();
80009694:	f0 1f 00 10 	mcall	800096d4 <prvIdleTask+0x7c>

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
80009698:	6c cc       	ld.w	r12,r6[0x30]
8000969a:	f0 1f 00 10 	mcall	800096d8 <prvIdleTask+0x80>
		vPortFree( pxTCB );
8000969e:	0c 9c       	mov	r12,r6
800096a0:	f0 1f 00 0e 	mcall	800096d8 <prvIdleTask+0x80>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
800096a4:	6a 08       	ld.w	r8,r5[0x0]
800096a6:	58 18       	cp.w	r8,1
800096a8:	e0 88 00 03 	brls	800096ae <prvIdleTask+0x56>
			{
				taskYIELD();
800096ac:	d7 33       	scall
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
800096ae:	f0 1f 00 0c 	mcall	800096dc <prvIdleTask+0x84>
		}
		#endif
	}
800096b2:	cd 9b       	rjmp	80009664 <prvIdleTask+0xc>
800096b4:	00 00       	add	r0,r0
800096b6:	11 64       	ld.uh	r4,--r8
800096b8:	00 00       	add	r0,r0
800096ba:	12 10       	sub	r0,r9
800096bc:	00 00       	add	r0,r0
800096be:	12 70       	tst	r0,r9
800096c0:	00 00       	add	r0,r0
800096c2:	11 70       	ld.ub	r0,--r8
800096c4:	80 00       	ld.sh	r0,r0[0x0]
800096c6:	90 80       	ld.uh	r0,r8[0x0]
800096c8:	80 00       	ld.sh	r0,r0[0x0]
800096ca:	94 3c       	ld.sh	r12,r10[0x6]
800096cc:	80 00       	ld.sh	r0,r0[0x0]
800096ce:	88 f4       	ld.uh	r4,r4[0xe]
800096d0:	80 00       	ld.sh	r0,r0[0x0]
800096d2:	88 3a       	ld.sh	r10,r4[0x6]
800096d4:	80 00       	ld.sh	r0,r0[0x0]
800096d6:	8a 00       	ld.sh	r0,r5[0x0]
800096d8:	80 00       	ld.sh	r0,r0[0x0]
800096da:	8b 38       	st.w	r5[0xc],r8
800096dc:	80 00       	ld.sh	r0,r0[0x0]
800096de:	20 34       	sub	r4,3

800096e0 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
800096e0:	d4 31       	pushm	r0-r7,lr
800096e2:	20 1d       	sub	sp,4
800096e4:	fa c4 ff d8 	sub	r4,sp,-40
800096e8:	50 0c       	stdsp	sp[0x0],r12
800096ea:	16 91       	mov	r1,r11
800096ec:	14 97       	mov	r7,r10
800096ee:	12 90       	mov	r0,r9
800096f0:	10 93       	mov	r3,r8
800096f2:	68 02       	ld.w	r2,r4[0x0]
800096f4:	68 16       	ld.w	r6,r4[0x4]
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
800096f6:	34 8c       	mov	r12,72
800096f8:	f0 1f 00 5c 	mcall	80009868 <xTaskGenericCreate+0x188>
800096fc:	18 95       	mov	r5,r12

	if( pxNewTCB != NULL )
800096fe:	c0 31       	brne	80009704 <xTaskGenericCreate+0x24>
80009700:	3f fc       	mov	r12,-1
80009702:	ca f8       	rjmp	80009860 <xTaskGenericCreate+0x180>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80009704:	58 06       	cp.w	r6,0
80009706:	e0 81 00 af 	brne	80009864 <xTaskGenericCreate+0x184>
8000970a:	0e 9c       	mov	r12,r7
8000970c:	5c 7c       	castu.h	r12
8000970e:	a3 6c       	lsl	r12,0x2
80009710:	f0 1f 00 56 	mcall	80009868 <xTaskGenericCreate+0x188>
80009714:	18 96       	mov	r6,r12
80009716:	8b cc       	st.w	r5[0x30],r12

		if( pxNewTCB->pxStack == NULL )
80009718:	c0 61       	brne	80009724 <xTaskGenericCreate+0x44>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
8000971a:	0a 9c       	mov	r12,r5
8000971c:	f0 1f 00 54 	mcall	8000986c <xTaskGenericCreate+0x18c>
80009720:	3f fc       	mov	r12,-1
80009722:	c9 f8       	rjmp	80009860 <xTaskGenericCreate+0x180>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
80009724:	5c 77       	castu.h	r7
80009726:	ee 0a 15 02 	lsl	r10,r7,0x2
8000972a:	e0 6b 00 a5 	mov	r11,165
8000972e:	0c 9c       	mov	r12,r6
80009730:	f0 1f 00 50 	mcall	80009870 <xTaskGenericCreate+0x190>
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
80009734:	ee c6 00 01 	sub	r6,r7,1
80009738:	6a c8       	ld.w	r8,r5[0x30]
8000973a:	f0 06 00 26 	add	r6,r8,r6<<0x2
8000973e:	e0 16 ff fc 	andl	r6,0xfffc
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
80009742:	31 0a       	mov	r10,16
80009744:	02 9b       	mov	r11,r1
80009746:	ea cc ff cc 	sub	r12,r5,-52
8000974a:	f0 1f 00 4b 	mcall	80009874 <xTaskGenericCreate+0x194>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
8000974e:	30 08       	mov	r8,0
80009750:	eb 68 00 43 	st.b	r5[67],r8
80009754:	58 73       	cp.w	r3,7
80009756:	e6 07 17 80 	movls	r7,r3
8000975a:	f9 b7 0b 07 	movhi	r7,7
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
8000975e:	8b b7       	st.w	r5[0x2c],r7
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
80009760:	eb 47 00 44 	st.w	r5[68],r7
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
80009764:	ea c4 ff fc 	sub	r4,r5,-4
80009768:	08 9c       	mov	r12,r4
8000976a:	f0 1f 00 44 	mcall	80009878 <xTaskGenericCreate+0x198>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
8000976e:	ea cc ff e8 	sub	r12,r5,-24
80009772:	f0 1f 00 42 	mcall	80009878 <xTaskGenericCreate+0x198>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
80009776:	8b 45       	st.w	r5[0x10],r5

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
80009778:	ee 07 11 08 	rsub	r7,r7,8
8000977c:	8b 67       	st.w	r5[0x18],r7
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
8000977e:	8b 95       	st.w	r5[0x24],r5
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
80009780:	00 9a       	mov	r10,r0
80009782:	40 0b       	lddsp	r11,sp[0x0]
80009784:	0c 9c       	mov	r12,r6
80009786:	f0 1f 00 3e 	mcall	8000987c <xTaskGenericCreate+0x19c>
8000978a:	8b 0c       	st.w	r5[0x0],r12
		if( ( void * ) pxCreatedTask != NULL )
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
8000978c:	58 02       	cp.w	r2,0
8000978e:	e5 f5 1a 00 	st.wne	r2[0x0],r5
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
80009792:	f0 1f 00 3c 	mcall	80009880 <xTaskGenericCreate+0x1a0>
		{
			uxCurrentNumberOfTasks++;
80009796:	4b c8       	lddpc	r8,80009884 <xTaskGenericCreate+0x1a4>
80009798:	70 09       	ld.w	r9,r8[0x0]
8000979a:	2f f9       	sub	r9,-1
8000979c:	91 09       	st.w	r8[0x0],r9
			if( pxCurrentTCB == NULL )
8000979e:	4b b8       	lddpc	r8,80009888 <xTaskGenericCreate+0x1a8>
800097a0:	70 08       	ld.w	r8,r8[0x0]
800097a2:	58 08       	cp.w	r8,0
800097a4:	c2 61       	brne	800097f0 <xTaskGenericCreate+0x110>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
800097a6:	4b 98       	lddpc	r8,80009888 <xTaskGenericCreate+0x1a8>
800097a8:	91 05       	st.w	r8[0x0],r5

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
800097aa:	4b 78       	lddpc	r8,80009884 <xTaskGenericCreate+0x1a4>
800097ac:	70 08       	ld.w	r8,r8[0x0]
800097ae:	58 18       	cp.w	r8,1
800097b0:	c2 b1       	brne	80009806 <xTaskGenericCreate+0x126>
800097b2:	4b 77       	lddpc	r7,8000988c <xTaskGenericCreate+0x1ac>

/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
800097b4:	ee c6 ff 60 	sub	r6,r7,-160
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
800097b8:	0e 9c       	mov	r12,r7
800097ba:	f0 1f 00 36 	mcall	80009890 <xTaskGenericCreate+0x1b0>
800097be:	2e c7       	sub	r7,-20

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
800097c0:	0c 37       	cp.w	r7,r6
800097c2:	cf b1       	brne	800097b8 <xTaskGenericCreate+0xd8>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
800097c4:	4b 47       	lddpc	r7,80009894 <xTaskGenericCreate+0x1b4>
800097c6:	0e 9c       	mov	r12,r7
800097c8:	f0 1f 00 32 	mcall	80009890 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
800097cc:	4b 36       	lddpc	r6,80009898 <xTaskGenericCreate+0x1b8>
800097ce:	0c 9c       	mov	r12,r6
800097d0:	f0 1f 00 30 	mcall	80009890 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xPendingReadyList );
800097d4:	4b 2c       	lddpc	r12,8000989c <xTaskGenericCreate+0x1bc>
800097d6:	f0 1f 00 2f 	mcall	80009890 <xTaskGenericCreate+0x1b0>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
800097da:	4b 2c       	lddpc	r12,800098a0 <xTaskGenericCreate+0x1c0>
800097dc:	f0 1f 00 2d 	mcall	80009890 <xTaskGenericCreate+0x1b0>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
800097e0:	4b 1c       	lddpc	r12,800098a4 <xTaskGenericCreate+0x1c4>
800097e2:	f0 1f 00 2c 	mcall	80009890 <xTaskGenericCreate+0x1b0>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
800097e6:	4b 18       	lddpc	r8,800098a8 <xTaskGenericCreate+0x1c8>
800097e8:	91 07       	st.w	r8[0x0],r7
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
800097ea:	4b 18       	lddpc	r8,800098ac <xTaskGenericCreate+0x1cc>
800097ec:	91 06       	st.w	r8[0x0],r6
800097ee:	c0 c8       	rjmp	80009806 <xTaskGenericCreate+0x126>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
800097f0:	4b 08       	lddpc	r8,800098b0 <xTaskGenericCreate+0x1d0>
800097f2:	70 08       	ld.w	r8,r8[0x0]
800097f4:	58 08       	cp.w	r8,0
800097f6:	c0 81       	brne	80009806 <xTaskGenericCreate+0x126>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
800097f8:	4a 48       	lddpc	r8,80009888 <xTaskGenericCreate+0x1a8>
800097fa:	70 08       	ld.w	r8,r8[0x0]
800097fc:	70 b8       	ld.w	r8,r8[0x2c]
800097fe:	10 33       	cp.w	r3,r8
80009800:	c0 33       	brcs	80009806 <xTaskGenericCreate+0x126>
					{
						pxCurrentTCB = pxNewTCB;
80009802:	4a 28       	lddpc	r8,80009888 <xTaskGenericCreate+0x1a8>
80009804:	91 05       	st.w	r8[0x0],r5
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
80009806:	6a b8       	ld.w	r8,r5[0x2c]
80009808:	4a b9       	lddpc	r9,800098b4 <xTaskGenericCreate+0x1d4>
8000980a:	72 09       	ld.w	r9,r9[0x0]
8000980c:	12 38       	cp.w	r8,r9
8000980e:	e0 88 00 04 	brls	80009816 <xTaskGenericCreate+0x136>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
80009812:	4a 99       	lddpc	r9,800098b4 <xTaskGenericCreate+0x1d4>
80009814:	93 08       	st.w	r9[0x0],r8
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
80009816:	4a 98       	lddpc	r8,800098b8 <xTaskGenericCreate+0x1d8>
80009818:	70 09       	ld.w	r9,r8[0x0]
8000981a:	2f f9       	sub	r9,-1
8000981c:	91 09       	st.w	r8[0x0],r9

			prvAddTaskToReadyQueue( pxNewTCB );
8000981e:	6a b8       	ld.w	r8,r5[0x2c]
80009820:	4a 79       	lddpc	r9,800098bc <xTaskGenericCreate+0x1dc>
80009822:	72 09       	ld.w	r9,r9[0x0]
80009824:	12 38       	cp.w	r8,r9
80009826:	e0 88 00 04 	brls	8000982e <xTaskGenericCreate+0x14e>
8000982a:	4a 59       	lddpc	r9,800098bc <xTaskGenericCreate+0x1dc>
8000982c:	93 08       	st.w	r9[0x0],r8
8000982e:	6a bc       	ld.w	r12,r5[0x2c]
80009830:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80009834:	08 9b       	mov	r11,r4
80009836:	49 68       	lddpc	r8,8000988c <xTaskGenericCreate+0x1ac>
80009838:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
8000983c:	f0 1f 00 21 	mcall	800098c0 <xTaskGenericCreate+0x1e0>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
80009840:	f0 1f 00 21 	mcall	800098c4 <xTaskGenericCreate+0x1e4>
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
80009844:	49 b8       	lddpc	r8,800098b0 <xTaskGenericCreate+0x1d0>
80009846:	70 08       	ld.w	r8,r8[0x0]
80009848:	58 08       	cp.w	r8,0
8000984a:	c0 a0       	breq	8000985e <xTaskGenericCreate+0x17e>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
8000984c:	48 f8       	lddpc	r8,80009888 <xTaskGenericCreate+0x1a8>
8000984e:	70 08       	ld.w	r8,r8[0x0]
80009850:	70 b8       	ld.w	r8,r8[0x2c]
80009852:	10 33       	cp.w	r3,r8
80009854:	e0 88 00 05 	brls	8000985e <xTaskGenericCreate+0x17e>
			{
				portYIELD_WITHIN_API();
80009858:	d7 33       	scall
8000985a:	30 1c       	mov	r12,1
8000985c:	c0 28       	rjmp	80009860 <xTaskGenericCreate+0x180>
8000985e:	30 1c       	mov	r12,1
			}
		}
	}

	return xReturn;
}
80009860:	2f fd       	sub	sp,-4
80009862:	d8 32       	popm	r0-r7,pc
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80009864:	99 c6       	st.w	r12[0x30],r6
80009866:	c5 fb       	rjmp	80009724 <xTaskGenericCreate+0x44>
80009868:	80 00       	ld.sh	r0,r0[0x0]
8000986a:	8b 60       	st.w	r5[0x18],r0
8000986c:	80 00       	ld.sh	r0,r0[0x0]
8000986e:	8b 38       	st.w	r5[0xc],r8
80009870:	80 00       	ld.sh	r0,r0[0x0]
80009872:	a5 b2       	sbr	r2,0x5
80009874:	80 00       	ld.sh	r0,r0[0x0]
80009876:	a9 04       	ld.d	r4,r4
80009878:	80 00       	ld.sh	r0,r0[0x0]
8000987a:	87 e4       	st.w	r3[0x38],r4
8000987c:	80 00       	ld.sh	r0,r0[0x0]
8000987e:	88 60       	ld.sh	r0,r4[0xc]
80009880:	80 00       	ld.sh	r0,r0[0x0]
80009882:	88 f4       	ld.uh	r4,r4[0xe]
80009884:	00 00       	add	r0,r0
80009886:	12 70       	tst	r0,r9
80009888:	00 00       	add	r0,r0
8000988a:	12 24       	rsub	r4,r9
8000988c:	00 00       	add	r0,r0
8000988e:	11 70       	ld.ub	r0,--r8
80009890:	80 00       	ld.sh	r0,r0[0x0]
80009892:	87 d0       	st.w	r3[0x34],r0
80009894:	00 00       	add	r0,r0
80009896:	12 3c       	cp.w	r12,r9
80009898:	00 00       	add	r0,r0
8000989a:	12 58       	eor	r8,r9
8000989c:	00 00       	add	r0,r0
8000989e:	12 28       	rsub	r8,r9
800098a0:	00 00       	add	r0,r0
800098a2:	12 10       	sub	r0,r9
800098a4:	00 00       	add	r0,r0
800098a6:	12 78       	tst	r8,r9
800098a8:	00 00       	add	r0,r0
800098aa:	11 5c       	ld.sh	r12,--r8
800098ac:	00 00       	add	r0,r0
800098ae:	11 6c       	ld.uh	r12,--r8
800098b0:	00 00       	add	r0,r0
800098b2:	11 60       	ld.uh	r0,--r8
800098b4:	00 00       	add	r0,r0
800098b6:	11 58       	ld.sh	r8,--r8
800098b8:	00 00       	add	r0,r0
800098ba:	12 6c       	and	r12,r9
800098bc:	00 00       	add	r0,r0
800098be:	12 8c       	andn	r12,r9
800098c0:	80 00       	ld.sh	r0,r0[0x0]
800098c2:	87 ea       	st.w	r3[0x38],r10
800098c4:	80 00       	ld.sh	r0,r0[0x0]
800098c6:	8a 00       	ld.sh	r0,r5[0x0]

800098c8 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
800098c8:	d4 01       	pushm	lr
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
800098ca:	30 09       	mov	r9,0
800098cc:	1a d9       	st.w	--sp,r9
800098ce:	1a d9       	st.w	--sp,r9
800098d0:	1a d9       	st.w	--sp,r9
800098d2:	12 98       	mov	r8,r9
800098d4:	e0 6a 01 00 	mov	r10,256
800098d8:	48 9b       	lddpc	r11,800098fc <vTaskStartScheduler+0x34>
800098da:	48 ac       	lddpc	r12,80009900 <vTaskStartScheduler+0x38>
800098dc:	f0 1f 00 0a 	mcall	80009904 <vTaskStartScheduler+0x3c>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
800098e0:	2f dd       	sub	sp,-12
800098e2:	58 1c       	cp.w	r12,1
800098e4:	c0 a1       	brne	800098f8 <vTaskStartScheduler+0x30>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
800098e6:	d3 03       	ssrf	0x10

		xSchedulerRunning = pdTRUE;
800098e8:	30 19       	mov	r9,1
800098ea:	48 88       	lddpc	r8,80009908 <vTaskStartScheduler+0x40>
800098ec:	91 09       	st.w	r8[0x0],r9
		xTickCount = ( portTickType ) 0;
800098ee:	30 09       	mov	r9,0
800098f0:	48 78       	lddpc	r8,8000990c <vTaskStartScheduler+0x44>
800098f2:	91 09       	st.w	r8[0x0],r9
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
800098f4:	f0 1f 00 07 	mcall	80009910 <vTaskStartScheduler+0x48>
800098f8:	d8 02       	popm	pc
800098fa:	00 00       	add	r0,r0
800098fc:	80 01       	ld.sh	r1,r0[0x0]
800098fe:	8b d8       	st.w	r5[0x34],r8
80009900:	80 00       	ld.sh	r0,r0[0x0]
80009902:	96 58       	ld.sh	r8,r11[0xa]
80009904:	80 00       	ld.sh	r0,r0[0x0]
80009906:	96 e0       	ld.uh	r0,r11[0xc]
80009908:	00 00       	add	r0,r0
8000990a:	11 60       	ld.uh	r0,--r8
8000990c:	00 00       	add	r0,r0
8000990e:	12 50       	eor	r0,r9
80009910:	80 00       	ld.sh	r0,r0[0x0]
80009912:	89 04       	st.w	r4[0x0],r4

80009914 <PrintChar>:
	
static void task_log(void * pvParameters);

char *  PrintChar(char c, char * str)
{
	*str++ = c;
80009914:	16 cc       	st.b	r11++,r12
	return str;
}
80009916:	5e fb       	retal	r11

80009918 <PrintHex>:
	
	return str;
}

char * PrintHex(int i,char len, char * str)
{
80009918:	eb cd 40 c0 	pushm	r6-r7,lr
8000991c:	20 3d       	sub	sp,12
8000991e:	18 98       	mov	r8,r12
	char * p = str;
	char s[12];
	memset(s, 0 , 12);
80009920:	30 06       	mov	r6,0
80009922:	30 07       	mov	r7,0
80009924:	fa e7 00 00 	st.d	sp[0],r6
80009928:	30 0c       	mov	r12,0
8000992a:	50 2c       	stdsp	sp[0x8],r12
	int cnt=0;
	
	if(i)
8000992c:	58 08       	cp.w	r8,0
8000992e:	c1 30       	breq	80009954 <PrintHex+0x3c>
80009930:	18 99       	mov	r9,r12
	while(i)
	{
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
80009932:	1a 9c       	mov	r12,sp
80009934:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80009938:	58 9e       	cp.w	lr,9
8000993a:	e0 8a 00 04 	brle	80009942 <PrintHex+0x2a>
8000993e:	2c 9e       	sub	lr,-55
80009940:	c0 48       	rjmp	80009948 <PrintHex+0x30>
80009942:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80009946:	2d 0e       	sub	lr,-48
80009948:	f8 09 0b 0e 	st.b	r12[r9],lr
8000994c:	2f f9       	sub	r9,-1
		i = (i >> 4 ) & 0x0FFFFFFF;
8000994e:	a5 88       	lsr	r8,0x4
	char s[12];
	memset(s, 0 , 12);
	int cnt=0;
	
	if(i)
	while(i)
80009950:	cf 21       	brne	80009934 <PrintHex+0x1c>
80009952:	c0 48       	rjmp	8000995a <PrintHex+0x42>
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
		i = (i >> 4 ) & 0x0FFFFFFF;
		//i >>= 4
	}
	else
	s[cnt++] = '0';
80009954:	33 08       	mov	r8,48
80009956:	ba 88       	st.b	sp[0x0],r8
80009958:	30 19       	mov	r9,1
	
	if(len - cnt > 0 )
8000995a:	f6 09 01 08 	sub	r8,r11,r9
8000995e:	58 08       	cp.w	r8,0
80009960:	e0 8a 00 13 	brle	80009986 <PrintHex+0x6e>
	{
		char num = len - cnt;
80009964:	12 1b       	sub	r11,r9
80009966:	f9 db c0 08 	bfextu	r12,r11,0x0,0x8
		for(int i = 0; i < num; i++)
8000996a:	18 9e       	mov	lr,r12
8000996c:	58 0c       	cp.w	r12,0
8000996e:	e0 8a 00 0c 	brle	80009986 <PrintHex+0x6e>
80009972:	1a 9b       	mov	r11,sp
80009974:	12 0b       	add	r11,r9
80009976:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80009978:	33 07       	mov	r7,48
8000997a:	16 c7       	st.b	r11++,r7
	s[cnt++] = '0';
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
8000997c:	2f f8       	sub	r8,-1
8000997e:	1c 38       	cp.w	r8,lr
80009980:	cf d5       	brlt	8000997a <PrintHex+0x62>
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80009982:	f8 09 00 09 	add	r9,r12,r9
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80009986:	f2 c8 ff ff 	sub	r8,r9,-1
	s[cnt++] = '0';
	
	while(cnt>0)
8000998a:	f0 cb ff ff 	sub	r11,r8,-1
8000998e:	58 0b       	cp.w	r11,0
80009990:	e0 8a 00 19 	brle	800099c2 <PrintHex+0xaa>
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80009994:	fa cb ff f4 	sub	r11,sp,-12
80009998:	f6 09 00 09 	add	r9,r11,r9
8000999c:	37 8b       	mov	r11,120
8000999e:	f3 6b ff f4 	st.b	r9[-12],r11
	s[cnt++] = '0';
800099a2:	fa c9 ff f4 	sub	r9,sp,-12
800099a6:	10 09       	add	r9,r8
800099a8:	33 0b       	mov	r11,48
800099aa:	f3 6b ff f4 	st.b	r9[-12],r11
800099ae:	fa 08 00 08 	add	r8,sp,r8
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
800099b2:	fa ce 00 01 	sub	lr,sp,1
800099b6:	14 99       	mov	r9,r10
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
	*p++ = s[--cnt];
800099b8:	11 8b       	ld.ub	r11,r8[0x0]
800099ba:	12 cb       	st.b	r9++,r11
800099bc:	20 18       	sub	r8,1
	}
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
800099be:	1c 38       	cp.w	r8,lr
800099c0:	cf c1       	brne	800099b8 <PrintHex+0xa0>
	*p++ = s[--cnt];
		
	return str;
}
800099c2:	14 9c       	mov	r12,r10
800099c4:	2f dd       	sub	sp,-12
800099c6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

800099ca <PrintDec>:
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
{
800099ca:	d4 21       	pushm	r4-r7,lr
800099cc:	20 3d       	sub	sp,12
800099ce:	18 98       	mov	r8,r12
	char * p = str;
	
	int sign = i>=0 ? 0 : 1;
	char s[10];
	memset(s, 0 , 10);
800099d0:	30 06       	mov	r6,0
800099d2:	30 07       	mov	r7,0
800099d4:	fa e7 00 00 	st.d	sp[0],r6
800099d8:	30 0c       	mov	r12,0
800099da:	ba 4c       	st.h	sp[0x8],r12
	int cnt=0;
	if(sign)
800099dc:	58 08       	cp.w	r8,0
800099de:	c0 35       	brlt	800099e4 <PrintDec+0x1a>
800099e0:	14 97       	mov	r7,r10
800099e2:	c0 58       	rjmp	800099ec <PrintDec+0x22>
	{
		*p++ = '-';
800099e4:	14 97       	mov	r7,r10
800099e6:	32 d9       	mov	r9,45
800099e8:	0e c9       	st.b	r7++,r9
		i = -i;
800099ea:	5c 38       	neg	r8
	}
	
	if(i == 0 )s[cnt++] = '0';
800099ec:	58 08       	cp.w	r8,0
800099ee:	c0 51       	brne	800099f8 <PrintDec+0x2e>
800099f0:	33 08       	mov	r8,48
800099f2:	ba 88       	st.b	sp[0x0],r8
800099f4:	30 1e       	mov	lr,1
800099f6:	c2 f8       	rjmp	80009a54 <PrintDec+0x8a>
	
	int ten = i%10;
800099f8:	e0 65 66 67 	mov	r5,26215
800099fc:	ea 15 66 66 	orh	r5,0x6666
80009a00:	f0 05 04 44 	muls.d	r4,r8,r5
80009a04:	ea 0c 14 02 	asr	r12,r5,0x2
80009a08:	f0 09 14 1f 	asr	r9,r8,0x1f
80009a0c:	f8 09 01 09 	sub	r9,r12,r9
80009a10:	f2 09 00 29 	add	r9,r9,r9<<0x2
80009a14:	f0 09 01 19 	sub	r9,r8,r9<<0x1
80009a18:	30 0e       	mov	lr,0
	while(i)
	{
		s[cnt] = ten+'0';
80009a1a:	1a 9c       	mov	r12,sp
		cnt++;
		i /= 10;
80009a1c:	e0 66 66 67 	mov	r6,26215
80009a20:	ea 16 66 66 	orh	r6,0x6666
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
	{
		s[cnt] = ten+'0';
80009a24:	2d 09       	sub	r9,-48
80009a26:	f8 0e 0b 09 	st.b	r12[lr],r9
		cnt++;
80009a2a:	2f fe       	sub	lr,-1
		i /= 10;
80009a2c:	f0 06 04 44 	muls.d	r4,r8,r6
80009a30:	ea 09 14 02 	asr	r9,r5,0x2
80009a34:	bf 58       	asr	r8,0x1f
80009a36:	f2 08 01 08 	sub	r8,r9,r8
		ten = i%10;
80009a3a:	f0 06 04 44 	muls.d	r4,r8,r6
80009a3e:	ea 09 14 02 	asr	r9,r5,0x2
80009a42:	f0 05 14 1f 	asr	r5,r8,0x1f
80009a46:	0a 19       	sub	r9,r5
80009a48:	f2 09 00 29 	add	r9,r9,r9<<0x2
80009a4c:	f0 09 01 19 	sub	r9,r8,r9<<0x1
	}
	
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
80009a50:	58 08       	cp.w	r8,0
80009a52:	ce 91       	brne	80009a24 <PrintDec+0x5a>
		cnt++;
		i /= 10;
		ten = i%10;
	}
	
	if(len - cnt > 0 )
80009a54:	f6 0e 01 08 	sub	r8,r11,lr
80009a58:	58 08       	cp.w	r8,0
80009a5a:	e0 89 00 06 	brgt	80009a66 <PrintDec+0x9c>
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80009a5e:	58 0e       	cp.w	lr,0
80009a60:	e0 89 00 14 	brgt	80009a88 <PrintDec+0xbe>
80009a64:	c1 d8       	rjmp	80009a9e <PrintDec+0xd4>
		ten = i%10;
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
80009a66:	1c 1b       	sub	r11,lr
80009a68:	5c 5b       	castu.b	r11
		for(int i = 0; i < num; i++)
80009a6a:	16 9c       	mov	r12,r11
80009a6c:	58 0b       	cp.w	r11,0
80009a6e:	fe 9a ff f8 	brle	80009a5e <PrintDec+0x94>
80009a72:	1a 99       	mov	r9,sp
80009a74:	1c 09       	add	r9,lr
80009a76:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80009a78:	33 06       	mov	r6,48
80009a7a:	12 c6       	st.b	r9++,r6
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80009a7c:	2f f8       	sub	r8,-1
80009a7e:	18 38       	cp.w	r8,r12
80009a80:	cf d5       	brlt	80009a7a <PrintDec+0xb0>
{
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
80009a82:	f6 0e 00 0e 	add	lr,r11,lr
80009a86:	ce cb       	rjmp	80009a5e <PrintDec+0x94>
80009a88:	fa c8 ff f4 	sub	r8,sp,-12
80009a8c:	1c 08       	add	r8,lr
80009a8e:	20 d8       	sub	r8,13
80009a90:	fa cb 00 01 	sub	r11,sp,1
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
	*p++ = s[--cnt];
80009a94:	11 89       	ld.ub	r9,r8[0x0]
80009a96:	0e c9       	st.b	r7++,r9
80009a98:	20 18       	sub	r8,1
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80009a9a:	16 38       	cp.w	r8,r11
80009a9c:	cf c1       	brne	80009a94 <PrintDec+0xca>
	*p++ = s[--cnt];
	
	return str;
}
80009a9e:	14 9c       	mov	r12,r10
80009aa0:	2f dd       	sub	sp,-12
80009aa2:	d8 22       	popm	r4-r7,pc

80009aa4 <log>:
	,  NULL );
	
}

int log(char * content, ...)
{
80009aa4:	d4 31       	pushm	r0-r7,lr
80009aa6:	fa cd 02 08 	sub	sp,sp,520
80009aaa:	18 97       	mov	r7,r12
	
	
	char logTmp[MAX_LOG_LINE_SIZE];
	memset(logTmp, '\0', MAX_LOG_LINE_SIZE);	
80009aac:	e0 6a 01 00 	mov	r10,256
80009ab0:	30 0b       	mov	r11,0
80009ab2:	fa cc fe f8 	sub	r12,sp,-264
80009ab6:	f0 1f 00 4e 	mcall	80009bec <log+0x148>
	,  tskLOG_PRIORITY
	,  NULL );
	
}

int log(char * content, ...)
80009aba:	fa c4 fd d4 	sub	r4,sp,-556
80009abe:	30 0a       	mov	r10,0
80009ac0:	50 0a       	stdsp	sp[0x0],r10
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80009ac2:	fa c3 ff fc 	sub	r3,sp,-4
80009ac6:	e0 61 01 00 	mov	r1,256
80009aca:	14 90       	mov	r0,r10
			
					if(*str == '%')
80009acc:	32 52       	mov	r2,37
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
80009ace:	fa c6 fe f8 	sub	r6,sp,-264
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80009ad2:	02 9a       	mov	r10,r1
80009ad4:	00 9b       	mov	r11,r0
80009ad6:	06 9c       	mov	r12,r3
80009ad8:	f0 1f 00 45 	mcall	80009bec <log+0x148>
			
					if(*str == '%')
80009adc:	0f 88       	ld.ub	r8,r7[0x0]
80009ade:	e4 08 18 00 	cp.b	r8,r2
80009ae2:	c5 71       	brne	80009b90 <log+0xec>
					{
						static char lench = 0;
						lench =*(str + 1);
80009ae4:	ee c8 ff ff 	sub	r8,r7,-1
80009ae8:	11 89       	ld.ub	r9,r8[0x0]
80009aea:	4c 2a       	lddpc	r10,80009bf0 <log+0x14c>
80009aec:	b4 89       	st.b	r10[0x0],r9
						if((lench >= '0') &&  (lench <= '9'))
80009aee:	23 09       	sub	r9,48
80009af0:	30 9a       	mov	r10,9
80009af2:	f4 09 18 00 	cp.b	r9,r10
80009af6:	ee 08 17 b0 	movhi	r8,r7
						{
							len = *(++str) - '0';
80009afa:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
80009afe:	f7 b9 08 30 	subls	r9,48
80009b02:	fb f9 8a 00 	st.wls	sp[0x0],r9
						}
						
						str++;
80009b06:	f0 c7 ff ff 	sub	r7,r8,-1
						
						switch(*(str))
80009b0a:	0f 88       	ld.ub	r8,r7[0x0]
80009b0c:	22 58       	sub	r8,37
80009b0e:	e0 48 00 53 	cp.w	r8,83
80009b12:	e0 8b 00 31 	brhi	80009b74 <log+0xd0>
80009b16:	4b 89       	lddpc	r9,80009bf4 <log+0x150>
80009b18:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
						{
							case('i'):
							case('I'):
							case('d'):
							case('D'):
							x = va_arg(arg_ptr,int);
80009b1c:	e8 c5 ff fc 	sub	r5,r4,-4
							strTmp = PrintDec(x, len, strTmp);
80009b20:	06 9a       	mov	r10,r3
80009b22:	40 0b       	lddsp	r11,sp[0x0]
80009b24:	5c 5b       	castu.b	r11
80009b26:	68 0c       	ld.w	r12,r4[0x0]
80009b28:	f0 1f 00 34 	mcall	80009bf8 <log+0x154>
							break;
80009b2c:	c2 98       	rjmp	80009b7e <log+0xda>
							
							case('f')://
							case('F'):
							//f = va_arg(arg_ptr,int);
							//strTmp = PrintDec(x, len, strTmp);
							log("I need float.");
80009b2e:	4b 4c       	lddpc	r12,80009bfc <log+0x158>
80009b30:	f0 1f 00 34 	mcall	80009c00 <log+0x15c>
80009b34:	08 95       	mov	r5,r4
80009b36:	06 9c       	mov	r12,r3
							break;
80009b38:	c2 38       	rjmp	80009b7e <log+0xda>
							
							
							case('x'):
							case('X'):
							x = va_arg(arg_ptr,int);
80009b3a:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintHex(x,len, strTmp);
80009b3e:	06 9a       	mov	r10,r3
80009b40:	40 0b       	lddsp	r11,sp[0x0]
80009b42:	5c 5b       	castu.b	r11
80009b44:	68 0c       	ld.w	r12,r4[0x0]
80009b46:	f0 1f 00 30 	mcall	80009c04 <log+0x160>
80009b4a:	06 9c       	mov	r12,r3
							break;
80009b4c:	c1 98       	rjmp	80009b7e <log+0xda>
							
							case('c'):
							case('C'):
							y = va_arg(arg_ptr,int);
80009b4e:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintChar(y, strTmp);
80009b52:	06 9b       	mov	r11,r3
80009b54:	09 bc       	ld.ub	r12,r4[0x3]
80009b56:	f0 1f 00 2d 	mcall	80009c08 <log+0x164>
80009b5a:	06 9c       	mov	r12,r3
							break;
80009b5c:	c1 18       	rjmp	80009b7e <log+0xda>
							
							case('s'):
							case('S'):
							strTmp = va_arg(arg_ptr,char*);
80009b5e:	e8 c5 ff fc 	sub	r5,r4,-4
80009b62:	68 0c       	ld.w	r12,r4[0x0]
							//PrintStr(s);
							break;
80009b64:	c0 d8       	rjmp	80009b7e <log+0xda>
							
							case('%'):
							PrintChar('%', strTmp);
80009b66:	06 9b       	mov	r11,r3
80009b68:	32 5c       	mov	r12,37
80009b6a:	f0 1f 00 28 	mcall	80009c08 <log+0x164>
80009b6e:	08 95       	mov	r5,r4
80009b70:	06 9c       	mov	r12,r3
							//PrintChar('%');
							break;
80009b72:	c0 68       	rjmp	80009b7e <log+0xda>
							
							default:
							log("I need relax.");
80009b74:	4a 6c       	lddpc	r12,80009c0c <log+0x168>
80009b76:	f0 1f 00 23 	mcall	80009c00 <log+0x15c>
80009b7a:	08 95       	mov	r5,r4
80009b7c:	06 9c       	mov	r12,r3
						}
						str++;
80009b7e:	2f f7       	sub	r7,-1
						
						length = sprintf(logTmp,"%s%s",logTmp,strTmp );
80009b80:	1a dc       	st.w	--sp,r12
80009b82:	1a d6       	st.w	--sp,r6
80009b84:	4a 3b       	lddpc	r11,80009c10 <log+0x16c>
80009b86:	0c 9c       	mov	r12,r6
80009b88:	f0 1f 00 23 	mcall	80009c14 <log+0x170>
80009b8c:	2f ed       	sub	sp,-8
80009b8e:	c0 a8       	rjmp	80009ba2 <log+0xfe>
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
80009b90:	2f f7       	sub	r7,-1
80009b92:	1a d8       	st.w	--sp,r8
80009b94:	1a d6       	st.w	--sp,r6
80009b96:	4a 1b       	lddpc	r11,80009c18 <log+0x174>
80009b98:	0c 9c       	mov	r12,r6
80009b9a:	f0 1f 00 1f 	mcall	80009c14 <log+0x170>
80009b9e:	08 95       	mov	r5,r4
80009ba0:	2f ed       	sub	sp,-8
			
			
			
	}while(*str != '\0');
80009ba2:	0f 89       	ld.ub	r9,r7[0x0]
80009ba4:	30 08       	mov	r8,0
80009ba6:	f0 09 18 00 	cp.b	r9,r8
80009baa:	c0 30       	breq	80009bb0 <log+0x10c>
80009bac:	0a 94       	mov	r4,r5
80009bae:	c9 2b       	rjmp	80009ad2 <log+0x2e>
		
		
				
	va_end(arg_ptr);
	//while(1)		
	length = sprintf(logTmp,"%s\r\n",logTmp);
80009bb0:	fa c7 fe f8 	sub	r7,sp,-264
80009bb4:	1a d7       	st.w	--sp,r7
80009bb6:	49 ab       	lddpc	r11,80009c1c <log+0x178>
80009bb8:	0e 9c       	mov	r12,r7
80009bba:	f0 1f 00 17 	mcall	80009c14 <log+0x170>
	
	char * p = pvPortMalloc(length+1);
80009bbe:	5c 5c       	castu.b	r12
80009bc0:	f8 c6 ff ff 	sub	r6,r12,-1
80009bc4:	0c 9c       	mov	r12,r6
80009bc6:	f0 1f 00 17 	mcall	80009c20 <log+0x17c>
80009bca:	54 2c       	stdsp	sp[0x108],r12
	memcpy(p, logTmp, length+1);
80009bcc:	0c 9a       	mov	r10,r6
80009bce:	0e 9b       	mov	r11,r7
80009bd0:	f0 1f 00 15 	mcall	80009c24 <log+0x180>
	//
	//usart_write_line(EXAMPLE_USART, logTmp);
	xQueueSend( logQueue, &p, 5);
80009bd4:	30 09       	mov	r9,0
80009bd6:	30 5a       	mov	r10,5
80009bd8:	fa cb fe f8 	sub	r11,sp,-264
80009bdc:	49 38       	lddpc	r8,80009c28 <log+0x184>
80009bde:	70 0c       	ld.w	r12,r8[0x0]
80009be0:	f0 1f 00 13 	mcall	80009c2c <log+0x188>
80009be4:	2f fd       	sub	sp,-4
}
80009be6:	fe 3d fd f8 	sub	sp,-520
80009bea:	d8 32       	popm	r0-r7,pc
80009bec:	80 00       	ld.sh	r0,r0[0x0]
80009bee:	a5 b2       	sbr	r2,0x5
80009bf0:	00 00       	add	r0,r0
80009bf2:	12 90       	mov	r0,r9
80009bf4:	80 01       	ld.sh	r1,r0[0x0]
80009bf6:	8b e0       	st.w	r5[0x38],r0
80009bf8:	80 00       	ld.sh	r0,r0[0x0]
80009bfa:	99 ca       	st.w	r12[0x30],r10
80009bfc:	80 01       	ld.sh	r1,r0[0x0]
80009bfe:	8e 8c       	ld.uh	r12,r7[0x0]
80009c00:	80 00       	ld.sh	r0,r0[0x0]
80009c02:	9a a4       	ld.uh	r4,sp[0x4]
80009c04:	80 00       	ld.sh	r0,r0[0x0]
80009c06:	99 18       	st.w	r12[0x4],r8
80009c08:	80 00       	ld.sh	r0,r0[0x0]
80009c0a:	99 14       	st.w	r12[0x4],r4
80009c0c:	80 01       	ld.sh	r1,r0[0x0]
80009c0e:	8e 9c       	ld.uh	r12,r7[0x2]
80009c10:	80 01       	ld.sh	r1,r0[0x0]
80009c12:	8e ac       	ld.uh	r12,r7[0x4]
80009c14:	80 00       	ld.sh	r0,r0[0x0]
80009c16:	a8 a0       	st.b	r4[0x2],r0
80009c18:	80 01       	ld.sh	r1,r0[0x0]
80009c1a:	8e b4       	ld.uh	r4,r7[0x6]
80009c1c:	80 01       	ld.sh	r1,r0[0x0]
80009c1e:	8e bc       	ld.uh	r12,r7[0x6]
80009c20:	80 00       	ld.sh	r0,r0[0x0]
80009c22:	8b 60       	st.w	r5[0x18],r0
80009c24:	80 00       	ld.sh	r0,r0[0x0]
80009c26:	a4 6a       	st.h	r2[0xc],r10
80009c28:	00 00       	add	r0,r0
80009c2a:	46 24       	lddsp	r4,sp[0x188]
80009c2c:	80 00       	ld.sh	r0,r0[0x0]
80009c2e:	8e b4       	ld.uh	r4,r7[0x6]

80009c30 <logFromISR>:
	
	
int logFromISR(char * content, ...)
	{
80009c30:	d4 31       	pushm	r0-r7,lr
80009c32:	fa cd 02 0c 	sub	sp,sp,524
80009c36:	18 97       	mov	r7,r12
		
		
		char logTmp[MAX_LOG_LINE_SIZE];
		memset(logTmp, '\0', MAX_LOG_LINE_SIZE);
80009c38:	e0 6a 01 00 	mov	r10,256
80009c3c:	30 0b       	mov	r11,0
80009c3e:	fa cc fe f4 	sub	r12,sp,-268
80009c42:	f0 1f 00 4c 	mcall	80009d70 <logFromISR+0x140>
	//usart_write_line(EXAMPLE_USART, logTmp);
	xQueueSend( logQueue, &p, 5);
}
	
	
int logFromISR(char * content, ...)
80009c46:	fa c4 fd d0 	sub	r4,sp,-560
80009c4a:	30 0a       	mov	r10,0
80009c4c:	50 0a       	stdsp	sp[0x0],r10
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80009c4e:	fa c3 ff fc 	sub	r3,sp,-4
80009c52:	e0 61 01 00 	mov	r1,256
80009c56:	14 90       	mov	r0,r10
			
			if(*str == '%')
80009c58:	32 52       	mov	r2,37
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
80009c5a:	fa c6 fe f4 	sub	r6,sp,-268
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80009c5e:	02 9a       	mov	r10,r1
80009c60:	00 9b       	mov	r11,r0
80009c62:	06 9c       	mov	r12,r3
80009c64:	f0 1f 00 43 	mcall	80009d70 <logFromISR+0x140>
			
			if(*str == '%')
80009c68:	0f 88       	ld.ub	r8,r7[0x0]
80009c6a:	e4 08 18 00 	cp.b	r8,r2
80009c6e:	c5 11       	brne	80009d10 <logFromISR+0xe0>
			{
				static char lench = 0;
				lench =*(str + 1);
80009c70:	ee c8 ff ff 	sub	r8,r7,-1
80009c74:	11 89       	ld.ub	r9,r8[0x0]
80009c76:	4c 0a       	lddpc	r10,80009d74 <logFromISR+0x144>
80009c78:	b4 89       	st.b	r10[0x0],r9
				if((lench >= '0') &&  (lench <= '9'))
80009c7a:	23 09       	sub	r9,48
80009c7c:	30 9a       	mov	r10,9
80009c7e:	f4 09 18 00 	cp.b	r9,r10
80009c82:	ee 08 17 b0 	movhi	r8,r7
				{
					len = *(++str) - '0';
80009c86:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
80009c8a:	f7 b9 08 30 	subls	r9,48
80009c8e:	fb f9 8a 00 	st.wls	sp[0x0],r9
				}
				
				str++;
80009c92:	f0 c7 ff ff 	sub	r7,r8,-1
				
				switch(*(str))
80009c96:	0f 88       	ld.ub	r8,r7[0x0]
80009c98:	22 58       	sub	r8,37
80009c9a:	e0 48 00 53 	cp.w	r8,83
80009c9e:	e0 8b 00 2b 	brhi	80009cf4 <logFromISR+0xc4>
80009ca2:	4b 69       	lddpc	r9,80009d78 <logFromISR+0x148>
80009ca4:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
				{
					case('d'):
					case('D'):
					x = va_arg(arg_ptr,int);
80009ca8:	e8 c5 ff fc 	sub	r5,r4,-4
					strTmp = PrintDec(x, len, strTmp);
80009cac:	06 9a       	mov	r10,r3
80009cae:	40 0b       	lddsp	r11,sp[0x0]
80009cb0:	5c 5b       	castu.b	r11
80009cb2:	68 0c       	ld.w	r12,r4[0x0]
80009cb4:	f0 1f 00 32 	mcall	80009d7c <logFromISR+0x14c>
					break;
80009cb8:	c2 38       	rjmp	80009cfe <logFromISR+0xce>
					case('x'):
					case('X'):
					x = va_arg(arg_ptr,int);
80009cba:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintHex(x,len, strTmp);
80009cbe:	06 9a       	mov	r10,r3
80009cc0:	40 0b       	lddsp	r11,sp[0x0]
80009cc2:	5c 5b       	castu.b	r11
80009cc4:	68 0c       	ld.w	r12,r4[0x0]
80009cc6:	f0 1f 00 2f 	mcall	80009d80 <logFromISR+0x150>
80009cca:	06 9c       	mov	r12,r3
					break;
80009ccc:	c1 98       	rjmp	80009cfe <logFromISR+0xce>
					case('c'):
					case('C'):
					y = va_arg(arg_ptr,int);
80009cce:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintChar(y, strTmp);
80009cd2:	06 9b       	mov	r11,r3
80009cd4:	09 bc       	ld.ub	r12,r4[0x3]
80009cd6:	f0 1f 00 2c 	mcall	80009d84 <logFromISR+0x154>
80009cda:	06 9c       	mov	r12,r3
					break;
80009cdc:	c1 18       	rjmp	80009cfe <logFromISR+0xce>
					case('s'):
					case('S'):
					strTmp = va_arg(arg_ptr,char*);
80009cde:	e8 c5 ff fc 	sub	r5,r4,-4
80009ce2:	68 0c       	ld.w	r12,r4[0x0]
					//PrintStr(s);
					break;
80009ce4:	c0 d8       	rjmp	80009cfe <logFromISR+0xce>
					case('%'):
					PrintChar('%', strTmp);
80009ce6:	06 9b       	mov	r11,r3
80009ce8:	32 5c       	mov	r12,37
80009cea:	f0 1f 00 27 	mcall	80009d84 <logFromISR+0x154>
80009cee:	08 95       	mov	r5,r4
80009cf0:	06 9c       	mov	r12,r3
					//PrintChar('%');
					break;
80009cf2:	c0 68       	rjmp	80009cfe <logFromISR+0xce>
					default:
					log("I need relax.");
80009cf4:	4a 5c       	lddpc	r12,80009d88 <logFromISR+0x158>
80009cf6:	f0 1f 00 26 	mcall	80009d8c <logFromISR+0x15c>
80009cfa:	08 95       	mov	r5,r4
80009cfc:	06 9c       	mov	r12,r3
				}
				str++;
80009cfe:	2f f7       	sub	r7,-1
				
				length = sprintf(logTmp,"%s%s",logTmp,strTmp );
80009d00:	1a dc       	st.w	--sp,r12
80009d02:	1a d6       	st.w	--sp,r6
80009d04:	4a 3b       	lddpc	r11,80009d90 <logFromISR+0x160>
80009d06:	0c 9c       	mov	r12,r6
80009d08:	f0 1f 00 23 	mcall	80009d94 <logFromISR+0x164>
80009d0c:	2f ed       	sub	sp,-8
80009d0e:	c0 a8       	rjmp	80009d22 <logFromISR+0xf2>
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
80009d10:	2f f7       	sub	r7,-1
80009d12:	1a d8       	st.w	--sp,r8
80009d14:	1a d6       	st.w	--sp,r6
80009d16:	4a 1b       	lddpc	r11,80009d98 <logFromISR+0x168>
80009d18:	0c 9c       	mov	r12,r6
80009d1a:	f0 1f 00 1f 	mcall	80009d94 <logFromISR+0x164>
80009d1e:	08 95       	mov	r5,r4
80009d20:	2f ed       	sub	sp,-8
			
			
			
		}while(*str != '\0');
80009d22:	0f 89       	ld.ub	r9,r7[0x0]
80009d24:	30 08       	mov	r8,0
80009d26:	f0 09 18 00 	cp.b	r9,r8
80009d2a:	c0 30       	breq	80009d30 <logFromISR+0x100>
80009d2c:	0a 94       	mov	r4,r5
80009d2e:	c9 8b       	rjmp	80009c5e <logFromISR+0x2e>
		
		
		
		va_end(arg_ptr);
		//while(1)
		length = sprintf(logTmp,"%s\r\n",logTmp);
80009d30:	fa c7 fe f4 	sub	r7,sp,-268
80009d34:	1a d7       	st.w	--sp,r7
80009d36:	49 ab       	lddpc	r11,80009d9c <logFromISR+0x16c>
80009d38:	0e 9c       	mov	r12,r7
80009d3a:	f0 1f 00 17 	mcall	80009d94 <logFromISR+0x164>
		
		char * p = pvPortMalloc(length+1);
80009d3e:	5c 5c       	castu.b	r12
80009d40:	f8 c6 ff ff 	sub	r6,r12,-1
80009d44:	0c 9c       	mov	r12,r6
80009d46:	f0 1f 00 17 	mcall	80009da0 <logFromISR+0x170>
80009d4a:	54 3c       	stdsp	sp[0x10c],r12
		memcpy(p, logTmp, length+1);
80009d4c:	0c 9a       	mov	r10,r6
80009d4e:	0e 9b       	mov	r11,r7
80009d50:	f0 1f 00 15 	mcall	80009da4 <logFromISR+0x174>
		//
		portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80009d54:	30 09       	mov	r9,0
80009d56:	54 29       	stdsp	sp[0x108],r9
		
		//usart_write_line(EXAMPLE_USART, p);
		//vPortFree(p);
		xQueueSendFromISR( logQueue, &p, &xHigherPriorityTaskWoken );
80009d58:	fa ca fe f8 	sub	r10,sp,-264
80009d5c:	fa cb fe f4 	sub	r11,sp,-268
80009d60:	49 28       	lddpc	r8,80009da8 <logFromISR+0x178>
80009d62:	70 0c       	ld.w	r12,r8[0x0]
80009d64:	f0 1f 00 12 	mcall	80009dac <logFromISR+0x17c>
80009d68:	2f fd       	sub	sp,-4
		//if (xHigherPriorityTaskWoken == pdTRUE)
		//{
			////taskYIELD();
		//}
	}
80009d6a:	fe 3d fd f4 	sub	sp,-524
80009d6e:	d8 32       	popm	r0-r7,pc
80009d70:	80 00       	ld.sh	r0,r0[0x0]
80009d72:	a5 b2       	sbr	r2,0x5
80009d74:	00 00       	add	r0,r0
80009d76:	12 91       	mov	r1,r9
80009d78:	80 01       	ld.sh	r1,r0[0x0]
80009d7a:	8d 30       	st.w	r6[0xc],r0
80009d7c:	80 00       	ld.sh	r0,r0[0x0]
80009d7e:	99 ca       	st.w	r12[0x30],r10
80009d80:	80 00       	ld.sh	r0,r0[0x0]
80009d82:	99 18       	st.w	r12[0x4],r8
80009d84:	80 00       	ld.sh	r0,r0[0x0]
80009d86:	99 14       	st.w	r12[0x4],r4
80009d88:	80 01       	ld.sh	r1,r0[0x0]
80009d8a:	8e 9c       	ld.uh	r12,r7[0x2]
80009d8c:	80 00       	ld.sh	r0,r0[0x0]
80009d8e:	9a a4       	ld.uh	r4,sp[0x4]
80009d90:	80 01       	ld.sh	r1,r0[0x0]
80009d92:	8e ac       	ld.uh	r12,r7[0x4]
80009d94:	80 00       	ld.sh	r0,r0[0x0]
80009d96:	a8 a0       	st.b	r4[0x2],r0
80009d98:	80 01       	ld.sh	r1,r0[0x0]
80009d9a:	8e b4       	ld.uh	r4,r7[0x6]
80009d9c:	80 01       	ld.sh	r1,r0[0x0]
80009d9e:	8e bc       	ld.uh	r12,r7[0x6]
80009da0:	80 00       	ld.sh	r0,r0[0x0]
80009da2:	8b 60       	st.w	r5[0x18],r0
80009da4:	80 00       	ld.sh	r0,r0[0x0]
80009da6:	a4 6a       	st.h	r2[0xc],r10
80009da8:	00 00       	add	r0,r0
80009daa:	46 24       	lddsp	r4,sp[0x188]
80009dac:	80 00       	ld.sh	r0,r0[0x0]
80009dae:	8e 64       	ld.sh	r4,r7[0xc]

80009db0 <log_init>:
		
	return str;
}

void log_init(void)
{
80009db0:	d4 01       	pushm	lr
		.stopbits     = USART_1_STOPBIT,
		.channelmode  = USART_NORMAL_CHMODE
	};

	// Assign GPIO to USART.
	gpio_enable_module(USART_GPIO_MAP,
80009db2:	30 2b       	mov	r11,2
80009db4:	49 0c       	lddpc	r12,80009df4 <log_init+0x44>
80009db6:	f0 1f 00 11 	mcall	80009df8 <log_init+0x48>
	sizeof(USART_GPIO_MAP) / sizeof(USART_GPIO_MAP[0]));

	// Initialize USART in RS232 mode.
	usart_init_rs232(EXAMPLE_USART, &USART_OPTIONS, EXAMPLE_TARGET_PBACLK_FREQ_HZ);			
80009dba:	e0 6a 36 00 	mov	r10,13824
80009dbe:	ea 1a 01 6e 	orh	r10,0x16e
80009dc2:	48 fb       	lddpc	r11,80009dfc <log_init+0x4c>
80009dc4:	fe 7c 18 00 	mov	r12,-59392
80009dc8:	f0 1f 00 0e 	mcall	80009e00 <log_init+0x50>
			
	logQueue  = xQueueCreate(50, sizeof(char *));
80009dcc:	30 4b       	mov	r11,4
80009dce:	33 2c       	mov	r12,50
80009dd0:	f0 1f 00 0d 	mcall	80009e04 <log_init+0x54>
80009dd4:	48 d8       	lddpc	r8,80009e08 <log_init+0x58>
80009dd6:	91 0c       	st.w	r8[0x0],r12
	
	xTaskCreate(
80009dd8:	30 09       	mov	r9,0
80009dda:	1a d9       	st.w	--sp,r9
80009ddc:	1a d9       	st.w	--sp,r9
80009dde:	1a d9       	st.w	--sp,r9
80009de0:	30 28       	mov	r8,2
80009de2:	e0 6a 01 80 	mov	r10,384
80009de6:	48 ab       	lddpc	r11,80009e0c <log_init+0x5c>
80009de8:	48 ac       	lddpc	r12,80009e10 <log_init+0x60>
80009dea:	f0 1f 00 0b 	mcall	80009e14 <log_init+0x64>
80009dee:	2f dd       	sub	sp,-12
	,  384
	,  NULL
	,  tskLOG_PRIORITY
	,  NULL );
	
}
80009df0:	d8 02       	popm	pc
80009df2:	00 00       	add	r0,r0
80009df4:	80 01       	ld.sh	r1,r0[0x0]
80009df6:	8e c8       	ld.uh	r8,r7[0x8]
80009df8:	80 00       	ld.sh	r0,r0[0x0]
80009dfa:	9f 44       	st.w	pc[0x10],r4
80009dfc:	80 01       	ld.sh	r1,r0[0x0]
80009dfe:	8e 80       	ld.uh	r0,r7[0x0]
80009e00:	80 00       	ld.sh	r0,r0[0x0]
80009e02:	61 34       	ld.w	r4,r0[0x4c]
80009e04:	80 00       	ld.sh	r0,r0[0x0]
80009e06:	90 0c       	ld.sh	r12,r8[0x0]
80009e08:	00 00       	add	r0,r0
80009e0a:	46 24       	lddsp	r4,sp[0x188]
80009e0c:	80 01       	ld.sh	r1,r0[0x0]
80009e0e:	8e c4       	ld.uh	r4,r7[0x8]
80009e10:	80 00       	ld.sh	r0,r0[0x0]
80009e12:	9e 18       	ld.sh	r8,pc[0x2]
80009e14:	80 00       	ld.sh	r0,r0[0x0]
80009e16:	96 e0       	ld.uh	r0,r11[0xc]

80009e18 <task_log>:
			////taskYIELD();
		//}
	}
	
static void task_log(void * pvParameters)
{
80009e18:	eb cd 40 f8 	pushm	r3-r7,lr
80009e1c:	20 1d       	sub	sp,4
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
80009e1e:	48 c7       	lddpc	r7,80009e4c <task_log+0x34>
80009e20:	30 05       	mov	r5,0
80009e22:	3f f4       	mov	r4,-1
		{
			if( NULL != str)
			{
				usart_write_line(EXAMPLE_USART, str);
80009e24:	fe 73 18 00 	mov	r3,-59392
{
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
80009e28:	0a 99       	mov	r9,r5
80009e2a:	08 9a       	mov	r10,r4
80009e2c:	1a 9b       	mov	r11,sp
80009e2e:	6e 0c       	ld.w	r12,r7[0x0]
80009e30:	f0 1f 00 08 	mcall	80009e50 <task_log+0x38>
80009e34:	58 1c       	cp.w	r12,1
80009e36:	cf 91       	brne	80009e28 <task_log+0x10>
		{
			if( NULL != str)
80009e38:	40 0b       	lddsp	r11,sp[0x0]
80009e3a:	58 0b       	cp.w	r11,0
80009e3c:	cf 60       	breq	80009e28 <task_log+0x10>
			{
				usart_write_line(EXAMPLE_USART, str);
80009e3e:	06 9c       	mov	r12,r3
80009e40:	f0 1f 00 05 	mcall	80009e54 <task_log+0x3c>
				vPortFree(str);
80009e44:	40 0c       	lddsp	r12,sp[0x0]
80009e46:	f0 1f 00 05 	mcall	80009e58 <task_log+0x40>
80009e4a:	ce fb       	rjmp	80009e28 <task_log+0x10>
80009e4c:	00 00       	add	r0,r0
80009e4e:	46 24       	lddsp	r4,sp[0x188]
80009e50:	80 00       	ld.sh	r0,r0[0x0]
80009e52:	8c a8       	ld.uh	r8,r6[0x4]
80009e54:	80 00       	ld.sh	r0,r0[0x0]
80009e56:	60 e4       	ld.w	r4,r0[0x38]
80009e58:	80 00       	ld.sh	r0,r0[0x0]
80009e5a:	8b 38       	st.w	r5[0xc],r8

80009e5c <main>:

#include "fs/fs.h"
#include "rtc/rtc.h"

int main(void)
{
80009e5c:	d4 01       	pushm	lr
	//Force SSC_TX_DATA_ENABLE Disabled as soon as possible.
	AVR32_GPIO.port[1].ovrs  =  0x00000001;  //Value will be high.
80009e5e:	fe 78 10 00 	mov	r8,-61440
80009e62:	30 19       	mov	r9,1
80009e64:	f1 49 01 54 	st.w	r8[340],r9
	AVR32_GPIO.port[1].oders =  0x00000001;  //Output Driver will be Enabled.
80009e68:	f1 49 01 44 	st.w	r8[324],r9
	AVR32_GPIO.port[1].gpers =  0x00000001;  //Enable as GPIO.
80009e6c:	f1 49 01 04 	st.w	r8[260],r9
	
	Disable_global_interrupt();
80009e70:	d3 03       	ssrf	0x10
	local_start_pll0();
80009e72:	f0 1f 00 14 	mcall	80009ec0 <main+0x64>
		
	INTC_init_interrupts();
80009e76:	f0 1f 00 14 	mcall	80009ec4 <main+0x68>
	
	log_init();		
80009e7a:	f0 1f 00 14 	mcall	80009ec8 <main+0x6c>
	log("----start debug----");	
80009e7e:	49 4c       	lddpc	r12,80009ecc <main+0x70>
80009e80:	f0 1f 00 14 	mcall	80009ed0 <main+0x74>
		
	rtc_init();
80009e84:	f0 1f 00 14 	mcall	80009ed4 <main+0x78>
	
	fs_init();//65795
80009e88:	f0 1f 00 14 	mcall	80009ed8 <main+0x7c>

	tc_init();	
80009e8c:	f0 1f 00 14 	mcall	80009edc <main+0x80>
			
	xcmp_init();
80009e90:	f0 1f 00 14 	mcall	80009ee0 <main+0x84>
	
	app_init();
80009e94:	f0 1f 00 14 	mcall	80009ee4 <main+0x88>
		
	while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
80009e98:	fe 79 10 00 	mov	r9,-61440
80009e9c:	f2 f8 01 60 	ld.w	r8,r9[352]
80009ea0:	e2 18 00 02 	andl	r8,0x2,COH
80009ea4:	cf c0       	breq	80009e9c <main+0x40>
	while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
80009ea6:	fe 79 10 00 	mov	r9,-61440
80009eaa:	f2 f8 01 60 	ld.w	r8,r9[352]
80009eae:	e2 18 00 02 	andl	r8,0x2,COH
80009eb2:	cf c1       	brne	80009eaa <main+0x4e>
	local_start_timer();
80009eb4:	f0 1f 00 0d 	mcall	80009ee8 <main+0x8c>
	
	Enable_global_interrupt();
80009eb8:	d5 03       	csrf	0x10
	
	vTaskStartScheduler();		
80009eba:	f0 1f 00 0d 	mcall	80009eec <main+0x90>
	return 0;
}
80009ebe:	d8 0a       	popm	pc,r12=0
80009ec0:	80 00       	ld.sh	r0,r0[0x0]
80009ec2:	56 ac       	stdsp	sp[0x1a8],r12
80009ec4:	80 00       	ld.sh	r0,r0[0x0]
80009ec6:	5a 44       	cp.w	r4,-28
80009ec8:	80 00       	ld.sh	r0,r0[0x0]
80009eca:	9d b0       	st.w	lr[0x2c],r0
80009ecc:	80 01       	ld.sh	r1,r0[0x0]
80009ece:	8e d8       	ld.uh	r8,r7[0xa]
80009ed0:	80 00       	ld.sh	r0,r0[0x0]
80009ed2:	9a a4       	ld.uh	r4,sp[0x4]
80009ed4:	80 00       	ld.sh	r0,r0[0x0]
80009ed6:	58 78       	cp.w	r8,7
80009ed8:	80 00       	ld.sh	r0,r0[0x0]
80009eda:	39 0c       	mov	r12,-112
80009edc:	80 00       	ld.sh	r0,r0[0x0]
80009ede:	59 40       	cp.w	r0,20
80009ee0:	80 00       	ld.sh	r0,r0[0x0]
80009ee2:	4f b0       	lddpc	r0,8000a0cc <_malloc_r+0xc0>
80009ee4:	80 00       	ld.sh	r0,r0[0x0]
80009ee6:	20 44       	sub	r4,4
80009ee8:	80 00       	ld.sh	r0,r0[0x0]
80009eea:	59 04       	cp.w	r4,16
80009eec:	80 00       	ld.sh	r0,r0[0x0]
80009eee:	98 c8       	ld.uh	r8,r12[0x8]

80009ef0 <gpio_enable_module_pin>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80009ef0:	f8 08 16 05 	lsr	r8,r12,0x5
80009ef4:	a9 68       	lsl	r8,0x8
80009ef6:	e0 28 f0 00 	sub	r8,61440

	/* Enable the correct function. */
	switch (function) {
80009efa:	58 1b       	cp.w	r11,1
80009efc:	c0 d0       	breq	80009f16 <gpio_enable_module_pin+0x26>
80009efe:	c0 63       	brcs	80009f0a <gpio_enable_module_pin+0x1a>
80009f00:	58 2b       	cp.w	r11,2
80009f02:	c1 00       	breq	80009f22 <gpio_enable_module_pin+0x32>
80009f04:	58 3b       	cp.w	r11,3
80009f06:	c1 40       	breq	80009f2e <gpio_enable_module_pin+0x3e>
80009f08:	5e ff       	retal	1
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80009f0a:	30 19       	mov	r9,1
80009f0c:	f2 0c 09 49 	lsl	r9,r9,r12
80009f10:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80009f12:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80009f14:	c1 28       	rjmp	80009f38 <gpio_enable_module_pin+0x48>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80009f16:	30 19       	mov	r9,1
80009f18:	f2 0c 09 49 	lsl	r9,r9,r12
80009f1c:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80009f1e:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80009f20:	c0 c8       	rjmp	80009f38 <gpio_enable_module_pin+0x48>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80009f22:	30 19       	mov	r9,1
80009f24:	f2 0c 09 49 	lsl	r9,r9,r12
80009f28:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80009f2a:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80009f2c:	c0 68       	rjmp	80009f38 <gpio_enable_module_pin+0x48>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80009f2e:	30 19       	mov	r9,1
80009f30:	f2 0c 09 49 	lsl	r9,r9,r12
80009f34:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80009f36:	91 99       	st.w	r8[0x24],r9
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
80009f38:	30 19       	mov	r9,1
80009f3a:	f2 0c 09 4c 	lsl	r12,r9,r12
80009f3e:	91 2c       	st.w	r8[0x8],r12
80009f40:	5e fd       	retal	0
80009f42:	d7 03       	nop

80009f44 <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
80009f44:	d4 21       	pushm	r4-r7,lr
80009f46:	18 97       	mov	r7,r12
80009f48:	16 94       	mov	r4,r11
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80009f4a:	58 0b       	cp.w	r11,0
80009f4c:	c0 31       	brne	80009f52 <gpio_enable_module+0xe>
80009f4e:	30 05       	mov	r5,0
80009f50:	c0 d8       	rjmp	80009f6a <gpio_enable_module+0x26>
80009f52:	30 06       	mov	r6,0
80009f54:	0c 95       	mov	r5,r6
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
80009f56:	6e 1b       	ld.w	r11,r7[0x4]
80009f58:	6e 0c       	ld.w	r12,r7[0x0]
80009f5a:	f0 1f 00 06 	mcall	80009f70 <gpio_enable_module+0x2c>
80009f5e:	18 45       	or	r5,r12
		gpiomap++;
80009f60:	2f 87       	sub	r7,-8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80009f62:	2f f6       	sub	r6,-1
80009f64:	0c 34       	cp.w	r4,r6
80009f66:	fe 9b ff f8 	brhi	80009f56 <gpio_enable_module+0x12>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
}
80009f6a:	0a 9c       	mov	r12,r5
80009f6c:	d8 22       	popm	r4-r7,pc
80009f6e:	00 00       	add	r0,r0
80009f70:	80 00       	ld.sh	r0,r0[0x0]
80009f72:	9e f0       	ld.uh	r0,pc[0xe]

80009f74 <gpio_set_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_set_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80009f74:	f8 08 16 05 	lsr	r8,r12,0x5
80009f78:	a9 68       	lsl	r8,0x8
80009f7a:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 1. */
	gpio_port->ovrs  = 1 << (pin & 0x1F);																				
80009f7e:	30 19       	mov	r9,1
80009f80:	f2 0c 09 4c 	lsl	r12,r9,r12
80009f84:	f1 4c 00 54 	st.w	r8[84],r12
	/* The GPIO output driver is enabled for that pin. */ 
	gpio_port->oders = 1 << (pin & 0x1F);
80009f88:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
80009f8c:	91 1c       	st.w	r8[0x4],r12
}
80009f8e:	5e fc       	retal	r12

80009f90 <gpio_clr_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_clr_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80009f90:	f8 08 16 05 	lsr	r8,r12,0x5
80009f94:	a9 68       	lsl	r8,0x8
80009f96:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 0. */
	gpio_port->ovrc  = 1 << (pin & 0x1F);
80009f9a:	30 19       	mov	r9,1
80009f9c:	f2 0c 09 4c 	lsl	r12,r9,r12
80009fa0:	f1 4c 00 58 	st.w	r8[88],r12
	/* The GPIO output driver is enabled for that pin. */
	gpio_port->oders = 1 << (pin & 0x1F);
80009fa4:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
80009fa8:	91 1c       	st.w	r8[0x4],r12
}
80009faa:	5e fc       	retal	r12

80009fac <_stext>:

  .global _stext
  .type _stext, @function
_stext:
  // Set initial stack pointer.
  lda.w   sp, _estack
80009fac:	e0 7d 80 00 	mov	sp,98304

  // Set up EVBA so interrupts can be enabled.
  lda.w   r0, _evba
  mtsr    AVR32_EVBA, r0
80009fb0:	fe c0 a3 b0 	sub	r0,pc,-23632

  // Enable the exception processing.
  csrf    AVR32_SR_EM_OFFSET
80009fb4:	e3 b0 00 01 	mtsr	0x4,r0

  // Load initialized data having a global lifetime from the data LMA.
  lda.w   r0, _data
  lda.w   r1, _edata
80009fb8:	d5 53       	csrf	0x15
  cp      r0, r1
80009fba:	30 80       	mov	r0,8
  brhs    idata_load_loop_end
80009fbc:	e0 61 0a 40 	mov	r1,2624
  lda.w   r2, _data_lma
idata_load_loop:
  ld.d    r4, r2++
80009fc0:	02 30       	cp.w	r0,r1
  st.d    r0++, r4
80009fc2:	c0 62       	brcc	80009fce <idata_load_loop_end>
  cp      r0, r1
80009fc4:	48 92       	lddpc	r2,80009fe8 <udata_clear_loop_end+0x4>

80009fc6 <idata_load_loop>:
  brlo    idata_load_loop
80009fc6:	a5 05       	ld.d	r4,r2++
idata_load_loop_end:

  // Clear uninitialized data having a global lifetime in the blank static storage section.
  lda.w   r0, __bss_start
80009fc8:	a1 24       	st.d	r0++,r4
  lda.w   r1, _end
80009fca:	02 30       	cp.w	r0,r1
  cp      r0, r1
80009fcc:	cf d3       	brcs	80009fc6 <idata_load_loop>

80009fce <idata_load_loop_end>:
  brhs    udata_clear_loop_end
80009fce:	e0 60 0a 40 	mov	r0,2624
  mov     r2, 0
  mov     r3, 0
80009fd2:	e0 61 46 30 	mov	r1,17968
udata_clear_loop:
  st.d    r0++, r2
  cp      r0, r1
80009fd6:	02 30       	cp.w	r0,r1
  brlo    udata_clear_loop
80009fd8:	c0 62       	brcc	80009fe4 <udata_clear_loop_end>
  // Safety: Set the default "return" @ to the exit routine address.
  lda.w   lr, exit
#endif

  // Start the show.
  lda.w   pc, main
80009fda:	30 02       	mov	r2,0
80009fdc:	30 03       	mov	r3,0

80009fde <udata_clear_loop>:
80009fde:	a1 22       	st.d	r0++,r2
80009fe0:	02 30       	cp.w	r0,r1
80009fe2:	cf e3       	brcs	80009fde <udata_clear_loop>

80009fe4 <udata_clear_loop_end>:
80009fe4:	fe cf 01 88 	sub	pc,pc,392
80009fe8:	80 01       	ld.sh	r1,r0[0x0]
80009fea:	94 70       	ld.sh	r0,r10[0xe]

80009fec <free>:
80009fec:	d4 01       	pushm	lr
80009fee:	e0 68 0a 38 	mov	r8,2616
80009ff2:	18 9b       	mov	r11,r12
80009ff4:	70 0c       	ld.w	r12,r8[0x0]
80009ff6:	e0 a0 1f 19 	rcall	8000de28 <_free_r>
80009ffa:	d8 02       	popm	pc

80009ffc <malloc>:
80009ffc:	d4 01       	pushm	lr
80009ffe:	e0 68 0a 38 	mov	r8,2616
8000a002:	18 9b       	mov	r11,r12
8000a004:	70 0c       	ld.w	r12,r8[0x0]
8000a006:	c0 3c       	rcall	8000a00c <_malloc_r>
8000a008:	d8 02       	popm	pc
8000a00a:	d7 03       	nop

8000a00c <_malloc_r>:
8000a00c:	d4 31       	pushm	r0-r7,lr
8000a00e:	f6 c8 ff f5 	sub	r8,r11,-11
8000a012:	18 95       	mov	r5,r12
8000a014:	10 97       	mov	r7,r8
8000a016:	e0 17 ff f8 	andl	r7,0xfff8
8000a01a:	59 68       	cp.w	r8,22
8000a01c:	f9 b7 08 10 	movls	r7,16
8000a020:	16 37       	cp.w	r7,r11
8000a022:	5f 38       	srlo	r8
8000a024:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
8000a028:	c0 50       	breq	8000a032 <_malloc_r+0x26>
8000a02a:	30 c8       	mov	r8,12
8000a02c:	99 38       	st.w	r12[0xc],r8
8000a02e:	e0 8f 01 fa 	bral	8000a422 <_malloc_r+0x416>
8000a032:	fe b0 f5 39 	rcall	80008aa4 <__malloc_lock>
8000a036:	e0 47 01 f7 	cp.w	r7,503
8000a03a:	e0 8b 00 1d 	brhi	8000a074 <_malloc_r+0x68>
8000a03e:	ee 03 16 03 	lsr	r3,r7,0x3
8000a042:	e0 68 05 38 	mov	r8,1336
8000a046:	f0 03 00 38 	add	r8,r8,r3<<0x3
8000a04a:	70 36       	ld.w	r6,r8[0xc]
8000a04c:	10 36       	cp.w	r6,r8
8000a04e:	c0 61       	brne	8000a05a <_malloc_r+0x4e>
8000a050:	ec c8 ff f8 	sub	r8,r6,-8
8000a054:	70 36       	ld.w	r6,r8[0xc]
8000a056:	10 36       	cp.w	r6,r8
8000a058:	c0 c0       	breq	8000a070 <_malloc_r+0x64>
8000a05a:	6c 18       	ld.w	r8,r6[0x4]
8000a05c:	e0 18 ff fc 	andl	r8,0xfffc
8000a060:	6c 3a       	ld.w	r10,r6[0xc]
8000a062:	ec 08 00 09 	add	r9,r6,r8
8000a066:	0a 9c       	mov	r12,r5
8000a068:	6c 28       	ld.w	r8,r6[0x8]
8000a06a:	95 28       	st.w	r10[0x8],r8
8000a06c:	91 3a       	st.w	r8[0xc],r10
8000a06e:	c4 78       	rjmp	8000a0fc <_malloc_r+0xf0>
8000a070:	2f e3       	sub	r3,-2
8000a072:	c4 d8       	rjmp	8000a10c <_malloc_r+0x100>
8000a074:	ee 03 16 09 	lsr	r3,r7,0x9
8000a078:	c0 41       	brne	8000a080 <_malloc_r+0x74>
8000a07a:	ee 03 16 03 	lsr	r3,r7,0x3
8000a07e:	c2 68       	rjmp	8000a0ca <_malloc_r+0xbe>
8000a080:	58 43       	cp.w	r3,4
8000a082:	e0 8b 00 06 	brhi	8000a08e <_malloc_r+0x82>
8000a086:	ee 03 16 06 	lsr	r3,r7,0x6
8000a08a:	2c 83       	sub	r3,-56
8000a08c:	c1 f8       	rjmp	8000a0ca <_malloc_r+0xbe>
8000a08e:	59 43       	cp.w	r3,20
8000a090:	e0 8b 00 04 	brhi	8000a098 <_malloc_r+0x8c>
8000a094:	2a 53       	sub	r3,-91
8000a096:	c1 a8       	rjmp	8000a0ca <_malloc_r+0xbe>
8000a098:	e0 43 00 54 	cp.w	r3,84
8000a09c:	e0 8b 00 06 	brhi	8000a0a8 <_malloc_r+0x9c>
8000a0a0:	ee 03 16 0c 	lsr	r3,r7,0xc
8000a0a4:	29 23       	sub	r3,-110
8000a0a6:	c1 28       	rjmp	8000a0ca <_malloc_r+0xbe>
8000a0a8:	e0 43 01 54 	cp.w	r3,340
8000a0ac:	e0 8b 00 06 	brhi	8000a0b8 <_malloc_r+0xac>
8000a0b0:	ee 03 16 0f 	lsr	r3,r7,0xf
8000a0b4:	28 93       	sub	r3,-119
8000a0b6:	c0 a8       	rjmp	8000a0ca <_malloc_r+0xbe>
8000a0b8:	e0 43 05 54 	cp.w	r3,1364
8000a0bc:	e0 88 00 04 	brls	8000a0c4 <_malloc_r+0xb8>
8000a0c0:	37 e3       	mov	r3,126
8000a0c2:	c0 48       	rjmp	8000a0ca <_malloc_r+0xbe>
8000a0c4:	ee 03 16 12 	lsr	r3,r7,0x12
8000a0c8:	28 43       	sub	r3,-124
8000a0ca:	e0 6a 05 38 	mov	r10,1336
8000a0ce:	f4 03 00 3a 	add	r10,r10,r3<<0x3
8000a0d2:	74 36       	ld.w	r6,r10[0xc]
8000a0d4:	c1 98       	rjmp	8000a106 <_malloc_r+0xfa>
8000a0d6:	6c 19       	ld.w	r9,r6[0x4]
8000a0d8:	e0 19 ff fc 	andl	r9,0xfffc
8000a0dc:	f2 07 01 0b 	sub	r11,r9,r7
8000a0e0:	58 fb       	cp.w	r11,15
8000a0e2:	e0 8a 00 04 	brle	8000a0ea <_malloc_r+0xde>
8000a0e6:	20 13       	sub	r3,1
8000a0e8:	c1 18       	rjmp	8000a10a <_malloc_r+0xfe>
8000a0ea:	6c 38       	ld.w	r8,r6[0xc]
8000a0ec:	58 0b       	cp.w	r11,0
8000a0ee:	c0 b5       	brlt	8000a104 <_malloc_r+0xf8>
8000a0f0:	6c 2a       	ld.w	r10,r6[0x8]
8000a0f2:	ec 09 00 09 	add	r9,r6,r9
8000a0f6:	0a 9c       	mov	r12,r5
8000a0f8:	91 2a       	st.w	r8[0x8],r10
8000a0fa:	95 38       	st.w	r10[0xc],r8
8000a0fc:	72 18       	ld.w	r8,r9[0x4]
8000a0fe:	a1 a8       	sbr	r8,0x0
8000a100:	93 18       	st.w	r9[0x4],r8
8000a102:	cb c8       	rjmp	8000a27a <_malloc_r+0x26e>
8000a104:	10 96       	mov	r6,r8
8000a106:	14 36       	cp.w	r6,r10
8000a108:	ce 71       	brne	8000a0d6 <_malloc_r+0xca>
8000a10a:	2f f3       	sub	r3,-1
8000a10c:	e0 6a 05 38 	mov	r10,1336
8000a110:	f4 cc ff f8 	sub	r12,r10,-8
8000a114:	78 26       	ld.w	r6,r12[0x8]
8000a116:	18 36       	cp.w	r6,r12
8000a118:	c6 c0       	breq	8000a1f0 <_malloc_r+0x1e4>
8000a11a:	6c 19       	ld.w	r9,r6[0x4]
8000a11c:	e0 19 ff fc 	andl	r9,0xfffc
8000a120:	f2 07 01 08 	sub	r8,r9,r7
8000a124:	58 f8       	cp.w	r8,15
8000a126:	e0 89 00 8f 	brgt	8000a244 <_malloc_r+0x238>
8000a12a:	99 3c       	st.w	r12[0xc],r12
8000a12c:	99 2c       	st.w	r12[0x8],r12
8000a12e:	58 08       	cp.w	r8,0
8000a130:	c0 55       	brlt	8000a13a <_malloc_r+0x12e>
8000a132:	ec 09 00 09 	add	r9,r6,r9
8000a136:	0a 9c       	mov	r12,r5
8000a138:	ce 2b       	rjmp	8000a0fc <_malloc_r+0xf0>
8000a13a:	e0 49 01 ff 	cp.w	r9,511
8000a13e:	e0 8b 00 13 	brhi	8000a164 <_malloc_r+0x158>
8000a142:	a3 99       	lsr	r9,0x3
8000a144:	f4 09 00 38 	add	r8,r10,r9<<0x3
8000a148:	70 2b       	ld.w	r11,r8[0x8]
8000a14a:	8d 38       	st.w	r6[0xc],r8
8000a14c:	8d 2b       	st.w	r6[0x8],r11
8000a14e:	97 36       	st.w	r11[0xc],r6
8000a150:	91 26       	st.w	r8[0x8],r6
8000a152:	a3 49       	asr	r9,0x2
8000a154:	74 18       	ld.w	r8,r10[0x4]
8000a156:	30 1b       	mov	r11,1
8000a158:	f6 09 09 49 	lsl	r9,r11,r9
8000a15c:	f1 e9 10 09 	or	r9,r8,r9
8000a160:	95 19       	st.w	r10[0x4],r9
8000a162:	c4 78       	rjmp	8000a1f0 <_malloc_r+0x1e4>
8000a164:	f2 0a 16 09 	lsr	r10,r9,0x9
8000a168:	58 4a       	cp.w	r10,4
8000a16a:	e0 8b 00 07 	brhi	8000a178 <_malloc_r+0x16c>
8000a16e:	f2 0a 16 06 	lsr	r10,r9,0x6
8000a172:	2c 8a       	sub	r10,-56
8000a174:	c2 08       	rjmp	8000a1b4 <_malloc_r+0x1a8>
8000a176:	d7 03       	nop
8000a178:	59 4a       	cp.w	r10,20
8000a17a:	e0 8b 00 04 	brhi	8000a182 <_malloc_r+0x176>
8000a17e:	2a 5a       	sub	r10,-91
8000a180:	c1 a8       	rjmp	8000a1b4 <_malloc_r+0x1a8>
8000a182:	e0 4a 00 54 	cp.w	r10,84
8000a186:	e0 8b 00 06 	brhi	8000a192 <_malloc_r+0x186>
8000a18a:	f2 0a 16 0c 	lsr	r10,r9,0xc
8000a18e:	29 2a       	sub	r10,-110
8000a190:	c1 28       	rjmp	8000a1b4 <_malloc_r+0x1a8>
8000a192:	e0 4a 01 54 	cp.w	r10,340
8000a196:	e0 8b 00 06 	brhi	8000a1a2 <_malloc_r+0x196>
8000a19a:	f2 0a 16 0f 	lsr	r10,r9,0xf
8000a19e:	28 9a       	sub	r10,-119
8000a1a0:	c0 a8       	rjmp	8000a1b4 <_malloc_r+0x1a8>
8000a1a2:	e0 4a 05 54 	cp.w	r10,1364
8000a1a6:	e0 88 00 04 	brls	8000a1ae <_malloc_r+0x1a2>
8000a1aa:	37 ea       	mov	r10,126
8000a1ac:	c0 48       	rjmp	8000a1b4 <_malloc_r+0x1a8>
8000a1ae:	f2 0a 16 12 	lsr	r10,r9,0x12
8000a1b2:	28 4a       	sub	r10,-124
8000a1b4:	e0 6b 05 38 	mov	r11,1336
8000a1b8:	f6 0a 00 34 	add	r4,r11,r10<<0x3
8000a1bc:	68 28       	ld.w	r8,r4[0x8]
8000a1be:	08 38       	cp.w	r8,r4
8000a1c0:	c0 e1       	brne	8000a1dc <_malloc_r+0x1d0>
8000a1c2:	76 19       	ld.w	r9,r11[0x4]
8000a1c4:	a3 4a       	asr	r10,0x2
8000a1c6:	30 1e       	mov	lr,1
8000a1c8:	fc 0a 09 4a 	lsl	r10,lr,r10
8000a1cc:	f3 ea 10 0a 	or	r10,r9,r10
8000a1d0:	10 99       	mov	r9,r8
8000a1d2:	97 1a       	st.w	r11[0x4],r10
8000a1d4:	c0 a8       	rjmp	8000a1e8 <_malloc_r+0x1dc>
8000a1d6:	70 28       	ld.w	r8,r8[0x8]
8000a1d8:	08 38       	cp.w	r8,r4
8000a1da:	c0 60       	breq	8000a1e6 <_malloc_r+0x1da>
8000a1dc:	70 1a       	ld.w	r10,r8[0x4]
8000a1de:	e0 1a ff fc 	andl	r10,0xfffc
8000a1e2:	14 39       	cp.w	r9,r10
8000a1e4:	cf 93       	brcs	8000a1d6 <_malloc_r+0x1ca>
8000a1e6:	70 39       	ld.w	r9,r8[0xc]
8000a1e8:	8d 39       	st.w	r6[0xc],r9
8000a1ea:	8d 28       	st.w	r6[0x8],r8
8000a1ec:	91 36       	st.w	r8[0xc],r6
8000a1ee:	93 26       	st.w	r9[0x8],r6
8000a1f0:	e6 08 14 02 	asr	r8,r3,0x2
8000a1f4:	30 1b       	mov	r11,1
8000a1f6:	e0 64 05 38 	mov	r4,1336
8000a1fa:	f6 08 09 4b 	lsl	r11,r11,r8
8000a1fe:	68 18       	ld.w	r8,r4[0x4]
8000a200:	10 3b       	cp.w	r11,r8
8000a202:	e0 8b 00 6b 	brhi	8000a2d8 <_malloc_r+0x2cc>
8000a206:	f7 e8 00 09 	and	r9,r11,r8
8000a20a:	c0 b1       	brne	8000a220 <_malloc_r+0x214>
8000a20c:	e0 13 ff fc 	andl	r3,0xfffc
8000a210:	a1 7b       	lsl	r11,0x1
8000a212:	2f c3       	sub	r3,-4
8000a214:	c0 38       	rjmp	8000a21a <_malloc_r+0x20e>
8000a216:	2f c3       	sub	r3,-4
8000a218:	a1 7b       	lsl	r11,0x1
8000a21a:	f7 e8 00 09 	and	r9,r11,r8
8000a21e:	cf c0       	breq	8000a216 <_malloc_r+0x20a>
8000a220:	e8 03 00 3e 	add	lr,r4,r3<<0x3
8000a224:	06 92       	mov	r2,r3
8000a226:	1c 91       	mov	r1,lr
8000a228:	62 36       	ld.w	r6,r1[0xc]
8000a22a:	c2 e8       	rjmp	8000a286 <_malloc_r+0x27a>
8000a22c:	6c 1a       	ld.w	r10,r6[0x4]
8000a22e:	e0 1a ff fc 	andl	r10,0xfffc
8000a232:	f4 07 01 08 	sub	r8,r10,r7
8000a236:	58 f8       	cp.w	r8,15
8000a238:	e0 8a 00 15 	brle	8000a262 <_malloc_r+0x256>
8000a23c:	6c 3a       	ld.w	r10,r6[0xc]
8000a23e:	6c 29       	ld.w	r9,r6[0x8]
8000a240:	95 29       	st.w	r10[0x8],r9
8000a242:	93 3a       	st.w	r9[0xc],r10
8000a244:	0e 99       	mov	r9,r7
8000a246:	ec 07 00 07 	add	r7,r6,r7
8000a24a:	a1 a9       	sbr	r9,0x0
8000a24c:	99 37       	st.w	r12[0xc],r7
8000a24e:	99 27       	st.w	r12[0x8],r7
8000a250:	8d 19       	st.w	r6[0x4],r9
8000a252:	ee 08 09 08 	st.w	r7[r8],r8
8000a256:	8f 2c       	st.w	r7[0x8],r12
8000a258:	8f 3c       	st.w	r7[0xc],r12
8000a25a:	a1 a8       	sbr	r8,0x0
8000a25c:	0a 9c       	mov	r12,r5
8000a25e:	8f 18       	st.w	r7[0x4],r8
8000a260:	c0 d8       	rjmp	8000a27a <_malloc_r+0x26e>
8000a262:	6c 39       	ld.w	r9,r6[0xc]
8000a264:	58 08       	cp.w	r8,0
8000a266:	c0 f5       	brlt	8000a284 <_malloc_r+0x278>
8000a268:	ec 0a 00 0a 	add	r10,r6,r10
8000a26c:	74 18       	ld.w	r8,r10[0x4]
8000a26e:	a1 a8       	sbr	r8,0x0
8000a270:	0a 9c       	mov	r12,r5
8000a272:	95 18       	st.w	r10[0x4],r8
8000a274:	6c 28       	ld.w	r8,r6[0x8]
8000a276:	93 28       	st.w	r9[0x8],r8
8000a278:	91 39       	st.w	r8[0xc],r9
8000a27a:	fe b0 f4 1b 	rcall	80008ab0 <__malloc_unlock>
8000a27e:	ec cc ff f8 	sub	r12,r6,-8
8000a282:	d8 32       	popm	r0-r7,pc
8000a284:	12 96       	mov	r6,r9
8000a286:	02 36       	cp.w	r6,r1
8000a288:	cd 21       	brne	8000a22c <_malloc_r+0x220>
8000a28a:	2f f2       	sub	r2,-1
8000a28c:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
8000a290:	c0 30       	breq	8000a296 <_malloc_r+0x28a>
8000a292:	2f 81       	sub	r1,-8
8000a294:	cc ab       	rjmp	8000a228 <_malloc_r+0x21c>
8000a296:	1c 98       	mov	r8,lr
8000a298:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
8000a29c:	c0 81       	brne	8000a2ac <_malloc_r+0x2a0>
8000a29e:	68 19       	ld.w	r9,r4[0x4]
8000a2a0:	f6 08 11 ff 	rsub	r8,r11,-1
8000a2a4:	f3 e8 00 08 	and	r8,r9,r8
8000a2a8:	89 18       	st.w	r4[0x4],r8
8000a2aa:	c0 78       	rjmp	8000a2b8 <_malloc_r+0x2ac>
8000a2ac:	f0 c9 00 08 	sub	r9,r8,8
8000a2b0:	20 13       	sub	r3,1
8000a2b2:	70 08       	ld.w	r8,r8[0x0]
8000a2b4:	12 38       	cp.w	r8,r9
8000a2b6:	cf 10       	breq	8000a298 <_malloc_r+0x28c>
8000a2b8:	a1 7b       	lsl	r11,0x1
8000a2ba:	68 18       	ld.w	r8,r4[0x4]
8000a2bc:	10 3b       	cp.w	r11,r8
8000a2be:	e0 8b 00 0d 	brhi	8000a2d8 <_malloc_r+0x2cc>
8000a2c2:	58 0b       	cp.w	r11,0
8000a2c4:	c0 a0       	breq	8000a2d8 <_malloc_r+0x2cc>
8000a2c6:	04 93       	mov	r3,r2
8000a2c8:	c0 38       	rjmp	8000a2ce <_malloc_r+0x2c2>
8000a2ca:	2f c3       	sub	r3,-4
8000a2cc:	a1 7b       	lsl	r11,0x1
8000a2ce:	f7 e8 00 09 	and	r9,r11,r8
8000a2d2:	ca 71       	brne	8000a220 <_malloc_r+0x214>
8000a2d4:	cf bb       	rjmp	8000a2ca <_malloc_r+0x2be>
8000a2d6:	d7 03       	nop
8000a2d8:	68 23       	ld.w	r3,r4[0x8]
8000a2da:	66 12       	ld.w	r2,r3[0x4]
8000a2dc:	e0 12 ff fc 	andl	r2,0xfffc
8000a2e0:	0e 32       	cp.w	r2,r7
8000a2e2:	5f 39       	srlo	r9
8000a2e4:	e4 07 01 08 	sub	r8,r2,r7
8000a2e8:	58 f8       	cp.w	r8,15
8000a2ea:	5f aa       	srle	r10
8000a2ec:	f5 e9 10 09 	or	r9,r10,r9
8000a2f0:	e0 80 00 9a 	breq	8000a424 <_malloc_r+0x418>
8000a2f4:	e0 68 12 9c 	mov	r8,4764
8000a2f8:	70 01       	ld.w	r1,r8[0x0]
8000a2fa:	e0 68 09 44 	mov	r8,2372
8000a2fe:	2f 01       	sub	r1,-16
8000a300:	70 08       	ld.w	r8,r8[0x0]
8000a302:	0e 01       	add	r1,r7
8000a304:	5b f8       	cp.w	r8,-1
8000a306:	c0 40       	breq	8000a30e <_malloc_r+0x302>
8000a308:	28 11       	sub	r1,-127
8000a30a:	e0 11 ff 80 	andl	r1,0xff80
8000a30e:	02 9b       	mov	r11,r1
8000a310:	0a 9c       	mov	r12,r5
8000a312:	e0 a0 02 b7 	rcall	8000a880 <_sbrk_r>
8000a316:	18 96       	mov	r6,r12
8000a318:	5b fc       	cp.w	r12,-1
8000a31a:	c7 50       	breq	8000a404 <_malloc_r+0x3f8>
8000a31c:	e6 02 00 08 	add	r8,r3,r2
8000a320:	10 3c       	cp.w	r12,r8
8000a322:	c0 32       	brcc	8000a328 <_malloc_r+0x31c>
8000a324:	08 33       	cp.w	r3,r4
8000a326:	c6 f1       	brne	8000a404 <_malloc_r+0x3f8>
8000a328:	e0 6a 12 a0 	mov	r10,4768
8000a32c:	74 09       	ld.w	r9,r10[0x0]
8000a32e:	e2 09 00 09 	add	r9,r1,r9
8000a332:	95 09       	st.w	r10[0x0],r9
8000a334:	10 36       	cp.w	r6,r8
8000a336:	c0 a1       	brne	8000a34a <_malloc_r+0x33e>
8000a338:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
8000a33c:	c0 71       	brne	8000a34a <_malloc_r+0x33e>
8000a33e:	e2 02 00 02 	add	r2,r1,r2
8000a342:	68 28       	ld.w	r8,r4[0x8]
8000a344:	a1 a2       	sbr	r2,0x0
8000a346:	91 12       	st.w	r8[0x4],r2
8000a348:	c4 f8       	rjmp	8000a3e6 <_malloc_r+0x3da>
8000a34a:	e0 6a 09 44 	mov	r10,2372
8000a34e:	74 0b       	ld.w	r11,r10[0x0]
8000a350:	5b fb       	cp.w	r11,-1
8000a352:	c0 31       	brne	8000a358 <_malloc_r+0x34c>
8000a354:	95 06       	st.w	r10[0x0],r6
8000a356:	c0 78       	rjmp	8000a364 <_malloc_r+0x358>
8000a358:	ec 09 00 09 	add	r9,r6,r9
8000a35c:	e0 6a 12 a0 	mov	r10,4768
8000a360:	10 19       	sub	r9,r8
8000a362:	95 09       	st.w	r10[0x0],r9
8000a364:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
8000a368:	f0 09 11 08 	rsub	r9,r8,8
8000a36c:	58 08       	cp.w	r8,0
8000a36e:	f2 08 17 10 	movne	r8,r9
8000a372:	ed d8 e1 06 	addne	r6,r6,r8
8000a376:	28 08       	sub	r8,-128
8000a378:	ec 01 00 01 	add	r1,r6,r1
8000a37c:	0a 9c       	mov	r12,r5
8000a37e:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
8000a382:	f0 01 01 01 	sub	r1,r8,r1
8000a386:	02 9b       	mov	r11,r1
8000a388:	e0 a0 02 7c 	rcall	8000a880 <_sbrk_r>
8000a38c:	e0 68 12 a0 	mov	r8,4768
8000a390:	5b fc       	cp.w	r12,-1
8000a392:	ec 0c 17 00 	moveq	r12,r6
8000a396:	f9 b1 00 00 	moveq	r1,0
8000a39a:	70 09       	ld.w	r9,r8[0x0]
8000a39c:	0c 1c       	sub	r12,r6
8000a39e:	89 26       	st.w	r4[0x8],r6
8000a3a0:	02 0c       	add	r12,r1
8000a3a2:	12 01       	add	r1,r9
8000a3a4:	a1 ac       	sbr	r12,0x0
8000a3a6:	91 01       	st.w	r8[0x0],r1
8000a3a8:	8d 1c       	st.w	r6[0x4],r12
8000a3aa:	08 33       	cp.w	r3,r4
8000a3ac:	c1 d0       	breq	8000a3e6 <_malloc_r+0x3da>
8000a3ae:	58 f2       	cp.w	r2,15
8000a3b0:	e0 8b 00 05 	brhi	8000a3ba <_malloc_r+0x3ae>
8000a3b4:	30 18       	mov	r8,1
8000a3b6:	8d 18       	st.w	r6[0x4],r8
8000a3b8:	c2 68       	rjmp	8000a404 <_malloc_r+0x3f8>
8000a3ba:	30 59       	mov	r9,5
8000a3bc:	20 c2       	sub	r2,12
8000a3be:	e0 12 ff f8 	andl	r2,0xfff8
8000a3c2:	e6 02 00 08 	add	r8,r3,r2
8000a3c6:	91 29       	st.w	r8[0x8],r9
8000a3c8:	91 19       	st.w	r8[0x4],r9
8000a3ca:	66 18       	ld.w	r8,r3[0x4]
8000a3cc:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000a3d0:	e5 e8 10 08 	or	r8,r2,r8
8000a3d4:	87 18       	st.w	r3[0x4],r8
8000a3d6:	58 f2       	cp.w	r2,15
8000a3d8:	e0 88 00 07 	brls	8000a3e6 <_malloc_r+0x3da>
8000a3dc:	e6 cb ff f8 	sub	r11,r3,-8
8000a3e0:	0a 9c       	mov	r12,r5
8000a3e2:	e0 a0 1d 23 	rcall	8000de28 <_free_r>
8000a3e6:	e0 69 12 98 	mov	r9,4760
8000a3ea:	72 0a       	ld.w	r10,r9[0x0]
8000a3ec:	e0 68 12 a0 	mov	r8,4768
8000a3f0:	70 08       	ld.w	r8,r8[0x0]
8000a3f2:	14 38       	cp.w	r8,r10
8000a3f4:	f3 f8 ba 00 	st.whi	r9[0x0],r8
8000a3f8:	e0 69 12 94 	mov	r9,4756
8000a3fc:	72 0a       	ld.w	r10,r9[0x0]
8000a3fe:	14 38       	cp.w	r8,r10
8000a400:	f3 f8 ba 00 	st.whi	r9[0x0],r8
8000a404:	68 28       	ld.w	r8,r4[0x8]
8000a406:	70 18       	ld.w	r8,r8[0x4]
8000a408:	e0 18 ff fc 	andl	r8,0xfffc
8000a40c:	0e 38       	cp.w	r8,r7
8000a40e:	5f 39       	srlo	r9
8000a410:	0e 18       	sub	r8,r7
8000a412:	58 f8       	cp.w	r8,15
8000a414:	5f aa       	srle	r10
8000a416:	f5 e9 10 09 	or	r9,r10,r9
8000a41a:	c0 50       	breq	8000a424 <_malloc_r+0x418>
8000a41c:	0a 9c       	mov	r12,r5
8000a41e:	fe b0 f3 49 	rcall	80008ab0 <__malloc_unlock>
8000a422:	d8 3a       	popm	r0-r7,pc,r12=0
8000a424:	68 26       	ld.w	r6,r4[0x8]
8000a426:	a1 a8       	sbr	r8,0x0
8000a428:	0e 99       	mov	r9,r7
8000a42a:	a1 a9       	sbr	r9,0x0
8000a42c:	8d 19       	st.w	r6[0x4],r9
8000a42e:	ec 07 00 07 	add	r7,r6,r7
8000a432:	0a 9c       	mov	r12,r5
8000a434:	89 27       	st.w	r4[0x8],r7
8000a436:	8f 18       	st.w	r7[0x4],r8
8000a438:	fe b0 f3 3c 	rcall	80008ab0 <__malloc_unlock>
8000a43c:	ec cc ff f8 	sub	r12,r6,-8
8000a440:	d8 32       	popm	r0-r7,pc
8000a442:	d7 03       	nop

8000a444 <memcmp>:
8000a444:	d4 01       	pushm	lr
8000a446:	30 08       	mov	r8,0
8000a448:	c0 d8       	rjmp	8000a462 <memcmp+0x1e>
8000a44a:	f8 08 07 0e 	ld.ub	lr,r12[r8]
8000a44e:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000a452:	20 1a       	sub	r10,1
8000a454:	2f f8       	sub	r8,-1
8000a456:	f2 0e 18 00 	cp.b	lr,r9
8000a45a:	c0 40       	breq	8000a462 <memcmp+0x1e>
8000a45c:	fc 09 01 0c 	sub	r12,lr,r9
8000a460:	d8 02       	popm	pc
8000a462:	58 0a       	cp.w	r10,0
8000a464:	cf 31       	brne	8000a44a <memcmp+0x6>
8000a466:	14 9c       	mov	r12,r10
8000a468:	d8 02       	popm	pc

8000a46a <memcpy>:
8000a46a:	58 8a       	cp.w	r10,8
8000a46c:	c2 f5       	brlt	8000a4ca <memcpy+0x60>
8000a46e:	f9 eb 10 09 	or	r9,r12,r11
8000a472:	e2 19 00 03 	andl	r9,0x3,COH
8000a476:	e0 81 00 97 	brne	8000a5a4 <memcpy+0x13a>
8000a47a:	e0 4a 00 20 	cp.w	r10,32
8000a47e:	c3 b4       	brge	8000a4f4 <memcpy+0x8a>
8000a480:	f4 08 14 02 	asr	r8,r10,0x2
8000a484:	f0 09 11 08 	rsub	r9,r8,8
8000a488:	fe 09 00 2f 	add	pc,pc,r9<<0x2
8000a48c:	76 69       	ld.w	r9,r11[0x18]
8000a48e:	99 69       	st.w	r12[0x18],r9
8000a490:	76 59       	ld.w	r9,r11[0x14]
8000a492:	99 59       	st.w	r12[0x14],r9
8000a494:	76 49       	ld.w	r9,r11[0x10]
8000a496:	99 49       	st.w	r12[0x10],r9
8000a498:	76 39       	ld.w	r9,r11[0xc]
8000a49a:	99 39       	st.w	r12[0xc],r9
8000a49c:	76 29       	ld.w	r9,r11[0x8]
8000a49e:	99 29       	st.w	r12[0x8],r9
8000a4a0:	76 19       	ld.w	r9,r11[0x4]
8000a4a2:	99 19       	st.w	r12[0x4],r9
8000a4a4:	76 09       	ld.w	r9,r11[0x0]
8000a4a6:	99 09       	st.w	r12[0x0],r9
8000a4a8:	f6 08 00 2b 	add	r11,r11,r8<<0x2
8000a4ac:	f8 08 00 28 	add	r8,r12,r8<<0x2
8000a4b0:	e0 1a 00 03 	andl	r10,0x3
8000a4b4:	f4 0a 11 04 	rsub	r10,r10,4
8000a4b8:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
8000a4bc:	17 a9       	ld.ub	r9,r11[0x2]
8000a4be:	b0 a9       	st.b	r8[0x2],r9
8000a4c0:	17 99       	ld.ub	r9,r11[0x1]
8000a4c2:	b0 99       	st.b	r8[0x1],r9
8000a4c4:	17 89       	ld.ub	r9,r11[0x0]
8000a4c6:	b0 89       	st.b	r8[0x0],r9
8000a4c8:	5e fc       	retal	r12
8000a4ca:	f4 0a 11 09 	rsub	r10,r10,9
8000a4ce:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
8000a4d2:	17 f9       	ld.ub	r9,r11[0x7]
8000a4d4:	b8 f9       	st.b	r12[0x7],r9
8000a4d6:	17 e9       	ld.ub	r9,r11[0x6]
8000a4d8:	b8 e9       	st.b	r12[0x6],r9
8000a4da:	17 d9       	ld.ub	r9,r11[0x5]
8000a4dc:	b8 d9       	st.b	r12[0x5],r9
8000a4de:	17 c9       	ld.ub	r9,r11[0x4]
8000a4e0:	b8 c9       	st.b	r12[0x4],r9
8000a4e2:	17 b9       	ld.ub	r9,r11[0x3]
8000a4e4:	b8 b9       	st.b	r12[0x3],r9
8000a4e6:	17 a9       	ld.ub	r9,r11[0x2]
8000a4e8:	b8 a9       	st.b	r12[0x2],r9
8000a4ea:	17 99       	ld.ub	r9,r11[0x1]
8000a4ec:	b8 99       	st.b	r12[0x1],r9
8000a4ee:	17 89       	ld.ub	r9,r11[0x0]
8000a4f0:	b8 89       	st.b	r12[0x0],r9
8000a4f2:	5e fc       	retal	r12
8000a4f4:	eb cd 40 c0 	pushm	r6-r7,lr
8000a4f8:	18 99       	mov	r9,r12
8000a4fa:	22 0a       	sub	r10,32
8000a4fc:	b7 07       	ld.d	r6,r11++
8000a4fe:	b3 26       	st.d	r9++,r6
8000a500:	b7 07       	ld.d	r6,r11++
8000a502:	b3 26       	st.d	r9++,r6
8000a504:	b7 07       	ld.d	r6,r11++
8000a506:	b3 26       	st.d	r9++,r6
8000a508:	b7 07       	ld.d	r6,r11++
8000a50a:	b3 26       	st.d	r9++,r6
8000a50c:	22 0a       	sub	r10,32
8000a50e:	cf 74       	brge	8000a4fc <memcpy+0x92>
8000a510:	2f 0a       	sub	r10,-16
8000a512:	c0 65       	brlt	8000a51e <memcpy+0xb4>
8000a514:	b7 07       	ld.d	r6,r11++
8000a516:	b3 26       	st.d	r9++,r6
8000a518:	b7 07       	ld.d	r6,r11++
8000a51a:	b3 26       	st.d	r9++,r6
8000a51c:	21 0a       	sub	r10,16
8000a51e:	5c 3a       	neg	r10
8000a520:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
8000a524:	d7 03       	nop
8000a526:	d7 03       	nop
8000a528:	f7 36 00 0e 	ld.ub	r6,r11[14]
8000a52c:	f3 66 00 0e 	st.b	r9[14],r6
8000a530:	f7 36 00 0d 	ld.ub	r6,r11[13]
8000a534:	f3 66 00 0d 	st.b	r9[13],r6
8000a538:	f7 36 00 0c 	ld.ub	r6,r11[12]
8000a53c:	f3 66 00 0c 	st.b	r9[12],r6
8000a540:	f7 36 00 0b 	ld.ub	r6,r11[11]
8000a544:	f3 66 00 0b 	st.b	r9[11],r6
8000a548:	f7 36 00 0a 	ld.ub	r6,r11[10]
8000a54c:	f3 66 00 0a 	st.b	r9[10],r6
8000a550:	f7 36 00 09 	ld.ub	r6,r11[9]
8000a554:	f3 66 00 09 	st.b	r9[9],r6
8000a558:	f7 36 00 08 	ld.ub	r6,r11[8]
8000a55c:	f3 66 00 08 	st.b	r9[8],r6
8000a560:	f7 36 00 07 	ld.ub	r6,r11[7]
8000a564:	f3 66 00 07 	st.b	r9[7],r6
8000a568:	f7 36 00 06 	ld.ub	r6,r11[6]
8000a56c:	f3 66 00 06 	st.b	r9[6],r6
8000a570:	f7 36 00 05 	ld.ub	r6,r11[5]
8000a574:	f3 66 00 05 	st.b	r9[5],r6
8000a578:	f7 36 00 04 	ld.ub	r6,r11[4]
8000a57c:	f3 66 00 04 	st.b	r9[4],r6
8000a580:	f7 36 00 03 	ld.ub	r6,r11[3]
8000a584:	f3 66 00 03 	st.b	r9[3],r6
8000a588:	f7 36 00 02 	ld.ub	r6,r11[2]
8000a58c:	f3 66 00 02 	st.b	r9[2],r6
8000a590:	f7 36 00 01 	ld.ub	r6,r11[1]
8000a594:	f3 66 00 01 	st.b	r9[1],r6
8000a598:	f7 36 00 00 	ld.ub	r6,r11[0]
8000a59c:	f3 66 00 00 	st.b	r9[0],r6
8000a5a0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000a5a4:	20 1a       	sub	r10,1
8000a5a6:	f6 0a 07 09 	ld.ub	r9,r11[r10]
8000a5aa:	f8 0a 0b 09 	st.b	r12[r10],r9
8000a5ae:	cf b1       	brne	8000a5a4 <memcpy+0x13a>
8000a5b0:	5e fc       	retal	r12

8000a5b2 <memset>:
8000a5b2:	18 98       	mov	r8,r12
8000a5b4:	c0 38       	rjmp	8000a5ba <memset+0x8>
8000a5b6:	10 cb       	st.b	r8++,r11
8000a5b8:	20 1a       	sub	r10,1
8000a5ba:	58 0a       	cp.w	r10,0
8000a5bc:	cf d1       	brne	8000a5b6 <memset+0x4>
8000a5be:	5e fc       	retal	r12

8000a5c0 <_realloc_r>:
8000a5c0:	d4 31       	pushm	r0-r7,lr
8000a5c2:	20 1d       	sub	sp,4
8000a5c4:	16 94       	mov	r4,r11
8000a5c6:	18 92       	mov	r2,r12
8000a5c8:	14 9b       	mov	r11,r10
8000a5ca:	58 04       	cp.w	r4,0
8000a5cc:	c0 51       	brne	8000a5d6 <_realloc_r+0x16>
8000a5ce:	fe b0 fd 1f 	rcall	8000a00c <_malloc_r>
8000a5d2:	18 95       	mov	r5,r12
8000a5d4:	c5 39       	rjmp	8000a87a <_realloc_r+0x2ba>
8000a5d6:	50 0a       	stdsp	sp[0x0],r10
8000a5d8:	fe b0 f2 66 	rcall	80008aa4 <__malloc_lock>
8000a5dc:	40 0b       	lddsp	r11,sp[0x0]
8000a5de:	f6 c8 ff f5 	sub	r8,r11,-11
8000a5e2:	e8 c1 00 08 	sub	r1,r4,8
8000a5e6:	10 96       	mov	r6,r8
8000a5e8:	62 1c       	ld.w	r12,r1[0x4]
8000a5ea:	e0 16 ff f8 	andl	r6,0xfff8
8000a5ee:	59 68       	cp.w	r8,22
8000a5f0:	f9 b6 08 10 	movls	r6,16
8000a5f4:	16 36       	cp.w	r6,r11
8000a5f6:	5f 38       	srlo	r8
8000a5f8:	f1 e6 13 f8 	or	r8,r8,r6>>0x1f
8000a5fc:	c0 50       	breq	8000a606 <_realloc_r+0x46>
8000a5fe:	30 c8       	mov	r8,12
8000a600:	30 05       	mov	r5,0
8000a602:	85 38       	st.w	r2[0xc],r8
8000a604:	c3 b9       	rjmp	8000a87a <_realloc_r+0x2ba>
8000a606:	18 90       	mov	r0,r12
8000a608:	e0 10 ff fc 	andl	r0,0xfffc
8000a60c:	0c 30       	cp.w	r0,r6
8000a60e:	e0 84 01 0b 	brge	8000a824 <_realloc_r+0x264>
8000a612:	e0 68 05 38 	mov	r8,1336
8000a616:	e2 00 00 09 	add	r9,r1,r0
8000a61a:	70 25       	ld.w	r5,r8[0x8]
8000a61c:	0a 39       	cp.w	r9,r5
8000a61e:	c0 90       	breq	8000a630 <_realloc_r+0x70>
8000a620:	72 1a       	ld.w	r10,r9[0x4]
8000a622:	a1 ca       	cbr	r10,0x0
8000a624:	f2 0a 00 0a 	add	r10,r9,r10
8000a628:	74 1a       	ld.w	r10,r10[0x4]
8000a62a:	ed ba 00 00 	bld	r10,0x0
8000a62e:	c2 20       	breq	8000a672 <_realloc_r+0xb2>
8000a630:	72 1a       	ld.w	r10,r9[0x4]
8000a632:	e0 1a ff fc 	andl	r10,0xfffc
8000a636:	f4 00 00 03 	add	r3,r10,r0
8000a63a:	0a 39       	cp.w	r9,r5
8000a63c:	c1 31       	brne	8000a662 <_realloc_r+0xa2>
8000a63e:	ec c7 ff f0 	sub	r7,r6,-16
8000a642:	0e 33       	cp.w	r3,r7
8000a644:	c1 95       	brlt	8000a676 <_realloc_r+0xb6>
8000a646:	e2 06 00 09 	add	r9,r1,r6
8000a64a:	0c 13       	sub	r3,r6
8000a64c:	a1 a3       	sbr	r3,0x0
8000a64e:	93 13       	st.w	r9[0x4],r3
8000a650:	91 29       	st.w	r8[0x8],r9
8000a652:	04 9c       	mov	r12,r2
8000a654:	62 18       	ld.w	r8,r1[0x4]
8000a656:	08 95       	mov	r5,r4
8000a658:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000a65c:	10 46       	or	r6,r8
8000a65e:	83 16       	st.w	r1[0x4],r6
8000a660:	c0 b9       	rjmp	8000a876 <_realloc_r+0x2b6>
8000a662:	0c 33       	cp.w	r3,r6
8000a664:	c0 95       	brlt	8000a676 <_realloc_r+0xb6>
8000a666:	72 28       	ld.w	r8,r9[0x8]
8000a668:	02 97       	mov	r7,r1
8000a66a:	72 39       	ld.w	r9,r9[0xc]
8000a66c:	93 28       	st.w	r9[0x8],r8
8000a66e:	91 39       	st.w	r8[0xc],r9
8000a670:	cd c8       	rjmp	8000a828 <_realloc_r+0x268>
8000a672:	30 0a       	mov	r10,0
8000a674:	14 99       	mov	r9,r10
8000a676:	ed bc 00 00 	bld	r12,0x0
8000a67a:	e0 80 00 95 	breq	8000a7a4 <_realloc_r+0x1e4>
8000a67e:	62 07       	ld.w	r7,r1[0x0]
8000a680:	e2 07 01 07 	sub	r7,r1,r7
8000a684:	6e 1c       	ld.w	r12,r7[0x4]
8000a686:	e0 1c ff fc 	andl	r12,0xfffc
8000a68a:	58 09       	cp.w	r9,0
8000a68c:	c5 60       	breq	8000a738 <_realloc_r+0x178>
8000a68e:	f8 00 00 03 	add	r3,r12,r0
8000a692:	0a 39       	cp.w	r9,r5
8000a694:	c4 81       	brne	8000a724 <_realloc_r+0x164>
8000a696:	14 03       	add	r3,r10
8000a698:	ec c9 ff f0 	sub	r9,r6,-16
8000a69c:	12 33       	cp.w	r3,r9
8000a69e:	c4 d5       	brlt	8000a738 <_realloc_r+0x178>
8000a6a0:	6e 3a       	ld.w	r10,r7[0xc]
8000a6a2:	6e 29       	ld.w	r9,r7[0x8]
8000a6a4:	95 29       	st.w	r10[0x8],r9
8000a6a6:	93 3a       	st.w	r9[0xc],r10
8000a6a8:	ee c5 ff f8 	sub	r5,r7,-8
8000a6ac:	e0 ca 00 04 	sub	r10,r0,4
8000a6b0:	e0 4a 00 24 	cp.w	r10,36
8000a6b4:	e0 8b 00 25 	brhi	8000a6fe <_realloc_r+0x13e>
8000a6b8:	0a 99       	mov	r9,r5
8000a6ba:	59 3a       	cp.w	r10,19
8000a6bc:	e0 88 00 1a 	brls	8000a6f0 <_realloc_r+0x130>
8000a6c0:	09 09       	ld.w	r9,r4++
8000a6c2:	8b 09       	st.w	r5[0x0],r9
8000a6c4:	09 09       	ld.w	r9,r4++
8000a6c6:	8f 39       	st.w	r7[0xc],r9
8000a6c8:	ee c9 ff f0 	sub	r9,r7,-16
8000a6cc:	59 ba       	cp.w	r10,27
8000a6ce:	e0 88 00 11 	brls	8000a6f0 <_realloc_r+0x130>
8000a6d2:	09 0b       	ld.w	r11,r4++
8000a6d4:	93 0b       	st.w	r9[0x0],r11
8000a6d6:	09 09       	ld.w	r9,r4++
8000a6d8:	8f 59       	st.w	r7[0x14],r9
8000a6da:	ee c9 ff e8 	sub	r9,r7,-24
8000a6de:	e0 4a 00 24 	cp.w	r10,36
8000a6e2:	c0 71       	brne	8000a6f0 <_realloc_r+0x130>
8000a6e4:	09 0a       	ld.w	r10,r4++
8000a6e6:	93 0a       	st.w	r9[0x0],r10
8000a6e8:	ee c9 ff e0 	sub	r9,r7,-32
8000a6ec:	09 0a       	ld.w	r10,r4++
8000a6ee:	8f 7a       	st.w	r7[0x1c],r10
8000a6f0:	09 0a       	ld.w	r10,r4++
8000a6f2:	12 aa       	st.w	r9++,r10
8000a6f4:	68 0a       	ld.w	r10,r4[0x0]
8000a6f6:	93 0a       	st.w	r9[0x0],r10
8000a6f8:	68 1a       	ld.w	r10,r4[0x4]
8000a6fa:	93 1a       	st.w	r9[0x4],r10
8000a6fc:	c0 78       	rjmp	8000a70a <_realloc_r+0x14a>
8000a6fe:	50 08       	stdsp	sp[0x0],r8
8000a700:	08 9b       	mov	r11,r4
8000a702:	0a 9c       	mov	r12,r5
8000a704:	e0 a0 1e 35 	rcall	8000e36e <memmove>
8000a708:	40 08       	lddsp	r8,sp[0x0]
8000a70a:	ee 06 00 09 	add	r9,r7,r6
8000a70e:	0c 13       	sub	r3,r6
8000a710:	a1 a3       	sbr	r3,0x0
8000a712:	93 13       	st.w	r9[0x4],r3
8000a714:	91 29       	st.w	r8[0x8],r9
8000a716:	04 9c       	mov	r12,r2
8000a718:	6e 18       	ld.w	r8,r7[0x4]
8000a71a:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000a71e:	10 46       	or	r6,r8
8000a720:	8f 16       	st.w	r7[0x4],r6
8000a722:	ca a8       	rjmp	8000a876 <_realloc_r+0x2b6>
8000a724:	14 03       	add	r3,r10
8000a726:	0c 33       	cp.w	r3,r6
8000a728:	c0 85       	brlt	8000a738 <_realloc_r+0x178>
8000a72a:	72 28       	ld.w	r8,r9[0x8]
8000a72c:	72 39       	ld.w	r9,r9[0xc]
8000a72e:	93 28       	st.w	r9[0x8],r8
8000a730:	91 39       	st.w	r8[0xc],r9
8000a732:	6e 28       	ld.w	r8,r7[0x8]
8000a734:	6e 39       	ld.w	r9,r7[0xc]
8000a736:	c0 78       	rjmp	8000a744 <_realloc_r+0x184>
8000a738:	f8 00 00 03 	add	r3,r12,r0
8000a73c:	0c 33       	cp.w	r3,r6
8000a73e:	c3 35       	brlt	8000a7a4 <_realloc_r+0x1e4>
8000a740:	6e 39       	ld.w	r9,r7[0xc]
8000a742:	6e 28       	ld.w	r8,r7[0x8]
8000a744:	93 28       	st.w	r9[0x8],r8
8000a746:	91 39       	st.w	r8[0xc],r9
8000a748:	e0 ca 00 04 	sub	r10,r0,4
8000a74c:	ee cc ff f8 	sub	r12,r7,-8
8000a750:	e0 4a 00 24 	cp.w	r10,36
8000a754:	e0 8b 00 24 	brhi	8000a79c <_realloc_r+0x1dc>
8000a758:	59 3a       	cp.w	r10,19
8000a75a:	e0 88 00 1a 	brls	8000a78e <_realloc_r+0x1ce>
8000a75e:	09 08       	ld.w	r8,r4++
8000a760:	99 08       	st.w	r12[0x0],r8
8000a762:	09 08       	ld.w	r8,r4++
8000a764:	8f 38       	st.w	r7[0xc],r8
8000a766:	ee cc ff f0 	sub	r12,r7,-16
8000a76a:	59 ba       	cp.w	r10,27
8000a76c:	e0 88 00 11 	brls	8000a78e <_realloc_r+0x1ce>
8000a770:	09 08       	ld.w	r8,r4++
8000a772:	99 08       	st.w	r12[0x0],r8
8000a774:	09 08       	ld.w	r8,r4++
8000a776:	8f 58       	st.w	r7[0x14],r8
8000a778:	ee cc ff e8 	sub	r12,r7,-24
8000a77c:	e0 4a 00 24 	cp.w	r10,36
8000a780:	c0 71       	brne	8000a78e <_realloc_r+0x1ce>
8000a782:	09 08       	ld.w	r8,r4++
8000a784:	99 08       	st.w	r12[0x0],r8
8000a786:	ee cc ff e0 	sub	r12,r7,-32
8000a78a:	09 08       	ld.w	r8,r4++
8000a78c:	8f 78       	st.w	r7[0x1c],r8
8000a78e:	09 08       	ld.w	r8,r4++
8000a790:	18 a8       	st.w	r12++,r8
8000a792:	68 08       	ld.w	r8,r4[0x0]
8000a794:	99 08       	st.w	r12[0x0],r8
8000a796:	68 18       	ld.w	r8,r4[0x4]
8000a798:	99 18       	st.w	r12[0x4],r8
8000a79a:	c4 78       	rjmp	8000a828 <_realloc_r+0x268>
8000a79c:	08 9b       	mov	r11,r4
8000a79e:	e0 a0 1d e8 	rcall	8000e36e <memmove>
8000a7a2:	c4 38       	rjmp	8000a828 <_realloc_r+0x268>
8000a7a4:	04 9c       	mov	r12,r2
8000a7a6:	fe b0 fc 33 	rcall	8000a00c <_malloc_r>
8000a7aa:	18 95       	mov	r5,r12
8000a7ac:	c3 a0       	breq	8000a820 <_realloc_r+0x260>
8000a7ae:	62 18       	ld.w	r8,r1[0x4]
8000a7b0:	f8 c9 00 08 	sub	r9,r12,8
8000a7b4:	a1 c8       	cbr	r8,0x0
8000a7b6:	e2 08 00 08 	add	r8,r1,r8
8000a7ba:	10 39       	cp.w	r9,r8
8000a7bc:	c0 71       	brne	8000a7ca <_realloc_r+0x20a>
8000a7be:	72 13       	ld.w	r3,r9[0x4]
8000a7c0:	02 97       	mov	r7,r1
8000a7c2:	e0 13 ff fc 	andl	r3,0xfffc
8000a7c6:	00 03       	add	r3,r0
8000a7c8:	c3 08       	rjmp	8000a828 <_realloc_r+0x268>
8000a7ca:	e0 ca 00 04 	sub	r10,r0,4
8000a7ce:	e0 4a 00 24 	cp.w	r10,36
8000a7d2:	e0 8b 00 20 	brhi	8000a812 <_realloc_r+0x252>
8000a7d6:	08 99       	mov	r9,r4
8000a7d8:	18 98       	mov	r8,r12
8000a7da:	59 3a       	cp.w	r10,19
8000a7dc:	e0 88 00 14 	brls	8000a804 <_realloc_r+0x244>
8000a7e0:	13 0b       	ld.w	r11,r9++
8000a7e2:	10 ab       	st.w	r8++,r11
8000a7e4:	13 0b       	ld.w	r11,r9++
8000a7e6:	10 ab       	st.w	r8++,r11
8000a7e8:	59 ba       	cp.w	r10,27
8000a7ea:	e0 88 00 0d 	brls	8000a804 <_realloc_r+0x244>
8000a7ee:	13 0b       	ld.w	r11,r9++
8000a7f0:	10 ab       	st.w	r8++,r11
8000a7f2:	13 0b       	ld.w	r11,r9++
8000a7f4:	10 ab       	st.w	r8++,r11
8000a7f6:	e0 4a 00 24 	cp.w	r10,36
8000a7fa:	c0 51       	brne	8000a804 <_realloc_r+0x244>
8000a7fc:	13 0a       	ld.w	r10,r9++
8000a7fe:	10 aa       	st.w	r8++,r10
8000a800:	13 0a       	ld.w	r10,r9++
8000a802:	10 aa       	st.w	r8++,r10
8000a804:	13 0a       	ld.w	r10,r9++
8000a806:	10 aa       	st.w	r8++,r10
8000a808:	72 0a       	ld.w	r10,r9[0x0]
8000a80a:	91 0a       	st.w	r8[0x0],r10
8000a80c:	72 19       	ld.w	r9,r9[0x4]
8000a80e:	91 19       	st.w	r8[0x4],r9
8000a810:	c0 48       	rjmp	8000a818 <_realloc_r+0x258>
8000a812:	08 9b       	mov	r11,r4
8000a814:	e0 a0 1d ad 	rcall	8000e36e <memmove>
8000a818:	08 9b       	mov	r11,r4
8000a81a:	04 9c       	mov	r12,r2
8000a81c:	e0 a0 1b 06 	rcall	8000de28 <_free_r>
8000a820:	04 9c       	mov	r12,r2
8000a822:	c2 a8       	rjmp	8000a876 <_realloc_r+0x2b6>
8000a824:	00 93       	mov	r3,r0
8000a826:	02 97       	mov	r7,r1
8000a828:	e6 06 01 09 	sub	r9,r3,r6
8000a82c:	6e 18       	ld.w	r8,r7[0x4]
8000a82e:	58 f9       	cp.w	r9,15
8000a830:	e0 88 00 16 	brls	8000a85c <_realloc_r+0x29c>
8000a834:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000a838:	ed e8 10 08 	or	r8,r6,r8
8000a83c:	8f 18       	st.w	r7[0x4],r8
8000a83e:	12 98       	mov	r8,r9
8000a840:	a1 a8       	sbr	r8,0x0
8000a842:	ee 06 00 0b 	add	r11,r7,r6
8000a846:	f6 09 00 09 	add	r9,r11,r9
8000a84a:	97 18       	st.w	r11[0x4],r8
8000a84c:	72 18       	ld.w	r8,r9[0x4]
8000a84e:	a1 a8       	sbr	r8,0x0
8000a850:	2f 8b       	sub	r11,-8
8000a852:	93 18       	st.w	r9[0x4],r8
8000a854:	04 9c       	mov	r12,r2
8000a856:	e0 a0 1a e9 	rcall	8000de28 <_free_r>
8000a85a:	c0 b8       	rjmp	8000a870 <_realloc_r+0x2b0>
8000a85c:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000a860:	e7 e8 10 08 	or	r8,r3,r8
8000a864:	8f 18       	st.w	r7[0x4],r8
8000a866:	ee 03 00 03 	add	r3,r7,r3
8000a86a:	66 18       	ld.w	r8,r3[0x4]
8000a86c:	a1 a8       	sbr	r8,0x0
8000a86e:	87 18       	st.w	r3[0x4],r8
8000a870:	04 9c       	mov	r12,r2
8000a872:	ee c5 ff f8 	sub	r5,r7,-8
8000a876:	fe b0 f1 1d 	rcall	80008ab0 <__malloc_unlock>
8000a87a:	0a 9c       	mov	r12,r5
8000a87c:	2f fd       	sub	sp,-4
8000a87e:	d8 32       	popm	r0-r7,pc

8000a880 <_sbrk_r>:
8000a880:	d4 21       	pushm	r4-r7,lr
8000a882:	30 08       	mov	r8,0
8000a884:	18 97       	mov	r7,r12
8000a886:	e0 66 46 28 	mov	r6,17960
8000a88a:	16 9c       	mov	r12,r11
8000a88c:	8d 08       	st.w	r6[0x0],r8
8000a88e:	c1 1d       	rcall	8000aab0 <_sbrk>
8000a890:	5b fc       	cp.w	r12,-1
8000a892:	c0 51       	brne	8000a89c <_sbrk_r+0x1c>
8000a894:	6c 08       	ld.w	r8,r6[0x0]
8000a896:	58 08       	cp.w	r8,0
8000a898:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000a89c:	d8 22       	popm	r4-r7,pc
8000a89e:	d7 03       	nop

8000a8a0 <sprintf>:
8000a8a0:	d4 01       	pushm	lr
8000a8a2:	21 7d       	sub	sp,92
8000a8a4:	e0 68 ff ff 	mov	r8,65535
8000a8a8:	ea 18 7f ff 	orh	r8,0x7fff
8000a8ac:	50 58       	stdsp	sp[0x14],r8
8000a8ae:	50 28       	stdsp	sp[0x8],r8
8000a8b0:	e0 68 02 08 	mov	r8,520
8000a8b4:	ba 68       	st.h	sp[0xc],r8
8000a8b6:	3f f8       	mov	r8,-1
8000a8b8:	ba 78       	st.h	sp[0xe],r8
8000a8ba:	e0 68 0a 38 	mov	r8,2616
8000a8be:	50 4c       	stdsp	sp[0x10],r12
8000a8c0:	16 9a       	mov	r10,r11
8000a8c2:	50 0c       	stdsp	sp[0x0],r12
8000a8c4:	fa c9 ff a0 	sub	r9,sp,-96
8000a8c8:	70 0c       	ld.w	r12,r8[0x0]
8000a8ca:	1a 9b       	mov	r11,sp
8000a8cc:	e0 a0 02 ac 	rcall	8000ae24 <_vfprintf_r>
8000a8d0:	30 09       	mov	r9,0
8000a8d2:	40 08       	lddsp	r8,sp[0x0]
8000a8d4:	b0 89       	st.b	r8[0x0],r9
8000a8d6:	2e 9d       	sub	sp,-92
8000a8d8:	d8 02       	popm	pc
8000a8da:	d7 03       	nop

8000a8dc <strcpy>:
8000a8dc:	30 08       	mov	r8,0
8000a8de:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000a8e2:	f8 08 0b 09 	st.b	r12[r8],r9
8000a8e6:	2f f8       	sub	r8,-1
8000a8e8:	58 09       	cp.w	r9,0
8000a8ea:	cf a1       	brne	8000a8de <strcpy+0x2>
8000a8ec:	5e fc       	retal	r12

8000a8ee <strlen>:
8000a8ee:	30 09       	mov	r9,0
8000a8f0:	18 98       	mov	r8,r12
8000a8f2:	c0 28       	rjmp	8000a8f6 <strlen+0x8>
8000a8f4:	2f f8       	sub	r8,-1
8000a8f6:	11 8a       	ld.ub	r10,r8[0x0]
8000a8f8:	f2 0a 18 00 	cp.b	r10,r9
8000a8fc:	cf c1       	brne	8000a8f4 <strlen+0x6>
8000a8fe:	f0 0c 01 0c 	sub	r12,r8,r12
8000a902:	5e fc       	retal	r12

8000a904 <strncpy>:
8000a904:	30 08       	mov	r8,0
8000a906:	10 3a       	cp.w	r10,r8
8000a908:	5e 0c       	reteq	r12
8000a90a:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000a90e:	f8 08 0b 09 	st.b	r12[r8],r9
8000a912:	2f f8       	sub	r8,-1
8000a914:	58 09       	cp.w	r9,0
8000a916:	cf 81       	brne	8000a906 <strncpy+0x2>
8000a918:	10 3a       	cp.w	r10,r8
8000a91a:	5e 0c       	reteq	r12
8000a91c:	f8 08 0b 09 	st.b	r12[r8],r9
8000a920:	2f f8       	sub	r8,-1
8000a922:	cf bb       	rjmp	8000a918 <strncpy+0x14>

8000a924 <strtok>:
8000a924:	d4 21       	pushm	r4-r7,lr
8000a926:	20 1d       	sub	sp,4
8000a928:	e0 65 0a 38 	mov	r5,2616
8000a92c:	18 97       	mov	r7,r12
8000a92e:	6a 04       	ld.w	r4,r5[0x0]
8000a930:	e8 f6 00 e8 	ld.w	r6,r4[232]
8000a934:	58 06       	cp.w	r6,0
8000a936:	c3 51       	brne	8000a9a0 <strtok+0x7c>
8000a938:	50 0b       	stdsp	sp[0x0],r11
8000a93a:	35 0c       	mov	r12,80
8000a93c:	fe b0 fb 60 	rcall	80009ffc <malloc>
8000a940:	6a 08       	ld.w	r8,r5[0x0]
8000a942:	e9 4c 00 e8 	st.w	r4[232],r12
8000a946:	f0 f9 00 e8 	ld.w	r9,r8[232]
8000a94a:	93 26       	st.w	r9[0x8],r6
8000a94c:	93 06       	st.w	r9[0x0],r6
8000a94e:	93 16       	st.w	r9[0x4],r6
8000a950:	f0 f9 00 e8 	ld.w	r9,r8[232]
8000a954:	93 46       	st.w	r9[0x10],r6
8000a956:	93 36       	st.w	r9[0xc],r6
8000a958:	f0 f9 00 e8 	ld.w	r9,r8[232]
8000a95c:	93 66       	st.w	r9[0x18],r6
8000a95e:	93 56       	st.w	r9[0x14],r6
8000a960:	f0 f9 00 e8 	ld.w	r9,r8[232]
8000a964:	93 b6       	st.w	r9[0x2c],r6
8000a966:	93 a6       	st.w	r9[0x28],r6
8000a968:	f0 f9 00 e8 	ld.w	r9,r8[232]
8000a96c:	93 d6       	st.w	r9[0x34],r6
8000a96e:	93 c6       	st.w	r9[0x30],r6
8000a970:	f0 f9 00 e8 	ld.w	r9,r8[232]
8000a974:	93 f6       	st.w	r9[0x3c],r6
8000a976:	93 e6       	st.w	r9[0x38],r6
8000a978:	f0 f9 00 e8 	ld.w	r9,r8[232]
8000a97c:	f3 46 00 44 	st.w	r9[68],r6
8000a980:	f3 46 00 40 	st.w	r9[64],r6
8000a984:	f0 f9 00 e8 	ld.w	r9,r8[232]
8000a988:	f3 46 00 4c 	st.w	r9[76],r6
8000a98c:	f3 46 00 48 	st.w	r9[72],r6
8000a990:	f0 f9 00 e8 	ld.w	r9,r8[232]
8000a994:	f3 66 00 1c 	st.b	r9[28],r6
8000a998:	f0 f8 00 e8 	ld.w	r8,r8[232]
8000a99c:	40 0b       	lddsp	r11,sp[0x0]
8000a99e:	91 96       	st.w	r8[0x24],r6
8000a9a0:	e0 68 0a 38 	mov	r8,2616
8000a9a4:	70 08       	ld.w	r8,r8[0x0]
8000a9a6:	0e 9c       	mov	r12,r7
8000a9a8:	f0 fa 00 e8 	ld.w	r10,r8[232]
8000a9ac:	30 19       	mov	r9,1
8000a9ae:	c0 3c       	rcall	8000a9b4 <__strtok_r>
8000a9b0:	2f fd       	sub	sp,-4
8000a9b2:	d8 22       	popm	r4-r7,pc

8000a9b4 <__strtok_r>:
8000a9b4:	d4 21       	pushm	r4-r7,lr
8000a9b6:	58 0c       	cp.w	r12,0
8000a9b8:	c0 41       	brne	8000a9c0 <__strtok_r+0xc>
8000a9ba:	74 0c       	ld.w	r12,r10[0x0]
8000a9bc:	58 0c       	cp.w	r12,0
8000a9be:	c2 90       	breq	8000aa10 <__strtok_r+0x5c>
8000a9c0:	18 98       	mov	r8,r12
8000a9c2:	16 97       	mov	r7,r11
8000a9c4:	11 3e       	ld.ub	lr,r8++
8000a9c6:	c0 a8       	rjmp	8000a9da <__strtok_r+0x26>
8000a9c8:	0c 3e       	cp.w	lr,r6
8000a9ca:	c0 81       	brne	8000a9da <__strtok_r+0x26>
8000a9cc:	58 09       	cp.w	r9,0
8000a9ce:	c0 30       	breq	8000a9d4 <__strtok_r+0x20>
8000a9d0:	10 9c       	mov	r12,r8
8000a9d2:	cf 7b       	rjmp	8000a9c0 <__strtok_r+0xc>
8000a9d4:	95 08       	st.w	r10[0x0],r8
8000a9d6:	b8 89       	st.b	r12[0x0],r9
8000a9d8:	d8 22       	popm	r4-r7,pc
8000a9da:	0f 36       	ld.ub	r6,r7++
8000a9dc:	58 06       	cp.w	r6,0
8000a9de:	cf 51       	brne	8000a9c8 <__strtok_r+0x14>
8000a9e0:	58 0e       	cp.w	lr,0
8000a9e2:	c0 51       	brne	8000a9ec <__strtok_r+0x38>
8000a9e4:	95 0e       	st.w	r10[0x0],lr
8000a9e6:	1c 9c       	mov	r12,lr
8000a9e8:	d8 22       	popm	r4-r7,pc
8000a9ea:	12 98       	mov	r8,r9
8000a9ec:	10 99       	mov	r9,r8
8000a9ee:	16 97       	mov	r7,r11
8000a9f0:	13 3e       	ld.ub	lr,r9++
8000a9f2:	0f 36       	ld.ub	r6,r7++
8000a9f4:	1c 36       	cp.w	r6,lr
8000a9f6:	c0 a1       	brne	8000aa0a <__strtok_r+0x56>
8000a9f8:	58 0e       	cp.w	lr,0
8000a9fa:	fc 09 17 00 	moveq	r9,lr
8000a9fe:	f9 bb 01 00 	movne	r11,0
8000aa02:	f1 fb 1e 00 	st.bne	r8[0x0],r11
8000aa06:	95 09       	st.w	r10[0x0],r9
8000aa08:	d8 22       	popm	r4-r7,pc
8000aa0a:	58 06       	cp.w	r6,0
8000aa0c:	cf 31       	brne	8000a9f2 <__strtok_r+0x3e>
8000aa0e:	ce eb       	rjmp	8000a9ea <__strtok_r+0x36>
8000aa10:	d8 22       	popm	r4-r7,pc
8000aa12:	d7 03       	nop

8000aa14 <_close>:
8000aa14:	30 28       	mov	r8,2
8000aa16:	d6 73       	breakpoint
8000aa18:	3f fc       	mov	r12,-1
8000aa1a:	35 8b       	mov	r11,88
8000aa1c:	58 0c       	cp.w	r12,0
8000aa1e:	5e 4c       	retge	r12
8000aa20:	e0 6a 46 28 	mov	r10,17960
8000aa24:	95 0b       	st.w	r10[0x0],r11
8000aa26:	5e fc       	retal	r12

8000aa28 <_lseek>:
8000aa28:	30 58       	mov	r8,5
8000aa2a:	d6 73       	breakpoint
8000aa2c:	3f fc       	mov	r12,-1
8000aa2e:	35 8b       	mov	r11,88
8000aa30:	58 0c       	cp.w	r12,0
8000aa32:	5e 4c       	retge	r12
8000aa34:	e0 6a 46 28 	mov	r10,17960
8000aa38:	95 0b       	st.w	r10[0x0],r11
8000aa3a:	5e fc       	retal	r12

8000aa3c <isatty>:
8000aa3c:	30 b8       	mov	r8,11
8000aa3e:	d6 73       	breakpoint
8000aa40:	3f fc       	mov	r12,-1
8000aa42:	35 8b       	mov	r11,88
8000aa44:	58 0c       	cp.w	r12,0
8000aa46:	5e 4c       	retge	r12
8000aa48:	e0 6a 46 28 	mov	r10,17960
8000aa4c:	95 0b       	st.w	r10[0x0],r11
8000aa4e:	5e fc       	retal	r12

8000aa50 <_fstat_host>:
8000aa50:	30 98       	mov	r8,9
8000aa52:	d6 73       	breakpoint
8000aa54:	3f fc       	mov	r12,-1
8000aa56:	35 8b       	mov	r11,88
8000aa58:	58 0c       	cp.w	r12,0
8000aa5a:	5e 4c       	retge	r12
8000aa5c:	e0 6a 46 28 	mov	r10,17960
8000aa60:	95 0b       	st.w	r10[0x0],r11
8000aa62:	5e fc       	retal	r12

8000aa64 <_fstat>:
8000aa64:	d4 21       	pushm	r4-r7,lr
8000aa66:	21 0d       	sub	sp,64
8000aa68:	16 97       	mov	r7,r11
8000aa6a:	1a 9b       	mov	r11,sp
8000aa6c:	cf 2f       	rcall	8000aa50 <_fstat_host>
8000aa6e:	c0 34       	brge	8000aa74 <_fstat+0x10>
8000aa70:	3f fc       	mov	r12,-1
8000aa72:	c1 c8       	rjmp	8000aaaa <_fstat+0x46>
8000aa74:	40 08       	lddsp	r8,sp[0x0]
8000aa76:	ae 08       	st.h	r7[0x0],r8
8000aa78:	40 18       	lddsp	r8,sp[0x4]
8000aa7a:	ae 18       	st.h	r7[0x2],r8
8000aa7c:	40 28       	lddsp	r8,sp[0x8]
8000aa7e:	8f 18       	st.w	r7[0x4],r8
8000aa80:	40 38       	lddsp	r8,sp[0xc]
8000aa82:	ae 48       	st.h	r7[0x8],r8
8000aa84:	40 48       	lddsp	r8,sp[0x10]
8000aa86:	ae 58       	st.h	r7[0xa],r8
8000aa88:	40 58       	lddsp	r8,sp[0x14]
8000aa8a:	ae 68       	st.h	r7[0xc],r8
8000aa8c:	40 68       	lddsp	r8,sp[0x18]
8000aa8e:	ae 78       	st.h	r7[0xe],r8
8000aa90:	40 88       	lddsp	r8,sp[0x20]
8000aa92:	8f 48       	st.w	r7[0x10],r8
8000aa94:	40 a8       	lddsp	r8,sp[0x28]
8000aa96:	8f b8       	st.w	r7[0x2c],r8
8000aa98:	40 c8       	lddsp	r8,sp[0x30]
8000aa9a:	8f c8       	st.w	r7[0x30],r8
8000aa9c:	40 d8       	lddsp	r8,sp[0x34]
8000aa9e:	8f 58       	st.w	r7[0x14],r8
8000aaa0:	40 e8       	lddsp	r8,sp[0x38]
8000aaa2:	30 0c       	mov	r12,0
8000aaa4:	8f 78       	st.w	r7[0x1c],r8
8000aaa6:	40 f8       	lddsp	r8,sp[0x3c]
8000aaa8:	8f 98       	st.w	r7[0x24],r8
8000aaaa:	2f 0d       	sub	sp,-64
8000aaac:	d8 22       	popm	r4-r7,pc
8000aaae:	d7 03       	nop

8000aab0 <_sbrk>:
8000aab0:	d4 01       	pushm	lr
8000aab2:	e0 68 12 c8 	mov	r8,4808
8000aab6:	70 09       	ld.w	r9,r8[0x0]
8000aab8:	58 09       	cp.w	r9,0
8000aaba:	c0 41       	brne	8000aac2 <_sbrk+0x12>
8000aabc:	e0 69 46 30 	mov	r9,17968
8000aac0:	91 09       	st.w	r8[0x0],r9
8000aac2:	e0 69 12 c8 	mov	r9,4808
8000aac6:	e0 7a 70 00 	mov	r10,94208
8000aaca:	72 08       	ld.w	r8,r9[0x0]
8000aacc:	f0 0c 00 0c 	add	r12,r8,r12
8000aad0:	14 3c       	cp.w	r12,r10
8000aad2:	e0 8b 00 04 	brhi	8000aada <_sbrk+0x2a>
8000aad6:	93 0c       	st.w	r9[0x0],r12
8000aad8:	c0 68       	rjmp	8000aae4 <_sbrk+0x34>
8000aada:	e0 a0 18 2b 	rcall	8000db30 <__errno>
8000aade:	30 c8       	mov	r8,12
8000aae0:	99 08       	st.w	r12[0x0],r8
8000aae2:	3f f8       	mov	r8,-1
8000aae4:	10 9c       	mov	r12,r8
8000aae6:	d8 02       	popm	pc

8000aae8 <get_arg>:
8000aae8:	d4 31       	pushm	r0-r7,lr
8000aaea:	20 8d       	sub	sp,32
8000aaec:	fa c4 ff bc 	sub	r4,sp,-68
8000aaf0:	50 4b       	stdsp	sp[0x10],r11
8000aaf2:	68 2e       	ld.w	lr,r4[0x8]
8000aaf4:	50 58       	stdsp	sp[0x14],r8
8000aaf6:	12 96       	mov	r6,r9
8000aaf8:	7c 0b       	ld.w	r11,lr[0x0]
8000aafa:	70 05       	ld.w	r5,r8[0x0]
8000aafc:	50 6e       	stdsp	sp[0x18],lr
8000aafe:	58 0b       	cp.w	r11,0
8000ab00:	f4 0b 17 00 	moveq	r11,r10
8000ab04:	68 03       	ld.w	r3,r4[0x0]
8000ab06:	68 11       	ld.w	r1,r4[0x4]
8000ab08:	40 49       	lddsp	r9,sp[0x10]
8000ab0a:	30 08       	mov	r8,0
8000ab0c:	c2 e9       	rjmp	8000ad68 <get_arg+0x280>
8000ab0e:	2f fb       	sub	r11,-1
8000ab10:	32 5c       	mov	r12,37
8000ab12:	17 8a       	ld.ub	r10,r11[0x0]
8000ab14:	f8 0a 18 00 	cp.b	r10,r12
8000ab18:	5f 1e       	srne	lr
8000ab1a:	f0 0a 18 00 	cp.b	r10,r8
8000ab1e:	5f 1c       	srne	r12
8000ab20:	fd ec 00 0c 	and	r12,lr,r12
8000ab24:	f0 0c 18 00 	cp.b	r12,r8
8000ab28:	cf 31       	brne	8000ab0e <get_arg+0x26>
8000ab2a:	58 0a       	cp.w	r10,0
8000ab2c:	e0 80 01 2b 	breq	8000ad82 <get_arg+0x29a>
8000ab30:	30 0c       	mov	r12,0
8000ab32:	3f fa       	mov	r10,-1
8000ab34:	18 90       	mov	r0,r12
8000ab36:	50 3a       	stdsp	sp[0xc],r10
8000ab38:	18 94       	mov	r4,r12
8000ab3a:	18 92       	mov	r2,r12
8000ab3c:	f8 0c 00 3c 	add	r12,r12,r12<<0x3
8000ab40:	16 97       	mov	r7,r11
8000ab42:	50 7c       	stdsp	sp[0x1c],r12
8000ab44:	4c ec       	lddpc	r12,8000ac7c <get_arg+0x194>
8000ab46:	0f 3a       	ld.ub	r10,r7++
8000ab48:	f8 0a 07 0e 	ld.ub	lr,r12[r10]
8000ab4c:	40 7c       	lddsp	r12,sp[0x1c]
8000ab4e:	1c 0c       	add	r12,lr
8000ab50:	4c ce       	lddpc	lr,8000ac80 <get_arg+0x198>
8000ab52:	fc 0c 07 0e 	ld.ub	lr,lr[r12]
8000ab56:	20 1e       	sub	lr,1
8000ab58:	50 0e       	stdsp	sp[0x0],lr
8000ab5a:	4c be       	lddpc	lr,8000ac84 <get_arg+0x19c>
8000ab5c:	fc 0c 07 0c 	ld.ub	r12,lr[r12]
8000ab60:	50 7c       	stdsp	sp[0x1c],r12
8000ab62:	40 0c       	lddsp	r12,sp[0x0]
8000ab64:	58 7c       	cp.w	r12,7
8000ab66:	e0 8b 00 fa 	brhi	8000ad5a <get_arg+0x272>
8000ab6a:	4c 8e       	lddpc	lr,8000ac88 <get_arg+0x1a0>
8000ab6c:	fc 0c 03 2f 	ld.w	pc,lr[r12<<0x2]
8000ab70:	36 8b       	mov	r11,104
8000ab72:	f6 0a 18 00 	cp.b	r10,r11
8000ab76:	e0 80 00 f2 	breq	8000ad5a <get_arg+0x272>
8000ab7a:	37 1b       	mov	r11,113
8000ab7c:	f6 0a 18 00 	cp.b	r10,r11
8000ab80:	c0 70       	breq	8000ab8e <get_arg+0xa6>
8000ab82:	34 cb       	mov	r11,76
8000ab84:	f6 0a 18 00 	cp.b	r10,r11
8000ab88:	c0 51       	brne	8000ab92 <get_arg+0xaa>
8000ab8a:	a3 b4       	sbr	r4,0x3
8000ab8c:	ce 78       	rjmp	8000ad5a <get_arg+0x272>
8000ab8e:	a5 b4       	sbr	r4,0x5
8000ab90:	ce 58       	rjmp	8000ad5a <get_arg+0x272>
8000ab92:	08 9a       	mov	r10,r4
8000ab94:	0e 9b       	mov	r11,r7
8000ab96:	a5 aa       	sbr	r10,0x4
8000ab98:	17 3c       	ld.ub	r12,r11++
8000ab9a:	a5 b4       	sbr	r4,0x5
8000ab9c:	36 ce       	mov	lr,108
8000ab9e:	fc 0c 18 00 	cp.b	r12,lr
8000aba2:	e0 80 00 dd 	breq	8000ad5c <get_arg+0x274>
8000aba6:	14 94       	mov	r4,r10
8000aba8:	cd 98       	rjmp	8000ad5a <get_arg+0x272>
8000abaa:	eb d5 c0 05 	bfextu	r5,r5,0x0,0x5
8000abae:	36 7c       	mov	r12,103
8000abb0:	f8 0a 18 00 	cp.b	r10,r12
8000abb4:	e0 8b 00 27 	brhi	8000ac02 <get_arg+0x11a>
8000abb8:	36 5b       	mov	r11,101
8000abba:	f6 0a 18 00 	cp.b	r10,r11
8000abbe:	c4 82       	brcc	8000ac4e <get_arg+0x166>
8000abc0:	34 fb       	mov	r11,79
8000abc2:	f6 0a 18 00 	cp.b	r10,r11
8000abc6:	c4 80       	breq	8000ac56 <get_arg+0x16e>
8000abc8:	e0 8b 00 0c 	brhi	8000abe0 <get_arg+0xf8>
8000abcc:	34 5b       	mov	r11,69
8000abce:	f6 0a 18 00 	cp.b	r10,r11
8000abd2:	c3 e0       	breq	8000ac4e <get_arg+0x166>
8000abd4:	34 7b       	mov	r11,71
8000abd6:	f6 0a 18 00 	cp.b	r10,r11
8000abda:	c3 a0       	breq	8000ac4e <get_arg+0x166>
8000abdc:	34 4b       	mov	r11,68
8000abde:	c0 88       	rjmp	8000abee <get_arg+0x106>
8000abe0:	35 8b       	mov	r11,88
8000abe2:	f6 0a 18 00 	cp.b	r10,r11
8000abe6:	c2 c0       	breq	8000ac3e <get_arg+0x156>
8000abe8:	e0 8b 00 07 	brhi	8000abf6 <get_arg+0x10e>
8000abec:	35 5b       	mov	r11,85
8000abee:	f6 0a 18 00 	cp.b	r10,r11
8000abf2:	c3 51       	brne	8000ac5c <get_arg+0x174>
8000abf4:	c3 18       	rjmp	8000ac56 <get_arg+0x16e>
8000abf6:	36 3b       	mov	r11,99
8000abf8:	f6 0a 18 00 	cp.b	r10,r11
8000abfc:	c2 f0       	breq	8000ac5a <get_arg+0x172>
8000abfe:	36 4b       	mov	r11,100
8000ac00:	c0 e8       	rjmp	8000ac1c <get_arg+0x134>
8000ac02:	37 0b       	mov	r11,112
8000ac04:	f6 0a 18 00 	cp.b	r10,r11
8000ac08:	c2 50       	breq	8000ac52 <get_arg+0x16a>
8000ac0a:	e0 8b 00 0d 	brhi	8000ac24 <get_arg+0x13c>
8000ac0e:	36 eb       	mov	r11,110
8000ac10:	f6 0a 18 00 	cp.b	r10,r11
8000ac14:	c1 f0       	breq	8000ac52 <get_arg+0x16a>
8000ac16:	e0 8b 00 14 	brhi	8000ac3e <get_arg+0x156>
8000ac1a:	36 9b       	mov	r11,105
8000ac1c:	f6 0a 18 00 	cp.b	r10,r11
8000ac20:	c1 e1       	brne	8000ac5c <get_arg+0x174>
8000ac22:	c0 e8       	rjmp	8000ac3e <get_arg+0x156>
8000ac24:	37 5b       	mov	r11,117
8000ac26:	f6 0a 18 00 	cp.b	r10,r11
8000ac2a:	c0 a0       	breq	8000ac3e <get_arg+0x156>
8000ac2c:	37 8b       	mov	r11,120
8000ac2e:	f6 0a 18 00 	cp.b	r10,r11
8000ac32:	c0 60       	breq	8000ac3e <get_arg+0x156>
8000ac34:	37 3b       	mov	r11,115
8000ac36:	f6 0a 18 00 	cp.b	r10,r11
8000ac3a:	c1 11       	brne	8000ac5c <get_arg+0x174>
8000ac3c:	c0 b8       	rjmp	8000ac52 <get_arg+0x16a>
8000ac3e:	ed b4 00 04 	bld	r4,0x4
8000ac42:	c0 a0       	breq	8000ac56 <get_arg+0x16e>
8000ac44:	ed b4 00 05 	bld	r4,0x5
8000ac48:	c0 91       	brne	8000ac5a <get_arg+0x172>
8000ac4a:	30 20       	mov	r0,2
8000ac4c:	c0 88       	rjmp	8000ac5c <get_arg+0x174>
8000ac4e:	30 40       	mov	r0,4
8000ac50:	c0 68       	rjmp	8000ac5c <get_arg+0x174>
8000ac52:	30 30       	mov	r0,3
8000ac54:	c0 48       	rjmp	8000ac5c <get_arg+0x174>
8000ac56:	30 10       	mov	r0,1
8000ac58:	c0 28       	rjmp	8000ac5c <get_arg+0x174>
8000ac5a:	30 00       	mov	r0,0
8000ac5c:	40 3b       	lddsp	r11,sp[0xc]
8000ac5e:	5b fb       	cp.w	r11,-1
8000ac60:	c0 40       	breq	8000ac68 <get_arg+0x180>
8000ac62:	e2 0b 09 20 	st.w	r1[r11<<0x2],r0
8000ac66:	c7 a8       	rjmp	8000ad5a <get_arg+0x272>
8000ac68:	58 60       	cp.w	r0,6
8000ac6a:	e0 8b 00 78 	brhi	8000ad5a <get_arg+0x272>
8000ac6e:	6c 0a       	ld.w	r10,r6[0x0]
8000ac70:	ea cc ff ff 	sub	r12,r5,-1
8000ac74:	48 6e       	lddpc	lr,8000ac8c <get_arg+0x1a4>
8000ac76:	fc 00 03 2f 	ld.w	pc,lr[r0<<0x2]
8000ac7a:	d7 03       	nop
8000ac7c:	80 01       	ld.sh	r1,r0[0x0]
8000ac7e:	91 c0       	st.w	r8[0x30],r0
8000ac80:	80 01       	ld.sh	r1,r0[0x0]
8000ac82:	90 f8       	ld.uh	r8,r8[0xe]
8000ac84:	80 01       	ld.sh	r1,r0[0x0]
8000ac86:	90 8c       	ld.uh	r12,r8[0x0]
8000ac88:	80 01       	ld.sh	r1,r0[0x0]
8000ac8a:	8e ec       	ld.uh	r12,r7[0xc]
8000ac8c:	80 01       	ld.sh	r1,r0[0x0]
8000ac8e:	8f 0c       	st.w	r7[0x0],r12
8000ac90:	f4 cb ff f8 	sub	r11,r10,-8
8000ac94:	8d 0b       	st.w	r6[0x0],r11
8000ac96:	f4 ea 00 00 	ld.d	r10,r10[0]
8000ac9a:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
8000ac9e:	c0 f8       	rjmp	8000acbc <get_arg+0x1d4>
8000aca0:	f4 cb ff fc 	sub	r11,r10,-4
8000aca4:	8d 0b       	st.w	r6[0x0],r11
8000aca6:	74 0a       	ld.w	r10,r10[0x0]
8000aca8:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
8000acac:	c0 88       	rjmp	8000acbc <get_arg+0x1d4>
8000acae:	f4 cb ff f8 	sub	r11,r10,-8
8000acb2:	8d 0b       	st.w	r6[0x0],r11
8000acb4:	f4 ea 00 00 	ld.d	r10,r10[0]
8000acb8:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
8000acbc:	0e 9b       	mov	r11,r7
8000acbe:	18 95       	mov	r5,r12
8000acc0:	c4 e8       	rjmp	8000ad5c <get_arg+0x274>
8000acc2:	62 0a       	ld.w	r10,r1[0x0]
8000acc4:	5b fa       	cp.w	r10,-1
8000acc6:	c0 b1       	brne	8000acdc <get_arg+0x1f4>
8000acc8:	50 19       	stdsp	sp[0x4],r9
8000acca:	50 28       	stdsp	sp[0x8],r8
8000accc:	e0 6a 00 80 	mov	r10,128
8000acd0:	30 0b       	mov	r11,0
8000acd2:	02 9c       	mov	r12,r1
8000acd4:	fe b0 fc 6f 	rcall	8000a5b2 <memset>
8000acd8:	40 28       	lddsp	r8,sp[0x8]
8000acda:	40 19       	lddsp	r9,sp[0x4]
8000acdc:	e4 cc 00 01 	sub	r12,r2,1
8000ace0:	0e 9b       	mov	r11,r7
8000ace2:	50 3c       	stdsp	sp[0xc],r12
8000ace4:	f2 0c 0c 49 	max	r9,r9,r12
8000ace8:	c3 a8       	rjmp	8000ad5c <get_arg+0x274>
8000acea:	62 0a       	ld.w	r10,r1[0x0]
8000acec:	5b fa       	cp.w	r10,-1
8000acee:	c0 b1       	brne	8000ad04 <get_arg+0x21c>
8000acf0:	50 19       	stdsp	sp[0x4],r9
8000acf2:	50 28       	stdsp	sp[0x8],r8
8000acf4:	e0 6a 00 80 	mov	r10,128
8000acf8:	30 0b       	mov	r11,0
8000acfa:	02 9c       	mov	r12,r1
8000acfc:	fe b0 fc 5b 	rcall	8000a5b2 <memset>
8000ad00:	40 28       	lddsp	r8,sp[0x8]
8000ad02:	40 19       	lddsp	r9,sp[0x4]
8000ad04:	20 12       	sub	r2,1
8000ad06:	30 0a       	mov	r10,0
8000ad08:	0e 9b       	mov	r11,r7
8000ad0a:	e2 02 09 2a 	st.w	r1[r2<<0x2],r10
8000ad0e:	f2 02 0c 49 	max	r9,r9,r2
8000ad12:	c2 58       	rjmp	8000ad5c <get_arg+0x274>
8000ad14:	16 97       	mov	r7,r11
8000ad16:	6c 0a       	ld.w	r10,r6[0x0]
8000ad18:	f4 cb ff fc 	sub	r11,r10,-4
8000ad1c:	8d 0b       	st.w	r6[0x0],r11
8000ad1e:	74 0a       	ld.w	r10,r10[0x0]
8000ad20:	0e 9b       	mov	r11,r7
8000ad22:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
8000ad26:	2f f5       	sub	r5,-1
8000ad28:	c1 a8       	rjmp	8000ad5c <get_arg+0x274>
8000ad2a:	f4 c2 00 30 	sub	r2,r10,48
8000ad2e:	c0 68       	rjmp	8000ad3a <get_arg+0x252>
8000ad30:	e4 02 00 22 	add	r2,r2,r2<<0x2
8000ad34:	2f f7       	sub	r7,-1
8000ad36:	f4 02 00 12 	add	r2,r10,r2<<0x1
8000ad3a:	0f 8a       	ld.ub	r10,r7[0x0]
8000ad3c:	58 0a       	cp.w	r10,0
8000ad3e:	c0 e0       	breq	8000ad5a <get_arg+0x272>
8000ad40:	23 0a       	sub	r10,48
8000ad42:	58 9a       	cp.w	r10,9
8000ad44:	fe 98 ff f6 	brls	8000ad30 <get_arg+0x248>
8000ad48:	c0 98       	rjmp	8000ad5a <get_arg+0x272>
8000ad4a:	2f f7       	sub	r7,-1
8000ad4c:	0f 8a       	ld.ub	r10,r7[0x0]
8000ad4e:	58 0a       	cp.w	r10,0
8000ad50:	c0 50       	breq	8000ad5a <get_arg+0x272>
8000ad52:	23 0a       	sub	r10,48
8000ad54:	58 9a       	cp.w	r10,9
8000ad56:	fe 98 ff fa 	brls	8000ad4a <get_arg+0x262>
8000ad5a:	0e 9b       	mov	r11,r7
8000ad5c:	40 7c       	lddsp	r12,sp[0x1c]
8000ad5e:	30 ba       	mov	r10,11
8000ad60:	f4 0c 18 00 	cp.b	r12,r10
8000ad64:	fe 91 fe ec 	brne	8000ab3c <get_arg+0x54>
8000ad68:	40 42       	lddsp	r2,sp[0x10]
8000ad6a:	17 8c       	ld.ub	r12,r11[0x0]
8000ad6c:	0a 32       	cp.w	r2,r5
8000ad6e:	5f 4a       	srge	r10
8000ad70:	f0 0c 18 00 	cp.b	r12,r8
8000ad74:	5f 1c       	srne	r12
8000ad76:	f9 ea 00 0a 	and	r10,r12,r10
8000ad7a:	f0 0a 18 00 	cp.b	r10,r8
8000ad7e:	fe 91 fe c9 	brne	8000ab10 <get_arg+0x28>
8000ad82:	30 08       	mov	r8,0
8000ad84:	40 4e       	lddsp	lr,sp[0x10]
8000ad86:	17 8a       	ld.ub	r10,r11[0x0]
8000ad88:	e2 05 00 21 	add	r1,r1,r5<<0x2
8000ad8c:	f0 0a 18 00 	cp.b	r10,r8
8000ad90:	fc 09 17 10 	movne	r9,lr
8000ad94:	e6 05 00 38 	add	r8,r3,r5<<0x3
8000ad98:	06 9e       	mov	lr,r3
8000ad9a:	c2 a8       	rjmp	8000adee <get_arg+0x306>
8000ad9c:	62 0a       	ld.w	r10,r1[0x0]
8000ad9e:	58 3a       	cp.w	r10,3
8000ada0:	c1 e0       	breq	8000addc <get_arg+0x2f4>
8000ada2:	e0 89 00 07 	brgt	8000adb0 <get_arg+0x2c8>
8000ada6:	58 1a       	cp.w	r10,1
8000ada8:	c1 a0       	breq	8000addc <get_arg+0x2f4>
8000adaa:	58 2a       	cp.w	r10,2
8000adac:	c1 81       	brne	8000addc <get_arg+0x2f4>
8000adae:	c0 58       	rjmp	8000adb8 <get_arg+0x2d0>
8000adb0:	58 5a       	cp.w	r10,5
8000adb2:	c0 c0       	breq	8000adca <get_arg+0x2e2>
8000adb4:	c0 b5       	brlt	8000adca <get_arg+0x2e2>
8000adb6:	c1 38       	rjmp	8000addc <get_arg+0x2f4>
8000adb8:	6c 0a       	ld.w	r10,r6[0x0]
8000adba:	f4 cc ff f8 	sub	r12,r10,-8
8000adbe:	8d 0c       	st.w	r6[0x0],r12
8000adc0:	f4 e2 00 00 	ld.d	r2,r10[0]
8000adc4:	f0 e3 00 00 	st.d	r8[0],r2
8000adc8:	c1 08       	rjmp	8000ade8 <get_arg+0x300>
8000adca:	6c 0a       	ld.w	r10,r6[0x0]
8000adcc:	f4 cc ff f8 	sub	r12,r10,-8
8000add0:	8d 0c       	st.w	r6[0x0],r12
8000add2:	f4 e2 00 00 	ld.d	r2,r10[0]
8000add6:	f0 e3 00 00 	st.d	r8[0],r2
8000adda:	c0 78       	rjmp	8000ade8 <get_arg+0x300>
8000addc:	6c 0a       	ld.w	r10,r6[0x0]
8000adde:	f4 cc ff fc 	sub	r12,r10,-4
8000ade2:	8d 0c       	st.w	r6[0x0],r12
8000ade4:	74 0a       	ld.w	r10,r10[0x0]
8000ade6:	91 0a       	st.w	r8[0x0],r10
8000ade8:	2f f5       	sub	r5,-1
8000adea:	2f 88       	sub	r8,-8
8000adec:	2f c1       	sub	r1,-4
8000adee:	12 35       	cp.w	r5,r9
8000adf0:	fe 9a ff d6 	brle	8000ad9c <get_arg+0x2b4>
8000adf4:	1c 93       	mov	r3,lr
8000adf6:	40 52       	lddsp	r2,sp[0x14]
8000adf8:	40 6e       	lddsp	lr,sp[0x18]
8000adfa:	85 05       	st.w	r2[0x0],r5
8000adfc:	9d 0b       	st.w	lr[0x0],r11
8000adfe:	40 4b       	lddsp	r11,sp[0x10]
8000ae00:	e6 0b 00 3c 	add	r12,r3,r11<<0x3
8000ae04:	2f 8d       	sub	sp,-32
8000ae06:	d8 32       	popm	r0-r7,pc

8000ae08 <__sprint_r>:
8000ae08:	d4 21       	pushm	r4-r7,lr
8000ae0a:	14 97       	mov	r7,r10
8000ae0c:	74 28       	ld.w	r8,r10[0x8]
8000ae0e:	58 08       	cp.w	r8,0
8000ae10:	c0 41       	brne	8000ae18 <__sprint_r+0x10>
8000ae12:	95 18       	st.w	r10[0x4],r8
8000ae14:	10 9c       	mov	r12,r8
8000ae16:	d8 22       	popm	r4-r7,pc
8000ae18:	e0 a0 18 ce 	rcall	8000dfb4 <__sfvwrite_r>
8000ae1c:	30 08       	mov	r8,0
8000ae1e:	8f 18       	st.w	r7[0x4],r8
8000ae20:	8f 28       	st.w	r7[0x8],r8
8000ae22:	d8 22       	popm	r4-r7,pc

8000ae24 <_vfprintf_r>:
8000ae24:	d4 31       	pushm	r0-r7,lr
8000ae26:	fa cd 06 bc 	sub	sp,sp,1724
8000ae2a:	51 09       	stdsp	sp[0x40],r9
8000ae2c:	16 91       	mov	r1,r11
8000ae2e:	14 97       	mov	r7,r10
8000ae30:	18 95       	mov	r5,r12
8000ae32:	e0 a0 1a 31 	rcall	8000e294 <_localeconv_r>
8000ae36:	78 0c       	ld.w	r12,r12[0x0]
8000ae38:	50 cc       	stdsp	sp[0x30],r12
8000ae3a:	58 05       	cp.w	r5,0
8000ae3c:	c0 70       	breq	8000ae4a <_vfprintf_r+0x26>
8000ae3e:	6a 68       	ld.w	r8,r5[0x18]
8000ae40:	58 08       	cp.w	r8,0
8000ae42:	c0 41       	brne	8000ae4a <_vfprintf_r+0x26>
8000ae44:	0a 9c       	mov	r12,r5
8000ae46:	e0 a0 17 57 	rcall	8000dcf4 <__sinit>
8000ae4a:	4d 08       	lddpc	r8,8000af88 <_vfprintf_r+0x164>
8000ae4c:	10 31       	cp.w	r1,r8
8000ae4e:	c0 31       	brne	8000ae54 <_vfprintf_r+0x30>
8000ae50:	6a 01       	ld.w	r1,r5[0x0]
8000ae52:	c0 a8       	rjmp	8000ae66 <_vfprintf_r+0x42>
8000ae54:	4c e8       	lddpc	r8,8000af8c <_vfprintf_r+0x168>
8000ae56:	10 31       	cp.w	r1,r8
8000ae58:	c0 31       	brne	8000ae5e <_vfprintf_r+0x3a>
8000ae5a:	6a 11       	ld.w	r1,r5[0x4]
8000ae5c:	c0 58       	rjmp	8000ae66 <_vfprintf_r+0x42>
8000ae5e:	4c d8       	lddpc	r8,8000af90 <_vfprintf_r+0x16c>
8000ae60:	10 31       	cp.w	r1,r8
8000ae62:	eb f1 00 02 	ld.weq	r1,r5[0x8]
8000ae66:	82 68       	ld.sh	r8,r1[0xc]
8000ae68:	ed b8 00 03 	bld	r8,0x3
8000ae6c:	c0 41       	brne	8000ae74 <_vfprintf_r+0x50>
8000ae6e:	62 48       	ld.w	r8,r1[0x10]
8000ae70:	58 08       	cp.w	r8,0
8000ae72:	c0 71       	brne	8000ae80 <_vfprintf_r+0x5c>
8000ae74:	02 9b       	mov	r11,r1
8000ae76:	0a 9c       	mov	r12,r5
8000ae78:	e0 a0 0f 6c 	rcall	8000cd50 <__swsetup_r>
8000ae7c:	e0 81 0f 63 	brne	8000cd42 <_vfprintf_r+0x1f1e>
8000ae80:	82 68       	ld.sh	r8,r1[0xc]
8000ae82:	10 99       	mov	r9,r8
8000ae84:	e2 19 00 1a 	andl	r9,0x1a,COH
8000ae88:	58 a9       	cp.w	r9,10
8000ae8a:	c3 c1       	brne	8000af02 <_vfprintf_r+0xde>
8000ae8c:	82 79       	ld.sh	r9,r1[0xe]
8000ae8e:	30 0a       	mov	r10,0
8000ae90:	f4 09 19 00 	cp.h	r9,r10
8000ae94:	c3 75       	brlt	8000af02 <_vfprintf_r+0xde>
8000ae96:	a1 d8       	cbr	r8,0x1
8000ae98:	fb 58 05 d0 	st.h	sp[1488],r8
8000ae9c:	62 88       	ld.w	r8,r1[0x20]
8000ae9e:	fb 48 05 e4 	st.w	sp[1508],r8
8000aea2:	62 a8       	ld.w	r8,r1[0x28]
8000aea4:	fb 48 05 ec 	st.w	sp[1516],r8
8000aea8:	fa c8 ff bc 	sub	r8,sp,-68
8000aeac:	fb 48 05 d4 	st.w	sp[1492],r8
8000aeb0:	fb 48 05 c4 	st.w	sp[1476],r8
8000aeb4:	e0 68 04 00 	mov	r8,1024
8000aeb8:	fb 48 05 d8 	st.w	sp[1496],r8
8000aebc:	fb 48 05 cc 	st.w	sp[1484],r8
8000aec0:	30 08       	mov	r8,0
8000aec2:	fb 59 05 d2 	st.h	sp[1490],r9
8000aec6:	0e 9a       	mov	r10,r7
8000aec8:	41 09       	lddsp	r9,sp[0x40]
8000aeca:	fa c7 fa 3c 	sub	r7,sp,-1476
8000aece:	fb 48 05 dc 	st.w	sp[1500],r8
8000aed2:	0a 9c       	mov	r12,r5
8000aed4:	0e 9b       	mov	r11,r7
8000aed6:	ca 7f       	rcall	8000ae24 <_vfprintf_r>
8000aed8:	50 bc       	stdsp	sp[0x2c],r12
8000aeda:	c0 95       	brlt	8000aeec <_vfprintf_r+0xc8>
8000aedc:	0e 9b       	mov	r11,r7
8000aede:	0a 9c       	mov	r12,r5
8000aee0:	e0 a0 16 2e 	rcall	8000db3c <_fflush_r>
8000aee4:	40 be       	lddsp	lr,sp[0x2c]
8000aee6:	f9 be 01 ff 	movne	lr,-1
8000aeea:	50 be       	stdsp	sp[0x2c],lr
8000aeec:	fb 08 05 d0 	ld.sh	r8,sp[1488]
8000aef0:	ed b8 00 06 	bld	r8,0x6
8000aef4:	e0 81 0f 29 	brne	8000cd46 <_vfprintf_r+0x1f22>
8000aef8:	82 68       	ld.sh	r8,r1[0xc]
8000aefa:	a7 a8       	sbr	r8,0x6
8000aefc:	a2 68       	st.h	r1[0xc],r8
8000aefe:	e0 8f 0f 24 	bral	8000cd46 <_vfprintf_r+0x1f22>
8000af02:	30 08       	mov	r8,0
8000af04:	fb 48 06 b4 	st.w	sp[1716],r8
8000af08:	fb 48 06 90 	st.w	sp[1680],r8
8000af0c:	fb 48 06 8c 	st.w	sp[1676],r8
8000af10:	fb 48 06 b0 	st.w	sp[1712],r8
8000af14:	30 08       	mov	r8,0
8000af16:	30 09       	mov	r9,0
8000af18:	50 a7       	stdsp	sp[0x28],r7
8000af1a:	50 78       	stdsp	sp[0x1c],r8
8000af1c:	fa c3 f9 e0 	sub	r3,sp,-1568
8000af20:	3f f8       	mov	r8,-1
8000af22:	50 59       	stdsp	sp[0x14],r9
8000af24:	fb 43 06 88 	st.w	sp[1672],r3
8000af28:	fb 48 05 44 	st.w	sp[1348],r8
8000af2c:	12 9c       	mov	r12,r9
8000af2e:	50 69       	stdsp	sp[0x18],r9
8000af30:	50 d9       	stdsp	sp[0x34],r9
8000af32:	50 e9       	stdsp	sp[0x38],r9
8000af34:	50 b9       	stdsp	sp[0x2c],r9
8000af36:	12 97       	mov	r7,r9
8000af38:	0a 94       	mov	r4,r5
8000af3a:	40 a2       	lddsp	r2,sp[0x28]
8000af3c:	32 5a       	mov	r10,37
8000af3e:	30 08       	mov	r8,0
8000af40:	c0 28       	rjmp	8000af44 <_vfprintf_r+0x120>
8000af42:	2f f2       	sub	r2,-1
8000af44:	05 89       	ld.ub	r9,r2[0x0]
8000af46:	f0 09 18 00 	cp.b	r9,r8
8000af4a:	5f 1b       	srne	r11
8000af4c:	f4 09 18 00 	cp.b	r9,r10
8000af50:	5f 19       	srne	r9
8000af52:	f3 eb 00 0b 	and	r11,r9,r11
8000af56:	f0 0b 18 00 	cp.b	r11,r8
8000af5a:	cf 41       	brne	8000af42 <_vfprintf_r+0x11e>
8000af5c:	40 ab       	lddsp	r11,sp[0x28]
8000af5e:	e4 0b 01 06 	sub	r6,r2,r11
8000af62:	c2 50       	breq	8000afac <_vfprintf_r+0x188>
8000af64:	fa f8 06 90 	ld.w	r8,sp[1680]
8000af68:	0c 08       	add	r8,r6
8000af6a:	87 0b       	st.w	r3[0x0],r11
8000af6c:	fb 48 06 90 	st.w	sp[1680],r8
8000af70:	87 16       	st.w	r3[0x4],r6
8000af72:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000af76:	2f f8       	sub	r8,-1
8000af78:	fb 48 06 8c 	st.w	sp[1676],r8
8000af7c:	58 78       	cp.w	r8,7
8000af7e:	e0 89 00 0b 	brgt	8000af94 <_vfprintf_r+0x170>
8000af82:	2f 83       	sub	r3,-8
8000af84:	c1 18       	rjmp	8000afa6 <_vfprintf_r+0x182>
8000af86:	d7 03       	nop
8000af88:	80 01       	ld.sh	r1,r0[0x0]
8000af8a:	92 d0       	ld.uh	r0,r9[0xa]
8000af8c:	80 01       	ld.sh	r1,r0[0x0]
8000af8e:	92 f0       	ld.uh	r0,r9[0xe]
8000af90:	80 01       	ld.sh	r1,r0[0x0]
8000af92:	93 10       	st.w	r9[0x4],r0
8000af94:	fa ca f9 78 	sub	r10,sp,-1672
8000af98:	02 9b       	mov	r11,r1
8000af9a:	08 9c       	mov	r12,r4
8000af9c:	c3 6f       	rcall	8000ae08 <__sprint_r>
8000af9e:	e0 81 0e ce 	brne	8000cd3a <_vfprintf_r+0x1f16>
8000afa2:	fa c3 f9 e0 	sub	r3,sp,-1568
8000afa6:	40 ba       	lddsp	r10,sp[0x2c]
8000afa8:	0c 0a       	add	r10,r6
8000afaa:	50 ba       	stdsp	sp[0x2c],r10
8000afac:	05 89       	ld.ub	r9,r2[0x0]
8000afae:	30 08       	mov	r8,0
8000afb0:	f0 09 18 00 	cp.b	r9,r8
8000afb4:	e0 80 0e b2 	breq	8000cd18 <_vfprintf_r+0x1ef4>
8000afb8:	30 09       	mov	r9,0
8000afba:	fb 68 06 bb 	st.b	sp[1723],r8
8000afbe:	0e 96       	mov	r6,r7
8000afc0:	e4 c8 ff ff 	sub	r8,r2,-1
8000afc4:	3f fe       	mov	lr,-1
8000afc6:	50 93       	stdsp	sp[0x24],r3
8000afc8:	50 41       	stdsp	sp[0x10],r1
8000afca:	0e 93       	mov	r3,r7
8000afcc:	04 91       	mov	r1,r2
8000afce:	50 89       	stdsp	sp[0x20],r9
8000afd0:	50 a8       	stdsp	sp[0x28],r8
8000afd2:	50 2e       	stdsp	sp[0x8],lr
8000afd4:	50 39       	stdsp	sp[0xc],r9
8000afd6:	12 95       	mov	r5,r9
8000afd8:	12 90       	mov	r0,r9
8000afda:	10 97       	mov	r7,r8
8000afdc:	08 92       	mov	r2,r4
8000afde:	c0 78       	rjmp	8000afec <_vfprintf_r+0x1c8>
8000afe0:	3f fc       	mov	r12,-1
8000afe2:	08 97       	mov	r7,r4
8000afe4:	50 2c       	stdsp	sp[0x8],r12
8000afe6:	c0 38       	rjmp	8000afec <_vfprintf_r+0x1c8>
8000afe8:	30 0b       	mov	r11,0
8000afea:	50 3b       	stdsp	sp[0xc],r11
8000afec:	0f 38       	ld.ub	r8,r7++
8000afee:	c0 28       	rjmp	8000aff2 <_vfprintf_r+0x1ce>
8000aff0:	12 90       	mov	r0,r9
8000aff2:	f0 c9 00 20 	sub	r9,r8,32
8000aff6:	e0 49 00 58 	cp.w	r9,88
8000affa:	e0 8b 0a 36 	brhi	8000c466 <_vfprintf_r+0x1642>
8000affe:	4d 9a       	lddpc	r10,8000b160 <_vfprintf_r+0x33c>
8000b000:	f4 09 03 2f 	ld.w	pc,r10[r9<<0x2]
8000b004:	50 a7       	stdsp	sp[0x28],r7
8000b006:	50 80       	stdsp	sp[0x20],r0
8000b008:	0c 97       	mov	r7,r6
8000b00a:	04 94       	mov	r4,r2
8000b00c:	06 96       	mov	r6,r3
8000b00e:	02 92       	mov	r2,r1
8000b010:	4d 59       	lddpc	r9,8000b164 <_vfprintf_r+0x340>
8000b012:	40 93       	lddsp	r3,sp[0x24]
8000b014:	10 90       	mov	r0,r8
8000b016:	40 41       	lddsp	r1,sp[0x10]
8000b018:	50 d9       	stdsp	sp[0x34],r9
8000b01a:	e0 8f 08 95 	bral	8000c144 <_vfprintf_r+0x1320>
8000b01e:	30 08       	mov	r8,0
8000b020:	fb 39 06 bb 	ld.ub	r9,sp[1723]
8000b024:	f0 09 18 00 	cp.b	r9,r8
8000b028:	ce 21       	brne	8000afec <_vfprintf_r+0x1c8>
8000b02a:	32 08       	mov	r8,32
8000b02c:	c6 e8       	rjmp	8000b108 <_vfprintf_r+0x2e4>
8000b02e:	a1 a5       	sbr	r5,0x0
8000b030:	cd eb       	rjmp	8000afec <_vfprintf_r+0x1c8>
8000b032:	0f 89       	ld.ub	r9,r7[0x0]
8000b034:	f2 c8 00 30 	sub	r8,r9,48
8000b038:	58 98       	cp.w	r8,9
8000b03a:	e0 8b 00 1d 	brhi	8000b074 <_vfprintf_r+0x250>
8000b03e:	ee c8 ff ff 	sub	r8,r7,-1
8000b042:	30 0b       	mov	r11,0
8000b044:	23 09       	sub	r9,48
8000b046:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
8000b04a:	f2 0b 00 1b 	add	r11,r9,r11<<0x1
8000b04e:	11 39       	ld.ub	r9,r8++
8000b050:	f2 ca 00 30 	sub	r10,r9,48
8000b054:	58 9a       	cp.w	r10,9
8000b056:	fe 98 ff f7 	brls	8000b044 <_vfprintf_r+0x220>
8000b05a:	e0 49 00 24 	cp.w	r9,36
8000b05e:	cc 51       	brne	8000afe8 <_vfprintf_r+0x1c4>
8000b060:	e0 4b 00 20 	cp.w	r11,32
8000b064:	e0 89 0e 6a 	brgt	8000cd38 <_vfprintf_r+0x1f14>
8000b068:	20 1b       	sub	r11,1
8000b06a:	fa f9 06 b4 	ld.w	r9,sp[1716]
8000b06e:	12 3b       	cp.w	r11,r9
8000b070:	c0 95       	brlt	8000b082 <_vfprintf_r+0x25e>
8000b072:	c1 08       	rjmp	8000b092 <_vfprintf_r+0x26e>
8000b074:	fa f9 06 b4 	ld.w	r9,sp[1716]
8000b078:	ec ca ff ff 	sub	r10,r6,-1
8000b07c:	12 36       	cp.w	r6,r9
8000b07e:	c1 f5       	brlt	8000b0bc <_vfprintf_r+0x298>
8000b080:	c2 68       	rjmp	8000b0cc <_vfprintf_r+0x2a8>
8000b082:	fa ce f9 44 	sub	lr,sp,-1724
8000b086:	10 97       	mov	r7,r8
8000b088:	fc 0b 00 3b 	add	r11,lr,r11<<0x3
8000b08c:	f6 f0 fd 88 	ld.w	r0,r11[-632]
8000b090:	c3 58       	rjmp	8000b0fa <_vfprintf_r+0x2d6>
8000b092:	10 97       	mov	r7,r8
8000b094:	fa c8 f9 50 	sub	r8,sp,-1712
8000b098:	1a d8       	st.w	--sp,r8
8000b09a:	fa c8 fa b8 	sub	r8,sp,-1352
8000b09e:	1a d8       	st.w	--sp,r8
8000b0a0:	fa c8 fb b4 	sub	r8,sp,-1100
8000b0a4:	02 9a       	mov	r10,r1
8000b0a6:	1a d8       	st.w	--sp,r8
8000b0a8:	04 9c       	mov	r12,r2
8000b0aa:	fa c8 f9 40 	sub	r8,sp,-1728
8000b0ae:	fa c9 ff b4 	sub	r9,sp,-76
8000b0b2:	fe b0 fd 1b 	rcall	8000aae8 <get_arg>
8000b0b6:	2f dd       	sub	sp,-12
8000b0b8:	78 00       	ld.w	r0,r12[0x0]
8000b0ba:	c2 08       	rjmp	8000b0fa <_vfprintf_r+0x2d6>
8000b0bc:	fa cc f9 44 	sub	r12,sp,-1724
8000b0c0:	14 96       	mov	r6,r10
8000b0c2:	f8 03 00 38 	add	r8,r12,r3<<0x3
8000b0c6:	f0 f0 fd 88 	ld.w	r0,r8[-632]
8000b0ca:	c1 88       	rjmp	8000b0fa <_vfprintf_r+0x2d6>
8000b0cc:	41 08       	lddsp	r8,sp[0x40]
8000b0ce:	59 f9       	cp.w	r9,31
8000b0d0:	e0 89 00 11 	brgt	8000b0f2 <_vfprintf_r+0x2ce>
8000b0d4:	f0 cb ff fc 	sub	r11,r8,-4
8000b0d8:	51 0b       	stdsp	sp[0x40],r11
8000b0da:	70 00       	ld.w	r0,r8[0x0]
8000b0dc:	fa cb f9 44 	sub	r11,sp,-1724
8000b0e0:	f6 09 00 38 	add	r8,r11,r9<<0x3
8000b0e4:	f1 40 fd 88 	st.w	r8[-632],r0
8000b0e8:	2f f9       	sub	r9,-1
8000b0ea:	14 96       	mov	r6,r10
8000b0ec:	fb 49 06 b4 	st.w	sp[1716],r9
8000b0f0:	c0 58       	rjmp	8000b0fa <_vfprintf_r+0x2d6>
8000b0f2:	70 00       	ld.w	r0,r8[0x0]
8000b0f4:	14 96       	mov	r6,r10
8000b0f6:	2f c8       	sub	r8,-4
8000b0f8:	51 08       	stdsp	sp[0x40],r8
8000b0fa:	58 00       	cp.w	r0,0
8000b0fc:	fe 94 ff 78 	brge	8000afec <_vfprintf_r+0x1c8>
8000b100:	5c 30       	neg	r0
8000b102:	a3 a5       	sbr	r5,0x2
8000b104:	c7 4b       	rjmp	8000afec <_vfprintf_r+0x1c8>
8000b106:	32 b8       	mov	r8,43
8000b108:	fb 68 06 bb 	st.b	sp[1723],r8
8000b10c:	c7 0b       	rjmp	8000afec <_vfprintf_r+0x1c8>
8000b10e:	0f 38       	ld.ub	r8,r7++
8000b110:	e0 48 00 2a 	cp.w	r8,42
8000b114:	c0 30       	breq	8000b11a <_vfprintf_r+0x2f6>
8000b116:	30 09       	mov	r9,0
8000b118:	c7 d8       	rjmp	8000b212 <_vfprintf_r+0x3ee>
8000b11a:	0f 88       	ld.ub	r8,r7[0x0]
8000b11c:	f0 c9 00 30 	sub	r9,r8,48
8000b120:	58 99       	cp.w	r9,9
8000b122:	e0 8b 00 23 	brhi	8000b168 <_vfprintf_r+0x344>
8000b126:	ee c4 ff ff 	sub	r4,r7,-1
8000b12a:	30 0b       	mov	r11,0
8000b12c:	23 08       	sub	r8,48
8000b12e:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
8000b132:	f0 0b 00 1b 	add	r11,r8,r11<<0x1
8000b136:	09 38       	ld.ub	r8,r4++
8000b138:	f0 c9 00 30 	sub	r9,r8,48
8000b13c:	58 99       	cp.w	r9,9
8000b13e:	fe 98 ff f7 	brls	8000b12c <_vfprintf_r+0x308>
8000b142:	e0 48 00 24 	cp.w	r8,36
8000b146:	fe 91 ff 51 	brne	8000afe8 <_vfprintf_r+0x1c4>
8000b14a:	e0 4b 00 20 	cp.w	r11,32
8000b14e:	e0 89 0d f5 	brgt	8000cd38 <_vfprintf_r+0x1f14>
8000b152:	20 1b       	sub	r11,1
8000b154:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000b158:	10 3b       	cp.w	r11,r8
8000b15a:	c0 e5       	brlt	8000b176 <_vfprintf_r+0x352>
8000b15c:	c1 58       	rjmp	8000b186 <_vfprintf_r+0x362>
8000b15e:	d7 03       	nop
8000b160:	80 01       	ld.sh	r1,r0[0x0]
8000b162:	8f 28       	st.w	r7[0x8],r8
8000b164:	80 01       	ld.sh	r1,r0[0x0]
8000b166:	91 64       	st.w	r8[0x18],r4
8000b168:	fa fa 06 b4 	ld.w	r10,sp[1716]
8000b16c:	ec c9 ff ff 	sub	r9,r6,-1
8000b170:	14 36       	cp.w	r6,r10
8000b172:	c1 f5       	brlt	8000b1b0 <_vfprintf_r+0x38c>
8000b174:	c2 88       	rjmp	8000b1c4 <_vfprintf_r+0x3a0>
8000b176:	fa ca f9 44 	sub	r10,sp,-1724
8000b17a:	f4 0b 00 3b 	add	r11,r10,r11<<0x3
8000b17e:	f6 fb fd 88 	ld.w	r11,r11[-632]
8000b182:	50 2b       	stdsp	sp[0x8],r11
8000b184:	c3 c8       	rjmp	8000b1fc <_vfprintf_r+0x3d8>
8000b186:	fa c8 f9 50 	sub	r8,sp,-1712
8000b18a:	1a d8       	st.w	--sp,r8
8000b18c:	fa c8 fa b8 	sub	r8,sp,-1352
8000b190:	1a d8       	st.w	--sp,r8
8000b192:	fa c8 fb b4 	sub	r8,sp,-1100
8000b196:	02 9a       	mov	r10,r1
8000b198:	1a d8       	st.w	--sp,r8
8000b19a:	04 9c       	mov	r12,r2
8000b19c:	fa c8 f9 40 	sub	r8,sp,-1728
8000b1a0:	fa c9 ff b4 	sub	r9,sp,-76
8000b1a4:	fe b0 fc a2 	rcall	8000aae8 <get_arg>
8000b1a8:	2f dd       	sub	sp,-12
8000b1aa:	78 0c       	ld.w	r12,r12[0x0]
8000b1ac:	50 2c       	stdsp	sp[0x8],r12
8000b1ae:	c2 78       	rjmp	8000b1fc <_vfprintf_r+0x3d8>
8000b1b0:	12 96       	mov	r6,r9
8000b1b2:	0e 94       	mov	r4,r7
8000b1b4:	fa c9 f9 44 	sub	r9,sp,-1724
8000b1b8:	f2 03 00 38 	add	r8,r9,r3<<0x3
8000b1bc:	f0 f8 fd 88 	ld.w	r8,r8[-632]
8000b1c0:	50 28       	stdsp	sp[0x8],r8
8000b1c2:	c1 d8       	rjmp	8000b1fc <_vfprintf_r+0x3d8>
8000b1c4:	41 08       	lddsp	r8,sp[0x40]
8000b1c6:	59 fa       	cp.w	r10,31
8000b1c8:	e0 89 00 14 	brgt	8000b1f0 <_vfprintf_r+0x3cc>
8000b1cc:	f0 cb ff fc 	sub	r11,r8,-4
8000b1d0:	70 08       	ld.w	r8,r8[0x0]
8000b1d2:	51 0b       	stdsp	sp[0x40],r11
8000b1d4:	50 28       	stdsp	sp[0x8],r8
8000b1d6:	fa c6 f9 44 	sub	r6,sp,-1724
8000b1da:	40 2e       	lddsp	lr,sp[0x8]
8000b1dc:	ec 0a 00 38 	add	r8,r6,r10<<0x3
8000b1e0:	f1 4e fd 88 	st.w	r8[-632],lr
8000b1e4:	2f fa       	sub	r10,-1
8000b1e6:	0e 94       	mov	r4,r7
8000b1e8:	fb 4a 06 b4 	st.w	sp[1716],r10
8000b1ec:	12 96       	mov	r6,r9
8000b1ee:	c0 78       	rjmp	8000b1fc <_vfprintf_r+0x3d8>
8000b1f0:	70 0c       	ld.w	r12,r8[0x0]
8000b1f2:	0e 94       	mov	r4,r7
8000b1f4:	2f c8       	sub	r8,-4
8000b1f6:	50 2c       	stdsp	sp[0x8],r12
8000b1f8:	12 96       	mov	r6,r9
8000b1fa:	51 08       	stdsp	sp[0x40],r8
8000b1fc:	40 2b       	lddsp	r11,sp[0x8]
8000b1fe:	58 0b       	cp.w	r11,0
8000b200:	fe 95 fe f0 	brlt	8000afe0 <_vfprintf_r+0x1bc>
8000b204:	08 97       	mov	r7,r4
8000b206:	cf 3a       	rjmp	8000afec <_vfprintf_r+0x1c8>
8000b208:	f2 09 00 29 	add	r9,r9,r9<<0x2
8000b20c:	0f 38       	ld.ub	r8,r7++
8000b20e:	f4 09 00 19 	add	r9,r10,r9<<0x1
8000b212:	f0 ca 00 30 	sub	r10,r8,48
8000b216:	58 9a       	cp.w	r10,9
8000b218:	fe 98 ff f8 	brls	8000b208 <_vfprintf_r+0x3e4>
8000b21c:	3f fa       	mov	r10,-1
8000b21e:	f2 0a 0c 49 	max	r9,r9,r10
8000b222:	50 29       	stdsp	sp[0x8],r9
8000b224:	ce 7a       	rjmp	8000aff2 <_vfprintf_r+0x1ce>
8000b226:	a7 b5       	sbr	r5,0x7
8000b228:	ce 2a       	rjmp	8000afec <_vfprintf_r+0x1c8>
8000b22a:	30 09       	mov	r9,0
8000b22c:	23 08       	sub	r8,48
8000b22e:	f2 09 00 29 	add	r9,r9,r9<<0x2
8000b232:	f0 09 00 19 	add	r9,r8,r9<<0x1
8000b236:	0f 38       	ld.ub	r8,r7++
8000b238:	f0 ca 00 30 	sub	r10,r8,48
8000b23c:	58 9a       	cp.w	r10,9
8000b23e:	fe 98 ff f7 	brls	8000b22c <_vfprintf_r+0x408>
8000b242:	e0 48 00 24 	cp.w	r8,36
8000b246:	fe 91 fe d5 	brne	8000aff0 <_vfprintf_r+0x1cc>
8000b24a:	e0 49 00 20 	cp.w	r9,32
8000b24e:	e0 89 0d 75 	brgt	8000cd38 <_vfprintf_r+0x1f14>
8000b252:	f2 c3 00 01 	sub	r3,r9,1
8000b256:	30 19       	mov	r9,1
8000b258:	50 39       	stdsp	sp[0xc],r9
8000b25a:	cc 9a       	rjmp	8000afec <_vfprintf_r+0x1c8>
8000b25c:	a3 b5       	sbr	r5,0x3
8000b25e:	cc 7a       	rjmp	8000afec <_vfprintf_r+0x1c8>
8000b260:	a7 a5       	sbr	r5,0x6
8000b262:	cc 5a       	rjmp	8000afec <_vfprintf_r+0x1c8>
8000b264:	0a 98       	mov	r8,r5
8000b266:	a5 b5       	sbr	r5,0x5
8000b268:	a5 a8       	sbr	r8,0x4
8000b26a:	0f 89       	ld.ub	r9,r7[0x0]
8000b26c:	36 ce       	mov	lr,108
8000b26e:	fc 09 18 00 	cp.b	r9,lr
8000b272:	f7 b7 00 ff 	subeq	r7,-1
8000b276:	f0 05 17 10 	movne	r5,r8
8000b27a:	cb 9a       	rjmp	8000afec <_vfprintf_r+0x1c8>
8000b27c:	a5 b5       	sbr	r5,0x5
8000b27e:	cb 7a       	rjmp	8000afec <_vfprintf_r+0x1c8>
8000b280:	50 a7       	stdsp	sp[0x28],r7
8000b282:	50 80       	stdsp	sp[0x20],r0
8000b284:	0c 97       	mov	r7,r6
8000b286:	10 90       	mov	r0,r8
8000b288:	06 96       	mov	r6,r3
8000b28a:	04 94       	mov	r4,r2
8000b28c:	40 93       	lddsp	r3,sp[0x24]
8000b28e:	02 92       	mov	r2,r1
8000b290:	0e 99       	mov	r9,r7
8000b292:	40 41       	lddsp	r1,sp[0x10]
8000b294:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000b298:	40 3c       	lddsp	r12,sp[0xc]
8000b29a:	58 0c       	cp.w	r12,0
8000b29c:	c1 d0       	breq	8000b2d6 <_vfprintf_r+0x4b2>
8000b29e:	10 36       	cp.w	r6,r8
8000b2a0:	c0 64       	brge	8000b2ac <_vfprintf_r+0x488>
8000b2a2:	fa cb f9 44 	sub	r11,sp,-1724
8000b2a6:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000b2aa:	c1 d8       	rjmp	8000b2e4 <_vfprintf_r+0x4c0>
8000b2ac:	fa c8 f9 50 	sub	r8,sp,-1712
8000b2b0:	1a d8       	st.w	--sp,r8
8000b2b2:	fa c8 fa b8 	sub	r8,sp,-1352
8000b2b6:	1a d8       	st.w	--sp,r8
8000b2b8:	fa c8 fb b4 	sub	r8,sp,-1100
8000b2bc:	1a d8       	st.w	--sp,r8
8000b2be:	fa c8 f9 40 	sub	r8,sp,-1728
8000b2c2:	fa c9 ff b4 	sub	r9,sp,-76
8000b2c6:	04 9a       	mov	r10,r2
8000b2c8:	0c 9b       	mov	r11,r6
8000b2ca:	08 9c       	mov	r12,r4
8000b2cc:	fe b0 fc 0e 	rcall	8000aae8 <get_arg>
8000b2d0:	2f dd       	sub	sp,-12
8000b2d2:	19 b8       	ld.ub	r8,r12[0x3]
8000b2d4:	c2 28       	rjmp	8000b318 <_vfprintf_r+0x4f4>
8000b2d6:	2f f7       	sub	r7,-1
8000b2d8:	10 39       	cp.w	r9,r8
8000b2da:	c0 84       	brge	8000b2ea <_vfprintf_r+0x4c6>
8000b2dc:	fa ca f9 44 	sub	r10,sp,-1724
8000b2e0:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000b2e4:	ed 38 fd 8b 	ld.ub	r8,r6[-629]
8000b2e8:	c1 88       	rjmp	8000b318 <_vfprintf_r+0x4f4>
8000b2ea:	41 09       	lddsp	r9,sp[0x40]
8000b2ec:	59 f8       	cp.w	r8,31
8000b2ee:	e0 89 00 12 	brgt	8000b312 <_vfprintf_r+0x4ee>
8000b2f2:	f2 ca ff fc 	sub	r10,r9,-4
8000b2f6:	51 0a       	stdsp	sp[0x40],r10
8000b2f8:	72 09       	ld.w	r9,r9[0x0]
8000b2fa:	fa c6 f9 44 	sub	r6,sp,-1724
8000b2fe:	ec 08 00 3a 	add	r10,r6,r8<<0x3
8000b302:	2f f8       	sub	r8,-1
8000b304:	f5 49 fd 88 	st.w	r10[-632],r9
8000b308:	fb 48 06 b4 	st.w	sp[1716],r8
8000b30c:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
8000b310:	c0 48       	rjmp	8000b318 <_vfprintf_r+0x4f4>
8000b312:	13 b8       	ld.ub	r8,r9[0x3]
8000b314:	2f c9       	sub	r9,-4
8000b316:	51 09       	stdsp	sp[0x40],r9
8000b318:	fb 68 06 60 	st.b	sp[1632],r8
8000b31c:	30 0e       	mov	lr,0
8000b31e:	30 08       	mov	r8,0
8000b320:	30 12       	mov	r2,1
8000b322:	fb 68 06 bb 	st.b	sp[1723],r8
8000b326:	50 2e       	stdsp	sp[0x8],lr
8000b328:	e0 8f 08 b1 	bral	8000c48a <_vfprintf_r+0x1666>
8000b32c:	50 a7       	stdsp	sp[0x28],r7
8000b32e:	50 80       	stdsp	sp[0x20],r0
8000b330:	0c 97       	mov	r7,r6
8000b332:	04 94       	mov	r4,r2
8000b334:	06 96       	mov	r6,r3
8000b336:	02 92       	mov	r2,r1
8000b338:	40 93       	lddsp	r3,sp[0x24]
8000b33a:	10 90       	mov	r0,r8
8000b33c:	40 41       	lddsp	r1,sp[0x10]
8000b33e:	a5 a5       	sbr	r5,0x4
8000b340:	c0 a8       	rjmp	8000b354 <_vfprintf_r+0x530>
8000b342:	50 a7       	stdsp	sp[0x28],r7
8000b344:	50 80       	stdsp	sp[0x20],r0
8000b346:	0c 97       	mov	r7,r6
8000b348:	04 94       	mov	r4,r2
8000b34a:	06 96       	mov	r6,r3
8000b34c:	02 92       	mov	r2,r1
8000b34e:	40 93       	lddsp	r3,sp[0x24]
8000b350:	10 90       	mov	r0,r8
8000b352:	40 41       	lddsp	r1,sp[0x10]
8000b354:	ed b5 00 05 	bld	r5,0x5
8000b358:	c5 11       	brne	8000b3fa <_vfprintf_r+0x5d6>
8000b35a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000b35e:	40 3c       	lddsp	r12,sp[0xc]
8000b360:	58 0c       	cp.w	r12,0
8000b362:	c1 e0       	breq	8000b39e <_vfprintf_r+0x57a>
8000b364:	10 36       	cp.w	r6,r8
8000b366:	c0 64       	brge	8000b372 <_vfprintf_r+0x54e>
8000b368:	fa cb f9 44 	sub	r11,sp,-1724
8000b36c:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000b370:	c2 08       	rjmp	8000b3b0 <_vfprintf_r+0x58c>
8000b372:	fa c8 f9 50 	sub	r8,sp,-1712
8000b376:	1a d8       	st.w	--sp,r8
8000b378:	fa c8 fa b8 	sub	r8,sp,-1352
8000b37c:	0c 9b       	mov	r11,r6
8000b37e:	1a d8       	st.w	--sp,r8
8000b380:	fa c8 fb b4 	sub	r8,sp,-1100
8000b384:	1a d8       	st.w	--sp,r8
8000b386:	fa c9 ff b4 	sub	r9,sp,-76
8000b38a:	fa c8 f9 40 	sub	r8,sp,-1728
8000b38e:	04 9a       	mov	r10,r2
8000b390:	08 9c       	mov	r12,r4
8000b392:	fe b0 fb ab 	rcall	8000aae8 <get_arg>
8000b396:	2f dd       	sub	sp,-12
8000b398:	78 1b       	ld.w	r11,r12[0x4]
8000b39a:	78 09       	ld.w	r9,r12[0x0]
8000b39c:	c2 b8       	rjmp	8000b3f2 <_vfprintf_r+0x5ce>
8000b39e:	ee ca ff ff 	sub	r10,r7,-1
8000b3a2:	10 37       	cp.w	r7,r8
8000b3a4:	c0 b4       	brge	8000b3ba <_vfprintf_r+0x596>
8000b3a6:	fa c9 f9 44 	sub	r9,sp,-1724
8000b3aa:	14 97       	mov	r7,r10
8000b3ac:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000b3b0:	ec fb fd 8c 	ld.w	r11,r6[-628]
8000b3b4:	ec f9 fd 88 	ld.w	r9,r6[-632]
8000b3b8:	c1 d8       	rjmp	8000b3f2 <_vfprintf_r+0x5ce>
8000b3ba:	41 09       	lddsp	r9,sp[0x40]
8000b3bc:	59 f8       	cp.w	r8,31
8000b3be:	e0 89 00 14 	brgt	8000b3e6 <_vfprintf_r+0x5c2>
8000b3c2:	f2 cb ff f8 	sub	r11,r9,-8
8000b3c6:	51 0b       	stdsp	sp[0x40],r11
8000b3c8:	fa c6 f9 44 	sub	r6,sp,-1724
8000b3cc:	72 1b       	ld.w	r11,r9[0x4]
8000b3ce:	ec 08 00 3c 	add	r12,r6,r8<<0x3
8000b3d2:	72 09       	ld.w	r9,r9[0x0]
8000b3d4:	f9 4b fd 8c 	st.w	r12[-628],r11
8000b3d8:	f9 49 fd 88 	st.w	r12[-632],r9
8000b3dc:	2f f8       	sub	r8,-1
8000b3de:	14 97       	mov	r7,r10
8000b3e0:	fb 48 06 b4 	st.w	sp[1716],r8
8000b3e4:	c0 78       	rjmp	8000b3f2 <_vfprintf_r+0x5ce>
8000b3e6:	f2 c8 ff f8 	sub	r8,r9,-8
8000b3ea:	72 1b       	ld.w	r11,r9[0x4]
8000b3ec:	14 97       	mov	r7,r10
8000b3ee:	51 08       	stdsp	sp[0x40],r8
8000b3f0:	72 09       	ld.w	r9,r9[0x0]
8000b3f2:	16 98       	mov	r8,r11
8000b3f4:	fa e9 00 00 	st.d	sp[0],r8
8000b3f8:	ca e8       	rjmp	8000b554 <_vfprintf_r+0x730>
8000b3fa:	ed b5 00 04 	bld	r5,0x4
8000b3fe:	c1 71       	brne	8000b42c <_vfprintf_r+0x608>
8000b400:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000b404:	40 3e       	lddsp	lr,sp[0xc]
8000b406:	58 0e       	cp.w	lr,0
8000b408:	c0 80       	breq	8000b418 <_vfprintf_r+0x5f4>
8000b40a:	10 36       	cp.w	r6,r8
8000b40c:	c6 94       	brge	8000b4de <_vfprintf_r+0x6ba>
8000b40e:	fa cc f9 44 	sub	r12,sp,-1724
8000b412:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000b416:	c8 28       	rjmp	8000b51a <_vfprintf_r+0x6f6>
8000b418:	ee ca ff ff 	sub	r10,r7,-1
8000b41c:	10 37       	cp.w	r7,r8
8000b41e:	e0 84 00 81 	brge	8000b520 <_vfprintf_r+0x6fc>
8000b422:	fa cb f9 44 	sub	r11,sp,-1724
8000b426:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000b42a:	c7 78       	rjmp	8000b518 <_vfprintf_r+0x6f4>
8000b42c:	ed b5 00 06 	bld	r5,0x6
8000b430:	c4 b1       	brne	8000b4c6 <_vfprintf_r+0x6a2>
8000b432:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000b436:	40 3c       	lddsp	r12,sp[0xc]
8000b438:	58 0c       	cp.w	r12,0
8000b43a:	c1 d0       	breq	8000b474 <_vfprintf_r+0x650>
8000b43c:	10 36       	cp.w	r6,r8
8000b43e:	c0 64       	brge	8000b44a <_vfprintf_r+0x626>
8000b440:	fa cb f9 44 	sub	r11,sp,-1724
8000b444:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000b448:	c1 f8       	rjmp	8000b486 <_vfprintf_r+0x662>
8000b44a:	fa c8 f9 50 	sub	r8,sp,-1712
8000b44e:	1a d8       	st.w	--sp,r8
8000b450:	fa c8 fa b8 	sub	r8,sp,-1352
8000b454:	1a d8       	st.w	--sp,r8
8000b456:	fa c8 fb b4 	sub	r8,sp,-1100
8000b45a:	1a d8       	st.w	--sp,r8
8000b45c:	fa c8 f9 40 	sub	r8,sp,-1728
8000b460:	fa c9 ff b4 	sub	r9,sp,-76
8000b464:	04 9a       	mov	r10,r2
8000b466:	0c 9b       	mov	r11,r6
8000b468:	08 9c       	mov	r12,r4
8000b46a:	fe b0 fb 3f 	rcall	8000aae8 <get_arg>
8000b46e:	2f dd       	sub	sp,-12
8000b470:	98 18       	ld.sh	r8,r12[0x2]
8000b472:	c2 68       	rjmp	8000b4be <_vfprintf_r+0x69a>
8000b474:	ee ca ff ff 	sub	r10,r7,-1
8000b478:	10 37       	cp.w	r7,r8
8000b47a:	c0 94       	brge	8000b48c <_vfprintf_r+0x668>
8000b47c:	fa c9 f9 44 	sub	r9,sp,-1724
8000b480:	14 97       	mov	r7,r10
8000b482:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000b486:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000b48a:	c1 a8       	rjmp	8000b4be <_vfprintf_r+0x69a>
8000b48c:	41 09       	lddsp	r9,sp[0x40]
8000b48e:	59 f8       	cp.w	r8,31
8000b490:	e0 89 00 13 	brgt	8000b4b6 <_vfprintf_r+0x692>
8000b494:	f2 cb ff fc 	sub	r11,r9,-4
8000b498:	51 0b       	stdsp	sp[0x40],r11
8000b49a:	72 09       	ld.w	r9,r9[0x0]
8000b49c:	fa c6 f9 44 	sub	r6,sp,-1724
8000b4a0:	ec 08 00 3b 	add	r11,r6,r8<<0x3
8000b4a4:	2f f8       	sub	r8,-1
8000b4a6:	f7 49 fd 88 	st.w	r11[-632],r9
8000b4aa:	fb 48 06 b4 	st.w	sp[1716],r8
8000b4ae:	14 97       	mov	r7,r10
8000b4b0:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
8000b4b4:	c0 58       	rjmp	8000b4be <_vfprintf_r+0x69a>
8000b4b6:	92 18       	ld.sh	r8,r9[0x2]
8000b4b8:	14 97       	mov	r7,r10
8000b4ba:	2f c9       	sub	r9,-4
8000b4bc:	51 09       	stdsp	sp[0x40],r9
8000b4be:	50 18       	stdsp	sp[0x4],r8
8000b4c0:	bf 58       	asr	r8,0x1f
8000b4c2:	50 08       	stdsp	sp[0x0],r8
8000b4c4:	c4 88       	rjmp	8000b554 <_vfprintf_r+0x730>
8000b4c6:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000b4ca:	40 3c       	lddsp	r12,sp[0xc]
8000b4cc:	58 0c       	cp.w	r12,0
8000b4ce:	c1 d0       	breq	8000b508 <_vfprintf_r+0x6e4>
8000b4d0:	10 36       	cp.w	r6,r8
8000b4d2:	c0 64       	brge	8000b4de <_vfprintf_r+0x6ba>
8000b4d4:	fa cb f9 44 	sub	r11,sp,-1724
8000b4d8:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000b4dc:	c1 f8       	rjmp	8000b51a <_vfprintf_r+0x6f6>
8000b4de:	fa c8 f9 50 	sub	r8,sp,-1712
8000b4e2:	1a d8       	st.w	--sp,r8
8000b4e4:	fa c8 fa b8 	sub	r8,sp,-1352
8000b4e8:	0c 9b       	mov	r11,r6
8000b4ea:	1a d8       	st.w	--sp,r8
8000b4ec:	fa c8 fb b4 	sub	r8,sp,-1100
8000b4f0:	04 9a       	mov	r10,r2
8000b4f2:	1a d8       	st.w	--sp,r8
8000b4f4:	08 9c       	mov	r12,r4
8000b4f6:	fa c8 f9 40 	sub	r8,sp,-1728
8000b4fa:	fa c9 ff b4 	sub	r9,sp,-76
8000b4fe:	fe b0 fa f5 	rcall	8000aae8 <get_arg>
8000b502:	2f dd       	sub	sp,-12
8000b504:	78 0b       	ld.w	r11,r12[0x0]
8000b506:	c2 48       	rjmp	8000b54e <_vfprintf_r+0x72a>
8000b508:	ee ca ff ff 	sub	r10,r7,-1
8000b50c:	10 37       	cp.w	r7,r8
8000b50e:	c0 94       	brge	8000b520 <_vfprintf_r+0x6fc>
8000b510:	fa c9 f9 44 	sub	r9,sp,-1724
8000b514:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000b518:	14 97       	mov	r7,r10
8000b51a:	ec fb fd 88 	ld.w	r11,r6[-632]
8000b51e:	c1 88       	rjmp	8000b54e <_vfprintf_r+0x72a>
8000b520:	41 09       	lddsp	r9,sp[0x40]
8000b522:	59 f8       	cp.w	r8,31
8000b524:	e0 89 00 11 	brgt	8000b546 <_vfprintf_r+0x722>
8000b528:	f2 cb ff fc 	sub	r11,r9,-4
8000b52c:	51 0b       	stdsp	sp[0x40],r11
8000b52e:	fa c6 f9 44 	sub	r6,sp,-1724
8000b532:	72 0b       	ld.w	r11,r9[0x0]
8000b534:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000b538:	f3 4b fd 88 	st.w	r9[-632],r11
8000b53c:	2f f8       	sub	r8,-1
8000b53e:	14 97       	mov	r7,r10
8000b540:	fb 48 06 b4 	st.w	sp[1716],r8
8000b544:	c0 58       	rjmp	8000b54e <_vfprintf_r+0x72a>
8000b546:	72 0b       	ld.w	r11,r9[0x0]
8000b548:	14 97       	mov	r7,r10
8000b54a:	2f c9       	sub	r9,-4
8000b54c:	51 09       	stdsp	sp[0x40],r9
8000b54e:	50 1b       	stdsp	sp[0x4],r11
8000b550:	bf 5b       	asr	r11,0x1f
8000b552:	50 0b       	stdsp	sp[0x0],r11
8000b554:	fa ea 00 00 	ld.d	r10,sp[0]
8000b558:	58 0a       	cp.w	r10,0
8000b55a:	5c 2b       	cpc	r11
8000b55c:	c0 e4       	brge	8000b578 <_vfprintf_r+0x754>
8000b55e:	30 08       	mov	r8,0
8000b560:	fa ea 00 00 	ld.d	r10,sp[0]
8000b564:	30 09       	mov	r9,0
8000b566:	f0 0a 01 0a 	sub	r10,r8,r10
8000b56a:	f2 0b 01 4b 	sbc	r11,r9,r11
8000b56e:	32 d8       	mov	r8,45
8000b570:	fa eb 00 00 	st.d	sp[0],r10
8000b574:	fb 68 06 bb 	st.b	sp[1723],r8
8000b578:	30 18       	mov	r8,1
8000b57a:	e0 8f 06 fe 	bral	8000c376 <_vfprintf_r+0x1552>
8000b57e:	50 a7       	stdsp	sp[0x28],r7
8000b580:	50 80       	stdsp	sp[0x20],r0
8000b582:	0c 97       	mov	r7,r6
8000b584:	04 94       	mov	r4,r2
8000b586:	06 96       	mov	r6,r3
8000b588:	02 92       	mov	r2,r1
8000b58a:	40 93       	lddsp	r3,sp[0x24]
8000b58c:	10 90       	mov	r0,r8
8000b58e:	40 41       	lddsp	r1,sp[0x10]
8000b590:	0e 99       	mov	r9,r7
8000b592:	ed b5 00 03 	bld	r5,0x3
8000b596:	c4 11       	brne	8000b618 <_vfprintf_r+0x7f4>
8000b598:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000b59c:	40 3a       	lddsp	r10,sp[0xc]
8000b59e:	58 0a       	cp.w	r10,0
8000b5a0:	c1 90       	breq	8000b5d2 <_vfprintf_r+0x7ae>
8000b5a2:	10 36       	cp.w	r6,r8
8000b5a4:	c6 45       	brlt	8000b66c <_vfprintf_r+0x848>
8000b5a6:	fa c8 f9 50 	sub	r8,sp,-1712
8000b5aa:	1a d8       	st.w	--sp,r8
8000b5ac:	fa c8 fa b8 	sub	r8,sp,-1352
8000b5b0:	1a d8       	st.w	--sp,r8
8000b5b2:	fa c8 fb b4 	sub	r8,sp,-1100
8000b5b6:	0c 9b       	mov	r11,r6
8000b5b8:	1a d8       	st.w	--sp,r8
8000b5ba:	04 9a       	mov	r10,r2
8000b5bc:	fa c8 f9 40 	sub	r8,sp,-1728
8000b5c0:	fa c9 ff b4 	sub	r9,sp,-76
8000b5c4:	08 9c       	mov	r12,r4
8000b5c6:	fe b0 fa 91 	rcall	8000aae8 <get_arg>
8000b5ca:	2f dd       	sub	sp,-12
8000b5cc:	78 16       	ld.w	r6,r12[0x4]
8000b5ce:	50 76       	stdsp	sp[0x1c],r6
8000b5d0:	c4 88       	rjmp	8000b660 <_vfprintf_r+0x83c>
8000b5d2:	2f f7       	sub	r7,-1
8000b5d4:	10 39       	cp.w	r9,r8
8000b5d6:	c0 c4       	brge	8000b5ee <_vfprintf_r+0x7ca>
8000b5d8:	fa ce f9 44 	sub	lr,sp,-1724
8000b5dc:	fc 06 00 36 	add	r6,lr,r6<<0x3
8000b5e0:	ec fc fd 8c 	ld.w	r12,r6[-628]
8000b5e4:	50 7c       	stdsp	sp[0x1c],r12
8000b5e6:	ec f6 fd 88 	ld.w	r6,r6[-632]
8000b5ea:	50 56       	stdsp	sp[0x14],r6
8000b5ec:	c6 68       	rjmp	8000b6b8 <_vfprintf_r+0x894>
8000b5ee:	41 09       	lddsp	r9,sp[0x40]
8000b5f0:	59 f8       	cp.w	r8,31
8000b5f2:	e0 89 00 10 	brgt	8000b612 <_vfprintf_r+0x7ee>
8000b5f6:	f2 ca ff f8 	sub	r10,r9,-8
8000b5fa:	72 1b       	ld.w	r11,r9[0x4]
8000b5fc:	51 0a       	stdsp	sp[0x40],r10
8000b5fe:	72 09       	ld.w	r9,r9[0x0]
8000b600:	fa ca f9 44 	sub	r10,sp,-1724
8000b604:	50 7b       	stdsp	sp[0x1c],r11
8000b606:	50 59       	stdsp	sp[0x14],r9
8000b608:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000b60c:	40 5b       	lddsp	r11,sp[0x14]
8000b60e:	40 7a       	lddsp	r10,sp[0x1c]
8000b610:	c4 78       	rjmp	8000b69e <_vfprintf_r+0x87a>
8000b612:	72 18       	ld.w	r8,r9[0x4]
8000b614:	50 78       	stdsp	sp[0x1c],r8
8000b616:	c4 c8       	rjmp	8000b6ae <_vfprintf_r+0x88a>
8000b618:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000b61c:	40 3e       	lddsp	lr,sp[0xc]
8000b61e:	58 0e       	cp.w	lr,0
8000b620:	c2 30       	breq	8000b666 <_vfprintf_r+0x842>
8000b622:	10 36       	cp.w	r6,r8
8000b624:	c0 94       	brge	8000b636 <_vfprintf_r+0x812>
8000b626:	fa cc f9 44 	sub	r12,sp,-1724
8000b62a:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000b62e:	ec fb fd 8c 	ld.w	r11,r6[-628]
8000b632:	50 7b       	stdsp	sp[0x1c],r11
8000b634:	cd 9b       	rjmp	8000b5e6 <_vfprintf_r+0x7c2>
8000b636:	fa c8 f9 50 	sub	r8,sp,-1712
8000b63a:	1a d8       	st.w	--sp,r8
8000b63c:	fa c8 fa b8 	sub	r8,sp,-1352
8000b640:	04 9a       	mov	r10,r2
8000b642:	1a d8       	st.w	--sp,r8
8000b644:	fa c8 fb b4 	sub	r8,sp,-1100
8000b648:	0c 9b       	mov	r11,r6
8000b64a:	1a d8       	st.w	--sp,r8
8000b64c:	08 9c       	mov	r12,r4
8000b64e:	fa c8 f9 40 	sub	r8,sp,-1728
8000b652:	fa c9 ff b4 	sub	r9,sp,-76
8000b656:	fe b0 fa 49 	rcall	8000aae8 <get_arg>
8000b65a:	2f dd       	sub	sp,-12
8000b65c:	78 1a       	ld.w	r10,r12[0x4]
8000b65e:	50 7a       	stdsp	sp[0x1c],r10
8000b660:	78 0c       	ld.w	r12,r12[0x0]
8000b662:	50 5c       	stdsp	sp[0x14],r12
8000b664:	c2 a8       	rjmp	8000b6b8 <_vfprintf_r+0x894>
8000b666:	2f f7       	sub	r7,-1
8000b668:	10 39       	cp.w	r9,r8
8000b66a:	c0 94       	brge	8000b67c <_vfprintf_r+0x858>
8000b66c:	fa c9 f9 44 	sub	r9,sp,-1724
8000b670:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000b674:	ec f8 fd 8c 	ld.w	r8,r6[-628]
8000b678:	50 78       	stdsp	sp[0x1c],r8
8000b67a:	cb 6b       	rjmp	8000b5e6 <_vfprintf_r+0x7c2>
8000b67c:	41 09       	lddsp	r9,sp[0x40]
8000b67e:	59 f8       	cp.w	r8,31
8000b680:	e0 89 00 15 	brgt	8000b6aa <_vfprintf_r+0x886>
8000b684:	f2 ca ff f8 	sub	r10,r9,-8
8000b688:	72 16       	ld.w	r6,r9[0x4]
8000b68a:	72 09       	ld.w	r9,r9[0x0]
8000b68c:	51 0a       	stdsp	sp[0x40],r10
8000b68e:	50 59       	stdsp	sp[0x14],r9
8000b690:	fa ce f9 44 	sub	lr,sp,-1724
8000b694:	50 76       	stdsp	sp[0x1c],r6
8000b696:	fc 08 00 39 	add	r9,lr,r8<<0x3
8000b69a:	40 5b       	lddsp	r11,sp[0x14]
8000b69c:	0c 9a       	mov	r10,r6
8000b69e:	f2 eb fd 88 	st.d	r9[-632],r10
8000b6a2:	2f f8       	sub	r8,-1
8000b6a4:	fb 48 06 b4 	st.w	sp[1716],r8
8000b6a8:	c0 88       	rjmp	8000b6b8 <_vfprintf_r+0x894>
8000b6aa:	72 1c       	ld.w	r12,r9[0x4]
8000b6ac:	50 7c       	stdsp	sp[0x1c],r12
8000b6ae:	f2 c8 ff f8 	sub	r8,r9,-8
8000b6b2:	51 08       	stdsp	sp[0x40],r8
8000b6b4:	72 09       	ld.w	r9,r9[0x0]
8000b6b6:	50 59       	stdsp	sp[0x14],r9
8000b6b8:	40 5b       	lddsp	r11,sp[0x14]
8000b6ba:	40 7a       	lddsp	r10,sp[0x1c]
8000b6bc:	e0 a0 19 64 	rcall	8000e984 <__isinfd>
8000b6c0:	18 96       	mov	r6,r12
8000b6c2:	c1 50       	breq	8000b6ec <_vfprintf_r+0x8c8>
8000b6c4:	30 08       	mov	r8,0
8000b6c6:	30 09       	mov	r9,0
8000b6c8:	40 5b       	lddsp	r11,sp[0x14]
8000b6ca:	40 7a       	lddsp	r10,sp[0x1c]
8000b6cc:	e0 a0 1d ba 	rcall	8000f240 <__avr32_f64_cmp_lt>
8000b6d0:	c0 40       	breq	8000b6d8 <_vfprintf_r+0x8b4>
8000b6d2:	32 d8       	mov	r8,45
8000b6d4:	fb 68 06 bb 	st.b	sp[1723],r8
8000b6d8:	4d 18       	lddpc	r8,8000b81c <_vfprintf_r+0x9f8>
8000b6da:	4d 26       	lddpc	r6,8000b820 <_vfprintf_r+0x9fc>
8000b6dc:	a7 d5       	cbr	r5,0x7
8000b6de:	e0 40 00 47 	cp.w	r0,71
8000b6e2:	f0 06 17 a0 	movle	r6,r8
8000b6e6:	30 32       	mov	r2,3
8000b6e8:	e0 8f 06 d4 	bral	8000c490 <_vfprintf_r+0x166c>
8000b6ec:	40 5b       	lddsp	r11,sp[0x14]
8000b6ee:	40 7a       	lddsp	r10,sp[0x1c]
8000b6f0:	e0 a0 19 5f 	rcall	8000e9ae <__isnand>
8000b6f4:	c0 c0       	breq	8000b70c <_vfprintf_r+0x8e8>
8000b6f6:	50 26       	stdsp	sp[0x8],r6
8000b6f8:	4c b8       	lddpc	r8,8000b824 <_vfprintf_r+0xa00>
8000b6fa:	4c c6       	lddpc	r6,8000b828 <_vfprintf_r+0xa04>
8000b6fc:	a7 d5       	cbr	r5,0x7
8000b6fe:	e0 40 00 47 	cp.w	r0,71
8000b702:	f0 06 17 a0 	movle	r6,r8
8000b706:	30 32       	mov	r2,3
8000b708:	e0 8f 06 ca 	bral	8000c49c <_vfprintf_r+0x1678>
8000b70c:	40 2a       	lddsp	r10,sp[0x8]
8000b70e:	5b fa       	cp.w	r10,-1
8000b710:	c0 41       	brne	8000b718 <_vfprintf_r+0x8f4>
8000b712:	30 69       	mov	r9,6
8000b714:	50 29       	stdsp	sp[0x8],r9
8000b716:	c1 18       	rjmp	8000b738 <_vfprintf_r+0x914>
8000b718:	e0 40 00 47 	cp.w	r0,71
8000b71c:	5f 09       	sreq	r9
8000b71e:	e0 40 00 67 	cp.w	r0,103
8000b722:	5f 08       	sreq	r8
8000b724:	f3 e8 10 08 	or	r8,r9,r8
8000b728:	f8 08 18 00 	cp.b	r8,r12
8000b72c:	c0 60       	breq	8000b738 <_vfprintf_r+0x914>
8000b72e:	40 28       	lddsp	r8,sp[0x8]
8000b730:	58 08       	cp.w	r8,0
8000b732:	f9 b8 00 01 	moveq	r8,1
8000b736:	50 28       	stdsp	sp[0x8],r8
8000b738:	40 78       	lddsp	r8,sp[0x1c]
8000b73a:	40 59       	lddsp	r9,sp[0x14]
8000b73c:	fa e9 06 94 	st.d	sp[1684],r8
8000b740:	a9 a5       	sbr	r5,0x8
8000b742:	fa f8 06 94 	ld.w	r8,sp[1684]
8000b746:	58 08       	cp.w	r8,0
8000b748:	c0 65       	brlt	8000b754 <_vfprintf_r+0x930>
8000b74a:	40 5e       	lddsp	lr,sp[0x14]
8000b74c:	30 0c       	mov	r12,0
8000b74e:	50 6e       	stdsp	sp[0x18],lr
8000b750:	50 9c       	stdsp	sp[0x24],r12
8000b752:	c0 78       	rjmp	8000b760 <_vfprintf_r+0x93c>
8000b754:	40 5b       	lddsp	r11,sp[0x14]
8000b756:	32 da       	mov	r10,45
8000b758:	ee 1b 80 00 	eorh	r11,0x8000
8000b75c:	50 9a       	stdsp	sp[0x24],r10
8000b75e:	50 6b       	stdsp	sp[0x18],r11
8000b760:	e0 40 00 46 	cp.w	r0,70
8000b764:	5f 09       	sreq	r9
8000b766:	e0 40 00 66 	cp.w	r0,102
8000b76a:	5f 08       	sreq	r8
8000b76c:	f3 e8 10 08 	or	r8,r9,r8
8000b770:	50 48       	stdsp	sp[0x10],r8
8000b772:	c0 40       	breq	8000b77a <_vfprintf_r+0x956>
8000b774:	40 22       	lddsp	r2,sp[0x8]
8000b776:	30 39       	mov	r9,3
8000b778:	c1 08       	rjmp	8000b798 <_vfprintf_r+0x974>
8000b77a:	e0 40 00 45 	cp.w	r0,69
8000b77e:	5f 09       	sreq	r9
8000b780:	e0 40 00 65 	cp.w	r0,101
8000b784:	5f 08       	sreq	r8
8000b786:	40 22       	lddsp	r2,sp[0x8]
8000b788:	10 49       	or	r9,r8
8000b78a:	2f f2       	sub	r2,-1
8000b78c:	40 46       	lddsp	r6,sp[0x10]
8000b78e:	ec 09 18 00 	cp.b	r9,r6
8000b792:	fb f2 00 02 	ld.weq	r2,sp[0x8]
8000b796:	30 29       	mov	r9,2
8000b798:	fa c8 f9 5c 	sub	r8,sp,-1700
8000b79c:	1a d8       	st.w	--sp,r8
8000b79e:	fa c8 f9 54 	sub	r8,sp,-1708
8000b7a2:	1a d8       	st.w	--sp,r8
8000b7a4:	fa c8 f9 4c 	sub	r8,sp,-1716
8000b7a8:	08 9c       	mov	r12,r4
8000b7aa:	1a d8       	st.w	--sp,r8
8000b7ac:	04 98       	mov	r8,r2
8000b7ae:	40 9b       	lddsp	r11,sp[0x24]
8000b7b0:	40 aa       	lddsp	r10,sp[0x28]
8000b7b2:	e0 a0 0b cf 	rcall	8000cf50 <_dtoa_r>
8000b7b6:	e0 40 00 47 	cp.w	r0,71
8000b7ba:	5f 19       	srne	r9
8000b7bc:	e0 40 00 67 	cp.w	r0,103
8000b7c0:	5f 18       	srne	r8
8000b7c2:	18 96       	mov	r6,r12
8000b7c4:	2f dd       	sub	sp,-12
8000b7c6:	f3 e8 00 08 	and	r8,r9,r8
8000b7ca:	c0 41       	brne	8000b7d2 <_vfprintf_r+0x9ae>
8000b7cc:	ed b5 00 00 	bld	r5,0x0
8000b7d0:	c3 81       	brne	8000b840 <_vfprintf_r+0xa1c>
8000b7d2:	ec 02 00 0e 	add	lr,r6,r2
8000b7d6:	50 3e       	stdsp	sp[0xc],lr
8000b7d8:	40 4c       	lddsp	r12,sp[0x10]
8000b7da:	58 0c       	cp.w	r12,0
8000b7dc:	c1 50       	breq	8000b806 <_vfprintf_r+0x9e2>
8000b7de:	0d 89       	ld.ub	r9,r6[0x0]
8000b7e0:	33 08       	mov	r8,48
8000b7e2:	f0 09 18 00 	cp.b	r9,r8
8000b7e6:	c0 b1       	brne	8000b7fc <_vfprintf_r+0x9d8>
8000b7e8:	30 08       	mov	r8,0
8000b7ea:	30 09       	mov	r9,0
8000b7ec:	40 6b       	lddsp	r11,sp[0x18]
8000b7ee:	40 7a       	lddsp	r10,sp[0x1c]
8000b7f0:	e0 a0 1c e1 	rcall	8000f1b2 <__avr32_f64_cmp_eq>
8000b7f4:	fb b2 00 01 	rsubeq	r2,1
8000b7f8:	fb f2 0b ab 	st.weq	sp[0x6ac],r2
8000b7fc:	40 3b       	lddsp	r11,sp[0xc]
8000b7fe:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000b802:	10 0b       	add	r11,r8
8000b804:	50 3b       	stdsp	sp[0xc],r11
8000b806:	40 6b       	lddsp	r11,sp[0x18]
8000b808:	30 08       	mov	r8,0
8000b80a:	30 09       	mov	r9,0
8000b80c:	40 7a       	lddsp	r10,sp[0x1c]
8000b80e:	e0 a0 1c d2 	rcall	8000f1b2 <__avr32_f64_cmp_eq>
8000b812:	c1 10       	breq	8000b834 <_vfprintf_r+0xa10>
8000b814:	40 3a       	lddsp	r10,sp[0xc]
8000b816:	fb 4a 06 a4 	st.w	sp[1700],r10
8000b81a:	c0 d8       	rjmp	8000b834 <_vfprintf_r+0xa10>
8000b81c:	80 01       	ld.sh	r1,r0[0x0]
8000b81e:	91 78       	st.w	r8[0x1c],r8
8000b820:	80 01       	ld.sh	r1,r0[0x0]
8000b822:	91 7c       	st.w	r8[0x1c],r12
8000b824:	80 01       	ld.sh	r1,r0[0x0]
8000b826:	91 80       	st.w	r8[0x20],r0
8000b828:	80 01       	ld.sh	r1,r0[0x0]
8000b82a:	91 84       	st.w	r8[0x20],r4
8000b82c:	10 c9       	st.b	r8++,r9
8000b82e:	fb 48 06 a4 	st.w	sp[1700],r8
8000b832:	c0 28       	rjmp	8000b836 <_vfprintf_r+0xa12>
8000b834:	33 09       	mov	r9,48
8000b836:	fa f8 06 a4 	ld.w	r8,sp[1700]
8000b83a:	40 3e       	lddsp	lr,sp[0xc]
8000b83c:	1c 38       	cp.w	r8,lr
8000b83e:	cf 73       	brcs	8000b82c <_vfprintf_r+0xa08>
8000b840:	e0 40 00 47 	cp.w	r0,71
8000b844:	5f 09       	sreq	r9
8000b846:	e0 40 00 67 	cp.w	r0,103
8000b84a:	5f 08       	sreq	r8
8000b84c:	f3 e8 10 08 	or	r8,r9,r8
8000b850:	fa f9 06 a4 	ld.w	r9,sp[1700]
8000b854:	0c 19       	sub	r9,r6
8000b856:	50 69       	stdsp	sp[0x18],r9
8000b858:	58 08       	cp.w	r8,0
8000b85a:	c0 b0       	breq	8000b870 <_vfprintf_r+0xa4c>
8000b85c:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000b860:	5b d8       	cp.w	r8,-3
8000b862:	c0 55       	brlt	8000b86c <_vfprintf_r+0xa48>
8000b864:	40 2c       	lddsp	r12,sp[0x8]
8000b866:	18 38       	cp.w	r8,r12
8000b868:	e0 8a 00 6a 	brle	8000b93c <_vfprintf_r+0xb18>
8000b86c:	20 20       	sub	r0,2
8000b86e:	c0 58       	rjmp	8000b878 <_vfprintf_r+0xa54>
8000b870:	e0 40 00 65 	cp.w	r0,101
8000b874:	e0 89 00 46 	brgt	8000b900 <_vfprintf_r+0xadc>
8000b878:	fa fb 06 ac 	ld.w	r11,sp[1708]
8000b87c:	fb 60 06 9c 	st.b	sp[1692],r0
8000b880:	20 1b       	sub	r11,1
8000b882:	fb 4b 06 ac 	st.w	sp[1708],r11
8000b886:	c0 47       	brpl	8000b88e <_vfprintf_r+0xa6a>
8000b888:	5c 3b       	neg	r11
8000b88a:	32 d8       	mov	r8,45
8000b88c:	c0 28       	rjmp	8000b890 <_vfprintf_r+0xa6c>
8000b88e:	32 b8       	mov	r8,43
8000b890:	fb 68 06 9d 	st.b	sp[1693],r8
8000b894:	58 9b       	cp.w	r11,9
8000b896:	e0 8a 00 1d 	brle	8000b8d0 <_vfprintf_r+0xaac>
8000b89a:	fa c9 fa 35 	sub	r9,sp,-1483
8000b89e:	30 aa       	mov	r10,10
8000b8a0:	12 98       	mov	r8,r9
8000b8a2:	0e 9c       	mov	r12,r7
8000b8a4:	0c 92       	mov	r2,r6
8000b8a6:	f6 0a 0c 06 	divs	r6,r11,r10
8000b8aa:	0e 9b       	mov	r11,r7
8000b8ac:	2d 0b       	sub	r11,-48
8000b8ae:	10 fb       	st.b	--r8,r11
8000b8b0:	0c 9b       	mov	r11,r6
8000b8b2:	58 96       	cp.w	r6,9
8000b8b4:	fe 99 ff f9 	brgt	8000b8a6 <_vfprintf_r+0xa82>
8000b8b8:	2d 0b       	sub	r11,-48
8000b8ba:	18 97       	mov	r7,r12
8000b8bc:	04 96       	mov	r6,r2
8000b8be:	10 fb       	st.b	--r8,r11
8000b8c0:	fa ca f9 62 	sub	r10,sp,-1694
8000b8c4:	c0 38       	rjmp	8000b8ca <_vfprintf_r+0xaa6>
8000b8c6:	11 3b       	ld.ub	r11,r8++
8000b8c8:	14 cb       	st.b	r10++,r11
8000b8ca:	12 38       	cp.w	r8,r9
8000b8cc:	cf d3       	brcs	8000b8c6 <_vfprintf_r+0xaa2>
8000b8ce:	c0 98       	rjmp	8000b8e0 <_vfprintf_r+0xabc>
8000b8d0:	2d 0b       	sub	r11,-48
8000b8d2:	33 08       	mov	r8,48
8000b8d4:	fb 6b 06 9f 	st.b	sp[1695],r11
8000b8d8:	fb 68 06 9e 	st.b	sp[1694],r8
8000b8dc:	fa ca f9 60 	sub	r10,sp,-1696
8000b8e0:	fa c8 f9 64 	sub	r8,sp,-1692
8000b8e4:	f4 08 01 08 	sub	r8,r10,r8
8000b8e8:	50 e8       	stdsp	sp[0x38],r8
8000b8ea:	10 92       	mov	r2,r8
8000b8ec:	40 6b       	lddsp	r11,sp[0x18]
8000b8ee:	16 02       	add	r2,r11
8000b8f0:	58 1b       	cp.w	r11,1
8000b8f2:	e0 89 00 05 	brgt	8000b8fc <_vfprintf_r+0xad8>
8000b8f6:	ed b5 00 00 	bld	r5,0x0
8000b8fa:	c3 51       	brne	8000b964 <_vfprintf_r+0xb40>
8000b8fc:	2f f2       	sub	r2,-1
8000b8fe:	c3 38       	rjmp	8000b964 <_vfprintf_r+0xb40>
8000b900:	e0 40 00 66 	cp.w	r0,102
8000b904:	c1 c1       	brne	8000b93c <_vfprintf_r+0xb18>
8000b906:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000b90a:	58 02       	cp.w	r2,0
8000b90c:	e0 8a 00 0c 	brle	8000b924 <_vfprintf_r+0xb00>
8000b910:	40 2a       	lddsp	r10,sp[0x8]
8000b912:	58 0a       	cp.w	r10,0
8000b914:	c0 41       	brne	8000b91c <_vfprintf_r+0xaf8>
8000b916:	ed b5 00 00 	bld	r5,0x0
8000b91a:	c2 51       	brne	8000b964 <_vfprintf_r+0xb40>
8000b91c:	2f f2       	sub	r2,-1
8000b91e:	40 29       	lddsp	r9,sp[0x8]
8000b920:	12 02       	add	r2,r9
8000b922:	c0 b8       	rjmp	8000b938 <_vfprintf_r+0xb14>
8000b924:	40 28       	lddsp	r8,sp[0x8]
8000b926:	58 08       	cp.w	r8,0
8000b928:	c0 61       	brne	8000b934 <_vfprintf_r+0xb10>
8000b92a:	ed b5 00 00 	bld	r5,0x0
8000b92e:	c0 30       	breq	8000b934 <_vfprintf_r+0xb10>
8000b930:	30 12       	mov	r2,1
8000b932:	c1 98       	rjmp	8000b964 <_vfprintf_r+0xb40>
8000b934:	40 22       	lddsp	r2,sp[0x8]
8000b936:	2f e2       	sub	r2,-2
8000b938:	36 60       	mov	r0,102
8000b93a:	c1 58       	rjmp	8000b964 <_vfprintf_r+0xb40>
8000b93c:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000b940:	40 6e       	lddsp	lr,sp[0x18]
8000b942:	1c 32       	cp.w	r2,lr
8000b944:	c0 65       	brlt	8000b950 <_vfprintf_r+0xb2c>
8000b946:	ed b5 00 00 	bld	r5,0x0
8000b94a:	f7 b2 00 ff 	subeq	r2,-1
8000b94e:	c0 a8       	rjmp	8000b962 <_vfprintf_r+0xb3e>
8000b950:	e4 08 11 02 	rsub	r8,r2,2
8000b954:	40 6c       	lddsp	r12,sp[0x18]
8000b956:	58 02       	cp.w	r2,0
8000b958:	f0 02 17 a0 	movle	r2,r8
8000b95c:	f9 b2 09 01 	movgt	r2,1
8000b960:	18 02       	add	r2,r12
8000b962:	36 70       	mov	r0,103
8000b964:	40 9b       	lddsp	r11,sp[0x24]
8000b966:	58 0b       	cp.w	r11,0
8000b968:	e0 80 05 94 	breq	8000c490 <_vfprintf_r+0x166c>
8000b96c:	32 d8       	mov	r8,45
8000b96e:	fb 68 06 bb 	st.b	sp[1723],r8
8000b972:	e0 8f 05 93 	bral	8000c498 <_vfprintf_r+0x1674>
8000b976:	50 a7       	stdsp	sp[0x28],r7
8000b978:	04 94       	mov	r4,r2
8000b97a:	0c 97       	mov	r7,r6
8000b97c:	02 92       	mov	r2,r1
8000b97e:	06 96       	mov	r6,r3
8000b980:	40 41       	lddsp	r1,sp[0x10]
8000b982:	40 93       	lddsp	r3,sp[0x24]
8000b984:	0e 99       	mov	r9,r7
8000b986:	ed b5 00 05 	bld	r5,0x5
8000b98a:	c4 81       	brne	8000ba1a <_vfprintf_r+0xbf6>
8000b98c:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000b990:	40 3e       	lddsp	lr,sp[0xc]
8000b992:	58 0e       	cp.w	lr,0
8000b994:	c1 d0       	breq	8000b9ce <_vfprintf_r+0xbaa>
8000b996:	10 36       	cp.w	r6,r8
8000b998:	c0 64       	brge	8000b9a4 <_vfprintf_r+0xb80>
8000b99a:	fa cc f9 44 	sub	r12,sp,-1724
8000b99e:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000b9a2:	c1 d8       	rjmp	8000b9dc <_vfprintf_r+0xbb8>
8000b9a4:	fa c8 f9 50 	sub	r8,sp,-1712
8000b9a8:	1a d8       	st.w	--sp,r8
8000b9aa:	fa c8 fa b8 	sub	r8,sp,-1352
8000b9ae:	04 9a       	mov	r10,r2
8000b9b0:	1a d8       	st.w	--sp,r8
8000b9b2:	fa c8 fb b4 	sub	r8,sp,-1100
8000b9b6:	0c 9b       	mov	r11,r6
8000b9b8:	1a d8       	st.w	--sp,r8
8000b9ba:	08 9c       	mov	r12,r4
8000b9bc:	fa c8 f9 40 	sub	r8,sp,-1728
8000b9c0:	fa c9 ff b4 	sub	r9,sp,-76
8000b9c4:	fe b0 f8 92 	rcall	8000aae8 <get_arg>
8000b9c8:	2f dd       	sub	sp,-12
8000b9ca:	78 0a       	ld.w	r10,r12[0x0]
8000b9cc:	c2 08       	rjmp	8000ba0c <_vfprintf_r+0xbe8>
8000b9ce:	2f f7       	sub	r7,-1
8000b9d0:	10 39       	cp.w	r9,r8
8000b9d2:	c0 84       	brge	8000b9e2 <_vfprintf_r+0xbbe>
8000b9d4:	fa cb f9 44 	sub	r11,sp,-1724
8000b9d8:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000b9dc:	ec fa fd 88 	ld.w	r10,r6[-632]
8000b9e0:	c1 68       	rjmp	8000ba0c <_vfprintf_r+0xbe8>
8000b9e2:	41 09       	lddsp	r9,sp[0x40]
8000b9e4:	59 f8       	cp.w	r8,31
8000b9e6:	e0 89 00 10 	brgt	8000ba06 <_vfprintf_r+0xbe2>
8000b9ea:	f2 ca ff fc 	sub	r10,r9,-4
8000b9ee:	51 0a       	stdsp	sp[0x40],r10
8000b9f0:	fa c6 f9 44 	sub	r6,sp,-1724
8000b9f4:	72 0a       	ld.w	r10,r9[0x0]
8000b9f6:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000b9fa:	f3 4a fd 88 	st.w	r9[-632],r10
8000b9fe:	2f f8       	sub	r8,-1
8000ba00:	fb 48 06 b4 	st.w	sp[1716],r8
8000ba04:	c0 48       	rjmp	8000ba0c <_vfprintf_r+0xbe8>
8000ba06:	72 0a       	ld.w	r10,r9[0x0]
8000ba08:	2f c9       	sub	r9,-4
8000ba0a:	51 09       	stdsp	sp[0x40],r9
8000ba0c:	40 be       	lddsp	lr,sp[0x2c]
8000ba0e:	1c 98       	mov	r8,lr
8000ba10:	95 1e       	st.w	r10[0x4],lr
8000ba12:	bf 58       	asr	r8,0x1f
8000ba14:	95 08       	st.w	r10[0x0],r8
8000ba16:	fe 9f fa 92 	bral	8000af3a <_vfprintf_r+0x116>
8000ba1a:	ed b5 00 04 	bld	r5,0x4
8000ba1e:	c4 80       	breq	8000baae <_vfprintf_r+0xc8a>
8000ba20:	e2 15 00 40 	andl	r5,0x40,COH
8000ba24:	c4 50       	breq	8000baae <_vfprintf_r+0xc8a>
8000ba26:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000ba2a:	40 3c       	lddsp	r12,sp[0xc]
8000ba2c:	58 0c       	cp.w	r12,0
8000ba2e:	c1 d0       	breq	8000ba68 <_vfprintf_r+0xc44>
8000ba30:	10 36       	cp.w	r6,r8
8000ba32:	c0 64       	brge	8000ba3e <_vfprintf_r+0xc1a>
8000ba34:	fa cb f9 44 	sub	r11,sp,-1724
8000ba38:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000ba3c:	c1 d8       	rjmp	8000ba76 <_vfprintf_r+0xc52>
8000ba3e:	fa c8 f9 50 	sub	r8,sp,-1712
8000ba42:	1a d8       	st.w	--sp,r8
8000ba44:	fa c8 fa b8 	sub	r8,sp,-1352
8000ba48:	04 9a       	mov	r10,r2
8000ba4a:	1a d8       	st.w	--sp,r8
8000ba4c:	fa c8 fb b4 	sub	r8,sp,-1100
8000ba50:	0c 9b       	mov	r11,r6
8000ba52:	1a d8       	st.w	--sp,r8
8000ba54:	08 9c       	mov	r12,r4
8000ba56:	fa c8 f9 40 	sub	r8,sp,-1728
8000ba5a:	fa c9 ff b4 	sub	r9,sp,-76
8000ba5e:	fe b0 f8 45 	rcall	8000aae8 <get_arg>
8000ba62:	2f dd       	sub	sp,-12
8000ba64:	78 0a       	ld.w	r10,r12[0x0]
8000ba66:	c2 08       	rjmp	8000baa6 <_vfprintf_r+0xc82>
8000ba68:	2f f7       	sub	r7,-1
8000ba6a:	10 39       	cp.w	r9,r8
8000ba6c:	c0 84       	brge	8000ba7c <_vfprintf_r+0xc58>
8000ba6e:	fa ca f9 44 	sub	r10,sp,-1724
8000ba72:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000ba76:	ec fa fd 88 	ld.w	r10,r6[-632]
8000ba7a:	c1 68       	rjmp	8000baa6 <_vfprintf_r+0xc82>
8000ba7c:	41 09       	lddsp	r9,sp[0x40]
8000ba7e:	59 f8       	cp.w	r8,31
8000ba80:	e0 89 00 10 	brgt	8000baa0 <_vfprintf_r+0xc7c>
8000ba84:	f2 ca ff fc 	sub	r10,r9,-4
8000ba88:	51 0a       	stdsp	sp[0x40],r10
8000ba8a:	fa c6 f9 44 	sub	r6,sp,-1724
8000ba8e:	72 0a       	ld.w	r10,r9[0x0]
8000ba90:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000ba94:	f3 4a fd 88 	st.w	r9[-632],r10
8000ba98:	2f f8       	sub	r8,-1
8000ba9a:	fb 48 06 b4 	st.w	sp[1716],r8
8000ba9e:	c0 48       	rjmp	8000baa6 <_vfprintf_r+0xc82>
8000baa0:	72 0a       	ld.w	r10,r9[0x0]
8000baa2:	2f c9       	sub	r9,-4
8000baa4:	51 09       	stdsp	sp[0x40],r9
8000baa6:	40 be       	lddsp	lr,sp[0x2c]
8000baa8:	b4 0e       	st.h	r10[0x0],lr
8000baaa:	fe 9f fa 48 	bral	8000af3a <_vfprintf_r+0x116>
8000baae:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000bab2:	40 3c       	lddsp	r12,sp[0xc]
8000bab4:	58 0c       	cp.w	r12,0
8000bab6:	c1 d0       	breq	8000baf0 <_vfprintf_r+0xccc>
8000bab8:	10 36       	cp.w	r6,r8
8000baba:	c0 64       	brge	8000bac6 <_vfprintf_r+0xca2>
8000babc:	fa cb f9 44 	sub	r11,sp,-1724
8000bac0:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000bac4:	c1 d8       	rjmp	8000bafe <_vfprintf_r+0xcda>
8000bac6:	fa c8 f9 50 	sub	r8,sp,-1712
8000baca:	1a d8       	st.w	--sp,r8
8000bacc:	fa c8 fa b8 	sub	r8,sp,-1352
8000bad0:	04 9a       	mov	r10,r2
8000bad2:	1a d8       	st.w	--sp,r8
8000bad4:	fa c8 fb b4 	sub	r8,sp,-1100
8000bad8:	0c 9b       	mov	r11,r6
8000bada:	1a d8       	st.w	--sp,r8
8000badc:	08 9c       	mov	r12,r4
8000bade:	fa c8 f9 40 	sub	r8,sp,-1728
8000bae2:	fa c9 ff b4 	sub	r9,sp,-76
8000bae6:	fe b0 f8 01 	rcall	8000aae8 <get_arg>
8000baea:	2f dd       	sub	sp,-12
8000baec:	78 0a       	ld.w	r10,r12[0x0]
8000baee:	c2 08       	rjmp	8000bb2e <_vfprintf_r+0xd0a>
8000baf0:	2f f7       	sub	r7,-1
8000baf2:	10 39       	cp.w	r9,r8
8000baf4:	c0 84       	brge	8000bb04 <_vfprintf_r+0xce0>
8000baf6:	fa ca f9 44 	sub	r10,sp,-1724
8000bafa:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000bafe:	ec fa fd 88 	ld.w	r10,r6[-632]
8000bb02:	c1 68       	rjmp	8000bb2e <_vfprintf_r+0xd0a>
8000bb04:	41 09       	lddsp	r9,sp[0x40]
8000bb06:	59 f8       	cp.w	r8,31
8000bb08:	e0 89 00 10 	brgt	8000bb28 <_vfprintf_r+0xd04>
8000bb0c:	f2 ca ff fc 	sub	r10,r9,-4
8000bb10:	51 0a       	stdsp	sp[0x40],r10
8000bb12:	fa c6 f9 44 	sub	r6,sp,-1724
8000bb16:	72 0a       	ld.w	r10,r9[0x0]
8000bb18:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000bb1c:	f3 4a fd 88 	st.w	r9[-632],r10
8000bb20:	2f f8       	sub	r8,-1
8000bb22:	fb 48 06 b4 	st.w	sp[1716],r8
8000bb26:	c0 48       	rjmp	8000bb2e <_vfprintf_r+0xd0a>
8000bb28:	72 0a       	ld.w	r10,r9[0x0]
8000bb2a:	2f c9       	sub	r9,-4
8000bb2c:	51 09       	stdsp	sp[0x40],r9
8000bb2e:	40 be       	lddsp	lr,sp[0x2c]
8000bb30:	95 0e       	st.w	r10[0x0],lr
8000bb32:	fe 9f fa 04 	bral	8000af3a <_vfprintf_r+0x116>
8000bb36:	50 a7       	stdsp	sp[0x28],r7
8000bb38:	50 80       	stdsp	sp[0x20],r0
8000bb3a:	0c 97       	mov	r7,r6
8000bb3c:	04 94       	mov	r4,r2
8000bb3e:	06 96       	mov	r6,r3
8000bb40:	02 92       	mov	r2,r1
8000bb42:	40 93       	lddsp	r3,sp[0x24]
8000bb44:	10 90       	mov	r0,r8
8000bb46:	40 41       	lddsp	r1,sp[0x10]
8000bb48:	a5 a5       	sbr	r5,0x4
8000bb4a:	c0 a8       	rjmp	8000bb5e <_vfprintf_r+0xd3a>
8000bb4c:	50 a7       	stdsp	sp[0x28],r7
8000bb4e:	50 80       	stdsp	sp[0x20],r0
8000bb50:	0c 97       	mov	r7,r6
8000bb52:	04 94       	mov	r4,r2
8000bb54:	06 96       	mov	r6,r3
8000bb56:	02 92       	mov	r2,r1
8000bb58:	40 93       	lddsp	r3,sp[0x24]
8000bb5a:	10 90       	mov	r0,r8
8000bb5c:	40 41       	lddsp	r1,sp[0x10]
8000bb5e:	ed b5 00 05 	bld	r5,0x5
8000bb62:	c5 d1       	brne	8000bc1c <_vfprintf_r+0xdf8>
8000bb64:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000bb68:	40 3c       	lddsp	r12,sp[0xc]
8000bb6a:	58 0c       	cp.w	r12,0
8000bb6c:	c2 60       	breq	8000bbb8 <_vfprintf_r+0xd94>
8000bb6e:	10 36       	cp.w	r6,r8
8000bb70:	c0 a4       	brge	8000bb84 <_vfprintf_r+0xd60>
8000bb72:	fa cb f9 44 	sub	r11,sp,-1724
8000bb76:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000bb7a:	ec e8 fd 88 	ld.d	r8,r6[-632]
8000bb7e:	fa e9 00 00 	st.d	sp[0],r8
8000bb82:	c1 88       	rjmp	8000bbb2 <_vfprintf_r+0xd8e>
8000bb84:	fa c8 f9 50 	sub	r8,sp,-1712
8000bb88:	1a d8       	st.w	--sp,r8
8000bb8a:	fa c8 fa b8 	sub	r8,sp,-1352
8000bb8e:	04 9a       	mov	r10,r2
8000bb90:	1a d8       	st.w	--sp,r8
8000bb92:	0c 9b       	mov	r11,r6
8000bb94:	fa c8 fb b4 	sub	r8,sp,-1100
8000bb98:	08 9c       	mov	r12,r4
8000bb9a:	1a d8       	st.w	--sp,r8
8000bb9c:	fa c8 f9 40 	sub	r8,sp,-1728
8000bba0:	fa c9 ff b4 	sub	r9,sp,-76
8000bba4:	fe b0 f7 a2 	rcall	8000aae8 <get_arg>
8000bba8:	2f dd       	sub	sp,-12
8000bbaa:	f8 ea 00 00 	ld.d	r10,r12[0]
8000bbae:	fa eb 00 00 	st.d	sp[0],r10
8000bbb2:	30 08       	mov	r8,0
8000bbb4:	e0 8f 03 de 	bral	8000c370 <_vfprintf_r+0x154c>
8000bbb8:	ee ca ff ff 	sub	r10,r7,-1
8000bbbc:	10 37       	cp.w	r7,r8
8000bbbe:	c0 b4       	brge	8000bbd4 <_vfprintf_r+0xdb0>
8000bbc0:	fa c9 f9 44 	sub	r9,sp,-1724
8000bbc4:	14 97       	mov	r7,r10
8000bbc6:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000bbca:	ec ea fd 88 	ld.d	r10,r6[-632]
8000bbce:	fa eb 00 00 	st.d	sp[0],r10
8000bbd2:	c1 88       	rjmp	8000bc02 <_vfprintf_r+0xdde>
8000bbd4:	41 09       	lddsp	r9,sp[0x40]
8000bbd6:	59 f8       	cp.w	r8,31
8000bbd8:	e0 89 00 18 	brgt	8000bc08 <_vfprintf_r+0xde4>
8000bbdc:	f2 e6 00 00 	ld.d	r6,r9[0]
8000bbe0:	f2 cb ff f8 	sub	r11,r9,-8
8000bbe4:	fa e7 00 00 	st.d	sp[0],r6
8000bbe8:	51 0b       	stdsp	sp[0x40],r11
8000bbea:	fa c6 f9 44 	sub	r6,sp,-1724
8000bbee:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000bbf2:	fa e6 00 00 	ld.d	r6,sp[0]
8000bbf6:	f2 e7 fd 88 	st.d	r9[-632],r6
8000bbfa:	2f f8       	sub	r8,-1
8000bbfc:	14 97       	mov	r7,r10
8000bbfe:	fb 48 06 b4 	st.w	sp[1716],r8
8000bc02:	40 38       	lddsp	r8,sp[0xc]
8000bc04:	e0 8f 03 b6 	bral	8000c370 <_vfprintf_r+0x154c>
8000bc08:	f2 e6 00 00 	ld.d	r6,r9[0]
8000bc0c:	40 38       	lddsp	r8,sp[0xc]
8000bc0e:	fa e7 00 00 	st.d	sp[0],r6
8000bc12:	2f 89       	sub	r9,-8
8000bc14:	14 97       	mov	r7,r10
8000bc16:	51 09       	stdsp	sp[0x40],r9
8000bc18:	e0 8f 03 ac 	bral	8000c370 <_vfprintf_r+0x154c>
8000bc1c:	ed b5 00 04 	bld	r5,0x4
8000bc20:	c1 61       	brne	8000bc4c <_vfprintf_r+0xe28>
8000bc22:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000bc26:	40 3e       	lddsp	lr,sp[0xc]
8000bc28:	58 0e       	cp.w	lr,0
8000bc2a:	c0 80       	breq	8000bc3a <_vfprintf_r+0xe16>
8000bc2c:	10 36       	cp.w	r6,r8
8000bc2e:	c6 74       	brge	8000bcfc <_vfprintf_r+0xed8>
8000bc30:	fa cc f9 44 	sub	r12,sp,-1724
8000bc34:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000bc38:	c8 08       	rjmp	8000bd38 <_vfprintf_r+0xf14>
8000bc3a:	ee ca ff ff 	sub	r10,r7,-1
8000bc3e:	10 37       	cp.w	r7,r8
8000bc40:	c7 f4       	brge	8000bd3e <_vfprintf_r+0xf1a>
8000bc42:	fa cb f9 44 	sub	r11,sp,-1724
8000bc46:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000bc4a:	c7 68       	rjmp	8000bd36 <_vfprintf_r+0xf12>
8000bc4c:	ed b5 00 06 	bld	r5,0x6
8000bc50:	c4 a1       	brne	8000bce4 <_vfprintf_r+0xec0>
8000bc52:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000bc56:	40 3c       	lddsp	r12,sp[0xc]
8000bc58:	58 0c       	cp.w	r12,0
8000bc5a:	c1 d0       	breq	8000bc94 <_vfprintf_r+0xe70>
8000bc5c:	10 36       	cp.w	r6,r8
8000bc5e:	c0 64       	brge	8000bc6a <_vfprintf_r+0xe46>
8000bc60:	fa cb f9 44 	sub	r11,sp,-1724
8000bc64:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000bc68:	c1 f8       	rjmp	8000bca6 <_vfprintf_r+0xe82>
8000bc6a:	fa c8 f9 50 	sub	r8,sp,-1712
8000bc6e:	1a d8       	st.w	--sp,r8
8000bc70:	fa c8 fa b8 	sub	r8,sp,-1352
8000bc74:	1a d8       	st.w	--sp,r8
8000bc76:	fa c8 fb b4 	sub	r8,sp,-1100
8000bc7a:	1a d8       	st.w	--sp,r8
8000bc7c:	fa c8 f9 40 	sub	r8,sp,-1728
8000bc80:	fa c9 ff b4 	sub	r9,sp,-76
8000bc84:	04 9a       	mov	r10,r2
8000bc86:	0c 9b       	mov	r11,r6
8000bc88:	08 9c       	mov	r12,r4
8000bc8a:	fe b0 f7 2f 	rcall	8000aae8 <get_arg>
8000bc8e:	2f dd       	sub	sp,-12
8000bc90:	98 18       	ld.sh	r8,r12[0x2]
8000bc92:	c2 68       	rjmp	8000bcde <_vfprintf_r+0xeba>
8000bc94:	ee ca ff ff 	sub	r10,r7,-1
8000bc98:	10 37       	cp.w	r7,r8
8000bc9a:	c0 94       	brge	8000bcac <_vfprintf_r+0xe88>
8000bc9c:	fa c9 f9 44 	sub	r9,sp,-1724
8000bca0:	14 97       	mov	r7,r10
8000bca2:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000bca6:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000bcaa:	c1 a8       	rjmp	8000bcde <_vfprintf_r+0xeba>
8000bcac:	41 09       	lddsp	r9,sp[0x40]
8000bcae:	59 f8       	cp.w	r8,31
8000bcb0:	e0 89 00 13 	brgt	8000bcd6 <_vfprintf_r+0xeb2>
8000bcb4:	f2 cb ff fc 	sub	r11,r9,-4
8000bcb8:	51 0b       	stdsp	sp[0x40],r11
8000bcba:	72 09       	ld.w	r9,r9[0x0]
8000bcbc:	fa c6 f9 44 	sub	r6,sp,-1724
8000bcc0:	ec 08 00 3b 	add	r11,r6,r8<<0x3
8000bcc4:	2f f8       	sub	r8,-1
8000bcc6:	f7 49 fd 88 	st.w	r11[-632],r9
8000bcca:	fb 48 06 b4 	st.w	sp[1716],r8
8000bcce:	14 97       	mov	r7,r10
8000bcd0:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
8000bcd4:	c0 58       	rjmp	8000bcde <_vfprintf_r+0xeba>
8000bcd6:	92 18       	ld.sh	r8,r9[0x2]
8000bcd8:	14 97       	mov	r7,r10
8000bcda:	2f c9       	sub	r9,-4
8000bcdc:	51 09       	stdsp	sp[0x40],r9
8000bcde:	5c 78       	castu.h	r8
8000bce0:	50 18       	stdsp	sp[0x4],r8
8000bce2:	c4 68       	rjmp	8000bd6e <_vfprintf_r+0xf4a>
8000bce4:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000bce8:	40 3c       	lddsp	r12,sp[0xc]
8000bcea:	58 0c       	cp.w	r12,0
8000bcec:	c1 d0       	breq	8000bd26 <_vfprintf_r+0xf02>
8000bcee:	10 36       	cp.w	r6,r8
8000bcf0:	c0 64       	brge	8000bcfc <_vfprintf_r+0xed8>
8000bcf2:	fa cb f9 44 	sub	r11,sp,-1724
8000bcf6:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000bcfa:	c1 f8       	rjmp	8000bd38 <_vfprintf_r+0xf14>
8000bcfc:	fa c8 f9 50 	sub	r8,sp,-1712
8000bd00:	1a d8       	st.w	--sp,r8
8000bd02:	fa c8 fa b8 	sub	r8,sp,-1352
8000bd06:	0c 9b       	mov	r11,r6
8000bd08:	1a d8       	st.w	--sp,r8
8000bd0a:	fa c8 fb b4 	sub	r8,sp,-1100
8000bd0e:	04 9a       	mov	r10,r2
8000bd10:	1a d8       	st.w	--sp,r8
8000bd12:	08 9c       	mov	r12,r4
8000bd14:	fa c8 f9 40 	sub	r8,sp,-1728
8000bd18:	fa c9 ff b4 	sub	r9,sp,-76
8000bd1c:	fe b0 f6 e6 	rcall	8000aae8 <get_arg>
8000bd20:	2f dd       	sub	sp,-12
8000bd22:	78 0b       	ld.w	r11,r12[0x0]
8000bd24:	c2 48       	rjmp	8000bd6c <_vfprintf_r+0xf48>
8000bd26:	ee ca ff ff 	sub	r10,r7,-1
8000bd2a:	10 37       	cp.w	r7,r8
8000bd2c:	c0 94       	brge	8000bd3e <_vfprintf_r+0xf1a>
8000bd2e:	fa c9 f9 44 	sub	r9,sp,-1724
8000bd32:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000bd36:	14 97       	mov	r7,r10
8000bd38:	ec fb fd 88 	ld.w	r11,r6[-632]
8000bd3c:	c1 88       	rjmp	8000bd6c <_vfprintf_r+0xf48>
8000bd3e:	41 09       	lddsp	r9,sp[0x40]
8000bd40:	59 f8       	cp.w	r8,31
8000bd42:	e0 89 00 11 	brgt	8000bd64 <_vfprintf_r+0xf40>
8000bd46:	f2 cb ff fc 	sub	r11,r9,-4
8000bd4a:	51 0b       	stdsp	sp[0x40],r11
8000bd4c:	fa c6 f9 44 	sub	r6,sp,-1724
8000bd50:	72 0b       	ld.w	r11,r9[0x0]
8000bd52:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000bd56:	f3 4b fd 88 	st.w	r9[-632],r11
8000bd5a:	2f f8       	sub	r8,-1
8000bd5c:	14 97       	mov	r7,r10
8000bd5e:	fb 48 06 b4 	st.w	sp[1716],r8
8000bd62:	c0 58       	rjmp	8000bd6c <_vfprintf_r+0xf48>
8000bd64:	72 0b       	ld.w	r11,r9[0x0]
8000bd66:	14 97       	mov	r7,r10
8000bd68:	2f c9       	sub	r9,-4
8000bd6a:	51 09       	stdsp	sp[0x40],r9
8000bd6c:	50 1b       	stdsp	sp[0x4],r11
8000bd6e:	30 0e       	mov	lr,0
8000bd70:	50 0e       	stdsp	sp[0x0],lr
8000bd72:	1c 98       	mov	r8,lr
8000bd74:	e0 8f 02 fe 	bral	8000c370 <_vfprintf_r+0x154c>
8000bd78:	50 a7       	stdsp	sp[0x28],r7
8000bd7a:	50 80       	stdsp	sp[0x20],r0
8000bd7c:	0c 97       	mov	r7,r6
8000bd7e:	04 94       	mov	r4,r2
8000bd80:	06 96       	mov	r6,r3
8000bd82:	02 92       	mov	r2,r1
8000bd84:	40 93       	lddsp	r3,sp[0x24]
8000bd86:	40 41       	lddsp	r1,sp[0x10]
8000bd88:	0e 99       	mov	r9,r7
8000bd8a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000bd8e:	40 3c       	lddsp	r12,sp[0xc]
8000bd90:	58 0c       	cp.w	r12,0
8000bd92:	c1 d0       	breq	8000bdcc <_vfprintf_r+0xfa8>
8000bd94:	10 36       	cp.w	r6,r8
8000bd96:	c0 64       	brge	8000bda2 <_vfprintf_r+0xf7e>
8000bd98:	fa cb f9 44 	sub	r11,sp,-1724
8000bd9c:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000bda0:	c1 d8       	rjmp	8000bdda <_vfprintf_r+0xfb6>
8000bda2:	fa c8 f9 50 	sub	r8,sp,-1712
8000bda6:	1a d8       	st.w	--sp,r8
8000bda8:	fa c8 fa b8 	sub	r8,sp,-1352
8000bdac:	1a d8       	st.w	--sp,r8
8000bdae:	fa c8 fb b4 	sub	r8,sp,-1100
8000bdb2:	1a d8       	st.w	--sp,r8
8000bdb4:	fa c9 ff b4 	sub	r9,sp,-76
8000bdb8:	fa c8 f9 40 	sub	r8,sp,-1728
8000bdbc:	04 9a       	mov	r10,r2
8000bdbe:	0c 9b       	mov	r11,r6
8000bdc0:	08 9c       	mov	r12,r4
8000bdc2:	fe b0 f6 93 	rcall	8000aae8 <get_arg>
8000bdc6:	2f dd       	sub	sp,-12
8000bdc8:	78 09       	ld.w	r9,r12[0x0]
8000bdca:	c2 18       	rjmp	8000be0c <_vfprintf_r+0xfe8>
8000bdcc:	2f f7       	sub	r7,-1
8000bdce:	10 39       	cp.w	r9,r8
8000bdd0:	c0 84       	brge	8000bde0 <_vfprintf_r+0xfbc>
8000bdd2:	fa ca f9 44 	sub	r10,sp,-1724
8000bdd6:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000bdda:	ec f9 fd 88 	ld.w	r9,r6[-632]
8000bdde:	c1 78       	rjmp	8000be0c <_vfprintf_r+0xfe8>
8000bde0:	41 09       	lddsp	r9,sp[0x40]
8000bde2:	59 f8       	cp.w	r8,31
8000bde4:	e0 89 00 10 	brgt	8000be04 <_vfprintf_r+0xfe0>
8000bde8:	f2 ca ff fc 	sub	r10,r9,-4
8000bdec:	51 0a       	stdsp	sp[0x40],r10
8000bdee:	fa c6 f9 44 	sub	r6,sp,-1724
8000bdf2:	72 09       	ld.w	r9,r9[0x0]
8000bdf4:	ec 08 00 3a 	add	r10,r6,r8<<0x3
8000bdf8:	f5 49 fd 88 	st.w	r10[-632],r9
8000bdfc:	2f f8       	sub	r8,-1
8000bdfe:	fb 48 06 b4 	st.w	sp[1716],r8
8000be02:	c0 58       	rjmp	8000be0c <_vfprintf_r+0xfe8>
8000be04:	f2 c8 ff fc 	sub	r8,r9,-4
8000be08:	51 08       	stdsp	sp[0x40],r8
8000be0a:	72 09       	ld.w	r9,r9[0x0]
8000be0c:	33 08       	mov	r8,48
8000be0e:	fb 68 06 b8 	st.b	sp[1720],r8
8000be12:	37 88       	mov	r8,120
8000be14:	30 0e       	mov	lr,0
8000be16:	fb 68 06 b9 	st.b	sp[1721],r8
8000be1a:	4c ac       	lddpc	r12,8000bf40 <_vfprintf_r+0x111c>
8000be1c:	50 19       	stdsp	sp[0x4],r9
8000be1e:	a1 b5       	sbr	r5,0x1
8000be20:	50 0e       	stdsp	sp[0x0],lr
8000be22:	50 dc       	stdsp	sp[0x34],r12
8000be24:	30 28       	mov	r8,2
8000be26:	37 80       	mov	r0,120
8000be28:	e0 8f 02 a4 	bral	8000c370 <_vfprintf_r+0x154c>
8000be2c:	50 a7       	stdsp	sp[0x28],r7
8000be2e:	50 80       	stdsp	sp[0x20],r0
8000be30:	10 90       	mov	r0,r8
8000be32:	30 08       	mov	r8,0
8000be34:	fb 68 06 bb 	st.b	sp[1723],r8
8000be38:	0c 97       	mov	r7,r6
8000be3a:	04 94       	mov	r4,r2
8000be3c:	06 96       	mov	r6,r3
8000be3e:	02 92       	mov	r2,r1
8000be40:	40 93       	lddsp	r3,sp[0x24]
8000be42:	40 41       	lddsp	r1,sp[0x10]
8000be44:	0e 99       	mov	r9,r7
8000be46:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000be4a:	40 3b       	lddsp	r11,sp[0xc]
8000be4c:	58 0b       	cp.w	r11,0
8000be4e:	c1 d0       	breq	8000be88 <_vfprintf_r+0x1064>
8000be50:	10 36       	cp.w	r6,r8
8000be52:	c0 64       	brge	8000be5e <_vfprintf_r+0x103a>
8000be54:	fa ca f9 44 	sub	r10,sp,-1724
8000be58:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000be5c:	c1 d8       	rjmp	8000be96 <_vfprintf_r+0x1072>
8000be5e:	fa c8 f9 50 	sub	r8,sp,-1712
8000be62:	1a d8       	st.w	--sp,r8
8000be64:	fa c8 fa b8 	sub	r8,sp,-1352
8000be68:	1a d8       	st.w	--sp,r8
8000be6a:	fa c8 fb b4 	sub	r8,sp,-1100
8000be6e:	0c 9b       	mov	r11,r6
8000be70:	1a d8       	st.w	--sp,r8
8000be72:	04 9a       	mov	r10,r2
8000be74:	fa c8 f9 40 	sub	r8,sp,-1728
8000be78:	fa c9 ff b4 	sub	r9,sp,-76
8000be7c:	08 9c       	mov	r12,r4
8000be7e:	fe b0 f6 35 	rcall	8000aae8 <get_arg>
8000be82:	2f dd       	sub	sp,-12
8000be84:	78 06       	ld.w	r6,r12[0x0]
8000be86:	c2 08       	rjmp	8000bec6 <_vfprintf_r+0x10a2>
8000be88:	2f f7       	sub	r7,-1
8000be8a:	10 39       	cp.w	r9,r8
8000be8c:	c0 84       	brge	8000be9c <_vfprintf_r+0x1078>
8000be8e:	fa c9 f9 44 	sub	r9,sp,-1724
8000be92:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000be96:	ec f6 fd 88 	ld.w	r6,r6[-632]
8000be9a:	c1 68       	rjmp	8000bec6 <_vfprintf_r+0x10a2>
8000be9c:	41 09       	lddsp	r9,sp[0x40]
8000be9e:	59 f8       	cp.w	r8,31
8000bea0:	e0 89 00 10 	brgt	8000bec0 <_vfprintf_r+0x109c>
8000bea4:	f2 ca ff fc 	sub	r10,r9,-4
8000bea8:	51 0a       	stdsp	sp[0x40],r10
8000beaa:	72 06       	ld.w	r6,r9[0x0]
8000beac:	fa ce f9 44 	sub	lr,sp,-1724
8000beb0:	fc 08 00 39 	add	r9,lr,r8<<0x3
8000beb4:	f3 46 fd 88 	st.w	r9[-632],r6
8000beb8:	2f f8       	sub	r8,-1
8000beba:	fb 48 06 b4 	st.w	sp[1716],r8
8000bebe:	c0 48       	rjmp	8000bec6 <_vfprintf_r+0x10a2>
8000bec0:	72 06       	ld.w	r6,r9[0x0]
8000bec2:	2f c9       	sub	r9,-4
8000bec4:	51 09       	stdsp	sp[0x40],r9
8000bec6:	40 2c       	lddsp	r12,sp[0x8]
8000bec8:	58 0c       	cp.w	r12,0
8000beca:	c1 05       	brlt	8000beea <_vfprintf_r+0x10c6>
8000becc:	18 9a       	mov	r10,r12
8000bece:	30 0b       	mov	r11,0
8000bed0:	0c 9c       	mov	r12,r6
8000bed2:	e0 a0 12 43 	rcall	8000e358 <memchr>
8000bed6:	e0 80 02 e0 	breq	8000c496 <_vfprintf_r+0x1672>
8000beda:	f8 06 01 02 	sub	r2,r12,r6
8000bede:	40 2b       	lddsp	r11,sp[0x8]
8000bee0:	16 32       	cp.w	r2,r11
8000bee2:	e0 89 02 da 	brgt	8000c496 <_vfprintf_r+0x1672>
8000bee6:	e0 8f 02 d5 	bral	8000c490 <_vfprintf_r+0x166c>
8000beea:	30 0a       	mov	r10,0
8000beec:	0c 9c       	mov	r12,r6
8000beee:	50 2a       	stdsp	sp[0x8],r10
8000bef0:	fe b0 f4 ff 	rcall	8000a8ee <strlen>
8000bef4:	18 92       	mov	r2,r12
8000bef6:	e0 8f 02 d3 	bral	8000c49c <_vfprintf_r+0x1678>
8000befa:	50 a7       	stdsp	sp[0x28],r7
8000befc:	50 80       	stdsp	sp[0x20],r0
8000befe:	0c 97       	mov	r7,r6
8000bf00:	04 94       	mov	r4,r2
8000bf02:	06 96       	mov	r6,r3
8000bf04:	02 92       	mov	r2,r1
8000bf06:	40 93       	lddsp	r3,sp[0x24]
8000bf08:	10 90       	mov	r0,r8
8000bf0a:	40 41       	lddsp	r1,sp[0x10]
8000bf0c:	a5 a5       	sbr	r5,0x4
8000bf0e:	c0 a8       	rjmp	8000bf22 <_vfprintf_r+0x10fe>
8000bf10:	50 a7       	stdsp	sp[0x28],r7
8000bf12:	50 80       	stdsp	sp[0x20],r0
8000bf14:	0c 97       	mov	r7,r6
8000bf16:	04 94       	mov	r4,r2
8000bf18:	06 96       	mov	r6,r3
8000bf1a:	02 92       	mov	r2,r1
8000bf1c:	40 93       	lddsp	r3,sp[0x24]
8000bf1e:	10 90       	mov	r0,r8
8000bf20:	40 41       	lddsp	r1,sp[0x10]
8000bf22:	ed b5 00 05 	bld	r5,0x5
8000bf26:	c5 71       	brne	8000bfd4 <_vfprintf_r+0x11b0>
8000bf28:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000bf2c:	40 39       	lddsp	r9,sp[0xc]
8000bf2e:	58 09       	cp.w	r9,0
8000bf30:	c2 20       	breq	8000bf74 <_vfprintf_r+0x1150>
8000bf32:	10 36       	cp.w	r6,r8
8000bf34:	c0 84       	brge	8000bf44 <_vfprintf_r+0x1120>
8000bf36:	fa c8 f9 44 	sub	r8,sp,-1724
8000bf3a:	f0 06 00 36 	add	r6,r8,r6<<0x3
8000bf3e:	c2 48       	rjmp	8000bf86 <_vfprintf_r+0x1162>
8000bf40:	80 01       	ld.sh	r1,r0[0x0]
8000bf42:	91 88       	st.w	r8[0x20],r8
8000bf44:	fa c8 f9 50 	sub	r8,sp,-1712
8000bf48:	1a d8       	st.w	--sp,r8
8000bf4a:	fa c8 fa b8 	sub	r8,sp,-1352
8000bf4e:	1a d8       	st.w	--sp,r8
8000bf50:	fa c8 fb b4 	sub	r8,sp,-1100
8000bf54:	1a d8       	st.w	--sp,r8
8000bf56:	fa c8 f9 40 	sub	r8,sp,-1728
8000bf5a:	fa c9 ff b4 	sub	r9,sp,-76
8000bf5e:	04 9a       	mov	r10,r2
8000bf60:	0c 9b       	mov	r11,r6
8000bf62:	08 9c       	mov	r12,r4
8000bf64:	fe b0 f5 c2 	rcall	8000aae8 <get_arg>
8000bf68:	2f dd       	sub	sp,-12
8000bf6a:	f8 e8 00 00 	ld.d	r8,r12[0]
8000bf6e:	fa e9 00 00 	st.d	sp[0],r8
8000bf72:	c2 e8       	rjmp	8000bfce <_vfprintf_r+0x11aa>
8000bf74:	ee ca ff ff 	sub	r10,r7,-1
8000bf78:	10 37       	cp.w	r7,r8
8000bf7a:	c0 b4       	brge	8000bf90 <_vfprintf_r+0x116c>
8000bf7c:	fa c8 f9 44 	sub	r8,sp,-1724
8000bf80:	14 97       	mov	r7,r10
8000bf82:	f0 06 00 36 	add	r6,r8,r6<<0x3
8000bf86:	ec ea fd 88 	ld.d	r10,r6[-632]
8000bf8a:	fa eb 00 00 	st.d	sp[0],r10
8000bf8e:	c2 08       	rjmp	8000bfce <_vfprintf_r+0x11aa>
8000bf90:	41 09       	lddsp	r9,sp[0x40]
8000bf92:	59 f8       	cp.w	r8,31
8000bf94:	e0 89 00 16 	brgt	8000bfc0 <_vfprintf_r+0x119c>
8000bf98:	f2 e6 00 00 	ld.d	r6,r9[0]
8000bf9c:	f2 cb ff f8 	sub	r11,r9,-8
8000bfa0:	fa e7 00 00 	st.d	sp[0],r6
8000bfa4:	51 0b       	stdsp	sp[0x40],r11
8000bfa6:	fa c6 f9 44 	sub	r6,sp,-1724
8000bfaa:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000bfae:	fa e6 00 00 	ld.d	r6,sp[0]
8000bfb2:	f2 e7 fd 88 	st.d	r9[-632],r6
8000bfb6:	2f f8       	sub	r8,-1
8000bfb8:	14 97       	mov	r7,r10
8000bfba:	fb 48 06 b4 	st.w	sp[1716],r8
8000bfbe:	c0 88       	rjmp	8000bfce <_vfprintf_r+0x11aa>
8000bfc0:	f2 e6 00 00 	ld.d	r6,r9[0]
8000bfc4:	2f 89       	sub	r9,-8
8000bfc6:	fa e7 00 00 	st.d	sp[0],r6
8000bfca:	51 09       	stdsp	sp[0x40],r9
8000bfcc:	14 97       	mov	r7,r10
8000bfce:	30 18       	mov	r8,1
8000bfd0:	e0 8f 01 d0 	bral	8000c370 <_vfprintf_r+0x154c>
8000bfd4:	ed b5 00 04 	bld	r5,0x4
8000bfd8:	c1 61       	brne	8000c004 <_vfprintf_r+0x11e0>
8000bfda:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000bfde:	40 3e       	lddsp	lr,sp[0xc]
8000bfe0:	58 0e       	cp.w	lr,0
8000bfe2:	c0 80       	breq	8000bff2 <_vfprintf_r+0x11ce>
8000bfe4:	10 36       	cp.w	r6,r8
8000bfe6:	c6 74       	brge	8000c0b4 <_vfprintf_r+0x1290>
8000bfe8:	fa cc f9 44 	sub	r12,sp,-1724
8000bfec:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000bff0:	c8 08       	rjmp	8000c0f0 <_vfprintf_r+0x12cc>
8000bff2:	ee ca ff ff 	sub	r10,r7,-1
8000bff6:	10 37       	cp.w	r7,r8
8000bff8:	c7 f4       	brge	8000c0f6 <_vfprintf_r+0x12d2>
8000bffa:	fa cb f9 44 	sub	r11,sp,-1724
8000bffe:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000c002:	c7 68       	rjmp	8000c0ee <_vfprintf_r+0x12ca>
8000c004:	ed b5 00 06 	bld	r5,0x6
8000c008:	c4 a1       	brne	8000c09c <_vfprintf_r+0x1278>
8000c00a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c00e:	40 3c       	lddsp	r12,sp[0xc]
8000c010:	58 0c       	cp.w	r12,0
8000c012:	c1 d0       	breq	8000c04c <_vfprintf_r+0x1228>
8000c014:	10 36       	cp.w	r6,r8
8000c016:	c0 64       	brge	8000c022 <_vfprintf_r+0x11fe>
8000c018:	fa cb f9 44 	sub	r11,sp,-1724
8000c01c:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000c020:	c1 f8       	rjmp	8000c05e <_vfprintf_r+0x123a>
8000c022:	fa c8 f9 50 	sub	r8,sp,-1712
8000c026:	1a d8       	st.w	--sp,r8
8000c028:	fa c8 fa b8 	sub	r8,sp,-1352
8000c02c:	1a d8       	st.w	--sp,r8
8000c02e:	fa c8 fb b4 	sub	r8,sp,-1100
8000c032:	1a d8       	st.w	--sp,r8
8000c034:	fa c8 f9 40 	sub	r8,sp,-1728
8000c038:	fa c9 ff b4 	sub	r9,sp,-76
8000c03c:	04 9a       	mov	r10,r2
8000c03e:	0c 9b       	mov	r11,r6
8000c040:	08 9c       	mov	r12,r4
8000c042:	fe b0 f5 53 	rcall	8000aae8 <get_arg>
8000c046:	2f dd       	sub	sp,-12
8000c048:	98 18       	ld.sh	r8,r12[0x2]
8000c04a:	c2 68       	rjmp	8000c096 <_vfprintf_r+0x1272>
8000c04c:	ee ca ff ff 	sub	r10,r7,-1
8000c050:	10 37       	cp.w	r7,r8
8000c052:	c0 94       	brge	8000c064 <_vfprintf_r+0x1240>
8000c054:	fa c9 f9 44 	sub	r9,sp,-1724
8000c058:	14 97       	mov	r7,r10
8000c05a:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000c05e:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000c062:	c1 a8       	rjmp	8000c096 <_vfprintf_r+0x1272>
8000c064:	41 09       	lddsp	r9,sp[0x40]
8000c066:	59 f8       	cp.w	r8,31
8000c068:	e0 89 00 13 	brgt	8000c08e <_vfprintf_r+0x126a>
8000c06c:	f2 cb ff fc 	sub	r11,r9,-4
8000c070:	51 0b       	stdsp	sp[0x40],r11
8000c072:	72 09       	ld.w	r9,r9[0x0]
8000c074:	fa c6 f9 44 	sub	r6,sp,-1724
8000c078:	ec 08 00 3b 	add	r11,r6,r8<<0x3
8000c07c:	2f f8       	sub	r8,-1
8000c07e:	f7 49 fd 88 	st.w	r11[-632],r9
8000c082:	fb 48 06 b4 	st.w	sp[1716],r8
8000c086:	14 97       	mov	r7,r10
8000c088:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
8000c08c:	c0 58       	rjmp	8000c096 <_vfprintf_r+0x1272>
8000c08e:	92 18       	ld.sh	r8,r9[0x2]
8000c090:	14 97       	mov	r7,r10
8000c092:	2f c9       	sub	r9,-4
8000c094:	51 09       	stdsp	sp[0x40],r9
8000c096:	5c 78       	castu.h	r8
8000c098:	50 18       	stdsp	sp[0x4],r8
8000c09a:	c4 68       	rjmp	8000c126 <_vfprintf_r+0x1302>
8000c09c:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c0a0:	40 3c       	lddsp	r12,sp[0xc]
8000c0a2:	58 0c       	cp.w	r12,0
8000c0a4:	c1 d0       	breq	8000c0de <_vfprintf_r+0x12ba>
8000c0a6:	10 36       	cp.w	r6,r8
8000c0a8:	c0 64       	brge	8000c0b4 <_vfprintf_r+0x1290>
8000c0aa:	fa cb f9 44 	sub	r11,sp,-1724
8000c0ae:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000c0b2:	c1 f8       	rjmp	8000c0f0 <_vfprintf_r+0x12cc>
8000c0b4:	fa c8 f9 50 	sub	r8,sp,-1712
8000c0b8:	1a d8       	st.w	--sp,r8
8000c0ba:	fa c8 fa b8 	sub	r8,sp,-1352
8000c0be:	0c 9b       	mov	r11,r6
8000c0c0:	1a d8       	st.w	--sp,r8
8000c0c2:	fa c8 fb b4 	sub	r8,sp,-1100
8000c0c6:	04 9a       	mov	r10,r2
8000c0c8:	1a d8       	st.w	--sp,r8
8000c0ca:	08 9c       	mov	r12,r4
8000c0cc:	fa c8 f9 40 	sub	r8,sp,-1728
8000c0d0:	fa c9 ff b4 	sub	r9,sp,-76
8000c0d4:	fe b0 f5 0a 	rcall	8000aae8 <get_arg>
8000c0d8:	2f dd       	sub	sp,-12
8000c0da:	78 0b       	ld.w	r11,r12[0x0]
8000c0dc:	c2 48       	rjmp	8000c124 <_vfprintf_r+0x1300>
8000c0de:	ee ca ff ff 	sub	r10,r7,-1
8000c0e2:	10 37       	cp.w	r7,r8
8000c0e4:	c0 94       	brge	8000c0f6 <_vfprintf_r+0x12d2>
8000c0e6:	fa c9 f9 44 	sub	r9,sp,-1724
8000c0ea:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000c0ee:	14 97       	mov	r7,r10
8000c0f0:	ec fb fd 88 	ld.w	r11,r6[-632]
8000c0f4:	c1 88       	rjmp	8000c124 <_vfprintf_r+0x1300>
8000c0f6:	41 09       	lddsp	r9,sp[0x40]
8000c0f8:	59 f8       	cp.w	r8,31
8000c0fa:	e0 89 00 11 	brgt	8000c11c <_vfprintf_r+0x12f8>
8000c0fe:	f2 cb ff fc 	sub	r11,r9,-4
8000c102:	51 0b       	stdsp	sp[0x40],r11
8000c104:	fa c6 f9 44 	sub	r6,sp,-1724
8000c108:	72 0b       	ld.w	r11,r9[0x0]
8000c10a:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000c10e:	f3 4b fd 88 	st.w	r9[-632],r11
8000c112:	2f f8       	sub	r8,-1
8000c114:	14 97       	mov	r7,r10
8000c116:	fb 48 06 b4 	st.w	sp[1716],r8
8000c11a:	c0 58       	rjmp	8000c124 <_vfprintf_r+0x1300>
8000c11c:	72 0b       	ld.w	r11,r9[0x0]
8000c11e:	14 97       	mov	r7,r10
8000c120:	2f c9       	sub	r9,-4
8000c122:	51 09       	stdsp	sp[0x40],r9
8000c124:	50 1b       	stdsp	sp[0x4],r11
8000c126:	30 0e       	mov	lr,0
8000c128:	30 18       	mov	r8,1
8000c12a:	50 0e       	stdsp	sp[0x0],lr
8000c12c:	c2 29       	rjmp	8000c370 <_vfprintf_r+0x154c>
8000c12e:	50 a7       	stdsp	sp[0x28],r7
8000c130:	50 80       	stdsp	sp[0x20],r0
8000c132:	0c 97       	mov	r7,r6
8000c134:	04 94       	mov	r4,r2
8000c136:	06 96       	mov	r6,r3
8000c138:	02 92       	mov	r2,r1
8000c13a:	4d 3c       	lddpc	r12,8000c284 <_vfprintf_r+0x1460>
8000c13c:	40 93       	lddsp	r3,sp[0x24]
8000c13e:	10 90       	mov	r0,r8
8000c140:	40 41       	lddsp	r1,sp[0x10]
8000c142:	50 dc       	stdsp	sp[0x34],r12
8000c144:	ed b5 00 05 	bld	r5,0x5
8000c148:	c5 51       	brne	8000c1f2 <_vfprintf_r+0x13ce>
8000c14a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c14e:	40 3b       	lddsp	r11,sp[0xc]
8000c150:	58 0b       	cp.w	r11,0
8000c152:	c2 20       	breq	8000c196 <_vfprintf_r+0x1372>
8000c154:	10 36       	cp.w	r6,r8
8000c156:	c0 a4       	brge	8000c16a <_vfprintf_r+0x1346>
8000c158:	fa ca f9 44 	sub	r10,sp,-1724
8000c15c:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000c160:	ec e8 fd 88 	ld.d	r8,r6[-632]
8000c164:	fa e9 00 00 	st.d	sp[0],r8
8000c168:	cf 38       	rjmp	8000c34e <_vfprintf_r+0x152a>
8000c16a:	fa c8 f9 50 	sub	r8,sp,-1712
8000c16e:	1a d8       	st.w	--sp,r8
8000c170:	fa c8 fa b8 	sub	r8,sp,-1352
8000c174:	04 9a       	mov	r10,r2
8000c176:	1a d8       	st.w	--sp,r8
8000c178:	0c 9b       	mov	r11,r6
8000c17a:	fa c8 fb b4 	sub	r8,sp,-1100
8000c17e:	08 9c       	mov	r12,r4
8000c180:	1a d8       	st.w	--sp,r8
8000c182:	fa c8 f9 40 	sub	r8,sp,-1728
8000c186:	fa c9 ff b4 	sub	r9,sp,-76
8000c18a:	fe b0 f4 af 	rcall	8000aae8 <get_arg>
8000c18e:	2f dd       	sub	sp,-12
8000c190:	f8 ea 00 00 	ld.d	r10,r12[0]
8000c194:	c0 c8       	rjmp	8000c1ac <_vfprintf_r+0x1388>
8000c196:	ee ca ff ff 	sub	r10,r7,-1
8000c19a:	10 37       	cp.w	r7,r8
8000c19c:	c0 b4       	brge	8000c1b2 <_vfprintf_r+0x138e>
8000c19e:	fa c9 f9 44 	sub	r9,sp,-1724
8000c1a2:	14 97       	mov	r7,r10
8000c1a4:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000c1a8:	ec ea fd 88 	ld.d	r10,r6[-632]
8000c1ac:	fa eb 00 00 	st.d	sp[0],r10
8000c1b0:	cc f8       	rjmp	8000c34e <_vfprintf_r+0x152a>
8000c1b2:	41 09       	lddsp	r9,sp[0x40]
8000c1b4:	59 f8       	cp.w	r8,31
8000c1b6:	e0 89 00 16 	brgt	8000c1e2 <_vfprintf_r+0x13be>
8000c1ba:	f2 e6 00 00 	ld.d	r6,r9[0]
8000c1be:	f2 cb ff f8 	sub	r11,r9,-8
8000c1c2:	fa e7 00 00 	st.d	sp[0],r6
8000c1c6:	51 0b       	stdsp	sp[0x40],r11
8000c1c8:	fa c6 f9 44 	sub	r6,sp,-1724
8000c1cc:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000c1d0:	fa e6 00 00 	ld.d	r6,sp[0]
8000c1d4:	f2 e7 fd 88 	st.d	r9[-632],r6
8000c1d8:	2f f8       	sub	r8,-1
8000c1da:	14 97       	mov	r7,r10
8000c1dc:	fb 48 06 b4 	st.w	sp[1716],r8
8000c1e0:	cb 78       	rjmp	8000c34e <_vfprintf_r+0x152a>
8000c1e2:	f2 e6 00 00 	ld.d	r6,r9[0]
8000c1e6:	2f 89       	sub	r9,-8
8000c1e8:	fa e7 00 00 	st.d	sp[0],r6
8000c1ec:	51 09       	stdsp	sp[0x40],r9
8000c1ee:	14 97       	mov	r7,r10
8000c1f0:	ca f8       	rjmp	8000c34e <_vfprintf_r+0x152a>
8000c1f2:	ed b5 00 04 	bld	r5,0x4
8000c1f6:	c1 71       	brne	8000c224 <_vfprintf_r+0x1400>
8000c1f8:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c1fc:	40 3e       	lddsp	lr,sp[0xc]
8000c1fe:	58 0e       	cp.w	lr,0
8000c200:	c0 80       	breq	8000c210 <_vfprintf_r+0x13ec>
8000c202:	10 36       	cp.w	r6,r8
8000c204:	c6 a4       	brge	8000c2d8 <_vfprintf_r+0x14b4>
8000c206:	fa cc f9 44 	sub	r12,sp,-1724
8000c20a:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000c20e:	c8 38       	rjmp	8000c314 <_vfprintf_r+0x14f0>
8000c210:	ee ca ff ff 	sub	r10,r7,-1
8000c214:	10 37       	cp.w	r7,r8
8000c216:	e0 84 00 82 	brge	8000c31a <_vfprintf_r+0x14f6>
8000c21a:	fa cb f9 44 	sub	r11,sp,-1724
8000c21e:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000c222:	c7 88       	rjmp	8000c312 <_vfprintf_r+0x14ee>
8000c224:	ed b5 00 06 	bld	r5,0x6
8000c228:	c4 c1       	brne	8000c2c0 <_vfprintf_r+0x149c>
8000c22a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c22e:	40 3c       	lddsp	r12,sp[0xc]
8000c230:	58 0c       	cp.w	r12,0
8000c232:	c1 d0       	breq	8000c26c <_vfprintf_r+0x1448>
8000c234:	10 36       	cp.w	r6,r8
8000c236:	c0 64       	brge	8000c242 <_vfprintf_r+0x141e>
8000c238:	fa cb f9 44 	sub	r11,sp,-1724
8000c23c:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000c240:	c1 f8       	rjmp	8000c27e <_vfprintf_r+0x145a>
8000c242:	fa c8 f9 50 	sub	r8,sp,-1712
8000c246:	1a d8       	st.w	--sp,r8
8000c248:	fa c8 fa b8 	sub	r8,sp,-1352
8000c24c:	1a d8       	st.w	--sp,r8
8000c24e:	fa c8 fb b4 	sub	r8,sp,-1100
8000c252:	1a d8       	st.w	--sp,r8
8000c254:	fa c8 f9 40 	sub	r8,sp,-1728
8000c258:	fa c9 ff b4 	sub	r9,sp,-76
8000c25c:	04 9a       	mov	r10,r2
8000c25e:	0c 9b       	mov	r11,r6
8000c260:	08 9c       	mov	r12,r4
8000c262:	fe b0 f4 43 	rcall	8000aae8 <get_arg>
8000c266:	2f dd       	sub	sp,-12
8000c268:	98 18       	ld.sh	r8,r12[0x2]
8000c26a:	c2 88       	rjmp	8000c2ba <_vfprintf_r+0x1496>
8000c26c:	ee ca ff ff 	sub	r10,r7,-1
8000c270:	10 37       	cp.w	r7,r8
8000c272:	c0 b4       	brge	8000c288 <_vfprintf_r+0x1464>
8000c274:	fa c9 f9 44 	sub	r9,sp,-1724
8000c278:	14 97       	mov	r7,r10
8000c27a:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000c27e:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000c282:	c1 c8       	rjmp	8000c2ba <_vfprintf_r+0x1496>
8000c284:	80 01       	ld.sh	r1,r0[0x0]
8000c286:	91 88       	st.w	r8[0x20],r8
8000c288:	41 09       	lddsp	r9,sp[0x40]
8000c28a:	59 f8       	cp.w	r8,31
8000c28c:	e0 89 00 13 	brgt	8000c2b2 <_vfprintf_r+0x148e>
8000c290:	f2 cb ff fc 	sub	r11,r9,-4
8000c294:	51 0b       	stdsp	sp[0x40],r11
8000c296:	72 09       	ld.w	r9,r9[0x0]
8000c298:	fa c6 f9 44 	sub	r6,sp,-1724
8000c29c:	ec 08 00 3b 	add	r11,r6,r8<<0x3
8000c2a0:	2f f8       	sub	r8,-1
8000c2a2:	f7 49 fd 88 	st.w	r11[-632],r9
8000c2a6:	fb 48 06 b4 	st.w	sp[1716],r8
8000c2aa:	14 97       	mov	r7,r10
8000c2ac:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
8000c2b0:	c0 58       	rjmp	8000c2ba <_vfprintf_r+0x1496>
8000c2b2:	92 18       	ld.sh	r8,r9[0x2]
8000c2b4:	14 97       	mov	r7,r10
8000c2b6:	2f c9       	sub	r9,-4
8000c2b8:	51 09       	stdsp	sp[0x40],r9
8000c2ba:	5c 78       	castu.h	r8
8000c2bc:	50 18       	stdsp	sp[0x4],r8
8000c2be:	c4 68       	rjmp	8000c34a <_vfprintf_r+0x1526>
8000c2c0:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c2c4:	40 3c       	lddsp	r12,sp[0xc]
8000c2c6:	58 0c       	cp.w	r12,0
8000c2c8:	c1 d0       	breq	8000c302 <_vfprintf_r+0x14de>
8000c2ca:	10 36       	cp.w	r6,r8
8000c2cc:	c0 64       	brge	8000c2d8 <_vfprintf_r+0x14b4>
8000c2ce:	fa cb f9 44 	sub	r11,sp,-1724
8000c2d2:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000c2d6:	c1 f8       	rjmp	8000c314 <_vfprintf_r+0x14f0>
8000c2d8:	fa c8 f9 50 	sub	r8,sp,-1712
8000c2dc:	1a d8       	st.w	--sp,r8
8000c2de:	fa c8 fa b8 	sub	r8,sp,-1352
8000c2e2:	0c 9b       	mov	r11,r6
8000c2e4:	1a d8       	st.w	--sp,r8
8000c2e6:	fa c8 fb b4 	sub	r8,sp,-1100
8000c2ea:	04 9a       	mov	r10,r2
8000c2ec:	1a d8       	st.w	--sp,r8
8000c2ee:	08 9c       	mov	r12,r4
8000c2f0:	fa c8 f9 40 	sub	r8,sp,-1728
8000c2f4:	fa c9 ff b4 	sub	r9,sp,-76
8000c2f8:	fe b0 f3 f8 	rcall	8000aae8 <get_arg>
8000c2fc:	2f dd       	sub	sp,-12
8000c2fe:	78 0b       	ld.w	r11,r12[0x0]
8000c300:	c2 48       	rjmp	8000c348 <_vfprintf_r+0x1524>
8000c302:	ee ca ff ff 	sub	r10,r7,-1
8000c306:	10 37       	cp.w	r7,r8
8000c308:	c0 94       	brge	8000c31a <_vfprintf_r+0x14f6>
8000c30a:	fa c9 f9 44 	sub	r9,sp,-1724
8000c30e:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000c312:	14 97       	mov	r7,r10
8000c314:	ec fb fd 88 	ld.w	r11,r6[-632]
8000c318:	c1 88       	rjmp	8000c348 <_vfprintf_r+0x1524>
8000c31a:	41 09       	lddsp	r9,sp[0x40]
8000c31c:	59 f8       	cp.w	r8,31
8000c31e:	e0 89 00 11 	brgt	8000c340 <_vfprintf_r+0x151c>
8000c322:	f2 cb ff fc 	sub	r11,r9,-4
8000c326:	51 0b       	stdsp	sp[0x40],r11
8000c328:	fa c6 f9 44 	sub	r6,sp,-1724
8000c32c:	72 0b       	ld.w	r11,r9[0x0]
8000c32e:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000c332:	f3 4b fd 88 	st.w	r9[-632],r11
8000c336:	2f f8       	sub	r8,-1
8000c338:	14 97       	mov	r7,r10
8000c33a:	fb 48 06 b4 	st.w	sp[1716],r8
8000c33e:	c0 58       	rjmp	8000c348 <_vfprintf_r+0x1524>
8000c340:	72 0b       	ld.w	r11,r9[0x0]
8000c342:	14 97       	mov	r7,r10
8000c344:	2f c9       	sub	r9,-4
8000c346:	51 09       	stdsp	sp[0x40],r9
8000c348:	50 1b       	stdsp	sp[0x4],r11
8000c34a:	30 0e       	mov	lr,0
8000c34c:	50 0e       	stdsp	sp[0x0],lr
8000c34e:	40 08       	lddsp	r8,sp[0x0]
8000c350:	40 1c       	lddsp	r12,sp[0x4]
8000c352:	18 48       	or	r8,r12
8000c354:	5f 19       	srne	r9
8000c356:	0a 98       	mov	r8,r5
8000c358:	eb e9 00 09 	and	r9,r5,r9
8000c35c:	a1 b8       	sbr	r8,0x1
8000c35e:	58 09       	cp.w	r9,0
8000c360:	c0 70       	breq	8000c36e <_vfprintf_r+0x154a>
8000c362:	10 95       	mov	r5,r8
8000c364:	fb 60 06 b9 	st.b	sp[1721],r0
8000c368:	33 08       	mov	r8,48
8000c36a:	fb 68 06 b8 	st.b	sp[1720],r8
8000c36e:	30 28       	mov	r8,2
8000c370:	30 09       	mov	r9,0
8000c372:	fb 69 06 bb 	st.b	sp[1723],r9
8000c376:	0a 99       	mov	r9,r5
8000c378:	a7 d9       	cbr	r9,0x7
8000c37a:	40 2b       	lddsp	r11,sp[0x8]
8000c37c:	40 16       	lddsp	r6,sp[0x4]
8000c37e:	58 0b       	cp.w	r11,0
8000c380:	5f 1a       	srne	r10
8000c382:	f2 05 17 40 	movge	r5,r9
8000c386:	fa c2 f9 78 	sub	r2,sp,-1672
8000c38a:	40 09       	lddsp	r9,sp[0x0]
8000c38c:	0c 49       	or	r9,r6
8000c38e:	5f 19       	srne	r9
8000c390:	f5 e9 10 09 	or	r9,r10,r9
8000c394:	c5 c0       	breq	8000c44c <_vfprintf_r+0x1628>
8000c396:	30 19       	mov	r9,1
8000c398:	f2 08 18 00 	cp.b	r8,r9
8000c39c:	c0 60       	breq	8000c3a8 <_vfprintf_r+0x1584>
8000c39e:	30 29       	mov	r9,2
8000c3a0:	f2 08 18 00 	cp.b	r8,r9
8000c3a4:	c0 41       	brne	8000c3ac <_vfprintf_r+0x1588>
8000c3a6:	c3 c8       	rjmp	8000c41e <_vfprintf_r+0x15fa>
8000c3a8:	04 96       	mov	r6,r2
8000c3aa:	c3 08       	rjmp	8000c40a <_vfprintf_r+0x15e6>
8000c3ac:	04 96       	mov	r6,r2
8000c3ae:	fa e8 00 00 	ld.d	r8,sp[0]
8000c3b2:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
8000c3b6:	2d 0a       	sub	r10,-48
8000c3b8:	0c fa       	st.b	--r6,r10
8000c3ba:	f0 0b 16 03 	lsr	r11,r8,0x3
8000c3be:	f2 0c 16 03 	lsr	r12,r9,0x3
8000c3c2:	f7 e9 11 db 	or	r11,r11,r9<<0x1d
8000c3c6:	18 99       	mov	r9,r12
8000c3c8:	16 98       	mov	r8,r11
8000c3ca:	58 08       	cp.w	r8,0
8000c3cc:	5c 29       	cpc	r9
8000c3ce:	cf 21       	brne	8000c3b2 <_vfprintf_r+0x158e>
8000c3d0:	fa e9 00 00 	st.d	sp[0],r8
8000c3d4:	ed b5 00 00 	bld	r5,0x0
8000c3d8:	c4 51       	brne	8000c462 <_vfprintf_r+0x163e>
8000c3da:	33 09       	mov	r9,48
8000c3dc:	f2 0a 18 00 	cp.b	r10,r9
8000c3e0:	c4 10       	breq	8000c462 <_vfprintf_r+0x163e>
8000c3e2:	0c f9       	st.b	--r6,r9
8000c3e4:	c3 f8       	rjmp	8000c462 <_vfprintf_r+0x163e>
8000c3e6:	fa ea 00 00 	ld.d	r10,sp[0]
8000c3ea:	30 a8       	mov	r8,10
8000c3ec:	30 09       	mov	r9,0
8000c3ee:	e0 a0 1a 1b 	rcall	8000f824 <__avr32_umod64>
8000c3f2:	30 a8       	mov	r8,10
8000c3f4:	2d 0a       	sub	r10,-48
8000c3f6:	30 09       	mov	r9,0
8000c3f8:	ac 8a       	st.b	r6[0x0],r10
8000c3fa:	fa ea 00 00 	ld.d	r10,sp[0]
8000c3fe:	e0 a0 18 e1 	rcall	8000f5c0 <__avr32_udiv64>
8000c402:	16 99       	mov	r9,r11
8000c404:	14 98       	mov	r8,r10
8000c406:	fa e9 00 00 	st.d	sp[0],r8
8000c40a:	20 16       	sub	r6,1
8000c40c:	fa ea 00 00 	ld.d	r10,sp[0]
8000c410:	58 9a       	cp.w	r10,9
8000c412:	5c 2b       	cpc	r11
8000c414:	fe 9b ff e9 	brhi	8000c3e6 <_vfprintf_r+0x15c2>
8000c418:	1b f8       	ld.ub	r8,sp[0x7]
8000c41a:	2d 08       	sub	r8,-48
8000c41c:	c2 08       	rjmp	8000c45c <_vfprintf_r+0x1638>
8000c41e:	04 96       	mov	r6,r2
8000c420:	fa e8 00 00 	ld.d	r8,sp[0]
8000c424:	f5 d8 c0 04 	bfextu	r10,r8,0x0,0x4
8000c428:	40 de       	lddsp	lr,sp[0x34]
8000c42a:	fc 0a 07 0a 	ld.ub	r10,lr[r10]
8000c42e:	0c fa       	st.b	--r6,r10
8000c430:	f2 0b 16 04 	lsr	r11,r9,0x4
8000c434:	f0 0a 16 04 	lsr	r10,r8,0x4
8000c438:	f5 e9 11 ca 	or	r10,r10,r9<<0x1c
8000c43c:	16 99       	mov	r9,r11
8000c43e:	14 98       	mov	r8,r10
8000c440:	58 08       	cp.w	r8,0
8000c442:	5c 29       	cpc	r9
8000c444:	cf 01       	brne	8000c424 <_vfprintf_r+0x1600>
8000c446:	fa e9 00 00 	st.d	sp[0],r8
8000c44a:	c0 c8       	rjmp	8000c462 <_vfprintf_r+0x163e>
8000c44c:	58 08       	cp.w	r8,0
8000c44e:	c0 91       	brne	8000c460 <_vfprintf_r+0x163c>
8000c450:	ed b5 00 00 	bld	r5,0x0
8000c454:	c0 61       	brne	8000c460 <_vfprintf_r+0x163c>
8000c456:	fa c6 f9 79 	sub	r6,sp,-1671
8000c45a:	33 08       	mov	r8,48
8000c45c:	ac 88       	st.b	r6[0x0],r8
8000c45e:	c0 28       	rjmp	8000c462 <_vfprintf_r+0x163e>
8000c460:	04 96       	mov	r6,r2
8000c462:	0c 12       	sub	r2,r6
8000c464:	c1 c8       	rjmp	8000c49c <_vfprintf_r+0x1678>
8000c466:	50 a7       	stdsp	sp[0x28],r7
8000c468:	50 80       	stdsp	sp[0x20],r0
8000c46a:	40 93       	lddsp	r3,sp[0x24]
8000c46c:	0c 97       	mov	r7,r6
8000c46e:	10 90       	mov	r0,r8
8000c470:	04 94       	mov	r4,r2
8000c472:	40 41       	lddsp	r1,sp[0x10]
8000c474:	58 08       	cp.w	r8,0
8000c476:	e0 80 04 51 	breq	8000cd18 <_vfprintf_r+0x1ef4>
8000c47a:	fb 68 06 60 	st.b	sp[1632],r8
8000c47e:	30 0c       	mov	r12,0
8000c480:	30 08       	mov	r8,0
8000c482:	30 12       	mov	r2,1
8000c484:	fb 68 06 bb 	st.b	sp[1723],r8
8000c488:	50 2c       	stdsp	sp[0x8],r12
8000c48a:	fa c6 f9 a0 	sub	r6,sp,-1632
8000c48e:	c0 78       	rjmp	8000c49c <_vfprintf_r+0x1678>
8000c490:	30 0b       	mov	r11,0
8000c492:	50 2b       	stdsp	sp[0x8],r11
8000c494:	c0 48       	rjmp	8000c49c <_vfprintf_r+0x1678>
8000c496:	40 22       	lddsp	r2,sp[0x8]
8000c498:	30 0a       	mov	r10,0
8000c49a:	50 2a       	stdsp	sp[0x8],r10
8000c49c:	40 29       	lddsp	r9,sp[0x8]
8000c49e:	e4 09 0c 49 	max	r9,r2,r9
8000c4a2:	fb 38 06 bb 	ld.ub	r8,sp[1723]
8000c4a6:	50 39       	stdsp	sp[0xc],r9
8000c4a8:	0a 9e       	mov	lr,r5
8000c4aa:	30 09       	mov	r9,0
8000c4ac:	e2 1e 00 02 	andl	lr,0x2,COH
8000c4b0:	f2 08 18 00 	cp.b	r8,r9
8000c4b4:	fb f8 10 03 	ld.wne	r8,sp[0xc]
8000c4b8:	f7 b8 01 ff 	subne	r8,-1
8000c4bc:	fb f8 1a 03 	st.wne	sp[0xc],r8
8000c4c0:	0a 9b       	mov	r11,r5
8000c4c2:	58 0e       	cp.w	lr,0
8000c4c4:	fb fc 10 03 	ld.wne	r12,sp[0xc]
8000c4c8:	f7 bc 01 fe 	subne	r12,-2
8000c4cc:	fb fc 1a 03 	st.wne	sp[0xc],r12
8000c4d0:	e2 1b 00 84 	andl	r11,0x84,COH
8000c4d4:	50 fe       	stdsp	sp[0x3c],lr
8000c4d6:	50 9b       	stdsp	sp[0x24],r11
8000c4d8:	c4 51       	brne	8000c562 <_vfprintf_r+0x173e>
8000c4da:	40 8a       	lddsp	r10,sp[0x20]
8000c4dc:	40 39       	lddsp	r9,sp[0xc]
8000c4de:	12 1a       	sub	r10,r9
8000c4e0:	50 4a       	stdsp	sp[0x10],r10
8000c4e2:	58 0a       	cp.w	r10,0
8000c4e4:	e0 89 00 1f 	brgt	8000c522 <_vfprintf_r+0x16fe>
8000c4e8:	c3 d8       	rjmp	8000c562 <_vfprintf_r+0x173e>
8000c4ea:	2f 09       	sub	r9,-16
8000c4ec:	2f f8       	sub	r8,-1
8000c4ee:	4c ee       	lddpc	lr,8000c624 <_vfprintf_r+0x1800>
8000c4f0:	31 0c       	mov	r12,16
8000c4f2:	fb 49 06 90 	st.w	sp[1680],r9
8000c4f6:	87 0e       	st.w	r3[0x0],lr
8000c4f8:	87 1c       	st.w	r3[0x4],r12
8000c4fa:	fb 48 06 8c 	st.w	sp[1676],r8
8000c4fe:	58 78       	cp.w	r8,7
8000c500:	e0 89 00 04 	brgt	8000c508 <_vfprintf_r+0x16e4>
8000c504:	2f 83       	sub	r3,-8
8000c506:	c0 b8       	rjmp	8000c51c <_vfprintf_r+0x16f8>
8000c508:	fa ca f9 78 	sub	r10,sp,-1672
8000c50c:	02 9b       	mov	r11,r1
8000c50e:	08 9c       	mov	r12,r4
8000c510:	fe b0 f4 7c 	rcall	8000ae08 <__sprint_r>
8000c514:	e0 81 04 13 	brne	8000cd3a <_vfprintf_r+0x1f16>
8000c518:	fa c3 f9 e0 	sub	r3,sp,-1568
8000c51c:	40 4b       	lddsp	r11,sp[0x10]
8000c51e:	21 0b       	sub	r11,16
8000c520:	50 4b       	stdsp	sp[0x10],r11
8000c522:	fa f9 06 90 	ld.w	r9,sp[1680]
8000c526:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000c52a:	4b fa       	lddpc	r10,8000c624 <_vfprintf_r+0x1800>
8000c52c:	40 4e       	lddsp	lr,sp[0x10]
8000c52e:	59 0e       	cp.w	lr,16
8000c530:	fe 99 ff dd 	brgt	8000c4ea <_vfprintf_r+0x16c6>
8000c534:	1c 09       	add	r9,lr
8000c536:	2f f8       	sub	r8,-1
8000c538:	87 0a       	st.w	r3[0x0],r10
8000c53a:	fb 49 06 90 	st.w	sp[1680],r9
8000c53e:	87 1e       	st.w	r3[0x4],lr
8000c540:	fb 48 06 8c 	st.w	sp[1676],r8
8000c544:	58 78       	cp.w	r8,7
8000c546:	e0 89 00 04 	brgt	8000c54e <_vfprintf_r+0x172a>
8000c54a:	2f 83       	sub	r3,-8
8000c54c:	c0 b8       	rjmp	8000c562 <_vfprintf_r+0x173e>
8000c54e:	fa ca f9 78 	sub	r10,sp,-1672
8000c552:	02 9b       	mov	r11,r1
8000c554:	08 9c       	mov	r12,r4
8000c556:	fe b0 f4 59 	rcall	8000ae08 <__sprint_r>
8000c55a:	e0 81 03 f0 	brne	8000cd3a <_vfprintf_r+0x1f16>
8000c55e:	fa c3 f9 e0 	sub	r3,sp,-1568
8000c562:	30 09       	mov	r9,0
8000c564:	fb 38 06 bb 	ld.ub	r8,sp[1723]
8000c568:	f2 08 18 00 	cp.b	r8,r9
8000c56c:	c1 f0       	breq	8000c5aa <_vfprintf_r+0x1786>
8000c56e:	fa f8 06 90 	ld.w	r8,sp[1680]
8000c572:	fa c9 f9 45 	sub	r9,sp,-1723
8000c576:	2f f8       	sub	r8,-1
8000c578:	87 09       	st.w	r3[0x0],r9
8000c57a:	fb 48 06 90 	st.w	sp[1680],r8
8000c57e:	30 19       	mov	r9,1
8000c580:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000c584:	87 19       	st.w	r3[0x4],r9
8000c586:	2f f8       	sub	r8,-1
8000c588:	fb 48 06 8c 	st.w	sp[1676],r8
8000c58c:	58 78       	cp.w	r8,7
8000c58e:	e0 89 00 04 	brgt	8000c596 <_vfprintf_r+0x1772>
8000c592:	2f 83       	sub	r3,-8
8000c594:	c0 b8       	rjmp	8000c5aa <_vfprintf_r+0x1786>
8000c596:	fa ca f9 78 	sub	r10,sp,-1672
8000c59a:	02 9b       	mov	r11,r1
8000c59c:	08 9c       	mov	r12,r4
8000c59e:	fe b0 f4 35 	rcall	8000ae08 <__sprint_r>
8000c5a2:	e0 81 03 cc 	brne	8000cd3a <_vfprintf_r+0x1f16>
8000c5a6:	fa c3 f9 e0 	sub	r3,sp,-1568
8000c5aa:	40 fc       	lddsp	r12,sp[0x3c]
8000c5ac:	58 0c       	cp.w	r12,0
8000c5ae:	c1 f0       	breq	8000c5ec <_vfprintf_r+0x17c8>
8000c5b0:	fa f8 06 90 	ld.w	r8,sp[1680]
8000c5b4:	fa c9 f9 48 	sub	r9,sp,-1720
8000c5b8:	2f e8       	sub	r8,-2
8000c5ba:	87 09       	st.w	r3[0x0],r9
8000c5bc:	fb 48 06 90 	st.w	sp[1680],r8
8000c5c0:	30 29       	mov	r9,2
8000c5c2:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000c5c6:	87 19       	st.w	r3[0x4],r9
8000c5c8:	2f f8       	sub	r8,-1
8000c5ca:	fb 48 06 8c 	st.w	sp[1676],r8
8000c5ce:	58 78       	cp.w	r8,7
8000c5d0:	e0 89 00 04 	brgt	8000c5d8 <_vfprintf_r+0x17b4>
8000c5d4:	2f 83       	sub	r3,-8
8000c5d6:	c0 b8       	rjmp	8000c5ec <_vfprintf_r+0x17c8>
8000c5d8:	fa ca f9 78 	sub	r10,sp,-1672
8000c5dc:	02 9b       	mov	r11,r1
8000c5de:	08 9c       	mov	r12,r4
8000c5e0:	fe b0 f4 14 	rcall	8000ae08 <__sprint_r>
8000c5e4:	e0 81 03 ab 	brne	8000cd3a <_vfprintf_r+0x1f16>
8000c5e8:	fa c3 f9 e0 	sub	r3,sp,-1568
8000c5ec:	40 9b       	lddsp	r11,sp[0x24]
8000c5ee:	e0 4b 00 80 	cp.w	r11,128
8000c5f2:	c4 a1       	brne	8000c686 <_vfprintf_r+0x1862>
8000c5f4:	40 8a       	lddsp	r10,sp[0x20]
8000c5f6:	40 39       	lddsp	r9,sp[0xc]
8000c5f8:	12 1a       	sub	r10,r9
8000c5fa:	50 4a       	stdsp	sp[0x10],r10
8000c5fc:	58 0a       	cp.w	r10,0
8000c5fe:	e0 89 00 24 	brgt	8000c646 <_vfprintf_r+0x1822>
8000c602:	c4 28       	rjmp	8000c686 <_vfprintf_r+0x1862>
8000c604:	2f 09       	sub	r9,-16
8000c606:	2f f8       	sub	r8,-1
8000c608:	48 8e       	lddpc	lr,8000c628 <_vfprintf_r+0x1804>
8000c60a:	31 0c       	mov	r12,16
8000c60c:	fb 49 06 90 	st.w	sp[1680],r9
8000c610:	87 0e       	st.w	r3[0x0],lr
8000c612:	87 1c       	st.w	r3[0x4],r12
8000c614:	fb 48 06 8c 	st.w	sp[1676],r8
8000c618:	58 78       	cp.w	r8,7
8000c61a:	e0 89 00 09 	brgt	8000c62c <_vfprintf_r+0x1808>
8000c61e:	2f 83       	sub	r3,-8
8000c620:	c1 08       	rjmp	8000c640 <_vfprintf_r+0x181c>
8000c622:	d7 03       	nop
8000c624:	80 01       	ld.sh	r1,r0[0x0]
8000c626:	91 a0       	st.w	r8[0x28],r0
8000c628:	80 01       	ld.sh	r1,r0[0x0]
8000c62a:	91 b0       	st.w	r8[0x2c],r0
8000c62c:	fa ca f9 78 	sub	r10,sp,-1672
8000c630:	02 9b       	mov	r11,r1
8000c632:	08 9c       	mov	r12,r4
8000c634:	fe b0 f3 ea 	rcall	8000ae08 <__sprint_r>
8000c638:	e0 81 03 81 	brne	8000cd3a <_vfprintf_r+0x1f16>
8000c63c:	fa c3 f9 e0 	sub	r3,sp,-1568
8000c640:	40 4b       	lddsp	r11,sp[0x10]
8000c642:	21 0b       	sub	r11,16
8000c644:	50 4b       	stdsp	sp[0x10],r11
8000c646:	fa f9 06 90 	ld.w	r9,sp[1680]
8000c64a:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000c64e:	4c 6a       	lddpc	r10,8000c764 <_vfprintf_r+0x1940>
8000c650:	40 4e       	lddsp	lr,sp[0x10]
8000c652:	59 0e       	cp.w	lr,16
8000c654:	fe 99 ff d8 	brgt	8000c604 <_vfprintf_r+0x17e0>
8000c658:	1c 09       	add	r9,lr
8000c65a:	2f f8       	sub	r8,-1
8000c65c:	87 0a       	st.w	r3[0x0],r10
8000c65e:	fb 49 06 90 	st.w	sp[1680],r9
8000c662:	87 1e       	st.w	r3[0x4],lr
8000c664:	fb 48 06 8c 	st.w	sp[1676],r8
8000c668:	58 78       	cp.w	r8,7
8000c66a:	e0 89 00 04 	brgt	8000c672 <_vfprintf_r+0x184e>
8000c66e:	2f 83       	sub	r3,-8
8000c670:	c0 b8       	rjmp	8000c686 <_vfprintf_r+0x1862>
8000c672:	fa ca f9 78 	sub	r10,sp,-1672
8000c676:	02 9b       	mov	r11,r1
8000c678:	08 9c       	mov	r12,r4
8000c67a:	fe b0 f3 c7 	rcall	8000ae08 <__sprint_r>
8000c67e:	e0 81 03 5e 	brne	8000cd3a <_vfprintf_r+0x1f16>
8000c682:	fa c3 f9 e0 	sub	r3,sp,-1568
8000c686:	40 2c       	lddsp	r12,sp[0x8]
8000c688:	04 1c       	sub	r12,r2
8000c68a:	50 2c       	stdsp	sp[0x8],r12
8000c68c:	58 0c       	cp.w	r12,0
8000c68e:	e0 89 00 1f 	brgt	8000c6cc <_vfprintf_r+0x18a8>
8000c692:	c3 d8       	rjmp	8000c70c <_vfprintf_r+0x18e8>
8000c694:	2f 09       	sub	r9,-16
8000c696:	2f f8       	sub	r8,-1
8000c698:	4b 3b       	lddpc	r11,8000c764 <_vfprintf_r+0x1940>
8000c69a:	31 0a       	mov	r10,16
8000c69c:	fb 49 06 90 	st.w	sp[1680],r9
8000c6a0:	87 0b       	st.w	r3[0x0],r11
8000c6a2:	87 1a       	st.w	r3[0x4],r10
8000c6a4:	fb 48 06 8c 	st.w	sp[1676],r8
8000c6a8:	58 78       	cp.w	r8,7
8000c6aa:	e0 89 00 04 	brgt	8000c6b2 <_vfprintf_r+0x188e>
8000c6ae:	2f 83       	sub	r3,-8
8000c6b0:	c0 b8       	rjmp	8000c6c6 <_vfprintf_r+0x18a2>
8000c6b2:	fa ca f9 78 	sub	r10,sp,-1672
8000c6b6:	02 9b       	mov	r11,r1
8000c6b8:	08 9c       	mov	r12,r4
8000c6ba:	fe b0 f3 a7 	rcall	8000ae08 <__sprint_r>
8000c6be:	e0 81 03 3e 	brne	8000cd3a <_vfprintf_r+0x1f16>
8000c6c2:	fa c3 f9 e0 	sub	r3,sp,-1568
8000c6c6:	40 29       	lddsp	r9,sp[0x8]
8000c6c8:	21 09       	sub	r9,16
8000c6ca:	50 29       	stdsp	sp[0x8],r9
8000c6cc:	fa f9 06 90 	ld.w	r9,sp[1680]
8000c6d0:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000c6d4:	4a 4a       	lddpc	r10,8000c764 <_vfprintf_r+0x1940>
8000c6d6:	40 2e       	lddsp	lr,sp[0x8]
8000c6d8:	59 0e       	cp.w	lr,16
8000c6da:	fe 99 ff dd 	brgt	8000c694 <_vfprintf_r+0x1870>
8000c6de:	1c 09       	add	r9,lr
8000c6e0:	2f f8       	sub	r8,-1
8000c6e2:	87 0a       	st.w	r3[0x0],r10
8000c6e4:	fb 49 06 90 	st.w	sp[1680],r9
8000c6e8:	87 1e       	st.w	r3[0x4],lr
8000c6ea:	fb 48 06 8c 	st.w	sp[1676],r8
8000c6ee:	58 78       	cp.w	r8,7
8000c6f0:	e0 89 00 04 	brgt	8000c6f8 <_vfprintf_r+0x18d4>
8000c6f4:	2f 83       	sub	r3,-8
8000c6f6:	c0 b8       	rjmp	8000c70c <_vfprintf_r+0x18e8>
8000c6f8:	fa ca f9 78 	sub	r10,sp,-1672
8000c6fc:	02 9b       	mov	r11,r1
8000c6fe:	08 9c       	mov	r12,r4
8000c700:	fe b0 f3 84 	rcall	8000ae08 <__sprint_r>
8000c704:	e0 81 03 1b 	brne	8000cd3a <_vfprintf_r+0x1f16>
8000c708:	fa c3 f9 e0 	sub	r3,sp,-1568
8000c70c:	ed b5 00 08 	bld	r5,0x8
8000c710:	c0 b0       	breq	8000c726 <_vfprintf_r+0x1902>
8000c712:	fa f8 06 90 	ld.w	r8,sp[1680]
8000c716:	87 12       	st.w	r3[0x4],r2
8000c718:	87 06       	st.w	r3[0x0],r6
8000c71a:	f0 02 00 02 	add	r2,r8,r2
8000c71e:	fb 42 06 90 	st.w	sp[1680],r2
8000c722:	e0 8f 01 d5 	bral	8000cacc <_vfprintf_r+0x1ca8>
8000c726:	e0 40 00 65 	cp.w	r0,101
8000c72a:	e0 8a 01 d7 	brle	8000cad8 <_vfprintf_r+0x1cb4>
8000c72e:	30 08       	mov	r8,0
8000c730:	30 09       	mov	r9,0
8000c732:	40 5b       	lddsp	r11,sp[0x14]
8000c734:	40 7a       	lddsp	r10,sp[0x1c]
8000c736:	e0 a0 15 3e 	rcall	8000f1b2 <__avr32_f64_cmp_eq>
8000c73a:	c7 a0       	breq	8000c82e <_vfprintf_r+0x1a0a>
8000c73c:	fa f8 06 90 	ld.w	r8,sp[1680]
8000c740:	48 a9       	lddpc	r9,8000c768 <_vfprintf_r+0x1944>
8000c742:	2f f8       	sub	r8,-1
8000c744:	87 09       	st.w	r3[0x0],r9
8000c746:	fb 48 06 90 	st.w	sp[1680],r8
8000c74a:	30 19       	mov	r9,1
8000c74c:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000c750:	87 19       	st.w	r3[0x4],r9
8000c752:	2f f8       	sub	r8,-1
8000c754:	fb 48 06 8c 	st.w	sp[1676],r8
8000c758:	58 78       	cp.w	r8,7
8000c75a:	e0 89 00 09 	brgt	8000c76c <_vfprintf_r+0x1948>
8000c75e:	2f 83       	sub	r3,-8
8000c760:	c1 08       	rjmp	8000c780 <_vfprintf_r+0x195c>
8000c762:	d7 03       	nop
8000c764:	80 01       	ld.sh	r1,r0[0x0]
8000c766:	91 b0       	st.w	r8[0x2c],r0
8000c768:	80 01       	ld.sh	r1,r0[0x0]
8000c76a:	91 9c       	st.w	r8[0x24],r12
8000c76c:	fa ca f9 78 	sub	r10,sp,-1672
8000c770:	02 9b       	mov	r11,r1
8000c772:	08 9c       	mov	r12,r4
8000c774:	fe b0 f3 4a 	rcall	8000ae08 <__sprint_r>
8000c778:	e0 81 02 e1 	brne	8000cd3a <_vfprintf_r+0x1f16>
8000c77c:	fa c3 f9 e0 	sub	r3,sp,-1568
8000c780:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000c784:	40 6c       	lddsp	r12,sp[0x18]
8000c786:	18 38       	cp.w	r8,r12
8000c788:	c0 55       	brlt	8000c792 <_vfprintf_r+0x196e>
8000c78a:	ed b5 00 00 	bld	r5,0x0
8000c78e:	e0 81 02 69 	brne	8000cc60 <_vfprintf_r+0x1e3c>
8000c792:	fa f8 06 90 	ld.w	r8,sp[1680]
8000c796:	2f f8       	sub	r8,-1
8000c798:	40 cb       	lddsp	r11,sp[0x30]
8000c79a:	fb 48 06 90 	st.w	sp[1680],r8
8000c79e:	30 19       	mov	r9,1
8000c7a0:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000c7a4:	87 0b       	st.w	r3[0x0],r11
8000c7a6:	2f f8       	sub	r8,-1
8000c7a8:	87 19       	st.w	r3[0x4],r9
8000c7aa:	fb 48 06 8c 	st.w	sp[1676],r8
8000c7ae:	58 78       	cp.w	r8,7
8000c7b0:	e0 89 00 04 	brgt	8000c7b8 <_vfprintf_r+0x1994>
8000c7b4:	2f 83       	sub	r3,-8
8000c7b6:	c0 b8       	rjmp	8000c7cc <_vfprintf_r+0x19a8>
8000c7b8:	fa ca f9 78 	sub	r10,sp,-1672
8000c7bc:	02 9b       	mov	r11,r1
8000c7be:	08 9c       	mov	r12,r4
8000c7c0:	fe b0 f3 24 	rcall	8000ae08 <__sprint_r>
8000c7c4:	e0 81 02 bb 	brne	8000cd3a <_vfprintf_r+0x1f16>
8000c7c8:	fa c3 f9 e0 	sub	r3,sp,-1568
8000c7cc:	40 66       	lddsp	r6,sp[0x18]
8000c7ce:	20 16       	sub	r6,1
8000c7d0:	58 06       	cp.w	r6,0
8000c7d2:	e0 89 00 1d 	brgt	8000c80c <_vfprintf_r+0x19e8>
8000c7d6:	e0 8f 02 45 	bral	8000cc60 <_vfprintf_r+0x1e3c>
8000c7da:	2f 09       	sub	r9,-16
8000c7dc:	2f f8       	sub	r8,-1
8000c7de:	fb 49 06 90 	st.w	sp[1680],r9
8000c7e2:	87 02       	st.w	r3[0x0],r2
8000c7e4:	87 10       	st.w	r3[0x4],r0
8000c7e6:	fb 48 06 8c 	st.w	sp[1676],r8
8000c7ea:	58 78       	cp.w	r8,7
8000c7ec:	e0 89 00 04 	brgt	8000c7f4 <_vfprintf_r+0x19d0>
8000c7f0:	2f 83       	sub	r3,-8
8000c7f2:	c0 b8       	rjmp	8000c808 <_vfprintf_r+0x19e4>
8000c7f4:	fa ca f9 78 	sub	r10,sp,-1672
8000c7f8:	02 9b       	mov	r11,r1
8000c7fa:	08 9c       	mov	r12,r4
8000c7fc:	fe b0 f3 06 	rcall	8000ae08 <__sprint_r>
8000c800:	e0 81 02 9d 	brne	8000cd3a <_vfprintf_r+0x1f16>
8000c804:	fa c3 f9 e0 	sub	r3,sp,-1568
8000c808:	21 06       	sub	r6,16
8000c80a:	c0 38       	rjmp	8000c810 <_vfprintf_r+0x19ec>
8000c80c:	4d 22       	lddpc	r2,8000c954 <_vfprintf_r+0x1b30>
8000c80e:	31 00       	mov	r0,16
8000c810:	fa f9 06 90 	ld.w	r9,sp[1680]
8000c814:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000c818:	4c fa       	lddpc	r10,8000c954 <_vfprintf_r+0x1b30>
8000c81a:	59 06       	cp.w	r6,16
8000c81c:	fe 99 ff df 	brgt	8000c7da <_vfprintf_r+0x19b6>
8000c820:	0c 09       	add	r9,r6
8000c822:	87 0a       	st.w	r3[0x0],r10
8000c824:	fb 49 06 90 	st.w	sp[1680],r9
8000c828:	2f f8       	sub	r8,-1
8000c82a:	87 16       	st.w	r3[0x4],r6
8000c82c:	c5 39       	rjmp	8000cad2 <_vfprintf_r+0x1cae>
8000c82e:	fa fa 06 ac 	ld.w	r10,sp[1708]
8000c832:	58 0a       	cp.w	r10,0
8000c834:	e0 89 00 94 	brgt	8000c95c <_vfprintf_r+0x1b38>
8000c838:	fa f8 06 90 	ld.w	r8,sp[1680]
8000c83c:	4c 79       	lddpc	r9,8000c958 <_vfprintf_r+0x1b34>
8000c83e:	2f f8       	sub	r8,-1
8000c840:	87 09       	st.w	r3[0x0],r9
8000c842:	fb 48 06 90 	st.w	sp[1680],r8
8000c846:	30 19       	mov	r9,1
8000c848:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000c84c:	87 19       	st.w	r3[0x4],r9
8000c84e:	2f f8       	sub	r8,-1
8000c850:	fb 48 06 8c 	st.w	sp[1676],r8
8000c854:	58 78       	cp.w	r8,7
8000c856:	e0 89 00 04 	brgt	8000c85e <_vfprintf_r+0x1a3a>
8000c85a:	2f 83       	sub	r3,-8
8000c85c:	c0 b8       	rjmp	8000c872 <_vfprintf_r+0x1a4e>
8000c85e:	fa ca f9 78 	sub	r10,sp,-1672
8000c862:	02 9b       	mov	r11,r1
8000c864:	08 9c       	mov	r12,r4
8000c866:	fe b0 f2 d1 	rcall	8000ae08 <__sprint_r>
8000c86a:	e0 81 02 68 	brne	8000cd3a <_vfprintf_r+0x1f16>
8000c86e:	fa c3 f9 e0 	sub	r3,sp,-1568
8000c872:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000c876:	58 08       	cp.w	r8,0
8000c878:	c0 81       	brne	8000c888 <_vfprintf_r+0x1a64>
8000c87a:	40 6a       	lddsp	r10,sp[0x18]
8000c87c:	58 0a       	cp.w	r10,0
8000c87e:	c0 51       	brne	8000c888 <_vfprintf_r+0x1a64>
8000c880:	ed b5 00 00 	bld	r5,0x0
8000c884:	e0 81 01 ee 	brne	8000cc60 <_vfprintf_r+0x1e3c>
8000c888:	40 c9       	lddsp	r9,sp[0x30]
8000c88a:	fa f8 06 90 	ld.w	r8,sp[1680]
8000c88e:	2f f8       	sub	r8,-1
8000c890:	87 09       	st.w	r3[0x0],r9
8000c892:	fb 48 06 90 	st.w	sp[1680],r8
8000c896:	30 19       	mov	r9,1
8000c898:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000c89c:	87 19       	st.w	r3[0x4],r9
8000c89e:	2f f8       	sub	r8,-1
8000c8a0:	fb 48 06 8c 	st.w	sp[1676],r8
8000c8a4:	58 78       	cp.w	r8,7
8000c8a6:	e0 89 00 04 	brgt	8000c8ae <_vfprintf_r+0x1a8a>
8000c8aa:	2f 83       	sub	r3,-8
8000c8ac:	c0 b8       	rjmp	8000c8c2 <_vfprintf_r+0x1a9e>
8000c8ae:	fa ca f9 78 	sub	r10,sp,-1672
8000c8b2:	02 9b       	mov	r11,r1
8000c8b4:	08 9c       	mov	r12,r4
8000c8b6:	fe b0 f2 a9 	rcall	8000ae08 <__sprint_r>
8000c8ba:	e0 81 02 40 	brne	8000cd3a <_vfprintf_r+0x1f16>
8000c8be:	fa c3 f9 e0 	sub	r3,sp,-1568
8000c8c2:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000c8c6:	5c 32       	neg	r2
8000c8c8:	58 02       	cp.w	r2,0
8000c8ca:	e0 89 00 1d 	brgt	8000c904 <_vfprintf_r+0x1ae0>
8000c8ce:	c3 b8       	rjmp	8000c944 <_vfprintf_r+0x1b20>
8000c8d0:	2f 09       	sub	r9,-16
8000c8d2:	2f f8       	sub	r8,-1
8000c8d4:	31 0e       	mov	lr,16
8000c8d6:	fb 49 06 90 	st.w	sp[1680],r9
8000c8da:	87 00       	st.w	r3[0x0],r0
8000c8dc:	87 1e       	st.w	r3[0x4],lr
8000c8de:	fb 48 06 8c 	st.w	sp[1676],r8
8000c8e2:	58 78       	cp.w	r8,7
8000c8e4:	e0 89 00 04 	brgt	8000c8ec <_vfprintf_r+0x1ac8>
8000c8e8:	2f 83       	sub	r3,-8
8000c8ea:	c0 b8       	rjmp	8000c900 <_vfprintf_r+0x1adc>
8000c8ec:	fa ca f9 78 	sub	r10,sp,-1672
8000c8f0:	02 9b       	mov	r11,r1
8000c8f2:	08 9c       	mov	r12,r4
8000c8f4:	fe b0 f2 8a 	rcall	8000ae08 <__sprint_r>
8000c8f8:	e0 81 02 21 	brne	8000cd3a <_vfprintf_r+0x1f16>
8000c8fc:	fa c3 f9 e0 	sub	r3,sp,-1568
8000c900:	21 02       	sub	r2,16
8000c902:	c0 28       	rjmp	8000c906 <_vfprintf_r+0x1ae2>
8000c904:	49 40       	lddpc	r0,8000c954 <_vfprintf_r+0x1b30>
8000c906:	fa f9 06 90 	ld.w	r9,sp[1680]
8000c90a:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000c90e:	49 2a       	lddpc	r10,8000c954 <_vfprintf_r+0x1b30>
8000c910:	59 02       	cp.w	r2,16
8000c912:	fe 99 ff df 	brgt	8000c8d0 <_vfprintf_r+0x1aac>
8000c916:	04 09       	add	r9,r2
8000c918:	2f f8       	sub	r8,-1
8000c91a:	87 0a       	st.w	r3[0x0],r10
8000c91c:	fb 49 06 90 	st.w	sp[1680],r9
8000c920:	87 12       	st.w	r3[0x4],r2
8000c922:	fb 48 06 8c 	st.w	sp[1676],r8
8000c926:	58 78       	cp.w	r8,7
8000c928:	e0 89 00 04 	brgt	8000c930 <_vfprintf_r+0x1b0c>
8000c92c:	2f 83       	sub	r3,-8
8000c92e:	c0 b8       	rjmp	8000c944 <_vfprintf_r+0x1b20>
8000c930:	fa ca f9 78 	sub	r10,sp,-1672
8000c934:	02 9b       	mov	r11,r1
8000c936:	08 9c       	mov	r12,r4
8000c938:	fe b0 f2 68 	rcall	8000ae08 <__sprint_r>
8000c93c:	e0 81 01 ff 	brne	8000cd3a <_vfprintf_r+0x1f16>
8000c940:	fa c3 f9 e0 	sub	r3,sp,-1568
8000c944:	40 6c       	lddsp	r12,sp[0x18]
8000c946:	fa f8 06 90 	ld.w	r8,sp[1680]
8000c94a:	87 06       	st.w	r3[0x0],r6
8000c94c:	87 1c       	st.w	r3[0x4],r12
8000c94e:	18 08       	add	r8,r12
8000c950:	cb c8       	rjmp	8000cac8 <_vfprintf_r+0x1ca4>
8000c952:	d7 03       	nop
8000c954:	80 01       	ld.sh	r1,r0[0x0]
8000c956:	91 b0       	st.w	r8[0x2c],r0
8000c958:	80 01       	ld.sh	r1,r0[0x0]
8000c95a:	91 9c       	st.w	r8[0x24],r12
8000c95c:	fa f9 06 90 	ld.w	r9,sp[1680]
8000c960:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000c964:	40 6b       	lddsp	r11,sp[0x18]
8000c966:	16 3a       	cp.w	r10,r11
8000c968:	c6 d5       	brlt	8000ca42 <_vfprintf_r+0x1c1e>
8000c96a:	16 09       	add	r9,r11
8000c96c:	2f f8       	sub	r8,-1
8000c96e:	87 06       	st.w	r3[0x0],r6
8000c970:	fb 49 06 90 	st.w	sp[1680],r9
8000c974:	87 1b       	st.w	r3[0x4],r11
8000c976:	fb 48 06 8c 	st.w	sp[1676],r8
8000c97a:	58 78       	cp.w	r8,7
8000c97c:	e0 89 00 04 	brgt	8000c984 <_vfprintf_r+0x1b60>
8000c980:	2f 83       	sub	r3,-8
8000c982:	c0 b8       	rjmp	8000c998 <_vfprintf_r+0x1b74>
8000c984:	fa ca f9 78 	sub	r10,sp,-1672
8000c988:	02 9b       	mov	r11,r1
8000c98a:	08 9c       	mov	r12,r4
8000c98c:	fe b0 f2 3e 	rcall	8000ae08 <__sprint_r>
8000c990:	e0 81 01 d5 	brne	8000cd3a <_vfprintf_r+0x1f16>
8000c994:	fa c3 f9 e0 	sub	r3,sp,-1568
8000c998:	fa f6 06 ac 	ld.w	r6,sp[1708]
8000c99c:	40 6a       	lddsp	r10,sp[0x18]
8000c99e:	14 16       	sub	r6,r10
8000c9a0:	58 06       	cp.w	r6,0
8000c9a2:	e0 89 00 1c 	brgt	8000c9da <_vfprintf_r+0x1bb6>
8000c9a6:	c3 b8       	rjmp	8000ca1c <_vfprintf_r+0x1bf8>
8000c9a8:	2f 09       	sub	r9,-16
8000c9aa:	2f f8       	sub	r8,-1
8000c9ac:	fb 49 06 90 	st.w	sp[1680],r9
8000c9b0:	87 02       	st.w	r3[0x0],r2
8000c9b2:	87 10       	st.w	r3[0x4],r0
8000c9b4:	fb 48 06 8c 	st.w	sp[1676],r8
8000c9b8:	58 78       	cp.w	r8,7
8000c9ba:	e0 89 00 04 	brgt	8000c9c2 <_vfprintf_r+0x1b9e>
8000c9be:	2f 83       	sub	r3,-8
8000c9c0:	c0 b8       	rjmp	8000c9d6 <_vfprintf_r+0x1bb2>
8000c9c2:	fa ca f9 78 	sub	r10,sp,-1672
8000c9c6:	02 9b       	mov	r11,r1
8000c9c8:	08 9c       	mov	r12,r4
8000c9ca:	fe b0 f2 1f 	rcall	8000ae08 <__sprint_r>
8000c9ce:	e0 81 01 b6 	brne	8000cd3a <_vfprintf_r+0x1f16>
8000c9d2:	fa c3 f9 e0 	sub	r3,sp,-1568
8000c9d6:	21 06       	sub	r6,16
8000c9d8:	c0 38       	rjmp	8000c9de <_vfprintf_r+0x1bba>
8000c9da:	4d c2       	lddpc	r2,8000cb48 <_vfprintf_r+0x1d24>
8000c9dc:	31 00       	mov	r0,16
8000c9de:	fa f9 06 90 	ld.w	r9,sp[1680]
8000c9e2:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000c9e6:	4d 9a       	lddpc	r10,8000cb48 <_vfprintf_r+0x1d24>
8000c9e8:	59 06       	cp.w	r6,16
8000c9ea:	fe 99 ff df 	brgt	8000c9a8 <_vfprintf_r+0x1b84>
8000c9ee:	0c 09       	add	r9,r6
8000c9f0:	2f f8       	sub	r8,-1
8000c9f2:	87 0a       	st.w	r3[0x0],r10
8000c9f4:	fb 49 06 90 	st.w	sp[1680],r9
8000c9f8:	87 16       	st.w	r3[0x4],r6
8000c9fa:	fb 48 06 8c 	st.w	sp[1676],r8
8000c9fe:	58 78       	cp.w	r8,7
8000ca00:	e0 89 00 04 	brgt	8000ca08 <_vfprintf_r+0x1be4>
8000ca04:	2f 83       	sub	r3,-8
8000ca06:	c0 b8       	rjmp	8000ca1c <_vfprintf_r+0x1bf8>
8000ca08:	fa ca f9 78 	sub	r10,sp,-1672
8000ca0c:	02 9b       	mov	r11,r1
8000ca0e:	08 9c       	mov	r12,r4
8000ca10:	fe b0 f1 fc 	rcall	8000ae08 <__sprint_r>
8000ca14:	e0 81 01 93 	brne	8000cd3a <_vfprintf_r+0x1f16>
8000ca18:	fa c3 f9 e0 	sub	r3,sp,-1568
8000ca1c:	ed b5 00 00 	bld	r5,0x0
8000ca20:	e0 81 01 20 	brne	8000cc60 <_vfprintf_r+0x1e3c>
8000ca24:	40 c9       	lddsp	r9,sp[0x30]
8000ca26:	fa f8 06 90 	ld.w	r8,sp[1680]
8000ca2a:	2f f8       	sub	r8,-1
8000ca2c:	87 09       	st.w	r3[0x0],r9
8000ca2e:	fb 48 06 90 	st.w	sp[1680],r8
8000ca32:	30 19       	mov	r9,1
8000ca34:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000ca38:	87 19       	st.w	r3[0x4],r9
8000ca3a:	2f f8       	sub	r8,-1
8000ca3c:	fb 48 06 8c 	st.w	sp[1676],r8
8000ca40:	c0 29       	rjmp	8000cc44 <_vfprintf_r+0x1e20>
8000ca42:	14 09       	add	r9,r10
8000ca44:	2f f8       	sub	r8,-1
8000ca46:	fb 49 06 90 	st.w	sp[1680],r9
8000ca4a:	87 06       	st.w	r3[0x0],r6
8000ca4c:	87 1a       	st.w	r3[0x4],r10
8000ca4e:	fb 48 06 8c 	st.w	sp[1676],r8
8000ca52:	58 78       	cp.w	r8,7
8000ca54:	e0 89 00 04 	brgt	8000ca5c <_vfprintf_r+0x1c38>
8000ca58:	2f 83       	sub	r3,-8
8000ca5a:	c0 b8       	rjmp	8000ca70 <_vfprintf_r+0x1c4c>
8000ca5c:	fa ca f9 78 	sub	r10,sp,-1672
8000ca60:	02 9b       	mov	r11,r1
8000ca62:	08 9c       	mov	r12,r4
8000ca64:	fe b0 f1 d2 	rcall	8000ae08 <__sprint_r>
8000ca68:	e0 81 01 69 	brne	8000cd3a <_vfprintf_r+0x1f16>
8000ca6c:	fa c3 f9 e0 	sub	r3,sp,-1568
8000ca70:	40 c8       	lddsp	r8,sp[0x30]
8000ca72:	87 08       	st.w	r3[0x0],r8
8000ca74:	fa f8 06 90 	ld.w	r8,sp[1680]
8000ca78:	2f f8       	sub	r8,-1
8000ca7a:	30 19       	mov	r9,1
8000ca7c:	fb 48 06 90 	st.w	sp[1680],r8
8000ca80:	87 19       	st.w	r3[0x4],r9
8000ca82:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000ca86:	2f f8       	sub	r8,-1
8000ca88:	fb 48 06 8c 	st.w	sp[1676],r8
8000ca8c:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000ca90:	58 78       	cp.w	r8,7
8000ca92:	e0 89 00 04 	brgt	8000ca9a <_vfprintf_r+0x1c76>
8000ca96:	2f 83       	sub	r3,-8
8000ca98:	c0 b8       	rjmp	8000caae <_vfprintf_r+0x1c8a>
8000ca9a:	fa ca f9 78 	sub	r10,sp,-1672
8000ca9e:	02 9b       	mov	r11,r1
8000caa0:	08 9c       	mov	r12,r4
8000caa2:	fe b0 f1 b3 	rcall	8000ae08 <__sprint_r>
8000caa6:	e0 81 01 4a 	brne	8000cd3a <_vfprintf_r+0x1f16>
8000caaa:	fa c3 f9 e0 	sub	r3,sp,-1568
8000caae:	04 06       	add	r6,r2
8000cab0:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000cab4:	87 06       	st.w	r3[0x0],r6
8000cab6:	fa f9 06 90 	ld.w	r9,sp[1680]
8000caba:	40 66       	lddsp	r6,sp[0x18]
8000cabc:	40 6e       	lddsp	lr,sp[0x18]
8000cabe:	10 16       	sub	r6,r8
8000cac0:	f2 08 01 08 	sub	r8,r9,r8
8000cac4:	87 16       	st.w	r3[0x4],r6
8000cac6:	1c 08       	add	r8,lr
8000cac8:	fb 48 06 90 	st.w	sp[1680],r8
8000cacc:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000cad0:	2f f8       	sub	r8,-1
8000cad2:	fb 48 06 8c 	st.w	sp[1676],r8
8000cad6:	cb 78       	rjmp	8000cc44 <_vfprintf_r+0x1e20>
8000cad8:	40 6c       	lddsp	r12,sp[0x18]
8000cada:	58 1c       	cp.w	r12,1
8000cadc:	e0 89 00 06 	brgt	8000cae8 <_vfprintf_r+0x1cc4>
8000cae0:	ed b5 00 00 	bld	r5,0x0
8000cae4:	e0 81 00 85 	brne	8000cbee <_vfprintf_r+0x1dca>
8000cae8:	fa f8 06 90 	ld.w	r8,sp[1680]
8000caec:	2f f8       	sub	r8,-1
8000caee:	30 19       	mov	r9,1
8000caf0:	fb 48 06 90 	st.w	sp[1680],r8
8000caf4:	87 06       	st.w	r3[0x0],r6
8000caf6:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000cafa:	87 19       	st.w	r3[0x4],r9
8000cafc:	2f f8       	sub	r8,-1
8000cafe:	fb 48 06 8c 	st.w	sp[1676],r8
8000cb02:	58 78       	cp.w	r8,7
8000cb04:	e0 89 00 04 	brgt	8000cb0c <_vfprintf_r+0x1ce8>
8000cb08:	2f 83       	sub	r3,-8
8000cb0a:	c0 b8       	rjmp	8000cb20 <_vfprintf_r+0x1cfc>
8000cb0c:	fa ca f9 78 	sub	r10,sp,-1672
8000cb10:	02 9b       	mov	r11,r1
8000cb12:	08 9c       	mov	r12,r4
8000cb14:	fe b0 f1 7a 	rcall	8000ae08 <__sprint_r>
8000cb18:	e0 81 01 11 	brne	8000cd3a <_vfprintf_r+0x1f16>
8000cb1c:	fa c3 f9 e0 	sub	r3,sp,-1568
8000cb20:	fa f8 06 90 	ld.w	r8,sp[1680]
8000cb24:	2f f8       	sub	r8,-1
8000cb26:	40 cb       	lddsp	r11,sp[0x30]
8000cb28:	fb 48 06 90 	st.w	sp[1680],r8
8000cb2c:	30 19       	mov	r9,1
8000cb2e:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000cb32:	87 0b       	st.w	r3[0x0],r11
8000cb34:	2f f8       	sub	r8,-1
8000cb36:	87 19       	st.w	r3[0x4],r9
8000cb38:	fb 48 06 8c 	st.w	sp[1676],r8
8000cb3c:	58 78       	cp.w	r8,7
8000cb3e:	e0 89 00 07 	brgt	8000cb4c <_vfprintf_r+0x1d28>
8000cb42:	2f 83       	sub	r3,-8
8000cb44:	c0 e8       	rjmp	8000cb60 <_vfprintf_r+0x1d3c>
8000cb46:	d7 03       	nop
8000cb48:	80 01       	ld.sh	r1,r0[0x0]
8000cb4a:	91 b0       	st.w	r8[0x2c],r0
8000cb4c:	fa ca f9 78 	sub	r10,sp,-1672
8000cb50:	02 9b       	mov	r11,r1
8000cb52:	08 9c       	mov	r12,r4
8000cb54:	fe b0 f1 5a 	rcall	8000ae08 <__sprint_r>
8000cb58:	e0 81 00 f1 	brne	8000cd3a <_vfprintf_r+0x1f16>
8000cb5c:	fa c3 f9 e0 	sub	r3,sp,-1568
8000cb60:	30 08       	mov	r8,0
8000cb62:	30 09       	mov	r9,0
8000cb64:	40 5b       	lddsp	r11,sp[0x14]
8000cb66:	40 7a       	lddsp	r10,sp[0x1c]
8000cb68:	e0 a0 13 25 	rcall	8000f1b2 <__avr32_f64_cmp_eq>
8000cb6c:	40 68       	lddsp	r8,sp[0x18]
8000cb6e:	20 18       	sub	r8,1
8000cb70:	58 0c       	cp.w	r12,0
8000cb72:	c0 d1       	brne	8000cb8c <_vfprintf_r+0x1d68>
8000cb74:	2f f6       	sub	r6,-1
8000cb76:	87 18       	st.w	r3[0x4],r8
8000cb78:	87 06       	st.w	r3[0x0],r6
8000cb7a:	fa f6 06 90 	ld.w	r6,sp[1680]
8000cb7e:	10 06       	add	r6,r8
8000cb80:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000cb84:	fb 46 06 90 	st.w	sp[1680],r6
8000cb88:	2f f8       	sub	r8,-1
8000cb8a:	c2 f8       	rjmp	8000cbe8 <_vfprintf_r+0x1dc4>
8000cb8c:	10 96       	mov	r6,r8
8000cb8e:	58 08       	cp.w	r8,0
8000cb90:	e0 89 00 1c 	brgt	8000cbc8 <_vfprintf_r+0x1da4>
8000cb94:	c4 98       	rjmp	8000cc26 <_vfprintf_r+0x1e02>
8000cb96:	2f 09       	sub	r9,-16
8000cb98:	2f f8       	sub	r8,-1
8000cb9a:	fb 49 06 90 	st.w	sp[1680],r9
8000cb9e:	87 02       	st.w	r3[0x0],r2
8000cba0:	87 10       	st.w	r3[0x4],r0
8000cba2:	fb 48 06 8c 	st.w	sp[1676],r8
8000cba6:	58 78       	cp.w	r8,7
8000cba8:	e0 89 00 04 	brgt	8000cbb0 <_vfprintf_r+0x1d8c>
8000cbac:	2f 83       	sub	r3,-8
8000cbae:	c0 b8       	rjmp	8000cbc4 <_vfprintf_r+0x1da0>
8000cbb0:	fa ca f9 78 	sub	r10,sp,-1672
8000cbb4:	02 9b       	mov	r11,r1
8000cbb6:	08 9c       	mov	r12,r4
8000cbb8:	fe b0 f1 28 	rcall	8000ae08 <__sprint_r>
8000cbbc:	e0 81 00 bf 	brne	8000cd3a <_vfprintf_r+0x1f16>
8000cbc0:	fa c3 f9 e0 	sub	r3,sp,-1568
8000cbc4:	21 06       	sub	r6,16
8000cbc6:	c0 38       	rjmp	8000cbcc <_vfprintf_r+0x1da8>
8000cbc8:	4d 22       	lddpc	r2,8000cd10 <_vfprintf_r+0x1eec>
8000cbca:	31 00       	mov	r0,16
8000cbcc:	fa f9 06 90 	ld.w	r9,sp[1680]
8000cbd0:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000cbd4:	4c fa       	lddpc	r10,8000cd10 <_vfprintf_r+0x1eec>
8000cbd6:	59 06       	cp.w	r6,16
8000cbd8:	fe 99 ff df 	brgt	8000cb96 <_vfprintf_r+0x1d72>
8000cbdc:	0c 09       	add	r9,r6
8000cbde:	87 0a       	st.w	r3[0x0],r10
8000cbe0:	fb 49 06 90 	st.w	sp[1680],r9
8000cbe4:	2f f8       	sub	r8,-1
8000cbe6:	87 16       	st.w	r3[0x4],r6
8000cbe8:	fb 48 06 8c 	st.w	sp[1676],r8
8000cbec:	c0 e8       	rjmp	8000cc08 <_vfprintf_r+0x1de4>
8000cbee:	fa f8 06 90 	ld.w	r8,sp[1680]
8000cbf2:	2f f8       	sub	r8,-1
8000cbf4:	30 19       	mov	r9,1
8000cbf6:	fb 48 06 90 	st.w	sp[1680],r8
8000cbfa:	87 06       	st.w	r3[0x0],r6
8000cbfc:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000cc00:	87 19       	st.w	r3[0x4],r9
8000cc02:	2f f8       	sub	r8,-1
8000cc04:	fb 48 06 8c 	st.w	sp[1676],r8
8000cc08:	58 78       	cp.w	r8,7
8000cc0a:	e0 89 00 04 	brgt	8000cc12 <_vfprintf_r+0x1dee>
8000cc0e:	2f 83       	sub	r3,-8
8000cc10:	c0 b8       	rjmp	8000cc26 <_vfprintf_r+0x1e02>
8000cc12:	fa ca f9 78 	sub	r10,sp,-1672
8000cc16:	02 9b       	mov	r11,r1
8000cc18:	08 9c       	mov	r12,r4
8000cc1a:	fe b0 f0 f7 	rcall	8000ae08 <__sprint_r>
8000cc1e:	e0 81 00 8e 	brne	8000cd3a <_vfprintf_r+0x1f16>
8000cc22:	fa c3 f9 e0 	sub	r3,sp,-1568
8000cc26:	40 ea       	lddsp	r10,sp[0x38]
8000cc28:	fa f8 06 90 	ld.w	r8,sp[1680]
8000cc2c:	14 08       	add	r8,r10
8000cc2e:	fa c9 f9 64 	sub	r9,sp,-1692
8000cc32:	fb 48 06 90 	st.w	sp[1680],r8
8000cc36:	87 1a       	st.w	r3[0x4],r10
8000cc38:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000cc3c:	87 09       	st.w	r3[0x0],r9
8000cc3e:	2f f8       	sub	r8,-1
8000cc40:	fb 48 06 8c 	st.w	sp[1676],r8
8000cc44:	58 78       	cp.w	r8,7
8000cc46:	e0 89 00 04 	brgt	8000cc4e <_vfprintf_r+0x1e2a>
8000cc4a:	2f 83       	sub	r3,-8
8000cc4c:	c0 a8       	rjmp	8000cc60 <_vfprintf_r+0x1e3c>
8000cc4e:	fa ca f9 78 	sub	r10,sp,-1672
8000cc52:	02 9b       	mov	r11,r1
8000cc54:	08 9c       	mov	r12,r4
8000cc56:	fe b0 f0 d9 	rcall	8000ae08 <__sprint_r>
8000cc5a:	c7 01       	brne	8000cd3a <_vfprintf_r+0x1f16>
8000cc5c:	fa c3 f9 e0 	sub	r3,sp,-1568
8000cc60:	e2 15 00 04 	andl	r5,0x4,COH
8000cc64:	c3 d0       	breq	8000ccde <_vfprintf_r+0x1eba>
8000cc66:	40 86       	lddsp	r6,sp[0x20]
8000cc68:	40 39       	lddsp	r9,sp[0xc]
8000cc6a:	12 16       	sub	r6,r9
8000cc6c:	58 06       	cp.w	r6,0
8000cc6e:	e0 89 00 1a 	brgt	8000cca2 <_vfprintf_r+0x1e7e>
8000cc72:	c3 68       	rjmp	8000ccde <_vfprintf_r+0x1eba>
8000cc74:	2f 09       	sub	r9,-16
8000cc76:	2f f8       	sub	r8,-1
8000cc78:	fb 49 06 90 	st.w	sp[1680],r9
8000cc7c:	87 05       	st.w	r3[0x0],r5
8000cc7e:	87 12       	st.w	r3[0x4],r2
8000cc80:	fb 48 06 8c 	st.w	sp[1676],r8
8000cc84:	58 78       	cp.w	r8,7
8000cc86:	e0 89 00 04 	brgt	8000cc8e <_vfprintf_r+0x1e6a>
8000cc8a:	2f 83       	sub	r3,-8
8000cc8c:	c0 98       	rjmp	8000cc9e <_vfprintf_r+0x1e7a>
8000cc8e:	00 9a       	mov	r10,r0
8000cc90:	02 9b       	mov	r11,r1
8000cc92:	08 9c       	mov	r12,r4
8000cc94:	fe b0 f0 ba 	rcall	8000ae08 <__sprint_r>
8000cc98:	c5 11       	brne	8000cd3a <_vfprintf_r+0x1f16>
8000cc9a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000cc9e:	21 06       	sub	r6,16
8000cca0:	c0 58       	rjmp	8000ccaa <_vfprintf_r+0x1e86>
8000cca2:	49 d5       	lddpc	r5,8000cd14 <_vfprintf_r+0x1ef0>
8000cca4:	31 02       	mov	r2,16
8000cca6:	fa c0 f9 78 	sub	r0,sp,-1672
8000ccaa:	fa f9 06 90 	ld.w	r9,sp[1680]
8000ccae:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000ccb2:	49 9a       	lddpc	r10,8000cd14 <_vfprintf_r+0x1ef0>
8000ccb4:	59 06       	cp.w	r6,16
8000ccb6:	fe 99 ff df 	brgt	8000cc74 <_vfprintf_r+0x1e50>
8000ccba:	0c 09       	add	r9,r6
8000ccbc:	2f f8       	sub	r8,-1
8000ccbe:	87 0a       	st.w	r3[0x0],r10
8000ccc0:	87 16       	st.w	r3[0x4],r6
8000ccc2:	fb 49 06 90 	st.w	sp[1680],r9
8000ccc6:	fb 48 06 8c 	st.w	sp[1676],r8
8000ccca:	58 78       	cp.w	r8,7
8000cccc:	e0 8a 00 09 	brle	8000ccde <_vfprintf_r+0x1eba>
8000ccd0:	fa ca f9 78 	sub	r10,sp,-1672
8000ccd4:	02 9b       	mov	r11,r1
8000ccd6:	08 9c       	mov	r12,r4
8000ccd8:	fe b0 f0 98 	rcall	8000ae08 <__sprint_r>
8000ccdc:	c2 f1       	brne	8000cd3a <_vfprintf_r+0x1f16>
8000ccde:	40 bc       	lddsp	r12,sp[0x2c]
8000cce0:	40 36       	lddsp	r6,sp[0xc]
8000cce2:	40 8e       	lddsp	lr,sp[0x20]
8000cce4:	ec 0e 0c 48 	max	r8,r6,lr
8000cce8:	10 0c       	add	r12,r8
8000ccea:	50 bc       	stdsp	sp[0x2c],r12
8000ccec:	fa f8 06 90 	ld.w	r8,sp[1680]
8000ccf0:	58 08       	cp.w	r8,0
8000ccf2:	c0 80       	breq	8000cd02 <_vfprintf_r+0x1ede>
8000ccf4:	fa ca f9 78 	sub	r10,sp,-1672
8000ccf8:	02 9b       	mov	r11,r1
8000ccfa:	08 9c       	mov	r12,r4
8000ccfc:	fe b0 f0 86 	rcall	8000ae08 <__sprint_r>
8000cd00:	c1 d1       	brne	8000cd3a <_vfprintf_r+0x1f16>
8000cd02:	30 0b       	mov	r11,0
8000cd04:	fa c3 f9 e0 	sub	r3,sp,-1568
8000cd08:	fb 4b 06 8c 	st.w	sp[1676],r11
8000cd0c:	fe 9f f1 17 	bral	8000af3a <_vfprintf_r+0x116>
8000cd10:	80 01       	ld.sh	r1,r0[0x0]
8000cd12:	91 b0       	st.w	r8[0x2c],r0
8000cd14:	80 01       	ld.sh	r1,r0[0x0]
8000cd16:	91 a0       	st.w	r8[0x28],r0
8000cd18:	08 95       	mov	r5,r4
8000cd1a:	fa f8 06 90 	ld.w	r8,sp[1680]
8000cd1e:	58 08       	cp.w	r8,0
8000cd20:	c0 80       	breq	8000cd30 <_vfprintf_r+0x1f0c>
8000cd22:	08 9c       	mov	r12,r4
8000cd24:	fa ca f9 78 	sub	r10,sp,-1672
8000cd28:	02 9b       	mov	r11,r1
8000cd2a:	fe b0 f0 6f 	rcall	8000ae08 <__sprint_r>
8000cd2e:	c0 61       	brne	8000cd3a <_vfprintf_r+0x1f16>
8000cd30:	30 08       	mov	r8,0
8000cd32:	fb 48 06 8c 	st.w	sp[1676],r8
8000cd36:	c0 28       	rjmp	8000cd3a <_vfprintf_r+0x1f16>
8000cd38:	40 41       	lddsp	r1,sp[0x10]
8000cd3a:	82 68       	ld.sh	r8,r1[0xc]
8000cd3c:	ed b8 00 06 	bld	r8,0x6
8000cd40:	c0 31       	brne	8000cd46 <_vfprintf_r+0x1f22>
8000cd42:	3f fa       	mov	r10,-1
8000cd44:	50 ba       	stdsp	sp[0x2c],r10
8000cd46:	40 bc       	lddsp	r12,sp[0x2c]
8000cd48:	fe 3d f9 44 	sub	sp,-1724
8000cd4c:	d8 32       	popm	r0-r7,pc
8000cd4e:	d7 03       	nop

8000cd50 <__swsetup_r>:
8000cd50:	d4 21       	pushm	r4-r7,lr
8000cd52:	e0 68 0a 38 	mov	r8,2616
8000cd56:	18 96       	mov	r6,r12
8000cd58:	16 97       	mov	r7,r11
8000cd5a:	70 0c       	ld.w	r12,r8[0x0]
8000cd5c:	58 0c       	cp.w	r12,0
8000cd5e:	c0 60       	breq	8000cd6a <__swsetup_r+0x1a>
8000cd60:	78 68       	ld.w	r8,r12[0x18]
8000cd62:	58 08       	cp.w	r8,0
8000cd64:	c0 31       	brne	8000cd6a <__swsetup_r+0x1a>
8000cd66:	e0 a0 07 c7 	rcall	8000dcf4 <__sinit>
8000cd6a:	4a f8       	lddpc	r8,8000ce24 <__swsetup_r+0xd4>
8000cd6c:	10 37       	cp.w	r7,r8
8000cd6e:	c0 61       	brne	8000cd7a <__swsetup_r+0x2a>
8000cd70:	e0 68 0a 38 	mov	r8,2616
8000cd74:	70 08       	ld.w	r8,r8[0x0]
8000cd76:	70 07       	ld.w	r7,r8[0x0]
8000cd78:	c1 08       	rjmp	8000cd98 <__swsetup_r+0x48>
8000cd7a:	4a c8       	lddpc	r8,8000ce28 <__swsetup_r+0xd8>
8000cd7c:	10 37       	cp.w	r7,r8
8000cd7e:	c0 61       	brne	8000cd8a <__swsetup_r+0x3a>
8000cd80:	e0 68 0a 38 	mov	r8,2616
8000cd84:	70 08       	ld.w	r8,r8[0x0]
8000cd86:	70 17       	ld.w	r7,r8[0x4]
8000cd88:	c0 88       	rjmp	8000cd98 <__swsetup_r+0x48>
8000cd8a:	4a 98       	lddpc	r8,8000ce2c <__swsetup_r+0xdc>
8000cd8c:	10 37       	cp.w	r7,r8
8000cd8e:	c0 51       	brne	8000cd98 <__swsetup_r+0x48>
8000cd90:	e0 68 0a 38 	mov	r8,2616
8000cd94:	70 08       	ld.w	r8,r8[0x0]
8000cd96:	70 27       	ld.w	r7,r8[0x8]
8000cd98:	8e 68       	ld.sh	r8,r7[0xc]
8000cd9a:	ed b8 00 03 	bld	r8,0x3
8000cd9e:	c1 e0       	breq	8000cdda <__swsetup_r+0x8a>
8000cda0:	ed b8 00 04 	bld	r8,0x4
8000cda4:	c3 e1       	brne	8000ce20 <__swsetup_r+0xd0>
8000cda6:	ed b8 00 02 	bld	r8,0x2
8000cdaa:	c1 51       	brne	8000cdd4 <__swsetup_r+0x84>
8000cdac:	6e db       	ld.w	r11,r7[0x34]
8000cdae:	58 0b       	cp.w	r11,0
8000cdb0:	c0 a0       	breq	8000cdc4 <__swsetup_r+0x74>
8000cdb2:	ee c8 ff bc 	sub	r8,r7,-68
8000cdb6:	10 3b       	cp.w	r11,r8
8000cdb8:	c0 40       	breq	8000cdc0 <__swsetup_r+0x70>
8000cdba:	0c 9c       	mov	r12,r6
8000cdbc:	e0 a0 08 36 	rcall	8000de28 <_free_r>
8000cdc0:	30 08       	mov	r8,0
8000cdc2:	8f d8       	st.w	r7[0x34],r8
8000cdc4:	8e 68       	ld.sh	r8,r7[0xc]
8000cdc6:	e0 18 ff db 	andl	r8,0xffdb
8000cdca:	ae 68       	st.h	r7[0xc],r8
8000cdcc:	30 08       	mov	r8,0
8000cdce:	8f 18       	st.w	r7[0x4],r8
8000cdd0:	6e 48       	ld.w	r8,r7[0x10]
8000cdd2:	8f 08       	st.w	r7[0x0],r8
8000cdd4:	8e 68       	ld.sh	r8,r7[0xc]
8000cdd6:	a3 b8       	sbr	r8,0x3
8000cdd8:	ae 68       	st.h	r7[0xc],r8
8000cdda:	6e 48       	ld.w	r8,r7[0x10]
8000cddc:	58 08       	cp.w	r8,0
8000cdde:	c0 b1       	brne	8000cdf4 <__swsetup_r+0xa4>
8000cde0:	8e 68       	ld.sh	r8,r7[0xc]
8000cde2:	e2 18 02 80 	andl	r8,0x280,COH
8000cde6:	e0 48 02 00 	cp.w	r8,512
8000cdea:	c0 50       	breq	8000cdf4 <__swsetup_r+0xa4>
8000cdec:	0c 9c       	mov	r12,r6
8000cdee:	0e 9b       	mov	r11,r7
8000cdf0:	e0 a0 0a 56 	rcall	8000e29c <__smakebuf_r>
8000cdf4:	8e 69       	ld.sh	r9,r7[0xc]
8000cdf6:	f1 d9 c0 01 	bfextu	r8,r9,0x0,0x1
8000cdfa:	c0 70       	breq	8000ce08 <__swsetup_r+0xb8>
8000cdfc:	30 08       	mov	r8,0
8000cdfe:	8f 28       	st.w	r7[0x8],r8
8000ce00:	6e 58       	ld.w	r8,r7[0x14]
8000ce02:	5c 38       	neg	r8
8000ce04:	8f 68       	st.w	r7[0x18],r8
8000ce06:	c0 68       	rjmp	8000ce12 <__swsetup_r+0xc2>
8000ce08:	ed b9 00 01 	bld	r9,0x1
8000ce0c:	ef f8 10 05 	ld.wne	r8,r7[0x14]
8000ce10:	8f 28       	st.w	r7[0x8],r8
8000ce12:	6e 48       	ld.w	r8,r7[0x10]
8000ce14:	58 08       	cp.w	r8,0
8000ce16:	c0 61       	brne	8000ce22 <__swsetup_r+0xd2>
8000ce18:	8e 68       	ld.sh	r8,r7[0xc]
8000ce1a:	ed b8 00 07 	bld	r8,0x7
8000ce1e:	c0 21       	brne	8000ce22 <__swsetup_r+0xd2>
8000ce20:	dc 2a       	popm	r4-r7,pc,r12=-1
8000ce22:	d8 2a       	popm	r4-r7,pc,r12=0
8000ce24:	80 01       	ld.sh	r1,r0[0x0]
8000ce26:	92 d0       	ld.uh	r0,r9[0xa]
8000ce28:	80 01       	ld.sh	r1,r0[0x0]
8000ce2a:	92 f0       	ld.uh	r0,r9[0xe]
8000ce2c:	80 01       	ld.sh	r1,r0[0x0]
8000ce2e:	93 10       	st.w	r9[0x4],r0

8000ce30 <quorem>:
8000ce30:	d4 31       	pushm	r0-r7,lr
8000ce32:	20 2d       	sub	sp,8
8000ce34:	18 97       	mov	r7,r12
8000ce36:	78 48       	ld.w	r8,r12[0x10]
8000ce38:	76 46       	ld.w	r6,r11[0x10]
8000ce3a:	0c 38       	cp.w	r8,r6
8000ce3c:	c0 34       	brge	8000ce42 <quorem+0x12>
8000ce3e:	30 0c       	mov	r12,0
8000ce40:	c8 58       	rjmp	8000cf4a <quorem+0x11a>
8000ce42:	ec c2 ff fc 	sub	r2,r6,-4
8000ce46:	f6 c3 ff ec 	sub	r3,r11,-20
8000ce4a:	f6 02 03 29 	ld.w	r9,r11[r2<<0x2]
8000ce4e:	f8 02 03 2c 	ld.w	r12,r12[r2<<0x2]
8000ce52:	2f f9       	sub	r9,-1
8000ce54:	20 16       	sub	r6,1
8000ce56:	f8 09 0d 08 	divu	r8,r12,r9
8000ce5a:	f6 02 00 22 	add	r2,r11,r2<<0x2
8000ce5e:	ee c4 ff ec 	sub	r4,r7,-20
8000ce62:	10 95       	mov	r5,r8
8000ce64:	58 08       	cp.w	r8,0
8000ce66:	c4 10       	breq	8000cee8 <quorem+0xb8>
8000ce68:	30 09       	mov	r9,0
8000ce6a:	06 9a       	mov	r10,r3
8000ce6c:	08 98       	mov	r8,r4
8000ce6e:	12 91       	mov	r1,r9
8000ce70:	50 0b       	stdsp	sp[0x0],r11
8000ce72:	70 0e       	ld.w	lr,r8[0x0]
8000ce74:	b1 8e       	lsr	lr,0x10
8000ce76:	50 1e       	stdsp	sp[0x4],lr
8000ce78:	15 0e       	ld.w	lr,r10++
8000ce7a:	fc 00 16 10 	lsr	r0,lr,0x10
8000ce7e:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000ce82:	ea 0e 03 41 	mac	r1,r5,lr
8000ce86:	fd d1 c0 10 	bfextu	lr,r1,0x0,0x10
8000ce8a:	b1 81       	lsr	r1,0x10
8000ce8c:	40 1b       	lddsp	r11,sp[0x4]
8000ce8e:	ea 00 02 40 	mul	r0,r5,r0
8000ce92:	e2 00 00 00 	add	r0,r1,r0
8000ce96:	e3 d0 c0 10 	bfextu	r1,r0,0x0,0x10
8000ce9a:	02 1b       	sub	r11,r1
8000ce9c:	50 1b       	stdsp	sp[0x4],r11
8000ce9e:	70 0b       	ld.w	r11,r8[0x0]
8000cea0:	e3 db c0 10 	bfextu	r1,r11,0x0,0x10
8000cea4:	02 09       	add	r9,r1
8000cea6:	f2 0e 01 0e 	sub	lr,r9,lr
8000ceaa:	b0 1e       	st.h	r8[0x2],lr
8000ceac:	fc 09 14 10 	asr	r9,lr,0x10
8000ceb0:	40 1e       	lddsp	lr,sp[0x4]
8000ceb2:	fc 09 00 09 	add	r9,lr,r9
8000ceb6:	b0 09       	st.h	r8[0x0],r9
8000ceb8:	e0 01 16 10 	lsr	r1,r0,0x10
8000cebc:	2f c8       	sub	r8,-4
8000cebe:	b1 49       	asr	r9,0x10
8000cec0:	04 3a       	cp.w	r10,r2
8000cec2:	fe 98 ff d8 	brls	8000ce72 <quorem+0x42>
8000cec6:	40 0b       	lddsp	r11,sp[0x0]
8000cec8:	58 0c       	cp.w	r12,0
8000ceca:	c0 f1       	brne	8000cee8 <quorem+0xb8>
8000cecc:	ec c8 ff fb 	sub	r8,r6,-5
8000ced0:	ee 08 00 28 	add	r8,r7,r8<<0x2
8000ced4:	c0 28       	rjmp	8000ced8 <quorem+0xa8>
8000ced6:	20 16       	sub	r6,1
8000ced8:	20 48       	sub	r8,4
8000ceda:	08 38       	cp.w	r8,r4
8000cedc:	e0 88 00 05 	brls	8000cee6 <quorem+0xb6>
8000cee0:	70 09       	ld.w	r9,r8[0x0]
8000cee2:	58 09       	cp.w	r9,0
8000cee4:	cf 90       	breq	8000ced6 <quorem+0xa6>
8000cee6:	8f 46       	st.w	r7[0x10],r6
8000cee8:	0e 9c       	mov	r12,r7
8000ceea:	e0 a0 0a d8 	rcall	8000e49a <__mcmp>
8000ceee:	c2 d5       	brlt	8000cf48 <quorem+0x118>
8000cef0:	2f f5       	sub	r5,-1
8000cef2:	08 98       	mov	r8,r4
8000cef4:	30 09       	mov	r9,0
8000cef6:	07 0b       	ld.w	r11,r3++
8000cef8:	f6 0a 16 10 	lsr	r10,r11,0x10
8000cefc:	70 0c       	ld.w	r12,r8[0x0]
8000cefe:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000cf02:	f8 0e 16 10 	lsr	lr,r12,0x10
8000cf06:	14 1e       	sub	lr,r10
8000cf08:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000cf0c:	16 1a       	sub	r10,r11
8000cf0e:	12 0a       	add	r10,r9
8000cf10:	b0 1a       	st.h	r8[0x2],r10
8000cf12:	b1 4a       	asr	r10,0x10
8000cf14:	fc 0a 00 09 	add	r9,lr,r10
8000cf18:	b0 09       	st.h	r8[0x0],r9
8000cf1a:	2f c8       	sub	r8,-4
8000cf1c:	b1 49       	asr	r9,0x10
8000cf1e:	04 33       	cp.w	r3,r2
8000cf20:	fe 98 ff eb 	brls	8000cef6 <quorem+0xc6>
8000cf24:	ec c8 ff fb 	sub	r8,r6,-5
8000cf28:	ee 08 03 29 	ld.w	r9,r7[r8<<0x2]
8000cf2c:	58 09       	cp.w	r9,0
8000cf2e:	c0 d1       	brne	8000cf48 <quorem+0x118>
8000cf30:	ee 08 00 28 	add	r8,r7,r8<<0x2
8000cf34:	c0 28       	rjmp	8000cf38 <quorem+0x108>
8000cf36:	20 16       	sub	r6,1
8000cf38:	20 48       	sub	r8,4
8000cf3a:	08 38       	cp.w	r8,r4
8000cf3c:	e0 88 00 05 	brls	8000cf46 <quorem+0x116>
8000cf40:	70 09       	ld.w	r9,r8[0x0]
8000cf42:	58 09       	cp.w	r9,0
8000cf44:	cf 90       	breq	8000cf36 <quorem+0x106>
8000cf46:	8f 46       	st.w	r7[0x10],r6
8000cf48:	0a 9c       	mov	r12,r5
8000cf4a:	2f ed       	sub	sp,-8
8000cf4c:	d8 32       	popm	r0-r7,pc
8000cf4e:	d7 03       	nop

8000cf50 <_dtoa_r>:
8000cf50:	d4 31       	pushm	r0-r7,lr
8000cf52:	21 ad       	sub	sp,104
8000cf54:	fa c4 ff 74 	sub	r4,sp,-140
8000cf58:	18 97       	mov	r7,r12
8000cf5a:	16 95       	mov	r5,r11
8000cf5c:	68 2c       	ld.w	r12,r4[0x8]
8000cf5e:	50 c9       	stdsp	sp[0x30],r9
8000cf60:	68 16       	ld.w	r6,r4[0x4]
8000cf62:	68 09       	ld.w	r9,r4[0x0]
8000cf64:	50 e8       	stdsp	sp[0x38],r8
8000cf66:	14 94       	mov	r4,r10
8000cf68:	51 2c       	stdsp	sp[0x48],r12
8000cf6a:	fa e5 00 08 	st.d	sp[8],r4
8000cf6e:	51 59       	stdsp	sp[0x54],r9
8000cf70:	6e 95       	ld.w	r5,r7[0x24]
8000cf72:	58 05       	cp.w	r5,0
8000cf74:	c0 91       	brne	8000cf86 <_dtoa_r+0x36>
8000cf76:	31 0c       	mov	r12,16
8000cf78:	fe b0 e8 42 	rcall	80009ffc <malloc>
8000cf7c:	99 35       	st.w	r12[0xc],r5
8000cf7e:	8f 9c       	st.w	r7[0x24],r12
8000cf80:	99 15       	st.w	r12[0x4],r5
8000cf82:	99 25       	st.w	r12[0x8],r5
8000cf84:	99 05       	st.w	r12[0x0],r5
8000cf86:	6e 99       	ld.w	r9,r7[0x24]
8000cf88:	72 08       	ld.w	r8,r9[0x0]
8000cf8a:	58 08       	cp.w	r8,0
8000cf8c:	c0 f0       	breq	8000cfaa <_dtoa_r+0x5a>
8000cf8e:	72 1a       	ld.w	r10,r9[0x4]
8000cf90:	91 1a       	st.w	r8[0x4],r10
8000cf92:	30 1a       	mov	r10,1
8000cf94:	72 19       	ld.w	r9,r9[0x4]
8000cf96:	f4 09 09 49 	lsl	r9,r10,r9
8000cf9a:	10 9b       	mov	r11,r8
8000cf9c:	91 29       	st.w	r8[0x8],r9
8000cf9e:	0e 9c       	mov	r12,r7
8000cfa0:	e0 a0 0a 96 	rcall	8000e4cc <_Bfree>
8000cfa4:	6e 98       	ld.w	r8,r7[0x24]
8000cfa6:	30 09       	mov	r9,0
8000cfa8:	91 09       	st.w	r8[0x0],r9
8000cfaa:	40 28       	lddsp	r8,sp[0x8]
8000cfac:	10 94       	mov	r4,r8
8000cfae:	58 08       	cp.w	r8,0
8000cfb0:	c0 64       	brge	8000cfbc <_dtoa_r+0x6c>
8000cfb2:	f1 d8 c0 1f 	bfextu	r8,r8,0x0,0x1f
8000cfb6:	50 28       	stdsp	sp[0x8],r8
8000cfb8:	30 18       	mov	r8,1
8000cfba:	c0 28       	rjmp	8000cfbe <_dtoa_r+0x6e>
8000cfbc:	30 08       	mov	r8,0
8000cfbe:	8d 08       	st.w	r6[0x0],r8
8000cfc0:	fc 1c 7f f0 	movh	r12,0x7ff0
8000cfc4:	40 26       	lddsp	r6,sp[0x8]
8000cfc6:	0c 98       	mov	r8,r6
8000cfc8:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000cfcc:	18 38       	cp.w	r8,r12
8000cfce:	c1 e1       	brne	8000d00a <_dtoa_r+0xba>
8000cfd0:	e0 68 27 0f 	mov	r8,9999
8000cfd4:	41 5b       	lddsp	r11,sp[0x54]
8000cfd6:	97 08       	st.w	r11[0x0],r8
8000cfd8:	40 3a       	lddsp	r10,sp[0xc]
8000cfda:	58 0a       	cp.w	r10,0
8000cfdc:	c0 61       	brne	8000cfe8 <_dtoa_r+0x98>
8000cfde:	ed d6 c0 14 	bfextu	r6,r6,0x0,0x14
8000cfe2:	c0 31       	brne	8000cfe8 <_dtoa_r+0x98>
8000cfe4:	4a cc       	lddpc	r12,8000d094 <_dtoa_r+0x144>
8000cfe6:	c0 28       	rjmp	8000cfea <_dtoa_r+0x9a>
8000cfe8:	4a cc       	lddpc	r12,8000d098 <_dtoa_r+0x148>
8000cfea:	41 29       	lddsp	r9,sp[0x48]
8000cfec:	58 09       	cp.w	r9,0
8000cfee:	e0 80 05 9e 	breq	8000db2a <_dtoa_r+0xbda>
8000cff2:	f8 c8 ff fd 	sub	r8,r12,-3
8000cff6:	f8 c9 ff f8 	sub	r9,r12,-8
8000cffa:	11 8b       	ld.ub	r11,r8[0x0]
8000cffc:	30 0a       	mov	r10,0
8000cffe:	41 25       	lddsp	r5,sp[0x48]
8000d000:	f4 0b 18 00 	cp.b	r11,r10
8000d004:	f2 08 17 10 	movne	r8,r9
8000d008:	c1 58       	rjmp	8000d032 <_dtoa_r+0xe2>
8000d00a:	fa ea 00 08 	ld.d	r10,sp[8]
8000d00e:	30 08       	mov	r8,0
8000d010:	fa eb 00 3c 	st.d	sp[60],r10
8000d014:	30 09       	mov	r9,0
8000d016:	e0 a0 10 ce 	rcall	8000f1b2 <__avr32_f64_cmp_eq>
8000d01a:	c0 f0       	breq	8000d038 <_dtoa_r+0xe8>
8000d01c:	30 18       	mov	r8,1
8000d01e:	41 5a       	lddsp	r10,sp[0x54]
8000d020:	95 08       	st.w	r10[0x0],r8
8000d022:	49 fc       	lddpc	r12,8000d09c <_dtoa_r+0x14c>
8000d024:	41 29       	lddsp	r9,sp[0x48]
8000d026:	f8 08 00 08 	add	r8,r12,r8
8000d02a:	58 09       	cp.w	r9,0
8000d02c:	e0 80 05 7f 	breq	8000db2a <_dtoa_r+0xbda>
8000d030:	12 95       	mov	r5,r9
8000d032:	8b 08       	st.w	r5[0x0],r8
8000d034:	e0 8f 05 7b 	bral	8000db2a <_dtoa_r+0xbda>
8000d038:	fa c8 ff 9c 	sub	r8,sp,-100
8000d03c:	fa c9 ff a0 	sub	r9,sp,-96
8000d040:	fa ea 00 3c 	ld.d	r10,sp[60]
8000d044:	0e 9c       	mov	r12,r7
8000d046:	eb d6 c2 8b 	bfextu	r5,r6,0x14,0xb
8000d04a:	e0 a0 0a 93 	rcall	8000e570 <__d2b>
8000d04e:	18 93       	mov	r3,r12
8000d050:	58 05       	cp.w	r5,0
8000d052:	c0 d0       	breq	8000d06c <_dtoa_r+0x11c>
8000d054:	fa ea 00 3c 	ld.d	r10,sp[60]
8000d058:	30 04       	mov	r4,0
8000d05a:	f1 db c0 14 	bfextu	r8,r11,0x0,0x14
8000d05e:	ea c5 03 ff 	sub	r5,r5,1023
8000d062:	10 9b       	mov	r11,r8
8000d064:	51 74       	stdsp	sp[0x5c],r4
8000d066:	ea 1b 3f f0 	orh	r11,0x3ff0
8000d06a:	c2 a8       	rjmp	8000d0be <_dtoa_r+0x16e>
8000d06c:	41 88       	lddsp	r8,sp[0x60]
8000d06e:	41 9c       	lddsp	r12,sp[0x64]
8000d070:	10 0c       	add	r12,r8
8000d072:	f8 c5 fb ce 	sub	r5,r12,-1074
8000d076:	e0 45 00 20 	cp.w	r5,32
8000d07a:	e0 8a 00 13 	brle	8000d0a0 <_dtoa_r+0x150>
8000d07e:	f8 cc fb ee 	sub	r12,r12,-1042
8000d082:	40 3b       	lddsp	r11,sp[0xc]
8000d084:	ea 08 11 40 	rsub	r8,r5,64
8000d088:	f6 0c 0a 4c 	lsr	r12,r11,r12
8000d08c:	ec 08 09 46 	lsl	r6,r6,r8
8000d090:	0c 4c       	or	r12,r6
8000d092:	c0 c8       	rjmp	8000d0aa <_dtoa_r+0x15a>
8000d094:	80 01       	ld.sh	r1,r0[0x0]
8000d096:	92 c0       	ld.uh	r0,r9[0x8]
8000d098:	80 01       	ld.sh	r1,r0[0x0]
8000d09a:	92 cc       	ld.uh	r12,r9[0x8]
8000d09c:	80 01       	ld.sh	r1,r0[0x0]
8000d09e:	91 9c       	st.w	r8[0x24],r12
8000d0a0:	ea 0c 11 20 	rsub	r12,r5,32
8000d0a4:	40 3a       	lddsp	r10,sp[0xc]
8000d0a6:	f4 0c 09 4c 	lsl	r12,r10,r12
8000d0aa:	e0 a0 10 10 	rcall	8000f0ca <__avr32_u32_to_f64>
8000d0ae:	fc 18 fe 10 	movh	r8,0xfe10
8000d0b2:	30 19       	mov	r9,1
8000d0b4:	ea c5 04 33 	sub	r5,r5,1075
8000d0b8:	f0 0b 00 0b 	add	r11,r8,r11
8000d0bc:	51 79       	stdsp	sp[0x5c],r9
8000d0be:	30 08       	mov	r8,0
8000d0c0:	fc 19 3f f8 	movh	r9,0x3ff8
8000d0c4:	e0 a0 0e 98 	rcall	8000edf4 <__avr32_f64_sub>
8000d0c8:	e0 68 43 61 	mov	r8,17249
8000d0cc:	ea 18 63 6f 	orh	r8,0x636f
8000d0d0:	e0 69 87 a7 	mov	r9,34727
8000d0d4:	ea 19 3f d2 	orh	r9,0x3fd2
8000d0d8:	e0 a0 0d a2 	rcall	8000ec1c <__avr32_f64_mul>
8000d0dc:	e0 68 c8 b3 	mov	r8,51379
8000d0e0:	ea 18 8b 60 	orh	r8,0x8b60
8000d0e4:	e0 69 8a 28 	mov	r9,35368
8000d0e8:	ea 19 3f c6 	orh	r9,0x3fc6
8000d0ec:	e0 a0 0f 52 	rcall	8000ef90 <__avr32_f64_add>
8000d0f0:	0a 9c       	mov	r12,r5
8000d0f2:	14 90       	mov	r0,r10
8000d0f4:	16 91       	mov	r1,r11
8000d0f6:	e0 a0 0f ee 	rcall	8000f0d2 <__avr32_s32_to_f64>
8000d0fa:	e0 68 79 fb 	mov	r8,31227
8000d0fe:	ea 18 50 9f 	orh	r8,0x509f
8000d102:	e0 69 44 13 	mov	r9,17427
8000d106:	ea 19 3f d3 	orh	r9,0x3fd3
8000d10a:	e0 a0 0d 89 	rcall	8000ec1c <__avr32_f64_mul>
8000d10e:	14 98       	mov	r8,r10
8000d110:	16 99       	mov	r9,r11
8000d112:	00 9a       	mov	r10,r0
8000d114:	02 9b       	mov	r11,r1
8000d116:	e0 a0 0f 3d 	rcall	8000ef90 <__avr32_f64_add>
8000d11a:	14 90       	mov	r0,r10
8000d11c:	16 91       	mov	r1,r11
8000d11e:	e0 a0 0f c3 	rcall	8000f0a4 <__avr32_f64_to_s32>
8000d122:	30 08       	mov	r8,0
8000d124:	18 96       	mov	r6,r12
8000d126:	30 09       	mov	r9,0
8000d128:	00 9a       	mov	r10,r0
8000d12a:	02 9b       	mov	r11,r1
8000d12c:	e0 a0 10 8a 	rcall	8000f240 <__avr32_f64_cmp_lt>
8000d130:	c0 c0       	breq	8000d148 <_dtoa_r+0x1f8>
8000d132:	0c 9c       	mov	r12,r6
8000d134:	e0 a0 0f cf 	rcall	8000f0d2 <__avr32_s32_to_f64>
8000d138:	14 98       	mov	r8,r10
8000d13a:	16 99       	mov	r9,r11
8000d13c:	00 9a       	mov	r10,r0
8000d13e:	02 9b       	mov	r11,r1
8000d140:	e0 a0 10 39 	rcall	8000f1b2 <__avr32_f64_cmp_eq>
8000d144:	f7 b6 00 01 	subeq	r6,1
8000d148:	59 66       	cp.w	r6,22
8000d14a:	e0 88 00 05 	brls	8000d154 <_dtoa_r+0x204>
8000d14e:	30 18       	mov	r8,1
8000d150:	51 48       	stdsp	sp[0x50],r8
8000d152:	c1 28       	rjmp	8000d176 <_dtoa_r+0x226>
8000d154:	4c 08       	lddpc	r8,8000d254 <_dtoa_r+0x304>
8000d156:	fa ea 00 3c 	ld.d	r10,sp[60]
8000d15a:	f0 06 02 38 	ld.d	r8,r8[r6<<0x3]
8000d15e:	e0 a0 10 71 	rcall	8000f240 <__avr32_f64_cmp_lt>
8000d162:	f9 b4 00 00 	moveq	r4,0
8000d166:	fb f4 0a 14 	st.weq	sp[0x50],r4
8000d16a:	f7 b6 01 01 	subne	r6,1
8000d16e:	f9 bc 01 00 	movne	r12,0
8000d172:	fb fc 1a 14 	st.wne	sp[0x50],r12
8000d176:	41 90       	lddsp	r0,sp[0x64]
8000d178:	20 10       	sub	r0,1
8000d17a:	0a 10       	sub	r0,r5
8000d17c:	c0 46       	brmi	8000d184 <_dtoa_r+0x234>
8000d17e:	50 40       	stdsp	sp[0x10],r0
8000d180:	30 00       	mov	r0,0
8000d182:	c0 48       	rjmp	8000d18a <_dtoa_r+0x23a>
8000d184:	30 0b       	mov	r11,0
8000d186:	5c 30       	neg	r0
8000d188:	50 4b       	stdsp	sp[0x10],r11
8000d18a:	ec 02 11 00 	rsub	r2,r6,0
8000d18e:	58 06       	cp.w	r6,0
8000d190:	fb fa 40 04 	ld.wge	r10,sp[0x10]
8000d194:	f5 d6 e4 0a 	addge	r10,r10,r6
8000d198:	fb fa 4a 04 	st.wge	sp[0x10],r10
8000d19c:	fb f6 4a 11 	st.wge	sp[0x44],r6
8000d1a0:	f9 b2 04 00 	movge	r2,0
8000d1a4:	e1 d6 e5 10 	sublt	r0,r0,r6
8000d1a8:	f9 b9 05 00 	movlt	r9,0
8000d1ac:	fb f9 5a 11 	st.wlt	sp[0x44],r9
8000d1b0:	40 c8       	lddsp	r8,sp[0x30]
8000d1b2:	58 98       	cp.w	r8,9
8000d1b4:	e0 8b 00 20 	brhi	8000d1f4 <_dtoa_r+0x2a4>
8000d1b8:	58 58       	cp.w	r8,5
8000d1ba:	f9 b4 0a 01 	movle	r4,1
8000d1be:	fb f5 90 0c 	ld.wgt	r5,sp[0x30]
8000d1c2:	f7 b5 09 04 	subgt	r5,4
8000d1c6:	fb f5 9a 0c 	st.wgt	sp[0x30],r5
8000d1ca:	f9 b4 09 00 	movgt	r4,0
8000d1ce:	40 cc       	lddsp	r12,sp[0x30]
8000d1d0:	58 3c       	cp.w	r12,3
8000d1d2:	c2 d0       	breq	8000d22c <_dtoa_r+0x2dc>
8000d1d4:	e0 89 00 05 	brgt	8000d1de <_dtoa_r+0x28e>
8000d1d8:	58 2c       	cp.w	r12,2
8000d1da:	c1 01       	brne	8000d1fa <_dtoa_r+0x2aa>
8000d1dc:	c1 88       	rjmp	8000d20c <_dtoa_r+0x2bc>
8000d1de:	40 cb       	lddsp	r11,sp[0x30]
8000d1e0:	58 4b       	cp.w	r11,4
8000d1e2:	c0 60       	breq	8000d1ee <_dtoa_r+0x29e>
8000d1e4:	58 5b       	cp.w	r11,5
8000d1e6:	c0 a1       	brne	8000d1fa <_dtoa_r+0x2aa>
8000d1e8:	30 1a       	mov	r10,1
8000d1ea:	50 da       	stdsp	sp[0x34],r10
8000d1ec:	c2 28       	rjmp	8000d230 <_dtoa_r+0x2e0>
8000d1ee:	30 19       	mov	r9,1
8000d1f0:	50 d9       	stdsp	sp[0x34],r9
8000d1f2:	c0 f8       	rjmp	8000d210 <_dtoa_r+0x2c0>
8000d1f4:	30 08       	mov	r8,0
8000d1f6:	30 14       	mov	r4,1
8000d1f8:	50 c8       	stdsp	sp[0x30],r8
8000d1fa:	3f f5       	mov	r5,-1
8000d1fc:	30 1c       	mov	r12,1
8000d1fe:	30 0b       	mov	r11,0
8000d200:	50 95       	stdsp	sp[0x24],r5
8000d202:	50 dc       	stdsp	sp[0x34],r12
8000d204:	0a 91       	mov	r1,r5
8000d206:	31 28       	mov	r8,18
8000d208:	50 eb       	stdsp	sp[0x38],r11
8000d20a:	c2 08       	rjmp	8000d24a <_dtoa_r+0x2fa>
8000d20c:	30 0a       	mov	r10,0
8000d20e:	50 da       	stdsp	sp[0x34],r10
8000d210:	40 e9       	lddsp	r9,sp[0x38]
8000d212:	58 09       	cp.w	r9,0
8000d214:	e0 89 00 07 	brgt	8000d222 <_dtoa_r+0x2d2>
8000d218:	30 18       	mov	r8,1
8000d21a:	50 98       	stdsp	sp[0x24],r8
8000d21c:	10 91       	mov	r1,r8
8000d21e:	50 e8       	stdsp	sp[0x38],r8
8000d220:	c1 58       	rjmp	8000d24a <_dtoa_r+0x2fa>
8000d222:	40 e5       	lddsp	r5,sp[0x38]
8000d224:	50 95       	stdsp	sp[0x24],r5
8000d226:	0a 91       	mov	r1,r5
8000d228:	0a 98       	mov	r8,r5
8000d22a:	c1 08       	rjmp	8000d24a <_dtoa_r+0x2fa>
8000d22c:	30 0c       	mov	r12,0
8000d22e:	50 dc       	stdsp	sp[0x34],r12
8000d230:	40 eb       	lddsp	r11,sp[0x38]
8000d232:	ec 0b 00 0b 	add	r11,r6,r11
8000d236:	50 9b       	stdsp	sp[0x24],r11
8000d238:	16 98       	mov	r8,r11
8000d23a:	2f f8       	sub	r8,-1
8000d23c:	58 08       	cp.w	r8,0
8000d23e:	e0 89 00 05 	brgt	8000d248 <_dtoa_r+0x2f8>
8000d242:	10 91       	mov	r1,r8
8000d244:	30 18       	mov	r8,1
8000d246:	c0 28       	rjmp	8000d24a <_dtoa_r+0x2fa>
8000d248:	10 91       	mov	r1,r8
8000d24a:	30 09       	mov	r9,0
8000d24c:	6e 9a       	ld.w	r10,r7[0x24]
8000d24e:	95 19       	st.w	r10[0x4],r9
8000d250:	30 49       	mov	r9,4
8000d252:	c0 78       	rjmp	8000d260 <_dtoa_r+0x310>
8000d254:	80 01       	ld.sh	r1,r0[0x0]
8000d256:	93 80       	st.w	r9[0x20],r0
8000d258:	6a 1a       	ld.w	r10,r5[0x4]
8000d25a:	a1 79       	lsl	r9,0x1
8000d25c:	2f fa       	sub	r10,-1
8000d25e:	8b 1a       	st.w	r5[0x4],r10
8000d260:	6e 95       	ld.w	r5,r7[0x24]
8000d262:	f2 ca ff ec 	sub	r10,r9,-20
8000d266:	10 3a       	cp.w	r10,r8
8000d268:	fe 98 ff f8 	brls	8000d258 <_dtoa_r+0x308>
8000d26c:	6a 1b       	ld.w	r11,r5[0x4]
8000d26e:	0e 9c       	mov	r12,r7
8000d270:	e0 a0 09 48 	rcall	8000e500 <_Balloc>
8000d274:	58 e1       	cp.w	r1,14
8000d276:	5f 88       	srls	r8
8000d278:	8b 0c       	st.w	r5[0x0],r12
8000d27a:	f1 e4 00 04 	and	r4,r8,r4
8000d27e:	6e 98       	ld.w	r8,r7[0x24]
8000d280:	70 08       	ld.w	r8,r8[0x0]
8000d282:	50 88       	stdsp	sp[0x20],r8
8000d284:	e0 80 01 82 	breq	8000d588 <_dtoa_r+0x638>
8000d288:	58 06       	cp.w	r6,0
8000d28a:	e0 8a 00 40 	brle	8000d30a <_dtoa_r+0x3ba>
8000d28e:	f3 d6 c0 04 	bfextu	r9,r6,0x0,0x4
8000d292:	4c b8       	lddpc	r8,8000d3bc <_dtoa_r+0x46c>
8000d294:	f0 09 02 34 	ld.d	r4,r8[r9<<0x3]
8000d298:	fa e5 00 18 	st.d	sp[24],r4
8000d29c:	ec 04 14 04 	asr	r4,r6,0x4
8000d2a0:	ed b4 00 04 	bld	r4,0x4
8000d2a4:	c0 30       	breq	8000d2aa <_dtoa_r+0x35a>
8000d2a6:	30 25       	mov	r5,2
8000d2a8:	c0 f8       	rjmp	8000d2c6 <_dtoa_r+0x376>
8000d2aa:	4c 68       	lddpc	r8,8000d3c0 <_dtoa_r+0x470>
8000d2ac:	f0 e8 00 20 	ld.d	r8,r8[32]
8000d2b0:	fa ea 00 3c 	ld.d	r10,sp[60]
8000d2b4:	e9 d4 c0 04 	bfextu	r4,r4,0x0,0x4
8000d2b8:	e0 a0 0f f8 	rcall	8000f2a8 <__avr32_f64_div>
8000d2bc:	30 35       	mov	r5,3
8000d2be:	14 98       	mov	r8,r10
8000d2c0:	16 99       	mov	r9,r11
8000d2c2:	fa e9 00 08 	st.d	sp[8],r8
8000d2c6:	4b fc       	lddpc	r12,8000d3c0 <_dtoa_r+0x470>
8000d2c8:	50 a3       	stdsp	sp[0x28],r3
8000d2ca:	0c 93       	mov	r3,r6
8000d2cc:	18 96       	mov	r6,r12
8000d2ce:	c0 f8       	rjmp	8000d2ec <_dtoa_r+0x39c>
8000d2d0:	fa ea 00 18 	ld.d	r10,sp[24]
8000d2d4:	ed b4 00 00 	bld	r4,0x0
8000d2d8:	c0 81       	brne	8000d2e8 <_dtoa_r+0x398>
8000d2da:	ec e8 00 00 	ld.d	r8,r6[0]
8000d2de:	2f f5       	sub	r5,-1
8000d2e0:	e0 a0 0c 9e 	rcall	8000ec1c <__avr32_f64_mul>
8000d2e4:	fa eb 00 18 	st.d	sp[24],r10
8000d2e8:	a1 54       	asr	r4,0x1
8000d2ea:	2f 86       	sub	r6,-8
8000d2ec:	58 04       	cp.w	r4,0
8000d2ee:	cf 11       	brne	8000d2d0 <_dtoa_r+0x380>
8000d2f0:	fa e8 00 18 	ld.d	r8,sp[24]
8000d2f4:	fa ea 00 08 	ld.d	r10,sp[8]
8000d2f8:	06 96       	mov	r6,r3
8000d2fa:	e0 a0 0f d7 	rcall	8000f2a8 <__avr32_f64_div>
8000d2fe:	40 a3       	lddsp	r3,sp[0x28]
8000d300:	14 98       	mov	r8,r10
8000d302:	16 99       	mov	r9,r11
8000d304:	fa e9 00 08 	st.d	sp[8],r8
8000d308:	c2 d8       	rjmp	8000d362 <_dtoa_r+0x412>
8000d30a:	ec 08 11 00 	rsub	r8,r6,0
8000d30e:	c0 31       	brne	8000d314 <_dtoa_r+0x3c4>
8000d310:	30 25       	mov	r5,2
8000d312:	c2 88       	rjmp	8000d362 <_dtoa_r+0x412>
8000d314:	4a bc       	lddpc	r12,8000d3c0 <_dtoa_r+0x470>
8000d316:	f0 04 14 04 	asr	r4,r8,0x4
8000d31a:	50 1c       	stdsp	sp[0x4],r12
8000d31c:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
8000d320:	4a 79       	lddpc	r9,8000d3bc <_dtoa_r+0x46c>
8000d322:	fa ea 00 3c 	ld.d	r10,sp[60]
8000d326:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000d32a:	e0 a0 0c 79 	rcall	8000ec1c <__avr32_f64_mul>
8000d32e:	40 1c       	lddsp	r12,sp[0x4]
8000d330:	50 63       	stdsp	sp[0x18],r3
8000d332:	30 25       	mov	r5,2
8000d334:	0c 93       	mov	r3,r6
8000d336:	fa eb 00 08 	st.d	sp[8],r10
8000d33a:	18 96       	mov	r6,r12
8000d33c:	c0 f8       	rjmp	8000d35a <_dtoa_r+0x40a>
8000d33e:	fa ea 00 08 	ld.d	r10,sp[8]
8000d342:	ed b4 00 00 	bld	r4,0x0
8000d346:	c0 81       	brne	8000d356 <_dtoa_r+0x406>
8000d348:	ec e8 00 00 	ld.d	r8,r6[0]
8000d34c:	2f f5       	sub	r5,-1
8000d34e:	e0 a0 0c 67 	rcall	8000ec1c <__avr32_f64_mul>
8000d352:	fa eb 00 08 	st.d	sp[8],r10
8000d356:	a1 54       	asr	r4,0x1
8000d358:	2f 86       	sub	r6,-8
8000d35a:	58 04       	cp.w	r4,0
8000d35c:	cf 11       	brne	8000d33e <_dtoa_r+0x3ee>
8000d35e:	06 96       	mov	r6,r3
8000d360:	40 63       	lddsp	r3,sp[0x18]
8000d362:	41 4a       	lddsp	r10,sp[0x50]
8000d364:	58 0a       	cp.w	r10,0
8000d366:	c2 f0       	breq	8000d3c4 <_dtoa_r+0x474>
8000d368:	fa e8 00 08 	ld.d	r8,sp[8]
8000d36c:	58 01       	cp.w	r1,0
8000d36e:	5f 94       	srgt	r4
8000d370:	fa e9 00 18 	st.d	sp[24],r8
8000d374:	30 08       	mov	r8,0
8000d376:	fc 19 3f f0 	movh	r9,0x3ff0
8000d37a:	fa ea 00 18 	ld.d	r10,sp[24]
8000d37e:	e0 a0 0f 61 	rcall	8000f240 <__avr32_f64_cmp_lt>
8000d382:	f9 bc 00 00 	moveq	r12,0
8000d386:	f9 bc 01 01 	movne	r12,1
8000d38a:	e9 ec 00 0c 	and	r12,r4,r12
8000d38e:	c1 b0       	breq	8000d3c4 <_dtoa_r+0x474>
8000d390:	40 98       	lddsp	r8,sp[0x24]
8000d392:	58 08       	cp.w	r8,0
8000d394:	e0 8a 00 f6 	brle	8000d580 <_dtoa_r+0x630>
8000d398:	30 08       	mov	r8,0
8000d39a:	fc 19 40 24 	movh	r9,0x4024
8000d39e:	ec c4 00 01 	sub	r4,r6,1
8000d3a2:	fa ea 00 18 	ld.d	r10,sp[24]
8000d3a6:	2f f5       	sub	r5,-1
8000d3a8:	50 64       	stdsp	sp[0x18],r4
8000d3aa:	e0 a0 0c 39 	rcall	8000ec1c <__avr32_f64_mul>
8000d3ae:	40 94       	lddsp	r4,sp[0x24]
8000d3b0:	14 98       	mov	r8,r10
8000d3b2:	16 99       	mov	r9,r11
8000d3b4:	fa e9 00 08 	st.d	sp[8],r8
8000d3b8:	c0 88       	rjmp	8000d3c8 <_dtoa_r+0x478>
8000d3ba:	d7 03       	nop
8000d3bc:	80 01       	ld.sh	r1,r0[0x0]
8000d3be:	93 80       	st.w	r9[0x20],r0
8000d3c0:	80 01       	ld.sh	r1,r0[0x0]
8000d3c2:	94 48       	ld.sh	r8,r10[0x8]
8000d3c4:	50 66       	stdsp	sp[0x18],r6
8000d3c6:	02 94       	mov	r4,r1
8000d3c8:	0a 9c       	mov	r12,r5
8000d3ca:	e0 a0 0e 84 	rcall	8000f0d2 <__avr32_s32_to_f64>
8000d3ce:	fa e8 00 08 	ld.d	r8,sp[8]
8000d3d2:	e0 a0 0c 25 	rcall	8000ec1c <__avr32_f64_mul>
8000d3d6:	30 08       	mov	r8,0
8000d3d8:	fc 19 40 1c 	movh	r9,0x401c
8000d3dc:	e0 a0 0d da 	rcall	8000ef90 <__avr32_f64_add>
8000d3e0:	14 98       	mov	r8,r10
8000d3e2:	16 99       	mov	r9,r11
8000d3e4:	fa e9 00 28 	st.d	sp[40],r8
8000d3e8:	fc 18 fc c0 	movh	r8,0xfcc0
8000d3ec:	40 a5       	lddsp	r5,sp[0x28]
8000d3ee:	10 05       	add	r5,r8
8000d3f0:	50 a5       	stdsp	sp[0x28],r5
8000d3f2:	58 04       	cp.w	r4,0
8000d3f4:	c2 11       	brne	8000d436 <_dtoa_r+0x4e6>
8000d3f6:	fa ea 00 08 	ld.d	r10,sp[8]
8000d3fa:	30 08       	mov	r8,0
8000d3fc:	fc 19 40 14 	movh	r9,0x4014
8000d400:	e0 a0 0c fa 	rcall	8000edf4 <__avr32_f64_sub>
8000d404:	40 bc       	lddsp	r12,sp[0x2c]
8000d406:	fa eb 00 08 	st.d	sp[8],r10
8000d40a:	14 98       	mov	r8,r10
8000d40c:	16 99       	mov	r9,r11
8000d40e:	18 9a       	mov	r10,r12
8000d410:	0a 9b       	mov	r11,r5
8000d412:	e0 a0 0f 17 	rcall	8000f240 <__avr32_f64_cmp_lt>
8000d416:	e0 81 02 54 	brne	8000d8be <_dtoa_r+0x96e>
8000d41a:	0a 98       	mov	r8,r5
8000d41c:	40 b9       	lddsp	r9,sp[0x2c]
8000d41e:	ee 18 80 00 	eorh	r8,0x8000
8000d422:	fa ea 00 08 	ld.d	r10,sp[8]
8000d426:	10 95       	mov	r5,r8
8000d428:	12 98       	mov	r8,r9
8000d42a:	0a 99       	mov	r9,r5
8000d42c:	e0 a0 0f 0a 	rcall	8000f240 <__avr32_f64_cmp_lt>
8000d430:	e0 81 02 3e 	brne	8000d8ac <_dtoa_r+0x95c>
8000d434:	ca 68       	rjmp	8000d580 <_dtoa_r+0x630>
8000d436:	4c e9       	lddpc	r9,8000d56c <_dtoa_r+0x61c>
8000d438:	e8 c8 00 01 	sub	r8,r4,1
8000d43c:	40 d5       	lddsp	r5,sp[0x34]
8000d43e:	58 05       	cp.w	r5,0
8000d440:	c4 f0       	breq	8000d4de <_dtoa_r+0x58e>
8000d442:	30 0c       	mov	r12,0
8000d444:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000d448:	51 3c       	stdsp	sp[0x4c],r12
8000d44a:	30 0a       	mov	r10,0
8000d44c:	fc 1b 3f e0 	movh	r11,0x3fe0
8000d450:	e0 a0 0f 2c 	rcall	8000f2a8 <__avr32_f64_div>
8000d454:	fa e8 00 28 	ld.d	r8,sp[40]
8000d458:	40 85       	lddsp	r5,sp[0x20]
8000d45a:	e0 a0 0c cd 	rcall	8000edf4 <__avr32_f64_sub>
8000d45e:	fa eb 00 28 	st.d	sp[40],r10
8000d462:	fa ea 00 08 	ld.d	r10,sp[8]
8000d466:	e0 a0 0e 1f 	rcall	8000f0a4 <__avr32_f64_to_s32>
8000d46a:	51 6c       	stdsp	sp[0x58],r12
8000d46c:	e0 a0 0e 33 	rcall	8000f0d2 <__avr32_s32_to_f64>
8000d470:	14 98       	mov	r8,r10
8000d472:	16 99       	mov	r9,r11
8000d474:	fa ea 00 08 	ld.d	r10,sp[8]
8000d478:	e0 a0 0c be 	rcall	8000edf4 <__avr32_f64_sub>
8000d47c:	fa eb 00 08 	st.d	sp[8],r10
8000d480:	41 68       	lddsp	r8,sp[0x58]
8000d482:	2d 08       	sub	r8,-48
8000d484:	0a c8       	st.b	r5++,r8
8000d486:	41 39       	lddsp	r9,sp[0x4c]
8000d488:	2f f9       	sub	r9,-1
8000d48a:	51 39       	stdsp	sp[0x4c],r9
8000d48c:	fa e8 00 28 	ld.d	r8,sp[40]
8000d490:	e0 a0 0e d8 	rcall	8000f240 <__avr32_f64_cmp_lt>
8000d494:	e0 81 03 3a 	brne	8000db08 <_dtoa_r+0xbb8>
8000d498:	fa e8 00 08 	ld.d	r8,sp[8]
8000d49c:	30 0a       	mov	r10,0
8000d49e:	fc 1b 3f f0 	movh	r11,0x3ff0
8000d4a2:	e0 a0 0c a9 	rcall	8000edf4 <__avr32_f64_sub>
8000d4a6:	fa e8 00 28 	ld.d	r8,sp[40]
8000d4aa:	e0 a0 0e cb 	rcall	8000f240 <__avr32_f64_cmp_lt>
8000d4ae:	fa ea 00 28 	ld.d	r10,sp[40]
8000d4b2:	30 08       	mov	r8,0
8000d4b4:	fc 19 40 24 	movh	r9,0x4024
8000d4b8:	e0 81 00 da 	brne	8000d66c <_dtoa_r+0x71c>
8000d4bc:	41 3c       	lddsp	r12,sp[0x4c]
8000d4be:	08 3c       	cp.w	r12,r4
8000d4c0:	c6 04       	brge	8000d580 <_dtoa_r+0x630>
8000d4c2:	e0 a0 0b ad 	rcall	8000ec1c <__avr32_f64_mul>
8000d4c6:	30 08       	mov	r8,0
8000d4c8:	fa eb 00 28 	st.d	sp[40],r10
8000d4cc:	fc 19 40 24 	movh	r9,0x4024
8000d4d0:	fa ea 00 08 	ld.d	r10,sp[8]
8000d4d4:	e0 a0 0b a4 	rcall	8000ec1c <__avr32_f64_mul>
8000d4d8:	fa eb 00 08 	st.d	sp[8],r10
8000d4dc:	cc 3b       	rjmp	8000d462 <_dtoa_r+0x512>
8000d4de:	40 85       	lddsp	r5,sp[0x20]
8000d4e0:	08 05       	add	r5,r4
8000d4e2:	f2 08 02 3a 	ld.d	r10,r9[r8<<0x3]
8000d4e6:	51 35       	stdsp	sp[0x4c],r5
8000d4e8:	fa e8 00 28 	ld.d	r8,sp[40]
8000d4ec:	40 85       	lddsp	r5,sp[0x20]
8000d4ee:	e0 a0 0b 97 	rcall	8000ec1c <__avr32_f64_mul>
8000d4f2:	fa eb 00 28 	st.d	sp[40],r10
8000d4f6:	fa ea 00 08 	ld.d	r10,sp[8]
8000d4fa:	e0 a0 0d d5 	rcall	8000f0a4 <__avr32_f64_to_s32>
8000d4fe:	51 6c       	stdsp	sp[0x58],r12
8000d500:	e0 a0 0d e9 	rcall	8000f0d2 <__avr32_s32_to_f64>
8000d504:	14 98       	mov	r8,r10
8000d506:	16 99       	mov	r9,r11
8000d508:	fa ea 00 08 	ld.d	r10,sp[8]
8000d50c:	e0 a0 0c 74 	rcall	8000edf4 <__avr32_f64_sub>
8000d510:	fa eb 00 08 	st.d	sp[8],r10
8000d514:	41 68       	lddsp	r8,sp[0x58]
8000d516:	2d 08       	sub	r8,-48
8000d518:	0a c8       	st.b	r5++,r8
8000d51a:	41 3c       	lddsp	r12,sp[0x4c]
8000d51c:	18 35       	cp.w	r5,r12
8000d51e:	c2 91       	brne	8000d570 <_dtoa_r+0x620>
8000d520:	30 08       	mov	r8,0
8000d522:	fc 19 3f e0 	movh	r9,0x3fe0
8000d526:	fa ea 00 28 	ld.d	r10,sp[40]
8000d52a:	e0 a0 0d 33 	rcall	8000ef90 <__avr32_f64_add>
8000d52e:	40 85       	lddsp	r5,sp[0x20]
8000d530:	fa e8 00 08 	ld.d	r8,sp[8]
8000d534:	08 05       	add	r5,r4
8000d536:	e0 a0 0e 85 	rcall	8000f240 <__avr32_f64_cmp_lt>
8000d53a:	e0 81 00 99 	brne	8000d66c <_dtoa_r+0x71c>
8000d53e:	fa e8 00 28 	ld.d	r8,sp[40]
8000d542:	30 0a       	mov	r10,0
8000d544:	fc 1b 3f e0 	movh	r11,0x3fe0
8000d548:	e0 a0 0c 56 	rcall	8000edf4 <__avr32_f64_sub>
8000d54c:	14 98       	mov	r8,r10
8000d54e:	16 99       	mov	r9,r11
8000d550:	fa ea 00 08 	ld.d	r10,sp[8]
8000d554:	e0 a0 0e 76 	rcall	8000f240 <__avr32_f64_cmp_lt>
8000d558:	c1 40       	breq	8000d580 <_dtoa_r+0x630>
8000d55a:	33 09       	mov	r9,48
8000d55c:	0a 98       	mov	r8,r5
8000d55e:	11 7a       	ld.ub	r10,--r8
8000d560:	f2 0a 18 00 	cp.b	r10,r9
8000d564:	e0 81 02 d2 	brne	8000db08 <_dtoa_r+0xbb8>
8000d568:	10 95       	mov	r5,r8
8000d56a:	cf 9b       	rjmp	8000d55c <_dtoa_r+0x60c>
8000d56c:	80 01       	ld.sh	r1,r0[0x0]
8000d56e:	93 80       	st.w	r9[0x20],r0
8000d570:	30 08       	mov	r8,0
8000d572:	fc 19 40 24 	movh	r9,0x4024
8000d576:	e0 a0 0b 53 	rcall	8000ec1c <__avr32_f64_mul>
8000d57a:	fa eb 00 08 	st.d	sp[8],r10
8000d57e:	cb cb       	rjmp	8000d4f6 <_dtoa_r+0x5a6>
8000d580:	fa ea 00 3c 	ld.d	r10,sp[60]
8000d584:	fa eb 00 08 	st.d	sp[8],r10
8000d588:	58 e6       	cp.w	r6,14
8000d58a:	5f ab       	srle	r11
8000d58c:	41 8a       	lddsp	r10,sp[0x60]
8000d58e:	30 08       	mov	r8,0
8000d590:	f4 09 11 ff 	rsub	r9,r10,-1
8000d594:	f7 e9 03 f9 	and	r9,r11,r9>>0x1f
8000d598:	f0 09 18 00 	cp.b	r9,r8
8000d59c:	e0 80 00 81 	breq	8000d69e <_dtoa_r+0x74e>
8000d5a0:	40 ea       	lddsp	r10,sp[0x38]
8000d5a2:	58 01       	cp.w	r1,0
8000d5a4:	5f a9       	srle	r9
8000d5a6:	f3 ea 03 f9 	and	r9,r9,r10>>0x1f
8000d5aa:	4c 9a       	lddpc	r10,8000d6cc <_dtoa_r+0x77c>
8000d5ac:	f4 06 02 34 	ld.d	r4,r10[r6<<0x3]
8000d5b0:	fa e5 00 10 	st.d	sp[16],r4
8000d5b4:	f0 09 18 00 	cp.b	r9,r8
8000d5b8:	c1 40       	breq	8000d5e0 <_dtoa_r+0x690>
8000d5ba:	58 01       	cp.w	r1,0
8000d5bc:	e0 81 01 78 	brne	8000d8ac <_dtoa_r+0x95c>
8000d5c0:	30 08       	mov	r8,0
8000d5c2:	fc 19 40 14 	movh	r9,0x4014
8000d5c6:	08 9a       	mov	r10,r4
8000d5c8:	0a 9b       	mov	r11,r5
8000d5ca:	e0 a0 0b 29 	rcall	8000ec1c <__avr32_f64_mul>
8000d5ce:	fa e8 00 08 	ld.d	r8,sp[8]
8000d5d2:	e0 a0 0e 03 	rcall	8000f1d8 <__avr32_f64_cmp_ge>
8000d5d6:	e0 81 01 6b 	brne	8000d8ac <_dtoa_r+0x95c>
8000d5da:	02 92       	mov	r2,r1
8000d5dc:	e0 8f 01 73 	bral	8000d8c2 <_dtoa_r+0x972>
8000d5e0:	40 85       	lddsp	r5,sp[0x20]
8000d5e2:	30 14       	mov	r4,1
8000d5e4:	fa e8 00 10 	ld.d	r8,sp[16]
8000d5e8:	fa ea 00 08 	ld.d	r10,sp[8]
8000d5ec:	e0 a0 0e 5e 	rcall	8000f2a8 <__avr32_f64_div>
8000d5f0:	e0 a0 0d 5a 	rcall	8000f0a4 <__avr32_f64_to_s32>
8000d5f4:	18 92       	mov	r2,r12
8000d5f6:	e0 a0 0d 6e 	rcall	8000f0d2 <__avr32_s32_to_f64>
8000d5fa:	fa e8 00 10 	ld.d	r8,sp[16]
8000d5fe:	e0 a0 0b 0f 	rcall	8000ec1c <__avr32_f64_mul>
8000d602:	14 98       	mov	r8,r10
8000d604:	16 99       	mov	r9,r11
8000d606:	fa ea 00 08 	ld.d	r10,sp[8]
8000d60a:	e0 a0 0b f5 	rcall	8000edf4 <__avr32_f64_sub>
8000d60e:	fa eb 00 08 	st.d	sp[8],r10
8000d612:	e4 c8 ff d0 	sub	r8,r2,-48
8000d616:	0a c8       	st.b	r5++,r8
8000d618:	fc 19 40 24 	movh	r9,0x4024
8000d61c:	30 08       	mov	r8,0
8000d61e:	02 34       	cp.w	r4,r1
8000d620:	c3 31       	brne	8000d686 <_dtoa_r+0x736>
8000d622:	fa e8 00 08 	ld.d	r8,sp[8]
8000d626:	e0 a0 0c b5 	rcall	8000ef90 <__avr32_f64_add>
8000d62a:	16 91       	mov	r1,r11
8000d62c:	14 90       	mov	r0,r10
8000d62e:	14 98       	mov	r8,r10
8000d630:	02 99       	mov	r9,r1
8000d632:	fa ea 00 10 	ld.d	r10,sp[16]
8000d636:	e0 a0 0e 05 	rcall	8000f240 <__avr32_f64_cmp_lt>
8000d63a:	c1 a1       	brne	8000d66e <_dtoa_r+0x71e>
8000d63c:	fa e8 00 10 	ld.d	r8,sp[16]
8000d640:	00 9a       	mov	r10,r0
8000d642:	02 9b       	mov	r11,r1
8000d644:	e0 a0 0d b7 	rcall	8000f1b2 <__avr32_f64_cmp_eq>
8000d648:	e0 80 02 5f 	breq	8000db06 <_dtoa_r+0xbb6>
8000d64c:	e5 d2 c0 01 	bfextu	r2,r2,0x0,0x1
8000d650:	c0 f1       	brne	8000d66e <_dtoa_r+0x71e>
8000d652:	e0 8f 02 5a 	bral	8000db06 <_dtoa_r+0xbb6>
8000d656:	40 8a       	lddsp	r10,sp[0x20]
8000d658:	14 38       	cp.w	r8,r10
8000d65a:	c0 30       	breq	8000d660 <_dtoa_r+0x710>
8000d65c:	10 95       	mov	r5,r8
8000d65e:	c0 98       	rjmp	8000d670 <_dtoa_r+0x720>
8000d660:	33 08       	mov	r8,48
8000d662:	40 89       	lddsp	r9,sp[0x20]
8000d664:	2f f6       	sub	r6,-1
8000d666:	b2 88       	st.b	r9[0x0],r8
8000d668:	40 88       	lddsp	r8,sp[0x20]
8000d66a:	c0 88       	rjmp	8000d67a <_dtoa_r+0x72a>
8000d66c:	40 66       	lddsp	r6,sp[0x18]
8000d66e:	33 99       	mov	r9,57
8000d670:	0a 98       	mov	r8,r5
8000d672:	11 7a       	ld.ub	r10,--r8
8000d674:	f2 0a 18 00 	cp.b	r10,r9
8000d678:	ce f0       	breq	8000d656 <_dtoa_r+0x706>
8000d67a:	50 66       	stdsp	sp[0x18],r6
8000d67c:	11 89       	ld.ub	r9,r8[0x0]
8000d67e:	2f f9       	sub	r9,-1
8000d680:	b0 89       	st.b	r8[0x0],r9
8000d682:	e0 8f 02 43 	bral	8000db08 <_dtoa_r+0xbb8>
8000d686:	e0 a0 0a cb 	rcall	8000ec1c <__avr32_f64_mul>
8000d68a:	2f f4       	sub	r4,-1
8000d68c:	fa eb 00 08 	st.d	sp[8],r10
8000d690:	30 08       	mov	r8,0
8000d692:	30 09       	mov	r9,0
8000d694:	e0 a0 0d 8f 	rcall	8000f1b2 <__avr32_f64_cmp_eq>
8000d698:	ca 60       	breq	8000d5e4 <_dtoa_r+0x694>
8000d69a:	e0 8f 02 36 	bral	8000db06 <_dtoa_r+0xbb6>
8000d69e:	40 d8       	lddsp	r8,sp[0x34]
8000d6a0:	58 08       	cp.w	r8,0
8000d6a2:	c0 51       	brne	8000d6ac <_dtoa_r+0x75c>
8000d6a4:	04 98       	mov	r8,r2
8000d6a6:	00 95       	mov	r5,r0
8000d6a8:	40 d4       	lddsp	r4,sp[0x34]
8000d6aa:	c3 88       	rjmp	8000d71a <_dtoa_r+0x7ca>
8000d6ac:	40 c5       	lddsp	r5,sp[0x30]
8000d6ae:	58 15       	cp.w	r5,1
8000d6b0:	e0 89 00 10 	brgt	8000d6d0 <_dtoa_r+0x780>
8000d6b4:	41 74       	lddsp	r4,sp[0x5c]
8000d6b6:	58 04       	cp.w	r4,0
8000d6b8:	c0 40       	breq	8000d6c0 <_dtoa_r+0x770>
8000d6ba:	f4 c9 fb cd 	sub	r9,r10,-1075
8000d6be:	c0 48       	rjmp	8000d6c6 <_dtoa_r+0x776>
8000d6c0:	41 99       	lddsp	r9,sp[0x64]
8000d6c2:	f2 09 11 36 	rsub	r9,r9,54
8000d6c6:	04 98       	mov	r8,r2
8000d6c8:	00 95       	mov	r5,r0
8000d6ca:	c1 d8       	rjmp	8000d704 <_dtoa_r+0x7b4>
8000d6cc:	80 01       	ld.sh	r1,r0[0x0]
8000d6ce:	93 80       	st.w	r9[0x20],r0
8000d6d0:	e2 c8 00 01 	sub	r8,r1,1
8000d6d4:	58 01       	cp.w	r1,0
8000d6d6:	e0 05 17 40 	movge	r5,r0
8000d6da:	e2 09 17 40 	movge	r9,r1
8000d6de:	e1 d1 e5 15 	sublt	r5,r0,r1
8000d6e2:	f9 b9 05 00 	movlt	r9,0
8000d6e6:	10 32       	cp.w	r2,r8
8000d6e8:	e5 d8 e4 18 	subge	r8,r2,r8
8000d6ec:	f1 d2 e5 18 	sublt	r8,r8,r2
8000d6f0:	e5 d8 e5 02 	addlt	r2,r2,r8
8000d6f4:	fb fc 50 11 	ld.wlt	r12,sp[0x44]
8000d6f8:	f9 d8 e5 0c 	addlt	r12,r12,r8
8000d6fc:	fb fc 5a 11 	st.wlt	sp[0x44],r12
8000d700:	f9 b8 05 00 	movlt	r8,0
8000d704:	40 4b       	lddsp	r11,sp[0x10]
8000d706:	12 0b       	add	r11,r9
8000d708:	50 08       	stdsp	sp[0x0],r8
8000d70a:	50 4b       	stdsp	sp[0x10],r11
8000d70c:	12 00       	add	r0,r9
8000d70e:	30 1b       	mov	r11,1
8000d710:	0e 9c       	mov	r12,r7
8000d712:	e0 a0 08 ab 	rcall	8000e868 <__i2b>
8000d716:	40 08       	lddsp	r8,sp[0x0]
8000d718:	18 94       	mov	r4,r12
8000d71a:	40 4a       	lddsp	r10,sp[0x10]
8000d71c:	58 05       	cp.w	r5,0
8000d71e:	5f 99       	srgt	r9
8000d720:	58 0a       	cp.w	r10,0
8000d722:	5f 9a       	srgt	r10
8000d724:	f5 e9 00 09 	and	r9,r10,r9
8000d728:	c0 80       	breq	8000d738 <_dtoa_r+0x7e8>
8000d72a:	40 4c       	lddsp	r12,sp[0x10]
8000d72c:	f8 05 0d 49 	min	r9,r12,r5
8000d730:	12 1c       	sub	r12,r9
8000d732:	12 10       	sub	r0,r9
8000d734:	50 4c       	stdsp	sp[0x10],r12
8000d736:	12 15       	sub	r5,r9
8000d738:	58 02       	cp.w	r2,0
8000d73a:	e0 8a 00 27 	brle	8000d788 <_dtoa_r+0x838>
8000d73e:	40 db       	lddsp	r11,sp[0x34]
8000d740:	58 0b       	cp.w	r11,0
8000d742:	c1 d0       	breq	8000d77c <_dtoa_r+0x82c>
8000d744:	58 08       	cp.w	r8,0
8000d746:	e0 8a 00 17 	brle	8000d774 <_dtoa_r+0x824>
8000d74a:	10 9a       	mov	r10,r8
8000d74c:	50 08       	stdsp	sp[0x0],r8
8000d74e:	08 9b       	mov	r11,r4
8000d750:	0e 9c       	mov	r12,r7
8000d752:	e0 a0 08 d1 	rcall	8000e8f4 <__pow5mult>
8000d756:	06 9a       	mov	r10,r3
8000d758:	18 9b       	mov	r11,r12
8000d75a:	18 94       	mov	r4,r12
8000d75c:	0e 9c       	mov	r12,r7
8000d75e:	e0 a0 08 05 	rcall	8000e768 <__multiply>
8000d762:	18 99       	mov	r9,r12
8000d764:	06 9b       	mov	r11,r3
8000d766:	50 19       	stdsp	sp[0x4],r9
8000d768:	0e 9c       	mov	r12,r7
8000d76a:	e0 a0 06 b1 	rcall	8000e4cc <_Bfree>
8000d76e:	40 19       	lddsp	r9,sp[0x4]
8000d770:	40 08       	lddsp	r8,sp[0x0]
8000d772:	12 93       	mov	r3,r9
8000d774:	e4 08 01 0a 	sub	r10,r2,r8
8000d778:	c0 80       	breq	8000d788 <_dtoa_r+0x838>
8000d77a:	c0 28       	rjmp	8000d77e <_dtoa_r+0x82e>
8000d77c:	04 9a       	mov	r10,r2
8000d77e:	06 9b       	mov	r11,r3
8000d780:	0e 9c       	mov	r12,r7
8000d782:	e0 a0 08 b9 	rcall	8000e8f4 <__pow5mult>
8000d786:	18 93       	mov	r3,r12
8000d788:	30 1b       	mov	r11,1
8000d78a:	0e 9c       	mov	r12,r7
8000d78c:	e0 a0 08 6e 	rcall	8000e868 <__i2b>
8000d790:	41 1a       	lddsp	r10,sp[0x44]
8000d792:	18 92       	mov	r2,r12
8000d794:	58 0a       	cp.w	r10,0
8000d796:	e0 8a 00 07 	brle	8000d7a4 <_dtoa_r+0x854>
8000d79a:	18 9b       	mov	r11,r12
8000d79c:	0e 9c       	mov	r12,r7
8000d79e:	e0 a0 08 ab 	rcall	8000e8f4 <__pow5mult>
8000d7a2:	18 92       	mov	r2,r12
8000d7a4:	40 c9       	lddsp	r9,sp[0x30]
8000d7a6:	58 19       	cp.w	r9,1
8000d7a8:	e0 89 00 14 	brgt	8000d7d0 <_dtoa_r+0x880>
8000d7ac:	40 38       	lddsp	r8,sp[0xc]
8000d7ae:	58 08       	cp.w	r8,0
8000d7b0:	c1 01       	brne	8000d7d0 <_dtoa_r+0x880>
8000d7b2:	40 29       	lddsp	r9,sp[0x8]
8000d7b4:	f1 d9 c0 14 	bfextu	r8,r9,0x0,0x14
8000d7b8:	c0 c1       	brne	8000d7d0 <_dtoa_r+0x880>
8000d7ba:	12 98       	mov	r8,r9
8000d7bc:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000d7c0:	c0 80       	breq	8000d7d0 <_dtoa_r+0x880>
8000d7c2:	40 4c       	lddsp	r12,sp[0x10]
8000d7c4:	30 1b       	mov	r11,1
8000d7c6:	2f fc       	sub	r12,-1
8000d7c8:	2f f0       	sub	r0,-1
8000d7ca:	50 4c       	stdsp	sp[0x10],r12
8000d7cc:	50 6b       	stdsp	sp[0x18],r11
8000d7ce:	c0 38       	rjmp	8000d7d4 <_dtoa_r+0x884>
8000d7d0:	30 0a       	mov	r10,0
8000d7d2:	50 6a       	stdsp	sp[0x18],r10
8000d7d4:	41 19       	lddsp	r9,sp[0x44]
8000d7d6:	58 09       	cp.w	r9,0
8000d7d8:	c0 31       	brne	8000d7de <_dtoa_r+0x88e>
8000d7da:	30 1c       	mov	r12,1
8000d7dc:	c0 98       	rjmp	8000d7ee <_dtoa_r+0x89e>
8000d7de:	64 48       	ld.w	r8,r2[0x10]
8000d7e0:	2f c8       	sub	r8,-4
8000d7e2:	e4 08 03 2c 	ld.w	r12,r2[r8<<0x2]
8000d7e6:	e0 a0 05 e3 	rcall	8000e3ac <__hi0bits>
8000d7ea:	f8 0c 11 20 	rsub	r12,r12,32
8000d7ee:	40 4b       	lddsp	r11,sp[0x10]
8000d7f0:	f8 0b 00 08 	add	r8,r12,r11
8000d7f4:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000d7f8:	c0 c0       	breq	8000d810 <_dtoa_r+0x8c0>
8000d7fa:	f0 08 11 20 	rsub	r8,r8,32
8000d7fe:	58 48       	cp.w	r8,4
8000d800:	e0 8a 00 06 	brle	8000d80c <_dtoa_r+0x8bc>
8000d804:	20 48       	sub	r8,4
8000d806:	10 0b       	add	r11,r8
8000d808:	50 4b       	stdsp	sp[0x10],r11
8000d80a:	c0 78       	rjmp	8000d818 <_dtoa_r+0x8c8>
8000d80c:	58 48       	cp.w	r8,4
8000d80e:	c0 70       	breq	8000d81c <_dtoa_r+0x8cc>
8000d810:	40 4a       	lddsp	r10,sp[0x10]
8000d812:	2e 48       	sub	r8,-28
8000d814:	10 0a       	add	r10,r8
8000d816:	50 4a       	stdsp	sp[0x10],r10
8000d818:	10 00       	add	r0,r8
8000d81a:	10 05       	add	r5,r8
8000d81c:	58 00       	cp.w	r0,0
8000d81e:	e0 8a 00 08 	brle	8000d82e <_dtoa_r+0x8de>
8000d822:	06 9b       	mov	r11,r3
8000d824:	00 9a       	mov	r10,r0
8000d826:	0e 9c       	mov	r12,r7
8000d828:	e0 a0 07 5c 	rcall	8000e6e0 <__lshift>
8000d82c:	18 93       	mov	r3,r12
8000d82e:	40 49       	lddsp	r9,sp[0x10]
8000d830:	58 09       	cp.w	r9,0
8000d832:	e0 8a 00 08 	brle	8000d842 <_dtoa_r+0x8f2>
8000d836:	04 9b       	mov	r11,r2
8000d838:	12 9a       	mov	r10,r9
8000d83a:	0e 9c       	mov	r12,r7
8000d83c:	e0 a0 07 52 	rcall	8000e6e0 <__lshift>
8000d840:	18 92       	mov	r2,r12
8000d842:	41 48       	lddsp	r8,sp[0x50]
8000d844:	58 08       	cp.w	r8,0
8000d846:	c1 b0       	breq	8000d87c <_dtoa_r+0x92c>
8000d848:	04 9b       	mov	r11,r2
8000d84a:	06 9c       	mov	r12,r3
8000d84c:	e0 a0 06 27 	rcall	8000e49a <__mcmp>
8000d850:	c1 64       	brge	8000d87c <_dtoa_r+0x92c>
8000d852:	06 9b       	mov	r11,r3
8000d854:	30 09       	mov	r9,0
8000d856:	30 aa       	mov	r10,10
8000d858:	0e 9c       	mov	r12,r7
8000d85a:	e0 a0 08 0f 	rcall	8000e878 <__multadd>
8000d85e:	20 16       	sub	r6,1
8000d860:	18 93       	mov	r3,r12
8000d862:	40 dc       	lddsp	r12,sp[0x34]
8000d864:	58 0c       	cp.w	r12,0
8000d866:	c0 31       	brne	8000d86c <_dtoa_r+0x91c>
8000d868:	40 91       	lddsp	r1,sp[0x24]
8000d86a:	c0 98       	rjmp	8000d87c <_dtoa_r+0x92c>
8000d86c:	08 9b       	mov	r11,r4
8000d86e:	40 91       	lddsp	r1,sp[0x24]
8000d870:	30 09       	mov	r9,0
8000d872:	30 aa       	mov	r10,10
8000d874:	0e 9c       	mov	r12,r7
8000d876:	e0 a0 08 01 	rcall	8000e878 <__multadd>
8000d87a:	18 94       	mov	r4,r12
8000d87c:	58 01       	cp.w	r1,0
8000d87e:	5f a9       	srle	r9
8000d880:	40 cb       	lddsp	r11,sp[0x30]
8000d882:	58 2b       	cp.w	r11,2
8000d884:	5f 98       	srgt	r8
8000d886:	f3 e8 00 08 	and	r8,r9,r8
8000d88a:	c2 50       	breq	8000d8d4 <_dtoa_r+0x984>
8000d88c:	58 01       	cp.w	r1,0
8000d88e:	c1 11       	brne	8000d8b0 <_dtoa_r+0x960>
8000d890:	04 9b       	mov	r11,r2
8000d892:	02 99       	mov	r9,r1
8000d894:	30 5a       	mov	r10,5
8000d896:	0e 9c       	mov	r12,r7
8000d898:	e0 a0 07 f0 	rcall	8000e878 <__multadd>
8000d89c:	18 92       	mov	r2,r12
8000d89e:	18 9b       	mov	r11,r12
8000d8a0:	06 9c       	mov	r12,r3
8000d8a2:	e0 a0 05 fc 	rcall	8000e49a <__mcmp>
8000d8a6:	e0 89 00 0f 	brgt	8000d8c4 <_dtoa_r+0x974>
8000d8aa:	c0 38       	rjmp	8000d8b0 <_dtoa_r+0x960>
8000d8ac:	30 02       	mov	r2,0
8000d8ae:	04 94       	mov	r4,r2
8000d8b0:	40 ea       	lddsp	r10,sp[0x38]
8000d8b2:	30 09       	mov	r9,0
8000d8b4:	5c da       	com	r10
8000d8b6:	40 85       	lddsp	r5,sp[0x20]
8000d8b8:	50 6a       	stdsp	sp[0x18],r10
8000d8ba:	50 49       	stdsp	sp[0x10],r9
8000d8bc:	c0 f9       	rjmp	8000dada <_dtoa_r+0xb8a>
8000d8be:	08 92       	mov	r2,r4
8000d8c0:	40 66       	lddsp	r6,sp[0x18]
8000d8c2:	04 94       	mov	r4,r2
8000d8c4:	2f f6       	sub	r6,-1
8000d8c6:	50 66       	stdsp	sp[0x18],r6
8000d8c8:	33 18       	mov	r8,49
8000d8ca:	40 85       	lddsp	r5,sp[0x20]
8000d8cc:	0a c8       	st.b	r5++,r8
8000d8ce:	30 08       	mov	r8,0
8000d8d0:	50 48       	stdsp	sp[0x10],r8
8000d8d2:	c0 49       	rjmp	8000dada <_dtoa_r+0xb8a>
8000d8d4:	40 dc       	lddsp	r12,sp[0x34]
8000d8d6:	58 0c       	cp.w	r12,0
8000d8d8:	e0 80 00 b5 	breq	8000da42 <_dtoa_r+0xaf2>
8000d8dc:	58 05       	cp.w	r5,0
8000d8de:	e0 8a 00 08 	brle	8000d8ee <_dtoa_r+0x99e>
8000d8e2:	08 9b       	mov	r11,r4
8000d8e4:	0a 9a       	mov	r10,r5
8000d8e6:	0e 9c       	mov	r12,r7
8000d8e8:	e0 a0 06 fc 	rcall	8000e6e0 <__lshift>
8000d8ec:	18 94       	mov	r4,r12
8000d8ee:	40 6b       	lddsp	r11,sp[0x18]
8000d8f0:	58 0b       	cp.w	r11,0
8000d8f2:	c0 31       	brne	8000d8f8 <_dtoa_r+0x9a8>
8000d8f4:	08 9c       	mov	r12,r4
8000d8f6:	c1 38       	rjmp	8000d91c <_dtoa_r+0x9cc>
8000d8f8:	68 1b       	ld.w	r11,r4[0x4]
8000d8fa:	0e 9c       	mov	r12,r7
8000d8fc:	e0 a0 06 02 	rcall	8000e500 <_Balloc>
8000d900:	68 4a       	ld.w	r10,r4[0x10]
8000d902:	18 95       	mov	r5,r12
8000d904:	e8 cb ff f4 	sub	r11,r4,-12
8000d908:	2f ea       	sub	r10,-2
8000d90a:	2f 4c       	sub	r12,-12
8000d90c:	a3 6a       	lsl	r10,0x2
8000d90e:	fe b0 e5 ae 	rcall	8000a46a <memcpy>
8000d912:	0a 9b       	mov	r11,r5
8000d914:	30 1a       	mov	r10,1
8000d916:	0e 9c       	mov	r12,r7
8000d918:	e0 a0 06 e4 	rcall	8000e6e0 <__lshift>
8000d91c:	50 44       	stdsp	sp[0x10],r4
8000d91e:	40 3a       	lddsp	r10,sp[0xc]
8000d920:	30 19       	mov	r9,1
8000d922:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
8000d926:	18 94       	mov	r4,r12
8000d928:	50 da       	stdsp	sp[0x34],r10
8000d92a:	40 85       	lddsp	r5,sp[0x20]
8000d92c:	50 99       	stdsp	sp[0x24],r9
8000d92e:	50 26       	stdsp	sp[0x8],r6
8000d930:	50 e1       	stdsp	sp[0x38],r1
8000d932:	04 9b       	mov	r11,r2
8000d934:	06 9c       	mov	r12,r3
8000d936:	fe b0 fa 7d 	rcall	8000ce30 <quorem>
8000d93a:	40 4b       	lddsp	r11,sp[0x10]
8000d93c:	f8 c0 ff d0 	sub	r0,r12,-48
8000d940:	06 9c       	mov	r12,r3
8000d942:	e0 a0 05 ac 	rcall	8000e49a <__mcmp>
8000d946:	08 9a       	mov	r10,r4
8000d948:	50 6c       	stdsp	sp[0x18],r12
8000d94a:	04 9b       	mov	r11,r2
8000d94c:	0e 9c       	mov	r12,r7
8000d94e:	e0 a0 06 61 	rcall	8000e610 <__mdiff>
8000d952:	18 91       	mov	r1,r12
8000d954:	78 38       	ld.w	r8,r12[0xc]
8000d956:	58 08       	cp.w	r8,0
8000d958:	c0 30       	breq	8000d95e <_dtoa_r+0xa0e>
8000d95a:	30 16       	mov	r6,1
8000d95c:	c0 68       	rjmp	8000d968 <_dtoa_r+0xa18>
8000d95e:	18 9b       	mov	r11,r12
8000d960:	06 9c       	mov	r12,r3
8000d962:	e0 a0 05 9c 	rcall	8000e49a <__mcmp>
8000d966:	18 96       	mov	r6,r12
8000d968:	0e 9c       	mov	r12,r7
8000d96a:	02 9b       	mov	r11,r1
8000d96c:	e0 a0 05 b0 	rcall	8000e4cc <_Bfree>
8000d970:	40 cc       	lddsp	r12,sp[0x30]
8000d972:	ed ec 10 08 	or	r8,r6,r12
8000d976:	c0 d1       	brne	8000d990 <_dtoa_r+0xa40>
8000d978:	40 db       	lddsp	r11,sp[0x34]
8000d97a:	58 0b       	cp.w	r11,0
8000d97c:	c0 a1       	brne	8000d990 <_dtoa_r+0xa40>
8000d97e:	40 26       	lddsp	r6,sp[0x8]
8000d980:	e0 40 00 39 	cp.w	r0,57
8000d984:	c3 00       	breq	8000d9e4 <_dtoa_r+0xa94>
8000d986:	40 6a       	lddsp	r10,sp[0x18]
8000d988:	58 0a       	cp.w	r10,0
8000d98a:	e0 89 00 24 	brgt	8000d9d2 <_dtoa_r+0xa82>
8000d98e:	c2 f8       	rjmp	8000d9ec <_dtoa_r+0xa9c>
8000d990:	40 69       	lddsp	r9,sp[0x18]
8000d992:	58 09       	cp.w	r9,0
8000d994:	c0 85       	brlt	8000d9a4 <_dtoa_r+0xa54>
8000d996:	12 98       	mov	r8,r9
8000d998:	40 cc       	lddsp	r12,sp[0x30]
8000d99a:	18 48       	or	r8,r12
8000d99c:	c1 d1       	brne	8000d9d6 <_dtoa_r+0xa86>
8000d99e:	40 db       	lddsp	r11,sp[0x34]
8000d9a0:	58 0b       	cp.w	r11,0
8000d9a2:	c1 a1       	brne	8000d9d6 <_dtoa_r+0xa86>
8000d9a4:	0c 99       	mov	r9,r6
8000d9a6:	40 26       	lddsp	r6,sp[0x8]
8000d9a8:	58 09       	cp.w	r9,0
8000d9aa:	e0 8a 00 21 	brle	8000d9ec <_dtoa_r+0xa9c>
8000d9ae:	06 9b       	mov	r11,r3
8000d9b0:	30 1a       	mov	r10,1
8000d9b2:	0e 9c       	mov	r12,r7
8000d9b4:	e0 a0 06 96 	rcall	8000e6e0 <__lshift>
8000d9b8:	04 9b       	mov	r11,r2
8000d9ba:	18 93       	mov	r3,r12
8000d9bc:	e0 a0 05 6f 	rcall	8000e49a <__mcmp>
8000d9c0:	e0 89 00 06 	brgt	8000d9cc <_dtoa_r+0xa7c>
8000d9c4:	c1 41       	brne	8000d9ec <_dtoa_r+0xa9c>
8000d9c6:	ed b0 00 00 	bld	r0,0x0
8000d9ca:	c1 11       	brne	8000d9ec <_dtoa_r+0xa9c>
8000d9cc:	e0 40 00 39 	cp.w	r0,57
8000d9d0:	c0 a0       	breq	8000d9e4 <_dtoa_r+0xa94>
8000d9d2:	2f f0       	sub	r0,-1
8000d9d4:	c0 c8       	rjmp	8000d9ec <_dtoa_r+0xa9c>
8000d9d6:	58 06       	cp.w	r6,0
8000d9d8:	e0 8a 00 0c 	brle	8000d9f0 <_dtoa_r+0xaa0>
8000d9dc:	40 26       	lddsp	r6,sp[0x8]
8000d9de:	e0 40 00 39 	cp.w	r0,57
8000d9e2:	c0 41       	brne	8000d9ea <_dtoa_r+0xa9a>
8000d9e4:	33 98       	mov	r8,57
8000d9e6:	0a c8       	st.b	r5++,r8
8000d9e8:	c6 78       	rjmp	8000dab6 <_dtoa_r+0xb66>
8000d9ea:	2f f0       	sub	r0,-1
8000d9ec:	0a c0       	st.b	r5++,r0
8000d9ee:	c7 58       	rjmp	8000dad8 <_dtoa_r+0xb88>
8000d9f0:	0a c0       	st.b	r5++,r0
8000d9f2:	40 9a       	lddsp	r10,sp[0x24]
8000d9f4:	40 e9       	lddsp	r9,sp[0x38]
8000d9f6:	12 3a       	cp.w	r10,r9
8000d9f8:	c4 30       	breq	8000da7e <_dtoa_r+0xb2e>
8000d9fa:	06 9b       	mov	r11,r3
8000d9fc:	30 09       	mov	r9,0
8000d9fe:	30 aa       	mov	r10,10
8000da00:	0e 9c       	mov	r12,r7
8000da02:	e0 a0 07 3b 	rcall	8000e878 <__multadd>
8000da06:	40 48       	lddsp	r8,sp[0x10]
8000da08:	18 93       	mov	r3,r12
8000da0a:	08 38       	cp.w	r8,r4
8000da0c:	c0 91       	brne	8000da1e <_dtoa_r+0xace>
8000da0e:	10 9b       	mov	r11,r8
8000da10:	30 09       	mov	r9,0
8000da12:	30 aa       	mov	r10,10
8000da14:	0e 9c       	mov	r12,r7
8000da16:	e0 a0 07 31 	rcall	8000e878 <__multadd>
8000da1a:	50 4c       	stdsp	sp[0x10],r12
8000da1c:	c0 e8       	rjmp	8000da38 <_dtoa_r+0xae8>
8000da1e:	40 4b       	lddsp	r11,sp[0x10]
8000da20:	30 09       	mov	r9,0
8000da22:	30 aa       	mov	r10,10
8000da24:	0e 9c       	mov	r12,r7
8000da26:	e0 a0 07 29 	rcall	8000e878 <__multadd>
8000da2a:	08 9b       	mov	r11,r4
8000da2c:	50 4c       	stdsp	sp[0x10],r12
8000da2e:	30 09       	mov	r9,0
8000da30:	30 aa       	mov	r10,10
8000da32:	0e 9c       	mov	r12,r7
8000da34:	e0 a0 07 22 	rcall	8000e878 <__multadd>
8000da38:	18 94       	mov	r4,r12
8000da3a:	40 9c       	lddsp	r12,sp[0x24]
8000da3c:	2f fc       	sub	r12,-1
8000da3e:	50 9c       	stdsp	sp[0x24],r12
8000da40:	c7 9b       	rjmp	8000d932 <_dtoa_r+0x9e2>
8000da42:	30 18       	mov	r8,1
8000da44:	06 90       	mov	r0,r3
8000da46:	40 85       	lddsp	r5,sp[0x20]
8000da48:	08 93       	mov	r3,r4
8000da4a:	0c 94       	mov	r4,r6
8000da4c:	10 96       	mov	r6,r8
8000da4e:	04 9b       	mov	r11,r2
8000da50:	00 9c       	mov	r12,r0
8000da52:	fe b0 f9 ef 	rcall	8000ce30 <quorem>
8000da56:	2d 0c       	sub	r12,-48
8000da58:	0a cc       	st.b	r5++,r12
8000da5a:	02 36       	cp.w	r6,r1
8000da5c:	c0 a4       	brge	8000da70 <_dtoa_r+0xb20>
8000da5e:	00 9b       	mov	r11,r0
8000da60:	30 09       	mov	r9,0
8000da62:	30 aa       	mov	r10,10
8000da64:	0e 9c       	mov	r12,r7
8000da66:	2f f6       	sub	r6,-1
8000da68:	e0 a0 07 08 	rcall	8000e878 <__multadd>
8000da6c:	18 90       	mov	r0,r12
8000da6e:	cf 0b       	rjmp	8000da4e <_dtoa_r+0xafe>
8000da70:	08 96       	mov	r6,r4
8000da72:	30 0b       	mov	r11,0
8000da74:	06 94       	mov	r4,r3
8000da76:	50 4b       	stdsp	sp[0x10],r11
8000da78:	00 93       	mov	r3,r0
8000da7a:	18 90       	mov	r0,r12
8000da7c:	c0 28       	rjmp	8000da80 <_dtoa_r+0xb30>
8000da7e:	40 26       	lddsp	r6,sp[0x8]
8000da80:	06 9b       	mov	r11,r3
8000da82:	30 1a       	mov	r10,1
8000da84:	0e 9c       	mov	r12,r7
8000da86:	e0 a0 06 2d 	rcall	8000e6e0 <__lshift>
8000da8a:	04 9b       	mov	r11,r2
8000da8c:	18 93       	mov	r3,r12
8000da8e:	e0 a0 05 06 	rcall	8000e49a <__mcmp>
8000da92:	e0 89 00 12 	brgt	8000dab6 <_dtoa_r+0xb66>
8000da96:	c1 b1       	brne	8000dacc <_dtoa_r+0xb7c>
8000da98:	e1 d0 c0 01 	bfextu	r0,r0,0x0,0x1
8000da9c:	c0 d1       	brne	8000dab6 <_dtoa_r+0xb66>
8000da9e:	c1 78       	rjmp	8000dacc <_dtoa_r+0xb7c>
8000daa0:	40 89       	lddsp	r9,sp[0x20]
8000daa2:	12 38       	cp.w	r8,r9
8000daa4:	c0 30       	breq	8000daaa <_dtoa_r+0xb5a>
8000daa6:	10 95       	mov	r5,r8
8000daa8:	c0 88       	rjmp	8000dab8 <_dtoa_r+0xb68>
8000daaa:	2f f6       	sub	r6,-1
8000daac:	50 66       	stdsp	sp[0x18],r6
8000daae:	33 18       	mov	r8,49
8000dab0:	40 8c       	lddsp	r12,sp[0x20]
8000dab2:	b8 88       	st.b	r12[0x0],r8
8000dab4:	c1 38       	rjmp	8000dada <_dtoa_r+0xb8a>
8000dab6:	33 9a       	mov	r10,57
8000dab8:	0a 98       	mov	r8,r5
8000daba:	11 79       	ld.ub	r9,--r8
8000dabc:	f4 09 18 00 	cp.b	r9,r10
8000dac0:	cf 00       	breq	8000daa0 <_dtoa_r+0xb50>
8000dac2:	2f f9       	sub	r9,-1
8000dac4:	b0 89       	st.b	r8[0x0],r9
8000dac6:	c0 98       	rjmp	8000dad8 <_dtoa_r+0xb88>
8000dac8:	10 95       	mov	r5,r8
8000daca:	c0 28       	rjmp	8000dace <_dtoa_r+0xb7e>
8000dacc:	33 09       	mov	r9,48
8000dace:	0a 98       	mov	r8,r5
8000dad0:	11 7a       	ld.ub	r10,--r8
8000dad2:	f2 0a 18 00 	cp.b	r10,r9
8000dad6:	cf 90       	breq	8000dac8 <_dtoa_r+0xb78>
8000dad8:	50 66       	stdsp	sp[0x18],r6
8000dada:	04 9b       	mov	r11,r2
8000dadc:	0e 9c       	mov	r12,r7
8000dade:	e0 a0 04 f7 	rcall	8000e4cc <_Bfree>
8000dae2:	58 04       	cp.w	r4,0
8000dae4:	c1 20       	breq	8000db08 <_dtoa_r+0xbb8>
8000dae6:	40 4b       	lddsp	r11,sp[0x10]
8000dae8:	08 3b       	cp.w	r11,r4
8000daea:	5f 19       	srne	r9
8000daec:	58 0b       	cp.w	r11,0
8000daee:	5f 18       	srne	r8
8000daf0:	f3 e8 00 08 	and	r8,r9,r8
8000daf4:	c0 40       	breq	8000dafc <_dtoa_r+0xbac>
8000daf6:	0e 9c       	mov	r12,r7
8000daf8:	e0 a0 04 ea 	rcall	8000e4cc <_Bfree>
8000dafc:	08 9b       	mov	r11,r4
8000dafe:	0e 9c       	mov	r12,r7
8000db00:	e0 a0 04 e6 	rcall	8000e4cc <_Bfree>
8000db04:	c0 28       	rjmp	8000db08 <_dtoa_r+0xbb8>
8000db06:	50 66       	stdsp	sp[0x18],r6
8000db08:	0e 9c       	mov	r12,r7
8000db0a:	06 9b       	mov	r11,r3
8000db0c:	e0 a0 04 e0 	rcall	8000e4cc <_Bfree>
8000db10:	30 08       	mov	r8,0
8000db12:	aa 88       	st.b	r5[0x0],r8
8000db14:	40 68       	lddsp	r8,sp[0x18]
8000db16:	41 5a       	lddsp	r10,sp[0x54]
8000db18:	2f f8       	sub	r8,-1
8000db1a:	41 29       	lddsp	r9,sp[0x48]
8000db1c:	95 08       	st.w	r10[0x0],r8
8000db1e:	40 8c       	lddsp	r12,sp[0x20]
8000db20:	58 09       	cp.w	r9,0
8000db22:	fb f8 10 12 	ld.wne	r8,sp[0x48]
8000db26:	f1 f5 1a 00 	st.wne	r8[0x0],r5
8000db2a:	2e 6d       	sub	sp,-104
8000db2c:	d8 32       	popm	r0-r7,pc
8000db2e:	d7 03       	nop

8000db30 <__errno>:
8000db30:	e0 68 0a 38 	mov	r8,2616
8000db34:	70 0c       	ld.w	r12,r8[0x0]
8000db36:	2f 4c       	sub	r12,-12
8000db38:	5e fc       	retal	r12
8000db3a:	d7 03       	nop

8000db3c <_fflush_r>:
8000db3c:	d4 21       	pushm	r4-r7,lr
8000db3e:	16 97       	mov	r7,r11
8000db40:	18 96       	mov	r6,r12
8000db42:	76 48       	ld.w	r8,r11[0x10]
8000db44:	58 08       	cp.w	r8,0
8000db46:	c7 c0       	breq	8000dc3e <_fflush_r+0x102>
8000db48:	58 0c       	cp.w	r12,0
8000db4a:	c0 50       	breq	8000db54 <_fflush_r+0x18>
8000db4c:	78 68       	ld.w	r8,r12[0x18]
8000db4e:	58 08       	cp.w	r8,0
8000db50:	c0 21       	brne	8000db54 <_fflush_r+0x18>
8000db52:	cd 1c       	rcall	8000dcf4 <__sinit>
8000db54:	4b b8       	lddpc	r8,8000dc40 <_fflush_r+0x104>
8000db56:	10 37       	cp.w	r7,r8
8000db58:	c0 31       	brne	8000db5e <_fflush_r+0x22>
8000db5a:	6c 07       	ld.w	r7,r6[0x0]
8000db5c:	c0 a8       	rjmp	8000db70 <_fflush_r+0x34>
8000db5e:	4b a8       	lddpc	r8,8000dc44 <_fflush_r+0x108>
8000db60:	10 37       	cp.w	r7,r8
8000db62:	c0 31       	brne	8000db68 <_fflush_r+0x2c>
8000db64:	6c 17       	ld.w	r7,r6[0x4]
8000db66:	c0 58       	rjmp	8000db70 <_fflush_r+0x34>
8000db68:	4b 88       	lddpc	r8,8000dc48 <_fflush_r+0x10c>
8000db6a:	10 37       	cp.w	r7,r8
8000db6c:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000db70:	8e 6a       	ld.sh	r10,r7[0xc]
8000db72:	14 98       	mov	r8,r10
8000db74:	ed ba 00 03 	bld	r10,0x3
8000db78:	c4 20       	breq	8000dbfc <_fflush_r+0xc0>
8000db7a:	ab ba       	sbr	r10,0xb
8000db7c:	ae 6a       	st.h	r7[0xc],r10
8000db7e:	6e 18       	ld.w	r8,r7[0x4]
8000db80:	58 08       	cp.w	r8,0
8000db82:	e0 89 00 06 	brgt	8000db8e <_fflush_r+0x52>
8000db86:	6f 08       	ld.w	r8,r7[0x40]
8000db88:	58 08       	cp.w	r8,0
8000db8a:	e0 8a 00 5a 	brle	8000dc3e <_fflush_r+0x102>
8000db8e:	6e b8       	ld.w	r8,r7[0x2c]
8000db90:	58 08       	cp.w	r8,0
8000db92:	c5 60       	breq	8000dc3e <_fflush_r+0x102>
8000db94:	e2 1a 10 00 	andl	r10,0x1000,COH
8000db98:	c0 30       	breq	8000db9e <_fflush_r+0x62>
8000db9a:	6f 55       	ld.w	r5,r7[0x54]
8000db9c:	c0 f8       	rjmp	8000dbba <_fflush_r+0x7e>
8000db9e:	30 19       	mov	r9,1
8000dba0:	6e 8b       	ld.w	r11,r7[0x20]
8000dba2:	0c 9c       	mov	r12,r6
8000dba4:	5d 18       	icall	r8
8000dba6:	18 95       	mov	r5,r12
8000dba8:	5b fc       	cp.w	r12,-1
8000dbaa:	c0 81       	brne	8000dbba <_fflush_r+0x7e>
8000dbac:	6c 38       	ld.w	r8,r6[0xc]
8000dbae:	59 d8       	cp.w	r8,29
8000dbb0:	c4 70       	breq	8000dc3e <_fflush_r+0x102>
8000dbb2:	8e 68       	ld.sh	r8,r7[0xc]
8000dbb4:	a7 a8       	sbr	r8,0x6
8000dbb6:	ae 68       	st.h	r7[0xc],r8
8000dbb8:	d8 22       	popm	r4-r7,pc
8000dbba:	8e 68       	ld.sh	r8,r7[0xc]
8000dbbc:	ed b8 00 02 	bld	r8,0x2
8000dbc0:	c0 91       	brne	8000dbd2 <_fflush_r+0x96>
8000dbc2:	6e 18       	ld.w	r8,r7[0x4]
8000dbc4:	10 15       	sub	r5,r8
8000dbc6:	6e d8       	ld.w	r8,r7[0x34]
8000dbc8:	58 08       	cp.w	r8,0
8000dbca:	ef f8 10 10 	ld.wne	r8,r7[0x40]
8000dbce:	eb d8 e1 15 	subne	r5,r5,r8
8000dbd2:	6e b8       	ld.w	r8,r7[0x2c]
8000dbd4:	0c 9c       	mov	r12,r6
8000dbd6:	30 09       	mov	r9,0
8000dbd8:	0a 9a       	mov	r10,r5
8000dbda:	6e 8b       	ld.w	r11,r7[0x20]
8000dbdc:	5d 18       	icall	r8
8000dbde:	8e 68       	ld.sh	r8,r7[0xc]
8000dbe0:	0a 3c       	cp.w	r12,r5
8000dbe2:	c2 61       	brne	8000dc2e <_fflush_r+0xf2>
8000dbe4:	ab d8       	cbr	r8,0xb
8000dbe6:	30 0c       	mov	r12,0
8000dbe8:	6e 49       	ld.w	r9,r7[0x10]
8000dbea:	ae 68       	st.h	r7[0xc],r8
8000dbec:	8f 1c       	st.w	r7[0x4],r12
8000dbee:	8f 09       	st.w	r7[0x0],r9
8000dbf0:	ed b8 00 0c 	bld	r8,0xc
8000dbf4:	c2 51       	brne	8000dc3e <_fflush_r+0x102>
8000dbf6:	ef 45 00 54 	st.w	r7[84],r5
8000dbfa:	d8 22       	popm	r4-r7,pc
8000dbfc:	6e 45       	ld.w	r5,r7[0x10]
8000dbfe:	58 05       	cp.w	r5,0
8000dc00:	c1 f0       	breq	8000dc3e <_fflush_r+0x102>
8000dc02:	6e 04       	ld.w	r4,r7[0x0]
8000dc04:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
8000dc08:	8f 05       	st.w	r7[0x0],r5
8000dc0a:	f9 b8 01 00 	movne	r8,0
8000dc0e:	ef f8 00 05 	ld.weq	r8,r7[0x14]
8000dc12:	0a 14       	sub	r4,r5
8000dc14:	8f 28       	st.w	r7[0x8],r8
8000dc16:	c1 18       	rjmp	8000dc38 <_fflush_r+0xfc>
8000dc18:	08 99       	mov	r9,r4
8000dc1a:	0a 9a       	mov	r10,r5
8000dc1c:	6e a8       	ld.w	r8,r7[0x28]
8000dc1e:	6e 8b       	ld.w	r11,r7[0x20]
8000dc20:	0c 9c       	mov	r12,r6
8000dc22:	5d 18       	icall	r8
8000dc24:	18 14       	sub	r4,r12
8000dc26:	58 0c       	cp.w	r12,0
8000dc28:	e0 89 00 07 	brgt	8000dc36 <_fflush_r+0xfa>
8000dc2c:	8e 68       	ld.sh	r8,r7[0xc]
8000dc2e:	a7 a8       	sbr	r8,0x6
8000dc30:	3f fc       	mov	r12,-1
8000dc32:	ae 68       	st.h	r7[0xc],r8
8000dc34:	d8 22       	popm	r4-r7,pc
8000dc36:	18 05       	add	r5,r12
8000dc38:	58 04       	cp.w	r4,0
8000dc3a:	fe 99 ff ef 	brgt	8000dc18 <_fflush_r+0xdc>
8000dc3e:	d8 2a       	popm	r4-r7,pc,r12=0
8000dc40:	80 01       	ld.sh	r1,r0[0x0]
8000dc42:	92 d0       	ld.uh	r0,r9[0xa]
8000dc44:	80 01       	ld.sh	r1,r0[0x0]
8000dc46:	92 f0       	ld.uh	r0,r9[0xe]
8000dc48:	80 01       	ld.sh	r1,r0[0x0]
8000dc4a:	93 10       	st.w	r9[0x4],r0

8000dc4c <__sfp_lock_acquire>:
8000dc4c:	5e fc       	retal	r12

8000dc4e <__sfp_lock_release>:
8000dc4e:	5e fc       	retal	r12

8000dc50 <_cleanup_r>:
8000dc50:	d4 01       	pushm	lr
8000dc52:	fe cb f0 ba 	sub	r11,pc,-3910
8000dc56:	e0 a0 02 f9 	rcall	8000e248 <_fwalk>
8000dc5a:	d8 02       	popm	pc

8000dc5c <__sfmoreglue>:
8000dc5c:	d4 21       	pushm	r4-r7,lr
8000dc5e:	16 95       	mov	r5,r11
8000dc60:	f6 06 10 5c 	mul	r6,r11,92
8000dc64:	ec cb ff f4 	sub	r11,r6,-12
8000dc68:	fe b0 e1 d2 	rcall	8000a00c <_malloc_r>
8000dc6c:	18 97       	mov	r7,r12
8000dc6e:	c0 90       	breq	8000dc80 <__sfmoreglue+0x24>
8000dc70:	99 15       	st.w	r12[0x4],r5
8000dc72:	30 0b       	mov	r11,0
8000dc74:	2f 4c       	sub	r12,-12
8000dc76:	0c 9a       	mov	r10,r6
8000dc78:	8f 2c       	st.w	r7[0x8],r12
8000dc7a:	8f 0b       	st.w	r7[0x0],r11
8000dc7c:	fe b0 e4 9b 	rcall	8000a5b2 <memset>
8000dc80:	0e 9c       	mov	r12,r7
8000dc82:	d8 22       	popm	r4-r7,pc

8000dc84 <__sfp>:
8000dc84:	d4 21       	pushm	r4-r7,lr
8000dc86:	49 b8       	lddpc	r8,8000dcf0 <__sfp+0x6c>
8000dc88:	18 96       	mov	r6,r12
8000dc8a:	70 07       	ld.w	r7,r8[0x0]
8000dc8c:	6e 68       	ld.w	r8,r7[0x18]
8000dc8e:	58 08       	cp.w	r8,0
8000dc90:	c0 31       	brne	8000dc96 <__sfp+0x12>
8000dc92:	0e 9c       	mov	r12,r7
8000dc94:	c3 0c       	rcall	8000dcf4 <__sinit>
8000dc96:	ee c7 ff 28 	sub	r7,r7,-216
8000dc9a:	30 05       	mov	r5,0
8000dc9c:	6e 2c       	ld.w	r12,r7[0x8]
8000dc9e:	6e 18       	ld.w	r8,r7[0x4]
8000dca0:	c0 68       	rjmp	8000dcac <__sfp+0x28>
8000dca2:	98 69       	ld.sh	r9,r12[0xc]
8000dca4:	ea 09 19 00 	cp.h	r9,r5
8000dca8:	c1 10       	breq	8000dcca <__sfp+0x46>
8000dcaa:	2a 4c       	sub	r12,-92
8000dcac:	20 18       	sub	r8,1
8000dcae:	cf a7       	brpl	8000dca2 <__sfp+0x1e>
8000dcb0:	6e 08       	ld.w	r8,r7[0x0]
8000dcb2:	58 08       	cp.w	r8,0
8000dcb4:	c0 61       	brne	8000dcc0 <__sfp+0x3c>
8000dcb6:	30 4b       	mov	r11,4
8000dcb8:	0c 9c       	mov	r12,r6
8000dcba:	cd 1f       	rcall	8000dc5c <__sfmoreglue>
8000dcbc:	8f 0c       	st.w	r7[0x0],r12
8000dcbe:	c0 30       	breq	8000dcc4 <__sfp+0x40>
8000dcc0:	6e 07       	ld.w	r7,r7[0x0]
8000dcc2:	ce db       	rjmp	8000dc9c <__sfp+0x18>
8000dcc4:	30 c8       	mov	r8,12
8000dcc6:	8d 38       	st.w	r6[0xc],r8
8000dcc8:	d8 22       	popm	r4-r7,pc
8000dcca:	30 08       	mov	r8,0
8000dccc:	f9 48 00 4c 	st.w	r12[76],r8
8000dcd0:	99 08       	st.w	r12[0x0],r8
8000dcd2:	99 28       	st.w	r12[0x8],r8
8000dcd4:	99 18       	st.w	r12[0x4],r8
8000dcd6:	99 48       	st.w	r12[0x10],r8
8000dcd8:	99 58       	st.w	r12[0x14],r8
8000dcda:	99 68       	st.w	r12[0x18],r8
8000dcdc:	99 d8       	st.w	r12[0x34],r8
8000dcde:	99 e8       	st.w	r12[0x38],r8
8000dce0:	f9 48 00 48 	st.w	r12[72],r8
8000dce4:	3f f8       	mov	r8,-1
8000dce6:	b8 78       	st.h	r12[0xe],r8
8000dce8:	30 18       	mov	r8,1
8000dcea:	b8 68       	st.h	r12[0xc],r8
8000dcec:	d8 22       	popm	r4-r7,pc
8000dcee:	d7 03       	nop
8000dcf0:	80 01       	ld.sh	r1,r0[0x0]
8000dcf2:	93 34       	st.w	r9[0xc],r4

8000dcf4 <__sinit>:
8000dcf4:	d4 21       	pushm	r4-r7,lr
8000dcf6:	18 96       	mov	r6,r12
8000dcf8:	78 67       	ld.w	r7,r12[0x18]
8000dcfa:	58 07       	cp.w	r7,0
8000dcfc:	c4 91       	brne	8000dd8e <__sinit+0x9a>
8000dcfe:	fe c8 00 ae 	sub	r8,pc,174
8000dd02:	30 15       	mov	r5,1
8000dd04:	99 a8       	st.w	r12[0x28],r8
8000dd06:	f9 47 00 d8 	st.w	r12[216],r7
8000dd0a:	f9 47 00 dc 	st.w	r12[220],r7
8000dd0e:	f9 47 00 e0 	st.w	r12[224],r7
8000dd12:	99 65       	st.w	r12[0x18],r5
8000dd14:	cb 8f       	rcall	8000dc84 <__sfp>
8000dd16:	8d 0c       	st.w	r6[0x0],r12
8000dd18:	0c 9c       	mov	r12,r6
8000dd1a:	cb 5f       	rcall	8000dc84 <__sfp>
8000dd1c:	8d 1c       	st.w	r6[0x4],r12
8000dd1e:	0c 9c       	mov	r12,r6
8000dd20:	cb 2f       	rcall	8000dc84 <__sfp>
8000dd22:	6c 09       	ld.w	r9,r6[0x0]
8000dd24:	30 48       	mov	r8,4
8000dd26:	93 07       	st.w	r9[0x0],r7
8000dd28:	b2 68       	st.h	r9[0xc],r8
8000dd2a:	93 17       	st.w	r9[0x4],r7
8000dd2c:	93 27       	st.w	r9[0x8],r7
8000dd2e:	6c 18       	ld.w	r8,r6[0x4]
8000dd30:	b2 77       	st.h	r9[0xe],r7
8000dd32:	93 47       	st.w	r9[0x10],r7
8000dd34:	93 57       	st.w	r9[0x14],r7
8000dd36:	93 67       	st.w	r9[0x18],r7
8000dd38:	93 89       	st.w	r9[0x20],r9
8000dd3a:	91 07       	st.w	r8[0x0],r7
8000dd3c:	91 17       	st.w	r8[0x4],r7
8000dd3e:	91 27       	st.w	r8[0x8],r7
8000dd40:	fe ce f3 20 	sub	lr,pc,-3296
8000dd44:	fe cb f3 50 	sub	r11,pc,-3248
8000dd48:	93 9e       	st.w	r9[0x24],lr
8000dd4a:	93 ab       	st.w	r9[0x28],r11
8000dd4c:	fe ca f3 78 	sub	r10,pc,-3208
8000dd50:	fe c4 f3 84 	sub	r4,pc,-3196
8000dd54:	93 ba       	st.w	r9[0x2c],r10
8000dd56:	93 c4       	st.w	r9[0x30],r4
8000dd58:	30 99       	mov	r9,9
8000dd5a:	b0 69       	st.h	r8[0xc],r9
8000dd5c:	b0 75       	st.h	r8[0xe],r5
8000dd5e:	91 c4       	st.w	r8[0x30],r4
8000dd60:	91 47       	st.w	r8[0x10],r7
8000dd62:	91 57       	st.w	r8[0x14],r7
8000dd64:	91 67       	st.w	r8[0x18],r7
8000dd66:	91 88       	st.w	r8[0x20],r8
8000dd68:	91 9e       	st.w	r8[0x24],lr
8000dd6a:	91 ab       	st.w	r8[0x28],r11
8000dd6c:	91 ba       	st.w	r8[0x2c],r10
8000dd6e:	8d 2c       	st.w	r6[0x8],r12
8000dd70:	31 28       	mov	r8,18
8000dd72:	99 07       	st.w	r12[0x0],r7
8000dd74:	b8 68       	st.h	r12[0xc],r8
8000dd76:	99 17       	st.w	r12[0x4],r7
8000dd78:	99 27       	st.w	r12[0x8],r7
8000dd7a:	30 28       	mov	r8,2
8000dd7c:	b8 78       	st.h	r12[0xe],r8
8000dd7e:	99 c4       	st.w	r12[0x30],r4
8000dd80:	99 67       	st.w	r12[0x18],r7
8000dd82:	99 9e       	st.w	r12[0x24],lr
8000dd84:	99 ab       	st.w	r12[0x28],r11
8000dd86:	99 ba       	st.w	r12[0x2c],r10
8000dd88:	99 47       	st.w	r12[0x10],r7
8000dd8a:	99 57       	st.w	r12[0x14],r7
8000dd8c:	99 8c       	st.w	r12[0x20],r12
8000dd8e:	d8 22       	popm	r4-r7,pc

8000dd90 <_malloc_trim_r>:
8000dd90:	d4 21       	pushm	r4-r7,lr
8000dd92:	16 95       	mov	r5,r11
8000dd94:	18 97       	mov	r7,r12
8000dd96:	fe b0 d6 87 	rcall	80008aa4 <__malloc_lock>
8000dd9a:	e0 64 05 38 	mov	r4,1336
8000dd9e:	68 28       	ld.w	r8,r4[0x8]
8000dda0:	70 16       	ld.w	r6,r8[0x4]
8000dda2:	e0 16 ff fc 	andl	r6,0xfffc
8000dda6:	ec c8 ff 91 	sub	r8,r6,-111
8000ddaa:	f0 05 01 05 	sub	r5,r8,r5
8000ddae:	e0 15 ff 80 	andl	r5,0xff80
8000ddb2:	ea c5 00 80 	sub	r5,r5,128
8000ddb6:	e0 45 00 7f 	cp.w	r5,127
8000ddba:	e0 8a 00 25 	brle	8000de04 <_malloc_trim_r+0x74>
8000ddbe:	30 0b       	mov	r11,0
8000ddc0:	0e 9c       	mov	r12,r7
8000ddc2:	fe b0 e5 5f 	rcall	8000a880 <_sbrk_r>
8000ddc6:	68 28       	ld.w	r8,r4[0x8]
8000ddc8:	0c 08       	add	r8,r6
8000ddca:	10 3c       	cp.w	r12,r8
8000ddcc:	c1 c1       	brne	8000de04 <_malloc_trim_r+0x74>
8000ddce:	ea 0b 11 00 	rsub	r11,r5,0
8000ddd2:	0e 9c       	mov	r12,r7
8000ddd4:	fe b0 e5 56 	rcall	8000a880 <_sbrk_r>
8000ddd8:	5b fc       	cp.w	r12,-1
8000ddda:	c1 91       	brne	8000de0c <_malloc_trim_r+0x7c>
8000dddc:	30 0b       	mov	r11,0
8000ddde:	0e 9c       	mov	r12,r7
8000dde0:	fe b0 e5 50 	rcall	8000a880 <_sbrk_r>
8000dde4:	68 28       	ld.w	r8,r4[0x8]
8000dde6:	f8 08 01 09 	sub	r9,r12,r8
8000ddea:	58 f9       	cp.w	r9,15
8000ddec:	e0 8a 00 0c 	brle	8000de04 <_malloc_trim_r+0x74>
8000ddf0:	a1 a9       	sbr	r9,0x0
8000ddf2:	91 19       	st.w	r8[0x4],r9
8000ddf4:	e0 68 09 44 	mov	r8,2372
8000ddf8:	70 09       	ld.w	r9,r8[0x0]
8000ddfa:	e0 68 12 a0 	mov	r8,4768
8000ddfe:	f8 09 01 09 	sub	r9,r12,r9
8000de02:	91 09       	st.w	r8[0x0],r9
8000de04:	0e 9c       	mov	r12,r7
8000de06:	fe b0 d6 55 	rcall	80008ab0 <__malloc_unlock>
8000de0a:	d8 2a       	popm	r4-r7,pc,r12=0
8000de0c:	68 28       	ld.w	r8,r4[0x8]
8000de0e:	0a 16       	sub	r6,r5
8000de10:	a1 a6       	sbr	r6,0x0
8000de12:	91 16       	st.w	r8[0x4],r6
8000de14:	e0 68 12 a0 	mov	r8,4768
8000de18:	70 09       	ld.w	r9,r8[0x0]
8000de1a:	0a 19       	sub	r9,r5
8000de1c:	0e 9c       	mov	r12,r7
8000de1e:	91 09       	st.w	r8[0x0],r9
8000de20:	fe b0 d6 48 	rcall	80008ab0 <__malloc_unlock>
8000de24:	da 2a       	popm	r4-r7,pc,r12=1
8000de26:	d7 03       	nop

8000de28 <_free_r>:
8000de28:	d4 21       	pushm	r4-r7,lr
8000de2a:	16 96       	mov	r6,r11
8000de2c:	18 97       	mov	r7,r12
8000de2e:	58 0b       	cp.w	r11,0
8000de30:	e0 80 00 c0 	breq	8000dfb0 <_free_r+0x188>
8000de34:	fe b0 d6 38 	rcall	80008aa4 <__malloc_lock>
8000de38:	20 86       	sub	r6,8
8000de3a:	e0 6a 05 38 	mov	r10,1336
8000de3e:	6c 18       	ld.w	r8,r6[0x4]
8000de40:	74 2e       	ld.w	lr,r10[0x8]
8000de42:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
8000de46:	a1 c8       	cbr	r8,0x0
8000de48:	ec 08 00 09 	add	r9,r6,r8
8000de4c:	72 1b       	ld.w	r11,r9[0x4]
8000de4e:	e0 1b ff fc 	andl	r11,0xfffc
8000de52:	1c 39       	cp.w	r9,lr
8000de54:	c1 e1       	brne	8000de90 <_free_r+0x68>
8000de56:	f6 08 00 08 	add	r8,r11,r8
8000de5a:	58 0c       	cp.w	r12,0
8000de5c:	c0 81       	brne	8000de6c <_free_r+0x44>
8000de5e:	6c 09       	ld.w	r9,r6[0x0]
8000de60:	12 16       	sub	r6,r9
8000de62:	12 08       	add	r8,r9
8000de64:	6c 3b       	ld.w	r11,r6[0xc]
8000de66:	6c 29       	ld.w	r9,r6[0x8]
8000de68:	97 29       	st.w	r11[0x8],r9
8000de6a:	93 3b       	st.w	r9[0xc],r11
8000de6c:	10 99       	mov	r9,r8
8000de6e:	95 26       	st.w	r10[0x8],r6
8000de70:	a1 a9       	sbr	r9,0x0
8000de72:	8d 19       	st.w	r6[0x4],r9
8000de74:	e0 69 09 40 	mov	r9,2368
8000de78:	72 09       	ld.w	r9,r9[0x0]
8000de7a:	12 38       	cp.w	r8,r9
8000de7c:	c0 63       	brcs	8000de88 <_free_r+0x60>
8000de7e:	e0 68 12 9c 	mov	r8,4764
8000de82:	0e 9c       	mov	r12,r7
8000de84:	70 0b       	ld.w	r11,r8[0x0]
8000de86:	c8 5f       	rcall	8000dd90 <_malloc_trim_r>
8000de88:	0e 9c       	mov	r12,r7
8000de8a:	fe b0 d6 13 	rcall	80008ab0 <__malloc_unlock>
8000de8e:	d8 22       	popm	r4-r7,pc
8000de90:	93 1b       	st.w	r9[0x4],r11
8000de92:	58 0c       	cp.w	r12,0
8000de94:	c0 30       	breq	8000de9a <_free_r+0x72>
8000de96:	30 0c       	mov	r12,0
8000de98:	c1 08       	rjmp	8000deb8 <_free_r+0x90>
8000de9a:	6c 0e       	ld.w	lr,r6[0x0]
8000de9c:	f4 c5 ff f8 	sub	r5,r10,-8
8000dea0:	1c 16       	sub	r6,lr
8000dea2:	1c 08       	add	r8,lr
8000dea4:	6c 2e       	ld.w	lr,r6[0x8]
8000dea6:	0a 3e       	cp.w	lr,r5
8000dea8:	f9 bc 00 01 	moveq	r12,1
8000deac:	ed f5 10 03 	ld.wne	r5,r6[0xc]
8000deb0:	eb fe 1a 02 	st.wne	r5[0x8],lr
8000deb4:	fd f5 1a 03 	st.wne	lr[0xc],r5
8000deb8:	f2 0b 00 0e 	add	lr,r9,r11
8000debc:	7c 1e       	ld.w	lr,lr[0x4]
8000debe:	ed be 00 00 	bld	lr,0x0
8000dec2:	c1 40       	breq	8000deea <_free_r+0xc2>
8000dec4:	16 08       	add	r8,r11
8000dec6:	58 0c       	cp.w	r12,0
8000dec8:	c0 d1       	brne	8000dee2 <_free_r+0xba>
8000deca:	e0 6e 05 38 	mov	lr,1336
8000dece:	72 2b       	ld.w	r11,r9[0x8]
8000ded0:	2f 8e       	sub	lr,-8
8000ded2:	1c 3b       	cp.w	r11,lr
8000ded4:	c0 71       	brne	8000dee2 <_free_r+0xba>
8000ded6:	97 36       	st.w	r11[0xc],r6
8000ded8:	97 26       	st.w	r11[0x8],r6
8000deda:	8d 2b       	st.w	r6[0x8],r11
8000dedc:	8d 3b       	st.w	r6[0xc],r11
8000dede:	30 1c       	mov	r12,1
8000dee0:	c0 58       	rjmp	8000deea <_free_r+0xc2>
8000dee2:	72 2b       	ld.w	r11,r9[0x8]
8000dee4:	72 39       	ld.w	r9,r9[0xc]
8000dee6:	93 2b       	st.w	r9[0x8],r11
8000dee8:	97 39       	st.w	r11[0xc],r9
8000deea:	10 99       	mov	r9,r8
8000deec:	ec 08 09 08 	st.w	r6[r8],r8
8000def0:	a1 a9       	sbr	r9,0x0
8000def2:	8d 19       	st.w	r6[0x4],r9
8000def4:	58 0c       	cp.w	r12,0
8000def6:	c5 a1       	brne	8000dfaa <_free_r+0x182>
8000def8:	e0 48 01 ff 	cp.w	r8,511
8000defc:	e0 8b 00 13 	brhi	8000df22 <_free_r+0xfa>
8000df00:	a3 98       	lsr	r8,0x3
8000df02:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000df06:	72 2b       	ld.w	r11,r9[0x8]
8000df08:	8d 39       	st.w	r6[0xc],r9
8000df0a:	8d 2b       	st.w	r6[0x8],r11
8000df0c:	97 36       	st.w	r11[0xc],r6
8000df0e:	93 26       	st.w	r9[0x8],r6
8000df10:	a3 48       	asr	r8,0x2
8000df12:	74 19       	ld.w	r9,r10[0x4]
8000df14:	30 1b       	mov	r11,1
8000df16:	f6 08 09 48 	lsl	r8,r11,r8
8000df1a:	f3 e8 10 08 	or	r8,r9,r8
8000df1e:	95 18       	st.w	r10[0x4],r8
8000df20:	c4 58       	rjmp	8000dfaa <_free_r+0x182>
8000df22:	f0 0b 16 09 	lsr	r11,r8,0x9
8000df26:	58 4b       	cp.w	r11,4
8000df28:	e0 8b 00 06 	brhi	8000df34 <_free_r+0x10c>
8000df2c:	f0 0b 16 06 	lsr	r11,r8,0x6
8000df30:	2c 8b       	sub	r11,-56
8000df32:	c2 08       	rjmp	8000df72 <_free_r+0x14a>
8000df34:	59 4b       	cp.w	r11,20
8000df36:	e0 8b 00 04 	brhi	8000df3e <_free_r+0x116>
8000df3a:	2a 5b       	sub	r11,-91
8000df3c:	c1 b8       	rjmp	8000df72 <_free_r+0x14a>
8000df3e:	e0 4b 00 54 	cp.w	r11,84
8000df42:	e0 8b 00 06 	brhi	8000df4e <_free_r+0x126>
8000df46:	f0 0b 16 0c 	lsr	r11,r8,0xc
8000df4a:	29 2b       	sub	r11,-110
8000df4c:	c1 38       	rjmp	8000df72 <_free_r+0x14a>
8000df4e:	e0 4b 01 54 	cp.w	r11,340
8000df52:	e0 8b 00 06 	brhi	8000df5e <_free_r+0x136>
8000df56:	f0 0b 16 0f 	lsr	r11,r8,0xf
8000df5a:	28 9b       	sub	r11,-119
8000df5c:	c0 b8       	rjmp	8000df72 <_free_r+0x14a>
8000df5e:	e0 4b 05 54 	cp.w	r11,1364
8000df62:	e0 88 00 05 	brls	8000df6c <_free_r+0x144>
8000df66:	37 eb       	mov	r11,126
8000df68:	c0 58       	rjmp	8000df72 <_free_r+0x14a>
8000df6a:	d7 03       	nop
8000df6c:	f0 0b 16 12 	lsr	r11,r8,0x12
8000df70:	28 4b       	sub	r11,-124
8000df72:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
8000df76:	78 29       	ld.w	r9,r12[0x8]
8000df78:	18 39       	cp.w	r9,r12
8000df7a:	c0 e1       	brne	8000df96 <_free_r+0x16e>
8000df7c:	74 18       	ld.w	r8,r10[0x4]
8000df7e:	a3 4b       	asr	r11,0x2
8000df80:	30 1c       	mov	r12,1
8000df82:	f8 0b 09 4b 	lsl	r11,r12,r11
8000df86:	f1 eb 10 0b 	or	r11,r8,r11
8000df8a:	12 98       	mov	r8,r9
8000df8c:	95 1b       	st.w	r10[0x4],r11
8000df8e:	c0 a8       	rjmp	8000dfa2 <_free_r+0x17a>
8000df90:	72 29       	ld.w	r9,r9[0x8]
8000df92:	18 39       	cp.w	r9,r12
8000df94:	c0 60       	breq	8000dfa0 <_free_r+0x178>
8000df96:	72 1a       	ld.w	r10,r9[0x4]
8000df98:	e0 1a ff fc 	andl	r10,0xfffc
8000df9c:	14 38       	cp.w	r8,r10
8000df9e:	cf 93       	brcs	8000df90 <_free_r+0x168>
8000dfa0:	72 38       	ld.w	r8,r9[0xc]
8000dfa2:	8d 38       	st.w	r6[0xc],r8
8000dfa4:	8d 29       	st.w	r6[0x8],r9
8000dfa6:	93 36       	st.w	r9[0xc],r6
8000dfa8:	91 26       	st.w	r8[0x8],r6
8000dfaa:	0e 9c       	mov	r12,r7
8000dfac:	fe b0 d5 82 	rcall	80008ab0 <__malloc_unlock>
8000dfb0:	d8 22       	popm	r4-r7,pc
8000dfb2:	d7 03       	nop

8000dfb4 <__sfvwrite_r>:
8000dfb4:	d4 31       	pushm	r0-r7,lr
8000dfb6:	20 3d       	sub	sp,12
8000dfb8:	14 94       	mov	r4,r10
8000dfba:	18 95       	mov	r5,r12
8000dfbc:	16 97       	mov	r7,r11
8000dfbe:	74 28       	ld.w	r8,r10[0x8]
8000dfc0:	58 08       	cp.w	r8,0
8000dfc2:	e0 80 01 40 	breq	8000e242 <__sfvwrite_r+0x28e>
8000dfc6:	96 68       	ld.sh	r8,r11[0xc]
8000dfc8:	ed b8 00 03 	bld	r8,0x3
8000dfcc:	c0 41       	brne	8000dfd4 <__sfvwrite_r+0x20>
8000dfce:	76 48       	ld.w	r8,r11[0x10]
8000dfd0:	58 08       	cp.w	r8,0
8000dfd2:	c0 c1       	brne	8000dfea <__sfvwrite_r+0x36>
8000dfd4:	0e 9b       	mov	r11,r7
8000dfd6:	0a 9c       	mov	r12,r5
8000dfd8:	fe b0 f6 bc 	rcall	8000cd50 <__swsetup_r>
8000dfdc:	c0 70       	breq	8000dfea <__sfvwrite_r+0x36>
8000dfde:	8e 68       	ld.sh	r8,r7[0xc]
8000dfe0:	a7 a8       	sbr	r8,0x6
8000dfe2:	ae 68       	st.h	r7[0xc],r8
8000dfe4:	30 98       	mov	r8,9
8000dfe6:	8b 38       	st.w	r5[0xc],r8
8000dfe8:	c2 b9       	rjmp	8000e23e <__sfvwrite_r+0x28a>
8000dfea:	8e 63       	ld.sh	r3,r7[0xc]
8000dfec:	68 00       	ld.w	r0,r4[0x0]
8000dfee:	06 96       	mov	r6,r3
8000dff0:	e2 16 00 02 	andl	r6,0x2,COH
8000dff4:	c2 10       	breq	8000e036 <__sfvwrite_r+0x82>
8000dff6:	30 03       	mov	r3,0
8000dff8:	e0 62 04 00 	mov	r2,1024
8000dffc:	06 96       	mov	r6,r3
8000dffe:	c0 48       	rjmp	8000e006 <__sfvwrite_r+0x52>
8000e000:	60 03       	ld.w	r3,r0[0x0]
8000e002:	60 16       	ld.w	r6,r0[0x4]
8000e004:	2f 80       	sub	r0,-8
8000e006:	58 06       	cp.w	r6,0
8000e008:	cf c0       	breq	8000e000 <__sfvwrite_r+0x4c>
8000e00a:	e0 46 04 00 	cp.w	r6,1024
8000e00e:	ec 09 17 80 	movls	r9,r6
8000e012:	e4 09 17 b0 	movhi	r9,r2
8000e016:	06 9a       	mov	r10,r3
8000e018:	6e a8       	ld.w	r8,r7[0x28]
8000e01a:	6e 8b       	ld.w	r11,r7[0x20]
8000e01c:	0a 9c       	mov	r12,r5
8000e01e:	5d 18       	icall	r8
8000e020:	18 16       	sub	r6,r12
8000e022:	58 0c       	cp.w	r12,0
8000e024:	e0 8a 01 0a 	brle	8000e238 <__sfvwrite_r+0x284>
8000e028:	68 28       	ld.w	r8,r4[0x8]
8000e02a:	18 18       	sub	r8,r12
8000e02c:	89 28       	st.w	r4[0x8],r8
8000e02e:	e0 80 01 0a 	breq	8000e242 <__sfvwrite_r+0x28e>
8000e032:	18 03       	add	r3,r12
8000e034:	ce 9b       	rjmp	8000e006 <__sfvwrite_r+0x52>
8000e036:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
8000e03a:	c0 70       	breq	8000e048 <__sfvwrite_r+0x94>
8000e03c:	50 06       	stdsp	sp[0x0],r6
8000e03e:	0c 93       	mov	r3,r6
8000e040:	0c 91       	mov	r1,r6
8000e042:	50 15       	stdsp	sp[0x4],r5
8000e044:	08 92       	mov	r2,r4
8000e046:	c9 c8       	rjmp	8000e17e <__sfvwrite_r+0x1ca>
8000e048:	06 96       	mov	r6,r3
8000e04a:	08 91       	mov	r1,r4
8000e04c:	c0 48       	rjmp	8000e054 <__sfvwrite_r+0xa0>
8000e04e:	60 03       	ld.w	r3,r0[0x0]
8000e050:	60 16       	ld.w	r6,r0[0x4]
8000e052:	2f 80       	sub	r0,-8
8000e054:	58 06       	cp.w	r6,0
8000e056:	cf c0       	breq	8000e04e <__sfvwrite_r+0x9a>
8000e058:	8e 68       	ld.sh	r8,r7[0xc]
8000e05a:	6e 24       	ld.w	r4,r7[0x8]
8000e05c:	10 99       	mov	r9,r8
8000e05e:	e2 19 02 00 	andl	r9,0x200,COH
8000e062:	c5 50       	breq	8000e10c <__sfvwrite_r+0x158>
8000e064:	08 36       	cp.w	r6,r4
8000e066:	c4 43       	brcs	8000e0ee <__sfvwrite_r+0x13a>
8000e068:	10 99       	mov	r9,r8
8000e06a:	e2 19 04 80 	andl	r9,0x480,COH
8000e06e:	c4 00       	breq	8000e0ee <__sfvwrite_r+0x13a>
8000e070:	6e 4b       	ld.w	r11,r7[0x10]
8000e072:	6e 09       	ld.w	r9,r7[0x0]
8000e074:	16 19       	sub	r9,r11
8000e076:	50 09       	stdsp	sp[0x0],r9
8000e078:	6e 59       	ld.w	r9,r7[0x14]
8000e07a:	10 9c       	mov	r12,r8
8000e07c:	f2 09 00 1a 	add	r10,r9,r9<<0x1
8000e080:	30 28       	mov	r8,2
8000e082:	f4 08 0c 08 	divs	r8,r10,r8
8000e086:	fa e9 00 04 	st.d	sp[4],r8
8000e08a:	10 94       	mov	r4,r8
8000e08c:	40 09       	lddsp	r9,sp[0x0]
8000e08e:	e2 1c 04 00 	andl	r12,0x400,COH
8000e092:	2f f9       	sub	r9,-1
8000e094:	0c 09       	add	r9,r6
8000e096:	12 38       	cp.w	r8,r9
8000e098:	f2 04 17 30 	movlo	r4,r9
8000e09c:	58 0c       	cp.w	r12,0
8000e09e:	c1 10       	breq	8000e0c0 <__sfvwrite_r+0x10c>
8000e0a0:	08 9b       	mov	r11,r4
8000e0a2:	0a 9c       	mov	r12,r5
8000e0a4:	fe b0 df b4 	rcall	8000a00c <_malloc_r>
8000e0a8:	18 92       	mov	r2,r12
8000e0aa:	c1 40       	breq	8000e0d2 <__sfvwrite_r+0x11e>
8000e0ac:	40 0a       	lddsp	r10,sp[0x0]
8000e0ae:	6e 4b       	ld.w	r11,r7[0x10]
8000e0b0:	fe b0 e1 dd 	rcall	8000a46a <memcpy>
8000e0b4:	8e 68       	ld.sh	r8,r7[0xc]
8000e0b6:	e0 18 fb 7f 	andl	r8,0xfb7f
8000e0ba:	a7 b8       	sbr	r8,0x7
8000e0bc:	ae 68       	st.h	r7[0xc],r8
8000e0be:	c0 d8       	rjmp	8000e0d8 <__sfvwrite_r+0x124>
8000e0c0:	08 9a       	mov	r10,r4
8000e0c2:	0a 9c       	mov	r12,r5
8000e0c4:	fe b0 e2 7e 	rcall	8000a5c0 <_realloc_r>
8000e0c8:	18 92       	mov	r2,r12
8000e0ca:	c0 71       	brne	8000e0d8 <__sfvwrite_r+0x124>
8000e0cc:	6e 4b       	ld.w	r11,r7[0x10]
8000e0ce:	0a 9c       	mov	r12,r5
8000e0d0:	ca ce       	rcall	8000de28 <_free_r>
8000e0d2:	30 c8       	mov	r8,12
8000e0d4:	8b 38       	st.w	r5[0xc],r8
8000e0d6:	cb 18       	rjmp	8000e238 <__sfvwrite_r+0x284>
8000e0d8:	40 0a       	lddsp	r10,sp[0x0]
8000e0da:	40 09       	lddsp	r9,sp[0x0]
8000e0dc:	e8 0a 01 0a 	sub	r10,r4,r10
8000e0e0:	e4 09 00 08 	add	r8,r2,r9
8000e0e4:	8f 54       	st.w	r7[0x14],r4
8000e0e6:	8f 2a       	st.w	r7[0x8],r10
8000e0e8:	8f 08       	st.w	r7[0x0],r8
8000e0ea:	8f 42       	st.w	r7[0x10],r2
8000e0ec:	0c 94       	mov	r4,r6
8000e0ee:	08 36       	cp.w	r6,r4
8000e0f0:	ec 04 17 30 	movlo	r4,r6
8000e0f4:	06 9b       	mov	r11,r3
8000e0f6:	08 9a       	mov	r10,r4
8000e0f8:	6e 0c       	ld.w	r12,r7[0x0]
8000e0fa:	c3 ad       	rcall	8000e36e <memmove>
8000e0fc:	6e 08       	ld.w	r8,r7[0x0]
8000e0fe:	08 08       	add	r8,r4
8000e100:	8f 08       	st.w	r7[0x0],r8
8000e102:	6e 28       	ld.w	r8,r7[0x8]
8000e104:	08 18       	sub	r8,r4
8000e106:	0c 94       	mov	r4,r6
8000e108:	8f 28       	st.w	r7[0x8],r8
8000e10a:	c2 e8       	rjmp	8000e166 <__sfvwrite_r+0x1b2>
8000e10c:	08 36       	cp.w	r6,r4
8000e10e:	5f ba       	srhi	r10
8000e110:	6e 0c       	ld.w	r12,r7[0x0]
8000e112:	6e 48       	ld.w	r8,r7[0x10]
8000e114:	10 3c       	cp.w	r12,r8
8000e116:	5f b8       	srhi	r8
8000e118:	f5 e8 00 08 	and	r8,r10,r8
8000e11c:	f2 08 18 00 	cp.b	r8,r9
8000e120:	c0 d0       	breq	8000e13a <__sfvwrite_r+0x186>
8000e122:	06 9b       	mov	r11,r3
8000e124:	08 9a       	mov	r10,r4
8000e126:	c2 4d       	rcall	8000e36e <memmove>
8000e128:	6e 08       	ld.w	r8,r7[0x0]
8000e12a:	08 08       	add	r8,r4
8000e12c:	0e 9b       	mov	r11,r7
8000e12e:	8f 08       	st.w	r7[0x0],r8
8000e130:	0a 9c       	mov	r12,r5
8000e132:	fe b0 fd 05 	rcall	8000db3c <_fflush_r>
8000e136:	c1 80       	breq	8000e166 <__sfvwrite_r+0x1b2>
8000e138:	c8 08       	rjmp	8000e238 <__sfvwrite_r+0x284>
8000e13a:	6e 59       	ld.w	r9,r7[0x14]
8000e13c:	12 36       	cp.w	r6,r9
8000e13e:	c0 a3       	brcs	8000e152 <__sfvwrite_r+0x19e>
8000e140:	6e a8       	ld.w	r8,r7[0x28]
8000e142:	06 9a       	mov	r10,r3
8000e144:	6e 8b       	ld.w	r11,r7[0x20]
8000e146:	0a 9c       	mov	r12,r5
8000e148:	5d 18       	icall	r8
8000e14a:	18 94       	mov	r4,r12
8000e14c:	e0 89 00 0d 	brgt	8000e166 <__sfvwrite_r+0x1b2>
8000e150:	c7 48       	rjmp	8000e238 <__sfvwrite_r+0x284>
8000e152:	0c 9a       	mov	r10,r6
8000e154:	06 9b       	mov	r11,r3
8000e156:	c0 cd       	rcall	8000e36e <memmove>
8000e158:	6e 08       	ld.w	r8,r7[0x0]
8000e15a:	0c 08       	add	r8,r6
8000e15c:	0c 94       	mov	r4,r6
8000e15e:	8f 08       	st.w	r7[0x0],r8
8000e160:	6e 28       	ld.w	r8,r7[0x8]
8000e162:	0c 18       	sub	r8,r6
8000e164:	8f 28       	st.w	r7[0x8],r8
8000e166:	62 28       	ld.w	r8,r1[0x8]
8000e168:	08 18       	sub	r8,r4
8000e16a:	83 28       	st.w	r1[0x8],r8
8000e16c:	c6 b0       	breq	8000e242 <__sfvwrite_r+0x28e>
8000e16e:	08 16       	sub	r6,r4
8000e170:	08 03       	add	r3,r4
8000e172:	c7 1b       	rjmp	8000e054 <__sfvwrite_r+0xa0>
8000e174:	60 03       	ld.w	r3,r0[0x0]
8000e176:	60 11       	ld.w	r1,r0[0x4]
8000e178:	30 08       	mov	r8,0
8000e17a:	2f 80       	sub	r0,-8
8000e17c:	50 08       	stdsp	sp[0x0],r8
8000e17e:	58 01       	cp.w	r1,0
8000e180:	cf a0       	breq	8000e174 <__sfvwrite_r+0x1c0>
8000e182:	40 0a       	lddsp	r10,sp[0x0]
8000e184:	58 0a       	cp.w	r10,0
8000e186:	c1 41       	brne	8000e1ae <__sfvwrite_r+0x1fa>
8000e188:	e2 c6 ff ff 	sub	r6,r1,-1
8000e18c:	02 9a       	mov	r10,r1
8000e18e:	30 ab       	mov	r11,10
8000e190:	06 9c       	mov	r12,r3
8000e192:	ce 3c       	rcall	8000e358 <memchr>
8000e194:	f8 c8 ff ff 	sub	r8,r12,-1
8000e198:	58 0c       	cp.w	r12,0
8000e19a:	f1 d3 e1 16 	subne	r6,r8,r3
8000e19e:	f9 b9 01 01 	movne	r9,1
8000e1a2:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000e1a6:	f9 b8 00 01 	moveq	r8,1
8000e1aa:	fb f8 0a 00 	st.weq	sp[0x0],r8
8000e1ae:	02 36       	cp.w	r6,r1
8000e1b0:	ec 04 17 80 	movls	r4,r6
8000e1b4:	e2 04 17 b0 	movhi	r4,r1
8000e1b8:	6e 59       	ld.w	r9,r7[0x14]
8000e1ba:	6e 25       	ld.w	r5,r7[0x8]
8000e1bc:	f2 05 00 05 	add	r5,r9,r5
8000e1c0:	0a 34       	cp.w	r4,r5
8000e1c2:	5f 9a       	srgt	r10
8000e1c4:	6e 0c       	ld.w	r12,r7[0x0]
8000e1c6:	6e 48       	ld.w	r8,r7[0x10]
8000e1c8:	10 3c       	cp.w	r12,r8
8000e1ca:	5f b8       	srhi	r8
8000e1cc:	f5 e8 00 08 	and	r8,r10,r8
8000e1d0:	30 0a       	mov	r10,0
8000e1d2:	f4 08 18 00 	cp.b	r8,r10
8000e1d6:	c0 d0       	breq	8000e1f0 <__sfvwrite_r+0x23c>
8000e1d8:	06 9b       	mov	r11,r3
8000e1da:	0a 9a       	mov	r10,r5
8000e1dc:	cc 9c       	rcall	8000e36e <memmove>
8000e1de:	6e 08       	ld.w	r8,r7[0x0]
8000e1e0:	0a 08       	add	r8,r5
8000e1e2:	0e 9b       	mov	r11,r7
8000e1e4:	8f 08       	st.w	r7[0x0],r8
8000e1e6:	40 1c       	lddsp	r12,sp[0x4]
8000e1e8:	fe b0 fc aa 	rcall	8000db3c <_fflush_r>
8000e1ec:	c1 70       	breq	8000e21a <__sfvwrite_r+0x266>
8000e1ee:	c2 58       	rjmp	8000e238 <__sfvwrite_r+0x284>
8000e1f0:	12 34       	cp.w	r4,r9
8000e1f2:	c0 a5       	brlt	8000e206 <__sfvwrite_r+0x252>
8000e1f4:	6e a8       	ld.w	r8,r7[0x28]
8000e1f6:	06 9a       	mov	r10,r3
8000e1f8:	6e 8b       	ld.w	r11,r7[0x20]
8000e1fa:	40 1c       	lddsp	r12,sp[0x4]
8000e1fc:	5d 18       	icall	r8
8000e1fe:	18 95       	mov	r5,r12
8000e200:	e0 89 00 0d 	brgt	8000e21a <__sfvwrite_r+0x266>
8000e204:	c1 a8       	rjmp	8000e238 <__sfvwrite_r+0x284>
8000e206:	08 9a       	mov	r10,r4
8000e208:	06 9b       	mov	r11,r3
8000e20a:	cb 2c       	rcall	8000e36e <memmove>
8000e20c:	6e 08       	ld.w	r8,r7[0x0]
8000e20e:	08 08       	add	r8,r4
8000e210:	08 95       	mov	r5,r4
8000e212:	8f 08       	st.w	r7[0x0],r8
8000e214:	6e 28       	ld.w	r8,r7[0x8]
8000e216:	08 18       	sub	r8,r4
8000e218:	8f 28       	st.w	r7[0x8],r8
8000e21a:	0a 16       	sub	r6,r5
8000e21c:	c0 71       	brne	8000e22a <__sfvwrite_r+0x276>
8000e21e:	0e 9b       	mov	r11,r7
8000e220:	40 1c       	lddsp	r12,sp[0x4]
8000e222:	fe b0 fc 8d 	rcall	8000db3c <_fflush_r>
8000e226:	c0 91       	brne	8000e238 <__sfvwrite_r+0x284>
8000e228:	50 06       	stdsp	sp[0x0],r6
8000e22a:	64 28       	ld.w	r8,r2[0x8]
8000e22c:	0a 18       	sub	r8,r5
8000e22e:	85 28       	st.w	r2[0x8],r8
8000e230:	c0 90       	breq	8000e242 <__sfvwrite_r+0x28e>
8000e232:	0a 11       	sub	r1,r5
8000e234:	0a 03       	add	r3,r5
8000e236:	ca 4b       	rjmp	8000e17e <__sfvwrite_r+0x1ca>
8000e238:	8e 68       	ld.sh	r8,r7[0xc]
8000e23a:	a7 a8       	sbr	r8,0x6
8000e23c:	ae 68       	st.h	r7[0xc],r8
8000e23e:	3f fc       	mov	r12,-1
8000e240:	c0 28       	rjmp	8000e244 <__sfvwrite_r+0x290>
8000e242:	30 0c       	mov	r12,0
8000e244:	2f dd       	sub	sp,-12
8000e246:	d8 32       	popm	r0-r7,pc

8000e248 <_fwalk>:
8000e248:	d4 31       	pushm	r0-r7,lr
8000e24a:	30 05       	mov	r5,0
8000e24c:	16 91       	mov	r1,r11
8000e24e:	f8 c7 ff 28 	sub	r7,r12,-216
8000e252:	0a 92       	mov	r2,r5
8000e254:	fe b0 fc fc 	rcall	8000dc4c <__sfp_lock_acquire>
8000e258:	3f f3       	mov	r3,-1
8000e25a:	c1 68       	rjmp	8000e286 <_fwalk+0x3e>
8000e25c:	6e 26       	ld.w	r6,r7[0x8]
8000e25e:	6e 14       	ld.w	r4,r7[0x4]
8000e260:	2f 46       	sub	r6,-12
8000e262:	c0 c8       	rjmp	8000e27a <_fwalk+0x32>
8000e264:	8c 08       	ld.sh	r8,r6[0x0]
8000e266:	e4 08 19 00 	cp.h	r8,r2
8000e26a:	c0 70       	breq	8000e278 <_fwalk+0x30>
8000e26c:	8c 18       	ld.sh	r8,r6[0x2]
8000e26e:	e6 08 19 00 	cp.h	r8,r3
8000e272:	c0 30       	breq	8000e278 <_fwalk+0x30>
8000e274:	5d 11       	icall	r1
8000e276:	18 45       	or	r5,r12
8000e278:	2a 46       	sub	r6,-92
8000e27a:	20 14       	sub	r4,1
8000e27c:	ec cc 00 0c 	sub	r12,r6,12
8000e280:	58 04       	cp.w	r4,0
8000e282:	cf 14       	brge	8000e264 <_fwalk+0x1c>
8000e284:	6e 07       	ld.w	r7,r7[0x0]
8000e286:	58 07       	cp.w	r7,0
8000e288:	ce a1       	brne	8000e25c <_fwalk+0x14>
8000e28a:	fe b0 fc e2 	rcall	8000dc4e <__sfp_lock_release>
8000e28e:	0a 9c       	mov	r12,r5
8000e290:	d8 32       	popm	r0-r7,pc
8000e292:	d7 03       	nop

8000e294 <_localeconv_r>:
8000e294:	48 1c       	lddpc	r12,8000e298 <_localeconv_r+0x4>
8000e296:	5e fc       	retal	r12
8000e298:	80 01       	ld.sh	r1,r0[0x0]
8000e29a:	93 38       	st.w	r9[0xc],r8

8000e29c <__smakebuf_r>:
8000e29c:	d4 21       	pushm	r4-r7,lr
8000e29e:	20 fd       	sub	sp,60
8000e2a0:	96 68       	ld.sh	r8,r11[0xc]
8000e2a2:	16 97       	mov	r7,r11
8000e2a4:	18 96       	mov	r6,r12
8000e2a6:	e2 18 00 02 	andl	r8,0x2,COH
8000e2aa:	c3 d1       	brne	8000e324 <__smakebuf_r+0x88>
8000e2ac:	96 7b       	ld.sh	r11,r11[0xe]
8000e2ae:	f0 0b 19 00 	cp.h	r11,r8
8000e2b2:	c0 55       	brlt	8000e2bc <__smakebuf_r+0x20>
8000e2b4:	1a 9a       	mov	r10,sp
8000e2b6:	e0 a0 04 79 	rcall	8000eba8 <_fstat_r>
8000e2ba:	c0 f4       	brge	8000e2d8 <__smakebuf_r+0x3c>
8000e2bc:	8e 65       	ld.sh	r5,r7[0xc]
8000e2be:	0a 98       	mov	r8,r5
8000e2c0:	ab b8       	sbr	r8,0xb
8000e2c2:	e2 15 00 80 	andl	r5,0x80,COH
8000e2c6:	ae 68       	st.h	r7[0xc],r8
8000e2c8:	30 04       	mov	r4,0
8000e2ca:	e0 68 04 00 	mov	r8,1024
8000e2ce:	f9 b5 01 40 	movne	r5,64
8000e2d2:	f0 05 17 00 	moveq	r5,r8
8000e2d6:	c1 c8       	rjmp	8000e30e <__smakebuf_r+0x72>
8000e2d8:	40 18       	lddsp	r8,sp[0x4]
8000e2da:	e2 18 f0 00 	andl	r8,0xf000,COH
8000e2de:	e0 48 20 00 	cp.w	r8,8192
8000e2e2:	5f 04       	sreq	r4
8000e2e4:	e0 48 80 00 	cp.w	r8,32768
8000e2e8:	c0 e1       	brne	8000e304 <__smakebuf_r+0x68>
8000e2ea:	6e b9       	ld.w	r9,r7[0x2c]
8000e2ec:	fe c8 f9 18 	sub	r8,pc,-1768
8000e2f0:	10 39       	cp.w	r9,r8
8000e2f2:	c0 91       	brne	8000e304 <__smakebuf_r+0x68>
8000e2f4:	8e 68       	ld.sh	r8,r7[0xc]
8000e2f6:	e0 65 04 00 	mov	r5,1024
8000e2fa:	ab a8       	sbr	r8,0xa
8000e2fc:	ef 45 00 50 	st.w	r7[80],r5
8000e300:	ae 68       	st.h	r7[0xc],r8
8000e302:	c0 68       	rjmp	8000e30e <__smakebuf_r+0x72>
8000e304:	8e 68       	ld.sh	r8,r7[0xc]
8000e306:	e0 65 04 00 	mov	r5,1024
8000e30a:	ab b8       	sbr	r8,0xb
8000e30c:	ae 68       	st.h	r7[0xc],r8
8000e30e:	0a 9b       	mov	r11,r5
8000e310:	0c 9c       	mov	r12,r6
8000e312:	fe b0 de 7d 	rcall	8000a00c <_malloc_r>
8000e316:	8e 68       	ld.sh	r8,r7[0xc]
8000e318:	c0 d1       	brne	8000e332 <__smakebuf_r+0x96>
8000e31a:	ed b8 00 09 	bld	r8,0x9
8000e31e:	c1 b0       	breq	8000e354 <__smakebuf_r+0xb8>
8000e320:	a1 b8       	sbr	r8,0x1
8000e322:	ae 68       	st.h	r7[0xc],r8
8000e324:	ee c8 ff b9 	sub	r8,r7,-71
8000e328:	8f 48       	st.w	r7[0x10],r8
8000e32a:	8f 08       	st.w	r7[0x0],r8
8000e32c:	30 18       	mov	r8,1
8000e32e:	8f 58       	st.w	r7[0x14],r8
8000e330:	c1 28       	rjmp	8000e354 <__smakebuf_r+0xb8>
8000e332:	a7 b8       	sbr	r8,0x7
8000e334:	8f 4c       	st.w	r7[0x10],r12
8000e336:	ae 68       	st.h	r7[0xc],r8
8000e338:	8f 55       	st.w	r7[0x14],r5
8000e33a:	fe c8 06 ea 	sub	r8,pc,1770
8000e33e:	8f 0c       	st.w	r7[0x0],r12
8000e340:	8d a8       	st.w	r6[0x28],r8
8000e342:	58 04       	cp.w	r4,0
8000e344:	c0 80       	breq	8000e354 <__smakebuf_r+0xb8>
8000e346:	8e 7c       	ld.sh	r12,r7[0xe]
8000e348:	fe b0 e3 7a 	rcall	8000aa3c <isatty>
8000e34c:	c0 40       	breq	8000e354 <__smakebuf_r+0xb8>
8000e34e:	8e 68       	ld.sh	r8,r7[0xc]
8000e350:	a1 a8       	sbr	r8,0x0
8000e352:	ae 68       	st.h	r7[0xc],r8
8000e354:	2f 1d       	sub	sp,-60
8000e356:	d8 22       	popm	r4-r7,pc

8000e358 <memchr>:
8000e358:	f7 db c0 08 	bfextu	r11,r11,0x0,0x8
8000e35c:	c0 68       	rjmp	8000e368 <memchr+0x10>
8000e35e:	20 1a       	sub	r10,1
8000e360:	19 88       	ld.ub	r8,r12[0x0]
8000e362:	16 38       	cp.w	r8,r11
8000e364:	5e 0c       	reteq	r12
8000e366:	2f fc       	sub	r12,-1
8000e368:	58 0a       	cp.w	r10,0
8000e36a:	cf a1       	brne	8000e35e <memchr+0x6>
8000e36c:	5e fa       	retal	r10

8000e36e <memmove>:
8000e36e:	d4 01       	pushm	lr
8000e370:	18 3b       	cp.w	r11,r12
8000e372:	c1 92       	brcc	8000e3a4 <memmove+0x36>
8000e374:	f6 0a 00 09 	add	r9,r11,r10
8000e378:	12 3c       	cp.w	r12,r9
8000e37a:	c1 52       	brcc	8000e3a4 <memmove+0x36>
8000e37c:	f8 0a 00 0b 	add	r11,r12,r10
8000e380:	30 08       	mov	r8,0
8000e382:	c0 68       	rjmp	8000e38e <memmove+0x20>
8000e384:	f2 08 07 0e 	ld.ub	lr,r9[r8]
8000e388:	20 1a       	sub	r10,1
8000e38a:	f6 08 0b 0e 	st.b	r11[r8],lr
8000e38e:	20 18       	sub	r8,1
8000e390:	58 0a       	cp.w	r10,0
8000e392:	cf 91       	brne	8000e384 <memmove+0x16>
8000e394:	d8 02       	popm	pc
8000e396:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000e39a:	20 1a       	sub	r10,1
8000e39c:	f8 08 0b 09 	st.b	r12[r8],r9
8000e3a0:	2f f8       	sub	r8,-1
8000e3a2:	c0 28       	rjmp	8000e3a6 <memmove+0x38>
8000e3a4:	30 08       	mov	r8,0
8000e3a6:	58 0a       	cp.w	r10,0
8000e3a8:	cf 71       	brne	8000e396 <memmove+0x28>
8000e3aa:	d8 02       	popm	pc

8000e3ac <__hi0bits>:
8000e3ac:	18 98       	mov	r8,r12
8000e3ae:	e0 1c 00 00 	andl	r12,0x0
8000e3b2:	f0 09 15 10 	lsl	r9,r8,0x10
8000e3b6:	58 0c       	cp.w	r12,0
8000e3b8:	f2 08 17 00 	moveq	r8,r9
8000e3bc:	f9 bc 00 10 	moveq	r12,16
8000e3c0:	f9 bc 01 00 	movne	r12,0
8000e3c4:	10 9a       	mov	r10,r8
8000e3c6:	f0 09 15 08 	lsl	r9,r8,0x8
8000e3ca:	e6 1a ff 00 	andh	r10,0xff00,COH
8000e3ce:	f7 bc 00 f8 	subeq	r12,-8
8000e3d2:	f2 08 17 00 	moveq	r8,r9
8000e3d6:	10 9a       	mov	r10,r8
8000e3d8:	f0 09 15 04 	lsl	r9,r8,0x4
8000e3dc:	e6 1a f0 00 	andh	r10,0xf000,COH
8000e3e0:	f7 bc 00 fc 	subeq	r12,-4
8000e3e4:	f2 08 17 00 	moveq	r8,r9
8000e3e8:	10 9a       	mov	r10,r8
8000e3ea:	f0 09 15 02 	lsl	r9,r8,0x2
8000e3ee:	e6 1a c0 00 	andh	r10,0xc000,COH
8000e3f2:	f7 bc 00 fe 	subeq	r12,-2
8000e3f6:	f2 08 17 00 	moveq	r8,r9
8000e3fa:	58 08       	cp.w	r8,0
8000e3fc:	5e 5c       	retlt	r12
8000e3fe:	ed b8 00 1e 	bld	r8,0x1e
8000e402:	f9 bc 01 20 	movne	r12,32
8000e406:	f7 bc 00 ff 	subeq	r12,-1
8000e40a:	5e fc       	retal	r12

8000e40c <__lo0bits>:
8000e40c:	18 99       	mov	r9,r12
8000e40e:	78 08       	ld.w	r8,r12[0x0]
8000e410:	f9 d8 c0 03 	bfextu	r12,r8,0x0,0x3
8000e414:	c1 50       	breq	8000e43e <__lo0bits+0x32>
8000e416:	ed b8 00 00 	bld	r8,0x0
8000e41a:	c0 21       	brne	8000e41e <__lo0bits+0x12>
8000e41c:	5e fd       	retal	0
8000e41e:	10 9b       	mov	r11,r8
8000e420:	f0 0a 16 01 	lsr	r10,r8,0x1
8000e424:	e2 1b 00 02 	andl	r11,0x2,COH
8000e428:	a3 88       	lsr	r8,0x2
8000e42a:	58 0b       	cp.w	r11,0
8000e42c:	f3 fa 1a 00 	st.wne	r9[0x0],r10
8000e430:	f9 bc 01 01 	movne	r12,1
8000e434:	f3 f8 0a 00 	st.weq	r9[0x0],r8
8000e438:	f9 bc 00 02 	moveq	r12,2
8000e43c:	5e fc       	retal	r12
8000e43e:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8000e442:	f0 0b 16 10 	lsr	r11,r8,0x10
8000e446:	58 0a       	cp.w	r10,0
8000e448:	f6 08 17 00 	moveq	r8,r11
8000e44c:	f9 bc 00 10 	moveq	r12,16
8000e450:	f7 d8 c0 08 	bfextu	r11,r8,0x0,0x8
8000e454:	f0 0a 16 08 	lsr	r10,r8,0x8
8000e458:	58 0b       	cp.w	r11,0
8000e45a:	f7 bc 00 f8 	subeq	r12,-8
8000e45e:	f4 08 17 00 	moveq	r8,r10
8000e462:	f7 d8 c0 04 	bfextu	r11,r8,0x0,0x4
8000e466:	f0 0a 16 04 	lsr	r10,r8,0x4
8000e46a:	58 0b       	cp.w	r11,0
8000e46c:	f7 bc 00 fc 	subeq	r12,-4
8000e470:	f4 08 17 00 	moveq	r8,r10
8000e474:	f7 d8 c0 02 	bfextu	r11,r8,0x0,0x2
8000e478:	f0 0a 16 02 	lsr	r10,r8,0x2
8000e47c:	58 0b       	cp.w	r11,0
8000e47e:	f7 bc 00 fe 	subeq	r12,-2
8000e482:	f4 08 17 00 	moveq	r8,r10
8000e486:	ed b8 00 00 	bld	r8,0x0
8000e48a:	c0 60       	breq	8000e496 <__lo0bits+0x8a>
8000e48c:	a1 98       	lsr	r8,0x1
8000e48e:	c0 31       	brne	8000e494 <__lo0bits+0x88>
8000e490:	32 0c       	mov	r12,32
8000e492:	5e fc       	retal	r12
8000e494:	2f fc       	sub	r12,-1
8000e496:	93 08       	st.w	r9[0x0],r8
8000e498:	5e fc       	retal	r12

8000e49a <__mcmp>:
8000e49a:	d4 01       	pushm	lr
8000e49c:	18 98       	mov	r8,r12
8000e49e:	76 49       	ld.w	r9,r11[0x10]
8000e4a0:	78 4c       	ld.w	r12,r12[0x10]
8000e4a2:	12 1c       	sub	r12,r9
8000e4a4:	c1 31       	brne	8000e4ca <__mcmp+0x30>
8000e4a6:	2f b9       	sub	r9,-5
8000e4a8:	a3 69       	lsl	r9,0x2
8000e4aa:	12 0b       	add	r11,r9
8000e4ac:	f0 09 00 09 	add	r9,r8,r9
8000e4b0:	2e c8       	sub	r8,-20
8000e4b2:	13 4e       	ld.w	lr,--r9
8000e4b4:	17 4a       	ld.w	r10,--r11
8000e4b6:	14 3e       	cp.w	lr,r10
8000e4b8:	c0 60       	breq	8000e4c4 <__mcmp+0x2a>
8000e4ba:	f9 bc 03 ff 	movlo	r12,-1
8000e4be:	f9 bc 02 01 	movhs	r12,1
8000e4c2:	d8 02       	popm	pc
8000e4c4:	10 39       	cp.w	r9,r8
8000e4c6:	fe 9b ff f6 	brhi	8000e4b2 <__mcmp+0x18>
8000e4ca:	d8 02       	popm	pc

8000e4cc <_Bfree>:
8000e4cc:	d4 21       	pushm	r4-r7,lr
8000e4ce:	18 97       	mov	r7,r12
8000e4d0:	16 95       	mov	r5,r11
8000e4d2:	78 96       	ld.w	r6,r12[0x24]
8000e4d4:	58 06       	cp.w	r6,0
8000e4d6:	c0 91       	brne	8000e4e8 <_Bfree+0x1c>
8000e4d8:	31 0c       	mov	r12,16
8000e4da:	fe b0 dd 91 	rcall	80009ffc <malloc>
8000e4de:	99 36       	st.w	r12[0xc],r6
8000e4e0:	8f 9c       	st.w	r7[0x24],r12
8000e4e2:	99 16       	st.w	r12[0x4],r6
8000e4e4:	99 26       	st.w	r12[0x8],r6
8000e4e6:	99 06       	st.w	r12[0x0],r6
8000e4e8:	58 05       	cp.w	r5,0
8000e4ea:	c0 90       	breq	8000e4fc <_Bfree+0x30>
8000e4ec:	6a 19       	ld.w	r9,r5[0x4]
8000e4ee:	6e 98       	ld.w	r8,r7[0x24]
8000e4f0:	70 38       	ld.w	r8,r8[0xc]
8000e4f2:	f0 09 03 2a 	ld.w	r10,r8[r9<<0x2]
8000e4f6:	8b 0a       	st.w	r5[0x0],r10
8000e4f8:	f0 09 09 25 	st.w	r8[r9<<0x2],r5
8000e4fc:	d8 22       	popm	r4-r7,pc
8000e4fe:	d7 03       	nop

8000e500 <_Balloc>:
8000e500:	d4 21       	pushm	r4-r7,lr
8000e502:	18 97       	mov	r7,r12
8000e504:	16 96       	mov	r6,r11
8000e506:	78 95       	ld.w	r5,r12[0x24]
8000e508:	58 05       	cp.w	r5,0
8000e50a:	c0 91       	brne	8000e51c <_Balloc+0x1c>
8000e50c:	31 0c       	mov	r12,16
8000e50e:	fe b0 dd 77 	rcall	80009ffc <malloc>
8000e512:	99 35       	st.w	r12[0xc],r5
8000e514:	8f 9c       	st.w	r7[0x24],r12
8000e516:	99 15       	st.w	r12[0x4],r5
8000e518:	99 25       	st.w	r12[0x8],r5
8000e51a:	99 05       	st.w	r12[0x0],r5
8000e51c:	6e 95       	ld.w	r5,r7[0x24]
8000e51e:	6a 38       	ld.w	r8,r5[0xc]
8000e520:	58 08       	cp.w	r8,0
8000e522:	c0 b1       	brne	8000e538 <_Balloc+0x38>
8000e524:	31 0a       	mov	r10,16
8000e526:	30 4b       	mov	r11,4
8000e528:	0e 9c       	mov	r12,r7
8000e52a:	e0 a0 02 9d 	rcall	8000ea64 <_calloc_r>
8000e52e:	8b 3c       	st.w	r5[0xc],r12
8000e530:	6e 98       	ld.w	r8,r7[0x24]
8000e532:	70 3c       	ld.w	r12,r8[0xc]
8000e534:	58 0c       	cp.w	r12,0
8000e536:	c1 b0       	breq	8000e56c <_Balloc+0x6c>
8000e538:	6e 98       	ld.w	r8,r7[0x24]
8000e53a:	70 38       	ld.w	r8,r8[0xc]
8000e53c:	f0 06 00 28 	add	r8,r8,r6<<0x2
8000e540:	70 0c       	ld.w	r12,r8[0x0]
8000e542:	58 0c       	cp.w	r12,0
8000e544:	c0 40       	breq	8000e54c <_Balloc+0x4c>
8000e546:	78 09       	ld.w	r9,r12[0x0]
8000e548:	91 09       	st.w	r8[0x0],r9
8000e54a:	c0 e8       	rjmp	8000e566 <_Balloc+0x66>
8000e54c:	0e 9c       	mov	r12,r7
8000e54e:	30 17       	mov	r7,1
8000e550:	0e 9b       	mov	r11,r7
8000e552:	ee 06 09 47 	lsl	r7,r7,r6
8000e556:	ee ca ff fb 	sub	r10,r7,-5
8000e55a:	a3 6a       	lsl	r10,0x2
8000e55c:	e0 a0 02 84 	rcall	8000ea64 <_calloc_r>
8000e560:	c0 60       	breq	8000e56c <_Balloc+0x6c>
8000e562:	99 16       	st.w	r12[0x4],r6
8000e564:	99 27       	st.w	r12[0x8],r7
8000e566:	30 08       	mov	r8,0
8000e568:	99 38       	st.w	r12[0xc],r8
8000e56a:	99 48       	st.w	r12[0x10],r8
8000e56c:	d8 22       	popm	r4-r7,pc
8000e56e:	d7 03       	nop

8000e570 <__d2b>:
8000e570:	d4 31       	pushm	r0-r7,lr
8000e572:	20 2d       	sub	sp,8
8000e574:	16 93       	mov	r3,r11
8000e576:	12 96       	mov	r6,r9
8000e578:	10 95       	mov	r5,r8
8000e57a:	14 92       	mov	r2,r10
8000e57c:	30 1b       	mov	r11,1
8000e57e:	cc 1f       	rcall	8000e500 <_Balloc>
8000e580:	f3 d3 c0 14 	bfextu	r9,r3,0x0,0x14
8000e584:	50 09       	stdsp	sp[0x0],r9
8000e586:	f1 d3 c0 1f 	bfextu	r8,r3,0x0,0x1f
8000e58a:	b5 a9       	sbr	r9,0x14
8000e58c:	f0 01 16 14 	lsr	r1,r8,0x14
8000e590:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000e594:	18 94       	mov	r4,r12
8000e596:	58 02       	cp.w	r2,0
8000e598:	c1 d0       	breq	8000e5d2 <__d2b+0x62>
8000e59a:	fa cc ff f8 	sub	r12,sp,-8
8000e59e:	18 d2       	st.w	--r12,r2
8000e5a0:	c3 6f       	rcall	8000e40c <__lo0bits>
8000e5a2:	40 18       	lddsp	r8,sp[0x4]
8000e5a4:	c0 d0       	breq	8000e5be <__d2b+0x4e>
8000e5a6:	40 09       	lddsp	r9,sp[0x0]
8000e5a8:	f8 0a 11 20 	rsub	r10,r12,32
8000e5ac:	f2 0a 09 4a 	lsl	r10,r9,r10
8000e5b0:	f5 e8 10 08 	or	r8,r10,r8
8000e5b4:	89 58       	st.w	r4[0x14],r8
8000e5b6:	f2 0c 0a 49 	lsr	r9,r9,r12
8000e5ba:	50 09       	stdsp	sp[0x0],r9
8000e5bc:	c0 28       	rjmp	8000e5c0 <__d2b+0x50>
8000e5be:	89 58       	st.w	r4[0x14],r8
8000e5c0:	40 08       	lddsp	r8,sp[0x0]
8000e5c2:	58 08       	cp.w	r8,0
8000e5c4:	f9 b3 01 02 	movne	r3,2
8000e5c8:	f9 b3 00 01 	moveq	r3,1
8000e5cc:	89 68       	st.w	r4[0x18],r8
8000e5ce:	89 43       	st.w	r4[0x10],r3
8000e5d0:	c0 88       	rjmp	8000e5e0 <__d2b+0x70>
8000e5d2:	1a 9c       	mov	r12,sp
8000e5d4:	c1 cf       	rcall	8000e40c <__lo0bits>
8000e5d6:	30 13       	mov	r3,1
8000e5d8:	40 08       	lddsp	r8,sp[0x0]
8000e5da:	2e 0c       	sub	r12,-32
8000e5dc:	89 43       	st.w	r4[0x10],r3
8000e5de:	89 58       	st.w	r4[0x14],r8
8000e5e0:	58 01       	cp.w	r1,0
8000e5e2:	c0 90       	breq	8000e5f4 <__d2b+0x84>
8000e5e4:	e2 c1 04 33 	sub	r1,r1,1075
8000e5e8:	18 01       	add	r1,r12
8000e5ea:	8d 01       	st.w	r6[0x0],r1
8000e5ec:	f8 0c 11 35 	rsub	r12,r12,53
8000e5f0:	8b 0c       	st.w	r5[0x0],r12
8000e5f2:	c0 c8       	rjmp	8000e60a <__d2b+0x9a>
8000e5f4:	e6 c8 ff fc 	sub	r8,r3,-4
8000e5f8:	f8 cc 04 32 	sub	r12,r12,1074
8000e5fc:	a5 73       	lsl	r3,0x5
8000e5fe:	8d 0c       	st.w	r6[0x0],r12
8000e600:	e8 08 03 2c 	ld.w	r12,r4[r8<<0x2]
8000e604:	cd 4e       	rcall	8000e3ac <__hi0bits>
8000e606:	18 13       	sub	r3,r12
8000e608:	8b 03       	st.w	r5[0x0],r3
8000e60a:	08 9c       	mov	r12,r4
8000e60c:	2f ed       	sub	sp,-8
8000e60e:	d8 32       	popm	r0-r7,pc

8000e610 <__mdiff>:
8000e610:	d4 31       	pushm	r0-r7,lr
8000e612:	74 48       	ld.w	r8,r10[0x10]
8000e614:	76 45       	ld.w	r5,r11[0x10]
8000e616:	16 97       	mov	r7,r11
8000e618:	14 96       	mov	r6,r10
8000e61a:	10 15       	sub	r5,r8
8000e61c:	c1 31       	brne	8000e642 <__mdiff+0x32>
8000e61e:	2f b8       	sub	r8,-5
8000e620:	ee ce ff ec 	sub	lr,r7,-20
8000e624:	a3 68       	lsl	r8,0x2
8000e626:	f4 08 00 0b 	add	r11,r10,r8
8000e62a:	ee 08 00 08 	add	r8,r7,r8
8000e62e:	11 4a       	ld.w	r10,--r8
8000e630:	17 49       	ld.w	r9,--r11
8000e632:	12 3a       	cp.w	r10,r9
8000e634:	c0 30       	breq	8000e63a <__mdiff+0x2a>
8000e636:	c0 e2       	brcc	8000e652 <__mdiff+0x42>
8000e638:	c0 78       	rjmp	8000e646 <__mdiff+0x36>
8000e63a:	1c 38       	cp.w	r8,lr
8000e63c:	fe 9b ff f9 	brhi	8000e62e <__mdiff+0x1e>
8000e640:	c4 98       	rjmp	8000e6d2 <__mdiff+0xc2>
8000e642:	58 05       	cp.w	r5,0
8000e644:	c0 64       	brge	8000e650 <__mdiff+0x40>
8000e646:	0e 98       	mov	r8,r7
8000e648:	30 15       	mov	r5,1
8000e64a:	0c 97       	mov	r7,r6
8000e64c:	10 96       	mov	r6,r8
8000e64e:	c0 28       	rjmp	8000e652 <__mdiff+0x42>
8000e650:	30 05       	mov	r5,0
8000e652:	6e 1b       	ld.w	r11,r7[0x4]
8000e654:	c5 6f       	rcall	8000e500 <_Balloc>
8000e656:	6e 49       	ld.w	r9,r7[0x10]
8000e658:	6c 44       	ld.w	r4,r6[0x10]
8000e65a:	99 35       	st.w	r12[0xc],r5
8000e65c:	2f b4       	sub	r4,-5
8000e65e:	f2 c5 ff fb 	sub	r5,r9,-5
8000e662:	ec 04 00 24 	add	r4,r6,r4<<0x2
8000e666:	ee 05 00 25 	add	r5,r7,r5<<0x2
8000e66a:	2e c6       	sub	r6,-20
8000e66c:	2e c7       	sub	r7,-20
8000e66e:	f8 c8 ff ec 	sub	r8,r12,-20
8000e672:	30 0a       	mov	r10,0
8000e674:	0f 0e       	ld.w	lr,r7++
8000e676:	0d 0b       	ld.w	r11,r6++
8000e678:	fc 02 16 10 	lsr	r2,lr,0x10
8000e67c:	f6 03 16 10 	lsr	r3,r11,0x10
8000e680:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000e684:	e4 03 01 03 	sub	r3,r2,r3
8000e688:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000e68c:	fc 0b 01 0b 	sub	r11,lr,r11
8000e690:	f6 0a 00 0a 	add	r10,r11,r10
8000e694:	b0 1a       	st.h	r8[0x2],r10
8000e696:	b1 4a       	asr	r10,0x10
8000e698:	e6 0a 00 0a 	add	r10,r3,r10
8000e69c:	b0 0a       	st.h	r8[0x0],r10
8000e69e:	2f c8       	sub	r8,-4
8000e6a0:	b1 4a       	asr	r10,0x10
8000e6a2:	08 36       	cp.w	r6,r4
8000e6a4:	ce 83       	brcs	8000e674 <__mdiff+0x64>
8000e6a6:	c0 d8       	rjmp	8000e6c0 <__mdiff+0xb0>
8000e6a8:	0f 0b       	ld.w	r11,r7++
8000e6aa:	f6 0e 16 10 	lsr	lr,r11,0x10
8000e6ae:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000e6b2:	16 0a       	add	r10,r11
8000e6b4:	b0 1a       	st.h	r8[0x2],r10
8000e6b6:	b1 4a       	asr	r10,0x10
8000e6b8:	1c 0a       	add	r10,lr
8000e6ba:	b0 0a       	st.h	r8[0x0],r10
8000e6bc:	2f c8       	sub	r8,-4
8000e6be:	b1 4a       	asr	r10,0x10
8000e6c0:	0a 37       	cp.w	r7,r5
8000e6c2:	cf 33       	brcs	8000e6a8 <__mdiff+0x98>
8000e6c4:	c0 28       	rjmp	8000e6c8 <__mdiff+0xb8>
8000e6c6:	20 19       	sub	r9,1
8000e6c8:	11 4a       	ld.w	r10,--r8
8000e6ca:	58 0a       	cp.w	r10,0
8000e6cc:	cf d0       	breq	8000e6c6 <__mdiff+0xb6>
8000e6ce:	99 49       	st.w	r12[0x10],r9
8000e6d0:	d8 32       	popm	r0-r7,pc
8000e6d2:	30 0b       	mov	r11,0
8000e6d4:	c1 6f       	rcall	8000e500 <_Balloc>
8000e6d6:	30 18       	mov	r8,1
8000e6d8:	99 48       	st.w	r12[0x10],r8
8000e6da:	30 08       	mov	r8,0
8000e6dc:	99 58       	st.w	r12[0x14],r8
8000e6de:	d8 32       	popm	r0-r7,pc

8000e6e0 <__lshift>:
8000e6e0:	d4 31       	pushm	r0-r7,lr
8000e6e2:	16 97       	mov	r7,r11
8000e6e4:	76 46       	ld.w	r6,r11[0x10]
8000e6e6:	f4 02 14 05 	asr	r2,r10,0x5
8000e6ea:	2f f6       	sub	r6,-1
8000e6ec:	14 93       	mov	r3,r10
8000e6ee:	18 94       	mov	r4,r12
8000e6f0:	04 06       	add	r6,r2
8000e6f2:	76 1b       	ld.w	r11,r11[0x4]
8000e6f4:	6e 28       	ld.w	r8,r7[0x8]
8000e6f6:	c0 38       	rjmp	8000e6fc <__lshift+0x1c>
8000e6f8:	2f fb       	sub	r11,-1
8000e6fa:	a1 78       	lsl	r8,0x1
8000e6fc:	10 36       	cp.w	r6,r8
8000e6fe:	fe 99 ff fd 	brgt	8000e6f8 <__lshift+0x18>
8000e702:	08 9c       	mov	r12,r4
8000e704:	cf ee       	rcall	8000e500 <_Balloc>
8000e706:	30 09       	mov	r9,0
8000e708:	18 95       	mov	r5,r12
8000e70a:	f8 c8 ff ec 	sub	r8,r12,-20
8000e70e:	12 9a       	mov	r10,r9
8000e710:	c0 38       	rjmp	8000e716 <__lshift+0x36>
8000e712:	10 aa       	st.w	r8++,r10
8000e714:	2f f9       	sub	r9,-1
8000e716:	04 39       	cp.w	r9,r2
8000e718:	cf d5       	brlt	8000e712 <__lshift+0x32>
8000e71a:	6e 4b       	ld.w	r11,r7[0x10]
8000e71c:	e7 d3 c0 05 	bfextu	r3,r3,0x0,0x5
8000e720:	2f bb       	sub	r11,-5
8000e722:	ee c9 ff ec 	sub	r9,r7,-20
8000e726:	ee 0b 00 2b 	add	r11,r7,r11<<0x2
8000e72a:	58 03       	cp.w	r3,0
8000e72c:	c1 30       	breq	8000e752 <__lshift+0x72>
8000e72e:	e6 0c 11 20 	rsub	r12,r3,32
8000e732:	30 0a       	mov	r10,0
8000e734:	72 02       	ld.w	r2,r9[0x0]
8000e736:	e4 03 09 42 	lsl	r2,r2,r3
8000e73a:	04 4a       	or	r10,r2
8000e73c:	10 aa       	st.w	r8++,r10
8000e73e:	13 0a       	ld.w	r10,r9++
8000e740:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000e744:	16 39       	cp.w	r9,r11
8000e746:	cf 73       	brcs	8000e734 <__lshift+0x54>
8000e748:	91 0a       	st.w	r8[0x0],r10
8000e74a:	58 0a       	cp.w	r10,0
8000e74c:	c0 70       	breq	8000e75a <__lshift+0x7a>
8000e74e:	2f f6       	sub	r6,-1
8000e750:	c0 58       	rjmp	8000e75a <__lshift+0x7a>
8000e752:	13 0a       	ld.w	r10,r9++
8000e754:	10 aa       	st.w	r8++,r10
8000e756:	16 39       	cp.w	r9,r11
8000e758:	cf d3       	brcs	8000e752 <__lshift+0x72>
8000e75a:	08 9c       	mov	r12,r4
8000e75c:	20 16       	sub	r6,1
8000e75e:	0e 9b       	mov	r11,r7
8000e760:	8b 46       	st.w	r5[0x10],r6
8000e762:	cb 5e       	rcall	8000e4cc <_Bfree>
8000e764:	0a 9c       	mov	r12,r5
8000e766:	d8 32       	popm	r0-r7,pc

8000e768 <__multiply>:
8000e768:	d4 31       	pushm	r0-r7,lr
8000e76a:	20 2d       	sub	sp,8
8000e76c:	76 49       	ld.w	r9,r11[0x10]
8000e76e:	74 48       	ld.w	r8,r10[0x10]
8000e770:	16 96       	mov	r6,r11
8000e772:	14 95       	mov	r5,r10
8000e774:	10 39       	cp.w	r9,r8
8000e776:	ec 08 17 50 	movlt	r8,r6
8000e77a:	ea 06 17 50 	movlt	r6,r5
8000e77e:	f0 05 17 50 	movlt	r5,r8
8000e782:	6c 28       	ld.w	r8,r6[0x8]
8000e784:	76 43       	ld.w	r3,r11[0x10]
8000e786:	74 42       	ld.w	r2,r10[0x10]
8000e788:	76 1b       	ld.w	r11,r11[0x4]
8000e78a:	e4 03 00 07 	add	r7,r2,r3
8000e78e:	10 37       	cp.w	r7,r8
8000e790:	f7 bb 09 ff 	subgt	r11,-1
8000e794:	cb 6e       	rcall	8000e500 <_Balloc>
8000e796:	ee c4 ff fb 	sub	r4,r7,-5
8000e79a:	f8 c9 ff ec 	sub	r9,r12,-20
8000e79e:	f8 04 00 24 	add	r4,r12,r4<<0x2
8000e7a2:	30 0a       	mov	r10,0
8000e7a4:	12 98       	mov	r8,r9
8000e7a6:	c0 28       	rjmp	8000e7aa <__multiply+0x42>
8000e7a8:	10 aa       	st.w	r8++,r10
8000e7aa:	08 38       	cp.w	r8,r4
8000e7ac:	cf e3       	brcs	8000e7a8 <__multiply+0x40>
8000e7ae:	2f b3       	sub	r3,-5
8000e7b0:	2f b2       	sub	r2,-5
8000e7b2:	ec 03 00 23 	add	r3,r6,r3<<0x2
8000e7b6:	ea 02 00 22 	add	r2,r5,r2<<0x2
8000e7ba:	ec cb ff ec 	sub	r11,r6,-20
8000e7be:	50 12       	stdsp	sp[0x4],r2
8000e7c0:	ea ca ff ec 	sub	r10,r5,-20
8000e7c4:	c4 48       	rjmp	8000e84c <__multiply+0xe4>
8000e7c6:	94 95       	ld.uh	r5,r10[0x2]
8000e7c8:	58 05       	cp.w	r5,0
8000e7ca:	c2 00       	breq	8000e80a <__multiply+0xa2>
8000e7cc:	12 98       	mov	r8,r9
8000e7ce:	16 96       	mov	r6,r11
8000e7d0:	30 0e       	mov	lr,0
8000e7d2:	50 09       	stdsp	sp[0x0],r9
8000e7d4:	0d 02       	ld.w	r2,r6++
8000e7d6:	e4 00 16 10 	lsr	r0,r2,0x10
8000e7da:	70 01       	ld.w	r1,r8[0x0]
8000e7dc:	70 09       	ld.w	r9,r8[0x0]
8000e7de:	b1 81       	lsr	r1,0x10
8000e7e0:	e5 d2 c0 10 	bfextu	r2,r2,0x0,0x10
8000e7e4:	e0 05 03 41 	mac	r1,r0,r5
8000e7e8:	ab 32       	mul	r2,r5
8000e7ea:	e1 d9 c0 10 	bfextu	r0,r9,0x0,0x10
8000e7ee:	00 02       	add	r2,r0
8000e7f0:	e4 0e 00 0e 	add	lr,r2,lr
8000e7f4:	b0 1e       	st.h	r8[0x2],lr
8000e7f6:	b1 8e       	lsr	lr,0x10
8000e7f8:	1c 01       	add	r1,lr
8000e7fa:	b0 01       	st.h	r8[0x0],r1
8000e7fc:	e2 0e 16 10 	lsr	lr,r1,0x10
8000e800:	2f c8       	sub	r8,-4
8000e802:	06 36       	cp.w	r6,r3
8000e804:	ce 83       	brcs	8000e7d4 <__multiply+0x6c>
8000e806:	40 09       	lddsp	r9,sp[0x0]
8000e808:	91 0e       	st.w	r8[0x0],lr
8000e80a:	94 86       	ld.uh	r6,r10[0x0]
8000e80c:	58 06       	cp.w	r6,0
8000e80e:	c1 d0       	breq	8000e848 <__multiply+0xe0>
8000e810:	72 02       	ld.w	r2,r9[0x0]
8000e812:	12 98       	mov	r8,r9
8000e814:	16 9e       	mov	lr,r11
8000e816:	30 05       	mov	r5,0
8000e818:	b0 12       	st.h	r8[0x2],r2
8000e81a:	1d 01       	ld.w	r1,lr++
8000e81c:	90 82       	ld.uh	r2,r8[0x0]
8000e81e:	e1 d1 c0 10 	bfextu	r0,r1,0x0,0x10
8000e822:	ad 30       	mul	r0,r6
8000e824:	e0 02 00 02 	add	r2,r0,r2
8000e828:	e4 05 00 05 	add	r5,r2,r5
8000e82c:	b0 05       	st.h	r8[0x0],r5
8000e82e:	b1 85       	lsr	r5,0x10
8000e830:	b1 81       	lsr	r1,0x10
8000e832:	2f c8       	sub	r8,-4
8000e834:	ad 31       	mul	r1,r6
8000e836:	90 92       	ld.uh	r2,r8[0x2]
8000e838:	e2 02 00 02 	add	r2,r1,r2
8000e83c:	0a 02       	add	r2,r5
8000e83e:	e4 05 16 10 	lsr	r5,r2,0x10
8000e842:	06 3e       	cp.w	lr,r3
8000e844:	ce a3       	brcs	8000e818 <__multiply+0xb0>
8000e846:	91 02       	st.w	r8[0x0],r2
8000e848:	2f ca       	sub	r10,-4
8000e84a:	2f c9       	sub	r9,-4
8000e84c:	40 18       	lddsp	r8,sp[0x4]
8000e84e:	10 3a       	cp.w	r10,r8
8000e850:	cb b3       	brcs	8000e7c6 <__multiply+0x5e>
8000e852:	c0 28       	rjmp	8000e856 <__multiply+0xee>
8000e854:	20 17       	sub	r7,1
8000e856:	58 07       	cp.w	r7,0
8000e858:	e0 8a 00 05 	brle	8000e862 <__multiply+0xfa>
8000e85c:	09 48       	ld.w	r8,--r4
8000e85e:	58 08       	cp.w	r8,0
8000e860:	cf a0       	breq	8000e854 <__multiply+0xec>
8000e862:	99 47       	st.w	r12[0x10],r7
8000e864:	2f ed       	sub	sp,-8
8000e866:	d8 32       	popm	r0-r7,pc

8000e868 <__i2b>:
8000e868:	d4 21       	pushm	r4-r7,lr
8000e86a:	16 97       	mov	r7,r11
8000e86c:	30 1b       	mov	r11,1
8000e86e:	c4 9e       	rcall	8000e500 <_Balloc>
8000e870:	30 19       	mov	r9,1
8000e872:	99 57       	st.w	r12[0x14],r7
8000e874:	99 49       	st.w	r12[0x10],r9
8000e876:	d8 22       	popm	r4-r7,pc

8000e878 <__multadd>:
8000e878:	d4 31       	pushm	r0-r7,lr
8000e87a:	30 08       	mov	r8,0
8000e87c:	12 95       	mov	r5,r9
8000e87e:	16 97       	mov	r7,r11
8000e880:	18 96       	mov	r6,r12
8000e882:	76 44       	ld.w	r4,r11[0x10]
8000e884:	f6 c9 ff ec 	sub	r9,r11,-20
8000e888:	72 0b       	ld.w	r11,r9[0x0]
8000e88a:	f6 0c 16 10 	lsr	r12,r11,0x10
8000e88e:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000e892:	f4 0c 02 4c 	mul	r12,r10,r12
8000e896:	f4 0b 03 45 	mac	r5,r10,r11
8000e89a:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
8000e89e:	b1 85       	lsr	r5,0x10
8000e8a0:	18 05       	add	r5,r12
8000e8a2:	ea 0c 15 10 	lsl	r12,r5,0x10
8000e8a6:	f8 0b 00 0b 	add	r11,r12,r11
8000e8aa:	12 ab       	st.w	r9++,r11
8000e8ac:	2f f8       	sub	r8,-1
8000e8ae:	b1 85       	lsr	r5,0x10
8000e8b0:	08 38       	cp.w	r8,r4
8000e8b2:	ce b5       	brlt	8000e888 <__multadd+0x10>
8000e8b4:	58 05       	cp.w	r5,0
8000e8b6:	c1 c0       	breq	8000e8ee <__multadd+0x76>
8000e8b8:	6e 28       	ld.w	r8,r7[0x8]
8000e8ba:	10 34       	cp.w	r4,r8
8000e8bc:	c1 35       	brlt	8000e8e2 <__multadd+0x6a>
8000e8be:	6e 1b       	ld.w	r11,r7[0x4]
8000e8c0:	0c 9c       	mov	r12,r6
8000e8c2:	2f fb       	sub	r11,-1
8000e8c4:	c1 ee       	rcall	8000e500 <_Balloc>
8000e8c6:	6e 4a       	ld.w	r10,r7[0x10]
8000e8c8:	ee cb ff f4 	sub	r11,r7,-12
8000e8cc:	18 93       	mov	r3,r12
8000e8ce:	2f ea       	sub	r10,-2
8000e8d0:	2f 4c       	sub	r12,-12
8000e8d2:	a3 6a       	lsl	r10,0x2
8000e8d4:	fe b0 dd cb 	rcall	8000a46a <memcpy>
8000e8d8:	0e 9b       	mov	r11,r7
8000e8da:	0c 9c       	mov	r12,r6
8000e8dc:	fe b0 fd f8 	rcall	8000e4cc <_Bfree>
8000e8e0:	06 97       	mov	r7,r3
8000e8e2:	e8 c8 ff ff 	sub	r8,r4,-1
8000e8e6:	2f b4       	sub	r4,-5
8000e8e8:	8f 48       	st.w	r7[0x10],r8
8000e8ea:	ee 04 09 25 	st.w	r7[r4<<0x2],r5
8000e8ee:	0e 9c       	mov	r12,r7
8000e8f0:	d8 32       	popm	r0-r7,pc
8000e8f2:	d7 03       	nop

8000e8f4 <__pow5mult>:
8000e8f4:	d4 31       	pushm	r0-r7,lr
8000e8f6:	14 96       	mov	r6,r10
8000e8f8:	18 97       	mov	r7,r12
8000e8fa:	16 94       	mov	r4,r11
8000e8fc:	f1 da c0 02 	bfextu	r8,r10,0x0,0x2
8000e900:	c0 80       	breq	8000e910 <__pow5mult+0x1c>
8000e902:	20 18       	sub	r8,1
8000e904:	49 f9       	lddpc	r9,8000e980 <__pow5mult+0x8c>
8000e906:	f2 08 03 2a 	ld.w	r10,r9[r8<<0x2]
8000e90a:	30 09       	mov	r9,0
8000e90c:	cb 6f       	rcall	8000e878 <__multadd>
8000e90e:	18 94       	mov	r4,r12
8000e910:	a3 46       	asr	r6,0x2
8000e912:	c3 40       	breq	8000e97a <__pow5mult+0x86>
8000e914:	6e 95       	ld.w	r5,r7[0x24]
8000e916:	58 05       	cp.w	r5,0
8000e918:	c0 91       	brne	8000e92a <__pow5mult+0x36>
8000e91a:	31 0c       	mov	r12,16
8000e91c:	fe b0 db 70 	rcall	80009ffc <malloc>
8000e920:	99 35       	st.w	r12[0xc],r5
8000e922:	8f 9c       	st.w	r7[0x24],r12
8000e924:	99 15       	st.w	r12[0x4],r5
8000e926:	99 25       	st.w	r12[0x8],r5
8000e928:	99 05       	st.w	r12[0x0],r5
8000e92a:	6e 93       	ld.w	r3,r7[0x24]
8000e92c:	66 25       	ld.w	r5,r3[0x8]
8000e92e:	58 05       	cp.w	r5,0
8000e930:	c0 c1       	brne	8000e948 <__pow5mult+0x54>
8000e932:	e0 6b 02 71 	mov	r11,625
8000e936:	0e 9c       	mov	r12,r7
8000e938:	c9 8f       	rcall	8000e868 <__i2b>
8000e93a:	87 2c       	st.w	r3[0x8],r12
8000e93c:	30 08       	mov	r8,0
8000e93e:	18 95       	mov	r5,r12
8000e940:	99 08       	st.w	r12[0x0],r8
8000e942:	c0 38       	rjmp	8000e948 <__pow5mult+0x54>
8000e944:	06 9c       	mov	r12,r3
8000e946:	18 95       	mov	r5,r12
8000e948:	ed b6 00 00 	bld	r6,0x0
8000e94c:	c0 b1       	brne	8000e962 <__pow5mult+0x6e>
8000e94e:	08 9b       	mov	r11,r4
8000e950:	0a 9a       	mov	r10,r5
8000e952:	0e 9c       	mov	r12,r7
8000e954:	c0 af       	rcall	8000e768 <__multiply>
8000e956:	08 9b       	mov	r11,r4
8000e958:	18 93       	mov	r3,r12
8000e95a:	0e 9c       	mov	r12,r7
8000e95c:	06 94       	mov	r4,r3
8000e95e:	fe b0 fd b7 	rcall	8000e4cc <_Bfree>
8000e962:	a1 56       	asr	r6,0x1
8000e964:	c0 b0       	breq	8000e97a <__pow5mult+0x86>
8000e966:	6a 03       	ld.w	r3,r5[0x0]
8000e968:	58 03       	cp.w	r3,0
8000e96a:	ce d1       	brne	8000e944 <__pow5mult+0x50>
8000e96c:	0a 9a       	mov	r10,r5
8000e96e:	0a 9b       	mov	r11,r5
8000e970:	0e 9c       	mov	r12,r7
8000e972:	cf be       	rcall	8000e768 <__multiply>
8000e974:	8b 0c       	st.w	r5[0x0],r12
8000e976:	99 03       	st.w	r12[0x0],r3
8000e978:	ce 7b       	rjmp	8000e946 <__pow5mult+0x52>
8000e97a:	08 9c       	mov	r12,r4
8000e97c:	d8 32       	popm	r0-r7,pc
8000e97e:	d7 03       	nop
8000e980:	80 01       	ld.sh	r1,r0[0x0]
8000e982:	93 74       	st.w	r9[0x1c],r4

8000e984 <__isinfd>:
8000e984:	14 98       	mov	r8,r10
8000e986:	fc 19 7f f0 	movh	r9,0x7ff0
8000e98a:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000e98e:	f0 0b 11 00 	rsub	r11,r8,0
8000e992:	f7 e8 10 08 	or	r8,r11,r8
8000e996:	f5 e8 13 f8 	or	r8,r10,r8>>0x1f
8000e99a:	f2 08 01 08 	sub	r8,r9,r8
8000e99e:	f0 0c 11 00 	rsub	r12,r8,0
8000e9a2:	f9 e8 10 08 	or	r8,r12,r8
8000e9a6:	f0 0c 14 1f 	asr	r12,r8,0x1f
8000e9aa:	2f fc       	sub	r12,-1
8000e9ac:	5e fc       	retal	r12

8000e9ae <__isnand>:
8000e9ae:	14 98       	mov	r8,r10
8000e9b0:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000e9b4:	f0 0c 11 00 	rsub	r12,r8,0
8000e9b8:	10 4c       	or	r12,r8
8000e9ba:	fc 18 7f f0 	movh	r8,0x7ff0
8000e9be:	f5 ec 13 fc 	or	r12,r10,r12>>0x1f
8000e9c2:	f0 0c 01 0c 	sub	r12,r8,r12
8000e9c6:	bf 9c       	lsr	r12,0x1f
8000e9c8:	5e fc       	retal	r12
8000e9ca:	d7 03       	nop

8000e9cc <__sclose>:
8000e9cc:	d4 01       	pushm	lr
8000e9ce:	96 7b       	ld.sh	r11,r11[0xe]
8000e9d0:	c7 6c       	rcall	8000eabc <_close_r>
8000e9d2:	d8 02       	popm	pc

8000e9d4 <__sseek>:
8000e9d4:	d4 21       	pushm	r4-r7,lr
8000e9d6:	16 97       	mov	r7,r11
8000e9d8:	96 7b       	ld.sh	r11,r11[0xe]
8000e9da:	cf 9c       	rcall	8000ebcc <_lseek_r>
8000e9dc:	8e 68       	ld.sh	r8,r7[0xc]
8000e9de:	10 99       	mov	r9,r8
8000e9e0:	ad c8       	cbr	r8,0xc
8000e9e2:	ad a9       	sbr	r9,0xc
8000e9e4:	5b fc       	cp.w	r12,-1
8000e9e6:	ef f8 0c 06 	st.heq	r7[0xc],r8
8000e9ea:	ef f9 1c 06 	st.hne	r7[0xc],r9
8000e9ee:	ef fc 1a 15 	st.wne	r7[0x54],r12
8000e9f2:	d8 22       	popm	r4-r7,pc

8000e9f4 <__swrite>:
8000e9f4:	d4 21       	pushm	r4-r7,lr
8000e9f6:	96 68       	ld.sh	r8,r11[0xc]
8000e9f8:	16 97       	mov	r7,r11
8000e9fa:	14 95       	mov	r5,r10
8000e9fc:	12 94       	mov	r4,r9
8000e9fe:	e2 18 01 00 	andl	r8,0x100,COH
8000ea02:	18 96       	mov	r6,r12
8000ea04:	c0 50       	breq	8000ea0e <__swrite+0x1a>
8000ea06:	30 29       	mov	r9,2
8000ea08:	30 0a       	mov	r10,0
8000ea0a:	96 7b       	ld.sh	r11,r11[0xe]
8000ea0c:	ce 0c       	rcall	8000ebcc <_lseek_r>
8000ea0e:	8e 68       	ld.sh	r8,r7[0xc]
8000ea10:	ad c8       	cbr	r8,0xc
8000ea12:	08 99       	mov	r9,r4
8000ea14:	0a 9a       	mov	r10,r5
8000ea16:	8e 7b       	ld.sh	r11,r7[0xe]
8000ea18:	0c 9c       	mov	r12,r6
8000ea1a:	ae 68       	st.h	r7[0xc],r8
8000ea1c:	c1 0c       	rcall	8000ea3c <_write_r>
8000ea1e:	d8 22       	popm	r4-r7,pc

8000ea20 <__sread>:
8000ea20:	d4 21       	pushm	r4-r7,lr
8000ea22:	16 97       	mov	r7,r11
8000ea24:	96 7b       	ld.sh	r11,r11[0xe]
8000ea26:	ce 7c       	rcall	8000ebf4 <_read_r>
8000ea28:	c0 65       	brlt	8000ea34 <__sread+0x14>
8000ea2a:	6f 58       	ld.w	r8,r7[0x54]
8000ea2c:	18 08       	add	r8,r12
8000ea2e:	ef 48 00 54 	st.w	r7[84],r8
8000ea32:	d8 22       	popm	r4-r7,pc
8000ea34:	8e 68       	ld.sh	r8,r7[0xc]
8000ea36:	ad c8       	cbr	r8,0xc
8000ea38:	ae 68       	st.h	r7[0xc],r8
8000ea3a:	d8 22       	popm	r4-r7,pc

8000ea3c <_write_r>:
8000ea3c:	d4 21       	pushm	r4-r7,lr
8000ea3e:	16 98       	mov	r8,r11
8000ea40:	18 97       	mov	r7,r12
8000ea42:	10 9c       	mov	r12,r8
8000ea44:	30 08       	mov	r8,0
8000ea46:	14 9b       	mov	r11,r10
8000ea48:	e0 66 46 28 	mov	r6,17960
8000ea4c:	12 9a       	mov	r10,r9
8000ea4e:	8d 08       	st.w	r6[0x0],r8
8000ea50:	fe b0 d0 56 	rcall	80008afc <_write>
8000ea54:	5b fc       	cp.w	r12,-1
8000ea56:	c0 51       	brne	8000ea60 <_write_r+0x24>
8000ea58:	6c 08       	ld.w	r8,r6[0x0]
8000ea5a:	58 08       	cp.w	r8,0
8000ea5c:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000ea60:	d8 22       	popm	r4-r7,pc
8000ea62:	d7 03       	nop

8000ea64 <_calloc_r>:
8000ea64:	d4 21       	pushm	r4-r7,lr
8000ea66:	f4 0b 02 4b 	mul	r11,r10,r11
8000ea6a:	fe b0 da d1 	rcall	8000a00c <_malloc_r>
8000ea6e:	18 97       	mov	r7,r12
8000ea70:	c2 30       	breq	8000eab6 <_calloc_r+0x52>
8000ea72:	f8 fa ff fc 	ld.w	r10,r12[-4]
8000ea76:	e0 1a ff fc 	andl	r10,0xfffc
8000ea7a:	20 4a       	sub	r10,4
8000ea7c:	e0 4a 00 24 	cp.w	r10,36
8000ea80:	e0 8b 00 18 	brhi	8000eab0 <_calloc_r+0x4c>
8000ea84:	18 98       	mov	r8,r12
8000ea86:	59 3a       	cp.w	r10,19
8000ea88:	e0 88 00 0f 	brls	8000eaa6 <_calloc_r+0x42>
8000ea8c:	30 09       	mov	r9,0
8000ea8e:	10 a9       	st.w	r8++,r9
8000ea90:	10 a9       	st.w	r8++,r9
8000ea92:	59 ba       	cp.w	r10,27
8000ea94:	e0 88 00 09 	brls	8000eaa6 <_calloc_r+0x42>
8000ea98:	10 a9       	st.w	r8++,r9
8000ea9a:	10 a9       	st.w	r8++,r9
8000ea9c:	e0 4a 00 24 	cp.w	r10,36
8000eaa0:	c0 31       	brne	8000eaa6 <_calloc_r+0x42>
8000eaa2:	10 a9       	st.w	r8++,r9
8000eaa4:	10 a9       	st.w	r8++,r9
8000eaa6:	30 09       	mov	r9,0
8000eaa8:	10 a9       	st.w	r8++,r9
8000eaaa:	91 19       	st.w	r8[0x4],r9
8000eaac:	91 09       	st.w	r8[0x0],r9
8000eaae:	c0 48       	rjmp	8000eab6 <_calloc_r+0x52>
8000eab0:	30 0b       	mov	r11,0
8000eab2:	fe b0 dd 80 	rcall	8000a5b2 <memset>
8000eab6:	0e 9c       	mov	r12,r7
8000eab8:	d8 22       	popm	r4-r7,pc
8000eaba:	d7 03       	nop

8000eabc <_close_r>:
8000eabc:	d4 21       	pushm	r4-r7,lr
8000eabe:	30 08       	mov	r8,0
8000eac0:	18 97       	mov	r7,r12
8000eac2:	e0 66 46 28 	mov	r6,17960
8000eac6:	16 9c       	mov	r12,r11
8000eac8:	8d 08       	st.w	r6[0x0],r8
8000eaca:	fe b0 df a5 	rcall	8000aa14 <_close>
8000eace:	5b fc       	cp.w	r12,-1
8000ead0:	c0 51       	brne	8000eada <_close_r+0x1e>
8000ead2:	6c 08       	ld.w	r8,r6[0x0]
8000ead4:	58 08       	cp.w	r8,0
8000ead6:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000eada:	d8 22       	popm	r4-r7,pc

8000eadc <_fclose_r>:
8000eadc:	d4 21       	pushm	r4-r7,lr
8000eade:	18 96       	mov	r6,r12
8000eae0:	16 97       	mov	r7,r11
8000eae2:	58 0b       	cp.w	r11,0
8000eae4:	c0 31       	brne	8000eaea <_fclose_r+0xe>
8000eae6:	16 95       	mov	r5,r11
8000eae8:	c5 08       	rjmp	8000eb88 <_fclose_r+0xac>
8000eaea:	fe b0 f8 b1 	rcall	8000dc4c <__sfp_lock_acquire>
8000eaee:	58 06       	cp.w	r6,0
8000eaf0:	c0 70       	breq	8000eafe <_fclose_r+0x22>
8000eaf2:	6c 68       	ld.w	r8,r6[0x18]
8000eaf4:	58 08       	cp.w	r8,0
8000eaf6:	c0 41       	brne	8000eafe <_fclose_r+0x22>
8000eaf8:	0c 9c       	mov	r12,r6
8000eafa:	fe b0 f8 fd 	rcall	8000dcf4 <__sinit>
8000eafe:	4a 48       	lddpc	r8,8000eb8c <_fclose_r+0xb0>
8000eb00:	10 37       	cp.w	r7,r8
8000eb02:	c0 31       	brne	8000eb08 <_fclose_r+0x2c>
8000eb04:	6c 07       	ld.w	r7,r6[0x0]
8000eb06:	c0 a8       	rjmp	8000eb1a <_fclose_r+0x3e>
8000eb08:	4a 28       	lddpc	r8,8000eb90 <_fclose_r+0xb4>
8000eb0a:	10 37       	cp.w	r7,r8
8000eb0c:	c0 31       	brne	8000eb12 <_fclose_r+0x36>
8000eb0e:	6c 17       	ld.w	r7,r6[0x4]
8000eb10:	c0 58       	rjmp	8000eb1a <_fclose_r+0x3e>
8000eb12:	4a 18       	lddpc	r8,8000eb94 <_fclose_r+0xb8>
8000eb14:	10 37       	cp.w	r7,r8
8000eb16:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000eb1a:	8e 69       	ld.sh	r9,r7[0xc]
8000eb1c:	30 08       	mov	r8,0
8000eb1e:	f0 09 19 00 	cp.h	r9,r8
8000eb22:	c0 51       	brne	8000eb2c <_fclose_r+0x50>
8000eb24:	fe b0 f8 95 	rcall	8000dc4e <__sfp_lock_release>
8000eb28:	30 05       	mov	r5,0
8000eb2a:	c2 f8       	rjmp	8000eb88 <_fclose_r+0xac>
8000eb2c:	0e 9b       	mov	r11,r7
8000eb2e:	0c 9c       	mov	r12,r6
8000eb30:	fe b0 f8 06 	rcall	8000db3c <_fflush_r>
8000eb34:	6e c8       	ld.w	r8,r7[0x30]
8000eb36:	18 95       	mov	r5,r12
8000eb38:	58 08       	cp.w	r8,0
8000eb3a:	c0 60       	breq	8000eb46 <_fclose_r+0x6a>
8000eb3c:	6e 8b       	ld.w	r11,r7[0x20]
8000eb3e:	0c 9c       	mov	r12,r6
8000eb40:	5d 18       	icall	r8
8000eb42:	f9 b5 05 ff 	movlt	r5,-1
8000eb46:	8e 68       	ld.sh	r8,r7[0xc]
8000eb48:	ed b8 00 07 	bld	r8,0x7
8000eb4c:	c0 51       	brne	8000eb56 <_fclose_r+0x7a>
8000eb4e:	6e 4b       	ld.w	r11,r7[0x10]
8000eb50:	0c 9c       	mov	r12,r6
8000eb52:	fe b0 f9 6b 	rcall	8000de28 <_free_r>
8000eb56:	6e db       	ld.w	r11,r7[0x34]
8000eb58:	58 0b       	cp.w	r11,0
8000eb5a:	c0 a0       	breq	8000eb6e <_fclose_r+0x92>
8000eb5c:	ee c8 ff bc 	sub	r8,r7,-68
8000eb60:	10 3b       	cp.w	r11,r8
8000eb62:	c0 40       	breq	8000eb6a <_fclose_r+0x8e>
8000eb64:	0c 9c       	mov	r12,r6
8000eb66:	fe b0 f9 61 	rcall	8000de28 <_free_r>
8000eb6a:	30 08       	mov	r8,0
8000eb6c:	8f d8       	st.w	r7[0x34],r8
8000eb6e:	6f 2b       	ld.w	r11,r7[0x48]
8000eb70:	58 0b       	cp.w	r11,0
8000eb72:	c0 70       	breq	8000eb80 <_fclose_r+0xa4>
8000eb74:	0c 9c       	mov	r12,r6
8000eb76:	fe b0 f9 59 	rcall	8000de28 <_free_r>
8000eb7a:	30 08       	mov	r8,0
8000eb7c:	ef 48 00 48 	st.w	r7[72],r8
8000eb80:	30 08       	mov	r8,0
8000eb82:	ae 68       	st.h	r7[0xc],r8
8000eb84:	fe b0 f8 65 	rcall	8000dc4e <__sfp_lock_release>
8000eb88:	0a 9c       	mov	r12,r5
8000eb8a:	d8 22       	popm	r4-r7,pc
8000eb8c:	80 01       	ld.sh	r1,r0[0x0]
8000eb8e:	92 d0       	ld.uh	r0,r9[0xa]
8000eb90:	80 01       	ld.sh	r1,r0[0x0]
8000eb92:	92 f0       	ld.uh	r0,r9[0xe]
8000eb94:	80 01       	ld.sh	r1,r0[0x0]
8000eb96:	93 10       	st.w	r9[0x4],r0

8000eb98 <fclose>:
8000eb98:	d4 01       	pushm	lr
8000eb9a:	e0 68 0a 38 	mov	r8,2616
8000eb9e:	18 9b       	mov	r11,r12
8000eba0:	70 0c       	ld.w	r12,r8[0x0]
8000eba2:	c9 df       	rcall	8000eadc <_fclose_r>
8000eba4:	d8 02       	popm	pc
8000eba6:	d7 03       	nop

8000eba8 <_fstat_r>:
8000eba8:	d4 21       	pushm	r4-r7,lr
8000ebaa:	16 98       	mov	r8,r11
8000ebac:	18 97       	mov	r7,r12
8000ebae:	10 9c       	mov	r12,r8
8000ebb0:	30 08       	mov	r8,0
8000ebb2:	e0 66 46 28 	mov	r6,17960
8000ebb6:	14 9b       	mov	r11,r10
8000ebb8:	8d 08       	st.w	r6[0x0],r8
8000ebba:	fe b0 df 55 	rcall	8000aa64 <_fstat>
8000ebbe:	5b fc       	cp.w	r12,-1
8000ebc0:	c0 51       	brne	8000ebca <_fstat_r+0x22>
8000ebc2:	6c 08       	ld.w	r8,r6[0x0]
8000ebc4:	58 08       	cp.w	r8,0
8000ebc6:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000ebca:	d8 22       	popm	r4-r7,pc

8000ebcc <_lseek_r>:
8000ebcc:	d4 21       	pushm	r4-r7,lr
8000ebce:	16 98       	mov	r8,r11
8000ebd0:	18 97       	mov	r7,r12
8000ebd2:	10 9c       	mov	r12,r8
8000ebd4:	30 08       	mov	r8,0
8000ebd6:	14 9b       	mov	r11,r10
8000ebd8:	e0 66 46 28 	mov	r6,17960
8000ebdc:	12 9a       	mov	r10,r9
8000ebde:	8d 08       	st.w	r6[0x0],r8
8000ebe0:	fe b0 df 24 	rcall	8000aa28 <_lseek>
8000ebe4:	5b fc       	cp.w	r12,-1
8000ebe6:	c0 51       	brne	8000ebf0 <_lseek_r+0x24>
8000ebe8:	6c 08       	ld.w	r8,r6[0x0]
8000ebea:	58 08       	cp.w	r8,0
8000ebec:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000ebf0:	d8 22       	popm	r4-r7,pc
8000ebf2:	d7 03       	nop

8000ebf4 <_read_r>:
8000ebf4:	d4 21       	pushm	r4-r7,lr
8000ebf6:	16 98       	mov	r8,r11
8000ebf8:	18 97       	mov	r7,r12
8000ebfa:	10 9c       	mov	r12,r8
8000ebfc:	30 08       	mov	r8,0
8000ebfe:	14 9b       	mov	r11,r10
8000ec00:	e0 66 46 28 	mov	r6,17960
8000ec04:	12 9a       	mov	r10,r9
8000ec06:	8d 08       	st.w	r6[0x0],r8
8000ec08:	fe b0 cf 5a 	rcall	80008abc <_read>
8000ec0c:	5b fc       	cp.w	r12,-1
8000ec0e:	c0 51       	brne	8000ec18 <_read_r+0x24>
8000ec10:	6c 08       	ld.w	r8,r6[0x0]
8000ec12:	58 08       	cp.w	r8,0
8000ec14:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000ec18:	d8 22       	popm	r4-r7,pc
8000ec1a:	d7 03       	nop

8000ec1c <__avr32_f64_mul>:
8000ec1c:	f5 eb 10 1c 	or	r12,r10,r11<<0x1
8000ec20:	e0 80 00 dc 	breq	8000edd8 <__avr32_f64_mul_op1_zero>
8000ec24:	d4 21       	pushm	r4-r7,lr
8000ec26:	f7 e9 20 0e 	eor	lr,r11,r9
8000ec2a:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000ec2e:	30 15       	mov	r5,1
8000ec30:	c4 30       	breq	8000ecb6 <__avr32_f64_mul_op1_subnormal>
8000ec32:	ab 6b       	lsl	r11,0xa
8000ec34:	f7 ea 13 6b 	or	r11,r11,r10>>0x16
8000ec38:	ab 6a       	lsl	r10,0xa
8000ec3a:	f7 d5 d3 c2 	bfins	r11,r5,0x1e,0x2
8000ec3e:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000ec42:	c5 c0       	breq	8000ecfa <__avr32_f64_mul_op2_subnormal>
8000ec44:	a1 78       	lsl	r8,0x1
8000ec46:	5c f9       	rol	r9
8000ec48:	f3 d5 d2 ab 	bfins	r9,r5,0x15,0xb
8000ec4c:	e0 47 07 ff 	cp.w	r7,2047
8000ec50:	c7 70       	breq	8000ed3e <__avr32_f64_mul_op_nan_or_inf>
8000ec52:	e0 46 07 ff 	cp.w	r6,2047
8000ec56:	c7 40       	breq	8000ed3e <__avr32_f64_mul_op_nan_or_inf>
8000ec58:	ee 06 00 0c 	add	r12,r7,r6
8000ec5c:	e0 2c 03 fe 	sub	r12,1022
8000ec60:	f6 08 06 44 	mulu.d	r4,r11,r8
8000ec64:	f4 09 07 44 	macu.d	r4,r10,r9
8000ec68:	f4 08 06 46 	mulu.d	r6,r10,r8
8000ec6c:	f6 09 06 4a 	mulu.d	r10,r11,r9
8000ec70:	08 07       	add	r7,r4
8000ec72:	f4 05 00 4a 	adc	r10,r10,r5
8000ec76:	5c 0b       	acr	r11
8000ec78:	ed bb 00 14 	bld	r11,0x14
8000ec7c:	c0 50       	breq	8000ec86 <__avr32_f64_mul+0x6a>
8000ec7e:	a1 77       	lsl	r7,0x1
8000ec80:	5c fa       	rol	r10
8000ec82:	5c fb       	rol	r11
8000ec84:	20 1c       	sub	r12,1
8000ec86:	58 0c       	cp.w	r12,0
8000ec88:	e0 8a 00 6f 	brle	8000ed66 <__avr32_f64_mul_res_subnormal>
8000ec8c:	e0 4c 07 ff 	cp.w	r12,2047
8000ec90:	e0 84 00 9c 	brge	8000edc8 <__avr32_f64_mul_res_inf>
8000ec94:	f7 dc d2 8b 	bfins	r11,r12,0x14,0xb
8000ec98:	ed ea 11 f6 	or	r6,r6,r10<<0x1f
8000ec9c:	ef e6 12 17 	or	r7,r7,r6>>0x1
8000eca0:	ee 17 80 00 	eorh	r7,0x8000
8000eca4:	f1 b7 04 20 	satu	r7,0x1
8000eca8:	0e 0a       	add	r10,r7
8000ecaa:	5c 0b       	acr	r11
8000ecac:	ed be 00 1f 	bld	lr,0x1f
8000ecb0:	ef bb 00 1f 	bst	r11,0x1f
8000ecb4:	d8 22       	popm	r4-r7,pc

8000ecb6 <__avr32_f64_mul_op1_subnormal>:
8000ecb6:	e4 1b 00 0f 	andh	r11,0xf
8000ecba:	f4 0c 12 00 	clz	r12,r10
8000ecbe:	f6 06 12 00 	clz	r6,r11
8000ecc2:	f7 bc 03 e1 	sublo	r12,-31
8000ecc6:	f8 06 17 30 	movlo	r6,r12
8000ecca:	f7 b6 02 01 	subhs	r6,1
8000ecce:	e0 46 00 20 	cp.w	r6,32
8000ecd2:	c0 d4       	brge	8000ecec <__avr32_f64_mul_op1_subnormal+0x36>
8000ecd4:	ec 0c 11 20 	rsub	r12,r6,32
8000ecd8:	f6 06 09 4b 	lsl	r11,r11,r6
8000ecdc:	f4 0c 0a 4c 	lsr	r12,r10,r12
8000ece0:	18 4b       	or	r11,r12
8000ece2:	f4 06 09 4a 	lsl	r10,r10,r6
8000ece6:	20 b6       	sub	r6,11
8000ece8:	0c 17       	sub	r7,r6
8000ecea:	ca ab       	rjmp	8000ec3e <__avr32_f64_mul+0x22>
8000ecec:	f4 06 09 4b 	lsl	r11,r10,r6
8000ecf0:	c6 40       	breq	8000edb8 <__avr32_f64_mul_res_zero>
8000ecf2:	30 0a       	mov	r10,0
8000ecf4:	20 b6       	sub	r6,11
8000ecf6:	0c 17       	sub	r7,r6
8000ecf8:	ca 3b       	rjmp	8000ec3e <__avr32_f64_mul+0x22>

8000ecfa <__avr32_f64_mul_op2_subnormal>:
8000ecfa:	e4 19 00 0f 	andh	r9,0xf
8000ecfe:	f0 0c 12 00 	clz	r12,r8
8000ed02:	f2 05 12 00 	clz	r5,r9
8000ed06:	f7 bc 03 ea 	sublo	r12,-22
8000ed0a:	f8 05 17 30 	movlo	r5,r12
8000ed0e:	f7 b5 02 0a 	subhs	r5,10
8000ed12:	e0 45 00 20 	cp.w	r5,32
8000ed16:	c0 d4       	brge	8000ed30 <__avr32_f64_mul_op2_subnormal+0x36>
8000ed18:	ea 0c 11 20 	rsub	r12,r5,32
8000ed1c:	f2 05 09 49 	lsl	r9,r9,r5
8000ed20:	f0 0c 0a 4c 	lsr	r12,r8,r12
8000ed24:	18 49       	or	r9,r12
8000ed26:	f0 05 09 48 	lsl	r8,r8,r5
8000ed2a:	20 25       	sub	r5,2
8000ed2c:	0a 16       	sub	r6,r5
8000ed2e:	c8 fb       	rjmp	8000ec4c <__avr32_f64_mul+0x30>
8000ed30:	f0 05 09 49 	lsl	r9,r8,r5
8000ed34:	c4 20       	breq	8000edb8 <__avr32_f64_mul_res_zero>
8000ed36:	30 08       	mov	r8,0
8000ed38:	20 25       	sub	r5,2
8000ed3a:	0a 16       	sub	r6,r5
8000ed3c:	c8 8b       	rjmp	8000ec4c <__avr32_f64_mul+0x30>

8000ed3e <__avr32_f64_mul_op_nan_or_inf>:
8000ed3e:	e4 19 00 0f 	andh	r9,0xf
8000ed42:	e4 1b 00 0f 	andh	r11,0xf
8000ed46:	14 4b       	or	r11,r10
8000ed48:	10 49       	or	r9,r8
8000ed4a:	e0 47 07 ff 	cp.w	r7,2047
8000ed4e:	c0 91       	brne	8000ed60 <__avr32_f64_mul_op1_not_naninf>
8000ed50:	58 0b       	cp.w	r11,0
8000ed52:	c3 81       	brne	8000edc2 <__avr32_f64_mul_res_nan>
8000ed54:	e0 46 07 ff 	cp.w	r6,2047
8000ed58:	c3 81       	brne	8000edc8 <__avr32_f64_mul_res_inf>
8000ed5a:	58 09       	cp.w	r9,0
8000ed5c:	c3 60       	breq	8000edc8 <__avr32_f64_mul_res_inf>
8000ed5e:	c3 28       	rjmp	8000edc2 <__avr32_f64_mul_res_nan>

8000ed60 <__avr32_f64_mul_op1_not_naninf>:
8000ed60:	58 09       	cp.w	r9,0
8000ed62:	c3 30       	breq	8000edc8 <__avr32_f64_mul_res_inf>
8000ed64:	c2 f8       	rjmp	8000edc2 <__avr32_f64_mul_res_nan>

8000ed66 <__avr32_f64_mul_res_subnormal>:
8000ed66:	5c 3c       	neg	r12
8000ed68:	2f fc       	sub	r12,-1
8000ed6a:	f1 bc 04 c0 	satu	r12,0x6
8000ed6e:	e0 4c 00 20 	cp.w	r12,32
8000ed72:	c1 14       	brge	8000ed94 <__avr32_f64_mul_res_subnormal+0x2e>
8000ed74:	f8 08 11 20 	rsub	r8,r12,32
8000ed78:	0e 46       	or	r6,r7
8000ed7a:	ee 0c 0a 47 	lsr	r7,r7,r12
8000ed7e:	f4 08 09 49 	lsl	r9,r10,r8
8000ed82:	12 47       	or	r7,r9
8000ed84:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000ed88:	f6 08 09 49 	lsl	r9,r11,r8
8000ed8c:	12 4a       	or	r10,r9
8000ed8e:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000ed92:	c8 3b       	rjmp	8000ec98 <__avr32_f64_mul+0x7c>
8000ed94:	f8 08 11 20 	rsub	r8,r12,32
8000ed98:	f9 b9 00 00 	moveq	r9,0
8000ed9c:	c0 30       	breq	8000eda2 <__avr32_f64_mul_res_subnormal+0x3c>
8000ed9e:	f6 08 09 49 	lsl	r9,r11,r8
8000eda2:	0e 46       	or	r6,r7
8000eda4:	ed ea 10 16 	or	r6,r6,r10<<0x1
8000eda8:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000edac:	f3 ea 10 07 	or	r7,r9,r10
8000edb0:	f6 0c 0a 4a 	lsr	r10,r11,r12
8000edb4:	30 0b       	mov	r11,0
8000edb6:	c7 1b       	rjmp	8000ec98 <__avr32_f64_mul+0x7c>

8000edb8 <__avr32_f64_mul_res_zero>:
8000edb8:	1c 9b       	mov	r11,lr
8000edba:	e6 1b 80 00 	andh	r11,0x8000,COH
8000edbe:	30 0a       	mov	r10,0
8000edc0:	d8 22       	popm	r4-r7,pc

8000edc2 <__avr32_f64_mul_res_nan>:
8000edc2:	3f fb       	mov	r11,-1
8000edc4:	3f fa       	mov	r10,-1
8000edc6:	d8 22       	popm	r4-r7,pc

8000edc8 <__avr32_f64_mul_res_inf>:
8000edc8:	f0 6b 00 00 	mov	r11,-1048576
8000edcc:	ed be 00 1f 	bld	lr,0x1f
8000edd0:	ef bb 00 1f 	bst	r11,0x1f
8000edd4:	30 0a       	mov	r10,0
8000edd6:	d8 22       	popm	r4-r7,pc

8000edd8 <__avr32_f64_mul_op1_zero>:
8000edd8:	f7 e9 20 0b 	eor	r11,r11,r9
8000eddc:	e6 1b 80 00 	andh	r11,0x8000,COH
8000ede0:	f9 d9 c2 8b 	bfextu	r12,r9,0x14,0xb
8000ede4:	e0 4c 07 ff 	cp.w	r12,2047
8000ede8:	5e 1c       	retne	r12
8000edea:	3f fa       	mov	r10,-1
8000edec:	3f fb       	mov	r11,-1
8000edee:	5e fc       	retal	r12

8000edf0 <__avr32_f64_sub_from_add>:
8000edf0:	ee 19 80 00 	eorh	r9,0x8000

8000edf4 <__avr32_f64_sub>:
8000edf4:	f7 e9 20 0c 	eor	r12,r11,r9
8000edf8:	e0 86 00 ca 	brmi	8000ef8c <__avr32_f64_add_from_sub>
8000edfc:	eb cd 40 e0 	pushm	r5-r7,lr
8000ee00:	16 9c       	mov	r12,r11
8000ee02:	e6 1c 80 00 	andh	r12,0x8000,COH
8000ee06:	bf db       	cbr	r11,0x1f
8000ee08:	bf d9       	cbr	r9,0x1f
8000ee0a:	10 3a       	cp.w	r10,r8
8000ee0c:	f2 0b 13 00 	cpc	r11,r9
8000ee10:	c0 92       	brcc	8000ee22 <__avr32_f64_sub+0x2e>
8000ee12:	16 97       	mov	r7,r11
8000ee14:	12 9b       	mov	r11,r9
8000ee16:	0e 99       	mov	r9,r7
8000ee18:	14 97       	mov	r7,r10
8000ee1a:	10 9a       	mov	r10,r8
8000ee1c:	0e 98       	mov	r8,r7
8000ee1e:	ee 1c 80 00 	eorh	r12,0x8000
8000ee22:	f6 07 16 14 	lsr	r7,r11,0x14
8000ee26:	ab 7b       	lsl	r11,0xb
8000ee28:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000ee2c:	ab 7a       	lsl	r10,0xb
8000ee2e:	bf bb       	sbr	r11,0x1f
8000ee30:	f2 06 16 14 	lsr	r6,r9,0x14
8000ee34:	c4 40       	breq	8000eebc <__avr32_f64_sub_opL_subnormal>
8000ee36:	ab 79       	lsl	r9,0xb
8000ee38:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000ee3c:	ab 78       	lsl	r8,0xb
8000ee3e:	bf b9       	sbr	r9,0x1f

8000ee40 <__avr32_f64_sub_opL_subnormal_done>:
8000ee40:	e0 47 07 ff 	cp.w	r7,2047
8000ee44:	c4 f0       	breq	8000eee2 <__avr32_f64_sub_opH_nan_or_inf>
8000ee46:	0e 26       	rsub	r6,r7
8000ee48:	c1 20       	breq	8000ee6c <__avr32_f64_sub_shift_done>
8000ee4a:	ec 05 11 20 	rsub	r5,r6,32
8000ee4e:	e0 46 00 20 	cp.w	r6,32
8000ee52:	c7 c2       	brcc	8000ef4a <__avr32_f64_sub_longshift>
8000ee54:	f0 05 09 4e 	lsl	lr,r8,r5
8000ee58:	f2 05 09 45 	lsl	r5,r9,r5
8000ee5c:	f0 06 0a 48 	lsr	r8,r8,r6
8000ee60:	f2 06 0a 49 	lsr	r9,r9,r6
8000ee64:	0a 48       	or	r8,r5
8000ee66:	58 0e       	cp.w	lr,0
8000ee68:	5f 1e       	srne	lr
8000ee6a:	1c 48       	or	r8,lr

8000ee6c <__avr32_f64_sub_shift_done>:
8000ee6c:	10 1a       	sub	r10,r8
8000ee6e:	f6 09 01 4b 	sbc	r11,r11,r9
8000ee72:	f6 06 12 00 	clz	r6,r11
8000ee76:	c0 e0       	breq	8000ee92 <__avr32_f64_sub_longnormalize_done>
8000ee78:	c7 83       	brcs	8000ef68 <__avr32_f64_sub_longnormalize>
8000ee7a:	ec 0e 11 20 	rsub	lr,r6,32
8000ee7e:	f6 06 09 4b 	lsl	r11,r11,r6
8000ee82:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000ee86:	1c 4b       	or	r11,lr
8000ee88:	f4 06 09 4a 	lsl	r10,r10,r6
8000ee8c:	0c 17       	sub	r7,r6
8000ee8e:	e0 8a 00 39 	brle	8000ef00 <__avr32_f64_sub_subnormal_result>

8000ee92 <__avr32_f64_sub_longnormalize_done>:
8000ee92:	f4 09 15 15 	lsl	r9,r10,0x15
8000ee96:	ab 9a       	lsr	r10,0xb
8000ee98:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000ee9c:	ab 9b       	lsr	r11,0xb
8000ee9e:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000eea2:	18 4b       	or	r11,r12

8000eea4 <__avr32_f64_sub_round>:
8000eea4:	fc 17 80 00 	movh	r7,0x8000
8000eea8:	ed ba 00 00 	bld	r10,0x0
8000eeac:	f7 b7 01 ff 	subne	r7,-1
8000eeb0:	0e 39       	cp.w	r9,r7
8000eeb2:	5f 29       	srhs	r9
8000eeb4:	12 0a       	add	r10,r9
8000eeb6:	5c 0b       	acr	r11
8000eeb8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000eebc <__avr32_f64_sub_opL_subnormal>:
8000eebc:	ab 79       	lsl	r9,0xb
8000eebe:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000eec2:	ab 78       	lsl	r8,0xb
8000eec4:	f3 e8 10 0e 	or	lr,r9,r8
8000eec8:	f9 b6 01 01 	movne	r6,1
8000eecc:	ee 0e 11 00 	rsub	lr,r7,0
8000eed0:	f9 b7 00 01 	moveq	r7,1
8000eed4:	ef bb 00 1f 	bst	r11,0x1f
8000eed8:	f7 ea 10 0e 	or	lr,r11,r10
8000eedc:	f9 b7 00 00 	moveq	r7,0
8000eee0:	cb 0b       	rjmp	8000ee40 <__avr32_f64_sub_opL_subnormal_done>

8000eee2 <__avr32_f64_sub_opH_nan_or_inf>:
8000eee2:	bf db       	cbr	r11,0x1f
8000eee4:	f7 ea 10 0e 	or	lr,r11,r10
8000eee8:	c0 81       	brne	8000eef8 <__avr32_f64_sub_return_nan>
8000eeea:	e0 46 07 ff 	cp.w	r6,2047
8000eeee:	c0 50       	breq	8000eef8 <__avr32_f64_sub_return_nan>
8000eef0:	f9 e7 11 4b 	or	r11,r12,r7<<0x14
8000eef4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000eef8 <__avr32_f64_sub_return_nan>:
8000eef8:	3f fa       	mov	r10,-1
8000eefa:	3f fb       	mov	r11,-1
8000eefc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000ef00 <__avr32_f64_sub_subnormal_result>:
8000ef00:	5c 37       	neg	r7
8000ef02:	2f f7       	sub	r7,-1
8000ef04:	f1 b7 04 c0 	satu	r7,0x6
8000ef08:	e0 47 00 20 	cp.w	r7,32
8000ef0c:	c1 14       	brge	8000ef2e <__avr32_f64_sub_subnormal_result+0x2e>
8000ef0e:	ee 08 11 20 	rsub	r8,r7,32
8000ef12:	f4 08 09 49 	lsl	r9,r10,r8
8000ef16:	5f 16       	srne	r6
8000ef18:	f4 07 0a 4a 	lsr	r10,r10,r7
8000ef1c:	0c 4a       	or	r10,r6
8000ef1e:	f6 08 09 49 	lsl	r9,r11,r8
8000ef22:	f5 e9 10 0a 	or	r10,r10,r9
8000ef26:	f4 07 0a 4b 	lsr	r11,r10,r7
8000ef2a:	30 07       	mov	r7,0
8000ef2c:	cb 3b       	rjmp	8000ee92 <__avr32_f64_sub_longnormalize_done>
8000ef2e:	ee 08 11 40 	rsub	r8,r7,64
8000ef32:	f6 08 09 49 	lsl	r9,r11,r8
8000ef36:	14 49       	or	r9,r10
8000ef38:	5f 16       	srne	r6
8000ef3a:	f6 07 0a 4a 	lsr	r10,r11,r7
8000ef3e:	0c 4a       	or	r10,r6
8000ef40:	30 0b       	mov	r11,0
8000ef42:	30 07       	mov	r7,0
8000ef44:	ca 7b       	rjmp	8000ee92 <__avr32_f64_sub_longnormalize_done>
8000ef46:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000ef4a <__avr32_f64_sub_longshift>:
8000ef4a:	f1 b6 04 c0 	satu	r6,0x6
8000ef4e:	f0 0e 17 00 	moveq	lr,r8
8000ef52:	c0 40       	breq	8000ef5a <__avr32_f64_sub_longshift+0x10>
8000ef54:	f2 05 09 4e 	lsl	lr,r9,r5
8000ef58:	10 4e       	or	lr,r8
8000ef5a:	f2 06 0a 48 	lsr	r8,r9,r6
8000ef5e:	30 09       	mov	r9,0
8000ef60:	58 0e       	cp.w	lr,0
8000ef62:	5f 1e       	srne	lr
8000ef64:	1c 48       	or	r8,lr
8000ef66:	c8 3b       	rjmp	8000ee6c <__avr32_f64_sub_shift_done>

8000ef68 <__avr32_f64_sub_longnormalize>:
8000ef68:	f4 06 12 00 	clz	r6,r10
8000ef6c:	f9 b7 03 00 	movlo	r7,0
8000ef70:	f9 b6 03 00 	movlo	r6,0
8000ef74:	f9 bc 03 00 	movlo	r12,0
8000ef78:	f7 b6 02 e0 	subhs	r6,-32
8000ef7c:	f4 06 09 4b 	lsl	r11,r10,r6
8000ef80:	30 0a       	mov	r10,0
8000ef82:	0c 17       	sub	r7,r6
8000ef84:	fe 9a ff be 	brle	8000ef00 <__avr32_f64_sub_subnormal_result>
8000ef88:	c8 5b       	rjmp	8000ee92 <__avr32_f64_sub_longnormalize_done>
8000ef8a:	d7 03       	nop

8000ef8c <__avr32_f64_add_from_sub>:
8000ef8c:	ee 19 80 00 	eorh	r9,0x8000

8000ef90 <__avr32_f64_add>:
8000ef90:	f7 e9 20 0c 	eor	r12,r11,r9
8000ef94:	fe 96 ff 2e 	brmi	8000edf0 <__avr32_f64_sub_from_add>
8000ef98:	eb cd 40 e0 	pushm	r5-r7,lr
8000ef9c:	16 9c       	mov	r12,r11
8000ef9e:	e6 1c 80 00 	andh	r12,0x8000,COH
8000efa2:	bf db       	cbr	r11,0x1f
8000efa4:	bf d9       	cbr	r9,0x1f
8000efa6:	12 3b       	cp.w	r11,r9
8000efa8:	c0 72       	brcc	8000efb6 <__avr32_f64_add+0x26>
8000efaa:	16 97       	mov	r7,r11
8000efac:	12 9b       	mov	r11,r9
8000efae:	0e 99       	mov	r9,r7
8000efb0:	14 97       	mov	r7,r10
8000efb2:	10 9a       	mov	r10,r8
8000efb4:	0e 98       	mov	r8,r7
8000efb6:	30 0e       	mov	lr,0
8000efb8:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000efbc:	f7 db c0 14 	bfextu	r11,r11,0x0,0x14
8000efc0:	b5 ab       	sbr	r11,0x14
8000efc2:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000efc6:	c6 20       	breq	8000f08a <__avr32_f64_add_op2_subnormal>
8000efc8:	f3 d9 c0 14 	bfextu	r9,r9,0x0,0x14
8000efcc:	b5 a9       	sbr	r9,0x14
8000efce:	e0 47 07 ff 	cp.w	r7,2047
8000efd2:	c2 80       	breq	8000f022 <__avr32_f64_add_opH_nan_or_inf>
8000efd4:	0e 26       	rsub	r6,r7
8000efd6:	c1 20       	breq	8000effa <__avr32_f64_add_shift_done>
8000efd8:	e0 46 00 36 	cp.w	r6,54
8000efdc:	c1 52       	brcc	8000f006 <__avr32_f64_add_res_of_done>
8000efde:	ec 05 11 20 	rsub	r5,r6,32
8000efe2:	e0 46 00 20 	cp.w	r6,32
8000efe6:	c3 52       	brcc	8000f050 <__avr32_f64_add_longshift>
8000efe8:	f0 05 09 4e 	lsl	lr,r8,r5
8000efec:	f2 05 09 45 	lsl	r5,r9,r5
8000eff0:	f0 06 0a 48 	lsr	r8,r8,r6
8000eff4:	f2 06 0a 49 	lsr	r9,r9,r6
8000eff8:	0a 48       	or	r8,r5

8000effa <__avr32_f64_add_shift_done>:
8000effa:	10 0a       	add	r10,r8
8000effc:	f6 09 00 4b 	adc	r11,r11,r9
8000f000:	ed bb 00 15 	bld	r11,0x15
8000f004:	c3 40       	breq	8000f06c <__avr32_f64_add_res_of>

8000f006 <__avr32_f64_add_res_of_done>:
8000f006:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000f00a:	18 4b       	or	r11,r12

8000f00c <__avr32_f64_add_round>:
8000f00c:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
8000f010:	18 4e       	or	lr,r12
8000f012:	ee 1e 80 00 	eorh	lr,0x8000
8000f016:	f1 be 04 20 	satu	lr,0x1
8000f01a:	1c 0a       	add	r10,lr
8000f01c:	5c 0b       	acr	r11
8000f01e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000f022 <__avr32_f64_add_opH_nan_or_inf>:
8000f022:	b5 cb       	cbr	r11,0x14
8000f024:	f7 ea 10 0e 	or	lr,r11,r10
8000f028:	c1 01       	brne	8000f048 <__avr32_f64_add_return_nan>
8000f02a:	e0 46 07 ff 	cp.w	r6,2047
8000f02e:	c0 30       	breq	8000f034 <__avr32_f64_add_opL_nan_or_inf>
8000f030:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000f034 <__avr32_f64_add_opL_nan_or_inf>:
8000f034:	b5 c9       	cbr	r9,0x14
8000f036:	f3 e8 10 0e 	or	lr,r9,r8
8000f03a:	c0 71       	brne	8000f048 <__avr32_f64_add_return_nan>
8000f03c:	30 0a       	mov	r10,0
8000f03e:	fc 1b 7f f0 	movh	r11,0x7ff0
8000f042:	18 4b       	or	r11,r12
8000f044:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000f048 <__avr32_f64_add_return_nan>:
8000f048:	3f fa       	mov	r10,-1
8000f04a:	3f fb       	mov	r11,-1
8000f04c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000f050 <__avr32_f64_add_longshift>:
8000f050:	f1 b6 04 c0 	satu	r6,0x6
8000f054:	f0 0e 17 00 	moveq	lr,r8
8000f058:	c0 60       	breq	8000f064 <__avr32_f64_add_longshift+0x14>
8000f05a:	f2 05 09 4e 	lsl	lr,r9,r5
8000f05e:	58 08       	cp.w	r8,0
8000f060:	5f 18       	srne	r8
8000f062:	10 4e       	or	lr,r8
8000f064:	f2 06 0a 48 	lsr	r8,r9,r6
8000f068:	30 09       	mov	r9,0
8000f06a:	cc 8b       	rjmp	8000effa <__avr32_f64_add_shift_done>

8000f06c <__avr32_f64_add_res_of>:
8000f06c:	fd ee 10 1e 	or	lr,lr,lr<<0x1
8000f070:	a1 9b       	lsr	r11,0x1
8000f072:	5d 0a       	ror	r10
8000f074:	5d 0e       	ror	lr
8000f076:	2f f7       	sub	r7,-1
8000f078:	e0 47 07 ff 	cp.w	r7,2047
8000f07c:	f9 ba 00 00 	moveq	r10,0
8000f080:	f9 bb 00 00 	moveq	r11,0
8000f084:	f9 be 00 00 	moveq	lr,0
8000f088:	cb fb       	rjmp	8000f006 <__avr32_f64_add_res_of_done>

8000f08a <__avr32_f64_add_op2_subnormal>:
8000f08a:	30 16       	mov	r6,1
8000f08c:	58 07       	cp.w	r7,0
8000f08e:	ca 01       	brne	8000efce <__avr32_f64_add+0x3e>
8000f090:	b5 cb       	cbr	r11,0x14
8000f092:	10 0a       	add	r10,r8
8000f094:	f6 09 00 4b 	adc	r11,r11,r9
8000f098:	18 4b       	or	r11,r12
8000f09a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000f09e:	d7 03       	nop

8000f0a0 <__avr32_f64_to_u32>:
8000f0a0:	58 0b       	cp.w	r11,0
8000f0a2:	5e 6d       	retmi	0

8000f0a4 <__avr32_f64_to_s32>:
8000f0a4:	f6 0c 15 01 	lsl	r12,r11,0x1
8000f0a8:	b5 9c       	lsr	r12,0x15
8000f0aa:	e0 2c 03 ff 	sub	r12,1023
8000f0ae:	5e 3d       	retlo	0
8000f0b0:	f8 0c 11 1f 	rsub	r12,r12,31
8000f0b4:	16 99       	mov	r9,r11
8000f0b6:	ab 7b       	lsl	r11,0xb
8000f0b8:	bf bb       	sbr	r11,0x1f
8000f0ba:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000f0be:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000f0c2:	a1 79       	lsl	r9,0x1
8000f0c4:	5e 2b       	reths	r11
8000f0c6:	5c 3b       	neg	r11
8000f0c8:	5e fb       	retal	r11

8000f0ca <__avr32_u32_to_f64>:
8000f0ca:	f8 cb 00 00 	sub	r11,r12,0
8000f0ce:	30 0c       	mov	r12,0
8000f0d0:	c0 38       	rjmp	8000f0d6 <__avr32_s32_to_f64+0x4>

8000f0d2 <__avr32_s32_to_f64>:
8000f0d2:	18 9b       	mov	r11,r12
8000f0d4:	5c 4b       	abs	r11
8000f0d6:	30 0a       	mov	r10,0
8000f0d8:	5e 0b       	reteq	r11
8000f0da:	d4 01       	pushm	lr
8000f0dc:	e0 69 04 1e 	mov	r9,1054
8000f0e0:	f6 08 12 00 	clz	r8,r11
8000f0e4:	c1 70       	breq	8000f112 <__avr32_s32_to_f64+0x40>
8000f0e6:	c0 c3       	brcs	8000f0fe <__avr32_s32_to_f64+0x2c>
8000f0e8:	f0 0e 11 20 	rsub	lr,r8,32
8000f0ec:	f6 08 09 4b 	lsl	r11,r11,r8
8000f0f0:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000f0f4:	1c 4b       	or	r11,lr
8000f0f6:	f4 08 09 4a 	lsl	r10,r10,r8
8000f0fa:	10 19       	sub	r9,r8
8000f0fc:	c0 b8       	rjmp	8000f112 <__avr32_s32_to_f64+0x40>
8000f0fe:	f4 08 12 00 	clz	r8,r10
8000f102:	f9 b8 03 00 	movlo	r8,0
8000f106:	f7 b8 02 e0 	subhs	r8,-32
8000f10a:	f4 08 09 4b 	lsl	r11,r10,r8
8000f10e:	30 0a       	mov	r10,0
8000f110:	10 19       	sub	r9,r8
8000f112:	58 09       	cp.w	r9,0
8000f114:	e0 89 00 30 	brgt	8000f174 <__avr32_s32_to_f64+0xa2>
8000f118:	5c 39       	neg	r9
8000f11a:	2f f9       	sub	r9,-1
8000f11c:	e0 49 00 36 	cp.w	r9,54
8000f120:	c0 43       	brcs	8000f128 <__avr32_s32_to_f64+0x56>
8000f122:	30 0b       	mov	r11,0
8000f124:	30 0a       	mov	r10,0
8000f126:	c2 68       	rjmp	8000f172 <__avr32_s32_to_f64+0xa0>
8000f128:	2f 69       	sub	r9,-10
8000f12a:	f2 08 11 20 	rsub	r8,r9,32
8000f12e:	e0 49 00 20 	cp.w	r9,32
8000f132:	c0 b2       	brcc	8000f148 <__avr32_s32_to_f64+0x76>
8000f134:	f4 08 09 4e 	lsl	lr,r10,r8
8000f138:	f6 08 09 48 	lsl	r8,r11,r8
8000f13c:	f4 09 0a 4a 	lsr	r10,r10,r9
8000f140:	f6 09 0a 4b 	lsr	r11,r11,r9
8000f144:	10 4b       	or	r11,r8
8000f146:	c0 88       	rjmp	8000f156 <__avr32_s32_to_f64+0x84>
8000f148:	f6 08 09 4e 	lsl	lr,r11,r8
8000f14c:	14 4e       	or	lr,r10
8000f14e:	16 9a       	mov	r10,r11
8000f150:	30 0b       	mov	r11,0
8000f152:	f4 09 0a 4a 	lsr	r10,r10,r9
8000f156:	ed ba 00 00 	bld	r10,0x0
8000f15a:	c0 92       	brcc	8000f16c <__avr32_s32_to_f64+0x9a>
8000f15c:	1c 7e       	tst	lr,lr
8000f15e:	c0 41       	brne	8000f166 <__avr32_s32_to_f64+0x94>
8000f160:	ed ba 00 01 	bld	r10,0x1
8000f164:	c0 42       	brcc	8000f16c <__avr32_s32_to_f64+0x9a>
8000f166:	2f fa       	sub	r10,-1
8000f168:	f7 bb 02 ff 	subhs	r11,-1
8000f16c:	5c fc       	rol	r12
8000f16e:	5d 0b       	ror	r11
8000f170:	5d 0a       	ror	r10
8000f172:	d8 02       	popm	pc
8000f174:	e0 68 03 ff 	mov	r8,1023
8000f178:	ed ba 00 0b 	bld	r10,0xb
8000f17c:	f7 b8 00 ff 	subeq	r8,-1
8000f180:	10 0a       	add	r10,r8
8000f182:	5c 0b       	acr	r11
8000f184:	f7 b9 03 fe 	sublo	r9,-2
8000f188:	e0 49 07 ff 	cp.w	r9,2047
8000f18c:	c0 55       	brlt	8000f196 <__avr32_s32_to_f64+0xc4>
8000f18e:	30 0a       	mov	r10,0
8000f190:	fc 1b ff e0 	movh	r11,0xffe0
8000f194:	c0 c8       	rjmp	8000f1ac <__floatsidf_return_op1>
8000f196:	ed bb 00 1f 	bld	r11,0x1f
8000f19a:	f7 b9 01 01 	subne	r9,1
8000f19e:	ab 9a       	lsr	r10,0xb
8000f1a0:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000f1a4:	a1 7b       	lsl	r11,0x1
8000f1a6:	ab 9b       	lsr	r11,0xb
8000f1a8:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

8000f1ac <__floatsidf_return_op1>:
8000f1ac:	a1 7c       	lsl	r12,0x1
8000f1ae:	5d 0b       	ror	r11
8000f1b0:	d8 02       	popm	pc

8000f1b2 <__avr32_f64_cmp_eq>:
8000f1b2:	10 3a       	cp.w	r10,r8
8000f1b4:	f2 0b 13 00 	cpc	r11,r9
8000f1b8:	c0 80       	breq	8000f1c8 <__avr32_f64_cmp_eq+0x16>
8000f1ba:	a1 7b       	lsl	r11,0x1
8000f1bc:	a1 79       	lsl	r9,0x1
8000f1be:	14 4b       	or	r11,r10
8000f1c0:	12 4b       	or	r11,r9
8000f1c2:	10 4b       	or	r11,r8
8000f1c4:	5e 0f       	reteq	1
8000f1c6:	5e fd       	retal	0
8000f1c8:	a1 7b       	lsl	r11,0x1
8000f1ca:	fc 1c ff e0 	movh	r12,0xffe0
8000f1ce:	58 0a       	cp.w	r10,0
8000f1d0:	f8 0b 13 00 	cpc	r11,r12
8000f1d4:	5e 8f       	retls	1
8000f1d6:	5e fd       	retal	0

8000f1d8 <__avr32_f64_cmp_ge>:
8000f1d8:	1a de       	st.w	--sp,lr
8000f1da:	1a d7       	st.w	--sp,r7
8000f1dc:	a1 7b       	lsl	r11,0x1
8000f1de:	5f 3c       	srlo	r12
8000f1e0:	a1 79       	lsl	r9,0x1
8000f1e2:	5f 37       	srlo	r7
8000f1e4:	5c fc       	rol	r12
8000f1e6:	fc 1e ff e0 	movh	lr,0xffe0
8000f1ea:	58 0a       	cp.w	r10,0
8000f1ec:	fc 0b 13 00 	cpc	r11,lr
8000f1f0:	e0 8b 00 1d 	brhi	8000f22a <__avr32_f64_cmp_ge+0x52>
8000f1f4:	58 08       	cp.w	r8,0
8000f1f6:	fc 09 13 00 	cpc	r9,lr
8000f1fa:	e0 8b 00 18 	brhi	8000f22a <__avr32_f64_cmp_ge+0x52>
8000f1fe:	58 0b       	cp.w	r11,0
8000f200:	f5 ba 00 00 	subfeq	r10,0
8000f204:	c1 50       	breq	8000f22e <__avr32_f64_cmp_ge+0x56>
8000f206:	1b 07       	ld.w	r7,sp++
8000f208:	1b 0e       	ld.w	lr,sp++
8000f20a:	58 3c       	cp.w	r12,3
8000f20c:	c0 a0       	breq	8000f220 <__avr32_f64_cmp_ge+0x48>
8000f20e:	58 1c       	cp.w	r12,1
8000f210:	c0 33       	brcs	8000f216 <__avr32_f64_cmp_ge+0x3e>
8000f212:	5e 0f       	reteq	1
8000f214:	5e 1d       	retne	0
8000f216:	10 3a       	cp.w	r10,r8
8000f218:	f2 0b 13 00 	cpc	r11,r9
8000f21c:	5e 2f       	reths	1
8000f21e:	5e 3d       	retlo	0
8000f220:	14 38       	cp.w	r8,r10
8000f222:	f6 09 13 00 	cpc	r9,r11
8000f226:	5e 2f       	reths	1
8000f228:	5e 3d       	retlo	0
8000f22a:	1b 07       	ld.w	r7,sp++
8000f22c:	d8 0a       	popm	pc,r12=0
8000f22e:	58 17       	cp.w	r7,1
8000f230:	5f 0c       	sreq	r12
8000f232:	58 09       	cp.w	r9,0
8000f234:	f5 b8 00 00 	subfeq	r8,0
8000f238:	1b 07       	ld.w	r7,sp++
8000f23a:	1b 0e       	ld.w	lr,sp++
8000f23c:	5e 0f       	reteq	1
8000f23e:	5e fc       	retal	r12

8000f240 <__avr32_f64_cmp_lt>:
8000f240:	1a de       	st.w	--sp,lr
8000f242:	1a d7       	st.w	--sp,r7
8000f244:	a1 7b       	lsl	r11,0x1
8000f246:	5f 3c       	srlo	r12
8000f248:	a1 79       	lsl	r9,0x1
8000f24a:	5f 37       	srlo	r7
8000f24c:	5c fc       	rol	r12
8000f24e:	fc 1e ff e0 	movh	lr,0xffe0
8000f252:	58 0a       	cp.w	r10,0
8000f254:	fc 0b 13 00 	cpc	r11,lr
8000f258:	e0 8b 00 1d 	brhi	8000f292 <__avr32_f64_cmp_lt+0x52>
8000f25c:	58 08       	cp.w	r8,0
8000f25e:	fc 09 13 00 	cpc	r9,lr
8000f262:	e0 8b 00 18 	brhi	8000f292 <__avr32_f64_cmp_lt+0x52>
8000f266:	58 0b       	cp.w	r11,0
8000f268:	f5 ba 00 00 	subfeq	r10,0
8000f26c:	c1 50       	breq	8000f296 <__avr32_f64_cmp_lt+0x56>
8000f26e:	1b 07       	ld.w	r7,sp++
8000f270:	1b 0e       	ld.w	lr,sp++
8000f272:	58 3c       	cp.w	r12,3
8000f274:	c0 a0       	breq	8000f288 <__avr32_f64_cmp_lt+0x48>
8000f276:	58 1c       	cp.w	r12,1
8000f278:	c0 33       	brcs	8000f27e <__avr32_f64_cmp_lt+0x3e>
8000f27a:	5e 0d       	reteq	0
8000f27c:	5e 1f       	retne	1
8000f27e:	10 3a       	cp.w	r10,r8
8000f280:	f2 0b 13 00 	cpc	r11,r9
8000f284:	5e 2d       	reths	0
8000f286:	5e 3f       	retlo	1
8000f288:	14 38       	cp.w	r8,r10
8000f28a:	f6 09 13 00 	cpc	r9,r11
8000f28e:	5e 2d       	reths	0
8000f290:	5e 3f       	retlo	1
8000f292:	1b 07       	ld.w	r7,sp++
8000f294:	d8 0a       	popm	pc,r12=0
8000f296:	58 17       	cp.w	r7,1
8000f298:	5f 1c       	srne	r12
8000f29a:	58 09       	cp.w	r9,0
8000f29c:	f5 b8 00 00 	subfeq	r8,0
8000f2a0:	1b 07       	ld.w	r7,sp++
8000f2a2:	1b 0e       	ld.w	lr,sp++
8000f2a4:	5e 0d       	reteq	0
8000f2a6:	5e fc       	retal	r12

8000f2a8 <__avr32_f64_div>:
8000f2a8:	eb cd 40 ff 	pushm	r0-r7,lr
8000f2ac:	f7 e9 20 0e 	eor	lr,r11,r9
8000f2b0:	f6 07 16 14 	lsr	r7,r11,0x14
8000f2b4:	a9 7b       	lsl	r11,0x9
8000f2b6:	f7 ea 13 7b 	or	r11,r11,r10>>0x17
8000f2ba:	a9 7a       	lsl	r10,0x9
8000f2bc:	bd bb       	sbr	r11,0x1d
8000f2be:	e4 1b 3f ff 	andh	r11,0x3fff
8000f2c2:	ab d7       	cbr	r7,0xb
8000f2c4:	e0 80 00 cc 	breq	8000f45c <__avr32_f64_div_round_subnormal+0x54>
8000f2c8:	e0 47 07 ff 	cp.w	r7,2047
8000f2cc:	e0 84 00 b5 	brge	8000f436 <__avr32_f64_div_round_subnormal+0x2e>
8000f2d0:	f2 06 16 14 	lsr	r6,r9,0x14
8000f2d4:	a9 79       	lsl	r9,0x9
8000f2d6:	f3 e8 13 79 	or	r9,r9,r8>>0x17
8000f2da:	a9 78       	lsl	r8,0x9
8000f2dc:	bd b9       	sbr	r9,0x1d
8000f2de:	e4 19 3f ff 	andh	r9,0x3fff
8000f2e2:	ab d6       	cbr	r6,0xb
8000f2e4:	e0 80 00 e2 	breq	8000f4a8 <__avr32_f64_div_round_subnormal+0xa0>
8000f2e8:	e0 46 07 ff 	cp.w	r6,2047
8000f2ec:	e0 84 00 b2 	brge	8000f450 <__avr32_f64_div_round_subnormal+0x48>
8000f2f0:	0c 17       	sub	r7,r6
8000f2f2:	fe 37 fc 01 	sub	r7,-1023
8000f2f6:	fc 1c 80 00 	movh	r12,0x8000
8000f2fa:	f8 03 16 01 	lsr	r3,r12,0x1
8000f2fe:	e9 d9 c3 62 	bfextu	r4,r9,0x1b,0x2
8000f302:	5c d4       	com	r4
8000f304:	e7 d4 d3 82 	bfins	r3,r4,0x1c,0x2
8000f308:	e6 09 06 44 	mulu.d	r4,r3,r9
8000f30c:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000f310:	e6 05 06 44 	mulu.d	r4,r3,r5
8000f314:	ea 03 15 02 	lsl	r3,r5,0x2
8000f318:	e6 09 06 44 	mulu.d	r4,r3,r9
8000f31c:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000f320:	e6 05 06 44 	mulu.d	r4,r3,r5
8000f324:	ea 03 15 02 	lsl	r3,r5,0x2
8000f328:	e6 09 06 44 	mulu.d	r4,r3,r9
8000f32c:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000f330:	e6 05 06 44 	mulu.d	r4,r3,r5
8000f334:	ea 03 15 02 	lsl	r3,r5,0x2
8000f338:	e6 08 06 40 	mulu.d	r0,r3,r8
8000f33c:	e4 09 07 40 	macu.d	r0,r2,r9
8000f340:	e6 09 06 44 	mulu.d	r4,r3,r9
8000f344:	02 04       	add	r4,r1
8000f346:	5c 05       	acr	r5
8000f348:	a3 65       	lsl	r5,0x2
8000f34a:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000f34e:	a3 64       	lsl	r4,0x2
8000f350:	5c 34       	neg	r4
8000f352:	f8 05 01 45 	sbc	r5,r12,r5
8000f356:	e6 04 06 40 	mulu.d	r0,r3,r4
8000f35a:	e4 05 07 40 	macu.d	r0,r2,r5
8000f35e:	e6 05 06 44 	mulu.d	r4,r3,r5
8000f362:	02 04       	add	r4,r1
8000f364:	5c 05       	acr	r5
8000f366:	ea 03 15 02 	lsl	r3,r5,0x2
8000f36a:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000f36e:	e8 02 15 02 	lsl	r2,r4,0x2
8000f372:	e6 08 06 40 	mulu.d	r0,r3,r8
8000f376:	e4 09 07 40 	macu.d	r0,r2,r9
8000f37a:	e6 09 06 44 	mulu.d	r4,r3,r9
8000f37e:	02 04       	add	r4,r1
8000f380:	5c 05       	acr	r5
8000f382:	a3 65       	lsl	r5,0x2
8000f384:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000f388:	a3 64       	lsl	r4,0x2
8000f38a:	5c 34       	neg	r4
8000f38c:	f8 05 01 45 	sbc	r5,r12,r5
8000f390:	e6 04 06 40 	mulu.d	r0,r3,r4
8000f394:	e4 05 07 40 	macu.d	r0,r2,r5
8000f398:	e6 05 06 44 	mulu.d	r4,r3,r5
8000f39c:	02 04       	add	r4,r1
8000f39e:	5c 05       	acr	r5
8000f3a0:	ea 03 15 02 	lsl	r3,r5,0x2
8000f3a4:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000f3a8:	e8 02 15 02 	lsl	r2,r4,0x2
8000f3ac:	e6 0a 06 40 	mulu.d	r0,r3,r10
8000f3b0:	e4 0b 07 40 	macu.d	r0,r2,r11
8000f3b4:	e6 0b 06 42 	mulu.d	r2,r3,r11
8000f3b8:	02 02       	add	r2,r1
8000f3ba:	5c 03       	acr	r3
8000f3bc:	ed b3 00 1c 	bld	r3,0x1c
8000f3c0:	c0 90       	breq	8000f3d2 <__avr32_f64_div+0x12a>
8000f3c2:	a1 72       	lsl	r2,0x1
8000f3c4:	5c f3       	rol	r3
8000f3c6:	20 17       	sub	r7,1
8000f3c8:	a3 9a       	lsr	r10,0x3
8000f3ca:	f5 eb 11 da 	or	r10,r10,r11<<0x1d
8000f3ce:	a3 9b       	lsr	r11,0x3
8000f3d0:	c0 58       	rjmp	8000f3da <__avr32_f64_div+0x132>
8000f3d2:	a5 8a       	lsr	r10,0x4
8000f3d4:	f5 eb 11 ca 	or	r10,r10,r11<<0x1c
8000f3d8:	a5 8b       	lsr	r11,0x4
8000f3da:	58 07       	cp.w	r7,0
8000f3dc:	e0 8a 00 8b 	brle	8000f4f2 <__avr32_f64_div_res_subnormal>
8000f3e0:	e0 12 ff 00 	andl	r2,0xff00
8000f3e4:	e8 12 00 80 	orl	r2,0x80
8000f3e8:	e6 08 06 40 	mulu.d	r0,r3,r8
8000f3ec:	e4 09 07 40 	macu.d	r0,r2,r9
8000f3f0:	e4 08 06 44 	mulu.d	r4,r2,r8
8000f3f4:	e6 09 06 48 	mulu.d	r8,r3,r9
8000f3f8:	00 05       	add	r5,r0
8000f3fa:	f0 01 00 48 	adc	r8,r8,r1
8000f3fe:	5c 09       	acr	r9
8000f400:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000f404:	58 04       	cp.w	r4,0
8000f406:	5c 25       	cpc	r5

8000f408 <__avr32_f64_div_round_subnormal>:
8000f408:	f4 08 13 00 	cpc	r8,r10
8000f40c:	f6 09 13 00 	cpc	r9,r11
8000f410:	5f 36       	srlo	r6
8000f412:	f8 06 17 00 	moveq	r6,r12
8000f416:	e4 0a 16 08 	lsr	r10,r2,0x8
8000f41a:	f5 e3 11 8a 	or	r10,r10,r3<<0x18
8000f41e:	e6 0b 16 08 	lsr	r11,r3,0x8
8000f422:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000f426:	ed be 00 1f 	bld	lr,0x1f
8000f42a:	ef bb 00 1f 	bst	r11,0x1f
8000f42e:	0c 0a       	add	r10,r6
8000f430:	5c 0b       	acr	r11
8000f432:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000f436:	e4 1b 00 0f 	andh	r11,0xf
8000f43a:	14 4b       	or	r11,r10
8000f43c:	e0 81 00 a7 	brne	8000f58a <__avr32_f64_div_res_subnormal+0x98>
8000f440:	f2 06 16 14 	lsr	r6,r9,0x14
8000f444:	ab d6       	cbr	r6,0xb
8000f446:	e0 46 07 ff 	cp.w	r6,2047
8000f44a:	e0 81 00 a4 	brne	8000f592 <__avr32_f64_div_res_subnormal+0xa0>
8000f44e:	c9 e8       	rjmp	8000f58a <__avr32_f64_div_res_subnormal+0x98>
8000f450:	e4 19 00 0f 	andh	r9,0xf
8000f454:	10 49       	or	r9,r8
8000f456:	e0 81 00 9a 	brne	8000f58a <__avr32_f64_div_res_subnormal+0x98>
8000f45a:	c9 28       	rjmp	8000f57e <__avr32_f64_div_res_subnormal+0x8c>
8000f45c:	a3 7b       	lsl	r11,0x3
8000f45e:	f7 ea 13 db 	or	r11,r11,r10>>0x1d
8000f462:	a3 7a       	lsl	r10,0x3
8000f464:	f5 eb 10 04 	or	r4,r10,r11
8000f468:	e0 80 00 a0 	breq	8000f5a8 <__avr32_f64_div_op1_zero>
8000f46c:	f6 04 12 00 	clz	r4,r11
8000f470:	c1 70       	breq	8000f49e <__avr32_f64_div_round_subnormal+0x96>
8000f472:	c0 c3       	brcs	8000f48a <__avr32_f64_div_round_subnormal+0x82>
8000f474:	e8 05 11 20 	rsub	r5,r4,32
8000f478:	f6 04 09 4b 	lsl	r11,r11,r4
8000f47c:	f4 05 0a 45 	lsr	r5,r10,r5
8000f480:	0a 4b       	or	r11,r5
8000f482:	f4 04 09 4a 	lsl	r10,r10,r4
8000f486:	08 17       	sub	r7,r4
8000f488:	c0 b8       	rjmp	8000f49e <__avr32_f64_div_round_subnormal+0x96>
8000f48a:	f4 04 12 00 	clz	r4,r10
8000f48e:	f9 b4 03 00 	movlo	r4,0
8000f492:	f7 b4 02 e0 	subhs	r4,-32
8000f496:	f4 04 09 4b 	lsl	r11,r10,r4
8000f49a:	30 0a       	mov	r10,0
8000f49c:	08 17       	sub	r7,r4
8000f49e:	a3 8a       	lsr	r10,0x2
8000f4a0:	f5 eb 11 ea 	or	r10,r10,r11<<0x1e
8000f4a4:	a3 8b       	lsr	r11,0x2
8000f4a6:	c1 1b       	rjmp	8000f2c8 <__avr32_f64_div+0x20>
8000f4a8:	a3 79       	lsl	r9,0x3
8000f4aa:	f3 e8 13 d9 	or	r9,r9,r8>>0x1d
8000f4ae:	a3 78       	lsl	r8,0x3
8000f4b0:	f3 e8 10 04 	or	r4,r9,r8
8000f4b4:	c6 f0       	breq	8000f592 <__avr32_f64_div_res_subnormal+0xa0>
8000f4b6:	f2 04 12 00 	clz	r4,r9
8000f4ba:	c1 70       	breq	8000f4e8 <__avr32_f64_div_round_subnormal+0xe0>
8000f4bc:	c0 c3       	brcs	8000f4d4 <__avr32_f64_div_round_subnormal+0xcc>
8000f4be:	e8 05 11 20 	rsub	r5,r4,32
8000f4c2:	f2 04 09 49 	lsl	r9,r9,r4
8000f4c6:	f0 05 0a 45 	lsr	r5,r8,r5
8000f4ca:	0a 49       	or	r9,r5
8000f4cc:	f0 04 09 48 	lsl	r8,r8,r4
8000f4d0:	08 16       	sub	r6,r4
8000f4d2:	c0 b8       	rjmp	8000f4e8 <__avr32_f64_div_round_subnormal+0xe0>
8000f4d4:	f0 04 12 00 	clz	r4,r8
8000f4d8:	f9 b4 03 00 	movlo	r4,0
8000f4dc:	f7 b4 02 e0 	subhs	r4,-32
8000f4e0:	f0 04 09 49 	lsl	r9,r8,r4
8000f4e4:	30 08       	mov	r8,0
8000f4e6:	08 16       	sub	r6,r4
8000f4e8:	a3 88       	lsr	r8,0x2
8000f4ea:	f1 e9 11 e8 	or	r8,r8,r9<<0x1e
8000f4ee:	a3 89       	lsr	r9,0x2
8000f4f0:	cf ca       	rjmp	8000f2e8 <__avr32_f64_div+0x40>

8000f4f2 <__avr32_f64_div_res_subnormal>:
8000f4f2:	5c 37       	neg	r7
8000f4f4:	2f f7       	sub	r7,-1
8000f4f6:	f1 b7 04 c0 	satu	r7,0x6
8000f4fa:	e0 47 00 20 	cp.w	r7,32
8000f4fe:	c1 54       	brge	8000f528 <__avr32_f64_div_res_subnormal+0x36>
8000f500:	ee 06 11 20 	rsub	r6,r7,32
8000f504:	e4 07 0a 42 	lsr	r2,r2,r7
8000f508:	e6 06 09 4c 	lsl	r12,r3,r6
8000f50c:	18 42       	or	r2,r12
8000f50e:	e6 07 0a 43 	lsr	r3,r3,r7
8000f512:	f4 06 09 41 	lsl	r1,r10,r6
8000f516:	f4 07 0a 4a 	lsr	r10,r10,r7
8000f51a:	f6 06 09 4c 	lsl	r12,r11,r6
8000f51e:	18 4a       	or	r10,r12
8000f520:	f6 07 0a 4b 	lsr	r11,r11,r7
8000f524:	30 00       	mov	r0,0
8000f526:	c1 58       	rjmp	8000f550 <__avr32_f64_div_res_subnormal+0x5e>
8000f528:	ee 06 11 20 	rsub	r6,r7,32
8000f52c:	f9 b0 00 00 	moveq	r0,0
8000f530:	f9 bc 00 00 	moveq	r12,0
8000f534:	c0 50       	breq	8000f53e <__avr32_f64_div_res_subnormal+0x4c>
8000f536:	f4 06 09 40 	lsl	r0,r10,r6
8000f53a:	f6 06 09 4c 	lsl	r12,r11,r6
8000f53e:	e6 07 0a 42 	lsr	r2,r3,r7
8000f542:	30 03       	mov	r3,0
8000f544:	f4 07 0a 41 	lsr	r1,r10,r7
8000f548:	18 41       	or	r1,r12
8000f54a:	f6 07 0a 4a 	lsr	r10,r11,r7
8000f54e:	30 0b       	mov	r11,0
8000f550:	e0 12 ff 00 	andl	r2,0xff00
8000f554:	e8 12 00 80 	orl	r2,0x80
8000f558:	e6 08 06 46 	mulu.d	r6,r3,r8
8000f55c:	e4 09 07 46 	macu.d	r6,r2,r9
8000f560:	e4 08 06 44 	mulu.d	r4,r2,r8
8000f564:	e6 09 06 48 	mulu.d	r8,r3,r9
8000f568:	0c 05       	add	r5,r6
8000f56a:	f0 07 00 48 	adc	r8,r8,r7
8000f56e:	5c 09       	acr	r9
8000f570:	30 07       	mov	r7,0
8000f572:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000f576:	00 34       	cp.w	r4,r0
8000f578:	e2 05 13 00 	cpc	r5,r1
8000f57c:	c4 6b       	rjmp	8000f408 <__avr32_f64_div_round_subnormal>
8000f57e:	1c 9b       	mov	r11,lr
8000f580:	e6 1b 80 00 	andh	r11,0x8000,COH
8000f584:	30 0a       	mov	r10,0
8000f586:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000f58a:	3f fb       	mov	r11,-1
8000f58c:	30 0a       	mov	r10,0
8000f58e:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000f592:	f5 eb 10 04 	or	r4,r10,r11
8000f596:	c0 90       	breq	8000f5a8 <__avr32_f64_div_op1_zero>
8000f598:	1c 9b       	mov	r11,lr
8000f59a:	e6 1b 80 00 	andh	r11,0x8000,COH
8000f59e:	ea 1b 7f f0 	orh	r11,0x7ff0
8000f5a2:	30 0a       	mov	r10,0
8000f5a4:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc

8000f5a8 <__avr32_f64_div_op1_zero>:
8000f5a8:	f1 e9 10 15 	or	r5,r8,r9<<0x1
8000f5ac:	ce f0       	breq	8000f58a <__avr32_f64_div_res_subnormal+0x98>
8000f5ae:	e9 d9 c2 8b 	bfextu	r4,r9,0x14,0xb
8000f5b2:	e0 44 07 ff 	cp.w	r4,2047
8000f5b6:	ce 41       	brne	8000f57e <__avr32_f64_div_res_subnormal+0x8c>
8000f5b8:	f1 e9 10 c5 	or	r5,r8,r9<<0xc
8000f5bc:	ce 10       	breq	8000f57e <__avr32_f64_div_res_subnormal+0x8c>
8000f5be:	ce 6b       	rjmp	8000f58a <__avr32_f64_div_res_subnormal+0x98>

8000f5c0 <__avr32_udiv64>:
8000f5c0:	d4 31       	pushm	r0-r7,lr
8000f5c2:	1a 97       	mov	r7,sp
8000f5c4:	20 3d       	sub	sp,12
8000f5c6:	10 9c       	mov	r12,r8
8000f5c8:	12 9e       	mov	lr,r9
8000f5ca:	14 93       	mov	r3,r10
8000f5cc:	58 09       	cp.w	r9,0
8000f5ce:	e0 81 00 bd 	brne	8000f748 <__avr32_udiv64+0x188>
8000f5d2:	16 38       	cp.w	r8,r11
8000f5d4:	e0 88 00 40 	brls	8000f654 <__avr32_udiv64+0x94>
8000f5d8:	f0 08 12 00 	clz	r8,r8
8000f5dc:	c0 d0       	breq	8000f5f6 <__avr32_udiv64+0x36>
8000f5de:	f6 08 09 4b 	lsl	r11,r11,r8
8000f5e2:	f0 09 11 20 	rsub	r9,r8,32
8000f5e6:	f8 08 09 4c 	lsl	r12,r12,r8
8000f5ea:	f4 09 0a 49 	lsr	r9,r10,r9
8000f5ee:	f4 08 09 43 	lsl	r3,r10,r8
8000f5f2:	f3 eb 10 0b 	or	r11,r9,r11
8000f5f6:	f8 0e 16 10 	lsr	lr,r12,0x10
8000f5fa:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000f5fe:	f6 0e 0d 00 	divu	r0,r11,lr
8000f602:	e6 0b 16 10 	lsr	r11,r3,0x10
8000f606:	00 99       	mov	r9,r0
8000f608:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000f60c:	e0 0a 02 48 	mul	r8,r0,r10
8000f610:	10 3b       	cp.w	r11,r8
8000f612:	c0 a2       	brcc	8000f626 <__avr32_udiv64+0x66>
8000f614:	20 19       	sub	r9,1
8000f616:	18 0b       	add	r11,r12
8000f618:	18 3b       	cp.w	r11,r12
8000f61a:	c0 63       	brcs	8000f626 <__avr32_udiv64+0x66>
8000f61c:	10 3b       	cp.w	r11,r8
8000f61e:	f7 b9 03 01 	sublo	r9,1
8000f622:	f7 dc e3 0b 	addcs	r11,r11,r12
8000f626:	f6 08 01 01 	sub	r1,r11,r8
8000f62a:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000f62e:	e2 0e 0d 00 	divu	r0,r1,lr
8000f632:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000f636:	00 98       	mov	r8,r0
8000f638:	e0 0a 02 4a 	mul	r10,r0,r10
8000f63c:	14 33       	cp.w	r3,r10
8000f63e:	c0 82       	brcc	8000f64e <__avr32_udiv64+0x8e>
8000f640:	20 18       	sub	r8,1
8000f642:	18 03       	add	r3,r12
8000f644:	18 33       	cp.w	r3,r12
8000f646:	c0 43       	brcs	8000f64e <__avr32_udiv64+0x8e>
8000f648:	14 33       	cp.w	r3,r10
8000f64a:	f7 b8 03 01 	sublo	r8,1
8000f64e:	f1 e9 11 08 	or	r8,r8,r9<<0x10
8000f652:	cd f8       	rjmp	8000f810 <__avr32_udiv64+0x250>
8000f654:	58 08       	cp.w	r8,0
8000f656:	c0 51       	brne	8000f660 <__avr32_udiv64+0xa0>
8000f658:	30 19       	mov	r9,1
8000f65a:	f2 08 0d 08 	divu	r8,r9,r8
8000f65e:	10 9c       	mov	r12,r8
8000f660:	f8 06 12 00 	clz	r6,r12
8000f664:	c0 41       	brne	8000f66c <__avr32_udiv64+0xac>
8000f666:	18 1b       	sub	r11,r12
8000f668:	30 19       	mov	r9,1
8000f66a:	c4 08       	rjmp	8000f6ea <__avr32_udiv64+0x12a>
8000f66c:	ec 01 11 20 	rsub	r1,r6,32
8000f670:	f4 01 0a 49 	lsr	r9,r10,r1
8000f674:	f8 06 09 4c 	lsl	r12,r12,r6
8000f678:	f6 06 09 48 	lsl	r8,r11,r6
8000f67c:	f6 01 0a 41 	lsr	r1,r11,r1
8000f680:	f3 e8 10 08 	or	r8,r9,r8
8000f684:	f8 03 16 10 	lsr	r3,r12,0x10
8000f688:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000f68c:	e2 03 0d 00 	divu	r0,r1,r3
8000f690:	f0 0b 16 10 	lsr	r11,r8,0x10
8000f694:	00 9e       	mov	lr,r0
8000f696:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000f69a:	e0 05 02 49 	mul	r9,r0,r5
8000f69e:	12 3b       	cp.w	r11,r9
8000f6a0:	c0 a2       	brcc	8000f6b4 <__avr32_udiv64+0xf4>
8000f6a2:	20 1e       	sub	lr,1
8000f6a4:	18 0b       	add	r11,r12
8000f6a6:	18 3b       	cp.w	r11,r12
8000f6a8:	c0 63       	brcs	8000f6b4 <__avr32_udiv64+0xf4>
8000f6aa:	12 3b       	cp.w	r11,r9
8000f6ac:	f7 be 03 01 	sublo	lr,1
8000f6b0:	f7 dc e3 0b 	addcs	r11,r11,r12
8000f6b4:	12 1b       	sub	r11,r9
8000f6b6:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
8000f6ba:	f6 03 0d 02 	divu	r2,r11,r3
8000f6be:	f1 e3 11 08 	or	r8,r8,r3<<0x10
8000f6c2:	04 99       	mov	r9,r2
8000f6c4:	e4 05 02 4b 	mul	r11,r2,r5
8000f6c8:	16 38       	cp.w	r8,r11
8000f6ca:	c0 a2       	brcc	8000f6de <__avr32_udiv64+0x11e>
8000f6cc:	20 19       	sub	r9,1
8000f6ce:	18 08       	add	r8,r12
8000f6d0:	18 38       	cp.w	r8,r12
8000f6d2:	c0 63       	brcs	8000f6de <__avr32_udiv64+0x11e>
8000f6d4:	16 38       	cp.w	r8,r11
8000f6d6:	f7 b9 03 01 	sublo	r9,1
8000f6da:	f1 dc e3 08 	addcs	r8,r8,r12
8000f6de:	f4 06 09 43 	lsl	r3,r10,r6
8000f6e2:	f0 0b 01 0b 	sub	r11,r8,r11
8000f6e6:	f3 ee 11 09 	or	r9,r9,lr<<0x10
8000f6ea:	f8 06 16 10 	lsr	r6,r12,0x10
8000f6ee:	fd dc c0 10 	bfextu	lr,r12,0x0,0x10
8000f6f2:	f6 06 0d 00 	divu	r0,r11,r6
8000f6f6:	e6 0b 16 10 	lsr	r11,r3,0x10
8000f6fa:	00 9a       	mov	r10,r0
8000f6fc:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000f700:	e0 0e 02 48 	mul	r8,r0,lr
8000f704:	10 3b       	cp.w	r11,r8
8000f706:	c0 a2       	brcc	8000f71a <__avr32_udiv64+0x15a>
8000f708:	20 1a       	sub	r10,1
8000f70a:	18 0b       	add	r11,r12
8000f70c:	18 3b       	cp.w	r11,r12
8000f70e:	c0 63       	brcs	8000f71a <__avr32_udiv64+0x15a>
8000f710:	10 3b       	cp.w	r11,r8
8000f712:	f7 ba 03 01 	sublo	r10,1
8000f716:	f7 dc e3 0b 	addcs	r11,r11,r12
8000f71a:	f6 08 01 01 	sub	r1,r11,r8
8000f71e:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000f722:	e2 06 0d 00 	divu	r0,r1,r6
8000f726:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000f72a:	00 98       	mov	r8,r0
8000f72c:	e0 0e 02 4b 	mul	r11,r0,lr
8000f730:	16 33       	cp.w	r3,r11
8000f732:	c0 82       	brcc	8000f742 <__avr32_udiv64+0x182>
8000f734:	20 18       	sub	r8,1
8000f736:	18 03       	add	r3,r12
8000f738:	18 33       	cp.w	r3,r12
8000f73a:	c0 43       	brcs	8000f742 <__avr32_udiv64+0x182>
8000f73c:	16 33       	cp.w	r3,r11
8000f73e:	f7 b8 03 01 	sublo	r8,1
8000f742:	f1 ea 11 08 	or	r8,r8,r10<<0x10
8000f746:	c6 98       	rjmp	8000f818 <__avr32_udiv64+0x258>
8000f748:	16 39       	cp.w	r9,r11
8000f74a:	e0 8b 00 65 	brhi	8000f814 <__avr32_udiv64+0x254>
8000f74e:	f2 09 12 00 	clz	r9,r9
8000f752:	c0 b1       	brne	8000f768 <__avr32_udiv64+0x1a8>
8000f754:	10 3a       	cp.w	r10,r8
8000f756:	5f 2a       	srhs	r10
8000f758:	1c 3b       	cp.w	r11,lr
8000f75a:	5f b8       	srhi	r8
8000f75c:	10 4a       	or	r10,r8
8000f75e:	f2 0a 18 00 	cp.b	r10,r9
8000f762:	c5 90       	breq	8000f814 <__avr32_udiv64+0x254>
8000f764:	30 18       	mov	r8,1
8000f766:	c5 98       	rjmp	8000f818 <__avr32_udiv64+0x258>
8000f768:	f0 09 09 46 	lsl	r6,r8,r9
8000f76c:	f2 03 11 20 	rsub	r3,r9,32
8000f770:	fc 09 09 4e 	lsl	lr,lr,r9
8000f774:	f0 03 0a 48 	lsr	r8,r8,r3
8000f778:	f6 09 09 4c 	lsl	r12,r11,r9
8000f77c:	f4 03 0a 42 	lsr	r2,r10,r3
8000f780:	ef 46 ff f4 	st.w	r7[-12],r6
8000f784:	f6 03 0a 43 	lsr	r3,r11,r3
8000f788:	18 42       	or	r2,r12
8000f78a:	f1 ee 10 0c 	or	r12,r8,lr
8000f78e:	f8 01 16 10 	lsr	r1,r12,0x10
8000f792:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000f796:	e6 01 0d 04 	divu	r4,r3,r1
8000f79a:	e4 03 16 10 	lsr	r3,r2,0x10
8000f79e:	08 9e       	mov	lr,r4
8000f7a0:	e7 e5 11 03 	or	r3,r3,r5<<0x10
8000f7a4:	e8 06 02 48 	mul	r8,r4,r6
8000f7a8:	10 33       	cp.w	r3,r8
8000f7aa:	c0 a2       	brcc	8000f7be <__avr32_udiv64+0x1fe>
8000f7ac:	20 1e       	sub	lr,1
8000f7ae:	18 03       	add	r3,r12
8000f7b0:	18 33       	cp.w	r3,r12
8000f7b2:	c0 63       	brcs	8000f7be <__avr32_udiv64+0x1fe>
8000f7b4:	10 33       	cp.w	r3,r8
8000f7b6:	f7 be 03 01 	sublo	lr,1
8000f7ba:	e7 dc e3 03 	addcs	r3,r3,r12
8000f7be:	10 13       	sub	r3,r8
8000f7c0:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
8000f7c4:	e6 01 0d 00 	divu	r0,r3,r1
8000f7c8:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000f7cc:	00 98       	mov	r8,r0
8000f7ce:	e0 06 02 46 	mul	r6,r0,r6
8000f7d2:	0c 3b       	cp.w	r11,r6
8000f7d4:	c0 a2       	brcc	8000f7e8 <__avr32_udiv64+0x228>
8000f7d6:	20 18       	sub	r8,1
8000f7d8:	18 0b       	add	r11,r12
8000f7da:	18 3b       	cp.w	r11,r12
8000f7dc:	c0 63       	brcs	8000f7e8 <__avr32_udiv64+0x228>
8000f7de:	0c 3b       	cp.w	r11,r6
8000f7e0:	f7 dc e3 0b 	addcs	r11,r11,r12
8000f7e4:	f7 b8 03 01 	sublo	r8,1
8000f7e8:	f1 ee 11 08 	or	r8,r8,lr<<0x10
8000f7ec:	ee f4 ff f4 	ld.w	r4,r7[-12]
8000f7f0:	0c 1b       	sub	r11,r6
8000f7f2:	f0 04 06 42 	mulu.d	r2,r8,r4
8000f7f6:	06 95       	mov	r5,r3
8000f7f8:	16 35       	cp.w	r5,r11
8000f7fa:	e0 8b 00 0a 	brhi	8000f80e <__avr32_udiv64+0x24e>
8000f7fe:	5f 0b       	sreq	r11
8000f800:	f4 09 09 49 	lsl	r9,r10,r9
8000f804:	12 32       	cp.w	r2,r9
8000f806:	5f b9       	srhi	r9
8000f808:	f7 e9 00 09 	and	r9,r11,r9
8000f80c:	c0 60       	breq	8000f818 <__avr32_udiv64+0x258>
8000f80e:	20 18       	sub	r8,1
8000f810:	30 09       	mov	r9,0
8000f812:	c0 38       	rjmp	8000f818 <__avr32_udiv64+0x258>
8000f814:	30 09       	mov	r9,0
8000f816:	12 98       	mov	r8,r9
8000f818:	10 9a       	mov	r10,r8
8000f81a:	12 93       	mov	r3,r9
8000f81c:	10 92       	mov	r2,r8
8000f81e:	12 9b       	mov	r11,r9
8000f820:	2f dd       	sub	sp,-12
8000f822:	d8 32       	popm	r0-r7,pc

8000f824 <__avr32_umod64>:
8000f824:	d4 31       	pushm	r0-r7,lr
8000f826:	1a 97       	mov	r7,sp
8000f828:	20 3d       	sub	sp,12
8000f82a:	10 9c       	mov	r12,r8
8000f82c:	12 95       	mov	r5,r9
8000f82e:	14 9e       	mov	lr,r10
8000f830:	16 91       	mov	r1,r11
8000f832:	16 96       	mov	r6,r11
8000f834:	58 09       	cp.w	r9,0
8000f836:	e0 81 00 81 	brne	8000f938 <__avr32_umod64+0x114>
8000f83a:	16 38       	cp.w	r8,r11
8000f83c:	e0 88 00 12 	brls	8000f860 <__avr32_umod64+0x3c>
8000f840:	f0 08 12 00 	clz	r8,r8
8000f844:	c4 e0       	breq	8000f8e0 <__avr32_umod64+0xbc>
8000f846:	f6 08 09 46 	lsl	r6,r11,r8
8000f84a:	f8 08 09 4c 	lsl	r12,r12,r8
8000f84e:	f0 0b 11 20 	rsub	r11,r8,32
8000f852:	f4 08 09 4e 	lsl	lr,r10,r8
8000f856:	f4 0b 0a 4b 	lsr	r11,r10,r11
8000f85a:	f7 e6 10 06 	or	r6,r11,r6
8000f85e:	c4 18       	rjmp	8000f8e0 <__avr32_umod64+0xbc>
8000f860:	58 08       	cp.w	r8,0
8000f862:	c0 51       	brne	8000f86c <__avr32_umod64+0x48>
8000f864:	30 19       	mov	r9,1
8000f866:	f2 08 0d 08 	divu	r8,r9,r8
8000f86a:	10 9c       	mov	r12,r8
8000f86c:	f8 08 12 00 	clz	r8,r12
8000f870:	c0 31       	brne	8000f876 <__avr32_umod64+0x52>
8000f872:	18 16       	sub	r6,r12
8000f874:	c3 68       	rjmp	8000f8e0 <__avr32_umod64+0xbc>
8000f876:	f0 03 11 20 	rsub	r3,r8,32
8000f87a:	f4 03 0a 4b 	lsr	r11,r10,r3
8000f87e:	f8 08 09 4c 	lsl	r12,r12,r8
8000f882:	ec 08 09 49 	lsl	r9,r6,r8
8000f886:	ec 03 0a 43 	lsr	r3,r6,r3
8000f88a:	f7 e9 10 09 	or	r9,r11,r9
8000f88e:	f8 05 16 10 	lsr	r5,r12,0x10
8000f892:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000f896:	e6 05 0d 02 	divu	r2,r3,r5
8000f89a:	f2 0e 16 10 	lsr	lr,r9,0x10
8000f89e:	ec 02 02 4b 	mul	r11,r6,r2
8000f8a2:	fd e3 11 0e 	or	lr,lr,r3<<0x10
8000f8a6:	16 3e       	cp.w	lr,r11
8000f8a8:	c0 72       	brcc	8000f8b6 <__avr32_umod64+0x92>
8000f8aa:	18 0e       	add	lr,r12
8000f8ac:	18 3e       	cp.w	lr,r12
8000f8ae:	c0 43       	brcs	8000f8b6 <__avr32_umod64+0x92>
8000f8b0:	16 3e       	cp.w	lr,r11
8000f8b2:	fd dc e3 0e 	addcs	lr,lr,r12
8000f8b6:	fc 0b 01 03 	sub	r3,lr,r11
8000f8ba:	f3 d9 c0 10 	bfextu	r9,r9,0x0,0x10
8000f8be:	e6 05 0d 02 	divu	r2,r3,r5
8000f8c2:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000f8c6:	a5 36       	mul	r6,r2
8000f8c8:	0c 39       	cp.w	r9,r6
8000f8ca:	c0 72       	brcc	8000f8d8 <__avr32_umod64+0xb4>
8000f8cc:	18 09       	add	r9,r12
8000f8ce:	18 39       	cp.w	r9,r12
8000f8d0:	c0 43       	brcs	8000f8d8 <__avr32_umod64+0xb4>
8000f8d2:	0c 39       	cp.w	r9,r6
8000f8d4:	f3 dc e3 09 	addcs	r9,r9,r12
8000f8d8:	f2 06 01 06 	sub	r6,r9,r6
8000f8dc:	f4 08 09 4e 	lsl	lr,r10,r8
8000f8e0:	f8 0a 16 10 	lsr	r10,r12,0x10
8000f8e4:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000f8e8:	ec 0a 0d 02 	divu	r2,r6,r10
8000f8ec:	fc 09 16 10 	lsr	r9,lr,0x10
8000f8f0:	ea 02 02 4b 	mul	r11,r5,r2
8000f8f4:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000f8f8:	16 39       	cp.w	r9,r11
8000f8fa:	c0 72       	brcc	8000f908 <__avr32_umod64+0xe4>
8000f8fc:	18 09       	add	r9,r12
8000f8fe:	18 39       	cp.w	r9,r12
8000f900:	c0 43       	brcs	8000f908 <__avr32_umod64+0xe4>
8000f902:	16 39       	cp.w	r9,r11
8000f904:	f3 dc e3 09 	addcs	r9,r9,r12
8000f908:	f2 0b 01 0b 	sub	r11,r9,r11
8000f90c:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000f910:	f6 0a 0d 0a 	divu	r10,r11,r10
8000f914:	fd eb 11 0e 	or	lr,lr,r11<<0x10
8000f918:	ea 0a 02 4a 	mul	r10,r5,r10
8000f91c:	14 3e       	cp.w	lr,r10
8000f91e:	c0 72       	brcc	8000f92c <__avr32_umod64+0x108>
8000f920:	18 0e       	add	lr,r12
8000f922:	18 3e       	cp.w	lr,r12
8000f924:	c0 43       	brcs	8000f92c <__avr32_umod64+0x108>
8000f926:	14 3e       	cp.w	lr,r10
8000f928:	fd dc e3 0e 	addcs	lr,lr,r12
8000f92c:	fc 0a 01 0a 	sub	r10,lr,r10
8000f930:	30 0b       	mov	r11,0
8000f932:	f4 08 0a 4a 	lsr	r10,r10,r8
8000f936:	c7 b8       	rjmp	8000fa2c <__avr32_umod64+0x208>
8000f938:	16 39       	cp.w	r9,r11
8000f93a:	e0 8b 00 79 	brhi	8000fa2c <__avr32_umod64+0x208>
8000f93e:	f2 09 12 00 	clz	r9,r9
8000f942:	c1 21       	brne	8000f966 <__avr32_umod64+0x142>
8000f944:	10 3a       	cp.w	r10,r8
8000f946:	5f 2b       	srhs	r11
8000f948:	0a 31       	cp.w	r1,r5
8000f94a:	5f ba       	srhi	r10
8000f94c:	f7 ea 10 0a 	or	r10,r11,r10
8000f950:	f2 0a 18 00 	cp.b	r10,r9
8000f954:	c0 60       	breq	8000f960 <__avr32_umod64+0x13c>
8000f956:	fc 08 01 0c 	sub	r12,lr,r8
8000f95a:	e2 05 01 46 	sbc	r6,r1,r5
8000f95e:	18 9e       	mov	lr,r12
8000f960:	0c 9b       	mov	r11,r6
8000f962:	1c 9a       	mov	r10,lr
8000f964:	c6 48       	rjmp	8000fa2c <__avr32_umod64+0x208>
8000f966:	ea 09 09 4c 	lsl	r12,r5,r9
8000f96a:	f2 06 11 20 	rsub	r6,r9,32
8000f96e:	f6 09 09 4b 	lsl	r11,r11,r9
8000f972:	f0 09 09 42 	lsl	r2,r8,r9
8000f976:	ef 46 ff f4 	st.w	r7[-12],r6
8000f97a:	f0 06 0a 48 	lsr	r8,r8,r6
8000f97e:	18 48       	or	r8,r12
8000f980:	e2 06 0a 4c 	lsr	r12,r1,r6
8000f984:	f4 09 09 43 	lsl	r3,r10,r9
8000f988:	fd d8 c0 10 	bfextu	lr,r8,0x0,0x10
8000f98c:	f4 06 0a 4a 	lsr	r10,r10,r6
8000f990:	16 4a       	or	r10,r11
8000f992:	f0 0b 16 10 	lsr	r11,r8,0x10
8000f996:	f8 0b 0d 04 	divu	r4,r12,r11
8000f99a:	f4 0c 16 10 	lsr	r12,r10,0x10
8000f99e:	08 91       	mov	r1,r4
8000f9a0:	f9 e5 11 0c 	or	r12,r12,r5<<0x10
8000f9a4:	e8 0e 02 46 	mul	r6,r4,lr
8000f9a8:	0c 3c       	cp.w	r12,r6
8000f9aa:	c0 a2       	brcc	8000f9be <__avr32_umod64+0x19a>
8000f9ac:	20 11       	sub	r1,1
8000f9ae:	10 0c       	add	r12,r8
8000f9b0:	10 3c       	cp.w	r12,r8
8000f9b2:	c0 63       	brcs	8000f9be <__avr32_umod64+0x19a>
8000f9b4:	0c 3c       	cp.w	r12,r6
8000f9b6:	f7 b1 03 01 	sublo	r1,1
8000f9ba:	f9 d8 e3 0c 	addcs	r12,r12,r8
8000f9be:	0c 1c       	sub	r12,r6
8000f9c0:	f5 da c0 10 	bfextu	r10,r10,0x0,0x10
8000f9c4:	f8 0b 0d 04 	divu	r4,r12,r11
8000f9c8:	f5 e5 11 0b 	or	r11,r10,r5<<0x10
8000f9cc:	08 96       	mov	r6,r4
8000f9ce:	e8 0e 02 4e 	mul	lr,r4,lr
8000f9d2:	1c 3b       	cp.w	r11,lr
8000f9d4:	c0 a2       	brcc	8000f9e8 <__avr32_umod64+0x1c4>
8000f9d6:	20 16       	sub	r6,1
8000f9d8:	10 0b       	add	r11,r8
8000f9da:	10 3b       	cp.w	r11,r8
8000f9dc:	c0 63       	brcs	8000f9e8 <__avr32_umod64+0x1c4>
8000f9de:	1c 3b       	cp.w	r11,lr
8000f9e0:	f7 b6 03 01 	sublo	r6,1
8000f9e4:	f7 d8 e3 0b 	addcs	r11,r11,r8
8000f9e8:	ed e1 11 01 	or	r1,r6,r1<<0x10
8000f9ec:	1c 1b       	sub	r11,lr
8000f9ee:	e2 02 06 40 	mulu.d	r0,r1,r2
8000f9f2:	00 9e       	mov	lr,r0
8000f9f4:	02 9c       	mov	r12,r1
8000f9f6:	16 3c       	cp.w	r12,r11
8000f9f8:	e0 8b 00 08 	brhi	8000fa08 <__avr32_umod64+0x1e4>
8000f9fc:	5f 06       	sreq	r6
8000f9fe:	06 30       	cp.w	r0,r3
8000fa00:	5f ba       	srhi	r10
8000fa02:	ed ea 00 0a 	and	r10,r6,r10
8000fa06:	c0 60       	breq	8000fa12 <__avr32_umod64+0x1ee>
8000fa08:	fc 02 01 04 	sub	r4,lr,r2
8000fa0c:	f8 08 01 4c 	sbc	r12,r12,r8
8000fa10:	08 9e       	mov	lr,r4
8000fa12:	e6 0e 01 0a 	sub	r10,r3,lr
8000fa16:	f6 0c 01 4c 	sbc	r12,r11,r12
8000fa1a:	ee f1 ff f4 	ld.w	r1,r7[-12]
8000fa1e:	f8 09 0a 4b 	lsr	r11,r12,r9
8000fa22:	f4 09 0a 4a 	lsr	r10,r10,r9
8000fa26:	f8 01 09 4c 	lsl	r12,r12,r1
8000fa2a:	18 4a       	or	r10,r12
8000fa2c:	2f dd       	sub	sp,-12
8000fa2e:	d8 32       	popm	r0-r7,pc

Disassembly of section .exception:

8000fc00 <_evba>:
_evba:

        .org  0x000
        // Unrecoverable Exception.
_handle_Unrecoverable_Exception:
        rjmp $
8000fc00:	c0 08       	rjmp	8000fc00 <_evba>
	...

8000fc04 <_handle_TLB_Multiple_Hit>:

        .org  0x004
        // TLB Multiple Hit: UNUSED IN AVR32UC.
_handle_TLB_Multiple_Hit:
        rjmp $
8000fc04:	c0 08       	rjmp	8000fc04 <_handle_TLB_Multiple_Hit>
	...

8000fc08 <_handle_Bus_Error_Data_Fetch>:

        .org  0x008
        // Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
        rjmp $
8000fc08:	c0 08       	rjmp	8000fc08 <_handle_Bus_Error_Data_Fetch>
	...

8000fc0c <_handle_Bus_Error_Instruction_Fetch>:

        .org  0x00C
         // Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
        rjmp $
8000fc0c:	c0 08       	rjmp	8000fc0c <_handle_Bus_Error_Instruction_Fetch>
	...

8000fc10 <_handle_NMI>:

        .org  0x010
        // NMI.
_handle_NMI:
        rjmp $
8000fc10:	c0 08       	rjmp	8000fc10 <_handle_NMI>
	...

8000fc14 <_handle_Instruction_Address>:

        .org  0x014
        // Instruction Address.
_handle_Instruction_Address:
        rjmp $
8000fc14:	c0 08       	rjmp	8000fc14 <_handle_Instruction_Address>
	...

8000fc18 <_handle_ITLB_Protection>:

        .org  0x018
        // ITLB Protection.
_handle_ITLB_Protection:
        rjmp $
8000fc18:	c0 08       	rjmp	8000fc18 <_handle_ITLB_Protection>
	...

8000fc1c <_handle_Breakpoint>:

        .org  0x01C
        // Breakpoint.
_handle_Breakpoint:
        rjmp $
8000fc1c:	c0 08       	rjmp	8000fc1c <_handle_Breakpoint>
	...

8000fc20 <_handle_Illegal_Opcode>:

        .org  0x020
        // Illegal Opcode.
_handle_Illegal_Opcode:
        rjmp $
8000fc20:	c0 08       	rjmp	8000fc20 <_handle_Illegal_Opcode>
	...

8000fc24 <_handle_Unimplemented_Instruction>:

        .org  0x024
        // Unimplemented Instruction.
_handle_Unimplemented_Instruction:
        rjmp $
8000fc24:	c0 08       	rjmp	8000fc24 <_handle_Unimplemented_Instruction>
	...

8000fc28 <_handle_Privilege_Violation>:

        .org  0x028
        // Privilege Violation.
_handle_Privilege_Violation:
        rjmp $
8000fc28:	c0 08       	rjmp	8000fc28 <_handle_Privilege_Violation>
	...

8000fc2c <_handle_Floating_Point>:

        .org  0x02C
        // Floating-Point: UNUSED IN AVR32UC.
_handle_Floating_Point:
        rjmp $
8000fc2c:	c0 08       	rjmp	8000fc2c <_handle_Floating_Point>
	...

8000fc30 <_handle_Coprocessor_Absent>:

        .org  0x030
        // Coprocessor Absent: UNUSED IN AVR32UC.
_handle_Coprocessor_Absent:
        rjmp $
8000fc30:	c0 08       	rjmp	8000fc30 <_handle_Coprocessor_Absent>
	...

8000fc34 <_handle_Data_Address_Read>:

        .org  0x034
        // Data Address (Read).
_handle_Data_Address_Read:
        rjmp $
8000fc34:	c0 08       	rjmp	8000fc34 <_handle_Data_Address_Read>
	...

8000fc38 <_handle_Data_Address_Write>:

        .org  0x038
        // Data Address (Write).
_handle_Data_Address_Write:
        rjmp $
8000fc38:	c0 08       	rjmp	8000fc38 <_handle_Data_Address_Write>
	...

8000fc3c <_handle_DTLB_Protection_Read>:

        .org  0x03C
        // DTLB Protection (Read).
_handle_DTLB_Protection_Read:
        rjmp $
8000fc3c:	c0 08       	rjmp	8000fc3c <_handle_DTLB_Protection_Read>
	...

8000fc40 <_handle_DTLB_Protection_Write>:

        .org  0x040
        // DTLB Protection (Write).
_handle_DTLB_Protection_Write:
        rjmp $
8000fc40:	c0 08       	rjmp	8000fc40 <_handle_DTLB_Protection_Write>
	...

8000fc44 <_handle_DTLB_Modified>:

        .org  0x044
        // DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
        rjmp $
8000fc44:	c0 08       	rjmp	8000fc44 <_handle_DTLB_Modified>
	...

8000fc50 <_handle_ITLB_Miss>:

        .org  0x050
        // ITLB Miss: UNUSED IN AVR32UC.
_handle_ITLB_Miss:
        rjmp $
8000fc50:	c0 08       	rjmp	8000fc50 <_handle_ITLB_Miss>
	...

8000fc60 <_handle_DTLB_Miss_Read>:

        .org  0x060
        // DTLB Miss (Read): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Read:
        rjmp $
8000fc60:	c0 08       	rjmp	8000fc60 <_handle_DTLB_Miss_Read>
	...

8000fc70 <_handle_DTLB_Miss_Write>:

        .org  0x070
        // DTLB Miss (Write): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Write:
        rjmp $
8000fc70:	c0 08       	rjmp	8000fc70 <_handle_DTLB_Miss_Write>
	...

8000fd00 <_handle_Supervisor_Call>:

        .org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
8000fd00:	fe cf 73 a4 	sub	pc,pc,29604

8000fd04 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
8000fd04:	30 0c       	mov	r12,0
8000fd06:	fe b0 ae c9 	rcall	80005a98 <_get_interrupt_handler>
8000fd0a:	58 0c       	cp.w	r12,0
8000fd0c:	f8 0f 17 10 	movne	pc,r12
8000fd10:	d6 03       	rete

8000fd12 <_int1>:
8000fd12:	30 1c       	mov	r12,1
8000fd14:	fe b0 ae c2 	rcall	80005a98 <_get_interrupt_handler>
8000fd18:	58 0c       	cp.w	r12,0
8000fd1a:	f8 0f 17 10 	movne	pc,r12
8000fd1e:	d6 03       	rete

8000fd20 <_int2>:
8000fd20:	30 2c       	mov	r12,2
8000fd22:	fe b0 ae bb 	rcall	80005a98 <_get_interrupt_handler>
8000fd26:	58 0c       	cp.w	r12,0
8000fd28:	f8 0f 17 10 	movne	pc,r12
8000fd2c:	d6 03       	rete

8000fd2e <_int3>:
8000fd2e:	30 3c       	mov	r12,3
8000fd30:	fe b0 ae b4 	rcall	80005a98 <_get_interrupt_handler>
8000fd34:	58 0c       	cp.w	r12,0
8000fd36:	f8 0f 17 10 	movne	pc,r12
8000fd3a:	d6 03       	rete

8000fd3c <ipr_val>:
8000fd3c:	00 00 01 04 40 00 01 12 80 00 01 20 c0 00 01 2e     ....@...... ....
8000fd4c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000fd5c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000fd6c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000fd7c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000fd8c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000fd9c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000fdac:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000fdbc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000fdcc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000fddc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000fdec:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000fdfc:	d7 03 d7 03                                         ....
