
moto_gob_prj.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002008  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80002008  80002008  00002408  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         00009de0  80002008  80002008  00002408  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  8000be00  8000be00  0000c200  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       00001114  8000c000  8000c000  0000c400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .lalign       00000004  8000d114  8000d114  0000d514  2**0
                  ALLOC
  6 .dalign       00000004  00000004  00000004  00000000  2**0
                  ALLOC
  7 .data         00000a2c  00000008  8000d118  0000d808  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .balign       00000004  00000a34  8000db44  0000e234  2**0
                  ALLOC
  9 .bss          000036c0  00000a38  00000a38  00000000  2**2
                  ALLOC
 10 .heap         00012f08  000040f8  000040f8  00000000  2**0
                  ALLOC
 11 .comment      00000030  00000000  00000000  0000e234  2**0
                  CONTENTS, READONLY
 12 .debug_aranges 000010e8  00000000  00000000  0000e268  2**3
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_pubnames 00002447  00000000  00000000  0000f350  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_info   000273a4  00000000  00000000  00011797  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_abbrev 000064c3  00000000  00000000  00038b3b  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_line   0000be2e  00000000  00000000  0003effe  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_frame  00002c00  00000000  00000000  0004ae2c  2**2
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_str    00006b23  00000000  00000000  0004da2c  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .debug_loc    0000c674  00000000  00000000  0005454f  2**0
                  CONTENTS, READONLY, DEBUGGING
 20 .stack        00001000  00017000  00017000  00000000  2**0
                  ALLOC
 21 .debug_ranges 000011d8  00000000  00000000  00060bc8  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_start>:

  .global _start
  .type _start, @function
_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80000000:	fe cf 9b 3c 	sub	pc,pc,-25796

80000004 <_trampoline>:
80000004:	e0 8f 10 00 	bral	80002004 <program_start>
	...

80002004 <program_start>:
  rjmp    program_start

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002004:	fe cf bb 40 	sub	pc,pc,-17600

Disassembly of section .text:

80002008 <DeviceManagement_brdcst_func>:
80002008:	19 a9       	ld.ub	r9,r12[0x2]
8000200a:	30 18       	mov	r8,1
		U8 temp = 0;
		temp  = xcmp->u8[1] << 8;
		temp |= xcmp->u8[2];
		//if (temp == theXNL_Ctrlr.XNL_DeviceLogicalAddress)
		{
			if (xcmp->u8[0] == 0x01)
8000200c:	f0 09 18 00 	cp.b	r9,r8
80002010:	c0 61       	brne	8000201c <DeviceManagement_brdcst_func+0x14>
			{
				bunchofrandomstatusflags |= 0x00000002;
80002012:	48 68       	lddpc	r8,80002028 <DeviceManagement_brdcst_func+0x20>
80002014:	70 09       	ld.w	r9,r8[0x0]
80002016:	a1 b9       	sbr	r9,0x1
80002018:	91 09       	st.w	r8[0x0],r9
8000201a:	5e fc       	retal	r12
			}
			else
			{
				bunchofrandomstatusflags &= 0xFFFFFFFD;
8000201c:	48 38       	lddpc	r8,80002028 <DeviceManagement_brdcst_func+0x20>
8000201e:	70 09       	ld.w	r9,r8[0x0]
80002020:	a1 d9       	cbr	r9,0x1
80002022:	91 09       	st.w	r8[0x0],r9
80002024:	5e fc       	retal	r12
80002026:	00 00       	add	r0,r0
80002028:	00 00       	add	r0,r0
8000202a:	0d 70       	ld.ub	r0,--r6

8000202c <Volume_brdcst_func>:
	//log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
	
	//log("\n\r Audio_Parameter: %x \n\r", ptr->Audio_Parameter);
	
	
}
8000202c:	5e fc       	retal	r12

8000202e <AudioRoutingControl_brdcst_func>:
	//
	//log("\n\r Audio-Function: %x \n\r", xcmp->u8[3+j*2-1]);
	
	
	
}
8000202e:	5e fc       	retal	r12

80002030 <vApplicationIdleHook>:
}

void vApplicationIdleHook( void )
{
	/* This hook function does nothing but increment a counter. */
	ulIdleCycleCount++;
80002030:	48 38       	lddpc	r8,8000203c <vApplicationIdleHook+0xc>
80002032:	70 09       	ld.w	r9,r8[0x0]
80002034:	2f f9       	sub	r9,-1
80002036:	91 09       	st.w	r8[0x0],r9
	
}
80002038:	5e fc       	retal	r12
8000203a:	00 00       	add	r0,r0
8000203c:	00 00       	add	r0,r0
8000203e:	0a 54       	eor	r4,r5

80002040 <app_init>:
														
		
};

void app_init(void)
{	
80002040:	d4 01       	pushm	lr
	//将app_payload_rx_proc更改为PCM加密功能
	payload_init( app_payload_rx_proc , app_payload_tx_proc );	
80002042:	48 cb       	lddpc	r11,80002070 <app_init+0x30>
80002044:	48 cc       	lddpc	r12,80002074 <app_init+0x34>
80002046:	f0 1f 00 0d 	mcall	80002078 <app_init+0x38>
	xcmp_register_app_list(the_app_list);
8000204a:	48 dc       	lddpc	r12,8000207c <app_init+0x3c>
8000204c:	f0 1f 00 0d 	mcall	80002080 <app_init+0x40>
			
	static portBASE_TYPE res = 0;
	 res = xTaskCreate(
80002050:	30 09       	mov	r9,0
80002052:	1a d9       	st.w	--sp,r9
80002054:	1a d9       	st.w	--sp,r9
80002056:	1a d9       	st.w	--sp,r9
80002058:	30 18       	mov	r8,1
8000205a:	e0 6a 01 80 	mov	r10,384
8000205e:	48 ab       	lddpc	r11,80002084 <app_init+0x44>
80002060:	48 ac       	lddpc	r12,80002088 <app_init+0x48>
80002062:	f0 1f 00 0b 	mcall	8000208c <app_init+0x4c>
80002066:	48 b8       	lddpc	r8,80002090 <app_init+0x50>
80002068:	91 0c       	st.w	r8[0x0],r12
8000206a:	2f dd       	sub	sp,-12
	,  NULL
	,  1
	,  NULL );
	
	
}
8000206c:	d8 02       	popm	pc
8000206e:	00 00       	add	r0,r0
80002070:	80 00       	ld.sh	r0,r0[0x0]
80002072:	21 20       	sub	r0,18
80002074:	80 00       	ld.sh	r0,r0[0x0]
80002076:	28 48       	sub	r8,-124
80002078:	80 00       	ld.sh	r0,r0[0x0]
8000207a:	28 e8       	sub	r8,-114
8000207c:	00 00       	add	r0,r0
8000207e:	00 08       	add	r8,r0
80002080:	80 00       	ld.sh	r0,r0[0x0]
80002082:	3e 68       	mov	r8,-26
80002084:	80 00       	ld.sh	r0,r0[0x0]
80002086:	c0 00       	breq	80002086 <app_init+0x46>
80002088:	80 00       	ld.sh	r0,r0[0x0]
8000208a:	20 94       	sub	r4,9
8000208c:	80 00       	ld.sh	r0,r0[0x0]
8000208e:	5c 40       	abs	r0
80002090:	00 00       	add	r0,r0
80002092:	0a 3c       	cp.w	r12,r5

80002094 <app_cfg>:

extern  char AudioData[];
extern U32 tc_tick;

static __app_Thread_(app_cfg)
{
80002094:	d4 31       	pushm	r0-r7,lr
	static  U32 isAudioRouting = 0;
	static  portTickType xLastWakeTime;
	const portTickType xFrequency = 4000;//2s,定时问题已经修正。2s x  2000hz = 4000
	U8 Burst_ID = 0;
	
	 xLastWakeTime = xTaskGetTickCount();
80002096:	f0 1f 00 1a 	mcall	800020fc <app_cfg+0x68>
8000209a:	49 a8       	lddpc	r8,80002100 <app_cfg+0x6c>
8000209c:	91 0c       	st.w	r8[0x0],r12
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003))//确认连接成功了，再发送请求
8000209e:	49 a6       	lddpc	r6,80002104 <app_cfg+0x70>
				//{
					////xcmp_transmit_dekeycontrol();
					//
				//}
				
				if(isAudioRouting == 0)
800020a0:	49 a4       	lddpc	r4,80002108 <app_cfg+0x74>
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_exit_enhanced_OB_mode();
					//xcmp_mute_speaker();
					//xcmp_enhanced_OB_mode();
					isAudioRouting = 4;
800020a2:	30 41       	mov	r1,4
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_mute_speaker();	
					//log("\n\r time: %d \n\r", tc_tick); 
					isAudioRouting = 3;
800020a4:	30 32       	mov	r2,3
					//xcmp_button_config();
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//log("\n\r time: %d \n\r", tc_tick);
					
					isAudioRouting = 2;
800020a6:	30 20       	mov	r0,2
					xcmp_enter_enhanced_OB_mode();
					//xcmp_unmute_speaker();
					//Speaker_is_unmute = 1;
					//xcmp_function_mic();
					
					isAudioRouting = 1;
800020a8:	30 13       	mov	r3,1
			
		}
		//vTaskDelay(300*2 / portTICK_RATE_MS);//延迟300ms
		//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
		
		vTaskDelayUntil( &xLastWakeTime, 2000*2 / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
800020aa:	10 97       	mov	r7,r8
800020ac:	e0 65 0f a0 	mov	r5,4000
	
	 xLastWakeTime = xTaskGetTickCount();
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003))//确认连接成功了，再发送请求
800020b0:	6c 08       	ld.w	r8,r6[0x0]
800020b2:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
800020b6:	58 38       	cp.w	r8,3
800020b8:	c1 d1       	brne	800020f2 <app_cfg+0x5e>
		{	
			//if((++coun) % 3 ==0)		
			{
				
				// xcmp_audio_route_speaker();
				xcmp_IdleTestTone();
800020ba:	f0 1f 00 15 	mcall	8000210c <app_cfg+0x78>
				//{
					////xcmp_transmit_dekeycontrol();
					//
				//}
				
				if(isAudioRouting == 0)
800020be:	68 08       	ld.w	r8,r4[0x0]
800020c0:	58 08       	cp.w	r8,0
800020c2:	c0 71       	brne	800020d0 <app_cfg+0x3c>
				{
					//xcmp_data_session();
					//xcmp_audio_route_mic();
					//xcmp_button_config();
					//xcmp_audio_route_speaker();
					xcmp_enter_device_control_mode();//调换3个命令的顺序，则不会导致掉线。。。奇葩
800020c4:	f0 1f 00 13 	mcall	80002110 <app_cfg+0x7c>
					xcmp_enter_enhanced_OB_mode();
800020c8:	f0 1f 00 13 	mcall	80002114 <app_cfg+0x80>
					//xcmp_unmute_speaker();
					//Speaker_is_unmute = 1;
					//xcmp_function_mic();
					
					isAudioRouting = 1;
800020cc:	89 03       	st.w	r4[0x0],r3
800020ce:	c1 28       	rjmp	800020f2 <app_cfg+0x5e>
				}
				else if(isAudioRouting == 1)
800020d0:	58 18       	cp.w	r8,1
800020d2:	c0 51       	brne	800020dc <app_cfg+0x48>
				{
					//xcmp_exit_device_control_mode();
					xcmp_audio_route_AMBE();
800020d4:	f0 1f 00 11 	mcall	80002118 <app_cfg+0x84>
					//xcmp_button_config();
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//log("\n\r time: %d \n\r", tc_tick);
					
					isAudioRouting = 2;
800020d8:	89 00       	st.w	r4[0x0],r0
800020da:	c0 c8       	rjmp	800020f2 <app_cfg+0x5e>
					//isAudioRouting++;
				}
				else if(isAudioRouting == 2)
800020dc:	58 28       	cp.w	r8,2
800020de:	c0 31       	brne	800020e4 <app_cfg+0x50>
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_mute_speaker();	
					//log("\n\r time: %d \n\r", tc_tick); 
					isAudioRouting = 3;
800020e0:	89 02       	st.w	r4[0x0],r2
800020e2:	c0 88       	rjmp	800020f2 <app_cfg+0x5e>
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_exit_enhanced_OB_mode();
					//xcmp_mute_speaker();
					//xcmp_enhanced_OB_mode();
					isAudioRouting = 4;
800020e4:	58 38       	cp.w	r8,3
800020e6:	e9 f1 0a 00 	st.weq	r4[0x0],r1
					
				}
				else
				{
					isAudioRouting++;
800020ea:	f7 b8 01 ff 	subne	r8,-1
800020ee:	e9 f8 1a 00 	st.wne	r4[0x0],r8
			
		}
		//vTaskDelay(300*2 / portTICK_RATE_MS);//延迟300ms
		//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
		
		vTaskDelayUntil( &xLastWakeTime, 2000*2 / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
800020f2:	0a 9b       	mov	r11,r5
800020f4:	0e 9c       	mov	r12,r7
800020f6:	f0 1f 00 0a 	mcall	8000211c <app_cfg+0x88>
	}
800020fa:	cd bb       	rjmp	800020b0 <app_cfg+0x1c>
800020fc:	80 00       	ld.sh	r0,r0[0x0]
800020fe:	59 78       	cp.w	r8,23
80002100:	00 00       	add	r0,r0
80002102:	0a 48       	or	r8,r5
80002104:	00 00       	add	r0,r0
80002106:	0d 70       	ld.ub	r0,--r6
80002108:	00 00       	add	r0,r0
8000210a:	0a 44       	or	r4,r5
8000210c:	80 00       	ld.sh	r0,r0[0x0]
8000210e:	40 18       	lddsp	r8,sp[0x4]
80002110:	80 00       	ld.sh	r0,r0[0x0]
80002112:	3e bc       	mov	r12,-21
80002114:	80 00       	ld.sh	r0,r0[0x0]
80002116:	3f 48       	mov	r8,-12
80002118:	80 00       	ld.sh	r0,r0[0x0]
8000211a:	3e e8       	mov	r8,-18
8000211c:	80 00       	ld.sh	r0,r0[0x0]
8000211e:	5a e0       	cp.w	r0,-18

80002120 <app_payload_tx_proc>:

}


static void app_payload_tx_proc(void  * payload)
{
80002120:	d4 01       	pushm	lr
  log("R");
80002122:	48 3c       	lddpc	r12,8000212c <app_payload_tx_proc+0xc>
80002124:	f0 1f 00 03 	mcall	80002130 <app_payload_tx_proc+0x10>
  //
  //
  //set_payload_idle(payload);


}
80002128:	d8 02       	popm	pc
8000212a:	00 00       	add	r0,r0
8000212c:	80 00       	ld.sh	r0,r0[0x0]
8000212e:	c0 08       	rjmp	8000212e <app_payload_tx_proc+0xe>
80002130:	80 00       	ld.sh	r0,r0[0x0]
80002132:	60 04       	ld.w	r4,r0[0x0]

80002134 <FD_brdcst_func>:
	
	
}

void FD_brdcst_func(xcmp_fragment_t * xcmp)
{
80002134:	d4 01       	pushm	lr
	
	
	log("\n\r Forward Data Broadcast \n\r");
80002136:	48 3c       	lddpc	r12,80002140 <FD_brdcst_func+0xc>
80002138:	f0 1f 00 03 	mcall	80002144 <FD_brdcst_func+0x10>
	
}
8000213c:	d8 02       	popm	pc
8000213e:	00 00       	add	r0,r0
80002140:	80 00       	ld.sh	r0,r0[0x0]
80002142:	c0 0c       	rcall	80002142 <FD_brdcst_func+0xe>
80002144:	80 00       	ld.sh	r0,r0[0x0]
80002146:	60 04       	ld.w	r4,r0[0x0]

80002148 <FD_reply_func>:
	
	
}

void FD_reply_func(xcmp_fragment_t * xcmp)
{
80002148:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Reply \n\r");
8000214a:	48 3c       	lddpc	r12,80002154 <FD_reply_func+0xc>
8000214c:	f0 1f 00 03 	mcall	80002158 <FD_reply_func+0x10>
	
	
}
80002150:	d8 02       	popm	pc
80002152:	00 00       	add	r0,r0
80002154:	80 00       	ld.sh	r0,r0[0x0]
80002156:	c0 2c       	rcall	8000215a <FD_reply_func+0x12>
80002158:	80 00       	ld.sh	r0,r0[0x0]
8000215a:	60 04       	ld.w	r4,r0[0x0]

8000215c <FD_request_func>:
}



void FD_request_func(xcmp_fragment_t * xcmp)
{
8000215c:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Request \n\r");
8000215e:	48 3c       	lddpc	r12,80002168 <FD_request_func+0xc>
80002160:	f0 1f 00 03 	mcall	8000216c <FD_request_func+0x10>
	
	
}
80002164:	d8 02       	popm	pc
80002166:	00 00       	add	r0,r0
80002168:	80 00       	ld.sh	r0,r0[0x0]
8000216a:	c0 48       	rjmp	80002172 <EnOB_brdcst_func+0x2>
8000216c:	80 00       	ld.sh	r0,r0[0x0]
8000216e:	60 04       	ld.w	r4,r0[0x0]

80002170 <EnOB_brdcst_func>:
	
	
}

void EnOB_brdcst_func(xcmp_fragment_t * xcmp)
{
80002170:	d4 01       	pushm	lr
	
	
	log("\n\r En_OB Broadcast \n\r");
80002172:	48 3c       	lddpc	r12,8000217c <EnOB_brdcst_func+0xc>
80002174:	f0 1f 00 03 	mcall	80002180 <EnOB_brdcst_func+0x10>
}
80002178:	d8 02       	popm	pc
8000217a:	00 00       	add	r0,r0
8000217c:	80 00       	ld.sh	r0,r0[0x0]
8000217e:	c0 64       	brge	8000218a <EnOB_reply_func+0x6>
80002180:	80 00       	ld.sh	r0,r0[0x0]
80002182:	60 04       	ld.w	r4,r0[0x0]

80002184 <EnOB_reply_func>:
}



void EnOB_reply_func(xcmp_fragment_t * xcmp)
{
80002184:	eb cd 40 80 	pushm	r7,lr
80002188:	18 97       	mov	r7,r12
		/*point to xcmp payload*/
	//En_OB_Control_reply_t *ptr = (En_OB_Control_reply_t* )xcmp->u8;
	//log("\n\r Xcmp_opcode: %x \n\r", xcmp->xcmp_opcode);
	
	if (xcmp->u8[0]== xcmp_Res_Success)
8000218a:	19 a9       	ld.ub	r9,r12[0x2]
8000218c:	30 08       	mov	r8,0
8000218e:	f0 09 18 00 	cp.b	r9,r8
80002192:	c1 91       	brne	800021c4 <EnOB_reply_func+0x40>
	{
		if (xcmp->u8[1] == EN_OB_Enter)
80002194:	19 b8       	ld.ub	r8,r12[0x3]
80002196:	30 19       	mov	r9,1
80002198:	f2 08 18 00 	cp.b	r8,r9
8000219c:	c0 61       	brne	800021a8 <EnOB_reply_func+0x24>
		{
		
			log("\n\r En_OB_Enter OK \n\r");
8000219e:	49 0c       	lddpc	r12,800021dc <EnOB_reply_func+0x58>
800021a0:	f0 1f 00 10 	mcall	800021e0 <EnOB_reply_func+0x5c>
800021a4:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else if (xcmp->u8[1] == EN_OB_Exit )
800021a8:	58 08       	cp.w	r8,0
800021aa:	c0 61       	brne	800021b6 <EnOB_reply_func+0x32>
		{
			log("\n\r En_OB_Exit OK \n\r");
800021ac:	48 ec       	lddpc	r12,800021e4 <EnOB_reply_func+0x60>
800021ae:	f0 1f 00 0d 	mcall	800021e0 <EnOB_reply_func+0x5c>
800021b2:	e3 cd 80 80 	ldm	sp++,r7,pc
		}
		else
		{
			
			log("\n\r En_OB_Control: %x \n\r", xcmp->u8[1]);
800021b6:	1a d8       	st.w	--sp,r8
800021b8:	48 cc       	lddpc	r12,800021e8 <EnOB_reply_func+0x64>
800021ba:	f0 1f 00 0a 	mcall	800021e0 <EnOB_reply_func+0x5c>
800021be:	2f fd       	sub	sp,-4
800021c0:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r En_OB_Control error \n\r");
800021c4:	48 ac       	lddpc	r12,800021ec <EnOB_reply_func+0x68>
800021c6:	f0 1f 00 07 	mcall	800021e0 <EnOB_reply_func+0x5c>
		log("\n\r En_OB_result: %x \n\r", xcmp->u8[0]);
800021ca:	0f a8       	ld.ub	r8,r7[0x2]
800021cc:	1a d8       	st.w	--sp,r8
800021ce:	48 9c       	lddpc	r12,800021f0 <EnOB_reply_func+0x6c>
800021d0:	f0 1f 00 04 	mcall	800021e0 <EnOB_reply_func+0x5c>
800021d4:	2f fd       	sub	sp,-4
800021d6:	e3 cd 80 80 	ldm	sp++,r7,pc
800021da:	00 00       	add	r0,r0
800021dc:	80 00       	ld.sh	r0,r0[0x0]
800021de:	c0 7c       	rcall	800021ec <EnOB_reply_func+0x68>
800021e0:	80 00       	ld.sh	r0,r0[0x0]
800021e2:	60 04       	ld.w	r4,r0[0x0]
800021e4:	80 00       	ld.sh	r0,r0[0x0]
800021e6:	c0 94       	brge	800021f8 <SingleDetection_brdcst_func+0x4>
800021e8:	80 00       	ld.sh	r0,r0[0x0]
800021ea:	c0 a8       	rjmp	800021fe <SingleDetection_brdcst_func+0xa>
800021ec:	80 00       	ld.sh	r0,r0[0x0]
800021ee:	c0 c0       	breq	80002206 <SingleDetection_brdcst_func+0x12>
800021f0:	80 00       	ld.sh	r0,r0[0x0]
800021f2:	c0 dc       	rcall	8000220c <SingleDetection_brdcst_func+0x18>

800021f4 <SingleDetection_brdcst_func>:
	
}


void SingleDetection_brdcst_func(xcmp_fragment_t * xcmp)
{
800021f4:	d4 01       	pushm	lr
	if (xcmp->u8[0] == 0x11)
800021f6:	19 a9       	ld.ub	r9,r12[0x2]
800021f8:	31 18       	mov	r8,17
800021fa:	f0 09 18 00 	cp.b	r9,r8
800021fe:	c0 41       	brne	80002206 <SingleDetection_brdcst_func+0x12>
	{
		log("\n\r DMR_CSBK OK \n\r");
80002200:	48 2c       	lddpc	r12,80002208 <SingleDetection_brdcst_func+0x14>
80002202:	f0 1f 00 03 	mcall	8000220c <SingleDetection_brdcst_func+0x18>
80002206:	d8 02       	popm	pc
80002208:	80 00       	ld.sh	r0,r0[0x0]
8000220a:	c0 f4       	brge	80002228 <ButtonConfig_brdcst_func+0x18>
8000220c:	80 00       	ld.sh	r0,r0[0x0]
8000220e:	60 04       	ld.w	r4,r0[0x0]

80002210 <ButtonConfig_brdcst_func>:
	
}


void ButtonConfig_brdcst_func(xcmp_fragment_t * xcmp)
{
80002210:	d4 31       	pushm	r0-r7,lr
	U8 Num_Button =0;
	U8 i = 0 ;
	/*point to xcmp payload*/
	ButtonConfig_brdcst_t  *ptr = (ButtonConfig_brdcst_t* )xcmp->u8;
80002212:	f8 c7 ff fe 	sub	r7,r12,-2
	
	Num_Button = ptr->NumOfButtons;
80002216:	0f 95       	ld.ub	r5,r7[0x1]
	
	log("\n\r ButtonConfig_broadcast  \n\r"  );
80002218:	4a bc       	lddpc	r12,800022c4 <ButtonConfig_brdcst_func+0xb4>
8000221a:	f0 1f 00 2c 	mcall	800022c8 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r Function: %X \n\r" , ptr->Function );
8000221e:	0f 88       	ld.ub	r8,r7[0x0]
80002220:	1a d8       	st.w	--sp,r8
80002222:	4a bc       	lddpc	r12,800022cc <ButtonConfig_brdcst_func+0xbc>
80002224:	f0 1f 00 29 	mcall	800022c8 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
80002228:	1a d5       	st.w	--sp,r5
8000222a:	4a ac       	lddpc	r12,800022d0 <ButtonConfig_brdcst_func+0xc0>
8000222c:	f0 1f 00 27 	mcall	800022c8 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
80002230:	0f a8       	ld.ub	r8,r7[0x2]
80002232:	1a d8       	st.w	--sp,r8
80002234:	4a 8c       	lddpc	r12,800022d4 <ButtonConfig_brdcst_func+0xc4>
80002236:	f0 1f 00 25 	mcall	800022c8 <ButtonConfig_brdcst_func+0xb8>
	
	for (i; i<Num_Button; i++)
8000223a:	2f dd       	sub	sp,-12
8000223c:	58 05       	cp.w	r5,0
8000223e:	c4 10       	breq	800022c0 <ButtonConfig_brdcst_func+0xb0>
80002240:	30 06       	mov	r6,0
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
80002242:	4a 64       	lddpc	r4,800022d8 <ButtonConfig_brdcst_func+0xc8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
80002244:	4a 63       	lddpc	r3,800022dc <ButtonConfig_brdcst_func+0xcc>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
80002246:	4a 72       	lddpc	r2,800022e0 <ButtonConfig_brdcst_func+0xd0>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
80002248:	4a 71       	lddpc	r1,800022e4 <ButtonConfig_brdcst_func+0xd4>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
8000224a:	4a 80       	lddpc	r0,800022e8 <ButtonConfig_brdcst_func+0xd8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
8000224c:	0f b9       	ld.ub	r9,r7[0x3]
8000224e:	0f c8       	ld.ub	r8,r7[0x4]
80002250:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002254:	1a d8       	st.w	--sp,r8
80002256:	1a d6       	st.w	--sp,r6
80002258:	08 9c       	mov	r12,r4
8000225a:	f0 1f 00 1c 	mcall	800022c8 <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
8000225e:	0f d9       	ld.ub	r9,r7[0x5]
80002260:	0f e8       	ld.ub	r8,r7[0x6]
80002262:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002266:	1a d8       	st.w	--sp,r8
80002268:	1a d6       	st.w	--sp,r6
8000226a:	06 9c       	mov	r12,r3
8000226c:	f0 1f 00 17 	mcall	800022c8 <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
80002270:	0f f9       	ld.ub	r9,r7[0x7]
80002272:	ef 38 00 08 	ld.ub	r8,r7[8]
80002276:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000227a:	1a d8       	st.w	--sp,r8
8000227c:	1a d6       	st.w	--sp,r6
8000227e:	04 9c       	mov	r12,r2
80002280:	f0 1f 00 12 	mcall	800022c8 <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
80002284:	ef 39 00 09 	ld.ub	r9,r7[9]
80002288:	ef 38 00 0a 	ld.ub	r8,r7[10]
8000228c:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002290:	1a d8       	st.w	--sp,r8
80002292:	1a d6       	st.w	--sp,r6
80002294:	02 9c       	mov	r12,r1
80002296:	f0 1f 00 0d 	mcall	800022c8 <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
8000229a:	2f 8d       	sub	sp,-32
8000229c:	ef 39 00 0b 	ld.ub	r9,r7[11]
800022a0:	ef 38 00 0c 	ld.ub	r8,r7[12]
800022a4:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800022a8:	1a d8       	st.w	--sp,r8
800022aa:	1a d6       	st.w	--sp,r6
800022ac:	00 9c       	mov	r12,r0
800022ae:	f0 1f 00 07 	mcall	800022c8 <ButtonConfig_brdcst_func+0xb8>
800022b2:	2f f6       	sub	r6,-1
800022b4:	2f 67       	sub	r7,-10
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
800022b6:	2f ed       	sub	sp,-8
800022b8:	ec 05 18 00 	cp.b	r5,r6
800022bc:	fe 9b ff c8 	brhi	8000224c <ButtonConfig_brdcst_func+0x3c>
800022c0:	d8 32       	popm	r0-r7,pc
800022c2:	00 00       	add	r0,r0
800022c4:	80 00       	ld.sh	r0,r0[0x0]
800022c6:	c1 08       	rjmp	800022e6 <ButtonConfig_brdcst_func+0xd6>
800022c8:	80 00       	ld.sh	r0,r0[0x0]
800022ca:	60 04       	ld.w	r4,r0[0x0]
800022cc:	80 00       	ld.sh	r0,r0[0x0]
800022ce:	c1 28       	rjmp	800022f2 <Phyuserinput_brdcst_func+0x6>
800022d0:	80 00       	ld.sh	r0,r0[0x0]
800022d2:	c1 3c       	rcall	800022f8 <Phyuserinput_brdcst_func+0xc>
800022d4:	80 00       	ld.sh	r0,r0[0x0]
800022d6:	c1 54       	brge	80002300 <Phyuserinput_brdcst_func+0x14>
800022d8:	80 00       	ld.sh	r0,r0[0x0]
800022da:	c1 74       	brge	80002308 <Phyuserinput_brdcst_func+0x1c>
800022dc:	80 00       	ld.sh	r0,r0[0x0]
800022de:	c1 9c       	rcall	80002310 <Phyuserinput_brdcst_func+0x24>
800022e0:	80 00       	ld.sh	r0,r0[0x0]
800022e2:	c1 c4       	brge	8000231a <Phyuserinput_brdcst_func+0x2e>
800022e4:	80 00       	ld.sh	r0,r0[0x0]
800022e6:	c1 e8       	rjmp	80002322 <Phyuserinput_brdcst_func+0x36>
800022e8:	80 00       	ld.sh	r0,r0[0x0]
800022ea:	c2 10       	breq	8000232c <Phyuserinput_brdcst_func+0x40>

800022ec <Phyuserinput_brdcst_func>:
	
}


void Phyuserinput_brdcst_func(xcmp_fragment_t * xcmp)
{
800022ec:	eb cd 40 fc 	pushm	r2-r7,lr
	U16 PUI_ID =0;
	U8 PUI_State =0;
	U8 PUI_State_Min_Value =0;
	U8 PUI_State_Max_Value =0;
	
	PUI_Source = xcmp->u8[0];
800022f0:	19 a6       	ld.ub	r6,r12[0x2]
	PUI_Type = xcmp ->u8[1];
800022f2:	19 b5       	ld.ub	r5,r12[0x3]
	PUI_ID = ((xcmp->u8[2]<<8) | xcmp->u8[3]);
800022f4:	19 c7       	ld.ub	r7,r12[0x4]
800022f6:	19 d8       	ld.ub	r8,r12[0x5]
800022f8:	f1 e7 10 87 	or	r7,r8,r7<<0x8
	PUI_State = xcmp->u8[4];
800022fc:	19 e4       	ld.ub	r4,r12[0x6]
	PUI_State_Min_Value = xcmp->u8[5];
800022fe:	19 f3       	ld.ub	r3,r12[0x7]
	PUI_State_Max_Value = xcmp->u8[6];
80002300:	f9 32 00 08 	ld.ub	r2,r12[8]
	
	log("\n\r PhysicalUserInput_broadcast  \n\r"  );
80002304:	49 0c       	lddpc	r12,80002344 <Phyuserinput_brdcst_func+0x58>
80002306:	f0 1f 00 11 	mcall	80002348 <Phyuserinput_brdcst_func+0x5c>
	
	log("\n\r PUI_Source: %X \n\r" , PUI_Source);
8000230a:	1a d6       	st.w	--sp,r6
8000230c:	49 0c       	lddpc	r12,8000234c <Phyuserinput_brdcst_func+0x60>
8000230e:	f0 1f 00 0f 	mcall	80002348 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_Type: %X \n\r" , PUI_Type);
80002312:	1a d5       	st.w	--sp,r5
80002314:	48 fc       	lddpc	r12,80002350 <Phyuserinput_brdcst_func+0x64>
80002316:	f0 1f 00 0d 	mcall	80002348 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_ID: %X \n\r" , PUI_ID);
8000231a:	5c 77       	castu.h	r7
8000231c:	1a d7       	st.w	--sp,r7
8000231e:	48 ec       	lddpc	r12,80002354 <Phyuserinput_brdcst_func+0x68>
80002320:	f0 1f 00 0a 	mcall	80002348 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_State: %X \n\r" , PUI_State);
80002324:	1a d4       	st.w	--sp,r4
80002326:	48 dc       	lddpc	r12,80002358 <Phyuserinput_brdcst_func+0x6c>
80002328:	f0 1f 00 08 	mcall	80002348 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_State_Min_Value: %X \n\r" , PUI_State_Min_Value);
8000232c:	1a d3       	st.w	--sp,r3
8000232e:	48 cc       	lddpc	r12,8000235c <Phyuserinput_brdcst_func+0x70>
80002330:	f0 1f 00 06 	mcall	80002348 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_State_Max_Value: %X \n\r" , PUI_State_Max_Value);
80002334:	1a d2       	st.w	--sp,r2
80002336:	48 bc       	lddpc	r12,80002360 <Phyuserinput_brdcst_func+0x74>
80002338:	f0 1f 00 04 	mcall	80002348 <Phyuserinput_brdcst_func+0x5c>
8000233c:	2f ad       	sub	sp,-24
	
	
	
	
	
}
8000233e:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80002342:	00 00       	add	r0,r0
80002344:	80 00       	ld.sh	r0,r0[0x0]
80002346:	c2 34       	brge	8000238c <ButtonConfig_reply_func+0x28>
80002348:	80 00       	ld.sh	r0,r0[0x0]
8000234a:	60 04       	ld.w	r4,r0[0x0]
8000234c:	80 00       	ld.sh	r0,r0[0x0]
8000234e:	c2 58       	rjmp	80002398 <ButtonConfig_reply_func+0x34>
80002350:	80 00       	ld.sh	r0,r0[0x0]
80002352:	c2 70       	breq	800023a0 <ButtonConfig_reply_func+0x3c>
80002354:	80 00       	ld.sh	r0,r0[0x0]
80002356:	c2 84       	brge	800023a6 <ButtonConfig_reply_func+0x42>
80002358:	80 00       	ld.sh	r0,r0[0x0]
8000235a:	c2 98       	rjmp	800023ac <DataSession_brdcst_func+0x4>
8000235c:	80 00       	ld.sh	r0,r0[0x0]
8000235e:	c2 ac       	rcall	800023b2 <DataSession_brdcst_func+0xa>
80002360:	80 00       	ld.sh	r0,r0[0x0]
80002362:	c2 cc       	rcall	800023ba <DataSession_brdcst_func+0x12>

80002364 <ButtonConfig_reply_func>:
	}
	
}

void ButtonConfig_reply_func(xcmp_fragment_t * xcmp)
{
80002364:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	ButtonConfig_reply_t *ptr = (ButtonConfig_reply_t* )(xcmp->u8);
80002368:	f8 c7 ff fe 	sub	r7,r12,-2
	if (ptr->Result == xcmp_Res_Success)
8000236c:	0f 89       	ld.ub	r9,r7[0x0]
8000236e:	30 08       	mov	r8,0
80002370:	f0 09 18 00 	cp.b	r9,r8
80002374:	c0 c1       	brne	8000238c <ButtonConfig_reply_func+0x28>
	{
		log("\n\r Button_Config OK \n\r");
80002376:	48 9c       	lddpc	r12,80002398 <ButtonConfig_reply_func+0x34>
80002378:	f0 1f 00 09 	mcall	8000239c <ButtonConfig_reply_func+0x38>
		
		log("\n\r Function: %X \n\r" , ptr->Function );
8000237c:	0f 98       	ld.ub	r8,r7[0x1]
8000237e:	1a d8       	st.w	--sp,r8
80002380:	48 8c       	lddpc	r12,800023a0 <ButtonConfig_reply_func+0x3c>
80002382:	f0 1f 00 07 	mcall	8000239c <ButtonConfig_reply_func+0x38>
80002386:	2f fd       	sub	sp,-4
80002388:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r Button_Request error \n\r");
8000238c:	48 6c       	lddpc	r12,800023a4 <ButtonConfig_reply_func+0x40>
8000238e:	f0 1f 00 04 	mcall	8000239c <ButtonConfig_reply_func+0x38>
80002392:	e3 cd 80 80 	ldm	sp++,r7,pc
80002396:	00 00       	add	r0,r0
80002398:	80 00       	ld.sh	r0,r0[0x0]
8000239a:	c2 ec       	rcall	800023f6 <DataSession_brdcst_func+0x4e>
8000239c:	80 00       	ld.sh	r0,r0[0x0]
8000239e:	60 04       	ld.w	r4,r0[0x0]
800023a0:	80 00       	ld.sh	r0,r0[0x0]
800023a2:	c1 28       	rjmp	800023c6 <DataSession_brdcst_func+0x1e>
800023a4:	80 00       	ld.sh	r0,r0[0x0]
800023a6:	c3 04       	brge	80002406 <DataSession_brdcst_func+0x5e>

800023a8 <DataSession_brdcst_func>:
	}
	
}

void DataSession_brdcst_func(xcmp_fragment_t * xcmp)
{
800023a8:	d4 21       	pushm	r4-r7,lr
	U8 Session_number = 0;
	U16 data_length = 0;
	U8 i = 0;
	/*point to xcmp payload*/
	DataSession_brdcst_t *ptr = (DataSession_brdcst_t* )xcmp->u8;
800023aa:	f8 c6 ff fe 	sub	r6,r12,-2

	if (ptr->State == CSBK_DATA_RX_Suc)
800023ae:	0d 88       	ld.ub	r8,r6[0x0]
800023b0:	32 49       	mov	r9,36
800023b2:	f2 08 18 00 	cp.b	r8,r9
800023b6:	c2 91       	brne	80002408 <DataSession_brdcst_func+0x60>
	{
		
		log("\n\r CSBK_RX OK \n\r");
800023b8:	49 7c       	lddpc	r12,80002414 <DataSession_brdcst_func+0x6c>
800023ba:	f0 1f 00 18 	mcall	80002418 <DataSession_brdcst_func+0x70>
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
800023be:	0d a5       	ld.ub	r5,r6[0x2]
800023c0:	0d b8       	ld.ub	r8,r6[0x3]
800023c2:	f1 e5 10 85 	or	r5,r8,r5<<0x8
800023c6:	5c 85       	casts.h	r5

		log("\n\r Session_ID: %x \n\r",Session_number );
800023c8:	0d 98       	ld.ub	r8,r6[0x1]
800023ca:	1a d8       	st.w	--sp,r8
800023cc:	49 4c       	lddpc	r12,8000241c <DataSession_brdcst_func+0x74>
800023ce:	f0 1f 00 13 	mcall	80002418 <DataSession_brdcst_func+0x70>
		log("\n\r paylaod_length: %d \n\r",data_length );
800023d2:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
800023d6:	1a d8       	st.w	--sp,r8
800023d8:	49 2c       	lddpc	r12,80002420 <DataSession_brdcst_func+0x78>
800023da:	f0 1f 00 10 	mcall	80002418 <DataSession_brdcst_func+0x70>
		for(i=0; i<data_length; i++)
800023de:	2f ed       	sub	sp,-8
800023e0:	58 05       	cp.w	r5,0
800023e2:	c1 80       	breq	80002412 <DataSession_brdcst_func+0x6a>
800023e4:	30 07       	mov	r7,0
		{
			
			//log("\n\r payload[%d]: %X \n\r", i, xcmp->u8[4+i]);
			log("\n\r payload[%d]: %X \n\r", i, ptr->DataPayload.DataPayload[i]);
800023e6:	49 04       	lddpc	r4,80002424 <DataSession_brdcst_func+0x7c>
800023e8:	ec 07 00 08 	add	r8,r6,r7
800023ec:	11 c8       	ld.ub	r8,r8[0x4]
800023ee:	1a d8       	st.w	--sp,r8
800023f0:	1a d7       	st.w	--sp,r7
800023f2:	08 9c       	mov	r12,r4
800023f4:	f0 1f 00 09 	mcall	80002418 <DataSession_brdcst_func+0x70>
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);

		log("\n\r Session_ID: %x \n\r",Session_number );
		log("\n\r paylaod_length: %d \n\r",data_length );
		for(i=0; i<data_length; i++)
800023f8:	2f f7       	sub	r7,-1
800023fa:	5c 57       	castu.b	r7
800023fc:	2f ed       	sub	sp,-8
800023fe:	ee 05 19 00 	cp.h	r5,r7
80002402:	fe 9b ff f3 	brhi	800023e8 <DataSession_brdcst_func+0x40>
80002406:	d8 22       	popm	r4-r7,pc
		
	}
	else
	{
		//log("\n\r State: 0x %X \n\r", xcmp->u8[0]);
		log("\n\r State: 0x %X \n\r", ptr->State);
80002408:	1a d8       	st.w	--sp,r8
8000240a:	48 8c       	lddpc	r12,80002428 <DataSession_brdcst_func+0x80>
8000240c:	f0 1f 00 03 	mcall	80002418 <DataSession_brdcst_func+0x70>
80002410:	2f fd       	sub	sp,-4
80002412:	d8 22       	popm	r4-r7,pc
80002414:	80 00       	ld.sh	r0,r0[0x0]
80002416:	c3 20       	breq	8000247a <DataSession_reply_func+0x4e>
80002418:	80 00       	ld.sh	r0,r0[0x0]
8000241a:	60 04       	ld.w	r4,r0[0x0]
8000241c:	80 00       	ld.sh	r0,r0[0x0]
8000241e:	c3 34       	brge	80002484 <CallControl_brdcst_func>
80002420:	80 00       	ld.sh	r0,r0[0x0]
80002422:	c3 4c       	rcall	8000248a <CallControl_brdcst_func+0x6>
80002424:	80 00       	ld.sh	r0,r0[0x0]
80002426:	c3 68       	rjmp	80002492 <CallControl_brdcst_func+0xe>
80002428:	80 00       	ld.sh	r0,r0[0x0]
8000242a:	c3 80       	breq	8000249a <CallControl_brdcst_func+0x16>

8000242c <DataSession_reply_func>:
}



void DataSession_reply_func(xcmp_fragment_t * xcmp)
{
8000242c:	eb cd 40 80 	pushm	r7,lr
80002430:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
80002432:	19 a8       	ld.ub	r8,r12[0x2]
80002434:	58 08       	cp.w	r8,0
80002436:	c0 61       	brne	80002442 <DataSession_reply_func+0x16>
	{
		log("\n\r DATArep OK \n\r");
80002438:	48 dc       	lddpc	r12,8000246c <DataSession_reply_func+0x40>
8000243a:	f0 1f 00 0e 	mcall	80002470 <DataSession_reply_func+0x44>
8000243e:	e3 cd 80 80 	ldm	sp++,r7,pc
		//log("\n\r ID: 0x %X \n\r", xcmp->u8[2]);
		
	}
	else
	{
		log("\n\r Result:  %X \n\r", xcmp->u8[0]);
80002442:	1a d8       	st.w	--sp,r8
80002444:	48 cc       	lddpc	r12,80002474 <DataSession_reply_func+0x48>
80002446:	f0 1f 00 0b 	mcall	80002470 <DataSession_reply_func+0x44>
		log("\n\r DATArep error \n\r");
8000244a:	48 cc       	lddpc	r12,80002478 <DataSession_reply_func+0x4c>
8000244c:	f0 1f 00 09 	mcall	80002470 <DataSession_reply_func+0x44>
		log("\n\r Func:  %X \n\r", xcmp->u8[1]);
80002450:	0f b8       	ld.ub	r8,r7[0x3]
80002452:	1a d8       	st.w	--sp,r8
80002454:	48 ac       	lddpc	r12,8000247c <DataSession_reply_func+0x50>
80002456:	f0 1f 00 07 	mcall	80002470 <DataSession_reply_func+0x44>
		log("\n\r ID:  %X \n\r", xcmp->u8[2]);
8000245a:	0f c8       	ld.ub	r8,r7[0x4]
8000245c:	1a d8       	st.w	--sp,r8
8000245e:	48 9c       	lddpc	r12,80002480 <DataSession_reply_func+0x54>
80002460:	f0 1f 00 04 	mcall	80002470 <DataSession_reply_func+0x44>
80002464:	2f dd       	sub	sp,-12
80002466:	e3 cd 80 80 	ldm	sp++,r7,pc
8000246a:	00 00       	add	r0,r0
8000246c:	80 00       	ld.sh	r0,r0[0x0]
8000246e:	c3 94       	brge	800024e0 <TransmitControl_brdcst_func+0x18>
80002470:	80 00       	ld.sh	r0,r0[0x0]
80002472:	60 04       	ld.w	r4,r0[0x0]
80002474:	80 00       	ld.sh	r0,r0[0x0]
80002476:	c3 a8       	rjmp	800024ea <TransmitControl_brdcst_func+0x22>
80002478:	80 00       	ld.sh	r0,r0[0x0]
8000247a:	c3 bc       	rcall	800024f0 <TransmitControl_brdcst_func+0x28>
8000247c:	80 00       	ld.sh	r0,r0[0x0]
8000247e:	c3 d0       	breq	800024f8 <TransmitControl_brdcst_func+0x30>
80002480:	80 00       	ld.sh	r0,r0[0x0]
80002482:	c3 e0       	breq	800024fe <TransmitControl_brdcst_func+0x36>

80002484 <CallControl_brdcst_func>:
	
}


void CallControl_brdcst_func(xcmp_fragment_t * xcmp)
{
80002484:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	CallControl_brdcst_t *ptr = (CallControl_brdcst_t* )xcmp->u8;
80002488:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  CallControl brst \n\r ");
	//log("\n\r  Call_type: %x \n\r ", ptr->Calltype );
	log("\n\r  Call_state: %x \n\r ", ptr->Callstate );
8000248c:	0f 98       	ld.ub	r8,r7[0x1]
8000248e:	1a d8       	st.w	--sp,r8
80002490:	48 bc       	lddpc	r12,800024bc <CallControl_brdcst_func+0x38>
80002492:	f0 1f 00 0c 	mcall	800024c0 <CallControl_brdcst_func+0x3c>
	if (ptr->Callstate == Call_Ended)//0x03
80002496:	2f fd       	sub	sp,-4
80002498:	0f 99       	ld.ub	r9,r7[0x1]
8000249a:	30 38       	mov	r8,3
8000249c:	f0 09 18 00 	cp.b	r9,r8
800024a0:	c0 41       	brne	800024a8 <CallControl_brdcst_func+0x24>
	{
		//恢复正常语音路径通道
		//xcmp_audio_route_revert();
		Call_Begin = 0;
800024a2:	30 09       	mov	r9,0
800024a4:	48 88       	lddpc	r8,800024c4 <CallControl_brdcst_func+0x40>
800024a6:	b0 89       	st.b	r8[0x0],r9
		
	}
	
	if (ptr->Callstate == Call_Initiated)//0x04
800024a8:	0f 99       	ld.ub	r9,r7[0x1]
800024aa:	30 48       	mov	r8,4
800024ac:	f0 09 18 00 	cp.b	r9,r8
800024b0:	c0 41       	brne	800024b8 <CallControl_brdcst_func+0x34>
	{
		Call_Begin = 1;
800024b2:	30 19       	mov	r9,1
800024b4:	48 48       	lddpc	r8,800024c4 <CallControl_brdcst_func+0x40>
800024b6:	b0 89       	st.b	r8[0x0],r9
800024b8:	e3 cd 80 80 	ldm	sp++,r7,pc
800024bc:	80 00       	ld.sh	r0,r0[0x0]
800024be:	c3 f0       	breq	8000253c <TransmitControl_reply_func+0x2c>
800024c0:	80 00       	ld.sh	r0,r0[0x0]
800024c2:	60 04       	ld.w	r4,r0[0x0]
800024c4:	00 00       	add	r0,r0
800024c6:	0a 4d       	or	sp,r5

800024c8 <TransmitControl_brdcst_func>:

}


void TransmitControl_brdcst_func(xcmp_fragment_t * xcmp)
{
800024c8:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	TransmitControl_brdcast_t *ptr = (TransmitControl_brdcast_t* )xcmp->u8;
800024cc:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  TransmitControl broadcast \n\r ");
	//log("\n\r  Mode_Of_Operation: %x \n\r ", ptr->Mode_Of_Operation );
	if (ptr->State == 0x00)
800024d0:	0f 99       	ld.ub	r9,r7[0x1]
800024d2:	30 08       	mov	r8,0
800024d4:	f0 09 18 00 	cp.b	r9,r8
800024d8:	c0 71       	brne	800024e6 <TransmitControl_brdcst_func+0x1e>
	{
		log("\n\r  Standby-Receive \n\r ");
800024da:	48 ac       	lddpc	r12,80002500 <TransmitControl_brdcst_func+0x38>
800024dc:	f0 1f 00 0a 	mcall	80002504 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 0;
800024e0:	30 09       	mov	r9,0
800024e2:	48 a8       	lddpc	r8,80002508 <TransmitControl_brdcst_func+0x40>
800024e4:	b0 89       	st.b	r8[0x0],r9
	}
	if (ptr->State == 0x01)
800024e6:	0f 99       	ld.ub	r9,r7[0x1]
800024e8:	30 18       	mov	r8,1
800024ea:	f0 09 18 00 	cp.b	r9,r8
800024ee:	c0 71       	brne	800024fc <TransmitControl_brdcst_func+0x34>
	{
		log("\n\r  Transmit \n\r ");
800024f0:	48 7c       	lddpc	r12,8000250c <TransmitControl_brdcst_func+0x44>
800024f2:	f0 1f 00 05 	mcall	80002504 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 1;
800024f6:	30 19       	mov	r9,1
800024f8:	48 48       	lddpc	r8,80002508 <TransmitControl_brdcst_func+0x40>
800024fa:	b0 89       	st.b	r8[0x0],r9
800024fc:	e3 cd 80 80 	ldm	sp++,r7,pc
80002500:	80 00       	ld.sh	r0,r0[0x0]
80002502:	c4 08       	rjmp	80002582 <AudioRoutingControl_reply_func+0x12>
80002504:	80 00       	ld.sh	r0,r0[0x0]
80002506:	60 04       	ld.w	r4,r0[0x0]
80002508:	00 00       	add	r0,r0
8000250a:	0a 4c       	or	r12,r5
8000250c:	80 00       	ld.sh	r0,r0[0x0]
8000250e:	c4 20       	breq	80002592 <AudioRoutingControl_reply_func+0x22>

80002510 <TransmitControl_reply_func>:




void TransmitControl_reply_func(xcmp_fragment_t * xcmp)
{
80002510:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	TransmitControl_reply_t *ptr = (TransmitControl_reply_t* )xcmp->u8;
80002514:	f8 c7 ff fe 	sub	r7,r12,-2
	
	if (ptr->Result == xcmp_Res_Success)
80002518:	0f 89       	ld.ub	r9,r7[0x0]
8000251a:	30 08       	mov	r8,0
8000251c:	f0 09 18 00 	cp.b	r9,r8
80002520:	c1 61       	brne	8000254c <TransmitControl_reply_func+0x3c>
	{
		
		log("\n\r  TransmitControl OK \n\r ");
80002522:	48 ec       	lddpc	r12,80002558 <TransmitControl_reply_func+0x48>
80002524:	f0 1f 00 0e 	mcall	8000255c <TransmitControl_reply_func+0x4c>
		log("\n\r Function: %x \n\r", ptr->Function);
80002528:	0f 98       	ld.ub	r8,r7[0x1]
8000252a:	1a d8       	st.w	--sp,r8
8000252c:	48 dc       	lddpc	r12,80002560 <TransmitControl_reply_func+0x50>
8000252e:	f0 1f 00 0c 	mcall	8000255c <TransmitControl_reply_func+0x4c>
		log("\n\r Mode of Operation: %x \n\r", ptr->Mode_Of_Operation);
80002532:	0f a8       	ld.ub	r8,r7[0x2]
80002534:	1a d8       	st.w	--sp,r8
80002536:	48 cc       	lddpc	r12,80002564 <TransmitControl_reply_func+0x54>
80002538:	f0 1f 00 09 	mcall	8000255c <TransmitControl_reply_func+0x4c>
		log("\n\r State: %x \n\r", ptr->State);
8000253c:	0f b8       	ld.ub	r8,r7[0x3]
8000253e:	1a d8       	st.w	--sp,r8
80002540:	48 ac       	lddpc	r12,80002568 <TransmitControl_reply_func+0x58>
80002542:	f0 1f 00 07 	mcall	8000255c <TransmitControl_reply_func+0x4c>
80002546:	2f dd       	sub	sp,-12
80002548:	e3 cd 80 80 	ldm	sp++,r7,pc
		
		//Silent_flag = 1;
	}
	else
	{
		log("TransmitControl error");
8000254c:	48 8c       	lddpc	r12,8000256c <TransmitControl_reply_func+0x5c>
8000254e:	f0 1f 00 04 	mcall	8000255c <TransmitControl_reply_func+0x4c>
80002552:	e3 cd 80 80 	ldm	sp++,r7,pc
80002556:	00 00       	add	r0,r0
80002558:	80 00       	ld.sh	r0,r0[0x0]
8000255a:	c4 34       	brge	800025e0 <Volume_reply_func+0x40>
8000255c:	80 00       	ld.sh	r0,r0[0x0]
8000255e:	60 04       	ld.w	r4,r0[0x0]
80002560:	80 00       	ld.sh	r0,r0[0x0]
80002562:	c4 50       	breq	800025ec <Volume_reply_func+0x4c>
80002564:	80 00       	ld.sh	r0,r0[0x0]
80002566:	c4 64       	brge	800025f2 <Volume_reply_func+0x52>
80002568:	80 00       	ld.sh	r0,r0[0x0]
8000256a:	c4 80       	breq	800025fa <Volume_reply_func+0x5a>
8000256c:	80 00       	ld.sh	r0,r0[0x0]
8000256e:	c4 90       	breq	80002600 <Volume_reply_func+0x60>

80002570 <AudioRoutingControl_reply_func>:
	
}


void AudioRoutingControl_reply_func(xcmp_fragment_t * xcmp)
{
80002570:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
80002572:	19 a9       	ld.ub	r9,r12[0x2]
80002574:	30 08       	mov	r8,0
80002576:	f0 09 18 00 	cp.b	r9,r8
8000257a:	c0 71       	brne	80002588 <AudioRoutingControl_reply_func+0x18>
	{
		log("AudioRouting OK");
8000257c:	48 5c       	lddpc	r12,80002590 <AudioRoutingControl_reply_func+0x20>
8000257e:	f0 1f 00 06 	mcall	80002594 <AudioRoutingControl_reply_func+0x24>
		xcmp_IdleTestTone();//提示通道配置成功
80002582:	f0 1f 00 06 	mcall	80002598 <AudioRoutingControl_reply_func+0x28>
80002586:	d8 02       	popm	pc
		//xcmp_IdleTestTone();
		//Speaker_is_unmute = 1;
	}
	else
	{
		log("AudioRouting error");
80002588:	48 5c       	lddpc	r12,8000259c <AudioRoutingControl_reply_func+0x2c>
8000258a:	f0 1f 00 03 	mcall	80002594 <AudioRoutingControl_reply_func+0x24>
8000258e:	d8 02       	popm	pc
80002590:	80 00       	ld.sh	r0,r0[0x0]
80002592:	c4 a8       	rjmp	80002626 <spk_brdcst_func+0x22>
80002594:	80 00       	ld.sh	r0,r0[0x0]
80002596:	60 04       	ld.w	r4,r0[0x0]
80002598:	80 00       	ld.sh	r0,r0[0x0]
8000259a:	40 18       	lddsp	r8,sp[0x4]
8000259c:	80 00       	ld.sh	r0,r0[0x0]
8000259e:	c4 b8       	rjmp	80002634 <spk_brdcst_func+0x30>

800025a0 <Volume_reply_func>:
	
}


void Volume_reply_func(xcmp_fragment_t * xcmp)
{
800025a0:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	VolumeControl_reply_t *ptr = (VolumeControl_reply_t* )xcmp->u8;
800025a4:	f8 c7 ff fe 	sub	r7,r12,-2
	
		if (ptr->Result == xcmp_Res_Success)
800025a8:	0f 89       	ld.ub	r9,r7[0x0]
800025aa:	30 08       	mov	r8,0
800025ac:	f0 09 18 00 	cp.b	r9,r8
800025b0:	c1 b1       	brne	800025e6 <Volume_reply_func+0x46>
		{
			if (ptr->Function == Enable_IntelligentAudio)
800025b2:	0f b8       	ld.ub	r8,r7[0x3]
800025b4:	31 09       	mov	r9,16
800025b6:	f2 08 18 00 	cp.b	r8,r9
800025ba:	c0 f1       	brne	800025d8 <Volume_reply_func+0x38>
			{
				log("\n\r Enable_IA OK \n\r");
800025bc:	48 dc       	lddpc	r12,800025f0 <Volume_reply_func+0x50>
800025be:	f0 1f 00 0e 	mcall	800025f4 <Volume_reply_func+0x54>
				log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
800025c2:	0f 99       	ld.ub	r9,r7[0x1]
800025c4:	0f a8       	ld.ub	r8,r7[0x2]
800025c6:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800025ca:	1a d8       	st.w	--sp,r8
800025cc:	48 bc       	lddpc	r12,800025f8 <Volume_reply_func+0x58>
800025ce:	f0 1f 00 0a 	mcall	800025f4 <Volume_reply_func+0x54>
800025d2:	2f fd       	sub	sp,-4
800025d4:	e3 cd 80 80 	ldm	sp++,r7,pc
	
			}
			else
			{
				
				log("\n\r VolumeControl: %x \n\r", ptr->Function);
800025d8:	1a d8       	st.w	--sp,r8
800025da:	48 9c       	lddpc	r12,800025fc <Volume_reply_func+0x5c>
800025dc:	f0 1f 00 06 	mcall	800025f4 <Volume_reply_func+0x54>
800025e0:	2f fd       	sub	sp,-4
800025e2:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		
		else
		{
			log("\n\r Enable_IA error \n\r");
800025e6:	48 7c       	lddpc	r12,80002600 <Volume_reply_func+0x60>
800025e8:	f0 1f 00 03 	mcall	800025f4 <Volume_reply_func+0x54>
800025ec:	e3 cd 80 80 	ldm	sp++,r7,pc
800025f0:	80 00       	ld.sh	r0,r0[0x0]
800025f2:	c4 cc       	rcall	8000268a <mic_brdcst_func+0x6>
800025f4:	80 00       	ld.sh	r0,r0[0x0]
800025f6:	60 04       	ld.w	r4,r0[0x0]
800025f8:	80 00       	ld.sh	r0,r0[0x0]
800025fa:	c4 e0       	breq	80002696 <mic_brdcst_func+0x12>
800025fc:	80 00       	ld.sh	r0,r0[0x0]
800025fe:	c4 fc       	rcall	8000269c <mic_brdcst_func+0x18>
80002600:	80 00       	ld.sh	r0,r0[0x0]
80002602:	c5 14       	brge	800026a4 <mic_brdcst_func+0x20>

80002604 <spk_brdcst_func>:
		log("spk error");
	}
}

void spk_brdcst_func(xcmp_fragment_t * xcmp)
{
80002604:	d4 01       	pushm	lr
	if (xcmp->u8[3] == xcmp_Res_Success)//0x0000:mute
80002606:	19 d9       	ld.ub	r9,r12[0x5]
80002608:	30 08       	mov	r8,0
8000260a:	f0 09 18 00 	cp.b	r9,r8
8000260e:	c0 81       	brne	8000261e <spk_brdcst_func+0x1a>
	{
		Speaker_is_unmute =0;
80002610:	10 99       	mov	r9,r8
80002612:	48 78       	lddpc	r8,8000262c <spk_brdcst_func+0x28>
80002614:	b0 89       	st.b	r8[0x0],r9
		//Silent_flag = 0;
		log("spk_s_close ");
80002616:	48 7c       	lddpc	r12,80002630 <spk_brdcst_func+0x2c>
80002618:	f0 1f 00 07 	mcall	80002634 <spk_brdcst_func+0x30>
8000261c:	d8 02       	popm	pc
		
	}
	else
	{
		//Silent_flag = 1;
		Speaker_is_unmute = 1;
8000261e:	30 19       	mov	r9,1
80002620:	48 38       	lddpc	r8,8000262c <spk_brdcst_func+0x28>
80002622:	b0 89       	st.b	r8[0x0],r9
		log("spk_s_open ");	
80002624:	48 5c       	lddpc	r12,80002638 <spk_brdcst_func+0x34>
80002626:	f0 1f 00 04 	mcall	80002634 <spk_brdcst_func+0x30>
8000262a:	d8 02       	popm	pc
8000262c:	00 00       	add	r0,r0
8000262e:	0a 38       	cp.w	r8,r5
80002630:	80 00       	ld.sh	r0,r0[0x0]
80002632:	c5 2c       	rcall	800026d6 <mic_brdcst_func+0x52>
80002634:	80 00       	ld.sh	r0,r0[0x0]
80002636:	60 04       	ld.w	r4,r0[0x0]
80002638:	80 00       	ld.sh	r0,r0[0x0]
8000263a:	c5 3c       	rcall	800026e0 <mic_reply_func+0x4>

8000263c <spk_reply_func>:
			
	
}

void spk_reply_func(xcmp_fragment_t * xcmp)
{
8000263c:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
8000263e:	19 a9       	ld.ub	r9,r12[0x2]
80002640:	30 08       	mov	r8,0
80002642:	f0 09 18 00 	cp.b	r9,r8
80002646:	c0 f1       	brne	80002664 <spk_reply_func+0x28>
	{
		
		if(xcmp->u8[4])
80002648:	19 e9       	ld.ub	r9,r12[0x6]
8000264a:	f0 09 18 00 	cp.b	r9,r8
8000264e:	c0 40       	breq	80002656 <spk_reply_func+0x1a>
		{
			Speaker_is_unmute = 1;
80002650:	30 19       	mov	r9,1
80002652:	48 98       	lddpc	r8,80002674 <spk_reply_func+0x38>
80002654:	b0 89       	st.b	r8[0x0],r9
			
			//Silent_flag = 1;
		}
		log("spk OK -st%2x", xcmp->u8[4] );
80002656:	19 e8       	ld.ub	r8,r12[0x6]
80002658:	1a d8       	st.w	--sp,r8
8000265a:	48 8c       	lddpc	r12,80002678 <spk_reply_func+0x3c>
8000265c:	f0 1f 00 08 	mcall	8000267c <spk_reply_func+0x40>
80002660:	2f fd       	sub	sp,-4
80002662:	d8 02       	popm	pc
		
	}
	else
	{
		Speaker_is_unmute = 0;
80002664:	30 09       	mov	r9,0
80002666:	48 48       	lddpc	r8,80002674 <spk_reply_func+0x38>
80002668:	b0 89       	st.b	r8[0x0],r9
		log("spk error");
8000266a:	48 6c       	lddpc	r12,80002680 <spk_reply_func+0x44>
8000266c:	f0 1f 00 04 	mcall	8000267c <spk_reply_func+0x40>
80002670:	d8 02       	popm	pc
80002672:	00 00       	add	r0,r0
80002674:	00 00       	add	r0,r0
80002676:	0a 38       	cp.w	r8,r5
80002678:	80 00       	ld.sh	r0,r0[0x0]
8000267a:	c5 48       	rjmp	80002722 <mic_reply_func+0x46>
8000267c:	80 00       	ld.sh	r0,r0[0x0]
8000267e:	60 04       	ld.w	r4,r0[0x0]
80002680:	80 00       	ld.sh	r0,r0[0x0]
80002682:	c5 58       	rjmp	8000272c <mic_reply_func+0x50>

80002684 <mic_brdcst_func>:
	
	
}

void mic_brdcst_func(xcmp_fragment_t * xcmp)
{
80002684:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_brdcast_t *ptr = (MicControl_brdcast_t* )xcmp->u8;
80002688:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r Mic_brdcst \n\r");		
	//log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
	//log("\n\r Signal_type: %x \n\r " ,  ptr->Signaling_Type);
	if (ptr->Mic_State == 0x00)
8000268c:	0f a9       	ld.ub	r9,r7[0x2]
8000268e:	30 08       	mov	r8,0
80002690:	f0 09 18 00 	cp.b	r9,r8
80002694:	c0 71       	brne	800026a2 <mic_brdcst_func+0x1e>
	{
		log("\n\r Mic_Disabled \n\r");	
80002696:	48 dc       	lddpc	r12,800026c8 <mic_brdcst_func+0x44>
80002698:	f0 1f 00 0d 	mcall	800026cc <mic_brdcst_func+0x48>
		Mic_is_Enabled = 0;
8000269c:	30 09       	mov	r9,0
8000269e:	48 d8       	lddpc	r8,800026d0 <mic_brdcst_func+0x4c>
800026a0:	b0 89       	st.b	r8[0x0],r9
	} 
	if(ptr->Mic_State == 0x11)
800026a2:	0f a9       	ld.ub	r9,r7[0x2]
800026a4:	31 18       	mov	r8,17
800026a6:	f0 09 18 00 	cp.b	r9,r8
800026aa:	c0 d1       	brne	800026c4 <mic_brdcst_func+0x40>
	{
		log("\n\r Mic_Enabled \n\r");
800026ac:	48 ac       	lddpc	r12,800026d4 <mic_brdcst_func+0x50>
800026ae:	f0 1f 00 08 	mcall	800026cc <mic_brdcst_func+0x48>
		Mic_is_Enabled = 1;
800026b2:	48 89       	lddpc	r9,800026d0 <mic_brdcst_func+0x4c>
800026b4:	30 18       	mov	r8,1
800026b6:	b2 88       	st.b	r9[0x0],r8
		
		if ((Mic_is_Enabled == 1) && (Call_Begin == 1))
800026b8:	13 89       	ld.ub	r9,r9[0x0]
800026ba:	f0 09 18 00 	cp.b	r9,r8
800026be:	c0 31       	brne	800026c4 <mic_brdcst_func+0x40>
800026c0:	48 68       	lddpc	r8,800026d8 <mic_brdcst_func+0x54>
800026c2:	11 88       	ld.ub	r8,r8[0x0]
800026c4:	e3 cd 80 80 	ldm	sp++,r7,pc
800026c8:	80 00       	ld.sh	r0,r0[0x0]
800026ca:	c5 64       	brge	80002776 <dcm_brdcst_func+0x6>
800026cc:	80 00       	ld.sh	r0,r0[0x0]
800026ce:	60 04       	ld.w	r4,r0[0x0]
800026d0:	00 00       	add	r0,r0
800026d2:	0a 51       	eor	r1,r5
800026d4:	80 00       	ld.sh	r0,r0[0x0]
800026d6:	c5 78       	rjmp	80002784 <dcm_brdcst_func+0x14>
800026d8:	00 00       	add	r0,r0
800026da:	0a 4d       	or	sp,r5

800026dc <mic_reply_func>:
	
	
}

void mic_reply_func(xcmp_fragment_t * xcmp)
{
800026dc:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_reply_t *ptr = (MicControl_reply_t* )xcmp->u8;
800026e0:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Mic_reply \n\r");
800026e4:	49 ac       	lddpc	r12,8000274c <mic_reply_func+0x70>
800026e6:	f0 1f 00 1b 	mcall	80002750 <mic_reply_func+0x74>
	if (ptr->Result == 0x00)
800026ea:	0f 89       	ld.ub	r9,r7[0x0]
800026ec:	30 08       	mov	r8,0
800026ee:	f0 09 18 00 	cp.b	r9,r8
800026f2:	c2 71       	brne	80002740 <mic_reply_func+0x64>
	{
		
		if (ptr->Function == Mic_Disable)
800026f4:	0f 98       	ld.ub	r8,r7[0x1]
800026f6:	30 29       	mov	r9,2
800026f8:	f2 08 18 00 	cp.b	r8,r9
800026fc:	c1 b1       	brne	80002732 <mic_reply_func+0x56>
		{
		
			log("\n\r Mic_close_ok \n\r " );
800026fe:	49 6c       	lddpc	r12,80002754 <mic_reply_func+0x78>
80002700:	f0 1f 00 14 	mcall	80002750 <mic_reply_func+0x74>
			log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
80002704:	0f a8       	ld.ub	r8,r7[0x2]
80002706:	1a d8       	st.w	--sp,r8
80002708:	49 4c       	lddpc	r12,80002758 <mic_reply_func+0x7c>
8000270a:	f0 1f 00 12 	mcall	80002750 <mic_reply_func+0x74>
			log("\n\r Signaling_type: %x \n\r " ,  ptr->Signaling_Type);
8000270e:	0f b8       	ld.ub	r8,r7[0x3]
80002710:	1a d8       	st.w	--sp,r8
80002712:	49 3c       	lddpc	r12,8000275c <mic_reply_func+0x80>
80002714:	f0 1f 00 0f 	mcall	80002750 <mic_reply_func+0x74>
			log("\n\r Mic_state: %x \n\r " ,  ptr->Mic_State);
80002718:	0f c8       	ld.ub	r8,r7[0x4]
8000271a:	1a d8       	st.w	--sp,r8
8000271c:	49 1c       	lddpc	r12,80002760 <mic_reply_func+0x84>
8000271e:	f0 1f 00 0d 	mcall	80002750 <mic_reply_func+0x74>
			log("\n\r Gain_offset: %x \n\r " ,  ptr->Gain_Offset);
80002722:	0f d8       	ld.ub	r8,r7[0x5]
80002724:	1a d8       	st.w	--sp,r8
80002726:	49 0c       	lddpc	r12,80002764 <mic_reply_func+0x88>
80002728:	f0 1f 00 0a 	mcall	80002750 <mic_reply_func+0x74>
8000272c:	2f cd       	sub	sp,-16
8000272e:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else
		{
			log("\n\r Mic_function: %x \n\r ", ptr->Function );
80002732:	1a d8       	st.w	--sp,r8
80002734:	48 dc       	lddpc	r12,80002768 <mic_reply_func+0x8c>
80002736:	f0 1f 00 07 	mcall	80002750 <mic_reply_func+0x74>
8000273a:	2f fd       	sub	sp,-4
8000273c:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else 
	{
		
	
		log("\n\r Mic error \n\r");
80002740:	48 bc       	lddpc	r12,8000276c <mic_reply_func+0x90>
80002742:	f0 1f 00 04 	mcall	80002750 <mic_reply_func+0x74>
80002746:	e3 cd 80 80 	ldm	sp++,r7,pc
8000274a:	00 00       	add	r0,r0
8000274c:	80 00       	ld.sh	r0,r0[0x0]
8000274e:	c5 8c       	rcall	800027fe <dcm_reply_func+0x46>
80002750:	80 00       	ld.sh	r0,r0[0x0]
80002752:	60 04       	ld.w	r4,r0[0x0]
80002754:	80 00       	ld.sh	r0,r0[0x0]
80002756:	c5 9c       	rcall	80002808 <dcm_reply_func+0x50>
80002758:	80 00       	ld.sh	r0,r0[0x0]
8000275a:	c5 b0       	breq	80002810 <dcm_reply_func+0x58>
8000275c:	80 00       	ld.sh	r0,r0[0x0]
8000275e:	c5 c4       	brge	80002816 <dcm_reply_func+0x5e>
80002760:	80 00       	ld.sh	r0,r0[0x0]
80002762:	c5 e0       	breq	8000281e <dcm_reply_func+0x66>
80002764:	80 00       	ld.sh	r0,r0[0x0]
80002766:	c5 f8       	rjmp	80002824 <ToneControl_reply_func+0x4>
80002768:	80 00       	ld.sh	r0,r0[0x0]
8000276a:	c6 10       	breq	8000282c <ToneControl_reply_func+0xc>
8000276c:	80 00       	ld.sh	r0,r0[0x0]
8000276e:	c6 28       	rjmp	80002832 <ToneControl_reply_func+0x12>

80002770 <dcm_brdcst_func>:
	}
}


void dcm_brdcst_func(xcmp_fragment_t * xcmp)
{
80002770:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	DeviceControlMode_brdcst_t *ptr = (DeviceControlMode_brdcst_t* )xcmp->u8;
80002774:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Dcm_brdcst \n\r");		
80002778:	48 bc       	lddpc	r12,800027a4 <dcm_brdcst_func+0x34>
8000277a:	f0 1f 00 0c 	mcall	800027a8 <dcm_brdcst_func+0x38>
	log("\n\r Function: %x \n\r " ,  ptr->Function);
8000277e:	0f 88       	ld.ub	r8,r7[0x0]
80002780:	1a d8       	st.w	--sp,r8
80002782:	48 bc       	lddpc	r12,800027ac <dcm_brdcst_func+0x3c>
80002784:	f0 1f 00 09 	mcall	800027a8 <dcm_brdcst_func+0x38>
	log("\n\r ControlType: %x \n\r " ,  ptr->ControlType);
80002788:	0f a8       	ld.ub	r8,r7[0x2]
8000278a:	1a d8       	st.w	--sp,r8
8000278c:	48 9c       	lddpc	r12,800027b0 <dcm_brdcst_func+0x40>
8000278e:	f0 1f 00 07 	mcall	800027a8 <dcm_brdcst_func+0x38>
	log("\n\r ControlTypeSize: %x \n\r " ,  ptr->ControlTypeSize);
80002792:	0f 98       	ld.ub	r8,r7[0x1]
80002794:	1a d8       	st.w	--sp,r8
80002796:	48 8c       	lddpc	r12,800027b4 <dcm_brdcst_func+0x44>
80002798:	f0 1f 00 04 	mcall	800027a8 <dcm_brdcst_func+0x38>
8000279c:	2f dd       	sub	sp,-12
	
	
}
8000279e:	e3 cd 80 80 	ldm	sp++,r7,pc
800027a2:	00 00       	add	r0,r0
800027a4:	80 00       	ld.sh	r0,r0[0x0]
800027a6:	c6 38       	rjmp	8000286c <app_payload_rx_proc+0x24>
800027a8:	80 00       	ld.sh	r0,r0[0x0]
800027aa:	60 04       	ld.w	r4,r0[0x0]
800027ac:	80 00       	ld.sh	r0,r0[0x0]
800027ae:	c6 4c       	rcall	80002876 <app_payload_rx_proc+0x2e>
800027b0:	80 00       	ld.sh	r0,r0[0x0]
800027b2:	c6 60       	breq	8000287e <app_payload_rx_proc+0x36>
800027b4:	80 00       	ld.sh	r0,r0[0x0]
800027b6:	c6 78       	rjmp	80002884 <app_payload_rx_proc+0x3c>

800027b8 <dcm_reply_func>:
		log("Tone error");
	}
}

void dcm_reply_func(xcmp_fragment_t * xcmp)
{
800027b8:	eb cd 40 80 	pushm	r7,lr
800027bc:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
800027be:	19 a9       	ld.ub	r9,r12[0x2]
800027c0:	30 08       	mov	r8,0
800027c2:	f0 09 18 00 	cp.b	r9,r8
800027c6:	c1 b1       	brne	800027fc <dcm_reply_func+0x44>
	{
		if(xcmp->u8[1] == DCM_ENTER)
800027c8:	19 b8       	ld.ub	r8,r12[0x3]
800027ca:	30 19       	mov	r9,1
800027cc:	f2 08 18 00 	cp.b	r8,r9
800027d0:	c0 51       	brne	800027da <dcm_reply_func+0x22>
		{
			log("\n\r Dcm-Enter OK \n\r");
800027d2:	48 ec       	lddpc	r12,80002808 <dcm_reply_func+0x50>
800027d4:	f0 1f 00 0e 	mcall	8000280c <dcm_reply_func+0x54>
800027d8:	c0 a8       	rjmp	800027ec <dcm_reply_func+0x34>
			
		}
		else if (xcmp->u8[1] == DCM_EXIT)
800027da:	58 08       	cp.w	r8,0
800027dc:	c0 51       	brne	800027e6 <dcm_reply_func+0x2e>
		{
			log("\n\r Dcm-Exit OK \n\r");
800027de:	48 dc       	lddpc	r12,80002810 <dcm_reply_func+0x58>
800027e0:	f0 1f 00 0b 	mcall	8000280c <dcm_reply_func+0x54>
800027e4:	c0 48       	rjmp	800027ec <dcm_reply_func+0x34>
		}
		else
		{
			log("\n\r Dcm-Revoke \n\r");
800027e6:	48 cc       	lddpc	r12,80002814 <dcm_reply_func+0x5c>
800027e8:	f0 1f 00 09 	mcall	8000280c <dcm_reply_func+0x54>
		}
		
		log("dcm OK-mo%X", xcmp->u8[3]);
800027ec:	0f d8       	ld.ub	r8,r7[0x5]
800027ee:	1a d8       	st.w	--sp,r8
800027f0:	48 ac       	lddpc	r12,80002818 <dcm_reply_func+0x60>
800027f2:	f0 1f 00 07 	mcall	8000280c <dcm_reply_func+0x54>
800027f6:	2f fd       	sub	sp,-4
800027f8:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		log("dcm error");
800027fc:	48 8c       	lddpc	r12,8000281c <dcm_reply_func+0x64>
800027fe:	f0 1f 00 04 	mcall	8000280c <dcm_reply_func+0x54>
80002802:	e3 cd 80 80 	ldm	sp++,r7,pc
80002806:	00 00       	add	r0,r0
80002808:	80 00       	ld.sh	r0,r0[0x0]
8000280a:	c6 94       	brge	800028dc <CalculateBurst+0x10>
8000280c:	80 00       	ld.sh	r0,r0[0x0]
8000280e:	60 04       	ld.w	r4,r0[0x0]
80002810:	80 00       	ld.sh	r0,r0[0x0]
80002812:	c6 a8       	rjmp	800028e6 <CalculateBurst+0x1a>
80002814:	80 00       	ld.sh	r0,r0[0x0]
80002816:	c6 bc       	rcall	800028ec <payload_init+0x4>
80002818:	80 00       	ld.sh	r0,r0[0x0]
8000281a:	c6 d0       	breq	800028f4 <payload_init+0xc>
8000281c:	80 00       	ld.sh	r0,r0[0x0]
8000281e:	c6 dc       	rcall	800028f8 <payload_init+0x10>

80002820 <ToneControl_reply_func>:
			}
		}
}

void ToneControl_reply_func(xcmp_fragment_t * xcmp)
{
80002820:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
80002822:	19 a9       	ld.ub	r9,r12[0x2]
80002824:	30 08       	mov	r8,0
80002826:	f0 09 18 00 	cp.b	r9,r8
8000282a:	c0 51       	brne	80002834 <ToneControl_reply_func+0x14>
	{		
		log("Tone OK");
8000282c:	48 4c       	lddpc	r12,8000283c <ToneControl_reply_func+0x1c>
8000282e:	f0 1f 00 05 	mcall	80002840 <ToneControl_reply_func+0x20>
80002832:	d8 02       	popm	pc
		//fl_write("/test.txt", FILE_END, (void *)"send tone ok\r\n", sizeof("send tone ok\r\n") - 1);
	}
	else
	{
		log("Tone error");
80002834:	48 4c       	lddpc	r12,80002844 <ToneControl_reply_func+0x24>
80002836:	f0 1f 00 03 	mcall	80002840 <ToneControl_reply_func+0x20>
8000283a:	d8 02       	popm	pc
8000283c:	80 00       	ld.sh	r0,r0[0x0]
8000283e:	c6 e8       	rjmp	8000291a <payload_init+0x32>
80002840:	80 00       	ld.sh	r0,r0[0x0]
80002842:	60 04       	ld.w	r4,r0[0x0]
80002844:	80 00       	ld.sh	r0,r0[0x0]
80002846:	c6 f0       	breq	80002924 <payload_rx_process+0x4>

80002848 <app_payload_rx_proc>:
	}
}


static void app_payload_rx_proc(void  * payload)
{
80002848:	eb cd 40 80 	pushm	r7,lr
8000284c:	18 97       	mov	r7,r12
	static  U8 times_counter = 0;
	
	times_counter++;
8000284e:	48 c9       	lddpc	r9,8000287c <app_payload_rx_proc+0x34>
80002850:	13 88       	ld.ub	r8,r9[0x0]
80002852:	2f f8       	sub	r8,-1
80002854:	b2 88       	st.b	r9[0x0],r8
	if (times_counter == 3)
80002856:	30 39       	mov	r9,3
80002858:	f2 08 18 00 	cp.b	r8,r9
8000285c:	c0 71       	brne	8000286a <app_payload_rx_proc+0x22>
	{
		times_counter = 0 ;
8000285e:	30 09       	mov	r9,0
80002860:	48 78       	lddpc	r8,8000287c <app_payload_rx_proc+0x34>
80002862:	b0 89       	st.b	r8[0x0],r9
		log("\n\r w: \n\r");
80002864:	48 7c       	lddpc	r12,80002880 <app_payload_rx_proc+0x38>
80002866:	f0 1f 00 08 	mcall	80002884 <app_payload_rx_proc+0x3c>
	}
	//log("\n\r w: \n\r");
	if (AMBE_tx_flag)//本地发送方的mic录音
8000286a:	48 88       	lddpc	r8,80002888 <app_payload_rx_proc+0x40>
8000286c:	11 88       	ld.ub	r8,r8[0x0]
	{
		//fl_write("PCMvo.pcm", FILE_END, payload, MAX_PAYLOAD_BUFF_SIZE * 2);
	}
	
	//payload_fragment_t * ptr = (payload_fragment_t *)payload;
	set_payload_idle(payload);
8000286e:	48 88       	lddpc	r8,8000288c <app_payload_rx_proc+0x44>
80002870:	70 0c       	ld.w	r12,r8[0x0]
80002872:	0e 9b       	mov	r11,r7
80002874:	f0 1f 00 07 	mcall	80002890 <app_payload_rx_proc+0x48>

}
80002878:	e3 cd 80 80 	ldm	sp++,r7,pc
8000287c:	00 00       	add	r0,r0
8000287e:	0a 50       	eor	r0,r5
80002880:	80 00       	ld.sh	r0,r0[0x0]
80002882:	c6 fc       	rcall	80002960 <payload_rx_process+0x40>
80002884:	80 00       	ld.sh	r0,r0[0x0]
80002886:	60 04       	ld.w	r4,r0[0x0]
80002888:	00 00       	add	r0,r0
8000288a:	0a 52       	eor	r2,r5
8000288c:	00 00       	add	r0,r0
8000288e:	0a 6c       	and	r12,r5
80002890:	80 00       	ld.sh	r0,r0[0x0]
80002892:	29 c0       	sub	r0,-100

80002894 <DeviceInitializationStatus_brdcst_func>:
static void app_payload_tx_proc(void  * payload);

//app func--list

void DeviceInitializationStatus_brdcst_func(xcmp_fragment_t  * xcmp)
{
80002894:	d4 01       	pushm	lr
	if (xcmp->u8[4] == 0x01)
80002896:	19 e8       	ld.ub	r8,r12[0x6]
80002898:	30 19       	mov	r9,1
8000289a:	f2 08 18 00 	cp.b	r8,r9
8000289e:	c0 61       	brne	800028aa <DeviceInitializationStatus_brdcst_func+0x16>
	{
		bunchofrandomstatusflags |= 0x01;  //Need do nothing else.
800028a0:	48 98       	lddpc	r8,800028c4 <DeviceInitializationStatus_brdcst_func+0x30>
800028a2:	70 09       	ld.w	r9,r8[0x0]
800028a4:	a1 a9       	sbr	r9,0x0
800028a6:	91 09       	st.w	r8[0x0],r9
800028a8:	d8 02       	popm	pc
	}
	else if(xcmp->u8[4] != 0x02)
800028aa:	30 29       	mov	r9,2
800028ac:	f2 08 18 00 	cp.b	r8,r9
800028b0:	c0 80       	breq	800028c0 <DeviceInitializationStatus_brdcst_func+0x2c>
	{
		bunchofrandomstatusflags  &= 0xFFFFFFFC; //Device Init no longer Complete.
800028b2:	48 58       	lddpc	r8,800028c4 <DeviceInitializationStatus_brdcst_func+0x30>
800028b4:	70 09       	ld.w	r9,r8[0x0]
800028b6:	e0 19 ff fc 	andl	r9,0xfffc
800028ba:	91 09       	st.w	r8[0x0],r9
		xcmp_DeviceInitializationStatus_request();
800028bc:	f0 1f 00 03 	mcall	800028c8 <DeviceInitializationStatus_brdcst_func+0x34>
800028c0:	d8 02       	popm	pc
800028c2:	00 00       	add	r0,r0
800028c4:	00 00       	add	r0,r0
800028c6:	0d 70       	ld.ub	r0,--r6
800028c8:	80 00       	ld.sh	r0,r0[0x0]
800028ca:	3f 6c       	mov	r12,-10

800028cc <CalculateBurst>:
Calls:
Called By: phy_payload_rx
*/

volatile RxAMBEBurstType CalculateBurst(U8 vf_sn)
{
800028cc:	20 1c       	sub	r12,1
800028ce:	5c 5c       	castu.b	r12
800028d0:	31 18       	mov	r8,17
800028d2:	f0 0c 18 00 	cp.b	r12,r8
800028d6:	e0 88 00 03 	brls	800028dc <CalculateBurst+0x10>
800028da:	5e fd       	retal	0
800028dc:	48 28       	lddpc	r8,800028e4 <CalculateBurst+0x18>
800028de:	f0 0c 03 2c 	ld.w	r12,r8[r12<<0x2]
			Burst_ID = 0x00;
			return VOICE_WATING;
		
	}
	
}
800028e2:	5e fc       	retal	r12
800028e4:	80 00       	ld.sh	r0,r0[0x0]
800028e6:	c7 10       	breq	800029c8 <set_idle_store+0x8>

800028e8 <payload_init>:
	Create the corresponding task;
Calls: xTaskCreate--freertos
Called By:app_init -- app.c
*/
void payload_init(void ( *payload_rx_func)(void * ), void ( *payload_tx_func)(void * ) )
{				
800028e8:	d4 01       	pushm	lr
	payload_rx_exec = payload_rx_func;
800028ea:	48 98       	lddpc	r8,8000290c <payload_init+0x24>
800028ec:	91 0c       	st.w	r8[0x0],r12
	payload_tx_exec = payload_tx_func;
800028ee:	48 98       	lddpc	r8,80002910 <payload_init+0x28>
800028f0:	91 0b       	st.w	r8[0x0],r11
	
	
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
800028f2:	30 09       	mov	r9,0
800028f4:	1a d9       	st.w	--sp,r9
800028f6:	1a d9       	st.w	--sp,r9
800028f8:	1a d9       	st.w	--sp,r9
800028fa:	30 28       	mov	r8,2
800028fc:	e0 6a 04 00 	mov	r10,1024
80002900:	48 5b       	lddpc	r11,80002914 <payload_init+0x2c>
80002902:	48 6c       	lddpc	r12,80002918 <payload_init+0x30>
80002904:	f0 1f 00 06 	mcall	8000291c <payload_init+0x34>
80002908:	2f dd       	sub	sp,-12
	//,  2
	//,  NULL
	//);
	//
	
}
8000290a:	d8 02       	popm	pc
8000290c:	00 00       	add	r0,r0
8000290e:	0a 58       	eor	r8,r5
80002910:	00 00       	add	r0,r0
80002912:	0a 5c       	eor	r12,r5
80002914:	80 00       	ld.sh	r0,r0[0x0]
80002916:	c7 58       	rjmp	80002a00 <phy_tx+0x20>
80002918:	80 00       	ld.sh	r0,r0[0x0]
8000291a:	29 20       	sub	r0,-110
8000291c:	80 00       	ld.sh	r0,r0[0x0]
8000291e:	5c 40       	abs	r0

80002920 <payload_rx_process>:
Description: Receive the payload
Calls:
Called By:task
*/
static void payload_rx_process(void * pvParameters)
{
80002920:	eb cd 40 f8 	pushm	r3-r7,lr
80002924:	20 1d       	sub	sp,4
	/*To store the elements in the queue*/
	U16  * payload_ptr;
		
	if(NULL ==   phy_payload_frame_rx)
80002926:	48 e8       	lddpc	r8,8000295c <payload_rx_process+0x3c>
80002928:	70 08       	ld.w	r8,r8[0x0]
8000292a:	58 08       	cp.w	r8,0
8000292c:	c0 71       	brne	8000293a <payload_rx_process+0x1a>
	{
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
8000292e:	30 4b       	mov	r11,4
80002930:	30 5c       	mov	r12,5
80002932:	f0 1f 00 0c 	mcall	80002960 <payload_rx_process+0x40>
80002936:	48 a8       	lddpc	r8,8000295c <payload_rx_process+0x3c>
80002938:	91 0c       	st.w	r8[0x0],r12
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_rx, &payload_ptr,portMAX_DELAY ))
8000293a:	48 96       	lddpc	r6,8000295c <payload_rx_process+0x3c>
8000293c:	30 05       	mov	r5,0
8000293e:	3f f4       	mov	r4,-1
		{			
			payload_rx_exec(payload_ptr);//app_payload_rx_proc();
80002940:	48 93       	lddpc	r3,80002964 <payload_rx_process+0x44>
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_rx, &payload_ptr,portMAX_DELAY ))
80002942:	6c 0c       	ld.w	r12,r6[0x0]
80002944:	0a 99       	mov	r9,r5
80002946:	08 9a       	mov	r10,r4
80002948:	1a 9b       	mov	r11,sp
8000294a:	f0 1f 00 08 	mcall	80002968 <payload_rx_process+0x48>
8000294e:	58 1c       	cp.w	r12,1
80002950:	cf 91       	brne	80002942 <payload_rx_process+0x22>
		{			
			payload_rx_exec(payload_ptr);//app_payload_rx_proc();
80002952:	66 08       	ld.w	r8,r3[0x0]
80002954:	40 0c       	lddsp	r12,sp[0x0]
80002956:	5d 18       	icall	r8
80002958:	cf 5b       	rjmp	80002942 <payload_rx_process+0x22>
8000295a:	00 00       	add	r0,r0
8000295c:	00 00       	add	r0,r0
8000295e:	0a 88       	andn	r8,r5
80002960:	80 00       	ld.sh	r0,r0[0x0]
80002962:	55 6c       	stdsp	sp[0x158],r12
80002964:	00 00       	add	r0,r0
80002966:	0a 58       	eor	r8,r5
80002968:	80 00       	ld.sh	r0,r0[0x0]
8000296a:	52 60       	stdsp	sp[0x98],r0

8000296c <set_idle_store_isr>:
{
	xQueueSend(store, &ptr, 0);
}

void set_idle_store_isr(xQueueHandle store, void * ptr)
{
8000296c:	d4 01       	pushm	lr
8000296e:	20 2d       	sub	sp,8
80002970:	50 0b       	stdsp	sp[0x0],r11
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002972:	30 09       	mov	r9,0
80002974:	fa ca ff f8 	sub	r10,sp,-8
80002978:	14 d9       	st.w	--r10,r9
	xQueueSendFromISR(store, &ptr, &xHigherPriorityTaskWoken);
8000297a:	1a 9b       	mov	r11,sp
8000297c:	f0 1f 00 02 	mcall	80002984 <set_idle_store_isr+0x18>
}
80002980:	2f ed       	sub	sp,-8
80002982:	d8 02       	popm	pc
80002984:	80 00       	ld.sh	r0,r0[0x0]
80002986:	54 1c       	stdsp	sp[0x104],r12

80002988 <phy_rx>:
	xQueueSendFromISR -- freertos
Called By: phy_xnl_rx
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
80002988:	d4 01       	pushm	lr
8000298a:	20 2d       	sub	sp,8
8000298c:	50 0c       	stdsp	sp[0x0],r12
	//memcpy(xx, phy_ptr, sizeof(phy_fragment_t));
	//set_phy_idle_isr(&phy_ptr, &xHigherPriorityTaskWoken);
	
	Bool res = FALSE;
	
	if(NULL == phy_ptr)
8000298e:	58 0c       	cp.w	r12,0
80002990:	c1 10       	breq	800029b2 <phy_rx+0x2a>
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
    /*variables are used to store the push result in interrupt*/
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002992:	30 08       	mov	r8,0
80002994:	50 18       	stdsp	sp[0x4],r8
	if(NULL == phy_ptr)
	{
		return;
	}
	
    U16 phy_ctrl = phy_ptr->xnl_fragment.phy_header.phy_control;
80002996:	98 88       	ld.uh	r8,r12[0x0]
80002998:	e2 18 f0 00 	andl	r8,0xf000,COH
8000299c:	e0 48 40 00 	cp.w	r8,16384
800029a0:	c0 91       	brne	800029b2 <phy_rx+0x2a>

    if (XCMPXNL_DATA == (phy_ctrl & 0xF000))
    {
        /*push the xnl packet to queue*/
        if( pdTRUE == xQueueSendFromISR(
800029a2:	48 68       	lddpc	r8,800029b8 <phy_rx+0x30>
800029a4:	70 0c       	ld.w	r12,r8[0x0]
800029a6:	30 09       	mov	r9,0
800029a8:	fa ca ff fc 	sub	r10,sp,-4
800029ac:	1a 9b       	mov	r11,sp
800029ae:	f0 1f 00 04 	mcall	800029bc <phy_rx+0x34>
		}	

    }
		
 
}
800029b2:	2f ed       	sub	sp,-8
800029b4:	d8 02       	popm	pc
800029b6:	00 00       	add	r0,r0
800029b8:	00 00       	add	r0,r0
800029ba:	0a b8       	st.h	r5++,r8
800029bc:	80 00       	ld.sh	r0,r0[0x0]
800029be:	54 1c       	stdsp	sp[0x104],r12

800029c0 <set_idle_store>:
	}
}


void set_idle_store(xQueueHandle store, void * ptr)
{
800029c0:	eb cd 40 80 	pushm	r7,lr
800029c4:	20 1d       	sub	sp,4
800029c6:	fa c7 ff fc 	sub	r7,sp,-4
800029ca:	0e db       	st.w	--r7,r11
	xQueueSend(store, &ptr, 0);
800029cc:	30 09       	mov	r9,0
800029ce:	12 9a       	mov	r10,r9
800029d0:	1a 9b       	mov	r11,sp
800029d2:	f0 1f 00 03 	mcall	800029dc <set_idle_store+0x1c>
}
800029d6:	2f fd       	sub	sp,-4
800029d8:	e3 cd 80 80 	ldm	sp++,r7,pc
800029dc:	80 00       	ld.sh	r0,r0[0x0]
800029de:	54 6c       	stdsp	sp[0x118],r12

800029e0 <phy_tx>:
Calls:   
	xQueueSend -- freertos
Called By: xnl_tx -- xnl.c
*/
void phy_tx(phy_fragment_t * phy)
{	
800029e0:	d4 01       	pushm	lr
800029e2:	20 1d       	sub	sp,4
800029e4:	50 0c       	stdsp	sp[0x0],r12
	
	//phy_fragment_t * phy_ptr = malloc(sizeof(phy_fragment_t));
	//memcpy(phy_ptr, phy, sizeof(phy_fragment_t));
	//log("\n\r T_xcmp:%4x \n\r", phy->xnl_fragment.xnl_payload.xnl_content_data_msg.xcmp_opcode);
	//log("T_xnl-opcode:%4x", xnl->xnl_header.opcode);//log:R_xnl指令	
	if(XCMPXNL_DATA == (phy_ctrl & 0xF000))
800029e6:	98 88       	ld.uh	r8,r12[0x0]
800029e8:	e2 18 f0 00 	andl	r8,0xf000,COH
800029ec:	e0 48 40 00 	cp.w	r8,16384
800029f0:	c0 d1       	brne	80002a0a <phy_tx+0x2a>
	{
		/*push the xnl packet to queue to send */
		if(NULL != phy_xnl_frame_tx)
800029f2:	49 08       	lddpc	r8,80002a30 <phy_tx+0x50>
800029f4:	70 08       	ld.w	r8,r8[0x0]
800029f6:	58 08       	cp.w	r8,0
800029f8:	c1 a0       	breq	80002a2c <phy_tx+0x4c>
		{
			if( pdTRUE == xQueueSend(phy_xnl_frame_tx, &phy, 0))
800029fa:	48 e8       	lddpc	r8,80002a30 <phy_tx+0x50>
800029fc:	70 0c       	ld.w	r12,r8[0x0]
800029fe:	30 09       	mov	r9,0
80002a00:	12 9a       	mov	r10,r9
80002a02:	1a 9b       	mov	r11,sp
80002a04:	f0 1f 00 0c 	mcall	80002a34 <phy_tx+0x54>
80002a08:	c1 28       	rjmp	80002a2c <phy_tx+0x4c>
		}
	}
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE		
	else if((SPEAKER_DATA == (phy_ctrl & 0xF000))
80002a0a:	e0 48 10 00 	cp.w	r8,4096
80002a0e:	5f 0a       	sreq	r10
80002a10:	e0 48 20 00 	cp.w	r8,8192
80002a14:	5f 09       	sreq	r9
80002a16:	f5 e9 10 09 	or	r9,r10,r9
80002a1a:	c0 71       	brne	80002a28 <phy_tx+0x48>
80002a1c:	e0 48 50 00 	cp.w	r8,20480
80002a20:	c0 40       	breq	80002a28 <phy_tx+0x48>
80002a22:	e0 48 60 00 	cp.w	r8,24576
80002a26:	c0 31       	brne	80002a2c <phy_tx+0x4c>
	    || (MIC_DATA  == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_RX == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_TX == (phy_ctrl & 0xF000))
	)
	{		
		if(NULL == phy_payload_frame_tx)
80002a28:	48 48       	lddpc	r8,80002a38 <phy_tx+0x58>
80002a2a:	70 08       	ld.w	r8,r8[0x0]
	
	if(res != TRUE)
	{
		//vPortFree(phy_ptr);
	}
}
80002a2c:	2f fd       	sub	sp,-4
80002a2e:	d8 02       	popm	pc
80002a30:	00 00       	add	r0,r0
80002a32:	0a c4       	st.b	r5++,r4
80002a34:	80 00       	ld.sh	r0,r0[0x0]
80002a36:	54 6c       	stdsp	sp[0x118],r12
80002a38:	00 00       	add	r0,r0
80002a3a:	0a b4       	st.h	r5++,r4

80002a3c <get_idle_store_isr>:
		return NULL;
	}
}

void * get_idle_store_isr(xQueueHandle store)
{
80002a3c:	d4 01       	pushm	lr
80002a3e:	20 2d       	sub	sp,8
	void * ptr = NULL;
80002a40:	30 08       	mov	r8,0
80002a42:	50 18       	stdsp	sp[0x4],r8
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002a44:	50 08       	stdsp	sp[0x0],r8
	
	if(pdTRUE == xQueueReceiveFromISR(store, &ptr, &xHigherPriorityTaskWoken))
80002a46:	1a 9a       	mov	r10,sp
80002a48:	fa cb ff fc 	sub	r11,sp,-4
80002a4c:	f0 1f 00 05 	mcall	80002a60 <get_idle_store_isr+0x24>
80002a50:	58 1c       	cp.w	r12,1
80002a52:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80002a56:	fb fc 00 01 	ld.weq	r12,sp[0x4]
	}
	else
	{
		return NULL;
	}
}
80002a5a:	2f ed       	sub	sp,-8
80002a5c:	d8 02       	popm	pc
80002a5e:	00 00       	add	r0,r0
80002a60:	80 00       	ld.sh	r0,r0[0x0]
80002a62:	51 70       	stdsp	sp[0x5c],r0

80002a64 <phy_tx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_tx_func( void * ssc)
{
80002a64:	eb cd 40 c0 	pushm	r6-r7,lr
80002a68:	20 1d       	sub	sp,4
80002a6a:	18 97       	mov	r7,r12
    if(NULL != phy_xnl_frame_tx)
80002a6c:	fe f8 04 70 	ld.w	r8,pc[1136]
80002a70:	70 08       	ld.w	r8,r8[0x0]
80002a72:	58 08       	cp.w	r8,0
80002a74:	c7 40       	breq	80002b5c <phy_tx_func+0xf8>
    {
  	  	/*send ssc data in xnl frame*/
  	  	phy_xnl_tx(&(((ssc_fragment_t * )ssc)->xnl_channel));		
80002a76:	18 96       	mov	r6,r12
Called By:phy_tx_func
*/
static void phy_xnl_tx(xnl_channel_t * xnl_tx_channel)
{
	/*variables are used to store the push result in interrupt*/
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002a78:	30 08       	mov	r8,0
80002a7a:	50 08       	stdsp	sp[0x0],r8
	
	static S16 phy_tx_expexted_length = 0;
	static U8 phy_tx_index = 0;
	
	/*his is the code for handling any outgoing XNL Phy message*/
	switch(phy_tx_state)
80002a7c:	fe f8 04 64 	ld.w	r8,pc[1124]
80002a80:	70 08       	ld.w	r8,r8[0x0]
80002a82:	58 18       	cp.w	r8,1
80002a84:	c2 90       	breq	80002ad6 <phy_tx_func+0x72>
80002a86:	c0 43       	brcs	80002a8e <phy_tx_func+0x2a>
80002a88:	58 28       	cp.w	r8,2
80002a8a:	c6 91       	brne	80002b5c <phy_tx_func+0xf8>
80002a8c:	c6 18       	rjmp	80002b4e <phy_tx_func+0xea>
	{
		/*Waiting for the send xnl packet*/
		case WAITING_FOR_PHY_TX:			
			if( pdTRUE == xQueueReceiveFromISR(
80002a8e:	fe f8 04 4e 	ld.w	r8,pc[1102]
80002a92:	70 0c       	ld.w	r12,r8[0x0]
80002a94:	1a 9a       	mov	r10,sp
80002a96:	fe fb 04 4e 	ld.w	r11,pc[1102]
80002a9a:	f0 1f 01 14 	mcall	80002ee8 <phy_tx_func+0x484>
80002a9e:	58 1c       	cp.w	r12,1
80002aa0:	c1 51       	brne	80002aca <phy_tx_func+0x66>
				  phy_xnl_frame_tx
				, &phy_ptr
				, &xHigherPriorityTaskWoken 
			))
			{								
				phy_tx_expexted_length = 
80002aa2:	fe f8 04 42 	ld.w	r8,pc[1090]
80002aa6:	70 08       	ld.w	r8,r8[0x0]
80002aa8:	11 9a       	ld.ub	r10,r8[0x1]
80002aaa:	fe f9 04 42 	ld.w	r9,pc[1090]
80002aae:	b2 0a       	st.h	r9[0x0],r10
				*/
				xnl_tx_channel->dword = 
				                   phy_ptr->xnl_fragment.phy_header.phy_control;
				
				/*Transmit 0xABCD0000 | Type/Length.*/
				xnl_tx_channel->dword |= PHYHEADER32;
80002ab0:	90 88       	ld.uh	r8,r8[0x0]
80002ab2:	ea 18 ab cd 	orh	r8,0xabcd
80002ab6:	8f 18       	st.w	r7[0x4],r8
				
				phy_tx_index = 1;
80002ab8:	30 19       	mov	r9,1
80002aba:	fe f8 04 36 	ld.w	r8,pc[1078]
80002abe:	b0 89       	st.b	r8[0x0],r9
				phy_tx_state = WRITE_NEXT_DWORD;	
80002ac0:	30 19       	mov	r9,1
80002ac2:	fe f8 04 1e 	ld.w	r8,pc[1054]
80002ac6:	91 09       	st.w	r8[0x0],r9
80002ac8:	c4 a8       	rjmp	80002b5c <phy_tx_func+0xf8>
				/*The new transmission has started.*/
			}
			else
			{
				/*Nothing new to transmit, send an idle frame*/
				xnl_tx_channel->dword = XNL_IDLE;
80002aca:	e0 68 5a 5a 	mov	r8,23130
80002ace:	ea 18 ab cd 	orh	r8,0xabcd
80002ad2:	8f 18       	st.w	r7[0x4],r8
80002ad4:	c4 48       	rjmp	80002b5c <phy_tx_func+0xf8>
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80002ad6:	fe f9 04 1a 	ld.w	r9,pc[1050]
80002ada:	13 88       	ld.ub	r8,r9[0x0]
				xnl_tx_channel->dword = XNL_IDLE;
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
80002adc:	fe fa 04 08 	ld.w	r10,pc[1032]
80002ae0:	74 0a       	ld.w	r10,r10[0x0]
80002ae2:	f4 08 05 1a 	ld.uh	r10,r10[r8<<0x1]
80002ae6:	b1 6a       	lsl	r10,0x10
80002ae8:	99 1a       	st.w	r12[0x4],r10
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80002aea:	2f f8       	sub	r8,-1
80002aec:	5c 58       	castu.b	r8
80002aee:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
80002af0:	fe fa 03 fc 	ld.w	r10,pc[1020]
80002af4:	94 09       	ld.sh	r9,r10[0x0]
80002af6:	20 29       	sub	r9,2
80002af8:	b4 09       	st.h	r10[0x0],r9
			
			/*have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80002afa:	30 0a       	mov	r10,0
80002afc:	f4 09 19 00 	cp.h	r9,r10
80002b00:	e0 89 00 0b 	brgt	80002b16 <phy_tx_func+0xb2>
			{
				/*Must immediately send 0x00BA in Slot 4.*/
				xnl_tx_channel->dword |= PHYTERMRIGHT;
80002b04:	78 18       	ld.w	r8,r12[0x4]
80002b06:	e8 18 00 ba 	orl	r8,0xba
80002b0a:	99 18       	st.w	r12[0x4],r8
				
				/*Go back to waiting.*/
				//vPortFree(phy_ptr);
				phy_tx_state = WAITING_FOR_PHY_TX;
80002b0c:	30 09       	mov	r9,0
80002b0e:	fe f8 03 d2 	ld.w	r8,pc[978]
80002b12:	91 09       	st.w	r8[0x0],r9
80002b14:	c2 48       	rjmp	80002b5c <phy_tx_func+0xf8>
				break;
			}

			/*Have not broken. Transmit 2nd hWord.*/
			xnl_tx_channel->dword |=  phy_ptr->fragment_element[phy_tx_index++];
80002b16:	fe f9 03 ce 	ld.w	r9,pc[974]
80002b1a:	72 09       	ld.w	r9,r9[0x0]
80002b1c:	f2 08 05 19 	ld.uh	r9,r9[r8<<0x1]
80002b20:	78 1a       	ld.w	r10,r12[0x4]
80002b22:	f5 e9 10 09 	or	r9,r10,r9
80002b26:	99 19       	st.w	r12[0x4],r9
80002b28:	2f f8       	sub	r8,-1
80002b2a:	fe f9 03 c6 	ld.w	r9,pc[966]
80002b2e:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
80002b30:	fe f9 03 bc 	ld.w	r9,pc[956]
80002b34:	92 08       	ld.sh	r8,r9[0x0]
80002b36:	20 28       	sub	r8,2
80002b38:	b2 08       	st.h	r9[0x0],r8
			
			/*Have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80002b3a:	30 09       	mov	r9,0
80002b3c:	f2 08 19 00 	cp.h	r8,r9
80002b40:	e0 89 00 0e 	brgt	80002b5c <phy_tx_func+0xf8>
			{
				/*Must send 0x00BA0000 next interrupt in Slot 3&4*/
				phy_tx_state = SEND_TAILED;
80002b44:	30 29       	mov	r9,2
80002b46:	fe f8 03 9a 	ld.w	r8,pc[922]
80002b4a:	91 09       	st.w	r8[0x0],r9
80002b4c:	c0 88       	rjmp	80002b5c <phy_tx_func+0xf8>
			}
			break;

		case SEND_TAILED:
			/*send 0x00BA0000*/
			xnl_tx_channel->dword = PHYTERMLEFT;
80002b4e:	fc 18 00 ba 	movh	r8,0xba
80002b52:	99 18       	st.w	r12[0x4],r8
			
			/*Go back to waiting.*/	
			//vPortFree(phy_ptr);		
			phy_tx_state = WAITING_FOR_PHY_TX;		
80002b54:	30 09       	mov	r9,0
80002b56:	fe f8 03 8a 	ld.w	r8,pc[906]
80002b5a:	91 09       	st.w	r8[0x0],r9
	
	//static U8 frame_5_end = 0;
	//static U16 pay[256];
	
	//Send-AMBE-data
	if ((AMBE_Media == TRUE))
80002b5c:	fe f8 03 98 	ld.w	r8,pc[920]
80002b60:	11 89       	ld.ub	r9,r8[0x0]
80002b62:	30 18       	mov	r8,1
80002b64:	f0 09 18 00 	cp.b	r9,r8
80002b68:	e0 81 01 af 	brne	80002ec6 <phy_tx_func+0x462>
	{
		A_index = (A_index >=1456) ? 0 : A_index;
80002b6c:	fe f8 03 8c 	ld.w	r8,pc[908]
80002b70:	70 08       	ld.w	r8,r8[0x0]
80002b72:	e0 48 05 b0 	cp.w	r8,1456
80002b76:	f9 b8 02 00 	movhs	r8,0
80002b7a:	fe f9 03 7e 	ld.w	r9,pc[894]
80002b7e:	93 08       	st.w	r9[0x0],r8
	  //AMBE_flag
		switch(AMBEpayload_tx_state)
80002b80:	fe f8 03 7c 	ld.w	r8,pc[892]
80002b84:	70 08       	ld.w	r8,r8[0x0]
80002b86:	58 68       	cp.w	r8,6
80002b88:	e0 8b 01 95 	brhi	80002eb2 <phy_tx_func+0x44e>
80002b8c:	fe f9 03 74 	ld.w	r9,pc[884]
80002b90:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
		{
			case AMBE_IDLE:
		
				if ((m_RxBurstType == VOICE_WATING) || (m_RxBurstType == VOICETERMINATOR)  || (m_RxBurstType == VOICEHEADER))
80002b94:	fe f8 03 70 	ld.w	r8,pc[880]
80002b98:	70 08       	ld.w	r8,r8[0x0]
80002b9a:	58 08       	cp.w	r8,0
80002b9c:	c0 b0       	breq	80002bb2 <phy_tx_func+0x14e>
80002b9e:	fe f8 03 66 	ld.w	r8,pc[870]
80002ba2:	70 08       	ld.w	r8,r8[0x0]
80002ba4:	58 a8       	cp.w	r8,10
80002ba6:	c0 60       	breq	80002bb2 <phy_tx_func+0x14e>
80002ba8:	fe f8 03 5c 	ld.w	r8,pc[860]
80002bac:	70 08       	ld.w	r8,r8[0x0]
80002bae:	58 18       	cp.w	r8,1
80002bb0:	c0 a1       	brne	80002bc4 <phy_tx_func+0x160>
				{
							
					payload_tx_channel->dword[0] = PAYLOADIDLE0;
80002bb2:	e0 68 5a 5a 	mov	r8,23130
80002bb6:	ea 18 ab cd 	orh	r8,0xabcd
80002bba:	8f 28       	st.w	r7[0x8],r8
					payload_tx_channel->dword[1] = PAYLOADIDLE1;
80002bbc:	30 08       	mov	r8,0
80002bbe:	8f 38       	st.w	r7[0xc],r8
80002bc0:	e0 8f 01 8a 	bral	80002ed4 <phy_tx_func+0x470>
			
				}
				else if((m_RxBurstType == UNSUREDATA))
80002bc4:	fe f8 03 40 	ld.w	r8,pc[832]
80002bc8:	70 08       	ld.w	r8,r8[0x0]
80002bca:	58 38       	cp.w	r8,3
80002bcc:	c0 91       	brne	80002bde <phy_tx_func+0x17a>
				{
					payload_tx_channel->dword[0] = AMBE_HT[0];
80002bce:	fe f8 03 3a 	ld.w	r8,pc[826]
80002bd2:	70 09       	ld.w	r9,r8[0x0]
80002bd4:	8f 29       	st.w	r7[0x8],r9
					payload_tx_channel->dword[1] = AMBE_HT[1];
80002bd6:	70 18       	ld.w	r8,r8[0x4]
80002bd8:	8f 38       	st.w	r7[0xc],r8
80002bda:	e0 8f 01 7d 	bral	80002ed4 <phy_tx_func+0x470>
				else//加密和解密的激励类型
				{
					
					//Radio Internal Parameter + Vocoder Bits Stream Parameter + soft decision value + 1st 20ms AMBE bits of Voice Burst A 
					//assemble 4 items into 1 Command. Send it to Radio.
					if (m_RxBurstType == RADIOINTERNAL)//解密数据
80002bde:	fe f8 03 26 	ld.w	r8,pc[806]
80002be2:	70 08       	ld.w	r8,r8[0x0]
80002be4:	58 28       	cp.w	r8,2
80002be6:	c1 31       	brne	80002c0c <phy_tx_func+0x1a8>
					{
						//0xABCDCO32
						payload_tx_channel->dword[0] = DE_OB_PAYLOAD;//50bytes
80002be8:	e0 68 c0 32 	mov	r8,49202
80002bec:	ea 18 ab cd 	orh	r8,0xabcd
80002bf0:	8f 28       	st.w	r7[0x8],r8
						//0x847F
						payload_tx_channel->word[2] = RIP_PAYLOAD;
80002bf2:	fe 78 84 7f 	mov	r8,-31617
80002bf6:	ae 68       	st.h	r7[0xc],r8
						//0xxxxx
						payload_tx_channel->word[3] = Radio_Internal_Data[0];
80002bf8:	fe f8 03 14 	ld.w	r8,pc[788]
80002bfc:	90 08       	ld.sh	r8,r8[0x0]
80002bfe:	ae 78       	st.h	r7[0xe],r8
						
						AMBEpayload_tx_state = AMBE_DE_FIRST;
80002c00:	30 39       	mov	r9,3
80002c02:	fe f8 02 fa 	ld.w	r8,pc[762]
80002c06:	91 09       	st.w	r8[0x0],r9
80002c08:	e0 8f 01 66 	bral	80002ed4 <phy_tx_func+0x470>
					//assemble 2 items into 1 Command. Send it to Radio.
					else//加密数据
					{
	
						//0xABCDCOOE
						payload_tx_channel->dword[0] = EN_OB_PAYLOAD;//49bits
80002c0c:	e0 68 c0 0e 	mov	r8,49166
80002c10:	ea 18 ab cd 	orh	r8,0xabcd
80002c14:	8f 28       	st.w	r7[0x8],r8
						//0x8212
						payload_tx_channel->word[2] = VBSP_data[0];
80002c16:	fe f8 02 fa 	ld.w	r8,pc[762]
80002c1a:	90 09       	ld.sh	r9,r8[0x0]
80002c1c:	ae 69       	st.h	r7[0xc],r9
						//0xF00x
						payload_tx_channel->word[3] = VBSP_data[1];
80002c1e:	90 18       	ld.sh	r8,r8[0x2]
80002c20:	ae 78       	st.h	r7[0xe],r8
						
						AMBEpayload_tx_state = AMBE_EN_FIRST;
80002c22:	30 19       	mov	r9,1
80002c24:	fe f8 02 d8 	ld.w	r8,pc[728]
80002c28:	91 09       	st.w	r8[0x0],r9
80002c2a:	e0 8f 01 55 	bral	80002ed4 <phy_tx_func+0x470>
			
			case AMBE_EN_FIRST:
			
			
				//0x88F2
				payload_tx_channel->word[0] = ENCODER_PAYLOAD;//49bits
80002c2e:	fe 78 88 f2 	mov	r8,-30478
80002c32:	ae 48       	st.h	r7[0x8],r8
				//A_index+=2;
				//
				//AMBEpayload_tx_state = AMBE_EN_LAST;
				
			
				switch (m_RxBurstType)//在发送函数中去做加密处理
80002c34:	fe f8 02 d0 	ld.w	r8,pc[720]
80002c38:	70 08       	ld.w	r8,r8[0x0]
80002c3a:	58 48       	cp.w	r8,4
80002c3c:	c0 60       	breq	80002c48 <phy_tx_func+0x1e4>
80002c3e:	c4 53       	brcs	80002cc8 <phy_tx_func+0x264>
80002c40:	58 98       	cp.w	r8,9
80002c42:	e0 8b 00 43 	brhi	80002cc8 <phy_tx_func+0x264>
80002c46:	c2 98       	rjmp	80002c98 <phy_tx_func+0x234>
				{
					case VOICEBURST_A:
							if (VF_SN == 1)
80002c48:	fe f8 02 cc 	ld.w	r8,pc[716]
80002c4c:	11 89       	ld.ub	r9,r8[0x0]
80002c4e:	30 18       	mov	r8,1
80002c50:	f0 09 18 00 	cp.b	r9,r8
80002c54:	c0 a1       	brne	80002c68 <phy_tx_func+0x204>
							{	
								
								
								//Place public key
								payload_tx_channel->word[1] = Public_AMBEkey[0];
80002c56:	fe f8 02 c2 	ld.w	r8,pc[706]
80002c5a:	90 09       	ld.sh	r9,r8[0x0]
80002c5c:	ae 59       	st.h	r7[0xa],r9
								payload_tx_channel->word[2] = Public_AMBEkey[1];
80002c5e:	90 19       	ld.sh	r9,r8[0x2]
80002c60:	ae 69       	st.h	r7[0xc],r9
								payload_tx_channel->word[3] = Public_AMBEkey[2];
80002c62:	90 28       	ld.sh	r8,r8[0x4]
80002c64:	ae 78       	st.h	r7[0xe],r8
80002c66:	c1 48       	rjmp	80002c8e <phy_tx_func+0x22a>
							{
								
								
						
								//Encrypted AMBE data(XOR)
								payload_tx_channel->word[1] = ((Public_AMBEkey[0]) ^ (AMBEBurst_rawdata[0])) ;
80002c68:	fe f9 02 b4 	ld.w	r9,pc[692]
80002c6c:	92 0b       	ld.sh	r11,r9[0x0]
80002c6e:	fe f8 02 aa 	ld.w	r8,pc[682]
80002c72:	90 0a       	ld.sh	r10,r8[0x0]
80002c74:	f7 ea 20 0a 	eor	r10,r11,r10
80002c78:	ae 5a       	st.h	r7[0xa],r10
								payload_tx_channel->word[2] = ((Public_AMBEkey[1]) ^ (AMBEBurst_rawdata[1])) ;
80002c7a:	92 1b       	ld.sh	r11,r9[0x2]
80002c7c:	90 1a       	ld.sh	r10,r8[0x2]
80002c7e:	f7 ea 20 0a 	eor	r10,r11,r10
80002c82:	ae 6a       	st.h	r7[0xc],r10
								payload_tx_channel->word[3] = ((Public_AMBEkey[2]) ^ (AMBEBurst_rawdata[2])) ;
80002c84:	92 29       	ld.sh	r9,r9[0x4]
80002c86:	90 28       	ld.sh	r8,r8[0x4]
80002c88:	f3 e8 20 08 	eor	r8,r9,r8
80002c8c:	ae 78       	st.h	r7[0xe],r8
								//payload_tx_channel->word[3] = AMBEBurst_rawdata[2];
							
						
							}
					
							AMBEpayload_tx_state = AMBE_EN_LAST;
80002c8e:	30 29       	mov	r9,2
80002c90:	fe f8 02 6c 	ld.w	r8,pc[620]
80002c94:	91 09       	st.w	r8[0x0],r9
80002c96:	c1 f9       	rjmp	80002ed4 <phy_tx_func+0x470>
							//Encrypted AMBE data(XOR)
						
							//payload_tx_channel->word[1] = AMBEBurst_rawdata[0];
							//payload_tx_channel->word[2] = AMBEBurst_rawdata[1];
							//payload_tx_channel->word[3] = AMBEBurst_rawdata[2];
							payload_tx_channel->word[1] = ((Public_AMBEkey[0]) ^ (AMBEBurst_rawdata[0])) ;
80002c98:	fe f9 02 84 	ld.w	r9,pc[644]
80002c9c:	92 0b       	ld.sh	r11,r9[0x0]
80002c9e:	fe f8 02 7a 	ld.w	r8,pc[634]
80002ca2:	90 0a       	ld.sh	r10,r8[0x0]
80002ca4:	f7 ea 20 0a 	eor	r10,r11,r10
80002ca8:	ae 5a       	st.h	r7[0xa],r10
							payload_tx_channel->word[2] = ((Public_AMBEkey[1]) ^ (AMBEBurst_rawdata[1])) ;
80002caa:	92 1b       	ld.sh	r11,r9[0x2]
80002cac:	90 1a       	ld.sh	r10,r8[0x2]
80002cae:	f7 ea 20 0a 	eor	r10,r11,r10
80002cb2:	ae 6a       	st.h	r7[0xc],r10
							payload_tx_channel->word[3] = ((Public_AMBEkey[2]) ^ (AMBEBurst_rawdata[2])) ;
80002cb4:	92 29       	ld.sh	r9,r9[0x4]
80002cb6:	90 28       	ld.sh	r8,r8[0x4]
80002cb8:	f3 e8 20 08 	eor	r8,r9,r8
80002cbc:	ae 78       	st.h	r7[0xe],r8
						
							AMBEpayload_tx_state = AMBE_EN_LAST;
80002cbe:	30 29       	mov	r9,2
80002cc0:	fe f8 02 3c 	ld.w	r8,pc[572]
80002cc4:	91 09       	st.w	r8[0x0],r9
80002cc6:	c0 79       	rjmp	80002ed4 <phy_tx_func+0x470>
				
						break;
					default://This shouldn't happen, but must check;
					
							payload_tx_channel->dword[0] = PAYLOADIDLE0;
80002cc8:	e0 68 5a 5a 	mov	r8,23130
80002ccc:	ea 18 ab cd 	orh	r8,0xabcd
80002cd0:	8f 28       	st.w	r7[0x8],r8
							payload_tx_channel->dword[1] = PAYLOADIDLE1;
80002cd2:	30 08       	mov	r8,0
80002cd4:	8f 38       	st.w	r7[0xc],r8
							
							AMBEpayload_tx_state = AMBE_IDLE;
80002cd6:	fe f9 02 26 	ld.w	r9,pc[550]
80002cda:	93 08       	st.w	r9[0x0],r8
80002cdc:	cf c8       	rjmp	80002ed4 <phy_tx_func+0x470>
						  1:VF1 of first Burst A after last Voice Header (49 bits).
						  2:Last 4 bits (bit 45 to bit 48) of every 49 bits AMBE Voice Frame. (72 bits@Super Frame).
					
					*/
					
					payload_tx_channel->word[0] = AMBEBurst_rawdata[3];
80002cde:	fe f8 02 3e 	ld.w	r8,pc[574]
80002ce2:	90 38       	ld.sh	r8,r8[0x6]
80002ce4:	ae 48       	st.h	r7[0x8],r8
					
					
					//payload_tx_channel->word[0] = ((AMBE_AudioData[A_index]<<8) + 0x00) ;//需要补充Pad_bits位
					//A_index+=1;
					
					payload_tx_channel->word[1]	= 0x00BA ; 
80002ce6:	e0 68 00 ba 	mov	r8,186
80002cea:	ae 58       	st.h	r7[0xa],r8
					payload_tx_channel->word[2]	= 0x0000 ;
80002cec:	30 08       	mov	r8,0
80002cee:	ae 68       	st.h	r7[0xc],r8
					payload_tx_channel->word[3]	= 0x0000 ;
80002cf0:	ae 78       	st.h	r7[0xe],r8
				
					AMBEpayload_tx_state = AMBE_IDLE;
80002cf2:	30 09       	mov	r9,0
80002cf4:	fe f8 02 08 	ld.w	r8,pc[520]
80002cf8:	91 09       	st.w	r8[0x0],r9
80002cfa:	ce d8       	rjmp	80002ed4 <phy_tx_func+0x470>
				break;
				
			case AMBE_DE_FIRST:
				
					//0xxxxx
					payload_tx_channel->word[0] = Radio_Internal_Data[1];
80002cfc:	fe f8 02 10 	ld.w	r8,pc[528]
80002d00:	90 18       	ld.sh	r8,r8[0x2]
80002d02:	ae 48       	st.h	r7[0x8],r8
					//0x8212
					payload_tx_channel->word[1] = VBSP_data[0];
80002d04:	fe f8 02 0c 	ld.w	r8,pc[524]
80002d08:	90 08       	ld.sh	r8,r8[0x0]
80002d0a:	ae 58       	st.h	r7[0xa],r8
					
					if ((m_RxBurstType == VOICEBURST_A) && (VF_SN == 1) )
80002d0c:	4f e8       	lddpc	r8,80002f04 <phy_tx_func+0x4a0>
80002d0e:	70 08       	ld.w	r8,r8[0x0]
80002d10:	58 48       	cp.w	r8,4
80002d12:	c0 d1       	brne	80002d2c <phy_tx_func+0x2c8>
80002d14:	fe f8 02 00 	ld.w	r8,pc[512]
80002d18:	11 89       	ld.ub	r9,r8[0x0]
80002d1a:	30 18       	mov	r8,1
80002d1c:	f0 09 18 00 	cp.b	r9,r8
80002d20:	c0 61       	brne	80002d2c <phy_tx_func+0x2c8>
					{
						// Vocoder Bits Stream Parameter("E(bit8)" flag = 1)
						//0xF0(8+)x
						payload_tx_channel->word[2] = ((VBSP_data[1]) | (0x0100));
80002d22:	4f c8       	lddpc	r8,80002f10 <phy_tx_func+0x4ac>
80002d24:	90 18       	ld.sh	r8,r8[0x2]
80002d26:	a9 a8       	sbr	r8,0x8
80002d28:	ae 68       	st.h	r7[0xc],r8
80002d2a:	c0 48       	rjmp	80002d32 <phy_tx_func+0x2ce>
					}
					else
						//0xF00x
						payload_tx_channel->word[2] = (VBSP_data[1]) ;
80002d2c:	4f 98       	lddpc	r8,80002f10 <phy_tx_func+0x4ac>
80002d2e:	90 18       	ld.sh	r8,r8[0x2]
80002d30:	ae 68       	st.h	r7[0xc],r8
					
					//0x9A13
					payload_tx_channel->word[3] = SDV_PAYLOAD;
80002d32:	fe 78 9a 13 	mov	r8,-26093
80002d36:	ae 78       	st.h	r7[0xe],r8
		
					AMBEpayload_tx_state = AMBE_DE_SECOND;
80002d38:	30 49       	mov	r9,4
80002d3a:	4f 18       	lddpc	r8,80002efc <phy_tx_func+0x498>
80002d3c:	91 09       	st.w	r8[0x0],r9
80002d3e:	cc b8       	rjmp	80002ed4 <phy_tx_func+0x470>
				break;
			
			case AMBE_DE_SECOND:
					//Post back soft decision value data

						payload_tx_channel->word[0] = Soft_Decision_Data[Soft_index] ;
80002d40:	4f 88       	lddpc	r8,80002f20 <phy_tx_func+0x4bc>
80002d42:	70 0a       	ld.w	r10,r8[0x0]
80002d44:	4f 89       	lddpc	r9,80002f24 <phy_tx_func+0x4c0>
80002d46:	f2 0a 04 1a 	ld.sh	r10,r9[r10<<0x1]
80002d4a:	ae 4a       	st.h	r7[0x8],r10
						payload_tx_channel->word[1] = Soft_Decision_Data[Soft_index+1] ;
80002d4c:	70 0a       	ld.w	r10,r8[0x0]
80002d4e:	2f fa       	sub	r10,-1
80002d50:	f2 0a 04 1a 	ld.sh	r10,r9[r10<<0x1]
80002d54:	ae 5a       	st.h	r7[0xa],r10
						payload_tx_channel->word[2] = Soft_Decision_Data[Soft_index+2] ;
80002d56:	70 0a       	ld.w	r10,r8[0x0]
80002d58:	2f ea       	sub	r10,-2
80002d5a:	f2 0a 04 1a 	ld.sh	r10,r9[r10<<0x1]
80002d5e:	ae 6a       	st.h	r7[0xc],r10
						payload_tx_channel->word[3] = Soft_Decision_Data[Soft_index+3] ;
80002d60:	70 0a       	ld.w	r10,r8[0x0]
80002d62:	2f da       	sub	r10,-3
80002d64:	f2 0a 04 19 	ld.sh	r9,r9[r10<<0x1]
80002d68:	ae 79       	st.h	r7[0xe],r9
						Soft_index +=4;
80002d6a:	70 09       	ld.w	r9,r8[0x0]
80002d6c:	2f c9       	sub	r9,-4
80002d6e:	91 09       	st.w	r8[0x0],r9
						
						if (Soft_index == 12)
80002d70:	58 c9       	cp.w	r9,12
80002d72:	c0 51       	brne	80002d7c <phy_tx_func+0x318>
						{
							AMBEpayload_tx_state = AMBE_DE_THIRD;
80002d74:	30 59       	mov	r9,5
80002d76:	4e 28       	lddpc	r8,80002efc <phy_tx_func+0x498>
80002d78:	91 09       	st.w	r8[0x0],r9
80002d7a:	ca d8       	rjmp	80002ed4 <phy_tx_func+0x470>
							//Soft_index = 0 ;
							
						}
						else
						AMBEpayload_tx_state = AMBE_DE_SECOND;
80002d7c:	30 49       	mov	r9,4
80002d7e:	4e 08       	lddpc	r8,80002efc <phy_tx_func+0x498>
80002d80:	91 09       	st.w	r8[0x0],r9
80002d82:	ca 98       	rjmp	80002ed4 <phy_tx_func+0x470>
				break;	
				
			case AMBE_DE_THIRD:
					
					//0x xxxx
					payload_tx_channel->word[0] = Soft_Decision_Data[Soft_index] ;
80002d84:	4e 78       	lddpc	r8,80002f20 <phy_tx_func+0x4bc>
80002d86:	70 0a       	ld.w	r10,r8[0x0]
80002d88:	4e 79       	lddpc	r9,80002f24 <phy_tx_func+0x4c0>
80002d8a:	f2 0a 04 19 	ld.sh	r9,r9[r10<<0x1]
80002d8e:	ae 49       	st.h	r7[0x8],r9
					Soft_index = 0 ;//索引清零
80002d90:	30 09       	mov	r9,0
80002d92:	91 09       	st.w	r8[0x0],r9
					
					//0x8003 隔离符号？
					payload_tx_channel->word[1] = 0x8003;
80002d94:	fe 78 80 03 	mov	r8,-32765
80002d98:	ae 58       	st.h	r7[0xa],r8
					//0x88F3
					payload_tx_channel->word[2] = DECODER_PAYLOAD;
80002d9a:	fe 78 88 f3 	mov	r8,-30477
80002d9e:	ae 68       	st.h	r7[0xc],r8
				
					switch (m_RxBurstType)//在发送函数中去做解密处理
80002da0:	4d 98       	lddpc	r8,80002f04 <phy_tx_func+0x4a0>
80002da2:	70 08       	ld.w	r8,r8[0x0]
80002da4:	58 48       	cp.w	r8,4
80002da6:	c0 60       	breq	80002db2 <phy_tx_func+0x34e>
80002da8:	c2 83       	brcs	80002df8 <phy_tx_func+0x394>
80002daa:	58 98       	cp.w	r8,9
80002dac:	e0 8b 00 26 	brhi	80002df8 <phy_tx_func+0x394>
80002db0:	c1 98       	rjmp	80002de2 <phy_tx_func+0x37e>
					{
						case VOICEBURST_A:
								if (VF_SN == 1)
80002db2:	4d 98       	lddpc	r8,80002f14 <phy_tx_func+0x4b0>
80002db4:	11 89       	ld.ub	r9,r8[0x0]
80002db6:	30 18       	mov	r8,1
80002db8:	f0 09 18 00 	cp.b	r9,r8
80002dbc:	c0 81       	brne	80002dcc <phy_tx_func+0x368>
									//if(AMBEBurst_rawdata[0] == Public_AMBEkey[0])//0X1AC3
									{
										
									
										//Pick up public key
										AMBE_DecryptionKey[0] = AMBEBurst_rawdata[0];
80002dbe:	4d 88       	lddpc	r8,80002f1c <phy_tx_func+0x4b8>
80002dc0:	90 0a       	ld.sh	r10,r8[0x0]
80002dc2:	4d a9       	lddpc	r9,80002f28 <phy_tx_func+0x4c4>
80002dc4:	b2 0a       	st.h	r9[0x0],r10
									
										//Post back data
										payload_tx_channel->word[3] = AMBEBurst_rawdata[0] ;
80002dc6:	90 08       	ld.sh	r8,r8[0x0]
80002dc8:	ae 78       	st.h	r7[0xe],r8
80002dca:	c0 88       	rjmp	80002dda <phy_tx_func+0x376>
								else//VF_SN==2/3
								{	
									//Decrypt AMBE data(XOR) 
									//Recover data

									payload_tx_channel->word[3] = ((AMBE_DecryptionKey[0]) ^ (AMBEBurst_rawdata[0])) ;
80002dcc:	4d 78       	lddpc	r8,80002f28 <phy_tx_func+0x4c4>
80002dce:	90 08       	ld.sh	r8,r8[0x0]
80002dd0:	4d 39       	lddpc	r9,80002f1c <phy_tx_func+0x4b8>
80002dd2:	92 09       	ld.sh	r9,r9[0x0]
80002dd4:	f3 e8 20 08 	eor	r8,r9,r8
80002dd8:	ae 78       	st.h	r7[0xe],r8
									
									//payload_tx_channel->word[3] = ((AMBEBurst_rawdata[0])) ;
						
								}
					
								AMBEpayload_tx_state = AMBE_DE_LAST;
80002dda:	30 69       	mov	r9,6
80002ddc:	4c 88       	lddpc	r8,80002efc <phy_tx_func+0x498>
80002dde:	91 09       	st.w	r8[0x0],r9
80002de0:	c7 a8       	rjmp	80002ed4 <phy_tx_func+0x470>
						
								//Encrypted AMBE data(XOR)
						
								//Decrypt AMBE data(XOR)
								//Recover data
								payload_tx_channel->word[3] = ((AMBE_DecryptionKey[0]) ^ (AMBEBurst_rawdata[0])) ;
80002de2:	4d 28       	lddpc	r8,80002f28 <phy_tx_func+0x4c4>
80002de4:	90 08       	ld.sh	r8,r8[0x0]
80002de6:	4c e9       	lddpc	r9,80002f1c <phy_tx_func+0x4b8>
80002de8:	92 09       	ld.sh	r9,r9[0x0]
80002dea:	f3 e8 20 08 	eor	r8,r9,r8
80002dee:	ae 78       	st.h	r7[0xe],r8
								//payload_tx_channel->word[3] = ((AMBEBurst_rawdata[0])) ;
						
								AMBEpayload_tx_state = AMBE_DE_LAST;
80002df0:	30 69       	mov	r9,6
80002df2:	4c 38       	lddpc	r8,80002efc <phy_tx_func+0x498>
80002df4:	91 09       	st.w	r8[0x0],r9
80002df6:	c6 f8       	rjmp	80002ed4 <phy_tx_func+0x470>
				
							break;
						default://This shouldn't happen, but must check;
					
								payload_tx_channel->dword[0] = PAYLOADIDLE0;
80002df8:	e0 68 5a 5a 	mov	r8,23130
80002dfc:	ea 18 ab cd 	orh	r8,0xabcd
80002e00:	8f 28       	st.w	r7[0x8],r8
								payload_tx_channel->dword[1] = PAYLOADIDLE1;
80002e02:	30 08       	mov	r8,0
80002e04:	8f 38       	st.w	r7[0xc],r8
								AMBEpayload_tx_state = AMBE_IDLE;
80002e06:	4b e9       	lddpc	r9,80002efc <phy_tx_func+0x498>
80002e08:	93 08       	st.w	r9[0x0],r8
80002e0a:	c6 58       	rjmp	80002ed4 <phy_tx_func+0x470>
		
					break;
				
			case AMBE_DE_LAST:
				
					switch (m_RxBurstType)//在发送函数中去做解密处理
80002e0c:	4b e8       	lddpc	r8,80002f04 <phy_tx_func+0x4a0>
80002e0e:	70 08       	ld.w	r8,r8[0x0]
80002e10:	58 48       	cp.w	r8,4
80002e12:	c0 60       	breq	80002e1e <phy_tx_func+0x3ba>
80002e14:	c4 53       	brcs	80002e9e <phy_tx_func+0x43a>
80002e16:	58 98       	cp.w	r8,9
80002e18:	e0 8b 00 43 	brhi	80002e9e <phy_tx_func+0x43a>
80002e1c:	c2 d8       	rjmp	80002e76 <phy_tx_func+0x412>
					{
						case VOICEBURST_A:
							if (VF_SN == 1)
80002e1e:	4b e8       	lddpc	r8,80002f14 <phy_tx_func+0x4b0>
80002e20:	11 89       	ld.ub	r9,r8[0x0]
80002e22:	30 18       	mov	r8,1
80002e24:	f0 09 18 00 	cp.b	r9,r8
80002e28:	c1 31       	brne	80002e4e <phy_tx_func+0x3ea>
								//if(AMBEBurst_rawdata[1] == Public_AMBEkey[1])//0X1840
								{
								
									//Pick up public key
							
									AMBE_DecryptionKey[1] = AMBEBurst_rawdata[1];
80002e2a:	4b d8       	lddpc	r8,80002f1c <phy_tx_func+0x4b8>
80002e2c:	90 1a       	ld.sh	r10,r8[0x2]
80002e2e:	4b f9       	lddpc	r9,80002f28 <phy_tx_func+0x4c4>
80002e30:	b2 1a       	st.h	r9[0x2],r10
									AMBE_DecryptionKey[2] = AMBEBurst_rawdata[2];
80002e32:	90 2a       	ld.sh	r10,r8[0x4]
80002e34:	b2 2a       	st.h	r9[0x4],r10
									AMBE_DecryptionKey[3] = AMBEBurst_rawdata[3];
80002e36:	90 3a       	ld.sh	r10,r8[0x6]
80002e38:	b2 3a       	st.h	r9[0x6],r10
							
									//Post back data
									payload_tx_channel->word[0] = AMBEBurst_rawdata[1] ;
80002e3a:	90 19       	ld.sh	r9,r8[0x2]
80002e3c:	ae 49       	st.h	r7[0x8],r9
									payload_tx_channel->word[1] = AMBEBurst_rawdata[2] ;
80002e3e:	90 29       	ld.sh	r9,r8[0x4]
80002e40:	ae 59       	st.h	r7[0xa],r9
									payload_tx_channel->word[2] = AMBEBurst_rawdata[3] ;
80002e42:	90 38       	ld.sh	r8,r8[0x6]
80002e44:	ae 68       	st.h	r7[0xc],r8
									payload_tx_channel->word[3] = 0x00BA ;
80002e46:	e0 68 00 ba 	mov	r8,186
80002e4a:	ae 78       	st.h	r7[0xe],r8
80002e4c:	c1 18       	rjmp	80002e6e <phy_tx_func+0x40a>
							{
							
								//Decrypt AMBE data(XOR)
								//Recover data

									payload_tx_channel->word[0] = (AMBEBurst_rawdata[1] ^ AMBE_DecryptionKey[1]);
80002e4e:	4b 48       	lddpc	r8,80002f1c <phy_tx_func+0x4b8>
80002e50:	90 1a       	ld.sh	r10,r8[0x2]
80002e52:	4b 69       	lddpc	r9,80002f28 <phy_tx_func+0x4c4>
80002e54:	92 1b       	ld.sh	r11,r9[0x2]
80002e56:	f7 ea 20 0a 	eor	r10,r11,r10
80002e5a:	ae 4a       	st.h	r7[0x8],r10
									payload_tx_channel->word[1] = (AMBEBurst_rawdata[2] ^ AMBE_DecryptionKey[2]);
80002e5c:	90 2a       	ld.sh	r10,r8[0x4]
80002e5e:	92 29       	ld.sh	r9,r9[0x4]
80002e60:	14 59       	eor	r9,r10
80002e62:	ae 59       	st.h	r7[0xa],r9
									payload_tx_channel->word[2] = (AMBEBurst_rawdata[3]);
80002e64:	90 38       	ld.sh	r8,r8[0x6]
80002e66:	ae 68       	st.h	r7[0xc],r8
									
									//payload_tx_channel->word[0] = (AMBEBurst_rawdata[1]);
									//payload_tx_channel->word[1] = (AMBEBurst_rawdata[2]);
									//payload_tx_channel->word[2] = (AMBEBurst_rawdata[3]);
									
									payload_tx_channel->word[3] = 0x00BA ;
80002e68:	e0 68 00 ba 	mov	r8,186
80002e6c:	ae 78       	st.h	r7[0xe],r8
							
							
							}
						
							AMBEpayload_tx_state = AMBE_IDLE;
80002e6e:	30 09       	mov	r9,0
80002e70:	4a 38       	lddpc	r8,80002efc <phy_tx_func+0x498>
80002e72:	91 09       	st.w	r8[0x0],r9
80002e74:	c3 08       	rjmp	80002ed4 <phy_tx_func+0x470>
						
							//Encrypted AMBE data(XOR)
						
							//Decrypt AMBE data(XOR)
							//Recover data
							payload_tx_channel->word[0] = (AMBEBurst_rawdata[1] ^ AMBE_DecryptionKey[1]);
80002e76:	4a a8       	lddpc	r8,80002f1c <phy_tx_func+0x4b8>
80002e78:	90 1a       	ld.sh	r10,r8[0x2]
80002e7a:	4a c9       	lddpc	r9,80002f28 <phy_tx_func+0x4c4>
80002e7c:	92 1b       	ld.sh	r11,r9[0x2]
80002e7e:	f7 ea 20 0a 	eor	r10,r11,r10
80002e82:	ae 4a       	st.h	r7[0x8],r10
							payload_tx_channel->word[1] = (AMBEBurst_rawdata[2] ^ AMBE_DecryptionKey[2]);
80002e84:	90 2a       	ld.sh	r10,r8[0x4]
80002e86:	92 29       	ld.sh	r9,r9[0x4]
80002e88:	14 59       	eor	r9,r10
80002e8a:	ae 59       	st.h	r7[0xa],r9
							payload_tx_channel->word[2] = (AMBEBurst_rawdata[3]);
80002e8c:	90 38       	ld.sh	r8,r8[0x6]
80002e8e:	ae 68       	st.h	r7[0xc],r8
							
							//payload_tx_channel->word[0] = (AMBEBurst_rawdata[1]);
							//payload_tx_channel->word[1] = (AMBEBurst_rawdata[2]);
							//payload_tx_channel->word[2] = (AMBEBurst_rawdata[3]);
							
							payload_tx_channel->word[3] = 0x00BA ;
80002e90:	e0 68 00 ba 	mov	r8,186
80002e94:	ae 78       	st.h	r7[0xe],r8
						
							AMBEpayload_tx_state = AMBE_IDLE;
80002e96:	30 09       	mov	r9,0
80002e98:	49 98       	lddpc	r8,80002efc <phy_tx_func+0x498>
80002e9a:	91 09       	st.w	r8[0x0],r9
80002e9c:	c1 c8       	rjmp	80002ed4 <phy_tx_func+0x470>
						
							break;
						default://This shouldn't happen, but must check;
						
							payload_tx_channel->dword[0] = PAYLOADIDLE0;
80002e9e:	e0 68 5a 5a 	mov	r8,23130
80002ea2:	ea 18 ab cd 	orh	r8,0xabcd
80002ea6:	8f 28       	st.w	r7[0x8],r8
							payload_tx_channel->dword[1] = PAYLOADIDLE1;
80002ea8:	30 08       	mov	r8,0
80002eaa:	8f 38       	st.w	r7[0xc],r8
							AMBEpayload_tx_state = AMBE_IDLE;
80002eac:	49 49       	lddpc	r9,80002efc <phy_tx_func+0x498>
80002eae:	93 08       	st.w	r9[0x0],r8
80002eb0:	c1 28       	rjmp	80002ed4 <phy_tx_func+0x470>

				break;
		
			default:
			
					payload_tx_channel->dword[0] = PAYLOADIDLE0;
80002eb2:	e0 68 5a 5a 	mov	r8,23130
80002eb6:	ea 18 ab cd 	orh	r8,0xabcd
80002eba:	8f 28       	st.w	r7[0x8],r8
					payload_tx_channel->dword[1] = PAYLOADIDLE1;
80002ebc:	30 08       	mov	r8,0
80002ebe:	8f 38       	st.w	r7[0xc],r8
					
					AMBEpayload_tx_state = AMBE_IDLE;
80002ec0:	48 f9       	lddpc	r9,80002efc <phy_tx_func+0x498>
80002ec2:	93 08       	st.w	r9[0x0],r8
80002ec4:	c0 88       	rjmp	80002ed4 <phy_tx_func+0x470>

	}//end of Send-AMBE-data

	else
	{
		payload_tx_channel->dword[0] = PAYLOADIDLE0;
80002ec6:	e0 68 5a 5a 	mov	r8,23130
80002eca:	ea 18 ab cd 	orh	r8,0xabcd
80002ece:	8f 28       	st.w	r7[0x8],r8
		payload_tx_channel->dword[1] = PAYLOADIDLE1;
80002ed0:	30 08       	mov	r8,0
80002ed2:	8f 38       	st.w	r7[0xc],r8
	#else
	/*send idle frame*/	
	((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
	((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
	#endif /*end if*/
}
80002ed4:	2f fd       	sub	sp,-4
80002ed6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002eda:	00 00       	add	r0,r0
80002edc:	00 00       	add	r0,r0
80002ede:	0a c4       	st.b	r5++,r4
80002ee0:	00 00       	add	r0,r0
80002ee2:	0a 9c       	mov	r12,r5
80002ee4:	00 00       	add	r0,r0
80002ee6:	0a 78       	tst	r8,r5
80002ee8:	80 00       	ld.sh	r0,r0[0x0]
80002eea:	51 70       	stdsp	sp[0x5c],r0
80002eec:	00 00       	add	r0,r0
80002eee:	0a bc       	st.h	r5++,r12
80002ef0:	00 00       	add	r0,r0
80002ef2:	0a 81       	andn	r1,r5
80002ef4:	00 00       	add	r0,r0
80002ef6:	0a 4f       	or	pc,r5
80002ef8:	00 00       	add	r0,r0
80002efa:	0a 74       	tst	r4,r5
80002efc:	00 00       	add	r0,r0
80002efe:	0a ac       	st.w	r5++,r12
80002f00:	80 00       	ld.sh	r0,r0[0x0]
80002f02:	c7 64       	brge	80002fee <phy_init+0x9a>
80002f04:	00 00       	add	r0,r0
80002f06:	0a 68       	and	r8,r5
80002f08:	00 00       	add	r0,r0
80002f0a:	0a cc       	st.b	r5++,r12
80002f0c:	00 00       	add	r0,r0
80002f0e:	0d 7c       	ld.ub	r12,--r6
80002f10:	00 00       	add	r0,r0
80002f12:	0e 78       	tst	r8,r7
80002f14:	00 00       	add	r0,r0
80002f16:	0a 40       	or	r0,r5
80002f18:	80 00       	ld.sh	r0,r0[0x0]
80002f1a:	c7 06       	brmi	80002ffa <phy_init+0xa6>
80002f1c:	00 00       	add	r0,r0
80002f1e:	0d 74       	ld.ub	r4,--r6
80002f20:	00 00       	add	r0,r0
80002f22:	0a 98       	mov	r8,r5
80002f24:	00 00       	add	r0,r0
80002f26:	0e 7c       	tst	r12,r7
80002f28:	00 00       	add	r0,r0
80002f2a:	0d 80       	ld.ub	r0,r6[0x0]

80002f2c <get_idle_store>:
	}//End of RxMedia Phy Handler.
}
#endif /*end if*/

void * get_idle_store(xQueueHandle store)
{
80002f2c:	d4 01       	pushm	lr
80002f2e:	20 1d       	sub	sp,4
	void * ptr = NULL;
80002f30:	30 0a       	mov	r10,0
80002f32:	fa cb ff fc 	sub	r11,sp,-4
80002f36:	16 da       	st.w	--r11,r10

	if(pdTRUE == xQueueReceive(store, &ptr, 0))
80002f38:	14 99       	mov	r9,r10
80002f3a:	1a 9b       	mov	r11,sp
80002f3c:	f0 1f 00 05 	mcall	80002f50 <get_idle_store+0x24>
80002f40:	58 1c       	cp.w	r12,1
80002f42:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80002f46:	fb fc 00 00 	ld.weq	r12,sp[0x0]
	}
	else
	{
		return NULL;
	}
}
80002f4a:	2f fd       	sub	sp,-4
80002f4c:	d8 02       	popm	pc
80002f4e:	00 00       	add	r0,r0
80002f50:	80 00       	ld.sh	r0,r0[0x0]
80002f52:	52 60       	stdsp	sp[0x98],r0

80002f54 <phy_init>:
    register_rx_tx_func -- ssc.c
	xQueueCreate -- freertos
Called By: xnl_init -- xnl.c
*/
void phy_init( void )
{
80002f54:	eb cd 40 e0 	pushm	r5-r7,lr
    /*initialize the SSC*/
    ssc_init();
80002f58:	f0 1f 00 21 	mcall	80002fdc <phy_init+0x88>

    /*register the func to send/receive ssc packet*/
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
80002f5c:	4a 1b       	lddpc	r11,80002fe0 <phy_init+0x8c>
80002f5e:	4a 2c       	lddpc	r12,80002fe4 <phy_init+0x90>
80002f60:	f0 1f 00 22 	mcall	80002fe8 <phy_init+0x94>
	
	/*if enable send/receive payload(media), defined in physical.h*/	
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
80002f64:	30 4b       	mov	r11,4
80002f66:	31 ec       	mov	r12,30
80002f68:	f0 1f 00 21 	mcall	80002fec <phy_init+0x98>
80002f6c:	4a 18       	lddpc	r8,80002ff0 <phy_init+0x9c>
80002f6e:	91 0c       	st.w	r8[0x0],r12
80002f70:	30 07       	mov	r7,0
	phy_fragment_t * xnl_ptr = NULL;
	for(int i= 0; i < MAX_XNL_STORE; i++ )
	{
		set_xnl_idle(&xnl_store[i]);
80002f72:	10 96       	mov	r6,r8
80002f74:	4a 05       	lddpc	r5,80002ff4 <phy_init+0xa0>
80002f76:	6c 0c       	ld.w	r12,r6[0x0]
80002f78:	ea 07 00 0b 	add	r11,r5,r7
80002f7c:	f0 1f 00 1f 	mcall	80002ff8 <phy_init+0xa4>
80002f80:	ee c7 ff 00 	sub	r7,r7,-256
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
	
	/*if enable send/receive payload(media), defined in physical.h*/	
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
	phy_fragment_t * xnl_ptr = NULL;
	for(int i= 0; i < MAX_XNL_STORE; i++ )
80002f84:	e0 47 1e 00 	cp.w	r7,7680
80002f88:	cf 71       	brne	80002f76 <phy_init+0x22>
	{
		set_xnl_idle(&xnl_store[i]);
	}
		
    /*initialize the queue to send/receive xnl packet */	
    phy_xnl_frame_tx = xQueueCreate(TX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
80002f8a:	30 4b       	mov	r11,4
80002f8c:	31 4c       	mov	r12,20
80002f8e:	f0 1f 00 18 	mcall	80002fec <phy_init+0x98>
80002f92:	49 b8       	lddpc	r8,80002ffc <phy_init+0xa8>
80002f94:	91 0c       	st.w	r8[0x0],r12
    phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
80002f96:	30 4b       	mov	r11,4
80002f98:	30 ac       	mov	r12,10
80002f9a:	f0 1f 00 15 	mcall	80002fec <phy_init+0x98>
80002f9e:	49 98       	lddpc	r8,80003000 <phy_init+0xac>
80002fa0:	91 0c       	st.w	r8[0x0],r12
	
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
80002fa2:	30 4b       	mov	r11,4
80002fa4:	30 ac       	mov	r12,10
80002fa6:	f0 1f 00 12 	mcall	80002fec <phy_init+0x98>
80002faa:	49 78       	lddpc	r8,80003004 <phy_init+0xb0>
80002fac:	91 0c       	st.w	r8[0x0],r12
80002fae:	30 07       	mov	r7,0
	U8 * payload_ptr = NULL;
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
	{
		set_payload_idle(payload_store[i]);
80002fb0:	10 96       	mov	r6,r8
80002fb2:	49 65       	lddpc	r5,80003008 <phy_init+0xb4>
80002fb4:	6c 0c       	ld.w	r12,r6[0x0]
80002fb6:	ea 07 00 0b 	add	r11,r5,r7
80002fba:	f0 1f 00 10 	mcall	80002ff8 <phy_init+0xa4>
80002fbe:	ee c7 fe 00 	sub	r7,r7,-512
    phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
	
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
	U8 * payload_ptr = NULL;
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
80002fc2:	e0 47 14 00 	cp.w	r7,5120
80002fc6:	cf 71       	brne	80002fb4 <phy_init+0x60>
		set_payload_idle(payload_store[i]);
	}
		
	/*initialize the queue to send/receive xnl packet */
	phy_payload_frame_tx =
	xQueueCreate(TX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t));
80002fc8:	e0 6b 01 00 	mov	r11,256
80002fcc:	30 5c       	mov	r12,5
80002fce:	f0 1f 00 08 	mcall	80002fec <phy_init+0x98>
	{
		set_payload_idle(payload_store[i]);
	}
		
	/*initialize the queue to send/receive xnl packet */
	phy_payload_frame_tx =
80002fd2:	48 f8       	lddpc	r8,8000300c <phy_init+0xb8>
80002fd4:	91 0c       	st.w	r8[0x0],r12
		
	//phy_payload_frame_rx =
	//xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
	#endif /*end if*/
	
}
80002fd6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80002fda:	00 00       	add	r0,r0
80002fdc:	80 00       	ld.sh	r0,r0[0x0]
80002fde:	3e 00       	mov	r0,-32
80002fe0:	80 00       	ld.sh	r0,r0[0x0]
80002fe2:	2a 64       	sub	r4,-90
80002fe4:	80 00       	ld.sh	r0,r0[0x0]
80002fe6:	30 70       	mov	r0,7
80002fe8:	80 00       	ld.sh	r0,r0[0x0]
80002fea:	3d ec       	mov	r12,-34
80002fec:	80 00       	ld.sh	r0,r0[0x0]
80002fee:	55 6c       	stdsp	sp[0x158],r12
80002ff0:	00 00       	add	r0,r0
80002ff2:	0a 90       	mov	r0,r5
80002ff4:	00 00       	add	r0,r0
80002ff6:	22 96       	sub	r6,41
80002ff8:	80 00       	ld.sh	r0,r0[0x0]
80002ffa:	29 c0       	sub	r0,-100
80002ffc:	00 00       	add	r0,r0
80002ffe:	0a c4       	st.b	r5++,r4
80003000:	00 00       	add	r0,r0
80003002:	0a b8       	st.h	r5++,r8
80003004:	00 00       	add	r0,r0
80003006:	0a 6c       	and	r12,r5
80003008:	00 00       	add	r0,r0
8000300a:	0e 96       	mov	r6,r7
8000300c:	00 00       	add	r0,r0
8000300e:	0a b4       	st.h	r5++,r4

80003010 <payload_rx>:




static void payload_rx(void * payload)
{
80003010:	d4 01       	pushm	lr
80003012:	20 2d       	sub	sp,8
80003014:	50 0c       	stdsp	sp[0x0],r12
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80003016:	30 08       	mov	r8,0
80003018:	50 18       	stdsp	sp[0x4],r8
	
	//set_payload_idle(payload);
	if(NULL == phy_payload_frame_rx)
8000301a:	48 f8       	lddpc	r8,80003054 <payload_rx+0x44>
8000301c:	70 08       	ld.w	r8,r8[0x0]
8000301e:	58 08       	cp.w	r8,0
80003020:	c0 71       	brne	8000302e <payload_rx+0x1e>
	{
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));		
80003022:	30 4b       	mov	r11,4
80003024:	30 5c       	mov	r12,5
80003026:	f0 1f 00 0d 	mcall	80003058 <payload_rx+0x48>
8000302a:	48 b8       	lddpc	r8,80003054 <payload_rx+0x44>
8000302c:	91 0c       	st.w	r8[0x0],r12
	}

	if(errQUEUE_FULL == xQueueSendFromISR(phy_payload_frame_rx, &payload, &xHigherPriorityTaskWoken))
8000302e:	48 a8       	lddpc	r8,80003054 <payload_rx+0x44>
80003030:	70 0c       	ld.w	r12,r8[0x0]
80003032:	30 09       	mov	r9,0
80003034:	fa ca ff fc 	sub	r10,sp,-4
80003038:	1a 9b       	mov	r11,sp
8000303a:	f0 1f 00 09 	mcall	8000305c <payload_rx+0x4c>
8000303e:	c0 91       	brne	80003050 <payload_rx+0x40>
	//if(errQUEUE_FULL == xQueueSend(phy_payload_frame_rx, &payload, 0))
	{	//To payload_rx_process();	
		
		set_payload_idle_isr(payload);
80003040:	48 88       	lddpc	r8,80003060 <payload_rx+0x50>
80003042:	70 0c       	ld.w	r12,r8[0x0]
80003044:	40 0b       	lddsp	r11,sp[0x0]
80003046:	f0 1f 00 08 	mcall	80003064 <payload_rx+0x54>
		logFromISR("mm");
8000304a:	48 8c       	lddpc	r12,80003068 <payload_rx+0x58>
8000304c:	f0 1f 00 08 	mcall	8000306c <payload_rx+0x5c>
			
		}
		//set_payload_idle_isr(payload);
		//logFromISR("ss");
	}
}
80003050:	2f ed       	sub	sp,-8
80003052:	d8 02       	popm	pc
80003054:	00 00       	add	r0,r0
80003056:	0a 88       	andn	r8,r5
80003058:	80 00       	ld.sh	r0,r0[0x0]
8000305a:	55 6c       	stdsp	sp[0x158],r12
8000305c:	80 00       	ld.sh	r0,r0[0x0]
8000305e:	54 1c       	stdsp	sp[0x104],r12
80003060:	00 00       	add	r0,r0
80003062:	0a 6c       	and	r12,r5
80003064:	80 00       	ld.sh	r0,r0[0x0]
80003066:	29 6c       	sub	r12,-106
80003068:	80 00       	ld.sh	r0,r0[0x0]
8000306a:	c7 80       	breq	8000315a <phy_rx_func+0xea>
8000306c:	80 00       	ld.sh	r0,r0[0x0]
8000306e:	61 90       	ld.w	r0,r0[0x64]

80003070 <phy_rx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_rx_func( void * ssc)
{    
80003070:	eb cd 40 e0 	pushm	r5-r7,lr
80003074:	18 97       	mov	r7,r12
		
	if(NULL != phy_xnl_frame_rx)
80003076:	fe f8 0b be 	ld.w	r8,pc[3006]
8000307a:	70 08       	ld.w	r8,r8[0x0]
8000307c:	58 08       	cp.w	r8,0
8000307e:	e0 80 01 05 	breq	80003288 <phy_rx_func+0x218>
	static U16 phy_check_sum = 0;

	static phy_rx_state_t  phy_rx_state = WAITING_FOR_HEADER;
	static U32 phy_rx_count = 0;

	U32 phy_dword = xnl_rx_channel->dword;	
80003082:	78 16       	ld.w	r6,r12[0x4]

	phy_rx_count++;
80003084:	fe f8 0b b4 	ld.w	r8,pc[2996]
80003088:	70 09       	ld.w	r9,r8[0x0]
8000308a:	2f f9       	sub	r9,-1
8000308c:	91 09       	st.w	r8[0x0],r9
	
	/*This is the code for parsing the incoming physical message.*/
	switch (phy_rx_state)
8000308e:	fe f8 0b ae 	ld.w	r8,pc[2990]
80003092:	70 08       	ld.w	r8,r8[0x0]
80003094:	58 18       	cp.w	r8,1
80003096:	e0 80 00 84 	breq	8000319e <phy_rx_func+0x12e>
8000309a:	c0 73       	brcs	800030a8 <phy_rx_func+0x38>
8000309c:	58 28       	cp.w	r8,2
8000309e:	c5 b0       	breq	80003154 <phy_rx_func+0xe4>
800030a0:	58 38       	cp.w	r8,3
800030a2:	e0 81 00 f3 	brne	80003288 <phy_rx_func+0x218>
800030a6:	cd 38       	rjmp	8000324c <phy_rx_func+0x1dc>

        /*Waiting for something. Most frequent visit.*/		
		case WAITING_FOR_HEADER:
		
			/*Ignore Idles.*/
			if (0xABCD5A5A == phy_dword)
800030a8:	e0 6a 5a 5a 	mov	r10,23130
800030ac:	ea 1a ab cd 	orh	r10,0xabcd
800030b0:	14 36       	cp.w	r6,r10
800030b2:	e0 80 00 eb 	breq	80003288 <phy_rx_func+0x218>
			{
				break;
			}	

			/*Skip until Header.*/		
			if (0xABCD != (phy_dword >> 16))
800030b6:	ec 08 16 10 	lsr	r8,r6,0x10
800030ba:	e0 48 ab cd 	cp.w	r8,43981
800030be:	e0 81 00 e5 	brne	80003288 <phy_rx_func+0x218>
			{			
				break;
			}
		
			/*Length excluding CSUM.*/
			phy_rx_expexted_length = (phy_dword & 0x000000FF) - 2;
800030c2:	eb d6 b0 10 	bfexts	r5,r6,0x0,0x10
800030c6:	f1 d5 c0 08 	bfextu	r8,r5,0x0,0x8
800030ca:	20 28       	sub	r8,2
800030cc:	fe f9 0b 74 	ld.w	r9,pc[2932]
800030d0:	b2 08       	st.h	r9[0x0],r8
			
			/*Discard degenerate message.*/
			if (phy_rx_expexted_length <= 0)
800030d2:	30 09       	mov	r9,0
800030d4:	f2 08 19 00 	cp.h	r8,r9
800030d8:	e0 8a 00 d8 	brle	80003288 <phy_rx_func+0x218>
			{
				break;
			}
		
			phy_rx_length = 0;
800030dc:	fe f8 0b 68 	ld.w	r8,pc[2920]
800030e0:	b0 09       	st.h	r8[0x0],r9
			
			//get_xnl_idle_isr(&phy_frame_ptr, &xHigherPriorityTaskWoken);
			phy_frame_ptr = get_xnl_idle_isr();
800030e2:	fe f8 0b 66 	ld.w	r8,pc[2918]
800030e6:	70 0c       	ld.w	r12,r8[0x0]
800030e8:	f0 1f 02 d9 	mcall	80003c4c <phy_rx_func+0xbdc>
800030ec:	fe f8 0b 64 	ld.w	r8,pc[2916]
800030f0:	91 0c       	st.w	r8[0x0],r12
			if(NULL == phy_frame_ptr)
800030f2:	58 0c       	cp.w	r12,0
800030f4:	e0 80 00 ca 	breq	80003288 <phy_rx_func+0x218>
			//
			//xQueueReceiveFromISR(phy_store_idle, &phy_frame_ptr, &xHigherPriorityTaskWoken);
			
			//phy_frame_ptr = pvPortMalloc(sizeof(phy_fragment_t));
					
			phy_frame_ptr->fragment_element[phy_rx_length++] = phy_dword;
800030f8:	fe f8 0b 4c 	ld.w	r8,pc[2892]
800030fc:	90 09       	ld.sh	r9,r8[0x0]
800030fe:	f8 09 0a 15 	st.h	r12[r9<<0x1],r5
80003102:	2f f9       	sub	r9,-1
80003104:	5c 89       	casts.h	r9
			
			/*time stamp*/
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
80003106:	fe fa 0b 4a 	ld.w	r10,pc[2890]
8000310a:	74 0a       	ld.w	r10,r10[0x0]
8000310c:	fe fb 0b 2c 	ld.w	r11,pc[2860]
80003110:	76 0b       	ld.w	r11,r11[0x0]
80003112:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
80003116:	2f f9       	sub	r9,-1
80003118:	b0 09       	st.h	r8[0x0],r9
													(phy_rx_count) & 0x0000FFFF;
			
			/*This switch tests the fragment type, and adjusts receiver state
			accordingly.*/
			/*Check frag type*/
			switch (phy_dword & 0x00000F00)
8000311a:	e2 16 0f 00 	andl	r6,0xf00,COH
8000311e:	e0 46 01 00 	cp.w	r6,256
80003122:	c0 c0       	breq	8000313a <phy_rx_func+0xca>
80003124:	e0 8b 00 05 	brhi	8000312e <phy_rx_func+0xbe>
80003128:	58 06       	cp.w	r6,0
8000312a:	c0 80       	breq	8000313a <phy_rx_func+0xca>
8000312c:	c0 c8       	rjmp	80003144 <phy_rx_func+0xd4>
8000312e:	e0 46 02 00 	cp.w	r6,512
80003132:	c0 40       	breq	8000313a <phy_rx_func+0xca>
80003134:	e0 46 03 00 	cp.w	r6,768
80003138:	c0 61       	brne	80003144 <phy_rx_func+0xd4>
			{
				case SINGLE_FRAGMENT:  //Only Fragment.
				case FIRST_FRAGMENT:   //First of Multi-fragment.
				case MIDDLE_FRAGMENT:  //Continuing Multi-fragment.
				case LAST_FRAGMENT:    //Last Multi-fragment.
					phy_rx_state = WAITING_CHECK_SUM;
8000313a:	30 29       	mov	r9,2
8000313c:	fe f8 0b 00 	ld.w	r8,pc[2816]
80003140:	91 09       	st.w	r8[0x0],r9
80003142:	ca 38       	rjmp	80003288 <phy_rx_func+0x218>
				break;
				default:
					vPortFree(phy_frame_ptr);
80003144:	fe f6 0b 0c 	ld.w	r6,pc[2828]
80003148:	6c 0c       	ld.w	r12,r6[0x0]
8000314a:	f0 1f 02 c3 	mcall	80003c54 <phy_rx_func+0xbe4>
					phy_frame_ptr = NULL;					
8000314e:	30 08       	mov	r8,0
80003150:	8d 08       	st.w	r6[0x0],r8
80003152:	c9 b8       	rjmp	80003288 <phy_rx_func+0x218>
		
			/*Stores CSUM*/
			phy_check_sum  = (phy_dword & 0xFFFF0000) >> 16;
			
			/*sums in first hWord*/
			phy_check_sum += (phy_dword & 0x0000FFFF);		
80003154:	f5 d6 b0 10 	bfexts	r10,r6,0x0,0x10
80003158:	b1 86       	lsr	r6,0x10
8000315a:	14 06       	add	r6,r10
8000315c:	fe f8 0a fc 	ld.w	r8,pc[2812]
80003160:	b0 06       	st.h	r8[0x0],r6
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
80003162:	fe f8 0a e2 	ld.w	r8,pc[2786]
80003166:	90 09       	ld.sh	r9,r8[0x0]
80003168:	fe fb 0a e8 	ld.w	r11,pc[2792]
8000316c:	76 0b       	ld.w	r11,r11[0x0]
8000316e:	f6 09 0a 1a 	st.h	r11[r9<<0x1],r10
80003172:	2f f9       	sub	r9,-1
80003174:	b0 09       	st.h	r8[0x0],r9
														 phy_dword & 0x0000FFFF;
					
			phy_rx_expexted_length -= 2;
80003176:	fe f9 0a ca 	ld.w	r9,pc[2762]
8000317a:	92 08       	ld.sh	r8,r9[0x0]
8000317c:	20 28       	sub	r8,2
8000317e:	b2 08       	st.h	r9[0x0],r8
			
			/*Normal case for greater than one byte payloads.*/
			if (phy_rx_expexted_length > 0)
80003180:	30 09       	mov	r9,0
80003182:	f2 08 19 00 	cp.h	r8,r9
80003186:	e0 8a 00 07 	brle	80003194 <phy_rx_func+0x124>
			{					  
				phy_rx_state = READING_FRAGMENT;
8000318a:	30 19       	mov	r9,1
8000318c:	fe f8 0a b0 	ld.w	r8,pc[2736]
80003190:	91 09       	st.w	r8[0x0],r9
80003192:	c7 b8       	rjmp	80003288 <phy_rx_func+0x218>
	    		Note that all segments must align with a 32-bit boundary and
				beginning of each XCMP/XNL payload frame must start on slot 3
				Thus, segments of odd length must append a 0x0000 at the end
				(slot 4) to ensure alignment. [9.1.3]
				*/
				phy_rx_state = WAITING_LAST_TERM;
80003194:	30 39       	mov	r9,3
80003196:	fe f8 0a a6 	ld.w	r8,pc[2726]
8000319a:	91 09       	st.w	r8[0x0],r9
8000319c:	c7 68       	rjmp	80003288 <phy_rx_func+0x218>
			}			
		
			break;

		case READING_FRAGMENT:
			phy_check_sum += (phy_dword & 0xFFFF0000) >> 16;
8000319e:	ec 0a 14 10 	asr	r10,r6,0x10
800031a2:	fe f8 0a b6 	ld.w	r8,pc[2742]
800031a6:	90 09       	ld.sh	r9,r8[0x0]
800031a8:	14 09       	add	r9,r10
800031aa:	b0 09       	st.h	r8[0x0],r9
	
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
800031ac:	fe f9 0a 98 	ld.w	r9,pc[2712]
800031b0:	92 08       	ld.sh	r8,r9[0x0]
800031b2:	fe fb 0a 9e 	ld.w	r11,pc[2718]
800031b6:	76 0b       	ld.w	r11,r11[0x0]
800031b8:	f6 08 0a 1a 	st.h	r11[r8<<0x1],r10
800031bc:	2f f8       	sub	r8,-1
800031be:	5c 88       	casts.h	r8
800031c0:	b2 08       	st.h	r9[0x0],r8
												 (phy_dword & 0xFFFF0000) >> 16;
	
			phy_rx_expexted_length -= 2;
800031c2:	fe fa 0a 7e 	ld.w	r10,pc[2686]
800031c6:	94 09       	ld.sh	r9,r10[0x0]
800031c8:	20 29       	sub	r9,2
800031ca:	b4 09       	st.h	r10[0x0],r9
			if (phy_rx_expexted_length <= 0)
800031cc:	30 0a       	mov	r10,0
800031ce:	f4 09 19 00 	cp.h	r9,r10
800031d2:	e0 89 00 1f 	brgt	80003210 <phy_rx_func+0x1a0>
				Terminator should be in 2nd hWord.
				Shaoqun says useful bits not used. The packet will always end
				with $00BA. [9.1.2.8]	
				*/
				
				if ((0x000000BA == (phy_dword  & 0x0000FFFF)) 
800031d6:	ed d6 c0 10 	bfextu	r6,r6,0x0,0x10
800031da:	e0 46 00 ba 	cp.w	r6,186
800031de:	c0 d1       	brne	800031f8 <phy_rx_func+0x188>
800031e0:	fe f8 0a 78 	ld.w	r8,pc[2680]
800031e4:	90 09       	ld.sh	r9,r8[0x0]
800031e6:	f4 09 19 00 	cp.h	r9,r10
800031ea:	c0 71       	brne	800031f8 <phy_rx_func+0x188>
					&& (phy_check_sum == 0))
				{
					phy_rx(phy_frame_ptr);
800031ec:	fe f8 0a 64 	ld.w	r8,pc[2660]
800031f0:	70 0c       	ld.w	r12,r8[0x0]
800031f2:	f0 1f 02 9b 	mcall	80003c5c <phy_rx_func+0xbec>
800031f6:	c0 88       	rjmp	80003206 <phy_rx_func+0x196>
				}
				else
				{
					vPortFree(phy_frame_ptr);
800031f8:	fe f6 0a 58 	ld.w	r6,pc[2648]
800031fc:	6c 0c       	ld.w	r12,r6[0x0]
800031fe:	f0 1f 02 96 	mcall	80003c54 <phy_rx_func+0xbe4>
					phy_frame_ptr = NULL;
80003202:	30 08       	mov	r8,0
80003204:	8d 08       	st.w	r6[0x0],r8
				}

				phy_rx_state = WAITING_FOR_HEADER;
80003206:	30 09       	mov	r9,0
80003208:	fe f8 0a 34 	ld.w	r8,pc[2612]
8000320c:	91 09       	st.w	r8[0x0],r9
8000320e:	c3 d8       	rjmp	80003288 <phy_rx_func+0x218>
				break;
			}
		
			/*Have not broken. 2nd hWord contains payload.*/
			phy_check_sum += (phy_dword & 0x0000FFFF);
80003210:	5c 86       	casts.h	r6
80003212:	fe f9 0a 46 	ld.w	r9,pc[2630]
80003216:	92 0a       	ld.sh	r10,r9[0x0]
80003218:	0c 0a       	add	r10,r6
8000321a:	b2 0a       	st.h	r9[0x0],r10
		
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
8000321c:	fe f9 0a 34 	ld.w	r9,pc[2612]
80003220:	72 09       	ld.w	r9,r9[0x0]
80003222:	f2 08 0a 16 	st.h	r9[r8<<0x1],r6
80003226:	2f f8       	sub	r8,-1
80003228:	fe f9 0a 1c 	ld.w	r9,pc[2588]
8000322c:	b2 08       	st.h	r9[0x0],r8
													   (phy_dword & 0x0000FFFF);
		
			phy_rx_expexted_length -= 2;
8000322e:	fe f9 0a 12 	ld.w	r9,pc[2578]
80003232:	92 08       	ld.sh	r8,r9[0x0]
80003234:	20 28       	sub	r8,2
80003236:	b2 08       	st.h	r9[0x0],r8
			if (phy_rx_expexted_length <= 0)
80003238:	30 09       	mov	r9,0
8000323a:	f2 08 19 00 	cp.h	r8,r9
8000323e:	e0 89 00 25 	brgt	80003288 <phy_rx_func+0x218>
			{
				/*All read in. Next Word should be 0x00BA0000.*/
				phy_rx_state = WAITING_LAST_TERM;
80003242:	30 39       	mov	r9,3
80003244:	fe f8 09 f8 	ld.w	r8,pc[2552]
80003248:	91 09       	st.w	r8[0x0],r9
8000324a:	c1 f8       	rjmp	80003288 <phy_rx_func+0x218>
			}/*else, next Word contains more payload.*/
			break;

		/*Expecting last terminator 0x00BA0000.*/	
		case WAITING_LAST_TERM:			
			if ((0x00BA0000 == (phy_dword  & 0x00FF0000)) /*Expected found.*/
8000324c:	e6 16 00 ff 	andh	r6,0xff,COH
80003250:	fc 19 00 ba 	movh	r9,0xba
80003254:	12 36       	cp.w	r6,r9
80003256:	c0 e1       	brne	80003272 <phy_rx_func+0x202>
80003258:	fe f8 0a 00 	ld.w	r8,pc[2560]
8000325c:	90 09       	ld.sh	r9,r8[0x0]
8000325e:	30 08       	mov	r8,0
80003260:	f0 09 19 00 	cp.h	r9,r8
80003264:	c0 71       	brne	80003272 <phy_rx_func+0x202>
				&& (phy_check_sum == 0))/*Good checksum*/
			{
				phy_rx(phy_frame_ptr);
80003266:	fe f8 09 ea 	ld.w	r8,pc[2538]
8000326a:	70 0c       	ld.w	r12,r8[0x0]
8000326c:	f0 1f 02 7c 	mcall	80003c5c <phy_rx_func+0xbec>
80003270:	c0 88       	rjmp	80003280 <phy_rx_func+0x210>

			}
			else
			{
				vPortFree(phy_frame_ptr);
80003272:	fe f6 09 de 	ld.w	r6,pc[2526]
80003276:	6c 0c       	ld.w	r12,r6[0x0]
80003278:	f0 1f 02 77 	mcall	80003c54 <phy_rx_func+0xbe4>
				phy_frame_ptr = NULL;
8000327c:	30 08       	mov	r8,0
8000327e:	8d 08       	st.w	r6[0x0],r8
			}
				
			phy_rx_state = WAITING_FOR_HEADER;
80003280:	30 09       	mov	r9,0
80003282:	fe f8 09 ba 	ld.w	r8,pc[2490]
80003286:	91 09       	st.w	r8[0x0],r9
			
	//payload_ptr_t *AMBE_payload_ptr;		
				
	
	
	if(is_first == FALSE)
80003288:	fe f8 09 d8 	ld.w	r8,pc[2520]
8000328c:	11 89       	ld.ub	r9,r8[0x0]
8000328e:	30 08       	mov	r8,0
80003290:	f0 09 18 00 	cp.b	r9,r8
80003294:	c0 d1       	brne	800032ae <phy_rx_func+0x23e>
	{
		//payload_ptr = get_payload_idle_isr();
		AMBE_payload_ptr = get_payload_idle_isr();
80003296:	fe f8 09 ce 	ld.w	r8,pc[2510]
8000329a:	70 0c       	ld.w	r12,r8[0x0]
8000329c:	f0 1f 02 6c 	mcall	80003c4c <phy_rx_func+0xbdc>
800032a0:	fe f8 09 c8 	ld.w	r8,pc[2504]
800032a4:	91 0c       	st.w	r8[0x0],r12
		is_first = TRUE;
800032a6:	30 19       	mov	r9,1
800032a8:	fe f8 09 b8 	ld.w	r8,pc[2488]
800032ac:	b0 89       	st.b	r8[0x0],r9
	}	
	
	//This is the RxMedia Phy Handler.
	switch (RxMediaState)
800032ae:	fe f8 09 be 	ld.w	r8,pc[2494]
800032b2:	70 08       	ld.w	r8,r8[0x0]
800032b4:	58 38       	cp.w	r8,3
800032b6:	e0 80 04 7a 	breq	80003baa <phy_rx_func+0xb3a>
800032ba:	58 48       	cp.w	r8,4
800032bc:	e0 80 01 02 	breq	800034c0 <phy_rx_func+0x450>
800032c0:	58 08       	cp.w	r8,0
800032c2:	e0 81 04 b7 	brne	80003c30 <phy_rx_func+0xbc0>
	{
		case WAITINGABAB:

			
			if (payload_rx_channel->dword[0] == 0xABCD5A5A)//Ignore Idles.
800032c6:	6e 28       	ld.w	r8,r7[0x8]
800032c8:	e0 6a 5a 5a 	mov	r10,23130
800032cc:	ea 1a ab cd 	orh	r10,0xabcd
800032d0:	14 38       	cp.w	r8,r10
800032d2:	c0 71       	brne	800032e0 <phy_rx_func+0x270>
			{
				m_RxBurstType = VOICE_WATING;
800032d4:	30 09       	mov	r9,0
800032d6:	fe f8 09 9a 	ld.w	r8,pc[2458]
800032da:	91 09       	st.w	r8[0x0],r9
800032dc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
				//Upon receiving the idle frame, the m Rx Burst Type into an idle state in order to transmit the synchronization wait
				 break; 
			}
            
			if ((payload_rx_channel->dword[0]  & 0xFFFF0000) != 0xABCD0000)break; //Skip until Header. 
800032e0:	10 99       	mov	r9,r8
800032e2:	e0 19 00 00 	andl	r9,0x0
800032e6:	fc 1a ab cd 	movh	r10,0xabcd
800032ea:	14 39       	cp.w	r9,r10
800032ec:	e0 81 04 a2 	brne	80003c30 <phy_rx_func+0xbc0>
			}
			//logFromISR("\n\r P: %X \n\r", payload_rx_channel->word[1]);//测试收到的数据
			
			#endif
			
			RxBytesWaiting = payload_rx_channel->dword[0] & 0x000000FF;
800032f0:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
800032f4:	fe f9 09 80 	ld.w	r9,pc[2432]
800032f8:	93 08       	st.w	r9[0x0],r8
		
			if( (NULL== AMBE_payload_ptr))
800032fa:	fe f8 09 6e 	ld.w	r8,pc[2414]
800032fe:	70 08       	ld.w	r8,r8[0x0]
80003300:	58 08       	cp.w	r8,0
80003302:	c1 11       	brne	80003324 <phy_rx_func+0x2b4>
			{
				//payload_ptr = get_payload_idle_isr();
				AMBE_payload_ptr = get_payload_idle_isr();
80003304:	fe f8 09 60 	ld.w	r8,pc[2400]
80003308:	70 0c       	ld.w	r12,r8[0x0]
8000330a:	f0 1f 02 51 	mcall	80003c4c <phy_rx_func+0xbdc>
8000330e:	fe f8 09 5a 	ld.w	r8,pc[2394]
80003312:	91 0c       	st.w	r8[0x0],r12
				
				if (NULL== AMBE_payload_ptr)
80003314:	58 0c       	cp.w	r12,0
80003316:	c0 71       	brne	80003324 <phy_rx_func+0x2b4>
				{
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
80003318:	fe fc 09 60 	ld.w	r12,pc[2400]
8000331c:	f0 1f 02 58 	mcall	80003c7c <phy_rx_func+0xc0c>
80003320:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003324:	6e 28       	ld.w	r8,r7[0x8]
80003326:	e2 18 f0 00 	andl	r8,0xf000,COH
8000332a:	e0 48 c0 00 	cp.w	r8,49152
8000332e:	e0 81 00 c3 	brne	800034b4 <phy_rx_func+0x444>
		
			/****Note AMBE stream protocol frame structure and the PCM frame structure is different*****/
					
			if ((payload_rx_channel->dword[0] & 0x0000F000 ) == PAYLOAD_DATA_ENH )//PAYLOAD_DATA_ENH (0x0c))
			{
				AMBE_Media = 1;	
80003332:	30 19       	mov	r9,1
80003334:	fe f8 09 4c 	ld.w	r8,pc[2380]
80003338:	b0 89       	st.b	r8[0x0],r9
											
				Item_ID = payload_rx_channel->byte[5];
8000333a:	ef 39 00 0d 	ld.ub	r9,r7[13]
8000333e:	fe f8 09 46 	ld.w	r8,pc[2374]
80003342:	b0 89       	st.b	r8[0x0],r9
				
				Item_Length = (payload_rx_channel->byte[4] & 0x7F);//7bits
80003344:	ef 3a 00 0c 	ld.ub	r10,r7[12]
80003348:	f5 da c0 07 	bfextu	r10,r10,0x0,0x7
8000334c:	fe f9 09 3c 	ld.w	r9,pc[2364]
80003350:	93 0a       	st.w	r9[0x0],r10
								
				switch(Item_ID)
80003352:	11 88       	ld.ub	r8,r8[0x0]
80003354:	37 f9       	mov	r9,127
80003356:	f2 08 18 00 	cp.b	r8,r9
8000335a:	c6 d0       	breq	80003434 <phy_rx_func+0x3c4>
8000335c:	e0 8b 00 0c 	brhi	80003374 <phy_rx_func+0x304>
80003360:	31 29       	mov	r9,18
80003362:	f2 08 18 00 	cp.b	r8,r9
80003366:	c4 20       	breq	800033ea <phy_rx_func+0x37a>
80003368:	31 39       	mov	r9,19
8000336a:	f2 08 18 00 	cp.b	r8,r9
8000336e:	e0 81 00 83 	brne	80003474 <phy_rx_func+0x404>
80003372:	c5 b8       	rjmp	80003428 <phy_rx_func+0x3b8>
80003374:	2f 08       	sub	r8,-16
80003376:	30 19       	mov	r9,1
80003378:	f2 08 18 00 	cp.b	r8,r9
8000337c:	e0 8b 00 7c 	brhi	80003474 <phy_rx_func+0x404>
					//The OB know the Call begin and discard the Voice Header
					//The OB know the Call end and discard the Voice  Terminator
					case Raw_Tx_Data_HT://0xF0
					case Raw_Rx_Data_HT://0xF1
					
							if ((payload_rx_channel->byte[6] & 0xF0 )== 0x10)//header
80003380:	ef 38 00 0e 	ld.ub	r8,r7[14]
80003384:	e2 18 00 f0 	andl	r8,0xf0,COH
80003388:	59 08       	cp.w	r8,16
8000338a:	c0 71       	brne	80003398 <phy_rx_func+0x328>
							{
								m_RxBurstType = VOICEHEADER;
8000338c:	30 19       	mov	r9,1
8000338e:	fe f8 08 e2 	ld.w	r8,pc[2274]
80003392:	91 09       	st.w	r8[0x0],r9
80003394:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

							}
							else if ((payload_rx_channel->byte[6] & 0xF0) == 0x20)//Terminator
80003398:	e0 48 00 20 	cp.w	r8,32
8000339c:	c2 11       	brne	800033de <phy_rx_func+0x36e>
							{
								m_RxBurstType = VOICETERMINATOR;
8000339e:	30 a9       	mov	r9,10
800033a0:	fe f8 08 d0 	ld.w	r8,pc[2256]
800033a4:	91 09       	st.w	r8[0x0],r9
								//AMBE-data and PCM-data is not the same. AMBE is compressed data,
								//if there was a missing portion, a clear voice is difficult to extract the data.
								//It must ensure that all the data received AMBE.
								
								//注意！！！考虑是否需要把剩余的空间置0。
								memset((AMBE_payload_ptr+ (RxAMBE_IsFillingNext8 +1)), 0x00, (512-(RxAMBE_IsFillingNext8 + 1)));
800033a6:	fe f6 08 e6 	ld.w	r6,pc[2278]
800033aa:	6c 08       	ld.w	r8,r6[0x0]
800033ac:	f0 0a 11 ff 	rsub	r10,r8,-1
800033b0:	fe f7 08 b8 	ld.w	r7,pc[2232]
800033b4:	2f f8       	sub	r8,-1
800033b6:	6e 0c       	ld.w	r12,r7[0x0]
800033b8:	f4 ca fe 00 	sub	r10,r10,-512
800033bc:	30 0b       	mov	r11,0
800033be:	10 0c       	add	r12,r8
800033c0:	f0 1f 02 34 	mcall	80003c90 <phy_rx_func+0xc20>
								
								RxAMBE_IsFillingNext8 = 0;
800033c4:	30 08       	mov	r8,0
800033c6:	8d 08       	st.w	r6[0x0],r8
								payload_rx(AMBE_payload_ptr);
800033c8:	6e 0c       	ld.w	r12,r7[0x0]
800033ca:	f0 1f 02 33 	mcall	80003c94 <phy_rx_func+0xc24>
								AMBE_payload_ptr = get_payload_idle_isr();
800033ce:	fe f8 08 96 	ld.w	r8,pc[2198]
800033d2:	70 0c       	ld.w	r12,r8[0x0]
800033d4:	f0 1f 02 1e 	mcall	80003c4c <phy_rx_func+0xbdc>
800033d8:	8f 0c       	st.w	r7[0x0],r12
800033da:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								//logFromISR("\n\r QQ1 \n\r");
								
							}
							else//error voice
							{
								m_RxBurstType = VOICE_WATING;
800033de:	30 09       	mov	r9,0
800033e0:	fe f8 08 90 	ld.w	r8,pc[2192]
800033e4:	91 09       	st.w	r8[0x0],r9
800033e6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;//WAITINGABAB.
					
		
					case Vocoder_Bit_Stream_Parameter://0x12
							
							if ((RxBytesWaiting -= 4) <= 0) break;
800033ea:	fe f9 08 8a 	ld.w	r9,pc[2186]
800033ee:	72 08       	ld.w	r8,r9[0x0]
800033f0:	20 48       	sub	r8,4
800033f2:	93 08       	st.w	r9[0x0],r8
800033f4:	e0 80 04 1e 	breq	80003c30 <phy_rx_func+0xbc0>
					
							//Vocoder Bits Stream Parameter
							VF_SN = (payload_rx_channel->byte[7] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
800033f8:	ef 3c 00 0f 	ld.ub	r12,r7[15]
800033fc:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
80003400:	fe f8 08 98 	ld.w	r8,pc[2200]
80003404:	b0 8c       	st.b	r8[0x0],r12
							
							VBSP_data[0] = payload_rx_channel->word[2];
80003406:	8e 69       	ld.sh	r9,r7[0xc]
80003408:	fe f8 08 94 	ld.w	r8,pc[2196]
8000340c:	b0 09       	st.h	r8[0x0],r9
							VBSP_data[1] = payload_rx_channel->word[3];
8000340e:	8e 79       	ld.sh	r9,r7[0xe]
80003410:	b0 19       	st.h	r8[0x2],r9
							
							m_RxBurstType = CalculateBurst(VF_SN);
80003412:	f0 1f 02 24 	mcall	80003ca0 <phy_rx_func+0xc30>
80003416:	fe f8 08 5a 	ld.w	r8,pc[2138]
8000341a:	91 0c       	st.w	r8[0x0],r12
							
							RxMediaState = READING_AMBE_MEDIA;//Jump
8000341c:	30 49       	mov	r9,4
8000341e:	fe f8 08 4e 	ld.w	r8,pc[2126]
80003422:	91 09       	st.w	r8[0x0],r9
80003424:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							
					//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
					// or discard it to reduce payload size.	
					//This shouldn't happen, but must check.	
					case Soft_Decision_Value://0x13
						m_RxBurstType = VOICE_WATING;
80003428:	30 09       	mov	r9,0
8000342a:	fe f8 08 46 	ld.w	r8,pc[2118]
8000342e:	91 09       	st.w	r8[0x0],r9
80003430:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
					case Radio_Internal_Parameter://0x7F
							
							//logFromISR("\n\r Item_Length:%d\n\r", Item_Length);
							
							if ((RxBytesWaiting -= 4) <= 0) break;
80003434:	fe f9 08 40 	ld.w	r9,pc[2112]
80003438:	72 08       	ld.w	r8,r9[0x0]
8000343a:	20 48       	sub	r8,4
8000343c:	93 08       	st.w	r9[0x0],r8
8000343e:	e0 80 03 f9 	breq	80003c30 <phy_rx_func+0xbc0>
							//Radio Internal Parameter
							Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[3];
80003442:	fe f8 08 62 	ld.w	r8,pc[2146]
80003446:	70 09       	ld.w	r9,r8[0x0]
80003448:	8e 7b       	ld.sh	r11,r7[0xe]
8000344a:	fe fa 08 5e 	ld.w	r10,pc[2142]
8000344e:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
							RxData_IsFillingNext16 += 1; 
80003452:	2f f9       	sub	r9,-1
80003454:	91 09       	st.w	r8[0x0],r9
							Item_Length -= 2 ;
80003456:	fe f8 08 32 	ld.w	r8,pc[2098]
8000345a:	70 09       	ld.w	r9,r8[0x0]
8000345c:	20 29       	sub	r9,2
8000345e:	91 09       	st.w	r8[0x0],r9
							//....................................................
							m_RxBurstType = RADIOINTERNAL;
80003460:	30 29       	mov	r9,2
80003462:	fe f8 08 0e 	ld.w	r8,pc[2062]
80003466:	91 09       	st.w	r8[0x0],r9

							RxMediaState = READING_AMBE_AUX;//Jump
80003468:	30 39       	mov	r9,3
8000346a:	fe f8 08 02 	ld.w	r8,pc[2050]
8000346e:	91 09       	st.w	r8[0x0],r9
80003470:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									
					default://0x03,0x04
						
						//((Item_ID == 0x04) || (Item_ID == 0x03) )//Unknown type data directly back hair
							//break;
							m_RxBurstType = UNSUREDATA;
80003474:	30 39       	mov	r9,3
80003476:	fe f8 07 fa 	ld.w	r8,pc[2042]
8000347a:	91 09       	st.w	r8[0x0],r9
							AMBE_HT[0] = payload_rx_channel->dword[0];
8000347c:	6e 29       	ld.w	r9,r7[0x8]
8000347e:	fe f8 08 2e 	ld.w	r8,pc[2094]
80003482:	91 09       	st.w	r8[0x0],r9
							AMBE_HT[1] = payload_rx_channel->dword[1];
80003484:	6e 39       	ld.w	r9,r7[0xc]
80003486:	91 19       	st.w	r8[0x4],r9
							
							if (RxBytesWaiting == 0x00000014)
80003488:	fe f8 07 ec 	ld.w	r8,pc[2028]
8000348c:	70 08       	ld.w	r8,r8[0x0]
8000348e:	59 48       	cp.w	r8,20
80003490:	c0 61       	brne	8000349c <phy_rx_func+0x42c>
							{
								RxBytesWaiting = 0x18;//24 Reassigned
80003492:	31 89       	mov	r9,24
80003494:	fe f8 07 e0 	ld.w	r8,pc[2016]
80003498:	91 09       	st.w	r8[0x0],r9
8000349a:	c0 78       	rjmp	800034a8 <phy_rx_func+0x438>
								//_flag =0;
								
							}
							if (RxBytesWaiting == 0x00000010)
8000349c:	59 08       	cp.w	r8,16
8000349e:	c0 51       	brne	800034a8 <phy_rx_func+0x438>
							{
								RxBytesWaiting = 0x10;//16 Reassigned
800034a0:	31 09       	mov	r9,16
800034a2:	fe f8 07 d2 	ld.w	r8,pc[2002]
800034a6:	91 09       	st.w	r8[0x0],r9
								//_flag =1;
							}
					
							RxMediaState = READING_AMBE_MEDIA;//Jump
800034a8:	30 49       	mov	r9,4
800034aa:	fe f8 07 c2 	ld.w	r8,pc[1986]
800034ae:	91 09       	st.w	r8[0x0],r9
800034b0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
				break;
			}
			
			else
			{
				AMBE_Media = 0;	
800034b4:	30 09       	mov	r9,0
800034b6:	fe f8 07 ca 	ld.w	r8,pc[1994]
800034ba:	b0 89       	st.b	r8[0x0],r9
800034bc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

		case READING_AMBE_MEDIA:
		
			/****AMBE-media-data ****/
		
					if ((Item_ID == Vocoder_Bit_Stream_Parameter))//PAYLOAD_DATA_ENH (0x0c))
800034c0:	fe f8 07 c4 	ld.w	r8,pc[1988]
800034c4:	11 89       	ld.ub	r9,r8[0x0]
800034c6:	31 28       	mov	r8,18
800034c8:	f0 09 18 00 	cp.b	r9,r8
800034cc:	e0 81 01 4c 	brne	80003764 <phy_rx_func+0x6f4>
					{
						Item_ID = payload_rx_channel->byte[1];
800034d0:	ef 39 00 09 	ld.ub	r9,r7[9]
800034d4:	fe f8 07 b0 	ld.w	r8,pc[1968]
800034d8:	b0 89       	st.b	r8[0x0],r9
						if (Item_ID == Post_Voice_Encoder_Data)//发送方的压缩类型数据
800034da:	11 89       	ld.ub	r9,r8[0x0]
800034dc:	3f 28       	mov	r8,-14
800034de:	f0 09 18 00 	cp.b	r9,r8
800034e2:	e0 81 01 3b 	brne	80003758 <phy_rx_func+0x6e8>
						{
							AMBE_tx_flag = 1;
800034e6:	30 19       	mov	r9,1
800034e8:	fe f8 07 c8 	ld.w	r8,pc[1992]
800034ec:	b0 89       	st.b	r8[0x0],r9
							
							RxBytesWaiting = ((payload_rx_channel->dword[0] & 0x7F000000) >>24);//Test calculations are correct; 8
800034ee:	6e 29       	ld.w	r9,r7[0x8]
800034f0:	f3 d9 c3 07 	bfextu	r9,r9,0x18,0x7
800034f4:	fe f8 07 80 	ld.w	r8,pc[1920]
800034f8:	91 09       	st.w	r8[0x0],r9
							
							//For looping back to Radio
							AMBEBurst_rawdata[0] = payload_rx_channel->word[1];
800034fa:	8e 59       	ld.sh	r9,r7[0xa]
800034fc:	fe f8 07 b8 	ld.w	r8,pc[1976]
80003500:	b0 09       	st.h	r8[0x0],r9
							AMBEBurst_rawdata[1] = payload_rx_channel->word[2];
80003502:	8e 69       	ld.sh	r9,r7[0xc]
80003504:	b0 19       	st.h	r8[0x2],r9
							AMBEBurst_rawdata[2] = payload_rx_channel->word[3];
80003506:	8e 79       	ld.sh	r9,r7[0xe]
80003508:	b0 29       	st.h	r8[0x4],r9
							
							//To be tested. Also locally stored RAW-AMBER-DATA
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//1
8000350a:	fe f8 07 82 	ld.w	r8,pc[1922]
8000350e:	fe f9 07 5a 	ld.w	r9,pc[1882]
80003512:	72 0a       	ld.w	r10,r9[0x0]
80003514:	70 09       	ld.w	r9,r8[0x0]
80003516:	ef 3b 00 0a 	ld.ub	r11,r7[10]
8000351a:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
8000351e:	70 09       	ld.w	r9,r8[0x0]
80003520:	2f f9       	sub	r9,-1
80003522:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003524:	e0 49 01 ff 	cp.w	r9,511
80003528:	e0 88 00 16 	brls	80003554 <phy_rx_func+0x4e4>
							{
								RxAMBE_IsFillingNext8 = 0;
8000352c:	30 09       	mov	r9,0
8000352e:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003530:	fe f6 07 38 	ld.w	r6,pc[1848]
80003534:	6c 0c       	ld.w	r12,r6[0x0]
80003536:	f0 1f 01 d8 	mcall	80003c94 <phy_rx_func+0xc24>
								AMBE_payload_ptr = get_payload_idle_isr();
8000353a:	fe f8 07 2a 	ld.w	r8,pc[1834]
8000353e:	70 0c       	ld.w	r12,r8[0x0]
80003540:	f0 1f 01 c3 	mcall	80003c4c <phy_rx_func+0xbdc>
80003544:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003546:	c0 71       	brne	80003554 <phy_rx_func+0x4e4>
								{
									RxMediaState = WAITINGABAB;
80003548:	30 09       	mov	r9,0
8000354a:	fe f8 07 22 	ld.w	r8,pc[1826]
8000354e:	91 09       	st.w	r8[0x0],r9
80003550:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003554:	fe f9 07 20 	ld.w	r9,pc[1824]
80003558:	72 08       	ld.w	r8,r9[0x0]
8000355a:	20 18       	sub	r8,1
8000355c:	93 08       	st.w	r9[0x0],r8
8000355e:	c0 71       	brne	8000356c <phy_rx_func+0x4fc>
								RxMediaState = WAITINGABAB;
80003560:	30 09       	mov	r9,0
80003562:	fe f8 07 0a 	ld.w	r8,pc[1802]
80003566:	91 09       	st.w	r8[0x0],r9
80003568:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}			
							
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//2
8000356c:	fe f8 07 20 	ld.w	r8,pc[1824]
80003570:	fe f9 06 f8 	ld.w	r9,pc[1784]
80003574:	72 0a       	ld.w	r10,r9[0x0]
80003576:	70 09       	ld.w	r9,r8[0x0]
80003578:	ef 3b 00 0b 	ld.ub	r11,r7[11]
8000357c:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003580:	70 09       	ld.w	r9,r8[0x0]
80003582:	2f f9       	sub	r9,-1
80003584:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003586:	e0 49 01 ff 	cp.w	r9,511
8000358a:	e0 88 00 16 	brls	800035b6 <phy_rx_func+0x546>
							{
								RxAMBE_IsFillingNext8 = 0;
8000358e:	30 09       	mov	r9,0
80003590:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003592:	fe f6 06 d6 	ld.w	r6,pc[1750]
80003596:	6c 0c       	ld.w	r12,r6[0x0]
80003598:	f0 1f 01 bf 	mcall	80003c94 <phy_rx_func+0xc24>
								AMBE_payload_ptr = get_payload_idle_isr();
8000359c:	fe f8 06 c8 	ld.w	r8,pc[1736]
800035a0:	70 0c       	ld.w	r12,r8[0x0]
800035a2:	f0 1f 01 ab 	mcall	80003c4c <phy_rx_func+0xbdc>
800035a6:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
800035a8:	c0 71       	brne	800035b6 <phy_rx_func+0x546>
								{
									RxMediaState = WAITINGABAB;
800035aa:	30 09       	mov	r9,0
800035ac:	fe f8 06 c0 	ld.w	r8,pc[1728]
800035b0:	91 09       	st.w	r8[0x0],r9
800035b2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800035b6:	fe f9 06 be 	ld.w	r9,pc[1726]
800035ba:	72 08       	ld.w	r8,r9[0x0]
800035bc:	20 18       	sub	r8,1
800035be:	93 08       	st.w	r9[0x0],r8
800035c0:	c0 71       	brne	800035ce <phy_rx_func+0x55e>
								RxMediaState = WAITINGABAB;
800035c2:	30 09       	mov	r9,0
800035c4:	fe f8 06 a8 	ld.w	r8,pc[1704]
800035c8:	91 09       	st.w	r8[0x0],r9
800035ca:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}		
						
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//3
800035ce:	fe f8 06 be 	ld.w	r8,pc[1726]
800035d2:	fe f9 06 96 	ld.w	r9,pc[1686]
800035d6:	72 0a       	ld.w	r10,r9[0x0]
800035d8:	70 09       	ld.w	r9,r8[0x0]
800035da:	ef 3b 00 0c 	ld.ub	r11,r7[12]
800035de:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
800035e2:	70 09       	ld.w	r9,r8[0x0]
800035e4:	2f f9       	sub	r9,-1
800035e6:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800035e8:	e0 49 01 ff 	cp.w	r9,511
800035ec:	e0 88 00 16 	brls	80003618 <phy_rx_func+0x5a8>
							{
								RxAMBE_IsFillingNext8 = 0;
800035f0:	30 09       	mov	r9,0
800035f2:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800035f4:	fe f6 06 74 	ld.w	r6,pc[1652]
800035f8:	6c 0c       	ld.w	r12,r6[0x0]
800035fa:	f0 1f 01 a7 	mcall	80003c94 <phy_rx_func+0xc24>
								AMBE_payload_ptr = get_payload_idle_isr();
800035fe:	fe f8 06 66 	ld.w	r8,pc[1638]
80003602:	70 0c       	ld.w	r12,r8[0x0]
80003604:	f0 1f 01 92 	mcall	80003c4c <phy_rx_func+0xbdc>
80003608:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
8000360a:	c0 71       	brne	80003618 <phy_rx_func+0x5a8>
								{
									RxMediaState = WAITINGABAB;
8000360c:	30 09       	mov	r9,0
8000360e:	fe f8 06 5e 	ld.w	r8,pc[1630]
80003612:	91 09       	st.w	r8[0x0],r9
80003614:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003618:	fe f9 06 5c 	ld.w	r9,pc[1628]
8000361c:	72 08       	ld.w	r8,r9[0x0]
8000361e:	20 18       	sub	r8,1
80003620:	93 08       	st.w	r9[0x0],r8
80003622:	c0 71       	brne	80003630 <phy_rx_func+0x5c0>
								RxMediaState = WAITINGABAB;
80003624:	30 09       	mov	r9,0
80003626:	fe f8 06 46 	ld.w	r8,pc[1606]
8000362a:	91 09       	st.w	r8[0x0],r9
8000362c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[5];//4
80003630:	fe f8 06 5c 	ld.w	r8,pc[1628]
80003634:	fe f9 06 34 	ld.w	r9,pc[1588]
80003638:	72 0a       	ld.w	r10,r9[0x0]
8000363a:	70 09       	ld.w	r9,r8[0x0]
8000363c:	ef 3b 00 0d 	ld.ub	r11,r7[13]
80003640:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003644:	70 09       	ld.w	r9,r8[0x0]
80003646:	2f f9       	sub	r9,-1
80003648:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000364a:	e0 49 01 ff 	cp.w	r9,511
8000364e:	e0 88 00 16 	brls	8000367a <phy_rx_func+0x60a>
							{
								RxAMBE_IsFillingNext8 = 0;
80003652:	30 09       	mov	r9,0
80003654:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003656:	fe f6 06 12 	ld.w	r6,pc[1554]
8000365a:	6c 0c       	ld.w	r12,r6[0x0]
8000365c:	f0 1f 01 8e 	mcall	80003c94 <phy_rx_func+0xc24>
								AMBE_payload_ptr = get_payload_idle_isr();
80003660:	fe f8 06 04 	ld.w	r8,pc[1540]
80003664:	70 0c       	ld.w	r12,r8[0x0]
80003666:	f0 1f 01 7a 	mcall	80003c4c <phy_rx_func+0xbdc>
8000366a:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
8000366c:	c0 71       	brne	8000367a <phy_rx_func+0x60a>
								{
									RxMediaState = WAITINGABAB;
8000366e:	30 09       	mov	r9,0
80003670:	fe f8 05 fc 	ld.w	r8,pc[1532]
80003674:	91 09       	st.w	r8[0x0],r9
80003676:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
8000367a:	fe f9 05 fa 	ld.w	r9,pc[1530]
8000367e:	72 08       	ld.w	r8,r9[0x0]
80003680:	20 18       	sub	r8,1
80003682:	93 08       	st.w	r9[0x0],r8
80003684:	c0 71       	brne	80003692 <phy_rx_func+0x622>
								RxMediaState = WAITINGABAB;
80003686:	30 09       	mov	r9,0
80003688:	fe f8 05 e4 	ld.w	r8,pc[1508]
8000368c:	91 09       	st.w	r8[0x0],r9
8000368e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//5
80003692:	fe f8 05 fa 	ld.w	r8,pc[1530]
80003696:	fe f9 05 d2 	ld.w	r9,pc[1490]
8000369a:	72 0a       	ld.w	r10,r9[0x0]
8000369c:	70 09       	ld.w	r9,r8[0x0]
8000369e:	ef 3b 00 0e 	ld.ub	r11,r7[14]
800036a2:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
800036a6:	70 09       	ld.w	r9,r8[0x0]
800036a8:	2f f9       	sub	r9,-1
800036aa:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800036ac:	e0 49 01 ff 	cp.w	r9,511
800036b0:	e0 88 00 16 	brls	800036dc <phy_rx_func+0x66c>
							{
								RxAMBE_IsFillingNext8 = 0;
800036b4:	30 09       	mov	r9,0
800036b6:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800036b8:	fe f6 05 b0 	ld.w	r6,pc[1456]
800036bc:	6c 0c       	ld.w	r12,r6[0x0]
800036be:	f0 1f 01 76 	mcall	80003c94 <phy_rx_func+0xc24>
								AMBE_payload_ptr = get_payload_idle_isr();
800036c2:	fe f8 05 a2 	ld.w	r8,pc[1442]
800036c6:	70 0c       	ld.w	r12,r8[0x0]
800036c8:	f0 1f 01 61 	mcall	80003c4c <phy_rx_func+0xbdc>
800036cc:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
800036ce:	c0 71       	brne	800036dc <phy_rx_func+0x66c>
								{
									RxMediaState = WAITINGABAB;
800036d0:	30 09       	mov	r9,0
800036d2:	fe f8 05 9a 	ld.w	r8,pc[1434]
800036d6:	91 09       	st.w	r8[0x0],r9
800036d8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800036dc:	fe f9 05 98 	ld.w	r9,pc[1432]
800036e0:	72 08       	ld.w	r8,r9[0x0]
800036e2:	20 18       	sub	r8,1
800036e4:	93 08       	st.w	r9[0x0],r8
800036e6:	c0 71       	brne	800036f4 <phy_rx_func+0x684>
								RxMediaState = WAITINGABAB;
800036e8:	30 09       	mov	r9,0
800036ea:	fe f8 05 82 	ld.w	r8,pc[1410]
800036ee:	91 09       	st.w	r8[0x0],r9
800036f0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//6
800036f4:	fe f8 05 98 	ld.w	r8,pc[1432]
800036f8:	fe f9 05 70 	ld.w	r9,pc[1392]
800036fc:	72 0a       	ld.w	r10,r9[0x0]
800036fe:	70 09       	ld.w	r9,r8[0x0]
80003700:	ef 3b 00 0f 	ld.ub	r11,r7[15]
80003704:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003708:	70 09       	ld.w	r9,r8[0x0]
8000370a:	2f f9       	sub	r9,-1
8000370c:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000370e:	e0 49 01 ff 	cp.w	r9,511
80003712:	e0 88 00 16 	brls	8000373e <phy_rx_func+0x6ce>
							{
								RxAMBE_IsFillingNext8 = 0;
80003716:	30 09       	mov	r9,0
80003718:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
8000371a:	fe f7 05 4e 	ld.w	r7,pc[1358]
8000371e:	6e 0c       	ld.w	r12,r7[0x0]
80003720:	f0 1f 01 5d 	mcall	80003c94 <phy_rx_func+0xc24>
								AMBE_payload_ptr = get_payload_idle_isr();
80003724:	fe f8 05 40 	ld.w	r8,pc[1344]
80003728:	70 0c       	ld.w	r12,r8[0x0]
8000372a:	f0 1f 01 49 	mcall	80003c4c <phy_rx_func+0xbdc>
8000372e:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003730:	c0 71       	brne	8000373e <phy_rx_func+0x6ce>
								{
									RxMediaState = WAITINGABAB;
80003732:	30 09       	mov	r9,0
80003734:	fe f8 05 38 	ld.w	r8,pc[1336]
80003738:	91 09       	st.w	r8[0x0],r9
8000373a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
8000373e:	fe f9 05 36 	ld.w	r9,pc[1334]
80003742:	72 08       	ld.w	r8,r9[0x0]
80003744:	20 18       	sub	r8,1
80003746:	93 08       	st.w	r9[0x0],r8
80003748:	e0 81 02 74 	brne	80003c30 <phy_rx_func+0xbc0>
								RxMediaState = WAITINGABAB;
8000374c:	30 09       	mov	r9,0
8000374e:	fe f8 05 1e 	ld.w	r8,pc[1310]
80003752:	91 09       	st.w	r8[0x0],r9
80003754:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							//}
							
						}
						else//error
						{
							RxMediaState = WAITINGABAB;
80003758:	30 09       	mov	r9,0
8000375a:	fe f8 05 12 	ld.w	r8,pc[1298]
8000375e:	91 09       	st.w	r8[0x0],r9
80003760:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
					}
					else if (Item_ID == Post_Voice_Encoder_Data)//(bit48~Pad-bits)
80003764:	fe f8 05 20 	ld.w	r8,pc[1312]
80003768:	11 89       	ld.ub	r9,r8[0x0]
8000376a:	3f 28       	mov	r8,-14
8000376c:	f0 09 18 00 	cp.b	r9,r8
80003770:	c4 31       	brne	800037f6 <phy_rx_func+0x786>
					{
					
						AMBEBurst_rawdata[3] = payload_rx_channel->word[0];//(bit48~Pad-bits)
80003772:	8e 49       	ld.sh	r9,r7[0x8]
80003774:	fe f8 05 40 	ld.w	r8,pc[1344]
80003778:	b0 39       	st.h	r8[0x6],r9
						//AMBE_Per_Burst_Flag = 1;
						
						//根据MOTO.bit文件数据分布，建议测试pad-bits的最后一个字节不保存。
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//7
8000377a:	fe f8 05 12 	ld.w	r8,pc[1298]
8000377e:	fe f9 04 ea 	ld.w	r9,pc[1258]
80003782:	72 0a       	ld.w	r10,r9[0x0]
80003784:	70 09       	ld.w	r9,r8[0x0]
80003786:	ef 3b 00 08 	ld.ub	r11,r7[8]
8000378a:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
8000378e:	70 09       	ld.w	r9,r8[0x0]
80003790:	2f f9       	sub	r9,-1
80003792:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003794:	e0 49 01 ff 	cp.w	r9,511
80003798:	e0 88 00 16 	brls	800037c4 <phy_rx_func+0x754>
						{
							RxAMBE_IsFillingNext8 = 0;
8000379c:	30 09       	mov	r9,0
8000379e:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800037a0:	fe f7 04 c8 	ld.w	r7,pc[1224]
800037a4:	6e 0c       	ld.w	r12,r7[0x0]
800037a6:	f0 1f 01 3c 	mcall	80003c94 <phy_rx_func+0xc24>
							AMBE_payload_ptr = get_payload_idle_isr();
800037aa:	fe f8 04 ba 	ld.w	r8,pc[1210]
800037ae:	70 0c       	ld.w	r12,r8[0x0]
800037b0:	f0 1f 01 27 	mcall	80003c4c <phy_rx_func+0xbdc>
800037b4:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
800037b6:	c0 71       	brne	800037c4 <phy_rx_func+0x754>
							{
								RxMediaState = WAITINGABAB;
800037b8:	30 09       	mov	r9,0
800037ba:	fe f8 04 b2 	ld.w	r8,pc[1202]
800037be:	91 09       	st.w	r8[0x0],r9
800037c0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800037c4:	fe f9 04 b0 	ld.w	r9,pc[1200]
800037c8:	72 08       	ld.w	r8,r9[0x0]
800037ca:	20 18       	sub	r8,1
800037cc:	93 08       	st.w	r9[0x0],r8
800037ce:	c0 71       	brne	800037dc <phy_rx_func+0x76c>
							RxMediaState = WAITINGABAB;
800037d0:	30 09       	mov	r9,0
800037d2:	fe f8 04 9a 	ld.w	r8,pc[1178]
800037d6:	91 09       	st.w	r8[0x0],r9
800037d8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
						if ((RxBytesWaiting -= 1) <= 0){//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
800037dc:	20 18       	sub	r8,1
800037de:	fe f9 04 96 	ld.w	r9,pc[1174]
800037e2:	93 08       	st.w	r9[0x0],r8
800037e4:	58 08       	cp.w	r8,0
800037e6:	e0 81 02 25 	brne	80003c30 <phy_rx_func+0xbc0>
							RxMediaState = WAITINGABAB;
800037ea:	30 09       	mov	r9,0
800037ec:	fe f8 04 80 	ld.w	r8,pc[1152]
800037f0:	91 09       	st.w	r8[0x0],r9
800037f2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
								
					}
					else if (Item_ID == Pre_Voice_Decoder_Data)//bit16~bit63
800037f6:	fe f8 04 8e 	ld.w	r8,pc[1166]
800037fa:	11 89       	ld.ub	r9,r8[0x0]
800037fc:	3f 38       	mov	r8,-13
800037fe:	f0 09 18 00 	cp.b	r9,r8
80003802:	e0 81 01 0c 	brne	80003a1a <phy_rx_func+0x9aa>
					{
						//接收方的解压类型数据
						//For looping back to Radio
						AMBEBurst_rawdata[1] = payload_rx_channel->word[0];
80003806:	8e 49       	ld.sh	r9,r7[0x8]
80003808:	fe f8 04 ac 	ld.w	r8,pc[1196]
8000380c:	b0 19       	st.h	r8[0x2],r9
						AMBEBurst_rawdata[2] = payload_rx_channel->word[1];
8000380e:	8e 59       	ld.sh	r9,r7[0xa]
80003810:	b0 29       	st.h	r8[0x4],r9
						AMBEBurst_rawdata[3] = payload_rx_channel->word[2];
80003812:	8e 69       	ld.sh	r9,r7[0xc]
80003814:	b0 39       	st.h	r8[0x6],r9
						//if((m_RxBurstType == VOICEBURST_A) && (VF_SN == 1))
						//logFromISR("\n\r Pre_rx:%X\n\r", payload_rx_channel->word[2]);
						
						//To be tested. Also locally stored RAW-AMBER-DATA
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//3
80003816:	fe f8 04 76 	ld.w	r8,pc[1142]
8000381a:	fe f9 04 4e 	ld.w	r9,pc[1102]
8000381e:	72 0a       	ld.w	r10,r9[0x0]
80003820:	70 09       	ld.w	r9,r8[0x0]
80003822:	ef 3b 00 08 	ld.ub	r11,r7[8]
80003826:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
8000382a:	70 09       	ld.w	r9,r8[0x0]
8000382c:	2f f9       	sub	r9,-1
8000382e:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003830:	e0 49 01 ff 	cp.w	r9,511
80003834:	e0 88 00 16 	brls	80003860 <phy_rx_func+0x7f0>
						{
							RxAMBE_IsFillingNext8 = 0;
80003838:	30 09       	mov	r9,0
8000383a:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
8000383c:	fe f6 04 2c 	ld.w	r6,pc[1068]
80003840:	6c 0c       	ld.w	r12,r6[0x0]
80003842:	f0 1f 01 15 	mcall	80003c94 <phy_rx_func+0xc24>
							AMBE_payload_ptr = get_payload_idle_isr();
80003846:	fe f8 04 1e 	ld.w	r8,pc[1054]
8000384a:	70 0c       	ld.w	r12,r8[0x0]
8000384c:	f0 1f 01 00 	mcall	80003c4c <phy_rx_func+0xbdc>
80003850:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003852:	c0 71       	brne	80003860 <phy_rx_func+0x7f0>
							{
								RxMediaState = WAITINGABAB;
80003854:	30 09       	mov	r9,0
80003856:	fe f8 04 16 	ld.w	r8,pc[1046]
8000385a:	91 09       	st.w	r8[0x0],r9
8000385c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003860:	fe f9 04 14 	ld.w	r9,pc[1044]
80003864:	72 08       	ld.w	r8,r9[0x0]
80003866:	20 18       	sub	r8,1
80003868:	93 08       	st.w	r9[0x0],r8
8000386a:	c0 71       	brne	80003878 <phy_rx_func+0x808>
							RxMediaState = WAITINGABAB;
8000386c:	30 09       	mov	r9,0
8000386e:	fe f8 03 fe 	ld.w	r8,pc[1022]
80003872:	91 09       	st.w	r8[0x0],r9
80003874:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[1];//4
80003878:	fe f8 04 14 	ld.w	r8,pc[1044]
8000387c:	fe f9 03 ec 	ld.w	r9,pc[1004]
80003880:	72 0a       	ld.w	r10,r9[0x0]
80003882:	70 09       	ld.w	r9,r8[0x0]
80003884:	ef 3b 00 09 	ld.ub	r11,r7[9]
80003888:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
8000388c:	70 09       	ld.w	r9,r8[0x0]
8000388e:	2f f9       	sub	r9,-1
80003890:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003892:	e0 49 01 ff 	cp.w	r9,511
80003896:	e0 88 00 16 	brls	800038c2 <phy_rx_func+0x852>
						{
							RxAMBE_IsFillingNext8 = 0;
8000389a:	30 09       	mov	r9,0
8000389c:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
8000389e:	fe f6 03 ca 	ld.w	r6,pc[970]
800038a2:	6c 0c       	ld.w	r12,r6[0x0]
800038a4:	f0 1f 00 fc 	mcall	80003c94 <phy_rx_func+0xc24>
							AMBE_payload_ptr = get_payload_idle_isr();
800038a8:	fe f8 03 bc 	ld.w	r8,pc[956]
800038ac:	70 0c       	ld.w	r12,r8[0x0]
800038ae:	f0 1f 00 e8 	mcall	80003c4c <phy_rx_func+0xbdc>
800038b2:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
800038b4:	c0 71       	brne	800038c2 <phy_rx_func+0x852>
							{
								RxMediaState = WAITINGABAB;
800038b6:	30 09       	mov	r9,0
800038b8:	fe f8 03 b4 	ld.w	r8,pc[948]
800038bc:	91 09       	st.w	r8[0x0],r9
800038be:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800038c2:	fe f9 03 b2 	ld.w	r9,pc[946]
800038c6:	72 08       	ld.w	r8,r9[0x0]
800038c8:	20 18       	sub	r8,1
800038ca:	93 08       	st.w	r9[0x0],r8
800038cc:	c0 71       	brne	800038da <phy_rx_func+0x86a>
							RxMediaState = WAITINGABAB;
800038ce:	30 09       	mov	r9,0
800038d0:	fe f8 03 9c 	ld.w	r8,pc[924]
800038d4:	91 09       	st.w	r8[0x0],r9
800038d6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//5
800038da:	fe f8 03 b2 	ld.w	r8,pc[946]
800038de:	fe f9 03 8a 	ld.w	r9,pc[906]
800038e2:	72 0a       	ld.w	r10,r9[0x0]
800038e4:	70 09       	ld.w	r9,r8[0x0]
800038e6:	ef 3b 00 0a 	ld.ub	r11,r7[10]
800038ea:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800038ee:	70 09       	ld.w	r9,r8[0x0]
800038f0:	2f f9       	sub	r9,-1
800038f2:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800038f4:	e0 49 01 ff 	cp.w	r9,511
800038f8:	e0 88 00 16 	brls	80003924 <phy_rx_func+0x8b4>
						{
							RxAMBE_IsFillingNext8 = 0;
800038fc:	30 09       	mov	r9,0
800038fe:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003900:	fe f6 03 68 	ld.w	r6,pc[872]
80003904:	6c 0c       	ld.w	r12,r6[0x0]
80003906:	f0 1f 00 e4 	mcall	80003c94 <phy_rx_func+0xc24>
							AMBE_payload_ptr = get_payload_idle_isr();
8000390a:	fe f8 03 5a 	ld.w	r8,pc[858]
8000390e:	70 0c       	ld.w	r12,r8[0x0]
80003910:	f0 1f 00 cf 	mcall	80003c4c <phy_rx_func+0xbdc>
80003914:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003916:	c0 71       	brne	80003924 <phy_rx_func+0x8b4>
							{
								RxMediaState = WAITINGABAB;
80003918:	30 09       	mov	r9,0
8000391a:	fe f8 03 52 	ld.w	r8,pc[850]
8000391e:	91 09       	st.w	r8[0x0],r9
80003920:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003924:	fe f9 03 50 	ld.w	r9,pc[848]
80003928:	72 08       	ld.w	r8,r9[0x0]
8000392a:	20 18       	sub	r8,1
8000392c:	93 08       	st.w	r9[0x0],r8
8000392e:	c0 71       	brne	8000393c <phy_rx_func+0x8cc>
							RxMediaState = WAITINGABAB;
80003930:	30 09       	mov	r9,0
80003932:	fe f8 03 3a 	ld.w	r8,pc[826]
80003936:	91 09       	st.w	r8[0x0],r9
80003938:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//6
8000393c:	fe f8 03 50 	ld.w	r8,pc[848]
80003940:	fe f9 03 28 	ld.w	r9,pc[808]
80003944:	72 0a       	ld.w	r10,r9[0x0]
80003946:	70 09       	ld.w	r9,r8[0x0]
80003948:	ef 3b 00 0b 	ld.ub	r11,r7[11]
8000394c:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003950:	70 09       	ld.w	r9,r8[0x0]
80003952:	2f f9       	sub	r9,-1
80003954:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003956:	e0 49 01 ff 	cp.w	r9,511
8000395a:	e0 88 00 16 	brls	80003986 <phy_rx_func+0x916>
						{
							RxAMBE_IsFillingNext8 = 0;
8000395e:	30 09       	mov	r9,0
80003960:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003962:	fe f6 03 06 	ld.w	r6,pc[774]
80003966:	6c 0c       	ld.w	r12,r6[0x0]
80003968:	f0 1f 00 cb 	mcall	80003c94 <phy_rx_func+0xc24>
							AMBE_payload_ptr = get_payload_idle_isr();
8000396c:	fe f8 02 f8 	ld.w	r8,pc[760]
80003970:	70 0c       	ld.w	r12,r8[0x0]
80003972:	f0 1f 00 b7 	mcall	80003c4c <phy_rx_func+0xbdc>
80003976:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003978:	c0 71       	brne	80003986 <phy_rx_func+0x916>
							{
								RxMediaState = WAITINGABAB;
8000397a:	30 09       	mov	r9,0
8000397c:	fe f8 02 f0 	ld.w	r8,pc[752]
80003980:	91 09       	st.w	r8[0x0],r9
80003982:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003986:	fe f9 02 ee 	ld.w	r9,pc[750]
8000398a:	72 08       	ld.w	r8,r9[0x0]
8000398c:	20 18       	sub	r8,1
8000398e:	93 08       	st.w	r9[0x0],r8
80003990:	c0 71       	brne	8000399e <phy_rx_func+0x92e>
							RxMediaState = WAITINGABAB;
80003992:	30 09       	mov	r9,0
80003994:	fe f8 02 d8 	ld.w	r8,pc[728]
80003998:	91 09       	st.w	r8[0x0],r9
8000399a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//7
8000399e:	fe f8 02 ee 	ld.w	r8,pc[750]
800039a2:	fe f9 02 c6 	ld.w	r9,pc[710]
800039a6:	72 0a       	ld.w	r10,r9[0x0]
800039a8:	70 09       	ld.w	r9,r8[0x0]
800039aa:	ef 3b 00 0c 	ld.ub	r11,r7[12]
800039ae:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800039b2:	70 09       	ld.w	r9,r8[0x0]
800039b4:	2f f9       	sub	r9,-1
800039b6:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800039b8:	e0 49 01 ff 	cp.w	r9,511
800039bc:	e0 88 00 16 	brls	800039e8 <phy_rx_func+0x978>
						{
							RxAMBE_IsFillingNext8 = 0;
800039c0:	30 09       	mov	r9,0
800039c2:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800039c4:	fe f7 02 a4 	ld.w	r7,pc[676]
800039c8:	6e 0c       	ld.w	r12,r7[0x0]
800039ca:	f0 1f 00 b3 	mcall	80003c94 <phy_rx_func+0xc24>
							AMBE_payload_ptr = get_payload_idle_isr();
800039ce:	fe f8 02 96 	ld.w	r8,pc[662]
800039d2:	70 0c       	ld.w	r12,r8[0x0]
800039d4:	f0 1f 00 9e 	mcall	80003c4c <phy_rx_func+0xbdc>
800039d8:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
800039da:	c0 71       	brne	800039e8 <phy_rx_func+0x978>
							{
								RxMediaState = WAITINGABAB;
800039dc:	30 09       	mov	r9,0
800039de:	fe f8 02 8e 	ld.w	r8,pc[654]
800039e2:	91 09       	st.w	r8[0x0],r9
800039e4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800039e8:	fe f9 02 8c 	ld.w	r9,pc[652]
800039ec:	72 08       	ld.w	r8,r9[0x0]
800039ee:	20 18       	sub	r8,1
800039f0:	93 08       	st.w	r9[0x0],r8
800039f2:	c0 71       	brne	80003a00 <phy_rx_func+0x990>
							RxMediaState = WAITINGABAB;
800039f4:	30 09       	mov	r9,0
800039f6:	fe f8 02 76 	ld.w	r8,pc[630]
800039fa:	91 09       	st.w	r8[0x0],r9
800039fc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
						if ((RxBytesWaiting -= 1) <= 0){
80003a00:	20 18       	sub	r8,1
80003a02:	fe f9 02 72 	ld.w	r9,pc[626]
80003a06:	93 08       	st.w	r9[0x0],r8
80003a08:	58 08       	cp.w	r8,0
80003a0a:	e0 81 01 13 	brne	80003c30 <phy_rx_func+0xbc0>
							
							//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
							//or discard it to reduce payload size.
							
							RxMediaState = WAITINGABAB;
80003a0e:	30 09       	mov	r9,0
80003a10:	fe f8 02 5c 	ld.w	r8,pc[604]
80003a14:	91 09       	st.w	r8[0x0],r9
80003a16:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
					}
					else if ((Item_ID == 0x04)  ||  (Item_ID == 0x03))//Unknown type data directly back hair
80003a1a:	fe f8 02 6a 	ld.w	r8,pc[618]
80003a1e:	11 89       	ld.ub	r9,r8[0x0]
80003a20:	30 48       	mov	r8,4
80003a22:	f0 09 18 00 	cp.b	r9,r8
80003a26:	c0 80       	breq	80003a36 <phy_rx_func+0x9c6>
80003a28:	fe f8 02 5c 	ld.w	r8,pc[604]
80003a2c:	11 89       	ld.ub	r9,r8[0x0]
80003a2e:	30 38       	mov	r8,3
80003a30:	f0 09 18 00 	cp.b	r9,r8
80003a34:	c1 41       	brne	80003a5c <phy_rx_func+0x9ec>
					{
						AMBE_HT[0] = payload_rx_channel->dword[0];
80003a36:	6e 29       	ld.w	r9,r7[0x8]
80003a38:	fe f8 02 74 	ld.w	r8,pc[628]
80003a3c:	91 09       	st.w	r8[0x0],r9
						AMBE_HT[1] = payload_rx_channel->dword[1];				
80003a3e:	6e 39       	ld.w	r9,r7[0xc]
80003a40:	91 19       	st.w	r8[0x4],r9
						
						if ((RxBytesWaiting -= 8) <= 0)//Consider two cases 0xABCDC014 and 0xABCDC010
80003a42:	fe f9 02 32 	ld.w	r9,pc[562]
80003a46:	72 08       	ld.w	r8,r9[0x0]
80003a48:	20 88       	sub	r8,8
80003a4a:	93 08       	st.w	r9[0x0],r8
80003a4c:	e0 81 00 f2 	brne	80003c30 <phy_rx_func+0xbc0>
						{
					
							RxBytesWaiting = 0;
80003a50:	93 08       	st.w	r9[0x0],r8
							RxMediaState = WAITINGABAB;
80003a52:	fe f9 02 1a 	ld.w	r9,pc[538]
80003a56:	93 08       	st.w	r9[0x0],r8
80003a58:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
						}
						break;

					}
					else if (Item_ID == Soft_Decision_Value)
80003a5c:	fe f8 02 28 	ld.w	r8,pc[552]
80003a60:	11 89       	ld.ub	r9,r8[0x0]
80003a62:	31 38       	mov	r8,19
80003a64:	f0 09 18 00 	cp.b	r9,r8
80003a68:	e0 81 00 9c 	brne	80003ba0 <phy_rx_func+0xb30>
					{							
						if (SDV_Index == 12)
80003a6c:	fe f8 02 4c 	ld.w	r8,pc[588]
80003a70:	11 88       	ld.ub	r8,r8[0x0]
80003a72:	30 c9       	mov	r9,12
80003a74:	f2 08 18 00 	cp.b	r8,r9
80003a78:	e0 81 00 7b 	brne	80003b6e <phy_rx_func+0xafe>
						{
							Soft_Decision_Data[SDV_Index]= payload_rx_channel->word[0];
80003a7c:	8e 49       	ld.sh	r9,r7[0x8]
80003a7e:	fe f8 02 3e 	ld.w	r8,pc[574]
80003a82:	f1 59 00 18 	st.h	r8[24],r9
							
							SDV_Index = 0;
80003a86:	30 09       	mov	r9,0
80003a88:	fe f8 02 30 	ld.w	r8,pc[560]
80003a8c:	b0 89       	st.b	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003a8e:	ef 39 00 0d 	ld.ub	r9,r7[13]
80003a92:	3f 38       	mov	r8,-13
80003a94:	f0 09 18 00 	cp.b	r9,r8
80003a98:	c6 61       	brne	80003b64 <phy_rx_func+0xaf4>
							
							SDV_Index = 0;
								
							if (payload_rx_channel->byte[5] == Pre_Voice_Decoder_Data )//0xF3
							{
									Item_ID = Pre_Voice_Decoder_Data;
80003a9a:	10 99       	mov	r9,r8
80003a9c:	4f a8       	lddpc	r8,80003c84 <phy_rx_func+0xc14>
80003a9e:	b0 89       	st.b	r8[0x0],r9
									RxBytesWaiting = (payload_rx_channel->byte[4] & 0x7F);//Test calculations are correct; 8
80003aa0:	ef 39 00 0c 	ld.ub	r9,r7[12]
80003aa4:	f3 d9 c0 07 	bfextu	r9,r9,0x0,0x7
80003aa8:	4f 38       	lddpc	r8,80003c74 <phy_rx_func+0xc04>
80003aaa:	91 09       	st.w	r8[0x0],r9
									AMBE_rx_flag = 1;//本地作为AMBE数据的解密方
80003aac:	30 19       	mov	r9,1
80003aae:	fe f8 02 12 	ld.w	r8,pc[530]
80003ab2:	b0 89       	st.b	r8[0x0],r9
		
									AMBEBurst_rawdata[0] = payload_rx_channel->word[3];//用于解密的中间数据变量
80003ab4:	8e 79       	ld.sh	r9,r7[0xe]
80003ab6:	fe f8 01 fe 	ld.w	r8,pc[510]
80003aba:	b0 09       	st.h	r8[0x0],r9
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//1
80003abc:	4f 48       	lddpc	r8,80003c8c <phy_rx_func+0xc1c>
80003abe:	4e b9       	lddpc	r9,80003c68 <phy_rx_func+0xbf8>
80003ac0:	72 0a       	ld.w	r10,r9[0x0]
80003ac2:	70 09       	ld.w	r9,r8[0x0]
80003ac4:	ef 3b 00 0e 	ld.ub	r11,r7[14]
80003ac8:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
80003acc:	70 09       	ld.w	r9,r8[0x0]
80003ace:	2f f9       	sub	r9,-1
80003ad0:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003ad2:	e0 49 01 ff 	cp.w	r9,511
80003ad6:	e0 88 00 13 	brls	80003afc <phy_rx_func+0xa8c>
									{
										RxAMBE_IsFillingNext8 = 0;
80003ada:	30 09       	mov	r9,0
80003adc:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
80003ade:	4e 36       	lddpc	r6,80003c68 <phy_rx_func+0xbf8>
80003ae0:	6c 0c       	ld.w	r12,r6[0x0]
80003ae2:	f0 1f 00 6d 	mcall	80003c94 <phy_rx_func+0xc24>
										AMBE_payload_ptr = get_payload_idle_isr();
80003ae6:	4e 08       	lddpc	r8,80003c64 <phy_rx_func+0xbf4>
80003ae8:	70 0c       	ld.w	r12,r8[0x0]
80003aea:	f0 1f 00 59 	mcall	80003c4c <phy_rx_func+0xbdc>
80003aee:	8d 0c       	st.w	r6[0x0],r12
										if(NULL == AMBE_payload_ptr)
80003af0:	c0 61       	brne	80003afc <phy_rx_func+0xa8c>
										{
											RxMediaState = WAITINGABAB;
80003af2:	30 09       	mov	r9,0
80003af4:	4d e8       	lddpc	r8,80003c6c <phy_rx_func+0xbfc>
80003af6:	91 09       	st.w	r8[0x0],r9
80003af8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
80003afc:	4d e9       	lddpc	r9,80003c74 <phy_rx_func+0xc04>
80003afe:	72 08       	ld.w	r8,r9[0x0]
80003b00:	20 18       	sub	r8,1
80003b02:	93 08       	st.w	r9[0x0],r8
80003b04:	c0 61       	brne	80003b10 <phy_rx_func+0xaa0>
										RxMediaState = WAITINGABAB;
80003b06:	30 09       	mov	r9,0
80003b08:	4d 98       	lddpc	r8,80003c6c <phy_rx_func+0xbfc>
80003b0a:	91 09       	st.w	r8[0x0],r9
80003b0c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//2
80003b10:	4d f8       	lddpc	r8,80003c8c <phy_rx_func+0xc1c>
80003b12:	4d 69       	lddpc	r9,80003c68 <phy_rx_func+0xbf8>
80003b14:	72 0a       	ld.w	r10,r9[0x0]
80003b16:	70 09       	ld.w	r9,r8[0x0]
80003b18:	ef 3b 00 0f 	ld.ub	r11,r7[15]
80003b1c:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
80003b20:	70 09       	ld.w	r9,r8[0x0]
80003b22:	2f f9       	sub	r9,-1
80003b24:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003b26:	e0 49 01 ff 	cp.w	r9,511
80003b2a:	e0 88 00 13 	brls	80003b50 <phy_rx_func+0xae0>
									{
										RxAMBE_IsFillingNext8 = 0;
80003b2e:	30 09       	mov	r9,0
80003b30:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
80003b32:	4c e7       	lddpc	r7,80003c68 <phy_rx_func+0xbf8>
80003b34:	6e 0c       	ld.w	r12,r7[0x0]
80003b36:	f0 1f 00 58 	mcall	80003c94 <phy_rx_func+0xc24>
										AMBE_payload_ptr = get_payload_idle_isr();
80003b3a:	4c b8       	lddpc	r8,80003c64 <phy_rx_func+0xbf4>
80003b3c:	70 0c       	ld.w	r12,r8[0x0]
80003b3e:	f0 1f 00 44 	mcall	80003c4c <phy_rx_func+0xbdc>
80003b42:	8f 0c       	st.w	r7[0x0],r12
										if(NULL == AMBE_payload_ptr)
80003b44:	c0 61       	brne	80003b50 <phy_rx_func+0xae0>
										{
											RxMediaState = WAITINGABAB;
80003b46:	30 09       	mov	r9,0
80003b48:	4c 98       	lddpc	r8,80003c6c <phy_rx_func+0xbfc>
80003b4a:	91 09       	st.w	r8[0x0],r9
80003b4c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
80003b50:	4c 99       	lddpc	r9,80003c74 <phy_rx_func+0xc04>
80003b52:	72 08       	ld.w	r8,r9[0x0]
80003b54:	20 18       	sub	r8,1
80003b56:	93 08       	st.w	r9[0x0],r8
80003b58:	c6 c1       	brne	80003c30 <phy_rx_func+0xbc0>
										RxMediaState = WAITINGABAB;
80003b5a:	30 09       	mov	r9,0
80003b5c:	4c 48       	lddpc	r8,80003c6c <phy_rx_func+0xbfc>
80003b5e:	91 09       	st.w	r8[0x0],r9
80003b60:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
							}
							else
							RxMediaState = WAITINGABAB;
80003b64:	30 09       	mov	r9,0
80003b66:	4c 28       	lddpc	r8,80003c6c <phy_rx_func+0xbfc>
80003b68:	91 09       	st.w	r8[0x0],r9
80003b6a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
						}
						else
						{
									
							Soft_Decision_Data[SDV_Index]	  = payload_rx_channel->word[0];
80003b6e:	8e 4a       	ld.sh	r10,r7[0x8]
80003b70:	4d 39       	lddpc	r9,80003cbc <phy_rx_func+0xc4c>
80003b72:	f2 08 0a 1a 	st.h	r9[r8<<0x1],r10
							Soft_Decision_Data[SDV_Index+1]	  = payload_rx_channel->word[1];
80003b76:	4d 1a       	lddpc	r10,80003cb8 <phy_rx_func+0xc48>
80003b78:	15 88       	ld.ub	r8,r10[0x0]
80003b7a:	f0 cb ff ff 	sub	r11,r8,-1
80003b7e:	8e 5c       	ld.sh	r12,r7[0xa]
80003b80:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+2]	  = payload_rx_channel->word[2];
80003b84:	f0 cb ff fe 	sub	r11,r8,-2
80003b88:	8e 6c       	ld.sh	r12,r7[0xc]
80003b8a:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+3]	  = payload_rx_channel->word[3];
80003b8e:	f0 cb ff fd 	sub	r11,r8,-3
80003b92:	8e 7c       	ld.sh	r12,r7[0xe]
80003b94:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							SDV_Index +=4;
80003b98:	2f c8       	sub	r8,-4
80003b9a:	b4 88       	st.b	r10[0x0],r8
80003b9c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					
					else
					{
						
						RxMediaState  = WAITINGABAB;
80003ba0:	30 09       	mov	r9,0
80003ba2:	4b 38       	lddpc	r8,80003c6c <phy_rx_func+0xbfc>
80003ba4:	91 09       	st.w	r8[0x0],r9
80003ba6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
			break;//End of READING_AMBE_MEDIA.

        case READING_AMBE_AUX:
			
				Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[0];
80003baa:	4b f8       	lddpc	r8,80003ca4 <phy_rx_func+0xc34>
80003bac:	70 09       	ld.w	r9,r8[0x0]
80003bae:	8e 4b       	ld.sh	r11,r7[0x8]
80003bb0:	4b ea       	lddpc	r10,80003ca8 <phy_rx_func+0xc38>
80003bb2:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
				RxData_IsFillingNext16 += 1;
80003bb6:	2f f9       	sub	r9,-1
80003bb8:	91 09       	st.w	r8[0x0],r9
			
				if ((Item_Length -= 2) <= 0)
80003bba:	4b 48       	lddpc	r8,80003c88 <phy_rx_func+0xc18>
80003bbc:	70 09       	ld.w	r9,r8[0x0]
80003bbe:	20 29       	sub	r9,2
80003bc0:	91 09       	st.w	r8[0x0],r9
80003bc2:	70 08       	ld.w	r8,r8[0x0]
80003bc4:	58 08       	cp.w	r8,0
80003bc6:	c2 f1       	brne	80003c24 <phy_rx_func+0xbb4>
				{
					RxData_IsFillingNext16 = 0;
80003bc8:	30 09       	mov	r9,0
80003bca:	4b 78       	lddpc	r8,80003ca4 <phy_rx_func+0xc34>
80003bcc:	91 09       	st.w	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003bce:	8e 59       	ld.sh	r9,r7[0xa]
80003bd0:	fe 78 82 12 	mov	r8,-32238
80003bd4:	f0 09 19 00 	cp.h	r9,r8
80003bd8:	c2 11       	brne	80003c1a <phy_rx_func+0xbaa>
					{
						//Item_ID = Vocoder_Bit_Stream_Parameter;
						//Vocoder Bits Stream Parameter
						//Its value ranges from 1 to 18 for one voice superframe contains 6 voice bursts
						// and each burst contains 3 VFs.
						VF_SN = (payload_rx_channel->byte[5] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
80003bda:	ef 3c 00 0d 	ld.ub	r12,r7[13]
80003bde:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
80003be2:	4a e8       	lddpc	r8,80003c98 <phy_rx_func+0xc28>
80003be4:	b0 8c       	st.b	r8[0x0],r12
							
						VBSP_data[0] = payload_rx_channel->word[1];
80003be6:	8e 59       	ld.sh	r9,r7[0xa]
80003be8:	4a d8       	lddpc	r8,80003c9c <phy_rx_func+0xc2c>
80003bea:	b0 09       	st.h	r8[0x0],r9
						VBSP_data[1] = payload_rx_channel->word[2];
80003bec:	8e 69       	ld.sh	r9,r7[0xc]
80003bee:	b0 19       	st.h	r8[0x2],r9
							
						m_RxBurstType = CalculateBurst(VF_SN);
80003bf0:	f0 1f 00 2c 	mcall	80003ca0 <phy_rx_func+0xc30>
80003bf4:	49 f8       	lddpc	r8,80003c70 <phy_rx_func+0xc00>
80003bf6:	91 0c       	st.w	r8[0x0],r12
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003bf8:	ef 39 00 0f 	ld.ub	r9,r7[15]
80003bfc:	31 38       	mov	r8,19
80003bfe:	f0 09 18 00 	cp.b	r9,r8
80003c02:	c0 71       	brne	80003c10 <phy_rx_func+0xba0>
							
						m_RxBurstType = CalculateBurst(VF_SN);
						
						if (payload_rx_channel->byte[7] == Soft_Decision_Value)//0x13
						{
							Item_ID = Soft_Decision_Value;	
80003c04:	10 99       	mov	r9,r8
80003c06:	4a 08       	lddpc	r8,80003c84 <phy_rx_func+0xc14>
80003c08:	b0 89       	st.b	r8[0x0],r9
							RxBytesWaiting = ((payload_rx_channel->dword[1] & 0x00007F00) >>24);//Test calculations are correct; 26
80003c0a:	30 09       	mov	r9,0
80003c0c:	49 a8       	lddpc	r8,80003c74 <phy_rx_func+0xc04>
80003c0e:	91 09       	st.w	r8[0x0],r9
						else
						{//error
								RxMediaState = WAITINGABAB;//Jump
						}
							
						RxMediaState = READING_AMBE_MEDIA;//Jump
80003c10:	30 49       	mov	r9,4
80003c12:	49 78       	lddpc	r8,80003c6c <phy_rx_func+0xbfc>
80003c14:	91 09       	st.w	r8[0x0],r9
80003c16:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					else
					{
						RxMediaState = WAITINGABAB;//Jump
80003c1a:	30 09       	mov	r9,0
80003c1c:	49 48       	lddpc	r8,80003c6c <phy_rx_func+0xbfc>
80003c1e:	91 09       	st.w	r8[0x0],r9
80003c20:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}

				}
				else
				{//测试看看是几个字节数据
					logFromISR("\n\r Radio Internal parameter length error \n\r");
80003c24:	4a 8c       	lddpc	r12,80003cc4 <phy_rx_func+0xc54>
80003c26:	f0 1f 00 16 	mcall	80003c7c <phy_rx_func+0xc0c>
					RxMediaState = WAITINGABAB;//Jump
80003c2a:	30 09       	mov	r9,0
80003c2c:	49 08       	lddpc	r8,80003c6c <phy_rx_func+0xbfc>
80003c2e:	91 09       	st.w	r8[0x0],r9
80003c30:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003c34:	00 00       	add	r0,r0
80003c36:	0a b8       	st.h	r5++,r8
80003c38:	00 00       	add	r0,r0
80003c3a:	0a b0       	st.h	r5++,r0
80003c3c:	00 00       	add	r0,r0
80003c3e:	0a 84       	andn	r4,r5
80003c40:	00 00       	add	r0,r0
80003c42:	0a 60       	and	r0,r5
80003c44:	00 00       	add	r0,r0
80003c46:	0a ca       	st.b	r5++,r10
80003c48:	00 00       	add	r0,r0
80003c4a:	0a 90       	mov	r0,r5
80003c4c:	80 00       	ld.sh	r0,r0[0x0]
80003c4e:	2a 3c       	sub	r12,-93
80003c50:	00 00       	add	r0,r0
80003c52:	0a 70       	tst	r0,r5
80003c54:	80 00       	ld.sh	r0,r0[0x0]
80003c56:	50 f0       	stdsp	sp[0x3c],r0
80003c58:	00 00       	add	r0,r0
80003c5a:	0a 8c       	andn	r12,r5
80003c5c:	80 00       	ld.sh	r0,r0[0x0]
80003c5e:	29 88       	sub	r8,-104
80003c60:	00 00       	add	r0,r0
80003c62:	0a a0       	st.w	r5++,r0
80003c64:	00 00       	add	r0,r0
80003c66:	0a 6c       	and	r12,r5
80003c68:	00 00       	add	r0,r0
80003c6a:	0a a8       	st.w	r5++,r8
80003c6c:	00 00       	add	r0,r0
80003c6e:	0a 7c       	tst	r12,r5
80003c70:	00 00       	add	r0,r0
80003c72:	0a 68       	and	r8,r5
80003c74:	00 00       	add	r0,r0
80003c76:	0a 94       	mov	r4,r5
80003c78:	80 00       	ld.sh	r0,r0[0x0]
80003c7a:	c7 84       	brge	80003d6a <local_start_SSC+0x2e>
80003c7c:	80 00       	ld.sh	r0,r0[0x0]
80003c7e:	61 90       	ld.w	r0,r0[0x64]
80003c80:	00 00       	add	r0,r0
80003c82:	0a 4f       	or	pc,r5
80003c84:	00 00       	add	r0,r0
80003c86:	0a c8       	st.b	r5++,r8
80003c88:	00 00       	add	r0,r0
80003c8a:	0a 64       	and	r4,r5
80003c8c:	00 00       	add	r0,r0
80003c8e:	0a a4       	st.w	r5++,r4
80003c90:	80 00       	ld.sh	r0,r0[0x0]
80003c92:	6a a4       	ld.w	r4,r5[0x28]
80003c94:	80 00       	ld.sh	r0,r0[0x0]
80003c96:	30 10       	mov	r0,1
80003c98:	00 00       	add	r0,r0
80003c9a:	0a 40       	or	r0,r5
80003c9c:	00 00       	add	r0,r0
80003c9e:	0e 78       	tst	r8,r7
80003ca0:	80 00       	ld.sh	r0,r0[0x0]
80003ca2:	28 cc       	sub	r12,-116
80003ca4:	00 00       	add	r0,r0
80003ca6:	0a c0       	st.b	r5++,r0
80003ca8:	00 00       	add	r0,r0
80003caa:	0d 7c       	ld.ub	r12,--r6
80003cac:	00 00       	add	r0,r0
80003cae:	0a cc       	st.b	r5++,r12
80003cb0:	00 00       	add	r0,r0
80003cb2:	0a 52       	eor	r2,r5
80003cb4:	00 00       	add	r0,r0
80003cb6:	0d 74       	ld.ub	r4,--r6
80003cb8:	00 00       	add	r0,r0
80003cba:	0a 80       	andn	r0,r5
80003cbc:	00 00       	add	r0,r0
80003cbe:	0e 7c       	tst	r12,r7
80003cc0:	00 00       	add	r0,r0
80003cc2:	0a 4e       	or	lr,r5
80003cc4:	80 00       	ld.sh	r0,r0[0x0]
80003cc6:	c7 9c       	rcall	80003db8 <local_start_PDC+0x38>

80003cc8 <pdca_int_handler>:
    void (*phy_rx_exec)(void *)--callback function for receive SSC data 
Called By: interrupt
*/
__attribute__((__interrupt__))
static void pdca_int_handler(void)
{
80003cc8:	d4 01       	pushm	lr
    
	//intStartCount = Get_system_register(AVR32_COUNT);
	
	/*Toggle Index*/
    BufferIndex ^= 0x01;
80003cca:	49 88       	lddpc	r8,80003d28 <pdca_int_handler+0x60>
80003ccc:	11 89       	ld.ub	r9,r8[0x0]
80003cce:	ec 19 00 01 	eorl	r9,0x1
80003cd2:	b0 89       	st.b	r8[0x0],r9
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);
80003cd4:	11 89       	ld.ub	r9,r8[0x0]
80003cd6:	a5 69       	lsl	r9,0x4
80003cd8:	2f c9       	sub	r9,-4
80003cda:	49 5a       	lddpc	r10,80003d2c <pdca_int_handler+0x64>
80003cdc:	14 09       	add	r9,r10
	
	/*Toggle Index*/
    BufferIndex ^= 0x01;
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
80003cde:	fe 7a 00 40 	mov	r10,-65472
80003ce2:	95 39       	st.w	r10[0xc],r9
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80003ce4:	30 39       	mov	r9,3
80003ce6:	95 49       	st.w	r10[0x10],r9

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);
80003ce8:	11 8a       	ld.ub	r10,r8[0x0]
80003cea:	a5 6a       	lsl	r10,0x4
80003cec:	2f ca       	sub	r10,-4
80003cee:	49 18       	lddpc	r8,80003d30 <pdca_int_handler+0x68>
80003cf0:	10 0a       	add	r10,r8
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
80003cf2:	fe 78 00 00 	mov	r8,-65536
80003cf6:	91 3a       	st.w	r8[0xc],r10
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80003cf8:	91 49       	st.w	r8[0x10],r9
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr;
80003cfa:	70 b8       	ld.w	r8,r8[0x2c]
	
	/*receive SSC data*/
    if(phy_rx_exec != NULL)phy_rx_exec((void *)&RxBuffer[BufferIndex]);
80003cfc:	48 e8       	lddpc	r8,80003d34 <pdca_int_handler+0x6c>
80003cfe:	70 08       	ld.w	r8,r8[0x0]
80003d00:	58 08       	cp.w	r8,0
80003d02:	c0 70       	breq	80003d10 <pdca_int_handler+0x48>
80003d04:	48 99       	lddpc	r9,80003d28 <pdca_int_handler+0x60>
80003d06:	13 89       	ld.ub	r9,r9[0x0]
80003d08:	a5 69       	lsl	r9,0x4
80003d0a:	48 ac       	lddpc	r12,80003d30 <pdca_int_handler+0x68>
80003d0c:	12 0c       	add	r12,r9
80003d0e:	5d 18       	icall	r8

    /*transmit SSC data*/

	if(phy_tx_exec != NULL)phy_tx_exec((void *)&TxBuffer[BufferIndex]);//phy_tx_func, phy_rx_func
80003d10:	48 a8       	lddpc	r8,80003d38 <pdca_int_handler+0x70>
80003d12:	70 08       	ld.w	r8,r8[0x0]
80003d14:	58 08       	cp.w	r8,0
80003d16:	c0 70       	breq	80003d24 <pdca_int_handler+0x5c>
80003d18:	48 49       	lddpc	r9,80003d28 <pdca_int_handler+0x60>
80003d1a:	13 89       	ld.ub	r9,r9[0x0]
80003d1c:	a5 69       	lsl	r9,0x4
80003d1e:	48 4c       	lddpc	r12,80003d2c <pdca_int_handler+0x64>
80003d20:	12 0c       	add	r12,r9
80003d22:	5d 18       	icall	r8

	
	//intDuration = Get_system_register(AVR32_COUNT) - intStartCount;
	
	
}/*End of pdca_int_handler.*/
80003d24:	d4 02       	popm	lr
80003d26:	d6 03       	rete
80003d28:	00 00       	add	r0,r0
80003d2a:	40 9c       	lddsp	r12,sp[0x24]
80003d2c:	00 00       	add	r0,r0
80003d2e:	40 c4       	lddsp	r4,sp[0x30]
80003d30:	00 00       	add	r0,r0
80003d32:	40 a4       	lddsp	r4,sp[0x28]
80003d34:	00 00       	add	r0,r0
80003d36:	0a d4       	st.w	--r5,r4
80003d38:	00 00       	add	r0,r0
80003d3a:	0a d8       	st.w	--r5,r8

80003d3c <local_start_SSC>:
void local_start_SSC(void)
{
    /*Assign GPIO to SSC.
    gpio_enable_module
    gpio_enable_module_pin*/
    AVR32_GPIO.port[1].pmr0c = 0x00000DC0;
80003d3c:	fe 78 10 00 	mov	r8,-61440
80003d40:	e0 69 0d c0 	mov	r9,3520
80003d44:	f1 49 01 18 	st.w	r8[280],r9
    AVR32_GPIO.port[1].pmr1c = 0x00000DC0;
80003d48:	f1 49 01 28 	st.w	r8[296],r9
    AVR32_GPIO.port[1].gperc = 0x00000DC0;
80003d4c:	f1 49 01 08 	st.w	r8[264],r9

    /*Software reset SSC*/
    (&AVR32_SSC)->cr = AVR32_SSC_CR_SWRST_MASK;
80003d50:	fe 78 34 00 	mov	r8,-52224
80003d54:	e0 69 80 00 	mov	r9,32768
80003d58:	91 09       	st.w	r8[0x0],r9
    (&AVR32_SSC)->cmr 
80003d5a:	30 09       	mov	r9,0
80003d5c:	91 19       	st.w	r8[0x4],r9
                     = AVR32_SSC_CMR_DIV_NOT_ACTIVE << AVR32_SSC_CMR_DIV_OFFSET;

    /*For Slave*/
    (&AVR32_SSC)->tcmr =
80003d5e:	e0 69 04 21 	mov	r9,1057
80003d62:	ea 19 3f 20 	orh	r9,0x3f20
80003d66:	91 69       	st.w	r8[0x18],r9
	    | 32 << AVR32_SSC_TCMR_STTDLY_OFFSET
	    | 63 << AVR32_SSC_TCMR_PERIOD_OFFSET;


    /*For Slave*/
    (&AVR32_SSC)->tfmr = 31 << AVR32_SSC_TFMR_DATLEN_OFFSET 
80003d68:	e0 69 02 9f 	mov	r9,671
80003d6c:	ea 19 01 00 	orh	r9,0x100
80003d70:	91 79       	st.w	r8[0x1c],r9
	    | 0 << AVR32_SSC_TFMR_FSDEN_OFFSET
	    | 1 << AVR32_SSC_TFMR_FSEDGE_OFFSET;

	/*For Slave*/

	(&AVR32_SSC)->rcmr = AVR32_SSC_RCMR_CKS_RK_PIN << AVR32_SSC_RCMR_CKS_OFFSET
80003d72:	e0 6a 04 02 	mov	r10,1026
80003d76:	ea 1a 3f 20 	orh	r10,0x3f20
80003d7a:	91 4a       	st.w	r8[0x10],r10
	    | 0 << AVR32_SSC_RCMR_STOP_OFFSET
	    | 32 << AVR32_SSC_RCMR_STTDLY_OFFSET
	    | 63 << AVR32_SSC_RCMR_PERIOD_OFFSET;

	/*For Slave*/
	(&AVR32_SSC)->rfmr = 31 << AVR32_SSC_RFMR_DATLEN_OFFSET
80003d7c:	91 59       	st.w	r8[0x14],r9
	    | 1 << AVR32_SSC_RFMR_MSBF_OFFSET
	    | 2 << AVR32_SSC_RFMR_DATNB_OFFSET
	    | 0 << AVR32_SSC_RFMR_FSLEN_OFFSET
	    | AVR32_SSC_RFMR_FSOS_INPUT_ONLY << AVR32_SSC_RFMR_FSOS_OFFSET
	    | 1 << AVR32_SSC_RFMR_FSEDGE_OFFSET;
}/*End of local_start_SSC.*/
80003d7e:	5e fc       	retal	r12

80003d80 <local_start_PDC>:
Function: local_start_PDC
Description: none
Called By: void ssc_init(void) -- ssc.c
*/
void local_start_PDC(void)
{
80003d80:	d4 01       	pushm	lr
    /*Toggle Index*/	
    BufferIndex = 1;
80003d82:	30 19       	mov	r9,1
80003d84:	49 78       	lddpc	r8,80003de0 <local_start_PDC+0x60>
80003d86:	b0 89       	st.b	r8[0x0],r9
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
80003d88:	fe 78 00 00 	mov	r8,-65536
80003d8c:	30 7b       	mov	r11,7
80003d8e:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
80003d90:	70 b9       	ld.w	r9,r8[0x2c]
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
80003d92:	49 59       	lddpc	r9,80003de4 <local_start_PDC+0x64>
80003d94:	f2 ca ff fc 	sub	r10,r9,-4
    BufferIndex = 1;
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
80003d98:	91 0a       	st.w	r8[0x0],r10
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
80003d9a:	30 3a       	mov	r10,3
80003d9c:	91 2a       	st.w	r8[0x8],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
80003d9e:	30 1c       	mov	r12,1
80003da0:	91 1c       	st.w	r8[0x4],r12
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
80003da2:	2e c9       	sub	r9,-20
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
80003da4:	91 39       	st.w	r8[0xc],r9
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80003da6:	91 4a       	st.w	r8[0x10],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80003da8:	30 2c       	mov	r12,2
80003daa:	91 6c       	st.w	r8[0x18],r12

	TxBuffer[0].xnl_channel.dword = XNL_IDLE;
80003dac:	48 f9       	lddpc	r9,80003de8 <local_start_PDC+0x68>
80003dae:	e0 68 5a 5a 	mov	r8,23130
80003db2:	ea 18 ab cd 	orh	r8,0xabcd
80003db6:	93 18       	st.w	r9[0x4],r8
	TxBuffer[0].payload_channel.dword[0] = PAYLOADIDLE0;
80003db8:	93 28       	st.w	r9[0x8],r8
	TxBuffer[0].payload_channel.dword[1] = PAYLOADIDLE1;
80003dba:	30 0e       	mov	lr,0
80003dbc:	93 3e       	st.w	r9[0xc],lr
	TxBuffer[1].xnl_channel.dword = XNL_IDLE;
80003dbe:	93 58       	st.w	r9[0x14],r8
	TxBuffer[1].payload_channel.dword[0] = PAYLOADIDLE0;
80003dc0:	93 68       	st.w	r9[0x18],r8
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;
80003dc2:	93 7e       	st.w	r9[0x1c],lr

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
80003dc4:	fe 78 00 40 	mov	r8,-65472
80003dc8:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
80003dca:	70 be       	ld.w	lr,r8[0x2c]
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
80003dcc:	f2 ce ff fc 	sub	lr,r9,-4
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
80003dd0:	91 0e       	st.w	r8[0x0],lr
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
80003dd2:	91 2a       	st.w	r8[0x8],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
80003dd4:	91 1b       	st.w	r8[0x4],r11
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
80003dd6:	2e c9       	sub	r9,-20
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
80003dd8:	91 39       	st.w	r8[0xc],r9
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80003dda:	91 4a       	st.w	r8[0x10],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80003ddc:	91 6c       	st.w	r8[0x18],r12
}/*End of local_start_PDC.*/
80003dde:	d8 02       	popm	pc
80003de0:	00 00       	add	r0,r0
80003de2:	40 9c       	lddsp	r12,sp[0x24]
80003de4:	00 00       	add	r0,r0
80003de6:	40 a4       	lddsp	r4,sp[0x28]
80003de8:	00 00       	add	r0,r0
80003dea:	40 c4       	lddsp	r4,sp[0x30]

80003dec <register_rx_tx_func>:
Description: register the rx function(callback function)
Called By: phy_init -- physical.c
*/
void register_rx_tx_func(void (*rx_exec)(void *),  void ( *tx_exec)(void *))
{
	 phy_rx_exec = rx_exec;
80003dec:	48 38       	lddpc	r8,80003df8 <register_rx_tx_func+0xc>
80003dee:	91 0c       	st.w	r8[0x0],r12
	 phy_tx_exec = tx_exec;//phy_tx_func, phy_rx_func
80003df0:	48 38       	lddpc	r8,80003dfc <register_rx_tx_func+0x10>
80003df2:	91 0b       	st.w	r8[0x0],r11
	 
}/*End of register_tx_rx_func.*/
80003df4:	5e fc       	retal	r12
80003df6:	00 00       	add	r0,r0
80003df8:	00 00       	add	r0,r0
80003dfa:	0a d4       	st.w	--r5,r4
80003dfc:	00 00       	add	r0,r0
80003dfe:	0a d8       	st.w	--r5,r8

80003e00 <ssc_init>:
    local_start_SSC -- ssc.c
    local_start_PDC -- ssc.c
Called By: phy_init -- physical.c
*/
void ssc_init(void)
{		
80003e00:	d4 01       	pushm	lr
    /*Set up PB03 to watch FS.*/
    AVR32_GPIO.port[1].oderc = 0x00000002;
80003e02:	fe 78 10 00 	mov	r8,-61440
80003e06:	30 29       	mov	r9,2
80003e08:	f1 49 01 48 	st.w	r8[328],r9
    AVR32_GPIO.port[1].gpers = 0x00000002;
80003e0c:	f1 49 01 04 	st.w	r8[260],r9

    /*Waits for radio to start making FSYNC.*/
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
80003e10:	10 99       	mov	r9,r8
80003e12:	f2 f8 01 60 	ld.w	r8,r9[352]
80003e16:	e2 18 00 02 	andl	r8,0x2,COH
80003e1a:	cf c0       	breq	80003e12 <ssc_init+0x12>
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
80003e1c:	fe 79 10 00 	mov	r9,-61440
80003e20:	f2 f8 01 60 	ld.w	r8,r9[352]
80003e24:	e2 18 00 02 	andl	r8,0x2,COH
80003e28:	cf c1       	brne	80003e20 <ssc_init+0x20>
				
    INTC_register_interrupt (
80003e2a:	30 3a       	mov	r10,3
80003e2c:	36 0b       	mov	r11,96
80003e2e:	48 bc       	lddpc	r12,80003e58 <ssc_init+0x58>
80003e30:	f0 1f 00 0b 	mcall	80003e5c <ssc_init+0x5c>
        , AVR32_PDCA_IRQ_0
        , AVR32_INTC_INT3
    );
				
    /*config the SSC*/
    local_start_SSC();
80003e34:	f0 1f 00 0b 	mcall	80003e60 <ssc_init+0x60>

    /*config the PDCA*/
    local_start_PDC();
80003e38:	f0 1f 00 0b 	mcall	80003e64 <ssc_init+0x64>
		
    /*Start the SSC Physical Layer.*/

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80003e3c:	fe 79 00 00 	mov	r9,-65536
80003e40:	30 18       	mov	r8,1
80003e42:	93 58       	st.w	r9[0x14],r8
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80003e44:	fe 7a 00 40 	mov	r10,-65472
80003e48:	95 58       	st.w	r10[0x14],r8
    (&AVR32_SSC)->cr = AVR32_SSC_CR_RXEN_MASK | AVR32_SSC_CR_TXEN_MASK;
80003e4a:	e0 6b 01 01 	mov	r11,257
80003e4e:	fe 7a 34 00 	mov	r10,-52224
80003e52:	95 0b       	st.w	r10[0x0],r11
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->ier = 
80003e54:	93 88       	st.w	r9[0x20],r8
                                                            AVR32_PDCA_RCZ_MASK;
}/*End of ssc_init.*/
80003e56:	d8 02       	popm	pc
80003e58:	80 00       	ld.sh	r0,r0[0x0]
80003e5a:	3c c8       	mov	r8,-52
80003e5c:	80 00       	ld.sh	r0,r0[0x0]
80003e5e:	48 78       	lddpc	r8,80003e78 <xcmp_tx+0x4>
80003e60:	80 00       	ld.sh	r0,r0[0x0]
80003e62:	3d 3c       	mov	r12,-45
80003e64:	80 00       	ld.sh	r0,r0[0x0]
80003e66:	3d 80       	mov	r0,-40

80003e68 <xcmp_register_app_list>:
Calls: 
Called By: app_init -- app.c
*/
void xcmp_register_app_list(void * list)
{
	app_list = (app_exec_t *)list;
80003e68:	48 28       	lddpc	r8,80003e70 <xcmp_register_app_list+0x8>
80003e6a:	91 0c       	st.w	r8[0x0],r12
}
80003e6c:	5e fc       	retal	r12
80003e6e:	00 00       	add	r0,r0
80003e70:	00 00       	add	r0,r0
80003e72:	40 e4       	lddsp	r4,sp[0x38]

80003e74 <xcmp_tx>:
Calls:   
	xnl_tx -- xnl.c
Called By: ...
*/
static void xcmp_tx( xcmp_fragment_t * xcmp, U8 payload_len)
{
80003e74:	eb cd 40 80 	pushm	r7,lr
80003e78:	fa cd 01 00 	sub	sp,sp,256
80003e7c:	16 97       	mov	r7,r11
	Length :xnl length + checksum
	= checksum + xnl header + xcmp opcode + xcmp payload
	= 0x02 + 0x0C + 0x02 + xcmp payload
	= 0x10 + xcmp payload
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | ( 0x10 + payload_len);
80003e7e:	16 98       	mov	r8,r11
80003e80:	2f 08       	sub	r8,-16
80003e82:	af a8       	sbr	r8,0xe
80003e84:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE; 
80003e86:	3f f8       	mov	r8,-1
80003e88:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG;
80003e8a:	30 b9       	mov	r9,11
80003e8c:	ba 29       	st.h	sp[0x4],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;	
80003e8e:	ba 38       	st.h	sp[0x6],r8
	xnl_frame.xnl_header.destination = DEFAULT_VALUE;
80003e90:	ba 48       	st.h	sp[0x8],r8
	xnl_frame.xnl_header.source = DEFAULT_VALUE;	
80003e92:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80003e94:	ba 68       	st.h	sp[0xc],r8
	
	/*insert xcmp frame data*/
	memcpy(&xnl_frame.xnl_payload.xnl_content_data_msg, xcmp, payload_len + 2);
80003e96:	f6 ca ff fe 	sub	r10,r11,-2
80003e9a:	18 9b       	mov	r11,r12
80003e9c:	fa cc ff f0 	sub	r12,sp,-16
80003ea0:	f0 1f 00 05 	mcall	80003eb4 <xcmp_tx+0x40>
	xnl_frame.xnl_header.payload_length = payload_len + 2;	
80003ea4:	2f e7       	sub	r7,-2
80003ea6:	ba 77       	st.h	sp[0xe],r7
	
	/* send xnl frame*/	
	xnl_tx(&xnl_frame);
80003ea8:	1a 9c       	mov	r12,sp
80003eaa:	f0 1f 00 04 	mcall	80003eb8 <xcmp_tx+0x44>
}
80003eae:	2c 0d       	sub	sp,-256
80003eb0:	e3 cd 80 80 	ldm	sp++,r7,pc
80003eb4:	80 00       	ld.sh	r0,r0[0x0]
80003eb6:	69 5c       	ld.w	r12,r4[0x54]
80003eb8:	80 00       	ld.sh	r0,r0[0x0]
80003eba:	43 74       	lddsp	r4,sp[0xdc]

80003ebc <xcmp_enter_device_control_mode>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_enter_device_control_mode(void)
{
80003ebc:	d4 01       	pushm	lr
80003ebe:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DEVICE_CONTROL_MODE;
80003ec2:	e0 68 04 21 	mov	r8,1057
80003ec6:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceControlMode_req_t * ptr = (DeviceControlMode_req_t *)xcmp_farme.u8;
80003ec8:	fa c8 ff fc 	sub	r8,sp,-4
	
	ptr->Function = DCM_ENTER;
80003ecc:	30 19       	mov	r9,1
80003ece:	b0 89       	st.b	r8[0x0],r9
	ptr->ControlTypeSize = 1;
80003ed0:	b0 99       	st.b	r8[0x1],r9
	ptr->ControlType = 0x03;// 0xEB;//user-input
80003ed2:	30 39       	mov	r9,3
80003ed4:	b0 a9       	st.b	r8[0x2],r9
	//ptr->ControlType = DCM_SPEAKER_CTRL;
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(DeviceControlMode_req_t));
80003ed6:	30 3b       	mov	r11,3
80003ed8:	fa cc ff fe 	sub	r12,sp,-2
80003edc:	f0 1f 00 02 	mcall	80003ee4 <xcmp_enter_device_control_mode+0x28>
}
80003ee0:	2c dd       	sub	sp,-204
80003ee2:	d8 02       	popm	pc
80003ee4:	80 00       	ld.sh	r0,r0[0x0]
80003ee6:	3e 74       	mov	r4,-25

80003ee8 <xcmp_audio_route_AMBE>:
	xcmp_tx( &xcmp_farme, sizeof(AudioRoutingControl_req_t) - (MAX_ROUTING_CTR - NumberofRoutings) * sizeof(RoutingData_t));
}


void xcmp_audio_route_AMBE(void)
{
80003ee8:	d4 01       	pushm	lr
80003eea:	fa cd 00 cc 	sub	sp,sp,204

	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | AUDIO_ROUTING_CONTROL;
80003eee:	e0 68 04 14 	mov	r8,1044
80003ef2:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	AudioRoutingControl_req_t * ptr = (AudioRoutingControl_req_t *)xcmp_farme.u8;
80003ef4:	fa c8 ff fc 	sub	r8,sp,-4
	
	ptr->Function = Routing_Func_Update_Source;
80003ef8:	30 19       	mov	r9,1
80003efa:	b0 89       	st.b	r8[0x0],r9
	
	
	unsigned short NumberofRoutings = 6;// 4;//2;
	ptr->NumberofRoutings[0] = (NumberofRoutings >> 8) & 0xFF;
80003efc:	30 09       	mov	r9,0
80003efe:	b0 99       	st.b	r8[0x1],r9
	ptr->NumberofRoutings[1] =  NumberofRoutings & 0xFF;
80003f00:	30 69       	mov	r9,6
80003f02:	b0 a9       	st.b	r8[0x2],r9
	
	//ptr->RoutingData[0].audioInput = IN_Microphone;//Post_AMBE_Encoder;//IN_Pre_Speaker_Audio_Data;//IN_Microphone;//IN_Option_Board;
	//ptr->RoutingData[0].audioOutput = OUT_Option_Board;//Post_AMBE_Encoder;//OUT_Microphone_Data;//测试
	//注意：经测试发现，这里的路径配置，需要特别注意先后顺序，否则会提示参数错误。
	ptr->RoutingData[0].audioInput = Post_AMBE_Encoder;//IN_Option_Board;
80003f04:	30 fa       	mov	r10,15
80003f06:	b0 ba       	st.b	r8[0x3],r10
	ptr->RoutingData[0].audioOutput = OUT_Option_Board;// OUT_Speaker;
80003f08:	30 c9       	mov	r9,12
80003f0a:	b0 c9       	st.b	r8[0x4],r9
	ptr->RoutingData[1].audioInput = IN_Option_Board;//IN_Option_Board;
80003f0c:	b0 d9       	st.b	r8[0x5],r9
	ptr->RoutingData[1].audioOutput = Post_AMBE_Encoder;// OUT_Speaker;
80003f0e:	b0 ea       	st.b	r8[0x6],r10
	
	ptr->RoutingData[2].audioInput = Pre_AMBE_Decoder;//IN_Option_Board;
80003f10:	31 0a       	mov	r10,16
80003f12:	b0 fa       	st.b	r8[0x7],r10
	ptr->RoutingData[2].audioOutput = OUT_Option_Board;// OUT_Speaker;
80003f14:	f1 69 00 08 	st.b	r8[8],r9
	ptr->RoutingData[3].audioInput = IN_Option_Board;//IN_Option_Board;
80003f18:	f1 69 00 09 	st.b	r8[9],r9
	ptr->RoutingData[3].audioOutput = Pre_AMBE_Decoder;// OUT_Speaker;
80003f1c:	f1 6a 00 0a 	st.b	r8[10],r10
	
	ptr->RoutingData[4].audioInput = Tx_Voice_Header;//IN_Option_Board;
80003f20:	31 1a       	mov	r10,17
80003f22:	f1 6a 00 0b 	st.b	r8[11],r10
	ptr->RoutingData[4].audioOutput = OUT_Option_Board;// OUT_Speaker;
80003f26:	f1 69 00 0c 	st.b	r8[12],r9
	//ptr->RoutingData[3].audioInput = IN_Option_Board;//IN_Option_Board;
	//ptr->RoutingData[3].audioOutput = Tx_Voice_Header;// OUT_Speaker;
	
	ptr->RoutingData[5].audioInput = Tx_Voice_Terminator;//IN_Option_Board;
80003f2a:	31 3a       	mov	r10,19
80003f2c:	f1 6a 00 0d 	st.b	r8[13],r10
	ptr->RoutingData[5].audioOutput = OUT_Option_Board;// OUT_Speaker;
80003f30:	f1 69 00 0e 	st.b	r8[14],r9
	
	//ptr->RoutingData[1].audioInput = IN_Option_Board;
	//ptr->RoutingData[1].audioOutput = OUT_Microphone_Data;//测试OUT_Speaker;//
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(AudioRoutingControl_req_t) - (MAX_ROUTING_CTR - NumberofRoutings) * sizeof(RoutingData_t));
80003f34:	30 fb       	mov	r11,15
80003f36:	fa cc ff fe 	sub	r12,sp,-2
80003f3a:	f0 1f 00 03 	mcall	80003f44 <xcmp_audio_route_AMBE+0x5c>

	
}
80003f3e:	2c dd       	sub	sp,-204
80003f40:	d8 02       	popm	pc
80003f42:	00 00       	add	r0,r0
80003f44:	80 00       	ld.sh	r0,r0[0x0]
80003f46:	3e 74       	mov	r4,-25

80003f48 <xcmp_enter_enhanced_OB_mode>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_enter_enhanced_OB_mode(void)
{
80003f48:	d4 01       	pushm	lr
80003f4a:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | EN_OB_CONTROL;
80003f4e:	e0 68 04 65 	mov	r8,1125
80003f52:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	En_OB_Control_req_t * ptr = (En_OB_Control_req_t *)xcmp_farme.u8;
	
	ptr->Function = EN_OB_Enter;
80003f54:	fa cc ff fe 	sub	r12,sp,-2
80003f58:	30 18       	mov	r8,1
80003f5a:	b8 a8       	st.b	r12[0x2],r8
		
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(En_OB_Control_req_t));
80003f5c:	30 1b       	mov	r11,1
80003f5e:	f0 1f 00 03 	mcall	80003f68 <xcmp_enter_enhanced_OB_mode+0x20>
}
80003f62:	2c dd       	sub	sp,-204
80003f64:	d8 02       	popm	pc
80003f66:	00 00       	add	r0,r0
80003f68:	80 00       	ld.sh	r0,r0[0x0]
80003f6a:	3e 74       	mov	r4,-25

80003f6c <xcmp_DeviceInitializationStatus_request>:
Description: send device initialization status request
Calls: xcmp_tx
Called By:...
*/
void xcmp_DeviceInitializationStatus_request(void)
{
80003f6c:	d4 01       	pushm	lr
80003f6e:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
		
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_BRDCAST | DEVICE_INITIALIZATION_STATUS;
80003f72:	fe 78 b4 00 	mov	r8,-19456
80003f76:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceInitializationStatus_brdcst_t * ptr 
						 = (DeviceInitializationStatus_brdcst_t *)xcmp_farme.u8;
80003f78:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*xcmp version 8.1.0.5*///版本号未正确填写，纠正
	ptr->XCMPVersion[0] = 0x08;
80003f7c:	30 89       	mov	r9,8
80003f7e:	b0 89       	st.b	r8[0x0],r9
	ptr->XCMPVersion[1] = 0x01;
80003f80:	30 19       	mov	r9,1
80003f82:	b0 99       	st.b	r8[0x1],r9
	ptr->XCMPVersion[2] = 0x00;
80003f84:	30 09       	mov	r9,0
80003f86:	b0 a9       	st.b	r8[0x2],r9
	ptr->XCMPVersion[3] = 0x05;
80003f88:	30 5a       	mov	r10,5
80003f8a:	b0 ba       	st.b	r8[0x3],r10
	/*
	0x00:
	This is the message that the device sends at power up or after a reset. It 
	will give the initial status and capabilities for the device.
	*/
	ptr->DeviceInitType = 0x00;
80003f8c:	b0 c9       	st.b	r8[0x4],r9
	types of devices may provide a set of services to the radio system, but do 
	not have the ability to be the master.
	
	0x07:OptionBoard,3rd party Option Board-based application.
	*/
	ptr->DeviceStatusInfo.DeviceType = 0x07;
80003f8e:	30 7a       	mov	r10,7
80003f90:	b0 da       	st.b	r8[0x5],r10
	
	/*Power Up Success, Device has powered up with no errors*/
	ptr->DeviceStatusInfo.DeviceStatus[0] = 0x00;
80003f92:	b0 e9       	st.b	r8[0x6],r9
	ptr->DeviceStatusInfo.DeviceStatus[1] = 0x00;
80003f94:	b0 f9       	st.b	r8[0x7],r9
	
	/*
	This number is the size of the Device Descriptor data structure with a 
	maximum size not exceeding 255 bytes.
	*/
	ptr->DeviceStatusInfo.DeviceDescriptorSize = 0x00;
80003f96:	f1 69 00 08 	st.b	r8[8],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme
80003f9a:	30 9b       	mov	r11,9
80003f9c:	fa cc ff fe 	sub	r12,sp,-2
80003fa0:	f0 1f 00 02 	mcall	80003fa8 <xcmp_DeviceInitializationStatus_request+0x3c>
		, sizeof(DeviceInitializationStatus_brdcst_t) - MAX_DEVICE_DESC_SIZE);
}
80003fa4:	2c dd       	sub	sp,-204
80003fa6:	d8 02       	popm	pc
80003fa8:	80 00       	ld.sh	r0,r0[0x0]
80003faa:	3e 74       	mov	r4,-25

80003fac <xcmp_opcode_not_supported>:
Description: register the app list
Calls: xcmp_tx
Called By:...
*/
void xcmp_opcode_not_supported( void )
{
80003fac:	d4 01       	pushm	lr
80003fae:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REPLY;
80003fb2:	fe 78 80 00 	mov	r8,-32768
80003fb6:	ba 18       	st.h	sp[0x2],r8
	
	/*The radio does not support this opcode.*/
	xcmp_farme.u8[0] = xcmp_Res_Opcode_Not_Supported;
80003fb8:	30 38       	mov	r8,3
80003fba:	ba c8       	st.b	sp[0x4],r8
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, 1);
80003fbc:	30 1b       	mov	r11,1
80003fbe:	fa cc ff fe 	sub	r12,sp,-2
80003fc2:	f0 1f 00 03 	mcall	80003fcc <xcmp_opcode_not_supported+0x20>
}
80003fc6:	2c dd       	sub	sp,-204
80003fc8:	d8 02       	popm	pc
80003fca:	00 00       	add	r0,r0
80003fcc:	80 00       	ld.sh	r0,r0[0x0]
80003fce:	3e 74       	mov	r4,-25

80003fd0 <xcmp_exec_func>:
Description: Perform XCMP corresponding functions
Calls:   
Called By: xcmp_rx_process--task
*/
static void xcmp_exec_func(app_exec_t * exec, xcmp_fragment_t * xcmp)
{
80003fd0:	d4 01       	pushm	lr
	/*The message types*/
	switch(xcmp->xcmp_opcode & 0xF000)
80003fd2:	96 88       	ld.uh	r8,r11[0x0]
80003fd4:	e2 18 f0 00 	andl	r8,0xf000,COH
80003fd8:	e0 48 80 00 	cp.w	r8,32768
80003fdc:	c0 f0       	breq	80003ffa <xcmp_exec_func+0x2a>
80003fde:	e0 48 b0 00 	cp.w	r8,45056
80003fe2:	c1 20       	breq	80004006 <xcmp_exec_func+0x36>
80003fe4:	58 08       	cp.w	r8,0
80003fe6:	c1 51       	brne	80004010 <xcmp_exec_func+0x40>
	{
		case XCMP_REQUEST:
			if(NULL != exec->xcmp_rx_req)
80003fe8:	78 08       	ld.w	r8,r12[0x0]
80003fea:	58 08       	cp.w	r8,0
80003fec:	c0 40       	breq	80003ff4 <xcmp_exec_func+0x24>
			{
				exec->xcmp_rx_req(xcmp);
80003fee:	16 9c       	mov	r12,r11
80003ff0:	5d 18       	icall	r8
80003ff2:	d8 02       	popm	pc
			}
			else 
			{
				/*No function to register the request message*/
				/*send not supported opcode to raido */
				xcmp_opcode_not_supported();
80003ff4:	f0 1f 00 08 	mcall	80004014 <xcmp_exec_func+0x44>
80003ff8:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_REPLY:		
			if(NULL != exec->xcmp_rx_reply)
80003ffa:	78 18       	ld.w	r8,r12[0x4]
80003ffc:	58 08       	cp.w	r8,0
80003ffe:	c0 90       	breq	80004010 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_reply(xcmp);
80004000:	16 9c       	mov	r12,r11
80004002:	5d 18       	icall	r8
80004004:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_BRDCAST:	
			if(NULL != exec->xcmp_rx_brdcst)
80004006:	78 28       	ld.w	r8,r12[0x8]
80004008:	58 08       	cp.w	r8,0
8000400a:	c0 30       	breq	80004010 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_brdcst(xcmp);
8000400c:	16 9c       	mov	r12,r11
8000400e:	5d 18       	icall	r8
80004010:	d8 02       	popm	pc
80004012:	00 00       	add	r0,r0
80004014:	80 00       	ld.sh	r0,r0[0x0]
80004016:	3f ac       	mov	r12,-6

80004018 <xcmp_IdleTestTone>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_IdleTestTone(void)
{
80004018:	d4 01       	pushm	lr
8000401a:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | TONE_CONTROL;
8000401e:	e0 68 04 09 	mov	r8,1033
80004022:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	ToneControl_req_t * ptr = (ToneControl_req_t *)xcmp_farme.u8;
80004024:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*Starts the specific tone*/	
	ptr->Function = Tone_Start;
80004028:	30 19       	mov	r9,1
8000402a:	b0 89       	st.b	r8[0x0],r9
	
	/*This tone shall be sounded when radio landed on a priority channel*/
	ptr->ToneIdentifier[0] = (Priority_Beep >> 8) & 0xFF;
8000402c:	30 09       	mov	r9,0
8000402e:	b0 99       	st.b	r8[0x1],r9
	ptr->ToneIdentifier[1] = Priority_Beep & 0xFF;
80004030:	30 ca       	mov	r10,12
80004032:	b0 aa       	st.b	r8[0x2],r10
	
	/*
	The alert tone is played according to any rules for alert tones, given the 
	current volume setting. Settings for this field are 8 to 255 (0x08 ?0xFF).
	*/
	ptr->ToneVolumeControl = Current_Volume;
80004034:	b0 b9       	st.b	r8[0x3],r9
	
	/*clear reserved*/
	memset(ptr->Reserved, 0, 8);
80004036:	fb 69 00 08 	st.b	sp[8],r9
8000403a:	fa c8 ff f7 	sub	r8,sp,-9
8000403e:	b0 89       	st.b	r8[0x0],r9
80004040:	fa c8 ff f6 	sub	r8,sp,-10
80004044:	b0 89       	st.b	r8[0x0],r9
80004046:	fa c8 ff f5 	sub	r8,sp,-11
8000404a:	b0 89       	st.b	r8[0x0],r9
8000404c:	fa c8 ff f4 	sub	r8,sp,-12
80004050:	b0 89       	st.b	r8[0x0],r9
80004052:	fa c8 ff f3 	sub	r8,sp,-13
80004056:	b0 89       	st.b	r8[0x0],r9
80004058:	fa c8 ff f2 	sub	r8,sp,-14
8000405c:	b0 89       	st.b	r8[0x0],r9
8000405e:	fa c8 ff f1 	sub	r8,sp,-15
80004062:	b0 89       	st.b	r8[0x0],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(ToneControl_req_t));
80004064:	30 cb       	mov	r11,12
80004066:	fa cc ff fe 	sub	r12,sp,-2
8000406a:	f0 1f 00 03 	mcall	80004074 <xcmp_IdleTestTone+0x5c>
}
8000406e:	2c dd       	sub	sp,-204
80004070:	d8 02       	popm	pc
80004072:	00 00       	add	r0,r0
80004074:	80 00       	ld.sh	r0,r0[0x0]
80004076:	3e 74       	mov	r4,-25

80004078 <xcmp_init>:
	xQueueCreate -- freertos
	xTaskCreate -- freertos
Called By: main -- main.c
*/
void xcmp_init(void)
{
80004078:	d4 01       	pushm	lr
	/*register the xcmp function(callback function)*/
	xnl_register_xcmp_func( xcmp_rx );
8000407a:	48 dc       	lddpc	r12,800040ac <xcmp_init+0x34>
8000407c:	f0 1f 00 0d 	mcall	800040b0 <xcmp_init+0x38>
	
	/*initialize the queue*/
	//xcmp_frame_rx = xQueueCreate(10, sizeof(xcmp_fragment_t *));
	
	xcmp_frame_rx = xQueueCreate(20, sizeof(xcmp_fragment_t *));
80004080:	30 4b       	mov	r11,4
80004082:	31 4c       	mov	r12,20
80004084:	f0 1f 00 0c 	mcall	800040b4 <xcmp_init+0x3c>
80004088:	48 c8       	lddpc	r8,800040b8 <xcmp_init+0x40>
8000408a:	91 0c       	st.w	r8[0x0],r12
	/*create task*/	
	/*this task is used to execute xcmp message*/
	xTaskCreate(
8000408c:	30 09       	mov	r9,0
8000408e:	1a d9       	st.w	--sp,r9
80004090:	1a d9       	st.w	--sp,r9
80004092:	1a d9       	st.w	--sp,r9
80004094:	30 38       	mov	r8,3
80004096:	e0 6a 01 80 	mov	r10,384
8000409a:	48 9b       	lddpc	r11,800040bc <xcmp_init+0x44>
8000409c:	48 9c       	lddpc	r12,800040c0 <xcmp_init+0x48>
8000409e:	f0 1f 00 0a 	mcall	800040c4 <xcmp_init+0x4c>
	,  tskXCMP_PRIORITY
	,  NULL
	);
	
	/*initialize the xnl*/
	xnl_init();
800040a2:	f0 1f 00 0a 	mcall	800040c8 <xcmp_init+0x50>
800040a6:	2f dd       	sub	sp,-12
	
}
800040a8:	d8 02       	popm	pc
800040aa:	00 00       	add	r0,r0
800040ac:	80 00       	ld.sh	r0,r0[0x0]
800040ae:	41 c8       	lddsp	r8,sp[0x70]
800040b0:	80 00       	ld.sh	r0,r0[0x0]
800040b2:	42 14       	lddsp	r4,sp[0x84]
800040b4:	80 00       	ld.sh	r0,r0[0x0]
800040b6:	55 6c       	stdsp	sp[0x158],r12
800040b8:	00 00       	add	r0,r0
800040ba:	0a e8       	st.h	--r5,r8
800040bc:	80 00       	ld.sh	r0,r0[0x0]
800040be:	c7 c8       	rjmp	800041b6 <xcmp_rx_process+0xea>
800040c0:	80 00       	ld.sh	r0,r0[0x0]
800040c2:	40 cc       	lddsp	r12,sp[0x30]
800040c4:	80 00       	ld.sh	r0,r0[0x0]
800040c6:	5c 40       	abs	r0
800040c8:	80 00       	ld.sh	r0,r0[0x0]
800040ca:	44 58       	lddsp	r8,sp[0x114]

800040cc <xcmp_rx_process>:
Calls: xQueueReceive -- freerots
	xcmp_exec_func
Called By: task
*/
static void xcmp_rx_process(void * pvParameters)
{
800040cc:	d4 31       	pushm	r0-r7,lr
800040ce:	20 1d       	sub	sp,4
	xcmp_fragment_t xcmp;
	xcmp_fragment_t * ptr;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
800040d0:	4b 16       	lddpc	r6,80004194 <xcmp_rx_process+0xc8>
800040d2:	30 05       	mov	r5,0
800040d4:	31 44       	mov	r4,20
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
800040d6:	4b 13       	lddpc	r3,80004198 <xcmp_rx_process+0xcc>
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
					break;
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
800040d8:	4b 12       	lddpc	r2,8000419c <xcmp_rx_process+0xd0>
						, ptr);
					break;
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
800040da:	4b 21       	lddpc	r1,800041a0 <xcmp_rx_process+0xd4>
					break;
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
800040dc:	4b 20       	lddpc	r0,800041a4 <xcmp_rx_process+0xd8>
	xcmp_fragment_t xcmp;
	xcmp_fragment_t * ptr;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
800040de:	6c 0c       	ld.w	r12,r6[0x0]
800040e0:	0a 99       	mov	r9,r5
800040e2:	08 9a       	mov	r10,r4
800040e4:	1a 9b       	mov	r11,sp
800040e6:	f0 1f 00 31 	mcall	800041a8 <xcmp_rx_process+0xdc>
800040ea:	58 1c       	cp.w	r12,1
800040ec:	cf 91       	brne	800040de <xcmp_rx_process+0x12>
		{									
			if(NULL == ptr)
800040ee:	40 0b       	lddsp	r11,sp[0x0]
800040f0:	58 0b       	cp.w	r11,0
800040f2:	cf 60       	breq	800040de <xcmp_rx_process+0x12>
				continue;
			}
			
			//log("\n\r R_xcmp : %4x \n\r",ptr->xcmp_opcode);//log:R_xcmp指令	
						
			switch(ptr->xcmp_opcode & 0x0FFF)
800040f4:	96 0a       	ld.sh	r10,r11[0x0]
800040f6:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
800040fa:	f1 d9 c0 0c 	bfextu	r8,r9,0x0,0xc
800040fe:	59 c8       	cp.w	r8,28
80004100:	c1 e0       	breq	8000413c <xcmp_rx_process+0x70>
80004102:	e0 89 00 07 	brgt	80004110 <xcmp_rx_process+0x44>
80004106:	58 e8       	cp.w	r8,14
80004108:	c0 e0       	breq	80004124 <xcmp_rx_process+0x58>
8000410a:	58 f8       	cp.w	r8,15
8000410c:	c2 41       	brne	80004154 <xcmp_rx_process+0x88>
8000410e:	c0 f8       	rjmp	8000412c <xcmp_rx_process+0x60>
80004110:	e0 48 01 09 	cp.w	r8,265
80004114:	c1 80       	breq	80004144 <xcmp_rx_process+0x78>
80004116:	e0 48 01 0a 	cp.w	r8,266
8000411a:	c1 90       	breq	8000414c <xcmp_rx_process+0x80>
8000411c:	e0 48 00 2c 	cp.w	r8,44
80004120:	c1 a1       	brne	80004154 <xcmp_rx_process+0x88>
80004122:	c0 98       	rjmp	80004134 <xcmp_rx_process+0x68>
			{
				case RADIO_STATUS:				
					xcmp_exec_func(&radio_status, ptr);
80004124:	4a 2c       	lddpc	r12,800041ac <xcmp_rx_process+0xe0>
80004126:	f0 1f 00 23 	mcall	800041b0 <xcmp_rx_process+0xe4>
					break;
8000412a:	c2 f8       	rjmp	80004188 <xcmp_rx_process+0xbc>
					
				case VERSION_INFORMATION:
					xcmp_exec_func(&version_information, ptr);
8000412c:	4a 2c       	lddpc	r12,800041b4 <xcmp_rx_process+0xe8>
8000412e:	f0 1f 00 21 	mcall	800041b0 <xcmp_rx_process+0xe4>
					break;
80004132:	c2 b8       	rjmp	80004188 <xcmp_rx_process+0xbc>
					
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
80004134:	4a 1c       	lddpc	r12,800041b8 <xcmp_rx_process+0xec>
80004136:	f0 1f 00 1f 	mcall	800041b0 <xcmp_rx_process+0xe4>
					break;
8000413a:	c2 78       	rjmp	80004188 <xcmp_rx_process+0xbc>
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
8000413c:	04 9c       	mov	r12,r2
8000413e:	f0 1f 00 1d 	mcall	800041b0 <xcmp_rx_process+0xe4>
						, ptr);
					break;
80004142:	c2 38       	rjmp	80004188 <xcmp_rx_process+0xbc>
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
80004144:	02 9c       	mov	r12,r1
80004146:	f0 1f 00 1b 	mcall	800041b0 <xcmp_rx_process+0xe4>
					break;
8000414a:	c1 f8       	rjmp	80004188 <xcmp_rx_process+0xbc>
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
8000414c:	00 9c       	mov	r12,r0
8000414e:	f0 1f 00 19 	mcall	800041b0 <xcmp_rx_process+0xe4>
					break;
80004152:	c1 b8       	rjmp	80004188 <xcmp_rx_process+0xbc>
					
				default:
				
					/*the xcmp message not in order list*/
					/*over the length of the list*/
					if((0x0400 != (ptr->xcmp_opcode & 0x0400)) 
80004154:	12 98       	mov	r8,r9
80004156:	e2 18 04 00 	andl	r8,0x400,COH
8000415a:	c0 70       	breq	80004168 <xcmp_rx_process+0x9c>
8000415c:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
80004160:	e0 48 00 68 	cp.w	r8,104
80004164:	e0 8a 00 08 	brle	80004174 <xcmp_rx_process+0xa8>
						|| (MAX_APP_FUNC <= (ptr->xcmp_opcode & 0x00FF))
					)
					{
						/*xcmp request*/
						if( XCMP_REQUEST == (ptr->xcmp_opcode & 0xF000))
80004168:	e2 19 f0 00 	andl	r9,0xf000,COH
8000416c:	c0 e1       	brne	80004188 <xcmp_rx_process+0xbc>
						{
							/*send not supported opcode to raido */
							xcmp_opcode_not_supported();
8000416e:	f0 1f 00 14 	mcall	800041bc <xcmp_rx_process+0xf0>
80004172:	c0 b8       	rjmp	80004188 <xcmp_rx_process+0xbc>
						}
					}
					else
					{					
						xcmp_exec_func( &app_list[ptr->xcmp_opcode & 0x00FF]
80004174:	f9 da c0 08 	bfextu	r12,r10,0x0,0x8
80004178:	f8 0c 00 1c 	add	r12,r12,r12<<0x1
8000417c:	49 19       	lddpc	r9,800041c0 <xcmp_rx_process+0xf4>
8000417e:	72 08       	ld.w	r8,r9[0x0]
80004180:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80004184:	f0 1f 00 0b 	mcall	800041b0 <xcmp_rx_process+0xe4>
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
80004188:	66 0c       	ld.w	r12,r3[0x0]
8000418a:	40 0b       	lddsp	r11,sp[0x0]
8000418c:	f0 1f 00 0e 	mcall	800041c4 <xcmp_rx_process+0xf8>
80004190:	ca 7b       	rjmp	800040de <xcmp_rx_process+0x12>
80004192:	00 00       	add	r0,r0
80004194:	00 00       	add	r0,r0
80004196:	0a e8       	st.h	--r5,r8
80004198:	00 00       	add	r0,r0
8000419a:	0a 90       	mov	r0,r5
8000419c:	00 00       	add	r0,r0
8000419e:	0a f8       	st.b	--r5,r8
800041a0:	00 00       	add	r0,r0
800041a2:	0a ec       	st.h	--r5,r12
800041a4:	00 00       	add	r0,r0
800041a6:	0b 04       	ld.w	r4,r5++
800041a8:	80 00       	ld.sh	r0,r0[0x0]
800041aa:	52 60       	stdsp	sp[0x98],r0
800041ac:	00 00       	add	r0,r0
800041ae:	0b 1c       	ld.sh	r12,r5++
800041b0:	80 00       	ld.sh	r0,r0[0x0]
800041b2:	3f d0       	mov	r0,-3
800041b4:	00 00       	add	r0,r0
800041b6:	0a dc       	st.w	--r5,r12
800041b8:	00 00       	add	r0,r0
800041ba:	0b 10       	ld.sh	r0,r5++
800041bc:	80 00       	ld.sh	r0,r0[0x0]
800041be:	3f ac       	mov	r12,-6
800041c0:	00 00       	add	r0,r0
800041c2:	40 e4       	lddsp	r4,sp[0x38]
800041c4:	80 00       	ld.sh	r0,r0[0x0]
800041c6:	29 c0       	sub	r0,-100

800041c8 <xcmp_rx>:
Calls:   
	xQueueSend -- xnl.c
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
800041c8:	eb cd 40 90 	pushm	r4,r7,lr
800041cc:	20 1d       	sub	sp,4
800041ce:	fa c4 ff f0 	sub	r4,sp,-16
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
800041d2:	48 c8       	lddpc	r8,80004200 <xcmp_rx+0x38>
800041d4:	70 0c       	ld.w	r12,r8[0x0]
800041d6:	f0 1f 00 0c 	mcall	80004204 <xcmp_rx+0x3c>
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
800041da:	c1 00       	breq	800041fa <xcmp_rx+0x32>
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
800041dc:	fa c7 ff fc 	sub	r7,sp,-4
800041e0:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
	{
		memcpy(xcmp_ptr, &xcmp, sizeof(xcmp_fragment_t));				
800041e2:	e0 6a 00 ca 	mov	r10,202
800041e6:	08 9b       	mov	r11,r4
800041e8:	f0 1f 00 08 	mcall	80004208 <xcmp_rx+0x40>
		xQueueSend(xcmp_frame_rx, &xcmp_ptr, 0);	
800041ec:	48 88       	lddpc	r8,8000420c <xcmp_rx+0x44>
800041ee:	70 0c       	ld.w	r12,r8[0x0]
800041f0:	30 09       	mov	r9,0
800041f2:	12 9a       	mov	r10,r9
800041f4:	1a 9b       	mov	r11,sp
800041f6:	f0 1f 00 07 	mcall	80004210 <xcmp_rx+0x48>
	}	
}
800041fa:	2f fd       	sub	sp,-4
800041fc:	e3 cd 80 90 	ldm	sp++,r4,r7,pc
80004200:	00 00       	add	r0,r0
80004202:	0a 90       	mov	r0,r5
80004204:	80 00       	ld.sh	r0,r0[0x0]
80004206:	2f 2c       	sub	r12,-14
80004208:	80 00       	ld.sh	r0,r0[0x0]
8000420a:	69 5c       	ld.w	r12,r4[0x54]
8000420c:	00 00       	add	r0,r0
8000420e:	0a e8       	st.h	--r5,r8
80004210:	80 00       	ld.sh	r0,r0[0x0]
80004212:	54 6c       	stdsp	sp[0x118],r12

80004214 <xnl_register_xcmp_func>:
Function: xnl_register_xcmp_func
Description: register the xcmp function(callback function)
*/
void xnl_register_xcmp_func( void ( *func)(xnl_content_data_msg_t))
{
	 xcmp_exec = func;
80004214:	48 28       	lddpc	r8,8000421c <xnl_register_xcmp_func+0x8>
80004216:	91 0c       	st.w	r8[0x0],r12
}
80004218:	5e fc       	retal	r12
8000421a:	00 00       	add	r0,r0
8000421c:	00 00       	add	r0,r0
8000421e:	0b 48       	ld.w	r8,--r5

80004220 <xnl_get_msg_ack_func>:
Description: process while receive msg ack.
Calls:xSemaphoreGive--freertos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
80004220:	d4 01       	pushm	lr
	
	DestinationAddress = xnl->xnl_header.destination;
	/*No timeout*/		
	 //One relationship is controlled by a state machine, only the current MSG received the ACK, 
	//then the program will clear the current MSG sending address and out of standby and will jump to the sending state.
	if (DestinationAddress == xnl_information.device_address )
80004222:	48 88       	lddpc	r8,80004240 <xnl_get_msg_ack_func+0x20>
80004224:	90 28       	ld.sh	r8,r8[0x4]
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
	U16 DestinationAddress;
	U16 TransactionID;
	
	DestinationAddress = xnl->xnl_header.destination;
80004226:	98 49       	ld.sh	r9,r12[0x8]
80004228:	f0 09 19 00 	cp.h	r9,r8
8000422c:	c0 81       	brne	8000423c <xnl_get_msg_ack_func+0x1c>
	if (DestinationAddress == xnl_information.device_address )
	{
		//The ack is for me.
		
		TransactionID = xnl->xnl_header.transaction_id;
		xSemaphoreGive(xnl_timeout_semphr);	
8000422e:	48 68       	lddpc	r8,80004244 <xnl_get_msg_ack_func+0x24>
80004230:	70 0c       	ld.w	r12,r8[0x0]
80004232:	30 09       	mov	r9,0
80004234:	12 9a       	mov	r10,r9
80004236:	12 9b       	mov	r11,r9
80004238:	f0 1f 00 04 	mcall	80004248 <xnl_get_msg_ack_func+0x28>
8000423c:	d8 02       	popm	pc
8000423e:	00 00       	add	r0,r0
80004240:	00 00       	add	r0,r0
80004242:	0b 2e       	ld.uh	lr,r5++
80004244:	00 00       	add	r0,r0
80004246:	0b 28       	ld.uh	r8,r5++
80004248:	80 00       	ld.sh	r0,r0[0x0]
8000424a:	54 6c       	stdsp	sp[0x118],r12

8000424c <xnl_tx_process>:
	xSemaphoreTake--freertos 
	phy_tx -- physical.c
Called By: task
*/
static void xnl_tx_process(void * pvParameters)
{
8000424c:	d4 31       	pushm	r0-r7,lr
	static  xnl_fragment_t * ptr;//是否可以修缮为静态变量？请关注
	
	
	for(;;)
	{		
		switch(xnl_tx_state)
8000424e:	4a 86       	lddpc	r6,800042ec <xnl_tx_process+0xa0>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
80004250:	4a 82       	lddpc	r2,800042f0 <xnl_tx_process+0xa4>
80004252:	4a 94       	lddpc	r4,800042f4 <xnl_tx_process+0xa8>
80004254:	30 07       	mov	r7,0
80004256:	3f f1       	mov	r1,-1
					if(NULL == ptr)
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
80004258:	30 00       	mov	r0,0
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;
8000425a:	4a 85       	lddpc	r5,800042f8 <xnl_tx_process+0xac>
					
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
8000425c:	4a 83       	lddpc	r3,800042fc <xnl_tx_process+0xb0>
	static  xnl_fragment_t * ptr;//是否可以修缮为静态变量？请关注
	
	
	for(;;)
	{		
		switch(xnl_tx_state)
8000425e:	6c 08       	ld.w	r8,r6[0x0]
80004260:	58 08       	cp.w	r8,0
80004262:	c0 40       	breq	8000426a <xnl_tx_process+0x1e>
80004264:	58 18       	cp.w	r8,1
80004266:	cf d1       	brne	80004260 <xnl_tx_process+0x14>
80004268:	c2 08       	rjmp	800042a8 <xnl_tx_process+0x5c>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
8000426a:	64 0c       	ld.w	r12,r2[0x0]
8000426c:	0e 99       	mov	r9,r7
8000426e:	02 9a       	mov	r10,r1
80004270:	08 9b       	mov	r11,r4
80004272:	f0 1f 00 24 	mcall	80004300 <xnl_tx_process+0xb4>
80004276:	58 1c       	cp.w	r12,1
80004278:	cf 31       	brne	8000425e <xnl_tx_process+0x12>
					, portMAX_DELAY ))
				{				
					if(NULL == ptr)
8000427a:	68 0c       	ld.w	r12,r4[0x0]
8000427c:	58 0c       	cp.w	r12,0
8000427e:	cf 00       	breq	8000425e <xnl_tx_process+0x12>
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
80004280:	98 28       	ld.sh	r8,r12[0x4]
80004282:	e0 08 19 00 	cp.h	r8,r0
80004286:	c0 41       	brne	8000428e <xnl_tx_process+0x42>
					{
						/*invalid XNL opcode*/
						vPortFree(ptr);
80004288:	f0 1f 00 1f 	mcall	80004304 <xnl_tx_process+0xb8>
						break;
8000428c:	ce 9b       	rjmp	8000425e <xnl_tx_process+0x12>
					}
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
8000428e:	f0 1f 00 1f 	mcall	80004308 <xnl_tx_process+0xbc>
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;
80004292:	30 18       	mov	r8,1
80004294:	8b 08       	st.w	r5[0x0],r8
					
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
80004296:	66 0c       	ld.w	r12,r3[0x0]
80004298:	0e 99       	mov	r9,r7
8000429a:	0e 9a       	mov	r10,r7
8000429c:	0e 9b       	mov	r11,r7
8000429e:	f0 1f 00 19 	mcall	80004300 <xnl_tx_process+0xb4>
					xnl_tx_state = WAITING_FOR_REPLY;
800042a2:	30 18       	mov	r8,1
800042a4:	8d 08       	st.w	r6[0x0],r8
800042a6:	cd cb       	rjmp	8000425e <xnl_tx_process+0x12>
				}
				break;
			
			/*wait XNL reply*/			
			case WAITING_FOR_REPLY://直到回答ACK才再发送下一条data/control
				if(pdTRUE == xSemaphoreTake( xnl_timeout_semphr
800042a8:	66 0c       	ld.w	r12,r3[0x0]
800042aa:	0e 99       	mov	r9,r7
800042ac:	36 4a       	mov	r10,100
800042ae:	0e 9b       	mov	r11,r7
800042b0:	f0 1f 00 14 	mcall	80004300 <xnl_tx_process+0xb4>
800042b4:	58 1c       	cp.w	r12,1
800042b6:	c0 81       	brne	800042c6 <xnl_tx_process+0x7a>
					, ( portTickType )50*2/ portTICK_RATE_MS))//按ADK文档中提示500ms一次超时,但是实际情况下程序中启用freertos的任务延时不够精准。因此根据经验需要降低延时等待的时间
				{
					/*No timeout*/
					//vPortFree(ptr);	
					set_xnl_idle(ptr);			
800042b8:	49 58       	lddpc	r8,8000430c <xnl_tx_process+0xc0>
800042ba:	70 0c       	ld.w	r12,r8[0x0]
800042bc:	68 0b       	ld.w	r11,r4[0x0]
800042be:	f0 1f 00 15 	mcall	80004310 <xnl_tx_process+0xc4>
					xnl_tx_state = WAITING_FOR_TX;
800042c2:	8d 07       	st.w	r6[0x0],r7
800042c4:	cc db       	rjmp	8000425e <xnl_tx_process+0x12>
				}
				else
				{
					/*time out*/
					if(xnl_send_times <= MIN_RESEND_TIMES)
800042c6:	6a 08       	ld.w	r8,r5[0x0]
800042c8:	58 38       	cp.w	r8,3
800042ca:	e0 89 00 09 	brgt	800042dc <xnl_tx_process+0x90>
					{
						/*If times smaller than A supermarket, then resend the 
						instructions*/
						phy_tx((phy_fragment_t *)ptr);
800042ce:	68 0c       	ld.w	r12,r4[0x0]
800042d0:	f0 1f 00 0e 	mcall	80004308 <xnl_tx_process+0xbc>
						xnl_send_times++;
800042d4:	6a 08       	ld.w	r8,r5[0x0]
800042d6:	2f f8       	sub	r8,-1
800042d8:	8b 08       	st.w	r5[0x0],r8
800042da:	cc 2b       	rjmp	8000425e <xnl_tx_process+0x12>
					}
					else
					{
						//can not send data, disconnected						
						//vPortFree(ptr);	
						set_xnl_idle(ptr);									
800042dc:	48 c8       	lddpc	r8,8000430c <xnl_tx_process+0xc0>
800042de:	70 0c       	ld.w	r12,r8[0x0]
800042e0:	68 0b       	ld.w	r11,r4[0x0]
800042e2:	f0 1f 00 0c 	mcall	80004310 <xnl_tx_process+0xc4>
						xnl_tx_state = WAITING_FOR_TX;
800042e6:	8d 07       	st.w	r6[0x0],r7
800042e8:	cb bb       	rjmp	8000425e <xnl_tx_process+0x12>
800042ea:	00 00       	add	r0,r0
800042ec:	00 00       	add	r0,r0
800042ee:	0b 44       	ld.w	r4,--r5
800042f0:	00 00       	add	r0,r0
800042f2:	0b 38       	ld.ub	r8,r5++
800042f4:	00 00       	add	r0,r0
800042f6:	0b 3c       	ld.ub	r12,r5++
800042f8:	00 00       	add	r0,r0
800042fa:	0b 40       	ld.w	r0,--r5
800042fc:	00 00       	add	r0,r0
800042fe:	0b 28       	ld.uh	r8,r5++
80004300:	80 00       	ld.sh	r0,r0[0x0]
80004302:	52 60       	stdsp	sp[0x98],r0
80004304:	80 00       	ld.sh	r0,r0[0x0]
80004306:	50 f0       	stdsp	sp[0x3c],r0
80004308:	80 00       	ld.sh	r0,r0[0x0]
8000430a:	29 e0       	sub	r0,-98
8000430c:	00 00       	add	r0,r0
8000430e:	0a 90       	mov	r0,r5
80004310:	80 00       	ld.sh	r0,r0[0x0]
80004312:	29 c0       	sub	r0,-100

80004314 <xnl_rx_process>:
Description: Receive the XNL
Calls: 
Called By:task
*/
static void xnl_rx_process(void * pvParameters)
{
80004314:	eb cd 40 fe 	pushm	r1-r7,lr
80004318:	20 1d       	sub	sp,4
	/*To ptr the elements in the queue*/
	xnl_fragment_t * xnl_ptr;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
8000431a:	49 26       	lddpc	r6,80004360 <xnl_rx_process+0x4c>
8000431c:	30 05       	mov	r5,0
8000431e:	3f f4       	mov	r4,-1
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
80004320:	30 c3       	mov	r3,12
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
80004322:	49 11       	lddpc	r1,80004364 <xnl_rx_process+0x50>
	if(xnl->xnl_header.opcode > 0x0C)	
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
80004324:	49 12       	lddpc	r2,80004368 <xnl_rx_process+0x54>
	/*To ptr the elements in the queue*/
	xnl_fragment_t * xnl_ptr;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
80004326:	6c 0c       	ld.w	r12,r6[0x0]
80004328:	0a 99       	mov	r9,r5
8000432a:	08 9a       	mov	r10,r4
8000432c:	1a 9b       	mov	r11,sp
8000432e:	f0 1f 00 10 	mcall	8000436c <xnl_rx_process+0x58>
80004332:	58 1c       	cp.w	r12,1
80004334:	cf 91       	brne	80004326 <xnl_rx_process+0x12>
		, portMAX_DELAY ))
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
80004336:	40 0c       	lddsp	r12,sp[0x0]
80004338:	58 0c       	cp.w	r12,0
8000433a:	cf 60       	breq	80004326 <xnl_rx_process+0x12>
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
8000433c:	98 28       	ld.sh	r8,r12[0x4]
8000433e:	e6 08 19 00 	cp.h	r8,r3
80004342:	e0 8b 00 0a 	brhi	80004356 <xnl_rx_process+0x42>
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
80004346:	5c 78       	castu.h	r8
80004348:	e4 08 03 29 	ld.w	r9,r2[r8<<0x2]
8000434c:	58 09       	cp.w	r9,0
8000434e:	c0 40       	breq	80004356 <xnl_rx_process+0x42>
	{
		//log("\n\r R_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:R_xnl指令
		/*execute the function in list*/
		xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec(xnl);
80004350:	e4 08 03 28 	ld.w	r8,r2[r8<<0x2]
80004354:	5d 18       	icall	r8
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
80004356:	62 0c       	ld.w	r12,r1[0x0]
80004358:	40 0b       	lddsp	r11,sp[0x0]
8000435a:	f0 1f 00 06 	mcall	80004370 <xnl_rx_process+0x5c>
8000435e:	ce 4b       	rjmp	80004326 <xnl_rx_process+0x12>
80004360:	00 00       	add	r0,r0
80004362:	0a b8       	st.h	r5++,r8
80004364:	00 00       	add	r0,r0
80004366:	0a 90       	mov	r0,r5
80004368:	00 00       	add	r0,r0
8000436a:	04 f4       	st.b	--r2,r4
8000436c:	80 00       	ld.sh	r0,r0[0x0]
8000436e:	52 60       	stdsp	sp[0x98],r0
80004370:	80 00       	ld.sh	r0,r0[0x0]
80004372:	29 c0       	sub	r0,-100

80004374 <xnl_tx>:
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
{
80004374:	eb cd 40 c0 	pushm	r6-r7,lr
80004378:	20 1d       	sub	sp,4
8000437a:	18 96       	mov	r6,r12
	message that is sent. The same value should be used for all retries.
	*/
	static U8 flags = 0;
	
	/*If the value is DEFAULT_VALUE, the value will be modified*/
	if(DEFAULT_VALUE == xnl->xnl_header.flags)
8000437c:	98 39       	ld.sh	r9,r12[0x6]
8000437e:	3f f8       	mov	r8,-1
80004380:	f0 09 19 00 	cp.h	r9,r8
80004384:	c0 a1       	brne	80004398 <xnl_tx+0x24>
	{
		xnl->xnl_header.flags =  0x0100 | ((++flags) & 0x07);
80004386:	4a e9       	lddpc	r9,8000443c <xnl_tx+0xc8>
80004388:	13 88       	ld.ub	r8,r9[0x0]
8000438a:	2f f8       	sub	r8,-1
8000438c:	5c 58       	castu.b	r8
8000438e:	b2 88       	st.b	r9[0x0],r8
80004390:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
80004394:	a9 a8       	sbr	r8,0x8
80004396:	b8 38       	st.h	r12[0x6],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.destination)
80004398:	8c 49       	ld.sh	r9,r6[0x8]
8000439a:	3f f8       	mov	r8,-1
8000439c:	f0 09 19 00 	cp.h	r9,r8
800043a0:	c0 41       	brne	800043a8 <xnl_tx+0x34>
	{		
		/*Use actual Master address.*/
		xnl->xnl_header.destination = xnl_information.master_address;
800043a2:	4a 88       	lddpc	r8,80004440 <xnl_tx+0xcc>
800043a4:	90 18       	ld.sh	r8,r8[0x2]
800043a6:	ac 48       	st.h	r6[0x8],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.source)
800043a8:	8c 59       	ld.sh	r9,r6[0xa]
800043aa:	3f f8       	mov	r8,-1
800043ac:	f0 09 19 00 	cp.h	r9,r8
800043b0:	c0 41       	brne	800043b8 <xnl_tx+0x44>
	{
		/*Use Temporary address.*/	
		xnl->xnl_header.source = xnl_information.device_address;
800043b2:	4a 48       	lddpc	r8,80004440 <xnl_tx+0xcc>
800043b4:	90 28       	ld.sh	r8,r8[0x4]
800043b6:	ac 58       	st.h	r6[0xa],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
800043b8:	8c 69       	ld.sh	r9,r6[0xc]
800043ba:	3f f8       	mov	r8,-1
800043bc:	f0 09 19 00 	cp.h	r9,r8
800043c0:	c0 e1       	brne	800043dc <xnl_tx+0x68>
	{		
		xnl->xnl_header.transaction_id = 
		  ((++xnl_information.transaction_id) & 0xFF) 
800043c2:	4a 08       	lddpc	r8,80004440 <xnl_tx+0xcc>
800043c4:	90 49       	ld.sh	r9,r8[0x8]
800043c6:	2f f9       	sub	r9,-1
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
800043c8:	b0 49       	st.h	r8[0x8],r9
		  ((++xnl_information.transaction_id) & 0xFF) 
800043ca:	90 4a       	ld.sh	r10,r8[0x8]
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
800043cc:	90 49       	ld.sh	r9,r8[0x8]
800043ce:	e0 19 ff 00 	andl	r9,0xff00
800043d2:	f1 da c0 08 	bfextu	r8,r10,0x0,0x8
800043d6:	f3 e8 10 08 	or	r8,r9,r8
800043da:	ac 68       	st.h	r6[0xc],r8
	U16  sumScratch;
	U32  indextohWord;
	S32  hWordswithinFrag;
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
800043dc:	0d 98       	ld.ub	r8,r6[0x1]
800043de:	20 28       	sub	r8,2
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
800043e0:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
800043e4:	10 0c       	add	r12,r8
800043e6:	a1 5c       	asr	r12,0x1
	indextohWord = 2;
	while (hWordswithinFrag > 0)
800043e8:	58 0c       	cp.w	r12,0
800043ea:	e0 89 00 04 	brgt	800043f2 <xnl_tx+0x7e>
800043ee:	30 09       	mov	r9,0
800043f0:	c0 d8       	rjmp	8000440a <xnl_tx+0x96>
800043f2:	ec ca ff fc 	sub	r10,r6,-4
Parameters: xnl_fragment_t * 
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
800043f6:	2f ec       	sub	r12,-2
800043f8:	30 09       	mov	r9,0
800043fa:	30 28       	mov	r8,2
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
	{
		sumScratch += *((U16*)xnl + indextohWord);
800043fc:	15 1b       	ld.sh	r11,r10++
800043fe:	f6 09 00 09 	add	r9,r11,r9
80004402:	5c 89       	casts.h	r9
		indextohWord     += 1;
80004404:	2f f8       	sub	r8,-1
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
80004406:	18 38       	cp.w	r8,r12
80004408:	cf a1       	brne	800043fc <xnl_tx+0x88>
		  ((++xnl_information.transaction_id) & 0xFF) 
		| (xnl_information.transaction_id & 0xFF00);
	}
	
	/*count check sum */
	xnl->phy_header.check_sum = check_sum( xnl );
8000440a:	5c 39       	neg	r9
8000440c:	ac 19       	st.h	r6[0x2],r9
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
8000440e:	48 e8       	lddpc	r8,80004444 <xnl_tx+0xd0>
80004410:	70 0c       	ld.w	r12,r8[0x0]
80004412:	f0 1f 00 0e 	mcall	80004448 <xnl_tx+0xd4>
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
80004416:	c1 00       	breq	80004436 <xnl_tx+0xc2>
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
80004418:	fa c7 ff fc 	sub	r7,sp,-4
8000441c:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
	{
		memcpy(ptr, xnl, sizeof(xnl_fragment_t));
8000441e:	e0 6a 01 00 	mov	r10,256
80004422:	0c 9b       	mov	r11,r6
80004424:	f0 1f 00 0a 	mcall	8000444c <xnl_tx+0xd8>
	
		/*push to queue and send*/
		
		//log("ptr -%8x", ptr);
		
		xQueueSend(xnl_frame_tx, &ptr, 0);
80004428:	48 a8       	lddpc	r8,80004450 <xnl_tx+0xdc>
8000442a:	70 0c       	ld.w	r12,r8[0x0]
8000442c:	30 09       	mov	r9,0
8000442e:	12 9a       	mov	r10,r9
80004430:	1a 9b       	mov	r11,sp
80004432:	f0 1f 00 09 	mcall	80004454 <xnl_tx+0xe0>
		//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
		
		//vPortFree(ptr);
	}
}
80004436:	2f fd       	sub	sp,-4
80004438:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000443c:	00 00       	add	r0,r0
8000443e:	0b 2c       	ld.uh	r12,r5++
80004440:	00 00       	add	r0,r0
80004442:	0b 2e       	ld.uh	lr,r5++
80004444:	00 00       	add	r0,r0
80004446:	0a 90       	mov	r0,r5
80004448:	80 00       	ld.sh	r0,r0[0x0]
8000444a:	2f 2c       	sub	r12,-14
8000444c:	80 00       	ld.sh	r0,r0[0x0]
8000444e:	69 5c       	ld.w	r12,r4[0x54]
80004450:	00 00       	add	r0,r0
80004452:	0b 38       	ld.ub	r8,r5++
80004454:	80 00       	ld.sh	r0,r0[0x0]
80004456:	54 6c       	stdsp	sp[0x118],r12

80004458 <xnl_init>:
	xTaskCreate--freertos
	xnl_send_device_master_query
Called By:xcmp_init -- xcmp.c
*/
void xnl_init(void)
{
80004458:	eb cd 40 80 	pushm	r7,lr
8000445c:	fa cd 01 00 	sub	sp,sp,256
	
	xnl_information.is_connected = FALSE;
80004460:	30 09       	mov	r9,0
80004462:	4a 78       	lddpc	r8,800044fc <xnl_init+0xa4>
80004464:	b0 89       	st.b	r8[0x0],r9

	/*initialize the semaphore and queue*/
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
80004466:	30 0b       	mov	r11,0
80004468:	30 1c       	mov	r12,1
8000446a:	f0 1f 00 26 	mcall	80004500 <xnl_init+0xa8>
8000446e:	4a 68       	lddpc	r8,80004504 <xnl_init+0xac>
80004470:	91 0c       	st.w	r8[0x0],r12
80004472:	70 08       	ld.w	r8,r8[0x0]
80004474:	58 08       	cp.w	r8,0
80004476:	c0 80       	breq	80004486 <xnl_init+0x2e>
80004478:	4a 38       	lddpc	r8,80004504 <xnl_init+0xac>
8000447a:	70 0c       	ld.w	r12,r8[0x0]
8000447c:	30 09       	mov	r9,0
8000447e:	12 9a       	mov	r10,r9
80004480:	12 9b       	mov	r11,r9
80004482:	f0 1f 00 22 	mcall	80004508 <xnl_init+0xb0>
	//xnl_frame_tx = xQueueCreate(10, sizeof(xnl_fragment_t *)); 
	
	xnl_frame_tx = xQueueCreate(20, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
80004486:	30 4b       	mov	r11,4
80004488:	31 4c       	mov	r12,20
8000448a:	f0 1f 00 1e 	mcall	80004500 <xnl_init+0xa8>
8000448e:	4a 08       	lddpc	r8,8000450c <xnl_init+0xb4>
80004490:	91 0c       	st.w	r8[0x0],r12
		
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
80004492:	30 07       	mov	r7,0
80004494:	1a d7       	st.w	--sp,r7
80004496:	1a d7       	st.w	--sp,r7
80004498:	1a d7       	st.w	--sp,r7
8000449a:	30 38       	mov	r8,3
8000449c:	0e 99       	mov	r9,r7
8000449e:	e0 6a 02 00 	mov	r10,512
800044a2:	49 cb       	lddpc	r11,80004510 <xnl_init+0xb8>
800044a4:	49 cc       	lddpc	r12,80004514 <xnl_init+0xbc>
800044a6:	f0 1f 00 1d 	mcall	80004518 <xnl_init+0xc0>
	,  tskXNL_PRIORITY //+ 1
	,  NULL
	);
	
	/*this task is used to send xnl message*/
	xTaskCreate(
800044aa:	1a d7       	st.w	--sp,r7
800044ac:	1a d7       	st.w	--sp,r7
800044ae:	1a d7       	st.w	--sp,r7
800044b0:	30 38       	mov	r8,3
800044b2:	0e 99       	mov	r9,r7
800044b4:	e0 6a 03 20 	mov	r10,800
800044b8:	49 9b       	lddpc	r11,8000451c <xnl_init+0xc4>
800044ba:	49 ac       	lddpc	r12,80004520 <xnl_init+0xc8>
800044bc:	f0 1f 00 17 	mcall	80004518 <xnl_init+0xc0>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
800044c0:	e0 68 40 0e 	mov	r8,16398
800044c4:	fb 58 00 18 	st.h	sp[24],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
800044c8:	3f f8       	mov	r8,-1
800044ca:	fb 58 00 1a 	st.h	sp[26],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_MASTER_QUERY;
800044ce:	30 38       	mov	r8,3
800044d0:	fb 58 00 1c 	st.h	sp[28],r8
	
	/*The initial value*/
	xnl_frame.xnl_header.flags = 0;
800044d4:	fb 57 00 1e 	st.h	sp[30],r7
	
	/*XNL address of the master device, if known;otherwise 0x0000*/
	xnl_frame.xnl_header.destination = 0;
800044d8:	fb 57 00 20 	st.h	sp[32],r7
	
	/*XNL address, if assigned; otherwise 0x0000*/
	xnl_frame.xnl_header.source = 0;
800044dc:	fb 57 00 22 	st.h	sp[34],r7
	
	/*No transaction ID required for this message*/
	xnl_frame.xnl_header.transaction_id = 0;
800044e0:	fb 57 00 24 	st.h	sp[36],r7
	
	/*This message contains no payload*/
	xnl_frame.xnl_header.payload_length = 0;
800044e4:	fb 57 00 26 	st.h	sp[38],r7

	/*send XNL message*/
	xnl_tx(&xnl_frame);
800044e8:	fa cc ff e8 	sub	r12,sp,-24
800044ec:	f0 1f 00 0e 	mcall	80004524 <xnl_init+0xcc>
	
	/*send device_master_query to connect radio*/	
	xnl_send_device_master_query();
	
	/*initialize the physical layer*/
	phy_init();
800044f0:	f0 1f 00 0e 	mcall	80004528 <xnl_init+0xd0>
800044f4:	2f ad       	sub	sp,-24
}
800044f6:	2c 0d       	sub	sp,-256
800044f8:	e3 cd 80 80 	ldm	sp++,r7,pc
800044fc:	00 00       	add	r0,r0
800044fe:	0b 2e       	ld.uh	lr,r5++
80004500:	80 00       	ld.sh	r0,r0[0x0]
80004502:	55 6c       	stdsp	sp[0x158],r12
80004504:	00 00       	add	r0,r0
80004506:	0b 28       	ld.uh	r8,r5++
80004508:	80 00       	ld.sh	r0,r0[0x0]
8000450a:	54 6c       	stdsp	sp[0x118],r12
8000450c:	00 00       	add	r0,r0
8000450e:	0b 38       	ld.ub	r8,r5++
80004510:	80 00       	ld.sh	r0,r0[0x0]
80004512:	c7 d0       	breq	8000460c <xnl_device_auth_reply_func+0x80>
80004514:	80 00       	ld.sh	r0,r0[0x0]
80004516:	43 14       	lddsp	r4,sp[0xc4]
80004518:	80 00       	ld.sh	r0,r0[0x0]
8000451a:	5c 40       	abs	r0
8000451c:	80 00       	ld.sh	r0,r0[0x0]
8000451e:	c0 00       	breq	8000451e <xnl_init+0xc6>
80004520:	80 00       	ld.sh	r0,r0[0x0]
80004522:	42 4c       	lddsp	r12,sp[0x90]
80004524:	80 00       	ld.sh	r0,r0[0x0]
80004526:	43 74       	lddsp	r4,sp[0xdc]
80004528:	80 00       	ld.sh	r0,r0[0x0]
8000452a:	2f 54       	sub	r4,-11

8000452c <xnl_data_msg_func>:
Description: process while receive data message.
Calls:xnl_send_msg_ack, xcmp_exec(function in xcmp)
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_data_msg_func(xnl_fragment_t * xnl)
{
8000452c:	eb cd 40 80 	pushm	r7,lr
80004530:	fa cd 01 00 	sub	sp,sp,256
80004534:	18 97       	mov	r7,r12
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80004536:	e0 68 40 0e 	mov	r8,16398
8000453a:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
8000453c:	3f f8       	mov	r8,-1
8000453e:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG_ACK;
80004540:	30 c8       	mov	r8,12
80004542:	ba 28       	st.h	sp[0x4],r8
	
	/*Turn around Flags.*/	
	xnl_frame.xnl_header.flags = hdr->flags;
80004544:	98 38       	ld.sh	r8,r12[0x6]
80004546:	ba 38       	st.h	sp[0x6],r8
	
	/*ACK Destination Address is Source of XNL_Message.*/
	xnl_frame.xnl_header.destination = hdr->source;
80004548:	98 58       	ld.sh	r8,r12[0xa]
8000454a:	ba 48       	st.h	sp[0x8],r8
	
	/*ACK Source Address is my address.*/
	xnl_frame.xnl_header.source = hdr->destination;
8000454c:	98 48       	ld.sh	r8,r12[0x8]
8000454e:	ba 58       	st.h	sp[0xa],r8
	
	/*Turn around Transaction ID.*/
	xnl_frame.xnl_header.transaction_id = hdr->transaction_id;
80004550:	98 68       	ld.sh	r8,r12[0xc]
80004552:	ba 68       	st.h	sp[0xc],r8
	xnl_frame.xnl_header.payload_length = 0;
80004554:	30 08       	mov	r8,0
80004556:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004558:	1a 9c       	mov	r12,sp
8000455a:	f0 1f 00 0a 	mcall	80004580 <xnl_data_msg_func+0x54>
	transmitter, but possibly is waiting in Queue with immediate timeout.
	 */
	xnl_send_msg_ack(&xnl->xnl_header);
	
	/*exec xcmp function*/
	xcmp_exec(xnl->xnl_payload.xnl_content_data_msg);//xcmp_rx
8000455e:	fa cd 00 cc 	sub	sp,sp,204
80004562:	e0 6a 00 ca 	mov	r10,202
80004566:	ee cb ff f0 	sub	r11,r7,-16
8000456a:	1a 9c       	mov	r12,sp
8000456c:	f0 1f 00 06 	mcall	80004584 <xnl_data_msg_func+0x58>
80004570:	48 68       	lddpc	r8,80004588 <xnl_data_msg_func+0x5c>
80004572:	70 08       	ld.w	r8,r8[0x0]
80004574:	5d 18       	icall	r8
80004576:	fa cd ff 34 	sub	sp,sp,-204
}
8000457a:	2c 0d       	sub	sp,-256
8000457c:	e3 cd 80 80 	ldm	sp++,r7,pc
80004580:	80 00       	ld.sh	r0,r0[0x0]
80004582:	43 74       	lddsp	r4,sp[0xdc]
80004584:	80 00       	ld.sh	r0,r0[0x0]
80004586:	69 5c       	ld.w	r12,r4[0x54]
80004588:	00 00       	add	r0,r0
8000458a:	0b 48       	ld.w	r8,--r5

8000458c <xnl_device_auth_reply_func>:
Description: process while receive device auth reply.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_auth_reply_func(xnl_fragment_t * xnl)
{
8000458c:	d4 21       	pushm	r4-r7,lr
8000458e:	fa cd 01 00 	sub	sp,sp,256
80004592:	18 97       	mov	r7,r12
	the receiving device and will be used to authenticate the connection 
	request. 5.4.4
	*/
	//log("R_xnl-opcode:%4x", xnl->xnl_header.opcode);
	
	if(xnl_information.is_connected)
80004594:	4c 28       	lddpc	r8,8000469c <xnl_device_auth_reply_func+0x110>
80004596:	11 88       	ld.ub	r8,r8[0x0]
80004598:	58 08       	cp.w	r8,0
8000459a:	e0 81 00 7f 	brne	80004698 <xnl_device_auth_reply_func+0x10c>
	{
		return;		
	}
	
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);
8000459e:	4c 18       	lddpc	r8,800046a0 <xnl_device_auth_reply_func+0x114>
800045a0:	70 0c       	ld.w	r12,r8[0x0]
800045a2:	30 09       	mov	r9,0
800045a4:	12 9a       	mov	r10,r9
800045a6:	12 9b       	mov	r11,r9
800045a8:	f0 1f 00 3f 	mcall	800046a4 <xnl_device_auth_reply_func+0x118>

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
800045ac:	ef 09 00 10 	ld.sh	r9,r7[16]
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
800045b0:	4b b8       	lddpc	r8,8000469c <xnl_device_auth_reply_func+0x110>
800045b2:	b0 29       	st.h	r8[0x4],r9
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
	
	/*Get Array of values to be encrypted into an aligned 2X32bits.*/
	v_vector[0] =
800045b4:	ef 39 00 12 	ld.ub	r9,r7[18]
800045b8:	ef 38 00 13 	ld.ub	r8,r7[19]
800045bc:	b1 68       	lsl	r8,0x10
800045be:	f1 e9 11 89 	or	r9,r8,r9<<0x18
800045c2:	ef 38 00 15 	ld.ub	r8,r7[21]
800045c6:	f3 e8 10 08 	or	r8,r9,r8
800045ca:	ef 39 00 14 	ld.ub	r9,r7[20]
800045ce:	f1 e9 10 89 	or	r9,r8,r9<<0x8
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[2])<<8	  
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[3]);
	
	v_vector[1] =
800045d2:	ef 3a 00 16 	ld.ub	r10,r7[22]
800045d6:	ef 38 00 17 	ld.ub	r8,r7[23]
800045da:	b1 68       	lsl	r8,0x10
800045dc:	f1 ea 11 8a 	or	r10,r8,r10<<0x18
800045e0:	ef 38 00 19 	ld.ub	r8,r7[25]
800045e4:	f5 e8 10 08 	or	r8,r10,r8
800045e8:	ef 3a 00 18 	ld.ub	r10,r7[24]
800045ec:	f1 ea 10 88 	or	r8,r8,r10<<0x8
800045f0:	30 0a       	mov	r10,0
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
800045f2:	e0 64 79 b9 	mov	r4,31161
800045f6:	ea 14 9e 37 	orh	r4,0x9e37
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
800045fa:	e0 65 45 07 	mov	r5,17671
800045fe:	ea 15 8a bd 	orh	r5,0x8abd
80004602:	e0 66 f9 3d 	mov	r6,63805
80004606:	ea 16 99 68 	orh	r6,0x9968
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
8000460a:	e0 6e b8 cf 	mov	lr,47311
8000460e:	ea 1e 36 83 	orh	lr,0x3683
80004612:	e0 67 aa 1c 	mov	r7,43548
80004616:	ea 17 9c 36 	orh	r7,0x9c36
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
8000461a:	08 0a       	add	r10,r4
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
8000461c:	f4 08 00 0c 	add	r12,r10,r8
80004620:	f0 0b 15 04 	lsl	r11,r8,0x4
80004624:	0a 0b       	add	r11,r5
80004626:	f9 eb 20 0b 	eor	r11,r12,r11
8000462a:	f0 0c 16 05 	lsr	r12,r8,0x5
8000462e:	0c 0c       	add	r12,r6
80004630:	18 5b       	eor	r11,r12
80004632:	16 09       	add	r9,r11
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
80004634:	f2 0c 15 04 	lsl	r12,r9,0x4
80004638:	1c 0c       	add	r12,lr
8000463a:	f2 0b 16 05 	lsr	r11,r9,0x5
8000463e:	0e 0b       	add	r11,r7
80004640:	f9 eb 20 0b 	eor	r11,r12,r11
80004644:	f2 0a 00 0c 	add	r12,r9,r10
80004648:	18 5b       	eor	r11,r12
8000464a:	16 08       	add	r8,r11
{
	register U32 y=v[0], z=v[1], sum=0;
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
8000464c:	e0 6b 37 20 	mov	r11,14112
80004650:	ea 1b c6 ef 	orh	r11,0xc6ef
80004654:	16 3a       	cp.w	r10,r11
80004656:	ce 21       	brne	8000461a <xnl_device_auth_reply_func+0x8e>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :24 + 2(xnl length(24) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 24 + 2;
80004658:	e0 6a 40 1a 	mov	r10,16410
8000465c:	ba 0a       	st.h	sp[0x0],r10
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
8000465e:	3f fa       	mov	r10,-1
80004660:	ba 1a       	st.h	sp[0x2],r10
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_CONN_REQUEST;
80004662:	30 6b       	mov	r11,6
80004664:	ba 2b       	st.h	sp[0x4],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
80004666:	ba 3a       	st.h	sp[0x6],r10
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
80004668:	48 db       	lddpc	r11,8000469c <xnl_device_auth_reply_func+0x110>
8000466a:	96 1c       	ld.sh	r12,r11[0x2]
8000466c:	ba 4c       	st.h	sp[0x8],r12
	message here, and all will receive the same DEVICE_CONN_REPLY. Not real 
	sure what's going to happen with multiple conrol heads, etc. One suspects 
	the Rocket Scientists will eventually figure this out, and demand a 
	transaction ID based on Device Type in the XNL_DEVICE_AUTH_KEY_REQUEST.
	*/
	xnl_frame.xnl_header.source = xnl_information.device_address;
8000466e:	96 2b       	ld.sh	r11,r11[0x4]
80004670:	ba 5b       	st.h	sp[0xa],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80004672:	ba 6a       	st.h	sp[0xc],r10
	
    /*his message contains 12 payload bytes*/	
	xnl_frame.xnl_header.payload_length = 0x000C;
80004674:	30 ca       	mov	r10,12
80004676:	ba 7a       	st.h	sp[0xe],r10
	
	/*No Preferred XNL Address*/
	xnl_frame.xnl_payload.xnl_content_device_conn_req.preferred_xnl_address = 
80004678:	30 0a       	mov	r10,0
8000467a:	fb 5a 00 10 	st.h	sp[16],r10
	XCMP/XNL Development Specification Section 4.5.3.2.1.
	Same as in MOTOTRBO?XCMP/XNL Development Specification?
	evice_type--Option Board(0x07)
	authentication_index--Option Board(0x02)
	*/	
	xnl_frame.xnl_payload.xnl_content_device_conn_req.device_type = 0x07;
8000467e:	30 7a       	mov	r10,7
80004680:	fb 6a 00 12 	st.b	sp[18],r10
	xnl_frame.xnl_payload.xnl_content_device_conn_req.authentication_index =
80004684:	30 2a       	mov	r10,2
80004686:	fb 6a 00 13 	st.b	sp[19],r10
	                                                                       0x02;
		
	//We know encrypted array happens to be aligned to 32-bit boundary.
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
8000468a:	fa ca ff ec 	sub	r10,sp,-20
8000468e:	95 09       	st.w	r10[0x0],r9
	                         .encrypted_authentication_value[0])) = w_vector[0];
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
80004690:	95 18       	st.w	r10[0x4],r8
	                         .encrypted_authentication_value[4])) = w_vector[1];
	
	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004692:	1a 9c       	mov	r12,sp
80004694:	f0 1f 00 05 	mcall	800046a8 <xnl_device_auth_reply_func+0x11c>
}
80004698:	2c 0d       	sub	sp,-256
8000469a:	d8 22       	popm	r4-r7,pc
8000469c:	00 00       	add	r0,r0
8000469e:	0b 2e       	ld.uh	lr,r5++
800046a0:	00 00       	add	r0,r0
800046a2:	0b 28       	ld.uh	r8,r5++
800046a4:	80 00       	ld.sh	r0,r0[0x0]
800046a6:	54 6c       	stdsp	sp[0x118],r12
800046a8:	80 00       	ld.sh	r0,r0[0x0]
800046aa:	43 74       	lddsp	r4,sp[0xdc]

800046ac <xnl_master_status_brdcst_func>:
Description: process while receive master status boardcast.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_master_status_brdcst_func(xnl_fragment_t * xnl)
{	
800046ac:	eb cd 40 80 	pushm	r7,lr
800046b0:	fa cd 01 00 	sub	sp,sp,256
800046b4:	18 97       	mov	r7,r12
	not an XNL_DATA_MSG has been sent out. This will indicate to a connecting 
	device that it has missed messages. The XNL header will contain the 
	master?XNL address. 5.4.1
	*/
	
	if(xnl_information.is_connected)
800046b6:	49 28       	lddpc	r8,800046fc <xnl_master_status_brdcst_func+0x50>
800046b8:	11 88       	ld.ub	r8,r8[0x0]
800046ba:	58 08       	cp.w	r8,0
800046bc:	c1 c1       	brne	800046f4 <xnl_master_status_brdcst_func+0x48>
	{
		return;	
	}
		
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);	
800046be:	49 18       	lddpc	r8,80004700 <xnl_master_status_brdcst_func+0x54>
800046c0:	70 0c       	ld.w	r12,r8[0x0]
800046c2:	30 09       	mov	r9,0
800046c4:	12 9a       	mov	r10,r9
800046c6:	12 9b       	mov	r11,r9
800046c8:	f0 1f 00 0f 	mcall	80004704 <xnl_master_status_brdcst_func+0x58>

	//log("xnl-ma:%4x", xnl->xnl_header.source);
	/*get the master adderss from this message*/	
	xnl_information.master_address = xnl->xnl_header.source;	
800046cc:	8e 58       	ld.sh	r8,r7[0xa]
800046ce:	48 c9       	lddpc	r9,800046fc <xnl_master_status_brdcst_func+0x50>
800046d0:	b2 18       	st.h	r9[0x2],r8
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
800046d2:	e0 68 40 0e 	mov	r8,16398
800046d6:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
800046d8:	3f f8       	mov	r8,-1
800046da:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_AUTH_KEY_REQUEST;
800046dc:	30 4a       	mov	r10,4
800046de:	ba 2a       	st.h	sp[0x4],r10
		
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/	
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
800046e0:	ba 38       	st.h	sp[0x6],r8
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
800046e2:	92 19       	ld.sh	r9,r9[0x2]
800046e4:	ba 49       	st.h	sp[0x8],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.source = DEFAULT_VALUE;
800046e6:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
800046e8:	ba 68       	st.h	sp[0xc],r8
		
	xnl_frame.xnl_header.payload_length = 0;
800046ea:	30 08       	mov	r8,0
800046ec:	ba 78       	st.h	sp[0xe],r8
	
	/*send XNL message*/	
	xnl_tx(&xnl_frame);
800046ee:	1a 9c       	mov	r12,sp
800046f0:	f0 1f 00 06 	mcall	80004708 <xnl_master_status_brdcst_func+0x5c>
}
800046f4:	2c 0d       	sub	sp,-256
800046f6:	e3 cd 80 80 	ldm	sp++,r7,pc
800046fa:	00 00       	add	r0,r0
800046fc:	00 00       	add	r0,r0
800046fe:	0b 2e       	ld.uh	lr,r5++
80004700:	00 00       	add	r0,r0
80004702:	0b 28       	ld.uh	r8,r5++
80004704:	80 00       	ld.sh	r0,r0[0x0]
80004706:	54 6c       	stdsp	sp[0x118],r12
80004708:	80 00       	ld.sh	r0,r0[0x0]
8000470a:	43 74       	lddsp	r4,sp[0xdc]

8000470c <xnl_device_conn_reply_func>:
Description: process while receive device conn reply.
Calls:xSemaphoreGive--freestos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_conn_reply_func(xnl_fragment_t * xnl)
{
8000470c:	eb cd 40 80 	pushm	r7,lr
80004710:	18 97       	mov	r7,r12
	transaction ID and an 8-byte encrypted value that the device can use to 
	authenticate the master. XCMP/XNL Development Guide 5.4.6
	*/
	
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);
80004712:	49 28       	lddpc	r8,80004758 <xnl_device_conn_reply_func+0x4c>
80004714:	70 0c       	ld.w	r12,r8[0x0]
80004716:	30 09       	mov	r9,0
80004718:	12 9a       	mov	r10,r9
8000471a:	12 9b       	mov	r11,r9
8000471c:	f0 1f 00 10 	mcall	8000475c <xnl_device_conn_reply_func+0x50>

	/*Test result code*/
	if((xnl->xnl_payload.xnl_content_device_conn_reply.result_base & 0x0000FF00)
80004720:	ef 18 00 10 	ld.uh	r8,r7[16]
80004724:	10 99       	mov	r9,r8
80004726:	e2 19 ff 00 	andl	r9,0xff00,COH
8000472a:	e0 49 01 00 	cp.w	r9,256
8000472e:	c0 60       	breq	8000473a <xnl_device_conn_reply_func+0x2e>
		/*
		Rejected. The device must retry the authentication process at this 
		point by sending out a new AUTH_KEY_REQUEST message. XCMP/XNL 
		Development Guide Section 5.2.3
		*/
		xnl_master_status_brdcst_func(xnl);			
80004730:	0e 9c       	mov	r12,r7
80004732:	f0 1f 00 0c 	mcall	80004760 <xnl_device_conn_reply_func+0x54>
80004736:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/*connection accepted*/		
		/*Record Transaction ID Base*/
		xnl_information.transaction_id =  
8000473a:	a9 68       	lsl	r8,0x8
8000473c:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
80004740:	48 98       	lddpc	r8,80004764 <xnl_device_conn_reply_func+0x58>
80004742:	b0 49       	st.h	r8[0x8],r9
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
80004744:	ef 09 00 14 	ld.sh	r9,r7[20]
		xnl_information.transaction_id =  
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
80004748:	b0 39       	st.h	r8[0x6],r9
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
8000474a:	ef 09 00 12 	ld.sh	r9,r7[18]
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
8000474e:	b0 29       	st.h	r8[0x4],r9
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
		
		/*connect finish*/
		xnl_information.is_connected = TRUE;
80004750:	30 19       	mov	r9,1
80004752:	b0 89       	st.b	r8[0x0],r9
80004754:	e3 cd 80 80 	ldm	sp++,r7,pc
80004758:	00 00       	add	r0,r0
8000475a:	0b 28       	ld.uh	r8,r5++
8000475c:	80 00       	ld.sh	r0,r0[0x0]
8000475e:	54 6c       	stdsp	sp[0x118],r12
80004760:	80 00       	ld.sh	r0,r0[0x0]
80004762:	46 ac       	lddsp	r12,sp[0x1a8]
80004764:	00 00       	add	r0,r0
80004766:	0b 2e       	ld.uh	lr,r5++

80004768 <local_start_pll0>:
	//pm_switch_to_osc0(pm, 12000000, 3);
	//    pm_enable_osc0_crystal(pm, 12000000);
	//         pm_set_osc0_mode(pm,AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);  0x00000007
	//    pm_enable_clk0(pm, 3);
	//         pm_enable_clk0_no_wait(pm, 3);
	(&AVR32_PM)->oscctrl0 = 0x00000307;
80004768:	fe 78 0c 00 	mov	r8,-62464
8000476c:	e0 69 03 07 	mov	r9,775
80004770:	91 a9       	st.w	r8[0x28],r9
	(&AVR32_PM)->mcctrl   = 0x00000004;
80004772:	30 49       	mov	r9,4
80004774:	91 09       	st.w	r8[0x0],r9
	//         pm_wait_for_clk0_ready(pm);
	while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
80004776:	71 59       	ld.w	r9,r8[0x54]
80004778:	e2 19 00 80 	andl	r9,0x80,COH
8000477c:	cf d0       	breq	80004776 <local_start_pll0+0xe>
	//    pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);
	(&AVR32_PM)->mcctrl   = 0x00000005;
8000477e:	fe 78 0c 00 	mov	r8,-62464
80004782:	30 59       	mov	r9,5
80004784:	91 09       	st.w	r8[0x0],r9
	//pm_pll_set_option(pm, 0, //PLL number 0
	//                        1, //freq Set to 1 for VCO frequency range 80-180MHz
	//                        1, //div2 Divide the PLL output frequency by 2
	//                        0);//0 to enable the Wide-Bandith Mode
	//pm_pll_enable(pm,0);
	(&AVR32_PM)->pll[0] = 0x1007010D;
80004786:	e0 69 01 0d 	mov	r9,269
8000478a:	ea 19 10 07 	orh	r9,0x1007
8000478e:	91 89       	st.w	r8[0x20],r9


	//pm_wait_for_pll0_locked(pm);
	while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_LOCK0_MASK));
80004790:	71 59       	ld.w	r9,r8[0x54]
80004792:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
80004796:	cf d0       	breq	80004790 <local_start_pll0+0x28>
	//             0,  //Bus A select = 0 (PBA clock = 48MHz/2 = 24MHz).
	//             0,  //B clock divisor enable = 0
	//             0,  //Bus B select = 0
	//             0,  //HS Bus clock divisor enable = 0
	//             0); //HS Bus select = 0
	(&AVR32_PM)->cksel = 0x00800000;
80004798:	fe 78 0c 00 	mov	r8,-62464
8000479c:	fc 19 00 80 	movh	r9,0x80
800047a0:	91 19       	st.w	r8[0x4],r9

	//flashc_set_wait_state(1);
	AVR32_FLASHC.fcr = 0x00000040;
800047a2:	34 0a       	mov	r10,64
800047a4:	fe 69 14 00 	mov	r9,-125952
800047a8:	93 0a       	st.w	r9[0x0],r10

	//pm_switch_to_clock(pm, AVR32_PM_MCSEL_PLL0);
	(&AVR32_PM)->mcctrl   = 0x00000006;
800047aa:	30 69       	mov	r9,6
800047ac:	91 09       	st.w	r8[0x0],r9


	AVR32_HMATRIX.mcfg[AVR32_HMATRIX_MASTER_CPU_INSTRUCTION] = 0x1;
800047ae:	30 19       	mov	r9,1
800047b0:	fe 68 10 00 	mov	r8,-126976
800047b4:	91 19       	st.w	r8[0x4],r9
}
800047b6:	5e fc       	retal	r12

800047b8 <local_start_timer>:
//	MAKO_RX					AVR32_SSC_RX_DATA_0_PIN				[39 PortB Pin  7 00000080 Func 0]
//
void local_start_timer(void)
{
	//Route CLK to Timer
	AVR32_GPIO.port[0].pmr0s = 0x00100000;
800047b8:	fe 78 10 00 	mov	r8,-61440
800047bc:	fc 19 00 10 	movh	r9,0x10
800047c0:	91 59       	st.w	r8[0x14],r9
	AVR32_GPIO.port[0].pmr1c = 0x00100000;
800047c2:	91 a9       	st.w	r8[0x28],r9
	AVR32_GPIO.port[0].gperc = 0x00100000;
800047c4:	91 29       	st.w	r8[0x8],r9
	//Route FS and Tri-State to Timer.
	AVR32_GPIO.port[1].pmr0c = 0x00000003;
800047c6:	30 39       	mov	r9,3
800047c8:	f1 49 01 18 	st.w	r8[280],r9
	AVR32_GPIO.port[1].pmr1c = 0x00000003;
800047cc:	f1 49 01 28 	st.w	r8[296],r9
	AVR32_GPIO.port[1].gperc = 0x00000003;
800047d0:	f1 49 01 08 	st.w	r8[264],r9

	(&AVR32_TC)->bmr = 4;
800047d4:	fe 78 38 00 	mov	r8,-51200
800047d8:	30 49       	mov	r9,4
800047da:	f1 49 00 c4 	st.w	r8[196],r9
	(&AVR32_TC)->channel[0].cmr =
800047de:	e0 69 91 0d 	mov	r9,37133
800047e2:	ea 19 00 52 	orh	r9,0x52
800047e6:	91 19       	st.w	r8[0x4],r9
	1                          << AVR32_TC_CLKI_OFFSET     |
	AVR32_TC_TCCLKS_XC0        << AVR32_TC_TCCLKS_OFFSET;



	(&AVR32_TC)->channel[0].ra = 32;
800047e8:	32 09       	mov	r9,32
800047ea:	91 59       	st.w	r8[0x14],r9
	(&AVR32_TC)->channel[0].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
800047ec:	30 59       	mov	r9,5
800047ee:	91 09       	st.w	r8[0x0],r9
}
800047f0:	5e fc       	retal	r12
800047f2:	d7 03       	nop

800047f4 <tc_init>:
 * - fPBA/8 is used as clock source for TC
 * - Enables RC compare match interrupt
 * \param tc Base address of the TC module
 */
void tc_init()
{
800047f4:	d4 01       	pushm	lr

	volatile avr32_tc_t * tc = EXAMPLE_TC;
	
	INTC_register_interrupt(&_tc_interrupt, AVR32_TC_IRQ1, AVR32_INTC_INT2);
800047f6:	30 2a       	mov	r10,2
800047f8:	e0 6b 01 c1 	mov	r11,449
800047fc:	48 ec       	lddpc	r12,80004834 <tc_init+0x40>
800047fe:	f0 1f 00 0f 	mcall	80004838 <tc_init+0x44>
		.cpas  = 0,
		.lovrs = 0,
		.covfs = 0
	};
	// Initialize the timer/counter.
	tc_init_waveform(tc, &waveform_opt);
80004802:	48 fb       	lddpc	r11,8000483c <tc_init+0x48>
80004804:	fe 7c 38 00 	mov	r12,-51200
80004808:	f0 1f 00 0e 	mcall	80004840 <tc_init+0x4c>
	 * We want: (1 / (fPBA / 8)) * RC = 10 ms, hence RC = (fPBA / 8) / 100
	 * to get an interrupt every 10 ms.
	 */
	//tc_write_rc(tc, EXAMPLE_TC_CHANNEL, (sysclk_get_pba_hz() / 8 / 100));
	
	tc_write_rc(tc, EXAMPLE_TC_CHANNEL, ((FOSC0*2) / 8 / 100));
8000480c:	e0 6a 75 30 	mov	r10,30000
80004810:	30 1b       	mov	r11,1
80004812:	fe 7c 38 00 	mov	r12,-51200
80004816:	f0 1f 00 0c 	mcall	80004844 <tc_init+0x50>
	
	//tc_write_rc(tc, EXAMPLE_TC_CHANNEL, (FOSC0 / 8 / 100000));
	
	
	// configure the timer interrupt
	tc_configure_interrupts(tc, EXAMPLE_TC_CHANNEL, &tc_interrupt);
8000481a:	48 ca       	lddpc	r10,80004848 <tc_init+0x54>
8000481c:	30 1b       	mov	r11,1
8000481e:	fe 7c 38 00 	mov	r12,-51200
80004822:	f0 1f 00 0b 	mcall	8000484c <tc_init+0x58>
	// Start the timer/counter.
	tc_start(tc, EXAMPLE_TC_CHANNEL);
80004826:	30 1b       	mov	r11,1
80004828:	fe 7c 38 00 	mov	r12,-51200
8000482c:	f0 1f 00 09 	mcall	80004850 <tc_init+0x5c>
80004830:	d8 02       	popm	pc
80004832:	00 00       	add	r0,r0
80004834:	80 00       	ld.sh	r0,r0[0x0]
80004836:	48 54       	lddpc	r4,80004848 <tc_init+0x54>
80004838:	80 00       	ld.sh	r0,r0[0x0]
8000483a:	48 78       	lddpc	r8,80004854 <_tc_interrupt>
8000483c:	80 00       	ld.sh	r0,r0[0x0]
8000483e:	c7 dc       	rcall	80004938 <INTC_init_interrupts+0x40>
80004840:	80 00       	ld.sh	r0,r0[0x0]
80004842:	49 84       	lddpc	r4,800048a0 <INTC_register_interrupt+0x28>
80004844:	80 00       	ld.sh	r0,r0[0x0]
80004846:	4a 44       	lddpc	r4,800048d4 <INTC_register_interrupt+0x5c>
80004848:	80 00       	ld.sh	r0,r0[0x0]
8000484a:	c7 d8       	rjmp	80004944 <INTC_init_interrupts+0x4c>
8000484c:	80 00       	ld.sh	r0,r0[0x0]
8000484e:	4a 78       	lddpc	r8,800048e8 <INTC_register_interrupt+0x70>
80004850:	80 00       	ld.sh	r0,r0[0x0]
80004852:	4a 20       	lddpc	r0,800048d8 <INTC_register_interrupt+0x60>

80004854 <_tc_interrupt>:
volatile U32 tc_tick = 0;

//brief Default interrupt handler.
__attribute__((__interrupt__))
static void _tc_interrupt(void)
 {
80004854:	d4 01       	pushm	lr
	// Increment the 10ms seconds counter
	tc_tick++;
80004856:	48 68       	lddpc	r8,8000486c <_tc_interrupt+0x18>
80004858:	70 09       	ld.w	r9,r8[0x0]
8000485a:	2f f9       	sub	r9,-1
8000485c:	91 09       	st.w	r8[0x0],r9
	/*
	 * TODO: Place a breakpoint here and watch the update of tc_tick variable
	 * in the Watch Window.
	 */
	// Clear the interrupt flag. This is a side effect of reading the TC SR.
	tc_read_sr(EXAMPLE_TC, EXAMPLE_TC_CHANNEL);
8000485e:	30 1b       	mov	r11,1
80004860:	fe 7c 38 00 	mov	r12,-51200
80004864:	f0 1f 00 03 	mcall	80004870 <_tc_interrupt+0x1c>
	
}
80004868:	d4 02       	popm	lr
8000486a:	d6 03       	rete
8000486c:	00 00       	add	r0,r0
8000486e:	0b 4c       	ld.w	r12,--r5
80004870:	80 00       	ld.sh	r0,r0[0x0]
80004872:	4a 32       	lddpc	r2,800048fc <INTC_init_interrupts+0x4>

80004874 <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
80004874:	c0 08       	rjmp	80004874 <_unhandled_interrupt>
80004876:	d7 03       	nop

80004878 <INTC_register_interrupt>:
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
80004878:	f6 08 16 05 	lsr	r8,r11,0x5

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
8000487c:	49 99       	lddpc	r9,800048e0 <INTC_register_interrupt+0x68>
8000487e:	f2 08 00 39 	add	r9,r9,r8<<0x3
80004882:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
80004886:	72 19       	ld.w	r9,r9[0x4]
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
80004888:	f2 0b 09 2c 	st.w	r9[r11<<0x2],r12
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
8000488c:	58 0a       	cp.w	r10,0
8000488e:	c0 91       	brne	800048a0 <INTC_register_interrupt+0x28>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80004890:	49 59       	lddpc	r9,800048e4 <INTC_register_interrupt+0x6c>
80004892:	49 6a       	lddpc	r10,800048e8 <INTC_register_interrupt+0x70>
80004894:	12 1a       	sub	r10,r9
80004896:	fe 79 08 00 	mov	r9,-63488
8000489a:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
8000489e:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT1) {
800048a0:	58 1a       	cp.w	r10,1
800048a2:	c0 a1       	brne	800048b6 <INTC_register_interrupt+0x3e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
800048a4:	49 09       	lddpc	r9,800048e4 <INTC_register_interrupt+0x6c>
800048a6:	49 2a       	lddpc	r10,800048ec <INTC_register_interrupt+0x74>
800048a8:	12 1a       	sub	r10,r9
800048aa:	bf aa       	sbr	r10,0x1e
800048ac:	fe 79 08 00 	mov	r9,-63488
800048b0:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800048b4:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT2) {
800048b6:	58 2a       	cp.w	r10,2
800048b8:	c0 a1       	brne	800048cc <INTC_register_interrupt+0x54>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
800048ba:	48 b9       	lddpc	r9,800048e4 <INTC_register_interrupt+0x6c>
800048bc:	48 da       	lddpc	r10,800048f0 <INTC_register_interrupt+0x78>
800048be:	12 1a       	sub	r10,r9
800048c0:	bf ba       	sbr	r10,0x1f
800048c2:	fe 79 08 00 	mov	r9,-63488
800048c6:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800048ca:	5e fc       	retal	r12
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
800048cc:	48 69       	lddpc	r9,800048e4 <INTC_register_interrupt+0x6c>
800048ce:	48 aa       	lddpc	r10,800048f4 <INTC_register_interrupt+0x7c>
800048d0:	12 1a       	sub	r10,r9
800048d2:	ea 1a c0 00 	orh	r10,0xc000
800048d6:	fe 79 08 00 	mov	r9,-63488
800048da:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800048de:	5e fc       	retal	r12
800048e0:	80 00       	ld.sh	r0,r0[0x0]
800048e2:	c7 e4       	brge	800049de <tc_init_waveform+0x5a>
800048e4:	80 00       	ld.sh	r0,r0[0x0]
800048e6:	be 00       	st.h	pc[0x0],r0
800048e8:	80 00       	ld.sh	r0,r0[0x0]
800048ea:	bf 04       	ld.d	r4,pc
800048ec:	80 00       	ld.sh	r0,r0[0x0]
800048ee:	bf 12       	ld.d	r2,--pc
800048f0:	80 00       	ld.sh	r0,r0[0x0]
800048f2:	bf 20       	st.d	pc++,r0
800048f4:	80 00       	ld.sh	r0,r0[0x0]
800048f6:	bf 2e       	st.d	pc++,lr

800048f8 <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
800048f8:	d4 21       	pushm	r4-r7,lr
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
800048fa:	49 18       	lddpc	r8,8000493c <INTC_init_interrupts+0x44>
800048fc:	e3 b8 00 01 	mtsr	0x4,r8
80004900:	49 0e       	lddpc	lr,80004940 <INTC_init_interrupts+0x48>
80004902:	30 07       	mov	r7,0
80004904:	0e 94       	mov	r4,r7
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80004906:	49 0c       	lddpc	r12,80004944 <INTC_init_interrupts+0x4c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80004908:	49 05       	lddpc	r5,80004948 <INTC_init_interrupts+0x50>
8000490a:	10 15       	sub	r5,r8
8000490c:	fe 76 08 00 	mov	r6,-63488
80004910:	c1 08       	rjmp	80004930 <INTC_init_interrupts+0x38>
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
80004912:	08 98       	mov	r8,r4
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
80004914:	7c 1b       	ld.w	r11,lr[0x4]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80004916:	7c 0a       	ld.w	r10,lr[0x0]
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80004918:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
8000491c:	2f f8       	sub	r8,-1

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
8000491e:	10 3a       	cp.w	r10,r8
80004920:	fe 9b ff fc 	brhi	80004918 <INTC_init_interrupts+0x20>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80004924:	ec 07 09 25 	st.w	r6[r7<<0x2],r5
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
80004928:	2f f7       	sub	r7,-1
8000492a:	2f 8e       	sub	lr,-8
8000492c:	59 37       	cp.w	r7,19
8000492e:	c0 50       	breq	80004938 <INTC_init_interrupts+0x40>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80004930:	7c 08       	ld.w	r8,lr[0x0]
80004932:	58 08       	cp.w	r8,0
80004934:	ce f1       	brne	80004912 <INTC_init_interrupts+0x1a>
80004936:	cf 7b       	rjmp	80004924 <INTC_init_interrupts+0x2c>
80004938:	d8 22       	popm	r4-r7,pc
8000493a:	00 00       	add	r0,r0
8000493c:	80 00       	ld.sh	r0,r0[0x0]
8000493e:	be 00       	st.h	pc[0x0],r0
80004940:	80 00       	ld.sh	r0,r0[0x0]
80004942:	c7 e4       	brge	80004a3e <tc_read_sr+0xc>
80004944:	80 00       	ld.sh	r0,r0[0x0]
80004946:	48 74       	lddpc	r4,80004960 <_get_interrupt_handler+0x14>
80004948:	80 00       	ld.sh	r0,r0[0x0]
8000494a:	bf 04       	ld.d	r4,pc

8000494c <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
8000494c:	fe 78 08 00 	mov	r8,-63488
80004950:	e0 69 00 83 	mov	r9,131
80004954:	f2 0c 01 0c 	sub	r12,r9,r12
80004958:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
8000495c:	f2 ca ff c0 	sub	r10,r9,-64
80004960:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	
	return (int_req)
80004964:	58 08       	cp.w	r8,0
80004966:	c0 21       	brne	8000496a <_get_interrupt_handler+0x1e>
80004968:	5e fd       	retal	0
		? _int_handler_table[int_grp]._int_line_handler_table[32
8000496a:	f0 08 12 00 	clz	r8,r8
8000496e:	48 5a       	lddpc	r10,80004980 <_get_interrupt_handler+0x34>
80004970:	f4 09 00 39 	add	r9,r10,r9<<0x3
80004974:	f0 08 11 1f 	rsub	r8,r8,31
80004978:	72 19       	ld.w	r9,r9[0x4]
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	
	return (int_req)
8000497a:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
8000497e:	5e fc       	retal	r12
80004980:	80 00       	ld.sh	r0,r0[0x0]
80004982:	c7 e4       	brge	80004a7e <tc_configure_interrupts+0x6>

80004984 <tc_init_waveform>:


int tc_init_waveform(volatile avr32_tc_t *tc, const tc_waveform_opt_t *opt)
{
  // Check for valid input.
  if (opt->channel >= TC_NUMBER_OF_CHANNELS)
80004984:	76 09       	ld.w	r9,r11[0x0]
80004986:	58 29       	cp.w	r9,2
80004988:	e0 88 00 03 	brls	8000498e <tc_init_waveform+0xa>
8000498c:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  // GENERATE SIGNALS: Waveform operating mode.
  tc->channel[opt->channel].cmr = opt->bswtrg << AVR32_TC_BSWTRG_OFFSET |
8000498e:	76 18       	ld.w	r8,r11[0x4]
80004990:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
80004994:	af ba       	sbr	r10,0xf
80004996:	10 9b       	mov	r11,r8
80004998:	e6 1b c0 00 	andh	r11,0xc000,COH
8000499c:	16 4a       	or	r10,r11
8000499e:	10 9b       	mov	r11,r8
800049a0:	e6 1b 30 00 	andh	r11,0x3000,COH
800049a4:	16 4a       	or	r10,r11
800049a6:	10 9b       	mov	r11,r8
800049a8:	e6 1b 0c 00 	andh	r11,0xc00,COH
800049ac:	16 4a       	or	r10,r11
800049ae:	10 9b       	mov	r11,r8
800049b0:	e6 1b 03 00 	andh	r11,0x300,COH
800049b4:	16 4a       	or	r10,r11
800049b6:	10 9b       	mov	r11,r8
800049b8:	e6 1b 00 c0 	andh	r11,0xc0,COH
800049bc:	16 4a       	or	r10,r11
800049be:	10 9b       	mov	r11,r8
800049c0:	e6 1b 00 30 	andh	r11,0x30,COH
800049c4:	16 4a       	or	r10,r11
800049c6:	10 9b       	mov	r11,r8
800049c8:	e6 1b 00 0c 	andh	r11,0xc,COH
800049cc:	16 4a       	or	r10,r11
800049ce:	10 9b       	mov	r11,r8
800049d0:	e6 1b 00 03 	andh	r11,0x3,COH
800049d4:	16 4a       	or	r10,r11
800049d6:	10 9b       	mov	r11,r8
800049d8:	e2 1b 60 00 	andl	r11,0x6000,COH
800049dc:	16 4a       	or	r10,r11
800049de:	f7 d8 c1 81 	bfextu	r11,r8,0xc,0x1
800049e2:	f5 eb 10 ca 	or	r10,r10,r11<<0xc
800049e6:	10 9b       	mov	r11,r8
800049e8:	e2 1b 0c 00 	andl	r11,0xc00,COH
800049ec:	16 4a       	or	r10,r11
800049ee:	10 9b       	mov	r11,r8
800049f0:	e2 1b 03 00 	andl	r11,0x300,COH
800049f4:	16 4a       	or	r10,r11
800049f6:	f7 d8 c0 e1 	bfextu	r11,r8,0x7,0x1
800049fa:	f5 eb 10 7a 	or	r10,r10,r11<<0x7
800049fe:	f7 d8 c0 c1 	bfextu	r11,r8,0x6,0x1
80004a02:	f5 eb 10 6a 	or	r10,r10,r11<<0x6
80004a06:	10 9b       	mov	r11,r8
80004a08:	e2 1b 00 30 	andl	r11,0x30,COH
80004a0c:	16 4a       	or	r10,r11
80004a0e:	f1 d8 c0 61 	bfextu	r8,r8,0x3,0x1
80004a12:	f5 e8 10 38 	or	r8,r10,r8<<0x3
80004a16:	a5 69       	lsl	r9,0x4
80004a18:	2f f9       	sub	r9,-1
80004a1a:	f8 09 09 28 	st.w	r12[r9<<0x2],r8
80004a1e:	5e fd       	retal	0

80004a20 <tc_start>:


int tc_start(volatile avr32_tc_t *tc, unsigned int channel)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80004a20:	58 2b       	cp.w	r11,2
80004a22:	e0 88 00 03 	brls	80004a28 <tc_start+0x8>
80004a26:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  // Enable, reset and start the selected timer/counter channel.
  tc->channel[channel].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
80004a28:	a7 6b       	lsl	r11,0x6
80004a2a:	16 0c       	add	r12,r11
80004a2c:	30 58       	mov	r8,5
80004a2e:	99 08       	st.w	r12[0x0],r8
80004a30:	5e fd       	retal	0

80004a32 <tc_read_sr>:


int tc_read_sr(volatile avr32_tc_t *tc, unsigned int channel)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80004a32:	58 2b       	cp.w	r11,2
80004a34:	e0 88 00 03 	brls	80004a3a <tc_read_sr+0x8>
80004a38:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  return tc->channel[channel].sr;
80004a3a:	a7 6b       	lsl	r11,0x6
80004a3c:	2e 0b       	sub	r11,-32
80004a3e:	16 0c       	add	r12,r11
80004a40:	78 0c       	ld.w	r12,r12[0x0]
}
80004a42:	5e fc       	retal	r12

80004a44 <tc_write_rc>:


int tc_write_rc(volatile avr32_tc_t *tc, unsigned int channel, unsigned short value)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80004a44:	58 2b       	cp.w	r11,2
80004a46:	e0 88 00 03 	brls	80004a4c <tc_write_rc+0x8>
80004a4a:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  // This function is only available in WAVEFORM mode.
  if (Tst_bits(tc->channel[channel].cmr, AVR32_TC_WAVE_MASK))
80004a4c:	f6 08 15 04 	lsl	r8,r11,0x4
80004a50:	2f f8       	sub	r8,-1
80004a52:	f8 08 03 28 	ld.w	r8,r12[r8<<0x2]
80004a56:	e2 18 80 00 	andl	r8,0x8000,COH
80004a5a:	c0 c0       	breq	80004a72 <tc_write_rc+0x2e>
    Wr_bitfield(tc->channel[channel].rc, AVR32_TC_RC_MASK, value);
80004a5c:	a7 6b       	lsl	r11,0x6
80004a5e:	16 0c       	add	r12,r11
80004a60:	2e 4c       	sub	r12,-28
80004a62:	78 08       	ld.w	r8,r12[0x0]
80004a64:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
80004a68:	e0 18 00 00 	andl	r8,0x0
80004a6c:	f3 e8 10 08 	or	r8,r9,r8
80004a70:	99 08       	st.w	r12[0x0],r8

  return value;
80004a72:	f9 da c0 10 	bfextu	r12,r10,0x0,0x10
}
80004a76:	5e fc       	retal	r12

80004a78 <tc_configure_interrupts>:
  return tc->channel[channel].imr;
}


int tc_configure_interrupts(volatile avr32_tc_t *tc, unsigned int channel, const tc_interrupt_t *bitfield)
{
80004a78:	eb cd 40 fc 	pushm	r2-r7,lr
  bool global_interrupt_enabled = Is_global_interrupt_enabled();
80004a7c:	e1 b9 00 00 	mfsr	r9,0x0

  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80004a80:	58 2b       	cp.w	r11,2
80004a82:	e0 88 00 04 	brls	80004a8a <tc_configure_interrupts+0x12>
80004a86:	e3 cf c0 fc 	ldm	sp++,r2-r7,pc,r12=-1
	return flags;
}

static inline bool cpu_irq_is_enabled_flags(irqflags_t flags)
{
	return !(flags & AVR32_SR_GM_MASK);
80004a8a:	ee 19 00 01 	eorh	r9,0x1
80004a8e:	f3 d9 c2 01 	bfextu	r9,r9,0x10,0x1
    return TC_INVALID_ARGUMENT;

  // Enable the appropriate interrupts.
  tc->channel[channel].ier = bitfield->etrgs << AVR32_TC_ETRGS_OFFSET |
80004a92:	74 08       	ld.w	r8,r10[0x0]
80004a94:	ef d8 c0 e1 	bfextu	r7,r8,0x7,0x1
80004a98:	fd d8 c0 c1 	bfextu	lr,r8,0x6,0x1
80004a9c:	a7 6e       	lsl	lr,0x6
80004a9e:	fd e7 10 7e 	or	lr,lr,r7<<0x7
80004aa2:	ef d8 c0 01 	bfextu	r7,r8,0x0,0x1
80004aa6:	0e 4e       	or	lr,r7
80004aa8:	ef d8 c0 a1 	bfextu	r7,r8,0x5,0x1
80004aac:	fd e7 10 5e 	or	lr,lr,r7<<0x5
80004ab0:	ef d8 c0 81 	bfextu	r7,r8,0x4,0x1
80004ab4:	fd e7 10 4e 	or	lr,lr,r7<<0x4
80004ab8:	ef d8 c0 61 	bfextu	r7,r8,0x3,0x1
80004abc:	fd e7 10 3e 	or	lr,lr,r7<<0x3
80004ac0:	ef d8 c0 41 	bfextu	r7,r8,0x2,0x1
80004ac4:	fd e7 10 2e 	or	lr,lr,r7<<0x2
80004ac8:	f1 d8 c0 21 	bfextu	r8,r8,0x1,0x1
80004acc:	fd e8 10 18 	or	r8,lr,r8<<0x1
80004ad0:	f6 0e 15 06 	lsl	lr,r11,0x6
80004ad4:	f8 0e 00 0e 	add	lr,r12,lr
80004ad8:	2d ce       	sub	lr,-36
80004ada:	9d 08       	st.w	lr[0x0],r8
                             bitfield->cpas << AVR32_TC_CPAS_OFFSET |
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;

  // Disable the appropriate interrupts.
  if (global_interrupt_enabled) Disable_global_interrupt();
80004adc:	58 09       	cp.w	r9,0
80004ade:	c0 20       	breq	80004ae2 <tc_configure_interrupts+0x6a>
80004ae0:	d3 03       	ssrf	0x10
  tc->channel[channel].idr = (~bitfield->etrgs & 1) << AVR32_TC_ETRGS_OFFSET |
80004ae2:	74 08       	ld.w	r8,r10[0x0]
80004ae4:	f1 d8 c0 e1 	bfextu	r8,r8,0x7,0x1
80004ae8:	e0 65 00 80 	mov	r5,128
80004aec:	f9 b5 01 00 	movne	r5,0
                             (~bitfield->ldrbs & 1) << AVR32_TC_LDRBS_OFFSET |
80004af0:	74 08       	ld.w	r8,r10[0x0]
80004af2:	f1 d8 c0 c1 	bfextu	r8,r8,0x6,0x1
80004af6:	f9 b4 00 40 	moveq	r4,64
80004afa:	f9 b4 01 00 	movne	r4,0
                             (~bitfield->ldras & 1) << AVR32_TC_LDRAS_OFFSET |
80004afe:	74 08       	ld.w	r8,r10[0x0]
80004b00:	f1 d8 c0 a1 	bfextu	r8,r8,0x5,0x1
80004b04:	f9 b3 00 20 	moveq	r3,32
80004b08:	f9 b3 01 00 	movne	r3,0
                             (~bitfield->cpcs & 1) << AVR32_TC_CPCS_OFFSET |
80004b0c:	74 08       	ld.w	r8,r10[0x0]
80004b0e:	f1 d8 c0 81 	bfextu	r8,r8,0x4,0x1
80004b12:	f9 b2 00 10 	moveq	r2,16
80004b16:	f9 b2 01 00 	movne	r2,0
                             (~bitfield->cpbs & 1) << AVR32_TC_CPBS_OFFSET |
80004b1a:	74 08       	ld.w	r8,r10[0x0]
80004b1c:	f1 d8 c0 61 	bfextu	r8,r8,0x3,0x1
80004b20:	f9 b6 00 08 	moveq	r6,8
80004b24:	f9 b6 01 00 	movne	r6,0
                             (~bitfield->cpas & 1) << AVR32_TC_CPAS_OFFSET |
80004b28:	74 08       	ld.w	r8,r10[0x0]
80004b2a:	f1 d8 c0 41 	bfextu	r8,r8,0x2,0x1
80004b2e:	f9 b7 00 04 	moveq	r7,4
80004b32:	f9 b7 01 00 	movne	r7,0
                             (~bitfield->lovrs & 1) << AVR32_TC_LOVRS_OFFSET |
80004b36:	74 08       	ld.w	r8,r10[0x0]
80004b38:	f1 d8 c0 21 	bfextu	r8,r8,0x1,0x1
80004b3c:	f9 be 00 02 	moveq	lr,2
80004b40:	f9 be 01 00 	movne	lr,0
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;

  // Disable the appropriate interrupts.
  if (global_interrupt_enabled) Disable_global_interrupt();
  tc->channel[channel].idr = (~bitfield->etrgs & 1) << AVR32_TC_ETRGS_OFFSET |
80004b44:	74 08       	ld.w	r8,r10[0x0]
80004b46:	ec 18 00 01 	eorl	r8,0x1
80004b4a:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80004b4e:	eb e8 10 08 	or	r8,r5,r8
80004b52:	08 48       	or	r8,r4
80004b54:	06 48       	or	r8,r3
80004b56:	04 48       	or	r8,r2
80004b58:	0c 48       	or	r8,r6
80004b5a:	0e 48       	or	r8,r7
80004b5c:	1c 48       	or	r8,lr
80004b5e:	f6 0a 15 06 	lsl	r10,r11,0x6
80004b62:	f8 0a 00 0a 	add	r10,r12,r10
80004b66:	2d 8a       	sub	r10,-40
80004b68:	95 08       	st.w	r10[0x0],r8
                             (~bitfield->cpcs & 1) << AVR32_TC_CPCS_OFFSET |
                             (~bitfield->cpbs & 1) << AVR32_TC_CPBS_OFFSET |
                             (~bitfield->cpas & 1) << AVR32_TC_CPAS_OFFSET |
                             (~bitfield->lovrs & 1) << AVR32_TC_LOVRS_OFFSET |
                             (~bitfield->covfs & 1) << AVR32_TC_COVFS_OFFSET;
  tc->channel[channel].sr;
80004b6a:	a7 6b       	lsl	r11,0x6
80004b6c:	2e 0b       	sub	r11,-32
80004b6e:	16 0c       	add	r12,r11
80004b70:	78 08       	ld.w	r8,r12[0x0]
  if (global_interrupt_enabled) Enable_global_interrupt();
80004b72:	58 09       	cp.w	r9,0
80004b74:	c0 31       	brne	80004b7a <tc_configure_interrupts+0x102>
80004b76:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0
80004b7a:	d5 03       	csrf	0x10
80004b7c:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0

80004b80 <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
80004b80:	d4 01       	pushm	lr
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
80004b82:	f6 08 15 04 	lsl	r8,r11,0x4
80004b86:	14 38       	cp.w	r8,r10
80004b88:	f9 b8 08 10 	movls	r8,16
80004b8c:	f9 b8 0b 08 	movhi	r8,8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
80004b90:	f0 0b 02 4b 	mul	r11,r8,r11
80004b94:	f6 09 16 01 	lsr	r9,r11,0x1
80004b98:	f2 0a 00 3a 	add	r10,r9,r10<<0x3
80004b9c:	f4 0b 0d 0a 	divu	r10,r10,r11
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
80004ba0:	f4 09 16 03 	lsr	r9,r10,0x3
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
80004ba4:	f2 cb 00 01 	sub	r11,r9,1
80004ba8:	e0 4b ff fe 	cp.w	r11,65534
80004bac:	e0 88 00 03 	brls	80004bb2 <usart_set_async_baudrate+0x32>
80004bb0:	da 0a       	popm	pc,r12=1
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
80004bb2:	78 1b       	ld.w	r11,r12[0x4]
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
80004bb4:	e8 6e 00 00 	mov	lr,524288
80004bb8:	59 08       	cp.w	r8,16
80004bba:	fc 08 17 10 	movne	r8,lr
80004bbe:	f9 b8 00 00 	moveq	r8,0
80004bc2:	e4 1b ff f7 	andh	r11,0xfff7
80004bc6:	e0 1b fe cf 	andl	r11,0xfecf
80004bca:	16 48       	or	r8,r11
80004bcc:	99 18       	st.w	r12[0x4],r8
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
80004bce:	f5 da c0 03 	bfextu	r10,r10,0x0,0x3
80004bd2:	f3 ea 11 09 	or	r9,r9,r10<<0x10
80004bd6:	99 89       	st.w	r12[0x20],r9
80004bd8:	d8 0a       	popm	pc,r12=0

80004bda <usart_write_char>:
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
80004bda:	78 58       	ld.w	r8,r12[0x14]
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
  if (usart_tx_ready(usart))
80004bdc:	e2 18 00 02 	andl	r8,0x2,COH
80004be0:	c0 31       	brne	80004be6 <usart_write_char+0xc>
80004be2:	30 2c       	mov	r12,2
80004be4:	5e fc       	retal	r12
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
80004be6:	f7 db c0 09 	bfextu	r11,r11,0x0,0x9
80004bea:	99 7b       	st.w	r12[0x1c],r11
80004bec:	5e fd       	retal	0
80004bee:	d7 03       	nop

80004bf0 <usart_putchar>:
    return USART_TX_BUSY;
}


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
80004bf0:	eb cd 40 e0 	pushm	r5-r7,lr
80004bf4:	18 96       	mov	r6,r12
80004bf6:	16 95       	mov	r5,r11
80004bf8:	e0 67 27 0f 	mov	r7,9999
80004bfc:	c0 68       	rjmp	80004c08 <usart_putchar+0x18>
  int timeout = USART_DEFAULT_TIMEOUT;

  do
  {
    if (!timeout--) return USART_FAILURE;
80004bfe:	58 07       	cp.w	r7,0
80004c00:	c0 31       	brne	80004c06 <usart_putchar+0x16>
80004c02:	e3 cf c0 e0 	ldm	sp++,r5-r7,pc,r12=-1
80004c06:	20 17       	sub	r7,1
  } while (usart_write_char(usart, c) != USART_SUCCESS);
80004c08:	0a 9b       	mov	r11,r5
80004c0a:	0c 9c       	mov	r12,r6
80004c0c:	f0 1f 00 03 	mcall	80004c18 <usart_putchar+0x28>
80004c10:	cf 71       	brne	80004bfe <usart_putchar+0xe>

  return USART_SUCCESS;
}
80004c12:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80004c16:	00 00       	add	r0,r0
80004c18:	80 00       	ld.sh	r0,r0[0x0]
80004c1a:	4b da       	lddpc	r10,80004d0c <usart_init_rs232+0x50>

80004c1c <usart_read_char>:

int usart_read_char(volatile avr32_usart_t *usart, int *c)
{
  // Check for errors: frame, parity and overrun. In RS485 mode, a parity error
  // would mean that an address char has been received.
  if (usart->csr & (AVR32_USART_CSR_OVRE_MASK |
80004c1c:	78 58       	ld.w	r8,r12[0x14]
80004c1e:	e2 18 00 e0 	andl	r8,0xe0,COH
80004c22:	c0 30       	breq	80004c28 <usart_read_char+0xc>
80004c24:	30 4c       	mov	r12,4
80004c26:	5e fc       	retal	r12
 *
 * \return \c 1 if the USART Receive Holding Register is full, otherwise \c 0.
 */
__always_inline static int usart_test_hit(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_RXRDY_MASK) != 0;
80004c28:	78 58       	ld.w	r8,r12[0x14]
                    AVR32_USART_CSR_FRAME_MASK |
                    AVR32_USART_CSR_PARE_MASK))
    return USART_RX_ERROR;

  // No error; if we really did receive a char, read it and return SUCCESS.
  if (usart_test_hit(usart))
80004c2a:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80004c2e:	c0 31       	brne	80004c34 <usart_read_char+0x18>
80004c30:	30 3c       	mov	r12,3
80004c32:	5e fc       	retal	r12
  {
    *c = (usart->rhr & AVR32_USART_RHR_RXCHR_MASK) >> AVR32_USART_RHR_RXCHR_OFFSET;
80004c34:	78 68       	ld.w	r8,r12[0x18]
80004c36:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
80004c3a:	97 08       	st.w	r11[0x0],r8
80004c3c:	5e fd       	retal	0
80004c3e:	d7 03       	nop

80004c40 <usart_getchar>:
    return USART_RX_EMPTY;
}


int usart_getchar(volatile avr32_usart_t *usart)
{
80004c40:	eb cd 40 c0 	pushm	r6-r7,lr
80004c44:	20 1d       	sub	sp,4
80004c46:	18 96       	mov	r6,r12
  int c, ret;

  while ((ret = usart_read_char(usart, &c)) == USART_RX_EMPTY);
80004c48:	1a 97       	mov	r7,sp
80004c4a:	1a 9b       	mov	r11,sp
80004c4c:	0c 9c       	mov	r12,r6
80004c4e:	f0 1f 00 07 	mcall	80004c68 <usart_getchar+0x28>
80004c52:	58 3c       	cp.w	r12,3
80004c54:	cf b0       	breq	80004c4a <usart_getchar+0xa>

  if (ret == USART_RX_ERROR)
80004c56:	58 4c       	cp.w	r12,4
80004c58:	f9 bc 00 ff 	moveq	r12,-1
    return USART_FAILURE;

  return c;
80004c5c:	fb fc 10 00 	ld.wne	r12,sp[0x0]
}
80004c60:	2f fd       	sub	sp,-4
80004c62:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004c66:	00 00       	add	r0,r0
80004c68:	80 00       	ld.sh	r0,r0[0x0]
80004c6a:	4c 1c       	lddpc	r12,80004d6c <usart_init_rs232+0xb0>

80004c6c <usart_write_line>:


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
80004c6c:	eb cd 40 c0 	pushm	r6-r7,lr
80004c70:	18 96       	mov	r6,r12
80004c72:	16 97       	mov	r7,r11
  while (*string != '\0')
80004c74:	17 8b       	ld.ub	r11,r11[0x0]
80004c76:	58 0b       	cp.w	r11,0
80004c78:	c0 80       	breq	80004c88 <usart_write_line+0x1c>
    usart_putchar(usart, *string++);
80004c7a:	2f f7       	sub	r7,-1
80004c7c:	0c 9c       	mov	r12,r6
80004c7e:	f0 1f 00 04 	mcall	80004c8c <usart_write_line+0x20>
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
80004c82:	0f 8b       	ld.ub	r11,r7[0x0]
80004c84:	58 0b       	cp.w	r11,0
80004c86:	cf a1       	brne	80004c7a <usart_write_line+0xe>
80004c88:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004c8c:	80 00       	ld.sh	r0,r0[0x0]
80004c8e:	4b f0       	lddpc	r0,80004d88 <vListInitialise>

80004c90 <usart_reset>:
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
80004c90:	e1 b8 00 00 	mfsr	r8,0x0

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
80004c94:	e6 18 00 01 	andh	r8,0x1,COH
80004c98:	c0 71       	brne	80004ca6 <usart_reset+0x16>
80004c9a:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
80004c9c:	3f f8       	mov	r8,-1
80004c9e:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80004ca0:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
80004ca2:	d5 03       	csrf	0x10
80004ca4:	c0 48       	rjmp	80004cac <usart_reset+0x1c>
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
  usart->idr = 0xFFFFFFFF;
80004ca6:	3f f8       	mov	r8,-1
80004ca8:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80004caa:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
80004cac:	30 08       	mov	r8,0
80004cae:	99 18       	st.w	r12[0x4],r8
  usart->rtor = 0;
80004cb0:	99 98       	st.w	r12[0x24],r8
  usart->ttgr = 0;
80004cb2:	99 a8       	st.w	r12[0x28],r8

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
80004cb4:	ea 68 61 0c 	mov	r8,680204
80004cb8:	99 08       	st.w	r12[0x0],r8
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
80004cba:	5e fc       	retal	r12

80004cbc <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
80004cbc:	eb cd 40 e0 	pushm	r5-r7,lr
80004cc0:	18 96       	mov	r6,r12
80004cc2:	16 97       	mov	r7,r11
80004cc4:	14 95       	mov	r5,r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
80004cc6:	f0 1f 00 2f 	mcall	80004d80 <usart_init_rs232+0xc4>

  // Check input values.
  if (!opt || // Null pointer.
80004cca:	58 07       	cp.w	r7,0
80004ccc:	c5 80       	breq	80004d7c <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
80004cce:	0f c8       	ld.ub	r8,r7[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80004cd0:	30 49       	mov	r9,4
80004cd2:	f2 08 18 00 	cp.b	r8,r9
80004cd6:	e0 88 00 53 	brls	80004d7c <usart_init_rs232+0xc0>
80004cda:	30 99       	mov	r9,9
80004cdc:	f2 08 18 00 	cp.b	r8,r9
80004ce0:	e0 8b 00 4e 	brhi	80004d7c <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
80004ce4:	0f d9       	ld.ub	r9,r7[0x5]
80004ce6:	30 78       	mov	r8,7
80004ce8:	f0 09 18 00 	cp.b	r9,r8
80004cec:	e0 8b 00 48 	brhi	80004d7c <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
80004cf0:	8e 39       	ld.sh	r9,r7[0x6]
80004cf2:	e0 68 01 01 	mov	r8,257
80004cf6:	f0 09 19 00 	cp.h	r9,r8
80004cfa:	e0 8b 00 41 	brhi	80004d7c <usart_init_rs232+0xc0>
      opt->channelmode > 3 ||
80004cfe:	ef 39 00 08 	ld.ub	r9,r7[8]
80004d02:	30 38       	mov	r8,3
80004d04:	f0 09 18 00 	cp.b	r9,r8
80004d08:	e0 8b 00 3a 	brhi	80004d7c <usart_init_rs232+0xc0>
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
80004d0c:	0a 9a       	mov	r10,r5
80004d0e:	6e 0b       	ld.w	r11,r7[0x0]
80004d10:	0c 9c       	mov	r12,r6
80004d12:	f0 1f 00 1d 	mcall	80004d84 <usart_init_rs232+0xc8>
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80004d16:	58 1c       	cp.w	r12,1
80004d18:	c3 20       	breq	80004d7c <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;

  if (opt->charlength == 9)
80004d1a:	0f c8       	ld.ub	r8,r7[0x4]
80004d1c:	30 99       	mov	r9,9
80004d1e:	f2 08 18 00 	cp.b	r8,r9
80004d22:	c0 51       	brne	80004d2c <usart_init_rs232+0x70>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
80004d24:	6c 18       	ld.w	r8,r6[0x4]
80004d26:	b1 b8       	sbr	r8,0x11
80004d28:	8d 18       	st.w	r6[0x4],r8
80004d2a:	c0 68       	rjmp	80004d36 <usart_init_rs232+0x7a>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
80004d2c:	6c 19       	ld.w	r9,r6[0x4]
80004d2e:	20 58       	sub	r8,5
80004d30:	f3 e8 10 68 	or	r8,r9,r8<<0x6
80004d34:	8d 18       	st.w	r6[0x4],r8
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
80004d36:	6c 19       	ld.w	r9,r6[0x4]
80004d38:	ef 3a 00 08 	ld.ub	r10,r7[8]
80004d3c:	0f d8       	ld.ub	r8,r7[0x5]
80004d3e:	a9 78       	lsl	r8,0x9
80004d40:	f1 ea 10 e8 	or	r8,r8,r10<<0xe
80004d44:	12 48       	or	r8,r9
80004d46:	8d 18       	st.w	r6[0x4],r8
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
80004d48:	8e 38       	ld.sh	r8,r7[0x6]
80004d4a:	30 29       	mov	r9,2
80004d4c:	f2 08 19 00 	cp.h	r8,r9
80004d50:	e0 88 00 09 	brls	80004d62 <usart_init_rs232+0xa6>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
80004d54:	6c 18       	ld.w	r8,r6[0x4]
80004d56:	ad b8       	sbr	r8,0xd
80004d58:	8d 18       	st.w	r6[0x4],r8
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
80004d5a:	8e b8       	ld.uh	r8,r7[0x6]
80004d5c:	20 28       	sub	r8,2
80004d5e:	8d a8       	st.w	r6[0x28],r8
80004d60:	c0 68       	rjmp	80004d6c <usart_init_rs232+0xb0>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
80004d62:	6c 19       	ld.w	r9,r6[0x4]
80004d64:	5c 78       	castu.h	r8
80004d66:	f3 e8 10 c8 	or	r8,r9,r8<<0xc
80004d6a:	8d 18       	st.w	r6[0x4],r8

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
80004d6c:	6c 18       	ld.w	r8,r6[0x4]
80004d6e:	e0 18 ff f0 	andl	r8,0xfff0
80004d72:	8d 18       	st.w	r6[0x4],r8
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
80004d74:	35 08       	mov	r8,80
80004d76:	8d 08       	st.w	r6[0x0],r8
80004d78:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
80004d7c:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
80004d80:	80 00       	ld.sh	r0,r0[0x0]
80004d82:	4c 90       	lddpc	r0,80004ea4 <pxPortInitialiseStack+0x8c>
80004d84:	80 00       	ld.sh	r0,r0[0x0]
80004d86:	4b 80       	lddpc	r0,80004e64 <pxPortInitialiseStack+0x4c>

80004d88 <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
80004d88:	f8 c8 ff f8 	sub	r8,r12,-8
80004d8c:	99 18       	st.w	r12[0x4],r8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
80004d8e:	3f f9       	mov	r9,-1
80004d90:	99 29       	st.w	r12[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
80004d92:	99 38       	st.w	r12[0xc],r8
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
80004d94:	99 48       	st.w	r12[0x10],r8

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
80004d96:	30 08       	mov	r8,0
80004d98:	99 08       	st.w	r12[0x0],r8
}
80004d9a:	5e fc       	retal	r12

80004d9c <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
80004d9c:	30 08       	mov	r8,0
80004d9e:	99 48       	st.w	r12[0x10],r8
}
80004da0:	5e fc       	retal	r12

80004da2 <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
80004da2:	78 18       	ld.w	r8,r12[0x4]

	pxNewListItem->pxNext = pxIndex->pxNext;
80004da4:	70 19       	ld.w	r9,r8[0x4]
80004da6:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
80004da8:	78 19       	ld.w	r9,r12[0x4]
80004daa:	97 29       	st.w	r11[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80004dac:	70 19       	ld.w	r9,r8[0x4]
80004dae:	93 2b       	st.w	r9[0x8],r11
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
80004db0:	91 1b       	st.w	r8[0x4],r11
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
80004db2:	99 1b       	st.w	r12[0x4],r11

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80004db4:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80004db6:	78 08       	ld.w	r8,r12[0x0]
80004db8:	2f f8       	sub	r8,-1
80004dba:	99 08       	st.w	r12[0x0],r8
}
80004dbc:	5e fc       	retal	r12

80004dbe <vListInsert>:
{
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
80004dbe:	76 0a       	ld.w	r10,r11[0x0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
80004dc0:	5b fa       	cp.w	r10,-1
80004dc2:	c0 31       	brne	80004dc8 <vListInsert+0xa>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
80004dc4:	78 48       	ld.w	r8,r12[0x10]
80004dc6:	c0 c8       	rjmp	80004dde <vListInsert+0x20>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
80004dc8:	f8 c8 ff f8 	sub	r8,r12,-8
80004dcc:	70 19       	ld.w	r9,r8[0x4]
80004dce:	72 09       	ld.w	r9,r9[0x0]
80004dd0:	12 3a       	cp.w	r10,r9
80004dd2:	c0 63       	brcs	80004dde <vListInsert+0x20>
80004dd4:	70 18       	ld.w	r8,r8[0x4]
80004dd6:	70 19       	ld.w	r9,r8[0x4]
80004dd8:	72 09       	ld.w	r9,r9[0x0]
80004dda:	12 3a       	cp.w	r10,r9
80004ddc:	cf c2       	brcc	80004dd4 <vListInsert+0x16>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
80004dde:	70 19       	ld.w	r9,r8[0x4]
80004de0:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80004de2:	93 2b       	st.w	r9[0x8],r11
	pxNewListItem->pxPrevious = pxIterator;
80004de4:	97 28       	st.w	r11[0x8],r8
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
80004de6:	91 1b       	st.w	r8[0x4],r11

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80004de8:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80004dea:	78 08       	ld.w	r8,r12[0x0]
80004dec:	2f f8       	sub	r8,-1
80004dee:	99 08       	st.w	r12[0x0],r8
}
80004df0:	5e fc       	retal	r12

80004df2 <vListRemove>:

void vListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
80004df2:	78 18       	ld.w	r8,r12[0x4]
80004df4:	78 29       	ld.w	r9,r12[0x8]
80004df6:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
80004df8:	78 28       	ld.w	r8,r12[0x8]
80004dfa:	78 19       	ld.w	r9,r12[0x4]
80004dfc:	91 19       	st.w	r8[0x4],r9

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
80004dfe:	78 48       	ld.w	r8,r12[0x10]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
80004e00:	70 19       	ld.w	r9,r8[0x4]
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
80004e02:	18 39       	cp.w	r9,r12
80004e04:	f9 f9 00 02 	ld.weq	r9,r12[0x8]
80004e08:	f1 f9 0a 01 	st.weq	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
80004e0c:	30 09       	mov	r9,0
80004e0e:	99 49       	st.w	r12[0x10],r9
	( pxList->uxNumberOfItems )--;
80004e10:	70 09       	ld.w	r9,r8[0x0]
80004e12:	20 19       	sub	r9,1
80004e14:	91 09       	st.w	r8[0x0],r9
}
80004e16:	5e fc       	retal	r12

80004e18 <pxPortInitialiseStack>:
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x08080808;					/* R8 */
80004e18:	e0 68 08 08 	mov	r8,2056
80004e1c:	ea 18 08 08 	orh	r8,0x808
80004e20:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x09090909;					/* R9 */
80004e22:	e0 68 09 09 	mov	r8,2313
80004e26:	ea 18 09 09 	orh	r8,0x909
80004e2a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0A0A0A0A;					/* R10 */
80004e2c:	e0 68 0a 0a 	mov	r8,2570
80004e30:	ea 18 0a 0a 	orh	r8,0xa0a
80004e34:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0B0B0B0B;					/* R11 */
80004e36:	e0 68 0b 0b 	mov	r8,2827
80004e3a:	ea 18 0b 0b 	orh	r8,0xb0b
80004e3e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pvParameters;					/* R12 */
80004e40:	18 da       	st.w	--r12,r10
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xDEADBEEF;					/* R14/LR */
80004e42:	e0 68 be ef 	mov	r8,48879
80004e46:	ea 18 de ad 	orh	r8,0xdead
80004e4a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
80004e4c:	18 db       	st.w	--r12,r11
	*pxTopOfStack-- = ( portSTACK_TYPE ) portINITIAL_SR;				/* SR */
80004e4e:	fc 18 00 40 	movh	r8,0x40
80004e52:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xFF0000FF;					/* R0 */
80004e54:	e0 68 00 ff 	mov	r8,255
80004e58:	ea 18 ff 00 	orh	r8,0xff00
80004e5c:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x01010101;					/* R1 */
80004e5e:	e0 68 01 01 	mov	r8,257
80004e62:	ea 18 01 01 	orh	r8,0x101
80004e66:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x02020202;					/* R2 */
80004e68:	e0 68 02 02 	mov	r8,514
80004e6c:	ea 18 02 02 	orh	r8,0x202
80004e70:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x03030303;					/* R3 */
80004e72:	e0 68 03 03 	mov	r8,771
80004e76:	ea 18 03 03 	orh	r8,0x303
80004e7a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x04040404;					/* R4 */
80004e7c:	e0 68 04 04 	mov	r8,1028
80004e80:	ea 18 04 04 	orh	r8,0x404
80004e84:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x05050505;					/* R5 */
80004e86:	e0 68 05 05 	mov	r8,1285
80004e8a:	ea 18 05 05 	orh	r8,0x505
80004e8e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x06060606;					/* R6 */
80004e90:	e0 68 06 06 	mov	r8,1542
80004e94:	ea 18 06 06 	orh	r8,0x606
80004e98:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x07070707;					/* R7 */
80004e9a:	e0 68 07 07 	mov	r8,1799
80004e9e:	ea 18 07 07 	orh	r8,0x707
80004ea2:	18 d8       	st.w	--r12,r8
	*pxTopOfStack = ( portSTACK_TYPE ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
80004ea4:	30 08       	mov	r8,0
80004ea6:	18 d8       	st.w	--r12,r8

	return pxTopOfStack;
}
80004ea8:	5e fc       	retal	r12
80004eaa:	d7 03       	nop

80004eac <vPortEnterCritical>:
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
80004eac:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
80004eae:	48 38       	lddpc	r8,80004eb8 <vPortEnterCritical+0xc>
80004eb0:	70 09       	ld.w	r9,r8[0x0]
80004eb2:	2f f9       	sub	r9,-1
80004eb4:	91 09       	st.w	r8[0x0],r9
}
80004eb6:	5e fc       	retal	r12
80004eb8:	00 00       	add	r0,r0
80004eba:	05 28       	ld.uh	r8,r2++

80004ebc <xPortStartScheduler>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
80004ebc:	d4 01       	pushm	lr
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
80004ebe:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
80004ec0:	30 0a       	mov	r10,0
80004ec2:	14 9b       	mov	r11,r10
80004ec4:	49 2c       	lddpc	r12,80004f0c <xPortStartScheduler+0x50>
80004ec6:	f0 1f 00 13 	mcall	80004f10 <xPortStartScheduler+0x54>
/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);//cause!!!
80004eca:	e0 68 5d c0 	mov	r8,24000
80004ece:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
80004ed2:	30 08       	mov	r8,0
80004ed4:	e3 b8 00 42 	mtsr	0x108,r8
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Start the first task. */
	portRESTORE_CONTEXT();
80004ed8:	e0 68 0c c8 	mov	r8,3272
80004edc:	ea 18 00 00 	orh	r8,0x0
80004ee0:	70 00       	ld.w	r0,r8[0x0]
80004ee2:	60 0d       	ld.w	sp,r0[0x0]
80004ee4:	1b 00       	ld.w	r0,sp++
80004ee6:	e0 68 05 28 	mov	r8,1320
80004eea:	ea 18 00 00 	orh	r8,0x0
80004eee:	91 00       	st.w	r8[0x0],r0
80004ef0:	e3 cd 00 ff 	ldm	sp++,r0-r7
80004ef4:	2f ed       	sub	sp,-8
80004ef6:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
80004efa:	fa f0 ff e0 	ld.w	r0,sp[-32]
80004efe:	e3 b0 00 00 	mtsr	0x0,r0
80004f02:	fa f0 ff dc 	ld.w	r0,sp[-36]
80004f06:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
}
80004f0a:	d8 0a       	popm	pc,r12=0
80004f0c:	80 00       	ld.sh	r0,r0[0x0]
80004f0e:	4f d8       	lddpc	r8,80005100 <vPortFree+0x10>
80004f10:	80 00       	ld.sh	r0,r0[0x0]
80004f12:	48 78       	lddpc	r8,80004f2c <SCALLYield+0x18>

80004f14 <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
80004f14:	20 6d       	sub	sp,24
80004f16:	eb cd 00 ff 	pushm	r0-r7
80004f1a:	fa c7 ff c0 	sub	r7,sp,-64
80004f1e:	ee f0 ff f8 	ld.w	r0,r7[-8]
80004f22:	ef 40 ff e0 	st.w	r7[-32],r0
80004f26:	ee f0 ff fc 	ld.w	r0,r7[-4]
80004f2a:	ef 40 ff e4 	st.w	r7[-28],r0
80004f2e:	eb c7 5f 00 	stm	--r7,r8-r12,lr
80004f32:	e0 68 05 28 	mov	r8,1320
80004f36:	ea 18 00 00 	orh	r8,0x0
80004f3a:	70 00       	ld.w	r0,r8[0x0]
80004f3c:	1a d0       	st.w	--sp,r0
80004f3e:	f0 1f 00 1a 	mcall	80004fa4 <LABEL_RET_SCALL_263+0x14>
80004f42:	e0 68 0c c8 	mov	r8,3272
80004f46:	ea 18 00 00 	orh	r8,0x0
80004f4a:	70 00       	ld.w	r0,r8[0x0]
80004f4c:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
80004f4e:	f0 1f 00 17 	mcall	80004fa8 <LABEL_RET_SCALL_263+0x18>
	portRESTORE_CONTEXT_SCALL();
80004f52:	e0 68 0c c8 	mov	r8,3272
80004f56:	ea 18 00 00 	orh	r8,0x0
80004f5a:	70 00       	ld.w	r0,r8[0x0]
80004f5c:	60 0d       	ld.w	sp,r0[0x0]
80004f5e:	1b 00       	ld.w	r0,sp++
80004f60:	e0 68 05 28 	mov	r8,1320
80004f64:	ea 18 00 00 	orh	r8,0x0
80004f68:	91 00       	st.w	r8[0x0],r0
80004f6a:	fa c7 ff d8 	sub	r7,sp,-40
80004f6e:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
80004f72:	ee f0 ff e0 	ld.w	r0,r7[-32]
80004f76:	e0 61 05 28 	mov	r1,1320
80004f7a:	ea 11 00 00 	orh	r1,0x0
80004f7e:	62 02       	ld.w	r2,r1[0x0]
80004f80:	58 02       	cp.w	r2,0
80004f82:	c0 70       	breq	80004f90 <LABEL_RET_SCALL_263>
80004f84:	e4 c2 00 01 	sub	r2,r2,1
80004f88:	83 02       	st.w	r1[0x0],r2
80004f8a:	58 02       	cp.w	r2,0
80004f8c:	c0 21       	brne	80004f90 <LABEL_RET_SCALL_263>
80004f8e:	b1 c0       	cbr	r0,0x10

80004f90 <LABEL_RET_SCALL_263>:
80004f90:	ef 40 ff f8 	st.w	r7[-8],r0
80004f94:	ee f0 ff e4 	ld.w	r0,r7[-28]
80004f98:	ef 40 ff fc 	st.w	r7[-4],r0
80004f9c:	e3 cd 00 ff 	ldm	sp++,r0-r7
80004fa0:	2f ad       	sub	sp,-24
80004fa2:	d6 13       	rets
80004fa4:	80 00       	ld.sh	r0,r0[0x0]
80004fa6:	4e ac       	lddpc	r12,8000514c <prvCopyDataFromQueue+0xc>
80004fa8:	80 00       	ld.sh	r0,r0[0x0]
80004faa:	55 f0       	stdsp	sp[0x17c],r0

80004fac <prvClearCcInt>:
		Set_system_register(AVR32_COUNT, 0);
	}

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
80004fac:	e1 b8 00 43 	mfsr	r8,0x10c
80004fb0:	e3 b8 00 43 	mtsr	0x10c,r8
	}
80004fb4:	5e fc       	retal	r12
80004fb6:	d7 03       	nop

80004fb8 <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
80004fb8:	48 78       	lddpc	r8,80004fd4 <vPortExitCritical+0x1c>
80004fba:	70 08       	ld.w	r8,r8[0x0]
80004fbc:	58 08       	cp.w	r8,0
80004fbe:	5e 0c       	reteq	r12
	{
		ulCriticalNesting--;
80004fc0:	48 58       	lddpc	r8,80004fd4 <vPortExitCritical+0x1c>
80004fc2:	70 09       	ld.w	r9,r8[0x0]
80004fc4:	20 19       	sub	r9,1
80004fc6:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
80004fc8:	70 08       	ld.w	r8,r8[0x0]
80004fca:	58 08       	cp.w	r8,0
80004fcc:	5e 1c       	retne	r12
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
80004fce:	d5 03       	csrf	0x10
80004fd0:	5e fc       	retal	r12
80004fd2:	00 00       	add	r0,r0
80004fd4:	00 00       	add	r0,r0
80004fd6:	05 28       	ld.uh	r8,r2++

80004fd8 <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
80004fd8:	eb cd 00 ff 	pushm	r0-r7
80004fdc:	e0 68 05 28 	mov	r8,1320
80004fe0:	ea 18 00 00 	orh	r8,0x0
80004fe4:	70 00       	ld.w	r0,r8[0x0]
80004fe6:	1a d0       	st.w	--sp,r0
80004fe8:	7a 90       	ld.w	r0,sp[0x24]
80004fea:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80004fee:	58 10       	cp.w	r0,1
80004ff0:	e0 8b 00 08 	brhi	80005000 <LABEL_INT_SKIP_SAVE_CONTEXT_237>
80004ff4:	e0 68 0c c8 	mov	r8,3272
80004ff8:	ea 18 00 00 	orh	r8,0x0
80004ffc:	70 00       	ld.w	r0,r8[0x0]
80004ffe:	81 0d       	st.w	r0[0x0],sp

80005000 <LABEL_INT_SKIP_SAVE_CONTEXT_237>:
	#if( configTICK_USE_TC==1 )
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Clear the interrupt flag. */
		prvClearCcInt();
80005000:	f0 1f 00 12 	mcall	80005048 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
80005004:	f0 1f 00 12 	mcall	8000504c <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
		vTaskIncrementTick();
80005008:	f0 1f 00 12 	mcall	80005050 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x1c>
	portEXIT_CRITICAL();
8000500c:	f0 1f 00 12 	mcall	80005054 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
80005010:	7a 90       	ld.w	r0,sp[0x24]
80005012:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80005016:	58 10       	cp.w	r0,1
80005018:	e0 8b 00 0e 	brhi	80005034 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>
8000501c:	f0 1f 00 0c 	mcall	8000504c <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
80005020:	f0 1f 00 0e 	mcall	80005058 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x24>
80005024:	f0 1f 00 0c 	mcall	80005054 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>
80005028:	e0 68 0c c8 	mov	r8,3272
8000502c:	ea 18 00 00 	orh	r8,0x0
80005030:	70 00       	ld.w	r0,r8[0x0]
80005032:	60 0d       	ld.w	sp,r0[0x0]

80005034 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>:
80005034:	1b 00       	ld.w	r0,sp++
80005036:	e0 68 05 28 	mov	r8,1320
8000503a:	ea 18 00 00 	orh	r8,0x0
8000503e:	91 00       	st.w	r8[0x0],r0
80005040:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005044:	d6 03       	rete
80005046:	00 00       	add	r0,r0
80005048:	80 00       	ld.sh	r0,r0[0x0]
8000504a:	4f ac       	lddpc	r12,80005230 <prvUnlockQueue+0x70>
8000504c:	80 00       	ld.sh	r0,r0[0x0]
8000504e:	4e ac       	lddpc	r12,800051f4 <prvUnlockQueue+0x34>
80005050:	80 00       	ld.sh	r0,r0[0x0]
80005052:	57 f4       	stdsp	sp[0x1fc],r4
80005054:	80 00       	ld.sh	r0,r0[0x0]
80005056:	4f b8       	lddpc	r8,80005240 <prvUnlockQueue+0x80>
80005058:	80 00       	ld.sh	r0,r0[0x0]
8000505a:	55 f0       	stdsp	sp[0x17c],r0

8000505c <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
8000505c:	d4 01       	pushm	lr
	vTaskSuspendAll();
8000505e:	f0 1f 00 02 	mcall	80005064 <__malloc_lock+0x8>
}
80005062:	d8 02       	popm	pc
80005064:	80 00       	ld.sh	r0,r0[0x0]
80005066:	55 e0       	stdsp	sp[0x178],r0

80005068 <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
80005068:	d4 01       	pushm	lr
	xTaskResumeAll();
8000506a:	f0 1f 00 02 	mcall	80005070 <__malloc_unlock+0x8>
}
8000506e:	d8 02       	popm	pc
80005070:	80 00       	ld.sh	r0,r0[0x0]
80005072:	59 9c       	cp.w	r12,25

80005074 <_read>:
/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
{
80005074:	d4 21       	pushm	r4-r7,lr
80005076:	16 95       	mov	r5,r11
80005078:	14 96       	mov	r6,r10
  int nChars = 0;

  if (file != 0)
8000507a:	58 0c       	cp.w	r12,0
8000507c:	c0 30       	breq	80005082 <_read+0xe>
8000507e:	3f f7       	mov	r7,-1
80005080:	c1 48       	rjmp	800050a8 <_read+0x34>
    return -1;

  for (; len > 0; --len)
80005082:	58 0a       	cp.w	r10,0
80005084:	e0 89 00 04 	brgt	8000508c <_read+0x18>
80005088:	30 07       	mov	r7,0
8000508a:	c0 f8       	rjmp	800050a8 <_read+0x34>
8000508c:	30 07       	mov	r7,0
  {
    int c = usart_getchar(stdio_usart_base);
8000508e:	48 84       	lddpc	r4,800050ac <_read+0x38>
80005090:	68 0c       	ld.w	r12,r4[0x0]
80005092:	f0 1f 00 08 	mcall	800050b0 <_read+0x3c>
    if (c < 0)
80005096:	c0 95       	brlt	800050a8 <_read+0x34>
      break;

    *ptr++ = c;
80005098:	ea 07 0b 0c 	st.b	r5[r7],r12
    ++nChars;
8000509c:	2f f7       	sub	r7,-1

/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
8000509e:	ec 07 01 08 	sub	r8,r6,r7
  int nChars = 0;

  if (file != 0)
    return -1;

  for (; len > 0; --len)
800050a2:	58 08       	cp.w	r8,0
800050a4:	fe 99 ff f6 	brgt	80005090 <_read+0x1c>
    *ptr++ = c;
    ++nChars;
  }

  return nChars;
}
800050a8:	0e 9c       	mov	r12,r7
800050aa:	d8 22       	popm	r4-r7,pc
800050ac:	00 00       	add	r0,r0
800050ae:	40 e8       	lddsp	r8,sp[0x38]
800050b0:	80 00       	ld.sh	r0,r0[0x0]
800050b2:	4c 40       	lddpc	r0,800051c0 <prvUnlockQueue>

800050b4 <_write>:
 * 1 and 2 is stdout and stderr which goes to usart
 * 3 is framebuffer
 */
int __attribute__((weak))
_write (int file, char * ptr, int len)
{
800050b4:	d4 21       	pushm	r4-r7,lr
800050b6:	16 95       	mov	r5,r11
800050b8:	14 96       	mov	r6,r10
  int nChars = 0;

  if ( (file != 1)
800050ba:	20 1c       	sub	r12,1
800050bc:	58 2c       	cp.w	r12,2
800050be:	e0 8b 00 12 	brhi	800050e2 <_write+0x2e>
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
800050c2:	58 0a       	cp.w	r10,0
800050c4:	c0 31       	brne	800050ca <_write+0x16>
800050c6:	30 07       	mov	r7,0
800050c8:	c0 e8       	rjmp	800050e4 <_write+0x30>
800050ca:	30 07       	mov	r7,0
  {
    if (usart_putchar(stdio_usart_base, *ptr++) < 0)
800050cc:	48 74       	lddpc	r4,800050e8 <_write+0x34>
800050ce:	68 0c       	ld.w	r12,r4[0x0]
800050d0:	ea 07 07 0b 	ld.ub	r11,r5[r7]
800050d4:	f0 1f 00 06 	mcall	800050ec <_write+0x38>
800050d8:	c0 55       	brlt	800050e2 <_write+0x2e>
    {
      return -1;
    }

    ++nChars;
800050da:	2f f7       	sub	r7,-1

  if ( (file != 1)
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
800050dc:	0e 36       	cp.w	r6,r7
800050de:	cf 81       	brne	800050ce <_write+0x1a>
800050e0:	c0 28       	rjmp	800050e4 <_write+0x30>
800050e2:	3f f7       	mov	r7,-1

    ++nChars;
  }

  return nChars;
}
800050e4:	0e 9c       	mov	r12,r7
800050e6:	d8 22       	popm	r4-r7,pc
800050e8:	00 00       	add	r0,r0
800050ea:	40 e8       	lddsp	r8,sp[0x38]
800050ec:	80 00       	ld.sh	r0,r0[0x0]
800050ee:	4b f0       	lddpc	r0,800051e8 <prvUnlockQueue+0x28>

800050f0 <vPortFree>:
	return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
800050f0:	eb cd 40 80 	pushm	r7,lr
800050f4:	18 97       	mov	r7,r12
	if( pv )
800050f6:	58 0c       	cp.w	r12,0
800050f8:	c0 80       	breq	80005108 <vPortFree+0x18>
	{
		vTaskSuspendAll();
800050fa:	f0 1f 00 05 	mcall	8000510c <vPortFree+0x1c>
		{
			free( pv );
800050fe:	0e 9c       	mov	r12,r7
80005100:	f0 1f 00 04 	mcall	80005110 <vPortFree+0x20>
		}
		xTaskResumeAll();
80005104:	f0 1f 00 04 	mcall	80005114 <vPortFree+0x24>
80005108:	e3 cd 80 80 	ldm	sp++,r7,pc
8000510c:	80 00       	ld.sh	r0,r0[0x0]
8000510e:	55 e0       	stdsp	sp[0x178],r0
80005110:	80 00       	ld.sh	r0,r0[0x0]
80005112:	65 04       	ld.w	r4,r2[0x40]
80005114:	80 00       	ld.sh	r0,r0[0x0]
80005116:	59 9c       	cp.w	r12,25

80005118 <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
80005118:	eb cd 40 80 	pushm	r7,lr
8000511c:	18 97       	mov	r7,r12
void *pvReturn;

	vTaskSuspendAll();
8000511e:	f0 1f 00 06 	mcall	80005134 <pvPortMalloc+0x1c>
	{
		pvReturn = malloc( xWantedSize );
80005122:	0e 9c       	mov	r12,r7
80005124:	f0 1f 00 05 	mcall	80005138 <pvPortMalloc+0x20>
80005128:	18 97       	mov	r7,r12
	}
	xTaskResumeAll();
8000512a:	f0 1f 00 05 	mcall	8000513c <pvPortMalloc+0x24>
		}
	}
	#endif

	return pvReturn;
}
8000512e:	0e 9c       	mov	r12,r7
80005130:	e3 cd 80 80 	ldm	sp++,r7,pc
80005134:	80 00       	ld.sh	r0,r0[0x0]
80005136:	55 e0       	stdsp	sp[0x178],r0
80005138:	80 00       	ld.sh	r0,r0[0x0]
8000513a:	65 14       	ld.w	r4,r2[0x44]
8000513c:	80 00       	ld.sh	r0,r0[0x0]
8000513e:	59 9c       	cp.w	r12,25

80005140 <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
80005140:	d4 01       	pushm	lr
80005142:	16 98       	mov	r8,r11
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
80005144:	78 09       	ld.w	r9,r12[0x0]
80005146:	58 09       	cp.w	r9,0
80005148:	c1 10       	breq	8000516a <prvCopyDataFromQueue+0x2a>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
8000514a:	78 3a       	ld.w	r10,r12[0xc]
8000514c:	79 09       	ld.w	r9,r12[0x40]
8000514e:	f4 09 00 09 	add	r9,r10,r9
80005152:	99 39       	st.w	r12[0xc],r9
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
80005154:	78 1a       	ld.w	r10,r12[0x4]
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
80005156:	14 39       	cp.w	r9,r10
80005158:	f9 f9 20 00 	ld.wcc	r9,r12[0x0]
8000515c:	f9 f9 2a 03 	st.wcc	r12[0xc],r9
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
80005160:	79 0a       	ld.w	r10,r12[0x40]
80005162:	78 3b       	ld.w	r11,r12[0xc]
80005164:	10 9c       	mov	r12,r8
80005166:	f0 1f 00 02 	mcall	8000516c <prvCopyDataFromQueue+0x2c>
8000516a:	d8 02       	popm	pc
8000516c:	80 00       	ld.sh	r0,r0[0x0]
8000516e:	69 5c       	ld.w	r12,r4[0x54]

80005170 <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
80005170:	eb cd 40 c0 	pushm	r6-r7,lr
80005174:	18 97       	mov	r7,r12
80005176:	14 96       	mov	r6,r10
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80005178:	78 e8       	ld.w	r8,r12[0x38]
8000517a:	58 08       	cp.w	r8,0
8000517c:	c0 31       	brne	80005182 <xQueueReceiveFromISR+0x12>
8000517e:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
80005182:	f0 1f 00 0e 	mcall	800051b8 <xQueueReceiveFromISR+0x48>
			--( pxQueue->uxMessagesWaiting );
80005186:	6e e8       	ld.w	r8,r7[0x38]
80005188:	20 18       	sub	r8,1
8000518a:	8f e8       	st.w	r7[0x38],r8

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
8000518c:	6f 18       	ld.w	r8,r7[0x44]
8000518e:	5b f8       	cp.w	r8,-1
80005190:	c0 d1       	brne	800051aa <xQueueReceiveFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005192:	6e 48       	ld.w	r8,r7[0x10]
80005194:	58 08       	cp.w	r8,0
80005196:	c0 f0       	breq	800051b4 <xQueueReceiveFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80005198:	ee cc ff f0 	sub	r12,r7,-16
8000519c:	f0 1f 00 08 	mcall	800051bc <xQueueReceiveFromISR+0x4c>
800051a0:	c0 a0       	breq	800051b4 <xQueueReceiveFromISR+0x44>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
800051a2:	30 1c       	mov	r12,1
800051a4:	8d 0c       	st.w	r6[0x0],r12
800051a6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
800051aa:	2f f8       	sub	r8,-1
800051ac:	ef 48 00 44 	st.w	r7[68],r8
800051b0:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
800051b4:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
800051b8:	80 00       	ld.sh	r0,r0[0x0]
800051ba:	51 40       	stdsp	sp[0x50],r0
800051bc:	80 00       	ld.sh	r0,r0[0x0]
800051be:	57 78       	stdsp	sp[0x1dc],r8

800051c0 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
800051c0:	eb cd 40 c0 	pushm	r6-r7,lr
800051c4:	18 97       	mov	r7,r12

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
800051c6:	f0 1f 00 23 	mcall	80005250 <prvUnlockQueue+0x90>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
800051ca:	6f 28       	ld.w	r8,r7[0x48]
800051cc:	58 08       	cp.w	r8,0
800051ce:	e0 8a 00 18 	brle	800051fe <prvUnlockQueue+0x3e>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800051d2:	6e 98       	ld.w	r8,r7[0x24]
800051d4:	58 08       	cp.w	r8,0
800051d6:	c1 40       	breq	800051fe <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
800051d8:	ee c6 ff dc 	sub	r6,r7,-36
800051dc:	c0 48       	rjmp	800051e4 <prvUnlockQueue+0x24>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800051de:	6e 98       	ld.w	r8,r7[0x24]
800051e0:	58 08       	cp.w	r8,0
800051e2:	c0 e0       	breq	800051fe <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
800051e4:	0c 9c       	mov	r12,r6
800051e6:	f0 1f 00 1c 	mcall	80005254 <prvUnlockQueue+0x94>
800051ea:	c0 30       	breq	800051f0 <prvUnlockQueue+0x30>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
800051ec:	f0 1f 00 1b 	mcall	80005258 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xTxLock );
800051f0:	6f 28       	ld.w	r8,r7[0x48]
800051f2:	20 18       	sub	r8,1
800051f4:	ef 48 00 48 	st.w	r7[72],r8
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
800051f8:	58 08       	cp.w	r8,0
800051fa:	fe 99 ff f2 	brgt	800051de <prvUnlockQueue+0x1e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
800051fe:	3f f8       	mov	r8,-1
80005200:	ef 48 00 48 	st.w	r7[72],r8
	}
	taskEXIT_CRITICAL();
80005204:	f0 1f 00 16 	mcall	8000525c <prvUnlockQueue+0x9c>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
80005208:	f0 1f 00 12 	mcall	80005250 <prvUnlockQueue+0x90>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
8000520c:	6f 18       	ld.w	r8,r7[0x44]
8000520e:	58 08       	cp.w	r8,0
80005210:	e0 8a 00 18 	brle	80005240 <prvUnlockQueue+0x80>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005214:	6e 48       	ld.w	r8,r7[0x10]
80005216:	58 08       	cp.w	r8,0
80005218:	c1 40       	breq	80005240 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
8000521a:	ee c6 ff f0 	sub	r6,r7,-16
8000521e:	c0 48       	rjmp	80005226 <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005220:	6e 48       	ld.w	r8,r7[0x10]
80005222:	58 08       	cp.w	r8,0
80005224:	c0 e0       	breq	80005240 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80005226:	0c 9c       	mov	r12,r6
80005228:	f0 1f 00 0b 	mcall	80005254 <prvUnlockQueue+0x94>
8000522c:	c0 30       	breq	80005232 <prvUnlockQueue+0x72>
				{
					vTaskMissedYield();
8000522e:	f0 1f 00 0b 	mcall	80005258 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xRxLock );
80005232:	6f 18       	ld.w	r8,r7[0x44]
80005234:	20 18       	sub	r8,1
80005236:	ef 48 00 44 	st.w	r7[68],r8
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
8000523a:	58 08       	cp.w	r8,0
8000523c:	fe 99 ff f2 	brgt	80005220 <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
80005240:	3f f8       	mov	r8,-1
80005242:	ef 48 00 44 	st.w	r7[68],r8
	}
	taskEXIT_CRITICAL();
80005246:	f0 1f 00 06 	mcall	8000525c <prvUnlockQueue+0x9c>
}
8000524a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000524e:	00 00       	add	r0,r0
80005250:	80 00       	ld.sh	r0,r0[0x0]
80005252:	4e ac       	lddpc	r12,800053f8 <prvCopyDataToQueue+0x54>
80005254:	80 00       	ld.sh	r0,r0[0x0]
80005256:	57 78       	stdsp	sp[0x1dc],r8
80005258:	80 00       	ld.sh	r0,r0[0x0]
8000525a:	56 84       	stdsp	sp[0x1a0],r4
8000525c:	80 00       	ld.sh	r0,r0[0x0]
8000525e:	4f b8       	lddpc	r8,80005448 <xQueueGenericSendFromISR+0x2c>

80005260 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
80005260:	d4 31       	pushm	r0-r7,lr
80005262:	20 5d       	sub	sp,20
80005264:	18 97       	mov	r7,r12
80005266:	50 0b       	stdsp	sp[0x0],r11
80005268:	50 2a       	stdsp	sp[0x8],r10
8000526a:	50 19       	stdsp	sp[0x4],r9
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
8000526c:	f8 c2 ff dc 	sub	r2,r12,-36
80005270:	30 05       	mov	r5,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80005272:	fa c4 ff f4 	sub	r4,sp,-12
80005276:	30 10       	mov	r0,1

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80005278:	0a 91       	mov	r1,r5

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
8000527a:	fa c3 ff f8 	sub	r3,sp,-8
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
8000527e:	f0 1f 00 3e 	mcall	80005374 <xQueueGenericReceive+0x114>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80005282:	6e e8       	ld.w	r8,r7[0x38]
80005284:	58 08       	cp.w	r8,0
80005286:	c2 a0       	breq	800052da <xQueueGenericReceive+0x7a>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
80005288:	6e 36       	ld.w	r6,r7[0xc]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
8000528a:	40 0b       	lddsp	r11,sp[0x0]
8000528c:	0e 9c       	mov	r12,r7
8000528e:	f0 1f 00 3b 	mcall	80005378 <xQueueGenericReceive+0x118>

				if( xJustPeeking == pdFALSE )
80005292:	40 18       	lddsp	r8,sp[0x4]
80005294:	58 08       	cp.w	r8,0
80005296:	c1 51       	brne	800052c0 <xQueueGenericReceive+0x60>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
80005298:	6e e8       	ld.w	r8,r7[0x38]
8000529a:	20 18       	sub	r8,1
8000529c:	8f e8       	st.w	r7[0x38],r8

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
8000529e:	6e 08       	ld.w	r8,r7[0x0]
800052a0:	58 08       	cp.w	r8,0
800052a2:	c0 41       	brne	800052aa <xQueueGenericReceive+0x4a>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
800052a4:	f0 1f 00 36 	mcall	8000537c <xQueueGenericReceive+0x11c>
800052a8:	8f 1c       	st.w	r7[0x4],r12
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
800052aa:	6e 48       	ld.w	r8,r7[0x10]
800052ac:	58 08       	cp.w	r8,0
800052ae:	c1 20       	breq	800052d2 <xQueueGenericReceive+0x72>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
800052b0:	ee cc ff f0 	sub	r12,r7,-16
800052b4:	f0 1f 00 33 	mcall	80005380 <xQueueGenericReceive+0x120>
800052b8:	58 1c       	cp.w	r12,1
800052ba:	c0 c1       	brne	800052d2 <xQueueGenericReceive+0x72>
						{
							portYIELD_WITHIN_API();
800052bc:	d7 33       	scall
800052be:	c0 a8       	rjmp	800052d2 <xQueueGenericReceive+0x72>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
800052c0:	8f 36       	st.w	r7[0xc],r6

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800052c2:	6e 98       	ld.w	r8,r7[0x24]
800052c4:	58 08       	cp.w	r8,0
800052c6:	c0 60       	breq	800052d2 <xQueueGenericReceive+0x72>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
800052c8:	04 9c       	mov	r12,r2
800052ca:	f0 1f 00 2e 	mcall	80005380 <xQueueGenericReceive+0x120>
800052ce:	c0 20       	breq	800052d2 <xQueueGenericReceive+0x72>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
800052d0:	d7 33       	scall
						}
					}

				}

				taskEXIT_CRITICAL();
800052d2:	f0 1f 00 2d 	mcall	80005384 <xQueueGenericReceive+0x124>
800052d6:	30 1c       	mov	r12,1
				return pdPASS;
800052d8:	c4 c8       	rjmp	80005370 <xQueueGenericReceive+0x110>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
800052da:	40 28       	lddsp	r8,sp[0x8]
800052dc:	58 08       	cp.w	r8,0
800052de:	c0 51       	brne	800052e8 <xQueueGenericReceive+0x88>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
800052e0:	f0 1f 00 29 	mcall	80005384 <xQueueGenericReceive+0x124>
800052e4:	30 0c       	mov	r12,0
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
800052e6:	c4 58       	rjmp	80005370 <xQueueGenericReceive+0x110>
				}
				else if( xEntryTimeSet == pdFALSE )
800052e8:	58 05       	cp.w	r5,0
800052ea:	c0 51       	brne	800052f4 <xQueueGenericReceive+0x94>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
800052ec:	08 9c       	mov	r12,r4
800052ee:	f0 1f 00 27 	mcall	80005388 <xQueueGenericReceive+0x128>
800052f2:	00 95       	mov	r5,r0
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
800052f4:	f0 1f 00 24 	mcall	80005384 <xQueueGenericReceive+0x124>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
800052f8:	f0 1f 00 25 	mcall	8000538c <xQueueGenericReceive+0x12c>
		prvLockQueue( pxQueue );
800052fc:	f0 1f 00 1e 	mcall	80005374 <xQueueGenericReceive+0x114>
80005300:	6f 18       	ld.w	r8,r7[0x44]
80005302:	5b f8       	cp.w	r8,-1
80005304:	ef f1 0a 11 	st.weq	r7[0x44],r1
80005308:	6f 28       	ld.w	r8,r7[0x48]
8000530a:	5b f8       	cp.w	r8,-1
8000530c:	ef f1 0a 12 	st.weq	r7[0x48],r1
80005310:	f0 1f 00 1d 	mcall	80005384 <xQueueGenericReceive+0x124>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80005314:	06 9b       	mov	r11,r3
80005316:	08 9c       	mov	r12,r4
80005318:	f0 1f 00 1e 	mcall	80005390 <xQueueGenericReceive+0x130>
8000531c:	c2 41       	brne	80005364 <xQueueGenericReceive+0x104>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
8000531e:	f0 1f 00 16 	mcall	80005374 <xQueueGenericReceive+0x114>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
80005322:	6e e6       	ld.w	r6,r7[0x38]
	taskEXIT_CRITICAL();
80005324:	f0 1f 00 18 	mcall	80005384 <xQueueGenericReceive+0x124>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
80005328:	58 06       	cp.w	r6,0
8000532a:	c1 71       	brne	80005358 <xQueueGenericReceive+0xf8>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
8000532c:	6e 08       	ld.w	r8,r7[0x0]
8000532e:	58 08       	cp.w	r8,0
80005330:	c0 81       	brne	80005340 <xQueueGenericReceive+0xe0>
					{
						portENTER_CRITICAL();
80005332:	f0 1f 00 11 	mcall	80005374 <xQueueGenericReceive+0x114>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
80005336:	6e 1c       	ld.w	r12,r7[0x4]
80005338:	f0 1f 00 17 	mcall	80005394 <xQueueGenericReceive+0x134>
						}
						portEXIT_CRITICAL();
8000533c:	f0 1f 00 12 	mcall	80005384 <xQueueGenericReceive+0x124>
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80005340:	40 2b       	lddsp	r11,sp[0x8]
80005342:	04 9c       	mov	r12,r2
80005344:	f0 1f 00 15 	mcall	80005398 <xQueueGenericReceive+0x138>
				prvUnlockQueue( pxQueue );
80005348:	0e 9c       	mov	r12,r7
8000534a:	f0 1f 00 15 	mcall	8000539c <xQueueGenericReceive+0x13c>
				if( !xTaskResumeAll() )
8000534e:	f0 1f 00 15 	mcall	800053a0 <xQueueGenericReceive+0x140>
80005352:	c9 61       	brne	8000527e <xQueueGenericReceive+0x1e>
				{
					portYIELD_WITHIN_API();
80005354:	d7 33       	scall
80005356:	c9 4b       	rjmp	8000527e <xQueueGenericReceive+0x1e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80005358:	0e 9c       	mov	r12,r7
8000535a:	f0 1f 00 11 	mcall	8000539c <xQueueGenericReceive+0x13c>
				( void ) xTaskResumeAll();
8000535e:	f0 1f 00 11 	mcall	800053a0 <xQueueGenericReceive+0x140>
80005362:	c8 eb       	rjmp	8000527e <xQueueGenericReceive+0x1e>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
80005364:	0e 9c       	mov	r12,r7
80005366:	f0 1f 00 0e 	mcall	8000539c <xQueueGenericReceive+0x13c>
			( void ) xTaskResumeAll();
8000536a:	f0 1f 00 0e 	mcall	800053a0 <xQueueGenericReceive+0x140>
8000536e:	30 0c       	mov	r12,0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
80005370:	2f bd       	sub	sp,-20
80005372:	d8 32       	popm	r0-r7,pc
80005374:	80 00       	ld.sh	r0,r0[0x0]
80005376:	4e ac       	lddpc	r12,8000551c <xQueueGenericSend+0xb0>
80005378:	80 00       	ld.sh	r0,r0[0x0]
8000537a:	51 40       	stdsp	sp[0x50],r0
8000537c:	80 00       	ld.sh	r0,r0[0x0]
8000537e:	56 90       	stdsp	sp[0x1a4],r0
80005380:	80 00       	ld.sh	r0,r0[0x0]
80005382:	57 78       	stdsp	sp[0x1dc],r8
80005384:	80 00       	ld.sh	r0,r0[0x0]
80005386:	4f b8       	lddpc	r8,80005570 <xQueueCreate+0x4>
80005388:	80 00       	ld.sh	r0,r0[0x0]
8000538a:	56 6c       	stdsp	sp[0x198],r12
8000538c:	80 00       	ld.sh	r0,r0[0x0]
8000538e:	55 e0       	stdsp	sp[0x178],r0
80005390:	80 00       	ld.sh	r0,r0[0x0]
80005392:	59 08       	cp.w	r8,16
80005394:	80 00       	ld.sh	r0,r0[0x0]
80005396:	56 f4       	stdsp	sp[0x1bc],r4
80005398:	80 00       	ld.sh	r0,r0[0x0]
8000539a:	5b 60       	cp.w	r0,-10
8000539c:	80 00       	ld.sh	r0,r0[0x0]
8000539e:	51 c0       	stdsp	sp[0x70],r0
800053a0:	80 00       	ld.sh	r0,r0[0x0]
800053a2:	59 9c       	cp.w	r12,25

800053a4 <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
800053a4:	eb cd 40 80 	pushm	r7,lr
800053a8:	18 97       	mov	r7,r12
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
800053aa:	79 08       	ld.w	r8,r12[0x40]
800053ac:	58 08       	cp.w	r8,0
800053ae:	c0 a1       	brne	800053c2 <prvCopyDataToQueue+0x1e>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
800053b0:	78 08       	ld.w	r8,r12[0x0]
800053b2:	58 08       	cp.w	r8,0
800053b4:	c2 b1       	brne	8000540a <prvCopyDataToQueue+0x66>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
800053b6:	78 1c       	ld.w	r12,r12[0x4]
800053b8:	f0 1f 00 17 	mcall	80005414 <prvCopyDataToQueue+0x70>
				pxQueue->pxMutexHolder = NULL;
800053bc:	30 08       	mov	r8,0
800053be:	8f 18       	st.w	r7[0x4],r8
800053c0:	c2 58       	rjmp	8000540a <prvCopyDataToQueue+0x66>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
800053c2:	58 0a       	cp.w	r10,0
800053c4:	c1 01       	brne	800053e4 <prvCopyDataToQueue+0x40>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
800053c6:	10 9a       	mov	r10,r8
800053c8:	78 2c       	ld.w	r12,r12[0x8]
800053ca:	f0 1f 00 14 	mcall	80005418 <prvCopyDataToQueue+0x74>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
800053ce:	6e 29       	ld.w	r9,r7[0x8]
800053d0:	6f 08       	ld.w	r8,r7[0x40]
800053d2:	f2 08 00 08 	add	r8,r9,r8
800053d6:	8f 28       	st.w	r7[0x8],r8
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
800053d8:	6e 19       	ld.w	r9,r7[0x4]
800053da:	12 38       	cp.w	r8,r9
800053dc:	c1 73       	brcs	8000540a <prvCopyDataToQueue+0x66>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
800053de:	6e 08       	ld.w	r8,r7[0x0]
800053e0:	8f 28       	st.w	r7[0x8],r8
800053e2:	c1 48       	rjmp	8000540a <prvCopyDataToQueue+0x66>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
800053e4:	10 9a       	mov	r10,r8
800053e6:	78 3c       	ld.w	r12,r12[0xc]
800053e8:	f0 1f 00 0c 	mcall	80005418 <prvCopyDataToQueue+0x74>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
800053ec:	6f 08       	ld.w	r8,r7[0x40]
800053ee:	6e 39       	ld.w	r9,r7[0xc]
800053f0:	f2 08 01 08 	sub	r8,r9,r8
800053f4:	8f 38       	st.w	r7[0xc],r8
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
800053f6:	6e 09       	ld.w	r9,r7[0x0]
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
800053f8:	12 38       	cp.w	r8,r9
800053fa:	ef f8 30 10 	ld.wcs	r8,r7[0x40]
800053fe:	ef f9 30 01 	ld.wcs	r9,r7[0x4]
80005402:	f3 d8 e3 19 	subcs	r9,r9,r8
80005406:	ef f9 3a 03 	st.wcs	r7[0xc],r9
		}
	}

	++( pxQueue->uxMessagesWaiting );
8000540a:	6e e8       	ld.w	r8,r7[0x38]
8000540c:	2f f8       	sub	r8,-1
8000540e:	8f e8       	st.w	r7[0x38],r8
}
80005410:	e3 cd 80 80 	ldm	sp++,r7,pc
80005414:	80 00       	ld.sh	r0,r0[0x0]
80005416:	56 9c       	stdsp	sp[0x1a4],r12
80005418:	80 00       	ld.sh	r0,r0[0x0]
8000541a:	69 5c       	ld.w	r12,r4[0x54]

8000541c <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
8000541c:	eb cd 40 c0 	pushm	r6-r7,lr
80005420:	18 97       	mov	r7,r12
80005422:	14 96       	mov	r6,r10
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80005424:	78 ec       	ld.w	r12,r12[0x38]
80005426:	6e f8       	ld.w	r8,r7[0x3c]
80005428:	10 3c       	cp.w	r12,r8
8000542a:	c0 33       	brcs	80005430 <xQueueGenericSendFromISR+0x14>
8000542c:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80005430:	12 9a       	mov	r10,r9
80005432:	0e 9c       	mov	r12,r7
80005434:	f0 1f 00 0c 	mcall	80005464 <xQueueGenericSendFromISR+0x48>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
80005438:	6f 28       	ld.w	r8,r7[0x48]
8000543a:	5b f8       	cp.w	r8,-1
8000543c:	c0 d1       	brne	80005456 <xQueueGenericSendFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
8000543e:	6e 98       	ld.w	r8,r7[0x24]
80005440:	58 08       	cp.w	r8,0
80005442:	c0 f0       	breq	80005460 <xQueueGenericSendFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80005444:	ee cc ff dc 	sub	r12,r7,-36
80005448:	f0 1f 00 08 	mcall	80005468 <xQueueGenericSendFromISR+0x4c>
8000544c:	c0 a0       	breq	80005460 <xQueueGenericSendFromISR+0x44>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
8000544e:	30 1c       	mov	r12,1
80005450:	8d 0c       	st.w	r6[0x0],r12
80005452:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
80005456:	2f f8       	sub	r8,-1
80005458:	ef 48 00 48 	st.w	r7[72],r8
8000545c:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80005460:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80005464:	80 00       	ld.sh	r0,r0[0x0]
80005466:	53 a4       	stdsp	sp[0xe8],r4
80005468:	80 00       	ld.sh	r0,r0[0x0]
8000546a:	57 78       	stdsp	sp[0x1dc],r8

8000546c <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
8000546c:	d4 31       	pushm	r0-r7,lr
8000546e:	20 5d       	sub	sp,20
80005470:	18 97       	mov	r7,r12
80005472:	50 0b       	stdsp	sp[0x0],r11
80005474:	50 2a       	stdsp	sp[0x8],r10
80005476:	50 19       	stdsp	sp[0x4],r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
80005478:	f8 c0 ff f0 	sub	r0,r12,-16
8000547c:	30 04       	mov	r4,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
8000547e:	fa c3 ff f4 	sub	r3,sp,-12

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80005482:	08 91       	mov	r1,r4

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80005484:	fa c2 ff f8 	sub	r2,sp,-8
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
80005488:	f0 1f 00 2f 	mcall	80005544 <xQueueGenericSend+0xd8>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
8000548c:	6e e9       	ld.w	r9,r7[0x38]
8000548e:	6e f8       	ld.w	r8,r7[0x3c]
80005490:	10 39       	cp.w	r9,r8
80005492:	c1 42       	brcc	800054ba <xQueueGenericSend+0x4e>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80005494:	40 1a       	lddsp	r10,sp[0x4]
80005496:	40 0b       	lddsp	r11,sp[0x0]
80005498:	0e 9c       	mov	r12,r7
8000549a:	f0 1f 00 2c 	mcall	80005548 <xQueueGenericSend+0xdc>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
8000549e:	6e 98       	ld.w	r8,r7[0x24]
800054a0:	58 08       	cp.w	r8,0
800054a2:	c0 80       	breq	800054b2 <xQueueGenericSend+0x46>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
800054a4:	ee cc ff dc 	sub	r12,r7,-36
800054a8:	f0 1f 00 29 	mcall	8000554c <xQueueGenericSend+0xe0>
800054ac:	58 1c       	cp.w	r12,1
800054ae:	c0 21       	brne	800054b2 <xQueueGenericSend+0x46>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
800054b0:	d7 33       	scall
					}
				}

				taskEXIT_CRITICAL();
800054b2:	f0 1f 00 28 	mcall	80005550 <xQueueGenericSend+0xe4>
800054b6:	30 1c       	mov	r12,1

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
800054b8:	c4 38       	rjmp	8000553e <xQueueGenericSend+0xd2>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
800054ba:	40 28       	lddsp	r8,sp[0x8]
800054bc:	58 08       	cp.w	r8,0
800054be:	c0 51       	brne	800054c8 <xQueueGenericSend+0x5c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
800054c0:	f0 1f 00 24 	mcall	80005550 <xQueueGenericSend+0xe4>
800054c4:	30 0c       	mov	r12,0

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
800054c6:	c3 c8       	rjmp	8000553e <xQueueGenericSend+0xd2>
				}
				else if( xEntryTimeSet == pdFALSE )
800054c8:	58 04       	cp.w	r4,0
800054ca:	c0 51       	brne	800054d4 <xQueueGenericSend+0x68>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
800054cc:	06 9c       	mov	r12,r3
800054ce:	f0 1f 00 22 	mcall	80005554 <xQueueGenericSend+0xe8>
800054d2:	30 14       	mov	r4,1
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
800054d4:	f0 1f 00 1f 	mcall	80005550 <xQueueGenericSend+0xe4>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
800054d8:	f0 1f 00 20 	mcall	80005558 <xQueueGenericSend+0xec>
		prvLockQueue( pxQueue );
800054dc:	f0 1f 00 1a 	mcall	80005544 <xQueueGenericSend+0xd8>
800054e0:	6f 18       	ld.w	r8,r7[0x44]
800054e2:	5b f8       	cp.w	r8,-1
800054e4:	ef f1 0a 11 	st.weq	r7[0x44],r1
800054e8:	6f 28       	ld.w	r8,r7[0x48]
800054ea:	5b f8       	cp.w	r8,-1
800054ec:	ef f1 0a 12 	st.weq	r7[0x48],r1
800054f0:	f0 1f 00 18 	mcall	80005550 <xQueueGenericSend+0xe4>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800054f4:	04 9b       	mov	r11,r2
800054f6:	06 9c       	mov	r12,r3
800054f8:	f0 1f 00 19 	mcall	8000555c <xQueueGenericSend+0xf0>
800054fc:	c1 b1       	brne	80005532 <xQueueGenericSend+0xc6>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
800054fe:	f0 1f 00 12 	mcall	80005544 <xQueueGenericSend+0xd8>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
80005502:	6e e5       	ld.w	r5,r7[0x38]
80005504:	6e f6       	ld.w	r6,r7[0x3c]
	taskEXIT_CRITICAL();
80005506:	f0 1f 00 13 	mcall	80005550 <xQueueGenericSend+0xe4>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
8000550a:	0c 35       	cp.w	r5,r6
8000550c:	c0 d1       	brne	80005526 <xQueueGenericSend+0xba>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
8000550e:	40 2b       	lddsp	r11,sp[0x8]
80005510:	00 9c       	mov	r12,r0
80005512:	f0 1f 00 14 	mcall	80005560 <xQueueGenericSend+0xf4>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
80005516:	0e 9c       	mov	r12,r7
80005518:	f0 1f 00 13 	mcall	80005564 <xQueueGenericSend+0xf8>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
8000551c:	f0 1f 00 13 	mcall	80005568 <xQueueGenericSend+0xfc>
80005520:	cb 41       	brne	80005488 <xQueueGenericSend+0x1c>
				{
					portYIELD_WITHIN_API();
80005522:	d7 33       	scall
80005524:	cb 2b       	rjmp	80005488 <xQueueGenericSend+0x1c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80005526:	0e 9c       	mov	r12,r7
80005528:	f0 1f 00 0f 	mcall	80005564 <xQueueGenericSend+0xf8>
				( void ) xTaskResumeAll();
8000552c:	f0 1f 00 0f 	mcall	80005568 <xQueueGenericSend+0xfc>
80005530:	ca cb       	rjmp	80005488 <xQueueGenericSend+0x1c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
80005532:	0e 9c       	mov	r12,r7
80005534:	f0 1f 00 0c 	mcall	80005564 <xQueueGenericSend+0xf8>
			( void ) xTaskResumeAll();
80005538:	f0 1f 00 0c 	mcall	80005568 <xQueueGenericSend+0xfc>
8000553c:	30 0c       	mov	r12,0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
8000553e:	2f bd       	sub	sp,-20
80005540:	d8 32       	popm	r0-r7,pc
80005542:	00 00       	add	r0,r0
80005544:	80 00       	ld.sh	r0,r0[0x0]
80005546:	4e ac       	lddpc	r12,800056ec <vTaskPriorityDisinherit+0x50>
80005548:	80 00       	ld.sh	r0,r0[0x0]
8000554a:	53 a4       	stdsp	sp[0xe8],r4
8000554c:	80 00       	ld.sh	r0,r0[0x0]
8000554e:	57 78       	stdsp	sp[0x1dc],r8
80005550:	80 00       	ld.sh	r0,r0[0x0]
80005552:	4f b8       	lddpc	r8,8000573c <vTaskPriorityInherit+0x48>
80005554:	80 00       	ld.sh	r0,r0[0x0]
80005556:	56 6c       	stdsp	sp[0x198],r12
80005558:	80 00       	ld.sh	r0,r0[0x0]
8000555a:	55 e0       	stdsp	sp[0x178],r0
8000555c:	80 00       	ld.sh	r0,r0[0x0]
8000555e:	59 08       	cp.w	r8,16
80005560:	80 00       	ld.sh	r0,r0[0x0]
80005562:	5b 60       	cp.w	r0,-10
80005564:	80 00       	ld.sh	r0,r0[0x0]
80005566:	51 c0       	stdsp	sp[0x70],r0
80005568:	80 00       	ld.sh	r0,r0[0x0]
8000556a:	59 9c       	cp.w	r12,25

8000556c <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
8000556c:	d4 21       	pushm	r4-r7,lr
8000556e:	18 97       	mov	r7,r12
80005570:	16 96       	mov	r6,r11
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
80005572:	58 0c       	cp.w	r12,0
80005574:	c2 f0       	breq	800055d2 <xQueueCreate+0x66>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
80005576:	34 cc       	mov	r12,76
80005578:	f0 1f 00 17 	mcall	800055d4 <xQueueCreate+0x68>
8000557c:	18 95       	mov	r5,r12
		if( pxNewQueue != NULL )
8000557e:	c2 a0       	breq	800055d2 <xQueueCreate+0x66>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
80005580:	ec 07 02 44 	mul	r4,r6,r7

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
80005584:	e8 cc ff ff 	sub	r12,r4,-1
80005588:	f0 1f 00 13 	mcall	800055d4 <xQueueCreate+0x68>
8000558c:	8b 0c       	st.w	r5[0x0],r12
			if( pxNewQueue->pcHead != NULL )
8000558e:	c1 e0       	breq	800055ca <xQueueCreate+0x5e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
80005590:	f8 04 00 04 	add	r4,r12,r4
80005594:	8b 14       	st.w	r5[0x4],r4
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
80005596:	30 08       	mov	r8,0
80005598:	8b e8       	st.w	r5[0x38],r8
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
8000559a:	8b 2c       	st.w	r5[0x8],r12
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
8000559c:	ee c8 00 01 	sub	r8,r7,1
800055a0:	ad 38       	mul	r8,r6
800055a2:	10 0c       	add	r12,r8
800055a4:	8b 3c       	st.w	r5[0xc],r12
				pxNewQueue->uxLength = uxQueueLength;
800055a6:	8b f7       	st.w	r5[0x3c],r7
				pxNewQueue->uxItemSize = uxItemSize;
800055a8:	eb 46 00 40 	st.w	r5[64],r6
				pxNewQueue->xRxLock = queueUNLOCKED;
800055ac:	3f f8       	mov	r8,-1
800055ae:	eb 48 00 44 	st.w	r5[68],r8
				pxNewQueue->xTxLock = queueUNLOCKED;
800055b2:	eb 48 00 48 	st.w	r5[72],r8

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
800055b6:	ea cc ff f0 	sub	r12,r5,-16
800055ba:	f0 1f 00 08 	mcall	800055d8 <xQueueCreate+0x6c>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
800055be:	ea cc ff dc 	sub	r12,r5,-36
800055c2:	f0 1f 00 06 	mcall	800055d8 <xQueueCreate+0x6c>
800055c6:	0a 9c       	mov	r12,r5
800055c8:	d8 22       	popm	r4-r7,pc
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
800055ca:	0a 9c       	mov	r12,r5
800055cc:	f0 1f 00 04 	mcall	800055dc <xQueueCreate+0x70>
800055d0:	d8 2a       	popm	r4-r7,pc,r12=0
800055d2:	d8 2a       	popm	r4-r7,pc,r12=0
800055d4:	80 00       	ld.sh	r0,r0[0x0]
800055d6:	51 18       	stdsp	sp[0x44],r8
800055d8:	80 00       	ld.sh	r0,r0[0x0]
800055da:	4d 88       	lddpc	r8,80005738 <vTaskPriorityInherit+0x44>
800055dc:	80 00       	ld.sh	r0,r0[0x0]
800055de:	50 f0       	stdsp	sp[0x3c],r0

800055e0 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
800055e0:	48 38       	lddpc	r8,800055ec <vTaskSuspendAll+0xc>
800055e2:	70 09       	ld.w	r9,r8[0x0]
800055e4:	2f f9       	sub	r9,-1
800055e6:	91 09       	st.w	r8[0x0],r9
}
800055e8:	5e fc       	retal	r12
800055ea:	00 00       	add	r0,r0
800055ec:	00 00       	add	r0,r0
800055ee:	0c f8       	st.b	--r6,r8

800055f0 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
800055f0:	49 a8       	lddpc	r8,80005658 <vTaskSwitchContext+0x68>
800055f2:	70 08       	ld.w	r8,r8[0x0]
800055f4:	58 08       	cp.w	r8,0
800055f6:	c0 b1       	brne	8000560c <vTaskSwitchContext+0x1c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
800055f8:	49 98       	lddpc	r8,8000565c <vTaskSwitchContext+0x6c>
800055fa:	70 08       	ld.w	r8,r8[0x0]
800055fc:	f0 08 00 28 	add	r8,r8,r8<<0x2
80005600:	49 89       	lddpc	r9,80005660 <vTaskSwitchContext+0x70>
80005602:	f2 08 03 28 	ld.w	r8,r9[r8<<0x2]
80005606:	58 08       	cp.w	r8,0
80005608:	c0 60       	breq	80005614 <vTaskSwitchContext+0x24>
8000560a:	c1 18       	rjmp	8000562c <vTaskSwitchContext+0x3c>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
8000560c:	30 19       	mov	r9,1
8000560e:	49 68       	lddpc	r8,80005664 <vTaskSwitchContext+0x74>
80005610:	91 09       	st.w	r8[0x0],r9
80005612:	5e fc       	retal	r12

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80005614:	49 28       	lddpc	r8,8000565c <vTaskSwitchContext+0x6c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80005616:	49 3a       	lddpc	r10,80005660 <vTaskSwitchContext+0x70>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80005618:	70 09       	ld.w	r9,r8[0x0]
8000561a:	20 19       	sub	r9,1
8000561c:	91 09       	st.w	r8[0x0],r9

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
8000561e:	70 09       	ld.w	r9,r8[0x0]
80005620:	f2 09 00 29 	add	r9,r9,r9<<0x2
80005624:	f4 09 03 29 	ld.w	r9,r10[r9<<0x2]
80005628:	58 09       	cp.w	r9,0
8000562a:	cf 70       	breq	80005618 <vTaskSwitchContext+0x28>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
8000562c:	48 c8       	lddpc	r8,8000565c <vTaskSwitchContext+0x6c>
8000562e:	70 08       	ld.w	r8,r8[0x0]
80005630:	f0 08 00 28 	add	r8,r8,r8<<0x2
80005634:	48 b9       	lddpc	r9,80005660 <vTaskSwitchContext+0x70>
80005636:	f2 08 00 28 	add	r8,r9,r8<<0x2
8000563a:	70 19       	ld.w	r9,r8[0x4]
8000563c:	72 19       	ld.w	r9,r9[0x4]
8000563e:	91 19       	st.w	r8[0x4],r9
80005640:	f0 ca ff f8 	sub	r10,r8,-8
80005644:	14 39       	cp.w	r9,r10
80005646:	f3 f9 00 01 	ld.weq	r9,r9[0x4]
8000564a:	f1 f9 0a 01 	st.weq	r8[0x4],r9
8000564e:	70 18       	ld.w	r8,r8[0x4]
80005650:	70 39       	ld.w	r9,r8[0xc]
80005652:	48 68       	lddpc	r8,80005668 <vTaskSwitchContext+0x78>
80005654:	91 09       	st.w	r8[0x0],r9
80005656:	5e fc       	retal	r12
80005658:	00 00       	add	r0,r0
8000565a:	0c f8       	st.b	--r6,r8
8000565c:	00 00       	add	r0,r0
8000565e:	0d 30       	ld.ub	r0,r6++
80005660:	00 00       	add	r0,r0
80005662:	0c 14       	sub	r4,r6
80005664:	00 00       	add	r0,r0
80005666:	0d 18       	ld.sh	r8,r6++
80005668:	00 00       	add	r0,r0
8000566a:	0c c8       	st.b	r6++,r8

8000566c <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
8000566c:	48 48       	lddpc	r8,8000567c <vTaskSetTimeOutState+0x10>
8000566e:	70 08       	ld.w	r8,r8[0x0]
80005670:	99 08       	st.w	r12[0x0],r8
	pxTimeOut->xTimeOnEntering = xTickCount;
80005672:	48 48       	lddpc	r8,80005680 <vTaskSetTimeOutState+0x14>
80005674:	70 08       	ld.w	r8,r8[0x0]
80005676:	99 18       	st.w	r12[0x4],r8
}
80005678:	5e fc       	retal	r12
8000567a:	00 00       	add	r0,r0
8000567c:	00 00       	add	r0,r0
8000567e:	0c 0c       	add	r12,r6
80005680:	00 00       	add	r0,r0
80005682:	0c f4       	st.b	--r6,r4

80005684 <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
80005684:	30 19       	mov	r9,1
80005686:	48 28       	lddpc	r8,8000568c <vTaskMissedYield+0x8>
80005688:	91 09       	st.w	r8[0x0],r9
}
8000568a:	5e fc       	retal	r12
8000568c:	00 00       	add	r0,r0
8000568e:	0d 18       	ld.sh	r8,r6++

80005690 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
80005690:	48 28       	lddpc	r8,80005698 <xTaskGetCurrentTaskHandle+0x8>
80005692:	70 0c       	ld.w	r12,r8[0x0]

		return xReturn;
	}
80005694:	5e fc       	retal	r12
80005696:	00 00       	add	r0,r0
80005698:	00 00       	add	r0,r0
8000569a:	0c c8       	st.b	r6++,r8

8000569c <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
8000569c:	eb cd 40 c0 	pushm	r6-r7,lr
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
800056a0:	58 0c       	cp.w	r12,0
800056a2:	c1 f0       	breq	800056e0 <vTaskPriorityDisinherit+0x44>

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
800056a4:	18 97       	mov	r7,r12

		if( pxMutexHolder != NULL )
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
800056a6:	78 b9       	ld.w	r9,r12[0x2c]
800056a8:	79 18       	ld.w	r8,r12[0x44]
800056aa:	10 39       	cp.w	r9,r8
800056ac:	c1 a0       	breq	800056e0 <vTaskPriorityDisinherit+0x44>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
800056ae:	f8 c6 ff fc 	sub	r6,r12,-4
800056b2:	0c 9c       	mov	r12,r6
800056b4:	f0 1f 00 0c 	mcall	800056e4 <vTaskPriorityDisinherit+0x48>

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
800056b8:	6f 1c       	ld.w	r12,r7[0x44]
800056ba:	8f bc       	st.w	r7[0x2c],r12
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
800056bc:	f8 08 11 08 	rsub	r8,r12,8
800056c0:	8f 68       	st.w	r7[0x18],r8
				prvAddTaskToReadyQueue( pxTCB );
800056c2:	48 a8       	lddpc	r8,800056e8 <vTaskPriorityDisinherit+0x4c>
800056c4:	70 08       	ld.w	r8,r8[0x0]
800056c6:	10 3c       	cp.w	r12,r8
800056c8:	e0 88 00 04 	brls	800056d0 <vTaskPriorityDisinherit+0x34>
800056cc:	48 78       	lddpc	r8,800056e8 <vTaskPriorityDisinherit+0x4c>
800056ce:	91 0c       	st.w	r8[0x0],r12
800056d0:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800056d4:	0c 9b       	mov	r11,r6
800056d6:	48 68       	lddpc	r8,800056ec <vTaskPriorityDisinherit+0x50>
800056d8:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800056dc:	f0 1f 00 05 	mcall	800056f0 <vTaskPriorityDisinherit+0x54>
800056e0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800056e4:	80 00       	ld.sh	r0,r0[0x0]
800056e6:	4d f2       	lddpc	r2,80005860 <vTaskIncrementTick+0x6c>
800056e8:	00 00       	add	r0,r0
800056ea:	0d 30       	ld.ub	r0,r6++
800056ec:	00 00       	add	r0,r0
800056ee:	0c 14       	sub	r4,r6
800056f0:	80 00       	ld.sh	r0,r0[0x0]
800056f2:	4d a2       	lddpc	r2,80005858 <vTaskIncrementTick+0x64>

800056f4 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
800056f4:	eb cd 40 c0 	pushm	r6-r7,lr
800056f8:	18 97       	mov	r7,r12
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
800056fa:	49 b8       	lddpc	r8,80005764 <vTaskPriorityInherit+0x70>
800056fc:	70 08       	ld.w	r8,r8[0x0]
800056fe:	78 b9       	ld.w	r9,r12[0x2c]
80005700:	70 b8       	ld.w	r8,r8[0x2c]
80005702:	10 39       	cp.w	r9,r8
80005704:	c2 d2       	brcc	8000575e <vTaskPriorityInherit+0x6a>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
80005706:	49 88       	lddpc	r8,80005764 <vTaskPriorityInherit+0x70>
80005708:	70 08       	ld.w	r8,r8[0x0]
8000570a:	70 b8       	ld.w	r8,r8[0x2c]
8000570c:	f0 08 11 08 	rsub	r8,r8,8
80005710:	99 68       	st.w	r12[0x18],r8

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
80005712:	f2 09 00 28 	add	r8,r9,r9<<0x2
80005716:	49 59       	lddpc	r9,80005768 <vTaskPriorityInherit+0x74>
80005718:	f2 08 00 28 	add	r8,r9,r8<<0x2
8000571c:	78 59       	ld.w	r9,r12[0x14]
8000571e:	10 39       	cp.w	r9,r8
80005720:	c1 b1       	brne	80005756 <vTaskPriorityInherit+0x62>
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
80005722:	f8 c6 ff fc 	sub	r6,r12,-4
80005726:	0c 9c       	mov	r12,r6
80005728:	f0 1f 00 11 	mcall	8000576c <vTaskPriorityInherit+0x78>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
8000572c:	48 e8       	lddpc	r8,80005764 <vTaskPriorityInherit+0x70>
8000572e:	70 08       	ld.w	r8,r8[0x0]
80005730:	70 bc       	ld.w	r12,r8[0x2c]
80005732:	8f bc       	st.w	r7[0x2c],r12
				prvAddTaskToReadyQueue( pxTCB );
80005734:	48 f8       	lddpc	r8,80005770 <vTaskPriorityInherit+0x7c>
80005736:	70 08       	ld.w	r8,r8[0x0]
80005738:	10 3c       	cp.w	r12,r8
8000573a:	e0 88 00 04 	brls	80005742 <vTaskPriorityInherit+0x4e>
8000573e:	48 d8       	lddpc	r8,80005770 <vTaskPriorityInherit+0x7c>
80005740:	91 0c       	st.w	r8[0x0],r12
80005742:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005746:	0c 9b       	mov	r11,r6
80005748:	48 88       	lddpc	r8,80005768 <vTaskPriorityInherit+0x74>
8000574a:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
8000574e:	f0 1f 00 0a 	mcall	80005774 <vTaskPriorityInherit+0x80>
80005752:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
80005756:	48 48       	lddpc	r8,80005764 <vTaskPriorityInherit+0x70>
80005758:	70 08       	ld.w	r8,r8[0x0]
8000575a:	70 b8       	ld.w	r8,r8[0x2c]
8000575c:	99 b8       	st.w	r12[0x2c],r8
8000575e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005762:	00 00       	add	r0,r0
80005764:	00 00       	add	r0,r0
80005766:	0c c8       	st.b	r6++,r8
80005768:	00 00       	add	r0,r0
8000576a:	0c 14       	sub	r4,r6
8000576c:	80 00       	ld.sh	r0,r0[0x0]
8000576e:	4d f2       	lddpc	r2,800058e8 <vTaskIncrementTick+0xf4>
80005770:	00 00       	add	r0,r0
80005772:	0d 30       	ld.ub	r0,r6++
80005774:	80 00       	ld.sh	r0,r0[0x0]
80005776:	4d a2       	lddpc	r2,800058dc <vTaskIncrementTick+0xe8>

80005778 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
80005778:	eb cd 40 c0 	pushm	r6-r7,lr
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
8000577c:	78 38       	ld.w	r8,r12[0xc]
8000577e:	70 37       	ld.w	r7,r8[0xc]
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
80005780:	ee c6 ff e8 	sub	r6,r7,-24
80005784:	0c 9c       	mov	r12,r6
80005786:	f0 1f 00 15 	mcall	800057d8 <xTaskRemoveFromEventList+0x60>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
8000578a:	49 58       	lddpc	r8,800057dc <xTaskRemoveFromEventList+0x64>
8000578c:	70 08       	ld.w	r8,r8[0x0]
8000578e:	58 08       	cp.w	r8,0
80005790:	c1 71       	brne	800057be <xTaskRemoveFromEventList+0x46>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
80005792:	ee c6 ff fc 	sub	r6,r7,-4
80005796:	0c 9c       	mov	r12,r6
80005798:	f0 1f 00 10 	mcall	800057d8 <xTaskRemoveFromEventList+0x60>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
8000579c:	6e bc       	ld.w	r12,r7[0x2c]
8000579e:	49 18       	lddpc	r8,800057e0 <xTaskRemoveFromEventList+0x68>
800057a0:	70 08       	ld.w	r8,r8[0x0]
800057a2:	10 3c       	cp.w	r12,r8
800057a4:	e0 88 00 04 	brls	800057ac <xTaskRemoveFromEventList+0x34>
800057a8:	48 e8       	lddpc	r8,800057e0 <xTaskRemoveFromEventList+0x68>
800057aa:	91 0c       	st.w	r8[0x0],r12
800057ac:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800057b0:	0c 9b       	mov	r11,r6
800057b2:	48 d8       	lddpc	r8,800057e4 <xTaskRemoveFromEventList+0x6c>
800057b4:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800057b8:	f0 1f 00 0c 	mcall	800057e8 <xTaskRemoveFromEventList+0x70>
800057bc:	c0 58       	rjmp	800057c6 <xTaskRemoveFromEventList+0x4e>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
800057be:	0c 9b       	mov	r11,r6
800057c0:	48 bc       	lddpc	r12,800057ec <xTaskRemoveFromEventList+0x74>
800057c2:	f0 1f 00 0a 	mcall	800057e8 <xTaskRemoveFromEventList+0x70>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
800057c6:	48 b8       	lddpc	r8,800057f0 <xTaskRemoveFromEventList+0x78>
800057c8:	70 08       	ld.w	r8,r8[0x0]
800057ca:	6e b9       	ld.w	r9,r7[0x2c]
800057cc:	70 b8       	ld.w	r8,r8[0x2c]
800057ce:	10 39       	cp.w	r9,r8
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
800057d0:	5f 2c       	srhs	r12
800057d2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800057d6:	00 00       	add	r0,r0
800057d8:	80 00       	ld.sh	r0,r0[0x0]
800057da:	4d f2       	lddpc	r2,80005954 <xTaskCheckForTimeOut+0x4c>
800057dc:	00 00       	add	r0,r0
800057de:	0c f8       	st.b	--r6,r8
800057e0:	00 00       	add	r0,r0
800057e2:	0d 30       	ld.ub	r0,r6++
800057e4:	00 00       	add	r0,r0
800057e6:	0c 14       	sub	r4,r6
800057e8:	80 00       	ld.sh	r0,r0[0x0]
800057ea:	4d a2       	lddpc	r2,80005950 <xTaskCheckForTimeOut+0x48>
800057ec:	00 00       	add	r0,r0
800057ee:	0c cc       	st.b	r6++,r12
800057f0:	00 00       	add	r0,r0
800057f2:	0c c8       	st.b	r6++,r8

800057f4 <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
800057f4:	eb cd 40 fc 	pushm	r2-r7,lr
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
800057f8:	4b 98       	lddpc	r8,800058dc <vTaskIncrementTick+0xe8>
800057fa:	70 08       	ld.w	r8,r8[0x0]
800057fc:	58 08       	cp.w	r8,0
800057fe:	c6 91       	brne	800058d0 <vTaskIncrementTick+0xdc>
	{
		++xTickCount;
80005800:	4b 88       	lddpc	r8,800058e0 <vTaskIncrementTick+0xec>
80005802:	70 09       	ld.w	r9,r8[0x0]
80005804:	2f f9       	sub	r9,-1
80005806:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
80005808:	70 08       	ld.w	r8,r8[0x0]
8000580a:	58 08       	cp.w	r8,0
8000580c:	c1 a1       	brne	80005840 <vTaskIncrementTick+0x4c>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
8000580e:	4b 68       	lddpc	r8,800058e4 <vTaskIncrementTick+0xf0>
80005810:	70 0a       	ld.w	r10,r8[0x0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
80005812:	4b 69       	lddpc	r9,800058e8 <vTaskIncrementTick+0xf4>
80005814:	72 0b       	ld.w	r11,r9[0x0]
80005816:	91 0b       	st.w	r8[0x0],r11
			pxOverflowDelayedTaskList = pxTemp;
80005818:	93 0a       	st.w	r9[0x0],r10
			xNumOfOverflows++;
8000581a:	4b 59       	lddpc	r9,800058ec <vTaskIncrementTick+0xf8>
8000581c:	72 0a       	ld.w	r10,r9[0x0]
8000581e:	2f fa       	sub	r10,-1
80005820:	93 0a       	st.w	r9[0x0],r10

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
80005822:	70 08       	ld.w	r8,r8[0x0]
80005824:	70 08       	ld.w	r8,r8[0x0]
80005826:	58 08       	cp.w	r8,0
80005828:	c0 51       	brne	80005832 <vTaskIncrementTick+0x3e>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
8000582a:	3f f9       	mov	r9,-1
8000582c:	4b 18       	lddpc	r8,800058f0 <vTaskIncrementTick+0xfc>
8000582e:	91 09       	st.w	r8[0x0],r9
80005830:	c0 88       	rjmp	80005840 <vTaskIncrementTick+0x4c>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
80005832:	4a d8       	lddpc	r8,800058e4 <vTaskIncrementTick+0xf0>
80005834:	70 08       	ld.w	r8,r8[0x0]
80005836:	70 38       	ld.w	r8,r8[0xc]
80005838:	70 38       	ld.w	r8,r8[0xc]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
8000583a:	70 19       	ld.w	r9,r8[0x4]
8000583c:	4a d8       	lddpc	r8,800058f0 <vTaskIncrementTick+0xfc>
8000583e:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
80005840:	4a 88       	lddpc	r8,800058e0 <vTaskIncrementTick+0xec>
80005842:	70 09       	ld.w	r9,r8[0x0]
80005844:	4a b8       	lddpc	r8,800058f0 <vTaskIncrementTick+0xfc>
80005846:	70 08       	ld.w	r8,r8[0x0]
80005848:	10 39       	cp.w	r9,r8
8000584a:	c4 73       	brcs	800058d8 <vTaskIncrementTick+0xe4>
8000584c:	4a 68       	lddpc	r8,800058e4 <vTaskIncrementTick+0xf0>
8000584e:	70 08       	ld.w	r8,r8[0x0]
80005850:	70 08       	ld.w	r8,r8[0x0]
80005852:	58 08       	cp.w	r8,0
80005854:	c0 c0       	breq	8000586c <vTaskIncrementTick+0x78>
80005856:	4a 48       	lddpc	r8,800058e4 <vTaskIncrementTick+0xf0>
80005858:	70 08       	ld.w	r8,r8[0x0]
8000585a:	70 38       	ld.w	r8,r8[0xc]
8000585c:	70 37       	ld.w	r7,r8[0xc]
8000585e:	6e 18       	ld.w	r8,r7[0x4]
80005860:	4a 09       	lddpc	r9,800058e0 <vTaskIncrementTick+0xec>
80005862:	72 09       	ld.w	r9,r9[0x0]
80005864:	12 38       	cp.w	r8,r9
80005866:	e0 88 00 14 	brls	8000588e <vTaskIncrementTick+0x9a>
8000586a:	c0 e8       	rjmp	80005886 <vTaskIncrementTick+0x92>
8000586c:	3f f9       	mov	r9,-1
8000586e:	4a 18       	lddpc	r8,800058f0 <vTaskIncrementTick+0xfc>
80005870:	91 09       	st.w	r8[0x0],r9
80005872:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80005876:	6a 08       	ld.w	r8,r5[0x0]
80005878:	70 38       	ld.w	r8,r8[0xc]
8000587a:	70 37       	ld.w	r7,r8[0xc]
8000587c:	6e 18       	ld.w	r8,r7[0x4]
8000587e:	64 09       	ld.w	r9,r2[0x0]
80005880:	12 38       	cp.w	r8,r9
80005882:	e0 88 00 0a 	brls	80005896 <vTaskIncrementTick+0xa2>
80005886:	49 b9       	lddpc	r9,800058f0 <vTaskIncrementTick+0xfc>
80005888:	93 08       	st.w	r9[0x0],r8
8000588a:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
8000588e:	49 a4       	lddpc	r4,800058f4 <vTaskIncrementTick+0x100>
80005890:	49 a3       	lddpc	r3,800058f8 <vTaskIncrementTick+0x104>
80005892:	49 55       	lddpc	r5,800058e4 <vTaskIncrementTick+0xf0>
80005894:	49 32       	lddpc	r2,800058e0 <vTaskIncrementTick+0xec>
80005896:	ee c6 ff fc 	sub	r6,r7,-4
8000589a:	0c 9c       	mov	r12,r6
8000589c:	f0 1f 00 18 	mcall	800058fc <vTaskIncrementTick+0x108>
800058a0:	6e a8       	ld.w	r8,r7[0x28]
800058a2:	58 08       	cp.w	r8,0
800058a4:	c0 50       	breq	800058ae <vTaskIncrementTick+0xba>
800058a6:	ee cc ff e8 	sub	r12,r7,-24
800058aa:	f0 1f 00 15 	mcall	800058fc <vTaskIncrementTick+0x108>
800058ae:	6e bc       	ld.w	r12,r7[0x2c]
800058b0:	68 08       	ld.w	r8,r4[0x0]
800058b2:	10 3c       	cp.w	r12,r8
800058b4:	e9 fc ba 00 	st.whi	r4[0x0],r12
800058b8:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800058bc:	0c 9b       	mov	r11,r6
800058be:	e6 0c 00 2c 	add	r12,r3,r12<<0x2
800058c2:	f0 1f 00 10 	mcall	80005900 <vTaskIncrementTick+0x10c>
800058c6:	6a 08       	ld.w	r8,r5[0x0]
800058c8:	70 08       	ld.w	r8,r8[0x0]
800058ca:	58 08       	cp.w	r8,0
800058cc:	cd 51       	brne	80005876 <vTaskIncrementTick+0x82>
800058ce:	cc fb       	rjmp	8000586c <vTaskIncrementTick+0x78>
	}
	else
	{
		++uxMissedTicks;
800058d0:	48 d8       	lddpc	r8,80005904 <vTaskIncrementTick+0x110>
800058d2:	70 09       	ld.w	r9,r8[0x0]
800058d4:	2f f9       	sub	r9,-1
800058d6:	91 09       	st.w	r8[0x0],r9
800058d8:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800058dc:	00 00       	add	r0,r0
800058de:	0c f8       	st.b	--r6,r8
800058e0:	00 00       	add	r0,r0
800058e2:	0c f4       	st.b	--r6,r4
800058e4:	00 00       	add	r0,r0
800058e6:	0c 00       	add	r0,r6
800058e8:	00 00       	add	r0,r0
800058ea:	0c 10       	sub	r0,r6
800058ec:	00 00       	add	r0,r0
800058ee:	0c 0c       	add	r12,r6
800058f0:	00 00       	add	r0,r0
800058f2:	05 2c       	ld.uh	r12,r2++
800058f4:	00 00       	add	r0,r0
800058f6:	0d 30       	ld.ub	r0,r6++
800058f8:	00 00       	add	r0,r0
800058fa:	0c 14       	sub	r4,r6
800058fc:	80 00       	ld.sh	r0,r0[0x0]
800058fe:	4d f2       	lddpc	r2,80005a78 <xTaskResumeAll+0xdc>
80005900:	80 00       	ld.sh	r0,r0[0x0]
80005902:	4d a2       	lddpc	r2,80005a68 <xTaskResumeAll+0xcc>
80005904:	00 00       	add	r0,r0
80005906:	0b f8       	ld.ub	r8,r5[0x7]

80005908 <xTaskCheckForTimeOut>:
	pxTimeOut->xTimeOnEntering = xTickCount;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
80005908:	eb cd 40 c0 	pushm	r6-r7,lr
8000590c:	18 97       	mov	r7,r12
8000590e:	16 96       	mov	r6,r11
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
80005910:	f0 1f 00 15 	mcall	80005964 <xTaskCheckForTimeOut+0x5c>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
80005914:	6c 08       	ld.w	r8,r6[0x0]
80005916:	5b f8       	cp.w	r8,-1
80005918:	c0 31       	brne	8000591e <xTaskCheckForTimeOut+0x16>
8000591a:	30 07       	mov	r7,0
8000591c:	c1 f8       	rjmp	8000595a <xTaskCheckForTimeOut+0x52>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
8000591e:	49 39       	lddpc	r9,80005968 <xTaskCheckForTimeOut+0x60>
80005920:	72 09       	ld.w	r9,r9[0x0]
80005922:	6e 0a       	ld.w	r10,r7[0x0]
80005924:	12 3a       	cp.w	r10,r9
80005926:	c0 70       	breq	80005934 <xTaskCheckForTimeOut+0x2c>
80005928:	49 19       	lddpc	r9,8000596c <xTaskCheckForTimeOut+0x64>
8000592a:	72 09       	ld.w	r9,r9[0x0]
8000592c:	6e 1a       	ld.w	r10,r7[0x4]
8000592e:	12 3a       	cp.w	r10,r9
80005930:	e0 88 00 14 	brls	80005958 <xTaskCheckForTimeOut+0x50>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
80005934:	48 e9       	lddpc	r9,8000596c <xTaskCheckForTimeOut+0x64>
80005936:	72 0a       	ld.w	r10,r9[0x0]
80005938:	6e 19       	ld.w	r9,r7[0x4]
8000593a:	12 1a       	sub	r10,r9
8000593c:	14 38       	cp.w	r8,r10
8000593e:	e0 88 00 0d 	brls	80005958 <xTaskCheckForTimeOut+0x50>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
80005942:	48 ba       	lddpc	r10,8000596c <xTaskCheckForTimeOut+0x64>
80005944:	74 0a       	ld.w	r10,r10[0x0]
80005946:	14 19       	sub	r9,r10
80005948:	f2 08 00 08 	add	r8,r9,r8
8000594c:	8d 08       	st.w	r6[0x0],r8
			vTaskSetTimeOutState( pxTimeOut );
8000594e:	0e 9c       	mov	r12,r7
80005950:	f0 1f 00 08 	mcall	80005970 <xTaskCheckForTimeOut+0x68>
80005954:	30 07       	mov	r7,0
80005956:	c0 28       	rjmp	8000595a <xTaskCheckForTimeOut+0x52>
80005958:	30 17       	mov	r7,1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
8000595a:	f0 1f 00 07 	mcall	80005974 <xTaskCheckForTimeOut+0x6c>

	return xReturn;
}
8000595e:	0e 9c       	mov	r12,r7
80005960:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005964:	80 00       	ld.sh	r0,r0[0x0]
80005966:	4e ac       	lddpc	r12,80005b0c <vTaskDelayUntil+0x2c>
80005968:	00 00       	add	r0,r0
8000596a:	0c 0c       	add	r12,r6
8000596c:	00 00       	add	r0,r0
8000596e:	0c f4       	st.b	--r6,r4
80005970:	80 00       	ld.sh	r0,r0[0x0]
80005972:	56 6c       	stdsp	sp[0x198],r12
80005974:	80 00       	ld.sh	r0,r0[0x0]
80005976:	4f b8       	lddpc	r8,80005b60 <vTaskPlaceOnEventList>

80005978 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
80005978:	eb cd 40 80 	pushm	r7,lr
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
8000597c:	f0 1f 00 05 	mcall	80005990 <xTaskGetTickCount+0x18>
	{
		xTicks = xTickCount;
80005980:	48 58       	lddpc	r8,80005994 <xTaskGetTickCount+0x1c>
80005982:	70 07       	ld.w	r7,r8[0x0]
	}
	taskEXIT_CRITICAL();
80005984:	f0 1f 00 05 	mcall	80005998 <xTaskGetTickCount+0x20>

	return xTicks;
}
80005988:	0e 9c       	mov	r12,r7
8000598a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000598e:	00 00       	add	r0,r0
80005990:	80 00       	ld.sh	r0,r0[0x0]
80005992:	4e ac       	lddpc	r12,80005b38 <vTaskDelayUntil+0x58>
80005994:	00 00       	add	r0,r0
80005996:	0c f4       	st.b	--r6,r4
80005998:	80 00       	ld.sh	r0,r0[0x0]
8000599a:	4f b8       	lddpc	r8,80005b84 <vTaskPlaceOnEventList+0x24>

8000599c <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
8000599c:	eb cd 40 fe 	pushm	r1-r7,lr
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
800059a0:	f0 1f 00 2c 	mcall	80005a50 <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;
800059a4:	4a c8       	lddpc	r8,80005a54 <xTaskResumeAll+0xb8>
800059a6:	70 09       	ld.w	r9,r8[0x0]
800059a8:	20 19       	sub	r9,1
800059aa:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
800059ac:	70 08       	ld.w	r8,r8[0x0]
800059ae:	58 08       	cp.w	r8,0
800059b0:	c4 91       	brne	80005a42 <xTaskResumeAll+0xa6>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
800059b2:	4a a8       	lddpc	r8,80005a58 <xTaskResumeAll+0xbc>
800059b4:	70 08       	ld.w	r8,r8[0x0]
800059b6:	58 08       	cp.w	r8,0
800059b8:	c4 50       	breq	80005a42 <xTaskResumeAll+0xa6>
800059ba:	30 04       	mov	r4,0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
800059bc:	4a 85       	lddpc	r5,80005a5c <xTaskResumeAll+0xc0>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
800059be:	4a 93       	lddpc	r3,80005a60 <xTaskResumeAll+0xc4>
800059c0:	4a 92       	lddpc	r2,80005a64 <xTaskResumeAll+0xc8>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
800059c2:	4a a1       	lddpc	r1,80005a68 <xTaskResumeAll+0xcc>
800059c4:	c1 e8       	rjmp	80005a00 <xTaskResumeAll+0x64>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
800059c6:	6a 38       	ld.w	r8,r5[0xc]
800059c8:	70 37       	ld.w	r7,r8[0xc]
					vListRemove( &( pxTCB->xEventListItem ) );
800059ca:	ee cc ff e8 	sub	r12,r7,-24
800059ce:	f0 1f 00 28 	mcall	80005a6c <xTaskResumeAll+0xd0>
					vListRemove( &( pxTCB->xGenericListItem ) );
800059d2:	ee c6 ff fc 	sub	r6,r7,-4
800059d6:	0c 9c       	mov	r12,r6
800059d8:	f0 1f 00 25 	mcall	80005a6c <xTaskResumeAll+0xd0>
					prvAddTaskToReadyQueue( pxTCB );
800059dc:	6e bc       	ld.w	r12,r7[0x2c]
800059de:	66 08       	ld.w	r8,r3[0x0]
800059e0:	10 3c       	cp.w	r12,r8
800059e2:	e7 fc ba 00 	st.whi	r3[0x0],r12
800059e6:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800059ea:	0c 9b       	mov	r11,r6
800059ec:	e4 0c 00 2c 	add	r12,r2,r12<<0x2
800059f0:	f0 1f 00 20 	mcall	80005a70 <xTaskResumeAll+0xd4>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
800059f4:	62 08       	ld.w	r8,r1[0x0]
800059f6:	6e b9       	ld.w	r9,r7[0x2c]
800059f8:	70 b8       	ld.w	r8,r8[0x2c]
800059fa:	10 39       	cp.w	r9,r8
800059fc:	f9 b4 02 01 	movhs	r4,1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80005a00:	6a 08       	ld.w	r8,r5[0x0]
80005a02:	58 08       	cp.w	r8,0
80005a04:	ce 11       	brne	800059c6 <xTaskResumeAll+0x2a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80005a06:	49 c8       	lddpc	r8,80005a74 <xTaskResumeAll+0xd8>
80005a08:	70 08       	ld.w	r8,r8[0x0]
80005a0a:	58 08       	cp.w	r8,0
80005a0c:	c0 f0       	breq	80005a2a <xTaskResumeAll+0x8e>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80005a0e:	49 a8       	lddpc	r8,80005a74 <xTaskResumeAll+0xd8>
80005a10:	70 08       	ld.w	r8,r8[0x0]
80005a12:	58 08       	cp.w	r8,0
80005a14:	c1 10       	breq	80005a36 <xTaskResumeAll+0x9a>
					{
						vTaskIncrementTick();
						--uxMissedTicks;
80005a16:	49 87       	lddpc	r7,80005a74 <xTaskResumeAll+0xd8>
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
80005a18:	f0 1f 00 18 	mcall	80005a78 <xTaskResumeAll+0xdc>
						--uxMissedTicks;
80005a1c:	6e 08       	ld.w	r8,r7[0x0]
80005a1e:	20 18       	sub	r8,1
80005a20:	8f 08       	st.w	r7[0x0],r8
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80005a22:	6e 08       	ld.w	r8,r7[0x0]
80005a24:	58 08       	cp.w	r8,0
80005a26:	cf 91       	brne	80005a18 <xTaskResumeAll+0x7c>
80005a28:	c0 78       	rjmp	80005a36 <xTaskResumeAll+0x9a>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
80005a2a:	58 14       	cp.w	r4,1
80005a2c:	c0 50       	breq	80005a36 <xTaskResumeAll+0x9a>
80005a2e:	49 48       	lddpc	r8,80005a7c <xTaskResumeAll+0xe0>
80005a30:	70 08       	ld.w	r8,r8[0x0]
80005a32:	58 18       	cp.w	r8,1
80005a34:	c0 71       	brne	80005a42 <xTaskResumeAll+0xa6>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
80005a36:	30 09       	mov	r9,0
80005a38:	49 18       	lddpc	r8,80005a7c <xTaskResumeAll+0xe0>
80005a3a:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
80005a3c:	d7 33       	scall
80005a3e:	30 17       	mov	r7,1
80005a40:	c0 28       	rjmp	80005a44 <xTaskResumeAll+0xa8>
80005a42:	30 07       	mov	r7,0
				}
			}
		}
	}
	taskEXIT_CRITICAL();
80005a44:	f0 1f 00 0f 	mcall	80005a80 <xTaskResumeAll+0xe4>

	return xAlreadyYielded;
}
80005a48:	0e 9c       	mov	r12,r7
80005a4a:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
80005a4e:	00 00       	add	r0,r0
80005a50:	80 00       	ld.sh	r0,r0[0x0]
80005a52:	4e ac       	lddpc	r12,80005bf8 <prvIdleTask+0x40>
80005a54:	00 00       	add	r0,r0
80005a56:	0c f8       	st.b	--r6,r8
80005a58:	00 00       	add	r0,r0
80005a5a:	0d 14       	ld.sh	r4,r6++
80005a5c:	00 00       	add	r0,r0
80005a5e:	0c cc       	st.b	r6++,r12
80005a60:	00 00       	add	r0,r0
80005a62:	0d 30       	ld.ub	r0,r6++
80005a64:	00 00       	add	r0,r0
80005a66:	0c 14       	sub	r4,r6
80005a68:	00 00       	add	r0,r0
80005a6a:	0c c8       	st.b	r6++,r8
80005a6c:	80 00       	ld.sh	r0,r0[0x0]
80005a6e:	4d f2       	lddpc	r2,80005be8 <prvIdleTask+0x30>
80005a70:	80 00       	ld.sh	r0,r0[0x0]
80005a72:	4d a2       	lddpc	r2,80005bd8 <prvIdleTask+0x20>
80005a74:	00 00       	add	r0,r0
80005a76:	0b f8       	ld.ub	r8,r5[0x7]
80005a78:	80 00       	ld.sh	r0,r0[0x0]
80005a7a:	57 f4       	stdsp	sp[0x1fc],r4
80005a7c:	00 00       	add	r0,r0
80005a7e:	0d 18       	ld.sh	r8,r6++
80005a80:	80 00       	ld.sh	r0,r0[0x0]
80005a82:	4f b8       	lddpc	r8,80005c6c <xTaskGenericCreate+0x2c>

80005a84 <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
80005a84:	eb cd 40 80 	pushm	r7,lr
80005a88:	18 97       	mov	r7,r12
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
80005a8a:	49 08       	lddpc	r8,80005ac8 <prvAddCurrentTaskToDelayedList+0x44>
80005a8c:	70 08       	ld.w	r8,r8[0x0]
80005a8e:	91 1c       	st.w	r8[0x4],r12

	if( xTimeToWake < xTickCount )
80005a90:	48 f8       	lddpc	r8,80005acc <prvAddCurrentTaskToDelayedList+0x48>
80005a92:	70 08       	ld.w	r8,r8[0x0]
80005a94:	10 3c       	cp.w	r12,r8
80005a96:	c0 a2       	brcc	80005aaa <prvAddCurrentTaskToDelayedList+0x26>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005a98:	48 c8       	lddpc	r8,80005ac8 <prvAddCurrentTaskToDelayedList+0x44>
80005a9a:	70 0b       	ld.w	r11,r8[0x0]
80005a9c:	48 d8       	lddpc	r8,80005ad0 <prvAddCurrentTaskToDelayedList+0x4c>
80005a9e:	70 0c       	ld.w	r12,r8[0x0]
80005aa0:	2f cb       	sub	r11,-4
80005aa2:	f0 1f 00 0d 	mcall	80005ad4 <prvAddCurrentTaskToDelayedList+0x50>
80005aa6:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005aaa:	48 88       	lddpc	r8,80005ac8 <prvAddCurrentTaskToDelayedList+0x44>
80005aac:	70 0b       	ld.w	r11,r8[0x0]
80005aae:	48 b8       	lddpc	r8,80005ad8 <prvAddCurrentTaskToDelayedList+0x54>
80005ab0:	70 0c       	ld.w	r12,r8[0x0]
80005ab2:	2f cb       	sub	r11,-4
80005ab4:	f0 1f 00 08 	mcall	80005ad4 <prvAddCurrentTaskToDelayedList+0x50>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
80005ab8:	48 98       	lddpc	r8,80005adc <prvAddCurrentTaskToDelayedList+0x58>
80005aba:	70 08       	ld.w	r8,r8[0x0]
80005abc:	10 37       	cp.w	r7,r8
80005abe:	c0 32       	brcc	80005ac4 <prvAddCurrentTaskToDelayedList+0x40>
		{
			xNextTaskUnblockTime = xTimeToWake;
80005ac0:	48 78       	lddpc	r8,80005adc <prvAddCurrentTaskToDelayedList+0x58>
80005ac2:	91 07       	st.w	r8[0x0],r7
80005ac4:	e3 cd 80 80 	ldm	sp++,r7,pc
80005ac8:	00 00       	add	r0,r0
80005aca:	0c c8       	st.b	r6++,r8
80005acc:	00 00       	add	r0,r0
80005ace:	0c f4       	st.b	--r6,r4
80005ad0:	00 00       	add	r0,r0
80005ad2:	0c 10       	sub	r0,r6
80005ad4:	80 00       	ld.sh	r0,r0[0x0]
80005ad6:	4d be       	lddpc	lr,80005c40 <xTaskGenericCreate>
80005ad8:	00 00       	add	r0,r0
80005ada:	0c 00       	add	r0,r6
80005adc:	00 00       	add	r0,r0
80005ade:	05 2c       	ld.uh	r12,r2++

80005ae0 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
80005ae0:	eb cd 40 c0 	pushm	r6-r7,lr
80005ae4:	18 96       	mov	r6,r12
80005ae6:	16 97       	mov	r7,r11
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0 ) );

		vTaskSuspendAll();
80005ae8:	f0 1f 00 18 	mcall	80005b48 <vTaskDelayUntil+0x68>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
80005aec:	6c 08       	ld.w	r8,r6[0x0]
80005aee:	10 07       	add	r7,r8

			if( xTickCount < *pxPreviousWakeTime )
80005af0:	49 79       	lddpc	r9,80005b4c <vTaskDelayUntil+0x6c>
80005af2:	72 09       	ld.w	r9,r9[0x0]
80005af4:	12 38       	cp.w	r8,r9
80005af6:	e0 88 00 0c 	brls	80005b0e <vTaskDelayUntil+0x2e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
80005afa:	0e 38       	cp.w	r8,r7
80005afc:	e0 88 00 22 	brls	80005b40 <vTaskDelayUntil+0x60>
80005b00:	49 38       	lddpc	r8,80005b4c <vTaskDelayUntil+0x6c>
80005b02:	70 08       	ld.w	r8,r8[0x0]
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80005b04:	8d 07       	st.w	r6[0x0],r7

			if( xShouldDelay != pdFALSE )
80005b06:	10 37       	cp.w	r7,r8
80005b08:	e0 88 00 14 	brls	80005b30 <vTaskDelayUntil+0x50>
80005b0c:	c0 a8       	rjmp	80005b20 <vTaskDelayUntil+0x40>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
80005b0e:	0e 38       	cp.w	r8,r7
80005b10:	e0 8b 00 16 	brhi	80005b3c <vTaskDelayUntil+0x5c>
80005b14:	48 e8       	lddpc	r8,80005b4c <vTaskDelayUntil+0x6c>
80005b16:	70 08       	ld.w	r8,r8[0x0]
80005b18:	10 37       	cp.w	r7,r8
80005b1a:	e0 8b 00 11 	brhi	80005b3c <vTaskDelayUntil+0x5c>
80005b1e:	c1 18       	rjmp	80005b40 <vTaskDelayUntil+0x60>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005b20:	48 c8       	lddpc	r8,80005b50 <vTaskDelayUntil+0x70>
80005b22:	70 0c       	ld.w	r12,r8[0x0]
80005b24:	2f cc       	sub	r12,-4
80005b26:	f0 1f 00 0c 	mcall	80005b54 <vTaskDelayUntil+0x74>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
80005b2a:	0e 9c       	mov	r12,r7
80005b2c:	f0 1f 00 0b 	mcall	80005b58 <vTaskDelayUntil+0x78>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
80005b30:	f0 1f 00 0b 	mcall	80005b5c <vTaskDelayUntil+0x7c>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
80005b34:	c0 81       	brne	80005b44 <vTaskDelayUntil+0x64>
		{
			portYIELD_WITHIN_API();
80005b36:	d7 33       	scall
80005b38:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80005b3c:	8d 07       	st.w	r6[0x0],r7
80005b3e:	cf 1b       	rjmp	80005b20 <vTaskDelayUntil+0x40>
80005b40:	8d 07       	st.w	r6[0x0],r7
80005b42:	cf 7b       	rjmp	80005b30 <vTaskDelayUntil+0x50>
80005b44:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005b48:	80 00       	ld.sh	r0,r0[0x0]
80005b4a:	55 e0       	stdsp	sp[0x178],r0
80005b4c:	00 00       	add	r0,r0
80005b4e:	0c f4       	st.b	--r6,r4
80005b50:	00 00       	add	r0,r0
80005b52:	0c c8       	st.b	r6++,r8
80005b54:	80 00       	ld.sh	r0,r0[0x0]
80005b56:	4d f2       	lddpc	r2,80005cd0 <xTaskGenericCreate+0x90>
80005b58:	80 00       	ld.sh	r0,r0[0x0]
80005b5a:	5a 84       	cp.w	r4,-24
80005b5c:	80 00       	ld.sh	r0,r0[0x0]
80005b5e:	59 9c       	cp.w	r12,25

80005b60 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
80005b60:	eb cd 40 c0 	pushm	r6-r7,lr
80005b64:	16 96       	mov	r6,r11
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
80005b66:	48 e7       	lddpc	r7,80005b9c <vTaskPlaceOnEventList+0x3c>
80005b68:	6e 0b       	ld.w	r11,r7[0x0]
80005b6a:	2e 8b       	sub	r11,-24
80005b6c:	f0 1f 00 0d 	mcall	80005ba0 <vTaskPlaceOnEventList+0x40>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005b70:	6e 0c       	ld.w	r12,r7[0x0]
80005b72:	2f cc       	sub	r12,-4
80005b74:	f0 1f 00 0c 	mcall	80005ba4 <vTaskPlaceOnEventList+0x44>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
80005b78:	5b f6       	cp.w	r6,-1
80005b7a:	c0 81       	brne	80005b8a <vTaskPlaceOnEventList+0x2a>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005b7c:	6e 0b       	ld.w	r11,r7[0x0]
80005b7e:	2f cb       	sub	r11,-4
80005b80:	48 ac       	lddpc	r12,80005ba8 <vTaskPlaceOnEventList+0x48>
80005b82:	f0 1f 00 0b 	mcall	80005bac <vTaskPlaceOnEventList+0x4c>
80005b86:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
80005b8a:	48 a8       	lddpc	r8,80005bb0 <vTaskPlaceOnEventList+0x50>
80005b8c:	70 0c       	ld.w	r12,r8[0x0]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
80005b8e:	ec 0c 00 0c 	add	r12,r6,r12
80005b92:	f0 1f 00 09 	mcall	80005bb4 <vTaskPlaceOnEventList+0x54>
80005b96:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005b9a:	00 00       	add	r0,r0
80005b9c:	00 00       	add	r0,r0
80005b9e:	0c c8       	st.b	r6++,r8
80005ba0:	80 00       	ld.sh	r0,r0[0x0]
80005ba2:	4d be       	lddpc	lr,80005d0c <xTaskGenericCreate+0xcc>
80005ba4:	80 00       	ld.sh	r0,r0[0x0]
80005ba6:	4d f2       	lddpc	r2,80005d20 <xTaskGenericCreate+0xe0>
80005ba8:	00 00       	add	r0,r0
80005baa:	0d 1c       	ld.sh	r12,r6++
80005bac:	80 00       	ld.sh	r0,r0[0x0]
80005bae:	4d a2       	lddpc	r2,80005d14 <xTaskGenericCreate+0xd4>
80005bb0:	00 00       	add	r0,r0
80005bb2:	0c f4       	st.b	--r6,r4
80005bb4:	80 00       	ld.sh	r0,r0[0x0]
80005bb6:	5a 84       	cp.w	r4,-24

80005bb8 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
80005bb8:	eb cd 40 f8 	pushm	r3-r7,lr
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80005bbc:	49 67       	lddpc	r7,80005c14 <prvIdleTask+0x5c>
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80005bbe:	49 74       	lddpc	r4,80005c18 <prvIdleTask+0x60>

				taskENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					--uxCurrentNumberOfTasks;
80005bc0:	49 73       	lddpc	r3,80005c1c <prvIdleTask+0x64>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80005bc2:	49 85       	lddpc	r5,80005c20 <prvIdleTask+0x68>
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80005bc4:	6e 08       	ld.w	r8,r7[0x0]
80005bc6:	58 08       	cp.w	r8,0
80005bc8:	c1 e0       	breq	80005c04 <prvIdleTask+0x4c>
		{
			vTaskSuspendAll();
80005bca:	f0 1f 00 17 	mcall	80005c24 <prvIdleTask+0x6c>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80005bce:	68 06       	ld.w	r6,r4[0x0]
			xTaskResumeAll();
80005bd0:	f0 1f 00 16 	mcall	80005c28 <prvIdleTask+0x70>

			if( xListIsEmpty == pdFALSE )
80005bd4:	58 06       	cp.w	r6,0
80005bd6:	c1 70       	breq	80005c04 <prvIdleTask+0x4c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
80005bd8:	f0 1f 00 15 	mcall	80005c2c <prvIdleTask+0x74>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
80005bdc:	68 38       	ld.w	r8,r4[0xc]
80005bde:	70 36       	ld.w	r6,r8[0xc]
					vListRemove( &( pxTCB->xGenericListItem ) );
80005be0:	ec cc ff fc 	sub	r12,r6,-4
80005be4:	f0 1f 00 13 	mcall	80005c30 <prvIdleTask+0x78>
					--uxCurrentNumberOfTasks;
80005be8:	66 08       	ld.w	r8,r3[0x0]
80005bea:	20 18       	sub	r8,1
80005bec:	87 08       	st.w	r3[0x0],r8
					--uxTasksDeleted;
80005bee:	6e 08       	ld.w	r8,r7[0x0]
80005bf0:	20 18       	sub	r8,1
80005bf2:	8f 08       	st.w	r7[0x0],r8
				}
				taskEXIT_CRITICAL();
80005bf4:	f0 1f 00 10 	mcall	80005c34 <prvIdleTask+0x7c>

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
80005bf8:	6c cc       	ld.w	r12,r6[0x30]
80005bfa:	f0 1f 00 10 	mcall	80005c38 <prvIdleTask+0x80>
		vPortFree( pxTCB );
80005bfe:	0c 9c       	mov	r12,r6
80005c00:	f0 1f 00 0e 	mcall	80005c38 <prvIdleTask+0x80>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80005c04:	6a 08       	ld.w	r8,r5[0x0]
80005c06:	58 18       	cp.w	r8,1
80005c08:	e0 88 00 03 	brls	80005c0e <prvIdleTask+0x56>
			{
				taskYIELD();
80005c0c:	d7 33       	scall
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
80005c0e:	f0 1f 00 0c 	mcall	80005c3c <prvIdleTask+0x84>
		}
		#endif
	}
80005c12:	cd 9b       	rjmp	80005bc4 <prvIdleTask+0xc>
80005c14:	00 00       	add	r0,r0
80005c16:	0c 08       	add	r8,r6
80005c18:	00 00       	add	r0,r0
80005c1a:	0c b4       	st.h	r6++,r4
80005c1c:	00 00       	add	r0,r0
80005c1e:	0d 14       	ld.sh	r4,r6++
80005c20:	00 00       	add	r0,r0
80005c22:	0c 14       	sub	r4,r6
80005c24:	80 00       	ld.sh	r0,r0[0x0]
80005c26:	55 e0       	stdsp	sp[0x178],r0
80005c28:	80 00       	ld.sh	r0,r0[0x0]
80005c2a:	59 9c       	cp.w	r12,25
80005c2c:	80 00       	ld.sh	r0,r0[0x0]
80005c2e:	4e ac       	lddpc	r12,80005dd4 <xTaskGenericCreate+0x194>
80005c30:	80 00       	ld.sh	r0,r0[0x0]
80005c32:	4d f2       	lddpc	r2,80005dac <xTaskGenericCreate+0x16c>
80005c34:	80 00       	ld.sh	r0,r0[0x0]
80005c36:	4f b8       	lddpc	r8,80005e20 <xTaskGenericCreate+0x1e0>
80005c38:	80 00       	ld.sh	r0,r0[0x0]
80005c3a:	50 f0       	stdsp	sp[0x3c],r0
80005c3c:	80 00       	ld.sh	r0,r0[0x0]
80005c3e:	20 30       	sub	r0,3

80005c40 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
80005c40:	d4 31       	pushm	r0-r7,lr
80005c42:	20 1d       	sub	sp,4
80005c44:	fa c4 ff d8 	sub	r4,sp,-40
80005c48:	50 0c       	stdsp	sp[0x0],r12
80005c4a:	16 91       	mov	r1,r11
80005c4c:	14 97       	mov	r7,r10
80005c4e:	12 90       	mov	r0,r9
80005c50:	10 93       	mov	r3,r8
80005c52:	68 02       	ld.w	r2,r4[0x0]
80005c54:	68 16       	ld.w	r6,r4[0x4]
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
80005c56:	34 8c       	mov	r12,72
80005c58:	f0 1f 00 5c 	mcall	80005dc8 <xTaskGenericCreate+0x188>
80005c5c:	18 95       	mov	r5,r12

	if( pxNewTCB != NULL )
80005c5e:	c0 31       	brne	80005c64 <xTaskGenericCreate+0x24>
80005c60:	3f fc       	mov	r12,-1
80005c62:	ca f8       	rjmp	80005dc0 <xTaskGenericCreate+0x180>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80005c64:	58 06       	cp.w	r6,0
80005c66:	e0 81 00 af 	brne	80005dc4 <xTaskGenericCreate+0x184>
80005c6a:	0e 9c       	mov	r12,r7
80005c6c:	5c 7c       	castu.h	r12
80005c6e:	a3 6c       	lsl	r12,0x2
80005c70:	f0 1f 00 56 	mcall	80005dc8 <xTaskGenericCreate+0x188>
80005c74:	18 96       	mov	r6,r12
80005c76:	8b cc       	st.w	r5[0x30],r12

		if( pxNewTCB->pxStack == NULL )
80005c78:	c0 61       	brne	80005c84 <xTaskGenericCreate+0x44>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
80005c7a:	0a 9c       	mov	r12,r5
80005c7c:	f0 1f 00 54 	mcall	80005dcc <xTaskGenericCreate+0x18c>
80005c80:	3f fc       	mov	r12,-1
80005c82:	c9 f8       	rjmp	80005dc0 <xTaskGenericCreate+0x180>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
80005c84:	5c 77       	castu.h	r7
80005c86:	ee 0a 15 02 	lsl	r10,r7,0x2
80005c8a:	e0 6b 00 a5 	mov	r11,165
80005c8e:	0c 9c       	mov	r12,r6
80005c90:	f0 1f 00 50 	mcall	80005dd0 <xTaskGenericCreate+0x190>
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
80005c94:	ee c6 00 01 	sub	r6,r7,1
80005c98:	6a c8       	ld.w	r8,r5[0x30]
80005c9a:	f0 06 00 26 	add	r6,r8,r6<<0x2
80005c9e:	e0 16 ff fc 	andl	r6,0xfffc
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
80005ca2:	31 0a       	mov	r10,16
80005ca4:	02 9b       	mov	r11,r1
80005ca6:	ea cc ff cc 	sub	r12,r5,-52
80005caa:	f0 1f 00 4b 	mcall	80005dd4 <xTaskGenericCreate+0x194>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
80005cae:	30 08       	mov	r8,0
80005cb0:	eb 68 00 43 	st.b	r5[67],r8
80005cb4:	58 73       	cp.w	r3,7
80005cb6:	e6 07 17 80 	movls	r7,r3
80005cba:	f9 b7 0b 07 	movhi	r7,7
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
80005cbe:	8b b7       	st.w	r5[0x2c],r7
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
80005cc0:	eb 47 00 44 	st.w	r5[68],r7
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
80005cc4:	ea c4 ff fc 	sub	r4,r5,-4
80005cc8:	08 9c       	mov	r12,r4
80005cca:	f0 1f 00 44 	mcall	80005dd8 <xTaskGenericCreate+0x198>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
80005cce:	ea cc ff e8 	sub	r12,r5,-24
80005cd2:	f0 1f 00 42 	mcall	80005dd8 <xTaskGenericCreate+0x198>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
80005cd6:	8b 45       	st.w	r5[0x10],r5

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
80005cd8:	ee 07 11 08 	rsub	r7,r7,8
80005cdc:	8b 67       	st.w	r5[0x18],r7
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
80005cde:	8b 95       	st.w	r5[0x24],r5
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
80005ce0:	00 9a       	mov	r10,r0
80005ce2:	40 0b       	lddsp	r11,sp[0x0]
80005ce4:	0c 9c       	mov	r12,r6
80005ce6:	f0 1f 00 3e 	mcall	80005ddc <xTaskGenericCreate+0x19c>
80005cea:	8b 0c       	st.w	r5[0x0],r12
		if( ( void * ) pxCreatedTask != NULL )
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
80005cec:	58 02       	cp.w	r2,0
80005cee:	e5 f5 1a 00 	st.wne	r2[0x0],r5
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
80005cf2:	f0 1f 00 3c 	mcall	80005de0 <xTaskGenericCreate+0x1a0>
		{
			uxCurrentNumberOfTasks++;
80005cf6:	4b c8       	lddpc	r8,80005de4 <xTaskGenericCreate+0x1a4>
80005cf8:	70 09       	ld.w	r9,r8[0x0]
80005cfa:	2f f9       	sub	r9,-1
80005cfc:	91 09       	st.w	r8[0x0],r9
			if( pxCurrentTCB == NULL )
80005cfe:	4b b8       	lddpc	r8,80005de8 <xTaskGenericCreate+0x1a8>
80005d00:	70 08       	ld.w	r8,r8[0x0]
80005d02:	58 08       	cp.w	r8,0
80005d04:	c2 61       	brne	80005d50 <xTaskGenericCreate+0x110>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
80005d06:	4b 98       	lddpc	r8,80005de8 <xTaskGenericCreate+0x1a8>
80005d08:	91 05       	st.w	r8[0x0],r5

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
80005d0a:	4b 78       	lddpc	r8,80005de4 <xTaskGenericCreate+0x1a4>
80005d0c:	70 08       	ld.w	r8,r8[0x0]
80005d0e:	58 18       	cp.w	r8,1
80005d10:	c2 b1       	brne	80005d66 <xTaskGenericCreate+0x126>
80005d12:	4b 77       	lddpc	r7,80005dec <xTaskGenericCreate+0x1ac>

/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
80005d14:	ee c6 ff 60 	sub	r6,r7,-160
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
80005d18:	0e 9c       	mov	r12,r7
80005d1a:	f0 1f 00 36 	mcall	80005df0 <xTaskGenericCreate+0x1b0>
80005d1e:	2e c7       	sub	r7,-20

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
80005d20:	0c 37       	cp.w	r7,r6
80005d22:	cf b1       	brne	80005d18 <xTaskGenericCreate+0xd8>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
80005d24:	4b 47       	lddpc	r7,80005df4 <xTaskGenericCreate+0x1b4>
80005d26:	0e 9c       	mov	r12,r7
80005d28:	f0 1f 00 32 	mcall	80005df0 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
80005d2c:	4b 36       	lddpc	r6,80005df8 <xTaskGenericCreate+0x1b8>
80005d2e:	0c 9c       	mov	r12,r6
80005d30:	f0 1f 00 30 	mcall	80005df0 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xPendingReadyList );
80005d34:	4b 2c       	lddpc	r12,80005dfc <xTaskGenericCreate+0x1bc>
80005d36:	f0 1f 00 2f 	mcall	80005df0 <xTaskGenericCreate+0x1b0>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
80005d3a:	4b 2c       	lddpc	r12,80005e00 <xTaskGenericCreate+0x1c0>
80005d3c:	f0 1f 00 2d 	mcall	80005df0 <xTaskGenericCreate+0x1b0>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
80005d40:	4b 1c       	lddpc	r12,80005e04 <xTaskGenericCreate+0x1c4>
80005d42:	f0 1f 00 2c 	mcall	80005df0 <xTaskGenericCreate+0x1b0>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
80005d46:	4b 18       	lddpc	r8,80005e08 <xTaskGenericCreate+0x1c8>
80005d48:	91 07       	st.w	r8[0x0],r7
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
80005d4a:	4b 18       	lddpc	r8,80005e0c <xTaskGenericCreate+0x1cc>
80005d4c:	91 06       	st.w	r8[0x0],r6
80005d4e:	c0 c8       	rjmp	80005d66 <xTaskGenericCreate+0x126>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
80005d50:	4b 08       	lddpc	r8,80005e10 <xTaskGenericCreate+0x1d0>
80005d52:	70 08       	ld.w	r8,r8[0x0]
80005d54:	58 08       	cp.w	r8,0
80005d56:	c0 81       	brne	80005d66 <xTaskGenericCreate+0x126>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
80005d58:	4a 48       	lddpc	r8,80005de8 <xTaskGenericCreate+0x1a8>
80005d5a:	70 08       	ld.w	r8,r8[0x0]
80005d5c:	70 b8       	ld.w	r8,r8[0x2c]
80005d5e:	10 33       	cp.w	r3,r8
80005d60:	c0 33       	brcs	80005d66 <xTaskGenericCreate+0x126>
					{
						pxCurrentTCB = pxNewTCB;
80005d62:	4a 28       	lddpc	r8,80005de8 <xTaskGenericCreate+0x1a8>
80005d64:	91 05       	st.w	r8[0x0],r5
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
80005d66:	6a b8       	ld.w	r8,r5[0x2c]
80005d68:	4a b9       	lddpc	r9,80005e14 <xTaskGenericCreate+0x1d4>
80005d6a:	72 09       	ld.w	r9,r9[0x0]
80005d6c:	12 38       	cp.w	r8,r9
80005d6e:	e0 88 00 04 	brls	80005d76 <xTaskGenericCreate+0x136>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
80005d72:	4a 99       	lddpc	r9,80005e14 <xTaskGenericCreate+0x1d4>
80005d74:	93 08       	st.w	r9[0x0],r8
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
80005d76:	4a 98       	lddpc	r8,80005e18 <xTaskGenericCreate+0x1d8>
80005d78:	70 09       	ld.w	r9,r8[0x0]
80005d7a:	2f f9       	sub	r9,-1
80005d7c:	91 09       	st.w	r8[0x0],r9

			prvAddTaskToReadyQueue( pxNewTCB );
80005d7e:	6a b8       	ld.w	r8,r5[0x2c]
80005d80:	4a 79       	lddpc	r9,80005e1c <xTaskGenericCreate+0x1dc>
80005d82:	72 09       	ld.w	r9,r9[0x0]
80005d84:	12 38       	cp.w	r8,r9
80005d86:	e0 88 00 04 	brls	80005d8e <xTaskGenericCreate+0x14e>
80005d8a:	4a 59       	lddpc	r9,80005e1c <xTaskGenericCreate+0x1dc>
80005d8c:	93 08       	st.w	r9[0x0],r8
80005d8e:	6a bc       	ld.w	r12,r5[0x2c]
80005d90:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005d94:	08 9b       	mov	r11,r4
80005d96:	49 68       	lddpc	r8,80005dec <xTaskGenericCreate+0x1ac>
80005d98:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80005d9c:	f0 1f 00 21 	mcall	80005e20 <xTaskGenericCreate+0x1e0>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
80005da0:	f0 1f 00 21 	mcall	80005e24 <xTaskGenericCreate+0x1e4>
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
80005da4:	49 b8       	lddpc	r8,80005e10 <xTaskGenericCreate+0x1d0>
80005da6:	70 08       	ld.w	r8,r8[0x0]
80005da8:	58 08       	cp.w	r8,0
80005daa:	c0 a0       	breq	80005dbe <xTaskGenericCreate+0x17e>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
80005dac:	48 f8       	lddpc	r8,80005de8 <xTaskGenericCreate+0x1a8>
80005dae:	70 08       	ld.w	r8,r8[0x0]
80005db0:	70 b8       	ld.w	r8,r8[0x2c]
80005db2:	10 33       	cp.w	r3,r8
80005db4:	e0 88 00 05 	brls	80005dbe <xTaskGenericCreate+0x17e>
			{
				portYIELD_WITHIN_API();
80005db8:	d7 33       	scall
80005dba:	30 1c       	mov	r12,1
80005dbc:	c0 28       	rjmp	80005dc0 <xTaskGenericCreate+0x180>
80005dbe:	30 1c       	mov	r12,1
			}
		}
	}

	return xReturn;
}
80005dc0:	2f fd       	sub	sp,-4
80005dc2:	d8 32       	popm	r0-r7,pc
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80005dc4:	99 c6       	st.w	r12[0x30],r6
80005dc6:	c5 fb       	rjmp	80005c84 <xTaskGenericCreate+0x44>
80005dc8:	80 00       	ld.sh	r0,r0[0x0]
80005dca:	51 18       	stdsp	sp[0x44],r8
80005dcc:	80 00       	ld.sh	r0,r0[0x0]
80005dce:	50 f0       	stdsp	sp[0x3c],r0
80005dd0:	80 00       	ld.sh	r0,r0[0x0]
80005dd2:	6a a4       	ld.w	r4,r5[0x28]
80005dd4:	80 00       	ld.sh	r0,r0[0x0]
80005dd6:	6d e8       	ld.w	r8,r6[0x78]
80005dd8:	80 00       	ld.sh	r0,r0[0x0]
80005dda:	4d 9c       	lddpc	r12,80005f3c <PrintDec+0x12>
80005ddc:	80 00       	ld.sh	r0,r0[0x0]
80005dde:	4e 18       	lddpc	r8,80005f60 <PrintDec+0x36>
80005de0:	80 00       	ld.sh	r0,r0[0x0]
80005de2:	4e ac       	lddpc	r12,80005f88 <PrintDec+0x5e>
80005de4:	00 00       	add	r0,r0
80005de6:	0d 14       	ld.sh	r4,r6++
80005de8:	00 00       	add	r0,r0
80005dea:	0c c8       	st.b	r6++,r8
80005dec:	00 00       	add	r0,r0
80005dee:	0c 14       	sub	r4,r6
80005df0:	80 00       	ld.sh	r0,r0[0x0]
80005df2:	4d 88       	lddpc	r8,80005f50 <PrintDec+0x26>
80005df4:	00 00       	add	r0,r0
80005df6:	0c e0       	st.h	--r6,r0
80005df8:	00 00       	add	r0,r0
80005dfa:	0c fc       	st.b	--r6,r12
80005dfc:	00 00       	add	r0,r0
80005dfe:	0c cc       	st.b	r6++,r12
80005e00:	00 00       	add	r0,r0
80005e02:	0c b4       	st.h	r6++,r4
80005e04:	00 00       	add	r0,r0
80005e06:	0d 1c       	ld.sh	r12,r6++
80005e08:	00 00       	add	r0,r0
80005e0a:	0c 00       	add	r0,r6
80005e0c:	00 00       	add	r0,r0
80005e0e:	0c 10       	sub	r0,r6
80005e10:	00 00       	add	r0,r0
80005e12:	0c 04       	add	r4,r6
80005e14:	00 00       	add	r0,r0
80005e16:	0b fc       	ld.ub	r12,r5[0x7]
80005e18:	00 00       	add	r0,r0
80005e1a:	0d 10       	ld.sh	r0,r6++
80005e1c:	00 00       	add	r0,r0
80005e1e:	0d 30       	ld.ub	r0,r6++
80005e20:	80 00       	ld.sh	r0,r0[0x0]
80005e22:	4d a2       	lddpc	r2,80005f88 <PrintDec+0x5e>
80005e24:	80 00       	ld.sh	r0,r0[0x0]
80005e26:	4f b8       	lddpc	r8,80006010 <log+0xc>

80005e28 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
80005e28:	d4 01       	pushm	lr
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
80005e2a:	30 09       	mov	r9,0
80005e2c:	1a d9       	st.w	--sp,r9
80005e2e:	1a d9       	st.w	--sp,r9
80005e30:	1a d9       	st.w	--sp,r9
80005e32:	12 98       	mov	r8,r9
80005e34:	e0 6a 01 00 	mov	r10,256
80005e38:	48 9b       	lddpc	r11,80005e5c <vTaskStartScheduler+0x34>
80005e3a:	48 ac       	lddpc	r12,80005e60 <vTaskStartScheduler+0x38>
80005e3c:	f0 1f 00 0a 	mcall	80005e64 <vTaskStartScheduler+0x3c>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
80005e40:	2f dd       	sub	sp,-12
80005e42:	58 1c       	cp.w	r12,1
80005e44:	c0 a1       	brne	80005e58 <vTaskStartScheduler+0x30>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
80005e46:	d3 03       	ssrf	0x10

		xSchedulerRunning = pdTRUE;
80005e48:	30 19       	mov	r9,1
80005e4a:	48 88       	lddpc	r8,80005e68 <vTaskStartScheduler+0x40>
80005e4c:	91 09       	st.w	r8[0x0],r9
		xTickCount = ( portTickType ) 0;
80005e4e:	30 09       	mov	r9,0
80005e50:	48 78       	lddpc	r8,80005e6c <vTaskStartScheduler+0x44>
80005e52:	91 09       	st.w	r8[0x0],r9
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
80005e54:	f0 1f 00 07 	mcall	80005e70 <vTaskStartScheduler+0x48>
80005e58:	d8 02       	popm	pc
80005e5a:	00 00       	add	r0,r0
80005e5c:	80 00       	ld.sh	r0,r0[0x0]
80005e5e:	c8 7c       	rcall	80005f6c <PrintDec+0x42>
80005e60:	80 00       	ld.sh	r0,r0[0x0]
80005e62:	5b b8       	cp.w	r8,-5
80005e64:	80 00       	ld.sh	r0,r0[0x0]
80005e66:	5c 40       	abs	r0
80005e68:	00 00       	add	r0,r0
80005e6a:	0c 04       	add	r4,r6
80005e6c:	00 00       	add	r0,r0
80005e6e:	0c f4       	st.b	--r6,r4
80005e70:	80 00       	ld.sh	r0,r0[0x0]
80005e72:	4e bc       	lddpc	r12,8000601c <log+0x18>

80005e74 <PrintChar>:
	
static void task_log(void * pvParameters);

char *  PrintChar(char c, char * str)
{
	*str++ = c;
80005e74:	16 cc       	st.b	r11++,r12
	return str;
}
80005e76:	5e fb       	retal	r11

80005e78 <PrintHex>:
	
	return str;
}

char * PrintHex(int i,char len, char * str)
{
80005e78:	eb cd 40 c0 	pushm	r6-r7,lr
80005e7c:	20 3d       	sub	sp,12
80005e7e:	18 98       	mov	r8,r12
	char * p = str;
	char s[12];
	memset(s, 0 , 12);
80005e80:	30 06       	mov	r6,0
80005e82:	30 07       	mov	r7,0
80005e84:	fa e7 00 00 	st.d	sp[0],r6
80005e88:	30 0c       	mov	r12,0
80005e8a:	50 2c       	stdsp	sp[0x8],r12
	int cnt=0;
	
	if(i)
80005e8c:	58 08       	cp.w	r8,0
80005e8e:	c1 30       	breq	80005eb4 <PrintHex+0x3c>
80005e90:	18 99       	mov	r9,r12
	while(i)
	{
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
80005e92:	1a 9c       	mov	r12,sp
80005e94:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80005e98:	58 9e       	cp.w	lr,9
80005e9a:	e0 8a 00 04 	brle	80005ea2 <PrintHex+0x2a>
80005e9e:	2c 9e       	sub	lr,-55
80005ea0:	c0 48       	rjmp	80005ea8 <PrintHex+0x30>
80005ea2:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80005ea6:	2d 0e       	sub	lr,-48
80005ea8:	f8 09 0b 0e 	st.b	r12[r9],lr
80005eac:	2f f9       	sub	r9,-1
		i = (i >> 4 ) & 0x0FFFFFFF;
80005eae:	a5 88       	lsr	r8,0x4
	char s[12];
	memset(s, 0 , 12);
	int cnt=0;
	
	if(i)
	while(i)
80005eb0:	cf 21       	brne	80005e94 <PrintHex+0x1c>
80005eb2:	c0 48       	rjmp	80005eba <PrintHex+0x42>
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
		i = (i >> 4 ) & 0x0FFFFFFF;
		//i >>= 4
	}
	else
	s[cnt++] = '0';
80005eb4:	33 08       	mov	r8,48
80005eb6:	ba 88       	st.b	sp[0x0],r8
80005eb8:	30 19       	mov	r9,1
	
	if(len - cnt > 0 )
80005eba:	f6 09 01 08 	sub	r8,r11,r9
80005ebe:	58 08       	cp.w	r8,0
80005ec0:	e0 8a 00 13 	brle	80005ee6 <PrintHex+0x6e>
	{
		char num = len - cnt;
80005ec4:	12 1b       	sub	r11,r9
80005ec6:	f9 db c0 08 	bfextu	r12,r11,0x0,0x8
		for(int i = 0; i < num; i++)
80005eca:	18 9e       	mov	lr,r12
80005ecc:	58 0c       	cp.w	r12,0
80005ece:	e0 8a 00 0c 	brle	80005ee6 <PrintHex+0x6e>
80005ed2:	1a 9b       	mov	r11,sp
80005ed4:	12 0b       	add	r11,r9
80005ed6:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80005ed8:	33 07       	mov	r7,48
80005eda:	16 c7       	st.b	r11++,r7
	s[cnt++] = '0';
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80005edc:	2f f8       	sub	r8,-1
80005ede:	1c 38       	cp.w	r8,lr
80005ee0:	cf d5       	brlt	80005eda <PrintHex+0x62>
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80005ee2:	f8 09 00 09 	add	r9,r12,r9
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80005ee6:	f2 c8 ff ff 	sub	r8,r9,-1
	s[cnt++] = '0';
	
	while(cnt>0)
80005eea:	f0 cb ff ff 	sub	r11,r8,-1
80005eee:	58 0b       	cp.w	r11,0
80005ef0:	e0 8a 00 19 	brle	80005f22 <PrintHex+0xaa>
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80005ef4:	fa cb ff f4 	sub	r11,sp,-12
80005ef8:	f6 09 00 09 	add	r9,r11,r9
80005efc:	37 8b       	mov	r11,120
80005efe:	f3 6b ff f4 	st.b	r9[-12],r11
	s[cnt++] = '0';
80005f02:	fa c9 ff f4 	sub	r9,sp,-12
80005f06:	10 09       	add	r9,r8
80005f08:	33 0b       	mov	r11,48
80005f0a:	f3 6b ff f4 	st.b	r9[-12],r11
80005f0e:	fa 08 00 08 	add	r8,sp,r8
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80005f12:	fa ce 00 01 	sub	lr,sp,1
80005f16:	14 99       	mov	r9,r10
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
	*p++ = s[--cnt];
80005f18:	11 8b       	ld.ub	r11,r8[0x0]
80005f1a:	12 cb       	st.b	r9++,r11
80005f1c:	20 18       	sub	r8,1
	}
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
80005f1e:	1c 38       	cp.w	r8,lr
80005f20:	cf c1       	brne	80005f18 <PrintHex+0xa0>
	*p++ = s[--cnt];
		
	return str;
}
80005f22:	14 9c       	mov	r12,r10
80005f24:	2f dd       	sub	sp,-12
80005f26:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

80005f2a <PrintDec>:
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
{
80005f2a:	d4 21       	pushm	r4-r7,lr
80005f2c:	20 3d       	sub	sp,12
80005f2e:	18 98       	mov	r8,r12
	char * p = str;
	
	int sign = i>=0 ? 0 : 1;
	char s[10];
	memset(s, 0 , 10);
80005f30:	30 06       	mov	r6,0
80005f32:	30 07       	mov	r7,0
80005f34:	fa e7 00 00 	st.d	sp[0],r6
80005f38:	30 0c       	mov	r12,0
80005f3a:	ba 4c       	st.h	sp[0x8],r12
	int cnt=0;
	if(sign)
80005f3c:	58 08       	cp.w	r8,0
80005f3e:	c0 35       	brlt	80005f44 <PrintDec+0x1a>
80005f40:	14 97       	mov	r7,r10
80005f42:	c0 58       	rjmp	80005f4c <PrintDec+0x22>
	{
		*p++ = '-';
80005f44:	14 97       	mov	r7,r10
80005f46:	32 d9       	mov	r9,45
80005f48:	0e c9       	st.b	r7++,r9
		i = -i;
80005f4a:	5c 38       	neg	r8
	}
	
	if(i == 0 )s[cnt++] = '0';
80005f4c:	58 08       	cp.w	r8,0
80005f4e:	c0 51       	brne	80005f58 <PrintDec+0x2e>
80005f50:	33 08       	mov	r8,48
80005f52:	ba 88       	st.b	sp[0x0],r8
80005f54:	30 1e       	mov	lr,1
80005f56:	c2 f8       	rjmp	80005fb4 <PrintDec+0x8a>
	
	int ten = i%10;
80005f58:	e0 65 66 67 	mov	r5,26215
80005f5c:	ea 15 66 66 	orh	r5,0x6666
80005f60:	f0 05 04 44 	muls.d	r4,r8,r5
80005f64:	ea 0c 14 02 	asr	r12,r5,0x2
80005f68:	f0 09 14 1f 	asr	r9,r8,0x1f
80005f6c:	f8 09 01 09 	sub	r9,r12,r9
80005f70:	f2 09 00 29 	add	r9,r9,r9<<0x2
80005f74:	f0 09 01 19 	sub	r9,r8,r9<<0x1
80005f78:	30 0e       	mov	lr,0
	while(i)
	{
		s[cnt] = ten+'0';
80005f7a:	1a 9c       	mov	r12,sp
		cnt++;
		i /= 10;
80005f7c:	e0 66 66 67 	mov	r6,26215
80005f80:	ea 16 66 66 	orh	r6,0x6666
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
	{
		s[cnt] = ten+'0';
80005f84:	2d 09       	sub	r9,-48
80005f86:	f8 0e 0b 09 	st.b	r12[lr],r9
		cnt++;
80005f8a:	2f fe       	sub	lr,-1
		i /= 10;
80005f8c:	f0 06 04 44 	muls.d	r4,r8,r6
80005f90:	ea 09 14 02 	asr	r9,r5,0x2
80005f94:	bf 58       	asr	r8,0x1f
80005f96:	f2 08 01 08 	sub	r8,r9,r8
		ten = i%10;
80005f9a:	f0 06 04 44 	muls.d	r4,r8,r6
80005f9e:	ea 09 14 02 	asr	r9,r5,0x2
80005fa2:	f0 05 14 1f 	asr	r5,r8,0x1f
80005fa6:	0a 19       	sub	r9,r5
80005fa8:	f2 09 00 29 	add	r9,r9,r9<<0x2
80005fac:	f0 09 01 19 	sub	r9,r8,r9<<0x1
	}
	
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
80005fb0:	58 08       	cp.w	r8,0
80005fb2:	ce 91       	brne	80005f84 <PrintDec+0x5a>
		cnt++;
		i /= 10;
		ten = i%10;
	}
	
	if(len - cnt > 0 )
80005fb4:	f6 0e 01 08 	sub	r8,r11,lr
80005fb8:	58 08       	cp.w	r8,0
80005fba:	e0 89 00 06 	brgt	80005fc6 <PrintDec+0x9c>
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80005fbe:	58 0e       	cp.w	lr,0
80005fc0:	e0 89 00 14 	brgt	80005fe8 <PrintDec+0xbe>
80005fc4:	c1 d8       	rjmp	80005ffe <PrintDec+0xd4>
		ten = i%10;
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
80005fc6:	1c 1b       	sub	r11,lr
80005fc8:	5c 5b       	castu.b	r11
		for(int i = 0; i < num; i++)
80005fca:	16 9c       	mov	r12,r11
80005fcc:	58 0b       	cp.w	r11,0
80005fce:	fe 9a ff f8 	brle	80005fbe <PrintDec+0x94>
80005fd2:	1a 99       	mov	r9,sp
80005fd4:	1c 09       	add	r9,lr
80005fd6:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80005fd8:	33 06       	mov	r6,48
80005fda:	12 c6       	st.b	r9++,r6
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80005fdc:	2f f8       	sub	r8,-1
80005fde:	18 38       	cp.w	r8,r12
80005fe0:	cf d5       	brlt	80005fda <PrintDec+0xb0>
{
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
80005fe2:	f6 0e 00 0e 	add	lr,r11,lr
80005fe6:	ce cb       	rjmp	80005fbe <PrintDec+0x94>
80005fe8:	fa c8 ff f4 	sub	r8,sp,-12
80005fec:	1c 08       	add	r8,lr
80005fee:	20 d8       	sub	r8,13
80005ff0:	fa cb 00 01 	sub	r11,sp,1
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
	*p++ = s[--cnt];
80005ff4:	11 89       	ld.ub	r9,r8[0x0]
80005ff6:	0e c9       	st.b	r7++,r9
80005ff8:	20 18       	sub	r8,1
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80005ffa:	16 38       	cp.w	r8,r11
80005ffc:	cf c1       	brne	80005ff4 <PrintDec+0xca>
	*p++ = s[--cnt];
	
	return str;
}
80005ffe:	14 9c       	mov	r12,r10
80006000:	2f dd       	sub	sp,-12
80006002:	d8 22       	popm	r4-r7,pc

80006004 <log>:
	,  NULL );
	
}

int log(char * content, ...)
{
80006004:	d4 31       	pushm	r0-r7,lr
80006006:	fa cd 02 08 	sub	sp,sp,520
8000600a:	18 97       	mov	r7,r12
	
	
	char logTmp[MAX_LOG_LINE_SIZE];
	memset(logTmp, '\0', MAX_LOG_LINE_SIZE);	
8000600c:	e0 6a 01 00 	mov	r10,256
80006010:	30 0b       	mov	r11,0
80006012:	fa cc fe f8 	sub	r12,sp,-264
80006016:	f0 1f 00 4e 	mcall	8000614c <log+0x148>
	,  tskLOG_PRIORITY
	,  NULL );
	
}

int log(char * content, ...)
8000601a:	fa c4 fd d4 	sub	r4,sp,-556
8000601e:	30 0a       	mov	r10,0
80006020:	50 0a       	stdsp	sp[0x0],r10
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80006022:	fa c3 ff fc 	sub	r3,sp,-4
80006026:	e0 61 01 00 	mov	r1,256
8000602a:	14 90       	mov	r0,r10
			
					if(*str == '%')
8000602c:	32 52       	mov	r2,37
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
8000602e:	fa c6 fe f8 	sub	r6,sp,-264
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80006032:	02 9a       	mov	r10,r1
80006034:	00 9b       	mov	r11,r0
80006036:	06 9c       	mov	r12,r3
80006038:	f0 1f 00 45 	mcall	8000614c <log+0x148>
			
					if(*str == '%')
8000603c:	0f 88       	ld.ub	r8,r7[0x0]
8000603e:	e4 08 18 00 	cp.b	r8,r2
80006042:	c5 71       	brne	800060f0 <log+0xec>
					{
						static char lench = 0;
						lench =*(str + 1);
80006044:	ee c8 ff ff 	sub	r8,r7,-1
80006048:	11 89       	ld.ub	r9,r8[0x0]
8000604a:	4c 2a       	lddpc	r10,80006150 <log+0x14c>
8000604c:	b4 89       	st.b	r10[0x0],r9
						if((lench >= '0') &&  (lench <= '9'))
8000604e:	23 09       	sub	r9,48
80006050:	30 9a       	mov	r10,9
80006052:	f4 09 18 00 	cp.b	r9,r10
80006056:	ee 08 17 b0 	movhi	r8,r7
						{
							len = *(++str) - '0';
8000605a:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
8000605e:	f7 b9 08 30 	subls	r9,48
80006062:	fb f9 8a 00 	st.wls	sp[0x0],r9
						}
						
						str++;
80006066:	f0 c7 ff ff 	sub	r7,r8,-1
						
						switch(*(str))
8000606a:	0f 88       	ld.ub	r8,r7[0x0]
8000606c:	22 58       	sub	r8,37
8000606e:	e0 48 00 53 	cp.w	r8,83
80006072:	e0 8b 00 31 	brhi	800060d4 <log+0xd0>
80006076:	4b 89       	lddpc	r9,80006154 <log+0x150>
80006078:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
						{
							case('i'):
							case('I'):
							case('d'):
							case('D'):
							x = va_arg(arg_ptr,int);
8000607c:	e8 c5 ff fc 	sub	r5,r4,-4
							strTmp = PrintDec(x, len, strTmp);
80006080:	06 9a       	mov	r10,r3
80006082:	40 0b       	lddsp	r11,sp[0x0]
80006084:	5c 5b       	castu.b	r11
80006086:	68 0c       	ld.w	r12,r4[0x0]
80006088:	f0 1f 00 34 	mcall	80006158 <log+0x154>
							break;
8000608c:	c2 98       	rjmp	800060de <log+0xda>
							
							case('f')://浮点数输出
							case('F'):
							//f = va_arg(arg_ptr,int);
							//strTmp = PrintDec(x, len, strTmp);
							log("I need float.");
8000608e:	4b 4c       	lddpc	r12,8000615c <log+0x158>
80006090:	f0 1f 00 34 	mcall	80006160 <log+0x15c>
80006094:	08 95       	mov	r5,r4
80006096:	06 9c       	mov	r12,r3
							break;
80006098:	c2 38       	rjmp	800060de <log+0xda>
							
							
							case('x'):
							case('X'):
							x = va_arg(arg_ptr,int);
8000609a:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintHex(x,len, strTmp);
8000609e:	06 9a       	mov	r10,r3
800060a0:	40 0b       	lddsp	r11,sp[0x0]
800060a2:	5c 5b       	castu.b	r11
800060a4:	68 0c       	ld.w	r12,r4[0x0]
800060a6:	f0 1f 00 30 	mcall	80006164 <log+0x160>
800060aa:	06 9c       	mov	r12,r3
							break;
800060ac:	c1 98       	rjmp	800060de <log+0xda>
							
							case('c'):
							case('C'):
							y = va_arg(arg_ptr,int);
800060ae:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintChar(y, strTmp);
800060b2:	06 9b       	mov	r11,r3
800060b4:	09 bc       	ld.ub	r12,r4[0x3]
800060b6:	f0 1f 00 2d 	mcall	80006168 <log+0x164>
800060ba:	06 9c       	mov	r12,r3
							break;
800060bc:	c1 18       	rjmp	800060de <log+0xda>
							
							case('s'):
							case('S'):
							strTmp = va_arg(arg_ptr,char*);
800060be:	e8 c5 ff fc 	sub	r5,r4,-4
800060c2:	68 0c       	ld.w	r12,r4[0x0]
							//PrintStr(s);
							break;
800060c4:	c0 d8       	rjmp	800060de <log+0xda>
							
							case('%'):
							PrintChar('%', strTmp);
800060c6:	06 9b       	mov	r11,r3
800060c8:	32 5c       	mov	r12,37
800060ca:	f0 1f 00 28 	mcall	80006168 <log+0x164>
800060ce:	08 95       	mov	r5,r4
800060d0:	06 9c       	mov	r12,r3
							//PrintChar('%');
							break;
800060d2:	c0 68       	rjmp	800060de <log+0xda>
							
							default:
							log("I need relax.");
800060d4:	4a 6c       	lddpc	r12,8000616c <log+0x168>
800060d6:	f0 1f 00 23 	mcall	80006160 <log+0x15c>
800060da:	08 95       	mov	r5,r4
800060dc:	06 9c       	mov	r12,r3
						}
						str++;
800060de:	2f f7       	sub	r7,-1
						
						length = sprintf(logTmp,"%s%s",logTmp,strTmp );
800060e0:	1a dc       	st.w	--sp,r12
800060e2:	1a d6       	st.w	--sp,r6
800060e4:	4a 3b       	lddpc	r11,80006170 <log+0x16c>
800060e6:	0c 9c       	mov	r12,r6
800060e8:	f0 1f 00 23 	mcall	80006174 <log+0x170>
800060ec:	2f ed       	sub	sp,-8
800060ee:	c0 a8       	rjmp	80006102 <log+0xfe>
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
800060f0:	2f f7       	sub	r7,-1
800060f2:	1a d8       	st.w	--sp,r8
800060f4:	1a d6       	st.w	--sp,r6
800060f6:	4a 1b       	lddpc	r11,80006178 <log+0x174>
800060f8:	0c 9c       	mov	r12,r6
800060fa:	f0 1f 00 1f 	mcall	80006174 <log+0x170>
800060fe:	08 95       	mov	r5,r4
80006100:	2f ed       	sub	sp,-8
			
			
			
	}while(*str != '\0');
80006102:	0f 89       	ld.ub	r9,r7[0x0]
80006104:	30 08       	mov	r8,0
80006106:	f0 09 18 00 	cp.b	r9,r8
8000610a:	c0 30       	breq	80006110 <log+0x10c>
8000610c:	0a 94       	mov	r4,r5
8000610e:	c9 2b       	rjmp	80006032 <log+0x2e>
		
		
				
	va_end(arg_ptr);
	//while(1)		
	length = sprintf(logTmp,"%s\r\n",logTmp);
80006110:	fa c7 fe f8 	sub	r7,sp,-264
80006114:	1a d7       	st.w	--sp,r7
80006116:	49 ab       	lddpc	r11,8000617c <log+0x178>
80006118:	0e 9c       	mov	r12,r7
8000611a:	f0 1f 00 17 	mcall	80006174 <log+0x170>
	
	char * p = pvPortMalloc(length+1);
8000611e:	5c 5c       	castu.b	r12
80006120:	f8 c6 ff ff 	sub	r6,r12,-1
80006124:	0c 9c       	mov	r12,r6
80006126:	f0 1f 00 17 	mcall	80006180 <log+0x17c>
8000612a:	54 2c       	stdsp	sp[0x108],r12
	memcpy(p, logTmp, length+1);
8000612c:	0c 9a       	mov	r10,r6
8000612e:	0e 9b       	mov	r11,r7
80006130:	f0 1f 00 15 	mcall	80006184 <log+0x180>
	//
	//usart_write_line(EXAMPLE_USART, logTmp)
	
	xQueueSend( logQueue, &p, 5);
80006134:	30 09       	mov	r9,0
80006136:	30 5a       	mov	r10,5
80006138:	fa cb fe f8 	sub	r11,sp,-264
8000613c:	49 38       	lddpc	r8,80006188 <log+0x184>
8000613e:	70 0c       	ld.w	r12,r8[0x0]
80006140:	f0 1f 00 13 	mcall	8000618c <log+0x188>
80006144:	2f fd       	sub	sp,-4
	
	
}
80006146:	fe 3d fd f8 	sub	sp,-520
8000614a:	d8 32       	popm	r0-r7,pc
8000614c:	80 00       	ld.sh	r0,r0[0x0]
8000614e:	6a a4       	ld.w	r4,r5[0x28]
80006150:	00 00       	add	r0,r0
80006152:	0d 34       	ld.ub	r4,r6++
80006154:	80 00       	ld.sh	r0,r0[0x0]
80006156:	c8 84       	brge	80006066 <log+0x62>
80006158:	80 00       	ld.sh	r0,r0[0x0]
8000615a:	5f 2a       	srhs	r10
8000615c:	80 00       	ld.sh	r0,r0[0x0]
8000615e:	cb 30       	breq	800060c4 <log+0xc0>
80006160:	80 00       	ld.sh	r0,r0[0x0]
80006162:	60 04       	ld.w	r4,r0[0x0]
80006164:	80 00       	ld.sh	r0,r0[0x0]
80006166:	5e 78       	retpl	r8
80006168:	80 00       	ld.sh	r0,r0[0x0]
8000616a:	5e 74       	retpl	r4
8000616c:	80 00       	ld.sh	r0,r0[0x0]
8000616e:	cb 40       	breq	800060d6 <log+0xd2>
80006170:	80 00       	ld.sh	r0,r0[0x0]
80006172:	cb 50       	breq	800060dc <log+0xd8>
80006174:	80 00       	ld.sh	r0,r0[0x0]
80006176:	6d 94       	ld.w	r4,r6[0x64]
80006178:	80 00       	ld.sh	r0,r0[0x0]
8000617a:	cb 58       	rjmp	800062e4 <logFromISR+0x154>
8000617c:	80 00       	ld.sh	r0,r0[0x0]
8000617e:	cb 60       	breq	800060ea <log+0xe6>
80006180:	80 00       	ld.sh	r0,r0[0x0]
80006182:	51 18       	stdsp	sp[0x44],r8
80006184:	80 00       	ld.sh	r0,r0[0x0]
80006186:	69 5c       	ld.w	r12,r4[0x54]
80006188:	00 00       	add	r0,r0
8000618a:	40 ec       	lddsp	r12,sp[0x38]
8000618c:	80 00       	ld.sh	r0,r0[0x0]
8000618e:	54 6c       	stdsp	sp[0x118],r12

80006190 <logFromISR>:
	
	
int logFromISR(char * content, ...)
	{
80006190:	d4 31       	pushm	r0-r7,lr
80006192:	fa cd 02 0c 	sub	sp,sp,524
80006196:	18 97       	mov	r7,r12
		
		
		char logTmp[MAX_LOG_LINE_SIZE];
		memset(logTmp, '\0', MAX_LOG_LINE_SIZE);
80006198:	e0 6a 01 00 	mov	r10,256
8000619c:	30 0b       	mov	r11,0
8000619e:	fa cc fe f4 	sub	r12,sp,-268
800061a2:	f0 1f 00 4c 	mcall	800062d0 <logFromISR+0x140>
	
	
}
	
	
int logFromISR(char * content, ...)
800061a6:	fa c4 fd d0 	sub	r4,sp,-560
800061aa:	30 0a       	mov	r10,0
800061ac:	50 0a       	stdsp	sp[0x0],r10
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
800061ae:	fa c3 ff fc 	sub	r3,sp,-4
800061b2:	e0 61 01 00 	mov	r1,256
800061b6:	14 90       	mov	r0,r10
			
			if(*str == '%')
800061b8:	32 52       	mov	r2,37
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
800061ba:	fa c6 fe f4 	sub	r6,sp,-268
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
800061be:	02 9a       	mov	r10,r1
800061c0:	00 9b       	mov	r11,r0
800061c2:	06 9c       	mov	r12,r3
800061c4:	f0 1f 00 43 	mcall	800062d0 <logFromISR+0x140>
			
			if(*str == '%')
800061c8:	0f 88       	ld.ub	r8,r7[0x0]
800061ca:	e4 08 18 00 	cp.b	r8,r2
800061ce:	c5 11       	brne	80006270 <logFromISR+0xe0>
			{
				static char lench = 0;
				lench =*(str + 1);
800061d0:	ee c8 ff ff 	sub	r8,r7,-1
800061d4:	11 89       	ld.ub	r9,r8[0x0]
800061d6:	4c 0a       	lddpc	r10,800062d4 <logFromISR+0x144>
800061d8:	b4 89       	st.b	r10[0x0],r9
				if((lench >= '0') &&  (lench <= '9'))
800061da:	23 09       	sub	r9,48
800061dc:	30 9a       	mov	r10,9
800061de:	f4 09 18 00 	cp.b	r9,r10
800061e2:	ee 08 17 b0 	movhi	r8,r7
				{
					len = *(++str) - '0';
800061e6:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
800061ea:	f7 b9 08 30 	subls	r9,48
800061ee:	fb f9 8a 00 	st.wls	sp[0x0],r9
				}
				
				str++;
800061f2:	f0 c7 ff ff 	sub	r7,r8,-1
				
				switch(*(str))
800061f6:	0f 88       	ld.ub	r8,r7[0x0]
800061f8:	22 58       	sub	r8,37
800061fa:	e0 48 00 53 	cp.w	r8,83
800061fe:	e0 8b 00 2b 	brhi	80006254 <logFromISR+0xc4>
80006202:	4b 69       	lddpc	r9,800062d8 <logFromISR+0x148>
80006204:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
				{
					case('d'):
					case('D'):
					x = va_arg(arg_ptr,int);
80006208:	e8 c5 ff fc 	sub	r5,r4,-4
					strTmp = PrintDec(x, len, strTmp);
8000620c:	06 9a       	mov	r10,r3
8000620e:	40 0b       	lddsp	r11,sp[0x0]
80006210:	5c 5b       	castu.b	r11
80006212:	68 0c       	ld.w	r12,r4[0x0]
80006214:	f0 1f 00 32 	mcall	800062dc <logFromISR+0x14c>
					break;
80006218:	c2 38       	rjmp	8000625e <logFromISR+0xce>
					case('x'):
					case('X'):
					x = va_arg(arg_ptr,int);
8000621a:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintHex(x,len, strTmp);
8000621e:	06 9a       	mov	r10,r3
80006220:	40 0b       	lddsp	r11,sp[0x0]
80006222:	5c 5b       	castu.b	r11
80006224:	68 0c       	ld.w	r12,r4[0x0]
80006226:	f0 1f 00 2f 	mcall	800062e0 <logFromISR+0x150>
8000622a:	06 9c       	mov	r12,r3
					break;
8000622c:	c1 98       	rjmp	8000625e <logFromISR+0xce>
					case('c'):
					case('C'):
					y = va_arg(arg_ptr,int);
8000622e:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintChar(y, strTmp);
80006232:	06 9b       	mov	r11,r3
80006234:	09 bc       	ld.ub	r12,r4[0x3]
80006236:	f0 1f 00 2c 	mcall	800062e4 <logFromISR+0x154>
8000623a:	06 9c       	mov	r12,r3
					break;
8000623c:	c1 18       	rjmp	8000625e <logFromISR+0xce>
					case('s'):
					case('S'):
					strTmp = va_arg(arg_ptr,char*);
8000623e:	e8 c5 ff fc 	sub	r5,r4,-4
80006242:	68 0c       	ld.w	r12,r4[0x0]
					//PrintStr(s);
					break;
80006244:	c0 d8       	rjmp	8000625e <logFromISR+0xce>
					case('%'):
					PrintChar('%', strTmp);
80006246:	06 9b       	mov	r11,r3
80006248:	32 5c       	mov	r12,37
8000624a:	f0 1f 00 27 	mcall	800062e4 <logFromISR+0x154>
8000624e:	08 95       	mov	r5,r4
80006250:	06 9c       	mov	r12,r3
					//PrintChar('%');
					break;
80006252:	c0 68       	rjmp	8000625e <logFromISR+0xce>
					default:
					log("I need relax.");
80006254:	4a 5c       	lddpc	r12,800062e8 <logFromISR+0x158>
80006256:	f0 1f 00 26 	mcall	800062ec <logFromISR+0x15c>
8000625a:	08 95       	mov	r5,r4
8000625c:	06 9c       	mov	r12,r3
				}
				str++;
8000625e:	2f f7       	sub	r7,-1
				
				length = sprintf(logTmp,"%s%s",logTmp,strTmp );
80006260:	1a dc       	st.w	--sp,r12
80006262:	1a d6       	st.w	--sp,r6
80006264:	4a 3b       	lddpc	r11,800062f0 <logFromISR+0x160>
80006266:	0c 9c       	mov	r12,r6
80006268:	f0 1f 00 23 	mcall	800062f4 <logFromISR+0x164>
8000626c:	2f ed       	sub	sp,-8
8000626e:	c0 a8       	rjmp	80006282 <logFromISR+0xf2>
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
80006270:	2f f7       	sub	r7,-1
80006272:	1a d8       	st.w	--sp,r8
80006274:	1a d6       	st.w	--sp,r6
80006276:	4a 1b       	lddpc	r11,800062f8 <logFromISR+0x168>
80006278:	0c 9c       	mov	r12,r6
8000627a:	f0 1f 00 1f 	mcall	800062f4 <logFromISR+0x164>
8000627e:	08 95       	mov	r5,r4
80006280:	2f ed       	sub	sp,-8
			
			
			
		}while(*str != '\0');
80006282:	0f 89       	ld.ub	r9,r7[0x0]
80006284:	30 08       	mov	r8,0
80006286:	f0 09 18 00 	cp.b	r9,r8
8000628a:	c0 30       	breq	80006290 <logFromISR+0x100>
8000628c:	0a 94       	mov	r4,r5
8000628e:	c9 8b       	rjmp	800061be <logFromISR+0x2e>
		
		
		
		va_end(arg_ptr);
		//while(1)
		length = sprintf(logTmp,"%s\r\n",logTmp);
80006290:	fa c7 fe f4 	sub	r7,sp,-268
80006294:	1a d7       	st.w	--sp,r7
80006296:	49 ab       	lddpc	r11,800062fc <logFromISR+0x16c>
80006298:	0e 9c       	mov	r12,r7
8000629a:	f0 1f 00 17 	mcall	800062f4 <logFromISR+0x164>
		
		char * p = pvPortMalloc(length+1);
8000629e:	5c 5c       	castu.b	r12
800062a0:	f8 c6 ff ff 	sub	r6,r12,-1
800062a4:	0c 9c       	mov	r12,r6
800062a6:	f0 1f 00 17 	mcall	80006300 <logFromISR+0x170>
800062aa:	54 3c       	stdsp	sp[0x10c],r12
		memcpy(p, logTmp, length+1);
800062ac:	0c 9a       	mov	r10,r6
800062ae:	0e 9b       	mov	r11,r7
800062b0:	f0 1f 00 15 	mcall	80006304 <logFromISR+0x174>
		//
		portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
800062b4:	30 09       	mov	r9,0
800062b6:	54 29       	stdsp	sp[0x108],r9
		
		//usart_write_line(EXAMPLE_USART, p);
		//vPortFree(p);
		xQueueSendFromISR( logQueue, &p, &xHigherPriorityTaskWoken );
800062b8:	fa ca fe f8 	sub	r10,sp,-264
800062bc:	fa cb fe f4 	sub	r11,sp,-268
800062c0:	49 28       	lddpc	r8,80006308 <logFromISR+0x178>
800062c2:	70 0c       	ld.w	r12,r8[0x0]
800062c4:	f0 1f 00 12 	mcall	8000630c <logFromISR+0x17c>
800062c8:	2f fd       	sub	sp,-4
		
		//if (xHigherPriorityTaskWoken == pdTRUE)
		//{
			////taskYIELD();
		//}
	}
800062ca:	fe 3d fd f4 	sub	sp,-524
800062ce:	d8 32       	popm	r0-r7,pc
800062d0:	80 00       	ld.sh	r0,r0[0x0]
800062d2:	6a a4       	ld.w	r4,r5[0x28]
800062d4:	00 00       	add	r0,r0
800062d6:	0d 35       	ld.ub	r5,r6++
800062d8:	80 00       	ld.sh	r0,r0[0x0]
800062da:	c9 d4       	brge	80006214 <logFromISR+0x84>
800062dc:	80 00       	ld.sh	r0,r0[0x0]
800062de:	5f 2a       	srhs	r10
800062e0:	80 00       	ld.sh	r0,r0[0x0]
800062e2:	5e 78       	retpl	r8
800062e4:	80 00       	ld.sh	r0,r0[0x0]
800062e6:	5e 74       	retpl	r4
800062e8:	80 00       	ld.sh	r0,r0[0x0]
800062ea:	cb 40       	breq	80006252 <logFromISR+0xc2>
800062ec:	80 00       	ld.sh	r0,r0[0x0]
800062ee:	60 04       	ld.w	r4,r0[0x0]
800062f0:	80 00       	ld.sh	r0,r0[0x0]
800062f2:	cb 50       	breq	8000625c <logFromISR+0xcc>
800062f4:	80 00       	ld.sh	r0,r0[0x0]
800062f6:	6d 94       	ld.w	r4,r6[0x64]
800062f8:	80 00       	ld.sh	r0,r0[0x0]
800062fa:	cb 58       	rjmp	80006464 <gpio_enable_module_pin+0x24>
800062fc:	80 00       	ld.sh	r0,r0[0x0]
800062fe:	cb 60       	breq	8000626a <logFromISR+0xda>
80006300:	80 00       	ld.sh	r0,r0[0x0]
80006302:	51 18       	stdsp	sp[0x44],r8
80006304:	80 00       	ld.sh	r0,r0[0x0]
80006306:	69 5c       	ld.w	r12,r4[0x54]
80006308:	00 00       	add	r0,r0
8000630a:	40 ec       	lddsp	r12,sp[0x38]
8000630c:	80 00       	ld.sh	r0,r0[0x0]
8000630e:	54 1c       	stdsp	sp[0x104],r12

80006310 <log_init>:
		
	return str;
}

void log_init(void)
{
80006310:	d4 01       	pushm	lr
		.stopbits     = USART_1_STOPBIT,
		.channelmode  = USART_NORMAL_CHMODE
	};

	// Assign GPIO to USART.
	gpio_enable_module(USART_GPIO_MAP,
80006312:	30 2b       	mov	r11,2
80006314:	49 0c       	lddpc	r12,80006354 <log_init+0x44>
80006316:	f0 1f 00 11 	mcall	80006358 <log_init+0x48>
	sizeof(USART_GPIO_MAP) / sizeof(USART_GPIO_MAP[0]));

	// Initialize USART in RS232 mode.
	usart_init_rs232(EXAMPLE_USART, &USART_OPTIONS, EXAMPLE_TARGET_PBACLK_FREQ_HZ);			
8000631a:	e0 6a 36 00 	mov	r10,13824
8000631e:	ea 1a 01 6e 	orh	r10,0x16e
80006322:	48 fb       	lddpc	r11,8000635c <log_init+0x4c>
80006324:	fe 7c 18 00 	mov	r12,-59392
80006328:	f0 1f 00 0e 	mcall	80006360 <log_init+0x50>
			
	logQueue  = xQueueCreate(50, sizeof(char *));
8000632c:	30 4b       	mov	r11,4
8000632e:	33 2c       	mov	r12,50
80006330:	f0 1f 00 0d 	mcall	80006364 <log_init+0x54>
80006334:	48 d8       	lddpc	r8,80006368 <log_init+0x58>
80006336:	91 0c       	st.w	r8[0x0],r12
	
	xTaskCreate(
80006338:	30 09       	mov	r9,0
8000633a:	1a d9       	st.w	--sp,r9
8000633c:	1a d9       	st.w	--sp,r9
8000633e:	1a d9       	st.w	--sp,r9
80006340:	30 28       	mov	r8,2
80006342:	e0 6a 01 80 	mov	r10,384
80006346:	48 ab       	lddpc	r11,8000636c <log_init+0x5c>
80006348:	48 ac       	lddpc	r12,80006370 <log_init+0x60>
8000634a:	f0 1f 00 0b 	mcall	80006374 <log_init+0x64>
8000634e:	2f dd       	sub	sp,-12
	,  384
	,  NULL
	,  tskLOG_PRIORITY
	,  NULL );
	
}
80006350:	d8 02       	popm	pc
80006352:	00 00       	add	r0,r0
80006354:	80 00       	ld.sh	r0,r0[0x0]
80006356:	cb 6c       	rcall	800064c2 <gpio_enable_module+0x2e>
80006358:	80 00       	ld.sh	r0,r0[0x0]
8000635a:	64 94       	ld.w	r4,r2[0x24]
8000635c:	80 00       	ld.sh	r0,r0[0x0]
8000635e:	cb 24       	brge	800062c2 <logFromISR+0x132>
80006360:	80 00       	ld.sh	r0,r0[0x0]
80006362:	4c bc       	lddpc	r12,8000648c <gpio_enable_module_pin+0x4c>
80006364:	80 00       	ld.sh	r0,r0[0x0]
80006366:	55 6c       	stdsp	sp[0x158],r12
80006368:	00 00       	add	r0,r0
8000636a:	40 ec       	lddsp	r12,sp[0x38]
8000636c:	80 00       	ld.sh	r0,r0[0x0]
8000636e:	cb 68       	rjmp	800064da <_stext+0x16>
80006370:	80 00       	ld.sh	r0,r0[0x0]
80006372:	63 78       	ld.w	r8,r1[0x5c]
80006374:	80 00       	ld.sh	r0,r0[0x0]
80006376:	5c 40       	abs	r0

80006378 <task_log>:
			////taskYIELD();
		//}
	}
	
static void task_log(void * pvParameters)
{
80006378:	eb cd 40 f8 	pushm	r3-r7,lr
8000637c:	20 1d       	sub	sp,4
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
8000637e:	48 c7       	lddpc	r7,800063ac <task_log+0x34>
80006380:	30 05       	mov	r5,0
80006382:	3f f4       	mov	r4,-1
		{
			if( NULL != str)
			{
				usart_write_line(EXAMPLE_USART, str);
80006384:	fe 73 18 00 	mov	r3,-59392
{
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
80006388:	0a 99       	mov	r9,r5
8000638a:	08 9a       	mov	r10,r4
8000638c:	1a 9b       	mov	r11,sp
8000638e:	6e 0c       	ld.w	r12,r7[0x0]
80006390:	f0 1f 00 08 	mcall	800063b0 <task_log+0x38>
80006394:	58 1c       	cp.w	r12,1
80006396:	cf 91       	brne	80006388 <task_log+0x10>
		{
			if( NULL != str)
80006398:	40 0b       	lddsp	r11,sp[0x0]
8000639a:	58 0b       	cp.w	r11,0
8000639c:	cf 60       	breq	80006388 <task_log+0x10>
			{
				usart_write_line(EXAMPLE_USART, str);
8000639e:	06 9c       	mov	r12,r3
800063a0:	f0 1f 00 05 	mcall	800063b4 <task_log+0x3c>
				vPortFree(str);
800063a4:	40 0c       	lddsp	r12,sp[0x0]
800063a6:	f0 1f 00 05 	mcall	800063b8 <task_log+0x40>
800063aa:	ce fb       	rjmp	80006388 <task_log+0x10>
800063ac:	00 00       	add	r0,r0
800063ae:	40 ec       	lddsp	r12,sp[0x38]
800063b0:	80 00       	ld.sh	r0,r0[0x0]
800063b2:	52 60       	stdsp	sp[0x98],r0
800063b4:	80 00       	ld.sh	r0,r0[0x0]
800063b6:	4c 6c       	lddpc	r12,800064cc <_stext+0x8>
800063b8:	80 00       	ld.sh	r0,r0[0x0]
800063ba:	50 f0       	stdsp	sp[0x3c],r0

800063bc <main>:

#include "fs/fs.h"
#include "rtc/rtc.h"

int main(void)
{
800063bc:	d4 01       	pushm	lr
	//Force SSC_TX_DATA_ENABLE Disabled as soon as possible.
	AVR32_GPIO.port[1].ovrs  =  0x00000001;  //Value will be high.
800063be:	fe 78 10 00 	mov	r8,-61440
800063c2:	30 19       	mov	r9,1
800063c4:	f1 49 01 54 	st.w	r8[340],r9
	AVR32_GPIO.port[1].oders =  0x00000001;  //Output Driver will be Enabled.
800063c8:	f1 49 01 44 	st.w	r8[324],r9
	AVR32_GPIO.port[1].gpers =  0x00000001;  //Enable as GPIO.
800063cc:	f1 49 01 04 	st.w	r8[260],r9
	
	Disable_global_interrupt();
800063d0:	d3 03       	ssrf	0x10
	local_start_pll0();
800063d2:	f0 1f 00 12 	mcall	80006418 <main+0x5c>
		
	INTC_init_interrupts();
800063d6:	f0 1f 00 12 	mcall	8000641c <main+0x60>
	
	log_init();		
800063da:	f0 1f 00 12 	mcall	80006420 <main+0x64>
	log("----start debug----");	
800063de:	49 2c       	lddpc	r12,80006424 <main+0x68>
800063e0:	f0 1f 00 12 	mcall	80006428 <main+0x6c>
		
	//rtc_init();
	
	//fs_init();//65795机器无法通过文件系统初始化,究起原因，貌似是Radio对OB板的输出功率无法满足SD卡的正常工作。

	tc_init();	
800063e4:	f0 1f 00 12 	mcall	8000642c <main+0x70>
	
	app_init();
800063e8:	f0 1f 00 12 	mcall	80006430 <main+0x74>
	
	xcmp_init();
800063ec:	f0 1f 00 12 	mcall	80006434 <main+0x78>
		
	while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
800063f0:	fe 79 10 00 	mov	r9,-61440
800063f4:	f2 f8 01 60 	ld.w	r8,r9[352]
800063f8:	e2 18 00 02 	andl	r8,0x2,COH
800063fc:	cf c0       	breq	800063f4 <main+0x38>
	while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
800063fe:	fe 79 10 00 	mov	r9,-61440
80006402:	f2 f8 01 60 	ld.w	r8,r9[352]
80006406:	e2 18 00 02 	andl	r8,0x2,COH
8000640a:	cf c1       	brne	80006402 <main+0x46>
	local_start_timer();
8000640c:	f0 1f 00 0b 	mcall	80006438 <main+0x7c>
	
	Enable_global_interrupt();
80006410:	d5 03       	csrf	0x10
	
	vTaskStartScheduler();		
80006412:	f0 1f 00 0b 	mcall	8000643c <main+0x80>
	return 0;
}
80006416:	d8 0a       	popm	pc,r12=0
80006418:	80 00       	ld.sh	r0,r0[0x0]
8000641a:	47 68       	lddsp	r8,sp[0x1d8]
8000641c:	80 00       	ld.sh	r0,r0[0x0]
8000641e:	48 f8       	lddpc	r8,80006458 <gpio_enable_module_pin+0x18>
80006420:	80 00       	ld.sh	r0,r0[0x0]
80006422:	63 10       	ld.w	r0,r1[0x44]
80006424:	80 00       	ld.sh	r0,r0[0x0]
80006426:	cb 7c       	rcall	80006594 <_malloc_r+0x70>
80006428:	80 00       	ld.sh	r0,r0[0x0]
8000642a:	60 04       	ld.w	r4,r0[0x0]
8000642c:	80 00       	ld.sh	r0,r0[0x0]
8000642e:	47 f4       	lddsp	r4,sp[0x1fc]
80006430:	80 00       	ld.sh	r0,r0[0x0]
80006432:	20 40       	sub	r0,4
80006434:	80 00       	ld.sh	r0,r0[0x0]
80006436:	40 78       	lddsp	r8,sp[0x1c]
80006438:	80 00       	ld.sh	r0,r0[0x0]
8000643a:	47 b8       	lddsp	r8,sp[0x1ec]
8000643c:	80 00       	ld.sh	r0,r0[0x0]
8000643e:	5e 28       	reths	r8

80006440 <gpio_enable_module_pin>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80006440:	f8 08 16 05 	lsr	r8,r12,0x5
80006444:	a9 68       	lsl	r8,0x8
80006446:	e0 28 f0 00 	sub	r8,61440

	/* Enable the correct function. */
	switch (function) {
8000644a:	58 1b       	cp.w	r11,1
8000644c:	c0 d0       	breq	80006466 <gpio_enable_module_pin+0x26>
8000644e:	c0 63       	brcs	8000645a <gpio_enable_module_pin+0x1a>
80006450:	58 2b       	cp.w	r11,2
80006452:	c1 00       	breq	80006472 <gpio_enable_module_pin+0x32>
80006454:	58 3b       	cp.w	r11,3
80006456:	c1 40       	breq	8000647e <gpio_enable_module_pin+0x3e>
80006458:	5e ff       	retal	1
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
8000645a:	30 19       	mov	r9,1
8000645c:	f2 0c 09 49 	lsl	r9,r9,r12
80006460:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80006462:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80006464:	c1 28       	rjmp	80006488 <gpio_enable_module_pin+0x48>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80006466:	30 19       	mov	r9,1
80006468:	f2 0c 09 49 	lsl	r9,r9,r12
8000646c:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
8000646e:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80006470:	c0 c8       	rjmp	80006488 <gpio_enable_module_pin+0x48>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80006472:	30 19       	mov	r9,1
80006474:	f2 0c 09 49 	lsl	r9,r9,r12
80006478:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
8000647a:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
8000647c:	c0 68       	rjmp	80006488 <gpio_enable_module_pin+0x48>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
8000647e:	30 19       	mov	r9,1
80006480:	f2 0c 09 49 	lsl	r9,r9,r12
80006484:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80006486:	91 99       	st.w	r8[0x24],r9
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
80006488:	30 19       	mov	r9,1
8000648a:	f2 0c 09 4c 	lsl	r12,r9,r12
8000648e:	91 2c       	st.w	r8[0x8],r12
80006490:	5e fd       	retal	0
80006492:	d7 03       	nop

80006494 <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
80006494:	d4 21       	pushm	r4-r7,lr
80006496:	18 97       	mov	r7,r12
80006498:	16 94       	mov	r4,r11
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
8000649a:	58 0b       	cp.w	r11,0
8000649c:	c0 31       	brne	800064a2 <gpio_enable_module+0xe>
8000649e:	30 05       	mov	r5,0
800064a0:	c0 d8       	rjmp	800064ba <gpio_enable_module+0x26>
800064a2:	30 06       	mov	r6,0
800064a4:	0c 95       	mov	r5,r6
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
800064a6:	6e 1b       	ld.w	r11,r7[0x4]
800064a8:	6e 0c       	ld.w	r12,r7[0x0]
800064aa:	f0 1f 00 06 	mcall	800064c0 <gpio_enable_module+0x2c>
800064ae:	18 45       	or	r5,r12
		gpiomap++;
800064b0:	2f 87       	sub	r7,-8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
800064b2:	2f f6       	sub	r6,-1
800064b4:	0c 34       	cp.w	r4,r6
800064b6:	fe 9b ff f8 	brhi	800064a6 <gpio_enable_module+0x12>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
}
800064ba:	0a 9c       	mov	r12,r5
800064bc:	d8 22       	popm	r4-r7,pc
800064be:	00 00       	add	r0,r0
800064c0:	80 00       	ld.sh	r0,r0[0x0]
800064c2:	64 40       	ld.w	r0,r2[0x10]

800064c4 <_stext>:

  .global _stext
  .type _stext, @function
_stext:
  // Set initial stack pointer.
  lda.w   sp, _estack
800064c4:	e0 7d 80 00 	mov	sp,98304

  // Set up EVBA so interrupts can be enabled.
  lda.w   r0, _evba
  mtsr    AVR32_EVBA, r0
800064c8:	fe c0 a6 c8 	sub	r0,pc,-22840

  // Enable the exception processing.
  csrf    AVR32_SR_EM_OFFSET
800064cc:	e3 b0 00 01 	mtsr	0x4,r0

  // Load initialized data having a global lifetime from the data LMA.
  lda.w   r0, _data
  lda.w   r1, _edata
800064d0:	d5 53       	csrf	0x15
  cp      r0, r1
800064d2:	30 80       	mov	r0,8
  brhs    idata_load_loop_end
800064d4:	e0 61 0a 38 	mov	r1,2616
  lda.w   r2, _data_lma
idata_load_loop:
  ld.d    r4, r2++
800064d8:	02 30       	cp.w	r0,r1
  st.d    r0++, r4
800064da:	c0 72       	brcc	800064e8 <idata_load_loop_end>
  cp      r0, r1
800064dc:	fe c2 93 c4 	sub	r2,pc,-27708

800064e0 <idata_load_loop>:
  brlo    idata_load_loop
idata_load_loop_end:

  // Clear uninitialized data having a global lifetime in the blank static storage section.
  lda.w   r0, __bss_start
800064e0:	a5 05       	ld.d	r4,r2++
  lda.w   r1, _end
800064e2:	a1 24       	st.d	r0++,r4
  cp      r0, r1
800064e4:	02 30       	cp.w	r0,r1
  brhs    udata_clear_loop_end
800064e6:	cf d3       	brcs	800064e0 <idata_load_loop>

800064e8 <idata_load_loop_end>:
  mov     r2, 0
800064e8:	e0 60 0a 38 	mov	r0,2616
  mov     r3, 0
udata_clear_loop:
  st.d    r0++, r2
800064ec:	e0 61 40 f8 	mov	r1,16632
  cp      r0, r1
  brlo    udata_clear_loop
800064f0:	02 30       	cp.w	r0,r1
  // Safety: Set the default "return" @ to the exit routine address.
  lda.w   lr, exit
#endif

  // Start the show.
  lda.w   pc, main
800064f2:	c0 62       	brcc	800064fe <udata_clear_loop_end>
800064f4:	30 02       	mov	r2,0
800064f6:	30 03       	mov	r3,0

800064f8 <udata_clear_loop>:
800064f8:	a1 22       	st.d	r0++,r2
800064fa:	02 30       	cp.w	r0,r1
800064fc:	cf e3       	brcs	800064f8 <udata_clear_loop>

800064fe <udata_clear_loop_end>:
800064fe:	fe cf 01 42 	sub	pc,pc,322
80006502:	d7 03       	nop

80006504 <free>:
80006504:	d4 01       	pushm	lr
80006506:	e0 68 0a 30 	mov	r8,2608
8000650a:	18 9b       	mov	r11,r12
8000650c:	70 0c       	ld.w	r12,r8[0x0]
8000650e:	e0 a0 1e 6d 	rcall	8000a1e8 <_free_r>
80006512:	d8 02       	popm	pc

80006514 <malloc>:
80006514:	d4 01       	pushm	lr
80006516:	e0 68 0a 30 	mov	r8,2608
8000651a:	18 9b       	mov	r11,r12
8000651c:	70 0c       	ld.w	r12,r8[0x0]
8000651e:	c0 3c       	rcall	80006524 <_malloc_r>
80006520:	d8 02       	popm	pc
80006522:	d7 03       	nop

80006524 <_malloc_r>:
80006524:	d4 31       	pushm	r0-r7,lr
80006526:	f6 c8 ff f5 	sub	r8,r11,-11
8000652a:	18 95       	mov	r5,r12
8000652c:	10 97       	mov	r7,r8
8000652e:	e0 17 ff f8 	andl	r7,0xfff8
80006532:	59 68       	cp.w	r8,22
80006534:	f9 b7 08 10 	movls	r7,16
80006538:	16 37       	cp.w	r7,r11
8000653a:	5f 38       	srlo	r8
8000653c:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
80006540:	c0 50       	breq	8000654a <_malloc_r+0x26>
80006542:	30 c8       	mov	r8,12
80006544:	99 38       	st.w	r12[0xc],r8
80006546:	e0 8f 01 fa 	bral	8000693a <_malloc_r+0x416>
8000654a:	fe b0 f5 89 	rcall	8000505c <__malloc_lock>
8000654e:	e0 47 01 f7 	cp.w	r7,503
80006552:	e0 8b 00 1d 	brhi	8000658c <_malloc_r+0x68>
80006556:	ee 03 16 03 	lsr	r3,r7,0x3
8000655a:	e0 68 05 30 	mov	r8,1328
8000655e:	f0 03 00 38 	add	r8,r8,r3<<0x3
80006562:	70 36       	ld.w	r6,r8[0xc]
80006564:	10 36       	cp.w	r6,r8
80006566:	c0 61       	brne	80006572 <_malloc_r+0x4e>
80006568:	ec c8 ff f8 	sub	r8,r6,-8
8000656c:	70 36       	ld.w	r6,r8[0xc]
8000656e:	10 36       	cp.w	r6,r8
80006570:	c0 c0       	breq	80006588 <_malloc_r+0x64>
80006572:	6c 18       	ld.w	r8,r6[0x4]
80006574:	e0 18 ff fc 	andl	r8,0xfffc
80006578:	6c 3a       	ld.w	r10,r6[0xc]
8000657a:	ec 08 00 09 	add	r9,r6,r8
8000657e:	0a 9c       	mov	r12,r5
80006580:	6c 28       	ld.w	r8,r6[0x8]
80006582:	95 28       	st.w	r10[0x8],r8
80006584:	91 3a       	st.w	r8[0xc],r10
80006586:	c4 78       	rjmp	80006614 <_malloc_r+0xf0>
80006588:	2f e3       	sub	r3,-2
8000658a:	c4 d8       	rjmp	80006624 <_malloc_r+0x100>
8000658c:	ee 03 16 09 	lsr	r3,r7,0x9
80006590:	c0 41       	brne	80006598 <_malloc_r+0x74>
80006592:	ee 03 16 03 	lsr	r3,r7,0x3
80006596:	c2 68       	rjmp	800065e2 <_malloc_r+0xbe>
80006598:	58 43       	cp.w	r3,4
8000659a:	e0 8b 00 06 	brhi	800065a6 <_malloc_r+0x82>
8000659e:	ee 03 16 06 	lsr	r3,r7,0x6
800065a2:	2c 83       	sub	r3,-56
800065a4:	c1 f8       	rjmp	800065e2 <_malloc_r+0xbe>
800065a6:	59 43       	cp.w	r3,20
800065a8:	e0 8b 00 04 	brhi	800065b0 <_malloc_r+0x8c>
800065ac:	2a 53       	sub	r3,-91
800065ae:	c1 a8       	rjmp	800065e2 <_malloc_r+0xbe>
800065b0:	e0 43 00 54 	cp.w	r3,84
800065b4:	e0 8b 00 06 	brhi	800065c0 <_malloc_r+0x9c>
800065b8:	ee 03 16 0c 	lsr	r3,r7,0xc
800065bc:	29 23       	sub	r3,-110
800065be:	c1 28       	rjmp	800065e2 <_malloc_r+0xbe>
800065c0:	e0 43 01 54 	cp.w	r3,340
800065c4:	e0 8b 00 06 	brhi	800065d0 <_malloc_r+0xac>
800065c8:	ee 03 16 0f 	lsr	r3,r7,0xf
800065cc:	28 93       	sub	r3,-119
800065ce:	c0 a8       	rjmp	800065e2 <_malloc_r+0xbe>
800065d0:	e0 43 05 54 	cp.w	r3,1364
800065d4:	e0 88 00 04 	brls	800065dc <_malloc_r+0xb8>
800065d8:	37 e3       	mov	r3,126
800065da:	c0 48       	rjmp	800065e2 <_malloc_r+0xbe>
800065dc:	ee 03 16 12 	lsr	r3,r7,0x12
800065e0:	28 43       	sub	r3,-124
800065e2:	e0 6a 05 30 	mov	r10,1328
800065e6:	f4 03 00 3a 	add	r10,r10,r3<<0x3
800065ea:	74 36       	ld.w	r6,r10[0xc]
800065ec:	c1 98       	rjmp	8000661e <_malloc_r+0xfa>
800065ee:	6c 19       	ld.w	r9,r6[0x4]
800065f0:	e0 19 ff fc 	andl	r9,0xfffc
800065f4:	f2 07 01 0b 	sub	r11,r9,r7
800065f8:	58 fb       	cp.w	r11,15
800065fa:	e0 8a 00 04 	brle	80006602 <_malloc_r+0xde>
800065fe:	20 13       	sub	r3,1
80006600:	c1 18       	rjmp	80006622 <_malloc_r+0xfe>
80006602:	6c 38       	ld.w	r8,r6[0xc]
80006604:	58 0b       	cp.w	r11,0
80006606:	c0 b5       	brlt	8000661c <_malloc_r+0xf8>
80006608:	6c 2a       	ld.w	r10,r6[0x8]
8000660a:	ec 09 00 09 	add	r9,r6,r9
8000660e:	0a 9c       	mov	r12,r5
80006610:	91 2a       	st.w	r8[0x8],r10
80006612:	95 38       	st.w	r10[0xc],r8
80006614:	72 18       	ld.w	r8,r9[0x4]
80006616:	a1 a8       	sbr	r8,0x0
80006618:	93 18       	st.w	r9[0x4],r8
8000661a:	cb c8       	rjmp	80006792 <_malloc_r+0x26e>
8000661c:	10 96       	mov	r6,r8
8000661e:	14 36       	cp.w	r6,r10
80006620:	ce 71       	brne	800065ee <_malloc_r+0xca>
80006622:	2f f3       	sub	r3,-1
80006624:	e0 6a 05 30 	mov	r10,1328
80006628:	f4 cc ff f8 	sub	r12,r10,-8
8000662c:	78 26       	ld.w	r6,r12[0x8]
8000662e:	18 36       	cp.w	r6,r12
80006630:	c6 c0       	breq	80006708 <_malloc_r+0x1e4>
80006632:	6c 19       	ld.w	r9,r6[0x4]
80006634:	e0 19 ff fc 	andl	r9,0xfffc
80006638:	f2 07 01 08 	sub	r8,r9,r7
8000663c:	58 f8       	cp.w	r8,15
8000663e:	e0 89 00 8f 	brgt	8000675c <_malloc_r+0x238>
80006642:	99 3c       	st.w	r12[0xc],r12
80006644:	99 2c       	st.w	r12[0x8],r12
80006646:	58 08       	cp.w	r8,0
80006648:	c0 55       	brlt	80006652 <_malloc_r+0x12e>
8000664a:	ec 09 00 09 	add	r9,r6,r9
8000664e:	0a 9c       	mov	r12,r5
80006650:	ce 2b       	rjmp	80006614 <_malloc_r+0xf0>
80006652:	e0 49 01 ff 	cp.w	r9,511
80006656:	e0 8b 00 13 	brhi	8000667c <_malloc_r+0x158>
8000665a:	a3 99       	lsr	r9,0x3
8000665c:	f4 09 00 38 	add	r8,r10,r9<<0x3
80006660:	70 2b       	ld.w	r11,r8[0x8]
80006662:	8d 38       	st.w	r6[0xc],r8
80006664:	8d 2b       	st.w	r6[0x8],r11
80006666:	97 36       	st.w	r11[0xc],r6
80006668:	91 26       	st.w	r8[0x8],r6
8000666a:	a3 49       	asr	r9,0x2
8000666c:	74 18       	ld.w	r8,r10[0x4]
8000666e:	30 1b       	mov	r11,1
80006670:	f6 09 09 49 	lsl	r9,r11,r9
80006674:	f1 e9 10 09 	or	r9,r8,r9
80006678:	95 19       	st.w	r10[0x4],r9
8000667a:	c4 78       	rjmp	80006708 <_malloc_r+0x1e4>
8000667c:	f2 0a 16 09 	lsr	r10,r9,0x9
80006680:	58 4a       	cp.w	r10,4
80006682:	e0 8b 00 07 	brhi	80006690 <_malloc_r+0x16c>
80006686:	f2 0a 16 06 	lsr	r10,r9,0x6
8000668a:	2c 8a       	sub	r10,-56
8000668c:	c2 08       	rjmp	800066cc <_malloc_r+0x1a8>
8000668e:	d7 03       	nop
80006690:	59 4a       	cp.w	r10,20
80006692:	e0 8b 00 04 	brhi	8000669a <_malloc_r+0x176>
80006696:	2a 5a       	sub	r10,-91
80006698:	c1 a8       	rjmp	800066cc <_malloc_r+0x1a8>
8000669a:	e0 4a 00 54 	cp.w	r10,84
8000669e:	e0 8b 00 06 	brhi	800066aa <_malloc_r+0x186>
800066a2:	f2 0a 16 0c 	lsr	r10,r9,0xc
800066a6:	29 2a       	sub	r10,-110
800066a8:	c1 28       	rjmp	800066cc <_malloc_r+0x1a8>
800066aa:	e0 4a 01 54 	cp.w	r10,340
800066ae:	e0 8b 00 06 	brhi	800066ba <_malloc_r+0x196>
800066b2:	f2 0a 16 0f 	lsr	r10,r9,0xf
800066b6:	28 9a       	sub	r10,-119
800066b8:	c0 a8       	rjmp	800066cc <_malloc_r+0x1a8>
800066ba:	e0 4a 05 54 	cp.w	r10,1364
800066be:	e0 88 00 04 	brls	800066c6 <_malloc_r+0x1a2>
800066c2:	37 ea       	mov	r10,126
800066c4:	c0 48       	rjmp	800066cc <_malloc_r+0x1a8>
800066c6:	f2 0a 16 12 	lsr	r10,r9,0x12
800066ca:	28 4a       	sub	r10,-124
800066cc:	e0 6b 05 30 	mov	r11,1328
800066d0:	f6 0a 00 34 	add	r4,r11,r10<<0x3
800066d4:	68 28       	ld.w	r8,r4[0x8]
800066d6:	08 38       	cp.w	r8,r4
800066d8:	c0 e1       	brne	800066f4 <_malloc_r+0x1d0>
800066da:	76 19       	ld.w	r9,r11[0x4]
800066dc:	a3 4a       	asr	r10,0x2
800066de:	30 1e       	mov	lr,1
800066e0:	fc 0a 09 4a 	lsl	r10,lr,r10
800066e4:	f3 ea 10 0a 	or	r10,r9,r10
800066e8:	10 99       	mov	r9,r8
800066ea:	97 1a       	st.w	r11[0x4],r10
800066ec:	c0 a8       	rjmp	80006700 <_malloc_r+0x1dc>
800066ee:	70 28       	ld.w	r8,r8[0x8]
800066f0:	08 38       	cp.w	r8,r4
800066f2:	c0 60       	breq	800066fe <_malloc_r+0x1da>
800066f4:	70 1a       	ld.w	r10,r8[0x4]
800066f6:	e0 1a ff fc 	andl	r10,0xfffc
800066fa:	14 39       	cp.w	r9,r10
800066fc:	cf 93       	brcs	800066ee <_malloc_r+0x1ca>
800066fe:	70 39       	ld.w	r9,r8[0xc]
80006700:	8d 39       	st.w	r6[0xc],r9
80006702:	8d 28       	st.w	r6[0x8],r8
80006704:	91 36       	st.w	r8[0xc],r6
80006706:	93 26       	st.w	r9[0x8],r6
80006708:	e6 08 14 02 	asr	r8,r3,0x2
8000670c:	30 1b       	mov	r11,1
8000670e:	e0 64 05 30 	mov	r4,1328
80006712:	f6 08 09 4b 	lsl	r11,r11,r8
80006716:	68 18       	ld.w	r8,r4[0x4]
80006718:	10 3b       	cp.w	r11,r8
8000671a:	e0 8b 00 6b 	brhi	800067f0 <_malloc_r+0x2cc>
8000671e:	f7 e8 00 09 	and	r9,r11,r8
80006722:	c0 b1       	brne	80006738 <_malloc_r+0x214>
80006724:	e0 13 ff fc 	andl	r3,0xfffc
80006728:	a1 7b       	lsl	r11,0x1
8000672a:	2f c3       	sub	r3,-4
8000672c:	c0 38       	rjmp	80006732 <_malloc_r+0x20e>
8000672e:	2f c3       	sub	r3,-4
80006730:	a1 7b       	lsl	r11,0x1
80006732:	f7 e8 00 09 	and	r9,r11,r8
80006736:	cf c0       	breq	8000672e <_malloc_r+0x20a>
80006738:	e8 03 00 3e 	add	lr,r4,r3<<0x3
8000673c:	06 92       	mov	r2,r3
8000673e:	1c 91       	mov	r1,lr
80006740:	62 36       	ld.w	r6,r1[0xc]
80006742:	c2 e8       	rjmp	8000679e <_malloc_r+0x27a>
80006744:	6c 1a       	ld.w	r10,r6[0x4]
80006746:	e0 1a ff fc 	andl	r10,0xfffc
8000674a:	f4 07 01 08 	sub	r8,r10,r7
8000674e:	58 f8       	cp.w	r8,15
80006750:	e0 8a 00 15 	brle	8000677a <_malloc_r+0x256>
80006754:	6c 3a       	ld.w	r10,r6[0xc]
80006756:	6c 29       	ld.w	r9,r6[0x8]
80006758:	95 29       	st.w	r10[0x8],r9
8000675a:	93 3a       	st.w	r9[0xc],r10
8000675c:	0e 99       	mov	r9,r7
8000675e:	ec 07 00 07 	add	r7,r6,r7
80006762:	a1 a9       	sbr	r9,0x0
80006764:	99 37       	st.w	r12[0xc],r7
80006766:	99 27       	st.w	r12[0x8],r7
80006768:	8d 19       	st.w	r6[0x4],r9
8000676a:	ee 08 09 08 	st.w	r7[r8],r8
8000676e:	8f 2c       	st.w	r7[0x8],r12
80006770:	8f 3c       	st.w	r7[0xc],r12
80006772:	a1 a8       	sbr	r8,0x0
80006774:	0a 9c       	mov	r12,r5
80006776:	8f 18       	st.w	r7[0x4],r8
80006778:	c0 d8       	rjmp	80006792 <_malloc_r+0x26e>
8000677a:	6c 39       	ld.w	r9,r6[0xc]
8000677c:	58 08       	cp.w	r8,0
8000677e:	c0 f5       	brlt	8000679c <_malloc_r+0x278>
80006780:	ec 0a 00 0a 	add	r10,r6,r10
80006784:	74 18       	ld.w	r8,r10[0x4]
80006786:	a1 a8       	sbr	r8,0x0
80006788:	0a 9c       	mov	r12,r5
8000678a:	95 18       	st.w	r10[0x4],r8
8000678c:	6c 28       	ld.w	r8,r6[0x8]
8000678e:	93 28       	st.w	r9[0x8],r8
80006790:	91 39       	st.w	r8[0xc],r9
80006792:	fe b0 f4 6b 	rcall	80005068 <__malloc_unlock>
80006796:	ec cc ff f8 	sub	r12,r6,-8
8000679a:	d8 32       	popm	r0-r7,pc
8000679c:	12 96       	mov	r6,r9
8000679e:	02 36       	cp.w	r6,r1
800067a0:	cd 21       	brne	80006744 <_malloc_r+0x220>
800067a2:	2f f2       	sub	r2,-1
800067a4:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
800067a8:	c0 30       	breq	800067ae <_malloc_r+0x28a>
800067aa:	2f 81       	sub	r1,-8
800067ac:	cc ab       	rjmp	80006740 <_malloc_r+0x21c>
800067ae:	1c 98       	mov	r8,lr
800067b0:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
800067b4:	c0 81       	brne	800067c4 <_malloc_r+0x2a0>
800067b6:	68 19       	ld.w	r9,r4[0x4]
800067b8:	f6 08 11 ff 	rsub	r8,r11,-1
800067bc:	f3 e8 00 08 	and	r8,r9,r8
800067c0:	89 18       	st.w	r4[0x4],r8
800067c2:	c0 78       	rjmp	800067d0 <_malloc_r+0x2ac>
800067c4:	f0 c9 00 08 	sub	r9,r8,8
800067c8:	20 13       	sub	r3,1
800067ca:	70 08       	ld.w	r8,r8[0x0]
800067cc:	12 38       	cp.w	r8,r9
800067ce:	cf 10       	breq	800067b0 <_malloc_r+0x28c>
800067d0:	a1 7b       	lsl	r11,0x1
800067d2:	68 18       	ld.w	r8,r4[0x4]
800067d4:	10 3b       	cp.w	r11,r8
800067d6:	e0 8b 00 0d 	brhi	800067f0 <_malloc_r+0x2cc>
800067da:	58 0b       	cp.w	r11,0
800067dc:	c0 a0       	breq	800067f0 <_malloc_r+0x2cc>
800067de:	04 93       	mov	r3,r2
800067e0:	c0 38       	rjmp	800067e6 <_malloc_r+0x2c2>
800067e2:	2f c3       	sub	r3,-4
800067e4:	a1 7b       	lsl	r11,0x1
800067e6:	f7 e8 00 09 	and	r9,r11,r8
800067ea:	ca 71       	brne	80006738 <_malloc_r+0x214>
800067ec:	cf bb       	rjmp	800067e2 <_malloc_r+0x2be>
800067ee:	d7 03       	nop
800067f0:	68 23       	ld.w	r3,r4[0x8]
800067f2:	66 12       	ld.w	r2,r3[0x4]
800067f4:	e0 12 ff fc 	andl	r2,0xfffc
800067f8:	0e 32       	cp.w	r2,r7
800067fa:	5f 39       	srlo	r9
800067fc:	e4 07 01 08 	sub	r8,r2,r7
80006800:	58 f8       	cp.w	r8,15
80006802:	5f aa       	srle	r10
80006804:	f5 e9 10 09 	or	r9,r10,r9
80006808:	e0 80 00 9a 	breq	8000693c <_malloc_r+0x418>
8000680c:	e0 68 0d 40 	mov	r8,3392
80006810:	70 01       	ld.w	r1,r8[0x0]
80006812:	e0 68 09 3c 	mov	r8,2364
80006816:	2f 01       	sub	r1,-16
80006818:	70 08       	ld.w	r8,r8[0x0]
8000681a:	0e 01       	add	r1,r7
8000681c:	5b f8       	cp.w	r8,-1
8000681e:	c0 40       	breq	80006826 <_malloc_r+0x302>
80006820:	28 11       	sub	r1,-127
80006822:	e0 11 ff 80 	andl	r1,0xff80
80006826:	02 9b       	mov	r11,r1
80006828:	0a 9c       	mov	r12,r5
8000682a:	e0 a0 02 a5 	rcall	80006d74 <_sbrk_r>
8000682e:	18 96       	mov	r6,r12
80006830:	5b fc       	cp.w	r12,-1
80006832:	c7 50       	breq	8000691c <_malloc_r+0x3f8>
80006834:	e6 02 00 08 	add	r8,r3,r2
80006838:	10 3c       	cp.w	r12,r8
8000683a:	c0 32       	brcc	80006840 <_malloc_r+0x31c>
8000683c:	08 33       	cp.w	r3,r4
8000683e:	c6 f1       	brne	8000691c <_malloc_r+0x3f8>
80006840:	e0 6a 0d 44 	mov	r10,3396
80006844:	74 09       	ld.w	r9,r10[0x0]
80006846:	e2 09 00 09 	add	r9,r1,r9
8000684a:	95 09       	st.w	r10[0x0],r9
8000684c:	10 36       	cp.w	r6,r8
8000684e:	c0 a1       	brne	80006862 <_malloc_r+0x33e>
80006850:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
80006854:	c0 71       	brne	80006862 <_malloc_r+0x33e>
80006856:	e2 02 00 02 	add	r2,r1,r2
8000685a:	68 28       	ld.w	r8,r4[0x8]
8000685c:	a1 a2       	sbr	r2,0x0
8000685e:	91 12       	st.w	r8[0x4],r2
80006860:	c4 f8       	rjmp	800068fe <_malloc_r+0x3da>
80006862:	e0 6a 09 3c 	mov	r10,2364
80006866:	74 0b       	ld.w	r11,r10[0x0]
80006868:	5b fb       	cp.w	r11,-1
8000686a:	c0 31       	brne	80006870 <_malloc_r+0x34c>
8000686c:	95 06       	st.w	r10[0x0],r6
8000686e:	c0 78       	rjmp	8000687c <_malloc_r+0x358>
80006870:	ec 09 00 09 	add	r9,r6,r9
80006874:	e0 6a 0d 44 	mov	r10,3396
80006878:	10 19       	sub	r9,r8
8000687a:	95 09       	st.w	r10[0x0],r9
8000687c:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
80006880:	f0 09 11 08 	rsub	r9,r8,8
80006884:	58 08       	cp.w	r8,0
80006886:	f2 08 17 10 	movne	r8,r9
8000688a:	ed d8 e1 06 	addne	r6,r6,r8
8000688e:	28 08       	sub	r8,-128
80006890:	ec 01 00 01 	add	r1,r6,r1
80006894:	0a 9c       	mov	r12,r5
80006896:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
8000689a:	f0 01 01 01 	sub	r1,r8,r1
8000689e:	02 9b       	mov	r11,r1
800068a0:	e0 a0 02 6a 	rcall	80006d74 <_sbrk_r>
800068a4:	e0 68 0d 44 	mov	r8,3396
800068a8:	5b fc       	cp.w	r12,-1
800068aa:	ec 0c 17 00 	moveq	r12,r6
800068ae:	f9 b1 00 00 	moveq	r1,0
800068b2:	70 09       	ld.w	r9,r8[0x0]
800068b4:	0c 1c       	sub	r12,r6
800068b6:	89 26       	st.w	r4[0x8],r6
800068b8:	02 0c       	add	r12,r1
800068ba:	12 01       	add	r1,r9
800068bc:	a1 ac       	sbr	r12,0x0
800068be:	91 01       	st.w	r8[0x0],r1
800068c0:	8d 1c       	st.w	r6[0x4],r12
800068c2:	08 33       	cp.w	r3,r4
800068c4:	c1 d0       	breq	800068fe <_malloc_r+0x3da>
800068c6:	58 f2       	cp.w	r2,15
800068c8:	e0 8b 00 05 	brhi	800068d2 <_malloc_r+0x3ae>
800068cc:	30 18       	mov	r8,1
800068ce:	8d 18       	st.w	r6[0x4],r8
800068d0:	c2 68       	rjmp	8000691c <_malloc_r+0x3f8>
800068d2:	30 59       	mov	r9,5
800068d4:	20 c2       	sub	r2,12
800068d6:	e0 12 ff f8 	andl	r2,0xfff8
800068da:	e6 02 00 08 	add	r8,r3,r2
800068de:	91 29       	st.w	r8[0x8],r9
800068e0:	91 19       	st.w	r8[0x4],r9
800068e2:	66 18       	ld.w	r8,r3[0x4]
800068e4:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800068e8:	e5 e8 10 08 	or	r8,r2,r8
800068ec:	87 18       	st.w	r3[0x4],r8
800068ee:	58 f2       	cp.w	r2,15
800068f0:	e0 88 00 07 	brls	800068fe <_malloc_r+0x3da>
800068f4:	e6 cb ff f8 	sub	r11,r3,-8
800068f8:	0a 9c       	mov	r12,r5
800068fa:	e0 a0 1c 77 	rcall	8000a1e8 <_free_r>
800068fe:	e0 69 0d 3c 	mov	r9,3388
80006902:	72 0a       	ld.w	r10,r9[0x0]
80006904:	e0 68 0d 44 	mov	r8,3396
80006908:	70 08       	ld.w	r8,r8[0x0]
8000690a:	14 38       	cp.w	r8,r10
8000690c:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80006910:	e0 69 0d 38 	mov	r9,3384
80006914:	72 0a       	ld.w	r10,r9[0x0]
80006916:	14 38       	cp.w	r8,r10
80006918:	f3 f8 ba 00 	st.whi	r9[0x0],r8
8000691c:	68 28       	ld.w	r8,r4[0x8]
8000691e:	70 18       	ld.w	r8,r8[0x4]
80006920:	e0 18 ff fc 	andl	r8,0xfffc
80006924:	0e 38       	cp.w	r8,r7
80006926:	5f 39       	srlo	r9
80006928:	0e 18       	sub	r8,r7
8000692a:	58 f8       	cp.w	r8,15
8000692c:	5f aa       	srle	r10
8000692e:	f5 e9 10 09 	or	r9,r10,r9
80006932:	c0 50       	breq	8000693c <_malloc_r+0x418>
80006934:	0a 9c       	mov	r12,r5
80006936:	fe b0 f3 99 	rcall	80005068 <__malloc_unlock>
8000693a:	d8 3a       	popm	r0-r7,pc,r12=0
8000693c:	68 26       	ld.w	r6,r4[0x8]
8000693e:	a1 a8       	sbr	r8,0x0
80006940:	0e 99       	mov	r9,r7
80006942:	a1 a9       	sbr	r9,0x0
80006944:	8d 19       	st.w	r6[0x4],r9
80006946:	ec 07 00 07 	add	r7,r6,r7
8000694a:	0a 9c       	mov	r12,r5
8000694c:	89 27       	st.w	r4[0x8],r7
8000694e:	8f 18       	st.w	r7[0x4],r8
80006950:	fe b0 f3 8c 	rcall	80005068 <__malloc_unlock>
80006954:	ec cc ff f8 	sub	r12,r6,-8
80006958:	d8 32       	popm	r0-r7,pc
8000695a:	d7 03       	nop

8000695c <memcpy>:
8000695c:	58 8a       	cp.w	r10,8
8000695e:	c2 f5       	brlt	800069bc <memcpy+0x60>
80006960:	f9 eb 10 09 	or	r9,r12,r11
80006964:	e2 19 00 03 	andl	r9,0x3,COH
80006968:	e0 81 00 97 	brne	80006a96 <memcpy+0x13a>
8000696c:	e0 4a 00 20 	cp.w	r10,32
80006970:	c3 b4       	brge	800069e6 <memcpy+0x8a>
80006972:	f4 08 14 02 	asr	r8,r10,0x2
80006976:	f0 09 11 08 	rsub	r9,r8,8
8000697a:	fe 09 00 2f 	add	pc,pc,r9<<0x2
8000697e:	76 69       	ld.w	r9,r11[0x18]
80006980:	99 69       	st.w	r12[0x18],r9
80006982:	76 59       	ld.w	r9,r11[0x14]
80006984:	99 59       	st.w	r12[0x14],r9
80006986:	76 49       	ld.w	r9,r11[0x10]
80006988:	99 49       	st.w	r12[0x10],r9
8000698a:	76 39       	ld.w	r9,r11[0xc]
8000698c:	99 39       	st.w	r12[0xc],r9
8000698e:	76 29       	ld.w	r9,r11[0x8]
80006990:	99 29       	st.w	r12[0x8],r9
80006992:	76 19       	ld.w	r9,r11[0x4]
80006994:	99 19       	st.w	r12[0x4],r9
80006996:	76 09       	ld.w	r9,r11[0x0]
80006998:	99 09       	st.w	r12[0x0],r9
8000699a:	f6 08 00 2b 	add	r11,r11,r8<<0x2
8000699e:	f8 08 00 28 	add	r8,r12,r8<<0x2
800069a2:	e0 1a 00 03 	andl	r10,0x3
800069a6:	f4 0a 11 04 	rsub	r10,r10,4
800069aa:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
800069ae:	17 a9       	ld.ub	r9,r11[0x2]
800069b0:	b0 a9       	st.b	r8[0x2],r9
800069b2:	17 99       	ld.ub	r9,r11[0x1]
800069b4:	b0 99       	st.b	r8[0x1],r9
800069b6:	17 89       	ld.ub	r9,r11[0x0]
800069b8:	b0 89       	st.b	r8[0x0],r9
800069ba:	5e fc       	retal	r12
800069bc:	f4 0a 11 09 	rsub	r10,r10,9
800069c0:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
800069c4:	17 f9       	ld.ub	r9,r11[0x7]
800069c6:	b8 f9       	st.b	r12[0x7],r9
800069c8:	17 e9       	ld.ub	r9,r11[0x6]
800069ca:	b8 e9       	st.b	r12[0x6],r9
800069cc:	17 d9       	ld.ub	r9,r11[0x5]
800069ce:	b8 d9       	st.b	r12[0x5],r9
800069d0:	17 c9       	ld.ub	r9,r11[0x4]
800069d2:	b8 c9       	st.b	r12[0x4],r9
800069d4:	17 b9       	ld.ub	r9,r11[0x3]
800069d6:	b8 b9       	st.b	r12[0x3],r9
800069d8:	17 a9       	ld.ub	r9,r11[0x2]
800069da:	b8 a9       	st.b	r12[0x2],r9
800069dc:	17 99       	ld.ub	r9,r11[0x1]
800069de:	b8 99       	st.b	r12[0x1],r9
800069e0:	17 89       	ld.ub	r9,r11[0x0]
800069e2:	b8 89       	st.b	r12[0x0],r9
800069e4:	5e fc       	retal	r12
800069e6:	eb cd 40 c0 	pushm	r6-r7,lr
800069ea:	18 99       	mov	r9,r12
800069ec:	22 0a       	sub	r10,32
800069ee:	b7 07       	ld.d	r6,r11++
800069f0:	b3 26       	st.d	r9++,r6
800069f2:	b7 07       	ld.d	r6,r11++
800069f4:	b3 26       	st.d	r9++,r6
800069f6:	b7 07       	ld.d	r6,r11++
800069f8:	b3 26       	st.d	r9++,r6
800069fa:	b7 07       	ld.d	r6,r11++
800069fc:	b3 26       	st.d	r9++,r6
800069fe:	22 0a       	sub	r10,32
80006a00:	cf 74       	brge	800069ee <memcpy+0x92>
80006a02:	2f 0a       	sub	r10,-16
80006a04:	c0 65       	brlt	80006a10 <memcpy+0xb4>
80006a06:	b7 07       	ld.d	r6,r11++
80006a08:	b3 26       	st.d	r9++,r6
80006a0a:	b7 07       	ld.d	r6,r11++
80006a0c:	b3 26       	st.d	r9++,r6
80006a0e:	21 0a       	sub	r10,16
80006a10:	5c 3a       	neg	r10
80006a12:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
80006a16:	d7 03       	nop
80006a18:	d7 03       	nop
80006a1a:	f7 36 00 0e 	ld.ub	r6,r11[14]
80006a1e:	f3 66 00 0e 	st.b	r9[14],r6
80006a22:	f7 36 00 0d 	ld.ub	r6,r11[13]
80006a26:	f3 66 00 0d 	st.b	r9[13],r6
80006a2a:	f7 36 00 0c 	ld.ub	r6,r11[12]
80006a2e:	f3 66 00 0c 	st.b	r9[12],r6
80006a32:	f7 36 00 0b 	ld.ub	r6,r11[11]
80006a36:	f3 66 00 0b 	st.b	r9[11],r6
80006a3a:	f7 36 00 0a 	ld.ub	r6,r11[10]
80006a3e:	f3 66 00 0a 	st.b	r9[10],r6
80006a42:	f7 36 00 09 	ld.ub	r6,r11[9]
80006a46:	f3 66 00 09 	st.b	r9[9],r6
80006a4a:	f7 36 00 08 	ld.ub	r6,r11[8]
80006a4e:	f3 66 00 08 	st.b	r9[8],r6
80006a52:	f7 36 00 07 	ld.ub	r6,r11[7]
80006a56:	f3 66 00 07 	st.b	r9[7],r6
80006a5a:	f7 36 00 06 	ld.ub	r6,r11[6]
80006a5e:	f3 66 00 06 	st.b	r9[6],r6
80006a62:	f7 36 00 05 	ld.ub	r6,r11[5]
80006a66:	f3 66 00 05 	st.b	r9[5],r6
80006a6a:	f7 36 00 04 	ld.ub	r6,r11[4]
80006a6e:	f3 66 00 04 	st.b	r9[4],r6
80006a72:	f7 36 00 03 	ld.ub	r6,r11[3]
80006a76:	f3 66 00 03 	st.b	r9[3],r6
80006a7a:	f7 36 00 02 	ld.ub	r6,r11[2]
80006a7e:	f3 66 00 02 	st.b	r9[2],r6
80006a82:	f7 36 00 01 	ld.ub	r6,r11[1]
80006a86:	f3 66 00 01 	st.b	r9[1],r6
80006a8a:	f7 36 00 00 	ld.ub	r6,r11[0]
80006a8e:	f3 66 00 00 	st.b	r9[0],r6
80006a92:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006a96:	20 1a       	sub	r10,1
80006a98:	f6 0a 07 09 	ld.ub	r9,r11[r10]
80006a9c:	f8 0a 0b 09 	st.b	r12[r10],r9
80006aa0:	cf b1       	brne	80006a96 <memcpy+0x13a>
80006aa2:	5e fc       	retal	r12

80006aa4 <memset>:
80006aa4:	18 98       	mov	r8,r12
80006aa6:	c0 38       	rjmp	80006aac <memset+0x8>
80006aa8:	10 cb       	st.b	r8++,r11
80006aaa:	20 1a       	sub	r10,1
80006aac:	58 0a       	cp.w	r10,0
80006aae:	cf d1       	brne	80006aa8 <memset+0x4>
80006ab0:	5e fc       	retal	r12
80006ab2:	d7 03       	nop

80006ab4 <_realloc_r>:
80006ab4:	d4 31       	pushm	r0-r7,lr
80006ab6:	20 1d       	sub	sp,4
80006ab8:	16 94       	mov	r4,r11
80006aba:	18 92       	mov	r2,r12
80006abc:	14 9b       	mov	r11,r10
80006abe:	58 04       	cp.w	r4,0
80006ac0:	c0 51       	brne	80006aca <_realloc_r+0x16>
80006ac2:	fe b0 fd 31 	rcall	80006524 <_malloc_r>
80006ac6:	18 95       	mov	r5,r12
80006ac8:	c5 39       	rjmp	80006d6e <_realloc_r+0x2ba>
80006aca:	50 0a       	stdsp	sp[0x0],r10
80006acc:	fe b0 f2 c8 	rcall	8000505c <__malloc_lock>
80006ad0:	40 0b       	lddsp	r11,sp[0x0]
80006ad2:	f6 c8 ff f5 	sub	r8,r11,-11
80006ad6:	e8 c1 00 08 	sub	r1,r4,8
80006ada:	10 96       	mov	r6,r8
80006adc:	62 1c       	ld.w	r12,r1[0x4]
80006ade:	e0 16 ff f8 	andl	r6,0xfff8
80006ae2:	59 68       	cp.w	r8,22
80006ae4:	f9 b6 08 10 	movls	r6,16
80006ae8:	16 36       	cp.w	r6,r11
80006aea:	5f 38       	srlo	r8
80006aec:	f1 e6 13 f8 	or	r8,r8,r6>>0x1f
80006af0:	c0 50       	breq	80006afa <_realloc_r+0x46>
80006af2:	30 c8       	mov	r8,12
80006af4:	30 05       	mov	r5,0
80006af6:	85 38       	st.w	r2[0xc],r8
80006af8:	c3 b9       	rjmp	80006d6e <_realloc_r+0x2ba>
80006afa:	18 90       	mov	r0,r12
80006afc:	e0 10 ff fc 	andl	r0,0xfffc
80006b00:	0c 30       	cp.w	r0,r6
80006b02:	e0 84 01 0b 	brge	80006d18 <_realloc_r+0x264>
80006b06:	e0 68 05 30 	mov	r8,1328
80006b0a:	e2 00 00 09 	add	r9,r1,r0
80006b0e:	70 25       	ld.w	r5,r8[0x8]
80006b10:	0a 39       	cp.w	r9,r5
80006b12:	c0 90       	breq	80006b24 <_realloc_r+0x70>
80006b14:	72 1a       	ld.w	r10,r9[0x4]
80006b16:	a1 ca       	cbr	r10,0x0
80006b18:	f2 0a 00 0a 	add	r10,r9,r10
80006b1c:	74 1a       	ld.w	r10,r10[0x4]
80006b1e:	ed ba 00 00 	bld	r10,0x0
80006b22:	c2 20       	breq	80006b66 <_realloc_r+0xb2>
80006b24:	72 1a       	ld.w	r10,r9[0x4]
80006b26:	e0 1a ff fc 	andl	r10,0xfffc
80006b2a:	f4 00 00 03 	add	r3,r10,r0
80006b2e:	0a 39       	cp.w	r9,r5
80006b30:	c1 31       	brne	80006b56 <_realloc_r+0xa2>
80006b32:	ec c7 ff f0 	sub	r7,r6,-16
80006b36:	0e 33       	cp.w	r3,r7
80006b38:	c1 95       	brlt	80006b6a <_realloc_r+0xb6>
80006b3a:	e2 06 00 09 	add	r9,r1,r6
80006b3e:	0c 13       	sub	r3,r6
80006b40:	a1 a3       	sbr	r3,0x0
80006b42:	93 13       	st.w	r9[0x4],r3
80006b44:	91 29       	st.w	r8[0x8],r9
80006b46:	04 9c       	mov	r12,r2
80006b48:	62 18       	ld.w	r8,r1[0x4]
80006b4a:	08 95       	mov	r5,r4
80006b4c:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006b50:	10 46       	or	r6,r8
80006b52:	83 16       	st.w	r1[0x4],r6
80006b54:	c0 b9       	rjmp	80006d6a <_realloc_r+0x2b6>
80006b56:	0c 33       	cp.w	r3,r6
80006b58:	c0 95       	brlt	80006b6a <_realloc_r+0xb6>
80006b5a:	72 28       	ld.w	r8,r9[0x8]
80006b5c:	02 97       	mov	r7,r1
80006b5e:	72 39       	ld.w	r9,r9[0xc]
80006b60:	93 28       	st.w	r9[0x8],r8
80006b62:	91 39       	st.w	r8[0xc],r9
80006b64:	cd c8       	rjmp	80006d1c <_realloc_r+0x268>
80006b66:	30 0a       	mov	r10,0
80006b68:	14 99       	mov	r9,r10
80006b6a:	ed bc 00 00 	bld	r12,0x0
80006b6e:	e0 80 00 95 	breq	80006c98 <_realloc_r+0x1e4>
80006b72:	62 07       	ld.w	r7,r1[0x0]
80006b74:	e2 07 01 07 	sub	r7,r1,r7
80006b78:	6e 1c       	ld.w	r12,r7[0x4]
80006b7a:	e0 1c ff fc 	andl	r12,0xfffc
80006b7e:	58 09       	cp.w	r9,0
80006b80:	c5 60       	breq	80006c2c <_realloc_r+0x178>
80006b82:	f8 00 00 03 	add	r3,r12,r0
80006b86:	0a 39       	cp.w	r9,r5
80006b88:	c4 81       	brne	80006c18 <_realloc_r+0x164>
80006b8a:	14 03       	add	r3,r10
80006b8c:	ec c9 ff f0 	sub	r9,r6,-16
80006b90:	12 33       	cp.w	r3,r9
80006b92:	c4 d5       	brlt	80006c2c <_realloc_r+0x178>
80006b94:	6e 3a       	ld.w	r10,r7[0xc]
80006b96:	6e 29       	ld.w	r9,r7[0x8]
80006b98:	95 29       	st.w	r10[0x8],r9
80006b9a:	93 3a       	st.w	r9[0xc],r10
80006b9c:	ee c5 ff f8 	sub	r5,r7,-8
80006ba0:	e0 ca 00 04 	sub	r10,r0,4
80006ba4:	e0 4a 00 24 	cp.w	r10,36
80006ba8:	e0 8b 00 25 	brhi	80006bf2 <_realloc_r+0x13e>
80006bac:	0a 99       	mov	r9,r5
80006bae:	59 3a       	cp.w	r10,19
80006bb0:	e0 88 00 1a 	brls	80006be4 <_realloc_r+0x130>
80006bb4:	09 09       	ld.w	r9,r4++
80006bb6:	8b 09       	st.w	r5[0x0],r9
80006bb8:	09 09       	ld.w	r9,r4++
80006bba:	8f 39       	st.w	r7[0xc],r9
80006bbc:	ee c9 ff f0 	sub	r9,r7,-16
80006bc0:	59 ba       	cp.w	r10,27
80006bc2:	e0 88 00 11 	brls	80006be4 <_realloc_r+0x130>
80006bc6:	09 0b       	ld.w	r11,r4++
80006bc8:	93 0b       	st.w	r9[0x0],r11
80006bca:	09 09       	ld.w	r9,r4++
80006bcc:	8f 59       	st.w	r7[0x14],r9
80006bce:	ee c9 ff e8 	sub	r9,r7,-24
80006bd2:	e0 4a 00 24 	cp.w	r10,36
80006bd6:	c0 71       	brne	80006be4 <_realloc_r+0x130>
80006bd8:	09 0a       	ld.w	r10,r4++
80006bda:	93 0a       	st.w	r9[0x0],r10
80006bdc:	ee c9 ff e0 	sub	r9,r7,-32
80006be0:	09 0a       	ld.w	r10,r4++
80006be2:	8f 7a       	st.w	r7[0x1c],r10
80006be4:	09 0a       	ld.w	r10,r4++
80006be6:	12 aa       	st.w	r9++,r10
80006be8:	68 0a       	ld.w	r10,r4[0x0]
80006bea:	93 0a       	st.w	r9[0x0],r10
80006bec:	68 1a       	ld.w	r10,r4[0x4]
80006bee:	93 1a       	st.w	r9[0x4],r10
80006bf0:	c0 78       	rjmp	80006bfe <_realloc_r+0x14a>
80006bf2:	50 08       	stdsp	sp[0x0],r8
80006bf4:	08 9b       	mov	r11,r4
80006bf6:	0a 9c       	mov	r12,r5
80006bf8:	e0 a0 1d 9b 	rcall	8000a72e <memmove>
80006bfc:	40 08       	lddsp	r8,sp[0x0]
80006bfe:	ee 06 00 09 	add	r9,r7,r6
80006c02:	0c 13       	sub	r3,r6
80006c04:	a1 a3       	sbr	r3,0x0
80006c06:	93 13       	st.w	r9[0x4],r3
80006c08:	91 29       	st.w	r8[0x8],r9
80006c0a:	04 9c       	mov	r12,r2
80006c0c:	6e 18       	ld.w	r8,r7[0x4]
80006c0e:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006c12:	10 46       	or	r6,r8
80006c14:	8f 16       	st.w	r7[0x4],r6
80006c16:	ca a8       	rjmp	80006d6a <_realloc_r+0x2b6>
80006c18:	14 03       	add	r3,r10
80006c1a:	0c 33       	cp.w	r3,r6
80006c1c:	c0 85       	brlt	80006c2c <_realloc_r+0x178>
80006c1e:	72 28       	ld.w	r8,r9[0x8]
80006c20:	72 39       	ld.w	r9,r9[0xc]
80006c22:	93 28       	st.w	r9[0x8],r8
80006c24:	91 39       	st.w	r8[0xc],r9
80006c26:	6e 28       	ld.w	r8,r7[0x8]
80006c28:	6e 39       	ld.w	r9,r7[0xc]
80006c2a:	c0 78       	rjmp	80006c38 <_realloc_r+0x184>
80006c2c:	f8 00 00 03 	add	r3,r12,r0
80006c30:	0c 33       	cp.w	r3,r6
80006c32:	c3 35       	brlt	80006c98 <_realloc_r+0x1e4>
80006c34:	6e 39       	ld.w	r9,r7[0xc]
80006c36:	6e 28       	ld.w	r8,r7[0x8]
80006c38:	93 28       	st.w	r9[0x8],r8
80006c3a:	91 39       	st.w	r8[0xc],r9
80006c3c:	e0 ca 00 04 	sub	r10,r0,4
80006c40:	ee cc ff f8 	sub	r12,r7,-8
80006c44:	e0 4a 00 24 	cp.w	r10,36
80006c48:	e0 8b 00 24 	brhi	80006c90 <_realloc_r+0x1dc>
80006c4c:	59 3a       	cp.w	r10,19
80006c4e:	e0 88 00 1a 	brls	80006c82 <_realloc_r+0x1ce>
80006c52:	09 08       	ld.w	r8,r4++
80006c54:	99 08       	st.w	r12[0x0],r8
80006c56:	09 08       	ld.w	r8,r4++
80006c58:	8f 38       	st.w	r7[0xc],r8
80006c5a:	ee cc ff f0 	sub	r12,r7,-16
80006c5e:	59 ba       	cp.w	r10,27
80006c60:	e0 88 00 11 	brls	80006c82 <_realloc_r+0x1ce>
80006c64:	09 08       	ld.w	r8,r4++
80006c66:	99 08       	st.w	r12[0x0],r8
80006c68:	09 08       	ld.w	r8,r4++
80006c6a:	8f 58       	st.w	r7[0x14],r8
80006c6c:	ee cc ff e8 	sub	r12,r7,-24
80006c70:	e0 4a 00 24 	cp.w	r10,36
80006c74:	c0 71       	brne	80006c82 <_realloc_r+0x1ce>
80006c76:	09 08       	ld.w	r8,r4++
80006c78:	99 08       	st.w	r12[0x0],r8
80006c7a:	ee cc ff e0 	sub	r12,r7,-32
80006c7e:	09 08       	ld.w	r8,r4++
80006c80:	8f 78       	st.w	r7[0x1c],r8
80006c82:	09 08       	ld.w	r8,r4++
80006c84:	18 a8       	st.w	r12++,r8
80006c86:	68 08       	ld.w	r8,r4[0x0]
80006c88:	99 08       	st.w	r12[0x0],r8
80006c8a:	68 18       	ld.w	r8,r4[0x4]
80006c8c:	99 18       	st.w	r12[0x4],r8
80006c8e:	c4 78       	rjmp	80006d1c <_realloc_r+0x268>
80006c90:	08 9b       	mov	r11,r4
80006c92:	e0 a0 1d 4e 	rcall	8000a72e <memmove>
80006c96:	c4 38       	rjmp	80006d1c <_realloc_r+0x268>
80006c98:	04 9c       	mov	r12,r2
80006c9a:	fe b0 fc 45 	rcall	80006524 <_malloc_r>
80006c9e:	18 95       	mov	r5,r12
80006ca0:	c3 a0       	breq	80006d14 <_realloc_r+0x260>
80006ca2:	62 18       	ld.w	r8,r1[0x4]
80006ca4:	f8 c9 00 08 	sub	r9,r12,8
80006ca8:	a1 c8       	cbr	r8,0x0
80006caa:	e2 08 00 08 	add	r8,r1,r8
80006cae:	10 39       	cp.w	r9,r8
80006cb0:	c0 71       	brne	80006cbe <_realloc_r+0x20a>
80006cb2:	72 13       	ld.w	r3,r9[0x4]
80006cb4:	02 97       	mov	r7,r1
80006cb6:	e0 13 ff fc 	andl	r3,0xfffc
80006cba:	00 03       	add	r3,r0
80006cbc:	c3 08       	rjmp	80006d1c <_realloc_r+0x268>
80006cbe:	e0 ca 00 04 	sub	r10,r0,4
80006cc2:	e0 4a 00 24 	cp.w	r10,36
80006cc6:	e0 8b 00 20 	brhi	80006d06 <_realloc_r+0x252>
80006cca:	08 99       	mov	r9,r4
80006ccc:	18 98       	mov	r8,r12
80006cce:	59 3a       	cp.w	r10,19
80006cd0:	e0 88 00 14 	brls	80006cf8 <_realloc_r+0x244>
80006cd4:	13 0b       	ld.w	r11,r9++
80006cd6:	10 ab       	st.w	r8++,r11
80006cd8:	13 0b       	ld.w	r11,r9++
80006cda:	10 ab       	st.w	r8++,r11
80006cdc:	59 ba       	cp.w	r10,27
80006cde:	e0 88 00 0d 	brls	80006cf8 <_realloc_r+0x244>
80006ce2:	13 0b       	ld.w	r11,r9++
80006ce4:	10 ab       	st.w	r8++,r11
80006ce6:	13 0b       	ld.w	r11,r9++
80006ce8:	10 ab       	st.w	r8++,r11
80006cea:	e0 4a 00 24 	cp.w	r10,36
80006cee:	c0 51       	brne	80006cf8 <_realloc_r+0x244>
80006cf0:	13 0a       	ld.w	r10,r9++
80006cf2:	10 aa       	st.w	r8++,r10
80006cf4:	13 0a       	ld.w	r10,r9++
80006cf6:	10 aa       	st.w	r8++,r10
80006cf8:	13 0a       	ld.w	r10,r9++
80006cfa:	10 aa       	st.w	r8++,r10
80006cfc:	72 0a       	ld.w	r10,r9[0x0]
80006cfe:	91 0a       	st.w	r8[0x0],r10
80006d00:	72 19       	ld.w	r9,r9[0x4]
80006d02:	91 19       	st.w	r8[0x4],r9
80006d04:	c0 48       	rjmp	80006d0c <_realloc_r+0x258>
80006d06:	08 9b       	mov	r11,r4
80006d08:	e0 a0 1d 13 	rcall	8000a72e <memmove>
80006d0c:	08 9b       	mov	r11,r4
80006d0e:	04 9c       	mov	r12,r2
80006d10:	e0 a0 1a 6c 	rcall	8000a1e8 <_free_r>
80006d14:	04 9c       	mov	r12,r2
80006d16:	c2 a8       	rjmp	80006d6a <_realloc_r+0x2b6>
80006d18:	00 93       	mov	r3,r0
80006d1a:	02 97       	mov	r7,r1
80006d1c:	e6 06 01 09 	sub	r9,r3,r6
80006d20:	6e 18       	ld.w	r8,r7[0x4]
80006d22:	58 f9       	cp.w	r9,15
80006d24:	e0 88 00 16 	brls	80006d50 <_realloc_r+0x29c>
80006d28:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006d2c:	ed e8 10 08 	or	r8,r6,r8
80006d30:	8f 18       	st.w	r7[0x4],r8
80006d32:	12 98       	mov	r8,r9
80006d34:	a1 a8       	sbr	r8,0x0
80006d36:	ee 06 00 0b 	add	r11,r7,r6
80006d3a:	f6 09 00 09 	add	r9,r11,r9
80006d3e:	97 18       	st.w	r11[0x4],r8
80006d40:	72 18       	ld.w	r8,r9[0x4]
80006d42:	a1 a8       	sbr	r8,0x0
80006d44:	2f 8b       	sub	r11,-8
80006d46:	93 18       	st.w	r9[0x4],r8
80006d48:	04 9c       	mov	r12,r2
80006d4a:	e0 a0 1a 4f 	rcall	8000a1e8 <_free_r>
80006d4e:	c0 b8       	rjmp	80006d64 <_realloc_r+0x2b0>
80006d50:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006d54:	e7 e8 10 08 	or	r8,r3,r8
80006d58:	8f 18       	st.w	r7[0x4],r8
80006d5a:	ee 03 00 03 	add	r3,r7,r3
80006d5e:	66 18       	ld.w	r8,r3[0x4]
80006d60:	a1 a8       	sbr	r8,0x0
80006d62:	87 18       	st.w	r3[0x4],r8
80006d64:	04 9c       	mov	r12,r2
80006d66:	ee c5 ff f8 	sub	r5,r7,-8
80006d6a:	fe b0 f1 7f 	rcall	80005068 <__malloc_unlock>
80006d6e:	0a 9c       	mov	r12,r5
80006d70:	2f fd       	sub	sp,-4
80006d72:	d8 32       	popm	r0-r7,pc

80006d74 <_sbrk_r>:
80006d74:	d4 21       	pushm	r4-r7,lr
80006d76:	30 08       	mov	r8,0
80006d78:	18 97       	mov	r7,r12
80006d7a:	e0 66 40 f0 	mov	r6,16624
80006d7e:	16 9c       	mov	r12,r11
80006d80:	8d 08       	st.w	r6[0x0],r8
80006d82:	c9 1c       	rcall	80006ea4 <_sbrk>
80006d84:	5b fc       	cp.w	r12,-1
80006d86:	c0 51       	brne	80006d90 <_sbrk_r+0x1c>
80006d88:	6c 08       	ld.w	r8,r6[0x0]
80006d8a:	58 08       	cp.w	r8,0
80006d8c:	ef f8 1a 03 	st.wne	r7[0xc],r8
80006d90:	d8 22       	popm	r4-r7,pc
80006d92:	d7 03       	nop

80006d94 <sprintf>:
80006d94:	d4 01       	pushm	lr
80006d96:	21 7d       	sub	sp,92
80006d98:	e0 68 ff ff 	mov	r8,65535
80006d9c:	ea 18 7f ff 	orh	r8,0x7fff
80006da0:	50 58       	stdsp	sp[0x14],r8
80006da2:	50 28       	stdsp	sp[0x8],r8
80006da4:	e0 68 02 08 	mov	r8,520
80006da8:	ba 68       	st.h	sp[0xc],r8
80006daa:	3f f8       	mov	r8,-1
80006dac:	ba 78       	st.h	sp[0xe],r8
80006dae:	e0 68 0a 30 	mov	r8,2608
80006db2:	50 4c       	stdsp	sp[0x10],r12
80006db4:	16 9a       	mov	r10,r11
80006db6:	50 0c       	stdsp	sp[0x0],r12
80006db8:	fa c9 ff a0 	sub	r9,sp,-96
80006dbc:	70 0c       	ld.w	r12,r8[0x0]
80006dbe:	1a 9b       	mov	r11,sp
80006dc0:	e0 a0 02 26 	rcall	8000720c <_vfprintf_r>
80006dc4:	30 09       	mov	r9,0
80006dc6:	40 08       	lddsp	r8,sp[0x0]
80006dc8:	b0 89       	st.b	r8[0x0],r9
80006dca:	2e 9d       	sub	sp,-92
80006dcc:	d8 02       	popm	pc
80006dce:	d7 03       	nop

80006dd0 <strlen>:
80006dd0:	30 09       	mov	r9,0
80006dd2:	18 98       	mov	r8,r12
80006dd4:	c0 28       	rjmp	80006dd8 <strlen+0x8>
80006dd6:	2f f8       	sub	r8,-1
80006dd8:	11 8a       	ld.ub	r10,r8[0x0]
80006dda:	f2 0a 18 00 	cp.b	r10,r9
80006dde:	cf c1       	brne	80006dd6 <strlen+0x6>
80006de0:	f0 0c 01 0c 	sub	r12,r8,r12
80006de4:	5e fc       	retal	r12
80006de6:	d7 03       	nop

80006de8 <strncpy>:
80006de8:	30 08       	mov	r8,0
80006dea:	10 3a       	cp.w	r10,r8
80006dec:	5e 0c       	reteq	r12
80006dee:	f6 08 07 09 	ld.ub	r9,r11[r8]
80006df2:	f8 08 0b 09 	st.b	r12[r8],r9
80006df6:	2f f8       	sub	r8,-1
80006df8:	58 09       	cp.w	r9,0
80006dfa:	cf 81       	brne	80006dea <strncpy+0x2>
80006dfc:	10 3a       	cp.w	r10,r8
80006dfe:	5e 0c       	reteq	r12
80006e00:	f8 08 0b 09 	st.b	r12[r8],r9
80006e04:	2f f8       	sub	r8,-1
80006e06:	cf bb       	rjmp	80006dfc <strncpy+0x14>

80006e08 <_close>:
80006e08:	30 28       	mov	r8,2
80006e0a:	d6 73       	breakpoint
80006e0c:	3f fc       	mov	r12,-1
80006e0e:	35 8b       	mov	r11,88
80006e10:	58 0c       	cp.w	r12,0
80006e12:	5e 4c       	retge	r12
80006e14:	e0 6a 40 f0 	mov	r10,16624
80006e18:	95 0b       	st.w	r10[0x0],r11
80006e1a:	5e fc       	retal	r12

80006e1c <_lseek>:
80006e1c:	30 58       	mov	r8,5
80006e1e:	d6 73       	breakpoint
80006e20:	3f fc       	mov	r12,-1
80006e22:	35 8b       	mov	r11,88
80006e24:	58 0c       	cp.w	r12,0
80006e26:	5e 4c       	retge	r12
80006e28:	e0 6a 40 f0 	mov	r10,16624
80006e2c:	95 0b       	st.w	r10[0x0],r11
80006e2e:	5e fc       	retal	r12

80006e30 <isatty>:
80006e30:	30 b8       	mov	r8,11
80006e32:	d6 73       	breakpoint
80006e34:	3f fc       	mov	r12,-1
80006e36:	35 8b       	mov	r11,88
80006e38:	58 0c       	cp.w	r12,0
80006e3a:	5e 4c       	retge	r12
80006e3c:	e0 6a 40 f0 	mov	r10,16624
80006e40:	95 0b       	st.w	r10[0x0],r11
80006e42:	5e fc       	retal	r12

80006e44 <_fstat_host>:
80006e44:	30 98       	mov	r8,9
80006e46:	d6 73       	breakpoint
80006e48:	3f fc       	mov	r12,-1
80006e4a:	35 8b       	mov	r11,88
80006e4c:	58 0c       	cp.w	r12,0
80006e4e:	5e 4c       	retge	r12
80006e50:	e0 6a 40 f0 	mov	r10,16624
80006e54:	95 0b       	st.w	r10[0x0],r11
80006e56:	5e fc       	retal	r12

80006e58 <_fstat>:
80006e58:	d4 21       	pushm	r4-r7,lr
80006e5a:	21 0d       	sub	sp,64
80006e5c:	16 97       	mov	r7,r11
80006e5e:	1a 9b       	mov	r11,sp
80006e60:	cf 2f       	rcall	80006e44 <_fstat_host>
80006e62:	c0 34       	brge	80006e68 <_fstat+0x10>
80006e64:	3f fc       	mov	r12,-1
80006e66:	c1 c8       	rjmp	80006e9e <_fstat+0x46>
80006e68:	40 08       	lddsp	r8,sp[0x0]
80006e6a:	ae 08       	st.h	r7[0x0],r8
80006e6c:	40 18       	lddsp	r8,sp[0x4]
80006e6e:	ae 18       	st.h	r7[0x2],r8
80006e70:	40 28       	lddsp	r8,sp[0x8]
80006e72:	8f 18       	st.w	r7[0x4],r8
80006e74:	40 38       	lddsp	r8,sp[0xc]
80006e76:	ae 48       	st.h	r7[0x8],r8
80006e78:	40 48       	lddsp	r8,sp[0x10]
80006e7a:	ae 58       	st.h	r7[0xa],r8
80006e7c:	40 58       	lddsp	r8,sp[0x14]
80006e7e:	ae 68       	st.h	r7[0xc],r8
80006e80:	40 68       	lddsp	r8,sp[0x18]
80006e82:	ae 78       	st.h	r7[0xe],r8
80006e84:	40 88       	lddsp	r8,sp[0x20]
80006e86:	8f 48       	st.w	r7[0x10],r8
80006e88:	40 a8       	lddsp	r8,sp[0x28]
80006e8a:	8f b8       	st.w	r7[0x2c],r8
80006e8c:	40 c8       	lddsp	r8,sp[0x30]
80006e8e:	8f c8       	st.w	r7[0x30],r8
80006e90:	40 d8       	lddsp	r8,sp[0x34]
80006e92:	8f 58       	st.w	r7[0x14],r8
80006e94:	40 e8       	lddsp	r8,sp[0x38]
80006e96:	30 0c       	mov	r12,0
80006e98:	8f 78       	st.w	r7[0x1c],r8
80006e9a:	40 f8       	lddsp	r8,sp[0x3c]
80006e9c:	8f 98       	st.w	r7[0x24],r8
80006e9e:	2f 0d       	sub	sp,-64
80006ea0:	d8 22       	popm	r4-r7,pc
80006ea2:	d7 03       	nop

80006ea4 <_sbrk>:
80006ea4:	d4 01       	pushm	lr
80006ea6:	e0 68 0d 6c 	mov	r8,3436
80006eaa:	70 09       	ld.w	r9,r8[0x0]
80006eac:	58 09       	cp.w	r9,0
80006eae:	c0 41       	brne	80006eb6 <_sbrk+0x12>
80006eb0:	e0 69 40 f8 	mov	r9,16632
80006eb4:	91 09       	st.w	r8[0x0],r9
80006eb6:	e0 69 0d 6c 	mov	r9,3436
80006eba:	e0 7a 70 00 	mov	r10,94208
80006ebe:	72 08       	ld.w	r8,r9[0x0]
80006ec0:	f0 0c 00 0c 	add	r12,r8,r12
80006ec4:	14 3c       	cp.w	r12,r10
80006ec6:	e0 8b 00 04 	brhi	80006ece <_sbrk+0x2a>
80006eca:	93 0c       	st.w	r9[0x0],r12
80006ecc:	c0 68       	rjmp	80006ed8 <_sbrk+0x34>
80006ece:	e0 a0 18 15 	rcall	80009ef8 <__errno>
80006ed2:	30 c8       	mov	r8,12
80006ed4:	99 08       	st.w	r12[0x0],r8
80006ed6:	3f f8       	mov	r8,-1
80006ed8:	10 9c       	mov	r12,r8
80006eda:	d8 02       	popm	pc

80006edc <get_arg>:
80006edc:	d4 31       	pushm	r0-r7,lr
80006ede:	20 8d       	sub	sp,32
80006ee0:	fa c4 ff bc 	sub	r4,sp,-68
80006ee4:	50 4b       	stdsp	sp[0x10],r11
80006ee6:	68 2e       	ld.w	lr,r4[0x8]
80006ee8:	50 58       	stdsp	sp[0x14],r8
80006eea:	12 96       	mov	r6,r9
80006eec:	7c 0b       	ld.w	r11,lr[0x0]
80006eee:	70 05       	ld.w	r5,r8[0x0]
80006ef0:	50 6e       	stdsp	sp[0x18],lr
80006ef2:	58 0b       	cp.w	r11,0
80006ef4:	f4 0b 17 00 	moveq	r11,r10
80006ef8:	68 03       	ld.w	r3,r4[0x0]
80006efa:	68 11       	ld.w	r1,r4[0x4]
80006efc:	40 49       	lddsp	r9,sp[0x10]
80006efe:	30 08       	mov	r8,0
80006f00:	c2 89       	rjmp	80007150 <get_arg+0x274>
80006f02:	2f fb       	sub	r11,-1
80006f04:	32 5c       	mov	r12,37
80006f06:	17 8a       	ld.ub	r10,r11[0x0]
80006f08:	f8 0a 18 00 	cp.b	r10,r12
80006f0c:	5f 1e       	srne	lr
80006f0e:	f0 0a 18 00 	cp.b	r10,r8
80006f12:	5f 1c       	srne	r12
80006f14:	fd ec 00 0c 	and	r12,lr,r12
80006f18:	f0 0c 18 00 	cp.b	r12,r8
80006f1c:	cf 31       	brne	80006f02 <get_arg+0x26>
80006f1e:	58 0a       	cp.w	r10,0
80006f20:	e0 80 01 25 	breq	8000716a <get_arg+0x28e>
80006f24:	30 0c       	mov	r12,0
80006f26:	3f fa       	mov	r10,-1
80006f28:	18 90       	mov	r0,r12
80006f2a:	50 3a       	stdsp	sp[0xc],r10
80006f2c:	18 94       	mov	r4,r12
80006f2e:	18 92       	mov	r2,r12
80006f30:	f8 0c 00 3c 	add	r12,r12,r12<<0x3
80006f34:	16 97       	mov	r7,r11
80006f36:	50 7c       	stdsp	sp[0x1c],r12
80006f38:	fe cc a0 d4 	sub	r12,pc,-24364
80006f3c:	0f 3a       	ld.ub	r10,r7++
80006f3e:	f8 0a 07 0e 	ld.ub	lr,r12[r10]
80006f42:	40 7c       	lddsp	r12,sp[0x1c]
80006f44:	1c 0c       	add	r12,lr
80006f46:	fe ce a1 aa 	sub	lr,pc,-24150
80006f4a:	fc 0c 07 0e 	ld.ub	lr,lr[r12]
80006f4e:	20 1e       	sub	lr,1
80006f50:	50 0e       	stdsp	sp[0x0],lr
80006f52:	fe ce a2 22 	sub	lr,pc,-24030
80006f56:	fc 0c 07 0c 	ld.ub	r12,lr[r12]
80006f5a:	50 7c       	stdsp	sp[0x1c],r12
80006f5c:	40 0c       	lddsp	r12,sp[0x0]
80006f5e:	58 7c       	cp.w	r12,7
80006f60:	e0 8b 00 f1 	brhi	80007142 <get_arg+0x266>
80006f64:	fe ce a3 d4 	sub	lr,pc,-23596
80006f68:	fc 0c 03 2f 	ld.w	pc,lr[r12<<0x2]
80006f6c:	36 8b       	mov	r11,104
80006f6e:	f6 0a 18 00 	cp.b	r10,r11
80006f72:	e0 80 00 e8 	breq	80007142 <get_arg+0x266>
80006f76:	37 1b       	mov	r11,113
80006f78:	f6 0a 18 00 	cp.b	r10,r11
80006f7c:	c0 70       	breq	80006f8a <get_arg+0xae>
80006f7e:	34 cb       	mov	r11,76
80006f80:	f6 0a 18 00 	cp.b	r10,r11
80006f84:	c0 51       	brne	80006f8e <get_arg+0xb2>
80006f86:	a3 b4       	sbr	r4,0x3
80006f88:	cd d8       	rjmp	80007142 <get_arg+0x266>
80006f8a:	a5 b4       	sbr	r4,0x5
80006f8c:	cd b8       	rjmp	80007142 <get_arg+0x266>
80006f8e:	08 9a       	mov	r10,r4
80006f90:	0e 9b       	mov	r11,r7
80006f92:	a5 aa       	sbr	r10,0x4
80006f94:	17 3c       	ld.ub	r12,r11++
80006f96:	a5 b4       	sbr	r4,0x5
80006f98:	36 ce       	mov	lr,108
80006f9a:	fc 0c 18 00 	cp.b	r12,lr
80006f9e:	e0 80 00 d3 	breq	80007144 <get_arg+0x268>
80006fa2:	14 94       	mov	r4,r10
80006fa4:	cc f8       	rjmp	80007142 <get_arg+0x266>
80006fa6:	eb d5 c0 05 	bfextu	r5,r5,0x0,0x5
80006faa:	36 7c       	mov	r12,103
80006fac:	f8 0a 18 00 	cp.b	r10,r12
80006fb0:	e0 8b 00 27 	brhi	80006ffe <get_arg+0x122>
80006fb4:	36 5b       	mov	r11,101
80006fb6:	f6 0a 18 00 	cp.b	r10,r11
80006fba:	c4 82       	brcc	8000704a <get_arg+0x16e>
80006fbc:	34 fb       	mov	r11,79
80006fbe:	f6 0a 18 00 	cp.b	r10,r11
80006fc2:	c4 80       	breq	80007052 <get_arg+0x176>
80006fc4:	e0 8b 00 0c 	brhi	80006fdc <get_arg+0x100>
80006fc8:	34 5b       	mov	r11,69
80006fca:	f6 0a 18 00 	cp.b	r10,r11
80006fce:	c3 e0       	breq	8000704a <get_arg+0x16e>
80006fd0:	34 7b       	mov	r11,71
80006fd2:	f6 0a 18 00 	cp.b	r10,r11
80006fd6:	c3 a0       	breq	8000704a <get_arg+0x16e>
80006fd8:	34 4b       	mov	r11,68
80006fda:	c0 88       	rjmp	80006fea <get_arg+0x10e>
80006fdc:	35 8b       	mov	r11,88
80006fde:	f6 0a 18 00 	cp.b	r10,r11
80006fe2:	c2 c0       	breq	8000703a <get_arg+0x15e>
80006fe4:	e0 8b 00 07 	brhi	80006ff2 <get_arg+0x116>
80006fe8:	35 5b       	mov	r11,85
80006fea:	f6 0a 18 00 	cp.b	r10,r11
80006fee:	c3 51       	brne	80007058 <get_arg+0x17c>
80006ff0:	c3 18       	rjmp	80007052 <get_arg+0x176>
80006ff2:	36 3b       	mov	r11,99
80006ff4:	f6 0a 18 00 	cp.b	r10,r11
80006ff8:	c2 f0       	breq	80007056 <get_arg+0x17a>
80006ffa:	36 4b       	mov	r11,100
80006ffc:	c0 e8       	rjmp	80007018 <get_arg+0x13c>
80006ffe:	37 0b       	mov	r11,112
80007000:	f6 0a 18 00 	cp.b	r10,r11
80007004:	c2 50       	breq	8000704e <get_arg+0x172>
80007006:	e0 8b 00 0d 	brhi	80007020 <get_arg+0x144>
8000700a:	36 eb       	mov	r11,110
8000700c:	f6 0a 18 00 	cp.b	r10,r11
80007010:	c1 f0       	breq	8000704e <get_arg+0x172>
80007012:	e0 8b 00 14 	brhi	8000703a <get_arg+0x15e>
80007016:	36 9b       	mov	r11,105
80007018:	f6 0a 18 00 	cp.b	r10,r11
8000701c:	c1 e1       	brne	80007058 <get_arg+0x17c>
8000701e:	c0 e8       	rjmp	8000703a <get_arg+0x15e>
80007020:	37 5b       	mov	r11,117
80007022:	f6 0a 18 00 	cp.b	r10,r11
80007026:	c0 a0       	breq	8000703a <get_arg+0x15e>
80007028:	37 8b       	mov	r11,120
8000702a:	f6 0a 18 00 	cp.b	r10,r11
8000702e:	c0 60       	breq	8000703a <get_arg+0x15e>
80007030:	37 3b       	mov	r11,115
80007032:	f6 0a 18 00 	cp.b	r10,r11
80007036:	c1 11       	brne	80007058 <get_arg+0x17c>
80007038:	c0 b8       	rjmp	8000704e <get_arg+0x172>
8000703a:	ed b4 00 04 	bld	r4,0x4
8000703e:	c0 a0       	breq	80007052 <get_arg+0x176>
80007040:	ed b4 00 05 	bld	r4,0x5
80007044:	c0 91       	brne	80007056 <get_arg+0x17a>
80007046:	30 20       	mov	r0,2
80007048:	c0 88       	rjmp	80007058 <get_arg+0x17c>
8000704a:	30 40       	mov	r0,4
8000704c:	c0 68       	rjmp	80007058 <get_arg+0x17c>
8000704e:	30 30       	mov	r0,3
80007050:	c0 48       	rjmp	80007058 <get_arg+0x17c>
80007052:	30 10       	mov	r0,1
80007054:	c0 28       	rjmp	80007058 <get_arg+0x17c>
80007056:	30 00       	mov	r0,0
80007058:	40 3b       	lddsp	r11,sp[0xc]
8000705a:	5b fb       	cp.w	r11,-1
8000705c:	c0 40       	breq	80007064 <get_arg+0x188>
8000705e:	e2 0b 09 20 	st.w	r1[r11<<0x2],r0
80007062:	c7 08       	rjmp	80007142 <get_arg+0x266>
80007064:	58 60       	cp.w	r0,6
80007066:	e0 8b 00 6e 	brhi	80007142 <get_arg+0x266>
8000706a:	6c 0a       	ld.w	r10,r6[0x0]
8000706c:	ea cc ff ff 	sub	r12,r5,-1
80007070:	fe ce a4 c0 	sub	lr,pc,-23360
80007074:	fc 00 03 2f 	ld.w	pc,lr[r0<<0x2]
80007078:	f4 cb ff f8 	sub	r11,r10,-8
8000707c:	8d 0b       	st.w	r6[0x0],r11
8000707e:	f4 ea 00 00 	ld.d	r10,r10[0]
80007082:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80007086:	c0 f8       	rjmp	800070a4 <get_arg+0x1c8>
80007088:	f4 cb ff fc 	sub	r11,r10,-4
8000708c:	8d 0b       	st.w	r6[0x0],r11
8000708e:	74 0a       	ld.w	r10,r10[0x0]
80007090:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80007094:	c0 88       	rjmp	800070a4 <get_arg+0x1c8>
80007096:	f4 cb ff f8 	sub	r11,r10,-8
8000709a:	8d 0b       	st.w	r6[0x0],r11
8000709c:	f4 ea 00 00 	ld.d	r10,r10[0]
800070a0:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
800070a4:	0e 9b       	mov	r11,r7
800070a6:	18 95       	mov	r5,r12
800070a8:	c4 e8       	rjmp	80007144 <get_arg+0x268>
800070aa:	62 0a       	ld.w	r10,r1[0x0]
800070ac:	5b fa       	cp.w	r10,-1
800070ae:	c0 b1       	brne	800070c4 <get_arg+0x1e8>
800070b0:	50 19       	stdsp	sp[0x4],r9
800070b2:	50 28       	stdsp	sp[0x8],r8
800070b4:	e0 6a 00 80 	mov	r10,128
800070b8:	30 0b       	mov	r11,0
800070ba:	02 9c       	mov	r12,r1
800070bc:	fe b0 fc f4 	rcall	80006aa4 <memset>
800070c0:	40 28       	lddsp	r8,sp[0x8]
800070c2:	40 19       	lddsp	r9,sp[0x4]
800070c4:	e4 cc 00 01 	sub	r12,r2,1
800070c8:	0e 9b       	mov	r11,r7
800070ca:	50 3c       	stdsp	sp[0xc],r12
800070cc:	f2 0c 0c 49 	max	r9,r9,r12
800070d0:	c3 a8       	rjmp	80007144 <get_arg+0x268>
800070d2:	62 0a       	ld.w	r10,r1[0x0]
800070d4:	5b fa       	cp.w	r10,-1
800070d6:	c0 b1       	brne	800070ec <get_arg+0x210>
800070d8:	50 19       	stdsp	sp[0x4],r9
800070da:	50 28       	stdsp	sp[0x8],r8
800070dc:	e0 6a 00 80 	mov	r10,128
800070e0:	30 0b       	mov	r11,0
800070e2:	02 9c       	mov	r12,r1
800070e4:	fe b0 fc e0 	rcall	80006aa4 <memset>
800070e8:	40 28       	lddsp	r8,sp[0x8]
800070ea:	40 19       	lddsp	r9,sp[0x4]
800070ec:	20 12       	sub	r2,1
800070ee:	30 0a       	mov	r10,0
800070f0:	0e 9b       	mov	r11,r7
800070f2:	e2 02 09 2a 	st.w	r1[r2<<0x2],r10
800070f6:	f2 02 0c 49 	max	r9,r9,r2
800070fa:	c2 58       	rjmp	80007144 <get_arg+0x268>
800070fc:	16 97       	mov	r7,r11
800070fe:	6c 0a       	ld.w	r10,r6[0x0]
80007100:	f4 cb ff fc 	sub	r11,r10,-4
80007104:	8d 0b       	st.w	r6[0x0],r11
80007106:	74 0a       	ld.w	r10,r10[0x0]
80007108:	0e 9b       	mov	r11,r7
8000710a:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
8000710e:	2f f5       	sub	r5,-1
80007110:	c1 a8       	rjmp	80007144 <get_arg+0x268>
80007112:	f4 c2 00 30 	sub	r2,r10,48
80007116:	c0 68       	rjmp	80007122 <get_arg+0x246>
80007118:	e4 02 00 22 	add	r2,r2,r2<<0x2
8000711c:	2f f7       	sub	r7,-1
8000711e:	f4 02 00 12 	add	r2,r10,r2<<0x1
80007122:	0f 8a       	ld.ub	r10,r7[0x0]
80007124:	58 0a       	cp.w	r10,0
80007126:	c0 e0       	breq	80007142 <get_arg+0x266>
80007128:	23 0a       	sub	r10,48
8000712a:	58 9a       	cp.w	r10,9
8000712c:	fe 98 ff f6 	brls	80007118 <get_arg+0x23c>
80007130:	c0 98       	rjmp	80007142 <get_arg+0x266>
80007132:	2f f7       	sub	r7,-1
80007134:	0f 8a       	ld.ub	r10,r7[0x0]
80007136:	58 0a       	cp.w	r10,0
80007138:	c0 50       	breq	80007142 <get_arg+0x266>
8000713a:	23 0a       	sub	r10,48
8000713c:	58 9a       	cp.w	r10,9
8000713e:	fe 98 ff fa 	brls	80007132 <get_arg+0x256>
80007142:	0e 9b       	mov	r11,r7
80007144:	40 7c       	lddsp	r12,sp[0x1c]
80007146:	30 ba       	mov	r10,11
80007148:	f4 0c 18 00 	cp.b	r12,r10
8000714c:	fe 91 fe f2 	brne	80006f30 <get_arg+0x54>
80007150:	40 42       	lddsp	r2,sp[0x10]
80007152:	17 8c       	ld.ub	r12,r11[0x0]
80007154:	0a 32       	cp.w	r2,r5
80007156:	5f 4a       	srge	r10
80007158:	f0 0c 18 00 	cp.b	r12,r8
8000715c:	5f 1c       	srne	r12
8000715e:	f9 ea 00 0a 	and	r10,r12,r10
80007162:	f0 0a 18 00 	cp.b	r10,r8
80007166:	fe 91 fe cf 	brne	80006f04 <get_arg+0x28>
8000716a:	30 08       	mov	r8,0
8000716c:	40 4e       	lddsp	lr,sp[0x10]
8000716e:	17 8a       	ld.ub	r10,r11[0x0]
80007170:	e2 05 00 21 	add	r1,r1,r5<<0x2
80007174:	f0 0a 18 00 	cp.b	r10,r8
80007178:	fc 09 17 10 	movne	r9,lr
8000717c:	e6 05 00 38 	add	r8,r3,r5<<0x3
80007180:	06 9e       	mov	lr,r3
80007182:	c2 a8       	rjmp	800071d6 <get_arg+0x2fa>
80007184:	62 0a       	ld.w	r10,r1[0x0]
80007186:	58 3a       	cp.w	r10,3
80007188:	c1 e0       	breq	800071c4 <get_arg+0x2e8>
8000718a:	e0 89 00 07 	brgt	80007198 <get_arg+0x2bc>
8000718e:	58 1a       	cp.w	r10,1
80007190:	c1 a0       	breq	800071c4 <get_arg+0x2e8>
80007192:	58 2a       	cp.w	r10,2
80007194:	c1 81       	brne	800071c4 <get_arg+0x2e8>
80007196:	c0 58       	rjmp	800071a0 <get_arg+0x2c4>
80007198:	58 5a       	cp.w	r10,5
8000719a:	c0 c0       	breq	800071b2 <get_arg+0x2d6>
8000719c:	c0 b5       	brlt	800071b2 <get_arg+0x2d6>
8000719e:	c1 38       	rjmp	800071c4 <get_arg+0x2e8>
800071a0:	6c 0a       	ld.w	r10,r6[0x0]
800071a2:	f4 cc ff f8 	sub	r12,r10,-8
800071a6:	8d 0c       	st.w	r6[0x0],r12
800071a8:	f4 e2 00 00 	ld.d	r2,r10[0]
800071ac:	f0 e3 00 00 	st.d	r8[0],r2
800071b0:	c1 08       	rjmp	800071d0 <get_arg+0x2f4>
800071b2:	6c 0a       	ld.w	r10,r6[0x0]
800071b4:	f4 cc ff f8 	sub	r12,r10,-8
800071b8:	8d 0c       	st.w	r6[0x0],r12
800071ba:	f4 e2 00 00 	ld.d	r2,r10[0]
800071be:	f0 e3 00 00 	st.d	r8[0],r2
800071c2:	c0 78       	rjmp	800071d0 <get_arg+0x2f4>
800071c4:	6c 0a       	ld.w	r10,r6[0x0]
800071c6:	f4 cc ff fc 	sub	r12,r10,-4
800071ca:	8d 0c       	st.w	r6[0x0],r12
800071cc:	74 0a       	ld.w	r10,r10[0x0]
800071ce:	91 0a       	st.w	r8[0x0],r10
800071d0:	2f f5       	sub	r5,-1
800071d2:	2f 88       	sub	r8,-8
800071d4:	2f c1       	sub	r1,-4
800071d6:	12 35       	cp.w	r5,r9
800071d8:	fe 9a ff d6 	brle	80007184 <get_arg+0x2a8>
800071dc:	1c 93       	mov	r3,lr
800071de:	40 52       	lddsp	r2,sp[0x14]
800071e0:	40 6e       	lddsp	lr,sp[0x18]
800071e2:	85 05       	st.w	r2[0x0],r5
800071e4:	9d 0b       	st.w	lr[0x0],r11
800071e6:	40 4b       	lddsp	r11,sp[0x10]
800071e8:	e6 0b 00 3c 	add	r12,r3,r11<<0x3
800071ec:	2f 8d       	sub	sp,-32
800071ee:	d8 32       	popm	r0-r7,pc

800071f0 <__sprint_r>:
800071f0:	d4 21       	pushm	r4-r7,lr
800071f2:	14 97       	mov	r7,r10
800071f4:	74 28       	ld.w	r8,r10[0x8]
800071f6:	58 08       	cp.w	r8,0
800071f8:	c0 41       	brne	80007200 <__sprint_r+0x10>
800071fa:	95 18       	st.w	r10[0x4],r8
800071fc:	10 9c       	mov	r12,r8
800071fe:	d8 22       	popm	r4-r7,pc
80007200:	e0 a0 18 ba 	rcall	8000a374 <__sfvwrite_r>
80007204:	30 08       	mov	r8,0
80007206:	8f 18       	st.w	r7[0x4],r8
80007208:	8f 28       	st.w	r7[0x8],r8
8000720a:	d8 22       	popm	r4-r7,pc

8000720c <_vfprintf_r>:
8000720c:	d4 31       	pushm	r0-r7,lr
8000720e:	fa cd 06 bc 	sub	sp,sp,1724
80007212:	51 09       	stdsp	sp[0x40],r9
80007214:	16 91       	mov	r1,r11
80007216:	14 97       	mov	r7,r10
80007218:	18 95       	mov	r5,r12
8000721a:	e0 a0 1a 1d 	rcall	8000a654 <_localeconv_r>
8000721e:	78 0c       	ld.w	r12,r12[0x0]
80007220:	50 cc       	stdsp	sp[0x30],r12
80007222:	58 05       	cp.w	r5,0
80007224:	c0 70       	breq	80007232 <_vfprintf_r+0x26>
80007226:	6a 68       	ld.w	r8,r5[0x18]
80007228:	58 08       	cp.w	r8,0
8000722a:	c0 41       	brne	80007232 <_vfprintf_r+0x26>
8000722c:	0a 9c       	mov	r12,r5
8000722e:	e0 a0 17 43 	rcall	8000a0b4 <__sinit>
80007232:	fe c8 a2 be 	sub	r8,pc,-23874
80007236:	10 31       	cp.w	r1,r8
80007238:	c0 31       	brne	8000723e <_vfprintf_r+0x32>
8000723a:	6a 01       	ld.w	r1,r5[0x0]
8000723c:	c0 c8       	rjmp	80007254 <_vfprintf_r+0x48>
8000723e:	fe c8 a2 aa 	sub	r8,pc,-23894
80007242:	10 31       	cp.w	r1,r8
80007244:	c0 31       	brne	8000724a <_vfprintf_r+0x3e>
80007246:	6a 11       	ld.w	r1,r5[0x4]
80007248:	c0 68       	rjmp	80007254 <_vfprintf_r+0x48>
8000724a:	fe c8 a2 96 	sub	r8,pc,-23914
8000724e:	10 31       	cp.w	r1,r8
80007250:	eb f1 00 02 	ld.weq	r1,r5[0x8]
80007254:	82 68       	ld.sh	r8,r1[0xc]
80007256:	ed b8 00 03 	bld	r8,0x3
8000725a:	c0 41       	brne	80007262 <_vfprintf_r+0x56>
8000725c:	62 48       	ld.w	r8,r1[0x10]
8000725e:	58 08       	cp.w	r8,0
80007260:	c0 71       	brne	8000726e <_vfprintf_r+0x62>
80007262:	02 9b       	mov	r11,r1
80007264:	0a 9c       	mov	r12,r5
80007266:	e0 a0 0f 5d 	rcall	80009120 <__swsetup_r>
8000726a:	e0 81 0f 54 	brne	80009112 <_vfprintf_r+0x1f06>
8000726e:	82 68       	ld.sh	r8,r1[0xc]
80007270:	10 99       	mov	r9,r8
80007272:	e2 19 00 1a 	andl	r9,0x1a,COH
80007276:	58 a9       	cp.w	r9,10
80007278:	c3 c1       	brne	800072f0 <_vfprintf_r+0xe4>
8000727a:	82 79       	ld.sh	r9,r1[0xe]
8000727c:	30 0a       	mov	r10,0
8000727e:	f4 09 19 00 	cp.h	r9,r10
80007282:	c3 75       	brlt	800072f0 <_vfprintf_r+0xe4>
80007284:	a1 d8       	cbr	r8,0x1
80007286:	fb 58 05 d0 	st.h	sp[1488],r8
8000728a:	62 88       	ld.w	r8,r1[0x20]
8000728c:	fb 48 05 e4 	st.w	sp[1508],r8
80007290:	62 a8       	ld.w	r8,r1[0x28]
80007292:	fb 48 05 ec 	st.w	sp[1516],r8
80007296:	fa c8 ff bc 	sub	r8,sp,-68
8000729a:	fb 48 05 d4 	st.w	sp[1492],r8
8000729e:	fb 48 05 c4 	st.w	sp[1476],r8
800072a2:	e0 68 04 00 	mov	r8,1024
800072a6:	fb 48 05 d8 	st.w	sp[1496],r8
800072aa:	fb 48 05 cc 	st.w	sp[1484],r8
800072ae:	30 08       	mov	r8,0
800072b0:	fb 59 05 d2 	st.h	sp[1490],r9
800072b4:	0e 9a       	mov	r10,r7
800072b6:	41 09       	lddsp	r9,sp[0x40]
800072b8:	fa c7 fa 3c 	sub	r7,sp,-1476
800072bc:	fb 48 05 dc 	st.w	sp[1500],r8
800072c0:	0a 9c       	mov	r12,r5
800072c2:	0e 9b       	mov	r11,r7
800072c4:	ca 4f       	rcall	8000720c <_vfprintf_r>
800072c6:	50 bc       	stdsp	sp[0x2c],r12
800072c8:	c0 95       	brlt	800072da <_vfprintf_r+0xce>
800072ca:	0e 9b       	mov	r11,r7
800072cc:	0a 9c       	mov	r12,r5
800072ce:	e0 a0 16 1b 	rcall	80009f04 <_fflush_r>
800072d2:	40 be       	lddsp	lr,sp[0x2c]
800072d4:	f9 be 01 ff 	movne	lr,-1
800072d8:	50 be       	stdsp	sp[0x2c],lr
800072da:	fb 08 05 d0 	ld.sh	r8,sp[1488]
800072de:	ed b8 00 06 	bld	r8,0x6
800072e2:	e0 81 0f 1a 	brne	80009116 <_vfprintf_r+0x1f0a>
800072e6:	82 68       	ld.sh	r8,r1[0xc]
800072e8:	a7 a8       	sbr	r8,0x6
800072ea:	a2 68       	st.h	r1[0xc],r8
800072ec:	e0 8f 0f 15 	bral	80009116 <_vfprintf_r+0x1f0a>
800072f0:	30 08       	mov	r8,0
800072f2:	fb 48 06 b4 	st.w	sp[1716],r8
800072f6:	fb 48 06 90 	st.w	sp[1680],r8
800072fa:	fb 48 06 8c 	st.w	sp[1676],r8
800072fe:	fb 48 06 b0 	st.w	sp[1712],r8
80007302:	30 08       	mov	r8,0
80007304:	30 09       	mov	r9,0
80007306:	50 a7       	stdsp	sp[0x28],r7
80007308:	50 78       	stdsp	sp[0x1c],r8
8000730a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000730e:	3f f8       	mov	r8,-1
80007310:	50 59       	stdsp	sp[0x14],r9
80007312:	fb 43 06 88 	st.w	sp[1672],r3
80007316:	fb 48 05 44 	st.w	sp[1348],r8
8000731a:	12 9c       	mov	r12,r9
8000731c:	50 69       	stdsp	sp[0x18],r9
8000731e:	50 d9       	stdsp	sp[0x34],r9
80007320:	50 e9       	stdsp	sp[0x38],r9
80007322:	50 b9       	stdsp	sp[0x2c],r9
80007324:	12 97       	mov	r7,r9
80007326:	0a 94       	mov	r4,r5
80007328:	40 a2       	lddsp	r2,sp[0x28]
8000732a:	32 5a       	mov	r10,37
8000732c:	30 08       	mov	r8,0
8000732e:	c0 28       	rjmp	80007332 <_vfprintf_r+0x126>
80007330:	2f f2       	sub	r2,-1
80007332:	05 89       	ld.ub	r9,r2[0x0]
80007334:	f0 09 18 00 	cp.b	r9,r8
80007338:	5f 1b       	srne	r11
8000733a:	f4 09 18 00 	cp.b	r9,r10
8000733e:	5f 19       	srne	r9
80007340:	f3 eb 00 0b 	and	r11,r9,r11
80007344:	f0 0b 18 00 	cp.b	r11,r8
80007348:	cf 41       	brne	80007330 <_vfprintf_r+0x124>
8000734a:	40 ab       	lddsp	r11,sp[0x28]
8000734c:	e4 0b 01 06 	sub	r6,r2,r11
80007350:	c1 e0       	breq	8000738c <_vfprintf_r+0x180>
80007352:	fa f8 06 90 	ld.w	r8,sp[1680]
80007356:	0c 08       	add	r8,r6
80007358:	87 0b       	st.w	r3[0x0],r11
8000735a:	fb 48 06 90 	st.w	sp[1680],r8
8000735e:	87 16       	st.w	r3[0x4],r6
80007360:	fa f8 06 8c 	ld.w	r8,sp[1676]
80007364:	2f f8       	sub	r8,-1
80007366:	fb 48 06 8c 	st.w	sp[1676],r8
8000736a:	58 78       	cp.w	r8,7
8000736c:	e0 89 00 04 	brgt	80007374 <_vfprintf_r+0x168>
80007370:	2f 83       	sub	r3,-8
80007372:	c0 a8       	rjmp	80007386 <_vfprintf_r+0x17a>
80007374:	fa ca f9 78 	sub	r10,sp,-1672
80007378:	02 9b       	mov	r11,r1
8000737a:	08 9c       	mov	r12,r4
8000737c:	c3 af       	rcall	800071f0 <__sprint_r>
8000737e:	e0 81 0e c6 	brne	8000910a <_vfprintf_r+0x1efe>
80007382:	fa c3 f9 e0 	sub	r3,sp,-1568
80007386:	40 ba       	lddsp	r10,sp[0x2c]
80007388:	0c 0a       	add	r10,r6
8000738a:	50 ba       	stdsp	sp[0x2c],r10
8000738c:	05 89       	ld.ub	r9,r2[0x0]
8000738e:	30 08       	mov	r8,0
80007390:	f0 09 18 00 	cp.b	r9,r8
80007394:	e0 80 0e aa 	breq	800090e8 <_vfprintf_r+0x1edc>
80007398:	30 09       	mov	r9,0
8000739a:	fb 68 06 bb 	st.b	sp[1723],r8
8000739e:	0e 96       	mov	r6,r7
800073a0:	e4 c8 ff ff 	sub	r8,r2,-1
800073a4:	3f fe       	mov	lr,-1
800073a6:	50 93       	stdsp	sp[0x24],r3
800073a8:	50 41       	stdsp	sp[0x10],r1
800073aa:	0e 93       	mov	r3,r7
800073ac:	04 91       	mov	r1,r2
800073ae:	50 89       	stdsp	sp[0x20],r9
800073b0:	50 a8       	stdsp	sp[0x28],r8
800073b2:	50 2e       	stdsp	sp[0x8],lr
800073b4:	50 39       	stdsp	sp[0xc],r9
800073b6:	12 95       	mov	r5,r9
800073b8:	12 90       	mov	r0,r9
800073ba:	10 97       	mov	r7,r8
800073bc:	08 92       	mov	r2,r4
800073be:	c0 78       	rjmp	800073cc <_vfprintf_r+0x1c0>
800073c0:	3f fc       	mov	r12,-1
800073c2:	08 97       	mov	r7,r4
800073c4:	50 2c       	stdsp	sp[0x8],r12
800073c6:	c0 38       	rjmp	800073cc <_vfprintf_r+0x1c0>
800073c8:	30 0b       	mov	r11,0
800073ca:	50 3b       	stdsp	sp[0xc],r11
800073cc:	0f 38       	ld.ub	r8,r7++
800073ce:	c0 28       	rjmp	800073d2 <_vfprintf_r+0x1c6>
800073d0:	12 90       	mov	r0,r9
800073d2:	f0 c9 00 20 	sub	r9,r8,32
800073d6:	e0 49 00 58 	cp.w	r9,88
800073da:	e0 8b 0a 30 	brhi	8000883a <_vfprintf_r+0x162e>
800073de:	fe ca a8 12 	sub	r10,pc,-22510
800073e2:	f4 09 03 2f 	ld.w	pc,r10[r9<<0x2]
800073e6:	50 a7       	stdsp	sp[0x28],r7
800073e8:	50 80       	stdsp	sp[0x20],r0
800073ea:	0c 97       	mov	r7,r6
800073ec:	04 94       	mov	r4,r2
800073ee:	06 96       	mov	r6,r3
800073f0:	02 92       	mov	r2,r1
800073f2:	fe c9 a5 ea 	sub	r9,pc,-23062
800073f6:	40 93       	lddsp	r3,sp[0x24]
800073f8:	10 90       	mov	r0,r8
800073fa:	40 41       	lddsp	r1,sp[0x10]
800073fc:	50 d9       	stdsp	sp[0x34],r9
800073fe:	e0 8f 08 8e 	bral	8000851a <_vfprintf_r+0x130e>
80007402:	30 08       	mov	r8,0
80007404:	fb 39 06 bb 	ld.ub	r9,sp[1723]
80007408:	f0 09 18 00 	cp.b	r9,r8
8000740c:	ce 01       	brne	800073cc <_vfprintf_r+0x1c0>
8000740e:	32 08       	mov	r8,32
80007410:	c6 e8       	rjmp	800074ec <_vfprintf_r+0x2e0>
80007412:	a1 a5       	sbr	r5,0x0
80007414:	cd cb       	rjmp	800073cc <_vfprintf_r+0x1c0>
80007416:	0f 89       	ld.ub	r9,r7[0x0]
80007418:	f2 c8 00 30 	sub	r8,r9,48
8000741c:	58 98       	cp.w	r8,9
8000741e:	e0 8b 00 1d 	brhi	80007458 <_vfprintf_r+0x24c>
80007422:	ee c8 ff ff 	sub	r8,r7,-1
80007426:	30 0b       	mov	r11,0
80007428:	23 09       	sub	r9,48
8000742a:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
8000742e:	f2 0b 00 1b 	add	r11,r9,r11<<0x1
80007432:	11 39       	ld.ub	r9,r8++
80007434:	f2 ca 00 30 	sub	r10,r9,48
80007438:	58 9a       	cp.w	r10,9
8000743a:	fe 98 ff f7 	brls	80007428 <_vfprintf_r+0x21c>
8000743e:	e0 49 00 24 	cp.w	r9,36
80007442:	cc 31       	brne	800073c8 <_vfprintf_r+0x1bc>
80007444:	e0 4b 00 20 	cp.w	r11,32
80007448:	e0 89 0e 60 	brgt	80009108 <_vfprintf_r+0x1efc>
8000744c:	20 1b       	sub	r11,1
8000744e:	fa f9 06 b4 	ld.w	r9,sp[1716]
80007452:	12 3b       	cp.w	r11,r9
80007454:	c0 95       	brlt	80007466 <_vfprintf_r+0x25a>
80007456:	c1 08       	rjmp	80007476 <_vfprintf_r+0x26a>
80007458:	fa f9 06 b4 	ld.w	r9,sp[1716]
8000745c:	ec ca ff ff 	sub	r10,r6,-1
80007460:	12 36       	cp.w	r6,r9
80007462:	c1 f5       	brlt	800074a0 <_vfprintf_r+0x294>
80007464:	c2 68       	rjmp	800074b0 <_vfprintf_r+0x2a4>
80007466:	fa ce f9 44 	sub	lr,sp,-1724
8000746a:	10 97       	mov	r7,r8
8000746c:	fc 0b 00 3b 	add	r11,lr,r11<<0x3
80007470:	f6 f0 fd 88 	ld.w	r0,r11[-632]
80007474:	c3 58       	rjmp	800074de <_vfprintf_r+0x2d2>
80007476:	10 97       	mov	r7,r8
80007478:	fa c8 f9 50 	sub	r8,sp,-1712
8000747c:	1a d8       	st.w	--sp,r8
8000747e:	fa c8 fa b8 	sub	r8,sp,-1352
80007482:	1a d8       	st.w	--sp,r8
80007484:	fa c8 fb b4 	sub	r8,sp,-1100
80007488:	02 9a       	mov	r10,r1
8000748a:	1a d8       	st.w	--sp,r8
8000748c:	04 9c       	mov	r12,r2
8000748e:	fa c8 f9 40 	sub	r8,sp,-1728
80007492:	fa c9 ff b4 	sub	r9,sp,-76
80007496:	fe b0 fd 23 	rcall	80006edc <get_arg>
8000749a:	2f dd       	sub	sp,-12
8000749c:	78 00       	ld.w	r0,r12[0x0]
8000749e:	c2 08       	rjmp	800074de <_vfprintf_r+0x2d2>
800074a0:	fa cc f9 44 	sub	r12,sp,-1724
800074a4:	14 96       	mov	r6,r10
800074a6:	f8 03 00 38 	add	r8,r12,r3<<0x3
800074aa:	f0 f0 fd 88 	ld.w	r0,r8[-632]
800074ae:	c1 88       	rjmp	800074de <_vfprintf_r+0x2d2>
800074b0:	41 08       	lddsp	r8,sp[0x40]
800074b2:	59 f9       	cp.w	r9,31
800074b4:	e0 89 00 11 	brgt	800074d6 <_vfprintf_r+0x2ca>
800074b8:	f0 cb ff fc 	sub	r11,r8,-4
800074bc:	51 0b       	stdsp	sp[0x40],r11
800074be:	70 00       	ld.w	r0,r8[0x0]
800074c0:	fa cb f9 44 	sub	r11,sp,-1724
800074c4:	f6 09 00 38 	add	r8,r11,r9<<0x3
800074c8:	f1 40 fd 88 	st.w	r8[-632],r0
800074cc:	2f f9       	sub	r9,-1
800074ce:	14 96       	mov	r6,r10
800074d0:	fb 49 06 b4 	st.w	sp[1716],r9
800074d4:	c0 58       	rjmp	800074de <_vfprintf_r+0x2d2>
800074d6:	70 00       	ld.w	r0,r8[0x0]
800074d8:	14 96       	mov	r6,r10
800074da:	2f c8       	sub	r8,-4
800074dc:	51 08       	stdsp	sp[0x40],r8
800074de:	58 00       	cp.w	r0,0
800074e0:	fe 94 ff 76 	brge	800073cc <_vfprintf_r+0x1c0>
800074e4:	5c 30       	neg	r0
800074e6:	a3 a5       	sbr	r5,0x2
800074e8:	c7 2b       	rjmp	800073cc <_vfprintf_r+0x1c0>
800074ea:	32 b8       	mov	r8,43
800074ec:	fb 68 06 bb 	st.b	sp[1723],r8
800074f0:	c6 eb       	rjmp	800073cc <_vfprintf_r+0x1c0>
800074f2:	0f 38       	ld.ub	r8,r7++
800074f4:	e0 48 00 2a 	cp.w	r8,42
800074f8:	c0 30       	breq	800074fe <_vfprintf_r+0x2f2>
800074fa:	30 09       	mov	r9,0
800074fc:	c7 98       	rjmp	800075ee <_vfprintf_r+0x3e2>
800074fe:	0f 88       	ld.ub	r8,r7[0x0]
80007500:	f0 c9 00 30 	sub	r9,r8,48
80007504:	58 99       	cp.w	r9,9
80007506:	e0 8b 00 1f 	brhi	80007544 <_vfprintf_r+0x338>
8000750a:	ee c4 ff ff 	sub	r4,r7,-1
8000750e:	30 0b       	mov	r11,0
80007510:	23 08       	sub	r8,48
80007512:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
80007516:	f0 0b 00 1b 	add	r11,r8,r11<<0x1
8000751a:	09 38       	ld.ub	r8,r4++
8000751c:	f0 c9 00 30 	sub	r9,r8,48
80007520:	58 99       	cp.w	r9,9
80007522:	fe 98 ff f7 	brls	80007510 <_vfprintf_r+0x304>
80007526:	e0 48 00 24 	cp.w	r8,36
8000752a:	fe 91 ff 4f 	brne	800073c8 <_vfprintf_r+0x1bc>
8000752e:	e0 4b 00 20 	cp.w	r11,32
80007532:	e0 89 0d eb 	brgt	80009108 <_vfprintf_r+0x1efc>
80007536:	20 1b       	sub	r11,1
80007538:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000753c:	10 3b       	cp.w	r11,r8
8000753e:	c0 a5       	brlt	80007552 <_vfprintf_r+0x346>
80007540:	c1 18       	rjmp	80007562 <_vfprintf_r+0x356>
80007542:	d7 03       	nop
80007544:	fa fa 06 b4 	ld.w	r10,sp[1716]
80007548:	ec c9 ff ff 	sub	r9,r6,-1
8000754c:	14 36       	cp.w	r6,r10
8000754e:	c1 f5       	brlt	8000758c <_vfprintf_r+0x380>
80007550:	c2 88       	rjmp	800075a0 <_vfprintf_r+0x394>
80007552:	fa ca f9 44 	sub	r10,sp,-1724
80007556:	f4 0b 00 3b 	add	r11,r10,r11<<0x3
8000755a:	f6 fb fd 88 	ld.w	r11,r11[-632]
8000755e:	50 2b       	stdsp	sp[0x8],r11
80007560:	c3 c8       	rjmp	800075d8 <_vfprintf_r+0x3cc>
80007562:	fa c8 f9 50 	sub	r8,sp,-1712
80007566:	1a d8       	st.w	--sp,r8
80007568:	fa c8 fa b8 	sub	r8,sp,-1352
8000756c:	1a d8       	st.w	--sp,r8
8000756e:	fa c8 fb b4 	sub	r8,sp,-1100
80007572:	02 9a       	mov	r10,r1
80007574:	1a d8       	st.w	--sp,r8
80007576:	04 9c       	mov	r12,r2
80007578:	fa c8 f9 40 	sub	r8,sp,-1728
8000757c:	fa c9 ff b4 	sub	r9,sp,-76
80007580:	fe b0 fc ae 	rcall	80006edc <get_arg>
80007584:	2f dd       	sub	sp,-12
80007586:	78 0c       	ld.w	r12,r12[0x0]
80007588:	50 2c       	stdsp	sp[0x8],r12
8000758a:	c2 78       	rjmp	800075d8 <_vfprintf_r+0x3cc>
8000758c:	12 96       	mov	r6,r9
8000758e:	0e 94       	mov	r4,r7
80007590:	fa c9 f9 44 	sub	r9,sp,-1724
80007594:	f2 03 00 38 	add	r8,r9,r3<<0x3
80007598:	f0 f8 fd 88 	ld.w	r8,r8[-632]
8000759c:	50 28       	stdsp	sp[0x8],r8
8000759e:	c1 d8       	rjmp	800075d8 <_vfprintf_r+0x3cc>
800075a0:	41 08       	lddsp	r8,sp[0x40]
800075a2:	59 fa       	cp.w	r10,31
800075a4:	e0 89 00 14 	brgt	800075cc <_vfprintf_r+0x3c0>
800075a8:	f0 cb ff fc 	sub	r11,r8,-4
800075ac:	70 08       	ld.w	r8,r8[0x0]
800075ae:	51 0b       	stdsp	sp[0x40],r11
800075b0:	50 28       	stdsp	sp[0x8],r8
800075b2:	fa c6 f9 44 	sub	r6,sp,-1724
800075b6:	40 2e       	lddsp	lr,sp[0x8]
800075b8:	ec 0a 00 38 	add	r8,r6,r10<<0x3
800075bc:	f1 4e fd 88 	st.w	r8[-632],lr
800075c0:	2f fa       	sub	r10,-1
800075c2:	0e 94       	mov	r4,r7
800075c4:	fb 4a 06 b4 	st.w	sp[1716],r10
800075c8:	12 96       	mov	r6,r9
800075ca:	c0 78       	rjmp	800075d8 <_vfprintf_r+0x3cc>
800075cc:	70 0c       	ld.w	r12,r8[0x0]
800075ce:	0e 94       	mov	r4,r7
800075d0:	2f c8       	sub	r8,-4
800075d2:	50 2c       	stdsp	sp[0x8],r12
800075d4:	12 96       	mov	r6,r9
800075d6:	51 08       	stdsp	sp[0x40],r8
800075d8:	40 2b       	lddsp	r11,sp[0x8]
800075da:	58 0b       	cp.w	r11,0
800075dc:	fe 95 fe f2 	brlt	800073c0 <_vfprintf_r+0x1b4>
800075e0:	08 97       	mov	r7,r4
800075e2:	cf 5a       	rjmp	800073cc <_vfprintf_r+0x1c0>
800075e4:	f2 09 00 29 	add	r9,r9,r9<<0x2
800075e8:	0f 38       	ld.ub	r8,r7++
800075ea:	f4 09 00 19 	add	r9,r10,r9<<0x1
800075ee:	f0 ca 00 30 	sub	r10,r8,48
800075f2:	58 9a       	cp.w	r10,9
800075f4:	fe 98 ff f8 	brls	800075e4 <_vfprintf_r+0x3d8>
800075f8:	3f fa       	mov	r10,-1
800075fa:	f2 0a 0c 49 	max	r9,r9,r10
800075fe:	50 29       	stdsp	sp[0x8],r9
80007600:	ce 9a       	rjmp	800073d2 <_vfprintf_r+0x1c6>
80007602:	a7 b5       	sbr	r5,0x7
80007604:	ce 4a       	rjmp	800073cc <_vfprintf_r+0x1c0>
80007606:	30 09       	mov	r9,0
80007608:	23 08       	sub	r8,48
8000760a:	f2 09 00 29 	add	r9,r9,r9<<0x2
8000760e:	f0 09 00 19 	add	r9,r8,r9<<0x1
80007612:	0f 38       	ld.ub	r8,r7++
80007614:	f0 ca 00 30 	sub	r10,r8,48
80007618:	58 9a       	cp.w	r10,9
8000761a:	fe 98 ff f7 	brls	80007608 <_vfprintf_r+0x3fc>
8000761e:	e0 48 00 24 	cp.w	r8,36
80007622:	fe 91 fe d7 	brne	800073d0 <_vfprintf_r+0x1c4>
80007626:	e0 49 00 20 	cp.w	r9,32
8000762a:	e0 89 0d 6f 	brgt	80009108 <_vfprintf_r+0x1efc>
8000762e:	f2 c3 00 01 	sub	r3,r9,1
80007632:	30 19       	mov	r9,1
80007634:	50 39       	stdsp	sp[0xc],r9
80007636:	cc ba       	rjmp	800073cc <_vfprintf_r+0x1c0>
80007638:	a3 b5       	sbr	r5,0x3
8000763a:	cc 9a       	rjmp	800073cc <_vfprintf_r+0x1c0>
8000763c:	a7 a5       	sbr	r5,0x6
8000763e:	cc 7a       	rjmp	800073cc <_vfprintf_r+0x1c0>
80007640:	0a 98       	mov	r8,r5
80007642:	a5 b5       	sbr	r5,0x5
80007644:	a5 a8       	sbr	r8,0x4
80007646:	0f 89       	ld.ub	r9,r7[0x0]
80007648:	36 ce       	mov	lr,108
8000764a:	fc 09 18 00 	cp.b	r9,lr
8000764e:	f7 b7 00 ff 	subeq	r7,-1
80007652:	f0 05 17 10 	movne	r5,r8
80007656:	cb ba       	rjmp	800073cc <_vfprintf_r+0x1c0>
80007658:	a5 b5       	sbr	r5,0x5
8000765a:	cb 9a       	rjmp	800073cc <_vfprintf_r+0x1c0>
8000765c:	50 a7       	stdsp	sp[0x28],r7
8000765e:	50 80       	stdsp	sp[0x20],r0
80007660:	0c 97       	mov	r7,r6
80007662:	10 90       	mov	r0,r8
80007664:	06 96       	mov	r6,r3
80007666:	04 94       	mov	r4,r2
80007668:	40 93       	lddsp	r3,sp[0x24]
8000766a:	02 92       	mov	r2,r1
8000766c:	0e 99       	mov	r9,r7
8000766e:	40 41       	lddsp	r1,sp[0x10]
80007670:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007674:	40 3c       	lddsp	r12,sp[0xc]
80007676:	58 0c       	cp.w	r12,0
80007678:	c1 d0       	breq	800076b2 <_vfprintf_r+0x4a6>
8000767a:	10 36       	cp.w	r6,r8
8000767c:	c0 64       	brge	80007688 <_vfprintf_r+0x47c>
8000767e:	fa cb f9 44 	sub	r11,sp,-1724
80007682:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007686:	c1 d8       	rjmp	800076c0 <_vfprintf_r+0x4b4>
80007688:	fa c8 f9 50 	sub	r8,sp,-1712
8000768c:	1a d8       	st.w	--sp,r8
8000768e:	fa c8 fa b8 	sub	r8,sp,-1352
80007692:	1a d8       	st.w	--sp,r8
80007694:	fa c8 fb b4 	sub	r8,sp,-1100
80007698:	1a d8       	st.w	--sp,r8
8000769a:	fa c8 f9 40 	sub	r8,sp,-1728
8000769e:	fa c9 ff b4 	sub	r9,sp,-76
800076a2:	04 9a       	mov	r10,r2
800076a4:	0c 9b       	mov	r11,r6
800076a6:	08 9c       	mov	r12,r4
800076a8:	fe b0 fc 1a 	rcall	80006edc <get_arg>
800076ac:	2f dd       	sub	sp,-12
800076ae:	19 b8       	ld.ub	r8,r12[0x3]
800076b0:	c2 28       	rjmp	800076f4 <_vfprintf_r+0x4e8>
800076b2:	2f f7       	sub	r7,-1
800076b4:	10 39       	cp.w	r9,r8
800076b6:	c0 84       	brge	800076c6 <_vfprintf_r+0x4ba>
800076b8:	fa ca f9 44 	sub	r10,sp,-1724
800076bc:	f4 06 00 36 	add	r6,r10,r6<<0x3
800076c0:	ed 38 fd 8b 	ld.ub	r8,r6[-629]
800076c4:	c1 88       	rjmp	800076f4 <_vfprintf_r+0x4e8>
800076c6:	41 09       	lddsp	r9,sp[0x40]
800076c8:	59 f8       	cp.w	r8,31
800076ca:	e0 89 00 12 	brgt	800076ee <_vfprintf_r+0x4e2>
800076ce:	f2 ca ff fc 	sub	r10,r9,-4
800076d2:	51 0a       	stdsp	sp[0x40],r10
800076d4:	72 09       	ld.w	r9,r9[0x0]
800076d6:	fa c6 f9 44 	sub	r6,sp,-1724
800076da:	ec 08 00 3a 	add	r10,r6,r8<<0x3
800076de:	2f f8       	sub	r8,-1
800076e0:	f5 49 fd 88 	st.w	r10[-632],r9
800076e4:	fb 48 06 b4 	st.w	sp[1716],r8
800076e8:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
800076ec:	c0 48       	rjmp	800076f4 <_vfprintf_r+0x4e8>
800076ee:	13 b8       	ld.ub	r8,r9[0x3]
800076f0:	2f c9       	sub	r9,-4
800076f2:	51 09       	stdsp	sp[0x40],r9
800076f4:	fb 68 06 60 	st.b	sp[1632],r8
800076f8:	30 0e       	mov	lr,0
800076fa:	30 08       	mov	r8,0
800076fc:	30 12       	mov	r2,1
800076fe:	fb 68 06 bb 	st.b	sp[1723],r8
80007702:	50 2e       	stdsp	sp[0x8],lr
80007704:	e0 8f 08 ad 	bral	8000885e <_vfprintf_r+0x1652>
80007708:	50 a7       	stdsp	sp[0x28],r7
8000770a:	50 80       	stdsp	sp[0x20],r0
8000770c:	0c 97       	mov	r7,r6
8000770e:	04 94       	mov	r4,r2
80007710:	06 96       	mov	r6,r3
80007712:	02 92       	mov	r2,r1
80007714:	40 93       	lddsp	r3,sp[0x24]
80007716:	10 90       	mov	r0,r8
80007718:	40 41       	lddsp	r1,sp[0x10]
8000771a:	a5 a5       	sbr	r5,0x4
8000771c:	c0 a8       	rjmp	80007730 <_vfprintf_r+0x524>
8000771e:	50 a7       	stdsp	sp[0x28],r7
80007720:	50 80       	stdsp	sp[0x20],r0
80007722:	0c 97       	mov	r7,r6
80007724:	04 94       	mov	r4,r2
80007726:	06 96       	mov	r6,r3
80007728:	02 92       	mov	r2,r1
8000772a:	40 93       	lddsp	r3,sp[0x24]
8000772c:	10 90       	mov	r0,r8
8000772e:	40 41       	lddsp	r1,sp[0x10]
80007730:	ed b5 00 05 	bld	r5,0x5
80007734:	c5 11       	brne	800077d6 <_vfprintf_r+0x5ca>
80007736:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000773a:	40 3c       	lddsp	r12,sp[0xc]
8000773c:	58 0c       	cp.w	r12,0
8000773e:	c1 e0       	breq	8000777a <_vfprintf_r+0x56e>
80007740:	10 36       	cp.w	r6,r8
80007742:	c0 64       	brge	8000774e <_vfprintf_r+0x542>
80007744:	fa cb f9 44 	sub	r11,sp,-1724
80007748:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000774c:	c2 08       	rjmp	8000778c <_vfprintf_r+0x580>
8000774e:	fa c8 f9 50 	sub	r8,sp,-1712
80007752:	1a d8       	st.w	--sp,r8
80007754:	fa c8 fa b8 	sub	r8,sp,-1352
80007758:	0c 9b       	mov	r11,r6
8000775a:	1a d8       	st.w	--sp,r8
8000775c:	fa c8 fb b4 	sub	r8,sp,-1100
80007760:	1a d8       	st.w	--sp,r8
80007762:	fa c9 ff b4 	sub	r9,sp,-76
80007766:	fa c8 f9 40 	sub	r8,sp,-1728
8000776a:	04 9a       	mov	r10,r2
8000776c:	08 9c       	mov	r12,r4
8000776e:	fe b0 fb b7 	rcall	80006edc <get_arg>
80007772:	2f dd       	sub	sp,-12
80007774:	78 1b       	ld.w	r11,r12[0x4]
80007776:	78 09       	ld.w	r9,r12[0x0]
80007778:	c2 b8       	rjmp	800077ce <_vfprintf_r+0x5c2>
8000777a:	ee ca ff ff 	sub	r10,r7,-1
8000777e:	10 37       	cp.w	r7,r8
80007780:	c0 b4       	brge	80007796 <_vfprintf_r+0x58a>
80007782:	fa c9 f9 44 	sub	r9,sp,-1724
80007786:	14 97       	mov	r7,r10
80007788:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000778c:	ec fb fd 8c 	ld.w	r11,r6[-628]
80007790:	ec f9 fd 88 	ld.w	r9,r6[-632]
80007794:	c1 d8       	rjmp	800077ce <_vfprintf_r+0x5c2>
80007796:	41 09       	lddsp	r9,sp[0x40]
80007798:	59 f8       	cp.w	r8,31
8000779a:	e0 89 00 14 	brgt	800077c2 <_vfprintf_r+0x5b6>
8000779e:	f2 cb ff f8 	sub	r11,r9,-8
800077a2:	51 0b       	stdsp	sp[0x40],r11
800077a4:	fa c6 f9 44 	sub	r6,sp,-1724
800077a8:	72 1b       	ld.w	r11,r9[0x4]
800077aa:	ec 08 00 3c 	add	r12,r6,r8<<0x3
800077ae:	72 09       	ld.w	r9,r9[0x0]
800077b0:	f9 4b fd 8c 	st.w	r12[-628],r11
800077b4:	f9 49 fd 88 	st.w	r12[-632],r9
800077b8:	2f f8       	sub	r8,-1
800077ba:	14 97       	mov	r7,r10
800077bc:	fb 48 06 b4 	st.w	sp[1716],r8
800077c0:	c0 78       	rjmp	800077ce <_vfprintf_r+0x5c2>
800077c2:	f2 c8 ff f8 	sub	r8,r9,-8
800077c6:	72 1b       	ld.w	r11,r9[0x4]
800077c8:	14 97       	mov	r7,r10
800077ca:	51 08       	stdsp	sp[0x40],r8
800077cc:	72 09       	ld.w	r9,r9[0x0]
800077ce:	16 98       	mov	r8,r11
800077d0:	fa e9 00 00 	st.d	sp[0],r8
800077d4:	ca e8       	rjmp	80007930 <_vfprintf_r+0x724>
800077d6:	ed b5 00 04 	bld	r5,0x4
800077da:	c1 71       	brne	80007808 <_vfprintf_r+0x5fc>
800077dc:	fa f8 06 b4 	ld.w	r8,sp[1716]
800077e0:	40 3e       	lddsp	lr,sp[0xc]
800077e2:	58 0e       	cp.w	lr,0
800077e4:	c0 80       	breq	800077f4 <_vfprintf_r+0x5e8>
800077e6:	10 36       	cp.w	r6,r8
800077e8:	c6 94       	brge	800078ba <_vfprintf_r+0x6ae>
800077ea:	fa cc f9 44 	sub	r12,sp,-1724
800077ee:	f8 06 00 36 	add	r6,r12,r6<<0x3
800077f2:	c8 28       	rjmp	800078f6 <_vfprintf_r+0x6ea>
800077f4:	ee ca ff ff 	sub	r10,r7,-1
800077f8:	10 37       	cp.w	r7,r8
800077fa:	e0 84 00 81 	brge	800078fc <_vfprintf_r+0x6f0>
800077fe:	fa cb f9 44 	sub	r11,sp,-1724
80007802:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007806:	c7 78       	rjmp	800078f4 <_vfprintf_r+0x6e8>
80007808:	ed b5 00 06 	bld	r5,0x6
8000780c:	c4 b1       	brne	800078a2 <_vfprintf_r+0x696>
8000780e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007812:	40 3c       	lddsp	r12,sp[0xc]
80007814:	58 0c       	cp.w	r12,0
80007816:	c1 d0       	breq	80007850 <_vfprintf_r+0x644>
80007818:	10 36       	cp.w	r6,r8
8000781a:	c0 64       	brge	80007826 <_vfprintf_r+0x61a>
8000781c:	fa cb f9 44 	sub	r11,sp,-1724
80007820:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007824:	c1 f8       	rjmp	80007862 <_vfprintf_r+0x656>
80007826:	fa c8 f9 50 	sub	r8,sp,-1712
8000782a:	1a d8       	st.w	--sp,r8
8000782c:	fa c8 fa b8 	sub	r8,sp,-1352
80007830:	1a d8       	st.w	--sp,r8
80007832:	fa c8 fb b4 	sub	r8,sp,-1100
80007836:	1a d8       	st.w	--sp,r8
80007838:	fa c8 f9 40 	sub	r8,sp,-1728
8000783c:	fa c9 ff b4 	sub	r9,sp,-76
80007840:	04 9a       	mov	r10,r2
80007842:	0c 9b       	mov	r11,r6
80007844:	08 9c       	mov	r12,r4
80007846:	fe b0 fb 4b 	rcall	80006edc <get_arg>
8000784a:	2f dd       	sub	sp,-12
8000784c:	98 18       	ld.sh	r8,r12[0x2]
8000784e:	c2 68       	rjmp	8000789a <_vfprintf_r+0x68e>
80007850:	ee ca ff ff 	sub	r10,r7,-1
80007854:	10 37       	cp.w	r7,r8
80007856:	c0 94       	brge	80007868 <_vfprintf_r+0x65c>
80007858:	fa c9 f9 44 	sub	r9,sp,-1724
8000785c:	14 97       	mov	r7,r10
8000785e:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007862:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80007866:	c1 a8       	rjmp	8000789a <_vfprintf_r+0x68e>
80007868:	41 09       	lddsp	r9,sp[0x40]
8000786a:	59 f8       	cp.w	r8,31
8000786c:	e0 89 00 13 	brgt	80007892 <_vfprintf_r+0x686>
80007870:	f2 cb ff fc 	sub	r11,r9,-4
80007874:	51 0b       	stdsp	sp[0x40],r11
80007876:	72 09       	ld.w	r9,r9[0x0]
80007878:	fa c6 f9 44 	sub	r6,sp,-1724
8000787c:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80007880:	2f f8       	sub	r8,-1
80007882:	f7 49 fd 88 	st.w	r11[-632],r9
80007886:	fb 48 06 b4 	st.w	sp[1716],r8
8000788a:	14 97       	mov	r7,r10
8000788c:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80007890:	c0 58       	rjmp	8000789a <_vfprintf_r+0x68e>
80007892:	92 18       	ld.sh	r8,r9[0x2]
80007894:	14 97       	mov	r7,r10
80007896:	2f c9       	sub	r9,-4
80007898:	51 09       	stdsp	sp[0x40],r9
8000789a:	50 18       	stdsp	sp[0x4],r8
8000789c:	bf 58       	asr	r8,0x1f
8000789e:	50 08       	stdsp	sp[0x0],r8
800078a0:	c4 88       	rjmp	80007930 <_vfprintf_r+0x724>
800078a2:	fa f8 06 b4 	ld.w	r8,sp[1716]
800078a6:	40 3c       	lddsp	r12,sp[0xc]
800078a8:	58 0c       	cp.w	r12,0
800078aa:	c1 d0       	breq	800078e4 <_vfprintf_r+0x6d8>
800078ac:	10 36       	cp.w	r6,r8
800078ae:	c0 64       	brge	800078ba <_vfprintf_r+0x6ae>
800078b0:	fa cb f9 44 	sub	r11,sp,-1724
800078b4:	f6 06 00 36 	add	r6,r11,r6<<0x3
800078b8:	c1 f8       	rjmp	800078f6 <_vfprintf_r+0x6ea>
800078ba:	fa c8 f9 50 	sub	r8,sp,-1712
800078be:	1a d8       	st.w	--sp,r8
800078c0:	fa c8 fa b8 	sub	r8,sp,-1352
800078c4:	0c 9b       	mov	r11,r6
800078c6:	1a d8       	st.w	--sp,r8
800078c8:	fa c8 fb b4 	sub	r8,sp,-1100
800078cc:	04 9a       	mov	r10,r2
800078ce:	1a d8       	st.w	--sp,r8
800078d0:	08 9c       	mov	r12,r4
800078d2:	fa c8 f9 40 	sub	r8,sp,-1728
800078d6:	fa c9 ff b4 	sub	r9,sp,-76
800078da:	fe b0 fb 01 	rcall	80006edc <get_arg>
800078de:	2f dd       	sub	sp,-12
800078e0:	78 0b       	ld.w	r11,r12[0x0]
800078e2:	c2 48       	rjmp	8000792a <_vfprintf_r+0x71e>
800078e4:	ee ca ff ff 	sub	r10,r7,-1
800078e8:	10 37       	cp.w	r7,r8
800078ea:	c0 94       	brge	800078fc <_vfprintf_r+0x6f0>
800078ec:	fa c9 f9 44 	sub	r9,sp,-1724
800078f0:	f2 06 00 36 	add	r6,r9,r6<<0x3
800078f4:	14 97       	mov	r7,r10
800078f6:	ec fb fd 88 	ld.w	r11,r6[-632]
800078fa:	c1 88       	rjmp	8000792a <_vfprintf_r+0x71e>
800078fc:	41 09       	lddsp	r9,sp[0x40]
800078fe:	59 f8       	cp.w	r8,31
80007900:	e0 89 00 11 	brgt	80007922 <_vfprintf_r+0x716>
80007904:	f2 cb ff fc 	sub	r11,r9,-4
80007908:	51 0b       	stdsp	sp[0x40],r11
8000790a:	fa c6 f9 44 	sub	r6,sp,-1724
8000790e:	72 0b       	ld.w	r11,r9[0x0]
80007910:	ec 08 00 39 	add	r9,r6,r8<<0x3
80007914:	f3 4b fd 88 	st.w	r9[-632],r11
80007918:	2f f8       	sub	r8,-1
8000791a:	14 97       	mov	r7,r10
8000791c:	fb 48 06 b4 	st.w	sp[1716],r8
80007920:	c0 58       	rjmp	8000792a <_vfprintf_r+0x71e>
80007922:	72 0b       	ld.w	r11,r9[0x0]
80007924:	14 97       	mov	r7,r10
80007926:	2f c9       	sub	r9,-4
80007928:	51 09       	stdsp	sp[0x40],r9
8000792a:	50 1b       	stdsp	sp[0x4],r11
8000792c:	bf 5b       	asr	r11,0x1f
8000792e:	50 0b       	stdsp	sp[0x0],r11
80007930:	fa ea 00 00 	ld.d	r10,sp[0]
80007934:	58 0a       	cp.w	r10,0
80007936:	5c 2b       	cpc	r11
80007938:	c0 e4       	brge	80007954 <_vfprintf_r+0x748>
8000793a:	30 08       	mov	r8,0
8000793c:	fa ea 00 00 	ld.d	r10,sp[0]
80007940:	30 09       	mov	r9,0
80007942:	f0 0a 01 0a 	sub	r10,r8,r10
80007946:	f2 0b 01 4b 	sbc	r11,r9,r11
8000794a:	32 d8       	mov	r8,45
8000794c:	fa eb 00 00 	st.d	sp[0],r10
80007950:	fb 68 06 bb 	st.b	sp[1723],r8
80007954:	30 18       	mov	r8,1
80007956:	e0 8f 06 fa 	bral	8000874a <_vfprintf_r+0x153e>
8000795a:	50 a7       	stdsp	sp[0x28],r7
8000795c:	50 80       	stdsp	sp[0x20],r0
8000795e:	0c 97       	mov	r7,r6
80007960:	04 94       	mov	r4,r2
80007962:	06 96       	mov	r6,r3
80007964:	02 92       	mov	r2,r1
80007966:	40 93       	lddsp	r3,sp[0x24]
80007968:	10 90       	mov	r0,r8
8000796a:	40 41       	lddsp	r1,sp[0x10]
8000796c:	0e 99       	mov	r9,r7
8000796e:	ed b5 00 03 	bld	r5,0x3
80007972:	c4 11       	brne	800079f4 <_vfprintf_r+0x7e8>
80007974:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007978:	40 3a       	lddsp	r10,sp[0xc]
8000797a:	58 0a       	cp.w	r10,0
8000797c:	c1 90       	breq	800079ae <_vfprintf_r+0x7a2>
8000797e:	10 36       	cp.w	r6,r8
80007980:	c6 45       	brlt	80007a48 <_vfprintf_r+0x83c>
80007982:	fa c8 f9 50 	sub	r8,sp,-1712
80007986:	1a d8       	st.w	--sp,r8
80007988:	fa c8 fa b8 	sub	r8,sp,-1352
8000798c:	1a d8       	st.w	--sp,r8
8000798e:	fa c8 fb b4 	sub	r8,sp,-1100
80007992:	0c 9b       	mov	r11,r6
80007994:	1a d8       	st.w	--sp,r8
80007996:	04 9a       	mov	r10,r2
80007998:	fa c8 f9 40 	sub	r8,sp,-1728
8000799c:	fa c9 ff b4 	sub	r9,sp,-76
800079a0:	08 9c       	mov	r12,r4
800079a2:	fe b0 fa 9d 	rcall	80006edc <get_arg>
800079a6:	2f dd       	sub	sp,-12
800079a8:	78 16       	ld.w	r6,r12[0x4]
800079aa:	50 76       	stdsp	sp[0x1c],r6
800079ac:	c4 88       	rjmp	80007a3c <_vfprintf_r+0x830>
800079ae:	2f f7       	sub	r7,-1
800079b0:	10 39       	cp.w	r9,r8
800079b2:	c0 c4       	brge	800079ca <_vfprintf_r+0x7be>
800079b4:	fa ce f9 44 	sub	lr,sp,-1724
800079b8:	fc 06 00 36 	add	r6,lr,r6<<0x3
800079bc:	ec fc fd 8c 	ld.w	r12,r6[-628]
800079c0:	50 7c       	stdsp	sp[0x1c],r12
800079c2:	ec f6 fd 88 	ld.w	r6,r6[-632]
800079c6:	50 56       	stdsp	sp[0x14],r6
800079c8:	c6 68       	rjmp	80007a94 <_vfprintf_r+0x888>
800079ca:	41 09       	lddsp	r9,sp[0x40]
800079cc:	59 f8       	cp.w	r8,31
800079ce:	e0 89 00 10 	brgt	800079ee <_vfprintf_r+0x7e2>
800079d2:	f2 ca ff f8 	sub	r10,r9,-8
800079d6:	72 1b       	ld.w	r11,r9[0x4]
800079d8:	51 0a       	stdsp	sp[0x40],r10
800079da:	72 09       	ld.w	r9,r9[0x0]
800079dc:	fa ca f9 44 	sub	r10,sp,-1724
800079e0:	50 7b       	stdsp	sp[0x1c],r11
800079e2:	50 59       	stdsp	sp[0x14],r9
800079e4:	f4 08 00 39 	add	r9,r10,r8<<0x3
800079e8:	40 5b       	lddsp	r11,sp[0x14]
800079ea:	40 7a       	lddsp	r10,sp[0x1c]
800079ec:	c4 78       	rjmp	80007a7a <_vfprintf_r+0x86e>
800079ee:	72 18       	ld.w	r8,r9[0x4]
800079f0:	50 78       	stdsp	sp[0x1c],r8
800079f2:	c4 c8       	rjmp	80007a8a <_vfprintf_r+0x87e>
800079f4:	fa f8 06 b4 	ld.w	r8,sp[1716]
800079f8:	40 3e       	lddsp	lr,sp[0xc]
800079fa:	58 0e       	cp.w	lr,0
800079fc:	c2 30       	breq	80007a42 <_vfprintf_r+0x836>
800079fe:	10 36       	cp.w	r6,r8
80007a00:	c0 94       	brge	80007a12 <_vfprintf_r+0x806>
80007a02:	fa cc f9 44 	sub	r12,sp,-1724
80007a06:	f8 06 00 36 	add	r6,r12,r6<<0x3
80007a0a:	ec fb fd 8c 	ld.w	r11,r6[-628]
80007a0e:	50 7b       	stdsp	sp[0x1c],r11
80007a10:	cd 9b       	rjmp	800079c2 <_vfprintf_r+0x7b6>
80007a12:	fa c8 f9 50 	sub	r8,sp,-1712
80007a16:	1a d8       	st.w	--sp,r8
80007a18:	fa c8 fa b8 	sub	r8,sp,-1352
80007a1c:	04 9a       	mov	r10,r2
80007a1e:	1a d8       	st.w	--sp,r8
80007a20:	fa c8 fb b4 	sub	r8,sp,-1100
80007a24:	0c 9b       	mov	r11,r6
80007a26:	1a d8       	st.w	--sp,r8
80007a28:	08 9c       	mov	r12,r4
80007a2a:	fa c8 f9 40 	sub	r8,sp,-1728
80007a2e:	fa c9 ff b4 	sub	r9,sp,-76
80007a32:	fe b0 fa 55 	rcall	80006edc <get_arg>
80007a36:	2f dd       	sub	sp,-12
80007a38:	78 1a       	ld.w	r10,r12[0x4]
80007a3a:	50 7a       	stdsp	sp[0x1c],r10
80007a3c:	78 0c       	ld.w	r12,r12[0x0]
80007a3e:	50 5c       	stdsp	sp[0x14],r12
80007a40:	c2 a8       	rjmp	80007a94 <_vfprintf_r+0x888>
80007a42:	2f f7       	sub	r7,-1
80007a44:	10 39       	cp.w	r9,r8
80007a46:	c0 94       	brge	80007a58 <_vfprintf_r+0x84c>
80007a48:	fa c9 f9 44 	sub	r9,sp,-1724
80007a4c:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007a50:	ec f8 fd 8c 	ld.w	r8,r6[-628]
80007a54:	50 78       	stdsp	sp[0x1c],r8
80007a56:	cb 6b       	rjmp	800079c2 <_vfprintf_r+0x7b6>
80007a58:	41 09       	lddsp	r9,sp[0x40]
80007a5a:	59 f8       	cp.w	r8,31
80007a5c:	e0 89 00 15 	brgt	80007a86 <_vfprintf_r+0x87a>
80007a60:	f2 ca ff f8 	sub	r10,r9,-8
80007a64:	72 16       	ld.w	r6,r9[0x4]
80007a66:	72 09       	ld.w	r9,r9[0x0]
80007a68:	51 0a       	stdsp	sp[0x40],r10
80007a6a:	50 59       	stdsp	sp[0x14],r9
80007a6c:	fa ce f9 44 	sub	lr,sp,-1724
80007a70:	50 76       	stdsp	sp[0x1c],r6
80007a72:	fc 08 00 39 	add	r9,lr,r8<<0x3
80007a76:	40 5b       	lddsp	r11,sp[0x14]
80007a78:	0c 9a       	mov	r10,r6
80007a7a:	f2 eb fd 88 	st.d	r9[-632],r10
80007a7e:	2f f8       	sub	r8,-1
80007a80:	fb 48 06 b4 	st.w	sp[1716],r8
80007a84:	c0 88       	rjmp	80007a94 <_vfprintf_r+0x888>
80007a86:	72 1c       	ld.w	r12,r9[0x4]
80007a88:	50 7c       	stdsp	sp[0x1c],r12
80007a8a:	f2 c8 ff f8 	sub	r8,r9,-8
80007a8e:	51 08       	stdsp	sp[0x40],r8
80007a90:	72 09       	ld.w	r9,r9[0x0]
80007a92:	50 59       	stdsp	sp[0x14],r9
80007a94:	40 5b       	lddsp	r11,sp[0x14]
80007a96:	40 7a       	lddsp	r10,sp[0x1c]
80007a98:	e0 a0 19 54 	rcall	8000ad40 <__isinfd>
80007a9c:	18 96       	mov	r6,r12
80007a9e:	c1 70       	breq	80007acc <_vfprintf_r+0x8c0>
80007aa0:	30 08       	mov	r8,0
80007aa2:	30 09       	mov	r9,0
80007aa4:	40 5b       	lddsp	r11,sp[0x14]
80007aa6:	40 7a       	lddsp	r10,sp[0x1c]
80007aa8:	e0 a0 1d a8 	rcall	8000b5f8 <__avr32_f64_cmp_lt>
80007aac:	c0 40       	breq	80007ab4 <_vfprintf_r+0x8a8>
80007aae:	32 d8       	mov	r8,45
80007ab0:	fb 68 06 bb 	st.b	sp[1723],r8
80007ab4:	fe c8 ac 98 	sub	r8,pc,-21352
80007ab8:	fe c6 ac 98 	sub	r6,pc,-21352
80007abc:	a7 d5       	cbr	r5,0x7
80007abe:	e0 40 00 47 	cp.w	r0,71
80007ac2:	f0 06 17 a0 	movle	r6,r8
80007ac6:	30 32       	mov	r2,3
80007ac8:	e0 8f 06 ce 	bral	80008864 <_vfprintf_r+0x1658>
80007acc:	40 5b       	lddsp	r11,sp[0x14]
80007ace:	40 7a       	lddsp	r10,sp[0x1c]
80007ad0:	e0 a0 19 4d 	rcall	8000ad6a <__isnand>
80007ad4:	c0 e0       	breq	80007af0 <_vfprintf_r+0x8e4>
80007ad6:	50 26       	stdsp	sp[0x8],r6
80007ad8:	fe c8 ac b4 	sub	r8,pc,-21324
80007adc:	fe c6 ac b4 	sub	r6,pc,-21324
80007ae0:	a7 d5       	cbr	r5,0x7
80007ae2:	e0 40 00 47 	cp.w	r0,71
80007ae6:	f0 06 17 a0 	movle	r6,r8
80007aea:	30 32       	mov	r2,3
80007aec:	e0 8f 06 c2 	bral	80008870 <_vfprintf_r+0x1664>
80007af0:	40 2a       	lddsp	r10,sp[0x8]
80007af2:	5b fa       	cp.w	r10,-1
80007af4:	c0 41       	brne	80007afc <_vfprintf_r+0x8f0>
80007af6:	30 69       	mov	r9,6
80007af8:	50 29       	stdsp	sp[0x8],r9
80007afa:	c1 18       	rjmp	80007b1c <_vfprintf_r+0x910>
80007afc:	e0 40 00 47 	cp.w	r0,71
80007b00:	5f 09       	sreq	r9
80007b02:	e0 40 00 67 	cp.w	r0,103
80007b06:	5f 08       	sreq	r8
80007b08:	f3 e8 10 08 	or	r8,r9,r8
80007b0c:	f8 08 18 00 	cp.b	r8,r12
80007b10:	c0 60       	breq	80007b1c <_vfprintf_r+0x910>
80007b12:	40 28       	lddsp	r8,sp[0x8]
80007b14:	58 08       	cp.w	r8,0
80007b16:	f9 b8 00 01 	moveq	r8,1
80007b1a:	50 28       	stdsp	sp[0x8],r8
80007b1c:	40 78       	lddsp	r8,sp[0x1c]
80007b1e:	40 59       	lddsp	r9,sp[0x14]
80007b20:	fa e9 06 94 	st.d	sp[1684],r8
80007b24:	a9 a5       	sbr	r5,0x8
80007b26:	fa f8 06 94 	ld.w	r8,sp[1684]
80007b2a:	58 08       	cp.w	r8,0
80007b2c:	c0 65       	brlt	80007b38 <_vfprintf_r+0x92c>
80007b2e:	40 5e       	lddsp	lr,sp[0x14]
80007b30:	30 0c       	mov	r12,0
80007b32:	50 6e       	stdsp	sp[0x18],lr
80007b34:	50 9c       	stdsp	sp[0x24],r12
80007b36:	c0 78       	rjmp	80007b44 <_vfprintf_r+0x938>
80007b38:	40 5b       	lddsp	r11,sp[0x14]
80007b3a:	32 da       	mov	r10,45
80007b3c:	ee 1b 80 00 	eorh	r11,0x8000
80007b40:	50 9a       	stdsp	sp[0x24],r10
80007b42:	50 6b       	stdsp	sp[0x18],r11
80007b44:	e0 40 00 46 	cp.w	r0,70
80007b48:	5f 09       	sreq	r9
80007b4a:	e0 40 00 66 	cp.w	r0,102
80007b4e:	5f 08       	sreq	r8
80007b50:	f3 e8 10 08 	or	r8,r9,r8
80007b54:	50 48       	stdsp	sp[0x10],r8
80007b56:	c0 40       	breq	80007b5e <_vfprintf_r+0x952>
80007b58:	40 22       	lddsp	r2,sp[0x8]
80007b5a:	30 39       	mov	r9,3
80007b5c:	c1 08       	rjmp	80007b7c <_vfprintf_r+0x970>
80007b5e:	e0 40 00 45 	cp.w	r0,69
80007b62:	5f 09       	sreq	r9
80007b64:	e0 40 00 65 	cp.w	r0,101
80007b68:	5f 08       	sreq	r8
80007b6a:	40 22       	lddsp	r2,sp[0x8]
80007b6c:	10 49       	or	r9,r8
80007b6e:	2f f2       	sub	r2,-1
80007b70:	40 46       	lddsp	r6,sp[0x10]
80007b72:	ec 09 18 00 	cp.b	r9,r6
80007b76:	fb f2 00 02 	ld.weq	r2,sp[0x8]
80007b7a:	30 29       	mov	r9,2
80007b7c:	fa c8 f9 5c 	sub	r8,sp,-1700
80007b80:	1a d8       	st.w	--sp,r8
80007b82:	fa c8 f9 54 	sub	r8,sp,-1708
80007b86:	1a d8       	st.w	--sp,r8
80007b88:	fa c8 f9 4c 	sub	r8,sp,-1716
80007b8c:	08 9c       	mov	r12,r4
80007b8e:	1a d8       	st.w	--sp,r8
80007b90:	04 98       	mov	r8,r2
80007b92:	40 9b       	lddsp	r11,sp[0x24]
80007b94:	40 aa       	lddsp	r10,sp[0x28]
80007b96:	e0 a0 0b c3 	rcall	8000931c <_dtoa_r>
80007b9a:	e0 40 00 47 	cp.w	r0,71
80007b9e:	5f 19       	srne	r9
80007ba0:	e0 40 00 67 	cp.w	r0,103
80007ba4:	5f 18       	srne	r8
80007ba6:	18 96       	mov	r6,r12
80007ba8:	2f dd       	sub	sp,-12
80007baa:	f3 e8 00 08 	and	r8,r9,r8
80007bae:	c0 41       	brne	80007bb6 <_vfprintf_r+0x9aa>
80007bb0:	ed b5 00 00 	bld	r5,0x0
80007bb4:	c3 01       	brne	80007c14 <_vfprintf_r+0xa08>
80007bb6:	ec 02 00 0e 	add	lr,r6,r2
80007bba:	50 3e       	stdsp	sp[0xc],lr
80007bbc:	40 4c       	lddsp	r12,sp[0x10]
80007bbe:	58 0c       	cp.w	r12,0
80007bc0:	c1 50       	breq	80007bea <_vfprintf_r+0x9de>
80007bc2:	0d 89       	ld.ub	r9,r6[0x0]
80007bc4:	33 08       	mov	r8,48
80007bc6:	f0 09 18 00 	cp.b	r9,r8
80007bca:	c0 b1       	brne	80007be0 <_vfprintf_r+0x9d4>
80007bcc:	30 08       	mov	r8,0
80007bce:	30 09       	mov	r9,0
80007bd0:	40 6b       	lddsp	r11,sp[0x18]
80007bd2:	40 7a       	lddsp	r10,sp[0x1c]
80007bd4:	e0 a0 1c cb 	rcall	8000b56a <__avr32_f64_cmp_eq>
80007bd8:	fb b2 00 01 	rsubeq	r2,1
80007bdc:	fb f2 0b ab 	st.weq	sp[0x6ac],r2
80007be0:	40 3b       	lddsp	r11,sp[0xc]
80007be2:	fa f8 06 ac 	ld.w	r8,sp[1708]
80007be6:	10 0b       	add	r11,r8
80007be8:	50 3b       	stdsp	sp[0xc],r11
80007bea:	40 6b       	lddsp	r11,sp[0x18]
80007bec:	30 08       	mov	r8,0
80007bee:	30 09       	mov	r9,0
80007bf0:	40 7a       	lddsp	r10,sp[0x1c]
80007bf2:	e0 a0 1c bc 	rcall	8000b56a <__avr32_f64_cmp_eq>
80007bf6:	c0 90       	breq	80007c08 <_vfprintf_r+0x9fc>
80007bf8:	40 3a       	lddsp	r10,sp[0xc]
80007bfa:	fb 4a 06 a4 	st.w	sp[1700],r10
80007bfe:	c0 58       	rjmp	80007c08 <_vfprintf_r+0x9fc>
80007c00:	10 c9       	st.b	r8++,r9
80007c02:	fb 48 06 a4 	st.w	sp[1700],r8
80007c06:	c0 28       	rjmp	80007c0a <_vfprintf_r+0x9fe>
80007c08:	33 09       	mov	r9,48
80007c0a:	fa f8 06 a4 	ld.w	r8,sp[1700]
80007c0e:	40 3e       	lddsp	lr,sp[0xc]
80007c10:	1c 38       	cp.w	r8,lr
80007c12:	cf 73       	brcs	80007c00 <_vfprintf_r+0x9f4>
80007c14:	e0 40 00 47 	cp.w	r0,71
80007c18:	5f 09       	sreq	r9
80007c1a:	e0 40 00 67 	cp.w	r0,103
80007c1e:	5f 08       	sreq	r8
80007c20:	f3 e8 10 08 	or	r8,r9,r8
80007c24:	fa f9 06 a4 	ld.w	r9,sp[1700]
80007c28:	0c 19       	sub	r9,r6
80007c2a:	50 69       	stdsp	sp[0x18],r9
80007c2c:	58 08       	cp.w	r8,0
80007c2e:	c0 b0       	breq	80007c44 <_vfprintf_r+0xa38>
80007c30:	fa f8 06 ac 	ld.w	r8,sp[1708]
80007c34:	5b d8       	cp.w	r8,-3
80007c36:	c0 55       	brlt	80007c40 <_vfprintf_r+0xa34>
80007c38:	40 2c       	lddsp	r12,sp[0x8]
80007c3a:	18 38       	cp.w	r8,r12
80007c3c:	e0 8a 00 6a 	brle	80007d10 <_vfprintf_r+0xb04>
80007c40:	20 20       	sub	r0,2
80007c42:	c0 58       	rjmp	80007c4c <_vfprintf_r+0xa40>
80007c44:	e0 40 00 65 	cp.w	r0,101
80007c48:	e0 89 00 46 	brgt	80007cd4 <_vfprintf_r+0xac8>
80007c4c:	fa fb 06 ac 	ld.w	r11,sp[1708]
80007c50:	fb 60 06 9c 	st.b	sp[1692],r0
80007c54:	20 1b       	sub	r11,1
80007c56:	fb 4b 06 ac 	st.w	sp[1708],r11
80007c5a:	c0 47       	brpl	80007c62 <_vfprintf_r+0xa56>
80007c5c:	5c 3b       	neg	r11
80007c5e:	32 d8       	mov	r8,45
80007c60:	c0 28       	rjmp	80007c64 <_vfprintf_r+0xa58>
80007c62:	32 b8       	mov	r8,43
80007c64:	fb 68 06 9d 	st.b	sp[1693],r8
80007c68:	58 9b       	cp.w	r11,9
80007c6a:	e0 8a 00 1d 	brle	80007ca4 <_vfprintf_r+0xa98>
80007c6e:	fa c9 fa 35 	sub	r9,sp,-1483
80007c72:	30 aa       	mov	r10,10
80007c74:	12 98       	mov	r8,r9
80007c76:	0e 9c       	mov	r12,r7
80007c78:	0c 92       	mov	r2,r6
80007c7a:	f6 0a 0c 06 	divs	r6,r11,r10
80007c7e:	0e 9b       	mov	r11,r7
80007c80:	2d 0b       	sub	r11,-48
80007c82:	10 fb       	st.b	--r8,r11
80007c84:	0c 9b       	mov	r11,r6
80007c86:	58 96       	cp.w	r6,9
80007c88:	fe 99 ff f9 	brgt	80007c7a <_vfprintf_r+0xa6e>
80007c8c:	2d 0b       	sub	r11,-48
80007c8e:	18 97       	mov	r7,r12
80007c90:	04 96       	mov	r6,r2
80007c92:	10 fb       	st.b	--r8,r11
80007c94:	fa ca f9 62 	sub	r10,sp,-1694
80007c98:	c0 38       	rjmp	80007c9e <_vfprintf_r+0xa92>
80007c9a:	11 3b       	ld.ub	r11,r8++
80007c9c:	14 cb       	st.b	r10++,r11
80007c9e:	12 38       	cp.w	r8,r9
80007ca0:	cf d3       	brcs	80007c9a <_vfprintf_r+0xa8e>
80007ca2:	c0 98       	rjmp	80007cb4 <_vfprintf_r+0xaa8>
80007ca4:	2d 0b       	sub	r11,-48
80007ca6:	33 08       	mov	r8,48
80007ca8:	fb 6b 06 9f 	st.b	sp[1695],r11
80007cac:	fb 68 06 9e 	st.b	sp[1694],r8
80007cb0:	fa ca f9 60 	sub	r10,sp,-1696
80007cb4:	fa c8 f9 64 	sub	r8,sp,-1692
80007cb8:	f4 08 01 08 	sub	r8,r10,r8
80007cbc:	50 e8       	stdsp	sp[0x38],r8
80007cbe:	10 92       	mov	r2,r8
80007cc0:	40 6b       	lddsp	r11,sp[0x18]
80007cc2:	16 02       	add	r2,r11
80007cc4:	58 1b       	cp.w	r11,1
80007cc6:	e0 89 00 05 	brgt	80007cd0 <_vfprintf_r+0xac4>
80007cca:	ed b5 00 00 	bld	r5,0x0
80007cce:	c3 51       	brne	80007d38 <_vfprintf_r+0xb2c>
80007cd0:	2f f2       	sub	r2,-1
80007cd2:	c3 38       	rjmp	80007d38 <_vfprintf_r+0xb2c>
80007cd4:	e0 40 00 66 	cp.w	r0,102
80007cd8:	c1 c1       	brne	80007d10 <_vfprintf_r+0xb04>
80007cda:	fa f2 06 ac 	ld.w	r2,sp[1708]
80007cde:	58 02       	cp.w	r2,0
80007ce0:	e0 8a 00 0c 	brle	80007cf8 <_vfprintf_r+0xaec>
80007ce4:	40 2a       	lddsp	r10,sp[0x8]
80007ce6:	58 0a       	cp.w	r10,0
80007ce8:	c0 41       	brne	80007cf0 <_vfprintf_r+0xae4>
80007cea:	ed b5 00 00 	bld	r5,0x0
80007cee:	c2 51       	brne	80007d38 <_vfprintf_r+0xb2c>
80007cf0:	2f f2       	sub	r2,-1
80007cf2:	40 29       	lddsp	r9,sp[0x8]
80007cf4:	12 02       	add	r2,r9
80007cf6:	c0 b8       	rjmp	80007d0c <_vfprintf_r+0xb00>
80007cf8:	40 28       	lddsp	r8,sp[0x8]
80007cfa:	58 08       	cp.w	r8,0
80007cfc:	c0 61       	brne	80007d08 <_vfprintf_r+0xafc>
80007cfe:	ed b5 00 00 	bld	r5,0x0
80007d02:	c0 30       	breq	80007d08 <_vfprintf_r+0xafc>
80007d04:	30 12       	mov	r2,1
80007d06:	c1 98       	rjmp	80007d38 <_vfprintf_r+0xb2c>
80007d08:	40 22       	lddsp	r2,sp[0x8]
80007d0a:	2f e2       	sub	r2,-2
80007d0c:	36 60       	mov	r0,102
80007d0e:	c1 58       	rjmp	80007d38 <_vfprintf_r+0xb2c>
80007d10:	fa f2 06 ac 	ld.w	r2,sp[1708]
80007d14:	40 6e       	lddsp	lr,sp[0x18]
80007d16:	1c 32       	cp.w	r2,lr
80007d18:	c0 65       	brlt	80007d24 <_vfprintf_r+0xb18>
80007d1a:	ed b5 00 00 	bld	r5,0x0
80007d1e:	f7 b2 00 ff 	subeq	r2,-1
80007d22:	c0 a8       	rjmp	80007d36 <_vfprintf_r+0xb2a>
80007d24:	e4 08 11 02 	rsub	r8,r2,2
80007d28:	40 6c       	lddsp	r12,sp[0x18]
80007d2a:	58 02       	cp.w	r2,0
80007d2c:	f0 02 17 a0 	movle	r2,r8
80007d30:	f9 b2 09 01 	movgt	r2,1
80007d34:	18 02       	add	r2,r12
80007d36:	36 70       	mov	r0,103
80007d38:	40 9b       	lddsp	r11,sp[0x24]
80007d3a:	58 0b       	cp.w	r11,0
80007d3c:	e0 80 05 94 	breq	80008864 <_vfprintf_r+0x1658>
80007d40:	32 d8       	mov	r8,45
80007d42:	fb 68 06 bb 	st.b	sp[1723],r8
80007d46:	e0 8f 05 93 	bral	8000886c <_vfprintf_r+0x1660>
80007d4a:	50 a7       	stdsp	sp[0x28],r7
80007d4c:	04 94       	mov	r4,r2
80007d4e:	0c 97       	mov	r7,r6
80007d50:	02 92       	mov	r2,r1
80007d52:	06 96       	mov	r6,r3
80007d54:	40 41       	lddsp	r1,sp[0x10]
80007d56:	40 93       	lddsp	r3,sp[0x24]
80007d58:	0e 99       	mov	r9,r7
80007d5a:	ed b5 00 05 	bld	r5,0x5
80007d5e:	c4 81       	brne	80007dee <_vfprintf_r+0xbe2>
80007d60:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007d64:	40 3e       	lddsp	lr,sp[0xc]
80007d66:	58 0e       	cp.w	lr,0
80007d68:	c1 d0       	breq	80007da2 <_vfprintf_r+0xb96>
80007d6a:	10 36       	cp.w	r6,r8
80007d6c:	c0 64       	brge	80007d78 <_vfprintf_r+0xb6c>
80007d6e:	fa cc f9 44 	sub	r12,sp,-1724
80007d72:	f8 06 00 36 	add	r6,r12,r6<<0x3
80007d76:	c1 d8       	rjmp	80007db0 <_vfprintf_r+0xba4>
80007d78:	fa c8 f9 50 	sub	r8,sp,-1712
80007d7c:	1a d8       	st.w	--sp,r8
80007d7e:	fa c8 fa b8 	sub	r8,sp,-1352
80007d82:	04 9a       	mov	r10,r2
80007d84:	1a d8       	st.w	--sp,r8
80007d86:	fa c8 fb b4 	sub	r8,sp,-1100
80007d8a:	0c 9b       	mov	r11,r6
80007d8c:	1a d8       	st.w	--sp,r8
80007d8e:	08 9c       	mov	r12,r4
80007d90:	fa c8 f9 40 	sub	r8,sp,-1728
80007d94:	fa c9 ff b4 	sub	r9,sp,-76
80007d98:	fe b0 f8 a2 	rcall	80006edc <get_arg>
80007d9c:	2f dd       	sub	sp,-12
80007d9e:	78 0a       	ld.w	r10,r12[0x0]
80007da0:	c2 08       	rjmp	80007de0 <_vfprintf_r+0xbd4>
80007da2:	2f f7       	sub	r7,-1
80007da4:	10 39       	cp.w	r9,r8
80007da6:	c0 84       	brge	80007db6 <_vfprintf_r+0xbaa>
80007da8:	fa cb f9 44 	sub	r11,sp,-1724
80007dac:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007db0:	ec fa fd 88 	ld.w	r10,r6[-632]
80007db4:	c1 68       	rjmp	80007de0 <_vfprintf_r+0xbd4>
80007db6:	41 09       	lddsp	r9,sp[0x40]
80007db8:	59 f8       	cp.w	r8,31
80007dba:	e0 89 00 10 	brgt	80007dda <_vfprintf_r+0xbce>
80007dbe:	f2 ca ff fc 	sub	r10,r9,-4
80007dc2:	51 0a       	stdsp	sp[0x40],r10
80007dc4:	fa c6 f9 44 	sub	r6,sp,-1724
80007dc8:	72 0a       	ld.w	r10,r9[0x0]
80007dca:	ec 08 00 39 	add	r9,r6,r8<<0x3
80007dce:	f3 4a fd 88 	st.w	r9[-632],r10
80007dd2:	2f f8       	sub	r8,-1
80007dd4:	fb 48 06 b4 	st.w	sp[1716],r8
80007dd8:	c0 48       	rjmp	80007de0 <_vfprintf_r+0xbd4>
80007dda:	72 0a       	ld.w	r10,r9[0x0]
80007ddc:	2f c9       	sub	r9,-4
80007dde:	51 09       	stdsp	sp[0x40],r9
80007de0:	40 be       	lddsp	lr,sp[0x2c]
80007de2:	1c 98       	mov	r8,lr
80007de4:	95 1e       	st.w	r10[0x4],lr
80007de6:	bf 58       	asr	r8,0x1f
80007de8:	95 08       	st.w	r10[0x0],r8
80007dea:	fe 9f fa 9f 	bral	80007328 <_vfprintf_r+0x11c>
80007dee:	ed b5 00 04 	bld	r5,0x4
80007df2:	c4 80       	breq	80007e82 <_vfprintf_r+0xc76>
80007df4:	e2 15 00 40 	andl	r5,0x40,COH
80007df8:	c4 50       	breq	80007e82 <_vfprintf_r+0xc76>
80007dfa:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007dfe:	40 3c       	lddsp	r12,sp[0xc]
80007e00:	58 0c       	cp.w	r12,0
80007e02:	c1 d0       	breq	80007e3c <_vfprintf_r+0xc30>
80007e04:	10 36       	cp.w	r6,r8
80007e06:	c0 64       	brge	80007e12 <_vfprintf_r+0xc06>
80007e08:	fa cb f9 44 	sub	r11,sp,-1724
80007e0c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007e10:	c1 d8       	rjmp	80007e4a <_vfprintf_r+0xc3e>
80007e12:	fa c8 f9 50 	sub	r8,sp,-1712
80007e16:	1a d8       	st.w	--sp,r8
80007e18:	fa c8 fa b8 	sub	r8,sp,-1352
80007e1c:	04 9a       	mov	r10,r2
80007e1e:	1a d8       	st.w	--sp,r8
80007e20:	fa c8 fb b4 	sub	r8,sp,-1100
80007e24:	0c 9b       	mov	r11,r6
80007e26:	1a d8       	st.w	--sp,r8
80007e28:	08 9c       	mov	r12,r4
80007e2a:	fa c8 f9 40 	sub	r8,sp,-1728
80007e2e:	fa c9 ff b4 	sub	r9,sp,-76
80007e32:	fe b0 f8 55 	rcall	80006edc <get_arg>
80007e36:	2f dd       	sub	sp,-12
80007e38:	78 0a       	ld.w	r10,r12[0x0]
80007e3a:	c2 08       	rjmp	80007e7a <_vfprintf_r+0xc6e>
80007e3c:	2f f7       	sub	r7,-1
80007e3e:	10 39       	cp.w	r9,r8
80007e40:	c0 84       	brge	80007e50 <_vfprintf_r+0xc44>
80007e42:	fa ca f9 44 	sub	r10,sp,-1724
80007e46:	f4 06 00 36 	add	r6,r10,r6<<0x3
80007e4a:	ec fa fd 88 	ld.w	r10,r6[-632]
80007e4e:	c1 68       	rjmp	80007e7a <_vfprintf_r+0xc6e>
80007e50:	41 09       	lddsp	r9,sp[0x40]
80007e52:	59 f8       	cp.w	r8,31
80007e54:	e0 89 00 10 	brgt	80007e74 <_vfprintf_r+0xc68>
80007e58:	f2 ca ff fc 	sub	r10,r9,-4
80007e5c:	51 0a       	stdsp	sp[0x40],r10
80007e5e:	fa c6 f9 44 	sub	r6,sp,-1724
80007e62:	72 0a       	ld.w	r10,r9[0x0]
80007e64:	ec 08 00 39 	add	r9,r6,r8<<0x3
80007e68:	f3 4a fd 88 	st.w	r9[-632],r10
80007e6c:	2f f8       	sub	r8,-1
80007e6e:	fb 48 06 b4 	st.w	sp[1716],r8
80007e72:	c0 48       	rjmp	80007e7a <_vfprintf_r+0xc6e>
80007e74:	72 0a       	ld.w	r10,r9[0x0]
80007e76:	2f c9       	sub	r9,-4
80007e78:	51 09       	stdsp	sp[0x40],r9
80007e7a:	40 be       	lddsp	lr,sp[0x2c]
80007e7c:	b4 0e       	st.h	r10[0x0],lr
80007e7e:	fe 9f fa 55 	bral	80007328 <_vfprintf_r+0x11c>
80007e82:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007e86:	40 3c       	lddsp	r12,sp[0xc]
80007e88:	58 0c       	cp.w	r12,0
80007e8a:	c1 d0       	breq	80007ec4 <_vfprintf_r+0xcb8>
80007e8c:	10 36       	cp.w	r6,r8
80007e8e:	c0 64       	brge	80007e9a <_vfprintf_r+0xc8e>
80007e90:	fa cb f9 44 	sub	r11,sp,-1724
80007e94:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007e98:	c1 d8       	rjmp	80007ed2 <_vfprintf_r+0xcc6>
80007e9a:	fa c8 f9 50 	sub	r8,sp,-1712
80007e9e:	1a d8       	st.w	--sp,r8
80007ea0:	fa c8 fa b8 	sub	r8,sp,-1352
80007ea4:	04 9a       	mov	r10,r2
80007ea6:	1a d8       	st.w	--sp,r8
80007ea8:	fa c8 fb b4 	sub	r8,sp,-1100
80007eac:	0c 9b       	mov	r11,r6
80007eae:	1a d8       	st.w	--sp,r8
80007eb0:	08 9c       	mov	r12,r4
80007eb2:	fa c8 f9 40 	sub	r8,sp,-1728
80007eb6:	fa c9 ff b4 	sub	r9,sp,-76
80007eba:	fe b0 f8 11 	rcall	80006edc <get_arg>
80007ebe:	2f dd       	sub	sp,-12
80007ec0:	78 0a       	ld.w	r10,r12[0x0]
80007ec2:	c2 08       	rjmp	80007f02 <_vfprintf_r+0xcf6>
80007ec4:	2f f7       	sub	r7,-1
80007ec6:	10 39       	cp.w	r9,r8
80007ec8:	c0 84       	brge	80007ed8 <_vfprintf_r+0xccc>
80007eca:	fa ca f9 44 	sub	r10,sp,-1724
80007ece:	f4 06 00 36 	add	r6,r10,r6<<0x3
80007ed2:	ec fa fd 88 	ld.w	r10,r6[-632]
80007ed6:	c1 68       	rjmp	80007f02 <_vfprintf_r+0xcf6>
80007ed8:	41 09       	lddsp	r9,sp[0x40]
80007eda:	59 f8       	cp.w	r8,31
80007edc:	e0 89 00 10 	brgt	80007efc <_vfprintf_r+0xcf0>
80007ee0:	f2 ca ff fc 	sub	r10,r9,-4
80007ee4:	51 0a       	stdsp	sp[0x40],r10
80007ee6:	fa c6 f9 44 	sub	r6,sp,-1724
80007eea:	72 0a       	ld.w	r10,r9[0x0]
80007eec:	ec 08 00 39 	add	r9,r6,r8<<0x3
80007ef0:	f3 4a fd 88 	st.w	r9[-632],r10
80007ef4:	2f f8       	sub	r8,-1
80007ef6:	fb 48 06 b4 	st.w	sp[1716],r8
80007efa:	c0 48       	rjmp	80007f02 <_vfprintf_r+0xcf6>
80007efc:	72 0a       	ld.w	r10,r9[0x0]
80007efe:	2f c9       	sub	r9,-4
80007f00:	51 09       	stdsp	sp[0x40],r9
80007f02:	40 be       	lddsp	lr,sp[0x2c]
80007f04:	95 0e       	st.w	r10[0x0],lr
80007f06:	fe 9f fa 11 	bral	80007328 <_vfprintf_r+0x11c>
80007f0a:	50 a7       	stdsp	sp[0x28],r7
80007f0c:	50 80       	stdsp	sp[0x20],r0
80007f0e:	0c 97       	mov	r7,r6
80007f10:	04 94       	mov	r4,r2
80007f12:	06 96       	mov	r6,r3
80007f14:	02 92       	mov	r2,r1
80007f16:	40 93       	lddsp	r3,sp[0x24]
80007f18:	10 90       	mov	r0,r8
80007f1a:	40 41       	lddsp	r1,sp[0x10]
80007f1c:	a5 a5       	sbr	r5,0x4
80007f1e:	c0 a8       	rjmp	80007f32 <_vfprintf_r+0xd26>
80007f20:	50 a7       	stdsp	sp[0x28],r7
80007f22:	50 80       	stdsp	sp[0x20],r0
80007f24:	0c 97       	mov	r7,r6
80007f26:	04 94       	mov	r4,r2
80007f28:	06 96       	mov	r6,r3
80007f2a:	02 92       	mov	r2,r1
80007f2c:	40 93       	lddsp	r3,sp[0x24]
80007f2e:	10 90       	mov	r0,r8
80007f30:	40 41       	lddsp	r1,sp[0x10]
80007f32:	ed b5 00 05 	bld	r5,0x5
80007f36:	c5 d1       	brne	80007ff0 <_vfprintf_r+0xde4>
80007f38:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007f3c:	40 3c       	lddsp	r12,sp[0xc]
80007f3e:	58 0c       	cp.w	r12,0
80007f40:	c2 60       	breq	80007f8c <_vfprintf_r+0xd80>
80007f42:	10 36       	cp.w	r6,r8
80007f44:	c0 a4       	brge	80007f58 <_vfprintf_r+0xd4c>
80007f46:	fa cb f9 44 	sub	r11,sp,-1724
80007f4a:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007f4e:	ec e8 fd 88 	ld.d	r8,r6[-632]
80007f52:	fa e9 00 00 	st.d	sp[0],r8
80007f56:	c1 88       	rjmp	80007f86 <_vfprintf_r+0xd7a>
80007f58:	fa c8 f9 50 	sub	r8,sp,-1712
80007f5c:	1a d8       	st.w	--sp,r8
80007f5e:	fa c8 fa b8 	sub	r8,sp,-1352
80007f62:	04 9a       	mov	r10,r2
80007f64:	1a d8       	st.w	--sp,r8
80007f66:	0c 9b       	mov	r11,r6
80007f68:	fa c8 fb b4 	sub	r8,sp,-1100
80007f6c:	08 9c       	mov	r12,r4
80007f6e:	1a d8       	st.w	--sp,r8
80007f70:	fa c8 f9 40 	sub	r8,sp,-1728
80007f74:	fa c9 ff b4 	sub	r9,sp,-76
80007f78:	fe b0 f7 b2 	rcall	80006edc <get_arg>
80007f7c:	2f dd       	sub	sp,-12
80007f7e:	f8 ea 00 00 	ld.d	r10,r12[0]
80007f82:	fa eb 00 00 	st.d	sp[0],r10
80007f86:	30 08       	mov	r8,0
80007f88:	e0 8f 03 de 	bral	80008744 <_vfprintf_r+0x1538>
80007f8c:	ee ca ff ff 	sub	r10,r7,-1
80007f90:	10 37       	cp.w	r7,r8
80007f92:	c0 b4       	brge	80007fa8 <_vfprintf_r+0xd9c>
80007f94:	fa c9 f9 44 	sub	r9,sp,-1724
80007f98:	14 97       	mov	r7,r10
80007f9a:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007f9e:	ec ea fd 88 	ld.d	r10,r6[-632]
80007fa2:	fa eb 00 00 	st.d	sp[0],r10
80007fa6:	c1 88       	rjmp	80007fd6 <_vfprintf_r+0xdca>
80007fa8:	41 09       	lddsp	r9,sp[0x40]
80007faa:	59 f8       	cp.w	r8,31
80007fac:	e0 89 00 18 	brgt	80007fdc <_vfprintf_r+0xdd0>
80007fb0:	f2 e6 00 00 	ld.d	r6,r9[0]
80007fb4:	f2 cb ff f8 	sub	r11,r9,-8
80007fb8:	fa e7 00 00 	st.d	sp[0],r6
80007fbc:	51 0b       	stdsp	sp[0x40],r11
80007fbe:	fa c6 f9 44 	sub	r6,sp,-1724
80007fc2:	ec 08 00 39 	add	r9,r6,r8<<0x3
80007fc6:	fa e6 00 00 	ld.d	r6,sp[0]
80007fca:	f2 e7 fd 88 	st.d	r9[-632],r6
80007fce:	2f f8       	sub	r8,-1
80007fd0:	14 97       	mov	r7,r10
80007fd2:	fb 48 06 b4 	st.w	sp[1716],r8
80007fd6:	40 38       	lddsp	r8,sp[0xc]
80007fd8:	e0 8f 03 b6 	bral	80008744 <_vfprintf_r+0x1538>
80007fdc:	f2 e6 00 00 	ld.d	r6,r9[0]
80007fe0:	40 38       	lddsp	r8,sp[0xc]
80007fe2:	fa e7 00 00 	st.d	sp[0],r6
80007fe6:	2f 89       	sub	r9,-8
80007fe8:	14 97       	mov	r7,r10
80007fea:	51 09       	stdsp	sp[0x40],r9
80007fec:	e0 8f 03 ac 	bral	80008744 <_vfprintf_r+0x1538>
80007ff0:	ed b5 00 04 	bld	r5,0x4
80007ff4:	c1 61       	brne	80008020 <_vfprintf_r+0xe14>
80007ff6:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007ffa:	40 3e       	lddsp	lr,sp[0xc]
80007ffc:	58 0e       	cp.w	lr,0
80007ffe:	c0 80       	breq	8000800e <_vfprintf_r+0xe02>
80008000:	10 36       	cp.w	r6,r8
80008002:	c6 74       	brge	800080d0 <_vfprintf_r+0xec4>
80008004:	fa cc f9 44 	sub	r12,sp,-1724
80008008:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000800c:	c8 08       	rjmp	8000810c <_vfprintf_r+0xf00>
8000800e:	ee ca ff ff 	sub	r10,r7,-1
80008012:	10 37       	cp.w	r7,r8
80008014:	c7 f4       	brge	80008112 <_vfprintf_r+0xf06>
80008016:	fa cb f9 44 	sub	r11,sp,-1724
8000801a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000801e:	c7 68       	rjmp	8000810a <_vfprintf_r+0xefe>
80008020:	ed b5 00 06 	bld	r5,0x6
80008024:	c4 a1       	brne	800080b8 <_vfprintf_r+0xeac>
80008026:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000802a:	40 3c       	lddsp	r12,sp[0xc]
8000802c:	58 0c       	cp.w	r12,0
8000802e:	c1 d0       	breq	80008068 <_vfprintf_r+0xe5c>
80008030:	10 36       	cp.w	r6,r8
80008032:	c0 64       	brge	8000803e <_vfprintf_r+0xe32>
80008034:	fa cb f9 44 	sub	r11,sp,-1724
80008038:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000803c:	c1 f8       	rjmp	8000807a <_vfprintf_r+0xe6e>
8000803e:	fa c8 f9 50 	sub	r8,sp,-1712
80008042:	1a d8       	st.w	--sp,r8
80008044:	fa c8 fa b8 	sub	r8,sp,-1352
80008048:	1a d8       	st.w	--sp,r8
8000804a:	fa c8 fb b4 	sub	r8,sp,-1100
8000804e:	1a d8       	st.w	--sp,r8
80008050:	fa c8 f9 40 	sub	r8,sp,-1728
80008054:	fa c9 ff b4 	sub	r9,sp,-76
80008058:	04 9a       	mov	r10,r2
8000805a:	0c 9b       	mov	r11,r6
8000805c:	08 9c       	mov	r12,r4
8000805e:	fe b0 f7 3f 	rcall	80006edc <get_arg>
80008062:	2f dd       	sub	sp,-12
80008064:	98 18       	ld.sh	r8,r12[0x2]
80008066:	c2 68       	rjmp	800080b2 <_vfprintf_r+0xea6>
80008068:	ee ca ff ff 	sub	r10,r7,-1
8000806c:	10 37       	cp.w	r7,r8
8000806e:	c0 94       	brge	80008080 <_vfprintf_r+0xe74>
80008070:	fa c9 f9 44 	sub	r9,sp,-1724
80008074:	14 97       	mov	r7,r10
80008076:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000807a:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000807e:	c1 a8       	rjmp	800080b2 <_vfprintf_r+0xea6>
80008080:	41 09       	lddsp	r9,sp[0x40]
80008082:	59 f8       	cp.w	r8,31
80008084:	e0 89 00 13 	brgt	800080aa <_vfprintf_r+0xe9e>
80008088:	f2 cb ff fc 	sub	r11,r9,-4
8000808c:	51 0b       	stdsp	sp[0x40],r11
8000808e:	72 09       	ld.w	r9,r9[0x0]
80008090:	fa c6 f9 44 	sub	r6,sp,-1724
80008094:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008098:	2f f8       	sub	r8,-1
8000809a:	f7 49 fd 88 	st.w	r11[-632],r9
8000809e:	fb 48 06 b4 	st.w	sp[1716],r8
800080a2:	14 97       	mov	r7,r10
800080a4:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
800080a8:	c0 58       	rjmp	800080b2 <_vfprintf_r+0xea6>
800080aa:	92 18       	ld.sh	r8,r9[0x2]
800080ac:	14 97       	mov	r7,r10
800080ae:	2f c9       	sub	r9,-4
800080b0:	51 09       	stdsp	sp[0x40],r9
800080b2:	5c 78       	castu.h	r8
800080b4:	50 18       	stdsp	sp[0x4],r8
800080b6:	c4 68       	rjmp	80008142 <_vfprintf_r+0xf36>
800080b8:	fa f8 06 b4 	ld.w	r8,sp[1716]
800080bc:	40 3c       	lddsp	r12,sp[0xc]
800080be:	58 0c       	cp.w	r12,0
800080c0:	c1 d0       	breq	800080fa <_vfprintf_r+0xeee>
800080c2:	10 36       	cp.w	r6,r8
800080c4:	c0 64       	brge	800080d0 <_vfprintf_r+0xec4>
800080c6:	fa cb f9 44 	sub	r11,sp,-1724
800080ca:	f6 06 00 36 	add	r6,r11,r6<<0x3
800080ce:	c1 f8       	rjmp	8000810c <_vfprintf_r+0xf00>
800080d0:	fa c8 f9 50 	sub	r8,sp,-1712
800080d4:	1a d8       	st.w	--sp,r8
800080d6:	fa c8 fa b8 	sub	r8,sp,-1352
800080da:	0c 9b       	mov	r11,r6
800080dc:	1a d8       	st.w	--sp,r8
800080de:	fa c8 fb b4 	sub	r8,sp,-1100
800080e2:	04 9a       	mov	r10,r2
800080e4:	1a d8       	st.w	--sp,r8
800080e6:	08 9c       	mov	r12,r4
800080e8:	fa c8 f9 40 	sub	r8,sp,-1728
800080ec:	fa c9 ff b4 	sub	r9,sp,-76
800080f0:	fe b0 f6 f6 	rcall	80006edc <get_arg>
800080f4:	2f dd       	sub	sp,-12
800080f6:	78 0b       	ld.w	r11,r12[0x0]
800080f8:	c2 48       	rjmp	80008140 <_vfprintf_r+0xf34>
800080fa:	ee ca ff ff 	sub	r10,r7,-1
800080fe:	10 37       	cp.w	r7,r8
80008100:	c0 94       	brge	80008112 <_vfprintf_r+0xf06>
80008102:	fa c9 f9 44 	sub	r9,sp,-1724
80008106:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000810a:	14 97       	mov	r7,r10
8000810c:	ec fb fd 88 	ld.w	r11,r6[-632]
80008110:	c1 88       	rjmp	80008140 <_vfprintf_r+0xf34>
80008112:	41 09       	lddsp	r9,sp[0x40]
80008114:	59 f8       	cp.w	r8,31
80008116:	e0 89 00 11 	brgt	80008138 <_vfprintf_r+0xf2c>
8000811a:	f2 cb ff fc 	sub	r11,r9,-4
8000811e:	51 0b       	stdsp	sp[0x40],r11
80008120:	fa c6 f9 44 	sub	r6,sp,-1724
80008124:	72 0b       	ld.w	r11,r9[0x0]
80008126:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000812a:	f3 4b fd 88 	st.w	r9[-632],r11
8000812e:	2f f8       	sub	r8,-1
80008130:	14 97       	mov	r7,r10
80008132:	fb 48 06 b4 	st.w	sp[1716],r8
80008136:	c0 58       	rjmp	80008140 <_vfprintf_r+0xf34>
80008138:	72 0b       	ld.w	r11,r9[0x0]
8000813a:	14 97       	mov	r7,r10
8000813c:	2f c9       	sub	r9,-4
8000813e:	51 09       	stdsp	sp[0x40],r9
80008140:	50 1b       	stdsp	sp[0x4],r11
80008142:	30 0e       	mov	lr,0
80008144:	50 0e       	stdsp	sp[0x0],lr
80008146:	1c 98       	mov	r8,lr
80008148:	e0 8f 02 fe 	bral	80008744 <_vfprintf_r+0x1538>
8000814c:	50 a7       	stdsp	sp[0x28],r7
8000814e:	50 80       	stdsp	sp[0x20],r0
80008150:	0c 97       	mov	r7,r6
80008152:	04 94       	mov	r4,r2
80008154:	06 96       	mov	r6,r3
80008156:	02 92       	mov	r2,r1
80008158:	40 93       	lddsp	r3,sp[0x24]
8000815a:	40 41       	lddsp	r1,sp[0x10]
8000815c:	0e 99       	mov	r9,r7
8000815e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008162:	40 3c       	lddsp	r12,sp[0xc]
80008164:	58 0c       	cp.w	r12,0
80008166:	c1 d0       	breq	800081a0 <_vfprintf_r+0xf94>
80008168:	10 36       	cp.w	r6,r8
8000816a:	c0 64       	brge	80008176 <_vfprintf_r+0xf6a>
8000816c:	fa cb f9 44 	sub	r11,sp,-1724
80008170:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008174:	c1 d8       	rjmp	800081ae <_vfprintf_r+0xfa2>
80008176:	fa c8 f9 50 	sub	r8,sp,-1712
8000817a:	1a d8       	st.w	--sp,r8
8000817c:	fa c8 fa b8 	sub	r8,sp,-1352
80008180:	1a d8       	st.w	--sp,r8
80008182:	fa c8 fb b4 	sub	r8,sp,-1100
80008186:	1a d8       	st.w	--sp,r8
80008188:	fa c9 ff b4 	sub	r9,sp,-76
8000818c:	fa c8 f9 40 	sub	r8,sp,-1728
80008190:	04 9a       	mov	r10,r2
80008192:	0c 9b       	mov	r11,r6
80008194:	08 9c       	mov	r12,r4
80008196:	fe b0 f6 a3 	rcall	80006edc <get_arg>
8000819a:	2f dd       	sub	sp,-12
8000819c:	78 09       	ld.w	r9,r12[0x0]
8000819e:	c2 18       	rjmp	800081e0 <_vfprintf_r+0xfd4>
800081a0:	2f f7       	sub	r7,-1
800081a2:	10 39       	cp.w	r9,r8
800081a4:	c0 84       	brge	800081b4 <_vfprintf_r+0xfa8>
800081a6:	fa ca f9 44 	sub	r10,sp,-1724
800081aa:	f4 06 00 36 	add	r6,r10,r6<<0x3
800081ae:	ec f9 fd 88 	ld.w	r9,r6[-632]
800081b2:	c1 78       	rjmp	800081e0 <_vfprintf_r+0xfd4>
800081b4:	41 09       	lddsp	r9,sp[0x40]
800081b6:	59 f8       	cp.w	r8,31
800081b8:	e0 89 00 10 	brgt	800081d8 <_vfprintf_r+0xfcc>
800081bc:	f2 ca ff fc 	sub	r10,r9,-4
800081c0:	51 0a       	stdsp	sp[0x40],r10
800081c2:	fa c6 f9 44 	sub	r6,sp,-1724
800081c6:	72 09       	ld.w	r9,r9[0x0]
800081c8:	ec 08 00 3a 	add	r10,r6,r8<<0x3
800081cc:	f5 49 fd 88 	st.w	r10[-632],r9
800081d0:	2f f8       	sub	r8,-1
800081d2:	fb 48 06 b4 	st.w	sp[1716],r8
800081d6:	c0 58       	rjmp	800081e0 <_vfprintf_r+0xfd4>
800081d8:	f2 c8 ff fc 	sub	r8,r9,-4
800081dc:	51 08       	stdsp	sp[0x40],r8
800081de:	72 09       	ld.w	r9,r9[0x0]
800081e0:	33 08       	mov	r8,48
800081e2:	fb 68 06 b8 	st.b	sp[1720],r8
800081e6:	37 88       	mov	r8,120
800081e8:	30 0e       	mov	lr,0
800081ea:	fb 68 06 b9 	st.b	sp[1721],r8
800081ee:	fe cc b3 c2 	sub	r12,pc,-19518
800081f2:	50 19       	stdsp	sp[0x4],r9
800081f4:	a1 b5       	sbr	r5,0x1
800081f6:	50 0e       	stdsp	sp[0x0],lr
800081f8:	50 dc       	stdsp	sp[0x34],r12
800081fa:	30 28       	mov	r8,2
800081fc:	37 80       	mov	r0,120
800081fe:	e0 8f 02 a3 	bral	80008744 <_vfprintf_r+0x1538>
80008202:	50 a7       	stdsp	sp[0x28],r7
80008204:	50 80       	stdsp	sp[0x20],r0
80008206:	10 90       	mov	r0,r8
80008208:	30 08       	mov	r8,0
8000820a:	fb 68 06 bb 	st.b	sp[1723],r8
8000820e:	0c 97       	mov	r7,r6
80008210:	04 94       	mov	r4,r2
80008212:	06 96       	mov	r6,r3
80008214:	02 92       	mov	r2,r1
80008216:	40 93       	lddsp	r3,sp[0x24]
80008218:	40 41       	lddsp	r1,sp[0x10]
8000821a:	0e 99       	mov	r9,r7
8000821c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008220:	40 3b       	lddsp	r11,sp[0xc]
80008222:	58 0b       	cp.w	r11,0
80008224:	c1 d0       	breq	8000825e <_vfprintf_r+0x1052>
80008226:	10 36       	cp.w	r6,r8
80008228:	c0 64       	brge	80008234 <_vfprintf_r+0x1028>
8000822a:	fa ca f9 44 	sub	r10,sp,-1724
8000822e:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008232:	c1 d8       	rjmp	8000826c <_vfprintf_r+0x1060>
80008234:	fa c8 f9 50 	sub	r8,sp,-1712
80008238:	1a d8       	st.w	--sp,r8
8000823a:	fa c8 fa b8 	sub	r8,sp,-1352
8000823e:	1a d8       	st.w	--sp,r8
80008240:	fa c8 fb b4 	sub	r8,sp,-1100
80008244:	0c 9b       	mov	r11,r6
80008246:	1a d8       	st.w	--sp,r8
80008248:	04 9a       	mov	r10,r2
8000824a:	fa c8 f9 40 	sub	r8,sp,-1728
8000824e:	fa c9 ff b4 	sub	r9,sp,-76
80008252:	08 9c       	mov	r12,r4
80008254:	fe b0 f6 44 	rcall	80006edc <get_arg>
80008258:	2f dd       	sub	sp,-12
8000825a:	78 06       	ld.w	r6,r12[0x0]
8000825c:	c2 08       	rjmp	8000829c <_vfprintf_r+0x1090>
8000825e:	2f f7       	sub	r7,-1
80008260:	10 39       	cp.w	r9,r8
80008262:	c0 84       	brge	80008272 <_vfprintf_r+0x1066>
80008264:	fa c9 f9 44 	sub	r9,sp,-1724
80008268:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000826c:	ec f6 fd 88 	ld.w	r6,r6[-632]
80008270:	c1 68       	rjmp	8000829c <_vfprintf_r+0x1090>
80008272:	41 09       	lddsp	r9,sp[0x40]
80008274:	59 f8       	cp.w	r8,31
80008276:	e0 89 00 10 	brgt	80008296 <_vfprintf_r+0x108a>
8000827a:	f2 ca ff fc 	sub	r10,r9,-4
8000827e:	51 0a       	stdsp	sp[0x40],r10
80008280:	72 06       	ld.w	r6,r9[0x0]
80008282:	fa ce f9 44 	sub	lr,sp,-1724
80008286:	fc 08 00 39 	add	r9,lr,r8<<0x3
8000828a:	f3 46 fd 88 	st.w	r9[-632],r6
8000828e:	2f f8       	sub	r8,-1
80008290:	fb 48 06 b4 	st.w	sp[1716],r8
80008294:	c0 48       	rjmp	8000829c <_vfprintf_r+0x1090>
80008296:	72 06       	ld.w	r6,r9[0x0]
80008298:	2f c9       	sub	r9,-4
8000829a:	51 09       	stdsp	sp[0x40],r9
8000829c:	40 2c       	lddsp	r12,sp[0x8]
8000829e:	58 0c       	cp.w	r12,0
800082a0:	c1 05       	brlt	800082c0 <_vfprintf_r+0x10b4>
800082a2:	18 9a       	mov	r10,r12
800082a4:	30 0b       	mov	r11,0
800082a6:	0c 9c       	mov	r12,r6
800082a8:	e0 a0 12 38 	rcall	8000a718 <memchr>
800082ac:	e0 80 02 df 	breq	8000886a <_vfprintf_r+0x165e>
800082b0:	f8 06 01 02 	sub	r2,r12,r6
800082b4:	40 2b       	lddsp	r11,sp[0x8]
800082b6:	16 32       	cp.w	r2,r11
800082b8:	e0 89 02 d9 	brgt	8000886a <_vfprintf_r+0x165e>
800082bc:	e0 8f 02 d4 	bral	80008864 <_vfprintf_r+0x1658>
800082c0:	30 0a       	mov	r10,0
800082c2:	0c 9c       	mov	r12,r6
800082c4:	50 2a       	stdsp	sp[0x8],r10
800082c6:	fe b0 f5 85 	rcall	80006dd0 <strlen>
800082ca:	18 92       	mov	r2,r12
800082cc:	e0 8f 02 d2 	bral	80008870 <_vfprintf_r+0x1664>
800082d0:	50 a7       	stdsp	sp[0x28],r7
800082d2:	50 80       	stdsp	sp[0x20],r0
800082d4:	0c 97       	mov	r7,r6
800082d6:	04 94       	mov	r4,r2
800082d8:	06 96       	mov	r6,r3
800082da:	02 92       	mov	r2,r1
800082dc:	40 93       	lddsp	r3,sp[0x24]
800082de:	10 90       	mov	r0,r8
800082e0:	40 41       	lddsp	r1,sp[0x10]
800082e2:	a5 a5       	sbr	r5,0x4
800082e4:	c0 a8       	rjmp	800082f8 <_vfprintf_r+0x10ec>
800082e6:	50 a7       	stdsp	sp[0x28],r7
800082e8:	50 80       	stdsp	sp[0x20],r0
800082ea:	0c 97       	mov	r7,r6
800082ec:	04 94       	mov	r4,r2
800082ee:	06 96       	mov	r6,r3
800082f0:	02 92       	mov	r2,r1
800082f2:	40 93       	lddsp	r3,sp[0x24]
800082f4:	10 90       	mov	r0,r8
800082f6:	40 41       	lddsp	r1,sp[0x10]
800082f8:	ed b5 00 05 	bld	r5,0x5
800082fc:	c5 61       	brne	800083a8 <_vfprintf_r+0x119c>
800082fe:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008302:	40 39       	lddsp	r9,sp[0xc]
80008304:	58 09       	cp.w	r9,0
80008306:	c2 10       	breq	80008348 <_vfprintf_r+0x113c>
80008308:	10 36       	cp.w	r6,r8
8000830a:	c0 74       	brge	80008318 <_vfprintf_r+0x110c>
8000830c:	fa c8 f9 44 	sub	r8,sp,-1724
80008310:	f0 06 00 36 	add	r6,r8,r6<<0x3
80008314:	c2 38       	rjmp	8000835a <_vfprintf_r+0x114e>
80008316:	d7 03       	nop
80008318:	fa c8 f9 50 	sub	r8,sp,-1712
8000831c:	1a d8       	st.w	--sp,r8
8000831e:	fa c8 fa b8 	sub	r8,sp,-1352
80008322:	1a d8       	st.w	--sp,r8
80008324:	fa c8 fb b4 	sub	r8,sp,-1100
80008328:	1a d8       	st.w	--sp,r8
8000832a:	fa c8 f9 40 	sub	r8,sp,-1728
8000832e:	fa c9 ff b4 	sub	r9,sp,-76
80008332:	04 9a       	mov	r10,r2
80008334:	0c 9b       	mov	r11,r6
80008336:	08 9c       	mov	r12,r4
80008338:	fe b0 f5 d2 	rcall	80006edc <get_arg>
8000833c:	2f dd       	sub	sp,-12
8000833e:	f8 e8 00 00 	ld.d	r8,r12[0]
80008342:	fa e9 00 00 	st.d	sp[0],r8
80008346:	c2 e8       	rjmp	800083a2 <_vfprintf_r+0x1196>
80008348:	ee ca ff ff 	sub	r10,r7,-1
8000834c:	10 37       	cp.w	r7,r8
8000834e:	c0 b4       	brge	80008364 <_vfprintf_r+0x1158>
80008350:	fa c8 f9 44 	sub	r8,sp,-1724
80008354:	14 97       	mov	r7,r10
80008356:	f0 06 00 36 	add	r6,r8,r6<<0x3
8000835a:	ec ea fd 88 	ld.d	r10,r6[-632]
8000835e:	fa eb 00 00 	st.d	sp[0],r10
80008362:	c2 08       	rjmp	800083a2 <_vfprintf_r+0x1196>
80008364:	41 09       	lddsp	r9,sp[0x40]
80008366:	59 f8       	cp.w	r8,31
80008368:	e0 89 00 16 	brgt	80008394 <_vfprintf_r+0x1188>
8000836c:	f2 e6 00 00 	ld.d	r6,r9[0]
80008370:	f2 cb ff f8 	sub	r11,r9,-8
80008374:	fa e7 00 00 	st.d	sp[0],r6
80008378:	51 0b       	stdsp	sp[0x40],r11
8000837a:	fa c6 f9 44 	sub	r6,sp,-1724
8000837e:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008382:	fa e6 00 00 	ld.d	r6,sp[0]
80008386:	f2 e7 fd 88 	st.d	r9[-632],r6
8000838a:	2f f8       	sub	r8,-1
8000838c:	14 97       	mov	r7,r10
8000838e:	fb 48 06 b4 	st.w	sp[1716],r8
80008392:	c0 88       	rjmp	800083a2 <_vfprintf_r+0x1196>
80008394:	f2 e6 00 00 	ld.d	r6,r9[0]
80008398:	2f 89       	sub	r9,-8
8000839a:	fa e7 00 00 	st.d	sp[0],r6
8000839e:	51 09       	stdsp	sp[0x40],r9
800083a0:	14 97       	mov	r7,r10
800083a2:	30 18       	mov	r8,1
800083a4:	e0 8f 01 d0 	bral	80008744 <_vfprintf_r+0x1538>
800083a8:	ed b5 00 04 	bld	r5,0x4
800083ac:	c1 61       	brne	800083d8 <_vfprintf_r+0x11cc>
800083ae:	fa f8 06 b4 	ld.w	r8,sp[1716]
800083b2:	40 3e       	lddsp	lr,sp[0xc]
800083b4:	58 0e       	cp.w	lr,0
800083b6:	c0 80       	breq	800083c6 <_vfprintf_r+0x11ba>
800083b8:	10 36       	cp.w	r6,r8
800083ba:	c6 74       	brge	80008488 <_vfprintf_r+0x127c>
800083bc:	fa cc f9 44 	sub	r12,sp,-1724
800083c0:	f8 06 00 36 	add	r6,r12,r6<<0x3
800083c4:	c8 08       	rjmp	800084c4 <_vfprintf_r+0x12b8>
800083c6:	ee ca ff ff 	sub	r10,r7,-1
800083ca:	10 37       	cp.w	r7,r8
800083cc:	c7 f4       	brge	800084ca <_vfprintf_r+0x12be>
800083ce:	fa cb f9 44 	sub	r11,sp,-1724
800083d2:	f6 06 00 36 	add	r6,r11,r6<<0x3
800083d6:	c7 68       	rjmp	800084c2 <_vfprintf_r+0x12b6>
800083d8:	ed b5 00 06 	bld	r5,0x6
800083dc:	c4 a1       	brne	80008470 <_vfprintf_r+0x1264>
800083de:	fa f8 06 b4 	ld.w	r8,sp[1716]
800083e2:	40 3c       	lddsp	r12,sp[0xc]
800083e4:	58 0c       	cp.w	r12,0
800083e6:	c1 d0       	breq	80008420 <_vfprintf_r+0x1214>
800083e8:	10 36       	cp.w	r6,r8
800083ea:	c0 64       	brge	800083f6 <_vfprintf_r+0x11ea>
800083ec:	fa cb f9 44 	sub	r11,sp,-1724
800083f0:	f6 06 00 36 	add	r6,r11,r6<<0x3
800083f4:	c1 f8       	rjmp	80008432 <_vfprintf_r+0x1226>
800083f6:	fa c8 f9 50 	sub	r8,sp,-1712
800083fa:	1a d8       	st.w	--sp,r8
800083fc:	fa c8 fa b8 	sub	r8,sp,-1352
80008400:	1a d8       	st.w	--sp,r8
80008402:	fa c8 fb b4 	sub	r8,sp,-1100
80008406:	1a d8       	st.w	--sp,r8
80008408:	fa c8 f9 40 	sub	r8,sp,-1728
8000840c:	fa c9 ff b4 	sub	r9,sp,-76
80008410:	04 9a       	mov	r10,r2
80008412:	0c 9b       	mov	r11,r6
80008414:	08 9c       	mov	r12,r4
80008416:	fe b0 f5 63 	rcall	80006edc <get_arg>
8000841a:	2f dd       	sub	sp,-12
8000841c:	98 18       	ld.sh	r8,r12[0x2]
8000841e:	c2 68       	rjmp	8000846a <_vfprintf_r+0x125e>
80008420:	ee ca ff ff 	sub	r10,r7,-1
80008424:	10 37       	cp.w	r7,r8
80008426:	c0 94       	brge	80008438 <_vfprintf_r+0x122c>
80008428:	fa c9 f9 44 	sub	r9,sp,-1724
8000842c:	14 97       	mov	r7,r10
8000842e:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008432:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80008436:	c1 a8       	rjmp	8000846a <_vfprintf_r+0x125e>
80008438:	41 09       	lddsp	r9,sp[0x40]
8000843a:	59 f8       	cp.w	r8,31
8000843c:	e0 89 00 13 	brgt	80008462 <_vfprintf_r+0x1256>
80008440:	f2 cb ff fc 	sub	r11,r9,-4
80008444:	51 0b       	stdsp	sp[0x40],r11
80008446:	72 09       	ld.w	r9,r9[0x0]
80008448:	fa c6 f9 44 	sub	r6,sp,-1724
8000844c:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008450:	2f f8       	sub	r8,-1
80008452:	f7 49 fd 88 	st.w	r11[-632],r9
80008456:	fb 48 06 b4 	st.w	sp[1716],r8
8000845a:	14 97       	mov	r7,r10
8000845c:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008460:	c0 58       	rjmp	8000846a <_vfprintf_r+0x125e>
80008462:	92 18       	ld.sh	r8,r9[0x2]
80008464:	14 97       	mov	r7,r10
80008466:	2f c9       	sub	r9,-4
80008468:	51 09       	stdsp	sp[0x40],r9
8000846a:	5c 78       	castu.h	r8
8000846c:	50 18       	stdsp	sp[0x4],r8
8000846e:	c4 68       	rjmp	800084fa <_vfprintf_r+0x12ee>
80008470:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008474:	40 3c       	lddsp	r12,sp[0xc]
80008476:	58 0c       	cp.w	r12,0
80008478:	c1 d0       	breq	800084b2 <_vfprintf_r+0x12a6>
8000847a:	10 36       	cp.w	r6,r8
8000847c:	c0 64       	brge	80008488 <_vfprintf_r+0x127c>
8000847e:	fa cb f9 44 	sub	r11,sp,-1724
80008482:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008486:	c1 f8       	rjmp	800084c4 <_vfprintf_r+0x12b8>
80008488:	fa c8 f9 50 	sub	r8,sp,-1712
8000848c:	1a d8       	st.w	--sp,r8
8000848e:	fa c8 fa b8 	sub	r8,sp,-1352
80008492:	0c 9b       	mov	r11,r6
80008494:	1a d8       	st.w	--sp,r8
80008496:	fa c8 fb b4 	sub	r8,sp,-1100
8000849a:	04 9a       	mov	r10,r2
8000849c:	1a d8       	st.w	--sp,r8
8000849e:	08 9c       	mov	r12,r4
800084a0:	fa c8 f9 40 	sub	r8,sp,-1728
800084a4:	fa c9 ff b4 	sub	r9,sp,-76
800084a8:	fe b0 f5 1a 	rcall	80006edc <get_arg>
800084ac:	2f dd       	sub	sp,-12
800084ae:	78 0b       	ld.w	r11,r12[0x0]
800084b0:	c2 48       	rjmp	800084f8 <_vfprintf_r+0x12ec>
800084b2:	ee ca ff ff 	sub	r10,r7,-1
800084b6:	10 37       	cp.w	r7,r8
800084b8:	c0 94       	brge	800084ca <_vfprintf_r+0x12be>
800084ba:	fa c9 f9 44 	sub	r9,sp,-1724
800084be:	f2 06 00 36 	add	r6,r9,r6<<0x3
800084c2:	14 97       	mov	r7,r10
800084c4:	ec fb fd 88 	ld.w	r11,r6[-632]
800084c8:	c1 88       	rjmp	800084f8 <_vfprintf_r+0x12ec>
800084ca:	41 09       	lddsp	r9,sp[0x40]
800084cc:	59 f8       	cp.w	r8,31
800084ce:	e0 89 00 11 	brgt	800084f0 <_vfprintf_r+0x12e4>
800084d2:	f2 cb ff fc 	sub	r11,r9,-4
800084d6:	51 0b       	stdsp	sp[0x40],r11
800084d8:	fa c6 f9 44 	sub	r6,sp,-1724
800084dc:	72 0b       	ld.w	r11,r9[0x0]
800084de:	ec 08 00 39 	add	r9,r6,r8<<0x3
800084e2:	f3 4b fd 88 	st.w	r9[-632],r11
800084e6:	2f f8       	sub	r8,-1
800084e8:	14 97       	mov	r7,r10
800084ea:	fb 48 06 b4 	st.w	sp[1716],r8
800084ee:	c0 58       	rjmp	800084f8 <_vfprintf_r+0x12ec>
800084f0:	72 0b       	ld.w	r11,r9[0x0]
800084f2:	14 97       	mov	r7,r10
800084f4:	2f c9       	sub	r9,-4
800084f6:	51 09       	stdsp	sp[0x40],r9
800084f8:	50 1b       	stdsp	sp[0x4],r11
800084fa:	30 0e       	mov	lr,0
800084fc:	30 18       	mov	r8,1
800084fe:	50 0e       	stdsp	sp[0x0],lr
80008500:	c2 29       	rjmp	80008744 <_vfprintf_r+0x1538>
80008502:	50 a7       	stdsp	sp[0x28],r7
80008504:	50 80       	stdsp	sp[0x20],r0
80008506:	0c 97       	mov	r7,r6
80008508:	04 94       	mov	r4,r2
8000850a:	06 96       	mov	r6,r3
8000850c:	02 92       	mov	r2,r1
8000850e:	fe cc b6 e2 	sub	r12,pc,-18718
80008512:	40 93       	lddsp	r3,sp[0x24]
80008514:	10 90       	mov	r0,r8
80008516:	40 41       	lddsp	r1,sp[0x10]
80008518:	50 dc       	stdsp	sp[0x34],r12
8000851a:	ed b5 00 05 	bld	r5,0x5
8000851e:	c5 51       	brne	800085c8 <_vfprintf_r+0x13bc>
80008520:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008524:	40 3b       	lddsp	r11,sp[0xc]
80008526:	58 0b       	cp.w	r11,0
80008528:	c2 20       	breq	8000856c <_vfprintf_r+0x1360>
8000852a:	10 36       	cp.w	r6,r8
8000852c:	c0 a4       	brge	80008540 <_vfprintf_r+0x1334>
8000852e:	fa ca f9 44 	sub	r10,sp,-1724
80008532:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008536:	ec e8 fd 88 	ld.d	r8,r6[-632]
8000853a:	fa e9 00 00 	st.d	sp[0],r8
8000853e:	cf 28       	rjmp	80008722 <_vfprintf_r+0x1516>
80008540:	fa c8 f9 50 	sub	r8,sp,-1712
80008544:	1a d8       	st.w	--sp,r8
80008546:	fa c8 fa b8 	sub	r8,sp,-1352
8000854a:	04 9a       	mov	r10,r2
8000854c:	1a d8       	st.w	--sp,r8
8000854e:	0c 9b       	mov	r11,r6
80008550:	fa c8 fb b4 	sub	r8,sp,-1100
80008554:	08 9c       	mov	r12,r4
80008556:	1a d8       	st.w	--sp,r8
80008558:	fa c8 f9 40 	sub	r8,sp,-1728
8000855c:	fa c9 ff b4 	sub	r9,sp,-76
80008560:	fe b0 f4 be 	rcall	80006edc <get_arg>
80008564:	2f dd       	sub	sp,-12
80008566:	f8 ea 00 00 	ld.d	r10,r12[0]
8000856a:	c0 c8       	rjmp	80008582 <_vfprintf_r+0x1376>
8000856c:	ee ca ff ff 	sub	r10,r7,-1
80008570:	10 37       	cp.w	r7,r8
80008572:	c0 b4       	brge	80008588 <_vfprintf_r+0x137c>
80008574:	fa c9 f9 44 	sub	r9,sp,-1724
80008578:	14 97       	mov	r7,r10
8000857a:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000857e:	ec ea fd 88 	ld.d	r10,r6[-632]
80008582:	fa eb 00 00 	st.d	sp[0],r10
80008586:	cc e8       	rjmp	80008722 <_vfprintf_r+0x1516>
80008588:	41 09       	lddsp	r9,sp[0x40]
8000858a:	59 f8       	cp.w	r8,31
8000858c:	e0 89 00 16 	brgt	800085b8 <_vfprintf_r+0x13ac>
80008590:	f2 e6 00 00 	ld.d	r6,r9[0]
80008594:	f2 cb ff f8 	sub	r11,r9,-8
80008598:	fa e7 00 00 	st.d	sp[0],r6
8000859c:	51 0b       	stdsp	sp[0x40],r11
8000859e:	fa c6 f9 44 	sub	r6,sp,-1724
800085a2:	ec 08 00 39 	add	r9,r6,r8<<0x3
800085a6:	fa e6 00 00 	ld.d	r6,sp[0]
800085aa:	f2 e7 fd 88 	st.d	r9[-632],r6
800085ae:	2f f8       	sub	r8,-1
800085b0:	14 97       	mov	r7,r10
800085b2:	fb 48 06 b4 	st.w	sp[1716],r8
800085b6:	cb 68       	rjmp	80008722 <_vfprintf_r+0x1516>
800085b8:	f2 e6 00 00 	ld.d	r6,r9[0]
800085bc:	2f 89       	sub	r9,-8
800085be:	fa e7 00 00 	st.d	sp[0],r6
800085c2:	51 09       	stdsp	sp[0x40],r9
800085c4:	14 97       	mov	r7,r10
800085c6:	ca e8       	rjmp	80008722 <_vfprintf_r+0x1516>
800085c8:	ed b5 00 04 	bld	r5,0x4
800085cc:	c1 71       	brne	800085fa <_vfprintf_r+0x13ee>
800085ce:	fa f8 06 b4 	ld.w	r8,sp[1716]
800085d2:	40 3e       	lddsp	lr,sp[0xc]
800085d4:	58 0e       	cp.w	lr,0
800085d6:	c0 80       	breq	800085e6 <_vfprintf_r+0x13da>
800085d8:	10 36       	cp.w	r6,r8
800085da:	c6 94       	brge	800086ac <_vfprintf_r+0x14a0>
800085dc:	fa cc f9 44 	sub	r12,sp,-1724
800085e0:	f8 06 00 36 	add	r6,r12,r6<<0x3
800085e4:	c8 28       	rjmp	800086e8 <_vfprintf_r+0x14dc>
800085e6:	ee ca ff ff 	sub	r10,r7,-1
800085ea:	10 37       	cp.w	r7,r8
800085ec:	e0 84 00 81 	brge	800086ee <_vfprintf_r+0x14e2>
800085f0:	fa cb f9 44 	sub	r11,sp,-1724
800085f4:	f6 06 00 36 	add	r6,r11,r6<<0x3
800085f8:	c7 78       	rjmp	800086e6 <_vfprintf_r+0x14da>
800085fa:	ed b5 00 06 	bld	r5,0x6
800085fe:	c4 b1       	brne	80008694 <_vfprintf_r+0x1488>
80008600:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008604:	40 3c       	lddsp	r12,sp[0xc]
80008606:	58 0c       	cp.w	r12,0
80008608:	c1 d0       	breq	80008642 <_vfprintf_r+0x1436>
8000860a:	10 36       	cp.w	r6,r8
8000860c:	c0 64       	brge	80008618 <_vfprintf_r+0x140c>
8000860e:	fa cb f9 44 	sub	r11,sp,-1724
80008612:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008616:	c1 f8       	rjmp	80008654 <_vfprintf_r+0x1448>
80008618:	fa c8 f9 50 	sub	r8,sp,-1712
8000861c:	1a d8       	st.w	--sp,r8
8000861e:	fa c8 fa b8 	sub	r8,sp,-1352
80008622:	1a d8       	st.w	--sp,r8
80008624:	fa c8 fb b4 	sub	r8,sp,-1100
80008628:	1a d8       	st.w	--sp,r8
8000862a:	fa c8 f9 40 	sub	r8,sp,-1728
8000862e:	fa c9 ff b4 	sub	r9,sp,-76
80008632:	04 9a       	mov	r10,r2
80008634:	0c 9b       	mov	r11,r6
80008636:	08 9c       	mov	r12,r4
80008638:	fe b0 f4 52 	rcall	80006edc <get_arg>
8000863c:	2f dd       	sub	sp,-12
8000863e:	98 18       	ld.sh	r8,r12[0x2]
80008640:	c2 78       	rjmp	8000868e <_vfprintf_r+0x1482>
80008642:	ee ca ff ff 	sub	r10,r7,-1
80008646:	10 37       	cp.w	r7,r8
80008648:	c0 a4       	brge	8000865c <_vfprintf_r+0x1450>
8000864a:	fa c9 f9 44 	sub	r9,sp,-1724
8000864e:	14 97       	mov	r7,r10
80008650:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008654:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80008658:	c1 b8       	rjmp	8000868e <_vfprintf_r+0x1482>
8000865a:	d7 03       	nop
8000865c:	41 09       	lddsp	r9,sp[0x40]
8000865e:	59 f8       	cp.w	r8,31
80008660:	e0 89 00 13 	brgt	80008686 <_vfprintf_r+0x147a>
80008664:	f2 cb ff fc 	sub	r11,r9,-4
80008668:	51 0b       	stdsp	sp[0x40],r11
8000866a:	72 09       	ld.w	r9,r9[0x0]
8000866c:	fa c6 f9 44 	sub	r6,sp,-1724
80008670:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008674:	2f f8       	sub	r8,-1
80008676:	f7 49 fd 88 	st.w	r11[-632],r9
8000867a:	fb 48 06 b4 	st.w	sp[1716],r8
8000867e:	14 97       	mov	r7,r10
80008680:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008684:	c0 58       	rjmp	8000868e <_vfprintf_r+0x1482>
80008686:	92 18       	ld.sh	r8,r9[0x2]
80008688:	14 97       	mov	r7,r10
8000868a:	2f c9       	sub	r9,-4
8000868c:	51 09       	stdsp	sp[0x40],r9
8000868e:	5c 78       	castu.h	r8
80008690:	50 18       	stdsp	sp[0x4],r8
80008692:	c4 68       	rjmp	8000871e <_vfprintf_r+0x1512>
80008694:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008698:	40 3c       	lddsp	r12,sp[0xc]
8000869a:	58 0c       	cp.w	r12,0
8000869c:	c1 d0       	breq	800086d6 <_vfprintf_r+0x14ca>
8000869e:	10 36       	cp.w	r6,r8
800086a0:	c0 64       	brge	800086ac <_vfprintf_r+0x14a0>
800086a2:	fa cb f9 44 	sub	r11,sp,-1724
800086a6:	f6 06 00 36 	add	r6,r11,r6<<0x3
800086aa:	c1 f8       	rjmp	800086e8 <_vfprintf_r+0x14dc>
800086ac:	fa c8 f9 50 	sub	r8,sp,-1712
800086b0:	1a d8       	st.w	--sp,r8
800086b2:	fa c8 fa b8 	sub	r8,sp,-1352
800086b6:	0c 9b       	mov	r11,r6
800086b8:	1a d8       	st.w	--sp,r8
800086ba:	fa c8 fb b4 	sub	r8,sp,-1100
800086be:	04 9a       	mov	r10,r2
800086c0:	1a d8       	st.w	--sp,r8
800086c2:	08 9c       	mov	r12,r4
800086c4:	fa c8 f9 40 	sub	r8,sp,-1728
800086c8:	fa c9 ff b4 	sub	r9,sp,-76
800086cc:	fe b0 f4 08 	rcall	80006edc <get_arg>
800086d0:	2f dd       	sub	sp,-12
800086d2:	78 0b       	ld.w	r11,r12[0x0]
800086d4:	c2 48       	rjmp	8000871c <_vfprintf_r+0x1510>
800086d6:	ee ca ff ff 	sub	r10,r7,-1
800086da:	10 37       	cp.w	r7,r8
800086dc:	c0 94       	brge	800086ee <_vfprintf_r+0x14e2>
800086de:	fa c9 f9 44 	sub	r9,sp,-1724
800086e2:	f2 06 00 36 	add	r6,r9,r6<<0x3
800086e6:	14 97       	mov	r7,r10
800086e8:	ec fb fd 88 	ld.w	r11,r6[-632]
800086ec:	c1 88       	rjmp	8000871c <_vfprintf_r+0x1510>
800086ee:	41 09       	lddsp	r9,sp[0x40]
800086f0:	59 f8       	cp.w	r8,31
800086f2:	e0 89 00 11 	brgt	80008714 <_vfprintf_r+0x1508>
800086f6:	f2 cb ff fc 	sub	r11,r9,-4
800086fa:	51 0b       	stdsp	sp[0x40],r11
800086fc:	fa c6 f9 44 	sub	r6,sp,-1724
80008700:	72 0b       	ld.w	r11,r9[0x0]
80008702:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008706:	f3 4b fd 88 	st.w	r9[-632],r11
8000870a:	2f f8       	sub	r8,-1
8000870c:	14 97       	mov	r7,r10
8000870e:	fb 48 06 b4 	st.w	sp[1716],r8
80008712:	c0 58       	rjmp	8000871c <_vfprintf_r+0x1510>
80008714:	72 0b       	ld.w	r11,r9[0x0]
80008716:	14 97       	mov	r7,r10
80008718:	2f c9       	sub	r9,-4
8000871a:	51 09       	stdsp	sp[0x40],r9
8000871c:	50 1b       	stdsp	sp[0x4],r11
8000871e:	30 0e       	mov	lr,0
80008720:	50 0e       	stdsp	sp[0x0],lr
80008722:	40 08       	lddsp	r8,sp[0x0]
80008724:	40 1c       	lddsp	r12,sp[0x4]
80008726:	18 48       	or	r8,r12
80008728:	5f 19       	srne	r9
8000872a:	0a 98       	mov	r8,r5
8000872c:	eb e9 00 09 	and	r9,r5,r9
80008730:	a1 b8       	sbr	r8,0x1
80008732:	58 09       	cp.w	r9,0
80008734:	c0 70       	breq	80008742 <_vfprintf_r+0x1536>
80008736:	10 95       	mov	r5,r8
80008738:	fb 60 06 b9 	st.b	sp[1721],r0
8000873c:	33 08       	mov	r8,48
8000873e:	fb 68 06 b8 	st.b	sp[1720],r8
80008742:	30 28       	mov	r8,2
80008744:	30 09       	mov	r9,0
80008746:	fb 69 06 bb 	st.b	sp[1723],r9
8000874a:	0a 99       	mov	r9,r5
8000874c:	a7 d9       	cbr	r9,0x7
8000874e:	40 2b       	lddsp	r11,sp[0x8]
80008750:	40 16       	lddsp	r6,sp[0x4]
80008752:	58 0b       	cp.w	r11,0
80008754:	5f 1a       	srne	r10
80008756:	f2 05 17 40 	movge	r5,r9
8000875a:	fa c2 f9 78 	sub	r2,sp,-1672
8000875e:	40 09       	lddsp	r9,sp[0x0]
80008760:	0c 49       	or	r9,r6
80008762:	5f 19       	srne	r9
80008764:	f5 e9 10 09 	or	r9,r10,r9
80008768:	c5 c0       	breq	80008820 <_vfprintf_r+0x1614>
8000876a:	30 19       	mov	r9,1
8000876c:	f2 08 18 00 	cp.b	r8,r9
80008770:	c0 60       	breq	8000877c <_vfprintf_r+0x1570>
80008772:	30 29       	mov	r9,2
80008774:	f2 08 18 00 	cp.b	r8,r9
80008778:	c0 41       	brne	80008780 <_vfprintf_r+0x1574>
8000877a:	c3 c8       	rjmp	800087f2 <_vfprintf_r+0x15e6>
8000877c:	04 96       	mov	r6,r2
8000877e:	c3 08       	rjmp	800087de <_vfprintf_r+0x15d2>
80008780:	04 96       	mov	r6,r2
80008782:	fa e8 00 00 	ld.d	r8,sp[0]
80008786:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
8000878a:	2d 0a       	sub	r10,-48
8000878c:	0c fa       	st.b	--r6,r10
8000878e:	f0 0b 16 03 	lsr	r11,r8,0x3
80008792:	f2 0c 16 03 	lsr	r12,r9,0x3
80008796:	f7 e9 11 db 	or	r11,r11,r9<<0x1d
8000879a:	18 99       	mov	r9,r12
8000879c:	16 98       	mov	r8,r11
8000879e:	58 08       	cp.w	r8,0
800087a0:	5c 29       	cpc	r9
800087a2:	cf 21       	brne	80008786 <_vfprintf_r+0x157a>
800087a4:	fa e9 00 00 	st.d	sp[0],r8
800087a8:	ed b5 00 00 	bld	r5,0x0
800087ac:	c4 51       	brne	80008836 <_vfprintf_r+0x162a>
800087ae:	33 09       	mov	r9,48
800087b0:	f2 0a 18 00 	cp.b	r10,r9
800087b4:	c4 10       	breq	80008836 <_vfprintf_r+0x162a>
800087b6:	0c f9       	st.b	--r6,r9
800087b8:	c3 f8       	rjmp	80008836 <_vfprintf_r+0x162a>
800087ba:	fa ea 00 00 	ld.d	r10,sp[0]
800087be:	30 a8       	mov	r8,10
800087c0:	30 09       	mov	r9,0
800087c2:	e0 a0 1a 0d 	rcall	8000bbdc <__avr32_umod64>
800087c6:	30 a8       	mov	r8,10
800087c8:	2d 0a       	sub	r10,-48
800087ca:	30 09       	mov	r9,0
800087cc:	ac 8a       	st.b	r6[0x0],r10
800087ce:	fa ea 00 00 	ld.d	r10,sp[0]
800087d2:	e0 a0 18 d3 	rcall	8000b978 <__avr32_udiv64>
800087d6:	16 99       	mov	r9,r11
800087d8:	14 98       	mov	r8,r10
800087da:	fa e9 00 00 	st.d	sp[0],r8
800087de:	20 16       	sub	r6,1
800087e0:	fa ea 00 00 	ld.d	r10,sp[0]
800087e4:	58 9a       	cp.w	r10,9
800087e6:	5c 2b       	cpc	r11
800087e8:	fe 9b ff e9 	brhi	800087ba <_vfprintf_r+0x15ae>
800087ec:	1b f8       	ld.ub	r8,sp[0x7]
800087ee:	2d 08       	sub	r8,-48
800087f0:	c2 08       	rjmp	80008830 <_vfprintf_r+0x1624>
800087f2:	04 96       	mov	r6,r2
800087f4:	fa e8 00 00 	ld.d	r8,sp[0]
800087f8:	f5 d8 c0 04 	bfextu	r10,r8,0x0,0x4
800087fc:	40 de       	lddsp	lr,sp[0x34]
800087fe:	fc 0a 07 0a 	ld.ub	r10,lr[r10]
80008802:	0c fa       	st.b	--r6,r10
80008804:	f2 0b 16 04 	lsr	r11,r9,0x4
80008808:	f0 0a 16 04 	lsr	r10,r8,0x4
8000880c:	f5 e9 11 ca 	or	r10,r10,r9<<0x1c
80008810:	16 99       	mov	r9,r11
80008812:	14 98       	mov	r8,r10
80008814:	58 08       	cp.w	r8,0
80008816:	5c 29       	cpc	r9
80008818:	cf 01       	brne	800087f8 <_vfprintf_r+0x15ec>
8000881a:	fa e9 00 00 	st.d	sp[0],r8
8000881e:	c0 c8       	rjmp	80008836 <_vfprintf_r+0x162a>
80008820:	58 08       	cp.w	r8,0
80008822:	c0 91       	brne	80008834 <_vfprintf_r+0x1628>
80008824:	ed b5 00 00 	bld	r5,0x0
80008828:	c0 61       	brne	80008834 <_vfprintf_r+0x1628>
8000882a:	fa c6 f9 79 	sub	r6,sp,-1671
8000882e:	33 08       	mov	r8,48
80008830:	ac 88       	st.b	r6[0x0],r8
80008832:	c0 28       	rjmp	80008836 <_vfprintf_r+0x162a>
80008834:	04 96       	mov	r6,r2
80008836:	0c 12       	sub	r2,r6
80008838:	c1 c8       	rjmp	80008870 <_vfprintf_r+0x1664>
8000883a:	50 a7       	stdsp	sp[0x28],r7
8000883c:	50 80       	stdsp	sp[0x20],r0
8000883e:	40 93       	lddsp	r3,sp[0x24]
80008840:	0c 97       	mov	r7,r6
80008842:	10 90       	mov	r0,r8
80008844:	04 94       	mov	r4,r2
80008846:	40 41       	lddsp	r1,sp[0x10]
80008848:	58 08       	cp.w	r8,0
8000884a:	e0 80 04 4f 	breq	800090e8 <_vfprintf_r+0x1edc>
8000884e:	fb 68 06 60 	st.b	sp[1632],r8
80008852:	30 0c       	mov	r12,0
80008854:	30 08       	mov	r8,0
80008856:	30 12       	mov	r2,1
80008858:	fb 68 06 bb 	st.b	sp[1723],r8
8000885c:	50 2c       	stdsp	sp[0x8],r12
8000885e:	fa c6 f9 a0 	sub	r6,sp,-1632
80008862:	c0 78       	rjmp	80008870 <_vfprintf_r+0x1664>
80008864:	30 0b       	mov	r11,0
80008866:	50 2b       	stdsp	sp[0x8],r11
80008868:	c0 48       	rjmp	80008870 <_vfprintf_r+0x1664>
8000886a:	40 22       	lddsp	r2,sp[0x8]
8000886c:	30 0a       	mov	r10,0
8000886e:	50 2a       	stdsp	sp[0x8],r10
80008870:	40 29       	lddsp	r9,sp[0x8]
80008872:	e4 09 0c 49 	max	r9,r2,r9
80008876:	fb 38 06 bb 	ld.ub	r8,sp[1723]
8000887a:	50 39       	stdsp	sp[0xc],r9
8000887c:	0a 9e       	mov	lr,r5
8000887e:	30 09       	mov	r9,0
80008880:	e2 1e 00 02 	andl	lr,0x2,COH
80008884:	f2 08 18 00 	cp.b	r8,r9
80008888:	fb f8 10 03 	ld.wne	r8,sp[0xc]
8000888c:	f7 b8 01 ff 	subne	r8,-1
80008890:	fb f8 1a 03 	st.wne	sp[0xc],r8
80008894:	0a 9b       	mov	r11,r5
80008896:	58 0e       	cp.w	lr,0
80008898:	fb fc 10 03 	ld.wne	r12,sp[0xc]
8000889c:	f7 bc 01 fe 	subne	r12,-2
800088a0:	fb fc 1a 03 	st.wne	sp[0xc],r12
800088a4:	e2 1b 00 84 	andl	r11,0x84,COH
800088a8:	50 fe       	stdsp	sp[0x3c],lr
800088aa:	50 9b       	stdsp	sp[0x24],r11
800088ac:	c4 71       	brne	8000893a <_vfprintf_r+0x172e>
800088ae:	40 8a       	lddsp	r10,sp[0x20]
800088b0:	40 39       	lddsp	r9,sp[0xc]
800088b2:	12 1a       	sub	r10,r9
800088b4:	50 4a       	stdsp	sp[0x10],r10
800088b6:	58 0a       	cp.w	r10,0
800088b8:	e0 89 00 20 	brgt	800088f8 <_vfprintf_r+0x16ec>
800088bc:	c3 f8       	rjmp	8000893a <_vfprintf_r+0x172e>
800088be:	2f 09       	sub	r9,-16
800088c0:	2f f8       	sub	r8,-1
800088c2:	fe ce ba 7e 	sub	lr,pc,-17794
800088c6:	31 0c       	mov	r12,16
800088c8:	fb 49 06 90 	st.w	sp[1680],r9
800088cc:	87 0e       	st.w	r3[0x0],lr
800088ce:	87 1c       	st.w	r3[0x4],r12
800088d0:	fb 48 06 8c 	st.w	sp[1676],r8
800088d4:	58 78       	cp.w	r8,7
800088d6:	e0 89 00 04 	brgt	800088de <_vfprintf_r+0x16d2>
800088da:	2f 83       	sub	r3,-8
800088dc:	c0 b8       	rjmp	800088f2 <_vfprintf_r+0x16e6>
800088de:	fa ca f9 78 	sub	r10,sp,-1672
800088e2:	02 9b       	mov	r11,r1
800088e4:	08 9c       	mov	r12,r4
800088e6:	fe b0 f4 85 	rcall	800071f0 <__sprint_r>
800088ea:	e0 81 04 10 	brne	8000910a <_vfprintf_r+0x1efe>
800088ee:	fa c3 f9 e0 	sub	r3,sp,-1568
800088f2:	40 4b       	lddsp	r11,sp[0x10]
800088f4:	21 0b       	sub	r11,16
800088f6:	50 4b       	stdsp	sp[0x10],r11
800088f8:	fa f9 06 90 	ld.w	r9,sp[1680]
800088fc:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008900:	fe ca ba bc 	sub	r10,pc,-17732
80008904:	40 4e       	lddsp	lr,sp[0x10]
80008906:	59 0e       	cp.w	lr,16
80008908:	fe 99 ff db 	brgt	800088be <_vfprintf_r+0x16b2>
8000890c:	1c 09       	add	r9,lr
8000890e:	2f f8       	sub	r8,-1
80008910:	87 0a       	st.w	r3[0x0],r10
80008912:	fb 49 06 90 	st.w	sp[1680],r9
80008916:	87 1e       	st.w	r3[0x4],lr
80008918:	fb 48 06 8c 	st.w	sp[1676],r8
8000891c:	58 78       	cp.w	r8,7
8000891e:	e0 89 00 04 	brgt	80008926 <_vfprintf_r+0x171a>
80008922:	2f 83       	sub	r3,-8
80008924:	c0 b8       	rjmp	8000893a <_vfprintf_r+0x172e>
80008926:	fa ca f9 78 	sub	r10,sp,-1672
8000892a:	02 9b       	mov	r11,r1
8000892c:	08 9c       	mov	r12,r4
8000892e:	fe b0 f4 61 	rcall	800071f0 <__sprint_r>
80008932:	e0 81 03 ec 	brne	8000910a <_vfprintf_r+0x1efe>
80008936:	fa c3 f9 e0 	sub	r3,sp,-1568
8000893a:	30 09       	mov	r9,0
8000893c:	fb 38 06 bb 	ld.ub	r8,sp[1723]
80008940:	f2 08 18 00 	cp.b	r8,r9
80008944:	c1 f0       	breq	80008982 <_vfprintf_r+0x1776>
80008946:	fa f8 06 90 	ld.w	r8,sp[1680]
8000894a:	fa c9 f9 45 	sub	r9,sp,-1723
8000894e:	2f f8       	sub	r8,-1
80008950:	87 09       	st.w	r3[0x0],r9
80008952:	fb 48 06 90 	st.w	sp[1680],r8
80008956:	30 19       	mov	r9,1
80008958:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000895c:	87 19       	st.w	r3[0x4],r9
8000895e:	2f f8       	sub	r8,-1
80008960:	fb 48 06 8c 	st.w	sp[1676],r8
80008964:	58 78       	cp.w	r8,7
80008966:	e0 89 00 04 	brgt	8000896e <_vfprintf_r+0x1762>
8000896a:	2f 83       	sub	r3,-8
8000896c:	c0 b8       	rjmp	80008982 <_vfprintf_r+0x1776>
8000896e:	fa ca f9 78 	sub	r10,sp,-1672
80008972:	02 9b       	mov	r11,r1
80008974:	08 9c       	mov	r12,r4
80008976:	fe b0 f4 3d 	rcall	800071f0 <__sprint_r>
8000897a:	e0 81 03 c8 	brne	8000910a <_vfprintf_r+0x1efe>
8000897e:	fa c3 f9 e0 	sub	r3,sp,-1568
80008982:	40 fc       	lddsp	r12,sp[0x3c]
80008984:	58 0c       	cp.w	r12,0
80008986:	c1 f0       	breq	800089c4 <_vfprintf_r+0x17b8>
80008988:	fa f8 06 90 	ld.w	r8,sp[1680]
8000898c:	fa c9 f9 48 	sub	r9,sp,-1720
80008990:	2f e8       	sub	r8,-2
80008992:	87 09       	st.w	r3[0x0],r9
80008994:	fb 48 06 90 	st.w	sp[1680],r8
80008998:	30 29       	mov	r9,2
8000899a:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000899e:	87 19       	st.w	r3[0x4],r9
800089a0:	2f f8       	sub	r8,-1
800089a2:	fb 48 06 8c 	st.w	sp[1676],r8
800089a6:	58 78       	cp.w	r8,7
800089a8:	e0 89 00 04 	brgt	800089b0 <_vfprintf_r+0x17a4>
800089ac:	2f 83       	sub	r3,-8
800089ae:	c0 b8       	rjmp	800089c4 <_vfprintf_r+0x17b8>
800089b0:	fa ca f9 78 	sub	r10,sp,-1672
800089b4:	02 9b       	mov	r11,r1
800089b6:	08 9c       	mov	r12,r4
800089b8:	fe b0 f4 1c 	rcall	800071f0 <__sprint_r>
800089bc:	e0 81 03 a7 	brne	8000910a <_vfprintf_r+0x1efe>
800089c0:	fa c3 f9 e0 	sub	r3,sp,-1568
800089c4:	40 9b       	lddsp	r11,sp[0x24]
800089c6:	e0 4b 00 80 	cp.w	r11,128
800089ca:	c4 71       	brne	80008a58 <_vfprintf_r+0x184c>
800089cc:	40 8a       	lddsp	r10,sp[0x20]
800089ce:	40 39       	lddsp	r9,sp[0xc]
800089d0:	12 1a       	sub	r10,r9
800089d2:	50 4a       	stdsp	sp[0x10],r10
800089d4:	58 0a       	cp.w	r10,0
800089d6:	e0 89 00 20 	brgt	80008a16 <_vfprintf_r+0x180a>
800089da:	c3 f8       	rjmp	80008a58 <_vfprintf_r+0x184c>
800089dc:	2f 09       	sub	r9,-16
800089de:	2f f8       	sub	r8,-1
800089e0:	fe ce bb 8c 	sub	lr,pc,-17524
800089e4:	31 0c       	mov	r12,16
800089e6:	fb 49 06 90 	st.w	sp[1680],r9
800089ea:	87 0e       	st.w	r3[0x0],lr
800089ec:	87 1c       	st.w	r3[0x4],r12
800089ee:	fb 48 06 8c 	st.w	sp[1676],r8
800089f2:	58 78       	cp.w	r8,7
800089f4:	e0 89 00 04 	brgt	800089fc <_vfprintf_r+0x17f0>
800089f8:	2f 83       	sub	r3,-8
800089fa:	c0 b8       	rjmp	80008a10 <_vfprintf_r+0x1804>
800089fc:	fa ca f9 78 	sub	r10,sp,-1672
80008a00:	02 9b       	mov	r11,r1
80008a02:	08 9c       	mov	r12,r4
80008a04:	fe b0 f3 f6 	rcall	800071f0 <__sprint_r>
80008a08:	e0 81 03 81 	brne	8000910a <_vfprintf_r+0x1efe>
80008a0c:	fa c3 f9 e0 	sub	r3,sp,-1568
80008a10:	40 4b       	lddsp	r11,sp[0x10]
80008a12:	21 0b       	sub	r11,16
80008a14:	50 4b       	stdsp	sp[0x10],r11
80008a16:	fa f9 06 90 	ld.w	r9,sp[1680]
80008a1a:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008a1e:	fe ca bb ca 	sub	r10,pc,-17462
80008a22:	40 4e       	lddsp	lr,sp[0x10]
80008a24:	59 0e       	cp.w	lr,16
80008a26:	fe 99 ff db 	brgt	800089dc <_vfprintf_r+0x17d0>
80008a2a:	1c 09       	add	r9,lr
80008a2c:	2f f8       	sub	r8,-1
80008a2e:	87 0a       	st.w	r3[0x0],r10
80008a30:	fb 49 06 90 	st.w	sp[1680],r9
80008a34:	87 1e       	st.w	r3[0x4],lr
80008a36:	fb 48 06 8c 	st.w	sp[1676],r8
80008a3a:	58 78       	cp.w	r8,7
80008a3c:	e0 89 00 04 	brgt	80008a44 <_vfprintf_r+0x1838>
80008a40:	2f 83       	sub	r3,-8
80008a42:	c0 b8       	rjmp	80008a58 <_vfprintf_r+0x184c>
80008a44:	fa ca f9 78 	sub	r10,sp,-1672
80008a48:	02 9b       	mov	r11,r1
80008a4a:	08 9c       	mov	r12,r4
80008a4c:	fe b0 f3 d2 	rcall	800071f0 <__sprint_r>
80008a50:	e0 81 03 5d 	brne	8000910a <_vfprintf_r+0x1efe>
80008a54:	fa c3 f9 e0 	sub	r3,sp,-1568
80008a58:	40 2c       	lddsp	r12,sp[0x8]
80008a5a:	04 1c       	sub	r12,r2
80008a5c:	50 2c       	stdsp	sp[0x8],r12
80008a5e:	58 0c       	cp.w	r12,0
80008a60:	e0 89 00 20 	brgt	80008aa0 <_vfprintf_r+0x1894>
80008a64:	c3 f8       	rjmp	80008ae2 <_vfprintf_r+0x18d6>
80008a66:	2f 09       	sub	r9,-16
80008a68:	2f f8       	sub	r8,-1
80008a6a:	fe cb bc 16 	sub	r11,pc,-17386
80008a6e:	31 0a       	mov	r10,16
80008a70:	fb 49 06 90 	st.w	sp[1680],r9
80008a74:	87 0b       	st.w	r3[0x0],r11
80008a76:	87 1a       	st.w	r3[0x4],r10
80008a78:	fb 48 06 8c 	st.w	sp[1676],r8
80008a7c:	58 78       	cp.w	r8,7
80008a7e:	e0 89 00 04 	brgt	80008a86 <_vfprintf_r+0x187a>
80008a82:	2f 83       	sub	r3,-8
80008a84:	c0 b8       	rjmp	80008a9a <_vfprintf_r+0x188e>
80008a86:	fa ca f9 78 	sub	r10,sp,-1672
80008a8a:	02 9b       	mov	r11,r1
80008a8c:	08 9c       	mov	r12,r4
80008a8e:	fe b0 f3 b1 	rcall	800071f0 <__sprint_r>
80008a92:	e0 81 03 3c 	brne	8000910a <_vfprintf_r+0x1efe>
80008a96:	fa c3 f9 e0 	sub	r3,sp,-1568
80008a9a:	40 29       	lddsp	r9,sp[0x8]
80008a9c:	21 09       	sub	r9,16
80008a9e:	50 29       	stdsp	sp[0x8],r9
80008aa0:	fa f9 06 90 	ld.w	r9,sp[1680]
80008aa4:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008aa8:	fe ca bc 54 	sub	r10,pc,-17324
80008aac:	40 2e       	lddsp	lr,sp[0x8]
80008aae:	59 0e       	cp.w	lr,16
80008ab0:	fe 99 ff db 	brgt	80008a66 <_vfprintf_r+0x185a>
80008ab4:	1c 09       	add	r9,lr
80008ab6:	2f f8       	sub	r8,-1
80008ab8:	87 0a       	st.w	r3[0x0],r10
80008aba:	fb 49 06 90 	st.w	sp[1680],r9
80008abe:	87 1e       	st.w	r3[0x4],lr
80008ac0:	fb 48 06 8c 	st.w	sp[1676],r8
80008ac4:	58 78       	cp.w	r8,7
80008ac6:	e0 89 00 04 	brgt	80008ace <_vfprintf_r+0x18c2>
80008aca:	2f 83       	sub	r3,-8
80008acc:	c0 b8       	rjmp	80008ae2 <_vfprintf_r+0x18d6>
80008ace:	fa ca f9 78 	sub	r10,sp,-1672
80008ad2:	02 9b       	mov	r11,r1
80008ad4:	08 9c       	mov	r12,r4
80008ad6:	fe b0 f3 8d 	rcall	800071f0 <__sprint_r>
80008ada:	e0 81 03 18 	brne	8000910a <_vfprintf_r+0x1efe>
80008ade:	fa c3 f9 e0 	sub	r3,sp,-1568
80008ae2:	ed b5 00 08 	bld	r5,0x8
80008ae6:	c0 b0       	breq	80008afc <_vfprintf_r+0x18f0>
80008ae8:	fa f8 06 90 	ld.w	r8,sp[1680]
80008aec:	87 12       	st.w	r3[0x4],r2
80008aee:	87 06       	st.w	r3[0x0],r6
80008af0:	f0 02 00 02 	add	r2,r8,r2
80008af4:	fb 42 06 90 	st.w	sp[1680],r2
80008af8:	e0 8f 01 d4 	bral	80008ea0 <_vfprintf_r+0x1c94>
80008afc:	e0 40 00 65 	cp.w	r0,101
80008b00:	e0 8a 01 d6 	brle	80008eac <_vfprintf_r+0x1ca0>
80008b04:	30 08       	mov	r8,0
80008b06:	30 09       	mov	r9,0
80008b08:	40 5b       	lddsp	r11,sp[0x14]
80008b0a:	40 7a       	lddsp	r10,sp[0x1c]
80008b0c:	e0 a0 15 2f 	rcall	8000b56a <__avr32_f64_cmp_eq>
80008b10:	c7 90       	breq	80008c02 <_vfprintf_r+0x19f6>
80008b12:	fa f8 06 90 	ld.w	r8,sp[1680]
80008b16:	fe c9 bc d6 	sub	r9,pc,-17194
80008b1a:	2f f8       	sub	r8,-1
80008b1c:	87 09       	st.w	r3[0x0],r9
80008b1e:	fb 48 06 90 	st.w	sp[1680],r8
80008b22:	30 19       	mov	r9,1
80008b24:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008b28:	87 19       	st.w	r3[0x4],r9
80008b2a:	2f f8       	sub	r8,-1
80008b2c:	fb 48 06 8c 	st.w	sp[1676],r8
80008b30:	58 78       	cp.w	r8,7
80008b32:	e0 89 00 05 	brgt	80008b3c <_vfprintf_r+0x1930>
80008b36:	2f 83       	sub	r3,-8
80008b38:	c0 c8       	rjmp	80008b50 <_vfprintf_r+0x1944>
80008b3a:	d7 03       	nop
80008b3c:	fa ca f9 78 	sub	r10,sp,-1672
80008b40:	02 9b       	mov	r11,r1
80008b42:	08 9c       	mov	r12,r4
80008b44:	fe b0 f3 56 	rcall	800071f0 <__sprint_r>
80008b48:	e0 81 02 e1 	brne	8000910a <_vfprintf_r+0x1efe>
80008b4c:	fa c3 f9 e0 	sub	r3,sp,-1568
80008b50:	fa f8 06 ac 	ld.w	r8,sp[1708]
80008b54:	40 6c       	lddsp	r12,sp[0x18]
80008b56:	18 38       	cp.w	r8,r12
80008b58:	c0 55       	brlt	80008b62 <_vfprintf_r+0x1956>
80008b5a:	ed b5 00 00 	bld	r5,0x0
80008b5e:	e0 81 02 6b 	brne	80009034 <_vfprintf_r+0x1e28>
80008b62:	fa f8 06 90 	ld.w	r8,sp[1680]
80008b66:	2f f8       	sub	r8,-1
80008b68:	40 cb       	lddsp	r11,sp[0x30]
80008b6a:	fb 48 06 90 	st.w	sp[1680],r8
80008b6e:	30 19       	mov	r9,1
80008b70:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008b74:	87 0b       	st.w	r3[0x0],r11
80008b76:	2f f8       	sub	r8,-1
80008b78:	87 19       	st.w	r3[0x4],r9
80008b7a:	fb 48 06 8c 	st.w	sp[1676],r8
80008b7e:	58 78       	cp.w	r8,7
80008b80:	e0 89 00 04 	brgt	80008b88 <_vfprintf_r+0x197c>
80008b84:	2f 83       	sub	r3,-8
80008b86:	c0 b8       	rjmp	80008b9c <_vfprintf_r+0x1990>
80008b88:	fa ca f9 78 	sub	r10,sp,-1672
80008b8c:	02 9b       	mov	r11,r1
80008b8e:	08 9c       	mov	r12,r4
80008b90:	fe b0 f3 30 	rcall	800071f0 <__sprint_r>
80008b94:	e0 81 02 bb 	brne	8000910a <_vfprintf_r+0x1efe>
80008b98:	fa c3 f9 e0 	sub	r3,sp,-1568
80008b9c:	40 66       	lddsp	r6,sp[0x18]
80008b9e:	20 16       	sub	r6,1
80008ba0:	58 06       	cp.w	r6,0
80008ba2:	e0 89 00 1d 	brgt	80008bdc <_vfprintf_r+0x19d0>
80008ba6:	e0 8f 02 47 	bral	80009034 <_vfprintf_r+0x1e28>
80008baa:	2f 09       	sub	r9,-16
80008bac:	2f f8       	sub	r8,-1
80008bae:	fb 49 06 90 	st.w	sp[1680],r9
80008bb2:	87 02       	st.w	r3[0x0],r2
80008bb4:	87 10       	st.w	r3[0x4],r0
80008bb6:	fb 48 06 8c 	st.w	sp[1676],r8
80008bba:	58 78       	cp.w	r8,7
80008bbc:	e0 89 00 04 	brgt	80008bc4 <_vfprintf_r+0x19b8>
80008bc0:	2f 83       	sub	r3,-8
80008bc2:	c0 b8       	rjmp	80008bd8 <_vfprintf_r+0x19cc>
80008bc4:	fa ca f9 78 	sub	r10,sp,-1672
80008bc8:	02 9b       	mov	r11,r1
80008bca:	08 9c       	mov	r12,r4
80008bcc:	fe b0 f3 12 	rcall	800071f0 <__sprint_r>
80008bd0:	e0 81 02 9d 	brne	8000910a <_vfprintf_r+0x1efe>
80008bd4:	fa c3 f9 e0 	sub	r3,sp,-1568
80008bd8:	21 06       	sub	r6,16
80008bda:	c0 48       	rjmp	80008be2 <_vfprintf_r+0x19d6>
80008bdc:	fe c2 bd 88 	sub	r2,pc,-17016
80008be0:	31 00       	mov	r0,16
80008be2:	fa f9 06 90 	ld.w	r9,sp[1680]
80008be6:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008bea:	fe ca bd 96 	sub	r10,pc,-17002
80008bee:	59 06       	cp.w	r6,16
80008bf0:	fe 99 ff dd 	brgt	80008baa <_vfprintf_r+0x199e>
80008bf4:	0c 09       	add	r9,r6
80008bf6:	87 0a       	st.w	r3[0x0],r10
80008bf8:	fb 49 06 90 	st.w	sp[1680],r9
80008bfc:	2f f8       	sub	r8,-1
80008bfe:	87 16       	st.w	r3[0x4],r6
80008c00:	c5 39       	rjmp	80008ea6 <_vfprintf_r+0x1c9a>
80008c02:	fa fa 06 ac 	ld.w	r10,sp[1708]
80008c06:	58 0a       	cp.w	r10,0
80008c08:	e0 89 00 92 	brgt	80008d2c <_vfprintf_r+0x1b20>
80008c0c:	fa f8 06 90 	ld.w	r8,sp[1680]
80008c10:	fe c9 bd d0 	sub	r9,pc,-16944
80008c14:	2f f8       	sub	r8,-1
80008c16:	87 09       	st.w	r3[0x0],r9
80008c18:	fb 48 06 90 	st.w	sp[1680],r8
80008c1c:	30 19       	mov	r9,1
80008c1e:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008c22:	87 19       	st.w	r3[0x4],r9
80008c24:	2f f8       	sub	r8,-1
80008c26:	fb 48 06 8c 	st.w	sp[1676],r8
80008c2a:	58 78       	cp.w	r8,7
80008c2c:	e0 89 00 04 	brgt	80008c34 <_vfprintf_r+0x1a28>
80008c30:	2f 83       	sub	r3,-8
80008c32:	c0 b8       	rjmp	80008c48 <_vfprintf_r+0x1a3c>
80008c34:	fa ca f9 78 	sub	r10,sp,-1672
80008c38:	02 9b       	mov	r11,r1
80008c3a:	08 9c       	mov	r12,r4
80008c3c:	fe b0 f2 da 	rcall	800071f0 <__sprint_r>
80008c40:	e0 81 02 65 	brne	8000910a <_vfprintf_r+0x1efe>
80008c44:	fa c3 f9 e0 	sub	r3,sp,-1568
80008c48:	fa f8 06 ac 	ld.w	r8,sp[1708]
80008c4c:	58 08       	cp.w	r8,0
80008c4e:	c0 81       	brne	80008c5e <_vfprintf_r+0x1a52>
80008c50:	40 6a       	lddsp	r10,sp[0x18]
80008c52:	58 0a       	cp.w	r10,0
80008c54:	c0 51       	brne	80008c5e <_vfprintf_r+0x1a52>
80008c56:	ed b5 00 00 	bld	r5,0x0
80008c5a:	e0 81 01 ed 	brne	80009034 <_vfprintf_r+0x1e28>
80008c5e:	40 c9       	lddsp	r9,sp[0x30]
80008c60:	fa f8 06 90 	ld.w	r8,sp[1680]
80008c64:	2f f8       	sub	r8,-1
80008c66:	87 09       	st.w	r3[0x0],r9
80008c68:	fb 48 06 90 	st.w	sp[1680],r8
80008c6c:	30 19       	mov	r9,1
80008c6e:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008c72:	87 19       	st.w	r3[0x4],r9
80008c74:	2f f8       	sub	r8,-1
80008c76:	fb 48 06 8c 	st.w	sp[1676],r8
80008c7a:	58 78       	cp.w	r8,7
80008c7c:	e0 89 00 04 	brgt	80008c84 <_vfprintf_r+0x1a78>
80008c80:	2f 83       	sub	r3,-8
80008c82:	c0 b8       	rjmp	80008c98 <_vfprintf_r+0x1a8c>
80008c84:	fa ca f9 78 	sub	r10,sp,-1672
80008c88:	02 9b       	mov	r11,r1
80008c8a:	08 9c       	mov	r12,r4
80008c8c:	fe b0 f2 b2 	rcall	800071f0 <__sprint_r>
80008c90:	e0 81 02 3d 	brne	8000910a <_vfprintf_r+0x1efe>
80008c94:	fa c3 f9 e0 	sub	r3,sp,-1568
80008c98:	fa f2 06 ac 	ld.w	r2,sp[1708]
80008c9c:	5c 32       	neg	r2
80008c9e:	58 02       	cp.w	r2,0
80008ca0:	e0 89 00 1d 	brgt	80008cda <_vfprintf_r+0x1ace>
80008ca4:	c3 d8       	rjmp	80008d1e <_vfprintf_r+0x1b12>
80008ca6:	2f 09       	sub	r9,-16
80008ca8:	2f f8       	sub	r8,-1
80008caa:	31 0e       	mov	lr,16
80008cac:	fb 49 06 90 	st.w	sp[1680],r9
80008cb0:	87 00       	st.w	r3[0x0],r0
80008cb2:	87 1e       	st.w	r3[0x4],lr
80008cb4:	fb 48 06 8c 	st.w	sp[1676],r8
80008cb8:	58 78       	cp.w	r8,7
80008cba:	e0 89 00 04 	brgt	80008cc2 <_vfprintf_r+0x1ab6>
80008cbe:	2f 83       	sub	r3,-8
80008cc0:	c0 b8       	rjmp	80008cd6 <_vfprintf_r+0x1aca>
80008cc2:	fa ca f9 78 	sub	r10,sp,-1672
80008cc6:	02 9b       	mov	r11,r1
80008cc8:	08 9c       	mov	r12,r4
80008cca:	fe b0 f2 93 	rcall	800071f0 <__sprint_r>
80008cce:	e0 81 02 1e 	brne	8000910a <_vfprintf_r+0x1efe>
80008cd2:	fa c3 f9 e0 	sub	r3,sp,-1568
80008cd6:	21 02       	sub	r2,16
80008cd8:	c0 38       	rjmp	80008cde <_vfprintf_r+0x1ad2>
80008cda:	fe c0 be 86 	sub	r0,pc,-16762
80008cde:	fa f9 06 90 	ld.w	r9,sp[1680]
80008ce2:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008ce6:	fe ca be 92 	sub	r10,pc,-16750
80008cea:	59 02       	cp.w	r2,16
80008cec:	fe 99 ff dd 	brgt	80008ca6 <_vfprintf_r+0x1a9a>
80008cf0:	04 09       	add	r9,r2
80008cf2:	2f f8       	sub	r8,-1
80008cf4:	87 0a       	st.w	r3[0x0],r10
80008cf6:	fb 49 06 90 	st.w	sp[1680],r9
80008cfa:	87 12       	st.w	r3[0x4],r2
80008cfc:	fb 48 06 8c 	st.w	sp[1676],r8
80008d00:	58 78       	cp.w	r8,7
80008d02:	e0 89 00 04 	brgt	80008d0a <_vfprintf_r+0x1afe>
80008d06:	2f 83       	sub	r3,-8
80008d08:	c0 b8       	rjmp	80008d1e <_vfprintf_r+0x1b12>
80008d0a:	fa ca f9 78 	sub	r10,sp,-1672
80008d0e:	02 9b       	mov	r11,r1
80008d10:	08 9c       	mov	r12,r4
80008d12:	fe b0 f2 6f 	rcall	800071f0 <__sprint_r>
80008d16:	e0 81 01 fa 	brne	8000910a <_vfprintf_r+0x1efe>
80008d1a:	fa c3 f9 e0 	sub	r3,sp,-1568
80008d1e:	40 6c       	lddsp	r12,sp[0x18]
80008d20:	fa f8 06 90 	ld.w	r8,sp[1680]
80008d24:	87 06       	st.w	r3[0x0],r6
80008d26:	87 1c       	st.w	r3[0x4],r12
80008d28:	18 08       	add	r8,r12
80008d2a:	cb 98       	rjmp	80008e9c <_vfprintf_r+0x1c90>
80008d2c:	fa f9 06 90 	ld.w	r9,sp[1680]
80008d30:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008d34:	40 6b       	lddsp	r11,sp[0x18]
80008d36:	16 3a       	cp.w	r10,r11
80008d38:	c6 f5       	brlt	80008e16 <_vfprintf_r+0x1c0a>
80008d3a:	16 09       	add	r9,r11
80008d3c:	2f f8       	sub	r8,-1
80008d3e:	87 06       	st.w	r3[0x0],r6
80008d40:	fb 49 06 90 	st.w	sp[1680],r9
80008d44:	87 1b       	st.w	r3[0x4],r11
80008d46:	fb 48 06 8c 	st.w	sp[1676],r8
80008d4a:	58 78       	cp.w	r8,7
80008d4c:	e0 89 00 04 	brgt	80008d54 <_vfprintf_r+0x1b48>
80008d50:	2f 83       	sub	r3,-8
80008d52:	c0 b8       	rjmp	80008d68 <_vfprintf_r+0x1b5c>
80008d54:	fa ca f9 78 	sub	r10,sp,-1672
80008d58:	02 9b       	mov	r11,r1
80008d5a:	08 9c       	mov	r12,r4
80008d5c:	fe b0 f2 4a 	rcall	800071f0 <__sprint_r>
80008d60:	e0 81 01 d5 	brne	8000910a <_vfprintf_r+0x1efe>
80008d64:	fa c3 f9 e0 	sub	r3,sp,-1568
80008d68:	fa f6 06 ac 	ld.w	r6,sp[1708]
80008d6c:	40 6a       	lddsp	r10,sp[0x18]
80008d6e:	14 16       	sub	r6,r10
80008d70:	58 06       	cp.w	r6,0
80008d72:	e0 89 00 1c 	brgt	80008daa <_vfprintf_r+0x1b9e>
80008d76:	c3 d8       	rjmp	80008df0 <_vfprintf_r+0x1be4>
80008d78:	2f 09       	sub	r9,-16
80008d7a:	2f f8       	sub	r8,-1
80008d7c:	fb 49 06 90 	st.w	sp[1680],r9
80008d80:	87 02       	st.w	r3[0x0],r2
80008d82:	87 10       	st.w	r3[0x4],r0
80008d84:	fb 48 06 8c 	st.w	sp[1676],r8
80008d88:	58 78       	cp.w	r8,7
80008d8a:	e0 89 00 04 	brgt	80008d92 <_vfprintf_r+0x1b86>
80008d8e:	2f 83       	sub	r3,-8
80008d90:	c0 b8       	rjmp	80008da6 <_vfprintf_r+0x1b9a>
80008d92:	fa ca f9 78 	sub	r10,sp,-1672
80008d96:	02 9b       	mov	r11,r1
80008d98:	08 9c       	mov	r12,r4
80008d9a:	fe b0 f2 2b 	rcall	800071f0 <__sprint_r>
80008d9e:	e0 81 01 b6 	brne	8000910a <_vfprintf_r+0x1efe>
80008da2:	fa c3 f9 e0 	sub	r3,sp,-1568
80008da6:	21 06       	sub	r6,16
80008da8:	c0 48       	rjmp	80008db0 <_vfprintf_r+0x1ba4>
80008daa:	fe c2 bf 56 	sub	r2,pc,-16554
80008dae:	31 00       	mov	r0,16
80008db0:	fa f9 06 90 	ld.w	r9,sp[1680]
80008db4:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008db8:	fe ca bf 64 	sub	r10,pc,-16540
80008dbc:	59 06       	cp.w	r6,16
80008dbe:	fe 99 ff dd 	brgt	80008d78 <_vfprintf_r+0x1b6c>
80008dc2:	0c 09       	add	r9,r6
80008dc4:	2f f8       	sub	r8,-1
80008dc6:	87 0a       	st.w	r3[0x0],r10
80008dc8:	fb 49 06 90 	st.w	sp[1680],r9
80008dcc:	87 16       	st.w	r3[0x4],r6
80008dce:	fb 48 06 8c 	st.w	sp[1676],r8
80008dd2:	58 78       	cp.w	r8,7
80008dd4:	e0 89 00 04 	brgt	80008ddc <_vfprintf_r+0x1bd0>
80008dd8:	2f 83       	sub	r3,-8
80008dda:	c0 b8       	rjmp	80008df0 <_vfprintf_r+0x1be4>
80008ddc:	fa ca f9 78 	sub	r10,sp,-1672
80008de0:	02 9b       	mov	r11,r1
80008de2:	08 9c       	mov	r12,r4
80008de4:	fe b0 f2 06 	rcall	800071f0 <__sprint_r>
80008de8:	e0 81 01 91 	brne	8000910a <_vfprintf_r+0x1efe>
80008dec:	fa c3 f9 e0 	sub	r3,sp,-1568
80008df0:	ed b5 00 00 	bld	r5,0x0
80008df4:	e0 81 01 20 	brne	80009034 <_vfprintf_r+0x1e28>
80008df8:	40 c9       	lddsp	r9,sp[0x30]
80008dfa:	fa f8 06 90 	ld.w	r8,sp[1680]
80008dfe:	2f f8       	sub	r8,-1
80008e00:	87 09       	st.w	r3[0x0],r9
80008e02:	fb 48 06 90 	st.w	sp[1680],r8
80008e06:	30 19       	mov	r9,1
80008e08:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008e0c:	87 19       	st.w	r3[0x4],r9
80008e0e:	2f f8       	sub	r8,-1
80008e10:	fb 48 06 8c 	st.w	sp[1676],r8
80008e14:	c0 29       	rjmp	80009018 <_vfprintf_r+0x1e0c>
80008e16:	14 09       	add	r9,r10
80008e18:	2f f8       	sub	r8,-1
80008e1a:	fb 49 06 90 	st.w	sp[1680],r9
80008e1e:	87 06       	st.w	r3[0x0],r6
80008e20:	87 1a       	st.w	r3[0x4],r10
80008e22:	fb 48 06 8c 	st.w	sp[1676],r8
80008e26:	58 78       	cp.w	r8,7
80008e28:	e0 89 00 04 	brgt	80008e30 <_vfprintf_r+0x1c24>
80008e2c:	2f 83       	sub	r3,-8
80008e2e:	c0 b8       	rjmp	80008e44 <_vfprintf_r+0x1c38>
80008e30:	fa ca f9 78 	sub	r10,sp,-1672
80008e34:	02 9b       	mov	r11,r1
80008e36:	08 9c       	mov	r12,r4
80008e38:	fe b0 f1 dc 	rcall	800071f0 <__sprint_r>
80008e3c:	e0 81 01 67 	brne	8000910a <_vfprintf_r+0x1efe>
80008e40:	fa c3 f9 e0 	sub	r3,sp,-1568
80008e44:	40 c8       	lddsp	r8,sp[0x30]
80008e46:	87 08       	st.w	r3[0x0],r8
80008e48:	fa f8 06 90 	ld.w	r8,sp[1680]
80008e4c:	2f f8       	sub	r8,-1
80008e4e:	30 19       	mov	r9,1
80008e50:	fb 48 06 90 	st.w	sp[1680],r8
80008e54:	87 19       	st.w	r3[0x4],r9
80008e56:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008e5a:	2f f8       	sub	r8,-1
80008e5c:	fb 48 06 8c 	st.w	sp[1676],r8
80008e60:	fa f2 06 ac 	ld.w	r2,sp[1708]
80008e64:	58 78       	cp.w	r8,7
80008e66:	e0 89 00 04 	brgt	80008e6e <_vfprintf_r+0x1c62>
80008e6a:	2f 83       	sub	r3,-8
80008e6c:	c0 b8       	rjmp	80008e82 <_vfprintf_r+0x1c76>
80008e6e:	fa ca f9 78 	sub	r10,sp,-1672
80008e72:	02 9b       	mov	r11,r1
80008e74:	08 9c       	mov	r12,r4
80008e76:	fe b0 f1 bd 	rcall	800071f0 <__sprint_r>
80008e7a:	e0 81 01 48 	brne	8000910a <_vfprintf_r+0x1efe>
80008e7e:	fa c3 f9 e0 	sub	r3,sp,-1568
80008e82:	04 06       	add	r6,r2
80008e84:	fa f8 06 ac 	ld.w	r8,sp[1708]
80008e88:	87 06       	st.w	r3[0x0],r6
80008e8a:	fa f9 06 90 	ld.w	r9,sp[1680]
80008e8e:	40 66       	lddsp	r6,sp[0x18]
80008e90:	40 6e       	lddsp	lr,sp[0x18]
80008e92:	10 16       	sub	r6,r8
80008e94:	f2 08 01 08 	sub	r8,r9,r8
80008e98:	87 16       	st.w	r3[0x4],r6
80008e9a:	1c 08       	add	r8,lr
80008e9c:	fb 48 06 90 	st.w	sp[1680],r8
80008ea0:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008ea4:	2f f8       	sub	r8,-1
80008ea6:	fb 48 06 8c 	st.w	sp[1676],r8
80008eaa:	cb 78       	rjmp	80009018 <_vfprintf_r+0x1e0c>
80008eac:	40 6c       	lddsp	r12,sp[0x18]
80008eae:	58 1c       	cp.w	r12,1
80008eb0:	e0 89 00 06 	brgt	80008ebc <_vfprintf_r+0x1cb0>
80008eb4:	ed b5 00 00 	bld	r5,0x0
80008eb8:	e0 81 00 85 	brne	80008fc2 <_vfprintf_r+0x1db6>
80008ebc:	fa f8 06 90 	ld.w	r8,sp[1680]
80008ec0:	2f f8       	sub	r8,-1
80008ec2:	30 19       	mov	r9,1
80008ec4:	fb 48 06 90 	st.w	sp[1680],r8
80008ec8:	87 06       	st.w	r3[0x0],r6
80008eca:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008ece:	87 19       	st.w	r3[0x4],r9
80008ed0:	2f f8       	sub	r8,-1
80008ed2:	fb 48 06 8c 	st.w	sp[1676],r8
80008ed6:	58 78       	cp.w	r8,7
80008ed8:	e0 89 00 04 	brgt	80008ee0 <_vfprintf_r+0x1cd4>
80008edc:	2f 83       	sub	r3,-8
80008ede:	c0 b8       	rjmp	80008ef4 <_vfprintf_r+0x1ce8>
80008ee0:	fa ca f9 78 	sub	r10,sp,-1672
80008ee4:	02 9b       	mov	r11,r1
80008ee6:	08 9c       	mov	r12,r4
80008ee8:	fe b0 f1 84 	rcall	800071f0 <__sprint_r>
80008eec:	e0 81 01 0f 	brne	8000910a <_vfprintf_r+0x1efe>
80008ef0:	fa c3 f9 e0 	sub	r3,sp,-1568
80008ef4:	fa f8 06 90 	ld.w	r8,sp[1680]
80008ef8:	2f f8       	sub	r8,-1
80008efa:	40 cb       	lddsp	r11,sp[0x30]
80008efc:	fb 48 06 90 	st.w	sp[1680],r8
80008f00:	30 19       	mov	r9,1
80008f02:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008f06:	87 0b       	st.w	r3[0x0],r11
80008f08:	2f f8       	sub	r8,-1
80008f0a:	87 19       	st.w	r3[0x4],r9
80008f0c:	fb 48 06 8c 	st.w	sp[1676],r8
80008f10:	58 78       	cp.w	r8,7
80008f12:	e0 89 00 05 	brgt	80008f1c <_vfprintf_r+0x1d10>
80008f16:	2f 83       	sub	r3,-8
80008f18:	c0 c8       	rjmp	80008f30 <_vfprintf_r+0x1d24>
80008f1a:	d7 03       	nop
80008f1c:	fa ca f9 78 	sub	r10,sp,-1672
80008f20:	02 9b       	mov	r11,r1
80008f22:	08 9c       	mov	r12,r4
80008f24:	fe b0 f1 66 	rcall	800071f0 <__sprint_r>
80008f28:	e0 81 00 f1 	brne	8000910a <_vfprintf_r+0x1efe>
80008f2c:	fa c3 f9 e0 	sub	r3,sp,-1568
80008f30:	30 08       	mov	r8,0
80008f32:	30 09       	mov	r9,0
80008f34:	40 5b       	lddsp	r11,sp[0x14]
80008f36:	40 7a       	lddsp	r10,sp[0x1c]
80008f38:	e0 a0 13 19 	rcall	8000b56a <__avr32_f64_cmp_eq>
80008f3c:	40 68       	lddsp	r8,sp[0x18]
80008f3e:	20 18       	sub	r8,1
80008f40:	58 0c       	cp.w	r12,0
80008f42:	c0 d1       	brne	80008f5c <_vfprintf_r+0x1d50>
80008f44:	2f f6       	sub	r6,-1
80008f46:	87 18       	st.w	r3[0x4],r8
80008f48:	87 06       	st.w	r3[0x0],r6
80008f4a:	fa f6 06 90 	ld.w	r6,sp[1680]
80008f4e:	10 06       	add	r6,r8
80008f50:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008f54:	fb 46 06 90 	st.w	sp[1680],r6
80008f58:	2f f8       	sub	r8,-1
80008f5a:	c3 18       	rjmp	80008fbc <_vfprintf_r+0x1db0>
80008f5c:	10 96       	mov	r6,r8
80008f5e:	58 08       	cp.w	r8,0
80008f60:	e0 89 00 1c 	brgt	80008f98 <_vfprintf_r+0x1d8c>
80008f64:	c4 b8       	rjmp	80008ffa <_vfprintf_r+0x1dee>
80008f66:	2f 09       	sub	r9,-16
80008f68:	2f f8       	sub	r8,-1
80008f6a:	fb 49 06 90 	st.w	sp[1680],r9
80008f6e:	87 02       	st.w	r3[0x0],r2
80008f70:	87 10       	st.w	r3[0x4],r0
80008f72:	fb 48 06 8c 	st.w	sp[1676],r8
80008f76:	58 78       	cp.w	r8,7
80008f78:	e0 89 00 04 	brgt	80008f80 <_vfprintf_r+0x1d74>
80008f7c:	2f 83       	sub	r3,-8
80008f7e:	c0 b8       	rjmp	80008f94 <_vfprintf_r+0x1d88>
80008f80:	fa ca f9 78 	sub	r10,sp,-1672
80008f84:	02 9b       	mov	r11,r1
80008f86:	08 9c       	mov	r12,r4
80008f88:	fe b0 f1 34 	rcall	800071f0 <__sprint_r>
80008f8c:	e0 81 00 bf 	brne	8000910a <_vfprintf_r+0x1efe>
80008f90:	fa c3 f9 e0 	sub	r3,sp,-1568
80008f94:	21 06       	sub	r6,16
80008f96:	c0 48       	rjmp	80008f9e <_vfprintf_r+0x1d92>
80008f98:	fe c2 c1 44 	sub	r2,pc,-16060
80008f9c:	31 00       	mov	r0,16
80008f9e:	fa f9 06 90 	ld.w	r9,sp[1680]
80008fa2:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008fa6:	fe ca c1 52 	sub	r10,pc,-16046
80008faa:	59 06       	cp.w	r6,16
80008fac:	fe 99 ff dd 	brgt	80008f66 <_vfprintf_r+0x1d5a>
80008fb0:	0c 09       	add	r9,r6
80008fb2:	87 0a       	st.w	r3[0x0],r10
80008fb4:	fb 49 06 90 	st.w	sp[1680],r9
80008fb8:	2f f8       	sub	r8,-1
80008fba:	87 16       	st.w	r3[0x4],r6
80008fbc:	fb 48 06 8c 	st.w	sp[1676],r8
80008fc0:	c0 e8       	rjmp	80008fdc <_vfprintf_r+0x1dd0>
80008fc2:	fa f8 06 90 	ld.w	r8,sp[1680]
80008fc6:	2f f8       	sub	r8,-1
80008fc8:	30 19       	mov	r9,1
80008fca:	fb 48 06 90 	st.w	sp[1680],r8
80008fce:	87 06       	st.w	r3[0x0],r6
80008fd0:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008fd4:	87 19       	st.w	r3[0x4],r9
80008fd6:	2f f8       	sub	r8,-1
80008fd8:	fb 48 06 8c 	st.w	sp[1676],r8
80008fdc:	58 78       	cp.w	r8,7
80008fde:	e0 89 00 04 	brgt	80008fe6 <_vfprintf_r+0x1dda>
80008fe2:	2f 83       	sub	r3,-8
80008fe4:	c0 b8       	rjmp	80008ffa <_vfprintf_r+0x1dee>
80008fe6:	fa ca f9 78 	sub	r10,sp,-1672
80008fea:	02 9b       	mov	r11,r1
80008fec:	08 9c       	mov	r12,r4
80008fee:	fe b0 f1 01 	rcall	800071f0 <__sprint_r>
80008ff2:	e0 81 00 8c 	brne	8000910a <_vfprintf_r+0x1efe>
80008ff6:	fa c3 f9 e0 	sub	r3,sp,-1568
80008ffa:	40 ea       	lddsp	r10,sp[0x38]
80008ffc:	fa f8 06 90 	ld.w	r8,sp[1680]
80009000:	14 08       	add	r8,r10
80009002:	fa c9 f9 64 	sub	r9,sp,-1692
80009006:	fb 48 06 90 	st.w	sp[1680],r8
8000900a:	87 1a       	st.w	r3[0x4],r10
8000900c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009010:	87 09       	st.w	r3[0x0],r9
80009012:	2f f8       	sub	r8,-1
80009014:	fb 48 06 8c 	st.w	sp[1676],r8
80009018:	58 78       	cp.w	r8,7
8000901a:	e0 89 00 04 	brgt	80009022 <_vfprintf_r+0x1e16>
8000901e:	2f 83       	sub	r3,-8
80009020:	c0 a8       	rjmp	80009034 <_vfprintf_r+0x1e28>
80009022:	fa ca f9 78 	sub	r10,sp,-1672
80009026:	02 9b       	mov	r11,r1
80009028:	08 9c       	mov	r12,r4
8000902a:	fe b0 f0 e3 	rcall	800071f0 <__sprint_r>
8000902e:	c6 e1       	brne	8000910a <_vfprintf_r+0x1efe>
80009030:	fa c3 f9 e0 	sub	r3,sp,-1568
80009034:	e2 15 00 04 	andl	r5,0x4,COH
80009038:	c3 f0       	breq	800090b6 <_vfprintf_r+0x1eaa>
8000903a:	40 86       	lddsp	r6,sp[0x20]
8000903c:	40 39       	lddsp	r9,sp[0xc]
8000903e:	12 16       	sub	r6,r9
80009040:	58 06       	cp.w	r6,0
80009042:	e0 89 00 1a 	brgt	80009076 <_vfprintf_r+0x1e6a>
80009046:	c3 88       	rjmp	800090b6 <_vfprintf_r+0x1eaa>
80009048:	2f 09       	sub	r9,-16
8000904a:	2f f8       	sub	r8,-1
8000904c:	fb 49 06 90 	st.w	sp[1680],r9
80009050:	87 05       	st.w	r3[0x0],r5
80009052:	87 12       	st.w	r3[0x4],r2
80009054:	fb 48 06 8c 	st.w	sp[1676],r8
80009058:	58 78       	cp.w	r8,7
8000905a:	e0 89 00 04 	brgt	80009062 <_vfprintf_r+0x1e56>
8000905e:	2f 83       	sub	r3,-8
80009060:	c0 98       	rjmp	80009072 <_vfprintf_r+0x1e66>
80009062:	00 9a       	mov	r10,r0
80009064:	02 9b       	mov	r11,r1
80009066:	08 9c       	mov	r12,r4
80009068:	fe b0 f0 c4 	rcall	800071f0 <__sprint_r>
8000906c:	c4 f1       	brne	8000910a <_vfprintf_r+0x1efe>
8000906e:	fa c3 f9 e0 	sub	r3,sp,-1568
80009072:	21 06       	sub	r6,16
80009074:	c0 68       	rjmp	80009080 <_vfprintf_r+0x1e74>
80009076:	fe c5 c2 32 	sub	r5,pc,-15822
8000907a:	31 02       	mov	r2,16
8000907c:	fa c0 f9 78 	sub	r0,sp,-1672
80009080:	fa f9 06 90 	ld.w	r9,sp[1680]
80009084:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009088:	fe ca c2 44 	sub	r10,pc,-15804
8000908c:	59 06       	cp.w	r6,16
8000908e:	fe 99 ff dd 	brgt	80009048 <_vfprintf_r+0x1e3c>
80009092:	0c 09       	add	r9,r6
80009094:	2f f8       	sub	r8,-1
80009096:	87 0a       	st.w	r3[0x0],r10
80009098:	87 16       	st.w	r3[0x4],r6
8000909a:	fb 49 06 90 	st.w	sp[1680],r9
8000909e:	fb 48 06 8c 	st.w	sp[1676],r8
800090a2:	58 78       	cp.w	r8,7
800090a4:	e0 8a 00 09 	brle	800090b6 <_vfprintf_r+0x1eaa>
800090a8:	fa ca f9 78 	sub	r10,sp,-1672
800090ac:	02 9b       	mov	r11,r1
800090ae:	08 9c       	mov	r12,r4
800090b0:	fe b0 f0 a0 	rcall	800071f0 <__sprint_r>
800090b4:	c2 b1       	brne	8000910a <_vfprintf_r+0x1efe>
800090b6:	40 bc       	lddsp	r12,sp[0x2c]
800090b8:	40 36       	lddsp	r6,sp[0xc]
800090ba:	40 8e       	lddsp	lr,sp[0x20]
800090bc:	ec 0e 0c 48 	max	r8,r6,lr
800090c0:	10 0c       	add	r12,r8
800090c2:	50 bc       	stdsp	sp[0x2c],r12
800090c4:	fa f8 06 90 	ld.w	r8,sp[1680]
800090c8:	58 08       	cp.w	r8,0
800090ca:	c0 80       	breq	800090da <_vfprintf_r+0x1ece>
800090cc:	fa ca f9 78 	sub	r10,sp,-1672
800090d0:	02 9b       	mov	r11,r1
800090d2:	08 9c       	mov	r12,r4
800090d4:	fe b0 f0 8e 	rcall	800071f0 <__sprint_r>
800090d8:	c1 91       	brne	8000910a <_vfprintf_r+0x1efe>
800090da:	30 0b       	mov	r11,0
800090dc:	fa c3 f9 e0 	sub	r3,sp,-1568
800090e0:	fb 4b 06 8c 	st.w	sp[1676],r11
800090e4:	fe 9f f1 22 	bral	80007328 <_vfprintf_r+0x11c>
800090e8:	08 95       	mov	r5,r4
800090ea:	fa f8 06 90 	ld.w	r8,sp[1680]
800090ee:	58 08       	cp.w	r8,0
800090f0:	c0 80       	breq	80009100 <_vfprintf_r+0x1ef4>
800090f2:	08 9c       	mov	r12,r4
800090f4:	fa ca f9 78 	sub	r10,sp,-1672
800090f8:	02 9b       	mov	r11,r1
800090fa:	fe b0 f0 7b 	rcall	800071f0 <__sprint_r>
800090fe:	c0 61       	brne	8000910a <_vfprintf_r+0x1efe>
80009100:	30 08       	mov	r8,0
80009102:	fb 48 06 8c 	st.w	sp[1676],r8
80009106:	c0 28       	rjmp	8000910a <_vfprintf_r+0x1efe>
80009108:	40 41       	lddsp	r1,sp[0x10]
8000910a:	82 68       	ld.sh	r8,r1[0xc]
8000910c:	ed b8 00 06 	bld	r8,0x6
80009110:	c0 31       	brne	80009116 <_vfprintf_r+0x1f0a>
80009112:	3f fa       	mov	r10,-1
80009114:	50 ba       	stdsp	sp[0x2c],r10
80009116:	40 bc       	lddsp	r12,sp[0x2c]
80009118:	fe 3d f9 44 	sub	sp,-1724
8000911c:	d8 32       	popm	r0-r7,pc
8000911e:	d7 03       	nop

80009120 <__swsetup_r>:
80009120:	d4 21       	pushm	r4-r7,lr
80009122:	e0 68 0a 30 	mov	r8,2608
80009126:	18 96       	mov	r6,r12
80009128:	16 97       	mov	r7,r11
8000912a:	70 0c       	ld.w	r12,r8[0x0]
8000912c:	58 0c       	cp.w	r12,0
8000912e:	c0 60       	breq	8000913a <__swsetup_r+0x1a>
80009130:	78 68       	ld.w	r8,r12[0x18]
80009132:	58 08       	cp.w	r8,0
80009134:	c0 31       	brne	8000913a <__swsetup_r+0x1a>
80009136:	e0 a0 07 bf 	rcall	8000a0b4 <__sinit>
8000913a:	fe c8 c1 c6 	sub	r8,pc,-15930
8000913e:	10 37       	cp.w	r7,r8
80009140:	c0 61       	brne	8000914c <__swsetup_r+0x2c>
80009142:	e0 68 0a 30 	mov	r8,2608
80009146:	70 08       	ld.w	r8,r8[0x0]
80009148:	70 07       	ld.w	r7,r8[0x0]
8000914a:	c1 28       	rjmp	8000916e <__swsetup_r+0x4e>
8000914c:	fe c8 c1 b8 	sub	r8,pc,-15944
80009150:	10 37       	cp.w	r7,r8
80009152:	c0 61       	brne	8000915e <__swsetup_r+0x3e>
80009154:	e0 68 0a 30 	mov	r8,2608
80009158:	70 08       	ld.w	r8,r8[0x0]
8000915a:	70 17       	ld.w	r7,r8[0x4]
8000915c:	c0 98       	rjmp	8000916e <__swsetup_r+0x4e>
8000915e:	fe c8 c1 aa 	sub	r8,pc,-15958
80009162:	10 37       	cp.w	r7,r8
80009164:	c0 51       	brne	8000916e <__swsetup_r+0x4e>
80009166:	e0 68 0a 30 	mov	r8,2608
8000916a:	70 08       	ld.w	r8,r8[0x0]
8000916c:	70 27       	ld.w	r7,r8[0x8]
8000916e:	8e 68       	ld.sh	r8,r7[0xc]
80009170:	ed b8 00 03 	bld	r8,0x3
80009174:	c1 e0       	breq	800091b0 <__swsetup_r+0x90>
80009176:	ed b8 00 04 	bld	r8,0x4
8000917a:	c3 e1       	brne	800091f6 <__swsetup_r+0xd6>
8000917c:	ed b8 00 02 	bld	r8,0x2
80009180:	c1 51       	brne	800091aa <__swsetup_r+0x8a>
80009182:	6e db       	ld.w	r11,r7[0x34]
80009184:	58 0b       	cp.w	r11,0
80009186:	c0 a0       	breq	8000919a <__swsetup_r+0x7a>
80009188:	ee c8 ff bc 	sub	r8,r7,-68
8000918c:	10 3b       	cp.w	r11,r8
8000918e:	c0 40       	breq	80009196 <__swsetup_r+0x76>
80009190:	0c 9c       	mov	r12,r6
80009192:	e0 a0 08 2b 	rcall	8000a1e8 <_free_r>
80009196:	30 08       	mov	r8,0
80009198:	8f d8       	st.w	r7[0x34],r8
8000919a:	8e 68       	ld.sh	r8,r7[0xc]
8000919c:	e0 18 ff db 	andl	r8,0xffdb
800091a0:	ae 68       	st.h	r7[0xc],r8
800091a2:	30 08       	mov	r8,0
800091a4:	8f 18       	st.w	r7[0x4],r8
800091a6:	6e 48       	ld.w	r8,r7[0x10]
800091a8:	8f 08       	st.w	r7[0x0],r8
800091aa:	8e 68       	ld.sh	r8,r7[0xc]
800091ac:	a3 b8       	sbr	r8,0x3
800091ae:	ae 68       	st.h	r7[0xc],r8
800091b0:	6e 48       	ld.w	r8,r7[0x10]
800091b2:	58 08       	cp.w	r8,0
800091b4:	c0 b1       	brne	800091ca <__swsetup_r+0xaa>
800091b6:	8e 68       	ld.sh	r8,r7[0xc]
800091b8:	e2 18 02 80 	andl	r8,0x280,COH
800091bc:	e0 48 02 00 	cp.w	r8,512
800091c0:	c0 50       	breq	800091ca <__swsetup_r+0xaa>
800091c2:	0c 9c       	mov	r12,r6
800091c4:	0e 9b       	mov	r11,r7
800091c6:	e0 a0 0a 4b 	rcall	8000a65c <__smakebuf_r>
800091ca:	8e 69       	ld.sh	r9,r7[0xc]
800091cc:	f1 d9 c0 01 	bfextu	r8,r9,0x0,0x1
800091d0:	c0 70       	breq	800091de <__swsetup_r+0xbe>
800091d2:	30 08       	mov	r8,0
800091d4:	8f 28       	st.w	r7[0x8],r8
800091d6:	6e 58       	ld.w	r8,r7[0x14]
800091d8:	5c 38       	neg	r8
800091da:	8f 68       	st.w	r7[0x18],r8
800091dc:	c0 68       	rjmp	800091e8 <__swsetup_r+0xc8>
800091de:	ed b9 00 01 	bld	r9,0x1
800091e2:	ef f8 10 05 	ld.wne	r8,r7[0x14]
800091e6:	8f 28       	st.w	r7[0x8],r8
800091e8:	6e 48       	ld.w	r8,r7[0x10]
800091ea:	58 08       	cp.w	r8,0
800091ec:	c0 61       	brne	800091f8 <__swsetup_r+0xd8>
800091ee:	8e 68       	ld.sh	r8,r7[0xc]
800091f0:	ed b8 00 07 	bld	r8,0x7
800091f4:	c0 21       	brne	800091f8 <__swsetup_r+0xd8>
800091f6:	dc 2a       	popm	r4-r7,pc,r12=-1
800091f8:	d8 2a       	popm	r4-r7,pc,r12=0
800091fa:	d7 03       	nop

800091fc <quorem>:
800091fc:	d4 31       	pushm	r0-r7,lr
800091fe:	20 2d       	sub	sp,8
80009200:	18 97       	mov	r7,r12
80009202:	78 48       	ld.w	r8,r12[0x10]
80009204:	76 46       	ld.w	r6,r11[0x10]
80009206:	0c 38       	cp.w	r8,r6
80009208:	c0 34       	brge	8000920e <quorem+0x12>
8000920a:	30 0c       	mov	r12,0
8000920c:	c8 58       	rjmp	80009316 <quorem+0x11a>
8000920e:	ec c2 ff fc 	sub	r2,r6,-4
80009212:	f6 c3 ff ec 	sub	r3,r11,-20
80009216:	f6 02 03 29 	ld.w	r9,r11[r2<<0x2]
8000921a:	f8 02 03 2c 	ld.w	r12,r12[r2<<0x2]
8000921e:	2f f9       	sub	r9,-1
80009220:	20 16       	sub	r6,1
80009222:	f8 09 0d 08 	divu	r8,r12,r9
80009226:	f6 02 00 22 	add	r2,r11,r2<<0x2
8000922a:	ee c4 ff ec 	sub	r4,r7,-20
8000922e:	10 95       	mov	r5,r8
80009230:	58 08       	cp.w	r8,0
80009232:	c4 10       	breq	800092b4 <quorem+0xb8>
80009234:	30 09       	mov	r9,0
80009236:	06 9a       	mov	r10,r3
80009238:	08 98       	mov	r8,r4
8000923a:	12 91       	mov	r1,r9
8000923c:	50 0b       	stdsp	sp[0x0],r11
8000923e:	70 0e       	ld.w	lr,r8[0x0]
80009240:	b1 8e       	lsr	lr,0x10
80009242:	50 1e       	stdsp	sp[0x4],lr
80009244:	15 0e       	ld.w	lr,r10++
80009246:	fc 00 16 10 	lsr	r0,lr,0x10
8000924a:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000924e:	ea 0e 03 41 	mac	r1,r5,lr
80009252:	fd d1 c0 10 	bfextu	lr,r1,0x0,0x10
80009256:	b1 81       	lsr	r1,0x10
80009258:	40 1b       	lddsp	r11,sp[0x4]
8000925a:	ea 00 02 40 	mul	r0,r5,r0
8000925e:	e2 00 00 00 	add	r0,r1,r0
80009262:	e3 d0 c0 10 	bfextu	r1,r0,0x0,0x10
80009266:	02 1b       	sub	r11,r1
80009268:	50 1b       	stdsp	sp[0x4],r11
8000926a:	70 0b       	ld.w	r11,r8[0x0]
8000926c:	e3 db c0 10 	bfextu	r1,r11,0x0,0x10
80009270:	02 09       	add	r9,r1
80009272:	f2 0e 01 0e 	sub	lr,r9,lr
80009276:	b0 1e       	st.h	r8[0x2],lr
80009278:	fc 09 14 10 	asr	r9,lr,0x10
8000927c:	40 1e       	lddsp	lr,sp[0x4]
8000927e:	fc 09 00 09 	add	r9,lr,r9
80009282:	b0 09       	st.h	r8[0x0],r9
80009284:	e0 01 16 10 	lsr	r1,r0,0x10
80009288:	2f c8       	sub	r8,-4
8000928a:	b1 49       	asr	r9,0x10
8000928c:	04 3a       	cp.w	r10,r2
8000928e:	fe 98 ff d8 	brls	8000923e <quorem+0x42>
80009292:	40 0b       	lddsp	r11,sp[0x0]
80009294:	58 0c       	cp.w	r12,0
80009296:	c0 f1       	brne	800092b4 <quorem+0xb8>
80009298:	ec c8 ff fb 	sub	r8,r6,-5
8000929c:	ee 08 00 28 	add	r8,r7,r8<<0x2
800092a0:	c0 28       	rjmp	800092a4 <quorem+0xa8>
800092a2:	20 16       	sub	r6,1
800092a4:	20 48       	sub	r8,4
800092a6:	08 38       	cp.w	r8,r4
800092a8:	e0 88 00 05 	brls	800092b2 <quorem+0xb6>
800092ac:	70 09       	ld.w	r9,r8[0x0]
800092ae:	58 09       	cp.w	r9,0
800092b0:	cf 90       	breq	800092a2 <quorem+0xa6>
800092b2:	8f 46       	st.w	r7[0x10],r6
800092b4:	0e 9c       	mov	r12,r7
800092b6:	e0 a0 0a d2 	rcall	8000a85a <__mcmp>
800092ba:	c2 d5       	brlt	80009314 <quorem+0x118>
800092bc:	2f f5       	sub	r5,-1
800092be:	08 98       	mov	r8,r4
800092c0:	30 09       	mov	r9,0
800092c2:	07 0b       	ld.w	r11,r3++
800092c4:	f6 0a 16 10 	lsr	r10,r11,0x10
800092c8:	70 0c       	ld.w	r12,r8[0x0]
800092ca:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
800092ce:	f8 0e 16 10 	lsr	lr,r12,0x10
800092d2:	14 1e       	sub	lr,r10
800092d4:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
800092d8:	16 1a       	sub	r10,r11
800092da:	12 0a       	add	r10,r9
800092dc:	b0 1a       	st.h	r8[0x2],r10
800092de:	b1 4a       	asr	r10,0x10
800092e0:	fc 0a 00 09 	add	r9,lr,r10
800092e4:	b0 09       	st.h	r8[0x0],r9
800092e6:	2f c8       	sub	r8,-4
800092e8:	b1 49       	asr	r9,0x10
800092ea:	04 33       	cp.w	r3,r2
800092ec:	fe 98 ff eb 	brls	800092c2 <quorem+0xc6>
800092f0:	ec c8 ff fb 	sub	r8,r6,-5
800092f4:	ee 08 03 29 	ld.w	r9,r7[r8<<0x2]
800092f8:	58 09       	cp.w	r9,0
800092fa:	c0 d1       	brne	80009314 <quorem+0x118>
800092fc:	ee 08 00 28 	add	r8,r7,r8<<0x2
80009300:	c0 28       	rjmp	80009304 <quorem+0x108>
80009302:	20 16       	sub	r6,1
80009304:	20 48       	sub	r8,4
80009306:	08 38       	cp.w	r8,r4
80009308:	e0 88 00 05 	brls	80009312 <quorem+0x116>
8000930c:	70 09       	ld.w	r9,r8[0x0]
8000930e:	58 09       	cp.w	r9,0
80009310:	cf 90       	breq	80009302 <quorem+0x106>
80009312:	8f 46       	st.w	r7[0x10],r6
80009314:	0a 9c       	mov	r12,r5
80009316:	2f ed       	sub	sp,-8
80009318:	d8 32       	popm	r0-r7,pc
8000931a:	d7 03       	nop

8000931c <_dtoa_r>:
8000931c:	d4 31       	pushm	r0-r7,lr
8000931e:	21 ad       	sub	sp,104
80009320:	fa c4 ff 74 	sub	r4,sp,-140
80009324:	18 97       	mov	r7,r12
80009326:	16 95       	mov	r5,r11
80009328:	68 2c       	ld.w	r12,r4[0x8]
8000932a:	50 c9       	stdsp	sp[0x30],r9
8000932c:	68 16       	ld.w	r6,r4[0x4]
8000932e:	68 09       	ld.w	r9,r4[0x0]
80009330:	50 e8       	stdsp	sp[0x38],r8
80009332:	14 94       	mov	r4,r10
80009334:	51 2c       	stdsp	sp[0x48],r12
80009336:	fa e5 00 08 	st.d	sp[8],r4
8000933a:	51 59       	stdsp	sp[0x54],r9
8000933c:	6e 95       	ld.w	r5,r7[0x24]
8000933e:	58 05       	cp.w	r5,0
80009340:	c0 91       	brne	80009352 <_dtoa_r+0x36>
80009342:	31 0c       	mov	r12,16
80009344:	fe b0 e8 e8 	rcall	80006514 <malloc>
80009348:	99 35       	st.w	r12[0xc],r5
8000934a:	8f 9c       	st.w	r7[0x24],r12
8000934c:	99 15       	st.w	r12[0x4],r5
8000934e:	99 25       	st.w	r12[0x8],r5
80009350:	99 05       	st.w	r12[0x0],r5
80009352:	6e 99       	ld.w	r9,r7[0x24]
80009354:	72 08       	ld.w	r8,r9[0x0]
80009356:	58 08       	cp.w	r8,0
80009358:	c0 f0       	breq	80009376 <_dtoa_r+0x5a>
8000935a:	72 1a       	ld.w	r10,r9[0x4]
8000935c:	91 1a       	st.w	r8[0x4],r10
8000935e:	30 1a       	mov	r10,1
80009360:	72 19       	ld.w	r9,r9[0x4]
80009362:	f4 09 09 49 	lsl	r9,r10,r9
80009366:	10 9b       	mov	r11,r8
80009368:	91 29       	st.w	r8[0x8],r9
8000936a:	0e 9c       	mov	r12,r7
8000936c:	e0 a0 0a 90 	rcall	8000a88c <_Bfree>
80009370:	6e 98       	ld.w	r8,r7[0x24]
80009372:	30 09       	mov	r9,0
80009374:	91 09       	st.w	r8[0x0],r9
80009376:	40 28       	lddsp	r8,sp[0x8]
80009378:	10 94       	mov	r4,r8
8000937a:	58 08       	cp.w	r8,0
8000937c:	c0 64       	brge	80009388 <_dtoa_r+0x6c>
8000937e:	f1 d8 c0 1f 	bfextu	r8,r8,0x0,0x1f
80009382:	50 28       	stdsp	sp[0x8],r8
80009384:	30 18       	mov	r8,1
80009386:	c0 28       	rjmp	8000938a <_dtoa_r+0x6e>
80009388:	30 08       	mov	r8,0
8000938a:	8d 08       	st.w	r6[0x0],r8
8000938c:	fc 1c 7f f0 	movh	r12,0x7ff0
80009390:	40 26       	lddsp	r6,sp[0x8]
80009392:	0c 98       	mov	r8,r6
80009394:	e6 18 7f f0 	andh	r8,0x7ff0,COH
80009398:	18 38       	cp.w	r8,r12
8000939a:	c2 01       	brne	800093da <_dtoa_r+0xbe>
8000939c:	e0 68 27 0f 	mov	r8,9999
800093a0:	41 5b       	lddsp	r11,sp[0x54]
800093a2:	97 08       	st.w	r11[0x0],r8
800093a4:	40 3a       	lddsp	r10,sp[0xc]
800093a6:	58 0a       	cp.w	r10,0
800093a8:	c0 71       	brne	800093b6 <_dtoa_r+0x9a>
800093aa:	ed d6 c0 14 	bfextu	r6,r6,0x0,0x14
800093ae:	c0 41       	brne	800093b6 <_dtoa_r+0x9a>
800093b0:	fe cc c4 4c 	sub	r12,pc,-15284
800093b4:	c0 38       	rjmp	800093ba <_dtoa_r+0x9e>
800093b6:	fe cc c4 46 	sub	r12,pc,-15290
800093ba:	41 29       	lddsp	r9,sp[0x48]
800093bc:	58 09       	cp.w	r9,0
800093be:	e0 80 05 9a 	breq	80009ef2 <_dtoa_r+0xbd6>
800093c2:	f8 c8 ff fd 	sub	r8,r12,-3
800093c6:	f8 c9 ff f8 	sub	r9,r12,-8
800093ca:	11 8b       	ld.ub	r11,r8[0x0]
800093cc:	30 0a       	mov	r10,0
800093ce:	41 25       	lddsp	r5,sp[0x48]
800093d0:	f4 0b 18 00 	cp.b	r11,r10
800093d4:	f2 08 17 10 	movne	r8,r9
800093d8:	c1 68       	rjmp	80009404 <_dtoa_r+0xe8>
800093da:	fa ea 00 08 	ld.d	r10,sp[8]
800093de:	30 08       	mov	r8,0
800093e0:	fa eb 00 3c 	st.d	sp[60],r10
800093e4:	30 09       	mov	r9,0
800093e6:	e0 a0 10 c2 	rcall	8000b56a <__avr32_f64_cmp_eq>
800093ea:	c1 00       	breq	8000940a <_dtoa_r+0xee>
800093ec:	30 18       	mov	r8,1
800093ee:	41 5a       	lddsp	r10,sp[0x54]
800093f0:	95 08       	st.w	r10[0x0],r8
800093f2:	fe cc c5 b2 	sub	r12,pc,-14926
800093f6:	41 29       	lddsp	r9,sp[0x48]
800093f8:	f8 08 00 08 	add	r8,r12,r8
800093fc:	58 09       	cp.w	r9,0
800093fe:	e0 80 05 7a 	breq	80009ef2 <_dtoa_r+0xbd6>
80009402:	12 95       	mov	r5,r9
80009404:	8b 08       	st.w	r5[0x0],r8
80009406:	e0 8f 05 76 	bral	80009ef2 <_dtoa_r+0xbd6>
8000940a:	fa c8 ff 9c 	sub	r8,sp,-100
8000940e:	fa c9 ff a0 	sub	r9,sp,-96
80009412:	fa ea 00 3c 	ld.d	r10,sp[60]
80009416:	0e 9c       	mov	r12,r7
80009418:	eb d6 c2 8b 	bfextu	r5,r6,0x14,0xb
8000941c:	e0 a0 0a 8a 	rcall	8000a930 <__d2b>
80009420:	18 93       	mov	r3,r12
80009422:	58 05       	cp.w	r5,0
80009424:	c0 d0       	breq	8000943e <_dtoa_r+0x122>
80009426:	fa ea 00 3c 	ld.d	r10,sp[60]
8000942a:	30 04       	mov	r4,0
8000942c:	f1 db c0 14 	bfextu	r8,r11,0x0,0x14
80009430:	ea c5 03 ff 	sub	r5,r5,1023
80009434:	10 9b       	mov	r11,r8
80009436:	51 74       	stdsp	sp[0x5c],r4
80009438:	ea 1b 3f f0 	orh	r11,0x3ff0
8000943c:	c2 58       	rjmp	80009486 <_dtoa_r+0x16a>
8000943e:	41 88       	lddsp	r8,sp[0x60]
80009440:	41 9c       	lddsp	r12,sp[0x64]
80009442:	10 0c       	add	r12,r8
80009444:	f8 c5 fb ce 	sub	r5,r12,-1074
80009448:	e0 45 00 20 	cp.w	r5,32
8000944c:	e0 8a 00 0e 	brle	80009468 <_dtoa_r+0x14c>
80009450:	f8 cc fb ee 	sub	r12,r12,-1042
80009454:	40 3b       	lddsp	r11,sp[0xc]
80009456:	ea 08 11 40 	rsub	r8,r5,64
8000945a:	f6 0c 0a 4c 	lsr	r12,r11,r12
8000945e:	ec 08 09 46 	lsl	r6,r6,r8
80009462:	0c 4c       	or	r12,r6
80009464:	c0 78       	rjmp	80009472 <_dtoa_r+0x156>
80009466:	d7 03       	nop
80009468:	ea 0c 11 20 	rsub	r12,r5,32
8000946c:	40 3a       	lddsp	r10,sp[0xc]
8000946e:	f4 0c 09 4c 	lsl	r12,r10,r12
80009472:	e0 a0 10 08 	rcall	8000b482 <__avr32_u32_to_f64>
80009476:	fc 18 fe 10 	movh	r8,0xfe10
8000947a:	30 19       	mov	r9,1
8000947c:	ea c5 04 33 	sub	r5,r5,1075
80009480:	f0 0b 00 0b 	add	r11,r8,r11
80009484:	51 79       	stdsp	sp[0x5c],r9
80009486:	30 08       	mov	r8,0
80009488:	fc 19 3f f8 	movh	r9,0x3ff8
8000948c:	e0 a0 0e 90 	rcall	8000b1ac <__avr32_f64_sub>
80009490:	e0 68 43 61 	mov	r8,17249
80009494:	ea 18 63 6f 	orh	r8,0x636f
80009498:	e0 69 87 a7 	mov	r9,34727
8000949c:	ea 19 3f d2 	orh	r9,0x3fd2
800094a0:	e0 a0 0d 9a 	rcall	8000afd4 <__avr32_f64_mul>
800094a4:	e0 68 c8 b3 	mov	r8,51379
800094a8:	ea 18 8b 60 	orh	r8,0x8b60
800094ac:	e0 69 8a 28 	mov	r9,35368
800094b0:	ea 19 3f c6 	orh	r9,0x3fc6
800094b4:	e0 a0 0f 4a 	rcall	8000b348 <__avr32_f64_add>
800094b8:	0a 9c       	mov	r12,r5
800094ba:	14 90       	mov	r0,r10
800094bc:	16 91       	mov	r1,r11
800094be:	e0 a0 0f e6 	rcall	8000b48a <__avr32_s32_to_f64>
800094c2:	e0 68 79 fb 	mov	r8,31227
800094c6:	ea 18 50 9f 	orh	r8,0x509f
800094ca:	e0 69 44 13 	mov	r9,17427
800094ce:	ea 19 3f d3 	orh	r9,0x3fd3
800094d2:	e0 a0 0d 81 	rcall	8000afd4 <__avr32_f64_mul>
800094d6:	14 98       	mov	r8,r10
800094d8:	16 99       	mov	r9,r11
800094da:	00 9a       	mov	r10,r0
800094dc:	02 9b       	mov	r11,r1
800094de:	e0 a0 0f 35 	rcall	8000b348 <__avr32_f64_add>
800094e2:	14 90       	mov	r0,r10
800094e4:	16 91       	mov	r1,r11
800094e6:	e0 a0 0f bb 	rcall	8000b45c <__avr32_f64_to_s32>
800094ea:	30 08       	mov	r8,0
800094ec:	18 96       	mov	r6,r12
800094ee:	30 09       	mov	r9,0
800094f0:	00 9a       	mov	r10,r0
800094f2:	02 9b       	mov	r11,r1
800094f4:	e0 a0 10 82 	rcall	8000b5f8 <__avr32_f64_cmp_lt>
800094f8:	c0 c0       	breq	80009510 <_dtoa_r+0x1f4>
800094fa:	0c 9c       	mov	r12,r6
800094fc:	e0 a0 0f c7 	rcall	8000b48a <__avr32_s32_to_f64>
80009500:	14 98       	mov	r8,r10
80009502:	16 99       	mov	r9,r11
80009504:	00 9a       	mov	r10,r0
80009506:	02 9b       	mov	r11,r1
80009508:	e0 a0 10 31 	rcall	8000b56a <__avr32_f64_cmp_eq>
8000950c:	f7 b6 00 01 	subeq	r6,1
80009510:	59 66       	cp.w	r6,22
80009512:	e0 88 00 05 	brls	8000951c <_dtoa_r+0x200>
80009516:	30 18       	mov	r8,1
80009518:	51 48       	stdsp	sp[0x50],r8
8000951a:	c1 38       	rjmp	80009540 <_dtoa_r+0x224>
8000951c:	fe c8 c4 f8 	sub	r8,pc,-15112
80009520:	fa ea 00 3c 	ld.d	r10,sp[60]
80009524:	f0 06 02 38 	ld.d	r8,r8[r6<<0x3]
80009528:	e0 a0 10 68 	rcall	8000b5f8 <__avr32_f64_cmp_lt>
8000952c:	f9 b4 00 00 	moveq	r4,0
80009530:	fb f4 0a 14 	st.weq	sp[0x50],r4
80009534:	f7 b6 01 01 	subne	r6,1
80009538:	f9 bc 01 00 	movne	r12,0
8000953c:	fb fc 1a 14 	st.wne	sp[0x50],r12
80009540:	41 90       	lddsp	r0,sp[0x64]
80009542:	20 10       	sub	r0,1
80009544:	0a 10       	sub	r0,r5
80009546:	c0 46       	brmi	8000954e <_dtoa_r+0x232>
80009548:	50 40       	stdsp	sp[0x10],r0
8000954a:	30 00       	mov	r0,0
8000954c:	c0 48       	rjmp	80009554 <_dtoa_r+0x238>
8000954e:	30 0b       	mov	r11,0
80009550:	5c 30       	neg	r0
80009552:	50 4b       	stdsp	sp[0x10],r11
80009554:	ec 02 11 00 	rsub	r2,r6,0
80009558:	58 06       	cp.w	r6,0
8000955a:	fb fa 40 04 	ld.wge	r10,sp[0x10]
8000955e:	f5 d6 e4 0a 	addge	r10,r10,r6
80009562:	fb fa 4a 04 	st.wge	sp[0x10],r10
80009566:	fb f6 4a 11 	st.wge	sp[0x44],r6
8000956a:	f9 b2 04 00 	movge	r2,0
8000956e:	e1 d6 e5 10 	sublt	r0,r0,r6
80009572:	f9 b9 05 00 	movlt	r9,0
80009576:	fb f9 5a 11 	st.wlt	sp[0x44],r9
8000957a:	40 c8       	lddsp	r8,sp[0x30]
8000957c:	58 98       	cp.w	r8,9
8000957e:	e0 8b 00 20 	brhi	800095be <_dtoa_r+0x2a2>
80009582:	58 58       	cp.w	r8,5
80009584:	f9 b4 0a 01 	movle	r4,1
80009588:	fb f5 90 0c 	ld.wgt	r5,sp[0x30]
8000958c:	f7 b5 09 04 	subgt	r5,4
80009590:	fb f5 9a 0c 	st.wgt	sp[0x30],r5
80009594:	f9 b4 09 00 	movgt	r4,0
80009598:	40 cc       	lddsp	r12,sp[0x30]
8000959a:	58 3c       	cp.w	r12,3
8000959c:	c2 d0       	breq	800095f6 <_dtoa_r+0x2da>
8000959e:	e0 89 00 05 	brgt	800095a8 <_dtoa_r+0x28c>
800095a2:	58 2c       	cp.w	r12,2
800095a4:	c1 01       	brne	800095c4 <_dtoa_r+0x2a8>
800095a6:	c1 88       	rjmp	800095d6 <_dtoa_r+0x2ba>
800095a8:	40 cb       	lddsp	r11,sp[0x30]
800095aa:	58 4b       	cp.w	r11,4
800095ac:	c0 60       	breq	800095b8 <_dtoa_r+0x29c>
800095ae:	58 5b       	cp.w	r11,5
800095b0:	c0 a1       	brne	800095c4 <_dtoa_r+0x2a8>
800095b2:	30 1a       	mov	r10,1
800095b4:	50 da       	stdsp	sp[0x34],r10
800095b6:	c2 28       	rjmp	800095fa <_dtoa_r+0x2de>
800095b8:	30 19       	mov	r9,1
800095ba:	50 d9       	stdsp	sp[0x34],r9
800095bc:	c0 f8       	rjmp	800095da <_dtoa_r+0x2be>
800095be:	30 08       	mov	r8,0
800095c0:	30 14       	mov	r4,1
800095c2:	50 c8       	stdsp	sp[0x30],r8
800095c4:	3f f5       	mov	r5,-1
800095c6:	30 1c       	mov	r12,1
800095c8:	30 0b       	mov	r11,0
800095ca:	50 95       	stdsp	sp[0x24],r5
800095cc:	50 dc       	stdsp	sp[0x34],r12
800095ce:	0a 91       	mov	r1,r5
800095d0:	31 28       	mov	r8,18
800095d2:	50 eb       	stdsp	sp[0x38],r11
800095d4:	c2 08       	rjmp	80009614 <_dtoa_r+0x2f8>
800095d6:	30 0a       	mov	r10,0
800095d8:	50 da       	stdsp	sp[0x34],r10
800095da:	40 e9       	lddsp	r9,sp[0x38]
800095dc:	58 09       	cp.w	r9,0
800095de:	e0 89 00 07 	brgt	800095ec <_dtoa_r+0x2d0>
800095e2:	30 18       	mov	r8,1
800095e4:	50 98       	stdsp	sp[0x24],r8
800095e6:	10 91       	mov	r1,r8
800095e8:	50 e8       	stdsp	sp[0x38],r8
800095ea:	c1 58       	rjmp	80009614 <_dtoa_r+0x2f8>
800095ec:	40 e5       	lddsp	r5,sp[0x38]
800095ee:	50 95       	stdsp	sp[0x24],r5
800095f0:	0a 91       	mov	r1,r5
800095f2:	0a 98       	mov	r8,r5
800095f4:	c1 08       	rjmp	80009614 <_dtoa_r+0x2f8>
800095f6:	30 0c       	mov	r12,0
800095f8:	50 dc       	stdsp	sp[0x34],r12
800095fa:	40 eb       	lddsp	r11,sp[0x38]
800095fc:	ec 0b 00 0b 	add	r11,r6,r11
80009600:	50 9b       	stdsp	sp[0x24],r11
80009602:	16 98       	mov	r8,r11
80009604:	2f f8       	sub	r8,-1
80009606:	58 08       	cp.w	r8,0
80009608:	e0 89 00 05 	brgt	80009612 <_dtoa_r+0x2f6>
8000960c:	10 91       	mov	r1,r8
8000960e:	30 18       	mov	r8,1
80009610:	c0 28       	rjmp	80009614 <_dtoa_r+0x2f8>
80009612:	10 91       	mov	r1,r8
80009614:	30 09       	mov	r9,0
80009616:	6e 9a       	ld.w	r10,r7[0x24]
80009618:	95 19       	st.w	r10[0x4],r9
8000961a:	30 49       	mov	r9,4
8000961c:	c0 68       	rjmp	80009628 <_dtoa_r+0x30c>
8000961e:	d7 03       	nop
80009620:	6a 1a       	ld.w	r10,r5[0x4]
80009622:	a1 79       	lsl	r9,0x1
80009624:	2f fa       	sub	r10,-1
80009626:	8b 1a       	st.w	r5[0x4],r10
80009628:	6e 95       	ld.w	r5,r7[0x24]
8000962a:	f2 ca ff ec 	sub	r10,r9,-20
8000962e:	10 3a       	cp.w	r10,r8
80009630:	fe 98 ff f8 	brls	80009620 <_dtoa_r+0x304>
80009634:	6a 1b       	ld.w	r11,r5[0x4]
80009636:	0e 9c       	mov	r12,r7
80009638:	e0 a0 09 44 	rcall	8000a8c0 <_Balloc>
8000963c:	58 e1       	cp.w	r1,14
8000963e:	5f 88       	srls	r8
80009640:	8b 0c       	st.w	r5[0x0],r12
80009642:	f1 e4 00 04 	and	r4,r8,r4
80009646:	6e 98       	ld.w	r8,r7[0x24]
80009648:	70 08       	ld.w	r8,r8[0x0]
8000964a:	50 88       	stdsp	sp[0x20],r8
8000964c:	e0 80 01 82 	breq	80009950 <_dtoa_r+0x634>
80009650:	58 06       	cp.w	r6,0
80009652:	e0 8a 00 43 	brle	800096d8 <_dtoa_r+0x3bc>
80009656:	f3 d6 c0 04 	bfextu	r9,r6,0x0,0x4
8000965a:	fe c8 c6 36 	sub	r8,pc,-14794
8000965e:	f0 09 02 34 	ld.d	r4,r8[r9<<0x3]
80009662:	fa e5 00 18 	st.d	sp[24],r4
80009666:	ec 04 14 04 	asr	r4,r6,0x4
8000966a:	ed b4 00 04 	bld	r4,0x4
8000966e:	c0 30       	breq	80009674 <_dtoa_r+0x358>
80009670:	30 25       	mov	r5,2
80009672:	c1 08       	rjmp	80009692 <_dtoa_r+0x376>
80009674:	fe c8 c5 88 	sub	r8,pc,-14968
80009678:	f0 e8 00 20 	ld.d	r8,r8[32]
8000967c:	fa ea 00 3c 	ld.d	r10,sp[60]
80009680:	e9 d4 c0 04 	bfextu	r4,r4,0x0,0x4
80009684:	e0 a0 0f ee 	rcall	8000b660 <__avr32_f64_div>
80009688:	30 35       	mov	r5,3
8000968a:	14 98       	mov	r8,r10
8000968c:	16 99       	mov	r9,r11
8000968e:	fa e9 00 08 	st.d	sp[8],r8
80009692:	fe cc c5 a6 	sub	r12,pc,-14938
80009696:	50 a3       	stdsp	sp[0x28],r3
80009698:	0c 93       	mov	r3,r6
8000969a:	18 96       	mov	r6,r12
8000969c:	c0 f8       	rjmp	800096ba <_dtoa_r+0x39e>
8000969e:	fa ea 00 18 	ld.d	r10,sp[24]
800096a2:	ed b4 00 00 	bld	r4,0x0
800096a6:	c0 81       	brne	800096b6 <_dtoa_r+0x39a>
800096a8:	ec e8 00 00 	ld.d	r8,r6[0]
800096ac:	2f f5       	sub	r5,-1
800096ae:	e0 a0 0c 93 	rcall	8000afd4 <__avr32_f64_mul>
800096b2:	fa eb 00 18 	st.d	sp[24],r10
800096b6:	a1 54       	asr	r4,0x1
800096b8:	2f 86       	sub	r6,-8
800096ba:	58 04       	cp.w	r4,0
800096bc:	cf 11       	brne	8000969e <_dtoa_r+0x382>
800096be:	fa e8 00 18 	ld.d	r8,sp[24]
800096c2:	fa ea 00 08 	ld.d	r10,sp[8]
800096c6:	06 96       	mov	r6,r3
800096c8:	e0 a0 0f cc 	rcall	8000b660 <__avr32_f64_div>
800096cc:	40 a3       	lddsp	r3,sp[0x28]
800096ce:	14 98       	mov	r8,r10
800096d0:	16 99       	mov	r9,r11
800096d2:	fa e9 00 08 	st.d	sp[8],r8
800096d6:	c2 f8       	rjmp	80009734 <_dtoa_r+0x418>
800096d8:	ec 08 11 00 	rsub	r8,r6,0
800096dc:	c0 31       	brne	800096e2 <_dtoa_r+0x3c6>
800096de:	30 25       	mov	r5,2
800096e0:	c2 a8       	rjmp	80009734 <_dtoa_r+0x418>
800096e2:	fe cc c5 f6 	sub	r12,pc,-14858
800096e6:	f0 04 14 04 	asr	r4,r8,0x4
800096ea:	50 1c       	stdsp	sp[0x4],r12
800096ec:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
800096f0:	fe c9 c6 cc 	sub	r9,pc,-14644
800096f4:	fa ea 00 3c 	ld.d	r10,sp[60]
800096f8:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
800096fc:	e0 a0 0c 6c 	rcall	8000afd4 <__avr32_f64_mul>
80009700:	40 1c       	lddsp	r12,sp[0x4]
80009702:	50 63       	stdsp	sp[0x18],r3
80009704:	30 25       	mov	r5,2
80009706:	0c 93       	mov	r3,r6
80009708:	fa eb 00 08 	st.d	sp[8],r10
8000970c:	18 96       	mov	r6,r12
8000970e:	c0 f8       	rjmp	8000972c <_dtoa_r+0x410>
80009710:	fa ea 00 08 	ld.d	r10,sp[8]
80009714:	ed b4 00 00 	bld	r4,0x0
80009718:	c0 81       	brne	80009728 <_dtoa_r+0x40c>
8000971a:	ec e8 00 00 	ld.d	r8,r6[0]
8000971e:	2f f5       	sub	r5,-1
80009720:	e0 a0 0c 5a 	rcall	8000afd4 <__avr32_f64_mul>
80009724:	fa eb 00 08 	st.d	sp[8],r10
80009728:	a1 54       	asr	r4,0x1
8000972a:	2f 86       	sub	r6,-8
8000972c:	58 04       	cp.w	r4,0
8000972e:	cf 11       	brne	80009710 <_dtoa_r+0x3f4>
80009730:	06 96       	mov	r6,r3
80009732:	40 63       	lddsp	r3,sp[0x18]
80009734:	41 4a       	lddsp	r10,sp[0x50]
80009736:	58 0a       	cp.w	r10,0
80009738:	c2 a0       	breq	8000978c <_dtoa_r+0x470>
8000973a:	fa e8 00 08 	ld.d	r8,sp[8]
8000973e:	58 01       	cp.w	r1,0
80009740:	5f 94       	srgt	r4
80009742:	fa e9 00 18 	st.d	sp[24],r8
80009746:	30 08       	mov	r8,0
80009748:	fc 19 3f f0 	movh	r9,0x3ff0
8000974c:	fa ea 00 18 	ld.d	r10,sp[24]
80009750:	e0 a0 0f 54 	rcall	8000b5f8 <__avr32_f64_cmp_lt>
80009754:	f9 bc 00 00 	moveq	r12,0
80009758:	f9 bc 01 01 	movne	r12,1
8000975c:	e9 ec 00 0c 	and	r12,r4,r12
80009760:	c1 60       	breq	8000978c <_dtoa_r+0x470>
80009762:	40 98       	lddsp	r8,sp[0x24]
80009764:	58 08       	cp.w	r8,0
80009766:	e0 8a 00 f1 	brle	80009948 <_dtoa_r+0x62c>
8000976a:	30 08       	mov	r8,0
8000976c:	fc 19 40 24 	movh	r9,0x4024
80009770:	ec c4 00 01 	sub	r4,r6,1
80009774:	fa ea 00 18 	ld.d	r10,sp[24]
80009778:	2f f5       	sub	r5,-1
8000977a:	50 64       	stdsp	sp[0x18],r4
8000977c:	e0 a0 0c 2c 	rcall	8000afd4 <__avr32_f64_mul>
80009780:	40 94       	lddsp	r4,sp[0x24]
80009782:	14 98       	mov	r8,r10
80009784:	16 99       	mov	r9,r11
80009786:	fa e9 00 08 	st.d	sp[8],r8
8000978a:	c0 38       	rjmp	80009790 <_dtoa_r+0x474>
8000978c:	50 66       	stdsp	sp[0x18],r6
8000978e:	02 94       	mov	r4,r1
80009790:	0a 9c       	mov	r12,r5
80009792:	e0 a0 0e 7c 	rcall	8000b48a <__avr32_s32_to_f64>
80009796:	fa e8 00 08 	ld.d	r8,sp[8]
8000979a:	e0 a0 0c 1d 	rcall	8000afd4 <__avr32_f64_mul>
8000979e:	30 08       	mov	r8,0
800097a0:	fc 19 40 1c 	movh	r9,0x401c
800097a4:	e0 a0 0d d2 	rcall	8000b348 <__avr32_f64_add>
800097a8:	14 98       	mov	r8,r10
800097aa:	16 99       	mov	r9,r11
800097ac:	fa e9 00 28 	st.d	sp[40],r8
800097b0:	fc 18 fc c0 	movh	r8,0xfcc0
800097b4:	40 a5       	lddsp	r5,sp[0x28]
800097b6:	10 05       	add	r5,r8
800097b8:	50 a5       	stdsp	sp[0x28],r5
800097ba:	58 04       	cp.w	r4,0
800097bc:	c2 11       	brne	800097fe <_dtoa_r+0x4e2>
800097be:	fa ea 00 08 	ld.d	r10,sp[8]
800097c2:	30 08       	mov	r8,0
800097c4:	fc 19 40 14 	movh	r9,0x4014
800097c8:	e0 a0 0c f2 	rcall	8000b1ac <__avr32_f64_sub>
800097cc:	40 bc       	lddsp	r12,sp[0x2c]
800097ce:	fa eb 00 08 	st.d	sp[8],r10
800097d2:	14 98       	mov	r8,r10
800097d4:	16 99       	mov	r9,r11
800097d6:	18 9a       	mov	r10,r12
800097d8:	0a 9b       	mov	r11,r5
800097da:	e0 a0 0f 0f 	rcall	8000b5f8 <__avr32_f64_cmp_lt>
800097de:	e0 81 02 54 	brne	80009c86 <_dtoa_r+0x96a>
800097e2:	0a 98       	mov	r8,r5
800097e4:	40 b9       	lddsp	r9,sp[0x2c]
800097e6:	ee 18 80 00 	eorh	r8,0x8000
800097ea:	fa ea 00 08 	ld.d	r10,sp[8]
800097ee:	10 95       	mov	r5,r8
800097f0:	12 98       	mov	r8,r9
800097f2:	0a 99       	mov	r9,r5
800097f4:	e0 a0 0f 02 	rcall	8000b5f8 <__avr32_f64_cmp_lt>
800097f8:	e0 81 02 3e 	brne	80009c74 <_dtoa_r+0x958>
800097fc:	ca 68       	rjmp	80009948 <_dtoa_r+0x62c>
800097fe:	fe c9 c7 da 	sub	r9,pc,-14374
80009802:	e8 c8 00 01 	sub	r8,r4,1
80009806:	40 d5       	lddsp	r5,sp[0x34]
80009808:	58 05       	cp.w	r5,0
8000980a:	c4 f0       	breq	800098a8 <_dtoa_r+0x58c>
8000980c:	30 0c       	mov	r12,0
8000980e:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
80009812:	51 3c       	stdsp	sp[0x4c],r12
80009814:	30 0a       	mov	r10,0
80009816:	fc 1b 3f e0 	movh	r11,0x3fe0
8000981a:	e0 a0 0f 23 	rcall	8000b660 <__avr32_f64_div>
8000981e:	fa e8 00 28 	ld.d	r8,sp[40]
80009822:	40 85       	lddsp	r5,sp[0x20]
80009824:	e0 a0 0c c4 	rcall	8000b1ac <__avr32_f64_sub>
80009828:	fa eb 00 28 	st.d	sp[40],r10
8000982c:	fa ea 00 08 	ld.d	r10,sp[8]
80009830:	e0 a0 0e 16 	rcall	8000b45c <__avr32_f64_to_s32>
80009834:	51 6c       	stdsp	sp[0x58],r12
80009836:	e0 a0 0e 2a 	rcall	8000b48a <__avr32_s32_to_f64>
8000983a:	14 98       	mov	r8,r10
8000983c:	16 99       	mov	r9,r11
8000983e:	fa ea 00 08 	ld.d	r10,sp[8]
80009842:	e0 a0 0c b5 	rcall	8000b1ac <__avr32_f64_sub>
80009846:	fa eb 00 08 	st.d	sp[8],r10
8000984a:	41 68       	lddsp	r8,sp[0x58]
8000984c:	2d 08       	sub	r8,-48
8000984e:	0a c8       	st.b	r5++,r8
80009850:	41 39       	lddsp	r9,sp[0x4c]
80009852:	2f f9       	sub	r9,-1
80009854:	51 39       	stdsp	sp[0x4c],r9
80009856:	fa e8 00 28 	ld.d	r8,sp[40]
8000985a:	e0 a0 0e cf 	rcall	8000b5f8 <__avr32_f64_cmp_lt>
8000985e:	e0 81 03 39 	brne	80009ed0 <_dtoa_r+0xbb4>
80009862:	fa e8 00 08 	ld.d	r8,sp[8]
80009866:	30 0a       	mov	r10,0
80009868:	fc 1b 3f f0 	movh	r11,0x3ff0
8000986c:	e0 a0 0c a0 	rcall	8000b1ac <__avr32_f64_sub>
80009870:	fa e8 00 28 	ld.d	r8,sp[40]
80009874:	e0 a0 0e c2 	rcall	8000b5f8 <__avr32_f64_cmp_lt>
80009878:	fa ea 00 28 	ld.d	r10,sp[40]
8000987c:	30 08       	mov	r8,0
8000987e:	fc 19 40 24 	movh	r9,0x4024
80009882:	e0 81 00 da 	brne	80009a36 <_dtoa_r+0x71a>
80009886:	41 3c       	lddsp	r12,sp[0x4c]
80009888:	08 3c       	cp.w	r12,r4
8000988a:	c5 f4       	brge	80009948 <_dtoa_r+0x62c>
8000988c:	e0 a0 0b a4 	rcall	8000afd4 <__avr32_f64_mul>
80009890:	30 08       	mov	r8,0
80009892:	fa eb 00 28 	st.d	sp[40],r10
80009896:	fc 19 40 24 	movh	r9,0x4024
8000989a:	fa ea 00 08 	ld.d	r10,sp[8]
8000989e:	e0 a0 0b 9b 	rcall	8000afd4 <__avr32_f64_mul>
800098a2:	fa eb 00 08 	st.d	sp[8],r10
800098a6:	cc 3b       	rjmp	8000982c <_dtoa_r+0x510>
800098a8:	40 85       	lddsp	r5,sp[0x20]
800098aa:	08 05       	add	r5,r4
800098ac:	f2 08 02 3a 	ld.d	r10,r9[r8<<0x3]
800098b0:	51 35       	stdsp	sp[0x4c],r5
800098b2:	fa e8 00 28 	ld.d	r8,sp[40]
800098b6:	40 85       	lddsp	r5,sp[0x20]
800098b8:	e0 a0 0b 8e 	rcall	8000afd4 <__avr32_f64_mul>
800098bc:	fa eb 00 28 	st.d	sp[40],r10
800098c0:	fa ea 00 08 	ld.d	r10,sp[8]
800098c4:	e0 a0 0d cc 	rcall	8000b45c <__avr32_f64_to_s32>
800098c8:	51 6c       	stdsp	sp[0x58],r12
800098ca:	e0 a0 0d e0 	rcall	8000b48a <__avr32_s32_to_f64>
800098ce:	14 98       	mov	r8,r10
800098d0:	16 99       	mov	r9,r11
800098d2:	fa ea 00 08 	ld.d	r10,sp[8]
800098d6:	e0 a0 0c 6b 	rcall	8000b1ac <__avr32_f64_sub>
800098da:	fa eb 00 08 	st.d	sp[8],r10
800098de:	41 68       	lddsp	r8,sp[0x58]
800098e0:	2d 08       	sub	r8,-48
800098e2:	0a c8       	st.b	r5++,r8
800098e4:	41 3c       	lddsp	r12,sp[0x4c]
800098e6:	18 35       	cp.w	r5,r12
800098e8:	c2 81       	brne	80009938 <_dtoa_r+0x61c>
800098ea:	30 08       	mov	r8,0
800098ec:	fc 19 3f e0 	movh	r9,0x3fe0
800098f0:	fa ea 00 28 	ld.d	r10,sp[40]
800098f4:	e0 a0 0d 2a 	rcall	8000b348 <__avr32_f64_add>
800098f8:	40 85       	lddsp	r5,sp[0x20]
800098fa:	fa e8 00 08 	ld.d	r8,sp[8]
800098fe:	08 05       	add	r5,r4
80009900:	e0 a0 0e 7c 	rcall	8000b5f8 <__avr32_f64_cmp_lt>
80009904:	e0 81 00 99 	brne	80009a36 <_dtoa_r+0x71a>
80009908:	fa e8 00 28 	ld.d	r8,sp[40]
8000990c:	30 0a       	mov	r10,0
8000990e:	fc 1b 3f e0 	movh	r11,0x3fe0
80009912:	e0 a0 0c 4d 	rcall	8000b1ac <__avr32_f64_sub>
80009916:	14 98       	mov	r8,r10
80009918:	16 99       	mov	r9,r11
8000991a:	fa ea 00 08 	ld.d	r10,sp[8]
8000991e:	e0 a0 0e 6d 	rcall	8000b5f8 <__avr32_f64_cmp_lt>
80009922:	c1 30       	breq	80009948 <_dtoa_r+0x62c>
80009924:	33 09       	mov	r9,48
80009926:	0a 98       	mov	r8,r5
80009928:	11 7a       	ld.ub	r10,--r8
8000992a:	f2 0a 18 00 	cp.b	r10,r9
8000992e:	e0 81 02 d1 	brne	80009ed0 <_dtoa_r+0xbb4>
80009932:	10 95       	mov	r5,r8
80009934:	cf 9b       	rjmp	80009926 <_dtoa_r+0x60a>
80009936:	d7 03       	nop
80009938:	30 08       	mov	r8,0
8000993a:	fc 19 40 24 	movh	r9,0x4024
8000993e:	e0 a0 0b 4b 	rcall	8000afd4 <__avr32_f64_mul>
80009942:	fa eb 00 08 	st.d	sp[8],r10
80009946:	cb db       	rjmp	800098c0 <_dtoa_r+0x5a4>
80009948:	fa ea 00 3c 	ld.d	r10,sp[60]
8000994c:	fa eb 00 08 	st.d	sp[8],r10
80009950:	58 e6       	cp.w	r6,14
80009952:	5f ab       	srle	r11
80009954:	41 8a       	lddsp	r10,sp[0x60]
80009956:	30 08       	mov	r8,0
80009958:	f4 09 11 ff 	rsub	r9,r10,-1
8000995c:	f7 e9 03 f9 	and	r9,r11,r9>>0x1f
80009960:	f0 09 18 00 	cp.b	r9,r8
80009964:	e0 80 00 82 	breq	80009a68 <_dtoa_r+0x74c>
80009968:	40 ea       	lddsp	r10,sp[0x38]
8000996a:	58 01       	cp.w	r1,0
8000996c:	5f a9       	srle	r9
8000996e:	f3 ea 03 f9 	and	r9,r9,r10>>0x1f
80009972:	fe ca c9 4e 	sub	r10,pc,-14002
80009976:	f4 06 02 34 	ld.d	r4,r10[r6<<0x3]
8000997a:	fa e5 00 10 	st.d	sp[16],r4
8000997e:	f0 09 18 00 	cp.b	r9,r8
80009982:	c1 40       	breq	800099aa <_dtoa_r+0x68e>
80009984:	58 01       	cp.w	r1,0
80009986:	e0 81 01 77 	brne	80009c74 <_dtoa_r+0x958>
8000998a:	30 08       	mov	r8,0
8000998c:	fc 19 40 14 	movh	r9,0x4014
80009990:	08 9a       	mov	r10,r4
80009992:	0a 9b       	mov	r11,r5
80009994:	e0 a0 0b 20 	rcall	8000afd4 <__avr32_f64_mul>
80009998:	fa e8 00 08 	ld.d	r8,sp[8]
8000999c:	e0 a0 0d fa 	rcall	8000b590 <__avr32_f64_cmp_ge>
800099a0:	e0 81 01 6a 	brne	80009c74 <_dtoa_r+0x958>
800099a4:	02 92       	mov	r2,r1
800099a6:	e0 8f 01 72 	bral	80009c8a <_dtoa_r+0x96e>
800099aa:	40 85       	lddsp	r5,sp[0x20]
800099ac:	30 14       	mov	r4,1
800099ae:	fa e8 00 10 	ld.d	r8,sp[16]
800099b2:	fa ea 00 08 	ld.d	r10,sp[8]
800099b6:	e0 a0 0e 55 	rcall	8000b660 <__avr32_f64_div>
800099ba:	e0 a0 0d 51 	rcall	8000b45c <__avr32_f64_to_s32>
800099be:	18 92       	mov	r2,r12
800099c0:	e0 a0 0d 65 	rcall	8000b48a <__avr32_s32_to_f64>
800099c4:	fa e8 00 10 	ld.d	r8,sp[16]
800099c8:	e0 a0 0b 06 	rcall	8000afd4 <__avr32_f64_mul>
800099cc:	14 98       	mov	r8,r10
800099ce:	16 99       	mov	r9,r11
800099d0:	fa ea 00 08 	ld.d	r10,sp[8]
800099d4:	e0 a0 0b ec 	rcall	8000b1ac <__avr32_f64_sub>
800099d8:	fa eb 00 08 	st.d	sp[8],r10
800099dc:	e4 c8 ff d0 	sub	r8,r2,-48
800099e0:	0a c8       	st.b	r5++,r8
800099e2:	fc 19 40 24 	movh	r9,0x4024
800099e6:	30 08       	mov	r8,0
800099e8:	02 34       	cp.w	r4,r1
800099ea:	c3 31       	brne	80009a50 <_dtoa_r+0x734>
800099ec:	fa e8 00 08 	ld.d	r8,sp[8]
800099f0:	e0 a0 0c ac 	rcall	8000b348 <__avr32_f64_add>
800099f4:	16 91       	mov	r1,r11
800099f6:	14 90       	mov	r0,r10
800099f8:	14 98       	mov	r8,r10
800099fa:	02 99       	mov	r9,r1
800099fc:	fa ea 00 10 	ld.d	r10,sp[16]
80009a00:	e0 a0 0d fc 	rcall	8000b5f8 <__avr32_f64_cmp_lt>
80009a04:	c1 a1       	brne	80009a38 <_dtoa_r+0x71c>
80009a06:	fa e8 00 10 	ld.d	r8,sp[16]
80009a0a:	00 9a       	mov	r10,r0
80009a0c:	02 9b       	mov	r11,r1
80009a0e:	e0 a0 0d ae 	rcall	8000b56a <__avr32_f64_cmp_eq>
80009a12:	e0 80 02 5e 	breq	80009ece <_dtoa_r+0xbb2>
80009a16:	e5 d2 c0 01 	bfextu	r2,r2,0x0,0x1
80009a1a:	c0 f1       	brne	80009a38 <_dtoa_r+0x71c>
80009a1c:	e0 8f 02 59 	bral	80009ece <_dtoa_r+0xbb2>
80009a20:	40 8a       	lddsp	r10,sp[0x20]
80009a22:	14 38       	cp.w	r8,r10
80009a24:	c0 30       	breq	80009a2a <_dtoa_r+0x70e>
80009a26:	10 95       	mov	r5,r8
80009a28:	c0 98       	rjmp	80009a3a <_dtoa_r+0x71e>
80009a2a:	33 08       	mov	r8,48
80009a2c:	40 89       	lddsp	r9,sp[0x20]
80009a2e:	2f f6       	sub	r6,-1
80009a30:	b2 88       	st.b	r9[0x0],r8
80009a32:	40 88       	lddsp	r8,sp[0x20]
80009a34:	c0 88       	rjmp	80009a44 <_dtoa_r+0x728>
80009a36:	40 66       	lddsp	r6,sp[0x18]
80009a38:	33 99       	mov	r9,57
80009a3a:	0a 98       	mov	r8,r5
80009a3c:	11 7a       	ld.ub	r10,--r8
80009a3e:	f2 0a 18 00 	cp.b	r10,r9
80009a42:	ce f0       	breq	80009a20 <_dtoa_r+0x704>
80009a44:	50 66       	stdsp	sp[0x18],r6
80009a46:	11 89       	ld.ub	r9,r8[0x0]
80009a48:	2f f9       	sub	r9,-1
80009a4a:	b0 89       	st.b	r8[0x0],r9
80009a4c:	e0 8f 02 42 	bral	80009ed0 <_dtoa_r+0xbb4>
80009a50:	e0 a0 0a c2 	rcall	8000afd4 <__avr32_f64_mul>
80009a54:	2f f4       	sub	r4,-1
80009a56:	fa eb 00 08 	st.d	sp[8],r10
80009a5a:	30 08       	mov	r8,0
80009a5c:	30 09       	mov	r9,0
80009a5e:	e0 a0 0d 86 	rcall	8000b56a <__avr32_f64_cmp_eq>
80009a62:	ca 60       	breq	800099ae <_dtoa_r+0x692>
80009a64:	e0 8f 02 35 	bral	80009ece <_dtoa_r+0xbb2>
80009a68:	40 d8       	lddsp	r8,sp[0x34]
80009a6a:	58 08       	cp.w	r8,0
80009a6c:	c0 51       	brne	80009a76 <_dtoa_r+0x75a>
80009a6e:	04 98       	mov	r8,r2
80009a70:	00 95       	mov	r5,r0
80009a72:	40 d4       	lddsp	r4,sp[0x34]
80009a74:	c3 78       	rjmp	80009ae2 <_dtoa_r+0x7c6>
80009a76:	40 c5       	lddsp	r5,sp[0x30]
80009a78:	58 15       	cp.w	r5,1
80009a7a:	e0 89 00 0f 	brgt	80009a98 <_dtoa_r+0x77c>
80009a7e:	41 74       	lddsp	r4,sp[0x5c]
80009a80:	58 04       	cp.w	r4,0
80009a82:	c0 40       	breq	80009a8a <_dtoa_r+0x76e>
80009a84:	f4 c9 fb cd 	sub	r9,r10,-1075
80009a88:	c0 48       	rjmp	80009a90 <_dtoa_r+0x774>
80009a8a:	41 99       	lddsp	r9,sp[0x64]
80009a8c:	f2 09 11 36 	rsub	r9,r9,54
80009a90:	04 98       	mov	r8,r2
80009a92:	00 95       	mov	r5,r0
80009a94:	c1 c8       	rjmp	80009acc <_dtoa_r+0x7b0>
80009a96:	d7 03       	nop
80009a98:	e2 c8 00 01 	sub	r8,r1,1
80009a9c:	58 01       	cp.w	r1,0
80009a9e:	e0 05 17 40 	movge	r5,r0
80009aa2:	e2 09 17 40 	movge	r9,r1
80009aa6:	e1 d1 e5 15 	sublt	r5,r0,r1
80009aaa:	f9 b9 05 00 	movlt	r9,0
80009aae:	10 32       	cp.w	r2,r8
80009ab0:	e5 d8 e4 18 	subge	r8,r2,r8
80009ab4:	f1 d2 e5 18 	sublt	r8,r8,r2
80009ab8:	e5 d8 e5 02 	addlt	r2,r2,r8
80009abc:	fb fc 50 11 	ld.wlt	r12,sp[0x44]
80009ac0:	f9 d8 e5 0c 	addlt	r12,r12,r8
80009ac4:	fb fc 5a 11 	st.wlt	sp[0x44],r12
80009ac8:	f9 b8 05 00 	movlt	r8,0
80009acc:	40 4b       	lddsp	r11,sp[0x10]
80009ace:	12 0b       	add	r11,r9
80009ad0:	50 08       	stdsp	sp[0x0],r8
80009ad2:	50 4b       	stdsp	sp[0x10],r11
80009ad4:	12 00       	add	r0,r9
80009ad6:	30 1b       	mov	r11,1
80009ad8:	0e 9c       	mov	r12,r7
80009ada:	e0 a0 08 a7 	rcall	8000ac28 <__i2b>
80009ade:	40 08       	lddsp	r8,sp[0x0]
80009ae0:	18 94       	mov	r4,r12
80009ae2:	40 4a       	lddsp	r10,sp[0x10]
80009ae4:	58 05       	cp.w	r5,0
80009ae6:	5f 99       	srgt	r9
80009ae8:	58 0a       	cp.w	r10,0
80009aea:	5f 9a       	srgt	r10
80009aec:	f5 e9 00 09 	and	r9,r10,r9
80009af0:	c0 80       	breq	80009b00 <_dtoa_r+0x7e4>
80009af2:	40 4c       	lddsp	r12,sp[0x10]
80009af4:	f8 05 0d 49 	min	r9,r12,r5
80009af8:	12 1c       	sub	r12,r9
80009afa:	12 10       	sub	r0,r9
80009afc:	50 4c       	stdsp	sp[0x10],r12
80009afe:	12 15       	sub	r5,r9
80009b00:	58 02       	cp.w	r2,0
80009b02:	e0 8a 00 27 	brle	80009b50 <_dtoa_r+0x834>
80009b06:	40 db       	lddsp	r11,sp[0x34]
80009b08:	58 0b       	cp.w	r11,0
80009b0a:	c1 d0       	breq	80009b44 <_dtoa_r+0x828>
80009b0c:	58 08       	cp.w	r8,0
80009b0e:	e0 8a 00 17 	brle	80009b3c <_dtoa_r+0x820>
80009b12:	10 9a       	mov	r10,r8
80009b14:	50 08       	stdsp	sp[0x0],r8
80009b16:	08 9b       	mov	r11,r4
80009b18:	0e 9c       	mov	r12,r7
80009b1a:	e0 a0 08 cd 	rcall	8000acb4 <__pow5mult>
80009b1e:	06 9a       	mov	r10,r3
80009b20:	18 9b       	mov	r11,r12
80009b22:	18 94       	mov	r4,r12
80009b24:	0e 9c       	mov	r12,r7
80009b26:	e0 a0 08 01 	rcall	8000ab28 <__multiply>
80009b2a:	18 99       	mov	r9,r12
80009b2c:	06 9b       	mov	r11,r3
80009b2e:	50 19       	stdsp	sp[0x4],r9
80009b30:	0e 9c       	mov	r12,r7
80009b32:	e0 a0 06 ad 	rcall	8000a88c <_Bfree>
80009b36:	40 19       	lddsp	r9,sp[0x4]
80009b38:	40 08       	lddsp	r8,sp[0x0]
80009b3a:	12 93       	mov	r3,r9
80009b3c:	e4 08 01 0a 	sub	r10,r2,r8
80009b40:	c0 80       	breq	80009b50 <_dtoa_r+0x834>
80009b42:	c0 28       	rjmp	80009b46 <_dtoa_r+0x82a>
80009b44:	04 9a       	mov	r10,r2
80009b46:	06 9b       	mov	r11,r3
80009b48:	0e 9c       	mov	r12,r7
80009b4a:	e0 a0 08 b5 	rcall	8000acb4 <__pow5mult>
80009b4e:	18 93       	mov	r3,r12
80009b50:	30 1b       	mov	r11,1
80009b52:	0e 9c       	mov	r12,r7
80009b54:	e0 a0 08 6a 	rcall	8000ac28 <__i2b>
80009b58:	41 1a       	lddsp	r10,sp[0x44]
80009b5a:	18 92       	mov	r2,r12
80009b5c:	58 0a       	cp.w	r10,0
80009b5e:	e0 8a 00 07 	brle	80009b6c <_dtoa_r+0x850>
80009b62:	18 9b       	mov	r11,r12
80009b64:	0e 9c       	mov	r12,r7
80009b66:	e0 a0 08 a7 	rcall	8000acb4 <__pow5mult>
80009b6a:	18 92       	mov	r2,r12
80009b6c:	40 c9       	lddsp	r9,sp[0x30]
80009b6e:	58 19       	cp.w	r9,1
80009b70:	e0 89 00 14 	brgt	80009b98 <_dtoa_r+0x87c>
80009b74:	40 38       	lddsp	r8,sp[0xc]
80009b76:	58 08       	cp.w	r8,0
80009b78:	c1 01       	brne	80009b98 <_dtoa_r+0x87c>
80009b7a:	40 29       	lddsp	r9,sp[0x8]
80009b7c:	f1 d9 c0 14 	bfextu	r8,r9,0x0,0x14
80009b80:	c0 c1       	brne	80009b98 <_dtoa_r+0x87c>
80009b82:	12 98       	mov	r8,r9
80009b84:	e6 18 7f f0 	andh	r8,0x7ff0,COH
80009b88:	c0 80       	breq	80009b98 <_dtoa_r+0x87c>
80009b8a:	40 4c       	lddsp	r12,sp[0x10]
80009b8c:	30 1b       	mov	r11,1
80009b8e:	2f fc       	sub	r12,-1
80009b90:	2f f0       	sub	r0,-1
80009b92:	50 4c       	stdsp	sp[0x10],r12
80009b94:	50 6b       	stdsp	sp[0x18],r11
80009b96:	c0 38       	rjmp	80009b9c <_dtoa_r+0x880>
80009b98:	30 0a       	mov	r10,0
80009b9a:	50 6a       	stdsp	sp[0x18],r10
80009b9c:	41 19       	lddsp	r9,sp[0x44]
80009b9e:	58 09       	cp.w	r9,0
80009ba0:	c0 31       	brne	80009ba6 <_dtoa_r+0x88a>
80009ba2:	30 1c       	mov	r12,1
80009ba4:	c0 98       	rjmp	80009bb6 <_dtoa_r+0x89a>
80009ba6:	64 48       	ld.w	r8,r2[0x10]
80009ba8:	2f c8       	sub	r8,-4
80009baa:	e4 08 03 2c 	ld.w	r12,r2[r8<<0x2]
80009bae:	e0 a0 05 df 	rcall	8000a76c <__hi0bits>
80009bb2:	f8 0c 11 20 	rsub	r12,r12,32
80009bb6:	40 4b       	lddsp	r11,sp[0x10]
80009bb8:	f8 0b 00 08 	add	r8,r12,r11
80009bbc:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80009bc0:	c0 c0       	breq	80009bd8 <_dtoa_r+0x8bc>
80009bc2:	f0 08 11 20 	rsub	r8,r8,32
80009bc6:	58 48       	cp.w	r8,4
80009bc8:	e0 8a 00 06 	brle	80009bd4 <_dtoa_r+0x8b8>
80009bcc:	20 48       	sub	r8,4
80009bce:	10 0b       	add	r11,r8
80009bd0:	50 4b       	stdsp	sp[0x10],r11
80009bd2:	c0 78       	rjmp	80009be0 <_dtoa_r+0x8c4>
80009bd4:	58 48       	cp.w	r8,4
80009bd6:	c0 70       	breq	80009be4 <_dtoa_r+0x8c8>
80009bd8:	40 4a       	lddsp	r10,sp[0x10]
80009bda:	2e 48       	sub	r8,-28
80009bdc:	10 0a       	add	r10,r8
80009bde:	50 4a       	stdsp	sp[0x10],r10
80009be0:	10 00       	add	r0,r8
80009be2:	10 05       	add	r5,r8
80009be4:	58 00       	cp.w	r0,0
80009be6:	e0 8a 00 08 	brle	80009bf6 <_dtoa_r+0x8da>
80009bea:	06 9b       	mov	r11,r3
80009bec:	00 9a       	mov	r10,r0
80009bee:	0e 9c       	mov	r12,r7
80009bf0:	e0 a0 07 58 	rcall	8000aaa0 <__lshift>
80009bf4:	18 93       	mov	r3,r12
80009bf6:	40 49       	lddsp	r9,sp[0x10]
80009bf8:	58 09       	cp.w	r9,0
80009bfa:	e0 8a 00 08 	brle	80009c0a <_dtoa_r+0x8ee>
80009bfe:	04 9b       	mov	r11,r2
80009c00:	12 9a       	mov	r10,r9
80009c02:	0e 9c       	mov	r12,r7
80009c04:	e0 a0 07 4e 	rcall	8000aaa0 <__lshift>
80009c08:	18 92       	mov	r2,r12
80009c0a:	41 48       	lddsp	r8,sp[0x50]
80009c0c:	58 08       	cp.w	r8,0
80009c0e:	c1 b0       	breq	80009c44 <_dtoa_r+0x928>
80009c10:	04 9b       	mov	r11,r2
80009c12:	06 9c       	mov	r12,r3
80009c14:	e0 a0 06 23 	rcall	8000a85a <__mcmp>
80009c18:	c1 64       	brge	80009c44 <_dtoa_r+0x928>
80009c1a:	06 9b       	mov	r11,r3
80009c1c:	30 09       	mov	r9,0
80009c1e:	30 aa       	mov	r10,10
80009c20:	0e 9c       	mov	r12,r7
80009c22:	e0 a0 08 0b 	rcall	8000ac38 <__multadd>
80009c26:	20 16       	sub	r6,1
80009c28:	18 93       	mov	r3,r12
80009c2a:	40 dc       	lddsp	r12,sp[0x34]
80009c2c:	58 0c       	cp.w	r12,0
80009c2e:	c0 31       	brne	80009c34 <_dtoa_r+0x918>
80009c30:	40 91       	lddsp	r1,sp[0x24]
80009c32:	c0 98       	rjmp	80009c44 <_dtoa_r+0x928>
80009c34:	08 9b       	mov	r11,r4
80009c36:	40 91       	lddsp	r1,sp[0x24]
80009c38:	30 09       	mov	r9,0
80009c3a:	30 aa       	mov	r10,10
80009c3c:	0e 9c       	mov	r12,r7
80009c3e:	e0 a0 07 fd 	rcall	8000ac38 <__multadd>
80009c42:	18 94       	mov	r4,r12
80009c44:	58 01       	cp.w	r1,0
80009c46:	5f a9       	srle	r9
80009c48:	40 cb       	lddsp	r11,sp[0x30]
80009c4a:	58 2b       	cp.w	r11,2
80009c4c:	5f 98       	srgt	r8
80009c4e:	f3 e8 00 08 	and	r8,r9,r8
80009c52:	c2 50       	breq	80009c9c <_dtoa_r+0x980>
80009c54:	58 01       	cp.w	r1,0
80009c56:	c1 11       	brne	80009c78 <_dtoa_r+0x95c>
80009c58:	04 9b       	mov	r11,r2
80009c5a:	02 99       	mov	r9,r1
80009c5c:	30 5a       	mov	r10,5
80009c5e:	0e 9c       	mov	r12,r7
80009c60:	e0 a0 07 ec 	rcall	8000ac38 <__multadd>
80009c64:	18 92       	mov	r2,r12
80009c66:	18 9b       	mov	r11,r12
80009c68:	06 9c       	mov	r12,r3
80009c6a:	e0 a0 05 f8 	rcall	8000a85a <__mcmp>
80009c6e:	e0 89 00 0f 	brgt	80009c8c <_dtoa_r+0x970>
80009c72:	c0 38       	rjmp	80009c78 <_dtoa_r+0x95c>
80009c74:	30 02       	mov	r2,0
80009c76:	04 94       	mov	r4,r2
80009c78:	40 ea       	lddsp	r10,sp[0x38]
80009c7a:	30 09       	mov	r9,0
80009c7c:	5c da       	com	r10
80009c7e:	40 85       	lddsp	r5,sp[0x20]
80009c80:	50 6a       	stdsp	sp[0x18],r10
80009c82:	50 49       	stdsp	sp[0x10],r9
80009c84:	c0 f9       	rjmp	80009ea2 <_dtoa_r+0xb86>
80009c86:	08 92       	mov	r2,r4
80009c88:	40 66       	lddsp	r6,sp[0x18]
80009c8a:	04 94       	mov	r4,r2
80009c8c:	2f f6       	sub	r6,-1
80009c8e:	50 66       	stdsp	sp[0x18],r6
80009c90:	33 18       	mov	r8,49
80009c92:	40 85       	lddsp	r5,sp[0x20]
80009c94:	0a c8       	st.b	r5++,r8
80009c96:	30 08       	mov	r8,0
80009c98:	50 48       	stdsp	sp[0x10],r8
80009c9a:	c0 49       	rjmp	80009ea2 <_dtoa_r+0xb86>
80009c9c:	40 dc       	lddsp	r12,sp[0x34]
80009c9e:	58 0c       	cp.w	r12,0
80009ca0:	e0 80 00 b5 	breq	80009e0a <_dtoa_r+0xaee>
80009ca4:	58 05       	cp.w	r5,0
80009ca6:	e0 8a 00 08 	brle	80009cb6 <_dtoa_r+0x99a>
80009caa:	08 9b       	mov	r11,r4
80009cac:	0a 9a       	mov	r10,r5
80009cae:	0e 9c       	mov	r12,r7
80009cb0:	e0 a0 06 f8 	rcall	8000aaa0 <__lshift>
80009cb4:	18 94       	mov	r4,r12
80009cb6:	40 6b       	lddsp	r11,sp[0x18]
80009cb8:	58 0b       	cp.w	r11,0
80009cba:	c0 31       	brne	80009cc0 <_dtoa_r+0x9a4>
80009cbc:	08 9c       	mov	r12,r4
80009cbe:	c1 38       	rjmp	80009ce4 <_dtoa_r+0x9c8>
80009cc0:	68 1b       	ld.w	r11,r4[0x4]
80009cc2:	0e 9c       	mov	r12,r7
80009cc4:	e0 a0 05 fe 	rcall	8000a8c0 <_Balloc>
80009cc8:	68 4a       	ld.w	r10,r4[0x10]
80009cca:	18 95       	mov	r5,r12
80009ccc:	e8 cb ff f4 	sub	r11,r4,-12
80009cd0:	2f ea       	sub	r10,-2
80009cd2:	2f 4c       	sub	r12,-12
80009cd4:	a3 6a       	lsl	r10,0x2
80009cd6:	fe b0 e6 43 	rcall	8000695c <memcpy>
80009cda:	0a 9b       	mov	r11,r5
80009cdc:	30 1a       	mov	r10,1
80009cde:	0e 9c       	mov	r12,r7
80009ce0:	e0 a0 06 e0 	rcall	8000aaa0 <__lshift>
80009ce4:	50 44       	stdsp	sp[0x10],r4
80009ce6:	40 3a       	lddsp	r10,sp[0xc]
80009ce8:	30 19       	mov	r9,1
80009cea:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
80009cee:	18 94       	mov	r4,r12
80009cf0:	50 da       	stdsp	sp[0x34],r10
80009cf2:	40 85       	lddsp	r5,sp[0x20]
80009cf4:	50 99       	stdsp	sp[0x24],r9
80009cf6:	50 26       	stdsp	sp[0x8],r6
80009cf8:	50 e1       	stdsp	sp[0x38],r1
80009cfa:	04 9b       	mov	r11,r2
80009cfc:	06 9c       	mov	r12,r3
80009cfe:	fe b0 fa 7f 	rcall	800091fc <quorem>
80009d02:	40 4b       	lddsp	r11,sp[0x10]
80009d04:	f8 c0 ff d0 	sub	r0,r12,-48
80009d08:	06 9c       	mov	r12,r3
80009d0a:	e0 a0 05 a8 	rcall	8000a85a <__mcmp>
80009d0e:	08 9a       	mov	r10,r4
80009d10:	50 6c       	stdsp	sp[0x18],r12
80009d12:	04 9b       	mov	r11,r2
80009d14:	0e 9c       	mov	r12,r7
80009d16:	e0 a0 06 5d 	rcall	8000a9d0 <__mdiff>
80009d1a:	18 91       	mov	r1,r12
80009d1c:	78 38       	ld.w	r8,r12[0xc]
80009d1e:	58 08       	cp.w	r8,0
80009d20:	c0 30       	breq	80009d26 <_dtoa_r+0xa0a>
80009d22:	30 16       	mov	r6,1
80009d24:	c0 68       	rjmp	80009d30 <_dtoa_r+0xa14>
80009d26:	18 9b       	mov	r11,r12
80009d28:	06 9c       	mov	r12,r3
80009d2a:	e0 a0 05 98 	rcall	8000a85a <__mcmp>
80009d2e:	18 96       	mov	r6,r12
80009d30:	0e 9c       	mov	r12,r7
80009d32:	02 9b       	mov	r11,r1
80009d34:	e0 a0 05 ac 	rcall	8000a88c <_Bfree>
80009d38:	40 cc       	lddsp	r12,sp[0x30]
80009d3a:	ed ec 10 08 	or	r8,r6,r12
80009d3e:	c0 d1       	brne	80009d58 <_dtoa_r+0xa3c>
80009d40:	40 db       	lddsp	r11,sp[0x34]
80009d42:	58 0b       	cp.w	r11,0
80009d44:	c0 a1       	brne	80009d58 <_dtoa_r+0xa3c>
80009d46:	40 26       	lddsp	r6,sp[0x8]
80009d48:	e0 40 00 39 	cp.w	r0,57
80009d4c:	c3 00       	breq	80009dac <_dtoa_r+0xa90>
80009d4e:	40 6a       	lddsp	r10,sp[0x18]
80009d50:	58 0a       	cp.w	r10,0
80009d52:	e0 89 00 24 	brgt	80009d9a <_dtoa_r+0xa7e>
80009d56:	c2 f8       	rjmp	80009db4 <_dtoa_r+0xa98>
80009d58:	40 69       	lddsp	r9,sp[0x18]
80009d5a:	58 09       	cp.w	r9,0
80009d5c:	c0 85       	brlt	80009d6c <_dtoa_r+0xa50>
80009d5e:	12 98       	mov	r8,r9
80009d60:	40 cc       	lddsp	r12,sp[0x30]
80009d62:	18 48       	or	r8,r12
80009d64:	c1 d1       	brne	80009d9e <_dtoa_r+0xa82>
80009d66:	40 db       	lddsp	r11,sp[0x34]
80009d68:	58 0b       	cp.w	r11,0
80009d6a:	c1 a1       	brne	80009d9e <_dtoa_r+0xa82>
80009d6c:	0c 99       	mov	r9,r6
80009d6e:	40 26       	lddsp	r6,sp[0x8]
80009d70:	58 09       	cp.w	r9,0
80009d72:	e0 8a 00 21 	brle	80009db4 <_dtoa_r+0xa98>
80009d76:	06 9b       	mov	r11,r3
80009d78:	30 1a       	mov	r10,1
80009d7a:	0e 9c       	mov	r12,r7
80009d7c:	e0 a0 06 92 	rcall	8000aaa0 <__lshift>
80009d80:	04 9b       	mov	r11,r2
80009d82:	18 93       	mov	r3,r12
80009d84:	e0 a0 05 6b 	rcall	8000a85a <__mcmp>
80009d88:	e0 89 00 06 	brgt	80009d94 <_dtoa_r+0xa78>
80009d8c:	c1 41       	brne	80009db4 <_dtoa_r+0xa98>
80009d8e:	ed b0 00 00 	bld	r0,0x0
80009d92:	c1 11       	brne	80009db4 <_dtoa_r+0xa98>
80009d94:	e0 40 00 39 	cp.w	r0,57
80009d98:	c0 a0       	breq	80009dac <_dtoa_r+0xa90>
80009d9a:	2f f0       	sub	r0,-1
80009d9c:	c0 c8       	rjmp	80009db4 <_dtoa_r+0xa98>
80009d9e:	58 06       	cp.w	r6,0
80009da0:	e0 8a 00 0c 	brle	80009db8 <_dtoa_r+0xa9c>
80009da4:	40 26       	lddsp	r6,sp[0x8]
80009da6:	e0 40 00 39 	cp.w	r0,57
80009daa:	c0 41       	brne	80009db2 <_dtoa_r+0xa96>
80009dac:	33 98       	mov	r8,57
80009dae:	0a c8       	st.b	r5++,r8
80009db0:	c6 78       	rjmp	80009e7e <_dtoa_r+0xb62>
80009db2:	2f f0       	sub	r0,-1
80009db4:	0a c0       	st.b	r5++,r0
80009db6:	c7 58       	rjmp	80009ea0 <_dtoa_r+0xb84>
80009db8:	0a c0       	st.b	r5++,r0
80009dba:	40 9a       	lddsp	r10,sp[0x24]
80009dbc:	40 e9       	lddsp	r9,sp[0x38]
80009dbe:	12 3a       	cp.w	r10,r9
80009dc0:	c4 30       	breq	80009e46 <_dtoa_r+0xb2a>
80009dc2:	06 9b       	mov	r11,r3
80009dc4:	30 09       	mov	r9,0
80009dc6:	30 aa       	mov	r10,10
80009dc8:	0e 9c       	mov	r12,r7
80009dca:	e0 a0 07 37 	rcall	8000ac38 <__multadd>
80009dce:	40 48       	lddsp	r8,sp[0x10]
80009dd0:	18 93       	mov	r3,r12
80009dd2:	08 38       	cp.w	r8,r4
80009dd4:	c0 91       	brne	80009de6 <_dtoa_r+0xaca>
80009dd6:	10 9b       	mov	r11,r8
80009dd8:	30 09       	mov	r9,0
80009dda:	30 aa       	mov	r10,10
80009ddc:	0e 9c       	mov	r12,r7
80009dde:	e0 a0 07 2d 	rcall	8000ac38 <__multadd>
80009de2:	50 4c       	stdsp	sp[0x10],r12
80009de4:	c0 e8       	rjmp	80009e00 <_dtoa_r+0xae4>
80009de6:	40 4b       	lddsp	r11,sp[0x10]
80009de8:	30 09       	mov	r9,0
80009dea:	30 aa       	mov	r10,10
80009dec:	0e 9c       	mov	r12,r7
80009dee:	e0 a0 07 25 	rcall	8000ac38 <__multadd>
80009df2:	08 9b       	mov	r11,r4
80009df4:	50 4c       	stdsp	sp[0x10],r12
80009df6:	30 09       	mov	r9,0
80009df8:	30 aa       	mov	r10,10
80009dfa:	0e 9c       	mov	r12,r7
80009dfc:	e0 a0 07 1e 	rcall	8000ac38 <__multadd>
80009e00:	18 94       	mov	r4,r12
80009e02:	40 9c       	lddsp	r12,sp[0x24]
80009e04:	2f fc       	sub	r12,-1
80009e06:	50 9c       	stdsp	sp[0x24],r12
80009e08:	c7 9b       	rjmp	80009cfa <_dtoa_r+0x9de>
80009e0a:	30 18       	mov	r8,1
80009e0c:	06 90       	mov	r0,r3
80009e0e:	40 85       	lddsp	r5,sp[0x20]
80009e10:	08 93       	mov	r3,r4
80009e12:	0c 94       	mov	r4,r6
80009e14:	10 96       	mov	r6,r8
80009e16:	04 9b       	mov	r11,r2
80009e18:	00 9c       	mov	r12,r0
80009e1a:	fe b0 f9 f1 	rcall	800091fc <quorem>
80009e1e:	2d 0c       	sub	r12,-48
80009e20:	0a cc       	st.b	r5++,r12
80009e22:	02 36       	cp.w	r6,r1
80009e24:	c0 a4       	brge	80009e38 <_dtoa_r+0xb1c>
80009e26:	00 9b       	mov	r11,r0
80009e28:	30 09       	mov	r9,0
80009e2a:	30 aa       	mov	r10,10
80009e2c:	0e 9c       	mov	r12,r7
80009e2e:	2f f6       	sub	r6,-1
80009e30:	e0 a0 07 04 	rcall	8000ac38 <__multadd>
80009e34:	18 90       	mov	r0,r12
80009e36:	cf 0b       	rjmp	80009e16 <_dtoa_r+0xafa>
80009e38:	08 96       	mov	r6,r4
80009e3a:	30 0b       	mov	r11,0
80009e3c:	06 94       	mov	r4,r3
80009e3e:	50 4b       	stdsp	sp[0x10],r11
80009e40:	00 93       	mov	r3,r0
80009e42:	18 90       	mov	r0,r12
80009e44:	c0 28       	rjmp	80009e48 <_dtoa_r+0xb2c>
80009e46:	40 26       	lddsp	r6,sp[0x8]
80009e48:	06 9b       	mov	r11,r3
80009e4a:	30 1a       	mov	r10,1
80009e4c:	0e 9c       	mov	r12,r7
80009e4e:	e0 a0 06 29 	rcall	8000aaa0 <__lshift>
80009e52:	04 9b       	mov	r11,r2
80009e54:	18 93       	mov	r3,r12
80009e56:	e0 a0 05 02 	rcall	8000a85a <__mcmp>
80009e5a:	e0 89 00 12 	brgt	80009e7e <_dtoa_r+0xb62>
80009e5e:	c1 b1       	brne	80009e94 <_dtoa_r+0xb78>
80009e60:	e1 d0 c0 01 	bfextu	r0,r0,0x0,0x1
80009e64:	c0 d1       	brne	80009e7e <_dtoa_r+0xb62>
80009e66:	c1 78       	rjmp	80009e94 <_dtoa_r+0xb78>
80009e68:	40 89       	lddsp	r9,sp[0x20]
80009e6a:	12 38       	cp.w	r8,r9
80009e6c:	c0 30       	breq	80009e72 <_dtoa_r+0xb56>
80009e6e:	10 95       	mov	r5,r8
80009e70:	c0 88       	rjmp	80009e80 <_dtoa_r+0xb64>
80009e72:	2f f6       	sub	r6,-1
80009e74:	50 66       	stdsp	sp[0x18],r6
80009e76:	33 18       	mov	r8,49
80009e78:	40 8c       	lddsp	r12,sp[0x20]
80009e7a:	b8 88       	st.b	r12[0x0],r8
80009e7c:	c1 38       	rjmp	80009ea2 <_dtoa_r+0xb86>
80009e7e:	33 9a       	mov	r10,57
80009e80:	0a 98       	mov	r8,r5
80009e82:	11 79       	ld.ub	r9,--r8
80009e84:	f4 09 18 00 	cp.b	r9,r10
80009e88:	cf 00       	breq	80009e68 <_dtoa_r+0xb4c>
80009e8a:	2f f9       	sub	r9,-1
80009e8c:	b0 89       	st.b	r8[0x0],r9
80009e8e:	c0 98       	rjmp	80009ea0 <_dtoa_r+0xb84>
80009e90:	10 95       	mov	r5,r8
80009e92:	c0 28       	rjmp	80009e96 <_dtoa_r+0xb7a>
80009e94:	33 09       	mov	r9,48
80009e96:	0a 98       	mov	r8,r5
80009e98:	11 7a       	ld.ub	r10,--r8
80009e9a:	f2 0a 18 00 	cp.b	r10,r9
80009e9e:	cf 90       	breq	80009e90 <_dtoa_r+0xb74>
80009ea0:	50 66       	stdsp	sp[0x18],r6
80009ea2:	04 9b       	mov	r11,r2
80009ea4:	0e 9c       	mov	r12,r7
80009ea6:	e0 a0 04 f3 	rcall	8000a88c <_Bfree>
80009eaa:	58 04       	cp.w	r4,0
80009eac:	c1 20       	breq	80009ed0 <_dtoa_r+0xbb4>
80009eae:	40 4b       	lddsp	r11,sp[0x10]
80009eb0:	08 3b       	cp.w	r11,r4
80009eb2:	5f 19       	srne	r9
80009eb4:	58 0b       	cp.w	r11,0
80009eb6:	5f 18       	srne	r8
80009eb8:	f3 e8 00 08 	and	r8,r9,r8
80009ebc:	c0 40       	breq	80009ec4 <_dtoa_r+0xba8>
80009ebe:	0e 9c       	mov	r12,r7
80009ec0:	e0 a0 04 e6 	rcall	8000a88c <_Bfree>
80009ec4:	08 9b       	mov	r11,r4
80009ec6:	0e 9c       	mov	r12,r7
80009ec8:	e0 a0 04 e2 	rcall	8000a88c <_Bfree>
80009ecc:	c0 28       	rjmp	80009ed0 <_dtoa_r+0xbb4>
80009ece:	50 66       	stdsp	sp[0x18],r6
80009ed0:	0e 9c       	mov	r12,r7
80009ed2:	06 9b       	mov	r11,r3
80009ed4:	e0 a0 04 dc 	rcall	8000a88c <_Bfree>
80009ed8:	30 08       	mov	r8,0
80009eda:	aa 88       	st.b	r5[0x0],r8
80009edc:	40 68       	lddsp	r8,sp[0x18]
80009ede:	41 5a       	lddsp	r10,sp[0x54]
80009ee0:	2f f8       	sub	r8,-1
80009ee2:	41 29       	lddsp	r9,sp[0x48]
80009ee4:	95 08       	st.w	r10[0x0],r8
80009ee6:	40 8c       	lddsp	r12,sp[0x20]
80009ee8:	58 09       	cp.w	r9,0
80009eea:	fb f8 10 12 	ld.wne	r8,sp[0x48]
80009eee:	f1 f5 1a 00 	st.wne	r8[0x0],r5
80009ef2:	2e 6d       	sub	sp,-104
80009ef4:	d8 32       	popm	r0-r7,pc
80009ef6:	d7 03       	nop

80009ef8 <__errno>:
80009ef8:	e0 68 0a 30 	mov	r8,2608
80009efc:	70 0c       	ld.w	r12,r8[0x0]
80009efe:	2f 4c       	sub	r12,-12
80009f00:	5e fc       	retal	r12
80009f02:	d7 03       	nop

80009f04 <_fflush_r>:
80009f04:	d4 21       	pushm	r4-r7,lr
80009f06:	16 97       	mov	r7,r11
80009f08:	18 96       	mov	r6,r12
80009f0a:	76 48       	ld.w	r8,r11[0x10]
80009f0c:	58 08       	cp.w	r8,0
80009f0e:	c7 f0       	breq	8000a00c <_fflush_r+0x108>
80009f10:	58 0c       	cp.w	r12,0
80009f12:	c0 50       	breq	80009f1c <_fflush_r+0x18>
80009f14:	78 68       	ld.w	r8,r12[0x18]
80009f16:	58 08       	cp.w	r8,0
80009f18:	c0 21       	brne	80009f1c <_fflush_r+0x18>
80009f1a:	cc dc       	rcall	8000a0b4 <__sinit>
80009f1c:	fe c8 cf a8 	sub	r8,pc,-12376
80009f20:	10 37       	cp.w	r7,r8
80009f22:	c0 31       	brne	80009f28 <_fflush_r+0x24>
80009f24:	6c 07       	ld.w	r7,r6[0x0]
80009f26:	c0 c8       	rjmp	80009f3e <_fflush_r+0x3a>
80009f28:	fe c8 cf 94 	sub	r8,pc,-12396
80009f2c:	10 37       	cp.w	r7,r8
80009f2e:	c0 31       	brne	80009f34 <_fflush_r+0x30>
80009f30:	6c 17       	ld.w	r7,r6[0x4]
80009f32:	c0 68       	rjmp	80009f3e <_fflush_r+0x3a>
80009f34:	fe c8 cf 80 	sub	r8,pc,-12416
80009f38:	10 37       	cp.w	r7,r8
80009f3a:	ed f7 00 02 	ld.weq	r7,r6[0x8]
80009f3e:	8e 6a       	ld.sh	r10,r7[0xc]
80009f40:	14 98       	mov	r8,r10
80009f42:	ed ba 00 03 	bld	r10,0x3
80009f46:	c4 20       	breq	80009fca <_fflush_r+0xc6>
80009f48:	ab ba       	sbr	r10,0xb
80009f4a:	ae 6a       	st.h	r7[0xc],r10
80009f4c:	6e 18       	ld.w	r8,r7[0x4]
80009f4e:	58 08       	cp.w	r8,0
80009f50:	e0 89 00 06 	brgt	80009f5c <_fflush_r+0x58>
80009f54:	6f 08       	ld.w	r8,r7[0x40]
80009f56:	58 08       	cp.w	r8,0
80009f58:	e0 8a 00 5a 	brle	8000a00c <_fflush_r+0x108>
80009f5c:	6e b8       	ld.w	r8,r7[0x2c]
80009f5e:	58 08       	cp.w	r8,0
80009f60:	c5 60       	breq	8000a00c <_fflush_r+0x108>
80009f62:	e2 1a 10 00 	andl	r10,0x1000,COH
80009f66:	c0 30       	breq	80009f6c <_fflush_r+0x68>
80009f68:	6f 55       	ld.w	r5,r7[0x54]
80009f6a:	c0 f8       	rjmp	80009f88 <_fflush_r+0x84>
80009f6c:	30 19       	mov	r9,1
80009f6e:	6e 8b       	ld.w	r11,r7[0x20]
80009f70:	0c 9c       	mov	r12,r6
80009f72:	5d 18       	icall	r8
80009f74:	18 95       	mov	r5,r12
80009f76:	5b fc       	cp.w	r12,-1
80009f78:	c0 81       	brne	80009f88 <_fflush_r+0x84>
80009f7a:	6c 38       	ld.w	r8,r6[0xc]
80009f7c:	59 d8       	cp.w	r8,29
80009f7e:	c4 70       	breq	8000a00c <_fflush_r+0x108>
80009f80:	8e 68       	ld.sh	r8,r7[0xc]
80009f82:	a7 a8       	sbr	r8,0x6
80009f84:	ae 68       	st.h	r7[0xc],r8
80009f86:	d8 22       	popm	r4-r7,pc
80009f88:	8e 68       	ld.sh	r8,r7[0xc]
80009f8a:	ed b8 00 02 	bld	r8,0x2
80009f8e:	c0 91       	brne	80009fa0 <_fflush_r+0x9c>
80009f90:	6e 18       	ld.w	r8,r7[0x4]
80009f92:	10 15       	sub	r5,r8
80009f94:	6e d8       	ld.w	r8,r7[0x34]
80009f96:	58 08       	cp.w	r8,0
80009f98:	ef f8 10 10 	ld.wne	r8,r7[0x40]
80009f9c:	eb d8 e1 15 	subne	r5,r5,r8
80009fa0:	6e b8       	ld.w	r8,r7[0x2c]
80009fa2:	0c 9c       	mov	r12,r6
80009fa4:	30 09       	mov	r9,0
80009fa6:	0a 9a       	mov	r10,r5
80009fa8:	6e 8b       	ld.w	r11,r7[0x20]
80009faa:	5d 18       	icall	r8
80009fac:	8e 68       	ld.sh	r8,r7[0xc]
80009fae:	0a 3c       	cp.w	r12,r5
80009fb0:	c2 61       	brne	80009ffc <_fflush_r+0xf8>
80009fb2:	ab d8       	cbr	r8,0xb
80009fb4:	30 0c       	mov	r12,0
80009fb6:	6e 49       	ld.w	r9,r7[0x10]
80009fb8:	ae 68       	st.h	r7[0xc],r8
80009fba:	8f 1c       	st.w	r7[0x4],r12
80009fbc:	8f 09       	st.w	r7[0x0],r9
80009fbe:	ed b8 00 0c 	bld	r8,0xc
80009fc2:	c2 51       	brne	8000a00c <_fflush_r+0x108>
80009fc4:	ef 45 00 54 	st.w	r7[84],r5
80009fc8:	d8 22       	popm	r4-r7,pc
80009fca:	6e 45       	ld.w	r5,r7[0x10]
80009fcc:	58 05       	cp.w	r5,0
80009fce:	c1 f0       	breq	8000a00c <_fflush_r+0x108>
80009fd0:	6e 04       	ld.w	r4,r7[0x0]
80009fd2:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
80009fd6:	8f 05       	st.w	r7[0x0],r5
80009fd8:	f9 b8 01 00 	movne	r8,0
80009fdc:	ef f8 00 05 	ld.weq	r8,r7[0x14]
80009fe0:	0a 14       	sub	r4,r5
80009fe2:	8f 28       	st.w	r7[0x8],r8
80009fe4:	c1 18       	rjmp	8000a006 <_fflush_r+0x102>
80009fe6:	08 99       	mov	r9,r4
80009fe8:	0a 9a       	mov	r10,r5
80009fea:	6e a8       	ld.w	r8,r7[0x28]
80009fec:	6e 8b       	ld.w	r11,r7[0x20]
80009fee:	0c 9c       	mov	r12,r6
80009ff0:	5d 18       	icall	r8
80009ff2:	18 14       	sub	r4,r12
80009ff4:	58 0c       	cp.w	r12,0
80009ff6:	e0 89 00 07 	brgt	8000a004 <_fflush_r+0x100>
80009ffa:	8e 68       	ld.sh	r8,r7[0xc]
80009ffc:	a7 a8       	sbr	r8,0x6
80009ffe:	3f fc       	mov	r12,-1
8000a000:	ae 68       	st.h	r7[0xc],r8
8000a002:	d8 22       	popm	r4-r7,pc
8000a004:	18 05       	add	r5,r12
8000a006:	58 04       	cp.w	r4,0
8000a008:	fe 99 ff ef 	brgt	80009fe6 <_fflush_r+0xe2>
8000a00c:	d8 2a       	popm	r4-r7,pc,r12=0
8000a00e:	d7 03       	nop

8000a010 <__sfp_lock_acquire>:
8000a010:	5e fc       	retal	r12

8000a012 <__sfp_lock_release>:
8000a012:	5e fc       	retal	r12

8000a014 <_cleanup_r>:
8000a014:	d4 01       	pushm	lr
8000a016:	fe cb f0 c6 	sub	r11,pc,-3898
8000a01a:	e0 a0 02 f7 	rcall	8000a608 <_fwalk>
8000a01e:	d8 02       	popm	pc

8000a020 <__sfmoreglue>:
8000a020:	d4 21       	pushm	r4-r7,lr
8000a022:	16 95       	mov	r5,r11
8000a024:	f6 06 10 5c 	mul	r6,r11,92
8000a028:	ec cb ff f4 	sub	r11,r6,-12
8000a02c:	fe b0 e2 7c 	rcall	80006524 <_malloc_r>
8000a030:	18 97       	mov	r7,r12
8000a032:	c0 90       	breq	8000a044 <__sfmoreglue+0x24>
8000a034:	99 15       	st.w	r12[0x4],r5
8000a036:	30 0b       	mov	r11,0
8000a038:	2f 4c       	sub	r12,-12
8000a03a:	0c 9a       	mov	r10,r6
8000a03c:	8f 2c       	st.w	r7[0x8],r12
8000a03e:	8f 0b       	st.w	r7[0x0],r11
8000a040:	fe b0 e5 32 	rcall	80006aa4 <memset>
8000a044:	0e 9c       	mov	r12,r7
8000a046:	d8 22       	popm	r4-r7,pc

8000a048 <__sfp>:
8000a048:	d4 21       	pushm	r4-r7,lr
8000a04a:	fe c8 d0 72 	sub	r8,pc,-12174
8000a04e:	18 96       	mov	r6,r12
8000a050:	70 07       	ld.w	r7,r8[0x0]
8000a052:	6e 68       	ld.w	r8,r7[0x18]
8000a054:	58 08       	cp.w	r8,0
8000a056:	c0 31       	brne	8000a05c <__sfp+0x14>
8000a058:	0e 9c       	mov	r12,r7
8000a05a:	c2 dc       	rcall	8000a0b4 <__sinit>
8000a05c:	ee c7 ff 28 	sub	r7,r7,-216
8000a060:	30 05       	mov	r5,0
8000a062:	6e 2c       	ld.w	r12,r7[0x8]
8000a064:	6e 18       	ld.w	r8,r7[0x4]
8000a066:	c0 68       	rjmp	8000a072 <__sfp+0x2a>
8000a068:	98 69       	ld.sh	r9,r12[0xc]
8000a06a:	ea 09 19 00 	cp.h	r9,r5
8000a06e:	c1 10       	breq	8000a090 <__sfp+0x48>
8000a070:	2a 4c       	sub	r12,-92
8000a072:	20 18       	sub	r8,1
8000a074:	cf a7       	brpl	8000a068 <__sfp+0x20>
8000a076:	6e 08       	ld.w	r8,r7[0x0]
8000a078:	58 08       	cp.w	r8,0
8000a07a:	c0 61       	brne	8000a086 <__sfp+0x3e>
8000a07c:	30 4b       	mov	r11,4
8000a07e:	0c 9c       	mov	r12,r6
8000a080:	cd 0f       	rcall	8000a020 <__sfmoreglue>
8000a082:	8f 0c       	st.w	r7[0x0],r12
8000a084:	c0 30       	breq	8000a08a <__sfp+0x42>
8000a086:	6e 07       	ld.w	r7,r7[0x0]
8000a088:	ce db       	rjmp	8000a062 <__sfp+0x1a>
8000a08a:	30 c8       	mov	r8,12
8000a08c:	8d 38       	st.w	r6[0xc],r8
8000a08e:	d8 22       	popm	r4-r7,pc
8000a090:	30 08       	mov	r8,0
8000a092:	f9 48 00 4c 	st.w	r12[76],r8
8000a096:	99 08       	st.w	r12[0x0],r8
8000a098:	99 28       	st.w	r12[0x8],r8
8000a09a:	99 18       	st.w	r12[0x4],r8
8000a09c:	99 48       	st.w	r12[0x10],r8
8000a09e:	99 58       	st.w	r12[0x14],r8
8000a0a0:	99 68       	st.w	r12[0x18],r8
8000a0a2:	99 d8       	st.w	r12[0x34],r8
8000a0a4:	99 e8       	st.w	r12[0x38],r8
8000a0a6:	f9 48 00 48 	st.w	r12[72],r8
8000a0aa:	3f f8       	mov	r8,-1
8000a0ac:	b8 78       	st.h	r12[0xe],r8
8000a0ae:	30 18       	mov	r8,1
8000a0b0:	b8 68       	st.h	r12[0xc],r8
8000a0b2:	d8 22       	popm	r4-r7,pc

8000a0b4 <__sinit>:
8000a0b4:	d4 21       	pushm	r4-r7,lr
8000a0b6:	18 96       	mov	r6,r12
8000a0b8:	78 67       	ld.w	r7,r12[0x18]
8000a0ba:	58 07       	cp.w	r7,0
8000a0bc:	c4 91       	brne	8000a14e <__sinit+0x9a>
8000a0be:	fe c8 00 aa 	sub	r8,pc,170
8000a0c2:	30 15       	mov	r5,1
8000a0c4:	99 a8       	st.w	r12[0x28],r8
8000a0c6:	f9 47 00 d8 	st.w	r12[216],r7
8000a0ca:	f9 47 00 dc 	st.w	r12[220],r7
8000a0ce:	f9 47 00 e0 	st.w	r12[224],r7
8000a0d2:	99 65       	st.w	r12[0x18],r5
8000a0d4:	cb af       	rcall	8000a048 <__sfp>
8000a0d6:	8d 0c       	st.w	r6[0x0],r12
8000a0d8:	0c 9c       	mov	r12,r6
8000a0da:	cb 7f       	rcall	8000a048 <__sfp>
8000a0dc:	8d 1c       	st.w	r6[0x4],r12
8000a0de:	0c 9c       	mov	r12,r6
8000a0e0:	cb 4f       	rcall	8000a048 <__sfp>
8000a0e2:	6c 09       	ld.w	r9,r6[0x0]
8000a0e4:	30 48       	mov	r8,4
8000a0e6:	93 07       	st.w	r9[0x0],r7
8000a0e8:	b2 68       	st.h	r9[0xc],r8
8000a0ea:	93 17       	st.w	r9[0x4],r7
8000a0ec:	93 27       	st.w	r9[0x8],r7
8000a0ee:	6c 18       	ld.w	r8,r6[0x4]
8000a0f0:	b2 77       	st.h	r9[0xe],r7
8000a0f2:	93 47       	st.w	r9[0x10],r7
8000a0f4:	93 57       	st.w	r9[0x14],r7
8000a0f6:	93 67       	st.w	r9[0x18],r7
8000a0f8:	93 89       	st.w	r9[0x20],r9
8000a0fa:	91 07       	st.w	r8[0x0],r7
8000a0fc:	91 17       	st.w	r8[0x4],r7
8000a0fe:	91 27       	st.w	r8[0x8],r7
8000a100:	fe ce f3 24 	sub	lr,pc,-3292
8000a104:	fe cb f3 54 	sub	r11,pc,-3244
8000a108:	93 9e       	st.w	r9[0x24],lr
8000a10a:	93 ab       	st.w	r9[0x28],r11
8000a10c:	fe ca f3 7c 	sub	r10,pc,-3204
8000a110:	fe c4 f3 88 	sub	r4,pc,-3192
8000a114:	93 ba       	st.w	r9[0x2c],r10
8000a116:	93 c4       	st.w	r9[0x30],r4
8000a118:	30 99       	mov	r9,9
8000a11a:	b0 69       	st.h	r8[0xc],r9
8000a11c:	b0 75       	st.h	r8[0xe],r5
8000a11e:	91 c4       	st.w	r8[0x30],r4
8000a120:	91 47       	st.w	r8[0x10],r7
8000a122:	91 57       	st.w	r8[0x14],r7
8000a124:	91 67       	st.w	r8[0x18],r7
8000a126:	91 88       	st.w	r8[0x20],r8
8000a128:	91 9e       	st.w	r8[0x24],lr
8000a12a:	91 ab       	st.w	r8[0x28],r11
8000a12c:	91 ba       	st.w	r8[0x2c],r10
8000a12e:	8d 2c       	st.w	r6[0x8],r12
8000a130:	31 28       	mov	r8,18
8000a132:	99 07       	st.w	r12[0x0],r7
8000a134:	b8 68       	st.h	r12[0xc],r8
8000a136:	99 17       	st.w	r12[0x4],r7
8000a138:	99 27       	st.w	r12[0x8],r7
8000a13a:	30 28       	mov	r8,2
8000a13c:	b8 78       	st.h	r12[0xe],r8
8000a13e:	99 c4       	st.w	r12[0x30],r4
8000a140:	99 67       	st.w	r12[0x18],r7
8000a142:	99 9e       	st.w	r12[0x24],lr
8000a144:	99 ab       	st.w	r12[0x28],r11
8000a146:	99 ba       	st.w	r12[0x2c],r10
8000a148:	99 47       	st.w	r12[0x10],r7
8000a14a:	99 57       	st.w	r12[0x14],r7
8000a14c:	99 8c       	st.w	r12[0x20],r12
8000a14e:	d8 22       	popm	r4-r7,pc

8000a150 <_malloc_trim_r>:
8000a150:	d4 21       	pushm	r4-r7,lr
8000a152:	16 95       	mov	r5,r11
8000a154:	18 97       	mov	r7,r12
8000a156:	fe b0 d7 83 	rcall	8000505c <__malloc_lock>
8000a15a:	e0 64 05 30 	mov	r4,1328
8000a15e:	68 28       	ld.w	r8,r4[0x8]
8000a160:	70 16       	ld.w	r6,r8[0x4]
8000a162:	e0 16 ff fc 	andl	r6,0xfffc
8000a166:	ec c8 ff 91 	sub	r8,r6,-111
8000a16a:	f0 05 01 05 	sub	r5,r8,r5
8000a16e:	e0 15 ff 80 	andl	r5,0xff80
8000a172:	ea c5 00 80 	sub	r5,r5,128
8000a176:	e0 45 00 7f 	cp.w	r5,127
8000a17a:	e0 8a 00 25 	brle	8000a1c4 <_malloc_trim_r+0x74>
8000a17e:	30 0b       	mov	r11,0
8000a180:	0e 9c       	mov	r12,r7
8000a182:	fe b0 e5 f9 	rcall	80006d74 <_sbrk_r>
8000a186:	68 28       	ld.w	r8,r4[0x8]
8000a188:	0c 08       	add	r8,r6
8000a18a:	10 3c       	cp.w	r12,r8
8000a18c:	c1 c1       	brne	8000a1c4 <_malloc_trim_r+0x74>
8000a18e:	ea 0b 11 00 	rsub	r11,r5,0
8000a192:	0e 9c       	mov	r12,r7
8000a194:	fe b0 e5 f0 	rcall	80006d74 <_sbrk_r>
8000a198:	5b fc       	cp.w	r12,-1
8000a19a:	c1 91       	brne	8000a1cc <_malloc_trim_r+0x7c>
8000a19c:	30 0b       	mov	r11,0
8000a19e:	0e 9c       	mov	r12,r7
8000a1a0:	fe b0 e5 ea 	rcall	80006d74 <_sbrk_r>
8000a1a4:	68 28       	ld.w	r8,r4[0x8]
8000a1a6:	f8 08 01 09 	sub	r9,r12,r8
8000a1aa:	58 f9       	cp.w	r9,15
8000a1ac:	e0 8a 00 0c 	brle	8000a1c4 <_malloc_trim_r+0x74>
8000a1b0:	a1 a9       	sbr	r9,0x0
8000a1b2:	91 19       	st.w	r8[0x4],r9
8000a1b4:	e0 68 09 3c 	mov	r8,2364
8000a1b8:	70 09       	ld.w	r9,r8[0x0]
8000a1ba:	e0 68 0d 44 	mov	r8,3396
8000a1be:	f8 09 01 09 	sub	r9,r12,r9
8000a1c2:	91 09       	st.w	r8[0x0],r9
8000a1c4:	0e 9c       	mov	r12,r7
8000a1c6:	fe b0 d7 51 	rcall	80005068 <__malloc_unlock>
8000a1ca:	d8 2a       	popm	r4-r7,pc,r12=0
8000a1cc:	68 28       	ld.w	r8,r4[0x8]
8000a1ce:	0a 16       	sub	r6,r5
8000a1d0:	a1 a6       	sbr	r6,0x0
8000a1d2:	91 16       	st.w	r8[0x4],r6
8000a1d4:	e0 68 0d 44 	mov	r8,3396
8000a1d8:	70 09       	ld.w	r9,r8[0x0]
8000a1da:	0a 19       	sub	r9,r5
8000a1dc:	0e 9c       	mov	r12,r7
8000a1de:	91 09       	st.w	r8[0x0],r9
8000a1e0:	fe b0 d7 44 	rcall	80005068 <__malloc_unlock>
8000a1e4:	da 2a       	popm	r4-r7,pc,r12=1
8000a1e6:	d7 03       	nop

8000a1e8 <_free_r>:
8000a1e8:	d4 21       	pushm	r4-r7,lr
8000a1ea:	16 96       	mov	r6,r11
8000a1ec:	18 97       	mov	r7,r12
8000a1ee:	58 0b       	cp.w	r11,0
8000a1f0:	e0 80 00 c0 	breq	8000a370 <_free_r+0x188>
8000a1f4:	fe b0 d7 34 	rcall	8000505c <__malloc_lock>
8000a1f8:	20 86       	sub	r6,8
8000a1fa:	e0 6a 05 30 	mov	r10,1328
8000a1fe:	6c 18       	ld.w	r8,r6[0x4]
8000a200:	74 2e       	ld.w	lr,r10[0x8]
8000a202:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
8000a206:	a1 c8       	cbr	r8,0x0
8000a208:	ec 08 00 09 	add	r9,r6,r8
8000a20c:	72 1b       	ld.w	r11,r9[0x4]
8000a20e:	e0 1b ff fc 	andl	r11,0xfffc
8000a212:	1c 39       	cp.w	r9,lr
8000a214:	c1 e1       	brne	8000a250 <_free_r+0x68>
8000a216:	f6 08 00 08 	add	r8,r11,r8
8000a21a:	58 0c       	cp.w	r12,0
8000a21c:	c0 81       	brne	8000a22c <_free_r+0x44>
8000a21e:	6c 09       	ld.w	r9,r6[0x0]
8000a220:	12 16       	sub	r6,r9
8000a222:	12 08       	add	r8,r9
8000a224:	6c 3b       	ld.w	r11,r6[0xc]
8000a226:	6c 29       	ld.w	r9,r6[0x8]
8000a228:	97 29       	st.w	r11[0x8],r9
8000a22a:	93 3b       	st.w	r9[0xc],r11
8000a22c:	10 99       	mov	r9,r8
8000a22e:	95 26       	st.w	r10[0x8],r6
8000a230:	a1 a9       	sbr	r9,0x0
8000a232:	8d 19       	st.w	r6[0x4],r9
8000a234:	e0 69 09 38 	mov	r9,2360
8000a238:	72 09       	ld.w	r9,r9[0x0]
8000a23a:	12 38       	cp.w	r8,r9
8000a23c:	c0 63       	brcs	8000a248 <_free_r+0x60>
8000a23e:	e0 68 0d 40 	mov	r8,3392
8000a242:	0e 9c       	mov	r12,r7
8000a244:	70 0b       	ld.w	r11,r8[0x0]
8000a246:	c8 5f       	rcall	8000a150 <_malloc_trim_r>
8000a248:	0e 9c       	mov	r12,r7
8000a24a:	fe b0 d7 0f 	rcall	80005068 <__malloc_unlock>
8000a24e:	d8 22       	popm	r4-r7,pc
8000a250:	93 1b       	st.w	r9[0x4],r11
8000a252:	58 0c       	cp.w	r12,0
8000a254:	c0 30       	breq	8000a25a <_free_r+0x72>
8000a256:	30 0c       	mov	r12,0
8000a258:	c1 08       	rjmp	8000a278 <_free_r+0x90>
8000a25a:	6c 0e       	ld.w	lr,r6[0x0]
8000a25c:	f4 c5 ff f8 	sub	r5,r10,-8
8000a260:	1c 16       	sub	r6,lr
8000a262:	1c 08       	add	r8,lr
8000a264:	6c 2e       	ld.w	lr,r6[0x8]
8000a266:	0a 3e       	cp.w	lr,r5
8000a268:	f9 bc 00 01 	moveq	r12,1
8000a26c:	ed f5 10 03 	ld.wne	r5,r6[0xc]
8000a270:	eb fe 1a 02 	st.wne	r5[0x8],lr
8000a274:	fd f5 1a 03 	st.wne	lr[0xc],r5
8000a278:	f2 0b 00 0e 	add	lr,r9,r11
8000a27c:	7c 1e       	ld.w	lr,lr[0x4]
8000a27e:	ed be 00 00 	bld	lr,0x0
8000a282:	c1 40       	breq	8000a2aa <_free_r+0xc2>
8000a284:	16 08       	add	r8,r11
8000a286:	58 0c       	cp.w	r12,0
8000a288:	c0 d1       	brne	8000a2a2 <_free_r+0xba>
8000a28a:	e0 6e 05 30 	mov	lr,1328
8000a28e:	72 2b       	ld.w	r11,r9[0x8]
8000a290:	2f 8e       	sub	lr,-8
8000a292:	1c 3b       	cp.w	r11,lr
8000a294:	c0 71       	brne	8000a2a2 <_free_r+0xba>
8000a296:	97 36       	st.w	r11[0xc],r6
8000a298:	97 26       	st.w	r11[0x8],r6
8000a29a:	8d 2b       	st.w	r6[0x8],r11
8000a29c:	8d 3b       	st.w	r6[0xc],r11
8000a29e:	30 1c       	mov	r12,1
8000a2a0:	c0 58       	rjmp	8000a2aa <_free_r+0xc2>
8000a2a2:	72 2b       	ld.w	r11,r9[0x8]
8000a2a4:	72 39       	ld.w	r9,r9[0xc]
8000a2a6:	93 2b       	st.w	r9[0x8],r11
8000a2a8:	97 39       	st.w	r11[0xc],r9
8000a2aa:	10 99       	mov	r9,r8
8000a2ac:	ec 08 09 08 	st.w	r6[r8],r8
8000a2b0:	a1 a9       	sbr	r9,0x0
8000a2b2:	8d 19       	st.w	r6[0x4],r9
8000a2b4:	58 0c       	cp.w	r12,0
8000a2b6:	c5 a1       	brne	8000a36a <_free_r+0x182>
8000a2b8:	e0 48 01 ff 	cp.w	r8,511
8000a2bc:	e0 8b 00 13 	brhi	8000a2e2 <_free_r+0xfa>
8000a2c0:	a3 98       	lsr	r8,0x3
8000a2c2:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000a2c6:	72 2b       	ld.w	r11,r9[0x8]
8000a2c8:	8d 39       	st.w	r6[0xc],r9
8000a2ca:	8d 2b       	st.w	r6[0x8],r11
8000a2cc:	97 36       	st.w	r11[0xc],r6
8000a2ce:	93 26       	st.w	r9[0x8],r6
8000a2d0:	a3 48       	asr	r8,0x2
8000a2d2:	74 19       	ld.w	r9,r10[0x4]
8000a2d4:	30 1b       	mov	r11,1
8000a2d6:	f6 08 09 48 	lsl	r8,r11,r8
8000a2da:	f3 e8 10 08 	or	r8,r9,r8
8000a2de:	95 18       	st.w	r10[0x4],r8
8000a2e0:	c4 58       	rjmp	8000a36a <_free_r+0x182>
8000a2e2:	f0 0b 16 09 	lsr	r11,r8,0x9
8000a2e6:	58 4b       	cp.w	r11,4
8000a2e8:	e0 8b 00 06 	brhi	8000a2f4 <_free_r+0x10c>
8000a2ec:	f0 0b 16 06 	lsr	r11,r8,0x6
8000a2f0:	2c 8b       	sub	r11,-56
8000a2f2:	c2 08       	rjmp	8000a332 <_free_r+0x14a>
8000a2f4:	59 4b       	cp.w	r11,20
8000a2f6:	e0 8b 00 04 	brhi	8000a2fe <_free_r+0x116>
8000a2fa:	2a 5b       	sub	r11,-91
8000a2fc:	c1 b8       	rjmp	8000a332 <_free_r+0x14a>
8000a2fe:	e0 4b 00 54 	cp.w	r11,84
8000a302:	e0 8b 00 06 	brhi	8000a30e <_free_r+0x126>
8000a306:	f0 0b 16 0c 	lsr	r11,r8,0xc
8000a30a:	29 2b       	sub	r11,-110
8000a30c:	c1 38       	rjmp	8000a332 <_free_r+0x14a>
8000a30e:	e0 4b 01 54 	cp.w	r11,340
8000a312:	e0 8b 00 06 	brhi	8000a31e <_free_r+0x136>
8000a316:	f0 0b 16 0f 	lsr	r11,r8,0xf
8000a31a:	28 9b       	sub	r11,-119
8000a31c:	c0 b8       	rjmp	8000a332 <_free_r+0x14a>
8000a31e:	e0 4b 05 54 	cp.w	r11,1364
8000a322:	e0 88 00 05 	brls	8000a32c <_free_r+0x144>
8000a326:	37 eb       	mov	r11,126
8000a328:	c0 58       	rjmp	8000a332 <_free_r+0x14a>
8000a32a:	d7 03       	nop
8000a32c:	f0 0b 16 12 	lsr	r11,r8,0x12
8000a330:	28 4b       	sub	r11,-124
8000a332:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
8000a336:	78 29       	ld.w	r9,r12[0x8]
8000a338:	18 39       	cp.w	r9,r12
8000a33a:	c0 e1       	brne	8000a356 <_free_r+0x16e>
8000a33c:	74 18       	ld.w	r8,r10[0x4]
8000a33e:	a3 4b       	asr	r11,0x2
8000a340:	30 1c       	mov	r12,1
8000a342:	f8 0b 09 4b 	lsl	r11,r12,r11
8000a346:	f1 eb 10 0b 	or	r11,r8,r11
8000a34a:	12 98       	mov	r8,r9
8000a34c:	95 1b       	st.w	r10[0x4],r11
8000a34e:	c0 a8       	rjmp	8000a362 <_free_r+0x17a>
8000a350:	72 29       	ld.w	r9,r9[0x8]
8000a352:	18 39       	cp.w	r9,r12
8000a354:	c0 60       	breq	8000a360 <_free_r+0x178>
8000a356:	72 1a       	ld.w	r10,r9[0x4]
8000a358:	e0 1a ff fc 	andl	r10,0xfffc
8000a35c:	14 38       	cp.w	r8,r10
8000a35e:	cf 93       	brcs	8000a350 <_free_r+0x168>
8000a360:	72 38       	ld.w	r8,r9[0xc]
8000a362:	8d 38       	st.w	r6[0xc],r8
8000a364:	8d 29       	st.w	r6[0x8],r9
8000a366:	93 36       	st.w	r9[0xc],r6
8000a368:	91 26       	st.w	r8[0x8],r6
8000a36a:	0e 9c       	mov	r12,r7
8000a36c:	fe b0 d6 7e 	rcall	80005068 <__malloc_unlock>
8000a370:	d8 22       	popm	r4-r7,pc
8000a372:	d7 03       	nop

8000a374 <__sfvwrite_r>:
8000a374:	d4 31       	pushm	r0-r7,lr
8000a376:	20 3d       	sub	sp,12
8000a378:	14 94       	mov	r4,r10
8000a37a:	18 95       	mov	r5,r12
8000a37c:	16 97       	mov	r7,r11
8000a37e:	74 28       	ld.w	r8,r10[0x8]
8000a380:	58 08       	cp.w	r8,0
8000a382:	e0 80 01 40 	breq	8000a602 <__sfvwrite_r+0x28e>
8000a386:	96 68       	ld.sh	r8,r11[0xc]
8000a388:	ed b8 00 03 	bld	r8,0x3
8000a38c:	c0 41       	brne	8000a394 <__sfvwrite_r+0x20>
8000a38e:	76 48       	ld.w	r8,r11[0x10]
8000a390:	58 08       	cp.w	r8,0
8000a392:	c0 c1       	brne	8000a3aa <__sfvwrite_r+0x36>
8000a394:	0e 9b       	mov	r11,r7
8000a396:	0a 9c       	mov	r12,r5
8000a398:	fe b0 f6 c4 	rcall	80009120 <__swsetup_r>
8000a39c:	c0 70       	breq	8000a3aa <__sfvwrite_r+0x36>
8000a39e:	8e 68       	ld.sh	r8,r7[0xc]
8000a3a0:	a7 a8       	sbr	r8,0x6
8000a3a2:	ae 68       	st.h	r7[0xc],r8
8000a3a4:	30 98       	mov	r8,9
8000a3a6:	8b 38       	st.w	r5[0xc],r8
8000a3a8:	c2 b9       	rjmp	8000a5fe <__sfvwrite_r+0x28a>
8000a3aa:	8e 63       	ld.sh	r3,r7[0xc]
8000a3ac:	68 00       	ld.w	r0,r4[0x0]
8000a3ae:	06 96       	mov	r6,r3
8000a3b0:	e2 16 00 02 	andl	r6,0x2,COH
8000a3b4:	c2 10       	breq	8000a3f6 <__sfvwrite_r+0x82>
8000a3b6:	30 03       	mov	r3,0
8000a3b8:	e0 62 04 00 	mov	r2,1024
8000a3bc:	06 96       	mov	r6,r3
8000a3be:	c0 48       	rjmp	8000a3c6 <__sfvwrite_r+0x52>
8000a3c0:	60 03       	ld.w	r3,r0[0x0]
8000a3c2:	60 16       	ld.w	r6,r0[0x4]
8000a3c4:	2f 80       	sub	r0,-8
8000a3c6:	58 06       	cp.w	r6,0
8000a3c8:	cf c0       	breq	8000a3c0 <__sfvwrite_r+0x4c>
8000a3ca:	e0 46 04 00 	cp.w	r6,1024
8000a3ce:	ec 09 17 80 	movls	r9,r6
8000a3d2:	e4 09 17 b0 	movhi	r9,r2
8000a3d6:	06 9a       	mov	r10,r3
8000a3d8:	6e a8       	ld.w	r8,r7[0x28]
8000a3da:	6e 8b       	ld.w	r11,r7[0x20]
8000a3dc:	0a 9c       	mov	r12,r5
8000a3de:	5d 18       	icall	r8
8000a3e0:	18 16       	sub	r6,r12
8000a3e2:	58 0c       	cp.w	r12,0
8000a3e4:	e0 8a 01 0a 	brle	8000a5f8 <__sfvwrite_r+0x284>
8000a3e8:	68 28       	ld.w	r8,r4[0x8]
8000a3ea:	18 18       	sub	r8,r12
8000a3ec:	89 28       	st.w	r4[0x8],r8
8000a3ee:	e0 80 01 0a 	breq	8000a602 <__sfvwrite_r+0x28e>
8000a3f2:	18 03       	add	r3,r12
8000a3f4:	ce 9b       	rjmp	8000a3c6 <__sfvwrite_r+0x52>
8000a3f6:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
8000a3fa:	c0 70       	breq	8000a408 <__sfvwrite_r+0x94>
8000a3fc:	50 06       	stdsp	sp[0x0],r6
8000a3fe:	0c 93       	mov	r3,r6
8000a400:	0c 91       	mov	r1,r6
8000a402:	50 15       	stdsp	sp[0x4],r5
8000a404:	08 92       	mov	r2,r4
8000a406:	c9 c8       	rjmp	8000a53e <__sfvwrite_r+0x1ca>
8000a408:	06 96       	mov	r6,r3
8000a40a:	08 91       	mov	r1,r4
8000a40c:	c0 48       	rjmp	8000a414 <__sfvwrite_r+0xa0>
8000a40e:	60 03       	ld.w	r3,r0[0x0]
8000a410:	60 16       	ld.w	r6,r0[0x4]
8000a412:	2f 80       	sub	r0,-8
8000a414:	58 06       	cp.w	r6,0
8000a416:	cf c0       	breq	8000a40e <__sfvwrite_r+0x9a>
8000a418:	8e 68       	ld.sh	r8,r7[0xc]
8000a41a:	6e 24       	ld.w	r4,r7[0x8]
8000a41c:	10 99       	mov	r9,r8
8000a41e:	e2 19 02 00 	andl	r9,0x200,COH
8000a422:	c5 50       	breq	8000a4cc <__sfvwrite_r+0x158>
8000a424:	08 36       	cp.w	r6,r4
8000a426:	c4 43       	brcs	8000a4ae <__sfvwrite_r+0x13a>
8000a428:	10 99       	mov	r9,r8
8000a42a:	e2 19 04 80 	andl	r9,0x480,COH
8000a42e:	c4 00       	breq	8000a4ae <__sfvwrite_r+0x13a>
8000a430:	6e 4b       	ld.w	r11,r7[0x10]
8000a432:	6e 09       	ld.w	r9,r7[0x0]
8000a434:	16 19       	sub	r9,r11
8000a436:	50 09       	stdsp	sp[0x0],r9
8000a438:	6e 59       	ld.w	r9,r7[0x14]
8000a43a:	10 9c       	mov	r12,r8
8000a43c:	f2 09 00 1a 	add	r10,r9,r9<<0x1
8000a440:	30 28       	mov	r8,2
8000a442:	f4 08 0c 08 	divs	r8,r10,r8
8000a446:	fa e9 00 04 	st.d	sp[4],r8
8000a44a:	10 94       	mov	r4,r8
8000a44c:	40 09       	lddsp	r9,sp[0x0]
8000a44e:	e2 1c 04 00 	andl	r12,0x400,COH
8000a452:	2f f9       	sub	r9,-1
8000a454:	0c 09       	add	r9,r6
8000a456:	12 38       	cp.w	r8,r9
8000a458:	f2 04 17 30 	movlo	r4,r9
8000a45c:	58 0c       	cp.w	r12,0
8000a45e:	c1 10       	breq	8000a480 <__sfvwrite_r+0x10c>
8000a460:	08 9b       	mov	r11,r4
8000a462:	0a 9c       	mov	r12,r5
8000a464:	fe b0 e0 60 	rcall	80006524 <_malloc_r>
8000a468:	18 92       	mov	r2,r12
8000a46a:	c1 40       	breq	8000a492 <__sfvwrite_r+0x11e>
8000a46c:	40 0a       	lddsp	r10,sp[0x0]
8000a46e:	6e 4b       	ld.w	r11,r7[0x10]
8000a470:	fe b0 e2 76 	rcall	8000695c <memcpy>
8000a474:	8e 68       	ld.sh	r8,r7[0xc]
8000a476:	e0 18 fb 7f 	andl	r8,0xfb7f
8000a47a:	a7 b8       	sbr	r8,0x7
8000a47c:	ae 68       	st.h	r7[0xc],r8
8000a47e:	c0 d8       	rjmp	8000a498 <__sfvwrite_r+0x124>
8000a480:	08 9a       	mov	r10,r4
8000a482:	0a 9c       	mov	r12,r5
8000a484:	fe b0 e3 18 	rcall	80006ab4 <_realloc_r>
8000a488:	18 92       	mov	r2,r12
8000a48a:	c0 71       	brne	8000a498 <__sfvwrite_r+0x124>
8000a48c:	6e 4b       	ld.w	r11,r7[0x10]
8000a48e:	0a 9c       	mov	r12,r5
8000a490:	ca ce       	rcall	8000a1e8 <_free_r>
8000a492:	30 c8       	mov	r8,12
8000a494:	8b 38       	st.w	r5[0xc],r8
8000a496:	cb 18       	rjmp	8000a5f8 <__sfvwrite_r+0x284>
8000a498:	40 0a       	lddsp	r10,sp[0x0]
8000a49a:	40 09       	lddsp	r9,sp[0x0]
8000a49c:	e8 0a 01 0a 	sub	r10,r4,r10
8000a4a0:	e4 09 00 08 	add	r8,r2,r9
8000a4a4:	8f 54       	st.w	r7[0x14],r4
8000a4a6:	8f 2a       	st.w	r7[0x8],r10
8000a4a8:	8f 08       	st.w	r7[0x0],r8
8000a4aa:	8f 42       	st.w	r7[0x10],r2
8000a4ac:	0c 94       	mov	r4,r6
8000a4ae:	08 36       	cp.w	r6,r4
8000a4b0:	ec 04 17 30 	movlo	r4,r6
8000a4b4:	06 9b       	mov	r11,r3
8000a4b6:	08 9a       	mov	r10,r4
8000a4b8:	6e 0c       	ld.w	r12,r7[0x0]
8000a4ba:	c3 ad       	rcall	8000a72e <memmove>
8000a4bc:	6e 08       	ld.w	r8,r7[0x0]
8000a4be:	08 08       	add	r8,r4
8000a4c0:	8f 08       	st.w	r7[0x0],r8
8000a4c2:	6e 28       	ld.w	r8,r7[0x8]
8000a4c4:	08 18       	sub	r8,r4
8000a4c6:	0c 94       	mov	r4,r6
8000a4c8:	8f 28       	st.w	r7[0x8],r8
8000a4ca:	c2 e8       	rjmp	8000a526 <__sfvwrite_r+0x1b2>
8000a4cc:	08 36       	cp.w	r6,r4
8000a4ce:	5f ba       	srhi	r10
8000a4d0:	6e 0c       	ld.w	r12,r7[0x0]
8000a4d2:	6e 48       	ld.w	r8,r7[0x10]
8000a4d4:	10 3c       	cp.w	r12,r8
8000a4d6:	5f b8       	srhi	r8
8000a4d8:	f5 e8 00 08 	and	r8,r10,r8
8000a4dc:	f2 08 18 00 	cp.b	r8,r9
8000a4e0:	c0 d0       	breq	8000a4fa <__sfvwrite_r+0x186>
8000a4e2:	06 9b       	mov	r11,r3
8000a4e4:	08 9a       	mov	r10,r4
8000a4e6:	c2 4d       	rcall	8000a72e <memmove>
8000a4e8:	6e 08       	ld.w	r8,r7[0x0]
8000a4ea:	08 08       	add	r8,r4
8000a4ec:	0e 9b       	mov	r11,r7
8000a4ee:	8f 08       	st.w	r7[0x0],r8
8000a4f0:	0a 9c       	mov	r12,r5
8000a4f2:	fe b0 fd 09 	rcall	80009f04 <_fflush_r>
8000a4f6:	c1 80       	breq	8000a526 <__sfvwrite_r+0x1b2>
8000a4f8:	c8 08       	rjmp	8000a5f8 <__sfvwrite_r+0x284>
8000a4fa:	6e 59       	ld.w	r9,r7[0x14]
8000a4fc:	12 36       	cp.w	r6,r9
8000a4fe:	c0 a3       	brcs	8000a512 <__sfvwrite_r+0x19e>
8000a500:	6e a8       	ld.w	r8,r7[0x28]
8000a502:	06 9a       	mov	r10,r3
8000a504:	6e 8b       	ld.w	r11,r7[0x20]
8000a506:	0a 9c       	mov	r12,r5
8000a508:	5d 18       	icall	r8
8000a50a:	18 94       	mov	r4,r12
8000a50c:	e0 89 00 0d 	brgt	8000a526 <__sfvwrite_r+0x1b2>
8000a510:	c7 48       	rjmp	8000a5f8 <__sfvwrite_r+0x284>
8000a512:	0c 9a       	mov	r10,r6
8000a514:	06 9b       	mov	r11,r3
8000a516:	c0 cd       	rcall	8000a72e <memmove>
8000a518:	6e 08       	ld.w	r8,r7[0x0]
8000a51a:	0c 08       	add	r8,r6
8000a51c:	0c 94       	mov	r4,r6
8000a51e:	8f 08       	st.w	r7[0x0],r8
8000a520:	6e 28       	ld.w	r8,r7[0x8]
8000a522:	0c 18       	sub	r8,r6
8000a524:	8f 28       	st.w	r7[0x8],r8
8000a526:	62 28       	ld.w	r8,r1[0x8]
8000a528:	08 18       	sub	r8,r4
8000a52a:	83 28       	st.w	r1[0x8],r8
8000a52c:	c6 b0       	breq	8000a602 <__sfvwrite_r+0x28e>
8000a52e:	08 16       	sub	r6,r4
8000a530:	08 03       	add	r3,r4
8000a532:	c7 1b       	rjmp	8000a414 <__sfvwrite_r+0xa0>
8000a534:	60 03       	ld.w	r3,r0[0x0]
8000a536:	60 11       	ld.w	r1,r0[0x4]
8000a538:	30 08       	mov	r8,0
8000a53a:	2f 80       	sub	r0,-8
8000a53c:	50 08       	stdsp	sp[0x0],r8
8000a53e:	58 01       	cp.w	r1,0
8000a540:	cf a0       	breq	8000a534 <__sfvwrite_r+0x1c0>
8000a542:	40 0a       	lddsp	r10,sp[0x0]
8000a544:	58 0a       	cp.w	r10,0
8000a546:	c1 41       	brne	8000a56e <__sfvwrite_r+0x1fa>
8000a548:	e2 c6 ff ff 	sub	r6,r1,-1
8000a54c:	02 9a       	mov	r10,r1
8000a54e:	30 ab       	mov	r11,10
8000a550:	06 9c       	mov	r12,r3
8000a552:	ce 3c       	rcall	8000a718 <memchr>
8000a554:	f8 c8 ff ff 	sub	r8,r12,-1
8000a558:	58 0c       	cp.w	r12,0
8000a55a:	f1 d3 e1 16 	subne	r6,r8,r3
8000a55e:	f9 b9 01 01 	movne	r9,1
8000a562:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000a566:	f9 b8 00 01 	moveq	r8,1
8000a56a:	fb f8 0a 00 	st.weq	sp[0x0],r8
8000a56e:	02 36       	cp.w	r6,r1
8000a570:	ec 04 17 80 	movls	r4,r6
8000a574:	e2 04 17 b0 	movhi	r4,r1
8000a578:	6e 59       	ld.w	r9,r7[0x14]
8000a57a:	6e 25       	ld.w	r5,r7[0x8]
8000a57c:	f2 05 00 05 	add	r5,r9,r5
8000a580:	0a 34       	cp.w	r4,r5
8000a582:	5f 9a       	srgt	r10
8000a584:	6e 0c       	ld.w	r12,r7[0x0]
8000a586:	6e 48       	ld.w	r8,r7[0x10]
8000a588:	10 3c       	cp.w	r12,r8
8000a58a:	5f b8       	srhi	r8
8000a58c:	f5 e8 00 08 	and	r8,r10,r8
8000a590:	30 0a       	mov	r10,0
8000a592:	f4 08 18 00 	cp.b	r8,r10
8000a596:	c0 d0       	breq	8000a5b0 <__sfvwrite_r+0x23c>
8000a598:	06 9b       	mov	r11,r3
8000a59a:	0a 9a       	mov	r10,r5
8000a59c:	cc 9c       	rcall	8000a72e <memmove>
8000a59e:	6e 08       	ld.w	r8,r7[0x0]
8000a5a0:	0a 08       	add	r8,r5
8000a5a2:	0e 9b       	mov	r11,r7
8000a5a4:	8f 08       	st.w	r7[0x0],r8
8000a5a6:	40 1c       	lddsp	r12,sp[0x4]
8000a5a8:	fe b0 fc ae 	rcall	80009f04 <_fflush_r>
8000a5ac:	c1 70       	breq	8000a5da <__sfvwrite_r+0x266>
8000a5ae:	c2 58       	rjmp	8000a5f8 <__sfvwrite_r+0x284>
8000a5b0:	12 34       	cp.w	r4,r9
8000a5b2:	c0 a5       	brlt	8000a5c6 <__sfvwrite_r+0x252>
8000a5b4:	6e a8       	ld.w	r8,r7[0x28]
8000a5b6:	06 9a       	mov	r10,r3
8000a5b8:	6e 8b       	ld.w	r11,r7[0x20]
8000a5ba:	40 1c       	lddsp	r12,sp[0x4]
8000a5bc:	5d 18       	icall	r8
8000a5be:	18 95       	mov	r5,r12
8000a5c0:	e0 89 00 0d 	brgt	8000a5da <__sfvwrite_r+0x266>
8000a5c4:	c1 a8       	rjmp	8000a5f8 <__sfvwrite_r+0x284>
8000a5c6:	08 9a       	mov	r10,r4
8000a5c8:	06 9b       	mov	r11,r3
8000a5ca:	cb 2c       	rcall	8000a72e <memmove>
8000a5cc:	6e 08       	ld.w	r8,r7[0x0]
8000a5ce:	08 08       	add	r8,r4
8000a5d0:	08 95       	mov	r5,r4
8000a5d2:	8f 08       	st.w	r7[0x0],r8
8000a5d4:	6e 28       	ld.w	r8,r7[0x8]
8000a5d6:	08 18       	sub	r8,r4
8000a5d8:	8f 28       	st.w	r7[0x8],r8
8000a5da:	0a 16       	sub	r6,r5
8000a5dc:	c0 71       	brne	8000a5ea <__sfvwrite_r+0x276>
8000a5de:	0e 9b       	mov	r11,r7
8000a5e0:	40 1c       	lddsp	r12,sp[0x4]
8000a5e2:	fe b0 fc 91 	rcall	80009f04 <_fflush_r>
8000a5e6:	c0 91       	brne	8000a5f8 <__sfvwrite_r+0x284>
8000a5e8:	50 06       	stdsp	sp[0x0],r6
8000a5ea:	64 28       	ld.w	r8,r2[0x8]
8000a5ec:	0a 18       	sub	r8,r5
8000a5ee:	85 28       	st.w	r2[0x8],r8
8000a5f0:	c0 90       	breq	8000a602 <__sfvwrite_r+0x28e>
8000a5f2:	0a 11       	sub	r1,r5
8000a5f4:	0a 03       	add	r3,r5
8000a5f6:	ca 4b       	rjmp	8000a53e <__sfvwrite_r+0x1ca>
8000a5f8:	8e 68       	ld.sh	r8,r7[0xc]
8000a5fa:	a7 a8       	sbr	r8,0x6
8000a5fc:	ae 68       	st.h	r7[0xc],r8
8000a5fe:	3f fc       	mov	r12,-1
8000a600:	c0 28       	rjmp	8000a604 <__sfvwrite_r+0x290>
8000a602:	30 0c       	mov	r12,0
8000a604:	2f dd       	sub	sp,-12
8000a606:	d8 32       	popm	r0-r7,pc

8000a608 <_fwalk>:
8000a608:	d4 31       	pushm	r0-r7,lr
8000a60a:	30 05       	mov	r5,0
8000a60c:	16 91       	mov	r1,r11
8000a60e:	f8 c7 ff 28 	sub	r7,r12,-216
8000a612:	0a 92       	mov	r2,r5
8000a614:	fe b0 fc fe 	rcall	8000a010 <__sfp_lock_acquire>
8000a618:	3f f3       	mov	r3,-1
8000a61a:	c1 68       	rjmp	8000a646 <_fwalk+0x3e>
8000a61c:	6e 26       	ld.w	r6,r7[0x8]
8000a61e:	6e 14       	ld.w	r4,r7[0x4]
8000a620:	2f 46       	sub	r6,-12
8000a622:	c0 c8       	rjmp	8000a63a <_fwalk+0x32>
8000a624:	8c 08       	ld.sh	r8,r6[0x0]
8000a626:	e4 08 19 00 	cp.h	r8,r2
8000a62a:	c0 70       	breq	8000a638 <_fwalk+0x30>
8000a62c:	8c 18       	ld.sh	r8,r6[0x2]
8000a62e:	e6 08 19 00 	cp.h	r8,r3
8000a632:	c0 30       	breq	8000a638 <_fwalk+0x30>
8000a634:	5d 11       	icall	r1
8000a636:	18 45       	or	r5,r12
8000a638:	2a 46       	sub	r6,-92
8000a63a:	20 14       	sub	r4,1
8000a63c:	ec cc 00 0c 	sub	r12,r6,12
8000a640:	58 04       	cp.w	r4,0
8000a642:	cf 14       	brge	8000a624 <_fwalk+0x1c>
8000a644:	6e 07       	ld.w	r7,r7[0x0]
8000a646:	58 07       	cp.w	r7,0
8000a648:	ce a1       	brne	8000a61c <_fwalk+0x14>
8000a64a:	fe b0 fc e4 	rcall	8000a012 <__sfp_lock_release>
8000a64e:	0a 9c       	mov	r12,r5
8000a650:	d8 32       	popm	r0-r7,pc
8000a652:	d7 03       	nop

8000a654 <_localeconv_r>:
8000a654:	fe cc d6 78 	sub	r12,pc,-10632
8000a658:	5e fc       	retal	r12
8000a65a:	d7 03       	nop

8000a65c <__smakebuf_r>:
8000a65c:	d4 21       	pushm	r4-r7,lr
8000a65e:	20 fd       	sub	sp,60
8000a660:	96 68       	ld.sh	r8,r11[0xc]
8000a662:	16 97       	mov	r7,r11
8000a664:	18 96       	mov	r6,r12
8000a666:	e2 18 00 02 	andl	r8,0x2,COH
8000a66a:	c3 d1       	brne	8000a6e4 <__smakebuf_r+0x88>
8000a66c:	96 7b       	ld.sh	r11,r11[0xe]
8000a66e:	f0 0b 19 00 	cp.h	r11,r8
8000a672:	c0 55       	brlt	8000a67c <__smakebuf_r+0x20>
8000a674:	1a 9a       	mov	r10,sp
8000a676:	e0 a0 04 75 	rcall	8000af60 <_fstat_r>
8000a67a:	c0 f4       	brge	8000a698 <__smakebuf_r+0x3c>
8000a67c:	8e 65       	ld.sh	r5,r7[0xc]
8000a67e:	0a 98       	mov	r8,r5
8000a680:	ab b8       	sbr	r8,0xb
8000a682:	e2 15 00 80 	andl	r5,0x80,COH
8000a686:	ae 68       	st.h	r7[0xc],r8
8000a688:	30 04       	mov	r4,0
8000a68a:	e0 68 04 00 	mov	r8,1024
8000a68e:	f9 b5 01 40 	movne	r5,64
8000a692:	f0 05 17 00 	moveq	r5,r8
8000a696:	c1 c8       	rjmp	8000a6ce <__smakebuf_r+0x72>
8000a698:	40 18       	lddsp	r8,sp[0x4]
8000a69a:	e2 18 f0 00 	andl	r8,0xf000,COH
8000a69e:	e0 48 20 00 	cp.w	r8,8192
8000a6a2:	5f 04       	sreq	r4
8000a6a4:	e0 48 80 00 	cp.w	r8,32768
8000a6a8:	c0 e1       	brne	8000a6c4 <__smakebuf_r+0x68>
8000a6aa:	6e b9       	ld.w	r9,r7[0x2c]
8000a6ac:	fe c8 f9 1c 	sub	r8,pc,-1764
8000a6b0:	10 39       	cp.w	r9,r8
8000a6b2:	c0 91       	brne	8000a6c4 <__smakebuf_r+0x68>
8000a6b4:	8e 68       	ld.sh	r8,r7[0xc]
8000a6b6:	e0 65 04 00 	mov	r5,1024
8000a6ba:	ab a8       	sbr	r8,0xa
8000a6bc:	ef 45 00 50 	st.w	r7[80],r5
8000a6c0:	ae 68       	st.h	r7[0xc],r8
8000a6c2:	c0 68       	rjmp	8000a6ce <__smakebuf_r+0x72>
8000a6c4:	8e 68       	ld.sh	r8,r7[0xc]
8000a6c6:	e0 65 04 00 	mov	r5,1024
8000a6ca:	ab b8       	sbr	r8,0xb
8000a6cc:	ae 68       	st.h	r7[0xc],r8
8000a6ce:	0a 9b       	mov	r11,r5
8000a6d0:	0c 9c       	mov	r12,r6
8000a6d2:	fe b0 df 29 	rcall	80006524 <_malloc_r>
8000a6d6:	8e 68       	ld.sh	r8,r7[0xc]
8000a6d8:	c0 d1       	brne	8000a6f2 <__smakebuf_r+0x96>
8000a6da:	ed b8 00 09 	bld	r8,0x9
8000a6de:	c1 b0       	breq	8000a714 <__smakebuf_r+0xb8>
8000a6e0:	a1 b8       	sbr	r8,0x1
8000a6e2:	ae 68       	st.h	r7[0xc],r8
8000a6e4:	ee c8 ff b9 	sub	r8,r7,-71
8000a6e8:	8f 48       	st.w	r7[0x10],r8
8000a6ea:	8f 08       	st.w	r7[0x0],r8
8000a6ec:	30 18       	mov	r8,1
8000a6ee:	8f 58       	st.w	r7[0x14],r8
8000a6f0:	c1 28       	rjmp	8000a714 <__smakebuf_r+0xb8>
8000a6f2:	a7 b8       	sbr	r8,0x7
8000a6f4:	8f 4c       	st.w	r7[0x10],r12
8000a6f6:	ae 68       	st.h	r7[0xc],r8
8000a6f8:	8f 55       	st.w	r7[0x14],r5
8000a6fa:	fe c8 06 e6 	sub	r8,pc,1766
8000a6fe:	8f 0c       	st.w	r7[0x0],r12
8000a700:	8d a8       	st.w	r6[0x28],r8
8000a702:	58 04       	cp.w	r4,0
8000a704:	c0 80       	breq	8000a714 <__smakebuf_r+0xb8>
8000a706:	8e 7c       	ld.sh	r12,r7[0xe]
8000a708:	fe b0 e3 94 	rcall	80006e30 <isatty>
8000a70c:	c0 40       	breq	8000a714 <__smakebuf_r+0xb8>
8000a70e:	8e 68       	ld.sh	r8,r7[0xc]
8000a710:	a1 a8       	sbr	r8,0x0
8000a712:	ae 68       	st.h	r7[0xc],r8
8000a714:	2f 1d       	sub	sp,-60
8000a716:	d8 22       	popm	r4-r7,pc

8000a718 <memchr>:
8000a718:	f7 db c0 08 	bfextu	r11,r11,0x0,0x8
8000a71c:	c0 68       	rjmp	8000a728 <memchr+0x10>
8000a71e:	20 1a       	sub	r10,1
8000a720:	19 88       	ld.ub	r8,r12[0x0]
8000a722:	16 38       	cp.w	r8,r11
8000a724:	5e 0c       	reteq	r12
8000a726:	2f fc       	sub	r12,-1
8000a728:	58 0a       	cp.w	r10,0
8000a72a:	cf a1       	brne	8000a71e <memchr+0x6>
8000a72c:	5e fa       	retal	r10

8000a72e <memmove>:
8000a72e:	d4 01       	pushm	lr
8000a730:	18 3b       	cp.w	r11,r12
8000a732:	c1 92       	brcc	8000a764 <memmove+0x36>
8000a734:	f6 0a 00 09 	add	r9,r11,r10
8000a738:	12 3c       	cp.w	r12,r9
8000a73a:	c1 52       	brcc	8000a764 <memmove+0x36>
8000a73c:	f8 0a 00 0b 	add	r11,r12,r10
8000a740:	30 08       	mov	r8,0
8000a742:	c0 68       	rjmp	8000a74e <memmove+0x20>
8000a744:	f2 08 07 0e 	ld.ub	lr,r9[r8]
8000a748:	20 1a       	sub	r10,1
8000a74a:	f6 08 0b 0e 	st.b	r11[r8],lr
8000a74e:	20 18       	sub	r8,1
8000a750:	58 0a       	cp.w	r10,0
8000a752:	cf 91       	brne	8000a744 <memmove+0x16>
8000a754:	d8 02       	popm	pc
8000a756:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000a75a:	20 1a       	sub	r10,1
8000a75c:	f8 08 0b 09 	st.b	r12[r8],r9
8000a760:	2f f8       	sub	r8,-1
8000a762:	c0 28       	rjmp	8000a766 <memmove+0x38>
8000a764:	30 08       	mov	r8,0
8000a766:	58 0a       	cp.w	r10,0
8000a768:	cf 71       	brne	8000a756 <memmove+0x28>
8000a76a:	d8 02       	popm	pc

8000a76c <__hi0bits>:
8000a76c:	18 98       	mov	r8,r12
8000a76e:	e0 1c 00 00 	andl	r12,0x0
8000a772:	f0 09 15 10 	lsl	r9,r8,0x10
8000a776:	58 0c       	cp.w	r12,0
8000a778:	f2 08 17 00 	moveq	r8,r9
8000a77c:	f9 bc 00 10 	moveq	r12,16
8000a780:	f9 bc 01 00 	movne	r12,0
8000a784:	10 9a       	mov	r10,r8
8000a786:	f0 09 15 08 	lsl	r9,r8,0x8
8000a78a:	e6 1a ff 00 	andh	r10,0xff00,COH
8000a78e:	f7 bc 00 f8 	subeq	r12,-8
8000a792:	f2 08 17 00 	moveq	r8,r9
8000a796:	10 9a       	mov	r10,r8
8000a798:	f0 09 15 04 	lsl	r9,r8,0x4
8000a79c:	e6 1a f0 00 	andh	r10,0xf000,COH
8000a7a0:	f7 bc 00 fc 	subeq	r12,-4
8000a7a4:	f2 08 17 00 	moveq	r8,r9
8000a7a8:	10 9a       	mov	r10,r8
8000a7aa:	f0 09 15 02 	lsl	r9,r8,0x2
8000a7ae:	e6 1a c0 00 	andh	r10,0xc000,COH
8000a7b2:	f7 bc 00 fe 	subeq	r12,-2
8000a7b6:	f2 08 17 00 	moveq	r8,r9
8000a7ba:	58 08       	cp.w	r8,0
8000a7bc:	5e 5c       	retlt	r12
8000a7be:	ed b8 00 1e 	bld	r8,0x1e
8000a7c2:	f9 bc 01 20 	movne	r12,32
8000a7c6:	f7 bc 00 ff 	subeq	r12,-1
8000a7ca:	5e fc       	retal	r12

8000a7cc <__lo0bits>:
8000a7cc:	18 99       	mov	r9,r12
8000a7ce:	78 08       	ld.w	r8,r12[0x0]
8000a7d0:	f9 d8 c0 03 	bfextu	r12,r8,0x0,0x3
8000a7d4:	c1 50       	breq	8000a7fe <__lo0bits+0x32>
8000a7d6:	ed b8 00 00 	bld	r8,0x0
8000a7da:	c0 21       	brne	8000a7de <__lo0bits+0x12>
8000a7dc:	5e fd       	retal	0
8000a7de:	10 9b       	mov	r11,r8
8000a7e0:	f0 0a 16 01 	lsr	r10,r8,0x1
8000a7e4:	e2 1b 00 02 	andl	r11,0x2,COH
8000a7e8:	a3 88       	lsr	r8,0x2
8000a7ea:	58 0b       	cp.w	r11,0
8000a7ec:	f3 fa 1a 00 	st.wne	r9[0x0],r10
8000a7f0:	f9 bc 01 01 	movne	r12,1
8000a7f4:	f3 f8 0a 00 	st.weq	r9[0x0],r8
8000a7f8:	f9 bc 00 02 	moveq	r12,2
8000a7fc:	5e fc       	retal	r12
8000a7fe:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8000a802:	f0 0b 16 10 	lsr	r11,r8,0x10
8000a806:	58 0a       	cp.w	r10,0
8000a808:	f6 08 17 00 	moveq	r8,r11
8000a80c:	f9 bc 00 10 	moveq	r12,16
8000a810:	f7 d8 c0 08 	bfextu	r11,r8,0x0,0x8
8000a814:	f0 0a 16 08 	lsr	r10,r8,0x8
8000a818:	58 0b       	cp.w	r11,0
8000a81a:	f7 bc 00 f8 	subeq	r12,-8
8000a81e:	f4 08 17 00 	moveq	r8,r10
8000a822:	f7 d8 c0 04 	bfextu	r11,r8,0x0,0x4
8000a826:	f0 0a 16 04 	lsr	r10,r8,0x4
8000a82a:	58 0b       	cp.w	r11,0
8000a82c:	f7 bc 00 fc 	subeq	r12,-4
8000a830:	f4 08 17 00 	moveq	r8,r10
8000a834:	f7 d8 c0 02 	bfextu	r11,r8,0x0,0x2
8000a838:	f0 0a 16 02 	lsr	r10,r8,0x2
8000a83c:	58 0b       	cp.w	r11,0
8000a83e:	f7 bc 00 fe 	subeq	r12,-2
8000a842:	f4 08 17 00 	moveq	r8,r10
8000a846:	ed b8 00 00 	bld	r8,0x0
8000a84a:	c0 60       	breq	8000a856 <__lo0bits+0x8a>
8000a84c:	a1 98       	lsr	r8,0x1
8000a84e:	c0 31       	brne	8000a854 <__lo0bits+0x88>
8000a850:	32 0c       	mov	r12,32
8000a852:	5e fc       	retal	r12
8000a854:	2f fc       	sub	r12,-1
8000a856:	93 08       	st.w	r9[0x0],r8
8000a858:	5e fc       	retal	r12

8000a85a <__mcmp>:
8000a85a:	d4 01       	pushm	lr
8000a85c:	18 98       	mov	r8,r12
8000a85e:	76 49       	ld.w	r9,r11[0x10]
8000a860:	78 4c       	ld.w	r12,r12[0x10]
8000a862:	12 1c       	sub	r12,r9
8000a864:	c1 31       	brne	8000a88a <__mcmp+0x30>
8000a866:	2f b9       	sub	r9,-5
8000a868:	a3 69       	lsl	r9,0x2
8000a86a:	12 0b       	add	r11,r9
8000a86c:	f0 09 00 09 	add	r9,r8,r9
8000a870:	2e c8       	sub	r8,-20
8000a872:	13 4e       	ld.w	lr,--r9
8000a874:	17 4a       	ld.w	r10,--r11
8000a876:	14 3e       	cp.w	lr,r10
8000a878:	c0 60       	breq	8000a884 <__mcmp+0x2a>
8000a87a:	f9 bc 03 ff 	movlo	r12,-1
8000a87e:	f9 bc 02 01 	movhs	r12,1
8000a882:	d8 02       	popm	pc
8000a884:	10 39       	cp.w	r9,r8
8000a886:	fe 9b ff f6 	brhi	8000a872 <__mcmp+0x18>
8000a88a:	d8 02       	popm	pc

8000a88c <_Bfree>:
8000a88c:	d4 21       	pushm	r4-r7,lr
8000a88e:	18 97       	mov	r7,r12
8000a890:	16 95       	mov	r5,r11
8000a892:	78 96       	ld.w	r6,r12[0x24]
8000a894:	58 06       	cp.w	r6,0
8000a896:	c0 91       	brne	8000a8a8 <_Bfree+0x1c>
8000a898:	31 0c       	mov	r12,16
8000a89a:	fe b0 de 3d 	rcall	80006514 <malloc>
8000a89e:	99 36       	st.w	r12[0xc],r6
8000a8a0:	8f 9c       	st.w	r7[0x24],r12
8000a8a2:	99 16       	st.w	r12[0x4],r6
8000a8a4:	99 26       	st.w	r12[0x8],r6
8000a8a6:	99 06       	st.w	r12[0x0],r6
8000a8a8:	58 05       	cp.w	r5,0
8000a8aa:	c0 90       	breq	8000a8bc <_Bfree+0x30>
8000a8ac:	6a 19       	ld.w	r9,r5[0x4]
8000a8ae:	6e 98       	ld.w	r8,r7[0x24]
8000a8b0:	70 38       	ld.w	r8,r8[0xc]
8000a8b2:	f0 09 03 2a 	ld.w	r10,r8[r9<<0x2]
8000a8b6:	8b 0a       	st.w	r5[0x0],r10
8000a8b8:	f0 09 09 25 	st.w	r8[r9<<0x2],r5
8000a8bc:	d8 22       	popm	r4-r7,pc
8000a8be:	d7 03       	nop

8000a8c0 <_Balloc>:
8000a8c0:	d4 21       	pushm	r4-r7,lr
8000a8c2:	18 97       	mov	r7,r12
8000a8c4:	16 96       	mov	r6,r11
8000a8c6:	78 95       	ld.w	r5,r12[0x24]
8000a8c8:	58 05       	cp.w	r5,0
8000a8ca:	c0 91       	brne	8000a8dc <_Balloc+0x1c>
8000a8cc:	31 0c       	mov	r12,16
8000a8ce:	fe b0 de 23 	rcall	80006514 <malloc>
8000a8d2:	99 35       	st.w	r12[0xc],r5
8000a8d4:	8f 9c       	st.w	r7[0x24],r12
8000a8d6:	99 15       	st.w	r12[0x4],r5
8000a8d8:	99 25       	st.w	r12[0x8],r5
8000a8da:	99 05       	st.w	r12[0x0],r5
8000a8dc:	6e 95       	ld.w	r5,r7[0x24]
8000a8de:	6a 38       	ld.w	r8,r5[0xc]
8000a8e0:	58 08       	cp.w	r8,0
8000a8e2:	c0 b1       	brne	8000a8f8 <_Balloc+0x38>
8000a8e4:	31 0a       	mov	r10,16
8000a8e6:	30 4b       	mov	r11,4
8000a8e8:	0e 9c       	mov	r12,r7
8000a8ea:	e0 a0 02 9b 	rcall	8000ae20 <_calloc_r>
8000a8ee:	8b 3c       	st.w	r5[0xc],r12
8000a8f0:	6e 98       	ld.w	r8,r7[0x24]
8000a8f2:	70 3c       	ld.w	r12,r8[0xc]
8000a8f4:	58 0c       	cp.w	r12,0
8000a8f6:	c1 b0       	breq	8000a92c <_Balloc+0x6c>
8000a8f8:	6e 98       	ld.w	r8,r7[0x24]
8000a8fa:	70 38       	ld.w	r8,r8[0xc]
8000a8fc:	f0 06 00 28 	add	r8,r8,r6<<0x2
8000a900:	70 0c       	ld.w	r12,r8[0x0]
8000a902:	58 0c       	cp.w	r12,0
8000a904:	c0 40       	breq	8000a90c <_Balloc+0x4c>
8000a906:	78 09       	ld.w	r9,r12[0x0]
8000a908:	91 09       	st.w	r8[0x0],r9
8000a90a:	c0 e8       	rjmp	8000a926 <_Balloc+0x66>
8000a90c:	0e 9c       	mov	r12,r7
8000a90e:	30 17       	mov	r7,1
8000a910:	0e 9b       	mov	r11,r7
8000a912:	ee 06 09 47 	lsl	r7,r7,r6
8000a916:	ee ca ff fb 	sub	r10,r7,-5
8000a91a:	a3 6a       	lsl	r10,0x2
8000a91c:	e0 a0 02 82 	rcall	8000ae20 <_calloc_r>
8000a920:	c0 60       	breq	8000a92c <_Balloc+0x6c>
8000a922:	99 16       	st.w	r12[0x4],r6
8000a924:	99 27       	st.w	r12[0x8],r7
8000a926:	30 08       	mov	r8,0
8000a928:	99 38       	st.w	r12[0xc],r8
8000a92a:	99 48       	st.w	r12[0x10],r8
8000a92c:	d8 22       	popm	r4-r7,pc
8000a92e:	d7 03       	nop

8000a930 <__d2b>:
8000a930:	d4 31       	pushm	r0-r7,lr
8000a932:	20 2d       	sub	sp,8
8000a934:	16 93       	mov	r3,r11
8000a936:	12 96       	mov	r6,r9
8000a938:	10 95       	mov	r5,r8
8000a93a:	14 92       	mov	r2,r10
8000a93c:	30 1b       	mov	r11,1
8000a93e:	cc 1f       	rcall	8000a8c0 <_Balloc>
8000a940:	f3 d3 c0 14 	bfextu	r9,r3,0x0,0x14
8000a944:	50 09       	stdsp	sp[0x0],r9
8000a946:	f1 d3 c0 1f 	bfextu	r8,r3,0x0,0x1f
8000a94a:	b5 a9       	sbr	r9,0x14
8000a94c:	f0 01 16 14 	lsr	r1,r8,0x14
8000a950:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000a954:	18 94       	mov	r4,r12
8000a956:	58 02       	cp.w	r2,0
8000a958:	c1 d0       	breq	8000a992 <__d2b+0x62>
8000a95a:	fa cc ff f8 	sub	r12,sp,-8
8000a95e:	18 d2       	st.w	--r12,r2
8000a960:	c3 6f       	rcall	8000a7cc <__lo0bits>
8000a962:	40 18       	lddsp	r8,sp[0x4]
8000a964:	c0 d0       	breq	8000a97e <__d2b+0x4e>
8000a966:	40 09       	lddsp	r9,sp[0x0]
8000a968:	f8 0a 11 20 	rsub	r10,r12,32
8000a96c:	f2 0a 09 4a 	lsl	r10,r9,r10
8000a970:	f5 e8 10 08 	or	r8,r10,r8
8000a974:	89 58       	st.w	r4[0x14],r8
8000a976:	f2 0c 0a 49 	lsr	r9,r9,r12
8000a97a:	50 09       	stdsp	sp[0x0],r9
8000a97c:	c0 28       	rjmp	8000a980 <__d2b+0x50>
8000a97e:	89 58       	st.w	r4[0x14],r8
8000a980:	40 08       	lddsp	r8,sp[0x0]
8000a982:	58 08       	cp.w	r8,0
8000a984:	f9 b3 01 02 	movne	r3,2
8000a988:	f9 b3 00 01 	moveq	r3,1
8000a98c:	89 68       	st.w	r4[0x18],r8
8000a98e:	89 43       	st.w	r4[0x10],r3
8000a990:	c0 88       	rjmp	8000a9a0 <__d2b+0x70>
8000a992:	1a 9c       	mov	r12,sp
8000a994:	c1 cf       	rcall	8000a7cc <__lo0bits>
8000a996:	30 13       	mov	r3,1
8000a998:	40 08       	lddsp	r8,sp[0x0]
8000a99a:	2e 0c       	sub	r12,-32
8000a99c:	89 43       	st.w	r4[0x10],r3
8000a99e:	89 58       	st.w	r4[0x14],r8
8000a9a0:	58 01       	cp.w	r1,0
8000a9a2:	c0 90       	breq	8000a9b4 <__d2b+0x84>
8000a9a4:	e2 c1 04 33 	sub	r1,r1,1075
8000a9a8:	18 01       	add	r1,r12
8000a9aa:	8d 01       	st.w	r6[0x0],r1
8000a9ac:	f8 0c 11 35 	rsub	r12,r12,53
8000a9b0:	8b 0c       	st.w	r5[0x0],r12
8000a9b2:	c0 c8       	rjmp	8000a9ca <__d2b+0x9a>
8000a9b4:	e6 c8 ff fc 	sub	r8,r3,-4
8000a9b8:	f8 cc 04 32 	sub	r12,r12,1074
8000a9bc:	a5 73       	lsl	r3,0x5
8000a9be:	8d 0c       	st.w	r6[0x0],r12
8000a9c0:	e8 08 03 2c 	ld.w	r12,r4[r8<<0x2]
8000a9c4:	cd 4e       	rcall	8000a76c <__hi0bits>
8000a9c6:	18 13       	sub	r3,r12
8000a9c8:	8b 03       	st.w	r5[0x0],r3
8000a9ca:	08 9c       	mov	r12,r4
8000a9cc:	2f ed       	sub	sp,-8
8000a9ce:	d8 32       	popm	r0-r7,pc

8000a9d0 <__mdiff>:
8000a9d0:	d4 31       	pushm	r0-r7,lr
8000a9d2:	74 48       	ld.w	r8,r10[0x10]
8000a9d4:	76 45       	ld.w	r5,r11[0x10]
8000a9d6:	16 97       	mov	r7,r11
8000a9d8:	14 96       	mov	r6,r10
8000a9da:	10 15       	sub	r5,r8
8000a9dc:	c1 31       	brne	8000aa02 <__mdiff+0x32>
8000a9de:	2f b8       	sub	r8,-5
8000a9e0:	ee ce ff ec 	sub	lr,r7,-20
8000a9e4:	a3 68       	lsl	r8,0x2
8000a9e6:	f4 08 00 0b 	add	r11,r10,r8
8000a9ea:	ee 08 00 08 	add	r8,r7,r8
8000a9ee:	11 4a       	ld.w	r10,--r8
8000a9f0:	17 49       	ld.w	r9,--r11
8000a9f2:	12 3a       	cp.w	r10,r9
8000a9f4:	c0 30       	breq	8000a9fa <__mdiff+0x2a>
8000a9f6:	c0 e2       	brcc	8000aa12 <__mdiff+0x42>
8000a9f8:	c0 78       	rjmp	8000aa06 <__mdiff+0x36>
8000a9fa:	1c 38       	cp.w	r8,lr
8000a9fc:	fe 9b ff f9 	brhi	8000a9ee <__mdiff+0x1e>
8000aa00:	c4 98       	rjmp	8000aa92 <__mdiff+0xc2>
8000aa02:	58 05       	cp.w	r5,0
8000aa04:	c0 64       	brge	8000aa10 <__mdiff+0x40>
8000aa06:	0e 98       	mov	r8,r7
8000aa08:	30 15       	mov	r5,1
8000aa0a:	0c 97       	mov	r7,r6
8000aa0c:	10 96       	mov	r6,r8
8000aa0e:	c0 28       	rjmp	8000aa12 <__mdiff+0x42>
8000aa10:	30 05       	mov	r5,0
8000aa12:	6e 1b       	ld.w	r11,r7[0x4]
8000aa14:	c5 6f       	rcall	8000a8c0 <_Balloc>
8000aa16:	6e 49       	ld.w	r9,r7[0x10]
8000aa18:	6c 44       	ld.w	r4,r6[0x10]
8000aa1a:	99 35       	st.w	r12[0xc],r5
8000aa1c:	2f b4       	sub	r4,-5
8000aa1e:	f2 c5 ff fb 	sub	r5,r9,-5
8000aa22:	ec 04 00 24 	add	r4,r6,r4<<0x2
8000aa26:	ee 05 00 25 	add	r5,r7,r5<<0x2
8000aa2a:	2e c6       	sub	r6,-20
8000aa2c:	2e c7       	sub	r7,-20
8000aa2e:	f8 c8 ff ec 	sub	r8,r12,-20
8000aa32:	30 0a       	mov	r10,0
8000aa34:	0f 0e       	ld.w	lr,r7++
8000aa36:	0d 0b       	ld.w	r11,r6++
8000aa38:	fc 02 16 10 	lsr	r2,lr,0x10
8000aa3c:	f6 03 16 10 	lsr	r3,r11,0x10
8000aa40:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000aa44:	e4 03 01 03 	sub	r3,r2,r3
8000aa48:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000aa4c:	fc 0b 01 0b 	sub	r11,lr,r11
8000aa50:	f6 0a 00 0a 	add	r10,r11,r10
8000aa54:	b0 1a       	st.h	r8[0x2],r10
8000aa56:	b1 4a       	asr	r10,0x10
8000aa58:	e6 0a 00 0a 	add	r10,r3,r10
8000aa5c:	b0 0a       	st.h	r8[0x0],r10
8000aa5e:	2f c8       	sub	r8,-4
8000aa60:	b1 4a       	asr	r10,0x10
8000aa62:	08 36       	cp.w	r6,r4
8000aa64:	ce 83       	brcs	8000aa34 <__mdiff+0x64>
8000aa66:	c0 d8       	rjmp	8000aa80 <__mdiff+0xb0>
8000aa68:	0f 0b       	ld.w	r11,r7++
8000aa6a:	f6 0e 16 10 	lsr	lr,r11,0x10
8000aa6e:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000aa72:	16 0a       	add	r10,r11
8000aa74:	b0 1a       	st.h	r8[0x2],r10
8000aa76:	b1 4a       	asr	r10,0x10
8000aa78:	1c 0a       	add	r10,lr
8000aa7a:	b0 0a       	st.h	r8[0x0],r10
8000aa7c:	2f c8       	sub	r8,-4
8000aa7e:	b1 4a       	asr	r10,0x10
8000aa80:	0a 37       	cp.w	r7,r5
8000aa82:	cf 33       	brcs	8000aa68 <__mdiff+0x98>
8000aa84:	c0 28       	rjmp	8000aa88 <__mdiff+0xb8>
8000aa86:	20 19       	sub	r9,1
8000aa88:	11 4a       	ld.w	r10,--r8
8000aa8a:	58 0a       	cp.w	r10,0
8000aa8c:	cf d0       	breq	8000aa86 <__mdiff+0xb6>
8000aa8e:	99 49       	st.w	r12[0x10],r9
8000aa90:	d8 32       	popm	r0-r7,pc
8000aa92:	30 0b       	mov	r11,0
8000aa94:	c1 6f       	rcall	8000a8c0 <_Balloc>
8000aa96:	30 18       	mov	r8,1
8000aa98:	99 48       	st.w	r12[0x10],r8
8000aa9a:	30 08       	mov	r8,0
8000aa9c:	99 58       	st.w	r12[0x14],r8
8000aa9e:	d8 32       	popm	r0-r7,pc

8000aaa0 <__lshift>:
8000aaa0:	d4 31       	pushm	r0-r7,lr
8000aaa2:	16 97       	mov	r7,r11
8000aaa4:	76 46       	ld.w	r6,r11[0x10]
8000aaa6:	f4 02 14 05 	asr	r2,r10,0x5
8000aaaa:	2f f6       	sub	r6,-1
8000aaac:	14 93       	mov	r3,r10
8000aaae:	18 94       	mov	r4,r12
8000aab0:	04 06       	add	r6,r2
8000aab2:	76 1b       	ld.w	r11,r11[0x4]
8000aab4:	6e 28       	ld.w	r8,r7[0x8]
8000aab6:	c0 38       	rjmp	8000aabc <__lshift+0x1c>
8000aab8:	2f fb       	sub	r11,-1
8000aaba:	a1 78       	lsl	r8,0x1
8000aabc:	10 36       	cp.w	r6,r8
8000aabe:	fe 99 ff fd 	brgt	8000aab8 <__lshift+0x18>
8000aac2:	08 9c       	mov	r12,r4
8000aac4:	cf ee       	rcall	8000a8c0 <_Balloc>
8000aac6:	30 09       	mov	r9,0
8000aac8:	18 95       	mov	r5,r12
8000aaca:	f8 c8 ff ec 	sub	r8,r12,-20
8000aace:	12 9a       	mov	r10,r9
8000aad0:	c0 38       	rjmp	8000aad6 <__lshift+0x36>
8000aad2:	10 aa       	st.w	r8++,r10
8000aad4:	2f f9       	sub	r9,-1
8000aad6:	04 39       	cp.w	r9,r2
8000aad8:	cf d5       	brlt	8000aad2 <__lshift+0x32>
8000aada:	6e 4b       	ld.w	r11,r7[0x10]
8000aadc:	e7 d3 c0 05 	bfextu	r3,r3,0x0,0x5
8000aae0:	2f bb       	sub	r11,-5
8000aae2:	ee c9 ff ec 	sub	r9,r7,-20
8000aae6:	ee 0b 00 2b 	add	r11,r7,r11<<0x2
8000aaea:	58 03       	cp.w	r3,0
8000aaec:	c1 30       	breq	8000ab12 <__lshift+0x72>
8000aaee:	e6 0c 11 20 	rsub	r12,r3,32
8000aaf2:	30 0a       	mov	r10,0
8000aaf4:	72 02       	ld.w	r2,r9[0x0]
8000aaf6:	e4 03 09 42 	lsl	r2,r2,r3
8000aafa:	04 4a       	or	r10,r2
8000aafc:	10 aa       	st.w	r8++,r10
8000aafe:	13 0a       	ld.w	r10,r9++
8000ab00:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000ab04:	16 39       	cp.w	r9,r11
8000ab06:	cf 73       	brcs	8000aaf4 <__lshift+0x54>
8000ab08:	91 0a       	st.w	r8[0x0],r10
8000ab0a:	58 0a       	cp.w	r10,0
8000ab0c:	c0 70       	breq	8000ab1a <__lshift+0x7a>
8000ab0e:	2f f6       	sub	r6,-1
8000ab10:	c0 58       	rjmp	8000ab1a <__lshift+0x7a>
8000ab12:	13 0a       	ld.w	r10,r9++
8000ab14:	10 aa       	st.w	r8++,r10
8000ab16:	16 39       	cp.w	r9,r11
8000ab18:	cf d3       	brcs	8000ab12 <__lshift+0x72>
8000ab1a:	08 9c       	mov	r12,r4
8000ab1c:	20 16       	sub	r6,1
8000ab1e:	0e 9b       	mov	r11,r7
8000ab20:	8b 46       	st.w	r5[0x10],r6
8000ab22:	cb 5e       	rcall	8000a88c <_Bfree>
8000ab24:	0a 9c       	mov	r12,r5
8000ab26:	d8 32       	popm	r0-r7,pc

8000ab28 <__multiply>:
8000ab28:	d4 31       	pushm	r0-r7,lr
8000ab2a:	20 2d       	sub	sp,8
8000ab2c:	76 49       	ld.w	r9,r11[0x10]
8000ab2e:	74 48       	ld.w	r8,r10[0x10]
8000ab30:	16 96       	mov	r6,r11
8000ab32:	14 95       	mov	r5,r10
8000ab34:	10 39       	cp.w	r9,r8
8000ab36:	ec 08 17 50 	movlt	r8,r6
8000ab3a:	ea 06 17 50 	movlt	r6,r5
8000ab3e:	f0 05 17 50 	movlt	r5,r8
8000ab42:	6c 28       	ld.w	r8,r6[0x8]
8000ab44:	76 43       	ld.w	r3,r11[0x10]
8000ab46:	74 42       	ld.w	r2,r10[0x10]
8000ab48:	76 1b       	ld.w	r11,r11[0x4]
8000ab4a:	e4 03 00 07 	add	r7,r2,r3
8000ab4e:	10 37       	cp.w	r7,r8
8000ab50:	f7 bb 09 ff 	subgt	r11,-1
8000ab54:	cb 6e       	rcall	8000a8c0 <_Balloc>
8000ab56:	ee c4 ff fb 	sub	r4,r7,-5
8000ab5a:	f8 c9 ff ec 	sub	r9,r12,-20
8000ab5e:	f8 04 00 24 	add	r4,r12,r4<<0x2
8000ab62:	30 0a       	mov	r10,0
8000ab64:	12 98       	mov	r8,r9
8000ab66:	c0 28       	rjmp	8000ab6a <__multiply+0x42>
8000ab68:	10 aa       	st.w	r8++,r10
8000ab6a:	08 38       	cp.w	r8,r4
8000ab6c:	cf e3       	brcs	8000ab68 <__multiply+0x40>
8000ab6e:	2f b3       	sub	r3,-5
8000ab70:	2f b2       	sub	r2,-5
8000ab72:	ec 03 00 23 	add	r3,r6,r3<<0x2
8000ab76:	ea 02 00 22 	add	r2,r5,r2<<0x2
8000ab7a:	ec cb ff ec 	sub	r11,r6,-20
8000ab7e:	50 12       	stdsp	sp[0x4],r2
8000ab80:	ea ca ff ec 	sub	r10,r5,-20
8000ab84:	c4 48       	rjmp	8000ac0c <__multiply+0xe4>
8000ab86:	94 95       	ld.uh	r5,r10[0x2]
8000ab88:	58 05       	cp.w	r5,0
8000ab8a:	c2 00       	breq	8000abca <__multiply+0xa2>
8000ab8c:	12 98       	mov	r8,r9
8000ab8e:	16 96       	mov	r6,r11
8000ab90:	30 0e       	mov	lr,0
8000ab92:	50 09       	stdsp	sp[0x0],r9
8000ab94:	0d 02       	ld.w	r2,r6++
8000ab96:	e4 00 16 10 	lsr	r0,r2,0x10
8000ab9a:	70 01       	ld.w	r1,r8[0x0]
8000ab9c:	70 09       	ld.w	r9,r8[0x0]
8000ab9e:	b1 81       	lsr	r1,0x10
8000aba0:	e5 d2 c0 10 	bfextu	r2,r2,0x0,0x10
8000aba4:	e0 05 03 41 	mac	r1,r0,r5
8000aba8:	ab 32       	mul	r2,r5
8000abaa:	e1 d9 c0 10 	bfextu	r0,r9,0x0,0x10
8000abae:	00 02       	add	r2,r0
8000abb0:	e4 0e 00 0e 	add	lr,r2,lr
8000abb4:	b0 1e       	st.h	r8[0x2],lr
8000abb6:	b1 8e       	lsr	lr,0x10
8000abb8:	1c 01       	add	r1,lr
8000abba:	b0 01       	st.h	r8[0x0],r1
8000abbc:	e2 0e 16 10 	lsr	lr,r1,0x10
8000abc0:	2f c8       	sub	r8,-4
8000abc2:	06 36       	cp.w	r6,r3
8000abc4:	ce 83       	brcs	8000ab94 <__multiply+0x6c>
8000abc6:	40 09       	lddsp	r9,sp[0x0]
8000abc8:	91 0e       	st.w	r8[0x0],lr
8000abca:	94 86       	ld.uh	r6,r10[0x0]
8000abcc:	58 06       	cp.w	r6,0
8000abce:	c1 d0       	breq	8000ac08 <__multiply+0xe0>
8000abd0:	72 02       	ld.w	r2,r9[0x0]
8000abd2:	12 98       	mov	r8,r9
8000abd4:	16 9e       	mov	lr,r11
8000abd6:	30 05       	mov	r5,0
8000abd8:	b0 12       	st.h	r8[0x2],r2
8000abda:	1d 01       	ld.w	r1,lr++
8000abdc:	90 82       	ld.uh	r2,r8[0x0]
8000abde:	e1 d1 c0 10 	bfextu	r0,r1,0x0,0x10
8000abe2:	ad 30       	mul	r0,r6
8000abe4:	e0 02 00 02 	add	r2,r0,r2
8000abe8:	e4 05 00 05 	add	r5,r2,r5
8000abec:	b0 05       	st.h	r8[0x0],r5
8000abee:	b1 85       	lsr	r5,0x10
8000abf0:	b1 81       	lsr	r1,0x10
8000abf2:	2f c8       	sub	r8,-4
8000abf4:	ad 31       	mul	r1,r6
8000abf6:	90 92       	ld.uh	r2,r8[0x2]
8000abf8:	e2 02 00 02 	add	r2,r1,r2
8000abfc:	0a 02       	add	r2,r5
8000abfe:	e4 05 16 10 	lsr	r5,r2,0x10
8000ac02:	06 3e       	cp.w	lr,r3
8000ac04:	ce a3       	brcs	8000abd8 <__multiply+0xb0>
8000ac06:	91 02       	st.w	r8[0x0],r2
8000ac08:	2f ca       	sub	r10,-4
8000ac0a:	2f c9       	sub	r9,-4
8000ac0c:	40 18       	lddsp	r8,sp[0x4]
8000ac0e:	10 3a       	cp.w	r10,r8
8000ac10:	cb b3       	brcs	8000ab86 <__multiply+0x5e>
8000ac12:	c0 28       	rjmp	8000ac16 <__multiply+0xee>
8000ac14:	20 17       	sub	r7,1
8000ac16:	58 07       	cp.w	r7,0
8000ac18:	e0 8a 00 05 	brle	8000ac22 <__multiply+0xfa>
8000ac1c:	09 48       	ld.w	r8,--r4
8000ac1e:	58 08       	cp.w	r8,0
8000ac20:	cf a0       	breq	8000ac14 <__multiply+0xec>
8000ac22:	99 47       	st.w	r12[0x10],r7
8000ac24:	2f ed       	sub	sp,-8
8000ac26:	d8 32       	popm	r0-r7,pc

8000ac28 <__i2b>:
8000ac28:	d4 21       	pushm	r4-r7,lr
8000ac2a:	16 97       	mov	r7,r11
8000ac2c:	30 1b       	mov	r11,1
8000ac2e:	c4 9e       	rcall	8000a8c0 <_Balloc>
8000ac30:	30 19       	mov	r9,1
8000ac32:	99 57       	st.w	r12[0x14],r7
8000ac34:	99 49       	st.w	r12[0x10],r9
8000ac36:	d8 22       	popm	r4-r7,pc

8000ac38 <__multadd>:
8000ac38:	d4 31       	pushm	r0-r7,lr
8000ac3a:	30 08       	mov	r8,0
8000ac3c:	12 95       	mov	r5,r9
8000ac3e:	16 97       	mov	r7,r11
8000ac40:	18 96       	mov	r6,r12
8000ac42:	76 44       	ld.w	r4,r11[0x10]
8000ac44:	f6 c9 ff ec 	sub	r9,r11,-20
8000ac48:	72 0b       	ld.w	r11,r9[0x0]
8000ac4a:	f6 0c 16 10 	lsr	r12,r11,0x10
8000ac4e:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000ac52:	f4 0c 02 4c 	mul	r12,r10,r12
8000ac56:	f4 0b 03 45 	mac	r5,r10,r11
8000ac5a:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
8000ac5e:	b1 85       	lsr	r5,0x10
8000ac60:	18 05       	add	r5,r12
8000ac62:	ea 0c 15 10 	lsl	r12,r5,0x10
8000ac66:	f8 0b 00 0b 	add	r11,r12,r11
8000ac6a:	12 ab       	st.w	r9++,r11
8000ac6c:	2f f8       	sub	r8,-1
8000ac6e:	b1 85       	lsr	r5,0x10
8000ac70:	08 38       	cp.w	r8,r4
8000ac72:	ce b5       	brlt	8000ac48 <__multadd+0x10>
8000ac74:	58 05       	cp.w	r5,0
8000ac76:	c1 c0       	breq	8000acae <__multadd+0x76>
8000ac78:	6e 28       	ld.w	r8,r7[0x8]
8000ac7a:	10 34       	cp.w	r4,r8
8000ac7c:	c1 35       	brlt	8000aca2 <__multadd+0x6a>
8000ac7e:	6e 1b       	ld.w	r11,r7[0x4]
8000ac80:	0c 9c       	mov	r12,r6
8000ac82:	2f fb       	sub	r11,-1
8000ac84:	c1 ee       	rcall	8000a8c0 <_Balloc>
8000ac86:	6e 4a       	ld.w	r10,r7[0x10]
8000ac88:	ee cb ff f4 	sub	r11,r7,-12
8000ac8c:	18 93       	mov	r3,r12
8000ac8e:	2f ea       	sub	r10,-2
8000ac90:	2f 4c       	sub	r12,-12
8000ac92:	a3 6a       	lsl	r10,0x2
8000ac94:	fe b0 de 64 	rcall	8000695c <memcpy>
8000ac98:	0e 9b       	mov	r11,r7
8000ac9a:	0c 9c       	mov	r12,r6
8000ac9c:	fe b0 fd f8 	rcall	8000a88c <_Bfree>
8000aca0:	06 97       	mov	r7,r3
8000aca2:	e8 c8 ff ff 	sub	r8,r4,-1
8000aca6:	2f b4       	sub	r4,-5
8000aca8:	8f 48       	st.w	r7[0x10],r8
8000acaa:	ee 04 09 25 	st.w	r7[r4<<0x2],r5
8000acae:	0e 9c       	mov	r12,r7
8000acb0:	d8 32       	popm	r0-r7,pc
8000acb2:	d7 03       	nop

8000acb4 <__pow5mult>:
8000acb4:	d4 31       	pushm	r0-r7,lr
8000acb6:	14 96       	mov	r6,r10
8000acb8:	18 97       	mov	r7,r12
8000acba:	16 94       	mov	r4,r11
8000acbc:	f1 da c0 02 	bfextu	r8,r10,0x0,0x2
8000acc0:	c0 90       	breq	8000acd2 <__pow5mult+0x1e>
8000acc2:	20 18       	sub	r8,1
8000acc4:	fe c9 dc ac 	sub	r9,pc,-9044
8000acc8:	f2 08 03 2a 	ld.w	r10,r9[r8<<0x2]
8000accc:	30 09       	mov	r9,0
8000acce:	cb 5f       	rcall	8000ac38 <__multadd>
8000acd0:	18 94       	mov	r4,r12
8000acd2:	a3 46       	asr	r6,0x2
8000acd4:	c3 40       	breq	8000ad3c <__pow5mult+0x88>
8000acd6:	6e 95       	ld.w	r5,r7[0x24]
8000acd8:	58 05       	cp.w	r5,0
8000acda:	c0 91       	brne	8000acec <__pow5mult+0x38>
8000acdc:	31 0c       	mov	r12,16
8000acde:	fe b0 dc 1b 	rcall	80006514 <malloc>
8000ace2:	99 35       	st.w	r12[0xc],r5
8000ace4:	8f 9c       	st.w	r7[0x24],r12
8000ace6:	99 15       	st.w	r12[0x4],r5
8000ace8:	99 25       	st.w	r12[0x8],r5
8000acea:	99 05       	st.w	r12[0x0],r5
8000acec:	6e 93       	ld.w	r3,r7[0x24]
8000acee:	66 25       	ld.w	r5,r3[0x8]
8000acf0:	58 05       	cp.w	r5,0
8000acf2:	c0 c1       	brne	8000ad0a <__pow5mult+0x56>
8000acf4:	e0 6b 02 71 	mov	r11,625
8000acf8:	0e 9c       	mov	r12,r7
8000acfa:	c9 7f       	rcall	8000ac28 <__i2b>
8000acfc:	87 2c       	st.w	r3[0x8],r12
8000acfe:	30 08       	mov	r8,0
8000ad00:	18 95       	mov	r5,r12
8000ad02:	99 08       	st.w	r12[0x0],r8
8000ad04:	c0 38       	rjmp	8000ad0a <__pow5mult+0x56>
8000ad06:	06 9c       	mov	r12,r3
8000ad08:	18 95       	mov	r5,r12
8000ad0a:	ed b6 00 00 	bld	r6,0x0
8000ad0e:	c0 b1       	brne	8000ad24 <__pow5mult+0x70>
8000ad10:	08 9b       	mov	r11,r4
8000ad12:	0a 9a       	mov	r10,r5
8000ad14:	0e 9c       	mov	r12,r7
8000ad16:	c0 9f       	rcall	8000ab28 <__multiply>
8000ad18:	08 9b       	mov	r11,r4
8000ad1a:	18 93       	mov	r3,r12
8000ad1c:	0e 9c       	mov	r12,r7
8000ad1e:	06 94       	mov	r4,r3
8000ad20:	fe b0 fd b6 	rcall	8000a88c <_Bfree>
8000ad24:	a1 56       	asr	r6,0x1
8000ad26:	c0 b0       	breq	8000ad3c <__pow5mult+0x88>
8000ad28:	6a 03       	ld.w	r3,r5[0x0]
8000ad2a:	58 03       	cp.w	r3,0
8000ad2c:	ce d1       	brne	8000ad06 <__pow5mult+0x52>
8000ad2e:	0a 9a       	mov	r10,r5
8000ad30:	0a 9b       	mov	r11,r5
8000ad32:	0e 9c       	mov	r12,r7
8000ad34:	cf ae       	rcall	8000ab28 <__multiply>
8000ad36:	8b 0c       	st.w	r5[0x0],r12
8000ad38:	99 03       	st.w	r12[0x0],r3
8000ad3a:	ce 7b       	rjmp	8000ad08 <__pow5mult+0x54>
8000ad3c:	08 9c       	mov	r12,r4
8000ad3e:	d8 32       	popm	r0-r7,pc

8000ad40 <__isinfd>:
8000ad40:	14 98       	mov	r8,r10
8000ad42:	fc 19 7f f0 	movh	r9,0x7ff0
8000ad46:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000ad4a:	f0 0b 11 00 	rsub	r11,r8,0
8000ad4e:	f7 e8 10 08 	or	r8,r11,r8
8000ad52:	f5 e8 13 f8 	or	r8,r10,r8>>0x1f
8000ad56:	f2 08 01 08 	sub	r8,r9,r8
8000ad5a:	f0 0c 11 00 	rsub	r12,r8,0
8000ad5e:	f9 e8 10 08 	or	r8,r12,r8
8000ad62:	f0 0c 14 1f 	asr	r12,r8,0x1f
8000ad66:	2f fc       	sub	r12,-1
8000ad68:	5e fc       	retal	r12

8000ad6a <__isnand>:
8000ad6a:	14 98       	mov	r8,r10
8000ad6c:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000ad70:	f0 0c 11 00 	rsub	r12,r8,0
8000ad74:	10 4c       	or	r12,r8
8000ad76:	fc 18 7f f0 	movh	r8,0x7ff0
8000ad7a:	f5 ec 13 fc 	or	r12,r10,r12>>0x1f
8000ad7e:	f0 0c 01 0c 	sub	r12,r8,r12
8000ad82:	bf 9c       	lsr	r12,0x1f
8000ad84:	5e fc       	retal	r12
8000ad86:	d7 03       	nop

8000ad88 <__sclose>:
8000ad88:	d4 01       	pushm	lr
8000ad8a:	96 7b       	ld.sh	r11,r11[0xe]
8000ad8c:	c7 6c       	rcall	8000ae78 <_close_r>
8000ad8e:	d8 02       	popm	pc

8000ad90 <__sseek>:
8000ad90:	d4 21       	pushm	r4-r7,lr
8000ad92:	16 97       	mov	r7,r11
8000ad94:	96 7b       	ld.sh	r11,r11[0xe]
8000ad96:	cf 7c       	rcall	8000af84 <_lseek_r>
8000ad98:	8e 68       	ld.sh	r8,r7[0xc]
8000ad9a:	10 99       	mov	r9,r8
8000ad9c:	ad c8       	cbr	r8,0xc
8000ad9e:	ad a9       	sbr	r9,0xc
8000ada0:	5b fc       	cp.w	r12,-1
8000ada2:	ef f8 0c 06 	st.heq	r7[0xc],r8
8000ada6:	ef f9 1c 06 	st.hne	r7[0xc],r9
8000adaa:	ef fc 1a 15 	st.wne	r7[0x54],r12
8000adae:	d8 22       	popm	r4-r7,pc

8000adb0 <__swrite>:
8000adb0:	d4 21       	pushm	r4-r7,lr
8000adb2:	96 68       	ld.sh	r8,r11[0xc]
8000adb4:	16 97       	mov	r7,r11
8000adb6:	14 95       	mov	r5,r10
8000adb8:	12 94       	mov	r4,r9
8000adba:	e2 18 01 00 	andl	r8,0x100,COH
8000adbe:	18 96       	mov	r6,r12
8000adc0:	c0 50       	breq	8000adca <__swrite+0x1a>
8000adc2:	30 29       	mov	r9,2
8000adc4:	30 0a       	mov	r10,0
8000adc6:	96 7b       	ld.sh	r11,r11[0xe]
8000adc8:	cd ec       	rcall	8000af84 <_lseek_r>
8000adca:	8e 68       	ld.sh	r8,r7[0xc]
8000adcc:	ad c8       	cbr	r8,0xc
8000adce:	08 99       	mov	r9,r4
8000add0:	0a 9a       	mov	r10,r5
8000add2:	8e 7b       	ld.sh	r11,r7[0xe]
8000add4:	0c 9c       	mov	r12,r6
8000add6:	ae 68       	st.h	r7[0xc],r8
8000add8:	c1 0c       	rcall	8000adf8 <_write_r>
8000adda:	d8 22       	popm	r4-r7,pc

8000addc <__sread>:
8000addc:	d4 21       	pushm	r4-r7,lr
8000adde:	16 97       	mov	r7,r11
8000ade0:	96 7b       	ld.sh	r11,r11[0xe]
8000ade2:	ce 5c       	rcall	8000afac <_read_r>
8000ade4:	c0 65       	brlt	8000adf0 <__sread+0x14>
8000ade6:	6f 58       	ld.w	r8,r7[0x54]
8000ade8:	18 08       	add	r8,r12
8000adea:	ef 48 00 54 	st.w	r7[84],r8
8000adee:	d8 22       	popm	r4-r7,pc
8000adf0:	8e 68       	ld.sh	r8,r7[0xc]
8000adf2:	ad c8       	cbr	r8,0xc
8000adf4:	ae 68       	st.h	r7[0xc],r8
8000adf6:	d8 22       	popm	r4-r7,pc

8000adf8 <_write_r>:
8000adf8:	d4 21       	pushm	r4-r7,lr
8000adfa:	16 98       	mov	r8,r11
8000adfc:	18 97       	mov	r7,r12
8000adfe:	10 9c       	mov	r12,r8
8000ae00:	30 08       	mov	r8,0
8000ae02:	14 9b       	mov	r11,r10
8000ae04:	e0 66 40 f0 	mov	r6,16624
8000ae08:	12 9a       	mov	r10,r9
8000ae0a:	8d 08       	st.w	r6[0x0],r8
8000ae0c:	fe b0 d1 54 	rcall	800050b4 <_write>
8000ae10:	5b fc       	cp.w	r12,-1
8000ae12:	c0 51       	brne	8000ae1c <_write_r+0x24>
8000ae14:	6c 08       	ld.w	r8,r6[0x0]
8000ae16:	58 08       	cp.w	r8,0
8000ae18:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000ae1c:	d8 22       	popm	r4-r7,pc
8000ae1e:	d7 03       	nop

8000ae20 <_calloc_r>:
8000ae20:	d4 21       	pushm	r4-r7,lr
8000ae22:	f4 0b 02 4b 	mul	r11,r10,r11
8000ae26:	fe b0 db 7f 	rcall	80006524 <_malloc_r>
8000ae2a:	18 97       	mov	r7,r12
8000ae2c:	c2 30       	breq	8000ae72 <_calloc_r+0x52>
8000ae2e:	f8 fa ff fc 	ld.w	r10,r12[-4]
8000ae32:	e0 1a ff fc 	andl	r10,0xfffc
8000ae36:	20 4a       	sub	r10,4
8000ae38:	e0 4a 00 24 	cp.w	r10,36
8000ae3c:	e0 8b 00 18 	brhi	8000ae6c <_calloc_r+0x4c>
8000ae40:	18 98       	mov	r8,r12
8000ae42:	59 3a       	cp.w	r10,19
8000ae44:	e0 88 00 0f 	brls	8000ae62 <_calloc_r+0x42>
8000ae48:	30 09       	mov	r9,0
8000ae4a:	10 a9       	st.w	r8++,r9
8000ae4c:	10 a9       	st.w	r8++,r9
8000ae4e:	59 ba       	cp.w	r10,27
8000ae50:	e0 88 00 09 	brls	8000ae62 <_calloc_r+0x42>
8000ae54:	10 a9       	st.w	r8++,r9
8000ae56:	10 a9       	st.w	r8++,r9
8000ae58:	e0 4a 00 24 	cp.w	r10,36
8000ae5c:	c0 31       	brne	8000ae62 <_calloc_r+0x42>
8000ae5e:	10 a9       	st.w	r8++,r9
8000ae60:	10 a9       	st.w	r8++,r9
8000ae62:	30 09       	mov	r9,0
8000ae64:	10 a9       	st.w	r8++,r9
8000ae66:	91 19       	st.w	r8[0x4],r9
8000ae68:	91 09       	st.w	r8[0x0],r9
8000ae6a:	c0 48       	rjmp	8000ae72 <_calloc_r+0x52>
8000ae6c:	30 0b       	mov	r11,0
8000ae6e:	fe b0 de 1b 	rcall	80006aa4 <memset>
8000ae72:	0e 9c       	mov	r12,r7
8000ae74:	d8 22       	popm	r4-r7,pc
8000ae76:	d7 03       	nop

8000ae78 <_close_r>:
8000ae78:	d4 21       	pushm	r4-r7,lr
8000ae7a:	30 08       	mov	r8,0
8000ae7c:	18 97       	mov	r7,r12
8000ae7e:	e0 66 40 f0 	mov	r6,16624
8000ae82:	16 9c       	mov	r12,r11
8000ae84:	8d 08       	st.w	r6[0x0],r8
8000ae86:	fe b0 df c1 	rcall	80006e08 <_close>
8000ae8a:	5b fc       	cp.w	r12,-1
8000ae8c:	c0 51       	brne	8000ae96 <_close_r+0x1e>
8000ae8e:	6c 08       	ld.w	r8,r6[0x0]
8000ae90:	58 08       	cp.w	r8,0
8000ae92:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000ae96:	d8 22       	popm	r4-r7,pc

8000ae98 <_fclose_r>:
8000ae98:	d4 21       	pushm	r4-r7,lr
8000ae9a:	18 96       	mov	r6,r12
8000ae9c:	16 97       	mov	r7,r11
8000ae9e:	58 0b       	cp.w	r11,0
8000aea0:	c0 31       	brne	8000aea6 <_fclose_r+0xe>
8000aea2:	16 95       	mov	r5,r11
8000aea4:	c5 38       	rjmp	8000af4a <_fclose_r+0xb2>
8000aea6:	fe b0 f8 b5 	rcall	8000a010 <__sfp_lock_acquire>
8000aeaa:	58 06       	cp.w	r6,0
8000aeac:	c0 70       	breq	8000aeba <_fclose_r+0x22>
8000aeae:	6c 68       	ld.w	r8,r6[0x18]
8000aeb0:	58 08       	cp.w	r8,0
8000aeb2:	c0 41       	brne	8000aeba <_fclose_r+0x22>
8000aeb4:	0c 9c       	mov	r12,r6
8000aeb6:	fe b0 f8 ff 	rcall	8000a0b4 <__sinit>
8000aeba:	fe c8 df 46 	sub	r8,pc,-8378
8000aebe:	10 37       	cp.w	r7,r8
8000aec0:	c0 31       	brne	8000aec6 <_fclose_r+0x2e>
8000aec2:	6c 07       	ld.w	r7,r6[0x0]
8000aec4:	c0 c8       	rjmp	8000aedc <_fclose_r+0x44>
8000aec6:	fe c8 df 32 	sub	r8,pc,-8398
8000aeca:	10 37       	cp.w	r7,r8
8000aecc:	c0 31       	brne	8000aed2 <_fclose_r+0x3a>
8000aece:	6c 17       	ld.w	r7,r6[0x4]
8000aed0:	c0 68       	rjmp	8000aedc <_fclose_r+0x44>
8000aed2:	fe c8 df 1e 	sub	r8,pc,-8418
8000aed6:	10 37       	cp.w	r7,r8
8000aed8:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000aedc:	8e 69       	ld.sh	r9,r7[0xc]
8000aede:	30 08       	mov	r8,0
8000aee0:	f0 09 19 00 	cp.h	r9,r8
8000aee4:	c0 51       	brne	8000aeee <_fclose_r+0x56>
8000aee6:	fe b0 f8 96 	rcall	8000a012 <__sfp_lock_release>
8000aeea:	30 05       	mov	r5,0
8000aeec:	c2 f8       	rjmp	8000af4a <_fclose_r+0xb2>
8000aeee:	0e 9b       	mov	r11,r7
8000aef0:	0c 9c       	mov	r12,r6
8000aef2:	fe b0 f8 09 	rcall	80009f04 <_fflush_r>
8000aef6:	6e c8       	ld.w	r8,r7[0x30]
8000aef8:	18 95       	mov	r5,r12
8000aefa:	58 08       	cp.w	r8,0
8000aefc:	c0 60       	breq	8000af08 <_fclose_r+0x70>
8000aefe:	6e 8b       	ld.w	r11,r7[0x20]
8000af00:	0c 9c       	mov	r12,r6
8000af02:	5d 18       	icall	r8
8000af04:	f9 b5 05 ff 	movlt	r5,-1
8000af08:	8e 68       	ld.sh	r8,r7[0xc]
8000af0a:	ed b8 00 07 	bld	r8,0x7
8000af0e:	c0 51       	brne	8000af18 <_fclose_r+0x80>
8000af10:	6e 4b       	ld.w	r11,r7[0x10]
8000af12:	0c 9c       	mov	r12,r6
8000af14:	fe b0 f9 6a 	rcall	8000a1e8 <_free_r>
8000af18:	6e db       	ld.w	r11,r7[0x34]
8000af1a:	58 0b       	cp.w	r11,0
8000af1c:	c0 a0       	breq	8000af30 <_fclose_r+0x98>
8000af1e:	ee c8 ff bc 	sub	r8,r7,-68
8000af22:	10 3b       	cp.w	r11,r8
8000af24:	c0 40       	breq	8000af2c <_fclose_r+0x94>
8000af26:	0c 9c       	mov	r12,r6
8000af28:	fe b0 f9 60 	rcall	8000a1e8 <_free_r>
8000af2c:	30 08       	mov	r8,0
8000af2e:	8f d8       	st.w	r7[0x34],r8
8000af30:	6f 2b       	ld.w	r11,r7[0x48]
8000af32:	58 0b       	cp.w	r11,0
8000af34:	c0 70       	breq	8000af42 <_fclose_r+0xaa>
8000af36:	0c 9c       	mov	r12,r6
8000af38:	fe b0 f9 58 	rcall	8000a1e8 <_free_r>
8000af3c:	30 08       	mov	r8,0
8000af3e:	ef 48 00 48 	st.w	r7[72],r8
8000af42:	30 08       	mov	r8,0
8000af44:	ae 68       	st.h	r7[0xc],r8
8000af46:	fe b0 f8 66 	rcall	8000a012 <__sfp_lock_release>
8000af4a:	0a 9c       	mov	r12,r5
8000af4c:	d8 22       	popm	r4-r7,pc
8000af4e:	d7 03       	nop

8000af50 <fclose>:
8000af50:	d4 01       	pushm	lr
8000af52:	e0 68 0a 30 	mov	r8,2608
8000af56:	18 9b       	mov	r11,r12
8000af58:	70 0c       	ld.w	r12,r8[0x0]
8000af5a:	c9 ff       	rcall	8000ae98 <_fclose_r>
8000af5c:	d8 02       	popm	pc
8000af5e:	d7 03       	nop

8000af60 <_fstat_r>:
8000af60:	d4 21       	pushm	r4-r7,lr
8000af62:	16 98       	mov	r8,r11
8000af64:	18 97       	mov	r7,r12
8000af66:	10 9c       	mov	r12,r8
8000af68:	30 08       	mov	r8,0
8000af6a:	e0 66 40 f0 	mov	r6,16624
8000af6e:	14 9b       	mov	r11,r10
8000af70:	8d 08       	st.w	r6[0x0],r8
8000af72:	fe b0 df 73 	rcall	80006e58 <_fstat>
8000af76:	5b fc       	cp.w	r12,-1
8000af78:	c0 51       	brne	8000af82 <_fstat_r+0x22>
8000af7a:	6c 08       	ld.w	r8,r6[0x0]
8000af7c:	58 08       	cp.w	r8,0
8000af7e:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000af82:	d8 22       	popm	r4-r7,pc

8000af84 <_lseek_r>:
8000af84:	d4 21       	pushm	r4-r7,lr
8000af86:	16 98       	mov	r8,r11
8000af88:	18 97       	mov	r7,r12
8000af8a:	10 9c       	mov	r12,r8
8000af8c:	30 08       	mov	r8,0
8000af8e:	14 9b       	mov	r11,r10
8000af90:	e0 66 40 f0 	mov	r6,16624
8000af94:	12 9a       	mov	r10,r9
8000af96:	8d 08       	st.w	r6[0x0],r8
8000af98:	fe b0 df 42 	rcall	80006e1c <_lseek>
8000af9c:	5b fc       	cp.w	r12,-1
8000af9e:	c0 51       	brne	8000afa8 <_lseek_r+0x24>
8000afa0:	6c 08       	ld.w	r8,r6[0x0]
8000afa2:	58 08       	cp.w	r8,0
8000afa4:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000afa8:	d8 22       	popm	r4-r7,pc
8000afaa:	d7 03       	nop

8000afac <_read_r>:
8000afac:	d4 21       	pushm	r4-r7,lr
8000afae:	16 98       	mov	r8,r11
8000afb0:	18 97       	mov	r7,r12
8000afb2:	10 9c       	mov	r12,r8
8000afb4:	30 08       	mov	r8,0
8000afb6:	14 9b       	mov	r11,r10
8000afb8:	e0 66 40 f0 	mov	r6,16624
8000afbc:	12 9a       	mov	r10,r9
8000afbe:	8d 08       	st.w	r6[0x0],r8
8000afc0:	fe b0 d0 5a 	rcall	80005074 <_read>
8000afc4:	5b fc       	cp.w	r12,-1
8000afc6:	c0 51       	brne	8000afd0 <_read_r+0x24>
8000afc8:	6c 08       	ld.w	r8,r6[0x0]
8000afca:	58 08       	cp.w	r8,0
8000afcc:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000afd0:	d8 22       	popm	r4-r7,pc
8000afd2:	d7 03       	nop

8000afd4 <__avr32_f64_mul>:
8000afd4:	f5 eb 10 1c 	or	r12,r10,r11<<0x1
8000afd8:	e0 80 00 dc 	breq	8000b190 <__avr32_f64_mul_op1_zero>
8000afdc:	d4 21       	pushm	r4-r7,lr
8000afde:	f7 e9 20 0e 	eor	lr,r11,r9
8000afe2:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000afe6:	30 15       	mov	r5,1
8000afe8:	c4 30       	breq	8000b06e <__avr32_f64_mul_op1_subnormal>
8000afea:	ab 6b       	lsl	r11,0xa
8000afec:	f7 ea 13 6b 	or	r11,r11,r10>>0x16
8000aff0:	ab 6a       	lsl	r10,0xa
8000aff2:	f7 d5 d3 c2 	bfins	r11,r5,0x1e,0x2
8000aff6:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000affa:	c5 c0       	breq	8000b0b2 <__avr32_f64_mul_op2_subnormal>
8000affc:	a1 78       	lsl	r8,0x1
8000affe:	5c f9       	rol	r9
8000b000:	f3 d5 d2 ab 	bfins	r9,r5,0x15,0xb
8000b004:	e0 47 07 ff 	cp.w	r7,2047
8000b008:	c7 70       	breq	8000b0f6 <__avr32_f64_mul_op_nan_or_inf>
8000b00a:	e0 46 07 ff 	cp.w	r6,2047
8000b00e:	c7 40       	breq	8000b0f6 <__avr32_f64_mul_op_nan_or_inf>
8000b010:	ee 06 00 0c 	add	r12,r7,r6
8000b014:	e0 2c 03 fe 	sub	r12,1022
8000b018:	f6 08 06 44 	mulu.d	r4,r11,r8
8000b01c:	f4 09 07 44 	macu.d	r4,r10,r9
8000b020:	f4 08 06 46 	mulu.d	r6,r10,r8
8000b024:	f6 09 06 4a 	mulu.d	r10,r11,r9
8000b028:	08 07       	add	r7,r4
8000b02a:	f4 05 00 4a 	adc	r10,r10,r5
8000b02e:	5c 0b       	acr	r11
8000b030:	ed bb 00 14 	bld	r11,0x14
8000b034:	c0 50       	breq	8000b03e <__avr32_f64_mul+0x6a>
8000b036:	a1 77       	lsl	r7,0x1
8000b038:	5c fa       	rol	r10
8000b03a:	5c fb       	rol	r11
8000b03c:	20 1c       	sub	r12,1
8000b03e:	58 0c       	cp.w	r12,0
8000b040:	e0 8a 00 6f 	brle	8000b11e <__avr32_f64_mul_res_subnormal>
8000b044:	e0 4c 07 ff 	cp.w	r12,2047
8000b048:	e0 84 00 9c 	brge	8000b180 <__avr32_f64_mul_res_inf>
8000b04c:	f7 dc d2 8b 	bfins	r11,r12,0x14,0xb
8000b050:	ed ea 11 f6 	or	r6,r6,r10<<0x1f
8000b054:	ef e6 12 17 	or	r7,r7,r6>>0x1
8000b058:	ee 17 80 00 	eorh	r7,0x8000
8000b05c:	f1 b7 04 20 	satu	r7,0x1
8000b060:	0e 0a       	add	r10,r7
8000b062:	5c 0b       	acr	r11
8000b064:	ed be 00 1f 	bld	lr,0x1f
8000b068:	ef bb 00 1f 	bst	r11,0x1f
8000b06c:	d8 22       	popm	r4-r7,pc

8000b06e <__avr32_f64_mul_op1_subnormal>:
8000b06e:	e4 1b 00 0f 	andh	r11,0xf
8000b072:	f4 0c 12 00 	clz	r12,r10
8000b076:	f6 06 12 00 	clz	r6,r11
8000b07a:	f7 bc 03 e1 	sublo	r12,-31
8000b07e:	f8 06 17 30 	movlo	r6,r12
8000b082:	f7 b6 02 01 	subhs	r6,1
8000b086:	e0 46 00 20 	cp.w	r6,32
8000b08a:	c0 d4       	brge	8000b0a4 <__avr32_f64_mul_op1_subnormal+0x36>
8000b08c:	ec 0c 11 20 	rsub	r12,r6,32
8000b090:	f6 06 09 4b 	lsl	r11,r11,r6
8000b094:	f4 0c 0a 4c 	lsr	r12,r10,r12
8000b098:	18 4b       	or	r11,r12
8000b09a:	f4 06 09 4a 	lsl	r10,r10,r6
8000b09e:	20 b6       	sub	r6,11
8000b0a0:	0c 17       	sub	r7,r6
8000b0a2:	ca ab       	rjmp	8000aff6 <__avr32_f64_mul+0x22>
8000b0a4:	f4 06 09 4b 	lsl	r11,r10,r6
8000b0a8:	c6 40       	breq	8000b170 <__avr32_f64_mul_res_zero>
8000b0aa:	30 0a       	mov	r10,0
8000b0ac:	20 b6       	sub	r6,11
8000b0ae:	0c 17       	sub	r7,r6
8000b0b0:	ca 3b       	rjmp	8000aff6 <__avr32_f64_mul+0x22>

8000b0b2 <__avr32_f64_mul_op2_subnormal>:
8000b0b2:	e4 19 00 0f 	andh	r9,0xf
8000b0b6:	f0 0c 12 00 	clz	r12,r8
8000b0ba:	f2 05 12 00 	clz	r5,r9
8000b0be:	f7 bc 03 ea 	sublo	r12,-22
8000b0c2:	f8 05 17 30 	movlo	r5,r12
8000b0c6:	f7 b5 02 0a 	subhs	r5,10
8000b0ca:	e0 45 00 20 	cp.w	r5,32
8000b0ce:	c0 d4       	brge	8000b0e8 <__avr32_f64_mul_op2_subnormal+0x36>
8000b0d0:	ea 0c 11 20 	rsub	r12,r5,32
8000b0d4:	f2 05 09 49 	lsl	r9,r9,r5
8000b0d8:	f0 0c 0a 4c 	lsr	r12,r8,r12
8000b0dc:	18 49       	or	r9,r12
8000b0de:	f0 05 09 48 	lsl	r8,r8,r5
8000b0e2:	20 25       	sub	r5,2
8000b0e4:	0a 16       	sub	r6,r5
8000b0e6:	c8 fb       	rjmp	8000b004 <__avr32_f64_mul+0x30>
8000b0e8:	f0 05 09 49 	lsl	r9,r8,r5
8000b0ec:	c4 20       	breq	8000b170 <__avr32_f64_mul_res_zero>
8000b0ee:	30 08       	mov	r8,0
8000b0f0:	20 25       	sub	r5,2
8000b0f2:	0a 16       	sub	r6,r5
8000b0f4:	c8 8b       	rjmp	8000b004 <__avr32_f64_mul+0x30>

8000b0f6 <__avr32_f64_mul_op_nan_or_inf>:
8000b0f6:	e4 19 00 0f 	andh	r9,0xf
8000b0fa:	e4 1b 00 0f 	andh	r11,0xf
8000b0fe:	14 4b       	or	r11,r10
8000b100:	10 49       	or	r9,r8
8000b102:	e0 47 07 ff 	cp.w	r7,2047
8000b106:	c0 91       	brne	8000b118 <__avr32_f64_mul_op1_not_naninf>
8000b108:	58 0b       	cp.w	r11,0
8000b10a:	c3 81       	brne	8000b17a <__avr32_f64_mul_res_nan>
8000b10c:	e0 46 07 ff 	cp.w	r6,2047
8000b110:	c3 81       	brne	8000b180 <__avr32_f64_mul_res_inf>
8000b112:	58 09       	cp.w	r9,0
8000b114:	c3 60       	breq	8000b180 <__avr32_f64_mul_res_inf>
8000b116:	c3 28       	rjmp	8000b17a <__avr32_f64_mul_res_nan>

8000b118 <__avr32_f64_mul_op1_not_naninf>:
8000b118:	58 09       	cp.w	r9,0
8000b11a:	c3 30       	breq	8000b180 <__avr32_f64_mul_res_inf>
8000b11c:	c2 f8       	rjmp	8000b17a <__avr32_f64_mul_res_nan>

8000b11e <__avr32_f64_mul_res_subnormal>:
8000b11e:	5c 3c       	neg	r12
8000b120:	2f fc       	sub	r12,-1
8000b122:	f1 bc 04 c0 	satu	r12,0x6
8000b126:	e0 4c 00 20 	cp.w	r12,32
8000b12a:	c1 14       	brge	8000b14c <__avr32_f64_mul_res_subnormal+0x2e>
8000b12c:	f8 08 11 20 	rsub	r8,r12,32
8000b130:	0e 46       	or	r6,r7
8000b132:	ee 0c 0a 47 	lsr	r7,r7,r12
8000b136:	f4 08 09 49 	lsl	r9,r10,r8
8000b13a:	12 47       	or	r7,r9
8000b13c:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000b140:	f6 08 09 49 	lsl	r9,r11,r8
8000b144:	12 4a       	or	r10,r9
8000b146:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000b14a:	c8 3b       	rjmp	8000b050 <__avr32_f64_mul+0x7c>
8000b14c:	f8 08 11 20 	rsub	r8,r12,32
8000b150:	f9 b9 00 00 	moveq	r9,0
8000b154:	c0 30       	breq	8000b15a <__avr32_f64_mul_res_subnormal+0x3c>
8000b156:	f6 08 09 49 	lsl	r9,r11,r8
8000b15a:	0e 46       	or	r6,r7
8000b15c:	ed ea 10 16 	or	r6,r6,r10<<0x1
8000b160:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000b164:	f3 ea 10 07 	or	r7,r9,r10
8000b168:	f6 0c 0a 4a 	lsr	r10,r11,r12
8000b16c:	30 0b       	mov	r11,0
8000b16e:	c7 1b       	rjmp	8000b050 <__avr32_f64_mul+0x7c>

8000b170 <__avr32_f64_mul_res_zero>:
8000b170:	1c 9b       	mov	r11,lr
8000b172:	e6 1b 80 00 	andh	r11,0x8000,COH
8000b176:	30 0a       	mov	r10,0
8000b178:	d8 22       	popm	r4-r7,pc

8000b17a <__avr32_f64_mul_res_nan>:
8000b17a:	3f fb       	mov	r11,-1
8000b17c:	3f fa       	mov	r10,-1
8000b17e:	d8 22       	popm	r4-r7,pc

8000b180 <__avr32_f64_mul_res_inf>:
8000b180:	f0 6b 00 00 	mov	r11,-1048576
8000b184:	ed be 00 1f 	bld	lr,0x1f
8000b188:	ef bb 00 1f 	bst	r11,0x1f
8000b18c:	30 0a       	mov	r10,0
8000b18e:	d8 22       	popm	r4-r7,pc

8000b190 <__avr32_f64_mul_op1_zero>:
8000b190:	f7 e9 20 0b 	eor	r11,r11,r9
8000b194:	e6 1b 80 00 	andh	r11,0x8000,COH
8000b198:	f9 d9 c2 8b 	bfextu	r12,r9,0x14,0xb
8000b19c:	e0 4c 07 ff 	cp.w	r12,2047
8000b1a0:	5e 1c       	retne	r12
8000b1a2:	3f fa       	mov	r10,-1
8000b1a4:	3f fb       	mov	r11,-1
8000b1a6:	5e fc       	retal	r12

8000b1a8 <__avr32_f64_sub_from_add>:
8000b1a8:	ee 19 80 00 	eorh	r9,0x8000

8000b1ac <__avr32_f64_sub>:
8000b1ac:	f7 e9 20 0c 	eor	r12,r11,r9
8000b1b0:	e0 86 00 ca 	brmi	8000b344 <__avr32_f64_add_from_sub>
8000b1b4:	eb cd 40 e0 	pushm	r5-r7,lr
8000b1b8:	16 9c       	mov	r12,r11
8000b1ba:	e6 1c 80 00 	andh	r12,0x8000,COH
8000b1be:	bf db       	cbr	r11,0x1f
8000b1c0:	bf d9       	cbr	r9,0x1f
8000b1c2:	10 3a       	cp.w	r10,r8
8000b1c4:	f2 0b 13 00 	cpc	r11,r9
8000b1c8:	c0 92       	brcc	8000b1da <__avr32_f64_sub+0x2e>
8000b1ca:	16 97       	mov	r7,r11
8000b1cc:	12 9b       	mov	r11,r9
8000b1ce:	0e 99       	mov	r9,r7
8000b1d0:	14 97       	mov	r7,r10
8000b1d2:	10 9a       	mov	r10,r8
8000b1d4:	0e 98       	mov	r8,r7
8000b1d6:	ee 1c 80 00 	eorh	r12,0x8000
8000b1da:	f6 07 16 14 	lsr	r7,r11,0x14
8000b1de:	ab 7b       	lsl	r11,0xb
8000b1e0:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000b1e4:	ab 7a       	lsl	r10,0xb
8000b1e6:	bf bb       	sbr	r11,0x1f
8000b1e8:	f2 06 16 14 	lsr	r6,r9,0x14
8000b1ec:	c4 40       	breq	8000b274 <__avr32_f64_sub_opL_subnormal>
8000b1ee:	ab 79       	lsl	r9,0xb
8000b1f0:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000b1f4:	ab 78       	lsl	r8,0xb
8000b1f6:	bf b9       	sbr	r9,0x1f

8000b1f8 <__avr32_f64_sub_opL_subnormal_done>:
8000b1f8:	e0 47 07 ff 	cp.w	r7,2047
8000b1fc:	c4 f0       	breq	8000b29a <__avr32_f64_sub_opH_nan_or_inf>
8000b1fe:	0e 26       	rsub	r6,r7
8000b200:	c1 20       	breq	8000b224 <__avr32_f64_sub_shift_done>
8000b202:	ec 05 11 20 	rsub	r5,r6,32
8000b206:	e0 46 00 20 	cp.w	r6,32
8000b20a:	c7 c2       	brcc	8000b302 <__avr32_f64_sub_longshift>
8000b20c:	f0 05 09 4e 	lsl	lr,r8,r5
8000b210:	f2 05 09 45 	lsl	r5,r9,r5
8000b214:	f0 06 0a 48 	lsr	r8,r8,r6
8000b218:	f2 06 0a 49 	lsr	r9,r9,r6
8000b21c:	0a 48       	or	r8,r5
8000b21e:	58 0e       	cp.w	lr,0
8000b220:	5f 1e       	srne	lr
8000b222:	1c 48       	or	r8,lr

8000b224 <__avr32_f64_sub_shift_done>:
8000b224:	10 1a       	sub	r10,r8
8000b226:	f6 09 01 4b 	sbc	r11,r11,r9
8000b22a:	f6 06 12 00 	clz	r6,r11
8000b22e:	c0 e0       	breq	8000b24a <__avr32_f64_sub_longnormalize_done>
8000b230:	c7 83       	brcs	8000b320 <__avr32_f64_sub_longnormalize>
8000b232:	ec 0e 11 20 	rsub	lr,r6,32
8000b236:	f6 06 09 4b 	lsl	r11,r11,r6
8000b23a:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000b23e:	1c 4b       	or	r11,lr
8000b240:	f4 06 09 4a 	lsl	r10,r10,r6
8000b244:	0c 17       	sub	r7,r6
8000b246:	e0 8a 00 39 	brle	8000b2b8 <__avr32_f64_sub_subnormal_result>

8000b24a <__avr32_f64_sub_longnormalize_done>:
8000b24a:	f4 09 15 15 	lsl	r9,r10,0x15
8000b24e:	ab 9a       	lsr	r10,0xb
8000b250:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000b254:	ab 9b       	lsr	r11,0xb
8000b256:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000b25a:	18 4b       	or	r11,r12

8000b25c <__avr32_f64_sub_round>:
8000b25c:	fc 17 80 00 	movh	r7,0x8000
8000b260:	ed ba 00 00 	bld	r10,0x0
8000b264:	f7 b7 01 ff 	subne	r7,-1
8000b268:	0e 39       	cp.w	r9,r7
8000b26a:	5f 29       	srhs	r9
8000b26c:	12 0a       	add	r10,r9
8000b26e:	5c 0b       	acr	r11
8000b270:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b274 <__avr32_f64_sub_opL_subnormal>:
8000b274:	ab 79       	lsl	r9,0xb
8000b276:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000b27a:	ab 78       	lsl	r8,0xb
8000b27c:	f3 e8 10 0e 	or	lr,r9,r8
8000b280:	f9 b6 01 01 	movne	r6,1
8000b284:	ee 0e 11 00 	rsub	lr,r7,0
8000b288:	f9 b7 00 01 	moveq	r7,1
8000b28c:	ef bb 00 1f 	bst	r11,0x1f
8000b290:	f7 ea 10 0e 	or	lr,r11,r10
8000b294:	f9 b7 00 00 	moveq	r7,0
8000b298:	cb 0b       	rjmp	8000b1f8 <__avr32_f64_sub_opL_subnormal_done>

8000b29a <__avr32_f64_sub_opH_nan_or_inf>:
8000b29a:	bf db       	cbr	r11,0x1f
8000b29c:	f7 ea 10 0e 	or	lr,r11,r10
8000b2a0:	c0 81       	brne	8000b2b0 <__avr32_f64_sub_return_nan>
8000b2a2:	e0 46 07 ff 	cp.w	r6,2047
8000b2a6:	c0 50       	breq	8000b2b0 <__avr32_f64_sub_return_nan>
8000b2a8:	f9 e7 11 4b 	or	r11,r12,r7<<0x14
8000b2ac:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b2b0 <__avr32_f64_sub_return_nan>:
8000b2b0:	3f fa       	mov	r10,-1
8000b2b2:	3f fb       	mov	r11,-1
8000b2b4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b2b8 <__avr32_f64_sub_subnormal_result>:
8000b2b8:	5c 37       	neg	r7
8000b2ba:	2f f7       	sub	r7,-1
8000b2bc:	f1 b7 04 c0 	satu	r7,0x6
8000b2c0:	e0 47 00 20 	cp.w	r7,32
8000b2c4:	c1 14       	brge	8000b2e6 <__avr32_f64_sub_subnormal_result+0x2e>
8000b2c6:	ee 08 11 20 	rsub	r8,r7,32
8000b2ca:	f4 08 09 49 	lsl	r9,r10,r8
8000b2ce:	5f 16       	srne	r6
8000b2d0:	f4 07 0a 4a 	lsr	r10,r10,r7
8000b2d4:	0c 4a       	or	r10,r6
8000b2d6:	f6 08 09 49 	lsl	r9,r11,r8
8000b2da:	f5 e9 10 0a 	or	r10,r10,r9
8000b2de:	f4 07 0a 4b 	lsr	r11,r10,r7
8000b2e2:	30 07       	mov	r7,0
8000b2e4:	cb 3b       	rjmp	8000b24a <__avr32_f64_sub_longnormalize_done>
8000b2e6:	ee 08 11 40 	rsub	r8,r7,64
8000b2ea:	f6 08 09 49 	lsl	r9,r11,r8
8000b2ee:	14 49       	or	r9,r10
8000b2f0:	5f 16       	srne	r6
8000b2f2:	f6 07 0a 4a 	lsr	r10,r11,r7
8000b2f6:	0c 4a       	or	r10,r6
8000b2f8:	30 0b       	mov	r11,0
8000b2fa:	30 07       	mov	r7,0
8000b2fc:	ca 7b       	rjmp	8000b24a <__avr32_f64_sub_longnormalize_done>
8000b2fe:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b302 <__avr32_f64_sub_longshift>:
8000b302:	f1 b6 04 c0 	satu	r6,0x6
8000b306:	f0 0e 17 00 	moveq	lr,r8
8000b30a:	c0 40       	breq	8000b312 <__avr32_f64_sub_longshift+0x10>
8000b30c:	f2 05 09 4e 	lsl	lr,r9,r5
8000b310:	10 4e       	or	lr,r8
8000b312:	f2 06 0a 48 	lsr	r8,r9,r6
8000b316:	30 09       	mov	r9,0
8000b318:	58 0e       	cp.w	lr,0
8000b31a:	5f 1e       	srne	lr
8000b31c:	1c 48       	or	r8,lr
8000b31e:	c8 3b       	rjmp	8000b224 <__avr32_f64_sub_shift_done>

8000b320 <__avr32_f64_sub_longnormalize>:
8000b320:	f4 06 12 00 	clz	r6,r10
8000b324:	f9 b7 03 00 	movlo	r7,0
8000b328:	f9 b6 03 00 	movlo	r6,0
8000b32c:	f9 bc 03 00 	movlo	r12,0
8000b330:	f7 b6 02 e0 	subhs	r6,-32
8000b334:	f4 06 09 4b 	lsl	r11,r10,r6
8000b338:	30 0a       	mov	r10,0
8000b33a:	0c 17       	sub	r7,r6
8000b33c:	fe 9a ff be 	brle	8000b2b8 <__avr32_f64_sub_subnormal_result>
8000b340:	c8 5b       	rjmp	8000b24a <__avr32_f64_sub_longnormalize_done>
8000b342:	d7 03       	nop

8000b344 <__avr32_f64_add_from_sub>:
8000b344:	ee 19 80 00 	eorh	r9,0x8000

8000b348 <__avr32_f64_add>:
8000b348:	f7 e9 20 0c 	eor	r12,r11,r9
8000b34c:	fe 96 ff 2e 	brmi	8000b1a8 <__avr32_f64_sub_from_add>
8000b350:	eb cd 40 e0 	pushm	r5-r7,lr
8000b354:	16 9c       	mov	r12,r11
8000b356:	e6 1c 80 00 	andh	r12,0x8000,COH
8000b35a:	bf db       	cbr	r11,0x1f
8000b35c:	bf d9       	cbr	r9,0x1f
8000b35e:	12 3b       	cp.w	r11,r9
8000b360:	c0 72       	brcc	8000b36e <__avr32_f64_add+0x26>
8000b362:	16 97       	mov	r7,r11
8000b364:	12 9b       	mov	r11,r9
8000b366:	0e 99       	mov	r9,r7
8000b368:	14 97       	mov	r7,r10
8000b36a:	10 9a       	mov	r10,r8
8000b36c:	0e 98       	mov	r8,r7
8000b36e:	30 0e       	mov	lr,0
8000b370:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000b374:	f7 db c0 14 	bfextu	r11,r11,0x0,0x14
8000b378:	b5 ab       	sbr	r11,0x14
8000b37a:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000b37e:	c6 20       	breq	8000b442 <__avr32_f64_add_op2_subnormal>
8000b380:	f3 d9 c0 14 	bfextu	r9,r9,0x0,0x14
8000b384:	b5 a9       	sbr	r9,0x14
8000b386:	e0 47 07 ff 	cp.w	r7,2047
8000b38a:	c2 80       	breq	8000b3da <__avr32_f64_add_opH_nan_or_inf>
8000b38c:	0e 26       	rsub	r6,r7
8000b38e:	c1 20       	breq	8000b3b2 <__avr32_f64_add_shift_done>
8000b390:	e0 46 00 36 	cp.w	r6,54
8000b394:	c1 52       	brcc	8000b3be <__avr32_f64_add_res_of_done>
8000b396:	ec 05 11 20 	rsub	r5,r6,32
8000b39a:	e0 46 00 20 	cp.w	r6,32
8000b39e:	c3 52       	brcc	8000b408 <__avr32_f64_add_longshift>
8000b3a0:	f0 05 09 4e 	lsl	lr,r8,r5
8000b3a4:	f2 05 09 45 	lsl	r5,r9,r5
8000b3a8:	f0 06 0a 48 	lsr	r8,r8,r6
8000b3ac:	f2 06 0a 49 	lsr	r9,r9,r6
8000b3b0:	0a 48       	or	r8,r5

8000b3b2 <__avr32_f64_add_shift_done>:
8000b3b2:	10 0a       	add	r10,r8
8000b3b4:	f6 09 00 4b 	adc	r11,r11,r9
8000b3b8:	ed bb 00 15 	bld	r11,0x15
8000b3bc:	c3 40       	breq	8000b424 <__avr32_f64_add_res_of>

8000b3be <__avr32_f64_add_res_of_done>:
8000b3be:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000b3c2:	18 4b       	or	r11,r12

8000b3c4 <__avr32_f64_add_round>:
8000b3c4:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
8000b3c8:	18 4e       	or	lr,r12
8000b3ca:	ee 1e 80 00 	eorh	lr,0x8000
8000b3ce:	f1 be 04 20 	satu	lr,0x1
8000b3d2:	1c 0a       	add	r10,lr
8000b3d4:	5c 0b       	acr	r11
8000b3d6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b3da <__avr32_f64_add_opH_nan_or_inf>:
8000b3da:	b5 cb       	cbr	r11,0x14
8000b3dc:	f7 ea 10 0e 	or	lr,r11,r10
8000b3e0:	c1 01       	brne	8000b400 <__avr32_f64_add_return_nan>
8000b3e2:	e0 46 07 ff 	cp.w	r6,2047
8000b3e6:	c0 30       	breq	8000b3ec <__avr32_f64_add_opL_nan_or_inf>
8000b3e8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b3ec <__avr32_f64_add_opL_nan_or_inf>:
8000b3ec:	b5 c9       	cbr	r9,0x14
8000b3ee:	f3 e8 10 0e 	or	lr,r9,r8
8000b3f2:	c0 71       	brne	8000b400 <__avr32_f64_add_return_nan>
8000b3f4:	30 0a       	mov	r10,0
8000b3f6:	fc 1b 7f f0 	movh	r11,0x7ff0
8000b3fa:	18 4b       	or	r11,r12
8000b3fc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b400 <__avr32_f64_add_return_nan>:
8000b400:	3f fa       	mov	r10,-1
8000b402:	3f fb       	mov	r11,-1
8000b404:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b408 <__avr32_f64_add_longshift>:
8000b408:	f1 b6 04 c0 	satu	r6,0x6
8000b40c:	f0 0e 17 00 	moveq	lr,r8
8000b410:	c0 60       	breq	8000b41c <__avr32_f64_add_longshift+0x14>
8000b412:	f2 05 09 4e 	lsl	lr,r9,r5
8000b416:	58 08       	cp.w	r8,0
8000b418:	5f 18       	srne	r8
8000b41a:	10 4e       	or	lr,r8
8000b41c:	f2 06 0a 48 	lsr	r8,r9,r6
8000b420:	30 09       	mov	r9,0
8000b422:	cc 8b       	rjmp	8000b3b2 <__avr32_f64_add_shift_done>

8000b424 <__avr32_f64_add_res_of>:
8000b424:	fd ee 10 1e 	or	lr,lr,lr<<0x1
8000b428:	a1 9b       	lsr	r11,0x1
8000b42a:	5d 0a       	ror	r10
8000b42c:	5d 0e       	ror	lr
8000b42e:	2f f7       	sub	r7,-1
8000b430:	e0 47 07 ff 	cp.w	r7,2047
8000b434:	f9 ba 00 00 	moveq	r10,0
8000b438:	f9 bb 00 00 	moveq	r11,0
8000b43c:	f9 be 00 00 	moveq	lr,0
8000b440:	cb fb       	rjmp	8000b3be <__avr32_f64_add_res_of_done>

8000b442 <__avr32_f64_add_op2_subnormal>:
8000b442:	30 16       	mov	r6,1
8000b444:	58 07       	cp.w	r7,0
8000b446:	ca 01       	brne	8000b386 <__avr32_f64_add+0x3e>
8000b448:	b5 cb       	cbr	r11,0x14
8000b44a:	10 0a       	add	r10,r8
8000b44c:	f6 09 00 4b 	adc	r11,r11,r9
8000b450:	18 4b       	or	r11,r12
8000b452:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000b456:	d7 03       	nop

8000b458 <__avr32_f64_to_u32>:
8000b458:	58 0b       	cp.w	r11,0
8000b45a:	5e 6d       	retmi	0

8000b45c <__avr32_f64_to_s32>:
8000b45c:	f6 0c 15 01 	lsl	r12,r11,0x1
8000b460:	b5 9c       	lsr	r12,0x15
8000b462:	e0 2c 03 ff 	sub	r12,1023
8000b466:	5e 3d       	retlo	0
8000b468:	f8 0c 11 1f 	rsub	r12,r12,31
8000b46c:	16 99       	mov	r9,r11
8000b46e:	ab 7b       	lsl	r11,0xb
8000b470:	bf bb       	sbr	r11,0x1f
8000b472:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000b476:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000b47a:	a1 79       	lsl	r9,0x1
8000b47c:	5e 2b       	reths	r11
8000b47e:	5c 3b       	neg	r11
8000b480:	5e fb       	retal	r11

8000b482 <__avr32_u32_to_f64>:
8000b482:	f8 cb 00 00 	sub	r11,r12,0
8000b486:	30 0c       	mov	r12,0
8000b488:	c0 38       	rjmp	8000b48e <__avr32_s32_to_f64+0x4>

8000b48a <__avr32_s32_to_f64>:
8000b48a:	18 9b       	mov	r11,r12
8000b48c:	5c 4b       	abs	r11
8000b48e:	30 0a       	mov	r10,0
8000b490:	5e 0b       	reteq	r11
8000b492:	d4 01       	pushm	lr
8000b494:	e0 69 04 1e 	mov	r9,1054
8000b498:	f6 08 12 00 	clz	r8,r11
8000b49c:	c1 70       	breq	8000b4ca <__avr32_s32_to_f64+0x40>
8000b49e:	c0 c3       	brcs	8000b4b6 <__avr32_s32_to_f64+0x2c>
8000b4a0:	f0 0e 11 20 	rsub	lr,r8,32
8000b4a4:	f6 08 09 4b 	lsl	r11,r11,r8
8000b4a8:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000b4ac:	1c 4b       	or	r11,lr
8000b4ae:	f4 08 09 4a 	lsl	r10,r10,r8
8000b4b2:	10 19       	sub	r9,r8
8000b4b4:	c0 b8       	rjmp	8000b4ca <__avr32_s32_to_f64+0x40>
8000b4b6:	f4 08 12 00 	clz	r8,r10
8000b4ba:	f9 b8 03 00 	movlo	r8,0
8000b4be:	f7 b8 02 e0 	subhs	r8,-32
8000b4c2:	f4 08 09 4b 	lsl	r11,r10,r8
8000b4c6:	30 0a       	mov	r10,0
8000b4c8:	10 19       	sub	r9,r8
8000b4ca:	58 09       	cp.w	r9,0
8000b4cc:	e0 89 00 30 	brgt	8000b52c <__avr32_s32_to_f64+0xa2>
8000b4d0:	5c 39       	neg	r9
8000b4d2:	2f f9       	sub	r9,-1
8000b4d4:	e0 49 00 36 	cp.w	r9,54
8000b4d8:	c0 43       	brcs	8000b4e0 <__avr32_s32_to_f64+0x56>
8000b4da:	30 0b       	mov	r11,0
8000b4dc:	30 0a       	mov	r10,0
8000b4de:	c2 68       	rjmp	8000b52a <__avr32_s32_to_f64+0xa0>
8000b4e0:	2f 69       	sub	r9,-10
8000b4e2:	f2 08 11 20 	rsub	r8,r9,32
8000b4e6:	e0 49 00 20 	cp.w	r9,32
8000b4ea:	c0 b2       	brcc	8000b500 <__avr32_s32_to_f64+0x76>
8000b4ec:	f4 08 09 4e 	lsl	lr,r10,r8
8000b4f0:	f6 08 09 48 	lsl	r8,r11,r8
8000b4f4:	f4 09 0a 4a 	lsr	r10,r10,r9
8000b4f8:	f6 09 0a 4b 	lsr	r11,r11,r9
8000b4fc:	10 4b       	or	r11,r8
8000b4fe:	c0 88       	rjmp	8000b50e <__avr32_s32_to_f64+0x84>
8000b500:	f6 08 09 4e 	lsl	lr,r11,r8
8000b504:	14 4e       	or	lr,r10
8000b506:	16 9a       	mov	r10,r11
8000b508:	30 0b       	mov	r11,0
8000b50a:	f4 09 0a 4a 	lsr	r10,r10,r9
8000b50e:	ed ba 00 00 	bld	r10,0x0
8000b512:	c0 92       	brcc	8000b524 <__avr32_s32_to_f64+0x9a>
8000b514:	1c 7e       	tst	lr,lr
8000b516:	c0 41       	brne	8000b51e <__avr32_s32_to_f64+0x94>
8000b518:	ed ba 00 01 	bld	r10,0x1
8000b51c:	c0 42       	brcc	8000b524 <__avr32_s32_to_f64+0x9a>
8000b51e:	2f fa       	sub	r10,-1
8000b520:	f7 bb 02 ff 	subhs	r11,-1
8000b524:	5c fc       	rol	r12
8000b526:	5d 0b       	ror	r11
8000b528:	5d 0a       	ror	r10
8000b52a:	d8 02       	popm	pc
8000b52c:	e0 68 03 ff 	mov	r8,1023
8000b530:	ed ba 00 0b 	bld	r10,0xb
8000b534:	f7 b8 00 ff 	subeq	r8,-1
8000b538:	10 0a       	add	r10,r8
8000b53a:	5c 0b       	acr	r11
8000b53c:	f7 b9 03 fe 	sublo	r9,-2
8000b540:	e0 49 07 ff 	cp.w	r9,2047
8000b544:	c0 55       	brlt	8000b54e <__avr32_s32_to_f64+0xc4>
8000b546:	30 0a       	mov	r10,0
8000b548:	fc 1b ff e0 	movh	r11,0xffe0
8000b54c:	c0 c8       	rjmp	8000b564 <__floatsidf_return_op1>
8000b54e:	ed bb 00 1f 	bld	r11,0x1f
8000b552:	f7 b9 01 01 	subne	r9,1
8000b556:	ab 9a       	lsr	r10,0xb
8000b558:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000b55c:	a1 7b       	lsl	r11,0x1
8000b55e:	ab 9b       	lsr	r11,0xb
8000b560:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

8000b564 <__floatsidf_return_op1>:
8000b564:	a1 7c       	lsl	r12,0x1
8000b566:	5d 0b       	ror	r11
8000b568:	d8 02       	popm	pc

8000b56a <__avr32_f64_cmp_eq>:
8000b56a:	10 3a       	cp.w	r10,r8
8000b56c:	f2 0b 13 00 	cpc	r11,r9
8000b570:	c0 80       	breq	8000b580 <__avr32_f64_cmp_eq+0x16>
8000b572:	a1 7b       	lsl	r11,0x1
8000b574:	a1 79       	lsl	r9,0x1
8000b576:	14 4b       	or	r11,r10
8000b578:	12 4b       	or	r11,r9
8000b57a:	10 4b       	or	r11,r8
8000b57c:	5e 0f       	reteq	1
8000b57e:	5e fd       	retal	0
8000b580:	a1 7b       	lsl	r11,0x1
8000b582:	fc 1c ff e0 	movh	r12,0xffe0
8000b586:	58 0a       	cp.w	r10,0
8000b588:	f8 0b 13 00 	cpc	r11,r12
8000b58c:	5e 8f       	retls	1
8000b58e:	5e fd       	retal	0

8000b590 <__avr32_f64_cmp_ge>:
8000b590:	1a de       	st.w	--sp,lr
8000b592:	1a d7       	st.w	--sp,r7
8000b594:	a1 7b       	lsl	r11,0x1
8000b596:	5f 3c       	srlo	r12
8000b598:	a1 79       	lsl	r9,0x1
8000b59a:	5f 37       	srlo	r7
8000b59c:	5c fc       	rol	r12
8000b59e:	fc 1e ff e0 	movh	lr,0xffe0
8000b5a2:	58 0a       	cp.w	r10,0
8000b5a4:	fc 0b 13 00 	cpc	r11,lr
8000b5a8:	e0 8b 00 1d 	brhi	8000b5e2 <__avr32_f64_cmp_ge+0x52>
8000b5ac:	58 08       	cp.w	r8,0
8000b5ae:	fc 09 13 00 	cpc	r9,lr
8000b5b2:	e0 8b 00 18 	brhi	8000b5e2 <__avr32_f64_cmp_ge+0x52>
8000b5b6:	58 0b       	cp.w	r11,0
8000b5b8:	f5 ba 00 00 	subfeq	r10,0
8000b5bc:	c1 50       	breq	8000b5e6 <__avr32_f64_cmp_ge+0x56>
8000b5be:	1b 07       	ld.w	r7,sp++
8000b5c0:	1b 0e       	ld.w	lr,sp++
8000b5c2:	58 3c       	cp.w	r12,3
8000b5c4:	c0 a0       	breq	8000b5d8 <__avr32_f64_cmp_ge+0x48>
8000b5c6:	58 1c       	cp.w	r12,1
8000b5c8:	c0 33       	brcs	8000b5ce <__avr32_f64_cmp_ge+0x3e>
8000b5ca:	5e 0f       	reteq	1
8000b5cc:	5e 1d       	retne	0
8000b5ce:	10 3a       	cp.w	r10,r8
8000b5d0:	f2 0b 13 00 	cpc	r11,r9
8000b5d4:	5e 2f       	reths	1
8000b5d6:	5e 3d       	retlo	0
8000b5d8:	14 38       	cp.w	r8,r10
8000b5da:	f6 09 13 00 	cpc	r9,r11
8000b5de:	5e 2f       	reths	1
8000b5e0:	5e 3d       	retlo	0
8000b5e2:	1b 07       	ld.w	r7,sp++
8000b5e4:	d8 0a       	popm	pc,r12=0
8000b5e6:	58 17       	cp.w	r7,1
8000b5e8:	5f 0c       	sreq	r12
8000b5ea:	58 09       	cp.w	r9,0
8000b5ec:	f5 b8 00 00 	subfeq	r8,0
8000b5f0:	1b 07       	ld.w	r7,sp++
8000b5f2:	1b 0e       	ld.w	lr,sp++
8000b5f4:	5e 0f       	reteq	1
8000b5f6:	5e fc       	retal	r12

8000b5f8 <__avr32_f64_cmp_lt>:
8000b5f8:	1a de       	st.w	--sp,lr
8000b5fa:	1a d7       	st.w	--sp,r7
8000b5fc:	a1 7b       	lsl	r11,0x1
8000b5fe:	5f 3c       	srlo	r12
8000b600:	a1 79       	lsl	r9,0x1
8000b602:	5f 37       	srlo	r7
8000b604:	5c fc       	rol	r12
8000b606:	fc 1e ff e0 	movh	lr,0xffe0
8000b60a:	58 0a       	cp.w	r10,0
8000b60c:	fc 0b 13 00 	cpc	r11,lr
8000b610:	e0 8b 00 1d 	brhi	8000b64a <__avr32_f64_cmp_lt+0x52>
8000b614:	58 08       	cp.w	r8,0
8000b616:	fc 09 13 00 	cpc	r9,lr
8000b61a:	e0 8b 00 18 	brhi	8000b64a <__avr32_f64_cmp_lt+0x52>
8000b61e:	58 0b       	cp.w	r11,0
8000b620:	f5 ba 00 00 	subfeq	r10,0
8000b624:	c1 50       	breq	8000b64e <__avr32_f64_cmp_lt+0x56>
8000b626:	1b 07       	ld.w	r7,sp++
8000b628:	1b 0e       	ld.w	lr,sp++
8000b62a:	58 3c       	cp.w	r12,3
8000b62c:	c0 a0       	breq	8000b640 <__avr32_f64_cmp_lt+0x48>
8000b62e:	58 1c       	cp.w	r12,1
8000b630:	c0 33       	brcs	8000b636 <__avr32_f64_cmp_lt+0x3e>
8000b632:	5e 0d       	reteq	0
8000b634:	5e 1f       	retne	1
8000b636:	10 3a       	cp.w	r10,r8
8000b638:	f2 0b 13 00 	cpc	r11,r9
8000b63c:	5e 2d       	reths	0
8000b63e:	5e 3f       	retlo	1
8000b640:	14 38       	cp.w	r8,r10
8000b642:	f6 09 13 00 	cpc	r9,r11
8000b646:	5e 2d       	reths	0
8000b648:	5e 3f       	retlo	1
8000b64a:	1b 07       	ld.w	r7,sp++
8000b64c:	d8 0a       	popm	pc,r12=0
8000b64e:	58 17       	cp.w	r7,1
8000b650:	5f 1c       	srne	r12
8000b652:	58 09       	cp.w	r9,0
8000b654:	f5 b8 00 00 	subfeq	r8,0
8000b658:	1b 07       	ld.w	r7,sp++
8000b65a:	1b 0e       	ld.w	lr,sp++
8000b65c:	5e 0d       	reteq	0
8000b65e:	5e fc       	retal	r12

8000b660 <__avr32_f64_div>:
8000b660:	eb cd 40 ff 	pushm	r0-r7,lr
8000b664:	f7 e9 20 0e 	eor	lr,r11,r9
8000b668:	f6 07 16 14 	lsr	r7,r11,0x14
8000b66c:	a9 7b       	lsl	r11,0x9
8000b66e:	f7 ea 13 7b 	or	r11,r11,r10>>0x17
8000b672:	a9 7a       	lsl	r10,0x9
8000b674:	bd bb       	sbr	r11,0x1d
8000b676:	e4 1b 3f ff 	andh	r11,0x3fff
8000b67a:	ab d7       	cbr	r7,0xb
8000b67c:	e0 80 00 cc 	breq	8000b814 <__avr32_f64_div_round_subnormal+0x54>
8000b680:	e0 47 07 ff 	cp.w	r7,2047
8000b684:	e0 84 00 b5 	brge	8000b7ee <__avr32_f64_div_round_subnormal+0x2e>
8000b688:	f2 06 16 14 	lsr	r6,r9,0x14
8000b68c:	a9 79       	lsl	r9,0x9
8000b68e:	f3 e8 13 79 	or	r9,r9,r8>>0x17
8000b692:	a9 78       	lsl	r8,0x9
8000b694:	bd b9       	sbr	r9,0x1d
8000b696:	e4 19 3f ff 	andh	r9,0x3fff
8000b69a:	ab d6       	cbr	r6,0xb
8000b69c:	e0 80 00 e2 	breq	8000b860 <__avr32_f64_div_round_subnormal+0xa0>
8000b6a0:	e0 46 07 ff 	cp.w	r6,2047
8000b6a4:	e0 84 00 b2 	brge	8000b808 <__avr32_f64_div_round_subnormal+0x48>
8000b6a8:	0c 17       	sub	r7,r6
8000b6aa:	fe 37 fc 01 	sub	r7,-1023
8000b6ae:	fc 1c 80 00 	movh	r12,0x8000
8000b6b2:	f8 03 16 01 	lsr	r3,r12,0x1
8000b6b6:	e9 d9 c3 62 	bfextu	r4,r9,0x1b,0x2
8000b6ba:	5c d4       	com	r4
8000b6bc:	e7 d4 d3 82 	bfins	r3,r4,0x1c,0x2
8000b6c0:	e6 09 06 44 	mulu.d	r4,r3,r9
8000b6c4:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000b6c8:	e6 05 06 44 	mulu.d	r4,r3,r5
8000b6cc:	ea 03 15 02 	lsl	r3,r5,0x2
8000b6d0:	e6 09 06 44 	mulu.d	r4,r3,r9
8000b6d4:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000b6d8:	e6 05 06 44 	mulu.d	r4,r3,r5
8000b6dc:	ea 03 15 02 	lsl	r3,r5,0x2
8000b6e0:	e6 09 06 44 	mulu.d	r4,r3,r9
8000b6e4:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000b6e8:	e6 05 06 44 	mulu.d	r4,r3,r5
8000b6ec:	ea 03 15 02 	lsl	r3,r5,0x2
8000b6f0:	e6 08 06 40 	mulu.d	r0,r3,r8
8000b6f4:	e4 09 07 40 	macu.d	r0,r2,r9
8000b6f8:	e6 09 06 44 	mulu.d	r4,r3,r9
8000b6fc:	02 04       	add	r4,r1
8000b6fe:	5c 05       	acr	r5
8000b700:	a3 65       	lsl	r5,0x2
8000b702:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000b706:	a3 64       	lsl	r4,0x2
8000b708:	5c 34       	neg	r4
8000b70a:	f8 05 01 45 	sbc	r5,r12,r5
8000b70e:	e6 04 06 40 	mulu.d	r0,r3,r4
8000b712:	e4 05 07 40 	macu.d	r0,r2,r5
8000b716:	e6 05 06 44 	mulu.d	r4,r3,r5
8000b71a:	02 04       	add	r4,r1
8000b71c:	5c 05       	acr	r5
8000b71e:	ea 03 15 02 	lsl	r3,r5,0x2
8000b722:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000b726:	e8 02 15 02 	lsl	r2,r4,0x2
8000b72a:	e6 08 06 40 	mulu.d	r0,r3,r8
8000b72e:	e4 09 07 40 	macu.d	r0,r2,r9
8000b732:	e6 09 06 44 	mulu.d	r4,r3,r9
8000b736:	02 04       	add	r4,r1
8000b738:	5c 05       	acr	r5
8000b73a:	a3 65       	lsl	r5,0x2
8000b73c:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000b740:	a3 64       	lsl	r4,0x2
8000b742:	5c 34       	neg	r4
8000b744:	f8 05 01 45 	sbc	r5,r12,r5
8000b748:	e6 04 06 40 	mulu.d	r0,r3,r4
8000b74c:	e4 05 07 40 	macu.d	r0,r2,r5
8000b750:	e6 05 06 44 	mulu.d	r4,r3,r5
8000b754:	02 04       	add	r4,r1
8000b756:	5c 05       	acr	r5
8000b758:	ea 03 15 02 	lsl	r3,r5,0x2
8000b75c:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000b760:	e8 02 15 02 	lsl	r2,r4,0x2
8000b764:	e6 0a 06 40 	mulu.d	r0,r3,r10
8000b768:	e4 0b 07 40 	macu.d	r0,r2,r11
8000b76c:	e6 0b 06 42 	mulu.d	r2,r3,r11
8000b770:	02 02       	add	r2,r1
8000b772:	5c 03       	acr	r3
8000b774:	ed b3 00 1c 	bld	r3,0x1c
8000b778:	c0 90       	breq	8000b78a <__avr32_f64_div+0x12a>
8000b77a:	a1 72       	lsl	r2,0x1
8000b77c:	5c f3       	rol	r3
8000b77e:	20 17       	sub	r7,1
8000b780:	a3 9a       	lsr	r10,0x3
8000b782:	f5 eb 11 da 	or	r10,r10,r11<<0x1d
8000b786:	a3 9b       	lsr	r11,0x3
8000b788:	c0 58       	rjmp	8000b792 <__avr32_f64_div+0x132>
8000b78a:	a5 8a       	lsr	r10,0x4
8000b78c:	f5 eb 11 ca 	or	r10,r10,r11<<0x1c
8000b790:	a5 8b       	lsr	r11,0x4
8000b792:	58 07       	cp.w	r7,0
8000b794:	e0 8a 00 8b 	brle	8000b8aa <__avr32_f64_div_res_subnormal>
8000b798:	e0 12 ff 00 	andl	r2,0xff00
8000b79c:	e8 12 00 80 	orl	r2,0x80
8000b7a0:	e6 08 06 40 	mulu.d	r0,r3,r8
8000b7a4:	e4 09 07 40 	macu.d	r0,r2,r9
8000b7a8:	e4 08 06 44 	mulu.d	r4,r2,r8
8000b7ac:	e6 09 06 48 	mulu.d	r8,r3,r9
8000b7b0:	00 05       	add	r5,r0
8000b7b2:	f0 01 00 48 	adc	r8,r8,r1
8000b7b6:	5c 09       	acr	r9
8000b7b8:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000b7bc:	58 04       	cp.w	r4,0
8000b7be:	5c 25       	cpc	r5

8000b7c0 <__avr32_f64_div_round_subnormal>:
8000b7c0:	f4 08 13 00 	cpc	r8,r10
8000b7c4:	f6 09 13 00 	cpc	r9,r11
8000b7c8:	5f 36       	srlo	r6
8000b7ca:	f8 06 17 00 	moveq	r6,r12
8000b7ce:	e4 0a 16 08 	lsr	r10,r2,0x8
8000b7d2:	f5 e3 11 8a 	or	r10,r10,r3<<0x18
8000b7d6:	e6 0b 16 08 	lsr	r11,r3,0x8
8000b7da:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000b7de:	ed be 00 1f 	bld	lr,0x1f
8000b7e2:	ef bb 00 1f 	bst	r11,0x1f
8000b7e6:	0c 0a       	add	r10,r6
8000b7e8:	5c 0b       	acr	r11
8000b7ea:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000b7ee:	e4 1b 00 0f 	andh	r11,0xf
8000b7f2:	14 4b       	or	r11,r10
8000b7f4:	e0 81 00 a7 	brne	8000b942 <__avr32_f64_div_res_subnormal+0x98>
8000b7f8:	f2 06 16 14 	lsr	r6,r9,0x14
8000b7fc:	ab d6       	cbr	r6,0xb
8000b7fe:	e0 46 07 ff 	cp.w	r6,2047
8000b802:	e0 81 00 a4 	brne	8000b94a <__avr32_f64_div_res_subnormal+0xa0>
8000b806:	c9 e8       	rjmp	8000b942 <__avr32_f64_div_res_subnormal+0x98>
8000b808:	e4 19 00 0f 	andh	r9,0xf
8000b80c:	10 49       	or	r9,r8
8000b80e:	e0 81 00 9a 	brne	8000b942 <__avr32_f64_div_res_subnormal+0x98>
8000b812:	c9 28       	rjmp	8000b936 <__avr32_f64_div_res_subnormal+0x8c>
8000b814:	a3 7b       	lsl	r11,0x3
8000b816:	f7 ea 13 db 	or	r11,r11,r10>>0x1d
8000b81a:	a3 7a       	lsl	r10,0x3
8000b81c:	f5 eb 10 04 	or	r4,r10,r11
8000b820:	e0 80 00 a0 	breq	8000b960 <__avr32_f64_div_op1_zero>
8000b824:	f6 04 12 00 	clz	r4,r11
8000b828:	c1 70       	breq	8000b856 <__avr32_f64_div_round_subnormal+0x96>
8000b82a:	c0 c3       	brcs	8000b842 <__avr32_f64_div_round_subnormal+0x82>
8000b82c:	e8 05 11 20 	rsub	r5,r4,32
8000b830:	f6 04 09 4b 	lsl	r11,r11,r4
8000b834:	f4 05 0a 45 	lsr	r5,r10,r5
8000b838:	0a 4b       	or	r11,r5
8000b83a:	f4 04 09 4a 	lsl	r10,r10,r4
8000b83e:	08 17       	sub	r7,r4
8000b840:	c0 b8       	rjmp	8000b856 <__avr32_f64_div_round_subnormal+0x96>
8000b842:	f4 04 12 00 	clz	r4,r10
8000b846:	f9 b4 03 00 	movlo	r4,0
8000b84a:	f7 b4 02 e0 	subhs	r4,-32
8000b84e:	f4 04 09 4b 	lsl	r11,r10,r4
8000b852:	30 0a       	mov	r10,0
8000b854:	08 17       	sub	r7,r4
8000b856:	a3 8a       	lsr	r10,0x2
8000b858:	f5 eb 11 ea 	or	r10,r10,r11<<0x1e
8000b85c:	a3 8b       	lsr	r11,0x2
8000b85e:	c1 1b       	rjmp	8000b680 <__avr32_f64_div+0x20>
8000b860:	a3 79       	lsl	r9,0x3
8000b862:	f3 e8 13 d9 	or	r9,r9,r8>>0x1d
8000b866:	a3 78       	lsl	r8,0x3
8000b868:	f3 e8 10 04 	or	r4,r9,r8
8000b86c:	c6 f0       	breq	8000b94a <__avr32_f64_div_res_subnormal+0xa0>
8000b86e:	f2 04 12 00 	clz	r4,r9
8000b872:	c1 70       	breq	8000b8a0 <__avr32_f64_div_round_subnormal+0xe0>
8000b874:	c0 c3       	brcs	8000b88c <__avr32_f64_div_round_subnormal+0xcc>
8000b876:	e8 05 11 20 	rsub	r5,r4,32
8000b87a:	f2 04 09 49 	lsl	r9,r9,r4
8000b87e:	f0 05 0a 45 	lsr	r5,r8,r5
8000b882:	0a 49       	or	r9,r5
8000b884:	f0 04 09 48 	lsl	r8,r8,r4
8000b888:	08 16       	sub	r6,r4
8000b88a:	c0 b8       	rjmp	8000b8a0 <__avr32_f64_div_round_subnormal+0xe0>
8000b88c:	f0 04 12 00 	clz	r4,r8
8000b890:	f9 b4 03 00 	movlo	r4,0
8000b894:	f7 b4 02 e0 	subhs	r4,-32
8000b898:	f0 04 09 49 	lsl	r9,r8,r4
8000b89c:	30 08       	mov	r8,0
8000b89e:	08 16       	sub	r6,r4
8000b8a0:	a3 88       	lsr	r8,0x2
8000b8a2:	f1 e9 11 e8 	or	r8,r8,r9<<0x1e
8000b8a6:	a3 89       	lsr	r9,0x2
8000b8a8:	cf ca       	rjmp	8000b6a0 <__avr32_f64_div+0x40>

8000b8aa <__avr32_f64_div_res_subnormal>:
8000b8aa:	5c 37       	neg	r7
8000b8ac:	2f f7       	sub	r7,-1
8000b8ae:	f1 b7 04 c0 	satu	r7,0x6
8000b8b2:	e0 47 00 20 	cp.w	r7,32
8000b8b6:	c1 54       	brge	8000b8e0 <__avr32_f64_div_res_subnormal+0x36>
8000b8b8:	ee 06 11 20 	rsub	r6,r7,32
8000b8bc:	e4 07 0a 42 	lsr	r2,r2,r7
8000b8c0:	e6 06 09 4c 	lsl	r12,r3,r6
8000b8c4:	18 42       	or	r2,r12
8000b8c6:	e6 07 0a 43 	lsr	r3,r3,r7
8000b8ca:	f4 06 09 41 	lsl	r1,r10,r6
8000b8ce:	f4 07 0a 4a 	lsr	r10,r10,r7
8000b8d2:	f6 06 09 4c 	lsl	r12,r11,r6
8000b8d6:	18 4a       	or	r10,r12
8000b8d8:	f6 07 0a 4b 	lsr	r11,r11,r7
8000b8dc:	30 00       	mov	r0,0
8000b8de:	c1 58       	rjmp	8000b908 <__avr32_f64_div_res_subnormal+0x5e>
8000b8e0:	ee 06 11 20 	rsub	r6,r7,32
8000b8e4:	f9 b0 00 00 	moveq	r0,0
8000b8e8:	f9 bc 00 00 	moveq	r12,0
8000b8ec:	c0 50       	breq	8000b8f6 <__avr32_f64_div_res_subnormal+0x4c>
8000b8ee:	f4 06 09 40 	lsl	r0,r10,r6
8000b8f2:	f6 06 09 4c 	lsl	r12,r11,r6
8000b8f6:	e6 07 0a 42 	lsr	r2,r3,r7
8000b8fa:	30 03       	mov	r3,0
8000b8fc:	f4 07 0a 41 	lsr	r1,r10,r7
8000b900:	18 41       	or	r1,r12
8000b902:	f6 07 0a 4a 	lsr	r10,r11,r7
8000b906:	30 0b       	mov	r11,0
8000b908:	e0 12 ff 00 	andl	r2,0xff00
8000b90c:	e8 12 00 80 	orl	r2,0x80
8000b910:	e6 08 06 46 	mulu.d	r6,r3,r8
8000b914:	e4 09 07 46 	macu.d	r6,r2,r9
8000b918:	e4 08 06 44 	mulu.d	r4,r2,r8
8000b91c:	e6 09 06 48 	mulu.d	r8,r3,r9
8000b920:	0c 05       	add	r5,r6
8000b922:	f0 07 00 48 	adc	r8,r8,r7
8000b926:	5c 09       	acr	r9
8000b928:	30 07       	mov	r7,0
8000b92a:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000b92e:	00 34       	cp.w	r4,r0
8000b930:	e2 05 13 00 	cpc	r5,r1
8000b934:	c4 6b       	rjmp	8000b7c0 <__avr32_f64_div_round_subnormal>
8000b936:	1c 9b       	mov	r11,lr
8000b938:	e6 1b 80 00 	andh	r11,0x8000,COH
8000b93c:	30 0a       	mov	r10,0
8000b93e:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000b942:	3f fb       	mov	r11,-1
8000b944:	30 0a       	mov	r10,0
8000b946:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000b94a:	f5 eb 10 04 	or	r4,r10,r11
8000b94e:	c0 90       	breq	8000b960 <__avr32_f64_div_op1_zero>
8000b950:	1c 9b       	mov	r11,lr
8000b952:	e6 1b 80 00 	andh	r11,0x8000,COH
8000b956:	ea 1b 7f f0 	orh	r11,0x7ff0
8000b95a:	30 0a       	mov	r10,0
8000b95c:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc

8000b960 <__avr32_f64_div_op1_zero>:
8000b960:	f1 e9 10 15 	or	r5,r8,r9<<0x1
8000b964:	ce f0       	breq	8000b942 <__avr32_f64_div_res_subnormal+0x98>
8000b966:	e9 d9 c2 8b 	bfextu	r4,r9,0x14,0xb
8000b96a:	e0 44 07 ff 	cp.w	r4,2047
8000b96e:	ce 41       	brne	8000b936 <__avr32_f64_div_res_subnormal+0x8c>
8000b970:	f1 e9 10 c5 	or	r5,r8,r9<<0xc
8000b974:	ce 10       	breq	8000b936 <__avr32_f64_div_res_subnormal+0x8c>
8000b976:	ce 6b       	rjmp	8000b942 <__avr32_f64_div_res_subnormal+0x98>

8000b978 <__avr32_udiv64>:
8000b978:	d4 31       	pushm	r0-r7,lr
8000b97a:	1a 97       	mov	r7,sp
8000b97c:	20 3d       	sub	sp,12
8000b97e:	10 9c       	mov	r12,r8
8000b980:	12 9e       	mov	lr,r9
8000b982:	14 93       	mov	r3,r10
8000b984:	58 09       	cp.w	r9,0
8000b986:	e0 81 00 bd 	brne	8000bb00 <__avr32_udiv64+0x188>
8000b98a:	16 38       	cp.w	r8,r11
8000b98c:	e0 88 00 40 	brls	8000ba0c <__avr32_udiv64+0x94>
8000b990:	f0 08 12 00 	clz	r8,r8
8000b994:	c0 d0       	breq	8000b9ae <__avr32_udiv64+0x36>
8000b996:	f6 08 09 4b 	lsl	r11,r11,r8
8000b99a:	f0 09 11 20 	rsub	r9,r8,32
8000b99e:	f8 08 09 4c 	lsl	r12,r12,r8
8000b9a2:	f4 09 0a 49 	lsr	r9,r10,r9
8000b9a6:	f4 08 09 43 	lsl	r3,r10,r8
8000b9aa:	f3 eb 10 0b 	or	r11,r9,r11
8000b9ae:	f8 0e 16 10 	lsr	lr,r12,0x10
8000b9b2:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000b9b6:	f6 0e 0d 00 	divu	r0,r11,lr
8000b9ba:	e6 0b 16 10 	lsr	r11,r3,0x10
8000b9be:	00 99       	mov	r9,r0
8000b9c0:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000b9c4:	e0 0a 02 48 	mul	r8,r0,r10
8000b9c8:	10 3b       	cp.w	r11,r8
8000b9ca:	c0 a2       	brcc	8000b9de <__avr32_udiv64+0x66>
8000b9cc:	20 19       	sub	r9,1
8000b9ce:	18 0b       	add	r11,r12
8000b9d0:	18 3b       	cp.w	r11,r12
8000b9d2:	c0 63       	brcs	8000b9de <__avr32_udiv64+0x66>
8000b9d4:	10 3b       	cp.w	r11,r8
8000b9d6:	f7 b9 03 01 	sublo	r9,1
8000b9da:	f7 dc e3 0b 	addcs	r11,r11,r12
8000b9de:	f6 08 01 01 	sub	r1,r11,r8
8000b9e2:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000b9e6:	e2 0e 0d 00 	divu	r0,r1,lr
8000b9ea:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000b9ee:	00 98       	mov	r8,r0
8000b9f0:	e0 0a 02 4a 	mul	r10,r0,r10
8000b9f4:	14 33       	cp.w	r3,r10
8000b9f6:	c0 82       	brcc	8000ba06 <__avr32_udiv64+0x8e>
8000b9f8:	20 18       	sub	r8,1
8000b9fa:	18 03       	add	r3,r12
8000b9fc:	18 33       	cp.w	r3,r12
8000b9fe:	c0 43       	brcs	8000ba06 <__avr32_udiv64+0x8e>
8000ba00:	14 33       	cp.w	r3,r10
8000ba02:	f7 b8 03 01 	sublo	r8,1
8000ba06:	f1 e9 11 08 	or	r8,r8,r9<<0x10
8000ba0a:	cd f8       	rjmp	8000bbc8 <__avr32_udiv64+0x250>
8000ba0c:	58 08       	cp.w	r8,0
8000ba0e:	c0 51       	brne	8000ba18 <__avr32_udiv64+0xa0>
8000ba10:	30 19       	mov	r9,1
8000ba12:	f2 08 0d 08 	divu	r8,r9,r8
8000ba16:	10 9c       	mov	r12,r8
8000ba18:	f8 06 12 00 	clz	r6,r12
8000ba1c:	c0 41       	brne	8000ba24 <__avr32_udiv64+0xac>
8000ba1e:	18 1b       	sub	r11,r12
8000ba20:	30 19       	mov	r9,1
8000ba22:	c4 08       	rjmp	8000baa2 <__avr32_udiv64+0x12a>
8000ba24:	ec 01 11 20 	rsub	r1,r6,32
8000ba28:	f4 01 0a 49 	lsr	r9,r10,r1
8000ba2c:	f8 06 09 4c 	lsl	r12,r12,r6
8000ba30:	f6 06 09 48 	lsl	r8,r11,r6
8000ba34:	f6 01 0a 41 	lsr	r1,r11,r1
8000ba38:	f3 e8 10 08 	or	r8,r9,r8
8000ba3c:	f8 03 16 10 	lsr	r3,r12,0x10
8000ba40:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000ba44:	e2 03 0d 00 	divu	r0,r1,r3
8000ba48:	f0 0b 16 10 	lsr	r11,r8,0x10
8000ba4c:	00 9e       	mov	lr,r0
8000ba4e:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000ba52:	e0 05 02 49 	mul	r9,r0,r5
8000ba56:	12 3b       	cp.w	r11,r9
8000ba58:	c0 a2       	brcc	8000ba6c <__avr32_udiv64+0xf4>
8000ba5a:	20 1e       	sub	lr,1
8000ba5c:	18 0b       	add	r11,r12
8000ba5e:	18 3b       	cp.w	r11,r12
8000ba60:	c0 63       	brcs	8000ba6c <__avr32_udiv64+0xf4>
8000ba62:	12 3b       	cp.w	r11,r9
8000ba64:	f7 be 03 01 	sublo	lr,1
8000ba68:	f7 dc e3 0b 	addcs	r11,r11,r12
8000ba6c:	12 1b       	sub	r11,r9
8000ba6e:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
8000ba72:	f6 03 0d 02 	divu	r2,r11,r3
8000ba76:	f1 e3 11 08 	or	r8,r8,r3<<0x10
8000ba7a:	04 99       	mov	r9,r2
8000ba7c:	e4 05 02 4b 	mul	r11,r2,r5
8000ba80:	16 38       	cp.w	r8,r11
8000ba82:	c0 a2       	brcc	8000ba96 <__avr32_udiv64+0x11e>
8000ba84:	20 19       	sub	r9,1
8000ba86:	18 08       	add	r8,r12
8000ba88:	18 38       	cp.w	r8,r12
8000ba8a:	c0 63       	brcs	8000ba96 <__avr32_udiv64+0x11e>
8000ba8c:	16 38       	cp.w	r8,r11
8000ba8e:	f7 b9 03 01 	sublo	r9,1
8000ba92:	f1 dc e3 08 	addcs	r8,r8,r12
8000ba96:	f4 06 09 43 	lsl	r3,r10,r6
8000ba9a:	f0 0b 01 0b 	sub	r11,r8,r11
8000ba9e:	f3 ee 11 09 	or	r9,r9,lr<<0x10
8000baa2:	f8 06 16 10 	lsr	r6,r12,0x10
8000baa6:	fd dc c0 10 	bfextu	lr,r12,0x0,0x10
8000baaa:	f6 06 0d 00 	divu	r0,r11,r6
8000baae:	e6 0b 16 10 	lsr	r11,r3,0x10
8000bab2:	00 9a       	mov	r10,r0
8000bab4:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000bab8:	e0 0e 02 48 	mul	r8,r0,lr
8000babc:	10 3b       	cp.w	r11,r8
8000babe:	c0 a2       	brcc	8000bad2 <__avr32_udiv64+0x15a>
8000bac0:	20 1a       	sub	r10,1
8000bac2:	18 0b       	add	r11,r12
8000bac4:	18 3b       	cp.w	r11,r12
8000bac6:	c0 63       	brcs	8000bad2 <__avr32_udiv64+0x15a>
8000bac8:	10 3b       	cp.w	r11,r8
8000baca:	f7 ba 03 01 	sublo	r10,1
8000bace:	f7 dc e3 0b 	addcs	r11,r11,r12
8000bad2:	f6 08 01 01 	sub	r1,r11,r8
8000bad6:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000bada:	e2 06 0d 00 	divu	r0,r1,r6
8000bade:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000bae2:	00 98       	mov	r8,r0
8000bae4:	e0 0e 02 4b 	mul	r11,r0,lr
8000bae8:	16 33       	cp.w	r3,r11
8000baea:	c0 82       	brcc	8000bafa <__avr32_udiv64+0x182>
8000baec:	20 18       	sub	r8,1
8000baee:	18 03       	add	r3,r12
8000baf0:	18 33       	cp.w	r3,r12
8000baf2:	c0 43       	brcs	8000bafa <__avr32_udiv64+0x182>
8000baf4:	16 33       	cp.w	r3,r11
8000baf6:	f7 b8 03 01 	sublo	r8,1
8000bafa:	f1 ea 11 08 	or	r8,r8,r10<<0x10
8000bafe:	c6 98       	rjmp	8000bbd0 <__avr32_udiv64+0x258>
8000bb00:	16 39       	cp.w	r9,r11
8000bb02:	e0 8b 00 65 	brhi	8000bbcc <__avr32_udiv64+0x254>
8000bb06:	f2 09 12 00 	clz	r9,r9
8000bb0a:	c0 b1       	brne	8000bb20 <__avr32_udiv64+0x1a8>
8000bb0c:	10 3a       	cp.w	r10,r8
8000bb0e:	5f 2a       	srhs	r10
8000bb10:	1c 3b       	cp.w	r11,lr
8000bb12:	5f b8       	srhi	r8
8000bb14:	10 4a       	or	r10,r8
8000bb16:	f2 0a 18 00 	cp.b	r10,r9
8000bb1a:	c5 90       	breq	8000bbcc <__avr32_udiv64+0x254>
8000bb1c:	30 18       	mov	r8,1
8000bb1e:	c5 98       	rjmp	8000bbd0 <__avr32_udiv64+0x258>
8000bb20:	f0 09 09 46 	lsl	r6,r8,r9
8000bb24:	f2 03 11 20 	rsub	r3,r9,32
8000bb28:	fc 09 09 4e 	lsl	lr,lr,r9
8000bb2c:	f0 03 0a 48 	lsr	r8,r8,r3
8000bb30:	f6 09 09 4c 	lsl	r12,r11,r9
8000bb34:	f4 03 0a 42 	lsr	r2,r10,r3
8000bb38:	ef 46 ff f4 	st.w	r7[-12],r6
8000bb3c:	f6 03 0a 43 	lsr	r3,r11,r3
8000bb40:	18 42       	or	r2,r12
8000bb42:	f1 ee 10 0c 	or	r12,r8,lr
8000bb46:	f8 01 16 10 	lsr	r1,r12,0x10
8000bb4a:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000bb4e:	e6 01 0d 04 	divu	r4,r3,r1
8000bb52:	e4 03 16 10 	lsr	r3,r2,0x10
8000bb56:	08 9e       	mov	lr,r4
8000bb58:	e7 e5 11 03 	or	r3,r3,r5<<0x10
8000bb5c:	e8 06 02 48 	mul	r8,r4,r6
8000bb60:	10 33       	cp.w	r3,r8
8000bb62:	c0 a2       	brcc	8000bb76 <__avr32_udiv64+0x1fe>
8000bb64:	20 1e       	sub	lr,1
8000bb66:	18 03       	add	r3,r12
8000bb68:	18 33       	cp.w	r3,r12
8000bb6a:	c0 63       	brcs	8000bb76 <__avr32_udiv64+0x1fe>
8000bb6c:	10 33       	cp.w	r3,r8
8000bb6e:	f7 be 03 01 	sublo	lr,1
8000bb72:	e7 dc e3 03 	addcs	r3,r3,r12
8000bb76:	10 13       	sub	r3,r8
8000bb78:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
8000bb7c:	e6 01 0d 00 	divu	r0,r3,r1
8000bb80:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000bb84:	00 98       	mov	r8,r0
8000bb86:	e0 06 02 46 	mul	r6,r0,r6
8000bb8a:	0c 3b       	cp.w	r11,r6
8000bb8c:	c0 a2       	brcc	8000bba0 <__avr32_udiv64+0x228>
8000bb8e:	20 18       	sub	r8,1
8000bb90:	18 0b       	add	r11,r12
8000bb92:	18 3b       	cp.w	r11,r12
8000bb94:	c0 63       	brcs	8000bba0 <__avr32_udiv64+0x228>
8000bb96:	0c 3b       	cp.w	r11,r6
8000bb98:	f7 dc e3 0b 	addcs	r11,r11,r12
8000bb9c:	f7 b8 03 01 	sublo	r8,1
8000bba0:	f1 ee 11 08 	or	r8,r8,lr<<0x10
8000bba4:	ee f4 ff f4 	ld.w	r4,r7[-12]
8000bba8:	0c 1b       	sub	r11,r6
8000bbaa:	f0 04 06 42 	mulu.d	r2,r8,r4
8000bbae:	06 95       	mov	r5,r3
8000bbb0:	16 35       	cp.w	r5,r11
8000bbb2:	e0 8b 00 0a 	brhi	8000bbc6 <__avr32_udiv64+0x24e>
8000bbb6:	5f 0b       	sreq	r11
8000bbb8:	f4 09 09 49 	lsl	r9,r10,r9
8000bbbc:	12 32       	cp.w	r2,r9
8000bbbe:	5f b9       	srhi	r9
8000bbc0:	f7 e9 00 09 	and	r9,r11,r9
8000bbc4:	c0 60       	breq	8000bbd0 <__avr32_udiv64+0x258>
8000bbc6:	20 18       	sub	r8,1
8000bbc8:	30 09       	mov	r9,0
8000bbca:	c0 38       	rjmp	8000bbd0 <__avr32_udiv64+0x258>
8000bbcc:	30 09       	mov	r9,0
8000bbce:	12 98       	mov	r8,r9
8000bbd0:	10 9a       	mov	r10,r8
8000bbd2:	12 93       	mov	r3,r9
8000bbd4:	10 92       	mov	r2,r8
8000bbd6:	12 9b       	mov	r11,r9
8000bbd8:	2f dd       	sub	sp,-12
8000bbda:	d8 32       	popm	r0-r7,pc

8000bbdc <__avr32_umod64>:
8000bbdc:	d4 31       	pushm	r0-r7,lr
8000bbde:	1a 97       	mov	r7,sp
8000bbe0:	20 3d       	sub	sp,12
8000bbe2:	10 9c       	mov	r12,r8
8000bbe4:	12 95       	mov	r5,r9
8000bbe6:	14 9e       	mov	lr,r10
8000bbe8:	16 91       	mov	r1,r11
8000bbea:	16 96       	mov	r6,r11
8000bbec:	58 09       	cp.w	r9,0
8000bbee:	e0 81 00 81 	brne	8000bcf0 <__avr32_umod64+0x114>
8000bbf2:	16 38       	cp.w	r8,r11
8000bbf4:	e0 88 00 12 	brls	8000bc18 <__avr32_umod64+0x3c>
8000bbf8:	f0 08 12 00 	clz	r8,r8
8000bbfc:	c4 e0       	breq	8000bc98 <__avr32_umod64+0xbc>
8000bbfe:	f6 08 09 46 	lsl	r6,r11,r8
8000bc02:	f8 08 09 4c 	lsl	r12,r12,r8
8000bc06:	f0 0b 11 20 	rsub	r11,r8,32
8000bc0a:	f4 08 09 4e 	lsl	lr,r10,r8
8000bc0e:	f4 0b 0a 4b 	lsr	r11,r10,r11
8000bc12:	f7 e6 10 06 	or	r6,r11,r6
8000bc16:	c4 18       	rjmp	8000bc98 <__avr32_umod64+0xbc>
8000bc18:	58 08       	cp.w	r8,0
8000bc1a:	c0 51       	brne	8000bc24 <__avr32_umod64+0x48>
8000bc1c:	30 19       	mov	r9,1
8000bc1e:	f2 08 0d 08 	divu	r8,r9,r8
8000bc22:	10 9c       	mov	r12,r8
8000bc24:	f8 08 12 00 	clz	r8,r12
8000bc28:	c0 31       	brne	8000bc2e <__avr32_umod64+0x52>
8000bc2a:	18 16       	sub	r6,r12
8000bc2c:	c3 68       	rjmp	8000bc98 <__avr32_umod64+0xbc>
8000bc2e:	f0 03 11 20 	rsub	r3,r8,32
8000bc32:	f4 03 0a 4b 	lsr	r11,r10,r3
8000bc36:	f8 08 09 4c 	lsl	r12,r12,r8
8000bc3a:	ec 08 09 49 	lsl	r9,r6,r8
8000bc3e:	ec 03 0a 43 	lsr	r3,r6,r3
8000bc42:	f7 e9 10 09 	or	r9,r11,r9
8000bc46:	f8 05 16 10 	lsr	r5,r12,0x10
8000bc4a:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000bc4e:	e6 05 0d 02 	divu	r2,r3,r5
8000bc52:	f2 0e 16 10 	lsr	lr,r9,0x10
8000bc56:	ec 02 02 4b 	mul	r11,r6,r2
8000bc5a:	fd e3 11 0e 	or	lr,lr,r3<<0x10
8000bc5e:	16 3e       	cp.w	lr,r11
8000bc60:	c0 72       	brcc	8000bc6e <__avr32_umod64+0x92>
8000bc62:	18 0e       	add	lr,r12
8000bc64:	18 3e       	cp.w	lr,r12
8000bc66:	c0 43       	brcs	8000bc6e <__avr32_umod64+0x92>
8000bc68:	16 3e       	cp.w	lr,r11
8000bc6a:	fd dc e3 0e 	addcs	lr,lr,r12
8000bc6e:	fc 0b 01 03 	sub	r3,lr,r11
8000bc72:	f3 d9 c0 10 	bfextu	r9,r9,0x0,0x10
8000bc76:	e6 05 0d 02 	divu	r2,r3,r5
8000bc7a:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000bc7e:	a5 36       	mul	r6,r2
8000bc80:	0c 39       	cp.w	r9,r6
8000bc82:	c0 72       	brcc	8000bc90 <__avr32_umod64+0xb4>
8000bc84:	18 09       	add	r9,r12
8000bc86:	18 39       	cp.w	r9,r12
8000bc88:	c0 43       	brcs	8000bc90 <__avr32_umod64+0xb4>
8000bc8a:	0c 39       	cp.w	r9,r6
8000bc8c:	f3 dc e3 09 	addcs	r9,r9,r12
8000bc90:	f2 06 01 06 	sub	r6,r9,r6
8000bc94:	f4 08 09 4e 	lsl	lr,r10,r8
8000bc98:	f8 0a 16 10 	lsr	r10,r12,0x10
8000bc9c:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000bca0:	ec 0a 0d 02 	divu	r2,r6,r10
8000bca4:	fc 09 16 10 	lsr	r9,lr,0x10
8000bca8:	ea 02 02 4b 	mul	r11,r5,r2
8000bcac:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000bcb0:	16 39       	cp.w	r9,r11
8000bcb2:	c0 72       	brcc	8000bcc0 <__avr32_umod64+0xe4>
8000bcb4:	18 09       	add	r9,r12
8000bcb6:	18 39       	cp.w	r9,r12
8000bcb8:	c0 43       	brcs	8000bcc0 <__avr32_umod64+0xe4>
8000bcba:	16 39       	cp.w	r9,r11
8000bcbc:	f3 dc e3 09 	addcs	r9,r9,r12
8000bcc0:	f2 0b 01 0b 	sub	r11,r9,r11
8000bcc4:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000bcc8:	f6 0a 0d 0a 	divu	r10,r11,r10
8000bccc:	fd eb 11 0e 	or	lr,lr,r11<<0x10
8000bcd0:	ea 0a 02 4a 	mul	r10,r5,r10
8000bcd4:	14 3e       	cp.w	lr,r10
8000bcd6:	c0 72       	brcc	8000bce4 <__avr32_umod64+0x108>
8000bcd8:	18 0e       	add	lr,r12
8000bcda:	18 3e       	cp.w	lr,r12
8000bcdc:	c0 43       	brcs	8000bce4 <__avr32_umod64+0x108>
8000bcde:	14 3e       	cp.w	lr,r10
8000bce0:	fd dc e3 0e 	addcs	lr,lr,r12
8000bce4:	fc 0a 01 0a 	sub	r10,lr,r10
8000bce8:	30 0b       	mov	r11,0
8000bcea:	f4 08 0a 4a 	lsr	r10,r10,r8
8000bcee:	c7 b8       	rjmp	8000bde4 <__avr32_umod64+0x208>
8000bcf0:	16 39       	cp.w	r9,r11
8000bcf2:	e0 8b 00 79 	brhi	8000bde4 <__avr32_umod64+0x208>
8000bcf6:	f2 09 12 00 	clz	r9,r9
8000bcfa:	c1 21       	brne	8000bd1e <__avr32_umod64+0x142>
8000bcfc:	10 3a       	cp.w	r10,r8
8000bcfe:	5f 2b       	srhs	r11
8000bd00:	0a 31       	cp.w	r1,r5
8000bd02:	5f ba       	srhi	r10
8000bd04:	f7 ea 10 0a 	or	r10,r11,r10
8000bd08:	f2 0a 18 00 	cp.b	r10,r9
8000bd0c:	c0 60       	breq	8000bd18 <__avr32_umod64+0x13c>
8000bd0e:	fc 08 01 0c 	sub	r12,lr,r8
8000bd12:	e2 05 01 46 	sbc	r6,r1,r5
8000bd16:	18 9e       	mov	lr,r12
8000bd18:	0c 9b       	mov	r11,r6
8000bd1a:	1c 9a       	mov	r10,lr
8000bd1c:	c6 48       	rjmp	8000bde4 <__avr32_umod64+0x208>
8000bd1e:	ea 09 09 4c 	lsl	r12,r5,r9
8000bd22:	f2 06 11 20 	rsub	r6,r9,32
8000bd26:	f6 09 09 4b 	lsl	r11,r11,r9
8000bd2a:	f0 09 09 42 	lsl	r2,r8,r9
8000bd2e:	ef 46 ff f4 	st.w	r7[-12],r6
8000bd32:	f0 06 0a 48 	lsr	r8,r8,r6
8000bd36:	18 48       	or	r8,r12
8000bd38:	e2 06 0a 4c 	lsr	r12,r1,r6
8000bd3c:	f4 09 09 43 	lsl	r3,r10,r9
8000bd40:	fd d8 c0 10 	bfextu	lr,r8,0x0,0x10
8000bd44:	f4 06 0a 4a 	lsr	r10,r10,r6
8000bd48:	16 4a       	or	r10,r11
8000bd4a:	f0 0b 16 10 	lsr	r11,r8,0x10
8000bd4e:	f8 0b 0d 04 	divu	r4,r12,r11
8000bd52:	f4 0c 16 10 	lsr	r12,r10,0x10
8000bd56:	08 91       	mov	r1,r4
8000bd58:	f9 e5 11 0c 	or	r12,r12,r5<<0x10
8000bd5c:	e8 0e 02 46 	mul	r6,r4,lr
8000bd60:	0c 3c       	cp.w	r12,r6
8000bd62:	c0 a2       	brcc	8000bd76 <__avr32_umod64+0x19a>
8000bd64:	20 11       	sub	r1,1
8000bd66:	10 0c       	add	r12,r8
8000bd68:	10 3c       	cp.w	r12,r8
8000bd6a:	c0 63       	brcs	8000bd76 <__avr32_umod64+0x19a>
8000bd6c:	0c 3c       	cp.w	r12,r6
8000bd6e:	f7 b1 03 01 	sublo	r1,1
8000bd72:	f9 d8 e3 0c 	addcs	r12,r12,r8
8000bd76:	0c 1c       	sub	r12,r6
8000bd78:	f5 da c0 10 	bfextu	r10,r10,0x0,0x10
8000bd7c:	f8 0b 0d 04 	divu	r4,r12,r11
8000bd80:	f5 e5 11 0b 	or	r11,r10,r5<<0x10
8000bd84:	08 96       	mov	r6,r4
8000bd86:	e8 0e 02 4e 	mul	lr,r4,lr
8000bd8a:	1c 3b       	cp.w	r11,lr
8000bd8c:	c0 a2       	brcc	8000bda0 <__avr32_umod64+0x1c4>
8000bd8e:	20 16       	sub	r6,1
8000bd90:	10 0b       	add	r11,r8
8000bd92:	10 3b       	cp.w	r11,r8
8000bd94:	c0 63       	brcs	8000bda0 <__avr32_umod64+0x1c4>
8000bd96:	1c 3b       	cp.w	r11,lr
8000bd98:	f7 b6 03 01 	sublo	r6,1
8000bd9c:	f7 d8 e3 0b 	addcs	r11,r11,r8
8000bda0:	ed e1 11 01 	or	r1,r6,r1<<0x10
8000bda4:	1c 1b       	sub	r11,lr
8000bda6:	e2 02 06 40 	mulu.d	r0,r1,r2
8000bdaa:	00 9e       	mov	lr,r0
8000bdac:	02 9c       	mov	r12,r1
8000bdae:	16 3c       	cp.w	r12,r11
8000bdb0:	e0 8b 00 08 	brhi	8000bdc0 <__avr32_umod64+0x1e4>
8000bdb4:	5f 06       	sreq	r6
8000bdb6:	06 30       	cp.w	r0,r3
8000bdb8:	5f ba       	srhi	r10
8000bdba:	ed ea 00 0a 	and	r10,r6,r10
8000bdbe:	c0 60       	breq	8000bdca <__avr32_umod64+0x1ee>
8000bdc0:	fc 02 01 04 	sub	r4,lr,r2
8000bdc4:	f8 08 01 4c 	sbc	r12,r12,r8
8000bdc8:	08 9e       	mov	lr,r4
8000bdca:	e6 0e 01 0a 	sub	r10,r3,lr
8000bdce:	f6 0c 01 4c 	sbc	r12,r11,r12
8000bdd2:	ee f1 ff f4 	ld.w	r1,r7[-12]
8000bdd6:	f8 09 0a 4b 	lsr	r11,r12,r9
8000bdda:	f4 09 0a 4a 	lsr	r10,r10,r9
8000bdde:	f8 01 09 4c 	lsl	r12,r12,r1
8000bde2:	18 4a       	or	r10,r12
8000bde4:	2f dd       	sub	sp,-12
8000bde6:	d8 32       	popm	r0-r7,pc

Disassembly of section .exception:

8000be00 <_evba>:
_evba:

        .org  0x000
        // Unrecoverable Exception.
_handle_Unrecoverable_Exception:
        rjmp $
8000be00:	c0 08       	rjmp	8000be00 <_evba>
	...

8000be04 <_handle_TLB_Multiple_Hit>:

        .org  0x004
        // TLB Multiple Hit: UNUSED IN AVR32UC.
_handle_TLB_Multiple_Hit:
        rjmp $
8000be04:	c0 08       	rjmp	8000be04 <_handle_TLB_Multiple_Hit>
	...

8000be08 <_handle_Bus_Error_Data_Fetch>:

        .org  0x008
        // Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
        rjmp $
8000be08:	c0 08       	rjmp	8000be08 <_handle_Bus_Error_Data_Fetch>
	...

8000be0c <_handle_Bus_Error_Instruction_Fetch>:

        .org  0x00C
         // Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
        rjmp $
8000be0c:	c0 08       	rjmp	8000be0c <_handle_Bus_Error_Instruction_Fetch>
	...

8000be10 <_handle_NMI>:

        .org  0x010
        // NMI.
_handle_NMI:
        rjmp $
8000be10:	c0 08       	rjmp	8000be10 <_handle_NMI>
	...

8000be14 <_handle_Instruction_Address>:

        .org  0x014
        // Instruction Address.
_handle_Instruction_Address:
        rjmp $
8000be14:	c0 08       	rjmp	8000be14 <_handle_Instruction_Address>
	...

8000be18 <_handle_ITLB_Protection>:

        .org  0x018
        // ITLB Protection.
_handle_ITLB_Protection:
        rjmp $
8000be18:	c0 08       	rjmp	8000be18 <_handle_ITLB_Protection>
	...

8000be1c <_handle_Breakpoint>:

        .org  0x01C
        // Breakpoint.
_handle_Breakpoint:
        rjmp $
8000be1c:	c0 08       	rjmp	8000be1c <_handle_Breakpoint>
	...

8000be20 <_handle_Illegal_Opcode>:

        .org  0x020
        // Illegal Opcode.
_handle_Illegal_Opcode:
        rjmp $
8000be20:	c0 08       	rjmp	8000be20 <_handle_Illegal_Opcode>
	...

8000be24 <_handle_Unimplemented_Instruction>:

        .org  0x024
        // Unimplemented Instruction.
_handle_Unimplemented_Instruction:
        rjmp $
8000be24:	c0 08       	rjmp	8000be24 <_handle_Unimplemented_Instruction>
	...

8000be28 <_handle_Privilege_Violation>:

        .org  0x028
        // Privilege Violation.
_handle_Privilege_Violation:
        rjmp $
8000be28:	c0 08       	rjmp	8000be28 <_handle_Privilege_Violation>
	...

8000be2c <_handle_Floating_Point>:

        .org  0x02C
        // Floating-Point: UNUSED IN AVR32UC.
_handle_Floating_Point:
        rjmp $
8000be2c:	c0 08       	rjmp	8000be2c <_handle_Floating_Point>
	...

8000be30 <_handle_Coprocessor_Absent>:

        .org  0x030
        // Coprocessor Absent: UNUSED IN AVR32UC.
_handle_Coprocessor_Absent:
        rjmp $
8000be30:	c0 08       	rjmp	8000be30 <_handle_Coprocessor_Absent>
	...

8000be34 <_handle_Data_Address_Read>:

        .org  0x034
        // Data Address (Read).
_handle_Data_Address_Read:
        rjmp $
8000be34:	c0 08       	rjmp	8000be34 <_handle_Data_Address_Read>
	...

8000be38 <_handle_Data_Address_Write>:

        .org  0x038
        // Data Address (Write).
_handle_Data_Address_Write:
        rjmp $
8000be38:	c0 08       	rjmp	8000be38 <_handle_Data_Address_Write>
	...

8000be3c <_handle_DTLB_Protection_Read>:

        .org  0x03C
        // DTLB Protection (Read).
_handle_DTLB_Protection_Read:
        rjmp $
8000be3c:	c0 08       	rjmp	8000be3c <_handle_DTLB_Protection_Read>
	...

8000be40 <_handle_DTLB_Protection_Write>:

        .org  0x040
        // DTLB Protection (Write).
_handle_DTLB_Protection_Write:
        rjmp $
8000be40:	c0 08       	rjmp	8000be40 <_handle_DTLB_Protection_Write>
	...

8000be44 <_handle_DTLB_Modified>:

        .org  0x044
        // DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
        rjmp $
8000be44:	c0 08       	rjmp	8000be44 <_handle_DTLB_Modified>
	...

8000be50 <_handle_ITLB_Miss>:

        .org  0x050
        // ITLB Miss: UNUSED IN AVR32UC.
_handle_ITLB_Miss:
        rjmp $
8000be50:	c0 08       	rjmp	8000be50 <_handle_ITLB_Miss>
	...

8000be60 <_handle_DTLB_Miss_Read>:

        .org  0x060
        // DTLB Miss (Read): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Read:
        rjmp $
8000be60:	c0 08       	rjmp	8000be60 <_handle_DTLB_Miss_Read>
	...

8000be70 <_handle_DTLB_Miss_Write>:

        .org  0x070
        // DTLB Miss (Write): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Write:
        rjmp $
8000be70:	c0 08       	rjmp	8000be70 <_handle_DTLB_Miss_Write>
	...

8000bf00 <_handle_Supervisor_Call>:

        .org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
8000bf00:	fe cf 6f ec 	sub	pc,pc,28652

8000bf04 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
8000bf04:	30 0c       	mov	r12,0
8000bf06:	fe b0 c5 23 	rcall	8000494c <_get_interrupt_handler>
8000bf0a:	58 0c       	cp.w	r12,0
8000bf0c:	f8 0f 17 10 	movne	pc,r12
8000bf10:	d6 03       	rete

8000bf12 <_int1>:
8000bf12:	30 1c       	mov	r12,1
8000bf14:	fe b0 c5 1c 	rcall	8000494c <_get_interrupt_handler>
8000bf18:	58 0c       	cp.w	r12,0
8000bf1a:	f8 0f 17 10 	movne	pc,r12
8000bf1e:	d6 03       	rete

8000bf20 <_int2>:
8000bf20:	30 2c       	mov	r12,2
8000bf22:	fe b0 c5 15 	rcall	8000494c <_get_interrupt_handler>
8000bf26:	58 0c       	cp.w	r12,0
8000bf28:	f8 0f 17 10 	movne	pc,r12
8000bf2c:	d6 03       	rete

8000bf2e <_int3>:
8000bf2e:	30 3c       	mov	r12,3
8000bf30:	fe b0 c5 0e 	rcall	8000494c <_get_interrupt_handler>
8000bf34:	58 0c       	cp.w	r12,0
8000bf36:	f8 0f 17 10 	movne	pc,r12
8000bf3a:	d6 03       	rete

8000bf3c <ipr_val>:
8000bf3c:	00 00 01 04 40 00 01 12 80 00 01 20 c0 00 01 2e     ....@...... ....
8000bf4c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bf5c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bf6c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bf7c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bf8c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bf9c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bfac:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bfbc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bfcc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bfdc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bfec:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bffc:	d7 03 d7 03                                         ....
