
moto_gob_prj.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002008  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80002008  80002008  00002408  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         0000abbc  80002008  80002008  00002408  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  8000cc00  8000cc00  0000d000  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       000017b0  8000ce00  8000ce00  0000d200  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .dalign       00000004  00000004  00000004  00000000  2**0
                  ALLOC
  6 .data         00000a38  00000008  8000e5b0  0000ec08  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .bss          00005960  00000a40  00000a40  00000000  2**2
                  ALLOC
  8 .heap         00010c60  000063a0  000063a0  00000000  2**0
                  ALLOC
  9 .comment      00000030  00000000  00000000  0000f640  2**0
                  CONTENTS, READONLY
 10 .debug_aranges 00001270  00000000  00000000  0000f670  2**3
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_pubnames 0000282f  00000000  00000000  000108e0  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_info   0002a22a  00000000  00000000  0001310f  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_abbrev 00006e63  00000000  00000000  0003d339  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_line   000160bf  00000000  00000000  0004419c  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_frame  0000302c  00000000  00000000  0005a25c  2**2
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_str    000075c7  00000000  00000000  0005d288  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_loc    0000d45f  00000000  00000000  0006484f  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_macinfo 015f3991  00000000  00000000  00071cae  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .stack        00001000  00017000  00017000  00000000  2**0
                  ALLOC
 20 .debug_ranges 00001340  00000000  00000000  01665640  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_start>:

  .global _start
  .type _start, @function
_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80000000:	fe cf 8d 84 	sub	pc,pc,-29308

80000004 <_trampoline>:
80000004:	e0 8f 10 00 	bral	80002004 <program_start>
	...

80002004 <program_start>:
  rjmp    program_start

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002004:	fe cf ad 88 	sub	pc,pc,-21112

Disassembly of section .text:

80002008 <DeviceManagement_brdcst_func>:
80002008:	19 a9       	ld.ub	r9,r12[0x2]
8000200a:	30 18       	mov	r8,1
		U8 temp = 0;
		temp  = xcmp->u8[1] << 8;
		temp |= xcmp->u8[2];
		//if (temp == theXNL_Ctrlr.XNL_DeviceLogicalAddress)
		{
			if (xcmp->u8[0] == 0x01)
8000200c:	f0 09 18 00 	cp.b	r9,r8
80002010:	c0 61       	brne	8000201c <DeviceManagement_brdcst_func+0x14>
			{
				bunchofrandomstatusflags |= 0x00000002;
80002012:	48 68       	lddpc	r8,80002028 <DeviceManagement_brdcst_func+0x20>
80002014:	70 09       	ld.w	r9,r8[0x0]
80002016:	a1 b9       	sbr	r9,0x1
80002018:	91 09       	st.w	r8[0x0],r9
8000201a:	5e fc       	retal	r12
			}
			else
			{
				bunchofrandomstatusflags &= 0xFFFFFFFD;
8000201c:	48 38       	lddpc	r8,80002028 <DeviceManagement_brdcst_func+0x20>
8000201e:	70 09       	ld.w	r9,r8[0x0]
80002020:	a1 d9       	cbr	r9,0x1
80002022:	91 09       	st.w	r8[0x0],r9
80002024:	5e fc       	retal	r12
80002026:	00 00       	add	r0,r0
80002028:	00 00       	add	r0,r0
8000202a:	0d 88       	ld.ub	r8,r6[0x0]

8000202c <Volume_brdcst_func>:
	//log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
	
	//log("\n\r Audio_Parameter: %x \n\r", ptr->Audio_Parameter);
	
	
}
8000202c:	5e fc       	retal	r12

8000202e <AudioRoutingControl_brdcst_func>:
	//
	//log("\n\r Audio-Function: %x \n\r", xcmp->u8[3+j*2-1]);
	
	
	
}
8000202e:	5e fc       	retal	r12

80002030 <vApplicationIdleHook>:
}

void vApplicationIdleHook( void )
{
	/* This hook function does nothing but increment a counter. */
	ulIdleCycleCount++;
80002030:	48 38       	lddpc	r8,8000203c <vApplicationIdleHook+0xc>
80002032:	70 09       	ld.w	r9,r8[0x0]
80002034:	2f f9       	sub	r9,-1
80002036:	91 09       	st.w	r8[0x0],r9
	
}
80002038:	5e fc       	retal	r12
8000203a:	00 00       	add	r0,r0
8000203c:	00 00       	add	r0,r0
8000203e:	0a 5c       	eor	r12,r5

80002040 <app_init>:
														
		
};

void app_init(void)
{	
80002040:	d4 01       	pushm	lr
	//将app_payload_rx_proc更改为PCM加密功能
	payload_init( app_payload_rx_proc , app_payload_tx_proc );	
80002042:	48 cb       	lddpc	r11,80002070 <app_init+0x30>
80002044:	48 cc       	lddpc	r12,80002074 <app_init+0x34>
80002046:	f0 1f 00 0d 	mcall	80002078 <app_init+0x38>
	xcmp_register_app_list(the_app_list);
8000204a:	48 dc       	lddpc	r12,8000207c <app_init+0x3c>
8000204c:	f0 1f 00 0d 	mcall	80002080 <app_init+0x40>
			
	static portBASE_TYPE res = 0;
	 res = xTaskCreate(
80002050:	30 09       	mov	r9,0
80002052:	1a d9       	st.w	--sp,r9
80002054:	1a d9       	st.w	--sp,r9
80002056:	1a d9       	st.w	--sp,r9
80002058:	30 18       	mov	r8,1
8000205a:	e0 6a 01 80 	mov	r10,384
8000205e:	48 ab       	lddpc	r11,80002084 <app_init+0x44>
80002060:	48 ac       	lddpc	r12,80002088 <app_init+0x48>
80002062:	f0 1f 00 0b 	mcall	8000208c <app_init+0x4c>
80002066:	48 b8       	lddpc	r8,80002090 <app_init+0x50>
80002068:	91 0c       	st.w	r8[0x0],r12
8000206a:	2f dd       	sub	sp,-12
	,  NULL
	,  1
	,  NULL );
	
	
}
8000206c:	d8 02       	popm	pc
8000206e:	00 00       	add	r0,r0
80002070:	80 00       	ld.sh	r0,r0[0x0]
80002072:	20 94       	sub	r4,9
80002074:	80 00       	ld.sh	r0,r0[0x0]
80002076:	28 64       	sub	r4,-122
80002078:	80 00       	ld.sh	r0,r0[0x0]
8000207a:	2f 28       	sub	r8,-14
8000207c:	00 00       	add	r0,r0
8000207e:	00 08       	add	r8,r0
80002080:	80 00       	ld.sh	r0,r0[0x0]
80002082:	44 a8       	lddsp	r8,sp[0x128]
80002084:	80 00       	ld.sh	r0,r0[0x0]
80002086:	ce 00       	breq	80002046 <app_init+0x6>
80002088:	80 00       	ld.sh	r0,r0[0x0]
8000208a:	27 bc       	sub	r12,123
8000208c:	80 00       	ld.sh	r0,r0[0x0]
8000208e:	69 bc       	ld.w	r12,r4[0x6c]
80002090:	00 00       	add	r0,r0
80002092:	0a 4c       	or	r12,r5

80002094 <app_payload_tx_proc>:

}


static void app_payload_tx_proc(void  * payload)
{
80002094:	d4 01       	pushm	lr
  log("R");
80002096:	48 3c       	lddpc	r12,800020a0 <app_payload_tx_proc+0xc>
80002098:	f0 1f 00 03 	mcall	800020a4 <app_payload_tx_proc+0x10>
  //
  //
  //set_payload_idle(payload);


}
8000209c:	d8 02       	popm	pc
8000209e:	00 00       	add	r0,r0
800020a0:	80 00       	ld.sh	r0,r0[0x0]
800020a2:	ce 08       	rjmp	80002262 <Phyuserinput_brdcst_func+0x2>
800020a4:	80 00       	ld.sh	r0,r0[0x0]
800020a6:	6d 80       	ld.w	r0,r6[0x60]

800020a8 <FD_brdcst_func>:
	
	
}

void FD_brdcst_func(xcmp_fragment_t * xcmp)
{
800020a8:	d4 01       	pushm	lr
	
	
	log("\n\r Forward Data Broadcast \n\r");
800020aa:	48 3c       	lddpc	r12,800020b4 <FD_brdcst_func+0xc>
800020ac:	f0 1f 00 03 	mcall	800020b8 <FD_brdcst_func+0x10>
	
}
800020b0:	d8 02       	popm	pc
800020b2:	00 00       	add	r0,r0
800020b4:	80 00       	ld.sh	r0,r0[0x0]
800020b6:	ce 0c       	rcall	80002276 <Phyuserinput_brdcst_func+0x16>
800020b8:	80 00       	ld.sh	r0,r0[0x0]
800020ba:	6d 80       	ld.w	r0,r6[0x60]

800020bc <FD_reply_func>:
	
	
}

void FD_reply_func(xcmp_fragment_t * xcmp)
{
800020bc:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Reply \n\r");
800020be:	48 3c       	lddpc	r12,800020c8 <FD_reply_func+0xc>
800020c0:	f0 1f 00 03 	mcall	800020cc <FD_reply_func+0x10>
	
	
}
800020c4:	d8 02       	popm	pc
800020c6:	00 00       	add	r0,r0
800020c8:	80 00       	ld.sh	r0,r0[0x0]
800020ca:	ce 2c       	rcall	8000228e <Phyuserinput_brdcst_func+0x2e>
800020cc:	80 00       	ld.sh	r0,r0[0x0]
800020ce:	6d 80       	ld.w	r0,r6[0x60]

800020d0 <FD_request_func>:
}



void FD_request_func(xcmp_fragment_t * xcmp)
{
800020d0:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Request \n\r");
800020d2:	48 3c       	lddpc	r12,800020dc <FD_request_func+0xc>
800020d4:	f0 1f 00 03 	mcall	800020e0 <FD_request_func+0x10>
	
	
}
800020d8:	d8 02       	popm	pc
800020da:	00 00       	add	r0,r0
800020dc:	80 00       	ld.sh	r0,r0[0x0]
800020de:	ce 48       	rjmp	800022a6 <Phyuserinput_brdcst_func+0x46>
800020e0:	80 00       	ld.sh	r0,r0[0x0]
800020e2:	6d 80       	ld.w	r0,r6[0x60]

800020e4 <EnOB_brdcst_func>:
	
	
}

void EnOB_brdcst_func(xcmp_fragment_t * xcmp)
{
800020e4:	d4 01       	pushm	lr
	
	
	log("\n\r En_OB Broadcast \n\r");
800020e6:	48 3c       	lddpc	r12,800020f0 <EnOB_brdcst_func+0xc>
800020e8:	f0 1f 00 03 	mcall	800020f4 <EnOB_brdcst_func+0x10>
}
800020ec:	d8 02       	popm	pc
800020ee:	00 00       	add	r0,r0
800020f0:	80 00       	ld.sh	r0,r0[0x0]
800020f2:	ce 64       	brge	800020be <FD_reply_func+0x2>
800020f4:	80 00       	ld.sh	r0,r0[0x0]
800020f6:	6d 80       	ld.w	r0,r6[0x60]

800020f8 <EnOB_reply_func>:
}



void EnOB_reply_func(xcmp_fragment_t * xcmp)
{
800020f8:	eb cd 40 80 	pushm	r7,lr
800020fc:	18 97       	mov	r7,r12
		/*point to xcmp payload*/
	//En_OB_Control_reply_t *ptr = (En_OB_Control_reply_t* )xcmp->u8;
	//log("\n\r Xcmp_opcode: %x \n\r", xcmp->xcmp_opcode);
	
	if (xcmp->u8[0]== xcmp_Res_Success)
800020fe:	19 a9       	ld.ub	r9,r12[0x2]
80002100:	30 08       	mov	r8,0
80002102:	f0 09 18 00 	cp.b	r9,r8
80002106:	c1 91       	brne	80002138 <EnOB_reply_func+0x40>
	{
		if (xcmp->u8[1] == EN_OB_Enter)
80002108:	19 b8       	ld.ub	r8,r12[0x3]
8000210a:	30 19       	mov	r9,1
8000210c:	f2 08 18 00 	cp.b	r8,r9
80002110:	c0 61       	brne	8000211c <EnOB_reply_func+0x24>
		{
		
			log("\n\r En_OB_Enter OK \n\r");
80002112:	49 0c       	lddpc	r12,80002150 <EnOB_reply_func+0x58>
80002114:	f0 1f 00 10 	mcall	80002154 <EnOB_reply_func+0x5c>
80002118:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else if (xcmp->u8[1] == EN_OB_Exit )
8000211c:	58 08       	cp.w	r8,0
8000211e:	c0 61       	brne	8000212a <EnOB_reply_func+0x32>
		{
			log("\n\r En_OB_Exit OK \n\r");
80002120:	48 ec       	lddpc	r12,80002158 <EnOB_reply_func+0x60>
80002122:	f0 1f 00 0d 	mcall	80002154 <EnOB_reply_func+0x5c>
80002126:	e3 cd 80 80 	ldm	sp++,r7,pc
		}
		else
		{
			
			log("\n\r En_OB_Control: %x \n\r", xcmp->u8[1]);
8000212a:	1a d8       	st.w	--sp,r8
8000212c:	48 cc       	lddpc	r12,8000215c <EnOB_reply_func+0x64>
8000212e:	f0 1f 00 0a 	mcall	80002154 <EnOB_reply_func+0x5c>
80002132:	2f fd       	sub	sp,-4
80002134:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r En_OB_Control error \n\r");
80002138:	48 ac       	lddpc	r12,80002160 <EnOB_reply_func+0x68>
8000213a:	f0 1f 00 07 	mcall	80002154 <EnOB_reply_func+0x5c>
		log("\n\r En_OB_result: %x \n\r", xcmp->u8[0]);
8000213e:	0f a8       	ld.ub	r8,r7[0x2]
80002140:	1a d8       	st.w	--sp,r8
80002142:	48 9c       	lddpc	r12,80002164 <EnOB_reply_func+0x6c>
80002144:	f0 1f 00 04 	mcall	80002154 <EnOB_reply_func+0x5c>
80002148:	2f fd       	sub	sp,-4
8000214a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000214e:	00 00       	add	r0,r0
80002150:	80 00       	ld.sh	r0,r0[0x0]
80002152:	ce 7c       	rcall	80002320 <DataSession_brdcst_func+0x4>
80002154:	80 00       	ld.sh	r0,r0[0x0]
80002156:	6d 80       	ld.w	r0,r6[0x60]
80002158:	80 00       	ld.sh	r0,r0[0x0]
8000215a:	ce 94       	brge	8000212c <EnOB_reply_func+0x34>
8000215c:	80 00       	ld.sh	r0,r0[0x0]
8000215e:	ce a8       	rjmp	80002332 <DataSession_brdcst_func+0x16>
80002160:	80 00       	ld.sh	r0,r0[0x0]
80002162:	ce c0       	breq	8000213a <EnOB_reply_func+0x42>
80002164:	80 00       	ld.sh	r0,r0[0x0]
80002166:	ce dc       	rcall	80002340 <DataSession_brdcst_func+0x24>

80002168 <SingleDetection_brdcst_func>:
	
}


void SingleDetection_brdcst_func(xcmp_fragment_t * xcmp)
{
80002168:	d4 01       	pushm	lr
	if (xcmp->u8[0] == 0x11)
8000216a:	19 a9       	ld.ub	r9,r12[0x2]
8000216c:	31 18       	mov	r8,17
8000216e:	f0 09 18 00 	cp.b	r9,r8
80002172:	c0 41       	brne	8000217a <SingleDetection_brdcst_func+0x12>
	{
		log("\n\r DMR_CSBK OK \n\r");
80002174:	48 2c       	lddpc	r12,8000217c <SingleDetection_brdcst_func+0x14>
80002176:	f0 1f 00 03 	mcall	80002180 <SingleDetection_brdcst_func+0x18>
8000217a:	d8 02       	popm	pc
8000217c:	80 00       	ld.sh	r0,r0[0x0]
8000217e:	ce f4       	brge	8000215c <EnOB_reply_func+0x64>
80002180:	80 00       	ld.sh	r0,r0[0x0]
80002182:	6d 80       	ld.w	r0,r6[0x60]

80002184 <ButtonConfig_brdcst_func>:
	
}


void ButtonConfig_brdcst_func(xcmp_fragment_t * xcmp)
{
80002184:	d4 31       	pushm	r0-r7,lr
	U8 Num_Button =0;
	U8 i = 0 ;
	/*point to xcmp payload*/
	ButtonConfig_brdcst_t  *ptr = (ButtonConfig_brdcst_t* )xcmp->u8;
80002186:	f8 c7 ff fe 	sub	r7,r12,-2
	
	Num_Button = ptr->NumOfButtons;
8000218a:	0f 95       	ld.ub	r5,r7[0x1]
	
	log("\n\r ButtonConfig_broadcast  \n\r"  );
8000218c:	4a bc       	lddpc	r12,80002238 <ButtonConfig_brdcst_func+0xb4>
8000218e:	f0 1f 00 2c 	mcall	8000223c <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r Function: %X \n\r" , ptr->Function );
80002192:	0f 88       	ld.ub	r8,r7[0x0]
80002194:	1a d8       	st.w	--sp,r8
80002196:	4a bc       	lddpc	r12,80002240 <ButtonConfig_brdcst_func+0xbc>
80002198:	f0 1f 00 29 	mcall	8000223c <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
8000219c:	1a d5       	st.w	--sp,r5
8000219e:	4a ac       	lddpc	r12,80002244 <ButtonConfig_brdcst_func+0xc0>
800021a0:	f0 1f 00 27 	mcall	8000223c <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
800021a4:	0f a8       	ld.ub	r8,r7[0x2]
800021a6:	1a d8       	st.w	--sp,r8
800021a8:	4a 8c       	lddpc	r12,80002248 <ButtonConfig_brdcst_func+0xc4>
800021aa:	f0 1f 00 25 	mcall	8000223c <ButtonConfig_brdcst_func+0xb8>
	
	for (i; i<Num_Button; i++)
800021ae:	2f dd       	sub	sp,-12
800021b0:	58 05       	cp.w	r5,0
800021b2:	c4 10       	breq	80002234 <ButtonConfig_brdcst_func+0xb0>
800021b4:	30 06       	mov	r6,0
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
800021b6:	4a 64       	lddpc	r4,8000224c <ButtonConfig_brdcst_func+0xc8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
800021b8:	4a 63       	lddpc	r3,80002250 <ButtonConfig_brdcst_func+0xcc>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
800021ba:	4a 72       	lddpc	r2,80002254 <ButtonConfig_brdcst_func+0xd0>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
800021bc:	4a 71       	lddpc	r1,80002258 <ButtonConfig_brdcst_func+0xd4>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
800021be:	4a 80       	lddpc	r0,8000225c <ButtonConfig_brdcst_func+0xd8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
800021c0:	0f b9       	ld.ub	r9,r7[0x3]
800021c2:	0f c8       	ld.ub	r8,r7[0x4]
800021c4:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800021c8:	1a d8       	st.w	--sp,r8
800021ca:	1a d6       	st.w	--sp,r6
800021cc:	08 9c       	mov	r12,r4
800021ce:	f0 1f 00 1c 	mcall	8000223c <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
800021d2:	0f d9       	ld.ub	r9,r7[0x5]
800021d4:	0f e8       	ld.ub	r8,r7[0x6]
800021d6:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800021da:	1a d8       	st.w	--sp,r8
800021dc:	1a d6       	st.w	--sp,r6
800021de:	06 9c       	mov	r12,r3
800021e0:	f0 1f 00 17 	mcall	8000223c <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
800021e4:	0f f9       	ld.ub	r9,r7[0x7]
800021e6:	ef 38 00 08 	ld.ub	r8,r7[8]
800021ea:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800021ee:	1a d8       	st.w	--sp,r8
800021f0:	1a d6       	st.w	--sp,r6
800021f2:	04 9c       	mov	r12,r2
800021f4:	f0 1f 00 12 	mcall	8000223c <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
800021f8:	ef 39 00 09 	ld.ub	r9,r7[9]
800021fc:	ef 38 00 0a 	ld.ub	r8,r7[10]
80002200:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002204:	1a d8       	st.w	--sp,r8
80002206:	1a d6       	st.w	--sp,r6
80002208:	02 9c       	mov	r12,r1
8000220a:	f0 1f 00 0d 	mcall	8000223c <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
8000220e:	2f 8d       	sub	sp,-32
80002210:	ef 39 00 0b 	ld.ub	r9,r7[11]
80002214:	ef 38 00 0c 	ld.ub	r8,r7[12]
80002218:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000221c:	1a d8       	st.w	--sp,r8
8000221e:	1a d6       	st.w	--sp,r6
80002220:	00 9c       	mov	r12,r0
80002222:	f0 1f 00 07 	mcall	8000223c <ButtonConfig_brdcst_func+0xb8>
80002226:	2f f6       	sub	r6,-1
80002228:	2f 67       	sub	r7,-10
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
8000222a:	2f ed       	sub	sp,-8
8000222c:	ec 05 18 00 	cp.b	r5,r6
80002230:	fe 9b ff c8 	brhi	800021c0 <ButtonConfig_brdcst_func+0x3c>
80002234:	d8 32       	popm	r0-r7,pc
80002236:	00 00       	add	r0,r0
80002238:	80 00       	ld.sh	r0,r0[0x0]
8000223a:	cf 08       	rjmp	8000241a <CallControl_brdcst_func+0x22>
8000223c:	80 00       	ld.sh	r0,r0[0x0]
8000223e:	6d 80       	ld.w	r0,r6[0x60]
80002240:	80 00       	ld.sh	r0,r0[0x0]
80002242:	cf 28       	rjmp	80002426 <CallControl_brdcst_func+0x2e>
80002244:	80 00       	ld.sh	r0,r0[0x0]
80002246:	cf 3c       	rcall	8000242c <CallControl_brdcst_func+0x34>
80002248:	80 00       	ld.sh	r0,r0[0x0]
8000224a:	cf 54       	brge	80002234 <ButtonConfig_brdcst_func+0xb0>
8000224c:	80 00       	ld.sh	r0,r0[0x0]
8000224e:	cf 74       	brge	8000223c <ButtonConfig_brdcst_func+0xb8>
80002250:	80 00       	ld.sh	r0,r0[0x0]
80002252:	cf 9c       	rcall	80002444 <TransmitControl_brdcst_func+0x8>
80002254:	80 00       	ld.sh	r0,r0[0x0]
80002256:	cf c4       	brge	8000224e <ButtonConfig_brdcst_func+0xca>
80002258:	80 00       	ld.sh	r0,r0[0x0]
8000225a:	cf e8       	rjmp	80002456 <TransmitControl_brdcst_func+0x1a>
8000225c:	80 00       	ld.sh	r0,r0[0x0]
8000225e:	d0 10       	acall	0x1

80002260 <Phyuserinput_brdcst_func>:
	
}


void Phyuserinput_brdcst_func(xcmp_fragment_t * xcmp)
{
80002260:	eb cd 40 fc 	pushm	r2-r7,lr
	U16 PUI_ID =0;
	U8 PUI_State =0;
	U8 PUI_State_Min_Value =0;
	U8 PUI_State_Max_Value =0;
	
	PUI_Source = xcmp->u8[0];
80002264:	19 a6       	ld.ub	r6,r12[0x2]
	PUI_Type = xcmp ->u8[1];
80002266:	19 b5       	ld.ub	r5,r12[0x3]
	PUI_ID = ((xcmp->u8[2]<<8) | xcmp->u8[3]);
80002268:	19 c7       	ld.ub	r7,r12[0x4]
8000226a:	19 d8       	ld.ub	r8,r12[0x5]
8000226c:	f1 e7 10 87 	or	r7,r8,r7<<0x8
	PUI_State = xcmp->u8[4];
80002270:	19 e4       	ld.ub	r4,r12[0x6]
	PUI_State_Min_Value = xcmp->u8[5];
80002272:	19 f3       	ld.ub	r3,r12[0x7]
	PUI_State_Max_Value = xcmp->u8[6];
80002274:	f9 32 00 08 	ld.ub	r2,r12[8]
	
	log("\n\r PhysicalUserInput_broadcast  \n\r"  );
80002278:	49 0c       	lddpc	r12,800022b8 <Phyuserinput_brdcst_func+0x58>
8000227a:	f0 1f 00 11 	mcall	800022bc <Phyuserinput_brdcst_func+0x5c>
	
	log("\n\r PUI_Source: %X \n\r" , PUI_Source);
8000227e:	1a d6       	st.w	--sp,r6
80002280:	49 0c       	lddpc	r12,800022c0 <Phyuserinput_brdcst_func+0x60>
80002282:	f0 1f 00 0f 	mcall	800022bc <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_Type: %X \n\r" , PUI_Type);
80002286:	1a d5       	st.w	--sp,r5
80002288:	48 fc       	lddpc	r12,800022c4 <Phyuserinput_brdcst_func+0x64>
8000228a:	f0 1f 00 0d 	mcall	800022bc <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_ID: %X \n\r" , PUI_ID);
8000228e:	5c 77       	castu.h	r7
80002290:	1a d7       	st.w	--sp,r7
80002292:	48 ec       	lddpc	r12,800022c8 <Phyuserinput_brdcst_func+0x68>
80002294:	f0 1f 00 0a 	mcall	800022bc <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_State: %X \n\r" , PUI_State);
80002298:	1a d4       	st.w	--sp,r4
8000229a:	48 dc       	lddpc	r12,800022cc <Phyuserinput_brdcst_func+0x6c>
8000229c:	f0 1f 00 08 	mcall	800022bc <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_State_Min_Value: %X \n\r" , PUI_State_Min_Value);
800022a0:	1a d3       	st.w	--sp,r3
800022a2:	48 cc       	lddpc	r12,800022d0 <Phyuserinput_brdcst_func+0x70>
800022a4:	f0 1f 00 06 	mcall	800022bc <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_State_Max_Value: %X \n\r" , PUI_State_Max_Value);
800022a8:	1a d2       	st.w	--sp,r2
800022aa:	48 bc       	lddpc	r12,800022d4 <Phyuserinput_brdcst_func+0x74>
800022ac:	f0 1f 00 04 	mcall	800022bc <Phyuserinput_brdcst_func+0x5c>
800022b0:	2f ad       	sub	sp,-24
	
	
	
	
	
}
800022b2:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800022b6:	00 00       	add	r0,r0
800022b8:	80 00       	ld.sh	r0,r0[0x0]
800022ba:	d0 34       	*unknown*
800022bc:	80 00       	ld.sh	r0,r0[0x0]
800022be:	6d 80       	ld.w	r0,r6[0x60]
800022c0:	80 00       	ld.sh	r0,r0[0x0]
800022c2:	d0 58       	*unknown*
800022c4:	80 00       	ld.sh	r0,r0[0x0]
800022c6:	d0 70       	acall	0x7
800022c8:	80 00       	ld.sh	r0,r0[0x0]
800022ca:	d0 84       	*unknown*
800022cc:	80 00       	ld.sh	r0,r0[0x0]
800022ce:	d0 98       	*unknown*
800022d0:	80 00       	ld.sh	r0,r0[0x0]
800022d2:	d0 ac       	*unknown*
800022d4:	80 00       	ld.sh	r0,r0[0x0]
800022d6:	d0 cc       	*unknown*

800022d8 <ButtonConfig_reply_func>:
	}
	
}

void ButtonConfig_reply_func(xcmp_fragment_t * xcmp)
{
800022d8:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	ButtonConfig_reply_t *ptr = (ButtonConfig_reply_t* )(xcmp->u8);
800022dc:	f8 c7 ff fe 	sub	r7,r12,-2
	if (ptr->Result == xcmp_Res_Success)
800022e0:	0f 89       	ld.ub	r9,r7[0x0]
800022e2:	30 08       	mov	r8,0
800022e4:	f0 09 18 00 	cp.b	r9,r8
800022e8:	c0 c1       	brne	80002300 <ButtonConfig_reply_func+0x28>
	{
		log("\n\r Button_Config OK \n\r");
800022ea:	48 9c       	lddpc	r12,8000230c <ButtonConfig_reply_func+0x34>
800022ec:	f0 1f 00 09 	mcall	80002310 <ButtonConfig_reply_func+0x38>
		
		log("\n\r Function: %X \n\r" , ptr->Function );
800022f0:	0f 98       	ld.ub	r8,r7[0x1]
800022f2:	1a d8       	st.w	--sp,r8
800022f4:	48 8c       	lddpc	r12,80002314 <ButtonConfig_reply_func+0x3c>
800022f6:	f0 1f 00 07 	mcall	80002310 <ButtonConfig_reply_func+0x38>
800022fa:	2f fd       	sub	sp,-4
800022fc:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r Button_Request error \n\r");
80002300:	48 6c       	lddpc	r12,80002318 <ButtonConfig_reply_func+0x40>
80002302:	f0 1f 00 04 	mcall	80002310 <ButtonConfig_reply_func+0x38>
80002306:	e3 cd 80 80 	ldm	sp++,r7,pc
8000230a:	00 00       	add	r0,r0
8000230c:	80 00       	ld.sh	r0,r0[0x0]
8000230e:	d0 ec       	*unknown*
80002310:	80 00       	ld.sh	r0,r0[0x0]
80002312:	6d 80       	ld.w	r0,r6[0x60]
80002314:	80 00       	ld.sh	r0,r0[0x0]
80002316:	cf 28       	rjmp	800024fa <AudioRoutingControl_reply_func+0x16>
80002318:	80 00       	ld.sh	r0,r0[0x0]
8000231a:	d1 04       	*unknown*

8000231c <DataSession_brdcst_func>:
	}
	
}

void DataSession_brdcst_func(xcmp_fragment_t * xcmp)
{
8000231c:	d4 21       	pushm	r4-r7,lr
	U8 Session_number = 0;
	U16 data_length = 0;
	U8 i = 0;
	/*point to xcmp payload*/
	DataSession_brdcst_t *ptr = (DataSession_brdcst_t* )xcmp->u8;
8000231e:	f8 c6 ff fe 	sub	r6,r12,-2

	if (ptr->State == CSBK_DATA_RX_Suc)
80002322:	0d 88       	ld.ub	r8,r6[0x0]
80002324:	32 49       	mov	r9,36
80002326:	f2 08 18 00 	cp.b	r8,r9
8000232a:	c2 91       	brne	8000237c <DataSession_brdcst_func+0x60>
	{
		
		log("\n\r CSBK_RX OK \n\r");
8000232c:	49 7c       	lddpc	r12,80002388 <DataSession_brdcst_func+0x6c>
8000232e:	f0 1f 00 18 	mcall	8000238c <DataSession_brdcst_func+0x70>
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
80002332:	0d a5       	ld.ub	r5,r6[0x2]
80002334:	0d b8       	ld.ub	r8,r6[0x3]
80002336:	f1 e5 10 85 	or	r5,r8,r5<<0x8
8000233a:	5c 85       	casts.h	r5

		log("\n\r Session_ID: %x \n\r",Session_number );
8000233c:	0d 98       	ld.ub	r8,r6[0x1]
8000233e:	1a d8       	st.w	--sp,r8
80002340:	49 4c       	lddpc	r12,80002390 <DataSession_brdcst_func+0x74>
80002342:	f0 1f 00 13 	mcall	8000238c <DataSession_brdcst_func+0x70>
		log("\n\r paylaod_length: %d \n\r",data_length );
80002346:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
8000234a:	1a d8       	st.w	--sp,r8
8000234c:	49 2c       	lddpc	r12,80002394 <DataSession_brdcst_func+0x78>
8000234e:	f0 1f 00 10 	mcall	8000238c <DataSession_brdcst_func+0x70>
		for(i=0; i<data_length; i++)
80002352:	2f ed       	sub	sp,-8
80002354:	58 05       	cp.w	r5,0
80002356:	c1 80       	breq	80002386 <DataSession_brdcst_func+0x6a>
80002358:	30 07       	mov	r7,0
		{
			
			//log("\n\r payload[%d]: %X \n\r", i, xcmp->u8[4+i]);
			log("\n\r payload[%d]: %X \n\r", i, ptr->DataPayload.DataPayload[i]);
8000235a:	49 04       	lddpc	r4,80002398 <DataSession_brdcst_func+0x7c>
8000235c:	ec 07 00 08 	add	r8,r6,r7
80002360:	11 c8       	ld.ub	r8,r8[0x4]
80002362:	1a d8       	st.w	--sp,r8
80002364:	1a d7       	st.w	--sp,r7
80002366:	08 9c       	mov	r12,r4
80002368:	f0 1f 00 09 	mcall	8000238c <DataSession_brdcst_func+0x70>
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);

		log("\n\r Session_ID: %x \n\r",Session_number );
		log("\n\r paylaod_length: %d \n\r",data_length );
		for(i=0; i<data_length; i++)
8000236c:	2f f7       	sub	r7,-1
8000236e:	5c 57       	castu.b	r7
80002370:	2f ed       	sub	sp,-8
80002372:	ee 05 19 00 	cp.h	r5,r7
80002376:	fe 9b ff f3 	brhi	8000235c <DataSession_brdcst_func+0x40>
8000237a:	d8 22       	popm	r4-r7,pc
		
	}
	else
	{
		//log("\n\r State: 0x %X \n\r", xcmp->u8[0]);
		log("\n\r State: 0x %X \n\r", ptr->State);
8000237c:	1a d8       	st.w	--sp,r8
8000237e:	48 8c       	lddpc	r12,8000239c <DataSession_brdcst_func+0x80>
80002380:	f0 1f 00 03 	mcall	8000238c <DataSession_brdcst_func+0x70>
80002384:	2f fd       	sub	sp,-4
80002386:	d8 22       	popm	r4-r7,pc
80002388:	80 00       	ld.sh	r0,r0[0x0]
8000238a:	d1 20       	acall	0x12
8000238c:	80 00       	ld.sh	r0,r0[0x0]
8000238e:	6d 80       	ld.w	r0,r6[0x60]
80002390:	80 00       	ld.sh	r0,r0[0x0]
80002392:	d1 34       	*unknown*
80002394:	80 00       	ld.sh	r0,r0[0x0]
80002396:	d1 4c       	*unknown*
80002398:	80 00       	ld.sh	r0,r0[0x0]
8000239a:	d1 68       	*unknown*
8000239c:	80 00       	ld.sh	r0,r0[0x0]
8000239e:	d1 80       	acall	0x18

800023a0 <DataSession_reply_func>:
}



void DataSession_reply_func(xcmp_fragment_t * xcmp)
{
800023a0:	eb cd 40 80 	pushm	r7,lr
800023a4:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
800023a6:	19 a8       	ld.ub	r8,r12[0x2]
800023a8:	58 08       	cp.w	r8,0
800023aa:	c0 61       	brne	800023b6 <DataSession_reply_func+0x16>
	{
		log("\n\r DATArep OK \n\r");
800023ac:	48 dc       	lddpc	r12,800023e0 <DataSession_reply_func+0x40>
800023ae:	f0 1f 00 0e 	mcall	800023e4 <DataSession_reply_func+0x44>
800023b2:	e3 cd 80 80 	ldm	sp++,r7,pc
		//log("\n\r ID: 0x %X \n\r", xcmp->u8[2]);
		
	}
	else
	{
		log("\n\r Result:  %X \n\r", xcmp->u8[0]);
800023b6:	1a d8       	st.w	--sp,r8
800023b8:	48 cc       	lddpc	r12,800023e8 <DataSession_reply_func+0x48>
800023ba:	f0 1f 00 0b 	mcall	800023e4 <DataSession_reply_func+0x44>
		log("\n\r DATArep error \n\r");
800023be:	48 cc       	lddpc	r12,800023ec <DataSession_reply_func+0x4c>
800023c0:	f0 1f 00 09 	mcall	800023e4 <DataSession_reply_func+0x44>
		log("\n\r Func:  %X \n\r", xcmp->u8[1]);
800023c4:	0f b8       	ld.ub	r8,r7[0x3]
800023c6:	1a d8       	st.w	--sp,r8
800023c8:	48 ac       	lddpc	r12,800023f0 <DataSession_reply_func+0x50>
800023ca:	f0 1f 00 07 	mcall	800023e4 <DataSession_reply_func+0x44>
		log("\n\r ID:  %X \n\r", xcmp->u8[2]);
800023ce:	0f c8       	ld.ub	r8,r7[0x4]
800023d0:	1a d8       	st.w	--sp,r8
800023d2:	48 9c       	lddpc	r12,800023f4 <DataSession_reply_func+0x54>
800023d4:	f0 1f 00 04 	mcall	800023e4 <DataSession_reply_func+0x44>
800023d8:	2f dd       	sub	sp,-12
800023da:	e3 cd 80 80 	ldm	sp++,r7,pc
800023de:	00 00       	add	r0,r0
800023e0:	80 00       	ld.sh	r0,r0[0x0]
800023e2:	d1 94       	*unknown*
800023e4:	80 00       	ld.sh	r0,r0[0x0]
800023e6:	6d 80       	ld.w	r0,r6[0x60]
800023e8:	80 00       	ld.sh	r0,r0[0x0]
800023ea:	d1 a8       	*unknown*
800023ec:	80 00       	ld.sh	r0,r0[0x0]
800023ee:	d1 bc       	*unknown*
800023f0:	80 00       	ld.sh	r0,r0[0x0]
800023f2:	d1 d0       	acall	0x1d
800023f4:	80 00       	ld.sh	r0,r0[0x0]
800023f6:	d1 e0       	acall	0x1e

800023f8 <CallControl_brdcst_func>:
	
}


void CallControl_brdcst_func(xcmp_fragment_t * xcmp)
{
800023f8:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	CallControl_brdcst_t *ptr = (CallControl_brdcst_t* )xcmp->u8;
800023fc:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  CallControl brst \n\r ");
	//log("\n\r  Call_type: %x \n\r ", ptr->Calltype );
	log("\n\r  Call_state: %x \n\r ", ptr->Callstate );
80002400:	0f 98       	ld.ub	r8,r7[0x1]
80002402:	1a d8       	st.w	--sp,r8
80002404:	48 bc       	lddpc	r12,80002430 <CallControl_brdcst_func+0x38>
80002406:	f0 1f 00 0c 	mcall	80002434 <CallControl_brdcst_func+0x3c>
	if (ptr->Callstate == Call_Ended)//0x03
8000240a:	2f fd       	sub	sp,-4
8000240c:	0f 99       	ld.ub	r9,r7[0x1]
8000240e:	30 38       	mov	r8,3
80002410:	f0 09 18 00 	cp.b	r9,r8
80002414:	c0 41       	brne	8000241c <CallControl_brdcst_func+0x24>
	{
		//恢复正常语音路径通道
		//xcmp_audio_route_revert();
		Call_Begin = 0;
80002416:	30 09       	mov	r9,0
80002418:	48 88       	lddpc	r8,80002438 <CallControl_brdcst_func+0x40>
8000241a:	b0 89       	st.b	r8[0x0],r9
		
	}
	
	if (ptr->Callstate == Call_Initiated)//0x04
8000241c:	0f 99       	ld.ub	r9,r7[0x1]
8000241e:	30 48       	mov	r8,4
80002420:	f0 09 18 00 	cp.b	r9,r8
80002424:	c0 41       	brne	8000242c <CallControl_brdcst_func+0x34>
	{
		Call_Begin = 1;
80002426:	30 19       	mov	r9,1
80002428:	48 48       	lddpc	r8,80002438 <CallControl_brdcst_func+0x40>
8000242a:	b0 89       	st.b	r8[0x0],r9
8000242c:	e3 cd 80 80 	ldm	sp++,r7,pc
80002430:	80 00       	ld.sh	r0,r0[0x0]
80002432:	d1 f0       	acall	0x1f
80002434:	80 00       	ld.sh	r0,r0[0x0]
80002436:	6d 80       	ld.w	r0,r6[0x60]
80002438:	00 00       	add	r0,r0
8000243a:	0a 49       	or	r9,r5

8000243c <TransmitControl_brdcst_func>:

}


void TransmitControl_brdcst_func(xcmp_fragment_t * xcmp)
{
8000243c:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	TransmitControl_brdcast_t *ptr = (TransmitControl_brdcast_t* )xcmp->u8;
80002440:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  TransmitControl broadcast \n\r ");
	//log("\n\r  Mode_Of_Operation: %x \n\r ", ptr->Mode_Of_Operation );
	if (ptr->State == 0x00)
80002444:	0f 99       	ld.ub	r9,r7[0x1]
80002446:	30 08       	mov	r8,0
80002448:	f0 09 18 00 	cp.b	r9,r8
8000244c:	c0 71       	brne	8000245a <TransmitControl_brdcst_func+0x1e>
	{
		log("\n\r  Standby-Receive \n\r ");
8000244e:	48 ac       	lddpc	r12,80002474 <TransmitControl_brdcst_func+0x38>
80002450:	f0 1f 00 0a 	mcall	80002478 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 0;
80002454:	30 09       	mov	r9,0
80002456:	48 a8       	lddpc	r8,8000247c <TransmitControl_brdcst_func+0x40>
80002458:	b0 89       	st.b	r8[0x0],r9
	}
	if (ptr->State == 0x01)
8000245a:	0f 99       	ld.ub	r9,r7[0x1]
8000245c:	30 18       	mov	r8,1
8000245e:	f0 09 18 00 	cp.b	r9,r8
80002462:	c0 71       	brne	80002470 <TransmitControl_brdcst_func+0x34>
	{
		log("\n\r  Transmit \n\r ");
80002464:	48 7c       	lddpc	r12,80002480 <TransmitControl_brdcst_func+0x44>
80002466:	f0 1f 00 05 	mcall	80002478 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 1;
8000246a:	30 19       	mov	r9,1
8000246c:	48 48       	lddpc	r8,8000247c <TransmitControl_brdcst_func+0x40>
8000246e:	b0 89       	st.b	r8[0x0],r9
80002470:	e3 cd 80 80 	ldm	sp++,r7,pc
80002474:	80 00       	ld.sh	r0,r0[0x0]
80002476:	d2 08       	*unknown*
80002478:	80 00       	ld.sh	r0,r0[0x0]
8000247a:	6d 80       	ld.w	r0,r6[0x60]
8000247c:	00 00       	add	r0,r0
8000247e:	0a 48       	or	r8,r5
80002480:	80 00       	ld.sh	r0,r0[0x0]
80002482:	d2 20       	acall	0x22

80002484 <TransmitControl_reply_func>:




void TransmitControl_reply_func(xcmp_fragment_t * xcmp)
{
80002484:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	TransmitControl_reply_t *ptr = (TransmitControl_reply_t* )xcmp->u8;
80002488:	f8 c7 ff fe 	sub	r7,r12,-2
	
	if (ptr->Result == xcmp_Res_Success)
8000248c:	0f 89       	ld.ub	r9,r7[0x0]
8000248e:	30 08       	mov	r8,0
80002490:	f0 09 18 00 	cp.b	r9,r8
80002494:	c1 61       	brne	800024c0 <TransmitControl_reply_func+0x3c>
	{
		
		log("\n\r  TransmitControl OK \n\r ");
80002496:	48 ec       	lddpc	r12,800024cc <TransmitControl_reply_func+0x48>
80002498:	f0 1f 00 0e 	mcall	800024d0 <TransmitControl_reply_func+0x4c>
		log("\n\r Function: %x \n\r", ptr->Function);
8000249c:	0f 98       	ld.ub	r8,r7[0x1]
8000249e:	1a d8       	st.w	--sp,r8
800024a0:	48 dc       	lddpc	r12,800024d4 <TransmitControl_reply_func+0x50>
800024a2:	f0 1f 00 0c 	mcall	800024d0 <TransmitControl_reply_func+0x4c>
		log("\n\r Mode of Operation: %x \n\r", ptr->Mode_Of_Operation);
800024a6:	0f a8       	ld.ub	r8,r7[0x2]
800024a8:	1a d8       	st.w	--sp,r8
800024aa:	48 cc       	lddpc	r12,800024d8 <TransmitControl_reply_func+0x54>
800024ac:	f0 1f 00 09 	mcall	800024d0 <TransmitControl_reply_func+0x4c>
		log("\n\r State: %x \n\r", ptr->State);
800024b0:	0f b8       	ld.ub	r8,r7[0x3]
800024b2:	1a d8       	st.w	--sp,r8
800024b4:	48 ac       	lddpc	r12,800024dc <TransmitControl_reply_func+0x58>
800024b6:	f0 1f 00 07 	mcall	800024d0 <TransmitControl_reply_func+0x4c>
800024ba:	2f dd       	sub	sp,-12
800024bc:	e3 cd 80 80 	ldm	sp++,r7,pc
		
		//Silent_flag = 1;
	}
	else
	{
		log("TransmitControl error");
800024c0:	48 8c       	lddpc	r12,800024e0 <TransmitControl_reply_func+0x5c>
800024c2:	f0 1f 00 04 	mcall	800024d0 <TransmitControl_reply_func+0x4c>
800024c6:	e3 cd 80 80 	ldm	sp++,r7,pc
800024ca:	00 00       	add	r0,r0
800024cc:	80 00       	ld.sh	r0,r0[0x0]
800024ce:	d2 34       	*unknown*
800024d0:	80 00       	ld.sh	r0,r0[0x0]
800024d2:	6d 80       	ld.w	r0,r6[0x60]
800024d4:	80 00       	ld.sh	r0,r0[0x0]
800024d6:	d2 50       	acall	0x25
800024d8:	80 00       	ld.sh	r0,r0[0x0]
800024da:	d2 64       	*unknown*
800024dc:	80 00       	ld.sh	r0,r0[0x0]
800024de:	d2 80       	acall	0x28
800024e0:	80 00       	ld.sh	r0,r0[0x0]
800024e2:	d2 90       	acall	0x29

800024e4 <AudioRoutingControl_reply_func>:
	
}


void AudioRoutingControl_reply_func(xcmp_fragment_t * xcmp)
{
800024e4:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
800024e6:	19 a9       	ld.ub	r9,r12[0x2]
800024e8:	30 08       	mov	r8,0
800024ea:	f0 09 18 00 	cp.b	r9,r8
800024ee:	c0 71       	brne	800024fc <AudioRoutingControl_reply_func+0x18>
	{
		log("AudioRouting OK");
800024f0:	48 5c       	lddpc	r12,80002504 <AudioRoutingControl_reply_func+0x20>
800024f2:	f0 1f 00 06 	mcall	80002508 <AudioRoutingControl_reply_func+0x24>
		xcmp_IdleTestTone();//提示通道配置成功
800024f6:	f0 1f 00 06 	mcall	8000250c <AudioRoutingControl_reply_func+0x28>
800024fa:	d8 02       	popm	pc
		//xcmp_IdleTestTone();
		//Speaker_is_unmute = 1;
	}
	else
	{
		log("AudioRouting error");
800024fc:	48 5c       	lddpc	r12,80002510 <AudioRoutingControl_reply_func+0x2c>
800024fe:	f0 1f 00 03 	mcall	80002508 <AudioRoutingControl_reply_func+0x24>
80002502:	d8 02       	popm	pc
80002504:	80 00       	ld.sh	r0,r0[0x0]
80002506:	d2 a8       	*unknown*
80002508:	80 00       	ld.sh	r0,r0[0x0]
8000250a:	6d 80       	ld.w	r0,r6[0x60]
8000250c:	80 00       	ld.sh	r0,r0[0x0]
8000250e:	46 58       	lddsp	r8,sp[0x194]
80002510:	80 00       	ld.sh	r0,r0[0x0]
80002512:	d2 b8       	*unknown*

80002514 <Volume_reply_func>:
	
}


void Volume_reply_func(xcmp_fragment_t * xcmp)
{
80002514:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	VolumeControl_reply_t *ptr = (VolumeControl_reply_t* )xcmp->u8;
80002518:	f8 c7 ff fe 	sub	r7,r12,-2
	
		if (ptr->Result == xcmp_Res_Success)
8000251c:	0f 89       	ld.ub	r9,r7[0x0]
8000251e:	30 08       	mov	r8,0
80002520:	f0 09 18 00 	cp.b	r9,r8
80002524:	c1 b1       	brne	8000255a <Volume_reply_func+0x46>
		{
			if (ptr->Function == Enable_IntelligentAudio)
80002526:	0f b8       	ld.ub	r8,r7[0x3]
80002528:	31 09       	mov	r9,16
8000252a:	f2 08 18 00 	cp.b	r8,r9
8000252e:	c0 f1       	brne	8000254c <Volume_reply_func+0x38>
			{
				log("\n\r Enable_IA OK \n\r");
80002530:	48 dc       	lddpc	r12,80002564 <Volume_reply_func+0x50>
80002532:	f0 1f 00 0e 	mcall	80002568 <Volume_reply_func+0x54>
				log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
80002536:	0f 99       	ld.ub	r9,r7[0x1]
80002538:	0f a8       	ld.ub	r8,r7[0x2]
8000253a:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000253e:	1a d8       	st.w	--sp,r8
80002540:	48 bc       	lddpc	r12,8000256c <Volume_reply_func+0x58>
80002542:	f0 1f 00 0a 	mcall	80002568 <Volume_reply_func+0x54>
80002546:	2f fd       	sub	sp,-4
80002548:	e3 cd 80 80 	ldm	sp++,r7,pc
	
			}
			else
			{
				
				log("\n\r VolumeControl: %x \n\r", ptr->Function);
8000254c:	1a d8       	st.w	--sp,r8
8000254e:	48 9c       	lddpc	r12,80002570 <Volume_reply_func+0x5c>
80002550:	f0 1f 00 06 	mcall	80002568 <Volume_reply_func+0x54>
80002554:	2f fd       	sub	sp,-4
80002556:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		
		else
		{
			log("\n\r Enable_IA error \n\r");
8000255a:	48 7c       	lddpc	r12,80002574 <Volume_reply_func+0x60>
8000255c:	f0 1f 00 03 	mcall	80002568 <Volume_reply_func+0x54>
80002560:	e3 cd 80 80 	ldm	sp++,r7,pc
80002564:	80 00       	ld.sh	r0,r0[0x0]
80002566:	d2 cc       	*unknown*
80002568:	80 00       	ld.sh	r0,r0[0x0]
8000256a:	6d 80       	ld.w	r0,r6[0x60]
8000256c:	80 00       	ld.sh	r0,r0[0x0]
8000256e:	d2 e0       	acall	0x2e
80002570:	80 00       	ld.sh	r0,r0[0x0]
80002572:	d2 fc       	*unknown*
80002574:	80 00       	ld.sh	r0,r0[0x0]
80002576:	d3 14       	*unknown*

80002578 <spk_brdcst_func>:
		log("spk error");
	}
}

void spk_brdcst_func(xcmp_fragment_t * xcmp)
{
80002578:	d4 01       	pushm	lr
	if (xcmp->u8[3] == xcmp_Res_Success)//0x0000:mute
8000257a:	19 d9       	ld.ub	r9,r12[0x5]
8000257c:	30 08       	mov	r8,0
8000257e:	f0 09 18 00 	cp.b	r9,r8
80002582:	c0 81       	brne	80002592 <spk_brdcst_func+0x1a>
	{
		Speaker_is_unmute =0;
80002584:	10 99       	mov	r9,r8
80002586:	48 78       	lddpc	r8,800025a0 <spk_brdcst_func+0x28>
80002588:	b0 89       	st.b	r8[0x0],r9
		//Silent_flag = 0;
		log("spk_s_close ");
8000258a:	48 7c       	lddpc	r12,800025a4 <spk_brdcst_func+0x2c>
8000258c:	f0 1f 00 07 	mcall	800025a8 <spk_brdcst_func+0x30>
80002590:	d8 02       	popm	pc
		
	}
	else
	{
		//Silent_flag = 1;
		Speaker_is_unmute = 1;
80002592:	30 19       	mov	r9,1
80002594:	48 38       	lddpc	r8,800025a0 <spk_brdcst_func+0x28>
80002596:	b0 89       	st.b	r8[0x0],r9
		log("spk_s_open ");	
80002598:	48 5c       	lddpc	r12,800025ac <spk_brdcst_func+0x34>
8000259a:	f0 1f 00 04 	mcall	800025a8 <spk_brdcst_func+0x30>
8000259e:	d8 02       	popm	pc
800025a0:	00 00       	add	r0,r0
800025a2:	0a 40       	or	r0,r5
800025a4:	80 00       	ld.sh	r0,r0[0x0]
800025a6:	d3 2c       	*unknown*
800025a8:	80 00       	ld.sh	r0,r0[0x0]
800025aa:	6d 80       	ld.w	r0,r6[0x60]
800025ac:	80 00       	ld.sh	r0,r0[0x0]
800025ae:	d3 3c       	*unknown*

800025b0 <spk_reply_func>:
			
	
}

void spk_reply_func(xcmp_fragment_t * xcmp)
{
800025b0:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
800025b2:	19 a9       	ld.ub	r9,r12[0x2]
800025b4:	30 08       	mov	r8,0
800025b6:	f0 09 18 00 	cp.b	r9,r8
800025ba:	c0 f1       	brne	800025d8 <spk_reply_func+0x28>
	{
		
		if(xcmp->u8[4])
800025bc:	19 e9       	ld.ub	r9,r12[0x6]
800025be:	f0 09 18 00 	cp.b	r9,r8
800025c2:	c0 40       	breq	800025ca <spk_reply_func+0x1a>
		{
			Speaker_is_unmute = 1;
800025c4:	30 19       	mov	r9,1
800025c6:	48 98       	lddpc	r8,800025e8 <spk_reply_func+0x38>
800025c8:	b0 89       	st.b	r8[0x0],r9
			
			//Silent_flag = 1;
		}
		log("spk OK -st%2x", xcmp->u8[4] );
800025ca:	19 e8       	ld.ub	r8,r12[0x6]
800025cc:	1a d8       	st.w	--sp,r8
800025ce:	48 8c       	lddpc	r12,800025ec <spk_reply_func+0x3c>
800025d0:	f0 1f 00 08 	mcall	800025f0 <spk_reply_func+0x40>
800025d4:	2f fd       	sub	sp,-4
800025d6:	d8 02       	popm	pc
		
	}
	else
	{
		Speaker_is_unmute = 0;
800025d8:	30 09       	mov	r9,0
800025da:	48 48       	lddpc	r8,800025e8 <spk_reply_func+0x38>
800025dc:	b0 89       	st.b	r8[0x0],r9
		log("spk error");
800025de:	48 6c       	lddpc	r12,800025f4 <spk_reply_func+0x44>
800025e0:	f0 1f 00 04 	mcall	800025f0 <spk_reply_func+0x40>
800025e4:	d8 02       	popm	pc
800025e6:	00 00       	add	r0,r0
800025e8:	00 00       	add	r0,r0
800025ea:	0a 40       	or	r0,r5
800025ec:	80 00       	ld.sh	r0,r0[0x0]
800025ee:	d3 48       	*unknown*
800025f0:	80 00       	ld.sh	r0,r0[0x0]
800025f2:	6d 80       	ld.w	r0,r6[0x60]
800025f4:	80 00       	ld.sh	r0,r0[0x0]
800025f6:	d3 58       	*unknown*

800025f8 <mic_brdcst_func>:
	
	
}

void mic_brdcst_func(xcmp_fragment_t * xcmp)
{
800025f8:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_brdcast_t *ptr = (MicControl_brdcast_t* )xcmp->u8;
800025fc:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r Mic_brdcst \n\r");		
	//log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
	//log("\n\r Signal_type: %x \n\r " ,  ptr->Signaling_Type);
	if (ptr->Mic_State == 0x00)
80002600:	0f a9       	ld.ub	r9,r7[0x2]
80002602:	30 08       	mov	r8,0
80002604:	f0 09 18 00 	cp.b	r9,r8
80002608:	c0 71       	brne	80002616 <mic_brdcst_func+0x1e>
	{
		log("\n\r Mic_Disabled \n\r");	
8000260a:	48 dc       	lddpc	r12,8000263c <mic_brdcst_func+0x44>
8000260c:	f0 1f 00 0d 	mcall	80002640 <mic_brdcst_func+0x48>
		Mic_is_Enabled = 0;
80002610:	30 09       	mov	r9,0
80002612:	48 d8       	lddpc	r8,80002644 <mic_brdcst_func+0x4c>
80002614:	b0 89       	st.b	r8[0x0],r9
	} 
	if(ptr->Mic_State == 0x11)
80002616:	0f a9       	ld.ub	r9,r7[0x2]
80002618:	31 18       	mov	r8,17
8000261a:	f0 09 18 00 	cp.b	r9,r8
8000261e:	c0 d1       	brne	80002638 <mic_brdcst_func+0x40>
	{
		log("\n\r Mic_Enabled \n\r");
80002620:	48 ac       	lddpc	r12,80002648 <mic_brdcst_func+0x50>
80002622:	f0 1f 00 08 	mcall	80002640 <mic_brdcst_func+0x48>
		Mic_is_Enabled = 1;
80002626:	48 89       	lddpc	r9,80002644 <mic_brdcst_func+0x4c>
80002628:	30 18       	mov	r8,1
8000262a:	b2 88       	st.b	r9[0x0],r8
		
		if ((Mic_is_Enabled == 1) && (Call_Begin == 1))
8000262c:	13 89       	ld.ub	r9,r9[0x0]
8000262e:	f0 09 18 00 	cp.b	r9,r8
80002632:	c0 31       	brne	80002638 <mic_brdcst_func+0x40>
80002634:	48 68       	lddpc	r8,8000264c <mic_brdcst_func+0x54>
80002636:	11 88       	ld.ub	r8,r8[0x0]
80002638:	e3 cd 80 80 	ldm	sp++,r7,pc
8000263c:	80 00       	ld.sh	r0,r0[0x0]
8000263e:	d3 64       	*unknown*
80002640:	80 00       	ld.sh	r0,r0[0x0]
80002642:	6d 80       	ld.w	r0,r6[0x60]
80002644:	00 00       	add	r0,r0
80002646:	0a 50       	eor	r0,r5
80002648:	80 00       	ld.sh	r0,r0[0x0]
8000264a:	d3 78       	*unknown*
8000264c:	00 00       	add	r0,r0
8000264e:	0a 49       	or	r9,r5

80002650 <mic_reply_func>:
	
	
}

void mic_reply_func(xcmp_fragment_t * xcmp)
{
80002650:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_reply_t *ptr = (MicControl_reply_t* )xcmp->u8;
80002654:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Mic_reply \n\r");
80002658:	49 ac       	lddpc	r12,800026c0 <mic_reply_func+0x70>
8000265a:	f0 1f 00 1b 	mcall	800026c4 <mic_reply_func+0x74>
	if (ptr->Result == 0x00)
8000265e:	0f 89       	ld.ub	r9,r7[0x0]
80002660:	30 08       	mov	r8,0
80002662:	f0 09 18 00 	cp.b	r9,r8
80002666:	c2 71       	brne	800026b4 <mic_reply_func+0x64>
	{
		
		if (ptr->Function == Mic_Disable)
80002668:	0f 98       	ld.ub	r8,r7[0x1]
8000266a:	30 29       	mov	r9,2
8000266c:	f2 08 18 00 	cp.b	r8,r9
80002670:	c1 b1       	brne	800026a6 <mic_reply_func+0x56>
		{
		
			log("\n\r Mic_close_ok \n\r " );
80002672:	49 6c       	lddpc	r12,800026c8 <mic_reply_func+0x78>
80002674:	f0 1f 00 14 	mcall	800026c4 <mic_reply_func+0x74>
			log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
80002678:	0f a8       	ld.ub	r8,r7[0x2]
8000267a:	1a d8       	st.w	--sp,r8
8000267c:	49 4c       	lddpc	r12,800026cc <mic_reply_func+0x7c>
8000267e:	f0 1f 00 12 	mcall	800026c4 <mic_reply_func+0x74>
			log("\n\r Signaling_type: %x \n\r " ,  ptr->Signaling_Type);
80002682:	0f b8       	ld.ub	r8,r7[0x3]
80002684:	1a d8       	st.w	--sp,r8
80002686:	49 3c       	lddpc	r12,800026d0 <mic_reply_func+0x80>
80002688:	f0 1f 00 0f 	mcall	800026c4 <mic_reply_func+0x74>
			log("\n\r Mic_state: %x \n\r " ,  ptr->Mic_State);
8000268c:	0f c8       	ld.ub	r8,r7[0x4]
8000268e:	1a d8       	st.w	--sp,r8
80002690:	49 1c       	lddpc	r12,800026d4 <mic_reply_func+0x84>
80002692:	f0 1f 00 0d 	mcall	800026c4 <mic_reply_func+0x74>
			log("\n\r Gain_offset: %x \n\r " ,  ptr->Gain_Offset);
80002696:	0f d8       	ld.ub	r8,r7[0x5]
80002698:	1a d8       	st.w	--sp,r8
8000269a:	49 0c       	lddpc	r12,800026d8 <mic_reply_func+0x88>
8000269c:	f0 1f 00 0a 	mcall	800026c4 <mic_reply_func+0x74>
800026a0:	2f cd       	sub	sp,-16
800026a2:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else
		{
			log("\n\r Mic_function: %x \n\r ", ptr->Function );
800026a6:	1a d8       	st.w	--sp,r8
800026a8:	48 dc       	lddpc	r12,800026dc <mic_reply_func+0x8c>
800026aa:	f0 1f 00 07 	mcall	800026c4 <mic_reply_func+0x74>
800026ae:	2f fd       	sub	sp,-4
800026b0:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else 
	{
		
	
		log("\n\r Mic error \n\r");
800026b4:	48 bc       	lddpc	r12,800026e0 <mic_reply_func+0x90>
800026b6:	f0 1f 00 04 	mcall	800026c4 <mic_reply_func+0x74>
800026ba:	e3 cd 80 80 	ldm	sp++,r7,pc
800026be:	00 00       	add	r0,r0
800026c0:	80 00       	ld.sh	r0,r0[0x0]
800026c2:	d3 8c       	*unknown*
800026c4:	80 00       	ld.sh	r0,r0[0x0]
800026c6:	6d 80       	ld.w	r0,r6[0x60]
800026c8:	80 00       	ld.sh	r0,r0[0x0]
800026ca:	d3 9c       	*unknown*
800026cc:	80 00       	ld.sh	r0,r0[0x0]
800026ce:	d3 b0       	acall	0x3b
800026d0:	80 00       	ld.sh	r0,r0[0x0]
800026d2:	d3 c4       	*unknown*
800026d4:	80 00       	ld.sh	r0,r0[0x0]
800026d6:	d3 e0       	acall	0x3e
800026d8:	80 00       	ld.sh	r0,r0[0x0]
800026da:	d3 f8       	*unknown*
800026dc:	80 00       	ld.sh	r0,r0[0x0]
800026de:	d4 10       	acall	0x41
800026e0:	80 00       	ld.sh	r0,r0[0x0]
800026e2:	d4 28       	*unknown*

800026e4 <dcm_brdcst_func>:
	}
}


void dcm_brdcst_func(xcmp_fragment_t * xcmp)
{
800026e4:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	DeviceControlMode_brdcst_t *ptr = (DeviceControlMode_brdcst_t* )xcmp->u8;
800026e8:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Dcm_brdcst \n\r");		
800026ec:	48 bc       	lddpc	r12,80002718 <dcm_brdcst_func+0x34>
800026ee:	f0 1f 00 0c 	mcall	8000271c <dcm_brdcst_func+0x38>
	log("\n\r Function: %x \n\r " ,  ptr->Function);
800026f2:	0f 88       	ld.ub	r8,r7[0x0]
800026f4:	1a d8       	st.w	--sp,r8
800026f6:	48 bc       	lddpc	r12,80002720 <dcm_brdcst_func+0x3c>
800026f8:	f0 1f 00 09 	mcall	8000271c <dcm_brdcst_func+0x38>
	log("\n\r ControlType: %x \n\r " ,  ptr->ControlType);
800026fc:	0f a8       	ld.ub	r8,r7[0x2]
800026fe:	1a d8       	st.w	--sp,r8
80002700:	48 9c       	lddpc	r12,80002724 <dcm_brdcst_func+0x40>
80002702:	f0 1f 00 07 	mcall	8000271c <dcm_brdcst_func+0x38>
	log("\n\r ControlTypeSize: %x \n\r " ,  ptr->ControlTypeSize);
80002706:	0f 98       	ld.ub	r8,r7[0x1]
80002708:	1a d8       	st.w	--sp,r8
8000270a:	48 8c       	lddpc	r12,80002728 <dcm_brdcst_func+0x44>
8000270c:	f0 1f 00 04 	mcall	8000271c <dcm_brdcst_func+0x38>
80002710:	2f dd       	sub	sp,-12
	
	
}
80002712:	e3 cd 80 80 	ldm	sp++,r7,pc
80002716:	00 00       	add	r0,r0
80002718:	80 00       	ld.sh	r0,r0[0x0]
8000271a:	d4 38       	*unknown*
8000271c:	80 00       	ld.sh	r0,r0[0x0]
8000271e:	6d 80       	ld.w	r0,r6[0x60]
80002720:	80 00       	ld.sh	r0,r0[0x0]
80002722:	d4 4c       	*unknown*
80002724:	80 00       	ld.sh	r0,r0[0x0]
80002726:	d4 60       	acall	0x46
80002728:	80 00       	ld.sh	r0,r0[0x0]
8000272a:	d4 78       	*unknown*

8000272c <dcm_reply_func>:
		log("Tone error");
	}
}

void dcm_reply_func(xcmp_fragment_t * xcmp)
{
8000272c:	eb cd 40 80 	pushm	r7,lr
80002730:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
80002732:	19 a9       	ld.ub	r9,r12[0x2]
80002734:	30 08       	mov	r8,0
80002736:	f0 09 18 00 	cp.b	r9,r8
8000273a:	c1 b1       	brne	80002770 <dcm_reply_func+0x44>
	{
		if(xcmp->u8[1] == DCM_ENTER)
8000273c:	19 b8       	ld.ub	r8,r12[0x3]
8000273e:	30 19       	mov	r9,1
80002740:	f2 08 18 00 	cp.b	r8,r9
80002744:	c0 51       	brne	8000274e <dcm_reply_func+0x22>
		{
			log("\n\r Dcm-Enter OK \n\r");
80002746:	48 ec       	lddpc	r12,8000277c <dcm_reply_func+0x50>
80002748:	f0 1f 00 0e 	mcall	80002780 <dcm_reply_func+0x54>
8000274c:	c0 a8       	rjmp	80002760 <dcm_reply_func+0x34>
			
		}
		else if (xcmp->u8[1] == DCM_EXIT)
8000274e:	58 08       	cp.w	r8,0
80002750:	c0 51       	brne	8000275a <dcm_reply_func+0x2e>
		{
			log("\n\r Dcm-Exit OK \n\r");
80002752:	48 dc       	lddpc	r12,80002784 <dcm_reply_func+0x58>
80002754:	f0 1f 00 0b 	mcall	80002780 <dcm_reply_func+0x54>
80002758:	c0 48       	rjmp	80002760 <dcm_reply_func+0x34>
		}
		else
		{
			log("\n\r Dcm-Revoke \n\r");
8000275a:	48 cc       	lddpc	r12,80002788 <dcm_reply_func+0x5c>
8000275c:	f0 1f 00 09 	mcall	80002780 <dcm_reply_func+0x54>
		}
		
		log("dcm OK-mo%X", xcmp->u8[3]);
80002760:	0f d8       	ld.ub	r8,r7[0x5]
80002762:	1a d8       	st.w	--sp,r8
80002764:	48 ac       	lddpc	r12,8000278c <dcm_reply_func+0x60>
80002766:	f0 1f 00 07 	mcall	80002780 <dcm_reply_func+0x54>
8000276a:	2f fd       	sub	sp,-4
8000276c:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		log("dcm error");
80002770:	48 8c       	lddpc	r12,80002790 <dcm_reply_func+0x64>
80002772:	f0 1f 00 04 	mcall	80002780 <dcm_reply_func+0x54>
80002776:	e3 cd 80 80 	ldm	sp++,r7,pc
8000277a:	00 00       	add	r0,r0
8000277c:	80 00       	ld.sh	r0,r0[0x0]
8000277e:	d4 94       	*unknown*
80002780:	80 00       	ld.sh	r0,r0[0x0]
80002782:	6d 80       	ld.w	r0,r6[0x60]
80002784:	80 00       	ld.sh	r0,r0[0x0]
80002786:	d4 a8       	*unknown*
80002788:	80 00       	ld.sh	r0,r0[0x0]
8000278a:	d4 bc       	*unknown*
8000278c:	80 00       	ld.sh	r0,r0[0x0]
8000278e:	d4 d0       	acall	0x4d
80002790:	80 00       	ld.sh	r0,r0[0x0]
80002792:	d4 dc       	*unknown*

80002794 <ToneControl_reply_func>:
			}
		}
}

void ToneControl_reply_func(xcmp_fragment_t * xcmp)
{
80002794:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
80002796:	19 a9       	ld.ub	r9,r12[0x2]
80002798:	30 08       	mov	r8,0
8000279a:	f0 09 18 00 	cp.b	r9,r8
8000279e:	c0 51       	brne	800027a8 <ToneControl_reply_func+0x14>
	{		
		log("Tone OK");
800027a0:	48 4c       	lddpc	r12,800027b0 <ToneControl_reply_func+0x1c>
800027a2:	f0 1f 00 05 	mcall	800027b4 <ToneControl_reply_func+0x20>
800027a6:	d8 02       	popm	pc
		//fl_write("/test.txt", FILE_END, (void *)"send tone ok\r\n", sizeof("send tone ok\r\n") - 1);
	}
	else
	{
		log("Tone error");
800027a8:	48 4c       	lddpc	r12,800027b8 <ToneControl_reply_func+0x24>
800027aa:	f0 1f 00 03 	mcall	800027b4 <ToneControl_reply_func+0x20>
800027ae:	d8 02       	popm	pc
800027b0:	80 00       	ld.sh	r0,r0[0x0]
800027b2:	d4 e8       	*unknown*
800027b4:	80 00       	ld.sh	r0,r0[0x0]
800027b6:	6d 80       	ld.w	r0,r6[0x60]
800027b8:	80 00       	ld.sh	r0,r0[0x0]
800027ba:	d4 f0       	acall	0x4f

800027bc <app_cfg>:

extern  char AudioData[];
extern U32 tc_tick;

static __app_Thread_(app_cfg)
{
800027bc:	d4 31       	pushm	r0-r7,lr
	static  U32 isAudioRouting = 0;
	static  portTickType xLastWakeTime;
	const portTickType xFrequency = 4000;//2s,定时问题已经修正。2s x  2000hz = 4000
	U8 Burst_ID = 0;
	
	 xLastWakeTime = xTaskGetTickCount();
800027be:	f0 1f 00 1e 	mcall	80002834 <app_cfg+0x78>
800027c2:	49 e8       	lddpc	r8,80002838 <app_cfg+0x7c>
800027c4:	91 0c       	st.w	r8[0x0],r12
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003))//确认连接成功了，再发送请求
800027c6:	49 e6       	lddpc	r6,8000283c <app_cfg+0x80>
				//{
					////xcmp_transmit_dekeycontrol();
					//
				//}
				
				if(isAudioRouting == 0)
800027c8:	49 e3       	lddpc	r3,80002840 <app_cfg+0x84>
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_exit_enhanced_OB_mode();
					//xcmp_mute_speaker();
					//xcmp_enhanced_OB_mode();
					isAudioRouting = 4;
800027ca:	30 40       	mov	r0,4
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_mute_speaker();	
					//log("\n\r time: %d \n\r", tc_tick); 
					isAudioRouting = 3;
800027cc:	30 31       	mov	r1,3
					xcmp_enter_enhanced_OB_mode();
					//xcmp_unmute_speaker();
					//Speaker_is_unmute = 1;
					//xcmp_function_mic();
					
					isAudioRouting = 1;
800027ce:	30 12       	mov	r2,1
				//}
			}
			
		}
		//vTaskDelay(300*2 / portTICK_RATE_MS);//延迟300ms
		log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
800027d0:	49 d5       	lddpc	r5,80002844 <app_cfg+0x88>
800027d2:	49 e7       	lddpc	r7,80002848 <app_cfg+0x8c>
		
		vTaskDelayUntil( &xLastWakeTime, 2000*2 / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
800027d4:	10 94       	mov	r4,r8
	
	 xLastWakeTime = xTaskGetTickCount();
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003))//确认连接成功了，再发送请求
800027d6:	6c 08       	ld.w	r8,r6[0x0]
800027d8:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
800027dc:	58 38       	cp.w	r8,3
800027de:	c1 e1       	brne	8000281a <app_cfg+0x5e>
		{	
			//if((++coun) % 3 ==0)		
			{
				
				// xcmp_audio_route_speaker();
				xcmp_IdleTestTone();
800027e0:	f0 1f 00 1b 	mcall	8000284c <app_cfg+0x90>
				//{
					////xcmp_transmit_dekeycontrol();
					//
				//}
				
				if(isAudioRouting == 0)
800027e4:	66 08       	ld.w	r8,r3[0x0]
800027e6:	58 08       	cp.w	r8,0
800027e8:	c0 71       	brne	800027f6 <app_cfg+0x3a>
				{
					//xcmp_data_session();
					//xcmp_audio_route_mic();
					//xcmp_button_config();
					//xcmp_audio_route_speaker();
					xcmp_enter_device_control_mode();//调换3个命令的顺序，则不会导致掉线。。。奇葩
800027ea:	f0 1f 00 1a 	mcall	80002850 <app_cfg+0x94>
					xcmp_enter_enhanced_OB_mode();
800027ee:	f0 1f 00 1a 	mcall	80002854 <app_cfg+0x98>
					//xcmp_unmute_speaker();
					//Speaker_is_unmute = 1;
					//xcmp_function_mic();
					
					isAudioRouting = 1;
800027f2:	87 02       	st.w	r3[0x0],r2
800027f4:	c1 38       	rjmp	8000281a <app_cfg+0x5e>
				}
				else if(isAudioRouting == 1)
800027f6:	58 18       	cp.w	r8,1
800027f8:	c0 61       	brne	80002804 <app_cfg+0x48>
				{
					//xcmp_exit_device_control_mode();
					xcmp_audio_route_AMBE();
800027fa:	f0 1f 00 18 	mcall	80002858 <app_cfg+0x9c>
					//xcmp_button_config();
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//log("\n\r time: %d \n\r", tc_tick);
					
					isAudioRouting = 2;
800027fe:	30 28       	mov	r8,2
80002800:	87 08       	st.w	r3[0x0],r8
80002802:	c0 c8       	rjmp	8000281a <app_cfg+0x5e>
					//isAudioRouting++;
				}
				else if(isAudioRouting == 2)
80002804:	58 28       	cp.w	r8,2
80002806:	c0 31       	brne	8000280c <app_cfg+0x50>
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_mute_speaker();	
					//log("\n\r time: %d \n\r", tc_tick); 
					isAudioRouting = 3;
80002808:	87 01       	st.w	r3[0x0],r1
8000280a:	c0 88       	rjmp	8000281a <app_cfg+0x5e>
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_exit_enhanced_OB_mode();
					//xcmp_mute_speaker();
					//xcmp_enhanced_OB_mode();
					isAudioRouting = 4;
8000280c:	58 38       	cp.w	r8,3
8000280e:	e7 f0 0a 00 	st.weq	r3[0x0],r0
					
				}
				else
				{
					isAudioRouting++;
80002812:	f7 b8 01 ff 	subne	r8,-1
80002816:	e7 f8 1a 00 	st.wne	r3[0x0],r8
				//}
			}
			
		}
		//vTaskDelay(300*2 / portTICK_RATE_MS);//延迟300ms
		log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
8000281a:	6e 08       	ld.w	r8,r7[0x0]
8000281c:	1a d8       	st.w	--sp,r8
8000281e:	0a 9c       	mov	r12,r5
80002820:	f0 1f 00 0f 	mcall	8000285c <app_cfg+0xa0>
		
		vTaskDelayUntil( &xLastWakeTime, 2000*2 / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
80002824:	e0 6b 0f a0 	mov	r11,4000
80002828:	08 9c       	mov	r12,r4
8000282a:	f0 1f 00 0e 	mcall	80002860 <app_cfg+0xa4>
	}
8000282e:	2f fd       	sub	sp,-4
80002830:	cd 3b       	rjmp	800027d6 <app_cfg+0x1a>
80002832:	00 00       	add	r0,r0
80002834:	80 00       	ld.sh	r0,r0[0x0]
80002836:	66 f4       	ld.w	r4,r3[0x3c]
80002838:	00 00       	add	r0,r0
8000283a:	0a 54       	eor	r4,r5
8000283c:	00 00       	add	r0,r0
8000283e:	0d 88       	ld.ub	r8,r6[0x0]
80002840:	00 00       	add	r0,r0
80002842:	0a 44       	or	r4,r5
80002844:	80 00       	ld.sh	r0,r0[0x0]
80002846:	d4 fc       	*unknown*
80002848:	00 00       	add	r0,r0
8000284a:	0a 5c       	eor	r12,r5
8000284c:	80 00       	ld.sh	r0,r0[0x0]
8000284e:	46 58       	lddsp	r8,sp[0x194]
80002850:	80 00       	ld.sh	r0,r0[0x0]
80002852:	44 fc       	lddsp	r12,sp[0x13c]
80002854:	80 00       	ld.sh	r0,r0[0x0]
80002856:	45 88       	lddsp	r8,sp[0x160]
80002858:	80 00       	ld.sh	r0,r0[0x0]
8000285a:	45 28       	lddsp	r8,sp[0x148]
8000285c:	80 00       	ld.sh	r0,r0[0x0]
8000285e:	6d 80       	ld.w	r0,r6[0x60]
80002860:	80 00       	ld.sh	r0,r0[0x0]
80002862:	68 5c       	ld.w	r12,r4[0x14]

80002864 <app_payload_rx_proc>:
}


static void app_payload_rx_proc(void  * payload)
{
80002864:	eb cd 40 80 	pushm	r7,lr
80002868:	18 97       	mov	r7,r12
	static  U8 times_counter = 0;
	
	times_counter++;
8000286a:	48 c9       	lddpc	r9,80002898 <app_payload_rx_proc+0x34>
8000286c:	13 88       	ld.ub	r8,r9[0x0]
8000286e:	2f f8       	sub	r8,-1
80002870:	b2 88       	st.b	r9[0x0],r8
	if (times_counter == 3)
80002872:	30 39       	mov	r9,3
80002874:	f2 08 18 00 	cp.b	r8,r9
80002878:	c0 71       	brne	80002886 <app_payload_rx_proc+0x22>
	{
		times_counter = 0 ;
8000287a:	30 09       	mov	r9,0
8000287c:	48 78       	lddpc	r8,80002898 <app_payload_rx_proc+0x34>
8000287e:	b0 89       	st.b	r8[0x0],r9
		log("\n\r w: \n\r");
80002880:	48 7c       	lddpc	r12,8000289c <app_payload_rx_proc+0x38>
80002882:	f0 1f 00 08 	mcall	800028a0 <app_payload_rx_proc+0x3c>
	}
	//log("\n\r w: \n\r");
	if (AMBE_tx_flag)//本地发送方的mic录音
80002886:	48 88       	lddpc	r8,800028a4 <app_payload_rx_proc+0x40>
80002888:	11 88       	ld.ub	r8,r8[0x0]
	{
		//fl_write("PCMvo.pcm", FILE_END, payload, MAX_PAYLOAD_BUFF_SIZE * 2);
	}
	
	//payload_fragment_t * ptr = (payload_fragment_t *)payload;
	set_payload_idle(payload);
8000288a:	48 88       	lddpc	r8,800028a8 <app_payload_rx_proc+0x44>
8000288c:	70 0c       	ld.w	r12,r8[0x0]
8000288e:	0e 9b       	mov	r11,r7
80002890:	f0 1f 00 07 	mcall	800028ac <app_payload_rx_proc+0x48>

}
80002894:	e3 cd 80 80 	ldm	sp++,r7,pc
80002898:	00 00       	add	r0,r0
8000289a:	0a 58       	eor	r8,r5
8000289c:	80 00       	ld.sh	r0,r0[0x0]
8000289e:	d5 18       	*unknown*
800028a0:	80 00       	ld.sh	r0,r0[0x0]
800028a2:	6d 80       	ld.w	r0,r6[0x60]
800028a4:	00 00       	add	r0,r0
800028a6:	0a 51       	eor	r1,r5
800028a8:	00 00       	add	r0,r0
800028aa:	0a 78       	tst	r8,r5
800028ac:	80 00       	ld.sh	r0,r0[0x0]
800028ae:	30 00       	mov	r0,0

800028b0 <DeviceInitializationStatus_brdcst_func>:
static void app_payload_tx_proc(void  * payload);

//app func--list

void DeviceInitializationStatus_brdcst_func(xcmp_fragment_t  * xcmp)
{
800028b0:	d4 01       	pushm	lr
	if (xcmp->u8[4] == 0x01)
800028b2:	19 e8       	ld.ub	r8,r12[0x6]
800028b4:	30 19       	mov	r9,1
800028b6:	f2 08 18 00 	cp.b	r8,r9
800028ba:	c0 61       	brne	800028c6 <DeviceInitializationStatus_brdcst_func+0x16>
	{
		bunchofrandomstatusflags |= 0x01;  //Need do nothing else.
800028bc:	48 98       	lddpc	r8,800028e0 <DeviceInitializationStatus_brdcst_func+0x30>
800028be:	70 09       	ld.w	r9,r8[0x0]
800028c0:	a1 a9       	sbr	r9,0x0
800028c2:	91 09       	st.w	r8[0x0],r9
800028c4:	d8 02       	popm	pc
	}
	else if(xcmp->u8[4] != 0x02)
800028c6:	30 29       	mov	r9,2
800028c8:	f2 08 18 00 	cp.b	r8,r9
800028cc:	c0 80       	breq	800028dc <DeviceInitializationStatus_brdcst_func+0x2c>
	{
		bunchofrandomstatusflags  &= 0xFFFFFFFC; //Device Init no longer Complete.
800028ce:	48 58       	lddpc	r8,800028e0 <DeviceInitializationStatus_brdcst_func+0x30>
800028d0:	70 09       	ld.w	r9,r8[0x0]
800028d2:	e0 19 ff fc 	andl	r9,0xfffc
800028d6:	91 09       	st.w	r8[0x0],r9
		xcmp_DeviceInitializationStatus_request();
800028d8:	f0 1f 00 03 	mcall	800028e4 <DeviceInitializationStatus_brdcst_func+0x34>
800028dc:	d8 02       	popm	pc
800028de:	00 00       	add	r0,r0
800028e0:	00 00       	add	r0,r0
800028e2:	0d 88       	ld.ub	r8,r6[0x0]
800028e4:	80 00       	ld.sh	r0,r0[0x0]
800028e6:	45 ac       	lddsp	r12,sp[0x168]

800028e8 <send_flash_command>:
* ----------  --------  ----------  --------------------------------------------
* 10-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
U16 send_flash_command(U16 command, U32 address, U8 *data_ptr, U16 length)
{
800028e8:	eb cd 40 fc 	pushm	r2-r7,lr
800028ec:	20 1d       	sub	sp,4
800028ee:	18 97       	mov	r7,r12
800028f0:	14 95       	mov	r5,r10
800028f2:	12 96       	mov	r6,r9
	U16 status = 1;
800028f4:	30 18       	mov	r8,1
800028f6:	ba 18       	st.h	sp[0x2],r8
	U16 i = 0;

    /* in order to call spi_write(U16* data), change 3-bytes address to 3-U16 address */
	U16 addr[3];
	addr[2] = (address & 0x00ff0000) >> 16;
800028f8:	e9 db c2 08 	bfextu	r4,r11,0x10,0x8
	addr[1] = (address & 0x0000ff00) >> 8;
800028fc:	e7 db c1 08 	bfextu	r3,r11,0x8,0x8
	addr[0] = (address & 0x000000ff);
80002900:	e5 db c0 08 	bfextu	r2,r11,0x0,0x8

	U16 data_u16;

	spi_selectChip(spi, DF_SPI_PCS_0);
80002904:	30 0b       	mov	r11,0
80002906:	4e 38       	lddpc	r8,80002a90 <send_flash_command+0x1a8>
80002908:	70 0c       	ld.w	r12,r8[0x0]
8000290a:	f0 1f 00 63 	mcall	80002a94 <send_flash_command+0x1ac>

    switch (command)
8000290e:	30 58       	mov	r8,5
80002910:	f0 07 19 00 	cp.h	r7,r8
80002914:	c3 40       	breq	8000297c <send_flash_command+0x94>
80002916:	e0 8b 00 18 	brhi	80002946 <send_flash_command+0x5e>
8000291a:	30 28       	mov	r8,2
8000291c:	f0 07 19 00 	cp.h	r7,r8
80002920:	c5 e0       	breq	800029dc <send_flash_command+0xf4>
80002922:	e0 8b 00 08 	brhi	80002932 <send_flash_command+0x4a>
80002926:	30 18       	mov	r8,1
80002928:	f0 07 19 00 	cp.h	r7,r8
8000292c:	e0 81 00 a9 	brne	80002a7e <send_flash_command+0x196>
80002930:	c9 e8       	rjmp	80002a6c <send_flash_command+0x184>
80002932:	30 38       	mov	r8,3
80002934:	f0 07 19 00 	cp.h	r7,r8
80002938:	c7 20       	breq	80002a1c <send_flash_command+0x134>
8000293a:	30 48       	mov	r8,4
8000293c:	f0 07 19 00 	cp.h	r7,r8
80002940:	e0 81 00 9f 	brne	80002a7e <send_flash_command+0x196>
80002944:	c2 c8       	rjmp	8000299c <send_flash_command+0xb4>
80002946:	35 28       	mov	r8,82
80002948:	f0 07 19 00 	cp.h	r7,r8
8000294c:	c2 f0       	breq	800029aa <send_flash_command+0xc2>
8000294e:	e0 8b 00 0c 	brhi	80002966 <send_flash_command+0x7e>
80002952:	30 68       	mov	r8,6
80002954:	f0 07 19 00 	cp.h	r7,r8
80002958:	c2 20       	breq	8000299c <send_flash_command+0xb4>
8000295a:	32 08       	mov	r8,32
8000295c:	f0 07 19 00 	cp.h	r7,r8
80002960:	e0 81 00 8f 	brne	80002a7e <send_flash_command+0x196>
80002964:	c2 38       	rjmp	800029aa <send_flash_command+0xc2>
80002966:	36 08       	mov	r8,96
80002968:	f0 07 19 00 	cp.h	r7,r8
8000296c:	c3 20       	breq	800029d0 <send_flash_command+0xe8>
8000296e:	e0 68 00 d8 	mov	r8,216
80002972:	f0 07 19 00 	cp.h	r7,r8
80002976:	e0 81 00 84 	brne	80002a7e <send_flash_command+0x196>
8000297a:	c1 88       	rjmp	800029aa <send_flash_command+0xc2>
	{
		case READ_STATUS_REG:
			spi_write_byte(command);
8000297c:	4c 57       	lddpc	r7,80002a90 <send_flash_command+0x1a8>
8000297e:	30 5b       	mov	r11,5
80002980:	6e 0c       	ld.w	r12,r7[0x0]
80002982:	f0 1f 00 46 	mcall	80002a98 <send_flash_command+0x1b0>
			spi_write_dummy();
80002986:	e0 6b 00 ff 	mov	r11,255
8000298a:	6e 0c       	ld.w	r12,r7[0x0]
8000298c:	f0 1f 00 43 	mcall	80002a98 <send_flash_command+0x1b0>
			spi_read_byte(&status);
80002990:	fa cb ff fe 	sub	r11,sp,-2
80002994:	6e 0c       	ld.w	r12,r7[0x0]
80002996:	f0 1f 00 42 	mcall	80002a9c <send_flash_command+0x1b4>
			break;
8000299a:	c7 28       	rjmp	80002a7e <send_flash_command+0x196>
		case WRITE_ENABLE:
		case WRITE_DISABLE:
			spi_write_byte(command);
8000299c:	0e 9b       	mov	r11,r7
8000299e:	5c 7b       	castu.h	r11
800029a0:	4b c8       	lddpc	r8,80002a90 <send_flash_command+0x1a8>
800029a2:	70 0c       	ld.w	r12,r8[0x0]
800029a4:	f0 1f 00 3d 	mcall	80002a98 <send_flash_command+0x1b0>
			break;
800029a8:	c6 b8       	rjmp	80002a7e <send_flash_command+0x196>
		case BLOCK_ERASE_4KB:
		case BLOCK_ERASE_32KB:
		case BLOCK_ERASE_64KB:
			spi_write_byte(command);
800029aa:	4b a6       	lddpc	r6,80002a90 <send_flash_command+0x1a8>
800029ac:	0e 9b       	mov	r11,r7
800029ae:	5c 7b       	castu.h	r11
800029b0:	6c 0c       	ld.w	r12,r6[0x0]
800029b2:	f0 1f 00 3a 	mcall	80002a98 <send_flash_command+0x1b0>
			spi_write_byte(addr[2]);
800029b6:	08 9b       	mov	r11,r4
800029b8:	6c 0c       	ld.w	r12,r6[0x0]
800029ba:	f0 1f 00 38 	mcall	80002a98 <send_flash_command+0x1b0>
			spi_write_byte(addr[1]);
800029be:	06 9b       	mov	r11,r3
800029c0:	6c 0c       	ld.w	r12,r6[0x0]
800029c2:	f0 1f 00 36 	mcall	80002a98 <send_flash_command+0x1b0>
			spi_write_byte(addr[0]);
800029c6:	04 9b       	mov	r11,r2
800029c8:	6c 0c       	ld.w	r12,r6[0x0]
800029ca:	f0 1f 00 34 	mcall	80002a98 <send_flash_command+0x1b0>
			break;
800029ce:	c5 88       	rjmp	80002a7e <send_flash_command+0x196>
		case CHIP_ERASE:
			spi_write_byte(command);
800029d0:	36 0b       	mov	r11,96
800029d2:	4b 08       	lddpc	r8,80002a90 <send_flash_command+0x1a8>
800029d4:	70 0c       	ld.w	r12,r8[0x0]
800029d6:	f0 1f 00 31 	mcall	80002a98 <send_flash_command+0x1b0>
			break;
800029da:	c5 28       	rjmp	80002a7e <send_flash_command+0x196>
		case BYTE_PROGRAM: /* PAGE_PROGRAM use the same value */
			spi_write_byte(command);
800029dc:	4a d7       	lddpc	r7,80002a90 <send_flash_command+0x1a8>
800029de:	30 2b       	mov	r11,2
800029e0:	6e 0c       	ld.w	r12,r7[0x0]
800029e2:	f0 1f 00 2e 	mcall	80002a98 <send_flash_command+0x1b0>
			spi_write_byte(addr[2]);
800029e6:	08 9b       	mov	r11,r4
800029e8:	6e 0c       	ld.w	r12,r7[0x0]
800029ea:	f0 1f 00 2c 	mcall	80002a98 <send_flash_command+0x1b0>
			spi_write_byte(addr[1]);
800029ee:	06 9b       	mov	r11,r3
800029f0:	6e 0c       	ld.w	r12,r7[0x0]
800029f2:	f0 1f 00 2a 	mcall	80002a98 <send_flash_command+0x1b0>
			spi_write_byte(addr[0]);
800029f6:	04 9b       	mov	r11,r2
800029f8:	6e 0c       	ld.w	r12,r7[0x0]
800029fa:	f0 1f 00 28 	mcall	80002a98 <send_flash_command+0x1b0>
			for (i = 0; i < length; i++)
800029fe:	58 06       	cp.w	r6,0
80002a00:	c3 f0       	breq	80002a7e <send_flash_command+0x196>
80002a02:	0a 97       	mov	r7,r5
			{
				data_u16 = (*data_ptr)&0x00ff;//modified by huayi
				data_ptr++;
				spi_write_byte(data_u16);
80002a04:	4a 34       	lddpc	r4,80002a90 <send_flash_command+0x1a8>
			spi_write_byte(addr[2]);
			spi_write_byte(addr[1]);
			spi_write_byte(addr[0]);
			for (i = 0; i < length; i++)
			{
				data_u16 = (*data_ptr)&0x00ff;//modified by huayi
80002a06:	0f 3b       	ld.ub	r11,r7++
80002a08:	ba 0b       	st.h	sp[0x0],r11
				data_ptr++;
				spi_write_byte(data_u16);
80002a0a:	68 0c       	ld.w	r12,r4[0x0]
80002a0c:	f0 1f 00 23 	mcall	80002a98 <send_flash_command+0x1b0>
		case BYTE_PROGRAM: /* PAGE_PROGRAM use the same value */
			spi_write_byte(command);
			spi_write_byte(addr[2]);
			spi_write_byte(addr[1]);
			spi_write_byte(addr[0]);
			for (i = 0; i < length; i++)
80002a10:	0e 98       	mov	r8,r7
80002a12:	0a 18       	sub	r8,r5
80002a14:	ec 08 19 00 	cp.h	r8,r6
80002a18:	cf 73       	brcs	80002a06 <send_flash_command+0x11e>
80002a1a:	c3 28       	rjmp	80002a7e <send_flash_command+0x196>
				data_ptr++;
				spi_write_byte(data_u16);
			}
			break;
		case READ_ARRAY:
			spi_write_byte(command);
80002a1c:	49 d7       	lddpc	r7,80002a90 <send_flash_command+0x1a8>
80002a1e:	30 3b       	mov	r11,3
80002a20:	6e 0c       	ld.w	r12,r7[0x0]
80002a22:	f0 1f 00 1e 	mcall	80002a98 <send_flash_command+0x1b0>
			spi_write_byte(addr[2]);
80002a26:	08 9b       	mov	r11,r4
80002a28:	6e 0c       	ld.w	r12,r7[0x0]
80002a2a:	f0 1f 00 1c 	mcall	80002a98 <send_flash_command+0x1b0>
			spi_write_byte(addr[1]);
80002a2e:	06 9b       	mov	r11,r3
80002a30:	6e 0c       	ld.w	r12,r7[0x0]
80002a32:	f0 1f 00 1a 	mcall	80002a98 <send_flash_command+0x1b0>
			spi_write_byte(addr[0]);
80002a36:	04 9b       	mov	r11,r2
80002a38:	6e 0c       	ld.w	r12,r7[0x0]
80002a3a:	f0 1f 00 18 	mcall	80002a98 <send_flash_command+0x1b0>
			for (i = 0; i < length; i++)
80002a3e:	58 06       	cp.w	r6,0
80002a40:	c1 f0       	breq	80002a7e <send_flash_command+0x196>
80002a42:	0a 97       	mov	r7,r5
			{
				spi_write_dummy();
80002a44:	49 34       	lddpc	r4,80002a90 <send_flash_command+0x1a8>
80002a46:	e0 63 00 ff 	mov	r3,255
				spi_read_byte(&data_u16);
80002a4a:	1a 92       	mov	r2,sp
			spi_write_byte(addr[2]);
			spi_write_byte(addr[1]);
			spi_write_byte(addr[0]);
			for (i = 0; i < length; i++)
			{
				spi_write_dummy();
80002a4c:	06 9b       	mov	r11,r3
80002a4e:	68 0c       	ld.w	r12,r4[0x0]
80002a50:	f0 1f 00 12 	mcall	80002a98 <send_flash_command+0x1b0>
				spi_read_byte(&data_u16);
80002a54:	1a 9b       	mov	r11,sp
80002a56:	68 0c       	ld.w	r12,r4[0x0]
80002a58:	f0 1f 00 11 	mcall	80002a9c <send_flash_command+0x1b4>
				*data_ptr = (U8)data_u16;
80002a5c:	9a 08       	ld.sh	r8,sp[0x0]
80002a5e:	0e c8       	st.b	r7++,r8
		case READ_ARRAY:
			spi_write_byte(command);
			spi_write_byte(addr[2]);
			spi_write_byte(addr[1]);
			spi_write_byte(addr[0]);
			for (i = 0; i < length; i++)
80002a60:	0e 98       	mov	r8,r7
80002a62:	0a 18       	sub	r8,r5
80002a64:	ec 08 19 00 	cp.h	r8,r6
80002a68:	cf 23       	brcs	80002a4c <send_flash_command+0x164>
80002a6a:	c0 a8       	rjmp	80002a7e <send_flash_command+0x196>
				*data_ptr = (U8)data_u16;
				data_ptr++;
			}
			break;
		case WRITE_STATUS_REG_BYTE_1:
			spi_write_byte(command);
80002a6c:	48 97       	lddpc	r7,80002a90 <send_flash_command+0x1a8>
80002a6e:	30 1b       	mov	r11,1
80002a70:	6e 0c       	ld.w	r12,r7[0x0]
80002a72:	f0 1f 00 0a 	mcall	80002a98 <send_flash_command+0x1b0>
			spi_write_byte(UNPROTECT_ALL_SECTORS);
80002a76:	30 0b       	mov	r11,0
80002a78:	6e 0c       	ld.w	r12,r7[0x0]
80002a7a:	f0 1f 00 08 	mcall	80002a98 <send_flash_command+0x1b0>
			break;
		default:
			break;
	}

	spi_unselectChip(spi, DF_SPI_PCS_0);
80002a7e:	30 0b       	mov	r11,0
80002a80:	48 48       	lddpc	r8,80002a90 <send_flash_command+0x1a8>
80002a82:	70 0c       	ld.w	r12,r8[0x0]
80002a84:	f0 1f 00 07 	mcall	80002aa0 <send_flash_command+0x1b8>

	return status;
}
80002a88:	9a 1c       	ld.sh	r12,sp[0x2]
80002a8a:	2f fd       	sub	sp,-4
80002a8c:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80002a90:	00 00       	add	r0,r0
80002a92:	1d 8c       	ld.ub	r12,lr[0x0]
80002a94:	80 00       	ld.sh	r0,r0[0x0]
80002a96:	55 8c       	stdsp	sp[0x160],r12
80002a98:	80 00       	ld.sh	r0,r0[0x0]
80002a9a:	56 c6       	stdsp	sp[0x1b0],r6
80002a9c:	80 00       	ld.sh	r0,r0[0x0]
80002a9e:	56 e2       	stdsp	sp[0x1b8],r2
80002aa0:	80 00       	ld.sh	r0,r0[0x0]
80002aa2:	55 d8       	stdsp	sp[0x174],r8

80002aa4 <data_flash_read_block>:
* ----------  --------  ----------  --------------------------------------------
* 25-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_read_block(U32 address, U16 length, U8 *data_ptr)
{
80002aa4:	d4 01       	pushm	lr
	/* check input parameter */
	if (data_ptr == NULL || address >= DF_MAX_ADDR || length > 0x1000)
80002aa6:	58 0a       	cp.w	r10,0
80002aa8:	5f 09       	sreq	r9
80002aaa:	e0 68 ff fe 	mov	r8,65534
80002aae:	ea 18 00 7f 	orh	r8,0x7f
80002ab2:	10 3c       	cp.w	r12,r8
80002ab4:	5f b8       	srhi	r8
80002ab6:	f3 e8 10 08 	or	r8,r9,r8
80002aba:	c0 e1       	brne	80002ad6 <data_flash_read_block+0x32>
80002abc:	e0 68 10 00 	mov	r8,4096
80002ac0:	f0 0b 19 00 	cp.h	r11,r8
80002ac4:	e0 8b 00 09 	brhi	80002ad6 <data_flash_read_block+0x32>
	{
		return DF_INVALID_PARAM;
	}

	send_flash_command(READ_ARRAY, address, data_ptr, length);
80002ac8:	f3 db c0 10 	bfextu	r9,r11,0x0,0x10
80002acc:	18 9b       	mov	r11,r12
80002ace:	30 3c       	mov	r12,3
80002ad0:	f0 1f 00 02 	mcall	80002ad8 <data_flash_read_block+0x34>
80002ad4:	d8 0a       	popm	pc,r12=0

	return DF_OK;
80002ad6:	da 0a       	popm	pc,r12=1
80002ad8:	80 00       	ld.sh	r0,r0[0x0]
80002ada:	28 e8       	sub	r8,-114

80002adc <data_flash_write_page>:
* ----------  --------  ----------  --------------------------------------------
* 25-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_write_page(U8 *data_ptr, U32 address, U16 length)
{
80002adc:	eb cd 40 e0 	pushm	r5-r7,lr
80002ae0:	18 96       	mov	r6,r12
80002ae2:	16 97       	mov	r7,r11
80002ae4:	14 95       	mov	r5,r10
	U16 status = 1;
	df_status_t return_code = DF_WRITE_FAIL;
	U16 count = 0; /* to monitor write time consumption */

	/* check input parameter */
	if (data_ptr == NULL || address >= DF_MAX_ADDR || length > DF_PAGE_SIZE)
80002ae6:	58 0c       	cp.w	r12,0
80002ae8:	5f 09       	sreq	r9
80002aea:	e0 68 ff fe 	mov	r8,65534
80002aee:	ea 18 00 7f 	orh	r8,0x7f
80002af2:	10 3b       	cp.w	r11,r8
80002af4:	5f b8       	srhi	r8
80002af6:	f3 e8 10 08 	or	r8,r9,r8
80002afa:	c3 91       	brne	80002b6c <data_flash_write_page+0x90>
80002afc:	e0 68 01 00 	mov	r8,256
80002b00:	f0 0a 19 00 	cp.h	r10,r8
80002b04:	e0 8b 00 34 	brhi	80002b6c <data_flash_write_page+0x90>
	{
		return DF_INVALID_PARAM;
	}

	status = send_flash_command(READ_STATUS_REG, 0, NULL, 0);
80002b08:	30 09       	mov	r9,0
80002b0a:	12 9a       	mov	r10,r9
80002b0c:	12 9b       	mov	r11,r9
80002b0e:	30 5c       	mov	r12,5
80002b10:	f0 1f 00 19 	mcall	80002b74 <data_flash_write_page+0x98>
	if ((status & STATUS_BUSY) != 0)
80002b14:	f9 dc c0 01 	bfextu	r12,r12,0x0,0x1
80002b18:	c0 30       	breq	80002b1e <data_flash_write_page+0x42>
80002b1a:	30 27       	mov	r7,2
80002b1c:	c2 98       	rjmp	80002b6e <data_flash_write_page+0x92>
	{
		return DF_DEVICE_BUSY;
	}

	/* send WRITE_ENABLE command */
	send_flash_command(WRITE_ENABLE, 0, NULL, 0);
80002b1e:	30 09       	mov	r9,0
80002b20:	12 9a       	mov	r10,r9
80002b22:	12 9b       	mov	r11,r9
80002b24:	30 6c       	mov	r12,6
80002b26:	f0 1f 00 14 	mcall	80002b74 <data_flash_write_page+0x98>

	/* send PAGE_PROGRAM command */
	send_flash_command(PAGE_PROGRAM, address, data_ptr, length);
80002b2a:	f3 d5 c0 10 	bfextu	r9,r5,0x0,0x10
80002b2e:	0c 9a       	mov	r10,r6
80002b30:	0e 9b       	mov	r11,r7
80002b32:	30 2c       	mov	r12,2
80002b34:	f0 1f 00 10 	mcall	80002b74 <data_flash_write_page+0x98>
	do {
		status = send_flash_command(READ_STATUS_REG, 0, NULL, 0);
80002b38:	30 05       	mov	r5,0
80002b3a:	30 56       	mov	r6,5
80002b3c:	0a 99       	mov	r9,r5
80002b3e:	0a 9a       	mov	r10,r5
80002b40:	0a 9b       	mov	r11,r5
80002b42:	0c 9c       	mov	r12,r6
80002b44:	f0 1f 00 0c 	mcall	80002b74 <data_flash_write_page+0x98>
		count++;
	} while((status & STATUS_BUSY) != 0);
80002b48:	5c 7c       	castu.h	r12
80002b4a:	f1 dc c0 01 	bfextu	r8,r12,0x0,0x1
80002b4e:	cf 71       	brne	80002b3c <data_flash_write_page+0x60>

	/*  Check Status Register */
	if ((status & STATUS_ERASE_PROG_ERROR) != 0)
80002b50:	18 97       	mov	r7,r12
80002b52:	e2 17 00 20 	andl	r7,0x20,COH
80002b56:	f9 b7 01 06 	movne	r7,6
80002b5a:	f9 b7 00 07 	moveq	r7,7
		/*  Erase Successful.  */
		return_code = DF_WRITE_COMPLETED;
	}

	/* send WRITE_DISABLE command */
	send_flash_command(WRITE_DISABLE, 0, NULL, 0);
80002b5e:	30 09       	mov	r9,0
80002b60:	12 9a       	mov	r10,r9
80002b62:	12 9b       	mov	r11,r9
80002b64:	30 4c       	mov	r12,4
80002b66:	f0 1f 00 04 	mcall	80002b74 <data_flash_write_page+0x98>

	return return_code;
80002b6a:	c0 28       	rjmp	80002b6e <data_flash_write_page+0x92>
80002b6c:	30 17       	mov	r7,1
}
80002b6e:	0e 9c       	mov	r12,r7
80002b70:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80002b74:	80 00       	ld.sh	r0,r0[0x0]
80002b76:	28 e8       	sub	r8,-114

80002b78 <data_flash_write_block>:
* ----------  --------  ----------  --------------------------------------------
* 25-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_write_block(U8 *data_ptr, U32 address, U16 data_length)
{
80002b78:	d4 31       	pushm	r0-r7,lr
80002b7a:	18 94       	mov	r4,r12
80002b7c:	ed da b0 10 	bfexts	r6,r10,0x0,0x10
80002b80:	16 97       	mov	r7,r11
80002b82:	30 7c       	mov	r12,7
	df_status_t return_code = DF_WRITE_COMPLETED;
	U32 write_addr = address;
	U16 bytes_remained = data_length;

	while (bytes_remained >= 1 && return_code == DF_WRITE_COMPLETED)
80002b84:	30 03       	mov	r3,0
80002b86:	06 92       	mov	r2,r3
	{
		if ((write_addr & 0xFF) == 0)
		{
			/* address 256 bytes aligned */

			if (bytes_remained <= DF_PAGE_SIZE)
80002b88:	e0 60 01 00 	mov	r0,256
{
	df_status_t return_code = DF_WRITE_COMPLETED;
	U32 write_addr = address;
	U16 bytes_remained = data_length;

	while (bytes_remained >= 1 && return_code == DF_WRITE_COMPLETED)
80002b8c:	c4 98       	rjmp	80002c1e <data_flash_write_block+0xa6>
	{
		if ((write_addr & 0xFF) == 0)
80002b8e:	eb d7 c0 08 	bfextu	r5,r7,0x0,0x8
80002b92:	c1 b1       	brne	80002bc8 <data_flash_write_block+0x50>
		{
			/* address 256 bytes aligned */

			if (bytes_remained <= DF_PAGE_SIZE)
80002b94:	e0 06 19 00 	cp.h	r6,r0
80002b98:	e0 8b 00 0a 	brhi	80002bac <data_flash_write_block+0x34>
			{
				/* bytes remained less than one page */
				return_code = data_flash_write_page(data_ptr, write_addr, bytes_remained);
80002b9c:	f5 d6 c0 10 	bfextu	r10,r6,0x0,0x10
80002ba0:	0e 9b       	mov	r11,r7
80002ba2:	08 9c       	mov	r12,r4
80002ba4:	f0 1f 00 24 	mcall	80002c34 <data_flash_write_block+0xbc>
80002ba8:	30 06       	mov	r6,0
80002baa:	c3 a8       	rjmp	80002c1e <data_flash_write_block+0xa6>
				bytes_remained = 0;	/* end while loop */
			}
			else /* (bytes_remained > DF_PAGE_SIZE) */
			{
				/* bytes remained more than one page */
				return_code = data_flash_write_page(data_ptr, write_addr, DF_PAGE_SIZE);
80002bac:	e0 6a 01 00 	mov	r10,256
80002bb0:	0e 9b       	mov	r11,r7
80002bb2:	08 9c       	mov	r12,r4
80002bb4:	f0 1f 00 20 	mcall	80002c34 <data_flash_write_block+0xbc>
				bytes_remained -= DF_PAGE_SIZE;
80002bb8:	ec c6 01 00 	sub	r6,r6,256
80002bbc:	5c 86       	casts.h	r6
				data_ptr += DF_PAGE_SIZE;
80002bbe:	e8 c4 ff 00 	sub	r4,r4,-256
				write_addr += DF_PAGE_SIZE;
80002bc2:	ee c7 ff 00 	sub	r7,r7,-256
80002bc6:	c2 c8       	rjmp	80002c1e <data_flash_write_block+0xa6>
		}
		else
		{
			/*(write_addr & 0xFF != 0), address not 256 bytes aligned */

			if (BEYOND_PAGE_BOUNDARY(write_addr, bytes_remained) == TRUE)
80002bc8:	f3 d6 c0 10 	bfextu	r9,r6,0x0,0x10
80002bcc:	0e 09       	add	r9,r7
80002bce:	0e 98       	mov	r8,r7
80002bd0:	e4 18 00 7f 	andh	r8,0x7f
80002bd4:	e0 18 ff 00 	andl	r8,0xff00
80002bd8:	f0 c8 ff 00 	sub	r8,r8,-256
80002bdc:	10 39       	cp.w	r9,r8
80002bde:	e0 88 00 19 	brls	80002c10 <data_flash_write_block+0x98>
			{
				/* bytes remained exceed current page, only write data within current page */
				return_code = data_flash_write_page(data_ptr, write_addr, BYTES_TO_NEXT_PAGE_BOUNDARY(write_addr));
80002be2:	0e 91       	mov	r1,r7
80002be4:	5c 51       	castu.b	r1
80002be6:	e0 6a 01 00 	mov	r10,256
80002bea:	02 1a       	sub	r10,r1
80002bec:	5c 7a       	castu.h	r10
80002bee:	0e 9b       	mov	r11,r7
80002bf0:	08 9c       	mov	r12,r4
80002bf2:	f0 1f 00 11 	mcall	80002c34 <data_flash_write_block+0xbc>
				bytes_remained -= BYTES_TO_NEXT_PAGE_BOUNDARY(write_addr);
80002bf6:	ec c6 01 00 	sub	r6,r6,256
80002bfa:	02 06       	add	r6,r1
80002bfc:	5c 86       	casts.h	r6
				data_ptr += BYTES_TO_NEXT_PAGE_BOUNDARY(write_addr);
80002bfe:	e0 68 01 00 	mov	r8,256
80002c02:	f0 05 01 05 	sub	r5,r8,r5
80002c06:	0a 04       	add	r4,r5
				write_addr += BYTES_TO_NEXT_PAGE_BOUNDARY(write_addr); /* now became 256 bytes aligned */
80002c08:	e0 17 ff 00 	andl	r7,0xff00
80002c0c:	10 07       	add	r7,r8
80002c0e:	c0 88       	rjmp	80002c1e <data_flash_write_block+0xa6>
			}
			else
			{
				/* bytes remained not exceed current page */
				return_code = data_flash_write_page(data_ptr, write_addr, bytes_remained);
80002c10:	f5 d6 c0 10 	bfextu	r10,r6,0x0,0x10
80002c14:	0e 9b       	mov	r11,r7
80002c16:	08 9c       	mov	r12,r4
80002c18:	f0 1f 00 07 	mcall	80002c34 <data_flash_write_block+0xbc>
80002c1c:	30 06       	mov	r6,0
{
	df_status_t return_code = DF_WRITE_COMPLETED;
	U32 write_addr = address;
	U16 bytes_remained = data_length;

	while (bytes_remained >= 1 && return_code == DF_WRITE_COMPLETED)
80002c1e:	e6 06 19 00 	cp.h	r6,r3
80002c22:	5f 19       	srne	r9
80002c24:	58 7c       	cp.w	r12,7
80002c26:	5f 08       	sreq	r8
80002c28:	f3 e8 00 08 	and	r8,r9,r8
80002c2c:	e4 08 18 00 	cp.b	r8,r2
80002c30:	ca f1       	brne	80002b8e <data_flash_write_block+0x16>
			}
		}
	}	/* end of while */

	return return_code;
}
80002c32:	d8 32       	popm	r0-r7,pc
80002c34:	80 00       	ld.sh	r0,r0[0x0]
80002c36:	2a dc       	sub	r12,-83

80002c38 <data_flash_erase_block>:
* ----------  --------  ----------  --------------------------------------------
* 25-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_erase_block(U32 address, df_block_size_t block_size)
{
80002c38:	eb cd 40 c0 	pushm	r6-r7,lr
80002c3c:	18 97       	mov	r7,r12
	U16 erase_commond;
	df_status_t return_code = DF_ERASE_FAIL;
	U16 count = 0; /* to monitor erase time consumption */

	/* check input parameter */
	if (address >= DF_MAX_ADDR)
80002c3e:	e0 68 ff fe 	mov	r8,65534
80002c42:	ea 18 00 7f 	orh	r8,0x7f
80002c46:	10 3c       	cp.w	r12,r8
80002c48:	e0 88 00 04 	brls	80002c50 <data_flash_erase_block+0x18>
80002c4c:	30 17       	mov	r7,1
80002c4e:	c3 e8       	rjmp	80002cca <data_flash_erase_block+0x92>
	{
		return DF_INVALID_PARAM;
	}

	/* determine erase command to be issued */
	if (block_size == DF_BLOCK_4KB)
80002c50:	58 1b       	cp.w	r11,1
80002c52:	c0 31       	brne	80002c58 <data_flash_erase_block+0x20>
80002c54:	32 06       	mov	r6,32
80002c56:	c0 a8       	rjmp	80002c6a <data_flash_erase_block+0x32>
		erase_commond = BLOCK_ERASE_4KB;
	else if (block_size == DF_BLOCK_32KB)
80002c58:	58 2b       	cp.w	r11,2
80002c5a:	c0 31       	brne	80002c60 <data_flash_erase_block+0x28>
80002c5c:	35 26       	mov	r6,82
80002c5e:	c0 68       	rjmp	80002c6a <data_flash_erase_block+0x32>
		erase_commond = BLOCK_ERASE_32KB;
	else if(block_size == DF_BLOCK_64KB)
80002c60:	e0 66 00 d8 	mov	r6,216
80002c64:	58 3b       	cp.w	r11,3
80002c66:	f9 b6 01 60 	movne	r6,96
		erase_commond = BLOCK_ERASE_64KB;
	else/*(block_size == DF_BLOCK_ALL)*/
		erase_commond = CHIP_ERASE;

	status = send_flash_command(READ_STATUS_REG, 0, NULL, 0);
80002c6a:	30 09       	mov	r9,0
80002c6c:	12 9a       	mov	r10,r9
80002c6e:	12 9b       	mov	r11,r9
80002c70:	30 5c       	mov	r12,5
80002c72:	f0 1f 00 18 	mcall	80002cd0 <data_flash_erase_block+0x98>
	if ((status & STATUS_BUSY) != 0)
80002c76:	f9 dc c0 01 	bfextu	r12,r12,0x0,0x1
80002c7a:	c0 30       	breq	80002c80 <data_flash_erase_block+0x48>
80002c7c:	30 27       	mov	r7,2
80002c7e:	c2 68       	rjmp	80002cca <data_flash_erase_block+0x92>
	{
		return DF_DEVICE_BUSY;
	}

	/* send WRITE_ENABLE command */
	send_flash_command(WRITE_ENABLE, 0, NULL, 0);
80002c80:	30 09       	mov	r9,0
80002c82:	12 9a       	mov	r10,r9
80002c84:	12 9b       	mov	r11,r9
80002c86:	30 6c       	mov	r12,6
80002c88:	f0 1f 00 12 	mcall	80002cd0 <data_flash_erase_block+0x98>

	/* send BLOCK_ERASE command */
	send_flash_command(erase_commond, address, NULL, 0);
80002c8c:	30 09       	mov	r9,0
80002c8e:	12 9a       	mov	r10,r9
80002c90:	0e 9b       	mov	r11,r7
80002c92:	0c 9c       	mov	r12,r6
80002c94:	f0 1f 00 0f 	mcall	80002cd0 <data_flash_erase_block+0x98>
	do {
		status = send_flash_command(READ_STATUS_REG, 0, NULL, 0);
80002c98:	30 06       	mov	r6,0
80002c9a:	30 57       	mov	r7,5
80002c9c:	0c 99       	mov	r9,r6
80002c9e:	0c 9a       	mov	r10,r6
80002ca0:	0c 9b       	mov	r11,r6
80002ca2:	0e 9c       	mov	r12,r7
80002ca4:	f0 1f 00 0b 	mcall	80002cd0 <data_flash_erase_block+0x98>
		count++;
	} while((status & STATUS_BUSY) != 0);
80002ca8:	5c 7c       	castu.h	r12
80002caa:	f1 dc c0 01 	bfextu	r8,r12,0x0,0x1
80002cae:	cf 71       	brne	80002c9c <data_flash_erase_block+0x64>

	/*  Check Status Register */
	if ((status & STATUS_ERASE_PROG_ERROR) != 0)
80002cb0:	18 97       	mov	r7,r12
80002cb2:	e2 17 00 20 	andl	r7,0x20,COH
80002cb6:	f9 b7 01 04 	movne	r7,4
80002cba:	f9 b7 00 05 	moveq	r7,5
		/*  Erase Successful.  */
		return_code = DF_ERASE_COMPLETED;
	}

	/* send WRITE_DISABLE command */
	send_flash_command(WRITE_DISABLE, 0, NULL, 0);
80002cbe:	30 09       	mov	r9,0
80002cc0:	12 9a       	mov	r10,r9
80002cc2:	12 9b       	mov	r11,r9
80002cc4:	30 4c       	mov	r12,4
80002cc6:	f0 1f 00 03 	mcall	80002cd0 <data_flash_erase_block+0x98>

	return return_code;
}
80002cca:	0e 9c       	mov	r12,r7
80002ccc:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002cd0:	80 00       	ld.sh	r0,r0[0x0]
80002cd2:	28 e8       	sub	r8,-114

80002cd4 <data_flash_write>:
* ----------  --------  ----------  --------------------------------------------
* 25-Fri-17   Edwards    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_write(U8 *data_ptr, U32 address, U16 data_length)
{
80002cd4:	d4 31       	pushm	r0-r7,lr
80002cd6:	20 3d       	sub	sp,12
80002cd8:	50 0c       	stdsp	sp[0x0],r12
80002cda:	16 91       	mov	r1,r11
80002cdc:	14 95       	mov	r5,r10
	U16 secremain;
	U16 i;
	df_status_t return_code = DF_OK;

	secpos	=	address/4096;//扇区地址 0~2047 for AT25DF641 
	secoff	=	address%4096;//在扇区内的偏移
80002cde:	f5 db c0 0c 	bfextu	r10,r11,0x0,0xc
80002ce2:	50 1a       	stdsp	sp[0x4],r10
	secremain	=	4096-secoff;//扇区剩余空间大小
80002ce4:	e0 69 10 00 	mov	r9,4096
80002ce8:	f2 0a 01 07 	sub	r7,r9,r10
80002cec:	ea 07 19 00 	cp.h	r7,r5
80002cf0:	ea 07 17 b0 	movhi	r7,r5
80002cf4:	5c 87       	casts.h	r7
80002cf6:	16 92       	mov	r2,r11
80002cf8:	e0 12 f0 00 	andl	r2,0xf000
	if(data_length <= secremain)secremain = data_length;//不大于4096个字节
	while(1)
	{
		data_flash_read_block(secpos*4096, 4096, FLASH_BUF);//读出整个扇区的内容
80002cfc:	4a e4       	lddpc	r4,80002db4 <data_flash_write+0xe0>
		for(i=0; i<secremain; i++)//校验数据
		{
			if(FLASH_BUF[secoff+i]!=0XFF)break;//需要擦除
80002cfe:	3f f6       	mov	r6,-1
* Date        Name      Prob#       Description
* ----------  --------  ----------  --------------------------------------------
* 25-Fri-17   Edwards    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_write(U8 *data_ptr, U32 address, U16 data_length)
80002d00:	e8 c8 ff ff 	sub	r8,r4,-1
80002d04:	50 28       	stdsp	sp[0x8],r8
			secpos++;//扇区地址增1
			secoff=0;//偏移位置为0

			data_ptr+=secremain;  //指针偏移
			address+=secremain;//写地址偏移
			data_length-=secremain;				//字节数递减
80002d06:	12 90       	mov	r0,r9
	secoff	=	address%4096;//在扇区内的偏移
	secremain	=	4096-secoff;//扇区剩余空间大小
	if(data_length <= secremain)secremain = data_length;//不大于4096个字节
	while(1)
	{
		data_flash_read_block(secpos*4096, 4096, FLASH_BUF);//读出整个扇区的内容
80002d08:	08 9a       	mov	r10,r4
80002d0a:	e0 6b 10 00 	mov	r11,4096
80002d0e:	04 9c       	mov	r12,r2
80002d10:	f0 1f 00 2a 	mcall	80002db8 <data_flash_write+0xe4>
		for(i=0; i<secremain; i++)//校验数据
80002d14:	58 07       	cp.w	r7,0
80002d16:	c3 00       	breq	80002d76 <data_flash_write+0xa2>
		{
			if(FLASH_BUF[secoff+i]!=0XFF)break;//需要擦除
80002d18:	40 13       	lddsp	r3,sp[0x4]
80002d1a:	5c 73       	castu.h	r3
80002d1c:	e8 03 07 08 	ld.ub	r8,r4[r3]
80002d20:	ec 08 18 00 	cp.b	r8,r6
80002d24:	c1 11       	brne	80002d46 <data_flash_write+0x72>
80002d26:	e6 c9 ff ff 	sub	r9,r3,-1
80002d2a:	08 09       	add	r9,r4
80002d2c:	30 08       	mov	r8,0
80002d2e:	c0 58       	rjmp	80002d38 <data_flash_write+0x64>
80002d30:	13 3a       	ld.ub	r10,r9++
80002d32:	ec 0a 18 00 	cp.b	r10,r6
80002d36:	c0 81       	brne	80002d46 <data_flash_write+0x72>
	secremain	=	4096-secoff;//扇区剩余空间大小
	if(data_length <= secremain)secremain = data_length;//不大于4096个字节
	while(1)
	{
		data_flash_read_block(secpos*4096, 4096, FLASH_BUF);//读出整个扇区的内容
		for(i=0; i<secremain; i++)//校验数据
80002d38:	2f f8       	sub	r8,-1
80002d3a:	5c 88       	casts.h	r8
80002d3c:	f0 07 19 00 	cp.h	r7,r8
80002d40:	fe 9b ff f8 	brhi	80002d30 <data_flash_write+0x5c>
80002d44:	c1 98       	rjmp	80002d76 <data_flash_write+0xa2>
		{
			if(FLASH_BUF[secoff+i]!=0XFF)break;//需要擦除
		}
		if(i < secremain)//需要擦除
		{
			return_code = data_flash_erase_block(secpos*4096, DF_BLOCK_4KB);//擦除这个扇区
80002d46:	30 1b       	mov	r11,1
80002d48:	04 9c       	mov	r12,r2
80002d4a:	f0 1f 00 1d 	mcall	80002dbc <data_flash_write+0xe8>
80002d4e:	40 08       	lddsp	r8,sp[0x0]
80002d50:	08 03       	add	r3,r4
* Date        Name      Prob#       Description
* ----------  --------  ----------  --------------------------------------------
* 25-Fri-17   Edwards    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_write(U8 *data_ptr, U32 address, U16 data_length)
80002d52:	40 2a       	lddsp	r10,sp[0x8]
80002d54:	40 19       	lddsp	r9,sp[0x4]
80002d56:	12 0a       	add	r10,r9
80002d58:	0e 99       	mov	r9,r7
80002d5a:	20 19       	sub	r9,1
80002d5c:	5c 79       	castu.h	r9
80002d5e:	12 0a       	add	r10,r9
		if(i < secremain)//需要擦除
		{
			return_code = data_flash_erase_block(secpos*4096, DF_BLOCK_4KB);//擦除这个扇区
			for(i=0; i<secremain; i++)	   //复制
			{
				FLASH_BUF[i+secoff]=data_ptr[i];
80002d60:	11 39       	ld.ub	r9,r8++
80002d62:	06 c9       	st.b	r3++,r9
			if(FLASH_BUF[secoff+i]!=0XFF)break;//需要擦除
		}
		if(i < secremain)//需要擦除
		{
			return_code = data_flash_erase_block(secpos*4096, DF_BLOCK_4KB);//擦除这个扇区
			for(i=0; i<secremain; i++)	   //复制
80002d64:	14 33       	cp.w	r3,r10
80002d66:	cf d1       	brne	80002d60 <data_flash_write+0x8c>
			{
				FLASH_BUF[i+secoff]=data_ptr[i];
			}
			return_code = data_flash_write_block(FLASH_BUF, secpos*4096, 4096);//写入整个扇区
80002d68:	e0 6a 10 00 	mov	r10,4096
80002d6c:	04 9b       	mov	r11,r2
80002d6e:	08 9c       	mov	r12,r4
80002d70:	f0 1f 00 14 	mcall	80002dc0 <data_flash_write+0xec>
80002d74:	c0 78       	rjmp	80002d82 <data_flash_write+0xae>

		}
		else 
		{
			return_code = data_flash_write_block(data_ptr, address, secremain);//写已经擦除了的,直接写入扇区剩余区间.
80002d76:	0e 9a       	mov	r10,r7
80002d78:	5c 7a       	castu.h	r10
80002d7a:	02 9b       	mov	r11,r1
80002d7c:	40 0c       	lddsp	r12,sp[0x0]
80002d7e:	f0 1f 00 11 	mcall	80002dc0 <data_flash_write+0xec>
80002d82:	e4 c2 f0 00 	sub	r2,r2,-4096
		}
		if(data_length==secremain)break;//写入结束了
80002d86:	0e 98       	mov	r8,r7
80002d88:	ee 05 19 00 	cp.h	r5,r7
80002d8c:	c1 20       	breq	80002db0 <data_flash_write+0xdc>
		else//写入未结束
		{
			secpos++;//扇区地址增1
			secoff=0;//偏移位置为0

			data_ptr+=secremain;  //指针偏移
80002d8e:	5c 78       	castu.h	r8
80002d90:	40 0a       	lddsp	r10,sp[0x0]
80002d92:	10 0a       	add	r10,r8
80002d94:	50 0a       	stdsp	sp[0x0],r10
			address+=secremain;//写地址偏移
80002d96:	10 01       	add	r1,r8
			data_length-=secremain;				//字节数递减
80002d98:	0e 15       	sub	r5,r7
80002d9a:	5c 85       	casts.h	r5
80002d9c:	e0 05 19 00 	cp.h	r5,r0
80002da0:	ea 07 17 80 	movls	r7,r5
80002da4:	e0 07 17 b0 	movhi	r7,r0
80002da8:	5c 87       	casts.h	r7
80002daa:	30 09       	mov	r9,0
80002dac:	50 19       	stdsp	sp[0x4],r9
80002dae:	ca db       	rjmp	80002d08 <data_flash_write+0x34>
		}
	}
	
	return return_code;
	
}
80002db0:	2f dd       	sub	sp,-12
80002db2:	d8 32       	popm	r0-r7,pc
80002db4:	00 00       	add	r0,r0
80002db6:	0d 8c       	ld.ub	r12,r6[0x0]
80002db8:	80 00       	ld.sh	r0,r0[0x0]
80002dba:	2a a4       	sub	r4,-86
80002dbc:	80 00       	ld.sh	r0,r0[0x0]
80002dbe:	2c 38       	sub	r8,-61
80002dc0:	80 00       	ld.sh	r0,r0[0x0]
80002dc2:	2b 78       	sub	r8,-73

80002dc4 <data_flash_init>:
* ----------  --------  ----------  --------------------------------------------
* 10-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
void data_flash_init(void)
{
80002dc4:	eb cd 40 c0 	pushm	r6-r7,lr
80002dc8:	20 5d       	sub	sp,20
		.spck_delay   = 0,
		.trans_delay  = 0,
		.stay_act     = 1,
		.spi_mode     = 0,
		.modfdis      = 1
	};
80002dca:	4b f8       	lddpc	r8,80002ec4 <data_flash_init+0x100>
80002dcc:	fa c6 ff fc 	sub	r6,sp,-4
80002dd0:	f0 ea 00 00 	ld.d	r10,r8[0]
80002dd4:	ec eb 00 00 	st.d	r6[0],r10
80002dd8:	f0 e8 00 08 	ld.d	r8,r8[8]
80002ddc:	ec e9 00 08 	st.d	r6[8],r8

	// Assign I/Os to SPI.
	gpio_enable_module(DF_SPI_GPIO_MAP, sizeof(DF_SPI_GPIO_MAP) / sizeof(DF_SPI_GPIO_MAP[0]));
80002de0:	30 4b       	mov	r11,4
80002de2:	4b ac       	lddpc	r12,80002ec8 <data_flash_init+0x104>
80002de4:	f0 1f 00 3a 	mcall	80002ecc <data_flash_init+0x108>

	// Configure PA25 as WP pin - 1: deasserted (allow write) always
	gpio_enable_gpio_pin(AVR32_PIN_PA25);
80002de8:	31 9c       	mov	r12,25
80002dea:	f0 1f 00 3a 	mcall	80002ed0 <data_flash_init+0x10c>
 	gpio_set_gpio_pin(AVR32_PIN_PA25);
80002dee:	31 9c       	mov	r12,25
80002df0:	f0 1f 00 39 	mcall	80002ed4 <data_flash_init+0x110>

	spi = &AVR32_SPI;
80002df4:	4b 97       	lddpc	r7,80002ed8 <data_flash_init+0x114>
80002df6:	fe 7c 24 00 	mov	r12,-56320
80002dfa:	8f 0c       	st.w	r7[0x0],r12

	// Initialize as master.
	spi_initMaster(spi, &spiOptions);
80002dfc:	0c 9b       	mov	r11,r6
80002dfe:	f0 1f 00 38 	mcall	80002edc <data_flash_init+0x118>

	// Set selection mode: variable_ps, pcs_decode, delay.
	spi_selectionMode(spi, 0, 0, 0);
80002e02:	30 09       	mov	r9,0
80002e04:	12 9a       	mov	r10,r9
80002e06:	12 9b       	mov	r11,r9
80002e08:	6e 0c       	ld.w	r12,r7[0x0]
80002e0a:	f0 1f 00 36 	mcall	80002ee0 <data_flash_init+0x11c>

	// Enable SPI.
	spi_enable(spi);
80002e0e:	6e 0c       	ld.w	r12,r7[0x0]
80002e10:	f0 1f 00 35 	mcall	80002ee4 <data_flash_init+0x120>

	// Initialize data flash with SPI clock Osc0.
	if (spi_setupChipReg(spi, &spiOptions, 2*FOSC0) != SPI_OK)
80002e14:	e0 6a 36 00 	mov	r10,13824
80002e18:	ea 1a 01 6e 	orh	r10,0x16e
80002e1c:	0c 9b       	mov	r11,r6
80002e1e:	6e 0c       	ld.w	r12,r7[0x0]
80002e20:	f0 1f 00 32 	mcall	80002ee8 <data_flash_init+0x124>
80002e24:	c0 50       	breq	80002e2e <data_flash_init+0x6a>
	{
		//fatal_error(FATAL_ERROR_DATA_FLASH_SPI_INIT);
		data_flash_failure = FATAL_ERROR_DATA_FLASH_SPI_INIT;
80002e26:	30 29       	mov	r9,2
80002e28:	4b 18       	lddpc	r8,80002eec <data_flash_init+0x128>
80002e2a:	b0 89       	st.b	r8[0x0],r9
		return;
80002e2c:	c4 88       	rjmp	80002ebc <data_flash_init+0xf8>
* 10-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
static Bool data_flash_check_device_id(void)
{
	U16 manufacturer_device_id[2] = {0x5A5A, 0x5A5A};
80002e2e:	1a 96       	mov	r6,sp
80002e30:	30 4a       	mov	r10,4
80002e32:	4b 0b       	lddpc	r11,80002ef0 <data_flash_init+0x12c>
80002e34:	1a 9c       	mov	r12,sp
80002e36:	f0 1f 00 30 	mcall	80002ef4 <data_flash_init+0x130>

	/* DF memory check. */
	/* Select the DF memory to check. */
	spi_selectChip(spi, DF_SPI_PCS_0);
80002e3a:	4a 87       	lddpc	r7,80002ed8 <data_flash_init+0x114>
80002e3c:	30 0b       	mov	r11,0
80002e3e:	6e 0c       	ld.w	r12,r7[0x0]
80002e40:	f0 1f 00 2e 	mcall	80002ef8 <data_flash_init+0x134>

	/* Send the Status Register Read command. */
	spi_write(spi, READ_M_D_ID);
80002e44:	e0 6b 00 9f 	mov	r11,159
80002e48:	6e 0c       	ld.w	r12,r7[0x0]
80002e4a:	f0 1f 00 2d 	mcall	80002efc <data_flash_init+0x138>

	/* Send 2 dummy byte to read the status register. */
	spi_write_dummy();
80002e4e:	e0 6b 00 ff 	mov	r11,255
80002e52:	6e 0c       	ld.w	r12,r7[0x0]
80002e54:	f0 1f 00 2a 	mcall	80002efc <data_flash_init+0x138>
	spi_read(spi, &manufacturer_device_id[0]);
80002e58:	1a 9b       	mov	r11,sp
80002e5a:	6e 0c       	ld.w	r12,r7[0x0]
80002e5c:	f0 1f 00 29 	mcall	80002f00 <data_flash_init+0x13c>
	spi_write_dummy();
80002e60:	e0 6b 00 ff 	mov	r11,255
80002e64:	6e 0c       	ld.w	r12,r7[0x0]
80002e66:	f0 1f 00 26 	mcall	80002efc <data_flash_init+0x138>
	spi_read(spi, &manufacturer_device_id[1]);
80002e6a:	fa cb ff fe 	sub	r11,sp,-2
80002e6e:	6e 0c       	ld.w	r12,r7[0x0]
80002e70:	f0 1f 00 24 	mcall	80002f00 <data_flash_init+0x13c>

	/* Unselect the checked DF memory. */
	spi_unselectChip(spi, DF_SPI_PCS_0);
80002e74:	30 0b       	mov	r11,0
80002e76:	6e 0c       	ld.w	r12,r7[0x0]
80002e78:	f0 1f 00 23 	mcall	80002f04 <data_flash_init+0x140>

	/* Unexpected device ID. */
    if ((manufacturer_device_id[0] != 0x1F) || (manufacturer_device_id[1] != 0x48))
80002e7c:	31 f8       	mov	r8,31
80002e7e:	9a 09       	ld.sh	r9,sp[0x0]
80002e80:	f0 09 19 00 	cp.h	r9,r8
80002e84:	c0 61       	brne	80002e90 <data_flash_init+0xcc>
80002e86:	34 88       	mov	r8,72
80002e88:	9a 19       	ld.sh	r9,sp[0x2]
80002e8a:	f0 09 19 00 	cp.h	r9,r8
80002e8e:	c0 50       	breq	80002e98 <data_flash_init+0xd4>
	}

	if (data_flash_check_device_id() != TRUE)
	{
		//fatal_error(FATAL_ERROR_DATA_FLASH_READ_ID);
		data_flash_failure = FATAL_ERROR_DATA_FLASH_READ_ID;
80002e90:	30 39       	mov	r9,3
80002e92:	49 78       	lddpc	r8,80002eec <data_flash_init+0x128>
80002e94:	b0 89       	st.b	r8[0x0],r9
		return;
80002e96:	c1 38       	rjmp	80002ebc <data_flash_init+0xf8>
	}

	// Set STATUS reg to unprotect all sect
	send_flash_command(WRITE_ENABLE, 0, NULL, 0);
80002e98:	30 09       	mov	r9,0
80002e9a:	12 9a       	mov	r10,r9
80002e9c:	12 9b       	mov	r11,r9
80002e9e:	30 6c       	mov	r12,6
80002ea0:	f0 1f 00 1a 	mcall	80002f08 <data_flash_init+0x144>
	send_flash_command(WRITE_STATUS_REG_BYTE_1, 0, NULL, 0);
80002ea4:	30 09       	mov	r9,0
80002ea6:	12 9a       	mov	r10,r9
80002ea8:	12 9b       	mov	r11,r9
80002eaa:	30 1c       	mov	r12,1
80002eac:	f0 1f 00 17 	mcall	80002f08 <data_flash_init+0x144>
	status = send_flash_command(READ_STATUS_REG, 0, NULL, 0);
80002eb0:	30 09       	mov	r9,0
80002eb2:	12 9a       	mov	r10,r9
80002eb4:	12 9b       	mov	r11,r9
80002eb6:	30 5c       	mov	r12,5
80002eb8:	f0 1f 00 14 	mcall	80002f08 <data_flash_init+0x144>
	
	return;
}
80002ebc:	2f bd       	sub	sp,-20
80002ebe:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002ec2:	00 00       	add	r0,r0
80002ec4:	80 00       	ld.sh	r0,r0[0x0]
80002ec6:	d5 24       	*unknown*
80002ec8:	80 00       	ld.sh	r0,r0[0x0]
80002eca:	d5 38       	*unknown*
80002ecc:	80 00       	ld.sh	r0,r0[0x0]
80002ece:	72 18       	ld.w	r8,r9[0x4]
80002ed0:	80 00       	ld.sh	r0,r0[0x0]
80002ed2:	72 48       	ld.w	r8,r9[0x10]
80002ed4:	80 00       	ld.sh	r0,r0[0x0]
80002ed6:	72 60       	ld.w	r0,r9[0x18]
80002ed8:	00 00       	add	r0,r0
80002eda:	1d 8c       	ld.ub	r12,lr[0x0]
80002edc:	80 00       	ld.sh	r0,r0[0x0]
80002ede:	55 28       	stdsp	sp[0x148],r8
80002ee0:	80 00       	ld.sh	r0,r0[0x0]
80002ee2:	55 60       	stdsp	sp[0x158],r0
80002ee4:	80 00       	ld.sh	r0,r0[0x0]
80002ee6:	56 c0       	stdsp	sp[0x1b0],r0
80002ee8:	80 00       	ld.sh	r0,r0[0x0]
80002eea:	55 fe       	stdsp	sp[0x17c],lr
80002eec:	00 00       	add	r0,r0
80002eee:	0a 60       	and	r0,r5
80002ef0:	80 00       	ld.sh	r0,r0[0x0]
80002ef2:	d5 34       	*unknown*
80002ef4:	80 00       	ld.sh	r0,r0[0x0]
80002ef6:	77 3a       	ld.w	r10,r11[0x4c]
80002ef8:	80 00       	ld.sh	r0,r0[0x0]
80002efa:	55 8c       	stdsp	sp[0x160],r12
80002efc:	80 00       	ld.sh	r0,r0[0x0]
80002efe:	56 c6       	stdsp	sp[0x1b0],r6
80002f00:	80 00       	ld.sh	r0,r0[0x0]
80002f02:	56 e2       	stdsp	sp[0x1b8],r2
80002f04:	80 00       	ld.sh	r0,r0[0x0]
80002f06:	55 d8       	stdsp	sp[0x174],r8
80002f08:	80 00       	ld.sh	r0,r0[0x0]
80002f0a:	28 e8       	sub	r8,-114

80002f0c <CalculateBurst>:
Calls:
Called By: phy_payload_rx
*/

volatile RxAMBEBurstType CalculateBurst(U8 vf_sn)
{
80002f0c:	20 1c       	sub	r12,1
80002f0e:	5c 5c       	castu.b	r12
80002f10:	31 18       	mov	r8,17
80002f12:	f0 0c 18 00 	cp.b	r12,r8
80002f16:	e0 88 00 03 	brls	80002f1c <CalculateBurst+0x10>
80002f1a:	5e fd       	retal	0
80002f1c:	48 28       	lddpc	r8,80002f24 <CalculateBurst+0x18>
80002f1e:	f0 0c 03 2c 	ld.w	r12,r8[r12<<0x2]
			Burst_ID = 0x00;
			return VOICE_WATING;
		
	}
	
}
80002f22:	5e fc       	retal	r12
80002f24:	80 00       	ld.sh	r0,r0[0x0]
80002f26:	d5 60       	acall	0x56

80002f28 <payload_init>:
	Create the corresponding task;
Calls: xTaskCreate--freertos
Called By:app_init -- app.c
*/
void payload_init(void ( *payload_rx_func)(void * ), void ( *payload_tx_func)(void * ) )
{				
80002f28:	d4 01       	pushm	lr
	payload_rx_exec = payload_rx_func;
80002f2a:	48 98       	lddpc	r8,80002f4c <payload_init+0x24>
80002f2c:	91 0c       	st.w	r8[0x0],r12
	payload_tx_exec = payload_tx_func;
80002f2e:	48 98       	lddpc	r8,80002f50 <payload_init+0x28>
80002f30:	91 0b       	st.w	r8[0x0],r11
	
	
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
80002f32:	30 09       	mov	r9,0
80002f34:	1a d9       	st.w	--sp,r9
80002f36:	1a d9       	st.w	--sp,r9
80002f38:	1a d9       	st.w	--sp,r9
80002f3a:	30 28       	mov	r8,2
80002f3c:	e0 6a 04 00 	mov	r10,1024
80002f40:	48 5b       	lddpc	r11,80002f54 <payload_init+0x2c>
80002f42:	48 6c       	lddpc	r12,80002f58 <payload_init+0x30>
80002f44:	f0 1f 00 06 	mcall	80002f5c <payload_init+0x34>
80002f48:	2f dd       	sub	sp,-12
	//,  2
	//,  NULL
	//);
	//
	
}
80002f4a:	d8 02       	popm	pc
80002f4c:	00 00       	add	r0,r0
80002f4e:	0a 64       	and	r4,r5
80002f50:	00 00       	add	r0,r0
80002f52:	0a 68       	and	r8,r5
80002f54:	80 00       	ld.sh	r0,r0[0x0]
80002f56:	db 58       	*unknown*
80002f58:	80 00       	ld.sh	r0,r0[0x0]
80002f5a:	2f 60       	sub	r0,-10
80002f5c:	80 00       	ld.sh	r0,r0[0x0]
80002f5e:	69 bc       	ld.w	r12,r4[0x6c]

80002f60 <payload_rx_process>:
Description: Receive the payload
Calls:
Called By:task
*/
static void payload_rx_process(void * pvParameters)
{
80002f60:	eb cd 40 f8 	pushm	r3-r7,lr
80002f64:	20 1d       	sub	sp,4
	/*To store the elements in the queue*/
	U16  * payload_ptr;
		
	if(NULL ==   phy_payload_frame_rx)
80002f66:	48 e8       	lddpc	r8,80002f9c <payload_rx_process+0x3c>
80002f68:	70 08       	ld.w	r8,r8[0x0]
80002f6a:	58 08       	cp.w	r8,0
80002f6c:	c0 71       	brne	80002f7a <payload_rx_process+0x1a>
	{
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
80002f6e:	30 4b       	mov	r11,4
80002f70:	30 5c       	mov	r12,5
80002f72:	f0 1f 00 0c 	mcall	80002fa0 <payload_rx_process+0x40>
80002f76:	48 a8       	lddpc	r8,80002f9c <payload_rx_process+0x3c>
80002f78:	91 0c       	st.w	r8[0x0],r12
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_rx, &payload_ptr,portMAX_DELAY ))
80002f7a:	48 96       	lddpc	r6,80002f9c <payload_rx_process+0x3c>
80002f7c:	30 05       	mov	r5,0
80002f7e:	3f f4       	mov	r4,-1
		{			
			payload_rx_exec(payload_ptr);//app_payload_rx_proc();
80002f80:	48 93       	lddpc	r3,80002fa4 <payload_rx_process+0x44>
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_rx, &payload_ptr,portMAX_DELAY ))
80002f82:	6c 0c       	ld.w	r12,r6[0x0]
80002f84:	0a 99       	mov	r9,r5
80002f86:	08 9a       	mov	r10,r4
80002f88:	1a 9b       	mov	r11,sp
80002f8a:	f0 1f 00 08 	mcall	80002fa8 <payload_rx_process+0x48>
80002f8e:	58 1c       	cp.w	r12,1
80002f90:	cf 91       	brne	80002f82 <payload_rx_process+0x22>
		{			
			payload_rx_exec(payload_ptr);//app_payload_rx_proc();
80002f92:	66 08       	ld.w	r8,r3[0x0]
80002f94:	40 0c       	lddsp	r12,sp[0x0]
80002f96:	5d 18       	icall	r8
80002f98:	cf 5b       	rjmp	80002f82 <payload_rx_process+0x22>
80002f9a:	00 00       	add	r0,r0
80002f9c:	00 00       	add	r0,r0
80002f9e:	0a 94       	mov	r4,r5
80002fa0:	80 00       	ld.sh	r0,r0[0x0]
80002fa2:	62 e8       	ld.w	r8,r1[0x38]
80002fa4:	00 00       	add	r0,r0
80002fa6:	0a 64       	and	r4,r5
80002fa8:	80 00       	ld.sh	r0,r0[0x0]
80002faa:	5f dc       	srvc	r12

80002fac <set_idle_store_isr>:
{
	xQueueSend(store, &ptr, 0);
}

void set_idle_store_isr(xQueueHandle store, void * ptr)
{
80002fac:	d4 01       	pushm	lr
80002fae:	20 2d       	sub	sp,8
80002fb0:	50 0b       	stdsp	sp[0x0],r11
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002fb2:	30 09       	mov	r9,0
80002fb4:	fa ca ff f8 	sub	r10,sp,-8
80002fb8:	14 d9       	st.w	--r10,r9
	xQueueSendFromISR(store, &ptr, &xHigherPriorityTaskWoken);
80002fba:	1a 9b       	mov	r11,sp
80002fbc:	f0 1f 00 02 	mcall	80002fc4 <set_idle_store_isr+0x18>
}
80002fc0:	2f ed       	sub	sp,-8
80002fc2:	d8 02       	popm	pc
80002fc4:	80 00       	ld.sh	r0,r0[0x0]
80002fc6:	61 98       	ld.w	r8,r0[0x64]

80002fc8 <phy_rx>:
	xQueueSendFromISR -- freertos
Called By: phy_xnl_rx
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
80002fc8:	d4 01       	pushm	lr
80002fca:	20 2d       	sub	sp,8
80002fcc:	50 0c       	stdsp	sp[0x0],r12
	//memcpy(xx, phy_ptr, sizeof(phy_fragment_t));
	//set_phy_idle_isr(&phy_ptr, &xHigherPriorityTaskWoken);
	
	Bool res = FALSE;
	
	if(NULL == phy_ptr)
80002fce:	58 0c       	cp.w	r12,0
80002fd0:	c1 10       	breq	80002ff2 <phy_rx+0x2a>
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
    /*variables are used to store the push result in interrupt*/
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002fd2:	30 08       	mov	r8,0
80002fd4:	50 18       	stdsp	sp[0x4],r8
	if(NULL == phy_ptr)
	{
		return;
	}
	
    U16 phy_ctrl = phy_ptr->xnl_fragment.phy_header.phy_control;
80002fd6:	98 88       	ld.uh	r8,r12[0x0]
80002fd8:	e2 18 f0 00 	andl	r8,0xf000,COH
80002fdc:	e0 48 40 00 	cp.w	r8,16384
80002fe0:	c0 91       	brne	80002ff2 <phy_rx+0x2a>

    if (XCMPXNL_DATA == (phy_ctrl & 0xF000))
    {
        /*push the xnl packet to queue*/
        if( pdTRUE == xQueueSendFromISR(
80002fe2:	48 68       	lddpc	r8,80002ff8 <phy_rx+0x30>
80002fe4:	70 0c       	ld.w	r12,r8[0x0]
80002fe6:	30 09       	mov	r9,0
80002fe8:	fa ca ff fc 	sub	r10,sp,-4
80002fec:	1a 9b       	mov	r11,sp
80002fee:	f0 1f 00 04 	mcall	80002ffc <phy_rx+0x34>
		}	

    }
		
 
}
80002ff2:	2f ed       	sub	sp,-8
80002ff4:	d8 02       	popm	pc
80002ff6:	00 00       	add	r0,r0
80002ff8:	00 00       	add	r0,r0
80002ffa:	0a c4       	st.b	r5++,r4
80002ffc:	80 00       	ld.sh	r0,r0[0x0]
80002ffe:	61 98       	ld.w	r8,r0[0x64]

80003000 <set_idle_store>:
	}
}


void set_idle_store(xQueueHandle store, void * ptr)
{
80003000:	eb cd 40 80 	pushm	r7,lr
80003004:	20 1d       	sub	sp,4
80003006:	fa c7 ff fc 	sub	r7,sp,-4
8000300a:	0e db       	st.w	--r7,r11
	xQueueSend(store, &ptr, 0);
8000300c:	30 09       	mov	r9,0
8000300e:	12 9a       	mov	r10,r9
80003010:	1a 9b       	mov	r11,sp
80003012:	f0 1f 00 03 	mcall	8000301c <set_idle_store+0x1c>
}
80003016:	2f fd       	sub	sp,-4
80003018:	e3 cd 80 80 	ldm	sp++,r7,pc
8000301c:	80 00       	ld.sh	r0,r0[0x0]
8000301e:	61 e8       	ld.w	r8,r0[0x78]

80003020 <phy_tx>:
Calls:   
	xQueueSend -- freertos
Called By: xnl_tx -- xnl.c
*/
void phy_tx(phy_fragment_t * phy)
{	
80003020:	d4 01       	pushm	lr
80003022:	20 1d       	sub	sp,4
80003024:	50 0c       	stdsp	sp[0x0],r12
	
	//phy_fragment_t * phy_ptr = malloc(sizeof(phy_fragment_t));
	//memcpy(phy_ptr, phy, sizeof(phy_fragment_t));
	//log("\n\r T_xcmp:%4x \n\r", phy->xnl_fragment.xnl_payload.xnl_content_data_msg.xcmp_opcode);
	//log("T_xnl-opcode:%4x", xnl->xnl_header.opcode);//log:R_xnl指令	
	if(XCMPXNL_DATA == (phy_ctrl & 0xF000))
80003026:	98 88       	ld.uh	r8,r12[0x0]
80003028:	e2 18 f0 00 	andl	r8,0xf000,COH
8000302c:	e0 48 40 00 	cp.w	r8,16384
80003030:	c0 d1       	brne	8000304a <phy_tx+0x2a>
	{
		/*push the xnl packet to queue to send */
		if(NULL != phy_xnl_frame_tx)
80003032:	49 08       	lddpc	r8,80003070 <phy_tx+0x50>
80003034:	70 08       	ld.w	r8,r8[0x0]
80003036:	58 08       	cp.w	r8,0
80003038:	c1 a0       	breq	8000306c <phy_tx+0x4c>
		{
			if( pdTRUE == xQueueSend(phy_xnl_frame_tx, &phy, 0))
8000303a:	48 e8       	lddpc	r8,80003070 <phy_tx+0x50>
8000303c:	70 0c       	ld.w	r12,r8[0x0]
8000303e:	30 09       	mov	r9,0
80003040:	12 9a       	mov	r10,r9
80003042:	1a 9b       	mov	r11,sp
80003044:	f0 1f 00 0c 	mcall	80003074 <phy_tx+0x54>
80003048:	c1 28       	rjmp	8000306c <phy_tx+0x4c>
		}
	}
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE		
	else if((SPEAKER_DATA == (phy_ctrl & 0xF000))
8000304a:	e0 48 10 00 	cp.w	r8,4096
8000304e:	5f 0a       	sreq	r10
80003050:	e0 48 20 00 	cp.w	r8,8192
80003054:	5f 09       	sreq	r9
80003056:	f5 e9 10 09 	or	r9,r10,r9
8000305a:	c0 71       	brne	80003068 <phy_tx+0x48>
8000305c:	e0 48 50 00 	cp.w	r8,20480
80003060:	c0 40       	breq	80003068 <phy_tx+0x48>
80003062:	e0 48 60 00 	cp.w	r8,24576
80003066:	c0 31       	brne	8000306c <phy_tx+0x4c>
	    || (MIC_DATA  == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_RX == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_TX == (phy_ctrl & 0xF000))
	)
	{		
		if(NULL == phy_payload_frame_tx)
80003068:	48 48       	lddpc	r8,80003078 <phy_tx+0x58>
8000306a:	70 08       	ld.w	r8,r8[0x0]
	
	if(res != TRUE)
	{
		//vPortFree(phy_ptr);
	}
}
8000306c:	2f fd       	sub	sp,-4
8000306e:	d8 02       	popm	pc
80003070:	00 00       	add	r0,r0
80003072:	0a d0       	st.w	--r5,r0
80003074:	80 00       	ld.sh	r0,r0[0x0]
80003076:	61 e8       	ld.w	r8,r0[0x78]
80003078:	00 00       	add	r0,r0
8000307a:	0a c0       	st.b	r5++,r0

8000307c <get_idle_store_isr>:
		return NULL;
	}
}

void * get_idle_store_isr(xQueueHandle store)
{
8000307c:	d4 01       	pushm	lr
8000307e:	20 2d       	sub	sp,8
	void * ptr = NULL;
80003080:	30 08       	mov	r8,0
80003082:	50 18       	stdsp	sp[0x4],r8
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80003084:	50 08       	stdsp	sp[0x0],r8
	
	if(pdTRUE == xQueueReceiveFromISR(store, &ptr, &xHigherPriorityTaskWoken))
80003086:	1a 9a       	mov	r10,sp
80003088:	fa cb ff fc 	sub	r11,sp,-4
8000308c:	f0 1f 00 05 	mcall	800030a0 <get_idle_store_isr+0x24>
80003090:	58 1c       	cp.w	r12,1
80003092:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80003096:	fb fc 00 01 	ld.weq	r12,sp[0x4]
	}
	else
	{
		return NULL;
	}
}
8000309a:	2f ed       	sub	sp,-8
8000309c:	d8 02       	popm	pc
8000309e:	00 00       	add	r0,r0
800030a0:	80 00       	ld.sh	r0,r0[0x0]
800030a2:	5e ec       	retqs	r12

800030a4 <phy_tx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_tx_func( void * ssc)
{
800030a4:	eb cd 40 c0 	pushm	r6-r7,lr
800030a8:	20 1d       	sub	sp,4
800030aa:	18 97       	mov	r7,r12
    if(NULL != phy_xnl_frame_tx)
800030ac:	fe f8 04 70 	ld.w	r8,pc[1136]
800030b0:	70 08       	ld.w	r8,r8[0x0]
800030b2:	58 08       	cp.w	r8,0
800030b4:	c7 40       	breq	8000319c <phy_tx_func+0xf8>
    {
  	  	/*send ssc data in xnl frame*/
  	  	phy_xnl_tx(&(((ssc_fragment_t * )ssc)->xnl_channel));		
800030b6:	18 96       	mov	r6,r12
Called By:phy_tx_func
*/
static void phy_xnl_tx(xnl_channel_t * xnl_tx_channel)
{
	/*variables are used to store the push result in interrupt*/
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
800030b8:	30 08       	mov	r8,0
800030ba:	50 08       	stdsp	sp[0x0],r8
	
	static S16 phy_tx_expexted_length = 0;
	static U8 phy_tx_index = 0;
	
	/*his is the code for handling any outgoing XNL Phy message*/
	switch(phy_tx_state)
800030bc:	fe f8 04 64 	ld.w	r8,pc[1124]
800030c0:	70 08       	ld.w	r8,r8[0x0]
800030c2:	58 18       	cp.w	r8,1
800030c4:	c2 90       	breq	80003116 <phy_tx_func+0x72>
800030c6:	c0 43       	brcs	800030ce <phy_tx_func+0x2a>
800030c8:	58 28       	cp.w	r8,2
800030ca:	c6 91       	brne	8000319c <phy_tx_func+0xf8>
800030cc:	c6 18       	rjmp	8000318e <phy_tx_func+0xea>
	{
		/*Waiting for the send xnl packet*/
		case WAITING_FOR_PHY_TX:			
			if( pdTRUE == xQueueReceiveFromISR(
800030ce:	fe f8 04 4e 	ld.w	r8,pc[1102]
800030d2:	70 0c       	ld.w	r12,r8[0x0]
800030d4:	1a 9a       	mov	r10,sp
800030d6:	fe fb 04 4e 	ld.w	r11,pc[1102]
800030da:	f0 1f 01 14 	mcall	80003528 <phy_tx_func+0x484>
800030de:	58 1c       	cp.w	r12,1
800030e0:	c1 51       	brne	8000310a <phy_tx_func+0x66>
				  phy_xnl_frame_tx
				, &phy_ptr
				, &xHigherPriorityTaskWoken 
			))
			{								
				phy_tx_expexted_length = 
800030e2:	fe f8 04 42 	ld.w	r8,pc[1090]
800030e6:	70 08       	ld.w	r8,r8[0x0]
800030e8:	11 9a       	ld.ub	r10,r8[0x1]
800030ea:	fe f9 04 42 	ld.w	r9,pc[1090]
800030ee:	b2 0a       	st.h	r9[0x0],r10
				*/
				xnl_tx_channel->dword = 
				                   phy_ptr->xnl_fragment.phy_header.phy_control;
				
				/*Transmit 0xABCD0000 | Type/Length.*/
				xnl_tx_channel->dword |= PHYHEADER32;
800030f0:	90 88       	ld.uh	r8,r8[0x0]
800030f2:	ea 18 ab cd 	orh	r8,0xabcd
800030f6:	8f 18       	st.w	r7[0x4],r8
				
				phy_tx_index = 1;
800030f8:	30 19       	mov	r9,1
800030fa:	fe f8 04 36 	ld.w	r8,pc[1078]
800030fe:	b0 89       	st.b	r8[0x0],r9
				phy_tx_state = WRITE_NEXT_DWORD;	
80003100:	30 19       	mov	r9,1
80003102:	fe f8 04 1e 	ld.w	r8,pc[1054]
80003106:	91 09       	st.w	r8[0x0],r9
80003108:	c4 a8       	rjmp	8000319c <phy_tx_func+0xf8>
				/*The new transmission has started.*/
			}
			else
			{
				/*Nothing new to transmit, send an idle frame*/
				xnl_tx_channel->dword = XNL_IDLE;
8000310a:	e0 68 5a 5a 	mov	r8,23130
8000310e:	ea 18 ab cd 	orh	r8,0xabcd
80003112:	8f 18       	st.w	r7[0x4],r8
80003114:	c4 48       	rjmp	8000319c <phy_tx_func+0xf8>
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80003116:	fe f9 04 1a 	ld.w	r9,pc[1050]
8000311a:	13 88       	ld.ub	r8,r9[0x0]
				xnl_tx_channel->dword = XNL_IDLE;
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
8000311c:	fe fa 04 08 	ld.w	r10,pc[1032]
80003120:	74 0a       	ld.w	r10,r10[0x0]
80003122:	f4 08 05 1a 	ld.uh	r10,r10[r8<<0x1]
80003126:	b1 6a       	lsl	r10,0x10
80003128:	99 1a       	st.w	r12[0x4],r10
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
8000312a:	2f f8       	sub	r8,-1
8000312c:	5c 58       	castu.b	r8
8000312e:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
80003130:	fe fa 03 fc 	ld.w	r10,pc[1020]
80003134:	94 09       	ld.sh	r9,r10[0x0]
80003136:	20 29       	sub	r9,2
80003138:	b4 09       	st.h	r10[0x0],r9
			
			/*have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
8000313a:	30 0a       	mov	r10,0
8000313c:	f4 09 19 00 	cp.h	r9,r10
80003140:	e0 89 00 0b 	brgt	80003156 <phy_tx_func+0xb2>
			{
				/*Must immediately send 0x00BA in Slot 4.*/
				xnl_tx_channel->dword |= PHYTERMRIGHT;
80003144:	78 18       	ld.w	r8,r12[0x4]
80003146:	e8 18 00 ba 	orl	r8,0xba
8000314a:	99 18       	st.w	r12[0x4],r8
				
				/*Go back to waiting.*/
				//vPortFree(phy_ptr);
				phy_tx_state = WAITING_FOR_PHY_TX;
8000314c:	30 09       	mov	r9,0
8000314e:	fe f8 03 d2 	ld.w	r8,pc[978]
80003152:	91 09       	st.w	r8[0x0],r9
80003154:	c2 48       	rjmp	8000319c <phy_tx_func+0xf8>
				break;
			}

			/*Have not broken. Transmit 2nd hWord.*/
			xnl_tx_channel->dword |=  phy_ptr->fragment_element[phy_tx_index++];
80003156:	fe f9 03 ce 	ld.w	r9,pc[974]
8000315a:	72 09       	ld.w	r9,r9[0x0]
8000315c:	f2 08 05 19 	ld.uh	r9,r9[r8<<0x1]
80003160:	78 1a       	ld.w	r10,r12[0x4]
80003162:	f5 e9 10 09 	or	r9,r10,r9
80003166:	99 19       	st.w	r12[0x4],r9
80003168:	2f f8       	sub	r8,-1
8000316a:	fe f9 03 c6 	ld.w	r9,pc[966]
8000316e:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
80003170:	fe f9 03 bc 	ld.w	r9,pc[956]
80003174:	92 08       	ld.sh	r8,r9[0x0]
80003176:	20 28       	sub	r8,2
80003178:	b2 08       	st.h	r9[0x0],r8
			
			/*Have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
8000317a:	30 09       	mov	r9,0
8000317c:	f2 08 19 00 	cp.h	r8,r9
80003180:	e0 89 00 0e 	brgt	8000319c <phy_tx_func+0xf8>
			{
				/*Must send 0x00BA0000 next interrupt in Slot 3&4*/
				phy_tx_state = SEND_TAILED;
80003184:	30 29       	mov	r9,2
80003186:	fe f8 03 9a 	ld.w	r8,pc[922]
8000318a:	91 09       	st.w	r8[0x0],r9
8000318c:	c0 88       	rjmp	8000319c <phy_tx_func+0xf8>
			}
			break;

		case SEND_TAILED:
			/*send 0x00BA0000*/
			xnl_tx_channel->dword = PHYTERMLEFT;
8000318e:	fc 18 00 ba 	movh	r8,0xba
80003192:	99 18       	st.w	r12[0x4],r8
			
			/*Go back to waiting.*/	
			//vPortFree(phy_ptr);		
			phy_tx_state = WAITING_FOR_PHY_TX;		
80003194:	30 09       	mov	r9,0
80003196:	fe f8 03 8a 	ld.w	r8,pc[906]
8000319a:	91 09       	st.w	r8[0x0],r9
	
	//static U8 frame_5_end = 0;
	//static U16 pay[256];
	
	//Send-AMBE-data
	if ((AMBE_Media == TRUE))
8000319c:	fe f8 03 98 	ld.w	r8,pc[920]
800031a0:	11 89       	ld.ub	r9,r8[0x0]
800031a2:	30 18       	mov	r8,1
800031a4:	f0 09 18 00 	cp.b	r9,r8
800031a8:	e0 81 01 af 	brne	80003506 <phy_tx_func+0x462>
	{
		A_index = (A_index >=1456) ? 0 : A_index;
800031ac:	fe f8 03 8c 	ld.w	r8,pc[908]
800031b0:	70 08       	ld.w	r8,r8[0x0]
800031b2:	e0 48 05 b0 	cp.w	r8,1456
800031b6:	f9 b8 02 00 	movhs	r8,0
800031ba:	fe f9 03 7e 	ld.w	r9,pc[894]
800031be:	93 08       	st.w	r9[0x0],r8
	  //AMBE_flag
		switch(AMBEpayload_tx_state)
800031c0:	fe f8 03 7c 	ld.w	r8,pc[892]
800031c4:	70 08       	ld.w	r8,r8[0x0]
800031c6:	58 68       	cp.w	r8,6
800031c8:	e0 8b 01 95 	brhi	800034f2 <phy_tx_func+0x44e>
800031cc:	fe f9 03 74 	ld.w	r9,pc[884]
800031d0:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
		{
			case AMBE_IDLE:
		
				if ((m_RxBurstType == VOICE_WATING) || (m_RxBurstType == VOICETERMINATOR)  || (m_RxBurstType == VOICEHEADER))
800031d4:	fe f8 03 70 	ld.w	r8,pc[880]
800031d8:	70 08       	ld.w	r8,r8[0x0]
800031da:	58 08       	cp.w	r8,0
800031dc:	c0 b0       	breq	800031f2 <phy_tx_func+0x14e>
800031de:	fe f8 03 66 	ld.w	r8,pc[870]
800031e2:	70 08       	ld.w	r8,r8[0x0]
800031e4:	58 a8       	cp.w	r8,10
800031e6:	c0 60       	breq	800031f2 <phy_tx_func+0x14e>
800031e8:	fe f8 03 5c 	ld.w	r8,pc[860]
800031ec:	70 08       	ld.w	r8,r8[0x0]
800031ee:	58 18       	cp.w	r8,1
800031f0:	c0 a1       	brne	80003204 <phy_tx_func+0x160>
				{
							
					payload_tx_channel->dword[0] = PAYLOADIDLE0;
800031f2:	e0 68 5a 5a 	mov	r8,23130
800031f6:	ea 18 ab cd 	orh	r8,0xabcd
800031fa:	8f 28       	st.w	r7[0x8],r8
					payload_tx_channel->dword[1] = PAYLOADIDLE1;
800031fc:	30 08       	mov	r8,0
800031fe:	8f 38       	st.w	r7[0xc],r8
80003200:	e0 8f 01 8a 	bral	80003514 <phy_tx_func+0x470>
			
				}
				else if((m_RxBurstType == UNSUREDATA))
80003204:	fe f8 03 40 	ld.w	r8,pc[832]
80003208:	70 08       	ld.w	r8,r8[0x0]
8000320a:	58 38       	cp.w	r8,3
8000320c:	c0 91       	brne	8000321e <phy_tx_func+0x17a>
				{
					payload_tx_channel->dword[0] = AMBE_HT[0];
8000320e:	fe f8 03 3a 	ld.w	r8,pc[826]
80003212:	70 09       	ld.w	r9,r8[0x0]
80003214:	8f 29       	st.w	r7[0x8],r9
					payload_tx_channel->dword[1] = AMBE_HT[1];
80003216:	70 18       	ld.w	r8,r8[0x4]
80003218:	8f 38       	st.w	r7[0xc],r8
8000321a:	e0 8f 01 7d 	bral	80003514 <phy_tx_func+0x470>
				else//加密和解密的激励类型
				{
					
					//Radio Internal Parameter + Vocoder Bits Stream Parameter + soft decision value + 1st 20ms AMBE bits of Voice Burst A 
					//assemble 4 items into 1 Command. Send it to Radio.
					if (m_RxBurstType == RADIOINTERNAL)//解密数据
8000321e:	fe f8 03 26 	ld.w	r8,pc[806]
80003222:	70 08       	ld.w	r8,r8[0x0]
80003224:	58 28       	cp.w	r8,2
80003226:	c1 31       	brne	8000324c <phy_tx_func+0x1a8>
					{
						//0xABCDCO32
						payload_tx_channel->dword[0] = DE_OB_PAYLOAD;//50bytes
80003228:	e0 68 c0 32 	mov	r8,49202
8000322c:	ea 18 ab cd 	orh	r8,0xabcd
80003230:	8f 28       	st.w	r7[0x8],r8
						//0x847F
						payload_tx_channel->word[2] = RIP_PAYLOAD;
80003232:	fe 78 84 7f 	mov	r8,-31617
80003236:	ae 68       	st.h	r7[0xc],r8
						//0xxxxx
						payload_tx_channel->word[3] = Radio_Internal_Data[0];
80003238:	fe f8 03 14 	ld.w	r8,pc[788]
8000323c:	90 08       	ld.sh	r8,r8[0x0]
8000323e:	ae 78       	st.h	r7[0xe],r8
						
						AMBEpayload_tx_state = AMBE_DE_FIRST;
80003240:	30 39       	mov	r9,3
80003242:	fe f8 02 fa 	ld.w	r8,pc[762]
80003246:	91 09       	st.w	r8[0x0],r9
80003248:	e0 8f 01 66 	bral	80003514 <phy_tx_func+0x470>
					//assemble 2 items into 1 Command. Send it to Radio.
					else//加密数据
					{
	
						//0xABCDCOOE
						payload_tx_channel->dword[0] = EN_OB_PAYLOAD;//49bits
8000324c:	e0 68 c0 0e 	mov	r8,49166
80003250:	ea 18 ab cd 	orh	r8,0xabcd
80003254:	8f 28       	st.w	r7[0x8],r8
						//0x8212
						payload_tx_channel->word[2] = VBSP_data[0];
80003256:	fe f8 02 fa 	ld.w	r8,pc[762]
8000325a:	90 09       	ld.sh	r9,r8[0x0]
8000325c:	ae 69       	st.h	r7[0xc],r9
						//0xF00x
						payload_tx_channel->word[3] = VBSP_data[1];
8000325e:	90 18       	ld.sh	r8,r8[0x2]
80003260:	ae 78       	st.h	r7[0xe],r8
						
						AMBEpayload_tx_state = AMBE_EN_FIRST;
80003262:	30 19       	mov	r9,1
80003264:	fe f8 02 d8 	ld.w	r8,pc[728]
80003268:	91 09       	st.w	r8[0x0],r9
8000326a:	e0 8f 01 55 	bral	80003514 <phy_tx_func+0x470>
			
			case AMBE_EN_FIRST:
			
			
				//0x88F2
				payload_tx_channel->word[0] = ENCODER_PAYLOAD;//49bits
8000326e:	fe 78 88 f2 	mov	r8,-30478
80003272:	ae 48       	st.h	r7[0x8],r8
				//A_index+=2;
				//
				//AMBEpayload_tx_state = AMBE_EN_LAST;
				
			
				switch (m_RxBurstType)//在发送函数中去做加密处理
80003274:	fe f8 02 d0 	ld.w	r8,pc[720]
80003278:	70 08       	ld.w	r8,r8[0x0]
8000327a:	58 48       	cp.w	r8,4
8000327c:	c0 60       	breq	80003288 <phy_tx_func+0x1e4>
8000327e:	c4 53       	brcs	80003308 <phy_tx_func+0x264>
80003280:	58 98       	cp.w	r8,9
80003282:	e0 8b 00 43 	brhi	80003308 <phy_tx_func+0x264>
80003286:	c2 98       	rjmp	800032d8 <phy_tx_func+0x234>
				{
					case VOICEBURST_A:
							if (VF_SN == 1)
80003288:	fe f8 02 cc 	ld.w	r8,pc[716]
8000328c:	11 89       	ld.ub	r9,r8[0x0]
8000328e:	30 18       	mov	r8,1
80003290:	f0 09 18 00 	cp.b	r9,r8
80003294:	c0 a1       	brne	800032a8 <phy_tx_func+0x204>
							{	
								
								
								//Place public key
								payload_tx_channel->word[1] = Public_AMBEkey[0];
80003296:	fe f8 02 c2 	ld.w	r8,pc[706]
8000329a:	90 09       	ld.sh	r9,r8[0x0]
8000329c:	ae 59       	st.h	r7[0xa],r9
								payload_tx_channel->word[2] = Public_AMBEkey[1];
8000329e:	90 19       	ld.sh	r9,r8[0x2]
800032a0:	ae 69       	st.h	r7[0xc],r9
								payload_tx_channel->word[3] = Public_AMBEkey[2];
800032a2:	90 28       	ld.sh	r8,r8[0x4]
800032a4:	ae 78       	st.h	r7[0xe],r8
800032a6:	c1 48       	rjmp	800032ce <phy_tx_func+0x22a>
							{
								
								
						
								//Encrypted AMBE data(XOR)
								payload_tx_channel->word[1] = ((Public_AMBEkey[0]) ^ (AMBEBurst_rawdata[0])) ;
800032a8:	fe f9 02 b4 	ld.w	r9,pc[692]
800032ac:	92 0b       	ld.sh	r11,r9[0x0]
800032ae:	fe f8 02 aa 	ld.w	r8,pc[682]
800032b2:	90 0a       	ld.sh	r10,r8[0x0]
800032b4:	f7 ea 20 0a 	eor	r10,r11,r10
800032b8:	ae 5a       	st.h	r7[0xa],r10
								payload_tx_channel->word[2] = ((Public_AMBEkey[1]) ^ (AMBEBurst_rawdata[1])) ;
800032ba:	92 1b       	ld.sh	r11,r9[0x2]
800032bc:	90 1a       	ld.sh	r10,r8[0x2]
800032be:	f7 ea 20 0a 	eor	r10,r11,r10
800032c2:	ae 6a       	st.h	r7[0xc],r10
								payload_tx_channel->word[3] = ((Public_AMBEkey[2]) ^ (AMBEBurst_rawdata[2])) ;
800032c4:	92 29       	ld.sh	r9,r9[0x4]
800032c6:	90 28       	ld.sh	r8,r8[0x4]
800032c8:	f3 e8 20 08 	eor	r8,r9,r8
800032cc:	ae 78       	st.h	r7[0xe],r8
								//payload_tx_channel->word[3] = AMBEBurst_rawdata[2];
							
						
							}
					
							AMBEpayload_tx_state = AMBE_EN_LAST;
800032ce:	30 29       	mov	r9,2
800032d0:	fe f8 02 6c 	ld.w	r8,pc[620]
800032d4:	91 09       	st.w	r8[0x0],r9
800032d6:	c1 f9       	rjmp	80003514 <phy_tx_func+0x470>
							//Encrypted AMBE data(XOR)
						
							//payload_tx_channel->word[1] = AMBEBurst_rawdata[0];
							//payload_tx_channel->word[2] = AMBEBurst_rawdata[1];
							//payload_tx_channel->word[3] = AMBEBurst_rawdata[2];
							payload_tx_channel->word[1] = ((Public_AMBEkey[0]) ^ (AMBEBurst_rawdata[0])) ;
800032d8:	fe f9 02 84 	ld.w	r9,pc[644]
800032dc:	92 0b       	ld.sh	r11,r9[0x0]
800032de:	fe f8 02 7a 	ld.w	r8,pc[634]
800032e2:	90 0a       	ld.sh	r10,r8[0x0]
800032e4:	f7 ea 20 0a 	eor	r10,r11,r10
800032e8:	ae 5a       	st.h	r7[0xa],r10
							payload_tx_channel->word[2] = ((Public_AMBEkey[1]) ^ (AMBEBurst_rawdata[1])) ;
800032ea:	92 1b       	ld.sh	r11,r9[0x2]
800032ec:	90 1a       	ld.sh	r10,r8[0x2]
800032ee:	f7 ea 20 0a 	eor	r10,r11,r10
800032f2:	ae 6a       	st.h	r7[0xc],r10
							payload_tx_channel->word[3] = ((Public_AMBEkey[2]) ^ (AMBEBurst_rawdata[2])) ;
800032f4:	92 29       	ld.sh	r9,r9[0x4]
800032f6:	90 28       	ld.sh	r8,r8[0x4]
800032f8:	f3 e8 20 08 	eor	r8,r9,r8
800032fc:	ae 78       	st.h	r7[0xe],r8
						
							AMBEpayload_tx_state = AMBE_EN_LAST;
800032fe:	30 29       	mov	r9,2
80003300:	fe f8 02 3c 	ld.w	r8,pc[572]
80003304:	91 09       	st.w	r8[0x0],r9
80003306:	c0 79       	rjmp	80003514 <phy_tx_func+0x470>
				
						break;
					default://This shouldn't happen, but must check;
					
							payload_tx_channel->dword[0] = PAYLOADIDLE0;
80003308:	e0 68 5a 5a 	mov	r8,23130
8000330c:	ea 18 ab cd 	orh	r8,0xabcd
80003310:	8f 28       	st.w	r7[0x8],r8
							payload_tx_channel->dword[1] = PAYLOADIDLE1;
80003312:	30 08       	mov	r8,0
80003314:	8f 38       	st.w	r7[0xc],r8
							
							AMBEpayload_tx_state = AMBE_IDLE;
80003316:	fe f9 02 26 	ld.w	r9,pc[550]
8000331a:	93 08       	st.w	r9[0x0],r8
8000331c:	cf c8       	rjmp	80003514 <phy_tx_func+0x470>
						  1:VF1 of first Burst A after last Voice Header (49 bits).
						  2:Last 4 bits (bit 45 to bit 48) of every 49 bits AMBE Voice Frame. (72 bits@Super Frame).
					
					*/
					
					payload_tx_channel->word[0] = AMBEBurst_rawdata[3];
8000331e:	fe f8 02 3e 	ld.w	r8,pc[574]
80003322:	90 38       	ld.sh	r8,r8[0x6]
80003324:	ae 48       	st.h	r7[0x8],r8
					
					
					//payload_tx_channel->word[0] = ((AMBE_AudioData[A_index]<<8) + 0x00) ;//需要补充Pad_bits位
					//A_index+=1;
					
					payload_tx_channel->word[1]	= 0x00BA ; 
80003326:	e0 68 00 ba 	mov	r8,186
8000332a:	ae 58       	st.h	r7[0xa],r8
					payload_tx_channel->word[2]	= 0x0000 ;
8000332c:	30 08       	mov	r8,0
8000332e:	ae 68       	st.h	r7[0xc],r8
					payload_tx_channel->word[3]	= 0x0000 ;
80003330:	ae 78       	st.h	r7[0xe],r8
				
					AMBEpayload_tx_state = AMBE_IDLE;
80003332:	30 09       	mov	r9,0
80003334:	fe f8 02 08 	ld.w	r8,pc[520]
80003338:	91 09       	st.w	r8[0x0],r9
8000333a:	ce d8       	rjmp	80003514 <phy_tx_func+0x470>
				break;
				
			case AMBE_DE_FIRST:
				
					//0xxxxx
					payload_tx_channel->word[0] = Radio_Internal_Data[1];
8000333c:	fe f8 02 10 	ld.w	r8,pc[528]
80003340:	90 18       	ld.sh	r8,r8[0x2]
80003342:	ae 48       	st.h	r7[0x8],r8
					//0x8212
					payload_tx_channel->word[1] = VBSP_data[0];
80003344:	fe f8 02 0c 	ld.w	r8,pc[524]
80003348:	90 08       	ld.sh	r8,r8[0x0]
8000334a:	ae 58       	st.h	r7[0xa],r8
					
					if ((m_RxBurstType == VOICEBURST_A) && (VF_SN == 1) )
8000334c:	4f e8       	lddpc	r8,80003544 <phy_tx_func+0x4a0>
8000334e:	70 08       	ld.w	r8,r8[0x0]
80003350:	58 48       	cp.w	r8,4
80003352:	c0 d1       	brne	8000336c <phy_tx_func+0x2c8>
80003354:	fe f8 02 00 	ld.w	r8,pc[512]
80003358:	11 89       	ld.ub	r9,r8[0x0]
8000335a:	30 18       	mov	r8,1
8000335c:	f0 09 18 00 	cp.b	r9,r8
80003360:	c0 61       	brne	8000336c <phy_tx_func+0x2c8>
					{
						// Vocoder Bits Stream Parameter("E(bit8)" flag = 1)
						//0xF0(8+)x
						payload_tx_channel->word[2] = ((VBSP_data[1]) | (0x0100));
80003362:	4f c8       	lddpc	r8,80003550 <phy_tx_func+0x4ac>
80003364:	90 18       	ld.sh	r8,r8[0x2]
80003366:	a9 a8       	sbr	r8,0x8
80003368:	ae 68       	st.h	r7[0xc],r8
8000336a:	c0 48       	rjmp	80003372 <phy_tx_func+0x2ce>
					}
					else
						//0xF00x
						payload_tx_channel->word[2] = (VBSP_data[1]) ;
8000336c:	4f 98       	lddpc	r8,80003550 <phy_tx_func+0x4ac>
8000336e:	90 18       	ld.sh	r8,r8[0x2]
80003370:	ae 68       	st.h	r7[0xc],r8
					
					//0x9A13
					payload_tx_channel->word[3] = SDV_PAYLOAD;
80003372:	fe 78 9a 13 	mov	r8,-26093
80003376:	ae 78       	st.h	r7[0xe],r8
		
					AMBEpayload_tx_state = AMBE_DE_SECOND;
80003378:	30 49       	mov	r9,4
8000337a:	4f 18       	lddpc	r8,8000353c <phy_tx_func+0x498>
8000337c:	91 09       	st.w	r8[0x0],r9
8000337e:	cc b8       	rjmp	80003514 <phy_tx_func+0x470>
				break;
			
			case AMBE_DE_SECOND:
					//Post back soft decision value data

						payload_tx_channel->word[0] = Soft_Decision_Data[Soft_index] ;
80003380:	4f 88       	lddpc	r8,80003560 <phy_tx_func+0x4bc>
80003382:	70 0a       	ld.w	r10,r8[0x0]
80003384:	4f 89       	lddpc	r9,80003564 <phy_tx_func+0x4c0>
80003386:	f2 0a 04 1a 	ld.sh	r10,r9[r10<<0x1]
8000338a:	ae 4a       	st.h	r7[0x8],r10
						payload_tx_channel->word[1] = Soft_Decision_Data[Soft_index+1] ;
8000338c:	70 0a       	ld.w	r10,r8[0x0]
8000338e:	2f fa       	sub	r10,-1
80003390:	f2 0a 04 1a 	ld.sh	r10,r9[r10<<0x1]
80003394:	ae 5a       	st.h	r7[0xa],r10
						payload_tx_channel->word[2] = Soft_Decision_Data[Soft_index+2] ;
80003396:	70 0a       	ld.w	r10,r8[0x0]
80003398:	2f ea       	sub	r10,-2
8000339a:	f2 0a 04 1a 	ld.sh	r10,r9[r10<<0x1]
8000339e:	ae 6a       	st.h	r7[0xc],r10
						payload_tx_channel->word[3] = Soft_Decision_Data[Soft_index+3] ;
800033a0:	70 0a       	ld.w	r10,r8[0x0]
800033a2:	2f da       	sub	r10,-3
800033a4:	f2 0a 04 19 	ld.sh	r9,r9[r10<<0x1]
800033a8:	ae 79       	st.h	r7[0xe],r9
						Soft_index +=4;
800033aa:	70 09       	ld.w	r9,r8[0x0]
800033ac:	2f c9       	sub	r9,-4
800033ae:	91 09       	st.w	r8[0x0],r9
						
						if (Soft_index == 12)
800033b0:	58 c9       	cp.w	r9,12
800033b2:	c0 51       	brne	800033bc <phy_tx_func+0x318>
						{
							AMBEpayload_tx_state = AMBE_DE_THIRD;
800033b4:	30 59       	mov	r9,5
800033b6:	4e 28       	lddpc	r8,8000353c <phy_tx_func+0x498>
800033b8:	91 09       	st.w	r8[0x0],r9
800033ba:	ca d8       	rjmp	80003514 <phy_tx_func+0x470>
							//Soft_index = 0 ;
							
						}
						else
						AMBEpayload_tx_state = AMBE_DE_SECOND;
800033bc:	30 49       	mov	r9,4
800033be:	4e 08       	lddpc	r8,8000353c <phy_tx_func+0x498>
800033c0:	91 09       	st.w	r8[0x0],r9
800033c2:	ca 98       	rjmp	80003514 <phy_tx_func+0x470>
				break;	
				
			case AMBE_DE_THIRD:
					
					//0x xxxx
					payload_tx_channel->word[0] = Soft_Decision_Data[Soft_index] ;
800033c4:	4e 78       	lddpc	r8,80003560 <phy_tx_func+0x4bc>
800033c6:	70 0a       	ld.w	r10,r8[0x0]
800033c8:	4e 79       	lddpc	r9,80003564 <phy_tx_func+0x4c0>
800033ca:	f2 0a 04 19 	ld.sh	r9,r9[r10<<0x1]
800033ce:	ae 49       	st.h	r7[0x8],r9
					Soft_index = 0 ;//索引清零
800033d0:	30 09       	mov	r9,0
800033d2:	91 09       	st.w	r8[0x0],r9
					
					//0x8003 隔离符号？
					payload_tx_channel->word[1] = 0x8003;
800033d4:	fe 78 80 03 	mov	r8,-32765
800033d8:	ae 58       	st.h	r7[0xa],r8
					//0x88F3
					payload_tx_channel->word[2] = DECODER_PAYLOAD;
800033da:	fe 78 88 f3 	mov	r8,-30477
800033de:	ae 68       	st.h	r7[0xc],r8
				
					switch (m_RxBurstType)//在发送函数中去做解密处理
800033e0:	4d 98       	lddpc	r8,80003544 <phy_tx_func+0x4a0>
800033e2:	70 08       	ld.w	r8,r8[0x0]
800033e4:	58 48       	cp.w	r8,4
800033e6:	c0 60       	breq	800033f2 <phy_tx_func+0x34e>
800033e8:	c2 83       	brcs	80003438 <phy_tx_func+0x394>
800033ea:	58 98       	cp.w	r8,9
800033ec:	e0 8b 00 26 	brhi	80003438 <phy_tx_func+0x394>
800033f0:	c1 98       	rjmp	80003422 <phy_tx_func+0x37e>
					{
						case VOICEBURST_A:
								if (VF_SN == 1)
800033f2:	4d 98       	lddpc	r8,80003554 <phy_tx_func+0x4b0>
800033f4:	11 89       	ld.ub	r9,r8[0x0]
800033f6:	30 18       	mov	r8,1
800033f8:	f0 09 18 00 	cp.b	r9,r8
800033fc:	c0 81       	brne	8000340c <phy_tx_func+0x368>
									//if(AMBEBurst_rawdata[0] == Public_AMBEkey[0])//0X1AC3
									{
										
									
										//Pick up public key
										AMBE_DecryptionKey[0] = AMBEBurst_rawdata[0];
800033fe:	4d 88       	lddpc	r8,8000355c <phy_tx_func+0x4b8>
80003400:	90 0a       	ld.sh	r10,r8[0x0]
80003402:	4d a9       	lddpc	r9,80003568 <phy_tx_func+0x4c4>
80003404:	b2 0a       	st.h	r9[0x0],r10
									
										//Post back data
										payload_tx_channel->word[3] = AMBEBurst_rawdata[0] ;
80003406:	90 08       	ld.sh	r8,r8[0x0]
80003408:	ae 78       	st.h	r7[0xe],r8
8000340a:	c0 88       	rjmp	8000341a <phy_tx_func+0x376>
								else//VF_SN==2/3
								{	
									//Decrypt AMBE data(XOR) 
									//Recover data

									payload_tx_channel->word[3] = ((AMBE_DecryptionKey[0]) ^ (AMBEBurst_rawdata[0])) ;
8000340c:	4d 78       	lddpc	r8,80003568 <phy_tx_func+0x4c4>
8000340e:	90 08       	ld.sh	r8,r8[0x0]
80003410:	4d 39       	lddpc	r9,8000355c <phy_tx_func+0x4b8>
80003412:	92 09       	ld.sh	r9,r9[0x0]
80003414:	f3 e8 20 08 	eor	r8,r9,r8
80003418:	ae 78       	st.h	r7[0xe],r8
									
									//payload_tx_channel->word[3] = ((AMBEBurst_rawdata[0])) ;
						
								}
					
								AMBEpayload_tx_state = AMBE_DE_LAST;
8000341a:	30 69       	mov	r9,6
8000341c:	4c 88       	lddpc	r8,8000353c <phy_tx_func+0x498>
8000341e:	91 09       	st.w	r8[0x0],r9
80003420:	c7 a8       	rjmp	80003514 <phy_tx_func+0x470>
						
								//Encrypted AMBE data(XOR)
						
								//Decrypt AMBE data(XOR)
								//Recover data
								payload_tx_channel->word[3] = ((AMBE_DecryptionKey[0]) ^ (AMBEBurst_rawdata[0])) ;
80003422:	4d 28       	lddpc	r8,80003568 <phy_tx_func+0x4c4>
80003424:	90 08       	ld.sh	r8,r8[0x0]
80003426:	4c e9       	lddpc	r9,8000355c <phy_tx_func+0x4b8>
80003428:	92 09       	ld.sh	r9,r9[0x0]
8000342a:	f3 e8 20 08 	eor	r8,r9,r8
8000342e:	ae 78       	st.h	r7[0xe],r8
								//payload_tx_channel->word[3] = ((AMBEBurst_rawdata[0])) ;
						
								AMBEpayload_tx_state = AMBE_DE_LAST;
80003430:	30 69       	mov	r9,6
80003432:	4c 38       	lddpc	r8,8000353c <phy_tx_func+0x498>
80003434:	91 09       	st.w	r8[0x0],r9
80003436:	c6 f8       	rjmp	80003514 <phy_tx_func+0x470>
				
							break;
						default://This shouldn't happen, but must check;
					
								payload_tx_channel->dword[0] = PAYLOADIDLE0;
80003438:	e0 68 5a 5a 	mov	r8,23130
8000343c:	ea 18 ab cd 	orh	r8,0xabcd
80003440:	8f 28       	st.w	r7[0x8],r8
								payload_tx_channel->dword[1] = PAYLOADIDLE1;
80003442:	30 08       	mov	r8,0
80003444:	8f 38       	st.w	r7[0xc],r8
								AMBEpayload_tx_state = AMBE_IDLE;
80003446:	4b e9       	lddpc	r9,8000353c <phy_tx_func+0x498>
80003448:	93 08       	st.w	r9[0x0],r8
8000344a:	c6 58       	rjmp	80003514 <phy_tx_func+0x470>
		
					break;
				
			case AMBE_DE_LAST:
				
					switch (m_RxBurstType)//在发送函数中去做解密处理
8000344c:	4b e8       	lddpc	r8,80003544 <phy_tx_func+0x4a0>
8000344e:	70 08       	ld.w	r8,r8[0x0]
80003450:	58 48       	cp.w	r8,4
80003452:	c0 60       	breq	8000345e <phy_tx_func+0x3ba>
80003454:	c4 53       	brcs	800034de <phy_tx_func+0x43a>
80003456:	58 98       	cp.w	r8,9
80003458:	e0 8b 00 43 	brhi	800034de <phy_tx_func+0x43a>
8000345c:	c2 d8       	rjmp	800034b6 <phy_tx_func+0x412>
					{
						case VOICEBURST_A:
							if (VF_SN == 1)
8000345e:	4b e8       	lddpc	r8,80003554 <phy_tx_func+0x4b0>
80003460:	11 89       	ld.ub	r9,r8[0x0]
80003462:	30 18       	mov	r8,1
80003464:	f0 09 18 00 	cp.b	r9,r8
80003468:	c1 31       	brne	8000348e <phy_tx_func+0x3ea>
								//if(AMBEBurst_rawdata[1] == Public_AMBEkey[1])//0X1840
								{
								
									//Pick up public key
							
									AMBE_DecryptionKey[1] = AMBEBurst_rawdata[1];
8000346a:	4b d8       	lddpc	r8,8000355c <phy_tx_func+0x4b8>
8000346c:	90 1a       	ld.sh	r10,r8[0x2]
8000346e:	4b f9       	lddpc	r9,80003568 <phy_tx_func+0x4c4>
80003470:	b2 1a       	st.h	r9[0x2],r10
									AMBE_DecryptionKey[2] = AMBEBurst_rawdata[2];
80003472:	90 2a       	ld.sh	r10,r8[0x4]
80003474:	b2 2a       	st.h	r9[0x4],r10
									AMBE_DecryptionKey[3] = AMBEBurst_rawdata[3];
80003476:	90 3a       	ld.sh	r10,r8[0x6]
80003478:	b2 3a       	st.h	r9[0x6],r10
							
									//Post back data
									payload_tx_channel->word[0] = AMBEBurst_rawdata[1] ;
8000347a:	90 19       	ld.sh	r9,r8[0x2]
8000347c:	ae 49       	st.h	r7[0x8],r9
									payload_tx_channel->word[1] = AMBEBurst_rawdata[2] ;
8000347e:	90 29       	ld.sh	r9,r8[0x4]
80003480:	ae 59       	st.h	r7[0xa],r9
									payload_tx_channel->word[2] = AMBEBurst_rawdata[3] ;
80003482:	90 38       	ld.sh	r8,r8[0x6]
80003484:	ae 68       	st.h	r7[0xc],r8
									payload_tx_channel->word[3] = 0x00BA ;
80003486:	e0 68 00 ba 	mov	r8,186
8000348a:	ae 78       	st.h	r7[0xe],r8
8000348c:	c1 18       	rjmp	800034ae <phy_tx_func+0x40a>
							{
							
								//Decrypt AMBE data(XOR)
								//Recover data

									payload_tx_channel->word[0] = (AMBEBurst_rawdata[1] ^ AMBE_DecryptionKey[1]);
8000348e:	4b 48       	lddpc	r8,8000355c <phy_tx_func+0x4b8>
80003490:	90 1a       	ld.sh	r10,r8[0x2]
80003492:	4b 69       	lddpc	r9,80003568 <phy_tx_func+0x4c4>
80003494:	92 1b       	ld.sh	r11,r9[0x2]
80003496:	f7 ea 20 0a 	eor	r10,r11,r10
8000349a:	ae 4a       	st.h	r7[0x8],r10
									payload_tx_channel->word[1] = (AMBEBurst_rawdata[2] ^ AMBE_DecryptionKey[2]);
8000349c:	90 2a       	ld.sh	r10,r8[0x4]
8000349e:	92 29       	ld.sh	r9,r9[0x4]
800034a0:	14 59       	eor	r9,r10
800034a2:	ae 59       	st.h	r7[0xa],r9
									payload_tx_channel->word[2] = (AMBEBurst_rawdata[3]);
800034a4:	90 38       	ld.sh	r8,r8[0x6]
800034a6:	ae 68       	st.h	r7[0xc],r8
									
									//payload_tx_channel->word[0] = (AMBEBurst_rawdata[1]);
									//payload_tx_channel->word[1] = (AMBEBurst_rawdata[2]);
									//payload_tx_channel->word[2] = (AMBEBurst_rawdata[3]);
									
									payload_tx_channel->word[3] = 0x00BA ;
800034a8:	e0 68 00 ba 	mov	r8,186
800034ac:	ae 78       	st.h	r7[0xe],r8
							
							
							}
						
							AMBEpayload_tx_state = AMBE_IDLE;
800034ae:	30 09       	mov	r9,0
800034b0:	4a 38       	lddpc	r8,8000353c <phy_tx_func+0x498>
800034b2:	91 09       	st.w	r8[0x0],r9
800034b4:	c3 08       	rjmp	80003514 <phy_tx_func+0x470>
						
							//Encrypted AMBE data(XOR)
						
							//Decrypt AMBE data(XOR)
							//Recover data
							payload_tx_channel->word[0] = (AMBEBurst_rawdata[1] ^ AMBE_DecryptionKey[1]);
800034b6:	4a a8       	lddpc	r8,8000355c <phy_tx_func+0x4b8>
800034b8:	90 1a       	ld.sh	r10,r8[0x2]
800034ba:	4a c9       	lddpc	r9,80003568 <phy_tx_func+0x4c4>
800034bc:	92 1b       	ld.sh	r11,r9[0x2]
800034be:	f7 ea 20 0a 	eor	r10,r11,r10
800034c2:	ae 4a       	st.h	r7[0x8],r10
							payload_tx_channel->word[1] = (AMBEBurst_rawdata[2] ^ AMBE_DecryptionKey[2]);
800034c4:	90 2a       	ld.sh	r10,r8[0x4]
800034c6:	92 29       	ld.sh	r9,r9[0x4]
800034c8:	14 59       	eor	r9,r10
800034ca:	ae 59       	st.h	r7[0xa],r9
							payload_tx_channel->word[2] = (AMBEBurst_rawdata[3]);
800034cc:	90 38       	ld.sh	r8,r8[0x6]
800034ce:	ae 68       	st.h	r7[0xc],r8
							
							//payload_tx_channel->word[0] = (AMBEBurst_rawdata[1]);
							//payload_tx_channel->word[1] = (AMBEBurst_rawdata[2]);
							//payload_tx_channel->word[2] = (AMBEBurst_rawdata[3]);
							
							payload_tx_channel->word[3] = 0x00BA ;
800034d0:	e0 68 00 ba 	mov	r8,186
800034d4:	ae 78       	st.h	r7[0xe],r8
						
							AMBEpayload_tx_state = AMBE_IDLE;
800034d6:	30 09       	mov	r9,0
800034d8:	49 98       	lddpc	r8,8000353c <phy_tx_func+0x498>
800034da:	91 09       	st.w	r8[0x0],r9
800034dc:	c1 c8       	rjmp	80003514 <phy_tx_func+0x470>
						
							break;
						default://This shouldn't happen, but must check;
						
							payload_tx_channel->dword[0] = PAYLOADIDLE0;
800034de:	e0 68 5a 5a 	mov	r8,23130
800034e2:	ea 18 ab cd 	orh	r8,0xabcd
800034e6:	8f 28       	st.w	r7[0x8],r8
							payload_tx_channel->dword[1] = PAYLOADIDLE1;
800034e8:	30 08       	mov	r8,0
800034ea:	8f 38       	st.w	r7[0xc],r8
							AMBEpayload_tx_state = AMBE_IDLE;
800034ec:	49 49       	lddpc	r9,8000353c <phy_tx_func+0x498>
800034ee:	93 08       	st.w	r9[0x0],r8
800034f0:	c1 28       	rjmp	80003514 <phy_tx_func+0x470>

				break;
		
			default:
			
					payload_tx_channel->dword[0] = PAYLOADIDLE0;
800034f2:	e0 68 5a 5a 	mov	r8,23130
800034f6:	ea 18 ab cd 	orh	r8,0xabcd
800034fa:	8f 28       	st.w	r7[0x8],r8
					payload_tx_channel->dword[1] = PAYLOADIDLE1;
800034fc:	30 08       	mov	r8,0
800034fe:	8f 38       	st.w	r7[0xc],r8
					
					AMBEpayload_tx_state = AMBE_IDLE;
80003500:	48 f9       	lddpc	r9,8000353c <phy_tx_func+0x498>
80003502:	93 08       	st.w	r9[0x0],r8
80003504:	c0 88       	rjmp	80003514 <phy_tx_func+0x470>

	}//end of Send-AMBE-data

	else
	{
		payload_tx_channel->dword[0] = PAYLOADIDLE0;
80003506:	e0 68 5a 5a 	mov	r8,23130
8000350a:	ea 18 ab cd 	orh	r8,0xabcd
8000350e:	8f 28       	st.w	r7[0x8],r8
		payload_tx_channel->dword[1] = PAYLOADIDLE1;
80003510:	30 08       	mov	r8,0
80003512:	8f 38       	st.w	r7[0xc],r8
	#else
	/*send idle frame*/	
	((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
	((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
	#endif /*end if*/
}
80003514:	2f fd       	sub	sp,-4
80003516:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000351a:	00 00       	add	r0,r0
8000351c:	00 00       	add	r0,r0
8000351e:	0a d0       	st.w	--r5,r0
80003520:	00 00       	add	r0,r0
80003522:	0a a8       	st.w	r5++,r8
80003524:	00 00       	add	r0,r0
80003526:	0a 84       	andn	r4,r5
80003528:	80 00       	ld.sh	r0,r0[0x0]
8000352a:	5e ec       	retqs	r12
8000352c:	00 00       	add	r0,r0
8000352e:	0a c8       	st.b	r5++,r8
80003530:	00 00       	add	r0,r0
80003532:	0a 8d       	andn	sp,r5
80003534:	00 00       	add	r0,r0
80003536:	0a 4a       	or	r10,r5
80003538:	00 00       	add	r0,r0
8000353a:	0a 80       	andn	r0,r5
8000353c:	00 00       	add	r0,r0
8000353e:	0a b8       	st.h	r5++,r8
80003540:	80 00       	ld.sh	r0,r0[0x0]
80003542:	db 64       	*unknown*
80003544:	00 00       	add	r0,r0
80003546:	0a 74       	tst	r4,r5
80003548:	00 00       	add	r0,r0
8000354a:	0a d8       	st.w	--r5,r8
8000354c:	00 00       	add	r0,r0
8000354e:	1d 98       	ld.ub	r8,lr[0x1]
80003550:	00 00       	add	r0,r0
80003552:	1e 94       	mov	r4,pc
80003554:	00 00       	add	r0,r0
80003556:	0a 4b       	or	r11,r5
80003558:	80 00       	ld.sh	r0,r0[0x0]
8000355a:	d5 58       	*unknown*
8000355c:	00 00       	add	r0,r0
8000355e:	1d 90       	ld.ub	r0,lr[0x1]
80003560:	00 00       	add	r0,r0
80003562:	0a a4       	st.w	r5++,r4
80003564:	00 00       	add	r0,r0
80003566:	1e 98       	mov	r8,pc
80003568:	00 00       	add	r0,r0
8000356a:	1d 9c       	ld.ub	r12,lr[0x1]

8000356c <get_idle_store>:
	}//End of RxMedia Phy Handler.
}
#endif /*end if*/

void * get_idle_store(xQueueHandle store)
{
8000356c:	d4 01       	pushm	lr
8000356e:	20 1d       	sub	sp,4
	void * ptr = NULL;
80003570:	30 0a       	mov	r10,0
80003572:	fa cb ff fc 	sub	r11,sp,-4
80003576:	16 da       	st.w	--r11,r10

	if(pdTRUE == xQueueReceive(store, &ptr, 0))
80003578:	14 99       	mov	r9,r10
8000357a:	1a 9b       	mov	r11,sp
8000357c:	f0 1f 00 05 	mcall	80003590 <get_idle_store+0x24>
80003580:	58 1c       	cp.w	r12,1
80003582:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80003586:	fb fc 00 00 	ld.weq	r12,sp[0x0]
	}
	else
	{
		return NULL;
	}
}
8000358a:	2f fd       	sub	sp,-4
8000358c:	d8 02       	popm	pc
8000358e:	00 00       	add	r0,r0
80003590:	80 00       	ld.sh	r0,r0[0x0]
80003592:	5f dc       	srvc	r12

80003594 <phy_init>:
    register_rx_tx_func -- ssc.c
	xQueueCreate -- freertos
Called By: xnl_init -- xnl.c
*/
void phy_init( void )
{
80003594:	eb cd 40 e0 	pushm	r5-r7,lr
    /*initialize the SSC*/
    ssc_init();
80003598:	f0 1f 00 21 	mcall	8000361c <phy_init+0x88>

    /*register the func to send/receive ssc packet*/
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
8000359c:	4a 1b       	lddpc	r11,80003620 <phy_init+0x8c>
8000359e:	4a 2c       	lddpc	r12,80003624 <phy_init+0x90>
800035a0:	f0 1f 00 22 	mcall	80003628 <phy_init+0x94>
	
	/*if enable send/receive payload(media), defined in physical.h*/	
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
800035a4:	30 4b       	mov	r11,4
800035a6:	31 ec       	mov	r12,30
800035a8:	f0 1f 00 21 	mcall	8000362c <phy_init+0x98>
800035ac:	4a 18       	lddpc	r8,80003630 <phy_init+0x9c>
800035ae:	91 0c       	st.w	r8[0x0],r12
800035b0:	30 07       	mov	r7,0
	phy_fragment_t * xnl_ptr = NULL;
	for(int i= 0; i < MAX_XNL_STORE; i++ )
	{
		set_xnl_idle(&xnl_store[i]);
800035b2:	10 96       	mov	r6,r8
800035b4:	4a 05       	lddpc	r5,80003634 <phy_init+0xa0>
800035b6:	6c 0c       	ld.w	r12,r6[0x0]
800035b8:	ea 07 00 0b 	add	r11,r5,r7
800035bc:	f0 1f 00 1f 	mcall	80003638 <phy_init+0xa4>
800035c0:	ee c7 ff 00 	sub	r7,r7,-256
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
	
	/*if enable send/receive payload(media), defined in physical.h*/	
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
	phy_fragment_t * xnl_ptr = NULL;
	for(int i= 0; i < MAX_XNL_STORE; i++ )
800035c4:	e0 47 1e 00 	cp.w	r7,7680
800035c8:	cf 71       	brne	800035b6 <phy_init+0x22>
	{
		set_xnl_idle(&xnl_store[i]);
	}
		
    /*initialize the queue to send/receive xnl packet */	
    phy_xnl_frame_tx = xQueueCreate(TX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
800035ca:	30 4b       	mov	r11,4
800035cc:	31 4c       	mov	r12,20
800035ce:	f0 1f 00 18 	mcall	8000362c <phy_init+0x98>
800035d2:	49 b8       	lddpc	r8,8000363c <phy_init+0xa8>
800035d4:	91 0c       	st.w	r8[0x0],r12
    phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
800035d6:	30 4b       	mov	r11,4
800035d8:	30 ac       	mov	r12,10
800035da:	f0 1f 00 15 	mcall	8000362c <phy_init+0x98>
800035de:	49 98       	lddpc	r8,80003640 <phy_init+0xac>
800035e0:	91 0c       	st.w	r8[0x0],r12
	
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
800035e2:	30 4b       	mov	r11,4
800035e4:	30 ac       	mov	r12,10
800035e6:	f0 1f 00 12 	mcall	8000362c <phy_init+0x98>
800035ea:	49 78       	lddpc	r8,80003644 <phy_init+0xb0>
800035ec:	91 0c       	st.w	r8[0x0],r12
800035ee:	30 07       	mov	r7,0
	U8 * payload_ptr = NULL;
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
	{
		set_payload_idle(payload_store[i]);
800035f0:	10 96       	mov	r6,r8
800035f2:	49 65       	lddpc	r5,80003648 <phy_init+0xb4>
800035f4:	6c 0c       	ld.w	r12,r6[0x0]
800035f6:	ea 07 00 0b 	add	r11,r5,r7
800035fa:	f0 1f 00 10 	mcall	80003638 <phy_init+0xa4>
800035fe:	ee c7 fe 00 	sub	r7,r7,-512
    phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
	
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
	U8 * payload_ptr = NULL;
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
80003602:	e0 47 14 00 	cp.w	r7,5120
80003606:	cf 71       	brne	800035f4 <phy_init+0x60>
		set_payload_idle(payload_store[i]);
	}
		
	/*initialize the queue to send/receive xnl packet */
	phy_payload_frame_tx =
	xQueueCreate(TX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t));
80003608:	e0 6b 01 00 	mov	r11,256
8000360c:	30 5c       	mov	r12,5
8000360e:	f0 1f 00 08 	mcall	8000362c <phy_init+0x98>
	{
		set_payload_idle(payload_store[i]);
	}
		
	/*initialize the queue to send/receive xnl packet */
	phy_payload_frame_tx =
80003612:	48 f8       	lddpc	r8,8000364c <phy_init+0xb8>
80003614:	91 0c       	st.w	r8[0x0],r12
		
	//phy_payload_frame_rx =
	//xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
	#endif /*end if*/
	
}
80003616:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000361a:	00 00       	add	r0,r0
8000361c:	80 00       	ld.sh	r0,r0[0x0]
8000361e:	44 40       	lddsp	r0,sp[0x110]
80003620:	80 00       	ld.sh	r0,r0[0x0]
80003622:	30 a4       	mov	r4,10
80003624:	80 00       	ld.sh	r0,r0[0x0]
80003626:	36 b0       	mov	r0,107
80003628:	80 00       	ld.sh	r0,r0[0x0]
8000362a:	44 2c       	lddsp	r12,sp[0x108]
8000362c:	80 00       	ld.sh	r0,r0[0x0]
8000362e:	62 e8       	ld.w	r8,r1[0x38]
80003630:	00 00       	add	r0,r0
80003632:	0a 9c       	mov	r12,r5
80003634:	00 00       	add	r0,r0
80003636:	32 b2       	mov	r2,43
80003638:	80 00       	ld.sh	r0,r0[0x0]
8000363a:	30 00       	mov	r0,0
8000363c:	00 00       	add	r0,r0
8000363e:	0a d0       	st.w	--r5,r0
80003640:	00 00       	add	r0,r0
80003642:	0a c4       	st.b	r5++,r4
80003644:	00 00       	add	r0,r0
80003646:	0a 78       	tst	r8,r5
80003648:	00 00       	add	r0,r0
8000364a:	1e b2       	st.h	pc++,r2
8000364c:	00 00       	add	r0,r0
8000364e:	0a c0       	st.b	r5++,r0

80003650 <payload_rx>:




static void payload_rx(void * payload)
{
80003650:	d4 01       	pushm	lr
80003652:	20 2d       	sub	sp,8
80003654:	50 0c       	stdsp	sp[0x0],r12
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80003656:	30 08       	mov	r8,0
80003658:	50 18       	stdsp	sp[0x4],r8
	
	//set_payload_idle(payload);
	if(NULL == phy_payload_frame_rx)
8000365a:	48 f8       	lddpc	r8,80003694 <payload_rx+0x44>
8000365c:	70 08       	ld.w	r8,r8[0x0]
8000365e:	58 08       	cp.w	r8,0
80003660:	c0 71       	brne	8000366e <payload_rx+0x1e>
	{
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));		
80003662:	30 4b       	mov	r11,4
80003664:	30 5c       	mov	r12,5
80003666:	f0 1f 00 0d 	mcall	80003698 <payload_rx+0x48>
8000366a:	48 b8       	lddpc	r8,80003694 <payload_rx+0x44>
8000366c:	91 0c       	st.w	r8[0x0],r12
	}

	if(errQUEUE_FULL == xQueueSendFromISR(phy_payload_frame_rx, &payload, &xHigherPriorityTaskWoken))
8000366e:	48 a8       	lddpc	r8,80003694 <payload_rx+0x44>
80003670:	70 0c       	ld.w	r12,r8[0x0]
80003672:	30 09       	mov	r9,0
80003674:	fa ca ff fc 	sub	r10,sp,-4
80003678:	1a 9b       	mov	r11,sp
8000367a:	f0 1f 00 09 	mcall	8000369c <payload_rx+0x4c>
8000367e:	c0 91       	brne	80003690 <payload_rx+0x40>
	//if(errQUEUE_FULL == xQueueSend(phy_payload_frame_rx, &payload, 0))
	{	//To payload_rx_process();	
		
		set_payload_idle_isr(payload);
80003680:	48 88       	lddpc	r8,800036a0 <payload_rx+0x50>
80003682:	70 0c       	ld.w	r12,r8[0x0]
80003684:	40 0b       	lddsp	r11,sp[0x0]
80003686:	f0 1f 00 08 	mcall	800036a4 <payload_rx+0x54>
		logFromISR("mm");
8000368a:	48 8c       	lddpc	r12,800036a8 <payload_rx+0x58>
8000368c:	f0 1f 00 08 	mcall	800036ac <payload_rx+0x5c>
			
		}
		//set_payload_idle_isr(payload);
		//logFromISR("ss");
	}
}
80003690:	2f ed       	sub	sp,-8
80003692:	d8 02       	popm	pc
80003694:	00 00       	add	r0,r0
80003696:	0a 94       	mov	r4,r5
80003698:	80 00       	ld.sh	r0,r0[0x0]
8000369a:	62 e8       	ld.w	r8,r1[0x38]
8000369c:	80 00       	ld.sh	r0,r0[0x0]
8000369e:	61 98       	ld.w	r8,r0[0x64]
800036a0:	00 00       	add	r0,r0
800036a2:	0a 78       	tst	r8,r5
800036a4:	80 00       	ld.sh	r0,r0[0x0]
800036a6:	2f ac       	sub	r12,-6
800036a8:	80 00       	ld.sh	r0,r0[0x0]
800036aa:	db 80       	acall	0xb8
800036ac:	80 00       	ld.sh	r0,r0[0x0]
800036ae:	6f 0c       	ld.w	r12,r7[0x40]

800036b0 <phy_rx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_rx_func( void * ssc)
{    
800036b0:	eb cd 40 e0 	pushm	r5-r7,lr
800036b4:	18 97       	mov	r7,r12
		
	if(NULL != phy_xnl_frame_rx)
800036b6:	fe f8 0b be 	ld.w	r8,pc[3006]
800036ba:	70 08       	ld.w	r8,r8[0x0]
800036bc:	58 08       	cp.w	r8,0
800036be:	e0 80 01 05 	breq	800038c8 <phy_rx_func+0x218>
	static U16 phy_check_sum = 0;

	static phy_rx_state_t  phy_rx_state = WAITING_FOR_HEADER;
	static U32 phy_rx_count = 0;

	U32 phy_dword = xnl_rx_channel->dword;	
800036c2:	78 16       	ld.w	r6,r12[0x4]

	phy_rx_count++;
800036c4:	fe f8 0b b4 	ld.w	r8,pc[2996]
800036c8:	70 09       	ld.w	r9,r8[0x0]
800036ca:	2f f9       	sub	r9,-1
800036cc:	91 09       	st.w	r8[0x0],r9
	
	/*This is the code for parsing the incoming physical message.*/
	switch (phy_rx_state)
800036ce:	fe f8 0b ae 	ld.w	r8,pc[2990]
800036d2:	70 08       	ld.w	r8,r8[0x0]
800036d4:	58 18       	cp.w	r8,1
800036d6:	e0 80 00 84 	breq	800037de <phy_rx_func+0x12e>
800036da:	c0 73       	brcs	800036e8 <phy_rx_func+0x38>
800036dc:	58 28       	cp.w	r8,2
800036de:	c5 b0       	breq	80003794 <phy_rx_func+0xe4>
800036e0:	58 38       	cp.w	r8,3
800036e2:	e0 81 00 f3 	brne	800038c8 <phy_rx_func+0x218>
800036e6:	cd 38       	rjmp	8000388c <phy_rx_func+0x1dc>

        /*Waiting for something. Most frequent visit.*/		
		case WAITING_FOR_HEADER:
		
			/*Ignore Idles.*/
			if (0xABCD5A5A == phy_dword)
800036e8:	e0 6a 5a 5a 	mov	r10,23130
800036ec:	ea 1a ab cd 	orh	r10,0xabcd
800036f0:	14 36       	cp.w	r6,r10
800036f2:	e0 80 00 eb 	breq	800038c8 <phy_rx_func+0x218>
			{
				break;
			}	

			/*Skip until Header.*/		
			if (0xABCD != (phy_dword >> 16))
800036f6:	ec 08 16 10 	lsr	r8,r6,0x10
800036fa:	e0 48 ab cd 	cp.w	r8,43981
800036fe:	e0 81 00 e5 	brne	800038c8 <phy_rx_func+0x218>
			{			
				break;
			}
		
			/*Length excluding CSUM.*/
			phy_rx_expexted_length = (phy_dword & 0x000000FF) - 2;
80003702:	eb d6 b0 10 	bfexts	r5,r6,0x0,0x10
80003706:	f1 d5 c0 08 	bfextu	r8,r5,0x0,0x8
8000370a:	20 28       	sub	r8,2
8000370c:	fe f9 0b 74 	ld.w	r9,pc[2932]
80003710:	b2 08       	st.h	r9[0x0],r8
			
			/*Discard degenerate message.*/
			if (phy_rx_expexted_length <= 0)
80003712:	30 09       	mov	r9,0
80003714:	f2 08 19 00 	cp.h	r8,r9
80003718:	e0 8a 00 d8 	brle	800038c8 <phy_rx_func+0x218>
			{
				break;
			}
		
			phy_rx_length = 0;
8000371c:	fe f8 0b 68 	ld.w	r8,pc[2920]
80003720:	b0 09       	st.h	r8[0x0],r9
			
			//get_xnl_idle_isr(&phy_frame_ptr, &xHigherPriorityTaskWoken);
			phy_frame_ptr = get_xnl_idle_isr();
80003722:	fe f8 0b 66 	ld.w	r8,pc[2918]
80003726:	70 0c       	ld.w	r12,r8[0x0]
80003728:	f0 1f 02 d9 	mcall	8000428c <phy_rx_func+0xbdc>
8000372c:	fe f8 0b 64 	ld.w	r8,pc[2916]
80003730:	91 0c       	st.w	r8[0x0],r12
			if(NULL == phy_frame_ptr)
80003732:	58 0c       	cp.w	r12,0
80003734:	e0 80 00 ca 	breq	800038c8 <phy_rx_func+0x218>
			//
			//xQueueReceiveFromISR(phy_store_idle, &phy_frame_ptr, &xHigherPriorityTaskWoken);
			
			//phy_frame_ptr = pvPortMalloc(sizeof(phy_fragment_t));
					
			phy_frame_ptr->fragment_element[phy_rx_length++] = phy_dword;
80003738:	fe f8 0b 4c 	ld.w	r8,pc[2892]
8000373c:	90 09       	ld.sh	r9,r8[0x0]
8000373e:	f8 09 0a 15 	st.h	r12[r9<<0x1],r5
80003742:	2f f9       	sub	r9,-1
80003744:	5c 89       	casts.h	r9
			
			/*time stamp*/
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
80003746:	fe fa 0b 4a 	ld.w	r10,pc[2890]
8000374a:	74 0a       	ld.w	r10,r10[0x0]
8000374c:	fe fb 0b 2c 	ld.w	r11,pc[2860]
80003750:	76 0b       	ld.w	r11,r11[0x0]
80003752:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
80003756:	2f f9       	sub	r9,-1
80003758:	b0 09       	st.h	r8[0x0],r9
													(phy_rx_count) & 0x0000FFFF;
			
			/*This switch tests the fragment type, and adjusts receiver state
			accordingly.*/
			/*Check frag type*/
			switch (phy_dword & 0x00000F00)
8000375a:	e2 16 0f 00 	andl	r6,0xf00,COH
8000375e:	e0 46 01 00 	cp.w	r6,256
80003762:	c0 c0       	breq	8000377a <phy_rx_func+0xca>
80003764:	e0 8b 00 05 	brhi	8000376e <phy_rx_func+0xbe>
80003768:	58 06       	cp.w	r6,0
8000376a:	c0 80       	breq	8000377a <phy_rx_func+0xca>
8000376c:	c0 c8       	rjmp	80003784 <phy_rx_func+0xd4>
8000376e:	e0 46 02 00 	cp.w	r6,512
80003772:	c0 40       	breq	8000377a <phy_rx_func+0xca>
80003774:	e0 46 03 00 	cp.w	r6,768
80003778:	c0 61       	brne	80003784 <phy_rx_func+0xd4>
			{
				case SINGLE_FRAGMENT:  //Only Fragment.
				case FIRST_FRAGMENT:   //First of Multi-fragment.
				case MIDDLE_FRAGMENT:  //Continuing Multi-fragment.
				case LAST_FRAGMENT:    //Last Multi-fragment.
					phy_rx_state = WAITING_CHECK_SUM;
8000377a:	30 29       	mov	r9,2
8000377c:	fe f8 0b 00 	ld.w	r8,pc[2816]
80003780:	91 09       	st.w	r8[0x0],r9
80003782:	ca 38       	rjmp	800038c8 <phy_rx_func+0x218>
				break;
				default:
					vPortFree(phy_frame_ptr);
80003784:	fe f6 0b 0c 	ld.w	r6,pc[2828]
80003788:	6c 0c       	ld.w	r12,r6[0x0]
8000378a:	f0 1f 02 c3 	mcall	80004294 <phy_rx_func+0xbe4>
					phy_frame_ptr = NULL;					
8000378e:	30 08       	mov	r8,0
80003790:	8d 08       	st.w	r6[0x0],r8
80003792:	c9 b8       	rjmp	800038c8 <phy_rx_func+0x218>
		
			/*Stores CSUM*/
			phy_check_sum  = (phy_dword & 0xFFFF0000) >> 16;
			
			/*sums in first hWord*/
			phy_check_sum += (phy_dword & 0x0000FFFF);		
80003794:	f5 d6 b0 10 	bfexts	r10,r6,0x0,0x10
80003798:	b1 86       	lsr	r6,0x10
8000379a:	14 06       	add	r6,r10
8000379c:	fe f8 0a fc 	ld.w	r8,pc[2812]
800037a0:	b0 06       	st.h	r8[0x0],r6
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
800037a2:	fe f8 0a e2 	ld.w	r8,pc[2786]
800037a6:	90 09       	ld.sh	r9,r8[0x0]
800037a8:	fe fb 0a e8 	ld.w	r11,pc[2792]
800037ac:	76 0b       	ld.w	r11,r11[0x0]
800037ae:	f6 09 0a 1a 	st.h	r11[r9<<0x1],r10
800037b2:	2f f9       	sub	r9,-1
800037b4:	b0 09       	st.h	r8[0x0],r9
														 phy_dword & 0x0000FFFF;
					
			phy_rx_expexted_length -= 2;
800037b6:	fe f9 0a ca 	ld.w	r9,pc[2762]
800037ba:	92 08       	ld.sh	r8,r9[0x0]
800037bc:	20 28       	sub	r8,2
800037be:	b2 08       	st.h	r9[0x0],r8
			
			/*Normal case for greater than one byte payloads.*/
			if (phy_rx_expexted_length > 0)
800037c0:	30 09       	mov	r9,0
800037c2:	f2 08 19 00 	cp.h	r8,r9
800037c6:	e0 8a 00 07 	brle	800037d4 <phy_rx_func+0x124>
			{					  
				phy_rx_state = READING_FRAGMENT;
800037ca:	30 19       	mov	r9,1
800037cc:	fe f8 0a b0 	ld.w	r8,pc[2736]
800037d0:	91 09       	st.w	r8[0x0],r9
800037d2:	c7 b8       	rjmp	800038c8 <phy_rx_func+0x218>
	    		Note that all segments must align with a 32-bit boundary and
				beginning of each XCMP/XNL payload frame must start on slot 3
				Thus, segments of odd length must append a 0x0000 at the end
				(slot 4) to ensure alignment. [9.1.3]
				*/
				phy_rx_state = WAITING_LAST_TERM;
800037d4:	30 39       	mov	r9,3
800037d6:	fe f8 0a a6 	ld.w	r8,pc[2726]
800037da:	91 09       	st.w	r8[0x0],r9
800037dc:	c7 68       	rjmp	800038c8 <phy_rx_func+0x218>
			}			
		
			break;

		case READING_FRAGMENT:
			phy_check_sum += (phy_dword & 0xFFFF0000) >> 16;
800037de:	ec 0a 14 10 	asr	r10,r6,0x10
800037e2:	fe f8 0a b6 	ld.w	r8,pc[2742]
800037e6:	90 09       	ld.sh	r9,r8[0x0]
800037e8:	14 09       	add	r9,r10
800037ea:	b0 09       	st.h	r8[0x0],r9
	
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
800037ec:	fe f9 0a 98 	ld.w	r9,pc[2712]
800037f0:	92 08       	ld.sh	r8,r9[0x0]
800037f2:	fe fb 0a 9e 	ld.w	r11,pc[2718]
800037f6:	76 0b       	ld.w	r11,r11[0x0]
800037f8:	f6 08 0a 1a 	st.h	r11[r8<<0x1],r10
800037fc:	2f f8       	sub	r8,-1
800037fe:	5c 88       	casts.h	r8
80003800:	b2 08       	st.h	r9[0x0],r8
												 (phy_dword & 0xFFFF0000) >> 16;
	
			phy_rx_expexted_length -= 2;
80003802:	fe fa 0a 7e 	ld.w	r10,pc[2686]
80003806:	94 09       	ld.sh	r9,r10[0x0]
80003808:	20 29       	sub	r9,2
8000380a:	b4 09       	st.h	r10[0x0],r9
			if (phy_rx_expexted_length <= 0)
8000380c:	30 0a       	mov	r10,0
8000380e:	f4 09 19 00 	cp.h	r9,r10
80003812:	e0 89 00 1f 	brgt	80003850 <phy_rx_func+0x1a0>
				Terminator should be in 2nd hWord.
				Shaoqun says useful bits not used. The packet will always end
				with $00BA. [9.1.2.8]	
				*/
				
				if ((0x000000BA == (phy_dword  & 0x0000FFFF)) 
80003816:	ed d6 c0 10 	bfextu	r6,r6,0x0,0x10
8000381a:	e0 46 00 ba 	cp.w	r6,186
8000381e:	c0 d1       	brne	80003838 <phy_rx_func+0x188>
80003820:	fe f8 0a 78 	ld.w	r8,pc[2680]
80003824:	90 09       	ld.sh	r9,r8[0x0]
80003826:	f4 09 19 00 	cp.h	r9,r10
8000382a:	c0 71       	brne	80003838 <phy_rx_func+0x188>
					&& (phy_check_sum == 0))
				{
					phy_rx(phy_frame_ptr);
8000382c:	fe f8 0a 64 	ld.w	r8,pc[2660]
80003830:	70 0c       	ld.w	r12,r8[0x0]
80003832:	f0 1f 02 9b 	mcall	8000429c <phy_rx_func+0xbec>
80003836:	c0 88       	rjmp	80003846 <phy_rx_func+0x196>
				}
				else
				{
					vPortFree(phy_frame_ptr);
80003838:	fe f6 0a 58 	ld.w	r6,pc[2648]
8000383c:	6c 0c       	ld.w	r12,r6[0x0]
8000383e:	f0 1f 02 96 	mcall	80004294 <phy_rx_func+0xbe4>
					phy_frame_ptr = NULL;
80003842:	30 08       	mov	r8,0
80003844:	8d 08       	st.w	r6[0x0],r8
				}

				phy_rx_state = WAITING_FOR_HEADER;
80003846:	30 09       	mov	r9,0
80003848:	fe f8 0a 34 	ld.w	r8,pc[2612]
8000384c:	91 09       	st.w	r8[0x0],r9
8000384e:	c3 d8       	rjmp	800038c8 <phy_rx_func+0x218>
				break;
			}
		
			/*Have not broken. 2nd hWord contains payload.*/
			phy_check_sum += (phy_dword & 0x0000FFFF);
80003850:	5c 86       	casts.h	r6
80003852:	fe f9 0a 46 	ld.w	r9,pc[2630]
80003856:	92 0a       	ld.sh	r10,r9[0x0]
80003858:	0c 0a       	add	r10,r6
8000385a:	b2 0a       	st.h	r9[0x0],r10
		
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
8000385c:	fe f9 0a 34 	ld.w	r9,pc[2612]
80003860:	72 09       	ld.w	r9,r9[0x0]
80003862:	f2 08 0a 16 	st.h	r9[r8<<0x1],r6
80003866:	2f f8       	sub	r8,-1
80003868:	fe f9 0a 1c 	ld.w	r9,pc[2588]
8000386c:	b2 08       	st.h	r9[0x0],r8
													   (phy_dword & 0x0000FFFF);
		
			phy_rx_expexted_length -= 2;
8000386e:	fe f9 0a 12 	ld.w	r9,pc[2578]
80003872:	92 08       	ld.sh	r8,r9[0x0]
80003874:	20 28       	sub	r8,2
80003876:	b2 08       	st.h	r9[0x0],r8
			if (phy_rx_expexted_length <= 0)
80003878:	30 09       	mov	r9,0
8000387a:	f2 08 19 00 	cp.h	r8,r9
8000387e:	e0 89 00 25 	brgt	800038c8 <phy_rx_func+0x218>
			{
				/*All read in. Next Word should be 0x00BA0000.*/
				phy_rx_state = WAITING_LAST_TERM;
80003882:	30 39       	mov	r9,3
80003884:	fe f8 09 f8 	ld.w	r8,pc[2552]
80003888:	91 09       	st.w	r8[0x0],r9
8000388a:	c1 f8       	rjmp	800038c8 <phy_rx_func+0x218>
			}/*else, next Word contains more payload.*/
			break;

		/*Expecting last terminator 0x00BA0000.*/	
		case WAITING_LAST_TERM:			
			if ((0x00BA0000 == (phy_dword  & 0x00FF0000)) /*Expected found.*/
8000388c:	e6 16 00 ff 	andh	r6,0xff,COH
80003890:	fc 19 00 ba 	movh	r9,0xba
80003894:	12 36       	cp.w	r6,r9
80003896:	c0 e1       	brne	800038b2 <phy_rx_func+0x202>
80003898:	fe f8 0a 00 	ld.w	r8,pc[2560]
8000389c:	90 09       	ld.sh	r9,r8[0x0]
8000389e:	30 08       	mov	r8,0
800038a0:	f0 09 19 00 	cp.h	r9,r8
800038a4:	c0 71       	brne	800038b2 <phy_rx_func+0x202>
				&& (phy_check_sum == 0))/*Good checksum*/
			{
				phy_rx(phy_frame_ptr);
800038a6:	fe f8 09 ea 	ld.w	r8,pc[2538]
800038aa:	70 0c       	ld.w	r12,r8[0x0]
800038ac:	f0 1f 02 7c 	mcall	8000429c <phy_rx_func+0xbec>
800038b0:	c0 88       	rjmp	800038c0 <phy_rx_func+0x210>

			}
			else
			{
				vPortFree(phy_frame_ptr);
800038b2:	fe f6 09 de 	ld.w	r6,pc[2526]
800038b6:	6c 0c       	ld.w	r12,r6[0x0]
800038b8:	f0 1f 02 77 	mcall	80004294 <phy_rx_func+0xbe4>
				phy_frame_ptr = NULL;
800038bc:	30 08       	mov	r8,0
800038be:	8d 08       	st.w	r6[0x0],r8
			}
				
			phy_rx_state = WAITING_FOR_HEADER;
800038c0:	30 09       	mov	r9,0
800038c2:	fe f8 09 ba 	ld.w	r8,pc[2490]
800038c6:	91 09       	st.w	r8[0x0],r9
			
	//payload_ptr_t *AMBE_payload_ptr;		
				
	
	
	if(is_first == FALSE)
800038c8:	fe f8 09 d8 	ld.w	r8,pc[2520]
800038cc:	11 89       	ld.ub	r9,r8[0x0]
800038ce:	30 08       	mov	r8,0
800038d0:	f0 09 18 00 	cp.b	r9,r8
800038d4:	c0 d1       	brne	800038ee <phy_rx_func+0x23e>
	{
		//payload_ptr = get_payload_idle_isr();
		AMBE_payload_ptr = get_payload_idle_isr();
800038d6:	fe f8 09 ce 	ld.w	r8,pc[2510]
800038da:	70 0c       	ld.w	r12,r8[0x0]
800038dc:	f0 1f 02 6c 	mcall	8000428c <phy_rx_func+0xbdc>
800038e0:	fe f8 09 c8 	ld.w	r8,pc[2504]
800038e4:	91 0c       	st.w	r8[0x0],r12
		is_first = TRUE;
800038e6:	30 19       	mov	r9,1
800038e8:	fe f8 09 b8 	ld.w	r8,pc[2488]
800038ec:	b0 89       	st.b	r8[0x0],r9
	}	
	
	//This is the RxMedia Phy Handler.
	switch (RxMediaState)
800038ee:	fe f8 09 be 	ld.w	r8,pc[2494]
800038f2:	70 08       	ld.w	r8,r8[0x0]
800038f4:	58 38       	cp.w	r8,3
800038f6:	e0 80 04 7a 	breq	800041ea <phy_rx_func+0xb3a>
800038fa:	58 48       	cp.w	r8,4
800038fc:	e0 80 01 02 	breq	80003b00 <phy_rx_func+0x450>
80003900:	58 08       	cp.w	r8,0
80003902:	e0 81 04 b7 	brne	80004270 <phy_rx_func+0xbc0>
	{
		case WAITINGABAB:

			
			if (payload_rx_channel->dword[0] == 0xABCD5A5A)//Ignore Idles.
80003906:	6e 28       	ld.w	r8,r7[0x8]
80003908:	e0 6a 5a 5a 	mov	r10,23130
8000390c:	ea 1a ab cd 	orh	r10,0xabcd
80003910:	14 38       	cp.w	r8,r10
80003912:	c0 71       	brne	80003920 <phy_rx_func+0x270>
			{
				m_RxBurstType = VOICE_WATING;
80003914:	30 09       	mov	r9,0
80003916:	fe f8 09 9a 	ld.w	r8,pc[2458]
8000391a:	91 09       	st.w	r8[0x0],r9
8000391c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
				//Upon receiving the idle frame, the m Rx Burst Type into an idle state in order to transmit the synchronization wait
				 break; 
			}
            
			if ((payload_rx_channel->dword[0]  & 0xFFFF0000) != 0xABCD0000)break; //Skip until Header. 
80003920:	10 99       	mov	r9,r8
80003922:	e0 19 00 00 	andl	r9,0x0
80003926:	fc 1a ab cd 	movh	r10,0xabcd
8000392a:	14 39       	cp.w	r9,r10
8000392c:	e0 81 04 a2 	brne	80004270 <phy_rx_func+0xbc0>
			}
			//logFromISR("\n\r P: %X \n\r", payload_rx_channel->word[1]);//测试收到的数据
			
			#endif
			
			RxBytesWaiting = payload_rx_channel->dword[0] & 0x000000FF;
80003930:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
80003934:	fe f9 09 80 	ld.w	r9,pc[2432]
80003938:	93 08       	st.w	r9[0x0],r8
		
			if( (NULL== AMBE_payload_ptr))
8000393a:	fe f8 09 6e 	ld.w	r8,pc[2414]
8000393e:	70 08       	ld.w	r8,r8[0x0]
80003940:	58 08       	cp.w	r8,0
80003942:	c1 11       	brne	80003964 <phy_rx_func+0x2b4>
			{
				//payload_ptr = get_payload_idle_isr();
				AMBE_payload_ptr = get_payload_idle_isr();
80003944:	fe f8 09 60 	ld.w	r8,pc[2400]
80003948:	70 0c       	ld.w	r12,r8[0x0]
8000394a:	f0 1f 02 51 	mcall	8000428c <phy_rx_func+0xbdc>
8000394e:	fe f8 09 5a 	ld.w	r8,pc[2394]
80003952:	91 0c       	st.w	r8[0x0],r12
				
				if (NULL== AMBE_payload_ptr)
80003954:	58 0c       	cp.w	r12,0
80003956:	c0 71       	brne	80003964 <phy_rx_func+0x2b4>
				{
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
80003958:	fe fc 09 60 	ld.w	r12,pc[2400]
8000395c:	f0 1f 02 58 	mcall	800042bc <phy_rx_func+0xc0c>
80003960:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003964:	6e 28       	ld.w	r8,r7[0x8]
80003966:	e2 18 f0 00 	andl	r8,0xf000,COH
8000396a:	e0 48 c0 00 	cp.w	r8,49152
8000396e:	e0 81 00 c3 	brne	80003af4 <phy_rx_func+0x444>
		
			/****Note AMBE stream protocol frame structure and the PCM frame structure is different*****/
					
			if ((payload_rx_channel->dword[0] & 0x0000F000 ) == PAYLOAD_DATA_ENH )//PAYLOAD_DATA_ENH (0x0c))
			{
				AMBE_Media = 1;	
80003972:	30 19       	mov	r9,1
80003974:	fe f8 09 4c 	ld.w	r8,pc[2380]
80003978:	b0 89       	st.b	r8[0x0],r9
											
				Item_ID = payload_rx_channel->byte[5];
8000397a:	ef 39 00 0d 	ld.ub	r9,r7[13]
8000397e:	fe f8 09 46 	ld.w	r8,pc[2374]
80003982:	b0 89       	st.b	r8[0x0],r9
				
				Item_Length = (payload_rx_channel->byte[4] & 0x7F);//7bits
80003984:	ef 3a 00 0c 	ld.ub	r10,r7[12]
80003988:	f5 da c0 07 	bfextu	r10,r10,0x0,0x7
8000398c:	fe f9 09 3c 	ld.w	r9,pc[2364]
80003990:	93 0a       	st.w	r9[0x0],r10
								
				switch(Item_ID)
80003992:	11 88       	ld.ub	r8,r8[0x0]
80003994:	37 f9       	mov	r9,127
80003996:	f2 08 18 00 	cp.b	r8,r9
8000399a:	c6 d0       	breq	80003a74 <phy_rx_func+0x3c4>
8000399c:	e0 8b 00 0c 	brhi	800039b4 <phy_rx_func+0x304>
800039a0:	31 29       	mov	r9,18
800039a2:	f2 08 18 00 	cp.b	r8,r9
800039a6:	c4 20       	breq	80003a2a <phy_rx_func+0x37a>
800039a8:	31 39       	mov	r9,19
800039aa:	f2 08 18 00 	cp.b	r8,r9
800039ae:	e0 81 00 83 	brne	80003ab4 <phy_rx_func+0x404>
800039b2:	c5 b8       	rjmp	80003a68 <phy_rx_func+0x3b8>
800039b4:	2f 08       	sub	r8,-16
800039b6:	30 19       	mov	r9,1
800039b8:	f2 08 18 00 	cp.b	r8,r9
800039bc:	e0 8b 00 7c 	brhi	80003ab4 <phy_rx_func+0x404>
					//The OB know the Call begin and discard the Voice Header
					//The OB know the Call end and discard the Voice  Terminator
					case Raw_Tx_Data_HT://0xF0
					case Raw_Rx_Data_HT://0xF1
					
							if ((payload_rx_channel->byte[6] & 0xF0 )== 0x10)//header
800039c0:	ef 38 00 0e 	ld.ub	r8,r7[14]
800039c4:	e2 18 00 f0 	andl	r8,0xf0,COH
800039c8:	59 08       	cp.w	r8,16
800039ca:	c0 71       	brne	800039d8 <phy_rx_func+0x328>
							{
								m_RxBurstType = VOICEHEADER;
800039cc:	30 19       	mov	r9,1
800039ce:	fe f8 08 e2 	ld.w	r8,pc[2274]
800039d2:	91 09       	st.w	r8[0x0],r9
800039d4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

							}
							else if ((payload_rx_channel->byte[6] & 0xF0) == 0x20)//Terminator
800039d8:	e0 48 00 20 	cp.w	r8,32
800039dc:	c2 11       	brne	80003a1e <phy_rx_func+0x36e>
							{
								m_RxBurstType = VOICETERMINATOR;
800039de:	30 a9       	mov	r9,10
800039e0:	fe f8 08 d0 	ld.w	r8,pc[2256]
800039e4:	91 09       	st.w	r8[0x0],r9
								//AMBE-data and PCM-data is not the same. AMBE is compressed data,
								//if there was a missing portion, a clear voice is difficult to extract the data.
								//It must ensure that all the data received AMBE.
								
								//注意！！！考虑是否需要把剩余的空间置0。
								memset((AMBE_payload_ptr+ (RxAMBE_IsFillingNext8 +1)), 0x00, (512-(RxAMBE_IsFillingNext8 + 1)));
800039e6:	fe f6 08 e6 	ld.w	r6,pc[2278]
800039ea:	6c 08       	ld.w	r8,r6[0x0]
800039ec:	f0 0a 11 ff 	rsub	r10,r8,-1
800039f0:	fe f7 08 b8 	ld.w	r7,pc[2232]
800039f4:	2f f8       	sub	r8,-1
800039f6:	6e 0c       	ld.w	r12,r7[0x0]
800039f8:	f4 ca fe 00 	sub	r10,r10,-512
800039fc:	30 0b       	mov	r11,0
800039fe:	10 0c       	add	r12,r8
80003a00:	f0 1f 02 34 	mcall	800042d0 <phy_rx_func+0xc20>
								
								RxAMBE_IsFillingNext8 = 0;
80003a04:	30 08       	mov	r8,0
80003a06:	8d 08       	st.w	r6[0x0],r8
								payload_rx(AMBE_payload_ptr);
80003a08:	6e 0c       	ld.w	r12,r7[0x0]
80003a0a:	f0 1f 02 33 	mcall	800042d4 <phy_rx_func+0xc24>
								AMBE_payload_ptr = get_payload_idle_isr();
80003a0e:	fe f8 08 96 	ld.w	r8,pc[2198]
80003a12:	70 0c       	ld.w	r12,r8[0x0]
80003a14:	f0 1f 02 1e 	mcall	8000428c <phy_rx_func+0xbdc>
80003a18:	8f 0c       	st.w	r7[0x0],r12
80003a1a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								//logFromISR("\n\r QQ1 \n\r");
								
							}
							else//error voice
							{
								m_RxBurstType = VOICE_WATING;
80003a1e:	30 09       	mov	r9,0
80003a20:	fe f8 08 90 	ld.w	r8,pc[2192]
80003a24:	91 09       	st.w	r8[0x0],r9
80003a26:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;//WAITINGABAB.
					
		
					case Vocoder_Bit_Stream_Parameter://0x12
							
							if ((RxBytesWaiting -= 4) <= 0) break;
80003a2a:	fe f9 08 8a 	ld.w	r9,pc[2186]
80003a2e:	72 08       	ld.w	r8,r9[0x0]
80003a30:	20 48       	sub	r8,4
80003a32:	93 08       	st.w	r9[0x0],r8
80003a34:	e0 80 04 1e 	breq	80004270 <phy_rx_func+0xbc0>
					
							//Vocoder Bits Stream Parameter
							VF_SN = (payload_rx_channel->byte[7] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
80003a38:	ef 3c 00 0f 	ld.ub	r12,r7[15]
80003a3c:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
80003a40:	fe f8 08 98 	ld.w	r8,pc[2200]
80003a44:	b0 8c       	st.b	r8[0x0],r12
							
							VBSP_data[0] = payload_rx_channel->word[2];
80003a46:	8e 69       	ld.sh	r9,r7[0xc]
80003a48:	fe f8 08 94 	ld.w	r8,pc[2196]
80003a4c:	b0 09       	st.h	r8[0x0],r9
							VBSP_data[1] = payload_rx_channel->word[3];
80003a4e:	8e 79       	ld.sh	r9,r7[0xe]
80003a50:	b0 19       	st.h	r8[0x2],r9
							
							m_RxBurstType = CalculateBurst(VF_SN);
80003a52:	f0 1f 02 24 	mcall	800042e0 <phy_rx_func+0xc30>
80003a56:	fe f8 08 5a 	ld.w	r8,pc[2138]
80003a5a:	91 0c       	st.w	r8[0x0],r12
							
							RxMediaState = READING_AMBE_MEDIA;//Jump
80003a5c:	30 49       	mov	r9,4
80003a5e:	fe f8 08 4e 	ld.w	r8,pc[2126]
80003a62:	91 09       	st.w	r8[0x0],r9
80003a64:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							
					//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
					// or discard it to reduce payload size.	
					//This shouldn't happen, but must check.	
					case Soft_Decision_Value://0x13
						m_RxBurstType = VOICE_WATING;
80003a68:	30 09       	mov	r9,0
80003a6a:	fe f8 08 46 	ld.w	r8,pc[2118]
80003a6e:	91 09       	st.w	r8[0x0],r9
80003a70:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
					case Radio_Internal_Parameter://0x7F
							
							//logFromISR("\n\r Item_Length:%d\n\r", Item_Length);
							
							if ((RxBytesWaiting -= 4) <= 0) break;
80003a74:	fe f9 08 40 	ld.w	r9,pc[2112]
80003a78:	72 08       	ld.w	r8,r9[0x0]
80003a7a:	20 48       	sub	r8,4
80003a7c:	93 08       	st.w	r9[0x0],r8
80003a7e:	e0 80 03 f9 	breq	80004270 <phy_rx_func+0xbc0>
							//Radio Internal Parameter
							Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[3];
80003a82:	fe f8 08 62 	ld.w	r8,pc[2146]
80003a86:	70 09       	ld.w	r9,r8[0x0]
80003a88:	8e 7b       	ld.sh	r11,r7[0xe]
80003a8a:	fe fa 08 5e 	ld.w	r10,pc[2142]
80003a8e:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
							RxData_IsFillingNext16 += 1; 
80003a92:	2f f9       	sub	r9,-1
80003a94:	91 09       	st.w	r8[0x0],r9
							Item_Length -= 2 ;
80003a96:	fe f8 08 32 	ld.w	r8,pc[2098]
80003a9a:	70 09       	ld.w	r9,r8[0x0]
80003a9c:	20 29       	sub	r9,2
80003a9e:	91 09       	st.w	r8[0x0],r9
							//....................................................
							m_RxBurstType = RADIOINTERNAL;
80003aa0:	30 29       	mov	r9,2
80003aa2:	fe f8 08 0e 	ld.w	r8,pc[2062]
80003aa6:	91 09       	st.w	r8[0x0],r9

							RxMediaState = READING_AMBE_AUX;//Jump
80003aa8:	30 39       	mov	r9,3
80003aaa:	fe f8 08 02 	ld.w	r8,pc[2050]
80003aae:	91 09       	st.w	r8[0x0],r9
80003ab0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									
					default://0x03,0x04
						
						//((Item_ID == 0x04) || (Item_ID == 0x03) )//Unknown type data directly back hair
							//break;
							m_RxBurstType = UNSUREDATA;
80003ab4:	30 39       	mov	r9,3
80003ab6:	fe f8 07 fa 	ld.w	r8,pc[2042]
80003aba:	91 09       	st.w	r8[0x0],r9
							AMBE_HT[0] = payload_rx_channel->dword[0];
80003abc:	6e 29       	ld.w	r9,r7[0x8]
80003abe:	fe f8 08 2e 	ld.w	r8,pc[2094]
80003ac2:	91 09       	st.w	r8[0x0],r9
							AMBE_HT[1] = payload_rx_channel->dword[1];
80003ac4:	6e 39       	ld.w	r9,r7[0xc]
80003ac6:	91 19       	st.w	r8[0x4],r9
							
							if (RxBytesWaiting == 0x00000014)
80003ac8:	fe f8 07 ec 	ld.w	r8,pc[2028]
80003acc:	70 08       	ld.w	r8,r8[0x0]
80003ace:	59 48       	cp.w	r8,20
80003ad0:	c0 61       	brne	80003adc <phy_rx_func+0x42c>
							{
								RxBytesWaiting = 0x18;//24 Reassigned
80003ad2:	31 89       	mov	r9,24
80003ad4:	fe f8 07 e0 	ld.w	r8,pc[2016]
80003ad8:	91 09       	st.w	r8[0x0],r9
80003ada:	c0 78       	rjmp	80003ae8 <phy_rx_func+0x438>
								//_flag =0;
								
							}
							if (RxBytesWaiting == 0x00000010)
80003adc:	59 08       	cp.w	r8,16
80003ade:	c0 51       	brne	80003ae8 <phy_rx_func+0x438>
							{
								RxBytesWaiting = 0x10;//16 Reassigned
80003ae0:	31 09       	mov	r9,16
80003ae2:	fe f8 07 d2 	ld.w	r8,pc[2002]
80003ae6:	91 09       	st.w	r8[0x0],r9
								//_flag =1;
							}
					
							RxMediaState = READING_AMBE_MEDIA;//Jump
80003ae8:	30 49       	mov	r9,4
80003aea:	fe f8 07 c2 	ld.w	r8,pc[1986]
80003aee:	91 09       	st.w	r8[0x0],r9
80003af0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
				break;
			}
			
			else
			{
				AMBE_Media = 0;	
80003af4:	30 09       	mov	r9,0
80003af6:	fe f8 07 ca 	ld.w	r8,pc[1994]
80003afa:	b0 89       	st.b	r8[0x0],r9
80003afc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

		case READING_AMBE_MEDIA:
		
			/****AMBE-media-data ****/
		
					if ((Item_ID == Vocoder_Bit_Stream_Parameter))//PAYLOAD_DATA_ENH (0x0c))
80003b00:	fe f8 07 c4 	ld.w	r8,pc[1988]
80003b04:	11 89       	ld.ub	r9,r8[0x0]
80003b06:	31 28       	mov	r8,18
80003b08:	f0 09 18 00 	cp.b	r9,r8
80003b0c:	e0 81 01 4c 	brne	80003da4 <phy_rx_func+0x6f4>
					{
						Item_ID = payload_rx_channel->byte[1];
80003b10:	ef 39 00 09 	ld.ub	r9,r7[9]
80003b14:	fe f8 07 b0 	ld.w	r8,pc[1968]
80003b18:	b0 89       	st.b	r8[0x0],r9
						if (Item_ID == Post_Voice_Encoder_Data)//发送方的压缩类型数据
80003b1a:	11 89       	ld.ub	r9,r8[0x0]
80003b1c:	3f 28       	mov	r8,-14
80003b1e:	f0 09 18 00 	cp.b	r9,r8
80003b22:	e0 81 01 3b 	brne	80003d98 <phy_rx_func+0x6e8>
						{
							AMBE_tx_flag = 1;
80003b26:	30 19       	mov	r9,1
80003b28:	fe f8 07 c8 	ld.w	r8,pc[1992]
80003b2c:	b0 89       	st.b	r8[0x0],r9
							
							RxBytesWaiting = ((payload_rx_channel->dword[0] & 0x7F000000) >>24);//Test calculations are correct; 8
80003b2e:	6e 29       	ld.w	r9,r7[0x8]
80003b30:	f3 d9 c3 07 	bfextu	r9,r9,0x18,0x7
80003b34:	fe f8 07 80 	ld.w	r8,pc[1920]
80003b38:	91 09       	st.w	r8[0x0],r9
							
							//For looping back to Radio
							AMBEBurst_rawdata[0] = payload_rx_channel->word[1];
80003b3a:	8e 59       	ld.sh	r9,r7[0xa]
80003b3c:	fe f8 07 b8 	ld.w	r8,pc[1976]
80003b40:	b0 09       	st.h	r8[0x0],r9
							AMBEBurst_rawdata[1] = payload_rx_channel->word[2];
80003b42:	8e 69       	ld.sh	r9,r7[0xc]
80003b44:	b0 19       	st.h	r8[0x2],r9
							AMBEBurst_rawdata[2] = payload_rx_channel->word[3];
80003b46:	8e 79       	ld.sh	r9,r7[0xe]
80003b48:	b0 29       	st.h	r8[0x4],r9
							
							//To be tested. Also locally stored RAW-AMBER-DATA
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//1
80003b4a:	fe f8 07 82 	ld.w	r8,pc[1922]
80003b4e:	fe f9 07 5a 	ld.w	r9,pc[1882]
80003b52:	72 0a       	ld.w	r10,r9[0x0]
80003b54:	70 09       	ld.w	r9,r8[0x0]
80003b56:	ef 3b 00 0a 	ld.ub	r11,r7[10]
80003b5a:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003b5e:	70 09       	ld.w	r9,r8[0x0]
80003b60:	2f f9       	sub	r9,-1
80003b62:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003b64:	e0 49 01 ff 	cp.w	r9,511
80003b68:	e0 88 00 16 	brls	80003b94 <phy_rx_func+0x4e4>
							{
								RxAMBE_IsFillingNext8 = 0;
80003b6c:	30 09       	mov	r9,0
80003b6e:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003b70:	fe f6 07 38 	ld.w	r6,pc[1848]
80003b74:	6c 0c       	ld.w	r12,r6[0x0]
80003b76:	f0 1f 01 d8 	mcall	800042d4 <phy_rx_func+0xc24>
								AMBE_payload_ptr = get_payload_idle_isr();
80003b7a:	fe f8 07 2a 	ld.w	r8,pc[1834]
80003b7e:	70 0c       	ld.w	r12,r8[0x0]
80003b80:	f0 1f 01 c3 	mcall	8000428c <phy_rx_func+0xbdc>
80003b84:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003b86:	c0 71       	brne	80003b94 <phy_rx_func+0x4e4>
								{
									RxMediaState = WAITINGABAB;
80003b88:	30 09       	mov	r9,0
80003b8a:	fe f8 07 22 	ld.w	r8,pc[1826]
80003b8e:	91 09       	st.w	r8[0x0],r9
80003b90:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003b94:	fe f9 07 20 	ld.w	r9,pc[1824]
80003b98:	72 08       	ld.w	r8,r9[0x0]
80003b9a:	20 18       	sub	r8,1
80003b9c:	93 08       	st.w	r9[0x0],r8
80003b9e:	c0 71       	brne	80003bac <phy_rx_func+0x4fc>
								RxMediaState = WAITINGABAB;
80003ba0:	30 09       	mov	r9,0
80003ba2:	fe f8 07 0a 	ld.w	r8,pc[1802]
80003ba6:	91 09       	st.w	r8[0x0],r9
80003ba8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}			
							
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//2
80003bac:	fe f8 07 20 	ld.w	r8,pc[1824]
80003bb0:	fe f9 06 f8 	ld.w	r9,pc[1784]
80003bb4:	72 0a       	ld.w	r10,r9[0x0]
80003bb6:	70 09       	ld.w	r9,r8[0x0]
80003bb8:	ef 3b 00 0b 	ld.ub	r11,r7[11]
80003bbc:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003bc0:	70 09       	ld.w	r9,r8[0x0]
80003bc2:	2f f9       	sub	r9,-1
80003bc4:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003bc6:	e0 49 01 ff 	cp.w	r9,511
80003bca:	e0 88 00 16 	brls	80003bf6 <phy_rx_func+0x546>
							{
								RxAMBE_IsFillingNext8 = 0;
80003bce:	30 09       	mov	r9,0
80003bd0:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003bd2:	fe f6 06 d6 	ld.w	r6,pc[1750]
80003bd6:	6c 0c       	ld.w	r12,r6[0x0]
80003bd8:	f0 1f 01 bf 	mcall	800042d4 <phy_rx_func+0xc24>
								AMBE_payload_ptr = get_payload_idle_isr();
80003bdc:	fe f8 06 c8 	ld.w	r8,pc[1736]
80003be0:	70 0c       	ld.w	r12,r8[0x0]
80003be2:	f0 1f 01 ab 	mcall	8000428c <phy_rx_func+0xbdc>
80003be6:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003be8:	c0 71       	brne	80003bf6 <phy_rx_func+0x546>
								{
									RxMediaState = WAITINGABAB;
80003bea:	30 09       	mov	r9,0
80003bec:	fe f8 06 c0 	ld.w	r8,pc[1728]
80003bf0:	91 09       	st.w	r8[0x0],r9
80003bf2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003bf6:	fe f9 06 be 	ld.w	r9,pc[1726]
80003bfa:	72 08       	ld.w	r8,r9[0x0]
80003bfc:	20 18       	sub	r8,1
80003bfe:	93 08       	st.w	r9[0x0],r8
80003c00:	c0 71       	brne	80003c0e <phy_rx_func+0x55e>
								RxMediaState = WAITINGABAB;
80003c02:	30 09       	mov	r9,0
80003c04:	fe f8 06 a8 	ld.w	r8,pc[1704]
80003c08:	91 09       	st.w	r8[0x0],r9
80003c0a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}		
						
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//3
80003c0e:	fe f8 06 be 	ld.w	r8,pc[1726]
80003c12:	fe f9 06 96 	ld.w	r9,pc[1686]
80003c16:	72 0a       	ld.w	r10,r9[0x0]
80003c18:	70 09       	ld.w	r9,r8[0x0]
80003c1a:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80003c1e:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003c22:	70 09       	ld.w	r9,r8[0x0]
80003c24:	2f f9       	sub	r9,-1
80003c26:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003c28:	e0 49 01 ff 	cp.w	r9,511
80003c2c:	e0 88 00 16 	brls	80003c58 <phy_rx_func+0x5a8>
							{
								RxAMBE_IsFillingNext8 = 0;
80003c30:	30 09       	mov	r9,0
80003c32:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003c34:	fe f6 06 74 	ld.w	r6,pc[1652]
80003c38:	6c 0c       	ld.w	r12,r6[0x0]
80003c3a:	f0 1f 01 a7 	mcall	800042d4 <phy_rx_func+0xc24>
								AMBE_payload_ptr = get_payload_idle_isr();
80003c3e:	fe f8 06 66 	ld.w	r8,pc[1638]
80003c42:	70 0c       	ld.w	r12,r8[0x0]
80003c44:	f0 1f 01 92 	mcall	8000428c <phy_rx_func+0xbdc>
80003c48:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003c4a:	c0 71       	brne	80003c58 <phy_rx_func+0x5a8>
								{
									RxMediaState = WAITINGABAB;
80003c4c:	30 09       	mov	r9,0
80003c4e:	fe f8 06 5e 	ld.w	r8,pc[1630]
80003c52:	91 09       	st.w	r8[0x0],r9
80003c54:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003c58:	fe f9 06 5c 	ld.w	r9,pc[1628]
80003c5c:	72 08       	ld.w	r8,r9[0x0]
80003c5e:	20 18       	sub	r8,1
80003c60:	93 08       	st.w	r9[0x0],r8
80003c62:	c0 71       	brne	80003c70 <phy_rx_func+0x5c0>
								RxMediaState = WAITINGABAB;
80003c64:	30 09       	mov	r9,0
80003c66:	fe f8 06 46 	ld.w	r8,pc[1606]
80003c6a:	91 09       	st.w	r8[0x0],r9
80003c6c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[5];//4
80003c70:	fe f8 06 5c 	ld.w	r8,pc[1628]
80003c74:	fe f9 06 34 	ld.w	r9,pc[1588]
80003c78:	72 0a       	ld.w	r10,r9[0x0]
80003c7a:	70 09       	ld.w	r9,r8[0x0]
80003c7c:	ef 3b 00 0d 	ld.ub	r11,r7[13]
80003c80:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003c84:	70 09       	ld.w	r9,r8[0x0]
80003c86:	2f f9       	sub	r9,-1
80003c88:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003c8a:	e0 49 01 ff 	cp.w	r9,511
80003c8e:	e0 88 00 16 	brls	80003cba <phy_rx_func+0x60a>
							{
								RxAMBE_IsFillingNext8 = 0;
80003c92:	30 09       	mov	r9,0
80003c94:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003c96:	fe f6 06 12 	ld.w	r6,pc[1554]
80003c9a:	6c 0c       	ld.w	r12,r6[0x0]
80003c9c:	f0 1f 01 8e 	mcall	800042d4 <phy_rx_func+0xc24>
								AMBE_payload_ptr = get_payload_idle_isr();
80003ca0:	fe f8 06 04 	ld.w	r8,pc[1540]
80003ca4:	70 0c       	ld.w	r12,r8[0x0]
80003ca6:	f0 1f 01 7a 	mcall	8000428c <phy_rx_func+0xbdc>
80003caa:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003cac:	c0 71       	brne	80003cba <phy_rx_func+0x60a>
								{
									RxMediaState = WAITINGABAB;
80003cae:	30 09       	mov	r9,0
80003cb0:	fe f8 05 fc 	ld.w	r8,pc[1532]
80003cb4:	91 09       	st.w	r8[0x0],r9
80003cb6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003cba:	fe f9 05 fa 	ld.w	r9,pc[1530]
80003cbe:	72 08       	ld.w	r8,r9[0x0]
80003cc0:	20 18       	sub	r8,1
80003cc2:	93 08       	st.w	r9[0x0],r8
80003cc4:	c0 71       	brne	80003cd2 <phy_rx_func+0x622>
								RxMediaState = WAITINGABAB;
80003cc6:	30 09       	mov	r9,0
80003cc8:	fe f8 05 e4 	ld.w	r8,pc[1508]
80003ccc:	91 09       	st.w	r8[0x0],r9
80003cce:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//5
80003cd2:	fe f8 05 fa 	ld.w	r8,pc[1530]
80003cd6:	fe f9 05 d2 	ld.w	r9,pc[1490]
80003cda:	72 0a       	ld.w	r10,r9[0x0]
80003cdc:	70 09       	ld.w	r9,r8[0x0]
80003cde:	ef 3b 00 0e 	ld.ub	r11,r7[14]
80003ce2:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003ce6:	70 09       	ld.w	r9,r8[0x0]
80003ce8:	2f f9       	sub	r9,-1
80003cea:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003cec:	e0 49 01 ff 	cp.w	r9,511
80003cf0:	e0 88 00 16 	brls	80003d1c <phy_rx_func+0x66c>
							{
								RxAMBE_IsFillingNext8 = 0;
80003cf4:	30 09       	mov	r9,0
80003cf6:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003cf8:	fe f6 05 b0 	ld.w	r6,pc[1456]
80003cfc:	6c 0c       	ld.w	r12,r6[0x0]
80003cfe:	f0 1f 01 76 	mcall	800042d4 <phy_rx_func+0xc24>
								AMBE_payload_ptr = get_payload_idle_isr();
80003d02:	fe f8 05 a2 	ld.w	r8,pc[1442]
80003d06:	70 0c       	ld.w	r12,r8[0x0]
80003d08:	f0 1f 01 61 	mcall	8000428c <phy_rx_func+0xbdc>
80003d0c:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003d0e:	c0 71       	brne	80003d1c <phy_rx_func+0x66c>
								{
									RxMediaState = WAITINGABAB;
80003d10:	30 09       	mov	r9,0
80003d12:	fe f8 05 9a 	ld.w	r8,pc[1434]
80003d16:	91 09       	st.w	r8[0x0],r9
80003d18:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003d1c:	fe f9 05 98 	ld.w	r9,pc[1432]
80003d20:	72 08       	ld.w	r8,r9[0x0]
80003d22:	20 18       	sub	r8,1
80003d24:	93 08       	st.w	r9[0x0],r8
80003d26:	c0 71       	brne	80003d34 <phy_rx_func+0x684>
								RxMediaState = WAITINGABAB;
80003d28:	30 09       	mov	r9,0
80003d2a:	fe f8 05 82 	ld.w	r8,pc[1410]
80003d2e:	91 09       	st.w	r8[0x0],r9
80003d30:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//6
80003d34:	fe f8 05 98 	ld.w	r8,pc[1432]
80003d38:	fe f9 05 70 	ld.w	r9,pc[1392]
80003d3c:	72 0a       	ld.w	r10,r9[0x0]
80003d3e:	70 09       	ld.w	r9,r8[0x0]
80003d40:	ef 3b 00 0f 	ld.ub	r11,r7[15]
80003d44:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003d48:	70 09       	ld.w	r9,r8[0x0]
80003d4a:	2f f9       	sub	r9,-1
80003d4c:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003d4e:	e0 49 01 ff 	cp.w	r9,511
80003d52:	e0 88 00 16 	brls	80003d7e <phy_rx_func+0x6ce>
							{
								RxAMBE_IsFillingNext8 = 0;
80003d56:	30 09       	mov	r9,0
80003d58:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003d5a:	fe f7 05 4e 	ld.w	r7,pc[1358]
80003d5e:	6e 0c       	ld.w	r12,r7[0x0]
80003d60:	f0 1f 01 5d 	mcall	800042d4 <phy_rx_func+0xc24>
								AMBE_payload_ptr = get_payload_idle_isr();
80003d64:	fe f8 05 40 	ld.w	r8,pc[1344]
80003d68:	70 0c       	ld.w	r12,r8[0x0]
80003d6a:	f0 1f 01 49 	mcall	8000428c <phy_rx_func+0xbdc>
80003d6e:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003d70:	c0 71       	brne	80003d7e <phy_rx_func+0x6ce>
								{
									RxMediaState = WAITINGABAB;
80003d72:	30 09       	mov	r9,0
80003d74:	fe f8 05 38 	ld.w	r8,pc[1336]
80003d78:	91 09       	st.w	r8[0x0],r9
80003d7a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003d7e:	fe f9 05 36 	ld.w	r9,pc[1334]
80003d82:	72 08       	ld.w	r8,r9[0x0]
80003d84:	20 18       	sub	r8,1
80003d86:	93 08       	st.w	r9[0x0],r8
80003d88:	e0 81 02 74 	brne	80004270 <phy_rx_func+0xbc0>
								RxMediaState = WAITINGABAB;
80003d8c:	30 09       	mov	r9,0
80003d8e:	fe f8 05 1e 	ld.w	r8,pc[1310]
80003d92:	91 09       	st.w	r8[0x0],r9
80003d94:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							//}
							
						}
						else//error
						{
							RxMediaState = WAITINGABAB;
80003d98:	30 09       	mov	r9,0
80003d9a:	fe f8 05 12 	ld.w	r8,pc[1298]
80003d9e:	91 09       	st.w	r8[0x0],r9
80003da0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
					}
					else if (Item_ID == Post_Voice_Encoder_Data)//(bit48~Pad-bits)
80003da4:	fe f8 05 20 	ld.w	r8,pc[1312]
80003da8:	11 89       	ld.ub	r9,r8[0x0]
80003daa:	3f 28       	mov	r8,-14
80003dac:	f0 09 18 00 	cp.b	r9,r8
80003db0:	c4 31       	brne	80003e36 <phy_rx_func+0x786>
					{
					
						AMBEBurst_rawdata[3] = payload_rx_channel->word[0];//(bit48~Pad-bits)
80003db2:	8e 49       	ld.sh	r9,r7[0x8]
80003db4:	fe f8 05 40 	ld.w	r8,pc[1344]
80003db8:	b0 39       	st.h	r8[0x6],r9
						//AMBE_Per_Burst_Flag = 1;
						
						//根据MOTO.bit文件数据分布，建议测试pad-bits的最后一个字节不保存。
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//7
80003dba:	fe f8 05 12 	ld.w	r8,pc[1298]
80003dbe:	fe f9 04 ea 	ld.w	r9,pc[1258]
80003dc2:	72 0a       	ld.w	r10,r9[0x0]
80003dc4:	70 09       	ld.w	r9,r8[0x0]
80003dc6:	ef 3b 00 08 	ld.ub	r11,r7[8]
80003dca:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003dce:	70 09       	ld.w	r9,r8[0x0]
80003dd0:	2f f9       	sub	r9,-1
80003dd2:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003dd4:	e0 49 01 ff 	cp.w	r9,511
80003dd8:	e0 88 00 16 	brls	80003e04 <phy_rx_func+0x754>
						{
							RxAMBE_IsFillingNext8 = 0;
80003ddc:	30 09       	mov	r9,0
80003dde:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003de0:	fe f7 04 c8 	ld.w	r7,pc[1224]
80003de4:	6e 0c       	ld.w	r12,r7[0x0]
80003de6:	f0 1f 01 3c 	mcall	800042d4 <phy_rx_func+0xc24>
							AMBE_payload_ptr = get_payload_idle_isr();
80003dea:	fe f8 04 ba 	ld.w	r8,pc[1210]
80003dee:	70 0c       	ld.w	r12,r8[0x0]
80003df0:	f0 1f 01 27 	mcall	8000428c <phy_rx_func+0xbdc>
80003df4:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003df6:	c0 71       	brne	80003e04 <phy_rx_func+0x754>
							{
								RxMediaState = WAITINGABAB;
80003df8:	30 09       	mov	r9,0
80003dfa:	fe f8 04 b2 	ld.w	r8,pc[1202]
80003dfe:	91 09       	st.w	r8[0x0],r9
80003e00:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003e04:	fe f9 04 b0 	ld.w	r9,pc[1200]
80003e08:	72 08       	ld.w	r8,r9[0x0]
80003e0a:	20 18       	sub	r8,1
80003e0c:	93 08       	st.w	r9[0x0],r8
80003e0e:	c0 71       	brne	80003e1c <phy_rx_func+0x76c>
							RxMediaState = WAITINGABAB;
80003e10:	30 09       	mov	r9,0
80003e12:	fe f8 04 9a 	ld.w	r8,pc[1178]
80003e16:	91 09       	st.w	r8[0x0],r9
80003e18:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
						if ((RxBytesWaiting -= 1) <= 0){//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
80003e1c:	20 18       	sub	r8,1
80003e1e:	fe f9 04 96 	ld.w	r9,pc[1174]
80003e22:	93 08       	st.w	r9[0x0],r8
80003e24:	58 08       	cp.w	r8,0
80003e26:	e0 81 02 25 	brne	80004270 <phy_rx_func+0xbc0>
							RxMediaState = WAITINGABAB;
80003e2a:	30 09       	mov	r9,0
80003e2c:	fe f8 04 80 	ld.w	r8,pc[1152]
80003e30:	91 09       	st.w	r8[0x0],r9
80003e32:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
								
					}
					else if (Item_ID == Pre_Voice_Decoder_Data)//bit16~bit63
80003e36:	fe f8 04 8e 	ld.w	r8,pc[1166]
80003e3a:	11 89       	ld.ub	r9,r8[0x0]
80003e3c:	3f 38       	mov	r8,-13
80003e3e:	f0 09 18 00 	cp.b	r9,r8
80003e42:	e0 81 01 0c 	brne	8000405a <phy_rx_func+0x9aa>
					{
						//接收方的解压类型数据
						//For looping back to Radio
						AMBEBurst_rawdata[1] = payload_rx_channel->word[0];
80003e46:	8e 49       	ld.sh	r9,r7[0x8]
80003e48:	fe f8 04 ac 	ld.w	r8,pc[1196]
80003e4c:	b0 19       	st.h	r8[0x2],r9
						AMBEBurst_rawdata[2] = payload_rx_channel->word[1];
80003e4e:	8e 59       	ld.sh	r9,r7[0xa]
80003e50:	b0 29       	st.h	r8[0x4],r9
						AMBEBurst_rawdata[3] = payload_rx_channel->word[2];
80003e52:	8e 69       	ld.sh	r9,r7[0xc]
80003e54:	b0 39       	st.h	r8[0x6],r9
						//if((m_RxBurstType == VOICEBURST_A) && (VF_SN == 1))
						//logFromISR("\n\r Pre_rx:%X\n\r", payload_rx_channel->word[2]);
						
						//To be tested. Also locally stored RAW-AMBER-DATA
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//3
80003e56:	fe f8 04 76 	ld.w	r8,pc[1142]
80003e5a:	fe f9 04 4e 	ld.w	r9,pc[1102]
80003e5e:	72 0a       	ld.w	r10,r9[0x0]
80003e60:	70 09       	ld.w	r9,r8[0x0]
80003e62:	ef 3b 00 08 	ld.ub	r11,r7[8]
80003e66:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003e6a:	70 09       	ld.w	r9,r8[0x0]
80003e6c:	2f f9       	sub	r9,-1
80003e6e:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003e70:	e0 49 01 ff 	cp.w	r9,511
80003e74:	e0 88 00 16 	brls	80003ea0 <phy_rx_func+0x7f0>
						{
							RxAMBE_IsFillingNext8 = 0;
80003e78:	30 09       	mov	r9,0
80003e7a:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003e7c:	fe f6 04 2c 	ld.w	r6,pc[1068]
80003e80:	6c 0c       	ld.w	r12,r6[0x0]
80003e82:	f0 1f 01 15 	mcall	800042d4 <phy_rx_func+0xc24>
							AMBE_payload_ptr = get_payload_idle_isr();
80003e86:	fe f8 04 1e 	ld.w	r8,pc[1054]
80003e8a:	70 0c       	ld.w	r12,r8[0x0]
80003e8c:	f0 1f 01 00 	mcall	8000428c <phy_rx_func+0xbdc>
80003e90:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003e92:	c0 71       	brne	80003ea0 <phy_rx_func+0x7f0>
							{
								RxMediaState = WAITINGABAB;
80003e94:	30 09       	mov	r9,0
80003e96:	fe f8 04 16 	ld.w	r8,pc[1046]
80003e9a:	91 09       	st.w	r8[0x0],r9
80003e9c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003ea0:	fe f9 04 14 	ld.w	r9,pc[1044]
80003ea4:	72 08       	ld.w	r8,r9[0x0]
80003ea6:	20 18       	sub	r8,1
80003ea8:	93 08       	st.w	r9[0x0],r8
80003eaa:	c0 71       	brne	80003eb8 <phy_rx_func+0x808>
							RxMediaState = WAITINGABAB;
80003eac:	30 09       	mov	r9,0
80003eae:	fe f8 03 fe 	ld.w	r8,pc[1022]
80003eb2:	91 09       	st.w	r8[0x0],r9
80003eb4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[1];//4
80003eb8:	fe f8 04 14 	ld.w	r8,pc[1044]
80003ebc:	fe f9 03 ec 	ld.w	r9,pc[1004]
80003ec0:	72 0a       	ld.w	r10,r9[0x0]
80003ec2:	70 09       	ld.w	r9,r8[0x0]
80003ec4:	ef 3b 00 09 	ld.ub	r11,r7[9]
80003ec8:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003ecc:	70 09       	ld.w	r9,r8[0x0]
80003ece:	2f f9       	sub	r9,-1
80003ed0:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003ed2:	e0 49 01 ff 	cp.w	r9,511
80003ed6:	e0 88 00 16 	brls	80003f02 <phy_rx_func+0x852>
						{
							RxAMBE_IsFillingNext8 = 0;
80003eda:	30 09       	mov	r9,0
80003edc:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003ede:	fe f6 03 ca 	ld.w	r6,pc[970]
80003ee2:	6c 0c       	ld.w	r12,r6[0x0]
80003ee4:	f0 1f 00 fc 	mcall	800042d4 <phy_rx_func+0xc24>
							AMBE_payload_ptr = get_payload_idle_isr();
80003ee8:	fe f8 03 bc 	ld.w	r8,pc[956]
80003eec:	70 0c       	ld.w	r12,r8[0x0]
80003eee:	f0 1f 00 e8 	mcall	8000428c <phy_rx_func+0xbdc>
80003ef2:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003ef4:	c0 71       	brne	80003f02 <phy_rx_func+0x852>
							{
								RxMediaState = WAITINGABAB;
80003ef6:	30 09       	mov	r9,0
80003ef8:	fe f8 03 b4 	ld.w	r8,pc[948]
80003efc:	91 09       	st.w	r8[0x0],r9
80003efe:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003f02:	fe f9 03 b2 	ld.w	r9,pc[946]
80003f06:	72 08       	ld.w	r8,r9[0x0]
80003f08:	20 18       	sub	r8,1
80003f0a:	93 08       	st.w	r9[0x0],r8
80003f0c:	c0 71       	brne	80003f1a <phy_rx_func+0x86a>
							RxMediaState = WAITINGABAB;
80003f0e:	30 09       	mov	r9,0
80003f10:	fe f8 03 9c 	ld.w	r8,pc[924]
80003f14:	91 09       	st.w	r8[0x0],r9
80003f16:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//5
80003f1a:	fe f8 03 b2 	ld.w	r8,pc[946]
80003f1e:	fe f9 03 8a 	ld.w	r9,pc[906]
80003f22:	72 0a       	ld.w	r10,r9[0x0]
80003f24:	70 09       	ld.w	r9,r8[0x0]
80003f26:	ef 3b 00 0a 	ld.ub	r11,r7[10]
80003f2a:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003f2e:	70 09       	ld.w	r9,r8[0x0]
80003f30:	2f f9       	sub	r9,-1
80003f32:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003f34:	e0 49 01 ff 	cp.w	r9,511
80003f38:	e0 88 00 16 	brls	80003f64 <phy_rx_func+0x8b4>
						{
							RxAMBE_IsFillingNext8 = 0;
80003f3c:	30 09       	mov	r9,0
80003f3e:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003f40:	fe f6 03 68 	ld.w	r6,pc[872]
80003f44:	6c 0c       	ld.w	r12,r6[0x0]
80003f46:	f0 1f 00 e4 	mcall	800042d4 <phy_rx_func+0xc24>
							AMBE_payload_ptr = get_payload_idle_isr();
80003f4a:	fe f8 03 5a 	ld.w	r8,pc[858]
80003f4e:	70 0c       	ld.w	r12,r8[0x0]
80003f50:	f0 1f 00 cf 	mcall	8000428c <phy_rx_func+0xbdc>
80003f54:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003f56:	c0 71       	brne	80003f64 <phy_rx_func+0x8b4>
							{
								RxMediaState = WAITINGABAB;
80003f58:	30 09       	mov	r9,0
80003f5a:	fe f8 03 52 	ld.w	r8,pc[850]
80003f5e:	91 09       	st.w	r8[0x0],r9
80003f60:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003f64:	fe f9 03 50 	ld.w	r9,pc[848]
80003f68:	72 08       	ld.w	r8,r9[0x0]
80003f6a:	20 18       	sub	r8,1
80003f6c:	93 08       	st.w	r9[0x0],r8
80003f6e:	c0 71       	brne	80003f7c <phy_rx_func+0x8cc>
							RxMediaState = WAITINGABAB;
80003f70:	30 09       	mov	r9,0
80003f72:	fe f8 03 3a 	ld.w	r8,pc[826]
80003f76:	91 09       	st.w	r8[0x0],r9
80003f78:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//6
80003f7c:	fe f8 03 50 	ld.w	r8,pc[848]
80003f80:	fe f9 03 28 	ld.w	r9,pc[808]
80003f84:	72 0a       	ld.w	r10,r9[0x0]
80003f86:	70 09       	ld.w	r9,r8[0x0]
80003f88:	ef 3b 00 0b 	ld.ub	r11,r7[11]
80003f8c:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003f90:	70 09       	ld.w	r9,r8[0x0]
80003f92:	2f f9       	sub	r9,-1
80003f94:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003f96:	e0 49 01 ff 	cp.w	r9,511
80003f9a:	e0 88 00 16 	brls	80003fc6 <phy_rx_func+0x916>
						{
							RxAMBE_IsFillingNext8 = 0;
80003f9e:	30 09       	mov	r9,0
80003fa0:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003fa2:	fe f6 03 06 	ld.w	r6,pc[774]
80003fa6:	6c 0c       	ld.w	r12,r6[0x0]
80003fa8:	f0 1f 00 cb 	mcall	800042d4 <phy_rx_func+0xc24>
							AMBE_payload_ptr = get_payload_idle_isr();
80003fac:	fe f8 02 f8 	ld.w	r8,pc[760]
80003fb0:	70 0c       	ld.w	r12,r8[0x0]
80003fb2:	f0 1f 00 b7 	mcall	8000428c <phy_rx_func+0xbdc>
80003fb6:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003fb8:	c0 71       	brne	80003fc6 <phy_rx_func+0x916>
							{
								RxMediaState = WAITINGABAB;
80003fba:	30 09       	mov	r9,0
80003fbc:	fe f8 02 f0 	ld.w	r8,pc[752]
80003fc0:	91 09       	st.w	r8[0x0],r9
80003fc2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003fc6:	fe f9 02 ee 	ld.w	r9,pc[750]
80003fca:	72 08       	ld.w	r8,r9[0x0]
80003fcc:	20 18       	sub	r8,1
80003fce:	93 08       	st.w	r9[0x0],r8
80003fd0:	c0 71       	brne	80003fde <phy_rx_func+0x92e>
							RxMediaState = WAITINGABAB;
80003fd2:	30 09       	mov	r9,0
80003fd4:	fe f8 02 d8 	ld.w	r8,pc[728]
80003fd8:	91 09       	st.w	r8[0x0],r9
80003fda:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//7
80003fde:	fe f8 02 ee 	ld.w	r8,pc[750]
80003fe2:	fe f9 02 c6 	ld.w	r9,pc[710]
80003fe6:	72 0a       	ld.w	r10,r9[0x0]
80003fe8:	70 09       	ld.w	r9,r8[0x0]
80003fea:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80003fee:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003ff2:	70 09       	ld.w	r9,r8[0x0]
80003ff4:	2f f9       	sub	r9,-1
80003ff6:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003ff8:	e0 49 01 ff 	cp.w	r9,511
80003ffc:	e0 88 00 16 	brls	80004028 <phy_rx_func+0x978>
						{
							RxAMBE_IsFillingNext8 = 0;
80004000:	30 09       	mov	r9,0
80004002:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80004004:	fe f7 02 a4 	ld.w	r7,pc[676]
80004008:	6e 0c       	ld.w	r12,r7[0x0]
8000400a:	f0 1f 00 b3 	mcall	800042d4 <phy_rx_func+0xc24>
							AMBE_payload_ptr = get_payload_idle_isr();
8000400e:	fe f8 02 96 	ld.w	r8,pc[662]
80004012:	70 0c       	ld.w	r12,r8[0x0]
80004014:	f0 1f 00 9e 	mcall	8000428c <phy_rx_func+0xbdc>
80004018:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
8000401a:	c0 71       	brne	80004028 <phy_rx_func+0x978>
							{
								RxMediaState = WAITINGABAB;
8000401c:	30 09       	mov	r9,0
8000401e:	fe f8 02 8e 	ld.w	r8,pc[654]
80004022:	91 09       	st.w	r8[0x0],r9
80004024:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80004028:	fe f9 02 8c 	ld.w	r9,pc[652]
8000402c:	72 08       	ld.w	r8,r9[0x0]
8000402e:	20 18       	sub	r8,1
80004030:	93 08       	st.w	r9[0x0],r8
80004032:	c0 71       	brne	80004040 <phy_rx_func+0x990>
							RxMediaState = WAITINGABAB;
80004034:	30 09       	mov	r9,0
80004036:	fe f8 02 76 	ld.w	r8,pc[630]
8000403a:	91 09       	st.w	r8[0x0],r9
8000403c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
						if ((RxBytesWaiting -= 1) <= 0){
80004040:	20 18       	sub	r8,1
80004042:	fe f9 02 72 	ld.w	r9,pc[626]
80004046:	93 08       	st.w	r9[0x0],r8
80004048:	58 08       	cp.w	r8,0
8000404a:	e0 81 01 13 	brne	80004270 <phy_rx_func+0xbc0>
							
							//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
							//or discard it to reduce payload size.
							
							RxMediaState = WAITINGABAB;
8000404e:	30 09       	mov	r9,0
80004050:	fe f8 02 5c 	ld.w	r8,pc[604]
80004054:	91 09       	st.w	r8[0x0],r9
80004056:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
					}
					else if ((Item_ID == 0x04)  ||  (Item_ID == 0x03))//Unknown type data directly back hair
8000405a:	fe f8 02 6a 	ld.w	r8,pc[618]
8000405e:	11 89       	ld.ub	r9,r8[0x0]
80004060:	30 48       	mov	r8,4
80004062:	f0 09 18 00 	cp.b	r9,r8
80004066:	c0 80       	breq	80004076 <phy_rx_func+0x9c6>
80004068:	fe f8 02 5c 	ld.w	r8,pc[604]
8000406c:	11 89       	ld.ub	r9,r8[0x0]
8000406e:	30 38       	mov	r8,3
80004070:	f0 09 18 00 	cp.b	r9,r8
80004074:	c1 41       	brne	8000409c <phy_rx_func+0x9ec>
					{
						AMBE_HT[0] = payload_rx_channel->dword[0];
80004076:	6e 29       	ld.w	r9,r7[0x8]
80004078:	fe f8 02 74 	ld.w	r8,pc[628]
8000407c:	91 09       	st.w	r8[0x0],r9
						AMBE_HT[1] = payload_rx_channel->dword[1];				
8000407e:	6e 39       	ld.w	r9,r7[0xc]
80004080:	91 19       	st.w	r8[0x4],r9
						
						if ((RxBytesWaiting -= 8) <= 0)//Consider two cases 0xABCDC014 and 0xABCDC010
80004082:	fe f9 02 32 	ld.w	r9,pc[562]
80004086:	72 08       	ld.w	r8,r9[0x0]
80004088:	20 88       	sub	r8,8
8000408a:	93 08       	st.w	r9[0x0],r8
8000408c:	e0 81 00 f2 	brne	80004270 <phy_rx_func+0xbc0>
						{
					
							RxBytesWaiting = 0;
80004090:	93 08       	st.w	r9[0x0],r8
							RxMediaState = WAITINGABAB;
80004092:	fe f9 02 1a 	ld.w	r9,pc[538]
80004096:	93 08       	st.w	r9[0x0],r8
80004098:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
						}
						break;

					}
					else if (Item_ID == Soft_Decision_Value)
8000409c:	fe f8 02 28 	ld.w	r8,pc[552]
800040a0:	11 89       	ld.ub	r9,r8[0x0]
800040a2:	31 38       	mov	r8,19
800040a4:	f0 09 18 00 	cp.b	r9,r8
800040a8:	e0 81 00 9c 	brne	800041e0 <phy_rx_func+0xb30>
					{							
						if (SDV_Index == 12)
800040ac:	fe f8 02 4c 	ld.w	r8,pc[588]
800040b0:	11 88       	ld.ub	r8,r8[0x0]
800040b2:	30 c9       	mov	r9,12
800040b4:	f2 08 18 00 	cp.b	r8,r9
800040b8:	e0 81 00 7b 	brne	800041ae <phy_rx_func+0xafe>
						{
							Soft_Decision_Data[SDV_Index]= payload_rx_channel->word[0];
800040bc:	8e 49       	ld.sh	r9,r7[0x8]
800040be:	fe f8 02 3e 	ld.w	r8,pc[574]
800040c2:	f1 59 00 18 	st.h	r8[24],r9
							
							SDV_Index = 0;
800040c6:	30 09       	mov	r9,0
800040c8:	fe f8 02 30 	ld.w	r8,pc[560]
800040cc:	b0 89       	st.b	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
800040ce:	ef 39 00 0d 	ld.ub	r9,r7[13]
800040d2:	3f 38       	mov	r8,-13
800040d4:	f0 09 18 00 	cp.b	r9,r8
800040d8:	c6 61       	brne	800041a4 <phy_rx_func+0xaf4>
							
							SDV_Index = 0;
								
							if (payload_rx_channel->byte[5] == Pre_Voice_Decoder_Data )//0xF3
							{
									Item_ID = Pre_Voice_Decoder_Data;
800040da:	10 99       	mov	r9,r8
800040dc:	4f a8       	lddpc	r8,800042c4 <phy_rx_func+0xc14>
800040de:	b0 89       	st.b	r8[0x0],r9
									RxBytesWaiting = (payload_rx_channel->byte[4] & 0x7F);//Test calculations are correct; 8
800040e0:	ef 39 00 0c 	ld.ub	r9,r7[12]
800040e4:	f3 d9 c0 07 	bfextu	r9,r9,0x0,0x7
800040e8:	4f 38       	lddpc	r8,800042b4 <phy_rx_func+0xc04>
800040ea:	91 09       	st.w	r8[0x0],r9
									AMBE_rx_flag = 1;//本地作为AMBE数据的解密方
800040ec:	30 19       	mov	r9,1
800040ee:	fe f8 02 12 	ld.w	r8,pc[530]
800040f2:	b0 89       	st.b	r8[0x0],r9
		
									AMBEBurst_rawdata[0] = payload_rx_channel->word[3];//用于解密的中间数据变量
800040f4:	8e 79       	ld.sh	r9,r7[0xe]
800040f6:	fe f8 01 fe 	ld.w	r8,pc[510]
800040fa:	b0 09       	st.h	r8[0x0],r9
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//1
800040fc:	4f 48       	lddpc	r8,800042cc <phy_rx_func+0xc1c>
800040fe:	4e b9       	lddpc	r9,800042a8 <phy_rx_func+0xbf8>
80004100:	72 0a       	ld.w	r10,r9[0x0]
80004102:	70 09       	ld.w	r9,r8[0x0]
80004104:	ef 3b 00 0e 	ld.ub	r11,r7[14]
80004108:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
8000410c:	70 09       	ld.w	r9,r8[0x0]
8000410e:	2f f9       	sub	r9,-1
80004110:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80004112:	e0 49 01 ff 	cp.w	r9,511
80004116:	e0 88 00 13 	brls	8000413c <phy_rx_func+0xa8c>
									{
										RxAMBE_IsFillingNext8 = 0;
8000411a:	30 09       	mov	r9,0
8000411c:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
8000411e:	4e 36       	lddpc	r6,800042a8 <phy_rx_func+0xbf8>
80004120:	6c 0c       	ld.w	r12,r6[0x0]
80004122:	f0 1f 00 6d 	mcall	800042d4 <phy_rx_func+0xc24>
										AMBE_payload_ptr = get_payload_idle_isr();
80004126:	4e 08       	lddpc	r8,800042a4 <phy_rx_func+0xbf4>
80004128:	70 0c       	ld.w	r12,r8[0x0]
8000412a:	f0 1f 00 59 	mcall	8000428c <phy_rx_func+0xbdc>
8000412e:	8d 0c       	st.w	r6[0x0],r12
										if(NULL == AMBE_payload_ptr)
80004130:	c0 61       	brne	8000413c <phy_rx_func+0xa8c>
										{
											RxMediaState = WAITINGABAB;
80004132:	30 09       	mov	r9,0
80004134:	4d e8       	lddpc	r8,800042ac <phy_rx_func+0xbfc>
80004136:	91 09       	st.w	r8[0x0],r9
80004138:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
8000413c:	4d e9       	lddpc	r9,800042b4 <phy_rx_func+0xc04>
8000413e:	72 08       	ld.w	r8,r9[0x0]
80004140:	20 18       	sub	r8,1
80004142:	93 08       	st.w	r9[0x0],r8
80004144:	c0 61       	brne	80004150 <phy_rx_func+0xaa0>
										RxMediaState = WAITINGABAB;
80004146:	30 09       	mov	r9,0
80004148:	4d 98       	lddpc	r8,800042ac <phy_rx_func+0xbfc>
8000414a:	91 09       	st.w	r8[0x0],r9
8000414c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//2
80004150:	4d f8       	lddpc	r8,800042cc <phy_rx_func+0xc1c>
80004152:	4d 69       	lddpc	r9,800042a8 <phy_rx_func+0xbf8>
80004154:	72 0a       	ld.w	r10,r9[0x0]
80004156:	70 09       	ld.w	r9,r8[0x0]
80004158:	ef 3b 00 0f 	ld.ub	r11,r7[15]
8000415c:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
80004160:	70 09       	ld.w	r9,r8[0x0]
80004162:	2f f9       	sub	r9,-1
80004164:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80004166:	e0 49 01 ff 	cp.w	r9,511
8000416a:	e0 88 00 13 	brls	80004190 <phy_rx_func+0xae0>
									{
										RxAMBE_IsFillingNext8 = 0;
8000416e:	30 09       	mov	r9,0
80004170:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
80004172:	4c e7       	lddpc	r7,800042a8 <phy_rx_func+0xbf8>
80004174:	6e 0c       	ld.w	r12,r7[0x0]
80004176:	f0 1f 00 58 	mcall	800042d4 <phy_rx_func+0xc24>
										AMBE_payload_ptr = get_payload_idle_isr();
8000417a:	4c b8       	lddpc	r8,800042a4 <phy_rx_func+0xbf4>
8000417c:	70 0c       	ld.w	r12,r8[0x0]
8000417e:	f0 1f 00 44 	mcall	8000428c <phy_rx_func+0xbdc>
80004182:	8f 0c       	st.w	r7[0x0],r12
										if(NULL == AMBE_payload_ptr)
80004184:	c0 61       	brne	80004190 <phy_rx_func+0xae0>
										{
											RxMediaState = WAITINGABAB;
80004186:	30 09       	mov	r9,0
80004188:	4c 98       	lddpc	r8,800042ac <phy_rx_func+0xbfc>
8000418a:	91 09       	st.w	r8[0x0],r9
8000418c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
80004190:	4c 99       	lddpc	r9,800042b4 <phy_rx_func+0xc04>
80004192:	72 08       	ld.w	r8,r9[0x0]
80004194:	20 18       	sub	r8,1
80004196:	93 08       	st.w	r9[0x0],r8
80004198:	c6 c1       	brne	80004270 <phy_rx_func+0xbc0>
										RxMediaState = WAITINGABAB;
8000419a:	30 09       	mov	r9,0
8000419c:	4c 48       	lddpc	r8,800042ac <phy_rx_func+0xbfc>
8000419e:	91 09       	st.w	r8[0x0],r9
800041a0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
							}
							else
							RxMediaState = WAITINGABAB;
800041a4:	30 09       	mov	r9,0
800041a6:	4c 28       	lddpc	r8,800042ac <phy_rx_func+0xbfc>
800041a8:	91 09       	st.w	r8[0x0],r9
800041aa:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
						}
						else
						{
									
							Soft_Decision_Data[SDV_Index]	  = payload_rx_channel->word[0];
800041ae:	8e 4a       	ld.sh	r10,r7[0x8]
800041b0:	4d 39       	lddpc	r9,800042fc <phy_rx_func+0xc4c>
800041b2:	f2 08 0a 1a 	st.h	r9[r8<<0x1],r10
							Soft_Decision_Data[SDV_Index+1]	  = payload_rx_channel->word[1];
800041b6:	4d 1a       	lddpc	r10,800042f8 <phy_rx_func+0xc48>
800041b8:	15 88       	ld.ub	r8,r10[0x0]
800041ba:	f0 cb ff ff 	sub	r11,r8,-1
800041be:	8e 5c       	ld.sh	r12,r7[0xa]
800041c0:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+2]	  = payload_rx_channel->word[2];
800041c4:	f0 cb ff fe 	sub	r11,r8,-2
800041c8:	8e 6c       	ld.sh	r12,r7[0xc]
800041ca:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+3]	  = payload_rx_channel->word[3];
800041ce:	f0 cb ff fd 	sub	r11,r8,-3
800041d2:	8e 7c       	ld.sh	r12,r7[0xe]
800041d4:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							SDV_Index +=4;
800041d8:	2f c8       	sub	r8,-4
800041da:	b4 88       	st.b	r10[0x0],r8
800041dc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					
					else
					{
						
						RxMediaState  = WAITINGABAB;
800041e0:	30 09       	mov	r9,0
800041e2:	4b 38       	lddpc	r8,800042ac <phy_rx_func+0xbfc>
800041e4:	91 09       	st.w	r8[0x0],r9
800041e6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
			break;//End of READING_AMBE_MEDIA.

        case READING_AMBE_AUX:
			
				Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[0];
800041ea:	4b f8       	lddpc	r8,800042e4 <phy_rx_func+0xc34>
800041ec:	70 09       	ld.w	r9,r8[0x0]
800041ee:	8e 4b       	ld.sh	r11,r7[0x8]
800041f0:	4b ea       	lddpc	r10,800042e8 <phy_rx_func+0xc38>
800041f2:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
				RxData_IsFillingNext16 += 1;
800041f6:	2f f9       	sub	r9,-1
800041f8:	91 09       	st.w	r8[0x0],r9
			
				if ((Item_Length -= 2) <= 0)
800041fa:	4b 48       	lddpc	r8,800042c8 <phy_rx_func+0xc18>
800041fc:	70 09       	ld.w	r9,r8[0x0]
800041fe:	20 29       	sub	r9,2
80004200:	91 09       	st.w	r8[0x0],r9
80004202:	70 08       	ld.w	r8,r8[0x0]
80004204:	58 08       	cp.w	r8,0
80004206:	c2 f1       	brne	80004264 <phy_rx_func+0xbb4>
				{
					RxData_IsFillingNext16 = 0;
80004208:	30 09       	mov	r9,0
8000420a:	4b 78       	lddpc	r8,800042e4 <phy_rx_func+0xc34>
8000420c:	91 09       	st.w	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
8000420e:	8e 59       	ld.sh	r9,r7[0xa]
80004210:	fe 78 82 12 	mov	r8,-32238
80004214:	f0 09 19 00 	cp.h	r9,r8
80004218:	c2 11       	brne	8000425a <phy_rx_func+0xbaa>
					{
						//Item_ID = Vocoder_Bit_Stream_Parameter;
						//Vocoder Bits Stream Parameter
						//Its value ranges from 1 to 18 for one voice superframe contains 6 voice bursts
						// and each burst contains 3 VFs.
						VF_SN = (payload_rx_channel->byte[5] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
8000421a:	ef 3c 00 0d 	ld.ub	r12,r7[13]
8000421e:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
80004222:	4a e8       	lddpc	r8,800042d8 <phy_rx_func+0xc28>
80004224:	b0 8c       	st.b	r8[0x0],r12
							
						VBSP_data[0] = payload_rx_channel->word[1];
80004226:	8e 59       	ld.sh	r9,r7[0xa]
80004228:	4a d8       	lddpc	r8,800042dc <phy_rx_func+0xc2c>
8000422a:	b0 09       	st.h	r8[0x0],r9
						VBSP_data[1] = payload_rx_channel->word[2];
8000422c:	8e 69       	ld.sh	r9,r7[0xc]
8000422e:	b0 19       	st.h	r8[0x2],r9
							
						m_RxBurstType = CalculateBurst(VF_SN);
80004230:	f0 1f 00 2c 	mcall	800042e0 <phy_rx_func+0xc30>
80004234:	49 f8       	lddpc	r8,800042b0 <phy_rx_func+0xc00>
80004236:	91 0c       	st.w	r8[0x0],r12
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80004238:	ef 39 00 0f 	ld.ub	r9,r7[15]
8000423c:	31 38       	mov	r8,19
8000423e:	f0 09 18 00 	cp.b	r9,r8
80004242:	c0 71       	brne	80004250 <phy_rx_func+0xba0>
							
						m_RxBurstType = CalculateBurst(VF_SN);
						
						if (payload_rx_channel->byte[7] == Soft_Decision_Value)//0x13
						{
							Item_ID = Soft_Decision_Value;	
80004244:	10 99       	mov	r9,r8
80004246:	4a 08       	lddpc	r8,800042c4 <phy_rx_func+0xc14>
80004248:	b0 89       	st.b	r8[0x0],r9
							RxBytesWaiting = ((payload_rx_channel->dword[1] & 0x00007F00) >>24);//Test calculations are correct; 26
8000424a:	30 09       	mov	r9,0
8000424c:	49 a8       	lddpc	r8,800042b4 <phy_rx_func+0xc04>
8000424e:	91 09       	st.w	r8[0x0],r9
						else
						{//error
								RxMediaState = WAITINGABAB;//Jump
						}
							
						RxMediaState = READING_AMBE_MEDIA;//Jump
80004250:	30 49       	mov	r9,4
80004252:	49 78       	lddpc	r8,800042ac <phy_rx_func+0xbfc>
80004254:	91 09       	st.w	r8[0x0],r9
80004256:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					else
					{
						RxMediaState = WAITINGABAB;//Jump
8000425a:	30 09       	mov	r9,0
8000425c:	49 48       	lddpc	r8,800042ac <phy_rx_func+0xbfc>
8000425e:	91 09       	st.w	r8[0x0],r9
80004260:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}

				}
				else
				{//测试看看是几个字节数据
					logFromISR("\n\r Radio Internal parameter length error \n\r");
80004264:	4a 8c       	lddpc	r12,80004304 <phy_rx_func+0xc54>
80004266:	f0 1f 00 16 	mcall	800042bc <phy_rx_func+0xc0c>
					RxMediaState = WAITINGABAB;//Jump
8000426a:	30 09       	mov	r9,0
8000426c:	49 08       	lddpc	r8,800042ac <phy_rx_func+0xbfc>
8000426e:	91 09       	st.w	r8[0x0],r9
80004270:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80004274:	00 00       	add	r0,r0
80004276:	0a c4       	st.b	r5++,r4
80004278:	00 00       	add	r0,r0
8000427a:	0a bc       	st.h	r5++,r12
8000427c:	00 00       	add	r0,r0
8000427e:	0a 90       	mov	r0,r5
80004280:	00 00       	add	r0,r0
80004282:	0a 6c       	and	r12,r5
80004284:	00 00       	add	r0,r0
80004286:	0a d6       	st.w	--r5,r6
80004288:	00 00       	add	r0,r0
8000428a:	0a 9c       	mov	r12,r5
8000428c:	80 00       	ld.sh	r0,r0[0x0]
8000428e:	30 7c       	mov	r12,7
80004290:	00 00       	add	r0,r0
80004292:	0a 7c       	tst	r12,r5
80004294:	80 00       	ld.sh	r0,r0[0x0]
80004296:	5e 6c       	retmi	r12
80004298:	00 00       	add	r0,r0
8000429a:	0a 98       	mov	r8,r5
8000429c:	80 00       	ld.sh	r0,r0[0x0]
8000429e:	2f c8       	sub	r8,-4
800042a0:	00 00       	add	r0,r0
800042a2:	0a ac       	st.w	r5++,r12
800042a4:	00 00       	add	r0,r0
800042a6:	0a 78       	tst	r8,r5
800042a8:	00 00       	add	r0,r0
800042aa:	0a b4       	st.h	r5++,r4
800042ac:	00 00       	add	r0,r0
800042ae:	0a 88       	andn	r8,r5
800042b0:	00 00       	add	r0,r0
800042b2:	0a 74       	tst	r4,r5
800042b4:	00 00       	add	r0,r0
800042b6:	0a a0       	st.w	r5++,r0
800042b8:	80 00       	ld.sh	r0,r0[0x0]
800042ba:	db 84       	*unknown*
800042bc:	80 00       	ld.sh	r0,r0[0x0]
800042be:	6f 0c       	ld.w	r12,r7[0x40]
800042c0:	00 00       	add	r0,r0
800042c2:	0a 4a       	or	r10,r5
800042c4:	00 00       	add	r0,r0
800042c6:	0a d4       	st.w	--r5,r4
800042c8:	00 00       	add	r0,r0
800042ca:	0a 70       	tst	r0,r5
800042cc:	00 00       	add	r0,r0
800042ce:	0a b0       	st.h	r5++,r0
800042d0:	80 00       	ld.sh	r0,r0[0x0]
800042d2:	78 82       	ld.w	r2,r12[0x20]
800042d4:	80 00       	ld.sh	r0,r0[0x0]
800042d6:	36 50       	mov	r0,101
800042d8:	00 00       	add	r0,r0
800042da:	0a 4b       	or	r11,r5
800042dc:	00 00       	add	r0,r0
800042de:	1e 94       	mov	r4,pc
800042e0:	80 00       	ld.sh	r0,r0[0x0]
800042e2:	2f 0c       	sub	r12,-16
800042e4:	00 00       	add	r0,r0
800042e6:	0a cc       	st.b	r5++,r12
800042e8:	00 00       	add	r0,r0
800042ea:	1d 98       	ld.ub	r8,lr[0x1]
800042ec:	00 00       	add	r0,r0
800042ee:	0a d8       	st.w	--r5,r8
800042f0:	00 00       	add	r0,r0
800042f2:	0a 51       	eor	r1,r5
800042f4:	00 00       	add	r0,r0
800042f6:	1d 90       	ld.ub	r0,lr[0x1]
800042f8:	00 00       	add	r0,r0
800042fa:	0a 8c       	andn	r12,r5
800042fc:	00 00       	add	r0,r0
800042fe:	1e 98       	mov	r8,pc
80004300:	00 00       	add	r0,r0
80004302:	0a 41       	or	r1,r5
80004304:	80 00       	ld.sh	r0,r0[0x0]
80004306:	db 9c       	*unknown*

80004308 <pdca_int_handler>:
    void (*phy_rx_exec)(void *)--callback function for receive SSC data 
Called By: interrupt
*/
__attribute__((__interrupt__))
static void pdca_int_handler(void)
{
80004308:	d4 01       	pushm	lr
    
	//intStartCount = Get_system_register(AVR32_COUNT);
	
	/*Toggle Index*/
    BufferIndex ^= 0x01;
8000430a:	49 88       	lddpc	r8,80004368 <pdca_int_handler+0x60>
8000430c:	11 89       	ld.ub	r9,r8[0x0]
8000430e:	ec 19 00 01 	eorl	r9,0x1
80004312:	b0 89       	st.b	r8[0x0],r9
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);
80004314:	11 89       	ld.ub	r9,r8[0x0]
80004316:	a5 69       	lsl	r9,0x4
80004318:	2f c9       	sub	r9,-4
8000431a:	49 5a       	lddpc	r10,8000436c <pdca_int_handler+0x64>
8000431c:	14 09       	add	r9,r10
	
	/*Toggle Index*/
    BufferIndex ^= 0x01;
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
8000431e:	fe 7a 00 40 	mov	r10,-65472
80004322:	95 39       	st.w	r10[0xc],r9
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80004324:	30 39       	mov	r9,3
80004326:	95 49       	st.w	r10[0x10],r9

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);
80004328:	11 8a       	ld.ub	r10,r8[0x0]
8000432a:	a5 6a       	lsl	r10,0x4
8000432c:	2f ca       	sub	r10,-4
8000432e:	49 18       	lddpc	r8,80004370 <pdca_int_handler+0x68>
80004330:	10 0a       	add	r10,r8
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
80004332:	fe 78 00 00 	mov	r8,-65536
80004336:	91 3a       	st.w	r8[0xc],r10
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80004338:	91 49       	st.w	r8[0x10],r9
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr;
8000433a:	70 b8       	ld.w	r8,r8[0x2c]
	
	/*receive SSC data*/
    if(phy_rx_exec != NULL)phy_rx_exec((void *)&RxBuffer[BufferIndex]);
8000433c:	48 e8       	lddpc	r8,80004374 <pdca_int_handler+0x6c>
8000433e:	70 08       	ld.w	r8,r8[0x0]
80004340:	58 08       	cp.w	r8,0
80004342:	c0 70       	breq	80004350 <pdca_int_handler+0x48>
80004344:	48 99       	lddpc	r9,80004368 <pdca_int_handler+0x60>
80004346:	13 89       	ld.ub	r9,r9[0x0]
80004348:	a5 69       	lsl	r9,0x4
8000434a:	48 ac       	lddpc	r12,80004370 <pdca_int_handler+0x68>
8000434c:	12 0c       	add	r12,r9
8000434e:	5d 18       	icall	r8

    /*transmit SSC data*/

	if(phy_tx_exec != NULL)phy_tx_exec((void *)&TxBuffer[BufferIndex]);//phy_tx_func, phy_rx_func
80004350:	48 a8       	lddpc	r8,80004378 <pdca_int_handler+0x70>
80004352:	70 08       	ld.w	r8,r8[0x0]
80004354:	58 08       	cp.w	r8,0
80004356:	c0 70       	breq	80004364 <pdca_int_handler+0x5c>
80004358:	48 49       	lddpc	r9,80004368 <pdca_int_handler+0x60>
8000435a:	13 89       	ld.ub	r9,r9[0x0]
8000435c:	a5 69       	lsl	r9,0x4
8000435e:	48 4c       	lddpc	r12,8000436c <pdca_int_handler+0x64>
80004360:	12 0c       	add	r12,r9
80004362:	5d 18       	icall	r8

	
	//intDuration = Get_system_register(AVR32_COUNT) - intStartCount;
	
	
}/*End of pdca_int_handler.*/
80004364:	d4 02       	popm	lr
80004366:	d6 03       	rete
80004368:	00 00       	add	r0,r0
8000436a:	50 b8       	stdsp	sp[0x2c],r8
8000436c:	00 00       	add	r0,r0
8000436e:	50 e0       	stdsp	sp[0x38],r0
80004370:	00 00       	add	r0,r0
80004372:	50 c0       	stdsp	sp[0x30],r0
80004374:	00 00       	add	r0,r0
80004376:	0a e0       	st.h	--r5,r0
80004378:	00 00       	add	r0,r0
8000437a:	0a e4       	st.h	--r5,r4

8000437c <local_start_SSC>:
void local_start_SSC(void)
{
    /*Assign GPIO to SSC.
    gpio_enable_module
    gpio_enable_module_pin*/
    AVR32_GPIO.port[1].pmr0c = 0x00000DC0;
8000437c:	fe 78 10 00 	mov	r8,-61440
80004380:	e0 69 0d c0 	mov	r9,3520
80004384:	f1 49 01 18 	st.w	r8[280],r9
    AVR32_GPIO.port[1].pmr1c = 0x00000DC0;
80004388:	f1 49 01 28 	st.w	r8[296],r9
    AVR32_GPIO.port[1].gperc = 0x00000DC0;
8000438c:	f1 49 01 08 	st.w	r8[264],r9

    /*Software reset SSC*/
    (&AVR32_SSC)->cr = AVR32_SSC_CR_SWRST_MASK;
80004390:	fe 78 34 00 	mov	r8,-52224
80004394:	e0 69 80 00 	mov	r9,32768
80004398:	91 09       	st.w	r8[0x0],r9
    (&AVR32_SSC)->cmr 
8000439a:	30 09       	mov	r9,0
8000439c:	91 19       	st.w	r8[0x4],r9
                     = AVR32_SSC_CMR_DIV_NOT_ACTIVE << AVR32_SSC_CMR_DIV_OFFSET;

    /*For Slave*/
    (&AVR32_SSC)->tcmr =
8000439e:	e0 69 04 21 	mov	r9,1057
800043a2:	ea 19 3f 20 	orh	r9,0x3f20
800043a6:	91 69       	st.w	r8[0x18],r9
	    | 32 << AVR32_SSC_TCMR_STTDLY_OFFSET
	    | 63 << AVR32_SSC_TCMR_PERIOD_OFFSET;


    /*For Slave*/
    (&AVR32_SSC)->tfmr = 31 << AVR32_SSC_TFMR_DATLEN_OFFSET 
800043a8:	e0 69 02 9f 	mov	r9,671
800043ac:	ea 19 01 00 	orh	r9,0x100
800043b0:	91 79       	st.w	r8[0x1c],r9
	    | 0 << AVR32_SSC_TFMR_FSDEN_OFFSET
	    | 1 << AVR32_SSC_TFMR_FSEDGE_OFFSET;

	/*For Slave*/

	(&AVR32_SSC)->rcmr = AVR32_SSC_RCMR_CKS_RK_PIN << AVR32_SSC_RCMR_CKS_OFFSET
800043b2:	e0 6a 04 02 	mov	r10,1026
800043b6:	ea 1a 3f 20 	orh	r10,0x3f20
800043ba:	91 4a       	st.w	r8[0x10],r10
	    | 0 << AVR32_SSC_RCMR_STOP_OFFSET
	    | 32 << AVR32_SSC_RCMR_STTDLY_OFFSET
	    | 63 << AVR32_SSC_RCMR_PERIOD_OFFSET;

	/*For Slave*/
	(&AVR32_SSC)->rfmr = 31 << AVR32_SSC_RFMR_DATLEN_OFFSET
800043bc:	91 59       	st.w	r8[0x14],r9
	    | 1 << AVR32_SSC_RFMR_MSBF_OFFSET
	    | 2 << AVR32_SSC_RFMR_DATNB_OFFSET
	    | 0 << AVR32_SSC_RFMR_FSLEN_OFFSET
	    | AVR32_SSC_RFMR_FSOS_INPUT_ONLY << AVR32_SSC_RFMR_FSOS_OFFSET
	    | 1 << AVR32_SSC_RFMR_FSEDGE_OFFSET;
}/*End of local_start_SSC.*/
800043be:	5e fc       	retal	r12

800043c0 <local_start_PDC>:
Function: local_start_PDC
Description: none
Called By: void ssc_init(void) -- ssc.c
*/
void local_start_PDC(void)
{
800043c0:	d4 01       	pushm	lr
    /*Toggle Index*/	
    BufferIndex = 1;
800043c2:	30 19       	mov	r9,1
800043c4:	49 78       	lddpc	r8,80004420 <local_start_PDC+0x60>
800043c6:	b0 89       	st.b	r8[0x0],r9
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
800043c8:	fe 78 00 00 	mov	r8,-65536
800043cc:	30 7b       	mov	r11,7
800043ce:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
800043d0:	70 b9       	ld.w	r9,r8[0x2c]
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
800043d2:	49 59       	lddpc	r9,80004424 <local_start_PDC+0x64>
800043d4:	f2 ca ff fc 	sub	r10,r9,-4
    BufferIndex = 1;
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
800043d8:	91 0a       	st.w	r8[0x0],r10
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
800043da:	30 3a       	mov	r10,3
800043dc:	91 2a       	st.w	r8[0x8],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
800043de:	30 1c       	mov	r12,1
800043e0:	91 1c       	st.w	r8[0x4],r12
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
800043e2:	2e c9       	sub	r9,-20
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
800043e4:	91 39       	st.w	r8[0xc],r9
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
800043e6:	91 4a       	st.w	r8[0x10],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mr = AVR32_PDCA_WORD;
800043e8:	30 2c       	mov	r12,2
800043ea:	91 6c       	st.w	r8[0x18],r12

	TxBuffer[0].xnl_channel.dword = XNL_IDLE;
800043ec:	48 f9       	lddpc	r9,80004428 <local_start_PDC+0x68>
800043ee:	e0 68 5a 5a 	mov	r8,23130
800043f2:	ea 18 ab cd 	orh	r8,0xabcd
800043f6:	93 18       	st.w	r9[0x4],r8
	TxBuffer[0].payload_channel.dword[0] = PAYLOADIDLE0;
800043f8:	93 28       	st.w	r9[0x8],r8
	TxBuffer[0].payload_channel.dword[1] = PAYLOADIDLE1;
800043fa:	30 0e       	mov	lr,0
800043fc:	93 3e       	st.w	r9[0xc],lr
	TxBuffer[1].xnl_channel.dword = XNL_IDLE;
800043fe:	93 58       	st.w	r9[0x14],r8
	TxBuffer[1].payload_channel.dword[0] = PAYLOADIDLE0;
80004400:	93 68       	st.w	r9[0x18],r8
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;
80004402:	93 7e       	st.w	r9[0x1c],lr

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
80004404:	fe 78 00 40 	mov	r8,-65472
80004408:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
8000440a:	70 be       	ld.w	lr,r8[0x2c]
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
8000440c:	f2 ce ff fc 	sub	lr,r9,-4
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
80004410:	91 0e       	st.w	r8[0x0],lr
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
80004412:	91 2a       	st.w	r8[0x8],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
80004414:	91 1b       	st.w	r8[0x4],r11
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
80004416:	2e c9       	sub	r9,-20
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
80004418:	91 39       	st.w	r8[0xc],r9
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
8000441a:	91 4a       	st.w	r8[0x10],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mr = AVR32_PDCA_WORD;
8000441c:	91 6c       	st.w	r8[0x18],r12
}/*End of local_start_PDC.*/
8000441e:	d8 02       	popm	pc
80004420:	00 00       	add	r0,r0
80004422:	50 b8       	stdsp	sp[0x2c],r8
80004424:	00 00       	add	r0,r0
80004426:	50 c0       	stdsp	sp[0x30],r0
80004428:	00 00       	add	r0,r0
8000442a:	50 e0       	stdsp	sp[0x38],r0

8000442c <register_rx_tx_func>:
Description: register the rx function(callback function)
Called By: phy_init -- physical.c
*/
void register_rx_tx_func(void (*rx_exec)(void *),  void ( *tx_exec)(void *))
{
	 phy_rx_exec = rx_exec;
8000442c:	48 38       	lddpc	r8,80004438 <register_rx_tx_func+0xc>
8000442e:	91 0c       	st.w	r8[0x0],r12
	 phy_tx_exec = tx_exec;//phy_tx_func, phy_rx_func
80004430:	48 38       	lddpc	r8,8000443c <register_rx_tx_func+0x10>
80004432:	91 0b       	st.w	r8[0x0],r11
	 
}/*End of register_tx_rx_func.*/
80004434:	5e fc       	retal	r12
80004436:	00 00       	add	r0,r0
80004438:	00 00       	add	r0,r0
8000443a:	0a e0       	st.h	--r5,r0
8000443c:	00 00       	add	r0,r0
8000443e:	0a e4       	st.h	--r5,r4

80004440 <ssc_init>:
    local_start_SSC -- ssc.c
    local_start_PDC -- ssc.c
Called By: phy_init -- physical.c
*/
void ssc_init(void)
{		
80004440:	d4 01       	pushm	lr
    /*Set up PB03 to watch FS.*/
    AVR32_GPIO.port[1].oderc = 0x00000002;
80004442:	fe 78 10 00 	mov	r8,-61440
80004446:	30 29       	mov	r9,2
80004448:	f1 49 01 48 	st.w	r8[328],r9
    AVR32_GPIO.port[1].gpers = 0x00000002;
8000444c:	f1 49 01 04 	st.w	r8[260],r9

    /*Waits for radio to start making FSYNC.*/
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
80004450:	10 99       	mov	r9,r8
80004452:	f2 f8 01 60 	ld.w	r8,r9[352]
80004456:	e2 18 00 02 	andl	r8,0x2,COH
8000445a:	cf c0       	breq	80004452 <ssc_init+0x12>
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
8000445c:	fe 79 10 00 	mov	r9,-61440
80004460:	f2 f8 01 60 	ld.w	r8,r9[352]
80004464:	e2 18 00 02 	andl	r8,0x2,COH
80004468:	cf c1       	brne	80004460 <ssc_init+0x20>
				
    INTC_register_interrupt (
8000446a:	30 3a       	mov	r10,3
8000446c:	36 0b       	mov	r11,96
8000446e:	48 bc       	lddpc	r12,80004498 <ssc_init+0x58>
80004470:	f0 1f 00 0b 	mcall	8000449c <ssc_init+0x5c>
        , AVR32_PDCA_IRQ_0
        , AVR32_INTC_INT3
    );
				
    /*config the SSC*/
    local_start_SSC();
80004474:	f0 1f 00 0b 	mcall	800044a0 <ssc_init+0x60>

    /*config the PDCA*/
    local_start_PDC();
80004478:	f0 1f 00 0b 	mcall	800044a4 <ssc_init+0x64>
		
    /*Start the SSC Physical Layer.*/

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
8000447c:	fe 79 00 00 	mov	r9,-65536
80004480:	30 18       	mov	r8,1
80004482:	93 58       	st.w	r9[0x14],r8
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80004484:	fe 7a 00 40 	mov	r10,-65472
80004488:	95 58       	st.w	r10[0x14],r8
    (&AVR32_SSC)->cr = AVR32_SSC_CR_RXEN_MASK | AVR32_SSC_CR_TXEN_MASK;
8000448a:	e0 6b 01 01 	mov	r11,257
8000448e:	fe 7a 34 00 	mov	r10,-52224
80004492:	95 0b       	st.w	r10[0x0],r11
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->ier = 
80004494:	93 88       	st.w	r9[0x20],r8
                                                            AVR32_PDCA_RCZ_MASK;
}/*End of ssc_init.*/
80004496:	d8 02       	popm	pc
80004498:	80 00       	ld.sh	r0,r0[0x0]
8000449a:	43 08       	lddsp	r8,sp[0xc0]
8000449c:	80 00       	ld.sh	r0,r0[0x0]
8000449e:	54 1c       	stdsp	sp[0x104],r12
800044a0:	80 00       	ld.sh	r0,r0[0x0]
800044a2:	43 7c       	lddsp	r12,sp[0xdc]
800044a4:	80 00       	ld.sh	r0,r0[0x0]
800044a6:	43 c0       	lddsp	r0,sp[0xf0]

800044a8 <xcmp_register_app_list>:
Calls: 
Called By: app_init -- app.c
*/
void xcmp_register_app_list(void * list)
{
	app_list = (app_exec_t *)list;
800044a8:	48 28       	lddpc	r8,800044b0 <xcmp_register_app_list+0x8>
800044aa:	91 0c       	st.w	r8[0x0],r12
}
800044ac:	5e fc       	retal	r12
800044ae:	00 00       	add	r0,r0
800044b0:	00 00       	add	r0,r0
800044b2:	51 00       	stdsp	sp[0x40],r0

800044b4 <xcmp_tx>:
Calls:   
	xnl_tx -- xnl.c
Called By: ...
*/
static void xcmp_tx( xcmp_fragment_t * xcmp, U8 payload_len)
{
800044b4:	eb cd 40 80 	pushm	r7,lr
800044b8:	fa cd 01 00 	sub	sp,sp,256
800044bc:	16 97       	mov	r7,r11
	Length :xnl length + checksum
	= checksum + xnl header + xcmp opcode + xcmp payload
	= 0x02 + 0x0C + 0x02 + xcmp payload
	= 0x10 + xcmp payload
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | ( 0x10 + payload_len);
800044be:	16 98       	mov	r8,r11
800044c0:	2f 08       	sub	r8,-16
800044c2:	af a8       	sbr	r8,0xe
800044c4:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE; 
800044c6:	3f f8       	mov	r8,-1
800044c8:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG;
800044ca:	30 b9       	mov	r9,11
800044cc:	ba 29       	st.h	sp[0x4],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;	
800044ce:	ba 38       	st.h	sp[0x6],r8
	xnl_frame.xnl_header.destination = DEFAULT_VALUE;
800044d0:	ba 48       	st.h	sp[0x8],r8
	xnl_frame.xnl_header.source = DEFAULT_VALUE;	
800044d2:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
800044d4:	ba 68       	st.h	sp[0xc],r8
	
	/*insert xcmp frame data*/
	memcpy(&xnl_frame.xnl_payload.xnl_content_data_msg, xcmp, payload_len + 2);
800044d6:	f6 ca ff fe 	sub	r10,r11,-2
800044da:	18 9b       	mov	r11,r12
800044dc:	fa cc ff f0 	sub	r12,sp,-16
800044e0:	f0 1f 00 05 	mcall	800044f4 <xcmp_tx+0x40>
	xnl_frame.xnl_header.payload_length = payload_len + 2;	
800044e4:	2f e7       	sub	r7,-2
800044e6:	ba 77       	st.h	sp[0xe],r7
	
	/* send xnl frame*/	
	xnl_tx(&xnl_frame);
800044e8:	1a 9c       	mov	r12,sp
800044ea:	f0 1f 00 04 	mcall	800044f8 <xcmp_tx+0x44>
}
800044ee:	2c 0d       	sub	sp,-256
800044f0:	e3 cd 80 80 	ldm	sp++,r7,pc
800044f4:	80 00       	ld.sh	r0,r0[0x0]
800044f6:	77 3a       	ld.w	r10,r11[0x4c]
800044f8:	80 00       	ld.sh	r0,r0[0x0]
800044fa:	49 b4       	lddpc	r4,80004564 <xcmp_audio_route_AMBE+0x3c>

800044fc <xcmp_enter_device_control_mode>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_enter_device_control_mode(void)
{
800044fc:	d4 01       	pushm	lr
800044fe:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DEVICE_CONTROL_MODE;
80004502:	e0 68 04 21 	mov	r8,1057
80004506:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceControlMode_req_t * ptr = (DeviceControlMode_req_t *)xcmp_farme.u8;
80004508:	fa c8 ff fc 	sub	r8,sp,-4
	
	ptr->Function = DCM_ENTER;
8000450c:	30 19       	mov	r9,1
8000450e:	b0 89       	st.b	r8[0x0],r9
	ptr->ControlTypeSize = 1;
80004510:	b0 99       	st.b	r8[0x1],r9
	ptr->ControlType = 0x03;// 0xEB;//user-input
80004512:	30 39       	mov	r9,3
80004514:	b0 a9       	st.b	r8[0x2],r9
	//ptr->ControlType = DCM_SPEAKER_CTRL;
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(DeviceControlMode_req_t));
80004516:	30 3b       	mov	r11,3
80004518:	fa cc ff fe 	sub	r12,sp,-2
8000451c:	f0 1f 00 02 	mcall	80004524 <xcmp_enter_device_control_mode+0x28>
}
80004520:	2c dd       	sub	sp,-204
80004522:	d8 02       	popm	pc
80004524:	80 00       	ld.sh	r0,r0[0x0]
80004526:	44 b4       	lddsp	r4,sp[0x12c]

80004528 <xcmp_audio_route_AMBE>:
	xcmp_tx( &xcmp_farme, sizeof(AudioRoutingControl_req_t) - (MAX_ROUTING_CTR - NumberofRoutings) * sizeof(RoutingData_t));
}


void xcmp_audio_route_AMBE(void)
{
80004528:	d4 01       	pushm	lr
8000452a:	fa cd 00 cc 	sub	sp,sp,204

	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | AUDIO_ROUTING_CONTROL;
8000452e:	e0 68 04 14 	mov	r8,1044
80004532:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	AudioRoutingControl_req_t * ptr = (AudioRoutingControl_req_t *)xcmp_farme.u8;
80004534:	fa c8 ff fc 	sub	r8,sp,-4
	
	ptr->Function = Routing_Func_Update_Source;
80004538:	30 19       	mov	r9,1
8000453a:	b0 89       	st.b	r8[0x0],r9
	
	
	unsigned short NumberofRoutings = 6;// 4;//2;
	ptr->NumberofRoutings[0] = (NumberofRoutings >> 8) & 0xFF;
8000453c:	30 09       	mov	r9,0
8000453e:	b0 99       	st.b	r8[0x1],r9
	ptr->NumberofRoutings[1] =  NumberofRoutings & 0xFF;
80004540:	30 69       	mov	r9,6
80004542:	b0 a9       	st.b	r8[0x2],r9
	
	//ptr->RoutingData[0].audioInput = IN_Microphone;//Post_AMBE_Encoder;//IN_Pre_Speaker_Audio_Data;//IN_Microphone;//IN_Option_Board;
	//ptr->RoutingData[0].audioOutput = OUT_Option_Board;//Post_AMBE_Encoder;//OUT_Microphone_Data;//测试
	//注意：经测试发现，这里的路径配置，需要特别注意先后顺序，否则会提示参数错误。
	ptr->RoutingData[0].audioInput = Post_AMBE_Encoder;//IN_Option_Board;
80004544:	30 fa       	mov	r10,15
80004546:	b0 ba       	st.b	r8[0x3],r10
	ptr->RoutingData[0].audioOutput = OUT_Option_Board;// OUT_Speaker;
80004548:	30 c9       	mov	r9,12
8000454a:	b0 c9       	st.b	r8[0x4],r9
	ptr->RoutingData[1].audioInput = IN_Option_Board;//IN_Option_Board;
8000454c:	b0 d9       	st.b	r8[0x5],r9
	ptr->RoutingData[1].audioOutput = Post_AMBE_Encoder;// OUT_Speaker;
8000454e:	b0 ea       	st.b	r8[0x6],r10
	
	ptr->RoutingData[2].audioInput = Pre_AMBE_Decoder;//IN_Option_Board;
80004550:	31 0a       	mov	r10,16
80004552:	b0 fa       	st.b	r8[0x7],r10
	ptr->RoutingData[2].audioOutput = OUT_Option_Board;// OUT_Speaker;
80004554:	f1 69 00 08 	st.b	r8[8],r9
	ptr->RoutingData[3].audioInput = IN_Option_Board;//IN_Option_Board;
80004558:	f1 69 00 09 	st.b	r8[9],r9
	ptr->RoutingData[3].audioOutput = Pre_AMBE_Decoder;// OUT_Speaker;
8000455c:	f1 6a 00 0a 	st.b	r8[10],r10
	
	ptr->RoutingData[4].audioInput = Tx_Voice_Header;//IN_Option_Board;
80004560:	31 1a       	mov	r10,17
80004562:	f1 6a 00 0b 	st.b	r8[11],r10
	ptr->RoutingData[4].audioOutput = OUT_Option_Board;// OUT_Speaker;
80004566:	f1 69 00 0c 	st.b	r8[12],r9
	//ptr->RoutingData[3].audioInput = IN_Option_Board;//IN_Option_Board;
	//ptr->RoutingData[3].audioOutput = Tx_Voice_Header;// OUT_Speaker;
	
	ptr->RoutingData[5].audioInput = Tx_Voice_Terminator;//IN_Option_Board;
8000456a:	31 3a       	mov	r10,19
8000456c:	f1 6a 00 0d 	st.b	r8[13],r10
	ptr->RoutingData[5].audioOutput = OUT_Option_Board;// OUT_Speaker;
80004570:	f1 69 00 0e 	st.b	r8[14],r9
	
	//ptr->RoutingData[1].audioInput = IN_Option_Board;
	//ptr->RoutingData[1].audioOutput = OUT_Microphone_Data;//测试OUT_Speaker;//
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(AudioRoutingControl_req_t) - (MAX_ROUTING_CTR - NumberofRoutings) * sizeof(RoutingData_t));
80004574:	30 fb       	mov	r11,15
80004576:	fa cc ff fe 	sub	r12,sp,-2
8000457a:	f0 1f 00 03 	mcall	80004584 <xcmp_audio_route_AMBE+0x5c>

	
}
8000457e:	2c dd       	sub	sp,-204
80004580:	d8 02       	popm	pc
80004582:	00 00       	add	r0,r0
80004584:	80 00       	ld.sh	r0,r0[0x0]
80004586:	44 b4       	lddsp	r4,sp[0x12c]

80004588 <xcmp_enter_enhanced_OB_mode>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_enter_enhanced_OB_mode(void)
{
80004588:	d4 01       	pushm	lr
8000458a:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | EN_OB_CONTROL;
8000458e:	e0 68 04 65 	mov	r8,1125
80004592:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	En_OB_Control_req_t * ptr = (En_OB_Control_req_t *)xcmp_farme.u8;
	
	ptr->Function = EN_OB_Enter;
80004594:	fa cc ff fe 	sub	r12,sp,-2
80004598:	30 18       	mov	r8,1
8000459a:	b8 a8       	st.b	r12[0x2],r8
		
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(En_OB_Control_req_t));
8000459c:	30 1b       	mov	r11,1
8000459e:	f0 1f 00 03 	mcall	800045a8 <xcmp_enter_enhanced_OB_mode+0x20>
}
800045a2:	2c dd       	sub	sp,-204
800045a4:	d8 02       	popm	pc
800045a6:	00 00       	add	r0,r0
800045a8:	80 00       	ld.sh	r0,r0[0x0]
800045aa:	44 b4       	lddsp	r4,sp[0x12c]

800045ac <xcmp_DeviceInitializationStatus_request>:
Description: send device initialization status request
Calls: xcmp_tx
Called By:...
*/
void xcmp_DeviceInitializationStatus_request(void)
{
800045ac:	d4 01       	pushm	lr
800045ae:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
		
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_BRDCAST | DEVICE_INITIALIZATION_STATUS;
800045b2:	fe 78 b4 00 	mov	r8,-19456
800045b6:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceInitializationStatus_brdcst_t * ptr 
						 = (DeviceInitializationStatus_brdcst_t *)xcmp_farme.u8;
800045b8:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*xcmp version 8.1.0.5*///版本号未正确填写，纠正
	ptr->XCMPVersion[0] = 0x08;
800045bc:	30 89       	mov	r9,8
800045be:	b0 89       	st.b	r8[0x0],r9
	ptr->XCMPVersion[1] = 0x01;
800045c0:	30 19       	mov	r9,1
800045c2:	b0 99       	st.b	r8[0x1],r9
	ptr->XCMPVersion[2] = 0x00;
800045c4:	30 09       	mov	r9,0
800045c6:	b0 a9       	st.b	r8[0x2],r9
	ptr->XCMPVersion[3] = 0x05;
800045c8:	30 5a       	mov	r10,5
800045ca:	b0 ba       	st.b	r8[0x3],r10
	/*
	0x00:
	This is the message that the device sends at power up or after a reset. It 
	will give the initial status and capabilities for the device.
	*/
	ptr->DeviceInitType = 0x00;
800045cc:	b0 c9       	st.b	r8[0x4],r9
	types of devices may provide a set of services to the radio system, but do 
	not have the ability to be the master.
	
	0x07:OptionBoard,3rd party Option Board-based application.
	*/
	ptr->DeviceStatusInfo.DeviceType = 0x07;
800045ce:	30 7a       	mov	r10,7
800045d0:	b0 da       	st.b	r8[0x5],r10
	
	/*Power Up Success, Device has powered up with no errors*/
	ptr->DeviceStatusInfo.DeviceStatus[0] = 0x00;
800045d2:	b0 e9       	st.b	r8[0x6],r9
	ptr->DeviceStatusInfo.DeviceStatus[1] = 0x00;
800045d4:	b0 f9       	st.b	r8[0x7],r9
	
	/*
	This number is the size of the Device Descriptor data structure with a 
	maximum size not exceeding 255 bytes.
	*/
	ptr->DeviceStatusInfo.DeviceDescriptorSize = 0x00;
800045d6:	f1 69 00 08 	st.b	r8[8],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme
800045da:	30 9b       	mov	r11,9
800045dc:	fa cc ff fe 	sub	r12,sp,-2
800045e0:	f0 1f 00 02 	mcall	800045e8 <xcmp_DeviceInitializationStatus_request+0x3c>
		, sizeof(DeviceInitializationStatus_brdcst_t) - MAX_DEVICE_DESC_SIZE);
}
800045e4:	2c dd       	sub	sp,-204
800045e6:	d8 02       	popm	pc
800045e8:	80 00       	ld.sh	r0,r0[0x0]
800045ea:	44 b4       	lddsp	r4,sp[0x12c]

800045ec <xcmp_opcode_not_supported>:
Description: register the app list
Calls: xcmp_tx
Called By:...
*/
void xcmp_opcode_not_supported( void )
{
800045ec:	d4 01       	pushm	lr
800045ee:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REPLY;
800045f2:	fe 78 80 00 	mov	r8,-32768
800045f6:	ba 18       	st.h	sp[0x2],r8
	
	/*The radio does not support this opcode.*/
	xcmp_farme.u8[0] = xcmp_Res_Opcode_Not_Supported;
800045f8:	30 38       	mov	r8,3
800045fa:	ba c8       	st.b	sp[0x4],r8
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, 1);
800045fc:	30 1b       	mov	r11,1
800045fe:	fa cc ff fe 	sub	r12,sp,-2
80004602:	f0 1f 00 03 	mcall	8000460c <xcmp_opcode_not_supported+0x20>
}
80004606:	2c dd       	sub	sp,-204
80004608:	d8 02       	popm	pc
8000460a:	00 00       	add	r0,r0
8000460c:	80 00       	ld.sh	r0,r0[0x0]
8000460e:	44 b4       	lddsp	r4,sp[0x12c]

80004610 <xcmp_exec_func>:
Description: Perform XCMP corresponding functions
Calls:   
Called By: xcmp_rx_process--task
*/
static void xcmp_exec_func(app_exec_t * exec, xcmp_fragment_t * xcmp)
{
80004610:	d4 01       	pushm	lr
	/*The message types*/
	switch(xcmp->xcmp_opcode & 0xF000)
80004612:	96 88       	ld.uh	r8,r11[0x0]
80004614:	e2 18 f0 00 	andl	r8,0xf000,COH
80004618:	e0 48 80 00 	cp.w	r8,32768
8000461c:	c0 f0       	breq	8000463a <xcmp_exec_func+0x2a>
8000461e:	e0 48 b0 00 	cp.w	r8,45056
80004622:	c1 20       	breq	80004646 <xcmp_exec_func+0x36>
80004624:	58 08       	cp.w	r8,0
80004626:	c1 51       	brne	80004650 <xcmp_exec_func+0x40>
	{
		case XCMP_REQUEST:
			if(NULL != exec->xcmp_rx_req)
80004628:	78 08       	ld.w	r8,r12[0x0]
8000462a:	58 08       	cp.w	r8,0
8000462c:	c0 40       	breq	80004634 <xcmp_exec_func+0x24>
			{
				exec->xcmp_rx_req(xcmp);
8000462e:	16 9c       	mov	r12,r11
80004630:	5d 18       	icall	r8
80004632:	d8 02       	popm	pc
			}
			else 
			{
				/*No function to register the request message*/
				/*send not supported opcode to raido */
				xcmp_opcode_not_supported();
80004634:	f0 1f 00 08 	mcall	80004654 <xcmp_exec_func+0x44>
80004638:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_REPLY:		
			if(NULL != exec->xcmp_rx_reply)
8000463a:	78 18       	ld.w	r8,r12[0x4]
8000463c:	58 08       	cp.w	r8,0
8000463e:	c0 90       	breq	80004650 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_reply(xcmp);
80004640:	16 9c       	mov	r12,r11
80004642:	5d 18       	icall	r8
80004644:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_BRDCAST:	
			if(NULL != exec->xcmp_rx_brdcst)
80004646:	78 28       	ld.w	r8,r12[0x8]
80004648:	58 08       	cp.w	r8,0
8000464a:	c0 30       	breq	80004650 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_brdcst(xcmp);
8000464c:	16 9c       	mov	r12,r11
8000464e:	5d 18       	icall	r8
80004650:	d8 02       	popm	pc
80004652:	00 00       	add	r0,r0
80004654:	80 00       	ld.sh	r0,r0[0x0]
80004656:	45 ec       	lddsp	r12,sp[0x178]

80004658 <xcmp_IdleTestTone>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_IdleTestTone(void)
{
80004658:	d4 01       	pushm	lr
8000465a:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | TONE_CONTROL;
8000465e:	e0 68 04 09 	mov	r8,1033
80004662:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	ToneControl_req_t * ptr = (ToneControl_req_t *)xcmp_farme.u8;
80004664:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*Starts the specific tone*/	
	ptr->Function = Tone_Start;
80004668:	30 19       	mov	r9,1
8000466a:	b0 89       	st.b	r8[0x0],r9
	
	/*This tone shall be sounded when radio landed on a priority channel*/
	ptr->ToneIdentifier[0] = (Priority_Beep >> 8) & 0xFF;
8000466c:	30 09       	mov	r9,0
8000466e:	b0 99       	st.b	r8[0x1],r9
	ptr->ToneIdentifier[1] = Priority_Beep & 0xFF;
80004670:	30 ca       	mov	r10,12
80004672:	b0 aa       	st.b	r8[0x2],r10
	
	/*
	The alert tone is played according to any rules for alert tones, given the 
	current volume setting. Settings for this field are 8 to 255 (0x08 ?0xFF).
	*/
	ptr->ToneVolumeControl = Current_Volume;
80004674:	b0 b9       	st.b	r8[0x3],r9
	
	/*clear reserved*/
	memset(ptr->Reserved, 0, 8);
80004676:	fb 69 00 08 	st.b	sp[8],r9
8000467a:	fa c8 ff f7 	sub	r8,sp,-9
8000467e:	b0 89       	st.b	r8[0x0],r9
80004680:	fa c8 ff f6 	sub	r8,sp,-10
80004684:	b0 89       	st.b	r8[0x0],r9
80004686:	fa c8 ff f5 	sub	r8,sp,-11
8000468a:	b0 89       	st.b	r8[0x0],r9
8000468c:	fa c8 ff f4 	sub	r8,sp,-12
80004690:	b0 89       	st.b	r8[0x0],r9
80004692:	fa c8 ff f3 	sub	r8,sp,-13
80004696:	b0 89       	st.b	r8[0x0],r9
80004698:	fa c8 ff f2 	sub	r8,sp,-14
8000469c:	b0 89       	st.b	r8[0x0],r9
8000469e:	fa c8 ff f1 	sub	r8,sp,-15
800046a2:	b0 89       	st.b	r8[0x0],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(ToneControl_req_t));
800046a4:	30 cb       	mov	r11,12
800046a6:	fa cc ff fe 	sub	r12,sp,-2
800046aa:	f0 1f 00 03 	mcall	800046b4 <xcmp_IdleTestTone+0x5c>
}
800046ae:	2c dd       	sub	sp,-204
800046b0:	d8 02       	popm	pc
800046b2:	00 00       	add	r0,r0
800046b4:	80 00       	ld.sh	r0,r0[0x0]
800046b6:	44 b4       	lddsp	r4,sp[0x12c]

800046b8 <xcmp_init>:
	xQueueCreate -- freertos
	xTaskCreate -- freertos
Called By: main -- main.c
*/
void xcmp_init(void)
{
800046b8:	d4 01       	pushm	lr
	/*register the xcmp function(callback function)*/
	xnl_register_xcmp_func( xcmp_rx );
800046ba:	48 dc       	lddpc	r12,800046ec <xcmp_init+0x34>
800046bc:	f0 1f 00 0d 	mcall	800046f0 <xcmp_init+0x38>
	
	/*initialize the queue*/
	//xcmp_frame_rx = xQueueCreate(10, sizeof(xcmp_fragment_t *));
	
	xcmp_frame_rx = xQueueCreate(20, sizeof(xcmp_fragment_t *));
800046c0:	30 4b       	mov	r11,4
800046c2:	31 4c       	mov	r12,20
800046c4:	f0 1f 00 0c 	mcall	800046f4 <xcmp_init+0x3c>
800046c8:	48 c8       	lddpc	r8,800046f8 <xcmp_init+0x40>
800046ca:	91 0c       	st.w	r8[0x0],r12
	/*create task*/	
	/*this task is used to execute xcmp message*/
	xTaskCreate(
800046cc:	30 09       	mov	r9,0
800046ce:	1a d9       	st.w	--sp,r9
800046d0:	1a d9       	st.w	--sp,r9
800046d2:	1a d9       	st.w	--sp,r9
800046d4:	30 38       	mov	r8,3
800046d6:	e0 6a 01 80 	mov	r10,384
800046da:	48 9b       	lddpc	r11,800046fc <xcmp_init+0x44>
800046dc:	48 9c       	lddpc	r12,80004700 <xcmp_init+0x48>
800046de:	f0 1f 00 0a 	mcall	80004704 <xcmp_init+0x4c>
	,  tskXCMP_PRIORITY
	,  NULL
	);
	
	/*initialize the xnl*/
	xnl_init();
800046e2:	f0 1f 00 0a 	mcall	80004708 <xcmp_init+0x50>
800046e6:	2f dd       	sub	sp,-12
	
}
800046e8:	d8 02       	popm	pc
800046ea:	00 00       	add	r0,r0
800046ec:	80 00       	ld.sh	r0,r0[0x0]
800046ee:	48 08       	lddpc	r8,800046ec <xcmp_init+0x34>
800046f0:	80 00       	ld.sh	r0,r0[0x0]
800046f2:	48 54       	lddpc	r4,80004704 <xcmp_init+0x4c>
800046f4:	80 00       	ld.sh	r0,r0[0x0]
800046f6:	62 e8       	ld.w	r8,r1[0x38]
800046f8:	00 00       	add	r0,r0
800046fa:	0a f4       	st.b	--r5,r4
800046fc:	80 00       	ld.sh	r0,r0[0x0]
800046fe:	db c8       	*unknown*
80004700:	80 00       	ld.sh	r0,r0[0x0]
80004702:	47 0c       	lddsp	r12,sp[0x1c0]
80004704:	80 00       	ld.sh	r0,r0[0x0]
80004706:	69 bc       	ld.w	r12,r4[0x6c]
80004708:	80 00       	ld.sh	r0,r0[0x0]
8000470a:	4a 98       	lddpc	r8,800047ac <xcmp_rx_process+0xa0>

8000470c <xcmp_rx_process>:
Calls: xQueueReceive -- freerots
	xcmp_exec_func
Called By: task
*/
static void xcmp_rx_process(void * pvParameters)
{
8000470c:	d4 31       	pushm	r0-r7,lr
8000470e:	20 1d       	sub	sp,4
	xcmp_fragment_t xcmp;
	xcmp_fragment_t * ptr;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
80004710:	4b 16       	lddpc	r6,800047d4 <xcmp_rx_process+0xc8>
80004712:	30 05       	mov	r5,0
80004714:	31 44       	mov	r4,20
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
80004716:	4b 13       	lddpc	r3,800047d8 <xcmp_rx_process+0xcc>
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
					break;
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
80004718:	4b 12       	lddpc	r2,800047dc <xcmp_rx_process+0xd0>
						, ptr);
					break;
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
8000471a:	4b 21       	lddpc	r1,800047e0 <xcmp_rx_process+0xd4>
					break;
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
8000471c:	4b 20       	lddpc	r0,800047e4 <xcmp_rx_process+0xd8>
	xcmp_fragment_t xcmp;
	xcmp_fragment_t * ptr;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
8000471e:	6c 0c       	ld.w	r12,r6[0x0]
80004720:	0a 99       	mov	r9,r5
80004722:	08 9a       	mov	r10,r4
80004724:	1a 9b       	mov	r11,sp
80004726:	f0 1f 00 31 	mcall	800047e8 <xcmp_rx_process+0xdc>
8000472a:	58 1c       	cp.w	r12,1
8000472c:	cf 91       	brne	8000471e <xcmp_rx_process+0x12>
		{									
			if(NULL == ptr)
8000472e:	40 0b       	lddsp	r11,sp[0x0]
80004730:	58 0b       	cp.w	r11,0
80004732:	cf 60       	breq	8000471e <xcmp_rx_process+0x12>
				continue;
			}
			
			//log("\n\r R_xcmp : %4x \n\r",ptr->xcmp_opcode);//log:R_xcmp指令	
						
			switch(ptr->xcmp_opcode & 0x0FFF)
80004734:	96 0a       	ld.sh	r10,r11[0x0]
80004736:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
8000473a:	f1 d9 c0 0c 	bfextu	r8,r9,0x0,0xc
8000473e:	59 c8       	cp.w	r8,28
80004740:	c1 e0       	breq	8000477c <xcmp_rx_process+0x70>
80004742:	e0 89 00 07 	brgt	80004750 <xcmp_rx_process+0x44>
80004746:	58 e8       	cp.w	r8,14
80004748:	c0 e0       	breq	80004764 <xcmp_rx_process+0x58>
8000474a:	58 f8       	cp.w	r8,15
8000474c:	c2 41       	brne	80004794 <xcmp_rx_process+0x88>
8000474e:	c0 f8       	rjmp	8000476c <xcmp_rx_process+0x60>
80004750:	e0 48 01 09 	cp.w	r8,265
80004754:	c1 80       	breq	80004784 <xcmp_rx_process+0x78>
80004756:	e0 48 01 0a 	cp.w	r8,266
8000475a:	c1 90       	breq	8000478c <xcmp_rx_process+0x80>
8000475c:	e0 48 00 2c 	cp.w	r8,44
80004760:	c1 a1       	brne	80004794 <xcmp_rx_process+0x88>
80004762:	c0 98       	rjmp	80004774 <xcmp_rx_process+0x68>
			{
				case RADIO_STATUS:				
					xcmp_exec_func(&radio_status, ptr);
80004764:	4a 2c       	lddpc	r12,800047ec <xcmp_rx_process+0xe0>
80004766:	f0 1f 00 23 	mcall	800047f0 <xcmp_rx_process+0xe4>
					break;
8000476a:	c2 f8       	rjmp	800047c8 <xcmp_rx_process+0xbc>
					
				case VERSION_INFORMATION:
					xcmp_exec_func(&version_information, ptr);
8000476c:	4a 2c       	lddpc	r12,800047f4 <xcmp_rx_process+0xe8>
8000476e:	f0 1f 00 21 	mcall	800047f0 <xcmp_rx_process+0xe4>
					break;
80004772:	c2 b8       	rjmp	800047c8 <xcmp_rx_process+0xbc>
					
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
80004774:	4a 1c       	lddpc	r12,800047f8 <xcmp_rx_process+0xec>
80004776:	f0 1f 00 1f 	mcall	800047f0 <xcmp_rx_process+0xe4>
					break;
8000477a:	c2 78       	rjmp	800047c8 <xcmp_rx_process+0xbc>
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
8000477c:	04 9c       	mov	r12,r2
8000477e:	f0 1f 00 1d 	mcall	800047f0 <xcmp_rx_process+0xe4>
						, ptr);
					break;
80004782:	c2 38       	rjmp	800047c8 <xcmp_rx_process+0xbc>
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
80004784:	02 9c       	mov	r12,r1
80004786:	f0 1f 00 1b 	mcall	800047f0 <xcmp_rx_process+0xe4>
					break;
8000478a:	c1 f8       	rjmp	800047c8 <xcmp_rx_process+0xbc>
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
8000478c:	00 9c       	mov	r12,r0
8000478e:	f0 1f 00 19 	mcall	800047f0 <xcmp_rx_process+0xe4>
					break;
80004792:	c1 b8       	rjmp	800047c8 <xcmp_rx_process+0xbc>
					
				default:
				
					/*the xcmp message not in order list*/
					/*over the length of the list*/
					if((0x0400 != (ptr->xcmp_opcode & 0x0400)) 
80004794:	12 98       	mov	r8,r9
80004796:	e2 18 04 00 	andl	r8,0x400,COH
8000479a:	c0 70       	breq	800047a8 <xcmp_rx_process+0x9c>
8000479c:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
800047a0:	e0 48 00 68 	cp.w	r8,104
800047a4:	e0 8a 00 08 	brle	800047b4 <xcmp_rx_process+0xa8>
						|| (MAX_APP_FUNC <= (ptr->xcmp_opcode & 0x00FF))
					)
					{
						/*xcmp request*/
						if( XCMP_REQUEST == (ptr->xcmp_opcode & 0xF000))
800047a8:	e2 19 f0 00 	andl	r9,0xf000,COH
800047ac:	c0 e1       	brne	800047c8 <xcmp_rx_process+0xbc>
						{
							/*send not supported opcode to raido */
							xcmp_opcode_not_supported();
800047ae:	f0 1f 00 14 	mcall	800047fc <xcmp_rx_process+0xf0>
800047b2:	c0 b8       	rjmp	800047c8 <xcmp_rx_process+0xbc>
						}
					}
					else
					{					
						xcmp_exec_func( &app_list[ptr->xcmp_opcode & 0x00FF]
800047b4:	f9 da c0 08 	bfextu	r12,r10,0x0,0x8
800047b8:	f8 0c 00 1c 	add	r12,r12,r12<<0x1
800047bc:	49 19       	lddpc	r9,80004800 <xcmp_rx_process+0xf4>
800047be:	72 08       	ld.w	r8,r9[0x0]
800047c0:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800047c4:	f0 1f 00 0b 	mcall	800047f0 <xcmp_rx_process+0xe4>
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
800047c8:	66 0c       	ld.w	r12,r3[0x0]
800047ca:	40 0b       	lddsp	r11,sp[0x0]
800047cc:	f0 1f 00 0e 	mcall	80004804 <xcmp_rx_process+0xf8>
800047d0:	ca 7b       	rjmp	8000471e <xcmp_rx_process+0x12>
800047d2:	00 00       	add	r0,r0
800047d4:	00 00       	add	r0,r0
800047d6:	0a f4       	st.b	--r5,r4
800047d8:	00 00       	add	r0,r0
800047da:	0a 9c       	mov	r12,r5
800047dc:	00 00       	add	r0,r0
800047de:	0b 04       	ld.w	r4,r5++
800047e0:	00 00       	add	r0,r0
800047e2:	0a f8       	st.b	--r5,r8
800047e4:	00 00       	add	r0,r0
800047e6:	0b 10       	ld.sh	r0,r5++
800047e8:	80 00       	ld.sh	r0,r0[0x0]
800047ea:	5f dc       	srvc	r12
800047ec:	00 00       	add	r0,r0
800047ee:	0b 28       	ld.uh	r8,r5++
800047f0:	80 00       	ld.sh	r0,r0[0x0]
800047f2:	46 10       	lddsp	r0,sp[0x184]
800047f4:	00 00       	add	r0,r0
800047f6:	0a e8       	st.h	--r5,r8
800047f8:	00 00       	add	r0,r0
800047fa:	0b 1c       	ld.sh	r12,r5++
800047fc:	80 00       	ld.sh	r0,r0[0x0]
800047fe:	45 ec       	lddsp	r12,sp[0x178]
80004800:	00 00       	add	r0,r0
80004802:	51 00       	stdsp	sp[0x40],r0
80004804:	80 00       	ld.sh	r0,r0[0x0]
80004806:	30 00       	mov	r0,0

80004808 <xcmp_rx>:
Calls:   
	xQueueSend -- xnl.c
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
80004808:	eb cd 40 90 	pushm	r4,r7,lr
8000480c:	20 1d       	sub	sp,4
8000480e:	fa c4 ff f0 	sub	r4,sp,-16
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
80004812:	48 c8       	lddpc	r8,80004840 <xcmp_rx+0x38>
80004814:	70 0c       	ld.w	r12,r8[0x0]
80004816:	f0 1f 00 0c 	mcall	80004844 <xcmp_rx+0x3c>
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
8000481a:	c1 00       	breq	8000483a <xcmp_rx+0x32>
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
8000481c:	fa c7 ff fc 	sub	r7,sp,-4
80004820:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
	{
		memcpy(xcmp_ptr, &xcmp, sizeof(xcmp_fragment_t));				
80004822:	e0 6a 00 ca 	mov	r10,202
80004826:	08 9b       	mov	r11,r4
80004828:	f0 1f 00 08 	mcall	80004848 <xcmp_rx+0x40>
		xQueueSend(xcmp_frame_rx, &xcmp_ptr, 0);	
8000482c:	48 88       	lddpc	r8,8000484c <xcmp_rx+0x44>
8000482e:	70 0c       	ld.w	r12,r8[0x0]
80004830:	30 09       	mov	r9,0
80004832:	12 9a       	mov	r10,r9
80004834:	1a 9b       	mov	r11,sp
80004836:	f0 1f 00 07 	mcall	80004850 <xcmp_rx+0x48>
	}	
}
8000483a:	2f fd       	sub	sp,-4
8000483c:	e3 cd 80 90 	ldm	sp++,r4,r7,pc
80004840:	00 00       	add	r0,r0
80004842:	0a 9c       	mov	r12,r5
80004844:	80 00       	ld.sh	r0,r0[0x0]
80004846:	35 6c       	mov	r12,86
80004848:	80 00       	ld.sh	r0,r0[0x0]
8000484a:	77 3a       	ld.w	r10,r11[0x4c]
8000484c:	00 00       	add	r0,r0
8000484e:	0a f4       	st.b	--r5,r4
80004850:	80 00       	ld.sh	r0,r0[0x0]
80004852:	61 e8       	ld.w	r8,r0[0x78]

80004854 <xnl_register_xcmp_func>:
Function: xnl_register_xcmp_func
Description: register the xcmp function(callback function)
*/
void xnl_register_xcmp_func( void ( *func)(xnl_content_data_msg_t))
{
	 xcmp_exec = func;
80004854:	48 28       	lddpc	r8,8000485c <xnl_register_xcmp_func+0x8>
80004856:	91 0c       	st.w	r8[0x0],r12
}
80004858:	5e fc       	retal	r12
8000485a:	00 00       	add	r0,r0
8000485c:	00 00       	add	r0,r0
8000485e:	0b 54       	ld.sh	r4,--r5

80004860 <xnl_get_msg_ack_func>:
Description: process while receive msg ack.
Calls:xSemaphoreGive--freertos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
80004860:	d4 01       	pushm	lr
	
	DestinationAddress = xnl->xnl_header.destination;
	/*No timeout*/		
	 //One relationship is controlled by a state machine, only the current MSG received the ACK, 
	//then the program will clear the current MSG sending address and out of standby and will jump to the sending state.
	if (DestinationAddress == xnl_information.device_address )
80004862:	48 88       	lddpc	r8,80004880 <xnl_get_msg_ack_func+0x20>
80004864:	90 28       	ld.sh	r8,r8[0x4]
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
	U16 DestinationAddress;
	U16 TransactionID;
	
	DestinationAddress = xnl->xnl_header.destination;
80004866:	98 49       	ld.sh	r9,r12[0x8]
80004868:	f0 09 19 00 	cp.h	r9,r8
8000486c:	c0 81       	brne	8000487c <xnl_get_msg_ack_func+0x1c>
	if (DestinationAddress == xnl_information.device_address )
	{
		//The ack is for me.
		
		TransactionID = xnl->xnl_header.transaction_id;
		xSemaphoreGive(xnl_timeout_semphr);	
8000486e:	48 68       	lddpc	r8,80004884 <xnl_get_msg_ack_func+0x24>
80004870:	70 0c       	ld.w	r12,r8[0x0]
80004872:	30 09       	mov	r9,0
80004874:	12 9a       	mov	r10,r9
80004876:	12 9b       	mov	r11,r9
80004878:	f0 1f 00 04 	mcall	80004888 <xnl_get_msg_ack_func+0x28>
8000487c:	d8 02       	popm	pc
8000487e:	00 00       	add	r0,r0
80004880:	00 00       	add	r0,r0
80004882:	0b 3a       	ld.ub	r10,r5++
80004884:	00 00       	add	r0,r0
80004886:	0b 34       	ld.ub	r4,r5++
80004888:	80 00       	ld.sh	r0,r0[0x0]
8000488a:	61 e8       	ld.w	r8,r0[0x78]

8000488c <xnl_tx_process>:
	xSemaphoreTake--freertos 
	phy_tx -- physical.c
Called By: task
*/
static void xnl_tx_process(void * pvParameters)
{
8000488c:	d4 31       	pushm	r0-r7,lr
	static  xnl_fragment_t * ptr;//是否可以修缮为静态变量？请关注
	
	
	for(;;)
	{		
		switch(xnl_tx_state)
8000488e:	4a 86       	lddpc	r6,8000492c <xnl_tx_process+0xa0>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
80004890:	4a 82       	lddpc	r2,80004930 <xnl_tx_process+0xa4>
80004892:	4a 94       	lddpc	r4,80004934 <xnl_tx_process+0xa8>
80004894:	30 07       	mov	r7,0
80004896:	3f f1       	mov	r1,-1
					if(NULL == ptr)
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
80004898:	30 00       	mov	r0,0
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;
8000489a:	4a 85       	lddpc	r5,80004938 <xnl_tx_process+0xac>
					
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
8000489c:	4a 83       	lddpc	r3,8000493c <xnl_tx_process+0xb0>
	static  xnl_fragment_t * ptr;//是否可以修缮为静态变量？请关注
	
	
	for(;;)
	{		
		switch(xnl_tx_state)
8000489e:	6c 08       	ld.w	r8,r6[0x0]
800048a0:	58 08       	cp.w	r8,0
800048a2:	c0 40       	breq	800048aa <xnl_tx_process+0x1e>
800048a4:	58 18       	cp.w	r8,1
800048a6:	cf d1       	brne	800048a0 <xnl_tx_process+0x14>
800048a8:	c2 08       	rjmp	800048e8 <xnl_tx_process+0x5c>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
800048aa:	64 0c       	ld.w	r12,r2[0x0]
800048ac:	0e 99       	mov	r9,r7
800048ae:	02 9a       	mov	r10,r1
800048b0:	08 9b       	mov	r11,r4
800048b2:	f0 1f 00 24 	mcall	80004940 <xnl_tx_process+0xb4>
800048b6:	58 1c       	cp.w	r12,1
800048b8:	cf 31       	brne	8000489e <xnl_tx_process+0x12>
					, portMAX_DELAY ))
				{				
					if(NULL == ptr)
800048ba:	68 0c       	ld.w	r12,r4[0x0]
800048bc:	58 0c       	cp.w	r12,0
800048be:	cf 00       	breq	8000489e <xnl_tx_process+0x12>
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
800048c0:	98 28       	ld.sh	r8,r12[0x4]
800048c2:	e0 08 19 00 	cp.h	r8,r0
800048c6:	c0 41       	brne	800048ce <xnl_tx_process+0x42>
					{
						/*invalid XNL opcode*/
						vPortFree(ptr);
800048c8:	f0 1f 00 1f 	mcall	80004944 <xnl_tx_process+0xb8>
						break;
800048cc:	ce 9b       	rjmp	8000489e <xnl_tx_process+0x12>
					}
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
800048ce:	f0 1f 00 1f 	mcall	80004948 <xnl_tx_process+0xbc>
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;
800048d2:	30 18       	mov	r8,1
800048d4:	8b 08       	st.w	r5[0x0],r8
					
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
800048d6:	66 0c       	ld.w	r12,r3[0x0]
800048d8:	0e 99       	mov	r9,r7
800048da:	0e 9a       	mov	r10,r7
800048dc:	0e 9b       	mov	r11,r7
800048de:	f0 1f 00 19 	mcall	80004940 <xnl_tx_process+0xb4>
					xnl_tx_state = WAITING_FOR_REPLY;
800048e2:	30 18       	mov	r8,1
800048e4:	8d 08       	st.w	r6[0x0],r8
800048e6:	cd cb       	rjmp	8000489e <xnl_tx_process+0x12>
				}
				break;
			
			/*wait XNL reply*/			
			case WAITING_FOR_REPLY://直到回答ACK才再发送下一条data/control
				if(pdTRUE == xSemaphoreTake( xnl_timeout_semphr
800048e8:	66 0c       	ld.w	r12,r3[0x0]
800048ea:	0e 99       	mov	r9,r7
800048ec:	36 4a       	mov	r10,100
800048ee:	0e 9b       	mov	r11,r7
800048f0:	f0 1f 00 14 	mcall	80004940 <xnl_tx_process+0xb4>
800048f4:	58 1c       	cp.w	r12,1
800048f6:	c0 81       	brne	80004906 <xnl_tx_process+0x7a>
					, ( portTickType )50*2/ portTICK_RATE_MS))//按ADK文档中提示500ms一次超时,但是实际情况下程序中启用freertos的任务延时不够精准。因此根据经验需要降低延时等待的时间
				{
					/*No timeout*/
					//vPortFree(ptr);	
					set_xnl_idle(ptr);			
800048f8:	49 58       	lddpc	r8,8000494c <xnl_tx_process+0xc0>
800048fa:	70 0c       	ld.w	r12,r8[0x0]
800048fc:	68 0b       	ld.w	r11,r4[0x0]
800048fe:	f0 1f 00 15 	mcall	80004950 <xnl_tx_process+0xc4>
					xnl_tx_state = WAITING_FOR_TX;
80004902:	8d 07       	st.w	r6[0x0],r7
80004904:	cc db       	rjmp	8000489e <xnl_tx_process+0x12>
				}
				else
				{
					/*time out*/
					if(xnl_send_times <= MIN_RESEND_TIMES)
80004906:	6a 08       	ld.w	r8,r5[0x0]
80004908:	58 38       	cp.w	r8,3
8000490a:	e0 89 00 09 	brgt	8000491c <xnl_tx_process+0x90>
					{
						/*If times smaller than A supermarket, then resend the 
						instructions*/
						phy_tx((phy_fragment_t *)ptr);
8000490e:	68 0c       	ld.w	r12,r4[0x0]
80004910:	f0 1f 00 0e 	mcall	80004948 <xnl_tx_process+0xbc>
						xnl_send_times++;
80004914:	6a 08       	ld.w	r8,r5[0x0]
80004916:	2f f8       	sub	r8,-1
80004918:	8b 08       	st.w	r5[0x0],r8
8000491a:	cc 2b       	rjmp	8000489e <xnl_tx_process+0x12>
					}
					else
					{
						//can not send data, disconnected						
						//vPortFree(ptr);	
						set_xnl_idle(ptr);									
8000491c:	48 c8       	lddpc	r8,8000494c <xnl_tx_process+0xc0>
8000491e:	70 0c       	ld.w	r12,r8[0x0]
80004920:	68 0b       	ld.w	r11,r4[0x0]
80004922:	f0 1f 00 0c 	mcall	80004950 <xnl_tx_process+0xc4>
						xnl_tx_state = WAITING_FOR_TX;
80004926:	8d 07       	st.w	r6[0x0],r7
80004928:	cb bb       	rjmp	8000489e <xnl_tx_process+0x12>
8000492a:	00 00       	add	r0,r0
8000492c:	00 00       	add	r0,r0
8000492e:	0b 50       	ld.sh	r0,--r5
80004930:	00 00       	add	r0,r0
80004932:	0b 44       	ld.w	r4,--r5
80004934:	00 00       	add	r0,r0
80004936:	0b 48       	ld.w	r8,--r5
80004938:	00 00       	add	r0,r0
8000493a:	0b 4c       	ld.w	r12,--r5
8000493c:	00 00       	add	r0,r0
8000493e:	0b 34       	ld.ub	r4,r5++
80004940:	80 00       	ld.sh	r0,r0[0x0]
80004942:	5f dc       	srvc	r12
80004944:	80 00       	ld.sh	r0,r0[0x0]
80004946:	5e 6c       	retmi	r12
80004948:	80 00       	ld.sh	r0,r0[0x0]
8000494a:	30 20       	mov	r0,2
8000494c:	00 00       	add	r0,r0
8000494e:	0a 9c       	mov	r12,r5
80004950:	80 00       	ld.sh	r0,r0[0x0]
80004952:	30 00       	mov	r0,0

80004954 <xnl_rx_process>:
Description: Receive the XNL
Calls: 
Called By:task
*/
static void xnl_rx_process(void * pvParameters)
{
80004954:	eb cd 40 fe 	pushm	r1-r7,lr
80004958:	20 1d       	sub	sp,4
	/*To ptr the elements in the queue*/
	xnl_fragment_t * xnl_ptr;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
8000495a:	49 26       	lddpc	r6,800049a0 <xnl_rx_process+0x4c>
8000495c:	30 05       	mov	r5,0
8000495e:	3f f4       	mov	r4,-1
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
80004960:	30 c3       	mov	r3,12
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
80004962:	49 11       	lddpc	r1,800049a4 <xnl_rx_process+0x50>
	if(xnl->xnl_header.opcode > 0x0C)	
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
80004964:	49 12       	lddpc	r2,800049a8 <xnl_rx_process+0x54>
	/*To ptr the elements in the queue*/
	xnl_fragment_t * xnl_ptr;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
80004966:	6c 0c       	ld.w	r12,r6[0x0]
80004968:	0a 99       	mov	r9,r5
8000496a:	08 9a       	mov	r10,r4
8000496c:	1a 9b       	mov	r11,sp
8000496e:	f0 1f 00 10 	mcall	800049ac <xnl_rx_process+0x58>
80004972:	58 1c       	cp.w	r12,1
80004974:	cf 91       	brne	80004966 <xnl_rx_process+0x12>
		, portMAX_DELAY ))
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
80004976:	40 0c       	lddsp	r12,sp[0x0]
80004978:	58 0c       	cp.w	r12,0
8000497a:	cf 60       	breq	80004966 <xnl_rx_process+0x12>
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
8000497c:	98 28       	ld.sh	r8,r12[0x4]
8000497e:	e6 08 19 00 	cp.h	r8,r3
80004982:	e0 8b 00 0a 	brhi	80004996 <xnl_rx_process+0x42>
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
80004986:	5c 78       	castu.h	r8
80004988:	e4 08 03 29 	ld.w	r9,r2[r8<<0x2]
8000498c:	58 09       	cp.w	r9,0
8000498e:	c0 40       	breq	80004996 <xnl_rx_process+0x42>
	{
		//log("\n\r R_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:R_xnl指令
		/*execute the function in list*/
		xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec(xnl);
80004990:	e4 08 03 28 	ld.w	r8,r2[r8<<0x2]
80004994:	5d 18       	icall	r8
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
80004996:	62 0c       	ld.w	r12,r1[0x0]
80004998:	40 0b       	lddsp	r11,sp[0x0]
8000499a:	f0 1f 00 06 	mcall	800049b0 <xnl_rx_process+0x5c>
8000499e:	ce 4b       	rjmp	80004966 <xnl_rx_process+0x12>
800049a0:	00 00       	add	r0,r0
800049a2:	0a c4       	st.b	r5++,r4
800049a4:	00 00       	add	r0,r0
800049a6:	0a 9c       	mov	r12,r5
800049a8:	00 00       	add	r0,r0
800049aa:	04 f4       	st.b	--r2,r4
800049ac:	80 00       	ld.sh	r0,r0[0x0]
800049ae:	5f dc       	srvc	r12
800049b0:	80 00       	ld.sh	r0,r0[0x0]
800049b2:	30 00       	mov	r0,0

800049b4 <xnl_tx>:
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
{
800049b4:	eb cd 40 c0 	pushm	r6-r7,lr
800049b8:	20 1d       	sub	sp,4
800049ba:	18 96       	mov	r6,r12
	message that is sent. The same value should be used for all retries.
	*/
	static U8 flags = 0;
	
	/*If the value is DEFAULT_VALUE, the value will be modified*/
	if(DEFAULT_VALUE == xnl->xnl_header.flags)
800049bc:	98 39       	ld.sh	r9,r12[0x6]
800049be:	3f f8       	mov	r8,-1
800049c0:	f0 09 19 00 	cp.h	r9,r8
800049c4:	c0 a1       	brne	800049d8 <xnl_tx+0x24>
	{
		xnl->xnl_header.flags =  0x0100 | ((++flags) & 0x07);
800049c6:	4a e9       	lddpc	r9,80004a7c <xnl_tx+0xc8>
800049c8:	13 88       	ld.ub	r8,r9[0x0]
800049ca:	2f f8       	sub	r8,-1
800049cc:	5c 58       	castu.b	r8
800049ce:	b2 88       	st.b	r9[0x0],r8
800049d0:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
800049d4:	a9 a8       	sbr	r8,0x8
800049d6:	b8 38       	st.h	r12[0x6],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.destination)
800049d8:	8c 49       	ld.sh	r9,r6[0x8]
800049da:	3f f8       	mov	r8,-1
800049dc:	f0 09 19 00 	cp.h	r9,r8
800049e0:	c0 41       	brne	800049e8 <xnl_tx+0x34>
	{		
		/*Use actual Master address.*/
		xnl->xnl_header.destination = xnl_information.master_address;
800049e2:	4a 88       	lddpc	r8,80004a80 <xnl_tx+0xcc>
800049e4:	90 18       	ld.sh	r8,r8[0x2]
800049e6:	ac 48       	st.h	r6[0x8],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.source)
800049e8:	8c 59       	ld.sh	r9,r6[0xa]
800049ea:	3f f8       	mov	r8,-1
800049ec:	f0 09 19 00 	cp.h	r9,r8
800049f0:	c0 41       	brne	800049f8 <xnl_tx+0x44>
	{
		/*Use Temporary address.*/	
		xnl->xnl_header.source = xnl_information.device_address;
800049f2:	4a 48       	lddpc	r8,80004a80 <xnl_tx+0xcc>
800049f4:	90 28       	ld.sh	r8,r8[0x4]
800049f6:	ac 58       	st.h	r6[0xa],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
800049f8:	8c 69       	ld.sh	r9,r6[0xc]
800049fa:	3f f8       	mov	r8,-1
800049fc:	f0 09 19 00 	cp.h	r9,r8
80004a00:	c0 e1       	brne	80004a1c <xnl_tx+0x68>
	{		
		xnl->xnl_header.transaction_id = 
		  ((++xnl_information.transaction_id) & 0xFF) 
80004a02:	4a 08       	lddpc	r8,80004a80 <xnl_tx+0xcc>
80004a04:	90 49       	ld.sh	r9,r8[0x8]
80004a06:	2f f9       	sub	r9,-1
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
80004a08:	b0 49       	st.h	r8[0x8],r9
		  ((++xnl_information.transaction_id) & 0xFF) 
80004a0a:	90 4a       	ld.sh	r10,r8[0x8]
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
80004a0c:	90 49       	ld.sh	r9,r8[0x8]
80004a0e:	e0 19 ff 00 	andl	r9,0xff00
80004a12:	f1 da c0 08 	bfextu	r8,r10,0x0,0x8
80004a16:	f3 e8 10 08 	or	r8,r9,r8
80004a1a:	ac 68       	st.h	r6[0xc],r8
	U16  sumScratch;
	U32  indextohWord;
	S32  hWordswithinFrag;
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
80004a1c:	0d 98       	ld.ub	r8,r6[0x1]
80004a1e:	20 28       	sub	r8,2
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
80004a20:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
80004a24:	10 0c       	add	r12,r8
80004a26:	a1 5c       	asr	r12,0x1
	indextohWord = 2;
	while (hWordswithinFrag > 0)
80004a28:	58 0c       	cp.w	r12,0
80004a2a:	e0 89 00 04 	brgt	80004a32 <xnl_tx+0x7e>
80004a2e:	30 09       	mov	r9,0
80004a30:	c0 d8       	rjmp	80004a4a <xnl_tx+0x96>
80004a32:	ec ca ff fc 	sub	r10,r6,-4
Parameters: xnl_fragment_t * 
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
80004a36:	2f ec       	sub	r12,-2
80004a38:	30 09       	mov	r9,0
80004a3a:	30 28       	mov	r8,2
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
	{
		sumScratch += *((U16*)xnl + indextohWord);
80004a3c:	15 1b       	ld.sh	r11,r10++
80004a3e:	f6 09 00 09 	add	r9,r11,r9
80004a42:	5c 89       	casts.h	r9
		indextohWord     += 1;
80004a44:	2f f8       	sub	r8,-1
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
80004a46:	18 38       	cp.w	r8,r12
80004a48:	cf a1       	brne	80004a3c <xnl_tx+0x88>
		  ((++xnl_information.transaction_id) & 0xFF) 
		| (xnl_information.transaction_id & 0xFF00);
	}
	
	/*count check sum */
	xnl->phy_header.check_sum = check_sum( xnl );
80004a4a:	5c 39       	neg	r9
80004a4c:	ac 19       	st.h	r6[0x2],r9
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
80004a4e:	48 e8       	lddpc	r8,80004a84 <xnl_tx+0xd0>
80004a50:	70 0c       	ld.w	r12,r8[0x0]
80004a52:	f0 1f 00 0e 	mcall	80004a88 <xnl_tx+0xd4>
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
80004a56:	c1 00       	breq	80004a76 <xnl_tx+0xc2>
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
80004a58:	fa c7 ff fc 	sub	r7,sp,-4
80004a5c:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
	{
		memcpy(ptr, xnl, sizeof(xnl_fragment_t));
80004a5e:	e0 6a 01 00 	mov	r10,256
80004a62:	0c 9b       	mov	r11,r6
80004a64:	f0 1f 00 0a 	mcall	80004a8c <xnl_tx+0xd8>
	
		/*push to queue and send*/
		
		//log("ptr -%8x", ptr);
		
		xQueueSend(xnl_frame_tx, &ptr, 0);
80004a68:	48 a8       	lddpc	r8,80004a90 <xnl_tx+0xdc>
80004a6a:	70 0c       	ld.w	r12,r8[0x0]
80004a6c:	30 09       	mov	r9,0
80004a6e:	12 9a       	mov	r10,r9
80004a70:	1a 9b       	mov	r11,sp
80004a72:	f0 1f 00 09 	mcall	80004a94 <xnl_tx+0xe0>
		//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
		
		//vPortFree(ptr);
	}
}
80004a76:	2f fd       	sub	sp,-4
80004a78:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004a7c:	00 00       	add	r0,r0
80004a7e:	0b 38       	ld.ub	r8,r5++
80004a80:	00 00       	add	r0,r0
80004a82:	0b 3a       	ld.ub	r10,r5++
80004a84:	00 00       	add	r0,r0
80004a86:	0a 9c       	mov	r12,r5
80004a88:	80 00       	ld.sh	r0,r0[0x0]
80004a8a:	35 6c       	mov	r12,86
80004a8c:	80 00       	ld.sh	r0,r0[0x0]
80004a8e:	77 3a       	ld.w	r10,r11[0x4c]
80004a90:	00 00       	add	r0,r0
80004a92:	0b 44       	ld.w	r4,--r5
80004a94:	80 00       	ld.sh	r0,r0[0x0]
80004a96:	61 e8       	ld.w	r8,r0[0x78]

80004a98 <xnl_init>:
	xTaskCreate--freertos
	xnl_send_device_master_query
Called By:xcmp_init -- xcmp.c
*/
void xnl_init(void)
{
80004a98:	eb cd 40 80 	pushm	r7,lr
80004a9c:	fa cd 01 00 	sub	sp,sp,256
	
	xnl_information.is_connected = FALSE;
80004aa0:	30 09       	mov	r9,0
80004aa2:	4a 78       	lddpc	r8,80004b3c <xnl_init+0xa4>
80004aa4:	b0 89       	st.b	r8[0x0],r9

	/*initialize the semaphore and queue*/
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
80004aa6:	30 0b       	mov	r11,0
80004aa8:	30 1c       	mov	r12,1
80004aaa:	f0 1f 00 26 	mcall	80004b40 <xnl_init+0xa8>
80004aae:	4a 68       	lddpc	r8,80004b44 <xnl_init+0xac>
80004ab0:	91 0c       	st.w	r8[0x0],r12
80004ab2:	70 08       	ld.w	r8,r8[0x0]
80004ab4:	58 08       	cp.w	r8,0
80004ab6:	c0 80       	breq	80004ac6 <xnl_init+0x2e>
80004ab8:	4a 38       	lddpc	r8,80004b44 <xnl_init+0xac>
80004aba:	70 0c       	ld.w	r12,r8[0x0]
80004abc:	30 09       	mov	r9,0
80004abe:	12 9a       	mov	r10,r9
80004ac0:	12 9b       	mov	r11,r9
80004ac2:	f0 1f 00 22 	mcall	80004b48 <xnl_init+0xb0>
	//xnl_frame_tx = xQueueCreate(10, sizeof(xnl_fragment_t *)); 
	
	xnl_frame_tx = xQueueCreate(20, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
80004ac6:	30 4b       	mov	r11,4
80004ac8:	31 4c       	mov	r12,20
80004aca:	f0 1f 00 1e 	mcall	80004b40 <xnl_init+0xa8>
80004ace:	4a 08       	lddpc	r8,80004b4c <xnl_init+0xb4>
80004ad0:	91 0c       	st.w	r8[0x0],r12
		
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
80004ad2:	30 07       	mov	r7,0
80004ad4:	1a d7       	st.w	--sp,r7
80004ad6:	1a d7       	st.w	--sp,r7
80004ad8:	1a d7       	st.w	--sp,r7
80004ada:	30 38       	mov	r8,3
80004adc:	0e 99       	mov	r9,r7
80004ade:	e0 6a 02 00 	mov	r10,512
80004ae2:	49 cb       	lddpc	r11,80004b50 <xnl_init+0xb8>
80004ae4:	49 cc       	lddpc	r12,80004b54 <xnl_init+0xbc>
80004ae6:	f0 1f 00 1d 	mcall	80004b58 <xnl_init+0xc0>
	,  tskXNL_PRIORITY //+ 1
	,  NULL
	);
	
	/*this task is used to send xnl message*/
	xTaskCreate(
80004aea:	1a d7       	st.w	--sp,r7
80004aec:	1a d7       	st.w	--sp,r7
80004aee:	1a d7       	st.w	--sp,r7
80004af0:	30 38       	mov	r8,3
80004af2:	0e 99       	mov	r9,r7
80004af4:	e0 6a 03 20 	mov	r10,800
80004af8:	49 9b       	lddpc	r11,80004b5c <xnl_init+0xc4>
80004afa:	49 ac       	lddpc	r12,80004b60 <xnl_init+0xc8>
80004afc:	f0 1f 00 17 	mcall	80004b58 <xnl_init+0xc0>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80004b00:	e0 68 40 0e 	mov	r8,16398
80004b04:	fb 58 00 18 	st.h	sp[24],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004b08:	3f f8       	mov	r8,-1
80004b0a:	fb 58 00 1a 	st.h	sp[26],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_MASTER_QUERY;
80004b0e:	30 38       	mov	r8,3
80004b10:	fb 58 00 1c 	st.h	sp[28],r8
	
	/*The initial value*/
	xnl_frame.xnl_header.flags = 0;
80004b14:	fb 57 00 1e 	st.h	sp[30],r7
	
	/*XNL address of the master device, if known;otherwise 0x0000*/
	xnl_frame.xnl_header.destination = 0;
80004b18:	fb 57 00 20 	st.h	sp[32],r7
	
	/*XNL address, if assigned; otherwise 0x0000*/
	xnl_frame.xnl_header.source = 0;
80004b1c:	fb 57 00 22 	st.h	sp[34],r7
	
	/*No transaction ID required for this message*/
	xnl_frame.xnl_header.transaction_id = 0;
80004b20:	fb 57 00 24 	st.h	sp[36],r7
	
	/*This message contains no payload*/
	xnl_frame.xnl_header.payload_length = 0;
80004b24:	fb 57 00 26 	st.h	sp[38],r7

	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004b28:	fa cc ff e8 	sub	r12,sp,-24
80004b2c:	f0 1f 00 0e 	mcall	80004b64 <xnl_init+0xcc>
	
	/*send device_master_query to connect radio*/	
	xnl_send_device_master_query();
	
	/*initialize the physical layer*/
	phy_init();
80004b30:	f0 1f 00 0e 	mcall	80004b68 <xnl_init+0xd0>
80004b34:	2f ad       	sub	sp,-24
}
80004b36:	2c 0d       	sub	sp,-256
80004b38:	e3 cd 80 80 	ldm	sp++,r7,pc
80004b3c:	00 00       	add	r0,r0
80004b3e:	0b 3a       	ld.ub	r10,r5++
80004b40:	80 00       	ld.sh	r0,r0[0x0]
80004b42:	62 e8       	ld.w	r8,r1[0x38]
80004b44:	00 00       	add	r0,r0
80004b46:	0b 34       	ld.ub	r4,r5++
80004b48:	80 00       	ld.sh	r0,r0[0x0]
80004b4a:	61 e8       	ld.w	r8,r0[0x78]
80004b4c:	00 00       	add	r0,r0
80004b4e:	0b 44       	ld.w	r4,--r5
80004b50:	80 00       	ld.sh	r0,r0[0x0]
80004b52:	db d0       	acall	0xbd
80004b54:	80 00       	ld.sh	r0,r0[0x0]
80004b56:	49 54       	lddpc	r4,80004ba8 <xnl_data_msg_func+0x3c>
80004b58:	80 00       	ld.sh	r0,r0[0x0]
80004b5a:	69 bc       	ld.w	r12,r4[0x6c]
80004b5c:	80 00       	ld.sh	r0,r0[0x0]
80004b5e:	ce 00       	breq	80004b1e <xnl_init+0x86>
80004b60:	80 00       	ld.sh	r0,r0[0x0]
80004b62:	48 8c       	lddpc	r12,80004b80 <xnl_data_msg_func+0x14>
80004b64:	80 00       	ld.sh	r0,r0[0x0]
80004b66:	49 b4       	lddpc	r4,80004bd0 <xnl_device_auth_reply_func+0x4>
80004b68:	80 00       	ld.sh	r0,r0[0x0]
80004b6a:	35 94       	mov	r4,89

80004b6c <xnl_data_msg_func>:
Description: process while receive data message.
Calls:xnl_send_msg_ack, xcmp_exec(function in xcmp)
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_data_msg_func(xnl_fragment_t * xnl)
{
80004b6c:	eb cd 40 80 	pushm	r7,lr
80004b70:	fa cd 01 00 	sub	sp,sp,256
80004b74:	18 97       	mov	r7,r12
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80004b76:	e0 68 40 0e 	mov	r8,16398
80004b7a:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004b7c:	3f f8       	mov	r8,-1
80004b7e:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG_ACK;
80004b80:	30 c8       	mov	r8,12
80004b82:	ba 28       	st.h	sp[0x4],r8
	
	/*Turn around Flags.*/	
	xnl_frame.xnl_header.flags = hdr->flags;
80004b84:	98 38       	ld.sh	r8,r12[0x6]
80004b86:	ba 38       	st.h	sp[0x6],r8
	
	/*ACK Destination Address is Source of XNL_Message.*/
	xnl_frame.xnl_header.destination = hdr->source;
80004b88:	98 58       	ld.sh	r8,r12[0xa]
80004b8a:	ba 48       	st.h	sp[0x8],r8
	
	/*ACK Source Address is my address.*/
	xnl_frame.xnl_header.source = hdr->destination;
80004b8c:	98 48       	ld.sh	r8,r12[0x8]
80004b8e:	ba 58       	st.h	sp[0xa],r8
	
	/*Turn around Transaction ID.*/
	xnl_frame.xnl_header.transaction_id = hdr->transaction_id;
80004b90:	98 68       	ld.sh	r8,r12[0xc]
80004b92:	ba 68       	st.h	sp[0xc],r8
	xnl_frame.xnl_header.payload_length = 0;
80004b94:	30 08       	mov	r8,0
80004b96:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004b98:	1a 9c       	mov	r12,sp
80004b9a:	f0 1f 00 0a 	mcall	80004bc0 <xnl_data_msg_func+0x54>
	transmitter, but possibly is waiting in Queue with immediate timeout.
	 */
	xnl_send_msg_ack(&xnl->xnl_header);
	
	/*exec xcmp function*/
	xcmp_exec(xnl->xnl_payload.xnl_content_data_msg);//xcmp_rx
80004b9e:	fa cd 00 cc 	sub	sp,sp,204
80004ba2:	e0 6a 00 ca 	mov	r10,202
80004ba6:	ee cb ff f0 	sub	r11,r7,-16
80004baa:	1a 9c       	mov	r12,sp
80004bac:	f0 1f 00 06 	mcall	80004bc4 <xnl_data_msg_func+0x58>
80004bb0:	48 68       	lddpc	r8,80004bc8 <xnl_data_msg_func+0x5c>
80004bb2:	70 08       	ld.w	r8,r8[0x0]
80004bb4:	5d 18       	icall	r8
80004bb6:	fa cd ff 34 	sub	sp,sp,-204
}
80004bba:	2c 0d       	sub	sp,-256
80004bbc:	e3 cd 80 80 	ldm	sp++,r7,pc
80004bc0:	80 00       	ld.sh	r0,r0[0x0]
80004bc2:	49 b4       	lddpc	r4,80004c2c <xnl_device_auth_reply_func+0x60>
80004bc4:	80 00       	ld.sh	r0,r0[0x0]
80004bc6:	77 3a       	ld.w	r10,r11[0x4c]
80004bc8:	00 00       	add	r0,r0
80004bca:	0b 54       	ld.sh	r4,--r5

80004bcc <xnl_device_auth_reply_func>:
Description: process while receive device auth reply.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_auth_reply_func(xnl_fragment_t * xnl)
{
80004bcc:	d4 21       	pushm	r4-r7,lr
80004bce:	fa cd 01 00 	sub	sp,sp,256
80004bd2:	18 97       	mov	r7,r12
	the receiving device and will be used to authenticate the connection 
	request. 5.4.4
	*/
	//log("R_xnl-opcode:%4x", xnl->xnl_header.opcode);
	
	if(xnl_information.is_connected)
80004bd4:	4c 28       	lddpc	r8,80004cdc <xnl_device_auth_reply_func+0x110>
80004bd6:	11 88       	ld.ub	r8,r8[0x0]
80004bd8:	58 08       	cp.w	r8,0
80004bda:	c7 e1       	brne	80004cd6 <xnl_device_auth_reply_func+0x10a>
	{
		return;		
	}
	
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);
80004bdc:	4c 18       	lddpc	r8,80004ce0 <xnl_device_auth_reply_func+0x114>
80004bde:	70 0c       	ld.w	r12,r8[0x0]
80004be0:	30 09       	mov	r9,0
80004be2:	12 9a       	mov	r10,r9
80004be4:	12 9b       	mov	r11,r9
80004be6:	f0 1f 00 40 	mcall	80004ce4 <xnl_device_auth_reply_func+0x118>

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
80004bea:	ef 09 00 10 	ld.sh	r9,r7[16]
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
80004bee:	4b c8       	lddpc	r8,80004cdc <xnl_device_auth_reply_func+0x110>
80004bf0:	b0 29       	st.h	r8[0x4],r9
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
	
	/*Get Array of values to be encrypted into an aligned 2X32bits.*/
	v_vector[0] =
80004bf2:	ef 39 00 12 	ld.ub	r9,r7[18]
80004bf6:	ef 38 00 13 	ld.ub	r8,r7[19]
80004bfa:	b1 68       	lsl	r8,0x10
80004bfc:	f1 e9 11 89 	or	r9,r8,r9<<0x18
80004c00:	ef 38 00 15 	ld.ub	r8,r7[21]
80004c04:	f3 e8 10 08 	or	r8,r9,r8
80004c08:	ef 39 00 14 	ld.ub	r9,r7[20]
80004c0c:	f1 e9 10 89 	or	r9,r8,r9<<0x8
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[2])<<8	  
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[3]);
	
	v_vector[1] =
80004c10:	ef 3a 00 16 	ld.ub	r10,r7[22]
80004c14:	ef 38 00 17 	ld.ub	r8,r7[23]
80004c18:	b1 68       	lsl	r8,0x10
80004c1a:	f1 ea 11 8a 	or	r10,r8,r10<<0x18
80004c1e:	ef 38 00 19 	ld.ub	r8,r7[25]
80004c22:	f5 e8 10 08 	or	r8,r10,r8
80004c26:	ef 3a 00 18 	ld.ub	r10,r7[24]
80004c2a:	f1 ea 10 88 	or	r8,r8,r10<<0x8
80004c2e:	30 0a       	mov	r10,0
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
80004c30:	e0 64 79 b9 	mov	r4,31161
80004c34:	ea 14 9e 37 	orh	r4,0x9e37
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
80004c38:	e0 65 45 07 	mov	r5,17671
80004c3c:	ea 15 8a bd 	orh	r5,0x8abd
80004c40:	e0 66 f9 3d 	mov	r6,63805
80004c44:	ea 16 99 68 	orh	r6,0x9968
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
80004c48:	e0 6e b8 cf 	mov	lr,47311
80004c4c:	ea 1e 36 83 	orh	lr,0x3683
80004c50:	e0 67 aa 1c 	mov	r7,43548
80004c54:	ea 17 9c 36 	orh	r7,0x9c36
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
80004c58:	08 0a       	add	r10,r4
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
80004c5a:	f4 08 00 0c 	add	r12,r10,r8
80004c5e:	f0 0b 15 04 	lsl	r11,r8,0x4
80004c62:	0a 0b       	add	r11,r5
80004c64:	f9 eb 20 0b 	eor	r11,r12,r11
80004c68:	f0 0c 16 05 	lsr	r12,r8,0x5
80004c6c:	0c 0c       	add	r12,r6
80004c6e:	18 5b       	eor	r11,r12
80004c70:	16 09       	add	r9,r11
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
80004c72:	f2 0c 15 04 	lsl	r12,r9,0x4
80004c76:	1c 0c       	add	r12,lr
80004c78:	f2 0b 16 05 	lsr	r11,r9,0x5
80004c7c:	0e 0b       	add	r11,r7
80004c7e:	f9 eb 20 0b 	eor	r11,r12,r11
80004c82:	f2 0a 00 0c 	add	r12,r9,r10
80004c86:	18 5b       	eor	r11,r12
80004c88:	16 08       	add	r8,r11
{
	register U32 y=v[0], z=v[1], sum=0;
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
80004c8a:	e0 6b 37 20 	mov	r11,14112
80004c8e:	ea 1b c6 ef 	orh	r11,0xc6ef
80004c92:	16 3a       	cp.w	r10,r11
80004c94:	ce 21       	brne	80004c58 <xnl_device_auth_reply_func+0x8c>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :24 + 2(xnl length(24) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 24 + 2;
80004c96:	e0 6a 40 1a 	mov	r10,16410
80004c9a:	ba 0a       	st.h	sp[0x0],r10
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004c9c:	3f fa       	mov	r10,-1
80004c9e:	ba 1a       	st.h	sp[0x2],r10
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_CONN_REQUEST;
80004ca0:	30 6b       	mov	r11,6
80004ca2:	ba 2b       	st.h	sp[0x4],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
80004ca4:	ba 3a       	st.h	sp[0x6],r10
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
80004ca6:	48 eb       	lddpc	r11,80004cdc <xnl_device_auth_reply_func+0x110>
80004ca8:	96 1c       	ld.sh	r12,r11[0x2]
80004caa:	ba 4c       	st.h	sp[0x8],r12
	message here, and all will receive the same DEVICE_CONN_REPLY. Not real 
	sure what's going to happen with multiple conrol heads, etc. One suspects 
	the Rocket Scientists will eventually figure this out, and demand a 
	transaction ID based on Device Type in the XNL_DEVICE_AUTH_KEY_REQUEST.
	*/
	xnl_frame.xnl_header.source = xnl_information.device_address;
80004cac:	96 2b       	ld.sh	r11,r11[0x4]
80004cae:	ba 5b       	st.h	sp[0xa],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80004cb0:	ba 6a       	st.h	sp[0xc],r10
	
    /*his message contains 12 payload bytes*/	
	xnl_frame.xnl_header.payload_length = 0x000C;
80004cb2:	30 ca       	mov	r10,12
80004cb4:	ba 7a       	st.h	sp[0xe],r10
	
	/*No Preferred XNL Address*/
	xnl_frame.xnl_payload.xnl_content_device_conn_req.preferred_xnl_address = 
80004cb6:	30 0a       	mov	r10,0
80004cb8:	fb 5a 00 10 	st.h	sp[16],r10
	XCMP/XNL Development Specification Section 4.5.3.2.1.
	Same as in MOTOTRBO?XCMP/XNL Development Specification?
	evice_type--Option Board(0x07)
	authentication_index--Option Board(0x02)
	*/	
	xnl_frame.xnl_payload.xnl_content_device_conn_req.device_type = 0x07;
80004cbc:	30 7a       	mov	r10,7
80004cbe:	fb 6a 00 12 	st.b	sp[18],r10
	xnl_frame.xnl_payload.xnl_content_device_conn_req.authentication_index =
80004cc2:	30 2a       	mov	r10,2
80004cc4:	fb 6a 00 13 	st.b	sp[19],r10
	                                                                       0x02;
		
	//We know encrypted array happens to be aligned to 32-bit boundary.
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
80004cc8:	fa ca ff ec 	sub	r10,sp,-20
80004ccc:	95 09       	st.w	r10[0x0],r9
	                         .encrypted_authentication_value[0])) = w_vector[0];
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
80004cce:	95 18       	st.w	r10[0x4],r8
	                         .encrypted_authentication_value[4])) = w_vector[1];
	
	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004cd0:	1a 9c       	mov	r12,sp
80004cd2:	f0 1f 00 06 	mcall	80004ce8 <xnl_device_auth_reply_func+0x11c>
}
80004cd6:	2c 0d       	sub	sp,-256
80004cd8:	d8 22       	popm	r4-r7,pc
80004cda:	00 00       	add	r0,r0
80004cdc:	00 00       	add	r0,r0
80004cde:	0b 3a       	ld.ub	r10,r5++
80004ce0:	00 00       	add	r0,r0
80004ce2:	0b 34       	ld.ub	r4,r5++
80004ce4:	80 00       	ld.sh	r0,r0[0x0]
80004ce6:	61 e8       	ld.w	r8,r0[0x78]
80004ce8:	80 00       	ld.sh	r0,r0[0x0]
80004cea:	49 b4       	lddpc	r4,80004d54 <xnl_device_conn_reply_func+0x8>

80004cec <xnl_master_status_brdcst_func>:
Description: process while receive master status boardcast.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_master_status_brdcst_func(xnl_fragment_t * xnl)
{	
80004cec:	eb cd 40 80 	pushm	r7,lr
80004cf0:	fa cd 01 00 	sub	sp,sp,256
80004cf4:	18 97       	mov	r7,r12
	not an XNL_DATA_MSG has been sent out. This will indicate to a connecting 
	device that it has missed messages. The XNL header will contain the 
	master?XNL address. 5.4.1
	*/
	
	if(xnl_information.is_connected)
80004cf6:	49 28       	lddpc	r8,80004d3c <xnl_master_status_brdcst_func+0x50>
80004cf8:	11 88       	ld.ub	r8,r8[0x0]
80004cfa:	58 08       	cp.w	r8,0
80004cfc:	c1 c1       	brne	80004d34 <xnl_master_status_brdcst_func+0x48>
	{
		return;	
	}
		
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);	
80004cfe:	49 18       	lddpc	r8,80004d40 <xnl_master_status_brdcst_func+0x54>
80004d00:	70 0c       	ld.w	r12,r8[0x0]
80004d02:	30 09       	mov	r9,0
80004d04:	12 9a       	mov	r10,r9
80004d06:	12 9b       	mov	r11,r9
80004d08:	f0 1f 00 0f 	mcall	80004d44 <xnl_master_status_brdcst_func+0x58>

	//log("xnl-ma:%4x", xnl->xnl_header.source);
	/*get the master adderss from this message*/	
	xnl_information.master_address = xnl->xnl_header.source;	
80004d0c:	8e 58       	ld.sh	r8,r7[0xa]
80004d0e:	48 c9       	lddpc	r9,80004d3c <xnl_master_status_brdcst_func+0x50>
80004d10:	b2 18       	st.h	r9[0x2],r8
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80004d12:	e0 68 40 0e 	mov	r8,16398
80004d16:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004d18:	3f f8       	mov	r8,-1
80004d1a:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_AUTH_KEY_REQUEST;
80004d1c:	30 4a       	mov	r10,4
80004d1e:	ba 2a       	st.h	sp[0x4],r10
		
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/	
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
80004d20:	ba 38       	st.h	sp[0x6],r8
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
80004d22:	92 19       	ld.sh	r9,r9[0x2]
80004d24:	ba 49       	st.h	sp[0x8],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.source = DEFAULT_VALUE;
80004d26:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80004d28:	ba 68       	st.h	sp[0xc],r8
		
	xnl_frame.xnl_header.payload_length = 0;
80004d2a:	30 08       	mov	r8,0
80004d2c:	ba 78       	st.h	sp[0xe],r8
	
	/*send XNL message*/	
	xnl_tx(&xnl_frame);
80004d2e:	1a 9c       	mov	r12,sp
80004d30:	f0 1f 00 06 	mcall	80004d48 <xnl_master_status_brdcst_func+0x5c>
}
80004d34:	2c 0d       	sub	sp,-256
80004d36:	e3 cd 80 80 	ldm	sp++,r7,pc
80004d3a:	00 00       	add	r0,r0
80004d3c:	00 00       	add	r0,r0
80004d3e:	0b 3a       	ld.ub	r10,r5++
80004d40:	00 00       	add	r0,r0
80004d42:	0b 34       	ld.ub	r4,r5++
80004d44:	80 00       	ld.sh	r0,r0[0x0]
80004d46:	61 e8       	ld.w	r8,r0[0x78]
80004d48:	80 00       	ld.sh	r0,r0[0x0]
80004d4a:	49 b4       	lddpc	r4,80004db4 <local_start_pll0+0xc>

80004d4c <xnl_device_conn_reply_func>:
Description: process while receive device conn reply.
Calls:xSemaphoreGive--freestos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_conn_reply_func(xnl_fragment_t * xnl)
{
80004d4c:	eb cd 40 80 	pushm	r7,lr
80004d50:	18 97       	mov	r7,r12
	transaction ID and an 8-byte encrypted value that the device can use to 
	authenticate the master. XCMP/XNL Development Guide 5.4.6
	*/
	
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);
80004d52:	49 28       	lddpc	r8,80004d98 <xnl_device_conn_reply_func+0x4c>
80004d54:	70 0c       	ld.w	r12,r8[0x0]
80004d56:	30 09       	mov	r9,0
80004d58:	12 9a       	mov	r10,r9
80004d5a:	12 9b       	mov	r11,r9
80004d5c:	f0 1f 00 10 	mcall	80004d9c <xnl_device_conn_reply_func+0x50>

	/*Test result code*/
	if((xnl->xnl_payload.xnl_content_device_conn_reply.result_base & 0x0000FF00)
80004d60:	ef 18 00 10 	ld.uh	r8,r7[16]
80004d64:	10 99       	mov	r9,r8
80004d66:	e2 19 ff 00 	andl	r9,0xff00,COH
80004d6a:	e0 49 01 00 	cp.w	r9,256
80004d6e:	c0 60       	breq	80004d7a <xnl_device_conn_reply_func+0x2e>
		/*
		Rejected. The device must retry the authentication process at this 
		point by sending out a new AUTH_KEY_REQUEST message. XCMP/XNL 
		Development Guide Section 5.2.3
		*/
		xnl_master_status_brdcst_func(xnl);			
80004d70:	0e 9c       	mov	r12,r7
80004d72:	f0 1f 00 0c 	mcall	80004da0 <xnl_device_conn_reply_func+0x54>
80004d76:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/*connection accepted*/		
		/*Record Transaction ID Base*/
		xnl_information.transaction_id =  
80004d7a:	a9 68       	lsl	r8,0x8
80004d7c:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
80004d80:	48 98       	lddpc	r8,80004da4 <xnl_device_conn_reply_func+0x58>
80004d82:	b0 49       	st.h	r8[0x8],r9
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
80004d84:	ef 09 00 14 	ld.sh	r9,r7[20]
		xnl_information.transaction_id =  
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
80004d88:	b0 39       	st.h	r8[0x6],r9
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
80004d8a:	ef 09 00 12 	ld.sh	r9,r7[18]
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
80004d8e:	b0 29       	st.h	r8[0x4],r9
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
		
		/*connect finish*/
		xnl_information.is_connected = TRUE;
80004d90:	30 19       	mov	r9,1
80004d92:	b0 89       	st.b	r8[0x0],r9
80004d94:	e3 cd 80 80 	ldm	sp++,r7,pc
80004d98:	00 00       	add	r0,r0
80004d9a:	0b 34       	ld.ub	r4,r5++
80004d9c:	80 00       	ld.sh	r0,r0[0x0]
80004d9e:	61 e8       	ld.w	r8,r0[0x78]
80004da0:	80 00       	ld.sh	r0,r0[0x0]
80004da2:	4c ec       	lddpc	r12,80004ed8 <playback_voice_data+0x24>
80004da4:	00 00       	add	r0,r0
80004da6:	0b 3a       	ld.ub	r10,r5++

80004da8 <local_start_pll0>:
	//pm_switch_to_osc0(pm, 12000000, 3);
	//    pm_enable_osc0_crystal(pm, 12000000);
	//         pm_set_osc0_mode(pm,AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);  0x00000007
	//    pm_enable_clk0(pm, 3);
	//         pm_enable_clk0_no_wait(pm, 3);
	(&AVR32_PM)->oscctrl0 = 0x00000307;
80004da8:	fe 78 0c 00 	mov	r8,-62464
80004dac:	e0 69 03 07 	mov	r9,775
80004db0:	91 a9       	st.w	r8[0x28],r9
	(&AVR32_PM)->mcctrl   = 0x00000004;
80004db2:	30 49       	mov	r9,4
80004db4:	91 09       	st.w	r8[0x0],r9
	//         pm_wait_for_clk0_ready(pm);
	while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
80004db6:	71 59       	ld.w	r9,r8[0x54]
80004db8:	e2 19 00 80 	andl	r9,0x80,COH
80004dbc:	cf d0       	breq	80004db6 <local_start_pll0+0xe>
	//    pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);
	(&AVR32_PM)->mcctrl   = 0x00000005;
80004dbe:	fe 78 0c 00 	mov	r8,-62464
80004dc2:	30 59       	mov	r9,5
80004dc4:	91 09       	st.w	r8[0x0],r9
	//pm_pll_set_option(pm, 0, //PLL number 0
	//                        1, //freq Set to 1 for VCO frequency range 80-180MHz
	//                        1, //div2 Divide the PLL output frequency by 2
	//                        0);//0 to enable the Wide-Bandith Mode
	//pm_pll_enable(pm,0);
	(&AVR32_PM)->pll[0] = 0x1007010D;
80004dc6:	e0 69 01 0d 	mov	r9,269
80004dca:	ea 19 10 07 	orh	r9,0x1007
80004dce:	91 89       	st.w	r8[0x20],r9


	//pm_wait_for_pll0_locked(pm);
	while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_LOCK0_MASK));
80004dd0:	71 59       	ld.w	r9,r8[0x54]
80004dd2:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
80004dd6:	cf d0       	breq	80004dd0 <local_start_pll0+0x28>
	//             0,  //Bus A select = 0 (PBA clock = 48MHz/2 = 24MHz).
	//             0,  //B clock divisor enable = 0
	//             0,  //Bus B select = 0
	//             0,  //HS Bus clock divisor enable = 0
	//             0); //HS Bus select = 0
	(&AVR32_PM)->cksel = 0x00800000;
80004dd8:	fe 78 0c 00 	mov	r8,-62464
80004ddc:	fc 19 00 80 	movh	r9,0x80
80004de0:	91 19       	st.w	r8[0x4],r9

	//flashc_set_wait_state(1);
	AVR32_FLASHC.fcr = 0x00000040;
80004de2:	34 0a       	mov	r10,64
80004de4:	fe 69 14 00 	mov	r9,-125952
80004de8:	93 0a       	st.w	r9[0x0],r10

	//pm_switch_to_clock(pm, AVR32_PM_MCSEL_PLL0);
	(&AVR32_PM)->mcctrl   = 0x00000006;
80004dea:	30 69       	mov	r9,6
80004dec:	91 09       	st.w	r8[0x0],r9


	AVR32_HMATRIX.mcfg[AVR32_HMATRIX_MASTER_CPU_INSTRUCTION] = 0x1;
80004dee:	30 19       	mov	r9,1
80004df0:	fe 68 10 00 	mov	r8,-126976
80004df4:	91 19       	st.w	r8[0x4],r9
}
80004df6:	5e fc       	retal	r12

80004df8 <local_start_timer>:
//	MAKO_RX					AVR32_SSC_RX_DATA_0_PIN				[39 PortB Pin  7 00000080 Func 0]
//
void local_start_timer(void)
{
	//Route CLK to Timer
	AVR32_GPIO.port[0].pmr0s = 0x00100000;
80004df8:	fe 78 10 00 	mov	r8,-61440
80004dfc:	fc 19 00 10 	movh	r9,0x10
80004e00:	91 59       	st.w	r8[0x14],r9
	AVR32_GPIO.port[0].pmr1c = 0x00100000;
80004e02:	91 a9       	st.w	r8[0x28],r9
	AVR32_GPIO.port[0].gperc = 0x00100000;
80004e04:	91 29       	st.w	r8[0x8],r9
	//Route FS and Tri-State to Timer.
	AVR32_GPIO.port[1].pmr0c = 0x00000003;
80004e06:	30 39       	mov	r9,3
80004e08:	f1 49 01 18 	st.w	r8[280],r9
	AVR32_GPIO.port[1].pmr1c = 0x00000003;
80004e0c:	f1 49 01 28 	st.w	r8[296],r9
	AVR32_GPIO.port[1].gperc = 0x00000003;
80004e10:	f1 49 01 08 	st.w	r8[264],r9

	(&AVR32_TC)->bmr = 4;
80004e14:	fe 78 38 00 	mov	r8,-51200
80004e18:	30 49       	mov	r9,4
80004e1a:	f1 49 00 c4 	st.w	r8[196],r9
	(&AVR32_TC)->channel[0].cmr =
80004e1e:	e0 69 91 0d 	mov	r9,37133
80004e22:	ea 19 00 52 	orh	r9,0x52
80004e26:	91 19       	st.w	r8[0x4],r9
	1                          << AVR32_TC_CLKI_OFFSET     |
	AVR32_TC_TCCLKS_XC0        << AVR32_TC_TCCLKS_OFFSET;



	(&AVR32_TC)->channel[0].ra = 32;
80004e28:	32 09       	mov	r9,32
80004e2a:	91 59       	st.w	r8[0x14],r9
	(&AVR32_TC)->channel[0].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
80004e2c:	30 59       	mov	r9,5
80004e2e:	91 09       	st.w	r8[0x0],r9
}
80004e30:	5e fc       	retal	r12
80004e32:	d7 03       	nop

80004e34 <tc_init>:
 * - fPBA/8 is used as clock source for TC
 * - Enables RC compare match interrupt
 * \param tc Base address of the TC module
 */
void tc_init()
{
80004e34:	d4 01       	pushm	lr

	volatile avr32_tc_t * tc = EXAMPLE_TC;
	
	INTC_register_interrupt(&_tc_interrupt, AVR32_TC_IRQ1, AVR32_INTC_INT2);
80004e36:	30 2a       	mov	r10,2
80004e38:	e0 6b 01 c1 	mov	r11,449
80004e3c:	48 ec       	lddpc	r12,80004e74 <tc_init+0x40>
80004e3e:	f0 1f 00 0f 	mcall	80004e78 <tc_init+0x44>
		.cpas  = 0,
		.lovrs = 0,
		.covfs = 0
	};
	// Initialize the timer/counter.
	tc_init_waveform(tc, &waveform_opt);
80004e42:	48 fb       	lddpc	r11,80004e7c <tc_init+0x48>
80004e44:	fe 7c 38 00 	mov	r12,-51200
80004e48:	f0 1f 00 0e 	mcall	80004e80 <tc_init+0x4c>
	 * We want: (1 / (fPBA / 8)) * RC = 10 ms, hence RC = (fPBA / 8) / 100
	 * to get an interrupt every 10 ms.
	 */
	//tc_write_rc(tc, EXAMPLE_TC_CHANNEL, (sysclk_get_pba_hz() / 8 / 100));
	
	tc_write_rc(tc, EXAMPLE_TC_CHANNEL, ((FOSC0*2) / 8 / 100));
80004e4c:	e0 6a 75 30 	mov	r10,30000
80004e50:	30 1b       	mov	r11,1
80004e52:	fe 7c 38 00 	mov	r12,-51200
80004e56:	f0 1f 00 0c 	mcall	80004e84 <tc_init+0x50>
	
	//tc_write_rc(tc, EXAMPLE_TC_CHANNEL, (FOSC0 / 8 / 100000));
	
	
	// configure the timer interrupt
	tc_configure_interrupts(tc, EXAMPLE_TC_CHANNEL, &tc_interrupt);
80004e5a:	48 ca       	lddpc	r10,80004e88 <tc_init+0x54>
80004e5c:	30 1b       	mov	r11,1
80004e5e:	fe 7c 38 00 	mov	r12,-51200
80004e62:	f0 1f 00 0b 	mcall	80004e8c <tc_init+0x58>
	// Start the timer/counter.
	tc_start(tc, EXAMPLE_TC_CHANNEL);
80004e66:	30 1b       	mov	r11,1
80004e68:	fe 7c 38 00 	mov	r12,-51200
80004e6c:	f0 1f 00 09 	mcall	80004e90 <tc_init+0x5c>
80004e70:	d8 02       	popm	pc
80004e72:	00 00       	add	r0,r0
80004e74:	80 00       	ld.sh	r0,r0[0x0]
80004e76:	4e 94       	lddpc	r4,80005018 <voc_save_info+0x68>
80004e78:	80 00       	ld.sh	r0,r0[0x0]
80004e7a:	54 1c       	stdsp	sp[0x104],r12
80004e7c:	80 00       	ld.sh	r0,r0[0x0]
80004e7e:	db dc       	*unknown*
80004e80:	80 00       	ld.sh	r0,r0[0x0]
80004e82:	57 02       	stdsp	sp[0x1c0],r2
80004e84:	80 00       	ld.sh	r0,r0[0x0]
80004e86:	57 c2       	stdsp	sp[0x1f0],r2
80004e88:	80 00       	ld.sh	r0,r0[0x0]
80004e8a:	db d8       	*unknown*
80004e8c:	80 00       	ld.sh	r0,r0[0x0]
80004e8e:	57 f6       	stdsp	sp[0x1fc],r6
80004e90:	80 00       	ld.sh	r0,r0[0x0]
80004e92:	57 9e       	stdsp	sp[0x1e4],lr

80004e94 <_tc_interrupt>:
volatile U32 tc_tick = 0;

//brief Default interrupt handler.
__attribute__((__interrupt__))
static void _tc_interrupt(void)
 {
80004e94:	d4 01       	pushm	lr
	// Increment the 10ms seconds counter
	tc_tick++;
80004e96:	48 68       	lddpc	r8,80004eac <_tc_interrupt+0x18>
80004e98:	70 09       	ld.w	r9,r8[0x0]
80004e9a:	2f f9       	sub	r9,-1
80004e9c:	91 09       	st.w	r8[0x0],r9
	/*
	 * TODO: Place a breakpoint here and watch the update of tc_tick variable
	 * in the Watch Window.
	 */
	// Clear the interrupt flag. This is a side effect of reading the TC SR.
	tc_read_sr(EXAMPLE_TC, EXAMPLE_TC_CHANNEL);
80004e9e:	30 1b       	mov	r11,1
80004ea0:	fe 7c 38 00 	mov	r12,-51200
80004ea4:	f0 1f 00 03 	mcall	80004eb0 <_tc_interrupt+0x1c>
	
}
80004ea8:	d4 02       	popm	lr
80004eaa:	d6 03       	rete
80004eac:	00 00       	add	r0,r0
80004eae:	0b 58       	ld.sh	r8,--r5
80004eb0:	80 00       	ld.sh	r0,r0[0x0]
80004eb2:	57 b0       	stdsp	sp[0x1ec],r0

80004eb4 <playback_voice_data>:
* 20-Fri-17   Edwards    none        Initial draft
*
*******************************************************************************/
U8 PLAYBACK_BUF[512];
Bool playback_voice_data(U32 voice_index)
{
80004eb4:	d4 31       	pushm	r0-r7,lr
80004eb6:	21 2d       	sub	sp,72
80004eb8:	18 97       	mov	r7,r12
	if(!list_init_success_flag)return FALSE;
80004eba:	4b 98       	lddpc	r8,80004f9c <playback_voice_data+0xe8>
80004ebc:	11 89       	ld.ub	r9,r8[0x0]
80004ebe:	30 08       	mov	r8,0
80004ec0:	f0 09 18 00 	cp.b	r9,r8
80004ec4:	c6 40       	breq	80004f8c <playback_voice_data+0xd8>
	
	/* check input parameter */
	if (voice_index > current_voice_index)
80004ec6:	4b 78       	lddpc	r8,80004fa0 <playback_voice_data+0xec>
80004ec8:	90 88       	ld.uh	r8,r8[0x0]
80004eca:	18 38       	cp.w	r8,r12
80004ecc:	c6 23       	brcs	80004f90 <playback_voice_data+0xdc>
		return -1;
	}
	df_status_t return_code = DF_OK;
	unsigned int address =0x00000000;
	char str[VOICE_INFO_LENGTH];
	memset(str, 0x00, sizeof(str));
80004ece:	1a 9a       	mov	r10,sp
80004ed0:	30 08       	mov	r8,0
80004ed2:	30 09       	mov	r9,0
80004ed4:	fa e9 00 00 	st.d	sp[0],r8
80004ed8:	fa e9 00 08 	st.d	sp[8],r8
80004edc:	fa e9 00 10 	st.d	sp[16],r8
80004ee0:	fa e9 00 18 	st.d	sp[24],r8
80004ee4:	fa e9 00 20 	st.d	sp[32],r8
80004ee8:	fa e9 00 28 	st.d	sp[40],r8
80004eec:	fa e9 00 30 	st.d	sp[48],r8
80004ef0:	fa e9 00 38 	st.d	sp[56],r8
80004ef4:	fa e9 00 40 	st.d	sp[64],r8
	//find the voice storage info by voice_index
	address = START_ADDRESS_OF_VOICE_INFO + ((voice_index -1)*VOICE_INFO_LENGTH);
	return_code = data_flash_read_block(address, VOICE_INFO_LENGTH, (U8 *)str);
80004ef8:	f8 0c 00 3c 	add	r12,r12,r12<<0x3
80004efc:	a3 7c       	lsl	r12,0x3
80004efe:	34 8b       	mov	r11,72
80004f00:	23 8c       	sub	r12,56
80004f02:	f0 1f 00 29 	mcall	80004fa4 <playback_voice_data+0xf0>
	if (return_code == DF_OK)
80004f06:	c4 51       	brne	80004f90 <playback_voice_data+0xdc>
	{
		U16 bytes_remained;
		VoiceList_Info_t *ptr = (VoiceList_Info_t *)str;
		if(ptr->numb == voice_index)
80004f08:	9a 88       	ld.uh	r8,sp[0x0]
80004f0a:	0e 38       	cp.w	r8,r7
80004f0c:	c4 21       	brne	80004f90 <playback_voice_data+0xdc>
		{
			bytes_remained = ptr->offset;
80004f0e:	41 18       	lddsp	r8,sp[0x44]
80004f10:	ef d8 b0 10 	bfexts	r7,r8,0x0,0x10
			address = ptr->address;
80004f14:	fb 16 00 42 	ld.uh	r6,sp[66]
80004f18:	b1 88       	lsr	r8,0x10
80004f1a:	f1 e6 11 06 	or	r6,r8,r6<<0x10
			
			while (bytes_remained >= 1 && return_code == DF_OK)
80004f1e:	58 07       	cp.w	r7,0
80004f20:	c3 b0       	breq	80004f96 <playback_voice_data+0xe2>
			{
				if(bytes_remained < DF_DATA_SPACE_SIZE)//< 512bytes
80004f22:	e0 65 01 ff 	mov	r5,511
					bytes_remained = 0;	/* end while loop */

				}
				else//bytes_remained > DF_DATA_SPACE_SIZE
				{
					return_code = data_flash_read_block(address, DF_DATA_SPACE_SIZE, PLAYBACK_BUF);
80004f26:	4a 13       	lddpc	r3,80004fa8 <playback_voice_data+0xf4>
80004f28:	e0 62 02 00 	mov	r2,512
		if(ptr->numb == voice_index)
		{
			bytes_remained = ptr->offset;
			address = ptr->address;
			
			while (bytes_remained >= 1 && return_code == DF_OK)
80004f2c:	30 04       	mov	r4,0
80004f2e:	08 91       	mov	r1,r4
			{
				if(bytes_remained < DF_DATA_SPACE_SIZE)//< 512bytes
80004f30:	ea 07 19 00 	cp.h	r7,r5
80004f34:	e0 8b 00 11 	brhi	80004f56 <playback_voice_data+0xa2>
				{
					return_code = data_flash_read_block(address, bytes_remained, PLAYBACK_BUF);
80004f38:	49 c5       	lddpc	r5,80004fa8 <playback_voice_data+0xf4>
80004f3a:	0a 9a       	mov	r10,r5
80004f3c:	0e 9b       	mov	r11,r7
80004f3e:	5c 7b       	castu.h	r11
80004f40:	0c 9c       	mov	r12,r6
80004f42:	f0 1f 00 19 	mcall	80004fa4 <playback_voice_data+0xf0>
					return_code = data_flash_read_block(address, DF_DATA_SPACE_SIZE, PLAYBACK_BUF);
					bytes_remained-=DF_DATA_SPACE_SIZE;
					address+=DF_DATA_SPACE_SIZE;
					
				}
				memset(PLAYBACK_BUF, 0x00, DF_DATA_SPACE_SIZE);
80004f46:	e0 6a 02 00 	mov	r10,512
80004f4a:	30 0b       	mov	r11,0
80004f4c:	0a 9c       	mov	r12,r5
80004f4e:	f0 1f 00 18 	mcall	80004fac <playback_voice_data+0xf8>
80004f52:	30 1c       	mov	r12,1
80004f54:	c2 28       	rjmp	80004f98 <playback_voice_data+0xe4>
					bytes_remained = 0;	/* end while loop */

				}
				else//bytes_remained > DF_DATA_SPACE_SIZE
				{
					return_code = data_flash_read_block(address, DF_DATA_SPACE_SIZE, PLAYBACK_BUF);
80004f56:	06 9a       	mov	r10,r3
80004f58:	04 9b       	mov	r11,r2
80004f5a:	0c 9c       	mov	r12,r6
80004f5c:	f0 1f 00 12 	mcall	80004fa4 <playback_voice_data+0xf0>
80004f60:	18 90       	mov	r0,r12
					bytes_remained-=DF_DATA_SPACE_SIZE;
80004f62:	ee c7 02 00 	sub	r7,r7,512
80004f66:	5c 87       	casts.h	r7
					address+=DF_DATA_SPACE_SIZE;
					
				}
				memset(PLAYBACK_BUF, 0x00, DF_DATA_SPACE_SIZE);
80004f68:	04 9a       	mov	r10,r2
80004f6a:	30 0b       	mov	r11,0
80004f6c:	06 9c       	mov	r12,r3
80004f6e:	f0 1f 00 10 	mcall	80004fac <playback_voice_data+0xf8>
		if(ptr->numb == voice_index)
		{
			bytes_remained = ptr->offset;
			address = ptr->address;
			
			while (bytes_remained >= 1 && return_code == DF_OK)
80004f72:	e8 07 19 00 	cp.h	r7,r4
80004f76:	5f 19       	srne	r9
80004f78:	58 00       	cp.w	r0,0
80004f7a:	5f 08       	sreq	r8
80004f7c:	f3 e8 00 08 	and	r8,r9,r8
80004f80:	e2 08 18 00 	cp.b	r8,r1
80004f84:	c0 90       	breq	80004f96 <playback_voice_data+0xe2>
				}
				else//bytes_remained > DF_DATA_SPACE_SIZE
				{
					return_code = data_flash_read_block(address, DF_DATA_SPACE_SIZE, PLAYBACK_BUF);
					bytes_remained-=DF_DATA_SPACE_SIZE;
					address+=DF_DATA_SPACE_SIZE;
80004f86:	ec c6 fe 00 	sub	r6,r6,-512
80004f8a:	cd 3b       	rjmp	80004f30 <playback_voice_data+0x7c>
80004f8c:	30 0c       	mov	r12,0
80004f8e:	c0 58       	rjmp	80004f98 <playback_voice_data+0xe4>
80004f90:	e0 6c 00 ff 	mov	r12,255
80004f94:	c0 28       	rjmp	80004f98 <playback_voice_data+0xe4>
80004f96:	30 1c       	mov	r12,1
		}
	}
	
	return -1;
	
}
80004f98:	2e ed       	sub	sp,-72
80004f9a:	d8 32       	popm	r0-r7,pc
80004f9c:	00 00       	add	r0,r0
80004f9e:	0b 5e       	ld.sh	lr,--r5
80004fa0:	00 00       	add	r0,r0
80004fa2:	0b 5c       	ld.sh	r12,--r5
80004fa4:	80 00       	ld.sh	r0,r0[0x0]
80004fa6:	2a a4       	sub	r4,-86
80004fa8:	00 00       	add	r0,r0
80004faa:	61 04       	ld.w	r4,r0[0x40]
80004fac:	80 00       	ld.sh	r0,r0[0x0]
80004fae:	78 82       	ld.w	r2,r12[0x20]

80004fb0 <voc_save_info>:
	return TRUE;

}

Bool voc_save_info(VoiceList_Info_t * voice)
{
80004fb0:	d4 01       	pushm	lr
	df_status_t return_code = DF_WRITE_COMPLETED;
	
	//if(voice_end_flag == TRUE)//save a voice-info into list at the end of the recording
	{
		//current_voice_index++;
		voice->numb		= current_voice_index;
80004fb2:	49 d9       	lddpc	r9,80005024 <voc_save_info+0x74>
80004fb4:	13 88       	ld.ub	r8,r9[0x0]
80004fb6:	b8 88       	st.b	r12[0x0],r8
80004fb8:	13 98       	ld.ub	r8,r9[0x1]
80004fba:	b8 98       	st.b	r12[0x1],r8
		voice->address	= (current_save_voice_offset - current_bytes_remained);
80004fbc:	49 b8       	lddpc	r8,80005028 <voc_save_info+0x78>
80004fbe:	70 0a       	ld.w	r10,r8[0x0]
80004fc0:	49 b8       	lddpc	r8,8000502c <voc_save_info+0x7c>
80004fc2:	70 08       	ld.w	r8,r8[0x0]
80004fc4:	14 18       	sub	r8,r10
80004fc6:	f0 0b 16 18 	lsr	r11,r8,0x18
80004fca:	f9 6b 00 42 	st.b	r12[66],r11
80004fce:	f0 0b 16 10 	lsr	r11,r8,0x10
80004fd2:	f9 6b 00 43 	st.b	r12[67],r11
80004fd6:	f0 0b 16 08 	lsr	r11,r8,0x8
80004fda:	f9 6b 00 44 	st.b	r12[68],r11
80004fde:	f9 68 00 45 	st.b	r12[69],r8
		voice->offset		= current_bytes_remained;
80004fe2:	f1 da c0 10 	bfextu	r8,r10,0x0,0x10
80004fe6:	f0 0a 16 08 	lsr	r10,r8,0x8
80004fea:	f9 6a 00 46 	st.b	r12[70],r10
80004fee:	f9 68 00 47 	st.b	r12[71],r8
		
		address = START_ADDRESS_OF_VOICE_INFO + ((current_voice_index -1)*VOICE_INFO_LENGTH);
80004ff2:	92 8b       	ld.uh	r11,r9[0x0]
80004ff4:	20 1b       	sub	r11,1
80004ff6:	f6 0b 00 3b 	add	r11,r11,r11<<0x3
80004ffa:	a3 7b       	lsl	r11,0x3
80004ffc:	2f 0b       	sub	r11,-16
		if(address > VOICE_LIST_BOUNDARY)//The number of messages is out of bounds
80004ffe:	e8 4b 00 00 	cp.w	r11,524288
80005002:	e0 8b 00 10 	brhi	80005022 <voc_save_info+0x72>
		{
			return FALSE;
			log("\r\n----info list is Out of bounds!!!\r\n----");
		}
		//set a voice info by current_voice_index
		return_code = data_flash_write((U8 *)voice, address, VOICE_INFO_LENGTH);
80005006:	34 8a       	mov	r10,72
80005008:	f0 1f 00 0a 	mcall	80005030 <voc_save_info+0x80>
		//set voice numbers
		return_code = data_flash_write(&current_voice_index, VOICE_NUMBERS_ADDRESS, VOICE_NUMBERS_LENGTH);
8000500c:	30 2a       	mov	r10,2
8000500e:	30 ab       	mov	r11,10
80005010:	48 5c       	lddpc	r12,80005024 <voc_save_info+0x74>
80005012:	f0 1f 00 08 	mcall	80005030 <voc_save_info+0x80>
		if(return_code != DF_WRITE_COMPLETED)
80005016:	58 7c       	cp.w	r12,7
80005018:	c0 51       	brne	80005022 <voc_save_info+0x72>
		{
			return FALSE;
		}
		
		current_bytes_remained = 0;//reset 0
8000501a:	30 09       	mov	r9,0
8000501c:	48 38       	lddpc	r8,80005028 <voc_save_info+0x78>
8000501e:	91 09       	st.w	r8[0x0],r9
80005020:	da 0a       	popm	pc,r12=1
	}
	
	return TRUE;
80005022:	d8 0a       	popm	pc,r12=0
80005024:	00 00       	add	r0,r0
80005026:	0b 5c       	ld.sh	r12,--r5
80005028:	00 00       	add	r0,r0
8000502a:	0b 60       	ld.uh	r0,--r5
8000502c:	00 00       	add	r0,r0
8000502e:	05 30       	ld.ub	r0,r2++
80005030:	80 00       	ld.sh	r0,r0[0x0]
80005032:	2c d4       	sub	r4,-51

80005034 <voc_save_data>:
*
*******************************************************************************/
static U32 current_bytes_remained = 0;

Bool voc_save_data(void *data_ptr, U16 data_len, U8 voice_end_flag)
{
80005034:	eb cd 40 c0 	pushm	r6-r7,lr
80005038:	14 96       	mov	r6,r10
	if(!list_init_success_flag)return FALSE;
8000503a:	49 f8       	lddpc	r8,800050b4 <voc_save_data+0x80>
8000503c:	11 89       	ld.ub	r9,r8[0x0]
8000503e:	30 08       	mov	r8,0
80005040:	f0 09 18 00 	cp.b	r9,r8
80005044:	c3 50       	breq	800050ae <voc_save_data+0x7a>
	
	U32 address = 0;
	//static U32 bytes_remained = 0;
	df_status_t return_code = DF_WRITE_COMPLETED;
	
	current_bytes_remained+=data_len;//accumulate
80005046:	ef db c0 10 	bfextu	r7,r11,0x0,0x10
8000504a:	49 c8       	lddpc	r8,800050b8 <voc_save_data+0x84>
8000504c:	70 09       	ld.w	r9,r8[0x0]
8000504e:	ee 09 00 09 	add	r9,r7,r9
80005052:	91 09       	st.w	r8[0x0],r9
	/* check input parameter */
	if (data_ptr == NULL || data_len > 0x1000)
80005054:	58 0c       	cp.w	r12,0
80005056:	5f 0a       	sreq	r10
80005058:	e0 68 10 00 	mov	r8,4096
8000505c:	f0 0b 19 00 	cp.h	r11,r8
80005060:	5f b8       	srhi	r8
80005062:	f5 e8 10 08 	or	r8,r10,r8
80005066:	c2 41       	brne	800050ae <voc_save_data+0x7a>
	{
		return FALSE;
	}
	if(current_bytes_remained > 0xFFFF)//data size > 65535bytes == 64k,overout
80005068:	e0 49 ff ff 	cp.w	r9,65535
8000506c:	e0 8b 00 21 	brhi	800050ae <voc_save_data+0x7a>
	{
		//current_bytes_remained = 0;
		return FALSE;
	}
	//save data
	if(current_save_voice_offset > DF_MAX_ADDR)//The voice data is out of bounds
80005070:	49 38       	lddpc	r8,800050bc <voc_save_data+0x88>
80005072:	70 08       	ld.w	r8,r8[0x0]
80005074:	e0 69 ff ff 	mov	r9,65535
80005078:	ea 19 00 7f 	orh	r9,0x7f
8000507c:	12 38       	cp.w	r8,r9
8000507e:	e0 8b 00 18 	brhi	800050ae <voc_save_data+0x7a>
	{
		return FALSE;
		log("\r\n----voice data is Out of bounds!!!\r\n----");
	}
	return_code = data_flash_write((U8 *)data_ptr, current_save_voice_offset, data_len);
80005082:	0e 9a       	mov	r10,r7
80005084:	10 9b       	mov	r11,r8
80005086:	f0 1f 00 0f 	mcall	800050c0 <voc_save_data+0x8c>
	if(return_code != DF_WRITE_COMPLETED)
8000508a:	58 7c       	cp.w	r12,7
8000508c:	c1 11       	brne	800050ae <voc_save_data+0x7a>
	{
		return FALSE;
	}
	current_save_voice_offset+=data_len;
8000508e:	48 c8       	lddpc	r8,800050bc <voc_save_data+0x88>
80005090:	70 09       	ld.w	r9,r8[0x0]
80005092:	12 07       	add	r7,r9
80005094:	91 07       	st.w	r8[0x0],r7
	
	
	//VoiceList_Info_t *ptr = malloc(sizeof(VoiceList_Info_t));
	//if(ptr ==NULL)return FALSE;
	
	if(voice_end_flag == TRUE)//save a voice-info into list at the end of the recording
80005096:	30 18       	mov	r8,1
80005098:	f0 06 18 00 	cp.b	r6,r8
8000509c:	c0 30       	breq	800050a2 <voc_save_data+0x6e>
8000509e:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
	{
		current_voice_index++;
800050a2:	48 98       	lddpc	r8,800050c4 <voc_save_data+0x90>
800050a4:	90 09       	ld.sh	r9,r8[0x0]
800050a6:	2f f9       	sub	r9,-1
800050a8:	b0 09       	st.h	r8[0x0],r9
800050aa:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
800050ae:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
800050b2:	00 00       	add	r0,r0
800050b4:	00 00       	add	r0,r0
800050b6:	0b 5e       	ld.sh	lr,--r5
800050b8:	00 00       	add	r0,r0
800050ba:	0b 60       	ld.uh	r0,--r5
800050bc:	00 00       	add	r0,r0
800050be:	05 30       	ld.ub	r0,r2++
800050c0:	80 00       	ld.sh	r0,r0[0x0]
800050c2:	2c d4       	sub	r4,-51
800050c4:	00 00       	add	r0,r0
800050c6:	0b 5c       	ld.sh	r12,--r5

800050c8 <voc_read_info>:

}


Bool voc_read_info( unsigned int voice_index,  VoiceList_Info_t * voice)
{
800050c8:	eb cd 40 c0 	pushm	r6-r7,lr
800050cc:	21 2d       	sub	sp,72
800050ce:	18 97       	mov	r7,r12
800050d0:	16 96       	mov	r6,r11
	if(!list_init_success_flag)return FALSE;
800050d2:	49 d8       	lddpc	r8,80005144 <voc_read_info+0x7c>
800050d4:	11 89       	ld.ub	r9,r8[0x0]
800050d6:	30 08       	mov	r8,0
800050d8:	f0 09 18 00 	cp.b	r9,r8
800050dc:	c2 f0       	breq	8000513a <voc_read_info+0x72>
		
	/* check input parameter */
	if (voice_index > current_voice_index)
800050de:	49 b8       	lddpc	r8,80005148 <voc_read_info+0x80>
800050e0:	90 88       	ld.uh	r8,r8[0x0]
800050e2:	18 38       	cp.w	r8,r12
800050e4:	c0 42       	brcc	800050ec <voc_read_info+0x24>
800050e6:	e0 6c 00 ff 	mov	r12,255
800050ea:	c2 98       	rjmp	8000513c <voc_read_info+0x74>
		return -1;
	}
	
	df_status_t return_code = DF_OK;
	char str[VOICE_INFO_LENGTH];
	memset(str, 0x00, sizeof(str));
800050ec:	1a 9a       	mov	r10,sp
800050ee:	30 08       	mov	r8,0
800050f0:	30 09       	mov	r9,0
800050f2:	fa e9 00 00 	st.d	sp[0],r8
800050f6:	fa e9 00 08 	st.d	sp[8],r8
800050fa:	fa e9 00 10 	st.d	sp[16],r8
800050fe:	fa e9 00 18 	st.d	sp[24],r8
80005102:	fa e9 00 20 	st.d	sp[32],r8
80005106:	fa e9 00 28 	st.d	sp[40],r8
8000510a:	fa e9 00 30 	st.d	sp[48],r8
8000510e:	fa e9 00 38 	st.d	sp[56],r8
80005112:	fa e9 00 40 	st.d	sp[64],r8
	unsigned int address =0x00000000;
	//find the voice storage info by voice_index
	address = START_ADDRESS_OF_VOICE_INFO + ((voice_index -1)*VOICE_INFO_LENGTH);
	return_code = data_flash_read_block(address, VOICE_INFO_LENGTH, (U8 *)str);
80005116:	f8 0c 00 3c 	add	r12,r12,r12<<0x3
8000511a:	a3 7c       	lsl	r12,0x3
8000511c:	34 8b       	mov	r11,72
8000511e:	23 8c       	sub	r12,56
80005120:	f0 1f 00 0b 	mcall	8000514c <voc_read_info+0x84>
	if (return_code == DF_OK)
80005124:	c0 b1       	brne	8000513a <voc_read_info+0x72>
	{
		if(((VoiceList_Info_t *)str)->numb == voice_index)
80005126:	9a 88       	ld.uh	r8,sp[0x0]
80005128:	0e 38       	cp.w	r8,r7
8000512a:	c0 81       	brne	8000513a <voc_read_info+0x72>
		{
			memcpy(voice, str, sizeof(VoiceList_Info_t));
8000512c:	34 8a       	mov	r10,72
8000512e:	1a 9b       	mov	r11,sp
80005130:	0c 9c       	mov	r12,r6
80005132:	f0 1f 00 08 	mcall	80005150 <voc_read_info+0x88>
80005136:	30 1c       	mov	r12,1
			return TRUE;
80005138:	c0 28       	rjmp	8000513c <voc_read_info+0x74>
8000513a:	30 0c       	mov	r12,0
			return FALSE;
	}
	else
		return FALSE;
	
}
8000513c:	2e ed       	sub	sp,-72
8000513e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005142:	00 00       	add	r0,r0
80005144:	00 00       	add	r0,r0
80005146:	0b 5e       	ld.sh	lr,--r5
80005148:	00 00       	add	r0,r0
8000514a:	0b 5c       	ld.sh	r12,--r5
8000514c:	80 00       	ld.sh	r0,r0[0x0]
8000514e:	2a a4       	sub	r4,-86
80005150:	80 00       	ld.sh	r0,r0[0x0]
80005152:	77 3a       	ld.w	r10,r11[0x4c]

80005154 <voc_read_write_test>:

VoiceList_Info_t voice_ptr;
VoiceList_Info_t voice_temp;

void voc_read_write_test(void)
{
80005154:	eb cd 40 c0 	pushm	r6-r7,lr
	U16 status = 0xff;
	
	/**save**/
	voc_save_data(AMBE_AudioData, 600, TRUE);
80005158:	4b 26       	lddpc	r6,80005220 <voc_read_write_test+0xcc>
8000515a:	30 1a       	mov	r10,1
8000515c:	e0 6b 02 58 	mov	r11,600
80005160:	0c 9c       	mov	r12,r6
80005162:	f0 1f 00 31 	mcall	80005224 <voc_read_write_test+0xd0>
	//save voice information
	voc_save_info(&voice_ptr);
80005166:	4b 17       	lddpc	r7,80005228 <voc_read_write_test+0xd4>
80005168:	0e 9c       	mov	r12,r7
8000516a:	f0 1f 00 31 	mcall	8000522c <voc_read_write_test+0xd8>
	
	voc_save_data(&AMBE_AudioData[600], 300, FALSE);
8000516e:	30 0a       	mov	r10,0
80005170:	e0 6b 01 2c 	mov	r11,300
80005174:	ec cc fd a8 	sub	r12,r6,-600
80005178:	f0 1f 00 2b 	mcall	80005224 <voc_read_write_test+0xd0>
	voc_save_data(&AMBE_AudioData[950], 500, TRUE);
8000517c:	30 1a       	mov	r10,1
8000517e:	e0 6b 01 f4 	mov	r11,500
80005182:	ec cc fc 4a 	sub	r12,r6,-950
80005186:	f0 1f 00 28 	mcall	80005224 <voc_read_write_test+0xd0>
	memset(&voice_ptr, 0x00, sizeof(voice_ptr));
8000518a:	34 8a       	mov	r10,72
8000518c:	30 0b       	mov	r11,0
8000518e:	0e 9c       	mov	r12,r7
80005190:	f0 1f 00 28 	mcall	80005230 <voc_read_write_test+0xdc>
	voice_ptr.Header.Header = 0xABCD5A5A;
80005194:	3a b8       	mov	r8,-85
80005196:	ae a8       	st.b	r7[0x2],r8
80005198:	3c d8       	mov	r8,-51
8000519a:	ae b8       	st.b	r7[0x3],r8
8000519c:	35 a8       	mov	r8,90
8000519e:	ae c8       	st.b	r7[0x4],r8
800051a0:	ae d8       	st.b	r7[0x5],r8
	//save voice information
	voc_save_info(&voice_ptr);
800051a2:	0e 9c       	mov	r12,r7
800051a4:	f0 1f 00 22 	mcall	8000522c <voc_read_write_test+0xd8>
	
	
	voc_save_data(AMBE_AudioData, 1024, TRUE);
800051a8:	30 1a       	mov	r10,1
800051aa:	e0 6b 04 00 	mov	r11,1024
800051ae:	0c 9c       	mov	r12,r6
800051b0:	f0 1f 00 1d 	mcall	80005224 <voc_read_write_test+0xd0>
	//save voice information
	voc_save_info(&voice_ptr);
800051b4:	0e 9c       	mov	r12,r7
800051b6:	f0 1f 00 1e 	mcall	8000522c <voc_read_write_test+0xd8>
	
	
	/**read**/
	status = voc_read_info(1, &voice_temp);
800051ba:	49 fb       	lddpc	r11,80005234 <voc_read_write_test+0xe0>
800051bc:	30 1c       	mov	r12,1
800051be:	f0 1f 00 1f 	mcall	80005238 <voc_read_write_test+0xe4>
	if(status ==TRUE){
800051c2:	30 18       	mov	r8,1
800051c4:	f0 0c 18 00 	cp.b	r12,r8
800051c8:	c0 91       	brne	800051da <voc_read_write_test+0x86>
		
		playback_voice_data(1);
800051ca:	30 1c       	mov	r12,1
800051cc:	f0 1f 00 1c 	mcall	8000523c <voc_read_write_test+0xe8>
		memset(&voice_temp, 0x00, sizeof(voice_temp));
800051d0:	34 8a       	mov	r10,72
800051d2:	30 0b       	mov	r11,0
800051d4:	49 8c       	lddpc	r12,80005234 <voc_read_write_test+0xe0>
800051d6:	f0 1f 00 17 	mcall	80005230 <voc_read_write_test+0xdc>
		
	}
	
	status = voc_read_info(3, &voice_temp);
800051da:	49 7b       	lddpc	r11,80005234 <voc_read_write_test+0xe0>
800051dc:	30 3c       	mov	r12,3
800051de:	f0 1f 00 17 	mcall	80005238 <voc_read_write_test+0xe4>
	if(status ==TRUE){
800051e2:	30 18       	mov	r8,1
800051e4:	f0 0c 18 00 	cp.b	r12,r8
800051e8:	c0 91       	brne	800051fa <voc_read_write_test+0xa6>
		
		playback_voice_data(3);
800051ea:	30 3c       	mov	r12,3
800051ec:	f0 1f 00 14 	mcall	8000523c <voc_read_write_test+0xe8>
		memset(&voice_temp, 0x00, sizeof(voice_temp));
800051f0:	34 8a       	mov	r10,72
800051f2:	30 0b       	mov	r11,0
800051f4:	49 0c       	lddpc	r12,80005234 <voc_read_write_test+0xe0>
800051f6:	f0 1f 00 0f 	mcall	80005230 <voc_read_write_test+0xdc>
		
	}
	
	status = voc_read_info(20, &voice_temp);
800051fa:	48 fb       	lddpc	r11,80005234 <voc_read_write_test+0xe0>
800051fc:	31 4c       	mov	r12,20
800051fe:	f0 1f 00 0f 	mcall	80005238 <voc_read_write_test+0xe4>
	if(status ==TRUE){
80005202:	30 18       	mov	r8,1
80005204:	f0 0c 18 00 	cp.b	r12,r8
80005208:	c0 91       	brne	8000521a <voc_read_write_test+0xc6>
			
		playback_voice_data(20);
8000520a:	31 4c       	mov	r12,20
8000520c:	f0 1f 00 0c 	mcall	8000523c <voc_read_write_test+0xe8>
		memset(&voice_temp, 0x00, sizeof(voice_temp));
80005210:	34 8a       	mov	r10,72
80005212:	30 0b       	mov	r11,0
80005214:	48 8c       	lddpc	r12,80005234 <voc_read_write_test+0xe0>
80005216:	f0 1f 00 07 	mcall	80005230 <voc_read_write_test+0xdc>
8000521a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000521e:	00 00       	add	r0,r0
80005220:	80 00       	ld.sh	r0,r0[0x0]
80005222:	d5 a8       	*unknown*
80005224:	80 00       	ld.sh	r0,r0[0x0]
80005226:	50 34       	stdsp	sp[0xc],r4
80005228:	00 00       	add	r0,r0
8000522a:	63 04       	ld.w	r4,r1[0x40]
8000522c:	80 00       	ld.sh	r0,r0[0x0]
8000522e:	4f b0       	lddpc	r0,80005418 <_unhandled_interrupt>
80005230:	80 00       	ld.sh	r0,r0[0x0]
80005232:	78 82       	ld.w	r2,r12[0x20]
80005234:	00 00       	add	r0,r0
80005236:	63 4c       	ld.w	r12,r1[0x50]
80005238:	80 00       	ld.sh	r0,r0[0x0]
8000523a:	50 c8       	stdsp	sp[0x30],r8
8000523c:	80 00       	ld.sh	r0,r0[0x0]
8000523e:	4e b4       	lddpc	r4,800053e8 <voc_init+0x1a8>

80005240 <voc_init>:
	
}

U8 Current_total_voice[2] = {0};
void voc_init(void)
{
80005240:	d4 31       	pushm	r0-r7,lr
80005242:	21 4d       	sub	sp,80
	data_flash_init();
80005244:	f0 1f 00 64 	mcall	800053d4 <voc_init+0x194>
{
	df_status_t return_code = DF_OK;
	unsigned int i = 0;
	unsigned int address =0x00000000;
	char str[80];
	memset(str, 0x00, sizeof(str));
80005248:	30 08       	mov	r8,0
8000524a:	30 09       	mov	r9,0
8000524c:	fa e9 00 00 	st.d	sp[0],r8
80005250:	fa e9 00 08 	st.d	sp[8],r8
80005254:	fa e9 00 10 	st.d	sp[16],r8
80005258:	fa e9 00 18 	st.d	sp[24],r8
8000525c:	fa e9 00 20 	st.d	sp[32],r8
80005260:	fa e9 00 28 	st.d	sp[40],r8
80005264:	fa e9 00 30 	st.d	sp[48],r8
80005268:	fa e9 00 38 	st.d	sp[56],r8
8000526c:	fa e9 00 40 	st.d	sp[64],r8
80005270:	fa e9 00 48 	st.d	sp[72],r8
80005274:	30 05       	mov	r5,0
	
	start:

	/* bytes remained less than one page */
	return_code = data_flash_read_block(LABEL_ADDRESS, LABEL_LENGTH, str);
80005276:	1a 97       	mov	r7,sp
80005278:	30 73       	mov	r3,7
8000527a:	0a 94       	mov	r4,r5
	if(return_code == DF_OK)
	{
		if(memcmp(FlashLabel, str, sizeof(FlashLabel)-1) != 0)//compare label
8000527c:	4d 72       	lddpc	r2,800053d8 <voc_init+0x198>
			log("\r\n----create voice info锛 okay!----\r\n");
		}
		else//success
		{
			//Get the current voice index
			return_code = data_flash_read_block(VOICE_NUMBERS_ADDRESS, VOICE_NUMBERS_LENGTH, &current_voice_index);
8000527e:	4d 86       	lddpc	r6,800053dc <voc_init+0x19c>
80005280:	30 21       	mov	r1,2
80005282:	30 a0       	mov	r0,10
	memset(str, 0x00, sizeof(str));
	
	start:

	/* bytes remained less than one page */
	return_code = data_flash_read_block(LABEL_ADDRESS, LABEL_LENGTH, str);
80005284:	1a 9a       	mov	r10,sp
80005286:	06 9b       	mov	r11,r3
80005288:	08 9c       	mov	r12,r4
8000528a:	f0 1f 00 56 	mcall	800053e0 <voc_init+0x1a0>
	if(return_code == DF_OK)
8000528e:	e0 81 00 9f 	brne	800053cc <voc_init+0x18c>
	{
		if(memcmp(FlashLabel, str, sizeof(FlashLabel)-1) != 0)//compare label
80005292:	06 9a       	mov	r10,r3
80005294:	1a 9b       	mov	r11,sp
80005296:	04 9c       	mov	r12,r2
80005298:	f0 1f 00 53 	mcall	800053e4 <voc_init+0x1a4>
8000529c:	c3 60       	breq	80005308 <voc_init+0xc8>
8000529e:	c8 78       	rjmp	800053ac <voc_init+0x16c>
				return_code = data_flash_erase_block(address, DF_BLOCK_64KB);
				if(return_code != DF_ERASE_COMPLETED)
				{
					return FALSE;
				}
				address+=65536;//64k*1024=65536bytes
800052a0:	fe 35 00 00 	sub	r5,-65536
		{
			ERASE:
			//erase
			for(i; i < (VOICE_LIST_BOUNDARY/(64*1024)); i++)//8*64k
			{
				return_code = data_flash_erase_block(address, DF_BLOCK_64KB);
800052a4:	0e 9b       	mov	r11,r7
800052a6:	0a 9c       	mov	r12,r5
800052a8:	f0 1f 00 50 	mcall	800053e8 <voc_init+0x1a8>
				if(return_code != DF_ERASE_COMPLETED)
800052ac:	58 5c       	cp.w	r12,5
800052ae:	e0 81 00 8f 	brne	800053cc <voc_init+0x18c>
	{
		if(memcmp(FlashLabel, str, sizeof(FlashLabel)-1) != 0)//compare label
		{
			ERASE:
			//erase
			for(i; i < (VOICE_LIST_BOUNDARY/(64*1024)); i++)//8*64k
800052b2:	0c 35       	cp.w	r5,r6
800052b4:	cf 61       	brne	800052a0 <voc_init+0x60>
					return FALSE;
				}
				address+=65536;//64k*1024=65536bytes
			}
			//set label
			return_code = data_flash_write(FlashLabel, LABEL_ADDRESS, LABEL_LENGTH);
800052b6:	30 7a       	mov	r10,7
800052b8:	30 0b       	mov	r11,0
800052ba:	4c 8c       	lddpc	r12,800053d8 <voc_init+0x198>
800052bc:	f0 1f 00 4c 	mcall	800053ec <voc_init+0x1ac>
			//set current_voice_index
			memset(str, 0x00, sizeof(str));
800052c0:	1a 9c       	mov	r12,sp
800052c2:	30 08       	mov	r8,0
800052c4:	30 09       	mov	r9,0
800052c6:	fa e9 00 00 	st.d	sp[0],r8
800052ca:	fa e9 00 08 	st.d	sp[8],r8
800052ce:	fa e9 00 10 	st.d	sp[16],r8
800052d2:	fa e9 00 18 	st.d	sp[24],r8
800052d6:	fa e9 00 20 	st.d	sp[32],r8
800052da:	fa e9 00 28 	st.d	sp[40],r8
800052de:	fa e9 00 30 	st.d	sp[48],r8
800052e2:	fa e9 00 38 	st.d	sp[56],r8
800052e6:	fa e9 00 40 	st.d	sp[64],r8
800052ea:	fa e9 00 48 	st.d	sp[72],r8
			return_code = data_flash_write(str, VOICE_NUMBERS_ADDRESS, VOICE_NUMBERS_LENGTH);
800052ee:	30 2a       	mov	r10,2
800052f0:	30 ab       	mov	r11,10
800052f2:	f0 1f 00 3f 	mcall	800053ec <voc_init+0x1ac>
			if(return_code != DF_WRITE_COMPLETED)
800052f6:	58 7c       	cp.w	r12,7
800052f8:	c6 a1       	brne	800053cc <voc_init+0x18c>
			{
				return FALSE;
			}
			current_voice_index = 0;
800052fa:	30 09       	mov	r9,0
800052fc:	4b 88       	lddpc	r8,800053dc <voc_init+0x19c>
800052fe:	b0 09       	st.h	r8[0x0],r9
			log("\r\n----create voice info锛 okay!----\r\n");
80005300:	4b cc       	lddpc	r12,800053f0 <voc_init+0x1b0>
80005302:	f0 1f 00 3d 	mcall	800053f4 <voc_init+0x1b4>
80005306:	c5 c8       	rjmp	800053be <voc_init+0x17e>
		}
		else//success
		{
			//Get the current voice index
			return_code = data_flash_read_block(VOICE_NUMBERS_ADDRESS, VOICE_NUMBERS_LENGTH, &current_voice_index);
80005308:	0c 9a       	mov	r10,r6
8000530a:	02 9b       	mov	r11,r1
8000530c:	00 9c       	mov	r12,r0
8000530e:	f0 1f 00 35 	mcall	800053e0 <voc_init+0x1a0>
			if(return_code == DF_OK)
80005312:	c5 d1       	brne	800053cc <voc_init+0x18c>
			{
				//Calculates the offset address of the current stored voice
				if(current_voice_index != 0){
80005314:	8c 08       	ld.sh	r8,r6[0x0]
80005316:	58 08       	cp.w	r8,0
80005318:	c5 00       	breq	800053b8 <voc_init+0x178>
					
					address = START_ADDRESS_OF_VOICE_INFO + ((current_voice_index -1)*VOICE_INFO_LENGTH);
8000531a:	5c 78       	castu.h	r8
8000531c:	20 18       	sub	r8,1
8000531e:	f0 08 00 38 	add	r8,r8,r8<<0x3
80005322:	f0 05 15 03 	lsl	r5,r8,0x3
80005326:	2f 05       	sub	r5,-16
					return_code = data_flash_read_block(address, VOICE_INFO_LENGTH, (U8 *)str);
80005328:	1a 9a       	mov	r10,sp
8000532a:	34 8b       	mov	r11,72
8000532c:	0a 9c       	mov	r12,r5
8000532e:	f0 1f 00 2d 	mcall	800053e0 <voc_init+0x1a0>
					return_code = data_flash_read_block(LABEL_ADDRESS, 512, (U8 *)TEMP_BUF);
80005332:	4b 2a       	lddpc	r10,800053f8 <voc_init+0x1b8>
80005334:	e0 6b 02 00 	mov	r11,512
80005338:	08 9c       	mov	r12,r4
8000533a:	f0 1f 00 2a 	mcall	800053e0 <voc_init+0x1a0>
					if(return_code == DF_OK)
8000533e:	c3 d1       	brne	800053b8 <voc_init+0x178>
					{
						VoiceList_Info_t *ptr = (VoiceList_Info_t *)str;
						if(ptr->numb == current_voice_index)
80005340:	0f 89       	ld.ub	r9,r7[0x0]
80005342:	0f 98       	ld.ub	r8,r7[0x1]
80005344:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80005348:	8c 09       	ld.sh	r9,r6[0x0]
8000534a:	f0 09 19 00 	cp.h	r9,r8
8000534e:	c2 c1       	brne	800053a6 <voc_init+0x166>
						{
							current_save_voice_offset = ptr->address + ptr->offset;
80005350:	ef 39 00 46 	ld.ub	r9,r7[70]
80005354:	ef 38 00 47 	ld.ub	r8,r7[71]
80005358:	f1 e9 10 89 	or	r9,r8,r9<<0x8
8000535c:	ef 3a 00 42 	ld.ub	r10,r7[66]
80005360:	ef 38 00 43 	ld.ub	r8,r7[67]
80005364:	b1 68       	lsl	r8,0x10
80005366:	f1 ea 11 88 	or	r8,r8,r10<<0x18
8000536a:	ef 3a 00 44 	ld.ub	r10,r7[68]
8000536e:	f1 ea 10 88 	or	r8,r8,r10<<0x8
80005372:	ef 3a 00 45 	ld.ub	r10,r7[69]
80005376:	f5 e8 10 08 	or	r8,r10,r8
8000537a:	f2 08 00 08 	add	r8,r9,r8
8000537e:	4a 09       	lddpc	r9,800053fc <voc_init+0x1bc>
80005380:	93 08       	st.w	r9[0x0],r8
							if(current_save_voice_offset > 0x7bc000){
80005382:	e0 69 c0 00 	mov	r9,49152
80005386:	ea 19 00 7b 	orh	r9,0x7b
8000538a:	12 38       	cp.w	r8,r9
8000538c:	e0 88 00 16 	brls	800053b8 <voc_init+0x178>
								
								log("\r\n----voice storage is full!!!----\r\n");
80005390:	49 cc       	lddpc	r12,80005400 <voc_init+0x1c0>
80005392:	f0 1f 00 19 	mcall	800053f4 <voc_init+0x1b4>
								//chip erase
								return_code = data_flash_erase_block(0, DF_BLOCK_ALL);
80005396:	30 4b       	mov	r11,4
80005398:	08 9c       	mov	r12,r4
8000539a:	f0 1f 00 14 	mcall	800053e8 <voc_init+0x1a8>
								if(return_code == DF_ERASE_COMPLETED)goto start;
8000539e:	58 5c       	cp.w	r12,5
800053a0:	fe 90 ff 72 	breq	80005284 <voc_init+0x44>
800053a4:	c1 48       	rjmp	800053cc <voc_init+0x18c>
								return FALSE;
							}
						}
						else
						{
							log("\r\n----voice storage is err!!!----\r\n");
800053a6:	49 8c       	lddpc	r12,80005404 <voc_init+0x1c4>
800053a8:	f0 1f 00 13 	mcall	800053f4 <voc_init+0x1b4>
	
	
}

U8 Current_total_voice[2] = {0};
void voc_init(void)
800053ac:	e6 78 00 00 	mov	r8,458752
800053b0:	ea 08 00 06 	add	r6,r5,r8
		{
			ERASE:
			//erase
			for(i; i < (VOICE_LIST_BOUNDARY/(64*1024)); i++)//8*64k
			{
				return_code = data_flash_erase_block(address, DF_BLOCK_64KB);
800053b4:	30 37       	mov	r7,3
800053b6:	c7 7b       	rjmp	800052a4 <voc_init+0x64>
							goto ERASE;
							//return FALSE;
						}
					}
				}
				log("\r\n----read voice info锛 okay!----\r\n");
800053b8:	49 4c       	lddpc	r12,80005408 <voc_init+0x1c8>
800053ba:	f0 1f 00 0f 	mcall	800053f4 <voc_init+0x1b4>
			}
			else
			return FALSE;
		}
		
		memcpy(voice_count_ptr, &current_voice_index, sizeof(current_voice_index));
800053be:	48 88       	lddpc	r8,800053dc <voc_init+0x19c>
800053c0:	90 09       	ld.sh	r9,r8[0x0]
800053c2:	49 38       	lddpc	r8,8000540c <voc_init+0x1cc>
800053c4:	b0 09       	st.h	r8[0x0],r9
		list_init_success_flag = 1;
800053c6:	30 19       	mov	r9,1
800053c8:	49 28       	lddpc	r8,80005410 <voc_init+0x1d0>
800053ca:	b0 89       	st.b	r8[0x0],r9
	// then read address 0x00001002 every 5s and report to radio with failure
	//test_data_flash(FALSE);
	//create_data_flash_test_task();
	voice_list_info_init(Current_total_voice);
	
	voc_read_write_test();
800053cc:	f0 1f 00 12 	mcall	80005414 <voc_init+0x1d4>

800053d0:	2e cd       	sub	sp,-80
800053d2:	d8 32       	popm	r0-r7,pc
800053d4:	80 00       	ld.sh	r0,r0[0x0]
800053d6:	2d c4       	sub	r4,-36
800053d8:	00 00       	add	r0,r0
800053da:	05 28       	ld.uh	r8,r2++
800053dc:	00 00       	add	r0,r0
800053de:	0b 5c       	ld.sh	r12,--r5
800053e0:	80 00       	ld.sh	r0,r0[0x0]
800053e2:	2a a4       	sub	r4,-86
800053e4:	80 00       	ld.sh	r0,r0[0x0]
800053e6:	77 14       	ld.w	r4,r11[0x44]
800053e8:	80 00       	ld.sh	r0,r0[0x0]
800053ea:	2c 38       	sub	r8,-61
800053ec:	80 00       	ld.sh	r0,r0[0x0]
800053ee:	2c d4       	sub	r4,-51
800053f0:	80 00       	ld.sh	r0,r0[0x0]
800053f2:	db e4       	*unknown*
800053f4:	80 00       	ld.sh	r0,r0[0x0]
800053f6:	6d 80       	ld.w	r0,r6[0x60]
800053f8:	00 00       	add	r0,r0
800053fa:	51 04       	stdsp	sp[0x40],r4
800053fc:	00 00       	add	r0,r0
800053fe:	05 30       	ld.ub	r0,r2++
80005400:	80 00       	ld.sh	r0,r0[0x0]
80005402:	dc 0c       	*unknown*
80005404:	80 00       	ld.sh	r0,r0[0x0]
80005406:	dc 34       	*unknown*
80005408:	80 00       	ld.sh	r0,r0[0x0]
8000540a:	dc 58       	*unknown*
8000540c:	00 00       	add	r0,r0
8000540e:	0b 64       	ld.uh	r4,--r5
80005410:	00 00       	add	r0,r0
80005412:	0b 5e       	ld.sh	lr,--r5
80005414:	80 00       	ld.sh	r0,r0[0x0]
80005416:	51 54       	stdsp	sp[0x54],r4

80005418 <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
80005418:	c0 08       	rjmp	80005418 <_unhandled_interrupt>
8000541a:	d7 03       	nop

8000541c <INTC_register_interrupt>:
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
8000541c:	f6 08 16 05 	lsr	r8,r11,0x5

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
80005420:	49 99       	lddpc	r9,80005484 <INTC_register_interrupt+0x68>
80005422:	f2 08 00 39 	add	r9,r9,r8<<0x3
80005426:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
8000542a:	72 19       	ld.w	r9,r9[0x4]
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
8000542c:	f2 0b 09 2c 	st.w	r9[r11<<0x2],r12
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
80005430:	58 0a       	cp.w	r10,0
80005432:	c0 91       	brne	80005444 <INTC_register_interrupt+0x28>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80005434:	49 59       	lddpc	r9,80005488 <INTC_register_interrupt+0x6c>
80005436:	49 6a       	lddpc	r10,8000548c <INTC_register_interrupt+0x70>
80005438:	12 1a       	sub	r10,r9
8000543a:	fe 79 08 00 	mov	r9,-63488
8000543e:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80005442:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT1) {
80005444:	58 1a       	cp.w	r10,1
80005446:	c0 a1       	brne	8000545a <INTC_register_interrupt+0x3e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
80005448:	49 09       	lddpc	r9,80005488 <INTC_register_interrupt+0x6c>
8000544a:	49 2a       	lddpc	r10,80005490 <INTC_register_interrupt+0x74>
8000544c:	12 1a       	sub	r10,r9
8000544e:	bf aa       	sbr	r10,0x1e
80005450:	fe 79 08 00 	mov	r9,-63488
80005454:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80005458:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT2) {
8000545a:	58 2a       	cp.w	r10,2
8000545c:	c0 a1       	brne	80005470 <INTC_register_interrupt+0x54>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
8000545e:	48 b9       	lddpc	r9,80005488 <INTC_register_interrupt+0x6c>
80005460:	48 da       	lddpc	r10,80005494 <INTC_register_interrupt+0x78>
80005462:	12 1a       	sub	r10,r9
80005464:	bf ba       	sbr	r10,0x1f
80005466:	fe 79 08 00 	mov	r9,-63488
8000546a:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
8000546e:	5e fc       	retal	r12
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
80005470:	48 69       	lddpc	r9,80005488 <INTC_register_interrupt+0x6c>
80005472:	48 aa       	lddpc	r10,80005498 <INTC_register_interrupt+0x7c>
80005474:	12 1a       	sub	r10,r9
80005476:	ea 1a c0 00 	orh	r10,0xc000
8000547a:	fe 79 08 00 	mov	r9,-63488
8000547e:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80005482:	5e fc       	retal	r12
80005484:	80 00       	ld.sh	r0,r0[0x0]
80005486:	dc 80       	acall	0xc8
80005488:	80 00       	ld.sh	r0,r0[0x0]
8000548a:	cc 00       	breq	8000540a <voc_init+0x1ca>
8000548c:	80 00       	ld.sh	r0,r0[0x0]
8000548e:	cd 04       	brge	8000542e <INTC_register_interrupt+0x12>
80005490:	80 00       	ld.sh	r0,r0[0x0]
80005492:	cd 12       	brcc	80005434 <INTC_register_interrupt+0x18>
80005494:	80 00       	ld.sh	r0,r0[0x0]
80005496:	cd 20       	breq	8000543a <INTC_register_interrupt+0x1e>
80005498:	80 00       	ld.sh	r0,r0[0x0]
8000549a:	cd 2e       	rcall	8000523e <voc_read_write_test+0xea>

8000549c <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
8000549c:	d4 21       	pushm	r4-r7,lr
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
8000549e:	49 18       	lddpc	r8,800054e0 <INTC_init_interrupts+0x44>
800054a0:	e3 b8 00 01 	mtsr	0x4,r8
800054a4:	49 0e       	lddpc	lr,800054e4 <INTC_init_interrupts+0x48>
800054a6:	30 07       	mov	r7,0
800054a8:	0e 94       	mov	r4,r7
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
800054aa:	49 0c       	lddpc	r12,800054e8 <INTC_init_interrupts+0x4c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
800054ac:	49 05       	lddpc	r5,800054ec <INTC_init_interrupts+0x50>
800054ae:	10 15       	sub	r5,r8
800054b0:	fe 76 08 00 	mov	r6,-63488
800054b4:	c1 08       	rjmp	800054d4 <INTC_init_interrupts+0x38>
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
800054b6:	08 98       	mov	r8,r4
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
800054b8:	7c 1b       	ld.w	r11,lr[0x4]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
800054ba:	7c 0a       	ld.w	r10,lr[0x0]
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
800054bc:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
800054c0:	2f f8       	sub	r8,-1

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
800054c2:	10 3a       	cp.w	r10,r8
800054c4:	fe 9b ff fc 	brhi	800054bc <INTC_init_interrupts+0x20>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
800054c8:	ec 07 09 25 	st.w	r6[r7<<0x2],r5
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
800054cc:	2f f7       	sub	r7,-1
800054ce:	2f 8e       	sub	lr,-8
800054d0:	59 37       	cp.w	r7,19
800054d2:	c0 50       	breq	800054dc <INTC_init_interrupts+0x40>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
800054d4:	7c 08       	ld.w	r8,lr[0x0]
800054d6:	58 08       	cp.w	r8,0
800054d8:	ce f1       	brne	800054b6 <INTC_init_interrupts+0x1a>
800054da:	cf 7b       	rjmp	800054c8 <INTC_init_interrupts+0x2c>
800054dc:	d8 22       	popm	r4-r7,pc
800054de:	00 00       	add	r0,r0
800054e0:	80 00       	ld.sh	r0,r0[0x0]
800054e2:	cc 00       	breq	80005462 <INTC_register_interrupt+0x46>
800054e4:	80 00       	ld.sh	r0,r0[0x0]
800054e6:	dc 80       	acall	0xc8
800054e8:	80 00       	ld.sh	r0,r0[0x0]
800054ea:	54 18       	stdsp	sp[0x104],r8
800054ec:	80 00       	ld.sh	r0,r0[0x0]
800054ee:	cd 04       	brge	8000548e <INTC_register_interrupt+0x72>

800054f0 <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
800054f0:	fe 78 08 00 	mov	r8,-63488
800054f4:	e0 69 00 83 	mov	r9,131
800054f8:	f2 0c 01 0c 	sub	r12,r9,r12
800054fc:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
80005500:	f2 ca ff c0 	sub	r10,r9,-64
80005504:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	
	return (int_req)
80005508:	58 08       	cp.w	r8,0
8000550a:	c0 21       	brne	8000550e <_get_interrupt_handler+0x1e>
8000550c:	5e fd       	retal	0
		? _int_handler_table[int_grp]._int_line_handler_table[32
8000550e:	f0 08 12 00 	clz	r8,r8
80005512:	48 5a       	lddpc	r10,80005524 <_get_interrupt_handler+0x34>
80005514:	f4 09 00 39 	add	r9,r10,r9<<0x3
80005518:	f0 08 11 1f 	rsub	r8,r8,31
8000551c:	72 19       	ld.w	r9,r9[0x4]
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	
	return (int_req)
8000551e:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
80005522:	5e fc       	retal	r12
80005524:	80 00       	ld.sh	r0,r0[0x0]
80005526:	dc 80       	acall	0xc8

80005528 <spi_initMaster>:

spi_status_t spi_initMaster(volatile avr32_spi_t *spi, const spi_options_t *options)
{
  u_avr32_spi_mr_t u_avr32_spi_mr;

  if (options->modfdis > 1) {
80005528:	f7 39 00 0d 	ld.ub	r9,r11[13]
8000552c:	30 18       	mov	r8,1
8000552e:	f0 09 18 00 	cp.b	r9,r8
80005532:	e0 88 00 04 	brls	8000553a <spi_initMaster+0x12>
80005536:	30 2c       	mov	r12,2
80005538:	5e fc       	retal	r12
    return SPI_ERROR_ARGUMENT;
  }

  // Reset.
  spi->cr = AVR32_SPI_CR_SWRST_MASK;
8000553a:	e0 68 00 80 	mov	r8,128
8000553e:	99 08       	st.w	r12[0x0],r8

  // Master Mode.
  u_avr32_spi_mr.mr = spi->mr;
80005540:	78 18       	ld.w	r8,r12[0x4]
  u_avr32_spi_mr.MR.mstr = 1;
80005542:	30 19       	mov	r9,1
80005544:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
  u_avr32_spi_mr.MR.modfdis = options->modfdis;
80005548:	f7 39 00 0d 	ld.ub	r9,r11[13]
8000554c:	f1 d9 d0 81 	bfins	r8,r9,0x4,0x1
  u_avr32_spi_mr.MR.llb = 0;
80005550:	30 09       	mov	r9,0
80005552:	f1 d9 d0 e1 	bfins	r8,r9,0x7,0x1
  u_avr32_spi_mr.MR.pcs = (1 << AVR32_SPI_MR_PCS_SIZE) - 1;
80005556:	30 fa       	mov	r10,15
80005558:	f1 da d2 04 	bfins	r8,r10,0x10,0x4
  spi->mr = u_avr32_spi_mr.mr;
8000555c:	99 18       	st.w	r12[0x4],r8
8000555e:	5e f9       	retal	r9

80005560 <spi_selectionMode>:

spi_status_t spi_selectionMode(volatile avr32_spi_t *spi,
                               unsigned char variable_ps,
                               unsigned char pcs_decode,
                               unsigned char delay)
{
80005560:	d4 01       	pushm	lr
  u_avr32_spi_mr_t u_avr32_spi_mr;

  if (variable_ps > 1 ||
80005562:	30 18       	mov	r8,1
80005564:	f0 0b 18 00 	cp.b	r11,r8
80005568:	5f be       	srhi	lr
8000556a:	f0 0a 18 00 	cp.b	r10,r8
8000556e:	5f b8       	srhi	r8
80005570:	fd e8 10 08 	or	r8,lr,r8
80005574:	c0 30       	breq	8000557a <spi_selectionMode+0x1a>
80005576:	30 2c       	mov	r12,2
80005578:	d8 02       	popm	pc
      pcs_decode > 1) {
    return SPI_ERROR_ARGUMENT;
  }

  u_avr32_spi_mr.mr = spi->mr;
8000557a:	78 18       	ld.w	r8,r12[0x4]
  u_avr32_spi_mr.MR.ps = variable_ps;
8000557c:	f1 db d0 21 	bfins	r8,r11,0x1,0x1
  u_avr32_spi_mr.MR.pcsdec = pcs_decode;
80005580:	f1 da d0 41 	bfins	r8,r10,0x2,0x1
  u_avr32_spi_mr.MR.dlybcs = delay;
80005584:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8
  spi->mr = u_avr32_spi_mr.mr;
80005588:	99 18       	st.w	r12[0x4],r8
8000558a:	d8 0a       	popm	pc,r12=0

8000558c <spi_selectChip>:
   */
  while (pdFALSE == xSemaphoreTake(xSPIMutex, 20));
#endif

  // Assert all lines; no peripheral is selected.
  spi->mr |= AVR32_SPI_MR_PCS_MASK;
8000558c:	78 18       	ld.w	r8,r12[0x4]
8000558e:	ea 18 00 0f 	orh	r8,0xf
80005592:	99 18       	st.w	r12[0x4],r8

  if (spi->mr & AVR32_SPI_MR_PCSDEC_MASK) {
80005594:	78 18       	ld.w	r8,r12[0x4]
80005596:	e2 18 00 04 	andl	r8,0x4,COH
8000559a:	c0 f0       	breq	800055b8 <spi_selectChip+0x2c>
    // The signal is decoded; allow up to 15 chips.
    if (chip > 14) {
8000559c:	30 e8       	mov	r8,14
8000559e:	f0 0b 18 00 	cp.b	r11,r8
800055a2:	e0 8b 00 19 	brhi	800055d4 <spi_selectChip+0x48>
      return SPI_ERROR_ARGUMENT;
    }

    spi->mr &= ~AVR32_SPI_MR_PCS_MASK | (chip << AVR32_SPI_MR_PCS_OFFSET);
800055a6:	78 18       	ld.w	r8,r12[0x4]
800055a8:	b1 6b       	lsl	r11,0x10
800055aa:	ea 1b ff f0 	orh	r11,0xfff0
800055ae:	e8 1b ff ff 	orl	r11,0xffff
800055b2:	10 6b       	and	r11,r8
800055b4:	99 1b       	st.w	r12[0x4],r11
800055b6:	5e fd       	retal	0
  } else {
    if (chip > 3) {
800055b8:	30 38       	mov	r8,3
800055ba:	f0 0b 18 00 	cp.b	r11,r8
800055be:	e0 8b 00 0b 	brhi	800055d4 <spi_selectChip+0x48>
      return SPI_ERROR_ARGUMENT;
    }

    spi->mr &= ~(1 << (AVR32_SPI_MR_PCS_OFFSET + chip));
800055c2:	78 18       	ld.w	r8,r12[0x4]
800055c4:	2f 0b       	sub	r11,-16
800055c6:	30 19       	mov	r9,1
800055c8:	f2 0b 09 4b 	lsl	r11,r9,r11
800055cc:	5c db       	com	r11
800055ce:	10 6b       	and	r11,r8
800055d0:	99 1b       	st.w	r12[0x4],r11
800055d2:	5e fd       	retal	0
800055d4:	30 2c       	mov	r12,2
  }

  return SPI_OK;
}
800055d6:	5e fc       	retal	r12

800055d8 <spi_unselectChip>:


spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, unsigned char chip)
{
800055d8:	e0 68 27 10 	mov	r8,10000
  unsigned int timeout = SPI_TIMEOUT;

  while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
800055dc:	c0 58       	rjmp	800055e6 <spi_unselectChip+0xe>
    if (!timeout--) {
800055de:	58 08       	cp.w	r8,0
800055e0:	c0 21       	brne	800055e4 <spi_unselectChip+0xc>
800055e2:	5e ff       	retal	1
800055e4:	20 18       	sub	r8,1

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, unsigned char chip)
{
  unsigned int timeout = SPI_TIMEOUT;

  while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
800055e6:	78 49       	ld.w	r9,r12[0x10]
800055e8:	e2 19 02 00 	andl	r9,0x200,COH
800055ec:	cf 90       	breq	800055de <spi_unselectChip+0x6>
      return SPI_ERROR_TIMEOUT;
    }
  }

  // Assert all lines; no peripheral is selected.
  spi->mr |= AVR32_SPI_MR_PCS_MASK;
800055ee:	78 18       	ld.w	r8,r12[0x4]
800055f0:	ea 18 00 0f 	orh	r8,0xf
800055f4:	99 18       	st.w	r12[0x4],r8

  // Last transfer, so deassert the current NPCS if CSAAT is set.
  spi->cr = AVR32_SPI_CR_LASTXFER_MASK;
800055f6:	fc 18 01 00 	movh	r8,0x100
800055fa:	99 08       	st.w	r12[0x0],r8
800055fc:	5e fd       	retal	0

800055fe <spi_setupChipReg>:


spi_status_t spi_setupChipReg(volatile avr32_spi_t *spi,
                              const spi_options_t *options,
                              unsigned int pba_hz)
{
800055fe:	eb cd 40 c0 	pushm	r6-r7,lr
  u_avr32_spi_csr_t u_avr32_spi_csr;

  if (options->spi_mode > 3 ||
80005602:	f7 38 00 0c 	ld.ub	r8,r11[12]
80005606:	30 39       	mov	r9,3
80005608:	f2 08 18 00 	cp.b	r8,r9
8000560c:	e0 8b 00 57 	brhi	800056ba <spi_setupChipReg+0xbc>
      options->stay_act > 1 ||
80005610:	f7 39 00 0b 	ld.ub	r9,r11[11]
                              const spi_options_t *options,
                              unsigned int pba_hz)
{
  u_avr32_spi_csr_t u_avr32_spi_csr;

  if (options->spi_mode > 3 ||
80005614:	30 1e       	mov	lr,1
80005616:	fc 09 18 00 	cp.b	r9,lr
8000561a:	e0 8b 00 50 	brhi	800056ba <spi_setupChipReg+0xbc>
      options->stay_act > 1 ||
      options->bits < 8 || options->bits > 16) {
8000561e:	f7 3e 00 08 	ld.ub	lr,r11[8]
                              const spi_options_t *options,
                              unsigned int pba_hz)
{
  u_avr32_spi_csr_t u_avr32_spi_csr;

  if (options->spi_mode > 3 ||
80005622:	30 77       	mov	r7,7
80005624:	ee 0e 18 00 	cp.b	lr,r7
80005628:	e0 88 00 49 	brls	800056ba <spi_setupChipReg+0xbc>
8000562c:	31 07       	mov	r7,16
8000562e:	ee 0e 18 00 	cp.b	lr,r7
80005632:	e0 8b 00 44 	brhi	800056ba <spi_setupChipReg+0xbc>
 *   \retval >=0  Success.
 *   \retval  <0  Error.
 */
static int getBaudDiv(const spi_options_t *options, unsigned int pba_hz)
{
  int baudDiv = (pba_hz + options->baudrate / 2) / options->baudrate;
80005636:	76 17       	ld.w	r7,r11[0x4]
80005638:	ee 06 16 01 	lsr	r6,r7,0x1
8000563c:	0c 0a       	add	r10,r6
8000563e:	f4 07 0d 06 	divu	r6,r10,r7

  if (baudDiv <= 0 || baudDiv > 255) {
80005642:	ec c7 00 01 	sub	r7,r6,1
80005646:	e0 47 00 fe 	cp.w	r7,254
8000564a:	e0 8b 00 38 	brhi	800056ba <spi_setupChipReg+0xbc>
 *   \retval >=0  Success.
 *   \retval  <0  Error.
 */
static int getBaudDiv(const spi_options_t *options, unsigned int pba_hz)
{
  int baudDiv = (pba_hz + options->baudrate / 2) / options->baudrate;
8000564e:	0c 97       	mov	r7,r6
    return SPI_ERROR_ARGUMENT;
  }

  int baudDiv = getBaudDiv(options, pba_hz);

  if (baudDiv < 0) {
80005650:	58 06       	cp.w	r6,0
80005652:	c3 45       	brlt	800056ba <spi_setupChipReg+0xbc>
    return SPI_ERROR_ARGUMENT;
  }

  // Will use CSR0 offsets; these are the same for CSR0 to CSR3.
  u_avr32_spi_csr.csr = 0;
80005654:	30 0a       	mov	r10,0
  u_avr32_spi_csr.CSR.cpol = options->spi_mode >> 1;
80005656:	f0 06 16 01 	lsr	r6,r8,0x1
8000565a:	f5 d6 d0 01 	bfins	r10,r6,0x0,0x1
  u_avr32_spi_csr.CSR.ncpha = (options->spi_mode & 0x1) ^ 0x1;
8000565e:	ec 18 00 01 	eorl	r8,0x1
80005662:	f5 d8 d0 21 	bfins	r10,r8,0x1,0x1
  u_avr32_spi_csr.CSR.csaat = options->stay_act;
80005666:	f5 d9 d0 61 	bfins	r10,r9,0x3,0x1
  u_avr32_spi_csr.CSR.bits = options->bits - 8;
8000566a:	20 8e       	sub	lr,8
8000566c:	f5 de d0 84 	bfins	r10,lr,0x4,0x4
  u_avr32_spi_csr.CSR.scbr = baudDiv;
80005670:	f5 d7 d1 08 	bfins	r10,r7,0x8,0x8
  u_avr32_spi_csr.CSR.dlybs = options->spck_delay;
80005674:	f7 38 00 09 	ld.ub	r8,r11[9]
80005678:	f5 d8 d2 08 	bfins	r10,r8,0x10,0x8
  u_avr32_spi_csr.CSR.dlybct = options->trans_delay;
8000567c:	f7 38 00 0a 	ld.ub	r8,r11[10]
80005680:	f5 d8 d3 08 	bfins	r10,r8,0x18,0x8

  switch(options->reg) {
80005684:	17 88       	ld.ub	r8,r11[0x0]
80005686:	30 19       	mov	r9,1
80005688:	f2 08 18 00 	cp.b	r8,r9
8000568c:	c0 e0       	breq	800056a8 <spi_setupChipReg+0xaa>
8000568e:	c0 a3       	brcs	800056a2 <spi_setupChipReg+0xa4>
80005690:	30 29       	mov	r9,2
80005692:	f2 08 18 00 	cp.b	r8,r9
80005696:	c0 c0       	breq	800056ae <spi_setupChipReg+0xb0>
80005698:	30 39       	mov	r9,3
8000569a:	f2 08 18 00 	cp.b	r8,r9
8000569e:	c0 e1       	brne	800056ba <spi_setupChipReg+0xbc>
800056a0:	c0 a8       	rjmp	800056b4 <spi_setupChipReg+0xb6>
    case 0:
      spi->csr0 = u_avr32_spi_csr.csr;
800056a2:	99 ca       	st.w	r12[0x30],r10
800056a4:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
      break;
    case 1:
      spi->csr1 = u_avr32_spi_csr.csr;
800056a8:	99 da       	st.w	r12[0x34],r10
800056aa:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
      break;
    case 2:
      spi->csr2 = u_avr32_spi_csr.csr;
800056ae:	99 ea       	st.w	r12[0x38],r10
800056b0:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
      break;
    case 3:
      spi->csr3 = u_avr32_spi_csr.csr;
800056b4:	99 fa       	st.w	r12[0x3c],r10
800056b6:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
      break;
800056ba:	30 2c       	mov	r12,2
    }
  }
#endif

  return SPI_OK;
}
800056bc:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

800056c0 <spi_enable>:


void spi_enable(volatile avr32_spi_t *spi)
{
  spi->cr = AVR32_SPI_CR_SPIEN_MASK;
800056c0:	30 18       	mov	r8,1
800056c2:	99 08       	st.w	r12[0x0],r8
}
800056c4:	5e fc       	retal	r12

800056c6 <spi_write>:
  return ((spi->sr & AVR32_SPI_SR_TDRE_MASK) != 0);
}


spi_status_t spi_write(volatile avr32_spi_t *spi, unsigned short data)
{
800056c6:	e0 68 27 10 	mov	r8,10000
  unsigned int timeout = SPI_TIMEOUT;

  while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
800056ca:	c0 58       	rjmp	800056d4 <spi_write+0xe>
    if (!timeout--) {
800056cc:	58 08       	cp.w	r8,0
800056ce:	c0 21       	brne	800056d2 <spi_write+0xc>
800056d0:	5e ff       	retal	1
800056d2:	20 18       	sub	r8,1

spi_status_t spi_write(volatile avr32_spi_t *spi, unsigned short data)
{
  unsigned int timeout = SPI_TIMEOUT;

  while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
800056d4:	78 49       	ld.w	r9,r12[0x10]
800056d6:	e2 19 00 02 	andl	r9,0x2,COH
800056da:	cf 90       	breq	800056cc <spi_write+0x6>
    if (!timeout--) {
      return SPI_ERROR_TIMEOUT;
    }
  }

  spi->tdr = data << AVR32_SPI_TDR_TD_OFFSET;
800056dc:	5c 7b       	castu.h	r11
800056de:	99 3b       	st.w	r12[0xc],r11
800056e0:	5e fd       	retal	0

800056e2 <spi_read>:
  return ((spi->sr & AVR32_SPI_SR_RDRF_MASK) != 0);
}


spi_status_t spi_read(volatile avr32_spi_t *spi, unsigned short *data)
{
800056e2:	e0 68 27 10 	mov	r8,10000
  unsigned int timeout = SPI_TIMEOUT;

  while ((spi->sr & (AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) !=
800056e6:	c0 58       	rjmp	800056f0 <spi_read+0xe>
         (AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) {
    if (!timeout--) {
800056e8:	58 08       	cp.w	r8,0
800056ea:	c0 21       	brne	800056ee <spi_read+0xc>
800056ec:	5e ff       	retal	1
800056ee:	20 18       	sub	r8,1

spi_status_t spi_read(volatile avr32_spi_t *spi, unsigned short *data)
{
  unsigned int timeout = SPI_TIMEOUT;

  while ((spi->sr & (AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) !=
800056f0:	78 49       	ld.w	r9,r12[0x10]
800056f2:	e2 19 02 01 	andl	r9,0x201,COH
800056f6:	e0 49 02 01 	cp.w	r9,513
800056fa:	cf 71       	brne	800056e8 <spi_read+0x6>
    if (!timeout--) {
      return SPI_ERROR_TIMEOUT;
    }
  }

  *data = spi->rdr >> AVR32_SPI_RDR_RD_OFFSET;
800056fc:	78 28       	ld.w	r8,r12[0x8]
800056fe:	b6 08       	st.h	r11[0x0],r8
80005700:	5e fd       	retal	0

80005702 <tc_init_waveform>:


int tc_init_waveform(volatile avr32_tc_t *tc, const tc_waveform_opt_t *opt)
{
  // Check for valid input.
  if (opt->channel >= TC_NUMBER_OF_CHANNELS)
80005702:	76 09       	ld.w	r9,r11[0x0]
80005704:	58 29       	cp.w	r9,2
80005706:	e0 88 00 03 	brls	8000570c <tc_init_waveform+0xa>
8000570a:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  // GENERATE SIGNALS: Waveform operating mode.
  tc->channel[opt->channel].cmr = opt->bswtrg << AVR32_TC_BSWTRG_OFFSET |
8000570c:	76 18       	ld.w	r8,r11[0x4]
8000570e:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
80005712:	af ba       	sbr	r10,0xf
80005714:	10 9b       	mov	r11,r8
80005716:	e6 1b c0 00 	andh	r11,0xc000,COH
8000571a:	16 4a       	or	r10,r11
8000571c:	10 9b       	mov	r11,r8
8000571e:	e6 1b 30 00 	andh	r11,0x3000,COH
80005722:	16 4a       	or	r10,r11
80005724:	10 9b       	mov	r11,r8
80005726:	e6 1b 0c 00 	andh	r11,0xc00,COH
8000572a:	16 4a       	or	r10,r11
8000572c:	10 9b       	mov	r11,r8
8000572e:	e6 1b 03 00 	andh	r11,0x300,COH
80005732:	16 4a       	or	r10,r11
80005734:	10 9b       	mov	r11,r8
80005736:	e6 1b 00 c0 	andh	r11,0xc0,COH
8000573a:	16 4a       	or	r10,r11
8000573c:	10 9b       	mov	r11,r8
8000573e:	e6 1b 00 30 	andh	r11,0x30,COH
80005742:	16 4a       	or	r10,r11
80005744:	10 9b       	mov	r11,r8
80005746:	e6 1b 00 0c 	andh	r11,0xc,COH
8000574a:	16 4a       	or	r10,r11
8000574c:	10 9b       	mov	r11,r8
8000574e:	e6 1b 00 03 	andh	r11,0x3,COH
80005752:	16 4a       	or	r10,r11
80005754:	10 9b       	mov	r11,r8
80005756:	e2 1b 60 00 	andl	r11,0x6000,COH
8000575a:	16 4a       	or	r10,r11
8000575c:	f7 d8 c1 81 	bfextu	r11,r8,0xc,0x1
80005760:	f5 eb 10 ca 	or	r10,r10,r11<<0xc
80005764:	10 9b       	mov	r11,r8
80005766:	e2 1b 0c 00 	andl	r11,0xc00,COH
8000576a:	16 4a       	or	r10,r11
8000576c:	10 9b       	mov	r11,r8
8000576e:	e2 1b 03 00 	andl	r11,0x300,COH
80005772:	16 4a       	or	r10,r11
80005774:	f7 d8 c0 e1 	bfextu	r11,r8,0x7,0x1
80005778:	f5 eb 10 7a 	or	r10,r10,r11<<0x7
8000577c:	f7 d8 c0 c1 	bfextu	r11,r8,0x6,0x1
80005780:	f5 eb 10 6a 	or	r10,r10,r11<<0x6
80005784:	10 9b       	mov	r11,r8
80005786:	e2 1b 00 30 	andl	r11,0x30,COH
8000578a:	16 4a       	or	r10,r11
8000578c:	f1 d8 c0 61 	bfextu	r8,r8,0x3,0x1
80005790:	f5 e8 10 38 	or	r8,r10,r8<<0x3
80005794:	a5 69       	lsl	r9,0x4
80005796:	2f f9       	sub	r9,-1
80005798:	f8 09 09 28 	st.w	r12[r9<<0x2],r8
8000579c:	5e fd       	retal	0

8000579e <tc_start>:


int tc_start(volatile avr32_tc_t *tc, unsigned int channel)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
8000579e:	58 2b       	cp.w	r11,2
800057a0:	e0 88 00 03 	brls	800057a6 <tc_start+0x8>
800057a4:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  // Enable, reset and start the selected timer/counter channel.
  tc->channel[channel].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
800057a6:	a7 6b       	lsl	r11,0x6
800057a8:	16 0c       	add	r12,r11
800057aa:	30 58       	mov	r8,5
800057ac:	99 08       	st.w	r12[0x0],r8
800057ae:	5e fd       	retal	0

800057b0 <tc_read_sr>:


int tc_read_sr(volatile avr32_tc_t *tc, unsigned int channel)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
800057b0:	58 2b       	cp.w	r11,2
800057b2:	e0 88 00 03 	brls	800057b8 <tc_read_sr+0x8>
800057b6:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  return tc->channel[channel].sr;
800057b8:	a7 6b       	lsl	r11,0x6
800057ba:	2e 0b       	sub	r11,-32
800057bc:	16 0c       	add	r12,r11
800057be:	78 0c       	ld.w	r12,r12[0x0]
}
800057c0:	5e fc       	retal	r12

800057c2 <tc_write_rc>:


int tc_write_rc(volatile avr32_tc_t *tc, unsigned int channel, unsigned short value)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
800057c2:	58 2b       	cp.w	r11,2
800057c4:	e0 88 00 03 	brls	800057ca <tc_write_rc+0x8>
800057c8:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  // This function is only available in WAVEFORM mode.
  if (Tst_bits(tc->channel[channel].cmr, AVR32_TC_WAVE_MASK))
800057ca:	f6 08 15 04 	lsl	r8,r11,0x4
800057ce:	2f f8       	sub	r8,-1
800057d0:	f8 08 03 28 	ld.w	r8,r12[r8<<0x2]
800057d4:	e2 18 80 00 	andl	r8,0x8000,COH
800057d8:	c0 c0       	breq	800057f0 <tc_write_rc+0x2e>
    Wr_bitfield(tc->channel[channel].rc, AVR32_TC_RC_MASK, value);
800057da:	a7 6b       	lsl	r11,0x6
800057dc:	16 0c       	add	r12,r11
800057de:	2e 4c       	sub	r12,-28
800057e0:	78 08       	ld.w	r8,r12[0x0]
800057e2:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
800057e6:	e0 18 00 00 	andl	r8,0x0
800057ea:	f3 e8 10 08 	or	r8,r9,r8
800057ee:	99 08       	st.w	r12[0x0],r8

  return value;
800057f0:	f9 da c0 10 	bfextu	r12,r10,0x0,0x10
}
800057f4:	5e fc       	retal	r12

800057f6 <tc_configure_interrupts>:
  return tc->channel[channel].imr;
}


int tc_configure_interrupts(volatile avr32_tc_t *tc, unsigned int channel, const tc_interrupt_t *bitfield)
{
800057f6:	eb cd 40 fc 	pushm	r2-r7,lr
  bool global_interrupt_enabled = Is_global_interrupt_enabled();
800057fa:	e1 b9 00 00 	mfsr	r9,0x0

  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
800057fe:	58 2b       	cp.w	r11,2
80005800:	e0 88 00 04 	brls	80005808 <tc_configure_interrupts+0x12>
80005804:	e3 cf c0 fc 	ldm	sp++,r2-r7,pc,r12=-1
	return flags;
}

static inline bool cpu_irq_is_enabled_flags(irqflags_t flags)
{
	return !(flags & AVR32_SR_GM_MASK);
80005808:	ee 19 00 01 	eorh	r9,0x1
8000580c:	f3 d9 c2 01 	bfextu	r9,r9,0x10,0x1
    return TC_INVALID_ARGUMENT;

  // Enable the appropriate interrupts.
  tc->channel[channel].ier = bitfield->etrgs << AVR32_TC_ETRGS_OFFSET |
80005810:	74 08       	ld.w	r8,r10[0x0]
80005812:	ef d8 c0 e1 	bfextu	r7,r8,0x7,0x1
80005816:	fd d8 c0 c1 	bfextu	lr,r8,0x6,0x1
8000581a:	a7 6e       	lsl	lr,0x6
8000581c:	fd e7 10 7e 	or	lr,lr,r7<<0x7
80005820:	ef d8 c0 01 	bfextu	r7,r8,0x0,0x1
80005824:	0e 4e       	or	lr,r7
80005826:	ef d8 c0 a1 	bfextu	r7,r8,0x5,0x1
8000582a:	fd e7 10 5e 	or	lr,lr,r7<<0x5
8000582e:	ef d8 c0 81 	bfextu	r7,r8,0x4,0x1
80005832:	fd e7 10 4e 	or	lr,lr,r7<<0x4
80005836:	ef d8 c0 61 	bfextu	r7,r8,0x3,0x1
8000583a:	fd e7 10 3e 	or	lr,lr,r7<<0x3
8000583e:	ef d8 c0 41 	bfextu	r7,r8,0x2,0x1
80005842:	fd e7 10 2e 	or	lr,lr,r7<<0x2
80005846:	f1 d8 c0 21 	bfextu	r8,r8,0x1,0x1
8000584a:	fd e8 10 18 	or	r8,lr,r8<<0x1
8000584e:	f6 0e 15 06 	lsl	lr,r11,0x6
80005852:	f8 0e 00 0e 	add	lr,r12,lr
80005856:	2d ce       	sub	lr,-36
80005858:	9d 08       	st.w	lr[0x0],r8
                             bitfield->cpas << AVR32_TC_CPAS_OFFSET |
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;

  // Disable the appropriate interrupts.
  if (global_interrupt_enabled) Disable_global_interrupt();
8000585a:	58 09       	cp.w	r9,0
8000585c:	c0 20       	breq	80005860 <tc_configure_interrupts+0x6a>
8000585e:	d3 03       	ssrf	0x10
  tc->channel[channel].idr = (~bitfield->etrgs & 1) << AVR32_TC_ETRGS_OFFSET |
80005860:	74 08       	ld.w	r8,r10[0x0]
80005862:	f1 d8 c0 e1 	bfextu	r8,r8,0x7,0x1
80005866:	e0 65 00 80 	mov	r5,128
8000586a:	f9 b5 01 00 	movne	r5,0
                             (~bitfield->ldrbs & 1) << AVR32_TC_LDRBS_OFFSET |
8000586e:	74 08       	ld.w	r8,r10[0x0]
80005870:	f1 d8 c0 c1 	bfextu	r8,r8,0x6,0x1
80005874:	f9 b4 00 40 	moveq	r4,64
80005878:	f9 b4 01 00 	movne	r4,0
                             (~bitfield->ldras & 1) << AVR32_TC_LDRAS_OFFSET |
8000587c:	74 08       	ld.w	r8,r10[0x0]
8000587e:	f1 d8 c0 a1 	bfextu	r8,r8,0x5,0x1
80005882:	f9 b3 00 20 	moveq	r3,32
80005886:	f9 b3 01 00 	movne	r3,0
                             (~bitfield->cpcs & 1) << AVR32_TC_CPCS_OFFSET |
8000588a:	74 08       	ld.w	r8,r10[0x0]
8000588c:	f1 d8 c0 81 	bfextu	r8,r8,0x4,0x1
80005890:	f9 b2 00 10 	moveq	r2,16
80005894:	f9 b2 01 00 	movne	r2,0
                             (~bitfield->cpbs & 1) << AVR32_TC_CPBS_OFFSET |
80005898:	74 08       	ld.w	r8,r10[0x0]
8000589a:	f1 d8 c0 61 	bfextu	r8,r8,0x3,0x1
8000589e:	f9 b6 00 08 	moveq	r6,8
800058a2:	f9 b6 01 00 	movne	r6,0
                             (~bitfield->cpas & 1) << AVR32_TC_CPAS_OFFSET |
800058a6:	74 08       	ld.w	r8,r10[0x0]
800058a8:	f1 d8 c0 41 	bfextu	r8,r8,0x2,0x1
800058ac:	f9 b7 00 04 	moveq	r7,4
800058b0:	f9 b7 01 00 	movne	r7,0
                             (~bitfield->lovrs & 1) << AVR32_TC_LOVRS_OFFSET |
800058b4:	74 08       	ld.w	r8,r10[0x0]
800058b6:	f1 d8 c0 21 	bfextu	r8,r8,0x1,0x1
800058ba:	f9 be 00 02 	moveq	lr,2
800058be:	f9 be 01 00 	movne	lr,0
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;

  // Disable the appropriate interrupts.
  if (global_interrupt_enabled) Disable_global_interrupt();
  tc->channel[channel].idr = (~bitfield->etrgs & 1) << AVR32_TC_ETRGS_OFFSET |
800058c2:	74 08       	ld.w	r8,r10[0x0]
800058c4:	ec 18 00 01 	eorl	r8,0x1
800058c8:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800058cc:	eb e8 10 08 	or	r8,r5,r8
800058d0:	08 48       	or	r8,r4
800058d2:	06 48       	or	r8,r3
800058d4:	04 48       	or	r8,r2
800058d6:	0c 48       	or	r8,r6
800058d8:	0e 48       	or	r8,r7
800058da:	1c 48       	or	r8,lr
800058dc:	f6 0a 15 06 	lsl	r10,r11,0x6
800058e0:	f8 0a 00 0a 	add	r10,r12,r10
800058e4:	2d 8a       	sub	r10,-40
800058e6:	95 08       	st.w	r10[0x0],r8
                             (~bitfield->cpcs & 1) << AVR32_TC_CPCS_OFFSET |
                             (~bitfield->cpbs & 1) << AVR32_TC_CPBS_OFFSET |
                             (~bitfield->cpas & 1) << AVR32_TC_CPAS_OFFSET |
                             (~bitfield->lovrs & 1) << AVR32_TC_LOVRS_OFFSET |
                             (~bitfield->covfs & 1) << AVR32_TC_COVFS_OFFSET;
  tc->channel[channel].sr;
800058e8:	a7 6b       	lsl	r11,0x6
800058ea:	2e 0b       	sub	r11,-32
800058ec:	16 0c       	add	r12,r11
800058ee:	78 08       	ld.w	r8,r12[0x0]
  if (global_interrupt_enabled) Enable_global_interrupt();
800058f0:	58 09       	cp.w	r9,0
800058f2:	c0 31       	brne	800058f8 <tc_configure_interrupts+0x102>
800058f4:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0
800058f8:	d5 03       	csrf	0x10
800058fa:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0

800058fe <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
800058fe:	d4 01       	pushm	lr
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
80005900:	f6 08 15 04 	lsl	r8,r11,0x4
80005904:	14 38       	cp.w	r8,r10
80005906:	f9 b8 08 10 	movls	r8,16
8000590a:	f9 b8 0b 08 	movhi	r8,8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
8000590e:	f0 0b 02 4b 	mul	r11,r8,r11
80005912:	f6 09 16 01 	lsr	r9,r11,0x1
80005916:	f2 0a 00 3a 	add	r10,r9,r10<<0x3
8000591a:	f4 0b 0d 0a 	divu	r10,r10,r11
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
8000591e:	f4 09 16 03 	lsr	r9,r10,0x3
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
80005922:	f2 cb 00 01 	sub	r11,r9,1
80005926:	e0 4b ff fe 	cp.w	r11,65534
8000592a:	e0 88 00 03 	brls	80005930 <usart_set_async_baudrate+0x32>
8000592e:	da 0a       	popm	pc,r12=1
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
80005930:	78 1b       	ld.w	r11,r12[0x4]
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
80005932:	e8 6e 00 00 	mov	lr,524288
80005936:	59 08       	cp.w	r8,16
80005938:	fc 08 17 10 	movne	r8,lr
8000593c:	f9 b8 00 00 	moveq	r8,0
80005940:	e4 1b ff f7 	andh	r11,0xfff7
80005944:	e0 1b fe cf 	andl	r11,0xfecf
80005948:	16 48       	or	r8,r11
8000594a:	99 18       	st.w	r12[0x4],r8
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
8000594c:	f5 da c0 03 	bfextu	r10,r10,0x0,0x3
80005950:	f3 ea 11 09 	or	r9,r9,r10<<0x10
80005954:	99 89       	st.w	r12[0x20],r9
80005956:	d8 0a       	popm	pc,r12=0

80005958 <usart_write_char>:
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
80005958:	78 58       	ld.w	r8,r12[0x14]
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
  if (usart_tx_ready(usart))
8000595a:	e2 18 00 02 	andl	r8,0x2,COH
8000595e:	c0 31       	brne	80005964 <usart_write_char+0xc>
80005960:	30 2c       	mov	r12,2
80005962:	5e fc       	retal	r12
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
80005964:	f7 db c0 09 	bfextu	r11,r11,0x0,0x9
80005968:	99 7b       	st.w	r12[0x1c],r11
8000596a:	5e fd       	retal	0

8000596c <usart_putchar>:
    return USART_TX_BUSY;
}


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
8000596c:	eb cd 40 e0 	pushm	r5-r7,lr
80005970:	18 96       	mov	r6,r12
80005972:	16 95       	mov	r5,r11
80005974:	e0 67 27 0f 	mov	r7,9999
80005978:	c0 68       	rjmp	80005984 <usart_putchar+0x18>
  int timeout = USART_DEFAULT_TIMEOUT;

  do
  {
    if (!timeout--) return USART_FAILURE;
8000597a:	58 07       	cp.w	r7,0
8000597c:	c0 31       	brne	80005982 <usart_putchar+0x16>
8000597e:	e3 cf c0 e0 	ldm	sp++,r5-r7,pc,r12=-1
80005982:	20 17       	sub	r7,1
  } while (usart_write_char(usart, c) != USART_SUCCESS);
80005984:	0a 9b       	mov	r11,r5
80005986:	0c 9c       	mov	r12,r6
80005988:	f0 1f 00 03 	mcall	80005994 <usart_putchar+0x28>
8000598c:	cf 71       	brne	8000597a <usart_putchar+0xe>

  return USART_SUCCESS;
}
8000598e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80005992:	00 00       	add	r0,r0
80005994:	80 00       	ld.sh	r0,r0[0x0]
80005996:	59 58       	cp.w	r8,21

80005998 <usart_read_char>:

int usart_read_char(volatile avr32_usart_t *usart, int *c)
{
  // Check for errors: frame, parity and overrun. In RS485 mode, a parity error
  // would mean that an address char has been received.
  if (usart->csr & (AVR32_USART_CSR_OVRE_MASK |
80005998:	78 58       	ld.w	r8,r12[0x14]
8000599a:	e2 18 00 e0 	andl	r8,0xe0,COH
8000599e:	c0 30       	breq	800059a4 <usart_read_char+0xc>
800059a0:	30 4c       	mov	r12,4
800059a2:	5e fc       	retal	r12
 *
 * \return \c 1 if the USART Receive Holding Register is full, otherwise \c 0.
 */
__always_inline static int usart_test_hit(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_RXRDY_MASK) != 0;
800059a4:	78 58       	ld.w	r8,r12[0x14]
                    AVR32_USART_CSR_FRAME_MASK |
                    AVR32_USART_CSR_PARE_MASK))
    return USART_RX_ERROR;

  // No error; if we really did receive a char, read it and return SUCCESS.
  if (usart_test_hit(usart))
800059a6:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800059aa:	c0 31       	brne	800059b0 <usart_read_char+0x18>
800059ac:	30 3c       	mov	r12,3
800059ae:	5e fc       	retal	r12
  {
    *c = (usart->rhr & AVR32_USART_RHR_RXCHR_MASK) >> AVR32_USART_RHR_RXCHR_OFFSET;
800059b0:	78 68       	ld.w	r8,r12[0x18]
800059b2:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
800059b6:	97 08       	st.w	r11[0x0],r8
800059b8:	5e fd       	retal	0
800059ba:	d7 03       	nop

800059bc <usart_getchar>:
    return USART_RX_EMPTY;
}


int usart_getchar(volatile avr32_usart_t *usart)
{
800059bc:	eb cd 40 c0 	pushm	r6-r7,lr
800059c0:	20 1d       	sub	sp,4
800059c2:	18 96       	mov	r6,r12
  int c, ret;

  while ((ret = usart_read_char(usart, &c)) == USART_RX_EMPTY);
800059c4:	1a 97       	mov	r7,sp
800059c6:	1a 9b       	mov	r11,sp
800059c8:	0c 9c       	mov	r12,r6
800059ca:	f0 1f 00 07 	mcall	800059e4 <usart_getchar+0x28>
800059ce:	58 3c       	cp.w	r12,3
800059d0:	cf b0       	breq	800059c6 <usart_getchar+0xa>

  if (ret == USART_RX_ERROR)
800059d2:	58 4c       	cp.w	r12,4
800059d4:	f9 bc 00 ff 	moveq	r12,-1
    return USART_FAILURE;

  return c;
800059d8:	fb fc 10 00 	ld.wne	r12,sp[0x0]
}
800059dc:	2f fd       	sub	sp,-4
800059de:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800059e2:	00 00       	add	r0,r0
800059e4:	80 00       	ld.sh	r0,r0[0x0]
800059e6:	59 98       	cp.w	r8,25

800059e8 <usart_write_line>:


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
800059e8:	eb cd 40 c0 	pushm	r6-r7,lr
800059ec:	18 96       	mov	r6,r12
800059ee:	16 97       	mov	r7,r11
  while (*string != '\0')
800059f0:	17 8b       	ld.ub	r11,r11[0x0]
800059f2:	58 0b       	cp.w	r11,0
800059f4:	c0 80       	breq	80005a04 <usart_write_line+0x1c>
    usart_putchar(usart, *string++);
800059f6:	2f f7       	sub	r7,-1
800059f8:	0c 9c       	mov	r12,r6
800059fa:	f0 1f 00 04 	mcall	80005a08 <usart_write_line+0x20>
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
800059fe:	0f 8b       	ld.ub	r11,r7[0x0]
80005a00:	58 0b       	cp.w	r11,0
80005a02:	cf a1       	brne	800059f6 <usart_write_line+0xe>
80005a04:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005a08:	80 00       	ld.sh	r0,r0[0x0]
80005a0a:	59 6c       	cp.w	r12,22

80005a0c <usart_reset>:
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
80005a0c:	e1 b8 00 00 	mfsr	r8,0x0

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
80005a10:	e6 18 00 01 	andh	r8,0x1,COH
80005a14:	c0 71       	brne	80005a22 <usart_reset+0x16>
80005a16:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
80005a18:	3f f8       	mov	r8,-1
80005a1a:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80005a1c:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
80005a1e:	d5 03       	csrf	0x10
80005a20:	c0 48       	rjmp	80005a28 <usart_reset+0x1c>
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
  usart->idr = 0xFFFFFFFF;
80005a22:	3f f8       	mov	r8,-1
80005a24:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80005a26:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
80005a28:	30 08       	mov	r8,0
80005a2a:	99 18       	st.w	r12[0x4],r8
  usart->rtor = 0;
80005a2c:	99 98       	st.w	r12[0x24],r8
  usart->ttgr = 0;
80005a2e:	99 a8       	st.w	r12[0x28],r8

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
80005a30:	ea 68 61 0c 	mov	r8,680204
80005a34:	99 08       	st.w	r12[0x0],r8
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
80005a36:	5e fc       	retal	r12

80005a38 <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
80005a38:	eb cd 40 e0 	pushm	r5-r7,lr
80005a3c:	18 96       	mov	r6,r12
80005a3e:	16 97       	mov	r7,r11
80005a40:	14 95       	mov	r5,r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
80005a42:	f0 1f 00 2f 	mcall	80005afc <usart_init_rs232+0xc4>

  // Check input values.
  if (!opt || // Null pointer.
80005a46:	58 07       	cp.w	r7,0
80005a48:	c5 80       	breq	80005af8 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
80005a4a:	0f c8       	ld.ub	r8,r7[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80005a4c:	30 49       	mov	r9,4
80005a4e:	f2 08 18 00 	cp.b	r8,r9
80005a52:	e0 88 00 53 	brls	80005af8 <usart_init_rs232+0xc0>
80005a56:	30 99       	mov	r9,9
80005a58:	f2 08 18 00 	cp.b	r8,r9
80005a5c:	e0 8b 00 4e 	brhi	80005af8 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
80005a60:	0f d9       	ld.ub	r9,r7[0x5]
80005a62:	30 78       	mov	r8,7
80005a64:	f0 09 18 00 	cp.b	r9,r8
80005a68:	e0 8b 00 48 	brhi	80005af8 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
80005a6c:	8e 39       	ld.sh	r9,r7[0x6]
80005a6e:	e0 68 01 01 	mov	r8,257
80005a72:	f0 09 19 00 	cp.h	r9,r8
80005a76:	e0 8b 00 41 	brhi	80005af8 <usart_init_rs232+0xc0>
      opt->channelmode > 3 ||
80005a7a:	ef 39 00 08 	ld.ub	r9,r7[8]
80005a7e:	30 38       	mov	r8,3
80005a80:	f0 09 18 00 	cp.b	r9,r8
80005a84:	e0 8b 00 3a 	brhi	80005af8 <usart_init_rs232+0xc0>
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
80005a88:	0a 9a       	mov	r10,r5
80005a8a:	6e 0b       	ld.w	r11,r7[0x0]
80005a8c:	0c 9c       	mov	r12,r6
80005a8e:	f0 1f 00 1d 	mcall	80005b00 <usart_init_rs232+0xc8>
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80005a92:	58 1c       	cp.w	r12,1
80005a94:	c3 20       	breq	80005af8 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;

  if (opt->charlength == 9)
80005a96:	0f c8       	ld.ub	r8,r7[0x4]
80005a98:	30 99       	mov	r9,9
80005a9a:	f2 08 18 00 	cp.b	r8,r9
80005a9e:	c0 51       	brne	80005aa8 <usart_init_rs232+0x70>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
80005aa0:	6c 18       	ld.w	r8,r6[0x4]
80005aa2:	b1 b8       	sbr	r8,0x11
80005aa4:	8d 18       	st.w	r6[0x4],r8
80005aa6:	c0 68       	rjmp	80005ab2 <usart_init_rs232+0x7a>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
80005aa8:	6c 19       	ld.w	r9,r6[0x4]
80005aaa:	20 58       	sub	r8,5
80005aac:	f3 e8 10 68 	or	r8,r9,r8<<0x6
80005ab0:	8d 18       	st.w	r6[0x4],r8
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
80005ab2:	6c 19       	ld.w	r9,r6[0x4]
80005ab4:	ef 3a 00 08 	ld.ub	r10,r7[8]
80005ab8:	0f d8       	ld.ub	r8,r7[0x5]
80005aba:	a9 78       	lsl	r8,0x9
80005abc:	f1 ea 10 e8 	or	r8,r8,r10<<0xe
80005ac0:	12 48       	or	r8,r9
80005ac2:	8d 18       	st.w	r6[0x4],r8
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
80005ac4:	8e 38       	ld.sh	r8,r7[0x6]
80005ac6:	30 29       	mov	r9,2
80005ac8:	f2 08 19 00 	cp.h	r8,r9
80005acc:	e0 88 00 09 	brls	80005ade <usart_init_rs232+0xa6>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
80005ad0:	6c 18       	ld.w	r8,r6[0x4]
80005ad2:	ad b8       	sbr	r8,0xd
80005ad4:	8d 18       	st.w	r6[0x4],r8
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
80005ad6:	8e b8       	ld.uh	r8,r7[0x6]
80005ad8:	20 28       	sub	r8,2
80005ada:	8d a8       	st.w	r6[0x28],r8
80005adc:	c0 68       	rjmp	80005ae8 <usart_init_rs232+0xb0>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
80005ade:	6c 19       	ld.w	r9,r6[0x4]
80005ae0:	5c 78       	castu.h	r8
80005ae2:	f3 e8 10 c8 	or	r8,r9,r8<<0xc
80005ae6:	8d 18       	st.w	r6[0x4],r8

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
80005ae8:	6c 18       	ld.w	r8,r6[0x4]
80005aea:	e0 18 ff f0 	andl	r8,0xfff0
80005aee:	8d 18       	st.w	r6[0x4],r8
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
80005af0:	35 08       	mov	r8,80
80005af2:	8d 08       	st.w	r6[0x0],r8
80005af4:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
80005af8:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
80005afc:	80 00       	ld.sh	r0,r0[0x0]
80005afe:	5a 0c       	cp.w	r12,-32
80005b00:	80 00       	ld.sh	r0,r0[0x0]
80005b02:	58 fe       	cp.w	lr,15

80005b04 <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
80005b04:	f8 c8 ff f8 	sub	r8,r12,-8
80005b08:	99 18       	st.w	r12[0x4],r8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
80005b0a:	3f f9       	mov	r9,-1
80005b0c:	99 29       	st.w	r12[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
80005b0e:	99 38       	st.w	r12[0xc],r8
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
80005b10:	99 48       	st.w	r12[0x10],r8

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
80005b12:	30 08       	mov	r8,0
80005b14:	99 08       	st.w	r12[0x0],r8
}
80005b16:	5e fc       	retal	r12

80005b18 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
80005b18:	30 08       	mov	r8,0
80005b1a:	99 48       	st.w	r12[0x10],r8
}
80005b1c:	5e fc       	retal	r12

80005b1e <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
80005b1e:	78 18       	ld.w	r8,r12[0x4]

	pxNewListItem->pxNext = pxIndex->pxNext;
80005b20:	70 19       	ld.w	r9,r8[0x4]
80005b22:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
80005b24:	78 19       	ld.w	r9,r12[0x4]
80005b26:	97 29       	st.w	r11[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80005b28:	70 19       	ld.w	r9,r8[0x4]
80005b2a:	93 2b       	st.w	r9[0x8],r11
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
80005b2c:	91 1b       	st.w	r8[0x4],r11
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
80005b2e:	99 1b       	st.w	r12[0x4],r11

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80005b30:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80005b32:	78 08       	ld.w	r8,r12[0x0]
80005b34:	2f f8       	sub	r8,-1
80005b36:	99 08       	st.w	r12[0x0],r8
}
80005b38:	5e fc       	retal	r12

80005b3a <vListInsert>:
{
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
80005b3a:	76 0a       	ld.w	r10,r11[0x0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
80005b3c:	5b fa       	cp.w	r10,-1
80005b3e:	c0 31       	brne	80005b44 <vListInsert+0xa>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
80005b40:	78 48       	ld.w	r8,r12[0x10]
80005b42:	c0 c8       	rjmp	80005b5a <vListInsert+0x20>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
80005b44:	f8 c8 ff f8 	sub	r8,r12,-8
80005b48:	70 19       	ld.w	r9,r8[0x4]
80005b4a:	72 09       	ld.w	r9,r9[0x0]
80005b4c:	12 3a       	cp.w	r10,r9
80005b4e:	c0 63       	brcs	80005b5a <vListInsert+0x20>
80005b50:	70 18       	ld.w	r8,r8[0x4]
80005b52:	70 19       	ld.w	r9,r8[0x4]
80005b54:	72 09       	ld.w	r9,r9[0x0]
80005b56:	12 3a       	cp.w	r10,r9
80005b58:	cf c2       	brcc	80005b50 <vListInsert+0x16>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
80005b5a:	70 19       	ld.w	r9,r8[0x4]
80005b5c:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80005b5e:	93 2b       	st.w	r9[0x8],r11
	pxNewListItem->pxPrevious = pxIterator;
80005b60:	97 28       	st.w	r11[0x8],r8
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
80005b62:	91 1b       	st.w	r8[0x4],r11

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80005b64:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80005b66:	78 08       	ld.w	r8,r12[0x0]
80005b68:	2f f8       	sub	r8,-1
80005b6a:	99 08       	st.w	r12[0x0],r8
}
80005b6c:	5e fc       	retal	r12

80005b6e <vListRemove>:

void vListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
80005b6e:	78 18       	ld.w	r8,r12[0x4]
80005b70:	78 29       	ld.w	r9,r12[0x8]
80005b72:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
80005b74:	78 28       	ld.w	r8,r12[0x8]
80005b76:	78 19       	ld.w	r9,r12[0x4]
80005b78:	91 19       	st.w	r8[0x4],r9

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
80005b7a:	78 48       	ld.w	r8,r12[0x10]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
80005b7c:	70 19       	ld.w	r9,r8[0x4]
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
80005b7e:	18 39       	cp.w	r9,r12
80005b80:	f9 f9 00 02 	ld.weq	r9,r12[0x8]
80005b84:	f1 f9 0a 01 	st.weq	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
80005b88:	30 09       	mov	r9,0
80005b8a:	99 49       	st.w	r12[0x10],r9
	( pxList->uxNumberOfItems )--;
80005b8c:	70 09       	ld.w	r9,r8[0x0]
80005b8e:	20 19       	sub	r9,1
80005b90:	91 09       	st.w	r8[0x0],r9
}
80005b92:	5e fc       	retal	r12

80005b94 <pxPortInitialiseStack>:
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x08080808;					/* R8 */
80005b94:	e0 68 08 08 	mov	r8,2056
80005b98:	ea 18 08 08 	orh	r8,0x808
80005b9c:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x09090909;					/* R9 */
80005b9e:	e0 68 09 09 	mov	r8,2313
80005ba2:	ea 18 09 09 	orh	r8,0x909
80005ba6:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0A0A0A0A;					/* R10 */
80005ba8:	e0 68 0a 0a 	mov	r8,2570
80005bac:	ea 18 0a 0a 	orh	r8,0xa0a
80005bb0:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0B0B0B0B;					/* R11 */
80005bb2:	e0 68 0b 0b 	mov	r8,2827
80005bb6:	ea 18 0b 0b 	orh	r8,0xb0b
80005bba:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pvParameters;					/* R12 */
80005bbc:	18 da       	st.w	--r12,r10
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xDEADBEEF;					/* R14/LR */
80005bbe:	e0 68 be ef 	mov	r8,48879
80005bc2:	ea 18 de ad 	orh	r8,0xdead
80005bc6:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
80005bc8:	18 db       	st.w	--r12,r11
	*pxTopOfStack-- = ( portSTACK_TYPE ) portINITIAL_SR;				/* SR */
80005bca:	fc 18 00 40 	movh	r8,0x40
80005bce:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xFF0000FF;					/* R0 */
80005bd0:	e0 68 00 ff 	mov	r8,255
80005bd4:	ea 18 ff 00 	orh	r8,0xff00
80005bd8:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x01010101;					/* R1 */
80005bda:	e0 68 01 01 	mov	r8,257
80005bde:	ea 18 01 01 	orh	r8,0x101
80005be2:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x02020202;					/* R2 */
80005be4:	e0 68 02 02 	mov	r8,514
80005be8:	ea 18 02 02 	orh	r8,0x202
80005bec:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x03030303;					/* R3 */
80005bee:	e0 68 03 03 	mov	r8,771
80005bf2:	ea 18 03 03 	orh	r8,0x303
80005bf6:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x04040404;					/* R4 */
80005bf8:	e0 68 04 04 	mov	r8,1028
80005bfc:	ea 18 04 04 	orh	r8,0x404
80005c00:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x05050505;					/* R5 */
80005c02:	e0 68 05 05 	mov	r8,1285
80005c06:	ea 18 05 05 	orh	r8,0x505
80005c0a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x06060606;					/* R6 */
80005c0c:	e0 68 06 06 	mov	r8,1542
80005c10:	ea 18 06 06 	orh	r8,0x606
80005c14:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x07070707;					/* R7 */
80005c16:	e0 68 07 07 	mov	r8,1799
80005c1a:	ea 18 07 07 	orh	r8,0x707
80005c1e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack = ( portSTACK_TYPE ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
80005c20:	30 08       	mov	r8,0
80005c22:	18 d8       	st.w	--r12,r8

	return pxTopOfStack;
}
80005c24:	5e fc       	retal	r12
80005c26:	d7 03       	nop

80005c28 <vPortEnterCritical>:
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
80005c28:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
80005c2a:	48 38       	lddpc	r8,80005c34 <vPortEnterCritical+0xc>
80005c2c:	70 09       	ld.w	r9,r8[0x0]
80005c2e:	2f f9       	sub	r9,-1
80005c30:	91 09       	st.w	r8[0x0],r9
}
80005c32:	5e fc       	retal	r12
80005c34:	00 00       	add	r0,r0
80005c36:	05 34       	ld.ub	r4,r2++

80005c38 <xPortStartScheduler>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
80005c38:	d4 01       	pushm	lr
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
80005c3a:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
80005c3c:	30 0a       	mov	r10,0
80005c3e:	14 9b       	mov	r11,r10
80005c40:	49 2c       	lddpc	r12,80005c88 <xPortStartScheduler+0x50>
80005c42:	f0 1f 00 13 	mcall	80005c8c <xPortStartScheduler+0x54>
/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);//cause!!!
80005c46:	e0 68 5d c0 	mov	r8,24000
80005c4a:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
80005c4e:	30 08       	mov	r8,0
80005c50:	e3 b8 00 42 	mtsr	0x108,r8
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Start the first task. */
	portRESTORE_CONTEXT();
80005c54:	e0 68 0c e0 	mov	r8,3296
80005c58:	ea 18 00 00 	orh	r8,0x0
80005c5c:	70 00       	ld.w	r0,r8[0x0]
80005c5e:	60 0d       	ld.w	sp,r0[0x0]
80005c60:	1b 00       	ld.w	r0,sp++
80005c62:	e0 68 05 34 	mov	r8,1332
80005c66:	ea 18 00 00 	orh	r8,0x0
80005c6a:	91 00       	st.w	r8[0x0],r0
80005c6c:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005c70:	2f ed       	sub	sp,-8
80005c72:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
80005c76:	fa f0 ff e0 	ld.w	r0,sp[-32]
80005c7a:	e3 b0 00 00 	mtsr	0x0,r0
80005c7e:	fa f0 ff dc 	ld.w	r0,sp[-36]
80005c82:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
}
80005c86:	d8 0a       	popm	pc,r12=0
80005c88:	80 00       	ld.sh	r0,r0[0x0]
80005c8a:	5d 54       	*unknown*
80005c8c:	80 00       	ld.sh	r0,r0[0x0]
80005c8e:	54 1c       	stdsp	sp[0x104],r12

80005c90 <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
80005c90:	20 6d       	sub	sp,24
80005c92:	eb cd 00 ff 	pushm	r0-r7
80005c96:	fa c7 ff c0 	sub	r7,sp,-64
80005c9a:	ee f0 ff f8 	ld.w	r0,r7[-8]
80005c9e:	ef 40 ff e0 	st.w	r7[-32],r0
80005ca2:	ee f0 ff fc 	ld.w	r0,r7[-4]
80005ca6:	ef 40 ff e4 	st.w	r7[-28],r0
80005caa:	eb c7 5f 00 	stm	--r7,r8-r12,lr
80005cae:	e0 68 05 34 	mov	r8,1332
80005cb2:	ea 18 00 00 	orh	r8,0x0
80005cb6:	70 00       	ld.w	r0,r8[0x0]
80005cb8:	1a d0       	st.w	--sp,r0
80005cba:	f0 1f 00 1a 	mcall	80005d20 <LABEL_RET_SCALL_263+0x14>
80005cbe:	e0 68 0c e0 	mov	r8,3296
80005cc2:	ea 18 00 00 	orh	r8,0x0
80005cc6:	70 00       	ld.w	r0,r8[0x0]
80005cc8:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
80005cca:	f0 1f 00 17 	mcall	80005d24 <LABEL_RET_SCALL_263+0x18>
	portRESTORE_CONTEXT_SCALL();
80005cce:	e0 68 0c e0 	mov	r8,3296
80005cd2:	ea 18 00 00 	orh	r8,0x0
80005cd6:	70 00       	ld.w	r0,r8[0x0]
80005cd8:	60 0d       	ld.w	sp,r0[0x0]
80005cda:	1b 00       	ld.w	r0,sp++
80005cdc:	e0 68 05 34 	mov	r8,1332
80005ce0:	ea 18 00 00 	orh	r8,0x0
80005ce4:	91 00       	st.w	r8[0x0],r0
80005ce6:	fa c7 ff d8 	sub	r7,sp,-40
80005cea:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
80005cee:	ee f0 ff e0 	ld.w	r0,r7[-32]
80005cf2:	e0 61 05 34 	mov	r1,1332
80005cf6:	ea 11 00 00 	orh	r1,0x0
80005cfa:	62 02       	ld.w	r2,r1[0x0]
80005cfc:	58 02       	cp.w	r2,0
80005cfe:	c0 70       	breq	80005d0c <LABEL_RET_SCALL_263>
80005d00:	e4 c2 00 01 	sub	r2,r2,1
80005d04:	83 02       	st.w	r1[0x0],r2
80005d06:	58 02       	cp.w	r2,0
80005d08:	c0 21       	brne	80005d0c <LABEL_RET_SCALL_263>
80005d0a:	b1 c0       	cbr	r0,0x10

80005d0c <LABEL_RET_SCALL_263>:
80005d0c:	ef 40 ff f8 	st.w	r7[-8],r0
80005d10:	ee f0 ff e4 	ld.w	r0,r7[-28]
80005d14:	ef 40 ff fc 	st.w	r7[-4],r0
80005d18:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005d1c:	2f ad       	sub	sp,-24
80005d1e:	d6 13       	rets
80005d20:	80 00       	ld.sh	r0,r0[0x0]
80005d22:	5c 28       	cpc	r8
80005d24:	80 00       	ld.sh	r0,r0[0x0]
80005d26:	63 6c       	ld.w	r12,r1[0x58]

80005d28 <prvClearCcInt>:
		Set_system_register(AVR32_COUNT, 0);
	}

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
80005d28:	e1 b8 00 43 	mfsr	r8,0x10c
80005d2c:	e3 b8 00 43 	mtsr	0x10c,r8
	}
80005d30:	5e fc       	retal	r12
80005d32:	d7 03       	nop

80005d34 <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
80005d34:	48 78       	lddpc	r8,80005d50 <vPortExitCritical+0x1c>
80005d36:	70 08       	ld.w	r8,r8[0x0]
80005d38:	58 08       	cp.w	r8,0
80005d3a:	5e 0c       	reteq	r12
	{
		ulCriticalNesting--;
80005d3c:	48 58       	lddpc	r8,80005d50 <vPortExitCritical+0x1c>
80005d3e:	70 09       	ld.w	r9,r8[0x0]
80005d40:	20 19       	sub	r9,1
80005d42:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
80005d44:	70 08       	ld.w	r8,r8[0x0]
80005d46:	58 08       	cp.w	r8,0
80005d48:	5e 1c       	retne	r12
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
80005d4a:	d5 03       	csrf	0x10
80005d4c:	5e fc       	retal	r12
80005d4e:	00 00       	add	r0,r0
80005d50:	00 00       	add	r0,r0
80005d52:	05 34       	ld.ub	r4,r2++

80005d54 <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
80005d54:	eb cd 00 ff 	pushm	r0-r7
80005d58:	e0 68 05 34 	mov	r8,1332
80005d5c:	ea 18 00 00 	orh	r8,0x0
80005d60:	70 00       	ld.w	r0,r8[0x0]
80005d62:	1a d0       	st.w	--sp,r0
80005d64:	7a 90       	ld.w	r0,sp[0x24]
80005d66:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80005d6a:	58 10       	cp.w	r0,1
80005d6c:	e0 8b 00 08 	brhi	80005d7c <LABEL_INT_SKIP_SAVE_CONTEXT_237>
80005d70:	e0 68 0c e0 	mov	r8,3296
80005d74:	ea 18 00 00 	orh	r8,0x0
80005d78:	70 00       	ld.w	r0,r8[0x0]
80005d7a:	81 0d       	st.w	r0[0x0],sp

80005d7c <LABEL_INT_SKIP_SAVE_CONTEXT_237>:
	#if( configTICK_USE_TC==1 )
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Clear the interrupt flag. */
		prvClearCcInt();
80005d7c:	f0 1f 00 12 	mcall	80005dc4 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
80005d80:	f0 1f 00 12 	mcall	80005dc8 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
		vTaskIncrementTick();
80005d84:	f0 1f 00 12 	mcall	80005dcc <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x1c>
	portEXIT_CRITICAL();
80005d88:	f0 1f 00 12 	mcall	80005dd0 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
80005d8c:	7a 90       	ld.w	r0,sp[0x24]
80005d8e:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80005d92:	58 10       	cp.w	r0,1
80005d94:	e0 8b 00 0e 	brhi	80005db0 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>
80005d98:	f0 1f 00 0c 	mcall	80005dc8 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
80005d9c:	f0 1f 00 0e 	mcall	80005dd4 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x24>
80005da0:	f0 1f 00 0c 	mcall	80005dd0 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>
80005da4:	e0 68 0c e0 	mov	r8,3296
80005da8:	ea 18 00 00 	orh	r8,0x0
80005dac:	70 00       	ld.w	r0,r8[0x0]
80005dae:	60 0d       	ld.w	sp,r0[0x0]

80005db0 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>:
80005db0:	1b 00       	ld.w	r0,sp++
80005db2:	e0 68 05 34 	mov	r8,1332
80005db6:	ea 18 00 00 	orh	r8,0x0
80005dba:	91 00       	st.w	r8[0x0],r0
80005dbc:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005dc0:	d6 03       	rete
80005dc2:	00 00       	add	r0,r0
80005dc4:	80 00       	ld.sh	r0,r0[0x0]
80005dc6:	5d 28       	mustr	r8
80005dc8:	80 00       	ld.sh	r0,r0[0x0]
80005dca:	5c 28       	cpc	r8
80005dcc:	80 00       	ld.sh	r0,r0[0x0]
80005dce:	65 70       	ld.w	r0,r2[0x5c]
80005dd0:	80 00       	ld.sh	r0,r0[0x0]
80005dd2:	5d 34       	musfr	r4
80005dd4:	80 00       	ld.sh	r0,r0[0x0]
80005dd6:	63 6c       	ld.w	r12,r1[0x58]

80005dd8 <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
80005dd8:	d4 01       	pushm	lr
	vTaskSuspendAll();
80005dda:	f0 1f 00 02 	mcall	80005de0 <__malloc_lock+0x8>
}
80005dde:	d8 02       	popm	pc
80005de0:	80 00       	ld.sh	r0,r0[0x0]
80005de2:	63 5c       	ld.w	r12,r1[0x54]

80005de4 <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
80005de4:	d4 01       	pushm	lr
	xTaskResumeAll();
80005de6:	f0 1f 00 02 	mcall	80005dec <__malloc_unlock+0x8>
}
80005dea:	d8 02       	popm	pc
80005dec:	80 00       	ld.sh	r0,r0[0x0]
80005dee:	67 18       	ld.w	r8,r3[0x44]

80005df0 <_read>:
/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
{
80005df0:	d4 21       	pushm	r4-r7,lr
80005df2:	16 95       	mov	r5,r11
80005df4:	14 96       	mov	r6,r10
  int nChars = 0;

  if (file != 0)
80005df6:	58 0c       	cp.w	r12,0
80005df8:	c0 30       	breq	80005dfe <_read+0xe>
80005dfa:	3f f7       	mov	r7,-1
80005dfc:	c1 48       	rjmp	80005e24 <_read+0x34>
    return -1;

  for (; len > 0; --len)
80005dfe:	58 0a       	cp.w	r10,0
80005e00:	e0 89 00 04 	brgt	80005e08 <_read+0x18>
80005e04:	30 07       	mov	r7,0
80005e06:	c0 f8       	rjmp	80005e24 <_read+0x34>
80005e08:	30 07       	mov	r7,0
  {
    int c = usart_getchar(stdio_usart_base);
80005e0a:	48 84       	lddpc	r4,80005e28 <_read+0x38>
80005e0c:	68 0c       	ld.w	r12,r4[0x0]
80005e0e:	f0 1f 00 08 	mcall	80005e2c <_read+0x3c>
    if (c < 0)
80005e12:	c0 95       	brlt	80005e24 <_read+0x34>
      break;

    *ptr++ = c;
80005e14:	ea 07 0b 0c 	st.b	r5[r7],r12
    ++nChars;
80005e18:	2f f7       	sub	r7,-1

/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
80005e1a:	ec 07 01 08 	sub	r8,r6,r7
  int nChars = 0;

  if (file != 0)
    return -1;

  for (; len > 0; --len)
80005e1e:	58 08       	cp.w	r8,0
80005e20:	fe 99 ff f6 	brgt	80005e0c <_read+0x1c>
    *ptr++ = c;
    ++nChars;
  }

  return nChars;
}
80005e24:	0e 9c       	mov	r12,r7
80005e26:	d8 22       	popm	r4-r7,pc
80005e28:	00 00       	add	r0,r0
80005e2a:	63 94       	ld.w	r4,r1[0x64]
80005e2c:	80 00       	ld.sh	r0,r0[0x0]
80005e2e:	59 bc       	cp.w	r12,27

80005e30 <_write>:
 * 1 and 2 is stdout and stderr which goes to usart
 * 3 is framebuffer
 */
int __attribute__((weak))
_write (int file, char * ptr, int len)
{
80005e30:	d4 21       	pushm	r4-r7,lr
80005e32:	16 95       	mov	r5,r11
80005e34:	14 96       	mov	r6,r10
  int nChars = 0;

  if ( (file != 1)
80005e36:	20 1c       	sub	r12,1
80005e38:	58 2c       	cp.w	r12,2
80005e3a:	e0 8b 00 12 	brhi	80005e5e <_write+0x2e>
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80005e3e:	58 0a       	cp.w	r10,0
80005e40:	c0 31       	brne	80005e46 <_write+0x16>
80005e42:	30 07       	mov	r7,0
80005e44:	c0 e8       	rjmp	80005e60 <_write+0x30>
80005e46:	30 07       	mov	r7,0
  {
    if (usart_putchar(stdio_usart_base, *ptr++) < 0)
80005e48:	48 74       	lddpc	r4,80005e64 <_write+0x34>
80005e4a:	68 0c       	ld.w	r12,r4[0x0]
80005e4c:	ea 07 07 0b 	ld.ub	r11,r5[r7]
80005e50:	f0 1f 00 06 	mcall	80005e68 <_write+0x38>
80005e54:	c0 55       	brlt	80005e5e <_write+0x2e>
    {
      return -1;
    }

    ++nChars;
80005e56:	2f f7       	sub	r7,-1

  if ( (file != 1)
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80005e58:	0e 36       	cp.w	r6,r7
80005e5a:	cf 81       	brne	80005e4a <_write+0x1a>
80005e5c:	c0 28       	rjmp	80005e60 <_write+0x30>
80005e5e:	3f f7       	mov	r7,-1

    ++nChars;
  }

  return nChars;
}
80005e60:	0e 9c       	mov	r12,r7
80005e62:	d8 22       	popm	r4-r7,pc
80005e64:	00 00       	add	r0,r0
80005e66:	63 94       	ld.w	r4,r1[0x64]
80005e68:	80 00       	ld.sh	r0,r0[0x0]
80005e6a:	59 6c       	cp.w	r12,22

80005e6c <vPortFree>:
	return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
80005e6c:	eb cd 40 80 	pushm	r7,lr
80005e70:	18 97       	mov	r7,r12
	if( pv )
80005e72:	58 0c       	cp.w	r12,0
80005e74:	c0 80       	breq	80005e84 <vPortFree+0x18>
	{
		vTaskSuspendAll();
80005e76:	f0 1f 00 05 	mcall	80005e88 <vPortFree+0x1c>
		{
			free( pv );
80005e7a:	0e 9c       	mov	r12,r7
80005e7c:	f0 1f 00 04 	mcall	80005e8c <vPortFree+0x20>
		}
		xTaskResumeAll();
80005e80:	f0 1f 00 04 	mcall	80005e90 <vPortFree+0x24>
80005e84:	e3 cd 80 80 	ldm	sp++,r7,pc
80005e88:	80 00       	ld.sh	r0,r0[0x0]
80005e8a:	63 5c       	ld.w	r12,r1[0x54]
80005e8c:	80 00       	ld.sh	r0,r0[0x0]
80005e8e:	72 bc       	ld.w	r12,r9[0x2c]
80005e90:	80 00       	ld.sh	r0,r0[0x0]
80005e92:	67 18       	ld.w	r8,r3[0x44]

80005e94 <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
80005e94:	eb cd 40 80 	pushm	r7,lr
80005e98:	18 97       	mov	r7,r12
void *pvReturn;

	vTaskSuspendAll();
80005e9a:	f0 1f 00 06 	mcall	80005eb0 <pvPortMalloc+0x1c>
	{
		pvReturn = malloc( xWantedSize );
80005e9e:	0e 9c       	mov	r12,r7
80005ea0:	f0 1f 00 05 	mcall	80005eb4 <pvPortMalloc+0x20>
80005ea4:	18 97       	mov	r7,r12
	}
	xTaskResumeAll();
80005ea6:	f0 1f 00 05 	mcall	80005eb8 <pvPortMalloc+0x24>
		}
	}
	#endif

	return pvReturn;
}
80005eaa:	0e 9c       	mov	r12,r7
80005eac:	e3 cd 80 80 	ldm	sp++,r7,pc
80005eb0:	80 00       	ld.sh	r0,r0[0x0]
80005eb2:	63 5c       	ld.w	r12,r1[0x54]
80005eb4:	80 00       	ld.sh	r0,r0[0x0]
80005eb6:	72 cc       	ld.w	r12,r9[0x30]
80005eb8:	80 00       	ld.sh	r0,r0[0x0]
80005eba:	67 18       	ld.w	r8,r3[0x44]

80005ebc <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
80005ebc:	d4 01       	pushm	lr
80005ebe:	16 98       	mov	r8,r11
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
80005ec0:	78 09       	ld.w	r9,r12[0x0]
80005ec2:	58 09       	cp.w	r9,0
80005ec4:	c1 10       	breq	80005ee6 <prvCopyDataFromQueue+0x2a>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
80005ec6:	78 3a       	ld.w	r10,r12[0xc]
80005ec8:	79 09       	ld.w	r9,r12[0x40]
80005eca:	f4 09 00 09 	add	r9,r10,r9
80005ece:	99 39       	st.w	r12[0xc],r9
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
80005ed0:	78 1a       	ld.w	r10,r12[0x4]
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
80005ed2:	14 39       	cp.w	r9,r10
80005ed4:	f9 f9 20 00 	ld.wcc	r9,r12[0x0]
80005ed8:	f9 f9 2a 03 	st.wcc	r12[0xc],r9
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
80005edc:	79 0a       	ld.w	r10,r12[0x40]
80005ede:	78 3b       	ld.w	r11,r12[0xc]
80005ee0:	10 9c       	mov	r12,r8
80005ee2:	f0 1f 00 02 	mcall	80005ee8 <prvCopyDataFromQueue+0x2c>
80005ee6:	d8 02       	popm	pc
80005ee8:	80 00       	ld.sh	r0,r0[0x0]
80005eea:	77 3a       	ld.w	r10,r11[0x4c]

80005eec <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
80005eec:	eb cd 40 c0 	pushm	r6-r7,lr
80005ef0:	18 97       	mov	r7,r12
80005ef2:	14 96       	mov	r6,r10
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80005ef4:	78 e8       	ld.w	r8,r12[0x38]
80005ef6:	58 08       	cp.w	r8,0
80005ef8:	c0 31       	brne	80005efe <xQueueReceiveFromISR+0x12>
80005efa:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
80005efe:	f0 1f 00 0e 	mcall	80005f34 <xQueueReceiveFromISR+0x48>
			--( pxQueue->uxMessagesWaiting );
80005f02:	6e e8       	ld.w	r8,r7[0x38]
80005f04:	20 18       	sub	r8,1
80005f06:	8f e8       	st.w	r7[0x38],r8

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
80005f08:	6f 18       	ld.w	r8,r7[0x44]
80005f0a:	5b f8       	cp.w	r8,-1
80005f0c:	c0 d1       	brne	80005f26 <xQueueReceiveFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005f0e:	6e 48       	ld.w	r8,r7[0x10]
80005f10:	58 08       	cp.w	r8,0
80005f12:	c0 f0       	breq	80005f30 <xQueueReceiveFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80005f14:	ee cc ff f0 	sub	r12,r7,-16
80005f18:	f0 1f 00 08 	mcall	80005f38 <xQueueReceiveFromISR+0x4c>
80005f1c:	c0 a0       	breq	80005f30 <xQueueReceiveFromISR+0x44>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
80005f1e:	30 1c       	mov	r12,1
80005f20:	8d 0c       	st.w	r6[0x0],r12
80005f22:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
80005f26:	2f f8       	sub	r8,-1
80005f28:	ef 48 00 44 	st.w	r7[68],r8
80005f2c:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80005f30:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80005f34:	80 00       	ld.sh	r0,r0[0x0]
80005f36:	5e bc       	rethi	r12
80005f38:	80 00       	ld.sh	r0,r0[0x0]
80005f3a:	64 f4       	ld.w	r4,r2[0x3c]

80005f3c <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
80005f3c:	eb cd 40 c0 	pushm	r6-r7,lr
80005f40:	18 97       	mov	r7,r12

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
80005f42:	f0 1f 00 23 	mcall	80005fcc <prvUnlockQueue+0x90>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80005f46:	6f 28       	ld.w	r8,r7[0x48]
80005f48:	58 08       	cp.w	r8,0
80005f4a:	e0 8a 00 18 	brle	80005f7a <prvUnlockQueue+0x3e>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005f4e:	6e 98       	ld.w	r8,r7[0x24]
80005f50:	58 08       	cp.w	r8,0
80005f52:	c1 40       	breq	80005f7a <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80005f54:	ee c6 ff dc 	sub	r6,r7,-36
80005f58:	c0 48       	rjmp	80005f60 <prvUnlockQueue+0x24>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005f5a:	6e 98       	ld.w	r8,r7[0x24]
80005f5c:	58 08       	cp.w	r8,0
80005f5e:	c0 e0       	breq	80005f7a <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80005f60:	0c 9c       	mov	r12,r6
80005f62:	f0 1f 00 1c 	mcall	80005fd0 <prvUnlockQueue+0x94>
80005f66:	c0 30       	breq	80005f6c <prvUnlockQueue+0x30>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
80005f68:	f0 1f 00 1b 	mcall	80005fd4 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xTxLock );
80005f6c:	6f 28       	ld.w	r8,r7[0x48]
80005f6e:	20 18       	sub	r8,1
80005f70:	ef 48 00 48 	st.w	r7[72],r8
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80005f74:	58 08       	cp.w	r8,0
80005f76:	fe 99 ff f2 	brgt	80005f5a <prvUnlockQueue+0x1e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
80005f7a:	3f f8       	mov	r8,-1
80005f7c:	ef 48 00 48 	st.w	r7[72],r8
	}
	taskEXIT_CRITICAL();
80005f80:	f0 1f 00 16 	mcall	80005fd8 <prvUnlockQueue+0x9c>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
80005f84:	f0 1f 00 12 	mcall	80005fcc <prvUnlockQueue+0x90>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80005f88:	6f 18       	ld.w	r8,r7[0x44]
80005f8a:	58 08       	cp.w	r8,0
80005f8c:	e0 8a 00 18 	brle	80005fbc <prvUnlockQueue+0x80>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005f90:	6e 48       	ld.w	r8,r7[0x10]
80005f92:	58 08       	cp.w	r8,0
80005f94:	c1 40       	breq	80005fbc <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80005f96:	ee c6 ff f0 	sub	r6,r7,-16
80005f9a:	c0 48       	rjmp	80005fa2 <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005f9c:	6e 48       	ld.w	r8,r7[0x10]
80005f9e:	58 08       	cp.w	r8,0
80005fa0:	c0 e0       	breq	80005fbc <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80005fa2:	0c 9c       	mov	r12,r6
80005fa4:	f0 1f 00 0b 	mcall	80005fd0 <prvUnlockQueue+0x94>
80005fa8:	c0 30       	breq	80005fae <prvUnlockQueue+0x72>
				{
					vTaskMissedYield();
80005faa:	f0 1f 00 0b 	mcall	80005fd4 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xRxLock );
80005fae:	6f 18       	ld.w	r8,r7[0x44]
80005fb0:	20 18       	sub	r8,1
80005fb2:	ef 48 00 44 	st.w	r7[68],r8
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80005fb6:	58 08       	cp.w	r8,0
80005fb8:	fe 99 ff f2 	brgt	80005f9c <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
80005fbc:	3f f8       	mov	r8,-1
80005fbe:	ef 48 00 44 	st.w	r7[68],r8
	}
	taskEXIT_CRITICAL();
80005fc2:	f0 1f 00 06 	mcall	80005fd8 <prvUnlockQueue+0x9c>
}
80005fc6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005fca:	00 00       	add	r0,r0
80005fcc:	80 00       	ld.sh	r0,r0[0x0]
80005fce:	5c 28       	cpc	r8
80005fd0:	80 00       	ld.sh	r0,r0[0x0]
80005fd2:	64 f4       	ld.w	r4,r2[0x3c]
80005fd4:	80 00       	ld.sh	r0,r0[0x0]
80005fd6:	64 00       	ld.w	r0,r2[0x0]
80005fd8:	80 00       	ld.sh	r0,r0[0x0]
80005fda:	5d 34       	musfr	r4

80005fdc <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
80005fdc:	d4 31       	pushm	r0-r7,lr
80005fde:	20 5d       	sub	sp,20
80005fe0:	18 97       	mov	r7,r12
80005fe2:	50 0b       	stdsp	sp[0x0],r11
80005fe4:	50 2a       	stdsp	sp[0x8],r10
80005fe6:	50 19       	stdsp	sp[0x4],r9
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80005fe8:	f8 c2 ff dc 	sub	r2,r12,-36
80005fec:	30 05       	mov	r5,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80005fee:	fa c4 ff f4 	sub	r4,sp,-12
80005ff2:	30 10       	mov	r0,1

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80005ff4:	0a 91       	mov	r1,r5

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80005ff6:	fa c3 ff f8 	sub	r3,sp,-8
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
80005ffa:	f0 1f 00 3e 	mcall	800060f0 <xQueueGenericReceive+0x114>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80005ffe:	6e e8       	ld.w	r8,r7[0x38]
80006000:	58 08       	cp.w	r8,0
80006002:	c2 a0       	breq	80006056 <xQueueGenericReceive+0x7a>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
80006004:	6e 36       	ld.w	r6,r7[0xc]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
80006006:	40 0b       	lddsp	r11,sp[0x0]
80006008:	0e 9c       	mov	r12,r7
8000600a:	f0 1f 00 3b 	mcall	800060f4 <xQueueGenericReceive+0x118>

				if( xJustPeeking == pdFALSE )
8000600e:	40 18       	lddsp	r8,sp[0x4]
80006010:	58 08       	cp.w	r8,0
80006012:	c1 51       	brne	8000603c <xQueueGenericReceive+0x60>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
80006014:	6e e8       	ld.w	r8,r7[0x38]
80006016:	20 18       	sub	r8,1
80006018:	8f e8       	st.w	r7[0x38],r8

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
8000601a:	6e 08       	ld.w	r8,r7[0x0]
8000601c:	58 08       	cp.w	r8,0
8000601e:	c0 41       	brne	80006026 <xQueueGenericReceive+0x4a>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
80006020:	f0 1f 00 36 	mcall	800060f8 <xQueueGenericReceive+0x11c>
80006024:	8f 1c       	st.w	r7[0x4],r12
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80006026:	6e 48       	ld.w	r8,r7[0x10]
80006028:	58 08       	cp.w	r8,0
8000602a:	c1 20       	breq	8000604e <xQueueGenericReceive+0x72>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
8000602c:	ee cc ff f0 	sub	r12,r7,-16
80006030:	f0 1f 00 33 	mcall	800060fc <xQueueGenericReceive+0x120>
80006034:	58 1c       	cp.w	r12,1
80006036:	c0 c1       	brne	8000604e <xQueueGenericReceive+0x72>
						{
							portYIELD_WITHIN_API();
80006038:	d7 33       	scall
8000603a:	c0 a8       	rjmp	8000604e <xQueueGenericReceive+0x72>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
8000603c:	8f 36       	st.w	r7[0xc],r6

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
8000603e:	6e 98       	ld.w	r8,r7[0x24]
80006040:	58 08       	cp.w	r8,0
80006042:	c0 60       	breq	8000604e <xQueueGenericReceive+0x72>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80006044:	04 9c       	mov	r12,r2
80006046:	f0 1f 00 2e 	mcall	800060fc <xQueueGenericReceive+0x120>
8000604a:	c0 20       	breq	8000604e <xQueueGenericReceive+0x72>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
8000604c:	d7 33       	scall
						}
					}

				}

				taskEXIT_CRITICAL();
8000604e:	f0 1f 00 2d 	mcall	80006100 <xQueueGenericReceive+0x124>
80006052:	30 1c       	mov	r12,1
				return pdPASS;
80006054:	c4 c8       	rjmp	800060ec <xQueueGenericReceive+0x110>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
80006056:	40 28       	lddsp	r8,sp[0x8]
80006058:	58 08       	cp.w	r8,0
8000605a:	c0 51       	brne	80006064 <xQueueGenericReceive+0x88>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
8000605c:	f0 1f 00 29 	mcall	80006100 <xQueueGenericReceive+0x124>
80006060:	30 0c       	mov	r12,0
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
80006062:	c4 58       	rjmp	800060ec <xQueueGenericReceive+0x110>
				}
				else if( xEntryTimeSet == pdFALSE )
80006064:	58 05       	cp.w	r5,0
80006066:	c0 51       	brne	80006070 <xQueueGenericReceive+0x94>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80006068:	08 9c       	mov	r12,r4
8000606a:	f0 1f 00 27 	mcall	80006104 <xQueueGenericReceive+0x128>
8000606e:	00 95       	mov	r5,r0
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80006070:	f0 1f 00 24 	mcall	80006100 <xQueueGenericReceive+0x124>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80006074:	f0 1f 00 25 	mcall	80006108 <xQueueGenericReceive+0x12c>
		prvLockQueue( pxQueue );
80006078:	f0 1f 00 1e 	mcall	800060f0 <xQueueGenericReceive+0x114>
8000607c:	6f 18       	ld.w	r8,r7[0x44]
8000607e:	5b f8       	cp.w	r8,-1
80006080:	ef f1 0a 11 	st.weq	r7[0x44],r1
80006084:	6f 28       	ld.w	r8,r7[0x48]
80006086:	5b f8       	cp.w	r8,-1
80006088:	ef f1 0a 12 	st.weq	r7[0x48],r1
8000608c:	f0 1f 00 1d 	mcall	80006100 <xQueueGenericReceive+0x124>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80006090:	06 9b       	mov	r11,r3
80006092:	08 9c       	mov	r12,r4
80006094:	f0 1f 00 1e 	mcall	8000610c <xQueueGenericReceive+0x130>
80006098:	c2 41       	brne	800060e0 <xQueueGenericReceive+0x104>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
8000609a:	f0 1f 00 16 	mcall	800060f0 <xQueueGenericReceive+0x114>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
8000609e:	6e e6       	ld.w	r6,r7[0x38]
	taskEXIT_CRITICAL();
800060a0:	f0 1f 00 18 	mcall	80006100 <xQueueGenericReceive+0x124>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
800060a4:	58 06       	cp.w	r6,0
800060a6:	c1 71       	brne	800060d4 <xQueueGenericReceive+0xf8>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
800060a8:	6e 08       	ld.w	r8,r7[0x0]
800060aa:	58 08       	cp.w	r8,0
800060ac:	c0 81       	brne	800060bc <xQueueGenericReceive+0xe0>
					{
						portENTER_CRITICAL();
800060ae:	f0 1f 00 11 	mcall	800060f0 <xQueueGenericReceive+0x114>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
800060b2:	6e 1c       	ld.w	r12,r7[0x4]
800060b4:	f0 1f 00 17 	mcall	80006110 <xQueueGenericReceive+0x134>
						}
						portEXIT_CRITICAL();
800060b8:	f0 1f 00 12 	mcall	80006100 <xQueueGenericReceive+0x124>
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
800060bc:	40 2b       	lddsp	r11,sp[0x8]
800060be:	04 9c       	mov	r12,r2
800060c0:	f0 1f 00 15 	mcall	80006114 <xQueueGenericReceive+0x138>
				prvUnlockQueue( pxQueue );
800060c4:	0e 9c       	mov	r12,r7
800060c6:	f0 1f 00 15 	mcall	80006118 <xQueueGenericReceive+0x13c>
				if( !xTaskResumeAll() )
800060ca:	f0 1f 00 15 	mcall	8000611c <xQueueGenericReceive+0x140>
800060ce:	c9 61       	brne	80005ffa <xQueueGenericReceive+0x1e>
				{
					portYIELD_WITHIN_API();
800060d0:	d7 33       	scall
800060d2:	c9 4b       	rjmp	80005ffa <xQueueGenericReceive+0x1e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
800060d4:	0e 9c       	mov	r12,r7
800060d6:	f0 1f 00 11 	mcall	80006118 <xQueueGenericReceive+0x13c>
				( void ) xTaskResumeAll();
800060da:	f0 1f 00 11 	mcall	8000611c <xQueueGenericReceive+0x140>
800060de:	c8 eb       	rjmp	80005ffa <xQueueGenericReceive+0x1e>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
800060e0:	0e 9c       	mov	r12,r7
800060e2:	f0 1f 00 0e 	mcall	80006118 <xQueueGenericReceive+0x13c>
			( void ) xTaskResumeAll();
800060e6:	f0 1f 00 0e 	mcall	8000611c <xQueueGenericReceive+0x140>
800060ea:	30 0c       	mov	r12,0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
800060ec:	2f bd       	sub	sp,-20
800060ee:	d8 32       	popm	r0-r7,pc
800060f0:	80 00       	ld.sh	r0,r0[0x0]
800060f2:	5c 28       	cpc	r8
800060f4:	80 00       	ld.sh	r0,r0[0x0]
800060f6:	5e bc       	rethi	r12
800060f8:	80 00       	ld.sh	r0,r0[0x0]
800060fa:	64 0c       	ld.w	r12,r2[0x0]
800060fc:	80 00       	ld.sh	r0,r0[0x0]
800060fe:	64 f4       	ld.w	r4,r2[0x3c]
80006100:	80 00       	ld.sh	r0,r0[0x0]
80006102:	5d 34       	musfr	r4
80006104:	80 00       	ld.sh	r0,r0[0x0]
80006106:	63 e8       	ld.w	r8,r1[0x78]
80006108:	80 00       	ld.sh	r0,r0[0x0]
8000610a:	63 5c       	ld.w	r12,r1[0x54]
8000610c:	80 00       	ld.sh	r0,r0[0x0]
8000610e:	66 84       	ld.w	r4,r3[0x20]
80006110:	80 00       	ld.sh	r0,r0[0x0]
80006112:	64 70       	ld.w	r0,r2[0x1c]
80006114:	80 00       	ld.sh	r0,r0[0x0]
80006116:	68 dc       	ld.w	r12,r4[0x34]
80006118:	80 00       	ld.sh	r0,r0[0x0]
8000611a:	5f 3c       	srlo	r12
8000611c:	80 00       	ld.sh	r0,r0[0x0]
8000611e:	67 18       	ld.w	r8,r3[0x44]

80006120 <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
80006120:	eb cd 40 80 	pushm	r7,lr
80006124:	18 97       	mov	r7,r12
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
80006126:	79 08       	ld.w	r8,r12[0x40]
80006128:	58 08       	cp.w	r8,0
8000612a:	c0 a1       	brne	8000613e <prvCopyDataToQueue+0x1e>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
8000612c:	78 08       	ld.w	r8,r12[0x0]
8000612e:	58 08       	cp.w	r8,0
80006130:	c2 b1       	brne	80006186 <prvCopyDataToQueue+0x66>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
80006132:	78 1c       	ld.w	r12,r12[0x4]
80006134:	f0 1f 00 17 	mcall	80006190 <prvCopyDataToQueue+0x70>
				pxQueue->pxMutexHolder = NULL;
80006138:	30 08       	mov	r8,0
8000613a:	8f 18       	st.w	r7[0x4],r8
8000613c:	c2 58       	rjmp	80006186 <prvCopyDataToQueue+0x66>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
8000613e:	58 0a       	cp.w	r10,0
80006140:	c1 01       	brne	80006160 <prvCopyDataToQueue+0x40>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80006142:	10 9a       	mov	r10,r8
80006144:	78 2c       	ld.w	r12,r12[0x8]
80006146:	f0 1f 00 14 	mcall	80006194 <prvCopyDataToQueue+0x74>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
8000614a:	6e 29       	ld.w	r9,r7[0x8]
8000614c:	6f 08       	ld.w	r8,r7[0x40]
8000614e:	f2 08 00 08 	add	r8,r9,r8
80006152:	8f 28       	st.w	r7[0x8],r8
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
80006154:	6e 19       	ld.w	r9,r7[0x4]
80006156:	12 38       	cp.w	r8,r9
80006158:	c1 73       	brcs	80006186 <prvCopyDataToQueue+0x66>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
8000615a:	6e 08       	ld.w	r8,r7[0x0]
8000615c:	8f 28       	st.w	r7[0x8],r8
8000615e:	c1 48       	rjmp	80006186 <prvCopyDataToQueue+0x66>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80006160:	10 9a       	mov	r10,r8
80006162:	78 3c       	ld.w	r12,r12[0xc]
80006164:	f0 1f 00 0c 	mcall	80006194 <prvCopyDataToQueue+0x74>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
80006168:	6f 08       	ld.w	r8,r7[0x40]
8000616a:	6e 39       	ld.w	r9,r7[0xc]
8000616c:	f2 08 01 08 	sub	r8,r9,r8
80006170:	8f 38       	st.w	r7[0xc],r8
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
80006172:	6e 09       	ld.w	r9,r7[0x0]
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
80006174:	12 38       	cp.w	r8,r9
80006176:	ef f8 30 10 	ld.wcs	r8,r7[0x40]
8000617a:	ef f9 30 01 	ld.wcs	r9,r7[0x4]
8000617e:	f3 d8 e3 19 	subcs	r9,r9,r8
80006182:	ef f9 3a 03 	st.wcs	r7[0xc],r9
		}
	}

	++( pxQueue->uxMessagesWaiting );
80006186:	6e e8       	ld.w	r8,r7[0x38]
80006188:	2f f8       	sub	r8,-1
8000618a:	8f e8       	st.w	r7[0x38],r8
}
8000618c:	e3 cd 80 80 	ldm	sp++,r7,pc
80006190:	80 00       	ld.sh	r0,r0[0x0]
80006192:	64 18       	ld.w	r8,r2[0x4]
80006194:	80 00       	ld.sh	r0,r0[0x0]
80006196:	77 3a       	ld.w	r10,r11[0x4c]

80006198 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
80006198:	eb cd 40 c0 	pushm	r6-r7,lr
8000619c:	18 97       	mov	r7,r12
8000619e:	14 96       	mov	r6,r10
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
800061a0:	78 ec       	ld.w	r12,r12[0x38]
800061a2:	6e f8       	ld.w	r8,r7[0x3c]
800061a4:	10 3c       	cp.w	r12,r8
800061a6:	c0 33       	brcs	800061ac <xQueueGenericSendFromISR+0x14>
800061a8:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
800061ac:	12 9a       	mov	r10,r9
800061ae:	0e 9c       	mov	r12,r7
800061b0:	f0 1f 00 0c 	mcall	800061e0 <xQueueGenericSendFromISR+0x48>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
800061b4:	6f 28       	ld.w	r8,r7[0x48]
800061b6:	5b f8       	cp.w	r8,-1
800061b8:	c0 d1       	brne	800061d2 <xQueueGenericSendFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800061ba:	6e 98       	ld.w	r8,r7[0x24]
800061bc:	58 08       	cp.w	r8,0
800061be:	c0 f0       	breq	800061dc <xQueueGenericSendFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
800061c0:	ee cc ff dc 	sub	r12,r7,-36
800061c4:	f0 1f 00 08 	mcall	800061e4 <xQueueGenericSendFromISR+0x4c>
800061c8:	c0 a0       	breq	800061dc <xQueueGenericSendFromISR+0x44>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
800061ca:	30 1c       	mov	r12,1
800061cc:	8d 0c       	st.w	r6[0x0],r12
800061ce:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
800061d2:	2f f8       	sub	r8,-1
800061d4:	ef 48 00 48 	st.w	r7[72],r8
800061d8:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
800061dc:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
800061e0:	80 00       	ld.sh	r0,r0[0x0]
800061e2:	61 20       	ld.w	r0,r0[0x48]
800061e4:	80 00       	ld.sh	r0,r0[0x0]
800061e6:	64 f4       	ld.w	r4,r2[0x3c]

800061e8 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
800061e8:	d4 31       	pushm	r0-r7,lr
800061ea:	20 5d       	sub	sp,20
800061ec:	18 97       	mov	r7,r12
800061ee:	50 0b       	stdsp	sp[0x0],r11
800061f0:	50 2a       	stdsp	sp[0x8],r10
800061f2:	50 19       	stdsp	sp[0x4],r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
800061f4:	f8 c0 ff f0 	sub	r0,r12,-16
800061f8:	30 04       	mov	r4,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
800061fa:	fa c3 ff f4 	sub	r3,sp,-12

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
800061fe:	08 91       	mov	r1,r4

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80006200:	fa c2 ff f8 	sub	r2,sp,-8
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
80006204:	f0 1f 00 2f 	mcall	800062c0 <xQueueGenericSend+0xd8>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80006208:	6e e9       	ld.w	r9,r7[0x38]
8000620a:	6e f8       	ld.w	r8,r7[0x3c]
8000620c:	10 39       	cp.w	r9,r8
8000620e:	c1 42       	brcc	80006236 <xQueueGenericSend+0x4e>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80006210:	40 1a       	lddsp	r10,sp[0x4]
80006212:	40 0b       	lddsp	r11,sp[0x0]
80006214:	0e 9c       	mov	r12,r7
80006216:	f0 1f 00 2c 	mcall	800062c4 <xQueueGenericSend+0xdc>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
8000621a:	6e 98       	ld.w	r8,r7[0x24]
8000621c:	58 08       	cp.w	r8,0
8000621e:	c0 80       	breq	8000622e <xQueueGenericSend+0x46>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
80006220:	ee cc ff dc 	sub	r12,r7,-36
80006224:	f0 1f 00 29 	mcall	800062c8 <xQueueGenericSend+0xe0>
80006228:	58 1c       	cp.w	r12,1
8000622a:	c0 21       	brne	8000622e <xQueueGenericSend+0x46>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
8000622c:	d7 33       	scall
					}
				}

				taskEXIT_CRITICAL();
8000622e:	f0 1f 00 28 	mcall	800062cc <xQueueGenericSend+0xe4>
80006232:	30 1c       	mov	r12,1

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
80006234:	c4 38       	rjmp	800062ba <xQueueGenericSend+0xd2>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
80006236:	40 28       	lddsp	r8,sp[0x8]
80006238:	58 08       	cp.w	r8,0
8000623a:	c0 51       	brne	80006244 <xQueueGenericSend+0x5c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
8000623c:	f0 1f 00 24 	mcall	800062cc <xQueueGenericSend+0xe4>
80006240:	30 0c       	mov	r12,0

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
80006242:	c3 c8       	rjmp	800062ba <xQueueGenericSend+0xd2>
				}
				else if( xEntryTimeSet == pdFALSE )
80006244:	58 04       	cp.w	r4,0
80006246:	c0 51       	brne	80006250 <xQueueGenericSend+0x68>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80006248:	06 9c       	mov	r12,r3
8000624a:	f0 1f 00 22 	mcall	800062d0 <xQueueGenericSend+0xe8>
8000624e:	30 14       	mov	r4,1
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80006250:	f0 1f 00 1f 	mcall	800062cc <xQueueGenericSend+0xe4>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80006254:	f0 1f 00 20 	mcall	800062d4 <xQueueGenericSend+0xec>
		prvLockQueue( pxQueue );
80006258:	f0 1f 00 1a 	mcall	800062c0 <xQueueGenericSend+0xd8>
8000625c:	6f 18       	ld.w	r8,r7[0x44]
8000625e:	5b f8       	cp.w	r8,-1
80006260:	ef f1 0a 11 	st.weq	r7[0x44],r1
80006264:	6f 28       	ld.w	r8,r7[0x48]
80006266:	5b f8       	cp.w	r8,-1
80006268:	ef f1 0a 12 	st.weq	r7[0x48],r1
8000626c:	f0 1f 00 18 	mcall	800062cc <xQueueGenericSend+0xe4>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80006270:	04 9b       	mov	r11,r2
80006272:	06 9c       	mov	r12,r3
80006274:	f0 1f 00 19 	mcall	800062d8 <xQueueGenericSend+0xf0>
80006278:	c1 b1       	brne	800062ae <xQueueGenericSend+0xc6>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
8000627a:	f0 1f 00 12 	mcall	800062c0 <xQueueGenericSend+0xd8>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
8000627e:	6e e5       	ld.w	r5,r7[0x38]
80006280:	6e f6       	ld.w	r6,r7[0x3c]
	taskEXIT_CRITICAL();
80006282:	f0 1f 00 13 	mcall	800062cc <xQueueGenericSend+0xe4>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
80006286:	0c 35       	cp.w	r5,r6
80006288:	c0 d1       	brne	800062a2 <xQueueGenericSend+0xba>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
8000628a:	40 2b       	lddsp	r11,sp[0x8]
8000628c:	00 9c       	mov	r12,r0
8000628e:	f0 1f 00 14 	mcall	800062dc <xQueueGenericSend+0xf4>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
80006292:	0e 9c       	mov	r12,r7
80006294:	f0 1f 00 13 	mcall	800062e0 <xQueueGenericSend+0xf8>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
80006298:	f0 1f 00 13 	mcall	800062e4 <xQueueGenericSend+0xfc>
8000629c:	cb 41       	brne	80006204 <xQueueGenericSend+0x1c>
				{
					portYIELD_WITHIN_API();
8000629e:	d7 33       	scall
800062a0:	cb 2b       	rjmp	80006204 <xQueueGenericSend+0x1c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
800062a2:	0e 9c       	mov	r12,r7
800062a4:	f0 1f 00 0f 	mcall	800062e0 <xQueueGenericSend+0xf8>
				( void ) xTaskResumeAll();
800062a8:	f0 1f 00 0f 	mcall	800062e4 <xQueueGenericSend+0xfc>
800062ac:	ca cb       	rjmp	80006204 <xQueueGenericSend+0x1c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
800062ae:	0e 9c       	mov	r12,r7
800062b0:	f0 1f 00 0c 	mcall	800062e0 <xQueueGenericSend+0xf8>
			( void ) xTaskResumeAll();
800062b4:	f0 1f 00 0c 	mcall	800062e4 <xQueueGenericSend+0xfc>
800062b8:	30 0c       	mov	r12,0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
800062ba:	2f bd       	sub	sp,-20
800062bc:	d8 32       	popm	r0-r7,pc
800062be:	00 00       	add	r0,r0
800062c0:	80 00       	ld.sh	r0,r0[0x0]
800062c2:	5c 28       	cpc	r8
800062c4:	80 00       	ld.sh	r0,r0[0x0]
800062c6:	61 20       	ld.w	r0,r0[0x48]
800062c8:	80 00       	ld.sh	r0,r0[0x0]
800062ca:	64 f4       	ld.w	r4,r2[0x3c]
800062cc:	80 00       	ld.sh	r0,r0[0x0]
800062ce:	5d 34       	musfr	r4
800062d0:	80 00       	ld.sh	r0,r0[0x0]
800062d2:	63 e8       	ld.w	r8,r1[0x78]
800062d4:	80 00       	ld.sh	r0,r0[0x0]
800062d6:	63 5c       	ld.w	r12,r1[0x54]
800062d8:	80 00       	ld.sh	r0,r0[0x0]
800062da:	66 84       	ld.w	r4,r3[0x20]
800062dc:	80 00       	ld.sh	r0,r0[0x0]
800062de:	68 dc       	ld.w	r12,r4[0x34]
800062e0:	80 00       	ld.sh	r0,r0[0x0]
800062e2:	5f 3c       	srlo	r12
800062e4:	80 00       	ld.sh	r0,r0[0x0]
800062e6:	67 18       	ld.w	r8,r3[0x44]

800062e8 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
800062e8:	d4 21       	pushm	r4-r7,lr
800062ea:	18 97       	mov	r7,r12
800062ec:	16 96       	mov	r6,r11
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
800062ee:	58 0c       	cp.w	r12,0
800062f0:	c2 f0       	breq	8000634e <xQueueCreate+0x66>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
800062f2:	34 cc       	mov	r12,76
800062f4:	f0 1f 00 17 	mcall	80006350 <xQueueCreate+0x68>
800062f8:	18 95       	mov	r5,r12
		if( pxNewQueue != NULL )
800062fa:	c2 a0       	breq	8000634e <xQueueCreate+0x66>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
800062fc:	ec 07 02 44 	mul	r4,r6,r7

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
80006300:	e8 cc ff ff 	sub	r12,r4,-1
80006304:	f0 1f 00 13 	mcall	80006350 <xQueueCreate+0x68>
80006308:	8b 0c       	st.w	r5[0x0],r12
			if( pxNewQueue->pcHead != NULL )
8000630a:	c1 e0       	breq	80006346 <xQueueCreate+0x5e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
8000630c:	f8 04 00 04 	add	r4,r12,r4
80006310:	8b 14       	st.w	r5[0x4],r4
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
80006312:	30 08       	mov	r8,0
80006314:	8b e8       	st.w	r5[0x38],r8
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
80006316:	8b 2c       	st.w	r5[0x8],r12
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
80006318:	ee c8 00 01 	sub	r8,r7,1
8000631c:	ad 38       	mul	r8,r6
8000631e:	10 0c       	add	r12,r8
80006320:	8b 3c       	st.w	r5[0xc],r12
				pxNewQueue->uxLength = uxQueueLength;
80006322:	8b f7       	st.w	r5[0x3c],r7
				pxNewQueue->uxItemSize = uxItemSize;
80006324:	eb 46 00 40 	st.w	r5[64],r6
				pxNewQueue->xRxLock = queueUNLOCKED;
80006328:	3f f8       	mov	r8,-1
8000632a:	eb 48 00 44 	st.w	r5[68],r8
				pxNewQueue->xTxLock = queueUNLOCKED;
8000632e:	eb 48 00 48 	st.w	r5[72],r8

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
80006332:	ea cc ff f0 	sub	r12,r5,-16
80006336:	f0 1f 00 08 	mcall	80006354 <xQueueCreate+0x6c>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
8000633a:	ea cc ff dc 	sub	r12,r5,-36
8000633e:	f0 1f 00 06 	mcall	80006354 <xQueueCreate+0x6c>
80006342:	0a 9c       	mov	r12,r5
80006344:	d8 22       	popm	r4-r7,pc
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
80006346:	0a 9c       	mov	r12,r5
80006348:	f0 1f 00 04 	mcall	80006358 <xQueueCreate+0x70>
8000634c:	d8 2a       	popm	r4-r7,pc,r12=0
8000634e:	d8 2a       	popm	r4-r7,pc,r12=0
80006350:	80 00       	ld.sh	r0,r0[0x0]
80006352:	5e 94       	retgt	r4
80006354:	80 00       	ld.sh	r0,r0[0x0]
80006356:	5b 04       	cp.w	r4,-16
80006358:	80 00       	ld.sh	r0,r0[0x0]
8000635a:	5e 6c       	retmi	r12

8000635c <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
8000635c:	48 38       	lddpc	r8,80006368 <vTaskSuspendAll+0xc>
8000635e:	70 09       	ld.w	r9,r8[0x0]
80006360:	2f f9       	sub	r9,-1
80006362:	91 09       	st.w	r8[0x0],r9
}
80006364:	5e fc       	retal	r12
80006366:	00 00       	add	r0,r0
80006368:	00 00       	add	r0,r0
8000636a:	0d 10       	ld.sh	r0,r6++

8000636c <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
8000636c:	49 a8       	lddpc	r8,800063d4 <vTaskSwitchContext+0x68>
8000636e:	70 08       	ld.w	r8,r8[0x0]
80006370:	58 08       	cp.w	r8,0
80006372:	c0 b1       	brne	80006388 <vTaskSwitchContext+0x1c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80006374:	49 98       	lddpc	r8,800063d8 <vTaskSwitchContext+0x6c>
80006376:	70 08       	ld.w	r8,r8[0x0]
80006378:	f0 08 00 28 	add	r8,r8,r8<<0x2
8000637c:	49 89       	lddpc	r9,800063dc <vTaskSwitchContext+0x70>
8000637e:	f2 08 03 28 	ld.w	r8,r9[r8<<0x2]
80006382:	58 08       	cp.w	r8,0
80006384:	c0 60       	breq	80006390 <vTaskSwitchContext+0x24>
80006386:	c1 18       	rjmp	800063a8 <vTaskSwitchContext+0x3c>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
80006388:	30 19       	mov	r9,1
8000638a:	49 68       	lddpc	r8,800063e0 <vTaskSwitchContext+0x74>
8000638c:	91 09       	st.w	r8[0x0],r9
8000638e:	5e fc       	retal	r12

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80006390:	49 28       	lddpc	r8,800063d8 <vTaskSwitchContext+0x6c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80006392:	49 3a       	lddpc	r10,800063dc <vTaskSwitchContext+0x70>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80006394:	70 09       	ld.w	r9,r8[0x0]
80006396:	20 19       	sub	r9,1
80006398:	91 09       	st.w	r8[0x0],r9

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
8000639a:	70 09       	ld.w	r9,r8[0x0]
8000639c:	f2 09 00 29 	add	r9,r9,r9<<0x2
800063a0:	f4 09 03 29 	ld.w	r9,r10[r9<<0x2]
800063a4:	58 09       	cp.w	r9,0
800063a6:	cf 70       	breq	80006394 <vTaskSwitchContext+0x28>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
800063a8:	48 c8       	lddpc	r8,800063d8 <vTaskSwitchContext+0x6c>
800063aa:	70 08       	ld.w	r8,r8[0x0]
800063ac:	f0 08 00 28 	add	r8,r8,r8<<0x2
800063b0:	48 b9       	lddpc	r9,800063dc <vTaskSwitchContext+0x70>
800063b2:	f2 08 00 28 	add	r8,r9,r8<<0x2
800063b6:	70 19       	ld.w	r9,r8[0x4]
800063b8:	72 19       	ld.w	r9,r9[0x4]
800063ba:	91 19       	st.w	r8[0x4],r9
800063bc:	f0 ca ff f8 	sub	r10,r8,-8
800063c0:	14 39       	cp.w	r9,r10
800063c2:	f3 f9 00 01 	ld.weq	r9,r9[0x4]
800063c6:	f1 f9 0a 01 	st.weq	r8[0x4],r9
800063ca:	70 18       	ld.w	r8,r8[0x4]
800063cc:	70 39       	ld.w	r9,r8[0xc]
800063ce:	48 68       	lddpc	r8,800063e4 <vTaskSwitchContext+0x78>
800063d0:	91 09       	st.w	r8[0x0],r9
800063d2:	5e fc       	retal	r12
800063d4:	00 00       	add	r0,r0
800063d6:	0d 10       	ld.sh	r0,r6++
800063d8:	00 00       	add	r0,r0
800063da:	0d 48       	ld.w	r8,--r6
800063dc:	00 00       	add	r0,r0
800063de:	0c 2c       	rsub	r12,r6
800063e0:	00 00       	add	r0,r0
800063e2:	0d 30       	ld.ub	r0,r6++
800063e4:	00 00       	add	r0,r0
800063e6:	0c e0       	st.h	--r6,r0

800063e8 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
800063e8:	48 48       	lddpc	r8,800063f8 <vTaskSetTimeOutState+0x10>
800063ea:	70 08       	ld.w	r8,r8[0x0]
800063ec:	99 08       	st.w	r12[0x0],r8
	pxTimeOut->xTimeOnEntering = xTickCount;
800063ee:	48 48       	lddpc	r8,800063fc <vTaskSetTimeOutState+0x14>
800063f0:	70 08       	ld.w	r8,r8[0x0]
800063f2:	99 18       	st.w	r12[0x4],r8
}
800063f4:	5e fc       	retal	r12
800063f6:	00 00       	add	r0,r0
800063f8:	00 00       	add	r0,r0
800063fa:	0c 24       	rsub	r4,r6
800063fc:	00 00       	add	r0,r0
800063fe:	0d 0c       	ld.w	r12,r6++

80006400 <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
80006400:	30 19       	mov	r9,1
80006402:	48 28       	lddpc	r8,80006408 <vTaskMissedYield+0x8>
80006404:	91 09       	st.w	r8[0x0],r9
}
80006406:	5e fc       	retal	r12
80006408:	00 00       	add	r0,r0
8000640a:	0d 30       	ld.ub	r0,r6++

8000640c <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
8000640c:	48 28       	lddpc	r8,80006414 <xTaskGetCurrentTaskHandle+0x8>
8000640e:	70 0c       	ld.w	r12,r8[0x0]

		return xReturn;
	}
80006410:	5e fc       	retal	r12
80006412:	00 00       	add	r0,r0
80006414:	00 00       	add	r0,r0
80006416:	0c e0       	st.h	--r6,r0

80006418 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
80006418:	eb cd 40 c0 	pushm	r6-r7,lr
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
8000641c:	58 0c       	cp.w	r12,0
8000641e:	c1 f0       	breq	8000645c <vTaskPriorityDisinherit+0x44>

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
80006420:	18 97       	mov	r7,r12

		if( pxMutexHolder != NULL )
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
80006422:	78 b9       	ld.w	r9,r12[0x2c]
80006424:	79 18       	ld.w	r8,r12[0x44]
80006426:	10 39       	cp.w	r9,r8
80006428:	c1 a0       	breq	8000645c <vTaskPriorityDisinherit+0x44>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
8000642a:	f8 c6 ff fc 	sub	r6,r12,-4
8000642e:	0c 9c       	mov	r12,r6
80006430:	f0 1f 00 0c 	mcall	80006460 <vTaskPriorityDisinherit+0x48>

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
80006434:	6f 1c       	ld.w	r12,r7[0x44]
80006436:	8f bc       	st.w	r7[0x2c],r12
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
80006438:	f8 08 11 08 	rsub	r8,r12,8
8000643c:	8f 68       	st.w	r7[0x18],r8
				prvAddTaskToReadyQueue( pxTCB );
8000643e:	48 a8       	lddpc	r8,80006464 <vTaskPriorityDisinherit+0x4c>
80006440:	70 08       	ld.w	r8,r8[0x0]
80006442:	10 3c       	cp.w	r12,r8
80006444:	e0 88 00 04 	brls	8000644c <vTaskPriorityDisinherit+0x34>
80006448:	48 78       	lddpc	r8,80006464 <vTaskPriorityDisinherit+0x4c>
8000644a:	91 0c       	st.w	r8[0x0],r12
8000644c:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006450:	0c 9b       	mov	r11,r6
80006452:	48 68       	lddpc	r8,80006468 <vTaskPriorityDisinherit+0x50>
80006454:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80006458:	f0 1f 00 05 	mcall	8000646c <vTaskPriorityDisinherit+0x54>
8000645c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006460:	80 00       	ld.sh	r0,r0[0x0]
80006462:	5b 6e       	cp.w	lr,-10
80006464:	00 00       	add	r0,r0
80006466:	0d 48       	ld.w	r8,--r6
80006468:	00 00       	add	r0,r0
8000646a:	0c 2c       	rsub	r12,r6
8000646c:	80 00       	ld.sh	r0,r0[0x0]
8000646e:	5b 1e       	cp.w	lr,-15

80006470 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
80006470:	eb cd 40 c0 	pushm	r6-r7,lr
80006474:	18 97       	mov	r7,r12
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
80006476:	49 b8       	lddpc	r8,800064e0 <vTaskPriorityInherit+0x70>
80006478:	70 08       	ld.w	r8,r8[0x0]
8000647a:	78 b9       	ld.w	r9,r12[0x2c]
8000647c:	70 b8       	ld.w	r8,r8[0x2c]
8000647e:	10 39       	cp.w	r9,r8
80006480:	c2 d2       	brcc	800064da <vTaskPriorityInherit+0x6a>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
80006482:	49 88       	lddpc	r8,800064e0 <vTaskPriorityInherit+0x70>
80006484:	70 08       	ld.w	r8,r8[0x0]
80006486:	70 b8       	ld.w	r8,r8[0x2c]
80006488:	f0 08 11 08 	rsub	r8,r8,8
8000648c:	99 68       	st.w	r12[0x18],r8

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
8000648e:	f2 09 00 28 	add	r8,r9,r9<<0x2
80006492:	49 59       	lddpc	r9,800064e4 <vTaskPriorityInherit+0x74>
80006494:	f2 08 00 28 	add	r8,r9,r8<<0x2
80006498:	78 59       	ld.w	r9,r12[0x14]
8000649a:	10 39       	cp.w	r9,r8
8000649c:	c1 b1       	brne	800064d2 <vTaskPriorityInherit+0x62>
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
8000649e:	f8 c6 ff fc 	sub	r6,r12,-4
800064a2:	0c 9c       	mov	r12,r6
800064a4:	f0 1f 00 11 	mcall	800064e8 <vTaskPriorityInherit+0x78>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
800064a8:	48 e8       	lddpc	r8,800064e0 <vTaskPriorityInherit+0x70>
800064aa:	70 08       	ld.w	r8,r8[0x0]
800064ac:	70 bc       	ld.w	r12,r8[0x2c]
800064ae:	8f bc       	st.w	r7[0x2c],r12
				prvAddTaskToReadyQueue( pxTCB );
800064b0:	48 f8       	lddpc	r8,800064ec <vTaskPriorityInherit+0x7c>
800064b2:	70 08       	ld.w	r8,r8[0x0]
800064b4:	10 3c       	cp.w	r12,r8
800064b6:	e0 88 00 04 	brls	800064be <vTaskPriorityInherit+0x4e>
800064ba:	48 d8       	lddpc	r8,800064ec <vTaskPriorityInherit+0x7c>
800064bc:	91 0c       	st.w	r8[0x0],r12
800064be:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800064c2:	0c 9b       	mov	r11,r6
800064c4:	48 88       	lddpc	r8,800064e4 <vTaskPriorityInherit+0x74>
800064c6:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800064ca:	f0 1f 00 0a 	mcall	800064f0 <vTaskPriorityInherit+0x80>
800064ce:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
800064d2:	48 48       	lddpc	r8,800064e0 <vTaskPriorityInherit+0x70>
800064d4:	70 08       	ld.w	r8,r8[0x0]
800064d6:	70 b8       	ld.w	r8,r8[0x2c]
800064d8:	99 b8       	st.w	r12[0x2c],r8
800064da:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800064de:	00 00       	add	r0,r0
800064e0:	00 00       	add	r0,r0
800064e2:	0c e0       	st.h	--r6,r0
800064e4:	00 00       	add	r0,r0
800064e6:	0c 2c       	rsub	r12,r6
800064e8:	80 00       	ld.sh	r0,r0[0x0]
800064ea:	5b 6e       	cp.w	lr,-10
800064ec:	00 00       	add	r0,r0
800064ee:	0d 48       	ld.w	r8,--r6
800064f0:	80 00       	ld.sh	r0,r0[0x0]
800064f2:	5b 1e       	cp.w	lr,-15

800064f4 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
800064f4:	eb cd 40 c0 	pushm	r6-r7,lr
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
800064f8:	78 38       	ld.w	r8,r12[0xc]
800064fa:	70 37       	ld.w	r7,r8[0xc]
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
800064fc:	ee c6 ff e8 	sub	r6,r7,-24
80006500:	0c 9c       	mov	r12,r6
80006502:	f0 1f 00 15 	mcall	80006554 <xTaskRemoveFromEventList+0x60>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80006506:	49 58       	lddpc	r8,80006558 <xTaskRemoveFromEventList+0x64>
80006508:	70 08       	ld.w	r8,r8[0x0]
8000650a:	58 08       	cp.w	r8,0
8000650c:	c1 71       	brne	8000653a <xTaskRemoveFromEventList+0x46>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
8000650e:	ee c6 ff fc 	sub	r6,r7,-4
80006512:	0c 9c       	mov	r12,r6
80006514:	f0 1f 00 10 	mcall	80006554 <xTaskRemoveFromEventList+0x60>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
80006518:	6e bc       	ld.w	r12,r7[0x2c]
8000651a:	49 18       	lddpc	r8,8000655c <xTaskRemoveFromEventList+0x68>
8000651c:	70 08       	ld.w	r8,r8[0x0]
8000651e:	10 3c       	cp.w	r12,r8
80006520:	e0 88 00 04 	brls	80006528 <xTaskRemoveFromEventList+0x34>
80006524:	48 e8       	lddpc	r8,8000655c <xTaskRemoveFromEventList+0x68>
80006526:	91 0c       	st.w	r8[0x0],r12
80006528:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
8000652c:	0c 9b       	mov	r11,r6
8000652e:	48 d8       	lddpc	r8,80006560 <xTaskRemoveFromEventList+0x6c>
80006530:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80006534:	f0 1f 00 0c 	mcall	80006564 <xTaskRemoveFromEventList+0x70>
80006538:	c0 58       	rjmp	80006542 <xTaskRemoveFromEventList+0x4e>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
8000653a:	0c 9b       	mov	r11,r6
8000653c:	48 bc       	lddpc	r12,80006568 <xTaskRemoveFromEventList+0x74>
8000653e:	f0 1f 00 0a 	mcall	80006564 <xTaskRemoveFromEventList+0x70>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
80006542:	48 b8       	lddpc	r8,8000656c <xTaskRemoveFromEventList+0x78>
80006544:	70 08       	ld.w	r8,r8[0x0]
80006546:	6e b9       	ld.w	r9,r7[0x2c]
80006548:	70 b8       	ld.w	r8,r8[0x2c]
8000654a:	10 39       	cp.w	r9,r8
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
8000654c:	5f 2c       	srhs	r12
8000654e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006552:	00 00       	add	r0,r0
80006554:	80 00       	ld.sh	r0,r0[0x0]
80006556:	5b 6e       	cp.w	lr,-10
80006558:	00 00       	add	r0,r0
8000655a:	0d 10       	ld.sh	r0,r6++
8000655c:	00 00       	add	r0,r0
8000655e:	0d 48       	ld.w	r8,--r6
80006560:	00 00       	add	r0,r0
80006562:	0c 2c       	rsub	r12,r6
80006564:	80 00       	ld.sh	r0,r0[0x0]
80006566:	5b 1e       	cp.w	lr,-15
80006568:	00 00       	add	r0,r0
8000656a:	0c e4       	st.h	--r6,r4
8000656c:	00 00       	add	r0,r0
8000656e:	0c e0       	st.h	--r6,r0

80006570 <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
80006570:	eb cd 40 fc 	pushm	r2-r7,lr
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80006574:	4b 98       	lddpc	r8,80006658 <vTaskIncrementTick+0xe8>
80006576:	70 08       	ld.w	r8,r8[0x0]
80006578:	58 08       	cp.w	r8,0
8000657a:	c6 91       	brne	8000664c <vTaskIncrementTick+0xdc>
	{
		++xTickCount;
8000657c:	4b 88       	lddpc	r8,8000665c <vTaskIncrementTick+0xec>
8000657e:	70 09       	ld.w	r9,r8[0x0]
80006580:	2f f9       	sub	r9,-1
80006582:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
80006584:	70 08       	ld.w	r8,r8[0x0]
80006586:	58 08       	cp.w	r8,0
80006588:	c1 a1       	brne	800065bc <vTaskIncrementTick+0x4c>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
8000658a:	4b 68       	lddpc	r8,80006660 <vTaskIncrementTick+0xf0>
8000658c:	70 0a       	ld.w	r10,r8[0x0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
8000658e:	4b 69       	lddpc	r9,80006664 <vTaskIncrementTick+0xf4>
80006590:	72 0b       	ld.w	r11,r9[0x0]
80006592:	91 0b       	st.w	r8[0x0],r11
			pxOverflowDelayedTaskList = pxTemp;
80006594:	93 0a       	st.w	r9[0x0],r10
			xNumOfOverflows++;
80006596:	4b 59       	lddpc	r9,80006668 <vTaskIncrementTick+0xf8>
80006598:	72 0a       	ld.w	r10,r9[0x0]
8000659a:	2f fa       	sub	r10,-1
8000659c:	93 0a       	st.w	r9[0x0],r10

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
8000659e:	70 08       	ld.w	r8,r8[0x0]
800065a0:	70 08       	ld.w	r8,r8[0x0]
800065a2:	58 08       	cp.w	r8,0
800065a4:	c0 51       	brne	800065ae <vTaskIncrementTick+0x3e>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
800065a6:	3f f9       	mov	r9,-1
800065a8:	4b 18       	lddpc	r8,8000666c <vTaskIncrementTick+0xfc>
800065aa:	91 09       	st.w	r8[0x0],r9
800065ac:	c0 88       	rjmp	800065bc <vTaskIncrementTick+0x4c>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
800065ae:	4a d8       	lddpc	r8,80006660 <vTaskIncrementTick+0xf0>
800065b0:	70 08       	ld.w	r8,r8[0x0]
800065b2:	70 38       	ld.w	r8,r8[0xc]
800065b4:	70 38       	ld.w	r8,r8[0xc]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
800065b6:	70 19       	ld.w	r9,r8[0x4]
800065b8:	4a d8       	lddpc	r8,8000666c <vTaskIncrementTick+0xfc>
800065ba:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
800065bc:	4a 88       	lddpc	r8,8000665c <vTaskIncrementTick+0xec>
800065be:	70 09       	ld.w	r9,r8[0x0]
800065c0:	4a b8       	lddpc	r8,8000666c <vTaskIncrementTick+0xfc>
800065c2:	70 08       	ld.w	r8,r8[0x0]
800065c4:	10 39       	cp.w	r9,r8
800065c6:	c4 73       	brcs	80006654 <vTaskIncrementTick+0xe4>
800065c8:	4a 68       	lddpc	r8,80006660 <vTaskIncrementTick+0xf0>
800065ca:	70 08       	ld.w	r8,r8[0x0]
800065cc:	70 08       	ld.w	r8,r8[0x0]
800065ce:	58 08       	cp.w	r8,0
800065d0:	c0 c0       	breq	800065e8 <vTaskIncrementTick+0x78>
800065d2:	4a 48       	lddpc	r8,80006660 <vTaskIncrementTick+0xf0>
800065d4:	70 08       	ld.w	r8,r8[0x0]
800065d6:	70 38       	ld.w	r8,r8[0xc]
800065d8:	70 37       	ld.w	r7,r8[0xc]
800065da:	6e 18       	ld.w	r8,r7[0x4]
800065dc:	4a 09       	lddpc	r9,8000665c <vTaskIncrementTick+0xec>
800065de:	72 09       	ld.w	r9,r9[0x0]
800065e0:	12 38       	cp.w	r8,r9
800065e2:	e0 88 00 14 	brls	8000660a <vTaskIncrementTick+0x9a>
800065e6:	c0 e8       	rjmp	80006602 <vTaskIncrementTick+0x92>
800065e8:	3f f9       	mov	r9,-1
800065ea:	4a 18       	lddpc	r8,8000666c <vTaskIncrementTick+0xfc>
800065ec:	91 09       	st.w	r8[0x0],r9
800065ee:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800065f2:	6a 08       	ld.w	r8,r5[0x0]
800065f4:	70 38       	ld.w	r8,r8[0xc]
800065f6:	70 37       	ld.w	r7,r8[0xc]
800065f8:	6e 18       	ld.w	r8,r7[0x4]
800065fa:	64 09       	ld.w	r9,r2[0x0]
800065fc:	12 38       	cp.w	r8,r9
800065fe:	e0 88 00 0a 	brls	80006612 <vTaskIncrementTick+0xa2>
80006602:	49 b9       	lddpc	r9,8000666c <vTaskIncrementTick+0xfc>
80006604:	93 08       	st.w	r9[0x0],r8
80006606:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
8000660a:	49 a4       	lddpc	r4,80006670 <vTaskIncrementTick+0x100>
8000660c:	49 a3       	lddpc	r3,80006674 <vTaskIncrementTick+0x104>
8000660e:	49 55       	lddpc	r5,80006660 <vTaskIncrementTick+0xf0>
80006610:	49 32       	lddpc	r2,8000665c <vTaskIncrementTick+0xec>
80006612:	ee c6 ff fc 	sub	r6,r7,-4
80006616:	0c 9c       	mov	r12,r6
80006618:	f0 1f 00 18 	mcall	80006678 <vTaskIncrementTick+0x108>
8000661c:	6e a8       	ld.w	r8,r7[0x28]
8000661e:	58 08       	cp.w	r8,0
80006620:	c0 50       	breq	8000662a <vTaskIncrementTick+0xba>
80006622:	ee cc ff e8 	sub	r12,r7,-24
80006626:	f0 1f 00 15 	mcall	80006678 <vTaskIncrementTick+0x108>
8000662a:	6e bc       	ld.w	r12,r7[0x2c]
8000662c:	68 08       	ld.w	r8,r4[0x0]
8000662e:	10 3c       	cp.w	r12,r8
80006630:	e9 fc ba 00 	st.whi	r4[0x0],r12
80006634:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006638:	0c 9b       	mov	r11,r6
8000663a:	e6 0c 00 2c 	add	r12,r3,r12<<0x2
8000663e:	f0 1f 00 10 	mcall	8000667c <vTaskIncrementTick+0x10c>
80006642:	6a 08       	ld.w	r8,r5[0x0]
80006644:	70 08       	ld.w	r8,r8[0x0]
80006646:	58 08       	cp.w	r8,0
80006648:	cd 51       	brne	800065f2 <vTaskIncrementTick+0x82>
8000664a:	cc fb       	rjmp	800065e8 <vTaskIncrementTick+0x78>
	}
	else
	{
		++uxMissedTicks;
8000664c:	48 d8       	lddpc	r8,80006680 <vTaskIncrementTick+0x110>
8000664e:	70 09       	ld.w	r9,r8[0x0]
80006650:	2f f9       	sub	r9,-1
80006652:	91 09       	st.w	r8[0x0],r9
80006654:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80006658:	00 00       	add	r0,r0
8000665a:	0d 10       	ld.sh	r0,r6++
8000665c:	00 00       	add	r0,r0
8000665e:	0d 0c       	ld.w	r12,r6++
80006660:	00 00       	add	r0,r0
80006662:	0c 18       	sub	r8,r6
80006664:	00 00       	add	r0,r0
80006666:	0c 28       	rsub	r8,r6
80006668:	00 00       	add	r0,r0
8000666a:	0c 24       	rsub	r4,r6
8000666c:	00 00       	add	r0,r0
8000666e:	05 38       	ld.ub	r8,r2++
80006670:	00 00       	add	r0,r0
80006672:	0d 48       	ld.w	r8,--r6
80006674:	00 00       	add	r0,r0
80006676:	0c 2c       	rsub	r12,r6
80006678:	80 00       	ld.sh	r0,r0[0x0]
8000667a:	5b 6e       	cp.w	lr,-10
8000667c:	80 00       	ld.sh	r0,r0[0x0]
8000667e:	5b 1e       	cp.w	lr,-15
80006680:	00 00       	add	r0,r0
80006682:	0c 10       	sub	r0,r6

80006684 <xTaskCheckForTimeOut>:
	pxTimeOut->xTimeOnEntering = xTickCount;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
80006684:	eb cd 40 c0 	pushm	r6-r7,lr
80006688:	18 97       	mov	r7,r12
8000668a:	16 96       	mov	r6,r11
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
8000668c:	f0 1f 00 15 	mcall	800066e0 <xTaskCheckForTimeOut+0x5c>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
80006690:	6c 08       	ld.w	r8,r6[0x0]
80006692:	5b f8       	cp.w	r8,-1
80006694:	c0 31       	brne	8000669a <xTaskCheckForTimeOut+0x16>
80006696:	30 07       	mov	r7,0
80006698:	c1 f8       	rjmp	800066d6 <xTaskCheckForTimeOut+0x52>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
8000669a:	49 39       	lddpc	r9,800066e4 <xTaskCheckForTimeOut+0x60>
8000669c:	72 09       	ld.w	r9,r9[0x0]
8000669e:	6e 0a       	ld.w	r10,r7[0x0]
800066a0:	12 3a       	cp.w	r10,r9
800066a2:	c0 70       	breq	800066b0 <xTaskCheckForTimeOut+0x2c>
800066a4:	49 19       	lddpc	r9,800066e8 <xTaskCheckForTimeOut+0x64>
800066a6:	72 09       	ld.w	r9,r9[0x0]
800066a8:	6e 1a       	ld.w	r10,r7[0x4]
800066aa:	12 3a       	cp.w	r10,r9
800066ac:	e0 88 00 14 	brls	800066d4 <xTaskCheckForTimeOut+0x50>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
800066b0:	48 e9       	lddpc	r9,800066e8 <xTaskCheckForTimeOut+0x64>
800066b2:	72 0a       	ld.w	r10,r9[0x0]
800066b4:	6e 19       	ld.w	r9,r7[0x4]
800066b6:	12 1a       	sub	r10,r9
800066b8:	14 38       	cp.w	r8,r10
800066ba:	e0 88 00 0d 	brls	800066d4 <xTaskCheckForTimeOut+0x50>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
800066be:	48 ba       	lddpc	r10,800066e8 <xTaskCheckForTimeOut+0x64>
800066c0:	74 0a       	ld.w	r10,r10[0x0]
800066c2:	14 19       	sub	r9,r10
800066c4:	f2 08 00 08 	add	r8,r9,r8
800066c8:	8d 08       	st.w	r6[0x0],r8
			vTaskSetTimeOutState( pxTimeOut );
800066ca:	0e 9c       	mov	r12,r7
800066cc:	f0 1f 00 08 	mcall	800066ec <xTaskCheckForTimeOut+0x68>
800066d0:	30 07       	mov	r7,0
800066d2:	c0 28       	rjmp	800066d6 <xTaskCheckForTimeOut+0x52>
800066d4:	30 17       	mov	r7,1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
800066d6:	f0 1f 00 07 	mcall	800066f0 <xTaskCheckForTimeOut+0x6c>

	return xReturn;
}
800066da:	0e 9c       	mov	r12,r7
800066dc:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800066e0:	80 00       	ld.sh	r0,r0[0x0]
800066e2:	5c 28       	cpc	r8
800066e4:	00 00       	add	r0,r0
800066e6:	0c 24       	rsub	r4,r6
800066e8:	00 00       	add	r0,r0
800066ea:	0d 0c       	ld.w	r12,r6++
800066ec:	80 00       	ld.sh	r0,r0[0x0]
800066ee:	63 e8       	ld.w	r8,r1[0x78]
800066f0:	80 00       	ld.sh	r0,r0[0x0]
800066f2:	5d 34       	musfr	r4

800066f4 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
800066f4:	eb cd 40 80 	pushm	r7,lr
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
800066f8:	f0 1f 00 05 	mcall	8000670c <xTaskGetTickCount+0x18>
	{
		xTicks = xTickCount;
800066fc:	48 58       	lddpc	r8,80006710 <xTaskGetTickCount+0x1c>
800066fe:	70 07       	ld.w	r7,r8[0x0]
	}
	taskEXIT_CRITICAL();
80006700:	f0 1f 00 05 	mcall	80006714 <xTaskGetTickCount+0x20>

	return xTicks;
}
80006704:	0e 9c       	mov	r12,r7
80006706:	e3 cd 80 80 	ldm	sp++,r7,pc
8000670a:	00 00       	add	r0,r0
8000670c:	80 00       	ld.sh	r0,r0[0x0]
8000670e:	5c 28       	cpc	r8
80006710:	00 00       	add	r0,r0
80006712:	0d 0c       	ld.w	r12,r6++
80006714:	80 00       	ld.sh	r0,r0[0x0]
80006716:	5d 34       	musfr	r4

80006718 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
80006718:	eb cd 40 fe 	pushm	r1-r7,lr
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
8000671c:	f0 1f 00 2c 	mcall	800067cc <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;
80006720:	4a c8       	lddpc	r8,800067d0 <xTaskResumeAll+0xb8>
80006722:	70 09       	ld.w	r9,r8[0x0]
80006724:	20 19       	sub	r9,1
80006726:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80006728:	70 08       	ld.w	r8,r8[0x0]
8000672a:	58 08       	cp.w	r8,0
8000672c:	c4 91       	brne	800067be <xTaskResumeAll+0xa6>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
8000672e:	4a a8       	lddpc	r8,800067d4 <xTaskResumeAll+0xbc>
80006730:	70 08       	ld.w	r8,r8[0x0]
80006732:	58 08       	cp.w	r8,0
80006734:	c4 50       	breq	800067be <xTaskResumeAll+0xa6>
80006736:	30 04       	mov	r4,0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80006738:	4a 85       	lddpc	r5,800067d8 <xTaskResumeAll+0xc0>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
8000673a:	4a 93       	lddpc	r3,800067dc <xTaskResumeAll+0xc4>
8000673c:	4a 92       	lddpc	r2,800067e0 <xTaskResumeAll+0xc8>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
8000673e:	4a a1       	lddpc	r1,800067e4 <xTaskResumeAll+0xcc>
80006740:	c1 e8       	rjmp	8000677c <xTaskResumeAll+0x64>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
80006742:	6a 38       	ld.w	r8,r5[0xc]
80006744:	70 37       	ld.w	r7,r8[0xc]
					vListRemove( &( pxTCB->xEventListItem ) );
80006746:	ee cc ff e8 	sub	r12,r7,-24
8000674a:	f0 1f 00 28 	mcall	800067e8 <xTaskResumeAll+0xd0>
					vListRemove( &( pxTCB->xGenericListItem ) );
8000674e:	ee c6 ff fc 	sub	r6,r7,-4
80006752:	0c 9c       	mov	r12,r6
80006754:	f0 1f 00 25 	mcall	800067e8 <xTaskResumeAll+0xd0>
					prvAddTaskToReadyQueue( pxTCB );
80006758:	6e bc       	ld.w	r12,r7[0x2c]
8000675a:	66 08       	ld.w	r8,r3[0x0]
8000675c:	10 3c       	cp.w	r12,r8
8000675e:	e7 fc ba 00 	st.whi	r3[0x0],r12
80006762:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006766:	0c 9b       	mov	r11,r6
80006768:	e4 0c 00 2c 	add	r12,r2,r12<<0x2
8000676c:	f0 1f 00 20 	mcall	800067ec <xTaskResumeAll+0xd4>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80006770:	62 08       	ld.w	r8,r1[0x0]
80006772:	6e b9       	ld.w	r9,r7[0x2c]
80006774:	70 b8       	ld.w	r8,r8[0x2c]
80006776:	10 39       	cp.w	r9,r8
80006778:	f9 b4 02 01 	movhs	r4,1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
8000677c:	6a 08       	ld.w	r8,r5[0x0]
8000677e:	58 08       	cp.w	r8,0
80006780:	ce 11       	brne	80006742 <xTaskResumeAll+0x2a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80006782:	49 c8       	lddpc	r8,800067f0 <xTaskResumeAll+0xd8>
80006784:	70 08       	ld.w	r8,r8[0x0]
80006786:	58 08       	cp.w	r8,0
80006788:	c0 f0       	breq	800067a6 <xTaskResumeAll+0x8e>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
8000678a:	49 a8       	lddpc	r8,800067f0 <xTaskResumeAll+0xd8>
8000678c:	70 08       	ld.w	r8,r8[0x0]
8000678e:	58 08       	cp.w	r8,0
80006790:	c1 10       	breq	800067b2 <xTaskResumeAll+0x9a>
					{
						vTaskIncrementTick();
						--uxMissedTicks;
80006792:	49 87       	lddpc	r7,800067f0 <xTaskResumeAll+0xd8>
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
80006794:	f0 1f 00 18 	mcall	800067f4 <xTaskResumeAll+0xdc>
						--uxMissedTicks;
80006798:	6e 08       	ld.w	r8,r7[0x0]
8000679a:	20 18       	sub	r8,1
8000679c:	8f 08       	st.w	r7[0x0],r8
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
8000679e:	6e 08       	ld.w	r8,r7[0x0]
800067a0:	58 08       	cp.w	r8,0
800067a2:	cf 91       	brne	80006794 <xTaskResumeAll+0x7c>
800067a4:	c0 78       	rjmp	800067b2 <xTaskResumeAll+0x9a>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
800067a6:	58 14       	cp.w	r4,1
800067a8:	c0 50       	breq	800067b2 <xTaskResumeAll+0x9a>
800067aa:	49 48       	lddpc	r8,800067f8 <xTaskResumeAll+0xe0>
800067ac:	70 08       	ld.w	r8,r8[0x0]
800067ae:	58 18       	cp.w	r8,1
800067b0:	c0 71       	brne	800067be <xTaskResumeAll+0xa6>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
800067b2:	30 09       	mov	r9,0
800067b4:	49 18       	lddpc	r8,800067f8 <xTaskResumeAll+0xe0>
800067b6:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
800067b8:	d7 33       	scall
800067ba:	30 17       	mov	r7,1
800067bc:	c0 28       	rjmp	800067c0 <xTaskResumeAll+0xa8>
800067be:	30 07       	mov	r7,0
				}
			}
		}
	}
	taskEXIT_CRITICAL();
800067c0:	f0 1f 00 0f 	mcall	800067fc <xTaskResumeAll+0xe4>

	return xAlreadyYielded;
}
800067c4:	0e 9c       	mov	r12,r7
800067c6:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
800067ca:	00 00       	add	r0,r0
800067cc:	80 00       	ld.sh	r0,r0[0x0]
800067ce:	5c 28       	cpc	r8
800067d0:	00 00       	add	r0,r0
800067d2:	0d 10       	ld.sh	r0,r6++
800067d4:	00 00       	add	r0,r0
800067d6:	0d 2c       	ld.uh	r12,r6++
800067d8:	00 00       	add	r0,r0
800067da:	0c e4       	st.h	--r6,r4
800067dc:	00 00       	add	r0,r0
800067de:	0d 48       	ld.w	r8,--r6
800067e0:	00 00       	add	r0,r0
800067e2:	0c 2c       	rsub	r12,r6
800067e4:	00 00       	add	r0,r0
800067e6:	0c e0       	st.h	--r6,r0
800067e8:	80 00       	ld.sh	r0,r0[0x0]
800067ea:	5b 6e       	cp.w	lr,-10
800067ec:	80 00       	ld.sh	r0,r0[0x0]
800067ee:	5b 1e       	cp.w	lr,-15
800067f0:	00 00       	add	r0,r0
800067f2:	0c 10       	sub	r0,r6
800067f4:	80 00       	ld.sh	r0,r0[0x0]
800067f6:	65 70       	ld.w	r0,r2[0x5c]
800067f8:	00 00       	add	r0,r0
800067fa:	0d 30       	ld.ub	r0,r6++
800067fc:	80 00       	ld.sh	r0,r0[0x0]
800067fe:	5d 34       	musfr	r4

80006800 <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
80006800:	eb cd 40 80 	pushm	r7,lr
80006804:	18 97       	mov	r7,r12
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
80006806:	49 08       	lddpc	r8,80006844 <prvAddCurrentTaskToDelayedList+0x44>
80006808:	70 08       	ld.w	r8,r8[0x0]
8000680a:	91 1c       	st.w	r8[0x4],r12

	if( xTimeToWake < xTickCount )
8000680c:	48 f8       	lddpc	r8,80006848 <prvAddCurrentTaskToDelayedList+0x48>
8000680e:	70 08       	ld.w	r8,r8[0x0]
80006810:	10 3c       	cp.w	r12,r8
80006812:	c0 a2       	brcc	80006826 <prvAddCurrentTaskToDelayedList+0x26>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006814:	48 c8       	lddpc	r8,80006844 <prvAddCurrentTaskToDelayedList+0x44>
80006816:	70 0b       	ld.w	r11,r8[0x0]
80006818:	48 d8       	lddpc	r8,8000684c <prvAddCurrentTaskToDelayedList+0x4c>
8000681a:	70 0c       	ld.w	r12,r8[0x0]
8000681c:	2f cb       	sub	r11,-4
8000681e:	f0 1f 00 0d 	mcall	80006850 <prvAddCurrentTaskToDelayedList+0x50>
80006822:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006826:	48 88       	lddpc	r8,80006844 <prvAddCurrentTaskToDelayedList+0x44>
80006828:	70 0b       	ld.w	r11,r8[0x0]
8000682a:	48 b8       	lddpc	r8,80006854 <prvAddCurrentTaskToDelayedList+0x54>
8000682c:	70 0c       	ld.w	r12,r8[0x0]
8000682e:	2f cb       	sub	r11,-4
80006830:	f0 1f 00 08 	mcall	80006850 <prvAddCurrentTaskToDelayedList+0x50>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
80006834:	48 98       	lddpc	r8,80006858 <prvAddCurrentTaskToDelayedList+0x58>
80006836:	70 08       	ld.w	r8,r8[0x0]
80006838:	10 37       	cp.w	r7,r8
8000683a:	c0 32       	brcc	80006840 <prvAddCurrentTaskToDelayedList+0x40>
		{
			xNextTaskUnblockTime = xTimeToWake;
8000683c:	48 78       	lddpc	r8,80006858 <prvAddCurrentTaskToDelayedList+0x58>
8000683e:	91 07       	st.w	r8[0x0],r7
80006840:	e3 cd 80 80 	ldm	sp++,r7,pc
80006844:	00 00       	add	r0,r0
80006846:	0c e0       	st.h	--r6,r0
80006848:	00 00       	add	r0,r0
8000684a:	0d 0c       	ld.w	r12,r6++
8000684c:	00 00       	add	r0,r0
8000684e:	0c 28       	rsub	r8,r6
80006850:	80 00       	ld.sh	r0,r0[0x0]
80006852:	5b 3a       	cp.w	r10,-13
80006854:	00 00       	add	r0,r0
80006856:	0c 18       	sub	r8,r6
80006858:	00 00       	add	r0,r0
8000685a:	05 38       	ld.ub	r8,r2++

8000685c <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
8000685c:	eb cd 40 c0 	pushm	r6-r7,lr
80006860:	18 96       	mov	r6,r12
80006862:	16 97       	mov	r7,r11
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0 ) );

		vTaskSuspendAll();
80006864:	f0 1f 00 18 	mcall	800068c4 <vTaskDelayUntil+0x68>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
80006868:	6c 08       	ld.w	r8,r6[0x0]
8000686a:	10 07       	add	r7,r8

			if( xTickCount < *pxPreviousWakeTime )
8000686c:	49 79       	lddpc	r9,800068c8 <vTaskDelayUntil+0x6c>
8000686e:	72 09       	ld.w	r9,r9[0x0]
80006870:	12 38       	cp.w	r8,r9
80006872:	e0 88 00 0c 	brls	8000688a <vTaskDelayUntil+0x2e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
80006876:	0e 38       	cp.w	r8,r7
80006878:	e0 88 00 22 	brls	800068bc <vTaskDelayUntil+0x60>
8000687c:	49 38       	lddpc	r8,800068c8 <vTaskDelayUntil+0x6c>
8000687e:	70 08       	ld.w	r8,r8[0x0]
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80006880:	8d 07       	st.w	r6[0x0],r7

			if( xShouldDelay != pdFALSE )
80006882:	10 37       	cp.w	r7,r8
80006884:	e0 88 00 14 	brls	800068ac <vTaskDelayUntil+0x50>
80006888:	c0 a8       	rjmp	8000689c <vTaskDelayUntil+0x40>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
8000688a:	0e 38       	cp.w	r8,r7
8000688c:	e0 8b 00 16 	brhi	800068b8 <vTaskDelayUntil+0x5c>
80006890:	48 e8       	lddpc	r8,800068c8 <vTaskDelayUntil+0x6c>
80006892:	70 08       	ld.w	r8,r8[0x0]
80006894:	10 37       	cp.w	r7,r8
80006896:	e0 8b 00 11 	brhi	800068b8 <vTaskDelayUntil+0x5c>
8000689a:	c1 18       	rjmp	800068bc <vTaskDelayUntil+0x60>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
8000689c:	48 c8       	lddpc	r8,800068cc <vTaskDelayUntil+0x70>
8000689e:	70 0c       	ld.w	r12,r8[0x0]
800068a0:	2f cc       	sub	r12,-4
800068a2:	f0 1f 00 0c 	mcall	800068d0 <vTaskDelayUntil+0x74>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
800068a6:	0e 9c       	mov	r12,r7
800068a8:	f0 1f 00 0b 	mcall	800068d4 <vTaskDelayUntil+0x78>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
800068ac:	f0 1f 00 0b 	mcall	800068d8 <vTaskDelayUntil+0x7c>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
800068b0:	c0 81       	brne	800068c0 <vTaskDelayUntil+0x64>
		{
			portYIELD_WITHIN_API();
800068b2:	d7 33       	scall
800068b4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
800068b8:	8d 07       	st.w	r6[0x0],r7
800068ba:	cf 1b       	rjmp	8000689c <vTaskDelayUntil+0x40>
800068bc:	8d 07       	st.w	r6[0x0],r7
800068be:	cf 7b       	rjmp	800068ac <vTaskDelayUntil+0x50>
800068c0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800068c4:	80 00       	ld.sh	r0,r0[0x0]
800068c6:	63 5c       	ld.w	r12,r1[0x54]
800068c8:	00 00       	add	r0,r0
800068ca:	0d 0c       	ld.w	r12,r6++
800068cc:	00 00       	add	r0,r0
800068ce:	0c e0       	st.h	--r6,r0
800068d0:	80 00       	ld.sh	r0,r0[0x0]
800068d2:	5b 6e       	cp.w	lr,-10
800068d4:	80 00       	ld.sh	r0,r0[0x0]
800068d6:	68 00       	ld.w	r0,r4[0x0]
800068d8:	80 00       	ld.sh	r0,r0[0x0]
800068da:	67 18       	ld.w	r8,r3[0x44]

800068dc <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
800068dc:	eb cd 40 c0 	pushm	r6-r7,lr
800068e0:	16 96       	mov	r6,r11
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
800068e2:	48 e7       	lddpc	r7,80006918 <vTaskPlaceOnEventList+0x3c>
800068e4:	6e 0b       	ld.w	r11,r7[0x0]
800068e6:	2e 8b       	sub	r11,-24
800068e8:	f0 1f 00 0d 	mcall	8000691c <vTaskPlaceOnEventList+0x40>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800068ec:	6e 0c       	ld.w	r12,r7[0x0]
800068ee:	2f cc       	sub	r12,-4
800068f0:	f0 1f 00 0c 	mcall	80006920 <vTaskPlaceOnEventList+0x44>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
800068f4:	5b f6       	cp.w	r6,-1
800068f6:	c0 81       	brne	80006906 <vTaskPlaceOnEventList+0x2a>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800068f8:	6e 0b       	ld.w	r11,r7[0x0]
800068fa:	2f cb       	sub	r11,-4
800068fc:	48 ac       	lddpc	r12,80006924 <vTaskPlaceOnEventList+0x48>
800068fe:	f0 1f 00 0b 	mcall	80006928 <vTaskPlaceOnEventList+0x4c>
80006902:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
80006906:	48 a8       	lddpc	r8,8000692c <vTaskPlaceOnEventList+0x50>
80006908:	70 0c       	ld.w	r12,r8[0x0]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
8000690a:	ec 0c 00 0c 	add	r12,r6,r12
8000690e:	f0 1f 00 09 	mcall	80006930 <vTaskPlaceOnEventList+0x54>
80006912:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006916:	00 00       	add	r0,r0
80006918:	00 00       	add	r0,r0
8000691a:	0c e0       	st.h	--r6,r0
8000691c:	80 00       	ld.sh	r0,r0[0x0]
8000691e:	5b 3a       	cp.w	r10,-13
80006920:	80 00       	ld.sh	r0,r0[0x0]
80006922:	5b 6e       	cp.w	lr,-10
80006924:	00 00       	add	r0,r0
80006926:	0d 34       	ld.ub	r4,r6++
80006928:	80 00       	ld.sh	r0,r0[0x0]
8000692a:	5b 1e       	cp.w	lr,-15
8000692c:	00 00       	add	r0,r0
8000692e:	0d 0c       	ld.w	r12,r6++
80006930:	80 00       	ld.sh	r0,r0[0x0]
80006932:	68 00       	ld.w	r0,r4[0x0]

80006934 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
80006934:	eb cd 40 f8 	pushm	r3-r7,lr
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80006938:	49 67       	lddpc	r7,80006990 <prvIdleTask+0x5c>
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
8000693a:	49 74       	lddpc	r4,80006994 <prvIdleTask+0x60>

				taskENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					--uxCurrentNumberOfTasks;
8000693c:	49 73       	lddpc	r3,80006998 <prvIdleTask+0x64>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
8000693e:	49 85       	lddpc	r5,8000699c <prvIdleTask+0x68>
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80006940:	6e 08       	ld.w	r8,r7[0x0]
80006942:	58 08       	cp.w	r8,0
80006944:	c1 e0       	breq	80006980 <prvIdleTask+0x4c>
		{
			vTaskSuspendAll();
80006946:	f0 1f 00 17 	mcall	800069a0 <prvIdleTask+0x6c>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
8000694a:	68 06       	ld.w	r6,r4[0x0]
			xTaskResumeAll();
8000694c:	f0 1f 00 16 	mcall	800069a4 <prvIdleTask+0x70>

			if( xListIsEmpty == pdFALSE )
80006950:	58 06       	cp.w	r6,0
80006952:	c1 70       	breq	80006980 <prvIdleTask+0x4c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
80006954:	f0 1f 00 15 	mcall	800069a8 <prvIdleTask+0x74>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
80006958:	68 38       	ld.w	r8,r4[0xc]
8000695a:	70 36       	ld.w	r6,r8[0xc]
					vListRemove( &( pxTCB->xGenericListItem ) );
8000695c:	ec cc ff fc 	sub	r12,r6,-4
80006960:	f0 1f 00 13 	mcall	800069ac <prvIdleTask+0x78>
					--uxCurrentNumberOfTasks;
80006964:	66 08       	ld.w	r8,r3[0x0]
80006966:	20 18       	sub	r8,1
80006968:	87 08       	st.w	r3[0x0],r8
					--uxTasksDeleted;
8000696a:	6e 08       	ld.w	r8,r7[0x0]
8000696c:	20 18       	sub	r8,1
8000696e:	8f 08       	st.w	r7[0x0],r8
				}
				taskEXIT_CRITICAL();
80006970:	f0 1f 00 10 	mcall	800069b0 <prvIdleTask+0x7c>

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
80006974:	6c cc       	ld.w	r12,r6[0x30]
80006976:	f0 1f 00 10 	mcall	800069b4 <prvIdleTask+0x80>
		vPortFree( pxTCB );
8000697a:	0c 9c       	mov	r12,r6
8000697c:	f0 1f 00 0e 	mcall	800069b4 <prvIdleTask+0x80>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80006980:	6a 08       	ld.w	r8,r5[0x0]
80006982:	58 18       	cp.w	r8,1
80006984:	e0 88 00 03 	brls	8000698a <prvIdleTask+0x56>
			{
				taskYIELD();
80006988:	d7 33       	scall
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
8000698a:	f0 1f 00 0c 	mcall	800069b8 <prvIdleTask+0x84>
		}
		#endif
	}
8000698e:	cd 9b       	rjmp	80006940 <prvIdleTask+0xc>
80006990:	00 00       	add	r0,r0
80006992:	0c 20       	rsub	r0,r6
80006994:	00 00       	add	r0,r0
80006996:	0c cc       	st.b	r6++,r12
80006998:	00 00       	add	r0,r0
8000699a:	0d 2c       	ld.uh	r12,r6++
8000699c:	00 00       	add	r0,r0
8000699e:	0c 2c       	rsub	r12,r6
800069a0:	80 00       	ld.sh	r0,r0[0x0]
800069a2:	63 5c       	ld.w	r12,r1[0x54]
800069a4:	80 00       	ld.sh	r0,r0[0x0]
800069a6:	67 18       	ld.w	r8,r3[0x44]
800069a8:	80 00       	ld.sh	r0,r0[0x0]
800069aa:	5c 28       	cpc	r8
800069ac:	80 00       	ld.sh	r0,r0[0x0]
800069ae:	5b 6e       	cp.w	lr,-10
800069b0:	80 00       	ld.sh	r0,r0[0x0]
800069b2:	5d 34       	musfr	r4
800069b4:	80 00       	ld.sh	r0,r0[0x0]
800069b6:	5e 6c       	retmi	r12
800069b8:	80 00       	ld.sh	r0,r0[0x0]
800069ba:	20 30       	sub	r0,3

800069bc <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
800069bc:	d4 31       	pushm	r0-r7,lr
800069be:	20 1d       	sub	sp,4
800069c0:	fa c4 ff d8 	sub	r4,sp,-40
800069c4:	50 0c       	stdsp	sp[0x0],r12
800069c6:	16 91       	mov	r1,r11
800069c8:	14 97       	mov	r7,r10
800069ca:	12 90       	mov	r0,r9
800069cc:	10 93       	mov	r3,r8
800069ce:	68 02       	ld.w	r2,r4[0x0]
800069d0:	68 16       	ld.w	r6,r4[0x4]
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
800069d2:	34 8c       	mov	r12,72
800069d4:	f0 1f 00 5c 	mcall	80006b44 <xTaskGenericCreate+0x188>
800069d8:	18 95       	mov	r5,r12

	if( pxNewTCB != NULL )
800069da:	c0 31       	brne	800069e0 <xTaskGenericCreate+0x24>
800069dc:	3f fc       	mov	r12,-1
800069de:	ca f8       	rjmp	80006b3c <xTaskGenericCreate+0x180>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
800069e0:	58 06       	cp.w	r6,0
800069e2:	e0 81 00 af 	brne	80006b40 <xTaskGenericCreate+0x184>
800069e6:	0e 9c       	mov	r12,r7
800069e8:	5c 7c       	castu.h	r12
800069ea:	a3 6c       	lsl	r12,0x2
800069ec:	f0 1f 00 56 	mcall	80006b44 <xTaskGenericCreate+0x188>
800069f0:	18 96       	mov	r6,r12
800069f2:	8b cc       	st.w	r5[0x30],r12

		if( pxNewTCB->pxStack == NULL )
800069f4:	c0 61       	brne	80006a00 <xTaskGenericCreate+0x44>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
800069f6:	0a 9c       	mov	r12,r5
800069f8:	f0 1f 00 54 	mcall	80006b48 <xTaskGenericCreate+0x18c>
800069fc:	3f fc       	mov	r12,-1
800069fe:	c9 f8       	rjmp	80006b3c <xTaskGenericCreate+0x180>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
80006a00:	5c 77       	castu.h	r7
80006a02:	ee 0a 15 02 	lsl	r10,r7,0x2
80006a06:	e0 6b 00 a5 	mov	r11,165
80006a0a:	0c 9c       	mov	r12,r6
80006a0c:	f0 1f 00 50 	mcall	80006b4c <xTaskGenericCreate+0x190>
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
80006a10:	ee c6 00 01 	sub	r6,r7,1
80006a14:	6a c8       	ld.w	r8,r5[0x30]
80006a16:	f0 06 00 26 	add	r6,r8,r6<<0x2
80006a1a:	e0 16 ff fc 	andl	r6,0xfffc
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
80006a1e:	31 0a       	mov	r10,16
80006a20:	02 9b       	mov	r11,r1
80006a22:	ea cc ff cc 	sub	r12,r5,-52
80006a26:	f0 1f 00 4b 	mcall	80006b50 <xTaskGenericCreate+0x194>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
80006a2a:	30 08       	mov	r8,0
80006a2c:	eb 68 00 43 	st.b	r5[67],r8
80006a30:	58 73       	cp.w	r3,7
80006a32:	e6 07 17 80 	movls	r7,r3
80006a36:	f9 b7 0b 07 	movhi	r7,7
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
80006a3a:	8b b7       	st.w	r5[0x2c],r7
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
80006a3c:	eb 47 00 44 	st.w	r5[68],r7
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
80006a40:	ea c4 ff fc 	sub	r4,r5,-4
80006a44:	08 9c       	mov	r12,r4
80006a46:	f0 1f 00 44 	mcall	80006b54 <xTaskGenericCreate+0x198>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
80006a4a:	ea cc ff e8 	sub	r12,r5,-24
80006a4e:	f0 1f 00 42 	mcall	80006b54 <xTaskGenericCreate+0x198>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
80006a52:	8b 45       	st.w	r5[0x10],r5

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
80006a54:	ee 07 11 08 	rsub	r7,r7,8
80006a58:	8b 67       	st.w	r5[0x18],r7
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
80006a5a:	8b 95       	st.w	r5[0x24],r5
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
80006a5c:	00 9a       	mov	r10,r0
80006a5e:	40 0b       	lddsp	r11,sp[0x0]
80006a60:	0c 9c       	mov	r12,r6
80006a62:	f0 1f 00 3e 	mcall	80006b58 <xTaskGenericCreate+0x19c>
80006a66:	8b 0c       	st.w	r5[0x0],r12
		if( ( void * ) pxCreatedTask != NULL )
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
80006a68:	58 02       	cp.w	r2,0
80006a6a:	e5 f5 1a 00 	st.wne	r2[0x0],r5
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
80006a6e:	f0 1f 00 3c 	mcall	80006b5c <xTaskGenericCreate+0x1a0>
		{
			uxCurrentNumberOfTasks++;
80006a72:	4b c8       	lddpc	r8,80006b60 <xTaskGenericCreate+0x1a4>
80006a74:	70 09       	ld.w	r9,r8[0x0]
80006a76:	2f f9       	sub	r9,-1
80006a78:	91 09       	st.w	r8[0x0],r9
			if( pxCurrentTCB == NULL )
80006a7a:	4b b8       	lddpc	r8,80006b64 <xTaskGenericCreate+0x1a8>
80006a7c:	70 08       	ld.w	r8,r8[0x0]
80006a7e:	58 08       	cp.w	r8,0
80006a80:	c2 61       	brne	80006acc <xTaskGenericCreate+0x110>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
80006a82:	4b 98       	lddpc	r8,80006b64 <xTaskGenericCreate+0x1a8>
80006a84:	91 05       	st.w	r8[0x0],r5

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
80006a86:	4b 78       	lddpc	r8,80006b60 <xTaskGenericCreate+0x1a4>
80006a88:	70 08       	ld.w	r8,r8[0x0]
80006a8a:	58 18       	cp.w	r8,1
80006a8c:	c2 b1       	brne	80006ae2 <xTaskGenericCreate+0x126>
80006a8e:	4b 77       	lddpc	r7,80006b68 <xTaskGenericCreate+0x1ac>

/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
80006a90:	ee c6 ff 60 	sub	r6,r7,-160
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
80006a94:	0e 9c       	mov	r12,r7
80006a96:	f0 1f 00 36 	mcall	80006b6c <xTaskGenericCreate+0x1b0>
80006a9a:	2e c7       	sub	r7,-20

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
80006a9c:	0c 37       	cp.w	r7,r6
80006a9e:	cf b1       	brne	80006a94 <xTaskGenericCreate+0xd8>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
80006aa0:	4b 47       	lddpc	r7,80006b70 <xTaskGenericCreate+0x1b4>
80006aa2:	0e 9c       	mov	r12,r7
80006aa4:	f0 1f 00 32 	mcall	80006b6c <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
80006aa8:	4b 36       	lddpc	r6,80006b74 <xTaskGenericCreate+0x1b8>
80006aaa:	0c 9c       	mov	r12,r6
80006aac:	f0 1f 00 30 	mcall	80006b6c <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xPendingReadyList );
80006ab0:	4b 2c       	lddpc	r12,80006b78 <xTaskGenericCreate+0x1bc>
80006ab2:	f0 1f 00 2f 	mcall	80006b6c <xTaskGenericCreate+0x1b0>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
80006ab6:	4b 2c       	lddpc	r12,80006b7c <xTaskGenericCreate+0x1c0>
80006ab8:	f0 1f 00 2d 	mcall	80006b6c <xTaskGenericCreate+0x1b0>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
80006abc:	4b 1c       	lddpc	r12,80006b80 <xTaskGenericCreate+0x1c4>
80006abe:	f0 1f 00 2c 	mcall	80006b6c <xTaskGenericCreate+0x1b0>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
80006ac2:	4b 18       	lddpc	r8,80006b84 <xTaskGenericCreate+0x1c8>
80006ac4:	91 07       	st.w	r8[0x0],r7
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
80006ac6:	4b 18       	lddpc	r8,80006b88 <xTaskGenericCreate+0x1cc>
80006ac8:	91 06       	st.w	r8[0x0],r6
80006aca:	c0 c8       	rjmp	80006ae2 <xTaskGenericCreate+0x126>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
80006acc:	4b 08       	lddpc	r8,80006b8c <xTaskGenericCreate+0x1d0>
80006ace:	70 08       	ld.w	r8,r8[0x0]
80006ad0:	58 08       	cp.w	r8,0
80006ad2:	c0 81       	brne	80006ae2 <xTaskGenericCreate+0x126>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
80006ad4:	4a 48       	lddpc	r8,80006b64 <xTaskGenericCreate+0x1a8>
80006ad6:	70 08       	ld.w	r8,r8[0x0]
80006ad8:	70 b8       	ld.w	r8,r8[0x2c]
80006ada:	10 33       	cp.w	r3,r8
80006adc:	c0 33       	brcs	80006ae2 <xTaskGenericCreate+0x126>
					{
						pxCurrentTCB = pxNewTCB;
80006ade:	4a 28       	lddpc	r8,80006b64 <xTaskGenericCreate+0x1a8>
80006ae0:	91 05       	st.w	r8[0x0],r5
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
80006ae2:	6a b8       	ld.w	r8,r5[0x2c]
80006ae4:	4a b9       	lddpc	r9,80006b90 <xTaskGenericCreate+0x1d4>
80006ae6:	72 09       	ld.w	r9,r9[0x0]
80006ae8:	12 38       	cp.w	r8,r9
80006aea:	e0 88 00 04 	brls	80006af2 <xTaskGenericCreate+0x136>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
80006aee:	4a 99       	lddpc	r9,80006b90 <xTaskGenericCreate+0x1d4>
80006af0:	93 08       	st.w	r9[0x0],r8
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
80006af2:	4a 98       	lddpc	r8,80006b94 <xTaskGenericCreate+0x1d8>
80006af4:	70 09       	ld.w	r9,r8[0x0]
80006af6:	2f f9       	sub	r9,-1
80006af8:	91 09       	st.w	r8[0x0],r9

			prvAddTaskToReadyQueue( pxNewTCB );
80006afa:	6a b8       	ld.w	r8,r5[0x2c]
80006afc:	4a 79       	lddpc	r9,80006b98 <xTaskGenericCreate+0x1dc>
80006afe:	72 09       	ld.w	r9,r9[0x0]
80006b00:	12 38       	cp.w	r8,r9
80006b02:	e0 88 00 04 	brls	80006b0a <xTaskGenericCreate+0x14e>
80006b06:	4a 59       	lddpc	r9,80006b98 <xTaskGenericCreate+0x1dc>
80006b08:	93 08       	st.w	r9[0x0],r8
80006b0a:	6a bc       	ld.w	r12,r5[0x2c]
80006b0c:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006b10:	08 9b       	mov	r11,r4
80006b12:	49 68       	lddpc	r8,80006b68 <xTaskGenericCreate+0x1ac>
80006b14:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80006b18:	f0 1f 00 21 	mcall	80006b9c <xTaskGenericCreate+0x1e0>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
80006b1c:	f0 1f 00 21 	mcall	80006ba0 <xTaskGenericCreate+0x1e4>
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
80006b20:	49 b8       	lddpc	r8,80006b8c <xTaskGenericCreate+0x1d0>
80006b22:	70 08       	ld.w	r8,r8[0x0]
80006b24:	58 08       	cp.w	r8,0
80006b26:	c0 a0       	breq	80006b3a <xTaskGenericCreate+0x17e>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
80006b28:	48 f8       	lddpc	r8,80006b64 <xTaskGenericCreate+0x1a8>
80006b2a:	70 08       	ld.w	r8,r8[0x0]
80006b2c:	70 b8       	ld.w	r8,r8[0x2c]
80006b2e:	10 33       	cp.w	r3,r8
80006b30:	e0 88 00 05 	brls	80006b3a <xTaskGenericCreate+0x17e>
			{
				portYIELD_WITHIN_API();
80006b34:	d7 33       	scall
80006b36:	30 1c       	mov	r12,1
80006b38:	c0 28       	rjmp	80006b3c <xTaskGenericCreate+0x180>
80006b3a:	30 1c       	mov	r12,1
			}
		}
	}

	return xReturn;
}
80006b3c:	2f fd       	sub	sp,-4
80006b3e:	d8 32       	popm	r0-r7,pc
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80006b40:	99 c6       	st.w	r12[0x30],r6
80006b42:	c5 fb       	rjmp	80006a00 <xTaskGenericCreate+0x44>
80006b44:	80 00       	ld.sh	r0,r0[0x0]
80006b46:	5e 94       	retgt	r4
80006b48:	80 00       	ld.sh	r0,r0[0x0]
80006b4a:	5e 6c       	retmi	r12
80006b4c:	80 00       	ld.sh	r0,r0[0x0]
80006b4e:	78 82       	ld.w	r2,r12[0x20]
80006b50:	80 00       	ld.sh	r0,r0[0x0]
80006b52:	7b c4       	ld.w	r4,sp[0x70]
80006b54:	80 00       	ld.sh	r0,r0[0x0]
80006b56:	5b 18       	cp.w	r8,-15
80006b58:	80 00       	ld.sh	r0,r0[0x0]
80006b5a:	5b 94       	cp.w	r4,-7
80006b5c:	80 00       	ld.sh	r0,r0[0x0]
80006b5e:	5c 28       	cpc	r8
80006b60:	00 00       	add	r0,r0
80006b62:	0d 2c       	ld.uh	r12,r6++
80006b64:	00 00       	add	r0,r0
80006b66:	0c e0       	st.h	--r6,r0
80006b68:	00 00       	add	r0,r0
80006b6a:	0c 2c       	rsub	r12,r6
80006b6c:	80 00       	ld.sh	r0,r0[0x0]
80006b6e:	5b 04       	cp.w	r4,-16
80006b70:	00 00       	add	r0,r0
80006b72:	0c f8       	st.b	--r6,r8
80006b74:	00 00       	add	r0,r0
80006b76:	0d 14       	ld.sh	r4,r6++
80006b78:	00 00       	add	r0,r0
80006b7a:	0c e4       	st.h	--r6,r4
80006b7c:	00 00       	add	r0,r0
80006b7e:	0c cc       	st.b	r6++,r12
80006b80:	00 00       	add	r0,r0
80006b82:	0d 34       	ld.ub	r4,r6++
80006b84:	00 00       	add	r0,r0
80006b86:	0c 18       	sub	r8,r6
80006b88:	00 00       	add	r0,r0
80006b8a:	0c 28       	rsub	r8,r6
80006b8c:	00 00       	add	r0,r0
80006b8e:	0c 1c       	sub	r12,r6
80006b90:	00 00       	add	r0,r0
80006b92:	0c 14       	sub	r4,r6
80006b94:	00 00       	add	r0,r0
80006b96:	0d 28       	ld.uh	r8,r6++
80006b98:	00 00       	add	r0,r0
80006b9a:	0d 48       	ld.w	r8,--r6
80006b9c:	80 00       	ld.sh	r0,r0[0x0]
80006b9e:	5b 1e       	cp.w	lr,-15
80006ba0:	80 00       	ld.sh	r0,r0[0x0]
80006ba2:	5d 34       	musfr	r4

80006ba4 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
80006ba4:	d4 01       	pushm	lr
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
80006ba6:	30 09       	mov	r9,0
80006ba8:	1a d9       	st.w	--sp,r9
80006baa:	1a d9       	st.w	--sp,r9
80006bac:	1a d9       	st.w	--sp,r9
80006bae:	12 98       	mov	r8,r9
80006bb0:	e0 6a 01 00 	mov	r10,256
80006bb4:	48 9b       	lddpc	r11,80006bd8 <vTaskStartScheduler+0x34>
80006bb6:	48 ac       	lddpc	r12,80006bdc <vTaskStartScheduler+0x38>
80006bb8:	f0 1f 00 0a 	mcall	80006be0 <vTaskStartScheduler+0x3c>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
80006bbc:	2f dd       	sub	sp,-12
80006bbe:	58 1c       	cp.w	r12,1
80006bc0:	c0 a1       	brne	80006bd4 <vTaskStartScheduler+0x30>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
80006bc2:	d3 03       	ssrf	0x10

		xSchedulerRunning = pdTRUE;
80006bc4:	30 19       	mov	r9,1
80006bc6:	48 88       	lddpc	r8,80006be4 <vTaskStartScheduler+0x40>
80006bc8:	91 09       	st.w	r8[0x0],r9
		xTickCount = ( portTickType ) 0;
80006bca:	30 09       	mov	r9,0
80006bcc:	48 78       	lddpc	r8,80006be8 <vTaskStartScheduler+0x44>
80006bce:	91 09       	st.w	r8[0x0],r9
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
80006bd0:	f0 1f 00 07 	mcall	80006bec <vTaskStartScheduler+0x48>
80006bd4:	d8 02       	popm	pc
80006bd6:	00 00       	add	r0,r0
80006bd8:	80 00       	ld.sh	r0,r0[0x0]
80006bda:	dd 18       	*unknown*
80006bdc:	80 00       	ld.sh	r0,r0[0x0]
80006bde:	69 34       	ld.w	r4,r4[0x4c]
80006be0:	80 00       	ld.sh	r0,r0[0x0]
80006be2:	69 bc       	ld.w	r12,r4[0x6c]
80006be4:	00 00       	add	r0,r0
80006be6:	0c 1c       	sub	r12,r6
80006be8:	00 00       	add	r0,r0
80006bea:	0d 0c       	ld.w	r12,r6++
80006bec:	80 00       	ld.sh	r0,r0[0x0]
80006bee:	5c 38       	neg	r8

80006bf0 <PrintChar>:
	
static void task_log(void * pvParameters);

char *  PrintChar(char c, char * str)
{
	*str++ = c;
80006bf0:	16 cc       	st.b	r11++,r12
	return str;
}
80006bf2:	5e fb       	retal	r11

80006bf4 <PrintHex>:
	
	return str;
}

char * PrintHex(int i,char len, char * str)
{
80006bf4:	eb cd 40 c0 	pushm	r6-r7,lr
80006bf8:	20 3d       	sub	sp,12
80006bfa:	18 98       	mov	r8,r12
	char * p = str;
	char s[12];
	memset(s, 0 , 12);
80006bfc:	30 06       	mov	r6,0
80006bfe:	30 07       	mov	r7,0
80006c00:	fa e7 00 00 	st.d	sp[0],r6
80006c04:	30 0c       	mov	r12,0
80006c06:	50 2c       	stdsp	sp[0x8],r12
	int cnt=0;
	
	if(i)
80006c08:	58 08       	cp.w	r8,0
80006c0a:	c1 30       	breq	80006c30 <PrintHex+0x3c>
80006c0c:	18 99       	mov	r9,r12
	while(i)
	{
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
80006c0e:	1a 9c       	mov	r12,sp
80006c10:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80006c14:	58 9e       	cp.w	lr,9
80006c16:	e0 8a 00 04 	brle	80006c1e <PrintHex+0x2a>
80006c1a:	2c 9e       	sub	lr,-55
80006c1c:	c0 48       	rjmp	80006c24 <PrintHex+0x30>
80006c1e:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80006c22:	2d 0e       	sub	lr,-48
80006c24:	f8 09 0b 0e 	st.b	r12[r9],lr
80006c28:	2f f9       	sub	r9,-1
		i = (i >> 4 ) & 0x0FFFFFFF;
80006c2a:	a5 88       	lsr	r8,0x4
	char s[12];
	memset(s, 0 , 12);
	int cnt=0;
	
	if(i)
	while(i)
80006c2c:	cf 21       	brne	80006c10 <PrintHex+0x1c>
80006c2e:	c0 48       	rjmp	80006c36 <PrintHex+0x42>
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
		i = (i >> 4 ) & 0x0FFFFFFF;
		//i >>= 4
	}
	else
	s[cnt++] = '0';
80006c30:	33 08       	mov	r8,48
80006c32:	ba 88       	st.b	sp[0x0],r8
80006c34:	30 19       	mov	r9,1
	
	if(len - cnt > 0 )
80006c36:	f6 09 01 08 	sub	r8,r11,r9
80006c3a:	58 08       	cp.w	r8,0
80006c3c:	e0 8a 00 13 	brle	80006c62 <PrintHex+0x6e>
	{
		char num = len - cnt;
80006c40:	12 1b       	sub	r11,r9
80006c42:	f9 db c0 08 	bfextu	r12,r11,0x0,0x8
		for(int i = 0; i < num; i++)
80006c46:	18 9e       	mov	lr,r12
80006c48:	58 0c       	cp.w	r12,0
80006c4a:	e0 8a 00 0c 	brle	80006c62 <PrintHex+0x6e>
80006c4e:	1a 9b       	mov	r11,sp
80006c50:	12 0b       	add	r11,r9
80006c52:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80006c54:	33 07       	mov	r7,48
80006c56:	16 c7       	st.b	r11++,r7
	s[cnt++] = '0';
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80006c58:	2f f8       	sub	r8,-1
80006c5a:	1c 38       	cp.w	r8,lr
80006c5c:	cf d5       	brlt	80006c56 <PrintHex+0x62>
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80006c5e:	f8 09 00 09 	add	r9,r12,r9
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80006c62:	f2 c8 ff ff 	sub	r8,r9,-1
	s[cnt++] = '0';
	
	while(cnt>0)
80006c66:	f0 cb ff ff 	sub	r11,r8,-1
80006c6a:	58 0b       	cp.w	r11,0
80006c6c:	e0 8a 00 19 	brle	80006c9e <PrintHex+0xaa>
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80006c70:	fa cb ff f4 	sub	r11,sp,-12
80006c74:	f6 09 00 09 	add	r9,r11,r9
80006c78:	37 8b       	mov	r11,120
80006c7a:	f3 6b ff f4 	st.b	r9[-12],r11
	s[cnt++] = '0';
80006c7e:	fa c9 ff f4 	sub	r9,sp,-12
80006c82:	10 09       	add	r9,r8
80006c84:	33 0b       	mov	r11,48
80006c86:	f3 6b ff f4 	st.b	r9[-12],r11
80006c8a:	fa 08 00 08 	add	r8,sp,r8
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80006c8e:	fa ce 00 01 	sub	lr,sp,1
80006c92:	14 99       	mov	r9,r10
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
	*p++ = s[--cnt];
80006c94:	11 8b       	ld.ub	r11,r8[0x0]
80006c96:	12 cb       	st.b	r9++,r11
80006c98:	20 18       	sub	r8,1
	}
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
80006c9a:	1c 38       	cp.w	r8,lr
80006c9c:	cf c1       	brne	80006c94 <PrintHex+0xa0>
	*p++ = s[--cnt];
		
	return str;
}
80006c9e:	14 9c       	mov	r12,r10
80006ca0:	2f dd       	sub	sp,-12
80006ca2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

80006ca6 <PrintDec>:
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
{
80006ca6:	d4 21       	pushm	r4-r7,lr
80006ca8:	20 3d       	sub	sp,12
80006caa:	18 98       	mov	r8,r12
	char * p = str;
	
	int sign = i>=0 ? 0 : 1;
	char s[10];
	memset(s, 0 , 10);
80006cac:	30 06       	mov	r6,0
80006cae:	30 07       	mov	r7,0
80006cb0:	fa e7 00 00 	st.d	sp[0],r6
80006cb4:	30 0c       	mov	r12,0
80006cb6:	ba 4c       	st.h	sp[0x8],r12
	int cnt=0;
	if(sign)
80006cb8:	58 08       	cp.w	r8,0
80006cba:	c0 35       	brlt	80006cc0 <PrintDec+0x1a>
80006cbc:	14 97       	mov	r7,r10
80006cbe:	c0 58       	rjmp	80006cc8 <PrintDec+0x22>
	{
		*p++ = '-';
80006cc0:	14 97       	mov	r7,r10
80006cc2:	32 d9       	mov	r9,45
80006cc4:	0e c9       	st.b	r7++,r9
		i = -i;
80006cc6:	5c 38       	neg	r8
	}
	
	if(i == 0 )s[cnt++] = '0';
80006cc8:	58 08       	cp.w	r8,0
80006cca:	c0 51       	brne	80006cd4 <PrintDec+0x2e>
80006ccc:	33 08       	mov	r8,48
80006cce:	ba 88       	st.b	sp[0x0],r8
80006cd0:	30 1e       	mov	lr,1
80006cd2:	c2 f8       	rjmp	80006d30 <PrintDec+0x8a>
	
	int ten = i%10;
80006cd4:	e0 65 66 67 	mov	r5,26215
80006cd8:	ea 15 66 66 	orh	r5,0x6666
80006cdc:	f0 05 04 44 	muls.d	r4,r8,r5
80006ce0:	ea 0c 14 02 	asr	r12,r5,0x2
80006ce4:	f0 09 14 1f 	asr	r9,r8,0x1f
80006ce8:	f8 09 01 09 	sub	r9,r12,r9
80006cec:	f2 09 00 29 	add	r9,r9,r9<<0x2
80006cf0:	f0 09 01 19 	sub	r9,r8,r9<<0x1
80006cf4:	30 0e       	mov	lr,0
	while(i)
	{
		s[cnt] = ten+'0';
80006cf6:	1a 9c       	mov	r12,sp
		cnt++;
		i /= 10;
80006cf8:	e0 66 66 67 	mov	r6,26215
80006cfc:	ea 16 66 66 	orh	r6,0x6666
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
	{
		s[cnt] = ten+'0';
80006d00:	2d 09       	sub	r9,-48
80006d02:	f8 0e 0b 09 	st.b	r12[lr],r9
		cnt++;
80006d06:	2f fe       	sub	lr,-1
		i /= 10;
80006d08:	f0 06 04 44 	muls.d	r4,r8,r6
80006d0c:	ea 09 14 02 	asr	r9,r5,0x2
80006d10:	bf 58       	asr	r8,0x1f
80006d12:	f2 08 01 08 	sub	r8,r9,r8
		ten = i%10;
80006d16:	f0 06 04 44 	muls.d	r4,r8,r6
80006d1a:	ea 09 14 02 	asr	r9,r5,0x2
80006d1e:	f0 05 14 1f 	asr	r5,r8,0x1f
80006d22:	0a 19       	sub	r9,r5
80006d24:	f2 09 00 29 	add	r9,r9,r9<<0x2
80006d28:	f0 09 01 19 	sub	r9,r8,r9<<0x1
	}
	
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
80006d2c:	58 08       	cp.w	r8,0
80006d2e:	ce 91       	brne	80006d00 <PrintDec+0x5a>
		cnt++;
		i /= 10;
		ten = i%10;
	}
	
	if(len - cnt > 0 )
80006d30:	f6 0e 01 08 	sub	r8,r11,lr
80006d34:	58 08       	cp.w	r8,0
80006d36:	e0 89 00 06 	brgt	80006d42 <PrintDec+0x9c>
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80006d3a:	58 0e       	cp.w	lr,0
80006d3c:	e0 89 00 14 	brgt	80006d64 <PrintDec+0xbe>
80006d40:	c1 d8       	rjmp	80006d7a <PrintDec+0xd4>
		ten = i%10;
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
80006d42:	1c 1b       	sub	r11,lr
80006d44:	5c 5b       	castu.b	r11
		for(int i = 0; i < num; i++)
80006d46:	16 9c       	mov	r12,r11
80006d48:	58 0b       	cp.w	r11,0
80006d4a:	fe 9a ff f8 	brle	80006d3a <PrintDec+0x94>
80006d4e:	1a 99       	mov	r9,sp
80006d50:	1c 09       	add	r9,lr
80006d52:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80006d54:	33 06       	mov	r6,48
80006d56:	12 c6       	st.b	r9++,r6
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80006d58:	2f f8       	sub	r8,-1
80006d5a:	18 38       	cp.w	r8,r12
80006d5c:	cf d5       	brlt	80006d56 <PrintDec+0xb0>
{
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
80006d5e:	f6 0e 00 0e 	add	lr,r11,lr
80006d62:	ce cb       	rjmp	80006d3a <PrintDec+0x94>
80006d64:	fa c8 ff f4 	sub	r8,sp,-12
80006d68:	1c 08       	add	r8,lr
80006d6a:	20 d8       	sub	r8,13
80006d6c:	fa cb 00 01 	sub	r11,sp,1
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
	*p++ = s[--cnt];
80006d70:	11 89       	ld.ub	r9,r8[0x0]
80006d72:	0e c9       	st.b	r7++,r9
80006d74:	20 18       	sub	r8,1
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80006d76:	16 38       	cp.w	r8,r11
80006d78:	cf c1       	brne	80006d70 <PrintDec+0xca>
	*p++ = s[--cnt];
	
	return str;
}
80006d7a:	14 9c       	mov	r12,r10
80006d7c:	2f dd       	sub	sp,-12
80006d7e:	d8 22       	popm	r4-r7,pc

80006d80 <log>:
	,  NULL );
	
}

int log(char * content, ...)
{
80006d80:	d4 31       	pushm	r0-r7,lr
80006d82:	fa cd 02 08 	sub	sp,sp,520
80006d86:	18 97       	mov	r7,r12
	
	
	char logTmp[MAX_LOG_LINE_SIZE];
	memset(logTmp, '\0', MAX_LOG_LINE_SIZE);	
80006d88:	e0 6a 01 00 	mov	r10,256
80006d8c:	30 0b       	mov	r11,0
80006d8e:	fa cc fe f8 	sub	r12,sp,-264
80006d92:	f0 1f 00 4e 	mcall	80006ec8 <log+0x148>
	,  tskLOG_PRIORITY
	,  NULL );
	
}

int log(char * content, ...)
80006d96:	fa c4 fd d4 	sub	r4,sp,-556
80006d9a:	30 0a       	mov	r10,0
80006d9c:	50 0a       	stdsp	sp[0x0],r10
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80006d9e:	fa c3 ff fc 	sub	r3,sp,-4
80006da2:	e0 61 01 00 	mov	r1,256
80006da6:	14 90       	mov	r0,r10
			
					if(*str == '%')
80006da8:	32 52       	mov	r2,37
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
80006daa:	fa c6 fe f8 	sub	r6,sp,-264
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80006dae:	02 9a       	mov	r10,r1
80006db0:	00 9b       	mov	r11,r0
80006db2:	06 9c       	mov	r12,r3
80006db4:	f0 1f 00 45 	mcall	80006ec8 <log+0x148>
			
					if(*str == '%')
80006db8:	0f 88       	ld.ub	r8,r7[0x0]
80006dba:	e4 08 18 00 	cp.b	r8,r2
80006dbe:	c5 71       	brne	80006e6c <log+0xec>
					{
						static char lench = 0;
						lench =*(str + 1);
80006dc0:	ee c8 ff ff 	sub	r8,r7,-1
80006dc4:	11 89       	ld.ub	r9,r8[0x0]
80006dc6:	4c 2a       	lddpc	r10,80006ecc <log+0x14c>
80006dc8:	b4 89       	st.b	r10[0x0],r9
						if((lench >= '0') &&  (lench <= '9'))
80006dca:	23 09       	sub	r9,48
80006dcc:	30 9a       	mov	r10,9
80006dce:	f4 09 18 00 	cp.b	r9,r10
80006dd2:	ee 08 17 b0 	movhi	r8,r7
						{
							len = *(++str) - '0';
80006dd6:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
80006dda:	f7 b9 08 30 	subls	r9,48
80006dde:	fb f9 8a 00 	st.wls	sp[0x0],r9
						}
						
						str++;
80006de2:	f0 c7 ff ff 	sub	r7,r8,-1
						
						switch(*(str))
80006de6:	0f 88       	ld.ub	r8,r7[0x0]
80006de8:	22 58       	sub	r8,37
80006dea:	e0 48 00 53 	cp.w	r8,83
80006dee:	e0 8b 00 31 	brhi	80006e50 <log+0xd0>
80006df2:	4b 89       	lddpc	r9,80006ed0 <log+0x150>
80006df4:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
						{
							case('i'):
							case('I'):
							case('d'):
							case('D'):
							x = va_arg(arg_ptr,int);
80006df8:	e8 c5 ff fc 	sub	r5,r4,-4
							strTmp = PrintDec(x, len, strTmp);
80006dfc:	06 9a       	mov	r10,r3
80006dfe:	40 0b       	lddsp	r11,sp[0x0]
80006e00:	5c 5b       	castu.b	r11
80006e02:	68 0c       	ld.w	r12,r4[0x0]
80006e04:	f0 1f 00 34 	mcall	80006ed4 <log+0x154>
							break;
80006e08:	c2 98       	rjmp	80006e5a <log+0xda>
							
							case('f')://浮点数输出
							case('F'):
							//f = va_arg(arg_ptr,int);
							//strTmp = PrintDec(x, len, strTmp);
							log("I need float.");
80006e0a:	4b 4c       	lddpc	r12,80006ed8 <log+0x158>
80006e0c:	f0 1f 00 34 	mcall	80006edc <log+0x15c>
80006e10:	08 95       	mov	r5,r4
80006e12:	06 9c       	mov	r12,r3
							break;
80006e14:	c2 38       	rjmp	80006e5a <log+0xda>
							
							
							case('x'):
							case('X'):
							x = va_arg(arg_ptr,int);
80006e16:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintHex(x,len, strTmp);
80006e1a:	06 9a       	mov	r10,r3
80006e1c:	40 0b       	lddsp	r11,sp[0x0]
80006e1e:	5c 5b       	castu.b	r11
80006e20:	68 0c       	ld.w	r12,r4[0x0]
80006e22:	f0 1f 00 30 	mcall	80006ee0 <log+0x160>
80006e26:	06 9c       	mov	r12,r3
							break;
80006e28:	c1 98       	rjmp	80006e5a <log+0xda>
							
							case('c'):
							case('C'):
							y = va_arg(arg_ptr,int);
80006e2a:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintChar(y, strTmp);
80006e2e:	06 9b       	mov	r11,r3
80006e30:	09 bc       	ld.ub	r12,r4[0x3]
80006e32:	f0 1f 00 2d 	mcall	80006ee4 <log+0x164>
80006e36:	06 9c       	mov	r12,r3
							break;
80006e38:	c1 18       	rjmp	80006e5a <log+0xda>
							
							case('s'):
							case('S'):
							strTmp = va_arg(arg_ptr,char*);
80006e3a:	e8 c5 ff fc 	sub	r5,r4,-4
80006e3e:	68 0c       	ld.w	r12,r4[0x0]
							//PrintStr(s);
							break;
80006e40:	c0 d8       	rjmp	80006e5a <log+0xda>
							
							case('%'):
							PrintChar('%', strTmp);
80006e42:	06 9b       	mov	r11,r3
80006e44:	32 5c       	mov	r12,37
80006e46:	f0 1f 00 28 	mcall	80006ee4 <log+0x164>
80006e4a:	08 95       	mov	r5,r4
80006e4c:	06 9c       	mov	r12,r3
							//PrintChar('%');
							break;
80006e4e:	c0 68       	rjmp	80006e5a <log+0xda>
							
							default:
							log("I need relax.");
80006e50:	4a 6c       	lddpc	r12,80006ee8 <log+0x168>
80006e52:	f0 1f 00 23 	mcall	80006edc <log+0x15c>
80006e56:	08 95       	mov	r5,r4
80006e58:	06 9c       	mov	r12,r3
						}
						str++;
80006e5a:	2f f7       	sub	r7,-1
						
						length = sprintf(logTmp,"%s%s",logTmp,strTmp );
80006e5c:	1a dc       	st.w	--sp,r12
80006e5e:	1a d6       	st.w	--sp,r6
80006e60:	4a 3b       	lddpc	r11,80006eec <log+0x16c>
80006e62:	0c 9c       	mov	r12,r6
80006e64:	f0 1f 00 23 	mcall	80006ef0 <log+0x170>
80006e68:	2f ed       	sub	sp,-8
80006e6a:	c0 a8       	rjmp	80006e7e <log+0xfe>
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
80006e6c:	2f f7       	sub	r7,-1
80006e6e:	1a d8       	st.w	--sp,r8
80006e70:	1a d6       	st.w	--sp,r6
80006e72:	4a 1b       	lddpc	r11,80006ef4 <log+0x174>
80006e74:	0c 9c       	mov	r12,r6
80006e76:	f0 1f 00 1f 	mcall	80006ef0 <log+0x170>
80006e7a:	08 95       	mov	r5,r4
80006e7c:	2f ed       	sub	sp,-8
			
			
			
	}while(*str != '\0');
80006e7e:	0f 89       	ld.ub	r9,r7[0x0]
80006e80:	30 08       	mov	r8,0
80006e82:	f0 09 18 00 	cp.b	r9,r8
80006e86:	c0 30       	breq	80006e8c <log+0x10c>
80006e88:	0a 94       	mov	r4,r5
80006e8a:	c9 2b       	rjmp	80006dae <log+0x2e>
		
		
				
	va_end(arg_ptr);
	//while(1)		
	length = sprintf(logTmp,"%s\r\n",logTmp);
80006e8c:	fa c7 fe f8 	sub	r7,sp,-264
80006e90:	1a d7       	st.w	--sp,r7
80006e92:	49 ab       	lddpc	r11,80006ef8 <log+0x178>
80006e94:	0e 9c       	mov	r12,r7
80006e96:	f0 1f 00 17 	mcall	80006ef0 <log+0x170>
	
	char * p = pvPortMalloc(length+1);
80006e9a:	5c 5c       	castu.b	r12
80006e9c:	f8 c6 ff ff 	sub	r6,r12,-1
80006ea0:	0c 9c       	mov	r12,r6
80006ea2:	f0 1f 00 17 	mcall	80006efc <log+0x17c>
80006ea6:	54 2c       	stdsp	sp[0x108],r12
	memcpy(p, logTmp, length+1);
80006ea8:	0c 9a       	mov	r10,r6
80006eaa:	0e 9b       	mov	r11,r7
80006eac:	f0 1f 00 15 	mcall	80006f00 <log+0x180>
	//
	//usart_write_line(EXAMPLE_USART, logTmp)
	
	xQueueSend( logQueue, &p, 5);
80006eb0:	30 09       	mov	r9,0
80006eb2:	30 5a       	mov	r10,5
80006eb4:	fa cb fe f8 	sub	r11,sp,-264
80006eb8:	49 38       	lddpc	r8,80006f04 <log+0x184>
80006eba:	70 0c       	ld.w	r12,r8[0x0]
80006ebc:	f0 1f 00 13 	mcall	80006f08 <log+0x188>
80006ec0:	2f fd       	sub	sp,-4
	
	
}
80006ec2:	fe 3d fd f8 	sub	sp,-520
80006ec6:	d8 32       	popm	r0-r7,pc
80006ec8:	80 00       	ld.sh	r0,r0[0x0]
80006eca:	78 82       	ld.w	r2,r12[0x20]
80006ecc:	00 00       	add	r0,r0
80006ece:	0d 4c       	ld.w	r12,--r6
80006ed0:	80 00       	ld.sh	r0,r0[0x0]
80006ed2:	dd 20       	acall	0xd2
80006ed4:	80 00       	ld.sh	r0,r0[0x0]
80006ed6:	6c a6       	ld.w	r6,r6[0x28]
80006ed8:	80 00       	ld.sh	r0,r0[0x0]
80006eda:	df cc       	*unknown*
80006edc:	80 00       	ld.sh	r0,r0[0x0]
80006ede:	6d 80       	ld.w	r0,r6[0x60]
80006ee0:	80 00       	ld.sh	r0,r0[0x0]
80006ee2:	6b f4       	ld.w	r4,r5[0x7c]
80006ee4:	80 00       	ld.sh	r0,r0[0x0]
80006ee6:	6b f0       	ld.w	r0,r5[0x7c]
80006ee8:	80 00       	ld.sh	r0,r0[0x0]
80006eea:	df dc       	*unknown*
80006eec:	80 00       	ld.sh	r0,r0[0x0]
80006eee:	df ec       	*unknown*
80006ef0:	80 00       	ld.sh	r0,r0[0x0]
80006ef2:	7b 70       	ld.w	r0,sp[0x5c]
80006ef4:	80 00       	ld.sh	r0,r0[0x0]
80006ef6:	df f4       	*unknown*
80006ef8:	80 00       	ld.sh	r0,r0[0x0]
80006efa:	df fc       	*unknown*
80006efc:	80 00       	ld.sh	r0,r0[0x0]
80006efe:	5e 94       	retgt	r4
80006f00:	80 00       	ld.sh	r0,r0[0x0]
80006f02:	77 3a       	ld.w	r10,r11[0x4c]
80006f04:	00 00       	add	r0,r0
80006f06:	63 98       	ld.w	r8,r1[0x64]
80006f08:	80 00       	ld.sh	r0,r0[0x0]
80006f0a:	61 e8       	ld.w	r8,r0[0x78]

80006f0c <logFromISR>:
	
	
int logFromISR(char * content, ...)
	{
80006f0c:	d4 31       	pushm	r0-r7,lr
80006f0e:	fa cd 02 0c 	sub	sp,sp,524
80006f12:	18 97       	mov	r7,r12
		
		
		char logTmp[MAX_LOG_LINE_SIZE];
		memset(logTmp, '\0', MAX_LOG_LINE_SIZE);
80006f14:	e0 6a 01 00 	mov	r10,256
80006f18:	30 0b       	mov	r11,0
80006f1a:	fa cc fe f4 	sub	r12,sp,-268
80006f1e:	f0 1f 00 4c 	mcall	8000704c <logFromISR+0x140>
	
	
}
	
	
int logFromISR(char * content, ...)
80006f22:	fa c4 fd d0 	sub	r4,sp,-560
80006f26:	30 0a       	mov	r10,0
80006f28:	50 0a       	stdsp	sp[0x0],r10
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80006f2a:	fa c3 ff fc 	sub	r3,sp,-4
80006f2e:	e0 61 01 00 	mov	r1,256
80006f32:	14 90       	mov	r0,r10
			
			if(*str == '%')
80006f34:	32 52       	mov	r2,37
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
80006f36:	fa c6 fe f4 	sub	r6,sp,-268
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80006f3a:	02 9a       	mov	r10,r1
80006f3c:	00 9b       	mov	r11,r0
80006f3e:	06 9c       	mov	r12,r3
80006f40:	f0 1f 00 43 	mcall	8000704c <logFromISR+0x140>
			
			if(*str == '%')
80006f44:	0f 88       	ld.ub	r8,r7[0x0]
80006f46:	e4 08 18 00 	cp.b	r8,r2
80006f4a:	c5 11       	brne	80006fec <logFromISR+0xe0>
			{
				static char lench = 0;
				lench =*(str + 1);
80006f4c:	ee c8 ff ff 	sub	r8,r7,-1
80006f50:	11 89       	ld.ub	r9,r8[0x0]
80006f52:	4c 0a       	lddpc	r10,80007050 <logFromISR+0x144>
80006f54:	b4 89       	st.b	r10[0x0],r9
				if((lench >= '0') &&  (lench <= '9'))
80006f56:	23 09       	sub	r9,48
80006f58:	30 9a       	mov	r10,9
80006f5a:	f4 09 18 00 	cp.b	r9,r10
80006f5e:	ee 08 17 b0 	movhi	r8,r7
				{
					len = *(++str) - '0';
80006f62:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
80006f66:	f7 b9 08 30 	subls	r9,48
80006f6a:	fb f9 8a 00 	st.wls	sp[0x0],r9
				}
				
				str++;
80006f6e:	f0 c7 ff ff 	sub	r7,r8,-1
				
				switch(*(str))
80006f72:	0f 88       	ld.ub	r8,r7[0x0]
80006f74:	22 58       	sub	r8,37
80006f76:	e0 48 00 53 	cp.w	r8,83
80006f7a:	e0 8b 00 2b 	brhi	80006fd0 <logFromISR+0xc4>
80006f7e:	4b 69       	lddpc	r9,80007054 <logFromISR+0x148>
80006f80:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
				{
					case('d'):
					case('D'):
					x = va_arg(arg_ptr,int);
80006f84:	e8 c5 ff fc 	sub	r5,r4,-4
					strTmp = PrintDec(x, len, strTmp);
80006f88:	06 9a       	mov	r10,r3
80006f8a:	40 0b       	lddsp	r11,sp[0x0]
80006f8c:	5c 5b       	castu.b	r11
80006f8e:	68 0c       	ld.w	r12,r4[0x0]
80006f90:	f0 1f 00 32 	mcall	80007058 <logFromISR+0x14c>
					break;
80006f94:	c2 38       	rjmp	80006fda <logFromISR+0xce>
					case('x'):
					case('X'):
					x = va_arg(arg_ptr,int);
80006f96:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintHex(x,len, strTmp);
80006f9a:	06 9a       	mov	r10,r3
80006f9c:	40 0b       	lddsp	r11,sp[0x0]
80006f9e:	5c 5b       	castu.b	r11
80006fa0:	68 0c       	ld.w	r12,r4[0x0]
80006fa2:	f0 1f 00 2f 	mcall	8000705c <logFromISR+0x150>
80006fa6:	06 9c       	mov	r12,r3
					break;
80006fa8:	c1 98       	rjmp	80006fda <logFromISR+0xce>
					case('c'):
					case('C'):
					y = va_arg(arg_ptr,int);
80006faa:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintChar(y, strTmp);
80006fae:	06 9b       	mov	r11,r3
80006fb0:	09 bc       	ld.ub	r12,r4[0x3]
80006fb2:	f0 1f 00 2c 	mcall	80007060 <logFromISR+0x154>
80006fb6:	06 9c       	mov	r12,r3
					break;
80006fb8:	c1 18       	rjmp	80006fda <logFromISR+0xce>
					case('s'):
					case('S'):
					strTmp = va_arg(arg_ptr,char*);
80006fba:	e8 c5 ff fc 	sub	r5,r4,-4
80006fbe:	68 0c       	ld.w	r12,r4[0x0]
					//PrintStr(s);
					break;
80006fc0:	c0 d8       	rjmp	80006fda <logFromISR+0xce>
					case('%'):
					PrintChar('%', strTmp);
80006fc2:	06 9b       	mov	r11,r3
80006fc4:	32 5c       	mov	r12,37
80006fc6:	f0 1f 00 27 	mcall	80007060 <logFromISR+0x154>
80006fca:	08 95       	mov	r5,r4
80006fcc:	06 9c       	mov	r12,r3
					//PrintChar('%');
					break;
80006fce:	c0 68       	rjmp	80006fda <logFromISR+0xce>
					default:
					log("I need relax.");
80006fd0:	4a 5c       	lddpc	r12,80007064 <logFromISR+0x158>
80006fd2:	f0 1f 00 26 	mcall	80007068 <logFromISR+0x15c>
80006fd6:	08 95       	mov	r5,r4
80006fd8:	06 9c       	mov	r12,r3
				}
				str++;
80006fda:	2f f7       	sub	r7,-1
				
				length = sprintf(logTmp,"%s%s",logTmp,strTmp );
80006fdc:	1a dc       	st.w	--sp,r12
80006fde:	1a d6       	st.w	--sp,r6
80006fe0:	4a 3b       	lddpc	r11,8000706c <logFromISR+0x160>
80006fe2:	0c 9c       	mov	r12,r6
80006fe4:	f0 1f 00 23 	mcall	80007070 <logFromISR+0x164>
80006fe8:	2f ed       	sub	sp,-8
80006fea:	c0 a8       	rjmp	80006ffe <logFromISR+0xf2>
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
80006fec:	2f f7       	sub	r7,-1
80006fee:	1a d8       	st.w	--sp,r8
80006ff0:	1a d6       	st.w	--sp,r6
80006ff2:	4a 1b       	lddpc	r11,80007074 <logFromISR+0x168>
80006ff4:	0c 9c       	mov	r12,r6
80006ff6:	f0 1f 00 1f 	mcall	80007070 <logFromISR+0x164>
80006ffa:	08 95       	mov	r5,r4
80006ffc:	2f ed       	sub	sp,-8
			
			
			
		}while(*str != '\0');
80006ffe:	0f 89       	ld.ub	r9,r7[0x0]
80007000:	30 08       	mov	r8,0
80007002:	f0 09 18 00 	cp.b	r9,r8
80007006:	c0 30       	breq	8000700c <logFromISR+0x100>
80007008:	0a 94       	mov	r4,r5
8000700a:	c9 8b       	rjmp	80006f3a <logFromISR+0x2e>
		
		
		
		va_end(arg_ptr);
		//while(1)
		length = sprintf(logTmp,"%s\r\n",logTmp);
8000700c:	fa c7 fe f4 	sub	r7,sp,-268
80007010:	1a d7       	st.w	--sp,r7
80007012:	49 ab       	lddpc	r11,80007078 <logFromISR+0x16c>
80007014:	0e 9c       	mov	r12,r7
80007016:	f0 1f 00 17 	mcall	80007070 <logFromISR+0x164>
		
		char * p = pvPortMalloc(length+1);
8000701a:	5c 5c       	castu.b	r12
8000701c:	f8 c6 ff ff 	sub	r6,r12,-1
80007020:	0c 9c       	mov	r12,r6
80007022:	f0 1f 00 17 	mcall	8000707c <logFromISR+0x170>
80007026:	54 3c       	stdsp	sp[0x10c],r12
		memcpy(p, logTmp, length+1);
80007028:	0c 9a       	mov	r10,r6
8000702a:	0e 9b       	mov	r11,r7
8000702c:	f0 1f 00 15 	mcall	80007080 <logFromISR+0x174>
		//
		portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80007030:	30 09       	mov	r9,0
80007032:	54 29       	stdsp	sp[0x108],r9
		
		//usart_write_line(EXAMPLE_USART, p);
		//vPortFree(p);
		xQueueSendFromISR( logQueue, &p, &xHigherPriorityTaskWoken );
80007034:	fa ca fe f8 	sub	r10,sp,-264
80007038:	fa cb fe f4 	sub	r11,sp,-268
8000703c:	49 28       	lddpc	r8,80007084 <logFromISR+0x178>
8000703e:	70 0c       	ld.w	r12,r8[0x0]
80007040:	f0 1f 00 12 	mcall	80007088 <logFromISR+0x17c>
80007044:	2f fd       	sub	sp,-4
		
		//if (xHigherPriorityTaskWoken == pdTRUE)
		//{
			////taskYIELD();
		//}
	}
80007046:	fe 3d fd f4 	sub	sp,-524
8000704a:	d8 32       	popm	r0-r7,pc
8000704c:	80 00       	ld.sh	r0,r0[0x0]
8000704e:	78 82       	ld.w	r2,r12[0x20]
80007050:	00 00       	add	r0,r0
80007052:	0d 4d       	ld.w	sp,--r6
80007054:	80 00       	ld.sh	r0,r0[0x0]
80007056:	de 70       	acall	0xe7
80007058:	80 00       	ld.sh	r0,r0[0x0]
8000705a:	6c a6       	ld.w	r6,r6[0x28]
8000705c:	80 00       	ld.sh	r0,r0[0x0]
8000705e:	6b f4       	ld.w	r4,r5[0x7c]
80007060:	80 00       	ld.sh	r0,r0[0x0]
80007062:	6b f0       	ld.w	r0,r5[0x7c]
80007064:	80 00       	ld.sh	r0,r0[0x0]
80007066:	df dc       	*unknown*
80007068:	80 00       	ld.sh	r0,r0[0x0]
8000706a:	6d 80       	ld.w	r0,r6[0x60]
8000706c:	80 00       	ld.sh	r0,r0[0x0]
8000706e:	df ec       	*unknown*
80007070:	80 00       	ld.sh	r0,r0[0x0]
80007072:	7b 70       	ld.w	r0,sp[0x5c]
80007074:	80 00       	ld.sh	r0,r0[0x0]
80007076:	df f4       	*unknown*
80007078:	80 00       	ld.sh	r0,r0[0x0]
8000707a:	df fc       	*unknown*
8000707c:	80 00       	ld.sh	r0,r0[0x0]
8000707e:	5e 94       	retgt	r4
80007080:	80 00       	ld.sh	r0,r0[0x0]
80007082:	77 3a       	ld.w	r10,r11[0x4c]
80007084:	00 00       	add	r0,r0
80007086:	63 98       	ld.w	r8,r1[0x64]
80007088:	80 00       	ld.sh	r0,r0[0x0]
8000708a:	61 98       	ld.w	r8,r0[0x64]

8000708c <log_init>:
		
	return str;
}

void log_init(void)
{
8000708c:	d4 01       	pushm	lr
		.stopbits     = USART_1_STOPBIT,
		.channelmode  = USART_NORMAL_CHMODE
	};

	// Assign GPIO to USART.
	gpio_enable_module(USART_GPIO_MAP,
8000708e:	30 2b       	mov	r11,2
80007090:	49 0c       	lddpc	r12,800070d0 <log_init+0x44>
80007092:	f0 1f 00 11 	mcall	800070d4 <log_init+0x48>
	sizeof(USART_GPIO_MAP) / sizeof(USART_GPIO_MAP[0]));

	// Initialize USART in RS232 mode.
	usart_init_rs232(EXAMPLE_USART, &USART_OPTIONS, EXAMPLE_TARGET_PBACLK_FREQ_HZ);			
80007096:	e0 6a 36 00 	mov	r10,13824
8000709a:	ea 1a 01 6e 	orh	r10,0x16e
8000709e:	48 fb       	lddpc	r11,800070d8 <log_init+0x4c>
800070a0:	fe 7c 18 00 	mov	r12,-59392
800070a4:	f0 1f 00 0e 	mcall	800070dc <log_init+0x50>
			
	logQueue  = xQueueCreate(50, sizeof(char *));
800070a8:	30 4b       	mov	r11,4
800070aa:	33 2c       	mov	r12,50
800070ac:	f0 1f 00 0d 	mcall	800070e0 <log_init+0x54>
800070b0:	48 d8       	lddpc	r8,800070e4 <log_init+0x58>
800070b2:	91 0c       	st.w	r8[0x0],r12
	
	xTaskCreate(
800070b4:	30 09       	mov	r9,0
800070b6:	1a d9       	st.w	--sp,r9
800070b8:	1a d9       	st.w	--sp,r9
800070ba:	1a d9       	st.w	--sp,r9
800070bc:	30 28       	mov	r8,2
800070be:	e0 6a 01 80 	mov	r10,384
800070c2:	48 ab       	lddpc	r11,800070e8 <log_init+0x5c>
800070c4:	48 ac       	lddpc	r12,800070ec <log_init+0x60>
800070c6:	f0 1f 00 0b 	mcall	800070f0 <log_init+0x64>
800070ca:	2f dd       	sub	sp,-12
	,  384
	,  NULL
	,  tskLOG_PRIORITY
	,  NULL );
	
}
800070cc:	d8 02       	popm	pc
800070ce:	00 00       	add	r0,r0
800070d0:	80 00       	ld.sh	r0,r0[0x0]
800070d2:	e0 08       	*unknown*
800070d4:	80 00       	ld.sh	r0,r0[0x0]
800070d6:	72 18       	ld.w	r8,r9[0x4]
800070d8:	80 00       	ld.sh	r0,r0[0x0]
800070da:	df c0       	acall	0xfc
800070dc:	80 00       	ld.sh	r0,r0[0x0]
800070de:	5a 38       	cp.w	r8,-29
800070e0:	80 00       	ld.sh	r0,r0[0x0]
800070e2:	62 e8       	ld.w	r8,r1[0x38]
800070e4:	00 00       	add	r0,r0
800070e6:	63 98       	ld.w	r8,r1[0x64]
800070e8:	80 00       	ld.sh	r0,r0[0x0]
800070ea:	e0 04       	*unknown*
800070ec:	80 00       	ld.sh	r0,r0[0x0]
800070ee:	70 f4       	ld.w	r4,r8[0x3c]
800070f0:	80 00       	ld.sh	r0,r0[0x0]
800070f2:	69 bc       	ld.w	r12,r4[0x6c]

800070f4 <task_log>:
			////taskYIELD();
		//}
	}
	
static void task_log(void * pvParameters)
{
800070f4:	eb cd 40 f8 	pushm	r3-r7,lr
800070f8:	20 1d       	sub	sp,4
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
800070fa:	48 c7       	lddpc	r7,80007128 <task_log+0x34>
800070fc:	30 05       	mov	r5,0
800070fe:	3f f4       	mov	r4,-1
		{
			if( NULL != str)
			{
				usart_write_line(EXAMPLE_USART, str);
80007100:	fe 73 18 00 	mov	r3,-59392
{
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
80007104:	0a 99       	mov	r9,r5
80007106:	08 9a       	mov	r10,r4
80007108:	1a 9b       	mov	r11,sp
8000710a:	6e 0c       	ld.w	r12,r7[0x0]
8000710c:	f0 1f 00 08 	mcall	8000712c <task_log+0x38>
80007110:	58 1c       	cp.w	r12,1
80007112:	cf 91       	brne	80007104 <task_log+0x10>
		{
			if( NULL != str)
80007114:	40 0b       	lddsp	r11,sp[0x0]
80007116:	58 0b       	cp.w	r11,0
80007118:	cf 60       	breq	80007104 <task_log+0x10>
			{
				usart_write_line(EXAMPLE_USART, str);
8000711a:	06 9c       	mov	r12,r3
8000711c:	f0 1f 00 05 	mcall	80007130 <task_log+0x3c>
				vPortFree(str);
80007120:	40 0c       	lddsp	r12,sp[0x0]
80007122:	f0 1f 00 05 	mcall	80007134 <task_log+0x40>
80007126:	ce fb       	rjmp	80007104 <task_log+0x10>
80007128:	00 00       	add	r0,r0
8000712a:	63 98       	ld.w	r8,r1[0x64]
8000712c:	80 00       	ld.sh	r0,r0[0x0]
8000712e:	5f dc       	srvc	r12
80007130:	80 00       	ld.sh	r0,r0[0x0]
80007132:	59 e8       	cp.w	r8,30
80007134:	80 00       	ld.sh	r0,r0[0x0]
80007136:	5e 6c       	retmi	r12

80007138 <main>:
#include "fs/fs.h"
#include "rtc/rtc.h"
#include "voice/voice.h"

int main(void)
{
80007138:	d4 01       	pushm	lr
	//Force SSC_TX_DATA_ENABLE Disabled as soon as possible.
	AVR32_GPIO.port[1].ovrs  =  0x00000001;  //Value will be high.
8000713a:	fe 78 10 00 	mov	r8,-61440
8000713e:	30 19       	mov	r9,1
80007140:	f1 49 01 54 	st.w	r8[340],r9
	AVR32_GPIO.port[1].oders =  0x00000001;  //Output Driver will be Enabled.
80007144:	f1 49 01 44 	st.w	r8[324],r9
	AVR32_GPIO.port[1].gpers =  0x00000001;  //Enable as GPIO.
80007148:	f1 49 01 04 	st.w	r8[260],r9
	
	Disable_global_interrupt();
8000714c:	d3 03       	ssrf	0x10
	local_start_pll0();
8000714e:	f0 1f 00 13 	mcall	80007198 <main+0x60>
		
	INTC_init_interrupts();
80007152:	f0 1f 00 13 	mcall	8000719c <main+0x64>
	
	log_init();		
80007156:	f0 1f 00 13 	mcall	800071a0 <main+0x68>
	log("----start debug----");	
8000715a:	49 3c       	lddpc	r12,800071a4 <main+0x6c>
8000715c:	f0 1f 00 13 	mcall	800071a8 <main+0x70>
		
	//rtc_init();
	
	//fs_init();//65795机器无法通过文件系统初始化,究起原因，貌似是Radio对OB板的输出功率无法满足SD卡的正常工作。
	
	voc_init();
80007160:	f0 1f 00 13 	mcall	800071ac <main+0x74>

	tc_init();	
80007164:	f0 1f 00 13 	mcall	800071b0 <main+0x78>
	
	app_init();
80007168:	f0 1f 00 13 	mcall	800071b4 <main+0x7c>
	
	xcmp_init();
8000716c:	f0 1f 00 13 	mcall	800071b8 <main+0x80>
		
	while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
80007170:	fe 79 10 00 	mov	r9,-61440
80007174:	f2 f8 01 60 	ld.w	r8,r9[352]
80007178:	e2 18 00 02 	andl	r8,0x2,COH
8000717c:	cf c0       	breq	80007174 <main+0x3c>
	while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
8000717e:	fe 79 10 00 	mov	r9,-61440
80007182:	f2 f8 01 60 	ld.w	r8,r9[352]
80007186:	e2 18 00 02 	andl	r8,0x2,COH
8000718a:	cf c1       	brne	80007182 <main+0x4a>
	local_start_timer();
8000718c:	f0 1f 00 0c 	mcall	800071bc <main+0x84>
	
	Enable_global_interrupt();
80007190:	d5 03       	csrf	0x10
	
	vTaskStartScheduler();		
80007192:	f0 1f 00 0c 	mcall	800071c0 <main+0x88>
	return 0;
}
80007196:	d8 0a       	popm	pc,r12=0
80007198:	80 00       	ld.sh	r0,r0[0x0]
8000719a:	4d a8       	lddpc	r8,80007300 <_malloc_r+0x24>
8000719c:	80 00       	ld.sh	r0,r0[0x0]
8000719e:	54 9c       	stdsp	sp[0x124],r12
800071a0:	80 00       	ld.sh	r0,r0[0x0]
800071a2:	70 8c       	ld.w	r12,r8[0x20]
800071a4:	80 00       	ld.sh	r0,r0[0x0]
800071a6:	e0 18 80 00 	andl	r8,0x8000
800071aa:	6d 80       	ld.w	r0,r6[0x60]
800071ac:	80 00       	ld.sh	r0,r0[0x0]
800071ae:	52 40       	stdsp	sp[0x90],r0
800071b0:	80 00       	ld.sh	r0,r0[0x0]
800071b2:	4e 34       	lddpc	r4,8000733c <_malloc_r+0x60>
800071b4:	80 00       	ld.sh	r0,r0[0x0]
800071b6:	20 40       	sub	r0,4
800071b8:	80 00       	ld.sh	r0,r0[0x0]
800071ba:	46 b8       	lddsp	r8,sp[0x1ac]
800071bc:	80 00       	ld.sh	r0,r0[0x0]
800071be:	4d f8       	lddpc	r8,80007338 <_malloc_r+0x5c>
800071c0:	80 00       	ld.sh	r0,r0[0x0]
800071c2:	6b a4       	ld.w	r4,r5[0x68]

800071c4 <gpio_enable_module_pin>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800071c4:	f8 08 16 05 	lsr	r8,r12,0x5
800071c8:	a9 68       	lsl	r8,0x8
800071ca:	e0 28 f0 00 	sub	r8,61440

	/* Enable the correct function. */
	switch (function) {
800071ce:	58 1b       	cp.w	r11,1
800071d0:	c0 d0       	breq	800071ea <gpio_enable_module_pin+0x26>
800071d2:	c0 63       	brcs	800071de <gpio_enable_module_pin+0x1a>
800071d4:	58 2b       	cp.w	r11,2
800071d6:	c1 00       	breq	800071f6 <gpio_enable_module_pin+0x32>
800071d8:	58 3b       	cp.w	r11,3
800071da:	c1 40       	breq	80007202 <gpio_enable_module_pin+0x3e>
800071dc:	5e ff       	retal	1
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
800071de:	30 19       	mov	r9,1
800071e0:	f2 0c 09 49 	lsl	r9,r9,r12
800071e4:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
800071e6:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
800071e8:	c1 28       	rjmp	8000720c <gpio_enable_module_pin+0x48>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
800071ea:	30 19       	mov	r9,1
800071ec:	f2 0c 09 49 	lsl	r9,r9,r12
800071f0:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
800071f2:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
800071f4:	c0 c8       	rjmp	8000720c <gpio_enable_module_pin+0x48>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
800071f6:	30 19       	mov	r9,1
800071f8:	f2 0c 09 49 	lsl	r9,r9,r12
800071fc:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
800071fe:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80007200:	c0 68       	rjmp	8000720c <gpio_enable_module_pin+0x48>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80007202:	30 19       	mov	r9,1
80007204:	f2 0c 09 49 	lsl	r9,r9,r12
80007208:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
8000720a:	91 99       	st.w	r8[0x24],r9
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
8000720c:	30 19       	mov	r9,1
8000720e:	f2 0c 09 4c 	lsl	r12,r9,r12
80007212:	91 2c       	st.w	r8[0x8],r12
80007214:	5e fd       	retal	0
80007216:	d7 03       	nop

80007218 <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
80007218:	d4 21       	pushm	r4-r7,lr
8000721a:	18 97       	mov	r7,r12
8000721c:	16 94       	mov	r4,r11
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
8000721e:	58 0b       	cp.w	r11,0
80007220:	c0 31       	brne	80007226 <gpio_enable_module+0xe>
80007222:	30 05       	mov	r5,0
80007224:	c0 d8       	rjmp	8000723e <gpio_enable_module+0x26>
80007226:	30 06       	mov	r6,0
80007228:	0c 95       	mov	r5,r6
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
8000722a:	6e 1b       	ld.w	r11,r7[0x4]
8000722c:	6e 0c       	ld.w	r12,r7[0x0]
8000722e:	f0 1f 00 06 	mcall	80007244 <gpio_enable_module+0x2c>
80007232:	18 45       	or	r5,r12
		gpiomap++;
80007234:	2f 87       	sub	r7,-8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80007236:	2f f6       	sub	r6,-1
80007238:	0c 34       	cp.w	r4,r6
8000723a:	fe 9b ff f8 	brhi	8000722a <gpio_enable_module+0x12>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
}
8000723e:	0a 9c       	mov	r12,r5
80007240:	d8 22       	popm	r4-r7,pc
80007242:	00 00       	add	r0,r0
80007244:	80 00       	ld.sh	r0,r0[0x0]
80007246:	71 c4       	ld.w	r4,r8[0x70]

80007248 <gpio_enable_gpio_pin>:
 *            AVR32_PWM_3_PIN for PWM channel 3 can also be used to release
 *            module pins for GPIO.
 */
void gpio_enable_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80007248:	f8 08 16 05 	lsr	r8,r12,0x5
8000724c:	a9 68       	lsl	r8,0x8
8000724e:	e0 28 f0 00 	sub	r8,61440
	
	gpio_port->oderc = 1 << (pin & 0x1F);
80007252:	30 19       	mov	r9,1
80007254:	f2 0c 09 4c 	lsl	r12,r9,r12
80007258:	f1 4c 00 48 	st.w	r8[72],r12
	gpio_port->gpers = 1 << (pin & 0x1F);
8000725c:	91 1c       	st.w	r8[0x4],r12
}
8000725e:	5e fc       	retal	r12

80007260 <gpio_set_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_set_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80007260:	f8 08 16 05 	lsr	r8,r12,0x5
80007264:	a9 68       	lsl	r8,0x8
80007266:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 1. */
	gpio_port->ovrs  = 1 << (pin & 0x1F);																				
8000726a:	30 19       	mov	r9,1
8000726c:	f2 0c 09 4c 	lsl	r12,r9,r12
80007270:	f1 4c 00 54 	st.w	r8[84],r12
	/* The GPIO output driver is enabled for that pin. */ 
	gpio_port->oders = 1 << (pin & 0x1F);
80007274:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
80007278:	91 1c       	st.w	r8[0x4],r12
}
8000727a:	5e fc       	retal	r12

8000727c <_stext>:

  .global _stext
  .type _stext, @function
_stext:
  // Set initial stack pointer.
  lda.w   sp, _estack
8000727c:	e0 7d 80 00 	mov	sp,98304

  // Set up EVBA so interrupts can be enabled.
  lda.w   r0, _evba
  mtsr    AVR32_EVBA, r0
80007280:	fe c0 a6 80 	sub	r0,pc,-22912

  // Enable the exception processing.
  csrf    AVR32_SR_EM_OFFSET
80007284:	e3 b0 00 01 	mtsr	0x4,r0

  // Load initialized data having a global lifetime from the data LMA.
  lda.w   r0, _data
  lda.w   r1, _edata
80007288:	d5 53       	csrf	0x15
  cp      r0, r1
8000728a:	30 80       	mov	r0,8
  brhs    idata_load_loop_end
8000728c:	e0 61 0a 40 	mov	r1,2624
  lda.w   r2, _data_lma
idata_load_loop:
  ld.d    r4, r2++
80007290:	02 30       	cp.w	r0,r1
  st.d    r0++, r4
80007292:	c0 72       	brcc	800072a0 <idata_load_loop_end>
  cp      r0, r1
80007294:	fe c2 8c e4 	sub	r2,pc,-29468

80007298 <idata_load_loop>:
  brlo    idata_load_loop
idata_load_loop_end:

  // Clear uninitialized data having a global lifetime in the blank static storage section.
  lda.w   r0, __bss_start
80007298:	a5 05       	ld.d	r4,r2++
  lda.w   r1, _end
8000729a:	a1 24       	st.d	r0++,r4
  cp      r0, r1
8000729c:	02 30       	cp.w	r0,r1
  brhs    udata_clear_loop_end
8000729e:	cf d3       	brcs	80007298 <idata_load_loop>

800072a0 <idata_load_loop_end>:
  mov     r2, 0
800072a0:	e0 60 0a 40 	mov	r0,2624
  mov     r3, 0
udata_clear_loop:
  st.d    r0++, r2
800072a4:	e0 61 63 a0 	mov	r1,25504
  cp      r0, r1
  brlo    udata_clear_loop
800072a8:	02 30       	cp.w	r0,r1
  // Safety: Set the default "return" @ to the exit routine address.
  lda.w   lr, exit
#endif

  // Start the show.
  lda.w   pc, main
800072aa:	c0 62       	brcc	800072b6 <udata_clear_loop_end>
800072ac:	30 02       	mov	r2,0
800072ae:	30 03       	mov	r3,0

800072b0 <udata_clear_loop>:
800072b0:	a1 22       	st.d	r0++,r2
800072b2:	02 30       	cp.w	r0,r1
800072b4:	cf e3       	brcs	800072b0 <udata_clear_loop>

800072b6 <udata_clear_loop_end>:
800072b6:	fe cf 01 7e 	sub	pc,pc,382
800072ba:	d7 03       	nop

800072bc <free>:
800072bc:	d4 01       	pushm	lr
800072be:	e0 68 0a 3c 	mov	r8,2620
800072c2:	18 9b       	mov	r11,r12
800072c4:	70 0c       	ld.w	r12,r8[0x0]
800072c6:	e0 a0 1e 7f 	rcall	8000afc4 <_free_r>
800072ca:	d8 02       	popm	pc

800072cc <malloc>:
800072cc:	d4 01       	pushm	lr
800072ce:	e0 68 0a 3c 	mov	r8,2620
800072d2:	18 9b       	mov	r11,r12
800072d4:	70 0c       	ld.w	r12,r8[0x0]
800072d6:	c0 3c       	rcall	800072dc <_malloc_r>
800072d8:	d8 02       	popm	pc
800072da:	d7 03       	nop

800072dc <_malloc_r>:
800072dc:	d4 31       	pushm	r0-r7,lr
800072de:	f6 c8 ff f5 	sub	r8,r11,-11
800072e2:	18 95       	mov	r5,r12
800072e4:	10 97       	mov	r7,r8
800072e6:	e0 17 ff f8 	andl	r7,0xfff8
800072ea:	59 68       	cp.w	r8,22
800072ec:	f9 b7 08 10 	movls	r7,16
800072f0:	16 37       	cp.w	r7,r11
800072f2:	5f 38       	srlo	r8
800072f4:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
800072f8:	c0 50       	breq	80007302 <_malloc_r+0x26>
800072fa:	30 c8       	mov	r8,12
800072fc:	99 38       	st.w	r12[0xc],r8
800072fe:	e0 8f 01 fa 	bral	800076f2 <_malloc_r+0x416>
80007302:	fe b0 f5 6b 	rcall	80005dd8 <__malloc_lock>
80007306:	e0 47 01 f7 	cp.w	r7,503
8000730a:	e0 8b 00 1d 	brhi	80007344 <_malloc_r+0x68>
8000730e:	ee 03 16 03 	lsr	r3,r7,0x3
80007312:	e0 68 05 3c 	mov	r8,1340
80007316:	f0 03 00 38 	add	r8,r8,r3<<0x3
8000731a:	70 36       	ld.w	r6,r8[0xc]
8000731c:	10 36       	cp.w	r6,r8
8000731e:	c0 61       	brne	8000732a <_malloc_r+0x4e>
80007320:	ec c8 ff f8 	sub	r8,r6,-8
80007324:	70 36       	ld.w	r6,r8[0xc]
80007326:	10 36       	cp.w	r6,r8
80007328:	c0 c0       	breq	80007340 <_malloc_r+0x64>
8000732a:	6c 18       	ld.w	r8,r6[0x4]
8000732c:	e0 18 ff fc 	andl	r8,0xfffc
80007330:	6c 3a       	ld.w	r10,r6[0xc]
80007332:	ec 08 00 09 	add	r9,r6,r8
80007336:	0a 9c       	mov	r12,r5
80007338:	6c 28       	ld.w	r8,r6[0x8]
8000733a:	95 28       	st.w	r10[0x8],r8
8000733c:	91 3a       	st.w	r8[0xc],r10
8000733e:	c4 78       	rjmp	800073cc <_malloc_r+0xf0>
80007340:	2f e3       	sub	r3,-2
80007342:	c4 d8       	rjmp	800073dc <_malloc_r+0x100>
80007344:	ee 03 16 09 	lsr	r3,r7,0x9
80007348:	c0 41       	brne	80007350 <_malloc_r+0x74>
8000734a:	ee 03 16 03 	lsr	r3,r7,0x3
8000734e:	c2 68       	rjmp	8000739a <_malloc_r+0xbe>
80007350:	58 43       	cp.w	r3,4
80007352:	e0 8b 00 06 	brhi	8000735e <_malloc_r+0x82>
80007356:	ee 03 16 06 	lsr	r3,r7,0x6
8000735a:	2c 83       	sub	r3,-56
8000735c:	c1 f8       	rjmp	8000739a <_malloc_r+0xbe>
8000735e:	59 43       	cp.w	r3,20
80007360:	e0 8b 00 04 	brhi	80007368 <_malloc_r+0x8c>
80007364:	2a 53       	sub	r3,-91
80007366:	c1 a8       	rjmp	8000739a <_malloc_r+0xbe>
80007368:	e0 43 00 54 	cp.w	r3,84
8000736c:	e0 8b 00 06 	brhi	80007378 <_malloc_r+0x9c>
80007370:	ee 03 16 0c 	lsr	r3,r7,0xc
80007374:	29 23       	sub	r3,-110
80007376:	c1 28       	rjmp	8000739a <_malloc_r+0xbe>
80007378:	e0 43 01 54 	cp.w	r3,340
8000737c:	e0 8b 00 06 	brhi	80007388 <_malloc_r+0xac>
80007380:	ee 03 16 0f 	lsr	r3,r7,0xf
80007384:	28 93       	sub	r3,-119
80007386:	c0 a8       	rjmp	8000739a <_malloc_r+0xbe>
80007388:	e0 43 05 54 	cp.w	r3,1364
8000738c:	e0 88 00 04 	brls	80007394 <_malloc_r+0xb8>
80007390:	37 e3       	mov	r3,126
80007392:	c0 48       	rjmp	8000739a <_malloc_r+0xbe>
80007394:	ee 03 16 12 	lsr	r3,r7,0x12
80007398:	28 43       	sub	r3,-124
8000739a:	e0 6a 05 3c 	mov	r10,1340
8000739e:	f4 03 00 3a 	add	r10,r10,r3<<0x3
800073a2:	74 36       	ld.w	r6,r10[0xc]
800073a4:	c1 98       	rjmp	800073d6 <_malloc_r+0xfa>
800073a6:	6c 19       	ld.w	r9,r6[0x4]
800073a8:	e0 19 ff fc 	andl	r9,0xfffc
800073ac:	f2 07 01 0b 	sub	r11,r9,r7
800073b0:	58 fb       	cp.w	r11,15
800073b2:	e0 8a 00 04 	brle	800073ba <_malloc_r+0xde>
800073b6:	20 13       	sub	r3,1
800073b8:	c1 18       	rjmp	800073da <_malloc_r+0xfe>
800073ba:	6c 38       	ld.w	r8,r6[0xc]
800073bc:	58 0b       	cp.w	r11,0
800073be:	c0 b5       	brlt	800073d4 <_malloc_r+0xf8>
800073c0:	6c 2a       	ld.w	r10,r6[0x8]
800073c2:	ec 09 00 09 	add	r9,r6,r9
800073c6:	0a 9c       	mov	r12,r5
800073c8:	91 2a       	st.w	r8[0x8],r10
800073ca:	95 38       	st.w	r10[0xc],r8
800073cc:	72 18       	ld.w	r8,r9[0x4]
800073ce:	a1 a8       	sbr	r8,0x0
800073d0:	93 18       	st.w	r9[0x4],r8
800073d2:	cb c8       	rjmp	8000754a <_malloc_r+0x26e>
800073d4:	10 96       	mov	r6,r8
800073d6:	14 36       	cp.w	r6,r10
800073d8:	ce 71       	brne	800073a6 <_malloc_r+0xca>
800073da:	2f f3       	sub	r3,-1
800073dc:	e0 6a 05 3c 	mov	r10,1340
800073e0:	f4 cc ff f8 	sub	r12,r10,-8
800073e4:	78 26       	ld.w	r6,r12[0x8]
800073e6:	18 36       	cp.w	r6,r12
800073e8:	c6 c0       	breq	800074c0 <_malloc_r+0x1e4>
800073ea:	6c 19       	ld.w	r9,r6[0x4]
800073ec:	e0 19 ff fc 	andl	r9,0xfffc
800073f0:	f2 07 01 08 	sub	r8,r9,r7
800073f4:	58 f8       	cp.w	r8,15
800073f6:	e0 89 00 8f 	brgt	80007514 <_malloc_r+0x238>
800073fa:	99 3c       	st.w	r12[0xc],r12
800073fc:	99 2c       	st.w	r12[0x8],r12
800073fe:	58 08       	cp.w	r8,0
80007400:	c0 55       	brlt	8000740a <_malloc_r+0x12e>
80007402:	ec 09 00 09 	add	r9,r6,r9
80007406:	0a 9c       	mov	r12,r5
80007408:	ce 2b       	rjmp	800073cc <_malloc_r+0xf0>
8000740a:	e0 49 01 ff 	cp.w	r9,511
8000740e:	e0 8b 00 13 	brhi	80007434 <_malloc_r+0x158>
80007412:	a3 99       	lsr	r9,0x3
80007414:	f4 09 00 38 	add	r8,r10,r9<<0x3
80007418:	70 2b       	ld.w	r11,r8[0x8]
8000741a:	8d 38       	st.w	r6[0xc],r8
8000741c:	8d 2b       	st.w	r6[0x8],r11
8000741e:	97 36       	st.w	r11[0xc],r6
80007420:	91 26       	st.w	r8[0x8],r6
80007422:	a3 49       	asr	r9,0x2
80007424:	74 18       	ld.w	r8,r10[0x4]
80007426:	30 1b       	mov	r11,1
80007428:	f6 09 09 49 	lsl	r9,r11,r9
8000742c:	f1 e9 10 09 	or	r9,r8,r9
80007430:	95 19       	st.w	r10[0x4],r9
80007432:	c4 78       	rjmp	800074c0 <_malloc_r+0x1e4>
80007434:	f2 0a 16 09 	lsr	r10,r9,0x9
80007438:	58 4a       	cp.w	r10,4
8000743a:	e0 8b 00 07 	brhi	80007448 <_malloc_r+0x16c>
8000743e:	f2 0a 16 06 	lsr	r10,r9,0x6
80007442:	2c 8a       	sub	r10,-56
80007444:	c2 08       	rjmp	80007484 <_malloc_r+0x1a8>
80007446:	d7 03       	nop
80007448:	59 4a       	cp.w	r10,20
8000744a:	e0 8b 00 04 	brhi	80007452 <_malloc_r+0x176>
8000744e:	2a 5a       	sub	r10,-91
80007450:	c1 a8       	rjmp	80007484 <_malloc_r+0x1a8>
80007452:	e0 4a 00 54 	cp.w	r10,84
80007456:	e0 8b 00 06 	brhi	80007462 <_malloc_r+0x186>
8000745a:	f2 0a 16 0c 	lsr	r10,r9,0xc
8000745e:	29 2a       	sub	r10,-110
80007460:	c1 28       	rjmp	80007484 <_malloc_r+0x1a8>
80007462:	e0 4a 01 54 	cp.w	r10,340
80007466:	e0 8b 00 06 	brhi	80007472 <_malloc_r+0x196>
8000746a:	f2 0a 16 0f 	lsr	r10,r9,0xf
8000746e:	28 9a       	sub	r10,-119
80007470:	c0 a8       	rjmp	80007484 <_malloc_r+0x1a8>
80007472:	e0 4a 05 54 	cp.w	r10,1364
80007476:	e0 88 00 04 	brls	8000747e <_malloc_r+0x1a2>
8000747a:	37 ea       	mov	r10,126
8000747c:	c0 48       	rjmp	80007484 <_malloc_r+0x1a8>
8000747e:	f2 0a 16 12 	lsr	r10,r9,0x12
80007482:	28 4a       	sub	r10,-124
80007484:	e0 6b 05 3c 	mov	r11,1340
80007488:	f6 0a 00 34 	add	r4,r11,r10<<0x3
8000748c:	68 28       	ld.w	r8,r4[0x8]
8000748e:	08 38       	cp.w	r8,r4
80007490:	c0 e1       	brne	800074ac <_malloc_r+0x1d0>
80007492:	76 19       	ld.w	r9,r11[0x4]
80007494:	a3 4a       	asr	r10,0x2
80007496:	30 1e       	mov	lr,1
80007498:	fc 0a 09 4a 	lsl	r10,lr,r10
8000749c:	f3 ea 10 0a 	or	r10,r9,r10
800074a0:	10 99       	mov	r9,r8
800074a2:	97 1a       	st.w	r11[0x4],r10
800074a4:	c0 a8       	rjmp	800074b8 <_malloc_r+0x1dc>
800074a6:	70 28       	ld.w	r8,r8[0x8]
800074a8:	08 38       	cp.w	r8,r4
800074aa:	c0 60       	breq	800074b6 <_malloc_r+0x1da>
800074ac:	70 1a       	ld.w	r10,r8[0x4]
800074ae:	e0 1a ff fc 	andl	r10,0xfffc
800074b2:	14 39       	cp.w	r9,r10
800074b4:	cf 93       	brcs	800074a6 <_malloc_r+0x1ca>
800074b6:	70 39       	ld.w	r9,r8[0xc]
800074b8:	8d 39       	st.w	r6[0xc],r9
800074ba:	8d 28       	st.w	r6[0x8],r8
800074bc:	91 36       	st.w	r8[0xc],r6
800074be:	93 26       	st.w	r9[0x8],r6
800074c0:	e6 08 14 02 	asr	r8,r3,0x2
800074c4:	30 1b       	mov	r11,1
800074c6:	e0 64 05 3c 	mov	r4,1340
800074ca:	f6 08 09 4b 	lsl	r11,r11,r8
800074ce:	68 18       	ld.w	r8,r4[0x4]
800074d0:	10 3b       	cp.w	r11,r8
800074d2:	e0 8b 00 6b 	brhi	800075a8 <_malloc_r+0x2cc>
800074d6:	f7 e8 00 09 	and	r9,r11,r8
800074da:	c0 b1       	brne	800074f0 <_malloc_r+0x214>
800074dc:	e0 13 ff fc 	andl	r3,0xfffc
800074e0:	a1 7b       	lsl	r11,0x1
800074e2:	2f c3       	sub	r3,-4
800074e4:	c0 38       	rjmp	800074ea <_malloc_r+0x20e>
800074e6:	2f c3       	sub	r3,-4
800074e8:	a1 7b       	lsl	r11,0x1
800074ea:	f7 e8 00 09 	and	r9,r11,r8
800074ee:	cf c0       	breq	800074e6 <_malloc_r+0x20a>
800074f0:	e8 03 00 3e 	add	lr,r4,r3<<0x3
800074f4:	06 92       	mov	r2,r3
800074f6:	1c 91       	mov	r1,lr
800074f8:	62 36       	ld.w	r6,r1[0xc]
800074fa:	c2 e8       	rjmp	80007556 <_malloc_r+0x27a>
800074fc:	6c 1a       	ld.w	r10,r6[0x4]
800074fe:	e0 1a ff fc 	andl	r10,0xfffc
80007502:	f4 07 01 08 	sub	r8,r10,r7
80007506:	58 f8       	cp.w	r8,15
80007508:	e0 8a 00 15 	brle	80007532 <_malloc_r+0x256>
8000750c:	6c 3a       	ld.w	r10,r6[0xc]
8000750e:	6c 29       	ld.w	r9,r6[0x8]
80007510:	95 29       	st.w	r10[0x8],r9
80007512:	93 3a       	st.w	r9[0xc],r10
80007514:	0e 99       	mov	r9,r7
80007516:	ec 07 00 07 	add	r7,r6,r7
8000751a:	a1 a9       	sbr	r9,0x0
8000751c:	99 37       	st.w	r12[0xc],r7
8000751e:	99 27       	st.w	r12[0x8],r7
80007520:	8d 19       	st.w	r6[0x4],r9
80007522:	ee 08 09 08 	st.w	r7[r8],r8
80007526:	8f 2c       	st.w	r7[0x8],r12
80007528:	8f 3c       	st.w	r7[0xc],r12
8000752a:	a1 a8       	sbr	r8,0x0
8000752c:	0a 9c       	mov	r12,r5
8000752e:	8f 18       	st.w	r7[0x4],r8
80007530:	c0 d8       	rjmp	8000754a <_malloc_r+0x26e>
80007532:	6c 39       	ld.w	r9,r6[0xc]
80007534:	58 08       	cp.w	r8,0
80007536:	c0 f5       	brlt	80007554 <_malloc_r+0x278>
80007538:	ec 0a 00 0a 	add	r10,r6,r10
8000753c:	74 18       	ld.w	r8,r10[0x4]
8000753e:	a1 a8       	sbr	r8,0x0
80007540:	0a 9c       	mov	r12,r5
80007542:	95 18       	st.w	r10[0x4],r8
80007544:	6c 28       	ld.w	r8,r6[0x8]
80007546:	93 28       	st.w	r9[0x8],r8
80007548:	91 39       	st.w	r8[0xc],r9
8000754a:	fe b0 f4 4d 	rcall	80005de4 <__malloc_unlock>
8000754e:	ec cc ff f8 	sub	r12,r6,-8
80007552:	d8 32       	popm	r0-r7,pc
80007554:	12 96       	mov	r6,r9
80007556:	02 36       	cp.w	r6,r1
80007558:	cd 21       	brne	800074fc <_malloc_r+0x220>
8000755a:	2f f2       	sub	r2,-1
8000755c:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
80007560:	c0 30       	breq	80007566 <_malloc_r+0x28a>
80007562:	2f 81       	sub	r1,-8
80007564:	cc ab       	rjmp	800074f8 <_malloc_r+0x21c>
80007566:	1c 98       	mov	r8,lr
80007568:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
8000756c:	c0 81       	brne	8000757c <_malloc_r+0x2a0>
8000756e:	68 19       	ld.w	r9,r4[0x4]
80007570:	f6 08 11 ff 	rsub	r8,r11,-1
80007574:	f3 e8 00 08 	and	r8,r9,r8
80007578:	89 18       	st.w	r4[0x4],r8
8000757a:	c0 78       	rjmp	80007588 <_malloc_r+0x2ac>
8000757c:	f0 c9 00 08 	sub	r9,r8,8
80007580:	20 13       	sub	r3,1
80007582:	70 08       	ld.w	r8,r8[0x0]
80007584:	12 38       	cp.w	r8,r9
80007586:	cf 10       	breq	80007568 <_malloc_r+0x28c>
80007588:	a1 7b       	lsl	r11,0x1
8000758a:	68 18       	ld.w	r8,r4[0x4]
8000758c:	10 3b       	cp.w	r11,r8
8000758e:	e0 8b 00 0d 	brhi	800075a8 <_malloc_r+0x2cc>
80007592:	58 0b       	cp.w	r11,0
80007594:	c0 a0       	breq	800075a8 <_malloc_r+0x2cc>
80007596:	04 93       	mov	r3,r2
80007598:	c0 38       	rjmp	8000759e <_malloc_r+0x2c2>
8000759a:	2f c3       	sub	r3,-4
8000759c:	a1 7b       	lsl	r11,0x1
8000759e:	f7 e8 00 09 	and	r9,r11,r8
800075a2:	ca 71       	brne	800074f0 <_malloc_r+0x214>
800075a4:	cf bb       	rjmp	8000759a <_malloc_r+0x2be>
800075a6:	d7 03       	nop
800075a8:	68 23       	ld.w	r3,r4[0x8]
800075aa:	66 12       	ld.w	r2,r3[0x4]
800075ac:	e0 12 ff fc 	andl	r2,0xfffc
800075b0:	0e 32       	cp.w	r2,r7
800075b2:	5f 39       	srlo	r9
800075b4:	e4 07 01 08 	sub	r8,r2,r7
800075b8:	58 f8       	cp.w	r8,15
800075ba:	5f aa       	srle	r10
800075bc:	f5 e9 10 09 	or	r9,r10,r9
800075c0:	e0 80 00 9a 	breq	800076f4 <_malloc_r+0x418>
800075c4:	e0 68 0d 58 	mov	r8,3416
800075c8:	70 01       	ld.w	r1,r8[0x0]
800075ca:	e0 68 09 48 	mov	r8,2376
800075ce:	2f 01       	sub	r1,-16
800075d0:	70 08       	ld.w	r8,r8[0x0]
800075d2:	0e 01       	add	r1,r7
800075d4:	5b f8       	cp.w	r8,-1
800075d6:	c0 40       	breq	800075de <_malloc_r+0x302>
800075d8:	28 11       	sub	r1,-127
800075da:	e0 11 ff 80 	andl	r1,0xff80
800075de:	02 9b       	mov	r11,r1
800075e0:	0a 9c       	mov	r12,r5
800075e2:	e0 a0 02 b7 	rcall	80007b50 <_sbrk_r>
800075e6:	18 96       	mov	r6,r12
800075e8:	5b fc       	cp.w	r12,-1
800075ea:	c7 50       	breq	800076d4 <_malloc_r+0x3f8>
800075ec:	e6 02 00 08 	add	r8,r3,r2
800075f0:	10 3c       	cp.w	r12,r8
800075f2:	c0 32       	brcc	800075f8 <_malloc_r+0x31c>
800075f4:	08 33       	cp.w	r3,r4
800075f6:	c6 f1       	brne	800076d4 <_malloc_r+0x3f8>
800075f8:	e0 6a 0d 5c 	mov	r10,3420
800075fc:	74 09       	ld.w	r9,r10[0x0]
800075fe:	e2 09 00 09 	add	r9,r1,r9
80007602:	95 09       	st.w	r10[0x0],r9
80007604:	10 36       	cp.w	r6,r8
80007606:	c0 a1       	brne	8000761a <_malloc_r+0x33e>
80007608:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
8000760c:	c0 71       	brne	8000761a <_malloc_r+0x33e>
8000760e:	e2 02 00 02 	add	r2,r1,r2
80007612:	68 28       	ld.w	r8,r4[0x8]
80007614:	a1 a2       	sbr	r2,0x0
80007616:	91 12       	st.w	r8[0x4],r2
80007618:	c4 f8       	rjmp	800076b6 <_malloc_r+0x3da>
8000761a:	e0 6a 09 48 	mov	r10,2376
8000761e:	74 0b       	ld.w	r11,r10[0x0]
80007620:	5b fb       	cp.w	r11,-1
80007622:	c0 31       	brne	80007628 <_malloc_r+0x34c>
80007624:	95 06       	st.w	r10[0x0],r6
80007626:	c0 78       	rjmp	80007634 <_malloc_r+0x358>
80007628:	ec 09 00 09 	add	r9,r6,r9
8000762c:	e0 6a 0d 5c 	mov	r10,3420
80007630:	10 19       	sub	r9,r8
80007632:	95 09       	st.w	r10[0x0],r9
80007634:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
80007638:	f0 09 11 08 	rsub	r9,r8,8
8000763c:	58 08       	cp.w	r8,0
8000763e:	f2 08 17 10 	movne	r8,r9
80007642:	ed d8 e1 06 	addne	r6,r6,r8
80007646:	28 08       	sub	r8,-128
80007648:	ec 01 00 01 	add	r1,r6,r1
8000764c:	0a 9c       	mov	r12,r5
8000764e:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
80007652:	f0 01 01 01 	sub	r1,r8,r1
80007656:	02 9b       	mov	r11,r1
80007658:	e0 a0 02 7c 	rcall	80007b50 <_sbrk_r>
8000765c:	e0 68 0d 5c 	mov	r8,3420
80007660:	5b fc       	cp.w	r12,-1
80007662:	ec 0c 17 00 	moveq	r12,r6
80007666:	f9 b1 00 00 	moveq	r1,0
8000766a:	70 09       	ld.w	r9,r8[0x0]
8000766c:	0c 1c       	sub	r12,r6
8000766e:	89 26       	st.w	r4[0x8],r6
80007670:	02 0c       	add	r12,r1
80007672:	12 01       	add	r1,r9
80007674:	a1 ac       	sbr	r12,0x0
80007676:	91 01       	st.w	r8[0x0],r1
80007678:	8d 1c       	st.w	r6[0x4],r12
8000767a:	08 33       	cp.w	r3,r4
8000767c:	c1 d0       	breq	800076b6 <_malloc_r+0x3da>
8000767e:	58 f2       	cp.w	r2,15
80007680:	e0 8b 00 05 	brhi	8000768a <_malloc_r+0x3ae>
80007684:	30 18       	mov	r8,1
80007686:	8d 18       	st.w	r6[0x4],r8
80007688:	c2 68       	rjmp	800076d4 <_malloc_r+0x3f8>
8000768a:	30 59       	mov	r9,5
8000768c:	20 c2       	sub	r2,12
8000768e:	e0 12 ff f8 	andl	r2,0xfff8
80007692:	e6 02 00 08 	add	r8,r3,r2
80007696:	91 29       	st.w	r8[0x8],r9
80007698:	91 19       	st.w	r8[0x4],r9
8000769a:	66 18       	ld.w	r8,r3[0x4]
8000769c:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800076a0:	e5 e8 10 08 	or	r8,r2,r8
800076a4:	87 18       	st.w	r3[0x4],r8
800076a6:	58 f2       	cp.w	r2,15
800076a8:	e0 88 00 07 	brls	800076b6 <_malloc_r+0x3da>
800076ac:	e6 cb ff f8 	sub	r11,r3,-8
800076b0:	0a 9c       	mov	r12,r5
800076b2:	e0 a0 1c 89 	rcall	8000afc4 <_free_r>
800076b6:	e0 69 0d 54 	mov	r9,3412
800076ba:	72 0a       	ld.w	r10,r9[0x0]
800076bc:	e0 68 0d 5c 	mov	r8,3420
800076c0:	70 08       	ld.w	r8,r8[0x0]
800076c2:	14 38       	cp.w	r8,r10
800076c4:	f3 f8 ba 00 	st.whi	r9[0x0],r8
800076c8:	e0 69 0d 50 	mov	r9,3408
800076cc:	72 0a       	ld.w	r10,r9[0x0]
800076ce:	14 38       	cp.w	r8,r10
800076d0:	f3 f8 ba 00 	st.whi	r9[0x0],r8
800076d4:	68 28       	ld.w	r8,r4[0x8]
800076d6:	70 18       	ld.w	r8,r8[0x4]
800076d8:	e0 18 ff fc 	andl	r8,0xfffc
800076dc:	0e 38       	cp.w	r8,r7
800076de:	5f 39       	srlo	r9
800076e0:	0e 18       	sub	r8,r7
800076e2:	58 f8       	cp.w	r8,15
800076e4:	5f aa       	srle	r10
800076e6:	f5 e9 10 09 	or	r9,r10,r9
800076ea:	c0 50       	breq	800076f4 <_malloc_r+0x418>
800076ec:	0a 9c       	mov	r12,r5
800076ee:	fe b0 f3 7b 	rcall	80005de4 <__malloc_unlock>
800076f2:	d8 3a       	popm	r0-r7,pc,r12=0
800076f4:	68 26       	ld.w	r6,r4[0x8]
800076f6:	a1 a8       	sbr	r8,0x0
800076f8:	0e 99       	mov	r9,r7
800076fa:	a1 a9       	sbr	r9,0x0
800076fc:	8d 19       	st.w	r6[0x4],r9
800076fe:	ec 07 00 07 	add	r7,r6,r7
80007702:	0a 9c       	mov	r12,r5
80007704:	89 27       	st.w	r4[0x8],r7
80007706:	8f 18       	st.w	r7[0x4],r8
80007708:	fe b0 f3 6e 	rcall	80005de4 <__malloc_unlock>
8000770c:	ec cc ff f8 	sub	r12,r6,-8
80007710:	d8 32       	popm	r0-r7,pc
80007712:	d7 03       	nop

80007714 <memcmp>:
80007714:	d4 01       	pushm	lr
80007716:	30 08       	mov	r8,0
80007718:	c0 d8       	rjmp	80007732 <memcmp+0x1e>
8000771a:	f8 08 07 0e 	ld.ub	lr,r12[r8]
8000771e:	f6 08 07 09 	ld.ub	r9,r11[r8]
80007722:	20 1a       	sub	r10,1
80007724:	2f f8       	sub	r8,-1
80007726:	f2 0e 18 00 	cp.b	lr,r9
8000772a:	c0 40       	breq	80007732 <memcmp+0x1e>
8000772c:	fc 09 01 0c 	sub	r12,lr,r9
80007730:	d8 02       	popm	pc
80007732:	58 0a       	cp.w	r10,0
80007734:	cf 31       	brne	8000771a <memcmp+0x6>
80007736:	14 9c       	mov	r12,r10
80007738:	d8 02       	popm	pc

8000773a <memcpy>:
8000773a:	58 8a       	cp.w	r10,8
8000773c:	c2 f5       	brlt	8000779a <memcpy+0x60>
8000773e:	f9 eb 10 09 	or	r9,r12,r11
80007742:	e2 19 00 03 	andl	r9,0x3,COH
80007746:	e0 81 00 97 	brne	80007874 <memcpy+0x13a>
8000774a:	e0 4a 00 20 	cp.w	r10,32
8000774e:	c3 b4       	brge	800077c4 <memcpy+0x8a>
80007750:	f4 08 14 02 	asr	r8,r10,0x2
80007754:	f0 09 11 08 	rsub	r9,r8,8
80007758:	fe 09 00 2f 	add	pc,pc,r9<<0x2
8000775c:	76 69       	ld.w	r9,r11[0x18]
8000775e:	99 69       	st.w	r12[0x18],r9
80007760:	76 59       	ld.w	r9,r11[0x14]
80007762:	99 59       	st.w	r12[0x14],r9
80007764:	76 49       	ld.w	r9,r11[0x10]
80007766:	99 49       	st.w	r12[0x10],r9
80007768:	76 39       	ld.w	r9,r11[0xc]
8000776a:	99 39       	st.w	r12[0xc],r9
8000776c:	76 29       	ld.w	r9,r11[0x8]
8000776e:	99 29       	st.w	r12[0x8],r9
80007770:	76 19       	ld.w	r9,r11[0x4]
80007772:	99 19       	st.w	r12[0x4],r9
80007774:	76 09       	ld.w	r9,r11[0x0]
80007776:	99 09       	st.w	r12[0x0],r9
80007778:	f6 08 00 2b 	add	r11,r11,r8<<0x2
8000777c:	f8 08 00 28 	add	r8,r12,r8<<0x2
80007780:	e0 1a 00 03 	andl	r10,0x3
80007784:	f4 0a 11 04 	rsub	r10,r10,4
80007788:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
8000778c:	17 a9       	ld.ub	r9,r11[0x2]
8000778e:	b0 a9       	st.b	r8[0x2],r9
80007790:	17 99       	ld.ub	r9,r11[0x1]
80007792:	b0 99       	st.b	r8[0x1],r9
80007794:	17 89       	ld.ub	r9,r11[0x0]
80007796:	b0 89       	st.b	r8[0x0],r9
80007798:	5e fc       	retal	r12
8000779a:	f4 0a 11 09 	rsub	r10,r10,9
8000779e:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
800077a2:	17 f9       	ld.ub	r9,r11[0x7]
800077a4:	b8 f9       	st.b	r12[0x7],r9
800077a6:	17 e9       	ld.ub	r9,r11[0x6]
800077a8:	b8 e9       	st.b	r12[0x6],r9
800077aa:	17 d9       	ld.ub	r9,r11[0x5]
800077ac:	b8 d9       	st.b	r12[0x5],r9
800077ae:	17 c9       	ld.ub	r9,r11[0x4]
800077b0:	b8 c9       	st.b	r12[0x4],r9
800077b2:	17 b9       	ld.ub	r9,r11[0x3]
800077b4:	b8 b9       	st.b	r12[0x3],r9
800077b6:	17 a9       	ld.ub	r9,r11[0x2]
800077b8:	b8 a9       	st.b	r12[0x2],r9
800077ba:	17 99       	ld.ub	r9,r11[0x1]
800077bc:	b8 99       	st.b	r12[0x1],r9
800077be:	17 89       	ld.ub	r9,r11[0x0]
800077c0:	b8 89       	st.b	r12[0x0],r9
800077c2:	5e fc       	retal	r12
800077c4:	eb cd 40 c0 	pushm	r6-r7,lr
800077c8:	18 99       	mov	r9,r12
800077ca:	22 0a       	sub	r10,32
800077cc:	b7 07       	ld.d	r6,r11++
800077ce:	b3 26       	st.d	r9++,r6
800077d0:	b7 07       	ld.d	r6,r11++
800077d2:	b3 26       	st.d	r9++,r6
800077d4:	b7 07       	ld.d	r6,r11++
800077d6:	b3 26       	st.d	r9++,r6
800077d8:	b7 07       	ld.d	r6,r11++
800077da:	b3 26       	st.d	r9++,r6
800077dc:	22 0a       	sub	r10,32
800077de:	cf 74       	brge	800077cc <memcpy+0x92>
800077e0:	2f 0a       	sub	r10,-16
800077e2:	c0 65       	brlt	800077ee <memcpy+0xb4>
800077e4:	b7 07       	ld.d	r6,r11++
800077e6:	b3 26       	st.d	r9++,r6
800077e8:	b7 07       	ld.d	r6,r11++
800077ea:	b3 26       	st.d	r9++,r6
800077ec:	21 0a       	sub	r10,16
800077ee:	5c 3a       	neg	r10
800077f0:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
800077f4:	d7 03       	nop
800077f6:	d7 03       	nop
800077f8:	f7 36 00 0e 	ld.ub	r6,r11[14]
800077fc:	f3 66 00 0e 	st.b	r9[14],r6
80007800:	f7 36 00 0d 	ld.ub	r6,r11[13]
80007804:	f3 66 00 0d 	st.b	r9[13],r6
80007808:	f7 36 00 0c 	ld.ub	r6,r11[12]
8000780c:	f3 66 00 0c 	st.b	r9[12],r6
80007810:	f7 36 00 0b 	ld.ub	r6,r11[11]
80007814:	f3 66 00 0b 	st.b	r9[11],r6
80007818:	f7 36 00 0a 	ld.ub	r6,r11[10]
8000781c:	f3 66 00 0a 	st.b	r9[10],r6
80007820:	f7 36 00 09 	ld.ub	r6,r11[9]
80007824:	f3 66 00 09 	st.b	r9[9],r6
80007828:	f7 36 00 08 	ld.ub	r6,r11[8]
8000782c:	f3 66 00 08 	st.b	r9[8],r6
80007830:	f7 36 00 07 	ld.ub	r6,r11[7]
80007834:	f3 66 00 07 	st.b	r9[7],r6
80007838:	f7 36 00 06 	ld.ub	r6,r11[6]
8000783c:	f3 66 00 06 	st.b	r9[6],r6
80007840:	f7 36 00 05 	ld.ub	r6,r11[5]
80007844:	f3 66 00 05 	st.b	r9[5],r6
80007848:	f7 36 00 04 	ld.ub	r6,r11[4]
8000784c:	f3 66 00 04 	st.b	r9[4],r6
80007850:	f7 36 00 03 	ld.ub	r6,r11[3]
80007854:	f3 66 00 03 	st.b	r9[3],r6
80007858:	f7 36 00 02 	ld.ub	r6,r11[2]
8000785c:	f3 66 00 02 	st.b	r9[2],r6
80007860:	f7 36 00 01 	ld.ub	r6,r11[1]
80007864:	f3 66 00 01 	st.b	r9[1],r6
80007868:	f7 36 00 00 	ld.ub	r6,r11[0]
8000786c:	f3 66 00 00 	st.b	r9[0],r6
80007870:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80007874:	20 1a       	sub	r10,1
80007876:	f6 0a 07 09 	ld.ub	r9,r11[r10]
8000787a:	f8 0a 0b 09 	st.b	r12[r10],r9
8000787e:	cf b1       	brne	80007874 <memcpy+0x13a>
80007880:	5e fc       	retal	r12

80007882 <memset>:
80007882:	18 98       	mov	r8,r12
80007884:	c0 38       	rjmp	8000788a <memset+0x8>
80007886:	10 cb       	st.b	r8++,r11
80007888:	20 1a       	sub	r10,1
8000788a:	58 0a       	cp.w	r10,0
8000788c:	cf d1       	brne	80007886 <memset+0x4>
8000788e:	5e fc       	retal	r12

80007890 <_realloc_r>:
80007890:	d4 31       	pushm	r0-r7,lr
80007892:	20 1d       	sub	sp,4
80007894:	16 94       	mov	r4,r11
80007896:	18 92       	mov	r2,r12
80007898:	14 9b       	mov	r11,r10
8000789a:	58 04       	cp.w	r4,0
8000789c:	c0 51       	brne	800078a6 <_realloc_r+0x16>
8000789e:	fe b0 fd 1f 	rcall	800072dc <_malloc_r>
800078a2:	18 95       	mov	r5,r12
800078a4:	c5 39       	rjmp	80007b4a <_realloc_r+0x2ba>
800078a6:	50 0a       	stdsp	sp[0x0],r10
800078a8:	fe b0 f2 98 	rcall	80005dd8 <__malloc_lock>
800078ac:	40 0b       	lddsp	r11,sp[0x0]
800078ae:	f6 c8 ff f5 	sub	r8,r11,-11
800078b2:	e8 c1 00 08 	sub	r1,r4,8
800078b6:	10 96       	mov	r6,r8
800078b8:	62 1c       	ld.w	r12,r1[0x4]
800078ba:	e0 16 ff f8 	andl	r6,0xfff8
800078be:	59 68       	cp.w	r8,22
800078c0:	f9 b6 08 10 	movls	r6,16
800078c4:	16 36       	cp.w	r6,r11
800078c6:	5f 38       	srlo	r8
800078c8:	f1 e6 13 f8 	or	r8,r8,r6>>0x1f
800078cc:	c0 50       	breq	800078d6 <_realloc_r+0x46>
800078ce:	30 c8       	mov	r8,12
800078d0:	30 05       	mov	r5,0
800078d2:	85 38       	st.w	r2[0xc],r8
800078d4:	c3 b9       	rjmp	80007b4a <_realloc_r+0x2ba>
800078d6:	18 90       	mov	r0,r12
800078d8:	e0 10 ff fc 	andl	r0,0xfffc
800078dc:	0c 30       	cp.w	r0,r6
800078de:	e0 84 01 0b 	brge	80007af4 <_realloc_r+0x264>
800078e2:	e0 68 05 3c 	mov	r8,1340
800078e6:	e2 00 00 09 	add	r9,r1,r0
800078ea:	70 25       	ld.w	r5,r8[0x8]
800078ec:	0a 39       	cp.w	r9,r5
800078ee:	c0 90       	breq	80007900 <_realloc_r+0x70>
800078f0:	72 1a       	ld.w	r10,r9[0x4]
800078f2:	a1 ca       	cbr	r10,0x0
800078f4:	f2 0a 00 0a 	add	r10,r9,r10
800078f8:	74 1a       	ld.w	r10,r10[0x4]
800078fa:	ed ba 00 00 	bld	r10,0x0
800078fe:	c2 20       	breq	80007942 <_realloc_r+0xb2>
80007900:	72 1a       	ld.w	r10,r9[0x4]
80007902:	e0 1a ff fc 	andl	r10,0xfffc
80007906:	f4 00 00 03 	add	r3,r10,r0
8000790a:	0a 39       	cp.w	r9,r5
8000790c:	c1 31       	brne	80007932 <_realloc_r+0xa2>
8000790e:	ec c7 ff f0 	sub	r7,r6,-16
80007912:	0e 33       	cp.w	r3,r7
80007914:	c1 95       	brlt	80007946 <_realloc_r+0xb6>
80007916:	e2 06 00 09 	add	r9,r1,r6
8000791a:	0c 13       	sub	r3,r6
8000791c:	a1 a3       	sbr	r3,0x0
8000791e:	93 13       	st.w	r9[0x4],r3
80007920:	91 29       	st.w	r8[0x8],r9
80007922:	04 9c       	mov	r12,r2
80007924:	62 18       	ld.w	r8,r1[0x4]
80007926:	08 95       	mov	r5,r4
80007928:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000792c:	10 46       	or	r6,r8
8000792e:	83 16       	st.w	r1[0x4],r6
80007930:	c0 b9       	rjmp	80007b46 <_realloc_r+0x2b6>
80007932:	0c 33       	cp.w	r3,r6
80007934:	c0 95       	brlt	80007946 <_realloc_r+0xb6>
80007936:	72 28       	ld.w	r8,r9[0x8]
80007938:	02 97       	mov	r7,r1
8000793a:	72 39       	ld.w	r9,r9[0xc]
8000793c:	93 28       	st.w	r9[0x8],r8
8000793e:	91 39       	st.w	r8[0xc],r9
80007940:	cd c8       	rjmp	80007af8 <_realloc_r+0x268>
80007942:	30 0a       	mov	r10,0
80007944:	14 99       	mov	r9,r10
80007946:	ed bc 00 00 	bld	r12,0x0
8000794a:	e0 80 00 95 	breq	80007a74 <_realloc_r+0x1e4>
8000794e:	62 07       	ld.w	r7,r1[0x0]
80007950:	e2 07 01 07 	sub	r7,r1,r7
80007954:	6e 1c       	ld.w	r12,r7[0x4]
80007956:	e0 1c ff fc 	andl	r12,0xfffc
8000795a:	58 09       	cp.w	r9,0
8000795c:	c5 60       	breq	80007a08 <_realloc_r+0x178>
8000795e:	f8 00 00 03 	add	r3,r12,r0
80007962:	0a 39       	cp.w	r9,r5
80007964:	c4 81       	brne	800079f4 <_realloc_r+0x164>
80007966:	14 03       	add	r3,r10
80007968:	ec c9 ff f0 	sub	r9,r6,-16
8000796c:	12 33       	cp.w	r3,r9
8000796e:	c4 d5       	brlt	80007a08 <_realloc_r+0x178>
80007970:	6e 3a       	ld.w	r10,r7[0xc]
80007972:	6e 29       	ld.w	r9,r7[0x8]
80007974:	95 29       	st.w	r10[0x8],r9
80007976:	93 3a       	st.w	r9[0xc],r10
80007978:	ee c5 ff f8 	sub	r5,r7,-8
8000797c:	e0 ca 00 04 	sub	r10,r0,4
80007980:	e0 4a 00 24 	cp.w	r10,36
80007984:	e0 8b 00 25 	brhi	800079ce <_realloc_r+0x13e>
80007988:	0a 99       	mov	r9,r5
8000798a:	59 3a       	cp.w	r10,19
8000798c:	e0 88 00 1a 	brls	800079c0 <_realloc_r+0x130>
80007990:	09 09       	ld.w	r9,r4++
80007992:	8b 09       	st.w	r5[0x0],r9
80007994:	09 09       	ld.w	r9,r4++
80007996:	8f 39       	st.w	r7[0xc],r9
80007998:	ee c9 ff f0 	sub	r9,r7,-16
8000799c:	59 ba       	cp.w	r10,27
8000799e:	e0 88 00 11 	brls	800079c0 <_realloc_r+0x130>
800079a2:	09 0b       	ld.w	r11,r4++
800079a4:	93 0b       	st.w	r9[0x0],r11
800079a6:	09 09       	ld.w	r9,r4++
800079a8:	8f 59       	st.w	r7[0x14],r9
800079aa:	ee c9 ff e8 	sub	r9,r7,-24
800079ae:	e0 4a 00 24 	cp.w	r10,36
800079b2:	c0 71       	brne	800079c0 <_realloc_r+0x130>
800079b4:	09 0a       	ld.w	r10,r4++
800079b6:	93 0a       	st.w	r9[0x0],r10
800079b8:	ee c9 ff e0 	sub	r9,r7,-32
800079bc:	09 0a       	ld.w	r10,r4++
800079be:	8f 7a       	st.w	r7[0x1c],r10
800079c0:	09 0a       	ld.w	r10,r4++
800079c2:	12 aa       	st.w	r9++,r10
800079c4:	68 0a       	ld.w	r10,r4[0x0]
800079c6:	93 0a       	st.w	r9[0x0],r10
800079c8:	68 1a       	ld.w	r10,r4[0x4]
800079ca:	93 1a       	st.w	r9[0x4],r10
800079cc:	c0 78       	rjmp	800079da <_realloc_r+0x14a>
800079ce:	50 08       	stdsp	sp[0x0],r8
800079d0:	08 9b       	mov	r11,r4
800079d2:	0a 9c       	mov	r12,r5
800079d4:	e0 a0 1d 9b 	rcall	8000b50a <memmove>
800079d8:	40 08       	lddsp	r8,sp[0x0]
800079da:	ee 06 00 09 	add	r9,r7,r6
800079de:	0c 13       	sub	r3,r6
800079e0:	a1 a3       	sbr	r3,0x0
800079e2:	93 13       	st.w	r9[0x4],r3
800079e4:	91 29       	st.w	r8[0x8],r9
800079e6:	04 9c       	mov	r12,r2
800079e8:	6e 18       	ld.w	r8,r7[0x4]
800079ea:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800079ee:	10 46       	or	r6,r8
800079f0:	8f 16       	st.w	r7[0x4],r6
800079f2:	ca a8       	rjmp	80007b46 <_realloc_r+0x2b6>
800079f4:	14 03       	add	r3,r10
800079f6:	0c 33       	cp.w	r3,r6
800079f8:	c0 85       	brlt	80007a08 <_realloc_r+0x178>
800079fa:	72 28       	ld.w	r8,r9[0x8]
800079fc:	72 39       	ld.w	r9,r9[0xc]
800079fe:	93 28       	st.w	r9[0x8],r8
80007a00:	91 39       	st.w	r8[0xc],r9
80007a02:	6e 28       	ld.w	r8,r7[0x8]
80007a04:	6e 39       	ld.w	r9,r7[0xc]
80007a06:	c0 78       	rjmp	80007a14 <_realloc_r+0x184>
80007a08:	f8 00 00 03 	add	r3,r12,r0
80007a0c:	0c 33       	cp.w	r3,r6
80007a0e:	c3 35       	brlt	80007a74 <_realloc_r+0x1e4>
80007a10:	6e 39       	ld.w	r9,r7[0xc]
80007a12:	6e 28       	ld.w	r8,r7[0x8]
80007a14:	93 28       	st.w	r9[0x8],r8
80007a16:	91 39       	st.w	r8[0xc],r9
80007a18:	e0 ca 00 04 	sub	r10,r0,4
80007a1c:	ee cc ff f8 	sub	r12,r7,-8
80007a20:	e0 4a 00 24 	cp.w	r10,36
80007a24:	e0 8b 00 24 	brhi	80007a6c <_realloc_r+0x1dc>
80007a28:	59 3a       	cp.w	r10,19
80007a2a:	e0 88 00 1a 	brls	80007a5e <_realloc_r+0x1ce>
80007a2e:	09 08       	ld.w	r8,r4++
80007a30:	99 08       	st.w	r12[0x0],r8
80007a32:	09 08       	ld.w	r8,r4++
80007a34:	8f 38       	st.w	r7[0xc],r8
80007a36:	ee cc ff f0 	sub	r12,r7,-16
80007a3a:	59 ba       	cp.w	r10,27
80007a3c:	e0 88 00 11 	brls	80007a5e <_realloc_r+0x1ce>
80007a40:	09 08       	ld.w	r8,r4++
80007a42:	99 08       	st.w	r12[0x0],r8
80007a44:	09 08       	ld.w	r8,r4++
80007a46:	8f 58       	st.w	r7[0x14],r8
80007a48:	ee cc ff e8 	sub	r12,r7,-24
80007a4c:	e0 4a 00 24 	cp.w	r10,36
80007a50:	c0 71       	brne	80007a5e <_realloc_r+0x1ce>
80007a52:	09 08       	ld.w	r8,r4++
80007a54:	99 08       	st.w	r12[0x0],r8
80007a56:	ee cc ff e0 	sub	r12,r7,-32
80007a5a:	09 08       	ld.w	r8,r4++
80007a5c:	8f 78       	st.w	r7[0x1c],r8
80007a5e:	09 08       	ld.w	r8,r4++
80007a60:	18 a8       	st.w	r12++,r8
80007a62:	68 08       	ld.w	r8,r4[0x0]
80007a64:	99 08       	st.w	r12[0x0],r8
80007a66:	68 18       	ld.w	r8,r4[0x4]
80007a68:	99 18       	st.w	r12[0x4],r8
80007a6a:	c4 78       	rjmp	80007af8 <_realloc_r+0x268>
80007a6c:	08 9b       	mov	r11,r4
80007a6e:	e0 a0 1d 4e 	rcall	8000b50a <memmove>
80007a72:	c4 38       	rjmp	80007af8 <_realloc_r+0x268>
80007a74:	04 9c       	mov	r12,r2
80007a76:	fe b0 fc 33 	rcall	800072dc <_malloc_r>
80007a7a:	18 95       	mov	r5,r12
80007a7c:	c3 a0       	breq	80007af0 <_realloc_r+0x260>
80007a7e:	62 18       	ld.w	r8,r1[0x4]
80007a80:	f8 c9 00 08 	sub	r9,r12,8
80007a84:	a1 c8       	cbr	r8,0x0
80007a86:	e2 08 00 08 	add	r8,r1,r8
80007a8a:	10 39       	cp.w	r9,r8
80007a8c:	c0 71       	brne	80007a9a <_realloc_r+0x20a>
80007a8e:	72 13       	ld.w	r3,r9[0x4]
80007a90:	02 97       	mov	r7,r1
80007a92:	e0 13 ff fc 	andl	r3,0xfffc
80007a96:	00 03       	add	r3,r0
80007a98:	c3 08       	rjmp	80007af8 <_realloc_r+0x268>
80007a9a:	e0 ca 00 04 	sub	r10,r0,4
80007a9e:	e0 4a 00 24 	cp.w	r10,36
80007aa2:	e0 8b 00 20 	brhi	80007ae2 <_realloc_r+0x252>
80007aa6:	08 99       	mov	r9,r4
80007aa8:	18 98       	mov	r8,r12
80007aaa:	59 3a       	cp.w	r10,19
80007aac:	e0 88 00 14 	brls	80007ad4 <_realloc_r+0x244>
80007ab0:	13 0b       	ld.w	r11,r9++
80007ab2:	10 ab       	st.w	r8++,r11
80007ab4:	13 0b       	ld.w	r11,r9++
80007ab6:	10 ab       	st.w	r8++,r11
80007ab8:	59 ba       	cp.w	r10,27
80007aba:	e0 88 00 0d 	brls	80007ad4 <_realloc_r+0x244>
80007abe:	13 0b       	ld.w	r11,r9++
80007ac0:	10 ab       	st.w	r8++,r11
80007ac2:	13 0b       	ld.w	r11,r9++
80007ac4:	10 ab       	st.w	r8++,r11
80007ac6:	e0 4a 00 24 	cp.w	r10,36
80007aca:	c0 51       	brne	80007ad4 <_realloc_r+0x244>
80007acc:	13 0a       	ld.w	r10,r9++
80007ace:	10 aa       	st.w	r8++,r10
80007ad0:	13 0a       	ld.w	r10,r9++
80007ad2:	10 aa       	st.w	r8++,r10
80007ad4:	13 0a       	ld.w	r10,r9++
80007ad6:	10 aa       	st.w	r8++,r10
80007ad8:	72 0a       	ld.w	r10,r9[0x0]
80007ada:	91 0a       	st.w	r8[0x0],r10
80007adc:	72 19       	ld.w	r9,r9[0x4]
80007ade:	91 19       	st.w	r8[0x4],r9
80007ae0:	c0 48       	rjmp	80007ae8 <_realloc_r+0x258>
80007ae2:	08 9b       	mov	r11,r4
80007ae4:	e0 a0 1d 13 	rcall	8000b50a <memmove>
80007ae8:	08 9b       	mov	r11,r4
80007aea:	04 9c       	mov	r12,r2
80007aec:	e0 a0 1a 6c 	rcall	8000afc4 <_free_r>
80007af0:	04 9c       	mov	r12,r2
80007af2:	c2 a8       	rjmp	80007b46 <_realloc_r+0x2b6>
80007af4:	00 93       	mov	r3,r0
80007af6:	02 97       	mov	r7,r1
80007af8:	e6 06 01 09 	sub	r9,r3,r6
80007afc:	6e 18       	ld.w	r8,r7[0x4]
80007afe:	58 f9       	cp.w	r9,15
80007b00:	e0 88 00 16 	brls	80007b2c <_realloc_r+0x29c>
80007b04:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007b08:	ed e8 10 08 	or	r8,r6,r8
80007b0c:	8f 18       	st.w	r7[0x4],r8
80007b0e:	12 98       	mov	r8,r9
80007b10:	a1 a8       	sbr	r8,0x0
80007b12:	ee 06 00 0b 	add	r11,r7,r6
80007b16:	f6 09 00 09 	add	r9,r11,r9
80007b1a:	97 18       	st.w	r11[0x4],r8
80007b1c:	72 18       	ld.w	r8,r9[0x4]
80007b1e:	a1 a8       	sbr	r8,0x0
80007b20:	2f 8b       	sub	r11,-8
80007b22:	93 18       	st.w	r9[0x4],r8
80007b24:	04 9c       	mov	r12,r2
80007b26:	e0 a0 1a 4f 	rcall	8000afc4 <_free_r>
80007b2a:	c0 b8       	rjmp	80007b40 <_realloc_r+0x2b0>
80007b2c:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007b30:	e7 e8 10 08 	or	r8,r3,r8
80007b34:	8f 18       	st.w	r7[0x4],r8
80007b36:	ee 03 00 03 	add	r3,r7,r3
80007b3a:	66 18       	ld.w	r8,r3[0x4]
80007b3c:	a1 a8       	sbr	r8,0x0
80007b3e:	87 18       	st.w	r3[0x4],r8
80007b40:	04 9c       	mov	r12,r2
80007b42:	ee c5 ff f8 	sub	r5,r7,-8
80007b46:	fe b0 f1 4f 	rcall	80005de4 <__malloc_unlock>
80007b4a:	0a 9c       	mov	r12,r5
80007b4c:	2f fd       	sub	sp,-4
80007b4e:	d8 32       	popm	r0-r7,pc

80007b50 <_sbrk_r>:
80007b50:	d4 21       	pushm	r4-r7,lr
80007b52:	30 08       	mov	r8,0
80007b54:	18 97       	mov	r7,r12
80007b56:	e0 66 63 9c 	mov	r6,25500
80007b5a:	16 9c       	mov	r12,r11
80007b5c:	8d 08       	st.w	r6[0x0],r8
80007b5e:	c9 1c       	rcall	80007c80 <_sbrk>
80007b60:	5b fc       	cp.w	r12,-1
80007b62:	c0 51       	brne	80007b6c <_sbrk_r+0x1c>
80007b64:	6c 08       	ld.w	r8,r6[0x0]
80007b66:	58 08       	cp.w	r8,0
80007b68:	ef f8 1a 03 	st.wne	r7[0xc],r8
80007b6c:	d8 22       	popm	r4-r7,pc
80007b6e:	d7 03       	nop

80007b70 <sprintf>:
80007b70:	d4 01       	pushm	lr
80007b72:	21 7d       	sub	sp,92
80007b74:	e0 68 ff ff 	mov	r8,65535
80007b78:	ea 18 7f ff 	orh	r8,0x7fff
80007b7c:	50 58       	stdsp	sp[0x14],r8
80007b7e:	50 28       	stdsp	sp[0x8],r8
80007b80:	e0 68 02 08 	mov	r8,520
80007b84:	ba 68       	st.h	sp[0xc],r8
80007b86:	3f f8       	mov	r8,-1
80007b88:	ba 78       	st.h	sp[0xe],r8
80007b8a:	e0 68 0a 3c 	mov	r8,2620
80007b8e:	50 4c       	stdsp	sp[0x10],r12
80007b90:	16 9a       	mov	r10,r11
80007b92:	50 0c       	stdsp	sp[0x0],r12
80007b94:	fa c9 ff a0 	sub	r9,sp,-96
80007b98:	70 0c       	ld.w	r12,r8[0x0]
80007b9a:	1a 9b       	mov	r11,sp
80007b9c:	e0 a0 02 26 	rcall	80007fe8 <_vfprintf_r>
80007ba0:	30 09       	mov	r9,0
80007ba2:	40 08       	lddsp	r8,sp[0x0]
80007ba4:	b0 89       	st.b	r8[0x0],r9
80007ba6:	2e 9d       	sub	sp,-92
80007ba8:	d8 02       	popm	pc
80007baa:	d7 03       	nop

80007bac <strlen>:
80007bac:	30 09       	mov	r9,0
80007bae:	18 98       	mov	r8,r12
80007bb0:	c0 28       	rjmp	80007bb4 <strlen+0x8>
80007bb2:	2f f8       	sub	r8,-1
80007bb4:	11 8a       	ld.ub	r10,r8[0x0]
80007bb6:	f2 0a 18 00 	cp.b	r10,r9
80007bba:	cf c1       	brne	80007bb2 <strlen+0x6>
80007bbc:	f0 0c 01 0c 	sub	r12,r8,r12
80007bc0:	5e fc       	retal	r12
80007bc2:	d7 03       	nop

80007bc4 <strncpy>:
80007bc4:	30 08       	mov	r8,0
80007bc6:	10 3a       	cp.w	r10,r8
80007bc8:	5e 0c       	reteq	r12
80007bca:	f6 08 07 09 	ld.ub	r9,r11[r8]
80007bce:	f8 08 0b 09 	st.b	r12[r8],r9
80007bd2:	2f f8       	sub	r8,-1
80007bd4:	58 09       	cp.w	r9,0
80007bd6:	cf 81       	brne	80007bc6 <strncpy+0x2>
80007bd8:	10 3a       	cp.w	r10,r8
80007bda:	5e 0c       	reteq	r12
80007bdc:	f8 08 0b 09 	st.b	r12[r8],r9
80007be0:	2f f8       	sub	r8,-1
80007be2:	cf bb       	rjmp	80007bd8 <strncpy+0x14>

80007be4 <_close>:
80007be4:	30 28       	mov	r8,2
80007be6:	d6 73       	breakpoint
80007be8:	3f fc       	mov	r12,-1
80007bea:	35 8b       	mov	r11,88
80007bec:	58 0c       	cp.w	r12,0
80007bee:	5e 4c       	retge	r12
80007bf0:	e0 6a 63 9c 	mov	r10,25500
80007bf4:	95 0b       	st.w	r10[0x0],r11
80007bf6:	5e fc       	retal	r12

80007bf8 <_lseek>:
80007bf8:	30 58       	mov	r8,5
80007bfa:	d6 73       	breakpoint
80007bfc:	3f fc       	mov	r12,-1
80007bfe:	35 8b       	mov	r11,88
80007c00:	58 0c       	cp.w	r12,0
80007c02:	5e 4c       	retge	r12
80007c04:	e0 6a 63 9c 	mov	r10,25500
80007c08:	95 0b       	st.w	r10[0x0],r11
80007c0a:	5e fc       	retal	r12

80007c0c <isatty>:
80007c0c:	30 b8       	mov	r8,11
80007c0e:	d6 73       	breakpoint
80007c10:	3f fc       	mov	r12,-1
80007c12:	35 8b       	mov	r11,88
80007c14:	58 0c       	cp.w	r12,0
80007c16:	5e 4c       	retge	r12
80007c18:	e0 6a 63 9c 	mov	r10,25500
80007c1c:	95 0b       	st.w	r10[0x0],r11
80007c1e:	5e fc       	retal	r12

80007c20 <_fstat_host>:
80007c20:	30 98       	mov	r8,9
80007c22:	d6 73       	breakpoint
80007c24:	3f fc       	mov	r12,-1
80007c26:	35 8b       	mov	r11,88
80007c28:	58 0c       	cp.w	r12,0
80007c2a:	5e 4c       	retge	r12
80007c2c:	e0 6a 63 9c 	mov	r10,25500
80007c30:	95 0b       	st.w	r10[0x0],r11
80007c32:	5e fc       	retal	r12

80007c34 <_fstat>:
80007c34:	d4 21       	pushm	r4-r7,lr
80007c36:	21 0d       	sub	sp,64
80007c38:	16 97       	mov	r7,r11
80007c3a:	1a 9b       	mov	r11,sp
80007c3c:	cf 2f       	rcall	80007c20 <_fstat_host>
80007c3e:	c0 34       	brge	80007c44 <_fstat+0x10>
80007c40:	3f fc       	mov	r12,-1
80007c42:	c1 c8       	rjmp	80007c7a <_fstat+0x46>
80007c44:	40 08       	lddsp	r8,sp[0x0]
80007c46:	ae 08       	st.h	r7[0x0],r8
80007c48:	40 18       	lddsp	r8,sp[0x4]
80007c4a:	ae 18       	st.h	r7[0x2],r8
80007c4c:	40 28       	lddsp	r8,sp[0x8]
80007c4e:	8f 18       	st.w	r7[0x4],r8
80007c50:	40 38       	lddsp	r8,sp[0xc]
80007c52:	ae 48       	st.h	r7[0x8],r8
80007c54:	40 48       	lddsp	r8,sp[0x10]
80007c56:	ae 58       	st.h	r7[0xa],r8
80007c58:	40 58       	lddsp	r8,sp[0x14]
80007c5a:	ae 68       	st.h	r7[0xc],r8
80007c5c:	40 68       	lddsp	r8,sp[0x18]
80007c5e:	ae 78       	st.h	r7[0xe],r8
80007c60:	40 88       	lddsp	r8,sp[0x20]
80007c62:	8f 48       	st.w	r7[0x10],r8
80007c64:	40 a8       	lddsp	r8,sp[0x28]
80007c66:	8f b8       	st.w	r7[0x2c],r8
80007c68:	40 c8       	lddsp	r8,sp[0x30]
80007c6a:	8f c8       	st.w	r7[0x30],r8
80007c6c:	40 d8       	lddsp	r8,sp[0x34]
80007c6e:	8f 58       	st.w	r7[0x14],r8
80007c70:	40 e8       	lddsp	r8,sp[0x38]
80007c72:	30 0c       	mov	r12,0
80007c74:	8f 78       	st.w	r7[0x1c],r8
80007c76:	40 f8       	lddsp	r8,sp[0x3c]
80007c78:	8f 98       	st.w	r7[0x24],r8
80007c7a:	2f 0d       	sub	sp,-64
80007c7c:	d8 22       	popm	r4-r7,pc
80007c7e:	d7 03       	nop

80007c80 <_sbrk>:
80007c80:	d4 01       	pushm	lr
80007c82:	e0 68 0d 84 	mov	r8,3460
80007c86:	70 09       	ld.w	r9,r8[0x0]
80007c88:	58 09       	cp.w	r9,0
80007c8a:	c0 41       	brne	80007c92 <_sbrk+0x12>
80007c8c:	e0 69 63 a0 	mov	r9,25504
80007c90:	91 09       	st.w	r8[0x0],r9
80007c92:	e0 69 0d 84 	mov	r9,3460
80007c96:	e0 7a 70 00 	mov	r10,94208
80007c9a:	72 08       	ld.w	r8,r9[0x0]
80007c9c:	f0 0c 00 0c 	add	r12,r8,r12
80007ca0:	14 3c       	cp.w	r12,r10
80007ca2:	e0 8b 00 04 	brhi	80007caa <_sbrk+0x2a>
80007ca6:	93 0c       	st.w	r9[0x0],r12
80007ca8:	c0 68       	rjmp	80007cb4 <_sbrk+0x34>
80007caa:	e0 a0 18 15 	rcall	8000acd4 <__errno>
80007cae:	30 c8       	mov	r8,12
80007cb0:	99 08       	st.w	r12[0x0],r8
80007cb2:	3f f8       	mov	r8,-1
80007cb4:	10 9c       	mov	r12,r8
80007cb6:	d8 02       	popm	pc

80007cb8 <get_arg>:
80007cb8:	d4 31       	pushm	r0-r7,lr
80007cba:	20 8d       	sub	sp,32
80007cbc:	fa c4 ff bc 	sub	r4,sp,-68
80007cc0:	50 4b       	stdsp	sp[0x10],r11
80007cc2:	68 2e       	ld.w	lr,r4[0x8]
80007cc4:	50 58       	stdsp	sp[0x14],r8
80007cc6:	12 96       	mov	r6,r9
80007cc8:	7c 0b       	ld.w	r11,lr[0x0]
80007cca:	70 05       	ld.w	r5,r8[0x0]
80007ccc:	50 6e       	stdsp	sp[0x18],lr
80007cce:	58 0b       	cp.w	r11,0
80007cd0:	f4 0b 17 00 	moveq	r11,r10
80007cd4:	68 03       	ld.w	r3,r4[0x0]
80007cd6:	68 11       	ld.w	r1,r4[0x4]
80007cd8:	40 49       	lddsp	r9,sp[0x10]
80007cda:	30 08       	mov	r8,0
80007cdc:	c2 89       	rjmp	80007f2c <get_arg+0x274>
80007cde:	2f fb       	sub	r11,-1
80007ce0:	32 5c       	mov	r12,37
80007ce2:	17 8a       	ld.ub	r10,r11[0x0]
80007ce4:	f8 0a 18 00 	cp.b	r10,r12
80007ce8:	5f 1e       	srne	lr
80007cea:	f0 0a 18 00 	cp.b	r10,r8
80007cee:	5f 1c       	srne	r12
80007cf0:	fd ec 00 0c 	and	r12,lr,r12
80007cf4:	f0 0c 18 00 	cp.b	r12,r8
80007cf8:	cf 31       	brne	80007cde <get_arg+0x26>
80007cfa:	58 0a       	cp.w	r10,0
80007cfc:	e0 80 01 25 	breq	80007f46 <get_arg+0x28e>
80007d00:	30 0c       	mov	r12,0
80007d02:	3f fa       	mov	r10,-1
80007d04:	18 90       	mov	r0,r12
80007d06:	50 3a       	stdsp	sp[0xc],r10
80007d08:	18 94       	mov	r4,r12
80007d0a:	18 92       	mov	r2,r12
80007d0c:	f8 0c 00 3c 	add	r12,r12,r12<<0x3
80007d10:	16 97       	mov	r7,r11
80007d12:	50 7c       	stdsp	sp[0x1c],r12
80007d14:	fe cc 9a 14 	sub	r12,pc,-26092
80007d18:	0f 3a       	ld.ub	r10,r7++
80007d1a:	f8 0a 07 0e 	ld.ub	lr,r12[r10]
80007d1e:	40 7c       	lddsp	r12,sp[0x1c]
80007d20:	1c 0c       	add	r12,lr
80007d22:	fe ce 9a ea 	sub	lr,pc,-25878
80007d26:	fc 0c 07 0e 	ld.ub	lr,lr[r12]
80007d2a:	20 1e       	sub	lr,1
80007d2c:	50 0e       	stdsp	sp[0x0],lr
80007d2e:	fe ce 9b 62 	sub	lr,pc,-25758
80007d32:	fc 0c 07 0c 	ld.ub	r12,lr[r12]
80007d36:	50 7c       	stdsp	sp[0x1c],r12
80007d38:	40 0c       	lddsp	r12,sp[0x0]
80007d3a:	58 7c       	cp.w	r12,7
80007d3c:	e0 8b 00 f1 	brhi	80007f1e <get_arg+0x266>
80007d40:	fe ce 9d 14 	sub	lr,pc,-25324
80007d44:	fc 0c 03 2f 	ld.w	pc,lr[r12<<0x2]
80007d48:	36 8b       	mov	r11,104
80007d4a:	f6 0a 18 00 	cp.b	r10,r11
80007d4e:	e0 80 00 e8 	breq	80007f1e <get_arg+0x266>
80007d52:	37 1b       	mov	r11,113
80007d54:	f6 0a 18 00 	cp.b	r10,r11
80007d58:	c0 70       	breq	80007d66 <get_arg+0xae>
80007d5a:	34 cb       	mov	r11,76
80007d5c:	f6 0a 18 00 	cp.b	r10,r11
80007d60:	c0 51       	brne	80007d6a <get_arg+0xb2>
80007d62:	a3 b4       	sbr	r4,0x3
80007d64:	cd d8       	rjmp	80007f1e <get_arg+0x266>
80007d66:	a5 b4       	sbr	r4,0x5
80007d68:	cd b8       	rjmp	80007f1e <get_arg+0x266>
80007d6a:	08 9a       	mov	r10,r4
80007d6c:	0e 9b       	mov	r11,r7
80007d6e:	a5 aa       	sbr	r10,0x4
80007d70:	17 3c       	ld.ub	r12,r11++
80007d72:	a5 b4       	sbr	r4,0x5
80007d74:	36 ce       	mov	lr,108
80007d76:	fc 0c 18 00 	cp.b	r12,lr
80007d7a:	e0 80 00 d3 	breq	80007f20 <get_arg+0x268>
80007d7e:	14 94       	mov	r4,r10
80007d80:	cc f8       	rjmp	80007f1e <get_arg+0x266>
80007d82:	eb d5 c0 05 	bfextu	r5,r5,0x0,0x5
80007d86:	36 7c       	mov	r12,103
80007d88:	f8 0a 18 00 	cp.b	r10,r12
80007d8c:	e0 8b 00 27 	brhi	80007dda <get_arg+0x122>
80007d90:	36 5b       	mov	r11,101
80007d92:	f6 0a 18 00 	cp.b	r10,r11
80007d96:	c4 82       	brcc	80007e26 <get_arg+0x16e>
80007d98:	34 fb       	mov	r11,79
80007d9a:	f6 0a 18 00 	cp.b	r10,r11
80007d9e:	c4 80       	breq	80007e2e <get_arg+0x176>
80007da0:	e0 8b 00 0c 	brhi	80007db8 <get_arg+0x100>
80007da4:	34 5b       	mov	r11,69
80007da6:	f6 0a 18 00 	cp.b	r10,r11
80007daa:	c3 e0       	breq	80007e26 <get_arg+0x16e>
80007dac:	34 7b       	mov	r11,71
80007dae:	f6 0a 18 00 	cp.b	r10,r11
80007db2:	c3 a0       	breq	80007e26 <get_arg+0x16e>
80007db4:	34 4b       	mov	r11,68
80007db6:	c0 88       	rjmp	80007dc6 <get_arg+0x10e>
80007db8:	35 8b       	mov	r11,88
80007dba:	f6 0a 18 00 	cp.b	r10,r11
80007dbe:	c2 c0       	breq	80007e16 <get_arg+0x15e>
80007dc0:	e0 8b 00 07 	brhi	80007dce <get_arg+0x116>
80007dc4:	35 5b       	mov	r11,85
80007dc6:	f6 0a 18 00 	cp.b	r10,r11
80007dca:	c3 51       	brne	80007e34 <get_arg+0x17c>
80007dcc:	c3 18       	rjmp	80007e2e <get_arg+0x176>
80007dce:	36 3b       	mov	r11,99
80007dd0:	f6 0a 18 00 	cp.b	r10,r11
80007dd4:	c2 f0       	breq	80007e32 <get_arg+0x17a>
80007dd6:	36 4b       	mov	r11,100
80007dd8:	c0 e8       	rjmp	80007df4 <get_arg+0x13c>
80007dda:	37 0b       	mov	r11,112
80007ddc:	f6 0a 18 00 	cp.b	r10,r11
80007de0:	c2 50       	breq	80007e2a <get_arg+0x172>
80007de2:	e0 8b 00 0d 	brhi	80007dfc <get_arg+0x144>
80007de6:	36 eb       	mov	r11,110
80007de8:	f6 0a 18 00 	cp.b	r10,r11
80007dec:	c1 f0       	breq	80007e2a <get_arg+0x172>
80007dee:	e0 8b 00 14 	brhi	80007e16 <get_arg+0x15e>
80007df2:	36 9b       	mov	r11,105
80007df4:	f6 0a 18 00 	cp.b	r10,r11
80007df8:	c1 e1       	brne	80007e34 <get_arg+0x17c>
80007dfa:	c0 e8       	rjmp	80007e16 <get_arg+0x15e>
80007dfc:	37 5b       	mov	r11,117
80007dfe:	f6 0a 18 00 	cp.b	r10,r11
80007e02:	c0 a0       	breq	80007e16 <get_arg+0x15e>
80007e04:	37 8b       	mov	r11,120
80007e06:	f6 0a 18 00 	cp.b	r10,r11
80007e0a:	c0 60       	breq	80007e16 <get_arg+0x15e>
80007e0c:	37 3b       	mov	r11,115
80007e0e:	f6 0a 18 00 	cp.b	r10,r11
80007e12:	c1 11       	brne	80007e34 <get_arg+0x17c>
80007e14:	c0 b8       	rjmp	80007e2a <get_arg+0x172>
80007e16:	ed b4 00 04 	bld	r4,0x4
80007e1a:	c0 a0       	breq	80007e2e <get_arg+0x176>
80007e1c:	ed b4 00 05 	bld	r4,0x5
80007e20:	c0 91       	brne	80007e32 <get_arg+0x17a>
80007e22:	30 20       	mov	r0,2
80007e24:	c0 88       	rjmp	80007e34 <get_arg+0x17c>
80007e26:	30 40       	mov	r0,4
80007e28:	c0 68       	rjmp	80007e34 <get_arg+0x17c>
80007e2a:	30 30       	mov	r0,3
80007e2c:	c0 48       	rjmp	80007e34 <get_arg+0x17c>
80007e2e:	30 10       	mov	r0,1
80007e30:	c0 28       	rjmp	80007e34 <get_arg+0x17c>
80007e32:	30 00       	mov	r0,0
80007e34:	40 3b       	lddsp	r11,sp[0xc]
80007e36:	5b fb       	cp.w	r11,-1
80007e38:	c0 40       	breq	80007e40 <get_arg+0x188>
80007e3a:	e2 0b 09 20 	st.w	r1[r11<<0x2],r0
80007e3e:	c7 08       	rjmp	80007f1e <get_arg+0x266>
80007e40:	58 60       	cp.w	r0,6
80007e42:	e0 8b 00 6e 	brhi	80007f1e <get_arg+0x266>
80007e46:	6c 0a       	ld.w	r10,r6[0x0]
80007e48:	ea cc ff ff 	sub	r12,r5,-1
80007e4c:	fe ce 9e 00 	sub	lr,pc,-25088
80007e50:	fc 00 03 2f 	ld.w	pc,lr[r0<<0x2]
80007e54:	f4 cb ff f8 	sub	r11,r10,-8
80007e58:	8d 0b       	st.w	r6[0x0],r11
80007e5a:	f4 ea 00 00 	ld.d	r10,r10[0]
80007e5e:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80007e62:	c0 f8       	rjmp	80007e80 <get_arg+0x1c8>
80007e64:	f4 cb ff fc 	sub	r11,r10,-4
80007e68:	8d 0b       	st.w	r6[0x0],r11
80007e6a:	74 0a       	ld.w	r10,r10[0x0]
80007e6c:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80007e70:	c0 88       	rjmp	80007e80 <get_arg+0x1c8>
80007e72:	f4 cb ff f8 	sub	r11,r10,-8
80007e76:	8d 0b       	st.w	r6[0x0],r11
80007e78:	f4 ea 00 00 	ld.d	r10,r10[0]
80007e7c:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80007e80:	0e 9b       	mov	r11,r7
80007e82:	18 95       	mov	r5,r12
80007e84:	c4 e8       	rjmp	80007f20 <get_arg+0x268>
80007e86:	62 0a       	ld.w	r10,r1[0x0]
80007e88:	5b fa       	cp.w	r10,-1
80007e8a:	c0 b1       	brne	80007ea0 <get_arg+0x1e8>
80007e8c:	50 19       	stdsp	sp[0x4],r9
80007e8e:	50 28       	stdsp	sp[0x8],r8
80007e90:	e0 6a 00 80 	mov	r10,128
80007e94:	30 0b       	mov	r11,0
80007e96:	02 9c       	mov	r12,r1
80007e98:	fe b0 fc f5 	rcall	80007882 <memset>
80007e9c:	40 28       	lddsp	r8,sp[0x8]
80007e9e:	40 19       	lddsp	r9,sp[0x4]
80007ea0:	e4 cc 00 01 	sub	r12,r2,1
80007ea4:	0e 9b       	mov	r11,r7
80007ea6:	50 3c       	stdsp	sp[0xc],r12
80007ea8:	f2 0c 0c 49 	max	r9,r9,r12
80007eac:	c3 a8       	rjmp	80007f20 <get_arg+0x268>
80007eae:	62 0a       	ld.w	r10,r1[0x0]
80007eb0:	5b fa       	cp.w	r10,-1
80007eb2:	c0 b1       	brne	80007ec8 <get_arg+0x210>
80007eb4:	50 19       	stdsp	sp[0x4],r9
80007eb6:	50 28       	stdsp	sp[0x8],r8
80007eb8:	e0 6a 00 80 	mov	r10,128
80007ebc:	30 0b       	mov	r11,0
80007ebe:	02 9c       	mov	r12,r1
80007ec0:	fe b0 fc e1 	rcall	80007882 <memset>
80007ec4:	40 28       	lddsp	r8,sp[0x8]
80007ec6:	40 19       	lddsp	r9,sp[0x4]
80007ec8:	20 12       	sub	r2,1
80007eca:	30 0a       	mov	r10,0
80007ecc:	0e 9b       	mov	r11,r7
80007ece:	e2 02 09 2a 	st.w	r1[r2<<0x2],r10
80007ed2:	f2 02 0c 49 	max	r9,r9,r2
80007ed6:	c2 58       	rjmp	80007f20 <get_arg+0x268>
80007ed8:	16 97       	mov	r7,r11
80007eda:	6c 0a       	ld.w	r10,r6[0x0]
80007edc:	f4 cb ff fc 	sub	r11,r10,-4
80007ee0:	8d 0b       	st.w	r6[0x0],r11
80007ee2:	74 0a       	ld.w	r10,r10[0x0]
80007ee4:	0e 9b       	mov	r11,r7
80007ee6:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80007eea:	2f f5       	sub	r5,-1
80007eec:	c1 a8       	rjmp	80007f20 <get_arg+0x268>
80007eee:	f4 c2 00 30 	sub	r2,r10,48
80007ef2:	c0 68       	rjmp	80007efe <get_arg+0x246>
80007ef4:	e4 02 00 22 	add	r2,r2,r2<<0x2
80007ef8:	2f f7       	sub	r7,-1
80007efa:	f4 02 00 12 	add	r2,r10,r2<<0x1
80007efe:	0f 8a       	ld.ub	r10,r7[0x0]
80007f00:	58 0a       	cp.w	r10,0
80007f02:	c0 e0       	breq	80007f1e <get_arg+0x266>
80007f04:	23 0a       	sub	r10,48
80007f06:	58 9a       	cp.w	r10,9
80007f08:	fe 98 ff f6 	brls	80007ef4 <get_arg+0x23c>
80007f0c:	c0 98       	rjmp	80007f1e <get_arg+0x266>
80007f0e:	2f f7       	sub	r7,-1
80007f10:	0f 8a       	ld.ub	r10,r7[0x0]
80007f12:	58 0a       	cp.w	r10,0
80007f14:	c0 50       	breq	80007f1e <get_arg+0x266>
80007f16:	23 0a       	sub	r10,48
80007f18:	58 9a       	cp.w	r10,9
80007f1a:	fe 98 ff fa 	brls	80007f0e <get_arg+0x256>
80007f1e:	0e 9b       	mov	r11,r7
80007f20:	40 7c       	lddsp	r12,sp[0x1c]
80007f22:	30 ba       	mov	r10,11
80007f24:	f4 0c 18 00 	cp.b	r12,r10
80007f28:	fe 91 fe f2 	brne	80007d0c <get_arg+0x54>
80007f2c:	40 42       	lddsp	r2,sp[0x10]
80007f2e:	17 8c       	ld.ub	r12,r11[0x0]
80007f30:	0a 32       	cp.w	r2,r5
80007f32:	5f 4a       	srge	r10
80007f34:	f0 0c 18 00 	cp.b	r12,r8
80007f38:	5f 1c       	srne	r12
80007f3a:	f9 ea 00 0a 	and	r10,r12,r10
80007f3e:	f0 0a 18 00 	cp.b	r10,r8
80007f42:	fe 91 fe cf 	brne	80007ce0 <get_arg+0x28>
80007f46:	30 08       	mov	r8,0
80007f48:	40 4e       	lddsp	lr,sp[0x10]
80007f4a:	17 8a       	ld.ub	r10,r11[0x0]
80007f4c:	e2 05 00 21 	add	r1,r1,r5<<0x2
80007f50:	f0 0a 18 00 	cp.b	r10,r8
80007f54:	fc 09 17 10 	movne	r9,lr
80007f58:	e6 05 00 38 	add	r8,r3,r5<<0x3
80007f5c:	06 9e       	mov	lr,r3
80007f5e:	c2 a8       	rjmp	80007fb2 <get_arg+0x2fa>
80007f60:	62 0a       	ld.w	r10,r1[0x0]
80007f62:	58 3a       	cp.w	r10,3
80007f64:	c1 e0       	breq	80007fa0 <get_arg+0x2e8>
80007f66:	e0 89 00 07 	brgt	80007f74 <get_arg+0x2bc>
80007f6a:	58 1a       	cp.w	r10,1
80007f6c:	c1 a0       	breq	80007fa0 <get_arg+0x2e8>
80007f6e:	58 2a       	cp.w	r10,2
80007f70:	c1 81       	brne	80007fa0 <get_arg+0x2e8>
80007f72:	c0 58       	rjmp	80007f7c <get_arg+0x2c4>
80007f74:	58 5a       	cp.w	r10,5
80007f76:	c0 c0       	breq	80007f8e <get_arg+0x2d6>
80007f78:	c0 b5       	brlt	80007f8e <get_arg+0x2d6>
80007f7a:	c1 38       	rjmp	80007fa0 <get_arg+0x2e8>
80007f7c:	6c 0a       	ld.w	r10,r6[0x0]
80007f7e:	f4 cc ff f8 	sub	r12,r10,-8
80007f82:	8d 0c       	st.w	r6[0x0],r12
80007f84:	f4 e2 00 00 	ld.d	r2,r10[0]
80007f88:	f0 e3 00 00 	st.d	r8[0],r2
80007f8c:	c1 08       	rjmp	80007fac <get_arg+0x2f4>
80007f8e:	6c 0a       	ld.w	r10,r6[0x0]
80007f90:	f4 cc ff f8 	sub	r12,r10,-8
80007f94:	8d 0c       	st.w	r6[0x0],r12
80007f96:	f4 e2 00 00 	ld.d	r2,r10[0]
80007f9a:	f0 e3 00 00 	st.d	r8[0],r2
80007f9e:	c0 78       	rjmp	80007fac <get_arg+0x2f4>
80007fa0:	6c 0a       	ld.w	r10,r6[0x0]
80007fa2:	f4 cc ff fc 	sub	r12,r10,-4
80007fa6:	8d 0c       	st.w	r6[0x0],r12
80007fa8:	74 0a       	ld.w	r10,r10[0x0]
80007faa:	91 0a       	st.w	r8[0x0],r10
80007fac:	2f f5       	sub	r5,-1
80007fae:	2f 88       	sub	r8,-8
80007fb0:	2f c1       	sub	r1,-4
80007fb2:	12 35       	cp.w	r5,r9
80007fb4:	fe 9a ff d6 	brle	80007f60 <get_arg+0x2a8>
80007fb8:	1c 93       	mov	r3,lr
80007fba:	40 52       	lddsp	r2,sp[0x14]
80007fbc:	40 6e       	lddsp	lr,sp[0x18]
80007fbe:	85 05       	st.w	r2[0x0],r5
80007fc0:	9d 0b       	st.w	lr[0x0],r11
80007fc2:	40 4b       	lddsp	r11,sp[0x10]
80007fc4:	e6 0b 00 3c 	add	r12,r3,r11<<0x3
80007fc8:	2f 8d       	sub	sp,-32
80007fca:	d8 32       	popm	r0-r7,pc

80007fcc <__sprint_r>:
80007fcc:	d4 21       	pushm	r4-r7,lr
80007fce:	14 97       	mov	r7,r10
80007fd0:	74 28       	ld.w	r8,r10[0x8]
80007fd2:	58 08       	cp.w	r8,0
80007fd4:	c0 41       	brne	80007fdc <__sprint_r+0x10>
80007fd6:	95 18       	st.w	r10[0x4],r8
80007fd8:	10 9c       	mov	r12,r8
80007fda:	d8 22       	popm	r4-r7,pc
80007fdc:	e0 a0 18 ba 	rcall	8000b150 <__sfvwrite_r>
80007fe0:	30 08       	mov	r8,0
80007fe2:	8f 18       	st.w	r7[0x4],r8
80007fe4:	8f 28       	st.w	r7[0x8],r8
80007fe6:	d8 22       	popm	r4-r7,pc

80007fe8 <_vfprintf_r>:
80007fe8:	d4 31       	pushm	r0-r7,lr
80007fea:	fa cd 06 bc 	sub	sp,sp,1724
80007fee:	51 09       	stdsp	sp[0x40],r9
80007ff0:	16 91       	mov	r1,r11
80007ff2:	14 97       	mov	r7,r10
80007ff4:	18 95       	mov	r5,r12
80007ff6:	e0 a0 1a 1d 	rcall	8000b430 <_localeconv_r>
80007ffa:	78 0c       	ld.w	r12,r12[0x0]
80007ffc:	50 cc       	stdsp	sp[0x30],r12
80007ffe:	58 05       	cp.w	r5,0
80008000:	c0 70       	breq	8000800e <_vfprintf_r+0x26>
80008002:	6a 68       	ld.w	r8,r5[0x18]
80008004:	58 08       	cp.w	r8,0
80008006:	c0 41       	brne	8000800e <_vfprintf_r+0x26>
80008008:	0a 9c       	mov	r12,r5
8000800a:	e0 a0 17 43 	rcall	8000ae90 <__sinit>
8000800e:	fe c8 9b fe 	sub	r8,pc,-25602
80008012:	10 31       	cp.w	r1,r8
80008014:	c0 31       	brne	8000801a <_vfprintf_r+0x32>
80008016:	6a 01       	ld.w	r1,r5[0x0]
80008018:	c0 c8       	rjmp	80008030 <_vfprintf_r+0x48>
8000801a:	fe c8 9b ea 	sub	r8,pc,-25622
8000801e:	10 31       	cp.w	r1,r8
80008020:	c0 31       	brne	80008026 <_vfprintf_r+0x3e>
80008022:	6a 11       	ld.w	r1,r5[0x4]
80008024:	c0 68       	rjmp	80008030 <_vfprintf_r+0x48>
80008026:	fe c8 9b d6 	sub	r8,pc,-25642
8000802a:	10 31       	cp.w	r1,r8
8000802c:	eb f1 00 02 	ld.weq	r1,r5[0x8]
80008030:	82 68       	ld.sh	r8,r1[0xc]
80008032:	ed b8 00 03 	bld	r8,0x3
80008036:	c0 41       	brne	8000803e <_vfprintf_r+0x56>
80008038:	62 48       	ld.w	r8,r1[0x10]
8000803a:	58 08       	cp.w	r8,0
8000803c:	c0 71       	brne	8000804a <_vfprintf_r+0x62>
8000803e:	02 9b       	mov	r11,r1
80008040:	0a 9c       	mov	r12,r5
80008042:	e0 a0 0f 5d 	rcall	80009efc <__swsetup_r>
80008046:	e0 81 0f 54 	brne	80009eee <_vfprintf_r+0x1f06>
8000804a:	82 68       	ld.sh	r8,r1[0xc]
8000804c:	10 99       	mov	r9,r8
8000804e:	e2 19 00 1a 	andl	r9,0x1a,COH
80008052:	58 a9       	cp.w	r9,10
80008054:	c3 c1       	brne	800080cc <_vfprintf_r+0xe4>
80008056:	82 79       	ld.sh	r9,r1[0xe]
80008058:	30 0a       	mov	r10,0
8000805a:	f4 09 19 00 	cp.h	r9,r10
8000805e:	c3 75       	brlt	800080cc <_vfprintf_r+0xe4>
80008060:	a1 d8       	cbr	r8,0x1
80008062:	fb 58 05 d0 	st.h	sp[1488],r8
80008066:	62 88       	ld.w	r8,r1[0x20]
80008068:	fb 48 05 e4 	st.w	sp[1508],r8
8000806c:	62 a8       	ld.w	r8,r1[0x28]
8000806e:	fb 48 05 ec 	st.w	sp[1516],r8
80008072:	fa c8 ff bc 	sub	r8,sp,-68
80008076:	fb 48 05 d4 	st.w	sp[1492],r8
8000807a:	fb 48 05 c4 	st.w	sp[1476],r8
8000807e:	e0 68 04 00 	mov	r8,1024
80008082:	fb 48 05 d8 	st.w	sp[1496],r8
80008086:	fb 48 05 cc 	st.w	sp[1484],r8
8000808a:	30 08       	mov	r8,0
8000808c:	fb 59 05 d2 	st.h	sp[1490],r9
80008090:	0e 9a       	mov	r10,r7
80008092:	41 09       	lddsp	r9,sp[0x40]
80008094:	fa c7 fa 3c 	sub	r7,sp,-1476
80008098:	fb 48 05 dc 	st.w	sp[1500],r8
8000809c:	0a 9c       	mov	r12,r5
8000809e:	0e 9b       	mov	r11,r7
800080a0:	ca 4f       	rcall	80007fe8 <_vfprintf_r>
800080a2:	50 bc       	stdsp	sp[0x2c],r12
800080a4:	c0 95       	brlt	800080b6 <_vfprintf_r+0xce>
800080a6:	0e 9b       	mov	r11,r7
800080a8:	0a 9c       	mov	r12,r5
800080aa:	e0 a0 16 1b 	rcall	8000ace0 <_fflush_r>
800080ae:	40 be       	lddsp	lr,sp[0x2c]
800080b0:	f9 be 01 ff 	movne	lr,-1
800080b4:	50 be       	stdsp	sp[0x2c],lr
800080b6:	fb 08 05 d0 	ld.sh	r8,sp[1488]
800080ba:	ed b8 00 06 	bld	r8,0x6
800080be:	e0 81 0f 1a 	brne	80009ef2 <_vfprintf_r+0x1f0a>
800080c2:	82 68       	ld.sh	r8,r1[0xc]
800080c4:	a7 a8       	sbr	r8,0x6
800080c6:	a2 68       	st.h	r1[0xc],r8
800080c8:	e0 8f 0f 15 	bral	80009ef2 <_vfprintf_r+0x1f0a>
800080cc:	30 08       	mov	r8,0
800080ce:	fb 48 06 b4 	st.w	sp[1716],r8
800080d2:	fb 48 06 90 	st.w	sp[1680],r8
800080d6:	fb 48 06 8c 	st.w	sp[1676],r8
800080da:	fb 48 06 b0 	st.w	sp[1712],r8
800080de:	30 08       	mov	r8,0
800080e0:	30 09       	mov	r9,0
800080e2:	50 a7       	stdsp	sp[0x28],r7
800080e4:	50 78       	stdsp	sp[0x1c],r8
800080e6:	fa c3 f9 e0 	sub	r3,sp,-1568
800080ea:	3f f8       	mov	r8,-1
800080ec:	50 59       	stdsp	sp[0x14],r9
800080ee:	fb 43 06 88 	st.w	sp[1672],r3
800080f2:	fb 48 05 44 	st.w	sp[1348],r8
800080f6:	12 9c       	mov	r12,r9
800080f8:	50 69       	stdsp	sp[0x18],r9
800080fa:	50 d9       	stdsp	sp[0x34],r9
800080fc:	50 e9       	stdsp	sp[0x38],r9
800080fe:	50 b9       	stdsp	sp[0x2c],r9
80008100:	12 97       	mov	r7,r9
80008102:	0a 94       	mov	r4,r5
80008104:	40 a2       	lddsp	r2,sp[0x28]
80008106:	32 5a       	mov	r10,37
80008108:	30 08       	mov	r8,0
8000810a:	c0 28       	rjmp	8000810e <_vfprintf_r+0x126>
8000810c:	2f f2       	sub	r2,-1
8000810e:	05 89       	ld.ub	r9,r2[0x0]
80008110:	f0 09 18 00 	cp.b	r9,r8
80008114:	5f 1b       	srne	r11
80008116:	f4 09 18 00 	cp.b	r9,r10
8000811a:	5f 19       	srne	r9
8000811c:	f3 eb 00 0b 	and	r11,r9,r11
80008120:	f0 0b 18 00 	cp.b	r11,r8
80008124:	cf 41       	brne	8000810c <_vfprintf_r+0x124>
80008126:	40 ab       	lddsp	r11,sp[0x28]
80008128:	e4 0b 01 06 	sub	r6,r2,r11
8000812c:	c1 e0       	breq	80008168 <_vfprintf_r+0x180>
8000812e:	fa f8 06 90 	ld.w	r8,sp[1680]
80008132:	0c 08       	add	r8,r6
80008134:	87 0b       	st.w	r3[0x0],r11
80008136:	fb 48 06 90 	st.w	sp[1680],r8
8000813a:	87 16       	st.w	r3[0x4],r6
8000813c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008140:	2f f8       	sub	r8,-1
80008142:	fb 48 06 8c 	st.w	sp[1676],r8
80008146:	58 78       	cp.w	r8,7
80008148:	e0 89 00 04 	brgt	80008150 <_vfprintf_r+0x168>
8000814c:	2f 83       	sub	r3,-8
8000814e:	c0 a8       	rjmp	80008162 <_vfprintf_r+0x17a>
80008150:	fa ca f9 78 	sub	r10,sp,-1672
80008154:	02 9b       	mov	r11,r1
80008156:	08 9c       	mov	r12,r4
80008158:	c3 af       	rcall	80007fcc <__sprint_r>
8000815a:	e0 81 0e c6 	brne	80009ee6 <_vfprintf_r+0x1efe>
8000815e:	fa c3 f9 e0 	sub	r3,sp,-1568
80008162:	40 ba       	lddsp	r10,sp[0x2c]
80008164:	0c 0a       	add	r10,r6
80008166:	50 ba       	stdsp	sp[0x2c],r10
80008168:	05 89       	ld.ub	r9,r2[0x0]
8000816a:	30 08       	mov	r8,0
8000816c:	f0 09 18 00 	cp.b	r9,r8
80008170:	e0 80 0e aa 	breq	80009ec4 <_vfprintf_r+0x1edc>
80008174:	30 09       	mov	r9,0
80008176:	fb 68 06 bb 	st.b	sp[1723],r8
8000817a:	0e 96       	mov	r6,r7
8000817c:	e4 c8 ff ff 	sub	r8,r2,-1
80008180:	3f fe       	mov	lr,-1
80008182:	50 93       	stdsp	sp[0x24],r3
80008184:	50 41       	stdsp	sp[0x10],r1
80008186:	0e 93       	mov	r3,r7
80008188:	04 91       	mov	r1,r2
8000818a:	50 89       	stdsp	sp[0x20],r9
8000818c:	50 a8       	stdsp	sp[0x28],r8
8000818e:	50 2e       	stdsp	sp[0x8],lr
80008190:	50 39       	stdsp	sp[0xc],r9
80008192:	12 95       	mov	r5,r9
80008194:	12 90       	mov	r0,r9
80008196:	10 97       	mov	r7,r8
80008198:	08 92       	mov	r2,r4
8000819a:	c0 78       	rjmp	800081a8 <_vfprintf_r+0x1c0>
8000819c:	3f fc       	mov	r12,-1
8000819e:	08 97       	mov	r7,r4
800081a0:	50 2c       	stdsp	sp[0x8],r12
800081a2:	c0 38       	rjmp	800081a8 <_vfprintf_r+0x1c0>
800081a4:	30 0b       	mov	r11,0
800081a6:	50 3b       	stdsp	sp[0xc],r11
800081a8:	0f 38       	ld.ub	r8,r7++
800081aa:	c0 28       	rjmp	800081ae <_vfprintf_r+0x1c6>
800081ac:	12 90       	mov	r0,r9
800081ae:	f0 c9 00 20 	sub	r9,r8,32
800081b2:	e0 49 00 58 	cp.w	r9,88
800081b6:	e0 8b 0a 30 	brhi	80009616 <_vfprintf_r+0x162e>
800081ba:	fe ca a1 52 	sub	r10,pc,-24238
800081be:	f4 09 03 2f 	ld.w	pc,r10[r9<<0x2]
800081c2:	50 a7       	stdsp	sp[0x28],r7
800081c4:	50 80       	stdsp	sp[0x20],r0
800081c6:	0c 97       	mov	r7,r6
800081c8:	04 94       	mov	r4,r2
800081ca:	06 96       	mov	r6,r3
800081cc:	02 92       	mov	r2,r1
800081ce:	fe c9 9f 2a 	sub	r9,pc,-24790
800081d2:	40 93       	lddsp	r3,sp[0x24]
800081d4:	10 90       	mov	r0,r8
800081d6:	40 41       	lddsp	r1,sp[0x10]
800081d8:	50 d9       	stdsp	sp[0x34],r9
800081da:	e0 8f 08 8e 	bral	800092f6 <_vfprintf_r+0x130e>
800081de:	30 08       	mov	r8,0
800081e0:	fb 39 06 bb 	ld.ub	r9,sp[1723]
800081e4:	f0 09 18 00 	cp.b	r9,r8
800081e8:	ce 01       	brne	800081a8 <_vfprintf_r+0x1c0>
800081ea:	32 08       	mov	r8,32
800081ec:	c6 e8       	rjmp	800082c8 <_vfprintf_r+0x2e0>
800081ee:	a1 a5       	sbr	r5,0x0
800081f0:	cd cb       	rjmp	800081a8 <_vfprintf_r+0x1c0>
800081f2:	0f 89       	ld.ub	r9,r7[0x0]
800081f4:	f2 c8 00 30 	sub	r8,r9,48
800081f8:	58 98       	cp.w	r8,9
800081fa:	e0 8b 00 1d 	brhi	80008234 <_vfprintf_r+0x24c>
800081fe:	ee c8 ff ff 	sub	r8,r7,-1
80008202:	30 0b       	mov	r11,0
80008204:	23 09       	sub	r9,48
80008206:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
8000820a:	f2 0b 00 1b 	add	r11,r9,r11<<0x1
8000820e:	11 39       	ld.ub	r9,r8++
80008210:	f2 ca 00 30 	sub	r10,r9,48
80008214:	58 9a       	cp.w	r10,9
80008216:	fe 98 ff f7 	brls	80008204 <_vfprintf_r+0x21c>
8000821a:	e0 49 00 24 	cp.w	r9,36
8000821e:	cc 31       	brne	800081a4 <_vfprintf_r+0x1bc>
80008220:	e0 4b 00 20 	cp.w	r11,32
80008224:	e0 89 0e 60 	brgt	80009ee4 <_vfprintf_r+0x1efc>
80008228:	20 1b       	sub	r11,1
8000822a:	fa f9 06 b4 	ld.w	r9,sp[1716]
8000822e:	12 3b       	cp.w	r11,r9
80008230:	c0 95       	brlt	80008242 <_vfprintf_r+0x25a>
80008232:	c1 08       	rjmp	80008252 <_vfprintf_r+0x26a>
80008234:	fa f9 06 b4 	ld.w	r9,sp[1716]
80008238:	ec ca ff ff 	sub	r10,r6,-1
8000823c:	12 36       	cp.w	r6,r9
8000823e:	c1 f5       	brlt	8000827c <_vfprintf_r+0x294>
80008240:	c2 68       	rjmp	8000828c <_vfprintf_r+0x2a4>
80008242:	fa ce f9 44 	sub	lr,sp,-1724
80008246:	10 97       	mov	r7,r8
80008248:	fc 0b 00 3b 	add	r11,lr,r11<<0x3
8000824c:	f6 f0 fd 88 	ld.w	r0,r11[-632]
80008250:	c3 58       	rjmp	800082ba <_vfprintf_r+0x2d2>
80008252:	10 97       	mov	r7,r8
80008254:	fa c8 f9 50 	sub	r8,sp,-1712
80008258:	1a d8       	st.w	--sp,r8
8000825a:	fa c8 fa b8 	sub	r8,sp,-1352
8000825e:	1a d8       	st.w	--sp,r8
80008260:	fa c8 fb b4 	sub	r8,sp,-1100
80008264:	02 9a       	mov	r10,r1
80008266:	1a d8       	st.w	--sp,r8
80008268:	04 9c       	mov	r12,r2
8000826a:	fa c8 f9 40 	sub	r8,sp,-1728
8000826e:	fa c9 ff b4 	sub	r9,sp,-76
80008272:	fe b0 fd 23 	rcall	80007cb8 <get_arg>
80008276:	2f dd       	sub	sp,-12
80008278:	78 00       	ld.w	r0,r12[0x0]
8000827a:	c2 08       	rjmp	800082ba <_vfprintf_r+0x2d2>
8000827c:	fa cc f9 44 	sub	r12,sp,-1724
80008280:	14 96       	mov	r6,r10
80008282:	f8 03 00 38 	add	r8,r12,r3<<0x3
80008286:	f0 f0 fd 88 	ld.w	r0,r8[-632]
8000828a:	c1 88       	rjmp	800082ba <_vfprintf_r+0x2d2>
8000828c:	41 08       	lddsp	r8,sp[0x40]
8000828e:	59 f9       	cp.w	r9,31
80008290:	e0 89 00 11 	brgt	800082b2 <_vfprintf_r+0x2ca>
80008294:	f0 cb ff fc 	sub	r11,r8,-4
80008298:	51 0b       	stdsp	sp[0x40],r11
8000829a:	70 00       	ld.w	r0,r8[0x0]
8000829c:	fa cb f9 44 	sub	r11,sp,-1724
800082a0:	f6 09 00 38 	add	r8,r11,r9<<0x3
800082a4:	f1 40 fd 88 	st.w	r8[-632],r0
800082a8:	2f f9       	sub	r9,-1
800082aa:	14 96       	mov	r6,r10
800082ac:	fb 49 06 b4 	st.w	sp[1716],r9
800082b0:	c0 58       	rjmp	800082ba <_vfprintf_r+0x2d2>
800082b2:	70 00       	ld.w	r0,r8[0x0]
800082b4:	14 96       	mov	r6,r10
800082b6:	2f c8       	sub	r8,-4
800082b8:	51 08       	stdsp	sp[0x40],r8
800082ba:	58 00       	cp.w	r0,0
800082bc:	fe 94 ff 76 	brge	800081a8 <_vfprintf_r+0x1c0>
800082c0:	5c 30       	neg	r0
800082c2:	a3 a5       	sbr	r5,0x2
800082c4:	c7 2b       	rjmp	800081a8 <_vfprintf_r+0x1c0>
800082c6:	32 b8       	mov	r8,43
800082c8:	fb 68 06 bb 	st.b	sp[1723],r8
800082cc:	c6 eb       	rjmp	800081a8 <_vfprintf_r+0x1c0>
800082ce:	0f 38       	ld.ub	r8,r7++
800082d0:	e0 48 00 2a 	cp.w	r8,42
800082d4:	c0 30       	breq	800082da <_vfprintf_r+0x2f2>
800082d6:	30 09       	mov	r9,0
800082d8:	c7 98       	rjmp	800083ca <_vfprintf_r+0x3e2>
800082da:	0f 88       	ld.ub	r8,r7[0x0]
800082dc:	f0 c9 00 30 	sub	r9,r8,48
800082e0:	58 99       	cp.w	r9,9
800082e2:	e0 8b 00 1f 	brhi	80008320 <_vfprintf_r+0x338>
800082e6:	ee c4 ff ff 	sub	r4,r7,-1
800082ea:	30 0b       	mov	r11,0
800082ec:	23 08       	sub	r8,48
800082ee:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
800082f2:	f0 0b 00 1b 	add	r11,r8,r11<<0x1
800082f6:	09 38       	ld.ub	r8,r4++
800082f8:	f0 c9 00 30 	sub	r9,r8,48
800082fc:	58 99       	cp.w	r9,9
800082fe:	fe 98 ff f7 	brls	800082ec <_vfprintf_r+0x304>
80008302:	e0 48 00 24 	cp.w	r8,36
80008306:	fe 91 ff 4f 	brne	800081a4 <_vfprintf_r+0x1bc>
8000830a:	e0 4b 00 20 	cp.w	r11,32
8000830e:	e0 89 0d eb 	brgt	80009ee4 <_vfprintf_r+0x1efc>
80008312:	20 1b       	sub	r11,1
80008314:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008318:	10 3b       	cp.w	r11,r8
8000831a:	c0 a5       	brlt	8000832e <_vfprintf_r+0x346>
8000831c:	c1 18       	rjmp	8000833e <_vfprintf_r+0x356>
8000831e:	d7 03       	nop
80008320:	fa fa 06 b4 	ld.w	r10,sp[1716]
80008324:	ec c9 ff ff 	sub	r9,r6,-1
80008328:	14 36       	cp.w	r6,r10
8000832a:	c1 f5       	brlt	80008368 <_vfprintf_r+0x380>
8000832c:	c2 88       	rjmp	8000837c <_vfprintf_r+0x394>
8000832e:	fa ca f9 44 	sub	r10,sp,-1724
80008332:	f4 0b 00 3b 	add	r11,r10,r11<<0x3
80008336:	f6 fb fd 88 	ld.w	r11,r11[-632]
8000833a:	50 2b       	stdsp	sp[0x8],r11
8000833c:	c3 c8       	rjmp	800083b4 <_vfprintf_r+0x3cc>
8000833e:	fa c8 f9 50 	sub	r8,sp,-1712
80008342:	1a d8       	st.w	--sp,r8
80008344:	fa c8 fa b8 	sub	r8,sp,-1352
80008348:	1a d8       	st.w	--sp,r8
8000834a:	fa c8 fb b4 	sub	r8,sp,-1100
8000834e:	02 9a       	mov	r10,r1
80008350:	1a d8       	st.w	--sp,r8
80008352:	04 9c       	mov	r12,r2
80008354:	fa c8 f9 40 	sub	r8,sp,-1728
80008358:	fa c9 ff b4 	sub	r9,sp,-76
8000835c:	fe b0 fc ae 	rcall	80007cb8 <get_arg>
80008360:	2f dd       	sub	sp,-12
80008362:	78 0c       	ld.w	r12,r12[0x0]
80008364:	50 2c       	stdsp	sp[0x8],r12
80008366:	c2 78       	rjmp	800083b4 <_vfprintf_r+0x3cc>
80008368:	12 96       	mov	r6,r9
8000836a:	0e 94       	mov	r4,r7
8000836c:	fa c9 f9 44 	sub	r9,sp,-1724
80008370:	f2 03 00 38 	add	r8,r9,r3<<0x3
80008374:	f0 f8 fd 88 	ld.w	r8,r8[-632]
80008378:	50 28       	stdsp	sp[0x8],r8
8000837a:	c1 d8       	rjmp	800083b4 <_vfprintf_r+0x3cc>
8000837c:	41 08       	lddsp	r8,sp[0x40]
8000837e:	59 fa       	cp.w	r10,31
80008380:	e0 89 00 14 	brgt	800083a8 <_vfprintf_r+0x3c0>
80008384:	f0 cb ff fc 	sub	r11,r8,-4
80008388:	70 08       	ld.w	r8,r8[0x0]
8000838a:	51 0b       	stdsp	sp[0x40],r11
8000838c:	50 28       	stdsp	sp[0x8],r8
8000838e:	fa c6 f9 44 	sub	r6,sp,-1724
80008392:	40 2e       	lddsp	lr,sp[0x8]
80008394:	ec 0a 00 38 	add	r8,r6,r10<<0x3
80008398:	f1 4e fd 88 	st.w	r8[-632],lr
8000839c:	2f fa       	sub	r10,-1
8000839e:	0e 94       	mov	r4,r7
800083a0:	fb 4a 06 b4 	st.w	sp[1716],r10
800083a4:	12 96       	mov	r6,r9
800083a6:	c0 78       	rjmp	800083b4 <_vfprintf_r+0x3cc>
800083a8:	70 0c       	ld.w	r12,r8[0x0]
800083aa:	0e 94       	mov	r4,r7
800083ac:	2f c8       	sub	r8,-4
800083ae:	50 2c       	stdsp	sp[0x8],r12
800083b0:	12 96       	mov	r6,r9
800083b2:	51 08       	stdsp	sp[0x40],r8
800083b4:	40 2b       	lddsp	r11,sp[0x8]
800083b6:	58 0b       	cp.w	r11,0
800083b8:	fe 95 fe f2 	brlt	8000819c <_vfprintf_r+0x1b4>
800083bc:	08 97       	mov	r7,r4
800083be:	cf 5a       	rjmp	800081a8 <_vfprintf_r+0x1c0>
800083c0:	f2 09 00 29 	add	r9,r9,r9<<0x2
800083c4:	0f 38       	ld.ub	r8,r7++
800083c6:	f4 09 00 19 	add	r9,r10,r9<<0x1
800083ca:	f0 ca 00 30 	sub	r10,r8,48
800083ce:	58 9a       	cp.w	r10,9
800083d0:	fe 98 ff f8 	brls	800083c0 <_vfprintf_r+0x3d8>
800083d4:	3f fa       	mov	r10,-1
800083d6:	f2 0a 0c 49 	max	r9,r9,r10
800083da:	50 29       	stdsp	sp[0x8],r9
800083dc:	ce 9a       	rjmp	800081ae <_vfprintf_r+0x1c6>
800083de:	a7 b5       	sbr	r5,0x7
800083e0:	ce 4a       	rjmp	800081a8 <_vfprintf_r+0x1c0>
800083e2:	30 09       	mov	r9,0
800083e4:	23 08       	sub	r8,48
800083e6:	f2 09 00 29 	add	r9,r9,r9<<0x2
800083ea:	f0 09 00 19 	add	r9,r8,r9<<0x1
800083ee:	0f 38       	ld.ub	r8,r7++
800083f0:	f0 ca 00 30 	sub	r10,r8,48
800083f4:	58 9a       	cp.w	r10,9
800083f6:	fe 98 ff f7 	brls	800083e4 <_vfprintf_r+0x3fc>
800083fa:	e0 48 00 24 	cp.w	r8,36
800083fe:	fe 91 fe d7 	brne	800081ac <_vfprintf_r+0x1c4>
80008402:	e0 49 00 20 	cp.w	r9,32
80008406:	e0 89 0d 6f 	brgt	80009ee4 <_vfprintf_r+0x1efc>
8000840a:	f2 c3 00 01 	sub	r3,r9,1
8000840e:	30 19       	mov	r9,1
80008410:	50 39       	stdsp	sp[0xc],r9
80008412:	cc ba       	rjmp	800081a8 <_vfprintf_r+0x1c0>
80008414:	a3 b5       	sbr	r5,0x3
80008416:	cc 9a       	rjmp	800081a8 <_vfprintf_r+0x1c0>
80008418:	a7 a5       	sbr	r5,0x6
8000841a:	cc 7a       	rjmp	800081a8 <_vfprintf_r+0x1c0>
8000841c:	0a 98       	mov	r8,r5
8000841e:	a5 b5       	sbr	r5,0x5
80008420:	a5 a8       	sbr	r8,0x4
80008422:	0f 89       	ld.ub	r9,r7[0x0]
80008424:	36 ce       	mov	lr,108
80008426:	fc 09 18 00 	cp.b	r9,lr
8000842a:	f7 b7 00 ff 	subeq	r7,-1
8000842e:	f0 05 17 10 	movne	r5,r8
80008432:	cb ba       	rjmp	800081a8 <_vfprintf_r+0x1c0>
80008434:	a5 b5       	sbr	r5,0x5
80008436:	cb 9a       	rjmp	800081a8 <_vfprintf_r+0x1c0>
80008438:	50 a7       	stdsp	sp[0x28],r7
8000843a:	50 80       	stdsp	sp[0x20],r0
8000843c:	0c 97       	mov	r7,r6
8000843e:	10 90       	mov	r0,r8
80008440:	06 96       	mov	r6,r3
80008442:	04 94       	mov	r4,r2
80008444:	40 93       	lddsp	r3,sp[0x24]
80008446:	02 92       	mov	r2,r1
80008448:	0e 99       	mov	r9,r7
8000844a:	40 41       	lddsp	r1,sp[0x10]
8000844c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008450:	40 3c       	lddsp	r12,sp[0xc]
80008452:	58 0c       	cp.w	r12,0
80008454:	c1 d0       	breq	8000848e <_vfprintf_r+0x4a6>
80008456:	10 36       	cp.w	r6,r8
80008458:	c0 64       	brge	80008464 <_vfprintf_r+0x47c>
8000845a:	fa cb f9 44 	sub	r11,sp,-1724
8000845e:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008462:	c1 d8       	rjmp	8000849c <_vfprintf_r+0x4b4>
80008464:	fa c8 f9 50 	sub	r8,sp,-1712
80008468:	1a d8       	st.w	--sp,r8
8000846a:	fa c8 fa b8 	sub	r8,sp,-1352
8000846e:	1a d8       	st.w	--sp,r8
80008470:	fa c8 fb b4 	sub	r8,sp,-1100
80008474:	1a d8       	st.w	--sp,r8
80008476:	fa c8 f9 40 	sub	r8,sp,-1728
8000847a:	fa c9 ff b4 	sub	r9,sp,-76
8000847e:	04 9a       	mov	r10,r2
80008480:	0c 9b       	mov	r11,r6
80008482:	08 9c       	mov	r12,r4
80008484:	fe b0 fc 1a 	rcall	80007cb8 <get_arg>
80008488:	2f dd       	sub	sp,-12
8000848a:	19 b8       	ld.ub	r8,r12[0x3]
8000848c:	c2 28       	rjmp	800084d0 <_vfprintf_r+0x4e8>
8000848e:	2f f7       	sub	r7,-1
80008490:	10 39       	cp.w	r9,r8
80008492:	c0 84       	brge	800084a2 <_vfprintf_r+0x4ba>
80008494:	fa ca f9 44 	sub	r10,sp,-1724
80008498:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000849c:	ed 38 fd 8b 	ld.ub	r8,r6[-629]
800084a0:	c1 88       	rjmp	800084d0 <_vfprintf_r+0x4e8>
800084a2:	41 09       	lddsp	r9,sp[0x40]
800084a4:	59 f8       	cp.w	r8,31
800084a6:	e0 89 00 12 	brgt	800084ca <_vfprintf_r+0x4e2>
800084aa:	f2 ca ff fc 	sub	r10,r9,-4
800084ae:	51 0a       	stdsp	sp[0x40],r10
800084b0:	72 09       	ld.w	r9,r9[0x0]
800084b2:	fa c6 f9 44 	sub	r6,sp,-1724
800084b6:	ec 08 00 3a 	add	r10,r6,r8<<0x3
800084ba:	2f f8       	sub	r8,-1
800084bc:	f5 49 fd 88 	st.w	r10[-632],r9
800084c0:	fb 48 06 b4 	st.w	sp[1716],r8
800084c4:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
800084c8:	c0 48       	rjmp	800084d0 <_vfprintf_r+0x4e8>
800084ca:	13 b8       	ld.ub	r8,r9[0x3]
800084cc:	2f c9       	sub	r9,-4
800084ce:	51 09       	stdsp	sp[0x40],r9
800084d0:	fb 68 06 60 	st.b	sp[1632],r8
800084d4:	30 0e       	mov	lr,0
800084d6:	30 08       	mov	r8,0
800084d8:	30 12       	mov	r2,1
800084da:	fb 68 06 bb 	st.b	sp[1723],r8
800084de:	50 2e       	stdsp	sp[0x8],lr
800084e0:	e0 8f 08 ad 	bral	8000963a <_vfprintf_r+0x1652>
800084e4:	50 a7       	stdsp	sp[0x28],r7
800084e6:	50 80       	stdsp	sp[0x20],r0
800084e8:	0c 97       	mov	r7,r6
800084ea:	04 94       	mov	r4,r2
800084ec:	06 96       	mov	r6,r3
800084ee:	02 92       	mov	r2,r1
800084f0:	40 93       	lddsp	r3,sp[0x24]
800084f2:	10 90       	mov	r0,r8
800084f4:	40 41       	lddsp	r1,sp[0x10]
800084f6:	a5 a5       	sbr	r5,0x4
800084f8:	c0 a8       	rjmp	8000850c <_vfprintf_r+0x524>
800084fa:	50 a7       	stdsp	sp[0x28],r7
800084fc:	50 80       	stdsp	sp[0x20],r0
800084fe:	0c 97       	mov	r7,r6
80008500:	04 94       	mov	r4,r2
80008502:	06 96       	mov	r6,r3
80008504:	02 92       	mov	r2,r1
80008506:	40 93       	lddsp	r3,sp[0x24]
80008508:	10 90       	mov	r0,r8
8000850a:	40 41       	lddsp	r1,sp[0x10]
8000850c:	ed b5 00 05 	bld	r5,0x5
80008510:	c5 11       	brne	800085b2 <_vfprintf_r+0x5ca>
80008512:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008516:	40 3c       	lddsp	r12,sp[0xc]
80008518:	58 0c       	cp.w	r12,0
8000851a:	c1 e0       	breq	80008556 <_vfprintf_r+0x56e>
8000851c:	10 36       	cp.w	r6,r8
8000851e:	c0 64       	brge	8000852a <_vfprintf_r+0x542>
80008520:	fa cb f9 44 	sub	r11,sp,-1724
80008524:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008528:	c2 08       	rjmp	80008568 <_vfprintf_r+0x580>
8000852a:	fa c8 f9 50 	sub	r8,sp,-1712
8000852e:	1a d8       	st.w	--sp,r8
80008530:	fa c8 fa b8 	sub	r8,sp,-1352
80008534:	0c 9b       	mov	r11,r6
80008536:	1a d8       	st.w	--sp,r8
80008538:	fa c8 fb b4 	sub	r8,sp,-1100
8000853c:	1a d8       	st.w	--sp,r8
8000853e:	fa c9 ff b4 	sub	r9,sp,-76
80008542:	fa c8 f9 40 	sub	r8,sp,-1728
80008546:	04 9a       	mov	r10,r2
80008548:	08 9c       	mov	r12,r4
8000854a:	fe b0 fb b7 	rcall	80007cb8 <get_arg>
8000854e:	2f dd       	sub	sp,-12
80008550:	78 1b       	ld.w	r11,r12[0x4]
80008552:	78 09       	ld.w	r9,r12[0x0]
80008554:	c2 b8       	rjmp	800085aa <_vfprintf_r+0x5c2>
80008556:	ee ca ff ff 	sub	r10,r7,-1
8000855a:	10 37       	cp.w	r7,r8
8000855c:	c0 b4       	brge	80008572 <_vfprintf_r+0x58a>
8000855e:	fa c9 f9 44 	sub	r9,sp,-1724
80008562:	14 97       	mov	r7,r10
80008564:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008568:	ec fb fd 8c 	ld.w	r11,r6[-628]
8000856c:	ec f9 fd 88 	ld.w	r9,r6[-632]
80008570:	c1 d8       	rjmp	800085aa <_vfprintf_r+0x5c2>
80008572:	41 09       	lddsp	r9,sp[0x40]
80008574:	59 f8       	cp.w	r8,31
80008576:	e0 89 00 14 	brgt	8000859e <_vfprintf_r+0x5b6>
8000857a:	f2 cb ff f8 	sub	r11,r9,-8
8000857e:	51 0b       	stdsp	sp[0x40],r11
80008580:	fa c6 f9 44 	sub	r6,sp,-1724
80008584:	72 1b       	ld.w	r11,r9[0x4]
80008586:	ec 08 00 3c 	add	r12,r6,r8<<0x3
8000858a:	72 09       	ld.w	r9,r9[0x0]
8000858c:	f9 4b fd 8c 	st.w	r12[-628],r11
80008590:	f9 49 fd 88 	st.w	r12[-632],r9
80008594:	2f f8       	sub	r8,-1
80008596:	14 97       	mov	r7,r10
80008598:	fb 48 06 b4 	st.w	sp[1716],r8
8000859c:	c0 78       	rjmp	800085aa <_vfprintf_r+0x5c2>
8000859e:	f2 c8 ff f8 	sub	r8,r9,-8
800085a2:	72 1b       	ld.w	r11,r9[0x4]
800085a4:	14 97       	mov	r7,r10
800085a6:	51 08       	stdsp	sp[0x40],r8
800085a8:	72 09       	ld.w	r9,r9[0x0]
800085aa:	16 98       	mov	r8,r11
800085ac:	fa e9 00 00 	st.d	sp[0],r8
800085b0:	ca e8       	rjmp	8000870c <_vfprintf_r+0x724>
800085b2:	ed b5 00 04 	bld	r5,0x4
800085b6:	c1 71       	brne	800085e4 <_vfprintf_r+0x5fc>
800085b8:	fa f8 06 b4 	ld.w	r8,sp[1716]
800085bc:	40 3e       	lddsp	lr,sp[0xc]
800085be:	58 0e       	cp.w	lr,0
800085c0:	c0 80       	breq	800085d0 <_vfprintf_r+0x5e8>
800085c2:	10 36       	cp.w	r6,r8
800085c4:	c6 94       	brge	80008696 <_vfprintf_r+0x6ae>
800085c6:	fa cc f9 44 	sub	r12,sp,-1724
800085ca:	f8 06 00 36 	add	r6,r12,r6<<0x3
800085ce:	c8 28       	rjmp	800086d2 <_vfprintf_r+0x6ea>
800085d0:	ee ca ff ff 	sub	r10,r7,-1
800085d4:	10 37       	cp.w	r7,r8
800085d6:	e0 84 00 81 	brge	800086d8 <_vfprintf_r+0x6f0>
800085da:	fa cb f9 44 	sub	r11,sp,-1724
800085de:	f6 06 00 36 	add	r6,r11,r6<<0x3
800085e2:	c7 78       	rjmp	800086d0 <_vfprintf_r+0x6e8>
800085e4:	ed b5 00 06 	bld	r5,0x6
800085e8:	c4 b1       	brne	8000867e <_vfprintf_r+0x696>
800085ea:	fa f8 06 b4 	ld.w	r8,sp[1716]
800085ee:	40 3c       	lddsp	r12,sp[0xc]
800085f0:	58 0c       	cp.w	r12,0
800085f2:	c1 d0       	breq	8000862c <_vfprintf_r+0x644>
800085f4:	10 36       	cp.w	r6,r8
800085f6:	c0 64       	brge	80008602 <_vfprintf_r+0x61a>
800085f8:	fa cb f9 44 	sub	r11,sp,-1724
800085fc:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008600:	c1 f8       	rjmp	8000863e <_vfprintf_r+0x656>
80008602:	fa c8 f9 50 	sub	r8,sp,-1712
80008606:	1a d8       	st.w	--sp,r8
80008608:	fa c8 fa b8 	sub	r8,sp,-1352
8000860c:	1a d8       	st.w	--sp,r8
8000860e:	fa c8 fb b4 	sub	r8,sp,-1100
80008612:	1a d8       	st.w	--sp,r8
80008614:	fa c8 f9 40 	sub	r8,sp,-1728
80008618:	fa c9 ff b4 	sub	r9,sp,-76
8000861c:	04 9a       	mov	r10,r2
8000861e:	0c 9b       	mov	r11,r6
80008620:	08 9c       	mov	r12,r4
80008622:	fe b0 fb 4b 	rcall	80007cb8 <get_arg>
80008626:	2f dd       	sub	sp,-12
80008628:	98 18       	ld.sh	r8,r12[0x2]
8000862a:	c2 68       	rjmp	80008676 <_vfprintf_r+0x68e>
8000862c:	ee ca ff ff 	sub	r10,r7,-1
80008630:	10 37       	cp.w	r7,r8
80008632:	c0 94       	brge	80008644 <_vfprintf_r+0x65c>
80008634:	fa c9 f9 44 	sub	r9,sp,-1724
80008638:	14 97       	mov	r7,r10
8000863a:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000863e:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80008642:	c1 a8       	rjmp	80008676 <_vfprintf_r+0x68e>
80008644:	41 09       	lddsp	r9,sp[0x40]
80008646:	59 f8       	cp.w	r8,31
80008648:	e0 89 00 13 	brgt	8000866e <_vfprintf_r+0x686>
8000864c:	f2 cb ff fc 	sub	r11,r9,-4
80008650:	51 0b       	stdsp	sp[0x40],r11
80008652:	72 09       	ld.w	r9,r9[0x0]
80008654:	fa c6 f9 44 	sub	r6,sp,-1724
80008658:	ec 08 00 3b 	add	r11,r6,r8<<0x3
8000865c:	2f f8       	sub	r8,-1
8000865e:	f7 49 fd 88 	st.w	r11[-632],r9
80008662:	fb 48 06 b4 	st.w	sp[1716],r8
80008666:	14 97       	mov	r7,r10
80008668:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
8000866c:	c0 58       	rjmp	80008676 <_vfprintf_r+0x68e>
8000866e:	92 18       	ld.sh	r8,r9[0x2]
80008670:	14 97       	mov	r7,r10
80008672:	2f c9       	sub	r9,-4
80008674:	51 09       	stdsp	sp[0x40],r9
80008676:	50 18       	stdsp	sp[0x4],r8
80008678:	bf 58       	asr	r8,0x1f
8000867a:	50 08       	stdsp	sp[0x0],r8
8000867c:	c4 88       	rjmp	8000870c <_vfprintf_r+0x724>
8000867e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008682:	40 3c       	lddsp	r12,sp[0xc]
80008684:	58 0c       	cp.w	r12,0
80008686:	c1 d0       	breq	800086c0 <_vfprintf_r+0x6d8>
80008688:	10 36       	cp.w	r6,r8
8000868a:	c0 64       	brge	80008696 <_vfprintf_r+0x6ae>
8000868c:	fa cb f9 44 	sub	r11,sp,-1724
80008690:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008694:	c1 f8       	rjmp	800086d2 <_vfprintf_r+0x6ea>
80008696:	fa c8 f9 50 	sub	r8,sp,-1712
8000869a:	1a d8       	st.w	--sp,r8
8000869c:	fa c8 fa b8 	sub	r8,sp,-1352
800086a0:	0c 9b       	mov	r11,r6
800086a2:	1a d8       	st.w	--sp,r8
800086a4:	fa c8 fb b4 	sub	r8,sp,-1100
800086a8:	04 9a       	mov	r10,r2
800086aa:	1a d8       	st.w	--sp,r8
800086ac:	08 9c       	mov	r12,r4
800086ae:	fa c8 f9 40 	sub	r8,sp,-1728
800086b2:	fa c9 ff b4 	sub	r9,sp,-76
800086b6:	fe b0 fb 01 	rcall	80007cb8 <get_arg>
800086ba:	2f dd       	sub	sp,-12
800086bc:	78 0b       	ld.w	r11,r12[0x0]
800086be:	c2 48       	rjmp	80008706 <_vfprintf_r+0x71e>
800086c0:	ee ca ff ff 	sub	r10,r7,-1
800086c4:	10 37       	cp.w	r7,r8
800086c6:	c0 94       	brge	800086d8 <_vfprintf_r+0x6f0>
800086c8:	fa c9 f9 44 	sub	r9,sp,-1724
800086cc:	f2 06 00 36 	add	r6,r9,r6<<0x3
800086d0:	14 97       	mov	r7,r10
800086d2:	ec fb fd 88 	ld.w	r11,r6[-632]
800086d6:	c1 88       	rjmp	80008706 <_vfprintf_r+0x71e>
800086d8:	41 09       	lddsp	r9,sp[0x40]
800086da:	59 f8       	cp.w	r8,31
800086dc:	e0 89 00 11 	brgt	800086fe <_vfprintf_r+0x716>
800086e0:	f2 cb ff fc 	sub	r11,r9,-4
800086e4:	51 0b       	stdsp	sp[0x40],r11
800086e6:	fa c6 f9 44 	sub	r6,sp,-1724
800086ea:	72 0b       	ld.w	r11,r9[0x0]
800086ec:	ec 08 00 39 	add	r9,r6,r8<<0x3
800086f0:	f3 4b fd 88 	st.w	r9[-632],r11
800086f4:	2f f8       	sub	r8,-1
800086f6:	14 97       	mov	r7,r10
800086f8:	fb 48 06 b4 	st.w	sp[1716],r8
800086fc:	c0 58       	rjmp	80008706 <_vfprintf_r+0x71e>
800086fe:	72 0b       	ld.w	r11,r9[0x0]
80008700:	14 97       	mov	r7,r10
80008702:	2f c9       	sub	r9,-4
80008704:	51 09       	stdsp	sp[0x40],r9
80008706:	50 1b       	stdsp	sp[0x4],r11
80008708:	bf 5b       	asr	r11,0x1f
8000870a:	50 0b       	stdsp	sp[0x0],r11
8000870c:	fa ea 00 00 	ld.d	r10,sp[0]
80008710:	58 0a       	cp.w	r10,0
80008712:	5c 2b       	cpc	r11
80008714:	c0 e4       	brge	80008730 <_vfprintf_r+0x748>
80008716:	30 08       	mov	r8,0
80008718:	fa ea 00 00 	ld.d	r10,sp[0]
8000871c:	30 09       	mov	r9,0
8000871e:	f0 0a 01 0a 	sub	r10,r8,r10
80008722:	f2 0b 01 4b 	sbc	r11,r9,r11
80008726:	32 d8       	mov	r8,45
80008728:	fa eb 00 00 	st.d	sp[0],r10
8000872c:	fb 68 06 bb 	st.b	sp[1723],r8
80008730:	30 18       	mov	r8,1
80008732:	e0 8f 06 fa 	bral	80009526 <_vfprintf_r+0x153e>
80008736:	50 a7       	stdsp	sp[0x28],r7
80008738:	50 80       	stdsp	sp[0x20],r0
8000873a:	0c 97       	mov	r7,r6
8000873c:	04 94       	mov	r4,r2
8000873e:	06 96       	mov	r6,r3
80008740:	02 92       	mov	r2,r1
80008742:	40 93       	lddsp	r3,sp[0x24]
80008744:	10 90       	mov	r0,r8
80008746:	40 41       	lddsp	r1,sp[0x10]
80008748:	0e 99       	mov	r9,r7
8000874a:	ed b5 00 03 	bld	r5,0x3
8000874e:	c4 11       	brne	800087d0 <_vfprintf_r+0x7e8>
80008750:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008754:	40 3a       	lddsp	r10,sp[0xc]
80008756:	58 0a       	cp.w	r10,0
80008758:	c1 90       	breq	8000878a <_vfprintf_r+0x7a2>
8000875a:	10 36       	cp.w	r6,r8
8000875c:	c6 45       	brlt	80008824 <_vfprintf_r+0x83c>
8000875e:	fa c8 f9 50 	sub	r8,sp,-1712
80008762:	1a d8       	st.w	--sp,r8
80008764:	fa c8 fa b8 	sub	r8,sp,-1352
80008768:	1a d8       	st.w	--sp,r8
8000876a:	fa c8 fb b4 	sub	r8,sp,-1100
8000876e:	0c 9b       	mov	r11,r6
80008770:	1a d8       	st.w	--sp,r8
80008772:	04 9a       	mov	r10,r2
80008774:	fa c8 f9 40 	sub	r8,sp,-1728
80008778:	fa c9 ff b4 	sub	r9,sp,-76
8000877c:	08 9c       	mov	r12,r4
8000877e:	fe b0 fa 9d 	rcall	80007cb8 <get_arg>
80008782:	2f dd       	sub	sp,-12
80008784:	78 16       	ld.w	r6,r12[0x4]
80008786:	50 76       	stdsp	sp[0x1c],r6
80008788:	c4 88       	rjmp	80008818 <_vfprintf_r+0x830>
8000878a:	2f f7       	sub	r7,-1
8000878c:	10 39       	cp.w	r9,r8
8000878e:	c0 c4       	brge	800087a6 <_vfprintf_r+0x7be>
80008790:	fa ce f9 44 	sub	lr,sp,-1724
80008794:	fc 06 00 36 	add	r6,lr,r6<<0x3
80008798:	ec fc fd 8c 	ld.w	r12,r6[-628]
8000879c:	50 7c       	stdsp	sp[0x1c],r12
8000879e:	ec f6 fd 88 	ld.w	r6,r6[-632]
800087a2:	50 56       	stdsp	sp[0x14],r6
800087a4:	c6 68       	rjmp	80008870 <_vfprintf_r+0x888>
800087a6:	41 09       	lddsp	r9,sp[0x40]
800087a8:	59 f8       	cp.w	r8,31
800087aa:	e0 89 00 10 	brgt	800087ca <_vfprintf_r+0x7e2>
800087ae:	f2 ca ff f8 	sub	r10,r9,-8
800087b2:	72 1b       	ld.w	r11,r9[0x4]
800087b4:	51 0a       	stdsp	sp[0x40],r10
800087b6:	72 09       	ld.w	r9,r9[0x0]
800087b8:	fa ca f9 44 	sub	r10,sp,-1724
800087bc:	50 7b       	stdsp	sp[0x1c],r11
800087be:	50 59       	stdsp	sp[0x14],r9
800087c0:	f4 08 00 39 	add	r9,r10,r8<<0x3
800087c4:	40 5b       	lddsp	r11,sp[0x14]
800087c6:	40 7a       	lddsp	r10,sp[0x1c]
800087c8:	c4 78       	rjmp	80008856 <_vfprintf_r+0x86e>
800087ca:	72 18       	ld.w	r8,r9[0x4]
800087cc:	50 78       	stdsp	sp[0x1c],r8
800087ce:	c4 c8       	rjmp	80008866 <_vfprintf_r+0x87e>
800087d0:	fa f8 06 b4 	ld.w	r8,sp[1716]
800087d4:	40 3e       	lddsp	lr,sp[0xc]
800087d6:	58 0e       	cp.w	lr,0
800087d8:	c2 30       	breq	8000881e <_vfprintf_r+0x836>
800087da:	10 36       	cp.w	r6,r8
800087dc:	c0 94       	brge	800087ee <_vfprintf_r+0x806>
800087de:	fa cc f9 44 	sub	r12,sp,-1724
800087e2:	f8 06 00 36 	add	r6,r12,r6<<0x3
800087e6:	ec fb fd 8c 	ld.w	r11,r6[-628]
800087ea:	50 7b       	stdsp	sp[0x1c],r11
800087ec:	cd 9b       	rjmp	8000879e <_vfprintf_r+0x7b6>
800087ee:	fa c8 f9 50 	sub	r8,sp,-1712
800087f2:	1a d8       	st.w	--sp,r8
800087f4:	fa c8 fa b8 	sub	r8,sp,-1352
800087f8:	04 9a       	mov	r10,r2
800087fa:	1a d8       	st.w	--sp,r8
800087fc:	fa c8 fb b4 	sub	r8,sp,-1100
80008800:	0c 9b       	mov	r11,r6
80008802:	1a d8       	st.w	--sp,r8
80008804:	08 9c       	mov	r12,r4
80008806:	fa c8 f9 40 	sub	r8,sp,-1728
8000880a:	fa c9 ff b4 	sub	r9,sp,-76
8000880e:	fe b0 fa 55 	rcall	80007cb8 <get_arg>
80008812:	2f dd       	sub	sp,-12
80008814:	78 1a       	ld.w	r10,r12[0x4]
80008816:	50 7a       	stdsp	sp[0x1c],r10
80008818:	78 0c       	ld.w	r12,r12[0x0]
8000881a:	50 5c       	stdsp	sp[0x14],r12
8000881c:	c2 a8       	rjmp	80008870 <_vfprintf_r+0x888>
8000881e:	2f f7       	sub	r7,-1
80008820:	10 39       	cp.w	r9,r8
80008822:	c0 94       	brge	80008834 <_vfprintf_r+0x84c>
80008824:	fa c9 f9 44 	sub	r9,sp,-1724
80008828:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000882c:	ec f8 fd 8c 	ld.w	r8,r6[-628]
80008830:	50 78       	stdsp	sp[0x1c],r8
80008832:	cb 6b       	rjmp	8000879e <_vfprintf_r+0x7b6>
80008834:	41 09       	lddsp	r9,sp[0x40]
80008836:	59 f8       	cp.w	r8,31
80008838:	e0 89 00 15 	brgt	80008862 <_vfprintf_r+0x87a>
8000883c:	f2 ca ff f8 	sub	r10,r9,-8
80008840:	72 16       	ld.w	r6,r9[0x4]
80008842:	72 09       	ld.w	r9,r9[0x0]
80008844:	51 0a       	stdsp	sp[0x40],r10
80008846:	50 59       	stdsp	sp[0x14],r9
80008848:	fa ce f9 44 	sub	lr,sp,-1724
8000884c:	50 76       	stdsp	sp[0x1c],r6
8000884e:	fc 08 00 39 	add	r9,lr,r8<<0x3
80008852:	40 5b       	lddsp	r11,sp[0x14]
80008854:	0c 9a       	mov	r10,r6
80008856:	f2 eb fd 88 	st.d	r9[-632],r10
8000885a:	2f f8       	sub	r8,-1
8000885c:	fb 48 06 b4 	st.w	sp[1716],r8
80008860:	c0 88       	rjmp	80008870 <_vfprintf_r+0x888>
80008862:	72 1c       	ld.w	r12,r9[0x4]
80008864:	50 7c       	stdsp	sp[0x1c],r12
80008866:	f2 c8 ff f8 	sub	r8,r9,-8
8000886a:	51 08       	stdsp	sp[0x40],r8
8000886c:	72 09       	ld.w	r9,r9[0x0]
8000886e:	50 59       	stdsp	sp[0x14],r9
80008870:	40 5b       	lddsp	r11,sp[0x14]
80008872:	40 7a       	lddsp	r10,sp[0x1c]
80008874:	e0 a0 19 54 	rcall	8000bb1c <__isinfd>
80008878:	18 96       	mov	r6,r12
8000887a:	c1 70       	breq	800088a8 <_vfprintf_r+0x8c0>
8000887c:	30 08       	mov	r8,0
8000887e:	30 09       	mov	r9,0
80008880:	40 5b       	lddsp	r11,sp[0x14]
80008882:	40 7a       	lddsp	r10,sp[0x1c]
80008884:	e0 a0 1d a8 	rcall	8000c3d4 <__avr32_f64_cmp_lt>
80008888:	c0 40       	breq	80008890 <_vfprintf_r+0x8a8>
8000888a:	32 d8       	mov	r8,45
8000888c:	fb 68 06 bb 	st.b	sp[1723],r8
80008890:	fe c8 a5 d8 	sub	r8,pc,-23080
80008894:	fe c6 a5 d8 	sub	r6,pc,-23080
80008898:	a7 d5       	cbr	r5,0x7
8000889a:	e0 40 00 47 	cp.w	r0,71
8000889e:	f0 06 17 a0 	movle	r6,r8
800088a2:	30 32       	mov	r2,3
800088a4:	e0 8f 06 ce 	bral	80009640 <_vfprintf_r+0x1658>
800088a8:	40 5b       	lddsp	r11,sp[0x14]
800088aa:	40 7a       	lddsp	r10,sp[0x1c]
800088ac:	e0 a0 19 4d 	rcall	8000bb46 <__isnand>
800088b0:	c0 e0       	breq	800088cc <_vfprintf_r+0x8e4>
800088b2:	50 26       	stdsp	sp[0x8],r6
800088b4:	fe c8 a5 f4 	sub	r8,pc,-23052
800088b8:	fe c6 a5 f4 	sub	r6,pc,-23052
800088bc:	a7 d5       	cbr	r5,0x7
800088be:	e0 40 00 47 	cp.w	r0,71
800088c2:	f0 06 17 a0 	movle	r6,r8
800088c6:	30 32       	mov	r2,3
800088c8:	e0 8f 06 c2 	bral	8000964c <_vfprintf_r+0x1664>
800088cc:	40 2a       	lddsp	r10,sp[0x8]
800088ce:	5b fa       	cp.w	r10,-1
800088d0:	c0 41       	brne	800088d8 <_vfprintf_r+0x8f0>
800088d2:	30 69       	mov	r9,6
800088d4:	50 29       	stdsp	sp[0x8],r9
800088d6:	c1 18       	rjmp	800088f8 <_vfprintf_r+0x910>
800088d8:	e0 40 00 47 	cp.w	r0,71
800088dc:	5f 09       	sreq	r9
800088de:	e0 40 00 67 	cp.w	r0,103
800088e2:	5f 08       	sreq	r8
800088e4:	f3 e8 10 08 	or	r8,r9,r8
800088e8:	f8 08 18 00 	cp.b	r8,r12
800088ec:	c0 60       	breq	800088f8 <_vfprintf_r+0x910>
800088ee:	40 28       	lddsp	r8,sp[0x8]
800088f0:	58 08       	cp.w	r8,0
800088f2:	f9 b8 00 01 	moveq	r8,1
800088f6:	50 28       	stdsp	sp[0x8],r8
800088f8:	40 78       	lddsp	r8,sp[0x1c]
800088fa:	40 59       	lddsp	r9,sp[0x14]
800088fc:	fa e9 06 94 	st.d	sp[1684],r8
80008900:	a9 a5       	sbr	r5,0x8
80008902:	fa f8 06 94 	ld.w	r8,sp[1684]
80008906:	58 08       	cp.w	r8,0
80008908:	c0 65       	brlt	80008914 <_vfprintf_r+0x92c>
8000890a:	40 5e       	lddsp	lr,sp[0x14]
8000890c:	30 0c       	mov	r12,0
8000890e:	50 6e       	stdsp	sp[0x18],lr
80008910:	50 9c       	stdsp	sp[0x24],r12
80008912:	c0 78       	rjmp	80008920 <_vfprintf_r+0x938>
80008914:	40 5b       	lddsp	r11,sp[0x14]
80008916:	32 da       	mov	r10,45
80008918:	ee 1b 80 00 	eorh	r11,0x8000
8000891c:	50 9a       	stdsp	sp[0x24],r10
8000891e:	50 6b       	stdsp	sp[0x18],r11
80008920:	e0 40 00 46 	cp.w	r0,70
80008924:	5f 09       	sreq	r9
80008926:	e0 40 00 66 	cp.w	r0,102
8000892a:	5f 08       	sreq	r8
8000892c:	f3 e8 10 08 	or	r8,r9,r8
80008930:	50 48       	stdsp	sp[0x10],r8
80008932:	c0 40       	breq	8000893a <_vfprintf_r+0x952>
80008934:	40 22       	lddsp	r2,sp[0x8]
80008936:	30 39       	mov	r9,3
80008938:	c1 08       	rjmp	80008958 <_vfprintf_r+0x970>
8000893a:	e0 40 00 45 	cp.w	r0,69
8000893e:	5f 09       	sreq	r9
80008940:	e0 40 00 65 	cp.w	r0,101
80008944:	5f 08       	sreq	r8
80008946:	40 22       	lddsp	r2,sp[0x8]
80008948:	10 49       	or	r9,r8
8000894a:	2f f2       	sub	r2,-1
8000894c:	40 46       	lddsp	r6,sp[0x10]
8000894e:	ec 09 18 00 	cp.b	r9,r6
80008952:	fb f2 00 02 	ld.weq	r2,sp[0x8]
80008956:	30 29       	mov	r9,2
80008958:	fa c8 f9 5c 	sub	r8,sp,-1700
8000895c:	1a d8       	st.w	--sp,r8
8000895e:	fa c8 f9 54 	sub	r8,sp,-1708
80008962:	1a d8       	st.w	--sp,r8
80008964:	fa c8 f9 4c 	sub	r8,sp,-1716
80008968:	08 9c       	mov	r12,r4
8000896a:	1a d8       	st.w	--sp,r8
8000896c:	04 98       	mov	r8,r2
8000896e:	40 9b       	lddsp	r11,sp[0x24]
80008970:	40 aa       	lddsp	r10,sp[0x28]
80008972:	e0 a0 0b c3 	rcall	8000a0f8 <_dtoa_r>
80008976:	e0 40 00 47 	cp.w	r0,71
8000897a:	5f 19       	srne	r9
8000897c:	e0 40 00 67 	cp.w	r0,103
80008980:	5f 18       	srne	r8
80008982:	18 96       	mov	r6,r12
80008984:	2f dd       	sub	sp,-12
80008986:	f3 e8 00 08 	and	r8,r9,r8
8000898a:	c0 41       	brne	80008992 <_vfprintf_r+0x9aa>
8000898c:	ed b5 00 00 	bld	r5,0x0
80008990:	c3 01       	brne	800089f0 <_vfprintf_r+0xa08>
80008992:	ec 02 00 0e 	add	lr,r6,r2
80008996:	50 3e       	stdsp	sp[0xc],lr
80008998:	40 4c       	lddsp	r12,sp[0x10]
8000899a:	58 0c       	cp.w	r12,0
8000899c:	c1 50       	breq	800089c6 <_vfprintf_r+0x9de>
8000899e:	0d 89       	ld.ub	r9,r6[0x0]
800089a0:	33 08       	mov	r8,48
800089a2:	f0 09 18 00 	cp.b	r9,r8
800089a6:	c0 b1       	brne	800089bc <_vfprintf_r+0x9d4>
800089a8:	30 08       	mov	r8,0
800089aa:	30 09       	mov	r9,0
800089ac:	40 6b       	lddsp	r11,sp[0x18]
800089ae:	40 7a       	lddsp	r10,sp[0x1c]
800089b0:	e0 a0 1c cb 	rcall	8000c346 <__avr32_f64_cmp_eq>
800089b4:	fb b2 00 01 	rsubeq	r2,1
800089b8:	fb f2 0b ab 	st.weq	sp[0x6ac],r2
800089bc:	40 3b       	lddsp	r11,sp[0xc]
800089be:	fa f8 06 ac 	ld.w	r8,sp[1708]
800089c2:	10 0b       	add	r11,r8
800089c4:	50 3b       	stdsp	sp[0xc],r11
800089c6:	40 6b       	lddsp	r11,sp[0x18]
800089c8:	30 08       	mov	r8,0
800089ca:	30 09       	mov	r9,0
800089cc:	40 7a       	lddsp	r10,sp[0x1c]
800089ce:	e0 a0 1c bc 	rcall	8000c346 <__avr32_f64_cmp_eq>
800089d2:	c0 90       	breq	800089e4 <_vfprintf_r+0x9fc>
800089d4:	40 3a       	lddsp	r10,sp[0xc]
800089d6:	fb 4a 06 a4 	st.w	sp[1700],r10
800089da:	c0 58       	rjmp	800089e4 <_vfprintf_r+0x9fc>
800089dc:	10 c9       	st.b	r8++,r9
800089de:	fb 48 06 a4 	st.w	sp[1700],r8
800089e2:	c0 28       	rjmp	800089e6 <_vfprintf_r+0x9fe>
800089e4:	33 09       	mov	r9,48
800089e6:	fa f8 06 a4 	ld.w	r8,sp[1700]
800089ea:	40 3e       	lddsp	lr,sp[0xc]
800089ec:	1c 38       	cp.w	r8,lr
800089ee:	cf 73       	brcs	800089dc <_vfprintf_r+0x9f4>
800089f0:	e0 40 00 47 	cp.w	r0,71
800089f4:	5f 09       	sreq	r9
800089f6:	e0 40 00 67 	cp.w	r0,103
800089fa:	5f 08       	sreq	r8
800089fc:	f3 e8 10 08 	or	r8,r9,r8
80008a00:	fa f9 06 a4 	ld.w	r9,sp[1700]
80008a04:	0c 19       	sub	r9,r6
80008a06:	50 69       	stdsp	sp[0x18],r9
80008a08:	58 08       	cp.w	r8,0
80008a0a:	c0 b0       	breq	80008a20 <_vfprintf_r+0xa38>
80008a0c:	fa f8 06 ac 	ld.w	r8,sp[1708]
80008a10:	5b d8       	cp.w	r8,-3
80008a12:	c0 55       	brlt	80008a1c <_vfprintf_r+0xa34>
80008a14:	40 2c       	lddsp	r12,sp[0x8]
80008a16:	18 38       	cp.w	r8,r12
80008a18:	e0 8a 00 6a 	brle	80008aec <_vfprintf_r+0xb04>
80008a1c:	20 20       	sub	r0,2
80008a1e:	c0 58       	rjmp	80008a28 <_vfprintf_r+0xa40>
80008a20:	e0 40 00 65 	cp.w	r0,101
80008a24:	e0 89 00 46 	brgt	80008ab0 <_vfprintf_r+0xac8>
80008a28:	fa fb 06 ac 	ld.w	r11,sp[1708]
80008a2c:	fb 60 06 9c 	st.b	sp[1692],r0
80008a30:	20 1b       	sub	r11,1
80008a32:	fb 4b 06 ac 	st.w	sp[1708],r11
80008a36:	c0 47       	brpl	80008a3e <_vfprintf_r+0xa56>
80008a38:	5c 3b       	neg	r11
80008a3a:	32 d8       	mov	r8,45
80008a3c:	c0 28       	rjmp	80008a40 <_vfprintf_r+0xa58>
80008a3e:	32 b8       	mov	r8,43
80008a40:	fb 68 06 9d 	st.b	sp[1693],r8
80008a44:	58 9b       	cp.w	r11,9
80008a46:	e0 8a 00 1d 	brle	80008a80 <_vfprintf_r+0xa98>
80008a4a:	fa c9 fa 35 	sub	r9,sp,-1483
80008a4e:	30 aa       	mov	r10,10
80008a50:	12 98       	mov	r8,r9
80008a52:	0e 9c       	mov	r12,r7
80008a54:	0c 92       	mov	r2,r6
80008a56:	f6 0a 0c 06 	divs	r6,r11,r10
80008a5a:	0e 9b       	mov	r11,r7
80008a5c:	2d 0b       	sub	r11,-48
80008a5e:	10 fb       	st.b	--r8,r11
80008a60:	0c 9b       	mov	r11,r6
80008a62:	58 96       	cp.w	r6,9
80008a64:	fe 99 ff f9 	brgt	80008a56 <_vfprintf_r+0xa6e>
80008a68:	2d 0b       	sub	r11,-48
80008a6a:	18 97       	mov	r7,r12
80008a6c:	04 96       	mov	r6,r2
80008a6e:	10 fb       	st.b	--r8,r11
80008a70:	fa ca f9 62 	sub	r10,sp,-1694
80008a74:	c0 38       	rjmp	80008a7a <_vfprintf_r+0xa92>
80008a76:	11 3b       	ld.ub	r11,r8++
80008a78:	14 cb       	st.b	r10++,r11
80008a7a:	12 38       	cp.w	r8,r9
80008a7c:	cf d3       	brcs	80008a76 <_vfprintf_r+0xa8e>
80008a7e:	c0 98       	rjmp	80008a90 <_vfprintf_r+0xaa8>
80008a80:	2d 0b       	sub	r11,-48
80008a82:	33 08       	mov	r8,48
80008a84:	fb 6b 06 9f 	st.b	sp[1695],r11
80008a88:	fb 68 06 9e 	st.b	sp[1694],r8
80008a8c:	fa ca f9 60 	sub	r10,sp,-1696
80008a90:	fa c8 f9 64 	sub	r8,sp,-1692
80008a94:	f4 08 01 08 	sub	r8,r10,r8
80008a98:	50 e8       	stdsp	sp[0x38],r8
80008a9a:	10 92       	mov	r2,r8
80008a9c:	40 6b       	lddsp	r11,sp[0x18]
80008a9e:	16 02       	add	r2,r11
80008aa0:	58 1b       	cp.w	r11,1
80008aa2:	e0 89 00 05 	brgt	80008aac <_vfprintf_r+0xac4>
80008aa6:	ed b5 00 00 	bld	r5,0x0
80008aaa:	c3 51       	brne	80008b14 <_vfprintf_r+0xb2c>
80008aac:	2f f2       	sub	r2,-1
80008aae:	c3 38       	rjmp	80008b14 <_vfprintf_r+0xb2c>
80008ab0:	e0 40 00 66 	cp.w	r0,102
80008ab4:	c1 c1       	brne	80008aec <_vfprintf_r+0xb04>
80008ab6:	fa f2 06 ac 	ld.w	r2,sp[1708]
80008aba:	58 02       	cp.w	r2,0
80008abc:	e0 8a 00 0c 	brle	80008ad4 <_vfprintf_r+0xaec>
80008ac0:	40 2a       	lddsp	r10,sp[0x8]
80008ac2:	58 0a       	cp.w	r10,0
80008ac4:	c0 41       	brne	80008acc <_vfprintf_r+0xae4>
80008ac6:	ed b5 00 00 	bld	r5,0x0
80008aca:	c2 51       	brne	80008b14 <_vfprintf_r+0xb2c>
80008acc:	2f f2       	sub	r2,-1
80008ace:	40 29       	lddsp	r9,sp[0x8]
80008ad0:	12 02       	add	r2,r9
80008ad2:	c0 b8       	rjmp	80008ae8 <_vfprintf_r+0xb00>
80008ad4:	40 28       	lddsp	r8,sp[0x8]
80008ad6:	58 08       	cp.w	r8,0
80008ad8:	c0 61       	brne	80008ae4 <_vfprintf_r+0xafc>
80008ada:	ed b5 00 00 	bld	r5,0x0
80008ade:	c0 30       	breq	80008ae4 <_vfprintf_r+0xafc>
80008ae0:	30 12       	mov	r2,1
80008ae2:	c1 98       	rjmp	80008b14 <_vfprintf_r+0xb2c>
80008ae4:	40 22       	lddsp	r2,sp[0x8]
80008ae6:	2f e2       	sub	r2,-2
80008ae8:	36 60       	mov	r0,102
80008aea:	c1 58       	rjmp	80008b14 <_vfprintf_r+0xb2c>
80008aec:	fa f2 06 ac 	ld.w	r2,sp[1708]
80008af0:	40 6e       	lddsp	lr,sp[0x18]
80008af2:	1c 32       	cp.w	r2,lr
80008af4:	c0 65       	brlt	80008b00 <_vfprintf_r+0xb18>
80008af6:	ed b5 00 00 	bld	r5,0x0
80008afa:	f7 b2 00 ff 	subeq	r2,-1
80008afe:	c0 a8       	rjmp	80008b12 <_vfprintf_r+0xb2a>
80008b00:	e4 08 11 02 	rsub	r8,r2,2
80008b04:	40 6c       	lddsp	r12,sp[0x18]
80008b06:	58 02       	cp.w	r2,0
80008b08:	f0 02 17 a0 	movle	r2,r8
80008b0c:	f9 b2 09 01 	movgt	r2,1
80008b10:	18 02       	add	r2,r12
80008b12:	36 70       	mov	r0,103
80008b14:	40 9b       	lddsp	r11,sp[0x24]
80008b16:	58 0b       	cp.w	r11,0
80008b18:	e0 80 05 94 	breq	80009640 <_vfprintf_r+0x1658>
80008b1c:	32 d8       	mov	r8,45
80008b1e:	fb 68 06 bb 	st.b	sp[1723],r8
80008b22:	e0 8f 05 93 	bral	80009648 <_vfprintf_r+0x1660>
80008b26:	50 a7       	stdsp	sp[0x28],r7
80008b28:	04 94       	mov	r4,r2
80008b2a:	0c 97       	mov	r7,r6
80008b2c:	02 92       	mov	r2,r1
80008b2e:	06 96       	mov	r6,r3
80008b30:	40 41       	lddsp	r1,sp[0x10]
80008b32:	40 93       	lddsp	r3,sp[0x24]
80008b34:	0e 99       	mov	r9,r7
80008b36:	ed b5 00 05 	bld	r5,0x5
80008b3a:	c4 81       	brne	80008bca <_vfprintf_r+0xbe2>
80008b3c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008b40:	40 3e       	lddsp	lr,sp[0xc]
80008b42:	58 0e       	cp.w	lr,0
80008b44:	c1 d0       	breq	80008b7e <_vfprintf_r+0xb96>
80008b46:	10 36       	cp.w	r6,r8
80008b48:	c0 64       	brge	80008b54 <_vfprintf_r+0xb6c>
80008b4a:	fa cc f9 44 	sub	r12,sp,-1724
80008b4e:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008b52:	c1 d8       	rjmp	80008b8c <_vfprintf_r+0xba4>
80008b54:	fa c8 f9 50 	sub	r8,sp,-1712
80008b58:	1a d8       	st.w	--sp,r8
80008b5a:	fa c8 fa b8 	sub	r8,sp,-1352
80008b5e:	04 9a       	mov	r10,r2
80008b60:	1a d8       	st.w	--sp,r8
80008b62:	fa c8 fb b4 	sub	r8,sp,-1100
80008b66:	0c 9b       	mov	r11,r6
80008b68:	1a d8       	st.w	--sp,r8
80008b6a:	08 9c       	mov	r12,r4
80008b6c:	fa c8 f9 40 	sub	r8,sp,-1728
80008b70:	fa c9 ff b4 	sub	r9,sp,-76
80008b74:	fe b0 f8 a2 	rcall	80007cb8 <get_arg>
80008b78:	2f dd       	sub	sp,-12
80008b7a:	78 0a       	ld.w	r10,r12[0x0]
80008b7c:	c2 08       	rjmp	80008bbc <_vfprintf_r+0xbd4>
80008b7e:	2f f7       	sub	r7,-1
80008b80:	10 39       	cp.w	r9,r8
80008b82:	c0 84       	brge	80008b92 <_vfprintf_r+0xbaa>
80008b84:	fa cb f9 44 	sub	r11,sp,-1724
80008b88:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008b8c:	ec fa fd 88 	ld.w	r10,r6[-632]
80008b90:	c1 68       	rjmp	80008bbc <_vfprintf_r+0xbd4>
80008b92:	41 09       	lddsp	r9,sp[0x40]
80008b94:	59 f8       	cp.w	r8,31
80008b96:	e0 89 00 10 	brgt	80008bb6 <_vfprintf_r+0xbce>
80008b9a:	f2 ca ff fc 	sub	r10,r9,-4
80008b9e:	51 0a       	stdsp	sp[0x40],r10
80008ba0:	fa c6 f9 44 	sub	r6,sp,-1724
80008ba4:	72 0a       	ld.w	r10,r9[0x0]
80008ba6:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008baa:	f3 4a fd 88 	st.w	r9[-632],r10
80008bae:	2f f8       	sub	r8,-1
80008bb0:	fb 48 06 b4 	st.w	sp[1716],r8
80008bb4:	c0 48       	rjmp	80008bbc <_vfprintf_r+0xbd4>
80008bb6:	72 0a       	ld.w	r10,r9[0x0]
80008bb8:	2f c9       	sub	r9,-4
80008bba:	51 09       	stdsp	sp[0x40],r9
80008bbc:	40 be       	lddsp	lr,sp[0x2c]
80008bbe:	1c 98       	mov	r8,lr
80008bc0:	95 1e       	st.w	r10[0x4],lr
80008bc2:	bf 58       	asr	r8,0x1f
80008bc4:	95 08       	st.w	r10[0x0],r8
80008bc6:	fe 9f fa 9f 	bral	80008104 <_vfprintf_r+0x11c>
80008bca:	ed b5 00 04 	bld	r5,0x4
80008bce:	c4 80       	breq	80008c5e <_vfprintf_r+0xc76>
80008bd0:	e2 15 00 40 	andl	r5,0x40,COH
80008bd4:	c4 50       	breq	80008c5e <_vfprintf_r+0xc76>
80008bd6:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008bda:	40 3c       	lddsp	r12,sp[0xc]
80008bdc:	58 0c       	cp.w	r12,0
80008bde:	c1 d0       	breq	80008c18 <_vfprintf_r+0xc30>
80008be0:	10 36       	cp.w	r6,r8
80008be2:	c0 64       	brge	80008bee <_vfprintf_r+0xc06>
80008be4:	fa cb f9 44 	sub	r11,sp,-1724
80008be8:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008bec:	c1 d8       	rjmp	80008c26 <_vfprintf_r+0xc3e>
80008bee:	fa c8 f9 50 	sub	r8,sp,-1712
80008bf2:	1a d8       	st.w	--sp,r8
80008bf4:	fa c8 fa b8 	sub	r8,sp,-1352
80008bf8:	04 9a       	mov	r10,r2
80008bfa:	1a d8       	st.w	--sp,r8
80008bfc:	fa c8 fb b4 	sub	r8,sp,-1100
80008c00:	0c 9b       	mov	r11,r6
80008c02:	1a d8       	st.w	--sp,r8
80008c04:	08 9c       	mov	r12,r4
80008c06:	fa c8 f9 40 	sub	r8,sp,-1728
80008c0a:	fa c9 ff b4 	sub	r9,sp,-76
80008c0e:	fe b0 f8 55 	rcall	80007cb8 <get_arg>
80008c12:	2f dd       	sub	sp,-12
80008c14:	78 0a       	ld.w	r10,r12[0x0]
80008c16:	c2 08       	rjmp	80008c56 <_vfprintf_r+0xc6e>
80008c18:	2f f7       	sub	r7,-1
80008c1a:	10 39       	cp.w	r9,r8
80008c1c:	c0 84       	brge	80008c2c <_vfprintf_r+0xc44>
80008c1e:	fa ca f9 44 	sub	r10,sp,-1724
80008c22:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008c26:	ec fa fd 88 	ld.w	r10,r6[-632]
80008c2a:	c1 68       	rjmp	80008c56 <_vfprintf_r+0xc6e>
80008c2c:	41 09       	lddsp	r9,sp[0x40]
80008c2e:	59 f8       	cp.w	r8,31
80008c30:	e0 89 00 10 	brgt	80008c50 <_vfprintf_r+0xc68>
80008c34:	f2 ca ff fc 	sub	r10,r9,-4
80008c38:	51 0a       	stdsp	sp[0x40],r10
80008c3a:	fa c6 f9 44 	sub	r6,sp,-1724
80008c3e:	72 0a       	ld.w	r10,r9[0x0]
80008c40:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008c44:	f3 4a fd 88 	st.w	r9[-632],r10
80008c48:	2f f8       	sub	r8,-1
80008c4a:	fb 48 06 b4 	st.w	sp[1716],r8
80008c4e:	c0 48       	rjmp	80008c56 <_vfprintf_r+0xc6e>
80008c50:	72 0a       	ld.w	r10,r9[0x0]
80008c52:	2f c9       	sub	r9,-4
80008c54:	51 09       	stdsp	sp[0x40],r9
80008c56:	40 be       	lddsp	lr,sp[0x2c]
80008c58:	b4 0e       	st.h	r10[0x0],lr
80008c5a:	fe 9f fa 55 	bral	80008104 <_vfprintf_r+0x11c>
80008c5e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008c62:	40 3c       	lddsp	r12,sp[0xc]
80008c64:	58 0c       	cp.w	r12,0
80008c66:	c1 d0       	breq	80008ca0 <_vfprintf_r+0xcb8>
80008c68:	10 36       	cp.w	r6,r8
80008c6a:	c0 64       	brge	80008c76 <_vfprintf_r+0xc8e>
80008c6c:	fa cb f9 44 	sub	r11,sp,-1724
80008c70:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008c74:	c1 d8       	rjmp	80008cae <_vfprintf_r+0xcc6>
80008c76:	fa c8 f9 50 	sub	r8,sp,-1712
80008c7a:	1a d8       	st.w	--sp,r8
80008c7c:	fa c8 fa b8 	sub	r8,sp,-1352
80008c80:	04 9a       	mov	r10,r2
80008c82:	1a d8       	st.w	--sp,r8
80008c84:	fa c8 fb b4 	sub	r8,sp,-1100
80008c88:	0c 9b       	mov	r11,r6
80008c8a:	1a d8       	st.w	--sp,r8
80008c8c:	08 9c       	mov	r12,r4
80008c8e:	fa c8 f9 40 	sub	r8,sp,-1728
80008c92:	fa c9 ff b4 	sub	r9,sp,-76
80008c96:	fe b0 f8 11 	rcall	80007cb8 <get_arg>
80008c9a:	2f dd       	sub	sp,-12
80008c9c:	78 0a       	ld.w	r10,r12[0x0]
80008c9e:	c2 08       	rjmp	80008cde <_vfprintf_r+0xcf6>
80008ca0:	2f f7       	sub	r7,-1
80008ca2:	10 39       	cp.w	r9,r8
80008ca4:	c0 84       	brge	80008cb4 <_vfprintf_r+0xccc>
80008ca6:	fa ca f9 44 	sub	r10,sp,-1724
80008caa:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008cae:	ec fa fd 88 	ld.w	r10,r6[-632]
80008cb2:	c1 68       	rjmp	80008cde <_vfprintf_r+0xcf6>
80008cb4:	41 09       	lddsp	r9,sp[0x40]
80008cb6:	59 f8       	cp.w	r8,31
80008cb8:	e0 89 00 10 	brgt	80008cd8 <_vfprintf_r+0xcf0>
80008cbc:	f2 ca ff fc 	sub	r10,r9,-4
80008cc0:	51 0a       	stdsp	sp[0x40],r10
80008cc2:	fa c6 f9 44 	sub	r6,sp,-1724
80008cc6:	72 0a       	ld.w	r10,r9[0x0]
80008cc8:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008ccc:	f3 4a fd 88 	st.w	r9[-632],r10
80008cd0:	2f f8       	sub	r8,-1
80008cd2:	fb 48 06 b4 	st.w	sp[1716],r8
80008cd6:	c0 48       	rjmp	80008cde <_vfprintf_r+0xcf6>
80008cd8:	72 0a       	ld.w	r10,r9[0x0]
80008cda:	2f c9       	sub	r9,-4
80008cdc:	51 09       	stdsp	sp[0x40],r9
80008cde:	40 be       	lddsp	lr,sp[0x2c]
80008ce0:	95 0e       	st.w	r10[0x0],lr
80008ce2:	fe 9f fa 11 	bral	80008104 <_vfprintf_r+0x11c>
80008ce6:	50 a7       	stdsp	sp[0x28],r7
80008ce8:	50 80       	stdsp	sp[0x20],r0
80008cea:	0c 97       	mov	r7,r6
80008cec:	04 94       	mov	r4,r2
80008cee:	06 96       	mov	r6,r3
80008cf0:	02 92       	mov	r2,r1
80008cf2:	40 93       	lddsp	r3,sp[0x24]
80008cf4:	10 90       	mov	r0,r8
80008cf6:	40 41       	lddsp	r1,sp[0x10]
80008cf8:	a5 a5       	sbr	r5,0x4
80008cfa:	c0 a8       	rjmp	80008d0e <_vfprintf_r+0xd26>
80008cfc:	50 a7       	stdsp	sp[0x28],r7
80008cfe:	50 80       	stdsp	sp[0x20],r0
80008d00:	0c 97       	mov	r7,r6
80008d02:	04 94       	mov	r4,r2
80008d04:	06 96       	mov	r6,r3
80008d06:	02 92       	mov	r2,r1
80008d08:	40 93       	lddsp	r3,sp[0x24]
80008d0a:	10 90       	mov	r0,r8
80008d0c:	40 41       	lddsp	r1,sp[0x10]
80008d0e:	ed b5 00 05 	bld	r5,0x5
80008d12:	c5 d1       	brne	80008dcc <_vfprintf_r+0xde4>
80008d14:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008d18:	40 3c       	lddsp	r12,sp[0xc]
80008d1a:	58 0c       	cp.w	r12,0
80008d1c:	c2 60       	breq	80008d68 <_vfprintf_r+0xd80>
80008d1e:	10 36       	cp.w	r6,r8
80008d20:	c0 a4       	brge	80008d34 <_vfprintf_r+0xd4c>
80008d22:	fa cb f9 44 	sub	r11,sp,-1724
80008d26:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008d2a:	ec e8 fd 88 	ld.d	r8,r6[-632]
80008d2e:	fa e9 00 00 	st.d	sp[0],r8
80008d32:	c1 88       	rjmp	80008d62 <_vfprintf_r+0xd7a>
80008d34:	fa c8 f9 50 	sub	r8,sp,-1712
80008d38:	1a d8       	st.w	--sp,r8
80008d3a:	fa c8 fa b8 	sub	r8,sp,-1352
80008d3e:	04 9a       	mov	r10,r2
80008d40:	1a d8       	st.w	--sp,r8
80008d42:	0c 9b       	mov	r11,r6
80008d44:	fa c8 fb b4 	sub	r8,sp,-1100
80008d48:	08 9c       	mov	r12,r4
80008d4a:	1a d8       	st.w	--sp,r8
80008d4c:	fa c8 f9 40 	sub	r8,sp,-1728
80008d50:	fa c9 ff b4 	sub	r9,sp,-76
80008d54:	fe b0 f7 b2 	rcall	80007cb8 <get_arg>
80008d58:	2f dd       	sub	sp,-12
80008d5a:	f8 ea 00 00 	ld.d	r10,r12[0]
80008d5e:	fa eb 00 00 	st.d	sp[0],r10
80008d62:	30 08       	mov	r8,0
80008d64:	e0 8f 03 de 	bral	80009520 <_vfprintf_r+0x1538>
80008d68:	ee ca ff ff 	sub	r10,r7,-1
80008d6c:	10 37       	cp.w	r7,r8
80008d6e:	c0 b4       	brge	80008d84 <_vfprintf_r+0xd9c>
80008d70:	fa c9 f9 44 	sub	r9,sp,-1724
80008d74:	14 97       	mov	r7,r10
80008d76:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008d7a:	ec ea fd 88 	ld.d	r10,r6[-632]
80008d7e:	fa eb 00 00 	st.d	sp[0],r10
80008d82:	c1 88       	rjmp	80008db2 <_vfprintf_r+0xdca>
80008d84:	41 09       	lddsp	r9,sp[0x40]
80008d86:	59 f8       	cp.w	r8,31
80008d88:	e0 89 00 18 	brgt	80008db8 <_vfprintf_r+0xdd0>
80008d8c:	f2 e6 00 00 	ld.d	r6,r9[0]
80008d90:	f2 cb ff f8 	sub	r11,r9,-8
80008d94:	fa e7 00 00 	st.d	sp[0],r6
80008d98:	51 0b       	stdsp	sp[0x40],r11
80008d9a:	fa c6 f9 44 	sub	r6,sp,-1724
80008d9e:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008da2:	fa e6 00 00 	ld.d	r6,sp[0]
80008da6:	f2 e7 fd 88 	st.d	r9[-632],r6
80008daa:	2f f8       	sub	r8,-1
80008dac:	14 97       	mov	r7,r10
80008dae:	fb 48 06 b4 	st.w	sp[1716],r8
80008db2:	40 38       	lddsp	r8,sp[0xc]
80008db4:	e0 8f 03 b6 	bral	80009520 <_vfprintf_r+0x1538>
80008db8:	f2 e6 00 00 	ld.d	r6,r9[0]
80008dbc:	40 38       	lddsp	r8,sp[0xc]
80008dbe:	fa e7 00 00 	st.d	sp[0],r6
80008dc2:	2f 89       	sub	r9,-8
80008dc4:	14 97       	mov	r7,r10
80008dc6:	51 09       	stdsp	sp[0x40],r9
80008dc8:	e0 8f 03 ac 	bral	80009520 <_vfprintf_r+0x1538>
80008dcc:	ed b5 00 04 	bld	r5,0x4
80008dd0:	c1 61       	brne	80008dfc <_vfprintf_r+0xe14>
80008dd2:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008dd6:	40 3e       	lddsp	lr,sp[0xc]
80008dd8:	58 0e       	cp.w	lr,0
80008dda:	c0 80       	breq	80008dea <_vfprintf_r+0xe02>
80008ddc:	10 36       	cp.w	r6,r8
80008dde:	c6 74       	brge	80008eac <_vfprintf_r+0xec4>
80008de0:	fa cc f9 44 	sub	r12,sp,-1724
80008de4:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008de8:	c8 08       	rjmp	80008ee8 <_vfprintf_r+0xf00>
80008dea:	ee ca ff ff 	sub	r10,r7,-1
80008dee:	10 37       	cp.w	r7,r8
80008df0:	c7 f4       	brge	80008eee <_vfprintf_r+0xf06>
80008df2:	fa cb f9 44 	sub	r11,sp,-1724
80008df6:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008dfa:	c7 68       	rjmp	80008ee6 <_vfprintf_r+0xefe>
80008dfc:	ed b5 00 06 	bld	r5,0x6
80008e00:	c4 a1       	brne	80008e94 <_vfprintf_r+0xeac>
80008e02:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008e06:	40 3c       	lddsp	r12,sp[0xc]
80008e08:	58 0c       	cp.w	r12,0
80008e0a:	c1 d0       	breq	80008e44 <_vfprintf_r+0xe5c>
80008e0c:	10 36       	cp.w	r6,r8
80008e0e:	c0 64       	brge	80008e1a <_vfprintf_r+0xe32>
80008e10:	fa cb f9 44 	sub	r11,sp,-1724
80008e14:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008e18:	c1 f8       	rjmp	80008e56 <_vfprintf_r+0xe6e>
80008e1a:	fa c8 f9 50 	sub	r8,sp,-1712
80008e1e:	1a d8       	st.w	--sp,r8
80008e20:	fa c8 fa b8 	sub	r8,sp,-1352
80008e24:	1a d8       	st.w	--sp,r8
80008e26:	fa c8 fb b4 	sub	r8,sp,-1100
80008e2a:	1a d8       	st.w	--sp,r8
80008e2c:	fa c8 f9 40 	sub	r8,sp,-1728
80008e30:	fa c9 ff b4 	sub	r9,sp,-76
80008e34:	04 9a       	mov	r10,r2
80008e36:	0c 9b       	mov	r11,r6
80008e38:	08 9c       	mov	r12,r4
80008e3a:	fe b0 f7 3f 	rcall	80007cb8 <get_arg>
80008e3e:	2f dd       	sub	sp,-12
80008e40:	98 18       	ld.sh	r8,r12[0x2]
80008e42:	c2 68       	rjmp	80008e8e <_vfprintf_r+0xea6>
80008e44:	ee ca ff ff 	sub	r10,r7,-1
80008e48:	10 37       	cp.w	r7,r8
80008e4a:	c0 94       	brge	80008e5c <_vfprintf_r+0xe74>
80008e4c:	fa c9 f9 44 	sub	r9,sp,-1724
80008e50:	14 97       	mov	r7,r10
80008e52:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008e56:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80008e5a:	c1 a8       	rjmp	80008e8e <_vfprintf_r+0xea6>
80008e5c:	41 09       	lddsp	r9,sp[0x40]
80008e5e:	59 f8       	cp.w	r8,31
80008e60:	e0 89 00 13 	brgt	80008e86 <_vfprintf_r+0xe9e>
80008e64:	f2 cb ff fc 	sub	r11,r9,-4
80008e68:	51 0b       	stdsp	sp[0x40],r11
80008e6a:	72 09       	ld.w	r9,r9[0x0]
80008e6c:	fa c6 f9 44 	sub	r6,sp,-1724
80008e70:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008e74:	2f f8       	sub	r8,-1
80008e76:	f7 49 fd 88 	st.w	r11[-632],r9
80008e7a:	fb 48 06 b4 	st.w	sp[1716],r8
80008e7e:	14 97       	mov	r7,r10
80008e80:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008e84:	c0 58       	rjmp	80008e8e <_vfprintf_r+0xea6>
80008e86:	92 18       	ld.sh	r8,r9[0x2]
80008e88:	14 97       	mov	r7,r10
80008e8a:	2f c9       	sub	r9,-4
80008e8c:	51 09       	stdsp	sp[0x40],r9
80008e8e:	5c 78       	castu.h	r8
80008e90:	50 18       	stdsp	sp[0x4],r8
80008e92:	c4 68       	rjmp	80008f1e <_vfprintf_r+0xf36>
80008e94:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008e98:	40 3c       	lddsp	r12,sp[0xc]
80008e9a:	58 0c       	cp.w	r12,0
80008e9c:	c1 d0       	breq	80008ed6 <_vfprintf_r+0xeee>
80008e9e:	10 36       	cp.w	r6,r8
80008ea0:	c0 64       	brge	80008eac <_vfprintf_r+0xec4>
80008ea2:	fa cb f9 44 	sub	r11,sp,-1724
80008ea6:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008eaa:	c1 f8       	rjmp	80008ee8 <_vfprintf_r+0xf00>
80008eac:	fa c8 f9 50 	sub	r8,sp,-1712
80008eb0:	1a d8       	st.w	--sp,r8
80008eb2:	fa c8 fa b8 	sub	r8,sp,-1352
80008eb6:	0c 9b       	mov	r11,r6
80008eb8:	1a d8       	st.w	--sp,r8
80008eba:	fa c8 fb b4 	sub	r8,sp,-1100
80008ebe:	04 9a       	mov	r10,r2
80008ec0:	1a d8       	st.w	--sp,r8
80008ec2:	08 9c       	mov	r12,r4
80008ec4:	fa c8 f9 40 	sub	r8,sp,-1728
80008ec8:	fa c9 ff b4 	sub	r9,sp,-76
80008ecc:	fe b0 f6 f6 	rcall	80007cb8 <get_arg>
80008ed0:	2f dd       	sub	sp,-12
80008ed2:	78 0b       	ld.w	r11,r12[0x0]
80008ed4:	c2 48       	rjmp	80008f1c <_vfprintf_r+0xf34>
80008ed6:	ee ca ff ff 	sub	r10,r7,-1
80008eda:	10 37       	cp.w	r7,r8
80008edc:	c0 94       	brge	80008eee <_vfprintf_r+0xf06>
80008ede:	fa c9 f9 44 	sub	r9,sp,-1724
80008ee2:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008ee6:	14 97       	mov	r7,r10
80008ee8:	ec fb fd 88 	ld.w	r11,r6[-632]
80008eec:	c1 88       	rjmp	80008f1c <_vfprintf_r+0xf34>
80008eee:	41 09       	lddsp	r9,sp[0x40]
80008ef0:	59 f8       	cp.w	r8,31
80008ef2:	e0 89 00 11 	brgt	80008f14 <_vfprintf_r+0xf2c>
80008ef6:	f2 cb ff fc 	sub	r11,r9,-4
80008efa:	51 0b       	stdsp	sp[0x40],r11
80008efc:	fa c6 f9 44 	sub	r6,sp,-1724
80008f00:	72 0b       	ld.w	r11,r9[0x0]
80008f02:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008f06:	f3 4b fd 88 	st.w	r9[-632],r11
80008f0a:	2f f8       	sub	r8,-1
80008f0c:	14 97       	mov	r7,r10
80008f0e:	fb 48 06 b4 	st.w	sp[1716],r8
80008f12:	c0 58       	rjmp	80008f1c <_vfprintf_r+0xf34>
80008f14:	72 0b       	ld.w	r11,r9[0x0]
80008f16:	14 97       	mov	r7,r10
80008f18:	2f c9       	sub	r9,-4
80008f1a:	51 09       	stdsp	sp[0x40],r9
80008f1c:	50 1b       	stdsp	sp[0x4],r11
80008f1e:	30 0e       	mov	lr,0
80008f20:	50 0e       	stdsp	sp[0x0],lr
80008f22:	1c 98       	mov	r8,lr
80008f24:	e0 8f 02 fe 	bral	80009520 <_vfprintf_r+0x1538>
80008f28:	50 a7       	stdsp	sp[0x28],r7
80008f2a:	50 80       	stdsp	sp[0x20],r0
80008f2c:	0c 97       	mov	r7,r6
80008f2e:	04 94       	mov	r4,r2
80008f30:	06 96       	mov	r6,r3
80008f32:	02 92       	mov	r2,r1
80008f34:	40 93       	lddsp	r3,sp[0x24]
80008f36:	40 41       	lddsp	r1,sp[0x10]
80008f38:	0e 99       	mov	r9,r7
80008f3a:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008f3e:	40 3c       	lddsp	r12,sp[0xc]
80008f40:	58 0c       	cp.w	r12,0
80008f42:	c1 d0       	breq	80008f7c <_vfprintf_r+0xf94>
80008f44:	10 36       	cp.w	r6,r8
80008f46:	c0 64       	brge	80008f52 <_vfprintf_r+0xf6a>
80008f48:	fa cb f9 44 	sub	r11,sp,-1724
80008f4c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008f50:	c1 d8       	rjmp	80008f8a <_vfprintf_r+0xfa2>
80008f52:	fa c8 f9 50 	sub	r8,sp,-1712
80008f56:	1a d8       	st.w	--sp,r8
80008f58:	fa c8 fa b8 	sub	r8,sp,-1352
80008f5c:	1a d8       	st.w	--sp,r8
80008f5e:	fa c8 fb b4 	sub	r8,sp,-1100
80008f62:	1a d8       	st.w	--sp,r8
80008f64:	fa c9 ff b4 	sub	r9,sp,-76
80008f68:	fa c8 f9 40 	sub	r8,sp,-1728
80008f6c:	04 9a       	mov	r10,r2
80008f6e:	0c 9b       	mov	r11,r6
80008f70:	08 9c       	mov	r12,r4
80008f72:	fe b0 f6 a3 	rcall	80007cb8 <get_arg>
80008f76:	2f dd       	sub	sp,-12
80008f78:	78 09       	ld.w	r9,r12[0x0]
80008f7a:	c2 18       	rjmp	80008fbc <_vfprintf_r+0xfd4>
80008f7c:	2f f7       	sub	r7,-1
80008f7e:	10 39       	cp.w	r9,r8
80008f80:	c0 84       	brge	80008f90 <_vfprintf_r+0xfa8>
80008f82:	fa ca f9 44 	sub	r10,sp,-1724
80008f86:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008f8a:	ec f9 fd 88 	ld.w	r9,r6[-632]
80008f8e:	c1 78       	rjmp	80008fbc <_vfprintf_r+0xfd4>
80008f90:	41 09       	lddsp	r9,sp[0x40]
80008f92:	59 f8       	cp.w	r8,31
80008f94:	e0 89 00 10 	brgt	80008fb4 <_vfprintf_r+0xfcc>
80008f98:	f2 ca ff fc 	sub	r10,r9,-4
80008f9c:	51 0a       	stdsp	sp[0x40],r10
80008f9e:	fa c6 f9 44 	sub	r6,sp,-1724
80008fa2:	72 09       	ld.w	r9,r9[0x0]
80008fa4:	ec 08 00 3a 	add	r10,r6,r8<<0x3
80008fa8:	f5 49 fd 88 	st.w	r10[-632],r9
80008fac:	2f f8       	sub	r8,-1
80008fae:	fb 48 06 b4 	st.w	sp[1716],r8
80008fb2:	c0 58       	rjmp	80008fbc <_vfprintf_r+0xfd4>
80008fb4:	f2 c8 ff fc 	sub	r8,r9,-4
80008fb8:	51 08       	stdsp	sp[0x40],r8
80008fba:	72 09       	ld.w	r9,r9[0x0]
80008fbc:	33 08       	mov	r8,48
80008fbe:	fb 68 06 b8 	st.b	sp[1720],r8
80008fc2:	37 88       	mov	r8,120
80008fc4:	30 0e       	mov	lr,0
80008fc6:	fb 68 06 b9 	st.b	sp[1721],r8
80008fca:	fe cc ad 02 	sub	r12,pc,-21246
80008fce:	50 19       	stdsp	sp[0x4],r9
80008fd0:	a1 b5       	sbr	r5,0x1
80008fd2:	50 0e       	stdsp	sp[0x0],lr
80008fd4:	50 dc       	stdsp	sp[0x34],r12
80008fd6:	30 28       	mov	r8,2
80008fd8:	37 80       	mov	r0,120
80008fda:	e0 8f 02 a3 	bral	80009520 <_vfprintf_r+0x1538>
80008fde:	50 a7       	stdsp	sp[0x28],r7
80008fe0:	50 80       	stdsp	sp[0x20],r0
80008fe2:	10 90       	mov	r0,r8
80008fe4:	30 08       	mov	r8,0
80008fe6:	fb 68 06 bb 	st.b	sp[1723],r8
80008fea:	0c 97       	mov	r7,r6
80008fec:	04 94       	mov	r4,r2
80008fee:	06 96       	mov	r6,r3
80008ff0:	02 92       	mov	r2,r1
80008ff2:	40 93       	lddsp	r3,sp[0x24]
80008ff4:	40 41       	lddsp	r1,sp[0x10]
80008ff6:	0e 99       	mov	r9,r7
80008ff8:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008ffc:	40 3b       	lddsp	r11,sp[0xc]
80008ffe:	58 0b       	cp.w	r11,0
80009000:	c1 d0       	breq	8000903a <_vfprintf_r+0x1052>
80009002:	10 36       	cp.w	r6,r8
80009004:	c0 64       	brge	80009010 <_vfprintf_r+0x1028>
80009006:	fa ca f9 44 	sub	r10,sp,-1724
8000900a:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000900e:	c1 d8       	rjmp	80009048 <_vfprintf_r+0x1060>
80009010:	fa c8 f9 50 	sub	r8,sp,-1712
80009014:	1a d8       	st.w	--sp,r8
80009016:	fa c8 fa b8 	sub	r8,sp,-1352
8000901a:	1a d8       	st.w	--sp,r8
8000901c:	fa c8 fb b4 	sub	r8,sp,-1100
80009020:	0c 9b       	mov	r11,r6
80009022:	1a d8       	st.w	--sp,r8
80009024:	04 9a       	mov	r10,r2
80009026:	fa c8 f9 40 	sub	r8,sp,-1728
8000902a:	fa c9 ff b4 	sub	r9,sp,-76
8000902e:	08 9c       	mov	r12,r4
80009030:	fe b0 f6 44 	rcall	80007cb8 <get_arg>
80009034:	2f dd       	sub	sp,-12
80009036:	78 06       	ld.w	r6,r12[0x0]
80009038:	c2 08       	rjmp	80009078 <_vfprintf_r+0x1090>
8000903a:	2f f7       	sub	r7,-1
8000903c:	10 39       	cp.w	r9,r8
8000903e:	c0 84       	brge	8000904e <_vfprintf_r+0x1066>
80009040:	fa c9 f9 44 	sub	r9,sp,-1724
80009044:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009048:	ec f6 fd 88 	ld.w	r6,r6[-632]
8000904c:	c1 68       	rjmp	80009078 <_vfprintf_r+0x1090>
8000904e:	41 09       	lddsp	r9,sp[0x40]
80009050:	59 f8       	cp.w	r8,31
80009052:	e0 89 00 10 	brgt	80009072 <_vfprintf_r+0x108a>
80009056:	f2 ca ff fc 	sub	r10,r9,-4
8000905a:	51 0a       	stdsp	sp[0x40],r10
8000905c:	72 06       	ld.w	r6,r9[0x0]
8000905e:	fa ce f9 44 	sub	lr,sp,-1724
80009062:	fc 08 00 39 	add	r9,lr,r8<<0x3
80009066:	f3 46 fd 88 	st.w	r9[-632],r6
8000906a:	2f f8       	sub	r8,-1
8000906c:	fb 48 06 b4 	st.w	sp[1716],r8
80009070:	c0 48       	rjmp	80009078 <_vfprintf_r+0x1090>
80009072:	72 06       	ld.w	r6,r9[0x0]
80009074:	2f c9       	sub	r9,-4
80009076:	51 09       	stdsp	sp[0x40],r9
80009078:	40 2c       	lddsp	r12,sp[0x8]
8000907a:	58 0c       	cp.w	r12,0
8000907c:	c1 05       	brlt	8000909c <_vfprintf_r+0x10b4>
8000907e:	18 9a       	mov	r10,r12
80009080:	30 0b       	mov	r11,0
80009082:	0c 9c       	mov	r12,r6
80009084:	e0 a0 12 38 	rcall	8000b4f4 <memchr>
80009088:	e0 80 02 df 	breq	80009646 <_vfprintf_r+0x165e>
8000908c:	f8 06 01 02 	sub	r2,r12,r6
80009090:	40 2b       	lddsp	r11,sp[0x8]
80009092:	16 32       	cp.w	r2,r11
80009094:	e0 89 02 d9 	brgt	80009646 <_vfprintf_r+0x165e>
80009098:	e0 8f 02 d4 	bral	80009640 <_vfprintf_r+0x1658>
8000909c:	30 0a       	mov	r10,0
8000909e:	0c 9c       	mov	r12,r6
800090a0:	50 2a       	stdsp	sp[0x8],r10
800090a2:	fe b0 f5 85 	rcall	80007bac <strlen>
800090a6:	18 92       	mov	r2,r12
800090a8:	e0 8f 02 d2 	bral	8000964c <_vfprintf_r+0x1664>
800090ac:	50 a7       	stdsp	sp[0x28],r7
800090ae:	50 80       	stdsp	sp[0x20],r0
800090b0:	0c 97       	mov	r7,r6
800090b2:	04 94       	mov	r4,r2
800090b4:	06 96       	mov	r6,r3
800090b6:	02 92       	mov	r2,r1
800090b8:	40 93       	lddsp	r3,sp[0x24]
800090ba:	10 90       	mov	r0,r8
800090bc:	40 41       	lddsp	r1,sp[0x10]
800090be:	a5 a5       	sbr	r5,0x4
800090c0:	c0 a8       	rjmp	800090d4 <_vfprintf_r+0x10ec>
800090c2:	50 a7       	stdsp	sp[0x28],r7
800090c4:	50 80       	stdsp	sp[0x20],r0
800090c6:	0c 97       	mov	r7,r6
800090c8:	04 94       	mov	r4,r2
800090ca:	06 96       	mov	r6,r3
800090cc:	02 92       	mov	r2,r1
800090ce:	40 93       	lddsp	r3,sp[0x24]
800090d0:	10 90       	mov	r0,r8
800090d2:	40 41       	lddsp	r1,sp[0x10]
800090d4:	ed b5 00 05 	bld	r5,0x5
800090d8:	c5 61       	brne	80009184 <_vfprintf_r+0x119c>
800090da:	fa f8 06 b4 	ld.w	r8,sp[1716]
800090de:	40 39       	lddsp	r9,sp[0xc]
800090e0:	58 09       	cp.w	r9,0
800090e2:	c2 10       	breq	80009124 <_vfprintf_r+0x113c>
800090e4:	10 36       	cp.w	r6,r8
800090e6:	c0 74       	brge	800090f4 <_vfprintf_r+0x110c>
800090e8:	fa c8 f9 44 	sub	r8,sp,-1724
800090ec:	f0 06 00 36 	add	r6,r8,r6<<0x3
800090f0:	c2 38       	rjmp	80009136 <_vfprintf_r+0x114e>
800090f2:	d7 03       	nop
800090f4:	fa c8 f9 50 	sub	r8,sp,-1712
800090f8:	1a d8       	st.w	--sp,r8
800090fa:	fa c8 fa b8 	sub	r8,sp,-1352
800090fe:	1a d8       	st.w	--sp,r8
80009100:	fa c8 fb b4 	sub	r8,sp,-1100
80009104:	1a d8       	st.w	--sp,r8
80009106:	fa c8 f9 40 	sub	r8,sp,-1728
8000910a:	fa c9 ff b4 	sub	r9,sp,-76
8000910e:	04 9a       	mov	r10,r2
80009110:	0c 9b       	mov	r11,r6
80009112:	08 9c       	mov	r12,r4
80009114:	fe b0 f5 d2 	rcall	80007cb8 <get_arg>
80009118:	2f dd       	sub	sp,-12
8000911a:	f8 e8 00 00 	ld.d	r8,r12[0]
8000911e:	fa e9 00 00 	st.d	sp[0],r8
80009122:	c2 e8       	rjmp	8000917e <_vfprintf_r+0x1196>
80009124:	ee ca ff ff 	sub	r10,r7,-1
80009128:	10 37       	cp.w	r7,r8
8000912a:	c0 b4       	brge	80009140 <_vfprintf_r+0x1158>
8000912c:	fa c8 f9 44 	sub	r8,sp,-1724
80009130:	14 97       	mov	r7,r10
80009132:	f0 06 00 36 	add	r6,r8,r6<<0x3
80009136:	ec ea fd 88 	ld.d	r10,r6[-632]
8000913a:	fa eb 00 00 	st.d	sp[0],r10
8000913e:	c2 08       	rjmp	8000917e <_vfprintf_r+0x1196>
80009140:	41 09       	lddsp	r9,sp[0x40]
80009142:	59 f8       	cp.w	r8,31
80009144:	e0 89 00 16 	brgt	80009170 <_vfprintf_r+0x1188>
80009148:	f2 e6 00 00 	ld.d	r6,r9[0]
8000914c:	f2 cb ff f8 	sub	r11,r9,-8
80009150:	fa e7 00 00 	st.d	sp[0],r6
80009154:	51 0b       	stdsp	sp[0x40],r11
80009156:	fa c6 f9 44 	sub	r6,sp,-1724
8000915a:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000915e:	fa e6 00 00 	ld.d	r6,sp[0]
80009162:	f2 e7 fd 88 	st.d	r9[-632],r6
80009166:	2f f8       	sub	r8,-1
80009168:	14 97       	mov	r7,r10
8000916a:	fb 48 06 b4 	st.w	sp[1716],r8
8000916e:	c0 88       	rjmp	8000917e <_vfprintf_r+0x1196>
80009170:	f2 e6 00 00 	ld.d	r6,r9[0]
80009174:	2f 89       	sub	r9,-8
80009176:	fa e7 00 00 	st.d	sp[0],r6
8000917a:	51 09       	stdsp	sp[0x40],r9
8000917c:	14 97       	mov	r7,r10
8000917e:	30 18       	mov	r8,1
80009180:	e0 8f 01 d0 	bral	80009520 <_vfprintf_r+0x1538>
80009184:	ed b5 00 04 	bld	r5,0x4
80009188:	c1 61       	brne	800091b4 <_vfprintf_r+0x11cc>
8000918a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000918e:	40 3e       	lddsp	lr,sp[0xc]
80009190:	58 0e       	cp.w	lr,0
80009192:	c0 80       	breq	800091a2 <_vfprintf_r+0x11ba>
80009194:	10 36       	cp.w	r6,r8
80009196:	c6 74       	brge	80009264 <_vfprintf_r+0x127c>
80009198:	fa cc f9 44 	sub	r12,sp,-1724
8000919c:	f8 06 00 36 	add	r6,r12,r6<<0x3
800091a0:	c8 08       	rjmp	800092a0 <_vfprintf_r+0x12b8>
800091a2:	ee ca ff ff 	sub	r10,r7,-1
800091a6:	10 37       	cp.w	r7,r8
800091a8:	c7 f4       	brge	800092a6 <_vfprintf_r+0x12be>
800091aa:	fa cb f9 44 	sub	r11,sp,-1724
800091ae:	f6 06 00 36 	add	r6,r11,r6<<0x3
800091b2:	c7 68       	rjmp	8000929e <_vfprintf_r+0x12b6>
800091b4:	ed b5 00 06 	bld	r5,0x6
800091b8:	c4 a1       	brne	8000924c <_vfprintf_r+0x1264>
800091ba:	fa f8 06 b4 	ld.w	r8,sp[1716]
800091be:	40 3c       	lddsp	r12,sp[0xc]
800091c0:	58 0c       	cp.w	r12,0
800091c2:	c1 d0       	breq	800091fc <_vfprintf_r+0x1214>
800091c4:	10 36       	cp.w	r6,r8
800091c6:	c0 64       	brge	800091d2 <_vfprintf_r+0x11ea>
800091c8:	fa cb f9 44 	sub	r11,sp,-1724
800091cc:	f6 06 00 36 	add	r6,r11,r6<<0x3
800091d0:	c1 f8       	rjmp	8000920e <_vfprintf_r+0x1226>
800091d2:	fa c8 f9 50 	sub	r8,sp,-1712
800091d6:	1a d8       	st.w	--sp,r8
800091d8:	fa c8 fa b8 	sub	r8,sp,-1352
800091dc:	1a d8       	st.w	--sp,r8
800091de:	fa c8 fb b4 	sub	r8,sp,-1100
800091e2:	1a d8       	st.w	--sp,r8
800091e4:	fa c8 f9 40 	sub	r8,sp,-1728
800091e8:	fa c9 ff b4 	sub	r9,sp,-76
800091ec:	04 9a       	mov	r10,r2
800091ee:	0c 9b       	mov	r11,r6
800091f0:	08 9c       	mov	r12,r4
800091f2:	fe b0 f5 63 	rcall	80007cb8 <get_arg>
800091f6:	2f dd       	sub	sp,-12
800091f8:	98 18       	ld.sh	r8,r12[0x2]
800091fa:	c2 68       	rjmp	80009246 <_vfprintf_r+0x125e>
800091fc:	ee ca ff ff 	sub	r10,r7,-1
80009200:	10 37       	cp.w	r7,r8
80009202:	c0 94       	brge	80009214 <_vfprintf_r+0x122c>
80009204:	fa c9 f9 44 	sub	r9,sp,-1724
80009208:	14 97       	mov	r7,r10
8000920a:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000920e:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80009212:	c1 a8       	rjmp	80009246 <_vfprintf_r+0x125e>
80009214:	41 09       	lddsp	r9,sp[0x40]
80009216:	59 f8       	cp.w	r8,31
80009218:	e0 89 00 13 	brgt	8000923e <_vfprintf_r+0x1256>
8000921c:	f2 cb ff fc 	sub	r11,r9,-4
80009220:	51 0b       	stdsp	sp[0x40],r11
80009222:	72 09       	ld.w	r9,r9[0x0]
80009224:	fa c6 f9 44 	sub	r6,sp,-1724
80009228:	ec 08 00 3b 	add	r11,r6,r8<<0x3
8000922c:	2f f8       	sub	r8,-1
8000922e:	f7 49 fd 88 	st.w	r11[-632],r9
80009232:	fb 48 06 b4 	st.w	sp[1716],r8
80009236:	14 97       	mov	r7,r10
80009238:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
8000923c:	c0 58       	rjmp	80009246 <_vfprintf_r+0x125e>
8000923e:	92 18       	ld.sh	r8,r9[0x2]
80009240:	14 97       	mov	r7,r10
80009242:	2f c9       	sub	r9,-4
80009244:	51 09       	stdsp	sp[0x40],r9
80009246:	5c 78       	castu.h	r8
80009248:	50 18       	stdsp	sp[0x4],r8
8000924a:	c4 68       	rjmp	800092d6 <_vfprintf_r+0x12ee>
8000924c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009250:	40 3c       	lddsp	r12,sp[0xc]
80009252:	58 0c       	cp.w	r12,0
80009254:	c1 d0       	breq	8000928e <_vfprintf_r+0x12a6>
80009256:	10 36       	cp.w	r6,r8
80009258:	c0 64       	brge	80009264 <_vfprintf_r+0x127c>
8000925a:	fa cb f9 44 	sub	r11,sp,-1724
8000925e:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009262:	c1 f8       	rjmp	800092a0 <_vfprintf_r+0x12b8>
80009264:	fa c8 f9 50 	sub	r8,sp,-1712
80009268:	1a d8       	st.w	--sp,r8
8000926a:	fa c8 fa b8 	sub	r8,sp,-1352
8000926e:	0c 9b       	mov	r11,r6
80009270:	1a d8       	st.w	--sp,r8
80009272:	fa c8 fb b4 	sub	r8,sp,-1100
80009276:	04 9a       	mov	r10,r2
80009278:	1a d8       	st.w	--sp,r8
8000927a:	08 9c       	mov	r12,r4
8000927c:	fa c8 f9 40 	sub	r8,sp,-1728
80009280:	fa c9 ff b4 	sub	r9,sp,-76
80009284:	fe b0 f5 1a 	rcall	80007cb8 <get_arg>
80009288:	2f dd       	sub	sp,-12
8000928a:	78 0b       	ld.w	r11,r12[0x0]
8000928c:	c2 48       	rjmp	800092d4 <_vfprintf_r+0x12ec>
8000928e:	ee ca ff ff 	sub	r10,r7,-1
80009292:	10 37       	cp.w	r7,r8
80009294:	c0 94       	brge	800092a6 <_vfprintf_r+0x12be>
80009296:	fa c9 f9 44 	sub	r9,sp,-1724
8000929a:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000929e:	14 97       	mov	r7,r10
800092a0:	ec fb fd 88 	ld.w	r11,r6[-632]
800092a4:	c1 88       	rjmp	800092d4 <_vfprintf_r+0x12ec>
800092a6:	41 09       	lddsp	r9,sp[0x40]
800092a8:	59 f8       	cp.w	r8,31
800092aa:	e0 89 00 11 	brgt	800092cc <_vfprintf_r+0x12e4>
800092ae:	f2 cb ff fc 	sub	r11,r9,-4
800092b2:	51 0b       	stdsp	sp[0x40],r11
800092b4:	fa c6 f9 44 	sub	r6,sp,-1724
800092b8:	72 0b       	ld.w	r11,r9[0x0]
800092ba:	ec 08 00 39 	add	r9,r6,r8<<0x3
800092be:	f3 4b fd 88 	st.w	r9[-632],r11
800092c2:	2f f8       	sub	r8,-1
800092c4:	14 97       	mov	r7,r10
800092c6:	fb 48 06 b4 	st.w	sp[1716],r8
800092ca:	c0 58       	rjmp	800092d4 <_vfprintf_r+0x12ec>
800092cc:	72 0b       	ld.w	r11,r9[0x0]
800092ce:	14 97       	mov	r7,r10
800092d0:	2f c9       	sub	r9,-4
800092d2:	51 09       	stdsp	sp[0x40],r9
800092d4:	50 1b       	stdsp	sp[0x4],r11
800092d6:	30 0e       	mov	lr,0
800092d8:	30 18       	mov	r8,1
800092da:	50 0e       	stdsp	sp[0x0],lr
800092dc:	c2 29       	rjmp	80009520 <_vfprintf_r+0x1538>
800092de:	50 a7       	stdsp	sp[0x28],r7
800092e0:	50 80       	stdsp	sp[0x20],r0
800092e2:	0c 97       	mov	r7,r6
800092e4:	04 94       	mov	r4,r2
800092e6:	06 96       	mov	r6,r3
800092e8:	02 92       	mov	r2,r1
800092ea:	fe cc b0 22 	sub	r12,pc,-20446
800092ee:	40 93       	lddsp	r3,sp[0x24]
800092f0:	10 90       	mov	r0,r8
800092f2:	40 41       	lddsp	r1,sp[0x10]
800092f4:	50 dc       	stdsp	sp[0x34],r12
800092f6:	ed b5 00 05 	bld	r5,0x5
800092fa:	c5 51       	brne	800093a4 <_vfprintf_r+0x13bc>
800092fc:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009300:	40 3b       	lddsp	r11,sp[0xc]
80009302:	58 0b       	cp.w	r11,0
80009304:	c2 20       	breq	80009348 <_vfprintf_r+0x1360>
80009306:	10 36       	cp.w	r6,r8
80009308:	c0 a4       	brge	8000931c <_vfprintf_r+0x1334>
8000930a:	fa ca f9 44 	sub	r10,sp,-1724
8000930e:	f4 06 00 36 	add	r6,r10,r6<<0x3
80009312:	ec e8 fd 88 	ld.d	r8,r6[-632]
80009316:	fa e9 00 00 	st.d	sp[0],r8
8000931a:	cf 28       	rjmp	800094fe <_vfprintf_r+0x1516>
8000931c:	fa c8 f9 50 	sub	r8,sp,-1712
80009320:	1a d8       	st.w	--sp,r8
80009322:	fa c8 fa b8 	sub	r8,sp,-1352
80009326:	04 9a       	mov	r10,r2
80009328:	1a d8       	st.w	--sp,r8
8000932a:	0c 9b       	mov	r11,r6
8000932c:	fa c8 fb b4 	sub	r8,sp,-1100
80009330:	08 9c       	mov	r12,r4
80009332:	1a d8       	st.w	--sp,r8
80009334:	fa c8 f9 40 	sub	r8,sp,-1728
80009338:	fa c9 ff b4 	sub	r9,sp,-76
8000933c:	fe b0 f4 be 	rcall	80007cb8 <get_arg>
80009340:	2f dd       	sub	sp,-12
80009342:	f8 ea 00 00 	ld.d	r10,r12[0]
80009346:	c0 c8       	rjmp	8000935e <_vfprintf_r+0x1376>
80009348:	ee ca ff ff 	sub	r10,r7,-1
8000934c:	10 37       	cp.w	r7,r8
8000934e:	c0 b4       	brge	80009364 <_vfprintf_r+0x137c>
80009350:	fa c9 f9 44 	sub	r9,sp,-1724
80009354:	14 97       	mov	r7,r10
80009356:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000935a:	ec ea fd 88 	ld.d	r10,r6[-632]
8000935e:	fa eb 00 00 	st.d	sp[0],r10
80009362:	cc e8       	rjmp	800094fe <_vfprintf_r+0x1516>
80009364:	41 09       	lddsp	r9,sp[0x40]
80009366:	59 f8       	cp.w	r8,31
80009368:	e0 89 00 16 	brgt	80009394 <_vfprintf_r+0x13ac>
8000936c:	f2 e6 00 00 	ld.d	r6,r9[0]
80009370:	f2 cb ff f8 	sub	r11,r9,-8
80009374:	fa e7 00 00 	st.d	sp[0],r6
80009378:	51 0b       	stdsp	sp[0x40],r11
8000937a:	fa c6 f9 44 	sub	r6,sp,-1724
8000937e:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009382:	fa e6 00 00 	ld.d	r6,sp[0]
80009386:	f2 e7 fd 88 	st.d	r9[-632],r6
8000938a:	2f f8       	sub	r8,-1
8000938c:	14 97       	mov	r7,r10
8000938e:	fb 48 06 b4 	st.w	sp[1716],r8
80009392:	cb 68       	rjmp	800094fe <_vfprintf_r+0x1516>
80009394:	f2 e6 00 00 	ld.d	r6,r9[0]
80009398:	2f 89       	sub	r9,-8
8000939a:	fa e7 00 00 	st.d	sp[0],r6
8000939e:	51 09       	stdsp	sp[0x40],r9
800093a0:	14 97       	mov	r7,r10
800093a2:	ca e8       	rjmp	800094fe <_vfprintf_r+0x1516>
800093a4:	ed b5 00 04 	bld	r5,0x4
800093a8:	c1 71       	brne	800093d6 <_vfprintf_r+0x13ee>
800093aa:	fa f8 06 b4 	ld.w	r8,sp[1716]
800093ae:	40 3e       	lddsp	lr,sp[0xc]
800093b0:	58 0e       	cp.w	lr,0
800093b2:	c0 80       	breq	800093c2 <_vfprintf_r+0x13da>
800093b4:	10 36       	cp.w	r6,r8
800093b6:	c6 94       	brge	80009488 <_vfprintf_r+0x14a0>
800093b8:	fa cc f9 44 	sub	r12,sp,-1724
800093bc:	f8 06 00 36 	add	r6,r12,r6<<0x3
800093c0:	c8 28       	rjmp	800094c4 <_vfprintf_r+0x14dc>
800093c2:	ee ca ff ff 	sub	r10,r7,-1
800093c6:	10 37       	cp.w	r7,r8
800093c8:	e0 84 00 81 	brge	800094ca <_vfprintf_r+0x14e2>
800093cc:	fa cb f9 44 	sub	r11,sp,-1724
800093d0:	f6 06 00 36 	add	r6,r11,r6<<0x3
800093d4:	c7 78       	rjmp	800094c2 <_vfprintf_r+0x14da>
800093d6:	ed b5 00 06 	bld	r5,0x6
800093da:	c4 b1       	brne	80009470 <_vfprintf_r+0x1488>
800093dc:	fa f8 06 b4 	ld.w	r8,sp[1716]
800093e0:	40 3c       	lddsp	r12,sp[0xc]
800093e2:	58 0c       	cp.w	r12,0
800093e4:	c1 d0       	breq	8000941e <_vfprintf_r+0x1436>
800093e6:	10 36       	cp.w	r6,r8
800093e8:	c0 64       	brge	800093f4 <_vfprintf_r+0x140c>
800093ea:	fa cb f9 44 	sub	r11,sp,-1724
800093ee:	f6 06 00 36 	add	r6,r11,r6<<0x3
800093f2:	c1 f8       	rjmp	80009430 <_vfprintf_r+0x1448>
800093f4:	fa c8 f9 50 	sub	r8,sp,-1712
800093f8:	1a d8       	st.w	--sp,r8
800093fa:	fa c8 fa b8 	sub	r8,sp,-1352
800093fe:	1a d8       	st.w	--sp,r8
80009400:	fa c8 fb b4 	sub	r8,sp,-1100
80009404:	1a d8       	st.w	--sp,r8
80009406:	fa c8 f9 40 	sub	r8,sp,-1728
8000940a:	fa c9 ff b4 	sub	r9,sp,-76
8000940e:	04 9a       	mov	r10,r2
80009410:	0c 9b       	mov	r11,r6
80009412:	08 9c       	mov	r12,r4
80009414:	fe b0 f4 52 	rcall	80007cb8 <get_arg>
80009418:	2f dd       	sub	sp,-12
8000941a:	98 18       	ld.sh	r8,r12[0x2]
8000941c:	c2 78       	rjmp	8000946a <_vfprintf_r+0x1482>
8000941e:	ee ca ff ff 	sub	r10,r7,-1
80009422:	10 37       	cp.w	r7,r8
80009424:	c0 a4       	brge	80009438 <_vfprintf_r+0x1450>
80009426:	fa c9 f9 44 	sub	r9,sp,-1724
8000942a:	14 97       	mov	r7,r10
8000942c:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009430:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80009434:	c1 b8       	rjmp	8000946a <_vfprintf_r+0x1482>
80009436:	d7 03       	nop
80009438:	41 09       	lddsp	r9,sp[0x40]
8000943a:	59 f8       	cp.w	r8,31
8000943c:	e0 89 00 13 	brgt	80009462 <_vfprintf_r+0x147a>
80009440:	f2 cb ff fc 	sub	r11,r9,-4
80009444:	51 0b       	stdsp	sp[0x40],r11
80009446:	72 09       	ld.w	r9,r9[0x0]
80009448:	fa c6 f9 44 	sub	r6,sp,-1724
8000944c:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80009450:	2f f8       	sub	r8,-1
80009452:	f7 49 fd 88 	st.w	r11[-632],r9
80009456:	fb 48 06 b4 	st.w	sp[1716],r8
8000945a:	14 97       	mov	r7,r10
8000945c:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80009460:	c0 58       	rjmp	8000946a <_vfprintf_r+0x1482>
80009462:	92 18       	ld.sh	r8,r9[0x2]
80009464:	14 97       	mov	r7,r10
80009466:	2f c9       	sub	r9,-4
80009468:	51 09       	stdsp	sp[0x40],r9
8000946a:	5c 78       	castu.h	r8
8000946c:	50 18       	stdsp	sp[0x4],r8
8000946e:	c4 68       	rjmp	800094fa <_vfprintf_r+0x1512>
80009470:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009474:	40 3c       	lddsp	r12,sp[0xc]
80009476:	58 0c       	cp.w	r12,0
80009478:	c1 d0       	breq	800094b2 <_vfprintf_r+0x14ca>
8000947a:	10 36       	cp.w	r6,r8
8000947c:	c0 64       	brge	80009488 <_vfprintf_r+0x14a0>
8000947e:	fa cb f9 44 	sub	r11,sp,-1724
80009482:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009486:	c1 f8       	rjmp	800094c4 <_vfprintf_r+0x14dc>
80009488:	fa c8 f9 50 	sub	r8,sp,-1712
8000948c:	1a d8       	st.w	--sp,r8
8000948e:	fa c8 fa b8 	sub	r8,sp,-1352
80009492:	0c 9b       	mov	r11,r6
80009494:	1a d8       	st.w	--sp,r8
80009496:	fa c8 fb b4 	sub	r8,sp,-1100
8000949a:	04 9a       	mov	r10,r2
8000949c:	1a d8       	st.w	--sp,r8
8000949e:	08 9c       	mov	r12,r4
800094a0:	fa c8 f9 40 	sub	r8,sp,-1728
800094a4:	fa c9 ff b4 	sub	r9,sp,-76
800094a8:	fe b0 f4 08 	rcall	80007cb8 <get_arg>
800094ac:	2f dd       	sub	sp,-12
800094ae:	78 0b       	ld.w	r11,r12[0x0]
800094b0:	c2 48       	rjmp	800094f8 <_vfprintf_r+0x1510>
800094b2:	ee ca ff ff 	sub	r10,r7,-1
800094b6:	10 37       	cp.w	r7,r8
800094b8:	c0 94       	brge	800094ca <_vfprintf_r+0x14e2>
800094ba:	fa c9 f9 44 	sub	r9,sp,-1724
800094be:	f2 06 00 36 	add	r6,r9,r6<<0x3
800094c2:	14 97       	mov	r7,r10
800094c4:	ec fb fd 88 	ld.w	r11,r6[-632]
800094c8:	c1 88       	rjmp	800094f8 <_vfprintf_r+0x1510>
800094ca:	41 09       	lddsp	r9,sp[0x40]
800094cc:	59 f8       	cp.w	r8,31
800094ce:	e0 89 00 11 	brgt	800094f0 <_vfprintf_r+0x1508>
800094d2:	f2 cb ff fc 	sub	r11,r9,-4
800094d6:	51 0b       	stdsp	sp[0x40],r11
800094d8:	fa c6 f9 44 	sub	r6,sp,-1724
800094dc:	72 0b       	ld.w	r11,r9[0x0]
800094de:	ec 08 00 39 	add	r9,r6,r8<<0x3
800094e2:	f3 4b fd 88 	st.w	r9[-632],r11
800094e6:	2f f8       	sub	r8,-1
800094e8:	14 97       	mov	r7,r10
800094ea:	fb 48 06 b4 	st.w	sp[1716],r8
800094ee:	c0 58       	rjmp	800094f8 <_vfprintf_r+0x1510>
800094f0:	72 0b       	ld.w	r11,r9[0x0]
800094f2:	14 97       	mov	r7,r10
800094f4:	2f c9       	sub	r9,-4
800094f6:	51 09       	stdsp	sp[0x40],r9
800094f8:	50 1b       	stdsp	sp[0x4],r11
800094fa:	30 0e       	mov	lr,0
800094fc:	50 0e       	stdsp	sp[0x0],lr
800094fe:	40 08       	lddsp	r8,sp[0x0]
80009500:	40 1c       	lddsp	r12,sp[0x4]
80009502:	18 48       	or	r8,r12
80009504:	5f 19       	srne	r9
80009506:	0a 98       	mov	r8,r5
80009508:	eb e9 00 09 	and	r9,r5,r9
8000950c:	a1 b8       	sbr	r8,0x1
8000950e:	58 09       	cp.w	r9,0
80009510:	c0 70       	breq	8000951e <_vfprintf_r+0x1536>
80009512:	10 95       	mov	r5,r8
80009514:	fb 60 06 b9 	st.b	sp[1721],r0
80009518:	33 08       	mov	r8,48
8000951a:	fb 68 06 b8 	st.b	sp[1720],r8
8000951e:	30 28       	mov	r8,2
80009520:	30 09       	mov	r9,0
80009522:	fb 69 06 bb 	st.b	sp[1723],r9
80009526:	0a 99       	mov	r9,r5
80009528:	a7 d9       	cbr	r9,0x7
8000952a:	40 2b       	lddsp	r11,sp[0x8]
8000952c:	40 16       	lddsp	r6,sp[0x4]
8000952e:	58 0b       	cp.w	r11,0
80009530:	5f 1a       	srne	r10
80009532:	f2 05 17 40 	movge	r5,r9
80009536:	fa c2 f9 78 	sub	r2,sp,-1672
8000953a:	40 09       	lddsp	r9,sp[0x0]
8000953c:	0c 49       	or	r9,r6
8000953e:	5f 19       	srne	r9
80009540:	f5 e9 10 09 	or	r9,r10,r9
80009544:	c5 c0       	breq	800095fc <_vfprintf_r+0x1614>
80009546:	30 19       	mov	r9,1
80009548:	f2 08 18 00 	cp.b	r8,r9
8000954c:	c0 60       	breq	80009558 <_vfprintf_r+0x1570>
8000954e:	30 29       	mov	r9,2
80009550:	f2 08 18 00 	cp.b	r8,r9
80009554:	c0 41       	brne	8000955c <_vfprintf_r+0x1574>
80009556:	c3 c8       	rjmp	800095ce <_vfprintf_r+0x15e6>
80009558:	04 96       	mov	r6,r2
8000955a:	c3 08       	rjmp	800095ba <_vfprintf_r+0x15d2>
8000955c:	04 96       	mov	r6,r2
8000955e:	fa e8 00 00 	ld.d	r8,sp[0]
80009562:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
80009566:	2d 0a       	sub	r10,-48
80009568:	0c fa       	st.b	--r6,r10
8000956a:	f0 0b 16 03 	lsr	r11,r8,0x3
8000956e:	f2 0c 16 03 	lsr	r12,r9,0x3
80009572:	f7 e9 11 db 	or	r11,r11,r9<<0x1d
80009576:	18 99       	mov	r9,r12
80009578:	16 98       	mov	r8,r11
8000957a:	58 08       	cp.w	r8,0
8000957c:	5c 29       	cpc	r9
8000957e:	cf 21       	brne	80009562 <_vfprintf_r+0x157a>
80009580:	fa e9 00 00 	st.d	sp[0],r8
80009584:	ed b5 00 00 	bld	r5,0x0
80009588:	c4 51       	brne	80009612 <_vfprintf_r+0x162a>
8000958a:	33 09       	mov	r9,48
8000958c:	f2 0a 18 00 	cp.b	r10,r9
80009590:	c4 10       	breq	80009612 <_vfprintf_r+0x162a>
80009592:	0c f9       	st.b	--r6,r9
80009594:	c3 f8       	rjmp	80009612 <_vfprintf_r+0x162a>
80009596:	fa ea 00 00 	ld.d	r10,sp[0]
8000959a:	30 a8       	mov	r8,10
8000959c:	30 09       	mov	r9,0
8000959e:	e0 a0 1a 0d 	rcall	8000c9b8 <__avr32_umod64>
800095a2:	30 a8       	mov	r8,10
800095a4:	2d 0a       	sub	r10,-48
800095a6:	30 09       	mov	r9,0
800095a8:	ac 8a       	st.b	r6[0x0],r10
800095aa:	fa ea 00 00 	ld.d	r10,sp[0]
800095ae:	e0 a0 18 d3 	rcall	8000c754 <__avr32_udiv64>
800095b2:	16 99       	mov	r9,r11
800095b4:	14 98       	mov	r8,r10
800095b6:	fa e9 00 00 	st.d	sp[0],r8
800095ba:	20 16       	sub	r6,1
800095bc:	fa ea 00 00 	ld.d	r10,sp[0]
800095c0:	58 9a       	cp.w	r10,9
800095c2:	5c 2b       	cpc	r11
800095c4:	fe 9b ff e9 	brhi	80009596 <_vfprintf_r+0x15ae>
800095c8:	1b f8       	ld.ub	r8,sp[0x7]
800095ca:	2d 08       	sub	r8,-48
800095cc:	c2 08       	rjmp	8000960c <_vfprintf_r+0x1624>
800095ce:	04 96       	mov	r6,r2
800095d0:	fa e8 00 00 	ld.d	r8,sp[0]
800095d4:	f5 d8 c0 04 	bfextu	r10,r8,0x0,0x4
800095d8:	40 de       	lddsp	lr,sp[0x34]
800095da:	fc 0a 07 0a 	ld.ub	r10,lr[r10]
800095de:	0c fa       	st.b	--r6,r10
800095e0:	f2 0b 16 04 	lsr	r11,r9,0x4
800095e4:	f0 0a 16 04 	lsr	r10,r8,0x4
800095e8:	f5 e9 11 ca 	or	r10,r10,r9<<0x1c
800095ec:	16 99       	mov	r9,r11
800095ee:	14 98       	mov	r8,r10
800095f0:	58 08       	cp.w	r8,0
800095f2:	5c 29       	cpc	r9
800095f4:	cf 01       	brne	800095d4 <_vfprintf_r+0x15ec>
800095f6:	fa e9 00 00 	st.d	sp[0],r8
800095fa:	c0 c8       	rjmp	80009612 <_vfprintf_r+0x162a>
800095fc:	58 08       	cp.w	r8,0
800095fe:	c0 91       	brne	80009610 <_vfprintf_r+0x1628>
80009600:	ed b5 00 00 	bld	r5,0x0
80009604:	c0 61       	brne	80009610 <_vfprintf_r+0x1628>
80009606:	fa c6 f9 79 	sub	r6,sp,-1671
8000960a:	33 08       	mov	r8,48
8000960c:	ac 88       	st.b	r6[0x0],r8
8000960e:	c0 28       	rjmp	80009612 <_vfprintf_r+0x162a>
80009610:	04 96       	mov	r6,r2
80009612:	0c 12       	sub	r2,r6
80009614:	c1 c8       	rjmp	8000964c <_vfprintf_r+0x1664>
80009616:	50 a7       	stdsp	sp[0x28],r7
80009618:	50 80       	stdsp	sp[0x20],r0
8000961a:	40 93       	lddsp	r3,sp[0x24]
8000961c:	0c 97       	mov	r7,r6
8000961e:	10 90       	mov	r0,r8
80009620:	04 94       	mov	r4,r2
80009622:	40 41       	lddsp	r1,sp[0x10]
80009624:	58 08       	cp.w	r8,0
80009626:	e0 80 04 4f 	breq	80009ec4 <_vfprintf_r+0x1edc>
8000962a:	fb 68 06 60 	st.b	sp[1632],r8
8000962e:	30 0c       	mov	r12,0
80009630:	30 08       	mov	r8,0
80009632:	30 12       	mov	r2,1
80009634:	fb 68 06 bb 	st.b	sp[1723],r8
80009638:	50 2c       	stdsp	sp[0x8],r12
8000963a:	fa c6 f9 a0 	sub	r6,sp,-1632
8000963e:	c0 78       	rjmp	8000964c <_vfprintf_r+0x1664>
80009640:	30 0b       	mov	r11,0
80009642:	50 2b       	stdsp	sp[0x8],r11
80009644:	c0 48       	rjmp	8000964c <_vfprintf_r+0x1664>
80009646:	40 22       	lddsp	r2,sp[0x8]
80009648:	30 0a       	mov	r10,0
8000964a:	50 2a       	stdsp	sp[0x8],r10
8000964c:	40 29       	lddsp	r9,sp[0x8]
8000964e:	e4 09 0c 49 	max	r9,r2,r9
80009652:	fb 38 06 bb 	ld.ub	r8,sp[1723]
80009656:	50 39       	stdsp	sp[0xc],r9
80009658:	0a 9e       	mov	lr,r5
8000965a:	30 09       	mov	r9,0
8000965c:	e2 1e 00 02 	andl	lr,0x2,COH
80009660:	f2 08 18 00 	cp.b	r8,r9
80009664:	fb f8 10 03 	ld.wne	r8,sp[0xc]
80009668:	f7 b8 01 ff 	subne	r8,-1
8000966c:	fb f8 1a 03 	st.wne	sp[0xc],r8
80009670:	0a 9b       	mov	r11,r5
80009672:	58 0e       	cp.w	lr,0
80009674:	fb fc 10 03 	ld.wne	r12,sp[0xc]
80009678:	f7 bc 01 fe 	subne	r12,-2
8000967c:	fb fc 1a 03 	st.wne	sp[0xc],r12
80009680:	e2 1b 00 84 	andl	r11,0x84,COH
80009684:	50 fe       	stdsp	sp[0x3c],lr
80009686:	50 9b       	stdsp	sp[0x24],r11
80009688:	c4 71       	brne	80009716 <_vfprintf_r+0x172e>
8000968a:	40 8a       	lddsp	r10,sp[0x20]
8000968c:	40 39       	lddsp	r9,sp[0xc]
8000968e:	12 1a       	sub	r10,r9
80009690:	50 4a       	stdsp	sp[0x10],r10
80009692:	58 0a       	cp.w	r10,0
80009694:	e0 89 00 20 	brgt	800096d4 <_vfprintf_r+0x16ec>
80009698:	c3 f8       	rjmp	80009716 <_vfprintf_r+0x172e>
8000969a:	2f 09       	sub	r9,-16
8000969c:	2f f8       	sub	r8,-1
8000969e:	fe ce b3 be 	sub	lr,pc,-19522
800096a2:	31 0c       	mov	r12,16
800096a4:	fb 49 06 90 	st.w	sp[1680],r9
800096a8:	87 0e       	st.w	r3[0x0],lr
800096aa:	87 1c       	st.w	r3[0x4],r12
800096ac:	fb 48 06 8c 	st.w	sp[1676],r8
800096b0:	58 78       	cp.w	r8,7
800096b2:	e0 89 00 04 	brgt	800096ba <_vfprintf_r+0x16d2>
800096b6:	2f 83       	sub	r3,-8
800096b8:	c0 b8       	rjmp	800096ce <_vfprintf_r+0x16e6>
800096ba:	fa ca f9 78 	sub	r10,sp,-1672
800096be:	02 9b       	mov	r11,r1
800096c0:	08 9c       	mov	r12,r4
800096c2:	fe b0 f4 85 	rcall	80007fcc <__sprint_r>
800096c6:	e0 81 04 10 	brne	80009ee6 <_vfprintf_r+0x1efe>
800096ca:	fa c3 f9 e0 	sub	r3,sp,-1568
800096ce:	40 4b       	lddsp	r11,sp[0x10]
800096d0:	21 0b       	sub	r11,16
800096d2:	50 4b       	stdsp	sp[0x10],r11
800096d4:	fa f9 06 90 	ld.w	r9,sp[1680]
800096d8:	fa f8 06 8c 	ld.w	r8,sp[1676]
800096dc:	fe ca b3 fc 	sub	r10,pc,-19460
800096e0:	40 4e       	lddsp	lr,sp[0x10]
800096e2:	59 0e       	cp.w	lr,16
800096e4:	fe 99 ff db 	brgt	8000969a <_vfprintf_r+0x16b2>
800096e8:	1c 09       	add	r9,lr
800096ea:	2f f8       	sub	r8,-1
800096ec:	87 0a       	st.w	r3[0x0],r10
800096ee:	fb 49 06 90 	st.w	sp[1680],r9
800096f2:	87 1e       	st.w	r3[0x4],lr
800096f4:	fb 48 06 8c 	st.w	sp[1676],r8
800096f8:	58 78       	cp.w	r8,7
800096fa:	e0 89 00 04 	brgt	80009702 <_vfprintf_r+0x171a>
800096fe:	2f 83       	sub	r3,-8
80009700:	c0 b8       	rjmp	80009716 <_vfprintf_r+0x172e>
80009702:	fa ca f9 78 	sub	r10,sp,-1672
80009706:	02 9b       	mov	r11,r1
80009708:	08 9c       	mov	r12,r4
8000970a:	fe b0 f4 61 	rcall	80007fcc <__sprint_r>
8000970e:	e0 81 03 ec 	brne	80009ee6 <_vfprintf_r+0x1efe>
80009712:	fa c3 f9 e0 	sub	r3,sp,-1568
80009716:	30 09       	mov	r9,0
80009718:	fb 38 06 bb 	ld.ub	r8,sp[1723]
8000971c:	f2 08 18 00 	cp.b	r8,r9
80009720:	c1 f0       	breq	8000975e <_vfprintf_r+0x1776>
80009722:	fa f8 06 90 	ld.w	r8,sp[1680]
80009726:	fa c9 f9 45 	sub	r9,sp,-1723
8000972a:	2f f8       	sub	r8,-1
8000972c:	87 09       	st.w	r3[0x0],r9
8000972e:	fb 48 06 90 	st.w	sp[1680],r8
80009732:	30 19       	mov	r9,1
80009734:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009738:	87 19       	st.w	r3[0x4],r9
8000973a:	2f f8       	sub	r8,-1
8000973c:	fb 48 06 8c 	st.w	sp[1676],r8
80009740:	58 78       	cp.w	r8,7
80009742:	e0 89 00 04 	brgt	8000974a <_vfprintf_r+0x1762>
80009746:	2f 83       	sub	r3,-8
80009748:	c0 b8       	rjmp	8000975e <_vfprintf_r+0x1776>
8000974a:	fa ca f9 78 	sub	r10,sp,-1672
8000974e:	02 9b       	mov	r11,r1
80009750:	08 9c       	mov	r12,r4
80009752:	fe b0 f4 3d 	rcall	80007fcc <__sprint_r>
80009756:	e0 81 03 c8 	brne	80009ee6 <_vfprintf_r+0x1efe>
8000975a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000975e:	40 fc       	lddsp	r12,sp[0x3c]
80009760:	58 0c       	cp.w	r12,0
80009762:	c1 f0       	breq	800097a0 <_vfprintf_r+0x17b8>
80009764:	fa f8 06 90 	ld.w	r8,sp[1680]
80009768:	fa c9 f9 48 	sub	r9,sp,-1720
8000976c:	2f e8       	sub	r8,-2
8000976e:	87 09       	st.w	r3[0x0],r9
80009770:	fb 48 06 90 	st.w	sp[1680],r8
80009774:	30 29       	mov	r9,2
80009776:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000977a:	87 19       	st.w	r3[0x4],r9
8000977c:	2f f8       	sub	r8,-1
8000977e:	fb 48 06 8c 	st.w	sp[1676],r8
80009782:	58 78       	cp.w	r8,7
80009784:	e0 89 00 04 	brgt	8000978c <_vfprintf_r+0x17a4>
80009788:	2f 83       	sub	r3,-8
8000978a:	c0 b8       	rjmp	800097a0 <_vfprintf_r+0x17b8>
8000978c:	fa ca f9 78 	sub	r10,sp,-1672
80009790:	02 9b       	mov	r11,r1
80009792:	08 9c       	mov	r12,r4
80009794:	fe b0 f4 1c 	rcall	80007fcc <__sprint_r>
80009798:	e0 81 03 a7 	brne	80009ee6 <_vfprintf_r+0x1efe>
8000979c:	fa c3 f9 e0 	sub	r3,sp,-1568
800097a0:	40 9b       	lddsp	r11,sp[0x24]
800097a2:	e0 4b 00 80 	cp.w	r11,128
800097a6:	c4 71       	brne	80009834 <_vfprintf_r+0x184c>
800097a8:	40 8a       	lddsp	r10,sp[0x20]
800097aa:	40 39       	lddsp	r9,sp[0xc]
800097ac:	12 1a       	sub	r10,r9
800097ae:	50 4a       	stdsp	sp[0x10],r10
800097b0:	58 0a       	cp.w	r10,0
800097b2:	e0 89 00 20 	brgt	800097f2 <_vfprintf_r+0x180a>
800097b6:	c3 f8       	rjmp	80009834 <_vfprintf_r+0x184c>
800097b8:	2f 09       	sub	r9,-16
800097ba:	2f f8       	sub	r8,-1
800097bc:	fe ce b4 cc 	sub	lr,pc,-19252
800097c0:	31 0c       	mov	r12,16
800097c2:	fb 49 06 90 	st.w	sp[1680],r9
800097c6:	87 0e       	st.w	r3[0x0],lr
800097c8:	87 1c       	st.w	r3[0x4],r12
800097ca:	fb 48 06 8c 	st.w	sp[1676],r8
800097ce:	58 78       	cp.w	r8,7
800097d0:	e0 89 00 04 	brgt	800097d8 <_vfprintf_r+0x17f0>
800097d4:	2f 83       	sub	r3,-8
800097d6:	c0 b8       	rjmp	800097ec <_vfprintf_r+0x1804>
800097d8:	fa ca f9 78 	sub	r10,sp,-1672
800097dc:	02 9b       	mov	r11,r1
800097de:	08 9c       	mov	r12,r4
800097e0:	fe b0 f3 f6 	rcall	80007fcc <__sprint_r>
800097e4:	e0 81 03 81 	brne	80009ee6 <_vfprintf_r+0x1efe>
800097e8:	fa c3 f9 e0 	sub	r3,sp,-1568
800097ec:	40 4b       	lddsp	r11,sp[0x10]
800097ee:	21 0b       	sub	r11,16
800097f0:	50 4b       	stdsp	sp[0x10],r11
800097f2:	fa f9 06 90 	ld.w	r9,sp[1680]
800097f6:	fa f8 06 8c 	ld.w	r8,sp[1676]
800097fa:	fe ca b5 0a 	sub	r10,pc,-19190
800097fe:	40 4e       	lddsp	lr,sp[0x10]
80009800:	59 0e       	cp.w	lr,16
80009802:	fe 99 ff db 	brgt	800097b8 <_vfprintf_r+0x17d0>
80009806:	1c 09       	add	r9,lr
80009808:	2f f8       	sub	r8,-1
8000980a:	87 0a       	st.w	r3[0x0],r10
8000980c:	fb 49 06 90 	st.w	sp[1680],r9
80009810:	87 1e       	st.w	r3[0x4],lr
80009812:	fb 48 06 8c 	st.w	sp[1676],r8
80009816:	58 78       	cp.w	r8,7
80009818:	e0 89 00 04 	brgt	80009820 <_vfprintf_r+0x1838>
8000981c:	2f 83       	sub	r3,-8
8000981e:	c0 b8       	rjmp	80009834 <_vfprintf_r+0x184c>
80009820:	fa ca f9 78 	sub	r10,sp,-1672
80009824:	02 9b       	mov	r11,r1
80009826:	08 9c       	mov	r12,r4
80009828:	fe b0 f3 d2 	rcall	80007fcc <__sprint_r>
8000982c:	e0 81 03 5d 	brne	80009ee6 <_vfprintf_r+0x1efe>
80009830:	fa c3 f9 e0 	sub	r3,sp,-1568
80009834:	40 2c       	lddsp	r12,sp[0x8]
80009836:	04 1c       	sub	r12,r2
80009838:	50 2c       	stdsp	sp[0x8],r12
8000983a:	58 0c       	cp.w	r12,0
8000983c:	e0 89 00 20 	brgt	8000987c <_vfprintf_r+0x1894>
80009840:	c3 f8       	rjmp	800098be <_vfprintf_r+0x18d6>
80009842:	2f 09       	sub	r9,-16
80009844:	2f f8       	sub	r8,-1
80009846:	fe cb b5 56 	sub	r11,pc,-19114
8000984a:	31 0a       	mov	r10,16
8000984c:	fb 49 06 90 	st.w	sp[1680],r9
80009850:	87 0b       	st.w	r3[0x0],r11
80009852:	87 1a       	st.w	r3[0x4],r10
80009854:	fb 48 06 8c 	st.w	sp[1676],r8
80009858:	58 78       	cp.w	r8,7
8000985a:	e0 89 00 04 	brgt	80009862 <_vfprintf_r+0x187a>
8000985e:	2f 83       	sub	r3,-8
80009860:	c0 b8       	rjmp	80009876 <_vfprintf_r+0x188e>
80009862:	fa ca f9 78 	sub	r10,sp,-1672
80009866:	02 9b       	mov	r11,r1
80009868:	08 9c       	mov	r12,r4
8000986a:	fe b0 f3 b1 	rcall	80007fcc <__sprint_r>
8000986e:	e0 81 03 3c 	brne	80009ee6 <_vfprintf_r+0x1efe>
80009872:	fa c3 f9 e0 	sub	r3,sp,-1568
80009876:	40 29       	lddsp	r9,sp[0x8]
80009878:	21 09       	sub	r9,16
8000987a:	50 29       	stdsp	sp[0x8],r9
8000987c:	fa f9 06 90 	ld.w	r9,sp[1680]
80009880:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009884:	fe ca b5 94 	sub	r10,pc,-19052
80009888:	40 2e       	lddsp	lr,sp[0x8]
8000988a:	59 0e       	cp.w	lr,16
8000988c:	fe 99 ff db 	brgt	80009842 <_vfprintf_r+0x185a>
80009890:	1c 09       	add	r9,lr
80009892:	2f f8       	sub	r8,-1
80009894:	87 0a       	st.w	r3[0x0],r10
80009896:	fb 49 06 90 	st.w	sp[1680],r9
8000989a:	87 1e       	st.w	r3[0x4],lr
8000989c:	fb 48 06 8c 	st.w	sp[1676],r8
800098a0:	58 78       	cp.w	r8,7
800098a2:	e0 89 00 04 	brgt	800098aa <_vfprintf_r+0x18c2>
800098a6:	2f 83       	sub	r3,-8
800098a8:	c0 b8       	rjmp	800098be <_vfprintf_r+0x18d6>
800098aa:	fa ca f9 78 	sub	r10,sp,-1672
800098ae:	02 9b       	mov	r11,r1
800098b0:	08 9c       	mov	r12,r4
800098b2:	fe b0 f3 8d 	rcall	80007fcc <__sprint_r>
800098b6:	e0 81 03 18 	brne	80009ee6 <_vfprintf_r+0x1efe>
800098ba:	fa c3 f9 e0 	sub	r3,sp,-1568
800098be:	ed b5 00 08 	bld	r5,0x8
800098c2:	c0 b0       	breq	800098d8 <_vfprintf_r+0x18f0>
800098c4:	fa f8 06 90 	ld.w	r8,sp[1680]
800098c8:	87 12       	st.w	r3[0x4],r2
800098ca:	87 06       	st.w	r3[0x0],r6
800098cc:	f0 02 00 02 	add	r2,r8,r2
800098d0:	fb 42 06 90 	st.w	sp[1680],r2
800098d4:	e0 8f 01 d4 	bral	80009c7c <_vfprintf_r+0x1c94>
800098d8:	e0 40 00 65 	cp.w	r0,101
800098dc:	e0 8a 01 d6 	brle	80009c88 <_vfprintf_r+0x1ca0>
800098e0:	30 08       	mov	r8,0
800098e2:	30 09       	mov	r9,0
800098e4:	40 5b       	lddsp	r11,sp[0x14]
800098e6:	40 7a       	lddsp	r10,sp[0x1c]
800098e8:	e0 a0 15 2f 	rcall	8000c346 <__avr32_f64_cmp_eq>
800098ec:	c7 90       	breq	800099de <_vfprintf_r+0x19f6>
800098ee:	fa f8 06 90 	ld.w	r8,sp[1680]
800098f2:	fe c9 b6 16 	sub	r9,pc,-18922
800098f6:	2f f8       	sub	r8,-1
800098f8:	87 09       	st.w	r3[0x0],r9
800098fa:	fb 48 06 90 	st.w	sp[1680],r8
800098fe:	30 19       	mov	r9,1
80009900:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009904:	87 19       	st.w	r3[0x4],r9
80009906:	2f f8       	sub	r8,-1
80009908:	fb 48 06 8c 	st.w	sp[1676],r8
8000990c:	58 78       	cp.w	r8,7
8000990e:	e0 89 00 05 	brgt	80009918 <_vfprintf_r+0x1930>
80009912:	2f 83       	sub	r3,-8
80009914:	c0 c8       	rjmp	8000992c <_vfprintf_r+0x1944>
80009916:	d7 03       	nop
80009918:	fa ca f9 78 	sub	r10,sp,-1672
8000991c:	02 9b       	mov	r11,r1
8000991e:	08 9c       	mov	r12,r4
80009920:	fe b0 f3 56 	rcall	80007fcc <__sprint_r>
80009924:	e0 81 02 e1 	brne	80009ee6 <_vfprintf_r+0x1efe>
80009928:	fa c3 f9 e0 	sub	r3,sp,-1568
8000992c:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009930:	40 6c       	lddsp	r12,sp[0x18]
80009932:	18 38       	cp.w	r8,r12
80009934:	c0 55       	brlt	8000993e <_vfprintf_r+0x1956>
80009936:	ed b5 00 00 	bld	r5,0x0
8000993a:	e0 81 02 6b 	brne	80009e10 <_vfprintf_r+0x1e28>
8000993e:	fa f8 06 90 	ld.w	r8,sp[1680]
80009942:	2f f8       	sub	r8,-1
80009944:	40 cb       	lddsp	r11,sp[0x30]
80009946:	fb 48 06 90 	st.w	sp[1680],r8
8000994a:	30 19       	mov	r9,1
8000994c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009950:	87 0b       	st.w	r3[0x0],r11
80009952:	2f f8       	sub	r8,-1
80009954:	87 19       	st.w	r3[0x4],r9
80009956:	fb 48 06 8c 	st.w	sp[1676],r8
8000995a:	58 78       	cp.w	r8,7
8000995c:	e0 89 00 04 	brgt	80009964 <_vfprintf_r+0x197c>
80009960:	2f 83       	sub	r3,-8
80009962:	c0 b8       	rjmp	80009978 <_vfprintf_r+0x1990>
80009964:	fa ca f9 78 	sub	r10,sp,-1672
80009968:	02 9b       	mov	r11,r1
8000996a:	08 9c       	mov	r12,r4
8000996c:	fe b0 f3 30 	rcall	80007fcc <__sprint_r>
80009970:	e0 81 02 bb 	brne	80009ee6 <_vfprintf_r+0x1efe>
80009974:	fa c3 f9 e0 	sub	r3,sp,-1568
80009978:	40 66       	lddsp	r6,sp[0x18]
8000997a:	20 16       	sub	r6,1
8000997c:	58 06       	cp.w	r6,0
8000997e:	e0 89 00 1d 	brgt	800099b8 <_vfprintf_r+0x19d0>
80009982:	e0 8f 02 47 	bral	80009e10 <_vfprintf_r+0x1e28>
80009986:	2f 09       	sub	r9,-16
80009988:	2f f8       	sub	r8,-1
8000998a:	fb 49 06 90 	st.w	sp[1680],r9
8000998e:	87 02       	st.w	r3[0x0],r2
80009990:	87 10       	st.w	r3[0x4],r0
80009992:	fb 48 06 8c 	st.w	sp[1676],r8
80009996:	58 78       	cp.w	r8,7
80009998:	e0 89 00 04 	brgt	800099a0 <_vfprintf_r+0x19b8>
8000999c:	2f 83       	sub	r3,-8
8000999e:	c0 b8       	rjmp	800099b4 <_vfprintf_r+0x19cc>
800099a0:	fa ca f9 78 	sub	r10,sp,-1672
800099a4:	02 9b       	mov	r11,r1
800099a6:	08 9c       	mov	r12,r4
800099a8:	fe b0 f3 12 	rcall	80007fcc <__sprint_r>
800099ac:	e0 81 02 9d 	brne	80009ee6 <_vfprintf_r+0x1efe>
800099b0:	fa c3 f9 e0 	sub	r3,sp,-1568
800099b4:	21 06       	sub	r6,16
800099b6:	c0 48       	rjmp	800099be <_vfprintf_r+0x19d6>
800099b8:	fe c2 b6 c8 	sub	r2,pc,-18744
800099bc:	31 00       	mov	r0,16
800099be:	fa f9 06 90 	ld.w	r9,sp[1680]
800099c2:	fa f8 06 8c 	ld.w	r8,sp[1676]
800099c6:	fe ca b6 d6 	sub	r10,pc,-18730
800099ca:	59 06       	cp.w	r6,16
800099cc:	fe 99 ff dd 	brgt	80009986 <_vfprintf_r+0x199e>
800099d0:	0c 09       	add	r9,r6
800099d2:	87 0a       	st.w	r3[0x0],r10
800099d4:	fb 49 06 90 	st.w	sp[1680],r9
800099d8:	2f f8       	sub	r8,-1
800099da:	87 16       	st.w	r3[0x4],r6
800099dc:	c5 39       	rjmp	80009c82 <_vfprintf_r+0x1c9a>
800099de:	fa fa 06 ac 	ld.w	r10,sp[1708]
800099e2:	58 0a       	cp.w	r10,0
800099e4:	e0 89 00 92 	brgt	80009b08 <_vfprintf_r+0x1b20>
800099e8:	fa f8 06 90 	ld.w	r8,sp[1680]
800099ec:	fe c9 b7 10 	sub	r9,pc,-18672
800099f0:	2f f8       	sub	r8,-1
800099f2:	87 09       	st.w	r3[0x0],r9
800099f4:	fb 48 06 90 	st.w	sp[1680],r8
800099f8:	30 19       	mov	r9,1
800099fa:	fa f8 06 8c 	ld.w	r8,sp[1676]
800099fe:	87 19       	st.w	r3[0x4],r9
80009a00:	2f f8       	sub	r8,-1
80009a02:	fb 48 06 8c 	st.w	sp[1676],r8
80009a06:	58 78       	cp.w	r8,7
80009a08:	e0 89 00 04 	brgt	80009a10 <_vfprintf_r+0x1a28>
80009a0c:	2f 83       	sub	r3,-8
80009a0e:	c0 b8       	rjmp	80009a24 <_vfprintf_r+0x1a3c>
80009a10:	fa ca f9 78 	sub	r10,sp,-1672
80009a14:	02 9b       	mov	r11,r1
80009a16:	08 9c       	mov	r12,r4
80009a18:	fe b0 f2 da 	rcall	80007fcc <__sprint_r>
80009a1c:	e0 81 02 65 	brne	80009ee6 <_vfprintf_r+0x1efe>
80009a20:	fa c3 f9 e0 	sub	r3,sp,-1568
80009a24:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009a28:	58 08       	cp.w	r8,0
80009a2a:	c0 81       	brne	80009a3a <_vfprintf_r+0x1a52>
80009a2c:	40 6a       	lddsp	r10,sp[0x18]
80009a2e:	58 0a       	cp.w	r10,0
80009a30:	c0 51       	brne	80009a3a <_vfprintf_r+0x1a52>
80009a32:	ed b5 00 00 	bld	r5,0x0
80009a36:	e0 81 01 ed 	brne	80009e10 <_vfprintf_r+0x1e28>
80009a3a:	40 c9       	lddsp	r9,sp[0x30]
80009a3c:	fa f8 06 90 	ld.w	r8,sp[1680]
80009a40:	2f f8       	sub	r8,-1
80009a42:	87 09       	st.w	r3[0x0],r9
80009a44:	fb 48 06 90 	st.w	sp[1680],r8
80009a48:	30 19       	mov	r9,1
80009a4a:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009a4e:	87 19       	st.w	r3[0x4],r9
80009a50:	2f f8       	sub	r8,-1
80009a52:	fb 48 06 8c 	st.w	sp[1676],r8
80009a56:	58 78       	cp.w	r8,7
80009a58:	e0 89 00 04 	brgt	80009a60 <_vfprintf_r+0x1a78>
80009a5c:	2f 83       	sub	r3,-8
80009a5e:	c0 b8       	rjmp	80009a74 <_vfprintf_r+0x1a8c>
80009a60:	fa ca f9 78 	sub	r10,sp,-1672
80009a64:	02 9b       	mov	r11,r1
80009a66:	08 9c       	mov	r12,r4
80009a68:	fe b0 f2 b2 	rcall	80007fcc <__sprint_r>
80009a6c:	e0 81 02 3d 	brne	80009ee6 <_vfprintf_r+0x1efe>
80009a70:	fa c3 f9 e0 	sub	r3,sp,-1568
80009a74:	fa f2 06 ac 	ld.w	r2,sp[1708]
80009a78:	5c 32       	neg	r2
80009a7a:	58 02       	cp.w	r2,0
80009a7c:	e0 89 00 1d 	brgt	80009ab6 <_vfprintf_r+0x1ace>
80009a80:	c3 d8       	rjmp	80009afa <_vfprintf_r+0x1b12>
80009a82:	2f 09       	sub	r9,-16
80009a84:	2f f8       	sub	r8,-1
80009a86:	31 0e       	mov	lr,16
80009a88:	fb 49 06 90 	st.w	sp[1680],r9
80009a8c:	87 00       	st.w	r3[0x0],r0
80009a8e:	87 1e       	st.w	r3[0x4],lr
80009a90:	fb 48 06 8c 	st.w	sp[1676],r8
80009a94:	58 78       	cp.w	r8,7
80009a96:	e0 89 00 04 	brgt	80009a9e <_vfprintf_r+0x1ab6>
80009a9a:	2f 83       	sub	r3,-8
80009a9c:	c0 b8       	rjmp	80009ab2 <_vfprintf_r+0x1aca>
80009a9e:	fa ca f9 78 	sub	r10,sp,-1672
80009aa2:	02 9b       	mov	r11,r1
80009aa4:	08 9c       	mov	r12,r4
80009aa6:	fe b0 f2 93 	rcall	80007fcc <__sprint_r>
80009aaa:	e0 81 02 1e 	brne	80009ee6 <_vfprintf_r+0x1efe>
80009aae:	fa c3 f9 e0 	sub	r3,sp,-1568
80009ab2:	21 02       	sub	r2,16
80009ab4:	c0 38       	rjmp	80009aba <_vfprintf_r+0x1ad2>
80009ab6:	fe c0 b7 c6 	sub	r0,pc,-18490
80009aba:	fa f9 06 90 	ld.w	r9,sp[1680]
80009abe:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009ac2:	fe ca b7 d2 	sub	r10,pc,-18478
80009ac6:	59 02       	cp.w	r2,16
80009ac8:	fe 99 ff dd 	brgt	80009a82 <_vfprintf_r+0x1a9a>
80009acc:	04 09       	add	r9,r2
80009ace:	2f f8       	sub	r8,-1
80009ad0:	87 0a       	st.w	r3[0x0],r10
80009ad2:	fb 49 06 90 	st.w	sp[1680],r9
80009ad6:	87 12       	st.w	r3[0x4],r2
80009ad8:	fb 48 06 8c 	st.w	sp[1676],r8
80009adc:	58 78       	cp.w	r8,7
80009ade:	e0 89 00 04 	brgt	80009ae6 <_vfprintf_r+0x1afe>
80009ae2:	2f 83       	sub	r3,-8
80009ae4:	c0 b8       	rjmp	80009afa <_vfprintf_r+0x1b12>
80009ae6:	fa ca f9 78 	sub	r10,sp,-1672
80009aea:	02 9b       	mov	r11,r1
80009aec:	08 9c       	mov	r12,r4
80009aee:	fe b0 f2 6f 	rcall	80007fcc <__sprint_r>
80009af2:	e0 81 01 fa 	brne	80009ee6 <_vfprintf_r+0x1efe>
80009af6:	fa c3 f9 e0 	sub	r3,sp,-1568
80009afa:	40 6c       	lddsp	r12,sp[0x18]
80009afc:	fa f8 06 90 	ld.w	r8,sp[1680]
80009b00:	87 06       	st.w	r3[0x0],r6
80009b02:	87 1c       	st.w	r3[0x4],r12
80009b04:	18 08       	add	r8,r12
80009b06:	cb 98       	rjmp	80009c78 <_vfprintf_r+0x1c90>
80009b08:	fa f9 06 90 	ld.w	r9,sp[1680]
80009b0c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009b10:	40 6b       	lddsp	r11,sp[0x18]
80009b12:	16 3a       	cp.w	r10,r11
80009b14:	c6 f5       	brlt	80009bf2 <_vfprintf_r+0x1c0a>
80009b16:	16 09       	add	r9,r11
80009b18:	2f f8       	sub	r8,-1
80009b1a:	87 06       	st.w	r3[0x0],r6
80009b1c:	fb 49 06 90 	st.w	sp[1680],r9
80009b20:	87 1b       	st.w	r3[0x4],r11
80009b22:	fb 48 06 8c 	st.w	sp[1676],r8
80009b26:	58 78       	cp.w	r8,7
80009b28:	e0 89 00 04 	brgt	80009b30 <_vfprintf_r+0x1b48>
80009b2c:	2f 83       	sub	r3,-8
80009b2e:	c0 b8       	rjmp	80009b44 <_vfprintf_r+0x1b5c>
80009b30:	fa ca f9 78 	sub	r10,sp,-1672
80009b34:	02 9b       	mov	r11,r1
80009b36:	08 9c       	mov	r12,r4
80009b38:	fe b0 f2 4a 	rcall	80007fcc <__sprint_r>
80009b3c:	e0 81 01 d5 	brne	80009ee6 <_vfprintf_r+0x1efe>
80009b40:	fa c3 f9 e0 	sub	r3,sp,-1568
80009b44:	fa f6 06 ac 	ld.w	r6,sp[1708]
80009b48:	40 6a       	lddsp	r10,sp[0x18]
80009b4a:	14 16       	sub	r6,r10
80009b4c:	58 06       	cp.w	r6,0
80009b4e:	e0 89 00 1c 	brgt	80009b86 <_vfprintf_r+0x1b9e>
80009b52:	c3 d8       	rjmp	80009bcc <_vfprintf_r+0x1be4>
80009b54:	2f 09       	sub	r9,-16
80009b56:	2f f8       	sub	r8,-1
80009b58:	fb 49 06 90 	st.w	sp[1680],r9
80009b5c:	87 02       	st.w	r3[0x0],r2
80009b5e:	87 10       	st.w	r3[0x4],r0
80009b60:	fb 48 06 8c 	st.w	sp[1676],r8
80009b64:	58 78       	cp.w	r8,7
80009b66:	e0 89 00 04 	brgt	80009b6e <_vfprintf_r+0x1b86>
80009b6a:	2f 83       	sub	r3,-8
80009b6c:	c0 b8       	rjmp	80009b82 <_vfprintf_r+0x1b9a>
80009b6e:	fa ca f9 78 	sub	r10,sp,-1672
80009b72:	02 9b       	mov	r11,r1
80009b74:	08 9c       	mov	r12,r4
80009b76:	fe b0 f2 2b 	rcall	80007fcc <__sprint_r>
80009b7a:	e0 81 01 b6 	brne	80009ee6 <_vfprintf_r+0x1efe>
80009b7e:	fa c3 f9 e0 	sub	r3,sp,-1568
80009b82:	21 06       	sub	r6,16
80009b84:	c0 48       	rjmp	80009b8c <_vfprintf_r+0x1ba4>
80009b86:	fe c2 b8 96 	sub	r2,pc,-18282
80009b8a:	31 00       	mov	r0,16
80009b8c:	fa f9 06 90 	ld.w	r9,sp[1680]
80009b90:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009b94:	fe ca b8 a4 	sub	r10,pc,-18268
80009b98:	59 06       	cp.w	r6,16
80009b9a:	fe 99 ff dd 	brgt	80009b54 <_vfprintf_r+0x1b6c>
80009b9e:	0c 09       	add	r9,r6
80009ba0:	2f f8       	sub	r8,-1
80009ba2:	87 0a       	st.w	r3[0x0],r10
80009ba4:	fb 49 06 90 	st.w	sp[1680],r9
80009ba8:	87 16       	st.w	r3[0x4],r6
80009baa:	fb 48 06 8c 	st.w	sp[1676],r8
80009bae:	58 78       	cp.w	r8,7
80009bb0:	e0 89 00 04 	brgt	80009bb8 <_vfprintf_r+0x1bd0>
80009bb4:	2f 83       	sub	r3,-8
80009bb6:	c0 b8       	rjmp	80009bcc <_vfprintf_r+0x1be4>
80009bb8:	fa ca f9 78 	sub	r10,sp,-1672
80009bbc:	02 9b       	mov	r11,r1
80009bbe:	08 9c       	mov	r12,r4
80009bc0:	fe b0 f2 06 	rcall	80007fcc <__sprint_r>
80009bc4:	e0 81 01 91 	brne	80009ee6 <_vfprintf_r+0x1efe>
80009bc8:	fa c3 f9 e0 	sub	r3,sp,-1568
80009bcc:	ed b5 00 00 	bld	r5,0x0
80009bd0:	e0 81 01 20 	brne	80009e10 <_vfprintf_r+0x1e28>
80009bd4:	40 c9       	lddsp	r9,sp[0x30]
80009bd6:	fa f8 06 90 	ld.w	r8,sp[1680]
80009bda:	2f f8       	sub	r8,-1
80009bdc:	87 09       	st.w	r3[0x0],r9
80009bde:	fb 48 06 90 	st.w	sp[1680],r8
80009be2:	30 19       	mov	r9,1
80009be4:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009be8:	87 19       	st.w	r3[0x4],r9
80009bea:	2f f8       	sub	r8,-1
80009bec:	fb 48 06 8c 	st.w	sp[1676],r8
80009bf0:	c0 29       	rjmp	80009df4 <_vfprintf_r+0x1e0c>
80009bf2:	14 09       	add	r9,r10
80009bf4:	2f f8       	sub	r8,-1
80009bf6:	fb 49 06 90 	st.w	sp[1680],r9
80009bfa:	87 06       	st.w	r3[0x0],r6
80009bfc:	87 1a       	st.w	r3[0x4],r10
80009bfe:	fb 48 06 8c 	st.w	sp[1676],r8
80009c02:	58 78       	cp.w	r8,7
80009c04:	e0 89 00 04 	brgt	80009c0c <_vfprintf_r+0x1c24>
80009c08:	2f 83       	sub	r3,-8
80009c0a:	c0 b8       	rjmp	80009c20 <_vfprintf_r+0x1c38>
80009c0c:	fa ca f9 78 	sub	r10,sp,-1672
80009c10:	02 9b       	mov	r11,r1
80009c12:	08 9c       	mov	r12,r4
80009c14:	fe b0 f1 dc 	rcall	80007fcc <__sprint_r>
80009c18:	e0 81 01 67 	brne	80009ee6 <_vfprintf_r+0x1efe>
80009c1c:	fa c3 f9 e0 	sub	r3,sp,-1568
80009c20:	40 c8       	lddsp	r8,sp[0x30]
80009c22:	87 08       	st.w	r3[0x0],r8
80009c24:	fa f8 06 90 	ld.w	r8,sp[1680]
80009c28:	2f f8       	sub	r8,-1
80009c2a:	30 19       	mov	r9,1
80009c2c:	fb 48 06 90 	st.w	sp[1680],r8
80009c30:	87 19       	st.w	r3[0x4],r9
80009c32:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009c36:	2f f8       	sub	r8,-1
80009c38:	fb 48 06 8c 	st.w	sp[1676],r8
80009c3c:	fa f2 06 ac 	ld.w	r2,sp[1708]
80009c40:	58 78       	cp.w	r8,7
80009c42:	e0 89 00 04 	brgt	80009c4a <_vfprintf_r+0x1c62>
80009c46:	2f 83       	sub	r3,-8
80009c48:	c0 b8       	rjmp	80009c5e <_vfprintf_r+0x1c76>
80009c4a:	fa ca f9 78 	sub	r10,sp,-1672
80009c4e:	02 9b       	mov	r11,r1
80009c50:	08 9c       	mov	r12,r4
80009c52:	fe b0 f1 bd 	rcall	80007fcc <__sprint_r>
80009c56:	e0 81 01 48 	brne	80009ee6 <_vfprintf_r+0x1efe>
80009c5a:	fa c3 f9 e0 	sub	r3,sp,-1568
80009c5e:	04 06       	add	r6,r2
80009c60:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009c64:	87 06       	st.w	r3[0x0],r6
80009c66:	fa f9 06 90 	ld.w	r9,sp[1680]
80009c6a:	40 66       	lddsp	r6,sp[0x18]
80009c6c:	40 6e       	lddsp	lr,sp[0x18]
80009c6e:	10 16       	sub	r6,r8
80009c70:	f2 08 01 08 	sub	r8,r9,r8
80009c74:	87 16       	st.w	r3[0x4],r6
80009c76:	1c 08       	add	r8,lr
80009c78:	fb 48 06 90 	st.w	sp[1680],r8
80009c7c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009c80:	2f f8       	sub	r8,-1
80009c82:	fb 48 06 8c 	st.w	sp[1676],r8
80009c86:	cb 78       	rjmp	80009df4 <_vfprintf_r+0x1e0c>
80009c88:	40 6c       	lddsp	r12,sp[0x18]
80009c8a:	58 1c       	cp.w	r12,1
80009c8c:	e0 89 00 06 	brgt	80009c98 <_vfprintf_r+0x1cb0>
80009c90:	ed b5 00 00 	bld	r5,0x0
80009c94:	e0 81 00 85 	brne	80009d9e <_vfprintf_r+0x1db6>
80009c98:	fa f8 06 90 	ld.w	r8,sp[1680]
80009c9c:	2f f8       	sub	r8,-1
80009c9e:	30 19       	mov	r9,1
80009ca0:	fb 48 06 90 	st.w	sp[1680],r8
80009ca4:	87 06       	st.w	r3[0x0],r6
80009ca6:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009caa:	87 19       	st.w	r3[0x4],r9
80009cac:	2f f8       	sub	r8,-1
80009cae:	fb 48 06 8c 	st.w	sp[1676],r8
80009cb2:	58 78       	cp.w	r8,7
80009cb4:	e0 89 00 04 	brgt	80009cbc <_vfprintf_r+0x1cd4>
80009cb8:	2f 83       	sub	r3,-8
80009cba:	c0 b8       	rjmp	80009cd0 <_vfprintf_r+0x1ce8>
80009cbc:	fa ca f9 78 	sub	r10,sp,-1672
80009cc0:	02 9b       	mov	r11,r1
80009cc2:	08 9c       	mov	r12,r4
80009cc4:	fe b0 f1 84 	rcall	80007fcc <__sprint_r>
80009cc8:	e0 81 01 0f 	brne	80009ee6 <_vfprintf_r+0x1efe>
80009ccc:	fa c3 f9 e0 	sub	r3,sp,-1568
80009cd0:	fa f8 06 90 	ld.w	r8,sp[1680]
80009cd4:	2f f8       	sub	r8,-1
80009cd6:	40 cb       	lddsp	r11,sp[0x30]
80009cd8:	fb 48 06 90 	st.w	sp[1680],r8
80009cdc:	30 19       	mov	r9,1
80009cde:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009ce2:	87 0b       	st.w	r3[0x0],r11
80009ce4:	2f f8       	sub	r8,-1
80009ce6:	87 19       	st.w	r3[0x4],r9
80009ce8:	fb 48 06 8c 	st.w	sp[1676],r8
80009cec:	58 78       	cp.w	r8,7
80009cee:	e0 89 00 05 	brgt	80009cf8 <_vfprintf_r+0x1d10>
80009cf2:	2f 83       	sub	r3,-8
80009cf4:	c0 c8       	rjmp	80009d0c <_vfprintf_r+0x1d24>
80009cf6:	d7 03       	nop
80009cf8:	fa ca f9 78 	sub	r10,sp,-1672
80009cfc:	02 9b       	mov	r11,r1
80009cfe:	08 9c       	mov	r12,r4
80009d00:	fe b0 f1 66 	rcall	80007fcc <__sprint_r>
80009d04:	e0 81 00 f1 	brne	80009ee6 <_vfprintf_r+0x1efe>
80009d08:	fa c3 f9 e0 	sub	r3,sp,-1568
80009d0c:	30 08       	mov	r8,0
80009d0e:	30 09       	mov	r9,0
80009d10:	40 5b       	lddsp	r11,sp[0x14]
80009d12:	40 7a       	lddsp	r10,sp[0x1c]
80009d14:	e0 a0 13 19 	rcall	8000c346 <__avr32_f64_cmp_eq>
80009d18:	40 68       	lddsp	r8,sp[0x18]
80009d1a:	20 18       	sub	r8,1
80009d1c:	58 0c       	cp.w	r12,0
80009d1e:	c0 d1       	brne	80009d38 <_vfprintf_r+0x1d50>
80009d20:	2f f6       	sub	r6,-1
80009d22:	87 18       	st.w	r3[0x4],r8
80009d24:	87 06       	st.w	r3[0x0],r6
80009d26:	fa f6 06 90 	ld.w	r6,sp[1680]
80009d2a:	10 06       	add	r6,r8
80009d2c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009d30:	fb 46 06 90 	st.w	sp[1680],r6
80009d34:	2f f8       	sub	r8,-1
80009d36:	c3 18       	rjmp	80009d98 <_vfprintf_r+0x1db0>
80009d38:	10 96       	mov	r6,r8
80009d3a:	58 08       	cp.w	r8,0
80009d3c:	e0 89 00 1c 	brgt	80009d74 <_vfprintf_r+0x1d8c>
80009d40:	c4 b8       	rjmp	80009dd6 <_vfprintf_r+0x1dee>
80009d42:	2f 09       	sub	r9,-16
80009d44:	2f f8       	sub	r8,-1
80009d46:	fb 49 06 90 	st.w	sp[1680],r9
80009d4a:	87 02       	st.w	r3[0x0],r2
80009d4c:	87 10       	st.w	r3[0x4],r0
80009d4e:	fb 48 06 8c 	st.w	sp[1676],r8
80009d52:	58 78       	cp.w	r8,7
80009d54:	e0 89 00 04 	brgt	80009d5c <_vfprintf_r+0x1d74>
80009d58:	2f 83       	sub	r3,-8
80009d5a:	c0 b8       	rjmp	80009d70 <_vfprintf_r+0x1d88>
80009d5c:	fa ca f9 78 	sub	r10,sp,-1672
80009d60:	02 9b       	mov	r11,r1
80009d62:	08 9c       	mov	r12,r4
80009d64:	fe b0 f1 34 	rcall	80007fcc <__sprint_r>
80009d68:	e0 81 00 bf 	brne	80009ee6 <_vfprintf_r+0x1efe>
80009d6c:	fa c3 f9 e0 	sub	r3,sp,-1568
80009d70:	21 06       	sub	r6,16
80009d72:	c0 48       	rjmp	80009d7a <_vfprintf_r+0x1d92>
80009d74:	fe c2 ba 84 	sub	r2,pc,-17788
80009d78:	31 00       	mov	r0,16
80009d7a:	fa f9 06 90 	ld.w	r9,sp[1680]
80009d7e:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009d82:	fe ca ba 92 	sub	r10,pc,-17774
80009d86:	59 06       	cp.w	r6,16
80009d88:	fe 99 ff dd 	brgt	80009d42 <_vfprintf_r+0x1d5a>
80009d8c:	0c 09       	add	r9,r6
80009d8e:	87 0a       	st.w	r3[0x0],r10
80009d90:	fb 49 06 90 	st.w	sp[1680],r9
80009d94:	2f f8       	sub	r8,-1
80009d96:	87 16       	st.w	r3[0x4],r6
80009d98:	fb 48 06 8c 	st.w	sp[1676],r8
80009d9c:	c0 e8       	rjmp	80009db8 <_vfprintf_r+0x1dd0>
80009d9e:	fa f8 06 90 	ld.w	r8,sp[1680]
80009da2:	2f f8       	sub	r8,-1
80009da4:	30 19       	mov	r9,1
80009da6:	fb 48 06 90 	st.w	sp[1680],r8
80009daa:	87 06       	st.w	r3[0x0],r6
80009dac:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009db0:	87 19       	st.w	r3[0x4],r9
80009db2:	2f f8       	sub	r8,-1
80009db4:	fb 48 06 8c 	st.w	sp[1676],r8
80009db8:	58 78       	cp.w	r8,7
80009dba:	e0 89 00 04 	brgt	80009dc2 <_vfprintf_r+0x1dda>
80009dbe:	2f 83       	sub	r3,-8
80009dc0:	c0 b8       	rjmp	80009dd6 <_vfprintf_r+0x1dee>
80009dc2:	fa ca f9 78 	sub	r10,sp,-1672
80009dc6:	02 9b       	mov	r11,r1
80009dc8:	08 9c       	mov	r12,r4
80009dca:	fe b0 f1 01 	rcall	80007fcc <__sprint_r>
80009dce:	e0 81 00 8c 	brne	80009ee6 <_vfprintf_r+0x1efe>
80009dd2:	fa c3 f9 e0 	sub	r3,sp,-1568
80009dd6:	40 ea       	lddsp	r10,sp[0x38]
80009dd8:	fa f8 06 90 	ld.w	r8,sp[1680]
80009ddc:	14 08       	add	r8,r10
80009dde:	fa c9 f9 64 	sub	r9,sp,-1692
80009de2:	fb 48 06 90 	st.w	sp[1680],r8
80009de6:	87 1a       	st.w	r3[0x4],r10
80009de8:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009dec:	87 09       	st.w	r3[0x0],r9
80009dee:	2f f8       	sub	r8,-1
80009df0:	fb 48 06 8c 	st.w	sp[1676],r8
80009df4:	58 78       	cp.w	r8,7
80009df6:	e0 89 00 04 	brgt	80009dfe <_vfprintf_r+0x1e16>
80009dfa:	2f 83       	sub	r3,-8
80009dfc:	c0 a8       	rjmp	80009e10 <_vfprintf_r+0x1e28>
80009dfe:	fa ca f9 78 	sub	r10,sp,-1672
80009e02:	02 9b       	mov	r11,r1
80009e04:	08 9c       	mov	r12,r4
80009e06:	fe b0 f0 e3 	rcall	80007fcc <__sprint_r>
80009e0a:	c6 e1       	brne	80009ee6 <_vfprintf_r+0x1efe>
80009e0c:	fa c3 f9 e0 	sub	r3,sp,-1568
80009e10:	e2 15 00 04 	andl	r5,0x4,COH
80009e14:	c3 f0       	breq	80009e92 <_vfprintf_r+0x1eaa>
80009e16:	40 86       	lddsp	r6,sp[0x20]
80009e18:	40 39       	lddsp	r9,sp[0xc]
80009e1a:	12 16       	sub	r6,r9
80009e1c:	58 06       	cp.w	r6,0
80009e1e:	e0 89 00 1a 	brgt	80009e52 <_vfprintf_r+0x1e6a>
80009e22:	c3 88       	rjmp	80009e92 <_vfprintf_r+0x1eaa>
80009e24:	2f 09       	sub	r9,-16
80009e26:	2f f8       	sub	r8,-1
80009e28:	fb 49 06 90 	st.w	sp[1680],r9
80009e2c:	87 05       	st.w	r3[0x0],r5
80009e2e:	87 12       	st.w	r3[0x4],r2
80009e30:	fb 48 06 8c 	st.w	sp[1676],r8
80009e34:	58 78       	cp.w	r8,7
80009e36:	e0 89 00 04 	brgt	80009e3e <_vfprintf_r+0x1e56>
80009e3a:	2f 83       	sub	r3,-8
80009e3c:	c0 98       	rjmp	80009e4e <_vfprintf_r+0x1e66>
80009e3e:	00 9a       	mov	r10,r0
80009e40:	02 9b       	mov	r11,r1
80009e42:	08 9c       	mov	r12,r4
80009e44:	fe b0 f0 c4 	rcall	80007fcc <__sprint_r>
80009e48:	c4 f1       	brne	80009ee6 <_vfprintf_r+0x1efe>
80009e4a:	fa c3 f9 e0 	sub	r3,sp,-1568
80009e4e:	21 06       	sub	r6,16
80009e50:	c0 68       	rjmp	80009e5c <_vfprintf_r+0x1e74>
80009e52:	fe c5 bb 72 	sub	r5,pc,-17550
80009e56:	31 02       	mov	r2,16
80009e58:	fa c0 f9 78 	sub	r0,sp,-1672
80009e5c:	fa f9 06 90 	ld.w	r9,sp[1680]
80009e60:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009e64:	fe ca bb 84 	sub	r10,pc,-17532
80009e68:	59 06       	cp.w	r6,16
80009e6a:	fe 99 ff dd 	brgt	80009e24 <_vfprintf_r+0x1e3c>
80009e6e:	0c 09       	add	r9,r6
80009e70:	2f f8       	sub	r8,-1
80009e72:	87 0a       	st.w	r3[0x0],r10
80009e74:	87 16       	st.w	r3[0x4],r6
80009e76:	fb 49 06 90 	st.w	sp[1680],r9
80009e7a:	fb 48 06 8c 	st.w	sp[1676],r8
80009e7e:	58 78       	cp.w	r8,7
80009e80:	e0 8a 00 09 	brle	80009e92 <_vfprintf_r+0x1eaa>
80009e84:	fa ca f9 78 	sub	r10,sp,-1672
80009e88:	02 9b       	mov	r11,r1
80009e8a:	08 9c       	mov	r12,r4
80009e8c:	fe b0 f0 a0 	rcall	80007fcc <__sprint_r>
80009e90:	c2 b1       	brne	80009ee6 <_vfprintf_r+0x1efe>
80009e92:	40 bc       	lddsp	r12,sp[0x2c]
80009e94:	40 36       	lddsp	r6,sp[0xc]
80009e96:	40 8e       	lddsp	lr,sp[0x20]
80009e98:	ec 0e 0c 48 	max	r8,r6,lr
80009e9c:	10 0c       	add	r12,r8
80009e9e:	50 bc       	stdsp	sp[0x2c],r12
80009ea0:	fa f8 06 90 	ld.w	r8,sp[1680]
80009ea4:	58 08       	cp.w	r8,0
80009ea6:	c0 80       	breq	80009eb6 <_vfprintf_r+0x1ece>
80009ea8:	fa ca f9 78 	sub	r10,sp,-1672
80009eac:	02 9b       	mov	r11,r1
80009eae:	08 9c       	mov	r12,r4
80009eb0:	fe b0 f0 8e 	rcall	80007fcc <__sprint_r>
80009eb4:	c1 91       	brne	80009ee6 <_vfprintf_r+0x1efe>
80009eb6:	30 0b       	mov	r11,0
80009eb8:	fa c3 f9 e0 	sub	r3,sp,-1568
80009ebc:	fb 4b 06 8c 	st.w	sp[1676],r11
80009ec0:	fe 9f f1 22 	bral	80008104 <_vfprintf_r+0x11c>
80009ec4:	08 95       	mov	r5,r4
80009ec6:	fa f8 06 90 	ld.w	r8,sp[1680]
80009eca:	58 08       	cp.w	r8,0
80009ecc:	c0 80       	breq	80009edc <_vfprintf_r+0x1ef4>
80009ece:	08 9c       	mov	r12,r4
80009ed0:	fa ca f9 78 	sub	r10,sp,-1672
80009ed4:	02 9b       	mov	r11,r1
80009ed6:	fe b0 f0 7b 	rcall	80007fcc <__sprint_r>
80009eda:	c0 61       	brne	80009ee6 <_vfprintf_r+0x1efe>
80009edc:	30 08       	mov	r8,0
80009ede:	fb 48 06 8c 	st.w	sp[1676],r8
80009ee2:	c0 28       	rjmp	80009ee6 <_vfprintf_r+0x1efe>
80009ee4:	40 41       	lddsp	r1,sp[0x10]
80009ee6:	82 68       	ld.sh	r8,r1[0xc]
80009ee8:	ed b8 00 06 	bld	r8,0x6
80009eec:	c0 31       	brne	80009ef2 <_vfprintf_r+0x1f0a>
80009eee:	3f fa       	mov	r10,-1
80009ef0:	50 ba       	stdsp	sp[0x2c],r10
80009ef2:	40 bc       	lddsp	r12,sp[0x2c]
80009ef4:	fe 3d f9 44 	sub	sp,-1724
80009ef8:	d8 32       	popm	r0-r7,pc
80009efa:	d7 03       	nop

80009efc <__swsetup_r>:
80009efc:	d4 21       	pushm	r4-r7,lr
80009efe:	e0 68 0a 3c 	mov	r8,2620
80009f02:	18 96       	mov	r6,r12
80009f04:	16 97       	mov	r7,r11
80009f06:	70 0c       	ld.w	r12,r8[0x0]
80009f08:	58 0c       	cp.w	r12,0
80009f0a:	c0 60       	breq	80009f16 <__swsetup_r+0x1a>
80009f0c:	78 68       	ld.w	r8,r12[0x18]
80009f0e:	58 08       	cp.w	r8,0
80009f10:	c0 31       	brne	80009f16 <__swsetup_r+0x1a>
80009f12:	e0 a0 07 bf 	rcall	8000ae90 <__sinit>
80009f16:	fe c8 bb 06 	sub	r8,pc,-17658
80009f1a:	10 37       	cp.w	r7,r8
80009f1c:	c0 61       	brne	80009f28 <__swsetup_r+0x2c>
80009f1e:	e0 68 0a 3c 	mov	r8,2620
80009f22:	70 08       	ld.w	r8,r8[0x0]
80009f24:	70 07       	ld.w	r7,r8[0x0]
80009f26:	c1 28       	rjmp	80009f4a <__swsetup_r+0x4e>
80009f28:	fe c8 ba f8 	sub	r8,pc,-17672
80009f2c:	10 37       	cp.w	r7,r8
80009f2e:	c0 61       	brne	80009f3a <__swsetup_r+0x3e>
80009f30:	e0 68 0a 3c 	mov	r8,2620
80009f34:	70 08       	ld.w	r8,r8[0x0]
80009f36:	70 17       	ld.w	r7,r8[0x4]
80009f38:	c0 98       	rjmp	80009f4a <__swsetup_r+0x4e>
80009f3a:	fe c8 ba ea 	sub	r8,pc,-17686
80009f3e:	10 37       	cp.w	r7,r8
80009f40:	c0 51       	brne	80009f4a <__swsetup_r+0x4e>
80009f42:	e0 68 0a 3c 	mov	r8,2620
80009f46:	70 08       	ld.w	r8,r8[0x0]
80009f48:	70 27       	ld.w	r7,r8[0x8]
80009f4a:	8e 68       	ld.sh	r8,r7[0xc]
80009f4c:	ed b8 00 03 	bld	r8,0x3
80009f50:	c1 e0       	breq	80009f8c <__swsetup_r+0x90>
80009f52:	ed b8 00 04 	bld	r8,0x4
80009f56:	c3 e1       	brne	80009fd2 <__swsetup_r+0xd6>
80009f58:	ed b8 00 02 	bld	r8,0x2
80009f5c:	c1 51       	brne	80009f86 <__swsetup_r+0x8a>
80009f5e:	6e db       	ld.w	r11,r7[0x34]
80009f60:	58 0b       	cp.w	r11,0
80009f62:	c0 a0       	breq	80009f76 <__swsetup_r+0x7a>
80009f64:	ee c8 ff bc 	sub	r8,r7,-68
80009f68:	10 3b       	cp.w	r11,r8
80009f6a:	c0 40       	breq	80009f72 <__swsetup_r+0x76>
80009f6c:	0c 9c       	mov	r12,r6
80009f6e:	e0 a0 08 2b 	rcall	8000afc4 <_free_r>
80009f72:	30 08       	mov	r8,0
80009f74:	8f d8       	st.w	r7[0x34],r8
80009f76:	8e 68       	ld.sh	r8,r7[0xc]
80009f78:	e0 18 ff db 	andl	r8,0xffdb
80009f7c:	ae 68       	st.h	r7[0xc],r8
80009f7e:	30 08       	mov	r8,0
80009f80:	8f 18       	st.w	r7[0x4],r8
80009f82:	6e 48       	ld.w	r8,r7[0x10]
80009f84:	8f 08       	st.w	r7[0x0],r8
80009f86:	8e 68       	ld.sh	r8,r7[0xc]
80009f88:	a3 b8       	sbr	r8,0x3
80009f8a:	ae 68       	st.h	r7[0xc],r8
80009f8c:	6e 48       	ld.w	r8,r7[0x10]
80009f8e:	58 08       	cp.w	r8,0
80009f90:	c0 b1       	brne	80009fa6 <__swsetup_r+0xaa>
80009f92:	8e 68       	ld.sh	r8,r7[0xc]
80009f94:	e2 18 02 80 	andl	r8,0x280,COH
80009f98:	e0 48 02 00 	cp.w	r8,512
80009f9c:	c0 50       	breq	80009fa6 <__swsetup_r+0xaa>
80009f9e:	0c 9c       	mov	r12,r6
80009fa0:	0e 9b       	mov	r11,r7
80009fa2:	e0 a0 0a 4b 	rcall	8000b438 <__smakebuf_r>
80009fa6:	8e 69       	ld.sh	r9,r7[0xc]
80009fa8:	f1 d9 c0 01 	bfextu	r8,r9,0x0,0x1
80009fac:	c0 70       	breq	80009fba <__swsetup_r+0xbe>
80009fae:	30 08       	mov	r8,0
80009fb0:	8f 28       	st.w	r7[0x8],r8
80009fb2:	6e 58       	ld.w	r8,r7[0x14]
80009fb4:	5c 38       	neg	r8
80009fb6:	8f 68       	st.w	r7[0x18],r8
80009fb8:	c0 68       	rjmp	80009fc4 <__swsetup_r+0xc8>
80009fba:	ed b9 00 01 	bld	r9,0x1
80009fbe:	ef f8 10 05 	ld.wne	r8,r7[0x14]
80009fc2:	8f 28       	st.w	r7[0x8],r8
80009fc4:	6e 48       	ld.w	r8,r7[0x10]
80009fc6:	58 08       	cp.w	r8,0
80009fc8:	c0 61       	brne	80009fd4 <__swsetup_r+0xd8>
80009fca:	8e 68       	ld.sh	r8,r7[0xc]
80009fcc:	ed b8 00 07 	bld	r8,0x7
80009fd0:	c0 21       	brne	80009fd4 <__swsetup_r+0xd8>
80009fd2:	dc 2a       	popm	r4-r7,pc,r12=-1
80009fd4:	d8 2a       	popm	r4-r7,pc,r12=0
80009fd6:	d7 03       	nop

80009fd8 <quorem>:
80009fd8:	d4 31       	pushm	r0-r7,lr
80009fda:	20 2d       	sub	sp,8
80009fdc:	18 97       	mov	r7,r12
80009fde:	78 48       	ld.w	r8,r12[0x10]
80009fe0:	76 46       	ld.w	r6,r11[0x10]
80009fe2:	0c 38       	cp.w	r8,r6
80009fe4:	c0 34       	brge	80009fea <quorem+0x12>
80009fe6:	30 0c       	mov	r12,0
80009fe8:	c8 58       	rjmp	8000a0f2 <quorem+0x11a>
80009fea:	ec c2 ff fc 	sub	r2,r6,-4
80009fee:	f6 c3 ff ec 	sub	r3,r11,-20
80009ff2:	f6 02 03 29 	ld.w	r9,r11[r2<<0x2]
80009ff6:	f8 02 03 2c 	ld.w	r12,r12[r2<<0x2]
80009ffa:	2f f9       	sub	r9,-1
80009ffc:	20 16       	sub	r6,1
80009ffe:	f8 09 0d 08 	divu	r8,r12,r9
8000a002:	f6 02 00 22 	add	r2,r11,r2<<0x2
8000a006:	ee c4 ff ec 	sub	r4,r7,-20
8000a00a:	10 95       	mov	r5,r8
8000a00c:	58 08       	cp.w	r8,0
8000a00e:	c4 10       	breq	8000a090 <quorem+0xb8>
8000a010:	30 09       	mov	r9,0
8000a012:	06 9a       	mov	r10,r3
8000a014:	08 98       	mov	r8,r4
8000a016:	12 91       	mov	r1,r9
8000a018:	50 0b       	stdsp	sp[0x0],r11
8000a01a:	70 0e       	ld.w	lr,r8[0x0]
8000a01c:	b1 8e       	lsr	lr,0x10
8000a01e:	50 1e       	stdsp	sp[0x4],lr
8000a020:	15 0e       	ld.w	lr,r10++
8000a022:	fc 00 16 10 	lsr	r0,lr,0x10
8000a026:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000a02a:	ea 0e 03 41 	mac	r1,r5,lr
8000a02e:	fd d1 c0 10 	bfextu	lr,r1,0x0,0x10
8000a032:	b1 81       	lsr	r1,0x10
8000a034:	40 1b       	lddsp	r11,sp[0x4]
8000a036:	ea 00 02 40 	mul	r0,r5,r0
8000a03a:	e2 00 00 00 	add	r0,r1,r0
8000a03e:	e3 d0 c0 10 	bfextu	r1,r0,0x0,0x10
8000a042:	02 1b       	sub	r11,r1
8000a044:	50 1b       	stdsp	sp[0x4],r11
8000a046:	70 0b       	ld.w	r11,r8[0x0]
8000a048:	e3 db c0 10 	bfextu	r1,r11,0x0,0x10
8000a04c:	02 09       	add	r9,r1
8000a04e:	f2 0e 01 0e 	sub	lr,r9,lr
8000a052:	b0 1e       	st.h	r8[0x2],lr
8000a054:	fc 09 14 10 	asr	r9,lr,0x10
8000a058:	40 1e       	lddsp	lr,sp[0x4]
8000a05a:	fc 09 00 09 	add	r9,lr,r9
8000a05e:	b0 09       	st.h	r8[0x0],r9
8000a060:	e0 01 16 10 	lsr	r1,r0,0x10
8000a064:	2f c8       	sub	r8,-4
8000a066:	b1 49       	asr	r9,0x10
8000a068:	04 3a       	cp.w	r10,r2
8000a06a:	fe 98 ff d8 	brls	8000a01a <quorem+0x42>
8000a06e:	40 0b       	lddsp	r11,sp[0x0]
8000a070:	58 0c       	cp.w	r12,0
8000a072:	c0 f1       	brne	8000a090 <quorem+0xb8>
8000a074:	ec c8 ff fb 	sub	r8,r6,-5
8000a078:	ee 08 00 28 	add	r8,r7,r8<<0x2
8000a07c:	c0 28       	rjmp	8000a080 <quorem+0xa8>
8000a07e:	20 16       	sub	r6,1
8000a080:	20 48       	sub	r8,4
8000a082:	08 38       	cp.w	r8,r4
8000a084:	e0 88 00 05 	brls	8000a08e <quorem+0xb6>
8000a088:	70 09       	ld.w	r9,r8[0x0]
8000a08a:	58 09       	cp.w	r9,0
8000a08c:	cf 90       	breq	8000a07e <quorem+0xa6>
8000a08e:	8f 46       	st.w	r7[0x10],r6
8000a090:	0e 9c       	mov	r12,r7
8000a092:	e0 a0 0a d2 	rcall	8000b636 <__mcmp>
8000a096:	c2 d5       	brlt	8000a0f0 <quorem+0x118>
8000a098:	2f f5       	sub	r5,-1
8000a09a:	08 98       	mov	r8,r4
8000a09c:	30 09       	mov	r9,0
8000a09e:	07 0b       	ld.w	r11,r3++
8000a0a0:	f6 0a 16 10 	lsr	r10,r11,0x10
8000a0a4:	70 0c       	ld.w	r12,r8[0x0]
8000a0a6:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000a0aa:	f8 0e 16 10 	lsr	lr,r12,0x10
8000a0ae:	14 1e       	sub	lr,r10
8000a0b0:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000a0b4:	16 1a       	sub	r10,r11
8000a0b6:	12 0a       	add	r10,r9
8000a0b8:	b0 1a       	st.h	r8[0x2],r10
8000a0ba:	b1 4a       	asr	r10,0x10
8000a0bc:	fc 0a 00 09 	add	r9,lr,r10
8000a0c0:	b0 09       	st.h	r8[0x0],r9
8000a0c2:	2f c8       	sub	r8,-4
8000a0c4:	b1 49       	asr	r9,0x10
8000a0c6:	04 33       	cp.w	r3,r2
8000a0c8:	fe 98 ff eb 	brls	8000a09e <quorem+0xc6>
8000a0cc:	ec c8 ff fb 	sub	r8,r6,-5
8000a0d0:	ee 08 03 29 	ld.w	r9,r7[r8<<0x2]
8000a0d4:	58 09       	cp.w	r9,0
8000a0d6:	c0 d1       	brne	8000a0f0 <quorem+0x118>
8000a0d8:	ee 08 00 28 	add	r8,r7,r8<<0x2
8000a0dc:	c0 28       	rjmp	8000a0e0 <quorem+0x108>
8000a0de:	20 16       	sub	r6,1
8000a0e0:	20 48       	sub	r8,4
8000a0e2:	08 38       	cp.w	r8,r4
8000a0e4:	e0 88 00 05 	brls	8000a0ee <quorem+0x116>
8000a0e8:	70 09       	ld.w	r9,r8[0x0]
8000a0ea:	58 09       	cp.w	r9,0
8000a0ec:	cf 90       	breq	8000a0de <quorem+0x106>
8000a0ee:	8f 46       	st.w	r7[0x10],r6
8000a0f0:	0a 9c       	mov	r12,r5
8000a0f2:	2f ed       	sub	sp,-8
8000a0f4:	d8 32       	popm	r0-r7,pc
8000a0f6:	d7 03       	nop

8000a0f8 <_dtoa_r>:
8000a0f8:	d4 31       	pushm	r0-r7,lr
8000a0fa:	21 ad       	sub	sp,104
8000a0fc:	fa c4 ff 74 	sub	r4,sp,-140
8000a100:	18 97       	mov	r7,r12
8000a102:	16 95       	mov	r5,r11
8000a104:	68 2c       	ld.w	r12,r4[0x8]
8000a106:	50 c9       	stdsp	sp[0x30],r9
8000a108:	68 16       	ld.w	r6,r4[0x4]
8000a10a:	68 09       	ld.w	r9,r4[0x0]
8000a10c:	50 e8       	stdsp	sp[0x38],r8
8000a10e:	14 94       	mov	r4,r10
8000a110:	51 2c       	stdsp	sp[0x48],r12
8000a112:	fa e5 00 08 	st.d	sp[8],r4
8000a116:	51 59       	stdsp	sp[0x54],r9
8000a118:	6e 95       	ld.w	r5,r7[0x24]
8000a11a:	58 05       	cp.w	r5,0
8000a11c:	c0 91       	brne	8000a12e <_dtoa_r+0x36>
8000a11e:	31 0c       	mov	r12,16
8000a120:	fe b0 e8 d6 	rcall	800072cc <malloc>
8000a124:	99 35       	st.w	r12[0xc],r5
8000a126:	8f 9c       	st.w	r7[0x24],r12
8000a128:	99 15       	st.w	r12[0x4],r5
8000a12a:	99 25       	st.w	r12[0x8],r5
8000a12c:	99 05       	st.w	r12[0x0],r5
8000a12e:	6e 99       	ld.w	r9,r7[0x24]
8000a130:	72 08       	ld.w	r8,r9[0x0]
8000a132:	58 08       	cp.w	r8,0
8000a134:	c0 f0       	breq	8000a152 <_dtoa_r+0x5a>
8000a136:	72 1a       	ld.w	r10,r9[0x4]
8000a138:	91 1a       	st.w	r8[0x4],r10
8000a13a:	30 1a       	mov	r10,1
8000a13c:	72 19       	ld.w	r9,r9[0x4]
8000a13e:	f4 09 09 49 	lsl	r9,r10,r9
8000a142:	10 9b       	mov	r11,r8
8000a144:	91 29       	st.w	r8[0x8],r9
8000a146:	0e 9c       	mov	r12,r7
8000a148:	e0 a0 0a 90 	rcall	8000b668 <_Bfree>
8000a14c:	6e 98       	ld.w	r8,r7[0x24]
8000a14e:	30 09       	mov	r9,0
8000a150:	91 09       	st.w	r8[0x0],r9
8000a152:	40 28       	lddsp	r8,sp[0x8]
8000a154:	10 94       	mov	r4,r8
8000a156:	58 08       	cp.w	r8,0
8000a158:	c0 64       	brge	8000a164 <_dtoa_r+0x6c>
8000a15a:	f1 d8 c0 1f 	bfextu	r8,r8,0x0,0x1f
8000a15e:	50 28       	stdsp	sp[0x8],r8
8000a160:	30 18       	mov	r8,1
8000a162:	c0 28       	rjmp	8000a166 <_dtoa_r+0x6e>
8000a164:	30 08       	mov	r8,0
8000a166:	8d 08       	st.w	r6[0x0],r8
8000a168:	fc 1c 7f f0 	movh	r12,0x7ff0
8000a16c:	40 26       	lddsp	r6,sp[0x8]
8000a16e:	0c 98       	mov	r8,r6
8000a170:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000a174:	18 38       	cp.w	r8,r12
8000a176:	c2 01       	brne	8000a1b6 <_dtoa_r+0xbe>
8000a178:	e0 68 27 0f 	mov	r8,9999
8000a17c:	41 5b       	lddsp	r11,sp[0x54]
8000a17e:	97 08       	st.w	r11[0x0],r8
8000a180:	40 3a       	lddsp	r10,sp[0xc]
8000a182:	58 0a       	cp.w	r10,0
8000a184:	c0 71       	brne	8000a192 <_dtoa_r+0x9a>
8000a186:	ed d6 c0 14 	bfextu	r6,r6,0x0,0x14
8000a18a:	c0 41       	brne	8000a192 <_dtoa_r+0x9a>
8000a18c:	fe cc bd 8c 	sub	r12,pc,-17012
8000a190:	c0 38       	rjmp	8000a196 <_dtoa_r+0x9e>
8000a192:	fe cc bd 86 	sub	r12,pc,-17018
8000a196:	41 29       	lddsp	r9,sp[0x48]
8000a198:	58 09       	cp.w	r9,0
8000a19a:	e0 80 05 9a 	breq	8000acce <_dtoa_r+0xbd6>
8000a19e:	f8 c8 ff fd 	sub	r8,r12,-3
8000a1a2:	f8 c9 ff f8 	sub	r9,r12,-8
8000a1a6:	11 8b       	ld.ub	r11,r8[0x0]
8000a1a8:	30 0a       	mov	r10,0
8000a1aa:	41 25       	lddsp	r5,sp[0x48]
8000a1ac:	f4 0b 18 00 	cp.b	r11,r10
8000a1b0:	f2 08 17 10 	movne	r8,r9
8000a1b4:	c1 68       	rjmp	8000a1e0 <_dtoa_r+0xe8>
8000a1b6:	fa ea 00 08 	ld.d	r10,sp[8]
8000a1ba:	30 08       	mov	r8,0
8000a1bc:	fa eb 00 3c 	st.d	sp[60],r10
8000a1c0:	30 09       	mov	r9,0
8000a1c2:	e0 a0 10 c2 	rcall	8000c346 <__avr32_f64_cmp_eq>
8000a1c6:	c1 00       	breq	8000a1e6 <_dtoa_r+0xee>
8000a1c8:	30 18       	mov	r8,1
8000a1ca:	41 5a       	lddsp	r10,sp[0x54]
8000a1cc:	95 08       	st.w	r10[0x0],r8
8000a1ce:	fe cc be f2 	sub	r12,pc,-16654
8000a1d2:	41 29       	lddsp	r9,sp[0x48]
8000a1d4:	f8 08 00 08 	add	r8,r12,r8
8000a1d8:	58 09       	cp.w	r9,0
8000a1da:	e0 80 05 7a 	breq	8000acce <_dtoa_r+0xbd6>
8000a1de:	12 95       	mov	r5,r9
8000a1e0:	8b 08       	st.w	r5[0x0],r8
8000a1e2:	e0 8f 05 76 	bral	8000acce <_dtoa_r+0xbd6>
8000a1e6:	fa c8 ff 9c 	sub	r8,sp,-100
8000a1ea:	fa c9 ff a0 	sub	r9,sp,-96
8000a1ee:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a1f2:	0e 9c       	mov	r12,r7
8000a1f4:	eb d6 c2 8b 	bfextu	r5,r6,0x14,0xb
8000a1f8:	e0 a0 0a 8a 	rcall	8000b70c <__d2b>
8000a1fc:	18 93       	mov	r3,r12
8000a1fe:	58 05       	cp.w	r5,0
8000a200:	c0 d0       	breq	8000a21a <_dtoa_r+0x122>
8000a202:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a206:	30 04       	mov	r4,0
8000a208:	f1 db c0 14 	bfextu	r8,r11,0x0,0x14
8000a20c:	ea c5 03 ff 	sub	r5,r5,1023
8000a210:	10 9b       	mov	r11,r8
8000a212:	51 74       	stdsp	sp[0x5c],r4
8000a214:	ea 1b 3f f0 	orh	r11,0x3ff0
8000a218:	c2 58       	rjmp	8000a262 <_dtoa_r+0x16a>
8000a21a:	41 88       	lddsp	r8,sp[0x60]
8000a21c:	41 9c       	lddsp	r12,sp[0x64]
8000a21e:	10 0c       	add	r12,r8
8000a220:	f8 c5 fb ce 	sub	r5,r12,-1074
8000a224:	e0 45 00 20 	cp.w	r5,32
8000a228:	e0 8a 00 0e 	brle	8000a244 <_dtoa_r+0x14c>
8000a22c:	f8 cc fb ee 	sub	r12,r12,-1042
8000a230:	40 3b       	lddsp	r11,sp[0xc]
8000a232:	ea 08 11 40 	rsub	r8,r5,64
8000a236:	f6 0c 0a 4c 	lsr	r12,r11,r12
8000a23a:	ec 08 09 46 	lsl	r6,r6,r8
8000a23e:	0c 4c       	or	r12,r6
8000a240:	c0 78       	rjmp	8000a24e <_dtoa_r+0x156>
8000a242:	d7 03       	nop
8000a244:	ea 0c 11 20 	rsub	r12,r5,32
8000a248:	40 3a       	lddsp	r10,sp[0xc]
8000a24a:	f4 0c 09 4c 	lsl	r12,r10,r12
8000a24e:	e0 a0 10 08 	rcall	8000c25e <__avr32_u32_to_f64>
8000a252:	fc 18 fe 10 	movh	r8,0xfe10
8000a256:	30 19       	mov	r9,1
8000a258:	ea c5 04 33 	sub	r5,r5,1075
8000a25c:	f0 0b 00 0b 	add	r11,r8,r11
8000a260:	51 79       	stdsp	sp[0x5c],r9
8000a262:	30 08       	mov	r8,0
8000a264:	fc 19 3f f8 	movh	r9,0x3ff8
8000a268:	e0 a0 0e 90 	rcall	8000bf88 <__avr32_f64_sub>
8000a26c:	e0 68 43 61 	mov	r8,17249
8000a270:	ea 18 63 6f 	orh	r8,0x636f
8000a274:	e0 69 87 a7 	mov	r9,34727
8000a278:	ea 19 3f d2 	orh	r9,0x3fd2
8000a27c:	e0 a0 0d 9a 	rcall	8000bdb0 <__avr32_f64_mul>
8000a280:	e0 68 c8 b3 	mov	r8,51379
8000a284:	ea 18 8b 60 	orh	r8,0x8b60
8000a288:	e0 69 8a 28 	mov	r9,35368
8000a28c:	ea 19 3f c6 	orh	r9,0x3fc6
8000a290:	e0 a0 0f 4a 	rcall	8000c124 <__avr32_f64_add>
8000a294:	0a 9c       	mov	r12,r5
8000a296:	14 90       	mov	r0,r10
8000a298:	16 91       	mov	r1,r11
8000a29a:	e0 a0 0f e6 	rcall	8000c266 <__avr32_s32_to_f64>
8000a29e:	e0 68 79 fb 	mov	r8,31227
8000a2a2:	ea 18 50 9f 	orh	r8,0x509f
8000a2a6:	e0 69 44 13 	mov	r9,17427
8000a2aa:	ea 19 3f d3 	orh	r9,0x3fd3
8000a2ae:	e0 a0 0d 81 	rcall	8000bdb0 <__avr32_f64_mul>
8000a2b2:	14 98       	mov	r8,r10
8000a2b4:	16 99       	mov	r9,r11
8000a2b6:	00 9a       	mov	r10,r0
8000a2b8:	02 9b       	mov	r11,r1
8000a2ba:	e0 a0 0f 35 	rcall	8000c124 <__avr32_f64_add>
8000a2be:	14 90       	mov	r0,r10
8000a2c0:	16 91       	mov	r1,r11
8000a2c2:	e0 a0 0f bb 	rcall	8000c238 <__avr32_f64_to_s32>
8000a2c6:	30 08       	mov	r8,0
8000a2c8:	18 96       	mov	r6,r12
8000a2ca:	30 09       	mov	r9,0
8000a2cc:	00 9a       	mov	r10,r0
8000a2ce:	02 9b       	mov	r11,r1
8000a2d0:	e0 a0 10 82 	rcall	8000c3d4 <__avr32_f64_cmp_lt>
8000a2d4:	c0 c0       	breq	8000a2ec <_dtoa_r+0x1f4>
8000a2d6:	0c 9c       	mov	r12,r6
8000a2d8:	e0 a0 0f c7 	rcall	8000c266 <__avr32_s32_to_f64>
8000a2dc:	14 98       	mov	r8,r10
8000a2de:	16 99       	mov	r9,r11
8000a2e0:	00 9a       	mov	r10,r0
8000a2e2:	02 9b       	mov	r11,r1
8000a2e4:	e0 a0 10 31 	rcall	8000c346 <__avr32_f64_cmp_eq>
8000a2e8:	f7 b6 00 01 	subeq	r6,1
8000a2ec:	59 66       	cp.w	r6,22
8000a2ee:	e0 88 00 05 	brls	8000a2f8 <_dtoa_r+0x200>
8000a2f2:	30 18       	mov	r8,1
8000a2f4:	51 48       	stdsp	sp[0x50],r8
8000a2f6:	c1 38       	rjmp	8000a31c <_dtoa_r+0x224>
8000a2f8:	fe c8 be 38 	sub	r8,pc,-16840
8000a2fc:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a300:	f0 06 02 38 	ld.d	r8,r8[r6<<0x3]
8000a304:	e0 a0 10 68 	rcall	8000c3d4 <__avr32_f64_cmp_lt>
8000a308:	f9 b4 00 00 	moveq	r4,0
8000a30c:	fb f4 0a 14 	st.weq	sp[0x50],r4
8000a310:	f7 b6 01 01 	subne	r6,1
8000a314:	f9 bc 01 00 	movne	r12,0
8000a318:	fb fc 1a 14 	st.wne	sp[0x50],r12
8000a31c:	41 90       	lddsp	r0,sp[0x64]
8000a31e:	20 10       	sub	r0,1
8000a320:	0a 10       	sub	r0,r5
8000a322:	c0 46       	brmi	8000a32a <_dtoa_r+0x232>
8000a324:	50 40       	stdsp	sp[0x10],r0
8000a326:	30 00       	mov	r0,0
8000a328:	c0 48       	rjmp	8000a330 <_dtoa_r+0x238>
8000a32a:	30 0b       	mov	r11,0
8000a32c:	5c 30       	neg	r0
8000a32e:	50 4b       	stdsp	sp[0x10],r11
8000a330:	ec 02 11 00 	rsub	r2,r6,0
8000a334:	58 06       	cp.w	r6,0
8000a336:	fb fa 40 04 	ld.wge	r10,sp[0x10]
8000a33a:	f5 d6 e4 0a 	addge	r10,r10,r6
8000a33e:	fb fa 4a 04 	st.wge	sp[0x10],r10
8000a342:	fb f6 4a 11 	st.wge	sp[0x44],r6
8000a346:	f9 b2 04 00 	movge	r2,0
8000a34a:	e1 d6 e5 10 	sublt	r0,r0,r6
8000a34e:	f9 b9 05 00 	movlt	r9,0
8000a352:	fb f9 5a 11 	st.wlt	sp[0x44],r9
8000a356:	40 c8       	lddsp	r8,sp[0x30]
8000a358:	58 98       	cp.w	r8,9
8000a35a:	e0 8b 00 20 	brhi	8000a39a <_dtoa_r+0x2a2>
8000a35e:	58 58       	cp.w	r8,5
8000a360:	f9 b4 0a 01 	movle	r4,1
8000a364:	fb f5 90 0c 	ld.wgt	r5,sp[0x30]
8000a368:	f7 b5 09 04 	subgt	r5,4
8000a36c:	fb f5 9a 0c 	st.wgt	sp[0x30],r5
8000a370:	f9 b4 09 00 	movgt	r4,0
8000a374:	40 cc       	lddsp	r12,sp[0x30]
8000a376:	58 3c       	cp.w	r12,3
8000a378:	c2 d0       	breq	8000a3d2 <_dtoa_r+0x2da>
8000a37a:	e0 89 00 05 	brgt	8000a384 <_dtoa_r+0x28c>
8000a37e:	58 2c       	cp.w	r12,2
8000a380:	c1 01       	brne	8000a3a0 <_dtoa_r+0x2a8>
8000a382:	c1 88       	rjmp	8000a3b2 <_dtoa_r+0x2ba>
8000a384:	40 cb       	lddsp	r11,sp[0x30]
8000a386:	58 4b       	cp.w	r11,4
8000a388:	c0 60       	breq	8000a394 <_dtoa_r+0x29c>
8000a38a:	58 5b       	cp.w	r11,5
8000a38c:	c0 a1       	brne	8000a3a0 <_dtoa_r+0x2a8>
8000a38e:	30 1a       	mov	r10,1
8000a390:	50 da       	stdsp	sp[0x34],r10
8000a392:	c2 28       	rjmp	8000a3d6 <_dtoa_r+0x2de>
8000a394:	30 19       	mov	r9,1
8000a396:	50 d9       	stdsp	sp[0x34],r9
8000a398:	c0 f8       	rjmp	8000a3b6 <_dtoa_r+0x2be>
8000a39a:	30 08       	mov	r8,0
8000a39c:	30 14       	mov	r4,1
8000a39e:	50 c8       	stdsp	sp[0x30],r8
8000a3a0:	3f f5       	mov	r5,-1
8000a3a2:	30 1c       	mov	r12,1
8000a3a4:	30 0b       	mov	r11,0
8000a3a6:	50 95       	stdsp	sp[0x24],r5
8000a3a8:	50 dc       	stdsp	sp[0x34],r12
8000a3aa:	0a 91       	mov	r1,r5
8000a3ac:	31 28       	mov	r8,18
8000a3ae:	50 eb       	stdsp	sp[0x38],r11
8000a3b0:	c2 08       	rjmp	8000a3f0 <_dtoa_r+0x2f8>
8000a3b2:	30 0a       	mov	r10,0
8000a3b4:	50 da       	stdsp	sp[0x34],r10
8000a3b6:	40 e9       	lddsp	r9,sp[0x38]
8000a3b8:	58 09       	cp.w	r9,0
8000a3ba:	e0 89 00 07 	brgt	8000a3c8 <_dtoa_r+0x2d0>
8000a3be:	30 18       	mov	r8,1
8000a3c0:	50 98       	stdsp	sp[0x24],r8
8000a3c2:	10 91       	mov	r1,r8
8000a3c4:	50 e8       	stdsp	sp[0x38],r8
8000a3c6:	c1 58       	rjmp	8000a3f0 <_dtoa_r+0x2f8>
8000a3c8:	40 e5       	lddsp	r5,sp[0x38]
8000a3ca:	50 95       	stdsp	sp[0x24],r5
8000a3cc:	0a 91       	mov	r1,r5
8000a3ce:	0a 98       	mov	r8,r5
8000a3d0:	c1 08       	rjmp	8000a3f0 <_dtoa_r+0x2f8>
8000a3d2:	30 0c       	mov	r12,0
8000a3d4:	50 dc       	stdsp	sp[0x34],r12
8000a3d6:	40 eb       	lddsp	r11,sp[0x38]
8000a3d8:	ec 0b 00 0b 	add	r11,r6,r11
8000a3dc:	50 9b       	stdsp	sp[0x24],r11
8000a3de:	16 98       	mov	r8,r11
8000a3e0:	2f f8       	sub	r8,-1
8000a3e2:	58 08       	cp.w	r8,0
8000a3e4:	e0 89 00 05 	brgt	8000a3ee <_dtoa_r+0x2f6>
8000a3e8:	10 91       	mov	r1,r8
8000a3ea:	30 18       	mov	r8,1
8000a3ec:	c0 28       	rjmp	8000a3f0 <_dtoa_r+0x2f8>
8000a3ee:	10 91       	mov	r1,r8
8000a3f0:	30 09       	mov	r9,0
8000a3f2:	6e 9a       	ld.w	r10,r7[0x24]
8000a3f4:	95 19       	st.w	r10[0x4],r9
8000a3f6:	30 49       	mov	r9,4
8000a3f8:	c0 68       	rjmp	8000a404 <_dtoa_r+0x30c>
8000a3fa:	d7 03       	nop
8000a3fc:	6a 1a       	ld.w	r10,r5[0x4]
8000a3fe:	a1 79       	lsl	r9,0x1
8000a400:	2f fa       	sub	r10,-1
8000a402:	8b 1a       	st.w	r5[0x4],r10
8000a404:	6e 95       	ld.w	r5,r7[0x24]
8000a406:	f2 ca ff ec 	sub	r10,r9,-20
8000a40a:	10 3a       	cp.w	r10,r8
8000a40c:	fe 98 ff f8 	brls	8000a3fc <_dtoa_r+0x304>
8000a410:	6a 1b       	ld.w	r11,r5[0x4]
8000a412:	0e 9c       	mov	r12,r7
8000a414:	e0 a0 09 44 	rcall	8000b69c <_Balloc>
8000a418:	58 e1       	cp.w	r1,14
8000a41a:	5f 88       	srls	r8
8000a41c:	8b 0c       	st.w	r5[0x0],r12
8000a41e:	f1 e4 00 04 	and	r4,r8,r4
8000a422:	6e 98       	ld.w	r8,r7[0x24]
8000a424:	70 08       	ld.w	r8,r8[0x0]
8000a426:	50 88       	stdsp	sp[0x20],r8
8000a428:	e0 80 01 82 	breq	8000a72c <_dtoa_r+0x634>
8000a42c:	58 06       	cp.w	r6,0
8000a42e:	e0 8a 00 43 	brle	8000a4b4 <_dtoa_r+0x3bc>
8000a432:	f3 d6 c0 04 	bfextu	r9,r6,0x0,0x4
8000a436:	fe c8 bf 76 	sub	r8,pc,-16522
8000a43a:	f0 09 02 34 	ld.d	r4,r8[r9<<0x3]
8000a43e:	fa e5 00 18 	st.d	sp[24],r4
8000a442:	ec 04 14 04 	asr	r4,r6,0x4
8000a446:	ed b4 00 04 	bld	r4,0x4
8000a44a:	c0 30       	breq	8000a450 <_dtoa_r+0x358>
8000a44c:	30 25       	mov	r5,2
8000a44e:	c1 08       	rjmp	8000a46e <_dtoa_r+0x376>
8000a450:	fe c8 be c8 	sub	r8,pc,-16696
8000a454:	f0 e8 00 20 	ld.d	r8,r8[32]
8000a458:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a45c:	e9 d4 c0 04 	bfextu	r4,r4,0x0,0x4
8000a460:	e0 a0 0f ee 	rcall	8000c43c <__avr32_f64_div>
8000a464:	30 35       	mov	r5,3
8000a466:	14 98       	mov	r8,r10
8000a468:	16 99       	mov	r9,r11
8000a46a:	fa e9 00 08 	st.d	sp[8],r8
8000a46e:	fe cc be e6 	sub	r12,pc,-16666
8000a472:	50 a3       	stdsp	sp[0x28],r3
8000a474:	0c 93       	mov	r3,r6
8000a476:	18 96       	mov	r6,r12
8000a478:	c0 f8       	rjmp	8000a496 <_dtoa_r+0x39e>
8000a47a:	fa ea 00 18 	ld.d	r10,sp[24]
8000a47e:	ed b4 00 00 	bld	r4,0x0
8000a482:	c0 81       	brne	8000a492 <_dtoa_r+0x39a>
8000a484:	ec e8 00 00 	ld.d	r8,r6[0]
8000a488:	2f f5       	sub	r5,-1
8000a48a:	e0 a0 0c 93 	rcall	8000bdb0 <__avr32_f64_mul>
8000a48e:	fa eb 00 18 	st.d	sp[24],r10
8000a492:	a1 54       	asr	r4,0x1
8000a494:	2f 86       	sub	r6,-8
8000a496:	58 04       	cp.w	r4,0
8000a498:	cf 11       	brne	8000a47a <_dtoa_r+0x382>
8000a49a:	fa e8 00 18 	ld.d	r8,sp[24]
8000a49e:	fa ea 00 08 	ld.d	r10,sp[8]
8000a4a2:	06 96       	mov	r6,r3
8000a4a4:	e0 a0 0f cc 	rcall	8000c43c <__avr32_f64_div>
8000a4a8:	40 a3       	lddsp	r3,sp[0x28]
8000a4aa:	14 98       	mov	r8,r10
8000a4ac:	16 99       	mov	r9,r11
8000a4ae:	fa e9 00 08 	st.d	sp[8],r8
8000a4b2:	c2 f8       	rjmp	8000a510 <_dtoa_r+0x418>
8000a4b4:	ec 08 11 00 	rsub	r8,r6,0
8000a4b8:	c0 31       	brne	8000a4be <_dtoa_r+0x3c6>
8000a4ba:	30 25       	mov	r5,2
8000a4bc:	c2 a8       	rjmp	8000a510 <_dtoa_r+0x418>
8000a4be:	fe cc bf 36 	sub	r12,pc,-16586
8000a4c2:	f0 04 14 04 	asr	r4,r8,0x4
8000a4c6:	50 1c       	stdsp	sp[0x4],r12
8000a4c8:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
8000a4cc:	fe c9 c0 0c 	sub	r9,pc,-16372
8000a4d0:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a4d4:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000a4d8:	e0 a0 0c 6c 	rcall	8000bdb0 <__avr32_f64_mul>
8000a4dc:	40 1c       	lddsp	r12,sp[0x4]
8000a4de:	50 63       	stdsp	sp[0x18],r3
8000a4e0:	30 25       	mov	r5,2
8000a4e2:	0c 93       	mov	r3,r6
8000a4e4:	fa eb 00 08 	st.d	sp[8],r10
8000a4e8:	18 96       	mov	r6,r12
8000a4ea:	c0 f8       	rjmp	8000a508 <_dtoa_r+0x410>
8000a4ec:	fa ea 00 08 	ld.d	r10,sp[8]
8000a4f0:	ed b4 00 00 	bld	r4,0x0
8000a4f4:	c0 81       	brne	8000a504 <_dtoa_r+0x40c>
8000a4f6:	ec e8 00 00 	ld.d	r8,r6[0]
8000a4fa:	2f f5       	sub	r5,-1
8000a4fc:	e0 a0 0c 5a 	rcall	8000bdb0 <__avr32_f64_mul>
8000a500:	fa eb 00 08 	st.d	sp[8],r10
8000a504:	a1 54       	asr	r4,0x1
8000a506:	2f 86       	sub	r6,-8
8000a508:	58 04       	cp.w	r4,0
8000a50a:	cf 11       	brne	8000a4ec <_dtoa_r+0x3f4>
8000a50c:	06 96       	mov	r6,r3
8000a50e:	40 63       	lddsp	r3,sp[0x18]
8000a510:	41 4a       	lddsp	r10,sp[0x50]
8000a512:	58 0a       	cp.w	r10,0
8000a514:	c2 a0       	breq	8000a568 <_dtoa_r+0x470>
8000a516:	fa e8 00 08 	ld.d	r8,sp[8]
8000a51a:	58 01       	cp.w	r1,0
8000a51c:	5f 94       	srgt	r4
8000a51e:	fa e9 00 18 	st.d	sp[24],r8
8000a522:	30 08       	mov	r8,0
8000a524:	fc 19 3f f0 	movh	r9,0x3ff0
8000a528:	fa ea 00 18 	ld.d	r10,sp[24]
8000a52c:	e0 a0 0f 54 	rcall	8000c3d4 <__avr32_f64_cmp_lt>
8000a530:	f9 bc 00 00 	moveq	r12,0
8000a534:	f9 bc 01 01 	movne	r12,1
8000a538:	e9 ec 00 0c 	and	r12,r4,r12
8000a53c:	c1 60       	breq	8000a568 <_dtoa_r+0x470>
8000a53e:	40 98       	lddsp	r8,sp[0x24]
8000a540:	58 08       	cp.w	r8,0
8000a542:	e0 8a 00 f1 	brle	8000a724 <_dtoa_r+0x62c>
8000a546:	30 08       	mov	r8,0
8000a548:	fc 19 40 24 	movh	r9,0x4024
8000a54c:	ec c4 00 01 	sub	r4,r6,1
8000a550:	fa ea 00 18 	ld.d	r10,sp[24]
8000a554:	2f f5       	sub	r5,-1
8000a556:	50 64       	stdsp	sp[0x18],r4
8000a558:	e0 a0 0c 2c 	rcall	8000bdb0 <__avr32_f64_mul>
8000a55c:	40 94       	lddsp	r4,sp[0x24]
8000a55e:	14 98       	mov	r8,r10
8000a560:	16 99       	mov	r9,r11
8000a562:	fa e9 00 08 	st.d	sp[8],r8
8000a566:	c0 38       	rjmp	8000a56c <_dtoa_r+0x474>
8000a568:	50 66       	stdsp	sp[0x18],r6
8000a56a:	02 94       	mov	r4,r1
8000a56c:	0a 9c       	mov	r12,r5
8000a56e:	e0 a0 0e 7c 	rcall	8000c266 <__avr32_s32_to_f64>
8000a572:	fa e8 00 08 	ld.d	r8,sp[8]
8000a576:	e0 a0 0c 1d 	rcall	8000bdb0 <__avr32_f64_mul>
8000a57a:	30 08       	mov	r8,0
8000a57c:	fc 19 40 1c 	movh	r9,0x401c
8000a580:	e0 a0 0d d2 	rcall	8000c124 <__avr32_f64_add>
8000a584:	14 98       	mov	r8,r10
8000a586:	16 99       	mov	r9,r11
8000a588:	fa e9 00 28 	st.d	sp[40],r8
8000a58c:	fc 18 fc c0 	movh	r8,0xfcc0
8000a590:	40 a5       	lddsp	r5,sp[0x28]
8000a592:	10 05       	add	r5,r8
8000a594:	50 a5       	stdsp	sp[0x28],r5
8000a596:	58 04       	cp.w	r4,0
8000a598:	c2 11       	brne	8000a5da <_dtoa_r+0x4e2>
8000a59a:	fa ea 00 08 	ld.d	r10,sp[8]
8000a59e:	30 08       	mov	r8,0
8000a5a0:	fc 19 40 14 	movh	r9,0x4014
8000a5a4:	e0 a0 0c f2 	rcall	8000bf88 <__avr32_f64_sub>
8000a5a8:	40 bc       	lddsp	r12,sp[0x2c]
8000a5aa:	fa eb 00 08 	st.d	sp[8],r10
8000a5ae:	14 98       	mov	r8,r10
8000a5b0:	16 99       	mov	r9,r11
8000a5b2:	18 9a       	mov	r10,r12
8000a5b4:	0a 9b       	mov	r11,r5
8000a5b6:	e0 a0 0f 0f 	rcall	8000c3d4 <__avr32_f64_cmp_lt>
8000a5ba:	e0 81 02 54 	brne	8000aa62 <_dtoa_r+0x96a>
8000a5be:	0a 98       	mov	r8,r5
8000a5c0:	40 b9       	lddsp	r9,sp[0x2c]
8000a5c2:	ee 18 80 00 	eorh	r8,0x8000
8000a5c6:	fa ea 00 08 	ld.d	r10,sp[8]
8000a5ca:	10 95       	mov	r5,r8
8000a5cc:	12 98       	mov	r8,r9
8000a5ce:	0a 99       	mov	r9,r5
8000a5d0:	e0 a0 0f 02 	rcall	8000c3d4 <__avr32_f64_cmp_lt>
8000a5d4:	e0 81 02 3e 	brne	8000aa50 <_dtoa_r+0x958>
8000a5d8:	ca 68       	rjmp	8000a724 <_dtoa_r+0x62c>
8000a5da:	fe c9 c1 1a 	sub	r9,pc,-16102
8000a5de:	e8 c8 00 01 	sub	r8,r4,1
8000a5e2:	40 d5       	lddsp	r5,sp[0x34]
8000a5e4:	58 05       	cp.w	r5,0
8000a5e6:	c4 f0       	breq	8000a684 <_dtoa_r+0x58c>
8000a5e8:	30 0c       	mov	r12,0
8000a5ea:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000a5ee:	51 3c       	stdsp	sp[0x4c],r12
8000a5f0:	30 0a       	mov	r10,0
8000a5f2:	fc 1b 3f e0 	movh	r11,0x3fe0
8000a5f6:	e0 a0 0f 23 	rcall	8000c43c <__avr32_f64_div>
8000a5fa:	fa e8 00 28 	ld.d	r8,sp[40]
8000a5fe:	40 85       	lddsp	r5,sp[0x20]
8000a600:	e0 a0 0c c4 	rcall	8000bf88 <__avr32_f64_sub>
8000a604:	fa eb 00 28 	st.d	sp[40],r10
8000a608:	fa ea 00 08 	ld.d	r10,sp[8]
8000a60c:	e0 a0 0e 16 	rcall	8000c238 <__avr32_f64_to_s32>
8000a610:	51 6c       	stdsp	sp[0x58],r12
8000a612:	e0 a0 0e 2a 	rcall	8000c266 <__avr32_s32_to_f64>
8000a616:	14 98       	mov	r8,r10
8000a618:	16 99       	mov	r9,r11
8000a61a:	fa ea 00 08 	ld.d	r10,sp[8]
8000a61e:	e0 a0 0c b5 	rcall	8000bf88 <__avr32_f64_sub>
8000a622:	fa eb 00 08 	st.d	sp[8],r10
8000a626:	41 68       	lddsp	r8,sp[0x58]
8000a628:	2d 08       	sub	r8,-48
8000a62a:	0a c8       	st.b	r5++,r8
8000a62c:	41 39       	lddsp	r9,sp[0x4c]
8000a62e:	2f f9       	sub	r9,-1
8000a630:	51 39       	stdsp	sp[0x4c],r9
8000a632:	fa e8 00 28 	ld.d	r8,sp[40]
8000a636:	e0 a0 0e cf 	rcall	8000c3d4 <__avr32_f64_cmp_lt>
8000a63a:	e0 81 03 39 	brne	8000acac <_dtoa_r+0xbb4>
8000a63e:	fa e8 00 08 	ld.d	r8,sp[8]
8000a642:	30 0a       	mov	r10,0
8000a644:	fc 1b 3f f0 	movh	r11,0x3ff0
8000a648:	e0 a0 0c a0 	rcall	8000bf88 <__avr32_f64_sub>
8000a64c:	fa e8 00 28 	ld.d	r8,sp[40]
8000a650:	e0 a0 0e c2 	rcall	8000c3d4 <__avr32_f64_cmp_lt>
8000a654:	fa ea 00 28 	ld.d	r10,sp[40]
8000a658:	30 08       	mov	r8,0
8000a65a:	fc 19 40 24 	movh	r9,0x4024
8000a65e:	e0 81 00 da 	brne	8000a812 <_dtoa_r+0x71a>
8000a662:	41 3c       	lddsp	r12,sp[0x4c]
8000a664:	08 3c       	cp.w	r12,r4
8000a666:	c5 f4       	brge	8000a724 <_dtoa_r+0x62c>
8000a668:	e0 a0 0b a4 	rcall	8000bdb0 <__avr32_f64_mul>
8000a66c:	30 08       	mov	r8,0
8000a66e:	fa eb 00 28 	st.d	sp[40],r10
8000a672:	fc 19 40 24 	movh	r9,0x4024
8000a676:	fa ea 00 08 	ld.d	r10,sp[8]
8000a67a:	e0 a0 0b 9b 	rcall	8000bdb0 <__avr32_f64_mul>
8000a67e:	fa eb 00 08 	st.d	sp[8],r10
8000a682:	cc 3b       	rjmp	8000a608 <_dtoa_r+0x510>
8000a684:	40 85       	lddsp	r5,sp[0x20]
8000a686:	08 05       	add	r5,r4
8000a688:	f2 08 02 3a 	ld.d	r10,r9[r8<<0x3]
8000a68c:	51 35       	stdsp	sp[0x4c],r5
8000a68e:	fa e8 00 28 	ld.d	r8,sp[40]
8000a692:	40 85       	lddsp	r5,sp[0x20]
8000a694:	e0 a0 0b 8e 	rcall	8000bdb0 <__avr32_f64_mul>
8000a698:	fa eb 00 28 	st.d	sp[40],r10
8000a69c:	fa ea 00 08 	ld.d	r10,sp[8]
8000a6a0:	e0 a0 0d cc 	rcall	8000c238 <__avr32_f64_to_s32>
8000a6a4:	51 6c       	stdsp	sp[0x58],r12
8000a6a6:	e0 a0 0d e0 	rcall	8000c266 <__avr32_s32_to_f64>
8000a6aa:	14 98       	mov	r8,r10
8000a6ac:	16 99       	mov	r9,r11
8000a6ae:	fa ea 00 08 	ld.d	r10,sp[8]
8000a6b2:	e0 a0 0c 6b 	rcall	8000bf88 <__avr32_f64_sub>
8000a6b6:	fa eb 00 08 	st.d	sp[8],r10
8000a6ba:	41 68       	lddsp	r8,sp[0x58]
8000a6bc:	2d 08       	sub	r8,-48
8000a6be:	0a c8       	st.b	r5++,r8
8000a6c0:	41 3c       	lddsp	r12,sp[0x4c]
8000a6c2:	18 35       	cp.w	r5,r12
8000a6c4:	c2 81       	brne	8000a714 <_dtoa_r+0x61c>
8000a6c6:	30 08       	mov	r8,0
8000a6c8:	fc 19 3f e0 	movh	r9,0x3fe0
8000a6cc:	fa ea 00 28 	ld.d	r10,sp[40]
8000a6d0:	e0 a0 0d 2a 	rcall	8000c124 <__avr32_f64_add>
8000a6d4:	40 85       	lddsp	r5,sp[0x20]
8000a6d6:	fa e8 00 08 	ld.d	r8,sp[8]
8000a6da:	08 05       	add	r5,r4
8000a6dc:	e0 a0 0e 7c 	rcall	8000c3d4 <__avr32_f64_cmp_lt>
8000a6e0:	e0 81 00 99 	brne	8000a812 <_dtoa_r+0x71a>
8000a6e4:	fa e8 00 28 	ld.d	r8,sp[40]
8000a6e8:	30 0a       	mov	r10,0
8000a6ea:	fc 1b 3f e0 	movh	r11,0x3fe0
8000a6ee:	e0 a0 0c 4d 	rcall	8000bf88 <__avr32_f64_sub>
8000a6f2:	14 98       	mov	r8,r10
8000a6f4:	16 99       	mov	r9,r11
8000a6f6:	fa ea 00 08 	ld.d	r10,sp[8]
8000a6fa:	e0 a0 0e 6d 	rcall	8000c3d4 <__avr32_f64_cmp_lt>
8000a6fe:	c1 30       	breq	8000a724 <_dtoa_r+0x62c>
8000a700:	33 09       	mov	r9,48
8000a702:	0a 98       	mov	r8,r5
8000a704:	11 7a       	ld.ub	r10,--r8
8000a706:	f2 0a 18 00 	cp.b	r10,r9
8000a70a:	e0 81 02 d1 	brne	8000acac <_dtoa_r+0xbb4>
8000a70e:	10 95       	mov	r5,r8
8000a710:	cf 9b       	rjmp	8000a702 <_dtoa_r+0x60a>
8000a712:	d7 03       	nop
8000a714:	30 08       	mov	r8,0
8000a716:	fc 19 40 24 	movh	r9,0x4024
8000a71a:	e0 a0 0b 4b 	rcall	8000bdb0 <__avr32_f64_mul>
8000a71e:	fa eb 00 08 	st.d	sp[8],r10
8000a722:	cb db       	rjmp	8000a69c <_dtoa_r+0x5a4>
8000a724:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a728:	fa eb 00 08 	st.d	sp[8],r10
8000a72c:	58 e6       	cp.w	r6,14
8000a72e:	5f ab       	srle	r11
8000a730:	41 8a       	lddsp	r10,sp[0x60]
8000a732:	30 08       	mov	r8,0
8000a734:	f4 09 11 ff 	rsub	r9,r10,-1
8000a738:	f7 e9 03 f9 	and	r9,r11,r9>>0x1f
8000a73c:	f0 09 18 00 	cp.b	r9,r8
8000a740:	e0 80 00 82 	breq	8000a844 <_dtoa_r+0x74c>
8000a744:	40 ea       	lddsp	r10,sp[0x38]
8000a746:	58 01       	cp.w	r1,0
8000a748:	5f a9       	srle	r9
8000a74a:	f3 ea 03 f9 	and	r9,r9,r10>>0x1f
8000a74e:	fe ca c2 8e 	sub	r10,pc,-15730
8000a752:	f4 06 02 34 	ld.d	r4,r10[r6<<0x3]
8000a756:	fa e5 00 10 	st.d	sp[16],r4
8000a75a:	f0 09 18 00 	cp.b	r9,r8
8000a75e:	c1 40       	breq	8000a786 <_dtoa_r+0x68e>
8000a760:	58 01       	cp.w	r1,0
8000a762:	e0 81 01 77 	brne	8000aa50 <_dtoa_r+0x958>
8000a766:	30 08       	mov	r8,0
8000a768:	fc 19 40 14 	movh	r9,0x4014
8000a76c:	08 9a       	mov	r10,r4
8000a76e:	0a 9b       	mov	r11,r5
8000a770:	e0 a0 0b 20 	rcall	8000bdb0 <__avr32_f64_mul>
8000a774:	fa e8 00 08 	ld.d	r8,sp[8]
8000a778:	e0 a0 0d fa 	rcall	8000c36c <__avr32_f64_cmp_ge>
8000a77c:	e0 81 01 6a 	brne	8000aa50 <_dtoa_r+0x958>
8000a780:	02 92       	mov	r2,r1
8000a782:	e0 8f 01 72 	bral	8000aa66 <_dtoa_r+0x96e>
8000a786:	40 85       	lddsp	r5,sp[0x20]
8000a788:	30 14       	mov	r4,1
8000a78a:	fa e8 00 10 	ld.d	r8,sp[16]
8000a78e:	fa ea 00 08 	ld.d	r10,sp[8]
8000a792:	e0 a0 0e 55 	rcall	8000c43c <__avr32_f64_div>
8000a796:	e0 a0 0d 51 	rcall	8000c238 <__avr32_f64_to_s32>
8000a79a:	18 92       	mov	r2,r12
8000a79c:	e0 a0 0d 65 	rcall	8000c266 <__avr32_s32_to_f64>
8000a7a0:	fa e8 00 10 	ld.d	r8,sp[16]
8000a7a4:	e0 a0 0b 06 	rcall	8000bdb0 <__avr32_f64_mul>
8000a7a8:	14 98       	mov	r8,r10
8000a7aa:	16 99       	mov	r9,r11
8000a7ac:	fa ea 00 08 	ld.d	r10,sp[8]
8000a7b0:	e0 a0 0b ec 	rcall	8000bf88 <__avr32_f64_sub>
8000a7b4:	fa eb 00 08 	st.d	sp[8],r10
8000a7b8:	e4 c8 ff d0 	sub	r8,r2,-48
8000a7bc:	0a c8       	st.b	r5++,r8
8000a7be:	fc 19 40 24 	movh	r9,0x4024
8000a7c2:	30 08       	mov	r8,0
8000a7c4:	02 34       	cp.w	r4,r1
8000a7c6:	c3 31       	brne	8000a82c <_dtoa_r+0x734>
8000a7c8:	fa e8 00 08 	ld.d	r8,sp[8]
8000a7cc:	e0 a0 0c ac 	rcall	8000c124 <__avr32_f64_add>
8000a7d0:	16 91       	mov	r1,r11
8000a7d2:	14 90       	mov	r0,r10
8000a7d4:	14 98       	mov	r8,r10
8000a7d6:	02 99       	mov	r9,r1
8000a7d8:	fa ea 00 10 	ld.d	r10,sp[16]
8000a7dc:	e0 a0 0d fc 	rcall	8000c3d4 <__avr32_f64_cmp_lt>
8000a7e0:	c1 a1       	brne	8000a814 <_dtoa_r+0x71c>
8000a7e2:	fa e8 00 10 	ld.d	r8,sp[16]
8000a7e6:	00 9a       	mov	r10,r0
8000a7e8:	02 9b       	mov	r11,r1
8000a7ea:	e0 a0 0d ae 	rcall	8000c346 <__avr32_f64_cmp_eq>
8000a7ee:	e0 80 02 5e 	breq	8000acaa <_dtoa_r+0xbb2>
8000a7f2:	e5 d2 c0 01 	bfextu	r2,r2,0x0,0x1
8000a7f6:	c0 f1       	brne	8000a814 <_dtoa_r+0x71c>
8000a7f8:	e0 8f 02 59 	bral	8000acaa <_dtoa_r+0xbb2>
8000a7fc:	40 8a       	lddsp	r10,sp[0x20]
8000a7fe:	14 38       	cp.w	r8,r10
8000a800:	c0 30       	breq	8000a806 <_dtoa_r+0x70e>
8000a802:	10 95       	mov	r5,r8
8000a804:	c0 98       	rjmp	8000a816 <_dtoa_r+0x71e>
8000a806:	33 08       	mov	r8,48
8000a808:	40 89       	lddsp	r9,sp[0x20]
8000a80a:	2f f6       	sub	r6,-1
8000a80c:	b2 88       	st.b	r9[0x0],r8
8000a80e:	40 88       	lddsp	r8,sp[0x20]
8000a810:	c0 88       	rjmp	8000a820 <_dtoa_r+0x728>
8000a812:	40 66       	lddsp	r6,sp[0x18]
8000a814:	33 99       	mov	r9,57
8000a816:	0a 98       	mov	r8,r5
8000a818:	11 7a       	ld.ub	r10,--r8
8000a81a:	f2 0a 18 00 	cp.b	r10,r9
8000a81e:	ce f0       	breq	8000a7fc <_dtoa_r+0x704>
8000a820:	50 66       	stdsp	sp[0x18],r6
8000a822:	11 89       	ld.ub	r9,r8[0x0]
8000a824:	2f f9       	sub	r9,-1
8000a826:	b0 89       	st.b	r8[0x0],r9
8000a828:	e0 8f 02 42 	bral	8000acac <_dtoa_r+0xbb4>
8000a82c:	e0 a0 0a c2 	rcall	8000bdb0 <__avr32_f64_mul>
8000a830:	2f f4       	sub	r4,-1
8000a832:	fa eb 00 08 	st.d	sp[8],r10
8000a836:	30 08       	mov	r8,0
8000a838:	30 09       	mov	r9,0
8000a83a:	e0 a0 0d 86 	rcall	8000c346 <__avr32_f64_cmp_eq>
8000a83e:	ca 60       	breq	8000a78a <_dtoa_r+0x692>
8000a840:	e0 8f 02 35 	bral	8000acaa <_dtoa_r+0xbb2>
8000a844:	40 d8       	lddsp	r8,sp[0x34]
8000a846:	58 08       	cp.w	r8,0
8000a848:	c0 51       	brne	8000a852 <_dtoa_r+0x75a>
8000a84a:	04 98       	mov	r8,r2
8000a84c:	00 95       	mov	r5,r0
8000a84e:	40 d4       	lddsp	r4,sp[0x34]
8000a850:	c3 78       	rjmp	8000a8be <_dtoa_r+0x7c6>
8000a852:	40 c5       	lddsp	r5,sp[0x30]
8000a854:	58 15       	cp.w	r5,1
8000a856:	e0 89 00 0f 	brgt	8000a874 <_dtoa_r+0x77c>
8000a85a:	41 74       	lddsp	r4,sp[0x5c]
8000a85c:	58 04       	cp.w	r4,0
8000a85e:	c0 40       	breq	8000a866 <_dtoa_r+0x76e>
8000a860:	f4 c9 fb cd 	sub	r9,r10,-1075
8000a864:	c0 48       	rjmp	8000a86c <_dtoa_r+0x774>
8000a866:	41 99       	lddsp	r9,sp[0x64]
8000a868:	f2 09 11 36 	rsub	r9,r9,54
8000a86c:	04 98       	mov	r8,r2
8000a86e:	00 95       	mov	r5,r0
8000a870:	c1 c8       	rjmp	8000a8a8 <_dtoa_r+0x7b0>
8000a872:	d7 03       	nop
8000a874:	e2 c8 00 01 	sub	r8,r1,1
8000a878:	58 01       	cp.w	r1,0
8000a87a:	e0 05 17 40 	movge	r5,r0
8000a87e:	e2 09 17 40 	movge	r9,r1
8000a882:	e1 d1 e5 15 	sublt	r5,r0,r1
8000a886:	f9 b9 05 00 	movlt	r9,0
8000a88a:	10 32       	cp.w	r2,r8
8000a88c:	e5 d8 e4 18 	subge	r8,r2,r8
8000a890:	f1 d2 e5 18 	sublt	r8,r8,r2
8000a894:	e5 d8 e5 02 	addlt	r2,r2,r8
8000a898:	fb fc 50 11 	ld.wlt	r12,sp[0x44]
8000a89c:	f9 d8 e5 0c 	addlt	r12,r12,r8
8000a8a0:	fb fc 5a 11 	st.wlt	sp[0x44],r12
8000a8a4:	f9 b8 05 00 	movlt	r8,0
8000a8a8:	40 4b       	lddsp	r11,sp[0x10]
8000a8aa:	12 0b       	add	r11,r9
8000a8ac:	50 08       	stdsp	sp[0x0],r8
8000a8ae:	50 4b       	stdsp	sp[0x10],r11
8000a8b0:	12 00       	add	r0,r9
8000a8b2:	30 1b       	mov	r11,1
8000a8b4:	0e 9c       	mov	r12,r7
8000a8b6:	e0 a0 08 a7 	rcall	8000ba04 <__i2b>
8000a8ba:	40 08       	lddsp	r8,sp[0x0]
8000a8bc:	18 94       	mov	r4,r12
8000a8be:	40 4a       	lddsp	r10,sp[0x10]
8000a8c0:	58 05       	cp.w	r5,0
8000a8c2:	5f 99       	srgt	r9
8000a8c4:	58 0a       	cp.w	r10,0
8000a8c6:	5f 9a       	srgt	r10
8000a8c8:	f5 e9 00 09 	and	r9,r10,r9
8000a8cc:	c0 80       	breq	8000a8dc <_dtoa_r+0x7e4>
8000a8ce:	40 4c       	lddsp	r12,sp[0x10]
8000a8d0:	f8 05 0d 49 	min	r9,r12,r5
8000a8d4:	12 1c       	sub	r12,r9
8000a8d6:	12 10       	sub	r0,r9
8000a8d8:	50 4c       	stdsp	sp[0x10],r12
8000a8da:	12 15       	sub	r5,r9
8000a8dc:	58 02       	cp.w	r2,0
8000a8de:	e0 8a 00 27 	brle	8000a92c <_dtoa_r+0x834>
8000a8e2:	40 db       	lddsp	r11,sp[0x34]
8000a8e4:	58 0b       	cp.w	r11,0
8000a8e6:	c1 d0       	breq	8000a920 <_dtoa_r+0x828>
8000a8e8:	58 08       	cp.w	r8,0
8000a8ea:	e0 8a 00 17 	brle	8000a918 <_dtoa_r+0x820>
8000a8ee:	10 9a       	mov	r10,r8
8000a8f0:	50 08       	stdsp	sp[0x0],r8
8000a8f2:	08 9b       	mov	r11,r4
8000a8f4:	0e 9c       	mov	r12,r7
8000a8f6:	e0 a0 08 cd 	rcall	8000ba90 <__pow5mult>
8000a8fa:	06 9a       	mov	r10,r3
8000a8fc:	18 9b       	mov	r11,r12
8000a8fe:	18 94       	mov	r4,r12
8000a900:	0e 9c       	mov	r12,r7
8000a902:	e0 a0 08 01 	rcall	8000b904 <__multiply>
8000a906:	18 99       	mov	r9,r12
8000a908:	06 9b       	mov	r11,r3
8000a90a:	50 19       	stdsp	sp[0x4],r9
8000a90c:	0e 9c       	mov	r12,r7
8000a90e:	e0 a0 06 ad 	rcall	8000b668 <_Bfree>
8000a912:	40 19       	lddsp	r9,sp[0x4]
8000a914:	40 08       	lddsp	r8,sp[0x0]
8000a916:	12 93       	mov	r3,r9
8000a918:	e4 08 01 0a 	sub	r10,r2,r8
8000a91c:	c0 80       	breq	8000a92c <_dtoa_r+0x834>
8000a91e:	c0 28       	rjmp	8000a922 <_dtoa_r+0x82a>
8000a920:	04 9a       	mov	r10,r2
8000a922:	06 9b       	mov	r11,r3
8000a924:	0e 9c       	mov	r12,r7
8000a926:	e0 a0 08 b5 	rcall	8000ba90 <__pow5mult>
8000a92a:	18 93       	mov	r3,r12
8000a92c:	30 1b       	mov	r11,1
8000a92e:	0e 9c       	mov	r12,r7
8000a930:	e0 a0 08 6a 	rcall	8000ba04 <__i2b>
8000a934:	41 1a       	lddsp	r10,sp[0x44]
8000a936:	18 92       	mov	r2,r12
8000a938:	58 0a       	cp.w	r10,0
8000a93a:	e0 8a 00 07 	brle	8000a948 <_dtoa_r+0x850>
8000a93e:	18 9b       	mov	r11,r12
8000a940:	0e 9c       	mov	r12,r7
8000a942:	e0 a0 08 a7 	rcall	8000ba90 <__pow5mult>
8000a946:	18 92       	mov	r2,r12
8000a948:	40 c9       	lddsp	r9,sp[0x30]
8000a94a:	58 19       	cp.w	r9,1
8000a94c:	e0 89 00 14 	brgt	8000a974 <_dtoa_r+0x87c>
8000a950:	40 38       	lddsp	r8,sp[0xc]
8000a952:	58 08       	cp.w	r8,0
8000a954:	c1 01       	brne	8000a974 <_dtoa_r+0x87c>
8000a956:	40 29       	lddsp	r9,sp[0x8]
8000a958:	f1 d9 c0 14 	bfextu	r8,r9,0x0,0x14
8000a95c:	c0 c1       	brne	8000a974 <_dtoa_r+0x87c>
8000a95e:	12 98       	mov	r8,r9
8000a960:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000a964:	c0 80       	breq	8000a974 <_dtoa_r+0x87c>
8000a966:	40 4c       	lddsp	r12,sp[0x10]
8000a968:	30 1b       	mov	r11,1
8000a96a:	2f fc       	sub	r12,-1
8000a96c:	2f f0       	sub	r0,-1
8000a96e:	50 4c       	stdsp	sp[0x10],r12
8000a970:	50 6b       	stdsp	sp[0x18],r11
8000a972:	c0 38       	rjmp	8000a978 <_dtoa_r+0x880>
8000a974:	30 0a       	mov	r10,0
8000a976:	50 6a       	stdsp	sp[0x18],r10
8000a978:	41 19       	lddsp	r9,sp[0x44]
8000a97a:	58 09       	cp.w	r9,0
8000a97c:	c0 31       	brne	8000a982 <_dtoa_r+0x88a>
8000a97e:	30 1c       	mov	r12,1
8000a980:	c0 98       	rjmp	8000a992 <_dtoa_r+0x89a>
8000a982:	64 48       	ld.w	r8,r2[0x10]
8000a984:	2f c8       	sub	r8,-4
8000a986:	e4 08 03 2c 	ld.w	r12,r2[r8<<0x2]
8000a98a:	e0 a0 05 df 	rcall	8000b548 <__hi0bits>
8000a98e:	f8 0c 11 20 	rsub	r12,r12,32
8000a992:	40 4b       	lddsp	r11,sp[0x10]
8000a994:	f8 0b 00 08 	add	r8,r12,r11
8000a998:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000a99c:	c0 c0       	breq	8000a9b4 <_dtoa_r+0x8bc>
8000a99e:	f0 08 11 20 	rsub	r8,r8,32
8000a9a2:	58 48       	cp.w	r8,4
8000a9a4:	e0 8a 00 06 	brle	8000a9b0 <_dtoa_r+0x8b8>
8000a9a8:	20 48       	sub	r8,4
8000a9aa:	10 0b       	add	r11,r8
8000a9ac:	50 4b       	stdsp	sp[0x10],r11
8000a9ae:	c0 78       	rjmp	8000a9bc <_dtoa_r+0x8c4>
8000a9b0:	58 48       	cp.w	r8,4
8000a9b2:	c0 70       	breq	8000a9c0 <_dtoa_r+0x8c8>
8000a9b4:	40 4a       	lddsp	r10,sp[0x10]
8000a9b6:	2e 48       	sub	r8,-28
8000a9b8:	10 0a       	add	r10,r8
8000a9ba:	50 4a       	stdsp	sp[0x10],r10
8000a9bc:	10 00       	add	r0,r8
8000a9be:	10 05       	add	r5,r8
8000a9c0:	58 00       	cp.w	r0,0
8000a9c2:	e0 8a 00 08 	brle	8000a9d2 <_dtoa_r+0x8da>
8000a9c6:	06 9b       	mov	r11,r3
8000a9c8:	00 9a       	mov	r10,r0
8000a9ca:	0e 9c       	mov	r12,r7
8000a9cc:	e0 a0 07 58 	rcall	8000b87c <__lshift>
8000a9d0:	18 93       	mov	r3,r12
8000a9d2:	40 49       	lddsp	r9,sp[0x10]
8000a9d4:	58 09       	cp.w	r9,0
8000a9d6:	e0 8a 00 08 	brle	8000a9e6 <_dtoa_r+0x8ee>
8000a9da:	04 9b       	mov	r11,r2
8000a9dc:	12 9a       	mov	r10,r9
8000a9de:	0e 9c       	mov	r12,r7
8000a9e0:	e0 a0 07 4e 	rcall	8000b87c <__lshift>
8000a9e4:	18 92       	mov	r2,r12
8000a9e6:	41 48       	lddsp	r8,sp[0x50]
8000a9e8:	58 08       	cp.w	r8,0
8000a9ea:	c1 b0       	breq	8000aa20 <_dtoa_r+0x928>
8000a9ec:	04 9b       	mov	r11,r2
8000a9ee:	06 9c       	mov	r12,r3
8000a9f0:	e0 a0 06 23 	rcall	8000b636 <__mcmp>
8000a9f4:	c1 64       	brge	8000aa20 <_dtoa_r+0x928>
8000a9f6:	06 9b       	mov	r11,r3
8000a9f8:	30 09       	mov	r9,0
8000a9fa:	30 aa       	mov	r10,10
8000a9fc:	0e 9c       	mov	r12,r7
8000a9fe:	e0 a0 08 0b 	rcall	8000ba14 <__multadd>
8000aa02:	20 16       	sub	r6,1
8000aa04:	18 93       	mov	r3,r12
8000aa06:	40 dc       	lddsp	r12,sp[0x34]
8000aa08:	58 0c       	cp.w	r12,0
8000aa0a:	c0 31       	brne	8000aa10 <_dtoa_r+0x918>
8000aa0c:	40 91       	lddsp	r1,sp[0x24]
8000aa0e:	c0 98       	rjmp	8000aa20 <_dtoa_r+0x928>
8000aa10:	08 9b       	mov	r11,r4
8000aa12:	40 91       	lddsp	r1,sp[0x24]
8000aa14:	30 09       	mov	r9,0
8000aa16:	30 aa       	mov	r10,10
8000aa18:	0e 9c       	mov	r12,r7
8000aa1a:	e0 a0 07 fd 	rcall	8000ba14 <__multadd>
8000aa1e:	18 94       	mov	r4,r12
8000aa20:	58 01       	cp.w	r1,0
8000aa22:	5f a9       	srle	r9
8000aa24:	40 cb       	lddsp	r11,sp[0x30]
8000aa26:	58 2b       	cp.w	r11,2
8000aa28:	5f 98       	srgt	r8
8000aa2a:	f3 e8 00 08 	and	r8,r9,r8
8000aa2e:	c2 50       	breq	8000aa78 <_dtoa_r+0x980>
8000aa30:	58 01       	cp.w	r1,0
8000aa32:	c1 11       	brne	8000aa54 <_dtoa_r+0x95c>
8000aa34:	04 9b       	mov	r11,r2
8000aa36:	02 99       	mov	r9,r1
8000aa38:	30 5a       	mov	r10,5
8000aa3a:	0e 9c       	mov	r12,r7
8000aa3c:	e0 a0 07 ec 	rcall	8000ba14 <__multadd>
8000aa40:	18 92       	mov	r2,r12
8000aa42:	18 9b       	mov	r11,r12
8000aa44:	06 9c       	mov	r12,r3
8000aa46:	e0 a0 05 f8 	rcall	8000b636 <__mcmp>
8000aa4a:	e0 89 00 0f 	brgt	8000aa68 <_dtoa_r+0x970>
8000aa4e:	c0 38       	rjmp	8000aa54 <_dtoa_r+0x95c>
8000aa50:	30 02       	mov	r2,0
8000aa52:	04 94       	mov	r4,r2
8000aa54:	40 ea       	lddsp	r10,sp[0x38]
8000aa56:	30 09       	mov	r9,0
8000aa58:	5c da       	com	r10
8000aa5a:	40 85       	lddsp	r5,sp[0x20]
8000aa5c:	50 6a       	stdsp	sp[0x18],r10
8000aa5e:	50 49       	stdsp	sp[0x10],r9
8000aa60:	c0 f9       	rjmp	8000ac7e <_dtoa_r+0xb86>
8000aa62:	08 92       	mov	r2,r4
8000aa64:	40 66       	lddsp	r6,sp[0x18]
8000aa66:	04 94       	mov	r4,r2
8000aa68:	2f f6       	sub	r6,-1
8000aa6a:	50 66       	stdsp	sp[0x18],r6
8000aa6c:	33 18       	mov	r8,49
8000aa6e:	40 85       	lddsp	r5,sp[0x20]
8000aa70:	0a c8       	st.b	r5++,r8
8000aa72:	30 08       	mov	r8,0
8000aa74:	50 48       	stdsp	sp[0x10],r8
8000aa76:	c0 49       	rjmp	8000ac7e <_dtoa_r+0xb86>
8000aa78:	40 dc       	lddsp	r12,sp[0x34]
8000aa7a:	58 0c       	cp.w	r12,0
8000aa7c:	e0 80 00 b5 	breq	8000abe6 <_dtoa_r+0xaee>
8000aa80:	58 05       	cp.w	r5,0
8000aa82:	e0 8a 00 08 	brle	8000aa92 <_dtoa_r+0x99a>
8000aa86:	08 9b       	mov	r11,r4
8000aa88:	0a 9a       	mov	r10,r5
8000aa8a:	0e 9c       	mov	r12,r7
8000aa8c:	e0 a0 06 f8 	rcall	8000b87c <__lshift>
8000aa90:	18 94       	mov	r4,r12
8000aa92:	40 6b       	lddsp	r11,sp[0x18]
8000aa94:	58 0b       	cp.w	r11,0
8000aa96:	c0 31       	brne	8000aa9c <_dtoa_r+0x9a4>
8000aa98:	08 9c       	mov	r12,r4
8000aa9a:	c1 38       	rjmp	8000aac0 <_dtoa_r+0x9c8>
8000aa9c:	68 1b       	ld.w	r11,r4[0x4]
8000aa9e:	0e 9c       	mov	r12,r7
8000aaa0:	e0 a0 05 fe 	rcall	8000b69c <_Balloc>
8000aaa4:	68 4a       	ld.w	r10,r4[0x10]
8000aaa6:	18 95       	mov	r5,r12
8000aaa8:	e8 cb ff f4 	sub	r11,r4,-12
8000aaac:	2f ea       	sub	r10,-2
8000aaae:	2f 4c       	sub	r12,-12
8000aab0:	a3 6a       	lsl	r10,0x2
8000aab2:	fe b0 e6 44 	rcall	8000773a <memcpy>
8000aab6:	0a 9b       	mov	r11,r5
8000aab8:	30 1a       	mov	r10,1
8000aaba:	0e 9c       	mov	r12,r7
8000aabc:	e0 a0 06 e0 	rcall	8000b87c <__lshift>
8000aac0:	50 44       	stdsp	sp[0x10],r4
8000aac2:	40 3a       	lddsp	r10,sp[0xc]
8000aac4:	30 19       	mov	r9,1
8000aac6:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
8000aaca:	18 94       	mov	r4,r12
8000aacc:	50 da       	stdsp	sp[0x34],r10
8000aace:	40 85       	lddsp	r5,sp[0x20]
8000aad0:	50 99       	stdsp	sp[0x24],r9
8000aad2:	50 26       	stdsp	sp[0x8],r6
8000aad4:	50 e1       	stdsp	sp[0x38],r1
8000aad6:	04 9b       	mov	r11,r2
8000aad8:	06 9c       	mov	r12,r3
8000aada:	fe b0 fa 7f 	rcall	80009fd8 <quorem>
8000aade:	40 4b       	lddsp	r11,sp[0x10]
8000aae0:	f8 c0 ff d0 	sub	r0,r12,-48
8000aae4:	06 9c       	mov	r12,r3
8000aae6:	e0 a0 05 a8 	rcall	8000b636 <__mcmp>
8000aaea:	08 9a       	mov	r10,r4
8000aaec:	50 6c       	stdsp	sp[0x18],r12
8000aaee:	04 9b       	mov	r11,r2
8000aaf0:	0e 9c       	mov	r12,r7
8000aaf2:	e0 a0 06 5d 	rcall	8000b7ac <__mdiff>
8000aaf6:	18 91       	mov	r1,r12
8000aaf8:	78 38       	ld.w	r8,r12[0xc]
8000aafa:	58 08       	cp.w	r8,0
8000aafc:	c0 30       	breq	8000ab02 <_dtoa_r+0xa0a>
8000aafe:	30 16       	mov	r6,1
8000ab00:	c0 68       	rjmp	8000ab0c <_dtoa_r+0xa14>
8000ab02:	18 9b       	mov	r11,r12
8000ab04:	06 9c       	mov	r12,r3
8000ab06:	e0 a0 05 98 	rcall	8000b636 <__mcmp>
8000ab0a:	18 96       	mov	r6,r12
8000ab0c:	0e 9c       	mov	r12,r7
8000ab0e:	02 9b       	mov	r11,r1
8000ab10:	e0 a0 05 ac 	rcall	8000b668 <_Bfree>
8000ab14:	40 cc       	lddsp	r12,sp[0x30]
8000ab16:	ed ec 10 08 	or	r8,r6,r12
8000ab1a:	c0 d1       	brne	8000ab34 <_dtoa_r+0xa3c>
8000ab1c:	40 db       	lddsp	r11,sp[0x34]
8000ab1e:	58 0b       	cp.w	r11,0
8000ab20:	c0 a1       	brne	8000ab34 <_dtoa_r+0xa3c>
8000ab22:	40 26       	lddsp	r6,sp[0x8]
8000ab24:	e0 40 00 39 	cp.w	r0,57
8000ab28:	c3 00       	breq	8000ab88 <_dtoa_r+0xa90>
8000ab2a:	40 6a       	lddsp	r10,sp[0x18]
8000ab2c:	58 0a       	cp.w	r10,0
8000ab2e:	e0 89 00 24 	brgt	8000ab76 <_dtoa_r+0xa7e>
8000ab32:	c2 f8       	rjmp	8000ab90 <_dtoa_r+0xa98>
8000ab34:	40 69       	lddsp	r9,sp[0x18]
8000ab36:	58 09       	cp.w	r9,0
8000ab38:	c0 85       	brlt	8000ab48 <_dtoa_r+0xa50>
8000ab3a:	12 98       	mov	r8,r9
8000ab3c:	40 cc       	lddsp	r12,sp[0x30]
8000ab3e:	18 48       	or	r8,r12
8000ab40:	c1 d1       	brne	8000ab7a <_dtoa_r+0xa82>
8000ab42:	40 db       	lddsp	r11,sp[0x34]
8000ab44:	58 0b       	cp.w	r11,0
8000ab46:	c1 a1       	brne	8000ab7a <_dtoa_r+0xa82>
8000ab48:	0c 99       	mov	r9,r6
8000ab4a:	40 26       	lddsp	r6,sp[0x8]
8000ab4c:	58 09       	cp.w	r9,0
8000ab4e:	e0 8a 00 21 	brle	8000ab90 <_dtoa_r+0xa98>
8000ab52:	06 9b       	mov	r11,r3
8000ab54:	30 1a       	mov	r10,1
8000ab56:	0e 9c       	mov	r12,r7
8000ab58:	e0 a0 06 92 	rcall	8000b87c <__lshift>
8000ab5c:	04 9b       	mov	r11,r2
8000ab5e:	18 93       	mov	r3,r12
8000ab60:	e0 a0 05 6b 	rcall	8000b636 <__mcmp>
8000ab64:	e0 89 00 06 	brgt	8000ab70 <_dtoa_r+0xa78>
8000ab68:	c1 41       	brne	8000ab90 <_dtoa_r+0xa98>
8000ab6a:	ed b0 00 00 	bld	r0,0x0
8000ab6e:	c1 11       	brne	8000ab90 <_dtoa_r+0xa98>
8000ab70:	e0 40 00 39 	cp.w	r0,57
8000ab74:	c0 a0       	breq	8000ab88 <_dtoa_r+0xa90>
8000ab76:	2f f0       	sub	r0,-1
8000ab78:	c0 c8       	rjmp	8000ab90 <_dtoa_r+0xa98>
8000ab7a:	58 06       	cp.w	r6,0
8000ab7c:	e0 8a 00 0c 	brle	8000ab94 <_dtoa_r+0xa9c>
8000ab80:	40 26       	lddsp	r6,sp[0x8]
8000ab82:	e0 40 00 39 	cp.w	r0,57
8000ab86:	c0 41       	brne	8000ab8e <_dtoa_r+0xa96>
8000ab88:	33 98       	mov	r8,57
8000ab8a:	0a c8       	st.b	r5++,r8
8000ab8c:	c6 78       	rjmp	8000ac5a <_dtoa_r+0xb62>
8000ab8e:	2f f0       	sub	r0,-1
8000ab90:	0a c0       	st.b	r5++,r0
8000ab92:	c7 58       	rjmp	8000ac7c <_dtoa_r+0xb84>
8000ab94:	0a c0       	st.b	r5++,r0
8000ab96:	40 9a       	lddsp	r10,sp[0x24]
8000ab98:	40 e9       	lddsp	r9,sp[0x38]
8000ab9a:	12 3a       	cp.w	r10,r9
8000ab9c:	c4 30       	breq	8000ac22 <_dtoa_r+0xb2a>
8000ab9e:	06 9b       	mov	r11,r3
8000aba0:	30 09       	mov	r9,0
8000aba2:	30 aa       	mov	r10,10
8000aba4:	0e 9c       	mov	r12,r7
8000aba6:	e0 a0 07 37 	rcall	8000ba14 <__multadd>
8000abaa:	40 48       	lddsp	r8,sp[0x10]
8000abac:	18 93       	mov	r3,r12
8000abae:	08 38       	cp.w	r8,r4
8000abb0:	c0 91       	brne	8000abc2 <_dtoa_r+0xaca>
8000abb2:	10 9b       	mov	r11,r8
8000abb4:	30 09       	mov	r9,0
8000abb6:	30 aa       	mov	r10,10
8000abb8:	0e 9c       	mov	r12,r7
8000abba:	e0 a0 07 2d 	rcall	8000ba14 <__multadd>
8000abbe:	50 4c       	stdsp	sp[0x10],r12
8000abc0:	c0 e8       	rjmp	8000abdc <_dtoa_r+0xae4>
8000abc2:	40 4b       	lddsp	r11,sp[0x10]
8000abc4:	30 09       	mov	r9,0
8000abc6:	30 aa       	mov	r10,10
8000abc8:	0e 9c       	mov	r12,r7
8000abca:	e0 a0 07 25 	rcall	8000ba14 <__multadd>
8000abce:	08 9b       	mov	r11,r4
8000abd0:	50 4c       	stdsp	sp[0x10],r12
8000abd2:	30 09       	mov	r9,0
8000abd4:	30 aa       	mov	r10,10
8000abd6:	0e 9c       	mov	r12,r7
8000abd8:	e0 a0 07 1e 	rcall	8000ba14 <__multadd>
8000abdc:	18 94       	mov	r4,r12
8000abde:	40 9c       	lddsp	r12,sp[0x24]
8000abe0:	2f fc       	sub	r12,-1
8000abe2:	50 9c       	stdsp	sp[0x24],r12
8000abe4:	c7 9b       	rjmp	8000aad6 <_dtoa_r+0x9de>
8000abe6:	30 18       	mov	r8,1
8000abe8:	06 90       	mov	r0,r3
8000abea:	40 85       	lddsp	r5,sp[0x20]
8000abec:	08 93       	mov	r3,r4
8000abee:	0c 94       	mov	r4,r6
8000abf0:	10 96       	mov	r6,r8
8000abf2:	04 9b       	mov	r11,r2
8000abf4:	00 9c       	mov	r12,r0
8000abf6:	fe b0 f9 f1 	rcall	80009fd8 <quorem>
8000abfa:	2d 0c       	sub	r12,-48
8000abfc:	0a cc       	st.b	r5++,r12
8000abfe:	02 36       	cp.w	r6,r1
8000ac00:	c0 a4       	brge	8000ac14 <_dtoa_r+0xb1c>
8000ac02:	00 9b       	mov	r11,r0
8000ac04:	30 09       	mov	r9,0
8000ac06:	30 aa       	mov	r10,10
8000ac08:	0e 9c       	mov	r12,r7
8000ac0a:	2f f6       	sub	r6,-1
8000ac0c:	e0 a0 07 04 	rcall	8000ba14 <__multadd>
8000ac10:	18 90       	mov	r0,r12
8000ac12:	cf 0b       	rjmp	8000abf2 <_dtoa_r+0xafa>
8000ac14:	08 96       	mov	r6,r4
8000ac16:	30 0b       	mov	r11,0
8000ac18:	06 94       	mov	r4,r3
8000ac1a:	50 4b       	stdsp	sp[0x10],r11
8000ac1c:	00 93       	mov	r3,r0
8000ac1e:	18 90       	mov	r0,r12
8000ac20:	c0 28       	rjmp	8000ac24 <_dtoa_r+0xb2c>
8000ac22:	40 26       	lddsp	r6,sp[0x8]
8000ac24:	06 9b       	mov	r11,r3
8000ac26:	30 1a       	mov	r10,1
8000ac28:	0e 9c       	mov	r12,r7
8000ac2a:	e0 a0 06 29 	rcall	8000b87c <__lshift>
8000ac2e:	04 9b       	mov	r11,r2
8000ac30:	18 93       	mov	r3,r12
8000ac32:	e0 a0 05 02 	rcall	8000b636 <__mcmp>
8000ac36:	e0 89 00 12 	brgt	8000ac5a <_dtoa_r+0xb62>
8000ac3a:	c1 b1       	brne	8000ac70 <_dtoa_r+0xb78>
8000ac3c:	e1 d0 c0 01 	bfextu	r0,r0,0x0,0x1
8000ac40:	c0 d1       	brne	8000ac5a <_dtoa_r+0xb62>
8000ac42:	c1 78       	rjmp	8000ac70 <_dtoa_r+0xb78>
8000ac44:	40 89       	lddsp	r9,sp[0x20]
8000ac46:	12 38       	cp.w	r8,r9
8000ac48:	c0 30       	breq	8000ac4e <_dtoa_r+0xb56>
8000ac4a:	10 95       	mov	r5,r8
8000ac4c:	c0 88       	rjmp	8000ac5c <_dtoa_r+0xb64>
8000ac4e:	2f f6       	sub	r6,-1
8000ac50:	50 66       	stdsp	sp[0x18],r6
8000ac52:	33 18       	mov	r8,49
8000ac54:	40 8c       	lddsp	r12,sp[0x20]
8000ac56:	b8 88       	st.b	r12[0x0],r8
8000ac58:	c1 38       	rjmp	8000ac7e <_dtoa_r+0xb86>
8000ac5a:	33 9a       	mov	r10,57
8000ac5c:	0a 98       	mov	r8,r5
8000ac5e:	11 79       	ld.ub	r9,--r8
8000ac60:	f4 09 18 00 	cp.b	r9,r10
8000ac64:	cf 00       	breq	8000ac44 <_dtoa_r+0xb4c>
8000ac66:	2f f9       	sub	r9,-1
8000ac68:	b0 89       	st.b	r8[0x0],r9
8000ac6a:	c0 98       	rjmp	8000ac7c <_dtoa_r+0xb84>
8000ac6c:	10 95       	mov	r5,r8
8000ac6e:	c0 28       	rjmp	8000ac72 <_dtoa_r+0xb7a>
8000ac70:	33 09       	mov	r9,48
8000ac72:	0a 98       	mov	r8,r5
8000ac74:	11 7a       	ld.ub	r10,--r8
8000ac76:	f2 0a 18 00 	cp.b	r10,r9
8000ac7a:	cf 90       	breq	8000ac6c <_dtoa_r+0xb74>
8000ac7c:	50 66       	stdsp	sp[0x18],r6
8000ac7e:	04 9b       	mov	r11,r2
8000ac80:	0e 9c       	mov	r12,r7
8000ac82:	e0 a0 04 f3 	rcall	8000b668 <_Bfree>
8000ac86:	58 04       	cp.w	r4,0
8000ac88:	c1 20       	breq	8000acac <_dtoa_r+0xbb4>
8000ac8a:	40 4b       	lddsp	r11,sp[0x10]
8000ac8c:	08 3b       	cp.w	r11,r4
8000ac8e:	5f 19       	srne	r9
8000ac90:	58 0b       	cp.w	r11,0
8000ac92:	5f 18       	srne	r8
8000ac94:	f3 e8 00 08 	and	r8,r9,r8
8000ac98:	c0 40       	breq	8000aca0 <_dtoa_r+0xba8>
8000ac9a:	0e 9c       	mov	r12,r7
8000ac9c:	e0 a0 04 e6 	rcall	8000b668 <_Bfree>
8000aca0:	08 9b       	mov	r11,r4
8000aca2:	0e 9c       	mov	r12,r7
8000aca4:	e0 a0 04 e2 	rcall	8000b668 <_Bfree>
8000aca8:	c0 28       	rjmp	8000acac <_dtoa_r+0xbb4>
8000acaa:	50 66       	stdsp	sp[0x18],r6
8000acac:	0e 9c       	mov	r12,r7
8000acae:	06 9b       	mov	r11,r3
8000acb0:	e0 a0 04 dc 	rcall	8000b668 <_Bfree>
8000acb4:	30 08       	mov	r8,0
8000acb6:	aa 88       	st.b	r5[0x0],r8
8000acb8:	40 68       	lddsp	r8,sp[0x18]
8000acba:	41 5a       	lddsp	r10,sp[0x54]
8000acbc:	2f f8       	sub	r8,-1
8000acbe:	41 29       	lddsp	r9,sp[0x48]
8000acc0:	95 08       	st.w	r10[0x0],r8
8000acc2:	40 8c       	lddsp	r12,sp[0x20]
8000acc4:	58 09       	cp.w	r9,0
8000acc6:	fb f8 10 12 	ld.wne	r8,sp[0x48]
8000acca:	f1 f5 1a 00 	st.wne	r8[0x0],r5
8000acce:	2e 6d       	sub	sp,-104
8000acd0:	d8 32       	popm	r0-r7,pc
8000acd2:	d7 03       	nop

8000acd4 <__errno>:
8000acd4:	e0 68 0a 3c 	mov	r8,2620
8000acd8:	70 0c       	ld.w	r12,r8[0x0]
8000acda:	2f 4c       	sub	r12,-12
8000acdc:	5e fc       	retal	r12
8000acde:	d7 03       	nop

8000ace0 <_fflush_r>:
8000ace0:	d4 21       	pushm	r4-r7,lr
8000ace2:	16 97       	mov	r7,r11
8000ace4:	18 96       	mov	r6,r12
8000ace6:	76 48       	ld.w	r8,r11[0x10]
8000ace8:	58 08       	cp.w	r8,0
8000acea:	c7 f0       	breq	8000ade8 <_fflush_r+0x108>
8000acec:	58 0c       	cp.w	r12,0
8000acee:	c0 50       	breq	8000acf8 <_fflush_r+0x18>
8000acf0:	78 68       	ld.w	r8,r12[0x18]
8000acf2:	58 08       	cp.w	r8,0
8000acf4:	c0 21       	brne	8000acf8 <_fflush_r+0x18>
8000acf6:	cc dc       	rcall	8000ae90 <__sinit>
8000acf8:	fe c8 c8 e8 	sub	r8,pc,-14104
8000acfc:	10 37       	cp.w	r7,r8
8000acfe:	c0 31       	brne	8000ad04 <_fflush_r+0x24>
8000ad00:	6c 07       	ld.w	r7,r6[0x0]
8000ad02:	c0 c8       	rjmp	8000ad1a <_fflush_r+0x3a>
8000ad04:	fe c8 c8 d4 	sub	r8,pc,-14124
8000ad08:	10 37       	cp.w	r7,r8
8000ad0a:	c0 31       	brne	8000ad10 <_fflush_r+0x30>
8000ad0c:	6c 17       	ld.w	r7,r6[0x4]
8000ad0e:	c0 68       	rjmp	8000ad1a <_fflush_r+0x3a>
8000ad10:	fe c8 c8 c0 	sub	r8,pc,-14144
8000ad14:	10 37       	cp.w	r7,r8
8000ad16:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000ad1a:	8e 6a       	ld.sh	r10,r7[0xc]
8000ad1c:	14 98       	mov	r8,r10
8000ad1e:	ed ba 00 03 	bld	r10,0x3
8000ad22:	c4 20       	breq	8000ada6 <_fflush_r+0xc6>
8000ad24:	ab ba       	sbr	r10,0xb
8000ad26:	ae 6a       	st.h	r7[0xc],r10
8000ad28:	6e 18       	ld.w	r8,r7[0x4]
8000ad2a:	58 08       	cp.w	r8,0
8000ad2c:	e0 89 00 06 	brgt	8000ad38 <_fflush_r+0x58>
8000ad30:	6f 08       	ld.w	r8,r7[0x40]
8000ad32:	58 08       	cp.w	r8,0
8000ad34:	e0 8a 00 5a 	brle	8000ade8 <_fflush_r+0x108>
8000ad38:	6e b8       	ld.w	r8,r7[0x2c]
8000ad3a:	58 08       	cp.w	r8,0
8000ad3c:	c5 60       	breq	8000ade8 <_fflush_r+0x108>
8000ad3e:	e2 1a 10 00 	andl	r10,0x1000,COH
8000ad42:	c0 30       	breq	8000ad48 <_fflush_r+0x68>
8000ad44:	6f 55       	ld.w	r5,r7[0x54]
8000ad46:	c0 f8       	rjmp	8000ad64 <_fflush_r+0x84>
8000ad48:	30 19       	mov	r9,1
8000ad4a:	6e 8b       	ld.w	r11,r7[0x20]
8000ad4c:	0c 9c       	mov	r12,r6
8000ad4e:	5d 18       	icall	r8
8000ad50:	18 95       	mov	r5,r12
8000ad52:	5b fc       	cp.w	r12,-1
8000ad54:	c0 81       	brne	8000ad64 <_fflush_r+0x84>
8000ad56:	6c 38       	ld.w	r8,r6[0xc]
8000ad58:	59 d8       	cp.w	r8,29
8000ad5a:	c4 70       	breq	8000ade8 <_fflush_r+0x108>
8000ad5c:	8e 68       	ld.sh	r8,r7[0xc]
8000ad5e:	a7 a8       	sbr	r8,0x6
8000ad60:	ae 68       	st.h	r7[0xc],r8
8000ad62:	d8 22       	popm	r4-r7,pc
8000ad64:	8e 68       	ld.sh	r8,r7[0xc]
8000ad66:	ed b8 00 02 	bld	r8,0x2
8000ad6a:	c0 91       	brne	8000ad7c <_fflush_r+0x9c>
8000ad6c:	6e 18       	ld.w	r8,r7[0x4]
8000ad6e:	10 15       	sub	r5,r8
8000ad70:	6e d8       	ld.w	r8,r7[0x34]
8000ad72:	58 08       	cp.w	r8,0
8000ad74:	ef f8 10 10 	ld.wne	r8,r7[0x40]
8000ad78:	eb d8 e1 15 	subne	r5,r5,r8
8000ad7c:	6e b8       	ld.w	r8,r7[0x2c]
8000ad7e:	0c 9c       	mov	r12,r6
8000ad80:	30 09       	mov	r9,0
8000ad82:	0a 9a       	mov	r10,r5
8000ad84:	6e 8b       	ld.w	r11,r7[0x20]
8000ad86:	5d 18       	icall	r8
8000ad88:	8e 68       	ld.sh	r8,r7[0xc]
8000ad8a:	0a 3c       	cp.w	r12,r5
8000ad8c:	c2 61       	brne	8000add8 <_fflush_r+0xf8>
8000ad8e:	ab d8       	cbr	r8,0xb
8000ad90:	30 0c       	mov	r12,0
8000ad92:	6e 49       	ld.w	r9,r7[0x10]
8000ad94:	ae 68       	st.h	r7[0xc],r8
8000ad96:	8f 1c       	st.w	r7[0x4],r12
8000ad98:	8f 09       	st.w	r7[0x0],r9
8000ad9a:	ed b8 00 0c 	bld	r8,0xc
8000ad9e:	c2 51       	brne	8000ade8 <_fflush_r+0x108>
8000ada0:	ef 45 00 54 	st.w	r7[84],r5
8000ada4:	d8 22       	popm	r4-r7,pc
8000ada6:	6e 45       	ld.w	r5,r7[0x10]
8000ada8:	58 05       	cp.w	r5,0
8000adaa:	c1 f0       	breq	8000ade8 <_fflush_r+0x108>
8000adac:	6e 04       	ld.w	r4,r7[0x0]
8000adae:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
8000adb2:	8f 05       	st.w	r7[0x0],r5
8000adb4:	f9 b8 01 00 	movne	r8,0
8000adb8:	ef f8 00 05 	ld.weq	r8,r7[0x14]
8000adbc:	0a 14       	sub	r4,r5
8000adbe:	8f 28       	st.w	r7[0x8],r8
8000adc0:	c1 18       	rjmp	8000ade2 <_fflush_r+0x102>
8000adc2:	08 99       	mov	r9,r4
8000adc4:	0a 9a       	mov	r10,r5
8000adc6:	6e a8       	ld.w	r8,r7[0x28]
8000adc8:	6e 8b       	ld.w	r11,r7[0x20]
8000adca:	0c 9c       	mov	r12,r6
8000adcc:	5d 18       	icall	r8
8000adce:	18 14       	sub	r4,r12
8000add0:	58 0c       	cp.w	r12,0
8000add2:	e0 89 00 07 	brgt	8000ade0 <_fflush_r+0x100>
8000add6:	8e 68       	ld.sh	r8,r7[0xc]
8000add8:	a7 a8       	sbr	r8,0x6
8000adda:	3f fc       	mov	r12,-1
8000addc:	ae 68       	st.h	r7[0xc],r8
8000adde:	d8 22       	popm	r4-r7,pc
8000ade0:	18 05       	add	r5,r12
8000ade2:	58 04       	cp.w	r4,0
8000ade4:	fe 99 ff ef 	brgt	8000adc2 <_fflush_r+0xe2>
8000ade8:	d8 2a       	popm	r4-r7,pc,r12=0
8000adea:	d7 03       	nop

8000adec <__sfp_lock_acquire>:
8000adec:	5e fc       	retal	r12

8000adee <__sfp_lock_release>:
8000adee:	5e fc       	retal	r12

8000adf0 <_cleanup_r>:
8000adf0:	d4 01       	pushm	lr
8000adf2:	fe cb f0 c6 	sub	r11,pc,-3898
8000adf6:	e0 a0 02 f7 	rcall	8000b3e4 <_fwalk>
8000adfa:	d8 02       	popm	pc

8000adfc <__sfmoreglue>:
8000adfc:	d4 21       	pushm	r4-r7,lr
8000adfe:	16 95       	mov	r5,r11
8000ae00:	f6 06 10 5c 	mul	r6,r11,92
8000ae04:	ec cb ff f4 	sub	r11,r6,-12
8000ae08:	fe b0 e2 6a 	rcall	800072dc <_malloc_r>
8000ae0c:	18 97       	mov	r7,r12
8000ae0e:	c0 90       	breq	8000ae20 <__sfmoreglue+0x24>
8000ae10:	99 15       	st.w	r12[0x4],r5
8000ae12:	30 0b       	mov	r11,0
8000ae14:	2f 4c       	sub	r12,-12
8000ae16:	0c 9a       	mov	r10,r6
8000ae18:	8f 2c       	st.w	r7[0x8],r12
8000ae1a:	8f 0b       	st.w	r7[0x0],r11
8000ae1c:	fe b0 e5 33 	rcall	80007882 <memset>
8000ae20:	0e 9c       	mov	r12,r7
8000ae22:	d8 22       	popm	r4-r7,pc

8000ae24 <__sfp>:
8000ae24:	d4 21       	pushm	r4-r7,lr
8000ae26:	fe c8 c9 b2 	sub	r8,pc,-13902
8000ae2a:	18 96       	mov	r6,r12
8000ae2c:	70 07       	ld.w	r7,r8[0x0]
8000ae2e:	6e 68       	ld.w	r8,r7[0x18]
8000ae30:	58 08       	cp.w	r8,0
8000ae32:	c0 31       	brne	8000ae38 <__sfp+0x14>
8000ae34:	0e 9c       	mov	r12,r7
8000ae36:	c2 dc       	rcall	8000ae90 <__sinit>
8000ae38:	ee c7 ff 28 	sub	r7,r7,-216
8000ae3c:	30 05       	mov	r5,0
8000ae3e:	6e 2c       	ld.w	r12,r7[0x8]
8000ae40:	6e 18       	ld.w	r8,r7[0x4]
8000ae42:	c0 68       	rjmp	8000ae4e <__sfp+0x2a>
8000ae44:	98 69       	ld.sh	r9,r12[0xc]
8000ae46:	ea 09 19 00 	cp.h	r9,r5
8000ae4a:	c1 10       	breq	8000ae6c <__sfp+0x48>
8000ae4c:	2a 4c       	sub	r12,-92
8000ae4e:	20 18       	sub	r8,1
8000ae50:	cf a7       	brpl	8000ae44 <__sfp+0x20>
8000ae52:	6e 08       	ld.w	r8,r7[0x0]
8000ae54:	58 08       	cp.w	r8,0
8000ae56:	c0 61       	brne	8000ae62 <__sfp+0x3e>
8000ae58:	30 4b       	mov	r11,4
8000ae5a:	0c 9c       	mov	r12,r6
8000ae5c:	cd 0f       	rcall	8000adfc <__sfmoreglue>
8000ae5e:	8f 0c       	st.w	r7[0x0],r12
8000ae60:	c0 30       	breq	8000ae66 <__sfp+0x42>
8000ae62:	6e 07       	ld.w	r7,r7[0x0]
8000ae64:	ce db       	rjmp	8000ae3e <__sfp+0x1a>
8000ae66:	30 c8       	mov	r8,12
8000ae68:	8d 38       	st.w	r6[0xc],r8
8000ae6a:	d8 22       	popm	r4-r7,pc
8000ae6c:	30 08       	mov	r8,0
8000ae6e:	f9 48 00 4c 	st.w	r12[76],r8
8000ae72:	99 08       	st.w	r12[0x0],r8
8000ae74:	99 28       	st.w	r12[0x8],r8
8000ae76:	99 18       	st.w	r12[0x4],r8
8000ae78:	99 48       	st.w	r12[0x10],r8
8000ae7a:	99 58       	st.w	r12[0x14],r8
8000ae7c:	99 68       	st.w	r12[0x18],r8
8000ae7e:	99 d8       	st.w	r12[0x34],r8
8000ae80:	99 e8       	st.w	r12[0x38],r8
8000ae82:	f9 48 00 48 	st.w	r12[72],r8
8000ae86:	3f f8       	mov	r8,-1
8000ae88:	b8 78       	st.h	r12[0xe],r8
8000ae8a:	30 18       	mov	r8,1
8000ae8c:	b8 68       	st.h	r12[0xc],r8
8000ae8e:	d8 22       	popm	r4-r7,pc

8000ae90 <__sinit>:
8000ae90:	d4 21       	pushm	r4-r7,lr
8000ae92:	18 96       	mov	r6,r12
8000ae94:	78 67       	ld.w	r7,r12[0x18]
8000ae96:	58 07       	cp.w	r7,0
8000ae98:	c4 91       	brne	8000af2a <__sinit+0x9a>
8000ae9a:	fe c8 00 aa 	sub	r8,pc,170
8000ae9e:	30 15       	mov	r5,1
8000aea0:	99 a8       	st.w	r12[0x28],r8
8000aea2:	f9 47 00 d8 	st.w	r12[216],r7
8000aea6:	f9 47 00 dc 	st.w	r12[220],r7
8000aeaa:	f9 47 00 e0 	st.w	r12[224],r7
8000aeae:	99 65       	st.w	r12[0x18],r5
8000aeb0:	cb af       	rcall	8000ae24 <__sfp>
8000aeb2:	8d 0c       	st.w	r6[0x0],r12
8000aeb4:	0c 9c       	mov	r12,r6
8000aeb6:	cb 7f       	rcall	8000ae24 <__sfp>
8000aeb8:	8d 1c       	st.w	r6[0x4],r12
8000aeba:	0c 9c       	mov	r12,r6
8000aebc:	cb 4f       	rcall	8000ae24 <__sfp>
8000aebe:	6c 09       	ld.w	r9,r6[0x0]
8000aec0:	30 48       	mov	r8,4
8000aec2:	93 07       	st.w	r9[0x0],r7
8000aec4:	b2 68       	st.h	r9[0xc],r8
8000aec6:	93 17       	st.w	r9[0x4],r7
8000aec8:	93 27       	st.w	r9[0x8],r7
8000aeca:	6c 18       	ld.w	r8,r6[0x4]
8000aecc:	b2 77       	st.h	r9[0xe],r7
8000aece:	93 47       	st.w	r9[0x10],r7
8000aed0:	93 57       	st.w	r9[0x14],r7
8000aed2:	93 67       	st.w	r9[0x18],r7
8000aed4:	93 89       	st.w	r9[0x20],r9
8000aed6:	91 07       	st.w	r8[0x0],r7
8000aed8:	91 17       	st.w	r8[0x4],r7
8000aeda:	91 27       	st.w	r8[0x8],r7
8000aedc:	fe ce f3 24 	sub	lr,pc,-3292
8000aee0:	fe cb f3 54 	sub	r11,pc,-3244
8000aee4:	93 9e       	st.w	r9[0x24],lr
8000aee6:	93 ab       	st.w	r9[0x28],r11
8000aee8:	fe ca f3 7c 	sub	r10,pc,-3204
8000aeec:	fe c4 f3 88 	sub	r4,pc,-3192
8000aef0:	93 ba       	st.w	r9[0x2c],r10
8000aef2:	93 c4       	st.w	r9[0x30],r4
8000aef4:	30 99       	mov	r9,9
8000aef6:	b0 69       	st.h	r8[0xc],r9
8000aef8:	b0 75       	st.h	r8[0xe],r5
8000aefa:	91 c4       	st.w	r8[0x30],r4
8000aefc:	91 47       	st.w	r8[0x10],r7
8000aefe:	91 57       	st.w	r8[0x14],r7
8000af00:	91 67       	st.w	r8[0x18],r7
8000af02:	91 88       	st.w	r8[0x20],r8
8000af04:	91 9e       	st.w	r8[0x24],lr
8000af06:	91 ab       	st.w	r8[0x28],r11
8000af08:	91 ba       	st.w	r8[0x2c],r10
8000af0a:	8d 2c       	st.w	r6[0x8],r12
8000af0c:	31 28       	mov	r8,18
8000af0e:	99 07       	st.w	r12[0x0],r7
8000af10:	b8 68       	st.h	r12[0xc],r8
8000af12:	99 17       	st.w	r12[0x4],r7
8000af14:	99 27       	st.w	r12[0x8],r7
8000af16:	30 28       	mov	r8,2
8000af18:	b8 78       	st.h	r12[0xe],r8
8000af1a:	99 c4       	st.w	r12[0x30],r4
8000af1c:	99 67       	st.w	r12[0x18],r7
8000af1e:	99 9e       	st.w	r12[0x24],lr
8000af20:	99 ab       	st.w	r12[0x28],r11
8000af22:	99 ba       	st.w	r12[0x2c],r10
8000af24:	99 47       	st.w	r12[0x10],r7
8000af26:	99 57       	st.w	r12[0x14],r7
8000af28:	99 8c       	st.w	r12[0x20],r12
8000af2a:	d8 22       	popm	r4-r7,pc

8000af2c <_malloc_trim_r>:
8000af2c:	d4 21       	pushm	r4-r7,lr
8000af2e:	16 95       	mov	r5,r11
8000af30:	18 97       	mov	r7,r12
8000af32:	fe b0 d7 53 	rcall	80005dd8 <__malloc_lock>
8000af36:	e0 64 05 3c 	mov	r4,1340
8000af3a:	68 28       	ld.w	r8,r4[0x8]
8000af3c:	70 16       	ld.w	r6,r8[0x4]
8000af3e:	e0 16 ff fc 	andl	r6,0xfffc
8000af42:	ec c8 ff 91 	sub	r8,r6,-111
8000af46:	f0 05 01 05 	sub	r5,r8,r5
8000af4a:	e0 15 ff 80 	andl	r5,0xff80
8000af4e:	ea c5 00 80 	sub	r5,r5,128
8000af52:	e0 45 00 7f 	cp.w	r5,127
8000af56:	e0 8a 00 25 	brle	8000afa0 <_malloc_trim_r+0x74>
8000af5a:	30 0b       	mov	r11,0
8000af5c:	0e 9c       	mov	r12,r7
8000af5e:	fe b0 e5 f9 	rcall	80007b50 <_sbrk_r>
8000af62:	68 28       	ld.w	r8,r4[0x8]
8000af64:	0c 08       	add	r8,r6
8000af66:	10 3c       	cp.w	r12,r8
8000af68:	c1 c1       	brne	8000afa0 <_malloc_trim_r+0x74>
8000af6a:	ea 0b 11 00 	rsub	r11,r5,0
8000af6e:	0e 9c       	mov	r12,r7
8000af70:	fe b0 e5 f0 	rcall	80007b50 <_sbrk_r>
8000af74:	5b fc       	cp.w	r12,-1
8000af76:	c1 91       	brne	8000afa8 <_malloc_trim_r+0x7c>
8000af78:	30 0b       	mov	r11,0
8000af7a:	0e 9c       	mov	r12,r7
8000af7c:	fe b0 e5 ea 	rcall	80007b50 <_sbrk_r>
8000af80:	68 28       	ld.w	r8,r4[0x8]
8000af82:	f8 08 01 09 	sub	r9,r12,r8
8000af86:	58 f9       	cp.w	r9,15
8000af88:	e0 8a 00 0c 	brle	8000afa0 <_malloc_trim_r+0x74>
8000af8c:	a1 a9       	sbr	r9,0x0
8000af8e:	91 19       	st.w	r8[0x4],r9
8000af90:	e0 68 09 48 	mov	r8,2376
8000af94:	70 09       	ld.w	r9,r8[0x0]
8000af96:	e0 68 0d 5c 	mov	r8,3420
8000af9a:	f8 09 01 09 	sub	r9,r12,r9
8000af9e:	91 09       	st.w	r8[0x0],r9
8000afa0:	0e 9c       	mov	r12,r7
8000afa2:	fe b0 d7 21 	rcall	80005de4 <__malloc_unlock>
8000afa6:	d8 2a       	popm	r4-r7,pc,r12=0
8000afa8:	68 28       	ld.w	r8,r4[0x8]
8000afaa:	0a 16       	sub	r6,r5
8000afac:	a1 a6       	sbr	r6,0x0
8000afae:	91 16       	st.w	r8[0x4],r6
8000afb0:	e0 68 0d 5c 	mov	r8,3420
8000afb4:	70 09       	ld.w	r9,r8[0x0]
8000afb6:	0a 19       	sub	r9,r5
8000afb8:	0e 9c       	mov	r12,r7
8000afba:	91 09       	st.w	r8[0x0],r9
8000afbc:	fe b0 d7 14 	rcall	80005de4 <__malloc_unlock>
8000afc0:	da 2a       	popm	r4-r7,pc,r12=1
8000afc2:	d7 03       	nop

8000afc4 <_free_r>:
8000afc4:	d4 21       	pushm	r4-r7,lr
8000afc6:	16 96       	mov	r6,r11
8000afc8:	18 97       	mov	r7,r12
8000afca:	58 0b       	cp.w	r11,0
8000afcc:	e0 80 00 c0 	breq	8000b14c <_free_r+0x188>
8000afd0:	fe b0 d7 04 	rcall	80005dd8 <__malloc_lock>
8000afd4:	20 86       	sub	r6,8
8000afd6:	e0 6a 05 3c 	mov	r10,1340
8000afda:	6c 18       	ld.w	r8,r6[0x4]
8000afdc:	74 2e       	ld.w	lr,r10[0x8]
8000afde:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
8000afe2:	a1 c8       	cbr	r8,0x0
8000afe4:	ec 08 00 09 	add	r9,r6,r8
8000afe8:	72 1b       	ld.w	r11,r9[0x4]
8000afea:	e0 1b ff fc 	andl	r11,0xfffc
8000afee:	1c 39       	cp.w	r9,lr
8000aff0:	c1 e1       	brne	8000b02c <_free_r+0x68>
8000aff2:	f6 08 00 08 	add	r8,r11,r8
8000aff6:	58 0c       	cp.w	r12,0
8000aff8:	c0 81       	brne	8000b008 <_free_r+0x44>
8000affa:	6c 09       	ld.w	r9,r6[0x0]
8000affc:	12 16       	sub	r6,r9
8000affe:	12 08       	add	r8,r9
8000b000:	6c 3b       	ld.w	r11,r6[0xc]
8000b002:	6c 29       	ld.w	r9,r6[0x8]
8000b004:	97 29       	st.w	r11[0x8],r9
8000b006:	93 3b       	st.w	r9[0xc],r11
8000b008:	10 99       	mov	r9,r8
8000b00a:	95 26       	st.w	r10[0x8],r6
8000b00c:	a1 a9       	sbr	r9,0x0
8000b00e:	8d 19       	st.w	r6[0x4],r9
8000b010:	e0 69 09 44 	mov	r9,2372
8000b014:	72 09       	ld.w	r9,r9[0x0]
8000b016:	12 38       	cp.w	r8,r9
8000b018:	c0 63       	brcs	8000b024 <_free_r+0x60>
8000b01a:	e0 68 0d 58 	mov	r8,3416
8000b01e:	0e 9c       	mov	r12,r7
8000b020:	70 0b       	ld.w	r11,r8[0x0]
8000b022:	c8 5f       	rcall	8000af2c <_malloc_trim_r>
8000b024:	0e 9c       	mov	r12,r7
8000b026:	fe b0 d6 df 	rcall	80005de4 <__malloc_unlock>
8000b02a:	d8 22       	popm	r4-r7,pc
8000b02c:	93 1b       	st.w	r9[0x4],r11
8000b02e:	58 0c       	cp.w	r12,0
8000b030:	c0 30       	breq	8000b036 <_free_r+0x72>
8000b032:	30 0c       	mov	r12,0
8000b034:	c1 08       	rjmp	8000b054 <_free_r+0x90>
8000b036:	6c 0e       	ld.w	lr,r6[0x0]
8000b038:	f4 c5 ff f8 	sub	r5,r10,-8
8000b03c:	1c 16       	sub	r6,lr
8000b03e:	1c 08       	add	r8,lr
8000b040:	6c 2e       	ld.w	lr,r6[0x8]
8000b042:	0a 3e       	cp.w	lr,r5
8000b044:	f9 bc 00 01 	moveq	r12,1
8000b048:	ed f5 10 03 	ld.wne	r5,r6[0xc]
8000b04c:	eb fe 1a 02 	st.wne	r5[0x8],lr
8000b050:	fd f5 1a 03 	st.wne	lr[0xc],r5
8000b054:	f2 0b 00 0e 	add	lr,r9,r11
8000b058:	7c 1e       	ld.w	lr,lr[0x4]
8000b05a:	ed be 00 00 	bld	lr,0x0
8000b05e:	c1 40       	breq	8000b086 <_free_r+0xc2>
8000b060:	16 08       	add	r8,r11
8000b062:	58 0c       	cp.w	r12,0
8000b064:	c0 d1       	brne	8000b07e <_free_r+0xba>
8000b066:	e0 6e 05 3c 	mov	lr,1340
8000b06a:	72 2b       	ld.w	r11,r9[0x8]
8000b06c:	2f 8e       	sub	lr,-8
8000b06e:	1c 3b       	cp.w	r11,lr
8000b070:	c0 71       	brne	8000b07e <_free_r+0xba>
8000b072:	97 36       	st.w	r11[0xc],r6
8000b074:	97 26       	st.w	r11[0x8],r6
8000b076:	8d 2b       	st.w	r6[0x8],r11
8000b078:	8d 3b       	st.w	r6[0xc],r11
8000b07a:	30 1c       	mov	r12,1
8000b07c:	c0 58       	rjmp	8000b086 <_free_r+0xc2>
8000b07e:	72 2b       	ld.w	r11,r9[0x8]
8000b080:	72 39       	ld.w	r9,r9[0xc]
8000b082:	93 2b       	st.w	r9[0x8],r11
8000b084:	97 39       	st.w	r11[0xc],r9
8000b086:	10 99       	mov	r9,r8
8000b088:	ec 08 09 08 	st.w	r6[r8],r8
8000b08c:	a1 a9       	sbr	r9,0x0
8000b08e:	8d 19       	st.w	r6[0x4],r9
8000b090:	58 0c       	cp.w	r12,0
8000b092:	c5 a1       	brne	8000b146 <_free_r+0x182>
8000b094:	e0 48 01 ff 	cp.w	r8,511
8000b098:	e0 8b 00 13 	brhi	8000b0be <_free_r+0xfa>
8000b09c:	a3 98       	lsr	r8,0x3
8000b09e:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000b0a2:	72 2b       	ld.w	r11,r9[0x8]
8000b0a4:	8d 39       	st.w	r6[0xc],r9
8000b0a6:	8d 2b       	st.w	r6[0x8],r11
8000b0a8:	97 36       	st.w	r11[0xc],r6
8000b0aa:	93 26       	st.w	r9[0x8],r6
8000b0ac:	a3 48       	asr	r8,0x2
8000b0ae:	74 19       	ld.w	r9,r10[0x4]
8000b0b0:	30 1b       	mov	r11,1
8000b0b2:	f6 08 09 48 	lsl	r8,r11,r8
8000b0b6:	f3 e8 10 08 	or	r8,r9,r8
8000b0ba:	95 18       	st.w	r10[0x4],r8
8000b0bc:	c4 58       	rjmp	8000b146 <_free_r+0x182>
8000b0be:	f0 0b 16 09 	lsr	r11,r8,0x9
8000b0c2:	58 4b       	cp.w	r11,4
8000b0c4:	e0 8b 00 06 	brhi	8000b0d0 <_free_r+0x10c>
8000b0c8:	f0 0b 16 06 	lsr	r11,r8,0x6
8000b0cc:	2c 8b       	sub	r11,-56
8000b0ce:	c2 08       	rjmp	8000b10e <_free_r+0x14a>
8000b0d0:	59 4b       	cp.w	r11,20
8000b0d2:	e0 8b 00 04 	brhi	8000b0da <_free_r+0x116>
8000b0d6:	2a 5b       	sub	r11,-91
8000b0d8:	c1 b8       	rjmp	8000b10e <_free_r+0x14a>
8000b0da:	e0 4b 00 54 	cp.w	r11,84
8000b0de:	e0 8b 00 06 	brhi	8000b0ea <_free_r+0x126>
8000b0e2:	f0 0b 16 0c 	lsr	r11,r8,0xc
8000b0e6:	29 2b       	sub	r11,-110
8000b0e8:	c1 38       	rjmp	8000b10e <_free_r+0x14a>
8000b0ea:	e0 4b 01 54 	cp.w	r11,340
8000b0ee:	e0 8b 00 06 	brhi	8000b0fa <_free_r+0x136>
8000b0f2:	f0 0b 16 0f 	lsr	r11,r8,0xf
8000b0f6:	28 9b       	sub	r11,-119
8000b0f8:	c0 b8       	rjmp	8000b10e <_free_r+0x14a>
8000b0fa:	e0 4b 05 54 	cp.w	r11,1364
8000b0fe:	e0 88 00 05 	brls	8000b108 <_free_r+0x144>
8000b102:	37 eb       	mov	r11,126
8000b104:	c0 58       	rjmp	8000b10e <_free_r+0x14a>
8000b106:	d7 03       	nop
8000b108:	f0 0b 16 12 	lsr	r11,r8,0x12
8000b10c:	28 4b       	sub	r11,-124
8000b10e:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
8000b112:	78 29       	ld.w	r9,r12[0x8]
8000b114:	18 39       	cp.w	r9,r12
8000b116:	c0 e1       	brne	8000b132 <_free_r+0x16e>
8000b118:	74 18       	ld.w	r8,r10[0x4]
8000b11a:	a3 4b       	asr	r11,0x2
8000b11c:	30 1c       	mov	r12,1
8000b11e:	f8 0b 09 4b 	lsl	r11,r12,r11
8000b122:	f1 eb 10 0b 	or	r11,r8,r11
8000b126:	12 98       	mov	r8,r9
8000b128:	95 1b       	st.w	r10[0x4],r11
8000b12a:	c0 a8       	rjmp	8000b13e <_free_r+0x17a>
8000b12c:	72 29       	ld.w	r9,r9[0x8]
8000b12e:	18 39       	cp.w	r9,r12
8000b130:	c0 60       	breq	8000b13c <_free_r+0x178>
8000b132:	72 1a       	ld.w	r10,r9[0x4]
8000b134:	e0 1a ff fc 	andl	r10,0xfffc
8000b138:	14 38       	cp.w	r8,r10
8000b13a:	cf 93       	brcs	8000b12c <_free_r+0x168>
8000b13c:	72 38       	ld.w	r8,r9[0xc]
8000b13e:	8d 38       	st.w	r6[0xc],r8
8000b140:	8d 29       	st.w	r6[0x8],r9
8000b142:	93 36       	st.w	r9[0xc],r6
8000b144:	91 26       	st.w	r8[0x8],r6
8000b146:	0e 9c       	mov	r12,r7
8000b148:	fe b0 d6 4e 	rcall	80005de4 <__malloc_unlock>
8000b14c:	d8 22       	popm	r4-r7,pc
8000b14e:	d7 03       	nop

8000b150 <__sfvwrite_r>:
8000b150:	d4 31       	pushm	r0-r7,lr
8000b152:	20 3d       	sub	sp,12
8000b154:	14 94       	mov	r4,r10
8000b156:	18 95       	mov	r5,r12
8000b158:	16 97       	mov	r7,r11
8000b15a:	74 28       	ld.w	r8,r10[0x8]
8000b15c:	58 08       	cp.w	r8,0
8000b15e:	e0 80 01 40 	breq	8000b3de <__sfvwrite_r+0x28e>
8000b162:	96 68       	ld.sh	r8,r11[0xc]
8000b164:	ed b8 00 03 	bld	r8,0x3
8000b168:	c0 41       	brne	8000b170 <__sfvwrite_r+0x20>
8000b16a:	76 48       	ld.w	r8,r11[0x10]
8000b16c:	58 08       	cp.w	r8,0
8000b16e:	c0 c1       	brne	8000b186 <__sfvwrite_r+0x36>
8000b170:	0e 9b       	mov	r11,r7
8000b172:	0a 9c       	mov	r12,r5
8000b174:	fe b0 f6 c4 	rcall	80009efc <__swsetup_r>
8000b178:	c0 70       	breq	8000b186 <__sfvwrite_r+0x36>
8000b17a:	8e 68       	ld.sh	r8,r7[0xc]
8000b17c:	a7 a8       	sbr	r8,0x6
8000b17e:	ae 68       	st.h	r7[0xc],r8
8000b180:	30 98       	mov	r8,9
8000b182:	8b 38       	st.w	r5[0xc],r8
8000b184:	c2 b9       	rjmp	8000b3da <__sfvwrite_r+0x28a>
8000b186:	8e 63       	ld.sh	r3,r7[0xc]
8000b188:	68 00       	ld.w	r0,r4[0x0]
8000b18a:	06 96       	mov	r6,r3
8000b18c:	e2 16 00 02 	andl	r6,0x2,COH
8000b190:	c2 10       	breq	8000b1d2 <__sfvwrite_r+0x82>
8000b192:	30 03       	mov	r3,0
8000b194:	e0 62 04 00 	mov	r2,1024
8000b198:	06 96       	mov	r6,r3
8000b19a:	c0 48       	rjmp	8000b1a2 <__sfvwrite_r+0x52>
8000b19c:	60 03       	ld.w	r3,r0[0x0]
8000b19e:	60 16       	ld.w	r6,r0[0x4]
8000b1a0:	2f 80       	sub	r0,-8
8000b1a2:	58 06       	cp.w	r6,0
8000b1a4:	cf c0       	breq	8000b19c <__sfvwrite_r+0x4c>
8000b1a6:	e0 46 04 00 	cp.w	r6,1024
8000b1aa:	ec 09 17 80 	movls	r9,r6
8000b1ae:	e4 09 17 b0 	movhi	r9,r2
8000b1b2:	06 9a       	mov	r10,r3
8000b1b4:	6e a8       	ld.w	r8,r7[0x28]
8000b1b6:	6e 8b       	ld.w	r11,r7[0x20]
8000b1b8:	0a 9c       	mov	r12,r5
8000b1ba:	5d 18       	icall	r8
8000b1bc:	18 16       	sub	r6,r12
8000b1be:	58 0c       	cp.w	r12,0
8000b1c0:	e0 8a 01 0a 	brle	8000b3d4 <__sfvwrite_r+0x284>
8000b1c4:	68 28       	ld.w	r8,r4[0x8]
8000b1c6:	18 18       	sub	r8,r12
8000b1c8:	89 28       	st.w	r4[0x8],r8
8000b1ca:	e0 80 01 0a 	breq	8000b3de <__sfvwrite_r+0x28e>
8000b1ce:	18 03       	add	r3,r12
8000b1d0:	ce 9b       	rjmp	8000b1a2 <__sfvwrite_r+0x52>
8000b1d2:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
8000b1d6:	c0 70       	breq	8000b1e4 <__sfvwrite_r+0x94>
8000b1d8:	50 06       	stdsp	sp[0x0],r6
8000b1da:	0c 93       	mov	r3,r6
8000b1dc:	0c 91       	mov	r1,r6
8000b1de:	50 15       	stdsp	sp[0x4],r5
8000b1e0:	08 92       	mov	r2,r4
8000b1e2:	c9 c8       	rjmp	8000b31a <__sfvwrite_r+0x1ca>
8000b1e4:	06 96       	mov	r6,r3
8000b1e6:	08 91       	mov	r1,r4
8000b1e8:	c0 48       	rjmp	8000b1f0 <__sfvwrite_r+0xa0>
8000b1ea:	60 03       	ld.w	r3,r0[0x0]
8000b1ec:	60 16       	ld.w	r6,r0[0x4]
8000b1ee:	2f 80       	sub	r0,-8
8000b1f0:	58 06       	cp.w	r6,0
8000b1f2:	cf c0       	breq	8000b1ea <__sfvwrite_r+0x9a>
8000b1f4:	8e 68       	ld.sh	r8,r7[0xc]
8000b1f6:	6e 24       	ld.w	r4,r7[0x8]
8000b1f8:	10 99       	mov	r9,r8
8000b1fa:	e2 19 02 00 	andl	r9,0x200,COH
8000b1fe:	c5 50       	breq	8000b2a8 <__sfvwrite_r+0x158>
8000b200:	08 36       	cp.w	r6,r4
8000b202:	c4 43       	brcs	8000b28a <__sfvwrite_r+0x13a>
8000b204:	10 99       	mov	r9,r8
8000b206:	e2 19 04 80 	andl	r9,0x480,COH
8000b20a:	c4 00       	breq	8000b28a <__sfvwrite_r+0x13a>
8000b20c:	6e 4b       	ld.w	r11,r7[0x10]
8000b20e:	6e 09       	ld.w	r9,r7[0x0]
8000b210:	16 19       	sub	r9,r11
8000b212:	50 09       	stdsp	sp[0x0],r9
8000b214:	6e 59       	ld.w	r9,r7[0x14]
8000b216:	10 9c       	mov	r12,r8
8000b218:	f2 09 00 1a 	add	r10,r9,r9<<0x1
8000b21c:	30 28       	mov	r8,2
8000b21e:	f4 08 0c 08 	divs	r8,r10,r8
8000b222:	fa e9 00 04 	st.d	sp[4],r8
8000b226:	10 94       	mov	r4,r8
8000b228:	40 09       	lddsp	r9,sp[0x0]
8000b22a:	e2 1c 04 00 	andl	r12,0x400,COH
8000b22e:	2f f9       	sub	r9,-1
8000b230:	0c 09       	add	r9,r6
8000b232:	12 38       	cp.w	r8,r9
8000b234:	f2 04 17 30 	movlo	r4,r9
8000b238:	58 0c       	cp.w	r12,0
8000b23a:	c1 10       	breq	8000b25c <__sfvwrite_r+0x10c>
8000b23c:	08 9b       	mov	r11,r4
8000b23e:	0a 9c       	mov	r12,r5
8000b240:	fe b0 e0 4e 	rcall	800072dc <_malloc_r>
8000b244:	18 92       	mov	r2,r12
8000b246:	c1 40       	breq	8000b26e <__sfvwrite_r+0x11e>
8000b248:	40 0a       	lddsp	r10,sp[0x0]
8000b24a:	6e 4b       	ld.w	r11,r7[0x10]
8000b24c:	fe b0 e2 77 	rcall	8000773a <memcpy>
8000b250:	8e 68       	ld.sh	r8,r7[0xc]
8000b252:	e0 18 fb 7f 	andl	r8,0xfb7f
8000b256:	a7 b8       	sbr	r8,0x7
8000b258:	ae 68       	st.h	r7[0xc],r8
8000b25a:	c0 d8       	rjmp	8000b274 <__sfvwrite_r+0x124>
8000b25c:	08 9a       	mov	r10,r4
8000b25e:	0a 9c       	mov	r12,r5
8000b260:	fe b0 e3 18 	rcall	80007890 <_realloc_r>
8000b264:	18 92       	mov	r2,r12
8000b266:	c0 71       	brne	8000b274 <__sfvwrite_r+0x124>
8000b268:	6e 4b       	ld.w	r11,r7[0x10]
8000b26a:	0a 9c       	mov	r12,r5
8000b26c:	ca ce       	rcall	8000afc4 <_free_r>
8000b26e:	30 c8       	mov	r8,12
8000b270:	8b 38       	st.w	r5[0xc],r8
8000b272:	cb 18       	rjmp	8000b3d4 <__sfvwrite_r+0x284>
8000b274:	40 0a       	lddsp	r10,sp[0x0]
8000b276:	40 09       	lddsp	r9,sp[0x0]
8000b278:	e8 0a 01 0a 	sub	r10,r4,r10
8000b27c:	e4 09 00 08 	add	r8,r2,r9
8000b280:	8f 54       	st.w	r7[0x14],r4
8000b282:	8f 2a       	st.w	r7[0x8],r10
8000b284:	8f 08       	st.w	r7[0x0],r8
8000b286:	8f 42       	st.w	r7[0x10],r2
8000b288:	0c 94       	mov	r4,r6
8000b28a:	08 36       	cp.w	r6,r4
8000b28c:	ec 04 17 30 	movlo	r4,r6
8000b290:	06 9b       	mov	r11,r3
8000b292:	08 9a       	mov	r10,r4
8000b294:	6e 0c       	ld.w	r12,r7[0x0]
8000b296:	c3 ad       	rcall	8000b50a <memmove>
8000b298:	6e 08       	ld.w	r8,r7[0x0]
8000b29a:	08 08       	add	r8,r4
8000b29c:	8f 08       	st.w	r7[0x0],r8
8000b29e:	6e 28       	ld.w	r8,r7[0x8]
8000b2a0:	08 18       	sub	r8,r4
8000b2a2:	0c 94       	mov	r4,r6
8000b2a4:	8f 28       	st.w	r7[0x8],r8
8000b2a6:	c2 e8       	rjmp	8000b302 <__sfvwrite_r+0x1b2>
8000b2a8:	08 36       	cp.w	r6,r4
8000b2aa:	5f ba       	srhi	r10
8000b2ac:	6e 0c       	ld.w	r12,r7[0x0]
8000b2ae:	6e 48       	ld.w	r8,r7[0x10]
8000b2b0:	10 3c       	cp.w	r12,r8
8000b2b2:	5f b8       	srhi	r8
8000b2b4:	f5 e8 00 08 	and	r8,r10,r8
8000b2b8:	f2 08 18 00 	cp.b	r8,r9
8000b2bc:	c0 d0       	breq	8000b2d6 <__sfvwrite_r+0x186>
8000b2be:	06 9b       	mov	r11,r3
8000b2c0:	08 9a       	mov	r10,r4
8000b2c2:	c2 4d       	rcall	8000b50a <memmove>
8000b2c4:	6e 08       	ld.w	r8,r7[0x0]
8000b2c6:	08 08       	add	r8,r4
8000b2c8:	0e 9b       	mov	r11,r7
8000b2ca:	8f 08       	st.w	r7[0x0],r8
8000b2cc:	0a 9c       	mov	r12,r5
8000b2ce:	fe b0 fd 09 	rcall	8000ace0 <_fflush_r>
8000b2d2:	c1 80       	breq	8000b302 <__sfvwrite_r+0x1b2>
8000b2d4:	c8 08       	rjmp	8000b3d4 <__sfvwrite_r+0x284>
8000b2d6:	6e 59       	ld.w	r9,r7[0x14]
8000b2d8:	12 36       	cp.w	r6,r9
8000b2da:	c0 a3       	brcs	8000b2ee <__sfvwrite_r+0x19e>
8000b2dc:	6e a8       	ld.w	r8,r7[0x28]
8000b2de:	06 9a       	mov	r10,r3
8000b2e0:	6e 8b       	ld.w	r11,r7[0x20]
8000b2e2:	0a 9c       	mov	r12,r5
8000b2e4:	5d 18       	icall	r8
8000b2e6:	18 94       	mov	r4,r12
8000b2e8:	e0 89 00 0d 	brgt	8000b302 <__sfvwrite_r+0x1b2>
8000b2ec:	c7 48       	rjmp	8000b3d4 <__sfvwrite_r+0x284>
8000b2ee:	0c 9a       	mov	r10,r6
8000b2f0:	06 9b       	mov	r11,r3
8000b2f2:	c0 cd       	rcall	8000b50a <memmove>
8000b2f4:	6e 08       	ld.w	r8,r7[0x0]
8000b2f6:	0c 08       	add	r8,r6
8000b2f8:	0c 94       	mov	r4,r6
8000b2fa:	8f 08       	st.w	r7[0x0],r8
8000b2fc:	6e 28       	ld.w	r8,r7[0x8]
8000b2fe:	0c 18       	sub	r8,r6
8000b300:	8f 28       	st.w	r7[0x8],r8
8000b302:	62 28       	ld.w	r8,r1[0x8]
8000b304:	08 18       	sub	r8,r4
8000b306:	83 28       	st.w	r1[0x8],r8
8000b308:	c6 b0       	breq	8000b3de <__sfvwrite_r+0x28e>
8000b30a:	08 16       	sub	r6,r4
8000b30c:	08 03       	add	r3,r4
8000b30e:	c7 1b       	rjmp	8000b1f0 <__sfvwrite_r+0xa0>
8000b310:	60 03       	ld.w	r3,r0[0x0]
8000b312:	60 11       	ld.w	r1,r0[0x4]
8000b314:	30 08       	mov	r8,0
8000b316:	2f 80       	sub	r0,-8
8000b318:	50 08       	stdsp	sp[0x0],r8
8000b31a:	58 01       	cp.w	r1,0
8000b31c:	cf a0       	breq	8000b310 <__sfvwrite_r+0x1c0>
8000b31e:	40 0a       	lddsp	r10,sp[0x0]
8000b320:	58 0a       	cp.w	r10,0
8000b322:	c1 41       	brne	8000b34a <__sfvwrite_r+0x1fa>
8000b324:	e2 c6 ff ff 	sub	r6,r1,-1
8000b328:	02 9a       	mov	r10,r1
8000b32a:	30 ab       	mov	r11,10
8000b32c:	06 9c       	mov	r12,r3
8000b32e:	ce 3c       	rcall	8000b4f4 <memchr>
8000b330:	f8 c8 ff ff 	sub	r8,r12,-1
8000b334:	58 0c       	cp.w	r12,0
8000b336:	f1 d3 e1 16 	subne	r6,r8,r3
8000b33a:	f9 b9 01 01 	movne	r9,1
8000b33e:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000b342:	f9 b8 00 01 	moveq	r8,1
8000b346:	fb f8 0a 00 	st.weq	sp[0x0],r8
8000b34a:	02 36       	cp.w	r6,r1
8000b34c:	ec 04 17 80 	movls	r4,r6
8000b350:	e2 04 17 b0 	movhi	r4,r1
8000b354:	6e 59       	ld.w	r9,r7[0x14]
8000b356:	6e 25       	ld.w	r5,r7[0x8]
8000b358:	f2 05 00 05 	add	r5,r9,r5
8000b35c:	0a 34       	cp.w	r4,r5
8000b35e:	5f 9a       	srgt	r10
8000b360:	6e 0c       	ld.w	r12,r7[0x0]
8000b362:	6e 48       	ld.w	r8,r7[0x10]
8000b364:	10 3c       	cp.w	r12,r8
8000b366:	5f b8       	srhi	r8
8000b368:	f5 e8 00 08 	and	r8,r10,r8
8000b36c:	30 0a       	mov	r10,0
8000b36e:	f4 08 18 00 	cp.b	r8,r10
8000b372:	c0 d0       	breq	8000b38c <__sfvwrite_r+0x23c>
8000b374:	06 9b       	mov	r11,r3
8000b376:	0a 9a       	mov	r10,r5
8000b378:	cc 9c       	rcall	8000b50a <memmove>
8000b37a:	6e 08       	ld.w	r8,r7[0x0]
8000b37c:	0a 08       	add	r8,r5
8000b37e:	0e 9b       	mov	r11,r7
8000b380:	8f 08       	st.w	r7[0x0],r8
8000b382:	40 1c       	lddsp	r12,sp[0x4]
8000b384:	fe b0 fc ae 	rcall	8000ace0 <_fflush_r>
8000b388:	c1 70       	breq	8000b3b6 <__sfvwrite_r+0x266>
8000b38a:	c2 58       	rjmp	8000b3d4 <__sfvwrite_r+0x284>
8000b38c:	12 34       	cp.w	r4,r9
8000b38e:	c0 a5       	brlt	8000b3a2 <__sfvwrite_r+0x252>
8000b390:	6e a8       	ld.w	r8,r7[0x28]
8000b392:	06 9a       	mov	r10,r3
8000b394:	6e 8b       	ld.w	r11,r7[0x20]
8000b396:	40 1c       	lddsp	r12,sp[0x4]
8000b398:	5d 18       	icall	r8
8000b39a:	18 95       	mov	r5,r12
8000b39c:	e0 89 00 0d 	brgt	8000b3b6 <__sfvwrite_r+0x266>
8000b3a0:	c1 a8       	rjmp	8000b3d4 <__sfvwrite_r+0x284>
8000b3a2:	08 9a       	mov	r10,r4
8000b3a4:	06 9b       	mov	r11,r3
8000b3a6:	cb 2c       	rcall	8000b50a <memmove>
8000b3a8:	6e 08       	ld.w	r8,r7[0x0]
8000b3aa:	08 08       	add	r8,r4
8000b3ac:	08 95       	mov	r5,r4
8000b3ae:	8f 08       	st.w	r7[0x0],r8
8000b3b0:	6e 28       	ld.w	r8,r7[0x8]
8000b3b2:	08 18       	sub	r8,r4
8000b3b4:	8f 28       	st.w	r7[0x8],r8
8000b3b6:	0a 16       	sub	r6,r5
8000b3b8:	c0 71       	brne	8000b3c6 <__sfvwrite_r+0x276>
8000b3ba:	0e 9b       	mov	r11,r7
8000b3bc:	40 1c       	lddsp	r12,sp[0x4]
8000b3be:	fe b0 fc 91 	rcall	8000ace0 <_fflush_r>
8000b3c2:	c0 91       	brne	8000b3d4 <__sfvwrite_r+0x284>
8000b3c4:	50 06       	stdsp	sp[0x0],r6
8000b3c6:	64 28       	ld.w	r8,r2[0x8]
8000b3c8:	0a 18       	sub	r8,r5
8000b3ca:	85 28       	st.w	r2[0x8],r8
8000b3cc:	c0 90       	breq	8000b3de <__sfvwrite_r+0x28e>
8000b3ce:	0a 11       	sub	r1,r5
8000b3d0:	0a 03       	add	r3,r5
8000b3d2:	ca 4b       	rjmp	8000b31a <__sfvwrite_r+0x1ca>
8000b3d4:	8e 68       	ld.sh	r8,r7[0xc]
8000b3d6:	a7 a8       	sbr	r8,0x6
8000b3d8:	ae 68       	st.h	r7[0xc],r8
8000b3da:	3f fc       	mov	r12,-1
8000b3dc:	c0 28       	rjmp	8000b3e0 <__sfvwrite_r+0x290>
8000b3de:	30 0c       	mov	r12,0
8000b3e0:	2f dd       	sub	sp,-12
8000b3e2:	d8 32       	popm	r0-r7,pc

8000b3e4 <_fwalk>:
8000b3e4:	d4 31       	pushm	r0-r7,lr
8000b3e6:	30 05       	mov	r5,0
8000b3e8:	16 91       	mov	r1,r11
8000b3ea:	f8 c7 ff 28 	sub	r7,r12,-216
8000b3ee:	0a 92       	mov	r2,r5
8000b3f0:	fe b0 fc fe 	rcall	8000adec <__sfp_lock_acquire>
8000b3f4:	3f f3       	mov	r3,-1
8000b3f6:	c1 68       	rjmp	8000b422 <_fwalk+0x3e>
8000b3f8:	6e 26       	ld.w	r6,r7[0x8]
8000b3fa:	6e 14       	ld.w	r4,r7[0x4]
8000b3fc:	2f 46       	sub	r6,-12
8000b3fe:	c0 c8       	rjmp	8000b416 <_fwalk+0x32>
8000b400:	8c 08       	ld.sh	r8,r6[0x0]
8000b402:	e4 08 19 00 	cp.h	r8,r2
8000b406:	c0 70       	breq	8000b414 <_fwalk+0x30>
8000b408:	8c 18       	ld.sh	r8,r6[0x2]
8000b40a:	e6 08 19 00 	cp.h	r8,r3
8000b40e:	c0 30       	breq	8000b414 <_fwalk+0x30>
8000b410:	5d 11       	icall	r1
8000b412:	18 45       	or	r5,r12
8000b414:	2a 46       	sub	r6,-92
8000b416:	20 14       	sub	r4,1
8000b418:	ec cc 00 0c 	sub	r12,r6,12
8000b41c:	58 04       	cp.w	r4,0
8000b41e:	cf 14       	brge	8000b400 <_fwalk+0x1c>
8000b420:	6e 07       	ld.w	r7,r7[0x0]
8000b422:	58 07       	cp.w	r7,0
8000b424:	ce a1       	brne	8000b3f8 <_fwalk+0x14>
8000b426:	fe b0 fc e4 	rcall	8000adee <__sfp_lock_release>
8000b42a:	0a 9c       	mov	r12,r5
8000b42c:	d8 32       	popm	r0-r7,pc
8000b42e:	d7 03       	nop

8000b430 <_localeconv_r>:
8000b430:	fe cc cf b8 	sub	r12,pc,-12360
8000b434:	5e fc       	retal	r12
8000b436:	d7 03       	nop

8000b438 <__smakebuf_r>:
8000b438:	d4 21       	pushm	r4-r7,lr
8000b43a:	20 fd       	sub	sp,60
8000b43c:	96 68       	ld.sh	r8,r11[0xc]
8000b43e:	16 97       	mov	r7,r11
8000b440:	18 96       	mov	r6,r12
8000b442:	e2 18 00 02 	andl	r8,0x2,COH
8000b446:	c3 d1       	brne	8000b4c0 <__smakebuf_r+0x88>
8000b448:	96 7b       	ld.sh	r11,r11[0xe]
8000b44a:	f0 0b 19 00 	cp.h	r11,r8
8000b44e:	c0 55       	brlt	8000b458 <__smakebuf_r+0x20>
8000b450:	1a 9a       	mov	r10,sp
8000b452:	e0 a0 04 75 	rcall	8000bd3c <_fstat_r>
8000b456:	c0 f4       	brge	8000b474 <__smakebuf_r+0x3c>
8000b458:	8e 65       	ld.sh	r5,r7[0xc]
8000b45a:	0a 98       	mov	r8,r5
8000b45c:	ab b8       	sbr	r8,0xb
8000b45e:	e2 15 00 80 	andl	r5,0x80,COH
8000b462:	ae 68       	st.h	r7[0xc],r8
8000b464:	30 04       	mov	r4,0
8000b466:	e0 68 04 00 	mov	r8,1024
8000b46a:	f9 b5 01 40 	movne	r5,64
8000b46e:	f0 05 17 00 	moveq	r5,r8
8000b472:	c1 c8       	rjmp	8000b4aa <__smakebuf_r+0x72>
8000b474:	40 18       	lddsp	r8,sp[0x4]
8000b476:	e2 18 f0 00 	andl	r8,0xf000,COH
8000b47a:	e0 48 20 00 	cp.w	r8,8192
8000b47e:	5f 04       	sreq	r4
8000b480:	e0 48 80 00 	cp.w	r8,32768
8000b484:	c0 e1       	brne	8000b4a0 <__smakebuf_r+0x68>
8000b486:	6e b9       	ld.w	r9,r7[0x2c]
8000b488:	fe c8 f9 1c 	sub	r8,pc,-1764
8000b48c:	10 39       	cp.w	r9,r8
8000b48e:	c0 91       	brne	8000b4a0 <__smakebuf_r+0x68>
8000b490:	8e 68       	ld.sh	r8,r7[0xc]
8000b492:	e0 65 04 00 	mov	r5,1024
8000b496:	ab a8       	sbr	r8,0xa
8000b498:	ef 45 00 50 	st.w	r7[80],r5
8000b49c:	ae 68       	st.h	r7[0xc],r8
8000b49e:	c0 68       	rjmp	8000b4aa <__smakebuf_r+0x72>
8000b4a0:	8e 68       	ld.sh	r8,r7[0xc]
8000b4a2:	e0 65 04 00 	mov	r5,1024
8000b4a6:	ab b8       	sbr	r8,0xb
8000b4a8:	ae 68       	st.h	r7[0xc],r8
8000b4aa:	0a 9b       	mov	r11,r5
8000b4ac:	0c 9c       	mov	r12,r6
8000b4ae:	fe b0 df 17 	rcall	800072dc <_malloc_r>
8000b4b2:	8e 68       	ld.sh	r8,r7[0xc]
8000b4b4:	c0 d1       	brne	8000b4ce <__smakebuf_r+0x96>
8000b4b6:	ed b8 00 09 	bld	r8,0x9
8000b4ba:	c1 b0       	breq	8000b4f0 <__smakebuf_r+0xb8>
8000b4bc:	a1 b8       	sbr	r8,0x1
8000b4be:	ae 68       	st.h	r7[0xc],r8
8000b4c0:	ee c8 ff b9 	sub	r8,r7,-71
8000b4c4:	8f 48       	st.w	r7[0x10],r8
8000b4c6:	8f 08       	st.w	r7[0x0],r8
8000b4c8:	30 18       	mov	r8,1
8000b4ca:	8f 58       	st.w	r7[0x14],r8
8000b4cc:	c1 28       	rjmp	8000b4f0 <__smakebuf_r+0xb8>
8000b4ce:	a7 b8       	sbr	r8,0x7
8000b4d0:	8f 4c       	st.w	r7[0x10],r12
8000b4d2:	ae 68       	st.h	r7[0xc],r8
8000b4d4:	8f 55       	st.w	r7[0x14],r5
8000b4d6:	fe c8 06 e6 	sub	r8,pc,1766
8000b4da:	8f 0c       	st.w	r7[0x0],r12
8000b4dc:	8d a8       	st.w	r6[0x28],r8
8000b4de:	58 04       	cp.w	r4,0
8000b4e0:	c0 80       	breq	8000b4f0 <__smakebuf_r+0xb8>
8000b4e2:	8e 7c       	ld.sh	r12,r7[0xe]
8000b4e4:	fe b0 e3 94 	rcall	80007c0c <isatty>
8000b4e8:	c0 40       	breq	8000b4f0 <__smakebuf_r+0xb8>
8000b4ea:	8e 68       	ld.sh	r8,r7[0xc]
8000b4ec:	a1 a8       	sbr	r8,0x0
8000b4ee:	ae 68       	st.h	r7[0xc],r8
8000b4f0:	2f 1d       	sub	sp,-60
8000b4f2:	d8 22       	popm	r4-r7,pc

8000b4f4 <memchr>:
8000b4f4:	f7 db c0 08 	bfextu	r11,r11,0x0,0x8
8000b4f8:	c0 68       	rjmp	8000b504 <memchr+0x10>
8000b4fa:	20 1a       	sub	r10,1
8000b4fc:	19 88       	ld.ub	r8,r12[0x0]
8000b4fe:	16 38       	cp.w	r8,r11
8000b500:	5e 0c       	reteq	r12
8000b502:	2f fc       	sub	r12,-1
8000b504:	58 0a       	cp.w	r10,0
8000b506:	cf a1       	brne	8000b4fa <memchr+0x6>
8000b508:	5e fa       	retal	r10

8000b50a <memmove>:
8000b50a:	d4 01       	pushm	lr
8000b50c:	18 3b       	cp.w	r11,r12
8000b50e:	c1 92       	brcc	8000b540 <memmove+0x36>
8000b510:	f6 0a 00 09 	add	r9,r11,r10
8000b514:	12 3c       	cp.w	r12,r9
8000b516:	c1 52       	brcc	8000b540 <memmove+0x36>
8000b518:	f8 0a 00 0b 	add	r11,r12,r10
8000b51c:	30 08       	mov	r8,0
8000b51e:	c0 68       	rjmp	8000b52a <memmove+0x20>
8000b520:	f2 08 07 0e 	ld.ub	lr,r9[r8]
8000b524:	20 1a       	sub	r10,1
8000b526:	f6 08 0b 0e 	st.b	r11[r8],lr
8000b52a:	20 18       	sub	r8,1
8000b52c:	58 0a       	cp.w	r10,0
8000b52e:	cf 91       	brne	8000b520 <memmove+0x16>
8000b530:	d8 02       	popm	pc
8000b532:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000b536:	20 1a       	sub	r10,1
8000b538:	f8 08 0b 09 	st.b	r12[r8],r9
8000b53c:	2f f8       	sub	r8,-1
8000b53e:	c0 28       	rjmp	8000b542 <memmove+0x38>
8000b540:	30 08       	mov	r8,0
8000b542:	58 0a       	cp.w	r10,0
8000b544:	cf 71       	brne	8000b532 <memmove+0x28>
8000b546:	d8 02       	popm	pc

8000b548 <__hi0bits>:
8000b548:	18 98       	mov	r8,r12
8000b54a:	e0 1c 00 00 	andl	r12,0x0
8000b54e:	f0 09 15 10 	lsl	r9,r8,0x10
8000b552:	58 0c       	cp.w	r12,0
8000b554:	f2 08 17 00 	moveq	r8,r9
8000b558:	f9 bc 00 10 	moveq	r12,16
8000b55c:	f9 bc 01 00 	movne	r12,0
8000b560:	10 9a       	mov	r10,r8
8000b562:	f0 09 15 08 	lsl	r9,r8,0x8
8000b566:	e6 1a ff 00 	andh	r10,0xff00,COH
8000b56a:	f7 bc 00 f8 	subeq	r12,-8
8000b56e:	f2 08 17 00 	moveq	r8,r9
8000b572:	10 9a       	mov	r10,r8
8000b574:	f0 09 15 04 	lsl	r9,r8,0x4
8000b578:	e6 1a f0 00 	andh	r10,0xf000,COH
8000b57c:	f7 bc 00 fc 	subeq	r12,-4
8000b580:	f2 08 17 00 	moveq	r8,r9
8000b584:	10 9a       	mov	r10,r8
8000b586:	f0 09 15 02 	lsl	r9,r8,0x2
8000b58a:	e6 1a c0 00 	andh	r10,0xc000,COH
8000b58e:	f7 bc 00 fe 	subeq	r12,-2
8000b592:	f2 08 17 00 	moveq	r8,r9
8000b596:	58 08       	cp.w	r8,0
8000b598:	5e 5c       	retlt	r12
8000b59a:	ed b8 00 1e 	bld	r8,0x1e
8000b59e:	f9 bc 01 20 	movne	r12,32
8000b5a2:	f7 bc 00 ff 	subeq	r12,-1
8000b5a6:	5e fc       	retal	r12

8000b5a8 <__lo0bits>:
8000b5a8:	18 99       	mov	r9,r12
8000b5aa:	78 08       	ld.w	r8,r12[0x0]
8000b5ac:	f9 d8 c0 03 	bfextu	r12,r8,0x0,0x3
8000b5b0:	c1 50       	breq	8000b5da <__lo0bits+0x32>
8000b5b2:	ed b8 00 00 	bld	r8,0x0
8000b5b6:	c0 21       	brne	8000b5ba <__lo0bits+0x12>
8000b5b8:	5e fd       	retal	0
8000b5ba:	10 9b       	mov	r11,r8
8000b5bc:	f0 0a 16 01 	lsr	r10,r8,0x1
8000b5c0:	e2 1b 00 02 	andl	r11,0x2,COH
8000b5c4:	a3 88       	lsr	r8,0x2
8000b5c6:	58 0b       	cp.w	r11,0
8000b5c8:	f3 fa 1a 00 	st.wne	r9[0x0],r10
8000b5cc:	f9 bc 01 01 	movne	r12,1
8000b5d0:	f3 f8 0a 00 	st.weq	r9[0x0],r8
8000b5d4:	f9 bc 00 02 	moveq	r12,2
8000b5d8:	5e fc       	retal	r12
8000b5da:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8000b5de:	f0 0b 16 10 	lsr	r11,r8,0x10
8000b5e2:	58 0a       	cp.w	r10,0
8000b5e4:	f6 08 17 00 	moveq	r8,r11
8000b5e8:	f9 bc 00 10 	moveq	r12,16
8000b5ec:	f7 d8 c0 08 	bfextu	r11,r8,0x0,0x8
8000b5f0:	f0 0a 16 08 	lsr	r10,r8,0x8
8000b5f4:	58 0b       	cp.w	r11,0
8000b5f6:	f7 bc 00 f8 	subeq	r12,-8
8000b5fa:	f4 08 17 00 	moveq	r8,r10
8000b5fe:	f7 d8 c0 04 	bfextu	r11,r8,0x0,0x4
8000b602:	f0 0a 16 04 	lsr	r10,r8,0x4
8000b606:	58 0b       	cp.w	r11,0
8000b608:	f7 bc 00 fc 	subeq	r12,-4
8000b60c:	f4 08 17 00 	moveq	r8,r10
8000b610:	f7 d8 c0 02 	bfextu	r11,r8,0x0,0x2
8000b614:	f0 0a 16 02 	lsr	r10,r8,0x2
8000b618:	58 0b       	cp.w	r11,0
8000b61a:	f7 bc 00 fe 	subeq	r12,-2
8000b61e:	f4 08 17 00 	moveq	r8,r10
8000b622:	ed b8 00 00 	bld	r8,0x0
8000b626:	c0 60       	breq	8000b632 <__lo0bits+0x8a>
8000b628:	a1 98       	lsr	r8,0x1
8000b62a:	c0 31       	brne	8000b630 <__lo0bits+0x88>
8000b62c:	32 0c       	mov	r12,32
8000b62e:	5e fc       	retal	r12
8000b630:	2f fc       	sub	r12,-1
8000b632:	93 08       	st.w	r9[0x0],r8
8000b634:	5e fc       	retal	r12

8000b636 <__mcmp>:
8000b636:	d4 01       	pushm	lr
8000b638:	18 98       	mov	r8,r12
8000b63a:	76 49       	ld.w	r9,r11[0x10]
8000b63c:	78 4c       	ld.w	r12,r12[0x10]
8000b63e:	12 1c       	sub	r12,r9
8000b640:	c1 31       	brne	8000b666 <__mcmp+0x30>
8000b642:	2f b9       	sub	r9,-5
8000b644:	a3 69       	lsl	r9,0x2
8000b646:	12 0b       	add	r11,r9
8000b648:	f0 09 00 09 	add	r9,r8,r9
8000b64c:	2e c8       	sub	r8,-20
8000b64e:	13 4e       	ld.w	lr,--r9
8000b650:	17 4a       	ld.w	r10,--r11
8000b652:	14 3e       	cp.w	lr,r10
8000b654:	c0 60       	breq	8000b660 <__mcmp+0x2a>
8000b656:	f9 bc 03 ff 	movlo	r12,-1
8000b65a:	f9 bc 02 01 	movhs	r12,1
8000b65e:	d8 02       	popm	pc
8000b660:	10 39       	cp.w	r9,r8
8000b662:	fe 9b ff f6 	brhi	8000b64e <__mcmp+0x18>
8000b666:	d8 02       	popm	pc

8000b668 <_Bfree>:
8000b668:	d4 21       	pushm	r4-r7,lr
8000b66a:	18 97       	mov	r7,r12
8000b66c:	16 95       	mov	r5,r11
8000b66e:	78 96       	ld.w	r6,r12[0x24]
8000b670:	58 06       	cp.w	r6,0
8000b672:	c0 91       	brne	8000b684 <_Bfree+0x1c>
8000b674:	31 0c       	mov	r12,16
8000b676:	fe b0 de 2b 	rcall	800072cc <malloc>
8000b67a:	99 36       	st.w	r12[0xc],r6
8000b67c:	8f 9c       	st.w	r7[0x24],r12
8000b67e:	99 16       	st.w	r12[0x4],r6
8000b680:	99 26       	st.w	r12[0x8],r6
8000b682:	99 06       	st.w	r12[0x0],r6
8000b684:	58 05       	cp.w	r5,0
8000b686:	c0 90       	breq	8000b698 <_Bfree+0x30>
8000b688:	6a 19       	ld.w	r9,r5[0x4]
8000b68a:	6e 98       	ld.w	r8,r7[0x24]
8000b68c:	70 38       	ld.w	r8,r8[0xc]
8000b68e:	f0 09 03 2a 	ld.w	r10,r8[r9<<0x2]
8000b692:	8b 0a       	st.w	r5[0x0],r10
8000b694:	f0 09 09 25 	st.w	r8[r9<<0x2],r5
8000b698:	d8 22       	popm	r4-r7,pc
8000b69a:	d7 03       	nop

8000b69c <_Balloc>:
8000b69c:	d4 21       	pushm	r4-r7,lr
8000b69e:	18 97       	mov	r7,r12
8000b6a0:	16 96       	mov	r6,r11
8000b6a2:	78 95       	ld.w	r5,r12[0x24]
8000b6a4:	58 05       	cp.w	r5,0
8000b6a6:	c0 91       	brne	8000b6b8 <_Balloc+0x1c>
8000b6a8:	31 0c       	mov	r12,16
8000b6aa:	fe b0 de 11 	rcall	800072cc <malloc>
8000b6ae:	99 35       	st.w	r12[0xc],r5
8000b6b0:	8f 9c       	st.w	r7[0x24],r12
8000b6b2:	99 15       	st.w	r12[0x4],r5
8000b6b4:	99 25       	st.w	r12[0x8],r5
8000b6b6:	99 05       	st.w	r12[0x0],r5
8000b6b8:	6e 95       	ld.w	r5,r7[0x24]
8000b6ba:	6a 38       	ld.w	r8,r5[0xc]
8000b6bc:	58 08       	cp.w	r8,0
8000b6be:	c0 b1       	brne	8000b6d4 <_Balloc+0x38>
8000b6c0:	31 0a       	mov	r10,16
8000b6c2:	30 4b       	mov	r11,4
8000b6c4:	0e 9c       	mov	r12,r7
8000b6c6:	e0 a0 02 9b 	rcall	8000bbfc <_calloc_r>
8000b6ca:	8b 3c       	st.w	r5[0xc],r12
8000b6cc:	6e 98       	ld.w	r8,r7[0x24]
8000b6ce:	70 3c       	ld.w	r12,r8[0xc]
8000b6d0:	58 0c       	cp.w	r12,0
8000b6d2:	c1 b0       	breq	8000b708 <_Balloc+0x6c>
8000b6d4:	6e 98       	ld.w	r8,r7[0x24]
8000b6d6:	70 38       	ld.w	r8,r8[0xc]
8000b6d8:	f0 06 00 28 	add	r8,r8,r6<<0x2
8000b6dc:	70 0c       	ld.w	r12,r8[0x0]
8000b6de:	58 0c       	cp.w	r12,0
8000b6e0:	c0 40       	breq	8000b6e8 <_Balloc+0x4c>
8000b6e2:	78 09       	ld.w	r9,r12[0x0]
8000b6e4:	91 09       	st.w	r8[0x0],r9
8000b6e6:	c0 e8       	rjmp	8000b702 <_Balloc+0x66>
8000b6e8:	0e 9c       	mov	r12,r7
8000b6ea:	30 17       	mov	r7,1
8000b6ec:	0e 9b       	mov	r11,r7
8000b6ee:	ee 06 09 47 	lsl	r7,r7,r6
8000b6f2:	ee ca ff fb 	sub	r10,r7,-5
8000b6f6:	a3 6a       	lsl	r10,0x2
8000b6f8:	e0 a0 02 82 	rcall	8000bbfc <_calloc_r>
8000b6fc:	c0 60       	breq	8000b708 <_Balloc+0x6c>
8000b6fe:	99 16       	st.w	r12[0x4],r6
8000b700:	99 27       	st.w	r12[0x8],r7
8000b702:	30 08       	mov	r8,0
8000b704:	99 38       	st.w	r12[0xc],r8
8000b706:	99 48       	st.w	r12[0x10],r8
8000b708:	d8 22       	popm	r4-r7,pc
8000b70a:	d7 03       	nop

8000b70c <__d2b>:
8000b70c:	d4 31       	pushm	r0-r7,lr
8000b70e:	20 2d       	sub	sp,8
8000b710:	16 93       	mov	r3,r11
8000b712:	12 96       	mov	r6,r9
8000b714:	10 95       	mov	r5,r8
8000b716:	14 92       	mov	r2,r10
8000b718:	30 1b       	mov	r11,1
8000b71a:	cc 1f       	rcall	8000b69c <_Balloc>
8000b71c:	f3 d3 c0 14 	bfextu	r9,r3,0x0,0x14
8000b720:	50 09       	stdsp	sp[0x0],r9
8000b722:	f1 d3 c0 1f 	bfextu	r8,r3,0x0,0x1f
8000b726:	b5 a9       	sbr	r9,0x14
8000b728:	f0 01 16 14 	lsr	r1,r8,0x14
8000b72c:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000b730:	18 94       	mov	r4,r12
8000b732:	58 02       	cp.w	r2,0
8000b734:	c1 d0       	breq	8000b76e <__d2b+0x62>
8000b736:	fa cc ff f8 	sub	r12,sp,-8
8000b73a:	18 d2       	st.w	--r12,r2
8000b73c:	c3 6f       	rcall	8000b5a8 <__lo0bits>
8000b73e:	40 18       	lddsp	r8,sp[0x4]
8000b740:	c0 d0       	breq	8000b75a <__d2b+0x4e>
8000b742:	40 09       	lddsp	r9,sp[0x0]
8000b744:	f8 0a 11 20 	rsub	r10,r12,32
8000b748:	f2 0a 09 4a 	lsl	r10,r9,r10
8000b74c:	f5 e8 10 08 	or	r8,r10,r8
8000b750:	89 58       	st.w	r4[0x14],r8
8000b752:	f2 0c 0a 49 	lsr	r9,r9,r12
8000b756:	50 09       	stdsp	sp[0x0],r9
8000b758:	c0 28       	rjmp	8000b75c <__d2b+0x50>
8000b75a:	89 58       	st.w	r4[0x14],r8
8000b75c:	40 08       	lddsp	r8,sp[0x0]
8000b75e:	58 08       	cp.w	r8,0
8000b760:	f9 b3 01 02 	movne	r3,2
8000b764:	f9 b3 00 01 	moveq	r3,1
8000b768:	89 68       	st.w	r4[0x18],r8
8000b76a:	89 43       	st.w	r4[0x10],r3
8000b76c:	c0 88       	rjmp	8000b77c <__d2b+0x70>
8000b76e:	1a 9c       	mov	r12,sp
8000b770:	c1 cf       	rcall	8000b5a8 <__lo0bits>
8000b772:	30 13       	mov	r3,1
8000b774:	40 08       	lddsp	r8,sp[0x0]
8000b776:	2e 0c       	sub	r12,-32
8000b778:	89 43       	st.w	r4[0x10],r3
8000b77a:	89 58       	st.w	r4[0x14],r8
8000b77c:	58 01       	cp.w	r1,0
8000b77e:	c0 90       	breq	8000b790 <__d2b+0x84>
8000b780:	e2 c1 04 33 	sub	r1,r1,1075
8000b784:	18 01       	add	r1,r12
8000b786:	8d 01       	st.w	r6[0x0],r1
8000b788:	f8 0c 11 35 	rsub	r12,r12,53
8000b78c:	8b 0c       	st.w	r5[0x0],r12
8000b78e:	c0 c8       	rjmp	8000b7a6 <__d2b+0x9a>
8000b790:	e6 c8 ff fc 	sub	r8,r3,-4
8000b794:	f8 cc 04 32 	sub	r12,r12,1074
8000b798:	a5 73       	lsl	r3,0x5
8000b79a:	8d 0c       	st.w	r6[0x0],r12
8000b79c:	e8 08 03 2c 	ld.w	r12,r4[r8<<0x2]
8000b7a0:	cd 4e       	rcall	8000b548 <__hi0bits>
8000b7a2:	18 13       	sub	r3,r12
8000b7a4:	8b 03       	st.w	r5[0x0],r3
8000b7a6:	08 9c       	mov	r12,r4
8000b7a8:	2f ed       	sub	sp,-8
8000b7aa:	d8 32       	popm	r0-r7,pc

8000b7ac <__mdiff>:
8000b7ac:	d4 31       	pushm	r0-r7,lr
8000b7ae:	74 48       	ld.w	r8,r10[0x10]
8000b7b0:	76 45       	ld.w	r5,r11[0x10]
8000b7b2:	16 97       	mov	r7,r11
8000b7b4:	14 96       	mov	r6,r10
8000b7b6:	10 15       	sub	r5,r8
8000b7b8:	c1 31       	brne	8000b7de <__mdiff+0x32>
8000b7ba:	2f b8       	sub	r8,-5
8000b7bc:	ee ce ff ec 	sub	lr,r7,-20
8000b7c0:	a3 68       	lsl	r8,0x2
8000b7c2:	f4 08 00 0b 	add	r11,r10,r8
8000b7c6:	ee 08 00 08 	add	r8,r7,r8
8000b7ca:	11 4a       	ld.w	r10,--r8
8000b7cc:	17 49       	ld.w	r9,--r11
8000b7ce:	12 3a       	cp.w	r10,r9
8000b7d0:	c0 30       	breq	8000b7d6 <__mdiff+0x2a>
8000b7d2:	c0 e2       	brcc	8000b7ee <__mdiff+0x42>
8000b7d4:	c0 78       	rjmp	8000b7e2 <__mdiff+0x36>
8000b7d6:	1c 38       	cp.w	r8,lr
8000b7d8:	fe 9b ff f9 	brhi	8000b7ca <__mdiff+0x1e>
8000b7dc:	c4 98       	rjmp	8000b86e <__mdiff+0xc2>
8000b7de:	58 05       	cp.w	r5,0
8000b7e0:	c0 64       	brge	8000b7ec <__mdiff+0x40>
8000b7e2:	0e 98       	mov	r8,r7
8000b7e4:	30 15       	mov	r5,1
8000b7e6:	0c 97       	mov	r7,r6
8000b7e8:	10 96       	mov	r6,r8
8000b7ea:	c0 28       	rjmp	8000b7ee <__mdiff+0x42>
8000b7ec:	30 05       	mov	r5,0
8000b7ee:	6e 1b       	ld.w	r11,r7[0x4]
8000b7f0:	c5 6f       	rcall	8000b69c <_Balloc>
8000b7f2:	6e 49       	ld.w	r9,r7[0x10]
8000b7f4:	6c 44       	ld.w	r4,r6[0x10]
8000b7f6:	99 35       	st.w	r12[0xc],r5
8000b7f8:	2f b4       	sub	r4,-5
8000b7fa:	f2 c5 ff fb 	sub	r5,r9,-5
8000b7fe:	ec 04 00 24 	add	r4,r6,r4<<0x2
8000b802:	ee 05 00 25 	add	r5,r7,r5<<0x2
8000b806:	2e c6       	sub	r6,-20
8000b808:	2e c7       	sub	r7,-20
8000b80a:	f8 c8 ff ec 	sub	r8,r12,-20
8000b80e:	30 0a       	mov	r10,0
8000b810:	0f 0e       	ld.w	lr,r7++
8000b812:	0d 0b       	ld.w	r11,r6++
8000b814:	fc 02 16 10 	lsr	r2,lr,0x10
8000b818:	f6 03 16 10 	lsr	r3,r11,0x10
8000b81c:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000b820:	e4 03 01 03 	sub	r3,r2,r3
8000b824:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b828:	fc 0b 01 0b 	sub	r11,lr,r11
8000b82c:	f6 0a 00 0a 	add	r10,r11,r10
8000b830:	b0 1a       	st.h	r8[0x2],r10
8000b832:	b1 4a       	asr	r10,0x10
8000b834:	e6 0a 00 0a 	add	r10,r3,r10
8000b838:	b0 0a       	st.h	r8[0x0],r10
8000b83a:	2f c8       	sub	r8,-4
8000b83c:	b1 4a       	asr	r10,0x10
8000b83e:	08 36       	cp.w	r6,r4
8000b840:	ce 83       	brcs	8000b810 <__mdiff+0x64>
8000b842:	c0 d8       	rjmp	8000b85c <__mdiff+0xb0>
8000b844:	0f 0b       	ld.w	r11,r7++
8000b846:	f6 0e 16 10 	lsr	lr,r11,0x10
8000b84a:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b84e:	16 0a       	add	r10,r11
8000b850:	b0 1a       	st.h	r8[0x2],r10
8000b852:	b1 4a       	asr	r10,0x10
8000b854:	1c 0a       	add	r10,lr
8000b856:	b0 0a       	st.h	r8[0x0],r10
8000b858:	2f c8       	sub	r8,-4
8000b85a:	b1 4a       	asr	r10,0x10
8000b85c:	0a 37       	cp.w	r7,r5
8000b85e:	cf 33       	brcs	8000b844 <__mdiff+0x98>
8000b860:	c0 28       	rjmp	8000b864 <__mdiff+0xb8>
8000b862:	20 19       	sub	r9,1
8000b864:	11 4a       	ld.w	r10,--r8
8000b866:	58 0a       	cp.w	r10,0
8000b868:	cf d0       	breq	8000b862 <__mdiff+0xb6>
8000b86a:	99 49       	st.w	r12[0x10],r9
8000b86c:	d8 32       	popm	r0-r7,pc
8000b86e:	30 0b       	mov	r11,0
8000b870:	c1 6f       	rcall	8000b69c <_Balloc>
8000b872:	30 18       	mov	r8,1
8000b874:	99 48       	st.w	r12[0x10],r8
8000b876:	30 08       	mov	r8,0
8000b878:	99 58       	st.w	r12[0x14],r8
8000b87a:	d8 32       	popm	r0-r7,pc

8000b87c <__lshift>:
8000b87c:	d4 31       	pushm	r0-r7,lr
8000b87e:	16 97       	mov	r7,r11
8000b880:	76 46       	ld.w	r6,r11[0x10]
8000b882:	f4 02 14 05 	asr	r2,r10,0x5
8000b886:	2f f6       	sub	r6,-1
8000b888:	14 93       	mov	r3,r10
8000b88a:	18 94       	mov	r4,r12
8000b88c:	04 06       	add	r6,r2
8000b88e:	76 1b       	ld.w	r11,r11[0x4]
8000b890:	6e 28       	ld.w	r8,r7[0x8]
8000b892:	c0 38       	rjmp	8000b898 <__lshift+0x1c>
8000b894:	2f fb       	sub	r11,-1
8000b896:	a1 78       	lsl	r8,0x1
8000b898:	10 36       	cp.w	r6,r8
8000b89a:	fe 99 ff fd 	brgt	8000b894 <__lshift+0x18>
8000b89e:	08 9c       	mov	r12,r4
8000b8a0:	cf ee       	rcall	8000b69c <_Balloc>
8000b8a2:	30 09       	mov	r9,0
8000b8a4:	18 95       	mov	r5,r12
8000b8a6:	f8 c8 ff ec 	sub	r8,r12,-20
8000b8aa:	12 9a       	mov	r10,r9
8000b8ac:	c0 38       	rjmp	8000b8b2 <__lshift+0x36>
8000b8ae:	10 aa       	st.w	r8++,r10
8000b8b0:	2f f9       	sub	r9,-1
8000b8b2:	04 39       	cp.w	r9,r2
8000b8b4:	cf d5       	brlt	8000b8ae <__lshift+0x32>
8000b8b6:	6e 4b       	ld.w	r11,r7[0x10]
8000b8b8:	e7 d3 c0 05 	bfextu	r3,r3,0x0,0x5
8000b8bc:	2f bb       	sub	r11,-5
8000b8be:	ee c9 ff ec 	sub	r9,r7,-20
8000b8c2:	ee 0b 00 2b 	add	r11,r7,r11<<0x2
8000b8c6:	58 03       	cp.w	r3,0
8000b8c8:	c1 30       	breq	8000b8ee <__lshift+0x72>
8000b8ca:	e6 0c 11 20 	rsub	r12,r3,32
8000b8ce:	30 0a       	mov	r10,0
8000b8d0:	72 02       	ld.w	r2,r9[0x0]
8000b8d2:	e4 03 09 42 	lsl	r2,r2,r3
8000b8d6:	04 4a       	or	r10,r2
8000b8d8:	10 aa       	st.w	r8++,r10
8000b8da:	13 0a       	ld.w	r10,r9++
8000b8dc:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000b8e0:	16 39       	cp.w	r9,r11
8000b8e2:	cf 73       	brcs	8000b8d0 <__lshift+0x54>
8000b8e4:	91 0a       	st.w	r8[0x0],r10
8000b8e6:	58 0a       	cp.w	r10,0
8000b8e8:	c0 70       	breq	8000b8f6 <__lshift+0x7a>
8000b8ea:	2f f6       	sub	r6,-1
8000b8ec:	c0 58       	rjmp	8000b8f6 <__lshift+0x7a>
8000b8ee:	13 0a       	ld.w	r10,r9++
8000b8f0:	10 aa       	st.w	r8++,r10
8000b8f2:	16 39       	cp.w	r9,r11
8000b8f4:	cf d3       	brcs	8000b8ee <__lshift+0x72>
8000b8f6:	08 9c       	mov	r12,r4
8000b8f8:	20 16       	sub	r6,1
8000b8fa:	0e 9b       	mov	r11,r7
8000b8fc:	8b 46       	st.w	r5[0x10],r6
8000b8fe:	cb 5e       	rcall	8000b668 <_Bfree>
8000b900:	0a 9c       	mov	r12,r5
8000b902:	d8 32       	popm	r0-r7,pc

8000b904 <__multiply>:
8000b904:	d4 31       	pushm	r0-r7,lr
8000b906:	20 2d       	sub	sp,8
8000b908:	76 49       	ld.w	r9,r11[0x10]
8000b90a:	74 48       	ld.w	r8,r10[0x10]
8000b90c:	16 96       	mov	r6,r11
8000b90e:	14 95       	mov	r5,r10
8000b910:	10 39       	cp.w	r9,r8
8000b912:	ec 08 17 50 	movlt	r8,r6
8000b916:	ea 06 17 50 	movlt	r6,r5
8000b91a:	f0 05 17 50 	movlt	r5,r8
8000b91e:	6c 28       	ld.w	r8,r6[0x8]
8000b920:	76 43       	ld.w	r3,r11[0x10]
8000b922:	74 42       	ld.w	r2,r10[0x10]
8000b924:	76 1b       	ld.w	r11,r11[0x4]
8000b926:	e4 03 00 07 	add	r7,r2,r3
8000b92a:	10 37       	cp.w	r7,r8
8000b92c:	f7 bb 09 ff 	subgt	r11,-1
8000b930:	cb 6e       	rcall	8000b69c <_Balloc>
8000b932:	ee c4 ff fb 	sub	r4,r7,-5
8000b936:	f8 c9 ff ec 	sub	r9,r12,-20
8000b93a:	f8 04 00 24 	add	r4,r12,r4<<0x2
8000b93e:	30 0a       	mov	r10,0
8000b940:	12 98       	mov	r8,r9
8000b942:	c0 28       	rjmp	8000b946 <__multiply+0x42>
8000b944:	10 aa       	st.w	r8++,r10
8000b946:	08 38       	cp.w	r8,r4
8000b948:	cf e3       	brcs	8000b944 <__multiply+0x40>
8000b94a:	2f b3       	sub	r3,-5
8000b94c:	2f b2       	sub	r2,-5
8000b94e:	ec 03 00 23 	add	r3,r6,r3<<0x2
8000b952:	ea 02 00 22 	add	r2,r5,r2<<0x2
8000b956:	ec cb ff ec 	sub	r11,r6,-20
8000b95a:	50 12       	stdsp	sp[0x4],r2
8000b95c:	ea ca ff ec 	sub	r10,r5,-20
8000b960:	c4 48       	rjmp	8000b9e8 <__multiply+0xe4>
8000b962:	94 95       	ld.uh	r5,r10[0x2]
8000b964:	58 05       	cp.w	r5,0
8000b966:	c2 00       	breq	8000b9a6 <__multiply+0xa2>
8000b968:	12 98       	mov	r8,r9
8000b96a:	16 96       	mov	r6,r11
8000b96c:	30 0e       	mov	lr,0
8000b96e:	50 09       	stdsp	sp[0x0],r9
8000b970:	0d 02       	ld.w	r2,r6++
8000b972:	e4 00 16 10 	lsr	r0,r2,0x10
8000b976:	70 01       	ld.w	r1,r8[0x0]
8000b978:	70 09       	ld.w	r9,r8[0x0]
8000b97a:	b1 81       	lsr	r1,0x10
8000b97c:	e5 d2 c0 10 	bfextu	r2,r2,0x0,0x10
8000b980:	e0 05 03 41 	mac	r1,r0,r5
8000b984:	ab 32       	mul	r2,r5
8000b986:	e1 d9 c0 10 	bfextu	r0,r9,0x0,0x10
8000b98a:	00 02       	add	r2,r0
8000b98c:	e4 0e 00 0e 	add	lr,r2,lr
8000b990:	b0 1e       	st.h	r8[0x2],lr
8000b992:	b1 8e       	lsr	lr,0x10
8000b994:	1c 01       	add	r1,lr
8000b996:	b0 01       	st.h	r8[0x0],r1
8000b998:	e2 0e 16 10 	lsr	lr,r1,0x10
8000b99c:	2f c8       	sub	r8,-4
8000b99e:	06 36       	cp.w	r6,r3
8000b9a0:	ce 83       	brcs	8000b970 <__multiply+0x6c>
8000b9a2:	40 09       	lddsp	r9,sp[0x0]
8000b9a4:	91 0e       	st.w	r8[0x0],lr
8000b9a6:	94 86       	ld.uh	r6,r10[0x0]
8000b9a8:	58 06       	cp.w	r6,0
8000b9aa:	c1 d0       	breq	8000b9e4 <__multiply+0xe0>
8000b9ac:	72 02       	ld.w	r2,r9[0x0]
8000b9ae:	12 98       	mov	r8,r9
8000b9b0:	16 9e       	mov	lr,r11
8000b9b2:	30 05       	mov	r5,0
8000b9b4:	b0 12       	st.h	r8[0x2],r2
8000b9b6:	1d 01       	ld.w	r1,lr++
8000b9b8:	90 82       	ld.uh	r2,r8[0x0]
8000b9ba:	e1 d1 c0 10 	bfextu	r0,r1,0x0,0x10
8000b9be:	ad 30       	mul	r0,r6
8000b9c0:	e0 02 00 02 	add	r2,r0,r2
8000b9c4:	e4 05 00 05 	add	r5,r2,r5
8000b9c8:	b0 05       	st.h	r8[0x0],r5
8000b9ca:	b1 85       	lsr	r5,0x10
8000b9cc:	b1 81       	lsr	r1,0x10
8000b9ce:	2f c8       	sub	r8,-4
8000b9d0:	ad 31       	mul	r1,r6
8000b9d2:	90 92       	ld.uh	r2,r8[0x2]
8000b9d4:	e2 02 00 02 	add	r2,r1,r2
8000b9d8:	0a 02       	add	r2,r5
8000b9da:	e4 05 16 10 	lsr	r5,r2,0x10
8000b9de:	06 3e       	cp.w	lr,r3
8000b9e0:	ce a3       	brcs	8000b9b4 <__multiply+0xb0>
8000b9e2:	91 02       	st.w	r8[0x0],r2
8000b9e4:	2f ca       	sub	r10,-4
8000b9e6:	2f c9       	sub	r9,-4
8000b9e8:	40 18       	lddsp	r8,sp[0x4]
8000b9ea:	10 3a       	cp.w	r10,r8
8000b9ec:	cb b3       	brcs	8000b962 <__multiply+0x5e>
8000b9ee:	c0 28       	rjmp	8000b9f2 <__multiply+0xee>
8000b9f0:	20 17       	sub	r7,1
8000b9f2:	58 07       	cp.w	r7,0
8000b9f4:	e0 8a 00 05 	brle	8000b9fe <__multiply+0xfa>
8000b9f8:	09 48       	ld.w	r8,--r4
8000b9fa:	58 08       	cp.w	r8,0
8000b9fc:	cf a0       	breq	8000b9f0 <__multiply+0xec>
8000b9fe:	99 47       	st.w	r12[0x10],r7
8000ba00:	2f ed       	sub	sp,-8
8000ba02:	d8 32       	popm	r0-r7,pc

8000ba04 <__i2b>:
8000ba04:	d4 21       	pushm	r4-r7,lr
8000ba06:	16 97       	mov	r7,r11
8000ba08:	30 1b       	mov	r11,1
8000ba0a:	c4 9e       	rcall	8000b69c <_Balloc>
8000ba0c:	30 19       	mov	r9,1
8000ba0e:	99 57       	st.w	r12[0x14],r7
8000ba10:	99 49       	st.w	r12[0x10],r9
8000ba12:	d8 22       	popm	r4-r7,pc

8000ba14 <__multadd>:
8000ba14:	d4 31       	pushm	r0-r7,lr
8000ba16:	30 08       	mov	r8,0
8000ba18:	12 95       	mov	r5,r9
8000ba1a:	16 97       	mov	r7,r11
8000ba1c:	18 96       	mov	r6,r12
8000ba1e:	76 44       	ld.w	r4,r11[0x10]
8000ba20:	f6 c9 ff ec 	sub	r9,r11,-20
8000ba24:	72 0b       	ld.w	r11,r9[0x0]
8000ba26:	f6 0c 16 10 	lsr	r12,r11,0x10
8000ba2a:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000ba2e:	f4 0c 02 4c 	mul	r12,r10,r12
8000ba32:	f4 0b 03 45 	mac	r5,r10,r11
8000ba36:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
8000ba3a:	b1 85       	lsr	r5,0x10
8000ba3c:	18 05       	add	r5,r12
8000ba3e:	ea 0c 15 10 	lsl	r12,r5,0x10
8000ba42:	f8 0b 00 0b 	add	r11,r12,r11
8000ba46:	12 ab       	st.w	r9++,r11
8000ba48:	2f f8       	sub	r8,-1
8000ba4a:	b1 85       	lsr	r5,0x10
8000ba4c:	08 38       	cp.w	r8,r4
8000ba4e:	ce b5       	brlt	8000ba24 <__multadd+0x10>
8000ba50:	58 05       	cp.w	r5,0
8000ba52:	c1 c0       	breq	8000ba8a <__multadd+0x76>
8000ba54:	6e 28       	ld.w	r8,r7[0x8]
8000ba56:	10 34       	cp.w	r4,r8
8000ba58:	c1 35       	brlt	8000ba7e <__multadd+0x6a>
8000ba5a:	6e 1b       	ld.w	r11,r7[0x4]
8000ba5c:	0c 9c       	mov	r12,r6
8000ba5e:	2f fb       	sub	r11,-1
8000ba60:	c1 ee       	rcall	8000b69c <_Balloc>
8000ba62:	6e 4a       	ld.w	r10,r7[0x10]
8000ba64:	ee cb ff f4 	sub	r11,r7,-12
8000ba68:	18 93       	mov	r3,r12
8000ba6a:	2f ea       	sub	r10,-2
8000ba6c:	2f 4c       	sub	r12,-12
8000ba6e:	a3 6a       	lsl	r10,0x2
8000ba70:	fe b0 de 65 	rcall	8000773a <memcpy>
8000ba74:	0e 9b       	mov	r11,r7
8000ba76:	0c 9c       	mov	r12,r6
8000ba78:	fe b0 fd f8 	rcall	8000b668 <_Bfree>
8000ba7c:	06 97       	mov	r7,r3
8000ba7e:	e8 c8 ff ff 	sub	r8,r4,-1
8000ba82:	2f b4       	sub	r4,-5
8000ba84:	8f 48       	st.w	r7[0x10],r8
8000ba86:	ee 04 09 25 	st.w	r7[r4<<0x2],r5
8000ba8a:	0e 9c       	mov	r12,r7
8000ba8c:	d8 32       	popm	r0-r7,pc
8000ba8e:	d7 03       	nop

8000ba90 <__pow5mult>:
8000ba90:	d4 31       	pushm	r0-r7,lr
8000ba92:	14 96       	mov	r6,r10
8000ba94:	18 97       	mov	r7,r12
8000ba96:	16 94       	mov	r4,r11
8000ba98:	f1 da c0 02 	bfextu	r8,r10,0x0,0x2
8000ba9c:	c0 90       	breq	8000baae <__pow5mult+0x1e>
8000ba9e:	20 18       	sub	r8,1
8000baa0:	fe c9 d5 ec 	sub	r9,pc,-10772
8000baa4:	f2 08 03 2a 	ld.w	r10,r9[r8<<0x2]
8000baa8:	30 09       	mov	r9,0
8000baaa:	cb 5f       	rcall	8000ba14 <__multadd>
8000baac:	18 94       	mov	r4,r12
8000baae:	a3 46       	asr	r6,0x2
8000bab0:	c3 40       	breq	8000bb18 <__pow5mult+0x88>
8000bab2:	6e 95       	ld.w	r5,r7[0x24]
8000bab4:	58 05       	cp.w	r5,0
8000bab6:	c0 91       	brne	8000bac8 <__pow5mult+0x38>
8000bab8:	31 0c       	mov	r12,16
8000baba:	fe b0 dc 09 	rcall	800072cc <malloc>
8000babe:	99 35       	st.w	r12[0xc],r5
8000bac0:	8f 9c       	st.w	r7[0x24],r12
8000bac2:	99 15       	st.w	r12[0x4],r5
8000bac4:	99 25       	st.w	r12[0x8],r5
8000bac6:	99 05       	st.w	r12[0x0],r5
8000bac8:	6e 93       	ld.w	r3,r7[0x24]
8000baca:	66 25       	ld.w	r5,r3[0x8]
8000bacc:	58 05       	cp.w	r5,0
8000bace:	c0 c1       	brne	8000bae6 <__pow5mult+0x56>
8000bad0:	e0 6b 02 71 	mov	r11,625
8000bad4:	0e 9c       	mov	r12,r7
8000bad6:	c9 7f       	rcall	8000ba04 <__i2b>
8000bad8:	87 2c       	st.w	r3[0x8],r12
8000bada:	30 08       	mov	r8,0
8000badc:	18 95       	mov	r5,r12
8000bade:	99 08       	st.w	r12[0x0],r8
8000bae0:	c0 38       	rjmp	8000bae6 <__pow5mult+0x56>
8000bae2:	06 9c       	mov	r12,r3
8000bae4:	18 95       	mov	r5,r12
8000bae6:	ed b6 00 00 	bld	r6,0x0
8000baea:	c0 b1       	brne	8000bb00 <__pow5mult+0x70>
8000baec:	08 9b       	mov	r11,r4
8000baee:	0a 9a       	mov	r10,r5
8000baf0:	0e 9c       	mov	r12,r7
8000baf2:	c0 9f       	rcall	8000b904 <__multiply>
8000baf4:	08 9b       	mov	r11,r4
8000baf6:	18 93       	mov	r3,r12
8000baf8:	0e 9c       	mov	r12,r7
8000bafa:	06 94       	mov	r4,r3
8000bafc:	fe b0 fd b6 	rcall	8000b668 <_Bfree>
8000bb00:	a1 56       	asr	r6,0x1
8000bb02:	c0 b0       	breq	8000bb18 <__pow5mult+0x88>
8000bb04:	6a 03       	ld.w	r3,r5[0x0]
8000bb06:	58 03       	cp.w	r3,0
8000bb08:	ce d1       	brne	8000bae2 <__pow5mult+0x52>
8000bb0a:	0a 9a       	mov	r10,r5
8000bb0c:	0a 9b       	mov	r11,r5
8000bb0e:	0e 9c       	mov	r12,r7
8000bb10:	cf ae       	rcall	8000b904 <__multiply>
8000bb12:	8b 0c       	st.w	r5[0x0],r12
8000bb14:	99 03       	st.w	r12[0x0],r3
8000bb16:	ce 7b       	rjmp	8000bae4 <__pow5mult+0x54>
8000bb18:	08 9c       	mov	r12,r4
8000bb1a:	d8 32       	popm	r0-r7,pc

8000bb1c <__isinfd>:
8000bb1c:	14 98       	mov	r8,r10
8000bb1e:	fc 19 7f f0 	movh	r9,0x7ff0
8000bb22:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000bb26:	f0 0b 11 00 	rsub	r11,r8,0
8000bb2a:	f7 e8 10 08 	or	r8,r11,r8
8000bb2e:	f5 e8 13 f8 	or	r8,r10,r8>>0x1f
8000bb32:	f2 08 01 08 	sub	r8,r9,r8
8000bb36:	f0 0c 11 00 	rsub	r12,r8,0
8000bb3a:	f9 e8 10 08 	or	r8,r12,r8
8000bb3e:	f0 0c 14 1f 	asr	r12,r8,0x1f
8000bb42:	2f fc       	sub	r12,-1
8000bb44:	5e fc       	retal	r12

8000bb46 <__isnand>:
8000bb46:	14 98       	mov	r8,r10
8000bb48:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000bb4c:	f0 0c 11 00 	rsub	r12,r8,0
8000bb50:	10 4c       	or	r12,r8
8000bb52:	fc 18 7f f0 	movh	r8,0x7ff0
8000bb56:	f5 ec 13 fc 	or	r12,r10,r12>>0x1f
8000bb5a:	f0 0c 01 0c 	sub	r12,r8,r12
8000bb5e:	bf 9c       	lsr	r12,0x1f
8000bb60:	5e fc       	retal	r12
8000bb62:	d7 03       	nop

8000bb64 <__sclose>:
8000bb64:	d4 01       	pushm	lr
8000bb66:	96 7b       	ld.sh	r11,r11[0xe]
8000bb68:	c7 6c       	rcall	8000bc54 <_close_r>
8000bb6a:	d8 02       	popm	pc

8000bb6c <__sseek>:
8000bb6c:	d4 21       	pushm	r4-r7,lr
8000bb6e:	16 97       	mov	r7,r11
8000bb70:	96 7b       	ld.sh	r11,r11[0xe]
8000bb72:	cf 7c       	rcall	8000bd60 <_lseek_r>
8000bb74:	8e 68       	ld.sh	r8,r7[0xc]
8000bb76:	10 99       	mov	r9,r8
8000bb78:	ad c8       	cbr	r8,0xc
8000bb7a:	ad a9       	sbr	r9,0xc
8000bb7c:	5b fc       	cp.w	r12,-1
8000bb7e:	ef f8 0c 06 	st.heq	r7[0xc],r8
8000bb82:	ef f9 1c 06 	st.hne	r7[0xc],r9
8000bb86:	ef fc 1a 15 	st.wne	r7[0x54],r12
8000bb8a:	d8 22       	popm	r4-r7,pc

8000bb8c <__swrite>:
8000bb8c:	d4 21       	pushm	r4-r7,lr
8000bb8e:	96 68       	ld.sh	r8,r11[0xc]
8000bb90:	16 97       	mov	r7,r11
8000bb92:	14 95       	mov	r5,r10
8000bb94:	12 94       	mov	r4,r9
8000bb96:	e2 18 01 00 	andl	r8,0x100,COH
8000bb9a:	18 96       	mov	r6,r12
8000bb9c:	c0 50       	breq	8000bba6 <__swrite+0x1a>
8000bb9e:	30 29       	mov	r9,2
8000bba0:	30 0a       	mov	r10,0
8000bba2:	96 7b       	ld.sh	r11,r11[0xe]
8000bba4:	cd ec       	rcall	8000bd60 <_lseek_r>
8000bba6:	8e 68       	ld.sh	r8,r7[0xc]
8000bba8:	ad c8       	cbr	r8,0xc
8000bbaa:	08 99       	mov	r9,r4
8000bbac:	0a 9a       	mov	r10,r5
8000bbae:	8e 7b       	ld.sh	r11,r7[0xe]
8000bbb0:	0c 9c       	mov	r12,r6
8000bbb2:	ae 68       	st.h	r7[0xc],r8
8000bbb4:	c1 0c       	rcall	8000bbd4 <_write_r>
8000bbb6:	d8 22       	popm	r4-r7,pc

8000bbb8 <__sread>:
8000bbb8:	d4 21       	pushm	r4-r7,lr
8000bbba:	16 97       	mov	r7,r11
8000bbbc:	96 7b       	ld.sh	r11,r11[0xe]
8000bbbe:	ce 5c       	rcall	8000bd88 <_read_r>
8000bbc0:	c0 65       	brlt	8000bbcc <__sread+0x14>
8000bbc2:	6f 58       	ld.w	r8,r7[0x54]
8000bbc4:	18 08       	add	r8,r12
8000bbc6:	ef 48 00 54 	st.w	r7[84],r8
8000bbca:	d8 22       	popm	r4-r7,pc
8000bbcc:	8e 68       	ld.sh	r8,r7[0xc]
8000bbce:	ad c8       	cbr	r8,0xc
8000bbd0:	ae 68       	st.h	r7[0xc],r8
8000bbd2:	d8 22       	popm	r4-r7,pc

8000bbd4 <_write_r>:
8000bbd4:	d4 21       	pushm	r4-r7,lr
8000bbd6:	16 98       	mov	r8,r11
8000bbd8:	18 97       	mov	r7,r12
8000bbda:	10 9c       	mov	r12,r8
8000bbdc:	30 08       	mov	r8,0
8000bbde:	14 9b       	mov	r11,r10
8000bbe0:	e0 66 63 9c 	mov	r6,25500
8000bbe4:	12 9a       	mov	r10,r9
8000bbe6:	8d 08       	st.w	r6[0x0],r8
8000bbe8:	fe b0 d1 24 	rcall	80005e30 <_write>
8000bbec:	5b fc       	cp.w	r12,-1
8000bbee:	c0 51       	brne	8000bbf8 <_write_r+0x24>
8000bbf0:	6c 08       	ld.w	r8,r6[0x0]
8000bbf2:	58 08       	cp.w	r8,0
8000bbf4:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000bbf8:	d8 22       	popm	r4-r7,pc
8000bbfa:	d7 03       	nop

8000bbfc <_calloc_r>:
8000bbfc:	d4 21       	pushm	r4-r7,lr
8000bbfe:	f4 0b 02 4b 	mul	r11,r10,r11
8000bc02:	fe b0 db 6d 	rcall	800072dc <_malloc_r>
8000bc06:	18 97       	mov	r7,r12
8000bc08:	c2 30       	breq	8000bc4e <_calloc_r+0x52>
8000bc0a:	f8 fa ff fc 	ld.w	r10,r12[-4]
8000bc0e:	e0 1a ff fc 	andl	r10,0xfffc
8000bc12:	20 4a       	sub	r10,4
8000bc14:	e0 4a 00 24 	cp.w	r10,36
8000bc18:	e0 8b 00 18 	brhi	8000bc48 <_calloc_r+0x4c>
8000bc1c:	18 98       	mov	r8,r12
8000bc1e:	59 3a       	cp.w	r10,19
8000bc20:	e0 88 00 0f 	brls	8000bc3e <_calloc_r+0x42>
8000bc24:	30 09       	mov	r9,0
8000bc26:	10 a9       	st.w	r8++,r9
8000bc28:	10 a9       	st.w	r8++,r9
8000bc2a:	59 ba       	cp.w	r10,27
8000bc2c:	e0 88 00 09 	brls	8000bc3e <_calloc_r+0x42>
8000bc30:	10 a9       	st.w	r8++,r9
8000bc32:	10 a9       	st.w	r8++,r9
8000bc34:	e0 4a 00 24 	cp.w	r10,36
8000bc38:	c0 31       	brne	8000bc3e <_calloc_r+0x42>
8000bc3a:	10 a9       	st.w	r8++,r9
8000bc3c:	10 a9       	st.w	r8++,r9
8000bc3e:	30 09       	mov	r9,0
8000bc40:	10 a9       	st.w	r8++,r9
8000bc42:	91 19       	st.w	r8[0x4],r9
8000bc44:	91 09       	st.w	r8[0x0],r9
8000bc46:	c0 48       	rjmp	8000bc4e <_calloc_r+0x52>
8000bc48:	30 0b       	mov	r11,0
8000bc4a:	fe b0 de 1c 	rcall	80007882 <memset>
8000bc4e:	0e 9c       	mov	r12,r7
8000bc50:	d8 22       	popm	r4-r7,pc
8000bc52:	d7 03       	nop

8000bc54 <_close_r>:
8000bc54:	d4 21       	pushm	r4-r7,lr
8000bc56:	30 08       	mov	r8,0
8000bc58:	18 97       	mov	r7,r12
8000bc5a:	e0 66 63 9c 	mov	r6,25500
8000bc5e:	16 9c       	mov	r12,r11
8000bc60:	8d 08       	st.w	r6[0x0],r8
8000bc62:	fe b0 df c1 	rcall	80007be4 <_close>
8000bc66:	5b fc       	cp.w	r12,-1
8000bc68:	c0 51       	brne	8000bc72 <_close_r+0x1e>
8000bc6a:	6c 08       	ld.w	r8,r6[0x0]
8000bc6c:	58 08       	cp.w	r8,0
8000bc6e:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000bc72:	d8 22       	popm	r4-r7,pc

8000bc74 <_fclose_r>:
8000bc74:	d4 21       	pushm	r4-r7,lr
8000bc76:	18 96       	mov	r6,r12
8000bc78:	16 97       	mov	r7,r11
8000bc7a:	58 0b       	cp.w	r11,0
8000bc7c:	c0 31       	brne	8000bc82 <_fclose_r+0xe>
8000bc7e:	16 95       	mov	r5,r11
8000bc80:	c5 38       	rjmp	8000bd26 <_fclose_r+0xb2>
8000bc82:	fe b0 f8 b5 	rcall	8000adec <__sfp_lock_acquire>
8000bc86:	58 06       	cp.w	r6,0
8000bc88:	c0 70       	breq	8000bc96 <_fclose_r+0x22>
8000bc8a:	6c 68       	ld.w	r8,r6[0x18]
8000bc8c:	58 08       	cp.w	r8,0
8000bc8e:	c0 41       	brne	8000bc96 <_fclose_r+0x22>
8000bc90:	0c 9c       	mov	r12,r6
8000bc92:	fe b0 f8 ff 	rcall	8000ae90 <__sinit>
8000bc96:	fe c8 d8 86 	sub	r8,pc,-10106
8000bc9a:	10 37       	cp.w	r7,r8
8000bc9c:	c0 31       	brne	8000bca2 <_fclose_r+0x2e>
8000bc9e:	6c 07       	ld.w	r7,r6[0x0]
8000bca0:	c0 c8       	rjmp	8000bcb8 <_fclose_r+0x44>
8000bca2:	fe c8 d8 72 	sub	r8,pc,-10126
8000bca6:	10 37       	cp.w	r7,r8
8000bca8:	c0 31       	brne	8000bcae <_fclose_r+0x3a>
8000bcaa:	6c 17       	ld.w	r7,r6[0x4]
8000bcac:	c0 68       	rjmp	8000bcb8 <_fclose_r+0x44>
8000bcae:	fe c8 d8 5e 	sub	r8,pc,-10146
8000bcb2:	10 37       	cp.w	r7,r8
8000bcb4:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000bcb8:	8e 69       	ld.sh	r9,r7[0xc]
8000bcba:	30 08       	mov	r8,0
8000bcbc:	f0 09 19 00 	cp.h	r9,r8
8000bcc0:	c0 51       	brne	8000bcca <_fclose_r+0x56>
8000bcc2:	fe b0 f8 96 	rcall	8000adee <__sfp_lock_release>
8000bcc6:	30 05       	mov	r5,0
8000bcc8:	c2 f8       	rjmp	8000bd26 <_fclose_r+0xb2>
8000bcca:	0e 9b       	mov	r11,r7
8000bccc:	0c 9c       	mov	r12,r6
8000bcce:	fe b0 f8 09 	rcall	8000ace0 <_fflush_r>
8000bcd2:	6e c8       	ld.w	r8,r7[0x30]
8000bcd4:	18 95       	mov	r5,r12
8000bcd6:	58 08       	cp.w	r8,0
8000bcd8:	c0 60       	breq	8000bce4 <_fclose_r+0x70>
8000bcda:	6e 8b       	ld.w	r11,r7[0x20]
8000bcdc:	0c 9c       	mov	r12,r6
8000bcde:	5d 18       	icall	r8
8000bce0:	f9 b5 05 ff 	movlt	r5,-1
8000bce4:	8e 68       	ld.sh	r8,r7[0xc]
8000bce6:	ed b8 00 07 	bld	r8,0x7
8000bcea:	c0 51       	brne	8000bcf4 <_fclose_r+0x80>
8000bcec:	6e 4b       	ld.w	r11,r7[0x10]
8000bcee:	0c 9c       	mov	r12,r6
8000bcf0:	fe b0 f9 6a 	rcall	8000afc4 <_free_r>
8000bcf4:	6e db       	ld.w	r11,r7[0x34]
8000bcf6:	58 0b       	cp.w	r11,0
8000bcf8:	c0 a0       	breq	8000bd0c <_fclose_r+0x98>
8000bcfa:	ee c8 ff bc 	sub	r8,r7,-68
8000bcfe:	10 3b       	cp.w	r11,r8
8000bd00:	c0 40       	breq	8000bd08 <_fclose_r+0x94>
8000bd02:	0c 9c       	mov	r12,r6
8000bd04:	fe b0 f9 60 	rcall	8000afc4 <_free_r>
8000bd08:	30 08       	mov	r8,0
8000bd0a:	8f d8       	st.w	r7[0x34],r8
8000bd0c:	6f 2b       	ld.w	r11,r7[0x48]
8000bd0e:	58 0b       	cp.w	r11,0
8000bd10:	c0 70       	breq	8000bd1e <_fclose_r+0xaa>
8000bd12:	0c 9c       	mov	r12,r6
8000bd14:	fe b0 f9 58 	rcall	8000afc4 <_free_r>
8000bd18:	30 08       	mov	r8,0
8000bd1a:	ef 48 00 48 	st.w	r7[72],r8
8000bd1e:	30 08       	mov	r8,0
8000bd20:	ae 68       	st.h	r7[0xc],r8
8000bd22:	fe b0 f8 66 	rcall	8000adee <__sfp_lock_release>
8000bd26:	0a 9c       	mov	r12,r5
8000bd28:	d8 22       	popm	r4-r7,pc
8000bd2a:	d7 03       	nop

8000bd2c <fclose>:
8000bd2c:	d4 01       	pushm	lr
8000bd2e:	e0 68 0a 3c 	mov	r8,2620
8000bd32:	18 9b       	mov	r11,r12
8000bd34:	70 0c       	ld.w	r12,r8[0x0]
8000bd36:	c9 ff       	rcall	8000bc74 <_fclose_r>
8000bd38:	d8 02       	popm	pc
8000bd3a:	d7 03       	nop

8000bd3c <_fstat_r>:
8000bd3c:	d4 21       	pushm	r4-r7,lr
8000bd3e:	16 98       	mov	r8,r11
8000bd40:	18 97       	mov	r7,r12
8000bd42:	10 9c       	mov	r12,r8
8000bd44:	30 08       	mov	r8,0
8000bd46:	e0 66 63 9c 	mov	r6,25500
8000bd4a:	14 9b       	mov	r11,r10
8000bd4c:	8d 08       	st.w	r6[0x0],r8
8000bd4e:	fe b0 df 73 	rcall	80007c34 <_fstat>
8000bd52:	5b fc       	cp.w	r12,-1
8000bd54:	c0 51       	brne	8000bd5e <_fstat_r+0x22>
8000bd56:	6c 08       	ld.w	r8,r6[0x0]
8000bd58:	58 08       	cp.w	r8,0
8000bd5a:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000bd5e:	d8 22       	popm	r4-r7,pc

8000bd60 <_lseek_r>:
8000bd60:	d4 21       	pushm	r4-r7,lr
8000bd62:	16 98       	mov	r8,r11
8000bd64:	18 97       	mov	r7,r12
8000bd66:	10 9c       	mov	r12,r8
8000bd68:	30 08       	mov	r8,0
8000bd6a:	14 9b       	mov	r11,r10
8000bd6c:	e0 66 63 9c 	mov	r6,25500
8000bd70:	12 9a       	mov	r10,r9
8000bd72:	8d 08       	st.w	r6[0x0],r8
8000bd74:	fe b0 df 42 	rcall	80007bf8 <_lseek>
8000bd78:	5b fc       	cp.w	r12,-1
8000bd7a:	c0 51       	brne	8000bd84 <_lseek_r+0x24>
8000bd7c:	6c 08       	ld.w	r8,r6[0x0]
8000bd7e:	58 08       	cp.w	r8,0
8000bd80:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000bd84:	d8 22       	popm	r4-r7,pc
8000bd86:	d7 03       	nop

8000bd88 <_read_r>:
8000bd88:	d4 21       	pushm	r4-r7,lr
8000bd8a:	16 98       	mov	r8,r11
8000bd8c:	18 97       	mov	r7,r12
8000bd8e:	10 9c       	mov	r12,r8
8000bd90:	30 08       	mov	r8,0
8000bd92:	14 9b       	mov	r11,r10
8000bd94:	e0 66 63 9c 	mov	r6,25500
8000bd98:	12 9a       	mov	r10,r9
8000bd9a:	8d 08       	st.w	r6[0x0],r8
8000bd9c:	fe b0 d0 2a 	rcall	80005df0 <_read>
8000bda0:	5b fc       	cp.w	r12,-1
8000bda2:	c0 51       	brne	8000bdac <_read_r+0x24>
8000bda4:	6c 08       	ld.w	r8,r6[0x0]
8000bda6:	58 08       	cp.w	r8,0
8000bda8:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000bdac:	d8 22       	popm	r4-r7,pc
8000bdae:	d7 03       	nop

8000bdb0 <__avr32_f64_mul>:
8000bdb0:	f5 eb 10 1c 	or	r12,r10,r11<<0x1
8000bdb4:	e0 80 00 dc 	breq	8000bf6c <__avr32_f64_mul_op1_zero>
8000bdb8:	d4 21       	pushm	r4-r7,lr
8000bdba:	f7 e9 20 0e 	eor	lr,r11,r9
8000bdbe:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000bdc2:	30 15       	mov	r5,1
8000bdc4:	c4 30       	breq	8000be4a <__avr32_f64_mul_op1_subnormal>
8000bdc6:	ab 6b       	lsl	r11,0xa
8000bdc8:	f7 ea 13 6b 	or	r11,r11,r10>>0x16
8000bdcc:	ab 6a       	lsl	r10,0xa
8000bdce:	f7 d5 d3 c2 	bfins	r11,r5,0x1e,0x2
8000bdd2:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000bdd6:	c5 c0       	breq	8000be8e <__avr32_f64_mul_op2_subnormal>
8000bdd8:	a1 78       	lsl	r8,0x1
8000bdda:	5c f9       	rol	r9
8000bddc:	f3 d5 d2 ab 	bfins	r9,r5,0x15,0xb
8000bde0:	e0 47 07 ff 	cp.w	r7,2047
8000bde4:	c7 70       	breq	8000bed2 <__avr32_f64_mul_op_nan_or_inf>
8000bde6:	e0 46 07 ff 	cp.w	r6,2047
8000bdea:	c7 40       	breq	8000bed2 <__avr32_f64_mul_op_nan_or_inf>
8000bdec:	ee 06 00 0c 	add	r12,r7,r6
8000bdf0:	e0 2c 03 fe 	sub	r12,1022
8000bdf4:	f6 08 06 44 	mulu.d	r4,r11,r8
8000bdf8:	f4 09 07 44 	macu.d	r4,r10,r9
8000bdfc:	f4 08 06 46 	mulu.d	r6,r10,r8
8000be00:	f6 09 06 4a 	mulu.d	r10,r11,r9
8000be04:	08 07       	add	r7,r4
8000be06:	f4 05 00 4a 	adc	r10,r10,r5
8000be0a:	5c 0b       	acr	r11
8000be0c:	ed bb 00 14 	bld	r11,0x14
8000be10:	c0 50       	breq	8000be1a <__avr32_f64_mul+0x6a>
8000be12:	a1 77       	lsl	r7,0x1
8000be14:	5c fa       	rol	r10
8000be16:	5c fb       	rol	r11
8000be18:	20 1c       	sub	r12,1
8000be1a:	58 0c       	cp.w	r12,0
8000be1c:	e0 8a 00 6f 	brle	8000befa <__avr32_f64_mul_res_subnormal>
8000be20:	e0 4c 07 ff 	cp.w	r12,2047
8000be24:	e0 84 00 9c 	brge	8000bf5c <__avr32_f64_mul_res_inf>
8000be28:	f7 dc d2 8b 	bfins	r11,r12,0x14,0xb
8000be2c:	ed ea 11 f6 	or	r6,r6,r10<<0x1f
8000be30:	ef e6 12 17 	or	r7,r7,r6>>0x1
8000be34:	ee 17 80 00 	eorh	r7,0x8000
8000be38:	f1 b7 04 20 	satu	r7,0x1
8000be3c:	0e 0a       	add	r10,r7
8000be3e:	5c 0b       	acr	r11
8000be40:	ed be 00 1f 	bld	lr,0x1f
8000be44:	ef bb 00 1f 	bst	r11,0x1f
8000be48:	d8 22       	popm	r4-r7,pc

8000be4a <__avr32_f64_mul_op1_subnormal>:
8000be4a:	e4 1b 00 0f 	andh	r11,0xf
8000be4e:	f4 0c 12 00 	clz	r12,r10
8000be52:	f6 06 12 00 	clz	r6,r11
8000be56:	f7 bc 03 e1 	sublo	r12,-31
8000be5a:	f8 06 17 30 	movlo	r6,r12
8000be5e:	f7 b6 02 01 	subhs	r6,1
8000be62:	e0 46 00 20 	cp.w	r6,32
8000be66:	c0 d4       	brge	8000be80 <__avr32_f64_mul_op1_subnormal+0x36>
8000be68:	ec 0c 11 20 	rsub	r12,r6,32
8000be6c:	f6 06 09 4b 	lsl	r11,r11,r6
8000be70:	f4 0c 0a 4c 	lsr	r12,r10,r12
8000be74:	18 4b       	or	r11,r12
8000be76:	f4 06 09 4a 	lsl	r10,r10,r6
8000be7a:	20 b6       	sub	r6,11
8000be7c:	0c 17       	sub	r7,r6
8000be7e:	ca ab       	rjmp	8000bdd2 <__avr32_f64_mul+0x22>
8000be80:	f4 06 09 4b 	lsl	r11,r10,r6
8000be84:	c6 40       	breq	8000bf4c <__avr32_f64_mul_res_zero>
8000be86:	30 0a       	mov	r10,0
8000be88:	20 b6       	sub	r6,11
8000be8a:	0c 17       	sub	r7,r6
8000be8c:	ca 3b       	rjmp	8000bdd2 <__avr32_f64_mul+0x22>

8000be8e <__avr32_f64_mul_op2_subnormal>:
8000be8e:	e4 19 00 0f 	andh	r9,0xf
8000be92:	f0 0c 12 00 	clz	r12,r8
8000be96:	f2 05 12 00 	clz	r5,r9
8000be9a:	f7 bc 03 ea 	sublo	r12,-22
8000be9e:	f8 05 17 30 	movlo	r5,r12
8000bea2:	f7 b5 02 0a 	subhs	r5,10
8000bea6:	e0 45 00 20 	cp.w	r5,32
8000beaa:	c0 d4       	brge	8000bec4 <__avr32_f64_mul_op2_subnormal+0x36>
8000beac:	ea 0c 11 20 	rsub	r12,r5,32
8000beb0:	f2 05 09 49 	lsl	r9,r9,r5
8000beb4:	f0 0c 0a 4c 	lsr	r12,r8,r12
8000beb8:	18 49       	or	r9,r12
8000beba:	f0 05 09 48 	lsl	r8,r8,r5
8000bebe:	20 25       	sub	r5,2
8000bec0:	0a 16       	sub	r6,r5
8000bec2:	c8 fb       	rjmp	8000bde0 <__avr32_f64_mul+0x30>
8000bec4:	f0 05 09 49 	lsl	r9,r8,r5
8000bec8:	c4 20       	breq	8000bf4c <__avr32_f64_mul_res_zero>
8000beca:	30 08       	mov	r8,0
8000becc:	20 25       	sub	r5,2
8000bece:	0a 16       	sub	r6,r5
8000bed0:	c8 8b       	rjmp	8000bde0 <__avr32_f64_mul+0x30>

8000bed2 <__avr32_f64_mul_op_nan_or_inf>:
8000bed2:	e4 19 00 0f 	andh	r9,0xf
8000bed6:	e4 1b 00 0f 	andh	r11,0xf
8000beda:	14 4b       	or	r11,r10
8000bedc:	10 49       	or	r9,r8
8000bede:	e0 47 07 ff 	cp.w	r7,2047
8000bee2:	c0 91       	brne	8000bef4 <__avr32_f64_mul_op1_not_naninf>
8000bee4:	58 0b       	cp.w	r11,0
8000bee6:	c3 81       	brne	8000bf56 <__avr32_f64_mul_res_nan>
8000bee8:	e0 46 07 ff 	cp.w	r6,2047
8000beec:	c3 81       	brne	8000bf5c <__avr32_f64_mul_res_inf>
8000beee:	58 09       	cp.w	r9,0
8000bef0:	c3 60       	breq	8000bf5c <__avr32_f64_mul_res_inf>
8000bef2:	c3 28       	rjmp	8000bf56 <__avr32_f64_mul_res_nan>

8000bef4 <__avr32_f64_mul_op1_not_naninf>:
8000bef4:	58 09       	cp.w	r9,0
8000bef6:	c3 30       	breq	8000bf5c <__avr32_f64_mul_res_inf>
8000bef8:	c2 f8       	rjmp	8000bf56 <__avr32_f64_mul_res_nan>

8000befa <__avr32_f64_mul_res_subnormal>:
8000befa:	5c 3c       	neg	r12
8000befc:	2f fc       	sub	r12,-1
8000befe:	f1 bc 04 c0 	satu	r12,0x6
8000bf02:	e0 4c 00 20 	cp.w	r12,32
8000bf06:	c1 14       	brge	8000bf28 <__avr32_f64_mul_res_subnormal+0x2e>
8000bf08:	f8 08 11 20 	rsub	r8,r12,32
8000bf0c:	0e 46       	or	r6,r7
8000bf0e:	ee 0c 0a 47 	lsr	r7,r7,r12
8000bf12:	f4 08 09 49 	lsl	r9,r10,r8
8000bf16:	12 47       	or	r7,r9
8000bf18:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000bf1c:	f6 08 09 49 	lsl	r9,r11,r8
8000bf20:	12 4a       	or	r10,r9
8000bf22:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000bf26:	c8 3b       	rjmp	8000be2c <__avr32_f64_mul+0x7c>
8000bf28:	f8 08 11 20 	rsub	r8,r12,32
8000bf2c:	f9 b9 00 00 	moveq	r9,0
8000bf30:	c0 30       	breq	8000bf36 <__avr32_f64_mul_res_subnormal+0x3c>
8000bf32:	f6 08 09 49 	lsl	r9,r11,r8
8000bf36:	0e 46       	or	r6,r7
8000bf38:	ed ea 10 16 	or	r6,r6,r10<<0x1
8000bf3c:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000bf40:	f3 ea 10 07 	or	r7,r9,r10
8000bf44:	f6 0c 0a 4a 	lsr	r10,r11,r12
8000bf48:	30 0b       	mov	r11,0
8000bf4a:	c7 1b       	rjmp	8000be2c <__avr32_f64_mul+0x7c>

8000bf4c <__avr32_f64_mul_res_zero>:
8000bf4c:	1c 9b       	mov	r11,lr
8000bf4e:	e6 1b 80 00 	andh	r11,0x8000,COH
8000bf52:	30 0a       	mov	r10,0
8000bf54:	d8 22       	popm	r4-r7,pc

8000bf56 <__avr32_f64_mul_res_nan>:
8000bf56:	3f fb       	mov	r11,-1
8000bf58:	3f fa       	mov	r10,-1
8000bf5a:	d8 22       	popm	r4-r7,pc

8000bf5c <__avr32_f64_mul_res_inf>:
8000bf5c:	f0 6b 00 00 	mov	r11,-1048576
8000bf60:	ed be 00 1f 	bld	lr,0x1f
8000bf64:	ef bb 00 1f 	bst	r11,0x1f
8000bf68:	30 0a       	mov	r10,0
8000bf6a:	d8 22       	popm	r4-r7,pc

8000bf6c <__avr32_f64_mul_op1_zero>:
8000bf6c:	f7 e9 20 0b 	eor	r11,r11,r9
8000bf70:	e6 1b 80 00 	andh	r11,0x8000,COH
8000bf74:	f9 d9 c2 8b 	bfextu	r12,r9,0x14,0xb
8000bf78:	e0 4c 07 ff 	cp.w	r12,2047
8000bf7c:	5e 1c       	retne	r12
8000bf7e:	3f fa       	mov	r10,-1
8000bf80:	3f fb       	mov	r11,-1
8000bf82:	5e fc       	retal	r12

8000bf84 <__avr32_f64_sub_from_add>:
8000bf84:	ee 19 80 00 	eorh	r9,0x8000

8000bf88 <__avr32_f64_sub>:
8000bf88:	f7 e9 20 0c 	eor	r12,r11,r9
8000bf8c:	e0 86 00 ca 	brmi	8000c120 <__avr32_f64_add_from_sub>
8000bf90:	eb cd 40 e0 	pushm	r5-r7,lr
8000bf94:	16 9c       	mov	r12,r11
8000bf96:	e6 1c 80 00 	andh	r12,0x8000,COH
8000bf9a:	bf db       	cbr	r11,0x1f
8000bf9c:	bf d9       	cbr	r9,0x1f
8000bf9e:	10 3a       	cp.w	r10,r8
8000bfa0:	f2 0b 13 00 	cpc	r11,r9
8000bfa4:	c0 92       	brcc	8000bfb6 <__avr32_f64_sub+0x2e>
8000bfa6:	16 97       	mov	r7,r11
8000bfa8:	12 9b       	mov	r11,r9
8000bfaa:	0e 99       	mov	r9,r7
8000bfac:	14 97       	mov	r7,r10
8000bfae:	10 9a       	mov	r10,r8
8000bfb0:	0e 98       	mov	r8,r7
8000bfb2:	ee 1c 80 00 	eorh	r12,0x8000
8000bfb6:	f6 07 16 14 	lsr	r7,r11,0x14
8000bfba:	ab 7b       	lsl	r11,0xb
8000bfbc:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000bfc0:	ab 7a       	lsl	r10,0xb
8000bfc2:	bf bb       	sbr	r11,0x1f
8000bfc4:	f2 06 16 14 	lsr	r6,r9,0x14
8000bfc8:	c4 40       	breq	8000c050 <__avr32_f64_sub_opL_subnormal>
8000bfca:	ab 79       	lsl	r9,0xb
8000bfcc:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000bfd0:	ab 78       	lsl	r8,0xb
8000bfd2:	bf b9       	sbr	r9,0x1f

8000bfd4 <__avr32_f64_sub_opL_subnormal_done>:
8000bfd4:	e0 47 07 ff 	cp.w	r7,2047
8000bfd8:	c4 f0       	breq	8000c076 <__avr32_f64_sub_opH_nan_or_inf>
8000bfda:	0e 26       	rsub	r6,r7
8000bfdc:	c1 20       	breq	8000c000 <__avr32_f64_sub_shift_done>
8000bfde:	ec 05 11 20 	rsub	r5,r6,32
8000bfe2:	e0 46 00 20 	cp.w	r6,32
8000bfe6:	c7 c2       	brcc	8000c0de <__avr32_f64_sub_longshift>
8000bfe8:	f0 05 09 4e 	lsl	lr,r8,r5
8000bfec:	f2 05 09 45 	lsl	r5,r9,r5
8000bff0:	f0 06 0a 48 	lsr	r8,r8,r6
8000bff4:	f2 06 0a 49 	lsr	r9,r9,r6
8000bff8:	0a 48       	or	r8,r5
8000bffa:	58 0e       	cp.w	lr,0
8000bffc:	5f 1e       	srne	lr
8000bffe:	1c 48       	or	r8,lr

8000c000 <__avr32_f64_sub_shift_done>:
8000c000:	10 1a       	sub	r10,r8
8000c002:	f6 09 01 4b 	sbc	r11,r11,r9
8000c006:	f6 06 12 00 	clz	r6,r11
8000c00a:	c0 e0       	breq	8000c026 <__avr32_f64_sub_longnormalize_done>
8000c00c:	c7 83       	brcs	8000c0fc <__avr32_f64_sub_longnormalize>
8000c00e:	ec 0e 11 20 	rsub	lr,r6,32
8000c012:	f6 06 09 4b 	lsl	r11,r11,r6
8000c016:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000c01a:	1c 4b       	or	r11,lr
8000c01c:	f4 06 09 4a 	lsl	r10,r10,r6
8000c020:	0c 17       	sub	r7,r6
8000c022:	e0 8a 00 39 	brle	8000c094 <__avr32_f64_sub_subnormal_result>

8000c026 <__avr32_f64_sub_longnormalize_done>:
8000c026:	f4 09 15 15 	lsl	r9,r10,0x15
8000c02a:	ab 9a       	lsr	r10,0xb
8000c02c:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000c030:	ab 9b       	lsr	r11,0xb
8000c032:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000c036:	18 4b       	or	r11,r12

8000c038 <__avr32_f64_sub_round>:
8000c038:	fc 17 80 00 	movh	r7,0x8000
8000c03c:	ed ba 00 00 	bld	r10,0x0
8000c040:	f7 b7 01 ff 	subne	r7,-1
8000c044:	0e 39       	cp.w	r9,r7
8000c046:	5f 29       	srhs	r9
8000c048:	12 0a       	add	r10,r9
8000c04a:	5c 0b       	acr	r11
8000c04c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c050 <__avr32_f64_sub_opL_subnormal>:
8000c050:	ab 79       	lsl	r9,0xb
8000c052:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000c056:	ab 78       	lsl	r8,0xb
8000c058:	f3 e8 10 0e 	or	lr,r9,r8
8000c05c:	f9 b6 01 01 	movne	r6,1
8000c060:	ee 0e 11 00 	rsub	lr,r7,0
8000c064:	f9 b7 00 01 	moveq	r7,1
8000c068:	ef bb 00 1f 	bst	r11,0x1f
8000c06c:	f7 ea 10 0e 	or	lr,r11,r10
8000c070:	f9 b7 00 00 	moveq	r7,0
8000c074:	cb 0b       	rjmp	8000bfd4 <__avr32_f64_sub_opL_subnormal_done>

8000c076 <__avr32_f64_sub_opH_nan_or_inf>:
8000c076:	bf db       	cbr	r11,0x1f
8000c078:	f7 ea 10 0e 	or	lr,r11,r10
8000c07c:	c0 81       	brne	8000c08c <__avr32_f64_sub_return_nan>
8000c07e:	e0 46 07 ff 	cp.w	r6,2047
8000c082:	c0 50       	breq	8000c08c <__avr32_f64_sub_return_nan>
8000c084:	f9 e7 11 4b 	or	r11,r12,r7<<0x14
8000c088:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c08c <__avr32_f64_sub_return_nan>:
8000c08c:	3f fa       	mov	r10,-1
8000c08e:	3f fb       	mov	r11,-1
8000c090:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c094 <__avr32_f64_sub_subnormal_result>:
8000c094:	5c 37       	neg	r7
8000c096:	2f f7       	sub	r7,-1
8000c098:	f1 b7 04 c0 	satu	r7,0x6
8000c09c:	e0 47 00 20 	cp.w	r7,32
8000c0a0:	c1 14       	brge	8000c0c2 <__avr32_f64_sub_subnormal_result+0x2e>
8000c0a2:	ee 08 11 20 	rsub	r8,r7,32
8000c0a6:	f4 08 09 49 	lsl	r9,r10,r8
8000c0aa:	5f 16       	srne	r6
8000c0ac:	f4 07 0a 4a 	lsr	r10,r10,r7
8000c0b0:	0c 4a       	or	r10,r6
8000c0b2:	f6 08 09 49 	lsl	r9,r11,r8
8000c0b6:	f5 e9 10 0a 	or	r10,r10,r9
8000c0ba:	f4 07 0a 4b 	lsr	r11,r10,r7
8000c0be:	30 07       	mov	r7,0
8000c0c0:	cb 3b       	rjmp	8000c026 <__avr32_f64_sub_longnormalize_done>
8000c0c2:	ee 08 11 40 	rsub	r8,r7,64
8000c0c6:	f6 08 09 49 	lsl	r9,r11,r8
8000c0ca:	14 49       	or	r9,r10
8000c0cc:	5f 16       	srne	r6
8000c0ce:	f6 07 0a 4a 	lsr	r10,r11,r7
8000c0d2:	0c 4a       	or	r10,r6
8000c0d4:	30 0b       	mov	r11,0
8000c0d6:	30 07       	mov	r7,0
8000c0d8:	ca 7b       	rjmp	8000c026 <__avr32_f64_sub_longnormalize_done>
8000c0da:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c0de <__avr32_f64_sub_longshift>:
8000c0de:	f1 b6 04 c0 	satu	r6,0x6
8000c0e2:	f0 0e 17 00 	moveq	lr,r8
8000c0e6:	c0 40       	breq	8000c0ee <__avr32_f64_sub_longshift+0x10>
8000c0e8:	f2 05 09 4e 	lsl	lr,r9,r5
8000c0ec:	10 4e       	or	lr,r8
8000c0ee:	f2 06 0a 48 	lsr	r8,r9,r6
8000c0f2:	30 09       	mov	r9,0
8000c0f4:	58 0e       	cp.w	lr,0
8000c0f6:	5f 1e       	srne	lr
8000c0f8:	1c 48       	or	r8,lr
8000c0fa:	c8 3b       	rjmp	8000c000 <__avr32_f64_sub_shift_done>

8000c0fc <__avr32_f64_sub_longnormalize>:
8000c0fc:	f4 06 12 00 	clz	r6,r10
8000c100:	f9 b7 03 00 	movlo	r7,0
8000c104:	f9 b6 03 00 	movlo	r6,0
8000c108:	f9 bc 03 00 	movlo	r12,0
8000c10c:	f7 b6 02 e0 	subhs	r6,-32
8000c110:	f4 06 09 4b 	lsl	r11,r10,r6
8000c114:	30 0a       	mov	r10,0
8000c116:	0c 17       	sub	r7,r6
8000c118:	fe 9a ff be 	brle	8000c094 <__avr32_f64_sub_subnormal_result>
8000c11c:	c8 5b       	rjmp	8000c026 <__avr32_f64_sub_longnormalize_done>
8000c11e:	d7 03       	nop

8000c120 <__avr32_f64_add_from_sub>:
8000c120:	ee 19 80 00 	eorh	r9,0x8000

8000c124 <__avr32_f64_add>:
8000c124:	f7 e9 20 0c 	eor	r12,r11,r9
8000c128:	fe 96 ff 2e 	brmi	8000bf84 <__avr32_f64_sub_from_add>
8000c12c:	eb cd 40 e0 	pushm	r5-r7,lr
8000c130:	16 9c       	mov	r12,r11
8000c132:	e6 1c 80 00 	andh	r12,0x8000,COH
8000c136:	bf db       	cbr	r11,0x1f
8000c138:	bf d9       	cbr	r9,0x1f
8000c13a:	12 3b       	cp.w	r11,r9
8000c13c:	c0 72       	brcc	8000c14a <__avr32_f64_add+0x26>
8000c13e:	16 97       	mov	r7,r11
8000c140:	12 9b       	mov	r11,r9
8000c142:	0e 99       	mov	r9,r7
8000c144:	14 97       	mov	r7,r10
8000c146:	10 9a       	mov	r10,r8
8000c148:	0e 98       	mov	r8,r7
8000c14a:	30 0e       	mov	lr,0
8000c14c:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000c150:	f7 db c0 14 	bfextu	r11,r11,0x0,0x14
8000c154:	b5 ab       	sbr	r11,0x14
8000c156:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000c15a:	c6 20       	breq	8000c21e <__avr32_f64_add_op2_subnormal>
8000c15c:	f3 d9 c0 14 	bfextu	r9,r9,0x0,0x14
8000c160:	b5 a9       	sbr	r9,0x14
8000c162:	e0 47 07 ff 	cp.w	r7,2047
8000c166:	c2 80       	breq	8000c1b6 <__avr32_f64_add_opH_nan_or_inf>
8000c168:	0e 26       	rsub	r6,r7
8000c16a:	c1 20       	breq	8000c18e <__avr32_f64_add_shift_done>
8000c16c:	e0 46 00 36 	cp.w	r6,54
8000c170:	c1 52       	brcc	8000c19a <__avr32_f64_add_res_of_done>
8000c172:	ec 05 11 20 	rsub	r5,r6,32
8000c176:	e0 46 00 20 	cp.w	r6,32
8000c17a:	c3 52       	brcc	8000c1e4 <__avr32_f64_add_longshift>
8000c17c:	f0 05 09 4e 	lsl	lr,r8,r5
8000c180:	f2 05 09 45 	lsl	r5,r9,r5
8000c184:	f0 06 0a 48 	lsr	r8,r8,r6
8000c188:	f2 06 0a 49 	lsr	r9,r9,r6
8000c18c:	0a 48       	or	r8,r5

8000c18e <__avr32_f64_add_shift_done>:
8000c18e:	10 0a       	add	r10,r8
8000c190:	f6 09 00 4b 	adc	r11,r11,r9
8000c194:	ed bb 00 15 	bld	r11,0x15
8000c198:	c3 40       	breq	8000c200 <__avr32_f64_add_res_of>

8000c19a <__avr32_f64_add_res_of_done>:
8000c19a:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000c19e:	18 4b       	or	r11,r12

8000c1a0 <__avr32_f64_add_round>:
8000c1a0:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
8000c1a4:	18 4e       	or	lr,r12
8000c1a6:	ee 1e 80 00 	eorh	lr,0x8000
8000c1aa:	f1 be 04 20 	satu	lr,0x1
8000c1ae:	1c 0a       	add	r10,lr
8000c1b0:	5c 0b       	acr	r11
8000c1b2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c1b6 <__avr32_f64_add_opH_nan_or_inf>:
8000c1b6:	b5 cb       	cbr	r11,0x14
8000c1b8:	f7 ea 10 0e 	or	lr,r11,r10
8000c1bc:	c1 01       	brne	8000c1dc <__avr32_f64_add_return_nan>
8000c1be:	e0 46 07 ff 	cp.w	r6,2047
8000c1c2:	c0 30       	breq	8000c1c8 <__avr32_f64_add_opL_nan_or_inf>
8000c1c4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c1c8 <__avr32_f64_add_opL_nan_or_inf>:
8000c1c8:	b5 c9       	cbr	r9,0x14
8000c1ca:	f3 e8 10 0e 	or	lr,r9,r8
8000c1ce:	c0 71       	brne	8000c1dc <__avr32_f64_add_return_nan>
8000c1d0:	30 0a       	mov	r10,0
8000c1d2:	fc 1b 7f f0 	movh	r11,0x7ff0
8000c1d6:	18 4b       	or	r11,r12
8000c1d8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c1dc <__avr32_f64_add_return_nan>:
8000c1dc:	3f fa       	mov	r10,-1
8000c1de:	3f fb       	mov	r11,-1
8000c1e0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c1e4 <__avr32_f64_add_longshift>:
8000c1e4:	f1 b6 04 c0 	satu	r6,0x6
8000c1e8:	f0 0e 17 00 	moveq	lr,r8
8000c1ec:	c0 60       	breq	8000c1f8 <__avr32_f64_add_longshift+0x14>
8000c1ee:	f2 05 09 4e 	lsl	lr,r9,r5
8000c1f2:	58 08       	cp.w	r8,0
8000c1f4:	5f 18       	srne	r8
8000c1f6:	10 4e       	or	lr,r8
8000c1f8:	f2 06 0a 48 	lsr	r8,r9,r6
8000c1fc:	30 09       	mov	r9,0
8000c1fe:	cc 8b       	rjmp	8000c18e <__avr32_f64_add_shift_done>

8000c200 <__avr32_f64_add_res_of>:
8000c200:	fd ee 10 1e 	or	lr,lr,lr<<0x1
8000c204:	a1 9b       	lsr	r11,0x1
8000c206:	5d 0a       	ror	r10
8000c208:	5d 0e       	ror	lr
8000c20a:	2f f7       	sub	r7,-1
8000c20c:	e0 47 07 ff 	cp.w	r7,2047
8000c210:	f9 ba 00 00 	moveq	r10,0
8000c214:	f9 bb 00 00 	moveq	r11,0
8000c218:	f9 be 00 00 	moveq	lr,0
8000c21c:	cb fb       	rjmp	8000c19a <__avr32_f64_add_res_of_done>

8000c21e <__avr32_f64_add_op2_subnormal>:
8000c21e:	30 16       	mov	r6,1
8000c220:	58 07       	cp.w	r7,0
8000c222:	ca 01       	brne	8000c162 <__avr32_f64_add+0x3e>
8000c224:	b5 cb       	cbr	r11,0x14
8000c226:	10 0a       	add	r10,r8
8000c228:	f6 09 00 4b 	adc	r11,r11,r9
8000c22c:	18 4b       	or	r11,r12
8000c22e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000c232:	d7 03       	nop

8000c234 <__avr32_f64_to_u32>:
8000c234:	58 0b       	cp.w	r11,0
8000c236:	5e 6d       	retmi	0

8000c238 <__avr32_f64_to_s32>:
8000c238:	f6 0c 15 01 	lsl	r12,r11,0x1
8000c23c:	b5 9c       	lsr	r12,0x15
8000c23e:	e0 2c 03 ff 	sub	r12,1023
8000c242:	5e 3d       	retlo	0
8000c244:	f8 0c 11 1f 	rsub	r12,r12,31
8000c248:	16 99       	mov	r9,r11
8000c24a:	ab 7b       	lsl	r11,0xb
8000c24c:	bf bb       	sbr	r11,0x1f
8000c24e:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000c252:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000c256:	a1 79       	lsl	r9,0x1
8000c258:	5e 2b       	reths	r11
8000c25a:	5c 3b       	neg	r11
8000c25c:	5e fb       	retal	r11

8000c25e <__avr32_u32_to_f64>:
8000c25e:	f8 cb 00 00 	sub	r11,r12,0
8000c262:	30 0c       	mov	r12,0
8000c264:	c0 38       	rjmp	8000c26a <__avr32_s32_to_f64+0x4>

8000c266 <__avr32_s32_to_f64>:
8000c266:	18 9b       	mov	r11,r12
8000c268:	5c 4b       	abs	r11
8000c26a:	30 0a       	mov	r10,0
8000c26c:	5e 0b       	reteq	r11
8000c26e:	d4 01       	pushm	lr
8000c270:	e0 69 04 1e 	mov	r9,1054
8000c274:	f6 08 12 00 	clz	r8,r11
8000c278:	c1 70       	breq	8000c2a6 <__avr32_s32_to_f64+0x40>
8000c27a:	c0 c3       	brcs	8000c292 <__avr32_s32_to_f64+0x2c>
8000c27c:	f0 0e 11 20 	rsub	lr,r8,32
8000c280:	f6 08 09 4b 	lsl	r11,r11,r8
8000c284:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000c288:	1c 4b       	or	r11,lr
8000c28a:	f4 08 09 4a 	lsl	r10,r10,r8
8000c28e:	10 19       	sub	r9,r8
8000c290:	c0 b8       	rjmp	8000c2a6 <__avr32_s32_to_f64+0x40>
8000c292:	f4 08 12 00 	clz	r8,r10
8000c296:	f9 b8 03 00 	movlo	r8,0
8000c29a:	f7 b8 02 e0 	subhs	r8,-32
8000c29e:	f4 08 09 4b 	lsl	r11,r10,r8
8000c2a2:	30 0a       	mov	r10,0
8000c2a4:	10 19       	sub	r9,r8
8000c2a6:	58 09       	cp.w	r9,0
8000c2a8:	e0 89 00 30 	brgt	8000c308 <__avr32_s32_to_f64+0xa2>
8000c2ac:	5c 39       	neg	r9
8000c2ae:	2f f9       	sub	r9,-1
8000c2b0:	e0 49 00 36 	cp.w	r9,54
8000c2b4:	c0 43       	brcs	8000c2bc <__avr32_s32_to_f64+0x56>
8000c2b6:	30 0b       	mov	r11,0
8000c2b8:	30 0a       	mov	r10,0
8000c2ba:	c2 68       	rjmp	8000c306 <__avr32_s32_to_f64+0xa0>
8000c2bc:	2f 69       	sub	r9,-10
8000c2be:	f2 08 11 20 	rsub	r8,r9,32
8000c2c2:	e0 49 00 20 	cp.w	r9,32
8000c2c6:	c0 b2       	brcc	8000c2dc <__avr32_s32_to_f64+0x76>
8000c2c8:	f4 08 09 4e 	lsl	lr,r10,r8
8000c2cc:	f6 08 09 48 	lsl	r8,r11,r8
8000c2d0:	f4 09 0a 4a 	lsr	r10,r10,r9
8000c2d4:	f6 09 0a 4b 	lsr	r11,r11,r9
8000c2d8:	10 4b       	or	r11,r8
8000c2da:	c0 88       	rjmp	8000c2ea <__avr32_s32_to_f64+0x84>
8000c2dc:	f6 08 09 4e 	lsl	lr,r11,r8
8000c2e0:	14 4e       	or	lr,r10
8000c2e2:	16 9a       	mov	r10,r11
8000c2e4:	30 0b       	mov	r11,0
8000c2e6:	f4 09 0a 4a 	lsr	r10,r10,r9
8000c2ea:	ed ba 00 00 	bld	r10,0x0
8000c2ee:	c0 92       	brcc	8000c300 <__avr32_s32_to_f64+0x9a>
8000c2f0:	1c 7e       	tst	lr,lr
8000c2f2:	c0 41       	brne	8000c2fa <__avr32_s32_to_f64+0x94>
8000c2f4:	ed ba 00 01 	bld	r10,0x1
8000c2f8:	c0 42       	brcc	8000c300 <__avr32_s32_to_f64+0x9a>
8000c2fa:	2f fa       	sub	r10,-1
8000c2fc:	f7 bb 02 ff 	subhs	r11,-1
8000c300:	5c fc       	rol	r12
8000c302:	5d 0b       	ror	r11
8000c304:	5d 0a       	ror	r10
8000c306:	d8 02       	popm	pc
8000c308:	e0 68 03 ff 	mov	r8,1023
8000c30c:	ed ba 00 0b 	bld	r10,0xb
8000c310:	f7 b8 00 ff 	subeq	r8,-1
8000c314:	10 0a       	add	r10,r8
8000c316:	5c 0b       	acr	r11
8000c318:	f7 b9 03 fe 	sublo	r9,-2
8000c31c:	e0 49 07 ff 	cp.w	r9,2047
8000c320:	c0 55       	brlt	8000c32a <__avr32_s32_to_f64+0xc4>
8000c322:	30 0a       	mov	r10,0
8000c324:	fc 1b ff e0 	movh	r11,0xffe0
8000c328:	c0 c8       	rjmp	8000c340 <__floatsidf_return_op1>
8000c32a:	ed bb 00 1f 	bld	r11,0x1f
8000c32e:	f7 b9 01 01 	subne	r9,1
8000c332:	ab 9a       	lsr	r10,0xb
8000c334:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000c338:	a1 7b       	lsl	r11,0x1
8000c33a:	ab 9b       	lsr	r11,0xb
8000c33c:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

8000c340 <__floatsidf_return_op1>:
8000c340:	a1 7c       	lsl	r12,0x1
8000c342:	5d 0b       	ror	r11
8000c344:	d8 02       	popm	pc

8000c346 <__avr32_f64_cmp_eq>:
8000c346:	10 3a       	cp.w	r10,r8
8000c348:	f2 0b 13 00 	cpc	r11,r9
8000c34c:	c0 80       	breq	8000c35c <__avr32_f64_cmp_eq+0x16>
8000c34e:	a1 7b       	lsl	r11,0x1
8000c350:	a1 79       	lsl	r9,0x1
8000c352:	14 4b       	or	r11,r10
8000c354:	12 4b       	or	r11,r9
8000c356:	10 4b       	or	r11,r8
8000c358:	5e 0f       	reteq	1
8000c35a:	5e fd       	retal	0
8000c35c:	a1 7b       	lsl	r11,0x1
8000c35e:	fc 1c ff e0 	movh	r12,0xffe0
8000c362:	58 0a       	cp.w	r10,0
8000c364:	f8 0b 13 00 	cpc	r11,r12
8000c368:	5e 8f       	retls	1
8000c36a:	5e fd       	retal	0

8000c36c <__avr32_f64_cmp_ge>:
8000c36c:	1a de       	st.w	--sp,lr
8000c36e:	1a d7       	st.w	--sp,r7
8000c370:	a1 7b       	lsl	r11,0x1
8000c372:	5f 3c       	srlo	r12
8000c374:	a1 79       	lsl	r9,0x1
8000c376:	5f 37       	srlo	r7
8000c378:	5c fc       	rol	r12
8000c37a:	fc 1e ff e0 	movh	lr,0xffe0
8000c37e:	58 0a       	cp.w	r10,0
8000c380:	fc 0b 13 00 	cpc	r11,lr
8000c384:	e0 8b 00 1d 	brhi	8000c3be <__avr32_f64_cmp_ge+0x52>
8000c388:	58 08       	cp.w	r8,0
8000c38a:	fc 09 13 00 	cpc	r9,lr
8000c38e:	e0 8b 00 18 	brhi	8000c3be <__avr32_f64_cmp_ge+0x52>
8000c392:	58 0b       	cp.w	r11,0
8000c394:	f5 ba 00 00 	subfeq	r10,0
8000c398:	c1 50       	breq	8000c3c2 <__avr32_f64_cmp_ge+0x56>
8000c39a:	1b 07       	ld.w	r7,sp++
8000c39c:	1b 0e       	ld.w	lr,sp++
8000c39e:	58 3c       	cp.w	r12,3
8000c3a0:	c0 a0       	breq	8000c3b4 <__avr32_f64_cmp_ge+0x48>
8000c3a2:	58 1c       	cp.w	r12,1
8000c3a4:	c0 33       	brcs	8000c3aa <__avr32_f64_cmp_ge+0x3e>
8000c3a6:	5e 0f       	reteq	1
8000c3a8:	5e 1d       	retne	0
8000c3aa:	10 3a       	cp.w	r10,r8
8000c3ac:	f2 0b 13 00 	cpc	r11,r9
8000c3b0:	5e 2f       	reths	1
8000c3b2:	5e 3d       	retlo	0
8000c3b4:	14 38       	cp.w	r8,r10
8000c3b6:	f6 09 13 00 	cpc	r9,r11
8000c3ba:	5e 2f       	reths	1
8000c3bc:	5e 3d       	retlo	0
8000c3be:	1b 07       	ld.w	r7,sp++
8000c3c0:	d8 0a       	popm	pc,r12=0
8000c3c2:	58 17       	cp.w	r7,1
8000c3c4:	5f 0c       	sreq	r12
8000c3c6:	58 09       	cp.w	r9,0
8000c3c8:	f5 b8 00 00 	subfeq	r8,0
8000c3cc:	1b 07       	ld.w	r7,sp++
8000c3ce:	1b 0e       	ld.w	lr,sp++
8000c3d0:	5e 0f       	reteq	1
8000c3d2:	5e fc       	retal	r12

8000c3d4 <__avr32_f64_cmp_lt>:
8000c3d4:	1a de       	st.w	--sp,lr
8000c3d6:	1a d7       	st.w	--sp,r7
8000c3d8:	a1 7b       	lsl	r11,0x1
8000c3da:	5f 3c       	srlo	r12
8000c3dc:	a1 79       	lsl	r9,0x1
8000c3de:	5f 37       	srlo	r7
8000c3e0:	5c fc       	rol	r12
8000c3e2:	fc 1e ff e0 	movh	lr,0xffe0
8000c3e6:	58 0a       	cp.w	r10,0
8000c3e8:	fc 0b 13 00 	cpc	r11,lr
8000c3ec:	e0 8b 00 1d 	brhi	8000c426 <__avr32_f64_cmp_lt+0x52>
8000c3f0:	58 08       	cp.w	r8,0
8000c3f2:	fc 09 13 00 	cpc	r9,lr
8000c3f6:	e0 8b 00 18 	brhi	8000c426 <__avr32_f64_cmp_lt+0x52>
8000c3fa:	58 0b       	cp.w	r11,0
8000c3fc:	f5 ba 00 00 	subfeq	r10,0
8000c400:	c1 50       	breq	8000c42a <__avr32_f64_cmp_lt+0x56>
8000c402:	1b 07       	ld.w	r7,sp++
8000c404:	1b 0e       	ld.w	lr,sp++
8000c406:	58 3c       	cp.w	r12,3
8000c408:	c0 a0       	breq	8000c41c <__avr32_f64_cmp_lt+0x48>
8000c40a:	58 1c       	cp.w	r12,1
8000c40c:	c0 33       	brcs	8000c412 <__avr32_f64_cmp_lt+0x3e>
8000c40e:	5e 0d       	reteq	0
8000c410:	5e 1f       	retne	1
8000c412:	10 3a       	cp.w	r10,r8
8000c414:	f2 0b 13 00 	cpc	r11,r9
8000c418:	5e 2d       	reths	0
8000c41a:	5e 3f       	retlo	1
8000c41c:	14 38       	cp.w	r8,r10
8000c41e:	f6 09 13 00 	cpc	r9,r11
8000c422:	5e 2d       	reths	0
8000c424:	5e 3f       	retlo	1
8000c426:	1b 07       	ld.w	r7,sp++
8000c428:	d8 0a       	popm	pc,r12=0
8000c42a:	58 17       	cp.w	r7,1
8000c42c:	5f 1c       	srne	r12
8000c42e:	58 09       	cp.w	r9,0
8000c430:	f5 b8 00 00 	subfeq	r8,0
8000c434:	1b 07       	ld.w	r7,sp++
8000c436:	1b 0e       	ld.w	lr,sp++
8000c438:	5e 0d       	reteq	0
8000c43a:	5e fc       	retal	r12

8000c43c <__avr32_f64_div>:
8000c43c:	eb cd 40 ff 	pushm	r0-r7,lr
8000c440:	f7 e9 20 0e 	eor	lr,r11,r9
8000c444:	f6 07 16 14 	lsr	r7,r11,0x14
8000c448:	a9 7b       	lsl	r11,0x9
8000c44a:	f7 ea 13 7b 	or	r11,r11,r10>>0x17
8000c44e:	a9 7a       	lsl	r10,0x9
8000c450:	bd bb       	sbr	r11,0x1d
8000c452:	e4 1b 3f ff 	andh	r11,0x3fff
8000c456:	ab d7       	cbr	r7,0xb
8000c458:	e0 80 00 cc 	breq	8000c5f0 <__avr32_f64_div_round_subnormal+0x54>
8000c45c:	e0 47 07 ff 	cp.w	r7,2047
8000c460:	e0 84 00 b5 	brge	8000c5ca <__avr32_f64_div_round_subnormal+0x2e>
8000c464:	f2 06 16 14 	lsr	r6,r9,0x14
8000c468:	a9 79       	lsl	r9,0x9
8000c46a:	f3 e8 13 79 	or	r9,r9,r8>>0x17
8000c46e:	a9 78       	lsl	r8,0x9
8000c470:	bd b9       	sbr	r9,0x1d
8000c472:	e4 19 3f ff 	andh	r9,0x3fff
8000c476:	ab d6       	cbr	r6,0xb
8000c478:	e0 80 00 e2 	breq	8000c63c <__avr32_f64_div_round_subnormal+0xa0>
8000c47c:	e0 46 07 ff 	cp.w	r6,2047
8000c480:	e0 84 00 b2 	brge	8000c5e4 <__avr32_f64_div_round_subnormal+0x48>
8000c484:	0c 17       	sub	r7,r6
8000c486:	fe 37 fc 01 	sub	r7,-1023
8000c48a:	fc 1c 80 00 	movh	r12,0x8000
8000c48e:	f8 03 16 01 	lsr	r3,r12,0x1
8000c492:	e9 d9 c3 62 	bfextu	r4,r9,0x1b,0x2
8000c496:	5c d4       	com	r4
8000c498:	e7 d4 d3 82 	bfins	r3,r4,0x1c,0x2
8000c49c:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c4a0:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000c4a4:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c4a8:	ea 03 15 02 	lsl	r3,r5,0x2
8000c4ac:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c4b0:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000c4b4:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c4b8:	ea 03 15 02 	lsl	r3,r5,0x2
8000c4bc:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c4c0:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000c4c4:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c4c8:	ea 03 15 02 	lsl	r3,r5,0x2
8000c4cc:	e6 08 06 40 	mulu.d	r0,r3,r8
8000c4d0:	e4 09 07 40 	macu.d	r0,r2,r9
8000c4d4:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c4d8:	02 04       	add	r4,r1
8000c4da:	5c 05       	acr	r5
8000c4dc:	a3 65       	lsl	r5,0x2
8000c4de:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000c4e2:	a3 64       	lsl	r4,0x2
8000c4e4:	5c 34       	neg	r4
8000c4e6:	f8 05 01 45 	sbc	r5,r12,r5
8000c4ea:	e6 04 06 40 	mulu.d	r0,r3,r4
8000c4ee:	e4 05 07 40 	macu.d	r0,r2,r5
8000c4f2:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c4f6:	02 04       	add	r4,r1
8000c4f8:	5c 05       	acr	r5
8000c4fa:	ea 03 15 02 	lsl	r3,r5,0x2
8000c4fe:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000c502:	e8 02 15 02 	lsl	r2,r4,0x2
8000c506:	e6 08 06 40 	mulu.d	r0,r3,r8
8000c50a:	e4 09 07 40 	macu.d	r0,r2,r9
8000c50e:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c512:	02 04       	add	r4,r1
8000c514:	5c 05       	acr	r5
8000c516:	a3 65       	lsl	r5,0x2
8000c518:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000c51c:	a3 64       	lsl	r4,0x2
8000c51e:	5c 34       	neg	r4
8000c520:	f8 05 01 45 	sbc	r5,r12,r5
8000c524:	e6 04 06 40 	mulu.d	r0,r3,r4
8000c528:	e4 05 07 40 	macu.d	r0,r2,r5
8000c52c:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c530:	02 04       	add	r4,r1
8000c532:	5c 05       	acr	r5
8000c534:	ea 03 15 02 	lsl	r3,r5,0x2
8000c538:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000c53c:	e8 02 15 02 	lsl	r2,r4,0x2
8000c540:	e6 0a 06 40 	mulu.d	r0,r3,r10
8000c544:	e4 0b 07 40 	macu.d	r0,r2,r11
8000c548:	e6 0b 06 42 	mulu.d	r2,r3,r11
8000c54c:	02 02       	add	r2,r1
8000c54e:	5c 03       	acr	r3
8000c550:	ed b3 00 1c 	bld	r3,0x1c
8000c554:	c0 90       	breq	8000c566 <__avr32_f64_div+0x12a>
8000c556:	a1 72       	lsl	r2,0x1
8000c558:	5c f3       	rol	r3
8000c55a:	20 17       	sub	r7,1
8000c55c:	a3 9a       	lsr	r10,0x3
8000c55e:	f5 eb 11 da 	or	r10,r10,r11<<0x1d
8000c562:	a3 9b       	lsr	r11,0x3
8000c564:	c0 58       	rjmp	8000c56e <__avr32_f64_div+0x132>
8000c566:	a5 8a       	lsr	r10,0x4
8000c568:	f5 eb 11 ca 	or	r10,r10,r11<<0x1c
8000c56c:	a5 8b       	lsr	r11,0x4
8000c56e:	58 07       	cp.w	r7,0
8000c570:	e0 8a 00 8b 	brle	8000c686 <__avr32_f64_div_res_subnormal>
8000c574:	e0 12 ff 00 	andl	r2,0xff00
8000c578:	e8 12 00 80 	orl	r2,0x80
8000c57c:	e6 08 06 40 	mulu.d	r0,r3,r8
8000c580:	e4 09 07 40 	macu.d	r0,r2,r9
8000c584:	e4 08 06 44 	mulu.d	r4,r2,r8
8000c588:	e6 09 06 48 	mulu.d	r8,r3,r9
8000c58c:	00 05       	add	r5,r0
8000c58e:	f0 01 00 48 	adc	r8,r8,r1
8000c592:	5c 09       	acr	r9
8000c594:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000c598:	58 04       	cp.w	r4,0
8000c59a:	5c 25       	cpc	r5

8000c59c <__avr32_f64_div_round_subnormal>:
8000c59c:	f4 08 13 00 	cpc	r8,r10
8000c5a0:	f6 09 13 00 	cpc	r9,r11
8000c5a4:	5f 36       	srlo	r6
8000c5a6:	f8 06 17 00 	moveq	r6,r12
8000c5aa:	e4 0a 16 08 	lsr	r10,r2,0x8
8000c5ae:	f5 e3 11 8a 	or	r10,r10,r3<<0x18
8000c5b2:	e6 0b 16 08 	lsr	r11,r3,0x8
8000c5b6:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000c5ba:	ed be 00 1f 	bld	lr,0x1f
8000c5be:	ef bb 00 1f 	bst	r11,0x1f
8000c5c2:	0c 0a       	add	r10,r6
8000c5c4:	5c 0b       	acr	r11
8000c5c6:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c5ca:	e4 1b 00 0f 	andh	r11,0xf
8000c5ce:	14 4b       	or	r11,r10
8000c5d0:	e0 81 00 a7 	brne	8000c71e <__avr32_f64_div_res_subnormal+0x98>
8000c5d4:	f2 06 16 14 	lsr	r6,r9,0x14
8000c5d8:	ab d6       	cbr	r6,0xb
8000c5da:	e0 46 07 ff 	cp.w	r6,2047
8000c5de:	e0 81 00 a4 	brne	8000c726 <__avr32_f64_div_res_subnormal+0xa0>
8000c5e2:	c9 e8       	rjmp	8000c71e <__avr32_f64_div_res_subnormal+0x98>
8000c5e4:	e4 19 00 0f 	andh	r9,0xf
8000c5e8:	10 49       	or	r9,r8
8000c5ea:	e0 81 00 9a 	brne	8000c71e <__avr32_f64_div_res_subnormal+0x98>
8000c5ee:	c9 28       	rjmp	8000c712 <__avr32_f64_div_res_subnormal+0x8c>
8000c5f0:	a3 7b       	lsl	r11,0x3
8000c5f2:	f7 ea 13 db 	or	r11,r11,r10>>0x1d
8000c5f6:	a3 7a       	lsl	r10,0x3
8000c5f8:	f5 eb 10 04 	or	r4,r10,r11
8000c5fc:	e0 80 00 a0 	breq	8000c73c <__avr32_f64_div_op1_zero>
8000c600:	f6 04 12 00 	clz	r4,r11
8000c604:	c1 70       	breq	8000c632 <__avr32_f64_div_round_subnormal+0x96>
8000c606:	c0 c3       	brcs	8000c61e <__avr32_f64_div_round_subnormal+0x82>
8000c608:	e8 05 11 20 	rsub	r5,r4,32
8000c60c:	f6 04 09 4b 	lsl	r11,r11,r4
8000c610:	f4 05 0a 45 	lsr	r5,r10,r5
8000c614:	0a 4b       	or	r11,r5
8000c616:	f4 04 09 4a 	lsl	r10,r10,r4
8000c61a:	08 17       	sub	r7,r4
8000c61c:	c0 b8       	rjmp	8000c632 <__avr32_f64_div_round_subnormal+0x96>
8000c61e:	f4 04 12 00 	clz	r4,r10
8000c622:	f9 b4 03 00 	movlo	r4,0
8000c626:	f7 b4 02 e0 	subhs	r4,-32
8000c62a:	f4 04 09 4b 	lsl	r11,r10,r4
8000c62e:	30 0a       	mov	r10,0
8000c630:	08 17       	sub	r7,r4
8000c632:	a3 8a       	lsr	r10,0x2
8000c634:	f5 eb 11 ea 	or	r10,r10,r11<<0x1e
8000c638:	a3 8b       	lsr	r11,0x2
8000c63a:	c1 1b       	rjmp	8000c45c <__avr32_f64_div+0x20>
8000c63c:	a3 79       	lsl	r9,0x3
8000c63e:	f3 e8 13 d9 	or	r9,r9,r8>>0x1d
8000c642:	a3 78       	lsl	r8,0x3
8000c644:	f3 e8 10 04 	or	r4,r9,r8
8000c648:	c6 f0       	breq	8000c726 <__avr32_f64_div_res_subnormal+0xa0>
8000c64a:	f2 04 12 00 	clz	r4,r9
8000c64e:	c1 70       	breq	8000c67c <__avr32_f64_div_round_subnormal+0xe0>
8000c650:	c0 c3       	brcs	8000c668 <__avr32_f64_div_round_subnormal+0xcc>
8000c652:	e8 05 11 20 	rsub	r5,r4,32
8000c656:	f2 04 09 49 	lsl	r9,r9,r4
8000c65a:	f0 05 0a 45 	lsr	r5,r8,r5
8000c65e:	0a 49       	or	r9,r5
8000c660:	f0 04 09 48 	lsl	r8,r8,r4
8000c664:	08 16       	sub	r6,r4
8000c666:	c0 b8       	rjmp	8000c67c <__avr32_f64_div_round_subnormal+0xe0>
8000c668:	f0 04 12 00 	clz	r4,r8
8000c66c:	f9 b4 03 00 	movlo	r4,0
8000c670:	f7 b4 02 e0 	subhs	r4,-32
8000c674:	f0 04 09 49 	lsl	r9,r8,r4
8000c678:	30 08       	mov	r8,0
8000c67a:	08 16       	sub	r6,r4
8000c67c:	a3 88       	lsr	r8,0x2
8000c67e:	f1 e9 11 e8 	or	r8,r8,r9<<0x1e
8000c682:	a3 89       	lsr	r9,0x2
8000c684:	cf ca       	rjmp	8000c47c <__avr32_f64_div+0x40>

8000c686 <__avr32_f64_div_res_subnormal>:
8000c686:	5c 37       	neg	r7
8000c688:	2f f7       	sub	r7,-1
8000c68a:	f1 b7 04 c0 	satu	r7,0x6
8000c68e:	e0 47 00 20 	cp.w	r7,32
8000c692:	c1 54       	brge	8000c6bc <__avr32_f64_div_res_subnormal+0x36>
8000c694:	ee 06 11 20 	rsub	r6,r7,32
8000c698:	e4 07 0a 42 	lsr	r2,r2,r7
8000c69c:	e6 06 09 4c 	lsl	r12,r3,r6
8000c6a0:	18 42       	or	r2,r12
8000c6a2:	e6 07 0a 43 	lsr	r3,r3,r7
8000c6a6:	f4 06 09 41 	lsl	r1,r10,r6
8000c6aa:	f4 07 0a 4a 	lsr	r10,r10,r7
8000c6ae:	f6 06 09 4c 	lsl	r12,r11,r6
8000c6b2:	18 4a       	or	r10,r12
8000c6b4:	f6 07 0a 4b 	lsr	r11,r11,r7
8000c6b8:	30 00       	mov	r0,0
8000c6ba:	c1 58       	rjmp	8000c6e4 <__avr32_f64_div_res_subnormal+0x5e>
8000c6bc:	ee 06 11 20 	rsub	r6,r7,32
8000c6c0:	f9 b0 00 00 	moveq	r0,0
8000c6c4:	f9 bc 00 00 	moveq	r12,0
8000c6c8:	c0 50       	breq	8000c6d2 <__avr32_f64_div_res_subnormal+0x4c>
8000c6ca:	f4 06 09 40 	lsl	r0,r10,r6
8000c6ce:	f6 06 09 4c 	lsl	r12,r11,r6
8000c6d2:	e6 07 0a 42 	lsr	r2,r3,r7
8000c6d6:	30 03       	mov	r3,0
8000c6d8:	f4 07 0a 41 	lsr	r1,r10,r7
8000c6dc:	18 41       	or	r1,r12
8000c6de:	f6 07 0a 4a 	lsr	r10,r11,r7
8000c6e2:	30 0b       	mov	r11,0
8000c6e4:	e0 12 ff 00 	andl	r2,0xff00
8000c6e8:	e8 12 00 80 	orl	r2,0x80
8000c6ec:	e6 08 06 46 	mulu.d	r6,r3,r8
8000c6f0:	e4 09 07 46 	macu.d	r6,r2,r9
8000c6f4:	e4 08 06 44 	mulu.d	r4,r2,r8
8000c6f8:	e6 09 06 48 	mulu.d	r8,r3,r9
8000c6fc:	0c 05       	add	r5,r6
8000c6fe:	f0 07 00 48 	adc	r8,r8,r7
8000c702:	5c 09       	acr	r9
8000c704:	30 07       	mov	r7,0
8000c706:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000c70a:	00 34       	cp.w	r4,r0
8000c70c:	e2 05 13 00 	cpc	r5,r1
8000c710:	c4 6b       	rjmp	8000c59c <__avr32_f64_div_round_subnormal>
8000c712:	1c 9b       	mov	r11,lr
8000c714:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c718:	30 0a       	mov	r10,0
8000c71a:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c71e:	3f fb       	mov	r11,-1
8000c720:	30 0a       	mov	r10,0
8000c722:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c726:	f5 eb 10 04 	or	r4,r10,r11
8000c72a:	c0 90       	breq	8000c73c <__avr32_f64_div_op1_zero>
8000c72c:	1c 9b       	mov	r11,lr
8000c72e:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c732:	ea 1b 7f f0 	orh	r11,0x7ff0
8000c736:	30 0a       	mov	r10,0
8000c738:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc

8000c73c <__avr32_f64_div_op1_zero>:
8000c73c:	f1 e9 10 15 	or	r5,r8,r9<<0x1
8000c740:	ce f0       	breq	8000c71e <__avr32_f64_div_res_subnormal+0x98>
8000c742:	e9 d9 c2 8b 	bfextu	r4,r9,0x14,0xb
8000c746:	e0 44 07 ff 	cp.w	r4,2047
8000c74a:	ce 41       	brne	8000c712 <__avr32_f64_div_res_subnormal+0x8c>
8000c74c:	f1 e9 10 c5 	or	r5,r8,r9<<0xc
8000c750:	ce 10       	breq	8000c712 <__avr32_f64_div_res_subnormal+0x8c>
8000c752:	ce 6b       	rjmp	8000c71e <__avr32_f64_div_res_subnormal+0x98>

8000c754 <__avr32_udiv64>:
8000c754:	d4 31       	pushm	r0-r7,lr
8000c756:	1a 97       	mov	r7,sp
8000c758:	20 3d       	sub	sp,12
8000c75a:	10 9c       	mov	r12,r8
8000c75c:	12 9e       	mov	lr,r9
8000c75e:	14 93       	mov	r3,r10
8000c760:	58 09       	cp.w	r9,0
8000c762:	e0 81 00 bd 	brne	8000c8dc <__avr32_udiv64+0x188>
8000c766:	16 38       	cp.w	r8,r11
8000c768:	e0 88 00 40 	brls	8000c7e8 <__avr32_udiv64+0x94>
8000c76c:	f0 08 12 00 	clz	r8,r8
8000c770:	c0 d0       	breq	8000c78a <__avr32_udiv64+0x36>
8000c772:	f6 08 09 4b 	lsl	r11,r11,r8
8000c776:	f0 09 11 20 	rsub	r9,r8,32
8000c77a:	f8 08 09 4c 	lsl	r12,r12,r8
8000c77e:	f4 09 0a 49 	lsr	r9,r10,r9
8000c782:	f4 08 09 43 	lsl	r3,r10,r8
8000c786:	f3 eb 10 0b 	or	r11,r9,r11
8000c78a:	f8 0e 16 10 	lsr	lr,r12,0x10
8000c78e:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000c792:	f6 0e 0d 00 	divu	r0,r11,lr
8000c796:	e6 0b 16 10 	lsr	r11,r3,0x10
8000c79a:	00 99       	mov	r9,r0
8000c79c:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c7a0:	e0 0a 02 48 	mul	r8,r0,r10
8000c7a4:	10 3b       	cp.w	r11,r8
8000c7a6:	c0 a2       	brcc	8000c7ba <__avr32_udiv64+0x66>
8000c7a8:	20 19       	sub	r9,1
8000c7aa:	18 0b       	add	r11,r12
8000c7ac:	18 3b       	cp.w	r11,r12
8000c7ae:	c0 63       	brcs	8000c7ba <__avr32_udiv64+0x66>
8000c7b0:	10 3b       	cp.w	r11,r8
8000c7b2:	f7 b9 03 01 	sublo	r9,1
8000c7b6:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c7ba:	f6 08 01 01 	sub	r1,r11,r8
8000c7be:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000c7c2:	e2 0e 0d 00 	divu	r0,r1,lr
8000c7c6:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000c7ca:	00 98       	mov	r8,r0
8000c7cc:	e0 0a 02 4a 	mul	r10,r0,r10
8000c7d0:	14 33       	cp.w	r3,r10
8000c7d2:	c0 82       	brcc	8000c7e2 <__avr32_udiv64+0x8e>
8000c7d4:	20 18       	sub	r8,1
8000c7d6:	18 03       	add	r3,r12
8000c7d8:	18 33       	cp.w	r3,r12
8000c7da:	c0 43       	brcs	8000c7e2 <__avr32_udiv64+0x8e>
8000c7dc:	14 33       	cp.w	r3,r10
8000c7de:	f7 b8 03 01 	sublo	r8,1
8000c7e2:	f1 e9 11 08 	or	r8,r8,r9<<0x10
8000c7e6:	cd f8       	rjmp	8000c9a4 <__avr32_udiv64+0x250>
8000c7e8:	58 08       	cp.w	r8,0
8000c7ea:	c0 51       	brne	8000c7f4 <__avr32_udiv64+0xa0>
8000c7ec:	30 19       	mov	r9,1
8000c7ee:	f2 08 0d 08 	divu	r8,r9,r8
8000c7f2:	10 9c       	mov	r12,r8
8000c7f4:	f8 06 12 00 	clz	r6,r12
8000c7f8:	c0 41       	brne	8000c800 <__avr32_udiv64+0xac>
8000c7fa:	18 1b       	sub	r11,r12
8000c7fc:	30 19       	mov	r9,1
8000c7fe:	c4 08       	rjmp	8000c87e <__avr32_udiv64+0x12a>
8000c800:	ec 01 11 20 	rsub	r1,r6,32
8000c804:	f4 01 0a 49 	lsr	r9,r10,r1
8000c808:	f8 06 09 4c 	lsl	r12,r12,r6
8000c80c:	f6 06 09 48 	lsl	r8,r11,r6
8000c810:	f6 01 0a 41 	lsr	r1,r11,r1
8000c814:	f3 e8 10 08 	or	r8,r9,r8
8000c818:	f8 03 16 10 	lsr	r3,r12,0x10
8000c81c:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000c820:	e2 03 0d 00 	divu	r0,r1,r3
8000c824:	f0 0b 16 10 	lsr	r11,r8,0x10
8000c828:	00 9e       	mov	lr,r0
8000c82a:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c82e:	e0 05 02 49 	mul	r9,r0,r5
8000c832:	12 3b       	cp.w	r11,r9
8000c834:	c0 a2       	brcc	8000c848 <__avr32_udiv64+0xf4>
8000c836:	20 1e       	sub	lr,1
8000c838:	18 0b       	add	r11,r12
8000c83a:	18 3b       	cp.w	r11,r12
8000c83c:	c0 63       	brcs	8000c848 <__avr32_udiv64+0xf4>
8000c83e:	12 3b       	cp.w	r11,r9
8000c840:	f7 be 03 01 	sublo	lr,1
8000c844:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c848:	12 1b       	sub	r11,r9
8000c84a:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
8000c84e:	f6 03 0d 02 	divu	r2,r11,r3
8000c852:	f1 e3 11 08 	or	r8,r8,r3<<0x10
8000c856:	04 99       	mov	r9,r2
8000c858:	e4 05 02 4b 	mul	r11,r2,r5
8000c85c:	16 38       	cp.w	r8,r11
8000c85e:	c0 a2       	brcc	8000c872 <__avr32_udiv64+0x11e>
8000c860:	20 19       	sub	r9,1
8000c862:	18 08       	add	r8,r12
8000c864:	18 38       	cp.w	r8,r12
8000c866:	c0 63       	brcs	8000c872 <__avr32_udiv64+0x11e>
8000c868:	16 38       	cp.w	r8,r11
8000c86a:	f7 b9 03 01 	sublo	r9,1
8000c86e:	f1 dc e3 08 	addcs	r8,r8,r12
8000c872:	f4 06 09 43 	lsl	r3,r10,r6
8000c876:	f0 0b 01 0b 	sub	r11,r8,r11
8000c87a:	f3 ee 11 09 	or	r9,r9,lr<<0x10
8000c87e:	f8 06 16 10 	lsr	r6,r12,0x10
8000c882:	fd dc c0 10 	bfextu	lr,r12,0x0,0x10
8000c886:	f6 06 0d 00 	divu	r0,r11,r6
8000c88a:	e6 0b 16 10 	lsr	r11,r3,0x10
8000c88e:	00 9a       	mov	r10,r0
8000c890:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c894:	e0 0e 02 48 	mul	r8,r0,lr
8000c898:	10 3b       	cp.w	r11,r8
8000c89a:	c0 a2       	brcc	8000c8ae <__avr32_udiv64+0x15a>
8000c89c:	20 1a       	sub	r10,1
8000c89e:	18 0b       	add	r11,r12
8000c8a0:	18 3b       	cp.w	r11,r12
8000c8a2:	c0 63       	brcs	8000c8ae <__avr32_udiv64+0x15a>
8000c8a4:	10 3b       	cp.w	r11,r8
8000c8a6:	f7 ba 03 01 	sublo	r10,1
8000c8aa:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c8ae:	f6 08 01 01 	sub	r1,r11,r8
8000c8b2:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000c8b6:	e2 06 0d 00 	divu	r0,r1,r6
8000c8ba:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000c8be:	00 98       	mov	r8,r0
8000c8c0:	e0 0e 02 4b 	mul	r11,r0,lr
8000c8c4:	16 33       	cp.w	r3,r11
8000c8c6:	c0 82       	brcc	8000c8d6 <__avr32_udiv64+0x182>
8000c8c8:	20 18       	sub	r8,1
8000c8ca:	18 03       	add	r3,r12
8000c8cc:	18 33       	cp.w	r3,r12
8000c8ce:	c0 43       	brcs	8000c8d6 <__avr32_udiv64+0x182>
8000c8d0:	16 33       	cp.w	r3,r11
8000c8d2:	f7 b8 03 01 	sublo	r8,1
8000c8d6:	f1 ea 11 08 	or	r8,r8,r10<<0x10
8000c8da:	c6 98       	rjmp	8000c9ac <__avr32_udiv64+0x258>
8000c8dc:	16 39       	cp.w	r9,r11
8000c8de:	e0 8b 00 65 	brhi	8000c9a8 <__avr32_udiv64+0x254>
8000c8e2:	f2 09 12 00 	clz	r9,r9
8000c8e6:	c0 b1       	brne	8000c8fc <__avr32_udiv64+0x1a8>
8000c8e8:	10 3a       	cp.w	r10,r8
8000c8ea:	5f 2a       	srhs	r10
8000c8ec:	1c 3b       	cp.w	r11,lr
8000c8ee:	5f b8       	srhi	r8
8000c8f0:	10 4a       	or	r10,r8
8000c8f2:	f2 0a 18 00 	cp.b	r10,r9
8000c8f6:	c5 90       	breq	8000c9a8 <__avr32_udiv64+0x254>
8000c8f8:	30 18       	mov	r8,1
8000c8fa:	c5 98       	rjmp	8000c9ac <__avr32_udiv64+0x258>
8000c8fc:	f0 09 09 46 	lsl	r6,r8,r9
8000c900:	f2 03 11 20 	rsub	r3,r9,32
8000c904:	fc 09 09 4e 	lsl	lr,lr,r9
8000c908:	f0 03 0a 48 	lsr	r8,r8,r3
8000c90c:	f6 09 09 4c 	lsl	r12,r11,r9
8000c910:	f4 03 0a 42 	lsr	r2,r10,r3
8000c914:	ef 46 ff f4 	st.w	r7[-12],r6
8000c918:	f6 03 0a 43 	lsr	r3,r11,r3
8000c91c:	18 42       	or	r2,r12
8000c91e:	f1 ee 10 0c 	or	r12,r8,lr
8000c922:	f8 01 16 10 	lsr	r1,r12,0x10
8000c926:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000c92a:	e6 01 0d 04 	divu	r4,r3,r1
8000c92e:	e4 03 16 10 	lsr	r3,r2,0x10
8000c932:	08 9e       	mov	lr,r4
8000c934:	e7 e5 11 03 	or	r3,r3,r5<<0x10
8000c938:	e8 06 02 48 	mul	r8,r4,r6
8000c93c:	10 33       	cp.w	r3,r8
8000c93e:	c0 a2       	brcc	8000c952 <__avr32_udiv64+0x1fe>
8000c940:	20 1e       	sub	lr,1
8000c942:	18 03       	add	r3,r12
8000c944:	18 33       	cp.w	r3,r12
8000c946:	c0 63       	brcs	8000c952 <__avr32_udiv64+0x1fe>
8000c948:	10 33       	cp.w	r3,r8
8000c94a:	f7 be 03 01 	sublo	lr,1
8000c94e:	e7 dc e3 03 	addcs	r3,r3,r12
8000c952:	10 13       	sub	r3,r8
8000c954:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
8000c958:	e6 01 0d 00 	divu	r0,r3,r1
8000c95c:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c960:	00 98       	mov	r8,r0
8000c962:	e0 06 02 46 	mul	r6,r0,r6
8000c966:	0c 3b       	cp.w	r11,r6
8000c968:	c0 a2       	brcc	8000c97c <__avr32_udiv64+0x228>
8000c96a:	20 18       	sub	r8,1
8000c96c:	18 0b       	add	r11,r12
8000c96e:	18 3b       	cp.w	r11,r12
8000c970:	c0 63       	brcs	8000c97c <__avr32_udiv64+0x228>
8000c972:	0c 3b       	cp.w	r11,r6
8000c974:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c978:	f7 b8 03 01 	sublo	r8,1
8000c97c:	f1 ee 11 08 	or	r8,r8,lr<<0x10
8000c980:	ee f4 ff f4 	ld.w	r4,r7[-12]
8000c984:	0c 1b       	sub	r11,r6
8000c986:	f0 04 06 42 	mulu.d	r2,r8,r4
8000c98a:	06 95       	mov	r5,r3
8000c98c:	16 35       	cp.w	r5,r11
8000c98e:	e0 8b 00 0a 	brhi	8000c9a2 <__avr32_udiv64+0x24e>
8000c992:	5f 0b       	sreq	r11
8000c994:	f4 09 09 49 	lsl	r9,r10,r9
8000c998:	12 32       	cp.w	r2,r9
8000c99a:	5f b9       	srhi	r9
8000c99c:	f7 e9 00 09 	and	r9,r11,r9
8000c9a0:	c0 60       	breq	8000c9ac <__avr32_udiv64+0x258>
8000c9a2:	20 18       	sub	r8,1
8000c9a4:	30 09       	mov	r9,0
8000c9a6:	c0 38       	rjmp	8000c9ac <__avr32_udiv64+0x258>
8000c9a8:	30 09       	mov	r9,0
8000c9aa:	12 98       	mov	r8,r9
8000c9ac:	10 9a       	mov	r10,r8
8000c9ae:	12 93       	mov	r3,r9
8000c9b0:	10 92       	mov	r2,r8
8000c9b2:	12 9b       	mov	r11,r9
8000c9b4:	2f dd       	sub	sp,-12
8000c9b6:	d8 32       	popm	r0-r7,pc

8000c9b8 <__avr32_umod64>:
8000c9b8:	d4 31       	pushm	r0-r7,lr
8000c9ba:	1a 97       	mov	r7,sp
8000c9bc:	20 3d       	sub	sp,12
8000c9be:	10 9c       	mov	r12,r8
8000c9c0:	12 95       	mov	r5,r9
8000c9c2:	14 9e       	mov	lr,r10
8000c9c4:	16 91       	mov	r1,r11
8000c9c6:	16 96       	mov	r6,r11
8000c9c8:	58 09       	cp.w	r9,0
8000c9ca:	e0 81 00 81 	brne	8000cacc <__avr32_umod64+0x114>
8000c9ce:	16 38       	cp.w	r8,r11
8000c9d0:	e0 88 00 12 	brls	8000c9f4 <__avr32_umod64+0x3c>
8000c9d4:	f0 08 12 00 	clz	r8,r8
8000c9d8:	c4 e0       	breq	8000ca74 <__avr32_umod64+0xbc>
8000c9da:	f6 08 09 46 	lsl	r6,r11,r8
8000c9de:	f8 08 09 4c 	lsl	r12,r12,r8
8000c9e2:	f0 0b 11 20 	rsub	r11,r8,32
8000c9e6:	f4 08 09 4e 	lsl	lr,r10,r8
8000c9ea:	f4 0b 0a 4b 	lsr	r11,r10,r11
8000c9ee:	f7 e6 10 06 	or	r6,r11,r6
8000c9f2:	c4 18       	rjmp	8000ca74 <__avr32_umod64+0xbc>
8000c9f4:	58 08       	cp.w	r8,0
8000c9f6:	c0 51       	brne	8000ca00 <__avr32_umod64+0x48>
8000c9f8:	30 19       	mov	r9,1
8000c9fa:	f2 08 0d 08 	divu	r8,r9,r8
8000c9fe:	10 9c       	mov	r12,r8
8000ca00:	f8 08 12 00 	clz	r8,r12
8000ca04:	c0 31       	brne	8000ca0a <__avr32_umod64+0x52>
8000ca06:	18 16       	sub	r6,r12
8000ca08:	c3 68       	rjmp	8000ca74 <__avr32_umod64+0xbc>
8000ca0a:	f0 03 11 20 	rsub	r3,r8,32
8000ca0e:	f4 03 0a 4b 	lsr	r11,r10,r3
8000ca12:	f8 08 09 4c 	lsl	r12,r12,r8
8000ca16:	ec 08 09 49 	lsl	r9,r6,r8
8000ca1a:	ec 03 0a 43 	lsr	r3,r6,r3
8000ca1e:	f7 e9 10 09 	or	r9,r11,r9
8000ca22:	f8 05 16 10 	lsr	r5,r12,0x10
8000ca26:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000ca2a:	e6 05 0d 02 	divu	r2,r3,r5
8000ca2e:	f2 0e 16 10 	lsr	lr,r9,0x10
8000ca32:	ec 02 02 4b 	mul	r11,r6,r2
8000ca36:	fd e3 11 0e 	or	lr,lr,r3<<0x10
8000ca3a:	16 3e       	cp.w	lr,r11
8000ca3c:	c0 72       	brcc	8000ca4a <__avr32_umod64+0x92>
8000ca3e:	18 0e       	add	lr,r12
8000ca40:	18 3e       	cp.w	lr,r12
8000ca42:	c0 43       	brcs	8000ca4a <__avr32_umod64+0x92>
8000ca44:	16 3e       	cp.w	lr,r11
8000ca46:	fd dc e3 0e 	addcs	lr,lr,r12
8000ca4a:	fc 0b 01 03 	sub	r3,lr,r11
8000ca4e:	f3 d9 c0 10 	bfextu	r9,r9,0x0,0x10
8000ca52:	e6 05 0d 02 	divu	r2,r3,r5
8000ca56:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000ca5a:	a5 36       	mul	r6,r2
8000ca5c:	0c 39       	cp.w	r9,r6
8000ca5e:	c0 72       	brcc	8000ca6c <__avr32_umod64+0xb4>
8000ca60:	18 09       	add	r9,r12
8000ca62:	18 39       	cp.w	r9,r12
8000ca64:	c0 43       	brcs	8000ca6c <__avr32_umod64+0xb4>
8000ca66:	0c 39       	cp.w	r9,r6
8000ca68:	f3 dc e3 09 	addcs	r9,r9,r12
8000ca6c:	f2 06 01 06 	sub	r6,r9,r6
8000ca70:	f4 08 09 4e 	lsl	lr,r10,r8
8000ca74:	f8 0a 16 10 	lsr	r10,r12,0x10
8000ca78:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000ca7c:	ec 0a 0d 02 	divu	r2,r6,r10
8000ca80:	fc 09 16 10 	lsr	r9,lr,0x10
8000ca84:	ea 02 02 4b 	mul	r11,r5,r2
8000ca88:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000ca8c:	16 39       	cp.w	r9,r11
8000ca8e:	c0 72       	brcc	8000ca9c <__avr32_umod64+0xe4>
8000ca90:	18 09       	add	r9,r12
8000ca92:	18 39       	cp.w	r9,r12
8000ca94:	c0 43       	brcs	8000ca9c <__avr32_umod64+0xe4>
8000ca96:	16 39       	cp.w	r9,r11
8000ca98:	f3 dc e3 09 	addcs	r9,r9,r12
8000ca9c:	f2 0b 01 0b 	sub	r11,r9,r11
8000caa0:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000caa4:	f6 0a 0d 0a 	divu	r10,r11,r10
8000caa8:	fd eb 11 0e 	or	lr,lr,r11<<0x10
8000caac:	ea 0a 02 4a 	mul	r10,r5,r10
8000cab0:	14 3e       	cp.w	lr,r10
8000cab2:	c0 72       	brcc	8000cac0 <__avr32_umod64+0x108>
8000cab4:	18 0e       	add	lr,r12
8000cab6:	18 3e       	cp.w	lr,r12
8000cab8:	c0 43       	brcs	8000cac0 <__avr32_umod64+0x108>
8000caba:	14 3e       	cp.w	lr,r10
8000cabc:	fd dc e3 0e 	addcs	lr,lr,r12
8000cac0:	fc 0a 01 0a 	sub	r10,lr,r10
8000cac4:	30 0b       	mov	r11,0
8000cac6:	f4 08 0a 4a 	lsr	r10,r10,r8
8000caca:	c7 b8       	rjmp	8000cbc0 <__avr32_umod64+0x208>
8000cacc:	16 39       	cp.w	r9,r11
8000cace:	e0 8b 00 79 	brhi	8000cbc0 <__avr32_umod64+0x208>
8000cad2:	f2 09 12 00 	clz	r9,r9
8000cad6:	c1 21       	brne	8000cafa <__avr32_umod64+0x142>
8000cad8:	10 3a       	cp.w	r10,r8
8000cada:	5f 2b       	srhs	r11
8000cadc:	0a 31       	cp.w	r1,r5
8000cade:	5f ba       	srhi	r10
8000cae0:	f7 ea 10 0a 	or	r10,r11,r10
8000cae4:	f2 0a 18 00 	cp.b	r10,r9
8000cae8:	c0 60       	breq	8000caf4 <__avr32_umod64+0x13c>
8000caea:	fc 08 01 0c 	sub	r12,lr,r8
8000caee:	e2 05 01 46 	sbc	r6,r1,r5
8000caf2:	18 9e       	mov	lr,r12
8000caf4:	0c 9b       	mov	r11,r6
8000caf6:	1c 9a       	mov	r10,lr
8000caf8:	c6 48       	rjmp	8000cbc0 <__avr32_umod64+0x208>
8000cafa:	ea 09 09 4c 	lsl	r12,r5,r9
8000cafe:	f2 06 11 20 	rsub	r6,r9,32
8000cb02:	f6 09 09 4b 	lsl	r11,r11,r9
8000cb06:	f0 09 09 42 	lsl	r2,r8,r9
8000cb0a:	ef 46 ff f4 	st.w	r7[-12],r6
8000cb0e:	f0 06 0a 48 	lsr	r8,r8,r6
8000cb12:	18 48       	or	r8,r12
8000cb14:	e2 06 0a 4c 	lsr	r12,r1,r6
8000cb18:	f4 09 09 43 	lsl	r3,r10,r9
8000cb1c:	fd d8 c0 10 	bfextu	lr,r8,0x0,0x10
8000cb20:	f4 06 0a 4a 	lsr	r10,r10,r6
8000cb24:	16 4a       	or	r10,r11
8000cb26:	f0 0b 16 10 	lsr	r11,r8,0x10
8000cb2a:	f8 0b 0d 04 	divu	r4,r12,r11
8000cb2e:	f4 0c 16 10 	lsr	r12,r10,0x10
8000cb32:	08 91       	mov	r1,r4
8000cb34:	f9 e5 11 0c 	or	r12,r12,r5<<0x10
8000cb38:	e8 0e 02 46 	mul	r6,r4,lr
8000cb3c:	0c 3c       	cp.w	r12,r6
8000cb3e:	c0 a2       	brcc	8000cb52 <__avr32_umod64+0x19a>
8000cb40:	20 11       	sub	r1,1
8000cb42:	10 0c       	add	r12,r8
8000cb44:	10 3c       	cp.w	r12,r8
8000cb46:	c0 63       	brcs	8000cb52 <__avr32_umod64+0x19a>
8000cb48:	0c 3c       	cp.w	r12,r6
8000cb4a:	f7 b1 03 01 	sublo	r1,1
8000cb4e:	f9 d8 e3 0c 	addcs	r12,r12,r8
8000cb52:	0c 1c       	sub	r12,r6
8000cb54:	f5 da c0 10 	bfextu	r10,r10,0x0,0x10
8000cb58:	f8 0b 0d 04 	divu	r4,r12,r11
8000cb5c:	f5 e5 11 0b 	or	r11,r10,r5<<0x10
8000cb60:	08 96       	mov	r6,r4
8000cb62:	e8 0e 02 4e 	mul	lr,r4,lr
8000cb66:	1c 3b       	cp.w	r11,lr
8000cb68:	c0 a2       	brcc	8000cb7c <__avr32_umod64+0x1c4>
8000cb6a:	20 16       	sub	r6,1
8000cb6c:	10 0b       	add	r11,r8
8000cb6e:	10 3b       	cp.w	r11,r8
8000cb70:	c0 63       	brcs	8000cb7c <__avr32_umod64+0x1c4>
8000cb72:	1c 3b       	cp.w	r11,lr
8000cb74:	f7 b6 03 01 	sublo	r6,1
8000cb78:	f7 d8 e3 0b 	addcs	r11,r11,r8
8000cb7c:	ed e1 11 01 	or	r1,r6,r1<<0x10
8000cb80:	1c 1b       	sub	r11,lr
8000cb82:	e2 02 06 40 	mulu.d	r0,r1,r2
8000cb86:	00 9e       	mov	lr,r0
8000cb88:	02 9c       	mov	r12,r1
8000cb8a:	16 3c       	cp.w	r12,r11
8000cb8c:	e0 8b 00 08 	brhi	8000cb9c <__avr32_umod64+0x1e4>
8000cb90:	5f 06       	sreq	r6
8000cb92:	06 30       	cp.w	r0,r3
8000cb94:	5f ba       	srhi	r10
8000cb96:	ed ea 00 0a 	and	r10,r6,r10
8000cb9a:	c0 60       	breq	8000cba6 <__avr32_umod64+0x1ee>
8000cb9c:	fc 02 01 04 	sub	r4,lr,r2
8000cba0:	f8 08 01 4c 	sbc	r12,r12,r8
8000cba4:	08 9e       	mov	lr,r4
8000cba6:	e6 0e 01 0a 	sub	r10,r3,lr
8000cbaa:	f6 0c 01 4c 	sbc	r12,r11,r12
8000cbae:	ee f1 ff f4 	ld.w	r1,r7[-12]
8000cbb2:	f8 09 0a 4b 	lsr	r11,r12,r9
8000cbb6:	f4 09 0a 4a 	lsr	r10,r10,r9
8000cbba:	f8 01 09 4c 	lsl	r12,r12,r1
8000cbbe:	18 4a       	or	r10,r12
8000cbc0:	2f dd       	sub	sp,-12
8000cbc2:	d8 32       	popm	r0-r7,pc

Disassembly of section .exception:

8000cc00 <_evba>:
_evba:

        .org  0x000
        // Unrecoverable Exception.
_handle_Unrecoverable_Exception:
        rjmp $
8000cc00:	c0 08       	rjmp	8000cc00 <_evba>
	...

8000cc04 <_handle_TLB_Multiple_Hit>:

        .org  0x004
        // TLB Multiple Hit: UNUSED IN AVR32UC.
_handle_TLB_Multiple_Hit:
        rjmp $
8000cc04:	c0 08       	rjmp	8000cc04 <_handle_TLB_Multiple_Hit>
	...

8000cc08 <_handle_Bus_Error_Data_Fetch>:

        .org  0x008
        // Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
        rjmp $
8000cc08:	c0 08       	rjmp	8000cc08 <_handle_Bus_Error_Data_Fetch>
	...

8000cc0c <_handle_Bus_Error_Instruction_Fetch>:

        .org  0x00C
         // Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
        rjmp $
8000cc0c:	c0 08       	rjmp	8000cc0c <_handle_Bus_Error_Instruction_Fetch>
	...

8000cc10 <_handle_NMI>:

        .org  0x010
        // NMI.
_handle_NMI:
        rjmp $
8000cc10:	c0 08       	rjmp	8000cc10 <_handle_NMI>
	...

8000cc14 <_handle_Instruction_Address>:

        .org  0x014
        // Instruction Address.
_handle_Instruction_Address:
        rjmp $
8000cc14:	c0 08       	rjmp	8000cc14 <_handle_Instruction_Address>
	...

8000cc18 <_handle_ITLB_Protection>:

        .org  0x018
        // ITLB Protection.
_handle_ITLB_Protection:
        rjmp $
8000cc18:	c0 08       	rjmp	8000cc18 <_handle_ITLB_Protection>
	...

8000cc1c <_handle_Breakpoint>:

        .org  0x01C
        // Breakpoint.
_handle_Breakpoint:
        rjmp $
8000cc1c:	c0 08       	rjmp	8000cc1c <_handle_Breakpoint>
	...

8000cc20 <_handle_Illegal_Opcode>:

        .org  0x020
        // Illegal Opcode.
_handle_Illegal_Opcode:
        rjmp $
8000cc20:	c0 08       	rjmp	8000cc20 <_handle_Illegal_Opcode>
	...

8000cc24 <_handle_Unimplemented_Instruction>:

        .org  0x024
        // Unimplemented Instruction.
_handle_Unimplemented_Instruction:
        rjmp $
8000cc24:	c0 08       	rjmp	8000cc24 <_handle_Unimplemented_Instruction>
	...

8000cc28 <_handle_Privilege_Violation>:

        .org  0x028
        // Privilege Violation.
_handle_Privilege_Violation:
        rjmp $
8000cc28:	c0 08       	rjmp	8000cc28 <_handle_Privilege_Violation>
	...

8000cc2c <_handle_Floating_Point>:

        .org  0x02C
        // Floating-Point: UNUSED IN AVR32UC.
_handle_Floating_Point:
        rjmp $
8000cc2c:	c0 08       	rjmp	8000cc2c <_handle_Floating_Point>
	...

8000cc30 <_handle_Coprocessor_Absent>:

        .org  0x030
        // Coprocessor Absent: UNUSED IN AVR32UC.
_handle_Coprocessor_Absent:
        rjmp $
8000cc30:	c0 08       	rjmp	8000cc30 <_handle_Coprocessor_Absent>
	...

8000cc34 <_handle_Data_Address_Read>:

        .org  0x034
        // Data Address (Read).
_handle_Data_Address_Read:
        rjmp $
8000cc34:	c0 08       	rjmp	8000cc34 <_handle_Data_Address_Read>
	...

8000cc38 <_handle_Data_Address_Write>:

        .org  0x038
        // Data Address (Write).
_handle_Data_Address_Write:
        rjmp $
8000cc38:	c0 08       	rjmp	8000cc38 <_handle_Data_Address_Write>
	...

8000cc3c <_handle_DTLB_Protection_Read>:

        .org  0x03C
        // DTLB Protection (Read).
_handle_DTLB_Protection_Read:
        rjmp $
8000cc3c:	c0 08       	rjmp	8000cc3c <_handle_DTLB_Protection_Read>
	...

8000cc40 <_handle_DTLB_Protection_Write>:

        .org  0x040
        // DTLB Protection (Write).
_handle_DTLB_Protection_Write:
        rjmp $
8000cc40:	c0 08       	rjmp	8000cc40 <_handle_DTLB_Protection_Write>
	...

8000cc44 <_handle_DTLB_Modified>:

        .org  0x044
        // DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
        rjmp $
8000cc44:	c0 08       	rjmp	8000cc44 <_handle_DTLB_Modified>
	...

8000cc50 <_handle_ITLB_Miss>:

        .org  0x050
        // ITLB Miss: UNUSED IN AVR32UC.
_handle_ITLB_Miss:
        rjmp $
8000cc50:	c0 08       	rjmp	8000cc50 <_handle_ITLB_Miss>
	...

8000cc60 <_handle_DTLB_Miss_Read>:

        .org  0x060
        // DTLB Miss (Read): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Read:
        rjmp $
8000cc60:	c0 08       	rjmp	8000cc60 <_handle_DTLB_Miss_Read>
	...

8000cc70 <_handle_DTLB_Miss_Write>:

        .org  0x070
        // DTLB Miss (Write): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Write:
        rjmp $
8000cc70:	c0 08       	rjmp	8000cc70 <_handle_DTLB_Miss_Write>
	...

8000cd00 <_handle_Supervisor_Call>:

        .org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
8000cd00:	fe cf 70 70 	sub	pc,pc,28784

8000cd04 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
8000cd04:	30 0c       	mov	r12,0
8000cd06:	fe b0 c3 f5 	rcall	800054f0 <_get_interrupt_handler>
8000cd0a:	58 0c       	cp.w	r12,0
8000cd0c:	f8 0f 17 10 	movne	pc,r12
8000cd10:	d6 03       	rete

8000cd12 <_int1>:
8000cd12:	30 1c       	mov	r12,1
8000cd14:	fe b0 c3 ee 	rcall	800054f0 <_get_interrupt_handler>
8000cd18:	58 0c       	cp.w	r12,0
8000cd1a:	f8 0f 17 10 	movne	pc,r12
8000cd1e:	d6 03       	rete

8000cd20 <_int2>:
8000cd20:	30 2c       	mov	r12,2
8000cd22:	fe b0 c3 e7 	rcall	800054f0 <_get_interrupt_handler>
8000cd26:	58 0c       	cp.w	r12,0
8000cd28:	f8 0f 17 10 	movne	pc,r12
8000cd2c:	d6 03       	rete

8000cd2e <_int3>:
8000cd2e:	30 3c       	mov	r12,3
8000cd30:	fe b0 c3 e0 	rcall	800054f0 <_get_interrupt_handler>
8000cd34:	58 0c       	cp.w	r12,0
8000cd36:	f8 0f 17 10 	movne	pc,r12
8000cd3a:	d6 03       	rete

8000cd3c <ipr_val>:
8000cd3c:	00 00 01 04 40 00 01 12 80 00 01 20 c0 00 01 2e     ....@...... ....
8000cd4c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cd5c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cd6c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cd7c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cd8c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cd9c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cdac:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cdbc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cdcc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cddc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cdec:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cdfc:	d7 03 d7 03                                         ....
