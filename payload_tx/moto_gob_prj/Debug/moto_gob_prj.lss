
moto_gob_prj.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002008  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80002008  80002008  00002408  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         0000a058  80002008  80002008  00002408  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  8000c200  8000c200  0000c600  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       00001138  8000c400  8000c400  0000c800  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .dalign       00000004  00000004  00000004  00000000  2**0
                  ALLOC
  6 .data         00000a2c  00000008  8000d538  0000dc08  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .balign       00000004  00000a34  8000df64  0000e634  2**0
                  ALLOC
  8 .bss          000036e0  00000a38  00000a38  00000000  2**2
                  ALLOC
  9 .heap         00012ee8  00004118  00004118  00000000  2**0
                  ALLOC
 10 .comment      00000030  00000000  00000000  0000e634  2**0
                  CONTENTS, READONLY
 11 .debug_aranges 00001158  00000000  00000000  0000e668  2**3
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_pubnames 000024f9  00000000  00000000  0000f7c0  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_info   00028356  00000000  00000000  00011cb9  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_abbrev 00006793  00000000  00000000  0003a00f  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_line   0000c192  00000000  00000000  000407a2  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_frame  00002d24  00000000  00000000  0004c934  2**2
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_str    00006cf5  00000000  00000000  0004f658  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_loc    0000c9d2  00000000  00000000  0005634d  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .stack        00001000  00017000  00017000  00000000  2**0
                  ALLOC
 20 .debug_ranges 00001240  00000000  00000000  00062d20  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_start>:

  .global _start
  .type _start, @function
_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80000000:	fe cf 98 c4 	sub	pc,pc,-26428

80000004 <_trampoline>:
80000004:	e0 8f 10 00 	bral	80002004 <program_start>
	...

80002004 <program_start>:
  rjmp    program_start

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002004:	fe cf b8 c8 	sub	pc,pc,-18232

Disassembly of section .text:

80002008 <DeviceManagement_brdcst_func>:
80002008:	19 a9       	ld.ub	r9,r12[0x2]
8000200a:	30 18       	mov	r8,1
		U8 temp = 0;
		temp  = xcmp->u8[1] << 8;
		temp |= xcmp->u8[2];
		//if (temp == theXNL_Ctrlr.XNL_DeviceLogicalAddress)
		{
			if (xcmp->u8[0] == 0x01)
8000200c:	f0 09 18 00 	cp.b	r9,r8
80002010:	c0 61       	brne	8000201c <DeviceManagement_brdcst_func+0x14>
			{
				bunchofrandomstatusflags |= 0x00000002;
80002012:	48 68       	lddpc	r8,80002028 <DeviceManagement_brdcst_func+0x20>
80002014:	70 09       	ld.w	r9,r8[0x0]
80002016:	a1 b9       	sbr	r9,0x1
80002018:	91 09       	st.w	r8[0x0],r9
8000201a:	5e fc       	retal	r12
			}
			else
			{
				bunchofrandomstatusflags &= 0xFFFFFFFD;
8000201c:	48 38       	lddpc	r8,80002028 <DeviceManagement_brdcst_func+0x20>
8000201e:	70 09       	ld.w	r9,r8[0x0]
80002020:	a1 d9       	cbr	r9,0x1
80002022:	91 09       	st.w	r8[0x0],r9
80002024:	5e fc       	retal	r12
80002026:	00 00       	add	r0,r0
80002028:	00 00       	add	r0,r0
8000202a:	0d 94       	ld.ub	r4,r6[0x1]

8000202c <Volume_brdcst_func>:
	//log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
	
	//log("\n\r Audio_Parameter: %x \n\r", ptr->Audio_Parameter);
	
	
}
8000202c:	5e fc       	retal	r12

8000202e <AudioRoutingControl_brdcst_func>:
	//
	//log("\n\r Audio-Function: %x \n\r", xcmp->u8[3+j*2-1]);
	
	
	
}
8000202e:	5e fc       	retal	r12

80002030 <vApplicationIdleHook>:
}

void vApplicationIdleHook( void )
{
	/* This hook function does nothing but increment a counter. */
	ulIdleCycleCount++;
80002030:	48 38       	lddpc	r8,8000203c <vApplicationIdleHook+0xc>
80002032:	70 09       	ld.w	r9,r8[0x0]
80002034:	2f f9       	sub	r9,-1
80002036:	91 09       	st.w	r8[0x0],r9
	
}
80002038:	5e fc       	retal	r12
8000203a:	00 00       	add	r0,r0
8000203c:	00 00       	add	r0,r0
8000203e:	0a 54       	eor	r4,r5

80002040 <app_init>:
														
		
};

void app_init(void)
{	
80002040:	d4 01       	pushm	lr
	//将app_payload_rx_proc更改为PCM加密功能
	payload_init( app_payload_rx_proc , app_payload_tx_proc );	
80002042:	48 cb       	lddpc	r11,80002070 <app_init+0x30>
80002044:	48 cc       	lddpc	r12,80002074 <app_init+0x34>
80002046:	f0 1f 00 0d 	mcall	80002078 <app_init+0x38>
	xcmp_register_app_list(the_app_list);
8000204a:	48 dc       	lddpc	r12,8000207c <app_init+0x3c>
8000204c:	f0 1f 00 0d 	mcall	80002080 <app_init+0x40>
			
	static portBASE_TYPE res = 0;
	 res = xTaskCreate(
80002050:	30 09       	mov	r9,0
80002052:	1a d9       	st.w	--sp,r9
80002054:	1a d9       	st.w	--sp,r9
80002056:	1a d9       	st.w	--sp,r9
80002058:	30 18       	mov	r8,1
8000205a:	e0 6a 01 80 	mov	r10,384
8000205e:	48 ab       	lddpc	r11,80002084 <app_init+0x44>
80002060:	48 ac       	lddpc	r12,80002088 <app_init+0x48>
80002062:	f0 1f 00 0b 	mcall	8000208c <app_init+0x4c>
80002066:	48 b8       	lddpc	r8,80002090 <app_init+0x50>
80002068:	91 0c       	st.w	r8[0x0],r12
8000206a:	2f dd       	sub	sp,-12
	,  NULL
	,  1
	,  NULL );
	
	
}
8000206c:	d8 02       	popm	pc
8000206e:	00 00       	add	r0,r0
80002070:	80 00       	ld.sh	r0,r0[0x0]
80002072:	21 20       	sub	r0,18
80002074:	80 00       	ld.sh	r0,r0[0x0]
80002076:	28 18       	sub	r8,-127
80002078:	80 00       	ld.sh	r0,r0[0x0]
8000207a:	28 e8       	sub	r8,-114
8000207c:	00 00       	add	r0,r0
8000207e:	00 08       	add	r8,r0
80002080:	80 00       	ld.sh	r0,r0[0x0]
80002082:	3e 68       	mov	r8,-26
80002084:	80 00       	ld.sh	r0,r0[0x0]
80002086:	c4 00       	breq	80002106 <app_cfg+0x72>
80002088:	80 00       	ld.sh	r0,r0[0x0]
8000208a:	20 94       	sub	r4,9
8000208c:	80 00       	ld.sh	r0,r0[0x0]
8000208e:	5e b0       	rethi	r0
80002090:	00 00       	add	r0,r0
80002092:	0a 3c       	cp.w	r12,r5

80002094 <app_cfg>:

extern  char AudioData[];
extern U32 tc_tick;

static __app_Thread_(app_cfg)
{
80002094:	d4 31       	pushm	r0-r7,lr
	static  U32 isAudioRouting = 0;
	static  portTickType xLastWakeTime;
	const portTickType xFrequency = 4000;//2s,定时问题已经修正。2s x  2000hz = 4000
	U8 Burst_ID = 0;
	
	 xLastWakeTime = xTaskGetTickCount();
80002096:	f0 1f 00 1a 	mcall	800020fc <app_cfg+0x68>
8000209a:	49 a8       	lddpc	r8,80002100 <app_cfg+0x6c>
8000209c:	91 0c       	st.w	r8[0x0],r12
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003))//确认连接成功了，再发送请求
8000209e:	49 a6       	lddpc	r6,80002104 <app_cfg+0x70>
				//{
					////xcmp_transmit_dekeycontrol();
					//
				//}
				
				if(isAudioRouting == 0)
800020a0:	49 a4       	lddpc	r4,80002108 <app_cfg+0x74>
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_exit_enhanced_OB_mode();
					//xcmp_mute_speaker();
					//xcmp_enhanced_OB_mode();
					isAudioRouting = 4;
800020a2:	30 41       	mov	r1,4
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_mute_speaker();	
					//log("\n\r time: %d \n\r", tc_tick); 
					isAudioRouting = 3;
800020a4:	30 32       	mov	r2,3
					//xcmp_button_config();
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//log("\n\r time: %d \n\r", tc_tick);
					
					isAudioRouting = 2;
800020a6:	30 20       	mov	r0,2
					xcmp_enter_enhanced_OB_mode();
					//xcmp_unmute_speaker();
					//Speaker_is_unmute = 1;
					//xcmp_function_mic();
					
					isAudioRouting = 1;
800020a8:	30 13       	mov	r3,1
			
		}
		//vTaskDelay(300*2 / portTICK_RATE_MS);//延迟300ms
		//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
		
		vTaskDelayUntil( &xLastWakeTime, 1000*2 / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
800020aa:	10 97       	mov	r7,r8
800020ac:	e0 65 07 d0 	mov	r5,2000
	
	 xLastWakeTime = xTaskGetTickCount();
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003))//确认连接成功了，再发送请求
800020b0:	6c 08       	ld.w	r8,r6[0x0]
800020b2:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
800020b6:	58 38       	cp.w	r8,3
800020b8:	c1 d1       	brne	800020f2 <app_cfg+0x5e>
				//{
					////xcmp_transmit_dekeycontrol();
					//
				//}
				
				if(isAudioRouting == 0)
800020ba:	68 08       	ld.w	r8,r4[0x0]
800020bc:	58 08       	cp.w	r8,0
800020be:	c0 71       	brne	800020cc <app_cfg+0x38>
				{
					//xcmp_data_session();
					//xcmp_audio_route_mic();
					//xcmp_button_config();
					//xcmp_audio_route_speaker();
					xcmp_enter_device_control_mode();//调换3个命令的顺序，则不会导致掉线。。。奇葩
800020c0:	f0 1f 00 13 	mcall	8000210c <app_cfg+0x78>
					xcmp_enter_enhanced_OB_mode();
800020c4:	f0 1f 00 13 	mcall	80002110 <app_cfg+0x7c>
					//xcmp_unmute_speaker();
					//Speaker_is_unmute = 1;
					//xcmp_function_mic();
					
					isAudioRouting = 1;
800020c8:	89 03       	st.w	r4[0x0],r3
800020ca:	c1 48       	rjmp	800020f2 <app_cfg+0x5e>
				}
				else if(isAudioRouting == 1)
800020cc:	58 18       	cp.w	r8,1
800020ce:	c0 71       	brne	800020dc <app_cfg+0x48>
				{
					xcmp_exit_device_control_mode();
800020d0:	f0 1f 00 11 	mcall	80002114 <app_cfg+0x80>
					xcmp_audio_route_AMBE();
800020d4:	f0 1f 00 11 	mcall	80002118 <app_cfg+0x84>
					//xcmp_button_config();
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//log("\n\r time: %d \n\r", tc_tick);
					
					isAudioRouting = 2;
800020d8:	89 00       	st.w	r4[0x0],r0
800020da:	c0 c8       	rjmp	800020f2 <app_cfg+0x5e>
					//isAudioRouting++;
				}
				else if(isAudioRouting == 2)
800020dc:	58 28       	cp.w	r8,2
800020de:	c0 31       	brne	800020e4 <app_cfg+0x50>
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_mute_speaker();	
					//log("\n\r time: %d \n\r", tc_tick); 
					isAudioRouting = 3;
800020e0:	89 02       	st.w	r4[0x0],r2
800020e2:	c0 88       	rjmp	800020f2 <app_cfg+0x5e>
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_exit_enhanced_OB_mode();
					//xcmp_mute_speaker();
					//xcmp_enhanced_OB_mode();
					isAudioRouting = 4;
800020e4:	58 38       	cp.w	r8,3
800020e6:	e9 f1 0a 00 	st.weq	r4[0x0],r1
					
				}
				else
				{
					isAudioRouting++;
800020ea:	f7 b8 01 ff 	subne	r8,-1
800020ee:	e9 f8 1a 00 	st.wne	r4[0x0],r8
			
		}
		//vTaskDelay(300*2 / portTICK_RATE_MS);//延迟300ms
		//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
		
		vTaskDelayUntil( &xLastWakeTime, 1000*2 / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
800020f2:	0a 9b       	mov	r11,r5
800020f4:	0e 9c       	mov	r12,r7
800020f6:	f0 1f 00 0a 	mcall	8000211c <app_cfg+0x88>
	}
800020fa:	cd bb       	rjmp	800020b0 <app_cfg+0x1c>
800020fc:	80 00       	ld.sh	r0,r0[0x0]
800020fe:	5b e8       	cp.w	r8,-2
80002100:	00 00       	add	r0,r0
80002102:	0a 48       	or	r8,r5
80002104:	00 00       	add	r0,r0
80002106:	0d 94       	ld.ub	r4,r6[0x1]
80002108:	00 00       	add	r0,r0
8000210a:	0a 44       	or	r4,r5
8000210c:	80 00       	ld.sh	r0,r0[0x0]
8000210e:	3e ec       	mov	r12,-18
80002110:	80 00       	ld.sh	r0,r0[0x0]
80002112:	3f 78       	mov	r8,-9
80002114:	80 00       	ld.sh	r0,r0[0x0]
80002116:	3e bc       	mov	r12,-21
80002118:	80 00       	ld.sh	r0,r0[0x0]
8000211a:	3f 18       	mov	r8,-15
8000211c:	80 00       	ld.sh	r0,r0[0x0]
8000211e:	5d 50       	*unknown*

80002120 <app_payload_tx_proc>:

}


static void app_payload_tx_proc(void  * payload)
{
80002120:	d4 01       	pushm	lr
  log("R");
80002122:	48 3c       	lddpc	r12,8000212c <app_payload_tx_proc+0xc>
80002124:	f0 1f 00 03 	mcall	80002130 <app_payload_tx_proc+0x10>
  //
  //
  //set_payload_idle(payload);


}
80002128:	d8 02       	popm	pc
8000212a:	00 00       	add	r0,r0
8000212c:	80 00       	ld.sh	r0,r0[0x0]
8000212e:	c4 08       	rjmp	800021ae <EnOB_reply_func+0x2a>
80002130:	80 00       	ld.sh	r0,r0[0x0]
80002132:	62 74       	ld.w	r4,r1[0x1c]

80002134 <FD_brdcst_func>:
	
	
}

void FD_brdcst_func(xcmp_fragment_t * xcmp)
{
80002134:	d4 01       	pushm	lr
	
	
	log("\n\r Forward Data Broadcast \n\r");
80002136:	48 3c       	lddpc	r12,80002140 <FD_brdcst_func+0xc>
80002138:	f0 1f 00 03 	mcall	80002144 <FD_brdcst_func+0x10>
	
}
8000213c:	d8 02       	popm	pc
8000213e:	00 00       	add	r0,r0
80002140:	80 00       	ld.sh	r0,r0[0x0]
80002142:	c4 0c       	rcall	800021c2 <EnOB_reply_func+0x3e>
80002144:	80 00       	ld.sh	r0,r0[0x0]
80002146:	62 74       	ld.w	r4,r1[0x1c]

80002148 <FD_reply_func>:
	
	
}

void FD_reply_func(xcmp_fragment_t * xcmp)
{
80002148:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Reply \n\r");
8000214a:	48 3c       	lddpc	r12,80002154 <FD_reply_func+0xc>
8000214c:	f0 1f 00 03 	mcall	80002158 <FD_reply_func+0x10>
	
	
}
80002150:	d8 02       	popm	pc
80002152:	00 00       	add	r0,r0
80002154:	80 00       	ld.sh	r0,r0[0x0]
80002156:	c4 2c       	rcall	800021da <EnOB_reply_func+0x56>
80002158:	80 00       	ld.sh	r0,r0[0x0]
8000215a:	62 74       	ld.w	r4,r1[0x1c]

8000215c <FD_request_func>:
}



void FD_request_func(xcmp_fragment_t * xcmp)
{
8000215c:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Request \n\r");
8000215e:	48 3c       	lddpc	r12,80002168 <FD_request_func+0xc>
80002160:	f0 1f 00 03 	mcall	8000216c <FD_request_func+0x10>
	
	
}
80002164:	d8 02       	popm	pc
80002166:	00 00       	add	r0,r0
80002168:	80 00       	ld.sh	r0,r0[0x0]
8000216a:	c4 48       	rjmp	800021f2 <EnOB_reply_func+0x6e>
8000216c:	80 00       	ld.sh	r0,r0[0x0]
8000216e:	62 74       	ld.w	r4,r1[0x1c]

80002170 <EnOB_brdcst_func>:
	
	
}

void EnOB_brdcst_func(xcmp_fragment_t * xcmp)
{
80002170:	d4 01       	pushm	lr
	
	
	log("\n\r En_OB Broadcast \n\r");
80002172:	48 3c       	lddpc	r12,8000217c <EnOB_brdcst_func+0xc>
80002174:	f0 1f 00 03 	mcall	80002180 <EnOB_brdcst_func+0x10>
}
80002178:	d8 02       	popm	pc
8000217a:	00 00       	add	r0,r0
8000217c:	80 00       	ld.sh	r0,r0[0x0]
8000217e:	c4 64       	brge	8000220a <SingleDetection_brdcst_func+0x16>
80002180:	80 00       	ld.sh	r0,r0[0x0]
80002182:	62 74       	ld.w	r4,r1[0x1c]

80002184 <EnOB_reply_func>:
}



void EnOB_reply_func(xcmp_fragment_t * xcmp)
{
80002184:	eb cd 40 80 	pushm	r7,lr
80002188:	18 97       	mov	r7,r12
		/*point to xcmp payload*/
	//En_OB_Control_reply_t *ptr = (En_OB_Control_reply_t* )xcmp->u8;
	//log("\n\r Xcmp_opcode: %x \n\r", xcmp->xcmp_opcode);
	
	if (xcmp->u8[0]== xcmp_Res_Success)
8000218a:	19 a9       	ld.ub	r9,r12[0x2]
8000218c:	30 08       	mov	r8,0
8000218e:	f0 09 18 00 	cp.b	r9,r8
80002192:	c1 91       	brne	800021c4 <EnOB_reply_func+0x40>
	{
		if (xcmp->u8[1] == EN_OB_Enter)
80002194:	19 b8       	ld.ub	r8,r12[0x3]
80002196:	30 19       	mov	r9,1
80002198:	f2 08 18 00 	cp.b	r8,r9
8000219c:	c0 61       	brne	800021a8 <EnOB_reply_func+0x24>
		{
		
			log("\n\r En_OB_Enter OK \n\r");
8000219e:	49 0c       	lddpc	r12,800021dc <EnOB_reply_func+0x58>
800021a0:	f0 1f 00 10 	mcall	800021e0 <EnOB_reply_func+0x5c>
800021a4:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else if (xcmp->u8[1] == EN_OB_Exit )
800021a8:	58 08       	cp.w	r8,0
800021aa:	c0 61       	brne	800021b6 <EnOB_reply_func+0x32>
		{
			log("\n\r En_OB_Exit OK \n\r");
800021ac:	48 ec       	lddpc	r12,800021e4 <EnOB_reply_func+0x60>
800021ae:	f0 1f 00 0d 	mcall	800021e0 <EnOB_reply_func+0x5c>
800021b2:	e3 cd 80 80 	ldm	sp++,r7,pc
		}
		else
		{
			
			log("\n\r En_OB_Control: %x \n\r", xcmp->u8[1]);
800021b6:	1a d8       	st.w	--sp,r8
800021b8:	48 cc       	lddpc	r12,800021e8 <EnOB_reply_func+0x64>
800021ba:	f0 1f 00 0a 	mcall	800021e0 <EnOB_reply_func+0x5c>
800021be:	2f fd       	sub	sp,-4
800021c0:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r En_OB_Control error \n\r");
800021c4:	48 ac       	lddpc	r12,800021ec <EnOB_reply_func+0x68>
800021c6:	f0 1f 00 07 	mcall	800021e0 <EnOB_reply_func+0x5c>
		log("\n\r En_OB_result: %x \n\r", xcmp->u8[0]);
800021ca:	0f a8       	ld.ub	r8,r7[0x2]
800021cc:	1a d8       	st.w	--sp,r8
800021ce:	48 9c       	lddpc	r12,800021f0 <EnOB_reply_func+0x6c>
800021d0:	f0 1f 00 04 	mcall	800021e0 <EnOB_reply_func+0x5c>
800021d4:	2f fd       	sub	sp,-4
800021d6:	e3 cd 80 80 	ldm	sp++,r7,pc
800021da:	00 00       	add	r0,r0
800021dc:	80 00       	ld.sh	r0,r0[0x0]
800021de:	c4 7c       	rcall	8000226c <ButtonConfig_brdcst_func+0x5c>
800021e0:	80 00       	ld.sh	r0,r0[0x0]
800021e2:	62 74       	ld.w	r4,r1[0x1c]
800021e4:	80 00       	ld.sh	r0,r0[0x0]
800021e6:	c4 94       	brge	80002278 <ButtonConfig_brdcst_func+0x68>
800021e8:	80 00       	ld.sh	r0,r0[0x0]
800021ea:	c4 a8       	rjmp	8000227e <ButtonConfig_brdcst_func+0x6e>
800021ec:	80 00       	ld.sh	r0,r0[0x0]
800021ee:	c4 c0       	breq	80002286 <ButtonConfig_brdcst_func+0x76>
800021f0:	80 00       	ld.sh	r0,r0[0x0]
800021f2:	c4 dc       	rcall	8000228c <ButtonConfig_brdcst_func+0x7c>

800021f4 <SingleDetection_brdcst_func>:
	
}


void SingleDetection_brdcst_func(xcmp_fragment_t * xcmp)
{
800021f4:	d4 01       	pushm	lr
	if (xcmp->u8[0] == 0x11)
800021f6:	19 a9       	ld.ub	r9,r12[0x2]
800021f8:	31 18       	mov	r8,17
800021fa:	f0 09 18 00 	cp.b	r9,r8
800021fe:	c0 41       	brne	80002206 <SingleDetection_brdcst_func+0x12>
	{
		log("\n\r DMR_CSBK OK \n\r");
80002200:	48 2c       	lddpc	r12,80002208 <SingleDetection_brdcst_func+0x14>
80002202:	f0 1f 00 03 	mcall	8000220c <SingleDetection_brdcst_func+0x18>
80002206:	d8 02       	popm	pc
80002208:	80 00       	ld.sh	r0,r0[0x0]
8000220a:	c4 f4       	brge	800022a8 <ButtonConfig_brdcst_func+0x98>
8000220c:	80 00       	ld.sh	r0,r0[0x0]
8000220e:	62 74       	ld.w	r4,r1[0x1c]

80002210 <ButtonConfig_brdcst_func>:
	
}


void ButtonConfig_brdcst_func(xcmp_fragment_t * xcmp)
{
80002210:	d4 31       	pushm	r0-r7,lr
	U8 Num_Button =0;
	U8 i = 0 ;
	/*point to xcmp payload*/
	ButtonConfig_brdcst_t  *ptr = (ButtonConfig_brdcst_t* )xcmp->u8;
80002212:	f8 c7 ff fe 	sub	r7,r12,-2
	
	Num_Button = ptr->NumOfButtons;
80002216:	0f 95       	ld.ub	r5,r7[0x1]
	
	log("\n\r ButtonConfig_broadcast  \n\r"  );
80002218:	4a bc       	lddpc	r12,800022c4 <ButtonConfig_brdcst_func+0xb4>
8000221a:	f0 1f 00 2c 	mcall	800022c8 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r Function: %X \n\r" , ptr->Function );
8000221e:	0f 88       	ld.ub	r8,r7[0x0]
80002220:	1a d8       	st.w	--sp,r8
80002222:	4a bc       	lddpc	r12,800022cc <ButtonConfig_brdcst_func+0xbc>
80002224:	f0 1f 00 29 	mcall	800022c8 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
80002228:	1a d5       	st.w	--sp,r5
8000222a:	4a ac       	lddpc	r12,800022d0 <ButtonConfig_brdcst_func+0xc0>
8000222c:	f0 1f 00 27 	mcall	800022c8 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
80002230:	0f a8       	ld.ub	r8,r7[0x2]
80002232:	1a d8       	st.w	--sp,r8
80002234:	4a 8c       	lddpc	r12,800022d4 <ButtonConfig_brdcst_func+0xc4>
80002236:	f0 1f 00 25 	mcall	800022c8 <ButtonConfig_brdcst_func+0xb8>
	
	for (i; i<Num_Button; i++)
8000223a:	2f dd       	sub	sp,-12
8000223c:	58 05       	cp.w	r5,0
8000223e:	c4 10       	breq	800022c0 <ButtonConfig_brdcst_func+0xb0>
80002240:	30 06       	mov	r6,0
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
80002242:	4a 64       	lddpc	r4,800022d8 <ButtonConfig_brdcst_func+0xc8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
80002244:	4a 63       	lddpc	r3,800022dc <ButtonConfig_brdcst_func+0xcc>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
80002246:	4a 72       	lddpc	r2,800022e0 <ButtonConfig_brdcst_func+0xd0>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
80002248:	4a 71       	lddpc	r1,800022e4 <ButtonConfig_brdcst_func+0xd4>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
8000224a:	4a 80       	lddpc	r0,800022e8 <ButtonConfig_brdcst_func+0xd8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
8000224c:	0f b9       	ld.ub	r9,r7[0x3]
8000224e:	0f c8       	ld.ub	r8,r7[0x4]
80002250:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002254:	1a d8       	st.w	--sp,r8
80002256:	1a d6       	st.w	--sp,r6
80002258:	08 9c       	mov	r12,r4
8000225a:	f0 1f 00 1c 	mcall	800022c8 <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
8000225e:	0f d9       	ld.ub	r9,r7[0x5]
80002260:	0f e8       	ld.ub	r8,r7[0x6]
80002262:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002266:	1a d8       	st.w	--sp,r8
80002268:	1a d6       	st.w	--sp,r6
8000226a:	06 9c       	mov	r12,r3
8000226c:	f0 1f 00 17 	mcall	800022c8 <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
80002270:	0f f9       	ld.ub	r9,r7[0x7]
80002272:	ef 38 00 08 	ld.ub	r8,r7[8]
80002276:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000227a:	1a d8       	st.w	--sp,r8
8000227c:	1a d6       	st.w	--sp,r6
8000227e:	04 9c       	mov	r12,r2
80002280:	f0 1f 00 12 	mcall	800022c8 <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
80002284:	ef 39 00 09 	ld.ub	r9,r7[9]
80002288:	ef 38 00 0a 	ld.ub	r8,r7[10]
8000228c:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002290:	1a d8       	st.w	--sp,r8
80002292:	1a d6       	st.w	--sp,r6
80002294:	02 9c       	mov	r12,r1
80002296:	f0 1f 00 0d 	mcall	800022c8 <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
8000229a:	2f 8d       	sub	sp,-32
8000229c:	ef 39 00 0b 	ld.ub	r9,r7[11]
800022a0:	ef 38 00 0c 	ld.ub	r8,r7[12]
800022a4:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800022a8:	1a d8       	st.w	--sp,r8
800022aa:	1a d6       	st.w	--sp,r6
800022ac:	00 9c       	mov	r12,r0
800022ae:	f0 1f 00 07 	mcall	800022c8 <ButtonConfig_brdcst_func+0xb8>
800022b2:	2f f6       	sub	r6,-1
800022b4:	2f 67       	sub	r7,-10
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
800022b6:	2f ed       	sub	sp,-8
800022b8:	ec 05 18 00 	cp.b	r5,r6
800022bc:	fe 9b ff c8 	brhi	8000224c <ButtonConfig_brdcst_func+0x3c>
800022c0:	d8 32       	popm	r0-r7,pc
800022c2:	00 00       	add	r0,r0
800022c4:	80 00       	ld.sh	r0,r0[0x0]
800022c6:	c5 08       	rjmp	80002366 <ButtonConfig_reply_func+0x2>
800022c8:	80 00       	ld.sh	r0,r0[0x0]
800022ca:	62 74       	ld.w	r4,r1[0x1c]
800022cc:	80 00       	ld.sh	r0,r0[0x0]
800022ce:	c5 28       	rjmp	80002372 <ButtonConfig_reply_func+0xe>
800022d0:	80 00       	ld.sh	r0,r0[0x0]
800022d2:	c5 3c       	rcall	80002378 <ButtonConfig_reply_func+0x14>
800022d4:	80 00       	ld.sh	r0,r0[0x0]
800022d6:	c5 54       	brge	80002380 <ButtonConfig_reply_func+0x1c>
800022d8:	80 00       	ld.sh	r0,r0[0x0]
800022da:	c5 74       	brge	80002388 <ButtonConfig_reply_func+0x24>
800022dc:	80 00       	ld.sh	r0,r0[0x0]
800022de:	c5 9c       	rcall	80002390 <ButtonConfig_reply_func+0x2c>
800022e0:	80 00       	ld.sh	r0,r0[0x0]
800022e2:	c5 c4       	brge	8000239a <ButtonConfig_reply_func+0x36>
800022e4:	80 00       	ld.sh	r0,r0[0x0]
800022e6:	c5 e8       	rjmp	800023a2 <ButtonConfig_reply_func+0x3e>
800022e8:	80 00       	ld.sh	r0,r0[0x0]
800022ea:	c6 10       	breq	800023ac <DataSession_brdcst_func+0x4>

800022ec <Phyuserinput_brdcst_func>:
	
}


void Phyuserinput_brdcst_func(xcmp_fragment_t * xcmp)
{
800022ec:	eb cd 40 fc 	pushm	r2-r7,lr
	U16 PUI_ID =0;
	U8 PUI_State =0;
	U8 PUI_State_Min_Value =0;
	U8 PUI_State_Max_Value =0;
	
	PUI_Source = xcmp->u8[0];
800022f0:	19 a6       	ld.ub	r6,r12[0x2]
	PUI_Type = xcmp ->u8[1];
800022f2:	19 b5       	ld.ub	r5,r12[0x3]
	PUI_ID = ((xcmp->u8[2]<<8) | xcmp->u8[3]);
800022f4:	19 c7       	ld.ub	r7,r12[0x4]
800022f6:	19 d8       	ld.ub	r8,r12[0x5]
800022f8:	f1 e7 10 87 	or	r7,r8,r7<<0x8
	PUI_State = xcmp->u8[4];
800022fc:	19 e4       	ld.ub	r4,r12[0x6]
	PUI_State_Min_Value = xcmp->u8[5];
800022fe:	19 f3       	ld.ub	r3,r12[0x7]
	PUI_State_Max_Value = xcmp->u8[6];
80002300:	f9 32 00 08 	ld.ub	r2,r12[8]
	
	log("\n\r PhysicalUserInput_broadcast  \n\r"  );
80002304:	49 0c       	lddpc	r12,80002344 <Phyuserinput_brdcst_func+0x58>
80002306:	f0 1f 00 11 	mcall	80002348 <Phyuserinput_brdcst_func+0x5c>
	
	log("\n\r PUI_Source: %X \n\r" , PUI_Source);
8000230a:	1a d6       	st.w	--sp,r6
8000230c:	49 0c       	lddpc	r12,8000234c <Phyuserinput_brdcst_func+0x60>
8000230e:	f0 1f 00 0f 	mcall	80002348 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_Type: %X \n\r" , PUI_Type);
80002312:	1a d5       	st.w	--sp,r5
80002314:	48 fc       	lddpc	r12,80002350 <Phyuserinput_brdcst_func+0x64>
80002316:	f0 1f 00 0d 	mcall	80002348 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_ID: %X \n\r" , PUI_ID);
8000231a:	5c 77       	castu.h	r7
8000231c:	1a d7       	st.w	--sp,r7
8000231e:	48 ec       	lddpc	r12,80002354 <Phyuserinput_brdcst_func+0x68>
80002320:	f0 1f 00 0a 	mcall	80002348 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_State: %X \n\r" , PUI_State);
80002324:	1a d4       	st.w	--sp,r4
80002326:	48 dc       	lddpc	r12,80002358 <Phyuserinput_brdcst_func+0x6c>
80002328:	f0 1f 00 08 	mcall	80002348 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_State_Min_Value: %X \n\r" , PUI_State_Min_Value);
8000232c:	1a d3       	st.w	--sp,r3
8000232e:	48 cc       	lddpc	r12,8000235c <Phyuserinput_brdcst_func+0x70>
80002330:	f0 1f 00 06 	mcall	80002348 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_State_Max_Value: %X \n\r" , PUI_State_Max_Value);
80002334:	1a d2       	st.w	--sp,r2
80002336:	48 bc       	lddpc	r12,80002360 <Phyuserinput_brdcst_func+0x74>
80002338:	f0 1f 00 04 	mcall	80002348 <Phyuserinput_brdcst_func+0x5c>
8000233c:	2f ad       	sub	sp,-24
	
	
	
	
	
}
8000233e:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80002342:	00 00       	add	r0,r0
80002344:	80 00       	ld.sh	r0,r0[0x0]
80002346:	c6 34       	brge	8000240c <DataSession_brdcst_func+0x64>
80002348:	80 00       	ld.sh	r0,r0[0x0]
8000234a:	62 74       	ld.w	r4,r1[0x1c]
8000234c:	80 00       	ld.sh	r0,r0[0x0]
8000234e:	c6 58       	rjmp	80002418 <DataSession_brdcst_func+0x70>
80002350:	80 00       	ld.sh	r0,r0[0x0]
80002352:	c6 70       	breq	80002420 <DataSession_brdcst_func+0x78>
80002354:	80 00       	ld.sh	r0,r0[0x0]
80002356:	c6 84       	brge	80002426 <DataSession_brdcst_func+0x7e>
80002358:	80 00       	ld.sh	r0,r0[0x0]
8000235a:	c6 98       	rjmp	8000242c <DataSession_reply_func>
8000235c:	80 00       	ld.sh	r0,r0[0x0]
8000235e:	c6 ac       	rcall	80002432 <DataSession_reply_func+0x6>
80002360:	80 00       	ld.sh	r0,r0[0x0]
80002362:	c6 cc       	rcall	8000243a <DataSession_reply_func+0xe>

80002364 <ButtonConfig_reply_func>:
	}
	
}

void ButtonConfig_reply_func(xcmp_fragment_t * xcmp)
{
80002364:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	ButtonConfig_reply_t *ptr = (ButtonConfig_reply_t* )(xcmp->u8);
80002368:	f8 c7 ff fe 	sub	r7,r12,-2
	if (ptr->Result == xcmp_Res_Success)
8000236c:	0f 89       	ld.ub	r9,r7[0x0]
8000236e:	30 08       	mov	r8,0
80002370:	f0 09 18 00 	cp.b	r9,r8
80002374:	c0 c1       	brne	8000238c <ButtonConfig_reply_func+0x28>
	{
		log("\n\r Button_Config OK \n\r");
80002376:	48 9c       	lddpc	r12,80002398 <ButtonConfig_reply_func+0x34>
80002378:	f0 1f 00 09 	mcall	8000239c <ButtonConfig_reply_func+0x38>
		
		log("\n\r Function: %X \n\r" , ptr->Function );
8000237c:	0f 98       	ld.ub	r8,r7[0x1]
8000237e:	1a d8       	st.w	--sp,r8
80002380:	48 8c       	lddpc	r12,800023a0 <ButtonConfig_reply_func+0x3c>
80002382:	f0 1f 00 07 	mcall	8000239c <ButtonConfig_reply_func+0x38>
80002386:	2f fd       	sub	sp,-4
80002388:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r Button_Request error \n\r");
8000238c:	48 6c       	lddpc	r12,800023a4 <ButtonConfig_reply_func+0x40>
8000238e:	f0 1f 00 04 	mcall	8000239c <ButtonConfig_reply_func+0x38>
80002392:	e3 cd 80 80 	ldm	sp++,r7,pc
80002396:	00 00       	add	r0,r0
80002398:	80 00       	ld.sh	r0,r0[0x0]
8000239a:	c6 ec       	rcall	80002476 <DataSession_reply_func+0x4a>
8000239c:	80 00       	ld.sh	r0,r0[0x0]
8000239e:	62 74       	ld.w	r4,r1[0x1c]
800023a0:	80 00       	ld.sh	r0,r0[0x0]
800023a2:	c5 28       	rjmp	80002446 <DataSession_reply_func+0x1a>
800023a4:	80 00       	ld.sh	r0,r0[0x0]
800023a6:	c7 04       	brge	80002486 <CallControl_brdcst_func+0x2>

800023a8 <DataSession_brdcst_func>:
	}
	
}

void DataSession_brdcst_func(xcmp_fragment_t * xcmp)
{
800023a8:	d4 21       	pushm	r4-r7,lr
	U8 Session_number = 0;
	U16 data_length = 0;
	U8 i = 0;
	/*point to xcmp payload*/
	DataSession_brdcst_t *ptr = (DataSession_brdcst_t* )xcmp->u8;
800023aa:	f8 c6 ff fe 	sub	r6,r12,-2

	if (ptr->State == CSBK_DATA_RX_Suc)
800023ae:	0d 88       	ld.ub	r8,r6[0x0]
800023b0:	32 49       	mov	r9,36
800023b2:	f2 08 18 00 	cp.b	r8,r9
800023b6:	c2 91       	brne	80002408 <DataSession_brdcst_func+0x60>
	{
		
		log("\n\r CSBK_RX OK \n\r");
800023b8:	49 7c       	lddpc	r12,80002414 <DataSession_brdcst_func+0x6c>
800023ba:	f0 1f 00 18 	mcall	80002418 <DataSession_brdcst_func+0x70>
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
800023be:	0d a5       	ld.ub	r5,r6[0x2]
800023c0:	0d b8       	ld.ub	r8,r6[0x3]
800023c2:	f1 e5 10 85 	or	r5,r8,r5<<0x8
800023c6:	5c 85       	casts.h	r5

		log("\n\r Session_ID: %x \n\r",Session_number );
800023c8:	0d 98       	ld.ub	r8,r6[0x1]
800023ca:	1a d8       	st.w	--sp,r8
800023cc:	49 4c       	lddpc	r12,8000241c <DataSession_brdcst_func+0x74>
800023ce:	f0 1f 00 13 	mcall	80002418 <DataSession_brdcst_func+0x70>
		log("\n\r paylaod_length: %d \n\r",data_length );
800023d2:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
800023d6:	1a d8       	st.w	--sp,r8
800023d8:	49 2c       	lddpc	r12,80002420 <DataSession_brdcst_func+0x78>
800023da:	f0 1f 00 10 	mcall	80002418 <DataSession_brdcst_func+0x70>
		for(i=0; i<data_length; i++)
800023de:	2f ed       	sub	sp,-8
800023e0:	58 05       	cp.w	r5,0
800023e2:	c1 80       	breq	80002412 <DataSession_brdcst_func+0x6a>
800023e4:	30 07       	mov	r7,0
		{
			
			//log("\n\r payload[%d]: %X \n\r", i, xcmp->u8[4+i]);
			log("\n\r payload[%d]: %X \n\r", i, ptr->DataPayload.DataPayload[i]);
800023e6:	49 04       	lddpc	r4,80002424 <DataSession_brdcst_func+0x7c>
800023e8:	ec 07 00 08 	add	r8,r6,r7
800023ec:	11 c8       	ld.ub	r8,r8[0x4]
800023ee:	1a d8       	st.w	--sp,r8
800023f0:	1a d7       	st.w	--sp,r7
800023f2:	08 9c       	mov	r12,r4
800023f4:	f0 1f 00 09 	mcall	80002418 <DataSession_brdcst_func+0x70>
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);

		log("\n\r Session_ID: %x \n\r",Session_number );
		log("\n\r paylaod_length: %d \n\r",data_length );
		for(i=0; i<data_length; i++)
800023f8:	2f f7       	sub	r7,-1
800023fa:	5c 57       	castu.b	r7
800023fc:	2f ed       	sub	sp,-8
800023fe:	ee 05 19 00 	cp.h	r5,r7
80002402:	fe 9b ff f3 	brhi	800023e8 <DataSession_brdcst_func+0x40>
80002406:	d8 22       	popm	r4-r7,pc
		
	}
	else
	{
		//log("\n\r State: 0x %X \n\r", xcmp->u8[0]);
		log("\n\r State: 0x %X \n\r", ptr->State);
80002408:	1a d8       	st.w	--sp,r8
8000240a:	48 8c       	lddpc	r12,80002428 <DataSession_brdcst_func+0x80>
8000240c:	f0 1f 00 03 	mcall	80002418 <DataSession_brdcst_func+0x70>
80002410:	2f fd       	sub	sp,-4
80002412:	d8 22       	popm	r4-r7,pc
80002414:	80 00       	ld.sh	r0,r0[0x0]
80002416:	c7 20       	breq	800024fa <TransmitControl_brdcst_func+0x32>
80002418:	80 00       	ld.sh	r0,r0[0x0]
8000241a:	62 74       	ld.w	r4,r1[0x1c]
8000241c:	80 00       	ld.sh	r0,r0[0x0]
8000241e:	c7 34       	brge	80002504 <TransmitControl_brdcst_func+0x3c>
80002420:	80 00       	ld.sh	r0,r0[0x0]
80002422:	c7 4c       	rcall	8000250a <TransmitControl_brdcst_func+0x42>
80002424:	80 00       	ld.sh	r0,r0[0x0]
80002426:	c7 68       	rjmp	80002512 <TransmitControl_reply_func+0x2>
80002428:	80 00       	ld.sh	r0,r0[0x0]
8000242a:	c7 80       	breq	8000251a <TransmitControl_reply_func+0xa>

8000242c <DataSession_reply_func>:
}



void DataSession_reply_func(xcmp_fragment_t * xcmp)
{
8000242c:	eb cd 40 80 	pushm	r7,lr
80002430:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
80002432:	19 a8       	ld.ub	r8,r12[0x2]
80002434:	58 08       	cp.w	r8,0
80002436:	c0 61       	brne	80002442 <DataSession_reply_func+0x16>
	{
		log("\n\r DATArep OK \n\r");
80002438:	48 dc       	lddpc	r12,8000246c <DataSession_reply_func+0x40>
8000243a:	f0 1f 00 0e 	mcall	80002470 <DataSession_reply_func+0x44>
8000243e:	e3 cd 80 80 	ldm	sp++,r7,pc
		//log("\n\r ID: 0x %X \n\r", xcmp->u8[2]);
		
	}
	else
	{
		log("\n\r Result:  %X \n\r", xcmp->u8[0]);
80002442:	1a d8       	st.w	--sp,r8
80002444:	48 cc       	lddpc	r12,80002474 <DataSession_reply_func+0x48>
80002446:	f0 1f 00 0b 	mcall	80002470 <DataSession_reply_func+0x44>
		log("\n\r DATArep error \n\r");
8000244a:	48 cc       	lddpc	r12,80002478 <DataSession_reply_func+0x4c>
8000244c:	f0 1f 00 09 	mcall	80002470 <DataSession_reply_func+0x44>
		log("\n\r Func:  %X \n\r", xcmp->u8[1]);
80002450:	0f b8       	ld.ub	r8,r7[0x3]
80002452:	1a d8       	st.w	--sp,r8
80002454:	48 ac       	lddpc	r12,8000247c <DataSession_reply_func+0x50>
80002456:	f0 1f 00 07 	mcall	80002470 <DataSession_reply_func+0x44>
		log("\n\r ID:  %X \n\r", xcmp->u8[2]);
8000245a:	0f c8       	ld.ub	r8,r7[0x4]
8000245c:	1a d8       	st.w	--sp,r8
8000245e:	48 9c       	lddpc	r12,80002480 <DataSession_reply_func+0x54>
80002460:	f0 1f 00 04 	mcall	80002470 <DataSession_reply_func+0x44>
80002464:	2f dd       	sub	sp,-12
80002466:	e3 cd 80 80 	ldm	sp++,r7,pc
8000246a:	00 00       	add	r0,r0
8000246c:	80 00       	ld.sh	r0,r0[0x0]
8000246e:	c7 94       	brge	80002560 <TransmitControl_reply_func+0x50>
80002470:	80 00       	ld.sh	r0,r0[0x0]
80002472:	62 74       	ld.w	r4,r1[0x1c]
80002474:	80 00       	ld.sh	r0,r0[0x0]
80002476:	c7 a8       	rjmp	8000256a <TransmitControl_reply_func+0x5a>
80002478:	80 00       	ld.sh	r0,r0[0x0]
8000247a:	c7 bc       	rcall	80002570 <Volume_reply_func>
8000247c:	80 00       	ld.sh	r0,r0[0x0]
8000247e:	c7 d0       	breq	80002578 <Volume_reply_func+0x8>
80002480:	80 00       	ld.sh	r0,r0[0x0]
80002482:	c7 e0       	breq	8000257e <Volume_reply_func+0xe>

80002484 <CallControl_brdcst_func>:
	
}


void CallControl_brdcst_func(xcmp_fragment_t * xcmp)
{
80002484:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	CallControl_brdcst_t *ptr = (CallControl_brdcst_t* )xcmp->u8;
80002488:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  CallControl brst \n\r ");
	//log("\n\r  Call_type: %x \n\r ", ptr->Calltype );
	log("\n\r  Call_state: %x \n\r ", ptr->Callstate );
8000248c:	0f 98       	ld.ub	r8,r7[0x1]
8000248e:	1a d8       	st.w	--sp,r8
80002490:	48 bc       	lddpc	r12,800024bc <CallControl_brdcst_func+0x38>
80002492:	f0 1f 00 0c 	mcall	800024c0 <CallControl_brdcst_func+0x3c>
	if (ptr->Callstate == Call_Ended)//0x03
80002496:	2f fd       	sub	sp,-4
80002498:	0f 99       	ld.ub	r9,r7[0x1]
8000249a:	30 38       	mov	r8,3
8000249c:	f0 09 18 00 	cp.b	r9,r8
800024a0:	c0 41       	brne	800024a8 <CallControl_brdcst_func+0x24>
	{
		//恢复正常语音路径通道
		//xcmp_audio_route_revert();
		Call_Begin = 0;
800024a2:	30 09       	mov	r9,0
800024a4:	48 88       	lddpc	r8,800024c4 <CallControl_brdcst_func+0x40>
800024a6:	b0 89       	st.b	r8[0x0],r9
		
	}
	
	if (ptr->Callstate == Call_Initiated)//0x04
800024a8:	0f 99       	ld.ub	r9,r7[0x1]
800024aa:	30 48       	mov	r8,4
800024ac:	f0 09 18 00 	cp.b	r9,r8
800024b0:	c0 41       	brne	800024b8 <CallControl_brdcst_func+0x34>
	{
		Call_Begin = 1;
800024b2:	30 19       	mov	r9,1
800024b4:	48 48       	lddpc	r8,800024c4 <CallControl_brdcst_func+0x40>
800024b6:	b0 89       	st.b	r8[0x0],r9
800024b8:	e3 cd 80 80 	ldm	sp++,r7,pc
800024bc:	80 00       	ld.sh	r0,r0[0x0]
800024be:	c7 f0       	breq	800025bc <Volume_reply_func+0x4c>
800024c0:	80 00       	ld.sh	r0,r0[0x0]
800024c2:	62 74       	ld.w	r4,r1[0x1c]
800024c4:	00 00       	add	r0,r0
800024c6:	0a 4d       	or	sp,r5

800024c8 <TransmitControl_brdcst_func>:

}


void TransmitControl_brdcst_func(xcmp_fragment_t * xcmp)
{
800024c8:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	TransmitControl_brdcast_t *ptr = (TransmitControl_brdcast_t* )xcmp->u8;
800024cc:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  TransmitControl broadcast \n\r ");
	//log("\n\r  Mode_Of_Operation: %x \n\r ", ptr->Mode_Of_Operation );
	if (ptr->State == 0x00)
800024d0:	0f 99       	ld.ub	r9,r7[0x1]
800024d2:	30 08       	mov	r8,0
800024d4:	f0 09 18 00 	cp.b	r9,r8
800024d8:	c0 71       	brne	800024e6 <TransmitControl_brdcst_func+0x1e>
	{
		log("\n\r  Standby-Receive \n\r ");
800024da:	48 ac       	lddpc	r12,80002500 <TransmitControl_brdcst_func+0x38>
800024dc:	f0 1f 00 0a 	mcall	80002504 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 0;
800024e0:	30 09       	mov	r9,0
800024e2:	48 a8       	lddpc	r8,80002508 <TransmitControl_brdcst_func+0x40>
800024e4:	b0 89       	st.b	r8[0x0],r9
	}
	if (ptr->State == 0x01)
800024e6:	0f 99       	ld.ub	r9,r7[0x1]
800024e8:	30 18       	mov	r8,1
800024ea:	f0 09 18 00 	cp.b	r9,r8
800024ee:	c0 71       	brne	800024fc <TransmitControl_brdcst_func+0x34>
	{
		log("\n\r  Transmit \n\r ");
800024f0:	48 7c       	lddpc	r12,8000250c <TransmitControl_brdcst_func+0x44>
800024f2:	f0 1f 00 05 	mcall	80002504 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 1;
800024f6:	30 19       	mov	r9,1
800024f8:	48 48       	lddpc	r8,80002508 <TransmitControl_brdcst_func+0x40>
800024fa:	b0 89       	st.b	r8[0x0],r9
800024fc:	e3 cd 80 80 	ldm	sp++,r7,pc
80002500:	80 00       	ld.sh	r0,r0[0x0]
80002502:	c8 08       	rjmp	80002602 <spk_brdcst_func+0x2e>
80002504:	80 00       	ld.sh	r0,r0[0x0]
80002506:	62 74       	ld.w	r4,r1[0x1c]
80002508:	00 00       	add	r0,r0
8000250a:	0a 4c       	or	r12,r5
8000250c:	80 00       	ld.sh	r0,r0[0x0]
8000250e:	c8 20       	breq	80002412 <DataSession_brdcst_func+0x6a>

80002510 <TransmitControl_reply_func>:




void TransmitControl_reply_func(xcmp_fragment_t * xcmp)
{
80002510:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	TransmitControl_reply_t *ptr = (TransmitControl_reply_t* )xcmp->u8;
80002514:	f8 c7 ff fe 	sub	r7,r12,-2
	
	if (ptr->Result == xcmp_Res_Success)
80002518:	0f 89       	ld.ub	r9,r7[0x0]
8000251a:	30 08       	mov	r8,0
8000251c:	f0 09 18 00 	cp.b	r9,r8
80002520:	c1 61       	brne	8000254c <TransmitControl_reply_func+0x3c>
	{
		
		log("\n\r  TransmitControl OK \n\r ");
80002522:	48 ec       	lddpc	r12,80002558 <TransmitControl_reply_func+0x48>
80002524:	f0 1f 00 0e 	mcall	8000255c <TransmitControl_reply_func+0x4c>
		log("\n\r Function: %x \n\r", ptr->Function);
80002528:	0f 98       	ld.ub	r8,r7[0x1]
8000252a:	1a d8       	st.w	--sp,r8
8000252c:	48 dc       	lddpc	r12,80002560 <TransmitControl_reply_func+0x50>
8000252e:	f0 1f 00 0c 	mcall	8000255c <TransmitControl_reply_func+0x4c>
		log("\n\r Mode of Operation: %x \n\r", ptr->Mode_Of_Operation);
80002532:	0f a8       	ld.ub	r8,r7[0x2]
80002534:	1a d8       	st.w	--sp,r8
80002536:	48 cc       	lddpc	r12,80002564 <TransmitControl_reply_func+0x54>
80002538:	f0 1f 00 09 	mcall	8000255c <TransmitControl_reply_func+0x4c>
		log("\n\r State: %x \n\r", ptr->State);
8000253c:	0f b8       	ld.ub	r8,r7[0x3]
8000253e:	1a d8       	st.w	--sp,r8
80002540:	48 ac       	lddpc	r12,80002568 <TransmitControl_reply_func+0x58>
80002542:	f0 1f 00 07 	mcall	8000255c <TransmitControl_reply_func+0x4c>
80002546:	2f dd       	sub	sp,-12
80002548:	e3 cd 80 80 	ldm	sp++,r7,pc
		
		//Silent_flag = 1;
	}
	else
	{
		log("TransmitControl error");
8000254c:	48 8c       	lddpc	r12,8000256c <TransmitControl_reply_func+0x5c>
8000254e:	f0 1f 00 04 	mcall	8000255c <TransmitControl_reply_func+0x4c>
80002552:	e3 cd 80 80 	ldm	sp++,r7,pc
80002556:	00 00       	add	r0,r0
80002558:	80 00       	ld.sh	r0,r0[0x0]
8000255a:	c8 34       	brge	80002460 <DataSession_reply_func+0x34>
8000255c:	80 00       	ld.sh	r0,r0[0x0]
8000255e:	62 74       	ld.w	r4,r1[0x1c]
80002560:	80 00       	ld.sh	r0,r0[0x0]
80002562:	c8 50       	breq	8000246c <DataSession_reply_func+0x40>
80002564:	80 00       	ld.sh	r0,r0[0x0]
80002566:	c8 64       	brge	80002472 <DataSession_reply_func+0x46>
80002568:	80 00       	ld.sh	r0,r0[0x0]
8000256a:	c8 80       	breq	8000247a <DataSession_reply_func+0x4e>
8000256c:	80 00       	ld.sh	r0,r0[0x0]
8000256e:	c8 90       	breq	80002480 <DataSession_reply_func+0x54>

80002570 <Volume_reply_func>:
	
}


void Volume_reply_func(xcmp_fragment_t * xcmp)
{
80002570:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	VolumeControl_reply_t *ptr = (VolumeControl_reply_t* )xcmp->u8;
80002574:	f8 c7 ff fe 	sub	r7,r12,-2
	
		if (ptr->Result == xcmp_Res_Success)
80002578:	0f 89       	ld.ub	r9,r7[0x0]
8000257a:	30 08       	mov	r8,0
8000257c:	f0 09 18 00 	cp.b	r9,r8
80002580:	c1 b1       	brne	800025b6 <Volume_reply_func+0x46>
		{
			if (ptr->Function == Enable_IntelligentAudio)
80002582:	0f b8       	ld.ub	r8,r7[0x3]
80002584:	31 09       	mov	r9,16
80002586:	f2 08 18 00 	cp.b	r8,r9
8000258a:	c0 f1       	brne	800025a8 <Volume_reply_func+0x38>
			{
				log("\n\r Enable_IA OK \n\r");
8000258c:	48 dc       	lddpc	r12,800025c0 <Volume_reply_func+0x50>
8000258e:	f0 1f 00 0e 	mcall	800025c4 <Volume_reply_func+0x54>
				log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
80002592:	0f 99       	ld.ub	r9,r7[0x1]
80002594:	0f a8       	ld.ub	r8,r7[0x2]
80002596:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000259a:	1a d8       	st.w	--sp,r8
8000259c:	48 bc       	lddpc	r12,800025c8 <Volume_reply_func+0x58>
8000259e:	f0 1f 00 0a 	mcall	800025c4 <Volume_reply_func+0x54>
800025a2:	2f fd       	sub	sp,-4
800025a4:	e3 cd 80 80 	ldm	sp++,r7,pc
	
			}
			else
			{
				
				log("\n\r VolumeControl: %x \n\r", ptr->Function);
800025a8:	1a d8       	st.w	--sp,r8
800025aa:	48 9c       	lddpc	r12,800025cc <Volume_reply_func+0x5c>
800025ac:	f0 1f 00 06 	mcall	800025c4 <Volume_reply_func+0x54>
800025b0:	2f fd       	sub	sp,-4
800025b2:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		
		else
		{
			log("\n\r Enable_IA error \n\r");
800025b6:	48 7c       	lddpc	r12,800025d0 <Volume_reply_func+0x60>
800025b8:	f0 1f 00 03 	mcall	800025c4 <Volume_reply_func+0x54>
800025bc:	e3 cd 80 80 	ldm	sp++,r7,pc
800025c0:	80 00       	ld.sh	r0,r0[0x0]
800025c2:	c8 a8       	rjmp	800026d6 <mic_reply_func+0x2a>
800025c4:	80 00       	ld.sh	r0,r0[0x0]
800025c6:	62 74       	ld.w	r4,r1[0x1c]
800025c8:	80 00       	ld.sh	r0,r0[0x0]
800025ca:	c8 bc       	rcall	800026e0 <mic_reply_func+0x34>
800025cc:	80 00       	ld.sh	r0,r0[0x0]
800025ce:	c8 d8       	rjmp	800026e8 <mic_reply_func+0x3c>
800025d0:	80 00       	ld.sh	r0,r0[0x0]
800025d2:	c8 f0       	breq	800024f0 <TransmitControl_brdcst_func+0x28>

800025d4 <spk_brdcst_func>:
		log("spk error");
	}
}

void spk_brdcst_func(xcmp_fragment_t * xcmp)
{
800025d4:	d4 01       	pushm	lr
	if (xcmp->u8[3] == xcmp_Res_Success)//0x0000:mute
800025d6:	19 d9       	ld.ub	r9,r12[0x5]
800025d8:	30 08       	mov	r8,0
800025da:	f0 09 18 00 	cp.b	r9,r8
800025de:	c0 81       	brne	800025ee <spk_brdcst_func+0x1a>
	{
		Speaker_is_unmute =0;
800025e0:	10 99       	mov	r9,r8
800025e2:	48 78       	lddpc	r8,800025fc <spk_brdcst_func+0x28>
800025e4:	b0 89       	st.b	r8[0x0],r9
		//Silent_flag = 0;
		log("spk_s_close ");
800025e6:	48 7c       	lddpc	r12,80002600 <spk_brdcst_func+0x2c>
800025e8:	f0 1f 00 07 	mcall	80002604 <spk_brdcst_func+0x30>
800025ec:	d8 02       	popm	pc
		
	}
	else
	{
		//Silent_flag = 1;
		Speaker_is_unmute = 1;
800025ee:	30 19       	mov	r9,1
800025f0:	48 38       	lddpc	r8,800025fc <spk_brdcst_func+0x28>
800025f2:	b0 89       	st.b	r8[0x0],r9
		log("spk_s_open ");	
800025f4:	48 5c       	lddpc	r12,80002608 <spk_brdcst_func+0x34>
800025f6:	f0 1f 00 04 	mcall	80002604 <spk_brdcst_func+0x30>
800025fa:	d8 02       	popm	pc
800025fc:	00 00       	add	r0,r0
800025fe:	0a 38       	cp.w	r8,r5
80002600:	80 00       	ld.sh	r0,r0[0x0]
80002602:	c9 08       	rjmp	80002722 <mic_reply_func+0x76>
80002604:	80 00       	ld.sh	r0,r0[0x0]
80002606:	62 74       	ld.w	r4,r1[0x1c]
80002608:	80 00       	ld.sh	r0,r0[0x0]
8000260a:	c9 18       	rjmp	8000272c <mic_reply_func+0x80>

8000260c <spk_reply_func>:
			
	
}

void spk_reply_func(xcmp_fragment_t * xcmp)
{
8000260c:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
8000260e:	19 a9       	ld.ub	r9,r12[0x2]
80002610:	30 08       	mov	r8,0
80002612:	f0 09 18 00 	cp.b	r9,r8
80002616:	c0 f1       	brne	80002634 <spk_reply_func+0x28>
	{
		
		if(xcmp->u8[4])
80002618:	19 e9       	ld.ub	r9,r12[0x6]
8000261a:	f0 09 18 00 	cp.b	r9,r8
8000261e:	c0 40       	breq	80002626 <spk_reply_func+0x1a>
		{
			Speaker_is_unmute = 1;
80002620:	30 19       	mov	r9,1
80002622:	48 98       	lddpc	r8,80002644 <spk_reply_func+0x38>
80002624:	b0 89       	st.b	r8[0x0],r9
			
			//Silent_flag = 1;
		}
		log("spk OK -st%2x", xcmp->u8[4] );
80002626:	19 e8       	ld.ub	r8,r12[0x6]
80002628:	1a d8       	st.w	--sp,r8
8000262a:	48 8c       	lddpc	r12,80002648 <spk_reply_func+0x3c>
8000262c:	f0 1f 00 08 	mcall	8000264c <spk_reply_func+0x40>
80002630:	2f fd       	sub	sp,-4
80002632:	d8 02       	popm	pc
		
	}
	else
	{
		Speaker_is_unmute = 0;
80002634:	30 09       	mov	r9,0
80002636:	48 48       	lddpc	r8,80002644 <spk_reply_func+0x38>
80002638:	b0 89       	st.b	r8[0x0],r9
		log("spk error");
8000263a:	48 6c       	lddpc	r12,80002650 <spk_reply_func+0x44>
8000263c:	f0 1f 00 04 	mcall	8000264c <spk_reply_func+0x40>
80002640:	d8 02       	popm	pc
80002642:	00 00       	add	r0,r0
80002644:	00 00       	add	r0,r0
80002646:	0a 38       	cp.w	r8,r5
80002648:	80 00       	ld.sh	r0,r0[0x0]
8000264a:	c9 24       	brge	8000256e <TransmitControl_reply_func+0x5e>
8000264c:	80 00       	ld.sh	r0,r0[0x0]
8000264e:	62 74       	ld.w	r4,r1[0x1c]
80002650:	80 00       	ld.sh	r0,r0[0x0]
80002652:	c9 34       	brge	80002578 <Volume_reply_func+0x8>

80002654 <mic_brdcst_func>:
	
	
}

void mic_brdcst_func(xcmp_fragment_t * xcmp)
{
80002654:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_brdcast_t *ptr = (MicControl_brdcast_t* )xcmp->u8;
80002658:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r Mic_brdcst \n\r");		
	//log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
	//log("\n\r Signal_type: %x \n\r " ,  ptr->Signaling_Type);
	if (ptr->Mic_State == 0x00)
8000265c:	0f a9       	ld.ub	r9,r7[0x2]
8000265e:	30 08       	mov	r8,0
80002660:	f0 09 18 00 	cp.b	r9,r8
80002664:	c0 71       	brne	80002672 <mic_brdcst_func+0x1e>
	{
		log("\n\r Mic_Disabled \n\r");	
80002666:	48 dc       	lddpc	r12,80002698 <mic_brdcst_func+0x44>
80002668:	f0 1f 00 0d 	mcall	8000269c <mic_brdcst_func+0x48>
		Mic_is_Enabled = 0;
8000266c:	30 09       	mov	r9,0
8000266e:	48 d8       	lddpc	r8,800026a0 <mic_brdcst_func+0x4c>
80002670:	b0 89       	st.b	r8[0x0],r9
	} 
	if(ptr->Mic_State == 0x11)
80002672:	0f a9       	ld.ub	r9,r7[0x2]
80002674:	31 18       	mov	r8,17
80002676:	f0 09 18 00 	cp.b	r9,r8
8000267a:	c0 d1       	brne	80002694 <mic_brdcst_func+0x40>
	{
		log("\n\r Mic_Enabled \n\r");
8000267c:	48 ac       	lddpc	r12,800026a4 <mic_brdcst_func+0x50>
8000267e:	f0 1f 00 08 	mcall	8000269c <mic_brdcst_func+0x48>
		Mic_is_Enabled = 1;
80002682:	48 89       	lddpc	r9,800026a0 <mic_brdcst_func+0x4c>
80002684:	30 18       	mov	r8,1
80002686:	b2 88       	st.b	r9[0x0],r8
		
		if ((Mic_is_Enabled == 1) && (Call_Begin == 1))
80002688:	13 89       	ld.ub	r9,r9[0x0]
8000268a:	f0 09 18 00 	cp.b	r9,r8
8000268e:	c0 31       	brne	80002694 <mic_brdcst_func+0x40>
80002690:	48 68       	lddpc	r8,800026a8 <mic_brdcst_func+0x54>
80002692:	11 88       	ld.ub	r8,r8[0x0]
80002694:	e3 cd 80 80 	ldm	sp++,r7,pc
80002698:	80 00       	ld.sh	r0,r0[0x0]
8000269a:	c9 40       	breq	800025c2 <Volume_reply_func+0x52>
8000269c:	80 00       	ld.sh	r0,r0[0x0]
8000269e:	62 74       	ld.w	r4,r1[0x1c]
800026a0:	00 00       	add	r0,r0
800026a2:	0a 51       	eor	r1,r5
800026a4:	80 00       	ld.sh	r0,r0[0x0]
800026a6:	c9 54       	brge	800025d0 <Volume_reply_func+0x60>
800026a8:	00 00       	add	r0,r0
800026aa:	0a 4d       	or	sp,r5

800026ac <mic_reply_func>:
	
	
}

void mic_reply_func(xcmp_fragment_t * xcmp)
{
800026ac:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_reply_t *ptr = (MicControl_reply_t* )xcmp->u8;
800026b0:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Mic_reply \n\r");
800026b4:	49 ac       	lddpc	r12,8000271c <mic_reply_func+0x70>
800026b6:	f0 1f 00 1b 	mcall	80002720 <mic_reply_func+0x74>
	if (ptr->Result == 0x00)
800026ba:	0f 89       	ld.ub	r9,r7[0x0]
800026bc:	30 08       	mov	r8,0
800026be:	f0 09 18 00 	cp.b	r9,r8
800026c2:	c2 71       	brne	80002710 <mic_reply_func+0x64>
	{
		
		if (ptr->Function == Mic_Disable)
800026c4:	0f 98       	ld.ub	r8,r7[0x1]
800026c6:	30 29       	mov	r9,2
800026c8:	f2 08 18 00 	cp.b	r8,r9
800026cc:	c1 b1       	brne	80002702 <mic_reply_func+0x56>
		{
		
			log("\n\r Mic_close_ok \n\r " );
800026ce:	49 6c       	lddpc	r12,80002724 <mic_reply_func+0x78>
800026d0:	f0 1f 00 14 	mcall	80002720 <mic_reply_func+0x74>
			log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
800026d4:	0f a8       	ld.ub	r8,r7[0x2]
800026d6:	1a d8       	st.w	--sp,r8
800026d8:	49 4c       	lddpc	r12,80002728 <mic_reply_func+0x7c>
800026da:	f0 1f 00 12 	mcall	80002720 <mic_reply_func+0x74>
			log("\n\r Signaling_type: %x \n\r " ,  ptr->Signaling_Type);
800026de:	0f b8       	ld.ub	r8,r7[0x3]
800026e0:	1a d8       	st.w	--sp,r8
800026e2:	49 3c       	lddpc	r12,8000272c <mic_reply_func+0x80>
800026e4:	f0 1f 00 0f 	mcall	80002720 <mic_reply_func+0x74>
			log("\n\r Mic_state: %x \n\r " ,  ptr->Mic_State);
800026e8:	0f c8       	ld.ub	r8,r7[0x4]
800026ea:	1a d8       	st.w	--sp,r8
800026ec:	49 1c       	lddpc	r12,80002730 <mic_reply_func+0x84>
800026ee:	f0 1f 00 0d 	mcall	80002720 <mic_reply_func+0x74>
			log("\n\r Gain_offset: %x \n\r " ,  ptr->Gain_Offset);
800026f2:	0f d8       	ld.ub	r8,r7[0x5]
800026f4:	1a d8       	st.w	--sp,r8
800026f6:	49 0c       	lddpc	r12,80002734 <mic_reply_func+0x88>
800026f8:	f0 1f 00 0a 	mcall	80002720 <mic_reply_func+0x74>
800026fc:	2f cd       	sub	sp,-16
800026fe:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else
		{
			log("\n\r Mic_function: %x \n\r ", ptr->Function );
80002702:	1a d8       	st.w	--sp,r8
80002704:	48 dc       	lddpc	r12,80002738 <mic_reply_func+0x8c>
80002706:	f0 1f 00 07 	mcall	80002720 <mic_reply_func+0x74>
8000270a:	2f fd       	sub	sp,-4
8000270c:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else 
	{
		
	
		log("\n\r Mic error \n\r");
80002710:	48 bc       	lddpc	r12,8000273c <mic_reply_func+0x90>
80002712:	f0 1f 00 04 	mcall	80002720 <mic_reply_func+0x74>
80002716:	e3 cd 80 80 	ldm	sp++,r7,pc
8000271a:	00 00       	add	r0,r0
8000271c:	80 00       	ld.sh	r0,r0[0x0]
8000271e:	c9 68       	rjmp	8000284a <app_payload_rx_proc+0x32>
80002720:	80 00       	ld.sh	r0,r0[0x0]
80002722:	62 74       	ld.w	r4,r1[0x1c]
80002724:	80 00       	ld.sh	r0,r0[0x0]
80002726:	c9 78       	rjmp	80002854 <app_payload_rx_proc+0x3c>
80002728:	80 00       	ld.sh	r0,r0[0x0]
8000272a:	c9 8c       	rcall	8000285a <app_payload_rx_proc+0x42>
8000272c:	80 00       	ld.sh	r0,r0[0x0]
8000272e:	c9 a0       	breq	80002662 <mic_brdcst_func+0xe>
80002730:	80 00       	ld.sh	r0,r0[0x0]
80002732:	c9 bc       	rcall	80002868 <AudioRoutingControl_reply_func+0x4>
80002734:	80 00       	ld.sh	r0,r0[0x0]
80002736:	c9 d4       	brge	80002670 <mic_brdcst_func+0x1c>
80002738:	80 00       	ld.sh	r0,r0[0x0]
8000273a:	c9 ec       	rcall	80002876 <AudioRoutingControl_reply_func+0x12>
8000273c:	80 00       	ld.sh	r0,r0[0x0]
8000273e:	ca 04       	brge	8000267e <mic_brdcst_func+0x2a>

80002740 <dcm_brdcst_func>:
	}
}


void dcm_brdcst_func(xcmp_fragment_t * xcmp)
{
80002740:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	DeviceControlMode_brdcst_t *ptr = (DeviceControlMode_brdcst_t* )xcmp->u8;
80002744:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Dcm_brdcst \n\r");		
80002748:	48 bc       	lddpc	r12,80002774 <dcm_brdcst_func+0x34>
8000274a:	f0 1f 00 0c 	mcall	80002778 <dcm_brdcst_func+0x38>
	log("\n\r Function: %x \n\r " ,  ptr->Function);
8000274e:	0f 88       	ld.ub	r8,r7[0x0]
80002750:	1a d8       	st.w	--sp,r8
80002752:	48 bc       	lddpc	r12,8000277c <dcm_brdcst_func+0x3c>
80002754:	f0 1f 00 09 	mcall	80002778 <dcm_brdcst_func+0x38>
	log("\n\r ControlType: %x \n\r " ,  ptr->ControlType);
80002758:	0f a8       	ld.ub	r8,r7[0x2]
8000275a:	1a d8       	st.w	--sp,r8
8000275c:	48 9c       	lddpc	r12,80002780 <dcm_brdcst_func+0x40>
8000275e:	f0 1f 00 07 	mcall	80002778 <dcm_brdcst_func+0x38>
	log("\n\r ControlTypeSize: %x \n\r " ,  ptr->ControlTypeSize);
80002762:	0f 98       	ld.ub	r8,r7[0x1]
80002764:	1a d8       	st.w	--sp,r8
80002766:	48 8c       	lddpc	r12,80002784 <dcm_brdcst_func+0x44>
80002768:	f0 1f 00 04 	mcall	80002778 <dcm_brdcst_func+0x38>
8000276c:	2f dd       	sub	sp,-12
	
	
}
8000276e:	e3 cd 80 80 	ldm	sp++,r7,pc
80002772:	00 00       	add	r0,r0
80002774:	80 00       	ld.sh	r0,r0[0x0]
80002776:	ca 14       	brge	800026b8 <mic_reply_func+0xc>
80002778:	80 00       	ld.sh	r0,r0[0x0]
8000277a:	62 74       	ld.w	r4,r1[0x1c]
8000277c:	80 00       	ld.sh	r0,r0[0x0]
8000277e:	ca 28       	rjmp	800028c2 <DeviceInitializationStatus_brdcst_func+0x2e>
80002780:	80 00       	ld.sh	r0,r0[0x0]
80002782:	ca 3c       	rcall	800028c8 <DeviceInitializationStatus_brdcst_func+0x34>
80002784:	80 00       	ld.sh	r0,r0[0x0]
80002786:	ca 54       	brge	800026d0 <mic_reply_func+0x24>

80002788 <dcm_reply_func>:
		log("Tone error");
	}
}

void dcm_reply_func(xcmp_fragment_t * xcmp)
{
80002788:	eb cd 40 80 	pushm	r7,lr
8000278c:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
8000278e:	19 a9       	ld.ub	r9,r12[0x2]
80002790:	30 08       	mov	r8,0
80002792:	f0 09 18 00 	cp.b	r9,r8
80002796:	c1 b1       	brne	800027cc <dcm_reply_func+0x44>
	{
		if(xcmp->u8[1] == DCM_ENTER)
80002798:	19 b8       	ld.ub	r8,r12[0x3]
8000279a:	30 19       	mov	r9,1
8000279c:	f2 08 18 00 	cp.b	r8,r9
800027a0:	c0 51       	brne	800027aa <dcm_reply_func+0x22>
		{
			log("\n\r Dcm-Enter OK \n\r");
800027a2:	48 ec       	lddpc	r12,800027d8 <dcm_reply_func+0x50>
800027a4:	f0 1f 00 0e 	mcall	800027dc <dcm_reply_func+0x54>
800027a8:	c0 a8       	rjmp	800027bc <dcm_reply_func+0x34>
			
		}
		else if (xcmp->u8[1] == DCM_EXIT)
800027aa:	58 08       	cp.w	r8,0
800027ac:	c0 51       	brne	800027b6 <dcm_reply_func+0x2e>
		{
			log("\n\r Dcm-Exit OK \n\r");
800027ae:	48 dc       	lddpc	r12,800027e0 <dcm_reply_func+0x58>
800027b0:	f0 1f 00 0b 	mcall	800027dc <dcm_reply_func+0x54>
800027b4:	c0 48       	rjmp	800027bc <dcm_reply_func+0x34>
		}
		else
		{
			log("\n\r Dcm-Revoke \n\r");
800027b6:	48 cc       	lddpc	r12,800027e4 <dcm_reply_func+0x5c>
800027b8:	f0 1f 00 09 	mcall	800027dc <dcm_reply_func+0x54>
		}
		
		log("dcm OK-mo%X", xcmp->u8[3]);
800027bc:	0f d8       	ld.ub	r8,r7[0x5]
800027be:	1a d8       	st.w	--sp,r8
800027c0:	48 ac       	lddpc	r12,800027e8 <dcm_reply_func+0x60>
800027c2:	f0 1f 00 07 	mcall	800027dc <dcm_reply_func+0x54>
800027c6:	2f fd       	sub	sp,-4
800027c8:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		log("dcm error");
800027cc:	48 8c       	lddpc	r12,800027ec <dcm_reply_func+0x64>
800027ce:	f0 1f 00 04 	mcall	800027dc <dcm_reply_func+0x54>
800027d2:	e3 cd 80 80 	ldm	sp++,r7,pc
800027d6:	00 00       	add	r0,r0
800027d8:	80 00       	ld.sh	r0,r0[0x0]
800027da:	ca 70       	breq	80002728 <mic_reply_func+0x7c>
800027dc:	80 00       	ld.sh	r0,r0[0x0]
800027de:	62 74       	ld.w	r4,r1[0x1c]
800027e0:	80 00       	ld.sh	r0,r0[0x0]
800027e2:	ca 84       	brge	80002732 <mic_reply_func+0x86>
800027e4:	80 00       	ld.sh	r0,r0[0x0]
800027e6:	ca 98       	rjmp	80002938 <payload_rx_process+0x18>
800027e8:	80 00       	ld.sh	r0,r0[0x0]
800027ea:	ca ac       	rcall	8000293e <payload_rx_process+0x1e>
800027ec:	80 00       	ld.sh	r0,r0[0x0]
800027ee:	ca b8       	rjmp	80002944 <payload_rx_process+0x24>

800027f0 <ToneControl_reply_func>:
			}
		}
}

void ToneControl_reply_func(xcmp_fragment_t * xcmp)
{
800027f0:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
800027f2:	19 a9       	ld.ub	r9,r12[0x2]
800027f4:	30 08       	mov	r8,0
800027f6:	f0 09 18 00 	cp.b	r9,r8
800027fa:	c0 51       	brne	80002804 <ToneControl_reply_func+0x14>
	{		
		log("Tone OK");
800027fc:	48 4c       	lddpc	r12,8000280c <ToneControl_reply_func+0x1c>
800027fe:	f0 1f 00 05 	mcall	80002810 <ToneControl_reply_func+0x20>
80002802:	d8 02       	popm	pc
		//fl_write("/test.txt", FILE_END, (void *)"send tone ok\r\n", sizeof("send tone ok\r\n") - 1);
	}
	else
	{
		log("Tone error");
80002804:	48 4c       	lddpc	r12,80002814 <ToneControl_reply_func+0x24>
80002806:	f0 1f 00 03 	mcall	80002810 <ToneControl_reply_func+0x20>
8000280a:	d8 02       	popm	pc
8000280c:	80 00       	ld.sh	r0,r0[0x0]
8000280e:	ca c4       	brge	80002766 <dcm_brdcst_func+0x26>
80002810:	80 00       	ld.sh	r0,r0[0x0]
80002812:	62 74       	ld.w	r4,r1[0x1c]
80002814:	80 00       	ld.sh	r0,r0[0x0]
80002816:	ca cc       	rcall	8000296e <set_idle_store_isr+0x2>

80002818 <app_payload_rx_proc>:
	}
}


static void app_payload_rx_proc(void  * payload)
{
80002818:	eb cd 40 80 	pushm	r7,lr
8000281c:	18 97       	mov	r7,r12
	static  U8 times_counter = 0;
	
	times_counter++;
8000281e:	48 c9       	lddpc	r9,8000284c <app_payload_rx_proc+0x34>
80002820:	13 88       	ld.ub	r8,r9[0x0]
80002822:	2f f8       	sub	r8,-1
80002824:	b2 88       	st.b	r9[0x0],r8
	if (times_counter == 3)
80002826:	30 39       	mov	r9,3
80002828:	f2 08 18 00 	cp.b	r8,r9
8000282c:	c0 71       	brne	8000283a <app_payload_rx_proc+0x22>
	{
		times_counter = 0 ;
8000282e:	30 09       	mov	r9,0
80002830:	48 78       	lddpc	r8,8000284c <app_payload_rx_proc+0x34>
80002832:	b0 89       	st.b	r8[0x0],r9
		log("\n\r w: \n\r");
80002834:	48 7c       	lddpc	r12,80002850 <app_payload_rx_proc+0x38>
80002836:	f0 1f 00 08 	mcall	80002854 <app_payload_rx_proc+0x3c>
	}
	//log("\n\r w: \n\r");
	if (AMBE_tx_flag)//本地发送方的mic录音
8000283a:	48 88       	lddpc	r8,80002858 <app_payload_rx_proc+0x40>
8000283c:	11 88       	ld.ub	r8,r8[0x0]
	{
		//fl_write("PCMvo.pcm", FILE_END, payload, MAX_PAYLOAD_BUFF_SIZE * 2);
	}
	
	//payload_fragment_t * ptr = (payload_fragment_t *)payload;
	set_payload_idle(payload);
8000283e:	48 88       	lddpc	r8,8000285c <app_payload_rx_proc+0x44>
80002840:	70 0c       	ld.w	r12,r8[0x0]
80002842:	0e 9b       	mov	r11,r7
80002844:	f0 1f 00 07 	mcall	80002860 <app_payload_rx_proc+0x48>

}
80002848:	e3 cd 80 80 	ldm	sp++,r7,pc
8000284c:	00 00       	add	r0,r0
8000284e:	0a 50       	eor	r0,r5
80002850:	80 00       	ld.sh	r0,r0[0x0]
80002852:	ca d8       	rjmp	800029ac <phy_rx+0x24>
80002854:	80 00       	ld.sh	r0,r0[0x0]
80002856:	62 74       	ld.w	r4,r1[0x1c]
80002858:	00 00       	add	r0,r0
8000285a:	0a 52       	eor	r2,r5
8000285c:	00 00       	add	r0,r0
8000285e:	0a 6c       	and	r12,r5
80002860:	80 00       	ld.sh	r0,r0[0x0]
80002862:	29 c0       	sub	r0,-100

80002864 <AudioRoutingControl_reply_func>:
	
}


void AudioRoutingControl_reply_func(xcmp_fragment_t * xcmp)
{
80002864:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
80002866:	19 a9       	ld.ub	r9,r12[0x2]
80002868:	30 08       	mov	r8,0
8000286a:	f0 09 18 00 	cp.b	r9,r8
8000286e:	c0 71       	brne	8000287c <AudioRoutingControl_reply_func+0x18>
	{
		log("AudioRouting OK");
80002870:	48 5c       	lddpc	r12,80002884 <AudioRoutingControl_reply_func+0x20>
80002872:	f0 1f 00 06 	mcall	80002888 <AudioRoutingControl_reply_func+0x24>
		xcmp_IdleTestTone();//提示通道配置成功
80002876:	f0 1f 00 06 	mcall	8000288c <AudioRoutingControl_reply_func+0x28>
8000287a:	d8 02       	popm	pc
		//xcmp_IdleTestTone();
		//Speaker_is_unmute = 1;
	}
	else
	{
		log("AudioRouting error");
8000287c:	48 5c       	lddpc	r12,80002890 <AudioRoutingControl_reply_func+0x2c>
8000287e:	f0 1f 00 03 	mcall	80002888 <AudioRoutingControl_reply_func+0x24>
80002882:	d8 02       	popm	pc
80002884:	80 00       	ld.sh	r0,r0[0x0]
80002886:	ca e4       	brge	800027e2 <dcm_reply_func+0x5a>
80002888:	80 00       	ld.sh	r0,r0[0x0]
8000288a:	62 74       	ld.w	r4,r1[0x1c]
8000288c:	80 00       	ld.sh	r0,r0[0x0]
8000288e:	40 48       	lddsp	r8,sp[0x10]
80002890:	80 00       	ld.sh	r0,r0[0x0]
80002892:	ca f4       	brge	800027f0 <ToneControl_reply_func>

80002894 <DeviceInitializationStatus_brdcst_func>:
static void app_payload_tx_proc(void  * payload);

//app func--list

void DeviceInitializationStatus_brdcst_func(xcmp_fragment_t  * xcmp)
{
80002894:	d4 01       	pushm	lr
	if (xcmp->u8[4] == 0x01)
80002896:	19 e8       	ld.ub	r8,r12[0x6]
80002898:	30 19       	mov	r9,1
8000289a:	f2 08 18 00 	cp.b	r8,r9
8000289e:	c0 61       	brne	800028aa <DeviceInitializationStatus_brdcst_func+0x16>
	{
		bunchofrandomstatusflags |= 0x01;  //Need do nothing else.
800028a0:	48 98       	lddpc	r8,800028c4 <DeviceInitializationStatus_brdcst_func+0x30>
800028a2:	70 09       	ld.w	r9,r8[0x0]
800028a4:	a1 a9       	sbr	r9,0x0
800028a6:	91 09       	st.w	r8[0x0],r9
800028a8:	d8 02       	popm	pc
	}
	else if(xcmp->u8[4] != 0x02)
800028aa:	30 29       	mov	r9,2
800028ac:	f2 08 18 00 	cp.b	r8,r9
800028b0:	c0 80       	breq	800028c0 <DeviceInitializationStatus_brdcst_func+0x2c>
	{
		bunchofrandomstatusflags  &= 0xFFFFFFFC; //Device Init no longer Complete.
800028b2:	48 58       	lddpc	r8,800028c4 <DeviceInitializationStatus_brdcst_func+0x30>
800028b4:	70 09       	ld.w	r9,r8[0x0]
800028b6:	e0 19 ff fc 	andl	r9,0xfffc
800028ba:	91 09       	st.w	r8[0x0],r9
		xcmp_DeviceInitializationStatus_request();
800028bc:	f0 1f 00 03 	mcall	800028c8 <DeviceInitializationStatus_brdcst_func+0x34>
800028c0:	d8 02       	popm	pc
800028c2:	00 00       	add	r0,r0
800028c4:	00 00       	add	r0,r0
800028c6:	0d 94       	ld.ub	r4,r6[0x1]
800028c8:	80 00       	ld.sh	r0,r0[0x0]
800028ca:	3f 9c       	mov	r12,-7

800028cc <CalculateBurst>:
Calls:
Called By: phy_payload_rx
*/

volatile RxAMBEBurstType CalculateBurst(U8 vf_sn)
{
800028cc:	20 1c       	sub	r12,1
800028ce:	5c 5c       	castu.b	r12
800028d0:	31 18       	mov	r8,17
800028d2:	f0 0c 18 00 	cp.b	r12,r8
800028d6:	e0 88 00 03 	brls	800028dc <CalculateBurst+0x10>
800028da:	5e fd       	retal	0
800028dc:	48 28       	lddpc	r8,800028e4 <CalculateBurst+0x18>
800028de:	f0 0c 03 2c 	ld.w	r12,r8[r12<<0x2]
			Burst_ID = 0x00;
			return VOICE_WATING;
		
	}
	
}
800028e2:	5e fc       	retal	r12
800028e4:	80 00       	ld.sh	r0,r0[0x0]
800028e6:	cb 10       	breq	80002848 <app_payload_rx_proc+0x30>

800028e8 <payload_init>:
	Create the corresponding task;
Calls: xTaskCreate--freertos
Called By:app_init -- app.c
*/
void payload_init(void ( *payload_rx_func)(void * ), void ( *payload_tx_func)(void * ) )
{				
800028e8:	d4 01       	pushm	lr
	payload_rx_exec = payload_rx_func;
800028ea:	48 98       	lddpc	r8,8000290c <payload_init+0x24>
800028ec:	91 0c       	st.w	r8[0x0],r12
	payload_tx_exec = payload_tx_func;
800028ee:	48 98       	lddpc	r8,80002910 <payload_init+0x28>
800028f0:	91 0b       	st.w	r8[0x0],r11
	
	
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
800028f2:	30 09       	mov	r9,0
800028f4:	1a d9       	st.w	--sp,r9
800028f6:	1a d9       	st.w	--sp,r9
800028f8:	1a d9       	st.w	--sp,r9
800028fa:	30 28       	mov	r8,2
800028fc:	e0 6a 04 00 	mov	r10,1024
80002900:	48 5b       	lddpc	r11,80002914 <payload_init+0x2c>
80002902:	48 6c       	lddpc	r12,80002918 <payload_init+0x30>
80002904:	f0 1f 00 06 	mcall	8000291c <payload_init+0x34>
80002908:	2f dd       	sub	sp,-12
	//,  2
	//,  NULL
	//);
	//
	
}
8000290a:	d8 02       	popm	pc
8000290c:	00 00       	add	r0,r0
8000290e:	0a 58       	eor	r8,r5
80002910:	00 00       	add	r0,r0
80002912:	0a 5c       	eor	r12,r5
80002914:	80 00       	ld.sh	r0,r0[0x0]
80002916:	cb 58       	rjmp	80002a80 <phy_tx_func+0x1c>
80002918:	80 00       	ld.sh	r0,r0[0x0]
8000291a:	29 20       	sub	r0,-110
8000291c:	80 00       	ld.sh	r0,r0[0x0]
8000291e:	5e b0       	rethi	r0

80002920 <payload_rx_process>:
Description: Receive the payload
Calls:
Called By:task
*/
static void payload_rx_process(void * pvParameters)
{
80002920:	eb cd 40 f8 	pushm	r3-r7,lr
80002924:	20 1d       	sub	sp,4
	/*To store the elements in the queue*/
	U16  * payload_ptr;
		
	if(NULL ==   phy_payload_frame_rx)
80002926:	48 e8       	lddpc	r8,8000295c <payload_rx_process+0x3c>
80002928:	70 08       	ld.w	r8,r8[0x0]
8000292a:	58 08       	cp.w	r8,0
8000292c:	c0 71       	brne	8000293a <payload_rx_process+0x1a>
	{
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
8000292e:	30 4b       	mov	r11,4
80002930:	30 5c       	mov	r12,5
80002932:	f0 1f 00 0c 	mcall	80002960 <payload_rx_process+0x40>
80002936:	48 a8       	lddpc	r8,8000295c <payload_rx_process+0x3c>
80002938:	91 0c       	st.w	r8[0x0],r12
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_rx, &payload_ptr,portMAX_DELAY ))
8000293a:	48 96       	lddpc	r6,8000295c <payload_rx_process+0x3c>
8000293c:	30 05       	mov	r5,0
8000293e:	3f f4       	mov	r4,-1
		{			
			payload_rx_exec(payload_ptr);//app_payload_rx_proc();
80002940:	48 93       	lddpc	r3,80002964 <payload_rx_process+0x44>
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_rx, &payload_ptr,portMAX_DELAY ))
80002942:	6c 0c       	ld.w	r12,r6[0x0]
80002944:	0a 99       	mov	r9,r5
80002946:	08 9a       	mov	r10,r4
80002948:	1a 9b       	mov	r11,sp
8000294a:	f0 1f 00 08 	mcall	80002968 <payload_rx_process+0x48>
8000294e:	58 1c       	cp.w	r12,1
80002950:	cf 91       	brne	80002942 <payload_rx_process+0x22>
		{			
			payload_rx_exec(payload_ptr);//app_payload_rx_proc();
80002952:	66 08       	ld.w	r8,r3[0x0]
80002954:	40 0c       	lddsp	r12,sp[0x0]
80002956:	5d 18       	icall	r8
80002958:	cf 5b       	rjmp	80002942 <payload_rx_process+0x22>
8000295a:	00 00       	add	r0,r0
8000295c:	00 00       	add	r0,r0
8000295e:	0a 88       	andn	r8,r5
80002960:	80 00       	ld.sh	r0,r0[0x0]
80002962:	57 dc       	stdsp	sp[0x1f4],r12
80002964:	00 00       	add	r0,r0
80002966:	0a 58       	eor	r8,r5
80002968:	80 00       	ld.sh	r0,r0[0x0]
8000296a:	54 78       	stdsp	sp[0x11c],r8

8000296c <set_idle_store_isr>:
{
	xQueueSend(store, &ptr, 0);
}

void set_idle_store_isr(xQueueHandle store, void * ptr)
{
8000296c:	d4 01       	pushm	lr
8000296e:	20 2d       	sub	sp,8
80002970:	50 0b       	stdsp	sp[0x0],r11
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002972:	30 09       	mov	r9,0
80002974:	fa ca ff f8 	sub	r10,sp,-8
80002978:	14 d9       	st.w	--r10,r9
	xQueueSendFromISR(store, &ptr, &xHigherPriorityTaskWoken);
8000297a:	1a 9b       	mov	r11,sp
8000297c:	f0 1f 00 02 	mcall	80002984 <set_idle_store_isr+0x18>
}
80002980:	2f ed       	sub	sp,-8
80002982:	d8 02       	popm	pc
80002984:	80 00       	ld.sh	r0,r0[0x0]
80002986:	56 34       	stdsp	sp[0x18c],r4

80002988 <phy_rx>:
	xQueueSendFromISR -- freertos
Called By: phy_xnl_rx
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
80002988:	d4 01       	pushm	lr
8000298a:	20 2d       	sub	sp,8
8000298c:	50 0c       	stdsp	sp[0x0],r12
	//memcpy(xx, phy_ptr, sizeof(phy_fragment_t));
	//set_phy_idle_isr(&phy_ptr, &xHigherPriorityTaskWoken);
	
	Bool res = FALSE;
	
	if(NULL == phy_ptr)
8000298e:	58 0c       	cp.w	r12,0
80002990:	c1 10       	breq	800029b2 <phy_rx+0x2a>
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
    /*variables are used to store the push result in interrupt*/
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002992:	30 08       	mov	r8,0
80002994:	50 18       	stdsp	sp[0x4],r8
	if(NULL == phy_ptr)
	{
		return;
	}
	
    U16 phy_ctrl = phy_ptr->xnl_fragment.phy_header.phy_control;
80002996:	98 88       	ld.uh	r8,r12[0x0]
80002998:	e2 18 f0 00 	andl	r8,0xf000,COH
8000299c:	e0 48 40 00 	cp.w	r8,16384
800029a0:	c0 91       	brne	800029b2 <phy_rx+0x2a>

    if (XCMPXNL_DATA == (phy_ctrl & 0xF000))
    {
        /*push the xnl packet to queue*/
        if( pdTRUE == xQueueSendFromISR(
800029a2:	48 68       	lddpc	r8,800029b8 <phy_rx+0x30>
800029a4:	70 0c       	ld.w	r12,r8[0x0]
800029a6:	30 09       	mov	r9,0
800029a8:	fa ca ff fc 	sub	r10,sp,-4
800029ac:	1a 9b       	mov	r11,sp
800029ae:	f0 1f 00 04 	mcall	800029bc <phy_rx+0x34>
		}	

    }
		
 
}
800029b2:	2f ed       	sub	sp,-8
800029b4:	d8 02       	popm	pc
800029b6:	00 00       	add	r0,r0
800029b8:	00 00       	add	r0,r0
800029ba:	0a b8       	st.h	r5++,r8
800029bc:	80 00       	ld.sh	r0,r0[0x0]
800029be:	56 34       	stdsp	sp[0x18c],r4

800029c0 <set_idle_store>:
	}
}


void set_idle_store(xQueueHandle store, void * ptr)
{
800029c0:	eb cd 40 80 	pushm	r7,lr
800029c4:	20 1d       	sub	sp,4
800029c6:	fa c7 ff fc 	sub	r7,sp,-4
800029ca:	0e db       	st.w	--r7,r11
	xQueueSend(store, &ptr, 0);
800029cc:	30 09       	mov	r9,0
800029ce:	12 9a       	mov	r10,r9
800029d0:	1a 9b       	mov	r11,sp
800029d2:	f0 1f 00 03 	mcall	800029dc <set_idle_store+0x1c>
}
800029d6:	2f fd       	sub	sp,-4
800029d8:	e3 cd 80 80 	ldm	sp++,r7,pc
800029dc:	80 00       	ld.sh	r0,r0[0x0]
800029de:	56 84       	stdsp	sp[0x1a0],r4

800029e0 <phy_tx>:
Calls:   
	xQueueSend -- freertos
Called By: xnl_tx -- xnl.c
*/
void phy_tx(phy_fragment_t * phy)
{	
800029e0:	d4 01       	pushm	lr
800029e2:	20 1d       	sub	sp,4
800029e4:	50 0c       	stdsp	sp[0x0],r12
	
	//phy_fragment_t * phy_ptr = malloc(sizeof(phy_fragment_t));
	//memcpy(phy_ptr, phy, sizeof(phy_fragment_t));
	//log("\n\r T_xcmp:%4x \n\r", phy->xnl_fragment.xnl_payload.xnl_content_data_msg.xcmp_opcode);
	//log("T_xnl-opcode:%4x", xnl->xnl_header.opcode);//log:R_xnl指令	
	if(XCMPXNL_DATA == (phy_ctrl & 0xF000))
800029e6:	98 88       	ld.uh	r8,r12[0x0]
800029e8:	e2 18 f0 00 	andl	r8,0xf000,COH
800029ec:	e0 48 40 00 	cp.w	r8,16384
800029f0:	c0 d1       	brne	80002a0a <phy_tx+0x2a>
	{
		/*push the xnl packet to queue to send */
		if(NULL != phy_xnl_frame_tx)
800029f2:	49 08       	lddpc	r8,80002a30 <phy_tx+0x50>
800029f4:	70 08       	ld.w	r8,r8[0x0]
800029f6:	58 08       	cp.w	r8,0
800029f8:	c1 a0       	breq	80002a2c <phy_tx+0x4c>
		{
			if( pdTRUE == xQueueSend(phy_xnl_frame_tx, &phy, 0))
800029fa:	48 e8       	lddpc	r8,80002a30 <phy_tx+0x50>
800029fc:	70 0c       	ld.w	r12,r8[0x0]
800029fe:	30 09       	mov	r9,0
80002a00:	12 9a       	mov	r10,r9
80002a02:	1a 9b       	mov	r11,sp
80002a04:	f0 1f 00 0c 	mcall	80002a34 <phy_tx+0x54>
80002a08:	c1 28       	rjmp	80002a2c <phy_tx+0x4c>
		}
	}
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE		
	else if((SPEAKER_DATA == (phy_ctrl & 0xF000))
80002a0a:	e0 48 10 00 	cp.w	r8,4096
80002a0e:	5f 0a       	sreq	r10
80002a10:	e0 48 20 00 	cp.w	r8,8192
80002a14:	5f 09       	sreq	r9
80002a16:	f5 e9 10 09 	or	r9,r10,r9
80002a1a:	c0 71       	brne	80002a28 <phy_tx+0x48>
80002a1c:	e0 48 50 00 	cp.w	r8,20480
80002a20:	c0 40       	breq	80002a28 <phy_tx+0x48>
80002a22:	e0 48 60 00 	cp.w	r8,24576
80002a26:	c0 31       	brne	80002a2c <phy_tx+0x4c>
	    || (MIC_DATA  == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_RX == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_TX == (phy_ctrl & 0xF000))
	)
	{		
		if(NULL == phy_payload_frame_tx)
80002a28:	48 48       	lddpc	r8,80002a38 <phy_tx+0x58>
80002a2a:	70 08       	ld.w	r8,r8[0x0]
	
	if(res != TRUE)
	{
		//vPortFree(phy_ptr);
	}
}
80002a2c:	2f fd       	sub	sp,-4
80002a2e:	d8 02       	popm	pc
80002a30:	00 00       	add	r0,r0
80002a32:	0a c4       	st.b	r5++,r4
80002a34:	80 00       	ld.sh	r0,r0[0x0]
80002a36:	56 84       	stdsp	sp[0x1a0],r4
80002a38:	00 00       	add	r0,r0
80002a3a:	0a b4       	st.h	r5++,r4

80002a3c <get_idle_store_isr>:
		return NULL;
	}
}

void * get_idle_store_isr(xQueueHandle store)
{
80002a3c:	d4 01       	pushm	lr
80002a3e:	20 2d       	sub	sp,8
	void * ptr = NULL;
80002a40:	30 08       	mov	r8,0
80002a42:	50 18       	stdsp	sp[0x4],r8
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002a44:	50 08       	stdsp	sp[0x0],r8
	
	if(pdTRUE == xQueueReceiveFromISR(store, &ptr, &xHigherPriorityTaskWoken))
80002a46:	1a 9a       	mov	r10,sp
80002a48:	fa cb ff fc 	sub	r11,sp,-4
80002a4c:	f0 1f 00 05 	mcall	80002a60 <get_idle_store_isr+0x24>
80002a50:	58 1c       	cp.w	r12,1
80002a52:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80002a56:	fb fc 00 01 	ld.weq	r12,sp[0x4]
	}
	else
	{
		return NULL;
	}
}
80002a5a:	2f ed       	sub	sp,-8
80002a5c:	d8 02       	popm	pc
80002a5e:	00 00       	add	r0,r0
80002a60:	80 00       	ld.sh	r0,r0[0x0]
80002a62:	53 88       	stdsp	sp[0xe0],r8

80002a64 <phy_tx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_tx_func( void * ssc)
{
80002a64:	eb cd 40 c0 	pushm	r6-r7,lr
80002a68:	20 1d       	sub	sp,4
80002a6a:	18 97       	mov	r7,r12
    if(NULL != phy_xnl_frame_tx)
80002a6c:	fe f8 04 70 	ld.w	r8,pc[1136]
80002a70:	70 08       	ld.w	r8,r8[0x0]
80002a72:	58 08       	cp.w	r8,0
80002a74:	c7 40       	breq	80002b5c <phy_tx_func+0xf8>
    {
  	  	/*send ssc data in xnl frame*/
  	  	phy_xnl_tx(&(((ssc_fragment_t * )ssc)->xnl_channel));		
80002a76:	18 96       	mov	r6,r12
Called By:phy_tx_func
*/
static void phy_xnl_tx(xnl_channel_t * xnl_tx_channel)
{
	/*variables are used to store the push result in interrupt*/
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002a78:	30 08       	mov	r8,0
80002a7a:	50 08       	stdsp	sp[0x0],r8
	
	static S16 phy_tx_expexted_length = 0;
	static U8 phy_tx_index = 0;
	
	/*his is the code for handling any outgoing XNL Phy message*/
	switch(phy_tx_state)
80002a7c:	fe f8 04 64 	ld.w	r8,pc[1124]
80002a80:	70 08       	ld.w	r8,r8[0x0]
80002a82:	58 18       	cp.w	r8,1
80002a84:	c2 90       	breq	80002ad6 <phy_tx_func+0x72>
80002a86:	c0 43       	brcs	80002a8e <phy_tx_func+0x2a>
80002a88:	58 28       	cp.w	r8,2
80002a8a:	c6 91       	brne	80002b5c <phy_tx_func+0xf8>
80002a8c:	c6 18       	rjmp	80002b4e <phy_tx_func+0xea>
	{
		/*Waiting for the send xnl packet*/
		case WAITING_FOR_PHY_TX:			
			if( pdTRUE == xQueueReceiveFromISR(
80002a8e:	fe f8 04 4e 	ld.w	r8,pc[1102]
80002a92:	70 0c       	ld.w	r12,r8[0x0]
80002a94:	1a 9a       	mov	r10,sp
80002a96:	fe fb 04 4e 	ld.w	r11,pc[1102]
80002a9a:	f0 1f 01 14 	mcall	80002ee8 <phy_tx_func+0x484>
80002a9e:	58 1c       	cp.w	r12,1
80002aa0:	c1 51       	brne	80002aca <phy_tx_func+0x66>
				  phy_xnl_frame_tx
				, &phy_ptr
				, &xHigherPriorityTaskWoken 
			))
			{								
				phy_tx_expexted_length = 
80002aa2:	fe f8 04 42 	ld.w	r8,pc[1090]
80002aa6:	70 08       	ld.w	r8,r8[0x0]
80002aa8:	11 9a       	ld.ub	r10,r8[0x1]
80002aaa:	fe f9 04 42 	ld.w	r9,pc[1090]
80002aae:	b2 0a       	st.h	r9[0x0],r10
				*/
				xnl_tx_channel->dword = 
				                   phy_ptr->xnl_fragment.phy_header.phy_control;
				
				/*Transmit 0xABCD0000 | Type/Length.*/
				xnl_tx_channel->dword |= PHYHEADER32;
80002ab0:	90 88       	ld.uh	r8,r8[0x0]
80002ab2:	ea 18 ab cd 	orh	r8,0xabcd
80002ab6:	8f 18       	st.w	r7[0x4],r8
				
				phy_tx_index = 1;
80002ab8:	30 19       	mov	r9,1
80002aba:	fe f8 04 36 	ld.w	r8,pc[1078]
80002abe:	b0 89       	st.b	r8[0x0],r9
				phy_tx_state = WRITE_NEXT_DWORD;	
80002ac0:	30 19       	mov	r9,1
80002ac2:	fe f8 04 1e 	ld.w	r8,pc[1054]
80002ac6:	91 09       	st.w	r8[0x0],r9
80002ac8:	c4 a8       	rjmp	80002b5c <phy_tx_func+0xf8>
				/*The new transmission has started.*/
			}
			else
			{
				/*Nothing new to transmit, send an idle frame*/
				xnl_tx_channel->dword = XNL_IDLE;
80002aca:	e0 68 5a 5a 	mov	r8,23130
80002ace:	ea 18 ab cd 	orh	r8,0xabcd
80002ad2:	8f 18       	st.w	r7[0x4],r8
80002ad4:	c4 48       	rjmp	80002b5c <phy_tx_func+0xf8>
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80002ad6:	fe f9 04 1a 	ld.w	r9,pc[1050]
80002ada:	13 88       	ld.ub	r8,r9[0x0]
				xnl_tx_channel->dword = XNL_IDLE;
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
80002adc:	fe fa 04 08 	ld.w	r10,pc[1032]
80002ae0:	74 0a       	ld.w	r10,r10[0x0]
80002ae2:	f4 08 05 1a 	ld.uh	r10,r10[r8<<0x1]
80002ae6:	b1 6a       	lsl	r10,0x10
80002ae8:	99 1a       	st.w	r12[0x4],r10
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80002aea:	2f f8       	sub	r8,-1
80002aec:	5c 58       	castu.b	r8
80002aee:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
80002af0:	fe fa 03 fc 	ld.w	r10,pc[1020]
80002af4:	94 09       	ld.sh	r9,r10[0x0]
80002af6:	20 29       	sub	r9,2
80002af8:	b4 09       	st.h	r10[0x0],r9
			
			/*have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80002afa:	30 0a       	mov	r10,0
80002afc:	f4 09 19 00 	cp.h	r9,r10
80002b00:	e0 89 00 0b 	brgt	80002b16 <phy_tx_func+0xb2>
			{
				/*Must immediately send 0x00BA in Slot 4.*/
				xnl_tx_channel->dword |= PHYTERMRIGHT;
80002b04:	78 18       	ld.w	r8,r12[0x4]
80002b06:	e8 18 00 ba 	orl	r8,0xba
80002b0a:	99 18       	st.w	r12[0x4],r8
				
				/*Go back to waiting.*/
				//vPortFree(phy_ptr);
				phy_tx_state = WAITING_FOR_PHY_TX;
80002b0c:	30 09       	mov	r9,0
80002b0e:	fe f8 03 d2 	ld.w	r8,pc[978]
80002b12:	91 09       	st.w	r8[0x0],r9
80002b14:	c2 48       	rjmp	80002b5c <phy_tx_func+0xf8>
				break;
			}

			/*Have not broken. Transmit 2nd hWord.*/
			xnl_tx_channel->dword |=  phy_ptr->fragment_element[phy_tx_index++];
80002b16:	fe f9 03 ce 	ld.w	r9,pc[974]
80002b1a:	72 09       	ld.w	r9,r9[0x0]
80002b1c:	f2 08 05 19 	ld.uh	r9,r9[r8<<0x1]
80002b20:	78 1a       	ld.w	r10,r12[0x4]
80002b22:	f5 e9 10 09 	or	r9,r10,r9
80002b26:	99 19       	st.w	r12[0x4],r9
80002b28:	2f f8       	sub	r8,-1
80002b2a:	fe f9 03 c6 	ld.w	r9,pc[966]
80002b2e:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
80002b30:	fe f9 03 bc 	ld.w	r9,pc[956]
80002b34:	92 08       	ld.sh	r8,r9[0x0]
80002b36:	20 28       	sub	r8,2
80002b38:	b2 08       	st.h	r9[0x0],r8
			
			/*Have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80002b3a:	30 09       	mov	r9,0
80002b3c:	f2 08 19 00 	cp.h	r8,r9
80002b40:	e0 89 00 0e 	brgt	80002b5c <phy_tx_func+0xf8>
			{
				/*Must send 0x00BA0000 next interrupt in Slot 3&4*/
				phy_tx_state = SEND_TAILED;
80002b44:	30 29       	mov	r9,2
80002b46:	fe f8 03 9a 	ld.w	r8,pc[922]
80002b4a:	91 09       	st.w	r8[0x0],r9
80002b4c:	c0 88       	rjmp	80002b5c <phy_tx_func+0xf8>
			}
			break;

		case SEND_TAILED:
			/*send 0x00BA0000*/
			xnl_tx_channel->dword = PHYTERMLEFT;
80002b4e:	fc 18 00 ba 	movh	r8,0xba
80002b52:	99 18       	st.w	r12[0x4],r8
			
			/*Go back to waiting.*/	
			//vPortFree(phy_ptr);		
			phy_tx_state = WAITING_FOR_PHY_TX;		
80002b54:	30 09       	mov	r9,0
80002b56:	fe f8 03 8a 	ld.w	r8,pc[906]
80002b5a:	91 09       	st.w	r8[0x0],r9
	
	//static U8 frame_5_end = 0;
	//static U16 pay[256];
	
	//Send-AMBE-data
	if ((AMBE_Media == TRUE))
80002b5c:	fe f8 03 98 	ld.w	r8,pc[920]
80002b60:	11 89       	ld.ub	r9,r8[0x0]
80002b62:	30 18       	mov	r8,1
80002b64:	f0 09 18 00 	cp.b	r9,r8
80002b68:	e0 81 01 af 	brne	80002ec6 <phy_tx_func+0x462>
	{
		A_index = (A_index >=1456) ? 0 : A_index;
80002b6c:	fe f8 03 8c 	ld.w	r8,pc[908]
80002b70:	70 08       	ld.w	r8,r8[0x0]
80002b72:	e0 48 05 b0 	cp.w	r8,1456
80002b76:	f9 b8 02 00 	movhs	r8,0
80002b7a:	fe f9 03 7e 	ld.w	r9,pc[894]
80002b7e:	93 08       	st.w	r9[0x0],r8
	  //AMBE_flag
		switch(AMBEpayload_tx_state)
80002b80:	fe f8 03 7c 	ld.w	r8,pc[892]
80002b84:	70 08       	ld.w	r8,r8[0x0]
80002b86:	58 68       	cp.w	r8,6
80002b88:	e0 8b 01 95 	brhi	80002eb2 <phy_tx_func+0x44e>
80002b8c:	fe f9 03 74 	ld.w	r9,pc[884]
80002b90:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
		{
			case AMBE_IDLE:
		
				if ((m_RxBurstType == VOICE_WATING) || (m_RxBurstType == VOICETERMINATOR)  || (m_RxBurstType == VOICEHEADER))
80002b94:	fe f8 03 70 	ld.w	r8,pc[880]
80002b98:	70 08       	ld.w	r8,r8[0x0]
80002b9a:	58 08       	cp.w	r8,0
80002b9c:	c0 b0       	breq	80002bb2 <phy_tx_func+0x14e>
80002b9e:	fe f8 03 66 	ld.w	r8,pc[870]
80002ba2:	70 08       	ld.w	r8,r8[0x0]
80002ba4:	58 a8       	cp.w	r8,10
80002ba6:	c0 60       	breq	80002bb2 <phy_tx_func+0x14e>
80002ba8:	fe f8 03 5c 	ld.w	r8,pc[860]
80002bac:	70 08       	ld.w	r8,r8[0x0]
80002bae:	58 18       	cp.w	r8,1
80002bb0:	c0 a1       	brne	80002bc4 <phy_tx_func+0x160>
				{
							
					payload_tx_channel->dword[0] = PAYLOADIDLE0;
80002bb2:	e0 68 5a 5a 	mov	r8,23130
80002bb6:	ea 18 ab cd 	orh	r8,0xabcd
80002bba:	8f 28       	st.w	r7[0x8],r8
					payload_tx_channel->dword[1] = PAYLOADIDLE1;
80002bbc:	30 08       	mov	r8,0
80002bbe:	8f 38       	st.w	r7[0xc],r8
80002bc0:	e0 8f 01 8a 	bral	80002ed4 <phy_tx_func+0x470>
			
				}
				else if((m_RxBurstType == UNSUREDATA))
80002bc4:	fe f8 03 40 	ld.w	r8,pc[832]
80002bc8:	70 08       	ld.w	r8,r8[0x0]
80002bca:	58 38       	cp.w	r8,3
80002bcc:	c0 91       	brne	80002bde <phy_tx_func+0x17a>
				{
					payload_tx_channel->dword[0] = AMBE_HT[0];
80002bce:	fe f8 03 3a 	ld.w	r8,pc[826]
80002bd2:	70 09       	ld.w	r9,r8[0x0]
80002bd4:	8f 29       	st.w	r7[0x8],r9
					payload_tx_channel->dword[1] = AMBE_HT[1];
80002bd6:	70 18       	ld.w	r8,r8[0x4]
80002bd8:	8f 38       	st.w	r7[0xc],r8
80002bda:	e0 8f 01 7d 	bral	80002ed4 <phy_tx_func+0x470>
				else//加密和解密的激励类型
				{
					
					//Radio Internal Parameter + Vocoder Bits Stream Parameter + soft decision value + 1st 20ms AMBE bits of Voice Burst A 
					//assemble 4 items into 1 Command. Send it to Radio.
					if (m_RxBurstType == RADIOINTERNAL)//解密数据
80002bde:	fe f8 03 26 	ld.w	r8,pc[806]
80002be2:	70 08       	ld.w	r8,r8[0x0]
80002be4:	58 28       	cp.w	r8,2
80002be6:	c1 31       	brne	80002c0c <phy_tx_func+0x1a8>
					{
						//0xABCDCO32
						payload_tx_channel->dword[0] = DE_OB_PAYLOAD;//50bytes
80002be8:	e0 68 c0 32 	mov	r8,49202
80002bec:	ea 18 ab cd 	orh	r8,0xabcd
80002bf0:	8f 28       	st.w	r7[0x8],r8
						//0x847F
						payload_tx_channel->word[2] = RIP_PAYLOAD;
80002bf2:	fe 78 84 7f 	mov	r8,-31617
80002bf6:	ae 68       	st.h	r7[0xc],r8
						//0xxxxx
						payload_tx_channel->word[3] = Radio_Internal_Data[0];
80002bf8:	fe f8 03 14 	ld.w	r8,pc[788]
80002bfc:	90 08       	ld.sh	r8,r8[0x0]
80002bfe:	ae 78       	st.h	r7[0xe],r8
						
						AMBEpayload_tx_state = AMBE_DE_FIRST;
80002c00:	30 39       	mov	r9,3
80002c02:	fe f8 02 fa 	ld.w	r8,pc[762]
80002c06:	91 09       	st.w	r8[0x0],r9
80002c08:	e0 8f 01 66 	bral	80002ed4 <phy_tx_func+0x470>
					//assemble 2 items into 1 Command. Send it to Radio.
					else//加密数据
					{
	
						//0xABCDCOOE
						payload_tx_channel->dword[0] = EN_OB_PAYLOAD;//49bits
80002c0c:	e0 68 c0 0e 	mov	r8,49166
80002c10:	ea 18 ab cd 	orh	r8,0xabcd
80002c14:	8f 28       	st.w	r7[0x8],r8
						//0x8212
						payload_tx_channel->word[2] = VBSP_data[0];
80002c16:	fe f8 02 fa 	ld.w	r8,pc[762]
80002c1a:	90 09       	ld.sh	r9,r8[0x0]
80002c1c:	ae 69       	st.h	r7[0xc],r9
						//0xF00x
						payload_tx_channel->word[3] = VBSP_data[1];
80002c1e:	90 18       	ld.sh	r8,r8[0x2]
80002c20:	ae 78       	st.h	r7[0xe],r8
						
						AMBEpayload_tx_state = AMBE_EN_FIRST;
80002c22:	30 19       	mov	r9,1
80002c24:	fe f8 02 d8 	ld.w	r8,pc[728]
80002c28:	91 09       	st.w	r8[0x0],r9
80002c2a:	e0 8f 01 55 	bral	80002ed4 <phy_tx_func+0x470>
			
			case AMBE_EN_FIRST:
			
			
				//0x88F2
				payload_tx_channel->word[0] = ENCODER_PAYLOAD;//49bits
80002c2e:	fe 78 88 f2 	mov	r8,-30478
80002c32:	ae 48       	st.h	r7[0x8],r8
				//A_index+=2;
				//
				//AMBEpayload_tx_state = AMBE_EN_LAST;
				
			
				switch (m_RxBurstType)//在发送函数中去做加密处理
80002c34:	fe f8 02 d0 	ld.w	r8,pc[720]
80002c38:	70 08       	ld.w	r8,r8[0x0]
80002c3a:	58 48       	cp.w	r8,4
80002c3c:	c0 60       	breq	80002c48 <phy_tx_func+0x1e4>
80002c3e:	c4 53       	brcs	80002cc8 <phy_tx_func+0x264>
80002c40:	58 98       	cp.w	r8,9
80002c42:	e0 8b 00 43 	brhi	80002cc8 <phy_tx_func+0x264>
80002c46:	c2 98       	rjmp	80002c98 <phy_tx_func+0x234>
				{
					case VOICEBURST_A:
							if (VF_SN == 1)
80002c48:	fe f8 02 cc 	ld.w	r8,pc[716]
80002c4c:	11 89       	ld.ub	r9,r8[0x0]
80002c4e:	30 18       	mov	r8,1
80002c50:	f0 09 18 00 	cp.b	r9,r8
80002c54:	c0 a1       	brne	80002c68 <phy_tx_func+0x204>
							{	
								
								
								//Place public key
								payload_tx_channel->word[1] = Public_AMBEkey[0];
80002c56:	fe f8 02 c2 	ld.w	r8,pc[706]
80002c5a:	90 09       	ld.sh	r9,r8[0x0]
80002c5c:	ae 59       	st.h	r7[0xa],r9
								payload_tx_channel->word[2] = Public_AMBEkey[1];
80002c5e:	90 19       	ld.sh	r9,r8[0x2]
80002c60:	ae 69       	st.h	r7[0xc],r9
								payload_tx_channel->word[3] = Public_AMBEkey[2];
80002c62:	90 28       	ld.sh	r8,r8[0x4]
80002c64:	ae 78       	st.h	r7[0xe],r8
80002c66:	c1 48       	rjmp	80002c8e <phy_tx_func+0x22a>
							{
								
								
						
								//Encrypted AMBE data(XOR)
								payload_tx_channel->word[1] = ((Public_AMBEkey[0]) ^ (AMBEBurst_rawdata[0])) ;
80002c68:	fe f9 02 b4 	ld.w	r9,pc[692]
80002c6c:	92 0b       	ld.sh	r11,r9[0x0]
80002c6e:	fe f8 02 aa 	ld.w	r8,pc[682]
80002c72:	90 0a       	ld.sh	r10,r8[0x0]
80002c74:	f7 ea 20 0a 	eor	r10,r11,r10
80002c78:	ae 5a       	st.h	r7[0xa],r10
								payload_tx_channel->word[2] = ((Public_AMBEkey[1]) ^ (AMBEBurst_rawdata[1])) ;
80002c7a:	92 1b       	ld.sh	r11,r9[0x2]
80002c7c:	90 1a       	ld.sh	r10,r8[0x2]
80002c7e:	f7 ea 20 0a 	eor	r10,r11,r10
80002c82:	ae 6a       	st.h	r7[0xc],r10
								payload_tx_channel->word[3] = ((Public_AMBEkey[2]) ^ (AMBEBurst_rawdata[2])) ;
80002c84:	92 29       	ld.sh	r9,r9[0x4]
80002c86:	90 28       	ld.sh	r8,r8[0x4]
80002c88:	f3 e8 20 08 	eor	r8,r9,r8
80002c8c:	ae 78       	st.h	r7[0xe],r8
								//payload_tx_channel->word[3] = AMBEBurst_rawdata[2];
							
						
							}
					
							AMBEpayload_tx_state = AMBE_EN_LAST;
80002c8e:	30 29       	mov	r9,2
80002c90:	fe f8 02 6c 	ld.w	r8,pc[620]
80002c94:	91 09       	st.w	r8[0x0],r9
80002c96:	c1 f9       	rjmp	80002ed4 <phy_tx_func+0x470>
							//Encrypted AMBE data(XOR)
						
							//payload_tx_channel->word[1] = AMBEBurst_rawdata[0];
							//payload_tx_channel->word[2] = AMBEBurst_rawdata[1];
							//payload_tx_channel->word[3] = AMBEBurst_rawdata[2];
							payload_tx_channel->word[1] = ((Public_AMBEkey[0]) ^ (AMBEBurst_rawdata[0])) ;
80002c98:	fe f9 02 84 	ld.w	r9,pc[644]
80002c9c:	92 0b       	ld.sh	r11,r9[0x0]
80002c9e:	fe f8 02 7a 	ld.w	r8,pc[634]
80002ca2:	90 0a       	ld.sh	r10,r8[0x0]
80002ca4:	f7 ea 20 0a 	eor	r10,r11,r10
80002ca8:	ae 5a       	st.h	r7[0xa],r10
							payload_tx_channel->word[2] = ((Public_AMBEkey[1]) ^ (AMBEBurst_rawdata[1])) ;
80002caa:	92 1b       	ld.sh	r11,r9[0x2]
80002cac:	90 1a       	ld.sh	r10,r8[0x2]
80002cae:	f7 ea 20 0a 	eor	r10,r11,r10
80002cb2:	ae 6a       	st.h	r7[0xc],r10
							payload_tx_channel->word[3] = ((Public_AMBEkey[2]) ^ (AMBEBurst_rawdata[2])) ;
80002cb4:	92 29       	ld.sh	r9,r9[0x4]
80002cb6:	90 28       	ld.sh	r8,r8[0x4]
80002cb8:	f3 e8 20 08 	eor	r8,r9,r8
80002cbc:	ae 78       	st.h	r7[0xe],r8
						
							AMBEpayload_tx_state = AMBE_EN_LAST;
80002cbe:	30 29       	mov	r9,2
80002cc0:	fe f8 02 3c 	ld.w	r8,pc[572]
80002cc4:	91 09       	st.w	r8[0x0],r9
80002cc6:	c0 79       	rjmp	80002ed4 <phy_tx_func+0x470>
				
						break;
					default://This shouldn't happen, but must check;
					
							payload_tx_channel->dword[0] = PAYLOADIDLE0;
80002cc8:	e0 68 5a 5a 	mov	r8,23130
80002ccc:	ea 18 ab cd 	orh	r8,0xabcd
80002cd0:	8f 28       	st.w	r7[0x8],r8
							payload_tx_channel->dword[1] = PAYLOADIDLE1;
80002cd2:	30 08       	mov	r8,0
80002cd4:	8f 38       	st.w	r7[0xc],r8
							
							AMBEpayload_tx_state = AMBE_IDLE;
80002cd6:	fe f9 02 26 	ld.w	r9,pc[550]
80002cda:	93 08       	st.w	r9[0x0],r8
80002cdc:	cf c8       	rjmp	80002ed4 <phy_tx_func+0x470>
						  1:VF1 of first Burst A after last Voice Header (49 bits).
						  2:Last 4 bits (bit 45 to bit 48) of every 49 bits AMBE Voice Frame. (72 bits@Super Frame).
					
					*/
					
					payload_tx_channel->word[0] = AMBEBurst_rawdata[3];
80002cde:	fe f8 02 3e 	ld.w	r8,pc[574]
80002ce2:	90 38       	ld.sh	r8,r8[0x6]
80002ce4:	ae 48       	st.h	r7[0x8],r8
					
					
					//payload_tx_channel->word[0] = ((AMBE_AudioData[A_index]<<8) + 0x00) ;//需要补充Pad_bits位
					//A_index+=1;
					
					payload_tx_channel->word[1]	= 0x00BA ; 
80002ce6:	e0 68 00 ba 	mov	r8,186
80002cea:	ae 58       	st.h	r7[0xa],r8
					payload_tx_channel->word[2]	= 0x0000 ;
80002cec:	30 08       	mov	r8,0
80002cee:	ae 68       	st.h	r7[0xc],r8
					payload_tx_channel->word[3]	= 0x0000 ;
80002cf0:	ae 78       	st.h	r7[0xe],r8
				
					AMBEpayload_tx_state = AMBE_IDLE;
80002cf2:	30 09       	mov	r9,0
80002cf4:	fe f8 02 08 	ld.w	r8,pc[520]
80002cf8:	91 09       	st.w	r8[0x0],r9
80002cfa:	ce d8       	rjmp	80002ed4 <phy_tx_func+0x470>
				break;
				
			case AMBE_DE_FIRST:
				
					//0xxxxx
					payload_tx_channel->word[0] = Radio_Internal_Data[1];
80002cfc:	fe f8 02 10 	ld.w	r8,pc[528]
80002d00:	90 18       	ld.sh	r8,r8[0x2]
80002d02:	ae 48       	st.h	r7[0x8],r8
					//0x8212
					payload_tx_channel->word[1] = VBSP_data[0];
80002d04:	fe f8 02 0c 	ld.w	r8,pc[524]
80002d08:	90 08       	ld.sh	r8,r8[0x0]
80002d0a:	ae 58       	st.h	r7[0xa],r8
					
					if ((m_RxBurstType == VOICEBURST_A) && (VF_SN == 1) )
80002d0c:	4f e8       	lddpc	r8,80002f04 <phy_tx_func+0x4a0>
80002d0e:	70 08       	ld.w	r8,r8[0x0]
80002d10:	58 48       	cp.w	r8,4
80002d12:	c0 d1       	brne	80002d2c <phy_tx_func+0x2c8>
80002d14:	fe f8 02 00 	ld.w	r8,pc[512]
80002d18:	11 89       	ld.ub	r9,r8[0x0]
80002d1a:	30 18       	mov	r8,1
80002d1c:	f0 09 18 00 	cp.b	r9,r8
80002d20:	c0 61       	brne	80002d2c <phy_tx_func+0x2c8>
					{
						// Vocoder Bits Stream Parameter("E(bit8)" flag = 1)
						//0xF0(8+)x
						payload_tx_channel->word[2] = ((VBSP_data[1]) | (0x0100));
80002d22:	4f c8       	lddpc	r8,80002f10 <phy_tx_func+0x4ac>
80002d24:	90 18       	ld.sh	r8,r8[0x2]
80002d26:	a9 a8       	sbr	r8,0x8
80002d28:	ae 68       	st.h	r7[0xc],r8
80002d2a:	c0 48       	rjmp	80002d32 <phy_tx_func+0x2ce>
					}
					else
						//0xF00x
						payload_tx_channel->word[2] = (VBSP_data[1]) ;
80002d2c:	4f 98       	lddpc	r8,80002f10 <phy_tx_func+0x4ac>
80002d2e:	90 18       	ld.sh	r8,r8[0x2]
80002d30:	ae 68       	st.h	r7[0xc],r8
					
					//0x9A13
					payload_tx_channel->word[3] = SDV_PAYLOAD;
80002d32:	fe 78 9a 13 	mov	r8,-26093
80002d36:	ae 78       	st.h	r7[0xe],r8
		
					AMBEpayload_tx_state = AMBE_DE_SECOND;
80002d38:	30 49       	mov	r9,4
80002d3a:	4f 18       	lddpc	r8,80002efc <phy_tx_func+0x498>
80002d3c:	91 09       	st.w	r8[0x0],r9
80002d3e:	cc b8       	rjmp	80002ed4 <phy_tx_func+0x470>
				break;
			
			case AMBE_DE_SECOND:
					//Post back soft decision value data

						payload_tx_channel->word[0] = Soft_Decision_Data[Soft_index] ;
80002d40:	4f 88       	lddpc	r8,80002f20 <phy_tx_func+0x4bc>
80002d42:	70 0a       	ld.w	r10,r8[0x0]
80002d44:	4f 89       	lddpc	r9,80002f24 <phy_tx_func+0x4c0>
80002d46:	f2 0a 04 1a 	ld.sh	r10,r9[r10<<0x1]
80002d4a:	ae 4a       	st.h	r7[0x8],r10
						payload_tx_channel->word[1] = Soft_Decision_Data[Soft_index+1] ;
80002d4c:	70 0a       	ld.w	r10,r8[0x0]
80002d4e:	2f fa       	sub	r10,-1
80002d50:	f2 0a 04 1a 	ld.sh	r10,r9[r10<<0x1]
80002d54:	ae 5a       	st.h	r7[0xa],r10
						payload_tx_channel->word[2] = Soft_Decision_Data[Soft_index+2] ;
80002d56:	70 0a       	ld.w	r10,r8[0x0]
80002d58:	2f ea       	sub	r10,-2
80002d5a:	f2 0a 04 1a 	ld.sh	r10,r9[r10<<0x1]
80002d5e:	ae 6a       	st.h	r7[0xc],r10
						payload_tx_channel->word[3] = Soft_Decision_Data[Soft_index+3] ;
80002d60:	70 0a       	ld.w	r10,r8[0x0]
80002d62:	2f da       	sub	r10,-3
80002d64:	f2 0a 04 19 	ld.sh	r9,r9[r10<<0x1]
80002d68:	ae 79       	st.h	r7[0xe],r9
						Soft_index +=4;
80002d6a:	70 09       	ld.w	r9,r8[0x0]
80002d6c:	2f c9       	sub	r9,-4
80002d6e:	91 09       	st.w	r8[0x0],r9
						
						if (Soft_index == 12)
80002d70:	58 c9       	cp.w	r9,12
80002d72:	c0 51       	brne	80002d7c <phy_tx_func+0x318>
						{
							AMBEpayload_tx_state = AMBE_DE_THIRD;
80002d74:	30 59       	mov	r9,5
80002d76:	4e 28       	lddpc	r8,80002efc <phy_tx_func+0x498>
80002d78:	91 09       	st.w	r8[0x0],r9
80002d7a:	ca d8       	rjmp	80002ed4 <phy_tx_func+0x470>
							//Soft_index = 0 ;
							
						}
						else
						AMBEpayload_tx_state = AMBE_DE_SECOND;
80002d7c:	30 49       	mov	r9,4
80002d7e:	4e 08       	lddpc	r8,80002efc <phy_tx_func+0x498>
80002d80:	91 09       	st.w	r8[0x0],r9
80002d82:	ca 98       	rjmp	80002ed4 <phy_tx_func+0x470>
				break;	
				
			case AMBE_DE_THIRD:
					
					//0x xxxx
					payload_tx_channel->word[0] = Soft_Decision_Data[Soft_index] ;
80002d84:	4e 78       	lddpc	r8,80002f20 <phy_tx_func+0x4bc>
80002d86:	70 0a       	ld.w	r10,r8[0x0]
80002d88:	4e 79       	lddpc	r9,80002f24 <phy_tx_func+0x4c0>
80002d8a:	f2 0a 04 19 	ld.sh	r9,r9[r10<<0x1]
80002d8e:	ae 49       	st.h	r7[0x8],r9
					Soft_index = 0 ;//索引清零
80002d90:	30 09       	mov	r9,0
80002d92:	91 09       	st.w	r8[0x0],r9
					
					//0x8003 隔离符号？
					payload_tx_channel->word[1] = 0x8003;
80002d94:	fe 78 80 03 	mov	r8,-32765
80002d98:	ae 58       	st.h	r7[0xa],r8
					//0x88F3
					payload_tx_channel->word[2] = DECODER_PAYLOAD;
80002d9a:	fe 78 88 f3 	mov	r8,-30477
80002d9e:	ae 68       	st.h	r7[0xc],r8
				
					switch (m_RxBurstType)//在发送函数中去做解密处理
80002da0:	4d 98       	lddpc	r8,80002f04 <phy_tx_func+0x4a0>
80002da2:	70 08       	ld.w	r8,r8[0x0]
80002da4:	58 48       	cp.w	r8,4
80002da6:	c0 60       	breq	80002db2 <phy_tx_func+0x34e>
80002da8:	c2 83       	brcs	80002df8 <phy_tx_func+0x394>
80002daa:	58 98       	cp.w	r8,9
80002dac:	e0 8b 00 26 	brhi	80002df8 <phy_tx_func+0x394>
80002db0:	c1 98       	rjmp	80002de2 <phy_tx_func+0x37e>
					{
						case VOICEBURST_A:
								if (VF_SN == 1)
80002db2:	4d 98       	lddpc	r8,80002f14 <phy_tx_func+0x4b0>
80002db4:	11 89       	ld.ub	r9,r8[0x0]
80002db6:	30 18       	mov	r8,1
80002db8:	f0 09 18 00 	cp.b	r9,r8
80002dbc:	c0 81       	brne	80002dcc <phy_tx_func+0x368>
									//if(AMBEBurst_rawdata[0] == Public_AMBEkey[0])//0X1AC3
									{
										
									
										//Pick up public key
										AMBE_DecryptionKey[0] = AMBEBurst_rawdata[0];
80002dbe:	4d 88       	lddpc	r8,80002f1c <phy_tx_func+0x4b8>
80002dc0:	90 0a       	ld.sh	r10,r8[0x0]
80002dc2:	4d a9       	lddpc	r9,80002f28 <phy_tx_func+0x4c4>
80002dc4:	b2 0a       	st.h	r9[0x0],r10
									
										//Post back data
										payload_tx_channel->word[3] = AMBEBurst_rawdata[0] ;
80002dc6:	90 08       	ld.sh	r8,r8[0x0]
80002dc8:	ae 78       	st.h	r7[0xe],r8
80002dca:	c0 88       	rjmp	80002dda <phy_tx_func+0x376>
								else//VF_SN==2/3
								{	
									//Decrypt AMBE data(XOR) 
									//Recover data

									payload_tx_channel->word[3] = ((AMBE_DecryptionKey[0]) ^ (AMBEBurst_rawdata[0])) ;
80002dcc:	4d 78       	lddpc	r8,80002f28 <phy_tx_func+0x4c4>
80002dce:	90 08       	ld.sh	r8,r8[0x0]
80002dd0:	4d 39       	lddpc	r9,80002f1c <phy_tx_func+0x4b8>
80002dd2:	92 09       	ld.sh	r9,r9[0x0]
80002dd4:	f3 e8 20 08 	eor	r8,r9,r8
80002dd8:	ae 78       	st.h	r7[0xe],r8
									
									//payload_tx_channel->word[3] = ((AMBEBurst_rawdata[0])) ;
						
								}
					
								AMBEpayload_tx_state = AMBE_DE_LAST;
80002dda:	30 69       	mov	r9,6
80002ddc:	4c 88       	lddpc	r8,80002efc <phy_tx_func+0x498>
80002dde:	91 09       	st.w	r8[0x0],r9
80002de0:	c7 a8       	rjmp	80002ed4 <phy_tx_func+0x470>
						
								//Encrypted AMBE data(XOR)
						
								//Decrypt AMBE data(XOR)
								//Recover data
								payload_tx_channel->word[3] = ((AMBE_DecryptionKey[0]) ^ (AMBEBurst_rawdata[0])) ;
80002de2:	4d 28       	lddpc	r8,80002f28 <phy_tx_func+0x4c4>
80002de4:	90 08       	ld.sh	r8,r8[0x0]
80002de6:	4c e9       	lddpc	r9,80002f1c <phy_tx_func+0x4b8>
80002de8:	92 09       	ld.sh	r9,r9[0x0]
80002dea:	f3 e8 20 08 	eor	r8,r9,r8
80002dee:	ae 78       	st.h	r7[0xe],r8
								//payload_tx_channel->word[3] = ((AMBEBurst_rawdata[0])) ;
						
								AMBEpayload_tx_state = AMBE_DE_LAST;
80002df0:	30 69       	mov	r9,6
80002df2:	4c 38       	lddpc	r8,80002efc <phy_tx_func+0x498>
80002df4:	91 09       	st.w	r8[0x0],r9
80002df6:	c6 f8       	rjmp	80002ed4 <phy_tx_func+0x470>
				
							break;
						default://This shouldn't happen, but must check;
					
								payload_tx_channel->dword[0] = PAYLOADIDLE0;
80002df8:	e0 68 5a 5a 	mov	r8,23130
80002dfc:	ea 18 ab cd 	orh	r8,0xabcd
80002e00:	8f 28       	st.w	r7[0x8],r8
								payload_tx_channel->dword[1] = PAYLOADIDLE1;
80002e02:	30 08       	mov	r8,0
80002e04:	8f 38       	st.w	r7[0xc],r8
								AMBEpayload_tx_state = AMBE_IDLE;
80002e06:	4b e9       	lddpc	r9,80002efc <phy_tx_func+0x498>
80002e08:	93 08       	st.w	r9[0x0],r8
80002e0a:	c6 58       	rjmp	80002ed4 <phy_tx_func+0x470>
		
					break;
				
			case AMBE_DE_LAST:
				
					switch (m_RxBurstType)//在发送函数中去做解密处理
80002e0c:	4b e8       	lddpc	r8,80002f04 <phy_tx_func+0x4a0>
80002e0e:	70 08       	ld.w	r8,r8[0x0]
80002e10:	58 48       	cp.w	r8,4
80002e12:	c0 60       	breq	80002e1e <phy_tx_func+0x3ba>
80002e14:	c4 53       	brcs	80002e9e <phy_tx_func+0x43a>
80002e16:	58 98       	cp.w	r8,9
80002e18:	e0 8b 00 43 	brhi	80002e9e <phy_tx_func+0x43a>
80002e1c:	c2 d8       	rjmp	80002e76 <phy_tx_func+0x412>
					{
						case VOICEBURST_A:
							if (VF_SN == 1)
80002e1e:	4b e8       	lddpc	r8,80002f14 <phy_tx_func+0x4b0>
80002e20:	11 89       	ld.ub	r9,r8[0x0]
80002e22:	30 18       	mov	r8,1
80002e24:	f0 09 18 00 	cp.b	r9,r8
80002e28:	c1 31       	brne	80002e4e <phy_tx_func+0x3ea>
								//if(AMBEBurst_rawdata[1] == Public_AMBEkey[1])//0X1840
								{
								
									//Pick up public key
							
									AMBE_DecryptionKey[1] = AMBEBurst_rawdata[1];
80002e2a:	4b d8       	lddpc	r8,80002f1c <phy_tx_func+0x4b8>
80002e2c:	90 1a       	ld.sh	r10,r8[0x2]
80002e2e:	4b f9       	lddpc	r9,80002f28 <phy_tx_func+0x4c4>
80002e30:	b2 1a       	st.h	r9[0x2],r10
									AMBE_DecryptionKey[2] = AMBEBurst_rawdata[2];
80002e32:	90 2a       	ld.sh	r10,r8[0x4]
80002e34:	b2 2a       	st.h	r9[0x4],r10
									AMBE_DecryptionKey[3] = AMBEBurst_rawdata[3];
80002e36:	90 3a       	ld.sh	r10,r8[0x6]
80002e38:	b2 3a       	st.h	r9[0x6],r10
							
									//Post back data
									payload_tx_channel->word[0] = AMBEBurst_rawdata[1] ;
80002e3a:	90 19       	ld.sh	r9,r8[0x2]
80002e3c:	ae 49       	st.h	r7[0x8],r9
									payload_tx_channel->word[1] = AMBEBurst_rawdata[2] ;
80002e3e:	90 29       	ld.sh	r9,r8[0x4]
80002e40:	ae 59       	st.h	r7[0xa],r9
									payload_tx_channel->word[2] = AMBEBurst_rawdata[3] ;
80002e42:	90 38       	ld.sh	r8,r8[0x6]
80002e44:	ae 68       	st.h	r7[0xc],r8
									payload_tx_channel->word[3] = 0x00BA ;
80002e46:	e0 68 00 ba 	mov	r8,186
80002e4a:	ae 78       	st.h	r7[0xe],r8
80002e4c:	c1 18       	rjmp	80002e6e <phy_tx_func+0x40a>
							{
							
								//Decrypt AMBE data(XOR)
								//Recover data

									payload_tx_channel->word[0] = (AMBEBurst_rawdata[1] ^ AMBE_DecryptionKey[1]);
80002e4e:	4b 48       	lddpc	r8,80002f1c <phy_tx_func+0x4b8>
80002e50:	90 1a       	ld.sh	r10,r8[0x2]
80002e52:	4b 69       	lddpc	r9,80002f28 <phy_tx_func+0x4c4>
80002e54:	92 1b       	ld.sh	r11,r9[0x2]
80002e56:	f7 ea 20 0a 	eor	r10,r11,r10
80002e5a:	ae 4a       	st.h	r7[0x8],r10
									payload_tx_channel->word[1] = (AMBEBurst_rawdata[2] ^ AMBE_DecryptionKey[2]);
80002e5c:	90 2a       	ld.sh	r10,r8[0x4]
80002e5e:	92 29       	ld.sh	r9,r9[0x4]
80002e60:	14 59       	eor	r9,r10
80002e62:	ae 59       	st.h	r7[0xa],r9
									payload_tx_channel->word[2] = (AMBEBurst_rawdata[3]);
80002e64:	90 38       	ld.sh	r8,r8[0x6]
80002e66:	ae 68       	st.h	r7[0xc],r8
									
									//payload_tx_channel->word[0] = (AMBEBurst_rawdata[1]);
									//payload_tx_channel->word[1] = (AMBEBurst_rawdata[2]);
									//payload_tx_channel->word[2] = (AMBEBurst_rawdata[3]);
									
									payload_tx_channel->word[3] = 0x00BA ;
80002e68:	e0 68 00 ba 	mov	r8,186
80002e6c:	ae 78       	st.h	r7[0xe],r8
							
							
							}
						
							AMBEpayload_tx_state = AMBE_IDLE;
80002e6e:	30 09       	mov	r9,0
80002e70:	4a 38       	lddpc	r8,80002efc <phy_tx_func+0x498>
80002e72:	91 09       	st.w	r8[0x0],r9
80002e74:	c3 08       	rjmp	80002ed4 <phy_tx_func+0x470>
						
							//Encrypted AMBE data(XOR)
						
							//Decrypt AMBE data(XOR)
							//Recover data
							payload_tx_channel->word[0] = (AMBEBurst_rawdata[1] ^ AMBE_DecryptionKey[1]);
80002e76:	4a a8       	lddpc	r8,80002f1c <phy_tx_func+0x4b8>
80002e78:	90 1a       	ld.sh	r10,r8[0x2]
80002e7a:	4a c9       	lddpc	r9,80002f28 <phy_tx_func+0x4c4>
80002e7c:	92 1b       	ld.sh	r11,r9[0x2]
80002e7e:	f7 ea 20 0a 	eor	r10,r11,r10
80002e82:	ae 4a       	st.h	r7[0x8],r10
							payload_tx_channel->word[1] = (AMBEBurst_rawdata[2] ^ AMBE_DecryptionKey[2]);
80002e84:	90 2a       	ld.sh	r10,r8[0x4]
80002e86:	92 29       	ld.sh	r9,r9[0x4]
80002e88:	14 59       	eor	r9,r10
80002e8a:	ae 59       	st.h	r7[0xa],r9
							payload_tx_channel->word[2] = (AMBEBurst_rawdata[3]);
80002e8c:	90 38       	ld.sh	r8,r8[0x6]
80002e8e:	ae 68       	st.h	r7[0xc],r8
							
							//payload_tx_channel->word[0] = (AMBEBurst_rawdata[1]);
							//payload_tx_channel->word[1] = (AMBEBurst_rawdata[2]);
							//payload_tx_channel->word[2] = (AMBEBurst_rawdata[3]);
							
							payload_tx_channel->word[3] = 0x00BA ;
80002e90:	e0 68 00 ba 	mov	r8,186
80002e94:	ae 78       	st.h	r7[0xe],r8
						
							AMBEpayload_tx_state = AMBE_IDLE;
80002e96:	30 09       	mov	r9,0
80002e98:	49 98       	lddpc	r8,80002efc <phy_tx_func+0x498>
80002e9a:	91 09       	st.w	r8[0x0],r9
80002e9c:	c1 c8       	rjmp	80002ed4 <phy_tx_func+0x470>
						
							break;
						default://This shouldn't happen, but must check;
						
							payload_tx_channel->dword[0] = PAYLOADIDLE0;
80002e9e:	e0 68 5a 5a 	mov	r8,23130
80002ea2:	ea 18 ab cd 	orh	r8,0xabcd
80002ea6:	8f 28       	st.w	r7[0x8],r8
							payload_tx_channel->dword[1] = PAYLOADIDLE1;
80002ea8:	30 08       	mov	r8,0
80002eaa:	8f 38       	st.w	r7[0xc],r8
							AMBEpayload_tx_state = AMBE_IDLE;
80002eac:	49 49       	lddpc	r9,80002efc <phy_tx_func+0x498>
80002eae:	93 08       	st.w	r9[0x0],r8
80002eb0:	c1 28       	rjmp	80002ed4 <phy_tx_func+0x470>

				break;
		
			default:
			
					payload_tx_channel->dword[0] = PAYLOADIDLE0;
80002eb2:	e0 68 5a 5a 	mov	r8,23130
80002eb6:	ea 18 ab cd 	orh	r8,0xabcd
80002eba:	8f 28       	st.w	r7[0x8],r8
					payload_tx_channel->dword[1] = PAYLOADIDLE1;
80002ebc:	30 08       	mov	r8,0
80002ebe:	8f 38       	st.w	r7[0xc],r8
					
					AMBEpayload_tx_state = AMBE_IDLE;
80002ec0:	48 f9       	lddpc	r9,80002efc <phy_tx_func+0x498>
80002ec2:	93 08       	st.w	r9[0x0],r8
80002ec4:	c0 88       	rjmp	80002ed4 <phy_tx_func+0x470>

	}//end of Send-AMBE-data

	else
	{
		payload_tx_channel->dword[0] = PAYLOADIDLE0;
80002ec6:	e0 68 5a 5a 	mov	r8,23130
80002eca:	ea 18 ab cd 	orh	r8,0xabcd
80002ece:	8f 28       	st.w	r7[0x8],r8
		payload_tx_channel->dword[1] = PAYLOADIDLE1;
80002ed0:	30 08       	mov	r8,0
80002ed2:	8f 38       	st.w	r7[0xc],r8
	#else
	/*send idle frame*/	
	((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
	((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
	#endif /*end if*/
}
80002ed4:	2f fd       	sub	sp,-4
80002ed6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002eda:	00 00       	add	r0,r0
80002edc:	00 00       	add	r0,r0
80002ede:	0a c4       	st.b	r5++,r4
80002ee0:	00 00       	add	r0,r0
80002ee2:	0a 9c       	mov	r12,r5
80002ee4:	00 00       	add	r0,r0
80002ee6:	0a 78       	tst	r8,r5
80002ee8:	80 00       	ld.sh	r0,r0[0x0]
80002eea:	53 88       	stdsp	sp[0xe0],r8
80002eec:	00 00       	add	r0,r0
80002eee:	0a bc       	st.h	r5++,r12
80002ef0:	00 00       	add	r0,r0
80002ef2:	0a 81       	andn	r1,r5
80002ef4:	00 00       	add	r0,r0
80002ef6:	0a 4f       	or	pc,r5
80002ef8:	00 00       	add	r0,r0
80002efa:	0a 74       	tst	r4,r5
80002efc:	00 00       	add	r0,r0
80002efe:	0a ac       	st.w	r5++,r12
80002f00:	80 00       	ld.sh	r0,r0[0x0]
80002f02:	cb 64       	brge	80002e6e <phy_tx_func+0x40a>
80002f04:	00 00       	add	r0,r0
80002f06:	0a 68       	and	r8,r5
80002f08:	00 00       	add	r0,r0
80002f0a:	0a cc       	st.b	r5++,r12
80002f0c:	00 00       	add	r0,r0
80002f0e:	0d a0       	ld.ub	r0,r6[0x2]
80002f10:	00 00       	add	r0,r0
80002f12:	0e 9c       	mov	r12,r7
80002f14:	00 00       	add	r0,r0
80002f16:	0a 40       	or	r0,r5
80002f18:	80 00       	ld.sh	r0,r0[0x0]
80002f1a:	cb 08       	rjmp	8000307a <phy_rx_func+0xa>
80002f1c:	00 00       	add	r0,r0
80002f1e:	0d 98       	ld.ub	r8,r6[0x1]
80002f20:	00 00       	add	r0,r0
80002f22:	0a 98       	mov	r8,r5
80002f24:	00 00       	add	r0,r0
80002f26:	0e a0       	st.w	r7++,r0
80002f28:	00 00       	add	r0,r0
80002f2a:	0d a4       	ld.ub	r4,r6[0x2]

80002f2c <get_idle_store>:
	}//End of RxMedia Phy Handler.
}
#endif /*end if*/

void * get_idle_store(xQueueHandle store)
{
80002f2c:	d4 01       	pushm	lr
80002f2e:	20 1d       	sub	sp,4
	void * ptr = NULL;
80002f30:	30 0a       	mov	r10,0
80002f32:	fa cb ff fc 	sub	r11,sp,-4
80002f36:	16 da       	st.w	--r11,r10

	if(pdTRUE == xQueueReceive(store, &ptr, 0))
80002f38:	14 99       	mov	r9,r10
80002f3a:	1a 9b       	mov	r11,sp
80002f3c:	f0 1f 00 05 	mcall	80002f50 <get_idle_store+0x24>
80002f40:	58 1c       	cp.w	r12,1
80002f42:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80002f46:	fb fc 00 00 	ld.weq	r12,sp[0x0]
	}
	else
	{
		return NULL;
	}
}
80002f4a:	2f fd       	sub	sp,-4
80002f4c:	d8 02       	popm	pc
80002f4e:	00 00       	add	r0,r0
80002f50:	80 00       	ld.sh	r0,r0[0x0]
80002f52:	54 78       	stdsp	sp[0x11c],r8

80002f54 <phy_init>:
    register_rx_tx_func -- ssc.c
	xQueueCreate -- freertos
Called By: xnl_init -- xnl.c
*/
void phy_init( void )
{
80002f54:	eb cd 40 e0 	pushm	r5-r7,lr
    /*initialize the SSC*/
    ssc_init();
80002f58:	f0 1f 00 21 	mcall	80002fdc <phy_init+0x88>

    /*register the func to send/receive ssc packet*/
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
80002f5c:	4a 1b       	lddpc	r11,80002fe0 <phy_init+0x8c>
80002f5e:	4a 2c       	lddpc	r12,80002fe4 <phy_init+0x90>
80002f60:	f0 1f 00 22 	mcall	80002fe8 <phy_init+0x94>
	
	/*if enable send/receive payload(media), defined in physical.h*/	
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
80002f64:	30 4b       	mov	r11,4
80002f66:	31 ec       	mov	r12,30
80002f68:	f0 1f 00 21 	mcall	80002fec <phy_init+0x98>
80002f6c:	4a 18       	lddpc	r8,80002ff0 <phy_init+0x9c>
80002f6e:	91 0c       	st.w	r8[0x0],r12
80002f70:	30 07       	mov	r7,0
	phy_fragment_t * xnl_ptr = NULL;
	for(int i= 0; i < MAX_XNL_STORE; i++ )
	{
		set_xnl_idle(&xnl_store[i]);
80002f72:	10 96       	mov	r6,r8
80002f74:	4a 05       	lddpc	r5,80002ff4 <phy_init+0xa0>
80002f76:	6c 0c       	ld.w	r12,r6[0x0]
80002f78:	ea 07 00 0b 	add	r11,r5,r7
80002f7c:	f0 1f 00 1f 	mcall	80002ff8 <phy_init+0xa4>
80002f80:	ee c7 ff 00 	sub	r7,r7,-256
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
	
	/*if enable send/receive payload(media), defined in physical.h*/	
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
	phy_fragment_t * xnl_ptr = NULL;
	for(int i= 0; i < MAX_XNL_STORE; i++ )
80002f84:	e0 47 1e 00 	cp.w	r7,7680
80002f88:	cf 71       	brne	80002f76 <phy_init+0x22>
	{
		set_xnl_idle(&xnl_store[i]);
	}
		
    /*initialize the queue to send/receive xnl packet */	
    phy_xnl_frame_tx = xQueueCreate(TX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
80002f8a:	30 4b       	mov	r11,4
80002f8c:	31 4c       	mov	r12,20
80002f8e:	f0 1f 00 18 	mcall	80002fec <phy_init+0x98>
80002f92:	49 b8       	lddpc	r8,80002ffc <phy_init+0xa8>
80002f94:	91 0c       	st.w	r8[0x0],r12
    phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
80002f96:	30 4b       	mov	r11,4
80002f98:	30 ac       	mov	r12,10
80002f9a:	f0 1f 00 15 	mcall	80002fec <phy_init+0x98>
80002f9e:	49 98       	lddpc	r8,80003000 <phy_init+0xac>
80002fa0:	91 0c       	st.w	r8[0x0],r12
	
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
80002fa2:	30 4b       	mov	r11,4
80002fa4:	30 ac       	mov	r12,10
80002fa6:	f0 1f 00 12 	mcall	80002fec <phy_init+0x98>
80002faa:	49 78       	lddpc	r8,80003004 <phy_init+0xb0>
80002fac:	91 0c       	st.w	r8[0x0],r12
80002fae:	30 07       	mov	r7,0
	U8 * payload_ptr = NULL;
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
	{
		set_payload_idle(payload_store[i]);
80002fb0:	10 96       	mov	r6,r8
80002fb2:	49 65       	lddpc	r5,80003008 <phy_init+0xb4>
80002fb4:	6c 0c       	ld.w	r12,r6[0x0]
80002fb6:	ea 07 00 0b 	add	r11,r5,r7
80002fba:	f0 1f 00 10 	mcall	80002ff8 <phy_init+0xa4>
80002fbe:	ee c7 fe 00 	sub	r7,r7,-512
    phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
	
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
	U8 * payload_ptr = NULL;
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
80002fc2:	e0 47 14 00 	cp.w	r7,5120
80002fc6:	cf 71       	brne	80002fb4 <phy_init+0x60>
		set_payload_idle(payload_store[i]);
	}
		
	/*initialize the queue to send/receive xnl packet */
	phy_payload_frame_tx =
	xQueueCreate(TX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t));
80002fc8:	e0 6b 01 00 	mov	r11,256
80002fcc:	30 5c       	mov	r12,5
80002fce:	f0 1f 00 08 	mcall	80002fec <phy_init+0x98>
	{
		set_payload_idle(payload_store[i]);
	}
		
	/*initialize the queue to send/receive xnl packet */
	phy_payload_frame_tx =
80002fd2:	48 f8       	lddpc	r8,8000300c <phy_init+0xb8>
80002fd4:	91 0c       	st.w	r8[0x0],r12
		
	//phy_payload_frame_rx =
	//xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
	#endif /*end if*/
	
}
80002fd6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80002fda:	00 00       	add	r0,r0
80002fdc:	80 00       	ld.sh	r0,r0[0x0]
80002fde:	3e 00       	mov	r0,-32
80002fe0:	80 00       	ld.sh	r0,r0[0x0]
80002fe2:	2a 64       	sub	r4,-90
80002fe4:	80 00       	ld.sh	r0,r0[0x0]
80002fe6:	30 70       	mov	r0,7
80002fe8:	80 00       	ld.sh	r0,r0[0x0]
80002fea:	3d ec       	mov	r12,-34
80002fec:	80 00       	ld.sh	r0,r0[0x0]
80002fee:	57 dc       	stdsp	sp[0x1f4],r12
80002ff0:	00 00       	add	r0,r0
80002ff2:	0a 90       	mov	r0,r5
80002ff4:	00 00       	add	r0,r0
80002ff6:	22 ba       	sub	r10,43
80002ff8:	80 00       	ld.sh	r0,r0[0x0]
80002ffa:	29 c0       	sub	r0,-100
80002ffc:	00 00       	add	r0,r0
80002ffe:	0a c4       	st.b	r5++,r4
80003000:	00 00       	add	r0,r0
80003002:	0a b8       	st.h	r5++,r8
80003004:	00 00       	add	r0,r0
80003006:	0a 6c       	and	r12,r5
80003008:	00 00       	add	r0,r0
8000300a:	0e ba       	st.h	r7++,r10
8000300c:	00 00       	add	r0,r0
8000300e:	0a b4       	st.h	r5++,r4

80003010 <payload_rx>:




static void payload_rx(void * payload)
{
80003010:	d4 01       	pushm	lr
80003012:	20 2d       	sub	sp,8
80003014:	50 0c       	stdsp	sp[0x0],r12
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80003016:	30 08       	mov	r8,0
80003018:	50 18       	stdsp	sp[0x4],r8
	
	//set_payload_idle(payload);
	if(NULL == phy_payload_frame_rx)
8000301a:	48 f8       	lddpc	r8,80003054 <payload_rx+0x44>
8000301c:	70 08       	ld.w	r8,r8[0x0]
8000301e:	58 08       	cp.w	r8,0
80003020:	c0 71       	brne	8000302e <payload_rx+0x1e>
	{
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));		
80003022:	30 4b       	mov	r11,4
80003024:	30 5c       	mov	r12,5
80003026:	f0 1f 00 0d 	mcall	80003058 <payload_rx+0x48>
8000302a:	48 b8       	lddpc	r8,80003054 <payload_rx+0x44>
8000302c:	91 0c       	st.w	r8[0x0],r12
	}

	if(errQUEUE_FULL == xQueueSendFromISR(phy_payload_frame_rx, &payload, &xHigherPriorityTaskWoken))
8000302e:	48 a8       	lddpc	r8,80003054 <payload_rx+0x44>
80003030:	70 0c       	ld.w	r12,r8[0x0]
80003032:	30 09       	mov	r9,0
80003034:	fa ca ff fc 	sub	r10,sp,-4
80003038:	1a 9b       	mov	r11,sp
8000303a:	f0 1f 00 09 	mcall	8000305c <payload_rx+0x4c>
8000303e:	c0 91       	brne	80003050 <payload_rx+0x40>
	//if(errQUEUE_FULL == xQueueSend(phy_payload_frame_rx, &payload, 0))
	{	//To payload_rx_process();	
		
		set_payload_idle_isr(payload);
80003040:	48 88       	lddpc	r8,80003060 <payload_rx+0x50>
80003042:	70 0c       	ld.w	r12,r8[0x0]
80003044:	40 0b       	lddsp	r11,sp[0x0]
80003046:	f0 1f 00 08 	mcall	80003064 <payload_rx+0x54>
		logFromISR("mm");
8000304a:	48 8c       	lddpc	r12,80003068 <payload_rx+0x58>
8000304c:	f0 1f 00 08 	mcall	8000306c <payload_rx+0x5c>
			
		}
		//set_payload_idle_isr(payload);
		//logFromISR("ss");
	}
}
80003050:	2f ed       	sub	sp,-8
80003052:	d8 02       	popm	pc
80003054:	00 00       	add	r0,r0
80003056:	0a 88       	andn	r8,r5
80003058:	80 00       	ld.sh	r0,r0[0x0]
8000305a:	57 dc       	stdsp	sp[0x1f4],r12
8000305c:	80 00       	ld.sh	r0,r0[0x0]
8000305e:	56 34       	stdsp	sp[0x18c],r4
80003060:	00 00       	add	r0,r0
80003062:	0a 6c       	and	r12,r5
80003064:	80 00       	ld.sh	r0,r0[0x0]
80003066:	29 6c       	sub	r12,-106
80003068:	80 00       	ld.sh	r0,r0[0x0]
8000306a:	cb 80       	breq	80002fda <phy_init+0x86>
8000306c:	80 00       	ld.sh	r0,r0[0x0]
8000306e:	64 00       	ld.w	r0,r2[0x0]

80003070 <phy_rx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_rx_func( void * ssc)
{    
80003070:	eb cd 40 e0 	pushm	r5-r7,lr
80003074:	18 97       	mov	r7,r12
		
	if(NULL != phy_xnl_frame_rx)
80003076:	fe f8 0b be 	ld.w	r8,pc[3006]
8000307a:	70 08       	ld.w	r8,r8[0x0]
8000307c:	58 08       	cp.w	r8,0
8000307e:	e0 80 01 05 	breq	80003288 <phy_rx_func+0x218>
	static U16 phy_check_sum = 0;

	static phy_rx_state_t  phy_rx_state = WAITING_FOR_HEADER;
	static U32 phy_rx_count = 0;

	U32 phy_dword = xnl_rx_channel->dword;	
80003082:	78 16       	ld.w	r6,r12[0x4]

	phy_rx_count++;
80003084:	fe f8 0b b4 	ld.w	r8,pc[2996]
80003088:	70 09       	ld.w	r9,r8[0x0]
8000308a:	2f f9       	sub	r9,-1
8000308c:	91 09       	st.w	r8[0x0],r9
	
	/*This is the code for parsing the incoming physical message.*/
	switch (phy_rx_state)
8000308e:	fe f8 0b ae 	ld.w	r8,pc[2990]
80003092:	70 08       	ld.w	r8,r8[0x0]
80003094:	58 18       	cp.w	r8,1
80003096:	e0 80 00 84 	breq	8000319e <phy_rx_func+0x12e>
8000309a:	c0 73       	brcs	800030a8 <phy_rx_func+0x38>
8000309c:	58 28       	cp.w	r8,2
8000309e:	c5 b0       	breq	80003154 <phy_rx_func+0xe4>
800030a0:	58 38       	cp.w	r8,3
800030a2:	e0 81 00 f3 	brne	80003288 <phy_rx_func+0x218>
800030a6:	cd 38       	rjmp	8000324c <phy_rx_func+0x1dc>

        /*Waiting for something. Most frequent visit.*/		
		case WAITING_FOR_HEADER:
		
			/*Ignore Idles.*/
			if (0xABCD5A5A == phy_dword)
800030a8:	e0 6a 5a 5a 	mov	r10,23130
800030ac:	ea 1a ab cd 	orh	r10,0xabcd
800030b0:	14 36       	cp.w	r6,r10
800030b2:	e0 80 00 eb 	breq	80003288 <phy_rx_func+0x218>
			{
				break;
			}	

			/*Skip until Header.*/		
			if (0xABCD != (phy_dword >> 16))
800030b6:	ec 08 16 10 	lsr	r8,r6,0x10
800030ba:	e0 48 ab cd 	cp.w	r8,43981
800030be:	e0 81 00 e5 	brne	80003288 <phy_rx_func+0x218>
			{			
				break;
			}
		
			/*Length excluding CSUM.*/
			phy_rx_expexted_length = (phy_dword & 0x000000FF) - 2;
800030c2:	eb d6 b0 10 	bfexts	r5,r6,0x0,0x10
800030c6:	f1 d5 c0 08 	bfextu	r8,r5,0x0,0x8
800030ca:	20 28       	sub	r8,2
800030cc:	fe f9 0b 74 	ld.w	r9,pc[2932]
800030d0:	b2 08       	st.h	r9[0x0],r8
			
			/*Discard degenerate message.*/
			if (phy_rx_expexted_length <= 0)
800030d2:	30 09       	mov	r9,0
800030d4:	f2 08 19 00 	cp.h	r8,r9
800030d8:	e0 8a 00 d8 	brle	80003288 <phy_rx_func+0x218>
			{
				break;
			}
		
			phy_rx_length = 0;
800030dc:	fe f8 0b 68 	ld.w	r8,pc[2920]
800030e0:	b0 09       	st.h	r8[0x0],r9
			
			//get_xnl_idle_isr(&phy_frame_ptr, &xHigherPriorityTaskWoken);
			phy_frame_ptr = get_xnl_idle_isr();
800030e2:	fe f8 0b 66 	ld.w	r8,pc[2918]
800030e6:	70 0c       	ld.w	r12,r8[0x0]
800030e8:	f0 1f 02 d9 	mcall	80003c4c <phy_rx_func+0xbdc>
800030ec:	fe f8 0b 64 	ld.w	r8,pc[2916]
800030f0:	91 0c       	st.w	r8[0x0],r12
			if(NULL == phy_frame_ptr)
800030f2:	58 0c       	cp.w	r12,0
800030f4:	e0 80 00 ca 	breq	80003288 <phy_rx_func+0x218>
			//
			//xQueueReceiveFromISR(phy_store_idle, &phy_frame_ptr, &xHigherPriorityTaskWoken);
			
			//phy_frame_ptr = pvPortMalloc(sizeof(phy_fragment_t));
					
			phy_frame_ptr->fragment_element[phy_rx_length++] = phy_dword;
800030f8:	fe f8 0b 4c 	ld.w	r8,pc[2892]
800030fc:	90 09       	ld.sh	r9,r8[0x0]
800030fe:	f8 09 0a 15 	st.h	r12[r9<<0x1],r5
80003102:	2f f9       	sub	r9,-1
80003104:	5c 89       	casts.h	r9
			
			/*time stamp*/
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
80003106:	fe fa 0b 4a 	ld.w	r10,pc[2890]
8000310a:	74 0a       	ld.w	r10,r10[0x0]
8000310c:	fe fb 0b 2c 	ld.w	r11,pc[2860]
80003110:	76 0b       	ld.w	r11,r11[0x0]
80003112:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
80003116:	2f f9       	sub	r9,-1
80003118:	b0 09       	st.h	r8[0x0],r9
													(phy_rx_count) & 0x0000FFFF;
			
			/*This switch tests the fragment type, and adjusts receiver state
			accordingly.*/
			/*Check frag type*/
			switch (phy_dword & 0x00000F00)
8000311a:	e2 16 0f 00 	andl	r6,0xf00,COH
8000311e:	e0 46 01 00 	cp.w	r6,256
80003122:	c0 c0       	breq	8000313a <phy_rx_func+0xca>
80003124:	e0 8b 00 05 	brhi	8000312e <phy_rx_func+0xbe>
80003128:	58 06       	cp.w	r6,0
8000312a:	c0 80       	breq	8000313a <phy_rx_func+0xca>
8000312c:	c0 c8       	rjmp	80003144 <phy_rx_func+0xd4>
8000312e:	e0 46 02 00 	cp.w	r6,512
80003132:	c0 40       	breq	8000313a <phy_rx_func+0xca>
80003134:	e0 46 03 00 	cp.w	r6,768
80003138:	c0 61       	brne	80003144 <phy_rx_func+0xd4>
			{
				case SINGLE_FRAGMENT:  //Only Fragment.
				case FIRST_FRAGMENT:   //First of Multi-fragment.
				case MIDDLE_FRAGMENT:  //Continuing Multi-fragment.
				case LAST_FRAGMENT:    //Last Multi-fragment.
					phy_rx_state = WAITING_CHECK_SUM;
8000313a:	30 29       	mov	r9,2
8000313c:	fe f8 0b 00 	ld.w	r8,pc[2816]
80003140:	91 09       	st.w	r8[0x0],r9
80003142:	ca 38       	rjmp	80003288 <phy_rx_func+0x218>
				break;
				default:
					vPortFree(phy_frame_ptr);
80003144:	fe f6 0b 0c 	ld.w	r6,pc[2828]
80003148:	6c 0c       	ld.w	r12,r6[0x0]
8000314a:	f0 1f 02 c3 	mcall	80003c54 <phy_rx_func+0xbe4>
					phy_frame_ptr = NULL;					
8000314e:	30 08       	mov	r8,0
80003150:	8d 08       	st.w	r6[0x0],r8
80003152:	c9 b8       	rjmp	80003288 <phy_rx_func+0x218>
		
			/*Stores CSUM*/
			phy_check_sum  = (phy_dword & 0xFFFF0000) >> 16;
			
			/*sums in first hWord*/
			phy_check_sum += (phy_dword & 0x0000FFFF);		
80003154:	f5 d6 b0 10 	bfexts	r10,r6,0x0,0x10
80003158:	b1 86       	lsr	r6,0x10
8000315a:	14 06       	add	r6,r10
8000315c:	fe f8 0a fc 	ld.w	r8,pc[2812]
80003160:	b0 06       	st.h	r8[0x0],r6
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
80003162:	fe f8 0a e2 	ld.w	r8,pc[2786]
80003166:	90 09       	ld.sh	r9,r8[0x0]
80003168:	fe fb 0a e8 	ld.w	r11,pc[2792]
8000316c:	76 0b       	ld.w	r11,r11[0x0]
8000316e:	f6 09 0a 1a 	st.h	r11[r9<<0x1],r10
80003172:	2f f9       	sub	r9,-1
80003174:	b0 09       	st.h	r8[0x0],r9
														 phy_dword & 0x0000FFFF;
					
			phy_rx_expexted_length -= 2;
80003176:	fe f9 0a ca 	ld.w	r9,pc[2762]
8000317a:	92 08       	ld.sh	r8,r9[0x0]
8000317c:	20 28       	sub	r8,2
8000317e:	b2 08       	st.h	r9[0x0],r8
			
			/*Normal case for greater than one byte payloads.*/
			if (phy_rx_expexted_length > 0)
80003180:	30 09       	mov	r9,0
80003182:	f2 08 19 00 	cp.h	r8,r9
80003186:	e0 8a 00 07 	brle	80003194 <phy_rx_func+0x124>
			{					  
				phy_rx_state = READING_FRAGMENT;
8000318a:	30 19       	mov	r9,1
8000318c:	fe f8 0a b0 	ld.w	r8,pc[2736]
80003190:	91 09       	st.w	r8[0x0],r9
80003192:	c7 b8       	rjmp	80003288 <phy_rx_func+0x218>
	    		Note that all segments must align with a 32-bit boundary and
				beginning of each XCMP/XNL payload frame must start on slot 3
				Thus, segments of odd length must append a 0x0000 at the end
				(slot 4) to ensure alignment. [9.1.3]
				*/
				phy_rx_state = WAITING_LAST_TERM;
80003194:	30 39       	mov	r9,3
80003196:	fe f8 0a a6 	ld.w	r8,pc[2726]
8000319a:	91 09       	st.w	r8[0x0],r9
8000319c:	c7 68       	rjmp	80003288 <phy_rx_func+0x218>
			}			
		
			break;

		case READING_FRAGMENT:
			phy_check_sum += (phy_dword & 0xFFFF0000) >> 16;
8000319e:	ec 0a 14 10 	asr	r10,r6,0x10
800031a2:	fe f8 0a b6 	ld.w	r8,pc[2742]
800031a6:	90 09       	ld.sh	r9,r8[0x0]
800031a8:	14 09       	add	r9,r10
800031aa:	b0 09       	st.h	r8[0x0],r9
	
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
800031ac:	fe f9 0a 98 	ld.w	r9,pc[2712]
800031b0:	92 08       	ld.sh	r8,r9[0x0]
800031b2:	fe fb 0a 9e 	ld.w	r11,pc[2718]
800031b6:	76 0b       	ld.w	r11,r11[0x0]
800031b8:	f6 08 0a 1a 	st.h	r11[r8<<0x1],r10
800031bc:	2f f8       	sub	r8,-1
800031be:	5c 88       	casts.h	r8
800031c0:	b2 08       	st.h	r9[0x0],r8
												 (phy_dword & 0xFFFF0000) >> 16;
	
			phy_rx_expexted_length -= 2;
800031c2:	fe fa 0a 7e 	ld.w	r10,pc[2686]
800031c6:	94 09       	ld.sh	r9,r10[0x0]
800031c8:	20 29       	sub	r9,2
800031ca:	b4 09       	st.h	r10[0x0],r9
			if (phy_rx_expexted_length <= 0)
800031cc:	30 0a       	mov	r10,0
800031ce:	f4 09 19 00 	cp.h	r9,r10
800031d2:	e0 89 00 1f 	brgt	80003210 <phy_rx_func+0x1a0>
				Terminator should be in 2nd hWord.
				Shaoqun says useful bits not used. The packet will always end
				with $00BA. [9.1.2.8]	
				*/
				
				if ((0x000000BA == (phy_dword  & 0x0000FFFF)) 
800031d6:	ed d6 c0 10 	bfextu	r6,r6,0x0,0x10
800031da:	e0 46 00 ba 	cp.w	r6,186
800031de:	c0 d1       	brne	800031f8 <phy_rx_func+0x188>
800031e0:	fe f8 0a 78 	ld.w	r8,pc[2680]
800031e4:	90 09       	ld.sh	r9,r8[0x0]
800031e6:	f4 09 19 00 	cp.h	r9,r10
800031ea:	c0 71       	brne	800031f8 <phy_rx_func+0x188>
					&& (phy_check_sum == 0))
				{
					phy_rx(phy_frame_ptr);
800031ec:	fe f8 0a 64 	ld.w	r8,pc[2660]
800031f0:	70 0c       	ld.w	r12,r8[0x0]
800031f2:	f0 1f 02 9b 	mcall	80003c5c <phy_rx_func+0xbec>
800031f6:	c0 88       	rjmp	80003206 <phy_rx_func+0x196>
				}
				else
				{
					vPortFree(phy_frame_ptr);
800031f8:	fe f6 0a 58 	ld.w	r6,pc[2648]
800031fc:	6c 0c       	ld.w	r12,r6[0x0]
800031fe:	f0 1f 02 96 	mcall	80003c54 <phy_rx_func+0xbe4>
					phy_frame_ptr = NULL;
80003202:	30 08       	mov	r8,0
80003204:	8d 08       	st.w	r6[0x0],r8
				}

				phy_rx_state = WAITING_FOR_HEADER;
80003206:	30 09       	mov	r9,0
80003208:	fe f8 0a 34 	ld.w	r8,pc[2612]
8000320c:	91 09       	st.w	r8[0x0],r9
8000320e:	c3 d8       	rjmp	80003288 <phy_rx_func+0x218>
				break;
			}
		
			/*Have not broken. 2nd hWord contains payload.*/
			phy_check_sum += (phy_dword & 0x0000FFFF);
80003210:	5c 86       	casts.h	r6
80003212:	fe f9 0a 46 	ld.w	r9,pc[2630]
80003216:	92 0a       	ld.sh	r10,r9[0x0]
80003218:	0c 0a       	add	r10,r6
8000321a:	b2 0a       	st.h	r9[0x0],r10
		
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
8000321c:	fe f9 0a 34 	ld.w	r9,pc[2612]
80003220:	72 09       	ld.w	r9,r9[0x0]
80003222:	f2 08 0a 16 	st.h	r9[r8<<0x1],r6
80003226:	2f f8       	sub	r8,-1
80003228:	fe f9 0a 1c 	ld.w	r9,pc[2588]
8000322c:	b2 08       	st.h	r9[0x0],r8
													   (phy_dword & 0x0000FFFF);
		
			phy_rx_expexted_length -= 2;
8000322e:	fe f9 0a 12 	ld.w	r9,pc[2578]
80003232:	92 08       	ld.sh	r8,r9[0x0]
80003234:	20 28       	sub	r8,2
80003236:	b2 08       	st.h	r9[0x0],r8
			if (phy_rx_expexted_length <= 0)
80003238:	30 09       	mov	r9,0
8000323a:	f2 08 19 00 	cp.h	r8,r9
8000323e:	e0 89 00 25 	brgt	80003288 <phy_rx_func+0x218>
			{
				/*All read in. Next Word should be 0x00BA0000.*/
				phy_rx_state = WAITING_LAST_TERM;
80003242:	30 39       	mov	r9,3
80003244:	fe f8 09 f8 	ld.w	r8,pc[2552]
80003248:	91 09       	st.w	r8[0x0],r9
8000324a:	c1 f8       	rjmp	80003288 <phy_rx_func+0x218>
			}/*else, next Word contains more payload.*/
			break;

		/*Expecting last terminator 0x00BA0000.*/	
		case WAITING_LAST_TERM:			
			if ((0x00BA0000 == (phy_dword  & 0x00FF0000)) /*Expected found.*/
8000324c:	e6 16 00 ff 	andh	r6,0xff,COH
80003250:	fc 19 00 ba 	movh	r9,0xba
80003254:	12 36       	cp.w	r6,r9
80003256:	c0 e1       	brne	80003272 <phy_rx_func+0x202>
80003258:	fe f8 0a 00 	ld.w	r8,pc[2560]
8000325c:	90 09       	ld.sh	r9,r8[0x0]
8000325e:	30 08       	mov	r8,0
80003260:	f0 09 19 00 	cp.h	r9,r8
80003264:	c0 71       	brne	80003272 <phy_rx_func+0x202>
				&& (phy_check_sum == 0))/*Good checksum*/
			{
				phy_rx(phy_frame_ptr);
80003266:	fe f8 09 ea 	ld.w	r8,pc[2538]
8000326a:	70 0c       	ld.w	r12,r8[0x0]
8000326c:	f0 1f 02 7c 	mcall	80003c5c <phy_rx_func+0xbec>
80003270:	c0 88       	rjmp	80003280 <phy_rx_func+0x210>

			}
			else
			{
				vPortFree(phy_frame_ptr);
80003272:	fe f6 09 de 	ld.w	r6,pc[2526]
80003276:	6c 0c       	ld.w	r12,r6[0x0]
80003278:	f0 1f 02 77 	mcall	80003c54 <phy_rx_func+0xbe4>
				phy_frame_ptr = NULL;
8000327c:	30 08       	mov	r8,0
8000327e:	8d 08       	st.w	r6[0x0],r8
			}
				
			phy_rx_state = WAITING_FOR_HEADER;
80003280:	30 09       	mov	r9,0
80003282:	fe f8 09 ba 	ld.w	r8,pc[2490]
80003286:	91 09       	st.w	r8[0x0],r9
			
	//payload_ptr_t *AMBE_payload_ptr;		
				
	
	
	if(is_first == FALSE)
80003288:	fe f8 09 d8 	ld.w	r8,pc[2520]
8000328c:	11 89       	ld.ub	r9,r8[0x0]
8000328e:	30 08       	mov	r8,0
80003290:	f0 09 18 00 	cp.b	r9,r8
80003294:	c0 d1       	brne	800032ae <phy_rx_func+0x23e>
	{
		//payload_ptr = get_payload_idle_isr();
		AMBE_payload_ptr = get_payload_idle_isr();
80003296:	fe f8 09 ce 	ld.w	r8,pc[2510]
8000329a:	70 0c       	ld.w	r12,r8[0x0]
8000329c:	f0 1f 02 6c 	mcall	80003c4c <phy_rx_func+0xbdc>
800032a0:	fe f8 09 c8 	ld.w	r8,pc[2504]
800032a4:	91 0c       	st.w	r8[0x0],r12
		is_first = TRUE;
800032a6:	30 19       	mov	r9,1
800032a8:	fe f8 09 b8 	ld.w	r8,pc[2488]
800032ac:	b0 89       	st.b	r8[0x0],r9
	}	
	
	//This is the RxMedia Phy Handler.
	switch (RxMediaState)
800032ae:	fe f8 09 be 	ld.w	r8,pc[2494]
800032b2:	70 08       	ld.w	r8,r8[0x0]
800032b4:	58 38       	cp.w	r8,3
800032b6:	e0 80 04 7a 	breq	80003baa <phy_rx_func+0xb3a>
800032ba:	58 48       	cp.w	r8,4
800032bc:	e0 80 01 02 	breq	800034c0 <phy_rx_func+0x450>
800032c0:	58 08       	cp.w	r8,0
800032c2:	e0 81 04 b7 	brne	80003c30 <phy_rx_func+0xbc0>
	{
		case WAITINGABAB:

			
			if (payload_rx_channel->dword[0] == 0xABCD5A5A)//Ignore Idles.
800032c6:	6e 28       	ld.w	r8,r7[0x8]
800032c8:	e0 6a 5a 5a 	mov	r10,23130
800032cc:	ea 1a ab cd 	orh	r10,0xabcd
800032d0:	14 38       	cp.w	r8,r10
800032d2:	c0 71       	brne	800032e0 <phy_rx_func+0x270>
			{
				m_RxBurstType = VOICE_WATING;
800032d4:	30 09       	mov	r9,0
800032d6:	fe f8 09 9a 	ld.w	r8,pc[2458]
800032da:	91 09       	st.w	r8[0x0],r9
800032dc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
				//Upon receiving the idle frame, the m Rx Burst Type into an idle state in order to transmit the synchronization wait
				 break; 
			}
            
			if ((payload_rx_channel->dword[0]  & 0xFFFF0000) != 0xABCD0000)break; //Skip until Header. 
800032e0:	10 99       	mov	r9,r8
800032e2:	e0 19 00 00 	andl	r9,0x0
800032e6:	fc 1a ab cd 	movh	r10,0xabcd
800032ea:	14 39       	cp.w	r9,r10
800032ec:	e0 81 04 a2 	brne	80003c30 <phy_rx_func+0xbc0>
			}
			//logFromISR("\n\r P: %X \n\r", payload_rx_channel->word[1]);//测试收到的数据
			
			#endif
			
			RxBytesWaiting = payload_rx_channel->dword[0] & 0x000000FF;
800032f0:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
800032f4:	fe f9 09 80 	ld.w	r9,pc[2432]
800032f8:	93 08       	st.w	r9[0x0],r8
		
			if( (NULL== AMBE_payload_ptr))
800032fa:	fe f8 09 6e 	ld.w	r8,pc[2414]
800032fe:	70 08       	ld.w	r8,r8[0x0]
80003300:	58 08       	cp.w	r8,0
80003302:	c1 11       	brne	80003324 <phy_rx_func+0x2b4>
			{
				//payload_ptr = get_payload_idle_isr();
				AMBE_payload_ptr = get_payload_idle_isr();
80003304:	fe f8 09 60 	ld.w	r8,pc[2400]
80003308:	70 0c       	ld.w	r12,r8[0x0]
8000330a:	f0 1f 02 51 	mcall	80003c4c <phy_rx_func+0xbdc>
8000330e:	fe f8 09 5a 	ld.w	r8,pc[2394]
80003312:	91 0c       	st.w	r8[0x0],r12
				
				if (NULL== AMBE_payload_ptr)
80003314:	58 0c       	cp.w	r12,0
80003316:	c0 71       	brne	80003324 <phy_rx_func+0x2b4>
				{
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
80003318:	fe fc 09 60 	ld.w	r12,pc[2400]
8000331c:	f0 1f 02 58 	mcall	80003c7c <phy_rx_func+0xc0c>
80003320:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003324:	6e 28       	ld.w	r8,r7[0x8]
80003326:	e2 18 f0 00 	andl	r8,0xf000,COH
8000332a:	e0 48 c0 00 	cp.w	r8,49152
8000332e:	e0 81 00 c3 	brne	800034b4 <phy_rx_func+0x444>
		
			/****Note AMBE stream protocol frame structure and the PCM frame structure is different*****/
					
			if ((payload_rx_channel->dword[0] & 0x0000F000 ) == PAYLOAD_DATA_ENH )//PAYLOAD_DATA_ENH (0x0c))
			{
				AMBE_Media = 1;	
80003332:	30 19       	mov	r9,1
80003334:	fe f8 09 4c 	ld.w	r8,pc[2380]
80003338:	b0 89       	st.b	r8[0x0],r9
											
				Item_ID = payload_rx_channel->byte[5];
8000333a:	ef 39 00 0d 	ld.ub	r9,r7[13]
8000333e:	fe f8 09 46 	ld.w	r8,pc[2374]
80003342:	b0 89       	st.b	r8[0x0],r9
				
				Item_Length = (payload_rx_channel->byte[4] & 0x7F);//7bits
80003344:	ef 3a 00 0c 	ld.ub	r10,r7[12]
80003348:	f5 da c0 07 	bfextu	r10,r10,0x0,0x7
8000334c:	fe f9 09 3c 	ld.w	r9,pc[2364]
80003350:	93 0a       	st.w	r9[0x0],r10
								
				switch(Item_ID)
80003352:	11 88       	ld.ub	r8,r8[0x0]
80003354:	37 f9       	mov	r9,127
80003356:	f2 08 18 00 	cp.b	r8,r9
8000335a:	c6 d0       	breq	80003434 <phy_rx_func+0x3c4>
8000335c:	e0 8b 00 0c 	brhi	80003374 <phy_rx_func+0x304>
80003360:	31 29       	mov	r9,18
80003362:	f2 08 18 00 	cp.b	r8,r9
80003366:	c4 20       	breq	800033ea <phy_rx_func+0x37a>
80003368:	31 39       	mov	r9,19
8000336a:	f2 08 18 00 	cp.b	r8,r9
8000336e:	e0 81 00 83 	brne	80003474 <phy_rx_func+0x404>
80003372:	c5 b8       	rjmp	80003428 <phy_rx_func+0x3b8>
80003374:	2f 08       	sub	r8,-16
80003376:	30 19       	mov	r9,1
80003378:	f2 08 18 00 	cp.b	r8,r9
8000337c:	e0 8b 00 7c 	brhi	80003474 <phy_rx_func+0x404>
					//The OB know the Call begin and discard the Voice Header
					//The OB know the Call end and discard the Voice  Terminator
					case Raw_Tx_Data_HT://0xF0
					case Raw_Rx_Data_HT://0xF1
					
							if ((payload_rx_channel->byte[6] & 0xF0 )== 0x10)//header
80003380:	ef 38 00 0e 	ld.ub	r8,r7[14]
80003384:	e2 18 00 f0 	andl	r8,0xf0,COH
80003388:	59 08       	cp.w	r8,16
8000338a:	c0 71       	brne	80003398 <phy_rx_func+0x328>
							{
								m_RxBurstType = VOICEHEADER;
8000338c:	30 19       	mov	r9,1
8000338e:	fe f8 08 e2 	ld.w	r8,pc[2274]
80003392:	91 09       	st.w	r8[0x0],r9
80003394:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

							}
							else if ((payload_rx_channel->byte[6] & 0xF0) == 0x20)//Terminator
80003398:	e0 48 00 20 	cp.w	r8,32
8000339c:	c2 11       	brne	800033de <phy_rx_func+0x36e>
							{
								m_RxBurstType = VOICETERMINATOR;
8000339e:	30 a9       	mov	r9,10
800033a0:	fe f8 08 d0 	ld.w	r8,pc[2256]
800033a4:	91 09       	st.w	r8[0x0],r9
								//AMBE-data and PCM-data is not the same. AMBE is compressed data,
								//if there was a missing portion, a clear voice is difficult to extract the data.
								//It must ensure that all the data received AMBE.
								
								//注意！！！考虑是否需要把剩余的空间置0。
								memset((AMBE_payload_ptr+ (RxAMBE_IsFillingNext8 +1)), 0x00, (512-(RxAMBE_IsFillingNext8 + 1)));
800033a6:	fe f6 08 e6 	ld.w	r6,pc[2278]
800033aa:	6c 08       	ld.w	r8,r6[0x0]
800033ac:	f0 0a 11 ff 	rsub	r10,r8,-1
800033b0:	fe f7 08 b8 	ld.w	r7,pc[2232]
800033b4:	2f f8       	sub	r8,-1
800033b6:	6e 0c       	ld.w	r12,r7[0x0]
800033b8:	f4 ca fe 00 	sub	r10,r10,-512
800033bc:	30 0b       	mov	r11,0
800033be:	10 0c       	add	r12,r8
800033c0:	f0 1f 02 34 	mcall	80003c90 <phy_rx_func+0xc20>
								
								RxAMBE_IsFillingNext8 = 0;
800033c4:	30 08       	mov	r8,0
800033c6:	8d 08       	st.w	r6[0x0],r8
								payload_rx(AMBE_payload_ptr);
800033c8:	6e 0c       	ld.w	r12,r7[0x0]
800033ca:	f0 1f 02 33 	mcall	80003c94 <phy_rx_func+0xc24>
								AMBE_payload_ptr = get_payload_idle_isr();
800033ce:	fe f8 08 96 	ld.w	r8,pc[2198]
800033d2:	70 0c       	ld.w	r12,r8[0x0]
800033d4:	f0 1f 02 1e 	mcall	80003c4c <phy_rx_func+0xbdc>
800033d8:	8f 0c       	st.w	r7[0x0],r12
800033da:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								//logFromISR("\n\r QQ1 \n\r");
								
							}
							else//error voice
							{
								m_RxBurstType = VOICE_WATING;
800033de:	30 09       	mov	r9,0
800033e0:	fe f8 08 90 	ld.w	r8,pc[2192]
800033e4:	91 09       	st.w	r8[0x0],r9
800033e6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;//WAITINGABAB.
					
		
					case Vocoder_Bit_Stream_Parameter://0x12
							
							if ((RxBytesWaiting -= 4) <= 0) break;
800033ea:	fe f9 08 8a 	ld.w	r9,pc[2186]
800033ee:	72 08       	ld.w	r8,r9[0x0]
800033f0:	20 48       	sub	r8,4
800033f2:	93 08       	st.w	r9[0x0],r8
800033f4:	e0 80 04 1e 	breq	80003c30 <phy_rx_func+0xbc0>
					
							//Vocoder Bits Stream Parameter
							VF_SN = (payload_rx_channel->byte[7] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
800033f8:	ef 3c 00 0f 	ld.ub	r12,r7[15]
800033fc:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
80003400:	fe f8 08 98 	ld.w	r8,pc[2200]
80003404:	b0 8c       	st.b	r8[0x0],r12
							
							VBSP_data[0] = payload_rx_channel->word[2];
80003406:	8e 69       	ld.sh	r9,r7[0xc]
80003408:	fe f8 08 94 	ld.w	r8,pc[2196]
8000340c:	b0 09       	st.h	r8[0x0],r9
							VBSP_data[1] = payload_rx_channel->word[3];
8000340e:	8e 79       	ld.sh	r9,r7[0xe]
80003410:	b0 19       	st.h	r8[0x2],r9
							
							m_RxBurstType = CalculateBurst(VF_SN);
80003412:	f0 1f 02 24 	mcall	80003ca0 <phy_rx_func+0xc30>
80003416:	fe f8 08 5a 	ld.w	r8,pc[2138]
8000341a:	91 0c       	st.w	r8[0x0],r12
							
							RxMediaState = READING_AMBE_MEDIA;//Jump
8000341c:	30 49       	mov	r9,4
8000341e:	fe f8 08 4e 	ld.w	r8,pc[2126]
80003422:	91 09       	st.w	r8[0x0],r9
80003424:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							
					//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
					// or discard it to reduce payload size.	
					//This shouldn't happen, but must check.	
					case Soft_Decision_Value://0x13
						m_RxBurstType = VOICE_WATING;
80003428:	30 09       	mov	r9,0
8000342a:	fe f8 08 46 	ld.w	r8,pc[2118]
8000342e:	91 09       	st.w	r8[0x0],r9
80003430:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
					case Radio_Internal_Parameter://0x7F
							
							//logFromISR("\n\r Item_Length:%d\n\r", Item_Length);
							
							if ((RxBytesWaiting -= 4) <= 0) break;
80003434:	fe f9 08 40 	ld.w	r9,pc[2112]
80003438:	72 08       	ld.w	r8,r9[0x0]
8000343a:	20 48       	sub	r8,4
8000343c:	93 08       	st.w	r9[0x0],r8
8000343e:	e0 80 03 f9 	breq	80003c30 <phy_rx_func+0xbc0>
							//Radio Internal Parameter
							Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[3];
80003442:	fe f8 08 62 	ld.w	r8,pc[2146]
80003446:	70 09       	ld.w	r9,r8[0x0]
80003448:	8e 7b       	ld.sh	r11,r7[0xe]
8000344a:	fe fa 08 5e 	ld.w	r10,pc[2142]
8000344e:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
							RxData_IsFillingNext16 += 1; 
80003452:	2f f9       	sub	r9,-1
80003454:	91 09       	st.w	r8[0x0],r9
							Item_Length -= 2 ;
80003456:	fe f8 08 32 	ld.w	r8,pc[2098]
8000345a:	70 09       	ld.w	r9,r8[0x0]
8000345c:	20 29       	sub	r9,2
8000345e:	91 09       	st.w	r8[0x0],r9
							//....................................................
							m_RxBurstType = RADIOINTERNAL;
80003460:	30 29       	mov	r9,2
80003462:	fe f8 08 0e 	ld.w	r8,pc[2062]
80003466:	91 09       	st.w	r8[0x0],r9

							RxMediaState = READING_AMBE_AUX;//Jump
80003468:	30 39       	mov	r9,3
8000346a:	fe f8 08 02 	ld.w	r8,pc[2050]
8000346e:	91 09       	st.w	r8[0x0],r9
80003470:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									
					default://0x03,0x04
						
						//((Item_ID == 0x04) || (Item_ID == 0x03) )//Unknown type data directly back hair
							//break;
							m_RxBurstType = UNSUREDATA;
80003474:	30 39       	mov	r9,3
80003476:	fe f8 07 fa 	ld.w	r8,pc[2042]
8000347a:	91 09       	st.w	r8[0x0],r9
							AMBE_HT[0] = payload_rx_channel->dword[0];
8000347c:	6e 29       	ld.w	r9,r7[0x8]
8000347e:	fe f8 08 2e 	ld.w	r8,pc[2094]
80003482:	91 09       	st.w	r8[0x0],r9
							AMBE_HT[1] = payload_rx_channel->dword[1];
80003484:	6e 39       	ld.w	r9,r7[0xc]
80003486:	91 19       	st.w	r8[0x4],r9
							
							if (RxBytesWaiting == 0x00000014)
80003488:	fe f8 07 ec 	ld.w	r8,pc[2028]
8000348c:	70 08       	ld.w	r8,r8[0x0]
8000348e:	59 48       	cp.w	r8,20
80003490:	c0 61       	brne	8000349c <phy_rx_func+0x42c>
							{
								RxBytesWaiting = 0x18;//24 Reassigned
80003492:	31 89       	mov	r9,24
80003494:	fe f8 07 e0 	ld.w	r8,pc[2016]
80003498:	91 09       	st.w	r8[0x0],r9
8000349a:	c0 78       	rjmp	800034a8 <phy_rx_func+0x438>
								//_flag =0;
								
							}
							if (RxBytesWaiting == 0x00000010)
8000349c:	59 08       	cp.w	r8,16
8000349e:	c0 51       	brne	800034a8 <phy_rx_func+0x438>
							{
								RxBytesWaiting = 0x10;//16 Reassigned
800034a0:	31 09       	mov	r9,16
800034a2:	fe f8 07 d2 	ld.w	r8,pc[2002]
800034a6:	91 09       	st.w	r8[0x0],r9
								//_flag =1;
							}
					
							RxMediaState = READING_AMBE_MEDIA;//Jump
800034a8:	30 49       	mov	r9,4
800034aa:	fe f8 07 c2 	ld.w	r8,pc[1986]
800034ae:	91 09       	st.w	r8[0x0],r9
800034b0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
				break;
			}
			
			else
			{
				AMBE_Media = 0;	
800034b4:	30 09       	mov	r9,0
800034b6:	fe f8 07 ca 	ld.w	r8,pc[1994]
800034ba:	b0 89       	st.b	r8[0x0],r9
800034bc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

		case READING_AMBE_MEDIA:
		
			/****AMBE-media-data ****/
		
					if ((Item_ID == Vocoder_Bit_Stream_Parameter))//PAYLOAD_DATA_ENH (0x0c))
800034c0:	fe f8 07 c4 	ld.w	r8,pc[1988]
800034c4:	11 89       	ld.ub	r9,r8[0x0]
800034c6:	31 28       	mov	r8,18
800034c8:	f0 09 18 00 	cp.b	r9,r8
800034cc:	e0 81 01 4c 	brne	80003764 <phy_rx_func+0x6f4>
					{
						Item_ID = payload_rx_channel->byte[1];
800034d0:	ef 39 00 09 	ld.ub	r9,r7[9]
800034d4:	fe f8 07 b0 	ld.w	r8,pc[1968]
800034d8:	b0 89       	st.b	r8[0x0],r9
						if (Item_ID == Post_Voice_Encoder_Data)//发送方的压缩类型数据
800034da:	11 89       	ld.ub	r9,r8[0x0]
800034dc:	3f 28       	mov	r8,-14
800034de:	f0 09 18 00 	cp.b	r9,r8
800034e2:	e0 81 01 3b 	brne	80003758 <phy_rx_func+0x6e8>
						{
							AMBE_tx_flag = 1;
800034e6:	30 19       	mov	r9,1
800034e8:	fe f8 07 c8 	ld.w	r8,pc[1992]
800034ec:	b0 89       	st.b	r8[0x0],r9
							
							RxBytesWaiting = ((payload_rx_channel->dword[0] & 0x7F000000) >>24);//Test calculations are correct; 8
800034ee:	6e 29       	ld.w	r9,r7[0x8]
800034f0:	f3 d9 c3 07 	bfextu	r9,r9,0x18,0x7
800034f4:	fe f8 07 80 	ld.w	r8,pc[1920]
800034f8:	91 09       	st.w	r8[0x0],r9
							
							//For looping back to Radio
							AMBEBurst_rawdata[0] = payload_rx_channel->word[1];
800034fa:	8e 59       	ld.sh	r9,r7[0xa]
800034fc:	fe f8 07 b8 	ld.w	r8,pc[1976]
80003500:	b0 09       	st.h	r8[0x0],r9
							AMBEBurst_rawdata[1] = payload_rx_channel->word[2];
80003502:	8e 69       	ld.sh	r9,r7[0xc]
80003504:	b0 19       	st.h	r8[0x2],r9
							AMBEBurst_rawdata[2] = payload_rx_channel->word[3];
80003506:	8e 79       	ld.sh	r9,r7[0xe]
80003508:	b0 29       	st.h	r8[0x4],r9
							
							//To be tested. Also locally stored RAW-AMBER-DATA
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//1
8000350a:	fe f8 07 82 	ld.w	r8,pc[1922]
8000350e:	fe f9 07 5a 	ld.w	r9,pc[1882]
80003512:	72 0a       	ld.w	r10,r9[0x0]
80003514:	70 09       	ld.w	r9,r8[0x0]
80003516:	ef 3b 00 0a 	ld.ub	r11,r7[10]
8000351a:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
8000351e:	70 09       	ld.w	r9,r8[0x0]
80003520:	2f f9       	sub	r9,-1
80003522:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003524:	e0 49 01 ff 	cp.w	r9,511
80003528:	e0 88 00 16 	brls	80003554 <phy_rx_func+0x4e4>
							{
								RxAMBE_IsFillingNext8 = 0;
8000352c:	30 09       	mov	r9,0
8000352e:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003530:	fe f6 07 38 	ld.w	r6,pc[1848]
80003534:	6c 0c       	ld.w	r12,r6[0x0]
80003536:	f0 1f 01 d8 	mcall	80003c94 <phy_rx_func+0xc24>
								AMBE_payload_ptr = get_payload_idle_isr();
8000353a:	fe f8 07 2a 	ld.w	r8,pc[1834]
8000353e:	70 0c       	ld.w	r12,r8[0x0]
80003540:	f0 1f 01 c3 	mcall	80003c4c <phy_rx_func+0xbdc>
80003544:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003546:	c0 71       	brne	80003554 <phy_rx_func+0x4e4>
								{
									RxMediaState = WAITINGABAB;
80003548:	30 09       	mov	r9,0
8000354a:	fe f8 07 22 	ld.w	r8,pc[1826]
8000354e:	91 09       	st.w	r8[0x0],r9
80003550:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003554:	fe f9 07 20 	ld.w	r9,pc[1824]
80003558:	72 08       	ld.w	r8,r9[0x0]
8000355a:	20 18       	sub	r8,1
8000355c:	93 08       	st.w	r9[0x0],r8
8000355e:	c0 71       	brne	8000356c <phy_rx_func+0x4fc>
								RxMediaState = WAITINGABAB;
80003560:	30 09       	mov	r9,0
80003562:	fe f8 07 0a 	ld.w	r8,pc[1802]
80003566:	91 09       	st.w	r8[0x0],r9
80003568:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}			
							
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//2
8000356c:	fe f8 07 20 	ld.w	r8,pc[1824]
80003570:	fe f9 06 f8 	ld.w	r9,pc[1784]
80003574:	72 0a       	ld.w	r10,r9[0x0]
80003576:	70 09       	ld.w	r9,r8[0x0]
80003578:	ef 3b 00 0b 	ld.ub	r11,r7[11]
8000357c:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003580:	70 09       	ld.w	r9,r8[0x0]
80003582:	2f f9       	sub	r9,-1
80003584:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003586:	e0 49 01 ff 	cp.w	r9,511
8000358a:	e0 88 00 16 	brls	800035b6 <phy_rx_func+0x546>
							{
								RxAMBE_IsFillingNext8 = 0;
8000358e:	30 09       	mov	r9,0
80003590:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003592:	fe f6 06 d6 	ld.w	r6,pc[1750]
80003596:	6c 0c       	ld.w	r12,r6[0x0]
80003598:	f0 1f 01 bf 	mcall	80003c94 <phy_rx_func+0xc24>
								AMBE_payload_ptr = get_payload_idle_isr();
8000359c:	fe f8 06 c8 	ld.w	r8,pc[1736]
800035a0:	70 0c       	ld.w	r12,r8[0x0]
800035a2:	f0 1f 01 ab 	mcall	80003c4c <phy_rx_func+0xbdc>
800035a6:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
800035a8:	c0 71       	brne	800035b6 <phy_rx_func+0x546>
								{
									RxMediaState = WAITINGABAB;
800035aa:	30 09       	mov	r9,0
800035ac:	fe f8 06 c0 	ld.w	r8,pc[1728]
800035b0:	91 09       	st.w	r8[0x0],r9
800035b2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800035b6:	fe f9 06 be 	ld.w	r9,pc[1726]
800035ba:	72 08       	ld.w	r8,r9[0x0]
800035bc:	20 18       	sub	r8,1
800035be:	93 08       	st.w	r9[0x0],r8
800035c0:	c0 71       	brne	800035ce <phy_rx_func+0x55e>
								RxMediaState = WAITINGABAB;
800035c2:	30 09       	mov	r9,0
800035c4:	fe f8 06 a8 	ld.w	r8,pc[1704]
800035c8:	91 09       	st.w	r8[0x0],r9
800035ca:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}		
						
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//3
800035ce:	fe f8 06 be 	ld.w	r8,pc[1726]
800035d2:	fe f9 06 96 	ld.w	r9,pc[1686]
800035d6:	72 0a       	ld.w	r10,r9[0x0]
800035d8:	70 09       	ld.w	r9,r8[0x0]
800035da:	ef 3b 00 0c 	ld.ub	r11,r7[12]
800035de:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
800035e2:	70 09       	ld.w	r9,r8[0x0]
800035e4:	2f f9       	sub	r9,-1
800035e6:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800035e8:	e0 49 01 ff 	cp.w	r9,511
800035ec:	e0 88 00 16 	brls	80003618 <phy_rx_func+0x5a8>
							{
								RxAMBE_IsFillingNext8 = 0;
800035f0:	30 09       	mov	r9,0
800035f2:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800035f4:	fe f6 06 74 	ld.w	r6,pc[1652]
800035f8:	6c 0c       	ld.w	r12,r6[0x0]
800035fa:	f0 1f 01 a7 	mcall	80003c94 <phy_rx_func+0xc24>
								AMBE_payload_ptr = get_payload_idle_isr();
800035fe:	fe f8 06 66 	ld.w	r8,pc[1638]
80003602:	70 0c       	ld.w	r12,r8[0x0]
80003604:	f0 1f 01 92 	mcall	80003c4c <phy_rx_func+0xbdc>
80003608:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
8000360a:	c0 71       	brne	80003618 <phy_rx_func+0x5a8>
								{
									RxMediaState = WAITINGABAB;
8000360c:	30 09       	mov	r9,0
8000360e:	fe f8 06 5e 	ld.w	r8,pc[1630]
80003612:	91 09       	st.w	r8[0x0],r9
80003614:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003618:	fe f9 06 5c 	ld.w	r9,pc[1628]
8000361c:	72 08       	ld.w	r8,r9[0x0]
8000361e:	20 18       	sub	r8,1
80003620:	93 08       	st.w	r9[0x0],r8
80003622:	c0 71       	brne	80003630 <phy_rx_func+0x5c0>
								RxMediaState = WAITINGABAB;
80003624:	30 09       	mov	r9,0
80003626:	fe f8 06 46 	ld.w	r8,pc[1606]
8000362a:	91 09       	st.w	r8[0x0],r9
8000362c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[5];//4
80003630:	fe f8 06 5c 	ld.w	r8,pc[1628]
80003634:	fe f9 06 34 	ld.w	r9,pc[1588]
80003638:	72 0a       	ld.w	r10,r9[0x0]
8000363a:	70 09       	ld.w	r9,r8[0x0]
8000363c:	ef 3b 00 0d 	ld.ub	r11,r7[13]
80003640:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003644:	70 09       	ld.w	r9,r8[0x0]
80003646:	2f f9       	sub	r9,-1
80003648:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000364a:	e0 49 01 ff 	cp.w	r9,511
8000364e:	e0 88 00 16 	brls	8000367a <phy_rx_func+0x60a>
							{
								RxAMBE_IsFillingNext8 = 0;
80003652:	30 09       	mov	r9,0
80003654:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003656:	fe f6 06 12 	ld.w	r6,pc[1554]
8000365a:	6c 0c       	ld.w	r12,r6[0x0]
8000365c:	f0 1f 01 8e 	mcall	80003c94 <phy_rx_func+0xc24>
								AMBE_payload_ptr = get_payload_idle_isr();
80003660:	fe f8 06 04 	ld.w	r8,pc[1540]
80003664:	70 0c       	ld.w	r12,r8[0x0]
80003666:	f0 1f 01 7a 	mcall	80003c4c <phy_rx_func+0xbdc>
8000366a:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
8000366c:	c0 71       	brne	8000367a <phy_rx_func+0x60a>
								{
									RxMediaState = WAITINGABAB;
8000366e:	30 09       	mov	r9,0
80003670:	fe f8 05 fc 	ld.w	r8,pc[1532]
80003674:	91 09       	st.w	r8[0x0],r9
80003676:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
8000367a:	fe f9 05 fa 	ld.w	r9,pc[1530]
8000367e:	72 08       	ld.w	r8,r9[0x0]
80003680:	20 18       	sub	r8,1
80003682:	93 08       	st.w	r9[0x0],r8
80003684:	c0 71       	brne	80003692 <phy_rx_func+0x622>
								RxMediaState = WAITINGABAB;
80003686:	30 09       	mov	r9,0
80003688:	fe f8 05 e4 	ld.w	r8,pc[1508]
8000368c:	91 09       	st.w	r8[0x0],r9
8000368e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//5
80003692:	fe f8 05 fa 	ld.w	r8,pc[1530]
80003696:	fe f9 05 d2 	ld.w	r9,pc[1490]
8000369a:	72 0a       	ld.w	r10,r9[0x0]
8000369c:	70 09       	ld.w	r9,r8[0x0]
8000369e:	ef 3b 00 0e 	ld.ub	r11,r7[14]
800036a2:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
800036a6:	70 09       	ld.w	r9,r8[0x0]
800036a8:	2f f9       	sub	r9,-1
800036aa:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800036ac:	e0 49 01 ff 	cp.w	r9,511
800036b0:	e0 88 00 16 	brls	800036dc <phy_rx_func+0x66c>
							{
								RxAMBE_IsFillingNext8 = 0;
800036b4:	30 09       	mov	r9,0
800036b6:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800036b8:	fe f6 05 b0 	ld.w	r6,pc[1456]
800036bc:	6c 0c       	ld.w	r12,r6[0x0]
800036be:	f0 1f 01 76 	mcall	80003c94 <phy_rx_func+0xc24>
								AMBE_payload_ptr = get_payload_idle_isr();
800036c2:	fe f8 05 a2 	ld.w	r8,pc[1442]
800036c6:	70 0c       	ld.w	r12,r8[0x0]
800036c8:	f0 1f 01 61 	mcall	80003c4c <phy_rx_func+0xbdc>
800036cc:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
800036ce:	c0 71       	brne	800036dc <phy_rx_func+0x66c>
								{
									RxMediaState = WAITINGABAB;
800036d0:	30 09       	mov	r9,0
800036d2:	fe f8 05 9a 	ld.w	r8,pc[1434]
800036d6:	91 09       	st.w	r8[0x0],r9
800036d8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800036dc:	fe f9 05 98 	ld.w	r9,pc[1432]
800036e0:	72 08       	ld.w	r8,r9[0x0]
800036e2:	20 18       	sub	r8,1
800036e4:	93 08       	st.w	r9[0x0],r8
800036e6:	c0 71       	brne	800036f4 <phy_rx_func+0x684>
								RxMediaState = WAITINGABAB;
800036e8:	30 09       	mov	r9,0
800036ea:	fe f8 05 82 	ld.w	r8,pc[1410]
800036ee:	91 09       	st.w	r8[0x0],r9
800036f0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//6
800036f4:	fe f8 05 98 	ld.w	r8,pc[1432]
800036f8:	fe f9 05 70 	ld.w	r9,pc[1392]
800036fc:	72 0a       	ld.w	r10,r9[0x0]
800036fe:	70 09       	ld.w	r9,r8[0x0]
80003700:	ef 3b 00 0f 	ld.ub	r11,r7[15]
80003704:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003708:	70 09       	ld.w	r9,r8[0x0]
8000370a:	2f f9       	sub	r9,-1
8000370c:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000370e:	e0 49 01 ff 	cp.w	r9,511
80003712:	e0 88 00 16 	brls	8000373e <phy_rx_func+0x6ce>
							{
								RxAMBE_IsFillingNext8 = 0;
80003716:	30 09       	mov	r9,0
80003718:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
8000371a:	fe f7 05 4e 	ld.w	r7,pc[1358]
8000371e:	6e 0c       	ld.w	r12,r7[0x0]
80003720:	f0 1f 01 5d 	mcall	80003c94 <phy_rx_func+0xc24>
								AMBE_payload_ptr = get_payload_idle_isr();
80003724:	fe f8 05 40 	ld.w	r8,pc[1344]
80003728:	70 0c       	ld.w	r12,r8[0x0]
8000372a:	f0 1f 01 49 	mcall	80003c4c <phy_rx_func+0xbdc>
8000372e:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003730:	c0 71       	brne	8000373e <phy_rx_func+0x6ce>
								{
									RxMediaState = WAITINGABAB;
80003732:	30 09       	mov	r9,0
80003734:	fe f8 05 38 	ld.w	r8,pc[1336]
80003738:	91 09       	st.w	r8[0x0],r9
8000373a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
8000373e:	fe f9 05 36 	ld.w	r9,pc[1334]
80003742:	72 08       	ld.w	r8,r9[0x0]
80003744:	20 18       	sub	r8,1
80003746:	93 08       	st.w	r9[0x0],r8
80003748:	e0 81 02 74 	brne	80003c30 <phy_rx_func+0xbc0>
								RxMediaState = WAITINGABAB;
8000374c:	30 09       	mov	r9,0
8000374e:	fe f8 05 1e 	ld.w	r8,pc[1310]
80003752:	91 09       	st.w	r8[0x0],r9
80003754:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							//}
							
						}
						else//error
						{
							RxMediaState = WAITINGABAB;
80003758:	30 09       	mov	r9,0
8000375a:	fe f8 05 12 	ld.w	r8,pc[1298]
8000375e:	91 09       	st.w	r8[0x0],r9
80003760:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
					}
					else if (Item_ID == Post_Voice_Encoder_Data)//(bit48~Pad-bits)
80003764:	fe f8 05 20 	ld.w	r8,pc[1312]
80003768:	11 89       	ld.ub	r9,r8[0x0]
8000376a:	3f 28       	mov	r8,-14
8000376c:	f0 09 18 00 	cp.b	r9,r8
80003770:	c4 31       	brne	800037f6 <phy_rx_func+0x786>
					{
					
						AMBEBurst_rawdata[3] = payload_rx_channel->word[0];//(bit48~Pad-bits)
80003772:	8e 49       	ld.sh	r9,r7[0x8]
80003774:	fe f8 05 40 	ld.w	r8,pc[1344]
80003778:	b0 39       	st.h	r8[0x6],r9
						//AMBE_Per_Burst_Flag = 1;
						
						//根据MOTO.bit文件数据分布，建议测试pad-bits的最后一个字节不保存。
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//7
8000377a:	fe f8 05 12 	ld.w	r8,pc[1298]
8000377e:	fe f9 04 ea 	ld.w	r9,pc[1258]
80003782:	72 0a       	ld.w	r10,r9[0x0]
80003784:	70 09       	ld.w	r9,r8[0x0]
80003786:	ef 3b 00 08 	ld.ub	r11,r7[8]
8000378a:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
8000378e:	70 09       	ld.w	r9,r8[0x0]
80003790:	2f f9       	sub	r9,-1
80003792:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003794:	e0 49 01 ff 	cp.w	r9,511
80003798:	e0 88 00 16 	brls	800037c4 <phy_rx_func+0x754>
						{
							RxAMBE_IsFillingNext8 = 0;
8000379c:	30 09       	mov	r9,0
8000379e:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800037a0:	fe f7 04 c8 	ld.w	r7,pc[1224]
800037a4:	6e 0c       	ld.w	r12,r7[0x0]
800037a6:	f0 1f 01 3c 	mcall	80003c94 <phy_rx_func+0xc24>
							AMBE_payload_ptr = get_payload_idle_isr();
800037aa:	fe f8 04 ba 	ld.w	r8,pc[1210]
800037ae:	70 0c       	ld.w	r12,r8[0x0]
800037b0:	f0 1f 01 27 	mcall	80003c4c <phy_rx_func+0xbdc>
800037b4:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
800037b6:	c0 71       	brne	800037c4 <phy_rx_func+0x754>
							{
								RxMediaState = WAITINGABAB;
800037b8:	30 09       	mov	r9,0
800037ba:	fe f8 04 b2 	ld.w	r8,pc[1202]
800037be:	91 09       	st.w	r8[0x0],r9
800037c0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800037c4:	fe f9 04 b0 	ld.w	r9,pc[1200]
800037c8:	72 08       	ld.w	r8,r9[0x0]
800037ca:	20 18       	sub	r8,1
800037cc:	93 08       	st.w	r9[0x0],r8
800037ce:	c0 71       	brne	800037dc <phy_rx_func+0x76c>
							RxMediaState = WAITINGABAB;
800037d0:	30 09       	mov	r9,0
800037d2:	fe f8 04 9a 	ld.w	r8,pc[1178]
800037d6:	91 09       	st.w	r8[0x0],r9
800037d8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
						if ((RxBytesWaiting -= 1) <= 0){//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
800037dc:	20 18       	sub	r8,1
800037de:	fe f9 04 96 	ld.w	r9,pc[1174]
800037e2:	93 08       	st.w	r9[0x0],r8
800037e4:	58 08       	cp.w	r8,0
800037e6:	e0 81 02 25 	brne	80003c30 <phy_rx_func+0xbc0>
							RxMediaState = WAITINGABAB;
800037ea:	30 09       	mov	r9,0
800037ec:	fe f8 04 80 	ld.w	r8,pc[1152]
800037f0:	91 09       	st.w	r8[0x0],r9
800037f2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
								
					}
					else if (Item_ID == Pre_Voice_Decoder_Data)//bit16~bit63
800037f6:	fe f8 04 8e 	ld.w	r8,pc[1166]
800037fa:	11 89       	ld.ub	r9,r8[0x0]
800037fc:	3f 38       	mov	r8,-13
800037fe:	f0 09 18 00 	cp.b	r9,r8
80003802:	e0 81 01 0c 	brne	80003a1a <phy_rx_func+0x9aa>
					{
						//接收方的解压类型数据
						//For looping back to Radio
						AMBEBurst_rawdata[1] = payload_rx_channel->word[0];
80003806:	8e 49       	ld.sh	r9,r7[0x8]
80003808:	fe f8 04 ac 	ld.w	r8,pc[1196]
8000380c:	b0 19       	st.h	r8[0x2],r9
						AMBEBurst_rawdata[2] = payload_rx_channel->word[1];
8000380e:	8e 59       	ld.sh	r9,r7[0xa]
80003810:	b0 29       	st.h	r8[0x4],r9
						AMBEBurst_rawdata[3] = payload_rx_channel->word[2];
80003812:	8e 69       	ld.sh	r9,r7[0xc]
80003814:	b0 39       	st.h	r8[0x6],r9
						//if((m_RxBurstType == VOICEBURST_A) && (VF_SN == 1))
						//logFromISR("\n\r Pre_rx:%X\n\r", payload_rx_channel->word[2]);
						
						//To be tested. Also locally stored RAW-AMBER-DATA
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//3
80003816:	fe f8 04 76 	ld.w	r8,pc[1142]
8000381a:	fe f9 04 4e 	ld.w	r9,pc[1102]
8000381e:	72 0a       	ld.w	r10,r9[0x0]
80003820:	70 09       	ld.w	r9,r8[0x0]
80003822:	ef 3b 00 08 	ld.ub	r11,r7[8]
80003826:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
8000382a:	70 09       	ld.w	r9,r8[0x0]
8000382c:	2f f9       	sub	r9,-1
8000382e:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003830:	e0 49 01 ff 	cp.w	r9,511
80003834:	e0 88 00 16 	brls	80003860 <phy_rx_func+0x7f0>
						{
							RxAMBE_IsFillingNext8 = 0;
80003838:	30 09       	mov	r9,0
8000383a:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
8000383c:	fe f6 04 2c 	ld.w	r6,pc[1068]
80003840:	6c 0c       	ld.w	r12,r6[0x0]
80003842:	f0 1f 01 15 	mcall	80003c94 <phy_rx_func+0xc24>
							AMBE_payload_ptr = get_payload_idle_isr();
80003846:	fe f8 04 1e 	ld.w	r8,pc[1054]
8000384a:	70 0c       	ld.w	r12,r8[0x0]
8000384c:	f0 1f 01 00 	mcall	80003c4c <phy_rx_func+0xbdc>
80003850:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003852:	c0 71       	brne	80003860 <phy_rx_func+0x7f0>
							{
								RxMediaState = WAITINGABAB;
80003854:	30 09       	mov	r9,0
80003856:	fe f8 04 16 	ld.w	r8,pc[1046]
8000385a:	91 09       	st.w	r8[0x0],r9
8000385c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003860:	fe f9 04 14 	ld.w	r9,pc[1044]
80003864:	72 08       	ld.w	r8,r9[0x0]
80003866:	20 18       	sub	r8,1
80003868:	93 08       	st.w	r9[0x0],r8
8000386a:	c0 71       	brne	80003878 <phy_rx_func+0x808>
							RxMediaState = WAITINGABAB;
8000386c:	30 09       	mov	r9,0
8000386e:	fe f8 03 fe 	ld.w	r8,pc[1022]
80003872:	91 09       	st.w	r8[0x0],r9
80003874:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[1];//4
80003878:	fe f8 04 14 	ld.w	r8,pc[1044]
8000387c:	fe f9 03 ec 	ld.w	r9,pc[1004]
80003880:	72 0a       	ld.w	r10,r9[0x0]
80003882:	70 09       	ld.w	r9,r8[0x0]
80003884:	ef 3b 00 09 	ld.ub	r11,r7[9]
80003888:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
8000388c:	70 09       	ld.w	r9,r8[0x0]
8000388e:	2f f9       	sub	r9,-1
80003890:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003892:	e0 49 01 ff 	cp.w	r9,511
80003896:	e0 88 00 16 	brls	800038c2 <phy_rx_func+0x852>
						{
							RxAMBE_IsFillingNext8 = 0;
8000389a:	30 09       	mov	r9,0
8000389c:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
8000389e:	fe f6 03 ca 	ld.w	r6,pc[970]
800038a2:	6c 0c       	ld.w	r12,r6[0x0]
800038a4:	f0 1f 00 fc 	mcall	80003c94 <phy_rx_func+0xc24>
							AMBE_payload_ptr = get_payload_idle_isr();
800038a8:	fe f8 03 bc 	ld.w	r8,pc[956]
800038ac:	70 0c       	ld.w	r12,r8[0x0]
800038ae:	f0 1f 00 e8 	mcall	80003c4c <phy_rx_func+0xbdc>
800038b2:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
800038b4:	c0 71       	brne	800038c2 <phy_rx_func+0x852>
							{
								RxMediaState = WAITINGABAB;
800038b6:	30 09       	mov	r9,0
800038b8:	fe f8 03 b4 	ld.w	r8,pc[948]
800038bc:	91 09       	st.w	r8[0x0],r9
800038be:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800038c2:	fe f9 03 b2 	ld.w	r9,pc[946]
800038c6:	72 08       	ld.w	r8,r9[0x0]
800038c8:	20 18       	sub	r8,1
800038ca:	93 08       	st.w	r9[0x0],r8
800038cc:	c0 71       	brne	800038da <phy_rx_func+0x86a>
							RxMediaState = WAITINGABAB;
800038ce:	30 09       	mov	r9,0
800038d0:	fe f8 03 9c 	ld.w	r8,pc[924]
800038d4:	91 09       	st.w	r8[0x0],r9
800038d6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//5
800038da:	fe f8 03 b2 	ld.w	r8,pc[946]
800038de:	fe f9 03 8a 	ld.w	r9,pc[906]
800038e2:	72 0a       	ld.w	r10,r9[0x0]
800038e4:	70 09       	ld.w	r9,r8[0x0]
800038e6:	ef 3b 00 0a 	ld.ub	r11,r7[10]
800038ea:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800038ee:	70 09       	ld.w	r9,r8[0x0]
800038f0:	2f f9       	sub	r9,-1
800038f2:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800038f4:	e0 49 01 ff 	cp.w	r9,511
800038f8:	e0 88 00 16 	brls	80003924 <phy_rx_func+0x8b4>
						{
							RxAMBE_IsFillingNext8 = 0;
800038fc:	30 09       	mov	r9,0
800038fe:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003900:	fe f6 03 68 	ld.w	r6,pc[872]
80003904:	6c 0c       	ld.w	r12,r6[0x0]
80003906:	f0 1f 00 e4 	mcall	80003c94 <phy_rx_func+0xc24>
							AMBE_payload_ptr = get_payload_idle_isr();
8000390a:	fe f8 03 5a 	ld.w	r8,pc[858]
8000390e:	70 0c       	ld.w	r12,r8[0x0]
80003910:	f0 1f 00 cf 	mcall	80003c4c <phy_rx_func+0xbdc>
80003914:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003916:	c0 71       	brne	80003924 <phy_rx_func+0x8b4>
							{
								RxMediaState = WAITINGABAB;
80003918:	30 09       	mov	r9,0
8000391a:	fe f8 03 52 	ld.w	r8,pc[850]
8000391e:	91 09       	st.w	r8[0x0],r9
80003920:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003924:	fe f9 03 50 	ld.w	r9,pc[848]
80003928:	72 08       	ld.w	r8,r9[0x0]
8000392a:	20 18       	sub	r8,1
8000392c:	93 08       	st.w	r9[0x0],r8
8000392e:	c0 71       	brne	8000393c <phy_rx_func+0x8cc>
							RxMediaState = WAITINGABAB;
80003930:	30 09       	mov	r9,0
80003932:	fe f8 03 3a 	ld.w	r8,pc[826]
80003936:	91 09       	st.w	r8[0x0],r9
80003938:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//6
8000393c:	fe f8 03 50 	ld.w	r8,pc[848]
80003940:	fe f9 03 28 	ld.w	r9,pc[808]
80003944:	72 0a       	ld.w	r10,r9[0x0]
80003946:	70 09       	ld.w	r9,r8[0x0]
80003948:	ef 3b 00 0b 	ld.ub	r11,r7[11]
8000394c:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003950:	70 09       	ld.w	r9,r8[0x0]
80003952:	2f f9       	sub	r9,-1
80003954:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003956:	e0 49 01 ff 	cp.w	r9,511
8000395a:	e0 88 00 16 	brls	80003986 <phy_rx_func+0x916>
						{
							RxAMBE_IsFillingNext8 = 0;
8000395e:	30 09       	mov	r9,0
80003960:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003962:	fe f6 03 06 	ld.w	r6,pc[774]
80003966:	6c 0c       	ld.w	r12,r6[0x0]
80003968:	f0 1f 00 cb 	mcall	80003c94 <phy_rx_func+0xc24>
							AMBE_payload_ptr = get_payload_idle_isr();
8000396c:	fe f8 02 f8 	ld.w	r8,pc[760]
80003970:	70 0c       	ld.w	r12,r8[0x0]
80003972:	f0 1f 00 b7 	mcall	80003c4c <phy_rx_func+0xbdc>
80003976:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003978:	c0 71       	brne	80003986 <phy_rx_func+0x916>
							{
								RxMediaState = WAITINGABAB;
8000397a:	30 09       	mov	r9,0
8000397c:	fe f8 02 f0 	ld.w	r8,pc[752]
80003980:	91 09       	st.w	r8[0x0],r9
80003982:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003986:	fe f9 02 ee 	ld.w	r9,pc[750]
8000398a:	72 08       	ld.w	r8,r9[0x0]
8000398c:	20 18       	sub	r8,1
8000398e:	93 08       	st.w	r9[0x0],r8
80003990:	c0 71       	brne	8000399e <phy_rx_func+0x92e>
							RxMediaState = WAITINGABAB;
80003992:	30 09       	mov	r9,0
80003994:	fe f8 02 d8 	ld.w	r8,pc[728]
80003998:	91 09       	st.w	r8[0x0],r9
8000399a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//7
8000399e:	fe f8 02 ee 	ld.w	r8,pc[750]
800039a2:	fe f9 02 c6 	ld.w	r9,pc[710]
800039a6:	72 0a       	ld.w	r10,r9[0x0]
800039a8:	70 09       	ld.w	r9,r8[0x0]
800039aa:	ef 3b 00 0c 	ld.ub	r11,r7[12]
800039ae:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800039b2:	70 09       	ld.w	r9,r8[0x0]
800039b4:	2f f9       	sub	r9,-1
800039b6:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800039b8:	e0 49 01 ff 	cp.w	r9,511
800039bc:	e0 88 00 16 	brls	800039e8 <phy_rx_func+0x978>
						{
							RxAMBE_IsFillingNext8 = 0;
800039c0:	30 09       	mov	r9,0
800039c2:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800039c4:	fe f7 02 a4 	ld.w	r7,pc[676]
800039c8:	6e 0c       	ld.w	r12,r7[0x0]
800039ca:	f0 1f 00 b3 	mcall	80003c94 <phy_rx_func+0xc24>
							AMBE_payload_ptr = get_payload_idle_isr();
800039ce:	fe f8 02 96 	ld.w	r8,pc[662]
800039d2:	70 0c       	ld.w	r12,r8[0x0]
800039d4:	f0 1f 00 9e 	mcall	80003c4c <phy_rx_func+0xbdc>
800039d8:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
800039da:	c0 71       	brne	800039e8 <phy_rx_func+0x978>
							{
								RxMediaState = WAITINGABAB;
800039dc:	30 09       	mov	r9,0
800039de:	fe f8 02 8e 	ld.w	r8,pc[654]
800039e2:	91 09       	st.w	r8[0x0],r9
800039e4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800039e8:	fe f9 02 8c 	ld.w	r9,pc[652]
800039ec:	72 08       	ld.w	r8,r9[0x0]
800039ee:	20 18       	sub	r8,1
800039f0:	93 08       	st.w	r9[0x0],r8
800039f2:	c0 71       	brne	80003a00 <phy_rx_func+0x990>
							RxMediaState = WAITINGABAB;
800039f4:	30 09       	mov	r9,0
800039f6:	fe f8 02 76 	ld.w	r8,pc[630]
800039fa:	91 09       	st.w	r8[0x0],r9
800039fc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
						if ((RxBytesWaiting -= 1) <= 0){
80003a00:	20 18       	sub	r8,1
80003a02:	fe f9 02 72 	ld.w	r9,pc[626]
80003a06:	93 08       	st.w	r9[0x0],r8
80003a08:	58 08       	cp.w	r8,0
80003a0a:	e0 81 01 13 	brne	80003c30 <phy_rx_func+0xbc0>
							
							//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
							//or discard it to reduce payload size.
							
							RxMediaState = WAITINGABAB;
80003a0e:	30 09       	mov	r9,0
80003a10:	fe f8 02 5c 	ld.w	r8,pc[604]
80003a14:	91 09       	st.w	r8[0x0],r9
80003a16:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
					}
					else if ((Item_ID == 0x04)  ||  (Item_ID == 0x03))//Unknown type data directly back hair
80003a1a:	fe f8 02 6a 	ld.w	r8,pc[618]
80003a1e:	11 89       	ld.ub	r9,r8[0x0]
80003a20:	30 48       	mov	r8,4
80003a22:	f0 09 18 00 	cp.b	r9,r8
80003a26:	c0 80       	breq	80003a36 <phy_rx_func+0x9c6>
80003a28:	fe f8 02 5c 	ld.w	r8,pc[604]
80003a2c:	11 89       	ld.ub	r9,r8[0x0]
80003a2e:	30 38       	mov	r8,3
80003a30:	f0 09 18 00 	cp.b	r9,r8
80003a34:	c1 41       	brne	80003a5c <phy_rx_func+0x9ec>
					{
						AMBE_HT[0] = payload_rx_channel->dword[0];
80003a36:	6e 29       	ld.w	r9,r7[0x8]
80003a38:	fe f8 02 74 	ld.w	r8,pc[628]
80003a3c:	91 09       	st.w	r8[0x0],r9
						AMBE_HT[1] = payload_rx_channel->dword[1];				
80003a3e:	6e 39       	ld.w	r9,r7[0xc]
80003a40:	91 19       	st.w	r8[0x4],r9
						
						if ((RxBytesWaiting -= 8) <= 0)//Consider two cases 0xABCDC014 and 0xABCDC010
80003a42:	fe f9 02 32 	ld.w	r9,pc[562]
80003a46:	72 08       	ld.w	r8,r9[0x0]
80003a48:	20 88       	sub	r8,8
80003a4a:	93 08       	st.w	r9[0x0],r8
80003a4c:	e0 81 00 f2 	brne	80003c30 <phy_rx_func+0xbc0>
						{
					
							RxBytesWaiting = 0;
80003a50:	93 08       	st.w	r9[0x0],r8
							RxMediaState = WAITINGABAB;
80003a52:	fe f9 02 1a 	ld.w	r9,pc[538]
80003a56:	93 08       	st.w	r9[0x0],r8
80003a58:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
						}
						break;

					}
					else if (Item_ID == Soft_Decision_Value)
80003a5c:	fe f8 02 28 	ld.w	r8,pc[552]
80003a60:	11 89       	ld.ub	r9,r8[0x0]
80003a62:	31 38       	mov	r8,19
80003a64:	f0 09 18 00 	cp.b	r9,r8
80003a68:	e0 81 00 9c 	brne	80003ba0 <phy_rx_func+0xb30>
					{							
						if (SDV_Index == 12)
80003a6c:	fe f8 02 4c 	ld.w	r8,pc[588]
80003a70:	11 88       	ld.ub	r8,r8[0x0]
80003a72:	30 c9       	mov	r9,12
80003a74:	f2 08 18 00 	cp.b	r8,r9
80003a78:	e0 81 00 7b 	brne	80003b6e <phy_rx_func+0xafe>
						{
							Soft_Decision_Data[SDV_Index]= payload_rx_channel->word[0];
80003a7c:	8e 49       	ld.sh	r9,r7[0x8]
80003a7e:	fe f8 02 3e 	ld.w	r8,pc[574]
80003a82:	f1 59 00 18 	st.h	r8[24],r9
							
							SDV_Index = 0;
80003a86:	30 09       	mov	r9,0
80003a88:	fe f8 02 30 	ld.w	r8,pc[560]
80003a8c:	b0 89       	st.b	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003a8e:	ef 39 00 0d 	ld.ub	r9,r7[13]
80003a92:	3f 38       	mov	r8,-13
80003a94:	f0 09 18 00 	cp.b	r9,r8
80003a98:	c6 61       	brne	80003b64 <phy_rx_func+0xaf4>
							
							SDV_Index = 0;
								
							if (payload_rx_channel->byte[5] == Pre_Voice_Decoder_Data )//0xF3
							{
									Item_ID = Pre_Voice_Decoder_Data;
80003a9a:	10 99       	mov	r9,r8
80003a9c:	4f a8       	lddpc	r8,80003c84 <phy_rx_func+0xc14>
80003a9e:	b0 89       	st.b	r8[0x0],r9
									RxBytesWaiting = (payload_rx_channel->byte[4] & 0x7F);//Test calculations are correct; 8
80003aa0:	ef 39 00 0c 	ld.ub	r9,r7[12]
80003aa4:	f3 d9 c0 07 	bfextu	r9,r9,0x0,0x7
80003aa8:	4f 38       	lddpc	r8,80003c74 <phy_rx_func+0xc04>
80003aaa:	91 09       	st.w	r8[0x0],r9
									AMBE_rx_flag = 1;//本地作为AMBE数据的解密方
80003aac:	30 19       	mov	r9,1
80003aae:	fe f8 02 12 	ld.w	r8,pc[530]
80003ab2:	b0 89       	st.b	r8[0x0],r9
		
									AMBEBurst_rawdata[0] = payload_rx_channel->word[3];//用于解密的中间数据变量
80003ab4:	8e 79       	ld.sh	r9,r7[0xe]
80003ab6:	fe f8 01 fe 	ld.w	r8,pc[510]
80003aba:	b0 09       	st.h	r8[0x0],r9
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//1
80003abc:	4f 48       	lddpc	r8,80003c8c <phy_rx_func+0xc1c>
80003abe:	4e b9       	lddpc	r9,80003c68 <phy_rx_func+0xbf8>
80003ac0:	72 0a       	ld.w	r10,r9[0x0]
80003ac2:	70 09       	ld.w	r9,r8[0x0]
80003ac4:	ef 3b 00 0e 	ld.ub	r11,r7[14]
80003ac8:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
80003acc:	70 09       	ld.w	r9,r8[0x0]
80003ace:	2f f9       	sub	r9,-1
80003ad0:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003ad2:	e0 49 01 ff 	cp.w	r9,511
80003ad6:	e0 88 00 13 	brls	80003afc <phy_rx_func+0xa8c>
									{
										RxAMBE_IsFillingNext8 = 0;
80003ada:	30 09       	mov	r9,0
80003adc:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
80003ade:	4e 36       	lddpc	r6,80003c68 <phy_rx_func+0xbf8>
80003ae0:	6c 0c       	ld.w	r12,r6[0x0]
80003ae2:	f0 1f 00 6d 	mcall	80003c94 <phy_rx_func+0xc24>
										AMBE_payload_ptr = get_payload_idle_isr();
80003ae6:	4e 08       	lddpc	r8,80003c64 <phy_rx_func+0xbf4>
80003ae8:	70 0c       	ld.w	r12,r8[0x0]
80003aea:	f0 1f 00 59 	mcall	80003c4c <phy_rx_func+0xbdc>
80003aee:	8d 0c       	st.w	r6[0x0],r12
										if(NULL == AMBE_payload_ptr)
80003af0:	c0 61       	brne	80003afc <phy_rx_func+0xa8c>
										{
											RxMediaState = WAITINGABAB;
80003af2:	30 09       	mov	r9,0
80003af4:	4d e8       	lddpc	r8,80003c6c <phy_rx_func+0xbfc>
80003af6:	91 09       	st.w	r8[0x0],r9
80003af8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
80003afc:	4d e9       	lddpc	r9,80003c74 <phy_rx_func+0xc04>
80003afe:	72 08       	ld.w	r8,r9[0x0]
80003b00:	20 18       	sub	r8,1
80003b02:	93 08       	st.w	r9[0x0],r8
80003b04:	c0 61       	brne	80003b10 <phy_rx_func+0xaa0>
										RxMediaState = WAITINGABAB;
80003b06:	30 09       	mov	r9,0
80003b08:	4d 98       	lddpc	r8,80003c6c <phy_rx_func+0xbfc>
80003b0a:	91 09       	st.w	r8[0x0],r9
80003b0c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//2
80003b10:	4d f8       	lddpc	r8,80003c8c <phy_rx_func+0xc1c>
80003b12:	4d 69       	lddpc	r9,80003c68 <phy_rx_func+0xbf8>
80003b14:	72 0a       	ld.w	r10,r9[0x0]
80003b16:	70 09       	ld.w	r9,r8[0x0]
80003b18:	ef 3b 00 0f 	ld.ub	r11,r7[15]
80003b1c:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
80003b20:	70 09       	ld.w	r9,r8[0x0]
80003b22:	2f f9       	sub	r9,-1
80003b24:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003b26:	e0 49 01 ff 	cp.w	r9,511
80003b2a:	e0 88 00 13 	brls	80003b50 <phy_rx_func+0xae0>
									{
										RxAMBE_IsFillingNext8 = 0;
80003b2e:	30 09       	mov	r9,0
80003b30:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
80003b32:	4c e7       	lddpc	r7,80003c68 <phy_rx_func+0xbf8>
80003b34:	6e 0c       	ld.w	r12,r7[0x0]
80003b36:	f0 1f 00 58 	mcall	80003c94 <phy_rx_func+0xc24>
										AMBE_payload_ptr = get_payload_idle_isr();
80003b3a:	4c b8       	lddpc	r8,80003c64 <phy_rx_func+0xbf4>
80003b3c:	70 0c       	ld.w	r12,r8[0x0]
80003b3e:	f0 1f 00 44 	mcall	80003c4c <phy_rx_func+0xbdc>
80003b42:	8f 0c       	st.w	r7[0x0],r12
										if(NULL == AMBE_payload_ptr)
80003b44:	c0 61       	brne	80003b50 <phy_rx_func+0xae0>
										{
											RxMediaState = WAITINGABAB;
80003b46:	30 09       	mov	r9,0
80003b48:	4c 98       	lddpc	r8,80003c6c <phy_rx_func+0xbfc>
80003b4a:	91 09       	st.w	r8[0x0],r9
80003b4c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
80003b50:	4c 99       	lddpc	r9,80003c74 <phy_rx_func+0xc04>
80003b52:	72 08       	ld.w	r8,r9[0x0]
80003b54:	20 18       	sub	r8,1
80003b56:	93 08       	st.w	r9[0x0],r8
80003b58:	c6 c1       	brne	80003c30 <phy_rx_func+0xbc0>
										RxMediaState = WAITINGABAB;
80003b5a:	30 09       	mov	r9,0
80003b5c:	4c 48       	lddpc	r8,80003c6c <phy_rx_func+0xbfc>
80003b5e:	91 09       	st.w	r8[0x0],r9
80003b60:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
							}
							else
							RxMediaState = WAITINGABAB;
80003b64:	30 09       	mov	r9,0
80003b66:	4c 28       	lddpc	r8,80003c6c <phy_rx_func+0xbfc>
80003b68:	91 09       	st.w	r8[0x0],r9
80003b6a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
						}
						else
						{
									
							Soft_Decision_Data[SDV_Index]	  = payload_rx_channel->word[0];
80003b6e:	8e 4a       	ld.sh	r10,r7[0x8]
80003b70:	4d 39       	lddpc	r9,80003cbc <phy_rx_func+0xc4c>
80003b72:	f2 08 0a 1a 	st.h	r9[r8<<0x1],r10
							Soft_Decision_Data[SDV_Index+1]	  = payload_rx_channel->word[1];
80003b76:	4d 1a       	lddpc	r10,80003cb8 <phy_rx_func+0xc48>
80003b78:	15 88       	ld.ub	r8,r10[0x0]
80003b7a:	f0 cb ff ff 	sub	r11,r8,-1
80003b7e:	8e 5c       	ld.sh	r12,r7[0xa]
80003b80:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+2]	  = payload_rx_channel->word[2];
80003b84:	f0 cb ff fe 	sub	r11,r8,-2
80003b88:	8e 6c       	ld.sh	r12,r7[0xc]
80003b8a:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+3]	  = payload_rx_channel->word[3];
80003b8e:	f0 cb ff fd 	sub	r11,r8,-3
80003b92:	8e 7c       	ld.sh	r12,r7[0xe]
80003b94:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							SDV_Index +=4;
80003b98:	2f c8       	sub	r8,-4
80003b9a:	b4 88       	st.b	r10[0x0],r8
80003b9c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					
					else
					{
						
						RxMediaState  = WAITINGABAB;
80003ba0:	30 09       	mov	r9,0
80003ba2:	4b 38       	lddpc	r8,80003c6c <phy_rx_func+0xbfc>
80003ba4:	91 09       	st.w	r8[0x0],r9
80003ba6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
			break;//End of READING_AMBE_MEDIA.

        case READING_AMBE_AUX:
			
				Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[0];
80003baa:	4b f8       	lddpc	r8,80003ca4 <phy_rx_func+0xc34>
80003bac:	70 09       	ld.w	r9,r8[0x0]
80003bae:	8e 4b       	ld.sh	r11,r7[0x8]
80003bb0:	4b ea       	lddpc	r10,80003ca8 <phy_rx_func+0xc38>
80003bb2:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
				RxData_IsFillingNext16 += 1;
80003bb6:	2f f9       	sub	r9,-1
80003bb8:	91 09       	st.w	r8[0x0],r9
			
				if ((Item_Length -= 2) <= 0)
80003bba:	4b 48       	lddpc	r8,80003c88 <phy_rx_func+0xc18>
80003bbc:	70 09       	ld.w	r9,r8[0x0]
80003bbe:	20 29       	sub	r9,2
80003bc0:	91 09       	st.w	r8[0x0],r9
80003bc2:	70 08       	ld.w	r8,r8[0x0]
80003bc4:	58 08       	cp.w	r8,0
80003bc6:	c2 f1       	brne	80003c24 <phy_rx_func+0xbb4>
				{
					RxData_IsFillingNext16 = 0;
80003bc8:	30 09       	mov	r9,0
80003bca:	4b 78       	lddpc	r8,80003ca4 <phy_rx_func+0xc34>
80003bcc:	91 09       	st.w	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003bce:	8e 59       	ld.sh	r9,r7[0xa]
80003bd0:	fe 78 82 12 	mov	r8,-32238
80003bd4:	f0 09 19 00 	cp.h	r9,r8
80003bd8:	c2 11       	brne	80003c1a <phy_rx_func+0xbaa>
					{
						//Item_ID = Vocoder_Bit_Stream_Parameter;
						//Vocoder Bits Stream Parameter
						//Its value ranges from 1 to 18 for one voice superframe contains 6 voice bursts
						// and each burst contains 3 VFs.
						VF_SN = (payload_rx_channel->byte[5] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
80003bda:	ef 3c 00 0d 	ld.ub	r12,r7[13]
80003bde:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
80003be2:	4a e8       	lddpc	r8,80003c98 <phy_rx_func+0xc28>
80003be4:	b0 8c       	st.b	r8[0x0],r12
							
						VBSP_data[0] = payload_rx_channel->word[1];
80003be6:	8e 59       	ld.sh	r9,r7[0xa]
80003be8:	4a d8       	lddpc	r8,80003c9c <phy_rx_func+0xc2c>
80003bea:	b0 09       	st.h	r8[0x0],r9
						VBSP_data[1] = payload_rx_channel->word[2];
80003bec:	8e 69       	ld.sh	r9,r7[0xc]
80003bee:	b0 19       	st.h	r8[0x2],r9
							
						m_RxBurstType = CalculateBurst(VF_SN);
80003bf0:	f0 1f 00 2c 	mcall	80003ca0 <phy_rx_func+0xc30>
80003bf4:	49 f8       	lddpc	r8,80003c70 <phy_rx_func+0xc00>
80003bf6:	91 0c       	st.w	r8[0x0],r12
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003bf8:	ef 39 00 0f 	ld.ub	r9,r7[15]
80003bfc:	31 38       	mov	r8,19
80003bfe:	f0 09 18 00 	cp.b	r9,r8
80003c02:	c0 71       	brne	80003c10 <phy_rx_func+0xba0>
							
						m_RxBurstType = CalculateBurst(VF_SN);
						
						if (payload_rx_channel->byte[7] == Soft_Decision_Value)//0x13
						{
							Item_ID = Soft_Decision_Value;	
80003c04:	10 99       	mov	r9,r8
80003c06:	4a 08       	lddpc	r8,80003c84 <phy_rx_func+0xc14>
80003c08:	b0 89       	st.b	r8[0x0],r9
							RxBytesWaiting = ((payload_rx_channel->dword[1] & 0x00007F00) >>24);//Test calculations are correct; 26
80003c0a:	30 09       	mov	r9,0
80003c0c:	49 a8       	lddpc	r8,80003c74 <phy_rx_func+0xc04>
80003c0e:	91 09       	st.w	r8[0x0],r9
						else
						{//error
								RxMediaState = WAITINGABAB;//Jump
						}
							
						RxMediaState = READING_AMBE_MEDIA;//Jump
80003c10:	30 49       	mov	r9,4
80003c12:	49 78       	lddpc	r8,80003c6c <phy_rx_func+0xbfc>
80003c14:	91 09       	st.w	r8[0x0],r9
80003c16:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					else
					{
						RxMediaState = WAITINGABAB;//Jump
80003c1a:	30 09       	mov	r9,0
80003c1c:	49 48       	lddpc	r8,80003c6c <phy_rx_func+0xbfc>
80003c1e:	91 09       	st.w	r8[0x0],r9
80003c20:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}

				}
				else
				{//测试看看是几个字节数据
					logFromISR("\n\r Radio Internal parameter length error \n\r");
80003c24:	4a 8c       	lddpc	r12,80003cc4 <phy_rx_func+0xc54>
80003c26:	f0 1f 00 16 	mcall	80003c7c <phy_rx_func+0xc0c>
					RxMediaState = WAITINGABAB;//Jump
80003c2a:	30 09       	mov	r9,0
80003c2c:	49 08       	lddpc	r8,80003c6c <phy_rx_func+0xbfc>
80003c2e:	91 09       	st.w	r8[0x0],r9
80003c30:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003c34:	00 00       	add	r0,r0
80003c36:	0a b8       	st.h	r5++,r8
80003c38:	00 00       	add	r0,r0
80003c3a:	0a b0       	st.h	r5++,r0
80003c3c:	00 00       	add	r0,r0
80003c3e:	0a 84       	andn	r4,r5
80003c40:	00 00       	add	r0,r0
80003c42:	0a 60       	and	r0,r5
80003c44:	00 00       	add	r0,r0
80003c46:	0a ca       	st.b	r5++,r10
80003c48:	00 00       	add	r0,r0
80003c4a:	0a 90       	mov	r0,r5
80003c4c:	80 00       	ld.sh	r0,r0[0x0]
80003c4e:	2a 3c       	sub	r12,-93
80003c50:	00 00       	add	r0,r0
80003c52:	0a 70       	tst	r0,r5
80003c54:	80 00       	ld.sh	r0,r0[0x0]
80003c56:	53 08       	stdsp	sp[0xc0],r8
80003c58:	00 00       	add	r0,r0
80003c5a:	0a 8c       	andn	r12,r5
80003c5c:	80 00       	ld.sh	r0,r0[0x0]
80003c5e:	29 88       	sub	r8,-104
80003c60:	00 00       	add	r0,r0
80003c62:	0a a0       	st.w	r5++,r0
80003c64:	00 00       	add	r0,r0
80003c66:	0a 6c       	and	r12,r5
80003c68:	00 00       	add	r0,r0
80003c6a:	0a a8       	st.w	r5++,r8
80003c6c:	00 00       	add	r0,r0
80003c6e:	0a 7c       	tst	r12,r5
80003c70:	00 00       	add	r0,r0
80003c72:	0a 68       	and	r8,r5
80003c74:	00 00       	add	r0,r0
80003c76:	0a 94       	mov	r4,r5
80003c78:	80 00       	ld.sh	r0,r0[0x0]
80003c7a:	cb 84       	brge	80003bea <phy_rx_func+0xb7a>
80003c7c:	80 00       	ld.sh	r0,r0[0x0]
80003c7e:	64 00       	ld.w	r0,r2[0x0]
80003c80:	00 00       	add	r0,r0
80003c82:	0a 4f       	or	pc,r5
80003c84:	00 00       	add	r0,r0
80003c86:	0a c8       	st.b	r5++,r8
80003c88:	00 00       	add	r0,r0
80003c8a:	0a 64       	and	r4,r5
80003c8c:	00 00       	add	r0,r0
80003c8e:	0a a4       	st.w	r5++,r4
80003c90:	80 00       	ld.sh	r0,r0[0x0]
80003c92:	6d 1c       	ld.w	r12,r6[0x44]
80003c94:	80 00       	ld.sh	r0,r0[0x0]
80003c96:	30 10       	mov	r0,1
80003c98:	00 00       	add	r0,r0
80003c9a:	0a 40       	or	r0,r5
80003c9c:	00 00       	add	r0,r0
80003c9e:	0e 9c       	mov	r12,r7
80003ca0:	80 00       	ld.sh	r0,r0[0x0]
80003ca2:	28 cc       	sub	r12,-116
80003ca4:	00 00       	add	r0,r0
80003ca6:	0a c0       	st.b	r5++,r0
80003ca8:	00 00       	add	r0,r0
80003caa:	0d a0       	ld.ub	r0,r6[0x2]
80003cac:	00 00       	add	r0,r0
80003cae:	0a cc       	st.b	r5++,r12
80003cb0:	00 00       	add	r0,r0
80003cb2:	0a 52       	eor	r2,r5
80003cb4:	00 00       	add	r0,r0
80003cb6:	0d 98       	ld.ub	r8,r6[0x1]
80003cb8:	00 00       	add	r0,r0
80003cba:	0a 80       	andn	r0,r5
80003cbc:	00 00       	add	r0,r0
80003cbe:	0e a0       	st.w	r7++,r0
80003cc0:	00 00       	add	r0,r0
80003cc2:	0a 4e       	or	lr,r5
80003cc4:	80 00       	ld.sh	r0,r0[0x0]
80003cc6:	cb 9c       	rcall	80003e38 <ssc_init+0x38>

80003cc8 <pdca_int_handler>:
    void (*phy_rx_exec)(void *)--callback function for receive SSC data 
Called By: interrupt
*/
__attribute__((__interrupt__))
static void pdca_int_handler(void)
{
80003cc8:	d4 01       	pushm	lr
    
	//intStartCount = Get_system_register(AVR32_COUNT);
	
	/*Toggle Index*/
    BufferIndex ^= 0x01;
80003cca:	49 88       	lddpc	r8,80003d28 <pdca_int_handler+0x60>
80003ccc:	11 89       	ld.ub	r9,r8[0x0]
80003cce:	ec 19 00 01 	eorl	r9,0x1
80003cd2:	b0 89       	st.b	r8[0x0],r9
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);
80003cd4:	11 89       	ld.ub	r9,r8[0x0]
80003cd6:	a5 69       	lsl	r9,0x4
80003cd8:	2f c9       	sub	r9,-4
80003cda:	49 5a       	lddpc	r10,80003d2c <pdca_int_handler+0x64>
80003cdc:	14 09       	add	r9,r10
	
	/*Toggle Index*/
    BufferIndex ^= 0x01;
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
80003cde:	fe 7a 00 40 	mov	r10,-65472
80003ce2:	95 39       	st.w	r10[0xc],r9
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80003ce4:	30 39       	mov	r9,3
80003ce6:	95 49       	st.w	r10[0x10],r9

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);
80003ce8:	11 8a       	ld.ub	r10,r8[0x0]
80003cea:	a5 6a       	lsl	r10,0x4
80003cec:	2f ca       	sub	r10,-4
80003cee:	49 18       	lddpc	r8,80003d30 <pdca_int_handler+0x68>
80003cf0:	10 0a       	add	r10,r8
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
80003cf2:	fe 78 00 00 	mov	r8,-65536
80003cf6:	91 3a       	st.w	r8[0xc],r10
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80003cf8:	91 49       	st.w	r8[0x10],r9
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr;
80003cfa:	70 b8       	ld.w	r8,r8[0x2c]
	
	/*receive SSC data*/
    if(phy_rx_exec != NULL)phy_rx_exec((void *)&RxBuffer[BufferIndex]);
80003cfc:	48 e8       	lddpc	r8,80003d34 <pdca_int_handler+0x6c>
80003cfe:	70 08       	ld.w	r8,r8[0x0]
80003d00:	58 08       	cp.w	r8,0
80003d02:	c0 70       	breq	80003d10 <pdca_int_handler+0x48>
80003d04:	48 99       	lddpc	r9,80003d28 <pdca_int_handler+0x60>
80003d06:	13 89       	ld.ub	r9,r9[0x0]
80003d08:	a5 69       	lsl	r9,0x4
80003d0a:	48 ac       	lddpc	r12,80003d30 <pdca_int_handler+0x68>
80003d0c:	12 0c       	add	r12,r9
80003d0e:	5d 18       	icall	r8

    /*transmit SSC data*/

	if(phy_tx_exec != NULL)phy_tx_exec((void *)&TxBuffer[BufferIndex]);//phy_tx_func, phy_rx_func
80003d10:	48 a8       	lddpc	r8,80003d38 <pdca_int_handler+0x70>
80003d12:	70 08       	ld.w	r8,r8[0x0]
80003d14:	58 08       	cp.w	r8,0
80003d16:	c0 70       	breq	80003d24 <pdca_int_handler+0x5c>
80003d18:	48 49       	lddpc	r9,80003d28 <pdca_int_handler+0x60>
80003d1a:	13 89       	ld.ub	r9,r9[0x0]
80003d1c:	a5 69       	lsl	r9,0x4
80003d1e:	48 4c       	lddpc	r12,80003d2c <pdca_int_handler+0x64>
80003d20:	12 0c       	add	r12,r9
80003d22:	5d 18       	icall	r8

	
	//intDuration = Get_system_register(AVR32_COUNT) - intStartCount;
	
	
}/*End of pdca_int_handler.*/
80003d24:	d4 02       	popm	lr
80003d26:	d6 03       	rete
80003d28:	00 00       	add	r0,r0
80003d2a:	40 c0       	lddsp	r0,sp[0x30]
80003d2c:	00 00       	add	r0,r0
80003d2e:	40 e8       	lddsp	r8,sp[0x38]
80003d30:	00 00       	add	r0,r0
80003d32:	40 c8       	lddsp	r8,sp[0x30]
80003d34:	00 00       	add	r0,r0
80003d36:	0a d4       	st.w	--r5,r4
80003d38:	00 00       	add	r0,r0
80003d3a:	0a d8       	st.w	--r5,r8

80003d3c <local_start_SSC>:
void local_start_SSC(void)
{
    /*Assign GPIO to SSC.
    gpio_enable_module
    gpio_enable_module_pin*/
    AVR32_GPIO.port[1].pmr0c = 0x00000DC0;
80003d3c:	fe 78 10 00 	mov	r8,-61440
80003d40:	e0 69 0d c0 	mov	r9,3520
80003d44:	f1 49 01 18 	st.w	r8[280],r9
    AVR32_GPIO.port[1].pmr1c = 0x00000DC0;
80003d48:	f1 49 01 28 	st.w	r8[296],r9
    AVR32_GPIO.port[1].gperc = 0x00000DC0;
80003d4c:	f1 49 01 08 	st.w	r8[264],r9

    /*Software reset SSC*/
    (&AVR32_SSC)->cr = AVR32_SSC_CR_SWRST_MASK;
80003d50:	fe 78 34 00 	mov	r8,-52224
80003d54:	e0 69 80 00 	mov	r9,32768
80003d58:	91 09       	st.w	r8[0x0],r9
    (&AVR32_SSC)->cmr 
80003d5a:	30 09       	mov	r9,0
80003d5c:	91 19       	st.w	r8[0x4],r9
                     = AVR32_SSC_CMR_DIV_NOT_ACTIVE << AVR32_SSC_CMR_DIV_OFFSET;

    /*For Slave*/
    (&AVR32_SSC)->tcmr =
80003d5e:	e0 69 04 21 	mov	r9,1057
80003d62:	ea 19 3f 20 	orh	r9,0x3f20
80003d66:	91 69       	st.w	r8[0x18],r9
	    | 32 << AVR32_SSC_TCMR_STTDLY_OFFSET
	    | 63 << AVR32_SSC_TCMR_PERIOD_OFFSET;


    /*For Slave*/
    (&AVR32_SSC)->tfmr = 31 << AVR32_SSC_TFMR_DATLEN_OFFSET 
80003d68:	e0 69 02 9f 	mov	r9,671
80003d6c:	ea 19 01 00 	orh	r9,0x100
80003d70:	91 79       	st.w	r8[0x1c],r9
	    | 0 << AVR32_SSC_TFMR_FSDEN_OFFSET
	    | 1 << AVR32_SSC_TFMR_FSEDGE_OFFSET;

	/*For Slave*/

	(&AVR32_SSC)->rcmr = AVR32_SSC_RCMR_CKS_RK_PIN << AVR32_SSC_RCMR_CKS_OFFSET
80003d72:	e0 6a 04 02 	mov	r10,1026
80003d76:	ea 1a 3f 20 	orh	r10,0x3f20
80003d7a:	91 4a       	st.w	r8[0x10],r10
	    | 0 << AVR32_SSC_RCMR_STOP_OFFSET
	    | 32 << AVR32_SSC_RCMR_STTDLY_OFFSET
	    | 63 << AVR32_SSC_RCMR_PERIOD_OFFSET;

	/*For Slave*/
	(&AVR32_SSC)->rfmr = 31 << AVR32_SSC_RFMR_DATLEN_OFFSET
80003d7c:	91 59       	st.w	r8[0x14],r9
	    | 1 << AVR32_SSC_RFMR_MSBF_OFFSET
	    | 2 << AVR32_SSC_RFMR_DATNB_OFFSET
	    | 0 << AVR32_SSC_RFMR_FSLEN_OFFSET
	    | AVR32_SSC_RFMR_FSOS_INPUT_ONLY << AVR32_SSC_RFMR_FSOS_OFFSET
	    | 1 << AVR32_SSC_RFMR_FSEDGE_OFFSET;
}/*End of local_start_SSC.*/
80003d7e:	5e fc       	retal	r12

80003d80 <local_start_PDC>:
Function: local_start_PDC
Description: none
Called By: void ssc_init(void) -- ssc.c
*/
void local_start_PDC(void)
{
80003d80:	d4 01       	pushm	lr
    /*Toggle Index*/	
    BufferIndex = 1;
80003d82:	30 19       	mov	r9,1
80003d84:	49 78       	lddpc	r8,80003de0 <local_start_PDC+0x60>
80003d86:	b0 89       	st.b	r8[0x0],r9
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
80003d88:	fe 78 00 00 	mov	r8,-65536
80003d8c:	30 7b       	mov	r11,7
80003d8e:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
80003d90:	70 b9       	ld.w	r9,r8[0x2c]
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
80003d92:	49 59       	lddpc	r9,80003de4 <local_start_PDC+0x64>
80003d94:	f2 ca ff fc 	sub	r10,r9,-4
    BufferIndex = 1;
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
80003d98:	91 0a       	st.w	r8[0x0],r10
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
80003d9a:	30 3a       	mov	r10,3
80003d9c:	91 2a       	st.w	r8[0x8],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
80003d9e:	30 1c       	mov	r12,1
80003da0:	91 1c       	st.w	r8[0x4],r12
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
80003da2:	2e c9       	sub	r9,-20
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
80003da4:	91 39       	st.w	r8[0xc],r9
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80003da6:	91 4a       	st.w	r8[0x10],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80003da8:	30 2c       	mov	r12,2
80003daa:	91 6c       	st.w	r8[0x18],r12

	TxBuffer[0].xnl_channel.dword = XNL_IDLE;
80003dac:	48 f9       	lddpc	r9,80003de8 <local_start_PDC+0x68>
80003dae:	e0 68 5a 5a 	mov	r8,23130
80003db2:	ea 18 ab cd 	orh	r8,0xabcd
80003db6:	93 18       	st.w	r9[0x4],r8
	TxBuffer[0].payload_channel.dword[0] = PAYLOADIDLE0;
80003db8:	93 28       	st.w	r9[0x8],r8
	TxBuffer[0].payload_channel.dword[1] = PAYLOADIDLE1;
80003dba:	30 0e       	mov	lr,0
80003dbc:	93 3e       	st.w	r9[0xc],lr
	TxBuffer[1].xnl_channel.dword = XNL_IDLE;
80003dbe:	93 58       	st.w	r9[0x14],r8
	TxBuffer[1].payload_channel.dword[0] = PAYLOADIDLE0;
80003dc0:	93 68       	st.w	r9[0x18],r8
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;
80003dc2:	93 7e       	st.w	r9[0x1c],lr

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
80003dc4:	fe 78 00 40 	mov	r8,-65472
80003dc8:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
80003dca:	70 be       	ld.w	lr,r8[0x2c]
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
80003dcc:	f2 ce ff fc 	sub	lr,r9,-4
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
80003dd0:	91 0e       	st.w	r8[0x0],lr
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
80003dd2:	91 2a       	st.w	r8[0x8],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
80003dd4:	91 1b       	st.w	r8[0x4],r11
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
80003dd6:	2e c9       	sub	r9,-20
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
80003dd8:	91 39       	st.w	r8[0xc],r9
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80003dda:	91 4a       	st.w	r8[0x10],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80003ddc:	91 6c       	st.w	r8[0x18],r12
}/*End of local_start_PDC.*/
80003dde:	d8 02       	popm	pc
80003de0:	00 00       	add	r0,r0
80003de2:	40 c0       	lddsp	r0,sp[0x30]
80003de4:	00 00       	add	r0,r0
80003de6:	40 c8       	lddsp	r8,sp[0x30]
80003de8:	00 00       	add	r0,r0
80003dea:	40 e8       	lddsp	r8,sp[0x38]

80003dec <register_rx_tx_func>:
Description: register the rx function(callback function)
Called By: phy_init -- physical.c
*/
void register_rx_tx_func(void (*rx_exec)(void *),  void ( *tx_exec)(void *))
{
	 phy_rx_exec = rx_exec;
80003dec:	48 38       	lddpc	r8,80003df8 <register_rx_tx_func+0xc>
80003dee:	91 0c       	st.w	r8[0x0],r12
	 phy_tx_exec = tx_exec;//phy_tx_func, phy_rx_func
80003df0:	48 38       	lddpc	r8,80003dfc <register_rx_tx_func+0x10>
80003df2:	91 0b       	st.w	r8[0x0],r11
	 
}/*End of register_tx_rx_func.*/
80003df4:	5e fc       	retal	r12
80003df6:	00 00       	add	r0,r0
80003df8:	00 00       	add	r0,r0
80003dfa:	0a d4       	st.w	--r5,r4
80003dfc:	00 00       	add	r0,r0
80003dfe:	0a d8       	st.w	--r5,r8

80003e00 <ssc_init>:
    local_start_SSC -- ssc.c
    local_start_PDC -- ssc.c
Called By: phy_init -- physical.c
*/
void ssc_init(void)
{		
80003e00:	d4 01       	pushm	lr
    /*Set up PB03 to watch FS.*/
    AVR32_GPIO.port[1].oderc = 0x00000002;
80003e02:	fe 78 10 00 	mov	r8,-61440
80003e06:	30 29       	mov	r9,2
80003e08:	f1 49 01 48 	st.w	r8[328],r9
    AVR32_GPIO.port[1].gpers = 0x00000002;
80003e0c:	f1 49 01 04 	st.w	r8[260],r9

    /*Waits for radio to start making FSYNC.*/
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
80003e10:	10 99       	mov	r9,r8
80003e12:	f2 f8 01 60 	ld.w	r8,r9[352]
80003e16:	e2 18 00 02 	andl	r8,0x2,COH
80003e1a:	cf c0       	breq	80003e12 <ssc_init+0x12>
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
80003e1c:	fe 79 10 00 	mov	r9,-61440
80003e20:	f2 f8 01 60 	ld.w	r8,r9[352]
80003e24:	e2 18 00 02 	andl	r8,0x2,COH
80003e28:	cf c1       	brne	80003e20 <ssc_init+0x20>
				
    INTC_register_interrupt (
80003e2a:	30 3a       	mov	r10,3
80003e2c:	36 0b       	mov	r11,96
80003e2e:	48 bc       	lddpc	r12,80003e58 <ssc_init+0x58>
80003e30:	f0 1f 00 0b 	mcall	80003e5c <ssc_init+0x5c>
        , AVR32_PDCA_IRQ_0
        , AVR32_INTC_INT3
    );
				
    /*config the SSC*/
    local_start_SSC();
80003e34:	f0 1f 00 0b 	mcall	80003e60 <ssc_init+0x60>

    /*config the PDCA*/
    local_start_PDC();
80003e38:	f0 1f 00 0b 	mcall	80003e64 <ssc_init+0x64>
		
    /*Start the SSC Physical Layer.*/

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80003e3c:	fe 79 00 00 	mov	r9,-65536
80003e40:	30 18       	mov	r8,1
80003e42:	93 58       	st.w	r9[0x14],r8
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80003e44:	fe 7a 00 40 	mov	r10,-65472
80003e48:	95 58       	st.w	r10[0x14],r8
    (&AVR32_SSC)->cr = AVR32_SSC_CR_RXEN_MASK | AVR32_SSC_CR_TXEN_MASK;
80003e4a:	e0 6b 01 01 	mov	r11,257
80003e4e:	fe 7a 34 00 	mov	r10,-52224
80003e52:	95 0b       	st.w	r10[0x0],r11
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->ier = 
80003e54:	93 88       	st.w	r9[0x20],r8
                                                            AVR32_PDCA_RCZ_MASK;
}/*End of ssc_init.*/
80003e56:	d8 02       	popm	pc
80003e58:	80 00       	ld.sh	r0,r0[0x0]
80003e5a:	3c c8       	mov	r8,-52
80003e5c:	80 00       	ld.sh	r0,r0[0x0]
80003e5e:	49 40       	lddpc	r0,80003eac <xcmp_tx+0x38>
80003e60:	80 00       	ld.sh	r0,r0[0x0]
80003e62:	3d 3c       	mov	r12,-45
80003e64:	80 00       	ld.sh	r0,r0[0x0]
80003e66:	3d 80       	mov	r0,-40

80003e68 <xcmp_register_app_list>:
Calls: 
Called By: app_init -- app.c
*/
void xcmp_register_app_list(void * list)
{
	app_list = (app_exec_t *)list;
80003e68:	48 28       	lddpc	r8,80003e70 <xcmp_register_app_list+0x8>
80003e6a:	91 0c       	st.w	r8[0x0],r12
}
80003e6c:	5e fc       	retal	r12
80003e6e:	00 00       	add	r0,r0
80003e70:	00 00       	add	r0,r0
80003e72:	41 08       	lddsp	r8,sp[0x40]

80003e74 <xcmp_tx>:
Calls:   
	xnl_tx -- xnl.c
Called By: ...
*/
static void xcmp_tx( xcmp_fragment_t * xcmp, U8 payload_len)
{
80003e74:	eb cd 40 80 	pushm	r7,lr
80003e78:	fa cd 01 00 	sub	sp,sp,256
80003e7c:	16 97       	mov	r7,r11
	Length :xnl length + checksum
	= checksum + xnl header + xcmp opcode + xcmp payload
	= 0x02 + 0x0C + 0x02 + xcmp payload
	= 0x10 + xcmp payload
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | ( 0x10 + payload_len);
80003e7e:	16 98       	mov	r8,r11
80003e80:	2f 08       	sub	r8,-16
80003e82:	af a8       	sbr	r8,0xe
80003e84:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE; 
80003e86:	3f f8       	mov	r8,-1
80003e88:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG;
80003e8a:	30 b9       	mov	r9,11
80003e8c:	ba 29       	st.h	sp[0x4],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;	
80003e8e:	ba 38       	st.h	sp[0x6],r8
	xnl_frame.xnl_header.destination = DEFAULT_VALUE;
80003e90:	ba 48       	st.h	sp[0x8],r8
	xnl_frame.xnl_header.source = DEFAULT_VALUE;	
80003e92:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80003e94:	ba 68       	st.h	sp[0xc],r8
	
	/*insert xcmp frame data*/
	memcpy(&xnl_frame.xnl_payload.xnl_content_data_msg, xcmp, payload_len + 2);
80003e96:	f6 ca ff fe 	sub	r10,r11,-2
80003e9a:	18 9b       	mov	r11,r12
80003e9c:	fa cc ff f0 	sub	r12,sp,-16
80003ea0:	f0 1f 00 05 	mcall	80003eb4 <xcmp_tx+0x40>
	xnl_frame.xnl_header.payload_length = payload_len + 2;	
80003ea4:	2f e7       	sub	r7,-2
80003ea6:	ba 77       	st.h	sp[0xe],r7
	
	/* send xnl frame*/	
	xnl_tx(&xnl_frame);
80003ea8:	1a 9c       	mov	r12,sp
80003eaa:	f0 1f 00 04 	mcall	80003eb8 <xcmp_tx+0x44>
}
80003eae:	2c 0d       	sub	sp,-256
80003eb0:	e3 cd 80 80 	ldm	sp++,r7,pc
80003eb4:	80 00       	ld.sh	r0,r0[0x0]
80003eb6:	6b d4       	ld.w	r4,r5[0x74]
80003eb8:	80 00       	ld.sh	r0,r0[0x0]
80003eba:	43 a4       	lddsp	r4,sp[0xe8]

80003ebc <xcmp_exit_device_control_mode>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_exit_device_control_mode(void)
{
80003ebc:	d4 01       	pushm	lr
80003ebe:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DEVICE_CONTROL_MODE;
80003ec2:	e0 68 04 21 	mov	r8,1057
80003ec6:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceControlMode_req_t * ptr = (DeviceControlMode_req_t *)xcmp_farme.u8;
80003ec8:	fa c8 ff fc 	sub	r8,sp,-4
	
	ptr->Function = DCM_EXIT;
80003ecc:	30 09       	mov	r9,0
80003ece:	b0 89       	st.b	r8[0x0],r9
	ptr->ControlTypeSize = 1;
80003ed0:	30 19       	mov	r9,1
80003ed2:	b0 99       	st.b	r8[0x1],r9
	ptr->ControlType = 0x03;//DCM_SPEAKER_CTRL;
80003ed4:	30 39       	mov	r9,3
80003ed6:	b0 a9       	st.b	r8[0x2],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(DeviceControlMode_req_t));
80003ed8:	30 3b       	mov	r11,3
80003eda:	fa cc ff fe 	sub	r12,sp,-2
80003ede:	f0 1f 00 03 	mcall	80003ee8 <xcmp_exit_device_control_mode+0x2c>
}
80003ee2:	2c dd       	sub	sp,-204
80003ee4:	d8 02       	popm	pc
80003ee6:	00 00       	add	r0,r0
80003ee8:	80 00       	ld.sh	r0,r0[0x0]
80003eea:	3e 74       	mov	r4,-25

80003eec <xcmp_enter_device_control_mode>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_enter_device_control_mode(void)
{
80003eec:	d4 01       	pushm	lr
80003eee:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DEVICE_CONTROL_MODE;
80003ef2:	e0 68 04 21 	mov	r8,1057
80003ef6:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceControlMode_req_t * ptr = (DeviceControlMode_req_t *)xcmp_farme.u8;
80003ef8:	fa c8 ff fc 	sub	r8,sp,-4
	
	ptr->Function = DCM_ENTER;
80003efc:	30 19       	mov	r9,1
80003efe:	b0 89       	st.b	r8[0x0],r9
	ptr->ControlTypeSize = 1;
80003f00:	b0 99       	st.b	r8[0x1],r9
	ptr->ControlType = 0x03;// 0xEB;//user-input
80003f02:	30 39       	mov	r9,3
80003f04:	b0 a9       	st.b	r8[0x2],r9
	//ptr->ControlType = DCM_SPEAKER_CTRL;
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(DeviceControlMode_req_t));
80003f06:	30 3b       	mov	r11,3
80003f08:	fa cc ff fe 	sub	r12,sp,-2
80003f0c:	f0 1f 00 02 	mcall	80003f14 <xcmp_enter_device_control_mode+0x28>
}
80003f10:	2c dd       	sub	sp,-204
80003f12:	d8 02       	popm	pc
80003f14:	80 00       	ld.sh	r0,r0[0x0]
80003f16:	3e 74       	mov	r4,-25

80003f18 <xcmp_audio_route_AMBE>:
	xcmp_tx( &xcmp_farme, sizeof(AudioRoutingControl_req_t) - (MAX_ROUTING_CTR - NumberofRoutings) * sizeof(RoutingData_t));
}


void xcmp_audio_route_AMBE(void)
{
80003f18:	d4 01       	pushm	lr
80003f1a:	fa cd 00 cc 	sub	sp,sp,204

	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | AUDIO_ROUTING_CONTROL;
80003f1e:	e0 68 04 14 	mov	r8,1044
80003f22:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	AudioRoutingControl_req_t * ptr = (AudioRoutingControl_req_t *)xcmp_farme.u8;
80003f24:	fa c8 ff fc 	sub	r8,sp,-4
	
	ptr->Function = Routing_Func_Update_Source;
80003f28:	30 19       	mov	r9,1
80003f2a:	b0 89       	st.b	r8[0x0],r9
	
	
	unsigned short NumberofRoutings = 6;// 4;//2;
	ptr->NumberofRoutings[0] = (NumberofRoutings >> 8) & 0xFF;
80003f2c:	30 09       	mov	r9,0
80003f2e:	b0 99       	st.b	r8[0x1],r9
	ptr->NumberofRoutings[1] =  NumberofRoutings & 0xFF;
80003f30:	30 69       	mov	r9,6
80003f32:	b0 a9       	st.b	r8[0x2],r9
	
	//ptr->RoutingData[0].audioInput = IN_Microphone;//Post_AMBE_Encoder;//IN_Pre_Speaker_Audio_Data;//IN_Microphone;//IN_Option_Board;
	//ptr->RoutingData[0].audioOutput = OUT_Option_Board;//Post_AMBE_Encoder;//OUT_Microphone_Data;//测试
	//注意：经测试发现，这里的路径配置，需要特别注意先后顺序，否则会提示参数错误。
	ptr->RoutingData[0].audioInput = Post_AMBE_Encoder;//IN_Option_Board;
80003f34:	30 fa       	mov	r10,15
80003f36:	b0 ba       	st.b	r8[0x3],r10
	ptr->RoutingData[0].audioOutput = OUT_Option_Board;// OUT_Speaker;
80003f38:	30 c9       	mov	r9,12
80003f3a:	b0 c9       	st.b	r8[0x4],r9
	ptr->RoutingData[1].audioInput = IN_Option_Board;//IN_Option_Board;
80003f3c:	b0 d9       	st.b	r8[0x5],r9
	ptr->RoutingData[1].audioOutput = Post_AMBE_Encoder;// OUT_Speaker;
80003f3e:	b0 ea       	st.b	r8[0x6],r10
	
	ptr->RoutingData[2].audioInput = Pre_AMBE_Decoder;//IN_Option_Board;
80003f40:	31 0a       	mov	r10,16
80003f42:	b0 fa       	st.b	r8[0x7],r10
	ptr->RoutingData[2].audioOutput = OUT_Option_Board;// OUT_Speaker;
80003f44:	f1 69 00 08 	st.b	r8[8],r9
	ptr->RoutingData[3].audioInput = IN_Option_Board;//IN_Option_Board;
80003f48:	f1 69 00 09 	st.b	r8[9],r9
	ptr->RoutingData[3].audioOutput = Pre_AMBE_Decoder;// OUT_Speaker;
80003f4c:	f1 6a 00 0a 	st.b	r8[10],r10
	
	ptr->RoutingData[4].audioInput = Tx_Voice_Header;//IN_Option_Board;
80003f50:	31 1a       	mov	r10,17
80003f52:	f1 6a 00 0b 	st.b	r8[11],r10
	ptr->RoutingData[4].audioOutput = OUT_Option_Board;// OUT_Speaker;
80003f56:	f1 69 00 0c 	st.b	r8[12],r9
	//ptr->RoutingData[3].audioInput = IN_Option_Board;//IN_Option_Board;
	//ptr->RoutingData[3].audioOutput = Tx_Voice_Header;// OUT_Speaker;
	
	ptr->RoutingData[5].audioInput = Tx_Voice_Terminator;//IN_Option_Board;
80003f5a:	31 3a       	mov	r10,19
80003f5c:	f1 6a 00 0d 	st.b	r8[13],r10
	ptr->RoutingData[5].audioOutput = OUT_Option_Board;// OUT_Speaker;
80003f60:	f1 69 00 0e 	st.b	r8[14],r9
	
	//ptr->RoutingData[1].audioInput = IN_Option_Board;
	//ptr->RoutingData[1].audioOutput = OUT_Microphone_Data;//测试OUT_Speaker;//
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(AudioRoutingControl_req_t) - (MAX_ROUTING_CTR - NumberofRoutings) * sizeof(RoutingData_t));
80003f64:	30 fb       	mov	r11,15
80003f66:	fa cc ff fe 	sub	r12,sp,-2
80003f6a:	f0 1f 00 03 	mcall	80003f74 <xcmp_audio_route_AMBE+0x5c>

	
}
80003f6e:	2c dd       	sub	sp,-204
80003f70:	d8 02       	popm	pc
80003f72:	00 00       	add	r0,r0
80003f74:	80 00       	ld.sh	r0,r0[0x0]
80003f76:	3e 74       	mov	r4,-25

80003f78 <xcmp_enter_enhanced_OB_mode>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_enter_enhanced_OB_mode(void)
{
80003f78:	d4 01       	pushm	lr
80003f7a:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | EN_OB_CONTROL;
80003f7e:	e0 68 04 65 	mov	r8,1125
80003f82:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	En_OB_Control_req_t * ptr = (En_OB_Control_req_t *)xcmp_farme.u8;
	
	ptr->Function = EN_OB_Enter;
80003f84:	fa cc ff fe 	sub	r12,sp,-2
80003f88:	30 18       	mov	r8,1
80003f8a:	b8 a8       	st.b	r12[0x2],r8
		
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(En_OB_Control_req_t));
80003f8c:	30 1b       	mov	r11,1
80003f8e:	f0 1f 00 03 	mcall	80003f98 <xcmp_enter_enhanced_OB_mode+0x20>
}
80003f92:	2c dd       	sub	sp,-204
80003f94:	d8 02       	popm	pc
80003f96:	00 00       	add	r0,r0
80003f98:	80 00       	ld.sh	r0,r0[0x0]
80003f9a:	3e 74       	mov	r4,-25

80003f9c <xcmp_DeviceInitializationStatus_request>:
Description: send device initialization status request
Calls: xcmp_tx
Called By:...
*/
void xcmp_DeviceInitializationStatus_request(void)
{
80003f9c:	d4 01       	pushm	lr
80003f9e:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
		
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_BRDCAST | DEVICE_INITIALIZATION_STATUS;
80003fa2:	fe 78 b4 00 	mov	r8,-19456
80003fa6:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceInitializationStatus_brdcst_t * ptr 
						 = (DeviceInitializationStatus_brdcst_t *)xcmp_farme.u8;
80003fa8:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*xcmp version 8.1.0.5*///版本号未正确填写，纠正
	ptr->XCMPVersion[0] = 0x08;
80003fac:	30 89       	mov	r9,8
80003fae:	b0 89       	st.b	r8[0x0],r9
	ptr->XCMPVersion[1] = 0x01;
80003fb0:	30 19       	mov	r9,1
80003fb2:	b0 99       	st.b	r8[0x1],r9
	ptr->XCMPVersion[2] = 0x00;
80003fb4:	30 09       	mov	r9,0
80003fb6:	b0 a9       	st.b	r8[0x2],r9
	ptr->XCMPVersion[3] = 0x05;
80003fb8:	30 5a       	mov	r10,5
80003fba:	b0 ba       	st.b	r8[0x3],r10
	/*
	0x00:
	This is the message that the device sends at power up or after a reset. It 
	will give the initial status and capabilities for the device.
	*/
	ptr->DeviceInitType = 0x00;
80003fbc:	b0 c9       	st.b	r8[0x4],r9
	types of devices may provide a set of services to the radio system, but do 
	not have the ability to be the master.
	
	0x07:OptionBoard,3rd party Option Board-based application.
	*/
	ptr->DeviceStatusInfo.DeviceType = 0x07;
80003fbe:	30 7a       	mov	r10,7
80003fc0:	b0 da       	st.b	r8[0x5],r10
	
	/*Power Up Success, Device has powered up with no errors*/
	ptr->DeviceStatusInfo.DeviceStatus[0] = 0x00;
80003fc2:	b0 e9       	st.b	r8[0x6],r9
	ptr->DeviceStatusInfo.DeviceStatus[1] = 0x00;
80003fc4:	b0 f9       	st.b	r8[0x7],r9
	
	/*
	This number is the size of the Device Descriptor data structure with a 
	maximum size not exceeding 255 bytes.
	*/
	ptr->DeviceStatusInfo.DeviceDescriptorSize = 0x00;
80003fc6:	f1 69 00 08 	st.b	r8[8],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme
80003fca:	30 9b       	mov	r11,9
80003fcc:	fa cc ff fe 	sub	r12,sp,-2
80003fd0:	f0 1f 00 02 	mcall	80003fd8 <xcmp_DeviceInitializationStatus_request+0x3c>
		, sizeof(DeviceInitializationStatus_brdcst_t) - MAX_DEVICE_DESC_SIZE);
}
80003fd4:	2c dd       	sub	sp,-204
80003fd6:	d8 02       	popm	pc
80003fd8:	80 00       	ld.sh	r0,r0[0x0]
80003fda:	3e 74       	mov	r4,-25

80003fdc <xcmp_opcode_not_supported>:
Description: register the app list
Calls: xcmp_tx
Called By:...
*/
void xcmp_opcode_not_supported( void )
{
80003fdc:	d4 01       	pushm	lr
80003fde:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REPLY;
80003fe2:	fe 78 80 00 	mov	r8,-32768
80003fe6:	ba 18       	st.h	sp[0x2],r8
	
	/*The radio does not support this opcode.*/
	xcmp_farme.u8[0] = xcmp_Res_Opcode_Not_Supported;
80003fe8:	30 38       	mov	r8,3
80003fea:	ba c8       	st.b	sp[0x4],r8
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, 1);
80003fec:	30 1b       	mov	r11,1
80003fee:	fa cc ff fe 	sub	r12,sp,-2
80003ff2:	f0 1f 00 03 	mcall	80003ffc <xcmp_opcode_not_supported+0x20>
}
80003ff6:	2c dd       	sub	sp,-204
80003ff8:	d8 02       	popm	pc
80003ffa:	00 00       	add	r0,r0
80003ffc:	80 00       	ld.sh	r0,r0[0x0]
80003ffe:	3e 74       	mov	r4,-25

80004000 <xcmp_exec_func>:
Description: Perform XCMP corresponding functions
Calls:   
Called By: xcmp_rx_process--task
*/
static void xcmp_exec_func(app_exec_t * exec, xcmp_fragment_t * xcmp)
{
80004000:	d4 01       	pushm	lr
	/*The message types*/
	switch(xcmp->xcmp_opcode & 0xF000)
80004002:	96 88       	ld.uh	r8,r11[0x0]
80004004:	e2 18 f0 00 	andl	r8,0xf000,COH
80004008:	e0 48 80 00 	cp.w	r8,32768
8000400c:	c0 f0       	breq	8000402a <xcmp_exec_func+0x2a>
8000400e:	e0 48 b0 00 	cp.w	r8,45056
80004012:	c1 20       	breq	80004036 <xcmp_exec_func+0x36>
80004014:	58 08       	cp.w	r8,0
80004016:	c1 51       	brne	80004040 <xcmp_exec_func+0x40>
	{
		case XCMP_REQUEST:
			if(NULL != exec->xcmp_rx_req)
80004018:	78 08       	ld.w	r8,r12[0x0]
8000401a:	58 08       	cp.w	r8,0
8000401c:	c0 40       	breq	80004024 <xcmp_exec_func+0x24>
			{
				exec->xcmp_rx_req(xcmp);
8000401e:	16 9c       	mov	r12,r11
80004020:	5d 18       	icall	r8
80004022:	d8 02       	popm	pc
			}
			else 
			{
				/*No function to register the request message*/
				/*send not supported opcode to raido */
				xcmp_opcode_not_supported();
80004024:	f0 1f 00 08 	mcall	80004044 <xcmp_exec_func+0x44>
80004028:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_REPLY:		
			if(NULL != exec->xcmp_rx_reply)
8000402a:	78 18       	ld.w	r8,r12[0x4]
8000402c:	58 08       	cp.w	r8,0
8000402e:	c0 90       	breq	80004040 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_reply(xcmp);
80004030:	16 9c       	mov	r12,r11
80004032:	5d 18       	icall	r8
80004034:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_BRDCAST:	
			if(NULL != exec->xcmp_rx_brdcst)
80004036:	78 28       	ld.w	r8,r12[0x8]
80004038:	58 08       	cp.w	r8,0
8000403a:	c0 30       	breq	80004040 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_brdcst(xcmp);
8000403c:	16 9c       	mov	r12,r11
8000403e:	5d 18       	icall	r8
80004040:	d8 02       	popm	pc
80004042:	00 00       	add	r0,r0
80004044:	80 00       	ld.sh	r0,r0[0x0]
80004046:	3f dc       	mov	r12,-3

80004048 <xcmp_IdleTestTone>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_IdleTestTone(void)
{
80004048:	d4 01       	pushm	lr
8000404a:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | TONE_CONTROL;
8000404e:	e0 68 04 09 	mov	r8,1033
80004052:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	ToneControl_req_t * ptr = (ToneControl_req_t *)xcmp_farme.u8;
80004054:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*Starts the specific tone*/	
	ptr->Function = Tone_Start;
80004058:	30 19       	mov	r9,1
8000405a:	b0 89       	st.b	r8[0x0],r9
	
	/*This tone shall be sounded when radio landed on a priority channel*/
	ptr->ToneIdentifier[0] = (Priority_Beep >> 8) & 0xFF;
8000405c:	30 09       	mov	r9,0
8000405e:	b0 99       	st.b	r8[0x1],r9
	ptr->ToneIdentifier[1] = Priority_Beep & 0xFF;
80004060:	30 ca       	mov	r10,12
80004062:	b0 aa       	st.b	r8[0x2],r10
	
	/*
	The alert tone is played according to any rules for alert tones, given the 
	current volume setting. Settings for this field are 8 to 255 (0x08 ?0xFF).
	*/
	ptr->ToneVolumeControl = Current_Volume;
80004064:	b0 b9       	st.b	r8[0x3],r9
	
	/*clear reserved*/
	memset(ptr->Reserved, 0, 8);
80004066:	fb 69 00 08 	st.b	sp[8],r9
8000406a:	fa c8 ff f7 	sub	r8,sp,-9
8000406e:	b0 89       	st.b	r8[0x0],r9
80004070:	fa c8 ff f6 	sub	r8,sp,-10
80004074:	b0 89       	st.b	r8[0x0],r9
80004076:	fa c8 ff f5 	sub	r8,sp,-11
8000407a:	b0 89       	st.b	r8[0x0],r9
8000407c:	fa c8 ff f4 	sub	r8,sp,-12
80004080:	b0 89       	st.b	r8[0x0],r9
80004082:	fa c8 ff f3 	sub	r8,sp,-13
80004086:	b0 89       	st.b	r8[0x0],r9
80004088:	fa c8 ff f2 	sub	r8,sp,-14
8000408c:	b0 89       	st.b	r8[0x0],r9
8000408e:	fa c8 ff f1 	sub	r8,sp,-15
80004092:	b0 89       	st.b	r8[0x0],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(ToneControl_req_t));
80004094:	30 cb       	mov	r11,12
80004096:	fa cc ff fe 	sub	r12,sp,-2
8000409a:	f0 1f 00 03 	mcall	800040a4 <xcmp_IdleTestTone+0x5c>
}
8000409e:	2c dd       	sub	sp,-204
800040a0:	d8 02       	popm	pc
800040a2:	00 00       	add	r0,r0
800040a4:	80 00       	ld.sh	r0,r0[0x0]
800040a6:	3e 74       	mov	r4,-25

800040a8 <xcmp_init>:
	xQueueCreate -- freertos
	xTaskCreate -- freertos
Called By: main -- main.c
*/
void xcmp_init(void)
{
800040a8:	d4 01       	pushm	lr
	/*initialize the xnl*/
	xnl_init();
800040aa:	f0 1f 00 0d 	mcall	800040dc <xcmp_init+0x34>
	
	/*register the xcmp function(callback function)*/
	xnl_register_xcmp_func( xcmp_rx );
800040ae:	48 dc       	lddpc	r12,800040e0 <xcmp_init+0x38>
800040b0:	f0 1f 00 0d 	mcall	800040e4 <xcmp_init+0x3c>
	
	/*initialize the queue*/
	//xcmp_frame_rx = xQueueCreate(10, sizeof(xcmp_fragment_t *));
	
	xcmp_frame_rx = xQueueCreate(20, sizeof(xcmp_fragment_t *));
800040b4:	30 4b       	mov	r11,4
800040b6:	31 4c       	mov	r12,20
800040b8:	f0 1f 00 0c 	mcall	800040e8 <xcmp_init+0x40>
800040bc:	48 c8       	lddpc	r8,800040ec <xcmp_init+0x44>
800040be:	91 0c       	st.w	r8[0x0],r12
	/*create task*/	
	/*this task is used to execute xcmp message*/
	xTaskCreate(
800040c0:	30 09       	mov	r9,0
800040c2:	1a d9       	st.w	--sp,r9
800040c4:	1a d9       	st.w	--sp,r9
800040c6:	1a d9       	st.w	--sp,r9
800040c8:	30 38       	mov	r8,3
800040ca:	e0 6a 01 80 	mov	r10,384
800040ce:	48 9b       	lddpc	r11,800040f0 <xcmp_init+0x48>
800040d0:	48 9c       	lddpc	r12,800040f4 <xcmp_init+0x4c>
800040d2:	f0 1f 00 0a 	mcall	800040f8 <xcmp_init+0x50>
800040d6:	2f dd       	sub	sp,-12
	,  384
	,  NULL
	,  tskXCMP_PRIORITY
	,  NULL
	);
}
800040d8:	d8 02       	popm	pc
800040da:	00 00       	add	r0,r0
800040dc:	80 00       	ld.sh	r0,r0[0x0]
800040de:	44 88       	lddsp	r8,sp[0x120]
800040e0:	80 00       	ld.sh	r0,r0[0x0]
800040e2:	41 f8       	lddsp	r8,sp[0x7c]
800040e4:	80 00       	ld.sh	r0,r0[0x0]
800040e6:	42 44       	lddsp	r4,sp[0x90]
800040e8:	80 00       	ld.sh	r0,r0[0x0]
800040ea:	57 dc       	stdsp	sp[0x1f4],r12
800040ec:	00 00       	add	r0,r0
800040ee:	0a e8       	st.h	--r5,r8
800040f0:	80 00       	ld.sh	r0,r0[0x0]
800040f2:	cb c8       	rjmp	8000426a <xnl_get_msg_ack_func+0x1a>
800040f4:	80 00       	ld.sh	r0,r0[0x0]
800040f6:	40 fc       	lddsp	r12,sp[0x3c]
800040f8:	80 00       	ld.sh	r0,r0[0x0]
800040fa:	5e b0       	rethi	r0

800040fc <xcmp_rx_process>:
Calls: xQueueReceive -- freerots
	xcmp_exec_func
Called By: task
*/
static void xcmp_rx_process(void * pvParameters)
{
800040fc:	d4 31       	pushm	r0-r7,lr
800040fe:	20 1d       	sub	sp,4
	xcmp_fragment_t xcmp;
	xcmp_fragment_t * ptr;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
80004100:	4b 16       	lddpc	r6,800041c4 <xcmp_rx_process+0xc8>
80004102:	30 05       	mov	r5,0
80004104:	31 44       	mov	r4,20
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
80004106:	4b 13       	lddpc	r3,800041c8 <xcmp_rx_process+0xcc>
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
					break;
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
80004108:	4b 12       	lddpc	r2,800041cc <xcmp_rx_process+0xd0>
						, ptr);
					break;
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
8000410a:	4b 21       	lddpc	r1,800041d0 <xcmp_rx_process+0xd4>
					break;
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
8000410c:	4b 20       	lddpc	r0,800041d4 <xcmp_rx_process+0xd8>
	xcmp_fragment_t xcmp;
	xcmp_fragment_t * ptr;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
8000410e:	6c 0c       	ld.w	r12,r6[0x0]
80004110:	0a 99       	mov	r9,r5
80004112:	08 9a       	mov	r10,r4
80004114:	1a 9b       	mov	r11,sp
80004116:	f0 1f 00 31 	mcall	800041d8 <xcmp_rx_process+0xdc>
8000411a:	58 1c       	cp.w	r12,1
8000411c:	cf 91       	brne	8000410e <xcmp_rx_process+0x12>
		{									
			if(NULL == ptr)
8000411e:	40 0b       	lddsp	r11,sp[0x0]
80004120:	58 0b       	cp.w	r11,0
80004122:	cf 60       	breq	8000410e <xcmp_rx_process+0x12>
				continue;
			}
			
			//log("\n\r R_xcmp : %4x \n\r",ptr->xcmp_opcode);//log:R_xcmp指令	
						
			switch(ptr->xcmp_opcode & 0x0FFF)
80004124:	96 0a       	ld.sh	r10,r11[0x0]
80004126:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
8000412a:	f1 d9 c0 0c 	bfextu	r8,r9,0x0,0xc
8000412e:	59 c8       	cp.w	r8,28
80004130:	c1 e0       	breq	8000416c <xcmp_rx_process+0x70>
80004132:	e0 89 00 07 	brgt	80004140 <xcmp_rx_process+0x44>
80004136:	58 e8       	cp.w	r8,14
80004138:	c0 e0       	breq	80004154 <xcmp_rx_process+0x58>
8000413a:	58 f8       	cp.w	r8,15
8000413c:	c2 41       	brne	80004184 <xcmp_rx_process+0x88>
8000413e:	c0 f8       	rjmp	8000415c <xcmp_rx_process+0x60>
80004140:	e0 48 01 09 	cp.w	r8,265
80004144:	c1 80       	breq	80004174 <xcmp_rx_process+0x78>
80004146:	e0 48 01 0a 	cp.w	r8,266
8000414a:	c1 90       	breq	8000417c <xcmp_rx_process+0x80>
8000414c:	e0 48 00 2c 	cp.w	r8,44
80004150:	c1 a1       	brne	80004184 <xcmp_rx_process+0x88>
80004152:	c0 98       	rjmp	80004164 <xcmp_rx_process+0x68>
			{
				case RADIO_STATUS:				
					xcmp_exec_func(&radio_status, ptr);
80004154:	4a 2c       	lddpc	r12,800041dc <xcmp_rx_process+0xe0>
80004156:	f0 1f 00 23 	mcall	800041e0 <xcmp_rx_process+0xe4>
					break;
8000415a:	c2 f8       	rjmp	800041b8 <xcmp_rx_process+0xbc>
					
				case VERSION_INFORMATION:
					xcmp_exec_func(&version_information, ptr);
8000415c:	4a 2c       	lddpc	r12,800041e4 <xcmp_rx_process+0xe8>
8000415e:	f0 1f 00 21 	mcall	800041e0 <xcmp_rx_process+0xe4>
					break;
80004162:	c2 b8       	rjmp	800041b8 <xcmp_rx_process+0xbc>
					
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
80004164:	4a 1c       	lddpc	r12,800041e8 <xcmp_rx_process+0xec>
80004166:	f0 1f 00 1f 	mcall	800041e0 <xcmp_rx_process+0xe4>
					break;
8000416a:	c2 78       	rjmp	800041b8 <xcmp_rx_process+0xbc>
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
8000416c:	04 9c       	mov	r12,r2
8000416e:	f0 1f 00 1d 	mcall	800041e0 <xcmp_rx_process+0xe4>
						, ptr);
					break;
80004172:	c2 38       	rjmp	800041b8 <xcmp_rx_process+0xbc>
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
80004174:	02 9c       	mov	r12,r1
80004176:	f0 1f 00 1b 	mcall	800041e0 <xcmp_rx_process+0xe4>
					break;
8000417a:	c1 f8       	rjmp	800041b8 <xcmp_rx_process+0xbc>
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
8000417c:	00 9c       	mov	r12,r0
8000417e:	f0 1f 00 19 	mcall	800041e0 <xcmp_rx_process+0xe4>
					break;
80004182:	c1 b8       	rjmp	800041b8 <xcmp_rx_process+0xbc>
					
				default:
				
					/*the xcmp message not in order list*/
					/*over the length of the list*/
					if((0x0400 != (ptr->xcmp_opcode & 0x0400)) 
80004184:	12 98       	mov	r8,r9
80004186:	e2 18 04 00 	andl	r8,0x400,COH
8000418a:	c0 70       	breq	80004198 <xcmp_rx_process+0x9c>
8000418c:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
80004190:	e0 48 00 68 	cp.w	r8,104
80004194:	e0 8a 00 08 	brle	800041a4 <xcmp_rx_process+0xa8>
						|| (MAX_APP_FUNC <= (ptr->xcmp_opcode & 0x00FF))
					)
					{
						/*xcmp request*/
						if( XCMP_REQUEST == (ptr->xcmp_opcode & 0xF000))
80004198:	e2 19 f0 00 	andl	r9,0xf000,COH
8000419c:	c0 e1       	brne	800041b8 <xcmp_rx_process+0xbc>
						{
							/*send not supported opcode to raido */
							xcmp_opcode_not_supported();
8000419e:	f0 1f 00 14 	mcall	800041ec <xcmp_rx_process+0xf0>
800041a2:	c0 b8       	rjmp	800041b8 <xcmp_rx_process+0xbc>
						}
					}
					else
					{					
						xcmp_exec_func( &app_list[ptr->xcmp_opcode & 0x00FF]
800041a4:	f9 da c0 08 	bfextu	r12,r10,0x0,0x8
800041a8:	f8 0c 00 1c 	add	r12,r12,r12<<0x1
800041ac:	49 19       	lddpc	r9,800041f0 <xcmp_rx_process+0xf4>
800041ae:	72 08       	ld.w	r8,r9[0x0]
800041b0:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800041b4:	f0 1f 00 0b 	mcall	800041e0 <xcmp_rx_process+0xe4>
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
800041b8:	66 0c       	ld.w	r12,r3[0x0]
800041ba:	40 0b       	lddsp	r11,sp[0x0]
800041bc:	f0 1f 00 0e 	mcall	800041f4 <xcmp_rx_process+0xf8>
800041c0:	ca 7b       	rjmp	8000410e <xcmp_rx_process+0x12>
800041c2:	00 00       	add	r0,r0
800041c4:	00 00       	add	r0,r0
800041c6:	0a e8       	st.h	--r5,r8
800041c8:	00 00       	add	r0,r0
800041ca:	0a 90       	mov	r0,r5
800041cc:	00 00       	add	r0,r0
800041ce:	0a f8       	st.b	--r5,r8
800041d0:	00 00       	add	r0,r0
800041d2:	0a ec       	st.h	--r5,r12
800041d4:	00 00       	add	r0,r0
800041d6:	0b 04       	ld.w	r4,r5++
800041d8:	80 00       	ld.sh	r0,r0[0x0]
800041da:	54 78       	stdsp	sp[0x11c],r8
800041dc:	00 00       	add	r0,r0
800041de:	0b 1c       	ld.sh	r12,r5++
800041e0:	80 00       	ld.sh	r0,r0[0x0]
800041e2:	40 00       	lddsp	r0,sp[0x0]
800041e4:	00 00       	add	r0,r0
800041e6:	0a dc       	st.w	--r5,r12
800041e8:	00 00       	add	r0,r0
800041ea:	0b 10       	ld.sh	r0,r5++
800041ec:	80 00       	ld.sh	r0,r0[0x0]
800041ee:	3f dc       	mov	r12,-3
800041f0:	00 00       	add	r0,r0
800041f2:	41 08       	lddsp	r8,sp[0x40]
800041f4:	80 00       	ld.sh	r0,r0[0x0]
800041f6:	29 c0       	sub	r0,-100

800041f8 <xcmp_rx>:
Calls:   
	xQueueSend -- xnl.c
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
800041f8:	eb cd 40 90 	pushm	r4,r7,lr
800041fc:	20 1d       	sub	sp,4
800041fe:	fa c4 ff f0 	sub	r4,sp,-16
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
80004202:	48 c8       	lddpc	r8,80004230 <xcmp_rx+0x38>
80004204:	70 0c       	ld.w	r12,r8[0x0]
80004206:	f0 1f 00 0c 	mcall	80004234 <xcmp_rx+0x3c>
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
8000420a:	c1 00       	breq	8000422a <xcmp_rx+0x32>
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
8000420c:	fa c7 ff fc 	sub	r7,sp,-4
80004210:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
	{
		memcpy(xcmp_ptr, &xcmp, sizeof(xcmp_fragment_t));				
80004212:	e0 6a 00 ca 	mov	r10,202
80004216:	08 9b       	mov	r11,r4
80004218:	f0 1f 00 08 	mcall	80004238 <xcmp_rx+0x40>
		xQueueSend(xcmp_frame_rx, &xcmp_ptr, 0);	
8000421c:	48 88       	lddpc	r8,8000423c <xcmp_rx+0x44>
8000421e:	70 0c       	ld.w	r12,r8[0x0]
80004220:	30 09       	mov	r9,0
80004222:	12 9a       	mov	r10,r9
80004224:	1a 9b       	mov	r11,sp
80004226:	f0 1f 00 07 	mcall	80004240 <xcmp_rx+0x48>
	}	
}
8000422a:	2f fd       	sub	sp,-4
8000422c:	e3 cd 80 90 	ldm	sp++,r4,r7,pc
80004230:	00 00       	add	r0,r0
80004232:	0a 90       	mov	r0,r5
80004234:	80 00       	ld.sh	r0,r0[0x0]
80004236:	2f 2c       	sub	r12,-14
80004238:	80 00       	ld.sh	r0,r0[0x0]
8000423a:	6b d4       	ld.w	r4,r5[0x74]
8000423c:	00 00       	add	r0,r0
8000423e:	0a e8       	st.h	--r5,r8
80004240:	80 00       	ld.sh	r0,r0[0x0]
80004242:	56 84       	stdsp	sp[0x1a0],r4

80004244 <xnl_register_xcmp_func>:
Function: xnl_register_xcmp_func
Description: register the xcmp function(callback function)
*/
void xnl_register_xcmp_func( void ( *func)(xnl_content_data_msg_t))
{
	 xcmp_exec = func;
80004244:	48 28       	lddpc	r8,8000424c <xnl_register_xcmp_func+0x8>
80004246:	91 0c       	st.w	r8[0x0],r12
}
80004248:	5e fc       	retal	r12
8000424a:	00 00       	add	r0,r0
8000424c:	00 00       	add	r0,r0
8000424e:	0b 48       	ld.w	r8,--r5

80004250 <xnl_get_msg_ack_func>:
Description: process while receive msg ack.
Calls:xSemaphoreGive--freertos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
80004250:	d4 01       	pushm	lr
	
	DestinationAddress = xnl->xnl_header.destination;
	/*No timeout*/		
	 //One relationship is controlled by a state machine, only the current MSG received the ACK, 
	//then the program will clear the current MSG sending address and out of standby and will jump to the sending state.
	if (DestinationAddress == xnl_information.device_address )
80004252:	48 88       	lddpc	r8,80004270 <xnl_get_msg_ack_func+0x20>
80004254:	90 28       	ld.sh	r8,r8[0x4]
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
	U16 DestinationAddress;
	U16 TransactionID;
	
	DestinationAddress = xnl->xnl_header.destination;
80004256:	98 49       	ld.sh	r9,r12[0x8]
80004258:	f0 09 19 00 	cp.h	r9,r8
8000425c:	c0 81       	brne	8000426c <xnl_get_msg_ack_func+0x1c>
	if (DestinationAddress == xnl_information.device_address )
	{
		//The ack is for me.
		
		TransactionID = xnl->xnl_header.transaction_id;
		xSemaphoreGive(xnl_timeout_semphr);	
8000425e:	48 68       	lddpc	r8,80004274 <xnl_get_msg_ack_func+0x24>
80004260:	70 0c       	ld.w	r12,r8[0x0]
80004262:	30 09       	mov	r9,0
80004264:	12 9a       	mov	r10,r9
80004266:	12 9b       	mov	r11,r9
80004268:	f0 1f 00 04 	mcall	80004278 <xnl_get_msg_ack_func+0x28>
8000426c:	d8 02       	popm	pc
8000426e:	00 00       	add	r0,r0
80004270:	00 00       	add	r0,r0
80004272:	0b 2e       	ld.uh	lr,r5++
80004274:	00 00       	add	r0,r0
80004276:	0b 28       	ld.uh	r8,r5++
80004278:	80 00       	ld.sh	r0,r0[0x0]
8000427a:	56 84       	stdsp	sp[0x1a0],r4

8000427c <xnl_tx_process>:
	xSemaphoreTake--freertos 
	phy_tx -- physical.c
Called By: task
*/
static void xnl_tx_process(void * pvParameters)
{
8000427c:	d4 31       	pushm	r0-r7,lr
	static  xnl_fragment_t * ptr;//是否可以修缮为静态变量？请关注
	
	
	for(;;)
	{		
		switch(xnl_tx_state)
8000427e:	4a 86       	lddpc	r6,8000431c <xnl_tx_process+0xa0>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
80004280:	4a 82       	lddpc	r2,80004320 <xnl_tx_process+0xa4>
80004282:	4a 94       	lddpc	r4,80004324 <xnl_tx_process+0xa8>
80004284:	30 07       	mov	r7,0
80004286:	3f f1       	mov	r1,-1
					if(NULL == ptr)
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
80004288:	30 00       	mov	r0,0
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;
8000428a:	4a 85       	lddpc	r5,80004328 <xnl_tx_process+0xac>
					
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
8000428c:	4a 83       	lddpc	r3,8000432c <xnl_tx_process+0xb0>
	static  xnl_fragment_t * ptr;//是否可以修缮为静态变量？请关注
	
	
	for(;;)
	{		
		switch(xnl_tx_state)
8000428e:	6c 08       	ld.w	r8,r6[0x0]
80004290:	58 08       	cp.w	r8,0
80004292:	c0 40       	breq	8000429a <xnl_tx_process+0x1e>
80004294:	58 18       	cp.w	r8,1
80004296:	cf d1       	brne	80004290 <xnl_tx_process+0x14>
80004298:	c2 08       	rjmp	800042d8 <xnl_tx_process+0x5c>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
8000429a:	64 0c       	ld.w	r12,r2[0x0]
8000429c:	0e 99       	mov	r9,r7
8000429e:	02 9a       	mov	r10,r1
800042a0:	08 9b       	mov	r11,r4
800042a2:	f0 1f 00 24 	mcall	80004330 <xnl_tx_process+0xb4>
800042a6:	58 1c       	cp.w	r12,1
800042a8:	cf 31       	brne	8000428e <xnl_tx_process+0x12>
					, portMAX_DELAY ))
				{				
					if(NULL == ptr)
800042aa:	68 0c       	ld.w	r12,r4[0x0]
800042ac:	58 0c       	cp.w	r12,0
800042ae:	cf 00       	breq	8000428e <xnl_tx_process+0x12>
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
800042b0:	98 28       	ld.sh	r8,r12[0x4]
800042b2:	e0 08 19 00 	cp.h	r8,r0
800042b6:	c0 41       	brne	800042be <xnl_tx_process+0x42>
					{
						/*invalid XNL opcode*/
						vPortFree(ptr);
800042b8:	f0 1f 00 1f 	mcall	80004334 <xnl_tx_process+0xb8>
						break;
800042bc:	ce 9b       	rjmp	8000428e <xnl_tx_process+0x12>
					}
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
800042be:	f0 1f 00 1f 	mcall	80004338 <xnl_tx_process+0xbc>
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;
800042c2:	30 18       	mov	r8,1
800042c4:	8b 08       	st.w	r5[0x0],r8
					
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
800042c6:	66 0c       	ld.w	r12,r3[0x0]
800042c8:	0e 99       	mov	r9,r7
800042ca:	0e 9a       	mov	r10,r7
800042cc:	0e 9b       	mov	r11,r7
800042ce:	f0 1f 00 19 	mcall	80004330 <xnl_tx_process+0xb4>
					xnl_tx_state = WAITING_FOR_REPLY;
800042d2:	30 18       	mov	r8,1
800042d4:	8d 08       	st.w	r6[0x0],r8
800042d6:	cd cb       	rjmp	8000428e <xnl_tx_process+0x12>
				}
				break;
			
			/*wait XNL reply*/			
			case WAITING_FOR_REPLY://直到回答ACK才再发送下一条data/control
				if(pdTRUE == xSemaphoreTake( xnl_timeout_semphr
800042d8:	66 0c       	ld.w	r12,r3[0x0]
800042da:	0e 99       	mov	r9,r7
800042dc:	36 4a       	mov	r10,100
800042de:	0e 9b       	mov	r11,r7
800042e0:	f0 1f 00 14 	mcall	80004330 <xnl_tx_process+0xb4>
800042e4:	58 1c       	cp.w	r12,1
800042e6:	c0 81       	brne	800042f6 <xnl_tx_process+0x7a>
					, ( portTickType )50*2/ portTICK_RATE_MS))//按ADK文档中提示500ms一次超时,但是实际情况下程序中启用freertos的任务延时不够精准。因此根据经验需要降低延时等待的时间
				{
					/*No timeout*/
					//vPortFree(ptr);	
					set_xnl_idle(ptr);			
800042e8:	49 58       	lddpc	r8,8000433c <xnl_tx_process+0xc0>
800042ea:	70 0c       	ld.w	r12,r8[0x0]
800042ec:	68 0b       	ld.w	r11,r4[0x0]
800042ee:	f0 1f 00 15 	mcall	80004340 <xnl_tx_process+0xc4>
					xnl_tx_state = WAITING_FOR_TX;
800042f2:	8d 07       	st.w	r6[0x0],r7
800042f4:	cc db       	rjmp	8000428e <xnl_tx_process+0x12>
				}
				else
				{
					/*time out*/
					if(xnl_send_times <= MIN_RESEND_TIMES)
800042f6:	6a 08       	ld.w	r8,r5[0x0]
800042f8:	58 38       	cp.w	r8,3
800042fa:	e0 89 00 09 	brgt	8000430c <xnl_tx_process+0x90>
					{
						/*If times smaller than A supermarket, then resend the 
						instructions*/
						phy_tx((phy_fragment_t *)ptr);
800042fe:	68 0c       	ld.w	r12,r4[0x0]
80004300:	f0 1f 00 0e 	mcall	80004338 <xnl_tx_process+0xbc>
						xnl_send_times++;
80004304:	6a 08       	ld.w	r8,r5[0x0]
80004306:	2f f8       	sub	r8,-1
80004308:	8b 08       	st.w	r5[0x0],r8
8000430a:	cc 2b       	rjmp	8000428e <xnl_tx_process+0x12>
					}
					else
					{
						//can not send data, disconnected						
						//vPortFree(ptr);	
						set_xnl_idle(ptr);									
8000430c:	48 c8       	lddpc	r8,8000433c <xnl_tx_process+0xc0>
8000430e:	70 0c       	ld.w	r12,r8[0x0]
80004310:	68 0b       	ld.w	r11,r4[0x0]
80004312:	f0 1f 00 0c 	mcall	80004340 <xnl_tx_process+0xc4>
						xnl_tx_state = WAITING_FOR_TX;
80004316:	8d 07       	st.w	r6[0x0],r7
80004318:	cb bb       	rjmp	8000428e <xnl_tx_process+0x12>
8000431a:	00 00       	add	r0,r0
8000431c:	00 00       	add	r0,r0
8000431e:	0b 44       	ld.w	r4,--r5
80004320:	00 00       	add	r0,r0
80004322:	0b 38       	ld.ub	r8,r5++
80004324:	00 00       	add	r0,r0
80004326:	0b 3c       	ld.ub	r12,r5++
80004328:	00 00       	add	r0,r0
8000432a:	0b 40       	ld.w	r0,--r5
8000432c:	00 00       	add	r0,r0
8000432e:	0b 28       	ld.uh	r8,r5++
80004330:	80 00       	ld.sh	r0,r0[0x0]
80004332:	54 78       	stdsp	sp[0x11c],r8
80004334:	80 00       	ld.sh	r0,r0[0x0]
80004336:	53 08       	stdsp	sp[0xc0],r8
80004338:	80 00       	ld.sh	r0,r0[0x0]
8000433a:	29 e0       	sub	r0,-98
8000433c:	00 00       	add	r0,r0
8000433e:	0a 90       	mov	r0,r5
80004340:	80 00       	ld.sh	r0,r0[0x0]
80004342:	29 c0       	sub	r0,-100

80004344 <xnl_rx_process>:
Description: Receive the XNL
Calls: 
Called By:task
*/
static void xnl_rx_process(void * pvParameters)
{
80004344:	eb cd 40 fe 	pushm	r1-r7,lr
80004348:	20 1d       	sub	sp,4
	/*To ptr the elements in the queue*/
	xnl_fragment_t * xnl_ptr;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
8000434a:	49 26       	lddpc	r6,80004390 <xnl_rx_process+0x4c>
8000434c:	30 05       	mov	r5,0
8000434e:	3f f4       	mov	r4,-1
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
80004350:	30 c3       	mov	r3,12
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
80004352:	49 11       	lddpc	r1,80004394 <xnl_rx_process+0x50>
	if(xnl->xnl_header.opcode > 0x0C)	
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
80004354:	49 12       	lddpc	r2,80004398 <xnl_rx_process+0x54>
	/*To ptr the elements in the queue*/
	xnl_fragment_t * xnl_ptr;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
80004356:	6c 0c       	ld.w	r12,r6[0x0]
80004358:	0a 99       	mov	r9,r5
8000435a:	08 9a       	mov	r10,r4
8000435c:	1a 9b       	mov	r11,sp
8000435e:	f0 1f 00 10 	mcall	8000439c <xnl_rx_process+0x58>
80004362:	58 1c       	cp.w	r12,1
80004364:	cf 91       	brne	80004356 <xnl_rx_process+0x12>
		, portMAX_DELAY ))
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
80004366:	40 0c       	lddsp	r12,sp[0x0]
80004368:	58 0c       	cp.w	r12,0
8000436a:	cf 60       	breq	80004356 <xnl_rx_process+0x12>
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
8000436c:	98 28       	ld.sh	r8,r12[0x4]
8000436e:	e6 08 19 00 	cp.h	r8,r3
80004372:	e0 8b 00 0a 	brhi	80004386 <xnl_rx_process+0x42>
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
80004376:	5c 78       	castu.h	r8
80004378:	e4 08 03 29 	ld.w	r9,r2[r8<<0x2]
8000437c:	58 09       	cp.w	r9,0
8000437e:	c0 40       	breq	80004386 <xnl_rx_process+0x42>
	{
		//log("\n\r R_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:R_xnl指令
		/*execute the function in list*/
		xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec(xnl);
80004380:	e4 08 03 28 	ld.w	r8,r2[r8<<0x2]
80004384:	5d 18       	icall	r8
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
80004386:	62 0c       	ld.w	r12,r1[0x0]
80004388:	40 0b       	lddsp	r11,sp[0x0]
8000438a:	f0 1f 00 06 	mcall	800043a0 <xnl_rx_process+0x5c>
8000438e:	ce 4b       	rjmp	80004356 <xnl_rx_process+0x12>
80004390:	00 00       	add	r0,r0
80004392:	0a b8       	st.h	r5++,r8
80004394:	00 00       	add	r0,r0
80004396:	0a 90       	mov	r0,r5
80004398:	00 00       	add	r0,r0
8000439a:	04 f4       	st.b	--r2,r4
8000439c:	80 00       	ld.sh	r0,r0[0x0]
8000439e:	54 78       	stdsp	sp[0x11c],r8
800043a0:	80 00       	ld.sh	r0,r0[0x0]
800043a2:	29 c0       	sub	r0,-100

800043a4 <xnl_tx>:
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
{
800043a4:	eb cd 40 c0 	pushm	r6-r7,lr
800043a8:	20 1d       	sub	sp,4
800043aa:	18 96       	mov	r6,r12
	message that is sent. The same value should be used for all retries.
	*/
	static U8 flags = 0;
	
	/*If the value is DEFAULT_VALUE, the value will be modified*/
	if(DEFAULT_VALUE == xnl->xnl_header.flags)
800043ac:	98 39       	ld.sh	r9,r12[0x6]
800043ae:	3f f8       	mov	r8,-1
800043b0:	f0 09 19 00 	cp.h	r9,r8
800043b4:	c0 a1       	brne	800043c8 <xnl_tx+0x24>
	{
		xnl->xnl_header.flags =  0x0100 | ((++flags) & 0x07);
800043b6:	4a e9       	lddpc	r9,8000446c <xnl_tx+0xc8>
800043b8:	13 88       	ld.ub	r8,r9[0x0]
800043ba:	2f f8       	sub	r8,-1
800043bc:	5c 58       	castu.b	r8
800043be:	b2 88       	st.b	r9[0x0],r8
800043c0:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
800043c4:	a9 a8       	sbr	r8,0x8
800043c6:	b8 38       	st.h	r12[0x6],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.destination)
800043c8:	8c 49       	ld.sh	r9,r6[0x8]
800043ca:	3f f8       	mov	r8,-1
800043cc:	f0 09 19 00 	cp.h	r9,r8
800043d0:	c0 41       	brne	800043d8 <xnl_tx+0x34>
	{		
		/*Use actual Master address.*/
		xnl->xnl_header.destination = xnl_information.master_address;
800043d2:	4a 88       	lddpc	r8,80004470 <xnl_tx+0xcc>
800043d4:	90 18       	ld.sh	r8,r8[0x2]
800043d6:	ac 48       	st.h	r6[0x8],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.source)
800043d8:	8c 59       	ld.sh	r9,r6[0xa]
800043da:	3f f8       	mov	r8,-1
800043dc:	f0 09 19 00 	cp.h	r9,r8
800043e0:	c0 41       	brne	800043e8 <xnl_tx+0x44>
	{
		/*Use Temporary address.*/	
		xnl->xnl_header.source = xnl_information.device_address;
800043e2:	4a 48       	lddpc	r8,80004470 <xnl_tx+0xcc>
800043e4:	90 28       	ld.sh	r8,r8[0x4]
800043e6:	ac 58       	st.h	r6[0xa],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
800043e8:	8c 69       	ld.sh	r9,r6[0xc]
800043ea:	3f f8       	mov	r8,-1
800043ec:	f0 09 19 00 	cp.h	r9,r8
800043f0:	c0 e1       	brne	8000440c <xnl_tx+0x68>
	{		
		xnl->xnl_header.transaction_id = 
		  ((++xnl_information.transaction_id) & 0xFF) 
800043f2:	4a 08       	lddpc	r8,80004470 <xnl_tx+0xcc>
800043f4:	90 49       	ld.sh	r9,r8[0x8]
800043f6:	2f f9       	sub	r9,-1
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
800043f8:	b0 49       	st.h	r8[0x8],r9
		  ((++xnl_information.transaction_id) & 0xFF) 
800043fa:	90 4a       	ld.sh	r10,r8[0x8]
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
800043fc:	90 49       	ld.sh	r9,r8[0x8]
800043fe:	e0 19 ff 00 	andl	r9,0xff00
80004402:	f1 da c0 08 	bfextu	r8,r10,0x0,0x8
80004406:	f3 e8 10 08 	or	r8,r9,r8
8000440a:	ac 68       	st.h	r6[0xc],r8
	U16  sumScratch;
	U32  indextohWord;
	S32  hWordswithinFrag;
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
8000440c:	0d 98       	ld.ub	r8,r6[0x1]
8000440e:	20 28       	sub	r8,2
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
80004410:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
80004414:	10 0c       	add	r12,r8
80004416:	a1 5c       	asr	r12,0x1
	indextohWord = 2;
	while (hWordswithinFrag > 0)
80004418:	58 0c       	cp.w	r12,0
8000441a:	e0 89 00 04 	brgt	80004422 <xnl_tx+0x7e>
8000441e:	30 09       	mov	r9,0
80004420:	c0 d8       	rjmp	8000443a <xnl_tx+0x96>
80004422:	ec ca ff fc 	sub	r10,r6,-4
Parameters: xnl_fragment_t * 
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
80004426:	2f ec       	sub	r12,-2
80004428:	30 09       	mov	r9,0
8000442a:	30 28       	mov	r8,2
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
	{
		sumScratch += *((U16*)xnl + indextohWord);
8000442c:	15 1b       	ld.sh	r11,r10++
8000442e:	f6 09 00 09 	add	r9,r11,r9
80004432:	5c 89       	casts.h	r9
		indextohWord     += 1;
80004434:	2f f8       	sub	r8,-1
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
80004436:	18 38       	cp.w	r8,r12
80004438:	cf a1       	brne	8000442c <xnl_tx+0x88>
		  ((++xnl_information.transaction_id) & 0xFF) 
		| (xnl_information.transaction_id & 0xFF00);
	}
	
	/*count check sum */
	xnl->phy_header.check_sum = check_sum( xnl );
8000443a:	5c 39       	neg	r9
8000443c:	ac 19       	st.h	r6[0x2],r9
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
8000443e:	48 e8       	lddpc	r8,80004474 <xnl_tx+0xd0>
80004440:	70 0c       	ld.w	r12,r8[0x0]
80004442:	f0 1f 00 0e 	mcall	80004478 <xnl_tx+0xd4>
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
80004446:	c1 00       	breq	80004466 <xnl_tx+0xc2>
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
80004448:	fa c7 ff fc 	sub	r7,sp,-4
8000444c:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
	{
		memcpy(ptr, xnl, sizeof(xnl_fragment_t));
8000444e:	e0 6a 01 00 	mov	r10,256
80004452:	0c 9b       	mov	r11,r6
80004454:	f0 1f 00 0a 	mcall	8000447c <xnl_tx+0xd8>
	
		/*push to queue and send*/
		
		//log("ptr -%8x", ptr);
		
		xQueueSend(xnl_frame_tx, &ptr, 0);
80004458:	48 a8       	lddpc	r8,80004480 <xnl_tx+0xdc>
8000445a:	70 0c       	ld.w	r12,r8[0x0]
8000445c:	30 09       	mov	r9,0
8000445e:	12 9a       	mov	r10,r9
80004460:	1a 9b       	mov	r11,sp
80004462:	f0 1f 00 09 	mcall	80004484 <xnl_tx+0xe0>
		//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
		
		//vPortFree(ptr);
	}
}
80004466:	2f fd       	sub	sp,-4
80004468:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000446c:	00 00       	add	r0,r0
8000446e:	0b 2c       	ld.uh	r12,r5++
80004470:	00 00       	add	r0,r0
80004472:	0b 2e       	ld.uh	lr,r5++
80004474:	00 00       	add	r0,r0
80004476:	0a 90       	mov	r0,r5
80004478:	80 00       	ld.sh	r0,r0[0x0]
8000447a:	2f 2c       	sub	r12,-14
8000447c:	80 00       	ld.sh	r0,r0[0x0]
8000447e:	6b d4       	ld.w	r4,r5[0x74]
80004480:	00 00       	add	r0,r0
80004482:	0b 38       	ld.ub	r8,r5++
80004484:	80 00       	ld.sh	r0,r0[0x0]
80004486:	56 84       	stdsp	sp[0x1a0],r4

80004488 <xnl_init>:
	xTaskCreate--freertos
	xnl_send_device_master_query
Called By:xcmp_init -- xcmp.c
*/
void xnl_init(void)
{
80004488:	eb cd 40 80 	pushm	r7,lr
8000448c:	fa cd 01 00 	sub	sp,sp,256
	/*initialize the physical layer*/
	phy_init();
80004490:	f0 1f 00 27 	mcall	8000452c <xnl_init+0xa4>
	
	xnl_information.is_connected = FALSE;
80004494:	30 09       	mov	r9,0
80004496:	4a 78       	lddpc	r8,80004530 <xnl_init+0xa8>
80004498:	b0 89       	st.b	r8[0x0],r9

	/*initialize the semaphore and queue*/
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
8000449a:	30 0b       	mov	r11,0
8000449c:	30 1c       	mov	r12,1
8000449e:	f0 1f 00 26 	mcall	80004534 <xnl_init+0xac>
800044a2:	4a 68       	lddpc	r8,80004538 <xnl_init+0xb0>
800044a4:	91 0c       	st.w	r8[0x0],r12
800044a6:	70 08       	ld.w	r8,r8[0x0]
800044a8:	58 08       	cp.w	r8,0
800044aa:	c0 80       	breq	800044ba <xnl_init+0x32>
800044ac:	4a 38       	lddpc	r8,80004538 <xnl_init+0xb0>
800044ae:	70 0c       	ld.w	r12,r8[0x0]
800044b0:	30 09       	mov	r9,0
800044b2:	12 9a       	mov	r10,r9
800044b4:	12 9b       	mov	r11,r9
800044b6:	f0 1f 00 22 	mcall	8000453c <xnl_init+0xb4>
	//xnl_frame_tx = xQueueCreate(10, sizeof(xnl_fragment_t *)); 
	
	xnl_frame_tx = xQueueCreate(20, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
800044ba:	30 4b       	mov	r11,4
800044bc:	31 4c       	mov	r12,20
800044be:	f0 1f 00 1e 	mcall	80004534 <xnl_init+0xac>
800044c2:	4a 08       	lddpc	r8,80004540 <xnl_init+0xb8>
800044c4:	91 0c       	st.w	r8[0x0],r12
		
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
800044c6:	30 07       	mov	r7,0
800044c8:	1a d7       	st.w	--sp,r7
800044ca:	1a d7       	st.w	--sp,r7
800044cc:	1a d7       	st.w	--sp,r7
800044ce:	30 38       	mov	r8,3
800044d0:	0e 99       	mov	r9,r7
800044d2:	e0 6a 02 00 	mov	r10,512
800044d6:	49 cb       	lddpc	r11,80004544 <xnl_init+0xbc>
800044d8:	49 cc       	lddpc	r12,80004548 <xnl_init+0xc0>
800044da:	f0 1f 00 1d 	mcall	8000454c <xnl_init+0xc4>
	,  tskXNL_PRIORITY //+ 1
	,  NULL
	);
	
	/*this task is used to send xnl message*/
	xTaskCreate(
800044de:	1a d7       	st.w	--sp,r7
800044e0:	1a d7       	st.w	--sp,r7
800044e2:	1a d7       	st.w	--sp,r7
800044e4:	30 38       	mov	r8,3
800044e6:	0e 99       	mov	r9,r7
800044e8:	e0 6a 03 20 	mov	r10,800
800044ec:	49 9b       	lddpc	r11,80004550 <xnl_init+0xc8>
800044ee:	49 ac       	lddpc	r12,80004554 <xnl_init+0xcc>
800044f0:	f0 1f 00 17 	mcall	8000454c <xnl_init+0xc4>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
800044f4:	e0 68 40 0e 	mov	r8,16398
800044f8:	fb 58 00 18 	st.h	sp[24],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
800044fc:	3f f8       	mov	r8,-1
800044fe:	fb 58 00 1a 	st.h	sp[26],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_MASTER_QUERY;
80004502:	30 38       	mov	r8,3
80004504:	fb 58 00 1c 	st.h	sp[28],r8
	
	/*The initial value*/
	xnl_frame.xnl_header.flags = 0;
80004508:	fb 57 00 1e 	st.h	sp[30],r7
	
	/*XNL address of the master device, if known;otherwise 0x0000*/
	xnl_frame.xnl_header.destination = 0;
8000450c:	fb 57 00 20 	st.h	sp[32],r7
	
	/*XNL address, if assigned; otherwise 0x0000*/
	xnl_frame.xnl_header.source = 0;
80004510:	fb 57 00 22 	st.h	sp[34],r7
	
	/*No transaction ID required for this message*/
	xnl_frame.xnl_header.transaction_id = 0;
80004514:	fb 57 00 24 	st.h	sp[36],r7
	
	/*This message contains no payload*/
	xnl_frame.xnl_header.payload_length = 0;
80004518:	fb 57 00 26 	st.h	sp[38],r7

	/*send XNL message*/
	xnl_tx(&xnl_frame);
8000451c:	fa cc ff e8 	sub	r12,sp,-24
80004520:	f0 1f 00 0e 	mcall	80004558 <xnl_init+0xd0>
80004524:	2f ad       	sub	sp,-24
	,  NULL
	);
	
	/*send device_master_query to connect radio*/	
	xnl_send_device_master_query();
}
80004526:	2c 0d       	sub	sp,-256
80004528:	e3 cd 80 80 	ldm	sp++,r7,pc
8000452c:	80 00       	ld.sh	r0,r0[0x0]
8000452e:	2f 54       	sub	r4,-11
80004530:	00 00       	add	r0,r0
80004532:	0b 2e       	ld.uh	lr,r5++
80004534:	80 00       	ld.sh	r0,r0[0x0]
80004536:	57 dc       	stdsp	sp[0x1f4],r12
80004538:	00 00       	add	r0,r0
8000453a:	0b 28       	ld.uh	r8,r5++
8000453c:	80 00       	ld.sh	r0,r0[0x0]
8000453e:	56 84       	stdsp	sp[0x1a0],r4
80004540:	00 00       	add	r0,r0
80004542:	0b 38       	ld.ub	r8,r5++
80004544:	80 00       	ld.sh	r0,r0[0x0]
80004546:	cb d0       	breq	800044c0 <xnl_init+0x38>
80004548:	80 00       	ld.sh	r0,r0[0x0]
8000454a:	43 44       	lddsp	r4,sp[0xd0]
8000454c:	80 00       	ld.sh	r0,r0[0x0]
8000454e:	5e b0       	rethi	r0
80004550:	80 00       	ld.sh	r0,r0[0x0]
80004552:	c4 00       	breq	800045d2 <xnl_device_auth_reply_func+0x16>
80004554:	80 00       	ld.sh	r0,r0[0x0]
80004556:	42 7c       	lddsp	r12,sp[0x9c]
80004558:	80 00       	ld.sh	r0,r0[0x0]
8000455a:	43 a4       	lddsp	r4,sp[0xe8]

8000455c <xnl_data_msg_func>:
Description: process while receive data message.
Calls:xnl_send_msg_ack, xcmp_exec(function in xcmp)
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_data_msg_func(xnl_fragment_t * xnl)
{
8000455c:	eb cd 40 80 	pushm	r7,lr
80004560:	fa cd 01 00 	sub	sp,sp,256
80004564:	18 97       	mov	r7,r12
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80004566:	e0 68 40 0e 	mov	r8,16398
8000456a:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
8000456c:	3f f8       	mov	r8,-1
8000456e:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG_ACK;
80004570:	30 c8       	mov	r8,12
80004572:	ba 28       	st.h	sp[0x4],r8
	
	/*Turn around Flags.*/	
	xnl_frame.xnl_header.flags = hdr->flags;
80004574:	98 38       	ld.sh	r8,r12[0x6]
80004576:	ba 38       	st.h	sp[0x6],r8
	
	/*ACK Destination Address is Source of XNL_Message.*/
	xnl_frame.xnl_header.destination = hdr->source;
80004578:	98 58       	ld.sh	r8,r12[0xa]
8000457a:	ba 48       	st.h	sp[0x8],r8
	
	/*ACK Source Address is my address.*/
	xnl_frame.xnl_header.source = hdr->destination;
8000457c:	98 48       	ld.sh	r8,r12[0x8]
8000457e:	ba 58       	st.h	sp[0xa],r8
	
	/*Turn around Transaction ID.*/
	xnl_frame.xnl_header.transaction_id = hdr->transaction_id;
80004580:	98 68       	ld.sh	r8,r12[0xc]
80004582:	ba 68       	st.h	sp[0xc],r8
	xnl_frame.xnl_header.payload_length = 0;
80004584:	30 08       	mov	r8,0
80004586:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004588:	1a 9c       	mov	r12,sp
8000458a:	f0 1f 00 0a 	mcall	800045b0 <xnl_data_msg_func+0x54>
	transmitter, but possibly is waiting in Queue with immediate timeout.
	 */
	xnl_send_msg_ack(&xnl->xnl_header);
	
	/*exec xcmp function*/
	xcmp_exec(xnl->xnl_payload.xnl_content_data_msg);//xcmp_rx
8000458e:	fa cd 00 cc 	sub	sp,sp,204
80004592:	e0 6a 00 ca 	mov	r10,202
80004596:	ee cb ff f0 	sub	r11,r7,-16
8000459a:	1a 9c       	mov	r12,sp
8000459c:	f0 1f 00 06 	mcall	800045b4 <xnl_data_msg_func+0x58>
800045a0:	48 68       	lddpc	r8,800045b8 <xnl_data_msg_func+0x5c>
800045a2:	70 08       	ld.w	r8,r8[0x0]
800045a4:	5d 18       	icall	r8
800045a6:	fa cd ff 34 	sub	sp,sp,-204
}
800045aa:	2c 0d       	sub	sp,-256
800045ac:	e3 cd 80 80 	ldm	sp++,r7,pc
800045b0:	80 00       	ld.sh	r0,r0[0x0]
800045b2:	43 a4       	lddsp	r4,sp[0xe8]
800045b4:	80 00       	ld.sh	r0,r0[0x0]
800045b6:	6b d4       	ld.w	r4,r5[0x74]
800045b8:	00 00       	add	r0,r0
800045ba:	0b 48       	ld.w	r8,--r5

800045bc <xnl_device_auth_reply_func>:
Description: process while receive device auth reply.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_auth_reply_func(xnl_fragment_t * xnl)
{
800045bc:	d4 21       	pushm	r4-r7,lr
800045be:	fa cd 01 00 	sub	sp,sp,256
800045c2:	18 97       	mov	r7,r12
	the receiving device and will be used to authenticate the connection 
	request. 5.4.4
	*/
	//log("R_xnl-opcode:%4x", xnl->xnl_header.opcode);
	
	if(xnl_information.is_connected)
800045c4:	4c 28       	lddpc	r8,800046cc <xnl_device_auth_reply_func+0x110>
800045c6:	11 88       	ld.ub	r8,r8[0x0]
800045c8:	58 08       	cp.w	r8,0
800045ca:	e0 81 00 7f 	brne	800046c8 <xnl_device_auth_reply_func+0x10c>
	{
		return;		
	}
	
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);
800045ce:	4c 18       	lddpc	r8,800046d0 <xnl_device_auth_reply_func+0x114>
800045d0:	70 0c       	ld.w	r12,r8[0x0]
800045d2:	30 09       	mov	r9,0
800045d4:	12 9a       	mov	r10,r9
800045d6:	12 9b       	mov	r11,r9
800045d8:	f0 1f 00 3f 	mcall	800046d4 <xnl_device_auth_reply_func+0x118>

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
800045dc:	ef 09 00 10 	ld.sh	r9,r7[16]
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
800045e0:	4b b8       	lddpc	r8,800046cc <xnl_device_auth_reply_func+0x110>
800045e2:	b0 29       	st.h	r8[0x4],r9
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
	
	/*Get Array of values to be encrypted into an aligned 2X32bits.*/
	v_vector[0] =
800045e4:	ef 39 00 12 	ld.ub	r9,r7[18]
800045e8:	ef 38 00 13 	ld.ub	r8,r7[19]
800045ec:	b1 68       	lsl	r8,0x10
800045ee:	f1 e9 11 89 	or	r9,r8,r9<<0x18
800045f2:	ef 38 00 15 	ld.ub	r8,r7[21]
800045f6:	f3 e8 10 08 	or	r8,r9,r8
800045fa:	ef 39 00 14 	ld.ub	r9,r7[20]
800045fe:	f1 e9 10 89 	or	r9,r8,r9<<0x8
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[2])<<8	  
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[3]);
	
	v_vector[1] =
80004602:	ef 3a 00 16 	ld.ub	r10,r7[22]
80004606:	ef 38 00 17 	ld.ub	r8,r7[23]
8000460a:	b1 68       	lsl	r8,0x10
8000460c:	f1 ea 11 8a 	or	r10,r8,r10<<0x18
80004610:	ef 38 00 19 	ld.ub	r8,r7[25]
80004614:	f5 e8 10 08 	or	r8,r10,r8
80004618:	ef 3a 00 18 	ld.ub	r10,r7[24]
8000461c:	f1 ea 10 88 	or	r8,r8,r10<<0x8
80004620:	30 0a       	mov	r10,0
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
80004622:	e0 64 79 b9 	mov	r4,31161
80004626:	ea 14 9e 37 	orh	r4,0x9e37
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
8000462a:	e0 65 45 07 	mov	r5,17671
8000462e:	ea 15 8a bd 	orh	r5,0x8abd
80004632:	e0 66 f9 3d 	mov	r6,63805
80004636:	ea 16 99 68 	orh	r6,0x9968
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
8000463a:	e0 6e b8 cf 	mov	lr,47311
8000463e:	ea 1e 36 83 	orh	lr,0x3683
80004642:	e0 67 aa 1c 	mov	r7,43548
80004646:	ea 17 9c 36 	orh	r7,0x9c36
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
8000464a:	08 0a       	add	r10,r4
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
8000464c:	f4 08 00 0c 	add	r12,r10,r8
80004650:	f0 0b 15 04 	lsl	r11,r8,0x4
80004654:	0a 0b       	add	r11,r5
80004656:	f9 eb 20 0b 	eor	r11,r12,r11
8000465a:	f0 0c 16 05 	lsr	r12,r8,0x5
8000465e:	0c 0c       	add	r12,r6
80004660:	18 5b       	eor	r11,r12
80004662:	16 09       	add	r9,r11
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
80004664:	f2 0c 15 04 	lsl	r12,r9,0x4
80004668:	1c 0c       	add	r12,lr
8000466a:	f2 0b 16 05 	lsr	r11,r9,0x5
8000466e:	0e 0b       	add	r11,r7
80004670:	f9 eb 20 0b 	eor	r11,r12,r11
80004674:	f2 0a 00 0c 	add	r12,r9,r10
80004678:	18 5b       	eor	r11,r12
8000467a:	16 08       	add	r8,r11
{
	register U32 y=v[0], z=v[1], sum=0;
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
8000467c:	e0 6b 37 20 	mov	r11,14112
80004680:	ea 1b c6 ef 	orh	r11,0xc6ef
80004684:	16 3a       	cp.w	r10,r11
80004686:	ce 21       	brne	8000464a <xnl_device_auth_reply_func+0x8e>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :24 + 2(xnl length(24) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 24 + 2;
80004688:	e0 6a 40 1a 	mov	r10,16410
8000468c:	ba 0a       	st.h	sp[0x0],r10
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
8000468e:	3f fa       	mov	r10,-1
80004690:	ba 1a       	st.h	sp[0x2],r10
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_CONN_REQUEST;
80004692:	30 6b       	mov	r11,6
80004694:	ba 2b       	st.h	sp[0x4],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
80004696:	ba 3a       	st.h	sp[0x6],r10
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
80004698:	48 db       	lddpc	r11,800046cc <xnl_device_auth_reply_func+0x110>
8000469a:	96 1c       	ld.sh	r12,r11[0x2]
8000469c:	ba 4c       	st.h	sp[0x8],r12
	message here, and all will receive the same DEVICE_CONN_REPLY. Not real 
	sure what's going to happen with multiple conrol heads, etc. One suspects 
	the Rocket Scientists will eventually figure this out, and demand a 
	transaction ID based on Device Type in the XNL_DEVICE_AUTH_KEY_REQUEST.
	*/
	xnl_frame.xnl_header.source = xnl_information.device_address;
8000469e:	96 2b       	ld.sh	r11,r11[0x4]
800046a0:	ba 5b       	st.h	sp[0xa],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
800046a2:	ba 6a       	st.h	sp[0xc],r10
	
    /*his message contains 12 payload bytes*/	
	xnl_frame.xnl_header.payload_length = 0x000C;
800046a4:	30 ca       	mov	r10,12
800046a6:	ba 7a       	st.h	sp[0xe],r10
	
	/*No Preferred XNL Address*/
	xnl_frame.xnl_payload.xnl_content_device_conn_req.preferred_xnl_address = 
800046a8:	30 0a       	mov	r10,0
800046aa:	fb 5a 00 10 	st.h	sp[16],r10
	XCMP/XNL Development Specification Section 4.5.3.2.1.
	Same as in MOTOTRBO?XCMP/XNL Development Specification?
	evice_type--Option Board(0x07)
	authentication_index--Option Board(0x02)
	*/	
	xnl_frame.xnl_payload.xnl_content_device_conn_req.device_type = 0x07;
800046ae:	30 7a       	mov	r10,7
800046b0:	fb 6a 00 12 	st.b	sp[18],r10
	xnl_frame.xnl_payload.xnl_content_device_conn_req.authentication_index =
800046b4:	30 2a       	mov	r10,2
800046b6:	fb 6a 00 13 	st.b	sp[19],r10
	                                                                       0x02;
		
	//We know encrypted array happens to be aligned to 32-bit boundary.
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
800046ba:	fa ca ff ec 	sub	r10,sp,-20
800046be:	95 09       	st.w	r10[0x0],r9
	                         .encrypted_authentication_value[0])) = w_vector[0];
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
800046c0:	95 18       	st.w	r10[0x4],r8
	                         .encrypted_authentication_value[4])) = w_vector[1];
	
	/*send XNL message*/
	xnl_tx(&xnl_frame);
800046c2:	1a 9c       	mov	r12,sp
800046c4:	f0 1f 00 05 	mcall	800046d8 <xnl_device_auth_reply_func+0x11c>
}
800046c8:	2c 0d       	sub	sp,-256
800046ca:	d8 22       	popm	r4-r7,pc
800046cc:	00 00       	add	r0,r0
800046ce:	0b 2e       	ld.uh	lr,r5++
800046d0:	00 00       	add	r0,r0
800046d2:	0b 28       	ld.uh	r8,r5++
800046d4:	80 00       	ld.sh	r0,r0[0x0]
800046d6:	56 84       	stdsp	sp[0x1a0],r4
800046d8:	80 00       	ld.sh	r0,r0[0x0]
800046da:	43 a4       	lddsp	r4,sp[0xe8]

800046dc <xnl_master_status_brdcst_func>:
Description: process while receive master status boardcast.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_master_status_brdcst_func(xnl_fragment_t * xnl)
{	
800046dc:	eb cd 40 80 	pushm	r7,lr
800046e0:	fa cd 01 00 	sub	sp,sp,256
800046e4:	18 97       	mov	r7,r12
	not an XNL_DATA_MSG has been sent out. This will indicate to a connecting 
	device that it has missed messages. The XNL header will contain the 
	master?XNL address. 5.4.1
	*/
	
	if(xnl_information.is_connected)
800046e6:	49 28       	lddpc	r8,8000472c <xnl_master_status_brdcst_func+0x50>
800046e8:	11 88       	ld.ub	r8,r8[0x0]
800046ea:	58 08       	cp.w	r8,0
800046ec:	c1 c1       	brne	80004724 <xnl_master_status_brdcst_func+0x48>
	{
		return;	
	}
		
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);	
800046ee:	49 18       	lddpc	r8,80004730 <xnl_master_status_brdcst_func+0x54>
800046f0:	70 0c       	ld.w	r12,r8[0x0]
800046f2:	30 09       	mov	r9,0
800046f4:	12 9a       	mov	r10,r9
800046f6:	12 9b       	mov	r11,r9
800046f8:	f0 1f 00 0f 	mcall	80004734 <xnl_master_status_brdcst_func+0x58>

	//log("xnl-ma:%4x", xnl->xnl_header.source);
	/*get the master adderss from this message*/	
	xnl_information.master_address = xnl->xnl_header.source;	
800046fc:	8e 58       	ld.sh	r8,r7[0xa]
800046fe:	48 c9       	lddpc	r9,8000472c <xnl_master_status_brdcst_func+0x50>
80004700:	b2 18       	st.h	r9[0x2],r8
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80004702:	e0 68 40 0e 	mov	r8,16398
80004706:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004708:	3f f8       	mov	r8,-1
8000470a:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_AUTH_KEY_REQUEST;
8000470c:	30 4a       	mov	r10,4
8000470e:	ba 2a       	st.h	sp[0x4],r10
		
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/	
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
80004710:	ba 38       	st.h	sp[0x6],r8
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
80004712:	92 19       	ld.sh	r9,r9[0x2]
80004714:	ba 49       	st.h	sp[0x8],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.source = DEFAULT_VALUE;
80004716:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80004718:	ba 68       	st.h	sp[0xc],r8
		
	xnl_frame.xnl_header.payload_length = 0;
8000471a:	30 08       	mov	r8,0
8000471c:	ba 78       	st.h	sp[0xe],r8
	
	/*send XNL message*/	
	xnl_tx(&xnl_frame);
8000471e:	1a 9c       	mov	r12,sp
80004720:	f0 1f 00 06 	mcall	80004738 <xnl_master_status_brdcst_func+0x5c>
}
80004724:	2c 0d       	sub	sp,-256
80004726:	e3 cd 80 80 	ldm	sp++,r7,pc
8000472a:	00 00       	add	r0,r0
8000472c:	00 00       	add	r0,r0
8000472e:	0b 2e       	ld.uh	lr,r5++
80004730:	00 00       	add	r0,r0
80004732:	0b 28       	ld.uh	r8,r5++
80004734:	80 00       	ld.sh	r0,r0[0x0]
80004736:	56 84       	stdsp	sp[0x1a0],r4
80004738:	80 00       	ld.sh	r0,r0[0x0]
8000473a:	43 a4       	lddsp	r4,sp[0xe8]

8000473c <xnl_device_conn_reply_func>:
Description: process while receive device conn reply.
Calls:xSemaphoreGive--freestos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_conn_reply_func(xnl_fragment_t * xnl)
{
8000473c:	eb cd 40 80 	pushm	r7,lr
80004740:	18 97       	mov	r7,r12
	transaction ID and an 8-byte encrypted value that the device can use to 
	authenticate the master. XCMP/XNL Development Guide 5.4.6
	*/
	
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);
80004742:	49 38       	lddpc	r8,8000478c <xnl_device_conn_reply_func+0x50>
80004744:	70 0c       	ld.w	r12,r8[0x0]
80004746:	30 09       	mov	r9,0
80004748:	12 9a       	mov	r10,r9
8000474a:	12 9b       	mov	r11,r9
8000474c:	f0 1f 00 11 	mcall	80004790 <xnl_device_conn_reply_func+0x54>

	/*Test result code*/
	if((xnl->xnl_payload.xnl_content_device_conn_reply.result_base & 0x0000FF00)
80004750:	ef 18 00 10 	ld.uh	r8,r7[16]
80004754:	10 99       	mov	r9,r8
80004756:	e2 19 ff 00 	andl	r9,0xff00,COH
8000475a:	e0 49 01 00 	cp.w	r9,256
8000475e:	c0 60       	breq	8000476a <xnl_device_conn_reply_func+0x2e>
		/*
		Rejected. The device must retry the authentication process at this 
		point by sending out a new AUTH_KEY_REQUEST message. XCMP/XNL 
		Development Guide Section 5.2.3
		*/
		xnl_master_status_brdcst_func(xnl);			
80004760:	0e 9c       	mov	r12,r7
80004762:	f0 1f 00 0d 	mcall	80004794 <xnl_device_conn_reply_func+0x58>
80004766:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/*connection accepted*/		
		/*Record Transaction ID Base*/
		xnl_information.transaction_id =  
8000476a:	a9 68       	lsl	r8,0x8
8000476c:	48 b9       	lddpc	r9,80004798 <xnl_device_conn_reply_func+0x5c>
8000476e:	b2 48       	st.h	r9[0x8],r8
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
80004770:	ef 08 00 14 	ld.sh	r8,r7[20]
		xnl_information.transaction_id =  
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
80004774:	b2 38       	st.h	r9[0x6],r8
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
80004776:	ef 08 00 12 	ld.sh	r8,r7[18]
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
8000477a:	b2 28       	st.h	r9[0x4],r8
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
		
		/*connect finish*/
		xnl_information.is_connected = TRUE;
8000477c:	30 18       	mov	r8,1
8000477e:	b2 88       	st.b	r9[0x0],r8
		
		log("connected finish");
80004780:	48 7c       	lddpc	r12,8000479c <xnl_device_conn_reply_func+0x60>
80004782:	f0 1f 00 08 	mcall	800047a0 <xnl_device_conn_reply_func+0x64>
80004786:	e3 cd 80 80 	ldm	sp++,r7,pc
8000478a:	00 00       	add	r0,r0
8000478c:	00 00       	add	r0,r0
8000478e:	0b 28       	ld.uh	r8,r5++
80004790:	80 00       	ld.sh	r0,r0[0x0]
80004792:	56 84       	stdsp	sp[0x1a0],r4
80004794:	80 00       	ld.sh	r0,r0[0x0]
80004796:	46 dc       	lddsp	r12,sp[0x1b4]
80004798:	00 00       	add	r0,r0
8000479a:	0b 2e       	ld.uh	lr,r5++
8000479c:	80 00       	ld.sh	r0,r0[0x0]
8000479e:	cb d8       	rjmp	80004918 <tc_init+0x5c>
800047a0:	80 00       	ld.sh	r0,r0[0x0]
800047a2:	62 74       	ld.w	r4,r1[0x1c]

800047a4 <local_start_pll0>:
	//pm_switch_to_osc0(pm, 12000000, 3);
	//    pm_enable_osc0_crystal(pm, 12000000);
	//         pm_set_osc0_mode(pm,AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);  0x00000007
	//    pm_enable_clk0(pm, 3);
	//         pm_enable_clk0_no_wait(pm, 3);
	(&AVR32_PM)->oscctrl0 = 0x00000307;
800047a4:	fe 78 0c 00 	mov	r8,-62464
800047a8:	e0 69 03 07 	mov	r9,775
800047ac:	91 a9       	st.w	r8[0x28],r9
	(&AVR32_PM)->mcctrl   = 0x00000004;
800047ae:	30 49       	mov	r9,4
800047b0:	91 09       	st.w	r8[0x0],r9
	//         pm_wait_for_clk0_ready(pm);
	while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
800047b2:	71 59       	ld.w	r9,r8[0x54]
800047b4:	e2 19 00 80 	andl	r9,0x80,COH
800047b8:	cf d0       	breq	800047b2 <local_start_pll0+0xe>
	//    pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);
	(&AVR32_PM)->mcctrl   = 0x00000005;
800047ba:	fe 78 0c 00 	mov	r8,-62464
800047be:	30 59       	mov	r9,5
800047c0:	91 09       	st.w	r8[0x0],r9
	//pm_pll_set_option(pm, 0, //PLL number 0
	//                        1, //freq Set to 1 for VCO frequency range 80-180MHz
	//                        1, //div2 Divide the PLL output frequency by 2
	//                        0);//0 to enable the Wide-Bandith Mode
	//pm_pll_enable(pm,0);
	(&AVR32_PM)->pll[0] = 0x1007010D;
800047c2:	e0 69 01 0d 	mov	r9,269
800047c6:	ea 19 10 07 	orh	r9,0x1007
800047ca:	91 89       	st.w	r8[0x20],r9


	//pm_wait_for_pll0_locked(pm);
	while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_LOCK0_MASK));
800047cc:	71 59       	ld.w	r9,r8[0x54]
800047ce:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
800047d2:	cf d0       	breq	800047cc <local_start_pll0+0x28>
	//             0,  //Bus A select = 0 (PBA clock = 48MHz/2 = 24MHz).
	//             0,  //B clock divisor enable = 0
	//             0,  //Bus B select = 0
	//             0,  //HS Bus clock divisor enable = 0
	//             0); //HS Bus select = 0
	(&AVR32_PM)->cksel = 0x00800000;
800047d4:	fe 78 0c 00 	mov	r8,-62464
800047d8:	fc 19 00 80 	movh	r9,0x80
800047dc:	91 19       	st.w	r8[0x4],r9

	//flashc_set_wait_state(1);
	AVR32_FLASHC.fcr = 0x00000040;
800047de:	34 0a       	mov	r10,64
800047e0:	fe 69 14 00 	mov	r9,-125952
800047e4:	93 0a       	st.w	r9[0x0],r10

	//pm_switch_to_clock(pm, AVR32_PM_MCSEL_PLL0);
	(&AVR32_PM)->mcctrl   = 0x00000006;
800047e6:	30 69       	mov	r9,6
800047e8:	91 09       	st.w	r8[0x0],r9


	AVR32_HMATRIX.mcfg[AVR32_HMATRIX_MASTER_CPU_INSTRUCTION] = 0x1;
800047ea:	30 19       	mov	r9,1
800047ec:	fe 68 10 00 	mov	r8,-126976
800047f0:	91 19       	st.w	r8[0x4],r9
}
800047f2:	5e fc       	retal	r12

800047f4 <rtc_init>:
    PCF8563_init
Called By: ..
Return:rtc_err_t
*/
rtc_err_t rtc_init(void)
{
800047f4:	eb cd 40 c0 	pushm	r6-r7,lr
800047f8:	20 3d       	sub	sp,12
	/* Create the mutex semaphore to guard a shared RTC(TWI).*/	
	rtc_mutex = xSemaphoreCreateMutex();
800047fa:	f0 1f 00 1a 	mcall	80004860 <rtc_init+0x6c>
800047fe:	49 a8       	lddpc	r8,80004864 <rtc_init+0x70>
80004800:	91 0c       	st.w	r8[0x0],r12
	
	if(NULL != rtc_mutex)
80004802:	70 08       	ld.w	r8,r8[0x0]
80004804:	58 08       	cp.w	r8,0
80004806:	c0 31       	brne	8000480c <rtc_init+0x18>
80004808:	30 3c       	mov	r12,3
8000480a:	c2 78       	rjmp	80004858 <rtc_init+0x64>
	{
		/*See if we can obtain the semaphore. If the semaphore is not available wait aways to see if it becomes free*/
		xSemaphoreTake( rtc_mutex, portMAX_DELAY);
8000480c:	49 66       	lddpc	r6,80004864 <rtc_init+0x70>
8000480e:	6c 0c       	ld.w	r12,r6[0x0]
80004810:	30 09       	mov	r9,0
80004812:	3f fa       	mov	r10,-1
80004814:	12 9b       	mov	r11,r9
80004816:	f0 1f 00 15 	mcall	80004868 <rtc_init+0x74>
	
	/*twi_package_t packet, packet_received*/
	static int status;

	/*TWI gpio pins configuration*/	
	gpio_enable_module(TWI_GPIO_MAP, sizeof(TWI_GPIO_MAP) / sizeof(TWI_GPIO_MAP[0]));
8000481a:	30 2b       	mov	r11,2
8000481c:	49 4c       	lddpc	r12,8000486c <rtc_init+0x78>
8000481e:	f0 1f 00 15 	mcall	80004870 <rtc_init+0x7c>
	
	/* options settings*/
	opt.pba_hz = RTC_PBACLK_FREQ_HZ;//FOSC0;24Mhz
80004822:	e0 68 36 00 	mov	r8,13824
80004826:	ea 18 01 6e 	orh	r8,0x16e
8000482a:	50 08       	stdsp	sp[0x0],r8
	opt.speed  = TWI_SPEED;//200Khz
8000482c:	e2 78 0d 40 	mov	r8,200000
80004830:	50 18       	stdsp	sp[0x4],r8
	opt.chip   = PCF8563_ADDRESS;
80004832:	35 18       	mov	r8,81
80004834:	fb 68 00 08 	st.b	sp[8],r8

	/*initialize TWI driver with options*/
	status = twi_master_init(&AVR32_TWI, &opt);
80004838:	1a 9b       	mov	r11,sp
8000483a:	fe 7c 2c 00 	mov	r12,-54272
8000483e:	f0 1f 00 0e 	mcall	80004874 <rtc_init+0x80>
80004842:	48 e7       	lddpc	r7,80004878 <rtc_init+0x84>
80004844:	8f 0c       	st.w	r7[0x0],r12
	
	/*finished accessing the shared resource.Release the semaphore.*/
	xSemaphoreGive(rtc_mutex);		
80004846:	6c 0c       	ld.w	r12,r6[0x0]
80004848:	30 09       	mov	r9,0
8000484a:	12 9a       	mov	r10,r9
8000484c:	12 9b       	mov	r11,r9
8000484e:	f0 1f 00 0c 	mcall	8000487c <rtc_init+0x88>
80004852:	6e 08       	ld.w	r8,r7[0x0]
80004854:	58 08       	cp.w	r8,0
80004856:	5f 1c       	srne	r12
	{
		return rtc_success;
	}
		
	return rtc_init_err;
}
80004858:	2f dd       	sub	sp,-12
8000485a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000485e:	00 00       	add	r0,r0
80004860:	80 00       	ld.sh	r0,r0[0x0]
80004862:	57 84       	stdsp	sp[0x1e0],r4
80004864:	00 00       	add	r0,r0
80004866:	0b 50       	ld.sh	r0,--r5
80004868:	80 00       	ld.sh	r0,r0[0x0]
8000486a:	54 78       	stdsp	sp[0x11c],r8
8000486c:	80 00       	ld.sh	r0,r0[0x0]
8000486e:	cb ec       	rcall	800049ea <INTC_init_interrupts+0x2a>
80004870:	80 00       	ld.sh	r0,r0[0x0]
80004872:	67 0c       	ld.w	r12,r3[0x40]
80004874:	80 00       	ld.sh	r0,r0[0x0]
80004876:	4d 04       	lddpc	r4,800049b4 <INTC_register_interrupt+0x74>
80004878:	00 00       	add	r0,r0
8000487a:	0b 4c       	ld.w	r12,--r5
8000487c:	80 00       	ld.sh	r0,r0[0x0]
8000487e:	56 84       	stdsp	sp[0x1a0],r4

80004880 <local_start_timer>:
//	MAKO_RX					AVR32_SSC_RX_DATA_0_PIN				[39 PortB Pin  7 00000080 Func 0]
//
void local_start_timer(void)
{
	//Route CLK to Timer
	AVR32_GPIO.port[0].pmr0s = 0x00100000;
80004880:	fe 78 10 00 	mov	r8,-61440
80004884:	fc 19 00 10 	movh	r9,0x10
80004888:	91 59       	st.w	r8[0x14],r9
	AVR32_GPIO.port[0].pmr1c = 0x00100000;
8000488a:	91 a9       	st.w	r8[0x28],r9
	AVR32_GPIO.port[0].gperc = 0x00100000;
8000488c:	91 29       	st.w	r8[0x8],r9
	//Route FS and Tri-State to Timer.
	AVR32_GPIO.port[1].pmr0c = 0x00000003;
8000488e:	30 39       	mov	r9,3
80004890:	f1 49 01 18 	st.w	r8[280],r9
	AVR32_GPIO.port[1].pmr1c = 0x00000003;
80004894:	f1 49 01 28 	st.w	r8[296],r9
	AVR32_GPIO.port[1].gperc = 0x00000003;
80004898:	f1 49 01 08 	st.w	r8[264],r9

	(&AVR32_TC)->bmr = 4;
8000489c:	fe 78 38 00 	mov	r8,-51200
800048a0:	30 49       	mov	r9,4
800048a2:	f1 49 00 c4 	st.w	r8[196],r9
	(&AVR32_TC)->channel[0].cmr =
800048a6:	e0 69 91 0d 	mov	r9,37133
800048aa:	ea 19 00 52 	orh	r9,0x52
800048ae:	91 19       	st.w	r8[0x4],r9
	1                          << AVR32_TC_CLKI_OFFSET     |
	AVR32_TC_TCCLKS_XC0        << AVR32_TC_TCCLKS_OFFSET;



	(&AVR32_TC)->channel[0].ra = 32;
800048b0:	32 09       	mov	r9,32
800048b2:	91 59       	st.w	r8[0x14],r9
	(&AVR32_TC)->channel[0].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
800048b4:	30 59       	mov	r9,5
800048b6:	91 09       	st.w	r8[0x0],r9
}
800048b8:	5e fc       	retal	r12
800048ba:	d7 03       	nop

800048bc <tc_init>:
 * - fPBA/8 is used as clock source for TC
 * - Enables RC compare match interrupt
 * \param tc Base address of the TC module
 */
void tc_init()
{
800048bc:	d4 01       	pushm	lr

	volatile avr32_tc_t * tc = EXAMPLE_TC;
	
	INTC_register_interrupt(&_tc_interrupt, AVR32_TC_IRQ1, AVR32_INTC_INT2);
800048be:	30 2a       	mov	r10,2
800048c0:	e0 6b 01 c1 	mov	r11,449
800048c4:	48 ec       	lddpc	r12,800048fc <tc_init+0x40>
800048c6:	f0 1f 00 0f 	mcall	80004900 <tc_init+0x44>
		.cpas  = 0,
		.lovrs = 0,
		.covfs = 0
	};
	// Initialize the timer/counter.
	tc_init_waveform(tc, &waveform_opt);
800048ca:	48 fb       	lddpc	r11,80004904 <tc_init+0x48>
800048cc:	fe 7c 38 00 	mov	r12,-51200
800048d0:	f0 1f 00 0e 	mcall	80004908 <tc_init+0x4c>
	 * We want: (1 / (fPBA / 8)) * RC = 10 ms, hence RC = (fPBA / 8) / 100
	 * to get an interrupt every 10 ms.
	 */
	//tc_write_rc(tc, EXAMPLE_TC_CHANNEL, (sysclk_get_pba_hz() / 8 / 100));
	
	tc_write_rc(tc, EXAMPLE_TC_CHANNEL, ((FOSC0*2) / 8 / 100));
800048d4:	e0 6a 75 30 	mov	r10,30000
800048d8:	30 1b       	mov	r11,1
800048da:	fe 7c 38 00 	mov	r12,-51200
800048de:	f0 1f 00 0c 	mcall	8000490c <tc_init+0x50>
	
	//tc_write_rc(tc, EXAMPLE_TC_CHANNEL, (FOSC0 / 8 / 100000));
	
	
	// configure the timer interrupt
	tc_configure_interrupts(tc, EXAMPLE_TC_CHANNEL, &tc_interrupt);
800048e2:	48 ca       	lddpc	r10,80004910 <tc_init+0x54>
800048e4:	30 1b       	mov	r11,1
800048e6:	fe 7c 38 00 	mov	r12,-51200
800048ea:	f0 1f 00 0b 	mcall	80004914 <tc_init+0x58>
	// Start the timer/counter.
	tc_start(tc, EXAMPLE_TC_CHANNEL);
800048ee:	30 1b       	mov	r11,1
800048f0:	fe 7c 38 00 	mov	r12,-51200
800048f4:	f0 1f 00 09 	mcall	80004918 <tc_init+0x5c>
800048f8:	d8 02       	popm	pc
800048fa:	00 00       	add	r0,r0
800048fc:	80 00       	ld.sh	r0,r0[0x0]
800048fe:	49 1c       	lddpc	r12,80004940 <INTC_register_interrupt>
80004900:	80 00       	ld.sh	r0,r0[0x0]
80004902:	49 40       	lddpc	r0,80004950 <INTC_register_interrupt+0x10>
80004904:	80 00       	ld.sh	r0,r0[0x0]
80004906:	cc 00       	breq	80004886 <local_start_timer+0x6>
80004908:	80 00       	ld.sh	r0,r0[0x0]
8000490a:	4a 4c       	lddpc	r12,80004998 <INTC_register_interrupt+0x58>
8000490c:	80 00       	ld.sh	r0,r0[0x0]
8000490e:	4b 0c       	lddpc	r12,800049cc <INTC_init_interrupts+0xc>
80004910:	80 00       	ld.sh	r0,r0[0x0]
80004912:	cb fc       	rcall	80004a90 <tc_init_waveform+0x44>
80004914:	80 00       	ld.sh	r0,r0[0x0]
80004916:	4b 40       	lddpc	r0,800049e4 <INTC_init_interrupts+0x24>
80004918:	80 00       	ld.sh	r0,r0[0x0]
8000491a:	4a e8       	lddpc	r8,800049d0 <INTC_init_interrupts+0x10>

8000491c <_tc_interrupt>:
volatile U32 tc_tick = 0;

//brief Default interrupt handler.
__attribute__((__interrupt__))
static void _tc_interrupt(void)
 {
8000491c:	d4 01       	pushm	lr
	// Increment the 10ms seconds counter
	tc_tick++;
8000491e:	48 68       	lddpc	r8,80004934 <_tc_interrupt+0x18>
80004920:	70 09       	ld.w	r9,r8[0x0]
80004922:	2f f9       	sub	r9,-1
80004924:	91 09       	st.w	r8[0x0],r9
	/*
	 * TODO: Place a breakpoint here and watch the update of tc_tick variable
	 * in the Watch Window.
	 */
	// Clear the interrupt flag. This is a side effect of reading the TC SR.
	tc_read_sr(EXAMPLE_TC, EXAMPLE_TC_CHANNEL);
80004926:	30 1b       	mov	r11,1
80004928:	fe 7c 38 00 	mov	r12,-51200
8000492c:	f0 1f 00 03 	mcall	80004938 <_tc_interrupt+0x1c>
	
}
80004930:	d4 02       	popm	lr
80004932:	d6 03       	rete
80004934:	00 00       	add	r0,r0
80004936:	0b 54       	ld.sh	r4,--r5
80004938:	80 00       	ld.sh	r0,r0[0x0]
8000493a:	4a fa       	lddpc	r10,800049f4 <INTC_init_interrupts+0x34>

8000493c <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
8000493c:	c0 08       	rjmp	8000493c <_unhandled_interrupt>
8000493e:	d7 03       	nop

80004940 <INTC_register_interrupt>:
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
80004940:	f6 08 16 05 	lsr	r8,r11,0x5

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
80004944:	49 99       	lddpc	r9,800049a8 <INTC_register_interrupt+0x68>
80004946:	f2 08 00 39 	add	r9,r9,r8<<0x3
8000494a:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
8000494e:	72 19       	ld.w	r9,r9[0x4]
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
80004950:	f2 0b 09 2c 	st.w	r9[r11<<0x2],r12
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
80004954:	58 0a       	cp.w	r10,0
80004956:	c0 91       	brne	80004968 <INTC_register_interrupt+0x28>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80004958:	49 59       	lddpc	r9,800049ac <INTC_register_interrupt+0x6c>
8000495a:	49 6a       	lddpc	r10,800049b0 <INTC_register_interrupt+0x70>
8000495c:	12 1a       	sub	r10,r9
8000495e:	fe 79 08 00 	mov	r9,-63488
80004962:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80004966:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT1) {
80004968:	58 1a       	cp.w	r10,1
8000496a:	c0 a1       	brne	8000497e <INTC_register_interrupt+0x3e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
8000496c:	49 09       	lddpc	r9,800049ac <INTC_register_interrupt+0x6c>
8000496e:	49 2a       	lddpc	r10,800049b4 <INTC_register_interrupt+0x74>
80004970:	12 1a       	sub	r10,r9
80004972:	bf aa       	sbr	r10,0x1e
80004974:	fe 79 08 00 	mov	r9,-63488
80004978:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
8000497c:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT2) {
8000497e:	58 2a       	cp.w	r10,2
80004980:	c0 a1       	brne	80004994 <INTC_register_interrupt+0x54>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
80004982:	48 b9       	lddpc	r9,800049ac <INTC_register_interrupt+0x6c>
80004984:	48 da       	lddpc	r10,800049b8 <INTC_register_interrupt+0x78>
80004986:	12 1a       	sub	r10,r9
80004988:	bf ba       	sbr	r10,0x1f
8000498a:	fe 79 08 00 	mov	r9,-63488
8000498e:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80004992:	5e fc       	retal	r12
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
80004994:	48 69       	lddpc	r9,800049ac <INTC_register_interrupt+0x6c>
80004996:	48 aa       	lddpc	r10,800049bc <INTC_register_interrupt+0x7c>
80004998:	12 1a       	sub	r10,r9
8000499a:	ea 1a c0 00 	orh	r10,0xc000
8000499e:	fe 79 08 00 	mov	r9,-63488
800049a2:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800049a6:	5e fc       	retal	r12
800049a8:	80 00       	ld.sh	r0,r0[0x0]
800049aa:	cc 08       	rjmp	80004b2a <tc_write_rc+0x1e>
800049ac:	80 00       	ld.sh	r0,r0[0x0]
800049ae:	c2 00       	breq	800049ee <INTC_init_interrupts+0x2e>
800049b0:	80 00       	ld.sh	r0,r0[0x0]
800049b2:	c3 04       	brge	80004a12 <INTC_init_interrupts+0x52>
800049b4:	80 00       	ld.sh	r0,r0[0x0]
800049b6:	c3 12       	brcc	80004a18 <_get_interrupt_handler+0x4>
800049b8:	80 00       	ld.sh	r0,r0[0x0]
800049ba:	c3 20       	breq	80004a1e <_get_interrupt_handler+0xa>
800049bc:	80 00       	ld.sh	r0,r0[0x0]
800049be:	c3 2e       	rcall	80004622 <xnl_device_auth_reply_func+0x66>

800049c0 <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
800049c0:	d4 21       	pushm	r4-r7,lr
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
800049c2:	49 18       	lddpc	r8,80004a04 <INTC_init_interrupts+0x44>
800049c4:	e3 b8 00 01 	mtsr	0x4,r8
800049c8:	49 0e       	lddpc	lr,80004a08 <INTC_init_interrupts+0x48>
800049ca:	30 07       	mov	r7,0
800049cc:	0e 94       	mov	r4,r7
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
800049ce:	49 0c       	lddpc	r12,80004a0c <INTC_init_interrupts+0x4c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
800049d0:	49 05       	lddpc	r5,80004a10 <INTC_init_interrupts+0x50>
800049d2:	10 15       	sub	r5,r8
800049d4:	fe 76 08 00 	mov	r6,-63488
800049d8:	c1 08       	rjmp	800049f8 <INTC_init_interrupts+0x38>
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
800049da:	08 98       	mov	r8,r4
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
800049dc:	7c 1b       	ld.w	r11,lr[0x4]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
800049de:	7c 0a       	ld.w	r10,lr[0x0]
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
800049e0:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
800049e4:	2f f8       	sub	r8,-1

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
800049e6:	10 3a       	cp.w	r10,r8
800049e8:	fe 9b ff fc 	brhi	800049e0 <INTC_init_interrupts+0x20>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
800049ec:	ec 07 09 25 	st.w	r6[r7<<0x2],r5
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
800049f0:	2f f7       	sub	r7,-1
800049f2:	2f 8e       	sub	lr,-8
800049f4:	59 37       	cp.w	r7,19
800049f6:	c0 50       	breq	80004a00 <INTC_init_interrupts+0x40>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
800049f8:	7c 08       	ld.w	r8,lr[0x0]
800049fa:	58 08       	cp.w	r8,0
800049fc:	ce f1       	brne	800049da <INTC_init_interrupts+0x1a>
800049fe:	cf 7b       	rjmp	800049ec <INTC_init_interrupts+0x2c>
80004a00:	d8 22       	popm	r4-r7,pc
80004a02:	00 00       	add	r0,r0
80004a04:	80 00       	ld.sh	r0,r0[0x0]
80004a06:	c2 00       	breq	80004a46 <_get_interrupt_handler+0x32>
80004a08:	80 00       	ld.sh	r0,r0[0x0]
80004a0a:	cc 08       	rjmp	80004b8a <tc_configure_interrupts+0x4a>
80004a0c:	80 00       	ld.sh	r0,r0[0x0]
80004a0e:	49 3c       	lddpc	r12,80004a58 <tc_init_waveform+0xc>
80004a10:	80 00       	ld.sh	r0,r0[0x0]
80004a12:	c3 04       	brge	80004a72 <tc_init_waveform+0x26>

80004a14 <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
80004a14:	fe 78 08 00 	mov	r8,-63488
80004a18:	e0 69 00 83 	mov	r9,131
80004a1c:	f2 0c 01 0c 	sub	r12,r9,r12
80004a20:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
80004a24:	f2 ca ff c0 	sub	r10,r9,-64
80004a28:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	
	return (int_req)
80004a2c:	58 08       	cp.w	r8,0
80004a2e:	c0 21       	brne	80004a32 <_get_interrupt_handler+0x1e>
80004a30:	5e fd       	retal	0
		? _int_handler_table[int_grp]._int_line_handler_table[32
80004a32:	f0 08 12 00 	clz	r8,r8
80004a36:	48 5a       	lddpc	r10,80004a48 <_get_interrupt_handler+0x34>
80004a38:	f4 09 00 39 	add	r9,r10,r9<<0x3
80004a3c:	f0 08 11 1f 	rsub	r8,r8,31
80004a40:	72 19       	ld.w	r9,r9[0x4]
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	
	return (int_req)
80004a42:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
80004a46:	5e fc       	retal	r12
80004a48:	80 00       	ld.sh	r0,r0[0x0]
80004a4a:	cc 08       	rjmp	80004bca <tc_configure_interrupts+0x8a>

80004a4c <tc_init_waveform>:


int tc_init_waveform(volatile avr32_tc_t *tc, const tc_waveform_opt_t *opt)
{
  // Check for valid input.
  if (opt->channel >= TC_NUMBER_OF_CHANNELS)
80004a4c:	76 09       	ld.w	r9,r11[0x0]
80004a4e:	58 29       	cp.w	r9,2
80004a50:	e0 88 00 03 	brls	80004a56 <tc_init_waveform+0xa>
80004a54:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  // GENERATE SIGNALS: Waveform operating mode.
  tc->channel[opt->channel].cmr = opt->bswtrg << AVR32_TC_BSWTRG_OFFSET |
80004a56:	76 18       	ld.w	r8,r11[0x4]
80004a58:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
80004a5c:	af ba       	sbr	r10,0xf
80004a5e:	10 9b       	mov	r11,r8
80004a60:	e6 1b c0 00 	andh	r11,0xc000,COH
80004a64:	16 4a       	or	r10,r11
80004a66:	10 9b       	mov	r11,r8
80004a68:	e6 1b 30 00 	andh	r11,0x3000,COH
80004a6c:	16 4a       	or	r10,r11
80004a6e:	10 9b       	mov	r11,r8
80004a70:	e6 1b 0c 00 	andh	r11,0xc00,COH
80004a74:	16 4a       	or	r10,r11
80004a76:	10 9b       	mov	r11,r8
80004a78:	e6 1b 03 00 	andh	r11,0x300,COH
80004a7c:	16 4a       	or	r10,r11
80004a7e:	10 9b       	mov	r11,r8
80004a80:	e6 1b 00 c0 	andh	r11,0xc0,COH
80004a84:	16 4a       	or	r10,r11
80004a86:	10 9b       	mov	r11,r8
80004a88:	e6 1b 00 30 	andh	r11,0x30,COH
80004a8c:	16 4a       	or	r10,r11
80004a8e:	10 9b       	mov	r11,r8
80004a90:	e6 1b 00 0c 	andh	r11,0xc,COH
80004a94:	16 4a       	or	r10,r11
80004a96:	10 9b       	mov	r11,r8
80004a98:	e6 1b 00 03 	andh	r11,0x3,COH
80004a9c:	16 4a       	or	r10,r11
80004a9e:	10 9b       	mov	r11,r8
80004aa0:	e2 1b 60 00 	andl	r11,0x6000,COH
80004aa4:	16 4a       	or	r10,r11
80004aa6:	f7 d8 c1 81 	bfextu	r11,r8,0xc,0x1
80004aaa:	f5 eb 10 ca 	or	r10,r10,r11<<0xc
80004aae:	10 9b       	mov	r11,r8
80004ab0:	e2 1b 0c 00 	andl	r11,0xc00,COH
80004ab4:	16 4a       	or	r10,r11
80004ab6:	10 9b       	mov	r11,r8
80004ab8:	e2 1b 03 00 	andl	r11,0x300,COH
80004abc:	16 4a       	or	r10,r11
80004abe:	f7 d8 c0 e1 	bfextu	r11,r8,0x7,0x1
80004ac2:	f5 eb 10 7a 	or	r10,r10,r11<<0x7
80004ac6:	f7 d8 c0 c1 	bfextu	r11,r8,0x6,0x1
80004aca:	f5 eb 10 6a 	or	r10,r10,r11<<0x6
80004ace:	10 9b       	mov	r11,r8
80004ad0:	e2 1b 00 30 	andl	r11,0x30,COH
80004ad4:	16 4a       	or	r10,r11
80004ad6:	f1 d8 c0 61 	bfextu	r8,r8,0x3,0x1
80004ada:	f5 e8 10 38 	or	r8,r10,r8<<0x3
80004ade:	a5 69       	lsl	r9,0x4
80004ae0:	2f f9       	sub	r9,-1
80004ae2:	f8 09 09 28 	st.w	r12[r9<<0x2],r8
80004ae6:	5e fd       	retal	0

80004ae8 <tc_start>:


int tc_start(volatile avr32_tc_t *tc, unsigned int channel)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80004ae8:	58 2b       	cp.w	r11,2
80004aea:	e0 88 00 03 	brls	80004af0 <tc_start+0x8>
80004aee:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  // Enable, reset and start the selected timer/counter channel.
  tc->channel[channel].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
80004af0:	a7 6b       	lsl	r11,0x6
80004af2:	16 0c       	add	r12,r11
80004af4:	30 58       	mov	r8,5
80004af6:	99 08       	st.w	r12[0x0],r8
80004af8:	5e fd       	retal	0

80004afa <tc_read_sr>:


int tc_read_sr(volatile avr32_tc_t *tc, unsigned int channel)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80004afa:	58 2b       	cp.w	r11,2
80004afc:	e0 88 00 03 	brls	80004b02 <tc_read_sr+0x8>
80004b00:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  return tc->channel[channel].sr;
80004b02:	a7 6b       	lsl	r11,0x6
80004b04:	2e 0b       	sub	r11,-32
80004b06:	16 0c       	add	r12,r11
80004b08:	78 0c       	ld.w	r12,r12[0x0]
}
80004b0a:	5e fc       	retal	r12

80004b0c <tc_write_rc>:


int tc_write_rc(volatile avr32_tc_t *tc, unsigned int channel, unsigned short value)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80004b0c:	58 2b       	cp.w	r11,2
80004b0e:	e0 88 00 03 	brls	80004b14 <tc_write_rc+0x8>
80004b12:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  // This function is only available in WAVEFORM mode.
  if (Tst_bits(tc->channel[channel].cmr, AVR32_TC_WAVE_MASK))
80004b14:	f6 08 15 04 	lsl	r8,r11,0x4
80004b18:	2f f8       	sub	r8,-1
80004b1a:	f8 08 03 28 	ld.w	r8,r12[r8<<0x2]
80004b1e:	e2 18 80 00 	andl	r8,0x8000,COH
80004b22:	c0 c0       	breq	80004b3a <tc_write_rc+0x2e>
    Wr_bitfield(tc->channel[channel].rc, AVR32_TC_RC_MASK, value);
80004b24:	a7 6b       	lsl	r11,0x6
80004b26:	16 0c       	add	r12,r11
80004b28:	2e 4c       	sub	r12,-28
80004b2a:	78 08       	ld.w	r8,r12[0x0]
80004b2c:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
80004b30:	e0 18 00 00 	andl	r8,0x0
80004b34:	f3 e8 10 08 	or	r8,r9,r8
80004b38:	99 08       	st.w	r12[0x0],r8

  return value;
80004b3a:	f9 da c0 10 	bfextu	r12,r10,0x0,0x10
}
80004b3e:	5e fc       	retal	r12

80004b40 <tc_configure_interrupts>:
  return tc->channel[channel].imr;
}


int tc_configure_interrupts(volatile avr32_tc_t *tc, unsigned int channel, const tc_interrupt_t *bitfield)
{
80004b40:	eb cd 40 fc 	pushm	r2-r7,lr
  bool global_interrupt_enabled = Is_global_interrupt_enabled();
80004b44:	e1 b9 00 00 	mfsr	r9,0x0

  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80004b48:	58 2b       	cp.w	r11,2
80004b4a:	e0 88 00 04 	brls	80004b52 <tc_configure_interrupts+0x12>
80004b4e:	e3 cf c0 fc 	ldm	sp++,r2-r7,pc,r12=-1
	return flags;
}

static inline bool cpu_irq_is_enabled_flags(irqflags_t flags)
{
	return !(flags & AVR32_SR_GM_MASK);
80004b52:	ee 19 00 01 	eorh	r9,0x1
80004b56:	f3 d9 c2 01 	bfextu	r9,r9,0x10,0x1
    return TC_INVALID_ARGUMENT;

  // Enable the appropriate interrupts.
  tc->channel[channel].ier = bitfield->etrgs << AVR32_TC_ETRGS_OFFSET |
80004b5a:	74 08       	ld.w	r8,r10[0x0]
80004b5c:	ef d8 c0 e1 	bfextu	r7,r8,0x7,0x1
80004b60:	fd d8 c0 c1 	bfextu	lr,r8,0x6,0x1
80004b64:	a7 6e       	lsl	lr,0x6
80004b66:	fd e7 10 7e 	or	lr,lr,r7<<0x7
80004b6a:	ef d8 c0 01 	bfextu	r7,r8,0x0,0x1
80004b6e:	0e 4e       	or	lr,r7
80004b70:	ef d8 c0 a1 	bfextu	r7,r8,0x5,0x1
80004b74:	fd e7 10 5e 	or	lr,lr,r7<<0x5
80004b78:	ef d8 c0 81 	bfextu	r7,r8,0x4,0x1
80004b7c:	fd e7 10 4e 	or	lr,lr,r7<<0x4
80004b80:	ef d8 c0 61 	bfextu	r7,r8,0x3,0x1
80004b84:	fd e7 10 3e 	or	lr,lr,r7<<0x3
80004b88:	ef d8 c0 41 	bfextu	r7,r8,0x2,0x1
80004b8c:	fd e7 10 2e 	or	lr,lr,r7<<0x2
80004b90:	f1 d8 c0 21 	bfextu	r8,r8,0x1,0x1
80004b94:	fd e8 10 18 	or	r8,lr,r8<<0x1
80004b98:	f6 0e 15 06 	lsl	lr,r11,0x6
80004b9c:	f8 0e 00 0e 	add	lr,r12,lr
80004ba0:	2d ce       	sub	lr,-36
80004ba2:	9d 08       	st.w	lr[0x0],r8
                             bitfield->cpas << AVR32_TC_CPAS_OFFSET |
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;

  // Disable the appropriate interrupts.
  if (global_interrupt_enabled) Disable_global_interrupt();
80004ba4:	58 09       	cp.w	r9,0
80004ba6:	c0 20       	breq	80004baa <tc_configure_interrupts+0x6a>
80004ba8:	d3 03       	ssrf	0x10
  tc->channel[channel].idr = (~bitfield->etrgs & 1) << AVR32_TC_ETRGS_OFFSET |
80004baa:	74 08       	ld.w	r8,r10[0x0]
80004bac:	f1 d8 c0 e1 	bfextu	r8,r8,0x7,0x1
80004bb0:	e0 65 00 80 	mov	r5,128
80004bb4:	f9 b5 01 00 	movne	r5,0
                             (~bitfield->ldrbs & 1) << AVR32_TC_LDRBS_OFFSET |
80004bb8:	74 08       	ld.w	r8,r10[0x0]
80004bba:	f1 d8 c0 c1 	bfextu	r8,r8,0x6,0x1
80004bbe:	f9 b4 00 40 	moveq	r4,64
80004bc2:	f9 b4 01 00 	movne	r4,0
                             (~bitfield->ldras & 1) << AVR32_TC_LDRAS_OFFSET |
80004bc6:	74 08       	ld.w	r8,r10[0x0]
80004bc8:	f1 d8 c0 a1 	bfextu	r8,r8,0x5,0x1
80004bcc:	f9 b3 00 20 	moveq	r3,32
80004bd0:	f9 b3 01 00 	movne	r3,0
                             (~bitfield->cpcs & 1) << AVR32_TC_CPCS_OFFSET |
80004bd4:	74 08       	ld.w	r8,r10[0x0]
80004bd6:	f1 d8 c0 81 	bfextu	r8,r8,0x4,0x1
80004bda:	f9 b2 00 10 	moveq	r2,16
80004bde:	f9 b2 01 00 	movne	r2,0
                             (~bitfield->cpbs & 1) << AVR32_TC_CPBS_OFFSET |
80004be2:	74 08       	ld.w	r8,r10[0x0]
80004be4:	f1 d8 c0 61 	bfextu	r8,r8,0x3,0x1
80004be8:	f9 b6 00 08 	moveq	r6,8
80004bec:	f9 b6 01 00 	movne	r6,0
                             (~bitfield->cpas & 1) << AVR32_TC_CPAS_OFFSET |
80004bf0:	74 08       	ld.w	r8,r10[0x0]
80004bf2:	f1 d8 c0 41 	bfextu	r8,r8,0x2,0x1
80004bf6:	f9 b7 00 04 	moveq	r7,4
80004bfa:	f9 b7 01 00 	movne	r7,0
                             (~bitfield->lovrs & 1) << AVR32_TC_LOVRS_OFFSET |
80004bfe:	74 08       	ld.w	r8,r10[0x0]
80004c00:	f1 d8 c0 21 	bfextu	r8,r8,0x1,0x1
80004c04:	f9 be 00 02 	moveq	lr,2
80004c08:	f9 be 01 00 	movne	lr,0
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;

  // Disable the appropriate interrupts.
  if (global_interrupt_enabled) Disable_global_interrupt();
  tc->channel[channel].idr = (~bitfield->etrgs & 1) << AVR32_TC_ETRGS_OFFSET |
80004c0c:	74 08       	ld.w	r8,r10[0x0]
80004c0e:	ec 18 00 01 	eorl	r8,0x1
80004c12:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80004c16:	eb e8 10 08 	or	r8,r5,r8
80004c1a:	08 48       	or	r8,r4
80004c1c:	06 48       	or	r8,r3
80004c1e:	04 48       	or	r8,r2
80004c20:	0c 48       	or	r8,r6
80004c22:	0e 48       	or	r8,r7
80004c24:	1c 48       	or	r8,lr
80004c26:	f6 0a 15 06 	lsl	r10,r11,0x6
80004c2a:	f8 0a 00 0a 	add	r10,r12,r10
80004c2e:	2d 8a       	sub	r10,-40
80004c30:	95 08       	st.w	r10[0x0],r8
                             (~bitfield->cpcs & 1) << AVR32_TC_CPCS_OFFSET |
                             (~bitfield->cpbs & 1) << AVR32_TC_CPBS_OFFSET |
                             (~bitfield->cpas & 1) << AVR32_TC_CPAS_OFFSET |
                             (~bitfield->lovrs & 1) << AVR32_TC_LOVRS_OFFSET |
                             (~bitfield->covfs & 1) << AVR32_TC_COVFS_OFFSET;
  tc->channel[channel].sr;
80004c32:	a7 6b       	lsl	r11,0x6
80004c34:	2e 0b       	sub	r11,-32
80004c36:	16 0c       	add	r12,r11
80004c38:	78 08       	ld.w	r8,r12[0x0]
  if (global_interrupt_enabled) Enable_global_interrupt();
80004c3a:	58 09       	cp.w	r9,0
80004c3c:	c0 31       	brne	80004c42 <tc_configure_interrupts+0x102>
80004c3e:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0
80004c42:	d5 03       	csrf	0x10
80004c44:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0

80004c48 <twi_master_interrupt_handler>:
/*! \brief TWI interrupt handler.
 */
ISR(twi_master_interrupt_handler, CONF_TWI_IRQ_GROUP, CONF_TWI_IRQ_LEVEL)
{
	// get masked status register value
	int status = twi_inst->sr & twi_it_mask;
80004c48:	4a 78       	lddpc	r8,80004ce4 <twi_master_interrupt_handler+0x9c>
80004c4a:	70 08       	ld.w	r8,r8[0x0]
80004c4c:	70 89       	ld.w	r9,r8[0x20]
80004c4e:	4a 7a       	lddpc	r10,80004ce8 <twi_master_interrupt_handler+0xa0>
80004c50:	74 0a       	ld.w	r10,r10[0x0]
80004c52:	f5 e9 00 09 	and	r9,r10,r9

	// this is a NACK
	if (status & AVR32_TWI_SR_NACK_MASK) {
80004c56:	12 9a       	mov	r10,r9
80004c58:	e2 1a 01 00 	andl	r10,0x100,COH
80004c5c:	c3 91       	brne	80004cce <twi_master_interrupt_handler+0x86>
		goto nack;
	}
	// this is a RXRDY
	else if (status & AVR32_TWI_SR_RXRDY_MASK) {
80004c5e:	12 9a       	mov	r10,r9
80004c60:	e2 1a 00 02 	andl	r10,0x2,COH
80004c64:	c1 70       	breq	80004c92 <twi_master_interrupt_handler+0x4a>
		// get data from Receive Holding Register
		*twi_rx_data = twi_inst->rhr;
80004c66:	4a 29       	lddpc	r9,80004cec <twi_master_interrupt_handler+0xa4>
80004c68:	72 0a       	ld.w	r10,r9[0x0]
80004c6a:	70 cb       	ld.w	r11,r8[0x30]
80004c6c:	b4 8b       	st.b	r10[0x0],r11
		twi_rx_data++;
80004c6e:	72 0a       	ld.w	r10,r9[0x0]
80004c70:	2f fa       	sub	r10,-1
80004c72:	93 0a       	st.w	r9[0x0],r10
		// last byte to receive
		if (--twi_rx_nb_bytes == 1) {
80004c74:	49 f9       	lddpc	r9,80004cf0 <twi_master_interrupt_handler+0xa8>
80004c76:	72 0a       	ld.w	r10,r9[0x0]
80004c78:	20 1a       	sub	r10,1
80004c7a:	93 0a       	st.w	r9[0x0],r10
80004c7c:	72 09       	ld.w	r9,r9[0x0]
			// set stop bit
			twi_inst->cr = AVR32_TWI_STOP_MASK;
80004c7e:	58 19       	cp.w	r9,1
80004c80:	f9 b9 00 02 	moveq	r9,2
80004c84:	f1 f9 0a 00 	st.weq	r8[0x0],r9
		}
		// receive complete
		if (twi_rx_nb_bytes == 0) {
80004c88:	49 a9       	lddpc	r9,80004cf0 <twi_master_interrupt_handler+0xa8>
80004c8a:	72 09       	ld.w	r9,r9[0x0]
80004c8c:	58 09       	cp.w	r9,0
80004c8e:	c2 30       	breq	80004cd4 <twi_master_interrupt_handler+0x8c>
80004c90:	d6 03       	rete
			// finish the receive operation
			goto complete;
		}
	}
	// this is a TXRDY
	else if (status & AVR32_TWI_SR_TXRDY_MASK) {
80004c92:	12 9a       	mov	r10,r9
80004c94:	e2 1a 00 04 	andl	r10,0x4,COH
80004c98:	c1 70       	breq	80004cc6 <twi_master_interrupt_handler+0x7e>
		// decrease transmitted bytes number
		twi_tx_nb_bytes--;
80004c9a:	49 79       	lddpc	r9,80004cf4 <twi_master_interrupt_handler+0xac>
80004c9c:	72 0a       	ld.w	r10,r9[0x0]
80004c9e:	20 1a       	sub	r10,1
80004ca0:	93 0a       	st.w	r9[0x0],r10
		// no more bytes to transmit
		if (twi_tx_nb_bytes <= 0) {
80004ca2:	72 09       	ld.w	r9,r9[0x0]
80004ca4:	58 09       	cp.w	r9,0
80004ca6:	e0 89 00 0a 	brgt	80004cba <twi_master_interrupt_handler+0x72>
			// enable TXCOMP IT and unmask all others IT
			twi_it_mask = AVR32_TWI_IER_TXCOMP_MASK;
80004caa:	49 09       	lddpc	r9,80004ce8 <twi_master_interrupt_handler+0xa0>
80004cac:	30 1a       	mov	r10,1
80004cae:	93 0a       	st.w	r9[0x0],r10
			twi_inst->idr = ~0UL;
80004cb0:	3f fa       	mov	r10,-1
80004cb2:	91 aa       	st.w	r8[0x28],r10
			twi_inst->ier = twi_it_mask;
80004cb4:	72 09       	ld.w	r9,r9[0x0]
80004cb6:	91 99       	st.w	r8[0x24],r9
80004cb8:	d6 03       	rete
		} else {
			// put the byte in the Transmit Holding Register
			twi_inst->thr = *twi_tx_data++;
80004cba:	49 0a       	lddpc	r10,80004cf8 <twi_master_interrupt_handler+0xb0>
80004cbc:	74 09       	ld.w	r9,r10[0x0]
80004cbe:	13 3b       	ld.ub	r11,r9++
80004cc0:	91 db       	st.w	r8[0x34],r11
80004cc2:	95 09       	st.w	r10[0x0],r9
80004cc4:	d6 03       	rete
		}
	}
	// this is a TXCOMP
	else if (status & AVR32_TWI_SR_TXCOMP_MASK) {
80004cc6:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
80004cca:	c0 51       	brne	80004cd4 <twi_master_interrupt_handler+0x8c>
80004ccc:	d6 03       	rete
	}

	return;

nack:
	twi_nack = true;
80004cce:	30 1a       	mov	r10,1
80004cd0:	48 b9       	lddpc	r9,80004cfc <twi_master_interrupt_handler+0xb4>
80004cd2:	b2 8a       	st.b	r9[0x0],r10

complete:
	// disable all interrupts
	twi_inst->idr = ~0UL;
80004cd4:	3f f9       	mov	r9,-1
80004cd6:	91 a9       	st.w	r8[0x28],r9
	twi_inst->sr;
80004cd8:	70 88       	ld.w	r8,r8[0x20]
	twi_busy = false;
80004cda:	30 09       	mov	r9,0
80004cdc:	48 98       	lddpc	r8,80004d00 <twi_master_interrupt_handler+0xb8>
80004cde:	b0 89       	st.b	r8[0x0],r9
80004ce0:	d6 03       	rete
80004ce2:	00 00       	add	r0,r0
80004ce4:	00 00       	add	r0,r0
80004ce6:	0c 0c       	add	r12,r6
80004ce8:	00 00       	add	r0,r0
80004cea:	0c 08       	add	r8,r6
80004cec:	00 00       	add	r0,r0
80004cee:	0c 18       	sub	r8,r6
80004cf0:	00 00       	add	r0,r0
80004cf2:	0c 14       	sub	r4,r6
80004cf4:	00 00       	add	r0,r0
80004cf6:	0c 04       	add	r4,r6
80004cf8:	00 00       	add	r0,r0
80004cfa:	0c 10       	sub	r0,r6
80004cfc:	00 00       	add	r0,r0
80004cfe:	0c 01       	add	r1,r6
80004d00:	00 00       	add	r0,r0
80004d02:	0c 00       	add	r0,r6

80004d04 <twi_master_init>:
	return TWI_SUCCESS;
}


int twi_master_init(volatile avr32_twi_t *twi, const twi_options_t *opt)
{
80004d04:	eb cd 40 e0 	pushm	r5-r7,lr
80004d08:	18 97       	mov	r7,r12
80004d0a:	16 95       	mov	r5,r11
	irqflags_t flags = sysreg_read(AVR32_SR);
80004d0c:	e1 b8 00 00 	mfsr	r8,0x0
	int status = TWI_SUCCESS;

	// Set pointer to TWIM instance for IT
	twi_inst = twi;
80004d10:	49 f9       	lddpc	r9,80004d8c <twi_master_init+0x88>
80004d12:	93 0c       	st.w	r9[0x0],r12

	// Disable TWI interrupts
	cpu_irq_disable();
80004d14:	d3 03       	ssrf	0x10
	twi->idr = ~0UL;
80004d16:	3f f9       	mov	r9,-1
80004d18:	99 a9       	st.w	r12[0x28],r9
	twi->sr;
80004d1a:	78 89       	ld.w	r9,r12[0x20]

	// Reset TWI
	twi->cr = AVR32_TWI_CR_SWRST_MASK;
80004d1c:	e0 69 00 80 	mov	r9,128
80004d20:	99 09       	st.w	r12[0x0],r9
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80004d22:	e6 18 00 01 	andh	r8,0x1,COH
80004d26:	c0 21       	brne	80004d2a <twi_master_init+0x26>
      cpu_irq_enable();
80004d28:	d5 03       	csrf	0x10
	cpu_irq_restore(flags);

	// Dummy read in SR
	twi->sr;
80004d2a:	6e 88       	ld.w	r8,r7[0x20]

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80004d2c:	e1 b6 00 00 	mfsr	r6,0x0
	cpu_irq_disable();
80004d30:	d3 03       	ssrf	0x10
	
	// register Register twim_master_interrupt_handler interrupt
	// on level CONF_TWI_IRQ_LEVEL
	flags = cpu_irq_save();

	irq_register_handler(&twi_master_interrupt_handler, CONF_TWI_IRQ_LINE, CONF_TWI_IRQ_LEVEL);
80004d32:	30 3a       	mov	r10,3
80004d34:	e0 6b 01 60 	mov	r11,352
80004d38:	49 6c       	lddpc	r12,80004d90 <twi_master_init+0x8c>
80004d3a:	f0 1f 00 17 	mcall	80004d94 <twi_master_init+0x90>
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80004d3e:	e6 16 00 01 	andh	r6,0x1,COH
80004d42:	c0 21       	brne	80004d46 <twi_master_init+0x42>
      cpu_irq_enable();
80004d44:	d5 03       	csrf	0x10
		unsigned long pba_hz)
{
	unsigned int ckdiv = 0;
	unsigned int c_lh_div;

	c_lh_div = pba_hz / (speed * 2) - 4;
80004d46:	6a 19       	ld.w	r9,r5[0x4]
80004d48:	a1 79       	lsl	r9,0x1
80004d4a:	6a 08       	ld.w	r8,r5[0x0]
80004d4c:	f0 09 0d 08 	divu	r8,r8,r9
80004d50:	20 48       	sub	r8,4

	// cldiv must fit in 8 bits, ckdiv must fit in 3 bits
	while ((c_lh_div > 0xFF) && (ckdiv < 0x7)) {
80004d52:	e0 48 00 ff 	cp.w	r8,255
80004d56:	e0 8b 00 04 	brhi	80004d5e <twi_master_init+0x5a>
80004d5a:	30 09       	mov	r9,0
80004d5c:	c0 f8       	rjmp	80004d7a <twi_master_init+0x76>
80004d5e:	30 09       	mov	r9,0
80004d60:	30 0c       	mov	r12,0
		// increase clock divider
		ckdiv++;
80004d62:	2f f9       	sub	r9,-1

		// divide cldiv value
		c_lh_div /= 2;
80004d64:	a1 98       	lsr	r8,0x1
	unsigned int c_lh_div;

	c_lh_div = pba_hz / (speed * 2) - 4;

	// cldiv must fit in 8 bits, ckdiv must fit in 3 bits
	while ((c_lh_div > 0xFF) && (ckdiv < 0x7)) {
80004d66:	e0 48 00 ff 	cp.w	r8,255
80004d6a:	5f bb       	srhi	r11
80004d6c:	58 69       	cp.w	r9,6
80004d6e:	5f 8a       	srls	r10
80004d70:	f7 ea 00 0a 	and	r10,r11,r10
80004d74:	f8 0a 18 00 	cp.b	r10,r12
80004d78:	cf 51       	brne	80004d62 <twi_master_init+0x5e>
		// divide cldiv value
		c_lh_div /= 2;
	}

	// set clock waveform generator register
	twi->cwgr = ((c_lh_div << AVR32_TWI_CWGR_CLDIV_OFFSET) |
80004d7a:	b1 69       	lsl	r9,0x10
80004d7c:	f3 e8 10 89 	or	r9,r9,r8<<0x8
80004d80:	f3 e8 10 08 	or	r8,r9,r8
80004d84:	8f 48       	st.w	r7[0x10],r8

	//Probe the component
	//status = twi_probe(twi, opt->chip);

	return status;
}
80004d86:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
80004d8a:	00 00       	add	r0,r0
80004d8c:	00 00       	add	r0,r0
80004d8e:	0c 0c       	add	r12,r6
80004d90:	80 00       	ld.sh	r0,r0[0x0]
80004d92:	4c 48       	lddpc	r8,80004ea0 <usart_write_line+0x1c>
80004d94:	80 00       	ld.sh	r0,r0[0x0]
80004d96:	49 40       	lddpc	r0,80004de4 <usart_set_async_baudrate+0x4c>

80004d98 <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
80004d98:	d4 01       	pushm	lr
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
80004d9a:	f6 08 15 04 	lsl	r8,r11,0x4
80004d9e:	14 38       	cp.w	r8,r10
80004da0:	f9 b8 08 10 	movls	r8,16
80004da4:	f9 b8 0b 08 	movhi	r8,8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
80004da8:	f0 0b 02 4b 	mul	r11,r8,r11
80004dac:	f6 09 16 01 	lsr	r9,r11,0x1
80004db0:	f2 0a 00 3a 	add	r10,r9,r10<<0x3
80004db4:	f4 0b 0d 0a 	divu	r10,r10,r11
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
80004db8:	f4 09 16 03 	lsr	r9,r10,0x3
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
80004dbc:	f2 cb 00 01 	sub	r11,r9,1
80004dc0:	e0 4b ff fe 	cp.w	r11,65534
80004dc4:	e0 88 00 03 	brls	80004dca <usart_set_async_baudrate+0x32>
80004dc8:	da 0a       	popm	pc,r12=1
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
80004dca:	78 1b       	ld.w	r11,r12[0x4]
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
80004dcc:	e8 6e 00 00 	mov	lr,524288
80004dd0:	59 08       	cp.w	r8,16
80004dd2:	fc 08 17 10 	movne	r8,lr
80004dd6:	f9 b8 00 00 	moveq	r8,0
80004dda:	e4 1b ff f7 	andh	r11,0xfff7
80004dde:	e0 1b fe cf 	andl	r11,0xfecf
80004de2:	16 48       	or	r8,r11
80004de4:	99 18       	st.w	r12[0x4],r8
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
80004de6:	f5 da c0 03 	bfextu	r10,r10,0x0,0x3
80004dea:	f3 ea 11 09 	or	r9,r9,r10<<0x10
80004dee:	99 89       	st.w	r12[0x20],r9
80004df0:	d8 0a       	popm	pc,r12=0

80004df2 <usart_write_char>:
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
80004df2:	78 58       	ld.w	r8,r12[0x14]
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
  if (usart_tx_ready(usart))
80004df4:	e2 18 00 02 	andl	r8,0x2,COH
80004df8:	c0 31       	brne	80004dfe <usart_write_char+0xc>
80004dfa:	30 2c       	mov	r12,2
80004dfc:	5e fc       	retal	r12
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
80004dfe:	f7 db c0 09 	bfextu	r11,r11,0x0,0x9
80004e02:	99 7b       	st.w	r12[0x1c],r11
80004e04:	5e fd       	retal	0
80004e06:	d7 03       	nop

80004e08 <usart_putchar>:
    return USART_TX_BUSY;
}


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
80004e08:	eb cd 40 e0 	pushm	r5-r7,lr
80004e0c:	18 96       	mov	r6,r12
80004e0e:	16 95       	mov	r5,r11
80004e10:	e0 67 27 0f 	mov	r7,9999
80004e14:	c0 68       	rjmp	80004e20 <usart_putchar+0x18>
  int timeout = USART_DEFAULT_TIMEOUT;

  do
  {
    if (!timeout--) return USART_FAILURE;
80004e16:	58 07       	cp.w	r7,0
80004e18:	c0 31       	brne	80004e1e <usart_putchar+0x16>
80004e1a:	e3 cf c0 e0 	ldm	sp++,r5-r7,pc,r12=-1
80004e1e:	20 17       	sub	r7,1
  } while (usart_write_char(usart, c) != USART_SUCCESS);
80004e20:	0a 9b       	mov	r11,r5
80004e22:	0c 9c       	mov	r12,r6
80004e24:	f0 1f 00 03 	mcall	80004e30 <usart_putchar+0x28>
80004e28:	cf 71       	brne	80004e16 <usart_putchar+0xe>

  return USART_SUCCESS;
}
80004e2a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80004e2e:	00 00       	add	r0,r0
80004e30:	80 00       	ld.sh	r0,r0[0x0]
80004e32:	4d f2       	lddpc	r2,80004fac <vListInitialise+0xc>

80004e34 <usart_read_char>:

int usart_read_char(volatile avr32_usart_t *usart, int *c)
{
  // Check for errors: frame, parity and overrun. In RS485 mode, a parity error
  // would mean that an address char has been received.
  if (usart->csr & (AVR32_USART_CSR_OVRE_MASK |
80004e34:	78 58       	ld.w	r8,r12[0x14]
80004e36:	e2 18 00 e0 	andl	r8,0xe0,COH
80004e3a:	c0 30       	breq	80004e40 <usart_read_char+0xc>
80004e3c:	30 4c       	mov	r12,4
80004e3e:	5e fc       	retal	r12
 *
 * \return \c 1 if the USART Receive Holding Register is full, otherwise \c 0.
 */
__always_inline static int usart_test_hit(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_RXRDY_MASK) != 0;
80004e40:	78 58       	ld.w	r8,r12[0x14]
                    AVR32_USART_CSR_FRAME_MASK |
                    AVR32_USART_CSR_PARE_MASK))
    return USART_RX_ERROR;

  // No error; if we really did receive a char, read it and return SUCCESS.
  if (usart_test_hit(usart))
80004e42:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80004e46:	c0 31       	brne	80004e4c <usart_read_char+0x18>
80004e48:	30 3c       	mov	r12,3
80004e4a:	5e fc       	retal	r12
  {
    *c = (usart->rhr & AVR32_USART_RHR_RXCHR_MASK) >> AVR32_USART_RHR_RXCHR_OFFSET;
80004e4c:	78 68       	ld.w	r8,r12[0x18]
80004e4e:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
80004e52:	97 08       	st.w	r11[0x0],r8
80004e54:	5e fd       	retal	0
80004e56:	d7 03       	nop

80004e58 <usart_getchar>:
    return USART_RX_EMPTY;
}


int usart_getchar(volatile avr32_usart_t *usart)
{
80004e58:	eb cd 40 c0 	pushm	r6-r7,lr
80004e5c:	20 1d       	sub	sp,4
80004e5e:	18 96       	mov	r6,r12
  int c, ret;

  while ((ret = usart_read_char(usart, &c)) == USART_RX_EMPTY);
80004e60:	1a 97       	mov	r7,sp
80004e62:	1a 9b       	mov	r11,sp
80004e64:	0c 9c       	mov	r12,r6
80004e66:	f0 1f 00 07 	mcall	80004e80 <usart_getchar+0x28>
80004e6a:	58 3c       	cp.w	r12,3
80004e6c:	cf b0       	breq	80004e62 <usart_getchar+0xa>

  if (ret == USART_RX_ERROR)
80004e6e:	58 4c       	cp.w	r12,4
80004e70:	f9 bc 00 ff 	moveq	r12,-1
    return USART_FAILURE;

  return c;
80004e74:	fb fc 10 00 	ld.wne	r12,sp[0x0]
}
80004e78:	2f fd       	sub	sp,-4
80004e7a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004e7e:	00 00       	add	r0,r0
80004e80:	80 00       	ld.sh	r0,r0[0x0]
80004e82:	4e 34       	lddpc	r4,8000500c <vListRemove+0x2>

80004e84 <usart_write_line>:


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
80004e84:	eb cd 40 c0 	pushm	r6-r7,lr
80004e88:	18 96       	mov	r6,r12
80004e8a:	16 97       	mov	r7,r11
  while (*string != '\0')
80004e8c:	17 8b       	ld.ub	r11,r11[0x0]
80004e8e:	58 0b       	cp.w	r11,0
80004e90:	c0 80       	breq	80004ea0 <usart_write_line+0x1c>
    usart_putchar(usart, *string++);
80004e92:	2f f7       	sub	r7,-1
80004e94:	0c 9c       	mov	r12,r6
80004e96:	f0 1f 00 04 	mcall	80004ea4 <usart_write_line+0x20>
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
80004e9a:	0f 8b       	ld.ub	r11,r7[0x0]
80004e9c:	58 0b       	cp.w	r11,0
80004e9e:	cf a1       	brne	80004e92 <usart_write_line+0xe>
80004ea0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004ea4:	80 00       	ld.sh	r0,r0[0x0]
80004ea6:	4e 08       	lddpc	r8,80005024 <vListRemove+0x1a>

80004ea8 <usart_reset>:
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
80004ea8:	e1 b8 00 00 	mfsr	r8,0x0

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
80004eac:	e6 18 00 01 	andh	r8,0x1,COH
80004eb0:	c0 71       	brne	80004ebe <usart_reset+0x16>
80004eb2:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
80004eb4:	3f f8       	mov	r8,-1
80004eb6:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80004eb8:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
80004eba:	d5 03       	csrf	0x10
80004ebc:	c0 48       	rjmp	80004ec4 <usart_reset+0x1c>
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
  usart->idr = 0xFFFFFFFF;
80004ebe:	3f f8       	mov	r8,-1
80004ec0:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80004ec2:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
80004ec4:	30 08       	mov	r8,0
80004ec6:	99 18       	st.w	r12[0x4],r8
  usart->rtor = 0;
80004ec8:	99 98       	st.w	r12[0x24],r8
  usart->ttgr = 0;
80004eca:	99 a8       	st.w	r12[0x28],r8

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
80004ecc:	ea 68 61 0c 	mov	r8,680204
80004ed0:	99 08       	st.w	r12[0x0],r8
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
80004ed2:	5e fc       	retal	r12

80004ed4 <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
80004ed4:	eb cd 40 e0 	pushm	r5-r7,lr
80004ed8:	18 96       	mov	r6,r12
80004eda:	16 97       	mov	r7,r11
80004edc:	14 95       	mov	r5,r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
80004ede:	f0 1f 00 2f 	mcall	80004f98 <usart_init_rs232+0xc4>

  // Check input values.
  if (!opt || // Null pointer.
80004ee2:	58 07       	cp.w	r7,0
80004ee4:	c5 80       	breq	80004f94 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
80004ee6:	0f c8       	ld.ub	r8,r7[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80004ee8:	30 49       	mov	r9,4
80004eea:	f2 08 18 00 	cp.b	r8,r9
80004eee:	e0 88 00 53 	brls	80004f94 <usart_init_rs232+0xc0>
80004ef2:	30 99       	mov	r9,9
80004ef4:	f2 08 18 00 	cp.b	r8,r9
80004ef8:	e0 8b 00 4e 	brhi	80004f94 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
80004efc:	0f d9       	ld.ub	r9,r7[0x5]
80004efe:	30 78       	mov	r8,7
80004f00:	f0 09 18 00 	cp.b	r9,r8
80004f04:	e0 8b 00 48 	brhi	80004f94 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
80004f08:	8e 39       	ld.sh	r9,r7[0x6]
80004f0a:	e0 68 01 01 	mov	r8,257
80004f0e:	f0 09 19 00 	cp.h	r9,r8
80004f12:	e0 8b 00 41 	brhi	80004f94 <usart_init_rs232+0xc0>
      opt->channelmode > 3 ||
80004f16:	ef 39 00 08 	ld.ub	r9,r7[8]
80004f1a:	30 38       	mov	r8,3
80004f1c:	f0 09 18 00 	cp.b	r9,r8
80004f20:	e0 8b 00 3a 	brhi	80004f94 <usart_init_rs232+0xc0>
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
80004f24:	0a 9a       	mov	r10,r5
80004f26:	6e 0b       	ld.w	r11,r7[0x0]
80004f28:	0c 9c       	mov	r12,r6
80004f2a:	f0 1f 00 1d 	mcall	80004f9c <usart_init_rs232+0xc8>
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80004f2e:	58 1c       	cp.w	r12,1
80004f30:	c3 20       	breq	80004f94 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;

  if (opt->charlength == 9)
80004f32:	0f c8       	ld.ub	r8,r7[0x4]
80004f34:	30 99       	mov	r9,9
80004f36:	f2 08 18 00 	cp.b	r8,r9
80004f3a:	c0 51       	brne	80004f44 <usart_init_rs232+0x70>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
80004f3c:	6c 18       	ld.w	r8,r6[0x4]
80004f3e:	b1 b8       	sbr	r8,0x11
80004f40:	8d 18       	st.w	r6[0x4],r8
80004f42:	c0 68       	rjmp	80004f4e <usart_init_rs232+0x7a>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
80004f44:	6c 19       	ld.w	r9,r6[0x4]
80004f46:	20 58       	sub	r8,5
80004f48:	f3 e8 10 68 	or	r8,r9,r8<<0x6
80004f4c:	8d 18       	st.w	r6[0x4],r8
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
80004f4e:	6c 19       	ld.w	r9,r6[0x4]
80004f50:	ef 3a 00 08 	ld.ub	r10,r7[8]
80004f54:	0f d8       	ld.ub	r8,r7[0x5]
80004f56:	a9 78       	lsl	r8,0x9
80004f58:	f1 ea 10 e8 	or	r8,r8,r10<<0xe
80004f5c:	12 48       	or	r8,r9
80004f5e:	8d 18       	st.w	r6[0x4],r8
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
80004f60:	8e 38       	ld.sh	r8,r7[0x6]
80004f62:	30 29       	mov	r9,2
80004f64:	f2 08 19 00 	cp.h	r8,r9
80004f68:	e0 88 00 09 	brls	80004f7a <usart_init_rs232+0xa6>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
80004f6c:	6c 18       	ld.w	r8,r6[0x4]
80004f6e:	ad b8       	sbr	r8,0xd
80004f70:	8d 18       	st.w	r6[0x4],r8
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
80004f72:	8e b8       	ld.uh	r8,r7[0x6]
80004f74:	20 28       	sub	r8,2
80004f76:	8d a8       	st.w	r6[0x28],r8
80004f78:	c0 68       	rjmp	80004f84 <usart_init_rs232+0xb0>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
80004f7a:	6c 19       	ld.w	r9,r6[0x4]
80004f7c:	5c 78       	castu.h	r8
80004f7e:	f3 e8 10 c8 	or	r8,r9,r8<<0xc
80004f82:	8d 18       	st.w	r6[0x4],r8

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
80004f84:	6c 18       	ld.w	r8,r6[0x4]
80004f86:	e0 18 ff f0 	andl	r8,0xfff0
80004f8a:	8d 18       	st.w	r6[0x4],r8
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
80004f8c:	35 08       	mov	r8,80
80004f8e:	8d 08       	st.w	r6[0x0],r8
80004f90:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
80004f94:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
80004f98:	80 00       	ld.sh	r0,r0[0x0]
80004f9a:	4e a8       	lddpc	r8,80005140 <SCALLYield+0x14>
80004f9c:	80 00       	ld.sh	r0,r0[0x0]
80004f9e:	4d 98       	lddpc	r8,80005100 <xPortStartScheduler+0x2c>

80004fa0 <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
80004fa0:	f8 c8 ff f8 	sub	r8,r12,-8
80004fa4:	99 18       	st.w	r12[0x4],r8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
80004fa6:	3f f9       	mov	r9,-1
80004fa8:	99 29       	st.w	r12[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
80004faa:	99 38       	st.w	r12[0xc],r8
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
80004fac:	99 48       	st.w	r12[0x10],r8

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
80004fae:	30 08       	mov	r8,0
80004fb0:	99 08       	st.w	r12[0x0],r8
}
80004fb2:	5e fc       	retal	r12

80004fb4 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
80004fb4:	30 08       	mov	r8,0
80004fb6:	99 48       	st.w	r12[0x10],r8
}
80004fb8:	5e fc       	retal	r12

80004fba <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
80004fba:	78 18       	ld.w	r8,r12[0x4]

	pxNewListItem->pxNext = pxIndex->pxNext;
80004fbc:	70 19       	ld.w	r9,r8[0x4]
80004fbe:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
80004fc0:	78 19       	ld.w	r9,r12[0x4]
80004fc2:	97 29       	st.w	r11[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80004fc4:	70 19       	ld.w	r9,r8[0x4]
80004fc6:	93 2b       	st.w	r9[0x8],r11
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
80004fc8:	91 1b       	st.w	r8[0x4],r11
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
80004fca:	99 1b       	st.w	r12[0x4],r11

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80004fcc:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80004fce:	78 08       	ld.w	r8,r12[0x0]
80004fd0:	2f f8       	sub	r8,-1
80004fd2:	99 08       	st.w	r12[0x0],r8
}
80004fd4:	5e fc       	retal	r12

80004fd6 <vListInsert>:
{
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
80004fd6:	76 0a       	ld.w	r10,r11[0x0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
80004fd8:	5b fa       	cp.w	r10,-1
80004fda:	c0 31       	brne	80004fe0 <vListInsert+0xa>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
80004fdc:	78 48       	ld.w	r8,r12[0x10]
80004fde:	c0 c8       	rjmp	80004ff6 <vListInsert+0x20>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
80004fe0:	f8 c8 ff f8 	sub	r8,r12,-8
80004fe4:	70 19       	ld.w	r9,r8[0x4]
80004fe6:	72 09       	ld.w	r9,r9[0x0]
80004fe8:	12 3a       	cp.w	r10,r9
80004fea:	c0 63       	brcs	80004ff6 <vListInsert+0x20>
80004fec:	70 18       	ld.w	r8,r8[0x4]
80004fee:	70 19       	ld.w	r9,r8[0x4]
80004ff0:	72 09       	ld.w	r9,r9[0x0]
80004ff2:	12 3a       	cp.w	r10,r9
80004ff4:	cf c2       	brcc	80004fec <vListInsert+0x16>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
80004ff6:	70 19       	ld.w	r9,r8[0x4]
80004ff8:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80004ffa:	93 2b       	st.w	r9[0x8],r11
	pxNewListItem->pxPrevious = pxIterator;
80004ffc:	97 28       	st.w	r11[0x8],r8
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
80004ffe:	91 1b       	st.w	r8[0x4],r11

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80005000:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80005002:	78 08       	ld.w	r8,r12[0x0]
80005004:	2f f8       	sub	r8,-1
80005006:	99 08       	st.w	r12[0x0],r8
}
80005008:	5e fc       	retal	r12

8000500a <vListRemove>:

void vListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
8000500a:	78 18       	ld.w	r8,r12[0x4]
8000500c:	78 29       	ld.w	r9,r12[0x8]
8000500e:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
80005010:	78 28       	ld.w	r8,r12[0x8]
80005012:	78 19       	ld.w	r9,r12[0x4]
80005014:	91 19       	st.w	r8[0x4],r9

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
80005016:	78 48       	ld.w	r8,r12[0x10]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
80005018:	70 19       	ld.w	r9,r8[0x4]
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
8000501a:	18 39       	cp.w	r9,r12
8000501c:	f9 f9 00 02 	ld.weq	r9,r12[0x8]
80005020:	f1 f9 0a 01 	st.weq	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
80005024:	30 09       	mov	r9,0
80005026:	99 49       	st.w	r12[0x10],r9
	( pxList->uxNumberOfItems )--;
80005028:	70 09       	ld.w	r9,r8[0x0]
8000502a:	20 19       	sub	r9,1
8000502c:	91 09       	st.w	r8[0x0],r9
}
8000502e:	5e fc       	retal	r12

80005030 <pxPortInitialiseStack>:
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x08080808;					/* R8 */
80005030:	e0 68 08 08 	mov	r8,2056
80005034:	ea 18 08 08 	orh	r8,0x808
80005038:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x09090909;					/* R9 */
8000503a:	e0 68 09 09 	mov	r8,2313
8000503e:	ea 18 09 09 	orh	r8,0x909
80005042:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0A0A0A0A;					/* R10 */
80005044:	e0 68 0a 0a 	mov	r8,2570
80005048:	ea 18 0a 0a 	orh	r8,0xa0a
8000504c:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0B0B0B0B;					/* R11 */
8000504e:	e0 68 0b 0b 	mov	r8,2827
80005052:	ea 18 0b 0b 	orh	r8,0xb0b
80005056:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pvParameters;					/* R12 */
80005058:	18 da       	st.w	--r12,r10
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xDEADBEEF;					/* R14/LR */
8000505a:	e0 68 be ef 	mov	r8,48879
8000505e:	ea 18 de ad 	orh	r8,0xdead
80005062:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
80005064:	18 db       	st.w	--r12,r11
	*pxTopOfStack-- = ( portSTACK_TYPE ) portINITIAL_SR;				/* SR */
80005066:	fc 18 00 40 	movh	r8,0x40
8000506a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xFF0000FF;					/* R0 */
8000506c:	e0 68 00 ff 	mov	r8,255
80005070:	ea 18 ff 00 	orh	r8,0xff00
80005074:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x01010101;					/* R1 */
80005076:	e0 68 01 01 	mov	r8,257
8000507a:	ea 18 01 01 	orh	r8,0x101
8000507e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x02020202;					/* R2 */
80005080:	e0 68 02 02 	mov	r8,514
80005084:	ea 18 02 02 	orh	r8,0x202
80005088:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x03030303;					/* R3 */
8000508a:	e0 68 03 03 	mov	r8,771
8000508e:	ea 18 03 03 	orh	r8,0x303
80005092:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x04040404;					/* R4 */
80005094:	e0 68 04 04 	mov	r8,1028
80005098:	ea 18 04 04 	orh	r8,0x404
8000509c:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x05050505;					/* R5 */
8000509e:	e0 68 05 05 	mov	r8,1285
800050a2:	ea 18 05 05 	orh	r8,0x505
800050a6:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x06060606;					/* R6 */
800050a8:	e0 68 06 06 	mov	r8,1542
800050ac:	ea 18 06 06 	orh	r8,0x606
800050b0:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x07070707;					/* R7 */
800050b2:	e0 68 07 07 	mov	r8,1799
800050b6:	ea 18 07 07 	orh	r8,0x707
800050ba:	18 d8       	st.w	--r12,r8
	*pxTopOfStack = ( portSTACK_TYPE ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
800050bc:	30 08       	mov	r8,0
800050be:	18 d8       	st.w	--r12,r8

	return pxTopOfStack;
}
800050c0:	5e fc       	retal	r12
800050c2:	d7 03       	nop

800050c4 <vPortEnterCritical>:
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
800050c4:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
800050c6:	48 38       	lddpc	r8,800050d0 <vPortEnterCritical+0xc>
800050c8:	70 09       	ld.w	r9,r8[0x0]
800050ca:	2f f9       	sub	r9,-1
800050cc:	91 09       	st.w	r8[0x0],r9
}
800050ce:	5e fc       	retal	r12
800050d0:	00 00       	add	r0,r0
800050d2:	05 28       	ld.uh	r8,r2++

800050d4 <xPortStartScheduler>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
800050d4:	d4 01       	pushm	lr
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
800050d6:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
800050d8:	30 0a       	mov	r10,0
800050da:	14 9b       	mov	r11,r10
800050dc:	49 2c       	lddpc	r12,80005124 <xPortStartScheduler+0x50>
800050de:	f0 1f 00 13 	mcall	80005128 <xPortStartScheduler+0x54>
/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);//cause!!!
800050e2:	e0 68 5d c0 	mov	r8,24000
800050e6:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
800050ea:	30 08       	mov	r8,0
800050ec:	e3 b8 00 42 	mtsr	0x108,r8
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Start the first task. */
	portRESTORE_CONTEXT();
800050f0:	e0 68 0c ec 	mov	r8,3308
800050f4:	ea 18 00 00 	orh	r8,0x0
800050f8:	70 00       	ld.w	r0,r8[0x0]
800050fa:	60 0d       	ld.w	sp,r0[0x0]
800050fc:	1b 00       	ld.w	r0,sp++
800050fe:	e0 68 05 28 	mov	r8,1320
80005102:	ea 18 00 00 	orh	r8,0x0
80005106:	91 00       	st.w	r8[0x0],r0
80005108:	e3 cd 00 ff 	ldm	sp++,r0-r7
8000510c:	2f ed       	sub	sp,-8
8000510e:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
80005112:	fa f0 ff e0 	ld.w	r0,sp[-32]
80005116:	e3 b0 00 00 	mtsr	0x0,r0
8000511a:	fa f0 ff dc 	ld.w	r0,sp[-36]
8000511e:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
}
80005122:	d8 0a       	popm	pc,r12=0
80005124:	80 00       	ld.sh	r0,r0[0x0]
80005126:	51 f0       	stdsp	sp[0x7c],r0
80005128:	80 00       	ld.sh	r0,r0[0x0]
8000512a:	49 40       	lddpc	r0,80005178 <SCALLYield+0x4c>

8000512c <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
8000512c:	20 6d       	sub	sp,24
8000512e:	eb cd 00 ff 	pushm	r0-r7
80005132:	fa c7 ff c0 	sub	r7,sp,-64
80005136:	ee f0 ff f8 	ld.w	r0,r7[-8]
8000513a:	ef 40 ff e0 	st.w	r7[-32],r0
8000513e:	ee f0 ff fc 	ld.w	r0,r7[-4]
80005142:	ef 40 ff e4 	st.w	r7[-28],r0
80005146:	eb c7 5f 00 	stm	--r7,r8-r12,lr
8000514a:	e0 68 05 28 	mov	r8,1320
8000514e:	ea 18 00 00 	orh	r8,0x0
80005152:	70 00       	ld.w	r0,r8[0x0]
80005154:	1a d0       	st.w	--sp,r0
80005156:	f0 1f 00 1a 	mcall	800051bc <LABEL_RET_SCALL_263+0x14>
8000515a:	e0 68 0c ec 	mov	r8,3308
8000515e:	ea 18 00 00 	orh	r8,0x0
80005162:	70 00       	ld.w	r0,r8[0x0]
80005164:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
80005166:	f0 1f 00 17 	mcall	800051c0 <LABEL_RET_SCALL_263+0x18>
	portRESTORE_CONTEXT_SCALL();
8000516a:	e0 68 0c ec 	mov	r8,3308
8000516e:	ea 18 00 00 	orh	r8,0x0
80005172:	70 00       	ld.w	r0,r8[0x0]
80005174:	60 0d       	ld.w	sp,r0[0x0]
80005176:	1b 00       	ld.w	r0,sp++
80005178:	e0 68 05 28 	mov	r8,1320
8000517c:	ea 18 00 00 	orh	r8,0x0
80005180:	91 00       	st.w	r8[0x0],r0
80005182:	fa c7 ff d8 	sub	r7,sp,-40
80005186:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
8000518a:	ee f0 ff e0 	ld.w	r0,r7[-32]
8000518e:	e0 61 05 28 	mov	r1,1320
80005192:	ea 11 00 00 	orh	r1,0x0
80005196:	62 02       	ld.w	r2,r1[0x0]
80005198:	58 02       	cp.w	r2,0
8000519a:	c0 70       	breq	800051a8 <LABEL_RET_SCALL_263>
8000519c:	e4 c2 00 01 	sub	r2,r2,1
800051a0:	83 02       	st.w	r1[0x0],r2
800051a2:	58 02       	cp.w	r2,0
800051a4:	c0 21       	brne	800051a8 <LABEL_RET_SCALL_263>
800051a6:	b1 c0       	cbr	r0,0x10

800051a8 <LABEL_RET_SCALL_263>:
800051a8:	ef 40 ff f8 	st.w	r7[-8],r0
800051ac:	ee f0 ff e4 	ld.w	r0,r7[-28]
800051b0:	ef 40 ff fc 	st.w	r7[-4],r0
800051b4:	e3 cd 00 ff 	ldm	sp++,r0-r7
800051b8:	2f ad       	sub	sp,-24
800051ba:	d6 13       	rets
800051bc:	80 00       	ld.sh	r0,r0[0x0]
800051be:	50 c4       	stdsp	sp[0x30],r4
800051c0:	80 00       	ld.sh	r0,r0[0x0]
800051c2:	58 60       	cp.w	r0,6

800051c4 <prvClearCcInt>:
		Set_system_register(AVR32_COUNT, 0);
	}

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
800051c4:	e1 b8 00 43 	mfsr	r8,0x10c
800051c8:	e3 b8 00 43 	mtsr	0x10c,r8
	}
800051cc:	5e fc       	retal	r12
800051ce:	d7 03       	nop

800051d0 <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
800051d0:	48 78       	lddpc	r8,800051ec <vPortExitCritical+0x1c>
800051d2:	70 08       	ld.w	r8,r8[0x0]
800051d4:	58 08       	cp.w	r8,0
800051d6:	5e 0c       	reteq	r12
	{
		ulCriticalNesting--;
800051d8:	48 58       	lddpc	r8,800051ec <vPortExitCritical+0x1c>
800051da:	70 09       	ld.w	r9,r8[0x0]
800051dc:	20 19       	sub	r9,1
800051de:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
800051e0:	70 08       	ld.w	r8,r8[0x0]
800051e2:	58 08       	cp.w	r8,0
800051e4:	5e 1c       	retne	r12
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
800051e6:	d5 03       	csrf	0x10
800051e8:	5e fc       	retal	r12
800051ea:	00 00       	add	r0,r0
800051ec:	00 00       	add	r0,r0
800051ee:	05 28       	ld.uh	r8,r2++

800051f0 <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
800051f0:	eb cd 00 ff 	pushm	r0-r7
800051f4:	e0 68 05 28 	mov	r8,1320
800051f8:	ea 18 00 00 	orh	r8,0x0
800051fc:	70 00       	ld.w	r0,r8[0x0]
800051fe:	1a d0       	st.w	--sp,r0
80005200:	7a 90       	ld.w	r0,sp[0x24]
80005202:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80005206:	58 10       	cp.w	r0,1
80005208:	e0 8b 00 08 	brhi	80005218 <LABEL_INT_SKIP_SAVE_CONTEXT_237>
8000520c:	e0 68 0c ec 	mov	r8,3308
80005210:	ea 18 00 00 	orh	r8,0x0
80005214:	70 00       	ld.w	r0,r8[0x0]
80005216:	81 0d       	st.w	r0[0x0],sp

80005218 <LABEL_INT_SKIP_SAVE_CONTEXT_237>:
	#if( configTICK_USE_TC==1 )
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Clear the interrupt flag. */
		prvClearCcInt();
80005218:	f0 1f 00 12 	mcall	80005260 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
8000521c:	f0 1f 00 12 	mcall	80005264 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
		vTaskIncrementTick();
80005220:	f0 1f 00 12 	mcall	80005268 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x1c>
	portEXIT_CRITICAL();
80005224:	f0 1f 00 12 	mcall	8000526c <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
80005228:	7a 90       	ld.w	r0,sp[0x24]
8000522a:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
8000522e:	58 10       	cp.w	r0,1
80005230:	e0 8b 00 0e 	brhi	8000524c <LABEL_INT_SKIP_RESTORE_CONTEXT_254>
80005234:	f0 1f 00 0c 	mcall	80005264 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
80005238:	f0 1f 00 0e 	mcall	80005270 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x24>
8000523c:	f0 1f 00 0c 	mcall	8000526c <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>
80005240:	e0 68 0c ec 	mov	r8,3308
80005244:	ea 18 00 00 	orh	r8,0x0
80005248:	70 00       	ld.w	r0,r8[0x0]
8000524a:	60 0d       	ld.w	sp,r0[0x0]

8000524c <LABEL_INT_SKIP_RESTORE_CONTEXT_254>:
8000524c:	1b 00       	ld.w	r0,sp++
8000524e:	e0 68 05 28 	mov	r8,1320
80005252:	ea 18 00 00 	orh	r8,0x0
80005256:	91 00       	st.w	r8[0x0],r0
80005258:	e3 cd 00 ff 	ldm	sp++,r0-r7
8000525c:	d6 03       	rete
8000525e:	00 00       	add	r0,r0
80005260:	80 00       	ld.sh	r0,r0[0x0]
80005262:	51 c4       	stdsp	sp[0x70],r4
80005264:	80 00       	ld.sh	r0,r0[0x0]
80005266:	50 c4       	stdsp	sp[0x30],r4
80005268:	80 00       	ld.sh	r0,r0[0x0]
8000526a:	5a 64       	cp.w	r4,-26
8000526c:	80 00       	ld.sh	r0,r0[0x0]
8000526e:	51 d0       	stdsp	sp[0x74],r0
80005270:	80 00       	ld.sh	r0,r0[0x0]
80005272:	58 60       	cp.w	r0,6

80005274 <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
80005274:	d4 01       	pushm	lr
	vTaskSuspendAll();
80005276:	f0 1f 00 02 	mcall	8000527c <__malloc_lock+0x8>
}
8000527a:	d8 02       	popm	pc
8000527c:	80 00       	ld.sh	r0,r0[0x0]
8000527e:	58 50       	cp.w	r0,5

80005280 <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
80005280:	d4 01       	pushm	lr
	xTaskResumeAll();
80005282:	f0 1f 00 02 	mcall	80005288 <__malloc_unlock+0x8>
}
80005286:	d8 02       	popm	pc
80005288:	80 00       	ld.sh	r0,r0[0x0]
8000528a:	5c 0c       	acr	r12

8000528c <_read>:
/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
{
8000528c:	d4 21       	pushm	r4-r7,lr
8000528e:	16 95       	mov	r5,r11
80005290:	14 96       	mov	r6,r10
  int nChars = 0;

  if (file != 0)
80005292:	58 0c       	cp.w	r12,0
80005294:	c0 30       	breq	8000529a <_read+0xe>
80005296:	3f f7       	mov	r7,-1
80005298:	c1 48       	rjmp	800052c0 <_read+0x34>
    return -1;

  for (; len > 0; --len)
8000529a:	58 0a       	cp.w	r10,0
8000529c:	e0 89 00 04 	brgt	800052a4 <_read+0x18>
800052a0:	30 07       	mov	r7,0
800052a2:	c0 f8       	rjmp	800052c0 <_read+0x34>
800052a4:	30 07       	mov	r7,0
  {
    int c = usart_getchar(stdio_usart_base);
800052a6:	48 84       	lddpc	r4,800052c4 <_read+0x38>
800052a8:	68 0c       	ld.w	r12,r4[0x0]
800052aa:	f0 1f 00 08 	mcall	800052c8 <_read+0x3c>
    if (c < 0)
800052ae:	c0 95       	brlt	800052c0 <_read+0x34>
      break;

    *ptr++ = c;
800052b0:	ea 07 0b 0c 	st.b	r5[r7],r12
    ++nChars;
800052b4:	2f f7       	sub	r7,-1

/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
800052b6:	ec 07 01 08 	sub	r8,r6,r7
  int nChars = 0;

  if (file != 0)
    return -1;

  for (; len > 0; --len)
800052ba:	58 08       	cp.w	r8,0
800052bc:	fe 99 ff f6 	brgt	800052a8 <_read+0x1c>
    *ptr++ = c;
    ++nChars;
  }

  return nChars;
}
800052c0:	0e 9c       	mov	r12,r7
800052c2:	d8 22       	popm	r4-r7,pc
800052c4:	00 00       	add	r0,r0
800052c6:	41 0c       	lddsp	r12,sp[0x40]
800052c8:	80 00       	ld.sh	r0,r0[0x0]
800052ca:	4e 58       	lddpc	r8,8000545c <prvUnlockQueue+0x84>

800052cc <_write>:
 * 1 and 2 is stdout and stderr which goes to usart
 * 3 is framebuffer
 */
int __attribute__((weak))
_write (int file, char * ptr, int len)
{
800052cc:	d4 21       	pushm	r4-r7,lr
800052ce:	16 95       	mov	r5,r11
800052d0:	14 96       	mov	r6,r10
  int nChars = 0;

  if ( (file != 1)
800052d2:	20 1c       	sub	r12,1
800052d4:	58 2c       	cp.w	r12,2
800052d6:	e0 8b 00 12 	brhi	800052fa <_write+0x2e>
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
800052da:	58 0a       	cp.w	r10,0
800052dc:	c0 31       	brne	800052e2 <_write+0x16>
800052de:	30 07       	mov	r7,0
800052e0:	c0 e8       	rjmp	800052fc <_write+0x30>
800052e2:	30 07       	mov	r7,0
  {
    if (usart_putchar(stdio_usart_base, *ptr++) < 0)
800052e4:	48 74       	lddpc	r4,80005300 <_write+0x34>
800052e6:	68 0c       	ld.w	r12,r4[0x0]
800052e8:	ea 07 07 0b 	ld.ub	r11,r5[r7]
800052ec:	f0 1f 00 06 	mcall	80005304 <_write+0x38>
800052f0:	c0 55       	brlt	800052fa <_write+0x2e>
    {
      return -1;
    }

    ++nChars;
800052f2:	2f f7       	sub	r7,-1

  if ( (file != 1)
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
800052f4:	0e 36       	cp.w	r6,r7
800052f6:	cf 81       	brne	800052e6 <_write+0x1a>
800052f8:	c0 28       	rjmp	800052fc <_write+0x30>
800052fa:	3f f7       	mov	r7,-1

    ++nChars;
  }

  return nChars;
}
800052fc:	0e 9c       	mov	r12,r7
800052fe:	d8 22       	popm	r4-r7,pc
80005300:	00 00       	add	r0,r0
80005302:	41 0c       	lddsp	r12,sp[0x40]
80005304:	80 00       	ld.sh	r0,r0[0x0]
80005306:	4e 08       	lddpc	r8,80005484 <xQueueGenericReceive+0xc>

80005308 <vPortFree>:
	return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
80005308:	eb cd 40 80 	pushm	r7,lr
8000530c:	18 97       	mov	r7,r12
	if( pv )
8000530e:	58 0c       	cp.w	r12,0
80005310:	c0 80       	breq	80005320 <vPortFree+0x18>
	{
		vTaskSuspendAll();
80005312:	f0 1f 00 05 	mcall	80005324 <vPortFree+0x1c>
		{
			free( pv );
80005316:	0e 9c       	mov	r12,r7
80005318:	f0 1f 00 04 	mcall	80005328 <vPortFree+0x20>
		}
		xTaskResumeAll();
8000531c:	f0 1f 00 04 	mcall	8000532c <vPortFree+0x24>
80005320:	e3 cd 80 80 	ldm	sp++,r7,pc
80005324:	80 00       	ld.sh	r0,r0[0x0]
80005326:	58 50       	cp.w	r0,5
80005328:	80 00       	ld.sh	r0,r0[0x0]
8000532a:	67 7c       	ld.w	r12,r3[0x5c]
8000532c:	80 00       	ld.sh	r0,r0[0x0]
8000532e:	5c 0c       	acr	r12

80005330 <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
80005330:	eb cd 40 80 	pushm	r7,lr
80005334:	18 97       	mov	r7,r12
void *pvReturn;

	vTaskSuspendAll();
80005336:	f0 1f 00 06 	mcall	8000534c <pvPortMalloc+0x1c>
	{
		pvReturn = malloc( xWantedSize );
8000533a:	0e 9c       	mov	r12,r7
8000533c:	f0 1f 00 05 	mcall	80005350 <pvPortMalloc+0x20>
80005340:	18 97       	mov	r7,r12
	}
	xTaskResumeAll();
80005342:	f0 1f 00 05 	mcall	80005354 <pvPortMalloc+0x24>
		}
	}
	#endif

	return pvReturn;
}
80005346:	0e 9c       	mov	r12,r7
80005348:	e3 cd 80 80 	ldm	sp++,r7,pc
8000534c:	80 00       	ld.sh	r0,r0[0x0]
8000534e:	58 50       	cp.w	r0,5
80005350:	80 00       	ld.sh	r0,r0[0x0]
80005352:	67 8c       	ld.w	r12,r3[0x60]
80005354:	80 00       	ld.sh	r0,r0[0x0]
80005356:	5c 0c       	acr	r12

80005358 <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
80005358:	d4 01       	pushm	lr
8000535a:	16 98       	mov	r8,r11
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
8000535c:	78 09       	ld.w	r9,r12[0x0]
8000535e:	58 09       	cp.w	r9,0
80005360:	c1 10       	breq	80005382 <prvCopyDataFromQueue+0x2a>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
80005362:	78 3a       	ld.w	r10,r12[0xc]
80005364:	79 09       	ld.w	r9,r12[0x40]
80005366:	f4 09 00 09 	add	r9,r10,r9
8000536a:	99 39       	st.w	r12[0xc],r9
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
8000536c:	78 1a       	ld.w	r10,r12[0x4]
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
8000536e:	14 39       	cp.w	r9,r10
80005370:	f9 f9 20 00 	ld.wcc	r9,r12[0x0]
80005374:	f9 f9 2a 03 	st.wcc	r12[0xc],r9
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
80005378:	79 0a       	ld.w	r10,r12[0x40]
8000537a:	78 3b       	ld.w	r11,r12[0xc]
8000537c:	10 9c       	mov	r12,r8
8000537e:	f0 1f 00 02 	mcall	80005384 <prvCopyDataFromQueue+0x2c>
80005382:	d8 02       	popm	pc
80005384:	80 00       	ld.sh	r0,r0[0x0]
80005386:	6b d4       	ld.w	r4,r5[0x74]

80005388 <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
80005388:	eb cd 40 c0 	pushm	r6-r7,lr
8000538c:	18 97       	mov	r7,r12
8000538e:	14 96       	mov	r6,r10
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80005390:	78 e8       	ld.w	r8,r12[0x38]
80005392:	58 08       	cp.w	r8,0
80005394:	c0 31       	brne	8000539a <xQueueReceiveFromISR+0x12>
80005396:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
8000539a:	f0 1f 00 0e 	mcall	800053d0 <xQueueReceiveFromISR+0x48>
			--( pxQueue->uxMessagesWaiting );
8000539e:	6e e8       	ld.w	r8,r7[0x38]
800053a0:	20 18       	sub	r8,1
800053a2:	8f e8       	st.w	r7[0x38],r8

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
800053a4:	6f 18       	ld.w	r8,r7[0x44]
800053a6:	5b f8       	cp.w	r8,-1
800053a8:	c0 d1       	brne	800053c2 <xQueueReceiveFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
800053aa:	6e 48       	ld.w	r8,r7[0x10]
800053ac:	58 08       	cp.w	r8,0
800053ae:	c0 f0       	breq	800053cc <xQueueReceiveFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
800053b0:	ee cc ff f0 	sub	r12,r7,-16
800053b4:	f0 1f 00 08 	mcall	800053d4 <xQueueReceiveFromISR+0x4c>
800053b8:	c0 a0       	breq	800053cc <xQueueReceiveFromISR+0x44>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
800053ba:	30 1c       	mov	r12,1
800053bc:	8d 0c       	st.w	r6[0x0],r12
800053be:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
800053c2:	2f f8       	sub	r8,-1
800053c4:	ef 48 00 44 	st.w	r7[68],r8
800053c8:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
800053cc:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
800053d0:	80 00       	ld.sh	r0,r0[0x0]
800053d2:	53 58       	stdsp	sp[0xd4],r8
800053d4:	80 00       	ld.sh	r0,r0[0x0]
800053d6:	59 e8       	cp.w	r8,30

800053d8 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
800053d8:	eb cd 40 c0 	pushm	r6-r7,lr
800053dc:	18 97       	mov	r7,r12

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
800053de:	f0 1f 00 23 	mcall	80005468 <prvUnlockQueue+0x90>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
800053e2:	6f 28       	ld.w	r8,r7[0x48]
800053e4:	58 08       	cp.w	r8,0
800053e6:	e0 8a 00 18 	brle	80005416 <prvUnlockQueue+0x3e>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800053ea:	6e 98       	ld.w	r8,r7[0x24]
800053ec:	58 08       	cp.w	r8,0
800053ee:	c1 40       	breq	80005416 <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
800053f0:	ee c6 ff dc 	sub	r6,r7,-36
800053f4:	c0 48       	rjmp	800053fc <prvUnlockQueue+0x24>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800053f6:	6e 98       	ld.w	r8,r7[0x24]
800053f8:	58 08       	cp.w	r8,0
800053fa:	c0 e0       	breq	80005416 <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
800053fc:	0c 9c       	mov	r12,r6
800053fe:	f0 1f 00 1c 	mcall	8000546c <prvUnlockQueue+0x94>
80005402:	c0 30       	breq	80005408 <prvUnlockQueue+0x30>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
80005404:	f0 1f 00 1b 	mcall	80005470 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xTxLock );
80005408:	6f 28       	ld.w	r8,r7[0x48]
8000540a:	20 18       	sub	r8,1
8000540c:	ef 48 00 48 	st.w	r7[72],r8
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80005410:	58 08       	cp.w	r8,0
80005412:	fe 99 ff f2 	brgt	800053f6 <prvUnlockQueue+0x1e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
80005416:	3f f8       	mov	r8,-1
80005418:	ef 48 00 48 	st.w	r7[72],r8
	}
	taskEXIT_CRITICAL();
8000541c:	f0 1f 00 16 	mcall	80005474 <prvUnlockQueue+0x9c>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
80005420:	f0 1f 00 12 	mcall	80005468 <prvUnlockQueue+0x90>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80005424:	6f 18       	ld.w	r8,r7[0x44]
80005426:	58 08       	cp.w	r8,0
80005428:	e0 8a 00 18 	brle	80005458 <prvUnlockQueue+0x80>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
8000542c:	6e 48       	ld.w	r8,r7[0x10]
8000542e:	58 08       	cp.w	r8,0
80005430:	c1 40       	breq	80005458 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80005432:	ee c6 ff f0 	sub	r6,r7,-16
80005436:	c0 48       	rjmp	8000543e <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005438:	6e 48       	ld.w	r8,r7[0x10]
8000543a:	58 08       	cp.w	r8,0
8000543c:	c0 e0       	breq	80005458 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
8000543e:	0c 9c       	mov	r12,r6
80005440:	f0 1f 00 0b 	mcall	8000546c <prvUnlockQueue+0x94>
80005444:	c0 30       	breq	8000544a <prvUnlockQueue+0x72>
				{
					vTaskMissedYield();
80005446:	f0 1f 00 0b 	mcall	80005470 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xRxLock );
8000544a:	6f 18       	ld.w	r8,r7[0x44]
8000544c:	20 18       	sub	r8,1
8000544e:	ef 48 00 44 	st.w	r7[68],r8
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80005452:	58 08       	cp.w	r8,0
80005454:	fe 99 ff f2 	brgt	80005438 <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
80005458:	3f f8       	mov	r8,-1
8000545a:	ef 48 00 44 	st.w	r7[68],r8
	}
	taskEXIT_CRITICAL();
8000545e:	f0 1f 00 06 	mcall	80005474 <prvUnlockQueue+0x9c>
}
80005462:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005466:	00 00       	add	r0,r0
80005468:	80 00       	ld.sh	r0,r0[0x0]
8000546a:	50 c4       	stdsp	sp[0x30],r4
8000546c:	80 00       	ld.sh	r0,r0[0x0]
8000546e:	59 e8       	cp.w	r8,30
80005470:	80 00       	ld.sh	r0,r0[0x0]
80005472:	58 f4       	cp.w	r4,15
80005474:	80 00       	ld.sh	r0,r0[0x0]
80005476:	51 d0       	stdsp	sp[0x74],r0

80005478 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
80005478:	d4 31       	pushm	r0-r7,lr
8000547a:	20 5d       	sub	sp,20
8000547c:	18 97       	mov	r7,r12
8000547e:	50 0b       	stdsp	sp[0x0],r11
80005480:	50 2a       	stdsp	sp[0x8],r10
80005482:	50 19       	stdsp	sp[0x4],r9
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80005484:	f8 c2 ff dc 	sub	r2,r12,-36
80005488:	30 05       	mov	r5,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
8000548a:	fa c4 ff f4 	sub	r4,sp,-12
8000548e:	30 10       	mov	r0,1

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80005490:	0a 91       	mov	r1,r5

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80005492:	fa c3 ff f8 	sub	r3,sp,-8
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
80005496:	f0 1f 00 3e 	mcall	8000558c <xQueueGenericReceive+0x114>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
8000549a:	6e e8       	ld.w	r8,r7[0x38]
8000549c:	58 08       	cp.w	r8,0
8000549e:	c2 a0       	breq	800054f2 <xQueueGenericReceive+0x7a>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
800054a0:	6e 36       	ld.w	r6,r7[0xc]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
800054a2:	40 0b       	lddsp	r11,sp[0x0]
800054a4:	0e 9c       	mov	r12,r7
800054a6:	f0 1f 00 3b 	mcall	80005590 <xQueueGenericReceive+0x118>

				if( xJustPeeking == pdFALSE )
800054aa:	40 18       	lddsp	r8,sp[0x4]
800054ac:	58 08       	cp.w	r8,0
800054ae:	c1 51       	brne	800054d8 <xQueueGenericReceive+0x60>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
800054b0:	6e e8       	ld.w	r8,r7[0x38]
800054b2:	20 18       	sub	r8,1
800054b4:	8f e8       	st.w	r7[0x38],r8

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
800054b6:	6e 08       	ld.w	r8,r7[0x0]
800054b8:	58 08       	cp.w	r8,0
800054ba:	c0 41       	brne	800054c2 <xQueueGenericReceive+0x4a>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
800054bc:	f0 1f 00 36 	mcall	80005594 <xQueueGenericReceive+0x11c>
800054c0:	8f 1c       	st.w	r7[0x4],r12
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
800054c2:	6e 48       	ld.w	r8,r7[0x10]
800054c4:	58 08       	cp.w	r8,0
800054c6:	c1 20       	breq	800054ea <xQueueGenericReceive+0x72>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
800054c8:	ee cc ff f0 	sub	r12,r7,-16
800054cc:	f0 1f 00 33 	mcall	80005598 <xQueueGenericReceive+0x120>
800054d0:	58 1c       	cp.w	r12,1
800054d2:	c0 c1       	brne	800054ea <xQueueGenericReceive+0x72>
						{
							portYIELD_WITHIN_API();
800054d4:	d7 33       	scall
800054d6:	c0 a8       	rjmp	800054ea <xQueueGenericReceive+0x72>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
800054d8:	8f 36       	st.w	r7[0xc],r6

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800054da:	6e 98       	ld.w	r8,r7[0x24]
800054dc:	58 08       	cp.w	r8,0
800054de:	c0 60       	breq	800054ea <xQueueGenericReceive+0x72>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
800054e0:	04 9c       	mov	r12,r2
800054e2:	f0 1f 00 2e 	mcall	80005598 <xQueueGenericReceive+0x120>
800054e6:	c0 20       	breq	800054ea <xQueueGenericReceive+0x72>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
800054e8:	d7 33       	scall
						}
					}

				}

				taskEXIT_CRITICAL();
800054ea:	f0 1f 00 2d 	mcall	8000559c <xQueueGenericReceive+0x124>
800054ee:	30 1c       	mov	r12,1
				return pdPASS;
800054f0:	c4 c8       	rjmp	80005588 <xQueueGenericReceive+0x110>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
800054f2:	40 28       	lddsp	r8,sp[0x8]
800054f4:	58 08       	cp.w	r8,0
800054f6:	c0 51       	brne	80005500 <xQueueGenericReceive+0x88>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
800054f8:	f0 1f 00 29 	mcall	8000559c <xQueueGenericReceive+0x124>
800054fc:	30 0c       	mov	r12,0
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
800054fe:	c4 58       	rjmp	80005588 <xQueueGenericReceive+0x110>
				}
				else if( xEntryTimeSet == pdFALSE )
80005500:	58 05       	cp.w	r5,0
80005502:	c0 51       	brne	8000550c <xQueueGenericReceive+0x94>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80005504:	08 9c       	mov	r12,r4
80005506:	f0 1f 00 27 	mcall	800055a0 <xQueueGenericReceive+0x128>
8000550a:	00 95       	mov	r5,r0
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
8000550c:	f0 1f 00 24 	mcall	8000559c <xQueueGenericReceive+0x124>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80005510:	f0 1f 00 25 	mcall	800055a4 <xQueueGenericReceive+0x12c>
		prvLockQueue( pxQueue );
80005514:	f0 1f 00 1e 	mcall	8000558c <xQueueGenericReceive+0x114>
80005518:	6f 18       	ld.w	r8,r7[0x44]
8000551a:	5b f8       	cp.w	r8,-1
8000551c:	ef f1 0a 11 	st.weq	r7[0x44],r1
80005520:	6f 28       	ld.w	r8,r7[0x48]
80005522:	5b f8       	cp.w	r8,-1
80005524:	ef f1 0a 12 	st.weq	r7[0x48],r1
80005528:	f0 1f 00 1d 	mcall	8000559c <xQueueGenericReceive+0x124>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
8000552c:	06 9b       	mov	r11,r3
8000552e:	08 9c       	mov	r12,r4
80005530:	f0 1f 00 1e 	mcall	800055a8 <xQueueGenericReceive+0x130>
80005534:	c2 41       	brne	8000557c <xQueueGenericReceive+0x104>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80005536:	f0 1f 00 16 	mcall	8000558c <xQueueGenericReceive+0x114>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
8000553a:	6e e6       	ld.w	r6,r7[0x38]
	taskEXIT_CRITICAL();
8000553c:	f0 1f 00 18 	mcall	8000559c <xQueueGenericReceive+0x124>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
80005540:	58 06       	cp.w	r6,0
80005542:	c1 71       	brne	80005570 <xQueueGenericReceive+0xf8>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80005544:	6e 08       	ld.w	r8,r7[0x0]
80005546:	58 08       	cp.w	r8,0
80005548:	c0 81       	brne	80005558 <xQueueGenericReceive+0xe0>
					{
						portENTER_CRITICAL();
8000554a:	f0 1f 00 11 	mcall	8000558c <xQueueGenericReceive+0x114>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
8000554e:	6e 1c       	ld.w	r12,r7[0x4]
80005550:	f0 1f 00 17 	mcall	800055ac <xQueueGenericReceive+0x134>
						}
						portEXIT_CRITICAL();
80005554:	f0 1f 00 12 	mcall	8000559c <xQueueGenericReceive+0x124>
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80005558:	40 2b       	lddsp	r11,sp[0x8]
8000555a:	04 9c       	mov	r12,r2
8000555c:	f0 1f 00 15 	mcall	800055b0 <xQueueGenericReceive+0x138>
				prvUnlockQueue( pxQueue );
80005560:	0e 9c       	mov	r12,r7
80005562:	f0 1f 00 15 	mcall	800055b4 <xQueueGenericReceive+0x13c>
				if( !xTaskResumeAll() )
80005566:	f0 1f 00 15 	mcall	800055b8 <xQueueGenericReceive+0x140>
8000556a:	c9 61       	brne	80005496 <xQueueGenericReceive+0x1e>
				{
					portYIELD_WITHIN_API();
8000556c:	d7 33       	scall
8000556e:	c9 4b       	rjmp	80005496 <xQueueGenericReceive+0x1e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80005570:	0e 9c       	mov	r12,r7
80005572:	f0 1f 00 11 	mcall	800055b4 <xQueueGenericReceive+0x13c>
				( void ) xTaskResumeAll();
80005576:	f0 1f 00 11 	mcall	800055b8 <xQueueGenericReceive+0x140>
8000557a:	c8 eb       	rjmp	80005496 <xQueueGenericReceive+0x1e>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
8000557c:	0e 9c       	mov	r12,r7
8000557e:	f0 1f 00 0e 	mcall	800055b4 <xQueueGenericReceive+0x13c>
			( void ) xTaskResumeAll();
80005582:	f0 1f 00 0e 	mcall	800055b8 <xQueueGenericReceive+0x140>
80005586:	30 0c       	mov	r12,0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
80005588:	2f bd       	sub	sp,-20
8000558a:	d8 32       	popm	r0-r7,pc
8000558c:	80 00       	ld.sh	r0,r0[0x0]
8000558e:	50 c4       	stdsp	sp[0x30],r4
80005590:	80 00       	ld.sh	r0,r0[0x0]
80005592:	53 58       	stdsp	sp[0xd4],r8
80005594:	80 00       	ld.sh	r0,r0[0x0]
80005596:	59 00       	cp.w	r0,16
80005598:	80 00       	ld.sh	r0,r0[0x0]
8000559a:	59 e8       	cp.w	r8,30
8000559c:	80 00       	ld.sh	r0,r0[0x0]
8000559e:	51 d0       	stdsp	sp[0x74],r0
800055a0:	80 00       	ld.sh	r0,r0[0x0]
800055a2:	58 dc       	cp.w	r12,13
800055a4:	80 00       	ld.sh	r0,r0[0x0]
800055a6:	58 50       	cp.w	r0,5
800055a8:	80 00       	ld.sh	r0,r0[0x0]
800055aa:	5b 78       	cp.w	r8,-9
800055ac:	80 00       	ld.sh	r0,r0[0x0]
800055ae:	59 64       	cp.w	r4,22
800055b0:	80 00       	ld.sh	r0,r0[0x0]
800055b2:	5d d0       	*unknown*
800055b4:	80 00       	ld.sh	r0,r0[0x0]
800055b6:	53 d8       	stdsp	sp[0xf4],r8
800055b8:	80 00       	ld.sh	r0,r0[0x0]
800055ba:	5c 0c       	acr	r12

800055bc <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
800055bc:	eb cd 40 80 	pushm	r7,lr
800055c0:	18 97       	mov	r7,r12
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
800055c2:	79 08       	ld.w	r8,r12[0x40]
800055c4:	58 08       	cp.w	r8,0
800055c6:	c0 a1       	brne	800055da <prvCopyDataToQueue+0x1e>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
800055c8:	78 08       	ld.w	r8,r12[0x0]
800055ca:	58 08       	cp.w	r8,0
800055cc:	c2 b1       	brne	80005622 <prvCopyDataToQueue+0x66>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
800055ce:	78 1c       	ld.w	r12,r12[0x4]
800055d0:	f0 1f 00 17 	mcall	8000562c <prvCopyDataToQueue+0x70>
				pxQueue->pxMutexHolder = NULL;
800055d4:	30 08       	mov	r8,0
800055d6:	8f 18       	st.w	r7[0x4],r8
800055d8:	c2 58       	rjmp	80005622 <prvCopyDataToQueue+0x66>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
800055da:	58 0a       	cp.w	r10,0
800055dc:	c1 01       	brne	800055fc <prvCopyDataToQueue+0x40>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
800055de:	10 9a       	mov	r10,r8
800055e0:	78 2c       	ld.w	r12,r12[0x8]
800055e2:	f0 1f 00 14 	mcall	80005630 <prvCopyDataToQueue+0x74>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
800055e6:	6e 29       	ld.w	r9,r7[0x8]
800055e8:	6f 08       	ld.w	r8,r7[0x40]
800055ea:	f2 08 00 08 	add	r8,r9,r8
800055ee:	8f 28       	st.w	r7[0x8],r8
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
800055f0:	6e 19       	ld.w	r9,r7[0x4]
800055f2:	12 38       	cp.w	r8,r9
800055f4:	c1 73       	brcs	80005622 <prvCopyDataToQueue+0x66>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
800055f6:	6e 08       	ld.w	r8,r7[0x0]
800055f8:	8f 28       	st.w	r7[0x8],r8
800055fa:	c1 48       	rjmp	80005622 <prvCopyDataToQueue+0x66>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
800055fc:	10 9a       	mov	r10,r8
800055fe:	78 3c       	ld.w	r12,r12[0xc]
80005600:	f0 1f 00 0c 	mcall	80005630 <prvCopyDataToQueue+0x74>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
80005604:	6f 08       	ld.w	r8,r7[0x40]
80005606:	6e 39       	ld.w	r9,r7[0xc]
80005608:	f2 08 01 08 	sub	r8,r9,r8
8000560c:	8f 38       	st.w	r7[0xc],r8
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
8000560e:	6e 09       	ld.w	r9,r7[0x0]
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
80005610:	12 38       	cp.w	r8,r9
80005612:	ef f8 30 10 	ld.wcs	r8,r7[0x40]
80005616:	ef f9 30 01 	ld.wcs	r9,r7[0x4]
8000561a:	f3 d8 e3 19 	subcs	r9,r9,r8
8000561e:	ef f9 3a 03 	st.wcs	r7[0xc],r9
		}
	}

	++( pxQueue->uxMessagesWaiting );
80005622:	6e e8       	ld.w	r8,r7[0x38]
80005624:	2f f8       	sub	r8,-1
80005626:	8f e8       	st.w	r7[0x38],r8
}
80005628:	e3 cd 80 80 	ldm	sp++,r7,pc
8000562c:	80 00       	ld.sh	r0,r0[0x0]
8000562e:	59 0c       	cp.w	r12,16
80005630:	80 00       	ld.sh	r0,r0[0x0]
80005632:	6b d4       	ld.w	r4,r5[0x74]

80005634 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
80005634:	eb cd 40 c0 	pushm	r6-r7,lr
80005638:	18 97       	mov	r7,r12
8000563a:	14 96       	mov	r6,r10
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
8000563c:	78 ec       	ld.w	r12,r12[0x38]
8000563e:	6e f8       	ld.w	r8,r7[0x3c]
80005640:	10 3c       	cp.w	r12,r8
80005642:	c0 33       	brcs	80005648 <xQueueGenericSendFromISR+0x14>
80005644:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80005648:	12 9a       	mov	r10,r9
8000564a:	0e 9c       	mov	r12,r7
8000564c:	f0 1f 00 0c 	mcall	8000567c <xQueueGenericSendFromISR+0x48>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
80005650:	6f 28       	ld.w	r8,r7[0x48]
80005652:	5b f8       	cp.w	r8,-1
80005654:	c0 d1       	brne	8000566e <xQueueGenericSendFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005656:	6e 98       	ld.w	r8,r7[0x24]
80005658:	58 08       	cp.w	r8,0
8000565a:	c0 f0       	breq	80005678 <xQueueGenericSendFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
8000565c:	ee cc ff dc 	sub	r12,r7,-36
80005660:	f0 1f 00 08 	mcall	80005680 <xQueueGenericSendFromISR+0x4c>
80005664:	c0 a0       	breq	80005678 <xQueueGenericSendFromISR+0x44>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
80005666:	30 1c       	mov	r12,1
80005668:	8d 0c       	st.w	r6[0x0],r12
8000566a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
8000566e:	2f f8       	sub	r8,-1
80005670:	ef 48 00 48 	st.w	r7[72],r8
80005674:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80005678:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
8000567c:	80 00       	ld.sh	r0,r0[0x0]
8000567e:	55 bc       	stdsp	sp[0x16c],r12
80005680:	80 00       	ld.sh	r0,r0[0x0]
80005682:	59 e8       	cp.w	r8,30

80005684 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
80005684:	d4 31       	pushm	r0-r7,lr
80005686:	20 5d       	sub	sp,20
80005688:	18 97       	mov	r7,r12
8000568a:	50 0b       	stdsp	sp[0x0],r11
8000568c:	50 2a       	stdsp	sp[0x8],r10
8000568e:	50 19       	stdsp	sp[0x4],r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
80005690:	f8 c0 ff f0 	sub	r0,r12,-16
80005694:	30 04       	mov	r4,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80005696:	fa c3 ff f4 	sub	r3,sp,-12

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
8000569a:	08 91       	mov	r1,r4

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
8000569c:	fa c2 ff f8 	sub	r2,sp,-8
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
800056a0:	f0 1f 00 2f 	mcall	8000575c <xQueueGenericSend+0xd8>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
800056a4:	6e e9       	ld.w	r9,r7[0x38]
800056a6:	6e f8       	ld.w	r8,r7[0x3c]
800056a8:	10 39       	cp.w	r9,r8
800056aa:	c1 42       	brcc	800056d2 <xQueueGenericSend+0x4e>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
800056ac:	40 1a       	lddsp	r10,sp[0x4]
800056ae:	40 0b       	lddsp	r11,sp[0x0]
800056b0:	0e 9c       	mov	r12,r7
800056b2:	f0 1f 00 2c 	mcall	80005760 <xQueueGenericSend+0xdc>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800056b6:	6e 98       	ld.w	r8,r7[0x24]
800056b8:	58 08       	cp.w	r8,0
800056ba:	c0 80       	breq	800056ca <xQueueGenericSend+0x46>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
800056bc:	ee cc ff dc 	sub	r12,r7,-36
800056c0:	f0 1f 00 29 	mcall	80005764 <xQueueGenericSend+0xe0>
800056c4:	58 1c       	cp.w	r12,1
800056c6:	c0 21       	brne	800056ca <xQueueGenericSend+0x46>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
800056c8:	d7 33       	scall
					}
				}

				taskEXIT_CRITICAL();
800056ca:	f0 1f 00 28 	mcall	80005768 <xQueueGenericSend+0xe4>
800056ce:	30 1c       	mov	r12,1

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
800056d0:	c4 38       	rjmp	80005756 <xQueueGenericSend+0xd2>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
800056d2:	40 28       	lddsp	r8,sp[0x8]
800056d4:	58 08       	cp.w	r8,0
800056d6:	c0 51       	brne	800056e0 <xQueueGenericSend+0x5c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
800056d8:	f0 1f 00 24 	mcall	80005768 <xQueueGenericSend+0xe4>
800056dc:	30 0c       	mov	r12,0

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
800056de:	c3 c8       	rjmp	80005756 <xQueueGenericSend+0xd2>
				}
				else if( xEntryTimeSet == pdFALSE )
800056e0:	58 04       	cp.w	r4,0
800056e2:	c0 51       	brne	800056ec <xQueueGenericSend+0x68>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
800056e4:	06 9c       	mov	r12,r3
800056e6:	f0 1f 00 22 	mcall	8000576c <xQueueGenericSend+0xe8>
800056ea:	30 14       	mov	r4,1
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
800056ec:	f0 1f 00 1f 	mcall	80005768 <xQueueGenericSend+0xe4>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
800056f0:	f0 1f 00 20 	mcall	80005770 <xQueueGenericSend+0xec>
		prvLockQueue( pxQueue );
800056f4:	f0 1f 00 1a 	mcall	8000575c <xQueueGenericSend+0xd8>
800056f8:	6f 18       	ld.w	r8,r7[0x44]
800056fa:	5b f8       	cp.w	r8,-1
800056fc:	ef f1 0a 11 	st.weq	r7[0x44],r1
80005700:	6f 28       	ld.w	r8,r7[0x48]
80005702:	5b f8       	cp.w	r8,-1
80005704:	ef f1 0a 12 	st.weq	r7[0x48],r1
80005708:	f0 1f 00 18 	mcall	80005768 <xQueueGenericSend+0xe4>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
8000570c:	04 9b       	mov	r11,r2
8000570e:	06 9c       	mov	r12,r3
80005710:	f0 1f 00 19 	mcall	80005774 <xQueueGenericSend+0xf0>
80005714:	c1 b1       	brne	8000574a <xQueueGenericSend+0xc6>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80005716:	f0 1f 00 12 	mcall	8000575c <xQueueGenericSend+0xd8>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
8000571a:	6e e5       	ld.w	r5,r7[0x38]
8000571c:	6e f6       	ld.w	r6,r7[0x3c]
	taskEXIT_CRITICAL();
8000571e:	f0 1f 00 13 	mcall	80005768 <xQueueGenericSend+0xe4>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
80005722:	0c 35       	cp.w	r5,r6
80005724:	c0 d1       	brne	8000573e <xQueueGenericSend+0xba>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
80005726:	40 2b       	lddsp	r11,sp[0x8]
80005728:	00 9c       	mov	r12,r0
8000572a:	f0 1f 00 14 	mcall	80005778 <xQueueGenericSend+0xf4>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
8000572e:	0e 9c       	mov	r12,r7
80005730:	f0 1f 00 13 	mcall	8000577c <xQueueGenericSend+0xf8>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
80005734:	f0 1f 00 13 	mcall	80005780 <xQueueGenericSend+0xfc>
80005738:	cb 41       	brne	800056a0 <xQueueGenericSend+0x1c>
				{
					portYIELD_WITHIN_API();
8000573a:	d7 33       	scall
8000573c:	cb 2b       	rjmp	800056a0 <xQueueGenericSend+0x1c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
8000573e:	0e 9c       	mov	r12,r7
80005740:	f0 1f 00 0f 	mcall	8000577c <xQueueGenericSend+0xf8>
				( void ) xTaskResumeAll();
80005744:	f0 1f 00 0f 	mcall	80005780 <xQueueGenericSend+0xfc>
80005748:	ca cb       	rjmp	800056a0 <xQueueGenericSend+0x1c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
8000574a:	0e 9c       	mov	r12,r7
8000574c:	f0 1f 00 0c 	mcall	8000577c <xQueueGenericSend+0xf8>
			( void ) xTaskResumeAll();
80005750:	f0 1f 00 0c 	mcall	80005780 <xQueueGenericSend+0xfc>
80005754:	30 0c       	mov	r12,0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
80005756:	2f bd       	sub	sp,-20
80005758:	d8 32       	popm	r0-r7,pc
8000575a:	00 00       	add	r0,r0
8000575c:	80 00       	ld.sh	r0,r0[0x0]
8000575e:	50 c4       	stdsp	sp[0x30],r4
80005760:	80 00       	ld.sh	r0,r0[0x0]
80005762:	55 bc       	stdsp	sp[0x16c],r12
80005764:	80 00       	ld.sh	r0,r0[0x0]
80005766:	59 e8       	cp.w	r8,30
80005768:	80 00       	ld.sh	r0,r0[0x0]
8000576a:	51 d0       	stdsp	sp[0x74],r0
8000576c:	80 00       	ld.sh	r0,r0[0x0]
8000576e:	58 dc       	cp.w	r12,13
80005770:	80 00       	ld.sh	r0,r0[0x0]
80005772:	58 50       	cp.w	r0,5
80005774:	80 00       	ld.sh	r0,r0[0x0]
80005776:	5b 78       	cp.w	r8,-9
80005778:	80 00       	ld.sh	r0,r0[0x0]
8000577a:	5d d0       	*unknown*
8000577c:	80 00       	ld.sh	r0,r0[0x0]
8000577e:	53 d8       	stdsp	sp[0xf4],r8
80005780:	80 00       	ld.sh	r0,r0[0x0]
80005782:	5c 0c       	acr	r12

80005784 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	xQueueHandle xQueueCreateMutex( void )
	{
80005784:	eb cd 40 c0 	pushm	r6-r7,lr
	xQUEUE *pxNewQueue;

		/* Allocate the new queue structure. */
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
80005788:	34 cc       	mov	r12,76
8000578a:	f0 1f 00 12 	mcall	800057d0 <xQueueCreateMutex+0x4c>
8000578e:	18 97       	mov	r7,r12
		if( pxNewQueue != NULL )
80005790:	c1 d0       	breq	800057ca <xQueueCreateMutex+0x46>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
80005792:	30 06       	mov	r6,0
80005794:	99 16       	st.w	r12[0x4],r6
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
80005796:	99 06       	st.w	r12[0x0],r6

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
80005798:	99 26       	st.w	r12[0x8],r6
			pxNewQueue->pcReadFrom = NULL;
8000579a:	99 36       	st.w	r12[0xc],r6

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
8000579c:	99 e6       	st.w	r12[0x38],r6
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
8000579e:	30 18       	mov	r8,1
800057a0:	99 f8       	st.w	r12[0x3c],r8
			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
800057a2:	f9 46 00 40 	st.w	r12[64],r6
			pxNewQueue->xRxLock = queueUNLOCKED;
800057a6:	3f f8       	mov	r8,-1
800057a8:	f9 48 00 44 	st.w	r12[68],r8
			pxNewQueue->xTxLock = queueUNLOCKED;
800057ac:	f9 48 00 48 	st.w	r12[72],r8

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
800057b0:	2f 0c       	sub	r12,-16
800057b2:	f0 1f 00 09 	mcall	800057d4 <xQueueCreateMutex+0x50>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
800057b6:	ee cc ff dc 	sub	r12,r7,-36
800057ba:	f0 1f 00 07 	mcall	800057d4 <xQueueCreateMutex+0x50>

			/* Start with the semaphore in the expected state. */
			xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
800057be:	0c 99       	mov	r9,r6
800057c0:	0c 9a       	mov	r10,r6
800057c2:	0c 9b       	mov	r11,r6
800057c4:	0e 9c       	mov	r12,r7
800057c6:	f0 1f 00 05 	mcall	800057d8 <xQueueCreateMutex+0x54>
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
800057ca:	0e 9c       	mov	r12,r7
800057cc:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800057d0:	80 00       	ld.sh	r0,r0[0x0]
800057d2:	53 30       	stdsp	sp[0xcc],r0
800057d4:	80 00       	ld.sh	r0,r0[0x0]
800057d6:	4f a0       	lddpc	r0,800059bc <vTaskPriorityInherit+0x58>
800057d8:	80 00       	ld.sh	r0,r0[0x0]
800057da:	56 84       	stdsp	sp[0x1a0],r4

800057dc <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
800057dc:	d4 21       	pushm	r4-r7,lr
800057de:	18 97       	mov	r7,r12
800057e0:	16 96       	mov	r6,r11
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
800057e2:	58 0c       	cp.w	r12,0
800057e4:	c2 f0       	breq	80005842 <xQueueCreate+0x66>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
800057e6:	34 cc       	mov	r12,76
800057e8:	f0 1f 00 17 	mcall	80005844 <xQueueCreate+0x68>
800057ec:	18 95       	mov	r5,r12
		if( pxNewQueue != NULL )
800057ee:	c2 a0       	breq	80005842 <xQueueCreate+0x66>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
800057f0:	ec 07 02 44 	mul	r4,r6,r7

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
800057f4:	e8 cc ff ff 	sub	r12,r4,-1
800057f8:	f0 1f 00 13 	mcall	80005844 <xQueueCreate+0x68>
800057fc:	8b 0c       	st.w	r5[0x0],r12
			if( pxNewQueue->pcHead != NULL )
800057fe:	c1 e0       	breq	8000583a <xQueueCreate+0x5e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
80005800:	f8 04 00 04 	add	r4,r12,r4
80005804:	8b 14       	st.w	r5[0x4],r4
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
80005806:	30 08       	mov	r8,0
80005808:	8b e8       	st.w	r5[0x38],r8
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
8000580a:	8b 2c       	st.w	r5[0x8],r12
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
8000580c:	ee c8 00 01 	sub	r8,r7,1
80005810:	ad 38       	mul	r8,r6
80005812:	10 0c       	add	r12,r8
80005814:	8b 3c       	st.w	r5[0xc],r12
				pxNewQueue->uxLength = uxQueueLength;
80005816:	8b f7       	st.w	r5[0x3c],r7
				pxNewQueue->uxItemSize = uxItemSize;
80005818:	eb 46 00 40 	st.w	r5[64],r6
				pxNewQueue->xRxLock = queueUNLOCKED;
8000581c:	3f f8       	mov	r8,-1
8000581e:	eb 48 00 44 	st.w	r5[68],r8
				pxNewQueue->xTxLock = queueUNLOCKED;
80005822:	eb 48 00 48 	st.w	r5[72],r8

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
80005826:	ea cc ff f0 	sub	r12,r5,-16
8000582a:	f0 1f 00 08 	mcall	80005848 <xQueueCreate+0x6c>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
8000582e:	ea cc ff dc 	sub	r12,r5,-36
80005832:	f0 1f 00 06 	mcall	80005848 <xQueueCreate+0x6c>
80005836:	0a 9c       	mov	r12,r5
80005838:	d8 22       	popm	r4-r7,pc
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
8000583a:	0a 9c       	mov	r12,r5
8000583c:	f0 1f 00 04 	mcall	8000584c <xQueueCreate+0x70>
80005840:	d8 2a       	popm	r4-r7,pc,r12=0
80005842:	d8 2a       	popm	r4-r7,pc,r12=0
80005844:	80 00       	ld.sh	r0,r0[0x0]
80005846:	53 30       	stdsp	sp[0xcc],r0
80005848:	80 00       	ld.sh	r0,r0[0x0]
8000584a:	4f a0       	lddpc	r0,80005a30 <xTaskRemoveFromEventList+0x48>
8000584c:	80 00       	ld.sh	r0,r0[0x0]
8000584e:	53 08       	stdsp	sp[0xc0],r8

80005850 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
80005850:	48 38       	lddpc	r8,8000585c <vTaskSuspendAll+0xc>
80005852:	70 09       	ld.w	r9,r8[0x0]
80005854:	2f f9       	sub	r9,-1
80005856:	91 09       	st.w	r8[0x0],r9
}
80005858:	5e fc       	retal	r12
8000585a:	00 00       	add	r0,r0
8000585c:	00 00       	add	r0,r0
8000585e:	0d 1c       	ld.sh	r12,r6++

80005860 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
80005860:	49 a8       	lddpc	r8,800058c8 <vTaskSwitchContext+0x68>
80005862:	70 08       	ld.w	r8,r8[0x0]
80005864:	58 08       	cp.w	r8,0
80005866:	c0 b1       	brne	8000587c <vTaskSwitchContext+0x1c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80005868:	49 98       	lddpc	r8,800058cc <vTaskSwitchContext+0x6c>
8000586a:	70 08       	ld.w	r8,r8[0x0]
8000586c:	f0 08 00 28 	add	r8,r8,r8<<0x2
80005870:	49 89       	lddpc	r9,800058d0 <vTaskSwitchContext+0x70>
80005872:	f2 08 03 28 	ld.w	r8,r9[r8<<0x2]
80005876:	58 08       	cp.w	r8,0
80005878:	c0 60       	breq	80005884 <vTaskSwitchContext+0x24>
8000587a:	c1 18       	rjmp	8000589c <vTaskSwitchContext+0x3c>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
8000587c:	30 19       	mov	r9,1
8000587e:	49 68       	lddpc	r8,800058d4 <vTaskSwitchContext+0x74>
80005880:	91 09       	st.w	r8[0x0],r9
80005882:	5e fc       	retal	r12

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80005884:	49 28       	lddpc	r8,800058cc <vTaskSwitchContext+0x6c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80005886:	49 3a       	lddpc	r10,800058d0 <vTaskSwitchContext+0x70>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80005888:	70 09       	ld.w	r9,r8[0x0]
8000588a:	20 19       	sub	r9,1
8000588c:	91 09       	st.w	r8[0x0],r9

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
8000588e:	70 09       	ld.w	r9,r8[0x0]
80005890:	f2 09 00 29 	add	r9,r9,r9<<0x2
80005894:	f4 09 03 29 	ld.w	r9,r10[r9<<0x2]
80005898:	58 09       	cp.w	r9,0
8000589a:	cf 70       	breq	80005888 <vTaskSwitchContext+0x28>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
8000589c:	48 c8       	lddpc	r8,800058cc <vTaskSwitchContext+0x6c>
8000589e:	70 08       	ld.w	r8,r8[0x0]
800058a0:	f0 08 00 28 	add	r8,r8,r8<<0x2
800058a4:	48 b9       	lddpc	r9,800058d0 <vTaskSwitchContext+0x70>
800058a6:	f2 08 00 28 	add	r8,r9,r8<<0x2
800058aa:	70 19       	ld.w	r9,r8[0x4]
800058ac:	72 19       	ld.w	r9,r9[0x4]
800058ae:	91 19       	st.w	r8[0x4],r9
800058b0:	f0 ca ff f8 	sub	r10,r8,-8
800058b4:	14 39       	cp.w	r9,r10
800058b6:	f3 f9 00 01 	ld.weq	r9,r9[0x4]
800058ba:	f1 f9 0a 01 	st.weq	r8[0x4],r9
800058be:	70 18       	ld.w	r8,r8[0x4]
800058c0:	70 39       	ld.w	r9,r8[0xc]
800058c2:	48 68       	lddpc	r8,800058d8 <vTaskSwitchContext+0x78>
800058c4:	91 09       	st.w	r8[0x0],r9
800058c6:	5e fc       	retal	r12
800058c8:	00 00       	add	r0,r0
800058ca:	0d 1c       	ld.sh	r12,r6++
800058cc:	00 00       	add	r0,r0
800058ce:	0d 54       	ld.sh	r4,--r6
800058d0:	00 00       	add	r0,r0
800058d2:	0c 38       	cp.w	r8,r6
800058d4:	00 00       	add	r0,r0
800058d6:	0d 3c       	ld.ub	r12,r6++
800058d8:	00 00       	add	r0,r0
800058da:	0c ec       	st.h	--r6,r12

800058dc <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
800058dc:	48 48       	lddpc	r8,800058ec <vTaskSetTimeOutState+0x10>
800058de:	70 08       	ld.w	r8,r8[0x0]
800058e0:	99 08       	st.w	r12[0x0],r8
	pxTimeOut->xTimeOnEntering = xTickCount;
800058e2:	48 48       	lddpc	r8,800058f0 <vTaskSetTimeOutState+0x14>
800058e4:	70 08       	ld.w	r8,r8[0x0]
800058e6:	99 18       	st.w	r12[0x4],r8
}
800058e8:	5e fc       	retal	r12
800058ea:	00 00       	add	r0,r0
800058ec:	00 00       	add	r0,r0
800058ee:	0c 30       	cp.w	r0,r6
800058f0:	00 00       	add	r0,r0
800058f2:	0d 18       	ld.sh	r8,r6++

800058f4 <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
800058f4:	30 19       	mov	r9,1
800058f6:	48 28       	lddpc	r8,800058fc <vTaskMissedYield+0x8>
800058f8:	91 09       	st.w	r8[0x0],r9
}
800058fa:	5e fc       	retal	r12
800058fc:	00 00       	add	r0,r0
800058fe:	0d 3c       	ld.ub	r12,r6++

80005900 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
80005900:	48 28       	lddpc	r8,80005908 <xTaskGetCurrentTaskHandle+0x8>
80005902:	70 0c       	ld.w	r12,r8[0x0]

		return xReturn;
	}
80005904:	5e fc       	retal	r12
80005906:	00 00       	add	r0,r0
80005908:	00 00       	add	r0,r0
8000590a:	0c ec       	st.h	--r6,r12

8000590c <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
8000590c:	eb cd 40 c0 	pushm	r6-r7,lr
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
80005910:	58 0c       	cp.w	r12,0
80005912:	c1 f0       	breq	80005950 <vTaskPriorityDisinherit+0x44>

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
80005914:	18 97       	mov	r7,r12

		if( pxMutexHolder != NULL )
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
80005916:	78 b9       	ld.w	r9,r12[0x2c]
80005918:	79 18       	ld.w	r8,r12[0x44]
8000591a:	10 39       	cp.w	r9,r8
8000591c:	c1 a0       	breq	80005950 <vTaskPriorityDisinherit+0x44>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
8000591e:	f8 c6 ff fc 	sub	r6,r12,-4
80005922:	0c 9c       	mov	r12,r6
80005924:	f0 1f 00 0c 	mcall	80005954 <vTaskPriorityDisinherit+0x48>

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
80005928:	6f 1c       	ld.w	r12,r7[0x44]
8000592a:	8f bc       	st.w	r7[0x2c],r12
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
8000592c:	f8 08 11 08 	rsub	r8,r12,8
80005930:	8f 68       	st.w	r7[0x18],r8
				prvAddTaskToReadyQueue( pxTCB );
80005932:	48 a8       	lddpc	r8,80005958 <vTaskPriorityDisinherit+0x4c>
80005934:	70 08       	ld.w	r8,r8[0x0]
80005936:	10 3c       	cp.w	r12,r8
80005938:	e0 88 00 04 	brls	80005940 <vTaskPriorityDisinherit+0x34>
8000593c:	48 78       	lddpc	r8,80005958 <vTaskPriorityDisinherit+0x4c>
8000593e:	91 0c       	st.w	r8[0x0],r12
80005940:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005944:	0c 9b       	mov	r11,r6
80005946:	48 68       	lddpc	r8,8000595c <vTaskPriorityDisinherit+0x50>
80005948:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
8000594c:	f0 1f 00 05 	mcall	80005960 <vTaskPriorityDisinherit+0x54>
80005950:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005954:	80 00       	ld.sh	r0,r0[0x0]
80005956:	50 0a       	stdsp	sp[0x0],r10
80005958:	00 00       	add	r0,r0
8000595a:	0d 54       	ld.sh	r4,--r6
8000595c:	00 00       	add	r0,r0
8000595e:	0c 38       	cp.w	r8,r6
80005960:	80 00       	ld.sh	r0,r0[0x0]
80005962:	4f ba       	lddpc	r10,80005b4c <vTaskIncrementTick+0xe8>

80005964 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
80005964:	eb cd 40 c0 	pushm	r6-r7,lr
80005968:	18 97       	mov	r7,r12
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
8000596a:	49 b8       	lddpc	r8,800059d4 <vTaskPriorityInherit+0x70>
8000596c:	70 08       	ld.w	r8,r8[0x0]
8000596e:	78 b9       	ld.w	r9,r12[0x2c]
80005970:	70 b8       	ld.w	r8,r8[0x2c]
80005972:	10 39       	cp.w	r9,r8
80005974:	c2 d2       	brcc	800059ce <vTaskPriorityInherit+0x6a>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
80005976:	49 88       	lddpc	r8,800059d4 <vTaskPriorityInherit+0x70>
80005978:	70 08       	ld.w	r8,r8[0x0]
8000597a:	70 b8       	ld.w	r8,r8[0x2c]
8000597c:	f0 08 11 08 	rsub	r8,r8,8
80005980:	99 68       	st.w	r12[0x18],r8

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
80005982:	f2 09 00 28 	add	r8,r9,r9<<0x2
80005986:	49 59       	lddpc	r9,800059d8 <vTaskPriorityInherit+0x74>
80005988:	f2 08 00 28 	add	r8,r9,r8<<0x2
8000598c:	78 59       	ld.w	r9,r12[0x14]
8000598e:	10 39       	cp.w	r9,r8
80005990:	c1 b1       	brne	800059c6 <vTaskPriorityInherit+0x62>
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
80005992:	f8 c6 ff fc 	sub	r6,r12,-4
80005996:	0c 9c       	mov	r12,r6
80005998:	f0 1f 00 11 	mcall	800059dc <vTaskPriorityInherit+0x78>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
8000599c:	48 e8       	lddpc	r8,800059d4 <vTaskPriorityInherit+0x70>
8000599e:	70 08       	ld.w	r8,r8[0x0]
800059a0:	70 bc       	ld.w	r12,r8[0x2c]
800059a2:	8f bc       	st.w	r7[0x2c],r12
				prvAddTaskToReadyQueue( pxTCB );
800059a4:	48 f8       	lddpc	r8,800059e0 <vTaskPriorityInherit+0x7c>
800059a6:	70 08       	ld.w	r8,r8[0x0]
800059a8:	10 3c       	cp.w	r12,r8
800059aa:	e0 88 00 04 	brls	800059b2 <vTaskPriorityInherit+0x4e>
800059ae:	48 d8       	lddpc	r8,800059e0 <vTaskPriorityInherit+0x7c>
800059b0:	91 0c       	st.w	r8[0x0],r12
800059b2:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800059b6:	0c 9b       	mov	r11,r6
800059b8:	48 88       	lddpc	r8,800059d8 <vTaskPriorityInherit+0x74>
800059ba:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800059be:	f0 1f 00 0a 	mcall	800059e4 <vTaskPriorityInherit+0x80>
800059c2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
800059c6:	48 48       	lddpc	r8,800059d4 <vTaskPriorityInherit+0x70>
800059c8:	70 08       	ld.w	r8,r8[0x0]
800059ca:	70 b8       	ld.w	r8,r8[0x2c]
800059cc:	99 b8       	st.w	r12[0x2c],r8
800059ce:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800059d2:	00 00       	add	r0,r0
800059d4:	00 00       	add	r0,r0
800059d6:	0c ec       	st.h	--r6,r12
800059d8:	00 00       	add	r0,r0
800059da:	0c 38       	cp.w	r8,r6
800059dc:	80 00       	ld.sh	r0,r0[0x0]
800059de:	50 0a       	stdsp	sp[0x0],r10
800059e0:	00 00       	add	r0,r0
800059e2:	0d 54       	ld.sh	r4,--r6
800059e4:	80 00       	ld.sh	r0,r0[0x0]
800059e6:	4f ba       	lddpc	r10,80005bd0 <xTaskCheckForTimeOut+0x58>

800059e8 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
800059e8:	eb cd 40 c0 	pushm	r6-r7,lr
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
800059ec:	78 38       	ld.w	r8,r12[0xc]
800059ee:	70 37       	ld.w	r7,r8[0xc]
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
800059f0:	ee c6 ff e8 	sub	r6,r7,-24
800059f4:	0c 9c       	mov	r12,r6
800059f6:	f0 1f 00 15 	mcall	80005a48 <xTaskRemoveFromEventList+0x60>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
800059fa:	49 58       	lddpc	r8,80005a4c <xTaskRemoveFromEventList+0x64>
800059fc:	70 08       	ld.w	r8,r8[0x0]
800059fe:	58 08       	cp.w	r8,0
80005a00:	c1 71       	brne	80005a2e <xTaskRemoveFromEventList+0x46>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
80005a02:	ee c6 ff fc 	sub	r6,r7,-4
80005a06:	0c 9c       	mov	r12,r6
80005a08:	f0 1f 00 10 	mcall	80005a48 <xTaskRemoveFromEventList+0x60>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
80005a0c:	6e bc       	ld.w	r12,r7[0x2c]
80005a0e:	49 18       	lddpc	r8,80005a50 <xTaskRemoveFromEventList+0x68>
80005a10:	70 08       	ld.w	r8,r8[0x0]
80005a12:	10 3c       	cp.w	r12,r8
80005a14:	e0 88 00 04 	brls	80005a1c <xTaskRemoveFromEventList+0x34>
80005a18:	48 e8       	lddpc	r8,80005a50 <xTaskRemoveFromEventList+0x68>
80005a1a:	91 0c       	st.w	r8[0x0],r12
80005a1c:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005a20:	0c 9b       	mov	r11,r6
80005a22:	48 d8       	lddpc	r8,80005a54 <xTaskRemoveFromEventList+0x6c>
80005a24:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80005a28:	f0 1f 00 0c 	mcall	80005a58 <xTaskRemoveFromEventList+0x70>
80005a2c:	c0 58       	rjmp	80005a36 <xTaskRemoveFromEventList+0x4e>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
80005a2e:	0c 9b       	mov	r11,r6
80005a30:	48 bc       	lddpc	r12,80005a5c <xTaskRemoveFromEventList+0x74>
80005a32:	f0 1f 00 0a 	mcall	80005a58 <xTaskRemoveFromEventList+0x70>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
80005a36:	48 b8       	lddpc	r8,80005a60 <xTaskRemoveFromEventList+0x78>
80005a38:	70 08       	ld.w	r8,r8[0x0]
80005a3a:	6e b9       	ld.w	r9,r7[0x2c]
80005a3c:	70 b8       	ld.w	r8,r8[0x2c]
80005a3e:	10 39       	cp.w	r9,r8
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
80005a40:	5f 2c       	srhs	r12
80005a42:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005a46:	00 00       	add	r0,r0
80005a48:	80 00       	ld.sh	r0,r0[0x0]
80005a4a:	50 0a       	stdsp	sp[0x0],r10
80005a4c:	00 00       	add	r0,r0
80005a4e:	0d 1c       	ld.sh	r12,r6++
80005a50:	00 00       	add	r0,r0
80005a52:	0d 54       	ld.sh	r4,--r6
80005a54:	00 00       	add	r0,r0
80005a56:	0c 38       	cp.w	r8,r6
80005a58:	80 00       	ld.sh	r0,r0[0x0]
80005a5a:	4f ba       	lddpc	r10,80005c44 <xTaskResumeAll+0x38>
80005a5c:	00 00       	add	r0,r0
80005a5e:	0c f0       	st.b	--r6,r0
80005a60:	00 00       	add	r0,r0
80005a62:	0c ec       	st.h	--r6,r12

80005a64 <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
80005a64:	eb cd 40 fc 	pushm	r2-r7,lr
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80005a68:	4b 98       	lddpc	r8,80005b4c <vTaskIncrementTick+0xe8>
80005a6a:	70 08       	ld.w	r8,r8[0x0]
80005a6c:	58 08       	cp.w	r8,0
80005a6e:	c6 91       	brne	80005b40 <vTaskIncrementTick+0xdc>
	{
		++xTickCount;
80005a70:	4b 88       	lddpc	r8,80005b50 <vTaskIncrementTick+0xec>
80005a72:	70 09       	ld.w	r9,r8[0x0]
80005a74:	2f f9       	sub	r9,-1
80005a76:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
80005a78:	70 08       	ld.w	r8,r8[0x0]
80005a7a:	58 08       	cp.w	r8,0
80005a7c:	c1 a1       	brne	80005ab0 <vTaskIncrementTick+0x4c>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
80005a7e:	4b 68       	lddpc	r8,80005b54 <vTaskIncrementTick+0xf0>
80005a80:	70 0a       	ld.w	r10,r8[0x0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
80005a82:	4b 69       	lddpc	r9,80005b58 <vTaskIncrementTick+0xf4>
80005a84:	72 0b       	ld.w	r11,r9[0x0]
80005a86:	91 0b       	st.w	r8[0x0],r11
			pxOverflowDelayedTaskList = pxTemp;
80005a88:	93 0a       	st.w	r9[0x0],r10
			xNumOfOverflows++;
80005a8a:	4b 59       	lddpc	r9,80005b5c <vTaskIncrementTick+0xf8>
80005a8c:	72 0a       	ld.w	r10,r9[0x0]
80005a8e:	2f fa       	sub	r10,-1
80005a90:	93 0a       	st.w	r9[0x0],r10

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
80005a92:	70 08       	ld.w	r8,r8[0x0]
80005a94:	70 08       	ld.w	r8,r8[0x0]
80005a96:	58 08       	cp.w	r8,0
80005a98:	c0 51       	brne	80005aa2 <vTaskIncrementTick+0x3e>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
80005a9a:	3f f9       	mov	r9,-1
80005a9c:	4b 18       	lddpc	r8,80005b60 <vTaskIncrementTick+0xfc>
80005a9e:	91 09       	st.w	r8[0x0],r9
80005aa0:	c0 88       	rjmp	80005ab0 <vTaskIncrementTick+0x4c>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
80005aa2:	4a d8       	lddpc	r8,80005b54 <vTaskIncrementTick+0xf0>
80005aa4:	70 08       	ld.w	r8,r8[0x0]
80005aa6:	70 38       	ld.w	r8,r8[0xc]
80005aa8:	70 38       	ld.w	r8,r8[0xc]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
80005aaa:	70 19       	ld.w	r9,r8[0x4]
80005aac:	4a d8       	lddpc	r8,80005b60 <vTaskIncrementTick+0xfc>
80005aae:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
80005ab0:	4a 88       	lddpc	r8,80005b50 <vTaskIncrementTick+0xec>
80005ab2:	70 09       	ld.w	r9,r8[0x0]
80005ab4:	4a b8       	lddpc	r8,80005b60 <vTaskIncrementTick+0xfc>
80005ab6:	70 08       	ld.w	r8,r8[0x0]
80005ab8:	10 39       	cp.w	r9,r8
80005aba:	c4 73       	brcs	80005b48 <vTaskIncrementTick+0xe4>
80005abc:	4a 68       	lddpc	r8,80005b54 <vTaskIncrementTick+0xf0>
80005abe:	70 08       	ld.w	r8,r8[0x0]
80005ac0:	70 08       	ld.w	r8,r8[0x0]
80005ac2:	58 08       	cp.w	r8,0
80005ac4:	c0 c0       	breq	80005adc <vTaskIncrementTick+0x78>
80005ac6:	4a 48       	lddpc	r8,80005b54 <vTaskIncrementTick+0xf0>
80005ac8:	70 08       	ld.w	r8,r8[0x0]
80005aca:	70 38       	ld.w	r8,r8[0xc]
80005acc:	70 37       	ld.w	r7,r8[0xc]
80005ace:	6e 18       	ld.w	r8,r7[0x4]
80005ad0:	4a 09       	lddpc	r9,80005b50 <vTaskIncrementTick+0xec>
80005ad2:	72 09       	ld.w	r9,r9[0x0]
80005ad4:	12 38       	cp.w	r8,r9
80005ad6:	e0 88 00 14 	brls	80005afe <vTaskIncrementTick+0x9a>
80005ada:	c0 e8       	rjmp	80005af6 <vTaskIncrementTick+0x92>
80005adc:	3f f9       	mov	r9,-1
80005ade:	4a 18       	lddpc	r8,80005b60 <vTaskIncrementTick+0xfc>
80005ae0:	91 09       	st.w	r8[0x0],r9
80005ae2:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80005ae6:	6a 08       	ld.w	r8,r5[0x0]
80005ae8:	70 38       	ld.w	r8,r8[0xc]
80005aea:	70 37       	ld.w	r7,r8[0xc]
80005aec:	6e 18       	ld.w	r8,r7[0x4]
80005aee:	64 09       	ld.w	r9,r2[0x0]
80005af0:	12 38       	cp.w	r8,r9
80005af2:	e0 88 00 0a 	brls	80005b06 <vTaskIncrementTick+0xa2>
80005af6:	49 b9       	lddpc	r9,80005b60 <vTaskIncrementTick+0xfc>
80005af8:	93 08       	st.w	r9[0x0],r8
80005afa:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80005afe:	49 a4       	lddpc	r4,80005b64 <vTaskIncrementTick+0x100>
80005b00:	49 a3       	lddpc	r3,80005b68 <vTaskIncrementTick+0x104>
80005b02:	49 55       	lddpc	r5,80005b54 <vTaskIncrementTick+0xf0>
80005b04:	49 32       	lddpc	r2,80005b50 <vTaskIncrementTick+0xec>
80005b06:	ee c6 ff fc 	sub	r6,r7,-4
80005b0a:	0c 9c       	mov	r12,r6
80005b0c:	f0 1f 00 18 	mcall	80005b6c <vTaskIncrementTick+0x108>
80005b10:	6e a8       	ld.w	r8,r7[0x28]
80005b12:	58 08       	cp.w	r8,0
80005b14:	c0 50       	breq	80005b1e <vTaskIncrementTick+0xba>
80005b16:	ee cc ff e8 	sub	r12,r7,-24
80005b1a:	f0 1f 00 15 	mcall	80005b6c <vTaskIncrementTick+0x108>
80005b1e:	6e bc       	ld.w	r12,r7[0x2c]
80005b20:	68 08       	ld.w	r8,r4[0x0]
80005b22:	10 3c       	cp.w	r12,r8
80005b24:	e9 fc ba 00 	st.whi	r4[0x0],r12
80005b28:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005b2c:	0c 9b       	mov	r11,r6
80005b2e:	e6 0c 00 2c 	add	r12,r3,r12<<0x2
80005b32:	f0 1f 00 10 	mcall	80005b70 <vTaskIncrementTick+0x10c>
80005b36:	6a 08       	ld.w	r8,r5[0x0]
80005b38:	70 08       	ld.w	r8,r8[0x0]
80005b3a:	58 08       	cp.w	r8,0
80005b3c:	cd 51       	brne	80005ae6 <vTaskIncrementTick+0x82>
80005b3e:	cc fb       	rjmp	80005adc <vTaskIncrementTick+0x78>
	}
	else
	{
		++uxMissedTicks;
80005b40:	48 d8       	lddpc	r8,80005b74 <vTaskIncrementTick+0x110>
80005b42:	70 09       	ld.w	r9,r8[0x0]
80005b44:	2f f9       	sub	r9,-1
80005b46:	91 09       	st.w	r8[0x0],r9
80005b48:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80005b4c:	00 00       	add	r0,r0
80005b4e:	0d 1c       	ld.sh	r12,r6++
80005b50:	00 00       	add	r0,r0
80005b52:	0d 18       	ld.sh	r8,r6++
80005b54:	00 00       	add	r0,r0
80005b56:	0c 24       	rsub	r4,r6
80005b58:	00 00       	add	r0,r0
80005b5a:	0c 34       	cp.w	r4,r6
80005b5c:	00 00       	add	r0,r0
80005b5e:	0c 30       	cp.w	r0,r6
80005b60:	00 00       	add	r0,r0
80005b62:	05 2c       	ld.uh	r12,r2++
80005b64:	00 00       	add	r0,r0
80005b66:	0d 54       	ld.sh	r4,--r6
80005b68:	00 00       	add	r0,r0
80005b6a:	0c 38       	cp.w	r8,r6
80005b6c:	80 00       	ld.sh	r0,r0[0x0]
80005b6e:	50 0a       	stdsp	sp[0x0],r10
80005b70:	80 00       	ld.sh	r0,r0[0x0]
80005b72:	4f ba       	lddpc	r10,80005d5c <vTaskDelayUntil+0xc>
80005b74:	00 00       	add	r0,r0
80005b76:	0c 1c       	sub	r12,r6

80005b78 <xTaskCheckForTimeOut>:
	pxTimeOut->xTimeOnEntering = xTickCount;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
80005b78:	eb cd 40 c0 	pushm	r6-r7,lr
80005b7c:	18 97       	mov	r7,r12
80005b7e:	16 96       	mov	r6,r11
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
80005b80:	f0 1f 00 15 	mcall	80005bd4 <xTaskCheckForTimeOut+0x5c>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
80005b84:	6c 08       	ld.w	r8,r6[0x0]
80005b86:	5b f8       	cp.w	r8,-1
80005b88:	c0 31       	brne	80005b8e <xTaskCheckForTimeOut+0x16>
80005b8a:	30 07       	mov	r7,0
80005b8c:	c1 f8       	rjmp	80005bca <xTaskCheckForTimeOut+0x52>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
80005b8e:	49 39       	lddpc	r9,80005bd8 <xTaskCheckForTimeOut+0x60>
80005b90:	72 09       	ld.w	r9,r9[0x0]
80005b92:	6e 0a       	ld.w	r10,r7[0x0]
80005b94:	12 3a       	cp.w	r10,r9
80005b96:	c0 70       	breq	80005ba4 <xTaskCheckForTimeOut+0x2c>
80005b98:	49 19       	lddpc	r9,80005bdc <xTaskCheckForTimeOut+0x64>
80005b9a:	72 09       	ld.w	r9,r9[0x0]
80005b9c:	6e 1a       	ld.w	r10,r7[0x4]
80005b9e:	12 3a       	cp.w	r10,r9
80005ba0:	e0 88 00 14 	brls	80005bc8 <xTaskCheckForTimeOut+0x50>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
80005ba4:	48 e9       	lddpc	r9,80005bdc <xTaskCheckForTimeOut+0x64>
80005ba6:	72 0a       	ld.w	r10,r9[0x0]
80005ba8:	6e 19       	ld.w	r9,r7[0x4]
80005baa:	12 1a       	sub	r10,r9
80005bac:	14 38       	cp.w	r8,r10
80005bae:	e0 88 00 0d 	brls	80005bc8 <xTaskCheckForTimeOut+0x50>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
80005bb2:	48 ba       	lddpc	r10,80005bdc <xTaskCheckForTimeOut+0x64>
80005bb4:	74 0a       	ld.w	r10,r10[0x0]
80005bb6:	14 19       	sub	r9,r10
80005bb8:	f2 08 00 08 	add	r8,r9,r8
80005bbc:	8d 08       	st.w	r6[0x0],r8
			vTaskSetTimeOutState( pxTimeOut );
80005bbe:	0e 9c       	mov	r12,r7
80005bc0:	f0 1f 00 08 	mcall	80005be0 <xTaskCheckForTimeOut+0x68>
80005bc4:	30 07       	mov	r7,0
80005bc6:	c0 28       	rjmp	80005bca <xTaskCheckForTimeOut+0x52>
80005bc8:	30 17       	mov	r7,1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
80005bca:	f0 1f 00 07 	mcall	80005be4 <xTaskCheckForTimeOut+0x6c>

	return xReturn;
}
80005bce:	0e 9c       	mov	r12,r7
80005bd0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005bd4:	80 00       	ld.sh	r0,r0[0x0]
80005bd6:	50 c4       	stdsp	sp[0x30],r4
80005bd8:	00 00       	add	r0,r0
80005bda:	0c 30       	cp.w	r0,r6
80005bdc:	00 00       	add	r0,r0
80005bde:	0d 18       	ld.sh	r8,r6++
80005be0:	80 00       	ld.sh	r0,r0[0x0]
80005be2:	58 dc       	cp.w	r12,13
80005be4:	80 00       	ld.sh	r0,r0[0x0]
80005be6:	51 d0       	stdsp	sp[0x74],r0

80005be8 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
80005be8:	eb cd 40 80 	pushm	r7,lr
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
80005bec:	f0 1f 00 05 	mcall	80005c00 <xTaskGetTickCount+0x18>
	{
		xTicks = xTickCount;
80005bf0:	48 58       	lddpc	r8,80005c04 <xTaskGetTickCount+0x1c>
80005bf2:	70 07       	ld.w	r7,r8[0x0]
	}
	taskEXIT_CRITICAL();
80005bf4:	f0 1f 00 05 	mcall	80005c08 <xTaskGetTickCount+0x20>

	return xTicks;
}
80005bf8:	0e 9c       	mov	r12,r7
80005bfa:	e3 cd 80 80 	ldm	sp++,r7,pc
80005bfe:	00 00       	add	r0,r0
80005c00:	80 00       	ld.sh	r0,r0[0x0]
80005c02:	50 c4       	stdsp	sp[0x30],r4
80005c04:	00 00       	add	r0,r0
80005c06:	0d 18       	ld.sh	r8,r6++
80005c08:	80 00       	ld.sh	r0,r0[0x0]
80005c0a:	51 d0       	stdsp	sp[0x74],r0

80005c0c <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
80005c0c:	eb cd 40 fe 	pushm	r1-r7,lr
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
80005c10:	f0 1f 00 2c 	mcall	80005cc0 <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;
80005c14:	4a c8       	lddpc	r8,80005cc4 <xTaskResumeAll+0xb8>
80005c16:	70 09       	ld.w	r9,r8[0x0]
80005c18:	20 19       	sub	r9,1
80005c1a:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80005c1c:	70 08       	ld.w	r8,r8[0x0]
80005c1e:	58 08       	cp.w	r8,0
80005c20:	c4 91       	brne	80005cb2 <xTaskResumeAll+0xa6>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
80005c22:	4a a8       	lddpc	r8,80005cc8 <xTaskResumeAll+0xbc>
80005c24:	70 08       	ld.w	r8,r8[0x0]
80005c26:	58 08       	cp.w	r8,0
80005c28:	c4 50       	breq	80005cb2 <xTaskResumeAll+0xa6>
80005c2a:	30 04       	mov	r4,0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80005c2c:	4a 85       	lddpc	r5,80005ccc <xTaskResumeAll+0xc0>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
80005c2e:	4a 93       	lddpc	r3,80005cd0 <xTaskResumeAll+0xc4>
80005c30:	4a 92       	lddpc	r2,80005cd4 <xTaskResumeAll+0xc8>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80005c32:	4a a1       	lddpc	r1,80005cd8 <xTaskResumeAll+0xcc>
80005c34:	c1 e8       	rjmp	80005c70 <xTaskResumeAll+0x64>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
80005c36:	6a 38       	ld.w	r8,r5[0xc]
80005c38:	70 37       	ld.w	r7,r8[0xc]
					vListRemove( &( pxTCB->xEventListItem ) );
80005c3a:	ee cc ff e8 	sub	r12,r7,-24
80005c3e:	f0 1f 00 28 	mcall	80005cdc <xTaskResumeAll+0xd0>
					vListRemove( &( pxTCB->xGenericListItem ) );
80005c42:	ee c6 ff fc 	sub	r6,r7,-4
80005c46:	0c 9c       	mov	r12,r6
80005c48:	f0 1f 00 25 	mcall	80005cdc <xTaskResumeAll+0xd0>
					prvAddTaskToReadyQueue( pxTCB );
80005c4c:	6e bc       	ld.w	r12,r7[0x2c]
80005c4e:	66 08       	ld.w	r8,r3[0x0]
80005c50:	10 3c       	cp.w	r12,r8
80005c52:	e7 fc ba 00 	st.whi	r3[0x0],r12
80005c56:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005c5a:	0c 9b       	mov	r11,r6
80005c5c:	e4 0c 00 2c 	add	r12,r2,r12<<0x2
80005c60:	f0 1f 00 20 	mcall	80005ce0 <xTaskResumeAll+0xd4>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80005c64:	62 08       	ld.w	r8,r1[0x0]
80005c66:	6e b9       	ld.w	r9,r7[0x2c]
80005c68:	70 b8       	ld.w	r8,r8[0x2c]
80005c6a:	10 39       	cp.w	r9,r8
80005c6c:	f9 b4 02 01 	movhs	r4,1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80005c70:	6a 08       	ld.w	r8,r5[0x0]
80005c72:	58 08       	cp.w	r8,0
80005c74:	ce 11       	brne	80005c36 <xTaskResumeAll+0x2a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80005c76:	49 c8       	lddpc	r8,80005ce4 <xTaskResumeAll+0xd8>
80005c78:	70 08       	ld.w	r8,r8[0x0]
80005c7a:	58 08       	cp.w	r8,0
80005c7c:	c0 f0       	breq	80005c9a <xTaskResumeAll+0x8e>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80005c7e:	49 a8       	lddpc	r8,80005ce4 <xTaskResumeAll+0xd8>
80005c80:	70 08       	ld.w	r8,r8[0x0]
80005c82:	58 08       	cp.w	r8,0
80005c84:	c1 10       	breq	80005ca6 <xTaskResumeAll+0x9a>
					{
						vTaskIncrementTick();
						--uxMissedTicks;
80005c86:	49 87       	lddpc	r7,80005ce4 <xTaskResumeAll+0xd8>
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
80005c88:	f0 1f 00 18 	mcall	80005ce8 <xTaskResumeAll+0xdc>
						--uxMissedTicks;
80005c8c:	6e 08       	ld.w	r8,r7[0x0]
80005c8e:	20 18       	sub	r8,1
80005c90:	8f 08       	st.w	r7[0x0],r8
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80005c92:	6e 08       	ld.w	r8,r7[0x0]
80005c94:	58 08       	cp.w	r8,0
80005c96:	cf 91       	brne	80005c88 <xTaskResumeAll+0x7c>
80005c98:	c0 78       	rjmp	80005ca6 <xTaskResumeAll+0x9a>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
80005c9a:	58 14       	cp.w	r4,1
80005c9c:	c0 50       	breq	80005ca6 <xTaskResumeAll+0x9a>
80005c9e:	49 48       	lddpc	r8,80005cec <xTaskResumeAll+0xe0>
80005ca0:	70 08       	ld.w	r8,r8[0x0]
80005ca2:	58 18       	cp.w	r8,1
80005ca4:	c0 71       	brne	80005cb2 <xTaskResumeAll+0xa6>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
80005ca6:	30 09       	mov	r9,0
80005ca8:	49 18       	lddpc	r8,80005cec <xTaskResumeAll+0xe0>
80005caa:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
80005cac:	d7 33       	scall
80005cae:	30 17       	mov	r7,1
80005cb0:	c0 28       	rjmp	80005cb4 <xTaskResumeAll+0xa8>
80005cb2:	30 07       	mov	r7,0
				}
			}
		}
	}
	taskEXIT_CRITICAL();
80005cb4:	f0 1f 00 0f 	mcall	80005cf0 <xTaskResumeAll+0xe4>

	return xAlreadyYielded;
}
80005cb8:	0e 9c       	mov	r12,r7
80005cba:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
80005cbe:	00 00       	add	r0,r0
80005cc0:	80 00       	ld.sh	r0,r0[0x0]
80005cc2:	50 c4       	stdsp	sp[0x30],r4
80005cc4:	00 00       	add	r0,r0
80005cc6:	0d 1c       	ld.sh	r12,r6++
80005cc8:	00 00       	add	r0,r0
80005cca:	0d 38       	ld.ub	r8,r6++
80005ccc:	00 00       	add	r0,r0
80005cce:	0c f0       	st.b	--r6,r0
80005cd0:	00 00       	add	r0,r0
80005cd2:	0d 54       	ld.sh	r4,--r6
80005cd4:	00 00       	add	r0,r0
80005cd6:	0c 38       	cp.w	r8,r6
80005cd8:	00 00       	add	r0,r0
80005cda:	0c ec       	st.h	--r6,r12
80005cdc:	80 00       	ld.sh	r0,r0[0x0]
80005cde:	50 0a       	stdsp	sp[0x0],r10
80005ce0:	80 00       	ld.sh	r0,r0[0x0]
80005ce2:	4f ba       	lddpc	r10,80005ecc <xTaskGenericCreate+0x1c>
80005ce4:	00 00       	add	r0,r0
80005ce6:	0c 1c       	sub	r12,r6
80005ce8:	80 00       	ld.sh	r0,r0[0x0]
80005cea:	5a 64       	cp.w	r4,-26
80005cec:	00 00       	add	r0,r0
80005cee:	0d 3c       	ld.ub	r12,r6++
80005cf0:	80 00       	ld.sh	r0,r0[0x0]
80005cf2:	51 d0       	stdsp	sp[0x74],r0

80005cf4 <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
80005cf4:	eb cd 40 80 	pushm	r7,lr
80005cf8:	18 97       	mov	r7,r12
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
80005cfa:	49 08       	lddpc	r8,80005d38 <prvAddCurrentTaskToDelayedList+0x44>
80005cfc:	70 08       	ld.w	r8,r8[0x0]
80005cfe:	91 1c       	st.w	r8[0x4],r12

	if( xTimeToWake < xTickCount )
80005d00:	48 f8       	lddpc	r8,80005d3c <prvAddCurrentTaskToDelayedList+0x48>
80005d02:	70 08       	ld.w	r8,r8[0x0]
80005d04:	10 3c       	cp.w	r12,r8
80005d06:	c0 a2       	brcc	80005d1a <prvAddCurrentTaskToDelayedList+0x26>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005d08:	48 c8       	lddpc	r8,80005d38 <prvAddCurrentTaskToDelayedList+0x44>
80005d0a:	70 0b       	ld.w	r11,r8[0x0]
80005d0c:	48 d8       	lddpc	r8,80005d40 <prvAddCurrentTaskToDelayedList+0x4c>
80005d0e:	70 0c       	ld.w	r12,r8[0x0]
80005d10:	2f cb       	sub	r11,-4
80005d12:	f0 1f 00 0d 	mcall	80005d44 <prvAddCurrentTaskToDelayedList+0x50>
80005d16:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005d1a:	48 88       	lddpc	r8,80005d38 <prvAddCurrentTaskToDelayedList+0x44>
80005d1c:	70 0b       	ld.w	r11,r8[0x0]
80005d1e:	48 b8       	lddpc	r8,80005d48 <prvAddCurrentTaskToDelayedList+0x54>
80005d20:	70 0c       	ld.w	r12,r8[0x0]
80005d22:	2f cb       	sub	r11,-4
80005d24:	f0 1f 00 08 	mcall	80005d44 <prvAddCurrentTaskToDelayedList+0x50>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
80005d28:	48 98       	lddpc	r8,80005d4c <prvAddCurrentTaskToDelayedList+0x58>
80005d2a:	70 08       	ld.w	r8,r8[0x0]
80005d2c:	10 37       	cp.w	r7,r8
80005d2e:	c0 32       	brcc	80005d34 <prvAddCurrentTaskToDelayedList+0x40>
		{
			xNextTaskUnblockTime = xTimeToWake;
80005d30:	48 78       	lddpc	r8,80005d4c <prvAddCurrentTaskToDelayedList+0x58>
80005d32:	91 07       	st.w	r8[0x0],r7
80005d34:	e3 cd 80 80 	ldm	sp++,r7,pc
80005d38:	00 00       	add	r0,r0
80005d3a:	0c ec       	st.h	--r6,r12
80005d3c:	00 00       	add	r0,r0
80005d3e:	0d 18       	ld.sh	r8,r6++
80005d40:	00 00       	add	r0,r0
80005d42:	0c 34       	cp.w	r4,r6
80005d44:	80 00       	ld.sh	r0,r0[0x0]
80005d46:	4f d6       	lddpc	r6,80005f38 <xTaskGenericCreate+0x88>
80005d48:	00 00       	add	r0,r0
80005d4a:	0c 24       	rsub	r4,r6
80005d4c:	00 00       	add	r0,r0
80005d4e:	05 2c       	ld.uh	r12,r2++

80005d50 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
80005d50:	eb cd 40 c0 	pushm	r6-r7,lr
80005d54:	18 96       	mov	r6,r12
80005d56:	16 97       	mov	r7,r11
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0 ) );

		vTaskSuspendAll();
80005d58:	f0 1f 00 18 	mcall	80005db8 <vTaskDelayUntil+0x68>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
80005d5c:	6c 08       	ld.w	r8,r6[0x0]
80005d5e:	10 07       	add	r7,r8

			if( xTickCount < *pxPreviousWakeTime )
80005d60:	49 79       	lddpc	r9,80005dbc <vTaskDelayUntil+0x6c>
80005d62:	72 09       	ld.w	r9,r9[0x0]
80005d64:	12 38       	cp.w	r8,r9
80005d66:	e0 88 00 0c 	brls	80005d7e <vTaskDelayUntil+0x2e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
80005d6a:	0e 38       	cp.w	r8,r7
80005d6c:	e0 88 00 22 	brls	80005db0 <vTaskDelayUntil+0x60>
80005d70:	49 38       	lddpc	r8,80005dbc <vTaskDelayUntil+0x6c>
80005d72:	70 08       	ld.w	r8,r8[0x0]
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80005d74:	8d 07       	st.w	r6[0x0],r7

			if( xShouldDelay != pdFALSE )
80005d76:	10 37       	cp.w	r7,r8
80005d78:	e0 88 00 14 	brls	80005da0 <vTaskDelayUntil+0x50>
80005d7c:	c0 a8       	rjmp	80005d90 <vTaskDelayUntil+0x40>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
80005d7e:	0e 38       	cp.w	r8,r7
80005d80:	e0 8b 00 16 	brhi	80005dac <vTaskDelayUntil+0x5c>
80005d84:	48 e8       	lddpc	r8,80005dbc <vTaskDelayUntil+0x6c>
80005d86:	70 08       	ld.w	r8,r8[0x0]
80005d88:	10 37       	cp.w	r7,r8
80005d8a:	e0 8b 00 11 	brhi	80005dac <vTaskDelayUntil+0x5c>
80005d8e:	c1 18       	rjmp	80005db0 <vTaskDelayUntil+0x60>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005d90:	48 c8       	lddpc	r8,80005dc0 <vTaskDelayUntil+0x70>
80005d92:	70 0c       	ld.w	r12,r8[0x0]
80005d94:	2f cc       	sub	r12,-4
80005d96:	f0 1f 00 0c 	mcall	80005dc4 <vTaskDelayUntil+0x74>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
80005d9a:	0e 9c       	mov	r12,r7
80005d9c:	f0 1f 00 0b 	mcall	80005dc8 <vTaskDelayUntil+0x78>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
80005da0:	f0 1f 00 0b 	mcall	80005dcc <vTaskDelayUntil+0x7c>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
80005da4:	c0 81       	brne	80005db4 <vTaskDelayUntil+0x64>
		{
			portYIELD_WITHIN_API();
80005da6:	d7 33       	scall
80005da8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80005dac:	8d 07       	st.w	r6[0x0],r7
80005dae:	cf 1b       	rjmp	80005d90 <vTaskDelayUntil+0x40>
80005db0:	8d 07       	st.w	r6[0x0],r7
80005db2:	cf 7b       	rjmp	80005da0 <vTaskDelayUntil+0x50>
80005db4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005db8:	80 00       	ld.sh	r0,r0[0x0]
80005dba:	58 50       	cp.w	r0,5
80005dbc:	00 00       	add	r0,r0
80005dbe:	0d 18       	ld.sh	r8,r6++
80005dc0:	00 00       	add	r0,r0
80005dc2:	0c ec       	st.h	--r6,r12
80005dc4:	80 00       	ld.sh	r0,r0[0x0]
80005dc6:	50 0a       	stdsp	sp[0x0],r10
80005dc8:	80 00       	ld.sh	r0,r0[0x0]
80005dca:	5c f4       	rol	r4
80005dcc:	80 00       	ld.sh	r0,r0[0x0]
80005dce:	5c 0c       	acr	r12

80005dd0 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
80005dd0:	eb cd 40 c0 	pushm	r6-r7,lr
80005dd4:	16 96       	mov	r6,r11
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
80005dd6:	48 e7       	lddpc	r7,80005e0c <vTaskPlaceOnEventList+0x3c>
80005dd8:	6e 0b       	ld.w	r11,r7[0x0]
80005dda:	2e 8b       	sub	r11,-24
80005ddc:	f0 1f 00 0d 	mcall	80005e10 <vTaskPlaceOnEventList+0x40>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005de0:	6e 0c       	ld.w	r12,r7[0x0]
80005de2:	2f cc       	sub	r12,-4
80005de4:	f0 1f 00 0c 	mcall	80005e14 <vTaskPlaceOnEventList+0x44>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
80005de8:	5b f6       	cp.w	r6,-1
80005dea:	c0 81       	brne	80005dfa <vTaskPlaceOnEventList+0x2a>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005dec:	6e 0b       	ld.w	r11,r7[0x0]
80005dee:	2f cb       	sub	r11,-4
80005df0:	48 ac       	lddpc	r12,80005e18 <vTaskPlaceOnEventList+0x48>
80005df2:	f0 1f 00 0b 	mcall	80005e1c <vTaskPlaceOnEventList+0x4c>
80005df6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
80005dfa:	48 a8       	lddpc	r8,80005e20 <vTaskPlaceOnEventList+0x50>
80005dfc:	70 0c       	ld.w	r12,r8[0x0]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
80005dfe:	ec 0c 00 0c 	add	r12,r6,r12
80005e02:	f0 1f 00 09 	mcall	80005e24 <vTaskPlaceOnEventList+0x54>
80005e06:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005e0a:	00 00       	add	r0,r0
80005e0c:	00 00       	add	r0,r0
80005e0e:	0c ec       	st.h	--r6,r12
80005e10:	80 00       	ld.sh	r0,r0[0x0]
80005e12:	4f d6       	lddpc	r6,80006004 <xTaskGenericCreate+0x154>
80005e14:	80 00       	ld.sh	r0,r0[0x0]
80005e16:	50 0a       	stdsp	sp[0x0],r10
80005e18:	00 00       	add	r0,r0
80005e1a:	0d 40       	ld.w	r0,--r6
80005e1c:	80 00       	ld.sh	r0,r0[0x0]
80005e1e:	4f ba       	lddpc	r10,80006008 <xTaskGenericCreate+0x158>
80005e20:	00 00       	add	r0,r0
80005e22:	0d 18       	ld.sh	r8,r6++
80005e24:	80 00       	ld.sh	r0,r0[0x0]
80005e26:	5c f4       	rol	r4

80005e28 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
80005e28:	eb cd 40 f8 	pushm	r3-r7,lr
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80005e2c:	49 67       	lddpc	r7,80005e84 <prvIdleTask+0x5c>
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80005e2e:	49 74       	lddpc	r4,80005e88 <prvIdleTask+0x60>

				taskENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					--uxCurrentNumberOfTasks;
80005e30:	49 73       	lddpc	r3,80005e8c <prvIdleTask+0x64>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80005e32:	49 85       	lddpc	r5,80005e90 <prvIdleTask+0x68>
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80005e34:	6e 08       	ld.w	r8,r7[0x0]
80005e36:	58 08       	cp.w	r8,0
80005e38:	c1 e0       	breq	80005e74 <prvIdleTask+0x4c>
		{
			vTaskSuspendAll();
80005e3a:	f0 1f 00 17 	mcall	80005e94 <prvIdleTask+0x6c>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80005e3e:	68 06       	ld.w	r6,r4[0x0]
			xTaskResumeAll();
80005e40:	f0 1f 00 16 	mcall	80005e98 <prvIdleTask+0x70>

			if( xListIsEmpty == pdFALSE )
80005e44:	58 06       	cp.w	r6,0
80005e46:	c1 70       	breq	80005e74 <prvIdleTask+0x4c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
80005e48:	f0 1f 00 15 	mcall	80005e9c <prvIdleTask+0x74>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
80005e4c:	68 38       	ld.w	r8,r4[0xc]
80005e4e:	70 36       	ld.w	r6,r8[0xc]
					vListRemove( &( pxTCB->xGenericListItem ) );
80005e50:	ec cc ff fc 	sub	r12,r6,-4
80005e54:	f0 1f 00 13 	mcall	80005ea0 <prvIdleTask+0x78>
					--uxCurrentNumberOfTasks;
80005e58:	66 08       	ld.w	r8,r3[0x0]
80005e5a:	20 18       	sub	r8,1
80005e5c:	87 08       	st.w	r3[0x0],r8
					--uxTasksDeleted;
80005e5e:	6e 08       	ld.w	r8,r7[0x0]
80005e60:	20 18       	sub	r8,1
80005e62:	8f 08       	st.w	r7[0x0],r8
				}
				taskEXIT_CRITICAL();
80005e64:	f0 1f 00 10 	mcall	80005ea4 <prvIdleTask+0x7c>

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
80005e68:	6c cc       	ld.w	r12,r6[0x30]
80005e6a:	f0 1f 00 10 	mcall	80005ea8 <prvIdleTask+0x80>
		vPortFree( pxTCB );
80005e6e:	0c 9c       	mov	r12,r6
80005e70:	f0 1f 00 0e 	mcall	80005ea8 <prvIdleTask+0x80>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80005e74:	6a 08       	ld.w	r8,r5[0x0]
80005e76:	58 18       	cp.w	r8,1
80005e78:	e0 88 00 03 	brls	80005e7e <prvIdleTask+0x56>
			{
				taskYIELD();
80005e7c:	d7 33       	scall
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
80005e7e:	f0 1f 00 0c 	mcall	80005eac <prvIdleTask+0x84>
		}
		#endif
	}
80005e82:	cd 9b       	rjmp	80005e34 <prvIdleTask+0xc>
80005e84:	00 00       	add	r0,r0
80005e86:	0c 2c       	rsub	r12,r6
80005e88:	00 00       	add	r0,r0
80005e8a:	0c d8       	st.w	--r6,r8
80005e8c:	00 00       	add	r0,r0
80005e8e:	0d 38       	ld.ub	r8,r6++
80005e90:	00 00       	add	r0,r0
80005e92:	0c 38       	cp.w	r8,r6
80005e94:	80 00       	ld.sh	r0,r0[0x0]
80005e96:	58 50       	cp.w	r0,5
80005e98:	80 00       	ld.sh	r0,r0[0x0]
80005e9a:	5c 0c       	acr	r12
80005e9c:	80 00       	ld.sh	r0,r0[0x0]
80005e9e:	50 c4       	stdsp	sp[0x30],r4
80005ea0:	80 00       	ld.sh	r0,r0[0x0]
80005ea2:	50 0a       	stdsp	sp[0x0],r10
80005ea4:	80 00       	ld.sh	r0,r0[0x0]
80005ea6:	51 d0       	stdsp	sp[0x74],r0
80005ea8:	80 00       	ld.sh	r0,r0[0x0]
80005eaa:	53 08       	stdsp	sp[0xc0],r8
80005eac:	80 00       	ld.sh	r0,r0[0x0]
80005eae:	20 30       	sub	r0,3

80005eb0 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
80005eb0:	d4 31       	pushm	r0-r7,lr
80005eb2:	20 1d       	sub	sp,4
80005eb4:	fa c4 ff d8 	sub	r4,sp,-40
80005eb8:	50 0c       	stdsp	sp[0x0],r12
80005eba:	16 91       	mov	r1,r11
80005ebc:	14 97       	mov	r7,r10
80005ebe:	12 90       	mov	r0,r9
80005ec0:	10 93       	mov	r3,r8
80005ec2:	68 02       	ld.w	r2,r4[0x0]
80005ec4:	68 16       	ld.w	r6,r4[0x4]
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
80005ec6:	34 8c       	mov	r12,72
80005ec8:	f0 1f 00 5c 	mcall	80006038 <xTaskGenericCreate+0x188>
80005ecc:	18 95       	mov	r5,r12

	if( pxNewTCB != NULL )
80005ece:	c0 31       	brne	80005ed4 <xTaskGenericCreate+0x24>
80005ed0:	3f fc       	mov	r12,-1
80005ed2:	ca f8       	rjmp	80006030 <xTaskGenericCreate+0x180>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80005ed4:	58 06       	cp.w	r6,0
80005ed6:	e0 81 00 af 	brne	80006034 <xTaskGenericCreate+0x184>
80005eda:	0e 9c       	mov	r12,r7
80005edc:	5c 7c       	castu.h	r12
80005ede:	a3 6c       	lsl	r12,0x2
80005ee0:	f0 1f 00 56 	mcall	80006038 <xTaskGenericCreate+0x188>
80005ee4:	18 96       	mov	r6,r12
80005ee6:	8b cc       	st.w	r5[0x30],r12

		if( pxNewTCB->pxStack == NULL )
80005ee8:	c0 61       	brne	80005ef4 <xTaskGenericCreate+0x44>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
80005eea:	0a 9c       	mov	r12,r5
80005eec:	f0 1f 00 54 	mcall	8000603c <xTaskGenericCreate+0x18c>
80005ef0:	3f fc       	mov	r12,-1
80005ef2:	c9 f8       	rjmp	80006030 <xTaskGenericCreate+0x180>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
80005ef4:	5c 77       	castu.h	r7
80005ef6:	ee 0a 15 02 	lsl	r10,r7,0x2
80005efa:	e0 6b 00 a5 	mov	r11,165
80005efe:	0c 9c       	mov	r12,r6
80005f00:	f0 1f 00 50 	mcall	80006040 <xTaskGenericCreate+0x190>
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
80005f04:	ee c6 00 01 	sub	r6,r7,1
80005f08:	6a c8       	ld.w	r8,r5[0x30]
80005f0a:	f0 06 00 26 	add	r6,r8,r6<<0x2
80005f0e:	e0 16 ff fc 	andl	r6,0xfffc
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
80005f12:	31 0a       	mov	r10,16
80005f14:	02 9b       	mov	r11,r1
80005f16:	ea cc ff cc 	sub	r12,r5,-52
80005f1a:	f0 1f 00 4b 	mcall	80006044 <xTaskGenericCreate+0x194>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
80005f1e:	30 08       	mov	r8,0
80005f20:	eb 68 00 43 	st.b	r5[67],r8
80005f24:	58 73       	cp.w	r3,7
80005f26:	e6 07 17 80 	movls	r7,r3
80005f2a:	f9 b7 0b 07 	movhi	r7,7
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
80005f2e:	8b b7       	st.w	r5[0x2c],r7
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
80005f30:	eb 47 00 44 	st.w	r5[68],r7
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
80005f34:	ea c4 ff fc 	sub	r4,r5,-4
80005f38:	08 9c       	mov	r12,r4
80005f3a:	f0 1f 00 44 	mcall	80006048 <xTaskGenericCreate+0x198>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
80005f3e:	ea cc ff e8 	sub	r12,r5,-24
80005f42:	f0 1f 00 42 	mcall	80006048 <xTaskGenericCreate+0x198>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
80005f46:	8b 45       	st.w	r5[0x10],r5

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
80005f48:	ee 07 11 08 	rsub	r7,r7,8
80005f4c:	8b 67       	st.w	r5[0x18],r7
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
80005f4e:	8b 95       	st.w	r5[0x24],r5
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
80005f50:	00 9a       	mov	r10,r0
80005f52:	40 0b       	lddsp	r11,sp[0x0]
80005f54:	0c 9c       	mov	r12,r6
80005f56:	f0 1f 00 3e 	mcall	8000604c <xTaskGenericCreate+0x19c>
80005f5a:	8b 0c       	st.w	r5[0x0],r12
		if( ( void * ) pxCreatedTask != NULL )
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
80005f5c:	58 02       	cp.w	r2,0
80005f5e:	e5 f5 1a 00 	st.wne	r2[0x0],r5
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
80005f62:	f0 1f 00 3c 	mcall	80006050 <xTaskGenericCreate+0x1a0>
		{
			uxCurrentNumberOfTasks++;
80005f66:	4b c8       	lddpc	r8,80006054 <xTaskGenericCreate+0x1a4>
80005f68:	70 09       	ld.w	r9,r8[0x0]
80005f6a:	2f f9       	sub	r9,-1
80005f6c:	91 09       	st.w	r8[0x0],r9
			if( pxCurrentTCB == NULL )
80005f6e:	4b b8       	lddpc	r8,80006058 <xTaskGenericCreate+0x1a8>
80005f70:	70 08       	ld.w	r8,r8[0x0]
80005f72:	58 08       	cp.w	r8,0
80005f74:	c2 61       	brne	80005fc0 <xTaskGenericCreate+0x110>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
80005f76:	4b 98       	lddpc	r8,80006058 <xTaskGenericCreate+0x1a8>
80005f78:	91 05       	st.w	r8[0x0],r5

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
80005f7a:	4b 78       	lddpc	r8,80006054 <xTaskGenericCreate+0x1a4>
80005f7c:	70 08       	ld.w	r8,r8[0x0]
80005f7e:	58 18       	cp.w	r8,1
80005f80:	c2 b1       	brne	80005fd6 <xTaskGenericCreate+0x126>
80005f82:	4b 77       	lddpc	r7,8000605c <xTaskGenericCreate+0x1ac>

/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
80005f84:	ee c6 ff 60 	sub	r6,r7,-160
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
80005f88:	0e 9c       	mov	r12,r7
80005f8a:	f0 1f 00 36 	mcall	80006060 <xTaskGenericCreate+0x1b0>
80005f8e:	2e c7       	sub	r7,-20

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
80005f90:	0c 37       	cp.w	r7,r6
80005f92:	cf b1       	brne	80005f88 <xTaskGenericCreate+0xd8>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
80005f94:	4b 47       	lddpc	r7,80006064 <xTaskGenericCreate+0x1b4>
80005f96:	0e 9c       	mov	r12,r7
80005f98:	f0 1f 00 32 	mcall	80006060 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
80005f9c:	4b 36       	lddpc	r6,80006068 <xTaskGenericCreate+0x1b8>
80005f9e:	0c 9c       	mov	r12,r6
80005fa0:	f0 1f 00 30 	mcall	80006060 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xPendingReadyList );
80005fa4:	4b 2c       	lddpc	r12,8000606c <xTaskGenericCreate+0x1bc>
80005fa6:	f0 1f 00 2f 	mcall	80006060 <xTaskGenericCreate+0x1b0>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
80005faa:	4b 2c       	lddpc	r12,80006070 <xTaskGenericCreate+0x1c0>
80005fac:	f0 1f 00 2d 	mcall	80006060 <xTaskGenericCreate+0x1b0>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
80005fb0:	4b 1c       	lddpc	r12,80006074 <xTaskGenericCreate+0x1c4>
80005fb2:	f0 1f 00 2c 	mcall	80006060 <xTaskGenericCreate+0x1b0>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
80005fb6:	4b 18       	lddpc	r8,80006078 <xTaskGenericCreate+0x1c8>
80005fb8:	91 07       	st.w	r8[0x0],r7
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
80005fba:	4b 18       	lddpc	r8,8000607c <xTaskGenericCreate+0x1cc>
80005fbc:	91 06       	st.w	r8[0x0],r6
80005fbe:	c0 c8       	rjmp	80005fd6 <xTaskGenericCreate+0x126>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
80005fc0:	4b 08       	lddpc	r8,80006080 <xTaskGenericCreate+0x1d0>
80005fc2:	70 08       	ld.w	r8,r8[0x0]
80005fc4:	58 08       	cp.w	r8,0
80005fc6:	c0 81       	brne	80005fd6 <xTaskGenericCreate+0x126>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
80005fc8:	4a 48       	lddpc	r8,80006058 <xTaskGenericCreate+0x1a8>
80005fca:	70 08       	ld.w	r8,r8[0x0]
80005fcc:	70 b8       	ld.w	r8,r8[0x2c]
80005fce:	10 33       	cp.w	r3,r8
80005fd0:	c0 33       	brcs	80005fd6 <xTaskGenericCreate+0x126>
					{
						pxCurrentTCB = pxNewTCB;
80005fd2:	4a 28       	lddpc	r8,80006058 <xTaskGenericCreate+0x1a8>
80005fd4:	91 05       	st.w	r8[0x0],r5
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
80005fd6:	6a b8       	ld.w	r8,r5[0x2c]
80005fd8:	4a b9       	lddpc	r9,80006084 <xTaskGenericCreate+0x1d4>
80005fda:	72 09       	ld.w	r9,r9[0x0]
80005fdc:	12 38       	cp.w	r8,r9
80005fde:	e0 88 00 04 	brls	80005fe6 <xTaskGenericCreate+0x136>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
80005fe2:	4a 99       	lddpc	r9,80006084 <xTaskGenericCreate+0x1d4>
80005fe4:	93 08       	st.w	r9[0x0],r8
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
80005fe6:	4a 98       	lddpc	r8,80006088 <xTaskGenericCreate+0x1d8>
80005fe8:	70 09       	ld.w	r9,r8[0x0]
80005fea:	2f f9       	sub	r9,-1
80005fec:	91 09       	st.w	r8[0x0],r9

			prvAddTaskToReadyQueue( pxNewTCB );
80005fee:	6a b8       	ld.w	r8,r5[0x2c]
80005ff0:	4a 79       	lddpc	r9,8000608c <xTaskGenericCreate+0x1dc>
80005ff2:	72 09       	ld.w	r9,r9[0x0]
80005ff4:	12 38       	cp.w	r8,r9
80005ff6:	e0 88 00 04 	brls	80005ffe <xTaskGenericCreate+0x14e>
80005ffa:	4a 59       	lddpc	r9,8000608c <xTaskGenericCreate+0x1dc>
80005ffc:	93 08       	st.w	r9[0x0],r8
80005ffe:	6a bc       	ld.w	r12,r5[0x2c]
80006000:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006004:	08 9b       	mov	r11,r4
80006006:	49 68       	lddpc	r8,8000605c <xTaskGenericCreate+0x1ac>
80006008:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
8000600c:	f0 1f 00 21 	mcall	80006090 <xTaskGenericCreate+0x1e0>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
80006010:	f0 1f 00 21 	mcall	80006094 <xTaskGenericCreate+0x1e4>
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
80006014:	49 b8       	lddpc	r8,80006080 <xTaskGenericCreate+0x1d0>
80006016:	70 08       	ld.w	r8,r8[0x0]
80006018:	58 08       	cp.w	r8,0
8000601a:	c0 a0       	breq	8000602e <xTaskGenericCreate+0x17e>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
8000601c:	48 f8       	lddpc	r8,80006058 <xTaskGenericCreate+0x1a8>
8000601e:	70 08       	ld.w	r8,r8[0x0]
80006020:	70 b8       	ld.w	r8,r8[0x2c]
80006022:	10 33       	cp.w	r3,r8
80006024:	e0 88 00 05 	brls	8000602e <xTaskGenericCreate+0x17e>
			{
				portYIELD_WITHIN_API();
80006028:	d7 33       	scall
8000602a:	30 1c       	mov	r12,1
8000602c:	c0 28       	rjmp	80006030 <xTaskGenericCreate+0x180>
8000602e:	30 1c       	mov	r12,1
			}
		}
	}

	return xReturn;
}
80006030:	2f fd       	sub	sp,-4
80006032:	d8 32       	popm	r0-r7,pc
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80006034:	99 c6       	st.w	r12[0x30],r6
80006036:	c5 fb       	rjmp	80005ef4 <xTaskGenericCreate+0x44>
80006038:	80 00       	ld.sh	r0,r0[0x0]
8000603a:	53 30       	stdsp	sp[0xcc],r0
8000603c:	80 00       	ld.sh	r0,r0[0x0]
8000603e:	53 08       	stdsp	sp[0xc0],r8
80006040:	80 00       	ld.sh	r0,r0[0x0]
80006042:	6d 1c       	ld.w	r12,r6[0x44]
80006044:	80 00       	ld.sh	r0,r0[0x0]
80006046:	70 60       	ld.w	r0,r8[0x18]
80006048:	80 00       	ld.sh	r0,r0[0x0]
8000604a:	4f b4       	lddpc	r4,80006234 <PrintDec+0x9a>
8000604c:	80 00       	ld.sh	r0,r0[0x0]
8000604e:	50 30       	stdsp	sp[0xc],r0
80006050:	80 00       	ld.sh	r0,r0[0x0]
80006052:	50 c4       	stdsp	sp[0x30],r4
80006054:	00 00       	add	r0,r0
80006056:	0d 38       	ld.ub	r8,r6++
80006058:	00 00       	add	r0,r0
8000605a:	0c ec       	st.h	--r6,r12
8000605c:	00 00       	add	r0,r0
8000605e:	0c 38       	cp.w	r8,r6
80006060:	80 00       	ld.sh	r0,r0[0x0]
80006062:	4f a0       	lddpc	r0,80006248 <PrintDec+0xae>
80006064:	00 00       	add	r0,r0
80006066:	0d 04       	ld.w	r4,r6++
80006068:	00 00       	add	r0,r0
8000606a:	0d 20       	ld.uh	r0,r6++
8000606c:	00 00       	add	r0,r0
8000606e:	0c f0       	st.b	--r6,r0
80006070:	00 00       	add	r0,r0
80006072:	0c d8       	st.w	--r6,r8
80006074:	00 00       	add	r0,r0
80006076:	0d 40       	ld.w	r0,--r6
80006078:	00 00       	add	r0,r0
8000607a:	0c 24       	rsub	r4,r6
8000607c:	00 00       	add	r0,r0
8000607e:	0c 34       	cp.w	r4,r6
80006080:	00 00       	add	r0,r0
80006082:	0c 28       	rsub	r8,r6
80006084:	00 00       	add	r0,r0
80006086:	0c 20       	rsub	r0,r6
80006088:	00 00       	add	r0,r0
8000608a:	0d 34       	ld.ub	r4,r6++
8000608c:	00 00       	add	r0,r0
8000608e:	0d 54       	ld.sh	r4,--r6
80006090:	80 00       	ld.sh	r0,r0[0x0]
80006092:	4f ba       	lddpc	r10,8000627c <log+0x8>
80006094:	80 00       	ld.sh	r0,r0[0x0]
80006096:	51 d0       	stdsp	sp[0x74],r0

80006098 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
80006098:	d4 01       	pushm	lr
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
8000609a:	30 09       	mov	r9,0
8000609c:	1a d9       	st.w	--sp,r9
8000609e:	1a d9       	st.w	--sp,r9
800060a0:	1a d9       	st.w	--sp,r9
800060a2:	12 98       	mov	r8,r9
800060a4:	e0 6a 01 00 	mov	r10,256
800060a8:	48 9b       	lddpc	r11,800060cc <vTaskStartScheduler+0x34>
800060aa:	48 ac       	lddpc	r12,800060d0 <vTaskStartScheduler+0x38>
800060ac:	f0 1f 00 0a 	mcall	800060d4 <vTaskStartScheduler+0x3c>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
800060b0:	2f dd       	sub	sp,-12
800060b2:	58 1c       	cp.w	r12,1
800060b4:	c0 a1       	brne	800060c8 <vTaskStartScheduler+0x30>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
800060b6:	d3 03       	ssrf	0x10

		xSchedulerRunning = pdTRUE;
800060b8:	30 19       	mov	r9,1
800060ba:	48 88       	lddpc	r8,800060d8 <vTaskStartScheduler+0x40>
800060bc:	91 09       	st.w	r8[0x0],r9
		xTickCount = ( portTickType ) 0;
800060be:	30 09       	mov	r9,0
800060c0:	48 78       	lddpc	r8,800060dc <vTaskStartScheduler+0x44>
800060c2:	91 09       	st.w	r8[0x0],r9
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
800060c4:	f0 1f 00 07 	mcall	800060e0 <vTaskStartScheduler+0x48>
800060c8:	d8 02       	popm	pc
800060ca:	00 00       	add	r0,r0
800060cc:	80 00       	ld.sh	r0,r0[0x0]
800060ce:	cc a0       	breq	80006062 <xTaskGenericCreate+0x1b2>
800060d0:	80 00       	ld.sh	r0,r0[0x0]
800060d2:	5e 28       	reths	r8
800060d4:	80 00       	ld.sh	r0,r0[0x0]
800060d6:	5e b0       	rethi	r0
800060d8:	00 00       	add	r0,r0
800060da:	0c 28       	rsub	r8,r6
800060dc:	00 00       	add	r0,r0
800060de:	0d 18       	ld.sh	r8,r6++
800060e0:	80 00       	ld.sh	r0,r0[0x0]
800060e2:	50 d4       	stdsp	sp[0x34],r4

800060e4 <PrintChar>:
	
static void task_log(void * pvParameters);

char *  PrintChar(char c, char * str)
{
	*str++ = c;
800060e4:	16 cc       	st.b	r11++,r12
	return str;
}
800060e6:	5e fb       	retal	r11

800060e8 <PrintHex>:
	
	return str;
}

char * PrintHex(int i,char len, char * str)
{
800060e8:	eb cd 40 c0 	pushm	r6-r7,lr
800060ec:	20 3d       	sub	sp,12
800060ee:	18 98       	mov	r8,r12
	char * p = str;
	char s[12];
	memset(s, 0 , 12);
800060f0:	30 06       	mov	r6,0
800060f2:	30 07       	mov	r7,0
800060f4:	fa e7 00 00 	st.d	sp[0],r6
800060f8:	30 0c       	mov	r12,0
800060fa:	50 2c       	stdsp	sp[0x8],r12
	int cnt=0;
	
	if(i)
800060fc:	58 08       	cp.w	r8,0
800060fe:	c1 30       	breq	80006124 <PrintHex+0x3c>
80006100:	18 99       	mov	r9,r12
	while(i)
	{
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
80006102:	1a 9c       	mov	r12,sp
80006104:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80006108:	58 9e       	cp.w	lr,9
8000610a:	e0 8a 00 04 	brle	80006112 <PrintHex+0x2a>
8000610e:	2c 9e       	sub	lr,-55
80006110:	c0 48       	rjmp	80006118 <PrintHex+0x30>
80006112:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80006116:	2d 0e       	sub	lr,-48
80006118:	f8 09 0b 0e 	st.b	r12[r9],lr
8000611c:	2f f9       	sub	r9,-1
		i = (i >> 4 ) & 0x0FFFFFFF;
8000611e:	a5 88       	lsr	r8,0x4
	char s[12];
	memset(s, 0 , 12);
	int cnt=0;
	
	if(i)
	while(i)
80006120:	cf 21       	brne	80006104 <PrintHex+0x1c>
80006122:	c0 48       	rjmp	8000612a <PrintHex+0x42>
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
		i = (i >> 4 ) & 0x0FFFFFFF;
		//i >>= 4
	}
	else
	s[cnt++] = '0';
80006124:	33 08       	mov	r8,48
80006126:	ba 88       	st.b	sp[0x0],r8
80006128:	30 19       	mov	r9,1
	
	if(len - cnt > 0 )
8000612a:	f6 09 01 08 	sub	r8,r11,r9
8000612e:	58 08       	cp.w	r8,0
80006130:	e0 8a 00 13 	brle	80006156 <PrintHex+0x6e>
	{
		char num = len - cnt;
80006134:	12 1b       	sub	r11,r9
80006136:	f9 db c0 08 	bfextu	r12,r11,0x0,0x8
		for(int i = 0; i < num; i++)
8000613a:	18 9e       	mov	lr,r12
8000613c:	58 0c       	cp.w	r12,0
8000613e:	e0 8a 00 0c 	brle	80006156 <PrintHex+0x6e>
80006142:	1a 9b       	mov	r11,sp
80006144:	12 0b       	add	r11,r9
80006146:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80006148:	33 07       	mov	r7,48
8000614a:	16 c7       	st.b	r11++,r7
	s[cnt++] = '0';
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
8000614c:	2f f8       	sub	r8,-1
8000614e:	1c 38       	cp.w	r8,lr
80006150:	cf d5       	brlt	8000614a <PrintHex+0x62>
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80006152:	f8 09 00 09 	add	r9,r12,r9
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80006156:	f2 c8 ff ff 	sub	r8,r9,-1
	s[cnt++] = '0';
	
	while(cnt>0)
8000615a:	f0 cb ff ff 	sub	r11,r8,-1
8000615e:	58 0b       	cp.w	r11,0
80006160:	e0 8a 00 19 	brle	80006192 <PrintHex+0xaa>
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80006164:	fa cb ff f4 	sub	r11,sp,-12
80006168:	f6 09 00 09 	add	r9,r11,r9
8000616c:	37 8b       	mov	r11,120
8000616e:	f3 6b ff f4 	st.b	r9[-12],r11
	s[cnt++] = '0';
80006172:	fa c9 ff f4 	sub	r9,sp,-12
80006176:	10 09       	add	r9,r8
80006178:	33 0b       	mov	r11,48
8000617a:	f3 6b ff f4 	st.b	r9[-12],r11
8000617e:	fa 08 00 08 	add	r8,sp,r8
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80006182:	fa ce 00 01 	sub	lr,sp,1
80006186:	14 99       	mov	r9,r10
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
	*p++ = s[--cnt];
80006188:	11 8b       	ld.ub	r11,r8[0x0]
8000618a:	12 cb       	st.b	r9++,r11
8000618c:	20 18       	sub	r8,1
	}
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
8000618e:	1c 38       	cp.w	r8,lr
80006190:	cf c1       	brne	80006188 <PrintHex+0xa0>
	*p++ = s[--cnt];
		
	return str;
}
80006192:	14 9c       	mov	r12,r10
80006194:	2f dd       	sub	sp,-12
80006196:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

8000619a <PrintDec>:
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
{
8000619a:	d4 21       	pushm	r4-r7,lr
8000619c:	20 3d       	sub	sp,12
8000619e:	18 98       	mov	r8,r12
	char * p = str;
	
	int sign = i>=0 ? 0 : 1;
	char s[10];
	memset(s, 0 , 10);
800061a0:	30 06       	mov	r6,0
800061a2:	30 07       	mov	r7,0
800061a4:	fa e7 00 00 	st.d	sp[0],r6
800061a8:	30 0c       	mov	r12,0
800061aa:	ba 4c       	st.h	sp[0x8],r12
	int cnt=0;
	if(sign)
800061ac:	58 08       	cp.w	r8,0
800061ae:	c0 35       	brlt	800061b4 <PrintDec+0x1a>
800061b0:	14 97       	mov	r7,r10
800061b2:	c0 58       	rjmp	800061bc <PrintDec+0x22>
	{
		*p++ = '-';
800061b4:	14 97       	mov	r7,r10
800061b6:	32 d9       	mov	r9,45
800061b8:	0e c9       	st.b	r7++,r9
		i = -i;
800061ba:	5c 38       	neg	r8
	}
	
	if(i == 0 )s[cnt++] = '0';
800061bc:	58 08       	cp.w	r8,0
800061be:	c0 51       	brne	800061c8 <PrintDec+0x2e>
800061c0:	33 08       	mov	r8,48
800061c2:	ba 88       	st.b	sp[0x0],r8
800061c4:	30 1e       	mov	lr,1
800061c6:	c2 f8       	rjmp	80006224 <PrintDec+0x8a>
	
	int ten = i%10;
800061c8:	e0 65 66 67 	mov	r5,26215
800061cc:	ea 15 66 66 	orh	r5,0x6666
800061d0:	f0 05 04 44 	muls.d	r4,r8,r5
800061d4:	ea 0c 14 02 	asr	r12,r5,0x2
800061d8:	f0 09 14 1f 	asr	r9,r8,0x1f
800061dc:	f8 09 01 09 	sub	r9,r12,r9
800061e0:	f2 09 00 29 	add	r9,r9,r9<<0x2
800061e4:	f0 09 01 19 	sub	r9,r8,r9<<0x1
800061e8:	30 0e       	mov	lr,0
	while(i)
	{
		s[cnt] = ten+'0';
800061ea:	1a 9c       	mov	r12,sp
		cnt++;
		i /= 10;
800061ec:	e0 66 66 67 	mov	r6,26215
800061f0:	ea 16 66 66 	orh	r6,0x6666
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
	{
		s[cnt] = ten+'0';
800061f4:	2d 09       	sub	r9,-48
800061f6:	f8 0e 0b 09 	st.b	r12[lr],r9
		cnt++;
800061fa:	2f fe       	sub	lr,-1
		i /= 10;
800061fc:	f0 06 04 44 	muls.d	r4,r8,r6
80006200:	ea 09 14 02 	asr	r9,r5,0x2
80006204:	bf 58       	asr	r8,0x1f
80006206:	f2 08 01 08 	sub	r8,r9,r8
		ten = i%10;
8000620a:	f0 06 04 44 	muls.d	r4,r8,r6
8000620e:	ea 09 14 02 	asr	r9,r5,0x2
80006212:	f0 05 14 1f 	asr	r5,r8,0x1f
80006216:	0a 19       	sub	r9,r5
80006218:	f2 09 00 29 	add	r9,r9,r9<<0x2
8000621c:	f0 09 01 19 	sub	r9,r8,r9<<0x1
	}
	
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
80006220:	58 08       	cp.w	r8,0
80006222:	ce 91       	brne	800061f4 <PrintDec+0x5a>
		cnt++;
		i /= 10;
		ten = i%10;
	}
	
	if(len - cnt > 0 )
80006224:	f6 0e 01 08 	sub	r8,r11,lr
80006228:	58 08       	cp.w	r8,0
8000622a:	e0 89 00 06 	brgt	80006236 <PrintDec+0x9c>
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
8000622e:	58 0e       	cp.w	lr,0
80006230:	e0 89 00 14 	brgt	80006258 <PrintDec+0xbe>
80006234:	c1 d8       	rjmp	8000626e <PrintDec+0xd4>
		ten = i%10;
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
80006236:	1c 1b       	sub	r11,lr
80006238:	5c 5b       	castu.b	r11
		for(int i = 0; i < num; i++)
8000623a:	16 9c       	mov	r12,r11
8000623c:	58 0b       	cp.w	r11,0
8000623e:	fe 9a ff f8 	brle	8000622e <PrintDec+0x94>
80006242:	1a 99       	mov	r9,sp
80006244:	1c 09       	add	r9,lr
80006246:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80006248:	33 06       	mov	r6,48
8000624a:	12 c6       	st.b	r9++,r6
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
8000624c:	2f f8       	sub	r8,-1
8000624e:	18 38       	cp.w	r8,r12
80006250:	cf d5       	brlt	8000624a <PrintDec+0xb0>
{
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
80006252:	f6 0e 00 0e 	add	lr,r11,lr
80006256:	ce cb       	rjmp	8000622e <PrintDec+0x94>
80006258:	fa c8 ff f4 	sub	r8,sp,-12
8000625c:	1c 08       	add	r8,lr
8000625e:	20 d8       	sub	r8,13
80006260:	fa cb 00 01 	sub	r11,sp,1
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
	*p++ = s[--cnt];
80006264:	11 89       	ld.ub	r9,r8[0x0]
80006266:	0e c9       	st.b	r7++,r9
80006268:	20 18       	sub	r8,1
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
8000626a:	16 38       	cp.w	r8,r11
8000626c:	cf c1       	brne	80006264 <PrintDec+0xca>
	*p++ = s[--cnt];
	
	return str;
}
8000626e:	14 9c       	mov	r12,r10
80006270:	2f dd       	sub	sp,-12
80006272:	d8 22       	popm	r4-r7,pc

80006274 <log>:
	,  NULL );
	
}

int log(char * content, ...)
{
80006274:	d4 31       	pushm	r0-r7,lr
80006276:	fa cd 02 08 	sub	sp,sp,520
8000627a:	18 97       	mov	r7,r12
	
	
	char logTmp[MAX_LOG_LINE_SIZE];
	memset(logTmp, '\0', MAX_LOG_LINE_SIZE);	
8000627c:	e0 6a 01 00 	mov	r10,256
80006280:	30 0b       	mov	r11,0
80006282:	fa cc fe f8 	sub	r12,sp,-264
80006286:	f0 1f 00 4e 	mcall	800063bc <log+0x148>
	,  tskLOG_PRIORITY
	,  NULL );
	
}

int log(char * content, ...)
8000628a:	fa c4 fd d4 	sub	r4,sp,-556
8000628e:	30 0a       	mov	r10,0
80006290:	50 0a       	stdsp	sp[0x0],r10
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80006292:	fa c3 ff fc 	sub	r3,sp,-4
80006296:	e0 61 01 00 	mov	r1,256
8000629a:	14 90       	mov	r0,r10
			
					if(*str == '%')
8000629c:	32 52       	mov	r2,37
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
8000629e:	fa c6 fe f8 	sub	r6,sp,-264
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
800062a2:	02 9a       	mov	r10,r1
800062a4:	00 9b       	mov	r11,r0
800062a6:	06 9c       	mov	r12,r3
800062a8:	f0 1f 00 45 	mcall	800063bc <log+0x148>
			
					if(*str == '%')
800062ac:	0f 88       	ld.ub	r8,r7[0x0]
800062ae:	e4 08 18 00 	cp.b	r8,r2
800062b2:	c5 71       	brne	80006360 <log+0xec>
					{
						static char lench = 0;
						lench =*(str + 1);
800062b4:	ee c8 ff ff 	sub	r8,r7,-1
800062b8:	11 89       	ld.ub	r9,r8[0x0]
800062ba:	4c 2a       	lddpc	r10,800063c0 <log+0x14c>
800062bc:	b4 89       	st.b	r10[0x0],r9
						if((lench >= '0') &&  (lench <= '9'))
800062be:	23 09       	sub	r9,48
800062c0:	30 9a       	mov	r10,9
800062c2:	f4 09 18 00 	cp.b	r9,r10
800062c6:	ee 08 17 b0 	movhi	r8,r7
						{
							len = *(++str) - '0';
800062ca:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
800062ce:	f7 b9 08 30 	subls	r9,48
800062d2:	fb f9 8a 00 	st.wls	sp[0x0],r9
						}
						
						str++;
800062d6:	f0 c7 ff ff 	sub	r7,r8,-1
						
						switch(*(str))
800062da:	0f 88       	ld.ub	r8,r7[0x0]
800062dc:	22 58       	sub	r8,37
800062de:	e0 48 00 53 	cp.w	r8,83
800062e2:	e0 8b 00 31 	brhi	80006344 <log+0xd0>
800062e6:	4b 89       	lddpc	r9,800063c4 <log+0x150>
800062e8:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
						{
							case('i'):
							case('I'):
							case('d'):
							case('D'):
							x = va_arg(arg_ptr,int);
800062ec:	e8 c5 ff fc 	sub	r5,r4,-4
							strTmp = PrintDec(x, len, strTmp);
800062f0:	06 9a       	mov	r10,r3
800062f2:	40 0b       	lddsp	r11,sp[0x0]
800062f4:	5c 5b       	castu.b	r11
800062f6:	68 0c       	ld.w	r12,r4[0x0]
800062f8:	f0 1f 00 34 	mcall	800063c8 <log+0x154>
							break;
800062fc:	c2 98       	rjmp	8000634e <log+0xda>
							
							case('f')://浮点数输出
							case('F'):
							//f = va_arg(arg_ptr,int);
							//strTmp = PrintDec(x, len, strTmp);
							log("I need float.");
800062fe:	4b 4c       	lddpc	r12,800063cc <log+0x158>
80006300:	f0 1f 00 34 	mcall	800063d0 <log+0x15c>
80006304:	08 95       	mov	r5,r4
80006306:	06 9c       	mov	r12,r3
							break;
80006308:	c2 38       	rjmp	8000634e <log+0xda>
							
							
							case('x'):
							case('X'):
							x = va_arg(arg_ptr,int);
8000630a:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintHex(x,len, strTmp);
8000630e:	06 9a       	mov	r10,r3
80006310:	40 0b       	lddsp	r11,sp[0x0]
80006312:	5c 5b       	castu.b	r11
80006314:	68 0c       	ld.w	r12,r4[0x0]
80006316:	f0 1f 00 30 	mcall	800063d4 <log+0x160>
8000631a:	06 9c       	mov	r12,r3
							break;
8000631c:	c1 98       	rjmp	8000634e <log+0xda>
							
							case('c'):
							case('C'):
							y = va_arg(arg_ptr,int);
8000631e:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintChar(y, strTmp);
80006322:	06 9b       	mov	r11,r3
80006324:	09 bc       	ld.ub	r12,r4[0x3]
80006326:	f0 1f 00 2d 	mcall	800063d8 <log+0x164>
8000632a:	06 9c       	mov	r12,r3
							break;
8000632c:	c1 18       	rjmp	8000634e <log+0xda>
							
							case('s'):
							case('S'):
							strTmp = va_arg(arg_ptr,char*);
8000632e:	e8 c5 ff fc 	sub	r5,r4,-4
80006332:	68 0c       	ld.w	r12,r4[0x0]
							//PrintStr(s);
							break;
80006334:	c0 d8       	rjmp	8000634e <log+0xda>
							
							case('%'):
							PrintChar('%', strTmp);
80006336:	06 9b       	mov	r11,r3
80006338:	32 5c       	mov	r12,37
8000633a:	f0 1f 00 28 	mcall	800063d8 <log+0x164>
8000633e:	08 95       	mov	r5,r4
80006340:	06 9c       	mov	r12,r3
							//PrintChar('%');
							break;
80006342:	c0 68       	rjmp	8000634e <log+0xda>
							
							default:
							log("I need relax.");
80006344:	4a 6c       	lddpc	r12,800063dc <log+0x168>
80006346:	f0 1f 00 23 	mcall	800063d0 <log+0x15c>
8000634a:	08 95       	mov	r5,r4
8000634c:	06 9c       	mov	r12,r3
						}
						str++;
8000634e:	2f f7       	sub	r7,-1
						
						length = sprintf(logTmp,"%s%s",logTmp,strTmp );
80006350:	1a dc       	st.w	--sp,r12
80006352:	1a d6       	st.w	--sp,r6
80006354:	4a 3b       	lddpc	r11,800063e0 <log+0x16c>
80006356:	0c 9c       	mov	r12,r6
80006358:	f0 1f 00 23 	mcall	800063e4 <log+0x170>
8000635c:	2f ed       	sub	sp,-8
8000635e:	c0 a8       	rjmp	80006372 <log+0xfe>
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
80006360:	2f f7       	sub	r7,-1
80006362:	1a d8       	st.w	--sp,r8
80006364:	1a d6       	st.w	--sp,r6
80006366:	4a 1b       	lddpc	r11,800063e8 <log+0x174>
80006368:	0c 9c       	mov	r12,r6
8000636a:	f0 1f 00 1f 	mcall	800063e4 <log+0x170>
8000636e:	08 95       	mov	r5,r4
80006370:	2f ed       	sub	sp,-8
			
			
			
	}while(*str != '\0');
80006372:	0f 89       	ld.ub	r9,r7[0x0]
80006374:	30 08       	mov	r8,0
80006376:	f0 09 18 00 	cp.b	r9,r8
8000637a:	c0 30       	breq	80006380 <log+0x10c>
8000637c:	0a 94       	mov	r4,r5
8000637e:	c9 2b       	rjmp	800062a2 <log+0x2e>
		
		
				
	va_end(arg_ptr);
	//while(1)		
	length = sprintf(logTmp,"%s\r\n",logTmp);
80006380:	fa c7 fe f8 	sub	r7,sp,-264
80006384:	1a d7       	st.w	--sp,r7
80006386:	49 ab       	lddpc	r11,800063ec <log+0x178>
80006388:	0e 9c       	mov	r12,r7
8000638a:	f0 1f 00 17 	mcall	800063e4 <log+0x170>
	
	char * p = pvPortMalloc(length+1);
8000638e:	5c 5c       	castu.b	r12
80006390:	f8 c6 ff ff 	sub	r6,r12,-1
80006394:	0c 9c       	mov	r12,r6
80006396:	f0 1f 00 17 	mcall	800063f0 <log+0x17c>
8000639a:	54 2c       	stdsp	sp[0x108],r12
	memcpy(p, logTmp, length+1);
8000639c:	0c 9a       	mov	r10,r6
8000639e:	0e 9b       	mov	r11,r7
800063a0:	f0 1f 00 15 	mcall	800063f4 <log+0x180>
	//
	//usart_write_line(EXAMPLE_USART, logTmp)
	
	xQueueSend( logQueue, &p, 5);
800063a4:	30 09       	mov	r9,0
800063a6:	30 5a       	mov	r10,5
800063a8:	fa cb fe f8 	sub	r11,sp,-264
800063ac:	49 38       	lddpc	r8,800063f8 <log+0x184>
800063ae:	70 0c       	ld.w	r12,r8[0x0]
800063b0:	f0 1f 00 13 	mcall	800063fc <log+0x188>
800063b4:	2f fd       	sub	sp,-4
	
	
}
800063b6:	fe 3d fd f8 	sub	sp,-520
800063ba:	d8 32       	popm	r0-r7,pc
800063bc:	80 00       	ld.sh	r0,r0[0x0]
800063be:	6d 1c       	ld.w	r12,r6[0x44]
800063c0:	00 00       	add	r0,r0
800063c2:	0d 58       	ld.sh	r8,--r6
800063c4:	80 00       	ld.sh	r0,r0[0x0]
800063c6:	cc a8       	rjmp	8000655a <logFromISR+0x15a>
800063c8:	80 00       	ld.sh	r0,r0[0x0]
800063ca:	61 9a       	ld.w	r10,r0[0x64]
800063cc:	80 00       	ld.sh	r0,r0[0x0]
800063ce:	cf 54       	brge	800063b8 <log+0x144>
800063d0:	80 00       	ld.sh	r0,r0[0x0]
800063d2:	62 74       	ld.w	r4,r1[0x1c]
800063d4:	80 00       	ld.sh	r0,r0[0x0]
800063d6:	60 e8       	ld.w	r8,r0[0x38]
800063d8:	80 00       	ld.sh	r0,r0[0x0]
800063da:	60 e4       	ld.w	r4,r0[0x38]
800063dc:	80 00       	ld.sh	r0,r0[0x0]
800063de:	cf 64       	brge	800063ca <log+0x156>
800063e0:	80 00       	ld.sh	r0,r0[0x0]
800063e2:	cf 74       	brge	800063d0 <log+0x15c>
800063e4:	80 00       	ld.sh	r0,r0[0x0]
800063e6:	70 0c       	ld.w	r12,r8[0x0]
800063e8:	80 00       	ld.sh	r0,r0[0x0]
800063ea:	cf 7c       	rcall	800065d8 <log_init+0x58>
800063ec:	80 00       	ld.sh	r0,r0[0x0]
800063ee:	cf 84       	brge	800063de <log+0x16a>
800063f0:	80 00       	ld.sh	r0,r0[0x0]
800063f2:	53 30       	stdsp	sp[0xcc],r0
800063f4:	80 00       	ld.sh	r0,r0[0x0]
800063f6:	6b d4       	ld.w	r4,r5[0x74]
800063f8:	00 00       	add	r0,r0
800063fa:	41 10       	lddsp	r0,sp[0x44]
800063fc:	80 00       	ld.sh	r0,r0[0x0]
800063fe:	56 84       	stdsp	sp[0x1a0],r4

80006400 <logFromISR>:
	
	
int logFromISR(char * content, ...)
	{
80006400:	d4 31       	pushm	r0-r7,lr
80006402:	fa cd 02 0c 	sub	sp,sp,524
80006406:	18 97       	mov	r7,r12
		
		
		char logTmp[MAX_LOG_LINE_SIZE];
		memset(logTmp, '\0', MAX_LOG_LINE_SIZE);
80006408:	e0 6a 01 00 	mov	r10,256
8000640c:	30 0b       	mov	r11,0
8000640e:	fa cc fe f4 	sub	r12,sp,-268
80006412:	f0 1f 00 4c 	mcall	80006540 <logFromISR+0x140>
	
	
}
	
	
int logFromISR(char * content, ...)
80006416:	fa c4 fd d0 	sub	r4,sp,-560
8000641a:	30 0a       	mov	r10,0
8000641c:	50 0a       	stdsp	sp[0x0],r10
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
8000641e:	fa c3 ff fc 	sub	r3,sp,-4
80006422:	e0 61 01 00 	mov	r1,256
80006426:	14 90       	mov	r0,r10
			
			if(*str == '%')
80006428:	32 52       	mov	r2,37
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
8000642a:	fa c6 fe f4 	sub	r6,sp,-268
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
8000642e:	02 9a       	mov	r10,r1
80006430:	00 9b       	mov	r11,r0
80006432:	06 9c       	mov	r12,r3
80006434:	f0 1f 00 43 	mcall	80006540 <logFromISR+0x140>
			
			if(*str == '%')
80006438:	0f 88       	ld.ub	r8,r7[0x0]
8000643a:	e4 08 18 00 	cp.b	r8,r2
8000643e:	c5 11       	brne	800064e0 <logFromISR+0xe0>
			{
				static char lench = 0;
				lench =*(str + 1);
80006440:	ee c8 ff ff 	sub	r8,r7,-1
80006444:	11 89       	ld.ub	r9,r8[0x0]
80006446:	4c 0a       	lddpc	r10,80006544 <logFromISR+0x144>
80006448:	b4 89       	st.b	r10[0x0],r9
				if((lench >= '0') &&  (lench <= '9'))
8000644a:	23 09       	sub	r9,48
8000644c:	30 9a       	mov	r10,9
8000644e:	f4 09 18 00 	cp.b	r9,r10
80006452:	ee 08 17 b0 	movhi	r8,r7
				{
					len = *(++str) - '0';
80006456:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
8000645a:	f7 b9 08 30 	subls	r9,48
8000645e:	fb f9 8a 00 	st.wls	sp[0x0],r9
				}
				
				str++;
80006462:	f0 c7 ff ff 	sub	r7,r8,-1
				
				switch(*(str))
80006466:	0f 88       	ld.ub	r8,r7[0x0]
80006468:	22 58       	sub	r8,37
8000646a:	e0 48 00 53 	cp.w	r8,83
8000646e:	e0 8b 00 2b 	brhi	800064c4 <logFromISR+0xc4>
80006472:	4b 69       	lddpc	r9,80006548 <logFromISR+0x148>
80006474:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
				{
					case('d'):
					case('D'):
					x = va_arg(arg_ptr,int);
80006478:	e8 c5 ff fc 	sub	r5,r4,-4
					strTmp = PrintDec(x, len, strTmp);
8000647c:	06 9a       	mov	r10,r3
8000647e:	40 0b       	lddsp	r11,sp[0x0]
80006480:	5c 5b       	castu.b	r11
80006482:	68 0c       	ld.w	r12,r4[0x0]
80006484:	f0 1f 00 32 	mcall	8000654c <logFromISR+0x14c>
					break;
80006488:	c2 38       	rjmp	800064ce <logFromISR+0xce>
					case('x'):
					case('X'):
					x = va_arg(arg_ptr,int);
8000648a:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintHex(x,len, strTmp);
8000648e:	06 9a       	mov	r10,r3
80006490:	40 0b       	lddsp	r11,sp[0x0]
80006492:	5c 5b       	castu.b	r11
80006494:	68 0c       	ld.w	r12,r4[0x0]
80006496:	f0 1f 00 2f 	mcall	80006550 <logFromISR+0x150>
8000649a:	06 9c       	mov	r12,r3
					break;
8000649c:	c1 98       	rjmp	800064ce <logFromISR+0xce>
					case('c'):
					case('C'):
					y = va_arg(arg_ptr,int);
8000649e:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintChar(y, strTmp);
800064a2:	06 9b       	mov	r11,r3
800064a4:	09 bc       	ld.ub	r12,r4[0x3]
800064a6:	f0 1f 00 2c 	mcall	80006554 <logFromISR+0x154>
800064aa:	06 9c       	mov	r12,r3
					break;
800064ac:	c1 18       	rjmp	800064ce <logFromISR+0xce>
					case('s'):
					case('S'):
					strTmp = va_arg(arg_ptr,char*);
800064ae:	e8 c5 ff fc 	sub	r5,r4,-4
800064b2:	68 0c       	ld.w	r12,r4[0x0]
					//PrintStr(s);
					break;
800064b4:	c0 d8       	rjmp	800064ce <logFromISR+0xce>
					case('%'):
					PrintChar('%', strTmp);
800064b6:	06 9b       	mov	r11,r3
800064b8:	32 5c       	mov	r12,37
800064ba:	f0 1f 00 27 	mcall	80006554 <logFromISR+0x154>
800064be:	08 95       	mov	r5,r4
800064c0:	06 9c       	mov	r12,r3
					//PrintChar('%');
					break;
800064c2:	c0 68       	rjmp	800064ce <logFromISR+0xce>
					default:
					log("I need relax.");
800064c4:	4a 5c       	lddpc	r12,80006558 <logFromISR+0x158>
800064c6:	f0 1f 00 26 	mcall	8000655c <logFromISR+0x15c>
800064ca:	08 95       	mov	r5,r4
800064cc:	06 9c       	mov	r12,r3
				}
				str++;
800064ce:	2f f7       	sub	r7,-1
				
				length = sprintf(logTmp,"%s%s",logTmp,strTmp );
800064d0:	1a dc       	st.w	--sp,r12
800064d2:	1a d6       	st.w	--sp,r6
800064d4:	4a 3b       	lddpc	r11,80006560 <logFromISR+0x160>
800064d6:	0c 9c       	mov	r12,r6
800064d8:	f0 1f 00 23 	mcall	80006564 <logFromISR+0x164>
800064dc:	2f ed       	sub	sp,-8
800064de:	c0 a8       	rjmp	800064f2 <logFromISR+0xf2>
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
800064e0:	2f f7       	sub	r7,-1
800064e2:	1a d8       	st.w	--sp,r8
800064e4:	1a d6       	st.w	--sp,r6
800064e6:	4a 1b       	lddpc	r11,80006568 <logFromISR+0x168>
800064e8:	0c 9c       	mov	r12,r6
800064ea:	f0 1f 00 1f 	mcall	80006564 <logFromISR+0x164>
800064ee:	08 95       	mov	r5,r4
800064f0:	2f ed       	sub	sp,-8
			
			
			
		}while(*str != '\0');
800064f2:	0f 89       	ld.ub	r9,r7[0x0]
800064f4:	30 08       	mov	r8,0
800064f6:	f0 09 18 00 	cp.b	r9,r8
800064fa:	c0 30       	breq	80006500 <logFromISR+0x100>
800064fc:	0a 94       	mov	r4,r5
800064fe:	c9 8b       	rjmp	8000642e <logFromISR+0x2e>
		
		
		
		va_end(arg_ptr);
		//while(1)
		length = sprintf(logTmp,"%s\r\n",logTmp);
80006500:	fa c7 fe f4 	sub	r7,sp,-268
80006504:	1a d7       	st.w	--sp,r7
80006506:	49 ab       	lddpc	r11,8000656c <logFromISR+0x16c>
80006508:	0e 9c       	mov	r12,r7
8000650a:	f0 1f 00 17 	mcall	80006564 <logFromISR+0x164>
		
		char * p = pvPortMalloc(length+1);
8000650e:	5c 5c       	castu.b	r12
80006510:	f8 c6 ff ff 	sub	r6,r12,-1
80006514:	0c 9c       	mov	r12,r6
80006516:	f0 1f 00 17 	mcall	80006570 <logFromISR+0x170>
8000651a:	54 3c       	stdsp	sp[0x10c],r12
		memcpy(p, logTmp, length+1);
8000651c:	0c 9a       	mov	r10,r6
8000651e:	0e 9b       	mov	r11,r7
80006520:	f0 1f 00 15 	mcall	80006574 <logFromISR+0x174>
		//
		portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80006524:	30 09       	mov	r9,0
80006526:	54 29       	stdsp	sp[0x108],r9
		
		//usart_write_line(EXAMPLE_USART, p);
		//vPortFree(p);
		xQueueSendFromISR( logQueue, &p, &xHigherPriorityTaskWoken );
80006528:	fa ca fe f8 	sub	r10,sp,-264
8000652c:	fa cb fe f4 	sub	r11,sp,-268
80006530:	49 28       	lddpc	r8,80006578 <logFromISR+0x178>
80006532:	70 0c       	ld.w	r12,r8[0x0]
80006534:	f0 1f 00 12 	mcall	8000657c <logFromISR+0x17c>
80006538:	2f fd       	sub	sp,-4
		
		//if (xHigherPriorityTaskWoken == pdTRUE)
		//{
			////taskYIELD();
		//}
	}
8000653a:	fe 3d fd f4 	sub	sp,-524
8000653e:	d8 32       	popm	r0-r7,pc
80006540:	80 00       	ld.sh	r0,r0[0x0]
80006542:	6d 1c       	ld.w	r12,r6[0x44]
80006544:	00 00       	add	r0,r0
80006546:	0d 59       	ld.sh	r9,--r6
80006548:	80 00       	ld.sh	r0,r0[0x0]
8000654a:	cd f8       	rjmp	80006708 <gpio_enable_module_pin+0x50>
8000654c:	80 00       	ld.sh	r0,r0[0x0]
8000654e:	61 9a       	ld.w	r10,r0[0x64]
80006550:	80 00       	ld.sh	r0,r0[0x0]
80006552:	60 e8       	ld.w	r8,r0[0x38]
80006554:	80 00       	ld.sh	r0,r0[0x0]
80006556:	60 e4       	ld.w	r4,r0[0x38]
80006558:	80 00       	ld.sh	r0,r0[0x0]
8000655a:	cf 64       	brge	80006546 <logFromISR+0x146>
8000655c:	80 00       	ld.sh	r0,r0[0x0]
8000655e:	62 74       	ld.w	r4,r1[0x1c]
80006560:	80 00       	ld.sh	r0,r0[0x0]
80006562:	cf 74       	brge	80006550 <logFromISR+0x150>
80006564:	80 00       	ld.sh	r0,r0[0x0]
80006566:	70 0c       	ld.w	r12,r8[0x0]
80006568:	80 00       	ld.sh	r0,r0[0x0]
8000656a:	cf 7c       	rcall	80006758 <idata_load_loop>
8000656c:	80 00       	ld.sh	r0,r0[0x0]
8000656e:	cf 84       	brge	8000655e <logFromISR+0x15e>
80006570:	80 00       	ld.sh	r0,r0[0x0]
80006572:	53 30       	stdsp	sp[0xcc],r0
80006574:	80 00       	ld.sh	r0,r0[0x0]
80006576:	6b d4       	ld.w	r4,r5[0x74]
80006578:	00 00       	add	r0,r0
8000657a:	41 10       	lddsp	r0,sp[0x44]
8000657c:	80 00       	ld.sh	r0,r0[0x0]
8000657e:	56 34       	stdsp	sp[0x18c],r4

80006580 <log_init>:
		
	return str;
}

void log_init(void)
{
80006580:	d4 01       	pushm	lr
		.stopbits     = USART_1_STOPBIT,
		.channelmode  = USART_NORMAL_CHMODE
	};

	// Assign GPIO to USART.
	gpio_enable_module(USART_GPIO_MAP,
80006582:	30 2b       	mov	r11,2
80006584:	49 0c       	lddpc	r12,800065c4 <log_init+0x44>
80006586:	f0 1f 00 11 	mcall	800065c8 <log_init+0x48>
	sizeof(USART_GPIO_MAP) / sizeof(USART_GPIO_MAP[0]));

	// Initialize USART in RS232 mode.
	usart_init_rs232(EXAMPLE_USART, &USART_OPTIONS, EXAMPLE_TARGET_PBACLK_FREQ_HZ);			
8000658a:	e0 6a 36 00 	mov	r10,13824
8000658e:	ea 1a 01 6e 	orh	r10,0x16e
80006592:	48 fb       	lddpc	r11,800065cc <log_init+0x4c>
80006594:	fe 7c 18 00 	mov	r12,-59392
80006598:	f0 1f 00 0e 	mcall	800065d0 <log_init+0x50>
			
	logQueue  = xQueueCreate(50, sizeof(char *));
8000659c:	30 4b       	mov	r11,4
8000659e:	33 2c       	mov	r12,50
800065a0:	f0 1f 00 0d 	mcall	800065d4 <log_init+0x54>
800065a4:	48 d8       	lddpc	r8,800065d8 <log_init+0x58>
800065a6:	91 0c       	st.w	r8[0x0],r12
	
	xTaskCreate(
800065a8:	30 09       	mov	r9,0
800065aa:	1a d9       	st.w	--sp,r9
800065ac:	1a d9       	st.w	--sp,r9
800065ae:	1a d9       	st.w	--sp,r9
800065b0:	30 28       	mov	r8,2
800065b2:	e0 6a 01 80 	mov	r10,384
800065b6:	48 ab       	lddpc	r11,800065dc <log_init+0x5c>
800065b8:	48 ac       	lddpc	r12,800065e0 <log_init+0x60>
800065ba:	f0 1f 00 0b 	mcall	800065e4 <log_init+0x64>
800065be:	2f dd       	sub	sp,-12
	,  384
	,  NULL
	,  tskLOG_PRIORITY
	,  NULL );
	
}
800065c0:	d8 02       	popm	pc
800065c2:	00 00       	add	r0,r0
800065c4:	80 00       	ld.sh	r0,r0[0x0]
800065c6:	cf 90       	breq	800065b8 <log_init+0x38>
800065c8:	80 00       	ld.sh	r0,r0[0x0]
800065ca:	67 0c       	ld.w	r12,r3[0x40]
800065cc:	80 00       	ld.sh	r0,r0[0x0]
800065ce:	cf 48       	rjmp	800067b6 <_malloc_r+0x1a>
800065d0:	80 00       	ld.sh	r0,r0[0x0]
800065d2:	4e d4       	lddpc	r4,80006784 <free+0x8>
800065d4:	80 00       	ld.sh	r0,r0[0x0]
800065d6:	57 dc       	stdsp	sp[0x1f4],r12
800065d8:	00 00       	add	r0,r0
800065da:	41 10       	lddsp	r0,sp[0x44]
800065dc:	80 00       	ld.sh	r0,r0[0x0]
800065de:	cf 8c       	rcall	800067ce <_malloc_r+0x32>
800065e0:	80 00       	ld.sh	r0,r0[0x0]
800065e2:	65 e8       	ld.w	r8,r2[0x78]
800065e4:	80 00       	ld.sh	r0,r0[0x0]
800065e6:	5e b0       	rethi	r0

800065e8 <task_log>:
			////taskYIELD();
		//}
	}
	
static void task_log(void * pvParameters)
{
800065e8:	eb cd 40 f8 	pushm	r3-r7,lr
800065ec:	20 1d       	sub	sp,4
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
800065ee:	48 c7       	lddpc	r7,8000661c <task_log+0x34>
800065f0:	30 05       	mov	r5,0
800065f2:	3f f4       	mov	r4,-1
		{
			if( NULL != str)
			{
				usart_write_line(EXAMPLE_USART, str);
800065f4:	fe 73 18 00 	mov	r3,-59392
{
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
800065f8:	0a 99       	mov	r9,r5
800065fa:	08 9a       	mov	r10,r4
800065fc:	1a 9b       	mov	r11,sp
800065fe:	6e 0c       	ld.w	r12,r7[0x0]
80006600:	f0 1f 00 08 	mcall	80006620 <task_log+0x38>
80006604:	58 1c       	cp.w	r12,1
80006606:	cf 91       	brne	800065f8 <task_log+0x10>
		{
			if( NULL != str)
80006608:	40 0b       	lddsp	r11,sp[0x0]
8000660a:	58 0b       	cp.w	r11,0
8000660c:	cf 60       	breq	800065f8 <task_log+0x10>
			{
				usart_write_line(EXAMPLE_USART, str);
8000660e:	06 9c       	mov	r12,r3
80006610:	f0 1f 00 05 	mcall	80006624 <task_log+0x3c>
				vPortFree(str);
80006614:	40 0c       	lddsp	r12,sp[0x0]
80006616:	f0 1f 00 05 	mcall	80006628 <task_log+0x40>
8000661a:	ce fb       	rjmp	800065f8 <task_log+0x10>
8000661c:	00 00       	add	r0,r0
8000661e:	41 10       	lddsp	r0,sp[0x44]
80006620:	80 00       	ld.sh	r0,r0[0x0]
80006622:	54 78       	stdsp	sp[0x11c],r8
80006624:	80 00       	ld.sh	r0,r0[0x0]
80006626:	4e 84       	lddpc	r4,800067c4 <_malloc_r+0x28>
80006628:	80 00       	ld.sh	r0,r0[0x0]
8000662a:	53 08       	stdsp	sp[0xc0],r8

8000662c <main>:

#include "fs/fs.h"
#include "rtc/rtc.h"

int main(void)
{
8000662c:	d4 01       	pushm	lr
	//Force SSC_TX_DATA_ENABLE Disabled as soon as possible.
	AVR32_GPIO.port[1].ovrs  =  0x00000001;  //Value will be high.
8000662e:	fe 78 10 00 	mov	r8,-61440
80006632:	30 19       	mov	r9,1
80006634:	f1 49 01 54 	st.w	r8[340],r9
	AVR32_GPIO.port[1].oders =  0x00000001;  //Output Driver will be Enabled.
80006638:	f1 49 01 44 	st.w	r8[324],r9
	AVR32_GPIO.port[1].gpers =  0x00000001;  //Enable as GPIO.
8000663c:	f1 49 01 04 	st.w	r8[260],r9
	
	Disable_global_interrupt();
80006640:	d3 03       	ssrf	0x10
	local_start_pll0();
80006642:	f0 1f 00 13 	mcall	8000668c <main+0x60>
		
	INTC_init_interrupts();
80006646:	f0 1f 00 13 	mcall	80006690 <main+0x64>
	
	log_init();		
8000664a:	f0 1f 00 13 	mcall	80006694 <main+0x68>
	log("----start debug----");	
8000664e:	49 3c       	lddpc	r12,80006698 <main+0x6c>
80006650:	f0 1f 00 13 	mcall	8000669c <main+0x70>
		
	rtc_init();
80006654:	f0 1f 00 13 	mcall	800066a0 <main+0x74>
	
	//fs_init();//65795机器无法通过文件系统初始化,究起原因，貌似是Radio对OB板的输出功率无法满足SD卡的正常工作。

	tc_init();	
80006658:	f0 1f 00 13 	mcall	800066a4 <main+0x78>
			
	xcmp_init();
8000665c:	f0 1f 00 13 	mcall	800066a8 <main+0x7c>
	
	app_init();
80006660:	f0 1f 00 13 	mcall	800066ac <main+0x80>
		
	while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
80006664:	fe 79 10 00 	mov	r9,-61440
80006668:	f2 f8 01 60 	ld.w	r8,r9[352]
8000666c:	e2 18 00 02 	andl	r8,0x2,COH
80006670:	cf c0       	breq	80006668 <main+0x3c>
	while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
80006672:	fe 79 10 00 	mov	r9,-61440
80006676:	f2 f8 01 60 	ld.w	r8,r9[352]
8000667a:	e2 18 00 02 	andl	r8,0x2,COH
8000667e:	cf c1       	brne	80006676 <main+0x4a>
	local_start_timer();
80006680:	f0 1f 00 0c 	mcall	800066b0 <main+0x84>
	
	Enable_global_interrupt();
80006684:	d5 03       	csrf	0x10
	
	vTaskStartScheduler();		
80006686:	f0 1f 00 0c 	mcall	800066b4 <main+0x88>
	return 0;
}
8000668a:	d8 0a       	popm	pc,r12=0
8000668c:	80 00       	ld.sh	r0,r0[0x0]
8000668e:	47 a4       	lddsp	r4,sp[0x1e8]
80006690:	80 00       	ld.sh	r0,r0[0x0]
80006692:	49 c0       	lddpc	r0,80006700 <gpio_enable_module_pin+0x48>
80006694:	80 00       	ld.sh	r0,r0[0x0]
80006696:	65 80       	ld.w	r0,r2[0x60]
80006698:	80 00       	ld.sh	r0,r0[0x0]
8000669a:	cf a0       	breq	8000668e <main+0x62>
8000669c:	80 00       	ld.sh	r0,r0[0x0]
8000669e:	62 74       	ld.w	r4,r1[0x1c]
800066a0:	80 00       	ld.sh	r0,r0[0x0]
800066a2:	47 f4       	lddsp	r4,sp[0x1fc]
800066a4:	80 00       	ld.sh	r0,r0[0x0]
800066a6:	48 bc       	lddpc	r12,800066d0 <gpio_enable_module_pin+0x18>
800066a8:	80 00       	ld.sh	r0,r0[0x0]
800066aa:	40 a8       	lddsp	r8,sp[0x28]
800066ac:	80 00       	ld.sh	r0,r0[0x0]
800066ae:	20 40       	sub	r0,4
800066b0:	80 00       	ld.sh	r0,r0[0x0]
800066b2:	48 80       	lddpc	r0,800066d0 <gpio_enable_module_pin+0x18>
800066b4:	80 00       	ld.sh	r0,r0[0x0]
800066b6:	60 98       	ld.w	r8,r0[0x24]

800066b8 <gpio_enable_module_pin>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800066b8:	f8 08 16 05 	lsr	r8,r12,0x5
800066bc:	a9 68       	lsl	r8,0x8
800066be:	e0 28 f0 00 	sub	r8,61440

	/* Enable the correct function. */
	switch (function) {
800066c2:	58 1b       	cp.w	r11,1
800066c4:	c0 d0       	breq	800066de <gpio_enable_module_pin+0x26>
800066c6:	c0 63       	brcs	800066d2 <gpio_enable_module_pin+0x1a>
800066c8:	58 2b       	cp.w	r11,2
800066ca:	c1 00       	breq	800066ea <gpio_enable_module_pin+0x32>
800066cc:	58 3b       	cp.w	r11,3
800066ce:	c1 40       	breq	800066f6 <gpio_enable_module_pin+0x3e>
800066d0:	5e ff       	retal	1
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
800066d2:	30 19       	mov	r9,1
800066d4:	f2 0c 09 49 	lsl	r9,r9,r12
800066d8:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
800066da:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
800066dc:	c1 28       	rjmp	80006700 <gpio_enable_module_pin+0x48>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
800066de:	30 19       	mov	r9,1
800066e0:	f2 0c 09 49 	lsl	r9,r9,r12
800066e4:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
800066e6:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
800066e8:	c0 c8       	rjmp	80006700 <gpio_enable_module_pin+0x48>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
800066ea:	30 19       	mov	r9,1
800066ec:	f2 0c 09 49 	lsl	r9,r9,r12
800066f0:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
800066f2:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
800066f4:	c0 68       	rjmp	80006700 <gpio_enable_module_pin+0x48>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
800066f6:	30 19       	mov	r9,1
800066f8:	f2 0c 09 49 	lsl	r9,r9,r12
800066fc:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
800066fe:	91 99       	st.w	r8[0x24],r9
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
80006700:	30 19       	mov	r9,1
80006702:	f2 0c 09 4c 	lsl	r12,r9,r12
80006706:	91 2c       	st.w	r8[0x8],r12
80006708:	5e fd       	retal	0
8000670a:	d7 03       	nop

8000670c <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
8000670c:	d4 21       	pushm	r4-r7,lr
8000670e:	18 97       	mov	r7,r12
80006710:	16 94       	mov	r4,r11
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80006712:	58 0b       	cp.w	r11,0
80006714:	c0 31       	brne	8000671a <gpio_enable_module+0xe>
80006716:	30 05       	mov	r5,0
80006718:	c0 d8       	rjmp	80006732 <gpio_enable_module+0x26>
8000671a:	30 06       	mov	r6,0
8000671c:	0c 95       	mov	r5,r6
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
8000671e:	6e 1b       	ld.w	r11,r7[0x4]
80006720:	6e 0c       	ld.w	r12,r7[0x0]
80006722:	f0 1f 00 06 	mcall	80006738 <gpio_enable_module+0x2c>
80006726:	18 45       	or	r5,r12
		gpiomap++;
80006728:	2f 87       	sub	r7,-8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
8000672a:	2f f6       	sub	r6,-1
8000672c:	0c 34       	cp.w	r4,r6
8000672e:	fe 9b ff f8 	brhi	8000671e <gpio_enable_module+0x12>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
}
80006732:	0a 9c       	mov	r12,r5
80006734:	d8 22       	popm	r4-r7,pc
80006736:	00 00       	add	r0,r0
80006738:	80 00       	ld.sh	r0,r0[0x0]
8000673a:	66 b8       	ld.w	r8,r3[0x2c]

8000673c <_stext>:

  .global _stext
  .type _stext, @function
_stext:
  // Set initial stack pointer.
  lda.w   sp, _estack
8000673c:	e0 7d 80 00 	mov	sp,98304

  // Set up EVBA so interrupts can be enabled.
  lda.w   r0, _evba
  mtsr    AVR32_EVBA, r0
80006740:	fe c0 a5 40 	sub	r0,pc,-23232

  // Enable the exception processing.
  csrf    AVR32_SR_EM_OFFSET
80006744:	e3 b0 00 01 	mtsr	0x4,r0

  // Load initialized data having a global lifetime from the data LMA.
  lda.w   r0, _data
  lda.w   r1, _edata
80006748:	d5 53       	csrf	0x15
  cp      r0, r1
8000674a:	30 80       	mov	r0,8
  brhs    idata_load_loop_end
8000674c:	e0 61 0a 38 	mov	r1,2616
  lda.w   r2, _data_lma
idata_load_loop:
  ld.d    r4, r2++
80006750:	02 30       	cp.w	r0,r1
  st.d    r0++, r4
80006752:	c0 72       	brcc	80006760 <idata_load_loop_end>
  cp      r0, r1
80006754:	fe c2 92 1c 	sub	r2,pc,-28132

80006758 <idata_load_loop>:
  brlo    idata_load_loop
idata_load_loop_end:

  // Clear uninitialized data having a global lifetime in the blank static storage section.
  lda.w   r0, __bss_start
80006758:	a5 05       	ld.d	r4,r2++
  lda.w   r1, _end
8000675a:	a1 24       	st.d	r0++,r4
  cp      r0, r1
8000675c:	02 30       	cp.w	r0,r1
  brhs    udata_clear_loop_end
8000675e:	cf d3       	brcs	80006758 <idata_load_loop>

80006760 <idata_load_loop_end>:
  mov     r2, 0
80006760:	e0 60 0a 38 	mov	r0,2616
  mov     r3, 0
udata_clear_loop:
  st.d    r0++, r2
80006764:	e0 61 41 18 	mov	r1,16664
  cp      r0, r1
  brlo    udata_clear_loop
80006768:	02 30       	cp.w	r0,r1
  // Safety: Set the default "return" @ to the exit routine address.
  lda.w   lr, exit
#endif

  // Start the show.
  lda.w   pc, main
8000676a:	c0 62       	brcc	80006776 <udata_clear_loop_end>
8000676c:	30 02       	mov	r2,0
8000676e:	30 03       	mov	r3,0

80006770 <udata_clear_loop>:
80006770:	a1 22       	st.d	r0++,r2
80006772:	02 30       	cp.w	r0,r1
80006774:	cf e3       	brcs	80006770 <udata_clear_loop>

80006776 <udata_clear_loop_end>:
80006776:	fe cf 01 4a 	sub	pc,pc,330
8000677a:	d7 03       	nop

8000677c <free>:
8000677c:	d4 01       	pushm	lr
8000677e:	e0 68 0a 30 	mov	r8,2608
80006782:	18 9b       	mov	r11,r12
80006784:	70 0c       	ld.w	r12,r8[0x0]
80006786:	e0 a0 1e 6d 	rcall	8000a460 <_free_r>
8000678a:	d8 02       	popm	pc

8000678c <malloc>:
8000678c:	d4 01       	pushm	lr
8000678e:	e0 68 0a 30 	mov	r8,2608
80006792:	18 9b       	mov	r11,r12
80006794:	70 0c       	ld.w	r12,r8[0x0]
80006796:	c0 3c       	rcall	8000679c <_malloc_r>
80006798:	d8 02       	popm	pc
8000679a:	d7 03       	nop

8000679c <_malloc_r>:
8000679c:	d4 31       	pushm	r0-r7,lr
8000679e:	f6 c8 ff f5 	sub	r8,r11,-11
800067a2:	18 95       	mov	r5,r12
800067a4:	10 97       	mov	r7,r8
800067a6:	e0 17 ff f8 	andl	r7,0xfff8
800067aa:	59 68       	cp.w	r8,22
800067ac:	f9 b7 08 10 	movls	r7,16
800067b0:	16 37       	cp.w	r7,r11
800067b2:	5f 38       	srlo	r8
800067b4:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
800067b8:	c0 50       	breq	800067c2 <_malloc_r+0x26>
800067ba:	30 c8       	mov	r8,12
800067bc:	99 38       	st.w	r12[0xc],r8
800067be:	e0 8f 01 fa 	bral	80006bb2 <_malloc_r+0x416>
800067c2:	fe b0 f5 59 	rcall	80005274 <__malloc_lock>
800067c6:	e0 47 01 f7 	cp.w	r7,503
800067ca:	e0 8b 00 1d 	brhi	80006804 <_malloc_r+0x68>
800067ce:	ee 03 16 03 	lsr	r3,r7,0x3
800067d2:	e0 68 05 30 	mov	r8,1328
800067d6:	f0 03 00 38 	add	r8,r8,r3<<0x3
800067da:	70 36       	ld.w	r6,r8[0xc]
800067dc:	10 36       	cp.w	r6,r8
800067de:	c0 61       	brne	800067ea <_malloc_r+0x4e>
800067e0:	ec c8 ff f8 	sub	r8,r6,-8
800067e4:	70 36       	ld.w	r6,r8[0xc]
800067e6:	10 36       	cp.w	r6,r8
800067e8:	c0 c0       	breq	80006800 <_malloc_r+0x64>
800067ea:	6c 18       	ld.w	r8,r6[0x4]
800067ec:	e0 18 ff fc 	andl	r8,0xfffc
800067f0:	6c 3a       	ld.w	r10,r6[0xc]
800067f2:	ec 08 00 09 	add	r9,r6,r8
800067f6:	0a 9c       	mov	r12,r5
800067f8:	6c 28       	ld.w	r8,r6[0x8]
800067fa:	95 28       	st.w	r10[0x8],r8
800067fc:	91 3a       	st.w	r8[0xc],r10
800067fe:	c4 78       	rjmp	8000688c <_malloc_r+0xf0>
80006800:	2f e3       	sub	r3,-2
80006802:	c4 d8       	rjmp	8000689c <_malloc_r+0x100>
80006804:	ee 03 16 09 	lsr	r3,r7,0x9
80006808:	c0 41       	brne	80006810 <_malloc_r+0x74>
8000680a:	ee 03 16 03 	lsr	r3,r7,0x3
8000680e:	c2 68       	rjmp	8000685a <_malloc_r+0xbe>
80006810:	58 43       	cp.w	r3,4
80006812:	e0 8b 00 06 	brhi	8000681e <_malloc_r+0x82>
80006816:	ee 03 16 06 	lsr	r3,r7,0x6
8000681a:	2c 83       	sub	r3,-56
8000681c:	c1 f8       	rjmp	8000685a <_malloc_r+0xbe>
8000681e:	59 43       	cp.w	r3,20
80006820:	e0 8b 00 04 	brhi	80006828 <_malloc_r+0x8c>
80006824:	2a 53       	sub	r3,-91
80006826:	c1 a8       	rjmp	8000685a <_malloc_r+0xbe>
80006828:	e0 43 00 54 	cp.w	r3,84
8000682c:	e0 8b 00 06 	brhi	80006838 <_malloc_r+0x9c>
80006830:	ee 03 16 0c 	lsr	r3,r7,0xc
80006834:	29 23       	sub	r3,-110
80006836:	c1 28       	rjmp	8000685a <_malloc_r+0xbe>
80006838:	e0 43 01 54 	cp.w	r3,340
8000683c:	e0 8b 00 06 	brhi	80006848 <_malloc_r+0xac>
80006840:	ee 03 16 0f 	lsr	r3,r7,0xf
80006844:	28 93       	sub	r3,-119
80006846:	c0 a8       	rjmp	8000685a <_malloc_r+0xbe>
80006848:	e0 43 05 54 	cp.w	r3,1364
8000684c:	e0 88 00 04 	brls	80006854 <_malloc_r+0xb8>
80006850:	37 e3       	mov	r3,126
80006852:	c0 48       	rjmp	8000685a <_malloc_r+0xbe>
80006854:	ee 03 16 12 	lsr	r3,r7,0x12
80006858:	28 43       	sub	r3,-124
8000685a:	e0 6a 05 30 	mov	r10,1328
8000685e:	f4 03 00 3a 	add	r10,r10,r3<<0x3
80006862:	74 36       	ld.w	r6,r10[0xc]
80006864:	c1 98       	rjmp	80006896 <_malloc_r+0xfa>
80006866:	6c 19       	ld.w	r9,r6[0x4]
80006868:	e0 19 ff fc 	andl	r9,0xfffc
8000686c:	f2 07 01 0b 	sub	r11,r9,r7
80006870:	58 fb       	cp.w	r11,15
80006872:	e0 8a 00 04 	brle	8000687a <_malloc_r+0xde>
80006876:	20 13       	sub	r3,1
80006878:	c1 18       	rjmp	8000689a <_malloc_r+0xfe>
8000687a:	6c 38       	ld.w	r8,r6[0xc]
8000687c:	58 0b       	cp.w	r11,0
8000687e:	c0 b5       	brlt	80006894 <_malloc_r+0xf8>
80006880:	6c 2a       	ld.w	r10,r6[0x8]
80006882:	ec 09 00 09 	add	r9,r6,r9
80006886:	0a 9c       	mov	r12,r5
80006888:	91 2a       	st.w	r8[0x8],r10
8000688a:	95 38       	st.w	r10[0xc],r8
8000688c:	72 18       	ld.w	r8,r9[0x4]
8000688e:	a1 a8       	sbr	r8,0x0
80006890:	93 18       	st.w	r9[0x4],r8
80006892:	cb c8       	rjmp	80006a0a <_malloc_r+0x26e>
80006894:	10 96       	mov	r6,r8
80006896:	14 36       	cp.w	r6,r10
80006898:	ce 71       	brne	80006866 <_malloc_r+0xca>
8000689a:	2f f3       	sub	r3,-1
8000689c:	e0 6a 05 30 	mov	r10,1328
800068a0:	f4 cc ff f8 	sub	r12,r10,-8
800068a4:	78 26       	ld.w	r6,r12[0x8]
800068a6:	18 36       	cp.w	r6,r12
800068a8:	c6 c0       	breq	80006980 <_malloc_r+0x1e4>
800068aa:	6c 19       	ld.w	r9,r6[0x4]
800068ac:	e0 19 ff fc 	andl	r9,0xfffc
800068b0:	f2 07 01 08 	sub	r8,r9,r7
800068b4:	58 f8       	cp.w	r8,15
800068b6:	e0 89 00 8f 	brgt	800069d4 <_malloc_r+0x238>
800068ba:	99 3c       	st.w	r12[0xc],r12
800068bc:	99 2c       	st.w	r12[0x8],r12
800068be:	58 08       	cp.w	r8,0
800068c0:	c0 55       	brlt	800068ca <_malloc_r+0x12e>
800068c2:	ec 09 00 09 	add	r9,r6,r9
800068c6:	0a 9c       	mov	r12,r5
800068c8:	ce 2b       	rjmp	8000688c <_malloc_r+0xf0>
800068ca:	e0 49 01 ff 	cp.w	r9,511
800068ce:	e0 8b 00 13 	brhi	800068f4 <_malloc_r+0x158>
800068d2:	a3 99       	lsr	r9,0x3
800068d4:	f4 09 00 38 	add	r8,r10,r9<<0x3
800068d8:	70 2b       	ld.w	r11,r8[0x8]
800068da:	8d 38       	st.w	r6[0xc],r8
800068dc:	8d 2b       	st.w	r6[0x8],r11
800068de:	97 36       	st.w	r11[0xc],r6
800068e0:	91 26       	st.w	r8[0x8],r6
800068e2:	a3 49       	asr	r9,0x2
800068e4:	74 18       	ld.w	r8,r10[0x4]
800068e6:	30 1b       	mov	r11,1
800068e8:	f6 09 09 49 	lsl	r9,r11,r9
800068ec:	f1 e9 10 09 	or	r9,r8,r9
800068f0:	95 19       	st.w	r10[0x4],r9
800068f2:	c4 78       	rjmp	80006980 <_malloc_r+0x1e4>
800068f4:	f2 0a 16 09 	lsr	r10,r9,0x9
800068f8:	58 4a       	cp.w	r10,4
800068fa:	e0 8b 00 07 	brhi	80006908 <_malloc_r+0x16c>
800068fe:	f2 0a 16 06 	lsr	r10,r9,0x6
80006902:	2c 8a       	sub	r10,-56
80006904:	c2 08       	rjmp	80006944 <_malloc_r+0x1a8>
80006906:	d7 03       	nop
80006908:	59 4a       	cp.w	r10,20
8000690a:	e0 8b 00 04 	brhi	80006912 <_malloc_r+0x176>
8000690e:	2a 5a       	sub	r10,-91
80006910:	c1 a8       	rjmp	80006944 <_malloc_r+0x1a8>
80006912:	e0 4a 00 54 	cp.w	r10,84
80006916:	e0 8b 00 06 	brhi	80006922 <_malloc_r+0x186>
8000691a:	f2 0a 16 0c 	lsr	r10,r9,0xc
8000691e:	29 2a       	sub	r10,-110
80006920:	c1 28       	rjmp	80006944 <_malloc_r+0x1a8>
80006922:	e0 4a 01 54 	cp.w	r10,340
80006926:	e0 8b 00 06 	brhi	80006932 <_malloc_r+0x196>
8000692a:	f2 0a 16 0f 	lsr	r10,r9,0xf
8000692e:	28 9a       	sub	r10,-119
80006930:	c0 a8       	rjmp	80006944 <_malloc_r+0x1a8>
80006932:	e0 4a 05 54 	cp.w	r10,1364
80006936:	e0 88 00 04 	brls	8000693e <_malloc_r+0x1a2>
8000693a:	37 ea       	mov	r10,126
8000693c:	c0 48       	rjmp	80006944 <_malloc_r+0x1a8>
8000693e:	f2 0a 16 12 	lsr	r10,r9,0x12
80006942:	28 4a       	sub	r10,-124
80006944:	e0 6b 05 30 	mov	r11,1328
80006948:	f6 0a 00 34 	add	r4,r11,r10<<0x3
8000694c:	68 28       	ld.w	r8,r4[0x8]
8000694e:	08 38       	cp.w	r8,r4
80006950:	c0 e1       	brne	8000696c <_malloc_r+0x1d0>
80006952:	76 19       	ld.w	r9,r11[0x4]
80006954:	a3 4a       	asr	r10,0x2
80006956:	30 1e       	mov	lr,1
80006958:	fc 0a 09 4a 	lsl	r10,lr,r10
8000695c:	f3 ea 10 0a 	or	r10,r9,r10
80006960:	10 99       	mov	r9,r8
80006962:	97 1a       	st.w	r11[0x4],r10
80006964:	c0 a8       	rjmp	80006978 <_malloc_r+0x1dc>
80006966:	70 28       	ld.w	r8,r8[0x8]
80006968:	08 38       	cp.w	r8,r4
8000696a:	c0 60       	breq	80006976 <_malloc_r+0x1da>
8000696c:	70 1a       	ld.w	r10,r8[0x4]
8000696e:	e0 1a ff fc 	andl	r10,0xfffc
80006972:	14 39       	cp.w	r9,r10
80006974:	cf 93       	brcs	80006966 <_malloc_r+0x1ca>
80006976:	70 39       	ld.w	r9,r8[0xc]
80006978:	8d 39       	st.w	r6[0xc],r9
8000697a:	8d 28       	st.w	r6[0x8],r8
8000697c:	91 36       	st.w	r8[0xc],r6
8000697e:	93 26       	st.w	r9[0x8],r6
80006980:	e6 08 14 02 	asr	r8,r3,0x2
80006984:	30 1b       	mov	r11,1
80006986:	e0 64 05 30 	mov	r4,1328
8000698a:	f6 08 09 4b 	lsl	r11,r11,r8
8000698e:	68 18       	ld.w	r8,r4[0x4]
80006990:	10 3b       	cp.w	r11,r8
80006992:	e0 8b 00 6b 	brhi	80006a68 <_malloc_r+0x2cc>
80006996:	f7 e8 00 09 	and	r9,r11,r8
8000699a:	c0 b1       	brne	800069b0 <_malloc_r+0x214>
8000699c:	e0 13 ff fc 	andl	r3,0xfffc
800069a0:	a1 7b       	lsl	r11,0x1
800069a2:	2f c3       	sub	r3,-4
800069a4:	c0 38       	rjmp	800069aa <_malloc_r+0x20e>
800069a6:	2f c3       	sub	r3,-4
800069a8:	a1 7b       	lsl	r11,0x1
800069aa:	f7 e8 00 09 	and	r9,r11,r8
800069ae:	cf c0       	breq	800069a6 <_malloc_r+0x20a>
800069b0:	e8 03 00 3e 	add	lr,r4,r3<<0x3
800069b4:	06 92       	mov	r2,r3
800069b6:	1c 91       	mov	r1,lr
800069b8:	62 36       	ld.w	r6,r1[0xc]
800069ba:	c2 e8       	rjmp	80006a16 <_malloc_r+0x27a>
800069bc:	6c 1a       	ld.w	r10,r6[0x4]
800069be:	e0 1a ff fc 	andl	r10,0xfffc
800069c2:	f4 07 01 08 	sub	r8,r10,r7
800069c6:	58 f8       	cp.w	r8,15
800069c8:	e0 8a 00 15 	brle	800069f2 <_malloc_r+0x256>
800069cc:	6c 3a       	ld.w	r10,r6[0xc]
800069ce:	6c 29       	ld.w	r9,r6[0x8]
800069d0:	95 29       	st.w	r10[0x8],r9
800069d2:	93 3a       	st.w	r9[0xc],r10
800069d4:	0e 99       	mov	r9,r7
800069d6:	ec 07 00 07 	add	r7,r6,r7
800069da:	a1 a9       	sbr	r9,0x0
800069dc:	99 37       	st.w	r12[0xc],r7
800069de:	99 27       	st.w	r12[0x8],r7
800069e0:	8d 19       	st.w	r6[0x4],r9
800069e2:	ee 08 09 08 	st.w	r7[r8],r8
800069e6:	8f 2c       	st.w	r7[0x8],r12
800069e8:	8f 3c       	st.w	r7[0xc],r12
800069ea:	a1 a8       	sbr	r8,0x0
800069ec:	0a 9c       	mov	r12,r5
800069ee:	8f 18       	st.w	r7[0x4],r8
800069f0:	c0 d8       	rjmp	80006a0a <_malloc_r+0x26e>
800069f2:	6c 39       	ld.w	r9,r6[0xc]
800069f4:	58 08       	cp.w	r8,0
800069f6:	c0 f5       	brlt	80006a14 <_malloc_r+0x278>
800069f8:	ec 0a 00 0a 	add	r10,r6,r10
800069fc:	74 18       	ld.w	r8,r10[0x4]
800069fe:	a1 a8       	sbr	r8,0x0
80006a00:	0a 9c       	mov	r12,r5
80006a02:	95 18       	st.w	r10[0x4],r8
80006a04:	6c 28       	ld.w	r8,r6[0x8]
80006a06:	93 28       	st.w	r9[0x8],r8
80006a08:	91 39       	st.w	r8[0xc],r9
80006a0a:	fe b0 f4 3b 	rcall	80005280 <__malloc_unlock>
80006a0e:	ec cc ff f8 	sub	r12,r6,-8
80006a12:	d8 32       	popm	r0-r7,pc
80006a14:	12 96       	mov	r6,r9
80006a16:	02 36       	cp.w	r6,r1
80006a18:	cd 21       	brne	800069bc <_malloc_r+0x220>
80006a1a:	2f f2       	sub	r2,-1
80006a1c:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
80006a20:	c0 30       	breq	80006a26 <_malloc_r+0x28a>
80006a22:	2f 81       	sub	r1,-8
80006a24:	cc ab       	rjmp	800069b8 <_malloc_r+0x21c>
80006a26:	1c 98       	mov	r8,lr
80006a28:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
80006a2c:	c0 81       	brne	80006a3c <_malloc_r+0x2a0>
80006a2e:	68 19       	ld.w	r9,r4[0x4]
80006a30:	f6 08 11 ff 	rsub	r8,r11,-1
80006a34:	f3 e8 00 08 	and	r8,r9,r8
80006a38:	89 18       	st.w	r4[0x4],r8
80006a3a:	c0 78       	rjmp	80006a48 <_malloc_r+0x2ac>
80006a3c:	f0 c9 00 08 	sub	r9,r8,8
80006a40:	20 13       	sub	r3,1
80006a42:	70 08       	ld.w	r8,r8[0x0]
80006a44:	12 38       	cp.w	r8,r9
80006a46:	cf 10       	breq	80006a28 <_malloc_r+0x28c>
80006a48:	a1 7b       	lsl	r11,0x1
80006a4a:	68 18       	ld.w	r8,r4[0x4]
80006a4c:	10 3b       	cp.w	r11,r8
80006a4e:	e0 8b 00 0d 	brhi	80006a68 <_malloc_r+0x2cc>
80006a52:	58 0b       	cp.w	r11,0
80006a54:	c0 a0       	breq	80006a68 <_malloc_r+0x2cc>
80006a56:	04 93       	mov	r3,r2
80006a58:	c0 38       	rjmp	80006a5e <_malloc_r+0x2c2>
80006a5a:	2f c3       	sub	r3,-4
80006a5c:	a1 7b       	lsl	r11,0x1
80006a5e:	f7 e8 00 09 	and	r9,r11,r8
80006a62:	ca 71       	brne	800069b0 <_malloc_r+0x214>
80006a64:	cf bb       	rjmp	80006a5a <_malloc_r+0x2be>
80006a66:	d7 03       	nop
80006a68:	68 23       	ld.w	r3,r4[0x8]
80006a6a:	66 12       	ld.w	r2,r3[0x4]
80006a6c:	e0 12 ff fc 	andl	r2,0xfffc
80006a70:	0e 32       	cp.w	r2,r7
80006a72:	5f 39       	srlo	r9
80006a74:	e4 07 01 08 	sub	r8,r2,r7
80006a78:	58 f8       	cp.w	r8,15
80006a7a:	5f aa       	srle	r10
80006a7c:	f5 e9 10 09 	or	r9,r10,r9
80006a80:	e0 80 00 9a 	breq	80006bb4 <_malloc_r+0x418>
80006a84:	e0 68 0d 64 	mov	r8,3428
80006a88:	70 01       	ld.w	r1,r8[0x0]
80006a8a:	e0 68 09 3c 	mov	r8,2364
80006a8e:	2f 01       	sub	r1,-16
80006a90:	70 08       	ld.w	r8,r8[0x0]
80006a92:	0e 01       	add	r1,r7
80006a94:	5b f8       	cp.w	r8,-1
80006a96:	c0 40       	breq	80006a9e <_malloc_r+0x302>
80006a98:	28 11       	sub	r1,-127
80006a9a:	e0 11 ff 80 	andl	r1,0xff80
80006a9e:	02 9b       	mov	r11,r1
80006aa0:	0a 9c       	mov	r12,r5
80006aa2:	e0 a0 02 a5 	rcall	80006fec <_sbrk_r>
80006aa6:	18 96       	mov	r6,r12
80006aa8:	5b fc       	cp.w	r12,-1
80006aaa:	c7 50       	breq	80006b94 <_malloc_r+0x3f8>
80006aac:	e6 02 00 08 	add	r8,r3,r2
80006ab0:	10 3c       	cp.w	r12,r8
80006ab2:	c0 32       	brcc	80006ab8 <_malloc_r+0x31c>
80006ab4:	08 33       	cp.w	r3,r4
80006ab6:	c6 f1       	brne	80006b94 <_malloc_r+0x3f8>
80006ab8:	e0 6a 0d 68 	mov	r10,3432
80006abc:	74 09       	ld.w	r9,r10[0x0]
80006abe:	e2 09 00 09 	add	r9,r1,r9
80006ac2:	95 09       	st.w	r10[0x0],r9
80006ac4:	10 36       	cp.w	r6,r8
80006ac6:	c0 a1       	brne	80006ada <_malloc_r+0x33e>
80006ac8:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
80006acc:	c0 71       	brne	80006ada <_malloc_r+0x33e>
80006ace:	e2 02 00 02 	add	r2,r1,r2
80006ad2:	68 28       	ld.w	r8,r4[0x8]
80006ad4:	a1 a2       	sbr	r2,0x0
80006ad6:	91 12       	st.w	r8[0x4],r2
80006ad8:	c4 f8       	rjmp	80006b76 <_malloc_r+0x3da>
80006ada:	e0 6a 09 3c 	mov	r10,2364
80006ade:	74 0b       	ld.w	r11,r10[0x0]
80006ae0:	5b fb       	cp.w	r11,-1
80006ae2:	c0 31       	brne	80006ae8 <_malloc_r+0x34c>
80006ae4:	95 06       	st.w	r10[0x0],r6
80006ae6:	c0 78       	rjmp	80006af4 <_malloc_r+0x358>
80006ae8:	ec 09 00 09 	add	r9,r6,r9
80006aec:	e0 6a 0d 68 	mov	r10,3432
80006af0:	10 19       	sub	r9,r8
80006af2:	95 09       	st.w	r10[0x0],r9
80006af4:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
80006af8:	f0 09 11 08 	rsub	r9,r8,8
80006afc:	58 08       	cp.w	r8,0
80006afe:	f2 08 17 10 	movne	r8,r9
80006b02:	ed d8 e1 06 	addne	r6,r6,r8
80006b06:	28 08       	sub	r8,-128
80006b08:	ec 01 00 01 	add	r1,r6,r1
80006b0c:	0a 9c       	mov	r12,r5
80006b0e:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
80006b12:	f0 01 01 01 	sub	r1,r8,r1
80006b16:	02 9b       	mov	r11,r1
80006b18:	e0 a0 02 6a 	rcall	80006fec <_sbrk_r>
80006b1c:	e0 68 0d 68 	mov	r8,3432
80006b20:	5b fc       	cp.w	r12,-1
80006b22:	ec 0c 17 00 	moveq	r12,r6
80006b26:	f9 b1 00 00 	moveq	r1,0
80006b2a:	70 09       	ld.w	r9,r8[0x0]
80006b2c:	0c 1c       	sub	r12,r6
80006b2e:	89 26       	st.w	r4[0x8],r6
80006b30:	02 0c       	add	r12,r1
80006b32:	12 01       	add	r1,r9
80006b34:	a1 ac       	sbr	r12,0x0
80006b36:	91 01       	st.w	r8[0x0],r1
80006b38:	8d 1c       	st.w	r6[0x4],r12
80006b3a:	08 33       	cp.w	r3,r4
80006b3c:	c1 d0       	breq	80006b76 <_malloc_r+0x3da>
80006b3e:	58 f2       	cp.w	r2,15
80006b40:	e0 8b 00 05 	brhi	80006b4a <_malloc_r+0x3ae>
80006b44:	30 18       	mov	r8,1
80006b46:	8d 18       	st.w	r6[0x4],r8
80006b48:	c2 68       	rjmp	80006b94 <_malloc_r+0x3f8>
80006b4a:	30 59       	mov	r9,5
80006b4c:	20 c2       	sub	r2,12
80006b4e:	e0 12 ff f8 	andl	r2,0xfff8
80006b52:	e6 02 00 08 	add	r8,r3,r2
80006b56:	91 29       	st.w	r8[0x8],r9
80006b58:	91 19       	st.w	r8[0x4],r9
80006b5a:	66 18       	ld.w	r8,r3[0x4]
80006b5c:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006b60:	e5 e8 10 08 	or	r8,r2,r8
80006b64:	87 18       	st.w	r3[0x4],r8
80006b66:	58 f2       	cp.w	r2,15
80006b68:	e0 88 00 07 	brls	80006b76 <_malloc_r+0x3da>
80006b6c:	e6 cb ff f8 	sub	r11,r3,-8
80006b70:	0a 9c       	mov	r12,r5
80006b72:	e0 a0 1c 77 	rcall	8000a460 <_free_r>
80006b76:	e0 69 0d 60 	mov	r9,3424
80006b7a:	72 0a       	ld.w	r10,r9[0x0]
80006b7c:	e0 68 0d 68 	mov	r8,3432
80006b80:	70 08       	ld.w	r8,r8[0x0]
80006b82:	14 38       	cp.w	r8,r10
80006b84:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80006b88:	e0 69 0d 5c 	mov	r9,3420
80006b8c:	72 0a       	ld.w	r10,r9[0x0]
80006b8e:	14 38       	cp.w	r8,r10
80006b90:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80006b94:	68 28       	ld.w	r8,r4[0x8]
80006b96:	70 18       	ld.w	r8,r8[0x4]
80006b98:	e0 18 ff fc 	andl	r8,0xfffc
80006b9c:	0e 38       	cp.w	r8,r7
80006b9e:	5f 39       	srlo	r9
80006ba0:	0e 18       	sub	r8,r7
80006ba2:	58 f8       	cp.w	r8,15
80006ba4:	5f aa       	srle	r10
80006ba6:	f5 e9 10 09 	or	r9,r10,r9
80006baa:	c0 50       	breq	80006bb4 <_malloc_r+0x418>
80006bac:	0a 9c       	mov	r12,r5
80006bae:	fe b0 f3 69 	rcall	80005280 <__malloc_unlock>
80006bb2:	d8 3a       	popm	r0-r7,pc,r12=0
80006bb4:	68 26       	ld.w	r6,r4[0x8]
80006bb6:	a1 a8       	sbr	r8,0x0
80006bb8:	0e 99       	mov	r9,r7
80006bba:	a1 a9       	sbr	r9,0x0
80006bbc:	8d 19       	st.w	r6[0x4],r9
80006bbe:	ec 07 00 07 	add	r7,r6,r7
80006bc2:	0a 9c       	mov	r12,r5
80006bc4:	89 27       	st.w	r4[0x8],r7
80006bc6:	8f 18       	st.w	r7[0x4],r8
80006bc8:	fe b0 f3 5c 	rcall	80005280 <__malloc_unlock>
80006bcc:	ec cc ff f8 	sub	r12,r6,-8
80006bd0:	d8 32       	popm	r0-r7,pc
80006bd2:	d7 03       	nop

80006bd4 <memcpy>:
80006bd4:	58 8a       	cp.w	r10,8
80006bd6:	c2 f5       	brlt	80006c34 <memcpy+0x60>
80006bd8:	f9 eb 10 09 	or	r9,r12,r11
80006bdc:	e2 19 00 03 	andl	r9,0x3,COH
80006be0:	e0 81 00 97 	brne	80006d0e <memcpy+0x13a>
80006be4:	e0 4a 00 20 	cp.w	r10,32
80006be8:	c3 b4       	brge	80006c5e <memcpy+0x8a>
80006bea:	f4 08 14 02 	asr	r8,r10,0x2
80006bee:	f0 09 11 08 	rsub	r9,r8,8
80006bf2:	fe 09 00 2f 	add	pc,pc,r9<<0x2
80006bf6:	76 69       	ld.w	r9,r11[0x18]
80006bf8:	99 69       	st.w	r12[0x18],r9
80006bfa:	76 59       	ld.w	r9,r11[0x14]
80006bfc:	99 59       	st.w	r12[0x14],r9
80006bfe:	76 49       	ld.w	r9,r11[0x10]
80006c00:	99 49       	st.w	r12[0x10],r9
80006c02:	76 39       	ld.w	r9,r11[0xc]
80006c04:	99 39       	st.w	r12[0xc],r9
80006c06:	76 29       	ld.w	r9,r11[0x8]
80006c08:	99 29       	st.w	r12[0x8],r9
80006c0a:	76 19       	ld.w	r9,r11[0x4]
80006c0c:	99 19       	st.w	r12[0x4],r9
80006c0e:	76 09       	ld.w	r9,r11[0x0]
80006c10:	99 09       	st.w	r12[0x0],r9
80006c12:	f6 08 00 2b 	add	r11,r11,r8<<0x2
80006c16:	f8 08 00 28 	add	r8,r12,r8<<0x2
80006c1a:	e0 1a 00 03 	andl	r10,0x3
80006c1e:	f4 0a 11 04 	rsub	r10,r10,4
80006c22:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80006c26:	17 a9       	ld.ub	r9,r11[0x2]
80006c28:	b0 a9       	st.b	r8[0x2],r9
80006c2a:	17 99       	ld.ub	r9,r11[0x1]
80006c2c:	b0 99       	st.b	r8[0x1],r9
80006c2e:	17 89       	ld.ub	r9,r11[0x0]
80006c30:	b0 89       	st.b	r8[0x0],r9
80006c32:	5e fc       	retal	r12
80006c34:	f4 0a 11 09 	rsub	r10,r10,9
80006c38:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80006c3c:	17 f9       	ld.ub	r9,r11[0x7]
80006c3e:	b8 f9       	st.b	r12[0x7],r9
80006c40:	17 e9       	ld.ub	r9,r11[0x6]
80006c42:	b8 e9       	st.b	r12[0x6],r9
80006c44:	17 d9       	ld.ub	r9,r11[0x5]
80006c46:	b8 d9       	st.b	r12[0x5],r9
80006c48:	17 c9       	ld.ub	r9,r11[0x4]
80006c4a:	b8 c9       	st.b	r12[0x4],r9
80006c4c:	17 b9       	ld.ub	r9,r11[0x3]
80006c4e:	b8 b9       	st.b	r12[0x3],r9
80006c50:	17 a9       	ld.ub	r9,r11[0x2]
80006c52:	b8 a9       	st.b	r12[0x2],r9
80006c54:	17 99       	ld.ub	r9,r11[0x1]
80006c56:	b8 99       	st.b	r12[0x1],r9
80006c58:	17 89       	ld.ub	r9,r11[0x0]
80006c5a:	b8 89       	st.b	r12[0x0],r9
80006c5c:	5e fc       	retal	r12
80006c5e:	eb cd 40 c0 	pushm	r6-r7,lr
80006c62:	18 99       	mov	r9,r12
80006c64:	22 0a       	sub	r10,32
80006c66:	b7 07       	ld.d	r6,r11++
80006c68:	b3 26       	st.d	r9++,r6
80006c6a:	b7 07       	ld.d	r6,r11++
80006c6c:	b3 26       	st.d	r9++,r6
80006c6e:	b7 07       	ld.d	r6,r11++
80006c70:	b3 26       	st.d	r9++,r6
80006c72:	b7 07       	ld.d	r6,r11++
80006c74:	b3 26       	st.d	r9++,r6
80006c76:	22 0a       	sub	r10,32
80006c78:	cf 74       	brge	80006c66 <memcpy+0x92>
80006c7a:	2f 0a       	sub	r10,-16
80006c7c:	c0 65       	brlt	80006c88 <memcpy+0xb4>
80006c7e:	b7 07       	ld.d	r6,r11++
80006c80:	b3 26       	st.d	r9++,r6
80006c82:	b7 07       	ld.d	r6,r11++
80006c84:	b3 26       	st.d	r9++,r6
80006c86:	21 0a       	sub	r10,16
80006c88:	5c 3a       	neg	r10
80006c8a:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
80006c8e:	d7 03       	nop
80006c90:	d7 03       	nop
80006c92:	f7 36 00 0e 	ld.ub	r6,r11[14]
80006c96:	f3 66 00 0e 	st.b	r9[14],r6
80006c9a:	f7 36 00 0d 	ld.ub	r6,r11[13]
80006c9e:	f3 66 00 0d 	st.b	r9[13],r6
80006ca2:	f7 36 00 0c 	ld.ub	r6,r11[12]
80006ca6:	f3 66 00 0c 	st.b	r9[12],r6
80006caa:	f7 36 00 0b 	ld.ub	r6,r11[11]
80006cae:	f3 66 00 0b 	st.b	r9[11],r6
80006cb2:	f7 36 00 0a 	ld.ub	r6,r11[10]
80006cb6:	f3 66 00 0a 	st.b	r9[10],r6
80006cba:	f7 36 00 09 	ld.ub	r6,r11[9]
80006cbe:	f3 66 00 09 	st.b	r9[9],r6
80006cc2:	f7 36 00 08 	ld.ub	r6,r11[8]
80006cc6:	f3 66 00 08 	st.b	r9[8],r6
80006cca:	f7 36 00 07 	ld.ub	r6,r11[7]
80006cce:	f3 66 00 07 	st.b	r9[7],r6
80006cd2:	f7 36 00 06 	ld.ub	r6,r11[6]
80006cd6:	f3 66 00 06 	st.b	r9[6],r6
80006cda:	f7 36 00 05 	ld.ub	r6,r11[5]
80006cde:	f3 66 00 05 	st.b	r9[5],r6
80006ce2:	f7 36 00 04 	ld.ub	r6,r11[4]
80006ce6:	f3 66 00 04 	st.b	r9[4],r6
80006cea:	f7 36 00 03 	ld.ub	r6,r11[3]
80006cee:	f3 66 00 03 	st.b	r9[3],r6
80006cf2:	f7 36 00 02 	ld.ub	r6,r11[2]
80006cf6:	f3 66 00 02 	st.b	r9[2],r6
80006cfa:	f7 36 00 01 	ld.ub	r6,r11[1]
80006cfe:	f3 66 00 01 	st.b	r9[1],r6
80006d02:	f7 36 00 00 	ld.ub	r6,r11[0]
80006d06:	f3 66 00 00 	st.b	r9[0],r6
80006d0a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006d0e:	20 1a       	sub	r10,1
80006d10:	f6 0a 07 09 	ld.ub	r9,r11[r10]
80006d14:	f8 0a 0b 09 	st.b	r12[r10],r9
80006d18:	cf b1       	brne	80006d0e <memcpy+0x13a>
80006d1a:	5e fc       	retal	r12

80006d1c <memset>:
80006d1c:	18 98       	mov	r8,r12
80006d1e:	c0 38       	rjmp	80006d24 <memset+0x8>
80006d20:	10 cb       	st.b	r8++,r11
80006d22:	20 1a       	sub	r10,1
80006d24:	58 0a       	cp.w	r10,0
80006d26:	cf d1       	brne	80006d20 <memset+0x4>
80006d28:	5e fc       	retal	r12
80006d2a:	d7 03       	nop

80006d2c <_realloc_r>:
80006d2c:	d4 31       	pushm	r0-r7,lr
80006d2e:	20 1d       	sub	sp,4
80006d30:	16 94       	mov	r4,r11
80006d32:	18 92       	mov	r2,r12
80006d34:	14 9b       	mov	r11,r10
80006d36:	58 04       	cp.w	r4,0
80006d38:	c0 51       	brne	80006d42 <_realloc_r+0x16>
80006d3a:	fe b0 fd 31 	rcall	8000679c <_malloc_r>
80006d3e:	18 95       	mov	r5,r12
80006d40:	c5 39       	rjmp	80006fe6 <_realloc_r+0x2ba>
80006d42:	50 0a       	stdsp	sp[0x0],r10
80006d44:	fe b0 f2 98 	rcall	80005274 <__malloc_lock>
80006d48:	40 0b       	lddsp	r11,sp[0x0]
80006d4a:	f6 c8 ff f5 	sub	r8,r11,-11
80006d4e:	e8 c1 00 08 	sub	r1,r4,8
80006d52:	10 96       	mov	r6,r8
80006d54:	62 1c       	ld.w	r12,r1[0x4]
80006d56:	e0 16 ff f8 	andl	r6,0xfff8
80006d5a:	59 68       	cp.w	r8,22
80006d5c:	f9 b6 08 10 	movls	r6,16
80006d60:	16 36       	cp.w	r6,r11
80006d62:	5f 38       	srlo	r8
80006d64:	f1 e6 13 f8 	or	r8,r8,r6>>0x1f
80006d68:	c0 50       	breq	80006d72 <_realloc_r+0x46>
80006d6a:	30 c8       	mov	r8,12
80006d6c:	30 05       	mov	r5,0
80006d6e:	85 38       	st.w	r2[0xc],r8
80006d70:	c3 b9       	rjmp	80006fe6 <_realloc_r+0x2ba>
80006d72:	18 90       	mov	r0,r12
80006d74:	e0 10 ff fc 	andl	r0,0xfffc
80006d78:	0c 30       	cp.w	r0,r6
80006d7a:	e0 84 01 0b 	brge	80006f90 <_realloc_r+0x264>
80006d7e:	e0 68 05 30 	mov	r8,1328
80006d82:	e2 00 00 09 	add	r9,r1,r0
80006d86:	70 25       	ld.w	r5,r8[0x8]
80006d88:	0a 39       	cp.w	r9,r5
80006d8a:	c0 90       	breq	80006d9c <_realloc_r+0x70>
80006d8c:	72 1a       	ld.w	r10,r9[0x4]
80006d8e:	a1 ca       	cbr	r10,0x0
80006d90:	f2 0a 00 0a 	add	r10,r9,r10
80006d94:	74 1a       	ld.w	r10,r10[0x4]
80006d96:	ed ba 00 00 	bld	r10,0x0
80006d9a:	c2 20       	breq	80006dde <_realloc_r+0xb2>
80006d9c:	72 1a       	ld.w	r10,r9[0x4]
80006d9e:	e0 1a ff fc 	andl	r10,0xfffc
80006da2:	f4 00 00 03 	add	r3,r10,r0
80006da6:	0a 39       	cp.w	r9,r5
80006da8:	c1 31       	brne	80006dce <_realloc_r+0xa2>
80006daa:	ec c7 ff f0 	sub	r7,r6,-16
80006dae:	0e 33       	cp.w	r3,r7
80006db0:	c1 95       	brlt	80006de2 <_realloc_r+0xb6>
80006db2:	e2 06 00 09 	add	r9,r1,r6
80006db6:	0c 13       	sub	r3,r6
80006db8:	a1 a3       	sbr	r3,0x0
80006dba:	93 13       	st.w	r9[0x4],r3
80006dbc:	91 29       	st.w	r8[0x8],r9
80006dbe:	04 9c       	mov	r12,r2
80006dc0:	62 18       	ld.w	r8,r1[0x4]
80006dc2:	08 95       	mov	r5,r4
80006dc4:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006dc8:	10 46       	or	r6,r8
80006dca:	83 16       	st.w	r1[0x4],r6
80006dcc:	c0 b9       	rjmp	80006fe2 <_realloc_r+0x2b6>
80006dce:	0c 33       	cp.w	r3,r6
80006dd0:	c0 95       	brlt	80006de2 <_realloc_r+0xb6>
80006dd2:	72 28       	ld.w	r8,r9[0x8]
80006dd4:	02 97       	mov	r7,r1
80006dd6:	72 39       	ld.w	r9,r9[0xc]
80006dd8:	93 28       	st.w	r9[0x8],r8
80006dda:	91 39       	st.w	r8[0xc],r9
80006ddc:	cd c8       	rjmp	80006f94 <_realloc_r+0x268>
80006dde:	30 0a       	mov	r10,0
80006de0:	14 99       	mov	r9,r10
80006de2:	ed bc 00 00 	bld	r12,0x0
80006de6:	e0 80 00 95 	breq	80006f10 <_realloc_r+0x1e4>
80006dea:	62 07       	ld.w	r7,r1[0x0]
80006dec:	e2 07 01 07 	sub	r7,r1,r7
80006df0:	6e 1c       	ld.w	r12,r7[0x4]
80006df2:	e0 1c ff fc 	andl	r12,0xfffc
80006df6:	58 09       	cp.w	r9,0
80006df8:	c5 60       	breq	80006ea4 <_realloc_r+0x178>
80006dfa:	f8 00 00 03 	add	r3,r12,r0
80006dfe:	0a 39       	cp.w	r9,r5
80006e00:	c4 81       	brne	80006e90 <_realloc_r+0x164>
80006e02:	14 03       	add	r3,r10
80006e04:	ec c9 ff f0 	sub	r9,r6,-16
80006e08:	12 33       	cp.w	r3,r9
80006e0a:	c4 d5       	brlt	80006ea4 <_realloc_r+0x178>
80006e0c:	6e 3a       	ld.w	r10,r7[0xc]
80006e0e:	6e 29       	ld.w	r9,r7[0x8]
80006e10:	95 29       	st.w	r10[0x8],r9
80006e12:	93 3a       	st.w	r9[0xc],r10
80006e14:	ee c5 ff f8 	sub	r5,r7,-8
80006e18:	e0 ca 00 04 	sub	r10,r0,4
80006e1c:	e0 4a 00 24 	cp.w	r10,36
80006e20:	e0 8b 00 25 	brhi	80006e6a <_realloc_r+0x13e>
80006e24:	0a 99       	mov	r9,r5
80006e26:	59 3a       	cp.w	r10,19
80006e28:	e0 88 00 1a 	brls	80006e5c <_realloc_r+0x130>
80006e2c:	09 09       	ld.w	r9,r4++
80006e2e:	8b 09       	st.w	r5[0x0],r9
80006e30:	09 09       	ld.w	r9,r4++
80006e32:	8f 39       	st.w	r7[0xc],r9
80006e34:	ee c9 ff f0 	sub	r9,r7,-16
80006e38:	59 ba       	cp.w	r10,27
80006e3a:	e0 88 00 11 	brls	80006e5c <_realloc_r+0x130>
80006e3e:	09 0b       	ld.w	r11,r4++
80006e40:	93 0b       	st.w	r9[0x0],r11
80006e42:	09 09       	ld.w	r9,r4++
80006e44:	8f 59       	st.w	r7[0x14],r9
80006e46:	ee c9 ff e8 	sub	r9,r7,-24
80006e4a:	e0 4a 00 24 	cp.w	r10,36
80006e4e:	c0 71       	brne	80006e5c <_realloc_r+0x130>
80006e50:	09 0a       	ld.w	r10,r4++
80006e52:	93 0a       	st.w	r9[0x0],r10
80006e54:	ee c9 ff e0 	sub	r9,r7,-32
80006e58:	09 0a       	ld.w	r10,r4++
80006e5a:	8f 7a       	st.w	r7[0x1c],r10
80006e5c:	09 0a       	ld.w	r10,r4++
80006e5e:	12 aa       	st.w	r9++,r10
80006e60:	68 0a       	ld.w	r10,r4[0x0]
80006e62:	93 0a       	st.w	r9[0x0],r10
80006e64:	68 1a       	ld.w	r10,r4[0x4]
80006e66:	93 1a       	st.w	r9[0x4],r10
80006e68:	c0 78       	rjmp	80006e76 <_realloc_r+0x14a>
80006e6a:	50 08       	stdsp	sp[0x0],r8
80006e6c:	08 9b       	mov	r11,r4
80006e6e:	0a 9c       	mov	r12,r5
80006e70:	e0 a0 1d 9b 	rcall	8000a9a6 <memmove>
80006e74:	40 08       	lddsp	r8,sp[0x0]
80006e76:	ee 06 00 09 	add	r9,r7,r6
80006e7a:	0c 13       	sub	r3,r6
80006e7c:	a1 a3       	sbr	r3,0x0
80006e7e:	93 13       	st.w	r9[0x4],r3
80006e80:	91 29       	st.w	r8[0x8],r9
80006e82:	04 9c       	mov	r12,r2
80006e84:	6e 18       	ld.w	r8,r7[0x4]
80006e86:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006e8a:	10 46       	or	r6,r8
80006e8c:	8f 16       	st.w	r7[0x4],r6
80006e8e:	ca a8       	rjmp	80006fe2 <_realloc_r+0x2b6>
80006e90:	14 03       	add	r3,r10
80006e92:	0c 33       	cp.w	r3,r6
80006e94:	c0 85       	brlt	80006ea4 <_realloc_r+0x178>
80006e96:	72 28       	ld.w	r8,r9[0x8]
80006e98:	72 39       	ld.w	r9,r9[0xc]
80006e9a:	93 28       	st.w	r9[0x8],r8
80006e9c:	91 39       	st.w	r8[0xc],r9
80006e9e:	6e 28       	ld.w	r8,r7[0x8]
80006ea0:	6e 39       	ld.w	r9,r7[0xc]
80006ea2:	c0 78       	rjmp	80006eb0 <_realloc_r+0x184>
80006ea4:	f8 00 00 03 	add	r3,r12,r0
80006ea8:	0c 33       	cp.w	r3,r6
80006eaa:	c3 35       	brlt	80006f10 <_realloc_r+0x1e4>
80006eac:	6e 39       	ld.w	r9,r7[0xc]
80006eae:	6e 28       	ld.w	r8,r7[0x8]
80006eb0:	93 28       	st.w	r9[0x8],r8
80006eb2:	91 39       	st.w	r8[0xc],r9
80006eb4:	e0 ca 00 04 	sub	r10,r0,4
80006eb8:	ee cc ff f8 	sub	r12,r7,-8
80006ebc:	e0 4a 00 24 	cp.w	r10,36
80006ec0:	e0 8b 00 24 	brhi	80006f08 <_realloc_r+0x1dc>
80006ec4:	59 3a       	cp.w	r10,19
80006ec6:	e0 88 00 1a 	brls	80006efa <_realloc_r+0x1ce>
80006eca:	09 08       	ld.w	r8,r4++
80006ecc:	99 08       	st.w	r12[0x0],r8
80006ece:	09 08       	ld.w	r8,r4++
80006ed0:	8f 38       	st.w	r7[0xc],r8
80006ed2:	ee cc ff f0 	sub	r12,r7,-16
80006ed6:	59 ba       	cp.w	r10,27
80006ed8:	e0 88 00 11 	brls	80006efa <_realloc_r+0x1ce>
80006edc:	09 08       	ld.w	r8,r4++
80006ede:	99 08       	st.w	r12[0x0],r8
80006ee0:	09 08       	ld.w	r8,r4++
80006ee2:	8f 58       	st.w	r7[0x14],r8
80006ee4:	ee cc ff e8 	sub	r12,r7,-24
80006ee8:	e0 4a 00 24 	cp.w	r10,36
80006eec:	c0 71       	brne	80006efa <_realloc_r+0x1ce>
80006eee:	09 08       	ld.w	r8,r4++
80006ef0:	99 08       	st.w	r12[0x0],r8
80006ef2:	ee cc ff e0 	sub	r12,r7,-32
80006ef6:	09 08       	ld.w	r8,r4++
80006ef8:	8f 78       	st.w	r7[0x1c],r8
80006efa:	09 08       	ld.w	r8,r4++
80006efc:	18 a8       	st.w	r12++,r8
80006efe:	68 08       	ld.w	r8,r4[0x0]
80006f00:	99 08       	st.w	r12[0x0],r8
80006f02:	68 18       	ld.w	r8,r4[0x4]
80006f04:	99 18       	st.w	r12[0x4],r8
80006f06:	c4 78       	rjmp	80006f94 <_realloc_r+0x268>
80006f08:	08 9b       	mov	r11,r4
80006f0a:	e0 a0 1d 4e 	rcall	8000a9a6 <memmove>
80006f0e:	c4 38       	rjmp	80006f94 <_realloc_r+0x268>
80006f10:	04 9c       	mov	r12,r2
80006f12:	fe b0 fc 45 	rcall	8000679c <_malloc_r>
80006f16:	18 95       	mov	r5,r12
80006f18:	c3 a0       	breq	80006f8c <_realloc_r+0x260>
80006f1a:	62 18       	ld.w	r8,r1[0x4]
80006f1c:	f8 c9 00 08 	sub	r9,r12,8
80006f20:	a1 c8       	cbr	r8,0x0
80006f22:	e2 08 00 08 	add	r8,r1,r8
80006f26:	10 39       	cp.w	r9,r8
80006f28:	c0 71       	brne	80006f36 <_realloc_r+0x20a>
80006f2a:	72 13       	ld.w	r3,r9[0x4]
80006f2c:	02 97       	mov	r7,r1
80006f2e:	e0 13 ff fc 	andl	r3,0xfffc
80006f32:	00 03       	add	r3,r0
80006f34:	c3 08       	rjmp	80006f94 <_realloc_r+0x268>
80006f36:	e0 ca 00 04 	sub	r10,r0,4
80006f3a:	e0 4a 00 24 	cp.w	r10,36
80006f3e:	e0 8b 00 20 	brhi	80006f7e <_realloc_r+0x252>
80006f42:	08 99       	mov	r9,r4
80006f44:	18 98       	mov	r8,r12
80006f46:	59 3a       	cp.w	r10,19
80006f48:	e0 88 00 14 	brls	80006f70 <_realloc_r+0x244>
80006f4c:	13 0b       	ld.w	r11,r9++
80006f4e:	10 ab       	st.w	r8++,r11
80006f50:	13 0b       	ld.w	r11,r9++
80006f52:	10 ab       	st.w	r8++,r11
80006f54:	59 ba       	cp.w	r10,27
80006f56:	e0 88 00 0d 	brls	80006f70 <_realloc_r+0x244>
80006f5a:	13 0b       	ld.w	r11,r9++
80006f5c:	10 ab       	st.w	r8++,r11
80006f5e:	13 0b       	ld.w	r11,r9++
80006f60:	10 ab       	st.w	r8++,r11
80006f62:	e0 4a 00 24 	cp.w	r10,36
80006f66:	c0 51       	brne	80006f70 <_realloc_r+0x244>
80006f68:	13 0a       	ld.w	r10,r9++
80006f6a:	10 aa       	st.w	r8++,r10
80006f6c:	13 0a       	ld.w	r10,r9++
80006f6e:	10 aa       	st.w	r8++,r10
80006f70:	13 0a       	ld.w	r10,r9++
80006f72:	10 aa       	st.w	r8++,r10
80006f74:	72 0a       	ld.w	r10,r9[0x0]
80006f76:	91 0a       	st.w	r8[0x0],r10
80006f78:	72 19       	ld.w	r9,r9[0x4]
80006f7a:	91 19       	st.w	r8[0x4],r9
80006f7c:	c0 48       	rjmp	80006f84 <_realloc_r+0x258>
80006f7e:	08 9b       	mov	r11,r4
80006f80:	e0 a0 1d 13 	rcall	8000a9a6 <memmove>
80006f84:	08 9b       	mov	r11,r4
80006f86:	04 9c       	mov	r12,r2
80006f88:	e0 a0 1a 6c 	rcall	8000a460 <_free_r>
80006f8c:	04 9c       	mov	r12,r2
80006f8e:	c2 a8       	rjmp	80006fe2 <_realloc_r+0x2b6>
80006f90:	00 93       	mov	r3,r0
80006f92:	02 97       	mov	r7,r1
80006f94:	e6 06 01 09 	sub	r9,r3,r6
80006f98:	6e 18       	ld.w	r8,r7[0x4]
80006f9a:	58 f9       	cp.w	r9,15
80006f9c:	e0 88 00 16 	brls	80006fc8 <_realloc_r+0x29c>
80006fa0:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006fa4:	ed e8 10 08 	or	r8,r6,r8
80006fa8:	8f 18       	st.w	r7[0x4],r8
80006faa:	12 98       	mov	r8,r9
80006fac:	a1 a8       	sbr	r8,0x0
80006fae:	ee 06 00 0b 	add	r11,r7,r6
80006fb2:	f6 09 00 09 	add	r9,r11,r9
80006fb6:	97 18       	st.w	r11[0x4],r8
80006fb8:	72 18       	ld.w	r8,r9[0x4]
80006fba:	a1 a8       	sbr	r8,0x0
80006fbc:	2f 8b       	sub	r11,-8
80006fbe:	93 18       	st.w	r9[0x4],r8
80006fc0:	04 9c       	mov	r12,r2
80006fc2:	e0 a0 1a 4f 	rcall	8000a460 <_free_r>
80006fc6:	c0 b8       	rjmp	80006fdc <_realloc_r+0x2b0>
80006fc8:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006fcc:	e7 e8 10 08 	or	r8,r3,r8
80006fd0:	8f 18       	st.w	r7[0x4],r8
80006fd2:	ee 03 00 03 	add	r3,r7,r3
80006fd6:	66 18       	ld.w	r8,r3[0x4]
80006fd8:	a1 a8       	sbr	r8,0x0
80006fda:	87 18       	st.w	r3[0x4],r8
80006fdc:	04 9c       	mov	r12,r2
80006fde:	ee c5 ff f8 	sub	r5,r7,-8
80006fe2:	fe b0 f1 4f 	rcall	80005280 <__malloc_unlock>
80006fe6:	0a 9c       	mov	r12,r5
80006fe8:	2f fd       	sub	sp,-4
80006fea:	d8 32       	popm	r0-r7,pc

80006fec <_sbrk_r>:
80006fec:	d4 21       	pushm	r4-r7,lr
80006fee:	30 08       	mov	r8,0
80006ff0:	18 97       	mov	r7,r12
80006ff2:	e0 66 41 14 	mov	r6,16660
80006ff6:	16 9c       	mov	r12,r11
80006ff8:	8d 08       	st.w	r6[0x0],r8
80006ffa:	c9 1c       	rcall	8000711c <_sbrk>
80006ffc:	5b fc       	cp.w	r12,-1
80006ffe:	c0 51       	brne	80007008 <_sbrk_r+0x1c>
80007000:	6c 08       	ld.w	r8,r6[0x0]
80007002:	58 08       	cp.w	r8,0
80007004:	ef f8 1a 03 	st.wne	r7[0xc],r8
80007008:	d8 22       	popm	r4-r7,pc
8000700a:	d7 03       	nop

8000700c <sprintf>:
8000700c:	d4 01       	pushm	lr
8000700e:	21 7d       	sub	sp,92
80007010:	e0 68 ff ff 	mov	r8,65535
80007014:	ea 18 7f ff 	orh	r8,0x7fff
80007018:	50 58       	stdsp	sp[0x14],r8
8000701a:	50 28       	stdsp	sp[0x8],r8
8000701c:	e0 68 02 08 	mov	r8,520
80007020:	ba 68       	st.h	sp[0xc],r8
80007022:	3f f8       	mov	r8,-1
80007024:	ba 78       	st.h	sp[0xe],r8
80007026:	e0 68 0a 30 	mov	r8,2608
8000702a:	50 4c       	stdsp	sp[0x10],r12
8000702c:	16 9a       	mov	r10,r11
8000702e:	50 0c       	stdsp	sp[0x0],r12
80007030:	fa c9 ff a0 	sub	r9,sp,-96
80007034:	70 0c       	ld.w	r12,r8[0x0]
80007036:	1a 9b       	mov	r11,sp
80007038:	e0 a0 02 26 	rcall	80007484 <_vfprintf_r>
8000703c:	30 09       	mov	r9,0
8000703e:	40 08       	lddsp	r8,sp[0x0]
80007040:	b0 89       	st.b	r8[0x0],r9
80007042:	2e 9d       	sub	sp,-92
80007044:	d8 02       	popm	pc
80007046:	d7 03       	nop

80007048 <strlen>:
80007048:	30 09       	mov	r9,0
8000704a:	18 98       	mov	r8,r12
8000704c:	c0 28       	rjmp	80007050 <strlen+0x8>
8000704e:	2f f8       	sub	r8,-1
80007050:	11 8a       	ld.ub	r10,r8[0x0]
80007052:	f2 0a 18 00 	cp.b	r10,r9
80007056:	cf c1       	brne	8000704e <strlen+0x6>
80007058:	f0 0c 01 0c 	sub	r12,r8,r12
8000705c:	5e fc       	retal	r12
8000705e:	d7 03       	nop

80007060 <strncpy>:
80007060:	30 08       	mov	r8,0
80007062:	10 3a       	cp.w	r10,r8
80007064:	5e 0c       	reteq	r12
80007066:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000706a:	f8 08 0b 09 	st.b	r12[r8],r9
8000706e:	2f f8       	sub	r8,-1
80007070:	58 09       	cp.w	r9,0
80007072:	cf 81       	brne	80007062 <strncpy+0x2>
80007074:	10 3a       	cp.w	r10,r8
80007076:	5e 0c       	reteq	r12
80007078:	f8 08 0b 09 	st.b	r12[r8],r9
8000707c:	2f f8       	sub	r8,-1
8000707e:	cf bb       	rjmp	80007074 <strncpy+0x14>

80007080 <_close>:
80007080:	30 28       	mov	r8,2
80007082:	d6 73       	breakpoint
80007084:	3f fc       	mov	r12,-1
80007086:	35 8b       	mov	r11,88
80007088:	58 0c       	cp.w	r12,0
8000708a:	5e 4c       	retge	r12
8000708c:	e0 6a 41 14 	mov	r10,16660
80007090:	95 0b       	st.w	r10[0x0],r11
80007092:	5e fc       	retal	r12

80007094 <_lseek>:
80007094:	30 58       	mov	r8,5
80007096:	d6 73       	breakpoint
80007098:	3f fc       	mov	r12,-1
8000709a:	35 8b       	mov	r11,88
8000709c:	58 0c       	cp.w	r12,0
8000709e:	5e 4c       	retge	r12
800070a0:	e0 6a 41 14 	mov	r10,16660
800070a4:	95 0b       	st.w	r10[0x0],r11
800070a6:	5e fc       	retal	r12

800070a8 <isatty>:
800070a8:	30 b8       	mov	r8,11
800070aa:	d6 73       	breakpoint
800070ac:	3f fc       	mov	r12,-1
800070ae:	35 8b       	mov	r11,88
800070b0:	58 0c       	cp.w	r12,0
800070b2:	5e 4c       	retge	r12
800070b4:	e0 6a 41 14 	mov	r10,16660
800070b8:	95 0b       	st.w	r10[0x0],r11
800070ba:	5e fc       	retal	r12

800070bc <_fstat_host>:
800070bc:	30 98       	mov	r8,9
800070be:	d6 73       	breakpoint
800070c0:	3f fc       	mov	r12,-1
800070c2:	35 8b       	mov	r11,88
800070c4:	58 0c       	cp.w	r12,0
800070c6:	5e 4c       	retge	r12
800070c8:	e0 6a 41 14 	mov	r10,16660
800070cc:	95 0b       	st.w	r10[0x0],r11
800070ce:	5e fc       	retal	r12

800070d0 <_fstat>:
800070d0:	d4 21       	pushm	r4-r7,lr
800070d2:	21 0d       	sub	sp,64
800070d4:	16 97       	mov	r7,r11
800070d6:	1a 9b       	mov	r11,sp
800070d8:	cf 2f       	rcall	800070bc <_fstat_host>
800070da:	c0 34       	brge	800070e0 <_fstat+0x10>
800070dc:	3f fc       	mov	r12,-1
800070de:	c1 c8       	rjmp	80007116 <_fstat+0x46>
800070e0:	40 08       	lddsp	r8,sp[0x0]
800070e2:	ae 08       	st.h	r7[0x0],r8
800070e4:	40 18       	lddsp	r8,sp[0x4]
800070e6:	ae 18       	st.h	r7[0x2],r8
800070e8:	40 28       	lddsp	r8,sp[0x8]
800070ea:	8f 18       	st.w	r7[0x4],r8
800070ec:	40 38       	lddsp	r8,sp[0xc]
800070ee:	ae 48       	st.h	r7[0x8],r8
800070f0:	40 48       	lddsp	r8,sp[0x10]
800070f2:	ae 58       	st.h	r7[0xa],r8
800070f4:	40 58       	lddsp	r8,sp[0x14]
800070f6:	ae 68       	st.h	r7[0xc],r8
800070f8:	40 68       	lddsp	r8,sp[0x18]
800070fa:	ae 78       	st.h	r7[0xe],r8
800070fc:	40 88       	lddsp	r8,sp[0x20]
800070fe:	8f 48       	st.w	r7[0x10],r8
80007100:	40 a8       	lddsp	r8,sp[0x28]
80007102:	8f b8       	st.w	r7[0x2c],r8
80007104:	40 c8       	lddsp	r8,sp[0x30]
80007106:	8f c8       	st.w	r7[0x30],r8
80007108:	40 d8       	lddsp	r8,sp[0x34]
8000710a:	8f 58       	st.w	r7[0x14],r8
8000710c:	40 e8       	lddsp	r8,sp[0x38]
8000710e:	30 0c       	mov	r12,0
80007110:	8f 78       	st.w	r7[0x1c],r8
80007112:	40 f8       	lddsp	r8,sp[0x3c]
80007114:	8f 98       	st.w	r7[0x24],r8
80007116:	2f 0d       	sub	sp,-64
80007118:	d8 22       	popm	r4-r7,pc
8000711a:	d7 03       	nop

8000711c <_sbrk>:
8000711c:	d4 01       	pushm	lr
8000711e:	e0 68 0d 90 	mov	r8,3472
80007122:	70 09       	ld.w	r9,r8[0x0]
80007124:	58 09       	cp.w	r9,0
80007126:	c0 41       	brne	8000712e <_sbrk+0x12>
80007128:	e0 69 41 18 	mov	r9,16664
8000712c:	91 09       	st.w	r8[0x0],r9
8000712e:	e0 69 0d 90 	mov	r9,3472
80007132:	e0 7a 70 00 	mov	r10,94208
80007136:	72 08       	ld.w	r8,r9[0x0]
80007138:	f0 0c 00 0c 	add	r12,r8,r12
8000713c:	14 3c       	cp.w	r12,r10
8000713e:	e0 8b 00 04 	brhi	80007146 <_sbrk+0x2a>
80007142:	93 0c       	st.w	r9[0x0],r12
80007144:	c0 68       	rjmp	80007150 <_sbrk+0x34>
80007146:	e0 a0 18 15 	rcall	8000a170 <__errno>
8000714a:	30 c8       	mov	r8,12
8000714c:	99 08       	st.w	r12[0x0],r8
8000714e:	3f f8       	mov	r8,-1
80007150:	10 9c       	mov	r12,r8
80007152:	d8 02       	popm	pc

80007154 <get_arg>:
80007154:	d4 31       	pushm	r0-r7,lr
80007156:	20 8d       	sub	sp,32
80007158:	fa c4 ff bc 	sub	r4,sp,-68
8000715c:	50 4b       	stdsp	sp[0x10],r11
8000715e:	68 2e       	ld.w	lr,r4[0x8]
80007160:	50 58       	stdsp	sp[0x14],r8
80007162:	12 96       	mov	r6,r9
80007164:	7c 0b       	ld.w	r11,lr[0x0]
80007166:	70 05       	ld.w	r5,r8[0x0]
80007168:	50 6e       	stdsp	sp[0x18],lr
8000716a:	58 0b       	cp.w	r11,0
8000716c:	f4 0b 17 00 	moveq	r11,r10
80007170:	68 03       	ld.w	r3,r4[0x0]
80007172:	68 11       	ld.w	r1,r4[0x4]
80007174:	40 49       	lddsp	r9,sp[0x10]
80007176:	30 08       	mov	r8,0
80007178:	c2 89       	rjmp	800073c8 <get_arg+0x274>
8000717a:	2f fb       	sub	r11,-1
8000717c:	32 5c       	mov	r12,37
8000717e:	17 8a       	ld.ub	r10,r11[0x0]
80007180:	f8 0a 18 00 	cp.b	r10,r12
80007184:	5f 1e       	srne	lr
80007186:	f0 0a 18 00 	cp.b	r10,r8
8000718a:	5f 1c       	srne	r12
8000718c:	fd ec 00 0c 	and	r12,lr,r12
80007190:	f0 0c 18 00 	cp.b	r12,r8
80007194:	cf 31       	brne	8000717a <get_arg+0x26>
80007196:	58 0a       	cp.w	r10,0
80007198:	e0 80 01 25 	breq	800073e2 <get_arg+0x28e>
8000719c:	30 0c       	mov	r12,0
8000719e:	3f fa       	mov	r10,-1
800071a0:	18 90       	mov	r0,r12
800071a2:	50 3a       	stdsp	sp[0xc],r10
800071a4:	18 94       	mov	r4,r12
800071a6:	18 92       	mov	r2,r12
800071a8:	f8 0c 00 3c 	add	r12,r12,r12<<0x3
800071ac:	16 97       	mov	r7,r11
800071ae:	50 7c       	stdsp	sp[0x1c],r12
800071b0:	fe cc 9f 28 	sub	r12,pc,-24792
800071b4:	0f 3a       	ld.ub	r10,r7++
800071b6:	f8 0a 07 0e 	ld.ub	lr,r12[r10]
800071ba:	40 7c       	lddsp	r12,sp[0x1c]
800071bc:	1c 0c       	add	r12,lr
800071be:	fe ce 9f fe 	sub	lr,pc,-24578
800071c2:	fc 0c 07 0e 	ld.ub	lr,lr[r12]
800071c6:	20 1e       	sub	lr,1
800071c8:	50 0e       	stdsp	sp[0x0],lr
800071ca:	fe ce a0 76 	sub	lr,pc,-24458
800071ce:	fc 0c 07 0c 	ld.ub	r12,lr[r12]
800071d2:	50 7c       	stdsp	sp[0x1c],r12
800071d4:	40 0c       	lddsp	r12,sp[0x0]
800071d6:	58 7c       	cp.w	r12,7
800071d8:	e0 8b 00 f1 	brhi	800073ba <get_arg+0x266>
800071dc:	fe ce a2 28 	sub	lr,pc,-24024
800071e0:	fc 0c 03 2f 	ld.w	pc,lr[r12<<0x2]
800071e4:	36 8b       	mov	r11,104
800071e6:	f6 0a 18 00 	cp.b	r10,r11
800071ea:	e0 80 00 e8 	breq	800073ba <get_arg+0x266>
800071ee:	37 1b       	mov	r11,113
800071f0:	f6 0a 18 00 	cp.b	r10,r11
800071f4:	c0 70       	breq	80007202 <get_arg+0xae>
800071f6:	34 cb       	mov	r11,76
800071f8:	f6 0a 18 00 	cp.b	r10,r11
800071fc:	c0 51       	brne	80007206 <get_arg+0xb2>
800071fe:	a3 b4       	sbr	r4,0x3
80007200:	cd d8       	rjmp	800073ba <get_arg+0x266>
80007202:	a5 b4       	sbr	r4,0x5
80007204:	cd b8       	rjmp	800073ba <get_arg+0x266>
80007206:	08 9a       	mov	r10,r4
80007208:	0e 9b       	mov	r11,r7
8000720a:	a5 aa       	sbr	r10,0x4
8000720c:	17 3c       	ld.ub	r12,r11++
8000720e:	a5 b4       	sbr	r4,0x5
80007210:	36 ce       	mov	lr,108
80007212:	fc 0c 18 00 	cp.b	r12,lr
80007216:	e0 80 00 d3 	breq	800073bc <get_arg+0x268>
8000721a:	14 94       	mov	r4,r10
8000721c:	cc f8       	rjmp	800073ba <get_arg+0x266>
8000721e:	eb d5 c0 05 	bfextu	r5,r5,0x0,0x5
80007222:	36 7c       	mov	r12,103
80007224:	f8 0a 18 00 	cp.b	r10,r12
80007228:	e0 8b 00 27 	brhi	80007276 <get_arg+0x122>
8000722c:	36 5b       	mov	r11,101
8000722e:	f6 0a 18 00 	cp.b	r10,r11
80007232:	c4 82       	brcc	800072c2 <get_arg+0x16e>
80007234:	34 fb       	mov	r11,79
80007236:	f6 0a 18 00 	cp.b	r10,r11
8000723a:	c4 80       	breq	800072ca <get_arg+0x176>
8000723c:	e0 8b 00 0c 	brhi	80007254 <get_arg+0x100>
80007240:	34 5b       	mov	r11,69
80007242:	f6 0a 18 00 	cp.b	r10,r11
80007246:	c3 e0       	breq	800072c2 <get_arg+0x16e>
80007248:	34 7b       	mov	r11,71
8000724a:	f6 0a 18 00 	cp.b	r10,r11
8000724e:	c3 a0       	breq	800072c2 <get_arg+0x16e>
80007250:	34 4b       	mov	r11,68
80007252:	c0 88       	rjmp	80007262 <get_arg+0x10e>
80007254:	35 8b       	mov	r11,88
80007256:	f6 0a 18 00 	cp.b	r10,r11
8000725a:	c2 c0       	breq	800072b2 <get_arg+0x15e>
8000725c:	e0 8b 00 07 	brhi	8000726a <get_arg+0x116>
80007260:	35 5b       	mov	r11,85
80007262:	f6 0a 18 00 	cp.b	r10,r11
80007266:	c3 51       	brne	800072d0 <get_arg+0x17c>
80007268:	c3 18       	rjmp	800072ca <get_arg+0x176>
8000726a:	36 3b       	mov	r11,99
8000726c:	f6 0a 18 00 	cp.b	r10,r11
80007270:	c2 f0       	breq	800072ce <get_arg+0x17a>
80007272:	36 4b       	mov	r11,100
80007274:	c0 e8       	rjmp	80007290 <get_arg+0x13c>
80007276:	37 0b       	mov	r11,112
80007278:	f6 0a 18 00 	cp.b	r10,r11
8000727c:	c2 50       	breq	800072c6 <get_arg+0x172>
8000727e:	e0 8b 00 0d 	brhi	80007298 <get_arg+0x144>
80007282:	36 eb       	mov	r11,110
80007284:	f6 0a 18 00 	cp.b	r10,r11
80007288:	c1 f0       	breq	800072c6 <get_arg+0x172>
8000728a:	e0 8b 00 14 	brhi	800072b2 <get_arg+0x15e>
8000728e:	36 9b       	mov	r11,105
80007290:	f6 0a 18 00 	cp.b	r10,r11
80007294:	c1 e1       	brne	800072d0 <get_arg+0x17c>
80007296:	c0 e8       	rjmp	800072b2 <get_arg+0x15e>
80007298:	37 5b       	mov	r11,117
8000729a:	f6 0a 18 00 	cp.b	r10,r11
8000729e:	c0 a0       	breq	800072b2 <get_arg+0x15e>
800072a0:	37 8b       	mov	r11,120
800072a2:	f6 0a 18 00 	cp.b	r10,r11
800072a6:	c0 60       	breq	800072b2 <get_arg+0x15e>
800072a8:	37 3b       	mov	r11,115
800072aa:	f6 0a 18 00 	cp.b	r10,r11
800072ae:	c1 11       	brne	800072d0 <get_arg+0x17c>
800072b0:	c0 b8       	rjmp	800072c6 <get_arg+0x172>
800072b2:	ed b4 00 04 	bld	r4,0x4
800072b6:	c0 a0       	breq	800072ca <get_arg+0x176>
800072b8:	ed b4 00 05 	bld	r4,0x5
800072bc:	c0 91       	brne	800072ce <get_arg+0x17a>
800072be:	30 20       	mov	r0,2
800072c0:	c0 88       	rjmp	800072d0 <get_arg+0x17c>
800072c2:	30 40       	mov	r0,4
800072c4:	c0 68       	rjmp	800072d0 <get_arg+0x17c>
800072c6:	30 30       	mov	r0,3
800072c8:	c0 48       	rjmp	800072d0 <get_arg+0x17c>
800072ca:	30 10       	mov	r0,1
800072cc:	c0 28       	rjmp	800072d0 <get_arg+0x17c>
800072ce:	30 00       	mov	r0,0
800072d0:	40 3b       	lddsp	r11,sp[0xc]
800072d2:	5b fb       	cp.w	r11,-1
800072d4:	c0 40       	breq	800072dc <get_arg+0x188>
800072d6:	e2 0b 09 20 	st.w	r1[r11<<0x2],r0
800072da:	c7 08       	rjmp	800073ba <get_arg+0x266>
800072dc:	58 60       	cp.w	r0,6
800072de:	e0 8b 00 6e 	brhi	800073ba <get_arg+0x266>
800072e2:	6c 0a       	ld.w	r10,r6[0x0]
800072e4:	ea cc ff ff 	sub	r12,r5,-1
800072e8:	fe ce a3 14 	sub	lr,pc,-23788
800072ec:	fc 00 03 2f 	ld.w	pc,lr[r0<<0x2]
800072f0:	f4 cb ff f8 	sub	r11,r10,-8
800072f4:	8d 0b       	st.w	r6[0x0],r11
800072f6:	f4 ea 00 00 	ld.d	r10,r10[0]
800072fa:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
800072fe:	c0 f8       	rjmp	8000731c <get_arg+0x1c8>
80007300:	f4 cb ff fc 	sub	r11,r10,-4
80007304:	8d 0b       	st.w	r6[0x0],r11
80007306:	74 0a       	ld.w	r10,r10[0x0]
80007308:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
8000730c:	c0 88       	rjmp	8000731c <get_arg+0x1c8>
8000730e:	f4 cb ff f8 	sub	r11,r10,-8
80007312:	8d 0b       	st.w	r6[0x0],r11
80007314:	f4 ea 00 00 	ld.d	r10,r10[0]
80007318:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
8000731c:	0e 9b       	mov	r11,r7
8000731e:	18 95       	mov	r5,r12
80007320:	c4 e8       	rjmp	800073bc <get_arg+0x268>
80007322:	62 0a       	ld.w	r10,r1[0x0]
80007324:	5b fa       	cp.w	r10,-1
80007326:	c0 b1       	brne	8000733c <get_arg+0x1e8>
80007328:	50 19       	stdsp	sp[0x4],r9
8000732a:	50 28       	stdsp	sp[0x8],r8
8000732c:	e0 6a 00 80 	mov	r10,128
80007330:	30 0b       	mov	r11,0
80007332:	02 9c       	mov	r12,r1
80007334:	fe b0 fc f4 	rcall	80006d1c <memset>
80007338:	40 28       	lddsp	r8,sp[0x8]
8000733a:	40 19       	lddsp	r9,sp[0x4]
8000733c:	e4 cc 00 01 	sub	r12,r2,1
80007340:	0e 9b       	mov	r11,r7
80007342:	50 3c       	stdsp	sp[0xc],r12
80007344:	f2 0c 0c 49 	max	r9,r9,r12
80007348:	c3 a8       	rjmp	800073bc <get_arg+0x268>
8000734a:	62 0a       	ld.w	r10,r1[0x0]
8000734c:	5b fa       	cp.w	r10,-1
8000734e:	c0 b1       	brne	80007364 <get_arg+0x210>
80007350:	50 19       	stdsp	sp[0x4],r9
80007352:	50 28       	stdsp	sp[0x8],r8
80007354:	e0 6a 00 80 	mov	r10,128
80007358:	30 0b       	mov	r11,0
8000735a:	02 9c       	mov	r12,r1
8000735c:	fe b0 fc e0 	rcall	80006d1c <memset>
80007360:	40 28       	lddsp	r8,sp[0x8]
80007362:	40 19       	lddsp	r9,sp[0x4]
80007364:	20 12       	sub	r2,1
80007366:	30 0a       	mov	r10,0
80007368:	0e 9b       	mov	r11,r7
8000736a:	e2 02 09 2a 	st.w	r1[r2<<0x2],r10
8000736e:	f2 02 0c 49 	max	r9,r9,r2
80007372:	c2 58       	rjmp	800073bc <get_arg+0x268>
80007374:	16 97       	mov	r7,r11
80007376:	6c 0a       	ld.w	r10,r6[0x0]
80007378:	f4 cb ff fc 	sub	r11,r10,-4
8000737c:	8d 0b       	st.w	r6[0x0],r11
8000737e:	74 0a       	ld.w	r10,r10[0x0]
80007380:	0e 9b       	mov	r11,r7
80007382:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80007386:	2f f5       	sub	r5,-1
80007388:	c1 a8       	rjmp	800073bc <get_arg+0x268>
8000738a:	f4 c2 00 30 	sub	r2,r10,48
8000738e:	c0 68       	rjmp	8000739a <get_arg+0x246>
80007390:	e4 02 00 22 	add	r2,r2,r2<<0x2
80007394:	2f f7       	sub	r7,-1
80007396:	f4 02 00 12 	add	r2,r10,r2<<0x1
8000739a:	0f 8a       	ld.ub	r10,r7[0x0]
8000739c:	58 0a       	cp.w	r10,0
8000739e:	c0 e0       	breq	800073ba <get_arg+0x266>
800073a0:	23 0a       	sub	r10,48
800073a2:	58 9a       	cp.w	r10,9
800073a4:	fe 98 ff f6 	brls	80007390 <get_arg+0x23c>
800073a8:	c0 98       	rjmp	800073ba <get_arg+0x266>
800073aa:	2f f7       	sub	r7,-1
800073ac:	0f 8a       	ld.ub	r10,r7[0x0]
800073ae:	58 0a       	cp.w	r10,0
800073b0:	c0 50       	breq	800073ba <get_arg+0x266>
800073b2:	23 0a       	sub	r10,48
800073b4:	58 9a       	cp.w	r10,9
800073b6:	fe 98 ff fa 	brls	800073aa <get_arg+0x256>
800073ba:	0e 9b       	mov	r11,r7
800073bc:	40 7c       	lddsp	r12,sp[0x1c]
800073be:	30 ba       	mov	r10,11
800073c0:	f4 0c 18 00 	cp.b	r12,r10
800073c4:	fe 91 fe f2 	brne	800071a8 <get_arg+0x54>
800073c8:	40 42       	lddsp	r2,sp[0x10]
800073ca:	17 8c       	ld.ub	r12,r11[0x0]
800073cc:	0a 32       	cp.w	r2,r5
800073ce:	5f 4a       	srge	r10
800073d0:	f0 0c 18 00 	cp.b	r12,r8
800073d4:	5f 1c       	srne	r12
800073d6:	f9 ea 00 0a 	and	r10,r12,r10
800073da:	f0 0a 18 00 	cp.b	r10,r8
800073de:	fe 91 fe cf 	brne	8000717c <get_arg+0x28>
800073e2:	30 08       	mov	r8,0
800073e4:	40 4e       	lddsp	lr,sp[0x10]
800073e6:	17 8a       	ld.ub	r10,r11[0x0]
800073e8:	e2 05 00 21 	add	r1,r1,r5<<0x2
800073ec:	f0 0a 18 00 	cp.b	r10,r8
800073f0:	fc 09 17 10 	movne	r9,lr
800073f4:	e6 05 00 38 	add	r8,r3,r5<<0x3
800073f8:	06 9e       	mov	lr,r3
800073fa:	c2 a8       	rjmp	8000744e <get_arg+0x2fa>
800073fc:	62 0a       	ld.w	r10,r1[0x0]
800073fe:	58 3a       	cp.w	r10,3
80007400:	c1 e0       	breq	8000743c <get_arg+0x2e8>
80007402:	e0 89 00 07 	brgt	80007410 <get_arg+0x2bc>
80007406:	58 1a       	cp.w	r10,1
80007408:	c1 a0       	breq	8000743c <get_arg+0x2e8>
8000740a:	58 2a       	cp.w	r10,2
8000740c:	c1 81       	brne	8000743c <get_arg+0x2e8>
8000740e:	c0 58       	rjmp	80007418 <get_arg+0x2c4>
80007410:	58 5a       	cp.w	r10,5
80007412:	c0 c0       	breq	8000742a <get_arg+0x2d6>
80007414:	c0 b5       	brlt	8000742a <get_arg+0x2d6>
80007416:	c1 38       	rjmp	8000743c <get_arg+0x2e8>
80007418:	6c 0a       	ld.w	r10,r6[0x0]
8000741a:	f4 cc ff f8 	sub	r12,r10,-8
8000741e:	8d 0c       	st.w	r6[0x0],r12
80007420:	f4 e2 00 00 	ld.d	r2,r10[0]
80007424:	f0 e3 00 00 	st.d	r8[0],r2
80007428:	c1 08       	rjmp	80007448 <get_arg+0x2f4>
8000742a:	6c 0a       	ld.w	r10,r6[0x0]
8000742c:	f4 cc ff f8 	sub	r12,r10,-8
80007430:	8d 0c       	st.w	r6[0x0],r12
80007432:	f4 e2 00 00 	ld.d	r2,r10[0]
80007436:	f0 e3 00 00 	st.d	r8[0],r2
8000743a:	c0 78       	rjmp	80007448 <get_arg+0x2f4>
8000743c:	6c 0a       	ld.w	r10,r6[0x0]
8000743e:	f4 cc ff fc 	sub	r12,r10,-4
80007442:	8d 0c       	st.w	r6[0x0],r12
80007444:	74 0a       	ld.w	r10,r10[0x0]
80007446:	91 0a       	st.w	r8[0x0],r10
80007448:	2f f5       	sub	r5,-1
8000744a:	2f 88       	sub	r8,-8
8000744c:	2f c1       	sub	r1,-4
8000744e:	12 35       	cp.w	r5,r9
80007450:	fe 9a ff d6 	brle	800073fc <get_arg+0x2a8>
80007454:	1c 93       	mov	r3,lr
80007456:	40 52       	lddsp	r2,sp[0x14]
80007458:	40 6e       	lddsp	lr,sp[0x18]
8000745a:	85 05       	st.w	r2[0x0],r5
8000745c:	9d 0b       	st.w	lr[0x0],r11
8000745e:	40 4b       	lddsp	r11,sp[0x10]
80007460:	e6 0b 00 3c 	add	r12,r3,r11<<0x3
80007464:	2f 8d       	sub	sp,-32
80007466:	d8 32       	popm	r0-r7,pc

80007468 <__sprint_r>:
80007468:	d4 21       	pushm	r4-r7,lr
8000746a:	14 97       	mov	r7,r10
8000746c:	74 28       	ld.w	r8,r10[0x8]
8000746e:	58 08       	cp.w	r8,0
80007470:	c0 41       	brne	80007478 <__sprint_r+0x10>
80007472:	95 18       	st.w	r10[0x4],r8
80007474:	10 9c       	mov	r12,r8
80007476:	d8 22       	popm	r4-r7,pc
80007478:	e0 a0 18 ba 	rcall	8000a5ec <__sfvwrite_r>
8000747c:	30 08       	mov	r8,0
8000747e:	8f 18       	st.w	r7[0x4],r8
80007480:	8f 28       	st.w	r7[0x8],r8
80007482:	d8 22       	popm	r4-r7,pc

80007484 <_vfprintf_r>:
80007484:	d4 31       	pushm	r0-r7,lr
80007486:	fa cd 06 bc 	sub	sp,sp,1724
8000748a:	51 09       	stdsp	sp[0x40],r9
8000748c:	16 91       	mov	r1,r11
8000748e:	14 97       	mov	r7,r10
80007490:	18 95       	mov	r5,r12
80007492:	e0 a0 1a 1d 	rcall	8000a8cc <_localeconv_r>
80007496:	78 0c       	ld.w	r12,r12[0x0]
80007498:	50 cc       	stdsp	sp[0x30],r12
8000749a:	58 05       	cp.w	r5,0
8000749c:	c0 70       	breq	800074aa <_vfprintf_r+0x26>
8000749e:	6a 68       	ld.w	r8,r5[0x18]
800074a0:	58 08       	cp.w	r8,0
800074a2:	c0 41       	brne	800074aa <_vfprintf_r+0x26>
800074a4:	0a 9c       	mov	r12,r5
800074a6:	e0 a0 17 43 	rcall	8000a32c <__sinit>
800074aa:	fe c8 a1 12 	sub	r8,pc,-24302
800074ae:	10 31       	cp.w	r1,r8
800074b0:	c0 31       	brne	800074b6 <_vfprintf_r+0x32>
800074b2:	6a 01       	ld.w	r1,r5[0x0]
800074b4:	c0 c8       	rjmp	800074cc <_vfprintf_r+0x48>
800074b6:	fe c8 a0 fe 	sub	r8,pc,-24322
800074ba:	10 31       	cp.w	r1,r8
800074bc:	c0 31       	brne	800074c2 <_vfprintf_r+0x3e>
800074be:	6a 11       	ld.w	r1,r5[0x4]
800074c0:	c0 68       	rjmp	800074cc <_vfprintf_r+0x48>
800074c2:	fe c8 a0 ea 	sub	r8,pc,-24342
800074c6:	10 31       	cp.w	r1,r8
800074c8:	eb f1 00 02 	ld.weq	r1,r5[0x8]
800074cc:	82 68       	ld.sh	r8,r1[0xc]
800074ce:	ed b8 00 03 	bld	r8,0x3
800074d2:	c0 41       	brne	800074da <_vfprintf_r+0x56>
800074d4:	62 48       	ld.w	r8,r1[0x10]
800074d6:	58 08       	cp.w	r8,0
800074d8:	c0 71       	brne	800074e6 <_vfprintf_r+0x62>
800074da:	02 9b       	mov	r11,r1
800074dc:	0a 9c       	mov	r12,r5
800074de:	e0 a0 0f 5d 	rcall	80009398 <__swsetup_r>
800074e2:	e0 81 0f 54 	brne	8000938a <_vfprintf_r+0x1f06>
800074e6:	82 68       	ld.sh	r8,r1[0xc]
800074e8:	10 99       	mov	r9,r8
800074ea:	e2 19 00 1a 	andl	r9,0x1a,COH
800074ee:	58 a9       	cp.w	r9,10
800074f0:	c3 c1       	brne	80007568 <_vfprintf_r+0xe4>
800074f2:	82 79       	ld.sh	r9,r1[0xe]
800074f4:	30 0a       	mov	r10,0
800074f6:	f4 09 19 00 	cp.h	r9,r10
800074fa:	c3 75       	brlt	80007568 <_vfprintf_r+0xe4>
800074fc:	a1 d8       	cbr	r8,0x1
800074fe:	fb 58 05 d0 	st.h	sp[1488],r8
80007502:	62 88       	ld.w	r8,r1[0x20]
80007504:	fb 48 05 e4 	st.w	sp[1508],r8
80007508:	62 a8       	ld.w	r8,r1[0x28]
8000750a:	fb 48 05 ec 	st.w	sp[1516],r8
8000750e:	fa c8 ff bc 	sub	r8,sp,-68
80007512:	fb 48 05 d4 	st.w	sp[1492],r8
80007516:	fb 48 05 c4 	st.w	sp[1476],r8
8000751a:	e0 68 04 00 	mov	r8,1024
8000751e:	fb 48 05 d8 	st.w	sp[1496],r8
80007522:	fb 48 05 cc 	st.w	sp[1484],r8
80007526:	30 08       	mov	r8,0
80007528:	fb 59 05 d2 	st.h	sp[1490],r9
8000752c:	0e 9a       	mov	r10,r7
8000752e:	41 09       	lddsp	r9,sp[0x40]
80007530:	fa c7 fa 3c 	sub	r7,sp,-1476
80007534:	fb 48 05 dc 	st.w	sp[1500],r8
80007538:	0a 9c       	mov	r12,r5
8000753a:	0e 9b       	mov	r11,r7
8000753c:	ca 4f       	rcall	80007484 <_vfprintf_r>
8000753e:	50 bc       	stdsp	sp[0x2c],r12
80007540:	c0 95       	brlt	80007552 <_vfprintf_r+0xce>
80007542:	0e 9b       	mov	r11,r7
80007544:	0a 9c       	mov	r12,r5
80007546:	e0 a0 16 1b 	rcall	8000a17c <_fflush_r>
8000754a:	40 be       	lddsp	lr,sp[0x2c]
8000754c:	f9 be 01 ff 	movne	lr,-1
80007550:	50 be       	stdsp	sp[0x2c],lr
80007552:	fb 08 05 d0 	ld.sh	r8,sp[1488]
80007556:	ed b8 00 06 	bld	r8,0x6
8000755a:	e0 81 0f 1a 	brne	8000938e <_vfprintf_r+0x1f0a>
8000755e:	82 68       	ld.sh	r8,r1[0xc]
80007560:	a7 a8       	sbr	r8,0x6
80007562:	a2 68       	st.h	r1[0xc],r8
80007564:	e0 8f 0f 15 	bral	8000938e <_vfprintf_r+0x1f0a>
80007568:	30 08       	mov	r8,0
8000756a:	fb 48 06 b4 	st.w	sp[1716],r8
8000756e:	fb 48 06 90 	st.w	sp[1680],r8
80007572:	fb 48 06 8c 	st.w	sp[1676],r8
80007576:	fb 48 06 b0 	st.w	sp[1712],r8
8000757a:	30 08       	mov	r8,0
8000757c:	30 09       	mov	r9,0
8000757e:	50 a7       	stdsp	sp[0x28],r7
80007580:	50 78       	stdsp	sp[0x1c],r8
80007582:	fa c3 f9 e0 	sub	r3,sp,-1568
80007586:	3f f8       	mov	r8,-1
80007588:	50 59       	stdsp	sp[0x14],r9
8000758a:	fb 43 06 88 	st.w	sp[1672],r3
8000758e:	fb 48 05 44 	st.w	sp[1348],r8
80007592:	12 9c       	mov	r12,r9
80007594:	50 69       	stdsp	sp[0x18],r9
80007596:	50 d9       	stdsp	sp[0x34],r9
80007598:	50 e9       	stdsp	sp[0x38],r9
8000759a:	50 b9       	stdsp	sp[0x2c],r9
8000759c:	12 97       	mov	r7,r9
8000759e:	0a 94       	mov	r4,r5
800075a0:	40 a2       	lddsp	r2,sp[0x28]
800075a2:	32 5a       	mov	r10,37
800075a4:	30 08       	mov	r8,0
800075a6:	c0 28       	rjmp	800075aa <_vfprintf_r+0x126>
800075a8:	2f f2       	sub	r2,-1
800075aa:	05 89       	ld.ub	r9,r2[0x0]
800075ac:	f0 09 18 00 	cp.b	r9,r8
800075b0:	5f 1b       	srne	r11
800075b2:	f4 09 18 00 	cp.b	r9,r10
800075b6:	5f 19       	srne	r9
800075b8:	f3 eb 00 0b 	and	r11,r9,r11
800075bc:	f0 0b 18 00 	cp.b	r11,r8
800075c0:	cf 41       	brne	800075a8 <_vfprintf_r+0x124>
800075c2:	40 ab       	lddsp	r11,sp[0x28]
800075c4:	e4 0b 01 06 	sub	r6,r2,r11
800075c8:	c1 e0       	breq	80007604 <_vfprintf_r+0x180>
800075ca:	fa f8 06 90 	ld.w	r8,sp[1680]
800075ce:	0c 08       	add	r8,r6
800075d0:	87 0b       	st.w	r3[0x0],r11
800075d2:	fb 48 06 90 	st.w	sp[1680],r8
800075d6:	87 16       	st.w	r3[0x4],r6
800075d8:	fa f8 06 8c 	ld.w	r8,sp[1676]
800075dc:	2f f8       	sub	r8,-1
800075de:	fb 48 06 8c 	st.w	sp[1676],r8
800075e2:	58 78       	cp.w	r8,7
800075e4:	e0 89 00 04 	brgt	800075ec <_vfprintf_r+0x168>
800075e8:	2f 83       	sub	r3,-8
800075ea:	c0 a8       	rjmp	800075fe <_vfprintf_r+0x17a>
800075ec:	fa ca f9 78 	sub	r10,sp,-1672
800075f0:	02 9b       	mov	r11,r1
800075f2:	08 9c       	mov	r12,r4
800075f4:	c3 af       	rcall	80007468 <__sprint_r>
800075f6:	e0 81 0e c6 	brne	80009382 <_vfprintf_r+0x1efe>
800075fa:	fa c3 f9 e0 	sub	r3,sp,-1568
800075fe:	40 ba       	lddsp	r10,sp[0x2c]
80007600:	0c 0a       	add	r10,r6
80007602:	50 ba       	stdsp	sp[0x2c],r10
80007604:	05 89       	ld.ub	r9,r2[0x0]
80007606:	30 08       	mov	r8,0
80007608:	f0 09 18 00 	cp.b	r9,r8
8000760c:	e0 80 0e aa 	breq	80009360 <_vfprintf_r+0x1edc>
80007610:	30 09       	mov	r9,0
80007612:	fb 68 06 bb 	st.b	sp[1723],r8
80007616:	0e 96       	mov	r6,r7
80007618:	e4 c8 ff ff 	sub	r8,r2,-1
8000761c:	3f fe       	mov	lr,-1
8000761e:	50 93       	stdsp	sp[0x24],r3
80007620:	50 41       	stdsp	sp[0x10],r1
80007622:	0e 93       	mov	r3,r7
80007624:	04 91       	mov	r1,r2
80007626:	50 89       	stdsp	sp[0x20],r9
80007628:	50 a8       	stdsp	sp[0x28],r8
8000762a:	50 2e       	stdsp	sp[0x8],lr
8000762c:	50 39       	stdsp	sp[0xc],r9
8000762e:	12 95       	mov	r5,r9
80007630:	12 90       	mov	r0,r9
80007632:	10 97       	mov	r7,r8
80007634:	08 92       	mov	r2,r4
80007636:	c0 78       	rjmp	80007644 <_vfprintf_r+0x1c0>
80007638:	3f fc       	mov	r12,-1
8000763a:	08 97       	mov	r7,r4
8000763c:	50 2c       	stdsp	sp[0x8],r12
8000763e:	c0 38       	rjmp	80007644 <_vfprintf_r+0x1c0>
80007640:	30 0b       	mov	r11,0
80007642:	50 3b       	stdsp	sp[0xc],r11
80007644:	0f 38       	ld.ub	r8,r7++
80007646:	c0 28       	rjmp	8000764a <_vfprintf_r+0x1c6>
80007648:	12 90       	mov	r0,r9
8000764a:	f0 c9 00 20 	sub	r9,r8,32
8000764e:	e0 49 00 58 	cp.w	r9,88
80007652:	e0 8b 0a 30 	brhi	80008ab2 <_vfprintf_r+0x162e>
80007656:	fe ca a6 66 	sub	r10,pc,-22938
8000765a:	f4 09 03 2f 	ld.w	pc,r10[r9<<0x2]
8000765e:	50 a7       	stdsp	sp[0x28],r7
80007660:	50 80       	stdsp	sp[0x20],r0
80007662:	0c 97       	mov	r7,r6
80007664:	04 94       	mov	r4,r2
80007666:	06 96       	mov	r6,r3
80007668:	02 92       	mov	r2,r1
8000766a:	fe c9 a4 3e 	sub	r9,pc,-23490
8000766e:	40 93       	lddsp	r3,sp[0x24]
80007670:	10 90       	mov	r0,r8
80007672:	40 41       	lddsp	r1,sp[0x10]
80007674:	50 d9       	stdsp	sp[0x34],r9
80007676:	e0 8f 08 8e 	bral	80008792 <_vfprintf_r+0x130e>
8000767a:	30 08       	mov	r8,0
8000767c:	fb 39 06 bb 	ld.ub	r9,sp[1723]
80007680:	f0 09 18 00 	cp.b	r9,r8
80007684:	ce 01       	brne	80007644 <_vfprintf_r+0x1c0>
80007686:	32 08       	mov	r8,32
80007688:	c6 e8       	rjmp	80007764 <_vfprintf_r+0x2e0>
8000768a:	a1 a5       	sbr	r5,0x0
8000768c:	cd cb       	rjmp	80007644 <_vfprintf_r+0x1c0>
8000768e:	0f 89       	ld.ub	r9,r7[0x0]
80007690:	f2 c8 00 30 	sub	r8,r9,48
80007694:	58 98       	cp.w	r8,9
80007696:	e0 8b 00 1d 	brhi	800076d0 <_vfprintf_r+0x24c>
8000769a:	ee c8 ff ff 	sub	r8,r7,-1
8000769e:	30 0b       	mov	r11,0
800076a0:	23 09       	sub	r9,48
800076a2:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
800076a6:	f2 0b 00 1b 	add	r11,r9,r11<<0x1
800076aa:	11 39       	ld.ub	r9,r8++
800076ac:	f2 ca 00 30 	sub	r10,r9,48
800076b0:	58 9a       	cp.w	r10,9
800076b2:	fe 98 ff f7 	brls	800076a0 <_vfprintf_r+0x21c>
800076b6:	e0 49 00 24 	cp.w	r9,36
800076ba:	cc 31       	brne	80007640 <_vfprintf_r+0x1bc>
800076bc:	e0 4b 00 20 	cp.w	r11,32
800076c0:	e0 89 0e 60 	brgt	80009380 <_vfprintf_r+0x1efc>
800076c4:	20 1b       	sub	r11,1
800076c6:	fa f9 06 b4 	ld.w	r9,sp[1716]
800076ca:	12 3b       	cp.w	r11,r9
800076cc:	c0 95       	brlt	800076de <_vfprintf_r+0x25a>
800076ce:	c1 08       	rjmp	800076ee <_vfprintf_r+0x26a>
800076d0:	fa f9 06 b4 	ld.w	r9,sp[1716]
800076d4:	ec ca ff ff 	sub	r10,r6,-1
800076d8:	12 36       	cp.w	r6,r9
800076da:	c1 f5       	brlt	80007718 <_vfprintf_r+0x294>
800076dc:	c2 68       	rjmp	80007728 <_vfprintf_r+0x2a4>
800076de:	fa ce f9 44 	sub	lr,sp,-1724
800076e2:	10 97       	mov	r7,r8
800076e4:	fc 0b 00 3b 	add	r11,lr,r11<<0x3
800076e8:	f6 f0 fd 88 	ld.w	r0,r11[-632]
800076ec:	c3 58       	rjmp	80007756 <_vfprintf_r+0x2d2>
800076ee:	10 97       	mov	r7,r8
800076f0:	fa c8 f9 50 	sub	r8,sp,-1712
800076f4:	1a d8       	st.w	--sp,r8
800076f6:	fa c8 fa b8 	sub	r8,sp,-1352
800076fa:	1a d8       	st.w	--sp,r8
800076fc:	fa c8 fb b4 	sub	r8,sp,-1100
80007700:	02 9a       	mov	r10,r1
80007702:	1a d8       	st.w	--sp,r8
80007704:	04 9c       	mov	r12,r2
80007706:	fa c8 f9 40 	sub	r8,sp,-1728
8000770a:	fa c9 ff b4 	sub	r9,sp,-76
8000770e:	fe b0 fd 23 	rcall	80007154 <get_arg>
80007712:	2f dd       	sub	sp,-12
80007714:	78 00       	ld.w	r0,r12[0x0]
80007716:	c2 08       	rjmp	80007756 <_vfprintf_r+0x2d2>
80007718:	fa cc f9 44 	sub	r12,sp,-1724
8000771c:	14 96       	mov	r6,r10
8000771e:	f8 03 00 38 	add	r8,r12,r3<<0x3
80007722:	f0 f0 fd 88 	ld.w	r0,r8[-632]
80007726:	c1 88       	rjmp	80007756 <_vfprintf_r+0x2d2>
80007728:	41 08       	lddsp	r8,sp[0x40]
8000772a:	59 f9       	cp.w	r9,31
8000772c:	e0 89 00 11 	brgt	8000774e <_vfprintf_r+0x2ca>
80007730:	f0 cb ff fc 	sub	r11,r8,-4
80007734:	51 0b       	stdsp	sp[0x40],r11
80007736:	70 00       	ld.w	r0,r8[0x0]
80007738:	fa cb f9 44 	sub	r11,sp,-1724
8000773c:	f6 09 00 38 	add	r8,r11,r9<<0x3
80007740:	f1 40 fd 88 	st.w	r8[-632],r0
80007744:	2f f9       	sub	r9,-1
80007746:	14 96       	mov	r6,r10
80007748:	fb 49 06 b4 	st.w	sp[1716],r9
8000774c:	c0 58       	rjmp	80007756 <_vfprintf_r+0x2d2>
8000774e:	70 00       	ld.w	r0,r8[0x0]
80007750:	14 96       	mov	r6,r10
80007752:	2f c8       	sub	r8,-4
80007754:	51 08       	stdsp	sp[0x40],r8
80007756:	58 00       	cp.w	r0,0
80007758:	fe 94 ff 76 	brge	80007644 <_vfprintf_r+0x1c0>
8000775c:	5c 30       	neg	r0
8000775e:	a3 a5       	sbr	r5,0x2
80007760:	c7 2b       	rjmp	80007644 <_vfprintf_r+0x1c0>
80007762:	32 b8       	mov	r8,43
80007764:	fb 68 06 bb 	st.b	sp[1723],r8
80007768:	c6 eb       	rjmp	80007644 <_vfprintf_r+0x1c0>
8000776a:	0f 38       	ld.ub	r8,r7++
8000776c:	e0 48 00 2a 	cp.w	r8,42
80007770:	c0 30       	breq	80007776 <_vfprintf_r+0x2f2>
80007772:	30 09       	mov	r9,0
80007774:	c7 98       	rjmp	80007866 <_vfprintf_r+0x3e2>
80007776:	0f 88       	ld.ub	r8,r7[0x0]
80007778:	f0 c9 00 30 	sub	r9,r8,48
8000777c:	58 99       	cp.w	r9,9
8000777e:	e0 8b 00 1f 	brhi	800077bc <_vfprintf_r+0x338>
80007782:	ee c4 ff ff 	sub	r4,r7,-1
80007786:	30 0b       	mov	r11,0
80007788:	23 08       	sub	r8,48
8000778a:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
8000778e:	f0 0b 00 1b 	add	r11,r8,r11<<0x1
80007792:	09 38       	ld.ub	r8,r4++
80007794:	f0 c9 00 30 	sub	r9,r8,48
80007798:	58 99       	cp.w	r9,9
8000779a:	fe 98 ff f7 	brls	80007788 <_vfprintf_r+0x304>
8000779e:	e0 48 00 24 	cp.w	r8,36
800077a2:	fe 91 ff 4f 	brne	80007640 <_vfprintf_r+0x1bc>
800077a6:	e0 4b 00 20 	cp.w	r11,32
800077aa:	e0 89 0d eb 	brgt	80009380 <_vfprintf_r+0x1efc>
800077ae:	20 1b       	sub	r11,1
800077b0:	fa f8 06 b4 	ld.w	r8,sp[1716]
800077b4:	10 3b       	cp.w	r11,r8
800077b6:	c0 a5       	brlt	800077ca <_vfprintf_r+0x346>
800077b8:	c1 18       	rjmp	800077da <_vfprintf_r+0x356>
800077ba:	d7 03       	nop
800077bc:	fa fa 06 b4 	ld.w	r10,sp[1716]
800077c0:	ec c9 ff ff 	sub	r9,r6,-1
800077c4:	14 36       	cp.w	r6,r10
800077c6:	c1 f5       	brlt	80007804 <_vfprintf_r+0x380>
800077c8:	c2 88       	rjmp	80007818 <_vfprintf_r+0x394>
800077ca:	fa ca f9 44 	sub	r10,sp,-1724
800077ce:	f4 0b 00 3b 	add	r11,r10,r11<<0x3
800077d2:	f6 fb fd 88 	ld.w	r11,r11[-632]
800077d6:	50 2b       	stdsp	sp[0x8],r11
800077d8:	c3 c8       	rjmp	80007850 <_vfprintf_r+0x3cc>
800077da:	fa c8 f9 50 	sub	r8,sp,-1712
800077de:	1a d8       	st.w	--sp,r8
800077e0:	fa c8 fa b8 	sub	r8,sp,-1352
800077e4:	1a d8       	st.w	--sp,r8
800077e6:	fa c8 fb b4 	sub	r8,sp,-1100
800077ea:	02 9a       	mov	r10,r1
800077ec:	1a d8       	st.w	--sp,r8
800077ee:	04 9c       	mov	r12,r2
800077f0:	fa c8 f9 40 	sub	r8,sp,-1728
800077f4:	fa c9 ff b4 	sub	r9,sp,-76
800077f8:	fe b0 fc ae 	rcall	80007154 <get_arg>
800077fc:	2f dd       	sub	sp,-12
800077fe:	78 0c       	ld.w	r12,r12[0x0]
80007800:	50 2c       	stdsp	sp[0x8],r12
80007802:	c2 78       	rjmp	80007850 <_vfprintf_r+0x3cc>
80007804:	12 96       	mov	r6,r9
80007806:	0e 94       	mov	r4,r7
80007808:	fa c9 f9 44 	sub	r9,sp,-1724
8000780c:	f2 03 00 38 	add	r8,r9,r3<<0x3
80007810:	f0 f8 fd 88 	ld.w	r8,r8[-632]
80007814:	50 28       	stdsp	sp[0x8],r8
80007816:	c1 d8       	rjmp	80007850 <_vfprintf_r+0x3cc>
80007818:	41 08       	lddsp	r8,sp[0x40]
8000781a:	59 fa       	cp.w	r10,31
8000781c:	e0 89 00 14 	brgt	80007844 <_vfprintf_r+0x3c0>
80007820:	f0 cb ff fc 	sub	r11,r8,-4
80007824:	70 08       	ld.w	r8,r8[0x0]
80007826:	51 0b       	stdsp	sp[0x40],r11
80007828:	50 28       	stdsp	sp[0x8],r8
8000782a:	fa c6 f9 44 	sub	r6,sp,-1724
8000782e:	40 2e       	lddsp	lr,sp[0x8]
80007830:	ec 0a 00 38 	add	r8,r6,r10<<0x3
80007834:	f1 4e fd 88 	st.w	r8[-632],lr
80007838:	2f fa       	sub	r10,-1
8000783a:	0e 94       	mov	r4,r7
8000783c:	fb 4a 06 b4 	st.w	sp[1716],r10
80007840:	12 96       	mov	r6,r9
80007842:	c0 78       	rjmp	80007850 <_vfprintf_r+0x3cc>
80007844:	70 0c       	ld.w	r12,r8[0x0]
80007846:	0e 94       	mov	r4,r7
80007848:	2f c8       	sub	r8,-4
8000784a:	50 2c       	stdsp	sp[0x8],r12
8000784c:	12 96       	mov	r6,r9
8000784e:	51 08       	stdsp	sp[0x40],r8
80007850:	40 2b       	lddsp	r11,sp[0x8]
80007852:	58 0b       	cp.w	r11,0
80007854:	fe 95 fe f2 	brlt	80007638 <_vfprintf_r+0x1b4>
80007858:	08 97       	mov	r7,r4
8000785a:	cf 5a       	rjmp	80007644 <_vfprintf_r+0x1c0>
8000785c:	f2 09 00 29 	add	r9,r9,r9<<0x2
80007860:	0f 38       	ld.ub	r8,r7++
80007862:	f4 09 00 19 	add	r9,r10,r9<<0x1
80007866:	f0 ca 00 30 	sub	r10,r8,48
8000786a:	58 9a       	cp.w	r10,9
8000786c:	fe 98 ff f8 	brls	8000785c <_vfprintf_r+0x3d8>
80007870:	3f fa       	mov	r10,-1
80007872:	f2 0a 0c 49 	max	r9,r9,r10
80007876:	50 29       	stdsp	sp[0x8],r9
80007878:	ce 9a       	rjmp	8000764a <_vfprintf_r+0x1c6>
8000787a:	a7 b5       	sbr	r5,0x7
8000787c:	ce 4a       	rjmp	80007644 <_vfprintf_r+0x1c0>
8000787e:	30 09       	mov	r9,0
80007880:	23 08       	sub	r8,48
80007882:	f2 09 00 29 	add	r9,r9,r9<<0x2
80007886:	f0 09 00 19 	add	r9,r8,r9<<0x1
8000788a:	0f 38       	ld.ub	r8,r7++
8000788c:	f0 ca 00 30 	sub	r10,r8,48
80007890:	58 9a       	cp.w	r10,9
80007892:	fe 98 ff f7 	brls	80007880 <_vfprintf_r+0x3fc>
80007896:	e0 48 00 24 	cp.w	r8,36
8000789a:	fe 91 fe d7 	brne	80007648 <_vfprintf_r+0x1c4>
8000789e:	e0 49 00 20 	cp.w	r9,32
800078a2:	e0 89 0d 6f 	brgt	80009380 <_vfprintf_r+0x1efc>
800078a6:	f2 c3 00 01 	sub	r3,r9,1
800078aa:	30 19       	mov	r9,1
800078ac:	50 39       	stdsp	sp[0xc],r9
800078ae:	cc ba       	rjmp	80007644 <_vfprintf_r+0x1c0>
800078b0:	a3 b5       	sbr	r5,0x3
800078b2:	cc 9a       	rjmp	80007644 <_vfprintf_r+0x1c0>
800078b4:	a7 a5       	sbr	r5,0x6
800078b6:	cc 7a       	rjmp	80007644 <_vfprintf_r+0x1c0>
800078b8:	0a 98       	mov	r8,r5
800078ba:	a5 b5       	sbr	r5,0x5
800078bc:	a5 a8       	sbr	r8,0x4
800078be:	0f 89       	ld.ub	r9,r7[0x0]
800078c0:	36 ce       	mov	lr,108
800078c2:	fc 09 18 00 	cp.b	r9,lr
800078c6:	f7 b7 00 ff 	subeq	r7,-1
800078ca:	f0 05 17 10 	movne	r5,r8
800078ce:	cb ba       	rjmp	80007644 <_vfprintf_r+0x1c0>
800078d0:	a5 b5       	sbr	r5,0x5
800078d2:	cb 9a       	rjmp	80007644 <_vfprintf_r+0x1c0>
800078d4:	50 a7       	stdsp	sp[0x28],r7
800078d6:	50 80       	stdsp	sp[0x20],r0
800078d8:	0c 97       	mov	r7,r6
800078da:	10 90       	mov	r0,r8
800078dc:	06 96       	mov	r6,r3
800078de:	04 94       	mov	r4,r2
800078e0:	40 93       	lddsp	r3,sp[0x24]
800078e2:	02 92       	mov	r2,r1
800078e4:	0e 99       	mov	r9,r7
800078e6:	40 41       	lddsp	r1,sp[0x10]
800078e8:	fa f8 06 b4 	ld.w	r8,sp[1716]
800078ec:	40 3c       	lddsp	r12,sp[0xc]
800078ee:	58 0c       	cp.w	r12,0
800078f0:	c1 d0       	breq	8000792a <_vfprintf_r+0x4a6>
800078f2:	10 36       	cp.w	r6,r8
800078f4:	c0 64       	brge	80007900 <_vfprintf_r+0x47c>
800078f6:	fa cb f9 44 	sub	r11,sp,-1724
800078fa:	f6 06 00 36 	add	r6,r11,r6<<0x3
800078fe:	c1 d8       	rjmp	80007938 <_vfprintf_r+0x4b4>
80007900:	fa c8 f9 50 	sub	r8,sp,-1712
80007904:	1a d8       	st.w	--sp,r8
80007906:	fa c8 fa b8 	sub	r8,sp,-1352
8000790a:	1a d8       	st.w	--sp,r8
8000790c:	fa c8 fb b4 	sub	r8,sp,-1100
80007910:	1a d8       	st.w	--sp,r8
80007912:	fa c8 f9 40 	sub	r8,sp,-1728
80007916:	fa c9 ff b4 	sub	r9,sp,-76
8000791a:	04 9a       	mov	r10,r2
8000791c:	0c 9b       	mov	r11,r6
8000791e:	08 9c       	mov	r12,r4
80007920:	fe b0 fc 1a 	rcall	80007154 <get_arg>
80007924:	2f dd       	sub	sp,-12
80007926:	19 b8       	ld.ub	r8,r12[0x3]
80007928:	c2 28       	rjmp	8000796c <_vfprintf_r+0x4e8>
8000792a:	2f f7       	sub	r7,-1
8000792c:	10 39       	cp.w	r9,r8
8000792e:	c0 84       	brge	8000793e <_vfprintf_r+0x4ba>
80007930:	fa ca f9 44 	sub	r10,sp,-1724
80007934:	f4 06 00 36 	add	r6,r10,r6<<0x3
80007938:	ed 38 fd 8b 	ld.ub	r8,r6[-629]
8000793c:	c1 88       	rjmp	8000796c <_vfprintf_r+0x4e8>
8000793e:	41 09       	lddsp	r9,sp[0x40]
80007940:	59 f8       	cp.w	r8,31
80007942:	e0 89 00 12 	brgt	80007966 <_vfprintf_r+0x4e2>
80007946:	f2 ca ff fc 	sub	r10,r9,-4
8000794a:	51 0a       	stdsp	sp[0x40],r10
8000794c:	72 09       	ld.w	r9,r9[0x0]
8000794e:	fa c6 f9 44 	sub	r6,sp,-1724
80007952:	ec 08 00 3a 	add	r10,r6,r8<<0x3
80007956:	2f f8       	sub	r8,-1
80007958:	f5 49 fd 88 	st.w	r10[-632],r9
8000795c:	fb 48 06 b4 	st.w	sp[1716],r8
80007960:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
80007964:	c0 48       	rjmp	8000796c <_vfprintf_r+0x4e8>
80007966:	13 b8       	ld.ub	r8,r9[0x3]
80007968:	2f c9       	sub	r9,-4
8000796a:	51 09       	stdsp	sp[0x40],r9
8000796c:	fb 68 06 60 	st.b	sp[1632],r8
80007970:	30 0e       	mov	lr,0
80007972:	30 08       	mov	r8,0
80007974:	30 12       	mov	r2,1
80007976:	fb 68 06 bb 	st.b	sp[1723],r8
8000797a:	50 2e       	stdsp	sp[0x8],lr
8000797c:	e0 8f 08 ad 	bral	80008ad6 <_vfprintf_r+0x1652>
80007980:	50 a7       	stdsp	sp[0x28],r7
80007982:	50 80       	stdsp	sp[0x20],r0
80007984:	0c 97       	mov	r7,r6
80007986:	04 94       	mov	r4,r2
80007988:	06 96       	mov	r6,r3
8000798a:	02 92       	mov	r2,r1
8000798c:	40 93       	lddsp	r3,sp[0x24]
8000798e:	10 90       	mov	r0,r8
80007990:	40 41       	lddsp	r1,sp[0x10]
80007992:	a5 a5       	sbr	r5,0x4
80007994:	c0 a8       	rjmp	800079a8 <_vfprintf_r+0x524>
80007996:	50 a7       	stdsp	sp[0x28],r7
80007998:	50 80       	stdsp	sp[0x20],r0
8000799a:	0c 97       	mov	r7,r6
8000799c:	04 94       	mov	r4,r2
8000799e:	06 96       	mov	r6,r3
800079a0:	02 92       	mov	r2,r1
800079a2:	40 93       	lddsp	r3,sp[0x24]
800079a4:	10 90       	mov	r0,r8
800079a6:	40 41       	lddsp	r1,sp[0x10]
800079a8:	ed b5 00 05 	bld	r5,0x5
800079ac:	c5 11       	brne	80007a4e <_vfprintf_r+0x5ca>
800079ae:	fa f8 06 b4 	ld.w	r8,sp[1716]
800079b2:	40 3c       	lddsp	r12,sp[0xc]
800079b4:	58 0c       	cp.w	r12,0
800079b6:	c1 e0       	breq	800079f2 <_vfprintf_r+0x56e>
800079b8:	10 36       	cp.w	r6,r8
800079ba:	c0 64       	brge	800079c6 <_vfprintf_r+0x542>
800079bc:	fa cb f9 44 	sub	r11,sp,-1724
800079c0:	f6 06 00 36 	add	r6,r11,r6<<0x3
800079c4:	c2 08       	rjmp	80007a04 <_vfprintf_r+0x580>
800079c6:	fa c8 f9 50 	sub	r8,sp,-1712
800079ca:	1a d8       	st.w	--sp,r8
800079cc:	fa c8 fa b8 	sub	r8,sp,-1352
800079d0:	0c 9b       	mov	r11,r6
800079d2:	1a d8       	st.w	--sp,r8
800079d4:	fa c8 fb b4 	sub	r8,sp,-1100
800079d8:	1a d8       	st.w	--sp,r8
800079da:	fa c9 ff b4 	sub	r9,sp,-76
800079de:	fa c8 f9 40 	sub	r8,sp,-1728
800079e2:	04 9a       	mov	r10,r2
800079e4:	08 9c       	mov	r12,r4
800079e6:	fe b0 fb b7 	rcall	80007154 <get_arg>
800079ea:	2f dd       	sub	sp,-12
800079ec:	78 1b       	ld.w	r11,r12[0x4]
800079ee:	78 09       	ld.w	r9,r12[0x0]
800079f0:	c2 b8       	rjmp	80007a46 <_vfprintf_r+0x5c2>
800079f2:	ee ca ff ff 	sub	r10,r7,-1
800079f6:	10 37       	cp.w	r7,r8
800079f8:	c0 b4       	brge	80007a0e <_vfprintf_r+0x58a>
800079fa:	fa c9 f9 44 	sub	r9,sp,-1724
800079fe:	14 97       	mov	r7,r10
80007a00:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007a04:	ec fb fd 8c 	ld.w	r11,r6[-628]
80007a08:	ec f9 fd 88 	ld.w	r9,r6[-632]
80007a0c:	c1 d8       	rjmp	80007a46 <_vfprintf_r+0x5c2>
80007a0e:	41 09       	lddsp	r9,sp[0x40]
80007a10:	59 f8       	cp.w	r8,31
80007a12:	e0 89 00 14 	brgt	80007a3a <_vfprintf_r+0x5b6>
80007a16:	f2 cb ff f8 	sub	r11,r9,-8
80007a1a:	51 0b       	stdsp	sp[0x40],r11
80007a1c:	fa c6 f9 44 	sub	r6,sp,-1724
80007a20:	72 1b       	ld.w	r11,r9[0x4]
80007a22:	ec 08 00 3c 	add	r12,r6,r8<<0x3
80007a26:	72 09       	ld.w	r9,r9[0x0]
80007a28:	f9 4b fd 8c 	st.w	r12[-628],r11
80007a2c:	f9 49 fd 88 	st.w	r12[-632],r9
80007a30:	2f f8       	sub	r8,-1
80007a32:	14 97       	mov	r7,r10
80007a34:	fb 48 06 b4 	st.w	sp[1716],r8
80007a38:	c0 78       	rjmp	80007a46 <_vfprintf_r+0x5c2>
80007a3a:	f2 c8 ff f8 	sub	r8,r9,-8
80007a3e:	72 1b       	ld.w	r11,r9[0x4]
80007a40:	14 97       	mov	r7,r10
80007a42:	51 08       	stdsp	sp[0x40],r8
80007a44:	72 09       	ld.w	r9,r9[0x0]
80007a46:	16 98       	mov	r8,r11
80007a48:	fa e9 00 00 	st.d	sp[0],r8
80007a4c:	ca e8       	rjmp	80007ba8 <_vfprintf_r+0x724>
80007a4e:	ed b5 00 04 	bld	r5,0x4
80007a52:	c1 71       	brne	80007a80 <_vfprintf_r+0x5fc>
80007a54:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007a58:	40 3e       	lddsp	lr,sp[0xc]
80007a5a:	58 0e       	cp.w	lr,0
80007a5c:	c0 80       	breq	80007a6c <_vfprintf_r+0x5e8>
80007a5e:	10 36       	cp.w	r6,r8
80007a60:	c6 94       	brge	80007b32 <_vfprintf_r+0x6ae>
80007a62:	fa cc f9 44 	sub	r12,sp,-1724
80007a66:	f8 06 00 36 	add	r6,r12,r6<<0x3
80007a6a:	c8 28       	rjmp	80007b6e <_vfprintf_r+0x6ea>
80007a6c:	ee ca ff ff 	sub	r10,r7,-1
80007a70:	10 37       	cp.w	r7,r8
80007a72:	e0 84 00 81 	brge	80007b74 <_vfprintf_r+0x6f0>
80007a76:	fa cb f9 44 	sub	r11,sp,-1724
80007a7a:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007a7e:	c7 78       	rjmp	80007b6c <_vfprintf_r+0x6e8>
80007a80:	ed b5 00 06 	bld	r5,0x6
80007a84:	c4 b1       	brne	80007b1a <_vfprintf_r+0x696>
80007a86:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007a8a:	40 3c       	lddsp	r12,sp[0xc]
80007a8c:	58 0c       	cp.w	r12,0
80007a8e:	c1 d0       	breq	80007ac8 <_vfprintf_r+0x644>
80007a90:	10 36       	cp.w	r6,r8
80007a92:	c0 64       	brge	80007a9e <_vfprintf_r+0x61a>
80007a94:	fa cb f9 44 	sub	r11,sp,-1724
80007a98:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007a9c:	c1 f8       	rjmp	80007ada <_vfprintf_r+0x656>
80007a9e:	fa c8 f9 50 	sub	r8,sp,-1712
80007aa2:	1a d8       	st.w	--sp,r8
80007aa4:	fa c8 fa b8 	sub	r8,sp,-1352
80007aa8:	1a d8       	st.w	--sp,r8
80007aaa:	fa c8 fb b4 	sub	r8,sp,-1100
80007aae:	1a d8       	st.w	--sp,r8
80007ab0:	fa c8 f9 40 	sub	r8,sp,-1728
80007ab4:	fa c9 ff b4 	sub	r9,sp,-76
80007ab8:	04 9a       	mov	r10,r2
80007aba:	0c 9b       	mov	r11,r6
80007abc:	08 9c       	mov	r12,r4
80007abe:	fe b0 fb 4b 	rcall	80007154 <get_arg>
80007ac2:	2f dd       	sub	sp,-12
80007ac4:	98 18       	ld.sh	r8,r12[0x2]
80007ac6:	c2 68       	rjmp	80007b12 <_vfprintf_r+0x68e>
80007ac8:	ee ca ff ff 	sub	r10,r7,-1
80007acc:	10 37       	cp.w	r7,r8
80007ace:	c0 94       	brge	80007ae0 <_vfprintf_r+0x65c>
80007ad0:	fa c9 f9 44 	sub	r9,sp,-1724
80007ad4:	14 97       	mov	r7,r10
80007ad6:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007ada:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80007ade:	c1 a8       	rjmp	80007b12 <_vfprintf_r+0x68e>
80007ae0:	41 09       	lddsp	r9,sp[0x40]
80007ae2:	59 f8       	cp.w	r8,31
80007ae4:	e0 89 00 13 	brgt	80007b0a <_vfprintf_r+0x686>
80007ae8:	f2 cb ff fc 	sub	r11,r9,-4
80007aec:	51 0b       	stdsp	sp[0x40],r11
80007aee:	72 09       	ld.w	r9,r9[0x0]
80007af0:	fa c6 f9 44 	sub	r6,sp,-1724
80007af4:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80007af8:	2f f8       	sub	r8,-1
80007afa:	f7 49 fd 88 	st.w	r11[-632],r9
80007afe:	fb 48 06 b4 	st.w	sp[1716],r8
80007b02:	14 97       	mov	r7,r10
80007b04:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80007b08:	c0 58       	rjmp	80007b12 <_vfprintf_r+0x68e>
80007b0a:	92 18       	ld.sh	r8,r9[0x2]
80007b0c:	14 97       	mov	r7,r10
80007b0e:	2f c9       	sub	r9,-4
80007b10:	51 09       	stdsp	sp[0x40],r9
80007b12:	50 18       	stdsp	sp[0x4],r8
80007b14:	bf 58       	asr	r8,0x1f
80007b16:	50 08       	stdsp	sp[0x0],r8
80007b18:	c4 88       	rjmp	80007ba8 <_vfprintf_r+0x724>
80007b1a:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007b1e:	40 3c       	lddsp	r12,sp[0xc]
80007b20:	58 0c       	cp.w	r12,0
80007b22:	c1 d0       	breq	80007b5c <_vfprintf_r+0x6d8>
80007b24:	10 36       	cp.w	r6,r8
80007b26:	c0 64       	brge	80007b32 <_vfprintf_r+0x6ae>
80007b28:	fa cb f9 44 	sub	r11,sp,-1724
80007b2c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007b30:	c1 f8       	rjmp	80007b6e <_vfprintf_r+0x6ea>
80007b32:	fa c8 f9 50 	sub	r8,sp,-1712
80007b36:	1a d8       	st.w	--sp,r8
80007b38:	fa c8 fa b8 	sub	r8,sp,-1352
80007b3c:	0c 9b       	mov	r11,r6
80007b3e:	1a d8       	st.w	--sp,r8
80007b40:	fa c8 fb b4 	sub	r8,sp,-1100
80007b44:	04 9a       	mov	r10,r2
80007b46:	1a d8       	st.w	--sp,r8
80007b48:	08 9c       	mov	r12,r4
80007b4a:	fa c8 f9 40 	sub	r8,sp,-1728
80007b4e:	fa c9 ff b4 	sub	r9,sp,-76
80007b52:	fe b0 fb 01 	rcall	80007154 <get_arg>
80007b56:	2f dd       	sub	sp,-12
80007b58:	78 0b       	ld.w	r11,r12[0x0]
80007b5a:	c2 48       	rjmp	80007ba2 <_vfprintf_r+0x71e>
80007b5c:	ee ca ff ff 	sub	r10,r7,-1
80007b60:	10 37       	cp.w	r7,r8
80007b62:	c0 94       	brge	80007b74 <_vfprintf_r+0x6f0>
80007b64:	fa c9 f9 44 	sub	r9,sp,-1724
80007b68:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007b6c:	14 97       	mov	r7,r10
80007b6e:	ec fb fd 88 	ld.w	r11,r6[-632]
80007b72:	c1 88       	rjmp	80007ba2 <_vfprintf_r+0x71e>
80007b74:	41 09       	lddsp	r9,sp[0x40]
80007b76:	59 f8       	cp.w	r8,31
80007b78:	e0 89 00 11 	brgt	80007b9a <_vfprintf_r+0x716>
80007b7c:	f2 cb ff fc 	sub	r11,r9,-4
80007b80:	51 0b       	stdsp	sp[0x40],r11
80007b82:	fa c6 f9 44 	sub	r6,sp,-1724
80007b86:	72 0b       	ld.w	r11,r9[0x0]
80007b88:	ec 08 00 39 	add	r9,r6,r8<<0x3
80007b8c:	f3 4b fd 88 	st.w	r9[-632],r11
80007b90:	2f f8       	sub	r8,-1
80007b92:	14 97       	mov	r7,r10
80007b94:	fb 48 06 b4 	st.w	sp[1716],r8
80007b98:	c0 58       	rjmp	80007ba2 <_vfprintf_r+0x71e>
80007b9a:	72 0b       	ld.w	r11,r9[0x0]
80007b9c:	14 97       	mov	r7,r10
80007b9e:	2f c9       	sub	r9,-4
80007ba0:	51 09       	stdsp	sp[0x40],r9
80007ba2:	50 1b       	stdsp	sp[0x4],r11
80007ba4:	bf 5b       	asr	r11,0x1f
80007ba6:	50 0b       	stdsp	sp[0x0],r11
80007ba8:	fa ea 00 00 	ld.d	r10,sp[0]
80007bac:	58 0a       	cp.w	r10,0
80007bae:	5c 2b       	cpc	r11
80007bb0:	c0 e4       	brge	80007bcc <_vfprintf_r+0x748>
80007bb2:	30 08       	mov	r8,0
80007bb4:	fa ea 00 00 	ld.d	r10,sp[0]
80007bb8:	30 09       	mov	r9,0
80007bba:	f0 0a 01 0a 	sub	r10,r8,r10
80007bbe:	f2 0b 01 4b 	sbc	r11,r9,r11
80007bc2:	32 d8       	mov	r8,45
80007bc4:	fa eb 00 00 	st.d	sp[0],r10
80007bc8:	fb 68 06 bb 	st.b	sp[1723],r8
80007bcc:	30 18       	mov	r8,1
80007bce:	e0 8f 06 fa 	bral	800089c2 <_vfprintf_r+0x153e>
80007bd2:	50 a7       	stdsp	sp[0x28],r7
80007bd4:	50 80       	stdsp	sp[0x20],r0
80007bd6:	0c 97       	mov	r7,r6
80007bd8:	04 94       	mov	r4,r2
80007bda:	06 96       	mov	r6,r3
80007bdc:	02 92       	mov	r2,r1
80007bde:	40 93       	lddsp	r3,sp[0x24]
80007be0:	10 90       	mov	r0,r8
80007be2:	40 41       	lddsp	r1,sp[0x10]
80007be4:	0e 99       	mov	r9,r7
80007be6:	ed b5 00 03 	bld	r5,0x3
80007bea:	c4 11       	brne	80007c6c <_vfprintf_r+0x7e8>
80007bec:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007bf0:	40 3a       	lddsp	r10,sp[0xc]
80007bf2:	58 0a       	cp.w	r10,0
80007bf4:	c1 90       	breq	80007c26 <_vfprintf_r+0x7a2>
80007bf6:	10 36       	cp.w	r6,r8
80007bf8:	c6 45       	brlt	80007cc0 <_vfprintf_r+0x83c>
80007bfa:	fa c8 f9 50 	sub	r8,sp,-1712
80007bfe:	1a d8       	st.w	--sp,r8
80007c00:	fa c8 fa b8 	sub	r8,sp,-1352
80007c04:	1a d8       	st.w	--sp,r8
80007c06:	fa c8 fb b4 	sub	r8,sp,-1100
80007c0a:	0c 9b       	mov	r11,r6
80007c0c:	1a d8       	st.w	--sp,r8
80007c0e:	04 9a       	mov	r10,r2
80007c10:	fa c8 f9 40 	sub	r8,sp,-1728
80007c14:	fa c9 ff b4 	sub	r9,sp,-76
80007c18:	08 9c       	mov	r12,r4
80007c1a:	fe b0 fa 9d 	rcall	80007154 <get_arg>
80007c1e:	2f dd       	sub	sp,-12
80007c20:	78 16       	ld.w	r6,r12[0x4]
80007c22:	50 76       	stdsp	sp[0x1c],r6
80007c24:	c4 88       	rjmp	80007cb4 <_vfprintf_r+0x830>
80007c26:	2f f7       	sub	r7,-1
80007c28:	10 39       	cp.w	r9,r8
80007c2a:	c0 c4       	brge	80007c42 <_vfprintf_r+0x7be>
80007c2c:	fa ce f9 44 	sub	lr,sp,-1724
80007c30:	fc 06 00 36 	add	r6,lr,r6<<0x3
80007c34:	ec fc fd 8c 	ld.w	r12,r6[-628]
80007c38:	50 7c       	stdsp	sp[0x1c],r12
80007c3a:	ec f6 fd 88 	ld.w	r6,r6[-632]
80007c3e:	50 56       	stdsp	sp[0x14],r6
80007c40:	c6 68       	rjmp	80007d0c <_vfprintf_r+0x888>
80007c42:	41 09       	lddsp	r9,sp[0x40]
80007c44:	59 f8       	cp.w	r8,31
80007c46:	e0 89 00 10 	brgt	80007c66 <_vfprintf_r+0x7e2>
80007c4a:	f2 ca ff f8 	sub	r10,r9,-8
80007c4e:	72 1b       	ld.w	r11,r9[0x4]
80007c50:	51 0a       	stdsp	sp[0x40],r10
80007c52:	72 09       	ld.w	r9,r9[0x0]
80007c54:	fa ca f9 44 	sub	r10,sp,-1724
80007c58:	50 7b       	stdsp	sp[0x1c],r11
80007c5a:	50 59       	stdsp	sp[0x14],r9
80007c5c:	f4 08 00 39 	add	r9,r10,r8<<0x3
80007c60:	40 5b       	lddsp	r11,sp[0x14]
80007c62:	40 7a       	lddsp	r10,sp[0x1c]
80007c64:	c4 78       	rjmp	80007cf2 <_vfprintf_r+0x86e>
80007c66:	72 18       	ld.w	r8,r9[0x4]
80007c68:	50 78       	stdsp	sp[0x1c],r8
80007c6a:	c4 c8       	rjmp	80007d02 <_vfprintf_r+0x87e>
80007c6c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007c70:	40 3e       	lddsp	lr,sp[0xc]
80007c72:	58 0e       	cp.w	lr,0
80007c74:	c2 30       	breq	80007cba <_vfprintf_r+0x836>
80007c76:	10 36       	cp.w	r6,r8
80007c78:	c0 94       	brge	80007c8a <_vfprintf_r+0x806>
80007c7a:	fa cc f9 44 	sub	r12,sp,-1724
80007c7e:	f8 06 00 36 	add	r6,r12,r6<<0x3
80007c82:	ec fb fd 8c 	ld.w	r11,r6[-628]
80007c86:	50 7b       	stdsp	sp[0x1c],r11
80007c88:	cd 9b       	rjmp	80007c3a <_vfprintf_r+0x7b6>
80007c8a:	fa c8 f9 50 	sub	r8,sp,-1712
80007c8e:	1a d8       	st.w	--sp,r8
80007c90:	fa c8 fa b8 	sub	r8,sp,-1352
80007c94:	04 9a       	mov	r10,r2
80007c96:	1a d8       	st.w	--sp,r8
80007c98:	fa c8 fb b4 	sub	r8,sp,-1100
80007c9c:	0c 9b       	mov	r11,r6
80007c9e:	1a d8       	st.w	--sp,r8
80007ca0:	08 9c       	mov	r12,r4
80007ca2:	fa c8 f9 40 	sub	r8,sp,-1728
80007ca6:	fa c9 ff b4 	sub	r9,sp,-76
80007caa:	fe b0 fa 55 	rcall	80007154 <get_arg>
80007cae:	2f dd       	sub	sp,-12
80007cb0:	78 1a       	ld.w	r10,r12[0x4]
80007cb2:	50 7a       	stdsp	sp[0x1c],r10
80007cb4:	78 0c       	ld.w	r12,r12[0x0]
80007cb6:	50 5c       	stdsp	sp[0x14],r12
80007cb8:	c2 a8       	rjmp	80007d0c <_vfprintf_r+0x888>
80007cba:	2f f7       	sub	r7,-1
80007cbc:	10 39       	cp.w	r9,r8
80007cbe:	c0 94       	brge	80007cd0 <_vfprintf_r+0x84c>
80007cc0:	fa c9 f9 44 	sub	r9,sp,-1724
80007cc4:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007cc8:	ec f8 fd 8c 	ld.w	r8,r6[-628]
80007ccc:	50 78       	stdsp	sp[0x1c],r8
80007cce:	cb 6b       	rjmp	80007c3a <_vfprintf_r+0x7b6>
80007cd0:	41 09       	lddsp	r9,sp[0x40]
80007cd2:	59 f8       	cp.w	r8,31
80007cd4:	e0 89 00 15 	brgt	80007cfe <_vfprintf_r+0x87a>
80007cd8:	f2 ca ff f8 	sub	r10,r9,-8
80007cdc:	72 16       	ld.w	r6,r9[0x4]
80007cde:	72 09       	ld.w	r9,r9[0x0]
80007ce0:	51 0a       	stdsp	sp[0x40],r10
80007ce2:	50 59       	stdsp	sp[0x14],r9
80007ce4:	fa ce f9 44 	sub	lr,sp,-1724
80007ce8:	50 76       	stdsp	sp[0x1c],r6
80007cea:	fc 08 00 39 	add	r9,lr,r8<<0x3
80007cee:	40 5b       	lddsp	r11,sp[0x14]
80007cf0:	0c 9a       	mov	r10,r6
80007cf2:	f2 eb fd 88 	st.d	r9[-632],r10
80007cf6:	2f f8       	sub	r8,-1
80007cf8:	fb 48 06 b4 	st.w	sp[1716],r8
80007cfc:	c0 88       	rjmp	80007d0c <_vfprintf_r+0x888>
80007cfe:	72 1c       	ld.w	r12,r9[0x4]
80007d00:	50 7c       	stdsp	sp[0x1c],r12
80007d02:	f2 c8 ff f8 	sub	r8,r9,-8
80007d06:	51 08       	stdsp	sp[0x40],r8
80007d08:	72 09       	ld.w	r9,r9[0x0]
80007d0a:	50 59       	stdsp	sp[0x14],r9
80007d0c:	40 5b       	lddsp	r11,sp[0x14]
80007d0e:	40 7a       	lddsp	r10,sp[0x1c]
80007d10:	e0 a0 19 54 	rcall	8000afb8 <__isinfd>
80007d14:	18 96       	mov	r6,r12
80007d16:	c1 70       	breq	80007d44 <_vfprintf_r+0x8c0>
80007d18:	30 08       	mov	r8,0
80007d1a:	30 09       	mov	r9,0
80007d1c:	40 5b       	lddsp	r11,sp[0x14]
80007d1e:	40 7a       	lddsp	r10,sp[0x1c]
80007d20:	e0 a0 1d a8 	rcall	8000b870 <__avr32_f64_cmp_lt>
80007d24:	c0 40       	breq	80007d2c <_vfprintf_r+0x8a8>
80007d26:	32 d8       	mov	r8,45
80007d28:	fb 68 06 bb 	st.b	sp[1723],r8
80007d2c:	fe c8 aa ec 	sub	r8,pc,-21780
80007d30:	fe c6 aa ec 	sub	r6,pc,-21780
80007d34:	a7 d5       	cbr	r5,0x7
80007d36:	e0 40 00 47 	cp.w	r0,71
80007d3a:	f0 06 17 a0 	movle	r6,r8
80007d3e:	30 32       	mov	r2,3
80007d40:	e0 8f 06 ce 	bral	80008adc <_vfprintf_r+0x1658>
80007d44:	40 5b       	lddsp	r11,sp[0x14]
80007d46:	40 7a       	lddsp	r10,sp[0x1c]
80007d48:	e0 a0 19 4d 	rcall	8000afe2 <__isnand>
80007d4c:	c0 e0       	breq	80007d68 <_vfprintf_r+0x8e4>
80007d4e:	50 26       	stdsp	sp[0x8],r6
80007d50:	fe c8 ab 08 	sub	r8,pc,-21752
80007d54:	fe c6 ab 08 	sub	r6,pc,-21752
80007d58:	a7 d5       	cbr	r5,0x7
80007d5a:	e0 40 00 47 	cp.w	r0,71
80007d5e:	f0 06 17 a0 	movle	r6,r8
80007d62:	30 32       	mov	r2,3
80007d64:	e0 8f 06 c2 	bral	80008ae8 <_vfprintf_r+0x1664>
80007d68:	40 2a       	lddsp	r10,sp[0x8]
80007d6a:	5b fa       	cp.w	r10,-1
80007d6c:	c0 41       	brne	80007d74 <_vfprintf_r+0x8f0>
80007d6e:	30 69       	mov	r9,6
80007d70:	50 29       	stdsp	sp[0x8],r9
80007d72:	c1 18       	rjmp	80007d94 <_vfprintf_r+0x910>
80007d74:	e0 40 00 47 	cp.w	r0,71
80007d78:	5f 09       	sreq	r9
80007d7a:	e0 40 00 67 	cp.w	r0,103
80007d7e:	5f 08       	sreq	r8
80007d80:	f3 e8 10 08 	or	r8,r9,r8
80007d84:	f8 08 18 00 	cp.b	r8,r12
80007d88:	c0 60       	breq	80007d94 <_vfprintf_r+0x910>
80007d8a:	40 28       	lddsp	r8,sp[0x8]
80007d8c:	58 08       	cp.w	r8,0
80007d8e:	f9 b8 00 01 	moveq	r8,1
80007d92:	50 28       	stdsp	sp[0x8],r8
80007d94:	40 78       	lddsp	r8,sp[0x1c]
80007d96:	40 59       	lddsp	r9,sp[0x14]
80007d98:	fa e9 06 94 	st.d	sp[1684],r8
80007d9c:	a9 a5       	sbr	r5,0x8
80007d9e:	fa f8 06 94 	ld.w	r8,sp[1684]
80007da2:	58 08       	cp.w	r8,0
80007da4:	c0 65       	brlt	80007db0 <_vfprintf_r+0x92c>
80007da6:	40 5e       	lddsp	lr,sp[0x14]
80007da8:	30 0c       	mov	r12,0
80007daa:	50 6e       	stdsp	sp[0x18],lr
80007dac:	50 9c       	stdsp	sp[0x24],r12
80007dae:	c0 78       	rjmp	80007dbc <_vfprintf_r+0x938>
80007db0:	40 5b       	lddsp	r11,sp[0x14]
80007db2:	32 da       	mov	r10,45
80007db4:	ee 1b 80 00 	eorh	r11,0x8000
80007db8:	50 9a       	stdsp	sp[0x24],r10
80007dba:	50 6b       	stdsp	sp[0x18],r11
80007dbc:	e0 40 00 46 	cp.w	r0,70
80007dc0:	5f 09       	sreq	r9
80007dc2:	e0 40 00 66 	cp.w	r0,102
80007dc6:	5f 08       	sreq	r8
80007dc8:	f3 e8 10 08 	or	r8,r9,r8
80007dcc:	50 48       	stdsp	sp[0x10],r8
80007dce:	c0 40       	breq	80007dd6 <_vfprintf_r+0x952>
80007dd0:	40 22       	lddsp	r2,sp[0x8]
80007dd2:	30 39       	mov	r9,3
80007dd4:	c1 08       	rjmp	80007df4 <_vfprintf_r+0x970>
80007dd6:	e0 40 00 45 	cp.w	r0,69
80007dda:	5f 09       	sreq	r9
80007ddc:	e0 40 00 65 	cp.w	r0,101
80007de0:	5f 08       	sreq	r8
80007de2:	40 22       	lddsp	r2,sp[0x8]
80007de4:	10 49       	or	r9,r8
80007de6:	2f f2       	sub	r2,-1
80007de8:	40 46       	lddsp	r6,sp[0x10]
80007dea:	ec 09 18 00 	cp.b	r9,r6
80007dee:	fb f2 00 02 	ld.weq	r2,sp[0x8]
80007df2:	30 29       	mov	r9,2
80007df4:	fa c8 f9 5c 	sub	r8,sp,-1700
80007df8:	1a d8       	st.w	--sp,r8
80007dfa:	fa c8 f9 54 	sub	r8,sp,-1708
80007dfe:	1a d8       	st.w	--sp,r8
80007e00:	fa c8 f9 4c 	sub	r8,sp,-1716
80007e04:	08 9c       	mov	r12,r4
80007e06:	1a d8       	st.w	--sp,r8
80007e08:	04 98       	mov	r8,r2
80007e0a:	40 9b       	lddsp	r11,sp[0x24]
80007e0c:	40 aa       	lddsp	r10,sp[0x28]
80007e0e:	e0 a0 0b c3 	rcall	80009594 <_dtoa_r>
80007e12:	e0 40 00 47 	cp.w	r0,71
80007e16:	5f 19       	srne	r9
80007e18:	e0 40 00 67 	cp.w	r0,103
80007e1c:	5f 18       	srne	r8
80007e1e:	18 96       	mov	r6,r12
80007e20:	2f dd       	sub	sp,-12
80007e22:	f3 e8 00 08 	and	r8,r9,r8
80007e26:	c0 41       	brne	80007e2e <_vfprintf_r+0x9aa>
80007e28:	ed b5 00 00 	bld	r5,0x0
80007e2c:	c3 01       	brne	80007e8c <_vfprintf_r+0xa08>
80007e2e:	ec 02 00 0e 	add	lr,r6,r2
80007e32:	50 3e       	stdsp	sp[0xc],lr
80007e34:	40 4c       	lddsp	r12,sp[0x10]
80007e36:	58 0c       	cp.w	r12,0
80007e38:	c1 50       	breq	80007e62 <_vfprintf_r+0x9de>
80007e3a:	0d 89       	ld.ub	r9,r6[0x0]
80007e3c:	33 08       	mov	r8,48
80007e3e:	f0 09 18 00 	cp.b	r9,r8
80007e42:	c0 b1       	brne	80007e58 <_vfprintf_r+0x9d4>
80007e44:	30 08       	mov	r8,0
80007e46:	30 09       	mov	r9,0
80007e48:	40 6b       	lddsp	r11,sp[0x18]
80007e4a:	40 7a       	lddsp	r10,sp[0x1c]
80007e4c:	e0 a0 1c cb 	rcall	8000b7e2 <__avr32_f64_cmp_eq>
80007e50:	fb b2 00 01 	rsubeq	r2,1
80007e54:	fb f2 0b ab 	st.weq	sp[0x6ac],r2
80007e58:	40 3b       	lddsp	r11,sp[0xc]
80007e5a:	fa f8 06 ac 	ld.w	r8,sp[1708]
80007e5e:	10 0b       	add	r11,r8
80007e60:	50 3b       	stdsp	sp[0xc],r11
80007e62:	40 6b       	lddsp	r11,sp[0x18]
80007e64:	30 08       	mov	r8,0
80007e66:	30 09       	mov	r9,0
80007e68:	40 7a       	lddsp	r10,sp[0x1c]
80007e6a:	e0 a0 1c bc 	rcall	8000b7e2 <__avr32_f64_cmp_eq>
80007e6e:	c0 90       	breq	80007e80 <_vfprintf_r+0x9fc>
80007e70:	40 3a       	lddsp	r10,sp[0xc]
80007e72:	fb 4a 06 a4 	st.w	sp[1700],r10
80007e76:	c0 58       	rjmp	80007e80 <_vfprintf_r+0x9fc>
80007e78:	10 c9       	st.b	r8++,r9
80007e7a:	fb 48 06 a4 	st.w	sp[1700],r8
80007e7e:	c0 28       	rjmp	80007e82 <_vfprintf_r+0x9fe>
80007e80:	33 09       	mov	r9,48
80007e82:	fa f8 06 a4 	ld.w	r8,sp[1700]
80007e86:	40 3e       	lddsp	lr,sp[0xc]
80007e88:	1c 38       	cp.w	r8,lr
80007e8a:	cf 73       	brcs	80007e78 <_vfprintf_r+0x9f4>
80007e8c:	e0 40 00 47 	cp.w	r0,71
80007e90:	5f 09       	sreq	r9
80007e92:	e0 40 00 67 	cp.w	r0,103
80007e96:	5f 08       	sreq	r8
80007e98:	f3 e8 10 08 	or	r8,r9,r8
80007e9c:	fa f9 06 a4 	ld.w	r9,sp[1700]
80007ea0:	0c 19       	sub	r9,r6
80007ea2:	50 69       	stdsp	sp[0x18],r9
80007ea4:	58 08       	cp.w	r8,0
80007ea6:	c0 b0       	breq	80007ebc <_vfprintf_r+0xa38>
80007ea8:	fa f8 06 ac 	ld.w	r8,sp[1708]
80007eac:	5b d8       	cp.w	r8,-3
80007eae:	c0 55       	brlt	80007eb8 <_vfprintf_r+0xa34>
80007eb0:	40 2c       	lddsp	r12,sp[0x8]
80007eb2:	18 38       	cp.w	r8,r12
80007eb4:	e0 8a 00 6a 	brle	80007f88 <_vfprintf_r+0xb04>
80007eb8:	20 20       	sub	r0,2
80007eba:	c0 58       	rjmp	80007ec4 <_vfprintf_r+0xa40>
80007ebc:	e0 40 00 65 	cp.w	r0,101
80007ec0:	e0 89 00 46 	brgt	80007f4c <_vfprintf_r+0xac8>
80007ec4:	fa fb 06 ac 	ld.w	r11,sp[1708]
80007ec8:	fb 60 06 9c 	st.b	sp[1692],r0
80007ecc:	20 1b       	sub	r11,1
80007ece:	fb 4b 06 ac 	st.w	sp[1708],r11
80007ed2:	c0 47       	brpl	80007eda <_vfprintf_r+0xa56>
80007ed4:	5c 3b       	neg	r11
80007ed6:	32 d8       	mov	r8,45
80007ed8:	c0 28       	rjmp	80007edc <_vfprintf_r+0xa58>
80007eda:	32 b8       	mov	r8,43
80007edc:	fb 68 06 9d 	st.b	sp[1693],r8
80007ee0:	58 9b       	cp.w	r11,9
80007ee2:	e0 8a 00 1d 	brle	80007f1c <_vfprintf_r+0xa98>
80007ee6:	fa c9 fa 35 	sub	r9,sp,-1483
80007eea:	30 aa       	mov	r10,10
80007eec:	12 98       	mov	r8,r9
80007eee:	0e 9c       	mov	r12,r7
80007ef0:	0c 92       	mov	r2,r6
80007ef2:	f6 0a 0c 06 	divs	r6,r11,r10
80007ef6:	0e 9b       	mov	r11,r7
80007ef8:	2d 0b       	sub	r11,-48
80007efa:	10 fb       	st.b	--r8,r11
80007efc:	0c 9b       	mov	r11,r6
80007efe:	58 96       	cp.w	r6,9
80007f00:	fe 99 ff f9 	brgt	80007ef2 <_vfprintf_r+0xa6e>
80007f04:	2d 0b       	sub	r11,-48
80007f06:	18 97       	mov	r7,r12
80007f08:	04 96       	mov	r6,r2
80007f0a:	10 fb       	st.b	--r8,r11
80007f0c:	fa ca f9 62 	sub	r10,sp,-1694
80007f10:	c0 38       	rjmp	80007f16 <_vfprintf_r+0xa92>
80007f12:	11 3b       	ld.ub	r11,r8++
80007f14:	14 cb       	st.b	r10++,r11
80007f16:	12 38       	cp.w	r8,r9
80007f18:	cf d3       	brcs	80007f12 <_vfprintf_r+0xa8e>
80007f1a:	c0 98       	rjmp	80007f2c <_vfprintf_r+0xaa8>
80007f1c:	2d 0b       	sub	r11,-48
80007f1e:	33 08       	mov	r8,48
80007f20:	fb 6b 06 9f 	st.b	sp[1695],r11
80007f24:	fb 68 06 9e 	st.b	sp[1694],r8
80007f28:	fa ca f9 60 	sub	r10,sp,-1696
80007f2c:	fa c8 f9 64 	sub	r8,sp,-1692
80007f30:	f4 08 01 08 	sub	r8,r10,r8
80007f34:	50 e8       	stdsp	sp[0x38],r8
80007f36:	10 92       	mov	r2,r8
80007f38:	40 6b       	lddsp	r11,sp[0x18]
80007f3a:	16 02       	add	r2,r11
80007f3c:	58 1b       	cp.w	r11,1
80007f3e:	e0 89 00 05 	brgt	80007f48 <_vfprintf_r+0xac4>
80007f42:	ed b5 00 00 	bld	r5,0x0
80007f46:	c3 51       	brne	80007fb0 <_vfprintf_r+0xb2c>
80007f48:	2f f2       	sub	r2,-1
80007f4a:	c3 38       	rjmp	80007fb0 <_vfprintf_r+0xb2c>
80007f4c:	e0 40 00 66 	cp.w	r0,102
80007f50:	c1 c1       	brne	80007f88 <_vfprintf_r+0xb04>
80007f52:	fa f2 06 ac 	ld.w	r2,sp[1708]
80007f56:	58 02       	cp.w	r2,0
80007f58:	e0 8a 00 0c 	brle	80007f70 <_vfprintf_r+0xaec>
80007f5c:	40 2a       	lddsp	r10,sp[0x8]
80007f5e:	58 0a       	cp.w	r10,0
80007f60:	c0 41       	brne	80007f68 <_vfprintf_r+0xae4>
80007f62:	ed b5 00 00 	bld	r5,0x0
80007f66:	c2 51       	brne	80007fb0 <_vfprintf_r+0xb2c>
80007f68:	2f f2       	sub	r2,-1
80007f6a:	40 29       	lddsp	r9,sp[0x8]
80007f6c:	12 02       	add	r2,r9
80007f6e:	c0 b8       	rjmp	80007f84 <_vfprintf_r+0xb00>
80007f70:	40 28       	lddsp	r8,sp[0x8]
80007f72:	58 08       	cp.w	r8,0
80007f74:	c0 61       	brne	80007f80 <_vfprintf_r+0xafc>
80007f76:	ed b5 00 00 	bld	r5,0x0
80007f7a:	c0 30       	breq	80007f80 <_vfprintf_r+0xafc>
80007f7c:	30 12       	mov	r2,1
80007f7e:	c1 98       	rjmp	80007fb0 <_vfprintf_r+0xb2c>
80007f80:	40 22       	lddsp	r2,sp[0x8]
80007f82:	2f e2       	sub	r2,-2
80007f84:	36 60       	mov	r0,102
80007f86:	c1 58       	rjmp	80007fb0 <_vfprintf_r+0xb2c>
80007f88:	fa f2 06 ac 	ld.w	r2,sp[1708]
80007f8c:	40 6e       	lddsp	lr,sp[0x18]
80007f8e:	1c 32       	cp.w	r2,lr
80007f90:	c0 65       	brlt	80007f9c <_vfprintf_r+0xb18>
80007f92:	ed b5 00 00 	bld	r5,0x0
80007f96:	f7 b2 00 ff 	subeq	r2,-1
80007f9a:	c0 a8       	rjmp	80007fae <_vfprintf_r+0xb2a>
80007f9c:	e4 08 11 02 	rsub	r8,r2,2
80007fa0:	40 6c       	lddsp	r12,sp[0x18]
80007fa2:	58 02       	cp.w	r2,0
80007fa4:	f0 02 17 a0 	movle	r2,r8
80007fa8:	f9 b2 09 01 	movgt	r2,1
80007fac:	18 02       	add	r2,r12
80007fae:	36 70       	mov	r0,103
80007fb0:	40 9b       	lddsp	r11,sp[0x24]
80007fb2:	58 0b       	cp.w	r11,0
80007fb4:	e0 80 05 94 	breq	80008adc <_vfprintf_r+0x1658>
80007fb8:	32 d8       	mov	r8,45
80007fba:	fb 68 06 bb 	st.b	sp[1723],r8
80007fbe:	e0 8f 05 93 	bral	80008ae4 <_vfprintf_r+0x1660>
80007fc2:	50 a7       	stdsp	sp[0x28],r7
80007fc4:	04 94       	mov	r4,r2
80007fc6:	0c 97       	mov	r7,r6
80007fc8:	02 92       	mov	r2,r1
80007fca:	06 96       	mov	r6,r3
80007fcc:	40 41       	lddsp	r1,sp[0x10]
80007fce:	40 93       	lddsp	r3,sp[0x24]
80007fd0:	0e 99       	mov	r9,r7
80007fd2:	ed b5 00 05 	bld	r5,0x5
80007fd6:	c4 81       	brne	80008066 <_vfprintf_r+0xbe2>
80007fd8:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007fdc:	40 3e       	lddsp	lr,sp[0xc]
80007fde:	58 0e       	cp.w	lr,0
80007fe0:	c1 d0       	breq	8000801a <_vfprintf_r+0xb96>
80007fe2:	10 36       	cp.w	r6,r8
80007fe4:	c0 64       	brge	80007ff0 <_vfprintf_r+0xb6c>
80007fe6:	fa cc f9 44 	sub	r12,sp,-1724
80007fea:	f8 06 00 36 	add	r6,r12,r6<<0x3
80007fee:	c1 d8       	rjmp	80008028 <_vfprintf_r+0xba4>
80007ff0:	fa c8 f9 50 	sub	r8,sp,-1712
80007ff4:	1a d8       	st.w	--sp,r8
80007ff6:	fa c8 fa b8 	sub	r8,sp,-1352
80007ffa:	04 9a       	mov	r10,r2
80007ffc:	1a d8       	st.w	--sp,r8
80007ffe:	fa c8 fb b4 	sub	r8,sp,-1100
80008002:	0c 9b       	mov	r11,r6
80008004:	1a d8       	st.w	--sp,r8
80008006:	08 9c       	mov	r12,r4
80008008:	fa c8 f9 40 	sub	r8,sp,-1728
8000800c:	fa c9 ff b4 	sub	r9,sp,-76
80008010:	fe b0 f8 a2 	rcall	80007154 <get_arg>
80008014:	2f dd       	sub	sp,-12
80008016:	78 0a       	ld.w	r10,r12[0x0]
80008018:	c2 08       	rjmp	80008058 <_vfprintf_r+0xbd4>
8000801a:	2f f7       	sub	r7,-1
8000801c:	10 39       	cp.w	r9,r8
8000801e:	c0 84       	brge	8000802e <_vfprintf_r+0xbaa>
80008020:	fa cb f9 44 	sub	r11,sp,-1724
80008024:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008028:	ec fa fd 88 	ld.w	r10,r6[-632]
8000802c:	c1 68       	rjmp	80008058 <_vfprintf_r+0xbd4>
8000802e:	41 09       	lddsp	r9,sp[0x40]
80008030:	59 f8       	cp.w	r8,31
80008032:	e0 89 00 10 	brgt	80008052 <_vfprintf_r+0xbce>
80008036:	f2 ca ff fc 	sub	r10,r9,-4
8000803a:	51 0a       	stdsp	sp[0x40],r10
8000803c:	fa c6 f9 44 	sub	r6,sp,-1724
80008040:	72 0a       	ld.w	r10,r9[0x0]
80008042:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008046:	f3 4a fd 88 	st.w	r9[-632],r10
8000804a:	2f f8       	sub	r8,-1
8000804c:	fb 48 06 b4 	st.w	sp[1716],r8
80008050:	c0 48       	rjmp	80008058 <_vfprintf_r+0xbd4>
80008052:	72 0a       	ld.w	r10,r9[0x0]
80008054:	2f c9       	sub	r9,-4
80008056:	51 09       	stdsp	sp[0x40],r9
80008058:	40 be       	lddsp	lr,sp[0x2c]
8000805a:	1c 98       	mov	r8,lr
8000805c:	95 1e       	st.w	r10[0x4],lr
8000805e:	bf 58       	asr	r8,0x1f
80008060:	95 08       	st.w	r10[0x0],r8
80008062:	fe 9f fa 9f 	bral	800075a0 <_vfprintf_r+0x11c>
80008066:	ed b5 00 04 	bld	r5,0x4
8000806a:	c4 80       	breq	800080fa <_vfprintf_r+0xc76>
8000806c:	e2 15 00 40 	andl	r5,0x40,COH
80008070:	c4 50       	breq	800080fa <_vfprintf_r+0xc76>
80008072:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008076:	40 3c       	lddsp	r12,sp[0xc]
80008078:	58 0c       	cp.w	r12,0
8000807a:	c1 d0       	breq	800080b4 <_vfprintf_r+0xc30>
8000807c:	10 36       	cp.w	r6,r8
8000807e:	c0 64       	brge	8000808a <_vfprintf_r+0xc06>
80008080:	fa cb f9 44 	sub	r11,sp,-1724
80008084:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008088:	c1 d8       	rjmp	800080c2 <_vfprintf_r+0xc3e>
8000808a:	fa c8 f9 50 	sub	r8,sp,-1712
8000808e:	1a d8       	st.w	--sp,r8
80008090:	fa c8 fa b8 	sub	r8,sp,-1352
80008094:	04 9a       	mov	r10,r2
80008096:	1a d8       	st.w	--sp,r8
80008098:	fa c8 fb b4 	sub	r8,sp,-1100
8000809c:	0c 9b       	mov	r11,r6
8000809e:	1a d8       	st.w	--sp,r8
800080a0:	08 9c       	mov	r12,r4
800080a2:	fa c8 f9 40 	sub	r8,sp,-1728
800080a6:	fa c9 ff b4 	sub	r9,sp,-76
800080aa:	fe b0 f8 55 	rcall	80007154 <get_arg>
800080ae:	2f dd       	sub	sp,-12
800080b0:	78 0a       	ld.w	r10,r12[0x0]
800080b2:	c2 08       	rjmp	800080f2 <_vfprintf_r+0xc6e>
800080b4:	2f f7       	sub	r7,-1
800080b6:	10 39       	cp.w	r9,r8
800080b8:	c0 84       	brge	800080c8 <_vfprintf_r+0xc44>
800080ba:	fa ca f9 44 	sub	r10,sp,-1724
800080be:	f4 06 00 36 	add	r6,r10,r6<<0x3
800080c2:	ec fa fd 88 	ld.w	r10,r6[-632]
800080c6:	c1 68       	rjmp	800080f2 <_vfprintf_r+0xc6e>
800080c8:	41 09       	lddsp	r9,sp[0x40]
800080ca:	59 f8       	cp.w	r8,31
800080cc:	e0 89 00 10 	brgt	800080ec <_vfprintf_r+0xc68>
800080d0:	f2 ca ff fc 	sub	r10,r9,-4
800080d4:	51 0a       	stdsp	sp[0x40],r10
800080d6:	fa c6 f9 44 	sub	r6,sp,-1724
800080da:	72 0a       	ld.w	r10,r9[0x0]
800080dc:	ec 08 00 39 	add	r9,r6,r8<<0x3
800080e0:	f3 4a fd 88 	st.w	r9[-632],r10
800080e4:	2f f8       	sub	r8,-1
800080e6:	fb 48 06 b4 	st.w	sp[1716],r8
800080ea:	c0 48       	rjmp	800080f2 <_vfprintf_r+0xc6e>
800080ec:	72 0a       	ld.w	r10,r9[0x0]
800080ee:	2f c9       	sub	r9,-4
800080f0:	51 09       	stdsp	sp[0x40],r9
800080f2:	40 be       	lddsp	lr,sp[0x2c]
800080f4:	b4 0e       	st.h	r10[0x0],lr
800080f6:	fe 9f fa 55 	bral	800075a0 <_vfprintf_r+0x11c>
800080fa:	fa f8 06 b4 	ld.w	r8,sp[1716]
800080fe:	40 3c       	lddsp	r12,sp[0xc]
80008100:	58 0c       	cp.w	r12,0
80008102:	c1 d0       	breq	8000813c <_vfprintf_r+0xcb8>
80008104:	10 36       	cp.w	r6,r8
80008106:	c0 64       	brge	80008112 <_vfprintf_r+0xc8e>
80008108:	fa cb f9 44 	sub	r11,sp,-1724
8000810c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008110:	c1 d8       	rjmp	8000814a <_vfprintf_r+0xcc6>
80008112:	fa c8 f9 50 	sub	r8,sp,-1712
80008116:	1a d8       	st.w	--sp,r8
80008118:	fa c8 fa b8 	sub	r8,sp,-1352
8000811c:	04 9a       	mov	r10,r2
8000811e:	1a d8       	st.w	--sp,r8
80008120:	fa c8 fb b4 	sub	r8,sp,-1100
80008124:	0c 9b       	mov	r11,r6
80008126:	1a d8       	st.w	--sp,r8
80008128:	08 9c       	mov	r12,r4
8000812a:	fa c8 f9 40 	sub	r8,sp,-1728
8000812e:	fa c9 ff b4 	sub	r9,sp,-76
80008132:	fe b0 f8 11 	rcall	80007154 <get_arg>
80008136:	2f dd       	sub	sp,-12
80008138:	78 0a       	ld.w	r10,r12[0x0]
8000813a:	c2 08       	rjmp	8000817a <_vfprintf_r+0xcf6>
8000813c:	2f f7       	sub	r7,-1
8000813e:	10 39       	cp.w	r9,r8
80008140:	c0 84       	brge	80008150 <_vfprintf_r+0xccc>
80008142:	fa ca f9 44 	sub	r10,sp,-1724
80008146:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000814a:	ec fa fd 88 	ld.w	r10,r6[-632]
8000814e:	c1 68       	rjmp	8000817a <_vfprintf_r+0xcf6>
80008150:	41 09       	lddsp	r9,sp[0x40]
80008152:	59 f8       	cp.w	r8,31
80008154:	e0 89 00 10 	brgt	80008174 <_vfprintf_r+0xcf0>
80008158:	f2 ca ff fc 	sub	r10,r9,-4
8000815c:	51 0a       	stdsp	sp[0x40],r10
8000815e:	fa c6 f9 44 	sub	r6,sp,-1724
80008162:	72 0a       	ld.w	r10,r9[0x0]
80008164:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008168:	f3 4a fd 88 	st.w	r9[-632],r10
8000816c:	2f f8       	sub	r8,-1
8000816e:	fb 48 06 b4 	st.w	sp[1716],r8
80008172:	c0 48       	rjmp	8000817a <_vfprintf_r+0xcf6>
80008174:	72 0a       	ld.w	r10,r9[0x0]
80008176:	2f c9       	sub	r9,-4
80008178:	51 09       	stdsp	sp[0x40],r9
8000817a:	40 be       	lddsp	lr,sp[0x2c]
8000817c:	95 0e       	st.w	r10[0x0],lr
8000817e:	fe 9f fa 11 	bral	800075a0 <_vfprintf_r+0x11c>
80008182:	50 a7       	stdsp	sp[0x28],r7
80008184:	50 80       	stdsp	sp[0x20],r0
80008186:	0c 97       	mov	r7,r6
80008188:	04 94       	mov	r4,r2
8000818a:	06 96       	mov	r6,r3
8000818c:	02 92       	mov	r2,r1
8000818e:	40 93       	lddsp	r3,sp[0x24]
80008190:	10 90       	mov	r0,r8
80008192:	40 41       	lddsp	r1,sp[0x10]
80008194:	a5 a5       	sbr	r5,0x4
80008196:	c0 a8       	rjmp	800081aa <_vfprintf_r+0xd26>
80008198:	50 a7       	stdsp	sp[0x28],r7
8000819a:	50 80       	stdsp	sp[0x20],r0
8000819c:	0c 97       	mov	r7,r6
8000819e:	04 94       	mov	r4,r2
800081a0:	06 96       	mov	r6,r3
800081a2:	02 92       	mov	r2,r1
800081a4:	40 93       	lddsp	r3,sp[0x24]
800081a6:	10 90       	mov	r0,r8
800081a8:	40 41       	lddsp	r1,sp[0x10]
800081aa:	ed b5 00 05 	bld	r5,0x5
800081ae:	c5 d1       	brne	80008268 <_vfprintf_r+0xde4>
800081b0:	fa f8 06 b4 	ld.w	r8,sp[1716]
800081b4:	40 3c       	lddsp	r12,sp[0xc]
800081b6:	58 0c       	cp.w	r12,0
800081b8:	c2 60       	breq	80008204 <_vfprintf_r+0xd80>
800081ba:	10 36       	cp.w	r6,r8
800081bc:	c0 a4       	brge	800081d0 <_vfprintf_r+0xd4c>
800081be:	fa cb f9 44 	sub	r11,sp,-1724
800081c2:	f6 06 00 36 	add	r6,r11,r6<<0x3
800081c6:	ec e8 fd 88 	ld.d	r8,r6[-632]
800081ca:	fa e9 00 00 	st.d	sp[0],r8
800081ce:	c1 88       	rjmp	800081fe <_vfprintf_r+0xd7a>
800081d0:	fa c8 f9 50 	sub	r8,sp,-1712
800081d4:	1a d8       	st.w	--sp,r8
800081d6:	fa c8 fa b8 	sub	r8,sp,-1352
800081da:	04 9a       	mov	r10,r2
800081dc:	1a d8       	st.w	--sp,r8
800081de:	0c 9b       	mov	r11,r6
800081e0:	fa c8 fb b4 	sub	r8,sp,-1100
800081e4:	08 9c       	mov	r12,r4
800081e6:	1a d8       	st.w	--sp,r8
800081e8:	fa c8 f9 40 	sub	r8,sp,-1728
800081ec:	fa c9 ff b4 	sub	r9,sp,-76
800081f0:	fe b0 f7 b2 	rcall	80007154 <get_arg>
800081f4:	2f dd       	sub	sp,-12
800081f6:	f8 ea 00 00 	ld.d	r10,r12[0]
800081fa:	fa eb 00 00 	st.d	sp[0],r10
800081fe:	30 08       	mov	r8,0
80008200:	e0 8f 03 de 	bral	800089bc <_vfprintf_r+0x1538>
80008204:	ee ca ff ff 	sub	r10,r7,-1
80008208:	10 37       	cp.w	r7,r8
8000820a:	c0 b4       	brge	80008220 <_vfprintf_r+0xd9c>
8000820c:	fa c9 f9 44 	sub	r9,sp,-1724
80008210:	14 97       	mov	r7,r10
80008212:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008216:	ec ea fd 88 	ld.d	r10,r6[-632]
8000821a:	fa eb 00 00 	st.d	sp[0],r10
8000821e:	c1 88       	rjmp	8000824e <_vfprintf_r+0xdca>
80008220:	41 09       	lddsp	r9,sp[0x40]
80008222:	59 f8       	cp.w	r8,31
80008224:	e0 89 00 18 	brgt	80008254 <_vfprintf_r+0xdd0>
80008228:	f2 e6 00 00 	ld.d	r6,r9[0]
8000822c:	f2 cb ff f8 	sub	r11,r9,-8
80008230:	fa e7 00 00 	st.d	sp[0],r6
80008234:	51 0b       	stdsp	sp[0x40],r11
80008236:	fa c6 f9 44 	sub	r6,sp,-1724
8000823a:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000823e:	fa e6 00 00 	ld.d	r6,sp[0]
80008242:	f2 e7 fd 88 	st.d	r9[-632],r6
80008246:	2f f8       	sub	r8,-1
80008248:	14 97       	mov	r7,r10
8000824a:	fb 48 06 b4 	st.w	sp[1716],r8
8000824e:	40 38       	lddsp	r8,sp[0xc]
80008250:	e0 8f 03 b6 	bral	800089bc <_vfprintf_r+0x1538>
80008254:	f2 e6 00 00 	ld.d	r6,r9[0]
80008258:	40 38       	lddsp	r8,sp[0xc]
8000825a:	fa e7 00 00 	st.d	sp[0],r6
8000825e:	2f 89       	sub	r9,-8
80008260:	14 97       	mov	r7,r10
80008262:	51 09       	stdsp	sp[0x40],r9
80008264:	e0 8f 03 ac 	bral	800089bc <_vfprintf_r+0x1538>
80008268:	ed b5 00 04 	bld	r5,0x4
8000826c:	c1 61       	brne	80008298 <_vfprintf_r+0xe14>
8000826e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008272:	40 3e       	lddsp	lr,sp[0xc]
80008274:	58 0e       	cp.w	lr,0
80008276:	c0 80       	breq	80008286 <_vfprintf_r+0xe02>
80008278:	10 36       	cp.w	r6,r8
8000827a:	c6 74       	brge	80008348 <_vfprintf_r+0xec4>
8000827c:	fa cc f9 44 	sub	r12,sp,-1724
80008280:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008284:	c8 08       	rjmp	80008384 <_vfprintf_r+0xf00>
80008286:	ee ca ff ff 	sub	r10,r7,-1
8000828a:	10 37       	cp.w	r7,r8
8000828c:	c7 f4       	brge	8000838a <_vfprintf_r+0xf06>
8000828e:	fa cb f9 44 	sub	r11,sp,-1724
80008292:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008296:	c7 68       	rjmp	80008382 <_vfprintf_r+0xefe>
80008298:	ed b5 00 06 	bld	r5,0x6
8000829c:	c4 a1       	brne	80008330 <_vfprintf_r+0xeac>
8000829e:	fa f8 06 b4 	ld.w	r8,sp[1716]
800082a2:	40 3c       	lddsp	r12,sp[0xc]
800082a4:	58 0c       	cp.w	r12,0
800082a6:	c1 d0       	breq	800082e0 <_vfprintf_r+0xe5c>
800082a8:	10 36       	cp.w	r6,r8
800082aa:	c0 64       	brge	800082b6 <_vfprintf_r+0xe32>
800082ac:	fa cb f9 44 	sub	r11,sp,-1724
800082b0:	f6 06 00 36 	add	r6,r11,r6<<0x3
800082b4:	c1 f8       	rjmp	800082f2 <_vfprintf_r+0xe6e>
800082b6:	fa c8 f9 50 	sub	r8,sp,-1712
800082ba:	1a d8       	st.w	--sp,r8
800082bc:	fa c8 fa b8 	sub	r8,sp,-1352
800082c0:	1a d8       	st.w	--sp,r8
800082c2:	fa c8 fb b4 	sub	r8,sp,-1100
800082c6:	1a d8       	st.w	--sp,r8
800082c8:	fa c8 f9 40 	sub	r8,sp,-1728
800082cc:	fa c9 ff b4 	sub	r9,sp,-76
800082d0:	04 9a       	mov	r10,r2
800082d2:	0c 9b       	mov	r11,r6
800082d4:	08 9c       	mov	r12,r4
800082d6:	fe b0 f7 3f 	rcall	80007154 <get_arg>
800082da:	2f dd       	sub	sp,-12
800082dc:	98 18       	ld.sh	r8,r12[0x2]
800082de:	c2 68       	rjmp	8000832a <_vfprintf_r+0xea6>
800082e0:	ee ca ff ff 	sub	r10,r7,-1
800082e4:	10 37       	cp.w	r7,r8
800082e6:	c0 94       	brge	800082f8 <_vfprintf_r+0xe74>
800082e8:	fa c9 f9 44 	sub	r9,sp,-1724
800082ec:	14 97       	mov	r7,r10
800082ee:	f2 06 00 36 	add	r6,r9,r6<<0x3
800082f2:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
800082f6:	c1 a8       	rjmp	8000832a <_vfprintf_r+0xea6>
800082f8:	41 09       	lddsp	r9,sp[0x40]
800082fa:	59 f8       	cp.w	r8,31
800082fc:	e0 89 00 13 	brgt	80008322 <_vfprintf_r+0xe9e>
80008300:	f2 cb ff fc 	sub	r11,r9,-4
80008304:	51 0b       	stdsp	sp[0x40],r11
80008306:	72 09       	ld.w	r9,r9[0x0]
80008308:	fa c6 f9 44 	sub	r6,sp,-1724
8000830c:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008310:	2f f8       	sub	r8,-1
80008312:	f7 49 fd 88 	st.w	r11[-632],r9
80008316:	fb 48 06 b4 	st.w	sp[1716],r8
8000831a:	14 97       	mov	r7,r10
8000831c:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008320:	c0 58       	rjmp	8000832a <_vfprintf_r+0xea6>
80008322:	92 18       	ld.sh	r8,r9[0x2]
80008324:	14 97       	mov	r7,r10
80008326:	2f c9       	sub	r9,-4
80008328:	51 09       	stdsp	sp[0x40],r9
8000832a:	5c 78       	castu.h	r8
8000832c:	50 18       	stdsp	sp[0x4],r8
8000832e:	c4 68       	rjmp	800083ba <_vfprintf_r+0xf36>
80008330:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008334:	40 3c       	lddsp	r12,sp[0xc]
80008336:	58 0c       	cp.w	r12,0
80008338:	c1 d0       	breq	80008372 <_vfprintf_r+0xeee>
8000833a:	10 36       	cp.w	r6,r8
8000833c:	c0 64       	brge	80008348 <_vfprintf_r+0xec4>
8000833e:	fa cb f9 44 	sub	r11,sp,-1724
80008342:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008346:	c1 f8       	rjmp	80008384 <_vfprintf_r+0xf00>
80008348:	fa c8 f9 50 	sub	r8,sp,-1712
8000834c:	1a d8       	st.w	--sp,r8
8000834e:	fa c8 fa b8 	sub	r8,sp,-1352
80008352:	0c 9b       	mov	r11,r6
80008354:	1a d8       	st.w	--sp,r8
80008356:	fa c8 fb b4 	sub	r8,sp,-1100
8000835a:	04 9a       	mov	r10,r2
8000835c:	1a d8       	st.w	--sp,r8
8000835e:	08 9c       	mov	r12,r4
80008360:	fa c8 f9 40 	sub	r8,sp,-1728
80008364:	fa c9 ff b4 	sub	r9,sp,-76
80008368:	fe b0 f6 f6 	rcall	80007154 <get_arg>
8000836c:	2f dd       	sub	sp,-12
8000836e:	78 0b       	ld.w	r11,r12[0x0]
80008370:	c2 48       	rjmp	800083b8 <_vfprintf_r+0xf34>
80008372:	ee ca ff ff 	sub	r10,r7,-1
80008376:	10 37       	cp.w	r7,r8
80008378:	c0 94       	brge	8000838a <_vfprintf_r+0xf06>
8000837a:	fa c9 f9 44 	sub	r9,sp,-1724
8000837e:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008382:	14 97       	mov	r7,r10
80008384:	ec fb fd 88 	ld.w	r11,r6[-632]
80008388:	c1 88       	rjmp	800083b8 <_vfprintf_r+0xf34>
8000838a:	41 09       	lddsp	r9,sp[0x40]
8000838c:	59 f8       	cp.w	r8,31
8000838e:	e0 89 00 11 	brgt	800083b0 <_vfprintf_r+0xf2c>
80008392:	f2 cb ff fc 	sub	r11,r9,-4
80008396:	51 0b       	stdsp	sp[0x40],r11
80008398:	fa c6 f9 44 	sub	r6,sp,-1724
8000839c:	72 0b       	ld.w	r11,r9[0x0]
8000839e:	ec 08 00 39 	add	r9,r6,r8<<0x3
800083a2:	f3 4b fd 88 	st.w	r9[-632],r11
800083a6:	2f f8       	sub	r8,-1
800083a8:	14 97       	mov	r7,r10
800083aa:	fb 48 06 b4 	st.w	sp[1716],r8
800083ae:	c0 58       	rjmp	800083b8 <_vfprintf_r+0xf34>
800083b0:	72 0b       	ld.w	r11,r9[0x0]
800083b2:	14 97       	mov	r7,r10
800083b4:	2f c9       	sub	r9,-4
800083b6:	51 09       	stdsp	sp[0x40],r9
800083b8:	50 1b       	stdsp	sp[0x4],r11
800083ba:	30 0e       	mov	lr,0
800083bc:	50 0e       	stdsp	sp[0x0],lr
800083be:	1c 98       	mov	r8,lr
800083c0:	e0 8f 02 fe 	bral	800089bc <_vfprintf_r+0x1538>
800083c4:	50 a7       	stdsp	sp[0x28],r7
800083c6:	50 80       	stdsp	sp[0x20],r0
800083c8:	0c 97       	mov	r7,r6
800083ca:	04 94       	mov	r4,r2
800083cc:	06 96       	mov	r6,r3
800083ce:	02 92       	mov	r2,r1
800083d0:	40 93       	lddsp	r3,sp[0x24]
800083d2:	40 41       	lddsp	r1,sp[0x10]
800083d4:	0e 99       	mov	r9,r7
800083d6:	fa f8 06 b4 	ld.w	r8,sp[1716]
800083da:	40 3c       	lddsp	r12,sp[0xc]
800083dc:	58 0c       	cp.w	r12,0
800083de:	c1 d0       	breq	80008418 <_vfprintf_r+0xf94>
800083e0:	10 36       	cp.w	r6,r8
800083e2:	c0 64       	brge	800083ee <_vfprintf_r+0xf6a>
800083e4:	fa cb f9 44 	sub	r11,sp,-1724
800083e8:	f6 06 00 36 	add	r6,r11,r6<<0x3
800083ec:	c1 d8       	rjmp	80008426 <_vfprintf_r+0xfa2>
800083ee:	fa c8 f9 50 	sub	r8,sp,-1712
800083f2:	1a d8       	st.w	--sp,r8
800083f4:	fa c8 fa b8 	sub	r8,sp,-1352
800083f8:	1a d8       	st.w	--sp,r8
800083fa:	fa c8 fb b4 	sub	r8,sp,-1100
800083fe:	1a d8       	st.w	--sp,r8
80008400:	fa c9 ff b4 	sub	r9,sp,-76
80008404:	fa c8 f9 40 	sub	r8,sp,-1728
80008408:	04 9a       	mov	r10,r2
8000840a:	0c 9b       	mov	r11,r6
8000840c:	08 9c       	mov	r12,r4
8000840e:	fe b0 f6 a3 	rcall	80007154 <get_arg>
80008412:	2f dd       	sub	sp,-12
80008414:	78 09       	ld.w	r9,r12[0x0]
80008416:	c2 18       	rjmp	80008458 <_vfprintf_r+0xfd4>
80008418:	2f f7       	sub	r7,-1
8000841a:	10 39       	cp.w	r9,r8
8000841c:	c0 84       	brge	8000842c <_vfprintf_r+0xfa8>
8000841e:	fa ca f9 44 	sub	r10,sp,-1724
80008422:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008426:	ec f9 fd 88 	ld.w	r9,r6[-632]
8000842a:	c1 78       	rjmp	80008458 <_vfprintf_r+0xfd4>
8000842c:	41 09       	lddsp	r9,sp[0x40]
8000842e:	59 f8       	cp.w	r8,31
80008430:	e0 89 00 10 	brgt	80008450 <_vfprintf_r+0xfcc>
80008434:	f2 ca ff fc 	sub	r10,r9,-4
80008438:	51 0a       	stdsp	sp[0x40],r10
8000843a:	fa c6 f9 44 	sub	r6,sp,-1724
8000843e:	72 09       	ld.w	r9,r9[0x0]
80008440:	ec 08 00 3a 	add	r10,r6,r8<<0x3
80008444:	f5 49 fd 88 	st.w	r10[-632],r9
80008448:	2f f8       	sub	r8,-1
8000844a:	fb 48 06 b4 	st.w	sp[1716],r8
8000844e:	c0 58       	rjmp	80008458 <_vfprintf_r+0xfd4>
80008450:	f2 c8 ff fc 	sub	r8,r9,-4
80008454:	51 08       	stdsp	sp[0x40],r8
80008456:	72 09       	ld.w	r9,r9[0x0]
80008458:	33 08       	mov	r8,48
8000845a:	fb 68 06 b8 	st.b	sp[1720],r8
8000845e:	37 88       	mov	r8,120
80008460:	30 0e       	mov	lr,0
80008462:	fb 68 06 b9 	st.b	sp[1721],r8
80008466:	fe cc b2 16 	sub	r12,pc,-19946
8000846a:	50 19       	stdsp	sp[0x4],r9
8000846c:	a1 b5       	sbr	r5,0x1
8000846e:	50 0e       	stdsp	sp[0x0],lr
80008470:	50 dc       	stdsp	sp[0x34],r12
80008472:	30 28       	mov	r8,2
80008474:	37 80       	mov	r0,120
80008476:	e0 8f 02 a3 	bral	800089bc <_vfprintf_r+0x1538>
8000847a:	50 a7       	stdsp	sp[0x28],r7
8000847c:	50 80       	stdsp	sp[0x20],r0
8000847e:	10 90       	mov	r0,r8
80008480:	30 08       	mov	r8,0
80008482:	fb 68 06 bb 	st.b	sp[1723],r8
80008486:	0c 97       	mov	r7,r6
80008488:	04 94       	mov	r4,r2
8000848a:	06 96       	mov	r6,r3
8000848c:	02 92       	mov	r2,r1
8000848e:	40 93       	lddsp	r3,sp[0x24]
80008490:	40 41       	lddsp	r1,sp[0x10]
80008492:	0e 99       	mov	r9,r7
80008494:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008498:	40 3b       	lddsp	r11,sp[0xc]
8000849a:	58 0b       	cp.w	r11,0
8000849c:	c1 d0       	breq	800084d6 <_vfprintf_r+0x1052>
8000849e:	10 36       	cp.w	r6,r8
800084a0:	c0 64       	brge	800084ac <_vfprintf_r+0x1028>
800084a2:	fa ca f9 44 	sub	r10,sp,-1724
800084a6:	f4 06 00 36 	add	r6,r10,r6<<0x3
800084aa:	c1 d8       	rjmp	800084e4 <_vfprintf_r+0x1060>
800084ac:	fa c8 f9 50 	sub	r8,sp,-1712
800084b0:	1a d8       	st.w	--sp,r8
800084b2:	fa c8 fa b8 	sub	r8,sp,-1352
800084b6:	1a d8       	st.w	--sp,r8
800084b8:	fa c8 fb b4 	sub	r8,sp,-1100
800084bc:	0c 9b       	mov	r11,r6
800084be:	1a d8       	st.w	--sp,r8
800084c0:	04 9a       	mov	r10,r2
800084c2:	fa c8 f9 40 	sub	r8,sp,-1728
800084c6:	fa c9 ff b4 	sub	r9,sp,-76
800084ca:	08 9c       	mov	r12,r4
800084cc:	fe b0 f6 44 	rcall	80007154 <get_arg>
800084d0:	2f dd       	sub	sp,-12
800084d2:	78 06       	ld.w	r6,r12[0x0]
800084d4:	c2 08       	rjmp	80008514 <_vfprintf_r+0x1090>
800084d6:	2f f7       	sub	r7,-1
800084d8:	10 39       	cp.w	r9,r8
800084da:	c0 84       	brge	800084ea <_vfprintf_r+0x1066>
800084dc:	fa c9 f9 44 	sub	r9,sp,-1724
800084e0:	f2 06 00 36 	add	r6,r9,r6<<0x3
800084e4:	ec f6 fd 88 	ld.w	r6,r6[-632]
800084e8:	c1 68       	rjmp	80008514 <_vfprintf_r+0x1090>
800084ea:	41 09       	lddsp	r9,sp[0x40]
800084ec:	59 f8       	cp.w	r8,31
800084ee:	e0 89 00 10 	brgt	8000850e <_vfprintf_r+0x108a>
800084f2:	f2 ca ff fc 	sub	r10,r9,-4
800084f6:	51 0a       	stdsp	sp[0x40],r10
800084f8:	72 06       	ld.w	r6,r9[0x0]
800084fa:	fa ce f9 44 	sub	lr,sp,-1724
800084fe:	fc 08 00 39 	add	r9,lr,r8<<0x3
80008502:	f3 46 fd 88 	st.w	r9[-632],r6
80008506:	2f f8       	sub	r8,-1
80008508:	fb 48 06 b4 	st.w	sp[1716],r8
8000850c:	c0 48       	rjmp	80008514 <_vfprintf_r+0x1090>
8000850e:	72 06       	ld.w	r6,r9[0x0]
80008510:	2f c9       	sub	r9,-4
80008512:	51 09       	stdsp	sp[0x40],r9
80008514:	40 2c       	lddsp	r12,sp[0x8]
80008516:	58 0c       	cp.w	r12,0
80008518:	c1 05       	brlt	80008538 <_vfprintf_r+0x10b4>
8000851a:	18 9a       	mov	r10,r12
8000851c:	30 0b       	mov	r11,0
8000851e:	0c 9c       	mov	r12,r6
80008520:	e0 a0 12 38 	rcall	8000a990 <memchr>
80008524:	e0 80 02 df 	breq	80008ae2 <_vfprintf_r+0x165e>
80008528:	f8 06 01 02 	sub	r2,r12,r6
8000852c:	40 2b       	lddsp	r11,sp[0x8]
8000852e:	16 32       	cp.w	r2,r11
80008530:	e0 89 02 d9 	brgt	80008ae2 <_vfprintf_r+0x165e>
80008534:	e0 8f 02 d4 	bral	80008adc <_vfprintf_r+0x1658>
80008538:	30 0a       	mov	r10,0
8000853a:	0c 9c       	mov	r12,r6
8000853c:	50 2a       	stdsp	sp[0x8],r10
8000853e:	fe b0 f5 85 	rcall	80007048 <strlen>
80008542:	18 92       	mov	r2,r12
80008544:	e0 8f 02 d2 	bral	80008ae8 <_vfprintf_r+0x1664>
80008548:	50 a7       	stdsp	sp[0x28],r7
8000854a:	50 80       	stdsp	sp[0x20],r0
8000854c:	0c 97       	mov	r7,r6
8000854e:	04 94       	mov	r4,r2
80008550:	06 96       	mov	r6,r3
80008552:	02 92       	mov	r2,r1
80008554:	40 93       	lddsp	r3,sp[0x24]
80008556:	10 90       	mov	r0,r8
80008558:	40 41       	lddsp	r1,sp[0x10]
8000855a:	a5 a5       	sbr	r5,0x4
8000855c:	c0 a8       	rjmp	80008570 <_vfprintf_r+0x10ec>
8000855e:	50 a7       	stdsp	sp[0x28],r7
80008560:	50 80       	stdsp	sp[0x20],r0
80008562:	0c 97       	mov	r7,r6
80008564:	04 94       	mov	r4,r2
80008566:	06 96       	mov	r6,r3
80008568:	02 92       	mov	r2,r1
8000856a:	40 93       	lddsp	r3,sp[0x24]
8000856c:	10 90       	mov	r0,r8
8000856e:	40 41       	lddsp	r1,sp[0x10]
80008570:	ed b5 00 05 	bld	r5,0x5
80008574:	c5 61       	brne	80008620 <_vfprintf_r+0x119c>
80008576:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000857a:	40 39       	lddsp	r9,sp[0xc]
8000857c:	58 09       	cp.w	r9,0
8000857e:	c2 10       	breq	800085c0 <_vfprintf_r+0x113c>
80008580:	10 36       	cp.w	r6,r8
80008582:	c0 74       	brge	80008590 <_vfprintf_r+0x110c>
80008584:	fa c8 f9 44 	sub	r8,sp,-1724
80008588:	f0 06 00 36 	add	r6,r8,r6<<0x3
8000858c:	c2 38       	rjmp	800085d2 <_vfprintf_r+0x114e>
8000858e:	d7 03       	nop
80008590:	fa c8 f9 50 	sub	r8,sp,-1712
80008594:	1a d8       	st.w	--sp,r8
80008596:	fa c8 fa b8 	sub	r8,sp,-1352
8000859a:	1a d8       	st.w	--sp,r8
8000859c:	fa c8 fb b4 	sub	r8,sp,-1100
800085a0:	1a d8       	st.w	--sp,r8
800085a2:	fa c8 f9 40 	sub	r8,sp,-1728
800085a6:	fa c9 ff b4 	sub	r9,sp,-76
800085aa:	04 9a       	mov	r10,r2
800085ac:	0c 9b       	mov	r11,r6
800085ae:	08 9c       	mov	r12,r4
800085b0:	fe b0 f5 d2 	rcall	80007154 <get_arg>
800085b4:	2f dd       	sub	sp,-12
800085b6:	f8 e8 00 00 	ld.d	r8,r12[0]
800085ba:	fa e9 00 00 	st.d	sp[0],r8
800085be:	c2 e8       	rjmp	8000861a <_vfprintf_r+0x1196>
800085c0:	ee ca ff ff 	sub	r10,r7,-1
800085c4:	10 37       	cp.w	r7,r8
800085c6:	c0 b4       	brge	800085dc <_vfprintf_r+0x1158>
800085c8:	fa c8 f9 44 	sub	r8,sp,-1724
800085cc:	14 97       	mov	r7,r10
800085ce:	f0 06 00 36 	add	r6,r8,r6<<0x3
800085d2:	ec ea fd 88 	ld.d	r10,r6[-632]
800085d6:	fa eb 00 00 	st.d	sp[0],r10
800085da:	c2 08       	rjmp	8000861a <_vfprintf_r+0x1196>
800085dc:	41 09       	lddsp	r9,sp[0x40]
800085de:	59 f8       	cp.w	r8,31
800085e0:	e0 89 00 16 	brgt	8000860c <_vfprintf_r+0x1188>
800085e4:	f2 e6 00 00 	ld.d	r6,r9[0]
800085e8:	f2 cb ff f8 	sub	r11,r9,-8
800085ec:	fa e7 00 00 	st.d	sp[0],r6
800085f0:	51 0b       	stdsp	sp[0x40],r11
800085f2:	fa c6 f9 44 	sub	r6,sp,-1724
800085f6:	ec 08 00 39 	add	r9,r6,r8<<0x3
800085fa:	fa e6 00 00 	ld.d	r6,sp[0]
800085fe:	f2 e7 fd 88 	st.d	r9[-632],r6
80008602:	2f f8       	sub	r8,-1
80008604:	14 97       	mov	r7,r10
80008606:	fb 48 06 b4 	st.w	sp[1716],r8
8000860a:	c0 88       	rjmp	8000861a <_vfprintf_r+0x1196>
8000860c:	f2 e6 00 00 	ld.d	r6,r9[0]
80008610:	2f 89       	sub	r9,-8
80008612:	fa e7 00 00 	st.d	sp[0],r6
80008616:	51 09       	stdsp	sp[0x40],r9
80008618:	14 97       	mov	r7,r10
8000861a:	30 18       	mov	r8,1
8000861c:	e0 8f 01 d0 	bral	800089bc <_vfprintf_r+0x1538>
80008620:	ed b5 00 04 	bld	r5,0x4
80008624:	c1 61       	brne	80008650 <_vfprintf_r+0x11cc>
80008626:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000862a:	40 3e       	lddsp	lr,sp[0xc]
8000862c:	58 0e       	cp.w	lr,0
8000862e:	c0 80       	breq	8000863e <_vfprintf_r+0x11ba>
80008630:	10 36       	cp.w	r6,r8
80008632:	c6 74       	brge	80008700 <_vfprintf_r+0x127c>
80008634:	fa cc f9 44 	sub	r12,sp,-1724
80008638:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000863c:	c8 08       	rjmp	8000873c <_vfprintf_r+0x12b8>
8000863e:	ee ca ff ff 	sub	r10,r7,-1
80008642:	10 37       	cp.w	r7,r8
80008644:	c7 f4       	brge	80008742 <_vfprintf_r+0x12be>
80008646:	fa cb f9 44 	sub	r11,sp,-1724
8000864a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000864e:	c7 68       	rjmp	8000873a <_vfprintf_r+0x12b6>
80008650:	ed b5 00 06 	bld	r5,0x6
80008654:	c4 a1       	brne	800086e8 <_vfprintf_r+0x1264>
80008656:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000865a:	40 3c       	lddsp	r12,sp[0xc]
8000865c:	58 0c       	cp.w	r12,0
8000865e:	c1 d0       	breq	80008698 <_vfprintf_r+0x1214>
80008660:	10 36       	cp.w	r6,r8
80008662:	c0 64       	brge	8000866e <_vfprintf_r+0x11ea>
80008664:	fa cb f9 44 	sub	r11,sp,-1724
80008668:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000866c:	c1 f8       	rjmp	800086aa <_vfprintf_r+0x1226>
8000866e:	fa c8 f9 50 	sub	r8,sp,-1712
80008672:	1a d8       	st.w	--sp,r8
80008674:	fa c8 fa b8 	sub	r8,sp,-1352
80008678:	1a d8       	st.w	--sp,r8
8000867a:	fa c8 fb b4 	sub	r8,sp,-1100
8000867e:	1a d8       	st.w	--sp,r8
80008680:	fa c8 f9 40 	sub	r8,sp,-1728
80008684:	fa c9 ff b4 	sub	r9,sp,-76
80008688:	04 9a       	mov	r10,r2
8000868a:	0c 9b       	mov	r11,r6
8000868c:	08 9c       	mov	r12,r4
8000868e:	fe b0 f5 63 	rcall	80007154 <get_arg>
80008692:	2f dd       	sub	sp,-12
80008694:	98 18       	ld.sh	r8,r12[0x2]
80008696:	c2 68       	rjmp	800086e2 <_vfprintf_r+0x125e>
80008698:	ee ca ff ff 	sub	r10,r7,-1
8000869c:	10 37       	cp.w	r7,r8
8000869e:	c0 94       	brge	800086b0 <_vfprintf_r+0x122c>
800086a0:	fa c9 f9 44 	sub	r9,sp,-1724
800086a4:	14 97       	mov	r7,r10
800086a6:	f2 06 00 36 	add	r6,r9,r6<<0x3
800086aa:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
800086ae:	c1 a8       	rjmp	800086e2 <_vfprintf_r+0x125e>
800086b0:	41 09       	lddsp	r9,sp[0x40]
800086b2:	59 f8       	cp.w	r8,31
800086b4:	e0 89 00 13 	brgt	800086da <_vfprintf_r+0x1256>
800086b8:	f2 cb ff fc 	sub	r11,r9,-4
800086bc:	51 0b       	stdsp	sp[0x40],r11
800086be:	72 09       	ld.w	r9,r9[0x0]
800086c0:	fa c6 f9 44 	sub	r6,sp,-1724
800086c4:	ec 08 00 3b 	add	r11,r6,r8<<0x3
800086c8:	2f f8       	sub	r8,-1
800086ca:	f7 49 fd 88 	st.w	r11[-632],r9
800086ce:	fb 48 06 b4 	st.w	sp[1716],r8
800086d2:	14 97       	mov	r7,r10
800086d4:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
800086d8:	c0 58       	rjmp	800086e2 <_vfprintf_r+0x125e>
800086da:	92 18       	ld.sh	r8,r9[0x2]
800086dc:	14 97       	mov	r7,r10
800086de:	2f c9       	sub	r9,-4
800086e0:	51 09       	stdsp	sp[0x40],r9
800086e2:	5c 78       	castu.h	r8
800086e4:	50 18       	stdsp	sp[0x4],r8
800086e6:	c4 68       	rjmp	80008772 <_vfprintf_r+0x12ee>
800086e8:	fa f8 06 b4 	ld.w	r8,sp[1716]
800086ec:	40 3c       	lddsp	r12,sp[0xc]
800086ee:	58 0c       	cp.w	r12,0
800086f0:	c1 d0       	breq	8000872a <_vfprintf_r+0x12a6>
800086f2:	10 36       	cp.w	r6,r8
800086f4:	c0 64       	brge	80008700 <_vfprintf_r+0x127c>
800086f6:	fa cb f9 44 	sub	r11,sp,-1724
800086fa:	f6 06 00 36 	add	r6,r11,r6<<0x3
800086fe:	c1 f8       	rjmp	8000873c <_vfprintf_r+0x12b8>
80008700:	fa c8 f9 50 	sub	r8,sp,-1712
80008704:	1a d8       	st.w	--sp,r8
80008706:	fa c8 fa b8 	sub	r8,sp,-1352
8000870a:	0c 9b       	mov	r11,r6
8000870c:	1a d8       	st.w	--sp,r8
8000870e:	fa c8 fb b4 	sub	r8,sp,-1100
80008712:	04 9a       	mov	r10,r2
80008714:	1a d8       	st.w	--sp,r8
80008716:	08 9c       	mov	r12,r4
80008718:	fa c8 f9 40 	sub	r8,sp,-1728
8000871c:	fa c9 ff b4 	sub	r9,sp,-76
80008720:	fe b0 f5 1a 	rcall	80007154 <get_arg>
80008724:	2f dd       	sub	sp,-12
80008726:	78 0b       	ld.w	r11,r12[0x0]
80008728:	c2 48       	rjmp	80008770 <_vfprintf_r+0x12ec>
8000872a:	ee ca ff ff 	sub	r10,r7,-1
8000872e:	10 37       	cp.w	r7,r8
80008730:	c0 94       	brge	80008742 <_vfprintf_r+0x12be>
80008732:	fa c9 f9 44 	sub	r9,sp,-1724
80008736:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000873a:	14 97       	mov	r7,r10
8000873c:	ec fb fd 88 	ld.w	r11,r6[-632]
80008740:	c1 88       	rjmp	80008770 <_vfprintf_r+0x12ec>
80008742:	41 09       	lddsp	r9,sp[0x40]
80008744:	59 f8       	cp.w	r8,31
80008746:	e0 89 00 11 	brgt	80008768 <_vfprintf_r+0x12e4>
8000874a:	f2 cb ff fc 	sub	r11,r9,-4
8000874e:	51 0b       	stdsp	sp[0x40],r11
80008750:	fa c6 f9 44 	sub	r6,sp,-1724
80008754:	72 0b       	ld.w	r11,r9[0x0]
80008756:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000875a:	f3 4b fd 88 	st.w	r9[-632],r11
8000875e:	2f f8       	sub	r8,-1
80008760:	14 97       	mov	r7,r10
80008762:	fb 48 06 b4 	st.w	sp[1716],r8
80008766:	c0 58       	rjmp	80008770 <_vfprintf_r+0x12ec>
80008768:	72 0b       	ld.w	r11,r9[0x0]
8000876a:	14 97       	mov	r7,r10
8000876c:	2f c9       	sub	r9,-4
8000876e:	51 09       	stdsp	sp[0x40],r9
80008770:	50 1b       	stdsp	sp[0x4],r11
80008772:	30 0e       	mov	lr,0
80008774:	30 18       	mov	r8,1
80008776:	50 0e       	stdsp	sp[0x0],lr
80008778:	c2 29       	rjmp	800089bc <_vfprintf_r+0x1538>
8000877a:	50 a7       	stdsp	sp[0x28],r7
8000877c:	50 80       	stdsp	sp[0x20],r0
8000877e:	0c 97       	mov	r7,r6
80008780:	04 94       	mov	r4,r2
80008782:	06 96       	mov	r6,r3
80008784:	02 92       	mov	r2,r1
80008786:	fe cc b5 36 	sub	r12,pc,-19146
8000878a:	40 93       	lddsp	r3,sp[0x24]
8000878c:	10 90       	mov	r0,r8
8000878e:	40 41       	lddsp	r1,sp[0x10]
80008790:	50 dc       	stdsp	sp[0x34],r12
80008792:	ed b5 00 05 	bld	r5,0x5
80008796:	c5 51       	brne	80008840 <_vfprintf_r+0x13bc>
80008798:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000879c:	40 3b       	lddsp	r11,sp[0xc]
8000879e:	58 0b       	cp.w	r11,0
800087a0:	c2 20       	breq	800087e4 <_vfprintf_r+0x1360>
800087a2:	10 36       	cp.w	r6,r8
800087a4:	c0 a4       	brge	800087b8 <_vfprintf_r+0x1334>
800087a6:	fa ca f9 44 	sub	r10,sp,-1724
800087aa:	f4 06 00 36 	add	r6,r10,r6<<0x3
800087ae:	ec e8 fd 88 	ld.d	r8,r6[-632]
800087b2:	fa e9 00 00 	st.d	sp[0],r8
800087b6:	cf 28       	rjmp	8000899a <_vfprintf_r+0x1516>
800087b8:	fa c8 f9 50 	sub	r8,sp,-1712
800087bc:	1a d8       	st.w	--sp,r8
800087be:	fa c8 fa b8 	sub	r8,sp,-1352
800087c2:	04 9a       	mov	r10,r2
800087c4:	1a d8       	st.w	--sp,r8
800087c6:	0c 9b       	mov	r11,r6
800087c8:	fa c8 fb b4 	sub	r8,sp,-1100
800087cc:	08 9c       	mov	r12,r4
800087ce:	1a d8       	st.w	--sp,r8
800087d0:	fa c8 f9 40 	sub	r8,sp,-1728
800087d4:	fa c9 ff b4 	sub	r9,sp,-76
800087d8:	fe b0 f4 be 	rcall	80007154 <get_arg>
800087dc:	2f dd       	sub	sp,-12
800087de:	f8 ea 00 00 	ld.d	r10,r12[0]
800087e2:	c0 c8       	rjmp	800087fa <_vfprintf_r+0x1376>
800087e4:	ee ca ff ff 	sub	r10,r7,-1
800087e8:	10 37       	cp.w	r7,r8
800087ea:	c0 b4       	brge	80008800 <_vfprintf_r+0x137c>
800087ec:	fa c9 f9 44 	sub	r9,sp,-1724
800087f0:	14 97       	mov	r7,r10
800087f2:	f2 06 00 36 	add	r6,r9,r6<<0x3
800087f6:	ec ea fd 88 	ld.d	r10,r6[-632]
800087fa:	fa eb 00 00 	st.d	sp[0],r10
800087fe:	cc e8       	rjmp	8000899a <_vfprintf_r+0x1516>
80008800:	41 09       	lddsp	r9,sp[0x40]
80008802:	59 f8       	cp.w	r8,31
80008804:	e0 89 00 16 	brgt	80008830 <_vfprintf_r+0x13ac>
80008808:	f2 e6 00 00 	ld.d	r6,r9[0]
8000880c:	f2 cb ff f8 	sub	r11,r9,-8
80008810:	fa e7 00 00 	st.d	sp[0],r6
80008814:	51 0b       	stdsp	sp[0x40],r11
80008816:	fa c6 f9 44 	sub	r6,sp,-1724
8000881a:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000881e:	fa e6 00 00 	ld.d	r6,sp[0]
80008822:	f2 e7 fd 88 	st.d	r9[-632],r6
80008826:	2f f8       	sub	r8,-1
80008828:	14 97       	mov	r7,r10
8000882a:	fb 48 06 b4 	st.w	sp[1716],r8
8000882e:	cb 68       	rjmp	8000899a <_vfprintf_r+0x1516>
80008830:	f2 e6 00 00 	ld.d	r6,r9[0]
80008834:	2f 89       	sub	r9,-8
80008836:	fa e7 00 00 	st.d	sp[0],r6
8000883a:	51 09       	stdsp	sp[0x40],r9
8000883c:	14 97       	mov	r7,r10
8000883e:	ca e8       	rjmp	8000899a <_vfprintf_r+0x1516>
80008840:	ed b5 00 04 	bld	r5,0x4
80008844:	c1 71       	brne	80008872 <_vfprintf_r+0x13ee>
80008846:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000884a:	40 3e       	lddsp	lr,sp[0xc]
8000884c:	58 0e       	cp.w	lr,0
8000884e:	c0 80       	breq	8000885e <_vfprintf_r+0x13da>
80008850:	10 36       	cp.w	r6,r8
80008852:	c6 94       	brge	80008924 <_vfprintf_r+0x14a0>
80008854:	fa cc f9 44 	sub	r12,sp,-1724
80008858:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000885c:	c8 28       	rjmp	80008960 <_vfprintf_r+0x14dc>
8000885e:	ee ca ff ff 	sub	r10,r7,-1
80008862:	10 37       	cp.w	r7,r8
80008864:	e0 84 00 81 	brge	80008966 <_vfprintf_r+0x14e2>
80008868:	fa cb f9 44 	sub	r11,sp,-1724
8000886c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008870:	c7 78       	rjmp	8000895e <_vfprintf_r+0x14da>
80008872:	ed b5 00 06 	bld	r5,0x6
80008876:	c4 b1       	brne	8000890c <_vfprintf_r+0x1488>
80008878:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000887c:	40 3c       	lddsp	r12,sp[0xc]
8000887e:	58 0c       	cp.w	r12,0
80008880:	c1 d0       	breq	800088ba <_vfprintf_r+0x1436>
80008882:	10 36       	cp.w	r6,r8
80008884:	c0 64       	brge	80008890 <_vfprintf_r+0x140c>
80008886:	fa cb f9 44 	sub	r11,sp,-1724
8000888a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000888e:	c1 f8       	rjmp	800088cc <_vfprintf_r+0x1448>
80008890:	fa c8 f9 50 	sub	r8,sp,-1712
80008894:	1a d8       	st.w	--sp,r8
80008896:	fa c8 fa b8 	sub	r8,sp,-1352
8000889a:	1a d8       	st.w	--sp,r8
8000889c:	fa c8 fb b4 	sub	r8,sp,-1100
800088a0:	1a d8       	st.w	--sp,r8
800088a2:	fa c8 f9 40 	sub	r8,sp,-1728
800088a6:	fa c9 ff b4 	sub	r9,sp,-76
800088aa:	04 9a       	mov	r10,r2
800088ac:	0c 9b       	mov	r11,r6
800088ae:	08 9c       	mov	r12,r4
800088b0:	fe b0 f4 52 	rcall	80007154 <get_arg>
800088b4:	2f dd       	sub	sp,-12
800088b6:	98 18       	ld.sh	r8,r12[0x2]
800088b8:	c2 78       	rjmp	80008906 <_vfprintf_r+0x1482>
800088ba:	ee ca ff ff 	sub	r10,r7,-1
800088be:	10 37       	cp.w	r7,r8
800088c0:	c0 a4       	brge	800088d4 <_vfprintf_r+0x1450>
800088c2:	fa c9 f9 44 	sub	r9,sp,-1724
800088c6:	14 97       	mov	r7,r10
800088c8:	f2 06 00 36 	add	r6,r9,r6<<0x3
800088cc:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
800088d0:	c1 b8       	rjmp	80008906 <_vfprintf_r+0x1482>
800088d2:	d7 03       	nop
800088d4:	41 09       	lddsp	r9,sp[0x40]
800088d6:	59 f8       	cp.w	r8,31
800088d8:	e0 89 00 13 	brgt	800088fe <_vfprintf_r+0x147a>
800088dc:	f2 cb ff fc 	sub	r11,r9,-4
800088e0:	51 0b       	stdsp	sp[0x40],r11
800088e2:	72 09       	ld.w	r9,r9[0x0]
800088e4:	fa c6 f9 44 	sub	r6,sp,-1724
800088e8:	ec 08 00 3b 	add	r11,r6,r8<<0x3
800088ec:	2f f8       	sub	r8,-1
800088ee:	f7 49 fd 88 	st.w	r11[-632],r9
800088f2:	fb 48 06 b4 	st.w	sp[1716],r8
800088f6:	14 97       	mov	r7,r10
800088f8:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
800088fc:	c0 58       	rjmp	80008906 <_vfprintf_r+0x1482>
800088fe:	92 18       	ld.sh	r8,r9[0x2]
80008900:	14 97       	mov	r7,r10
80008902:	2f c9       	sub	r9,-4
80008904:	51 09       	stdsp	sp[0x40],r9
80008906:	5c 78       	castu.h	r8
80008908:	50 18       	stdsp	sp[0x4],r8
8000890a:	c4 68       	rjmp	80008996 <_vfprintf_r+0x1512>
8000890c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008910:	40 3c       	lddsp	r12,sp[0xc]
80008912:	58 0c       	cp.w	r12,0
80008914:	c1 d0       	breq	8000894e <_vfprintf_r+0x14ca>
80008916:	10 36       	cp.w	r6,r8
80008918:	c0 64       	brge	80008924 <_vfprintf_r+0x14a0>
8000891a:	fa cb f9 44 	sub	r11,sp,-1724
8000891e:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008922:	c1 f8       	rjmp	80008960 <_vfprintf_r+0x14dc>
80008924:	fa c8 f9 50 	sub	r8,sp,-1712
80008928:	1a d8       	st.w	--sp,r8
8000892a:	fa c8 fa b8 	sub	r8,sp,-1352
8000892e:	0c 9b       	mov	r11,r6
80008930:	1a d8       	st.w	--sp,r8
80008932:	fa c8 fb b4 	sub	r8,sp,-1100
80008936:	04 9a       	mov	r10,r2
80008938:	1a d8       	st.w	--sp,r8
8000893a:	08 9c       	mov	r12,r4
8000893c:	fa c8 f9 40 	sub	r8,sp,-1728
80008940:	fa c9 ff b4 	sub	r9,sp,-76
80008944:	fe b0 f4 08 	rcall	80007154 <get_arg>
80008948:	2f dd       	sub	sp,-12
8000894a:	78 0b       	ld.w	r11,r12[0x0]
8000894c:	c2 48       	rjmp	80008994 <_vfprintf_r+0x1510>
8000894e:	ee ca ff ff 	sub	r10,r7,-1
80008952:	10 37       	cp.w	r7,r8
80008954:	c0 94       	brge	80008966 <_vfprintf_r+0x14e2>
80008956:	fa c9 f9 44 	sub	r9,sp,-1724
8000895a:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000895e:	14 97       	mov	r7,r10
80008960:	ec fb fd 88 	ld.w	r11,r6[-632]
80008964:	c1 88       	rjmp	80008994 <_vfprintf_r+0x1510>
80008966:	41 09       	lddsp	r9,sp[0x40]
80008968:	59 f8       	cp.w	r8,31
8000896a:	e0 89 00 11 	brgt	8000898c <_vfprintf_r+0x1508>
8000896e:	f2 cb ff fc 	sub	r11,r9,-4
80008972:	51 0b       	stdsp	sp[0x40],r11
80008974:	fa c6 f9 44 	sub	r6,sp,-1724
80008978:	72 0b       	ld.w	r11,r9[0x0]
8000897a:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000897e:	f3 4b fd 88 	st.w	r9[-632],r11
80008982:	2f f8       	sub	r8,-1
80008984:	14 97       	mov	r7,r10
80008986:	fb 48 06 b4 	st.w	sp[1716],r8
8000898a:	c0 58       	rjmp	80008994 <_vfprintf_r+0x1510>
8000898c:	72 0b       	ld.w	r11,r9[0x0]
8000898e:	14 97       	mov	r7,r10
80008990:	2f c9       	sub	r9,-4
80008992:	51 09       	stdsp	sp[0x40],r9
80008994:	50 1b       	stdsp	sp[0x4],r11
80008996:	30 0e       	mov	lr,0
80008998:	50 0e       	stdsp	sp[0x0],lr
8000899a:	40 08       	lddsp	r8,sp[0x0]
8000899c:	40 1c       	lddsp	r12,sp[0x4]
8000899e:	18 48       	or	r8,r12
800089a0:	5f 19       	srne	r9
800089a2:	0a 98       	mov	r8,r5
800089a4:	eb e9 00 09 	and	r9,r5,r9
800089a8:	a1 b8       	sbr	r8,0x1
800089aa:	58 09       	cp.w	r9,0
800089ac:	c0 70       	breq	800089ba <_vfprintf_r+0x1536>
800089ae:	10 95       	mov	r5,r8
800089b0:	fb 60 06 b9 	st.b	sp[1721],r0
800089b4:	33 08       	mov	r8,48
800089b6:	fb 68 06 b8 	st.b	sp[1720],r8
800089ba:	30 28       	mov	r8,2
800089bc:	30 09       	mov	r9,0
800089be:	fb 69 06 bb 	st.b	sp[1723],r9
800089c2:	0a 99       	mov	r9,r5
800089c4:	a7 d9       	cbr	r9,0x7
800089c6:	40 2b       	lddsp	r11,sp[0x8]
800089c8:	40 16       	lddsp	r6,sp[0x4]
800089ca:	58 0b       	cp.w	r11,0
800089cc:	5f 1a       	srne	r10
800089ce:	f2 05 17 40 	movge	r5,r9
800089d2:	fa c2 f9 78 	sub	r2,sp,-1672
800089d6:	40 09       	lddsp	r9,sp[0x0]
800089d8:	0c 49       	or	r9,r6
800089da:	5f 19       	srne	r9
800089dc:	f5 e9 10 09 	or	r9,r10,r9
800089e0:	c5 c0       	breq	80008a98 <_vfprintf_r+0x1614>
800089e2:	30 19       	mov	r9,1
800089e4:	f2 08 18 00 	cp.b	r8,r9
800089e8:	c0 60       	breq	800089f4 <_vfprintf_r+0x1570>
800089ea:	30 29       	mov	r9,2
800089ec:	f2 08 18 00 	cp.b	r8,r9
800089f0:	c0 41       	brne	800089f8 <_vfprintf_r+0x1574>
800089f2:	c3 c8       	rjmp	80008a6a <_vfprintf_r+0x15e6>
800089f4:	04 96       	mov	r6,r2
800089f6:	c3 08       	rjmp	80008a56 <_vfprintf_r+0x15d2>
800089f8:	04 96       	mov	r6,r2
800089fa:	fa e8 00 00 	ld.d	r8,sp[0]
800089fe:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
80008a02:	2d 0a       	sub	r10,-48
80008a04:	0c fa       	st.b	--r6,r10
80008a06:	f0 0b 16 03 	lsr	r11,r8,0x3
80008a0a:	f2 0c 16 03 	lsr	r12,r9,0x3
80008a0e:	f7 e9 11 db 	or	r11,r11,r9<<0x1d
80008a12:	18 99       	mov	r9,r12
80008a14:	16 98       	mov	r8,r11
80008a16:	58 08       	cp.w	r8,0
80008a18:	5c 29       	cpc	r9
80008a1a:	cf 21       	brne	800089fe <_vfprintf_r+0x157a>
80008a1c:	fa e9 00 00 	st.d	sp[0],r8
80008a20:	ed b5 00 00 	bld	r5,0x0
80008a24:	c4 51       	brne	80008aae <_vfprintf_r+0x162a>
80008a26:	33 09       	mov	r9,48
80008a28:	f2 0a 18 00 	cp.b	r10,r9
80008a2c:	c4 10       	breq	80008aae <_vfprintf_r+0x162a>
80008a2e:	0c f9       	st.b	--r6,r9
80008a30:	c3 f8       	rjmp	80008aae <_vfprintf_r+0x162a>
80008a32:	fa ea 00 00 	ld.d	r10,sp[0]
80008a36:	30 a8       	mov	r8,10
80008a38:	30 09       	mov	r9,0
80008a3a:	e0 a0 1a 0d 	rcall	8000be54 <__avr32_umod64>
80008a3e:	30 a8       	mov	r8,10
80008a40:	2d 0a       	sub	r10,-48
80008a42:	30 09       	mov	r9,0
80008a44:	ac 8a       	st.b	r6[0x0],r10
80008a46:	fa ea 00 00 	ld.d	r10,sp[0]
80008a4a:	e0 a0 18 d3 	rcall	8000bbf0 <__avr32_udiv64>
80008a4e:	16 99       	mov	r9,r11
80008a50:	14 98       	mov	r8,r10
80008a52:	fa e9 00 00 	st.d	sp[0],r8
80008a56:	20 16       	sub	r6,1
80008a58:	fa ea 00 00 	ld.d	r10,sp[0]
80008a5c:	58 9a       	cp.w	r10,9
80008a5e:	5c 2b       	cpc	r11
80008a60:	fe 9b ff e9 	brhi	80008a32 <_vfprintf_r+0x15ae>
80008a64:	1b f8       	ld.ub	r8,sp[0x7]
80008a66:	2d 08       	sub	r8,-48
80008a68:	c2 08       	rjmp	80008aa8 <_vfprintf_r+0x1624>
80008a6a:	04 96       	mov	r6,r2
80008a6c:	fa e8 00 00 	ld.d	r8,sp[0]
80008a70:	f5 d8 c0 04 	bfextu	r10,r8,0x0,0x4
80008a74:	40 de       	lddsp	lr,sp[0x34]
80008a76:	fc 0a 07 0a 	ld.ub	r10,lr[r10]
80008a7a:	0c fa       	st.b	--r6,r10
80008a7c:	f2 0b 16 04 	lsr	r11,r9,0x4
80008a80:	f0 0a 16 04 	lsr	r10,r8,0x4
80008a84:	f5 e9 11 ca 	or	r10,r10,r9<<0x1c
80008a88:	16 99       	mov	r9,r11
80008a8a:	14 98       	mov	r8,r10
80008a8c:	58 08       	cp.w	r8,0
80008a8e:	5c 29       	cpc	r9
80008a90:	cf 01       	brne	80008a70 <_vfprintf_r+0x15ec>
80008a92:	fa e9 00 00 	st.d	sp[0],r8
80008a96:	c0 c8       	rjmp	80008aae <_vfprintf_r+0x162a>
80008a98:	58 08       	cp.w	r8,0
80008a9a:	c0 91       	brne	80008aac <_vfprintf_r+0x1628>
80008a9c:	ed b5 00 00 	bld	r5,0x0
80008aa0:	c0 61       	brne	80008aac <_vfprintf_r+0x1628>
80008aa2:	fa c6 f9 79 	sub	r6,sp,-1671
80008aa6:	33 08       	mov	r8,48
80008aa8:	ac 88       	st.b	r6[0x0],r8
80008aaa:	c0 28       	rjmp	80008aae <_vfprintf_r+0x162a>
80008aac:	04 96       	mov	r6,r2
80008aae:	0c 12       	sub	r2,r6
80008ab0:	c1 c8       	rjmp	80008ae8 <_vfprintf_r+0x1664>
80008ab2:	50 a7       	stdsp	sp[0x28],r7
80008ab4:	50 80       	stdsp	sp[0x20],r0
80008ab6:	40 93       	lddsp	r3,sp[0x24]
80008ab8:	0c 97       	mov	r7,r6
80008aba:	10 90       	mov	r0,r8
80008abc:	04 94       	mov	r4,r2
80008abe:	40 41       	lddsp	r1,sp[0x10]
80008ac0:	58 08       	cp.w	r8,0
80008ac2:	e0 80 04 4f 	breq	80009360 <_vfprintf_r+0x1edc>
80008ac6:	fb 68 06 60 	st.b	sp[1632],r8
80008aca:	30 0c       	mov	r12,0
80008acc:	30 08       	mov	r8,0
80008ace:	30 12       	mov	r2,1
80008ad0:	fb 68 06 bb 	st.b	sp[1723],r8
80008ad4:	50 2c       	stdsp	sp[0x8],r12
80008ad6:	fa c6 f9 a0 	sub	r6,sp,-1632
80008ada:	c0 78       	rjmp	80008ae8 <_vfprintf_r+0x1664>
80008adc:	30 0b       	mov	r11,0
80008ade:	50 2b       	stdsp	sp[0x8],r11
80008ae0:	c0 48       	rjmp	80008ae8 <_vfprintf_r+0x1664>
80008ae2:	40 22       	lddsp	r2,sp[0x8]
80008ae4:	30 0a       	mov	r10,0
80008ae6:	50 2a       	stdsp	sp[0x8],r10
80008ae8:	40 29       	lddsp	r9,sp[0x8]
80008aea:	e4 09 0c 49 	max	r9,r2,r9
80008aee:	fb 38 06 bb 	ld.ub	r8,sp[1723]
80008af2:	50 39       	stdsp	sp[0xc],r9
80008af4:	0a 9e       	mov	lr,r5
80008af6:	30 09       	mov	r9,0
80008af8:	e2 1e 00 02 	andl	lr,0x2,COH
80008afc:	f2 08 18 00 	cp.b	r8,r9
80008b00:	fb f8 10 03 	ld.wne	r8,sp[0xc]
80008b04:	f7 b8 01 ff 	subne	r8,-1
80008b08:	fb f8 1a 03 	st.wne	sp[0xc],r8
80008b0c:	0a 9b       	mov	r11,r5
80008b0e:	58 0e       	cp.w	lr,0
80008b10:	fb fc 10 03 	ld.wne	r12,sp[0xc]
80008b14:	f7 bc 01 fe 	subne	r12,-2
80008b18:	fb fc 1a 03 	st.wne	sp[0xc],r12
80008b1c:	e2 1b 00 84 	andl	r11,0x84,COH
80008b20:	50 fe       	stdsp	sp[0x3c],lr
80008b22:	50 9b       	stdsp	sp[0x24],r11
80008b24:	c4 71       	brne	80008bb2 <_vfprintf_r+0x172e>
80008b26:	40 8a       	lddsp	r10,sp[0x20]
80008b28:	40 39       	lddsp	r9,sp[0xc]
80008b2a:	12 1a       	sub	r10,r9
80008b2c:	50 4a       	stdsp	sp[0x10],r10
80008b2e:	58 0a       	cp.w	r10,0
80008b30:	e0 89 00 20 	brgt	80008b70 <_vfprintf_r+0x16ec>
80008b34:	c3 f8       	rjmp	80008bb2 <_vfprintf_r+0x172e>
80008b36:	2f 09       	sub	r9,-16
80008b38:	2f f8       	sub	r8,-1
80008b3a:	fe ce b8 d2 	sub	lr,pc,-18222
80008b3e:	31 0c       	mov	r12,16
80008b40:	fb 49 06 90 	st.w	sp[1680],r9
80008b44:	87 0e       	st.w	r3[0x0],lr
80008b46:	87 1c       	st.w	r3[0x4],r12
80008b48:	fb 48 06 8c 	st.w	sp[1676],r8
80008b4c:	58 78       	cp.w	r8,7
80008b4e:	e0 89 00 04 	brgt	80008b56 <_vfprintf_r+0x16d2>
80008b52:	2f 83       	sub	r3,-8
80008b54:	c0 b8       	rjmp	80008b6a <_vfprintf_r+0x16e6>
80008b56:	fa ca f9 78 	sub	r10,sp,-1672
80008b5a:	02 9b       	mov	r11,r1
80008b5c:	08 9c       	mov	r12,r4
80008b5e:	fe b0 f4 85 	rcall	80007468 <__sprint_r>
80008b62:	e0 81 04 10 	brne	80009382 <_vfprintf_r+0x1efe>
80008b66:	fa c3 f9 e0 	sub	r3,sp,-1568
80008b6a:	40 4b       	lddsp	r11,sp[0x10]
80008b6c:	21 0b       	sub	r11,16
80008b6e:	50 4b       	stdsp	sp[0x10],r11
80008b70:	fa f9 06 90 	ld.w	r9,sp[1680]
80008b74:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008b78:	fe ca b9 10 	sub	r10,pc,-18160
80008b7c:	40 4e       	lddsp	lr,sp[0x10]
80008b7e:	59 0e       	cp.w	lr,16
80008b80:	fe 99 ff db 	brgt	80008b36 <_vfprintf_r+0x16b2>
80008b84:	1c 09       	add	r9,lr
80008b86:	2f f8       	sub	r8,-1
80008b88:	87 0a       	st.w	r3[0x0],r10
80008b8a:	fb 49 06 90 	st.w	sp[1680],r9
80008b8e:	87 1e       	st.w	r3[0x4],lr
80008b90:	fb 48 06 8c 	st.w	sp[1676],r8
80008b94:	58 78       	cp.w	r8,7
80008b96:	e0 89 00 04 	brgt	80008b9e <_vfprintf_r+0x171a>
80008b9a:	2f 83       	sub	r3,-8
80008b9c:	c0 b8       	rjmp	80008bb2 <_vfprintf_r+0x172e>
80008b9e:	fa ca f9 78 	sub	r10,sp,-1672
80008ba2:	02 9b       	mov	r11,r1
80008ba4:	08 9c       	mov	r12,r4
80008ba6:	fe b0 f4 61 	rcall	80007468 <__sprint_r>
80008baa:	e0 81 03 ec 	brne	80009382 <_vfprintf_r+0x1efe>
80008bae:	fa c3 f9 e0 	sub	r3,sp,-1568
80008bb2:	30 09       	mov	r9,0
80008bb4:	fb 38 06 bb 	ld.ub	r8,sp[1723]
80008bb8:	f2 08 18 00 	cp.b	r8,r9
80008bbc:	c1 f0       	breq	80008bfa <_vfprintf_r+0x1776>
80008bbe:	fa f8 06 90 	ld.w	r8,sp[1680]
80008bc2:	fa c9 f9 45 	sub	r9,sp,-1723
80008bc6:	2f f8       	sub	r8,-1
80008bc8:	87 09       	st.w	r3[0x0],r9
80008bca:	fb 48 06 90 	st.w	sp[1680],r8
80008bce:	30 19       	mov	r9,1
80008bd0:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008bd4:	87 19       	st.w	r3[0x4],r9
80008bd6:	2f f8       	sub	r8,-1
80008bd8:	fb 48 06 8c 	st.w	sp[1676],r8
80008bdc:	58 78       	cp.w	r8,7
80008bde:	e0 89 00 04 	brgt	80008be6 <_vfprintf_r+0x1762>
80008be2:	2f 83       	sub	r3,-8
80008be4:	c0 b8       	rjmp	80008bfa <_vfprintf_r+0x1776>
80008be6:	fa ca f9 78 	sub	r10,sp,-1672
80008bea:	02 9b       	mov	r11,r1
80008bec:	08 9c       	mov	r12,r4
80008bee:	fe b0 f4 3d 	rcall	80007468 <__sprint_r>
80008bf2:	e0 81 03 c8 	brne	80009382 <_vfprintf_r+0x1efe>
80008bf6:	fa c3 f9 e0 	sub	r3,sp,-1568
80008bfa:	40 fc       	lddsp	r12,sp[0x3c]
80008bfc:	58 0c       	cp.w	r12,0
80008bfe:	c1 f0       	breq	80008c3c <_vfprintf_r+0x17b8>
80008c00:	fa f8 06 90 	ld.w	r8,sp[1680]
80008c04:	fa c9 f9 48 	sub	r9,sp,-1720
80008c08:	2f e8       	sub	r8,-2
80008c0a:	87 09       	st.w	r3[0x0],r9
80008c0c:	fb 48 06 90 	st.w	sp[1680],r8
80008c10:	30 29       	mov	r9,2
80008c12:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008c16:	87 19       	st.w	r3[0x4],r9
80008c18:	2f f8       	sub	r8,-1
80008c1a:	fb 48 06 8c 	st.w	sp[1676],r8
80008c1e:	58 78       	cp.w	r8,7
80008c20:	e0 89 00 04 	brgt	80008c28 <_vfprintf_r+0x17a4>
80008c24:	2f 83       	sub	r3,-8
80008c26:	c0 b8       	rjmp	80008c3c <_vfprintf_r+0x17b8>
80008c28:	fa ca f9 78 	sub	r10,sp,-1672
80008c2c:	02 9b       	mov	r11,r1
80008c2e:	08 9c       	mov	r12,r4
80008c30:	fe b0 f4 1c 	rcall	80007468 <__sprint_r>
80008c34:	e0 81 03 a7 	brne	80009382 <_vfprintf_r+0x1efe>
80008c38:	fa c3 f9 e0 	sub	r3,sp,-1568
80008c3c:	40 9b       	lddsp	r11,sp[0x24]
80008c3e:	e0 4b 00 80 	cp.w	r11,128
80008c42:	c4 71       	brne	80008cd0 <_vfprintf_r+0x184c>
80008c44:	40 8a       	lddsp	r10,sp[0x20]
80008c46:	40 39       	lddsp	r9,sp[0xc]
80008c48:	12 1a       	sub	r10,r9
80008c4a:	50 4a       	stdsp	sp[0x10],r10
80008c4c:	58 0a       	cp.w	r10,0
80008c4e:	e0 89 00 20 	brgt	80008c8e <_vfprintf_r+0x180a>
80008c52:	c3 f8       	rjmp	80008cd0 <_vfprintf_r+0x184c>
80008c54:	2f 09       	sub	r9,-16
80008c56:	2f f8       	sub	r8,-1
80008c58:	fe ce b9 e0 	sub	lr,pc,-17952
80008c5c:	31 0c       	mov	r12,16
80008c5e:	fb 49 06 90 	st.w	sp[1680],r9
80008c62:	87 0e       	st.w	r3[0x0],lr
80008c64:	87 1c       	st.w	r3[0x4],r12
80008c66:	fb 48 06 8c 	st.w	sp[1676],r8
80008c6a:	58 78       	cp.w	r8,7
80008c6c:	e0 89 00 04 	brgt	80008c74 <_vfprintf_r+0x17f0>
80008c70:	2f 83       	sub	r3,-8
80008c72:	c0 b8       	rjmp	80008c88 <_vfprintf_r+0x1804>
80008c74:	fa ca f9 78 	sub	r10,sp,-1672
80008c78:	02 9b       	mov	r11,r1
80008c7a:	08 9c       	mov	r12,r4
80008c7c:	fe b0 f3 f6 	rcall	80007468 <__sprint_r>
80008c80:	e0 81 03 81 	brne	80009382 <_vfprintf_r+0x1efe>
80008c84:	fa c3 f9 e0 	sub	r3,sp,-1568
80008c88:	40 4b       	lddsp	r11,sp[0x10]
80008c8a:	21 0b       	sub	r11,16
80008c8c:	50 4b       	stdsp	sp[0x10],r11
80008c8e:	fa f9 06 90 	ld.w	r9,sp[1680]
80008c92:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008c96:	fe ca ba 1e 	sub	r10,pc,-17890
80008c9a:	40 4e       	lddsp	lr,sp[0x10]
80008c9c:	59 0e       	cp.w	lr,16
80008c9e:	fe 99 ff db 	brgt	80008c54 <_vfprintf_r+0x17d0>
80008ca2:	1c 09       	add	r9,lr
80008ca4:	2f f8       	sub	r8,-1
80008ca6:	87 0a       	st.w	r3[0x0],r10
80008ca8:	fb 49 06 90 	st.w	sp[1680],r9
80008cac:	87 1e       	st.w	r3[0x4],lr
80008cae:	fb 48 06 8c 	st.w	sp[1676],r8
80008cb2:	58 78       	cp.w	r8,7
80008cb4:	e0 89 00 04 	brgt	80008cbc <_vfprintf_r+0x1838>
80008cb8:	2f 83       	sub	r3,-8
80008cba:	c0 b8       	rjmp	80008cd0 <_vfprintf_r+0x184c>
80008cbc:	fa ca f9 78 	sub	r10,sp,-1672
80008cc0:	02 9b       	mov	r11,r1
80008cc2:	08 9c       	mov	r12,r4
80008cc4:	fe b0 f3 d2 	rcall	80007468 <__sprint_r>
80008cc8:	e0 81 03 5d 	brne	80009382 <_vfprintf_r+0x1efe>
80008ccc:	fa c3 f9 e0 	sub	r3,sp,-1568
80008cd0:	40 2c       	lddsp	r12,sp[0x8]
80008cd2:	04 1c       	sub	r12,r2
80008cd4:	50 2c       	stdsp	sp[0x8],r12
80008cd6:	58 0c       	cp.w	r12,0
80008cd8:	e0 89 00 20 	brgt	80008d18 <_vfprintf_r+0x1894>
80008cdc:	c3 f8       	rjmp	80008d5a <_vfprintf_r+0x18d6>
80008cde:	2f 09       	sub	r9,-16
80008ce0:	2f f8       	sub	r8,-1
80008ce2:	fe cb ba 6a 	sub	r11,pc,-17814
80008ce6:	31 0a       	mov	r10,16
80008ce8:	fb 49 06 90 	st.w	sp[1680],r9
80008cec:	87 0b       	st.w	r3[0x0],r11
80008cee:	87 1a       	st.w	r3[0x4],r10
80008cf0:	fb 48 06 8c 	st.w	sp[1676],r8
80008cf4:	58 78       	cp.w	r8,7
80008cf6:	e0 89 00 04 	brgt	80008cfe <_vfprintf_r+0x187a>
80008cfa:	2f 83       	sub	r3,-8
80008cfc:	c0 b8       	rjmp	80008d12 <_vfprintf_r+0x188e>
80008cfe:	fa ca f9 78 	sub	r10,sp,-1672
80008d02:	02 9b       	mov	r11,r1
80008d04:	08 9c       	mov	r12,r4
80008d06:	fe b0 f3 b1 	rcall	80007468 <__sprint_r>
80008d0a:	e0 81 03 3c 	brne	80009382 <_vfprintf_r+0x1efe>
80008d0e:	fa c3 f9 e0 	sub	r3,sp,-1568
80008d12:	40 29       	lddsp	r9,sp[0x8]
80008d14:	21 09       	sub	r9,16
80008d16:	50 29       	stdsp	sp[0x8],r9
80008d18:	fa f9 06 90 	ld.w	r9,sp[1680]
80008d1c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008d20:	fe ca ba a8 	sub	r10,pc,-17752
80008d24:	40 2e       	lddsp	lr,sp[0x8]
80008d26:	59 0e       	cp.w	lr,16
80008d28:	fe 99 ff db 	brgt	80008cde <_vfprintf_r+0x185a>
80008d2c:	1c 09       	add	r9,lr
80008d2e:	2f f8       	sub	r8,-1
80008d30:	87 0a       	st.w	r3[0x0],r10
80008d32:	fb 49 06 90 	st.w	sp[1680],r9
80008d36:	87 1e       	st.w	r3[0x4],lr
80008d38:	fb 48 06 8c 	st.w	sp[1676],r8
80008d3c:	58 78       	cp.w	r8,7
80008d3e:	e0 89 00 04 	brgt	80008d46 <_vfprintf_r+0x18c2>
80008d42:	2f 83       	sub	r3,-8
80008d44:	c0 b8       	rjmp	80008d5a <_vfprintf_r+0x18d6>
80008d46:	fa ca f9 78 	sub	r10,sp,-1672
80008d4a:	02 9b       	mov	r11,r1
80008d4c:	08 9c       	mov	r12,r4
80008d4e:	fe b0 f3 8d 	rcall	80007468 <__sprint_r>
80008d52:	e0 81 03 18 	brne	80009382 <_vfprintf_r+0x1efe>
80008d56:	fa c3 f9 e0 	sub	r3,sp,-1568
80008d5a:	ed b5 00 08 	bld	r5,0x8
80008d5e:	c0 b0       	breq	80008d74 <_vfprintf_r+0x18f0>
80008d60:	fa f8 06 90 	ld.w	r8,sp[1680]
80008d64:	87 12       	st.w	r3[0x4],r2
80008d66:	87 06       	st.w	r3[0x0],r6
80008d68:	f0 02 00 02 	add	r2,r8,r2
80008d6c:	fb 42 06 90 	st.w	sp[1680],r2
80008d70:	e0 8f 01 d4 	bral	80009118 <_vfprintf_r+0x1c94>
80008d74:	e0 40 00 65 	cp.w	r0,101
80008d78:	e0 8a 01 d6 	brle	80009124 <_vfprintf_r+0x1ca0>
80008d7c:	30 08       	mov	r8,0
80008d7e:	30 09       	mov	r9,0
80008d80:	40 5b       	lddsp	r11,sp[0x14]
80008d82:	40 7a       	lddsp	r10,sp[0x1c]
80008d84:	e0 a0 15 2f 	rcall	8000b7e2 <__avr32_f64_cmp_eq>
80008d88:	c7 90       	breq	80008e7a <_vfprintf_r+0x19f6>
80008d8a:	fa f8 06 90 	ld.w	r8,sp[1680]
80008d8e:	fe c9 bb 2a 	sub	r9,pc,-17622
80008d92:	2f f8       	sub	r8,-1
80008d94:	87 09       	st.w	r3[0x0],r9
80008d96:	fb 48 06 90 	st.w	sp[1680],r8
80008d9a:	30 19       	mov	r9,1
80008d9c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008da0:	87 19       	st.w	r3[0x4],r9
80008da2:	2f f8       	sub	r8,-1
80008da4:	fb 48 06 8c 	st.w	sp[1676],r8
80008da8:	58 78       	cp.w	r8,7
80008daa:	e0 89 00 05 	brgt	80008db4 <_vfprintf_r+0x1930>
80008dae:	2f 83       	sub	r3,-8
80008db0:	c0 c8       	rjmp	80008dc8 <_vfprintf_r+0x1944>
80008db2:	d7 03       	nop
80008db4:	fa ca f9 78 	sub	r10,sp,-1672
80008db8:	02 9b       	mov	r11,r1
80008dba:	08 9c       	mov	r12,r4
80008dbc:	fe b0 f3 56 	rcall	80007468 <__sprint_r>
80008dc0:	e0 81 02 e1 	brne	80009382 <_vfprintf_r+0x1efe>
80008dc4:	fa c3 f9 e0 	sub	r3,sp,-1568
80008dc8:	fa f8 06 ac 	ld.w	r8,sp[1708]
80008dcc:	40 6c       	lddsp	r12,sp[0x18]
80008dce:	18 38       	cp.w	r8,r12
80008dd0:	c0 55       	brlt	80008dda <_vfprintf_r+0x1956>
80008dd2:	ed b5 00 00 	bld	r5,0x0
80008dd6:	e0 81 02 6b 	brne	800092ac <_vfprintf_r+0x1e28>
80008dda:	fa f8 06 90 	ld.w	r8,sp[1680]
80008dde:	2f f8       	sub	r8,-1
80008de0:	40 cb       	lddsp	r11,sp[0x30]
80008de2:	fb 48 06 90 	st.w	sp[1680],r8
80008de6:	30 19       	mov	r9,1
80008de8:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008dec:	87 0b       	st.w	r3[0x0],r11
80008dee:	2f f8       	sub	r8,-1
80008df0:	87 19       	st.w	r3[0x4],r9
80008df2:	fb 48 06 8c 	st.w	sp[1676],r8
80008df6:	58 78       	cp.w	r8,7
80008df8:	e0 89 00 04 	brgt	80008e00 <_vfprintf_r+0x197c>
80008dfc:	2f 83       	sub	r3,-8
80008dfe:	c0 b8       	rjmp	80008e14 <_vfprintf_r+0x1990>
80008e00:	fa ca f9 78 	sub	r10,sp,-1672
80008e04:	02 9b       	mov	r11,r1
80008e06:	08 9c       	mov	r12,r4
80008e08:	fe b0 f3 30 	rcall	80007468 <__sprint_r>
80008e0c:	e0 81 02 bb 	brne	80009382 <_vfprintf_r+0x1efe>
80008e10:	fa c3 f9 e0 	sub	r3,sp,-1568
80008e14:	40 66       	lddsp	r6,sp[0x18]
80008e16:	20 16       	sub	r6,1
80008e18:	58 06       	cp.w	r6,0
80008e1a:	e0 89 00 1d 	brgt	80008e54 <_vfprintf_r+0x19d0>
80008e1e:	e0 8f 02 47 	bral	800092ac <_vfprintf_r+0x1e28>
80008e22:	2f 09       	sub	r9,-16
80008e24:	2f f8       	sub	r8,-1
80008e26:	fb 49 06 90 	st.w	sp[1680],r9
80008e2a:	87 02       	st.w	r3[0x0],r2
80008e2c:	87 10       	st.w	r3[0x4],r0
80008e2e:	fb 48 06 8c 	st.w	sp[1676],r8
80008e32:	58 78       	cp.w	r8,7
80008e34:	e0 89 00 04 	brgt	80008e3c <_vfprintf_r+0x19b8>
80008e38:	2f 83       	sub	r3,-8
80008e3a:	c0 b8       	rjmp	80008e50 <_vfprintf_r+0x19cc>
80008e3c:	fa ca f9 78 	sub	r10,sp,-1672
80008e40:	02 9b       	mov	r11,r1
80008e42:	08 9c       	mov	r12,r4
80008e44:	fe b0 f3 12 	rcall	80007468 <__sprint_r>
80008e48:	e0 81 02 9d 	brne	80009382 <_vfprintf_r+0x1efe>
80008e4c:	fa c3 f9 e0 	sub	r3,sp,-1568
80008e50:	21 06       	sub	r6,16
80008e52:	c0 48       	rjmp	80008e5a <_vfprintf_r+0x19d6>
80008e54:	fe c2 bb dc 	sub	r2,pc,-17444
80008e58:	31 00       	mov	r0,16
80008e5a:	fa f9 06 90 	ld.w	r9,sp[1680]
80008e5e:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008e62:	fe ca bb ea 	sub	r10,pc,-17430
80008e66:	59 06       	cp.w	r6,16
80008e68:	fe 99 ff dd 	brgt	80008e22 <_vfprintf_r+0x199e>
80008e6c:	0c 09       	add	r9,r6
80008e6e:	87 0a       	st.w	r3[0x0],r10
80008e70:	fb 49 06 90 	st.w	sp[1680],r9
80008e74:	2f f8       	sub	r8,-1
80008e76:	87 16       	st.w	r3[0x4],r6
80008e78:	c5 39       	rjmp	8000911e <_vfprintf_r+0x1c9a>
80008e7a:	fa fa 06 ac 	ld.w	r10,sp[1708]
80008e7e:	58 0a       	cp.w	r10,0
80008e80:	e0 89 00 92 	brgt	80008fa4 <_vfprintf_r+0x1b20>
80008e84:	fa f8 06 90 	ld.w	r8,sp[1680]
80008e88:	fe c9 bc 24 	sub	r9,pc,-17372
80008e8c:	2f f8       	sub	r8,-1
80008e8e:	87 09       	st.w	r3[0x0],r9
80008e90:	fb 48 06 90 	st.w	sp[1680],r8
80008e94:	30 19       	mov	r9,1
80008e96:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008e9a:	87 19       	st.w	r3[0x4],r9
80008e9c:	2f f8       	sub	r8,-1
80008e9e:	fb 48 06 8c 	st.w	sp[1676],r8
80008ea2:	58 78       	cp.w	r8,7
80008ea4:	e0 89 00 04 	brgt	80008eac <_vfprintf_r+0x1a28>
80008ea8:	2f 83       	sub	r3,-8
80008eaa:	c0 b8       	rjmp	80008ec0 <_vfprintf_r+0x1a3c>
80008eac:	fa ca f9 78 	sub	r10,sp,-1672
80008eb0:	02 9b       	mov	r11,r1
80008eb2:	08 9c       	mov	r12,r4
80008eb4:	fe b0 f2 da 	rcall	80007468 <__sprint_r>
80008eb8:	e0 81 02 65 	brne	80009382 <_vfprintf_r+0x1efe>
80008ebc:	fa c3 f9 e0 	sub	r3,sp,-1568
80008ec0:	fa f8 06 ac 	ld.w	r8,sp[1708]
80008ec4:	58 08       	cp.w	r8,0
80008ec6:	c0 81       	brne	80008ed6 <_vfprintf_r+0x1a52>
80008ec8:	40 6a       	lddsp	r10,sp[0x18]
80008eca:	58 0a       	cp.w	r10,0
80008ecc:	c0 51       	brne	80008ed6 <_vfprintf_r+0x1a52>
80008ece:	ed b5 00 00 	bld	r5,0x0
80008ed2:	e0 81 01 ed 	brne	800092ac <_vfprintf_r+0x1e28>
80008ed6:	40 c9       	lddsp	r9,sp[0x30]
80008ed8:	fa f8 06 90 	ld.w	r8,sp[1680]
80008edc:	2f f8       	sub	r8,-1
80008ede:	87 09       	st.w	r3[0x0],r9
80008ee0:	fb 48 06 90 	st.w	sp[1680],r8
80008ee4:	30 19       	mov	r9,1
80008ee6:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008eea:	87 19       	st.w	r3[0x4],r9
80008eec:	2f f8       	sub	r8,-1
80008eee:	fb 48 06 8c 	st.w	sp[1676],r8
80008ef2:	58 78       	cp.w	r8,7
80008ef4:	e0 89 00 04 	brgt	80008efc <_vfprintf_r+0x1a78>
80008ef8:	2f 83       	sub	r3,-8
80008efa:	c0 b8       	rjmp	80008f10 <_vfprintf_r+0x1a8c>
80008efc:	fa ca f9 78 	sub	r10,sp,-1672
80008f00:	02 9b       	mov	r11,r1
80008f02:	08 9c       	mov	r12,r4
80008f04:	fe b0 f2 b2 	rcall	80007468 <__sprint_r>
80008f08:	e0 81 02 3d 	brne	80009382 <_vfprintf_r+0x1efe>
80008f0c:	fa c3 f9 e0 	sub	r3,sp,-1568
80008f10:	fa f2 06 ac 	ld.w	r2,sp[1708]
80008f14:	5c 32       	neg	r2
80008f16:	58 02       	cp.w	r2,0
80008f18:	e0 89 00 1d 	brgt	80008f52 <_vfprintf_r+0x1ace>
80008f1c:	c3 d8       	rjmp	80008f96 <_vfprintf_r+0x1b12>
80008f1e:	2f 09       	sub	r9,-16
80008f20:	2f f8       	sub	r8,-1
80008f22:	31 0e       	mov	lr,16
80008f24:	fb 49 06 90 	st.w	sp[1680],r9
80008f28:	87 00       	st.w	r3[0x0],r0
80008f2a:	87 1e       	st.w	r3[0x4],lr
80008f2c:	fb 48 06 8c 	st.w	sp[1676],r8
80008f30:	58 78       	cp.w	r8,7
80008f32:	e0 89 00 04 	brgt	80008f3a <_vfprintf_r+0x1ab6>
80008f36:	2f 83       	sub	r3,-8
80008f38:	c0 b8       	rjmp	80008f4e <_vfprintf_r+0x1aca>
80008f3a:	fa ca f9 78 	sub	r10,sp,-1672
80008f3e:	02 9b       	mov	r11,r1
80008f40:	08 9c       	mov	r12,r4
80008f42:	fe b0 f2 93 	rcall	80007468 <__sprint_r>
80008f46:	e0 81 02 1e 	brne	80009382 <_vfprintf_r+0x1efe>
80008f4a:	fa c3 f9 e0 	sub	r3,sp,-1568
80008f4e:	21 02       	sub	r2,16
80008f50:	c0 38       	rjmp	80008f56 <_vfprintf_r+0x1ad2>
80008f52:	fe c0 bc da 	sub	r0,pc,-17190
80008f56:	fa f9 06 90 	ld.w	r9,sp[1680]
80008f5a:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008f5e:	fe ca bc e6 	sub	r10,pc,-17178
80008f62:	59 02       	cp.w	r2,16
80008f64:	fe 99 ff dd 	brgt	80008f1e <_vfprintf_r+0x1a9a>
80008f68:	04 09       	add	r9,r2
80008f6a:	2f f8       	sub	r8,-1
80008f6c:	87 0a       	st.w	r3[0x0],r10
80008f6e:	fb 49 06 90 	st.w	sp[1680],r9
80008f72:	87 12       	st.w	r3[0x4],r2
80008f74:	fb 48 06 8c 	st.w	sp[1676],r8
80008f78:	58 78       	cp.w	r8,7
80008f7a:	e0 89 00 04 	brgt	80008f82 <_vfprintf_r+0x1afe>
80008f7e:	2f 83       	sub	r3,-8
80008f80:	c0 b8       	rjmp	80008f96 <_vfprintf_r+0x1b12>
80008f82:	fa ca f9 78 	sub	r10,sp,-1672
80008f86:	02 9b       	mov	r11,r1
80008f88:	08 9c       	mov	r12,r4
80008f8a:	fe b0 f2 6f 	rcall	80007468 <__sprint_r>
80008f8e:	e0 81 01 fa 	brne	80009382 <_vfprintf_r+0x1efe>
80008f92:	fa c3 f9 e0 	sub	r3,sp,-1568
80008f96:	40 6c       	lddsp	r12,sp[0x18]
80008f98:	fa f8 06 90 	ld.w	r8,sp[1680]
80008f9c:	87 06       	st.w	r3[0x0],r6
80008f9e:	87 1c       	st.w	r3[0x4],r12
80008fa0:	18 08       	add	r8,r12
80008fa2:	cb 98       	rjmp	80009114 <_vfprintf_r+0x1c90>
80008fa4:	fa f9 06 90 	ld.w	r9,sp[1680]
80008fa8:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008fac:	40 6b       	lddsp	r11,sp[0x18]
80008fae:	16 3a       	cp.w	r10,r11
80008fb0:	c6 f5       	brlt	8000908e <_vfprintf_r+0x1c0a>
80008fb2:	16 09       	add	r9,r11
80008fb4:	2f f8       	sub	r8,-1
80008fb6:	87 06       	st.w	r3[0x0],r6
80008fb8:	fb 49 06 90 	st.w	sp[1680],r9
80008fbc:	87 1b       	st.w	r3[0x4],r11
80008fbe:	fb 48 06 8c 	st.w	sp[1676],r8
80008fc2:	58 78       	cp.w	r8,7
80008fc4:	e0 89 00 04 	brgt	80008fcc <_vfprintf_r+0x1b48>
80008fc8:	2f 83       	sub	r3,-8
80008fca:	c0 b8       	rjmp	80008fe0 <_vfprintf_r+0x1b5c>
80008fcc:	fa ca f9 78 	sub	r10,sp,-1672
80008fd0:	02 9b       	mov	r11,r1
80008fd2:	08 9c       	mov	r12,r4
80008fd4:	fe b0 f2 4a 	rcall	80007468 <__sprint_r>
80008fd8:	e0 81 01 d5 	brne	80009382 <_vfprintf_r+0x1efe>
80008fdc:	fa c3 f9 e0 	sub	r3,sp,-1568
80008fe0:	fa f6 06 ac 	ld.w	r6,sp[1708]
80008fe4:	40 6a       	lddsp	r10,sp[0x18]
80008fe6:	14 16       	sub	r6,r10
80008fe8:	58 06       	cp.w	r6,0
80008fea:	e0 89 00 1c 	brgt	80009022 <_vfprintf_r+0x1b9e>
80008fee:	c3 d8       	rjmp	80009068 <_vfprintf_r+0x1be4>
80008ff0:	2f 09       	sub	r9,-16
80008ff2:	2f f8       	sub	r8,-1
80008ff4:	fb 49 06 90 	st.w	sp[1680],r9
80008ff8:	87 02       	st.w	r3[0x0],r2
80008ffa:	87 10       	st.w	r3[0x4],r0
80008ffc:	fb 48 06 8c 	st.w	sp[1676],r8
80009000:	58 78       	cp.w	r8,7
80009002:	e0 89 00 04 	brgt	8000900a <_vfprintf_r+0x1b86>
80009006:	2f 83       	sub	r3,-8
80009008:	c0 b8       	rjmp	8000901e <_vfprintf_r+0x1b9a>
8000900a:	fa ca f9 78 	sub	r10,sp,-1672
8000900e:	02 9b       	mov	r11,r1
80009010:	08 9c       	mov	r12,r4
80009012:	fe b0 f2 2b 	rcall	80007468 <__sprint_r>
80009016:	e0 81 01 b6 	brne	80009382 <_vfprintf_r+0x1efe>
8000901a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000901e:	21 06       	sub	r6,16
80009020:	c0 48       	rjmp	80009028 <_vfprintf_r+0x1ba4>
80009022:	fe c2 bd aa 	sub	r2,pc,-16982
80009026:	31 00       	mov	r0,16
80009028:	fa f9 06 90 	ld.w	r9,sp[1680]
8000902c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009030:	fe ca bd b8 	sub	r10,pc,-16968
80009034:	59 06       	cp.w	r6,16
80009036:	fe 99 ff dd 	brgt	80008ff0 <_vfprintf_r+0x1b6c>
8000903a:	0c 09       	add	r9,r6
8000903c:	2f f8       	sub	r8,-1
8000903e:	87 0a       	st.w	r3[0x0],r10
80009040:	fb 49 06 90 	st.w	sp[1680],r9
80009044:	87 16       	st.w	r3[0x4],r6
80009046:	fb 48 06 8c 	st.w	sp[1676],r8
8000904a:	58 78       	cp.w	r8,7
8000904c:	e0 89 00 04 	brgt	80009054 <_vfprintf_r+0x1bd0>
80009050:	2f 83       	sub	r3,-8
80009052:	c0 b8       	rjmp	80009068 <_vfprintf_r+0x1be4>
80009054:	fa ca f9 78 	sub	r10,sp,-1672
80009058:	02 9b       	mov	r11,r1
8000905a:	08 9c       	mov	r12,r4
8000905c:	fe b0 f2 06 	rcall	80007468 <__sprint_r>
80009060:	e0 81 01 91 	brne	80009382 <_vfprintf_r+0x1efe>
80009064:	fa c3 f9 e0 	sub	r3,sp,-1568
80009068:	ed b5 00 00 	bld	r5,0x0
8000906c:	e0 81 01 20 	brne	800092ac <_vfprintf_r+0x1e28>
80009070:	40 c9       	lddsp	r9,sp[0x30]
80009072:	fa f8 06 90 	ld.w	r8,sp[1680]
80009076:	2f f8       	sub	r8,-1
80009078:	87 09       	st.w	r3[0x0],r9
8000907a:	fb 48 06 90 	st.w	sp[1680],r8
8000907e:	30 19       	mov	r9,1
80009080:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009084:	87 19       	st.w	r3[0x4],r9
80009086:	2f f8       	sub	r8,-1
80009088:	fb 48 06 8c 	st.w	sp[1676],r8
8000908c:	c0 29       	rjmp	80009290 <_vfprintf_r+0x1e0c>
8000908e:	14 09       	add	r9,r10
80009090:	2f f8       	sub	r8,-1
80009092:	fb 49 06 90 	st.w	sp[1680],r9
80009096:	87 06       	st.w	r3[0x0],r6
80009098:	87 1a       	st.w	r3[0x4],r10
8000909a:	fb 48 06 8c 	st.w	sp[1676],r8
8000909e:	58 78       	cp.w	r8,7
800090a0:	e0 89 00 04 	brgt	800090a8 <_vfprintf_r+0x1c24>
800090a4:	2f 83       	sub	r3,-8
800090a6:	c0 b8       	rjmp	800090bc <_vfprintf_r+0x1c38>
800090a8:	fa ca f9 78 	sub	r10,sp,-1672
800090ac:	02 9b       	mov	r11,r1
800090ae:	08 9c       	mov	r12,r4
800090b0:	fe b0 f1 dc 	rcall	80007468 <__sprint_r>
800090b4:	e0 81 01 67 	brne	80009382 <_vfprintf_r+0x1efe>
800090b8:	fa c3 f9 e0 	sub	r3,sp,-1568
800090bc:	40 c8       	lddsp	r8,sp[0x30]
800090be:	87 08       	st.w	r3[0x0],r8
800090c0:	fa f8 06 90 	ld.w	r8,sp[1680]
800090c4:	2f f8       	sub	r8,-1
800090c6:	30 19       	mov	r9,1
800090c8:	fb 48 06 90 	st.w	sp[1680],r8
800090cc:	87 19       	st.w	r3[0x4],r9
800090ce:	fa f8 06 8c 	ld.w	r8,sp[1676]
800090d2:	2f f8       	sub	r8,-1
800090d4:	fb 48 06 8c 	st.w	sp[1676],r8
800090d8:	fa f2 06 ac 	ld.w	r2,sp[1708]
800090dc:	58 78       	cp.w	r8,7
800090de:	e0 89 00 04 	brgt	800090e6 <_vfprintf_r+0x1c62>
800090e2:	2f 83       	sub	r3,-8
800090e4:	c0 b8       	rjmp	800090fa <_vfprintf_r+0x1c76>
800090e6:	fa ca f9 78 	sub	r10,sp,-1672
800090ea:	02 9b       	mov	r11,r1
800090ec:	08 9c       	mov	r12,r4
800090ee:	fe b0 f1 bd 	rcall	80007468 <__sprint_r>
800090f2:	e0 81 01 48 	brne	80009382 <_vfprintf_r+0x1efe>
800090f6:	fa c3 f9 e0 	sub	r3,sp,-1568
800090fa:	04 06       	add	r6,r2
800090fc:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009100:	87 06       	st.w	r3[0x0],r6
80009102:	fa f9 06 90 	ld.w	r9,sp[1680]
80009106:	40 66       	lddsp	r6,sp[0x18]
80009108:	40 6e       	lddsp	lr,sp[0x18]
8000910a:	10 16       	sub	r6,r8
8000910c:	f2 08 01 08 	sub	r8,r9,r8
80009110:	87 16       	st.w	r3[0x4],r6
80009112:	1c 08       	add	r8,lr
80009114:	fb 48 06 90 	st.w	sp[1680],r8
80009118:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000911c:	2f f8       	sub	r8,-1
8000911e:	fb 48 06 8c 	st.w	sp[1676],r8
80009122:	cb 78       	rjmp	80009290 <_vfprintf_r+0x1e0c>
80009124:	40 6c       	lddsp	r12,sp[0x18]
80009126:	58 1c       	cp.w	r12,1
80009128:	e0 89 00 06 	brgt	80009134 <_vfprintf_r+0x1cb0>
8000912c:	ed b5 00 00 	bld	r5,0x0
80009130:	e0 81 00 85 	brne	8000923a <_vfprintf_r+0x1db6>
80009134:	fa f8 06 90 	ld.w	r8,sp[1680]
80009138:	2f f8       	sub	r8,-1
8000913a:	30 19       	mov	r9,1
8000913c:	fb 48 06 90 	st.w	sp[1680],r8
80009140:	87 06       	st.w	r3[0x0],r6
80009142:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009146:	87 19       	st.w	r3[0x4],r9
80009148:	2f f8       	sub	r8,-1
8000914a:	fb 48 06 8c 	st.w	sp[1676],r8
8000914e:	58 78       	cp.w	r8,7
80009150:	e0 89 00 04 	brgt	80009158 <_vfprintf_r+0x1cd4>
80009154:	2f 83       	sub	r3,-8
80009156:	c0 b8       	rjmp	8000916c <_vfprintf_r+0x1ce8>
80009158:	fa ca f9 78 	sub	r10,sp,-1672
8000915c:	02 9b       	mov	r11,r1
8000915e:	08 9c       	mov	r12,r4
80009160:	fe b0 f1 84 	rcall	80007468 <__sprint_r>
80009164:	e0 81 01 0f 	brne	80009382 <_vfprintf_r+0x1efe>
80009168:	fa c3 f9 e0 	sub	r3,sp,-1568
8000916c:	fa f8 06 90 	ld.w	r8,sp[1680]
80009170:	2f f8       	sub	r8,-1
80009172:	40 cb       	lddsp	r11,sp[0x30]
80009174:	fb 48 06 90 	st.w	sp[1680],r8
80009178:	30 19       	mov	r9,1
8000917a:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000917e:	87 0b       	st.w	r3[0x0],r11
80009180:	2f f8       	sub	r8,-1
80009182:	87 19       	st.w	r3[0x4],r9
80009184:	fb 48 06 8c 	st.w	sp[1676],r8
80009188:	58 78       	cp.w	r8,7
8000918a:	e0 89 00 05 	brgt	80009194 <_vfprintf_r+0x1d10>
8000918e:	2f 83       	sub	r3,-8
80009190:	c0 c8       	rjmp	800091a8 <_vfprintf_r+0x1d24>
80009192:	d7 03       	nop
80009194:	fa ca f9 78 	sub	r10,sp,-1672
80009198:	02 9b       	mov	r11,r1
8000919a:	08 9c       	mov	r12,r4
8000919c:	fe b0 f1 66 	rcall	80007468 <__sprint_r>
800091a0:	e0 81 00 f1 	brne	80009382 <_vfprintf_r+0x1efe>
800091a4:	fa c3 f9 e0 	sub	r3,sp,-1568
800091a8:	30 08       	mov	r8,0
800091aa:	30 09       	mov	r9,0
800091ac:	40 5b       	lddsp	r11,sp[0x14]
800091ae:	40 7a       	lddsp	r10,sp[0x1c]
800091b0:	e0 a0 13 19 	rcall	8000b7e2 <__avr32_f64_cmp_eq>
800091b4:	40 68       	lddsp	r8,sp[0x18]
800091b6:	20 18       	sub	r8,1
800091b8:	58 0c       	cp.w	r12,0
800091ba:	c0 d1       	brne	800091d4 <_vfprintf_r+0x1d50>
800091bc:	2f f6       	sub	r6,-1
800091be:	87 18       	st.w	r3[0x4],r8
800091c0:	87 06       	st.w	r3[0x0],r6
800091c2:	fa f6 06 90 	ld.w	r6,sp[1680]
800091c6:	10 06       	add	r6,r8
800091c8:	fa f8 06 8c 	ld.w	r8,sp[1676]
800091cc:	fb 46 06 90 	st.w	sp[1680],r6
800091d0:	2f f8       	sub	r8,-1
800091d2:	c3 18       	rjmp	80009234 <_vfprintf_r+0x1db0>
800091d4:	10 96       	mov	r6,r8
800091d6:	58 08       	cp.w	r8,0
800091d8:	e0 89 00 1c 	brgt	80009210 <_vfprintf_r+0x1d8c>
800091dc:	c4 b8       	rjmp	80009272 <_vfprintf_r+0x1dee>
800091de:	2f 09       	sub	r9,-16
800091e0:	2f f8       	sub	r8,-1
800091e2:	fb 49 06 90 	st.w	sp[1680],r9
800091e6:	87 02       	st.w	r3[0x0],r2
800091e8:	87 10       	st.w	r3[0x4],r0
800091ea:	fb 48 06 8c 	st.w	sp[1676],r8
800091ee:	58 78       	cp.w	r8,7
800091f0:	e0 89 00 04 	brgt	800091f8 <_vfprintf_r+0x1d74>
800091f4:	2f 83       	sub	r3,-8
800091f6:	c0 b8       	rjmp	8000920c <_vfprintf_r+0x1d88>
800091f8:	fa ca f9 78 	sub	r10,sp,-1672
800091fc:	02 9b       	mov	r11,r1
800091fe:	08 9c       	mov	r12,r4
80009200:	fe b0 f1 34 	rcall	80007468 <__sprint_r>
80009204:	e0 81 00 bf 	brne	80009382 <_vfprintf_r+0x1efe>
80009208:	fa c3 f9 e0 	sub	r3,sp,-1568
8000920c:	21 06       	sub	r6,16
8000920e:	c0 48       	rjmp	80009216 <_vfprintf_r+0x1d92>
80009210:	fe c2 bf 98 	sub	r2,pc,-16488
80009214:	31 00       	mov	r0,16
80009216:	fa f9 06 90 	ld.w	r9,sp[1680]
8000921a:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000921e:	fe ca bf a6 	sub	r10,pc,-16474
80009222:	59 06       	cp.w	r6,16
80009224:	fe 99 ff dd 	brgt	800091de <_vfprintf_r+0x1d5a>
80009228:	0c 09       	add	r9,r6
8000922a:	87 0a       	st.w	r3[0x0],r10
8000922c:	fb 49 06 90 	st.w	sp[1680],r9
80009230:	2f f8       	sub	r8,-1
80009232:	87 16       	st.w	r3[0x4],r6
80009234:	fb 48 06 8c 	st.w	sp[1676],r8
80009238:	c0 e8       	rjmp	80009254 <_vfprintf_r+0x1dd0>
8000923a:	fa f8 06 90 	ld.w	r8,sp[1680]
8000923e:	2f f8       	sub	r8,-1
80009240:	30 19       	mov	r9,1
80009242:	fb 48 06 90 	st.w	sp[1680],r8
80009246:	87 06       	st.w	r3[0x0],r6
80009248:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000924c:	87 19       	st.w	r3[0x4],r9
8000924e:	2f f8       	sub	r8,-1
80009250:	fb 48 06 8c 	st.w	sp[1676],r8
80009254:	58 78       	cp.w	r8,7
80009256:	e0 89 00 04 	brgt	8000925e <_vfprintf_r+0x1dda>
8000925a:	2f 83       	sub	r3,-8
8000925c:	c0 b8       	rjmp	80009272 <_vfprintf_r+0x1dee>
8000925e:	fa ca f9 78 	sub	r10,sp,-1672
80009262:	02 9b       	mov	r11,r1
80009264:	08 9c       	mov	r12,r4
80009266:	fe b0 f1 01 	rcall	80007468 <__sprint_r>
8000926a:	e0 81 00 8c 	brne	80009382 <_vfprintf_r+0x1efe>
8000926e:	fa c3 f9 e0 	sub	r3,sp,-1568
80009272:	40 ea       	lddsp	r10,sp[0x38]
80009274:	fa f8 06 90 	ld.w	r8,sp[1680]
80009278:	14 08       	add	r8,r10
8000927a:	fa c9 f9 64 	sub	r9,sp,-1692
8000927e:	fb 48 06 90 	st.w	sp[1680],r8
80009282:	87 1a       	st.w	r3[0x4],r10
80009284:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009288:	87 09       	st.w	r3[0x0],r9
8000928a:	2f f8       	sub	r8,-1
8000928c:	fb 48 06 8c 	st.w	sp[1676],r8
80009290:	58 78       	cp.w	r8,7
80009292:	e0 89 00 04 	brgt	8000929a <_vfprintf_r+0x1e16>
80009296:	2f 83       	sub	r3,-8
80009298:	c0 a8       	rjmp	800092ac <_vfprintf_r+0x1e28>
8000929a:	fa ca f9 78 	sub	r10,sp,-1672
8000929e:	02 9b       	mov	r11,r1
800092a0:	08 9c       	mov	r12,r4
800092a2:	fe b0 f0 e3 	rcall	80007468 <__sprint_r>
800092a6:	c6 e1       	brne	80009382 <_vfprintf_r+0x1efe>
800092a8:	fa c3 f9 e0 	sub	r3,sp,-1568
800092ac:	e2 15 00 04 	andl	r5,0x4,COH
800092b0:	c3 f0       	breq	8000932e <_vfprintf_r+0x1eaa>
800092b2:	40 86       	lddsp	r6,sp[0x20]
800092b4:	40 39       	lddsp	r9,sp[0xc]
800092b6:	12 16       	sub	r6,r9
800092b8:	58 06       	cp.w	r6,0
800092ba:	e0 89 00 1a 	brgt	800092ee <_vfprintf_r+0x1e6a>
800092be:	c3 88       	rjmp	8000932e <_vfprintf_r+0x1eaa>
800092c0:	2f 09       	sub	r9,-16
800092c2:	2f f8       	sub	r8,-1
800092c4:	fb 49 06 90 	st.w	sp[1680],r9
800092c8:	87 05       	st.w	r3[0x0],r5
800092ca:	87 12       	st.w	r3[0x4],r2
800092cc:	fb 48 06 8c 	st.w	sp[1676],r8
800092d0:	58 78       	cp.w	r8,7
800092d2:	e0 89 00 04 	brgt	800092da <_vfprintf_r+0x1e56>
800092d6:	2f 83       	sub	r3,-8
800092d8:	c0 98       	rjmp	800092ea <_vfprintf_r+0x1e66>
800092da:	00 9a       	mov	r10,r0
800092dc:	02 9b       	mov	r11,r1
800092de:	08 9c       	mov	r12,r4
800092e0:	fe b0 f0 c4 	rcall	80007468 <__sprint_r>
800092e4:	c4 f1       	brne	80009382 <_vfprintf_r+0x1efe>
800092e6:	fa c3 f9 e0 	sub	r3,sp,-1568
800092ea:	21 06       	sub	r6,16
800092ec:	c0 68       	rjmp	800092f8 <_vfprintf_r+0x1e74>
800092ee:	fe c5 c0 86 	sub	r5,pc,-16250
800092f2:	31 02       	mov	r2,16
800092f4:	fa c0 f9 78 	sub	r0,sp,-1672
800092f8:	fa f9 06 90 	ld.w	r9,sp[1680]
800092fc:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009300:	fe ca c0 98 	sub	r10,pc,-16232
80009304:	59 06       	cp.w	r6,16
80009306:	fe 99 ff dd 	brgt	800092c0 <_vfprintf_r+0x1e3c>
8000930a:	0c 09       	add	r9,r6
8000930c:	2f f8       	sub	r8,-1
8000930e:	87 0a       	st.w	r3[0x0],r10
80009310:	87 16       	st.w	r3[0x4],r6
80009312:	fb 49 06 90 	st.w	sp[1680],r9
80009316:	fb 48 06 8c 	st.w	sp[1676],r8
8000931a:	58 78       	cp.w	r8,7
8000931c:	e0 8a 00 09 	brle	8000932e <_vfprintf_r+0x1eaa>
80009320:	fa ca f9 78 	sub	r10,sp,-1672
80009324:	02 9b       	mov	r11,r1
80009326:	08 9c       	mov	r12,r4
80009328:	fe b0 f0 a0 	rcall	80007468 <__sprint_r>
8000932c:	c2 b1       	brne	80009382 <_vfprintf_r+0x1efe>
8000932e:	40 bc       	lddsp	r12,sp[0x2c]
80009330:	40 36       	lddsp	r6,sp[0xc]
80009332:	40 8e       	lddsp	lr,sp[0x20]
80009334:	ec 0e 0c 48 	max	r8,r6,lr
80009338:	10 0c       	add	r12,r8
8000933a:	50 bc       	stdsp	sp[0x2c],r12
8000933c:	fa f8 06 90 	ld.w	r8,sp[1680]
80009340:	58 08       	cp.w	r8,0
80009342:	c0 80       	breq	80009352 <_vfprintf_r+0x1ece>
80009344:	fa ca f9 78 	sub	r10,sp,-1672
80009348:	02 9b       	mov	r11,r1
8000934a:	08 9c       	mov	r12,r4
8000934c:	fe b0 f0 8e 	rcall	80007468 <__sprint_r>
80009350:	c1 91       	brne	80009382 <_vfprintf_r+0x1efe>
80009352:	30 0b       	mov	r11,0
80009354:	fa c3 f9 e0 	sub	r3,sp,-1568
80009358:	fb 4b 06 8c 	st.w	sp[1676],r11
8000935c:	fe 9f f1 22 	bral	800075a0 <_vfprintf_r+0x11c>
80009360:	08 95       	mov	r5,r4
80009362:	fa f8 06 90 	ld.w	r8,sp[1680]
80009366:	58 08       	cp.w	r8,0
80009368:	c0 80       	breq	80009378 <_vfprintf_r+0x1ef4>
8000936a:	08 9c       	mov	r12,r4
8000936c:	fa ca f9 78 	sub	r10,sp,-1672
80009370:	02 9b       	mov	r11,r1
80009372:	fe b0 f0 7b 	rcall	80007468 <__sprint_r>
80009376:	c0 61       	brne	80009382 <_vfprintf_r+0x1efe>
80009378:	30 08       	mov	r8,0
8000937a:	fb 48 06 8c 	st.w	sp[1676],r8
8000937e:	c0 28       	rjmp	80009382 <_vfprintf_r+0x1efe>
80009380:	40 41       	lddsp	r1,sp[0x10]
80009382:	82 68       	ld.sh	r8,r1[0xc]
80009384:	ed b8 00 06 	bld	r8,0x6
80009388:	c0 31       	brne	8000938e <_vfprintf_r+0x1f0a>
8000938a:	3f fa       	mov	r10,-1
8000938c:	50 ba       	stdsp	sp[0x2c],r10
8000938e:	40 bc       	lddsp	r12,sp[0x2c]
80009390:	fe 3d f9 44 	sub	sp,-1724
80009394:	d8 32       	popm	r0-r7,pc
80009396:	d7 03       	nop

80009398 <__swsetup_r>:
80009398:	d4 21       	pushm	r4-r7,lr
8000939a:	e0 68 0a 30 	mov	r8,2608
8000939e:	18 96       	mov	r6,r12
800093a0:	16 97       	mov	r7,r11
800093a2:	70 0c       	ld.w	r12,r8[0x0]
800093a4:	58 0c       	cp.w	r12,0
800093a6:	c0 60       	breq	800093b2 <__swsetup_r+0x1a>
800093a8:	78 68       	ld.w	r8,r12[0x18]
800093aa:	58 08       	cp.w	r8,0
800093ac:	c0 31       	brne	800093b2 <__swsetup_r+0x1a>
800093ae:	e0 a0 07 bf 	rcall	8000a32c <__sinit>
800093b2:	fe c8 c0 1a 	sub	r8,pc,-16358
800093b6:	10 37       	cp.w	r7,r8
800093b8:	c0 61       	brne	800093c4 <__swsetup_r+0x2c>
800093ba:	e0 68 0a 30 	mov	r8,2608
800093be:	70 08       	ld.w	r8,r8[0x0]
800093c0:	70 07       	ld.w	r7,r8[0x0]
800093c2:	c1 28       	rjmp	800093e6 <__swsetup_r+0x4e>
800093c4:	fe c8 c0 0c 	sub	r8,pc,-16372
800093c8:	10 37       	cp.w	r7,r8
800093ca:	c0 61       	brne	800093d6 <__swsetup_r+0x3e>
800093cc:	e0 68 0a 30 	mov	r8,2608
800093d0:	70 08       	ld.w	r8,r8[0x0]
800093d2:	70 17       	ld.w	r7,r8[0x4]
800093d4:	c0 98       	rjmp	800093e6 <__swsetup_r+0x4e>
800093d6:	fe c8 bf fe 	sub	r8,pc,-16386
800093da:	10 37       	cp.w	r7,r8
800093dc:	c0 51       	brne	800093e6 <__swsetup_r+0x4e>
800093de:	e0 68 0a 30 	mov	r8,2608
800093e2:	70 08       	ld.w	r8,r8[0x0]
800093e4:	70 27       	ld.w	r7,r8[0x8]
800093e6:	8e 68       	ld.sh	r8,r7[0xc]
800093e8:	ed b8 00 03 	bld	r8,0x3
800093ec:	c1 e0       	breq	80009428 <__swsetup_r+0x90>
800093ee:	ed b8 00 04 	bld	r8,0x4
800093f2:	c3 e1       	brne	8000946e <__swsetup_r+0xd6>
800093f4:	ed b8 00 02 	bld	r8,0x2
800093f8:	c1 51       	brne	80009422 <__swsetup_r+0x8a>
800093fa:	6e db       	ld.w	r11,r7[0x34]
800093fc:	58 0b       	cp.w	r11,0
800093fe:	c0 a0       	breq	80009412 <__swsetup_r+0x7a>
80009400:	ee c8 ff bc 	sub	r8,r7,-68
80009404:	10 3b       	cp.w	r11,r8
80009406:	c0 40       	breq	8000940e <__swsetup_r+0x76>
80009408:	0c 9c       	mov	r12,r6
8000940a:	e0 a0 08 2b 	rcall	8000a460 <_free_r>
8000940e:	30 08       	mov	r8,0
80009410:	8f d8       	st.w	r7[0x34],r8
80009412:	8e 68       	ld.sh	r8,r7[0xc]
80009414:	e0 18 ff db 	andl	r8,0xffdb
80009418:	ae 68       	st.h	r7[0xc],r8
8000941a:	30 08       	mov	r8,0
8000941c:	8f 18       	st.w	r7[0x4],r8
8000941e:	6e 48       	ld.w	r8,r7[0x10]
80009420:	8f 08       	st.w	r7[0x0],r8
80009422:	8e 68       	ld.sh	r8,r7[0xc]
80009424:	a3 b8       	sbr	r8,0x3
80009426:	ae 68       	st.h	r7[0xc],r8
80009428:	6e 48       	ld.w	r8,r7[0x10]
8000942a:	58 08       	cp.w	r8,0
8000942c:	c0 b1       	brne	80009442 <__swsetup_r+0xaa>
8000942e:	8e 68       	ld.sh	r8,r7[0xc]
80009430:	e2 18 02 80 	andl	r8,0x280,COH
80009434:	e0 48 02 00 	cp.w	r8,512
80009438:	c0 50       	breq	80009442 <__swsetup_r+0xaa>
8000943a:	0c 9c       	mov	r12,r6
8000943c:	0e 9b       	mov	r11,r7
8000943e:	e0 a0 0a 4b 	rcall	8000a8d4 <__smakebuf_r>
80009442:	8e 69       	ld.sh	r9,r7[0xc]
80009444:	f1 d9 c0 01 	bfextu	r8,r9,0x0,0x1
80009448:	c0 70       	breq	80009456 <__swsetup_r+0xbe>
8000944a:	30 08       	mov	r8,0
8000944c:	8f 28       	st.w	r7[0x8],r8
8000944e:	6e 58       	ld.w	r8,r7[0x14]
80009450:	5c 38       	neg	r8
80009452:	8f 68       	st.w	r7[0x18],r8
80009454:	c0 68       	rjmp	80009460 <__swsetup_r+0xc8>
80009456:	ed b9 00 01 	bld	r9,0x1
8000945a:	ef f8 10 05 	ld.wne	r8,r7[0x14]
8000945e:	8f 28       	st.w	r7[0x8],r8
80009460:	6e 48       	ld.w	r8,r7[0x10]
80009462:	58 08       	cp.w	r8,0
80009464:	c0 61       	brne	80009470 <__swsetup_r+0xd8>
80009466:	8e 68       	ld.sh	r8,r7[0xc]
80009468:	ed b8 00 07 	bld	r8,0x7
8000946c:	c0 21       	brne	80009470 <__swsetup_r+0xd8>
8000946e:	dc 2a       	popm	r4-r7,pc,r12=-1
80009470:	d8 2a       	popm	r4-r7,pc,r12=0
80009472:	d7 03       	nop

80009474 <quorem>:
80009474:	d4 31       	pushm	r0-r7,lr
80009476:	20 2d       	sub	sp,8
80009478:	18 97       	mov	r7,r12
8000947a:	78 48       	ld.w	r8,r12[0x10]
8000947c:	76 46       	ld.w	r6,r11[0x10]
8000947e:	0c 38       	cp.w	r8,r6
80009480:	c0 34       	brge	80009486 <quorem+0x12>
80009482:	30 0c       	mov	r12,0
80009484:	c8 58       	rjmp	8000958e <quorem+0x11a>
80009486:	ec c2 ff fc 	sub	r2,r6,-4
8000948a:	f6 c3 ff ec 	sub	r3,r11,-20
8000948e:	f6 02 03 29 	ld.w	r9,r11[r2<<0x2]
80009492:	f8 02 03 2c 	ld.w	r12,r12[r2<<0x2]
80009496:	2f f9       	sub	r9,-1
80009498:	20 16       	sub	r6,1
8000949a:	f8 09 0d 08 	divu	r8,r12,r9
8000949e:	f6 02 00 22 	add	r2,r11,r2<<0x2
800094a2:	ee c4 ff ec 	sub	r4,r7,-20
800094a6:	10 95       	mov	r5,r8
800094a8:	58 08       	cp.w	r8,0
800094aa:	c4 10       	breq	8000952c <quorem+0xb8>
800094ac:	30 09       	mov	r9,0
800094ae:	06 9a       	mov	r10,r3
800094b0:	08 98       	mov	r8,r4
800094b2:	12 91       	mov	r1,r9
800094b4:	50 0b       	stdsp	sp[0x0],r11
800094b6:	70 0e       	ld.w	lr,r8[0x0]
800094b8:	b1 8e       	lsr	lr,0x10
800094ba:	50 1e       	stdsp	sp[0x4],lr
800094bc:	15 0e       	ld.w	lr,r10++
800094be:	fc 00 16 10 	lsr	r0,lr,0x10
800094c2:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
800094c6:	ea 0e 03 41 	mac	r1,r5,lr
800094ca:	fd d1 c0 10 	bfextu	lr,r1,0x0,0x10
800094ce:	b1 81       	lsr	r1,0x10
800094d0:	40 1b       	lddsp	r11,sp[0x4]
800094d2:	ea 00 02 40 	mul	r0,r5,r0
800094d6:	e2 00 00 00 	add	r0,r1,r0
800094da:	e3 d0 c0 10 	bfextu	r1,r0,0x0,0x10
800094de:	02 1b       	sub	r11,r1
800094e0:	50 1b       	stdsp	sp[0x4],r11
800094e2:	70 0b       	ld.w	r11,r8[0x0]
800094e4:	e3 db c0 10 	bfextu	r1,r11,0x0,0x10
800094e8:	02 09       	add	r9,r1
800094ea:	f2 0e 01 0e 	sub	lr,r9,lr
800094ee:	b0 1e       	st.h	r8[0x2],lr
800094f0:	fc 09 14 10 	asr	r9,lr,0x10
800094f4:	40 1e       	lddsp	lr,sp[0x4]
800094f6:	fc 09 00 09 	add	r9,lr,r9
800094fa:	b0 09       	st.h	r8[0x0],r9
800094fc:	e0 01 16 10 	lsr	r1,r0,0x10
80009500:	2f c8       	sub	r8,-4
80009502:	b1 49       	asr	r9,0x10
80009504:	04 3a       	cp.w	r10,r2
80009506:	fe 98 ff d8 	brls	800094b6 <quorem+0x42>
8000950a:	40 0b       	lddsp	r11,sp[0x0]
8000950c:	58 0c       	cp.w	r12,0
8000950e:	c0 f1       	brne	8000952c <quorem+0xb8>
80009510:	ec c8 ff fb 	sub	r8,r6,-5
80009514:	ee 08 00 28 	add	r8,r7,r8<<0x2
80009518:	c0 28       	rjmp	8000951c <quorem+0xa8>
8000951a:	20 16       	sub	r6,1
8000951c:	20 48       	sub	r8,4
8000951e:	08 38       	cp.w	r8,r4
80009520:	e0 88 00 05 	brls	8000952a <quorem+0xb6>
80009524:	70 09       	ld.w	r9,r8[0x0]
80009526:	58 09       	cp.w	r9,0
80009528:	cf 90       	breq	8000951a <quorem+0xa6>
8000952a:	8f 46       	st.w	r7[0x10],r6
8000952c:	0e 9c       	mov	r12,r7
8000952e:	e0 a0 0a d2 	rcall	8000aad2 <__mcmp>
80009532:	c2 d5       	brlt	8000958c <quorem+0x118>
80009534:	2f f5       	sub	r5,-1
80009536:	08 98       	mov	r8,r4
80009538:	30 09       	mov	r9,0
8000953a:	07 0b       	ld.w	r11,r3++
8000953c:	f6 0a 16 10 	lsr	r10,r11,0x10
80009540:	70 0c       	ld.w	r12,r8[0x0]
80009542:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
80009546:	f8 0e 16 10 	lsr	lr,r12,0x10
8000954a:	14 1e       	sub	lr,r10
8000954c:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
80009550:	16 1a       	sub	r10,r11
80009552:	12 0a       	add	r10,r9
80009554:	b0 1a       	st.h	r8[0x2],r10
80009556:	b1 4a       	asr	r10,0x10
80009558:	fc 0a 00 09 	add	r9,lr,r10
8000955c:	b0 09       	st.h	r8[0x0],r9
8000955e:	2f c8       	sub	r8,-4
80009560:	b1 49       	asr	r9,0x10
80009562:	04 33       	cp.w	r3,r2
80009564:	fe 98 ff eb 	brls	8000953a <quorem+0xc6>
80009568:	ec c8 ff fb 	sub	r8,r6,-5
8000956c:	ee 08 03 29 	ld.w	r9,r7[r8<<0x2]
80009570:	58 09       	cp.w	r9,0
80009572:	c0 d1       	brne	8000958c <quorem+0x118>
80009574:	ee 08 00 28 	add	r8,r7,r8<<0x2
80009578:	c0 28       	rjmp	8000957c <quorem+0x108>
8000957a:	20 16       	sub	r6,1
8000957c:	20 48       	sub	r8,4
8000957e:	08 38       	cp.w	r8,r4
80009580:	e0 88 00 05 	brls	8000958a <quorem+0x116>
80009584:	70 09       	ld.w	r9,r8[0x0]
80009586:	58 09       	cp.w	r9,0
80009588:	cf 90       	breq	8000957a <quorem+0x106>
8000958a:	8f 46       	st.w	r7[0x10],r6
8000958c:	0a 9c       	mov	r12,r5
8000958e:	2f ed       	sub	sp,-8
80009590:	d8 32       	popm	r0-r7,pc
80009592:	d7 03       	nop

80009594 <_dtoa_r>:
80009594:	d4 31       	pushm	r0-r7,lr
80009596:	21 ad       	sub	sp,104
80009598:	fa c4 ff 74 	sub	r4,sp,-140
8000959c:	18 97       	mov	r7,r12
8000959e:	16 95       	mov	r5,r11
800095a0:	68 2c       	ld.w	r12,r4[0x8]
800095a2:	50 c9       	stdsp	sp[0x30],r9
800095a4:	68 16       	ld.w	r6,r4[0x4]
800095a6:	68 09       	ld.w	r9,r4[0x0]
800095a8:	50 e8       	stdsp	sp[0x38],r8
800095aa:	14 94       	mov	r4,r10
800095ac:	51 2c       	stdsp	sp[0x48],r12
800095ae:	fa e5 00 08 	st.d	sp[8],r4
800095b2:	51 59       	stdsp	sp[0x54],r9
800095b4:	6e 95       	ld.w	r5,r7[0x24]
800095b6:	58 05       	cp.w	r5,0
800095b8:	c0 91       	brne	800095ca <_dtoa_r+0x36>
800095ba:	31 0c       	mov	r12,16
800095bc:	fe b0 e8 e8 	rcall	8000678c <malloc>
800095c0:	99 35       	st.w	r12[0xc],r5
800095c2:	8f 9c       	st.w	r7[0x24],r12
800095c4:	99 15       	st.w	r12[0x4],r5
800095c6:	99 25       	st.w	r12[0x8],r5
800095c8:	99 05       	st.w	r12[0x0],r5
800095ca:	6e 99       	ld.w	r9,r7[0x24]
800095cc:	72 08       	ld.w	r8,r9[0x0]
800095ce:	58 08       	cp.w	r8,0
800095d0:	c0 f0       	breq	800095ee <_dtoa_r+0x5a>
800095d2:	72 1a       	ld.w	r10,r9[0x4]
800095d4:	91 1a       	st.w	r8[0x4],r10
800095d6:	30 1a       	mov	r10,1
800095d8:	72 19       	ld.w	r9,r9[0x4]
800095da:	f4 09 09 49 	lsl	r9,r10,r9
800095de:	10 9b       	mov	r11,r8
800095e0:	91 29       	st.w	r8[0x8],r9
800095e2:	0e 9c       	mov	r12,r7
800095e4:	e0 a0 0a 90 	rcall	8000ab04 <_Bfree>
800095e8:	6e 98       	ld.w	r8,r7[0x24]
800095ea:	30 09       	mov	r9,0
800095ec:	91 09       	st.w	r8[0x0],r9
800095ee:	40 28       	lddsp	r8,sp[0x8]
800095f0:	10 94       	mov	r4,r8
800095f2:	58 08       	cp.w	r8,0
800095f4:	c0 64       	brge	80009600 <_dtoa_r+0x6c>
800095f6:	f1 d8 c0 1f 	bfextu	r8,r8,0x0,0x1f
800095fa:	50 28       	stdsp	sp[0x8],r8
800095fc:	30 18       	mov	r8,1
800095fe:	c0 28       	rjmp	80009602 <_dtoa_r+0x6e>
80009600:	30 08       	mov	r8,0
80009602:	8d 08       	st.w	r6[0x0],r8
80009604:	fc 1c 7f f0 	movh	r12,0x7ff0
80009608:	40 26       	lddsp	r6,sp[0x8]
8000960a:	0c 98       	mov	r8,r6
8000960c:	e6 18 7f f0 	andh	r8,0x7ff0,COH
80009610:	18 38       	cp.w	r8,r12
80009612:	c2 01       	brne	80009652 <_dtoa_r+0xbe>
80009614:	e0 68 27 0f 	mov	r8,9999
80009618:	41 5b       	lddsp	r11,sp[0x54]
8000961a:	97 08       	st.w	r11[0x0],r8
8000961c:	40 3a       	lddsp	r10,sp[0xc]
8000961e:	58 0a       	cp.w	r10,0
80009620:	c0 71       	brne	8000962e <_dtoa_r+0x9a>
80009622:	ed d6 c0 14 	bfextu	r6,r6,0x0,0x14
80009626:	c0 41       	brne	8000962e <_dtoa_r+0x9a>
80009628:	fe cc c2 a0 	sub	r12,pc,-15712
8000962c:	c0 38       	rjmp	80009632 <_dtoa_r+0x9e>
8000962e:	fe cc c2 9a 	sub	r12,pc,-15718
80009632:	41 29       	lddsp	r9,sp[0x48]
80009634:	58 09       	cp.w	r9,0
80009636:	e0 80 05 9a 	breq	8000a16a <_dtoa_r+0xbd6>
8000963a:	f8 c8 ff fd 	sub	r8,r12,-3
8000963e:	f8 c9 ff f8 	sub	r9,r12,-8
80009642:	11 8b       	ld.ub	r11,r8[0x0]
80009644:	30 0a       	mov	r10,0
80009646:	41 25       	lddsp	r5,sp[0x48]
80009648:	f4 0b 18 00 	cp.b	r11,r10
8000964c:	f2 08 17 10 	movne	r8,r9
80009650:	c1 68       	rjmp	8000967c <_dtoa_r+0xe8>
80009652:	fa ea 00 08 	ld.d	r10,sp[8]
80009656:	30 08       	mov	r8,0
80009658:	fa eb 00 3c 	st.d	sp[60],r10
8000965c:	30 09       	mov	r9,0
8000965e:	e0 a0 10 c2 	rcall	8000b7e2 <__avr32_f64_cmp_eq>
80009662:	c1 00       	breq	80009682 <_dtoa_r+0xee>
80009664:	30 18       	mov	r8,1
80009666:	41 5a       	lddsp	r10,sp[0x54]
80009668:	95 08       	st.w	r10[0x0],r8
8000966a:	fe cc c4 06 	sub	r12,pc,-15354
8000966e:	41 29       	lddsp	r9,sp[0x48]
80009670:	f8 08 00 08 	add	r8,r12,r8
80009674:	58 09       	cp.w	r9,0
80009676:	e0 80 05 7a 	breq	8000a16a <_dtoa_r+0xbd6>
8000967a:	12 95       	mov	r5,r9
8000967c:	8b 08       	st.w	r5[0x0],r8
8000967e:	e0 8f 05 76 	bral	8000a16a <_dtoa_r+0xbd6>
80009682:	fa c8 ff 9c 	sub	r8,sp,-100
80009686:	fa c9 ff a0 	sub	r9,sp,-96
8000968a:	fa ea 00 3c 	ld.d	r10,sp[60]
8000968e:	0e 9c       	mov	r12,r7
80009690:	eb d6 c2 8b 	bfextu	r5,r6,0x14,0xb
80009694:	e0 a0 0a 8a 	rcall	8000aba8 <__d2b>
80009698:	18 93       	mov	r3,r12
8000969a:	58 05       	cp.w	r5,0
8000969c:	c0 d0       	breq	800096b6 <_dtoa_r+0x122>
8000969e:	fa ea 00 3c 	ld.d	r10,sp[60]
800096a2:	30 04       	mov	r4,0
800096a4:	f1 db c0 14 	bfextu	r8,r11,0x0,0x14
800096a8:	ea c5 03 ff 	sub	r5,r5,1023
800096ac:	10 9b       	mov	r11,r8
800096ae:	51 74       	stdsp	sp[0x5c],r4
800096b0:	ea 1b 3f f0 	orh	r11,0x3ff0
800096b4:	c2 58       	rjmp	800096fe <_dtoa_r+0x16a>
800096b6:	41 88       	lddsp	r8,sp[0x60]
800096b8:	41 9c       	lddsp	r12,sp[0x64]
800096ba:	10 0c       	add	r12,r8
800096bc:	f8 c5 fb ce 	sub	r5,r12,-1074
800096c0:	e0 45 00 20 	cp.w	r5,32
800096c4:	e0 8a 00 0e 	brle	800096e0 <_dtoa_r+0x14c>
800096c8:	f8 cc fb ee 	sub	r12,r12,-1042
800096cc:	40 3b       	lddsp	r11,sp[0xc]
800096ce:	ea 08 11 40 	rsub	r8,r5,64
800096d2:	f6 0c 0a 4c 	lsr	r12,r11,r12
800096d6:	ec 08 09 46 	lsl	r6,r6,r8
800096da:	0c 4c       	or	r12,r6
800096dc:	c0 78       	rjmp	800096ea <_dtoa_r+0x156>
800096de:	d7 03       	nop
800096e0:	ea 0c 11 20 	rsub	r12,r5,32
800096e4:	40 3a       	lddsp	r10,sp[0xc]
800096e6:	f4 0c 09 4c 	lsl	r12,r10,r12
800096ea:	e0 a0 10 08 	rcall	8000b6fa <__avr32_u32_to_f64>
800096ee:	fc 18 fe 10 	movh	r8,0xfe10
800096f2:	30 19       	mov	r9,1
800096f4:	ea c5 04 33 	sub	r5,r5,1075
800096f8:	f0 0b 00 0b 	add	r11,r8,r11
800096fc:	51 79       	stdsp	sp[0x5c],r9
800096fe:	30 08       	mov	r8,0
80009700:	fc 19 3f f8 	movh	r9,0x3ff8
80009704:	e0 a0 0e 90 	rcall	8000b424 <__avr32_f64_sub>
80009708:	e0 68 43 61 	mov	r8,17249
8000970c:	ea 18 63 6f 	orh	r8,0x636f
80009710:	e0 69 87 a7 	mov	r9,34727
80009714:	ea 19 3f d2 	orh	r9,0x3fd2
80009718:	e0 a0 0d 9a 	rcall	8000b24c <__avr32_f64_mul>
8000971c:	e0 68 c8 b3 	mov	r8,51379
80009720:	ea 18 8b 60 	orh	r8,0x8b60
80009724:	e0 69 8a 28 	mov	r9,35368
80009728:	ea 19 3f c6 	orh	r9,0x3fc6
8000972c:	e0 a0 0f 4a 	rcall	8000b5c0 <__avr32_f64_add>
80009730:	0a 9c       	mov	r12,r5
80009732:	14 90       	mov	r0,r10
80009734:	16 91       	mov	r1,r11
80009736:	e0 a0 0f e6 	rcall	8000b702 <__avr32_s32_to_f64>
8000973a:	e0 68 79 fb 	mov	r8,31227
8000973e:	ea 18 50 9f 	orh	r8,0x509f
80009742:	e0 69 44 13 	mov	r9,17427
80009746:	ea 19 3f d3 	orh	r9,0x3fd3
8000974a:	e0 a0 0d 81 	rcall	8000b24c <__avr32_f64_mul>
8000974e:	14 98       	mov	r8,r10
80009750:	16 99       	mov	r9,r11
80009752:	00 9a       	mov	r10,r0
80009754:	02 9b       	mov	r11,r1
80009756:	e0 a0 0f 35 	rcall	8000b5c0 <__avr32_f64_add>
8000975a:	14 90       	mov	r0,r10
8000975c:	16 91       	mov	r1,r11
8000975e:	e0 a0 0f bb 	rcall	8000b6d4 <__avr32_f64_to_s32>
80009762:	30 08       	mov	r8,0
80009764:	18 96       	mov	r6,r12
80009766:	30 09       	mov	r9,0
80009768:	00 9a       	mov	r10,r0
8000976a:	02 9b       	mov	r11,r1
8000976c:	e0 a0 10 82 	rcall	8000b870 <__avr32_f64_cmp_lt>
80009770:	c0 c0       	breq	80009788 <_dtoa_r+0x1f4>
80009772:	0c 9c       	mov	r12,r6
80009774:	e0 a0 0f c7 	rcall	8000b702 <__avr32_s32_to_f64>
80009778:	14 98       	mov	r8,r10
8000977a:	16 99       	mov	r9,r11
8000977c:	00 9a       	mov	r10,r0
8000977e:	02 9b       	mov	r11,r1
80009780:	e0 a0 10 31 	rcall	8000b7e2 <__avr32_f64_cmp_eq>
80009784:	f7 b6 00 01 	subeq	r6,1
80009788:	59 66       	cp.w	r6,22
8000978a:	e0 88 00 05 	brls	80009794 <_dtoa_r+0x200>
8000978e:	30 18       	mov	r8,1
80009790:	51 48       	stdsp	sp[0x50],r8
80009792:	c1 38       	rjmp	800097b8 <_dtoa_r+0x224>
80009794:	fe c8 c3 4c 	sub	r8,pc,-15540
80009798:	fa ea 00 3c 	ld.d	r10,sp[60]
8000979c:	f0 06 02 38 	ld.d	r8,r8[r6<<0x3]
800097a0:	e0 a0 10 68 	rcall	8000b870 <__avr32_f64_cmp_lt>
800097a4:	f9 b4 00 00 	moveq	r4,0
800097a8:	fb f4 0a 14 	st.weq	sp[0x50],r4
800097ac:	f7 b6 01 01 	subne	r6,1
800097b0:	f9 bc 01 00 	movne	r12,0
800097b4:	fb fc 1a 14 	st.wne	sp[0x50],r12
800097b8:	41 90       	lddsp	r0,sp[0x64]
800097ba:	20 10       	sub	r0,1
800097bc:	0a 10       	sub	r0,r5
800097be:	c0 46       	brmi	800097c6 <_dtoa_r+0x232>
800097c0:	50 40       	stdsp	sp[0x10],r0
800097c2:	30 00       	mov	r0,0
800097c4:	c0 48       	rjmp	800097cc <_dtoa_r+0x238>
800097c6:	30 0b       	mov	r11,0
800097c8:	5c 30       	neg	r0
800097ca:	50 4b       	stdsp	sp[0x10],r11
800097cc:	ec 02 11 00 	rsub	r2,r6,0
800097d0:	58 06       	cp.w	r6,0
800097d2:	fb fa 40 04 	ld.wge	r10,sp[0x10]
800097d6:	f5 d6 e4 0a 	addge	r10,r10,r6
800097da:	fb fa 4a 04 	st.wge	sp[0x10],r10
800097de:	fb f6 4a 11 	st.wge	sp[0x44],r6
800097e2:	f9 b2 04 00 	movge	r2,0
800097e6:	e1 d6 e5 10 	sublt	r0,r0,r6
800097ea:	f9 b9 05 00 	movlt	r9,0
800097ee:	fb f9 5a 11 	st.wlt	sp[0x44],r9
800097f2:	40 c8       	lddsp	r8,sp[0x30]
800097f4:	58 98       	cp.w	r8,9
800097f6:	e0 8b 00 20 	brhi	80009836 <_dtoa_r+0x2a2>
800097fa:	58 58       	cp.w	r8,5
800097fc:	f9 b4 0a 01 	movle	r4,1
80009800:	fb f5 90 0c 	ld.wgt	r5,sp[0x30]
80009804:	f7 b5 09 04 	subgt	r5,4
80009808:	fb f5 9a 0c 	st.wgt	sp[0x30],r5
8000980c:	f9 b4 09 00 	movgt	r4,0
80009810:	40 cc       	lddsp	r12,sp[0x30]
80009812:	58 3c       	cp.w	r12,3
80009814:	c2 d0       	breq	8000986e <_dtoa_r+0x2da>
80009816:	e0 89 00 05 	brgt	80009820 <_dtoa_r+0x28c>
8000981a:	58 2c       	cp.w	r12,2
8000981c:	c1 01       	brne	8000983c <_dtoa_r+0x2a8>
8000981e:	c1 88       	rjmp	8000984e <_dtoa_r+0x2ba>
80009820:	40 cb       	lddsp	r11,sp[0x30]
80009822:	58 4b       	cp.w	r11,4
80009824:	c0 60       	breq	80009830 <_dtoa_r+0x29c>
80009826:	58 5b       	cp.w	r11,5
80009828:	c0 a1       	brne	8000983c <_dtoa_r+0x2a8>
8000982a:	30 1a       	mov	r10,1
8000982c:	50 da       	stdsp	sp[0x34],r10
8000982e:	c2 28       	rjmp	80009872 <_dtoa_r+0x2de>
80009830:	30 19       	mov	r9,1
80009832:	50 d9       	stdsp	sp[0x34],r9
80009834:	c0 f8       	rjmp	80009852 <_dtoa_r+0x2be>
80009836:	30 08       	mov	r8,0
80009838:	30 14       	mov	r4,1
8000983a:	50 c8       	stdsp	sp[0x30],r8
8000983c:	3f f5       	mov	r5,-1
8000983e:	30 1c       	mov	r12,1
80009840:	30 0b       	mov	r11,0
80009842:	50 95       	stdsp	sp[0x24],r5
80009844:	50 dc       	stdsp	sp[0x34],r12
80009846:	0a 91       	mov	r1,r5
80009848:	31 28       	mov	r8,18
8000984a:	50 eb       	stdsp	sp[0x38],r11
8000984c:	c2 08       	rjmp	8000988c <_dtoa_r+0x2f8>
8000984e:	30 0a       	mov	r10,0
80009850:	50 da       	stdsp	sp[0x34],r10
80009852:	40 e9       	lddsp	r9,sp[0x38]
80009854:	58 09       	cp.w	r9,0
80009856:	e0 89 00 07 	brgt	80009864 <_dtoa_r+0x2d0>
8000985a:	30 18       	mov	r8,1
8000985c:	50 98       	stdsp	sp[0x24],r8
8000985e:	10 91       	mov	r1,r8
80009860:	50 e8       	stdsp	sp[0x38],r8
80009862:	c1 58       	rjmp	8000988c <_dtoa_r+0x2f8>
80009864:	40 e5       	lddsp	r5,sp[0x38]
80009866:	50 95       	stdsp	sp[0x24],r5
80009868:	0a 91       	mov	r1,r5
8000986a:	0a 98       	mov	r8,r5
8000986c:	c1 08       	rjmp	8000988c <_dtoa_r+0x2f8>
8000986e:	30 0c       	mov	r12,0
80009870:	50 dc       	stdsp	sp[0x34],r12
80009872:	40 eb       	lddsp	r11,sp[0x38]
80009874:	ec 0b 00 0b 	add	r11,r6,r11
80009878:	50 9b       	stdsp	sp[0x24],r11
8000987a:	16 98       	mov	r8,r11
8000987c:	2f f8       	sub	r8,-1
8000987e:	58 08       	cp.w	r8,0
80009880:	e0 89 00 05 	brgt	8000988a <_dtoa_r+0x2f6>
80009884:	10 91       	mov	r1,r8
80009886:	30 18       	mov	r8,1
80009888:	c0 28       	rjmp	8000988c <_dtoa_r+0x2f8>
8000988a:	10 91       	mov	r1,r8
8000988c:	30 09       	mov	r9,0
8000988e:	6e 9a       	ld.w	r10,r7[0x24]
80009890:	95 19       	st.w	r10[0x4],r9
80009892:	30 49       	mov	r9,4
80009894:	c0 68       	rjmp	800098a0 <_dtoa_r+0x30c>
80009896:	d7 03       	nop
80009898:	6a 1a       	ld.w	r10,r5[0x4]
8000989a:	a1 79       	lsl	r9,0x1
8000989c:	2f fa       	sub	r10,-1
8000989e:	8b 1a       	st.w	r5[0x4],r10
800098a0:	6e 95       	ld.w	r5,r7[0x24]
800098a2:	f2 ca ff ec 	sub	r10,r9,-20
800098a6:	10 3a       	cp.w	r10,r8
800098a8:	fe 98 ff f8 	brls	80009898 <_dtoa_r+0x304>
800098ac:	6a 1b       	ld.w	r11,r5[0x4]
800098ae:	0e 9c       	mov	r12,r7
800098b0:	e0 a0 09 44 	rcall	8000ab38 <_Balloc>
800098b4:	58 e1       	cp.w	r1,14
800098b6:	5f 88       	srls	r8
800098b8:	8b 0c       	st.w	r5[0x0],r12
800098ba:	f1 e4 00 04 	and	r4,r8,r4
800098be:	6e 98       	ld.w	r8,r7[0x24]
800098c0:	70 08       	ld.w	r8,r8[0x0]
800098c2:	50 88       	stdsp	sp[0x20],r8
800098c4:	e0 80 01 82 	breq	80009bc8 <_dtoa_r+0x634>
800098c8:	58 06       	cp.w	r6,0
800098ca:	e0 8a 00 43 	brle	80009950 <_dtoa_r+0x3bc>
800098ce:	f3 d6 c0 04 	bfextu	r9,r6,0x0,0x4
800098d2:	fe c8 c4 8a 	sub	r8,pc,-15222
800098d6:	f0 09 02 34 	ld.d	r4,r8[r9<<0x3]
800098da:	fa e5 00 18 	st.d	sp[24],r4
800098de:	ec 04 14 04 	asr	r4,r6,0x4
800098e2:	ed b4 00 04 	bld	r4,0x4
800098e6:	c0 30       	breq	800098ec <_dtoa_r+0x358>
800098e8:	30 25       	mov	r5,2
800098ea:	c1 08       	rjmp	8000990a <_dtoa_r+0x376>
800098ec:	fe c8 c3 dc 	sub	r8,pc,-15396
800098f0:	f0 e8 00 20 	ld.d	r8,r8[32]
800098f4:	fa ea 00 3c 	ld.d	r10,sp[60]
800098f8:	e9 d4 c0 04 	bfextu	r4,r4,0x0,0x4
800098fc:	e0 a0 0f ee 	rcall	8000b8d8 <__avr32_f64_div>
80009900:	30 35       	mov	r5,3
80009902:	14 98       	mov	r8,r10
80009904:	16 99       	mov	r9,r11
80009906:	fa e9 00 08 	st.d	sp[8],r8
8000990a:	fe cc c3 fa 	sub	r12,pc,-15366
8000990e:	50 a3       	stdsp	sp[0x28],r3
80009910:	0c 93       	mov	r3,r6
80009912:	18 96       	mov	r6,r12
80009914:	c0 f8       	rjmp	80009932 <_dtoa_r+0x39e>
80009916:	fa ea 00 18 	ld.d	r10,sp[24]
8000991a:	ed b4 00 00 	bld	r4,0x0
8000991e:	c0 81       	brne	8000992e <_dtoa_r+0x39a>
80009920:	ec e8 00 00 	ld.d	r8,r6[0]
80009924:	2f f5       	sub	r5,-1
80009926:	e0 a0 0c 93 	rcall	8000b24c <__avr32_f64_mul>
8000992a:	fa eb 00 18 	st.d	sp[24],r10
8000992e:	a1 54       	asr	r4,0x1
80009930:	2f 86       	sub	r6,-8
80009932:	58 04       	cp.w	r4,0
80009934:	cf 11       	brne	80009916 <_dtoa_r+0x382>
80009936:	fa e8 00 18 	ld.d	r8,sp[24]
8000993a:	fa ea 00 08 	ld.d	r10,sp[8]
8000993e:	06 96       	mov	r6,r3
80009940:	e0 a0 0f cc 	rcall	8000b8d8 <__avr32_f64_div>
80009944:	40 a3       	lddsp	r3,sp[0x28]
80009946:	14 98       	mov	r8,r10
80009948:	16 99       	mov	r9,r11
8000994a:	fa e9 00 08 	st.d	sp[8],r8
8000994e:	c2 f8       	rjmp	800099ac <_dtoa_r+0x418>
80009950:	ec 08 11 00 	rsub	r8,r6,0
80009954:	c0 31       	brne	8000995a <_dtoa_r+0x3c6>
80009956:	30 25       	mov	r5,2
80009958:	c2 a8       	rjmp	800099ac <_dtoa_r+0x418>
8000995a:	fe cc c4 4a 	sub	r12,pc,-15286
8000995e:	f0 04 14 04 	asr	r4,r8,0x4
80009962:	50 1c       	stdsp	sp[0x4],r12
80009964:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
80009968:	fe c9 c5 20 	sub	r9,pc,-15072
8000996c:	fa ea 00 3c 	ld.d	r10,sp[60]
80009970:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
80009974:	e0 a0 0c 6c 	rcall	8000b24c <__avr32_f64_mul>
80009978:	40 1c       	lddsp	r12,sp[0x4]
8000997a:	50 63       	stdsp	sp[0x18],r3
8000997c:	30 25       	mov	r5,2
8000997e:	0c 93       	mov	r3,r6
80009980:	fa eb 00 08 	st.d	sp[8],r10
80009984:	18 96       	mov	r6,r12
80009986:	c0 f8       	rjmp	800099a4 <_dtoa_r+0x410>
80009988:	fa ea 00 08 	ld.d	r10,sp[8]
8000998c:	ed b4 00 00 	bld	r4,0x0
80009990:	c0 81       	brne	800099a0 <_dtoa_r+0x40c>
80009992:	ec e8 00 00 	ld.d	r8,r6[0]
80009996:	2f f5       	sub	r5,-1
80009998:	e0 a0 0c 5a 	rcall	8000b24c <__avr32_f64_mul>
8000999c:	fa eb 00 08 	st.d	sp[8],r10
800099a0:	a1 54       	asr	r4,0x1
800099a2:	2f 86       	sub	r6,-8
800099a4:	58 04       	cp.w	r4,0
800099a6:	cf 11       	brne	80009988 <_dtoa_r+0x3f4>
800099a8:	06 96       	mov	r6,r3
800099aa:	40 63       	lddsp	r3,sp[0x18]
800099ac:	41 4a       	lddsp	r10,sp[0x50]
800099ae:	58 0a       	cp.w	r10,0
800099b0:	c2 a0       	breq	80009a04 <_dtoa_r+0x470>
800099b2:	fa e8 00 08 	ld.d	r8,sp[8]
800099b6:	58 01       	cp.w	r1,0
800099b8:	5f 94       	srgt	r4
800099ba:	fa e9 00 18 	st.d	sp[24],r8
800099be:	30 08       	mov	r8,0
800099c0:	fc 19 3f f0 	movh	r9,0x3ff0
800099c4:	fa ea 00 18 	ld.d	r10,sp[24]
800099c8:	e0 a0 0f 54 	rcall	8000b870 <__avr32_f64_cmp_lt>
800099cc:	f9 bc 00 00 	moveq	r12,0
800099d0:	f9 bc 01 01 	movne	r12,1
800099d4:	e9 ec 00 0c 	and	r12,r4,r12
800099d8:	c1 60       	breq	80009a04 <_dtoa_r+0x470>
800099da:	40 98       	lddsp	r8,sp[0x24]
800099dc:	58 08       	cp.w	r8,0
800099de:	e0 8a 00 f1 	brle	80009bc0 <_dtoa_r+0x62c>
800099e2:	30 08       	mov	r8,0
800099e4:	fc 19 40 24 	movh	r9,0x4024
800099e8:	ec c4 00 01 	sub	r4,r6,1
800099ec:	fa ea 00 18 	ld.d	r10,sp[24]
800099f0:	2f f5       	sub	r5,-1
800099f2:	50 64       	stdsp	sp[0x18],r4
800099f4:	e0 a0 0c 2c 	rcall	8000b24c <__avr32_f64_mul>
800099f8:	40 94       	lddsp	r4,sp[0x24]
800099fa:	14 98       	mov	r8,r10
800099fc:	16 99       	mov	r9,r11
800099fe:	fa e9 00 08 	st.d	sp[8],r8
80009a02:	c0 38       	rjmp	80009a08 <_dtoa_r+0x474>
80009a04:	50 66       	stdsp	sp[0x18],r6
80009a06:	02 94       	mov	r4,r1
80009a08:	0a 9c       	mov	r12,r5
80009a0a:	e0 a0 0e 7c 	rcall	8000b702 <__avr32_s32_to_f64>
80009a0e:	fa e8 00 08 	ld.d	r8,sp[8]
80009a12:	e0 a0 0c 1d 	rcall	8000b24c <__avr32_f64_mul>
80009a16:	30 08       	mov	r8,0
80009a18:	fc 19 40 1c 	movh	r9,0x401c
80009a1c:	e0 a0 0d d2 	rcall	8000b5c0 <__avr32_f64_add>
80009a20:	14 98       	mov	r8,r10
80009a22:	16 99       	mov	r9,r11
80009a24:	fa e9 00 28 	st.d	sp[40],r8
80009a28:	fc 18 fc c0 	movh	r8,0xfcc0
80009a2c:	40 a5       	lddsp	r5,sp[0x28]
80009a2e:	10 05       	add	r5,r8
80009a30:	50 a5       	stdsp	sp[0x28],r5
80009a32:	58 04       	cp.w	r4,0
80009a34:	c2 11       	brne	80009a76 <_dtoa_r+0x4e2>
80009a36:	fa ea 00 08 	ld.d	r10,sp[8]
80009a3a:	30 08       	mov	r8,0
80009a3c:	fc 19 40 14 	movh	r9,0x4014
80009a40:	e0 a0 0c f2 	rcall	8000b424 <__avr32_f64_sub>
80009a44:	40 bc       	lddsp	r12,sp[0x2c]
80009a46:	fa eb 00 08 	st.d	sp[8],r10
80009a4a:	14 98       	mov	r8,r10
80009a4c:	16 99       	mov	r9,r11
80009a4e:	18 9a       	mov	r10,r12
80009a50:	0a 9b       	mov	r11,r5
80009a52:	e0 a0 0f 0f 	rcall	8000b870 <__avr32_f64_cmp_lt>
80009a56:	e0 81 02 54 	brne	80009efe <_dtoa_r+0x96a>
80009a5a:	0a 98       	mov	r8,r5
80009a5c:	40 b9       	lddsp	r9,sp[0x2c]
80009a5e:	ee 18 80 00 	eorh	r8,0x8000
80009a62:	fa ea 00 08 	ld.d	r10,sp[8]
80009a66:	10 95       	mov	r5,r8
80009a68:	12 98       	mov	r8,r9
80009a6a:	0a 99       	mov	r9,r5
80009a6c:	e0 a0 0f 02 	rcall	8000b870 <__avr32_f64_cmp_lt>
80009a70:	e0 81 02 3e 	brne	80009eec <_dtoa_r+0x958>
80009a74:	ca 68       	rjmp	80009bc0 <_dtoa_r+0x62c>
80009a76:	fe c9 c6 2e 	sub	r9,pc,-14802
80009a7a:	e8 c8 00 01 	sub	r8,r4,1
80009a7e:	40 d5       	lddsp	r5,sp[0x34]
80009a80:	58 05       	cp.w	r5,0
80009a82:	c4 f0       	breq	80009b20 <_dtoa_r+0x58c>
80009a84:	30 0c       	mov	r12,0
80009a86:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
80009a8a:	51 3c       	stdsp	sp[0x4c],r12
80009a8c:	30 0a       	mov	r10,0
80009a8e:	fc 1b 3f e0 	movh	r11,0x3fe0
80009a92:	e0 a0 0f 23 	rcall	8000b8d8 <__avr32_f64_div>
80009a96:	fa e8 00 28 	ld.d	r8,sp[40]
80009a9a:	40 85       	lddsp	r5,sp[0x20]
80009a9c:	e0 a0 0c c4 	rcall	8000b424 <__avr32_f64_sub>
80009aa0:	fa eb 00 28 	st.d	sp[40],r10
80009aa4:	fa ea 00 08 	ld.d	r10,sp[8]
80009aa8:	e0 a0 0e 16 	rcall	8000b6d4 <__avr32_f64_to_s32>
80009aac:	51 6c       	stdsp	sp[0x58],r12
80009aae:	e0 a0 0e 2a 	rcall	8000b702 <__avr32_s32_to_f64>
80009ab2:	14 98       	mov	r8,r10
80009ab4:	16 99       	mov	r9,r11
80009ab6:	fa ea 00 08 	ld.d	r10,sp[8]
80009aba:	e0 a0 0c b5 	rcall	8000b424 <__avr32_f64_sub>
80009abe:	fa eb 00 08 	st.d	sp[8],r10
80009ac2:	41 68       	lddsp	r8,sp[0x58]
80009ac4:	2d 08       	sub	r8,-48
80009ac6:	0a c8       	st.b	r5++,r8
80009ac8:	41 39       	lddsp	r9,sp[0x4c]
80009aca:	2f f9       	sub	r9,-1
80009acc:	51 39       	stdsp	sp[0x4c],r9
80009ace:	fa e8 00 28 	ld.d	r8,sp[40]
80009ad2:	e0 a0 0e cf 	rcall	8000b870 <__avr32_f64_cmp_lt>
80009ad6:	e0 81 03 39 	brne	8000a148 <_dtoa_r+0xbb4>
80009ada:	fa e8 00 08 	ld.d	r8,sp[8]
80009ade:	30 0a       	mov	r10,0
80009ae0:	fc 1b 3f f0 	movh	r11,0x3ff0
80009ae4:	e0 a0 0c a0 	rcall	8000b424 <__avr32_f64_sub>
80009ae8:	fa e8 00 28 	ld.d	r8,sp[40]
80009aec:	e0 a0 0e c2 	rcall	8000b870 <__avr32_f64_cmp_lt>
80009af0:	fa ea 00 28 	ld.d	r10,sp[40]
80009af4:	30 08       	mov	r8,0
80009af6:	fc 19 40 24 	movh	r9,0x4024
80009afa:	e0 81 00 da 	brne	80009cae <_dtoa_r+0x71a>
80009afe:	41 3c       	lddsp	r12,sp[0x4c]
80009b00:	08 3c       	cp.w	r12,r4
80009b02:	c5 f4       	brge	80009bc0 <_dtoa_r+0x62c>
80009b04:	e0 a0 0b a4 	rcall	8000b24c <__avr32_f64_mul>
80009b08:	30 08       	mov	r8,0
80009b0a:	fa eb 00 28 	st.d	sp[40],r10
80009b0e:	fc 19 40 24 	movh	r9,0x4024
80009b12:	fa ea 00 08 	ld.d	r10,sp[8]
80009b16:	e0 a0 0b 9b 	rcall	8000b24c <__avr32_f64_mul>
80009b1a:	fa eb 00 08 	st.d	sp[8],r10
80009b1e:	cc 3b       	rjmp	80009aa4 <_dtoa_r+0x510>
80009b20:	40 85       	lddsp	r5,sp[0x20]
80009b22:	08 05       	add	r5,r4
80009b24:	f2 08 02 3a 	ld.d	r10,r9[r8<<0x3]
80009b28:	51 35       	stdsp	sp[0x4c],r5
80009b2a:	fa e8 00 28 	ld.d	r8,sp[40]
80009b2e:	40 85       	lddsp	r5,sp[0x20]
80009b30:	e0 a0 0b 8e 	rcall	8000b24c <__avr32_f64_mul>
80009b34:	fa eb 00 28 	st.d	sp[40],r10
80009b38:	fa ea 00 08 	ld.d	r10,sp[8]
80009b3c:	e0 a0 0d cc 	rcall	8000b6d4 <__avr32_f64_to_s32>
80009b40:	51 6c       	stdsp	sp[0x58],r12
80009b42:	e0 a0 0d e0 	rcall	8000b702 <__avr32_s32_to_f64>
80009b46:	14 98       	mov	r8,r10
80009b48:	16 99       	mov	r9,r11
80009b4a:	fa ea 00 08 	ld.d	r10,sp[8]
80009b4e:	e0 a0 0c 6b 	rcall	8000b424 <__avr32_f64_sub>
80009b52:	fa eb 00 08 	st.d	sp[8],r10
80009b56:	41 68       	lddsp	r8,sp[0x58]
80009b58:	2d 08       	sub	r8,-48
80009b5a:	0a c8       	st.b	r5++,r8
80009b5c:	41 3c       	lddsp	r12,sp[0x4c]
80009b5e:	18 35       	cp.w	r5,r12
80009b60:	c2 81       	brne	80009bb0 <_dtoa_r+0x61c>
80009b62:	30 08       	mov	r8,0
80009b64:	fc 19 3f e0 	movh	r9,0x3fe0
80009b68:	fa ea 00 28 	ld.d	r10,sp[40]
80009b6c:	e0 a0 0d 2a 	rcall	8000b5c0 <__avr32_f64_add>
80009b70:	40 85       	lddsp	r5,sp[0x20]
80009b72:	fa e8 00 08 	ld.d	r8,sp[8]
80009b76:	08 05       	add	r5,r4
80009b78:	e0 a0 0e 7c 	rcall	8000b870 <__avr32_f64_cmp_lt>
80009b7c:	e0 81 00 99 	brne	80009cae <_dtoa_r+0x71a>
80009b80:	fa e8 00 28 	ld.d	r8,sp[40]
80009b84:	30 0a       	mov	r10,0
80009b86:	fc 1b 3f e0 	movh	r11,0x3fe0
80009b8a:	e0 a0 0c 4d 	rcall	8000b424 <__avr32_f64_sub>
80009b8e:	14 98       	mov	r8,r10
80009b90:	16 99       	mov	r9,r11
80009b92:	fa ea 00 08 	ld.d	r10,sp[8]
80009b96:	e0 a0 0e 6d 	rcall	8000b870 <__avr32_f64_cmp_lt>
80009b9a:	c1 30       	breq	80009bc0 <_dtoa_r+0x62c>
80009b9c:	33 09       	mov	r9,48
80009b9e:	0a 98       	mov	r8,r5
80009ba0:	11 7a       	ld.ub	r10,--r8
80009ba2:	f2 0a 18 00 	cp.b	r10,r9
80009ba6:	e0 81 02 d1 	brne	8000a148 <_dtoa_r+0xbb4>
80009baa:	10 95       	mov	r5,r8
80009bac:	cf 9b       	rjmp	80009b9e <_dtoa_r+0x60a>
80009bae:	d7 03       	nop
80009bb0:	30 08       	mov	r8,0
80009bb2:	fc 19 40 24 	movh	r9,0x4024
80009bb6:	e0 a0 0b 4b 	rcall	8000b24c <__avr32_f64_mul>
80009bba:	fa eb 00 08 	st.d	sp[8],r10
80009bbe:	cb db       	rjmp	80009b38 <_dtoa_r+0x5a4>
80009bc0:	fa ea 00 3c 	ld.d	r10,sp[60]
80009bc4:	fa eb 00 08 	st.d	sp[8],r10
80009bc8:	58 e6       	cp.w	r6,14
80009bca:	5f ab       	srle	r11
80009bcc:	41 8a       	lddsp	r10,sp[0x60]
80009bce:	30 08       	mov	r8,0
80009bd0:	f4 09 11 ff 	rsub	r9,r10,-1
80009bd4:	f7 e9 03 f9 	and	r9,r11,r9>>0x1f
80009bd8:	f0 09 18 00 	cp.b	r9,r8
80009bdc:	e0 80 00 82 	breq	80009ce0 <_dtoa_r+0x74c>
80009be0:	40 ea       	lddsp	r10,sp[0x38]
80009be2:	58 01       	cp.w	r1,0
80009be4:	5f a9       	srle	r9
80009be6:	f3 ea 03 f9 	and	r9,r9,r10>>0x1f
80009bea:	fe ca c7 a2 	sub	r10,pc,-14430
80009bee:	f4 06 02 34 	ld.d	r4,r10[r6<<0x3]
80009bf2:	fa e5 00 10 	st.d	sp[16],r4
80009bf6:	f0 09 18 00 	cp.b	r9,r8
80009bfa:	c1 40       	breq	80009c22 <_dtoa_r+0x68e>
80009bfc:	58 01       	cp.w	r1,0
80009bfe:	e0 81 01 77 	brne	80009eec <_dtoa_r+0x958>
80009c02:	30 08       	mov	r8,0
80009c04:	fc 19 40 14 	movh	r9,0x4014
80009c08:	08 9a       	mov	r10,r4
80009c0a:	0a 9b       	mov	r11,r5
80009c0c:	e0 a0 0b 20 	rcall	8000b24c <__avr32_f64_mul>
80009c10:	fa e8 00 08 	ld.d	r8,sp[8]
80009c14:	e0 a0 0d fa 	rcall	8000b808 <__avr32_f64_cmp_ge>
80009c18:	e0 81 01 6a 	brne	80009eec <_dtoa_r+0x958>
80009c1c:	02 92       	mov	r2,r1
80009c1e:	e0 8f 01 72 	bral	80009f02 <_dtoa_r+0x96e>
80009c22:	40 85       	lddsp	r5,sp[0x20]
80009c24:	30 14       	mov	r4,1
80009c26:	fa e8 00 10 	ld.d	r8,sp[16]
80009c2a:	fa ea 00 08 	ld.d	r10,sp[8]
80009c2e:	e0 a0 0e 55 	rcall	8000b8d8 <__avr32_f64_div>
80009c32:	e0 a0 0d 51 	rcall	8000b6d4 <__avr32_f64_to_s32>
80009c36:	18 92       	mov	r2,r12
80009c38:	e0 a0 0d 65 	rcall	8000b702 <__avr32_s32_to_f64>
80009c3c:	fa e8 00 10 	ld.d	r8,sp[16]
80009c40:	e0 a0 0b 06 	rcall	8000b24c <__avr32_f64_mul>
80009c44:	14 98       	mov	r8,r10
80009c46:	16 99       	mov	r9,r11
80009c48:	fa ea 00 08 	ld.d	r10,sp[8]
80009c4c:	e0 a0 0b ec 	rcall	8000b424 <__avr32_f64_sub>
80009c50:	fa eb 00 08 	st.d	sp[8],r10
80009c54:	e4 c8 ff d0 	sub	r8,r2,-48
80009c58:	0a c8       	st.b	r5++,r8
80009c5a:	fc 19 40 24 	movh	r9,0x4024
80009c5e:	30 08       	mov	r8,0
80009c60:	02 34       	cp.w	r4,r1
80009c62:	c3 31       	brne	80009cc8 <_dtoa_r+0x734>
80009c64:	fa e8 00 08 	ld.d	r8,sp[8]
80009c68:	e0 a0 0c ac 	rcall	8000b5c0 <__avr32_f64_add>
80009c6c:	16 91       	mov	r1,r11
80009c6e:	14 90       	mov	r0,r10
80009c70:	14 98       	mov	r8,r10
80009c72:	02 99       	mov	r9,r1
80009c74:	fa ea 00 10 	ld.d	r10,sp[16]
80009c78:	e0 a0 0d fc 	rcall	8000b870 <__avr32_f64_cmp_lt>
80009c7c:	c1 a1       	brne	80009cb0 <_dtoa_r+0x71c>
80009c7e:	fa e8 00 10 	ld.d	r8,sp[16]
80009c82:	00 9a       	mov	r10,r0
80009c84:	02 9b       	mov	r11,r1
80009c86:	e0 a0 0d ae 	rcall	8000b7e2 <__avr32_f64_cmp_eq>
80009c8a:	e0 80 02 5e 	breq	8000a146 <_dtoa_r+0xbb2>
80009c8e:	e5 d2 c0 01 	bfextu	r2,r2,0x0,0x1
80009c92:	c0 f1       	brne	80009cb0 <_dtoa_r+0x71c>
80009c94:	e0 8f 02 59 	bral	8000a146 <_dtoa_r+0xbb2>
80009c98:	40 8a       	lddsp	r10,sp[0x20]
80009c9a:	14 38       	cp.w	r8,r10
80009c9c:	c0 30       	breq	80009ca2 <_dtoa_r+0x70e>
80009c9e:	10 95       	mov	r5,r8
80009ca0:	c0 98       	rjmp	80009cb2 <_dtoa_r+0x71e>
80009ca2:	33 08       	mov	r8,48
80009ca4:	40 89       	lddsp	r9,sp[0x20]
80009ca6:	2f f6       	sub	r6,-1
80009ca8:	b2 88       	st.b	r9[0x0],r8
80009caa:	40 88       	lddsp	r8,sp[0x20]
80009cac:	c0 88       	rjmp	80009cbc <_dtoa_r+0x728>
80009cae:	40 66       	lddsp	r6,sp[0x18]
80009cb0:	33 99       	mov	r9,57
80009cb2:	0a 98       	mov	r8,r5
80009cb4:	11 7a       	ld.ub	r10,--r8
80009cb6:	f2 0a 18 00 	cp.b	r10,r9
80009cba:	ce f0       	breq	80009c98 <_dtoa_r+0x704>
80009cbc:	50 66       	stdsp	sp[0x18],r6
80009cbe:	11 89       	ld.ub	r9,r8[0x0]
80009cc0:	2f f9       	sub	r9,-1
80009cc2:	b0 89       	st.b	r8[0x0],r9
80009cc4:	e0 8f 02 42 	bral	8000a148 <_dtoa_r+0xbb4>
80009cc8:	e0 a0 0a c2 	rcall	8000b24c <__avr32_f64_mul>
80009ccc:	2f f4       	sub	r4,-1
80009cce:	fa eb 00 08 	st.d	sp[8],r10
80009cd2:	30 08       	mov	r8,0
80009cd4:	30 09       	mov	r9,0
80009cd6:	e0 a0 0d 86 	rcall	8000b7e2 <__avr32_f64_cmp_eq>
80009cda:	ca 60       	breq	80009c26 <_dtoa_r+0x692>
80009cdc:	e0 8f 02 35 	bral	8000a146 <_dtoa_r+0xbb2>
80009ce0:	40 d8       	lddsp	r8,sp[0x34]
80009ce2:	58 08       	cp.w	r8,0
80009ce4:	c0 51       	brne	80009cee <_dtoa_r+0x75a>
80009ce6:	04 98       	mov	r8,r2
80009ce8:	00 95       	mov	r5,r0
80009cea:	40 d4       	lddsp	r4,sp[0x34]
80009cec:	c3 78       	rjmp	80009d5a <_dtoa_r+0x7c6>
80009cee:	40 c5       	lddsp	r5,sp[0x30]
80009cf0:	58 15       	cp.w	r5,1
80009cf2:	e0 89 00 0f 	brgt	80009d10 <_dtoa_r+0x77c>
80009cf6:	41 74       	lddsp	r4,sp[0x5c]
80009cf8:	58 04       	cp.w	r4,0
80009cfa:	c0 40       	breq	80009d02 <_dtoa_r+0x76e>
80009cfc:	f4 c9 fb cd 	sub	r9,r10,-1075
80009d00:	c0 48       	rjmp	80009d08 <_dtoa_r+0x774>
80009d02:	41 99       	lddsp	r9,sp[0x64]
80009d04:	f2 09 11 36 	rsub	r9,r9,54
80009d08:	04 98       	mov	r8,r2
80009d0a:	00 95       	mov	r5,r0
80009d0c:	c1 c8       	rjmp	80009d44 <_dtoa_r+0x7b0>
80009d0e:	d7 03       	nop
80009d10:	e2 c8 00 01 	sub	r8,r1,1
80009d14:	58 01       	cp.w	r1,0
80009d16:	e0 05 17 40 	movge	r5,r0
80009d1a:	e2 09 17 40 	movge	r9,r1
80009d1e:	e1 d1 e5 15 	sublt	r5,r0,r1
80009d22:	f9 b9 05 00 	movlt	r9,0
80009d26:	10 32       	cp.w	r2,r8
80009d28:	e5 d8 e4 18 	subge	r8,r2,r8
80009d2c:	f1 d2 e5 18 	sublt	r8,r8,r2
80009d30:	e5 d8 e5 02 	addlt	r2,r2,r8
80009d34:	fb fc 50 11 	ld.wlt	r12,sp[0x44]
80009d38:	f9 d8 e5 0c 	addlt	r12,r12,r8
80009d3c:	fb fc 5a 11 	st.wlt	sp[0x44],r12
80009d40:	f9 b8 05 00 	movlt	r8,0
80009d44:	40 4b       	lddsp	r11,sp[0x10]
80009d46:	12 0b       	add	r11,r9
80009d48:	50 08       	stdsp	sp[0x0],r8
80009d4a:	50 4b       	stdsp	sp[0x10],r11
80009d4c:	12 00       	add	r0,r9
80009d4e:	30 1b       	mov	r11,1
80009d50:	0e 9c       	mov	r12,r7
80009d52:	e0 a0 08 a7 	rcall	8000aea0 <__i2b>
80009d56:	40 08       	lddsp	r8,sp[0x0]
80009d58:	18 94       	mov	r4,r12
80009d5a:	40 4a       	lddsp	r10,sp[0x10]
80009d5c:	58 05       	cp.w	r5,0
80009d5e:	5f 99       	srgt	r9
80009d60:	58 0a       	cp.w	r10,0
80009d62:	5f 9a       	srgt	r10
80009d64:	f5 e9 00 09 	and	r9,r10,r9
80009d68:	c0 80       	breq	80009d78 <_dtoa_r+0x7e4>
80009d6a:	40 4c       	lddsp	r12,sp[0x10]
80009d6c:	f8 05 0d 49 	min	r9,r12,r5
80009d70:	12 1c       	sub	r12,r9
80009d72:	12 10       	sub	r0,r9
80009d74:	50 4c       	stdsp	sp[0x10],r12
80009d76:	12 15       	sub	r5,r9
80009d78:	58 02       	cp.w	r2,0
80009d7a:	e0 8a 00 27 	brle	80009dc8 <_dtoa_r+0x834>
80009d7e:	40 db       	lddsp	r11,sp[0x34]
80009d80:	58 0b       	cp.w	r11,0
80009d82:	c1 d0       	breq	80009dbc <_dtoa_r+0x828>
80009d84:	58 08       	cp.w	r8,0
80009d86:	e0 8a 00 17 	brle	80009db4 <_dtoa_r+0x820>
80009d8a:	10 9a       	mov	r10,r8
80009d8c:	50 08       	stdsp	sp[0x0],r8
80009d8e:	08 9b       	mov	r11,r4
80009d90:	0e 9c       	mov	r12,r7
80009d92:	e0 a0 08 cd 	rcall	8000af2c <__pow5mult>
80009d96:	06 9a       	mov	r10,r3
80009d98:	18 9b       	mov	r11,r12
80009d9a:	18 94       	mov	r4,r12
80009d9c:	0e 9c       	mov	r12,r7
80009d9e:	e0 a0 08 01 	rcall	8000ada0 <__multiply>
80009da2:	18 99       	mov	r9,r12
80009da4:	06 9b       	mov	r11,r3
80009da6:	50 19       	stdsp	sp[0x4],r9
80009da8:	0e 9c       	mov	r12,r7
80009daa:	e0 a0 06 ad 	rcall	8000ab04 <_Bfree>
80009dae:	40 19       	lddsp	r9,sp[0x4]
80009db0:	40 08       	lddsp	r8,sp[0x0]
80009db2:	12 93       	mov	r3,r9
80009db4:	e4 08 01 0a 	sub	r10,r2,r8
80009db8:	c0 80       	breq	80009dc8 <_dtoa_r+0x834>
80009dba:	c0 28       	rjmp	80009dbe <_dtoa_r+0x82a>
80009dbc:	04 9a       	mov	r10,r2
80009dbe:	06 9b       	mov	r11,r3
80009dc0:	0e 9c       	mov	r12,r7
80009dc2:	e0 a0 08 b5 	rcall	8000af2c <__pow5mult>
80009dc6:	18 93       	mov	r3,r12
80009dc8:	30 1b       	mov	r11,1
80009dca:	0e 9c       	mov	r12,r7
80009dcc:	e0 a0 08 6a 	rcall	8000aea0 <__i2b>
80009dd0:	41 1a       	lddsp	r10,sp[0x44]
80009dd2:	18 92       	mov	r2,r12
80009dd4:	58 0a       	cp.w	r10,0
80009dd6:	e0 8a 00 07 	brle	80009de4 <_dtoa_r+0x850>
80009dda:	18 9b       	mov	r11,r12
80009ddc:	0e 9c       	mov	r12,r7
80009dde:	e0 a0 08 a7 	rcall	8000af2c <__pow5mult>
80009de2:	18 92       	mov	r2,r12
80009de4:	40 c9       	lddsp	r9,sp[0x30]
80009de6:	58 19       	cp.w	r9,1
80009de8:	e0 89 00 14 	brgt	80009e10 <_dtoa_r+0x87c>
80009dec:	40 38       	lddsp	r8,sp[0xc]
80009dee:	58 08       	cp.w	r8,0
80009df0:	c1 01       	brne	80009e10 <_dtoa_r+0x87c>
80009df2:	40 29       	lddsp	r9,sp[0x8]
80009df4:	f1 d9 c0 14 	bfextu	r8,r9,0x0,0x14
80009df8:	c0 c1       	brne	80009e10 <_dtoa_r+0x87c>
80009dfa:	12 98       	mov	r8,r9
80009dfc:	e6 18 7f f0 	andh	r8,0x7ff0,COH
80009e00:	c0 80       	breq	80009e10 <_dtoa_r+0x87c>
80009e02:	40 4c       	lddsp	r12,sp[0x10]
80009e04:	30 1b       	mov	r11,1
80009e06:	2f fc       	sub	r12,-1
80009e08:	2f f0       	sub	r0,-1
80009e0a:	50 4c       	stdsp	sp[0x10],r12
80009e0c:	50 6b       	stdsp	sp[0x18],r11
80009e0e:	c0 38       	rjmp	80009e14 <_dtoa_r+0x880>
80009e10:	30 0a       	mov	r10,0
80009e12:	50 6a       	stdsp	sp[0x18],r10
80009e14:	41 19       	lddsp	r9,sp[0x44]
80009e16:	58 09       	cp.w	r9,0
80009e18:	c0 31       	brne	80009e1e <_dtoa_r+0x88a>
80009e1a:	30 1c       	mov	r12,1
80009e1c:	c0 98       	rjmp	80009e2e <_dtoa_r+0x89a>
80009e1e:	64 48       	ld.w	r8,r2[0x10]
80009e20:	2f c8       	sub	r8,-4
80009e22:	e4 08 03 2c 	ld.w	r12,r2[r8<<0x2]
80009e26:	e0 a0 05 df 	rcall	8000a9e4 <__hi0bits>
80009e2a:	f8 0c 11 20 	rsub	r12,r12,32
80009e2e:	40 4b       	lddsp	r11,sp[0x10]
80009e30:	f8 0b 00 08 	add	r8,r12,r11
80009e34:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80009e38:	c0 c0       	breq	80009e50 <_dtoa_r+0x8bc>
80009e3a:	f0 08 11 20 	rsub	r8,r8,32
80009e3e:	58 48       	cp.w	r8,4
80009e40:	e0 8a 00 06 	brle	80009e4c <_dtoa_r+0x8b8>
80009e44:	20 48       	sub	r8,4
80009e46:	10 0b       	add	r11,r8
80009e48:	50 4b       	stdsp	sp[0x10],r11
80009e4a:	c0 78       	rjmp	80009e58 <_dtoa_r+0x8c4>
80009e4c:	58 48       	cp.w	r8,4
80009e4e:	c0 70       	breq	80009e5c <_dtoa_r+0x8c8>
80009e50:	40 4a       	lddsp	r10,sp[0x10]
80009e52:	2e 48       	sub	r8,-28
80009e54:	10 0a       	add	r10,r8
80009e56:	50 4a       	stdsp	sp[0x10],r10
80009e58:	10 00       	add	r0,r8
80009e5a:	10 05       	add	r5,r8
80009e5c:	58 00       	cp.w	r0,0
80009e5e:	e0 8a 00 08 	brle	80009e6e <_dtoa_r+0x8da>
80009e62:	06 9b       	mov	r11,r3
80009e64:	00 9a       	mov	r10,r0
80009e66:	0e 9c       	mov	r12,r7
80009e68:	e0 a0 07 58 	rcall	8000ad18 <__lshift>
80009e6c:	18 93       	mov	r3,r12
80009e6e:	40 49       	lddsp	r9,sp[0x10]
80009e70:	58 09       	cp.w	r9,0
80009e72:	e0 8a 00 08 	brle	80009e82 <_dtoa_r+0x8ee>
80009e76:	04 9b       	mov	r11,r2
80009e78:	12 9a       	mov	r10,r9
80009e7a:	0e 9c       	mov	r12,r7
80009e7c:	e0 a0 07 4e 	rcall	8000ad18 <__lshift>
80009e80:	18 92       	mov	r2,r12
80009e82:	41 48       	lddsp	r8,sp[0x50]
80009e84:	58 08       	cp.w	r8,0
80009e86:	c1 b0       	breq	80009ebc <_dtoa_r+0x928>
80009e88:	04 9b       	mov	r11,r2
80009e8a:	06 9c       	mov	r12,r3
80009e8c:	e0 a0 06 23 	rcall	8000aad2 <__mcmp>
80009e90:	c1 64       	brge	80009ebc <_dtoa_r+0x928>
80009e92:	06 9b       	mov	r11,r3
80009e94:	30 09       	mov	r9,0
80009e96:	30 aa       	mov	r10,10
80009e98:	0e 9c       	mov	r12,r7
80009e9a:	e0 a0 08 0b 	rcall	8000aeb0 <__multadd>
80009e9e:	20 16       	sub	r6,1
80009ea0:	18 93       	mov	r3,r12
80009ea2:	40 dc       	lddsp	r12,sp[0x34]
80009ea4:	58 0c       	cp.w	r12,0
80009ea6:	c0 31       	brne	80009eac <_dtoa_r+0x918>
80009ea8:	40 91       	lddsp	r1,sp[0x24]
80009eaa:	c0 98       	rjmp	80009ebc <_dtoa_r+0x928>
80009eac:	08 9b       	mov	r11,r4
80009eae:	40 91       	lddsp	r1,sp[0x24]
80009eb0:	30 09       	mov	r9,0
80009eb2:	30 aa       	mov	r10,10
80009eb4:	0e 9c       	mov	r12,r7
80009eb6:	e0 a0 07 fd 	rcall	8000aeb0 <__multadd>
80009eba:	18 94       	mov	r4,r12
80009ebc:	58 01       	cp.w	r1,0
80009ebe:	5f a9       	srle	r9
80009ec0:	40 cb       	lddsp	r11,sp[0x30]
80009ec2:	58 2b       	cp.w	r11,2
80009ec4:	5f 98       	srgt	r8
80009ec6:	f3 e8 00 08 	and	r8,r9,r8
80009eca:	c2 50       	breq	80009f14 <_dtoa_r+0x980>
80009ecc:	58 01       	cp.w	r1,0
80009ece:	c1 11       	brne	80009ef0 <_dtoa_r+0x95c>
80009ed0:	04 9b       	mov	r11,r2
80009ed2:	02 99       	mov	r9,r1
80009ed4:	30 5a       	mov	r10,5
80009ed6:	0e 9c       	mov	r12,r7
80009ed8:	e0 a0 07 ec 	rcall	8000aeb0 <__multadd>
80009edc:	18 92       	mov	r2,r12
80009ede:	18 9b       	mov	r11,r12
80009ee0:	06 9c       	mov	r12,r3
80009ee2:	e0 a0 05 f8 	rcall	8000aad2 <__mcmp>
80009ee6:	e0 89 00 0f 	brgt	80009f04 <_dtoa_r+0x970>
80009eea:	c0 38       	rjmp	80009ef0 <_dtoa_r+0x95c>
80009eec:	30 02       	mov	r2,0
80009eee:	04 94       	mov	r4,r2
80009ef0:	40 ea       	lddsp	r10,sp[0x38]
80009ef2:	30 09       	mov	r9,0
80009ef4:	5c da       	com	r10
80009ef6:	40 85       	lddsp	r5,sp[0x20]
80009ef8:	50 6a       	stdsp	sp[0x18],r10
80009efa:	50 49       	stdsp	sp[0x10],r9
80009efc:	c0 f9       	rjmp	8000a11a <_dtoa_r+0xb86>
80009efe:	08 92       	mov	r2,r4
80009f00:	40 66       	lddsp	r6,sp[0x18]
80009f02:	04 94       	mov	r4,r2
80009f04:	2f f6       	sub	r6,-1
80009f06:	50 66       	stdsp	sp[0x18],r6
80009f08:	33 18       	mov	r8,49
80009f0a:	40 85       	lddsp	r5,sp[0x20]
80009f0c:	0a c8       	st.b	r5++,r8
80009f0e:	30 08       	mov	r8,0
80009f10:	50 48       	stdsp	sp[0x10],r8
80009f12:	c0 49       	rjmp	8000a11a <_dtoa_r+0xb86>
80009f14:	40 dc       	lddsp	r12,sp[0x34]
80009f16:	58 0c       	cp.w	r12,0
80009f18:	e0 80 00 b5 	breq	8000a082 <_dtoa_r+0xaee>
80009f1c:	58 05       	cp.w	r5,0
80009f1e:	e0 8a 00 08 	brle	80009f2e <_dtoa_r+0x99a>
80009f22:	08 9b       	mov	r11,r4
80009f24:	0a 9a       	mov	r10,r5
80009f26:	0e 9c       	mov	r12,r7
80009f28:	e0 a0 06 f8 	rcall	8000ad18 <__lshift>
80009f2c:	18 94       	mov	r4,r12
80009f2e:	40 6b       	lddsp	r11,sp[0x18]
80009f30:	58 0b       	cp.w	r11,0
80009f32:	c0 31       	brne	80009f38 <_dtoa_r+0x9a4>
80009f34:	08 9c       	mov	r12,r4
80009f36:	c1 38       	rjmp	80009f5c <_dtoa_r+0x9c8>
80009f38:	68 1b       	ld.w	r11,r4[0x4]
80009f3a:	0e 9c       	mov	r12,r7
80009f3c:	e0 a0 05 fe 	rcall	8000ab38 <_Balloc>
80009f40:	68 4a       	ld.w	r10,r4[0x10]
80009f42:	18 95       	mov	r5,r12
80009f44:	e8 cb ff f4 	sub	r11,r4,-12
80009f48:	2f ea       	sub	r10,-2
80009f4a:	2f 4c       	sub	r12,-12
80009f4c:	a3 6a       	lsl	r10,0x2
80009f4e:	fe b0 e6 43 	rcall	80006bd4 <memcpy>
80009f52:	0a 9b       	mov	r11,r5
80009f54:	30 1a       	mov	r10,1
80009f56:	0e 9c       	mov	r12,r7
80009f58:	e0 a0 06 e0 	rcall	8000ad18 <__lshift>
80009f5c:	50 44       	stdsp	sp[0x10],r4
80009f5e:	40 3a       	lddsp	r10,sp[0xc]
80009f60:	30 19       	mov	r9,1
80009f62:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
80009f66:	18 94       	mov	r4,r12
80009f68:	50 da       	stdsp	sp[0x34],r10
80009f6a:	40 85       	lddsp	r5,sp[0x20]
80009f6c:	50 99       	stdsp	sp[0x24],r9
80009f6e:	50 26       	stdsp	sp[0x8],r6
80009f70:	50 e1       	stdsp	sp[0x38],r1
80009f72:	04 9b       	mov	r11,r2
80009f74:	06 9c       	mov	r12,r3
80009f76:	fe b0 fa 7f 	rcall	80009474 <quorem>
80009f7a:	40 4b       	lddsp	r11,sp[0x10]
80009f7c:	f8 c0 ff d0 	sub	r0,r12,-48
80009f80:	06 9c       	mov	r12,r3
80009f82:	e0 a0 05 a8 	rcall	8000aad2 <__mcmp>
80009f86:	08 9a       	mov	r10,r4
80009f88:	50 6c       	stdsp	sp[0x18],r12
80009f8a:	04 9b       	mov	r11,r2
80009f8c:	0e 9c       	mov	r12,r7
80009f8e:	e0 a0 06 5d 	rcall	8000ac48 <__mdiff>
80009f92:	18 91       	mov	r1,r12
80009f94:	78 38       	ld.w	r8,r12[0xc]
80009f96:	58 08       	cp.w	r8,0
80009f98:	c0 30       	breq	80009f9e <_dtoa_r+0xa0a>
80009f9a:	30 16       	mov	r6,1
80009f9c:	c0 68       	rjmp	80009fa8 <_dtoa_r+0xa14>
80009f9e:	18 9b       	mov	r11,r12
80009fa0:	06 9c       	mov	r12,r3
80009fa2:	e0 a0 05 98 	rcall	8000aad2 <__mcmp>
80009fa6:	18 96       	mov	r6,r12
80009fa8:	0e 9c       	mov	r12,r7
80009faa:	02 9b       	mov	r11,r1
80009fac:	e0 a0 05 ac 	rcall	8000ab04 <_Bfree>
80009fb0:	40 cc       	lddsp	r12,sp[0x30]
80009fb2:	ed ec 10 08 	or	r8,r6,r12
80009fb6:	c0 d1       	brne	80009fd0 <_dtoa_r+0xa3c>
80009fb8:	40 db       	lddsp	r11,sp[0x34]
80009fba:	58 0b       	cp.w	r11,0
80009fbc:	c0 a1       	brne	80009fd0 <_dtoa_r+0xa3c>
80009fbe:	40 26       	lddsp	r6,sp[0x8]
80009fc0:	e0 40 00 39 	cp.w	r0,57
80009fc4:	c3 00       	breq	8000a024 <_dtoa_r+0xa90>
80009fc6:	40 6a       	lddsp	r10,sp[0x18]
80009fc8:	58 0a       	cp.w	r10,0
80009fca:	e0 89 00 24 	brgt	8000a012 <_dtoa_r+0xa7e>
80009fce:	c2 f8       	rjmp	8000a02c <_dtoa_r+0xa98>
80009fd0:	40 69       	lddsp	r9,sp[0x18]
80009fd2:	58 09       	cp.w	r9,0
80009fd4:	c0 85       	brlt	80009fe4 <_dtoa_r+0xa50>
80009fd6:	12 98       	mov	r8,r9
80009fd8:	40 cc       	lddsp	r12,sp[0x30]
80009fda:	18 48       	or	r8,r12
80009fdc:	c1 d1       	brne	8000a016 <_dtoa_r+0xa82>
80009fde:	40 db       	lddsp	r11,sp[0x34]
80009fe0:	58 0b       	cp.w	r11,0
80009fe2:	c1 a1       	brne	8000a016 <_dtoa_r+0xa82>
80009fe4:	0c 99       	mov	r9,r6
80009fe6:	40 26       	lddsp	r6,sp[0x8]
80009fe8:	58 09       	cp.w	r9,0
80009fea:	e0 8a 00 21 	brle	8000a02c <_dtoa_r+0xa98>
80009fee:	06 9b       	mov	r11,r3
80009ff0:	30 1a       	mov	r10,1
80009ff2:	0e 9c       	mov	r12,r7
80009ff4:	e0 a0 06 92 	rcall	8000ad18 <__lshift>
80009ff8:	04 9b       	mov	r11,r2
80009ffa:	18 93       	mov	r3,r12
80009ffc:	e0 a0 05 6b 	rcall	8000aad2 <__mcmp>
8000a000:	e0 89 00 06 	brgt	8000a00c <_dtoa_r+0xa78>
8000a004:	c1 41       	brne	8000a02c <_dtoa_r+0xa98>
8000a006:	ed b0 00 00 	bld	r0,0x0
8000a00a:	c1 11       	brne	8000a02c <_dtoa_r+0xa98>
8000a00c:	e0 40 00 39 	cp.w	r0,57
8000a010:	c0 a0       	breq	8000a024 <_dtoa_r+0xa90>
8000a012:	2f f0       	sub	r0,-1
8000a014:	c0 c8       	rjmp	8000a02c <_dtoa_r+0xa98>
8000a016:	58 06       	cp.w	r6,0
8000a018:	e0 8a 00 0c 	brle	8000a030 <_dtoa_r+0xa9c>
8000a01c:	40 26       	lddsp	r6,sp[0x8]
8000a01e:	e0 40 00 39 	cp.w	r0,57
8000a022:	c0 41       	brne	8000a02a <_dtoa_r+0xa96>
8000a024:	33 98       	mov	r8,57
8000a026:	0a c8       	st.b	r5++,r8
8000a028:	c6 78       	rjmp	8000a0f6 <_dtoa_r+0xb62>
8000a02a:	2f f0       	sub	r0,-1
8000a02c:	0a c0       	st.b	r5++,r0
8000a02e:	c7 58       	rjmp	8000a118 <_dtoa_r+0xb84>
8000a030:	0a c0       	st.b	r5++,r0
8000a032:	40 9a       	lddsp	r10,sp[0x24]
8000a034:	40 e9       	lddsp	r9,sp[0x38]
8000a036:	12 3a       	cp.w	r10,r9
8000a038:	c4 30       	breq	8000a0be <_dtoa_r+0xb2a>
8000a03a:	06 9b       	mov	r11,r3
8000a03c:	30 09       	mov	r9,0
8000a03e:	30 aa       	mov	r10,10
8000a040:	0e 9c       	mov	r12,r7
8000a042:	e0 a0 07 37 	rcall	8000aeb0 <__multadd>
8000a046:	40 48       	lddsp	r8,sp[0x10]
8000a048:	18 93       	mov	r3,r12
8000a04a:	08 38       	cp.w	r8,r4
8000a04c:	c0 91       	brne	8000a05e <_dtoa_r+0xaca>
8000a04e:	10 9b       	mov	r11,r8
8000a050:	30 09       	mov	r9,0
8000a052:	30 aa       	mov	r10,10
8000a054:	0e 9c       	mov	r12,r7
8000a056:	e0 a0 07 2d 	rcall	8000aeb0 <__multadd>
8000a05a:	50 4c       	stdsp	sp[0x10],r12
8000a05c:	c0 e8       	rjmp	8000a078 <_dtoa_r+0xae4>
8000a05e:	40 4b       	lddsp	r11,sp[0x10]
8000a060:	30 09       	mov	r9,0
8000a062:	30 aa       	mov	r10,10
8000a064:	0e 9c       	mov	r12,r7
8000a066:	e0 a0 07 25 	rcall	8000aeb0 <__multadd>
8000a06a:	08 9b       	mov	r11,r4
8000a06c:	50 4c       	stdsp	sp[0x10],r12
8000a06e:	30 09       	mov	r9,0
8000a070:	30 aa       	mov	r10,10
8000a072:	0e 9c       	mov	r12,r7
8000a074:	e0 a0 07 1e 	rcall	8000aeb0 <__multadd>
8000a078:	18 94       	mov	r4,r12
8000a07a:	40 9c       	lddsp	r12,sp[0x24]
8000a07c:	2f fc       	sub	r12,-1
8000a07e:	50 9c       	stdsp	sp[0x24],r12
8000a080:	c7 9b       	rjmp	80009f72 <_dtoa_r+0x9de>
8000a082:	30 18       	mov	r8,1
8000a084:	06 90       	mov	r0,r3
8000a086:	40 85       	lddsp	r5,sp[0x20]
8000a088:	08 93       	mov	r3,r4
8000a08a:	0c 94       	mov	r4,r6
8000a08c:	10 96       	mov	r6,r8
8000a08e:	04 9b       	mov	r11,r2
8000a090:	00 9c       	mov	r12,r0
8000a092:	fe b0 f9 f1 	rcall	80009474 <quorem>
8000a096:	2d 0c       	sub	r12,-48
8000a098:	0a cc       	st.b	r5++,r12
8000a09a:	02 36       	cp.w	r6,r1
8000a09c:	c0 a4       	brge	8000a0b0 <_dtoa_r+0xb1c>
8000a09e:	00 9b       	mov	r11,r0
8000a0a0:	30 09       	mov	r9,0
8000a0a2:	30 aa       	mov	r10,10
8000a0a4:	0e 9c       	mov	r12,r7
8000a0a6:	2f f6       	sub	r6,-1
8000a0a8:	e0 a0 07 04 	rcall	8000aeb0 <__multadd>
8000a0ac:	18 90       	mov	r0,r12
8000a0ae:	cf 0b       	rjmp	8000a08e <_dtoa_r+0xafa>
8000a0b0:	08 96       	mov	r6,r4
8000a0b2:	30 0b       	mov	r11,0
8000a0b4:	06 94       	mov	r4,r3
8000a0b6:	50 4b       	stdsp	sp[0x10],r11
8000a0b8:	00 93       	mov	r3,r0
8000a0ba:	18 90       	mov	r0,r12
8000a0bc:	c0 28       	rjmp	8000a0c0 <_dtoa_r+0xb2c>
8000a0be:	40 26       	lddsp	r6,sp[0x8]
8000a0c0:	06 9b       	mov	r11,r3
8000a0c2:	30 1a       	mov	r10,1
8000a0c4:	0e 9c       	mov	r12,r7
8000a0c6:	e0 a0 06 29 	rcall	8000ad18 <__lshift>
8000a0ca:	04 9b       	mov	r11,r2
8000a0cc:	18 93       	mov	r3,r12
8000a0ce:	e0 a0 05 02 	rcall	8000aad2 <__mcmp>
8000a0d2:	e0 89 00 12 	brgt	8000a0f6 <_dtoa_r+0xb62>
8000a0d6:	c1 b1       	brne	8000a10c <_dtoa_r+0xb78>
8000a0d8:	e1 d0 c0 01 	bfextu	r0,r0,0x0,0x1
8000a0dc:	c0 d1       	brne	8000a0f6 <_dtoa_r+0xb62>
8000a0de:	c1 78       	rjmp	8000a10c <_dtoa_r+0xb78>
8000a0e0:	40 89       	lddsp	r9,sp[0x20]
8000a0e2:	12 38       	cp.w	r8,r9
8000a0e4:	c0 30       	breq	8000a0ea <_dtoa_r+0xb56>
8000a0e6:	10 95       	mov	r5,r8
8000a0e8:	c0 88       	rjmp	8000a0f8 <_dtoa_r+0xb64>
8000a0ea:	2f f6       	sub	r6,-1
8000a0ec:	50 66       	stdsp	sp[0x18],r6
8000a0ee:	33 18       	mov	r8,49
8000a0f0:	40 8c       	lddsp	r12,sp[0x20]
8000a0f2:	b8 88       	st.b	r12[0x0],r8
8000a0f4:	c1 38       	rjmp	8000a11a <_dtoa_r+0xb86>
8000a0f6:	33 9a       	mov	r10,57
8000a0f8:	0a 98       	mov	r8,r5
8000a0fa:	11 79       	ld.ub	r9,--r8
8000a0fc:	f4 09 18 00 	cp.b	r9,r10
8000a100:	cf 00       	breq	8000a0e0 <_dtoa_r+0xb4c>
8000a102:	2f f9       	sub	r9,-1
8000a104:	b0 89       	st.b	r8[0x0],r9
8000a106:	c0 98       	rjmp	8000a118 <_dtoa_r+0xb84>
8000a108:	10 95       	mov	r5,r8
8000a10a:	c0 28       	rjmp	8000a10e <_dtoa_r+0xb7a>
8000a10c:	33 09       	mov	r9,48
8000a10e:	0a 98       	mov	r8,r5
8000a110:	11 7a       	ld.ub	r10,--r8
8000a112:	f2 0a 18 00 	cp.b	r10,r9
8000a116:	cf 90       	breq	8000a108 <_dtoa_r+0xb74>
8000a118:	50 66       	stdsp	sp[0x18],r6
8000a11a:	04 9b       	mov	r11,r2
8000a11c:	0e 9c       	mov	r12,r7
8000a11e:	e0 a0 04 f3 	rcall	8000ab04 <_Bfree>
8000a122:	58 04       	cp.w	r4,0
8000a124:	c1 20       	breq	8000a148 <_dtoa_r+0xbb4>
8000a126:	40 4b       	lddsp	r11,sp[0x10]
8000a128:	08 3b       	cp.w	r11,r4
8000a12a:	5f 19       	srne	r9
8000a12c:	58 0b       	cp.w	r11,0
8000a12e:	5f 18       	srne	r8
8000a130:	f3 e8 00 08 	and	r8,r9,r8
8000a134:	c0 40       	breq	8000a13c <_dtoa_r+0xba8>
8000a136:	0e 9c       	mov	r12,r7
8000a138:	e0 a0 04 e6 	rcall	8000ab04 <_Bfree>
8000a13c:	08 9b       	mov	r11,r4
8000a13e:	0e 9c       	mov	r12,r7
8000a140:	e0 a0 04 e2 	rcall	8000ab04 <_Bfree>
8000a144:	c0 28       	rjmp	8000a148 <_dtoa_r+0xbb4>
8000a146:	50 66       	stdsp	sp[0x18],r6
8000a148:	0e 9c       	mov	r12,r7
8000a14a:	06 9b       	mov	r11,r3
8000a14c:	e0 a0 04 dc 	rcall	8000ab04 <_Bfree>
8000a150:	30 08       	mov	r8,0
8000a152:	aa 88       	st.b	r5[0x0],r8
8000a154:	40 68       	lddsp	r8,sp[0x18]
8000a156:	41 5a       	lddsp	r10,sp[0x54]
8000a158:	2f f8       	sub	r8,-1
8000a15a:	41 29       	lddsp	r9,sp[0x48]
8000a15c:	95 08       	st.w	r10[0x0],r8
8000a15e:	40 8c       	lddsp	r12,sp[0x20]
8000a160:	58 09       	cp.w	r9,0
8000a162:	fb f8 10 12 	ld.wne	r8,sp[0x48]
8000a166:	f1 f5 1a 00 	st.wne	r8[0x0],r5
8000a16a:	2e 6d       	sub	sp,-104
8000a16c:	d8 32       	popm	r0-r7,pc
8000a16e:	d7 03       	nop

8000a170 <__errno>:
8000a170:	e0 68 0a 30 	mov	r8,2608
8000a174:	70 0c       	ld.w	r12,r8[0x0]
8000a176:	2f 4c       	sub	r12,-12
8000a178:	5e fc       	retal	r12
8000a17a:	d7 03       	nop

8000a17c <_fflush_r>:
8000a17c:	d4 21       	pushm	r4-r7,lr
8000a17e:	16 97       	mov	r7,r11
8000a180:	18 96       	mov	r6,r12
8000a182:	76 48       	ld.w	r8,r11[0x10]
8000a184:	58 08       	cp.w	r8,0
8000a186:	c7 f0       	breq	8000a284 <_fflush_r+0x108>
8000a188:	58 0c       	cp.w	r12,0
8000a18a:	c0 50       	breq	8000a194 <_fflush_r+0x18>
8000a18c:	78 68       	ld.w	r8,r12[0x18]
8000a18e:	58 08       	cp.w	r8,0
8000a190:	c0 21       	brne	8000a194 <_fflush_r+0x18>
8000a192:	cc dc       	rcall	8000a32c <__sinit>
8000a194:	fe c8 cd fc 	sub	r8,pc,-12804
8000a198:	10 37       	cp.w	r7,r8
8000a19a:	c0 31       	brne	8000a1a0 <_fflush_r+0x24>
8000a19c:	6c 07       	ld.w	r7,r6[0x0]
8000a19e:	c0 c8       	rjmp	8000a1b6 <_fflush_r+0x3a>
8000a1a0:	fe c8 cd e8 	sub	r8,pc,-12824
8000a1a4:	10 37       	cp.w	r7,r8
8000a1a6:	c0 31       	brne	8000a1ac <_fflush_r+0x30>
8000a1a8:	6c 17       	ld.w	r7,r6[0x4]
8000a1aa:	c0 68       	rjmp	8000a1b6 <_fflush_r+0x3a>
8000a1ac:	fe c8 cd d4 	sub	r8,pc,-12844
8000a1b0:	10 37       	cp.w	r7,r8
8000a1b2:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000a1b6:	8e 6a       	ld.sh	r10,r7[0xc]
8000a1b8:	14 98       	mov	r8,r10
8000a1ba:	ed ba 00 03 	bld	r10,0x3
8000a1be:	c4 20       	breq	8000a242 <_fflush_r+0xc6>
8000a1c0:	ab ba       	sbr	r10,0xb
8000a1c2:	ae 6a       	st.h	r7[0xc],r10
8000a1c4:	6e 18       	ld.w	r8,r7[0x4]
8000a1c6:	58 08       	cp.w	r8,0
8000a1c8:	e0 89 00 06 	brgt	8000a1d4 <_fflush_r+0x58>
8000a1cc:	6f 08       	ld.w	r8,r7[0x40]
8000a1ce:	58 08       	cp.w	r8,0
8000a1d0:	e0 8a 00 5a 	brle	8000a284 <_fflush_r+0x108>
8000a1d4:	6e b8       	ld.w	r8,r7[0x2c]
8000a1d6:	58 08       	cp.w	r8,0
8000a1d8:	c5 60       	breq	8000a284 <_fflush_r+0x108>
8000a1da:	e2 1a 10 00 	andl	r10,0x1000,COH
8000a1de:	c0 30       	breq	8000a1e4 <_fflush_r+0x68>
8000a1e0:	6f 55       	ld.w	r5,r7[0x54]
8000a1e2:	c0 f8       	rjmp	8000a200 <_fflush_r+0x84>
8000a1e4:	30 19       	mov	r9,1
8000a1e6:	6e 8b       	ld.w	r11,r7[0x20]
8000a1e8:	0c 9c       	mov	r12,r6
8000a1ea:	5d 18       	icall	r8
8000a1ec:	18 95       	mov	r5,r12
8000a1ee:	5b fc       	cp.w	r12,-1
8000a1f0:	c0 81       	brne	8000a200 <_fflush_r+0x84>
8000a1f2:	6c 38       	ld.w	r8,r6[0xc]
8000a1f4:	59 d8       	cp.w	r8,29
8000a1f6:	c4 70       	breq	8000a284 <_fflush_r+0x108>
8000a1f8:	8e 68       	ld.sh	r8,r7[0xc]
8000a1fa:	a7 a8       	sbr	r8,0x6
8000a1fc:	ae 68       	st.h	r7[0xc],r8
8000a1fe:	d8 22       	popm	r4-r7,pc
8000a200:	8e 68       	ld.sh	r8,r7[0xc]
8000a202:	ed b8 00 02 	bld	r8,0x2
8000a206:	c0 91       	brne	8000a218 <_fflush_r+0x9c>
8000a208:	6e 18       	ld.w	r8,r7[0x4]
8000a20a:	10 15       	sub	r5,r8
8000a20c:	6e d8       	ld.w	r8,r7[0x34]
8000a20e:	58 08       	cp.w	r8,0
8000a210:	ef f8 10 10 	ld.wne	r8,r7[0x40]
8000a214:	eb d8 e1 15 	subne	r5,r5,r8
8000a218:	6e b8       	ld.w	r8,r7[0x2c]
8000a21a:	0c 9c       	mov	r12,r6
8000a21c:	30 09       	mov	r9,0
8000a21e:	0a 9a       	mov	r10,r5
8000a220:	6e 8b       	ld.w	r11,r7[0x20]
8000a222:	5d 18       	icall	r8
8000a224:	8e 68       	ld.sh	r8,r7[0xc]
8000a226:	0a 3c       	cp.w	r12,r5
8000a228:	c2 61       	brne	8000a274 <_fflush_r+0xf8>
8000a22a:	ab d8       	cbr	r8,0xb
8000a22c:	30 0c       	mov	r12,0
8000a22e:	6e 49       	ld.w	r9,r7[0x10]
8000a230:	ae 68       	st.h	r7[0xc],r8
8000a232:	8f 1c       	st.w	r7[0x4],r12
8000a234:	8f 09       	st.w	r7[0x0],r9
8000a236:	ed b8 00 0c 	bld	r8,0xc
8000a23a:	c2 51       	brne	8000a284 <_fflush_r+0x108>
8000a23c:	ef 45 00 54 	st.w	r7[84],r5
8000a240:	d8 22       	popm	r4-r7,pc
8000a242:	6e 45       	ld.w	r5,r7[0x10]
8000a244:	58 05       	cp.w	r5,0
8000a246:	c1 f0       	breq	8000a284 <_fflush_r+0x108>
8000a248:	6e 04       	ld.w	r4,r7[0x0]
8000a24a:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
8000a24e:	8f 05       	st.w	r7[0x0],r5
8000a250:	f9 b8 01 00 	movne	r8,0
8000a254:	ef f8 00 05 	ld.weq	r8,r7[0x14]
8000a258:	0a 14       	sub	r4,r5
8000a25a:	8f 28       	st.w	r7[0x8],r8
8000a25c:	c1 18       	rjmp	8000a27e <_fflush_r+0x102>
8000a25e:	08 99       	mov	r9,r4
8000a260:	0a 9a       	mov	r10,r5
8000a262:	6e a8       	ld.w	r8,r7[0x28]
8000a264:	6e 8b       	ld.w	r11,r7[0x20]
8000a266:	0c 9c       	mov	r12,r6
8000a268:	5d 18       	icall	r8
8000a26a:	18 14       	sub	r4,r12
8000a26c:	58 0c       	cp.w	r12,0
8000a26e:	e0 89 00 07 	brgt	8000a27c <_fflush_r+0x100>
8000a272:	8e 68       	ld.sh	r8,r7[0xc]
8000a274:	a7 a8       	sbr	r8,0x6
8000a276:	3f fc       	mov	r12,-1
8000a278:	ae 68       	st.h	r7[0xc],r8
8000a27a:	d8 22       	popm	r4-r7,pc
8000a27c:	18 05       	add	r5,r12
8000a27e:	58 04       	cp.w	r4,0
8000a280:	fe 99 ff ef 	brgt	8000a25e <_fflush_r+0xe2>
8000a284:	d8 2a       	popm	r4-r7,pc,r12=0
8000a286:	d7 03       	nop

8000a288 <__sfp_lock_acquire>:
8000a288:	5e fc       	retal	r12

8000a28a <__sfp_lock_release>:
8000a28a:	5e fc       	retal	r12

8000a28c <_cleanup_r>:
8000a28c:	d4 01       	pushm	lr
8000a28e:	fe cb f0 c6 	sub	r11,pc,-3898
8000a292:	e0 a0 02 f7 	rcall	8000a880 <_fwalk>
8000a296:	d8 02       	popm	pc

8000a298 <__sfmoreglue>:
8000a298:	d4 21       	pushm	r4-r7,lr
8000a29a:	16 95       	mov	r5,r11
8000a29c:	f6 06 10 5c 	mul	r6,r11,92
8000a2a0:	ec cb ff f4 	sub	r11,r6,-12
8000a2a4:	fe b0 e2 7c 	rcall	8000679c <_malloc_r>
8000a2a8:	18 97       	mov	r7,r12
8000a2aa:	c0 90       	breq	8000a2bc <__sfmoreglue+0x24>
8000a2ac:	99 15       	st.w	r12[0x4],r5
8000a2ae:	30 0b       	mov	r11,0
8000a2b0:	2f 4c       	sub	r12,-12
8000a2b2:	0c 9a       	mov	r10,r6
8000a2b4:	8f 2c       	st.w	r7[0x8],r12
8000a2b6:	8f 0b       	st.w	r7[0x0],r11
8000a2b8:	fe b0 e5 32 	rcall	80006d1c <memset>
8000a2bc:	0e 9c       	mov	r12,r7
8000a2be:	d8 22       	popm	r4-r7,pc

8000a2c0 <__sfp>:
8000a2c0:	d4 21       	pushm	r4-r7,lr
8000a2c2:	fe c8 ce c6 	sub	r8,pc,-12602
8000a2c6:	18 96       	mov	r6,r12
8000a2c8:	70 07       	ld.w	r7,r8[0x0]
8000a2ca:	6e 68       	ld.w	r8,r7[0x18]
8000a2cc:	58 08       	cp.w	r8,0
8000a2ce:	c0 31       	brne	8000a2d4 <__sfp+0x14>
8000a2d0:	0e 9c       	mov	r12,r7
8000a2d2:	c2 dc       	rcall	8000a32c <__sinit>
8000a2d4:	ee c7 ff 28 	sub	r7,r7,-216
8000a2d8:	30 05       	mov	r5,0
8000a2da:	6e 2c       	ld.w	r12,r7[0x8]
8000a2dc:	6e 18       	ld.w	r8,r7[0x4]
8000a2de:	c0 68       	rjmp	8000a2ea <__sfp+0x2a>
8000a2e0:	98 69       	ld.sh	r9,r12[0xc]
8000a2e2:	ea 09 19 00 	cp.h	r9,r5
8000a2e6:	c1 10       	breq	8000a308 <__sfp+0x48>
8000a2e8:	2a 4c       	sub	r12,-92
8000a2ea:	20 18       	sub	r8,1
8000a2ec:	cf a7       	brpl	8000a2e0 <__sfp+0x20>
8000a2ee:	6e 08       	ld.w	r8,r7[0x0]
8000a2f0:	58 08       	cp.w	r8,0
8000a2f2:	c0 61       	brne	8000a2fe <__sfp+0x3e>
8000a2f4:	30 4b       	mov	r11,4
8000a2f6:	0c 9c       	mov	r12,r6
8000a2f8:	cd 0f       	rcall	8000a298 <__sfmoreglue>
8000a2fa:	8f 0c       	st.w	r7[0x0],r12
8000a2fc:	c0 30       	breq	8000a302 <__sfp+0x42>
8000a2fe:	6e 07       	ld.w	r7,r7[0x0]
8000a300:	ce db       	rjmp	8000a2da <__sfp+0x1a>
8000a302:	30 c8       	mov	r8,12
8000a304:	8d 38       	st.w	r6[0xc],r8
8000a306:	d8 22       	popm	r4-r7,pc
8000a308:	30 08       	mov	r8,0
8000a30a:	f9 48 00 4c 	st.w	r12[76],r8
8000a30e:	99 08       	st.w	r12[0x0],r8
8000a310:	99 28       	st.w	r12[0x8],r8
8000a312:	99 18       	st.w	r12[0x4],r8
8000a314:	99 48       	st.w	r12[0x10],r8
8000a316:	99 58       	st.w	r12[0x14],r8
8000a318:	99 68       	st.w	r12[0x18],r8
8000a31a:	99 d8       	st.w	r12[0x34],r8
8000a31c:	99 e8       	st.w	r12[0x38],r8
8000a31e:	f9 48 00 48 	st.w	r12[72],r8
8000a322:	3f f8       	mov	r8,-1
8000a324:	b8 78       	st.h	r12[0xe],r8
8000a326:	30 18       	mov	r8,1
8000a328:	b8 68       	st.h	r12[0xc],r8
8000a32a:	d8 22       	popm	r4-r7,pc

8000a32c <__sinit>:
8000a32c:	d4 21       	pushm	r4-r7,lr
8000a32e:	18 96       	mov	r6,r12
8000a330:	78 67       	ld.w	r7,r12[0x18]
8000a332:	58 07       	cp.w	r7,0
8000a334:	c4 91       	brne	8000a3c6 <__sinit+0x9a>
8000a336:	fe c8 00 aa 	sub	r8,pc,170
8000a33a:	30 15       	mov	r5,1
8000a33c:	99 a8       	st.w	r12[0x28],r8
8000a33e:	f9 47 00 d8 	st.w	r12[216],r7
8000a342:	f9 47 00 dc 	st.w	r12[220],r7
8000a346:	f9 47 00 e0 	st.w	r12[224],r7
8000a34a:	99 65       	st.w	r12[0x18],r5
8000a34c:	cb af       	rcall	8000a2c0 <__sfp>
8000a34e:	8d 0c       	st.w	r6[0x0],r12
8000a350:	0c 9c       	mov	r12,r6
8000a352:	cb 7f       	rcall	8000a2c0 <__sfp>
8000a354:	8d 1c       	st.w	r6[0x4],r12
8000a356:	0c 9c       	mov	r12,r6
8000a358:	cb 4f       	rcall	8000a2c0 <__sfp>
8000a35a:	6c 09       	ld.w	r9,r6[0x0]
8000a35c:	30 48       	mov	r8,4
8000a35e:	93 07       	st.w	r9[0x0],r7
8000a360:	b2 68       	st.h	r9[0xc],r8
8000a362:	93 17       	st.w	r9[0x4],r7
8000a364:	93 27       	st.w	r9[0x8],r7
8000a366:	6c 18       	ld.w	r8,r6[0x4]
8000a368:	b2 77       	st.h	r9[0xe],r7
8000a36a:	93 47       	st.w	r9[0x10],r7
8000a36c:	93 57       	st.w	r9[0x14],r7
8000a36e:	93 67       	st.w	r9[0x18],r7
8000a370:	93 89       	st.w	r9[0x20],r9
8000a372:	91 07       	st.w	r8[0x0],r7
8000a374:	91 17       	st.w	r8[0x4],r7
8000a376:	91 27       	st.w	r8[0x8],r7
8000a378:	fe ce f3 24 	sub	lr,pc,-3292
8000a37c:	fe cb f3 54 	sub	r11,pc,-3244
8000a380:	93 9e       	st.w	r9[0x24],lr
8000a382:	93 ab       	st.w	r9[0x28],r11
8000a384:	fe ca f3 7c 	sub	r10,pc,-3204
8000a388:	fe c4 f3 88 	sub	r4,pc,-3192
8000a38c:	93 ba       	st.w	r9[0x2c],r10
8000a38e:	93 c4       	st.w	r9[0x30],r4
8000a390:	30 99       	mov	r9,9
8000a392:	b0 69       	st.h	r8[0xc],r9
8000a394:	b0 75       	st.h	r8[0xe],r5
8000a396:	91 c4       	st.w	r8[0x30],r4
8000a398:	91 47       	st.w	r8[0x10],r7
8000a39a:	91 57       	st.w	r8[0x14],r7
8000a39c:	91 67       	st.w	r8[0x18],r7
8000a39e:	91 88       	st.w	r8[0x20],r8
8000a3a0:	91 9e       	st.w	r8[0x24],lr
8000a3a2:	91 ab       	st.w	r8[0x28],r11
8000a3a4:	91 ba       	st.w	r8[0x2c],r10
8000a3a6:	8d 2c       	st.w	r6[0x8],r12
8000a3a8:	31 28       	mov	r8,18
8000a3aa:	99 07       	st.w	r12[0x0],r7
8000a3ac:	b8 68       	st.h	r12[0xc],r8
8000a3ae:	99 17       	st.w	r12[0x4],r7
8000a3b0:	99 27       	st.w	r12[0x8],r7
8000a3b2:	30 28       	mov	r8,2
8000a3b4:	b8 78       	st.h	r12[0xe],r8
8000a3b6:	99 c4       	st.w	r12[0x30],r4
8000a3b8:	99 67       	st.w	r12[0x18],r7
8000a3ba:	99 9e       	st.w	r12[0x24],lr
8000a3bc:	99 ab       	st.w	r12[0x28],r11
8000a3be:	99 ba       	st.w	r12[0x2c],r10
8000a3c0:	99 47       	st.w	r12[0x10],r7
8000a3c2:	99 57       	st.w	r12[0x14],r7
8000a3c4:	99 8c       	st.w	r12[0x20],r12
8000a3c6:	d8 22       	popm	r4-r7,pc

8000a3c8 <_malloc_trim_r>:
8000a3c8:	d4 21       	pushm	r4-r7,lr
8000a3ca:	16 95       	mov	r5,r11
8000a3cc:	18 97       	mov	r7,r12
8000a3ce:	fe b0 d7 53 	rcall	80005274 <__malloc_lock>
8000a3d2:	e0 64 05 30 	mov	r4,1328
8000a3d6:	68 28       	ld.w	r8,r4[0x8]
8000a3d8:	70 16       	ld.w	r6,r8[0x4]
8000a3da:	e0 16 ff fc 	andl	r6,0xfffc
8000a3de:	ec c8 ff 91 	sub	r8,r6,-111
8000a3e2:	f0 05 01 05 	sub	r5,r8,r5
8000a3e6:	e0 15 ff 80 	andl	r5,0xff80
8000a3ea:	ea c5 00 80 	sub	r5,r5,128
8000a3ee:	e0 45 00 7f 	cp.w	r5,127
8000a3f2:	e0 8a 00 25 	brle	8000a43c <_malloc_trim_r+0x74>
8000a3f6:	30 0b       	mov	r11,0
8000a3f8:	0e 9c       	mov	r12,r7
8000a3fa:	fe b0 e5 f9 	rcall	80006fec <_sbrk_r>
8000a3fe:	68 28       	ld.w	r8,r4[0x8]
8000a400:	0c 08       	add	r8,r6
8000a402:	10 3c       	cp.w	r12,r8
8000a404:	c1 c1       	brne	8000a43c <_malloc_trim_r+0x74>
8000a406:	ea 0b 11 00 	rsub	r11,r5,0
8000a40a:	0e 9c       	mov	r12,r7
8000a40c:	fe b0 e5 f0 	rcall	80006fec <_sbrk_r>
8000a410:	5b fc       	cp.w	r12,-1
8000a412:	c1 91       	brne	8000a444 <_malloc_trim_r+0x7c>
8000a414:	30 0b       	mov	r11,0
8000a416:	0e 9c       	mov	r12,r7
8000a418:	fe b0 e5 ea 	rcall	80006fec <_sbrk_r>
8000a41c:	68 28       	ld.w	r8,r4[0x8]
8000a41e:	f8 08 01 09 	sub	r9,r12,r8
8000a422:	58 f9       	cp.w	r9,15
8000a424:	e0 8a 00 0c 	brle	8000a43c <_malloc_trim_r+0x74>
8000a428:	a1 a9       	sbr	r9,0x0
8000a42a:	91 19       	st.w	r8[0x4],r9
8000a42c:	e0 68 09 3c 	mov	r8,2364
8000a430:	70 09       	ld.w	r9,r8[0x0]
8000a432:	e0 68 0d 68 	mov	r8,3432
8000a436:	f8 09 01 09 	sub	r9,r12,r9
8000a43a:	91 09       	st.w	r8[0x0],r9
8000a43c:	0e 9c       	mov	r12,r7
8000a43e:	fe b0 d7 21 	rcall	80005280 <__malloc_unlock>
8000a442:	d8 2a       	popm	r4-r7,pc,r12=0
8000a444:	68 28       	ld.w	r8,r4[0x8]
8000a446:	0a 16       	sub	r6,r5
8000a448:	a1 a6       	sbr	r6,0x0
8000a44a:	91 16       	st.w	r8[0x4],r6
8000a44c:	e0 68 0d 68 	mov	r8,3432
8000a450:	70 09       	ld.w	r9,r8[0x0]
8000a452:	0a 19       	sub	r9,r5
8000a454:	0e 9c       	mov	r12,r7
8000a456:	91 09       	st.w	r8[0x0],r9
8000a458:	fe b0 d7 14 	rcall	80005280 <__malloc_unlock>
8000a45c:	da 2a       	popm	r4-r7,pc,r12=1
8000a45e:	d7 03       	nop

8000a460 <_free_r>:
8000a460:	d4 21       	pushm	r4-r7,lr
8000a462:	16 96       	mov	r6,r11
8000a464:	18 97       	mov	r7,r12
8000a466:	58 0b       	cp.w	r11,0
8000a468:	e0 80 00 c0 	breq	8000a5e8 <_free_r+0x188>
8000a46c:	fe b0 d7 04 	rcall	80005274 <__malloc_lock>
8000a470:	20 86       	sub	r6,8
8000a472:	e0 6a 05 30 	mov	r10,1328
8000a476:	6c 18       	ld.w	r8,r6[0x4]
8000a478:	74 2e       	ld.w	lr,r10[0x8]
8000a47a:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
8000a47e:	a1 c8       	cbr	r8,0x0
8000a480:	ec 08 00 09 	add	r9,r6,r8
8000a484:	72 1b       	ld.w	r11,r9[0x4]
8000a486:	e0 1b ff fc 	andl	r11,0xfffc
8000a48a:	1c 39       	cp.w	r9,lr
8000a48c:	c1 e1       	brne	8000a4c8 <_free_r+0x68>
8000a48e:	f6 08 00 08 	add	r8,r11,r8
8000a492:	58 0c       	cp.w	r12,0
8000a494:	c0 81       	brne	8000a4a4 <_free_r+0x44>
8000a496:	6c 09       	ld.w	r9,r6[0x0]
8000a498:	12 16       	sub	r6,r9
8000a49a:	12 08       	add	r8,r9
8000a49c:	6c 3b       	ld.w	r11,r6[0xc]
8000a49e:	6c 29       	ld.w	r9,r6[0x8]
8000a4a0:	97 29       	st.w	r11[0x8],r9
8000a4a2:	93 3b       	st.w	r9[0xc],r11
8000a4a4:	10 99       	mov	r9,r8
8000a4a6:	95 26       	st.w	r10[0x8],r6
8000a4a8:	a1 a9       	sbr	r9,0x0
8000a4aa:	8d 19       	st.w	r6[0x4],r9
8000a4ac:	e0 69 09 38 	mov	r9,2360
8000a4b0:	72 09       	ld.w	r9,r9[0x0]
8000a4b2:	12 38       	cp.w	r8,r9
8000a4b4:	c0 63       	brcs	8000a4c0 <_free_r+0x60>
8000a4b6:	e0 68 0d 64 	mov	r8,3428
8000a4ba:	0e 9c       	mov	r12,r7
8000a4bc:	70 0b       	ld.w	r11,r8[0x0]
8000a4be:	c8 5f       	rcall	8000a3c8 <_malloc_trim_r>
8000a4c0:	0e 9c       	mov	r12,r7
8000a4c2:	fe b0 d6 df 	rcall	80005280 <__malloc_unlock>
8000a4c6:	d8 22       	popm	r4-r7,pc
8000a4c8:	93 1b       	st.w	r9[0x4],r11
8000a4ca:	58 0c       	cp.w	r12,0
8000a4cc:	c0 30       	breq	8000a4d2 <_free_r+0x72>
8000a4ce:	30 0c       	mov	r12,0
8000a4d0:	c1 08       	rjmp	8000a4f0 <_free_r+0x90>
8000a4d2:	6c 0e       	ld.w	lr,r6[0x0]
8000a4d4:	f4 c5 ff f8 	sub	r5,r10,-8
8000a4d8:	1c 16       	sub	r6,lr
8000a4da:	1c 08       	add	r8,lr
8000a4dc:	6c 2e       	ld.w	lr,r6[0x8]
8000a4de:	0a 3e       	cp.w	lr,r5
8000a4e0:	f9 bc 00 01 	moveq	r12,1
8000a4e4:	ed f5 10 03 	ld.wne	r5,r6[0xc]
8000a4e8:	eb fe 1a 02 	st.wne	r5[0x8],lr
8000a4ec:	fd f5 1a 03 	st.wne	lr[0xc],r5
8000a4f0:	f2 0b 00 0e 	add	lr,r9,r11
8000a4f4:	7c 1e       	ld.w	lr,lr[0x4]
8000a4f6:	ed be 00 00 	bld	lr,0x0
8000a4fa:	c1 40       	breq	8000a522 <_free_r+0xc2>
8000a4fc:	16 08       	add	r8,r11
8000a4fe:	58 0c       	cp.w	r12,0
8000a500:	c0 d1       	brne	8000a51a <_free_r+0xba>
8000a502:	e0 6e 05 30 	mov	lr,1328
8000a506:	72 2b       	ld.w	r11,r9[0x8]
8000a508:	2f 8e       	sub	lr,-8
8000a50a:	1c 3b       	cp.w	r11,lr
8000a50c:	c0 71       	brne	8000a51a <_free_r+0xba>
8000a50e:	97 36       	st.w	r11[0xc],r6
8000a510:	97 26       	st.w	r11[0x8],r6
8000a512:	8d 2b       	st.w	r6[0x8],r11
8000a514:	8d 3b       	st.w	r6[0xc],r11
8000a516:	30 1c       	mov	r12,1
8000a518:	c0 58       	rjmp	8000a522 <_free_r+0xc2>
8000a51a:	72 2b       	ld.w	r11,r9[0x8]
8000a51c:	72 39       	ld.w	r9,r9[0xc]
8000a51e:	93 2b       	st.w	r9[0x8],r11
8000a520:	97 39       	st.w	r11[0xc],r9
8000a522:	10 99       	mov	r9,r8
8000a524:	ec 08 09 08 	st.w	r6[r8],r8
8000a528:	a1 a9       	sbr	r9,0x0
8000a52a:	8d 19       	st.w	r6[0x4],r9
8000a52c:	58 0c       	cp.w	r12,0
8000a52e:	c5 a1       	brne	8000a5e2 <_free_r+0x182>
8000a530:	e0 48 01 ff 	cp.w	r8,511
8000a534:	e0 8b 00 13 	brhi	8000a55a <_free_r+0xfa>
8000a538:	a3 98       	lsr	r8,0x3
8000a53a:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000a53e:	72 2b       	ld.w	r11,r9[0x8]
8000a540:	8d 39       	st.w	r6[0xc],r9
8000a542:	8d 2b       	st.w	r6[0x8],r11
8000a544:	97 36       	st.w	r11[0xc],r6
8000a546:	93 26       	st.w	r9[0x8],r6
8000a548:	a3 48       	asr	r8,0x2
8000a54a:	74 19       	ld.w	r9,r10[0x4]
8000a54c:	30 1b       	mov	r11,1
8000a54e:	f6 08 09 48 	lsl	r8,r11,r8
8000a552:	f3 e8 10 08 	or	r8,r9,r8
8000a556:	95 18       	st.w	r10[0x4],r8
8000a558:	c4 58       	rjmp	8000a5e2 <_free_r+0x182>
8000a55a:	f0 0b 16 09 	lsr	r11,r8,0x9
8000a55e:	58 4b       	cp.w	r11,4
8000a560:	e0 8b 00 06 	brhi	8000a56c <_free_r+0x10c>
8000a564:	f0 0b 16 06 	lsr	r11,r8,0x6
8000a568:	2c 8b       	sub	r11,-56
8000a56a:	c2 08       	rjmp	8000a5aa <_free_r+0x14a>
8000a56c:	59 4b       	cp.w	r11,20
8000a56e:	e0 8b 00 04 	brhi	8000a576 <_free_r+0x116>
8000a572:	2a 5b       	sub	r11,-91
8000a574:	c1 b8       	rjmp	8000a5aa <_free_r+0x14a>
8000a576:	e0 4b 00 54 	cp.w	r11,84
8000a57a:	e0 8b 00 06 	brhi	8000a586 <_free_r+0x126>
8000a57e:	f0 0b 16 0c 	lsr	r11,r8,0xc
8000a582:	29 2b       	sub	r11,-110
8000a584:	c1 38       	rjmp	8000a5aa <_free_r+0x14a>
8000a586:	e0 4b 01 54 	cp.w	r11,340
8000a58a:	e0 8b 00 06 	brhi	8000a596 <_free_r+0x136>
8000a58e:	f0 0b 16 0f 	lsr	r11,r8,0xf
8000a592:	28 9b       	sub	r11,-119
8000a594:	c0 b8       	rjmp	8000a5aa <_free_r+0x14a>
8000a596:	e0 4b 05 54 	cp.w	r11,1364
8000a59a:	e0 88 00 05 	brls	8000a5a4 <_free_r+0x144>
8000a59e:	37 eb       	mov	r11,126
8000a5a0:	c0 58       	rjmp	8000a5aa <_free_r+0x14a>
8000a5a2:	d7 03       	nop
8000a5a4:	f0 0b 16 12 	lsr	r11,r8,0x12
8000a5a8:	28 4b       	sub	r11,-124
8000a5aa:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
8000a5ae:	78 29       	ld.w	r9,r12[0x8]
8000a5b0:	18 39       	cp.w	r9,r12
8000a5b2:	c0 e1       	brne	8000a5ce <_free_r+0x16e>
8000a5b4:	74 18       	ld.w	r8,r10[0x4]
8000a5b6:	a3 4b       	asr	r11,0x2
8000a5b8:	30 1c       	mov	r12,1
8000a5ba:	f8 0b 09 4b 	lsl	r11,r12,r11
8000a5be:	f1 eb 10 0b 	or	r11,r8,r11
8000a5c2:	12 98       	mov	r8,r9
8000a5c4:	95 1b       	st.w	r10[0x4],r11
8000a5c6:	c0 a8       	rjmp	8000a5da <_free_r+0x17a>
8000a5c8:	72 29       	ld.w	r9,r9[0x8]
8000a5ca:	18 39       	cp.w	r9,r12
8000a5cc:	c0 60       	breq	8000a5d8 <_free_r+0x178>
8000a5ce:	72 1a       	ld.w	r10,r9[0x4]
8000a5d0:	e0 1a ff fc 	andl	r10,0xfffc
8000a5d4:	14 38       	cp.w	r8,r10
8000a5d6:	cf 93       	brcs	8000a5c8 <_free_r+0x168>
8000a5d8:	72 38       	ld.w	r8,r9[0xc]
8000a5da:	8d 38       	st.w	r6[0xc],r8
8000a5dc:	8d 29       	st.w	r6[0x8],r9
8000a5de:	93 36       	st.w	r9[0xc],r6
8000a5e0:	91 26       	st.w	r8[0x8],r6
8000a5e2:	0e 9c       	mov	r12,r7
8000a5e4:	fe b0 d6 4e 	rcall	80005280 <__malloc_unlock>
8000a5e8:	d8 22       	popm	r4-r7,pc
8000a5ea:	d7 03       	nop

8000a5ec <__sfvwrite_r>:
8000a5ec:	d4 31       	pushm	r0-r7,lr
8000a5ee:	20 3d       	sub	sp,12
8000a5f0:	14 94       	mov	r4,r10
8000a5f2:	18 95       	mov	r5,r12
8000a5f4:	16 97       	mov	r7,r11
8000a5f6:	74 28       	ld.w	r8,r10[0x8]
8000a5f8:	58 08       	cp.w	r8,0
8000a5fa:	e0 80 01 40 	breq	8000a87a <__sfvwrite_r+0x28e>
8000a5fe:	96 68       	ld.sh	r8,r11[0xc]
8000a600:	ed b8 00 03 	bld	r8,0x3
8000a604:	c0 41       	brne	8000a60c <__sfvwrite_r+0x20>
8000a606:	76 48       	ld.w	r8,r11[0x10]
8000a608:	58 08       	cp.w	r8,0
8000a60a:	c0 c1       	brne	8000a622 <__sfvwrite_r+0x36>
8000a60c:	0e 9b       	mov	r11,r7
8000a60e:	0a 9c       	mov	r12,r5
8000a610:	fe b0 f6 c4 	rcall	80009398 <__swsetup_r>
8000a614:	c0 70       	breq	8000a622 <__sfvwrite_r+0x36>
8000a616:	8e 68       	ld.sh	r8,r7[0xc]
8000a618:	a7 a8       	sbr	r8,0x6
8000a61a:	ae 68       	st.h	r7[0xc],r8
8000a61c:	30 98       	mov	r8,9
8000a61e:	8b 38       	st.w	r5[0xc],r8
8000a620:	c2 b9       	rjmp	8000a876 <__sfvwrite_r+0x28a>
8000a622:	8e 63       	ld.sh	r3,r7[0xc]
8000a624:	68 00       	ld.w	r0,r4[0x0]
8000a626:	06 96       	mov	r6,r3
8000a628:	e2 16 00 02 	andl	r6,0x2,COH
8000a62c:	c2 10       	breq	8000a66e <__sfvwrite_r+0x82>
8000a62e:	30 03       	mov	r3,0
8000a630:	e0 62 04 00 	mov	r2,1024
8000a634:	06 96       	mov	r6,r3
8000a636:	c0 48       	rjmp	8000a63e <__sfvwrite_r+0x52>
8000a638:	60 03       	ld.w	r3,r0[0x0]
8000a63a:	60 16       	ld.w	r6,r0[0x4]
8000a63c:	2f 80       	sub	r0,-8
8000a63e:	58 06       	cp.w	r6,0
8000a640:	cf c0       	breq	8000a638 <__sfvwrite_r+0x4c>
8000a642:	e0 46 04 00 	cp.w	r6,1024
8000a646:	ec 09 17 80 	movls	r9,r6
8000a64a:	e4 09 17 b0 	movhi	r9,r2
8000a64e:	06 9a       	mov	r10,r3
8000a650:	6e a8       	ld.w	r8,r7[0x28]
8000a652:	6e 8b       	ld.w	r11,r7[0x20]
8000a654:	0a 9c       	mov	r12,r5
8000a656:	5d 18       	icall	r8
8000a658:	18 16       	sub	r6,r12
8000a65a:	58 0c       	cp.w	r12,0
8000a65c:	e0 8a 01 0a 	brle	8000a870 <__sfvwrite_r+0x284>
8000a660:	68 28       	ld.w	r8,r4[0x8]
8000a662:	18 18       	sub	r8,r12
8000a664:	89 28       	st.w	r4[0x8],r8
8000a666:	e0 80 01 0a 	breq	8000a87a <__sfvwrite_r+0x28e>
8000a66a:	18 03       	add	r3,r12
8000a66c:	ce 9b       	rjmp	8000a63e <__sfvwrite_r+0x52>
8000a66e:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
8000a672:	c0 70       	breq	8000a680 <__sfvwrite_r+0x94>
8000a674:	50 06       	stdsp	sp[0x0],r6
8000a676:	0c 93       	mov	r3,r6
8000a678:	0c 91       	mov	r1,r6
8000a67a:	50 15       	stdsp	sp[0x4],r5
8000a67c:	08 92       	mov	r2,r4
8000a67e:	c9 c8       	rjmp	8000a7b6 <__sfvwrite_r+0x1ca>
8000a680:	06 96       	mov	r6,r3
8000a682:	08 91       	mov	r1,r4
8000a684:	c0 48       	rjmp	8000a68c <__sfvwrite_r+0xa0>
8000a686:	60 03       	ld.w	r3,r0[0x0]
8000a688:	60 16       	ld.w	r6,r0[0x4]
8000a68a:	2f 80       	sub	r0,-8
8000a68c:	58 06       	cp.w	r6,0
8000a68e:	cf c0       	breq	8000a686 <__sfvwrite_r+0x9a>
8000a690:	8e 68       	ld.sh	r8,r7[0xc]
8000a692:	6e 24       	ld.w	r4,r7[0x8]
8000a694:	10 99       	mov	r9,r8
8000a696:	e2 19 02 00 	andl	r9,0x200,COH
8000a69a:	c5 50       	breq	8000a744 <__sfvwrite_r+0x158>
8000a69c:	08 36       	cp.w	r6,r4
8000a69e:	c4 43       	brcs	8000a726 <__sfvwrite_r+0x13a>
8000a6a0:	10 99       	mov	r9,r8
8000a6a2:	e2 19 04 80 	andl	r9,0x480,COH
8000a6a6:	c4 00       	breq	8000a726 <__sfvwrite_r+0x13a>
8000a6a8:	6e 4b       	ld.w	r11,r7[0x10]
8000a6aa:	6e 09       	ld.w	r9,r7[0x0]
8000a6ac:	16 19       	sub	r9,r11
8000a6ae:	50 09       	stdsp	sp[0x0],r9
8000a6b0:	6e 59       	ld.w	r9,r7[0x14]
8000a6b2:	10 9c       	mov	r12,r8
8000a6b4:	f2 09 00 1a 	add	r10,r9,r9<<0x1
8000a6b8:	30 28       	mov	r8,2
8000a6ba:	f4 08 0c 08 	divs	r8,r10,r8
8000a6be:	fa e9 00 04 	st.d	sp[4],r8
8000a6c2:	10 94       	mov	r4,r8
8000a6c4:	40 09       	lddsp	r9,sp[0x0]
8000a6c6:	e2 1c 04 00 	andl	r12,0x400,COH
8000a6ca:	2f f9       	sub	r9,-1
8000a6cc:	0c 09       	add	r9,r6
8000a6ce:	12 38       	cp.w	r8,r9
8000a6d0:	f2 04 17 30 	movlo	r4,r9
8000a6d4:	58 0c       	cp.w	r12,0
8000a6d6:	c1 10       	breq	8000a6f8 <__sfvwrite_r+0x10c>
8000a6d8:	08 9b       	mov	r11,r4
8000a6da:	0a 9c       	mov	r12,r5
8000a6dc:	fe b0 e0 60 	rcall	8000679c <_malloc_r>
8000a6e0:	18 92       	mov	r2,r12
8000a6e2:	c1 40       	breq	8000a70a <__sfvwrite_r+0x11e>
8000a6e4:	40 0a       	lddsp	r10,sp[0x0]
8000a6e6:	6e 4b       	ld.w	r11,r7[0x10]
8000a6e8:	fe b0 e2 76 	rcall	80006bd4 <memcpy>
8000a6ec:	8e 68       	ld.sh	r8,r7[0xc]
8000a6ee:	e0 18 fb 7f 	andl	r8,0xfb7f
8000a6f2:	a7 b8       	sbr	r8,0x7
8000a6f4:	ae 68       	st.h	r7[0xc],r8
8000a6f6:	c0 d8       	rjmp	8000a710 <__sfvwrite_r+0x124>
8000a6f8:	08 9a       	mov	r10,r4
8000a6fa:	0a 9c       	mov	r12,r5
8000a6fc:	fe b0 e3 18 	rcall	80006d2c <_realloc_r>
8000a700:	18 92       	mov	r2,r12
8000a702:	c0 71       	brne	8000a710 <__sfvwrite_r+0x124>
8000a704:	6e 4b       	ld.w	r11,r7[0x10]
8000a706:	0a 9c       	mov	r12,r5
8000a708:	ca ce       	rcall	8000a460 <_free_r>
8000a70a:	30 c8       	mov	r8,12
8000a70c:	8b 38       	st.w	r5[0xc],r8
8000a70e:	cb 18       	rjmp	8000a870 <__sfvwrite_r+0x284>
8000a710:	40 0a       	lddsp	r10,sp[0x0]
8000a712:	40 09       	lddsp	r9,sp[0x0]
8000a714:	e8 0a 01 0a 	sub	r10,r4,r10
8000a718:	e4 09 00 08 	add	r8,r2,r9
8000a71c:	8f 54       	st.w	r7[0x14],r4
8000a71e:	8f 2a       	st.w	r7[0x8],r10
8000a720:	8f 08       	st.w	r7[0x0],r8
8000a722:	8f 42       	st.w	r7[0x10],r2
8000a724:	0c 94       	mov	r4,r6
8000a726:	08 36       	cp.w	r6,r4
8000a728:	ec 04 17 30 	movlo	r4,r6
8000a72c:	06 9b       	mov	r11,r3
8000a72e:	08 9a       	mov	r10,r4
8000a730:	6e 0c       	ld.w	r12,r7[0x0]
8000a732:	c3 ad       	rcall	8000a9a6 <memmove>
8000a734:	6e 08       	ld.w	r8,r7[0x0]
8000a736:	08 08       	add	r8,r4
8000a738:	8f 08       	st.w	r7[0x0],r8
8000a73a:	6e 28       	ld.w	r8,r7[0x8]
8000a73c:	08 18       	sub	r8,r4
8000a73e:	0c 94       	mov	r4,r6
8000a740:	8f 28       	st.w	r7[0x8],r8
8000a742:	c2 e8       	rjmp	8000a79e <__sfvwrite_r+0x1b2>
8000a744:	08 36       	cp.w	r6,r4
8000a746:	5f ba       	srhi	r10
8000a748:	6e 0c       	ld.w	r12,r7[0x0]
8000a74a:	6e 48       	ld.w	r8,r7[0x10]
8000a74c:	10 3c       	cp.w	r12,r8
8000a74e:	5f b8       	srhi	r8
8000a750:	f5 e8 00 08 	and	r8,r10,r8
8000a754:	f2 08 18 00 	cp.b	r8,r9
8000a758:	c0 d0       	breq	8000a772 <__sfvwrite_r+0x186>
8000a75a:	06 9b       	mov	r11,r3
8000a75c:	08 9a       	mov	r10,r4
8000a75e:	c2 4d       	rcall	8000a9a6 <memmove>
8000a760:	6e 08       	ld.w	r8,r7[0x0]
8000a762:	08 08       	add	r8,r4
8000a764:	0e 9b       	mov	r11,r7
8000a766:	8f 08       	st.w	r7[0x0],r8
8000a768:	0a 9c       	mov	r12,r5
8000a76a:	fe b0 fd 09 	rcall	8000a17c <_fflush_r>
8000a76e:	c1 80       	breq	8000a79e <__sfvwrite_r+0x1b2>
8000a770:	c8 08       	rjmp	8000a870 <__sfvwrite_r+0x284>
8000a772:	6e 59       	ld.w	r9,r7[0x14]
8000a774:	12 36       	cp.w	r6,r9
8000a776:	c0 a3       	brcs	8000a78a <__sfvwrite_r+0x19e>
8000a778:	6e a8       	ld.w	r8,r7[0x28]
8000a77a:	06 9a       	mov	r10,r3
8000a77c:	6e 8b       	ld.w	r11,r7[0x20]
8000a77e:	0a 9c       	mov	r12,r5
8000a780:	5d 18       	icall	r8
8000a782:	18 94       	mov	r4,r12
8000a784:	e0 89 00 0d 	brgt	8000a79e <__sfvwrite_r+0x1b2>
8000a788:	c7 48       	rjmp	8000a870 <__sfvwrite_r+0x284>
8000a78a:	0c 9a       	mov	r10,r6
8000a78c:	06 9b       	mov	r11,r3
8000a78e:	c0 cd       	rcall	8000a9a6 <memmove>
8000a790:	6e 08       	ld.w	r8,r7[0x0]
8000a792:	0c 08       	add	r8,r6
8000a794:	0c 94       	mov	r4,r6
8000a796:	8f 08       	st.w	r7[0x0],r8
8000a798:	6e 28       	ld.w	r8,r7[0x8]
8000a79a:	0c 18       	sub	r8,r6
8000a79c:	8f 28       	st.w	r7[0x8],r8
8000a79e:	62 28       	ld.w	r8,r1[0x8]
8000a7a0:	08 18       	sub	r8,r4
8000a7a2:	83 28       	st.w	r1[0x8],r8
8000a7a4:	c6 b0       	breq	8000a87a <__sfvwrite_r+0x28e>
8000a7a6:	08 16       	sub	r6,r4
8000a7a8:	08 03       	add	r3,r4
8000a7aa:	c7 1b       	rjmp	8000a68c <__sfvwrite_r+0xa0>
8000a7ac:	60 03       	ld.w	r3,r0[0x0]
8000a7ae:	60 11       	ld.w	r1,r0[0x4]
8000a7b0:	30 08       	mov	r8,0
8000a7b2:	2f 80       	sub	r0,-8
8000a7b4:	50 08       	stdsp	sp[0x0],r8
8000a7b6:	58 01       	cp.w	r1,0
8000a7b8:	cf a0       	breq	8000a7ac <__sfvwrite_r+0x1c0>
8000a7ba:	40 0a       	lddsp	r10,sp[0x0]
8000a7bc:	58 0a       	cp.w	r10,0
8000a7be:	c1 41       	brne	8000a7e6 <__sfvwrite_r+0x1fa>
8000a7c0:	e2 c6 ff ff 	sub	r6,r1,-1
8000a7c4:	02 9a       	mov	r10,r1
8000a7c6:	30 ab       	mov	r11,10
8000a7c8:	06 9c       	mov	r12,r3
8000a7ca:	ce 3c       	rcall	8000a990 <memchr>
8000a7cc:	f8 c8 ff ff 	sub	r8,r12,-1
8000a7d0:	58 0c       	cp.w	r12,0
8000a7d2:	f1 d3 e1 16 	subne	r6,r8,r3
8000a7d6:	f9 b9 01 01 	movne	r9,1
8000a7da:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000a7de:	f9 b8 00 01 	moveq	r8,1
8000a7e2:	fb f8 0a 00 	st.weq	sp[0x0],r8
8000a7e6:	02 36       	cp.w	r6,r1
8000a7e8:	ec 04 17 80 	movls	r4,r6
8000a7ec:	e2 04 17 b0 	movhi	r4,r1
8000a7f0:	6e 59       	ld.w	r9,r7[0x14]
8000a7f2:	6e 25       	ld.w	r5,r7[0x8]
8000a7f4:	f2 05 00 05 	add	r5,r9,r5
8000a7f8:	0a 34       	cp.w	r4,r5
8000a7fa:	5f 9a       	srgt	r10
8000a7fc:	6e 0c       	ld.w	r12,r7[0x0]
8000a7fe:	6e 48       	ld.w	r8,r7[0x10]
8000a800:	10 3c       	cp.w	r12,r8
8000a802:	5f b8       	srhi	r8
8000a804:	f5 e8 00 08 	and	r8,r10,r8
8000a808:	30 0a       	mov	r10,0
8000a80a:	f4 08 18 00 	cp.b	r8,r10
8000a80e:	c0 d0       	breq	8000a828 <__sfvwrite_r+0x23c>
8000a810:	06 9b       	mov	r11,r3
8000a812:	0a 9a       	mov	r10,r5
8000a814:	cc 9c       	rcall	8000a9a6 <memmove>
8000a816:	6e 08       	ld.w	r8,r7[0x0]
8000a818:	0a 08       	add	r8,r5
8000a81a:	0e 9b       	mov	r11,r7
8000a81c:	8f 08       	st.w	r7[0x0],r8
8000a81e:	40 1c       	lddsp	r12,sp[0x4]
8000a820:	fe b0 fc ae 	rcall	8000a17c <_fflush_r>
8000a824:	c1 70       	breq	8000a852 <__sfvwrite_r+0x266>
8000a826:	c2 58       	rjmp	8000a870 <__sfvwrite_r+0x284>
8000a828:	12 34       	cp.w	r4,r9
8000a82a:	c0 a5       	brlt	8000a83e <__sfvwrite_r+0x252>
8000a82c:	6e a8       	ld.w	r8,r7[0x28]
8000a82e:	06 9a       	mov	r10,r3
8000a830:	6e 8b       	ld.w	r11,r7[0x20]
8000a832:	40 1c       	lddsp	r12,sp[0x4]
8000a834:	5d 18       	icall	r8
8000a836:	18 95       	mov	r5,r12
8000a838:	e0 89 00 0d 	brgt	8000a852 <__sfvwrite_r+0x266>
8000a83c:	c1 a8       	rjmp	8000a870 <__sfvwrite_r+0x284>
8000a83e:	08 9a       	mov	r10,r4
8000a840:	06 9b       	mov	r11,r3
8000a842:	cb 2c       	rcall	8000a9a6 <memmove>
8000a844:	6e 08       	ld.w	r8,r7[0x0]
8000a846:	08 08       	add	r8,r4
8000a848:	08 95       	mov	r5,r4
8000a84a:	8f 08       	st.w	r7[0x0],r8
8000a84c:	6e 28       	ld.w	r8,r7[0x8]
8000a84e:	08 18       	sub	r8,r4
8000a850:	8f 28       	st.w	r7[0x8],r8
8000a852:	0a 16       	sub	r6,r5
8000a854:	c0 71       	brne	8000a862 <__sfvwrite_r+0x276>
8000a856:	0e 9b       	mov	r11,r7
8000a858:	40 1c       	lddsp	r12,sp[0x4]
8000a85a:	fe b0 fc 91 	rcall	8000a17c <_fflush_r>
8000a85e:	c0 91       	brne	8000a870 <__sfvwrite_r+0x284>
8000a860:	50 06       	stdsp	sp[0x0],r6
8000a862:	64 28       	ld.w	r8,r2[0x8]
8000a864:	0a 18       	sub	r8,r5
8000a866:	85 28       	st.w	r2[0x8],r8
8000a868:	c0 90       	breq	8000a87a <__sfvwrite_r+0x28e>
8000a86a:	0a 11       	sub	r1,r5
8000a86c:	0a 03       	add	r3,r5
8000a86e:	ca 4b       	rjmp	8000a7b6 <__sfvwrite_r+0x1ca>
8000a870:	8e 68       	ld.sh	r8,r7[0xc]
8000a872:	a7 a8       	sbr	r8,0x6
8000a874:	ae 68       	st.h	r7[0xc],r8
8000a876:	3f fc       	mov	r12,-1
8000a878:	c0 28       	rjmp	8000a87c <__sfvwrite_r+0x290>
8000a87a:	30 0c       	mov	r12,0
8000a87c:	2f dd       	sub	sp,-12
8000a87e:	d8 32       	popm	r0-r7,pc

8000a880 <_fwalk>:
8000a880:	d4 31       	pushm	r0-r7,lr
8000a882:	30 05       	mov	r5,0
8000a884:	16 91       	mov	r1,r11
8000a886:	f8 c7 ff 28 	sub	r7,r12,-216
8000a88a:	0a 92       	mov	r2,r5
8000a88c:	fe b0 fc fe 	rcall	8000a288 <__sfp_lock_acquire>
8000a890:	3f f3       	mov	r3,-1
8000a892:	c1 68       	rjmp	8000a8be <_fwalk+0x3e>
8000a894:	6e 26       	ld.w	r6,r7[0x8]
8000a896:	6e 14       	ld.w	r4,r7[0x4]
8000a898:	2f 46       	sub	r6,-12
8000a89a:	c0 c8       	rjmp	8000a8b2 <_fwalk+0x32>
8000a89c:	8c 08       	ld.sh	r8,r6[0x0]
8000a89e:	e4 08 19 00 	cp.h	r8,r2
8000a8a2:	c0 70       	breq	8000a8b0 <_fwalk+0x30>
8000a8a4:	8c 18       	ld.sh	r8,r6[0x2]
8000a8a6:	e6 08 19 00 	cp.h	r8,r3
8000a8aa:	c0 30       	breq	8000a8b0 <_fwalk+0x30>
8000a8ac:	5d 11       	icall	r1
8000a8ae:	18 45       	or	r5,r12
8000a8b0:	2a 46       	sub	r6,-92
8000a8b2:	20 14       	sub	r4,1
8000a8b4:	ec cc 00 0c 	sub	r12,r6,12
8000a8b8:	58 04       	cp.w	r4,0
8000a8ba:	cf 14       	brge	8000a89c <_fwalk+0x1c>
8000a8bc:	6e 07       	ld.w	r7,r7[0x0]
8000a8be:	58 07       	cp.w	r7,0
8000a8c0:	ce a1       	brne	8000a894 <_fwalk+0x14>
8000a8c2:	fe b0 fc e4 	rcall	8000a28a <__sfp_lock_release>
8000a8c6:	0a 9c       	mov	r12,r5
8000a8c8:	d8 32       	popm	r0-r7,pc
8000a8ca:	d7 03       	nop

8000a8cc <_localeconv_r>:
8000a8cc:	fe cc d4 cc 	sub	r12,pc,-11060
8000a8d0:	5e fc       	retal	r12
8000a8d2:	d7 03       	nop

8000a8d4 <__smakebuf_r>:
8000a8d4:	d4 21       	pushm	r4-r7,lr
8000a8d6:	20 fd       	sub	sp,60
8000a8d8:	96 68       	ld.sh	r8,r11[0xc]
8000a8da:	16 97       	mov	r7,r11
8000a8dc:	18 96       	mov	r6,r12
8000a8de:	e2 18 00 02 	andl	r8,0x2,COH
8000a8e2:	c3 d1       	brne	8000a95c <__smakebuf_r+0x88>
8000a8e4:	96 7b       	ld.sh	r11,r11[0xe]
8000a8e6:	f0 0b 19 00 	cp.h	r11,r8
8000a8ea:	c0 55       	brlt	8000a8f4 <__smakebuf_r+0x20>
8000a8ec:	1a 9a       	mov	r10,sp
8000a8ee:	e0 a0 04 75 	rcall	8000b1d8 <_fstat_r>
8000a8f2:	c0 f4       	brge	8000a910 <__smakebuf_r+0x3c>
8000a8f4:	8e 65       	ld.sh	r5,r7[0xc]
8000a8f6:	0a 98       	mov	r8,r5
8000a8f8:	ab b8       	sbr	r8,0xb
8000a8fa:	e2 15 00 80 	andl	r5,0x80,COH
8000a8fe:	ae 68       	st.h	r7[0xc],r8
8000a900:	30 04       	mov	r4,0
8000a902:	e0 68 04 00 	mov	r8,1024
8000a906:	f9 b5 01 40 	movne	r5,64
8000a90a:	f0 05 17 00 	moveq	r5,r8
8000a90e:	c1 c8       	rjmp	8000a946 <__smakebuf_r+0x72>
8000a910:	40 18       	lddsp	r8,sp[0x4]
8000a912:	e2 18 f0 00 	andl	r8,0xf000,COH
8000a916:	e0 48 20 00 	cp.w	r8,8192
8000a91a:	5f 04       	sreq	r4
8000a91c:	e0 48 80 00 	cp.w	r8,32768
8000a920:	c0 e1       	brne	8000a93c <__smakebuf_r+0x68>
8000a922:	6e b9       	ld.w	r9,r7[0x2c]
8000a924:	fe c8 f9 1c 	sub	r8,pc,-1764
8000a928:	10 39       	cp.w	r9,r8
8000a92a:	c0 91       	brne	8000a93c <__smakebuf_r+0x68>
8000a92c:	8e 68       	ld.sh	r8,r7[0xc]
8000a92e:	e0 65 04 00 	mov	r5,1024
8000a932:	ab a8       	sbr	r8,0xa
8000a934:	ef 45 00 50 	st.w	r7[80],r5
8000a938:	ae 68       	st.h	r7[0xc],r8
8000a93a:	c0 68       	rjmp	8000a946 <__smakebuf_r+0x72>
8000a93c:	8e 68       	ld.sh	r8,r7[0xc]
8000a93e:	e0 65 04 00 	mov	r5,1024
8000a942:	ab b8       	sbr	r8,0xb
8000a944:	ae 68       	st.h	r7[0xc],r8
8000a946:	0a 9b       	mov	r11,r5
8000a948:	0c 9c       	mov	r12,r6
8000a94a:	fe b0 df 29 	rcall	8000679c <_malloc_r>
8000a94e:	8e 68       	ld.sh	r8,r7[0xc]
8000a950:	c0 d1       	brne	8000a96a <__smakebuf_r+0x96>
8000a952:	ed b8 00 09 	bld	r8,0x9
8000a956:	c1 b0       	breq	8000a98c <__smakebuf_r+0xb8>
8000a958:	a1 b8       	sbr	r8,0x1
8000a95a:	ae 68       	st.h	r7[0xc],r8
8000a95c:	ee c8 ff b9 	sub	r8,r7,-71
8000a960:	8f 48       	st.w	r7[0x10],r8
8000a962:	8f 08       	st.w	r7[0x0],r8
8000a964:	30 18       	mov	r8,1
8000a966:	8f 58       	st.w	r7[0x14],r8
8000a968:	c1 28       	rjmp	8000a98c <__smakebuf_r+0xb8>
8000a96a:	a7 b8       	sbr	r8,0x7
8000a96c:	8f 4c       	st.w	r7[0x10],r12
8000a96e:	ae 68       	st.h	r7[0xc],r8
8000a970:	8f 55       	st.w	r7[0x14],r5
8000a972:	fe c8 06 e6 	sub	r8,pc,1766
8000a976:	8f 0c       	st.w	r7[0x0],r12
8000a978:	8d a8       	st.w	r6[0x28],r8
8000a97a:	58 04       	cp.w	r4,0
8000a97c:	c0 80       	breq	8000a98c <__smakebuf_r+0xb8>
8000a97e:	8e 7c       	ld.sh	r12,r7[0xe]
8000a980:	fe b0 e3 94 	rcall	800070a8 <isatty>
8000a984:	c0 40       	breq	8000a98c <__smakebuf_r+0xb8>
8000a986:	8e 68       	ld.sh	r8,r7[0xc]
8000a988:	a1 a8       	sbr	r8,0x0
8000a98a:	ae 68       	st.h	r7[0xc],r8
8000a98c:	2f 1d       	sub	sp,-60
8000a98e:	d8 22       	popm	r4-r7,pc

8000a990 <memchr>:
8000a990:	f7 db c0 08 	bfextu	r11,r11,0x0,0x8
8000a994:	c0 68       	rjmp	8000a9a0 <memchr+0x10>
8000a996:	20 1a       	sub	r10,1
8000a998:	19 88       	ld.ub	r8,r12[0x0]
8000a99a:	16 38       	cp.w	r8,r11
8000a99c:	5e 0c       	reteq	r12
8000a99e:	2f fc       	sub	r12,-1
8000a9a0:	58 0a       	cp.w	r10,0
8000a9a2:	cf a1       	brne	8000a996 <memchr+0x6>
8000a9a4:	5e fa       	retal	r10

8000a9a6 <memmove>:
8000a9a6:	d4 01       	pushm	lr
8000a9a8:	18 3b       	cp.w	r11,r12
8000a9aa:	c1 92       	brcc	8000a9dc <memmove+0x36>
8000a9ac:	f6 0a 00 09 	add	r9,r11,r10
8000a9b0:	12 3c       	cp.w	r12,r9
8000a9b2:	c1 52       	brcc	8000a9dc <memmove+0x36>
8000a9b4:	f8 0a 00 0b 	add	r11,r12,r10
8000a9b8:	30 08       	mov	r8,0
8000a9ba:	c0 68       	rjmp	8000a9c6 <memmove+0x20>
8000a9bc:	f2 08 07 0e 	ld.ub	lr,r9[r8]
8000a9c0:	20 1a       	sub	r10,1
8000a9c2:	f6 08 0b 0e 	st.b	r11[r8],lr
8000a9c6:	20 18       	sub	r8,1
8000a9c8:	58 0a       	cp.w	r10,0
8000a9ca:	cf 91       	brne	8000a9bc <memmove+0x16>
8000a9cc:	d8 02       	popm	pc
8000a9ce:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000a9d2:	20 1a       	sub	r10,1
8000a9d4:	f8 08 0b 09 	st.b	r12[r8],r9
8000a9d8:	2f f8       	sub	r8,-1
8000a9da:	c0 28       	rjmp	8000a9de <memmove+0x38>
8000a9dc:	30 08       	mov	r8,0
8000a9de:	58 0a       	cp.w	r10,0
8000a9e0:	cf 71       	brne	8000a9ce <memmove+0x28>
8000a9e2:	d8 02       	popm	pc

8000a9e4 <__hi0bits>:
8000a9e4:	18 98       	mov	r8,r12
8000a9e6:	e0 1c 00 00 	andl	r12,0x0
8000a9ea:	f0 09 15 10 	lsl	r9,r8,0x10
8000a9ee:	58 0c       	cp.w	r12,0
8000a9f0:	f2 08 17 00 	moveq	r8,r9
8000a9f4:	f9 bc 00 10 	moveq	r12,16
8000a9f8:	f9 bc 01 00 	movne	r12,0
8000a9fc:	10 9a       	mov	r10,r8
8000a9fe:	f0 09 15 08 	lsl	r9,r8,0x8
8000aa02:	e6 1a ff 00 	andh	r10,0xff00,COH
8000aa06:	f7 bc 00 f8 	subeq	r12,-8
8000aa0a:	f2 08 17 00 	moveq	r8,r9
8000aa0e:	10 9a       	mov	r10,r8
8000aa10:	f0 09 15 04 	lsl	r9,r8,0x4
8000aa14:	e6 1a f0 00 	andh	r10,0xf000,COH
8000aa18:	f7 bc 00 fc 	subeq	r12,-4
8000aa1c:	f2 08 17 00 	moveq	r8,r9
8000aa20:	10 9a       	mov	r10,r8
8000aa22:	f0 09 15 02 	lsl	r9,r8,0x2
8000aa26:	e6 1a c0 00 	andh	r10,0xc000,COH
8000aa2a:	f7 bc 00 fe 	subeq	r12,-2
8000aa2e:	f2 08 17 00 	moveq	r8,r9
8000aa32:	58 08       	cp.w	r8,0
8000aa34:	5e 5c       	retlt	r12
8000aa36:	ed b8 00 1e 	bld	r8,0x1e
8000aa3a:	f9 bc 01 20 	movne	r12,32
8000aa3e:	f7 bc 00 ff 	subeq	r12,-1
8000aa42:	5e fc       	retal	r12

8000aa44 <__lo0bits>:
8000aa44:	18 99       	mov	r9,r12
8000aa46:	78 08       	ld.w	r8,r12[0x0]
8000aa48:	f9 d8 c0 03 	bfextu	r12,r8,0x0,0x3
8000aa4c:	c1 50       	breq	8000aa76 <__lo0bits+0x32>
8000aa4e:	ed b8 00 00 	bld	r8,0x0
8000aa52:	c0 21       	brne	8000aa56 <__lo0bits+0x12>
8000aa54:	5e fd       	retal	0
8000aa56:	10 9b       	mov	r11,r8
8000aa58:	f0 0a 16 01 	lsr	r10,r8,0x1
8000aa5c:	e2 1b 00 02 	andl	r11,0x2,COH
8000aa60:	a3 88       	lsr	r8,0x2
8000aa62:	58 0b       	cp.w	r11,0
8000aa64:	f3 fa 1a 00 	st.wne	r9[0x0],r10
8000aa68:	f9 bc 01 01 	movne	r12,1
8000aa6c:	f3 f8 0a 00 	st.weq	r9[0x0],r8
8000aa70:	f9 bc 00 02 	moveq	r12,2
8000aa74:	5e fc       	retal	r12
8000aa76:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8000aa7a:	f0 0b 16 10 	lsr	r11,r8,0x10
8000aa7e:	58 0a       	cp.w	r10,0
8000aa80:	f6 08 17 00 	moveq	r8,r11
8000aa84:	f9 bc 00 10 	moveq	r12,16
8000aa88:	f7 d8 c0 08 	bfextu	r11,r8,0x0,0x8
8000aa8c:	f0 0a 16 08 	lsr	r10,r8,0x8
8000aa90:	58 0b       	cp.w	r11,0
8000aa92:	f7 bc 00 f8 	subeq	r12,-8
8000aa96:	f4 08 17 00 	moveq	r8,r10
8000aa9a:	f7 d8 c0 04 	bfextu	r11,r8,0x0,0x4
8000aa9e:	f0 0a 16 04 	lsr	r10,r8,0x4
8000aaa2:	58 0b       	cp.w	r11,0
8000aaa4:	f7 bc 00 fc 	subeq	r12,-4
8000aaa8:	f4 08 17 00 	moveq	r8,r10
8000aaac:	f7 d8 c0 02 	bfextu	r11,r8,0x0,0x2
8000aab0:	f0 0a 16 02 	lsr	r10,r8,0x2
8000aab4:	58 0b       	cp.w	r11,0
8000aab6:	f7 bc 00 fe 	subeq	r12,-2
8000aaba:	f4 08 17 00 	moveq	r8,r10
8000aabe:	ed b8 00 00 	bld	r8,0x0
8000aac2:	c0 60       	breq	8000aace <__lo0bits+0x8a>
8000aac4:	a1 98       	lsr	r8,0x1
8000aac6:	c0 31       	brne	8000aacc <__lo0bits+0x88>
8000aac8:	32 0c       	mov	r12,32
8000aaca:	5e fc       	retal	r12
8000aacc:	2f fc       	sub	r12,-1
8000aace:	93 08       	st.w	r9[0x0],r8
8000aad0:	5e fc       	retal	r12

8000aad2 <__mcmp>:
8000aad2:	d4 01       	pushm	lr
8000aad4:	18 98       	mov	r8,r12
8000aad6:	76 49       	ld.w	r9,r11[0x10]
8000aad8:	78 4c       	ld.w	r12,r12[0x10]
8000aada:	12 1c       	sub	r12,r9
8000aadc:	c1 31       	brne	8000ab02 <__mcmp+0x30>
8000aade:	2f b9       	sub	r9,-5
8000aae0:	a3 69       	lsl	r9,0x2
8000aae2:	12 0b       	add	r11,r9
8000aae4:	f0 09 00 09 	add	r9,r8,r9
8000aae8:	2e c8       	sub	r8,-20
8000aaea:	13 4e       	ld.w	lr,--r9
8000aaec:	17 4a       	ld.w	r10,--r11
8000aaee:	14 3e       	cp.w	lr,r10
8000aaf0:	c0 60       	breq	8000aafc <__mcmp+0x2a>
8000aaf2:	f9 bc 03 ff 	movlo	r12,-1
8000aaf6:	f9 bc 02 01 	movhs	r12,1
8000aafa:	d8 02       	popm	pc
8000aafc:	10 39       	cp.w	r9,r8
8000aafe:	fe 9b ff f6 	brhi	8000aaea <__mcmp+0x18>
8000ab02:	d8 02       	popm	pc

8000ab04 <_Bfree>:
8000ab04:	d4 21       	pushm	r4-r7,lr
8000ab06:	18 97       	mov	r7,r12
8000ab08:	16 95       	mov	r5,r11
8000ab0a:	78 96       	ld.w	r6,r12[0x24]
8000ab0c:	58 06       	cp.w	r6,0
8000ab0e:	c0 91       	brne	8000ab20 <_Bfree+0x1c>
8000ab10:	31 0c       	mov	r12,16
8000ab12:	fe b0 de 3d 	rcall	8000678c <malloc>
8000ab16:	99 36       	st.w	r12[0xc],r6
8000ab18:	8f 9c       	st.w	r7[0x24],r12
8000ab1a:	99 16       	st.w	r12[0x4],r6
8000ab1c:	99 26       	st.w	r12[0x8],r6
8000ab1e:	99 06       	st.w	r12[0x0],r6
8000ab20:	58 05       	cp.w	r5,0
8000ab22:	c0 90       	breq	8000ab34 <_Bfree+0x30>
8000ab24:	6a 19       	ld.w	r9,r5[0x4]
8000ab26:	6e 98       	ld.w	r8,r7[0x24]
8000ab28:	70 38       	ld.w	r8,r8[0xc]
8000ab2a:	f0 09 03 2a 	ld.w	r10,r8[r9<<0x2]
8000ab2e:	8b 0a       	st.w	r5[0x0],r10
8000ab30:	f0 09 09 25 	st.w	r8[r9<<0x2],r5
8000ab34:	d8 22       	popm	r4-r7,pc
8000ab36:	d7 03       	nop

8000ab38 <_Balloc>:
8000ab38:	d4 21       	pushm	r4-r7,lr
8000ab3a:	18 97       	mov	r7,r12
8000ab3c:	16 96       	mov	r6,r11
8000ab3e:	78 95       	ld.w	r5,r12[0x24]
8000ab40:	58 05       	cp.w	r5,0
8000ab42:	c0 91       	brne	8000ab54 <_Balloc+0x1c>
8000ab44:	31 0c       	mov	r12,16
8000ab46:	fe b0 de 23 	rcall	8000678c <malloc>
8000ab4a:	99 35       	st.w	r12[0xc],r5
8000ab4c:	8f 9c       	st.w	r7[0x24],r12
8000ab4e:	99 15       	st.w	r12[0x4],r5
8000ab50:	99 25       	st.w	r12[0x8],r5
8000ab52:	99 05       	st.w	r12[0x0],r5
8000ab54:	6e 95       	ld.w	r5,r7[0x24]
8000ab56:	6a 38       	ld.w	r8,r5[0xc]
8000ab58:	58 08       	cp.w	r8,0
8000ab5a:	c0 b1       	brne	8000ab70 <_Balloc+0x38>
8000ab5c:	31 0a       	mov	r10,16
8000ab5e:	30 4b       	mov	r11,4
8000ab60:	0e 9c       	mov	r12,r7
8000ab62:	e0 a0 02 9b 	rcall	8000b098 <_calloc_r>
8000ab66:	8b 3c       	st.w	r5[0xc],r12
8000ab68:	6e 98       	ld.w	r8,r7[0x24]
8000ab6a:	70 3c       	ld.w	r12,r8[0xc]
8000ab6c:	58 0c       	cp.w	r12,0
8000ab6e:	c1 b0       	breq	8000aba4 <_Balloc+0x6c>
8000ab70:	6e 98       	ld.w	r8,r7[0x24]
8000ab72:	70 38       	ld.w	r8,r8[0xc]
8000ab74:	f0 06 00 28 	add	r8,r8,r6<<0x2
8000ab78:	70 0c       	ld.w	r12,r8[0x0]
8000ab7a:	58 0c       	cp.w	r12,0
8000ab7c:	c0 40       	breq	8000ab84 <_Balloc+0x4c>
8000ab7e:	78 09       	ld.w	r9,r12[0x0]
8000ab80:	91 09       	st.w	r8[0x0],r9
8000ab82:	c0 e8       	rjmp	8000ab9e <_Balloc+0x66>
8000ab84:	0e 9c       	mov	r12,r7
8000ab86:	30 17       	mov	r7,1
8000ab88:	0e 9b       	mov	r11,r7
8000ab8a:	ee 06 09 47 	lsl	r7,r7,r6
8000ab8e:	ee ca ff fb 	sub	r10,r7,-5
8000ab92:	a3 6a       	lsl	r10,0x2
8000ab94:	e0 a0 02 82 	rcall	8000b098 <_calloc_r>
8000ab98:	c0 60       	breq	8000aba4 <_Balloc+0x6c>
8000ab9a:	99 16       	st.w	r12[0x4],r6
8000ab9c:	99 27       	st.w	r12[0x8],r7
8000ab9e:	30 08       	mov	r8,0
8000aba0:	99 38       	st.w	r12[0xc],r8
8000aba2:	99 48       	st.w	r12[0x10],r8
8000aba4:	d8 22       	popm	r4-r7,pc
8000aba6:	d7 03       	nop

8000aba8 <__d2b>:
8000aba8:	d4 31       	pushm	r0-r7,lr
8000abaa:	20 2d       	sub	sp,8
8000abac:	16 93       	mov	r3,r11
8000abae:	12 96       	mov	r6,r9
8000abb0:	10 95       	mov	r5,r8
8000abb2:	14 92       	mov	r2,r10
8000abb4:	30 1b       	mov	r11,1
8000abb6:	cc 1f       	rcall	8000ab38 <_Balloc>
8000abb8:	f3 d3 c0 14 	bfextu	r9,r3,0x0,0x14
8000abbc:	50 09       	stdsp	sp[0x0],r9
8000abbe:	f1 d3 c0 1f 	bfextu	r8,r3,0x0,0x1f
8000abc2:	b5 a9       	sbr	r9,0x14
8000abc4:	f0 01 16 14 	lsr	r1,r8,0x14
8000abc8:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000abcc:	18 94       	mov	r4,r12
8000abce:	58 02       	cp.w	r2,0
8000abd0:	c1 d0       	breq	8000ac0a <__d2b+0x62>
8000abd2:	fa cc ff f8 	sub	r12,sp,-8
8000abd6:	18 d2       	st.w	--r12,r2
8000abd8:	c3 6f       	rcall	8000aa44 <__lo0bits>
8000abda:	40 18       	lddsp	r8,sp[0x4]
8000abdc:	c0 d0       	breq	8000abf6 <__d2b+0x4e>
8000abde:	40 09       	lddsp	r9,sp[0x0]
8000abe0:	f8 0a 11 20 	rsub	r10,r12,32
8000abe4:	f2 0a 09 4a 	lsl	r10,r9,r10
8000abe8:	f5 e8 10 08 	or	r8,r10,r8
8000abec:	89 58       	st.w	r4[0x14],r8
8000abee:	f2 0c 0a 49 	lsr	r9,r9,r12
8000abf2:	50 09       	stdsp	sp[0x0],r9
8000abf4:	c0 28       	rjmp	8000abf8 <__d2b+0x50>
8000abf6:	89 58       	st.w	r4[0x14],r8
8000abf8:	40 08       	lddsp	r8,sp[0x0]
8000abfa:	58 08       	cp.w	r8,0
8000abfc:	f9 b3 01 02 	movne	r3,2
8000ac00:	f9 b3 00 01 	moveq	r3,1
8000ac04:	89 68       	st.w	r4[0x18],r8
8000ac06:	89 43       	st.w	r4[0x10],r3
8000ac08:	c0 88       	rjmp	8000ac18 <__d2b+0x70>
8000ac0a:	1a 9c       	mov	r12,sp
8000ac0c:	c1 cf       	rcall	8000aa44 <__lo0bits>
8000ac0e:	30 13       	mov	r3,1
8000ac10:	40 08       	lddsp	r8,sp[0x0]
8000ac12:	2e 0c       	sub	r12,-32
8000ac14:	89 43       	st.w	r4[0x10],r3
8000ac16:	89 58       	st.w	r4[0x14],r8
8000ac18:	58 01       	cp.w	r1,0
8000ac1a:	c0 90       	breq	8000ac2c <__d2b+0x84>
8000ac1c:	e2 c1 04 33 	sub	r1,r1,1075
8000ac20:	18 01       	add	r1,r12
8000ac22:	8d 01       	st.w	r6[0x0],r1
8000ac24:	f8 0c 11 35 	rsub	r12,r12,53
8000ac28:	8b 0c       	st.w	r5[0x0],r12
8000ac2a:	c0 c8       	rjmp	8000ac42 <__d2b+0x9a>
8000ac2c:	e6 c8 ff fc 	sub	r8,r3,-4
8000ac30:	f8 cc 04 32 	sub	r12,r12,1074
8000ac34:	a5 73       	lsl	r3,0x5
8000ac36:	8d 0c       	st.w	r6[0x0],r12
8000ac38:	e8 08 03 2c 	ld.w	r12,r4[r8<<0x2]
8000ac3c:	cd 4e       	rcall	8000a9e4 <__hi0bits>
8000ac3e:	18 13       	sub	r3,r12
8000ac40:	8b 03       	st.w	r5[0x0],r3
8000ac42:	08 9c       	mov	r12,r4
8000ac44:	2f ed       	sub	sp,-8
8000ac46:	d8 32       	popm	r0-r7,pc

8000ac48 <__mdiff>:
8000ac48:	d4 31       	pushm	r0-r7,lr
8000ac4a:	74 48       	ld.w	r8,r10[0x10]
8000ac4c:	76 45       	ld.w	r5,r11[0x10]
8000ac4e:	16 97       	mov	r7,r11
8000ac50:	14 96       	mov	r6,r10
8000ac52:	10 15       	sub	r5,r8
8000ac54:	c1 31       	brne	8000ac7a <__mdiff+0x32>
8000ac56:	2f b8       	sub	r8,-5
8000ac58:	ee ce ff ec 	sub	lr,r7,-20
8000ac5c:	a3 68       	lsl	r8,0x2
8000ac5e:	f4 08 00 0b 	add	r11,r10,r8
8000ac62:	ee 08 00 08 	add	r8,r7,r8
8000ac66:	11 4a       	ld.w	r10,--r8
8000ac68:	17 49       	ld.w	r9,--r11
8000ac6a:	12 3a       	cp.w	r10,r9
8000ac6c:	c0 30       	breq	8000ac72 <__mdiff+0x2a>
8000ac6e:	c0 e2       	brcc	8000ac8a <__mdiff+0x42>
8000ac70:	c0 78       	rjmp	8000ac7e <__mdiff+0x36>
8000ac72:	1c 38       	cp.w	r8,lr
8000ac74:	fe 9b ff f9 	brhi	8000ac66 <__mdiff+0x1e>
8000ac78:	c4 98       	rjmp	8000ad0a <__mdiff+0xc2>
8000ac7a:	58 05       	cp.w	r5,0
8000ac7c:	c0 64       	brge	8000ac88 <__mdiff+0x40>
8000ac7e:	0e 98       	mov	r8,r7
8000ac80:	30 15       	mov	r5,1
8000ac82:	0c 97       	mov	r7,r6
8000ac84:	10 96       	mov	r6,r8
8000ac86:	c0 28       	rjmp	8000ac8a <__mdiff+0x42>
8000ac88:	30 05       	mov	r5,0
8000ac8a:	6e 1b       	ld.w	r11,r7[0x4]
8000ac8c:	c5 6f       	rcall	8000ab38 <_Balloc>
8000ac8e:	6e 49       	ld.w	r9,r7[0x10]
8000ac90:	6c 44       	ld.w	r4,r6[0x10]
8000ac92:	99 35       	st.w	r12[0xc],r5
8000ac94:	2f b4       	sub	r4,-5
8000ac96:	f2 c5 ff fb 	sub	r5,r9,-5
8000ac9a:	ec 04 00 24 	add	r4,r6,r4<<0x2
8000ac9e:	ee 05 00 25 	add	r5,r7,r5<<0x2
8000aca2:	2e c6       	sub	r6,-20
8000aca4:	2e c7       	sub	r7,-20
8000aca6:	f8 c8 ff ec 	sub	r8,r12,-20
8000acaa:	30 0a       	mov	r10,0
8000acac:	0f 0e       	ld.w	lr,r7++
8000acae:	0d 0b       	ld.w	r11,r6++
8000acb0:	fc 02 16 10 	lsr	r2,lr,0x10
8000acb4:	f6 03 16 10 	lsr	r3,r11,0x10
8000acb8:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000acbc:	e4 03 01 03 	sub	r3,r2,r3
8000acc0:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000acc4:	fc 0b 01 0b 	sub	r11,lr,r11
8000acc8:	f6 0a 00 0a 	add	r10,r11,r10
8000accc:	b0 1a       	st.h	r8[0x2],r10
8000acce:	b1 4a       	asr	r10,0x10
8000acd0:	e6 0a 00 0a 	add	r10,r3,r10
8000acd4:	b0 0a       	st.h	r8[0x0],r10
8000acd6:	2f c8       	sub	r8,-4
8000acd8:	b1 4a       	asr	r10,0x10
8000acda:	08 36       	cp.w	r6,r4
8000acdc:	ce 83       	brcs	8000acac <__mdiff+0x64>
8000acde:	c0 d8       	rjmp	8000acf8 <__mdiff+0xb0>
8000ace0:	0f 0b       	ld.w	r11,r7++
8000ace2:	f6 0e 16 10 	lsr	lr,r11,0x10
8000ace6:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000acea:	16 0a       	add	r10,r11
8000acec:	b0 1a       	st.h	r8[0x2],r10
8000acee:	b1 4a       	asr	r10,0x10
8000acf0:	1c 0a       	add	r10,lr
8000acf2:	b0 0a       	st.h	r8[0x0],r10
8000acf4:	2f c8       	sub	r8,-4
8000acf6:	b1 4a       	asr	r10,0x10
8000acf8:	0a 37       	cp.w	r7,r5
8000acfa:	cf 33       	brcs	8000ace0 <__mdiff+0x98>
8000acfc:	c0 28       	rjmp	8000ad00 <__mdiff+0xb8>
8000acfe:	20 19       	sub	r9,1
8000ad00:	11 4a       	ld.w	r10,--r8
8000ad02:	58 0a       	cp.w	r10,0
8000ad04:	cf d0       	breq	8000acfe <__mdiff+0xb6>
8000ad06:	99 49       	st.w	r12[0x10],r9
8000ad08:	d8 32       	popm	r0-r7,pc
8000ad0a:	30 0b       	mov	r11,0
8000ad0c:	c1 6f       	rcall	8000ab38 <_Balloc>
8000ad0e:	30 18       	mov	r8,1
8000ad10:	99 48       	st.w	r12[0x10],r8
8000ad12:	30 08       	mov	r8,0
8000ad14:	99 58       	st.w	r12[0x14],r8
8000ad16:	d8 32       	popm	r0-r7,pc

8000ad18 <__lshift>:
8000ad18:	d4 31       	pushm	r0-r7,lr
8000ad1a:	16 97       	mov	r7,r11
8000ad1c:	76 46       	ld.w	r6,r11[0x10]
8000ad1e:	f4 02 14 05 	asr	r2,r10,0x5
8000ad22:	2f f6       	sub	r6,-1
8000ad24:	14 93       	mov	r3,r10
8000ad26:	18 94       	mov	r4,r12
8000ad28:	04 06       	add	r6,r2
8000ad2a:	76 1b       	ld.w	r11,r11[0x4]
8000ad2c:	6e 28       	ld.w	r8,r7[0x8]
8000ad2e:	c0 38       	rjmp	8000ad34 <__lshift+0x1c>
8000ad30:	2f fb       	sub	r11,-1
8000ad32:	a1 78       	lsl	r8,0x1
8000ad34:	10 36       	cp.w	r6,r8
8000ad36:	fe 99 ff fd 	brgt	8000ad30 <__lshift+0x18>
8000ad3a:	08 9c       	mov	r12,r4
8000ad3c:	cf ee       	rcall	8000ab38 <_Balloc>
8000ad3e:	30 09       	mov	r9,0
8000ad40:	18 95       	mov	r5,r12
8000ad42:	f8 c8 ff ec 	sub	r8,r12,-20
8000ad46:	12 9a       	mov	r10,r9
8000ad48:	c0 38       	rjmp	8000ad4e <__lshift+0x36>
8000ad4a:	10 aa       	st.w	r8++,r10
8000ad4c:	2f f9       	sub	r9,-1
8000ad4e:	04 39       	cp.w	r9,r2
8000ad50:	cf d5       	brlt	8000ad4a <__lshift+0x32>
8000ad52:	6e 4b       	ld.w	r11,r7[0x10]
8000ad54:	e7 d3 c0 05 	bfextu	r3,r3,0x0,0x5
8000ad58:	2f bb       	sub	r11,-5
8000ad5a:	ee c9 ff ec 	sub	r9,r7,-20
8000ad5e:	ee 0b 00 2b 	add	r11,r7,r11<<0x2
8000ad62:	58 03       	cp.w	r3,0
8000ad64:	c1 30       	breq	8000ad8a <__lshift+0x72>
8000ad66:	e6 0c 11 20 	rsub	r12,r3,32
8000ad6a:	30 0a       	mov	r10,0
8000ad6c:	72 02       	ld.w	r2,r9[0x0]
8000ad6e:	e4 03 09 42 	lsl	r2,r2,r3
8000ad72:	04 4a       	or	r10,r2
8000ad74:	10 aa       	st.w	r8++,r10
8000ad76:	13 0a       	ld.w	r10,r9++
8000ad78:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000ad7c:	16 39       	cp.w	r9,r11
8000ad7e:	cf 73       	brcs	8000ad6c <__lshift+0x54>
8000ad80:	91 0a       	st.w	r8[0x0],r10
8000ad82:	58 0a       	cp.w	r10,0
8000ad84:	c0 70       	breq	8000ad92 <__lshift+0x7a>
8000ad86:	2f f6       	sub	r6,-1
8000ad88:	c0 58       	rjmp	8000ad92 <__lshift+0x7a>
8000ad8a:	13 0a       	ld.w	r10,r9++
8000ad8c:	10 aa       	st.w	r8++,r10
8000ad8e:	16 39       	cp.w	r9,r11
8000ad90:	cf d3       	brcs	8000ad8a <__lshift+0x72>
8000ad92:	08 9c       	mov	r12,r4
8000ad94:	20 16       	sub	r6,1
8000ad96:	0e 9b       	mov	r11,r7
8000ad98:	8b 46       	st.w	r5[0x10],r6
8000ad9a:	cb 5e       	rcall	8000ab04 <_Bfree>
8000ad9c:	0a 9c       	mov	r12,r5
8000ad9e:	d8 32       	popm	r0-r7,pc

8000ada0 <__multiply>:
8000ada0:	d4 31       	pushm	r0-r7,lr
8000ada2:	20 2d       	sub	sp,8
8000ada4:	76 49       	ld.w	r9,r11[0x10]
8000ada6:	74 48       	ld.w	r8,r10[0x10]
8000ada8:	16 96       	mov	r6,r11
8000adaa:	14 95       	mov	r5,r10
8000adac:	10 39       	cp.w	r9,r8
8000adae:	ec 08 17 50 	movlt	r8,r6
8000adb2:	ea 06 17 50 	movlt	r6,r5
8000adb6:	f0 05 17 50 	movlt	r5,r8
8000adba:	6c 28       	ld.w	r8,r6[0x8]
8000adbc:	76 43       	ld.w	r3,r11[0x10]
8000adbe:	74 42       	ld.w	r2,r10[0x10]
8000adc0:	76 1b       	ld.w	r11,r11[0x4]
8000adc2:	e4 03 00 07 	add	r7,r2,r3
8000adc6:	10 37       	cp.w	r7,r8
8000adc8:	f7 bb 09 ff 	subgt	r11,-1
8000adcc:	cb 6e       	rcall	8000ab38 <_Balloc>
8000adce:	ee c4 ff fb 	sub	r4,r7,-5
8000add2:	f8 c9 ff ec 	sub	r9,r12,-20
8000add6:	f8 04 00 24 	add	r4,r12,r4<<0x2
8000adda:	30 0a       	mov	r10,0
8000addc:	12 98       	mov	r8,r9
8000adde:	c0 28       	rjmp	8000ade2 <__multiply+0x42>
8000ade0:	10 aa       	st.w	r8++,r10
8000ade2:	08 38       	cp.w	r8,r4
8000ade4:	cf e3       	brcs	8000ade0 <__multiply+0x40>
8000ade6:	2f b3       	sub	r3,-5
8000ade8:	2f b2       	sub	r2,-5
8000adea:	ec 03 00 23 	add	r3,r6,r3<<0x2
8000adee:	ea 02 00 22 	add	r2,r5,r2<<0x2
8000adf2:	ec cb ff ec 	sub	r11,r6,-20
8000adf6:	50 12       	stdsp	sp[0x4],r2
8000adf8:	ea ca ff ec 	sub	r10,r5,-20
8000adfc:	c4 48       	rjmp	8000ae84 <__multiply+0xe4>
8000adfe:	94 95       	ld.uh	r5,r10[0x2]
8000ae00:	58 05       	cp.w	r5,0
8000ae02:	c2 00       	breq	8000ae42 <__multiply+0xa2>
8000ae04:	12 98       	mov	r8,r9
8000ae06:	16 96       	mov	r6,r11
8000ae08:	30 0e       	mov	lr,0
8000ae0a:	50 09       	stdsp	sp[0x0],r9
8000ae0c:	0d 02       	ld.w	r2,r6++
8000ae0e:	e4 00 16 10 	lsr	r0,r2,0x10
8000ae12:	70 01       	ld.w	r1,r8[0x0]
8000ae14:	70 09       	ld.w	r9,r8[0x0]
8000ae16:	b1 81       	lsr	r1,0x10
8000ae18:	e5 d2 c0 10 	bfextu	r2,r2,0x0,0x10
8000ae1c:	e0 05 03 41 	mac	r1,r0,r5
8000ae20:	ab 32       	mul	r2,r5
8000ae22:	e1 d9 c0 10 	bfextu	r0,r9,0x0,0x10
8000ae26:	00 02       	add	r2,r0
8000ae28:	e4 0e 00 0e 	add	lr,r2,lr
8000ae2c:	b0 1e       	st.h	r8[0x2],lr
8000ae2e:	b1 8e       	lsr	lr,0x10
8000ae30:	1c 01       	add	r1,lr
8000ae32:	b0 01       	st.h	r8[0x0],r1
8000ae34:	e2 0e 16 10 	lsr	lr,r1,0x10
8000ae38:	2f c8       	sub	r8,-4
8000ae3a:	06 36       	cp.w	r6,r3
8000ae3c:	ce 83       	brcs	8000ae0c <__multiply+0x6c>
8000ae3e:	40 09       	lddsp	r9,sp[0x0]
8000ae40:	91 0e       	st.w	r8[0x0],lr
8000ae42:	94 86       	ld.uh	r6,r10[0x0]
8000ae44:	58 06       	cp.w	r6,0
8000ae46:	c1 d0       	breq	8000ae80 <__multiply+0xe0>
8000ae48:	72 02       	ld.w	r2,r9[0x0]
8000ae4a:	12 98       	mov	r8,r9
8000ae4c:	16 9e       	mov	lr,r11
8000ae4e:	30 05       	mov	r5,0
8000ae50:	b0 12       	st.h	r8[0x2],r2
8000ae52:	1d 01       	ld.w	r1,lr++
8000ae54:	90 82       	ld.uh	r2,r8[0x0]
8000ae56:	e1 d1 c0 10 	bfextu	r0,r1,0x0,0x10
8000ae5a:	ad 30       	mul	r0,r6
8000ae5c:	e0 02 00 02 	add	r2,r0,r2
8000ae60:	e4 05 00 05 	add	r5,r2,r5
8000ae64:	b0 05       	st.h	r8[0x0],r5
8000ae66:	b1 85       	lsr	r5,0x10
8000ae68:	b1 81       	lsr	r1,0x10
8000ae6a:	2f c8       	sub	r8,-4
8000ae6c:	ad 31       	mul	r1,r6
8000ae6e:	90 92       	ld.uh	r2,r8[0x2]
8000ae70:	e2 02 00 02 	add	r2,r1,r2
8000ae74:	0a 02       	add	r2,r5
8000ae76:	e4 05 16 10 	lsr	r5,r2,0x10
8000ae7a:	06 3e       	cp.w	lr,r3
8000ae7c:	ce a3       	brcs	8000ae50 <__multiply+0xb0>
8000ae7e:	91 02       	st.w	r8[0x0],r2
8000ae80:	2f ca       	sub	r10,-4
8000ae82:	2f c9       	sub	r9,-4
8000ae84:	40 18       	lddsp	r8,sp[0x4]
8000ae86:	10 3a       	cp.w	r10,r8
8000ae88:	cb b3       	brcs	8000adfe <__multiply+0x5e>
8000ae8a:	c0 28       	rjmp	8000ae8e <__multiply+0xee>
8000ae8c:	20 17       	sub	r7,1
8000ae8e:	58 07       	cp.w	r7,0
8000ae90:	e0 8a 00 05 	brle	8000ae9a <__multiply+0xfa>
8000ae94:	09 48       	ld.w	r8,--r4
8000ae96:	58 08       	cp.w	r8,0
8000ae98:	cf a0       	breq	8000ae8c <__multiply+0xec>
8000ae9a:	99 47       	st.w	r12[0x10],r7
8000ae9c:	2f ed       	sub	sp,-8
8000ae9e:	d8 32       	popm	r0-r7,pc

8000aea0 <__i2b>:
8000aea0:	d4 21       	pushm	r4-r7,lr
8000aea2:	16 97       	mov	r7,r11
8000aea4:	30 1b       	mov	r11,1
8000aea6:	c4 9e       	rcall	8000ab38 <_Balloc>
8000aea8:	30 19       	mov	r9,1
8000aeaa:	99 57       	st.w	r12[0x14],r7
8000aeac:	99 49       	st.w	r12[0x10],r9
8000aeae:	d8 22       	popm	r4-r7,pc

8000aeb0 <__multadd>:
8000aeb0:	d4 31       	pushm	r0-r7,lr
8000aeb2:	30 08       	mov	r8,0
8000aeb4:	12 95       	mov	r5,r9
8000aeb6:	16 97       	mov	r7,r11
8000aeb8:	18 96       	mov	r6,r12
8000aeba:	76 44       	ld.w	r4,r11[0x10]
8000aebc:	f6 c9 ff ec 	sub	r9,r11,-20
8000aec0:	72 0b       	ld.w	r11,r9[0x0]
8000aec2:	f6 0c 16 10 	lsr	r12,r11,0x10
8000aec6:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000aeca:	f4 0c 02 4c 	mul	r12,r10,r12
8000aece:	f4 0b 03 45 	mac	r5,r10,r11
8000aed2:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
8000aed6:	b1 85       	lsr	r5,0x10
8000aed8:	18 05       	add	r5,r12
8000aeda:	ea 0c 15 10 	lsl	r12,r5,0x10
8000aede:	f8 0b 00 0b 	add	r11,r12,r11
8000aee2:	12 ab       	st.w	r9++,r11
8000aee4:	2f f8       	sub	r8,-1
8000aee6:	b1 85       	lsr	r5,0x10
8000aee8:	08 38       	cp.w	r8,r4
8000aeea:	ce b5       	brlt	8000aec0 <__multadd+0x10>
8000aeec:	58 05       	cp.w	r5,0
8000aeee:	c1 c0       	breq	8000af26 <__multadd+0x76>
8000aef0:	6e 28       	ld.w	r8,r7[0x8]
8000aef2:	10 34       	cp.w	r4,r8
8000aef4:	c1 35       	brlt	8000af1a <__multadd+0x6a>
8000aef6:	6e 1b       	ld.w	r11,r7[0x4]
8000aef8:	0c 9c       	mov	r12,r6
8000aefa:	2f fb       	sub	r11,-1
8000aefc:	c1 ee       	rcall	8000ab38 <_Balloc>
8000aefe:	6e 4a       	ld.w	r10,r7[0x10]
8000af00:	ee cb ff f4 	sub	r11,r7,-12
8000af04:	18 93       	mov	r3,r12
8000af06:	2f ea       	sub	r10,-2
8000af08:	2f 4c       	sub	r12,-12
8000af0a:	a3 6a       	lsl	r10,0x2
8000af0c:	fe b0 de 64 	rcall	80006bd4 <memcpy>
8000af10:	0e 9b       	mov	r11,r7
8000af12:	0c 9c       	mov	r12,r6
8000af14:	fe b0 fd f8 	rcall	8000ab04 <_Bfree>
8000af18:	06 97       	mov	r7,r3
8000af1a:	e8 c8 ff ff 	sub	r8,r4,-1
8000af1e:	2f b4       	sub	r4,-5
8000af20:	8f 48       	st.w	r7[0x10],r8
8000af22:	ee 04 09 25 	st.w	r7[r4<<0x2],r5
8000af26:	0e 9c       	mov	r12,r7
8000af28:	d8 32       	popm	r0-r7,pc
8000af2a:	d7 03       	nop

8000af2c <__pow5mult>:
8000af2c:	d4 31       	pushm	r0-r7,lr
8000af2e:	14 96       	mov	r6,r10
8000af30:	18 97       	mov	r7,r12
8000af32:	16 94       	mov	r4,r11
8000af34:	f1 da c0 02 	bfextu	r8,r10,0x0,0x2
8000af38:	c0 90       	breq	8000af4a <__pow5mult+0x1e>
8000af3a:	20 18       	sub	r8,1
8000af3c:	fe c9 db 00 	sub	r9,pc,-9472
8000af40:	f2 08 03 2a 	ld.w	r10,r9[r8<<0x2]
8000af44:	30 09       	mov	r9,0
8000af46:	cb 5f       	rcall	8000aeb0 <__multadd>
8000af48:	18 94       	mov	r4,r12
8000af4a:	a3 46       	asr	r6,0x2
8000af4c:	c3 40       	breq	8000afb4 <__pow5mult+0x88>
8000af4e:	6e 95       	ld.w	r5,r7[0x24]
8000af50:	58 05       	cp.w	r5,0
8000af52:	c0 91       	brne	8000af64 <__pow5mult+0x38>
8000af54:	31 0c       	mov	r12,16
8000af56:	fe b0 dc 1b 	rcall	8000678c <malloc>
8000af5a:	99 35       	st.w	r12[0xc],r5
8000af5c:	8f 9c       	st.w	r7[0x24],r12
8000af5e:	99 15       	st.w	r12[0x4],r5
8000af60:	99 25       	st.w	r12[0x8],r5
8000af62:	99 05       	st.w	r12[0x0],r5
8000af64:	6e 93       	ld.w	r3,r7[0x24]
8000af66:	66 25       	ld.w	r5,r3[0x8]
8000af68:	58 05       	cp.w	r5,0
8000af6a:	c0 c1       	brne	8000af82 <__pow5mult+0x56>
8000af6c:	e0 6b 02 71 	mov	r11,625
8000af70:	0e 9c       	mov	r12,r7
8000af72:	c9 7f       	rcall	8000aea0 <__i2b>
8000af74:	87 2c       	st.w	r3[0x8],r12
8000af76:	30 08       	mov	r8,0
8000af78:	18 95       	mov	r5,r12
8000af7a:	99 08       	st.w	r12[0x0],r8
8000af7c:	c0 38       	rjmp	8000af82 <__pow5mult+0x56>
8000af7e:	06 9c       	mov	r12,r3
8000af80:	18 95       	mov	r5,r12
8000af82:	ed b6 00 00 	bld	r6,0x0
8000af86:	c0 b1       	brne	8000af9c <__pow5mult+0x70>
8000af88:	08 9b       	mov	r11,r4
8000af8a:	0a 9a       	mov	r10,r5
8000af8c:	0e 9c       	mov	r12,r7
8000af8e:	c0 9f       	rcall	8000ada0 <__multiply>
8000af90:	08 9b       	mov	r11,r4
8000af92:	18 93       	mov	r3,r12
8000af94:	0e 9c       	mov	r12,r7
8000af96:	06 94       	mov	r4,r3
8000af98:	fe b0 fd b6 	rcall	8000ab04 <_Bfree>
8000af9c:	a1 56       	asr	r6,0x1
8000af9e:	c0 b0       	breq	8000afb4 <__pow5mult+0x88>
8000afa0:	6a 03       	ld.w	r3,r5[0x0]
8000afa2:	58 03       	cp.w	r3,0
8000afa4:	ce d1       	brne	8000af7e <__pow5mult+0x52>
8000afa6:	0a 9a       	mov	r10,r5
8000afa8:	0a 9b       	mov	r11,r5
8000afaa:	0e 9c       	mov	r12,r7
8000afac:	cf ae       	rcall	8000ada0 <__multiply>
8000afae:	8b 0c       	st.w	r5[0x0],r12
8000afb0:	99 03       	st.w	r12[0x0],r3
8000afb2:	ce 7b       	rjmp	8000af80 <__pow5mult+0x54>
8000afb4:	08 9c       	mov	r12,r4
8000afb6:	d8 32       	popm	r0-r7,pc

8000afb8 <__isinfd>:
8000afb8:	14 98       	mov	r8,r10
8000afba:	fc 19 7f f0 	movh	r9,0x7ff0
8000afbe:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000afc2:	f0 0b 11 00 	rsub	r11,r8,0
8000afc6:	f7 e8 10 08 	or	r8,r11,r8
8000afca:	f5 e8 13 f8 	or	r8,r10,r8>>0x1f
8000afce:	f2 08 01 08 	sub	r8,r9,r8
8000afd2:	f0 0c 11 00 	rsub	r12,r8,0
8000afd6:	f9 e8 10 08 	or	r8,r12,r8
8000afda:	f0 0c 14 1f 	asr	r12,r8,0x1f
8000afde:	2f fc       	sub	r12,-1
8000afe0:	5e fc       	retal	r12

8000afe2 <__isnand>:
8000afe2:	14 98       	mov	r8,r10
8000afe4:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000afe8:	f0 0c 11 00 	rsub	r12,r8,0
8000afec:	10 4c       	or	r12,r8
8000afee:	fc 18 7f f0 	movh	r8,0x7ff0
8000aff2:	f5 ec 13 fc 	or	r12,r10,r12>>0x1f
8000aff6:	f0 0c 01 0c 	sub	r12,r8,r12
8000affa:	bf 9c       	lsr	r12,0x1f
8000affc:	5e fc       	retal	r12
8000affe:	d7 03       	nop

8000b000 <__sclose>:
8000b000:	d4 01       	pushm	lr
8000b002:	96 7b       	ld.sh	r11,r11[0xe]
8000b004:	c7 6c       	rcall	8000b0f0 <_close_r>
8000b006:	d8 02       	popm	pc

8000b008 <__sseek>:
8000b008:	d4 21       	pushm	r4-r7,lr
8000b00a:	16 97       	mov	r7,r11
8000b00c:	96 7b       	ld.sh	r11,r11[0xe]
8000b00e:	cf 7c       	rcall	8000b1fc <_lseek_r>
8000b010:	8e 68       	ld.sh	r8,r7[0xc]
8000b012:	10 99       	mov	r9,r8
8000b014:	ad c8       	cbr	r8,0xc
8000b016:	ad a9       	sbr	r9,0xc
8000b018:	5b fc       	cp.w	r12,-1
8000b01a:	ef f8 0c 06 	st.heq	r7[0xc],r8
8000b01e:	ef f9 1c 06 	st.hne	r7[0xc],r9
8000b022:	ef fc 1a 15 	st.wne	r7[0x54],r12
8000b026:	d8 22       	popm	r4-r7,pc

8000b028 <__swrite>:
8000b028:	d4 21       	pushm	r4-r7,lr
8000b02a:	96 68       	ld.sh	r8,r11[0xc]
8000b02c:	16 97       	mov	r7,r11
8000b02e:	14 95       	mov	r5,r10
8000b030:	12 94       	mov	r4,r9
8000b032:	e2 18 01 00 	andl	r8,0x100,COH
8000b036:	18 96       	mov	r6,r12
8000b038:	c0 50       	breq	8000b042 <__swrite+0x1a>
8000b03a:	30 29       	mov	r9,2
8000b03c:	30 0a       	mov	r10,0
8000b03e:	96 7b       	ld.sh	r11,r11[0xe]
8000b040:	cd ec       	rcall	8000b1fc <_lseek_r>
8000b042:	8e 68       	ld.sh	r8,r7[0xc]
8000b044:	ad c8       	cbr	r8,0xc
8000b046:	08 99       	mov	r9,r4
8000b048:	0a 9a       	mov	r10,r5
8000b04a:	8e 7b       	ld.sh	r11,r7[0xe]
8000b04c:	0c 9c       	mov	r12,r6
8000b04e:	ae 68       	st.h	r7[0xc],r8
8000b050:	c1 0c       	rcall	8000b070 <_write_r>
8000b052:	d8 22       	popm	r4-r7,pc

8000b054 <__sread>:
8000b054:	d4 21       	pushm	r4-r7,lr
8000b056:	16 97       	mov	r7,r11
8000b058:	96 7b       	ld.sh	r11,r11[0xe]
8000b05a:	ce 5c       	rcall	8000b224 <_read_r>
8000b05c:	c0 65       	brlt	8000b068 <__sread+0x14>
8000b05e:	6f 58       	ld.w	r8,r7[0x54]
8000b060:	18 08       	add	r8,r12
8000b062:	ef 48 00 54 	st.w	r7[84],r8
8000b066:	d8 22       	popm	r4-r7,pc
8000b068:	8e 68       	ld.sh	r8,r7[0xc]
8000b06a:	ad c8       	cbr	r8,0xc
8000b06c:	ae 68       	st.h	r7[0xc],r8
8000b06e:	d8 22       	popm	r4-r7,pc

8000b070 <_write_r>:
8000b070:	d4 21       	pushm	r4-r7,lr
8000b072:	16 98       	mov	r8,r11
8000b074:	18 97       	mov	r7,r12
8000b076:	10 9c       	mov	r12,r8
8000b078:	30 08       	mov	r8,0
8000b07a:	14 9b       	mov	r11,r10
8000b07c:	e0 66 41 14 	mov	r6,16660
8000b080:	12 9a       	mov	r10,r9
8000b082:	8d 08       	st.w	r6[0x0],r8
8000b084:	fe b0 d1 24 	rcall	800052cc <_write>
8000b088:	5b fc       	cp.w	r12,-1
8000b08a:	c0 51       	brne	8000b094 <_write_r+0x24>
8000b08c:	6c 08       	ld.w	r8,r6[0x0]
8000b08e:	58 08       	cp.w	r8,0
8000b090:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b094:	d8 22       	popm	r4-r7,pc
8000b096:	d7 03       	nop

8000b098 <_calloc_r>:
8000b098:	d4 21       	pushm	r4-r7,lr
8000b09a:	f4 0b 02 4b 	mul	r11,r10,r11
8000b09e:	fe b0 db 7f 	rcall	8000679c <_malloc_r>
8000b0a2:	18 97       	mov	r7,r12
8000b0a4:	c2 30       	breq	8000b0ea <_calloc_r+0x52>
8000b0a6:	f8 fa ff fc 	ld.w	r10,r12[-4]
8000b0aa:	e0 1a ff fc 	andl	r10,0xfffc
8000b0ae:	20 4a       	sub	r10,4
8000b0b0:	e0 4a 00 24 	cp.w	r10,36
8000b0b4:	e0 8b 00 18 	brhi	8000b0e4 <_calloc_r+0x4c>
8000b0b8:	18 98       	mov	r8,r12
8000b0ba:	59 3a       	cp.w	r10,19
8000b0bc:	e0 88 00 0f 	brls	8000b0da <_calloc_r+0x42>
8000b0c0:	30 09       	mov	r9,0
8000b0c2:	10 a9       	st.w	r8++,r9
8000b0c4:	10 a9       	st.w	r8++,r9
8000b0c6:	59 ba       	cp.w	r10,27
8000b0c8:	e0 88 00 09 	brls	8000b0da <_calloc_r+0x42>
8000b0cc:	10 a9       	st.w	r8++,r9
8000b0ce:	10 a9       	st.w	r8++,r9
8000b0d0:	e0 4a 00 24 	cp.w	r10,36
8000b0d4:	c0 31       	brne	8000b0da <_calloc_r+0x42>
8000b0d6:	10 a9       	st.w	r8++,r9
8000b0d8:	10 a9       	st.w	r8++,r9
8000b0da:	30 09       	mov	r9,0
8000b0dc:	10 a9       	st.w	r8++,r9
8000b0de:	91 19       	st.w	r8[0x4],r9
8000b0e0:	91 09       	st.w	r8[0x0],r9
8000b0e2:	c0 48       	rjmp	8000b0ea <_calloc_r+0x52>
8000b0e4:	30 0b       	mov	r11,0
8000b0e6:	fe b0 de 1b 	rcall	80006d1c <memset>
8000b0ea:	0e 9c       	mov	r12,r7
8000b0ec:	d8 22       	popm	r4-r7,pc
8000b0ee:	d7 03       	nop

8000b0f0 <_close_r>:
8000b0f0:	d4 21       	pushm	r4-r7,lr
8000b0f2:	30 08       	mov	r8,0
8000b0f4:	18 97       	mov	r7,r12
8000b0f6:	e0 66 41 14 	mov	r6,16660
8000b0fa:	16 9c       	mov	r12,r11
8000b0fc:	8d 08       	st.w	r6[0x0],r8
8000b0fe:	fe b0 df c1 	rcall	80007080 <_close>
8000b102:	5b fc       	cp.w	r12,-1
8000b104:	c0 51       	brne	8000b10e <_close_r+0x1e>
8000b106:	6c 08       	ld.w	r8,r6[0x0]
8000b108:	58 08       	cp.w	r8,0
8000b10a:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b10e:	d8 22       	popm	r4-r7,pc

8000b110 <_fclose_r>:
8000b110:	d4 21       	pushm	r4-r7,lr
8000b112:	18 96       	mov	r6,r12
8000b114:	16 97       	mov	r7,r11
8000b116:	58 0b       	cp.w	r11,0
8000b118:	c0 31       	brne	8000b11e <_fclose_r+0xe>
8000b11a:	16 95       	mov	r5,r11
8000b11c:	c5 38       	rjmp	8000b1c2 <_fclose_r+0xb2>
8000b11e:	fe b0 f8 b5 	rcall	8000a288 <__sfp_lock_acquire>
8000b122:	58 06       	cp.w	r6,0
8000b124:	c0 70       	breq	8000b132 <_fclose_r+0x22>
8000b126:	6c 68       	ld.w	r8,r6[0x18]
8000b128:	58 08       	cp.w	r8,0
8000b12a:	c0 41       	brne	8000b132 <_fclose_r+0x22>
8000b12c:	0c 9c       	mov	r12,r6
8000b12e:	fe b0 f8 ff 	rcall	8000a32c <__sinit>
8000b132:	fe c8 dd 9a 	sub	r8,pc,-8806
8000b136:	10 37       	cp.w	r7,r8
8000b138:	c0 31       	brne	8000b13e <_fclose_r+0x2e>
8000b13a:	6c 07       	ld.w	r7,r6[0x0]
8000b13c:	c0 c8       	rjmp	8000b154 <_fclose_r+0x44>
8000b13e:	fe c8 dd 86 	sub	r8,pc,-8826
8000b142:	10 37       	cp.w	r7,r8
8000b144:	c0 31       	brne	8000b14a <_fclose_r+0x3a>
8000b146:	6c 17       	ld.w	r7,r6[0x4]
8000b148:	c0 68       	rjmp	8000b154 <_fclose_r+0x44>
8000b14a:	fe c8 dd 72 	sub	r8,pc,-8846
8000b14e:	10 37       	cp.w	r7,r8
8000b150:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000b154:	8e 69       	ld.sh	r9,r7[0xc]
8000b156:	30 08       	mov	r8,0
8000b158:	f0 09 19 00 	cp.h	r9,r8
8000b15c:	c0 51       	brne	8000b166 <_fclose_r+0x56>
8000b15e:	fe b0 f8 96 	rcall	8000a28a <__sfp_lock_release>
8000b162:	30 05       	mov	r5,0
8000b164:	c2 f8       	rjmp	8000b1c2 <_fclose_r+0xb2>
8000b166:	0e 9b       	mov	r11,r7
8000b168:	0c 9c       	mov	r12,r6
8000b16a:	fe b0 f8 09 	rcall	8000a17c <_fflush_r>
8000b16e:	6e c8       	ld.w	r8,r7[0x30]
8000b170:	18 95       	mov	r5,r12
8000b172:	58 08       	cp.w	r8,0
8000b174:	c0 60       	breq	8000b180 <_fclose_r+0x70>
8000b176:	6e 8b       	ld.w	r11,r7[0x20]
8000b178:	0c 9c       	mov	r12,r6
8000b17a:	5d 18       	icall	r8
8000b17c:	f9 b5 05 ff 	movlt	r5,-1
8000b180:	8e 68       	ld.sh	r8,r7[0xc]
8000b182:	ed b8 00 07 	bld	r8,0x7
8000b186:	c0 51       	brne	8000b190 <_fclose_r+0x80>
8000b188:	6e 4b       	ld.w	r11,r7[0x10]
8000b18a:	0c 9c       	mov	r12,r6
8000b18c:	fe b0 f9 6a 	rcall	8000a460 <_free_r>
8000b190:	6e db       	ld.w	r11,r7[0x34]
8000b192:	58 0b       	cp.w	r11,0
8000b194:	c0 a0       	breq	8000b1a8 <_fclose_r+0x98>
8000b196:	ee c8 ff bc 	sub	r8,r7,-68
8000b19a:	10 3b       	cp.w	r11,r8
8000b19c:	c0 40       	breq	8000b1a4 <_fclose_r+0x94>
8000b19e:	0c 9c       	mov	r12,r6
8000b1a0:	fe b0 f9 60 	rcall	8000a460 <_free_r>
8000b1a4:	30 08       	mov	r8,0
8000b1a6:	8f d8       	st.w	r7[0x34],r8
8000b1a8:	6f 2b       	ld.w	r11,r7[0x48]
8000b1aa:	58 0b       	cp.w	r11,0
8000b1ac:	c0 70       	breq	8000b1ba <_fclose_r+0xaa>
8000b1ae:	0c 9c       	mov	r12,r6
8000b1b0:	fe b0 f9 58 	rcall	8000a460 <_free_r>
8000b1b4:	30 08       	mov	r8,0
8000b1b6:	ef 48 00 48 	st.w	r7[72],r8
8000b1ba:	30 08       	mov	r8,0
8000b1bc:	ae 68       	st.h	r7[0xc],r8
8000b1be:	fe b0 f8 66 	rcall	8000a28a <__sfp_lock_release>
8000b1c2:	0a 9c       	mov	r12,r5
8000b1c4:	d8 22       	popm	r4-r7,pc
8000b1c6:	d7 03       	nop

8000b1c8 <fclose>:
8000b1c8:	d4 01       	pushm	lr
8000b1ca:	e0 68 0a 30 	mov	r8,2608
8000b1ce:	18 9b       	mov	r11,r12
8000b1d0:	70 0c       	ld.w	r12,r8[0x0]
8000b1d2:	c9 ff       	rcall	8000b110 <_fclose_r>
8000b1d4:	d8 02       	popm	pc
8000b1d6:	d7 03       	nop

8000b1d8 <_fstat_r>:
8000b1d8:	d4 21       	pushm	r4-r7,lr
8000b1da:	16 98       	mov	r8,r11
8000b1dc:	18 97       	mov	r7,r12
8000b1de:	10 9c       	mov	r12,r8
8000b1e0:	30 08       	mov	r8,0
8000b1e2:	e0 66 41 14 	mov	r6,16660
8000b1e6:	14 9b       	mov	r11,r10
8000b1e8:	8d 08       	st.w	r6[0x0],r8
8000b1ea:	fe b0 df 73 	rcall	800070d0 <_fstat>
8000b1ee:	5b fc       	cp.w	r12,-1
8000b1f0:	c0 51       	brne	8000b1fa <_fstat_r+0x22>
8000b1f2:	6c 08       	ld.w	r8,r6[0x0]
8000b1f4:	58 08       	cp.w	r8,0
8000b1f6:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b1fa:	d8 22       	popm	r4-r7,pc

8000b1fc <_lseek_r>:
8000b1fc:	d4 21       	pushm	r4-r7,lr
8000b1fe:	16 98       	mov	r8,r11
8000b200:	18 97       	mov	r7,r12
8000b202:	10 9c       	mov	r12,r8
8000b204:	30 08       	mov	r8,0
8000b206:	14 9b       	mov	r11,r10
8000b208:	e0 66 41 14 	mov	r6,16660
8000b20c:	12 9a       	mov	r10,r9
8000b20e:	8d 08       	st.w	r6[0x0],r8
8000b210:	fe b0 df 42 	rcall	80007094 <_lseek>
8000b214:	5b fc       	cp.w	r12,-1
8000b216:	c0 51       	brne	8000b220 <_lseek_r+0x24>
8000b218:	6c 08       	ld.w	r8,r6[0x0]
8000b21a:	58 08       	cp.w	r8,0
8000b21c:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b220:	d8 22       	popm	r4-r7,pc
8000b222:	d7 03       	nop

8000b224 <_read_r>:
8000b224:	d4 21       	pushm	r4-r7,lr
8000b226:	16 98       	mov	r8,r11
8000b228:	18 97       	mov	r7,r12
8000b22a:	10 9c       	mov	r12,r8
8000b22c:	30 08       	mov	r8,0
8000b22e:	14 9b       	mov	r11,r10
8000b230:	e0 66 41 14 	mov	r6,16660
8000b234:	12 9a       	mov	r10,r9
8000b236:	8d 08       	st.w	r6[0x0],r8
8000b238:	fe b0 d0 2a 	rcall	8000528c <_read>
8000b23c:	5b fc       	cp.w	r12,-1
8000b23e:	c0 51       	brne	8000b248 <_read_r+0x24>
8000b240:	6c 08       	ld.w	r8,r6[0x0]
8000b242:	58 08       	cp.w	r8,0
8000b244:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b248:	d8 22       	popm	r4-r7,pc
8000b24a:	d7 03       	nop

8000b24c <__avr32_f64_mul>:
8000b24c:	f5 eb 10 1c 	or	r12,r10,r11<<0x1
8000b250:	e0 80 00 dc 	breq	8000b408 <__avr32_f64_mul_op1_zero>
8000b254:	d4 21       	pushm	r4-r7,lr
8000b256:	f7 e9 20 0e 	eor	lr,r11,r9
8000b25a:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000b25e:	30 15       	mov	r5,1
8000b260:	c4 30       	breq	8000b2e6 <__avr32_f64_mul_op1_subnormal>
8000b262:	ab 6b       	lsl	r11,0xa
8000b264:	f7 ea 13 6b 	or	r11,r11,r10>>0x16
8000b268:	ab 6a       	lsl	r10,0xa
8000b26a:	f7 d5 d3 c2 	bfins	r11,r5,0x1e,0x2
8000b26e:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000b272:	c5 c0       	breq	8000b32a <__avr32_f64_mul_op2_subnormal>
8000b274:	a1 78       	lsl	r8,0x1
8000b276:	5c f9       	rol	r9
8000b278:	f3 d5 d2 ab 	bfins	r9,r5,0x15,0xb
8000b27c:	e0 47 07 ff 	cp.w	r7,2047
8000b280:	c7 70       	breq	8000b36e <__avr32_f64_mul_op_nan_or_inf>
8000b282:	e0 46 07 ff 	cp.w	r6,2047
8000b286:	c7 40       	breq	8000b36e <__avr32_f64_mul_op_nan_or_inf>
8000b288:	ee 06 00 0c 	add	r12,r7,r6
8000b28c:	e0 2c 03 fe 	sub	r12,1022
8000b290:	f6 08 06 44 	mulu.d	r4,r11,r8
8000b294:	f4 09 07 44 	macu.d	r4,r10,r9
8000b298:	f4 08 06 46 	mulu.d	r6,r10,r8
8000b29c:	f6 09 06 4a 	mulu.d	r10,r11,r9
8000b2a0:	08 07       	add	r7,r4
8000b2a2:	f4 05 00 4a 	adc	r10,r10,r5
8000b2a6:	5c 0b       	acr	r11
8000b2a8:	ed bb 00 14 	bld	r11,0x14
8000b2ac:	c0 50       	breq	8000b2b6 <__avr32_f64_mul+0x6a>
8000b2ae:	a1 77       	lsl	r7,0x1
8000b2b0:	5c fa       	rol	r10
8000b2b2:	5c fb       	rol	r11
8000b2b4:	20 1c       	sub	r12,1
8000b2b6:	58 0c       	cp.w	r12,0
8000b2b8:	e0 8a 00 6f 	brle	8000b396 <__avr32_f64_mul_res_subnormal>
8000b2bc:	e0 4c 07 ff 	cp.w	r12,2047
8000b2c0:	e0 84 00 9c 	brge	8000b3f8 <__avr32_f64_mul_res_inf>
8000b2c4:	f7 dc d2 8b 	bfins	r11,r12,0x14,0xb
8000b2c8:	ed ea 11 f6 	or	r6,r6,r10<<0x1f
8000b2cc:	ef e6 12 17 	or	r7,r7,r6>>0x1
8000b2d0:	ee 17 80 00 	eorh	r7,0x8000
8000b2d4:	f1 b7 04 20 	satu	r7,0x1
8000b2d8:	0e 0a       	add	r10,r7
8000b2da:	5c 0b       	acr	r11
8000b2dc:	ed be 00 1f 	bld	lr,0x1f
8000b2e0:	ef bb 00 1f 	bst	r11,0x1f
8000b2e4:	d8 22       	popm	r4-r7,pc

8000b2e6 <__avr32_f64_mul_op1_subnormal>:
8000b2e6:	e4 1b 00 0f 	andh	r11,0xf
8000b2ea:	f4 0c 12 00 	clz	r12,r10
8000b2ee:	f6 06 12 00 	clz	r6,r11
8000b2f2:	f7 bc 03 e1 	sublo	r12,-31
8000b2f6:	f8 06 17 30 	movlo	r6,r12
8000b2fa:	f7 b6 02 01 	subhs	r6,1
8000b2fe:	e0 46 00 20 	cp.w	r6,32
8000b302:	c0 d4       	brge	8000b31c <__avr32_f64_mul_op1_subnormal+0x36>
8000b304:	ec 0c 11 20 	rsub	r12,r6,32
8000b308:	f6 06 09 4b 	lsl	r11,r11,r6
8000b30c:	f4 0c 0a 4c 	lsr	r12,r10,r12
8000b310:	18 4b       	or	r11,r12
8000b312:	f4 06 09 4a 	lsl	r10,r10,r6
8000b316:	20 b6       	sub	r6,11
8000b318:	0c 17       	sub	r7,r6
8000b31a:	ca ab       	rjmp	8000b26e <__avr32_f64_mul+0x22>
8000b31c:	f4 06 09 4b 	lsl	r11,r10,r6
8000b320:	c6 40       	breq	8000b3e8 <__avr32_f64_mul_res_zero>
8000b322:	30 0a       	mov	r10,0
8000b324:	20 b6       	sub	r6,11
8000b326:	0c 17       	sub	r7,r6
8000b328:	ca 3b       	rjmp	8000b26e <__avr32_f64_mul+0x22>

8000b32a <__avr32_f64_mul_op2_subnormal>:
8000b32a:	e4 19 00 0f 	andh	r9,0xf
8000b32e:	f0 0c 12 00 	clz	r12,r8
8000b332:	f2 05 12 00 	clz	r5,r9
8000b336:	f7 bc 03 ea 	sublo	r12,-22
8000b33a:	f8 05 17 30 	movlo	r5,r12
8000b33e:	f7 b5 02 0a 	subhs	r5,10
8000b342:	e0 45 00 20 	cp.w	r5,32
8000b346:	c0 d4       	brge	8000b360 <__avr32_f64_mul_op2_subnormal+0x36>
8000b348:	ea 0c 11 20 	rsub	r12,r5,32
8000b34c:	f2 05 09 49 	lsl	r9,r9,r5
8000b350:	f0 0c 0a 4c 	lsr	r12,r8,r12
8000b354:	18 49       	or	r9,r12
8000b356:	f0 05 09 48 	lsl	r8,r8,r5
8000b35a:	20 25       	sub	r5,2
8000b35c:	0a 16       	sub	r6,r5
8000b35e:	c8 fb       	rjmp	8000b27c <__avr32_f64_mul+0x30>
8000b360:	f0 05 09 49 	lsl	r9,r8,r5
8000b364:	c4 20       	breq	8000b3e8 <__avr32_f64_mul_res_zero>
8000b366:	30 08       	mov	r8,0
8000b368:	20 25       	sub	r5,2
8000b36a:	0a 16       	sub	r6,r5
8000b36c:	c8 8b       	rjmp	8000b27c <__avr32_f64_mul+0x30>

8000b36e <__avr32_f64_mul_op_nan_or_inf>:
8000b36e:	e4 19 00 0f 	andh	r9,0xf
8000b372:	e4 1b 00 0f 	andh	r11,0xf
8000b376:	14 4b       	or	r11,r10
8000b378:	10 49       	or	r9,r8
8000b37a:	e0 47 07 ff 	cp.w	r7,2047
8000b37e:	c0 91       	brne	8000b390 <__avr32_f64_mul_op1_not_naninf>
8000b380:	58 0b       	cp.w	r11,0
8000b382:	c3 81       	brne	8000b3f2 <__avr32_f64_mul_res_nan>
8000b384:	e0 46 07 ff 	cp.w	r6,2047
8000b388:	c3 81       	brne	8000b3f8 <__avr32_f64_mul_res_inf>
8000b38a:	58 09       	cp.w	r9,0
8000b38c:	c3 60       	breq	8000b3f8 <__avr32_f64_mul_res_inf>
8000b38e:	c3 28       	rjmp	8000b3f2 <__avr32_f64_mul_res_nan>

8000b390 <__avr32_f64_mul_op1_not_naninf>:
8000b390:	58 09       	cp.w	r9,0
8000b392:	c3 30       	breq	8000b3f8 <__avr32_f64_mul_res_inf>
8000b394:	c2 f8       	rjmp	8000b3f2 <__avr32_f64_mul_res_nan>

8000b396 <__avr32_f64_mul_res_subnormal>:
8000b396:	5c 3c       	neg	r12
8000b398:	2f fc       	sub	r12,-1
8000b39a:	f1 bc 04 c0 	satu	r12,0x6
8000b39e:	e0 4c 00 20 	cp.w	r12,32
8000b3a2:	c1 14       	brge	8000b3c4 <__avr32_f64_mul_res_subnormal+0x2e>
8000b3a4:	f8 08 11 20 	rsub	r8,r12,32
8000b3a8:	0e 46       	or	r6,r7
8000b3aa:	ee 0c 0a 47 	lsr	r7,r7,r12
8000b3ae:	f4 08 09 49 	lsl	r9,r10,r8
8000b3b2:	12 47       	or	r7,r9
8000b3b4:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000b3b8:	f6 08 09 49 	lsl	r9,r11,r8
8000b3bc:	12 4a       	or	r10,r9
8000b3be:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000b3c2:	c8 3b       	rjmp	8000b2c8 <__avr32_f64_mul+0x7c>
8000b3c4:	f8 08 11 20 	rsub	r8,r12,32
8000b3c8:	f9 b9 00 00 	moveq	r9,0
8000b3cc:	c0 30       	breq	8000b3d2 <__avr32_f64_mul_res_subnormal+0x3c>
8000b3ce:	f6 08 09 49 	lsl	r9,r11,r8
8000b3d2:	0e 46       	or	r6,r7
8000b3d4:	ed ea 10 16 	or	r6,r6,r10<<0x1
8000b3d8:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000b3dc:	f3 ea 10 07 	or	r7,r9,r10
8000b3e0:	f6 0c 0a 4a 	lsr	r10,r11,r12
8000b3e4:	30 0b       	mov	r11,0
8000b3e6:	c7 1b       	rjmp	8000b2c8 <__avr32_f64_mul+0x7c>

8000b3e8 <__avr32_f64_mul_res_zero>:
8000b3e8:	1c 9b       	mov	r11,lr
8000b3ea:	e6 1b 80 00 	andh	r11,0x8000,COH
8000b3ee:	30 0a       	mov	r10,0
8000b3f0:	d8 22       	popm	r4-r7,pc

8000b3f2 <__avr32_f64_mul_res_nan>:
8000b3f2:	3f fb       	mov	r11,-1
8000b3f4:	3f fa       	mov	r10,-1
8000b3f6:	d8 22       	popm	r4-r7,pc

8000b3f8 <__avr32_f64_mul_res_inf>:
8000b3f8:	f0 6b 00 00 	mov	r11,-1048576
8000b3fc:	ed be 00 1f 	bld	lr,0x1f
8000b400:	ef bb 00 1f 	bst	r11,0x1f
8000b404:	30 0a       	mov	r10,0
8000b406:	d8 22       	popm	r4-r7,pc

8000b408 <__avr32_f64_mul_op1_zero>:
8000b408:	f7 e9 20 0b 	eor	r11,r11,r9
8000b40c:	e6 1b 80 00 	andh	r11,0x8000,COH
8000b410:	f9 d9 c2 8b 	bfextu	r12,r9,0x14,0xb
8000b414:	e0 4c 07 ff 	cp.w	r12,2047
8000b418:	5e 1c       	retne	r12
8000b41a:	3f fa       	mov	r10,-1
8000b41c:	3f fb       	mov	r11,-1
8000b41e:	5e fc       	retal	r12

8000b420 <__avr32_f64_sub_from_add>:
8000b420:	ee 19 80 00 	eorh	r9,0x8000

8000b424 <__avr32_f64_sub>:
8000b424:	f7 e9 20 0c 	eor	r12,r11,r9
8000b428:	e0 86 00 ca 	brmi	8000b5bc <__avr32_f64_add_from_sub>
8000b42c:	eb cd 40 e0 	pushm	r5-r7,lr
8000b430:	16 9c       	mov	r12,r11
8000b432:	e6 1c 80 00 	andh	r12,0x8000,COH
8000b436:	bf db       	cbr	r11,0x1f
8000b438:	bf d9       	cbr	r9,0x1f
8000b43a:	10 3a       	cp.w	r10,r8
8000b43c:	f2 0b 13 00 	cpc	r11,r9
8000b440:	c0 92       	brcc	8000b452 <__avr32_f64_sub+0x2e>
8000b442:	16 97       	mov	r7,r11
8000b444:	12 9b       	mov	r11,r9
8000b446:	0e 99       	mov	r9,r7
8000b448:	14 97       	mov	r7,r10
8000b44a:	10 9a       	mov	r10,r8
8000b44c:	0e 98       	mov	r8,r7
8000b44e:	ee 1c 80 00 	eorh	r12,0x8000
8000b452:	f6 07 16 14 	lsr	r7,r11,0x14
8000b456:	ab 7b       	lsl	r11,0xb
8000b458:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000b45c:	ab 7a       	lsl	r10,0xb
8000b45e:	bf bb       	sbr	r11,0x1f
8000b460:	f2 06 16 14 	lsr	r6,r9,0x14
8000b464:	c4 40       	breq	8000b4ec <__avr32_f64_sub_opL_subnormal>
8000b466:	ab 79       	lsl	r9,0xb
8000b468:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000b46c:	ab 78       	lsl	r8,0xb
8000b46e:	bf b9       	sbr	r9,0x1f

8000b470 <__avr32_f64_sub_opL_subnormal_done>:
8000b470:	e0 47 07 ff 	cp.w	r7,2047
8000b474:	c4 f0       	breq	8000b512 <__avr32_f64_sub_opH_nan_or_inf>
8000b476:	0e 26       	rsub	r6,r7
8000b478:	c1 20       	breq	8000b49c <__avr32_f64_sub_shift_done>
8000b47a:	ec 05 11 20 	rsub	r5,r6,32
8000b47e:	e0 46 00 20 	cp.w	r6,32
8000b482:	c7 c2       	brcc	8000b57a <__avr32_f64_sub_longshift>
8000b484:	f0 05 09 4e 	lsl	lr,r8,r5
8000b488:	f2 05 09 45 	lsl	r5,r9,r5
8000b48c:	f0 06 0a 48 	lsr	r8,r8,r6
8000b490:	f2 06 0a 49 	lsr	r9,r9,r6
8000b494:	0a 48       	or	r8,r5
8000b496:	58 0e       	cp.w	lr,0
8000b498:	5f 1e       	srne	lr
8000b49a:	1c 48       	or	r8,lr

8000b49c <__avr32_f64_sub_shift_done>:
8000b49c:	10 1a       	sub	r10,r8
8000b49e:	f6 09 01 4b 	sbc	r11,r11,r9
8000b4a2:	f6 06 12 00 	clz	r6,r11
8000b4a6:	c0 e0       	breq	8000b4c2 <__avr32_f64_sub_longnormalize_done>
8000b4a8:	c7 83       	brcs	8000b598 <__avr32_f64_sub_longnormalize>
8000b4aa:	ec 0e 11 20 	rsub	lr,r6,32
8000b4ae:	f6 06 09 4b 	lsl	r11,r11,r6
8000b4b2:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000b4b6:	1c 4b       	or	r11,lr
8000b4b8:	f4 06 09 4a 	lsl	r10,r10,r6
8000b4bc:	0c 17       	sub	r7,r6
8000b4be:	e0 8a 00 39 	brle	8000b530 <__avr32_f64_sub_subnormal_result>

8000b4c2 <__avr32_f64_sub_longnormalize_done>:
8000b4c2:	f4 09 15 15 	lsl	r9,r10,0x15
8000b4c6:	ab 9a       	lsr	r10,0xb
8000b4c8:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000b4cc:	ab 9b       	lsr	r11,0xb
8000b4ce:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000b4d2:	18 4b       	or	r11,r12

8000b4d4 <__avr32_f64_sub_round>:
8000b4d4:	fc 17 80 00 	movh	r7,0x8000
8000b4d8:	ed ba 00 00 	bld	r10,0x0
8000b4dc:	f7 b7 01 ff 	subne	r7,-1
8000b4e0:	0e 39       	cp.w	r9,r7
8000b4e2:	5f 29       	srhs	r9
8000b4e4:	12 0a       	add	r10,r9
8000b4e6:	5c 0b       	acr	r11
8000b4e8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b4ec <__avr32_f64_sub_opL_subnormal>:
8000b4ec:	ab 79       	lsl	r9,0xb
8000b4ee:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000b4f2:	ab 78       	lsl	r8,0xb
8000b4f4:	f3 e8 10 0e 	or	lr,r9,r8
8000b4f8:	f9 b6 01 01 	movne	r6,1
8000b4fc:	ee 0e 11 00 	rsub	lr,r7,0
8000b500:	f9 b7 00 01 	moveq	r7,1
8000b504:	ef bb 00 1f 	bst	r11,0x1f
8000b508:	f7 ea 10 0e 	or	lr,r11,r10
8000b50c:	f9 b7 00 00 	moveq	r7,0
8000b510:	cb 0b       	rjmp	8000b470 <__avr32_f64_sub_opL_subnormal_done>

8000b512 <__avr32_f64_sub_opH_nan_or_inf>:
8000b512:	bf db       	cbr	r11,0x1f
8000b514:	f7 ea 10 0e 	or	lr,r11,r10
8000b518:	c0 81       	brne	8000b528 <__avr32_f64_sub_return_nan>
8000b51a:	e0 46 07 ff 	cp.w	r6,2047
8000b51e:	c0 50       	breq	8000b528 <__avr32_f64_sub_return_nan>
8000b520:	f9 e7 11 4b 	or	r11,r12,r7<<0x14
8000b524:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b528 <__avr32_f64_sub_return_nan>:
8000b528:	3f fa       	mov	r10,-1
8000b52a:	3f fb       	mov	r11,-1
8000b52c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b530 <__avr32_f64_sub_subnormal_result>:
8000b530:	5c 37       	neg	r7
8000b532:	2f f7       	sub	r7,-1
8000b534:	f1 b7 04 c0 	satu	r7,0x6
8000b538:	e0 47 00 20 	cp.w	r7,32
8000b53c:	c1 14       	brge	8000b55e <__avr32_f64_sub_subnormal_result+0x2e>
8000b53e:	ee 08 11 20 	rsub	r8,r7,32
8000b542:	f4 08 09 49 	lsl	r9,r10,r8
8000b546:	5f 16       	srne	r6
8000b548:	f4 07 0a 4a 	lsr	r10,r10,r7
8000b54c:	0c 4a       	or	r10,r6
8000b54e:	f6 08 09 49 	lsl	r9,r11,r8
8000b552:	f5 e9 10 0a 	or	r10,r10,r9
8000b556:	f4 07 0a 4b 	lsr	r11,r10,r7
8000b55a:	30 07       	mov	r7,0
8000b55c:	cb 3b       	rjmp	8000b4c2 <__avr32_f64_sub_longnormalize_done>
8000b55e:	ee 08 11 40 	rsub	r8,r7,64
8000b562:	f6 08 09 49 	lsl	r9,r11,r8
8000b566:	14 49       	or	r9,r10
8000b568:	5f 16       	srne	r6
8000b56a:	f6 07 0a 4a 	lsr	r10,r11,r7
8000b56e:	0c 4a       	or	r10,r6
8000b570:	30 0b       	mov	r11,0
8000b572:	30 07       	mov	r7,0
8000b574:	ca 7b       	rjmp	8000b4c2 <__avr32_f64_sub_longnormalize_done>
8000b576:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b57a <__avr32_f64_sub_longshift>:
8000b57a:	f1 b6 04 c0 	satu	r6,0x6
8000b57e:	f0 0e 17 00 	moveq	lr,r8
8000b582:	c0 40       	breq	8000b58a <__avr32_f64_sub_longshift+0x10>
8000b584:	f2 05 09 4e 	lsl	lr,r9,r5
8000b588:	10 4e       	or	lr,r8
8000b58a:	f2 06 0a 48 	lsr	r8,r9,r6
8000b58e:	30 09       	mov	r9,0
8000b590:	58 0e       	cp.w	lr,0
8000b592:	5f 1e       	srne	lr
8000b594:	1c 48       	or	r8,lr
8000b596:	c8 3b       	rjmp	8000b49c <__avr32_f64_sub_shift_done>

8000b598 <__avr32_f64_sub_longnormalize>:
8000b598:	f4 06 12 00 	clz	r6,r10
8000b59c:	f9 b7 03 00 	movlo	r7,0
8000b5a0:	f9 b6 03 00 	movlo	r6,0
8000b5a4:	f9 bc 03 00 	movlo	r12,0
8000b5a8:	f7 b6 02 e0 	subhs	r6,-32
8000b5ac:	f4 06 09 4b 	lsl	r11,r10,r6
8000b5b0:	30 0a       	mov	r10,0
8000b5b2:	0c 17       	sub	r7,r6
8000b5b4:	fe 9a ff be 	brle	8000b530 <__avr32_f64_sub_subnormal_result>
8000b5b8:	c8 5b       	rjmp	8000b4c2 <__avr32_f64_sub_longnormalize_done>
8000b5ba:	d7 03       	nop

8000b5bc <__avr32_f64_add_from_sub>:
8000b5bc:	ee 19 80 00 	eorh	r9,0x8000

8000b5c0 <__avr32_f64_add>:
8000b5c0:	f7 e9 20 0c 	eor	r12,r11,r9
8000b5c4:	fe 96 ff 2e 	brmi	8000b420 <__avr32_f64_sub_from_add>
8000b5c8:	eb cd 40 e0 	pushm	r5-r7,lr
8000b5cc:	16 9c       	mov	r12,r11
8000b5ce:	e6 1c 80 00 	andh	r12,0x8000,COH
8000b5d2:	bf db       	cbr	r11,0x1f
8000b5d4:	bf d9       	cbr	r9,0x1f
8000b5d6:	12 3b       	cp.w	r11,r9
8000b5d8:	c0 72       	brcc	8000b5e6 <__avr32_f64_add+0x26>
8000b5da:	16 97       	mov	r7,r11
8000b5dc:	12 9b       	mov	r11,r9
8000b5de:	0e 99       	mov	r9,r7
8000b5e0:	14 97       	mov	r7,r10
8000b5e2:	10 9a       	mov	r10,r8
8000b5e4:	0e 98       	mov	r8,r7
8000b5e6:	30 0e       	mov	lr,0
8000b5e8:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000b5ec:	f7 db c0 14 	bfextu	r11,r11,0x0,0x14
8000b5f0:	b5 ab       	sbr	r11,0x14
8000b5f2:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000b5f6:	c6 20       	breq	8000b6ba <__avr32_f64_add_op2_subnormal>
8000b5f8:	f3 d9 c0 14 	bfextu	r9,r9,0x0,0x14
8000b5fc:	b5 a9       	sbr	r9,0x14
8000b5fe:	e0 47 07 ff 	cp.w	r7,2047
8000b602:	c2 80       	breq	8000b652 <__avr32_f64_add_opH_nan_or_inf>
8000b604:	0e 26       	rsub	r6,r7
8000b606:	c1 20       	breq	8000b62a <__avr32_f64_add_shift_done>
8000b608:	e0 46 00 36 	cp.w	r6,54
8000b60c:	c1 52       	brcc	8000b636 <__avr32_f64_add_res_of_done>
8000b60e:	ec 05 11 20 	rsub	r5,r6,32
8000b612:	e0 46 00 20 	cp.w	r6,32
8000b616:	c3 52       	brcc	8000b680 <__avr32_f64_add_longshift>
8000b618:	f0 05 09 4e 	lsl	lr,r8,r5
8000b61c:	f2 05 09 45 	lsl	r5,r9,r5
8000b620:	f0 06 0a 48 	lsr	r8,r8,r6
8000b624:	f2 06 0a 49 	lsr	r9,r9,r6
8000b628:	0a 48       	or	r8,r5

8000b62a <__avr32_f64_add_shift_done>:
8000b62a:	10 0a       	add	r10,r8
8000b62c:	f6 09 00 4b 	adc	r11,r11,r9
8000b630:	ed bb 00 15 	bld	r11,0x15
8000b634:	c3 40       	breq	8000b69c <__avr32_f64_add_res_of>

8000b636 <__avr32_f64_add_res_of_done>:
8000b636:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000b63a:	18 4b       	or	r11,r12

8000b63c <__avr32_f64_add_round>:
8000b63c:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
8000b640:	18 4e       	or	lr,r12
8000b642:	ee 1e 80 00 	eorh	lr,0x8000
8000b646:	f1 be 04 20 	satu	lr,0x1
8000b64a:	1c 0a       	add	r10,lr
8000b64c:	5c 0b       	acr	r11
8000b64e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b652 <__avr32_f64_add_opH_nan_or_inf>:
8000b652:	b5 cb       	cbr	r11,0x14
8000b654:	f7 ea 10 0e 	or	lr,r11,r10
8000b658:	c1 01       	brne	8000b678 <__avr32_f64_add_return_nan>
8000b65a:	e0 46 07 ff 	cp.w	r6,2047
8000b65e:	c0 30       	breq	8000b664 <__avr32_f64_add_opL_nan_or_inf>
8000b660:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b664 <__avr32_f64_add_opL_nan_or_inf>:
8000b664:	b5 c9       	cbr	r9,0x14
8000b666:	f3 e8 10 0e 	or	lr,r9,r8
8000b66a:	c0 71       	brne	8000b678 <__avr32_f64_add_return_nan>
8000b66c:	30 0a       	mov	r10,0
8000b66e:	fc 1b 7f f0 	movh	r11,0x7ff0
8000b672:	18 4b       	or	r11,r12
8000b674:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b678 <__avr32_f64_add_return_nan>:
8000b678:	3f fa       	mov	r10,-1
8000b67a:	3f fb       	mov	r11,-1
8000b67c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b680 <__avr32_f64_add_longshift>:
8000b680:	f1 b6 04 c0 	satu	r6,0x6
8000b684:	f0 0e 17 00 	moveq	lr,r8
8000b688:	c0 60       	breq	8000b694 <__avr32_f64_add_longshift+0x14>
8000b68a:	f2 05 09 4e 	lsl	lr,r9,r5
8000b68e:	58 08       	cp.w	r8,0
8000b690:	5f 18       	srne	r8
8000b692:	10 4e       	or	lr,r8
8000b694:	f2 06 0a 48 	lsr	r8,r9,r6
8000b698:	30 09       	mov	r9,0
8000b69a:	cc 8b       	rjmp	8000b62a <__avr32_f64_add_shift_done>

8000b69c <__avr32_f64_add_res_of>:
8000b69c:	fd ee 10 1e 	or	lr,lr,lr<<0x1
8000b6a0:	a1 9b       	lsr	r11,0x1
8000b6a2:	5d 0a       	ror	r10
8000b6a4:	5d 0e       	ror	lr
8000b6a6:	2f f7       	sub	r7,-1
8000b6a8:	e0 47 07 ff 	cp.w	r7,2047
8000b6ac:	f9 ba 00 00 	moveq	r10,0
8000b6b0:	f9 bb 00 00 	moveq	r11,0
8000b6b4:	f9 be 00 00 	moveq	lr,0
8000b6b8:	cb fb       	rjmp	8000b636 <__avr32_f64_add_res_of_done>

8000b6ba <__avr32_f64_add_op2_subnormal>:
8000b6ba:	30 16       	mov	r6,1
8000b6bc:	58 07       	cp.w	r7,0
8000b6be:	ca 01       	brne	8000b5fe <__avr32_f64_add+0x3e>
8000b6c0:	b5 cb       	cbr	r11,0x14
8000b6c2:	10 0a       	add	r10,r8
8000b6c4:	f6 09 00 4b 	adc	r11,r11,r9
8000b6c8:	18 4b       	or	r11,r12
8000b6ca:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000b6ce:	d7 03       	nop

8000b6d0 <__avr32_f64_to_u32>:
8000b6d0:	58 0b       	cp.w	r11,0
8000b6d2:	5e 6d       	retmi	0

8000b6d4 <__avr32_f64_to_s32>:
8000b6d4:	f6 0c 15 01 	lsl	r12,r11,0x1
8000b6d8:	b5 9c       	lsr	r12,0x15
8000b6da:	e0 2c 03 ff 	sub	r12,1023
8000b6de:	5e 3d       	retlo	0
8000b6e0:	f8 0c 11 1f 	rsub	r12,r12,31
8000b6e4:	16 99       	mov	r9,r11
8000b6e6:	ab 7b       	lsl	r11,0xb
8000b6e8:	bf bb       	sbr	r11,0x1f
8000b6ea:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000b6ee:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000b6f2:	a1 79       	lsl	r9,0x1
8000b6f4:	5e 2b       	reths	r11
8000b6f6:	5c 3b       	neg	r11
8000b6f8:	5e fb       	retal	r11

8000b6fa <__avr32_u32_to_f64>:
8000b6fa:	f8 cb 00 00 	sub	r11,r12,0
8000b6fe:	30 0c       	mov	r12,0
8000b700:	c0 38       	rjmp	8000b706 <__avr32_s32_to_f64+0x4>

8000b702 <__avr32_s32_to_f64>:
8000b702:	18 9b       	mov	r11,r12
8000b704:	5c 4b       	abs	r11
8000b706:	30 0a       	mov	r10,0
8000b708:	5e 0b       	reteq	r11
8000b70a:	d4 01       	pushm	lr
8000b70c:	e0 69 04 1e 	mov	r9,1054
8000b710:	f6 08 12 00 	clz	r8,r11
8000b714:	c1 70       	breq	8000b742 <__avr32_s32_to_f64+0x40>
8000b716:	c0 c3       	brcs	8000b72e <__avr32_s32_to_f64+0x2c>
8000b718:	f0 0e 11 20 	rsub	lr,r8,32
8000b71c:	f6 08 09 4b 	lsl	r11,r11,r8
8000b720:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000b724:	1c 4b       	or	r11,lr
8000b726:	f4 08 09 4a 	lsl	r10,r10,r8
8000b72a:	10 19       	sub	r9,r8
8000b72c:	c0 b8       	rjmp	8000b742 <__avr32_s32_to_f64+0x40>
8000b72e:	f4 08 12 00 	clz	r8,r10
8000b732:	f9 b8 03 00 	movlo	r8,0
8000b736:	f7 b8 02 e0 	subhs	r8,-32
8000b73a:	f4 08 09 4b 	lsl	r11,r10,r8
8000b73e:	30 0a       	mov	r10,0
8000b740:	10 19       	sub	r9,r8
8000b742:	58 09       	cp.w	r9,0
8000b744:	e0 89 00 30 	brgt	8000b7a4 <__avr32_s32_to_f64+0xa2>
8000b748:	5c 39       	neg	r9
8000b74a:	2f f9       	sub	r9,-1
8000b74c:	e0 49 00 36 	cp.w	r9,54
8000b750:	c0 43       	brcs	8000b758 <__avr32_s32_to_f64+0x56>
8000b752:	30 0b       	mov	r11,0
8000b754:	30 0a       	mov	r10,0
8000b756:	c2 68       	rjmp	8000b7a2 <__avr32_s32_to_f64+0xa0>
8000b758:	2f 69       	sub	r9,-10
8000b75a:	f2 08 11 20 	rsub	r8,r9,32
8000b75e:	e0 49 00 20 	cp.w	r9,32
8000b762:	c0 b2       	brcc	8000b778 <__avr32_s32_to_f64+0x76>
8000b764:	f4 08 09 4e 	lsl	lr,r10,r8
8000b768:	f6 08 09 48 	lsl	r8,r11,r8
8000b76c:	f4 09 0a 4a 	lsr	r10,r10,r9
8000b770:	f6 09 0a 4b 	lsr	r11,r11,r9
8000b774:	10 4b       	or	r11,r8
8000b776:	c0 88       	rjmp	8000b786 <__avr32_s32_to_f64+0x84>
8000b778:	f6 08 09 4e 	lsl	lr,r11,r8
8000b77c:	14 4e       	or	lr,r10
8000b77e:	16 9a       	mov	r10,r11
8000b780:	30 0b       	mov	r11,0
8000b782:	f4 09 0a 4a 	lsr	r10,r10,r9
8000b786:	ed ba 00 00 	bld	r10,0x0
8000b78a:	c0 92       	brcc	8000b79c <__avr32_s32_to_f64+0x9a>
8000b78c:	1c 7e       	tst	lr,lr
8000b78e:	c0 41       	brne	8000b796 <__avr32_s32_to_f64+0x94>
8000b790:	ed ba 00 01 	bld	r10,0x1
8000b794:	c0 42       	brcc	8000b79c <__avr32_s32_to_f64+0x9a>
8000b796:	2f fa       	sub	r10,-1
8000b798:	f7 bb 02 ff 	subhs	r11,-1
8000b79c:	5c fc       	rol	r12
8000b79e:	5d 0b       	ror	r11
8000b7a0:	5d 0a       	ror	r10
8000b7a2:	d8 02       	popm	pc
8000b7a4:	e0 68 03 ff 	mov	r8,1023
8000b7a8:	ed ba 00 0b 	bld	r10,0xb
8000b7ac:	f7 b8 00 ff 	subeq	r8,-1
8000b7b0:	10 0a       	add	r10,r8
8000b7b2:	5c 0b       	acr	r11
8000b7b4:	f7 b9 03 fe 	sublo	r9,-2
8000b7b8:	e0 49 07 ff 	cp.w	r9,2047
8000b7bc:	c0 55       	brlt	8000b7c6 <__avr32_s32_to_f64+0xc4>
8000b7be:	30 0a       	mov	r10,0
8000b7c0:	fc 1b ff e0 	movh	r11,0xffe0
8000b7c4:	c0 c8       	rjmp	8000b7dc <__floatsidf_return_op1>
8000b7c6:	ed bb 00 1f 	bld	r11,0x1f
8000b7ca:	f7 b9 01 01 	subne	r9,1
8000b7ce:	ab 9a       	lsr	r10,0xb
8000b7d0:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000b7d4:	a1 7b       	lsl	r11,0x1
8000b7d6:	ab 9b       	lsr	r11,0xb
8000b7d8:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

8000b7dc <__floatsidf_return_op1>:
8000b7dc:	a1 7c       	lsl	r12,0x1
8000b7de:	5d 0b       	ror	r11
8000b7e0:	d8 02       	popm	pc

8000b7e2 <__avr32_f64_cmp_eq>:
8000b7e2:	10 3a       	cp.w	r10,r8
8000b7e4:	f2 0b 13 00 	cpc	r11,r9
8000b7e8:	c0 80       	breq	8000b7f8 <__avr32_f64_cmp_eq+0x16>
8000b7ea:	a1 7b       	lsl	r11,0x1
8000b7ec:	a1 79       	lsl	r9,0x1
8000b7ee:	14 4b       	or	r11,r10
8000b7f0:	12 4b       	or	r11,r9
8000b7f2:	10 4b       	or	r11,r8
8000b7f4:	5e 0f       	reteq	1
8000b7f6:	5e fd       	retal	0
8000b7f8:	a1 7b       	lsl	r11,0x1
8000b7fa:	fc 1c ff e0 	movh	r12,0xffe0
8000b7fe:	58 0a       	cp.w	r10,0
8000b800:	f8 0b 13 00 	cpc	r11,r12
8000b804:	5e 8f       	retls	1
8000b806:	5e fd       	retal	0

8000b808 <__avr32_f64_cmp_ge>:
8000b808:	1a de       	st.w	--sp,lr
8000b80a:	1a d7       	st.w	--sp,r7
8000b80c:	a1 7b       	lsl	r11,0x1
8000b80e:	5f 3c       	srlo	r12
8000b810:	a1 79       	lsl	r9,0x1
8000b812:	5f 37       	srlo	r7
8000b814:	5c fc       	rol	r12
8000b816:	fc 1e ff e0 	movh	lr,0xffe0
8000b81a:	58 0a       	cp.w	r10,0
8000b81c:	fc 0b 13 00 	cpc	r11,lr
8000b820:	e0 8b 00 1d 	brhi	8000b85a <__avr32_f64_cmp_ge+0x52>
8000b824:	58 08       	cp.w	r8,0
8000b826:	fc 09 13 00 	cpc	r9,lr
8000b82a:	e0 8b 00 18 	brhi	8000b85a <__avr32_f64_cmp_ge+0x52>
8000b82e:	58 0b       	cp.w	r11,0
8000b830:	f5 ba 00 00 	subfeq	r10,0
8000b834:	c1 50       	breq	8000b85e <__avr32_f64_cmp_ge+0x56>
8000b836:	1b 07       	ld.w	r7,sp++
8000b838:	1b 0e       	ld.w	lr,sp++
8000b83a:	58 3c       	cp.w	r12,3
8000b83c:	c0 a0       	breq	8000b850 <__avr32_f64_cmp_ge+0x48>
8000b83e:	58 1c       	cp.w	r12,1
8000b840:	c0 33       	brcs	8000b846 <__avr32_f64_cmp_ge+0x3e>
8000b842:	5e 0f       	reteq	1
8000b844:	5e 1d       	retne	0
8000b846:	10 3a       	cp.w	r10,r8
8000b848:	f2 0b 13 00 	cpc	r11,r9
8000b84c:	5e 2f       	reths	1
8000b84e:	5e 3d       	retlo	0
8000b850:	14 38       	cp.w	r8,r10
8000b852:	f6 09 13 00 	cpc	r9,r11
8000b856:	5e 2f       	reths	1
8000b858:	5e 3d       	retlo	0
8000b85a:	1b 07       	ld.w	r7,sp++
8000b85c:	d8 0a       	popm	pc,r12=0
8000b85e:	58 17       	cp.w	r7,1
8000b860:	5f 0c       	sreq	r12
8000b862:	58 09       	cp.w	r9,0
8000b864:	f5 b8 00 00 	subfeq	r8,0
8000b868:	1b 07       	ld.w	r7,sp++
8000b86a:	1b 0e       	ld.w	lr,sp++
8000b86c:	5e 0f       	reteq	1
8000b86e:	5e fc       	retal	r12

8000b870 <__avr32_f64_cmp_lt>:
8000b870:	1a de       	st.w	--sp,lr
8000b872:	1a d7       	st.w	--sp,r7
8000b874:	a1 7b       	lsl	r11,0x1
8000b876:	5f 3c       	srlo	r12
8000b878:	a1 79       	lsl	r9,0x1
8000b87a:	5f 37       	srlo	r7
8000b87c:	5c fc       	rol	r12
8000b87e:	fc 1e ff e0 	movh	lr,0xffe0
8000b882:	58 0a       	cp.w	r10,0
8000b884:	fc 0b 13 00 	cpc	r11,lr
8000b888:	e0 8b 00 1d 	brhi	8000b8c2 <__avr32_f64_cmp_lt+0x52>
8000b88c:	58 08       	cp.w	r8,0
8000b88e:	fc 09 13 00 	cpc	r9,lr
8000b892:	e0 8b 00 18 	brhi	8000b8c2 <__avr32_f64_cmp_lt+0x52>
8000b896:	58 0b       	cp.w	r11,0
8000b898:	f5 ba 00 00 	subfeq	r10,0
8000b89c:	c1 50       	breq	8000b8c6 <__avr32_f64_cmp_lt+0x56>
8000b89e:	1b 07       	ld.w	r7,sp++
8000b8a0:	1b 0e       	ld.w	lr,sp++
8000b8a2:	58 3c       	cp.w	r12,3
8000b8a4:	c0 a0       	breq	8000b8b8 <__avr32_f64_cmp_lt+0x48>
8000b8a6:	58 1c       	cp.w	r12,1
8000b8a8:	c0 33       	brcs	8000b8ae <__avr32_f64_cmp_lt+0x3e>
8000b8aa:	5e 0d       	reteq	0
8000b8ac:	5e 1f       	retne	1
8000b8ae:	10 3a       	cp.w	r10,r8
8000b8b0:	f2 0b 13 00 	cpc	r11,r9
8000b8b4:	5e 2d       	reths	0
8000b8b6:	5e 3f       	retlo	1
8000b8b8:	14 38       	cp.w	r8,r10
8000b8ba:	f6 09 13 00 	cpc	r9,r11
8000b8be:	5e 2d       	reths	0
8000b8c0:	5e 3f       	retlo	1
8000b8c2:	1b 07       	ld.w	r7,sp++
8000b8c4:	d8 0a       	popm	pc,r12=0
8000b8c6:	58 17       	cp.w	r7,1
8000b8c8:	5f 1c       	srne	r12
8000b8ca:	58 09       	cp.w	r9,0
8000b8cc:	f5 b8 00 00 	subfeq	r8,0
8000b8d0:	1b 07       	ld.w	r7,sp++
8000b8d2:	1b 0e       	ld.w	lr,sp++
8000b8d4:	5e 0d       	reteq	0
8000b8d6:	5e fc       	retal	r12

8000b8d8 <__avr32_f64_div>:
8000b8d8:	eb cd 40 ff 	pushm	r0-r7,lr
8000b8dc:	f7 e9 20 0e 	eor	lr,r11,r9
8000b8e0:	f6 07 16 14 	lsr	r7,r11,0x14
8000b8e4:	a9 7b       	lsl	r11,0x9
8000b8e6:	f7 ea 13 7b 	or	r11,r11,r10>>0x17
8000b8ea:	a9 7a       	lsl	r10,0x9
8000b8ec:	bd bb       	sbr	r11,0x1d
8000b8ee:	e4 1b 3f ff 	andh	r11,0x3fff
8000b8f2:	ab d7       	cbr	r7,0xb
8000b8f4:	e0 80 00 cc 	breq	8000ba8c <__avr32_f64_div_round_subnormal+0x54>
8000b8f8:	e0 47 07 ff 	cp.w	r7,2047
8000b8fc:	e0 84 00 b5 	brge	8000ba66 <__avr32_f64_div_round_subnormal+0x2e>
8000b900:	f2 06 16 14 	lsr	r6,r9,0x14
8000b904:	a9 79       	lsl	r9,0x9
8000b906:	f3 e8 13 79 	or	r9,r9,r8>>0x17
8000b90a:	a9 78       	lsl	r8,0x9
8000b90c:	bd b9       	sbr	r9,0x1d
8000b90e:	e4 19 3f ff 	andh	r9,0x3fff
8000b912:	ab d6       	cbr	r6,0xb
8000b914:	e0 80 00 e2 	breq	8000bad8 <__avr32_f64_div_round_subnormal+0xa0>
8000b918:	e0 46 07 ff 	cp.w	r6,2047
8000b91c:	e0 84 00 b2 	brge	8000ba80 <__avr32_f64_div_round_subnormal+0x48>
8000b920:	0c 17       	sub	r7,r6
8000b922:	fe 37 fc 01 	sub	r7,-1023
8000b926:	fc 1c 80 00 	movh	r12,0x8000
8000b92a:	f8 03 16 01 	lsr	r3,r12,0x1
8000b92e:	e9 d9 c3 62 	bfextu	r4,r9,0x1b,0x2
8000b932:	5c d4       	com	r4
8000b934:	e7 d4 d3 82 	bfins	r3,r4,0x1c,0x2
8000b938:	e6 09 06 44 	mulu.d	r4,r3,r9
8000b93c:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000b940:	e6 05 06 44 	mulu.d	r4,r3,r5
8000b944:	ea 03 15 02 	lsl	r3,r5,0x2
8000b948:	e6 09 06 44 	mulu.d	r4,r3,r9
8000b94c:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000b950:	e6 05 06 44 	mulu.d	r4,r3,r5
8000b954:	ea 03 15 02 	lsl	r3,r5,0x2
8000b958:	e6 09 06 44 	mulu.d	r4,r3,r9
8000b95c:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000b960:	e6 05 06 44 	mulu.d	r4,r3,r5
8000b964:	ea 03 15 02 	lsl	r3,r5,0x2
8000b968:	e6 08 06 40 	mulu.d	r0,r3,r8
8000b96c:	e4 09 07 40 	macu.d	r0,r2,r9
8000b970:	e6 09 06 44 	mulu.d	r4,r3,r9
8000b974:	02 04       	add	r4,r1
8000b976:	5c 05       	acr	r5
8000b978:	a3 65       	lsl	r5,0x2
8000b97a:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000b97e:	a3 64       	lsl	r4,0x2
8000b980:	5c 34       	neg	r4
8000b982:	f8 05 01 45 	sbc	r5,r12,r5
8000b986:	e6 04 06 40 	mulu.d	r0,r3,r4
8000b98a:	e4 05 07 40 	macu.d	r0,r2,r5
8000b98e:	e6 05 06 44 	mulu.d	r4,r3,r5
8000b992:	02 04       	add	r4,r1
8000b994:	5c 05       	acr	r5
8000b996:	ea 03 15 02 	lsl	r3,r5,0x2
8000b99a:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000b99e:	e8 02 15 02 	lsl	r2,r4,0x2
8000b9a2:	e6 08 06 40 	mulu.d	r0,r3,r8
8000b9a6:	e4 09 07 40 	macu.d	r0,r2,r9
8000b9aa:	e6 09 06 44 	mulu.d	r4,r3,r9
8000b9ae:	02 04       	add	r4,r1
8000b9b0:	5c 05       	acr	r5
8000b9b2:	a3 65       	lsl	r5,0x2
8000b9b4:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000b9b8:	a3 64       	lsl	r4,0x2
8000b9ba:	5c 34       	neg	r4
8000b9bc:	f8 05 01 45 	sbc	r5,r12,r5
8000b9c0:	e6 04 06 40 	mulu.d	r0,r3,r4
8000b9c4:	e4 05 07 40 	macu.d	r0,r2,r5
8000b9c8:	e6 05 06 44 	mulu.d	r4,r3,r5
8000b9cc:	02 04       	add	r4,r1
8000b9ce:	5c 05       	acr	r5
8000b9d0:	ea 03 15 02 	lsl	r3,r5,0x2
8000b9d4:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000b9d8:	e8 02 15 02 	lsl	r2,r4,0x2
8000b9dc:	e6 0a 06 40 	mulu.d	r0,r3,r10
8000b9e0:	e4 0b 07 40 	macu.d	r0,r2,r11
8000b9e4:	e6 0b 06 42 	mulu.d	r2,r3,r11
8000b9e8:	02 02       	add	r2,r1
8000b9ea:	5c 03       	acr	r3
8000b9ec:	ed b3 00 1c 	bld	r3,0x1c
8000b9f0:	c0 90       	breq	8000ba02 <__avr32_f64_div+0x12a>
8000b9f2:	a1 72       	lsl	r2,0x1
8000b9f4:	5c f3       	rol	r3
8000b9f6:	20 17       	sub	r7,1
8000b9f8:	a3 9a       	lsr	r10,0x3
8000b9fa:	f5 eb 11 da 	or	r10,r10,r11<<0x1d
8000b9fe:	a3 9b       	lsr	r11,0x3
8000ba00:	c0 58       	rjmp	8000ba0a <__avr32_f64_div+0x132>
8000ba02:	a5 8a       	lsr	r10,0x4
8000ba04:	f5 eb 11 ca 	or	r10,r10,r11<<0x1c
8000ba08:	a5 8b       	lsr	r11,0x4
8000ba0a:	58 07       	cp.w	r7,0
8000ba0c:	e0 8a 00 8b 	brle	8000bb22 <__avr32_f64_div_res_subnormal>
8000ba10:	e0 12 ff 00 	andl	r2,0xff00
8000ba14:	e8 12 00 80 	orl	r2,0x80
8000ba18:	e6 08 06 40 	mulu.d	r0,r3,r8
8000ba1c:	e4 09 07 40 	macu.d	r0,r2,r9
8000ba20:	e4 08 06 44 	mulu.d	r4,r2,r8
8000ba24:	e6 09 06 48 	mulu.d	r8,r3,r9
8000ba28:	00 05       	add	r5,r0
8000ba2a:	f0 01 00 48 	adc	r8,r8,r1
8000ba2e:	5c 09       	acr	r9
8000ba30:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000ba34:	58 04       	cp.w	r4,0
8000ba36:	5c 25       	cpc	r5

8000ba38 <__avr32_f64_div_round_subnormal>:
8000ba38:	f4 08 13 00 	cpc	r8,r10
8000ba3c:	f6 09 13 00 	cpc	r9,r11
8000ba40:	5f 36       	srlo	r6
8000ba42:	f8 06 17 00 	moveq	r6,r12
8000ba46:	e4 0a 16 08 	lsr	r10,r2,0x8
8000ba4a:	f5 e3 11 8a 	or	r10,r10,r3<<0x18
8000ba4e:	e6 0b 16 08 	lsr	r11,r3,0x8
8000ba52:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000ba56:	ed be 00 1f 	bld	lr,0x1f
8000ba5a:	ef bb 00 1f 	bst	r11,0x1f
8000ba5e:	0c 0a       	add	r10,r6
8000ba60:	5c 0b       	acr	r11
8000ba62:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000ba66:	e4 1b 00 0f 	andh	r11,0xf
8000ba6a:	14 4b       	or	r11,r10
8000ba6c:	e0 81 00 a7 	brne	8000bbba <__avr32_f64_div_res_subnormal+0x98>
8000ba70:	f2 06 16 14 	lsr	r6,r9,0x14
8000ba74:	ab d6       	cbr	r6,0xb
8000ba76:	e0 46 07 ff 	cp.w	r6,2047
8000ba7a:	e0 81 00 a4 	brne	8000bbc2 <__avr32_f64_div_res_subnormal+0xa0>
8000ba7e:	c9 e8       	rjmp	8000bbba <__avr32_f64_div_res_subnormal+0x98>
8000ba80:	e4 19 00 0f 	andh	r9,0xf
8000ba84:	10 49       	or	r9,r8
8000ba86:	e0 81 00 9a 	brne	8000bbba <__avr32_f64_div_res_subnormal+0x98>
8000ba8a:	c9 28       	rjmp	8000bbae <__avr32_f64_div_res_subnormal+0x8c>
8000ba8c:	a3 7b       	lsl	r11,0x3
8000ba8e:	f7 ea 13 db 	or	r11,r11,r10>>0x1d
8000ba92:	a3 7a       	lsl	r10,0x3
8000ba94:	f5 eb 10 04 	or	r4,r10,r11
8000ba98:	e0 80 00 a0 	breq	8000bbd8 <__avr32_f64_div_op1_zero>
8000ba9c:	f6 04 12 00 	clz	r4,r11
8000baa0:	c1 70       	breq	8000bace <__avr32_f64_div_round_subnormal+0x96>
8000baa2:	c0 c3       	brcs	8000baba <__avr32_f64_div_round_subnormal+0x82>
8000baa4:	e8 05 11 20 	rsub	r5,r4,32
8000baa8:	f6 04 09 4b 	lsl	r11,r11,r4
8000baac:	f4 05 0a 45 	lsr	r5,r10,r5
8000bab0:	0a 4b       	or	r11,r5
8000bab2:	f4 04 09 4a 	lsl	r10,r10,r4
8000bab6:	08 17       	sub	r7,r4
8000bab8:	c0 b8       	rjmp	8000bace <__avr32_f64_div_round_subnormal+0x96>
8000baba:	f4 04 12 00 	clz	r4,r10
8000babe:	f9 b4 03 00 	movlo	r4,0
8000bac2:	f7 b4 02 e0 	subhs	r4,-32
8000bac6:	f4 04 09 4b 	lsl	r11,r10,r4
8000baca:	30 0a       	mov	r10,0
8000bacc:	08 17       	sub	r7,r4
8000bace:	a3 8a       	lsr	r10,0x2
8000bad0:	f5 eb 11 ea 	or	r10,r10,r11<<0x1e
8000bad4:	a3 8b       	lsr	r11,0x2
8000bad6:	c1 1b       	rjmp	8000b8f8 <__avr32_f64_div+0x20>
8000bad8:	a3 79       	lsl	r9,0x3
8000bada:	f3 e8 13 d9 	or	r9,r9,r8>>0x1d
8000bade:	a3 78       	lsl	r8,0x3
8000bae0:	f3 e8 10 04 	or	r4,r9,r8
8000bae4:	c6 f0       	breq	8000bbc2 <__avr32_f64_div_res_subnormal+0xa0>
8000bae6:	f2 04 12 00 	clz	r4,r9
8000baea:	c1 70       	breq	8000bb18 <__avr32_f64_div_round_subnormal+0xe0>
8000baec:	c0 c3       	brcs	8000bb04 <__avr32_f64_div_round_subnormal+0xcc>
8000baee:	e8 05 11 20 	rsub	r5,r4,32
8000baf2:	f2 04 09 49 	lsl	r9,r9,r4
8000baf6:	f0 05 0a 45 	lsr	r5,r8,r5
8000bafa:	0a 49       	or	r9,r5
8000bafc:	f0 04 09 48 	lsl	r8,r8,r4
8000bb00:	08 16       	sub	r6,r4
8000bb02:	c0 b8       	rjmp	8000bb18 <__avr32_f64_div_round_subnormal+0xe0>
8000bb04:	f0 04 12 00 	clz	r4,r8
8000bb08:	f9 b4 03 00 	movlo	r4,0
8000bb0c:	f7 b4 02 e0 	subhs	r4,-32
8000bb10:	f0 04 09 49 	lsl	r9,r8,r4
8000bb14:	30 08       	mov	r8,0
8000bb16:	08 16       	sub	r6,r4
8000bb18:	a3 88       	lsr	r8,0x2
8000bb1a:	f1 e9 11 e8 	or	r8,r8,r9<<0x1e
8000bb1e:	a3 89       	lsr	r9,0x2
8000bb20:	cf ca       	rjmp	8000b918 <__avr32_f64_div+0x40>

8000bb22 <__avr32_f64_div_res_subnormal>:
8000bb22:	5c 37       	neg	r7
8000bb24:	2f f7       	sub	r7,-1
8000bb26:	f1 b7 04 c0 	satu	r7,0x6
8000bb2a:	e0 47 00 20 	cp.w	r7,32
8000bb2e:	c1 54       	brge	8000bb58 <__avr32_f64_div_res_subnormal+0x36>
8000bb30:	ee 06 11 20 	rsub	r6,r7,32
8000bb34:	e4 07 0a 42 	lsr	r2,r2,r7
8000bb38:	e6 06 09 4c 	lsl	r12,r3,r6
8000bb3c:	18 42       	or	r2,r12
8000bb3e:	e6 07 0a 43 	lsr	r3,r3,r7
8000bb42:	f4 06 09 41 	lsl	r1,r10,r6
8000bb46:	f4 07 0a 4a 	lsr	r10,r10,r7
8000bb4a:	f6 06 09 4c 	lsl	r12,r11,r6
8000bb4e:	18 4a       	or	r10,r12
8000bb50:	f6 07 0a 4b 	lsr	r11,r11,r7
8000bb54:	30 00       	mov	r0,0
8000bb56:	c1 58       	rjmp	8000bb80 <__avr32_f64_div_res_subnormal+0x5e>
8000bb58:	ee 06 11 20 	rsub	r6,r7,32
8000bb5c:	f9 b0 00 00 	moveq	r0,0
8000bb60:	f9 bc 00 00 	moveq	r12,0
8000bb64:	c0 50       	breq	8000bb6e <__avr32_f64_div_res_subnormal+0x4c>
8000bb66:	f4 06 09 40 	lsl	r0,r10,r6
8000bb6a:	f6 06 09 4c 	lsl	r12,r11,r6
8000bb6e:	e6 07 0a 42 	lsr	r2,r3,r7
8000bb72:	30 03       	mov	r3,0
8000bb74:	f4 07 0a 41 	lsr	r1,r10,r7
8000bb78:	18 41       	or	r1,r12
8000bb7a:	f6 07 0a 4a 	lsr	r10,r11,r7
8000bb7e:	30 0b       	mov	r11,0
8000bb80:	e0 12 ff 00 	andl	r2,0xff00
8000bb84:	e8 12 00 80 	orl	r2,0x80
8000bb88:	e6 08 06 46 	mulu.d	r6,r3,r8
8000bb8c:	e4 09 07 46 	macu.d	r6,r2,r9
8000bb90:	e4 08 06 44 	mulu.d	r4,r2,r8
8000bb94:	e6 09 06 48 	mulu.d	r8,r3,r9
8000bb98:	0c 05       	add	r5,r6
8000bb9a:	f0 07 00 48 	adc	r8,r8,r7
8000bb9e:	5c 09       	acr	r9
8000bba0:	30 07       	mov	r7,0
8000bba2:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000bba6:	00 34       	cp.w	r4,r0
8000bba8:	e2 05 13 00 	cpc	r5,r1
8000bbac:	c4 6b       	rjmp	8000ba38 <__avr32_f64_div_round_subnormal>
8000bbae:	1c 9b       	mov	r11,lr
8000bbb0:	e6 1b 80 00 	andh	r11,0x8000,COH
8000bbb4:	30 0a       	mov	r10,0
8000bbb6:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000bbba:	3f fb       	mov	r11,-1
8000bbbc:	30 0a       	mov	r10,0
8000bbbe:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000bbc2:	f5 eb 10 04 	or	r4,r10,r11
8000bbc6:	c0 90       	breq	8000bbd8 <__avr32_f64_div_op1_zero>
8000bbc8:	1c 9b       	mov	r11,lr
8000bbca:	e6 1b 80 00 	andh	r11,0x8000,COH
8000bbce:	ea 1b 7f f0 	orh	r11,0x7ff0
8000bbd2:	30 0a       	mov	r10,0
8000bbd4:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc

8000bbd8 <__avr32_f64_div_op1_zero>:
8000bbd8:	f1 e9 10 15 	or	r5,r8,r9<<0x1
8000bbdc:	ce f0       	breq	8000bbba <__avr32_f64_div_res_subnormal+0x98>
8000bbde:	e9 d9 c2 8b 	bfextu	r4,r9,0x14,0xb
8000bbe2:	e0 44 07 ff 	cp.w	r4,2047
8000bbe6:	ce 41       	brne	8000bbae <__avr32_f64_div_res_subnormal+0x8c>
8000bbe8:	f1 e9 10 c5 	or	r5,r8,r9<<0xc
8000bbec:	ce 10       	breq	8000bbae <__avr32_f64_div_res_subnormal+0x8c>
8000bbee:	ce 6b       	rjmp	8000bbba <__avr32_f64_div_res_subnormal+0x98>

8000bbf0 <__avr32_udiv64>:
8000bbf0:	d4 31       	pushm	r0-r7,lr
8000bbf2:	1a 97       	mov	r7,sp
8000bbf4:	20 3d       	sub	sp,12
8000bbf6:	10 9c       	mov	r12,r8
8000bbf8:	12 9e       	mov	lr,r9
8000bbfa:	14 93       	mov	r3,r10
8000bbfc:	58 09       	cp.w	r9,0
8000bbfe:	e0 81 00 bd 	brne	8000bd78 <__avr32_udiv64+0x188>
8000bc02:	16 38       	cp.w	r8,r11
8000bc04:	e0 88 00 40 	brls	8000bc84 <__avr32_udiv64+0x94>
8000bc08:	f0 08 12 00 	clz	r8,r8
8000bc0c:	c0 d0       	breq	8000bc26 <__avr32_udiv64+0x36>
8000bc0e:	f6 08 09 4b 	lsl	r11,r11,r8
8000bc12:	f0 09 11 20 	rsub	r9,r8,32
8000bc16:	f8 08 09 4c 	lsl	r12,r12,r8
8000bc1a:	f4 09 0a 49 	lsr	r9,r10,r9
8000bc1e:	f4 08 09 43 	lsl	r3,r10,r8
8000bc22:	f3 eb 10 0b 	or	r11,r9,r11
8000bc26:	f8 0e 16 10 	lsr	lr,r12,0x10
8000bc2a:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000bc2e:	f6 0e 0d 00 	divu	r0,r11,lr
8000bc32:	e6 0b 16 10 	lsr	r11,r3,0x10
8000bc36:	00 99       	mov	r9,r0
8000bc38:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000bc3c:	e0 0a 02 48 	mul	r8,r0,r10
8000bc40:	10 3b       	cp.w	r11,r8
8000bc42:	c0 a2       	brcc	8000bc56 <__avr32_udiv64+0x66>
8000bc44:	20 19       	sub	r9,1
8000bc46:	18 0b       	add	r11,r12
8000bc48:	18 3b       	cp.w	r11,r12
8000bc4a:	c0 63       	brcs	8000bc56 <__avr32_udiv64+0x66>
8000bc4c:	10 3b       	cp.w	r11,r8
8000bc4e:	f7 b9 03 01 	sublo	r9,1
8000bc52:	f7 dc e3 0b 	addcs	r11,r11,r12
8000bc56:	f6 08 01 01 	sub	r1,r11,r8
8000bc5a:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000bc5e:	e2 0e 0d 00 	divu	r0,r1,lr
8000bc62:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000bc66:	00 98       	mov	r8,r0
8000bc68:	e0 0a 02 4a 	mul	r10,r0,r10
8000bc6c:	14 33       	cp.w	r3,r10
8000bc6e:	c0 82       	brcc	8000bc7e <__avr32_udiv64+0x8e>
8000bc70:	20 18       	sub	r8,1
8000bc72:	18 03       	add	r3,r12
8000bc74:	18 33       	cp.w	r3,r12
8000bc76:	c0 43       	brcs	8000bc7e <__avr32_udiv64+0x8e>
8000bc78:	14 33       	cp.w	r3,r10
8000bc7a:	f7 b8 03 01 	sublo	r8,1
8000bc7e:	f1 e9 11 08 	or	r8,r8,r9<<0x10
8000bc82:	cd f8       	rjmp	8000be40 <__avr32_udiv64+0x250>
8000bc84:	58 08       	cp.w	r8,0
8000bc86:	c0 51       	brne	8000bc90 <__avr32_udiv64+0xa0>
8000bc88:	30 19       	mov	r9,1
8000bc8a:	f2 08 0d 08 	divu	r8,r9,r8
8000bc8e:	10 9c       	mov	r12,r8
8000bc90:	f8 06 12 00 	clz	r6,r12
8000bc94:	c0 41       	brne	8000bc9c <__avr32_udiv64+0xac>
8000bc96:	18 1b       	sub	r11,r12
8000bc98:	30 19       	mov	r9,1
8000bc9a:	c4 08       	rjmp	8000bd1a <__avr32_udiv64+0x12a>
8000bc9c:	ec 01 11 20 	rsub	r1,r6,32
8000bca0:	f4 01 0a 49 	lsr	r9,r10,r1
8000bca4:	f8 06 09 4c 	lsl	r12,r12,r6
8000bca8:	f6 06 09 48 	lsl	r8,r11,r6
8000bcac:	f6 01 0a 41 	lsr	r1,r11,r1
8000bcb0:	f3 e8 10 08 	or	r8,r9,r8
8000bcb4:	f8 03 16 10 	lsr	r3,r12,0x10
8000bcb8:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000bcbc:	e2 03 0d 00 	divu	r0,r1,r3
8000bcc0:	f0 0b 16 10 	lsr	r11,r8,0x10
8000bcc4:	00 9e       	mov	lr,r0
8000bcc6:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000bcca:	e0 05 02 49 	mul	r9,r0,r5
8000bcce:	12 3b       	cp.w	r11,r9
8000bcd0:	c0 a2       	brcc	8000bce4 <__avr32_udiv64+0xf4>
8000bcd2:	20 1e       	sub	lr,1
8000bcd4:	18 0b       	add	r11,r12
8000bcd6:	18 3b       	cp.w	r11,r12
8000bcd8:	c0 63       	brcs	8000bce4 <__avr32_udiv64+0xf4>
8000bcda:	12 3b       	cp.w	r11,r9
8000bcdc:	f7 be 03 01 	sublo	lr,1
8000bce0:	f7 dc e3 0b 	addcs	r11,r11,r12
8000bce4:	12 1b       	sub	r11,r9
8000bce6:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
8000bcea:	f6 03 0d 02 	divu	r2,r11,r3
8000bcee:	f1 e3 11 08 	or	r8,r8,r3<<0x10
8000bcf2:	04 99       	mov	r9,r2
8000bcf4:	e4 05 02 4b 	mul	r11,r2,r5
8000bcf8:	16 38       	cp.w	r8,r11
8000bcfa:	c0 a2       	brcc	8000bd0e <__avr32_udiv64+0x11e>
8000bcfc:	20 19       	sub	r9,1
8000bcfe:	18 08       	add	r8,r12
8000bd00:	18 38       	cp.w	r8,r12
8000bd02:	c0 63       	brcs	8000bd0e <__avr32_udiv64+0x11e>
8000bd04:	16 38       	cp.w	r8,r11
8000bd06:	f7 b9 03 01 	sublo	r9,1
8000bd0a:	f1 dc e3 08 	addcs	r8,r8,r12
8000bd0e:	f4 06 09 43 	lsl	r3,r10,r6
8000bd12:	f0 0b 01 0b 	sub	r11,r8,r11
8000bd16:	f3 ee 11 09 	or	r9,r9,lr<<0x10
8000bd1a:	f8 06 16 10 	lsr	r6,r12,0x10
8000bd1e:	fd dc c0 10 	bfextu	lr,r12,0x0,0x10
8000bd22:	f6 06 0d 00 	divu	r0,r11,r6
8000bd26:	e6 0b 16 10 	lsr	r11,r3,0x10
8000bd2a:	00 9a       	mov	r10,r0
8000bd2c:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000bd30:	e0 0e 02 48 	mul	r8,r0,lr
8000bd34:	10 3b       	cp.w	r11,r8
8000bd36:	c0 a2       	brcc	8000bd4a <__avr32_udiv64+0x15a>
8000bd38:	20 1a       	sub	r10,1
8000bd3a:	18 0b       	add	r11,r12
8000bd3c:	18 3b       	cp.w	r11,r12
8000bd3e:	c0 63       	brcs	8000bd4a <__avr32_udiv64+0x15a>
8000bd40:	10 3b       	cp.w	r11,r8
8000bd42:	f7 ba 03 01 	sublo	r10,1
8000bd46:	f7 dc e3 0b 	addcs	r11,r11,r12
8000bd4a:	f6 08 01 01 	sub	r1,r11,r8
8000bd4e:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000bd52:	e2 06 0d 00 	divu	r0,r1,r6
8000bd56:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000bd5a:	00 98       	mov	r8,r0
8000bd5c:	e0 0e 02 4b 	mul	r11,r0,lr
8000bd60:	16 33       	cp.w	r3,r11
8000bd62:	c0 82       	brcc	8000bd72 <__avr32_udiv64+0x182>
8000bd64:	20 18       	sub	r8,1
8000bd66:	18 03       	add	r3,r12
8000bd68:	18 33       	cp.w	r3,r12
8000bd6a:	c0 43       	brcs	8000bd72 <__avr32_udiv64+0x182>
8000bd6c:	16 33       	cp.w	r3,r11
8000bd6e:	f7 b8 03 01 	sublo	r8,1
8000bd72:	f1 ea 11 08 	or	r8,r8,r10<<0x10
8000bd76:	c6 98       	rjmp	8000be48 <__avr32_udiv64+0x258>
8000bd78:	16 39       	cp.w	r9,r11
8000bd7a:	e0 8b 00 65 	brhi	8000be44 <__avr32_udiv64+0x254>
8000bd7e:	f2 09 12 00 	clz	r9,r9
8000bd82:	c0 b1       	brne	8000bd98 <__avr32_udiv64+0x1a8>
8000bd84:	10 3a       	cp.w	r10,r8
8000bd86:	5f 2a       	srhs	r10
8000bd88:	1c 3b       	cp.w	r11,lr
8000bd8a:	5f b8       	srhi	r8
8000bd8c:	10 4a       	or	r10,r8
8000bd8e:	f2 0a 18 00 	cp.b	r10,r9
8000bd92:	c5 90       	breq	8000be44 <__avr32_udiv64+0x254>
8000bd94:	30 18       	mov	r8,1
8000bd96:	c5 98       	rjmp	8000be48 <__avr32_udiv64+0x258>
8000bd98:	f0 09 09 46 	lsl	r6,r8,r9
8000bd9c:	f2 03 11 20 	rsub	r3,r9,32
8000bda0:	fc 09 09 4e 	lsl	lr,lr,r9
8000bda4:	f0 03 0a 48 	lsr	r8,r8,r3
8000bda8:	f6 09 09 4c 	lsl	r12,r11,r9
8000bdac:	f4 03 0a 42 	lsr	r2,r10,r3
8000bdb0:	ef 46 ff f4 	st.w	r7[-12],r6
8000bdb4:	f6 03 0a 43 	lsr	r3,r11,r3
8000bdb8:	18 42       	or	r2,r12
8000bdba:	f1 ee 10 0c 	or	r12,r8,lr
8000bdbe:	f8 01 16 10 	lsr	r1,r12,0x10
8000bdc2:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000bdc6:	e6 01 0d 04 	divu	r4,r3,r1
8000bdca:	e4 03 16 10 	lsr	r3,r2,0x10
8000bdce:	08 9e       	mov	lr,r4
8000bdd0:	e7 e5 11 03 	or	r3,r3,r5<<0x10
8000bdd4:	e8 06 02 48 	mul	r8,r4,r6
8000bdd8:	10 33       	cp.w	r3,r8
8000bdda:	c0 a2       	brcc	8000bdee <__avr32_udiv64+0x1fe>
8000bddc:	20 1e       	sub	lr,1
8000bdde:	18 03       	add	r3,r12
8000bde0:	18 33       	cp.w	r3,r12
8000bde2:	c0 63       	brcs	8000bdee <__avr32_udiv64+0x1fe>
8000bde4:	10 33       	cp.w	r3,r8
8000bde6:	f7 be 03 01 	sublo	lr,1
8000bdea:	e7 dc e3 03 	addcs	r3,r3,r12
8000bdee:	10 13       	sub	r3,r8
8000bdf0:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
8000bdf4:	e6 01 0d 00 	divu	r0,r3,r1
8000bdf8:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000bdfc:	00 98       	mov	r8,r0
8000bdfe:	e0 06 02 46 	mul	r6,r0,r6
8000be02:	0c 3b       	cp.w	r11,r6
8000be04:	c0 a2       	brcc	8000be18 <__avr32_udiv64+0x228>
8000be06:	20 18       	sub	r8,1
8000be08:	18 0b       	add	r11,r12
8000be0a:	18 3b       	cp.w	r11,r12
8000be0c:	c0 63       	brcs	8000be18 <__avr32_udiv64+0x228>
8000be0e:	0c 3b       	cp.w	r11,r6
8000be10:	f7 dc e3 0b 	addcs	r11,r11,r12
8000be14:	f7 b8 03 01 	sublo	r8,1
8000be18:	f1 ee 11 08 	or	r8,r8,lr<<0x10
8000be1c:	ee f4 ff f4 	ld.w	r4,r7[-12]
8000be20:	0c 1b       	sub	r11,r6
8000be22:	f0 04 06 42 	mulu.d	r2,r8,r4
8000be26:	06 95       	mov	r5,r3
8000be28:	16 35       	cp.w	r5,r11
8000be2a:	e0 8b 00 0a 	brhi	8000be3e <__avr32_udiv64+0x24e>
8000be2e:	5f 0b       	sreq	r11
8000be30:	f4 09 09 49 	lsl	r9,r10,r9
8000be34:	12 32       	cp.w	r2,r9
8000be36:	5f b9       	srhi	r9
8000be38:	f7 e9 00 09 	and	r9,r11,r9
8000be3c:	c0 60       	breq	8000be48 <__avr32_udiv64+0x258>
8000be3e:	20 18       	sub	r8,1
8000be40:	30 09       	mov	r9,0
8000be42:	c0 38       	rjmp	8000be48 <__avr32_udiv64+0x258>
8000be44:	30 09       	mov	r9,0
8000be46:	12 98       	mov	r8,r9
8000be48:	10 9a       	mov	r10,r8
8000be4a:	12 93       	mov	r3,r9
8000be4c:	10 92       	mov	r2,r8
8000be4e:	12 9b       	mov	r11,r9
8000be50:	2f dd       	sub	sp,-12
8000be52:	d8 32       	popm	r0-r7,pc

8000be54 <__avr32_umod64>:
8000be54:	d4 31       	pushm	r0-r7,lr
8000be56:	1a 97       	mov	r7,sp
8000be58:	20 3d       	sub	sp,12
8000be5a:	10 9c       	mov	r12,r8
8000be5c:	12 95       	mov	r5,r9
8000be5e:	14 9e       	mov	lr,r10
8000be60:	16 91       	mov	r1,r11
8000be62:	16 96       	mov	r6,r11
8000be64:	58 09       	cp.w	r9,0
8000be66:	e0 81 00 81 	brne	8000bf68 <__avr32_umod64+0x114>
8000be6a:	16 38       	cp.w	r8,r11
8000be6c:	e0 88 00 12 	brls	8000be90 <__avr32_umod64+0x3c>
8000be70:	f0 08 12 00 	clz	r8,r8
8000be74:	c4 e0       	breq	8000bf10 <__avr32_umod64+0xbc>
8000be76:	f6 08 09 46 	lsl	r6,r11,r8
8000be7a:	f8 08 09 4c 	lsl	r12,r12,r8
8000be7e:	f0 0b 11 20 	rsub	r11,r8,32
8000be82:	f4 08 09 4e 	lsl	lr,r10,r8
8000be86:	f4 0b 0a 4b 	lsr	r11,r10,r11
8000be8a:	f7 e6 10 06 	or	r6,r11,r6
8000be8e:	c4 18       	rjmp	8000bf10 <__avr32_umod64+0xbc>
8000be90:	58 08       	cp.w	r8,0
8000be92:	c0 51       	brne	8000be9c <__avr32_umod64+0x48>
8000be94:	30 19       	mov	r9,1
8000be96:	f2 08 0d 08 	divu	r8,r9,r8
8000be9a:	10 9c       	mov	r12,r8
8000be9c:	f8 08 12 00 	clz	r8,r12
8000bea0:	c0 31       	brne	8000bea6 <__avr32_umod64+0x52>
8000bea2:	18 16       	sub	r6,r12
8000bea4:	c3 68       	rjmp	8000bf10 <__avr32_umod64+0xbc>
8000bea6:	f0 03 11 20 	rsub	r3,r8,32
8000beaa:	f4 03 0a 4b 	lsr	r11,r10,r3
8000beae:	f8 08 09 4c 	lsl	r12,r12,r8
8000beb2:	ec 08 09 49 	lsl	r9,r6,r8
8000beb6:	ec 03 0a 43 	lsr	r3,r6,r3
8000beba:	f7 e9 10 09 	or	r9,r11,r9
8000bebe:	f8 05 16 10 	lsr	r5,r12,0x10
8000bec2:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000bec6:	e6 05 0d 02 	divu	r2,r3,r5
8000beca:	f2 0e 16 10 	lsr	lr,r9,0x10
8000bece:	ec 02 02 4b 	mul	r11,r6,r2
8000bed2:	fd e3 11 0e 	or	lr,lr,r3<<0x10
8000bed6:	16 3e       	cp.w	lr,r11
8000bed8:	c0 72       	brcc	8000bee6 <__avr32_umod64+0x92>
8000beda:	18 0e       	add	lr,r12
8000bedc:	18 3e       	cp.w	lr,r12
8000bede:	c0 43       	brcs	8000bee6 <__avr32_umod64+0x92>
8000bee0:	16 3e       	cp.w	lr,r11
8000bee2:	fd dc e3 0e 	addcs	lr,lr,r12
8000bee6:	fc 0b 01 03 	sub	r3,lr,r11
8000beea:	f3 d9 c0 10 	bfextu	r9,r9,0x0,0x10
8000beee:	e6 05 0d 02 	divu	r2,r3,r5
8000bef2:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000bef6:	a5 36       	mul	r6,r2
8000bef8:	0c 39       	cp.w	r9,r6
8000befa:	c0 72       	brcc	8000bf08 <__avr32_umod64+0xb4>
8000befc:	18 09       	add	r9,r12
8000befe:	18 39       	cp.w	r9,r12
8000bf00:	c0 43       	brcs	8000bf08 <__avr32_umod64+0xb4>
8000bf02:	0c 39       	cp.w	r9,r6
8000bf04:	f3 dc e3 09 	addcs	r9,r9,r12
8000bf08:	f2 06 01 06 	sub	r6,r9,r6
8000bf0c:	f4 08 09 4e 	lsl	lr,r10,r8
8000bf10:	f8 0a 16 10 	lsr	r10,r12,0x10
8000bf14:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000bf18:	ec 0a 0d 02 	divu	r2,r6,r10
8000bf1c:	fc 09 16 10 	lsr	r9,lr,0x10
8000bf20:	ea 02 02 4b 	mul	r11,r5,r2
8000bf24:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000bf28:	16 39       	cp.w	r9,r11
8000bf2a:	c0 72       	brcc	8000bf38 <__avr32_umod64+0xe4>
8000bf2c:	18 09       	add	r9,r12
8000bf2e:	18 39       	cp.w	r9,r12
8000bf30:	c0 43       	brcs	8000bf38 <__avr32_umod64+0xe4>
8000bf32:	16 39       	cp.w	r9,r11
8000bf34:	f3 dc e3 09 	addcs	r9,r9,r12
8000bf38:	f2 0b 01 0b 	sub	r11,r9,r11
8000bf3c:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000bf40:	f6 0a 0d 0a 	divu	r10,r11,r10
8000bf44:	fd eb 11 0e 	or	lr,lr,r11<<0x10
8000bf48:	ea 0a 02 4a 	mul	r10,r5,r10
8000bf4c:	14 3e       	cp.w	lr,r10
8000bf4e:	c0 72       	brcc	8000bf5c <__avr32_umod64+0x108>
8000bf50:	18 0e       	add	lr,r12
8000bf52:	18 3e       	cp.w	lr,r12
8000bf54:	c0 43       	brcs	8000bf5c <__avr32_umod64+0x108>
8000bf56:	14 3e       	cp.w	lr,r10
8000bf58:	fd dc e3 0e 	addcs	lr,lr,r12
8000bf5c:	fc 0a 01 0a 	sub	r10,lr,r10
8000bf60:	30 0b       	mov	r11,0
8000bf62:	f4 08 0a 4a 	lsr	r10,r10,r8
8000bf66:	c7 b8       	rjmp	8000c05c <__avr32_umod64+0x208>
8000bf68:	16 39       	cp.w	r9,r11
8000bf6a:	e0 8b 00 79 	brhi	8000c05c <__avr32_umod64+0x208>
8000bf6e:	f2 09 12 00 	clz	r9,r9
8000bf72:	c1 21       	brne	8000bf96 <__avr32_umod64+0x142>
8000bf74:	10 3a       	cp.w	r10,r8
8000bf76:	5f 2b       	srhs	r11
8000bf78:	0a 31       	cp.w	r1,r5
8000bf7a:	5f ba       	srhi	r10
8000bf7c:	f7 ea 10 0a 	or	r10,r11,r10
8000bf80:	f2 0a 18 00 	cp.b	r10,r9
8000bf84:	c0 60       	breq	8000bf90 <__avr32_umod64+0x13c>
8000bf86:	fc 08 01 0c 	sub	r12,lr,r8
8000bf8a:	e2 05 01 46 	sbc	r6,r1,r5
8000bf8e:	18 9e       	mov	lr,r12
8000bf90:	0c 9b       	mov	r11,r6
8000bf92:	1c 9a       	mov	r10,lr
8000bf94:	c6 48       	rjmp	8000c05c <__avr32_umod64+0x208>
8000bf96:	ea 09 09 4c 	lsl	r12,r5,r9
8000bf9a:	f2 06 11 20 	rsub	r6,r9,32
8000bf9e:	f6 09 09 4b 	lsl	r11,r11,r9
8000bfa2:	f0 09 09 42 	lsl	r2,r8,r9
8000bfa6:	ef 46 ff f4 	st.w	r7[-12],r6
8000bfaa:	f0 06 0a 48 	lsr	r8,r8,r6
8000bfae:	18 48       	or	r8,r12
8000bfb0:	e2 06 0a 4c 	lsr	r12,r1,r6
8000bfb4:	f4 09 09 43 	lsl	r3,r10,r9
8000bfb8:	fd d8 c0 10 	bfextu	lr,r8,0x0,0x10
8000bfbc:	f4 06 0a 4a 	lsr	r10,r10,r6
8000bfc0:	16 4a       	or	r10,r11
8000bfc2:	f0 0b 16 10 	lsr	r11,r8,0x10
8000bfc6:	f8 0b 0d 04 	divu	r4,r12,r11
8000bfca:	f4 0c 16 10 	lsr	r12,r10,0x10
8000bfce:	08 91       	mov	r1,r4
8000bfd0:	f9 e5 11 0c 	or	r12,r12,r5<<0x10
8000bfd4:	e8 0e 02 46 	mul	r6,r4,lr
8000bfd8:	0c 3c       	cp.w	r12,r6
8000bfda:	c0 a2       	brcc	8000bfee <__avr32_umod64+0x19a>
8000bfdc:	20 11       	sub	r1,1
8000bfde:	10 0c       	add	r12,r8
8000bfe0:	10 3c       	cp.w	r12,r8
8000bfe2:	c0 63       	brcs	8000bfee <__avr32_umod64+0x19a>
8000bfe4:	0c 3c       	cp.w	r12,r6
8000bfe6:	f7 b1 03 01 	sublo	r1,1
8000bfea:	f9 d8 e3 0c 	addcs	r12,r12,r8
8000bfee:	0c 1c       	sub	r12,r6
8000bff0:	f5 da c0 10 	bfextu	r10,r10,0x0,0x10
8000bff4:	f8 0b 0d 04 	divu	r4,r12,r11
8000bff8:	f5 e5 11 0b 	or	r11,r10,r5<<0x10
8000bffc:	08 96       	mov	r6,r4
8000bffe:	e8 0e 02 4e 	mul	lr,r4,lr
8000c002:	1c 3b       	cp.w	r11,lr
8000c004:	c0 a2       	brcc	8000c018 <__avr32_umod64+0x1c4>
8000c006:	20 16       	sub	r6,1
8000c008:	10 0b       	add	r11,r8
8000c00a:	10 3b       	cp.w	r11,r8
8000c00c:	c0 63       	brcs	8000c018 <__avr32_umod64+0x1c4>
8000c00e:	1c 3b       	cp.w	r11,lr
8000c010:	f7 b6 03 01 	sublo	r6,1
8000c014:	f7 d8 e3 0b 	addcs	r11,r11,r8
8000c018:	ed e1 11 01 	or	r1,r6,r1<<0x10
8000c01c:	1c 1b       	sub	r11,lr
8000c01e:	e2 02 06 40 	mulu.d	r0,r1,r2
8000c022:	00 9e       	mov	lr,r0
8000c024:	02 9c       	mov	r12,r1
8000c026:	16 3c       	cp.w	r12,r11
8000c028:	e0 8b 00 08 	brhi	8000c038 <__avr32_umod64+0x1e4>
8000c02c:	5f 06       	sreq	r6
8000c02e:	06 30       	cp.w	r0,r3
8000c030:	5f ba       	srhi	r10
8000c032:	ed ea 00 0a 	and	r10,r6,r10
8000c036:	c0 60       	breq	8000c042 <__avr32_umod64+0x1ee>
8000c038:	fc 02 01 04 	sub	r4,lr,r2
8000c03c:	f8 08 01 4c 	sbc	r12,r12,r8
8000c040:	08 9e       	mov	lr,r4
8000c042:	e6 0e 01 0a 	sub	r10,r3,lr
8000c046:	f6 0c 01 4c 	sbc	r12,r11,r12
8000c04a:	ee f1 ff f4 	ld.w	r1,r7[-12]
8000c04e:	f8 09 0a 4b 	lsr	r11,r12,r9
8000c052:	f4 09 0a 4a 	lsr	r10,r10,r9
8000c056:	f8 01 09 4c 	lsl	r12,r12,r1
8000c05a:	18 4a       	or	r10,r12
8000c05c:	2f dd       	sub	sp,-12
8000c05e:	d8 32       	popm	r0-r7,pc

Disassembly of section .exception:

8000c200 <_evba>:
_evba:

        .org  0x000
        // Unrecoverable Exception.
_handle_Unrecoverable_Exception:
        rjmp $
8000c200:	c0 08       	rjmp	8000c200 <_evba>
	...

8000c204 <_handle_TLB_Multiple_Hit>:

        .org  0x004
        // TLB Multiple Hit: UNUSED IN AVR32UC.
_handle_TLB_Multiple_Hit:
        rjmp $
8000c204:	c0 08       	rjmp	8000c204 <_handle_TLB_Multiple_Hit>
	...

8000c208 <_handle_Bus_Error_Data_Fetch>:

        .org  0x008
        // Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
        rjmp $
8000c208:	c0 08       	rjmp	8000c208 <_handle_Bus_Error_Data_Fetch>
	...

8000c20c <_handle_Bus_Error_Instruction_Fetch>:

        .org  0x00C
         // Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
        rjmp $
8000c20c:	c0 08       	rjmp	8000c20c <_handle_Bus_Error_Instruction_Fetch>
	...

8000c210 <_handle_NMI>:

        .org  0x010
        // NMI.
_handle_NMI:
        rjmp $
8000c210:	c0 08       	rjmp	8000c210 <_handle_NMI>
	...

8000c214 <_handle_Instruction_Address>:

        .org  0x014
        // Instruction Address.
_handle_Instruction_Address:
        rjmp $
8000c214:	c0 08       	rjmp	8000c214 <_handle_Instruction_Address>
	...

8000c218 <_handle_ITLB_Protection>:

        .org  0x018
        // ITLB Protection.
_handle_ITLB_Protection:
        rjmp $
8000c218:	c0 08       	rjmp	8000c218 <_handle_ITLB_Protection>
	...

8000c21c <_handle_Breakpoint>:

        .org  0x01C
        // Breakpoint.
_handle_Breakpoint:
        rjmp $
8000c21c:	c0 08       	rjmp	8000c21c <_handle_Breakpoint>
	...

8000c220 <_handle_Illegal_Opcode>:

        .org  0x020
        // Illegal Opcode.
_handle_Illegal_Opcode:
        rjmp $
8000c220:	c0 08       	rjmp	8000c220 <_handle_Illegal_Opcode>
	...

8000c224 <_handle_Unimplemented_Instruction>:

        .org  0x024
        // Unimplemented Instruction.
_handle_Unimplemented_Instruction:
        rjmp $
8000c224:	c0 08       	rjmp	8000c224 <_handle_Unimplemented_Instruction>
	...

8000c228 <_handle_Privilege_Violation>:

        .org  0x028
        // Privilege Violation.
_handle_Privilege_Violation:
        rjmp $
8000c228:	c0 08       	rjmp	8000c228 <_handle_Privilege_Violation>
	...

8000c22c <_handle_Floating_Point>:

        .org  0x02C
        // Floating-Point: UNUSED IN AVR32UC.
_handle_Floating_Point:
        rjmp $
8000c22c:	c0 08       	rjmp	8000c22c <_handle_Floating_Point>
	...

8000c230 <_handle_Coprocessor_Absent>:

        .org  0x030
        // Coprocessor Absent: UNUSED IN AVR32UC.
_handle_Coprocessor_Absent:
        rjmp $
8000c230:	c0 08       	rjmp	8000c230 <_handle_Coprocessor_Absent>
	...

8000c234 <_handle_Data_Address_Read>:

        .org  0x034
        // Data Address (Read).
_handle_Data_Address_Read:
        rjmp $
8000c234:	c0 08       	rjmp	8000c234 <_handle_Data_Address_Read>
	...

8000c238 <_handle_Data_Address_Write>:

        .org  0x038
        // Data Address (Write).
_handle_Data_Address_Write:
        rjmp $
8000c238:	c0 08       	rjmp	8000c238 <_handle_Data_Address_Write>
	...

8000c23c <_handle_DTLB_Protection_Read>:

        .org  0x03C
        // DTLB Protection (Read).
_handle_DTLB_Protection_Read:
        rjmp $
8000c23c:	c0 08       	rjmp	8000c23c <_handle_DTLB_Protection_Read>
	...

8000c240 <_handle_DTLB_Protection_Write>:

        .org  0x040
        // DTLB Protection (Write).
_handle_DTLB_Protection_Write:
        rjmp $
8000c240:	c0 08       	rjmp	8000c240 <_handle_DTLB_Protection_Write>
	...

8000c244 <_handle_DTLB_Modified>:

        .org  0x044
        // DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
        rjmp $
8000c244:	c0 08       	rjmp	8000c244 <_handle_DTLB_Modified>
	...

8000c250 <_handle_ITLB_Miss>:

        .org  0x050
        // ITLB Miss: UNUSED IN AVR32UC.
_handle_ITLB_Miss:
        rjmp $
8000c250:	c0 08       	rjmp	8000c250 <_handle_ITLB_Miss>
	...

8000c260 <_handle_DTLB_Miss_Read>:

        .org  0x060
        // DTLB Miss (Read): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Read:
        rjmp $
8000c260:	c0 08       	rjmp	8000c260 <_handle_DTLB_Miss_Read>
	...

8000c270 <_handle_DTLB_Miss_Write>:

        .org  0x070
        // DTLB Miss (Write): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Write:
        rjmp $
8000c270:	c0 08       	rjmp	8000c270 <_handle_DTLB_Miss_Write>
	...

8000c300 <_handle_Supervisor_Call>:

        .org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
8000c300:	fe cf 71 d4 	sub	pc,pc,29140

8000c304 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
8000c304:	30 0c       	mov	r12,0
8000c306:	fe b0 c3 87 	rcall	80004a14 <_get_interrupt_handler>
8000c30a:	58 0c       	cp.w	r12,0
8000c30c:	f8 0f 17 10 	movne	pc,r12
8000c310:	d6 03       	rete

8000c312 <_int1>:
8000c312:	30 1c       	mov	r12,1
8000c314:	fe b0 c3 80 	rcall	80004a14 <_get_interrupt_handler>
8000c318:	58 0c       	cp.w	r12,0
8000c31a:	f8 0f 17 10 	movne	pc,r12
8000c31e:	d6 03       	rete

8000c320 <_int2>:
8000c320:	30 2c       	mov	r12,2
8000c322:	fe b0 c3 79 	rcall	80004a14 <_get_interrupt_handler>
8000c326:	58 0c       	cp.w	r12,0
8000c328:	f8 0f 17 10 	movne	pc,r12
8000c32c:	d6 03       	rete

8000c32e <_int3>:
8000c32e:	30 3c       	mov	r12,3
8000c330:	fe b0 c3 72 	rcall	80004a14 <_get_interrupt_handler>
8000c334:	58 0c       	cp.w	r12,0
8000c336:	f8 0f 17 10 	movne	pc,r12
8000c33a:	d6 03       	rete

8000c33c <ipr_val>:
8000c33c:	00 00 01 04 40 00 01 12 80 00 01 20 c0 00 01 2e     ....@...... ....
8000c34c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c35c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c36c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c37c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c38c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c39c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c3ac:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c3bc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c3cc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c3dc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c3ec:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c3fc:	d7 03 d7 03                                         ....
