
moto_gob_prj.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002010  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80002010  80002010  00002410  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         0000debc  80002010  80002010  00002410  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  80010000  80010000  00010400  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       00009688  80010200  80010200  00010600  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .dalign       00000004  00000004  00000004  00000000  2**0
                  ALLOC
  6 .data         00000a34  00000008  80019888  0001a008  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .balign       00000004  00000a3c  8001a2bc  0001aa3c  2**0
                  ALLOC
  8 .bss          00003c70  00000a40  00000a40  00000000  2**2
                  ALLOC
  9 .heap         00012950  000046b0  000046b0  00000000  2**0
                  ALLOC
 10 .comment      00000030  00000000  00000000  0001aa3c  2**0
                  CONTENTS, READONLY
 11 .debug_aranges 00001638  00000000  00000000  0001aa70  2**3
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_pubnames 00002afb  00000000  00000000  0001c0a8  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_info   0002ebe5  00000000  00000000  0001eba3  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_abbrev 00007853  00000000  00000000  0004d788  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_line   0000e002  00000000  00000000  00054fdb  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_frame  00003d88  00000000  00000000  00062fe0  2**2
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_str    0000804f  00000000  00000000  00066d68  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_loc    00012370  00000000  00000000  0006edb7  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .stack        00001000  00017000  00017000  00000000  2**0
                  ALLOC
 20 .debug_ranges 00001730  00000000  00000000  00081128  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_start>:

  .global _start
  .type _start, @function
_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80000000:	48 1f       	lddpc	pc,80000004 <_start+0x4>
80000002:	d7 03       	nop
80000004:	80 00       	ld.sh	r0,r0[0x0]
80000006:	a4 48       	st.h	r2[0x8],r8

80000008 <_trampoline>:

  .global _trampoline
  .type _trampoline, @function
_trampoline:
  // Jump to program start.
  rjmp    program_start
80000008:	e0 8f 10 00 	bral	80002008 <program_start>
	...

80002008 <program_start>:

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002008:	fe ff 00 04 	ld.w	pc,pc[4]
8000200c:	80 00       	ld.sh	r0,r0[0x0]
8000200e:	a4 48       	st.h	r2[0x8],r8

Disassembly of section .text:

80002010 <DeviceManagement_brdcst_func>:
		U8 temp = 0;
		temp  = xcmp->u8[1] << 8;
		temp |= xcmp->u8[2];
		//if (temp == theXNL_Ctrlr.XNL_DeviceLogicalAddress)
		{
			if (xcmp->u8[0] == 0x01)
80002010:	19 a9       	ld.ub	r9,r12[0x2]
80002012:	30 18       	mov	r8,1
80002014:	f0 09 18 00 	cp.b	r9,r8
80002018:	c0 61       	brne	80002024 <DeviceManagement_brdcst_func+0x14>
			{
				bunchofrandomstatusflags |= 0x00000002;
8000201a:	48 68       	lddpc	r8,80002030 <DeviceManagement_brdcst_func+0x20>
8000201c:	70 09       	ld.w	r9,r8[0x0]
8000201e:	a1 b9       	sbr	r9,0x1
80002020:	91 09       	st.w	r8[0x0],r9
80002022:	5e fc       	retal	r12
			}
			else
			{
				bunchofrandomstatusflags &= 0xFFFFFFFD;
80002024:	48 38       	lddpc	r8,80002030 <DeviceManagement_brdcst_func+0x20>
80002026:	70 09       	ld.w	r9,r8[0x0]
80002028:	a1 d9       	cbr	r9,0x1
8000202a:	91 09       	st.w	r8[0x0],r9
8000202c:	5e fc       	retal	r12
8000202e:	00 00       	add	r0,r0
80002030:	00 00       	add	r0,r0
80002032:	13 4c       	ld.w	r12,--r9

80002034 <mic_brdcst_func>:
	//log("\n\r Signal_type: %x \n\r " ,  ptr->Signaling_Type);
	//log("\n\r Mic_state: %x \n\r " ,  ptr->Mic_State);
	//log("\n\r Gain_offset: %x \n\r " ,  ptr->Gain_Offset);
			
	
}
80002034:	5e fc       	retal	r12

80002036 <TransmitControl_brdcst_func>:
	//log("\n\r  State: %x \n\r ", ptr->State );
	//log("\n\r  State_change_reason: %x \n\r ", ptr->State_change_reason );
	//
	
	
}
80002036:	5e fc       	retal	r12

80002038 <vApplicationIdleHook>:
}

void vApplicationIdleHook( void )
{
	/* This hook function does nothing but increment a counter. */
	ulIdleCycleCount++;
80002038:	48 38       	lddpc	r8,80002044 <vApplicationIdleHook+0xc>
8000203a:	70 09       	ld.w	r9,r8[0x0]
8000203c:	2f f9       	sub	r9,-1
8000203e:	91 09       	st.w	r8[0x0],r9
	
}
80002040:	5e fc       	retal	r12
80002042:	00 00       	add	r0,r0
80002044:	00 00       	add	r0,r0
80002046:	0a 58       	eor	r8,r5

80002048 <app_init>:
														
		
};

void app_init(void)
{	
80002048:	d4 01       	pushm	lr
	payload_init( app_payload_rx_proc , app_payload_tx_proc );	
8000204a:	48 cb       	lddpc	r11,80002078 <app_init+0x30>
8000204c:	48 cc       	lddpc	r12,8000207c <app_init+0x34>
8000204e:	f0 1f 00 0d 	mcall	80002080 <app_init+0x38>
	xcmp_register_app_list(the_app_list);
80002052:	48 dc       	lddpc	r12,80002084 <app_init+0x3c>
80002054:	f0 1f 00 0d 	mcall	80002088 <app_init+0x40>
			
	static portBASE_TYPE res = 0;
	 res = xTaskCreate(
80002058:	30 09       	mov	r9,0
8000205a:	1a d9       	st.w	--sp,r9
8000205c:	1a d9       	st.w	--sp,r9
8000205e:	1a d9       	st.w	--sp,r9
80002060:	30 18       	mov	r8,1
80002062:	e0 6a 01 80 	mov	r10,384
80002066:	48 ab       	lddpc	r11,8000208c <app_init+0x44>
80002068:	48 ac       	lddpc	r12,80002090 <app_init+0x48>
8000206a:	f0 1f 00 0b 	mcall	80002094 <app_init+0x4c>
8000206e:	48 b8       	lddpc	r8,80002098 <app_init+0x50>
80002070:	91 0c       	st.w	r8[0x0],r12
80002072:	2f dd       	sub	sp,-12
	,  NULL
	,  1
	,  NULL );
	
	
}
80002074:	d8 02       	popm	pc
80002076:	00 00       	add	r0,r0
80002078:	80 00       	ld.sh	r0,r0[0x0]
8000207a:	28 90       	sub	r0,-119
8000207c:	80 00       	ld.sh	r0,r0[0x0]
8000207e:	28 f4       	sub	r4,-113
80002080:	80 00       	ld.sh	r0,r0[0x0]
80002082:	3b e4       	mov	r4,-66
80002084:	00 00       	add	r0,r0
80002086:	00 08       	add	r8,r0
80002088:	80 00       	ld.sh	r0,r0[0x0]
8000208a:	50 dc       	stdsp	sp[0x34],r12
8000208c:	80 01       	ld.sh	r1,r0[0x0]
8000208e:	02 00       	add	r0,r1
80002090:	80 00       	ld.sh	r0,r0[0x0]
80002092:	27 d0       	sub	r0,125
80002094:	80 00       	ld.sh	r0,r0[0x0]
80002096:	9b 7c       	st.w	sp[0x1c],r12
80002098:	00 00       	add	r0,r0
8000209a:	0a 54       	eor	r4,r5

8000209c <FD_brdcst_func>:
	
	
}

void FD_brdcst_func(xcmp_fragment_t * xcmp)
{
8000209c:	d4 01       	pushm	lr
	
	
	log("\n\r Forward Data Broadcast \n\r");
8000209e:	48 3c       	lddpc	r12,800020a8 <FD_brdcst_func+0xc>
800020a0:	f0 1f 00 03 	mcall	800020ac <FD_brdcst_func+0x10>
	
}
800020a4:	d8 02       	popm	pc
800020a6:	00 00       	add	r0,r0
800020a8:	80 01       	ld.sh	r1,r0[0x0]
800020aa:	02 08       	add	r8,r1
800020ac:	80 00       	ld.sh	r0,r0[0x0]
800020ae:	9f 40       	st.w	pc[0x10],r0

800020b0 <FD_reply_func>:
	
	
}

void FD_reply_func(xcmp_fragment_t * xcmp)
{
800020b0:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Reply \n\r");
800020b2:	48 3c       	lddpc	r12,800020bc <FD_reply_func+0xc>
800020b4:	f0 1f 00 03 	mcall	800020c0 <FD_reply_func+0x10>
	
	
}
800020b8:	d8 02       	popm	pc
800020ba:	00 00       	add	r0,r0
800020bc:	80 01       	ld.sh	r1,r0[0x0]
800020be:	02 28       	rsub	r8,r1
800020c0:	80 00       	ld.sh	r0,r0[0x0]
800020c2:	9f 40       	st.w	pc[0x10],r0

800020c4 <FD_request_func>:
}



void FD_request_func(xcmp_fragment_t * xcmp)
{
800020c4:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Request \n\r");
800020c6:	48 3c       	lddpc	r12,800020d0 <FD_request_func+0xc>
800020c8:	f0 1f 00 03 	mcall	800020d4 <FD_request_func+0x10>
	
	
}
800020cc:	d8 02       	popm	pc
800020ce:	00 00       	add	r0,r0
800020d0:	80 01       	ld.sh	r1,r0[0x0]
800020d2:	02 44       	or	r4,r1
800020d4:	80 00       	ld.sh	r0,r0[0x0]
800020d6:	9f 40       	st.w	pc[0x10],r0

800020d8 <EnOB_brdcst_func>:
	
	
}

void EnOB_brdcst_func(xcmp_fragment_t * xcmp)
{
800020d8:	d4 01       	pushm	lr
	
	
	log("\n\r En_OB Broadcast \n\r");
800020da:	48 3c       	lddpc	r12,800020e4 <EnOB_brdcst_func+0xc>
800020dc:	f0 1f 00 03 	mcall	800020e8 <EnOB_brdcst_func+0x10>
}
800020e0:	d8 02       	popm	pc
800020e2:	00 00       	add	r0,r0
800020e4:	80 01       	ld.sh	r1,r0[0x0]
800020e6:	02 60       	and	r0,r1
800020e8:	80 00       	ld.sh	r0,r0[0x0]
800020ea:	9f 40       	st.w	pc[0x10],r0

800020ec <EnOB_reply_func>:
}



void EnOB_reply_func(xcmp_fragment_t * xcmp)
{
800020ec:	eb cd 40 80 	pushm	r7,lr
800020f0:	18 97       	mov	r7,r12
		/*point to xcmp payload*/
	//En_OB_Control_reply_t *ptr = (En_OB_Control_reply_t* )xcmp->u8;
	//log("\n\r Xcmp_opcode: %x \n\r", xcmp->xcmp_opcode);
	
	if (xcmp->u8[0]== xcmp_Res_Success)
800020f2:	19 a9       	ld.ub	r9,r12[0x2]
800020f4:	30 08       	mov	r8,0
800020f6:	f0 09 18 00 	cp.b	r9,r8
800020fa:	c1 91       	brne	8000212c <EnOB_reply_func+0x40>
	{
		if (xcmp->u8[1] == EN_OB_Enter)
800020fc:	19 b8       	ld.ub	r8,r12[0x3]
800020fe:	30 19       	mov	r9,1
80002100:	f2 08 18 00 	cp.b	r8,r9
80002104:	c0 61       	brne	80002110 <EnOB_reply_func+0x24>
		{
		
			log("\n\r En_OB_Enter OK \n\r");
80002106:	49 0c       	lddpc	r12,80002144 <EnOB_reply_func+0x58>
80002108:	f0 1f 00 10 	mcall	80002148 <EnOB_reply_func+0x5c>
8000210c:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else if (xcmp->u8[1] == EN_OB_Exit )
80002110:	58 08       	cp.w	r8,0
80002112:	c0 61       	brne	8000211e <EnOB_reply_func+0x32>
		{
			log("\n\r En_OB_Exit OK \n\r");
80002114:	48 ec       	lddpc	r12,8000214c <EnOB_reply_func+0x60>
80002116:	f0 1f 00 0d 	mcall	80002148 <EnOB_reply_func+0x5c>
8000211a:	e3 cd 80 80 	ldm	sp++,r7,pc
		}
		else
		{
			
			log("\n\r En_OB_Control: %x \n\r", xcmp->u8[1]);
8000211e:	1a d8       	st.w	--sp,r8
80002120:	48 cc       	lddpc	r12,80002150 <EnOB_reply_func+0x64>
80002122:	f0 1f 00 0a 	mcall	80002148 <EnOB_reply_func+0x5c>
80002126:	2f fd       	sub	sp,-4
80002128:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r En_OB_Control error \n\r");
8000212c:	48 ac       	lddpc	r12,80002154 <EnOB_reply_func+0x68>
8000212e:	f0 1f 00 07 	mcall	80002148 <EnOB_reply_func+0x5c>
		log("\n\r En_OB_result: %x \n\r", xcmp->u8[0]);
80002132:	0f a8       	ld.ub	r8,r7[0x2]
80002134:	1a d8       	st.w	--sp,r8
80002136:	48 9c       	lddpc	r12,80002158 <EnOB_reply_func+0x6c>
80002138:	f0 1f 00 04 	mcall	80002148 <EnOB_reply_func+0x5c>
8000213c:	2f fd       	sub	sp,-4
8000213e:	e3 cd 80 80 	ldm	sp++,r7,pc
80002142:	00 00       	add	r0,r0
80002144:	80 01       	ld.sh	r1,r0[0x0]
80002146:	02 78       	tst	r8,r1
80002148:	80 00       	ld.sh	r0,r0[0x0]
8000214a:	9f 40       	st.w	pc[0x10],r0
8000214c:	80 01       	ld.sh	r1,r0[0x0]
8000214e:	02 90       	mov	r0,r1
80002150:	80 01       	ld.sh	r1,r0[0x0]
80002152:	02 a4       	st.w	r1++,r4
80002154:	80 01       	ld.sh	r1,r0[0x0]
80002156:	02 bc       	st.h	r1++,r12
80002158:	80 01       	ld.sh	r1,r0[0x0]
8000215a:	02 d8       	st.w	--r1,r8

8000215c <SingleDetection_brdcst_func>:
	
}


void SingleDetection_brdcst_func(xcmp_fragment_t * xcmp)
{
8000215c:	eb cd 40 80 	pushm	r7,lr
80002160:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == 0x11)
80002162:	19 a9       	ld.ub	r9,r12[0x2]
80002164:	31 18       	mov	r8,17
80002166:	f0 09 18 00 	cp.b	r9,r8
8000216a:	c0 61       	brne	80002176 <SingleDetection_brdcst_func+0x1a>
	{
		log("\n\r DMR_CSBK OK \n\r");
8000216c:	48 8c       	lddpc	r12,8000218c <SingleDetection_brdcst_func+0x30>
8000216e:	f0 1f 00 09 	mcall	80002190 <SingleDetection_brdcst_func+0x34>
80002172:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	//if(xcmp->u8[1] == 0x11)
	else
	{
		log("SIGBRCST error");
80002176:	48 8c       	lddpc	r12,80002194 <SingleDetection_brdcst_func+0x38>
80002178:	f0 1f 00 06 	mcall	80002190 <SingleDetection_brdcst_func+0x34>
		log("\n\r Signal_type: %X \n\r", xcmp->u8[0] );
8000217c:	0f a8       	ld.ub	r8,r7[0x2]
8000217e:	1a d8       	st.w	--sp,r8
80002180:	48 6c       	lddpc	r12,80002198 <SingleDetection_brdcst_func+0x3c>
80002182:	f0 1f 00 04 	mcall	80002190 <SingleDetection_brdcst_func+0x34>
80002186:	2f fd       	sub	sp,-4
80002188:	e3 cd 80 80 	ldm	sp++,r7,pc
8000218c:	80 01       	ld.sh	r1,r0[0x0]
8000218e:	02 f0       	st.b	--r1,r0
80002190:	80 00       	ld.sh	r0,r0[0x0]
80002192:	9f 40       	st.w	pc[0x10],r0
80002194:	80 01       	ld.sh	r1,r0[0x0]
80002196:	03 04       	ld.w	r4,r1++
80002198:	80 01       	ld.sh	r1,r0[0x0]
8000219a:	03 14       	ld.sh	r4,r1++

8000219c <ButtonConfig_brdcst_func>:
	
}


void ButtonConfig_brdcst_func(xcmp_fragment_t * xcmp)
{
8000219c:	d4 31       	pushm	r0-r7,lr
	U8 Num_Button =0;
	U8 i = 0 ;
	/*point to xcmp payload*/
	ButtonConfig_brdcst_t  *ptr = (ButtonConfig_brdcst_t* )xcmp->u8;
8000219e:	f8 c7 ff fe 	sub	r7,r12,-2
	
	Num_Button = ptr->NumOfButtons;
800021a2:	0f 95       	ld.ub	r5,r7[0x1]
	
	log("\n\r ButtonConfig_broadcast  \n\r"  );
800021a4:	4a bc       	lddpc	r12,80002250 <ButtonConfig_brdcst_func+0xb4>
800021a6:	f0 1f 00 2c 	mcall	80002254 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r Function: %X \n\r" , ptr->Function );
800021aa:	0f 88       	ld.ub	r8,r7[0x0]
800021ac:	1a d8       	st.w	--sp,r8
800021ae:	4a bc       	lddpc	r12,80002258 <ButtonConfig_brdcst_func+0xbc>
800021b0:	f0 1f 00 29 	mcall	80002254 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
800021b4:	1a d5       	st.w	--sp,r5
800021b6:	4a ac       	lddpc	r12,8000225c <ButtonConfig_brdcst_func+0xc0>
800021b8:	f0 1f 00 27 	mcall	80002254 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
800021bc:	0f a8       	ld.ub	r8,r7[0x2]
800021be:	1a d8       	st.w	--sp,r8
800021c0:	4a 8c       	lddpc	r12,80002260 <ButtonConfig_brdcst_func+0xc4>
800021c2:	f0 1f 00 25 	mcall	80002254 <ButtonConfig_brdcst_func+0xb8>
	
	for (i; i<Num_Button; i++)
800021c6:	2f dd       	sub	sp,-12
800021c8:	58 05       	cp.w	r5,0
800021ca:	c4 10       	breq	8000224c <ButtonConfig_brdcst_func+0xb0>
800021cc:	30 06       	mov	r6,0
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
800021ce:	4a 64       	lddpc	r4,80002264 <ButtonConfig_brdcst_func+0xc8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
800021d0:	4a 63       	lddpc	r3,80002268 <ButtonConfig_brdcst_func+0xcc>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
800021d2:	4a 72       	lddpc	r2,8000226c <ButtonConfig_brdcst_func+0xd0>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
800021d4:	4a 71       	lddpc	r1,80002270 <ButtonConfig_brdcst_func+0xd4>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
800021d6:	4a 80       	lddpc	r0,80002274 <ButtonConfig_brdcst_func+0xd8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
800021d8:	0f b9       	ld.ub	r9,r7[0x3]
800021da:	0f c8       	ld.ub	r8,r7[0x4]
800021dc:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800021e0:	1a d8       	st.w	--sp,r8
800021e2:	1a d6       	st.w	--sp,r6
800021e4:	08 9c       	mov	r12,r4
800021e6:	f0 1f 00 1c 	mcall	80002254 <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
800021ea:	0f d9       	ld.ub	r9,r7[0x5]
800021ec:	0f e8       	ld.ub	r8,r7[0x6]
800021ee:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800021f2:	1a d8       	st.w	--sp,r8
800021f4:	1a d6       	st.w	--sp,r6
800021f6:	06 9c       	mov	r12,r3
800021f8:	f0 1f 00 17 	mcall	80002254 <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
800021fc:	0f f9       	ld.ub	r9,r7[0x7]
800021fe:	ef 38 00 08 	ld.ub	r8,r7[8]
80002202:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002206:	1a d8       	st.w	--sp,r8
80002208:	1a d6       	st.w	--sp,r6
8000220a:	04 9c       	mov	r12,r2
8000220c:	f0 1f 00 12 	mcall	80002254 <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
80002210:	ef 39 00 09 	ld.ub	r9,r7[9]
80002214:	ef 38 00 0a 	ld.ub	r8,r7[10]
80002218:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000221c:	1a d8       	st.w	--sp,r8
8000221e:	1a d6       	st.w	--sp,r6
80002220:	02 9c       	mov	r12,r1
80002222:	f0 1f 00 0d 	mcall	80002254 <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
80002226:	2f 8d       	sub	sp,-32
80002228:	ef 39 00 0b 	ld.ub	r9,r7[11]
8000222c:	ef 38 00 0c 	ld.ub	r8,r7[12]
80002230:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002234:	1a d8       	st.w	--sp,r8
80002236:	1a d6       	st.w	--sp,r6
80002238:	00 9c       	mov	r12,r0
8000223a:	f0 1f 00 07 	mcall	80002254 <ButtonConfig_brdcst_func+0xb8>
8000223e:	2f f6       	sub	r6,-1
80002240:	2f 67       	sub	r7,-10
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
80002242:	2f ed       	sub	sp,-8
80002244:	ec 05 18 00 	cp.b	r5,r6
80002248:	fe 9b ff c8 	brhi	800021d8 <ButtonConfig_brdcst_func+0x3c>
8000224c:	d8 32       	popm	r0-r7,pc
8000224e:	00 00       	add	r0,r0
80002250:	80 01       	ld.sh	r1,r0[0x0]
80002252:	03 2c       	ld.uh	r12,r1++
80002254:	80 00       	ld.sh	r0,r0[0x0]
80002256:	9f 40       	st.w	pc[0x10],r0
80002258:	80 01       	ld.sh	r1,r0[0x0]
8000225a:	03 4c       	ld.w	r12,--r1
8000225c:	80 01       	ld.sh	r1,r0[0x0]
8000225e:	03 60       	ld.uh	r0,--r1
80002260:	80 01       	ld.sh	r1,r0[0x0]
80002262:	03 78       	ld.ub	r8,--r1
80002264:	80 01       	ld.sh	r1,r0[0x0]
80002266:	03 98       	ld.ub	r8,r1[0x1]
80002268:	80 01       	ld.sh	r1,r0[0x0]
8000226a:	03 c0       	ld.ub	r0,r1[0x4]
8000226c:	80 01       	ld.sh	r1,r0[0x0]
8000226e:	03 e8       	ld.ub	r8,r1[0x6]
80002270:	80 01       	ld.sh	r1,r0[0x0]
80002272:	04 0c       	add	r12,r2
80002274:	80 01       	ld.sh	r1,r0[0x0]
80002276:	04 34       	cp.w	r4,r2

80002278 <Phyuserinput_brdcst_func>:
	
}


void Phyuserinput_brdcst_func(xcmp_fragment_t * xcmp)
{
80002278:	eb cd 40 fc 	pushm	r2-r7,lr
	U16 PUI_ID =0;
	U8 PUI_State =0;
	U8 PUI_State_Min_Value =0;
	U8 PUI_State_Max_Value =0;
	
	PUI_Source = xcmp->u8[0];
8000227c:	19 a6       	ld.ub	r6,r12[0x2]
	PUI_Type = xcmp ->u8[1];
8000227e:	19 b5       	ld.ub	r5,r12[0x3]
	PUI_ID = ((xcmp->u8[2]<<8) | xcmp->u8[3]);
80002280:	19 c7       	ld.ub	r7,r12[0x4]
80002282:	19 d8       	ld.ub	r8,r12[0x5]
80002284:	f1 e7 10 87 	or	r7,r8,r7<<0x8
	PUI_State = xcmp->u8[4];
80002288:	19 e4       	ld.ub	r4,r12[0x6]
	PUI_State_Min_Value = xcmp->u8[5];
8000228a:	19 f3       	ld.ub	r3,r12[0x7]
	PUI_State_Max_Value = xcmp->u8[6];
8000228c:	f9 32 00 08 	ld.ub	r2,r12[8]
	
	log("\n\r PhysicalUserInput_broadcast  \n\r"  );
80002290:	49 0c       	lddpc	r12,800022d0 <Phyuserinput_brdcst_func+0x58>
80002292:	f0 1f 00 11 	mcall	800022d4 <Phyuserinput_brdcst_func+0x5c>
	
	log("\n\r PUI_Source: %X \n\r" , PUI_Source);
80002296:	1a d6       	st.w	--sp,r6
80002298:	49 0c       	lddpc	r12,800022d8 <Phyuserinput_brdcst_func+0x60>
8000229a:	f0 1f 00 0f 	mcall	800022d4 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_Type: %X \n\r" , PUI_Type);
8000229e:	1a d5       	st.w	--sp,r5
800022a0:	48 fc       	lddpc	r12,800022dc <Phyuserinput_brdcst_func+0x64>
800022a2:	f0 1f 00 0d 	mcall	800022d4 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_ID: %X \n\r" , PUI_ID);
800022a6:	5c 77       	castu.h	r7
800022a8:	1a d7       	st.w	--sp,r7
800022aa:	48 ec       	lddpc	r12,800022e0 <Phyuserinput_brdcst_func+0x68>
800022ac:	f0 1f 00 0a 	mcall	800022d4 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_State: %X \n\r" , PUI_State);
800022b0:	1a d4       	st.w	--sp,r4
800022b2:	48 dc       	lddpc	r12,800022e4 <Phyuserinput_brdcst_func+0x6c>
800022b4:	f0 1f 00 08 	mcall	800022d4 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_State_Min_Value: %X \n\r" , PUI_State_Min_Value);
800022b8:	1a d3       	st.w	--sp,r3
800022ba:	48 cc       	lddpc	r12,800022e8 <Phyuserinput_brdcst_func+0x70>
800022bc:	f0 1f 00 06 	mcall	800022d4 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_State_Max_Value: %X \n\r" , PUI_State_Max_Value);
800022c0:	1a d2       	st.w	--sp,r2
800022c2:	48 bc       	lddpc	r12,800022ec <Phyuserinput_brdcst_func+0x74>
800022c4:	f0 1f 00 04 	mcall	800022d4 <Phyuserinput_brdcst_func+0x5c>
800022c8:	2f ad       	sub	sp,-24
	
	
	
	
	
}
800022ca:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800022ce:	00 00       	add	r0,r0
800022d0:	80 01       	ld.sh	r1,r0[0x0]
800022d2:	04 58       	eor	r8,r2
800022d4:	80 00       	ld.sh	r0,r0[0x0]
800022d6:	9f 40       	st.w	pc[0x10],r0
800022d8:	80 01       	ld.sh	r1,r0[0x0]
800022da:	04 7c       	tst	r12,r2
800022dc:	80 01       	ld.sh	r1,r0[0x0]
800022de:	04 94       	mov	r4,r2
800022e0:	80 01       	ld.sh	r1,r0[0x0]
800022e2:	04 a8       	st.w	r2++,r8
800022e4:	80 01       	ld.sh	r1,r0[0x0]
800022e6:	04 bc       	st.h	r2++,r12
800022e8:	80 01       	ld.sh	r1,r0[0x0]
800022ea:	04 d0       	st.w	--r2,r0
800022ec:	80 01       	ld.sh	r1,r0[0x0]
800022ee:	04 f0       	st.b	--r2,r0

800022f0 <ButtonConfig_reply_func>:
	}
	
}

void ButtonConfig_reply_func(xcmp_fragment_t * xcmp)
{
800022f0:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	ButtonConfig_reply_t *ptr = (ButtonConfig_reply_t* )(xcmp->u8);
800022f4:	f8 c7 ff fe 	sub	r7,r12,-2
	if (ptr->Result == xcmp_Res_Success)
800022f8:	0f 89       	ld.ub	r9,r7[0x0]
800022fa:	30 08       	mov	r8,0
800022fc:	f0 09 18 00 	cp.b	r9,r8
80002300:	c0 c1       	brne	80002318 <ButtonConfig_reply_func+0x28>
	{
		log("\n\r Button_Config OK \n\r");
80002302:	48 9c       	lddpc	r12,80002324 <ButtonConfig_reply_func+0x34>
80002304:	f0 1f 00 09 	mcall	80002328 <ButtonConfig_reply_func+0x38>
		
		log("\n\r Function: %X \n\r" , ptr->Function );
80002308:	0f 98       	ld.ub	r8,r7[0x1]
8000230a:	1a d8       	st.w	--sp,r8
8000230c:	48 8c       	lddpc	r12,8000232c <ButtonConfig_reply_func+0x3c>
8000230e:	f0 1f 00 07 	mcall	80002328 <ButtonConfig_reply_func+0x38>
80002312:	2f fd       	sub	sp,-4
80002314:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r Button_Request error \n\r");
80002318:	48 6c       	lddpc	r12,80002330 <ButtonConfig_reply_func+0x40>
8000231a:	f0 1f 00 04 	mcall	80002328 <ButtonConfig_reply_func+0x38>
8000231e:	e3 cd 80 80 	ldm	sp++,r7,pc
80002322:	00 00       	add	r0,r0
80002324:	80 01       	ld.sh	r1,r0[0x0]
80002326:	05 10       	ld.sh	r0,r2++
80002328:	80 00       	ld.sh	r0,r0[0x0]
8000232a:	9f 40       	st.w	pc[0x10],r0
8000232c:	80 01       	ld.sh	r1,r0[0x0]
8000232e:	03 4c       	ld.w	r12,--r1
80002330:	80 01       	ld.sh	r1,r0[0x0]
80002332:	05 28       	ld.uh	r8,r2++

80002334 <DataSession_brdcst_func>:
	}
	
}

void DataSession_brdcst_func(xcmp_fragment_t * xcmp)
{
80002334:	d4 21       	pushm	r4-r7,lr
	U8 Session_number = 0;
	U16 data_length = 0;
	U8 i = 0;
	/*point to xcmp payload*/
	DataSession_brdcst_t *ptr = (DataSession_brdcst_t* )xcmp->u8;
80002336:	f8 c6 ff fe 	sub	r6,r12,-2

	if (ptr->State == CSBK_DATA_RX_Suc)
8000233a:	0d 88       	ld.ub	r8,r6[0x0]
8000233c:	32 49       	mov	r9,36
8000233e:	f2 08 18 00 	cp.b	r8,r9
80002342:	c2 91       	brne	80002394 <DataSession_brdcst_func+0x60>
	{
		
		log("\n\r CSBK_RX OK \n\r");
80002344:	49 7c       	lddpc	r12,800023a0 <DataSession_brdcst_func+0x6c>
80002346:	f0 1f 00 18 	mcall	800023a4 <DataSession_brdcst_func+0x70>
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
8000234a:	0d a5       	ld.ub	r5,r6[0x2]
8000234c:	0d b8       	ld.ub	r8,r6[0x3]
8000234e:	f1 e5 10 85 	or	r5,r8,r5<<0x8
80002352:	5c 85       	casts.h	r5

		log("\n\r Session_ID: %x \n\r",Session_number );
80002354:	0d 98       	ld.ub	r8,r6[0x1]
80002356:	1a d8       	st.w	--sp,r8
80002358:	49 4c       	lddpc	r12,800023a8 <DataSession_brdcst_func+0x74>
8000235a:	f0 1f 00 13 	mcall	800023a4 <DataSession_brdcst_func+0x70>
		log("\n\r paylaod_length: %d \n\r",data_length );
8000235e:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
80002362:	1a d8       	st.w	--sp,r8
80002364:	49 2c       	lddpc	r12,800023ac <DataSession_brdcst_func+0x78>
80002366:	f0 1f 00 10 	mcall	800023a4 <DataSession_brdcst_func+0x70>
		for(i=0; i<data_length; i++)
8000236a:	2f ed       	sub	sp,-8
8000236c:	58 05       	cp.w	r5,0
8000236e:	c1 80       	breq	8000239e <DataSession_brdcst_func+0x6a>
80002370:	30 07       	mov	r7,0
		{
			
			//log("\n\r payload[%d]: %X \n\r", i, xcmp->u8[4+i]);
			log("\n\r payload[%d]: %X \n\r", i, ptr->DataPayload.DataPayload[i]);
80002372:	49 04       	lddpc	r4,800023b0 <DataSession_brdcst_func+0x7c>
80002374:	ec 07 00 08 	add	r8,r6,r7
80002378:	11 c8       	ld.ub	r8,r8[0x4]
8000237a:	1a d8       	st.w	--sp,r8
8000237c:	1a d7       	st.w	--sp,r7
8000237e:	08 9c       	mov	r12,r4
80002380:	f0 1f 00 09 	mcall	800023a4 <DataSession_brdcst_func+0x70>
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);

		log("\n\r Session_ID: %x \n\r",Session_number );
		log("\n\r paylaod_length: %d \n\r",data_length );
		for(i=0; i<data_length; i++)
80002384:	2f f7       	sub	r7,-1
80002386:	5c 57       	castu.b	r7
80002388:	2f ed       	sub	sp,-8
8000238a:	ee 05 19 00 	cp.h	r5,r7
8000238e:	fe 9b ff f3 	brhi	80002374 <DataSession_brdcst_func+0x40>
80002392:	d8 22       	popm	r4-r7,pc
		
	}
	else
	{
		//log("\n\r State: 0x %X \n\r", xcmp->u8[0]);
		log("\n\r State: 0x %X \n\r", ptr->State);
80002394:	1a d8       	st.w	--sp,r8
80002396:	48 8c       	lddpc	r12,800023b4 <DataSession_brdcst_func+0x80>
80002398:	f0 1f 00 03 	mcall	800023a4 <DataSession_brdcst_func+0x70>
8000239c:	2f fd       	sub	sp,-4
8000239e:	d8 22       	popm	r4-r7,pc
800023a0:	80 01       	ld.sh	r1,r0[0x0]
800023a2:	05 44       	ld.w	r4,--r2
800023a4:	80 00       	ld.sh	r0,r0[0x0]
800023a6:	9f 40       	st.w	pc[0x10],r0
800023a8:	80 01       	ld.sh	r1,r0[0x0]
800023aa:	05 58       	ld.sh	r8,--r2
800023ac:	80 01       	ld.sh	r1,r0[0x0]
800023ae:	05 70       	ld.ub	r0,--r2
800023b0:	80 01       	ld.sh	r1,r0[0x0]
800023b2:	05 8c       	ld.ub	r12,r2[0x0]
800023b4:	80 01       	ld.sh	r1,r0[0x0]
800023b6:	05 a4       	ld.ub	r4,r2[0x2]

800023b8 <DataSession_reply_func>:
	
}


void DataSession_reply_func(xcmp_fragment_t * xcmp)
{
800023b8:	eb cd 40 80 	pushm	r7,lr
800023bc:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
800023be:	19 a8       	ld.ub	r8,r12[0x2]
800023c0:	58 08       	cp.w	r8,0
800023c2:	c0 61       	brne	800023ce <DataSession_reply_func+0x16>
	{
		log("\n\r DATArep OK \n\r");
800023c4:	48 dc       	lddpc	r12,800023f8 <DataSession_reply_func+0x40>
800023c6:	f0 1f 00 0e 	mcall	800023fc <DataSession_reply_func+0x44>
800023ca:	e3 cd 80 80 	ldm	sp++,r7,pc
		//log("\n\r ID: 0x %X \n\r", xcmp->u8[2]);
		
	}
	else
	{
		log("\n\r Result:  %X \n\r", xcmp->u8[0]);
800023ce:	1a d8       	st.w	--sp,r8
800023d0:	48 cc       	lddpc	r12,80002400 <DataSession_reply_func+0x48>
800023d2:	f0 1f 00 0b 	mcall	800023fc <DataSession_reply_func+0x44>
		log("\n\r DATArep error \n\r");
800023d6:	48 cc       	lddpc	r12,80002404 <DataSession_reply_func+0x4c>
800023d8:	f0 1f 00 09 	mcall	800023fc <DataSession_reply_func+0x44>
		log("\n\r Func:  %X \n\r", xcmp->u8[1]);
800023dc:	0f b8       	ld.ub	r8,r7[0x3]
800023de:	1a d8       	st.w	--sp,r8
800023e0:	48 ac       	lddpc	r12,80002408 <DataSession_reply_func+0x50>
800023e2:	f0 1f 00 07 	mcall	800023fc <DataSession_reply_func+0x44>
		log("\n\r ID:  %X \n\r", xcmp->u8[2]);
800023e6:	0f c8       	ld.ub	r8,r7[0x4]
800023e8:	1a d8       	st.w	--sp,r8
800023ea:	48 9c       	lddpc	r12,8000240c <DataSession_reply_func+0x54>
800023ec:	f0 1f 00 04 	mcall	800023fc <DataSession_reply_func+0x44>
800023f0:	2f dd       	sub	sp,-12
800023f2:	e3 cd 80 80 	ldm	sp++,r7,pc
800023f6:	00 00       	add	r0,r0
800023f8:	80 01       	ld.sh	r1,r0[0x0]
800023fa:	05 b8       	ld.ub	r8,r2[0x3]
800023fc:	80 00       	ld.sh	r0,r0[0x0]
800023fe:	9f 40       	st.w	pc[0x10],r0
80002400:	80 01       	ld.sh	r1,r0[0x0]
80002402:	05 cc       	ld.ub	r12,r2[0x4]
80002404:	80 01       	ld.sh	r1,r0[0x0]
80002406:	05 e0       	ld.ub	r0,r2[0x6]
80002408:	80 01       	ld.sh	r1,r0[0x0]
8000240a:	05 f4       	ld.ub	r4,r2[0x7]
8000240c:	80 01       	ld.sh	r1,r0[0x0]
8000240e:	06 04       	add	r4,r3

80002410 <TransmitControl_reply_func>:




void TransmitControl_reply_func(xcmp_fragment_t * xcmp)
{
80002410:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	TransmitControl_reply_t *ptr = (TransmitControl_reply_t* )xcmp->u8;
80002414:	f8 c7 ff fe 	sub	r7,r12,-2
	
	if (ptr->Result == xcmp_Res_Success)
80002418:	0f 89       	ld.ub	r9,r7[0x0]
8000241a:	30 08       	mov	r8,0
8000241c:	f0 09 18 00 	cp.b	r9,r8
80002420:	c2 21       	brne	80002464 <TransmitControl_reply_func+0x54>
	{
		
		log("\n\r  TransmitControl OK \n\r ");
80002422:	49 4c       	lddpc	r12,80002470 <TransmitControl_reply_func+0x60>
80002424:	f0 1f 00 14 	mcall	80002474 <TransmitControl_reply_func+0x64>
		log("\n\r Function: %x \n\r", ptr->Function);
80002428:	0f 98       	ld.ub	r8,r7[0x1]
8000242a:	1a d8       	st.w	--sp,r8
8000242c:	49 3c       	lddpc	r12,80002478 <TransmitControl_reply_func+0x68>
8000242e:	f0 1f 00 12 	mcall	80002474 <TransmitControl_reply_func+0x64>
		log("\n\r Mode of Operation: %x \n\r", ptr->Mode_Of_Operation);
80002432:	0f a8       	ld.ub	r8,r7[0x2]
80002434:	1a d8       	st.w	--sp,r8
80002436:	49 2c       	lddpc	r12,8000247c <TransmitControl_reply_func+0x6c>
80002438:	f0 1f 00 0f 	mcall	80002474 <TransmitControl_reply_func+0x64>
		log("\n\r State: %x \n\r", ptr->State);
8000243c:	0f b8       	ld.ub	r8,r7[0x3]
8000243e:	1a d8       	st.w	--sp,r8
80002440:	49 0c       	lddpc	r12,80002480 <TransmitControl_reply_func+0x70>
80002442:	f0 1f 00 0d 	mcall	80002474 <TransmitControl_reply_func+0x64>
		
		if (ptr->Function == KEY_UP)
80002446:	0f 98       	ld.ub	r8,r7[0x1]
80002448:	2f dd       	sub	sp,-12
8000244a:	30 19       	mov	r9,1
8000244c:	f2 08 18 00 	cp.b	r8,r9
80002450:	c0 d0       	breq	8000246a <TransmitControl_reply_func+0x5a>
		{
			//is_unmute = 1;
		}
		else if (ptr->Function ==DE_KEY)
80002452:	30 29       	mov	r9,2
80002454:	f2 08 18 00 	cp.b	r8,r9
80002458:	c0 91       	brne	8000246a <TransmitControl_reply_func+0x5a>
		{
			is_unmute = 0;
8000245a:	30 09       	mov	r9,0
8000245c:	48 a8       	lddpc	r8,80002484 <TransmitControl_reply_func+0x74>
8000245e:	b0 89       	st.b	r8[0x0],r9
80002460:	e3 cd 80 80 	ldm	sp++,r7,pc
		
		//Silent_flag = 1;
	}
	else
	{
		log("TransmitControl error");
80002464:	48 9c       	lddpc	r12,80002488 <TransmitControl_reply_func+0x78>
80002466:	f0 1f 00 04 	mcall	80002474 <TransmitControl_reply_func+0x64>
8000246a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000246e:	00 00       	add	r0,r0
80002470:	80 01       	ld.sh	r1,r0[0x0]
80002472:	06 14       	sub	r4,r3
80002474:	80 00       	ld.sh	r0,r0[0x0]
80002476:	9f 40       	st.w	pc[0x10],r0
80002478:	80 01       	ld.sh	r1,r0[0x0]
8000247a:	06 30       	cp.w	r0,r3
8000247c:	80 01       	ld.sh	r1,r0[0x0]
8000247e:	06 44       	or	r4,r3
80002480:	80 01       	ld.sh	r1,r0[0x0]
80002482:	06 60       	and	r0,r3
80002484:	00 00       	add	r0,r0
80002486:	0a 48       	or	r8,r5
80002488:	80 01       	ld.sh	r1,r0[0x0]
8000248a:	06 70       	tst	r0,r3

8000248c <AudioRoutingControl_brdcst_func>:
	}
}


void AudioRoutingControl_brdcst_func(xcmp_fragment_t * xcmp)
{
8000248c:	eb cd 40 f8 	pushm	r3-r7,lr
80002490:	18 96       	mov	r6,r12
	
	U16 num_routings = 0;
	U8 j = 0 ;
	
	num_routings = ((xcmp->u8[0]<< 8) | (xcmp->u8[1]) );
80002492:	19 a5       	ld.ub	r5,r12[0x2]
80002494:	19 b8       	ld.ub	r8,r12[0x3]
80002496:	f1 e5 10 85 	or	r5,r8,r5<<0x8
8000249a:	5c 85       	casts.h	r5
	log("\n\r num_routings: %d \n\r", num_routings);
8000249c:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
800024a0:	1a d8       	st.w	--sp,r8
800024a2:	49 6c       	lddpc	r12,800024f8 <AudioRoutingControl_brdcst_func+0x6c>
800024a4:	f0 1f 00 16 	mcall	800024fc <AudioRoutingControl_brdcst_func+0x70>
	
	for(j = 0; j< num_routings ; j++ )
800024a8:	2f fd       	sub	sp,-4
800024aa:	58 05       	cp.w	r5,0
800024ac:	c0 31       	brne	800024b2 <AudioRoutingControl_brdcst_func+0x26>
800024ae:	30 07       	mov	r7,0
800024b0:	c1 98       	rjmp	800024e2 <AudioRoutingControl_brdcst_func+0x56>
800024b2:	30 07       	mov	r7,0
	{
		
		
		log("\n\r Audio-Input: %x \n\r", xcmp->u8[2+j*2]);
800024b4:	49 34       	lddpc	r4,80002500 <AudioRoutingControl_brdcst_func+0x74>
		log("\n\r Audio-Output: %x \n\r", xcmp->u8[3+j*2]);
800024b6:	49 43       	lddpc	r3,80002504 <AudioRoutingControl_brdcst_func+0x78>
	
	for(j = 0; j< num_routings ; j++ )
	{
		
		
		log("\n\r Audio-Input: %x \n\r", xcmp->u8[2+j*2]);
800024b8:	ec 07 00 18 	add	r8,r6,r7<<0x1
800024bc:	11 c8       	ld.ub	r8,r8[0x4]
800024be:	1a d8       	st.w	--sp,r8
800024c0:	08 9c       	mov	r12,r4
800024c2:	f0 1f 00 0f 	mcall	800024fc <AudioRoutingControl_brdcst_func+0x70>
		log("\n\r Audio-Output: %x \n\r", xcmp->u8[3+j*2]);
800024c6:	ec 07 00 18 	add	r8,r6,r7<<0x1
800024ca:	11 d8       	ld.ub	r8,r8[0x5]
800024cc:	1a d8       	st.w	--sp,r8
800024ce:	06 9c       	mov	r12,r3
800024d0:	f0 1f 00 0b 	mcall	800024fc <AudioRoutingControl_brdcst_func+0x70>
	U8 j = 0 ;
	
	num_routings = ((xcmp->u8[0]<< 8) | (xcmp->u8[1]) );
	log("\n\r num_routings: %d \n\r", num_routings);
	
	for(j = 0; j< num_routings ; j++ )
800024d4:	2f f7       	sub	r7,-1
800024d6:	5c 57       	castu.b	r7
800024d8:	2f ed       	sub	sp,-8
800024da:	ee 05 19 00 	cp.h	r5,r7
800024de:	fe 9b ff ed 	brhi	800024b8 <AudioRoutingControl_brdcst_func+0x2c>
		log("\n\r Audio-Output: %x \n\r", xcmp->u8[3+j*2]);
		
		
	}
	
	log("\n\r Audio-Function: %x \n\r", xcmp->u8[3+j*2-1]);
800024e2:	ec 07 00 17 	add	r7,r6,r7<<0x1
800024e6:	0f c8       	ld.ub	r8,r7[0x4]
800024e8:	1a d8       	st.w	--sp,r8
800024ea:	48 8c       	lddpc	r12,80002508 <AudioRoutingControl_brdcst_func+0x7c>
800024ec:	f0 1f 00 04 	mcall	800024fc <AudioRoutingControl_brdcst_func+0x70>
800024f0:	2f fd       	sub	sp,-4
	
	
	
}
800024f2:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
800024f6:	00 00       	add	r0,r0
800024f8:	80 01       	ld.sh	r1,r0[0x0]
800024fa:	06 88       	andn	r8,r3
800024fc:	80 00       	ld.sh	r0,r0[0x0]
800024fe:	9f 40       	st.w	pc[0x10],r0
80002500:	80 01       	ld.sh	r1,r0[0x0]
80002502:	06 a0       	st.w	r3++,r0
80002504:	80 01       	ld.sh	r1,r0[0x0]
80002506:	06 b8       	st.h	r3++,r8
80002508:	80 01       	ld.sh	r1,r0[0x0]
8000250a:	06 d0       	st.w	--r3,r0

8000250c <AudioRoutingControl_reply_func>:
	
}


void AudioRoutingControl_reply_func(xcmp_fragment_t * xcmp)
{
8000250c:	eb cd 40 80 	pushm	r7,lr
80002510:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
80002512:	19 a9       	ld.ub	r9,r12[0x2]
80002514:	30 08       	mov	r8,0
80002516:	f0 09 18 00 	cp.b	r9,r8
8000251a:	c0 61       	brne	80002526 <AudioRoutingControl_reply_func+0x1a>
	{
		log("AudioRouting OK");
8000251c:	48 8c       	lddpc	r12,8000253c <AudioRoutingControl_reply_func+0x30>
8000251e:	f0 1f 00 09 	mcall	80002540 <AudioRoutingControl_reply_func+0x34>
80002522:	e3 cd 80 80 	ldm	sp++,r7,pc
		//is_unmute = 1;
	}
	else
	{
		log("AudioRouting error");
80002526:	48 8c       	lddpc	r12,80002544 <AudioRoutingControl_reply_func+0x38>
80002528:	f0 1f 00 06 	mcall	80002540 <AudioRoutingControl_reply_func+0x34>
		log("\n\r AudioRouting result: %x \n\r", xcmp->u8[0]);
8000252c:	0f a8       	ld.ub	r8,r7[0x2]
8000252e:	1a d8       	st.w	--sp,r8
80002530:	48 6c       	lddpc	r12,80002548 <AudioRoutingControl_reply_func+0x3c>
80002532:	f0 1f 00 04 	mcall	80002540 <AudioRoutingControl_reply_func+0x34>
80002536:	2f fd       	sub	sp,-4
80002538:	e3 cd 80 80 	ldm	sp++,r7,pc
8000253c:	80 01       	ld.sh	r1,r0[0x0]
8000253e:	06 ec       	st.h	--r3,r12
80002540:	80 00       	ld.sh	r0,r0[0x0]
80002542:	9f 40       	st.w	pc[0x10],r0
80002544:	80 01       	ld.sh	r1,r0[0x0]
80002546:	06 fc       	st.b	--r3,r12
80002548:	80 01       	ld.sh	r1,r0[0x0]
8000254a:	07 10       	ld.sh	r0,r3++

8000254c <Volume_brdcst_func>:
	
	
}

void Volume_brdcst_func(xcmp_fragment_t * xcmp)
{
8000254c:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	VolumeControl_brdcst_t *ptr = (VolumeControl_brdcst_t* )xcmp->u8;
80002550:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
80002554:	0f 89       	ld.ub	r9,r7[0x0]
80002556:	0f 98       	ld.ub	r8,r7[0x1]
80002558:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000255c:	1a d8       	st.w	--sp,r8
8000255e:	48 6c       	lddpc	r12,80002574 <Volume_brdcst_func+0x28>
80002560:	f0 1f 00 06 	mcall	80002578 <Volume_brdcst_func+0x2c>
	
	log("\n\r Audio_Parameter: %x \n\r", ptr->Audio_Parameter);
80002564:	0f b8       	ld.ub	r8,r7[0x3]
80002566:	1a d8       	st.w	--sp,r8
80002568:	48 5c       	lddpc	r12,8000257c <Volume_brdcst_func+0x30>
8000256a:	f0 1f 00 04 	mcall	80002578 <Volume_brdcst_func+0x2c>
8000256e:	2f ed       	sub	sp,-8
	
	
}
80002570:	e3 cd 80 80 	ldm	sp++,r7,pc
80002574:	80 01       	ld.sh	r1,r0[0x0]
80002576:	07 30       	ld.ub	r0,r3++
80002578:	80 00       	ld.sh	r0,r0[0x0]
8000257a:	9f 40       	st.w	pc[0x10],r0
8000257c:	80 01       	ld.sh	r1,r0[0x0]
8000257e:	07 4c       	ld.w	r12,--r3

80002580 <Volume_reply_func>:
	
}


void Volume_reply_func(xcmp_fragment_t * xcmp)
{
80002580:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	VolumeControl_reply_t *ptr = (VolumeControl_reply_t* )xcmp->u8;
80002584:	f8 c7 ff fe 	sub	r7,r12,-2
	
		if (ptr->Result == xcmp_Res_Success)
80002588:	0f 89       	ld.ub	r9,r7[0x0]
8000258a:	30 08       	mov	r8,0
8000258c:	f0 09 18 00 	cp.b	r9,r8
80002590:	c1 b1       	brne	800025c6 <Volume_reply_func+0x46>
		{
			if (ptr->Function == Enable_IntelligentAudio)
80002592:	0f b8       	ld.ub	r8,r7[0x3]
80002594:	31 09       	mov	r9,16
80002596:	f2 08 18 00 	cp.b	r8,r9
8000259a:	c0 f1       	brne	800025b8 <Volume_reply_func+0x38>
			{
				log("\n\r Enable_IA OK \n\r");
8000259c:	48 dc       	lddpc	r12,800025d0 <Volume_reply_func+0x50>
8000259e:	f0 1f 00 0e 	mcall	800025d4 <Volume_reply_func+0x54>
				log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
800025a2:	0f 99       	ld.ub	r9,r7[0x1]
800025a4:	0f a8       	ld.ub	r8,r7[0x2]
800025a6:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800025aa:	1a d8       	st.w	--sp,r8
800025ac:	48 bc       	lddpc	r12,800025d8 <Volume_reply_func+0x58>
800025ae:	f0 1f 00 0a 	mcall	800025d4 <Volume_reply_func+0x54>
800025b2:	2f fd       	sub	sp,-4
800025b4:	e3 cd 80 80 	ldm	sp++,r7,pc
	
			}
			else
			{
				
				log("\n\r VolumeControl: %x \n\r", ptr->Function);
800025b8:	1a d8       	st.w	--sp,r8
800025ba:	48 9c       	lddpc	r12,800025dc <Volume_reply_func+0x5c>
800025bc:	f0 1f 00 06 	mcall	800025d4 <Volume_reply_func+0x54>
800025c0:	2f fd       	sub	sp,-4
800025c2:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		
		else
		{
			log("\n\r Enable_IA error \n\r");
800025c6:	48 7c       	lddpc	r12,800025e0 <Volume_reply_func+0x60>
800025c8:	f0 1f 00 03 	mcall	800025d4 <Volume_reply_func+0x54>
800025cc:	e3 cd 80 80 	ldm	sp++,r7,pc
800025d0:	80 01       	ld.sh	r1,r0[0x0]
800025d2:	07 68       	ld.uh	r8,--r3
800025d4:	80 00       	ld.sh	r0,r0[0x0]
800025d6:	9f 40       	st.w	pc[0x10],r0
800025d8:	80 01       	ld.sh	r1,r0[0x0]
800025da:	07 30       	ld.ub	r0,r3++
800025dc:	80 01       	ld.sh	r1,r0[0x0]
800025de:	07 7c       	ld.ub	r12,--r3
800025e0:	80 01       	ld.sh	r1,r0[0x0]
800025e2:	07 94       	ld.ub	r4,r3[0x1]

800025e4 <spk_brdcst_func>:
		log("spk error");
	}
}

void spk_brdcst_func(xcmp_fragment_t * xcmp)
{
800025e4:	d4 01       	pushm	lr
	if (xcmp->u8[3] == xcmp_Res_Success)//0x0000:mute
800025e6:	19 d9       	ld.ub	r9,r12[0x5]
800025e8:	30 08       	mov	r8,0
800025ea:	f0 09 18 00 	cp.b	r9,r8
800025ee:	c0 91       	brne	80002600 <spk_brdcst_func+0x1c>
	{
		is_unmute =0;
800025f0:	48 89       	lddpc	r9,80002610 <spk_brdcst_func+0x2c>
800025f2:	b2 88       	st.b	r9[0x0],r8
		Silent_flag = 0;
800025f4:	48 89       	lddpc	r9,80002614 <spk_brdcst_func+0x30>
800025f6:	b2 88       	st.b	r9[0x0],r8
		log("spk_s_close ");
800025f8:	48 8c       	lddpc	r12,80002618 <spk_brdcst_func+0x34>
800025fa:	f0 1f 00 09 	mcall	8000261c <spk_brdcst_func+0x38>
800025fe:	d8 02       	popm	pc
		
		
	}
	else
	{
		Silent_flag = 1;
80002600:	30 19       	mov	r9,1
80002602:	48 58       	lddpc	r8,80002614 <spk_brdcst_func+0x30>
80002604:	b0 89       	st.b	r8[0x0],r9
		//is_unmute = 1;
		log("spk_s_open ");
80002606:	48 7c       	lddpc	r12,80002620 <spk_brdcst_func+0x3c>
80002608:	f0 1f 00 05 	mcall	8000261c <spk_brdcst_func+0x38>
8000260c:	d8 02       	popm	pc
8000260e:	00 00       	add	r0,r0
80002610:	00 00       	add	r0,r0
80002612:	0a 48       	or	r8,r5
80002614:	00 00       	add	r0,r0
80002616:	0a 50       	eor	r0,r5
80002618:	80 01       	ld.sh	r1,r0[0x0]
8000261a:	07 ac       	ld.ub	r12,r3[0x2]
8000261c:	80 00       	ld.sh	r0,r0[0x0]
8000261e:	9f 40       	st.w	pc[0x10],r0
80002620:	80 01       	ld.sh	r1,r0[0x0]
80002622:	07 bc       	ld.ub	r12,r3[0x3]

80002624 <spk_reply_func>:
			
	
}

void spk_reply_func(xcmp_fragment_t * xcmp)
{
80002624:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
80002626:	19 a9       	ld.ub	r9,r12[0x2]
80002628:	30 08       	mov	r8,0
8000262a:	f0 09 18 00 	cp.b	r9,r8
8000262e:	c0 f1       	brne	8000264c <spk_reply_func+0x28>
	{
		
		if(xcmp->u8[4])
80002630:	19 e9       	ld.ub	r9,r12[0x6]
80002632:	f0 09 18 00 	cp.b	r9,r8
80002636:	c0 40       	breq	8000263e <spk_reply_func+0x1a>
		{
			is_unmute = 1;
80002638:	30 19       	mov	r9,1
8000263a:	48 78       	lddpc	r8,80002654 <spk_reply_func+0x30>
8000263c:	b0 89       	st.b	r8[0x0],r9
			
			//Silent_flag = 1;
		}
		log("spk OK -st%2x", xcmp->u8[4] );
8000263e:	19 e8       	ld.ub	r8,r12[0x6]
80002640:	1a d8       	st.w	--sp,r8
80002642:	48 6c       	lddpc	r12,80002658 <spk_reply_func+0x34>
80002644:	f0 1f 00 06 	mcall	8000265c <spk_reply_func+0x38>
80002648:	2f fd       	sub	sp,-4
8000264a:	d8 02       	popm	pc
		
	}
	else
	{
		log("spk error");
8000264c:	48 5c       	lddpc	r12,80002660 <spk_reply_func+0x3c>
8000264e:	f0 1f 00 04 	mcall	8000265c <spk_reply_func+0x38>
80002652:	d8 02       	popm	pc
80002654:	00 00       	add	r0,r0
80002656:	0a 48       	or	r8,r5
80002658:	80 01       	ld.sh	r1,r0[0x0]
8000265a:	07 c8       	ld.ub	r8,r3[0x4]
8000265c:	80 00       	ld.sh	r0,r0[0x0]
8000265e:	9f 40       	st.w	pc[0x10],r0
80002660:	80 01       	ld.sh	r1,r0[0x0]
80002662:	07 d8       	ld.ub	r8,r3[0x5]

80002664 <mic_reply_func>:
	
	
}

void mic_reply_func(xcmp_fragment_t * xcmp)
{
80002664:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_reply_t *ptr = (MicControl_reply_t* )xcmp->u8;
80002668:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Mic_reply \n\r");
8000266c:	49 ac       	lddpc	r12,800026d4 <mic_reply_func+0x70>
8000266e:	f0 1f 00 1b 	mcall	800026d8 <mic_reply_func+0x74>
	if (ptr->Result == 0x00)
80002672:	0f 89       	ld.ub	r9,r7[0x0]
80002674:	30 08       	mov	r8,0
80002676:	f0 09 18 00 	cp.b	r9,r8
8000267a:	c2 71       	brne	800026c8 <mic_reply_func+0x64>
	{
		
		if (ptr->Function == Mic_Disable)
8000267c:	0f 98       	ld.ub	r8,r7[0x1]
8000267e:	30 29       	mov	r9,2
80002680:	f2 08 18 00 	cp.b	r8,r9
80002684:	c1 b1       	brne	800026ba <mic_reply_func+0x56>
		{
		
			log("\n\r Mic_close_ok \n\r " );
80002686:	49 6c       	lddpc	r12,800026dc <mic_reply_func+0x78>
80002688:	f0 1f 00 14 	mcall	800026d8 <mic_reply_func+0x74>
			log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
8000268c:	0f a8       	ld.ub	r8,r7[0x2]
8000268e:	1a d8       	st.w	--sp,r8
80002690:	49 4c       	lddpc	r12,800026e0 <mic_reply_func+0x7c>
80002692:	f0 1f 00 12 	mcall	800026d8 <mic_reply_func+0x74>
			log("\n\r Signaling_type: %x \n\r " ,  ptr->Signaling_Type);
80002696:	0f b8       	ld.ub	r8,r7[0x3]
80002698:	1a d8       	st.w	--sp,r8
8000269a:	49 3c       	lddpc	r12,800026e4 <mic_reply_func+0x80>
8000269c:	f0 1f 00 0f 	mcall	800026d8 <mic_reply_func+0x74>
			log("\n\r Mic_state: %x \n\r " ,  ptr->Mic_State);
800026a0:	0f c8       	ld.ub	r8,r7[0x4]
800026a2:	1a d8       	st.w	--sp,r8
800026a4:	49 1c       	lddpc	r12,800026e8 <mic_reply_func+0x84>
800026a6:	f0 1f 00 0d 	mcall	800026d8 <mic_reply_func+0x74>
			log("\n\r Gain_offset: %x \n\r " ,  ptr->Gain_Offset);
800026aa:	0f d8       	ld.ub	r8,r7[0x5]
800026ac:	1a d8       	st.w	--sp,r8
800026ae:	49 0c       	lddpc	r12,800026ec <mic_reply_func+0x88>
800026b0:	f0 1f 00 0a 	mcall	800026d8 <mic_reply_func+0x74>
800026b4:	2f cd       	sub	sp,-16
800026b6:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else
		{
			log("\n\r Mic_function: %x \n\r ", ptr->Function );
800026ba:	1a d8       	st.w	--sp,r8
800026bc:	48 dc       	lddpc	r12,800026f0 <mic_reply_func+0x8c>
800026be:	f0 1f 00 07 	mcall	800026d8 <mic_reply_func+0x74>
800026c2:	2f fd       	sub	sp,-4
800026c4:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else 
	{
		
	
		log("\n\r Mic error \n\r");
800026c8:	48 bc       	lddpc	r12,800026f4 <mic_reply_func+0x90>
800026ca:	f0 1f 00 04 	mcall	800026d8 <mic_reply_func+0x74>
800026ce:	e3 cd 80 80 	ldm	sp++,r7,pc
800026d2:	00 00       	add	r0,r0
800026d4:	80 01       	ld.sh	r1,r0[0x0]
800026d6:	07 e4       	ld.ub	r4,r3[0x6]
800026d8:	80 00       	ld.sh	r0,r0[0x0]
800026da:	9f 40       	st.w	pc[0x10],r0
800026dc:	80 01       	ld.sh	r1,r0[0x0]
800026de:	07 f4       	ld.ub	r4,r3[0x7]
800026e0:	80 01       	ld.sh	r1,r0[0x0]
800026e2:	08 08       	add	r8,r4
800026e4:	80 01       	ld.sh	r1,r0[0x0]
800026e6:	08 1c       	sub	r12,r4
800026e8:	80 01       	ld.sh	r1,r0[0x0]
800026ea:	08 38       	cp.w	r8,r4
800026ec:	80 01       	ld.sh	r1,r0[0x0]
800026ee:	08 50       	eor	r0,r4
800026f0:	80 01       	ld.sh	r1,r0[0x0]
800026f2:	08 68       	and	r8,r4
800026f4:	80 01       	ld.sh	r1,r0[0x0]
800026f6:	08 80       	andn	r0,r4

800026f8 <dcm_brdcst_func>:
	}
}


void dcm_brdcst_func(xcmp_fragment_t * xcmp)
{
800026f8:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	DeviceControlMode_brdcst_t *ptr = (DeviceControlMode_brdcst_t* )xcmp->u8;
800026fc:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Dcm_brdcst \n\r");		
80002700:	48 bc       	lddpc	r12,8000272c <dcm_brdcst_func+0x34>
80002702:	f0 1f 00 0c 	mcall	80002730 <dcm_brdcst_func+0x38>
	log("\n\r Function: %x \n\r " ,  ptr->Function);
80002706:	0f 88       	ld.ub	r8,r7[0x0]
80002708:	1a d8       	st.w	--sp,r8
8000270a:	48 bc       	lddpc	r12,80002734 <dcm_brdcst_func+0x3c>
8000270c:	f0 1f 00 09 	mcall	80002730 <dcm_brdcst_func+0x38>
	log("\n\r ControlType: %x \n\r " ,  ptr->ControlType);
80002710:	0f a8       	ld.ub	r8,r7[0x2]
80002712:	1a d8       	st.w	--sp,r8
80002714:	48 9c       	lddpc	r12,80002738 <dcm_brdcst_func+0x40>
80002716:	f0 1f 00 07 	mcall	80002730 <dcm_brdcst_func+0x38>
	log("\n\r ControlTypeSize: %x \n\r " ,  ptr->ControlTypeSize);
8000271a:	0f 98       	ld.ub	r8,r7[0x1]
8000271c:	1a d8       	st.w	--sp,r8
8000271e:	48 8c       	lddpc	r12,8000273c <dcm_brdcst_func+0x44>
80002720:	f0 1f 00 04 	mcall	80002730 <dcm_brdcst_func+0x38>
80002724:	2f dd       	sub	sp,-12
	
	
}
80002726:	e3 cd 80 80 	ldm	sp++,r7,pc
8000272a:	00 00       	add	r0,r0
8000272c:	80 01       	ld.sh	r1,r0[0x0]
8000272e:	08 90       	mov	r0,r4
80002730:	80 00       	ld.sh	r0,r0[0x0]
80002732:	9f 40       	st.w	pc[0x10],r0
80002734:	80 01       	ld.sh	r1,r0[0x0]
80002736:	08 a4       	st.w	r4++,r4
80002738:	80 01       	ld.sh	r1,r0[0x0]
8000273a:	08 b8       	st.h	r4++,r8
8000273c:	80 01       	ld.sh	r1,r0[0x0]
8000273e:	08 d0       	st.w	--r4,r0

80002740 <dcm_reply_func>:
		log("Tone error");
	}
}

void dcm_reply_func(xcmp_fragment_t * xcmp)
{
80002740:	eb cd 40 80 	pushm	r7,lr
80002744:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
80002746:	19 a9       	ld.ub	r9,r12[0x2]
80002748:	30 08       	mov	r8,0
8000274a:	f0 09 18 00 	cp.b	r9,r8
8000274e:	c1 b1       	brne	80002784 <dcm_reply_func+0x44>
	{
		if(xcmp->u8[1] == DCM_ENTER)
80002750:	19 b8       	ld.ub	r8,r12[0x3]
80002752:	30 19       	mov	r9,1
80002754:	f2 08 18 00 	cp.b	r8,r9
80002758:	c0 51       	brne	80002762 <dcm_reply_func+0x22>
		{
			log("\n\r Dcm-Enter OK \n\r");
8000275a:	48 ec       	lddpc	r12,80002790 <dcm_reply_func+0x50>
8000275c:	f0 1f 00 0e 	mcall	80002794 <dcm_reply_func+0x54>
80002760:	c0 a8       	rjmp	80002774 <dcm_reply_func+0x34>
			
		}
		else if (xcmp->u8[1] == DCM_EXIT)
80002762:	58 08       	cp.w	r8,0
80002764:	c0 51       	brne	8000276e <dcm_reply_func+0x2e>
		{
			log("\n\r Dcm-Exit OK \n\r");
80002766:	48 dc       	lddpc	r12,80002798 <dcm_reply_func+0x58>
80002768:	f0 1f 00 0b 	mcall	80002794 <dcm_reply_func+0x54>
8000276c:	c0 48       	rjmp	80002774 <dcm_reply_func+0x34>
		}
		else
		{
			log("\n\r Dcm-Revoke \n\r");
8000276e:	48 cc       	lddpc	r12,8000279c <dcm_reply_func+0x5c>
80002770:	f0 1f 00 09 	mcall	80002794 <dcm_reply_func+0x54>
		}
		
		log("dcm OK-mo%X", xcmp->u8[3]);
80002774:	0f d8       	ld.ub	r8,r7[0x5]
80002776:	1a d8       	st.w	--sp,r8
80002778:	48 ac       	lddpc	r12,800027a0 <dcm_reply_func+0x60>
8000277a:	f0 1f 00 07 	mcall	80002794 <dcm_reply_func+0x54>
8000277e:	2f fd       	sub	sp,-4
80002780:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		log("dcm error");
80002784:	48 8c       	lddpc	r12,800027a4 <dcm_reply_func+0x64>
80002786:	f0 1f 00 04 	mcall	80002794 <dcm_reply_func+0x54>
8000278a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000278e:	00 00       	add	r0,r0
80002790:	80 01       	ld.sh	r1,r0[0x0]
80002792:	08 ec       	st.h	--r4,r12
80002794:	80 00       	ld.sh	r0,r0[0x0]
80002796:	9f 40       	st.w	pc[0x10],r0
80002798:	80 01       	ld.sh	r1,r0[0x0]
8000279a:	09 00       	ld.w	r0,r4++
8000279c:	80 01       	ld.sh	r1,r0[0x0]
8000279e:	09 14       	ld.sh	r4,r4++
800027a0:	80 01       	ld.sh	r1,r0[0x0]
800027a2:	09 28       	ld.uh	r8,r4++
800027a4:	80 01       	ld.sh	r1,r0[0x0]
800027a6:	09 34       	ld.ub	r4,r4++

800027a8 <ToneControl_reply_func>:
			}
		}
}

void ToneControl_reply_func(xcmp_fragment_t * xcmp)
{
800027a8:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
800027aa:	19 a9       	ld.ub	r9,r12[0x2]
800027ac:	30 08       	mov	r8,0
800027ae:	f0 09 18 00 	cp.b	r9,r8
800027b2:	c0 51       	brne	800027bc <ToneControl_reply_func+0x14>
	{		
		log("Tone OK");
800027b4:	48 4c       	lddpc	r12,800027c4 <ToneControl_reply_func+0x1c>
800027b6:	f0 1f 00 05 	mcall	800027c8 <ToneControl_reply_func+0x20>
800027ba:	d8 02       	popm	pc
		//fl_write("/test.txt", FILE_END, (void *)"send tone ok\r\n", sizeof("send tone ok\r\n") - 1);
	}
	else
	{
		log("Tone error");
800027bc:	48 4c       	lddpc	r12,800027cc <ToneControl_reply_func+0x24>
800027be:	f0 1f 00 03 	mcall	800027c8 <ToneControl_reply_func+0x20>
800027c2:	d8 02       	popm	pc
800027c4:	80 01       	ld.sh	r1,r0[0x0]
800027c6:	09 40       	ld.w	r0,--r4
800027c8:	80 00       	ld.sh	r0,r0[0x0]
800027ca:	9f 40       	st.w	pc[0x10],r0
800027cc:	80 01       	ld.sh	r1,r0[0x0]
800027ce:	09 48       	ld.w	r8,--r4

800027d0 <app_cfg>:

extern  char AudioData[];
extern U32 tc_tick;

static __app_Thread_(app_cfg)
{
800027d0:	d4 31       	pushm	r0-r7,lr
	static  U32 isAudioRouting = 0;
	static  portTickType xLastWakeTime;
	const portTickType xFrequency = 4000;//2s,2s x  2000hz = 4000
	U8 Burst_ID = 0;
	
	 xLastWakeTime = xTaskGetTickCount();
800027d2:	f0 1f 00 22 	mcall	80002858 <app_cfg+0x88>
800027d6:	4a 28       	lddpc	r8,8000285c <app_cfg+0x8c>
800027d8:	91 0c       	st.w	r8[0x0],r12
		
	for(;;)
	{
		//if((++coun) % 200 ==0)
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003))//
800027da:	4a 27       	lddpc	r7,80002860 <app_cfg+0x90>
				{
					//xcmp_transmit_dekeycontrol();
					
				}
				
				if(isAudioRouting == 0)
800027dc:	4a 26       	lddpc	r6,80002864 <app_cfg+0x94>
						//
						//
					//}
				//
				//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
				log("\n\r un: %d \n\r", is_unmute);
800027de:	4a 35       	lddpc	r5,80002868 <app_cfg+0x98>
800027e0:	4a 34       	lddpc	r4,8000286c <app_cfg+0x9c>
				//log("\n\r S_flag: %d \n\r", Silent_flag);
				//log("\n\r Tend_flag: %d \n\r", Terminator_Flag);
			
				log("\n\r AMBE_flag: %d \n\r", AMBE_flag);
800027e2:	4a 43       	lddpc	r3,80002870 <app_cfg+0xa0>
800027e4:	4a 42       	lddpc	r2,80002874 <app_cfg+0xa4>
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_exit_enhanced_OB_mode();
					//xcmp_mute_speaker();
					//xcmp_enhanced_OB_mode();
					isAudioRouting = 4;
800027e6:	30 41       	mov	r1,4
					//xcmp_button_config();
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//log("\n\r time: %d \n\r", tc_tick);
					
					isAudioRouting = 2;
800027e8:	30 20       	mov	r0,2
	 xLastWakeTime = xTaskGetTickCount();
		
	for(;;)
	{
		//if((++coun) % 200 ==0)
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003))//
800027ea:	6e 08       	ld.w	r8,r7[0x0]
800027ec:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
800027f0:	58 38       	cp.w	r8,3
800027f2:	c2 d1       	brne	8000284c <app_cfg+0x7c>
				{
					//xcmp_transmit_dekeycontrol();
					
				}
				
				if(isAudioRouting == 0)
800027f4:	6c 08       	ld.w	r8,r6[0x0]
800027f6:	58 08       	cp.w	r8,0
800027f8:	c0 61       	brne	80002804 <app_cfg+0x34>
				{
					//xcmp_data_session();
					//xcmp_audio_route_mic();
					//xcmp_button_config();
					//xcmp_audio_route_speaker();
					xcmp_enter_device_control_mode();//3
800027fa:	f0 1f 00 20 	mcall	80002878 <app_cfg+0xa8>
					//xcmp_unmute_speaker();
					
					//is_unmute = 1;
					//xcmp_function_mic();
					
					isAudioRouting = 1;
800027fe:	30 18       	mov	r8,1
80002800:	8d 08       	st.w	r6[0x0],r8
80002802:	c1 58       	rjmp	8000282c <app_cfg+0x5c>
				}
				else if(isAudioRouting == 1)
80002804:	58 18       	cp.w	r8,1
80002806:	c0 51       	brne	80002810 <app_cfg+0x40>
				{
					//xcmp_function_mic();
					//xcmp_data_session();
				   // xcmp_transmit_control();
					//xcmp_volume_control();
					xcmp_enter_enhanced_OB_mode();
80002808:	f0 1f 00 1d 	mcall	8000287c <app_cfg+0xac>
					//xcmp_button_config();
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//log("\n\r time: %d \n\r", tc_tick);
					
					isAudioRouting = 2;
8000280c:	8d 00       	st.w	r6[0x0],r0
8000280e:	c0 f8       	rjmp	8000282c <app_cfg+0x5c>
					//isAudioRouting++;
				}
				else if(isAudioRouting == 2)
80002810:	58 28       	cp.w	r8,2
80002812:	c0 61       	brne	8000281e <app_cfg+0x4e>
				{
					
					//xcmp_volume_control();
					//xcmp_data_session();
					xcmp_audio_route_AMBE();
80002814:	f0 1f 00 1b 	mcall	80002880 <app_cfg+0xb0>
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_mute_speaker();	
					//log("\n\r time: %d \n\r", tc_tick); 
					isAudioRouting = 3;
80002818:	30 38       	mov	r8,3
8000281a:	8d 08       	st.w	r6[0x0],r8
8000281c:	c0 88       	rjmp	8000282c <app_cfg+0x5c>
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_exit_enhanced_OB_mode();
					//xcmp_mute_speaker();
					//xcmp_enhanced_OB_mode();
					isAudioRouting = 4;
8000281e:	58 38       	cp.w	r8,3
80002820:	ed f1 0a 00 	st.weq	r6[0x0],r1
					
				}
				else
				{
					isAudioRouting++;
80002824:	f7 b8 01 ff 	subne	r8,-1
80002828:	ed f8 1a 00 	st.wne	r6[0x0],r8
						//
						//
					//}
				//
				//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
				log("\n\r un: %d \n\r", is_unmute);
8000282c:	09 88       	ld.ub	r8,r4[0x0]
8000282e:	1a d8       	st.w	--sp,r8
80002830:	0a 9c       	mov	r12,r5
80002832:	f0 1f 00 15 	mcall	80002884 <app_cfg+0xb4>
				//log("\n\r S_flag: %d \n\r", Silent_flag);
				//log("\n\r Tend_flag: %d \n\r", Terminator_Flag);
			
				log("\n\r AMBE_flag: %d \n\r", AMBE_flag);
80002836:	05 88       	ld.ub	r8,r2[0x0]
80002838:	1a d8       	st.w	--sp,r8
8000283a:	06 9c       	mov	r12,r3
8000283c:	f0 1f 00 12 	mcall	80002884 <app_cfg+0xb4>
				//log("\n\r VF_SN: %x \n\r",  VF_SN);
				//log("\n\r time: %d \n\r", tc_tick);
				
				if(isAudioRouting  == 6)
80002840:	2f ed       	sub	sp,-8
80002842:	6c 08       	ld.w	r8,r6[0x0]
80002844:	58 68       	cp.w	r8,6
80002846:	c0 31       	brne	8000284c <app_cfg+0x7c>
					
					//xcmp_audio_route_speaker();
					//xcmp_enter_device_control_mode();//3
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					xcmp_exit_device_control_mode();
80002848:	f0 1f 00 10 	mcall	80002888 <app_cfg+0xb8>
			//log("testtime:%d", now->second);
		}
		//vTaskDelay(300*2 / portTICK_RATE_MS);//300ms
		//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
		
		vTaskDelayUntil( &xLastWakeTime, 2000*2 / portTICK_RATE_MS  );//2000ms
8000284c:	e0 6b 0f a0 	mov	r11,4000
80002850:	48 3c       	lddpc	r12,8000285c <app_cfg+0x8c>
80002852:	f0 1f 00 0f 	mcall	8000288c <app_cfg+0xbc>
	}
80002856:	cc ab       	rjmp	800027ea <app_cfg+0x1a>
80002858:	80 00       	ld.sh	r0,r0[0x0]
8000285a:	98 b4       	ld.uh	r4,r12[0x6]
8000285c:	00 00       	add	r0,r0
8000285e:	0a 4c       	or	r12,r5
80002860:	00 00       	add	r0,r0
80002862:	13 4c       	ld.w	r12,--r9
80002864:	00 00       	add	r0,r0
80002866:	0a 44       	or	r4,r5
80002868:	80 01       	ld.sh	r1,r0[0x0]
8000286a:	09 54       	ld.sh	r4,--r4
8000286c:	00 00       	add	r0,r0
8000286e:	0a 48       	or	r8,r5
80002870:	80 01       	ld.sh	r1,r0[0x0]
80002872:	09 64       	ld.uh	r4,--r4
80002874:	00 00       	add	r0,r0
80002876:	0a 42       	or	r2,r5
80002878:	80 00       	ld.sh	r0,r0[0x0]
8000287a:	51 60       	stdsp	sp[0x58],r0
8000287c:	80 00       	ld.sh	r0,r0[0x0]
8000287e:	51 d8       	stdsp	sp[0x74],r8
80002880:	80 00       	ld.sh	r0,r0[0x0]
80002882:	51 8c       	stdsp	sp[0x60],r12
80002884:	80 00       	ld.sh	r0,r0[0x0]
80002886:	9f 40       	st.w	pc[0x10],r0
80002888:	80 00       	ld.sh	r0,r0[0x0]
8000288a:	51 30       	stdsp	sp[0x4c],r0
8000288c:	80 00       	ld.sh	r0,r0[0x0]
8000288e:	9a 1c       	ld.sh	r12,sp[0x2]

80002890 <app_payload_tx_proc>:

}


static void app_payload_tx_proc(void  * payload)
{
80002890:	eb cd 40 80 	pushm	r7,lr
80002894:	18 97       	mov	r7,r12
  log("R");
80002896:	49 0c       	lddpc	r12,800028d4 <app_payload_tx_proc+0x44>
80002898:	f0 1f 00 10 	mcall	800028d8 <app_payload_tx_proc+0x48>
  
  if (AMBE_flag)
8000289c:	49 08       	lddpc	r8,800028dc <app_payload_tx_proc+0x4c>
8000289e:	11 89       	ld.ub	r9,r8[0x0]
800028a0:	30 08       	mov	r8,0
800028a2:	f0 09 18 00 	cp.b	r9,r8
800028a6:	c0 90       	breq	800028b8 <app_payload_tx_proc+0x28>
  {
	  fl_read("AMBEvo.bit", FILE_BEGIN, payload, MAX_PAYLOAD_BUFF_SIZE * 2);
800028a8:	e0 69 02 00 	mov	r9,512
800028ac:	0e 9a       	mov	r10,r7
800028ae:	30 0b       	mov	r11,0
800028b0:	48 cc       	lddpc	r12,800028e0 <app_payload_tx_proc+0x50>
800028b2:	f0 1f 00 0d 	mcall	800028e4 <app_payload_tx_proc+0x54>
800028b6:	c0 88       	rjmp	800028c6 <app_payload_tx_proc+0x36>
  }
  else
  {
	  fl_read("PCMvo.pcm", FILE_BEGIN, payload, MAX_PAYLOAD_BUFF_SIZE * 2);
800028b8:	e0 69 02 00 	mov	r9,512
800028bc:	0e 9a       	mov	r10,r7
800028be:	30 0b       	mov	r11,0
800028c0:	48 ac       	lddpc	r12,800028e8 <app_payload_tx_proc+0x58>
800028c2:	f0 1f 00 09 	mcall	800028e4 <app_payload_tx_proc+0x54>
  }
  
  
  set_payload_idle(payload);
800028c6:	48 a8       	lddpc	r8,800028ec <app_payload_tx_proc+0x5c>
800028c8:	70 0c       	ld.w	r12,r8[0x0]
800028ca:	0e 9b       	mov	r11,r7
800028cc:	f0 1f 00 09 	mcall	800028f0 <app_payload_tx_proc+0x60>


}
800028d0:	e3 cd 80 80 	ldm	sp++,r7,pc
800028d4:	80 01       	ld.sh	r1,r0[0x0]
800028d6:	09 78       	ld.ub	r8,--r4
800028d8:	80 00       	ld.sh	r0,r0[0x0]
800028da:	9f 40       	st.w	pc[0x10],r0
800028dc:	00 00       	add	r0,r0
800028de:	0a 42       	or	r2,r5
800028e0:	80 01       	ld.sh	r1,r0[0x0]
800028e2:	09 7c       	ld.ub	r12,--r4
800028e4:	80 00       	ld.sh	r0,r0[0x0]
800028e6:	35 74       	mov	r4,87
800028e8:	80 01       	ld.sh	r1,r0[0x0]
800028ea:	09 88       	ld.ub	r8,r4[0x0]
800028ec:	00 00       	add	r0,r0
800028ee:	10 28       	rsub	r8,r8
800028f0:	80 00       	ld.sh	r0,r0[0x0]
800028f2:	3d 2c       	mov	r12,-46

800028f4 <app_payload_rx_proc>:
	}
}


static void app_payload_rx_proc(void  * payload)
{
800028f4:	eb cd 40 80 	pushm	r7,lr
800028f8:	18 97       	mov	r7,r12
	log("\n\r w: \n\r");
800028fa:	49 0c       	lddpc	r12,80002938 <app_payload_rx_proc+0x44>
800028fc:	f0 1f 00 10 	mcall	8000293c <app_payload_rx_proc+0x48>
	if (AMBE_flag)
80002900:	49 08       	lddpc	r8,80002940 <app_payload_rx_proc+0x4c>
80002902:	11 89       	ld.ub	r9,r8[0x0]
80002904:	30 08       	mov	r8,0
80002906:	f0 09 18 00 	cp.b	r9,r8
8000290a:	c0 90       	breq	8000291c <app_payload_rx_proc+0x28>
	{
		fl_write("AMBEvo.bit", FILE_END, payload, MAX_PAYLOAD_BUFF_SIZE * 2);
8000290c:	e0 69 02 00 	mov	r9,512
80002910:	0e 9a       	mov	r10,r7
80002912:	3f fb       	mov	r11,-1
80002914:	48 cc       	lddpc	r12,80002944 <app_payload_rx_proc+0x50>
80002916:	f0 1f 00 0d 	mcall	80002948 <app_payload_rx_proc+0x54>
8000291a:	c0 88       	rjmp	8000292a <app_payload_rx_proc+0x36>
	}
	else
	{
		fl_write("PCMvo.pcm", FILE_END, payload, MAX_PAYLOAD_BUFF_SIZE * 2);
8000291c:	e0 69 02 00 	mov	r9,512
80002920:	0e 9a       	mov	r10,r7
80002922:	3f fb       	mov	r11,-1
80002924:	48 ac       	lddpc	r12,8000294c <app_payload_rx_proc+0x58>
80002926:	f0 1f 00 09 	mcall	80002948 <app_payload_rx_proc+0x54>
	}
	
	//payload_fragment_t * ptr = (payload_fragment_t *)payload;
	set_payload_idle(payload);
8000292a:	48 a8       	lddpc	r8,80002950 <app_payload_rx_proc+0x5c>
8000292c:	70 0c       	ld.w	r12,r8[0x0]
8000292e:	0e 9b       	mov	r11,r7
80002930:	f0 1f 00 09 	mcall	80002954 <app_payload_rx_proc+0x60>

}
80002934:	e3 cd 80 80 	ldm	sp++,r7,pc
80002938:	80 01       	ld.sh	r1,r0[0x0]
8000293a:	09 94       	ld.ub	r4,r4[0x1]
8000293c:	80 00       	ld.sh	r0,r0[0x0]
8000293e:	9f 40       	st.w	pc[0x10],r0
80002940:	00 00       	add	r0,r0
80002942:	0a 42       	or	r2,r5
80002944:	80 01       	ld.sh	r1,r0[0x0]
80002946:	09 7c       	ld.ub	r12,--r4
80002948:	80 00       	ld.sh	r0,r0[0x0]
8000294a:	35 fc       	mov	r12,95
8000294c:	80 01       	ld.sh	r1,r0[0x0]
8000294e:	09 88       	ld.ub	r8,r4[0x0]
80002950:	00 00       	add	r0,r0
80002952:	10 28       	rsub	r8,r8
80002954:	80 00       	ld.sh	r0,r0[0x0]
80002956:	3d 2c       	mov	r12,-46

80002958 <DeviceInitializationStatus_brdcst_func>:
static void app_payload_tx_proc(void  * payload);

//app func--list

void DeviceInitializationStatus_brdcst_func(xcmp_fragment_t  * xcmp)
{
80002958:	d4 01       	pushm	lr
	if (xcmp->u8[4] == 0x01)
8000295a:	19 e8       	ld.ub	r8,r12[0x6]
8000295c:	30 19       	mov	r9,1
8000295e:	f2 08 18 00 	cp.b	r8,r9
80002962:	c0 61       	brne	8000296e <DeviceInitializationStatus_brdcst_func+0x16>
	{
		bunchofrandomstatusflags |= 0x01;  //Need do nothing else.
80002964:	48 98       	lddpc	r8,80002988 <DeviceInitializationStatus_brdcst_func+0x30>
80002966:	70 09       	ld.w	r9,r8[0x0]
80002968:	a1 a9       	sbr	r9,0x0
8000296a:	91 09       	st.w	r8[0x0],r9
8000296c:	d8 02       	popm	pc
	}
	else if(xcmp->u8[4] != 0x02)
8000296e:	30 29       	mov	r9,2
80002970:	f2 08 18 00 	cp.b	r8,r9
80002974:	c0 80       	breq	80002984 <DeviceInitializationStatus_brdcst_func+0x2c>
	{
		bunchofrandomstatusflags  &= 0xFFFFFFFC; //Device Init no longer Complete.
80002976:	48 58       	lddpc	r8,80002988 <DeviceInitializationStatus_brdcst_func+0x30>
80002978:	70 09       	ld.w	r9,r8[0x0]
8000297a:	e0 19 ff fc 	andl	r9,0xfffc
8000297e:	91 09       	st.w	r8[0x0],r9
		xcmp_DeviceInitializationStatus_request();
80002980:	f0 1f 00 03 	mcall	8000298c <DeviceInitializationStatus_brdcst_func+0x34>
80002984:	d8 02       	popm	pc
80002986:	00 00       	add	r0,r0
80002988:	00 00       	add	r0,r0
8000298a:	13 4c       	ld.w	r12,--r9
8000298c:	80 00       	ld.sh	r0,r0[0x0]
8000298e:	51 fc       	stdsp	sp[0x7c],r12

80002990 <SD_SPI_SetSpeed>:
	
}


void SD_SPI_SetSpeed(uint16_t SPI_BaudRatePrescaler)
{
80002990:	d4 01       	pushm	lr
 

	spi->csr0 = (spi->csr0 & (uint16_t)0x00FF) |SPI_BaudRatePrescaler;
80002992:	48 78       	lddpc	r8,800029ac <SD_SPI_SetSpeed+0x1c>
80002994:	70 09       	ld.w	r9,r8[0x0]
80002996:	72 ca       	ld.w	r10,r9[0x30]
80002998:	5c 7c       	castu.h	r12
8000299a:	f5 da c0 08 	bfextu	r10,r10,0x0,0x8
8000299e:	f9 ea 10 0a 	or	r10,r12,r10
800029a2:	93 ca       	st.w	r9[0x30],r10


 
    spi_enable(spi); /*!< SD_SPI enable */
800029a4:	70 0c       	ld.w	r12,r8[0x0]
800029a6:	f0 1f 00 03 	mcall	800029b0 <SD_SPI_SetSpeed+0x20>
	
 
}
800029aa:	d8 02       	popm	pc
800029ac:	00 00       	add	r0,r0
800029ae:	13 50       	ld.sh	r0,--r9
800029b0:	80 00       	ld.sh	r0,r0[0x0]
800029b2:	5f 60       	srmi	r0

800029b4 <SD_SPI_SetSpeedHi>:

	
}

void SD_SPI_SetSpeedHi(void)
{
800029b4:	d4 01       	pushm	lr

	SD_SPI_SetSpeed(0x0100);//baudDiv=1
800029b6:	e0 6c 01 00 	mov	r12,256
800029ba:	f0 1f 00 02 	mcall	800029c0 <SD_SPI_SetSpeedHi+0xc>

}
800029be:	d8 02       	popm	pc
800029c0:	80 00       	ld.sh	r0,r0[0x0]
800029c2:	29 90       	sub	r0,-103

800029c4 <SD_SPI_SetSpeedLow>:
	
 
}

void SD_SPI_SetSpeedLow(void)
{
800029c4:	d4 01       	pushm	lr


	SD_SPI_SetSpeed(0xFF00);//baudDiv=255
800029c6:	e0 6c ff 00 	mov	r12,65280
800029ca:	f0 1f 00 02 	mcall	800029d0 <SD_SPI_SetSpeedLow+0xc>


	
}
800029ce:	d8 02       	popm	pc
800029d0:	80 00       	ld.sh	r0,r0[0x0]
800029d2:	29 90       	sub	r0,-103

800029d4 <SD_LowLevel_Init>:
  * @   SD
  * @   
  * @ 
***------------------------------------------------------*/
void SD_LowLevel_Init(void)
{
800029d4:	eb cd 40 c0 	pushm	r6-r7,lr
800029d8:	20 4d       	sub	sp,16
		.spck_delay   = 0,
		.trans_delay  = 0,
		.stay_act     = 1,
		.spi_mode     = 0,
		.modfdis      = 1
	};
800029da:	49 58       	lddpc	r8,80002a2c <SD_LowLevel_Init+0x58>
800029dc:	1a 96       	mov	r6,sp
800029de:	f0 ea 00 00 	ld.d	r10,r8[0]
800029e2:	fa eb 00 00 	st.d	sp[0],r10
800029e6:	f0 e8 00 08 	ld.d	r8,r8[8]
800029ea:	fa e9 00 08 	st.d	sp[8],r8

	// Assign I/Os to SPI.
	gpio_enable_module(SD_SPI_GPIO_MAP, sizeof(SD_SPI_GPIO_MAP) / sizeof(SD_SPI_GPIO_MAP[0]));
800029ee:	30 4b       	mov	r11,4
800029f0:	49 0c       	lddpc	r12,80002a30 <SD_LowLevel_Init+0x5c>
800029f2:	f0 1f 00 11 	mcall	80002a34 <SD_LowLevel_Init+0x60>

	spi = &AVR32_SPI;
800029f6:	49 17       	lddpc	r7,80002a38 <SD_LowLevel_Init+0x64>
800029f8:	fe 7c 24 00 	mov	r12,-56320
800029fc:	8f 0c       	st.w	r7[0x0],r12

	// Initialize as master.
	spi_initMaster(spi, &spiOptions);
800029fe:	1a 9b       	mov	r11,sp
80002a00:	f0 1f 00 0f 	mcall	80002a3c <SD_LowLevel_Init+0x68>

	// Set selection mode: variable_ps, pcs_decode, delay.
	spi_selectionMode(spi, 0, 0, 0);
80002a04:	30 09       	mov	r9,0
80002a06:	12 9a       	mov	r10,r9
80002a08:	12 9b       	mov	r11,r9
80002a0a:	6e 0c       	ld.w	r12,r7[0x0]
80002a0c:	f0 1f 00 0d 	mcall	80002a40 <SD_LowLevel_Init+0x6c>

	// Enable SPI.
	spi_enable(spi);
80002a10:	6e 0c       	ld.w	r12,r7[0x0]
80002a12:	f0 1f 00 0d 	mcall	80002a44 <SD_LowLevel_Init+0x70>

	// Initialize data flash with SPI clock PBA.
	if (spi_setupChipReg(spi, &spiOptions, SPI_Clock_PBA) != SPI_OK)
80002a16:	e0 6a 36 00 	mov	r10,13824
80002a1a:	ea 1a 01 6e 	orh	r10,0x16e
80002a1e:	1a 9b       	mov	r11,sp
80002a20:	6e 0c       	ld.w	r12,r7[0x0]
80002a22:	f0 1f 00 0a 	mcall	80002a48 <SD_LowLevel_Init+0x74>
	return;
	}


	
}
80002a26:	2f cd       	sub	sp,-16
80002a28:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002a2c:	80 01       	ld.sh	r1,r0[0x0]
80002a2e:	09 b4       	ld.ub	r4,r4[0x3]
80002a30:	80 01       	ld.sh	r1,r0[0x0]
80002a32:	09 c4       	ld.ub	r4,r4[0x4]
80002a34:	80 00       	ld.sh	r0,r0[0x0]
80002a36:	a3 e0       	*unknown*
80002a38:	00 00       	add	r0,r0
80002a3a:	13 50       	ld.sh	r0,--r9
80002a3c:	80 00       	ld.sh	r0,r0[0x0]
80002a3e:	5d c8       	*unknown*
80002a40:	80 00       	ld.sh	r0,r0[0x0]
80002a42:	5e 00       	reteq	r0
80002a44:	80 00       	ld.sh	r0,r0[0x0]
80002a46:	5f 60       	srmi	r0
80002a48:	80 00       	ld.sh	r0,r0[0x0]
80002a4a:	5e 9e       	retgt	-1

80002a4c <SD_ReadByte>:
  * @   SD
  * @    
  * @  The received byte
***------------------------------------------------------*/  
uint8_t SD_ReadByte(void)
{
80002a4c:	eb cd 40 c0 	pushm	r6-r7,lr
  unsigned short *Data ;

  //
  spi_selectChip(spi, SD_SPI_PCS_0);
80002a50:	48 b7       	lddpc	r7,80002a7c <SD_ReadByte+0x30>
80002a52:	30 0b       	mov	r11,0
80002a54:	6e 0c       	ld.w	r12,r7[0x0]
80002a56:	f0 1f 00 0b 	mcall	80002a80 <SD_ReadByte+0x34>
  
  /*!< Send the byte */

  spi_write(spi,  SD_DUMMY_BYTE);
80002a5a:	e0 6b 00 ff 	mov	r11,255
80002a5e:	6e 0c       	ld.w	r12,r7[0x0]
80002a60:	f0 1f 00 09 	mcall	80002a84 <SD_ReadByte+0x38>
  
  /*!< Return the byte read from the SPI bus */ 

   spi_read(spi, Data);
80002a64:	30 06       	mov	r6,0
80002a66:	0c 9b       	mov	r11,r6
80002a68:	6e 0c       	ld.w	r12,r7[0x0]
80002a6a:	f0 1f 00 08 	mcall	80002a88 <SD_ReadByte+0x3c>

  /*!< Return the shifted data */
  
  spi_unselectChip(spi, SD_SPI_PCS_0);
80002a6e:	0c 9b       	mov	r11,r6
80002a70:	6e 0c       	ld.w	r12,r7[0x0]
80002a72:	f0 1f 00 07 	mcall	80002a8c <SD_ReadByte+0x40>
  
  return (uint8_t)(*Data);//
}
80002a76:	0d 9c       	ld.ub	r12,r6[0x1]
80002a78:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002a7c:	00 00       	add	r0,r0
80002a7e:	13 50       	ld.sh	r0,--r9
80002a80:	80 00       	ld.sh	r0,r0[0x0]
80002a82:	5e 2c       	reths	r12
80002a84:	80 00       	ld.sh	r0,r0[0x0]
80002a86:	5f 66       	srmi	r6
80002a88:	80 00       	ld.sh	r0,r0[0x0]
80002a8a:	5f 82       	srls	r2
80002a8c:	80 00       	ld.sh	r0,r0[0x0]
80002a8e:	5e 78       	retpl	r8

80002a90 <SD_GetResponse>:
  * @retval The SD Response: 
  *         - SD_RESPONSE_FAILURE: Sequence failed
  *         - SD_RESPONSE_NO_ERROR: Sequence succeed
  */
SD_Error SD_GetResponse(uint8_t Response)
{
80002a90:	eb cd 40 c0 	pushm	r6-r7,lr
80002a94:	18 96       	mov	r6,r12
80002a96:	e0 67 8f ff 	mov	r7,36863
  uint32_t Count = 0x8FFF;

  /*!< Check if response is got or a timeout is happen */
  while ((SD_ReadByte() != Response) && Count)
80002a9a:	c0 28       	rjmp	80002a9e <SD_GetResponse+0xe>
  {
    Count--;
80002a9c:	20 17       	sub	r7,1
SD_Error SD_GetResponse(uint8_t Response)
{
  uint32_t Count = 0x8FFF;

  /*!< Check if response is got or a timeout is happen */
  while ((SD_ReadByte() != Response) && Count)
80002a9e:	f0 1f 00 09 	mcall	80002ac0 <SD_GetResponse+0x30>
80002aa2:	ec 0c 18 00 	cp.b	r12,r6
80002aa6:	c0 40       	breq	80002aae <SD_GetResponse+0x1e>
80002aa8:	58 07       	cp.w	r7,0
80002aaa:	cf 91       	brne	80002a9c <SD_GetResponse+0xc>
80002aac:	c0 58       	rjmp	80002ab6 <SD_GetResponse+0x26>
  {
    Count--;
  }
  if (Count == 0)
80002aae:	58 07       	cp.w	r7,0
80002ab0:	c0 30       	breq	80002ab6 <SD_GetResponse+0x26>
80002ab2:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
80002ab6:	e0 6c 00 ff 	mov	r12,255
  else
  {
    /*!< Right response got */
    return SD_RESPONSE_NO_ERROR;
  }
}
80002aba:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002abe:	00 00       	add	r0,r0
80002ac0:	80 00       	ld.sh	r0,r0[0x0]
80002ac2:	2a 4c       	sub	r12,-92

80002ac4 <SD_GetDataResponse>:
  *         - status 101: Data rejected due to a crc error
  *         - status 110: Data rejected due to a Write error.
  *         - status 111: Data rejected due to other error.
  */
uint8_t SD_GetDataResponse(void)
{
80002ac4:	eb cd 40 f8 	pushm	r3-r7,lr
80002ac8:	30 06       	mov	r6,0
  {
    /*!< Read resonse */
    response = SD_ReadByte();
    /*!< Mask unused bits */
    response &= 0x1F;
    switch (response)
80002aca:	30 b5       	mov	r5,11
80002acc:	30 d4       	mov	r4,13
80002ace:	30 53       	mov	r3,5
  uint8_t response, rvalue;

  while (i <= 64)
  {
    /*!< Read resonse */
    response = SD_ReadByte();
80002ad0:	f0 1f 00 0c 	mcall	80002b00 <SD_GetDataResponse+0x3c>
    /*!< Mask unused bits */
    response &= 0x1F;
80002ad4:	ef dc c0 05 	bfextu	r7,r12,0x0,0x5
    switch (response)
80002ad8:	ea 07 18 00 	cp.b	r7,r5
80002adc:	c0 e0       	breq	80002af8 <SD_GetDataResponse+0x34>
80002ade:	e8 07 18 00 	cp.b	r7,r4
80002ae2:	c0 b0       	breq	80002af8 <SD_GetDataResponse+0x34>
80002ae4:	e6 07 18 00 	cp.b	r7,r3
80002ae8:	c0 50       	breq	80002af2 <SD_GetDataResponse+0x2e>
    }
    /*!< Exit loop in case of data ok */
    if (rvalue == SD_DATA_OK)
      break;
    /*!< Increment loop counter */
    i++;
80002aea:	2f f6       	sub	r6,-1
uint8_t SD_GetDataResponse(void)
{
  uint32_t i = 0;
  uint8_t response, rvalue;

  while (i <= 64)
80002aec:	e0 46 00 41 	cp.w	r6,65
80002af0:	cf 01       	brne	80002ad0 <SD_GetDataResponse+0xc>
    /*!< Increment loop counter */
    i++;
  }

  /*!< Wait null data */
  while (SD_ReadByte() == 0);
80002af2:	f0 1f 00 04 	mcall	80002b00 <SD_GetDataResponse+0x3c>
80002af6:	cf e0       	breq	80002af2 <SD_GetDataResponse+0x2e>

  /*!< Return response */
  return response;
}
80002af8:	0e 9c       	mov	r12,r7
80002afa:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80002afe:	00 00       	add	r0,r0
80002b00:	80 00       	ld.sh	r0,r0[0x0]
80002b02:	2a 4c       	sub	r12,-92

80002b04 <SD_WriteByte>:
  * @brief  Write a byte on the SD.
  * @param  Data: byte to send.
  * @retval None
  */
uint8_t SD_WriteByte(uint8_t Data)
{
80002b04:	eb cd 40 c0 	pushm	r6-r7,lr
80002b08:	20 1d       	sub	sp,4
80002b0a:	ba 8c       	st.b	sp[0x0],r12
  uint8_t temp;
  
  //
  spi_selectChip(spi, SD_SPI_PCS_0);
80002b0c:	48 c7       	lddpc	r7,80002b3c <SD_WriteByte+0x38>
80002b0e:	30 0b       	mov	r11,0
80002b10:	6e 0c       	ld.w	r12,r7[0x0]
80002b12:	f0 1f 00 0c 	mcall	80002b40 <SD_WriteByte+0x3c>
  
  /*!< Send the byte */
  spi_write(spi,  (U16)Data);
80002b16:	1b 8b       	ld.ub	r11,sp[0x0]
80002b18:	6e 0c       	ld.w	r12,r7[0x0]
80002b1a:	f0 1f 00 0b 	mcall	80002b44 <SD_WriteByte+0x40>
  

  /*!< Wait to receive a byte*/

  temp = spi_read(spi, (U16*)&Data);
80002b1e:	1a 9b       	mov	r11,sp
80002b20:	6e 0c       	ld.w	r12,r7[0x0]
80002b22:	f0 1f 00 0a 	mcall	80002b48 <SD_WriteByte+0x44>
80002b26:	18 96       	mov	r6,r12
  
  spi_unselectChip(spi, SD_SPI_PCS_0);
80002b28:	30 0b       	mov	r11,0
80002b2a:	6e 0c       	ld.w	r12,r7[0x0]
80002b2c:	f0 1f 00 08 	mcall	80002b4c <SD_WriteByte+0x48>
  
  /*!< Return the byte read from the SPI bus */ 
  return  temp;
    
}
80002b30:	f9 d6 c0 08 	bfextu	r12,r6,0x0,0x8
80002b34:	2f fd       	sub	sp,-4
80002b36:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002b3a:	00 00       	add	r0,r0
80002b3c:	00 00       	add	r0,r0
80002b3e:	13 50       	ld.sh	r0,--r9
80002b40:	80 00       	ld.sh	r0,r0[0x0]
80002b42:	5e 2c       	reths	r12
80002b44:	80 00       	ld.sh	r0,r0[0x0]
80002b46:	5f 66       	srmi	r6
80002b48:	80 00       	ld.sh	r0,r0[0x0]
80002b4a:	5f 82       	srls	r2
80002b4c:	80 00       	ld.sh	r0,r0[0x0]
80002b4e:	5e 78       	retpl	r8

80002b50 <SD_SendCmd>:
  * @param  Arg: 
  * @param  Crc: CRC
  * @retval None
  */
void SD_SendCmd(uint8_t Cmd, uint32_t Arg, uint8_t Crc)
{
80002b50:	eb cd 40 c0 	pushm	r6-r7,lr
80002b54:	20 2d       	sub	sp,8
  uint32_t i = 0x00;
  
  uint8_t Frame[6];

  Frame[0] = (Cmd | 0x40); /*!< Construct byte 1 */
80002b56:	a7 ac       	sbr	r12,0x6
80002b58:	ba 8c       	st.b	sp[0x0],r12
  
  Frame[1] = (uint8_t)(Arg >> 24); /*!< Construct byte 2 */
80002b5a:	f6 08 16 18 	lsr	r8,r11,0x18
80002b5e:	ba 98       	st.b	sp[0x1],r8
  
  Frame[2] = (uint8_t)(Arg >> 16); /*!< Construct byte 3 */
80002b60:	f6 08 16 10 	lsr	r8,r11,0x10
80002b64:	ba a8       	st.b	sp[0x2],r8
  
  Frame[3] = (uint8_t)(Arg >> 8); /*!< Construct byte 4 */
80002b66:	f6 08 16 08 	lsr	r8,r11,0x8
80002b6a:	ba b8       	st.b	sp[0x3],r8
  
  Frame[4] = (uint8_t)(Arg); /*!< Construct byte 5 */
80002b6c:	ba cb       	st.b	sp[0x4],r11
  
  Frame[5] = (Crc); /*!< Construct CRC: byte 6 */
80002b6e:	ba da       	st.b	sp[0x5],r10
80002b70:	1a 97       	mov	r7,sp
  * @param  Cmd: .
  * @param  Arg: 
  * @param  Crc: CRC
  * @retval None
  */
void SD_SendCmd(uint8_t Cmd, uint32_t Arg, uint8_t Crc)
80002b72:	fa c6 ff fa 	sub	r6,sp,-6
  Frame[5] = (Crc); /*!< Construct CRC: byte 6 */
  
  for (i = 0; i < 6; i++)
  {

	SD_WriteByte(Frame[i]); /*!< Send the Cmd bytes */
80002b76:	0f 3c       	ld.ub	r12,r7++
80002b78:	f0 1f 00 04 	mcall	80002b88 <SD_SendCmd+0x38>
  
  Frame[4] = (uint8_t)(Arg); /*!< Construct byte 5 */
  
  Frame[5] = (Crc); /*!< Construct CRC: byte 6 */
  
  for (i = 0; i < 6; i++)
80002b7c:	0c 37       	cp.w	r7,r6
80002b7e:	cf c1       	brne	80002b76 <SD_SendCmd+0x26>
  {

	SD_WriteByte(Frame[i]); /*!< Send the Cmd bytes */

  }
}
80002b80:	2f ed       	sub	sp,-8
80002b82:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002b86:	00 00       	add	r0,r0
80002b88:	80 00       	ld.sh	r0,r0[0x0]
80002b8a:	2b 04       	sub	r4,-80

80002b8c <SD_GoIdleState>:
  * @   SD
  * @    
  * @  
***------------------------------------------------------*/
SD_Error SD_GoIdleState(void)
{
80002b8c:	d4 31       	pushm	r0-r7,lr
  uint8_t r1;
  SD_Error Status = SD_RESPONSE_NO_ERROR;
  uint16_t n2,n;

  /* CS */
  SD_CS_LOW();
80002b8e:	31 8c       	mov	r12,24
80002b90:	f0 1f 00 6a 	mcall	80002d38 <SD_GoIdleState+0x1ac>
  
  /* CM0SDSPI */
  SD_SendCmd(SD_CMD_GO_IDLE_STATE, 0, 0x95);
80002b94:	e0 6a 00 95 	mov	r10,149
80002b98:	30 0b       	mov	r11,0
80002b9a:	16 9c       	mov	r12,r11
80002b9c:	f0 1f 00 68 	mcall	80002d3c <SD_GoIdleState+0x1b0>
  
  /* 0x01 */
  if (SD_GetResponse  (SD_IN_IDLE_STATE))
80002ba0:	30 1c       	mov	r12,1
80002ba2:	f0 1f 00 68 	mcall	80002d40 <SD_GoIdleState+0x1b4>
80002ba6:	e0 81 00 a8 	brne	80002cf6 <SD_GoIdleState+0x16a>
    return SD_RESPONSE_FAILURE;
  }

  
  /*CMD8*/
  SD_SendCmd(8, 0x1AA, 0x87);
80002baa:	e0 6a 00 87 	mov	r10,135
80002bae:	e0 6b 01 aa 	mov	r11,426
80002bb2:	30 8c       	mov	r12,8
80002bb4:	f0 1f 00 62 	mcall	80002d3c <SD_GoIdleState+0x1b0>
80002bb8:	e0 67 00 c8 	mov	r7,200

  /*  */
  TimeOut = 200;
  while (((r1 = SD_ReadByte()) == 0xFF) && TimeOut)
80002bbc:	3f f6       	mov	r6,-1
80002bbe:	c0 38       	rjmp	80002bc4 <SD_GoIdleState+0x38>
  {
    TimeOut--;
80002bc0:	20 17       	sub	r7,1
80002bc2:	5c 87       	casts.h	r7
  /*CMD8*/
  SD_SendCmd(8, 0x1AA, 0x87);

  /*  */
  TimeOut = 200;
  while (((r1 = SD_ReadByte()) == 0xFF) && TimeOut)
80002bc4:	f0 1f 00 60 	mcall	80002d44 <SD_GoIdleState+0x1b8>
80002bc8:	ec 0c 18 00 	cp.b	r12,r6
80002bcc:	c0 41       	brne	80002bd4 <SD_GoIdleState+0x48>
80002bce:	58 07       	cp.w	r7,0
80002bd0:	cf 81       	brne	80002bc0 <SD_GoIdleState+0x34>
80002bd2:	c2 68       	rjmp	80002c1e <SD_GoIdleState+0x92>
  {
    TimeOut--;
  }

  if(r1 == 0x05) 
80002bd4:	30 58       	mov	r8,5
80002bd6:	f0 0c 18 00 	cp.b	r12,r8
80002bda:	c2 21       	brne	80002c1e <SD_GoIdleState+0x92>
80002bdc:	c9 48       	rjmp	80002d04 <SD_GoIdleState+0x178>
    TimeOut = 0;
    /*----------SD-----------*/
    do
    {
      /* CS*/
      SD_CS_HIGH();
80002bde:	08 9c       	mov	r12,r4
80002be0:	f0 1f 00 5a 	mcall	80002d48 <SD_GoIdleState+0x1bc>
      
      /* 0xFF */
      SD_WriteByte(SD_DUMMY_BYTE);
80002be4:	06 9c       	mov	r12,r3
80002be6:	f0 1f 00 5a 	mcall	80002d4c <SD_GoIdleState+0x1c0>
      
      /* CS */
      SD_CS_LOW();
80002bea:	08 9c       	mov	r12,r4
80002bec:	f0 1f 00 53 	mcall	80002d38 <SD_GoIdleState+0x1ac>
      
      /* CMD10x00*/
      SD_SendCmd(SD_CMD_SEND_OP_COND, 0, 0xFF);
80002bf0:	06 9a       	mov	r10,r3
80002bf2:	0a 9b       	mov	r11,r5
80002bf4:	02 9c       	mov	r12,r1
80002bf6:	f0 1f 00 52 	mcall	80002d3c <SD_GoIdleState+0x1b0>
      /* error Response0x00 */
      TimeOut++;
80002bfa:	2f f6       	sub	r6,-1
80002bfc:	5c 86       	casts.h	r6
    
      if(TimeOut == 0x00F0)
80002bfe:	e4 06 19 00 	cp.h	r6,r2
80002c02:	c0 60       	breq	80002c0e <SD_GoIdleState+0x82>
      {
        break;
      }
  	
  	Status = SD_GetResponse(SD_RESPONSE_NO_ERROR);	
80002c04:	0a 9c       	mov	r12,r5
80002c06:	f0 1f 00 4f 	mcall	80002d40 <SD_GoIdleState+0x1b4>
80002c0a:	18 97       	mov	r7,r12
    }
    while (Status);
80002c0c:	ce 91       	brne	80002bde <SD_GoIdleState+0x52>
    
    /* CS */
    SD_CS_HIGH();
80002c0e:	31 8c       	mov	r12,24
80002c10:	f0 1f 00 4e 	mcall	80002d48 <SD_GoIdleState+0x1bc>
    
    /*dummy byte 0xFF */
    SD_WriteByte(SD_DUMMY_BYTE);    
80002c14:	e0 6c 00 ff 	mov	r12,255
80002c18:	f0 1f 00 4d 	mcall	80002d4c <SD_GoIdleState+0x1c0>
80002c1c:	c6 f8       	rjmp	80002cfa <SD_GoIdleState+0x16e>
    r1 = 1;

    /* SD5 */
    for(n=0; n<5; n++)
    {
      SD_ReadByte();
80002c1e:	f0 1f 00 4a 	mcall	80002d44 <SD_GoIdleState+0x1b8>
80002c22:	f0 1f 00 49 	mcall	80002d44 <SD_GoIdleState+0x1b8>
80002c26:	f0 1f 00 48 	mcall	80002d44 <SD_GoIdleState+0x1b8>
80002c2a:	f0 1f 00 47 	mcall	80002d44 <SD_GoIdleState+0x1b8>
80002c2e:	f0 1f 00 46 	mcall	80002d44 <SD_GoIdleState+0x1b8>
    }
  
    /* CS */
    SD_CS_HIGH();
80002c32:	31 8c       	mov	r12,24
80002c34:	f0 1f 00 45 	mcall	80002d48 <SD_GoIdleState+0x1bc>
    SD_WriteByte(SD_DUMMY_BYTE);
80002c38:	e0 6c 00 ff 	mov	r12,255
80002c3c:	f0 1f 00 44 	mcall	80002d4c <SD_GoIdleState+0x1c0>
    /* CS */
    SD_CS_LOW();
80002c40:	31 8c       	mov	r12,24
80002c42:	f0 1f 00 3e 	mcall	80002d38 <SD_GoIdleState+0x1ac>
    SD_WriteByte(SD_DUMMY_BYTE);
80002c46:	e0 6c 00 ff 	mov	r12,255
80002c4a:	f0 1f 00 41 	mcall	80002d4c <SD_GoIdleState+0x1c0>
    SD_WriteByte(SD_DUMMY_BYTE);
80002c4e:	e0 6c 00 ff 	mov	r12,255
80002c52:	f0 1f 00 3f 	mcall	80002d4c <SD_GoIdleState+0x1c0>
80002c56:	e0 64 00 ff 	mov	r4,255
    n=0xff;
  
    do
    {
	  /* CMD55 */
      SD_SendCmd(55, 0, 0xFF);
80002c5a:	08 91       	mov	r1,r4
80002c5c:	30 02       	mov	r2,0
      for(n2=0; n2<0x08;n2++)
      {
       r1= SD_ReadByte();
       if(r1 !=1)
80002c5e:	30 15       	mov	r5,1
  
    do
    {
	  /* CMD55 */
      SD_SendCmd(55, 0, 0xFF);
      for(n2=0; n2<0x08;n2++)
80002c60:	30 83       	mov	r3,8

      }
	   /* CMD41 */
      SD_SendCmd(41, 0x40000000, 0);
  
      for(n2=0; n2<0xff;n2++)
80002c62:	e0 66 00 ff 	mov	r6,255
    n=0xff;
  
    do
    {
	  /* CMD55 */
      SD_SendCmd(55, 0, 0xFF);
80002c66:	02 9a       	mov	r10,r1
80002c68:	04 9b       	mov	r11,r2
80002c6a:	33 7c       	mov	r12,55
80002c6c:	f0 1f 00 34 	mcall	80002d3c <SD_GoIdleState+0x1b0>
80002c70:	04 97       	mov	r7,r2
      for(n2=0; n2<0x08;n2++)
      {
       r1= SD_ReadByte();
80002c72:	f0 1f 00 35 	mcall	80002d44 <SD_GoIdleState+0x1b8>
       if(r1 !=1)
80002c76:	f8 05 18 00 	cp.b	r5,r12
80002c7a:	f9 b4 01 00 	movne	r4,0
  
    do
    {
	  /* CMD55 */
      SD_SendCmd(55, 0, 0xFF);
      for(n2=0; n2<0x08;n2++)
80002c7e:	2f f7       	sub	r7,-1
80002c80:	5c 87       	casts.h	r7
80002c82:	e6 07 19 00 	cp.h	r7,r3
80002c86:	cf 61       	brne	80002c72 <SD_GoIdleState+0xe6>
80002c88:	08 90       	mov	r0,r4
80002c8a:	5c 80       	casts.h	r0
		   n=0;
	   }

      }
	   /* CMD41 */
      SD_SendCmd(41, 0x40000000, 0);
80002c8c:	04 9a       	mov	r10,r2
80002c8e:	fc 1b 40 00 	movh	r11,0x4000
80002c92:	32 9c       	mov	r12,41
80002c94:	f0 1f 00 2a 	mcall	80002d3c <SD_GoIdleState+0x1b0>
80002c98:	04 97       	mov	r7,r2
  
      for(n2=0; n2<0xff;n2++)
      {
       r1= SD_ReadByte();
80002c9a:	f0 1f 00 2b 	mcall	80002d44 <SD_GoIdleState+0x1b8>
       if(r1 ==0)break;
80002c9e:	c3 00       	breq	80002cfe <SD_GoIdleState+0x172>

      }
	   /* CMD41 */
      SD_SendCmd(41, 0x40000000, 0);
  
      for(n2=0; n2<0xff;n2++)
80002ca0:	2f f7       	sub	r7,-1
80002ca2:	5c 87       	casts.h	r7
80002ca4:	ec 07 19 00 	cp.h	r7,r6
80002ca8:	cf 91       	brne	80002c9a <SD_GoIdleState+0x10e>
      {
       r1= SD_ReadByte();
       if(r1 ==0)break;
      }
      n--;
80002caa:	e0 c4 00 01 	sub	r4,r0,1
80002cae:	5c 84       	casts.h	r4
    }while((r1!=0)&&(n>0));
80002cb0:	30 08       	mov	r8,0
80002cb2:	f0 0c 18 00 	cp.b	r12,r8
80002cb6:	5f 1a       	srne	r10
80002cb8:	30 09       	mov	r9,0
80002cba:	f2 04 19 00 	cp.h	r4,r9
80002cbe:	5f 19       	srne	r9
80002cc0:	f5 e9 00 09 	and	r9,r10,r9
80002cc4:	f0 09 18 00 	cp.b	r9,r8
80002cc8:	cc f1       	brne	80002c66 <SD_GoIdleState+0xda>

    if(n==0)
80002cca:	58 04       	cp.w	r4,0
80002ccc:	c1 50       	breq	80002cf6 <SD_GoIdleState+0x16a>
      //printf("\r\n SDHC\n");
    }
    else
    {
	  /* CMD58 */
      SD_SendCmd(58, 0, 0);
80002cce:	30 0a       	mov	r10,0
80002cd0:	14 9b       	mov	r11,r10
80002cd2:	33 ac       	mov	r12,58
80002cd4:	f0 1f 00 1a 	mcall	80002d3c <SD_GoIdleState+0x1b0>
      for(n=0;n<5;n++)
      {
      r1 = SD_ReadByte();
80002cd8:	f0 1f 00 1b 	mcall	80002d44 <SD_GoIdleState+0x1b8>
80002cdc:	f0 1f 00 1a 	mcall	80002d44 <SD_GoIdleState+0x1b8>
80002ce0:	f0 1f 00 19 	mcall	80002d44 <SD_GoIdleState+0x1b8>
80002ce4:	f0 1f 00 18 	mcall	80002d44 <SD_GoIdleState+0x1b8>
80002ce8:	f0 1f 00 17 	mcall	80002d44 <SD_GoIdleState+0x1b8>
      }
	  flag_SDHC = 1;
80002cec:	30 19       	mov	r9,1
80002cee:	49 98       	lddpc	r8,80002d50 <SD_GoIdleState+0x1c4>
80002cf0:	b0 89       	st.b	r8[0x0],r9
80002cf2:	30 07       	mov	r7,0
80002cf4:	c0 38       	rjmp	80002cfa <SD_GoIdleState+0x16e>
80002cf6:	e0 67 00 ff 	mov	r7,255
    //printf("\n\r SD cards inint Done.");
  }  
  */
    
  return Status;
}
80002cfa:	0e 9c       	mov	r12,r7
80002cfc:	d8 32       	popm	r0-r7,pc
      for(n2=0; n2<0xff;n2++)
      {
       r1= SD_ReadByte();
       if(r1 ==0)break;
      }
      n--;
80002cfe:	20 14       	sub	r4,1
80002d00:	5c 84       	casts.h	r4
80002d02:	ce 4b       	rjmp	80002cca <SD_GoIdleState+0x13e>
    TimeOut = 0;
    /*----------SD-----------*/
    do
    {
      /* CS*/
      SD_CS_HIGH();
80002d04:	31 8c       	mov	r12,24
80002d06:	f0 1f 00 11 	mcall	80002d48 <SD_GoIdleState+0x1bc>
      
      /* 0xFF */
      SD_WriteByte(SD_DUMMY_BYTE);
80002d0a:	e0 6c 00 ff 	mov	r12,255
80002d0e:	f0 1f 00 10 	mcall	80002d4c <SD_GoIdleState+0x1c0>
      
      /* CS */
      SD_CS_LOW();
80002d12:	31 8c       	mov	r12,24
80002d14:	f0 1f 00 09 	mcall	80002d38 <SD_GoIdleState+0x1ac>
      
      /* CMD10x00*/
      SD_SendCmd(SD_CMD_SEND_OP_COND, 0, 0xFF);
80002d18:	e0 6a 00 ff 	mov	r10,255
80002d1c:	30 0b       	mov	r11,0
80002d1e:	30 1c       	mov	r12,1
80002d20:	f0 1f 00 07 	mcall	80002d3c <SD_GoIdleState+0x1b0>
80002d24:	30 16       	mov	r6,1
      if(TimeOut == 0x00F0)
      {
        break;
      }
  	
  	Status = SD_GetResponse(SD_RESPONSE_NO_ERROR);	
80002d26:	30 05       	mov	r5,0
    TimeOut = 0;
    /*----------SD-----------*/
    do
    {
      /* CS*/
      SD_CS_HIGH();
80002d28:	31 84       	mov	r4,24
      
      /* 0xFF */
      SD_WriteByte(SD_DUMMY_BYTE);
80002d2a:	e0 63 00 ff 	mov	r3,255
      
      /* CS */
      SD_CS_LOW();
      
      /* CMD10x00*/
      SD_SendCmd(SD_CMD_SEND_OP_COND, 0, 0xFF);
80002d2e:	0c 91       	mov	r1,r6
      /* error Response0x00 */
      TimeOut++;
    
      if(TimeOut == 0x00F0)
80002d30:	e0 62 00 f0 	mov	r2,240
80002d34:	c6 8b       	rjmp	80002c04 <SD_GoIdleState+0x78>
80002d36:	00 00       	add	r0,r0
80002d38:	80 00       	ld.sh	r0,r0[0x0]
80002d3a:	a4 2c       	st.h	r2[0x4],r12
80002d3c:	80 00       	ld.sh	r0,r0[0x0]
80002d3e:	2b 50       	sub	r0,-75
80002d40:	80 00       	ld.sh	r0,r0[0x0]
80002d42:	2a 90       	sub	r0,-87
80002d44:	80 00       	ld.sh	r0,r0[0x0]
80002d46:	2a 4c       	sub	r12,-92
80002d48:	80 00       	ld.sh	r0,r0[0x0]
80002d4a:	a4 10       	st.h	r2[0x2],r0
80002d4c:	80 00       	ld.sh	r0,r0[0x0]
80002d4e:	2b 04       	sub	r4,-80
80002d50:	00 00       	add	r0,r0
80002d52:	0a 68       	and	r8,r5

80002d54 <SD_GetCIDRegister>:
  * @retval The SD Response: 
  *         - SD_RESPONSE_FAILURE: Sequence failed
  *         - SD_RESPONSE_NO_ERROR: Sequence succeed
  */
SD_Error SD_GetCIDRegister(SD_CID* SD_cid)
{
80002d54:	eb cd 40 e0 	pushm	r5-r7,lr
80002d58:	20 4d       	sub	sp,16
80002d5a:	18 97       	mov	r7,r12
  uint32_t i = 0;
  SD_Error rvalue = SD_RESPONSE_FAILURE;
  uint8_t CID_Tab[16];
  
  /*!< SD chip select low */
  SD_CS_LOW();
80002d5c:	31 8c       	mov	r12,24
80002d5e:	f0 1f 00 44 	mcall	80002e6c <SD_GetCIDRegister+0x118>
  
  /*!< Send CMD10 (CID register) */
  SD_SendCmd(SD_CMD_SEND_CID, 0, 0xFF);
80002d62:	e0 6a 00 ff 	mov	r10,255
80002d66:	30 0b       	mov	r11,0
80002d68:	30 ac       	mov	r12,10
80002d6a:	f0 1f 00 42 	mcall	80002e70 <SD_GetCIDRegister+0x11c>
  
  /*!< Wait for response in the R1 format (0x00 is no errors) */
  if (!SD_GetResponse(SD_RESPONSE_NO_ERROR))
80002d6e:	30 0c       	mov	r12,0
80002d70:	f0 1f 00 41 	mcall	80002e74 <SD_GetCIDRegister+0x120>
80002d74:	c0 40       	breq	80002d7c <SD_GetCIDRegister+0x28>
80002d76:	e0 66 00 ff 	mov	r6,255
80002d7a:	c1 78       	rjmp	80002da8 <SD_GetCIDRegister+0x54>
  {
    if (!SD_GetResponse(SD_START_DATA_SINGLE_BLOCK_READ))
80002d7c:	e0 6c 00 fe 	mov	r12,254
80002d80:	f0 1f 00 3d 	mcall	80002e74 <SD_GetCIDRegister+0x120>
80002d84:	c0 91       	brne	80002d96 <SD_GetCIDRegister+0x42>
80002d86:	1a 96       	mov	r6,sp
  * @param  SD_cid: pointer on an CID register structure
  * @retval The SD Response: 
  *         - SD_RESPONSE_FAILURE: Sequence failed
  *         - SD_RESPONSE_NO_ERROR: Sequence succeed
  */
SD_Error SD_GetCIDRegister(SD_CID* SD_cid)
80002d88:	fa c5 ff f0 	sub	r5,sp,-16
    if (!SD_GetResponse(SD_START_DATA_SINGLE_BLOCK_READ))
    {
      /*!< Store CID register value on CID_Tab */
      for (i = 0; i < 16; i++)
      {
        CID_Tab[i] = SD_ReadByte();
80002d8c:	f0 1f 00 3b 	mcall	80002e78 <SD_GetCIDRegister+0x124>
80002d90:	0c cc       	st.b	r6++,r12
  if (!SD_GetResponse(SD_RESPONSE_NO_ERROR))
  {
    if (!SD_GetResponse(SD_START_DATA_SINGLE_BLOCK_READ))
    {
      /*!< Store CID register value on CID_Tab */
      for (i = 0; i < 16; i++)
80002d92:	0a 36       	cp.w	r6,r5
80002d94:	cf c1       	brne	80002d8c <SD_GetCIDRegister+0x38>
      {
        CID_Tab[i] = SD_ReadByte();
      }
    }
    /*!< Get CRC bytes (not really needed by us, but required by SD) */
    SD_WriteByte(SD_DUMMY_BYTE);
80002d96:	e0 6c 00 ff 	mov	r12,255
80002d9a:	f0 1f 00 39 	mcall	80002e7c <SD_GetCIDRegister+0x128>
    SD_WriteByte(SD_DUMMY_BYTE);
80002d9e:	e0 6c 00 ff 	mov	r12,255
80002da2:	f0 1f 00 37 	mcall	80002e7c <SD_GetCIDRegister+0x128>
80002da6:	30 06       	mov	r6,0
    /*!< Set response value to success */
    rvalue = SD_RESPONSE_NO_ERROR;
  }
  /*!< SD chip select high */
  SD_CS_HIGH();
80002da8:	31 8c       	mov	r12,24
80002daa:	f0 1f 00 36 	mcall	80002e80 <SD_GetCIDRegister+0x12c>
  /*!< Send dummy byte: 8 Clock pulses of delay */
  SD_WriteByte(SD_DUMMY_BYTE);
80002dae:	e0 6c 00 ff 	mov	r12,255
80002db2:	f0 1f 00 33 	mcall	80002e7c <SD_GetCIDRegister+0x128>

  /*!< Byte 0 */
  SD_cid->ManufacturerID = CID_Tab[0];
80002db6:	1b 88       	ld.ub	r8,sp[0x0]
80002db8:	ae 88       	st.b	r7[0x0],r8

  /*!< Byte 1 */
  SD_cid->OEM_AppliID = CID_Tab[1] << 8;
80002dba:	fb 28 00 01 	ld.sb	r8,sp[1]
80002dbe:	a9 68       	lsl	r8,0x8
80002dc0:	ae 18       	st.h	r7[0x2],r8

  /*!< Byte 2 */
  SD_cid->OEM_AppliID |= CID_Tab[2];
80002dc2:	8e 19       	ld.sh	r9,r7[0x2]
80002dc4:	1b a8       	ld.ub	r8,sp[0x2]
80002dc6:	f3 e8 10 08 	or	r8,r9,r8
80002dca:	ae 18       	st.h	r7[0x2],r8

  /*!< Byte 3 */
  SD_cid->ProdName1 = CID_Tab[3] << 24;
80002dcc:	1b b8       	ld.ub	r8,sp[0x3]
80002dce:	b9 68       	lsl	r8,0x18
80002dd0:	8f 18       	st.w	r7[0x4],r8

  /*!< Byte 4 */
  SD_cid->ProdName1 |= CID_Tab[4] << 16;
80002dd2:	6e 18       	ld.w	r8,r7[0x4]
80002dd4:	1b c9       	ld.ub	r9,sp[0x4]
80002dd6:	f1 e9 11 08 	or	r8,r8,r9<<0x10
80002dda:	8f 18       	st.w	r7[0x4],r8

  /*!< Byte 5 */
  SD_cid->ProdName1 |= CID_Tab[5] << 8;
80002ddc:	6e 18       	ld.w	r8,r7[0x4]
80002dde:	1b d9       	ld.ub	r9,sp[0x5]
80002de0:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002de4:	8f 18       	st.w	r7[0x4],r8

  /*!< Byte 6 */
  SD_cid->ProdName1 |= CID_Tab[6];
80002de6:	6e 18       	ld.w	r8,r7[0x4]
80002de8:	1b e9       	ld.ub	r9,sp[0x6]
80002dea:	f3 e8 10 08 	or	r8,r9,r8
80002dee:	8f 18       	st.w	r7[0x4],r8

  /*!< Byte 7 */
  SD_cid->ProdName2 = CID_Tab[7];
80002df0:	1b f8       	ld.ub	r8,sp[0x7]
80002df2:	ef 68 00 08 	st.b	r7[8],r8

  /*!< Byte 8 */
  SD_cid->ProdRev = CID_Tab[8];
80002df6:	fb 38 00 08 	ld.ub	r8,sp[8]
80002dfa:	ef 68 00 09 	st.b	r7[9],r8

  /*!< Byte 9 */
  SD_cid->ProdSN = CID_Tab[9] << 24;
80002dfe:	fb 38 00 09 	ld.ub	r8,sp[9]
80002e02:	b9 68       	lsl	r8,0x18
80002e04:	8f 38       	st.w	r7[0xc],r8

  /*!< Byte 10 */
  SD_cid->ProdSN |= CID_Tab[10] << 16;
80002e06:	6e 38       	ld.w	r8,r7[0xc]
80002e08:	fb 39 00 0a 	ld.ub	r9,sp[10]
80002e0c:	f1 e9 11 08 	or	r8,r8,r9<<0x10
80002e10:	8f 38       	st.w	r7[0xc],r8

  /*!< Byte 11 */
  SD_cid->ProdSN |= CID_Tab[11] << 8;
80002e12:	6e 38       	ld.w	r8,r7[0xc]
80002e14:	fb 39 00 0b 	ld.ub	r9,sp[11]
80002e18:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002e1c:	8f 38       	st.w	r7[0xc],r8

  /*!< Byte 12 */
  SD_cid->ProdSN |= CID_Tab[12];
80002e1e:	6e 38       	ld.w	r8,r7[0xc]
80002e20:	fb 39 00 0c 	ld.ub	r9,sp[12]
80002e24:	f3 e8 10 08 	or	r8,r9,r8
80002e28:	8f 38       	st.w	r7[0xc],r8

  /*!< Byte 13 */
  SD_cid->Reserved1 |= (CID_Tab[13] & 0xF0) >> 4;
80002e2a:	ef 39 00 10 	ld.ub	r9,r7[16]
80002e2e:	fb 38 00 0d 	ld.ub	r8,sp[13]
80002e32:	f3 e8 12 49 	or	r9,r9,r8>>0x4
80002e36:	ef 69 00 10 	st.b	r7[16],r9
  SD_cid->ManufactDate = (CID_Tab[13] & 0x0F) << 8;
80002e3a:	a9 68       	lsl	r8,0x8
80002e3c:	e2 18 0f 00 	andl	r8,0xf00,COH
80002e40:	ef 58 00 12 	st.h	r7[18],r8

  /*!< Byte 14 */
  SD_cid->ManufactDate |= CID_Tab[14];
80002e44:	ef 09 00 12 	ld.sh	r9,r7[18]
80002e48:	fb 38 00 0e 	ld.ub	r8,sp[14]
80002e4c:	f3 e8 10 08 	or	r8,r9,r8
80002e50:	ef 58 00 12 	st.h	r7[18],r8

  /*!< Byte 15 */
  SD_cid->CID_CRC = (CID_Tab[15] & 0xFE) >> 1;
80002e54:	fb 38 00 0f 	ld.ub	r8,sp[15]
80002e58:	a1 98       	lsr	r8,0x1
80002e5a:	ef 68 00 14 	st.b	r7[20],r8
  SD_cid->Reserved2 = 1;
80002e5e:	30 18       	mov	r8,1
80002e60:	ef 68 00 15 	st.b	r7[21],r8

  /*!< Return the reponse */
  return rvalue;
}
80002e64:	0c 9c       	mov	r12,r6
80002e66:	2f cd       	sub	sp,-16
80002e68:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80002e6c:	80 00       	ld.sh	r0,r0[0x0]
80002e6e:	a4 2c       	st.h	r2[0x4],r12
80002e70:	80 00       	ld.sh	r0,r0[0x0]
80002e72:	2b 50       	sub	r0,-75
80002e74:	80 00       	ld.sh	r0,r0[0x0]
80002e76:	2a 90       	sub	r0,-87
80002e78:	80 00       	ld.sh	r0,r0[0x0]
80002e7a:	2a 4c       	sub	r12,-92
80002e7c:	80 00       	ld.sh	r0,r0[0x0]
80002e7e:	2b 04       	sub	r4,-80
80002e80:	80 00       	ld.sh	r0,r0[0x0]
80002e82:	a4 10       	st.h	r2[0x2],r0

80002e84 <SD_WriteMultiBlocks>:
  * @retval The SD Response: 
  *         - SD_RESPONSE_FAILURE: Sequence failed
  *         - SD_RESPONSE_NO_ERROR: Sequence succeed
  */
SD_Error SD_WriteMultiBlocks(uint8_t* pBuffer, uint32_t WriteAddr, uint16_t BlockSize, uint32_t NumberOfBlocks)
{
80002e84:	d4 31       	pushm	r0-r7,lr
80002e86:	18 95       	mov	r5,r12
80002e88:	16 93       	mov	r3,r11
80002e8a:	14 96       	mov	r6,r10
80002e8c:	12 94       	mov	r4,r9
  uint32_t i = 0, Offset = 0;
  SD_Error rvalue = SD_RESPONSE_FAILURE;

  /*!< SD chip select low */
  SD_CS_LOW();
80002e8e:	31 8c       	mov	r12,24
80002e90:	f0 1f 00 27 	mcall	80002f2c <SD_WriteMultiBlocks+0xa8>
80002e94:	e0 67 00 ff 	mov	r7,255
  /*!< Data transfer */
  while (NumberOfBlocks--)
  {
    if(flag_SDHC == 1)
80002e98:	4a 60       	lddpc	r0,80002f30 <SD_WriteMultiBlocks+0xac>
        SD_SendCmd(SD_CMD_WRITE_SINGLE_BLOCK, (WriteAddr + Offset)/512, 0xFF);
    }
    else
    {
        /*!< Send CMD24 (SD_CMD_WRITE_SINGLE_BLOCK) to write blocks */
        SD_SendCmd(SD_CMD_WRITE_SINGLE_BLOCK, WriteAddr + Offset, 0xFF);
80002e9a:	0e 92       	mov	r2,r7
    /*!< Send dummy byte */
    SD_WriteByte(SD_DUMMY_BYTE);
    /*!< Send the data token to signify the start of the data */
    SD_WriteByte(SD_START_DATA_SINGLE_BLOCK_WRITE);
    /*!< Write the block data to SD : write count data by block */
    for (i = 0; i < BlockSize; i++)
80002e9c:	5c 76       	castu.h	r6
    Offset += 512;
    /*!< Put CRC bytes (not really needed by us, but required by SD) */
    SD_ReadByte();
    SD_ReadByte();
    /*!< Read data response */
    if (SD_GetDataResponse() == SD_DATA_OK)
80002e9e:	30 51       	mov	r1,5
  SD_Error rvalue = SD_RESPONSE_FAILURE;

  /*!< SD chip select low */
  SD_CS_LOW();
  /*!< Data transfer */
  while (NumberOfBlocks--)
80002ea0:	c3 a8       	rjmp	80002f14 <SD_WriteMultiBlocks+0x90>
  {
    if(flag_SDHC == 1)
80002ea2:	01 88       	ld.ub	r8,r0[0x0]
80002ea4:	30 19       	mov	r9,1
80002ea6:	f2 08 18 00 	cp.b	r8,r9
80002eaa:	c0 81       	brne	80002eba <SD_WriteMultiBlocks+0x36>
    {
        /* Send CMD24 (MSD_WRITE_BLOCK) to write blocks */
        SD_SendCmd(SD_CMD_WRITE_SINGLE_BLOCK, (WriteAddr + Offset)/512, 0xFF);
80002eac:	04 9a       	mov	r10,r2
80002eae:	e6 0b 16 09 	lsr	r11,r3,0x9
80002eb2:	31 8c       	mov	r12,24
80002eb4:	f0 1f 00 20 	mcall	80002f34 <SD_WriteMultiBlocks+0xb0>
80002eb8:	c0 68       	rjmp	80002ec4 <SD_WriteMultiBlocks+0x40>
    }
    else
    {
        /*!< Send CMD24 (SD_CMD_WRITE_SINGLE_BLOCK) to write blocks */
        SD_SendCmd(SD_CMD_WRITE_SINGLE_BLOCK, WriteAddr + Offset, 0xFF);
80002eba:	04 9a       	mov	r10,r2
80002ebc:	06 9b       	mov	r11,r3
80002ebe:	31 8c       	mov	r12,24
80002ec0:	f0 1f 00 1d 	mcall	80002f34 <SD_WriteMultiBlocks+0xb0>
    }
    /*!< Check if the SD acknowledged the write block command: R1 response (0x00: no errors) */
    if (SD_GetResponse(SD_RESPONSE_NO_ERROR))
80002ec4:	30 0c       	mov	r12,0
80002ec6:	f0 1f 00 1d 	mcall	80002f38 <SD_WriteMultiBlocks+0xb4>
80002eca:	c0 40       	breq	80002ed2 <SD_WriteMultiBlocks+0x4e>
80002ecc:	e0 67 00 ff 	mov	r7,255
80002ed0:	c2 b8       	rjmp	80002f26 <SD_WriteMultiBlocks+0xa2>
    {
      return SD_RESPONSE_FAILURE;
    }
    /*!< Send dummy byte */
    SD_WriteByte(SD_DUMMY_BYTE);
80002ed2:	04 9c       	mov	r12,r2
80002ed4:	f0 1f 00 1a 	mcall	80002f3c <SD_WriteMultiBlocks+0xb8>
    /*!< Send the data token to signify the start of the data */
    SD_WriteByte(SD_START_DATA_SINGLE_BLOCK_WRITE);
80002ed8:	e0 6c 00 fe 	mov	r12,254
80002edc:	f0 1f 00 18 	mcall	80002f3c <SD_WriteMultiBlocks+0xb8>
    /*!< Write the block data to SD : write count data by block */
    for (i = 0; i < BlockSize; i++)
80002ee0:	58 06       	cp.w	r6,0
80002ee2:	c0 a0       	breq	80002ef6 <SD_WriteMultiBlocks+0x72>
80002ee4:	30 07       	mov	r7,0
    {
      /*!< Send the pointed byte */
      SD_WriteByte(*pBuffer);
80002ee6:	ea 07 07 0c 	ld.ub	r12,r5[r7]
80002eea:	f0 1f 00 15 	mcall	80002f3c <SD_WriteMultiBlocks+0xb8>
    /*!< Send dummy byte */
    SD_WriteByte(SD_DUMMY_BYTE);
    /*!< Send the data token to signify the start of the data */
    SD_WriteByte(SD_START_DATA_SINGLE_BLOCK_WRITE);
    /*!< Write the block data to SD : write count data by block */
    for (i = 0; i < BlockSize; i++)
80002eee:	2f f7       	sub	r7,-1
80002ef0:	0c 37       	cp.w	r7,r6
80002ef2:	cf a3       	brcs	80002ee6 <SD_WriteMultiBlocks+0x62>
80002ef4:	0c 05       	add	r5,r6
      pBuffer++;
    }
    /*!< Set next write address */
    Offset += 512;
    /*!< Put CRC bytes (not really needed by us, but required by SD) */
    SD_ReadByte();
80002ef6:	f0 1f 00 13 	mcall	80002f40 <SD_WriteMultiBlocks+0xbc>
    SD_ReadByte();
80002efa:	f0 1f 00 12 	mcall	80002f40 <SD_WriteMultiBlocks+0xbc>
    /*!< Read data response */
    if (SD_GetDataResponse() == SD_DATA_OK)
80002efe:	f0 1f 00 12 	mcall	80002f44 <SD_WriteMultiBlocks+0xc0>
80002f02:	f8 01 18 00 	cp.b	r1,r12
80002f06:	f9 b7 00 00 	moveq	r7,0
80002f0a:	e4 07 17 10 	movne	r7,r2
80002f0e:	20 14       	sub	r4,1
80002f10:	e6 c3 fe 00 	sub	r3,r3,-512
  SD_Error rvalue = SD_RESPONSE_FAILURE;

  /*!< SD chip select low */
  SD_CS_LOW();
  /*!< Data transfer */
  while (NumberOfBlocks--)
80002f14:	58 04       	cp.w	r4,0
80002f16:	cc 61       	brne	80002ea2 <SD_WriteMultiBlocks+0x1e>
      /*!< Set response value to failure */
      rvalue = SD_RESPONSE_FAILURE;
    }
  }
  /*!< SD chip select high */
  SD_CS_HIGH();
80002f18:	31 8c       	mov	r12,24
80002f1a:	f0 1f 00 0c 	mcall	80002f48 <SD_WriteMultiBlocks+0xc4>
  /*!< Send dummy byte: 8 Clock pulses of delay */
  SD_WriteByte(SD_DUMMY_BYTE);
80002f1e:	e0 6c 00 ff 	mov	r12,255
80002f22:	f0 1f 00 07 	mcall	80002f3c <SD_WriteMultiBlocks+0xb8>
  /*!< Returns the reponse */
  return rvalue;
}
80002f26:	0e 9c       	mov	r12,r7
80002f28:	d8 32       	popm	r0-r7,pc
80002f2a:	00 00       	add	r0,r0
80002f2c:	80 00       	ld.sh	r0,r0[0x0]
80002f2e:	a4 2c       	st.h	r2[0x4],r12
80002f30:	00 00       	add	r0,r0
80002f32:	0a 68       	and	r8,r5
80002f34:	80 00       	ld.sh	r0,r0[0x0]
80002f36:	2b 50       	sub	r0,-75
80002f38:	80 00       	ld.sh	r0,r0[0x0]
80002f3a:	2a 90       	sub	r0,-87
80002f3c:	80 00       	ld.sh	r0,r0[0x0]
80002f3e:	2b 04       	sub	r4,-80
80002f40:	80 00       	ld.sh	r0,r0[0x0]
80002f42:	2a 4c       	sub	r12,-92
80002f44:	80 00       	ld.sh	r0,r0[0x0]
80002f46:	2a c4       	sub	r4,-84
80002f48:	80 00       	ld.sh	r0,r0[0x0]
80002f4a:	a4 10       	st.h	r2[0x2],r0

80002f4c <SD_WriteBlock>:
  * @retval The SD Response: 
  *         - SD_RESPONSE_FAILURE: Sequence failed
  *         - SD_RESPONSE_NO_ERROR: Sequence succeed
  */
SD_Error SD_WriteBlock(uint8_t* pBuffer, uint32_t WriteAddr, uint16_t BlockSize)
{
80002f4c:	eb cd 40 e0 	pushm	r5-r7,lr
80002f50:	18 95       	mov	r5,r12
80002f52:	16 97       	mov	r7,r11
80002f54:	14 96       	mov	r6,r10
  uint32_t i = 0;
  SD_Error rvalue = SD_RESPONSE_FAILURE;

  /*!< SD chip select low */
  SD_CS_LOW();
80002f56:	31 8c       	mov	r12,24
80002f58:	f0 1f 00 1f 	mcall	80002fd4 <SD_WriteBlock+0x88>

  if(flag_SDHC == 1)
80002f5c:	49 f8       	lddpc	r8,80002fd8 <SD_WriteBlock+0x8c>
80002f5e:	11 89       	ld.ub	r9,r8[0x0]
80002f60:	30 18       	mov	r8,1
80002f62:	f0 09 18 00 	cp.b	r9,r8
80002f66:	c0 21       	brne	80002f6a <SD_WriteBlock+0x1e>
  {
  	WriteAddr = WriteAddr/512;
80002f68:	a9 97       	lsr	r7,0x9
  }
  /*!< Send CMD24 (SD_CMD_WRITE_SINGLE_BLOCK) to write multiple block */
  SD_SendCmd(SD_CMD_WRITE_SINGLE_BLOCK, WriteAddr, 0xFF);
80002f6a:	e0 6a 00 ff 	mov	r10,255
80002f6e:	0e 9b       	mov	r11,r7
80002f70:	31 8c       	mov	r12,24
80002f72:	f0 1f 00 1b 	mcall	80002fdc <SD_WriteBlock+0x90>
  
  /*!< Check if the SD acknowledged the write block command: R1 response (0x00: no errors) */
  if (!SD_GetResponse(SD_RESPONSE_NO_ERROR))
80002f76:	30 0c       	mov	r12,0
80002f78:	f0 1f 00 1a 	mcall	80002fe0 <SD_WriteBlock+0x94>
80002f7c:	c1 f1       	brne	80002fba <SD_WriteBlock+0x6e>
  {
    /*!< Send a dummy byte */
    SD_WriteByte(SD_DUMMY_BYTE);
80002f7e:	e0 6c 00 ff 	mov	r12,255
80002f82:	f0 1f 00 19 	mcall	80002fe4 <SD_WriteBlock+0x98>

    /*!< Send the data token to signify the start of the data */
    SD_WriteByte(0xFE);
80002f86:	e0 6c 00 fe 	mov	r12,254
80002f8a:	f0 1f 00 17 	mcall	80002fe4 <SD_WriteBlock+0x98>

    /*!< Write the block data to SD : write count data by block */
    for (i = 0; i < BlockSize; i++)
80002f8e:	5c 76       	castu.h	r6
80002f90:	c0 90       	breq	80002fa2 <SD_WriteBlock+0x56>
80002f92:	30 07       	mov	r7,0
    {
      /*!< Send the pointed byte */
      SD_WriteByte(*pBuffer);
80002f94:	ea 07 07 0c 	ld.ub	r12,r5[r7]
80002f98:	f0 1f 00 13 	mcall	80002fe4 <SD_WriteBlock+0x98>

    /*!< Send the data token to signify the start of the data */
    SD_WriteByte(0xFE);

    /*!< Write the block data to SD : write count data by block */
    for (i = 0; i < BlockSize; i++)
80002f9c:	2f f7       	sub	r7,-1
80002f9e:	0c 37       	cp.w	r7,r6
80002fa0:	cf a3       	brcs	80002f94 <SD_WriteBlock+0x48>
      SD_WriteByte(*pBuffer);
      /*!< Point to the next location where the byte read will be saved */
      pBuffer++;
    }
    /*!< Put CRC bytes (not really needed by us, but required by SD) */
    SD_ReadByte();
80002fa2:	f0 1f 00 12 	mcall	80002fe8 <SD_WriteBlock+0x9c>
    SD_ReadByte();
80002fa6:	f0 1f 00 11 	mcall	80002fe8 <SD_WriteBlock+0x9c>

    /*!< Read data response */
    if (SD_GetDataResponse() == SD_DATA_OK)
80002faa:	f0 1f 00 11 	mcall	80002fec <SD_WriteBlock+0xa0>
80002fae:	30 58       	mov	r8,5
80002fb0:	f0 0c 18 00 	cp.b	r12,r8
80002fb4:	c0 31       	brne	80002fba <SD_WriteBlock+0x6e>
80002fb6:	30 07       	mov	r7,0
80002fb8:	c0 38       	rjmp	80002fbe <SD_WriteBlock+0x72>
80002fba:	e0 67 00 ff 	mov	r7,255
    {
      rvalue = SD_RESPONSE_NO_ERROR;
    }
  }
  /*!< SD chip select high */
  SD_CS_HIGH();
80002fbe:	31 8c       	mov	r12,24
80002fc0:	f0 1f 00 0c 	mcall	80002ff0 <SD_WriteBlock+0xa4>
  /*!< Send dummy byte: 8 Clock pulses of delay */
  SD_WriteByte(SD_DUMMY_BYTE);
80002fc4:	e0 6c 00 ff 	mov	r12,255
80002fc8:	f0 1f 00 07 	mcall	80002fe4 <SD_WriteBlock+0x98>

  /*!< Returns the reponse */
  return rvalue;
}
80002fcc:	0e 9c       	mov	r12,r7
80002fce:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80002fd2:	00 00       	add	r0,r0
80002fd4:	80 00       	ld.sh	r0,r0[0x0]
80002fd6:	a4 2c       	st.h	r2[0x4],r12
80002fd8:	00 00       	add	r0,r0
80002fda:	0a 68       	and	r8,r5
80002fdc:	80 00       	ld.sh	r0,r0[0x0]
80002fde:	2b 50       	sub	r0,-75
80002fe0:	80 00       	ld.sh	r0,r0[0x0]
80002fe2:	2a 90       	sub	r0,-87
80002fe4:	80 00       	ld.sh	r0,r0[0x0]
80002fe6:	2b 04       	sub	r4,-80
80002fe8:	80 00       	ld.sh	r0,r0[0x0]
80002fea:	2a 4c       	sub	r12,-92
80002fec:	80 00       	ld.sh	r0,r0[0x0]
80002fee:	2a c4       	sub	r4,-84
80002ff0:	80 00       	ld.sh	r0,r0[0x0]
80002ff2:	a4 10       	st.h	r2[0x2],r0

80002ff4 <SD_ReadMultiBlocks>:
  * @retval The SD Response:
  *         - SD_RESPONSE_FAILURE: Sequence failed
  *         - SD_RESPONSE_NO_ERROR: Sequence succeed
  */
SD_Error SD_ReadMultiBlocks(uint8_t* pBuffer, uint32_t ReadAddr, uint16_t BlockSize, uint32_t NumberOfBlocks)
{
80002ff4:	d4 31       	pushm	r0-r7,lr
80002ff6:	20 1d       	sub	sp,4
80002ff8:	18 95       	mov	r5,r12
80002ffa:	50 0b       	stdsp	sp[0x0],r11
80002ffc:	14 96       	mov	r6,r10
80002ffe:	12 94       	mov	r4,r9
  uint32_t i = 0, Offset = 0;
  SD_Error rvalue = SD_RESPONSE_FAILURE;
  
  /*!< SD chip select low */
  SD_CS_LOW();
80003000:	31 8c       	mov	r12,24
80003002:	f0 1f 00 27 	mcall	8000309c <SD_ReadMultiBlocks+0xa8>
80003006:	e0 67 00 ff 	mov	r7,255
8000300a:	30 02       	mov	r2,0
  /*!< Data transfer */
  while (NumberOfBlocks--)
  {
    if(flag_SDHC == 1)
8000300c:	4a 53       	lddpc	r3,800030a0 <SD_ReadMultiBlocks+0xac>
        SD_SendCmd (SD_CMD_READ_SINGLE_BLOCK,(ReadAddr + Offset)/512, 0xFF);
    }
    else
    {
        /*!< Send CMD17 (SD_CMD_READ_SINGLE_BLOCK) to read one block */
        SD_SendCmd (SD_CMD_READ_SINGLE_BLOCK, ReadAddr + Offset, 0xFF);
8000300e:	0e 90       	mov	r0,r7
    }
    /*!< Check if the SD acknowledged the read block command: R1 response (0x00: no errors) */
    if (SD_GetResponse(SD_RESPONSE_NO_ERROR))
80003010:	04 91       	mov	r1,r2
    }
    /*!< Now look for the data token to signify the start of the data */
    if (!SD_GetResponse(SD_START_DATA_SINGLE_BLOCK_READ))
    {
      /*!< Read the SD block data : read NumByteToRead data */
      for (i = 0; i < BlockSize; i++)
80003012:	5c 76       	castu.h	r6
  SD_Error rvalue = SD_RESPONSE_FAILURE;
  
  /*!< SD chip select low */
  SD_CS_LOW();
  /*!< Data transfer */
  while (NumberOfBlocks--)
80003014:	c3 78       	rjmp	80003082 <SD_ReadMultiBlocks+0x8e>
  {
    if(flag_SDHC == 1)
80003016:	07 88       	ld.ub	r8,r3[0x0]
80003018:	30 19       	mov	r9,1
8000301a:	f2 08 18 00 	cp.b	r8,r9
8000301e:	c0 a1       	brne	80003032 <SD_ReadMultiBlocks+0x3e>
    {
        /*!< Send CMD17 (SD_CMD_READ_SINGLE_BLOCK) to read one block */
        SD_SendCmd (SD_CMD_READ_SINGLE_BLOCK,(ReadAddr + Offset)/512, 0xFF);
80003020:	40 08       	lddsp	r8,sp[0x0]
80003022:	e4 08 00 0b 	add	r11,r2,r8
80003026:	00 9a       	mov	r10,r0
80003028:	a9 9b       	lsr	r11,0x9
8000302a:	31 1c       	mov	r12,17
8000302c:	f0 1f 00 1e 	mcall	800030a4 <SD_ReadMultiBlocks+0xb0>
80003030:	c0 88       	rjmp	80003040 <SD_ReadMultiBlocks+0x4c>
    }
    else
    {
        /*!< Send CMD17 (SD_CMD_READ_SINGLE_BLOCK) to read one block */
        SD_SendCmd (SD_CMD_READ_SINGLE_BLOCK, ReadAddr + Offset, 0xFF);
80003032:	00 9a       	mov	r10,r0
80003034:	40 09       	lddsp	r9,sp[0x0]
80003036:	e4 09 00 0b 	add	r11,r2,r9
8000303a:	31 1c       	mov	r12,17
8000303c:	f0 1f 00 1a 	mcall	800030a4 <SD_ReadMultiBlocks+0xb0>
    }
    /*!< Check if the SD acknowledged the read block command: R1 response (0x00: no errors) */
    if (SD_GetResponse(SD_RESPONSE_NO_ERROR))
80003040:	02 9c       	mov	r12,r1
80003042:	f0 1f 00 1a 	mcall	800030a8 <SD_ReadMultiBlocks+0xb4>
80003046:	c0 40       	breq	8000304e <SD_ReadMultiBlocks+0x5a>
80003048:	e0 67 00 ff 	mov	r7,255
8000304c:	c2 48       	rjmp	80003094 <SD_ReadMultiBlocks+0xa0>
    {
      return  SD_RESPONSE_FAILURE;
    }
    /*!< Now look for the data token to signify the start of the data */
    if (!SD_GetResponse(SD_START_DATA_SINGLE_BLOCK_READ))
8000304e:	e0 6c 00 fe 	mov	r12,254
80003052:	f0 1f 00 16 	mcall	800030a8 <SD_ReadMultiBlocks+0xb4>
80003056:	c0 30       	breq	8000305c <SD_ReadMultiBlocks+0x68>
80003058:	00 97       	mov	r7,r0
8000305a:	c1 38       	rjmp	80003080 <SD_ReadMultiBlocks+0x8c>
    {
      /*!< Read the SD block data : read NumByteToRead data */
      for (i = 0; i < BlockSize; i++)
8000305c:	58 06       	cp.w	r6,0
8000305e:	c0 a0       	breq	80003072 <SD_ReadMultiBlocks+0x7e>
80003060:	02 97       	mov	r7,r1
      {
        /*!< Read the pointed data */
        *pBuffer = SD_ReadByte();
80003062:	f0 1f 00 13 	mcall	800030ac <SD_ReadMultiBlocks+0xb8>
80003066:	ea 07 0b 0c 	st.b	r5[r7],r12
    }
    /*!< Now look for the data token to signify the start of the data */
    if (!SD_GetResponse(SD_START_DATA_SINGLE_BLOCK_READ))
    {
      /*!< Read the SD block data : read NumByteToRead data */
      for (i = 0; i < BlockSize; i++)
8000306a:	2f f7       	sub	r7,-1
8000306c:	0c 37       	cp.w	r7,r6
8000306e:	cf a3       	brcs	80003062 <SD_ReadMultiBlocks+0x6e>
80003070:	0c 05       	add	r5,r6
        *pBuffer = SD_ReadByte();
        /*!< Point to the next location where the byte read will be saved */
        pBuffer++;
      }
      /*!< Set next read address*/
      Offset += 512;
80003072:	e4 c2 fe 00 	sub	r2,r2,-512
      /*!< get CRC bytes (not really needed by us, but required by SD) */
      SD_ReadByte();
80003076:	f0 1f 00 0e 	mcall	800030ac <SD_ReadMultiBlocks+0xb8>
      SD_ReadByte();
8000307a:	f0 1f 00 0d 	mcall	800030ac <SD_ReadMultiBlocks+0xb8>
8000307e:	02 97       	mov	r7,r1
80003080:	20 14       	sub	r4,1
  SD_Error rvalue = SD_RESPONSE_FAILURE;
  
  /*!< SD chip select low */
  SD_CS_LOW();
  /*!< Data transfer */
  while (NumberOfBlocks--)
80003082:	58 04       	cp.w	r4,0
80003084:	cc 91       	brne	80003016 <SD_ReadMultiBlocks+0x22>
      /*!< Set response value to failure */
      rvalue = SD_RESPONSE_FAILURE;
    }
  }
  /*!< SD chip select high */
  SD_CS_HIGH();
80003086:	31 8c       	mov	r12,24
80003088:	f0 1f 00 0a 	mcall	800030b0 <SD_ReadMultiBlocks+0xbc>
  /*!< Send dummy byte: 8 Clock pulses of delay */
  SD_WriteByte(SD_DUMMY_BYTE);
8000308c:	e0 6c 00 ff 	mov	r12,255
80003090:	f0 1f 00 09 	mcall	800030b4 <SD_ReadMultiBlocks+0xc0>
  /*!< Returns the reponse */
  return rvalue;
}
80003094:	0e 9c       	mov	r12,r7
80003096:	2f fd       	sub	sp,-4
80003098:	d8 32       	popm	r0-r7,pc
8000309a:	00 00       	add	r0,r0
8000309c:	80 00       	ld.sh	r0,r0[0x0]
8000309e:	a4 2c       	st.h	r2[0x4],r12
800030a0:	00 00       	add	r0,r0
800030a2:	0a 68       	and	r8,r5
800030a4:	80 00       	ld.sh	r0,r0[0x0]
800030a6:	2b 50       	sub	r0,-75
800030a8:	80 00       	ld.sh	r0,r0[0x0]
800030aa:	2a 90       	sub	r0,-87
800030ac:	80 00       	ld.sh	r0,r0[0x0]
800030ae:	2a 4c       	sub	r12,-92
800030b0:	80 00       	ld.sh	r0,r0[0x0]
800030b2:	a4 10       	st.h	r2[0x2],r0
800030b4:	80 00       	ld.sh	r0,r0[0x0]
800030b6:	2b 04       	sub	r4,-80

800030b8 <SD_ReadBlock>:
  * @retval The SD Response:
  *         - SD_RESPONSE_FAILURE: Sequence failed
  *         - SD_RESPONSE_NO_ERROR: Sequence succeed
  */
SD_Error SD_ReadBlock(uint8_t* pBuffer, uint32_t ReadAddr, uint16_t BlockSize)
{
800030b8:	eb cd 40 e0 	pushm	r5-r7,lr
800030bc:	18 95       	mov	r5,r12
800030be:	16 97       	mov	r7,r11
800030c0:	14 96       	mov	r6,r10
  uint32_t i = 0;
  SD_Error rvalue = SD_RESPONSE_FAILURE;

  /*!< SD chip select low */
  SD_CS_LOW();
800030c2:	31 8c       	mov	r12,24
800030c4:	f0 1f 00 1a 	mcall	8000312c <SD_ReadBlock+0x74>
  
if(flag_SDHC == 1)
800030c8:	49 a8       	lddpc	r8,80003130 <SD_ReadBlock+0x78>
800030ca:	11 89       	ld.ub	r9,r8[0x0]
800030cc:	30 18       	mov	r8,1
800030ce:	f0 09 18 00 	cp.b	r9,r8
800030d2:	c0 21       	brne	800030d6 <SD_ReadBlock+0x1e>
{
	ReadAddr = ReadAddr/512;
800030d4:	a9 97       	lsr	r7,0x9
}
  /*!< Send CMD17 (SD_CMD_READ_SINGLE_BLOCK) to read one block */
  SD_SendCmd(SD_CMD_READ_SINGLE_BLOCK, ReadAddr, 0xFF);
800030d6:	e0 6a 00 ff 	mov	r10,255
800030da:	0e 9b       	mov	r11,r7
800030dc:	31 1c       	mov	r12,17
800030de:	f0 1f 00 16 	mcall	80003134 <SD_ReadBlock+0x7c>
  
  /*!< Check if the SD acknowledged the read block command: R1 response (0x00: no errors) */
  if (!SD_GetResponse(SD_RESPONSE_NO_ERROR))
800030e2:	30 0c       	mov	r12,0
800030e4:	f0 1f 00 15 	mcall	80003138 <SD_ReadBlock+0x80>
800030e8:	c1 61       	brne	80003114 <SD_ReadBlock+0x5c>
  {
    /*!< Now look for the data token to signify the start of the data */
    if (!SD_GetResponse(SD_START_DATA_SINGLE_BLOCK_READ))
800030ea:	e0 6c 00 fe 	mov	r12,254
800030ee:	f0 1f 00 13 	mcall	80003138 <SD_ReadBlock+0x80>
800030f2:	c1 11       	brne	80003114 <SD_ReadBlock+0x5c>
    {
      /*!< Read the SD block data : read NumByteToRead data */
      for (i = 0; i < BlockSize; i++)
800030f4:	5c 76       	castu.h	r6
800030f6:	c0 90       	breq	80003108 <SD_ReadBlock+0x50>
800030f8:	30 07       	mov	r7,0
      {
        /*!< Save the received data */
        *pBuffer = SD_ReadByte();
800030fa:	f0 1f 00 11 	mcall	8000313c <SD_ReadBlock+0x84>
800030fe:	ea 07 0b 0c 	st.b	r5[r7],r12
  {
    /*!< Now look for the data token to signify the start of the data */
    if (!SD_GetResponse(SD_START_DATA_SINGLE_BLOCK_READ))
    {
      /*!< Read the SD block data : read NumByteToRead data */
      for (i = 0; i < BlockSize; i++)
80003102:	2f f7       	sub	r7,-1
80003104:	0c 37       	cp.w	r7,r6
80003106:	cf a3       	brcs	800030fa <SD_ReadBlock+0x42>
       
        /*!< Point to the next location where the byte read will be saved */
        pBuffer++;
      }
      /*!< Get CRC bytes (not really needed by us, but required by SD) */
      SD_ReadByte();
80003108:	f0 1f 00 0d 	mcall	8000313c <SD_ReadBlock+0x84>
      SD_ReadByte();
8000310c:	f0 1f 00 0c 	mcall	8000313c <SD_ReadBlock+0x84>
80003110:	30 07       	mov	r7,0
80003112:	c0 38       	rjmp	80003118 <SD_ReadBlock+0x60>
80003114:	e0 67 00 ff 	mov	r7,255
      /*!< Set response value to success */
      rvalue = SD_RESPONSE_NO_ERROR;
    }
  }
  /*!< SD chip select high */
  SD_CS_HIGH();
80003118:	31 8c       	mov	r12,24
8000311a:	f0 1f 00 0a 	mcall	80003140 <SD_ReadBlock+0x88>
  
  /*!< Send dummy byte: 8 Clock pulses of delay */
  SD_WriteByte(SD_DUMMY_BYTE);
8000311e:	e0 6c 00 ff 	mov	r12,255
80003122:	f0 1f 00 09 	mcall	80003144 <SD_ReadBlock+0x8c>
  
  /*!< Returns the reponse */
  return rvalue;
}
80003126:	0e 9c       	mov	r12,r7
80003128:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000312c:	80 00       	ld.sh	r0,r0[0x0]
8000312e:	a4 2c       	st.h	r2[0x4],r12
80003130:	00 00       	add	r0,r0
80003132:	0a 68       	and	r8,r5
80003134:	80 00       	ld.sh	r0,r0[0x0]
80003136:	2b 50       	sub	r0,-75
80003138:	80 00       	ld.sh	r0,r0[0x0]
8000313a:	2a 90       	sub	r0,-87
8000313c:	80 00       	ld.sh	r0,r0[0x0]
8000313e:	2a 4c       	sub	r12,-92
80003140:	80 00       	ld.sh	r0,r0[0x0]
80003142:	a4 10       	st.h	r2[0x2],r0
80003144:	80 00       	ld.sh	r0,r0[0x0]
80003146:	2b 04       	sub	r4,-80

80003148 <SD_Init>:
  * @   SD
  * @   
  * @ 
***------------------------------------------------------*/
SD_Error SD_Init(void)
{
80003148:	eb cd 40 f8 	pushm	r3-r7,lr
  uint32_t TimeOut, i = 0;
  SD_Error Status = SD_RESPONSE_NO_ERROR;

  /* SD_SPI,SPI */
  SD_LowLevel_Init(); 
8000314c:	f0 1f 00 11 	mcall	80003190 <SD_Init+0x48>

  /*SD_SPI*/
  SD_SPI_SetSpeedLow();
80003150:	f0 1f 00 11 	mcall	80003194 <SD_Init+0x4c>
80003154:	30 05       	mov	r5,0
  TimeOut = 0;
  do
  {
	  
    /* SDCS*/
    SD_CS_HIGH();
80003156:	31 84       	mov	r4,24
80003158:	0a 93       	mov	r3,r5

    /*!< Rise CS and MOSI for 80 clocks cycles */
	/* CS100xFF,80*/
    for (i = 0; i <= 9; i++)
    {
      SD_WriteByte(SD_DUMMY_BYTE);
8000315a:	e0 66 00 ff 	mov	r6,255
  TimeOut = 0;
  do
  {
	  
    /* SDCS*/
    SD_CS_HIGH();
8000315e:	08 9c       	mov	r12,r4
80003160:	f0 1f 00 0e 	mcall	80003198 <SD_Init+0x50>
80003164:	06 97       	mov	r7,r3

    /*!< Rise CS and MOSI for 80 clocks cycles */
	/* CS100xFF,80*/
    for (i = 0; i <= 9; i++)
    {
      SD_WriteByte(SD_DUMMY_BYTE);
80003166:	0c 9c       	mov	r12,r6
80003168:	f0 1f 00 0d 	mcall	8000319c <SD_Init+0x54>
    /* SDCS*/
    SD_CS_HIGH();

    /*!< Rise CS and MOSI for 80 clocks cycles */
	/* CS100xFF,80*/
    for (i = 0; i <= 9; i++)
8000316c:	2f f7       	sub	r7,-1
8000316e:	58 a7       	cp.w	r7,10
80003170:	cf b1       	brne	80003166 <SD_Init+0x1e>
    {
      SD_WriteByte(SD_DUMMY_BYTE);
    }    
    
	Status = SD_GoIdleState();
80003172:	f0 1f 00 0c 	mcall	800031a0 <SD_Init+0x58>
80003176:	18 97       	mov	r7,r12

    if(TimeOut > 6)
80003178:	58 75       	cp.w	r5,7
8000317a:	c0 50       	breq	80003184 <SD_Init+0x3c>
    {
      break;
    }
    TimeOut++;
  }while(Status);
8000317c:	58 0c       	cp.w	r12,0
8000317e:	c0 30       	breq	80003184 <SD_Init+0x3c>

    if(TimeOut > 6)
    {
      break;
    }
    TimeOut++;
80003180:	2f f5       	sub	r5,-1
80003182:	ce eb       	rjmp	8000315e <SD_Init+0x16>
  }while(Status);


   /*SD_SPI*/
  SD_SPI_SetSpeedHi();
80003184:	f0 1f 00 08 	mcall	800031a4 <SD_Init+0x5c>
  return (Status);
}
80003188:	0e 9c       	mov	r12,r7
8000318a:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
8000318e:	00 00       	add	r0,r0
80003190:	80 00       	ld.sh	r0,r0[0x0]
80003192:	29 d4       	sub	r4,-99
80003194:	80 00       	ld.sh	r0,r0[0x0]
80003196:	29 c4       	sub	r4,-100
80003198:	80 00       	ld.sh	r0,r0[0x0]
8000319a:	a4 10       	st.h	r2[0x2],r0
8000319c:	80 00       	ld.sh	r0,r0[0x0]
8000319e:	2b 04       	sub	r4,-80
800031a0:	80 00       	ld.sh	r0,r0[0x0]
800031a2:	2b 8c       	sub	r12,-72
800031a4:	80 00       	ld.sh	r0,r0[0x0]
800031a6:	29 b4       	sub	r4,-101

800031a8 <SD_GetCSDRegister>:
  * @retval The SD Response: 
  *         - SD_RESPONSE_FAILURE: Sequence failed
  *         - SD_RESPONSE_NO_ERROR: Sequence succeed
  */
SD_Error SD_GetCSDRegister(SD_CSD* SD_csd)
{
800031a8:	eb cd 40 e0 	pushm	r5-r7,lr
800031ac:	20 9d       	sub	sp,36
800031ae:	18 97       	mov	r7,r12
  uint8_t CSD_Tab[16];
  uint32_t CardCapacity;
  static uint32_t times = 0;

  /*!< SD chip select low */
  SD_CS_LOW();
800031b0:	31 8c       	mov	r12,24
800031b2:	f0 1f 00 a6 	mcall	80003448 <SD_GetCSDRegister+0x2a0>
  /*!< Send CMD9 (CSD register) or CMD10(CSD register) */
  SD_SendCmd(SD_CMD_SEND_CSD, 0, 0xFF);
800031b6:	e0 6a 00 ff 	mov	r10,255
800031ba:	30 0b       	mov	r11,0
800031bc:	30 9c       	mov	r12,9
800031be:	f0 1f 00 a4 	mcall	8000344c <SD_GetCSDRegister+0x2a4>
  /*!< Wait for response in the R1 format (0x00 is no errors) */
  if (!SD_GetResponse(SD_RESPONSE_NO_ERROR))
800031c2:	30 0c       	mov	r12,0
800031c4:	f0 1f 00 a3 	mcall	80003450 <SD_GetCSDRegister+0x2a8>
800031c8:	c0 40       	breq	800031d0 <SD_GetCSDRegister+0x28>
800031ca:	e0 6c 00 ff 	mov	r12,255
800031ce:	c3 99       	rjmp	80003440 <SD_GetCSDRegister+0x298>
  {
    if (!SD_GetResponse(SD_START_DATA_SINGLE_BLOCK_READ))
800031d0:	e0 6c 00 fe 	mov	r12,254
800031d4:	f0 1f 00 9f 	mcall	80003450 <SD_GetCSDRegister+0x2a8>
800031d8:	c0 a1       	brne	800031ec <SD_GetCSDRegister+0x44>
800031da:	fa c6 ff ec 	sub	r6,sp,-20
  * @param  SD_csd: pointer on an SCD register structure
  * @retval The SD Response: 
  *         - SD_RESPONSE_FAILURE: Sequence failed
  *         - SD_RESPONSE_NO_ERROR: Sequence succeed
  */
SD_Error SD_GetCSDRegister(SD_CSD* SD_csd)
800031de:	fa c5 ff dc 	sub	r5,sp,-36
    if (!SD_GetResponse(SD_START_DATA_SINGLE_BLOCK_READ))
    {
      for (i = 0; i < 16; i++)
      {
        /*!< Store CSD register value on CSD_Tab */
        CSD_Tab[i] = SD_ReadByte();
800031e2:	f0 1f 00 9d 	mcall	80003454 <SD_GetCSDRegister+0x2ac>
800031e6:	0c cc       	st.b	r6++,r12
  /*!< Wait for response in the R1 format (0x00 is no errors) */
  if (!SD_GetResponse(SD_RESPONSE_NO_ERROR))
  {
    if (!SD_GetResponse(SD_START_DATA_SINGLE_BLOCK_READ))
    {
      for (i = 0; i < 16; i++)
800031e8:	0a 36       	cp.w	r6,r5
800031ea:	cf c1       	brne	800031e2 <SD_GetCSDRegister+0x3a>
          //printf("\n\r CSD_Tab[%d] 0x%X", i, CSD_Tab[i]);
        }
      }
    }
    /*!< Get CRC bytes (not really needed by us, but required by SD) */
    SD_WriteByte(SD_DUMMY_BYTE);
800031ec:	e0 6c 00 ff 	mov	r12,255
800031f0:	f0 1f 00 9a 	mcall	80003458 <SD_GetCSDRegister+0x2b0>
    SD_WriteByte(SD_DUMMY_BYTE);
800031f4:	e0 6c 00 ff 	mov	r12,255
800031f8:	f0 1f 00 98 	mcall	80003458 <SD_GetCSDRegister+0x2b0>
  else
  {
     return rvalue;
  }
  /*!< SD chip select high */
  SD_CS_HIGH();
800031fc:	31 8c       	mov	r12,24
800031fe:	f0 1f 00 98 	mcall	8000345c <SD_GetCSDRegister+0x2b4>
  /*!< Send dummy byte: 8 Clock pulses of delay */
  SD_WriteByte(SD_DUMMY_BYTE);
80003202:	e0 6c 00 ff 	mov	r12,255
80003206:	f0 1f 00 95 	mcall	80003458 <SD_GetCSDRegister+0x2b0>

  /*!< Byte 0 */
  SD_csd->CSDStruct = (CSD_Tab[0] & 0xC0) >> 6;
8000320a:	fb 38 00 14 	ld.ub	r8,sp[20]
8000320e:	f0 09 16 06 	lsr	r9,r8,0x6
80003212:	ae 89       	st.b	r7[0x0],r9
  SD_csd->SysSpecVersion = (CSD_Tab[0] & 0x3C) >> 2;
80003214:	f3 d8 c0 44 	bfextu	r9,r8,0x2,0x4
80003218:	ae 99       	st.b	r7[0x1],r9
  SD_csd->Reserved1 = CSD_Tab[0] & 0x03;
8000321a:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
8000321e:	ae a8       	st.b	r7[0x2],r8

  if(0 == times)
80003220:	fe f8 02 40 	ld.w	r8,pc[576]
80003224:	70 08       	ld.w	r8,r8[0x0]
80003226:	58 08       	cp.w	r8,0
80003228:	c0 f1       	brne	80003246 <SD_GetCSDRegister+0x9e>
  {
    if(SD_csd->CSDStruct == 1)
8000322a:	0f 89       	ld.ub	r9,r7[0x0]
8000322c:	30 18       	mov	r8,1
8000322e:	f0 09 18 00 	cp.b	r9,r8
80003232:	c0 61       	brne	8000323e <SD_GetCSDRegister+0x96>
    {
      //printf("\n\r SDHC CSD Version 2.0 Acess AS SD High Capacity.");
      flag_SDHC = 1;
80003234:	10 99       	mov	r9,r8
80003236:	fe f8 02 2e 	ld.w	r8,pc[558]
8000323a:	b0 89       	st.b	r8[0x0],r9
8000323c:	c0 58       	rjmp	80003246 <SD_GetCSDRegister+0x9e>
    }
	else
	{
      //printf("\n\r SDSC CSD Version 1.0 Acess AS SD Standard Capacity.");	
      flag_SDHC = 0;
8000323e:	30 09       	mov	r9,0
80003240:	fe f8 02 24 	ld.w	r8,pc[548]
80003244:	b0 89       	st.b	r8[0x0],r9
	}
  }

  /*!< Byte 1 */
  SD_csd->TAAC = CSD_Tab[1];
80003246:	fb 38 00 15 	ld.ub	r8,sp[21]
8000324a:	ae b8       	st.b	r7[0x3],r8

  /*!< Byte 2 */
  SD_csd->NSAC = CSD_Tab[2];
8000324c:	fb 38 00 16 	ld.ub	r8,sp[22]
80003250:	ae c8       	st.b	r7[0x4],r8

  /*!< Byte 3 */
  SD_csd->MaxBusClkFrec = CSD_Tab[3];
80003252:	fb 38 00 17 	ld.ub	r8,sp[23]
80003256:	ae d8       	st.b	r7[0x5],r8

  /*!< Byte 4 */
  SD_csd->CardComdClasses = CSD_Tab[4] << 4;
80003258:	fb 38 00 18 	ld.ub	r8,sp[24]
8000325c:	a5 68       	lsl	r8,0x4
8000325e:	ae 38       	st.h	r7[0x6],r8

  /*!< Byte 5 */
  SD_csd->CardComdClasses |= (CSD_Tab[5] & 0xF0) >> 4;
80003260:	8e 39       	ld.sh	r9,r7[0x6]
80003262:	fb 38 00 19 	ld.ub	r8,sp[25]
80003266:	f3 e8 12 49 	or	r9,r9,r8>>0x4
8000326a:	ae 39       	st.h	r7[0x6],r9
  SD_csd->RdBlockLen = CSD_Tab[5] & 0x0F;
8000326c:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
80003270:	ef 68 00 08 	st.b	r7[8],r8

  /*!< Byte 6 */
  SD_csd->PartBlockRead = (CSD_Tab[6] & 0x80) >> 7;
80003274:	fb 38 00 1a 	ld.ub	r8,sp[26]
80003278:	f0 09 16 07 	lsr	r9,r8,0x7
8000327c:	ef 69 00 09 	st.b	r7[9],r9
  SD_csd->WrBlockMisalign = (CSD_Tab[6] & 0x40) >> 6;
80003280:	f3 d8 c0 c1 	bfextu	r9,r8,0x6,0x1
80003284:	ef 69 00 0a 	st.b	r7[10],r9
  SD_csd->RdBlockMisalign = (CSD_Tab[6] & 0x20) >> 5;
80003288:	f3 d8 c0 a1 	bfextu	r9,r8,0x5,0x1
8000328c:	ef 69 00 0b 	st.b	r7[11],r9
  SD_csd->DSRImpl = (CSD_Tab[6] & 0x10) >> 4;
80003290:	f3 d8 c0 81 	bfextu	r9,r8,0x4,0x1
80003294:	ef 69 00 0c 	st.b	r7[12],r9
  SD_csd->Reserved2 = 0; /*!< Reserved */
80003298:	30 09       	mov	r9,0
8000329a:	ef 69 00 0d 	st.b	r7[13],r9

  if(flag_SDHC == 0)
8000329e:	4f 2a       	lddpc	r10,80003464 <SD_GetCSDRegister+0x2bc>
800032a0:	15 8a       	ld.ub	r10,r10[0x0]
800032a2:	f2 0a 18 00 	cp.b	r10,r9
800032a6:	c1 21       	brne	800032ca <SD_GetCSDRegister+0x122>
  {
    SD_csd->DeviceSize = (CSD_Tab[6] & 0x03) << 10;
800032a8:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
800032ac:	ab 68       	lsl	r8,0xa
800032ae:	8f 48       	st.w	r7[0x10],r8
  
    /*!< Byte 7 */
    SD_csd->DeviceSize |= (CSD_Tab[7]) << 2;
800032b0:	6e 48       	ld.w	r8,r7[0x10]
800032b2:	fb 39 00 1b 	ld.ub	r9,sp[27]
800032b6:	f1 e9 10 28 	or	r8,r8,r9<<0x2
800032ba:	8f 48       	st.w	r7[0x10],r8
  
    /*!< Byte 8 */
    SD_csd->DeviceSize |= (CSD_Tab[8] & 0xC0) >> 6;
800032bc:	6e 48       	ld.w	r8,r7[0x10]
800032be:	fb 39 00 1c 	ld.ub	r9,sp[28]
800032c2:	f1 e9 12 68 	or	r8,r8,r9>>0x6
800032c6:	8f 48       	st.w	r7[0x10],r8
800032c8:	c1 38       	rjmp	800032ee <SD_GetCSDRegister+0x146>
  }
  else
  {
    SD_csd->DeviceSize = (CSD_Tab[7] & 0x3F) << 16;
800032ca:	fb 38 00 1b 	ld.ub	r8,sp[27]
800032ce:	f1 d8 c0 06 	bfextu	r8,r8,0x0,0x6
800032d2:	b1 68       	lsl	r8,0x10
800032d4:	8f 48       	st.w	r7[0x10],r8
    /* Byte 7 */
    SD_csd->DeviceSize += (CSD_Tab[8]) << 8;
800032d6:	6e 49       	ld.w	r9,r7[0x10]
800032d8:	fb 38 00 1c 	ld.ub	r8,sp[28]
800032dc:	a9 68       	lsl	r8,0x8
800032de:	12 08       	add	r8,r9
800032e0:	8f 48       	st.w	r7[0x10],r8
    /* Byte 8 */
    SD_csd->DeviceSize += CSD_Tab[9] ;
800032e2:	6e 48       	ld.w	r8,r7[0x10]
800032e4:	fb 39 00 1d 	ld.ub	r9,sp[29]
800032e8:	f2 08 00 08 	add	r8,r9,r8
800032ec:	8f 48       	st.w	r7[0x10],r8
  }    

  SD_csd->MaxRdCurrentVDDMin = (CSD_Tab[8] & 0x38) >> 3;
800032ee:	fb 38 00 1c 	ld.ub	r8,sp[28]
800032f2:	f3 d8 c0 63 	bfextu	r9,r8,0x3,0x3
800032f6:	ef 69 00 14 	st.b	r7[20],r9
  SD_csd->MaxRdCurrentVDDMax = (CSD_Tab[8] & 0x07);
800032fa:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
800032fe:	ef 68 00 15 	st.b	r7[21],r8

  /*!< Byte 9 */
  SD_csd->MaxWrCurrentVDDMin = (CSD_Tab[9] & 0xE0) >> 5;
80003302:	fb 38 00 1d 	ld.ub	r8,sp[29]
80003306:	f0 09 16 05 	lsr	r9,r8,0x5
8000330a:	ef 69 00 16 	st.b	r7[22],r9
  SD_csd->MaxWrCurrentVDDMax = (CSD_Tab[9] & 0x1C) >> 2;
8000330e:	f3 d8 c0 43 	bfextu	r9,r8,0x2,0x3
80003312:	ef 69 00 17 	st.b	r7[23],r9
  SD_csd->DeviceSizeMul = (CSD_Tab[9] & 0x03) << 1;
80003316:	a1 78       	lsl	r8,0x1
80003318:	e2 18 00 06 	andl	r8,0x6,COH
8000331c:	ef 68 00 18 	st.b	r7[24],r8
  /*!< Byte 10 */
  SD_csd->DeviceSizeMul |= (CSD_Tab[10] & 0x80) >> 7;
80003320:	ef 39 00 18 	ld.ub	r9,r7[24]
80003324:	fb 38 00 1e 	ld.ub	r8,sp[30]
80003328:	f3 e8 12 79 	or	r9,r9,r8>>0x7
8000332c:	ef 69 00 18 	st.b	r7[24],r9
    
  SD_csd->EraseGrSize = (CSD_Tab[10] & 0x40) >> 6;
80003330:	f3 d8 c0 c1 	bfextu	r9,r8,0x6,0x1
80003334:	ef 69 00 19 	st.b	r7[25],r9
  SD_csd->EraseGrMul = (CSD_Tab[10] & 0x3F) << 1;
80003338:	a1 78       	lsl	r8,0x1
8000333a:	e2 18 00 7e 	andl	r8,0x7e,COH
8000333e:	ef 68 00 1a 	st.b	r7[26],r8

  /*!< Byte 11 */
  SD_csd->EraseGrMul |= (CSD_Tab[11] & 0x80) >> 7;
80003342:	ef 39 00 1a 	ld.ub	r9,r7[26]
80003346:	fb 38 00 1f 	ld.ub	r8,sp[31]
8000334a:	f3 e8 12 79 	or	r9,r9,r8>>0x7
8000334e:	ef 69 00 1a 	st.b	r7[26],r9
  SD_csd->WrProtectGrSize = (CSD_Tab[11] & 0x7F);
80003352:	f1 d8 c0 07 	bfextu	r8,r8,0x0,0x7
80003356:	ef 68 00 1b 	st.b	r7[27],r8

  /*!< Byte 12 */
  SD_csd->WrProtectGrEnable = (CSD_Tab[12] & 0x80) >> 7;
8000335a:	fb 38 00 20 	ld.ub	r8,sp[32]
8000335e:	f0 09 16 07 	lsr	r9,r8,0x7
80003362:	ef 69 00 1c 	st.b	r7[28],r9
  SD_csd->ManDeflECC = (CSD_Tab[12] & 0x60) >> 5;
80003366:	f3 d8 c0 a2 	bfextu	r9,r8,0x5,0x2
8000336a:	ef 69 00 1d 	st.b	r7[29],r9
  SD_csd->WrSpeedFact = (CSD_Tab[12] & 0x1C) >> 2;
8000336e:	f3 d8 c0 43 	bfextu	r9,r8,0x2,0x3
80003372:	ef 69 00 1e 	st.b	r7[30],r9
  SD_csd->MaxWrBlockLen = (CSD_Tab[12] & 0x03) << 2;
80003376:	a3 68       	lsl	r8,0x2
80003378:	e2 18 00 0c 	andl	r8,0xc,COH
8000337c:	ef 68 00 1f 	st.b	r7[31],r8

  /*!< Byte 13 */
  SD_csd->MaxWrBlockLen |= (CSD_Tab[13] & 0xC0) >> 6;
80003380:	ef 39 00 1f 	ld.ub	r9,r7[31]
80003384:	fb 38 00 21 	ld.ub	r8,sp[33]
80003388:	f3 e8 12 69 	or	r9,r9,r8>>0x6
8000338c:	ef 69 00 1f 	st.b	r7[31],r9
  SD_csd->WriteBlockPaPartial = (CSD_Tab[13] & 0x20) >> 5;
80003390:	f3 d8 c0 a1 	bfextu	r9,r8,0x5,0x1
80003394:	ef 69 00 20 	st.b	r7[32],r9
  SD_csd->Reserved3 = 0;
80003398:	30 09       	mov	r9,0
8000339a:	ef 69 00 21 	st.b	r7[33],r9
  SD_csd->ContentProtectAppli = (CSD_Tab[13] & 0x01);
8000339e:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800033a2:	ef 68 00 22 	st.b	r7[34],r8

  /*!< Byte 14 */
  SD_csd->FileFormatGrouop = (CSD_Tab[14] & 0x80) >> 7;
800033a6:	fb 38 00 22 	ld.ub	r8,sp[34]
800033aa:	f0 09 16 07 	lsr	r9,r8,0x7
800033ae:	ef 69 00 23 	st.b	r7[35],r9
  SD_csd->CopyFlag = (CSD_Tab[14] & 0x40) >> 6;
800033b2:	f3 d8 c0 c1 	bfextu	r9,r8,0x6,0x1
800033b6:	ef 69 00 24 	st.b	r7[36],r9
  SD_csd->PermWrProtect = (CSD_Tab[14] & 0x20) >> 5;
800033ba:	f3 d8 c0 a1 	bfextu	r9,r8,0x5,0x1
800033be:	ef 69 00 25 	st.b	r7[37],r9
  SD_csd->TempWrProtect = (CSD_Tab[14] & 0x10) >> 4;
800033c2:	f3 d8 c0 81 	bfextu	r9,r8,0x4,0x1
800033c6:	ef 69 00 26 	st.b	r7[38],r9
  SD_csd->FileFormat = (CSD_Tab[14] & 0x0C) >> 2;
800033ca:	f3 d8 c0 42 	bfextu	r9,r8,0x2,0x2
800033ce:	ef 69 00 27 	st.b	r7[39],r9
  SD_csd->ECC = (CSD_Tab[14] & 0x03);
800033d2:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
800033d6:	ef 68 00 28 	st.b	r7[40],r8

  /*!< Byte 15 */
  SD_csd->CSD_CRC = (CSD_Tab[15] & 0xFE) >> 1;
800033da:	fb 38 00 23 	ld.ub	r8,sp[35]
800033de:	a1 98       	lsr	r8,0x1
800033e0:	ef 68 00 29 	st.b	r7[41],r8
  SD_csd->Reserved4 = 1;
800033e4:	30 18       	mov	r8,1
800033e6:	ef 68 00 2a 	st.b	r7[42],r8

  if(times < 3)
800033ea:	49 e8       	lddpc	r8,80003460 <SD_GetCSDRegister+0x2b8>
800033ec:	70 08       	ld.w	r8,r8[0x0]
800033ee:	58 28       	cp.w	r8,2
800033f0:	e0 88 00 04 	brls	800033f8 <SD_GetCSDRegister+0x250>
800033f4:	30 0c       	mov	r12,0
800033f6:	c2 58       	rjmp	80003440 <SD_GetCSDRegister+0x298>
  {
    if(flag_SDHC ==1)
800033f8:	49 b9       	lddpc	r9,80003464 <SD_GetCSDRegister+0x2bc>
800033fa:	13 8a       	ld.ub	r10,r9[0x0]
800033fc:	30 19       	mov	r9,1
800033fe:	f2 0a 18 00 	cp.b	r10,r9
80003402:	c0 51       	brne	8000340c <SD_GetCSDRegister+0x264>
    {
	  /* SDHC memory capacity = (C_SIZE+1) * 512K byte */
      //SD_csd->DeviceSizeMul = 8 ;
      
      CardCapacity = (SD_csd->DeviceSize + 1)*512;
80003404:	6e 49       	ld.w	r9,r7[0x10]
80003406:	2f f9       	sub	r9,-1
80003408:	a9 79       	lsl	r9,0x9
8000340a:	c0 c8       	rjmp	80003422 <SD_GetCSDRegister+0x27a>
      
    }

    else
    {
      CardCapacity = (SD_csd->DeviceSize + 1);
8000340c:	6e 4a       	ld.w	r10,r7[0x10]
8000340e:	2f fa       	sub	r10,-1
      CardCapacity *= (1 << (SD_csd->DeviceSizeMul + 2));
80003410:	ef 39 00 18 	ld.ub	r9,r7[24]
80003414:	2f e9       	sub	r9,-2
80003416:	f4 09 09 4a 	lsl	r10,r10,r9
      CardCapacity *= (1<<SD_csd->RdBlockLen);
8000341a:	ef 39 00 08 	ld.ub	r9,r7[8]
8000341e:	f4 09 09 49 	lsl	r9,r10,r9
      //printf("\n\r SD CardBlockSize %d CardCapacity %d M.", (1<<SD_csd->RdBlockLen), 
            //CardCapacity / 1024 / 1024);
    }
    
  if(times == 0)
80003422:	58 08       	cp.w	r8,0
80003424:	c0 91       	brne	80003436 <SD_GetCSDRegister+0x28e>
    {
	    uint8_t str[20];
        sprintf((char *)&str[0], " SD Card Size %dM. ", CardCapacity / 1024 / 1024);
80003426:	b5 89       	lsr	r9,0x14
80003428:	1a d9       	st.w	--sp,r9
8000342a:	49 0b       	lddpc	r11,80003468 <SD_GetCSDRegister+0x2c0>
8000342c:	fa cc ff fc 	sub	r12,sp,-4
80003430:	f0 1f 00 0f 	mcall	8000346c <SD_GetCSDRegister+0x2c4>
80003434:	2f fd       	sub	sp,-4
//	    LCD_DisplayStringLine(LCD_LINE_0, str);
    }
	times++;
80003436:	48 b8       	lddpc	r8,80003460 <SD_GetCSDRegister+0x2b8>
80003438:	70 09       	ld.w	r9,r8[0x0]
8000343a:	2f f9       	sub	r9,-1
8000343c:	91 09       	st.w	r8[0x0],r9
8000343e:	30 0c       	mov	r12,0
  }
  /*!< Return the reponse */
  return rvalue;
}
80003440:	2f 7d       	sub	sp,-36
80003442:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003446:	00 00       	add	r0,r0
80003448:	80 00       	ld.sh	r0,r0[0x0]
8000344a:	a4 2c       	st.h	r2[0x4],r12
8000344c:	80 00       	ld.sh	r0,r0[0x0]
8000344e:	2b 50       	sub	r0,-75
80003450:	80 00       	ld.sh	r0,r0[0x0]
80003452:	2a 90       	sub	r0,-87
80003454:	80 00       	ld.sh	r0,r0[0x0]
80003456:	2a 4c       	sub	r12,-92
80003458:	80 00       	ld.sh	r0,r0[0x0]
8000345a:	2b 04       	sub	r4,-80
8000345c:	80 00       	ld.sh	r0,r0[0x0]
8000345e:	a4 10       	st.h	r2[0x2],r0
80003460:	00 00       	add	r0,r0
80003462:	0a 64       	and	r4,r5
80003464:	00 00       	add	r0,r0
80003466:	0a 68       	and	r8,r5
80003468:	80 01       	ld.sh	r1,r0[0x0]
8000346a:	09 a0       	ld.ub	r0,r4[0x2]
8000346c:	80 00       	ld.sh	r0,r0[0x0]
8000346e:	ad 3c       	mul	r12,r6

80003470 <SD_GetCardInfo>:
  * @   
  * @   
  * @ 
***------------------------------------------------------*/
SD_Error SD_GetCardInfo(SD_CardInfo *cardinfo)
{
80003470:	eb cd 40 c0 	pushm	r6-r7,lr
80003474:	18 97       	mov	r7,r12
  static uint32_t i = 0;
  SD_Error status = SD_RESPONSE_FAILURE;

  status = SD_GetCSDRegister(&(cardinfo->SD_csd));
80003476:	18 96       	mov	r6,r12
80003478:	f0 1f 00 12 	mcall	800034c0 <SD_GetCardInfo+0x50>
  if(SD_RESPONSE_FAILURE == status)
8000347c:	e0 4c 00 ff 	cp.w	r12,255
80003480:	c0 41       	brne	80003488 <SD_GetCardInfo+0x18>
  {
    status = SD_GetCSDRegister(&(cardinfo->SD_csd));
80003482:	0e 9c       	mov	r12,r7
80003484:	f0 1f 00 0f 	mcall	800034c0 <SD_GetCardInfo+0x50>
  }
  status = SD_GetCIDRegister(&(cardinfo->SD_cid));
80003488:	ee cc ff d4 	sub	r12,r7,-44
8000348c:	f0 1f 00 0e 	mcall	800034c4 <SD_GetCardInfo+0x54>
  
  if (flag_SDHC = 1)
80003490:	30 19       	mov	r9,1
80003492:	48 e8       	lddpc	r8,800034c8 <SD_GetCardInfo+0x58>
80003494:	b0 89       	st.b	r8[0x0],r9
  {
	  
	  /* SDHC memory capacity = (C_SIZE+1) * 512K byte */
	  
	  cardinfo->CardCapacity = (cardinfo->SD_csd.DeviceSize + 1) ; 
80003496:	6e 48       	ld.w	r8,r7[0x10]
80003498:	2f f8       	sub	r8,-1
8000349a:	ef 48 00 44 	st.w	r7[68],r8
	  cardinfo->CardBlockSize = 1 << (cardinfo->SD_csd.RdBlockLen);
8000349e:	ef 39 00 08 	ld.ub	r9,r7[8]
800034a2:	30 1a       	mov	r10,1
800034a4:	f4 09 09 49 	lsl	r9,r10,r9
800034a8:	ef 49 00 48 	st.w	r7[72],r9
	  cardinfo->CardCapacity *= cardinfo->CardBlockSize; 
800034ac:	f2 08 02 48 	mul	r8,r9,r8
800034b0:	ef 48 00 44 	st.w	r7[68],r8
  {
  
    //printf("\n\r SD CardBlockSize %d CardCapacity %d M", cardinfo->CardBlockSize, 
            //cardinfo->CardCapacity / 1024 / 1024);
  }
  i++; 
800034b4:	48 68       	lddpc	r8,800034cc <SD_GetCardInfo+0x5c>
800034b6:	70 09       	ld.w	r9,r8[0x0]
800034b8:	14 09       	add	r9,r10
800034ba:	91 09       	st.w	r8[0x0],r9
  
  /*!< Returns the reponse */
  return status;
}
800034bc:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800034c0:	80 00       	ld.sh	r0,r0[0x0]
800034c2:	31 a8       	mov	r8,26
800034c4:	80 00       	ld.sh	r0,r0[0x0]
800034c6:	2d 54       	sub	r4,-43
800034c8:	00 00       	add	r0,r0
800034ca:	0a 68       	and	r8,r5
800034cc:	00 00       	add	r0,r0
800034ce:	0a 60       	and	r0,r5

800034d0 <SD_GetSectorCount>:
	}while(t<0XFFFFFF);//
	return SD_RESPONSE_FAILURE ;
}

uint32_t SD_GetSectorCount(void)
{
800034d0:	d4 01       	pushm	lr
800034d2:	21 3d       	sub	sp,76
	
	
	uint32_t  static temp;
	
	
	SD_GetCardInfo(&sdinfo);
800034d4:	1a 9c       	mov	r12,sp
800034d6:	f0 1f 00 05 	mcall	800034e8 <SD_GetSectorCount+0x18>
	
	temp = sdinfo.CardCapacity;
	
	temp = temp*(1024/512);//:1sector=512byte
800034da:	41 1c       	lddsp	r12,sp[0x44]
800034dc:	a1 7c       	lsl	r12,0x1
800034de:	48 48       	lddpc	r8,800034ec <SD_GetSectorCount+0x1c>
800034e0:	91 0c       	st.w	r8[0x0],r12
	
	return (temp);
	
	

}
800034e2:	2e dd       	sub	sp,-76
800034e4:	d8 02       	popm	pc
800034e6:	00 00       	add	r0,r0
800034e8:	80 00       	ld.sh	r0,r0[0x0]
800034ea:	34 70       	mov	r0,71
800034ec:	00 00       	add	r0,r0
800034ee:	0a 5c       	eor	r12,r5

800034f0 <MAL_WriteDisk>:
* Output         :
* Return         : SD_ErrorStarus: SD Card Error code.
******************************************************************************************/

MAL_ErrorStarus MAL_WriteDisk(void *writebuff, uint32_t sector, uint32_t blockByteSize, uint8_t count)
{
800034f0:	d4 01       	pushm	lr
	
	
	if(count == 1)
800034f2:	30 18       	mov	r8,1
800034f4:	f0 09 18 00 	cp.b	r9,r8
800034f8:	c0 71       	brne	80003506 <MAL_WriteDisk+0x16>
	{
		
		if(SD_WriteBlock(writebuff, (sector*BLOCK_BYTE_SIZE), blockByteSize)==SD_RESPONSE_NO_ERROR)//1
800034fa:	5c 7a       	castu.h	r10
800034fc:	a9 7b       	lsl	r11,0x9
800034fe:	f0 1f 00 07 	mcall	80003518 <MAL_WriteDisk+0x28>
80003502:	c0 91       	brne	80003514 <MAL_WriteDisk+0x24>
80003504:	c0 68       	rjmp	80003510 <MAL_WriteDisk+0x20>
		
	}
	else
	{
		
		if(SD_WriteMultiBlocks(writebuff, (sector*BLOCK_BYTE_SIZE), blockByteSize, count)==SD_RESPONSE_NO_ERROR)
80003506:	5c 7a       	castu.h	r10
80003508:	a9 7b       	lsl	r11,0x9
8000350a:	f0 1f 00 05 	mcall	8000351c <MAL_WriteDisk+0x2c>
8000350e:	c0 31       	brne	80003514 <MAL_WriteDisk+0x24>
80003510:	30 4c       	mov	r12,4
80003512:	d8 02       	popm	pc
80003514:	30 3c       	mov	r12,3
	
	return WRITE_DATA_ERR;
	
	
	
}
80003516:	d8 02       	popm	pc
80003518:	80 00       	ld.sh	r0,r0[0x0]
8000351a:	2f 4c       	sub	r12,-12
8000351c:	80 00       	ld.sh	r0,r0[0x0]
8000351e:	2e 84       	sub	r4,-24

80003520 <MAL_ReadDisk>:
* Output         :
* Return         : SD_ErrorStarus: SD Card Error code.
******************************************************************************************/

MAL_ErrorStarus MAL_ReadDisk(void *readbuff, uint32_t sector, uint32_t blockByteSize, uint8_t count)
{
80003520:	d4 01       	pushm	lr
	
	
	if(count == 1)
80003522:	30 18       	mov	r8,1
80003524:	f0 09 18 00 	cp.b	r9,r8
80003528:	c0 71       	brne	80003536 <MAL_ReadDisk+0x16>
	{
		
		if(SD_ReadBlock(readbuff, (sector*BLOCK_BYTE_SIZE), blockByteSize)==SD_RESPONSE_NO_ERROR)//1
8000352a:	5c 7a       	castu.h	r10
8000352c:	a9 7b       	lsl	r11,0x9
8000352e:	f0 1f 00 07 	mcall	80003548 <MAL_ReadDisk+0x28>
80003532:	c0 91       	brne	80003544 <MAL_ReadDisk+0x24>
80003534:	c0 68       	rjmp	80003540 <MAL_ReadDisk+0x20>
		
	}
	else
	{
		
		if(SD_ReadMultiBlocks(readbuff, (sector*BLOCK_BYTE_SIZE), blockByteSize, count)==SD_RESPONSE_NO_ERROR)
80003536:	5c 7a       	castu.h	r10
80003538:	a9 7b       	lsl	r11,0x9
8000353a:	f0 1f 00 05 	mcall	8000354c <MAL_ReadDisk+0x2c>
8000353e:	c0 31       	brne	80003544 <MAL_ReadDisk+0x24>
80003540:	30 8c       	mov	r12,8
80003542:	d8 02       	popm	pc
80003544:	30 7c       	mov	r12,7
	
	return READ_DATA_ERR;
	
		
	
}
80003546:	d8 02       	popm	pc
80003548:	80 00       	ld.sh	r0,r0[0x0]
8000354a:	30 b8       	mov	r8,11
8000354c:	80 00       	ld.sh	r0,r0[0x0]
8000354e:	2f f4       	sub	r4,-1

80003550 <MAL_InitConfig>:
* Output         : None
* Return         : SDConfigStatus:SD Card initiation code
*******************************************************************************/

uint16_t MAL_InitConfig(void)
{
80003550:	d4 01       	pushm	lr
80003552:	21 3d       	sub	sp,76
	uint16_t status = SDConfig_OK;
        
    SD_CardInfo cardinfo;

      if(!(SD_Init()))
80003554:	f0 1f 00 06 	mcall	8000356c <MAL_InitConfig+0x1c>
80003558:	c0 30       	breq	8000355e <MAL_InitConfig+0xe>
8000355a:	30 1c       	mov	r12,1
8000355c:	c0 58       	rjmp	80003566 <MAL_InitConfig+0x16>
      {
        
			if(SD_GetCardInfo(&cardinfo)==0) /*SD */
8000355e:	1a 9c       	mov	r12,sp
80003560:	f0 1f 00 04 	mcall	80003570 <MAL_InitConfig+0x20>
80003564:	5f 1c       	srne	r12
			return status;//
      
      }    

        return SDConfig_FALL;
}
80003566:	2e dd       	sub	sp,-76
80003568:	d8 02       	popm	pc
8000356a:	00 00       	add	r0,r0
8000356c:	80 00       	ld.sh	r0,r0[0x0]
8000356e:	31 48       	mov	r8,20
80003570:	80 00       	ld.sh	r0,r0[0x0]
80003572:	34 70       	mov	r0,71

80003574 <fl_read>:
	}
	
}

void fl_read(void * path, S32 offset, void * buffer, U32 length)
{
80003574:	eb cd 40 f8 	pushm	r3-r7,lr
80003578:	20 2d       	sub	sp,8
8000357a:	18 95       	mov	r5,r12
8000357c:	16 94       	mov	r4,r11
8000357e:	14 93       	mov	r3,r10
80003580:	12 96       	mov	r6,r9
	
	fl_read_t * fl_read_ptr = pvPortMalloc(sizeof(fl_read_t));
80003582:	34 cc       	mov	r12,76
80003584:	f0 1f 00 16 	mcall	800035dc <fl_read+0x68>
80003588:	18 97       	mov	r7,r12
	
	sprintf(fl_read_ptr->path, "%s", path);
8000358a:	0a 9b       	mov	r11,r5
8000358c:	f0 1f 00 15 	mcall	800035e0 <fl_read+0x6c>
	fl_read_ptr->offset = offset;
80003590:	ef 44 00 40 	st.w	r7[64],r4
	fl_read_ptr->length = length;
80003594:	ef 46 00 44 	st.w	r7[68],r6
	
	fl_read_ptr->buffer = pvPortMalloc(length);
80003598:	0c 9c       	mov	r12,r6
8000359a:	f0 1f 00 11 	mcall	800035dc <fl_read+0x68>
8000359e:	ef 4c 00 48 	st.w	r7[72],r12
	memcpy(fl_read_ptr->buffer, buffer, length);
800035a2:	0c 9a       	mov	r10,r6
800035a4:	06 9b       	mov	r11,r3
800035a6:	f0 1f 00 10 	mcall	800035e4 <fl_read+0x70>
	
	fl_oper_t fl_oper;
	
	fl_oper.opcode = FL_READ;
800035aa:	e0 68 40 01 	mov	r8,16385
800035ae:	ba 08       	st.h	sp[0x0],r8
	fl_oper.payload = fl_read_ptr;
800035b0:	50 17       	stdsp	sp[0x4],r7
	
	if(pdTRUE != xQueueSend( fl_oper_queue, &fl_oper, 0 ))
800035b2:	48 e8       	lddpc	r8,800035e8 <fl_read+0x74>
800035b4:	70 0c       	ld.w	r12,r8[0x0]
800035b6:	30 09       	mov	r9,0
800035b8:	12 9a       	mov	r10,r9
800035ba:	1a 9b       	mov	r11,sp
800035bc:	f0 1f 00 0c 	mcall	800035ec <fl_read+0x78>
800035c0:	58 1c       	cp.w	r12,1
800035c2:	c0 a0       	breq	800035d6 <fl_read+0x62>
	{
		vPortFree(fl_read_ptr->buffer);
800035c4:	6f 2c       	ld.w	r12,r7[0x48]
800035c6:	f0 1f 00 0b 	mcall	800035f0 <fl_read+0x7c>
		vPortFree(fl_read_ptr);
800035ca:	0e 9c       	mov	r12,r7
800035cc:	f0 1f 00 09 	mcall	800035f0 <fl_read+0x7c>
		log("\n\r Rmm \n\r");//man...SPI_PBA
800035d0:	48 9c       	lddpc	r12,800035f4 <fl_read+0x80>
800035d2:	f0 1f 00 0a 	mcall	800035f8 <fl_read+0x84>
	}
	
}
800035d6:	2f ed       	sub	sp,-8
800035d8:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
800035dc:	80 00       	ld.sh	r0,r0[0x0]
800035de:	8f fc       	st.w	r7[0x3c],r12
800035e0:	80 00       	ld.sh	r0,r0[0x0]
800035e2:	ad 78       	lsl	r8,0xd
800035e4:	80 00       	ld.sh	r0,r0[0x0]
800035e6:	a9 06       	ld.d	r6,r4
800035e8:	00 00       	add	r0,r0
800035ea:	0d 40       	ld.w	r0,--r6
800035ec:	80 00       	ld.sh	r0,r0[0x0]
800035ee:	93 50       	st.w	r9[0x14],r0
800035f0:	80 00       	ld.sh	r0,r0[0x0]
800035f2:	8f d4       	st.w	r7[0x34],r4
800035f4:	80 01       	ld.sh	r1,r0[0x0]
800035f6:	09 e8       	ld.ub	r8,r4[0x6]
800035f8:	80 00       	ld.sh	r0,r0[0x0]
800035fa:	9f 40       	st.w	pc[0x10],r0

800035fc <fl_write>:
	}
}


void fl_write(void * path, S32 offset, void * buffer, U32 length)
{
800035fc:	eb cd 40 f8 	pushm	r3-r7,lr
80003600:	20 2d       	sub	sp,8
80003602:	18 95       	mov	r5,r12
80003604:	16 94       	mov	r4,r11
80003606:	14 93       	mov	r3,r10
80003608:	12 96       	mov	r6,r9
	
	fl_write_t * fl_write_ptr = pvPortMalloc(sizeof(fl_write_t));
8000360a:	34 cc       	mov	r12,76
8000360c:	f0 1f 00 16 	mcall	80003664 <fl_write+0x68>
80003610:	18 97       	mov	r7,r12
	
	sprintf(fl_write_ptr->path, "%s", path);
80003612:	0a 9b       	mov	r11,r5
80003614:	f0 1f 00 15 	mcall	80003668 <fl_write+0x6c>
	fl_write_ptr->offset = offset;
80003618:	ef 44 00 40 	st.w	r7[64],r4
	fl_write_ptr->length = length;	
8000361c:	ef 46 00 44 	st.w	r7[68],r6
	
	fl_write_ptr->buffer = pvPortMalloc(length);
80003620:	0c 9c       	mov	r12,r6
80003622:	f0 1f 00 11 	mcall	80003664 <fl_write+0x68>
80003626:	ef 4c 00 48 	st.w	r7[72],r12
	memcpy(fl_write_ptr->buffer, buffer, length);
8000362a:	0c 9a       	mov	r10,r6
8000362c:	06 9b       	mov	r11,r3
8000362e:	f0 1f 00 10 	mcall	8000366c <fl_write+0x70>
	
	fl_oper_t fl_oper;
	
	fl_oper.opcode = FL_WRITE;
80003632:	e0 68 40 00 	mov	r8,16384
80003636:	ba 08       	st.h	sp[0x0],r8
	fl_oper.payload = fl_write_ptr;
80003638:	50 17       	stdsp	sp[0x4],r7
	
	if(pdTRUE != xQueueSend( fl_oper_queue, &fl_oper, 0 ))
8000363a:	48 e8       	lddpc	r8,80003670 <fl_write+0x74>
8000363c:	70 0c       	ld.w	r12,r8[0x0]
8000363e:	30 09       	mov	r9,0
80003640:	12 9a       	mov	r10,r9
80003642:	1a 9b       	mov	r11,sp
80003644:	f0 1f 00 0c 	mcall	80003674 <fl_write+0x78>
80003648:	58 1c       	cp.w	r12,1
8000364a:	c0 a0       	breq	8000365e <fl_write+0x62>
	{
		vPortFree(fl_write_ptr->buffer);
8000364c:	6f 2c       	ld.w	r12,r7[0x48]
8000364e:	f0 1f 00 0b 	mcall	80003678 <fl_write+0x7c>
		vPortFree(fl_write_ptr);
80003652:	0e 9c       	mov	r12,r7
80003654:	f0 1f 00 09 	mcall	80003678 <fl_write+0x7c>
		log("\n\r Wmm \n\r");//man...SPI_PBA
80003658:	48 9c       	lddpc	r12,8000367c <fl_write+0x80>
8000365a:	f0 1f 00 0a 	mcall	80003680 <fl_write+0x84>
	}
	
}
8000365e:	2f ed       	sub	sp,-8
80003660:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80003664:	80 00       	ld.sh	r0,r0[0x0]
80003666:	8f fc       	st.w	r7[0x3c],r12
80003668:	80 00       	ld.sh	r0,r0[0x0]
8000366a:	ad 78       	lsl	r8,0xd
8000366c:	80 00       	ld.sh	r0,r0[0x0]
8000366e:	a9 06       	ld.d	r6,r4
80003670:	00 00       	add	r0,r0
80003672:	0d 40       	ld.w	r0,--r6
80003674:	80 00       	ld.sh	r0,r0[0x0]
80003676:	93 50       	st.w	r9[0x14],r0
80003678:	80 00       	ld.sh	r0,r0[0x0]
8000367a:	8f d4       	st.w	r7[0x34],r4
8000367c:	80 01       	ld.sh	r1,r0[0x0]
8000367e:	09 f4       	ld.ub	r4,r4[0x7]
80003680:	80 00       	ld.sh	r0,r0[0x0]
80003682:	9f 40       	st.w	pc[0x10],r0

80003684 <fl_write_func>:
	f_mount(NULL, "/", 1);		
	return fs_ok;
}

fs_err_t fl_write_func(void * path, S32 offset, void * buffer, U32 length)
{	
80003684:	d4 31       	pushm	r0-r7,lr
80003686:	20 1d       	sub	sp,4
80003688:	18 97       	mov	r7,r12
8000368a:	16 96       	mov	r6,r11
8000368c:	14 94       	mov	r4,r10
8000368e:	12 95       	mov	r5,r9
	if(f_mount(&fs, "/", 1) != FR_OK)
80003690:	30 1a       	mov	r10,1
80003692:	4c 7b       	lddpc	r11,800037ac <fl_write_func+0x128>
80003694:	4c 7c       	lddpc	r12,800037b0 <fl_write_func+0x12c>
80003696:	f0 1f 00 48 	mcall	800037b4 <fl_write_func+0x130>
8000369a:	e0 81 00 86 	brne	800037a6 <fl_write_func+0x122>
	{
		return amount_err;
	}
	
	FRESULT res	= f_open (&fl, path, FA_WRITE | FA_OPEN_ALWAYS);
8000369e:	0e 91       	mov	r1,r7
800036a0:	31 2a       	mov	r10,18
800036a2:	0e 9b       	mov	r11,r7
800036a4:	4c 5c       	lddpc	r12,800037b8 <fl_write_func+0x134>
800036a6:	f0 1f 00 46 	mcall	800037bc <fl_write_func+0x138>
	if(FR_NO_PATH == res)
800036aa:	58 5c       	cp.w	r12,5
800036ac:	c5 91       	brne	8000375e <fl_write_func+0xda>
	{
		if ( f_opendir(&dirs, "/") != FR_OK)
800036ae:	4c 0b       	lddpc	r11,800037ac <fl_write_func+0x128>
800036b0:	4c 4c       	lddpc	r12,800037c0 <fl_write_func+0x13c>
800036b2:	f0 1f 00 45 	mcall	800037c4 <fl_write_func+0x140>
800036b6:	c0 80       	breq	800036c6 <fl_write_func+0x42>
		{
			f_mount(NULL, "/", 1);
800036b8:	30 1a       	mov	r10,1
800036ba:	4b db       	lddpc	r11,800037ac <fl_write_func+0x128>
800036bc:	30 0c       	mov	r12,0
800036be:	f0 1f 00 3e 	mcall	800037b4 <fl_write_func+0x130>
800036c2:	30 6c       	mov	r12,6
			return fs_err;
800036c4:	c7 28       	rjmp	800037a8 <fl_write_func+0x124>
		}
		
		static char filename[MAX_PATH_LENGTH], path_bk[MAX_PATH_LENGTH];		
		memcpy(path_bk, path, strlen(path));
800036c6:	0e 9c       	mov	r12,r7
800036c8:	f0 1f 00 40 	mcall	800037c8 <fl_write_func+0x144>
800036cc:	4c 03       	lddpc	r3,800037cc <fl_write_func+0x148>
800036ce:	18 9a       	mov	r10,r12
800036d0:	0e 9b       	mov	r11,r7
800036d2:	06 9c       	mov	r12,r3
800036d4:	f0 1f 00 3f 	mcall	800037d0 <fl_write_func+0x14c>
				
		char * dir = strtok(path_bk,"/");
800036d8:	4b 57       	lddpc	r7,800037ac <fl_write_func+0x128>
800036da:	0e 9b       	mov	r11,r7
800036dc:	06 9c       	mov	r12,r3
800036de:	f0 1f 00 3e 	mcall	800037d4 <fl_write_func+0x150>
		sprintf(filename,"//%s", dir);		
800036e2:	1a dc       	st.w	--sp,r12
800036e4:	4b db       	lddpc	r11,800037d8 <fl_write_func+0x154>
800036e6:	4b ec       	lddpc	r12,800037dc <fl_write_func+0x158>
800036e8:	f0 1f 00 3e 	mcall	800037e0 <fl_write_func+0x15c>
		dir = strtok(NULL,"/");
800036ec:	0e 9b       	mov	r11,r7
800036ee:	30 0c       	mov	r12,0
800036f0:	f0 1f 00 39 	mcall	800037d4 <fl_write_func+0x150>
800036f4:	18 97       	mov	r7,r12
		while(TRUE)
		{
			if(NULL != dir)
800036f6:	2f fd       	sub	sp,-4
800036f8:	58 0c       	cp.w	r12,0
800036fa:	c2 50       	breq	80003744 <fl_write_func+0xc0>
			{				
				res = f_mkdir(filename);
800036fc:	4b 83       	lddpc	r3,800037dc <fl_write_func+0x158>
				if((res == FR_OK) || (res == FR_EXIST))
800036fe:	30 02       	mov	r2,0
				{					
					sprintf(filename,"%s//%s", filename, dir);
80003700:	4b 90       	lddpc	r0,800037e4 <fl_write_func+0x160>
		dir = strtok(NULL,"/");
		while(TRUE)
		{
			if(NULL != dir)
			{				
				res = f_mkdir(filename);
80003702:	06 9c       	mov	r12,r3
80003704:	f0 1f 00 39 	mcall	800037e8 <fl_write_func+0x164>
				if((res == FR_OK) || (res == FR_EXIST))
80003708:	5f 09       	sreq	r9
8000370a:	58 8c       	cp.w	r12,8
8000370c:	5f 08       	sreq	r8
8000370e:	f3 e8 10 08 	or	r8,r9,r8
80003712:	e4 08 18 00 	cp.b	r8,r2
80003716:	c1 00       	breq	80003736 <fl_write_func+0xb2>
				{					
					sprintf(filename,"%s//%s", filename, dir);
80003718:	1a d7       	st.w	--sp,r7
8000371a:	1a d3       	st.w	--sp,r3
8000371c:	00 9b       	mov	r11,r0
8000371e:	06 9c       	mov	r12,r3
80003720:	f0 1f 00 30 	mcall	800037e0 <fl_write_func+0x15c>
					dir = strtok(NULL,"/");					
80003724:	4a 2b       	lddpc	r11,800037ac <fl_write_func+0x128>
80003726:	30 0c       	mov	r12,0
80003728:	f0 1f 00 2b 	mcall	800037d4 <fl_write_func+0x150>
8000372c:	18 97       	mov	r7,r12
		char * dir = strtok(path_bk,"/");
		sprintf(filename,"//%s", dir);		
		dir = strtok(NULL,"/");
		while(TRUE)
		{
			if(NULL != dir)
8000372e:	2f ed       	sub	sp,-8
80003730:	58 0c       	cp.w	r12,0
80003732:	ce 81       	brne	80003702 <fl_write_func+0x7e>
80003734:	c0 88       	rjmp	80003744 <fl_write_func+0xc0>
					sprintf(filename,"%s//%s", filename, dir);
					dir = strtok(NULL,"/");					
				}
				else
				{
					f_mount(NULL, "/", 1);	
80003736:	30 1a       	mov	r10,1
80003738:	49 db       	lddpc	r11,800037ac <fl_write_func+0x128>
8000373a:	30 0c       	mov	r12,0
8000373c:	f0 1f 00 1e 	mcall	800037b4 <fl_write_func+0x130>
80003740:	30 4c       	mov	r12,4
					return new_dir_err;
80003742:	c3 38       	rjmp	800037a8 <fl_write_func+0x124>
				}
				
			}
			else
			{
				res	= f_open (&fl, path, FA_WRITE | FA_OPEN_ALWAYS);
80003744:	31 2a       	mov	r10,18
80003746:	02 9b       	mov	r11,r1
80003748:	49 cc       	lddpc	r12,800037b8 <fl_write_func+0x134>
8000374a:	f0 1f 00 1d 	mcall	800037bc <fl_write_func+0x138>
				if(res != FR_OK)
8000374e:	c1 10       	breq	80003770 <fl_write_func+0xec>
				{					
					f_mount(NULL, "/", 1);	
80003750:	30 1a       	mov	r10,1
80003752:	49 7b       	lddpc	r11,800037ac <fl_write_func+0x128>
80003754:	30 0c       	mov	r12,0
80003756:	f0 1f 00 18 	mcall	800037b4 <fl_write_func+0x130>
8000375a:	30 3c       	mov	r12,3
					return open_fl_err;
8000375c:	c2 68       	rjmp	800037a8 <fl_write_func+0x124>
				}
				break;
			}
		}
	}
	else if(res != FR_OK)
8000375e:	58 0c       	cp.w	r12,0
80003760:	c0 80       	breq	80003770 <fl_write_func+0xec>
	{
		f_mount(NULL, "/", 1);
80003762:	30 1a       	mov	r10,1
80003764:	49 2b       	lddpc	r11,800037ac <fl_write_func+0x128>
80003766:	30 0c       	mov	r12,0
80003768:	f0 1f 00 13 	mcall	800037b4 <fl_write_func+0x130>
8000376c:	30 3c       	mov	r12,3
		return open_fl_err;
8000376e:	c1 d8       	rjmp	800037a8 <fl_write_func+0x124>
	}
	
	if(offset == FILE_END)
80003770:	5b f6       	cp.w	r6,-1
80003772:	c0 61       	brne	8000377e <fl_write_func+0xfa>
	{
		f_lseek(&fl, fl.fsize);
80003774:	49 1c       	lddpc	r12,800037b8 <fl_write_func+0x134>
80003776:	78 3b       	ld.w	r11,r12[0xc]
80003778:	f0 1f 00 1d 	mcall	800037ec <fl_write_func+0x168>
8000377c:	c0 58       	rjmp	80003786 <fl_write_func+0x102>
	}
	else
	{
		f_lseek(&fl, offset);
8000377e:	0c 9b       	mov	r11,r6
80003780:	48 ec       	lddpc	r12,800037b8 <fl_write_func+0x134>
80003782:	f0 1f 00 1b 	mcall	800037ec <fl_write_func+0x168>
	}
	
	UINT w;
	f_write (&fl, buffer, length, &w );
80003786:	48 d7       	lddpc	r7,800037b8 <fl_write_func+0x134>
80003788:	1a 99       	mov	r9,sp
8000378a:	0a 9a       	mov	r10,r5
8000378c:	08 9b       	mov	r11,r4
8000378e:	0e 9c       	mov	r12,r7
80003790:	f0 1f 00 18 	mcall	800037f0 <fl_write_func+0x16c>

	f_close (&fl);
80003794:	0e 9c       	mov	r12,r7
80003796:	f0 1f 00 18 	mcall	800037f4 <fl_write_func+0x170>
		
	f_mount(NULL, "/", 1);	
8000379a:	30 1a       	mov	r10,1
8000379c:	48 4b       	lddpc	r11,800037ac <fl_write_func+0x128>
8000379e:	30 0c       	mov	r12,0
800037a0:	f0 1f 00 05 	mcall	800037b4 <fl_write_func+0x130>
800037a4:	c0 28       	rjmp	800037a8 <fl_write_func+0x124>
}
800037a6:	30 2c       	mov	r12,2
800037a8:	2f fd       	sub	sp,-4
800037aa:	d8 32       	popm	r0-r7,pc
800037ac:	80 01       	ld.sh	r1,r0[0x0]
800037ae:	09 e4       	ld.ub	r4,r4[0x6]
800037b0:	00 00       	add	r0,r0
800037b2:	0a b0       	st.h	r5++,r0
800037b4:	80 00       	ld.sh	r0,r0[0x0]
800037b6:	73 c8       	ld.w	r8,r9[0x70]
800037b8:	00 00       	add	r0,r0
800037ba:	0d c8       	ld.ub	r8,r6[0x4]
800037bc:	80 00       	ld.sh	r0,r0[0x0]
800037be:	83 94       	st.w	r1[0x24],r4
800037c0:	00 00       	add	r0,r0
800037c2:	0c e0       	st.h	--r6,r0
800037c4:	80 00       	ld.sh	r0,r0[0x0]
800037c6:	81 58       	st.w	r0[0x14],r8
800037c8:	80 00       	ld.sh	r0,r0[0x0]
800037ca:	ad 8a       	lsr	r10,0xc
800037cc:	00 00       	add	r0,r0
800037ce:	0d 44       	ld.w	r4,--r6
800037d0:	80 00       	ld.sh	r0,r0[0x0]
800037d2:	a9 06       	ld.d	r6,r4
800037d4:	80 00       	ld.sh	r0,r0[0x0]
800037d6:	ad c0       	cbr	r0,0xc
800037d8:	80 01       	ld.sh	r1,r0[0x0]
800037da:	0a 00       	add	r0,r5
800037dc:	00 00       	add	r0,r0
800037de:	0d 88       	ld.ub	r8,r6[0x0]
800037e0:	80 00       	ld.sh	r0,r0[0x0]
800037e2:	ad 3c       	mul	r12,r6
800037e4:	80 01       	ld.sh	r1,r0[0x0]
800037e6:	0a 08       	add	r8,r5
800037e8:	80 00       	ld.sh	r0,r0[0x0]
800037ea:	81 dc       	st.w	r0[0x34],r12
800037ec:	80 00       	ld.sh	r0,r0[0x0]
800037ee:	86 34       	ld.sh	r4,r3[0x6]
800037f0:	80 00       	ld.sh	r0,r0[0x0]
800037f2:	88 e8       	ld.uh	r8,r4[0xc]
800037f4:	80 00       	ld.sh	r0,r0[0x0]
800037f6:	75 14       	ld.w	r4,r10[0x44]

800037f8 <fl_read_func>:



fs_err_t fl_read_func(void * path, S32 offset, void * buffer, U32 length)
{
800037f8:	d4 31       	pushm	r0-r7,lr
800037fa:	20 1d       	sub	sp,4
800037fc:	18 97       	mov	r7,r12
800037fe:	16 96       	mov	r6,r11
80003800:	14 94       	mov	r4,r10
80003802:	12 95       	mov	r5,r9
	if(f_mount(&fs, "/", 1) != FR_OK)
80003804:	30 1a       	mov	r10,1
80003806:	4c 7b       	lddpc	r11,80003920 <fl_read_func+0x128>
80003808:	4c 7c       	lddpc	r12,80003924 <fl_read_func+0x12c>
8000380a:	f0 1f 00 48 	mcall	80003928 <fl_read_func+0x130>
8000380e:	e0 81 00 86 	brne	8000391a <fl_read_func+0x122>
		{
			return amount_err;
		}
	
		FRESULT res	= f_open (&fl, path, FA_READ | FA_OPEN_EXISTING);
80003812:	0e 91       	mov	r1,r7
80003814:	30 1a       	mov	r10,1
80003816:	0e 9b       	mov	r11,r7
80003818:	4c 5c       	lddpc	r12,8000392c <fl_read_func+0x134>
8000381a:	f0 1f 00 46 	mcall	80003930 <fl_read_func+0x138>
		if(FR_NO_PATH == res)
8000381e:	58 5c       	cp.w	r12,5
80003820:	c5 91       	brne	800038d2 <fl_read_func+0xda>
		{
			if ( f_opendir(&dirs, "/") != FR_OK)
80003822:	4c 0b       	lddpc	r11,80003920 <fl_read_func+0x128>
80003824:	4c 4c       	lddpc	r12,80003934 <fl_read_func+0x13c>
80003826:	f0 1f 00 45 	mcall	80003938 <fl_read_func+0x140>
8000382a:	c0 80       	breq	8000383a <fl_read_func+0x42>
			{
				f_mount(NULL, "/", 1);
8000382c:	30 1a       	mov	r10,1
8000382e:	4b db       	lddpc	r11,80003920 <fl_read_func+0x128>
80003830:	30 0c       	mov	r12,0
80003832:	f0 1f 00 3e 	mcall	80003928 <fl_read_func+0x130>
80003836:	30 6c       	mov	r12,6
				return fs_err;
80003838:	c7 28       	rjmp	8000391c <fl_read_func+0x124>
			}
		
			static char filename[MAX_PATH_LENGTH], path_bk[MAX_PATH_LENGTH];		
			memcpy(path_bk, path, strlen(path));
8000383a:	0e 9c       	mov	r12,r7
8000383c:	f0 1f 00 40 	mcall	8000393c <fl_read_func+0x144>
80003840:	4c 03       	lddpc	r3,80003940 <fl_read_func+0x148>
80003842:	18 9a       	mov	r10,r12
80003844:	0e 9b       	mov	r11,r7
80003846:	06 9c       	mov	r12,r3
80003848:	f0 1f 00 3f 	mcall	80003944 <fl_read_func+0x14c>
				
			char * dir = strtok(path_bk,"/");
8000384c:	4b 57       	lddpc	r7,80003920 <fl_read_func+0x128>
8000384e:	0e 9b       	mov	r11,r7
80003850:	06 9c       	mov	r12,r3
80003852:	f0 1f 00 3e 	mcall	80003948 <fl_read_func+0x150>
			sprintf(filename,"//%s", dir);		
80003856:	1a dc       	st.w	--sp,r12
80003858:	4b db       	lddpc	r11,8000394c <fl_read_func+0x154>
8000385a:	4b ec       	lddpc	r12,80003950 <fl_read_func+0x158>
8000385c:	f0 1f 00 3e 	mcall	80003954 <fl_read_func+0x15c>
			dir = strtok(NULL,"/");
80003860:	0e 9b       	mov	r11,r7
80003862:	30 0c       	mov	r12,0
80003864:	f0 1f 00 39 	mcall	80003948 <fl_read_func+0x150>
80003868:	18 97       	mov	r7,r12
			while(TRUE)
			{
				if(NULL != dir)
8000386a:	2f fd       	sub	sp,-4
8000386c:	58 0c       	cp.w	r12,0
8000386e:	c2 50       	breq	800038b8 <fl_read_func+0xc0>
				{				
					res = f_mkdir(filename);
80003870:	4b 83       	lddpc	r3,80003950 <fl_read_func+0x158>
					if((res == FR_OK) || (res == FR_EXIST))
80003872:	30 02       	mov	r2,0
					{					
						sprintf(filename,"%s//%s", filename, dir);
80003874:	4b 90       	lddpc	r0,80003958 <fl_read_func+0x160>
			dir = strtok(NULL,"/");
			while(TRUE)
			{
				if(NULL != dir)
				{				
					res = f_mkdir(filename);
80003876:	06 9c       	mov	r12,r3
80003878:	f0 1f 00 39 	mcall	8000395c <fl_read_func+0x164>
					if((res == FR_OK) || (res == FR_EXIST))
8000387c:	5f 09       	sreq	r9
8000387e:	58 8c       	cp.w	r12,8
80003880:	5f 08       	sreq	r8
80003882:	f3 e8 10 08 	or	r8,r9,r8
80003886:	e4 08 18 00 	cp.b	r8,r2
8000388a:	c1 00       	breq	800038aa <fl_read_func+0xb2>
					{					
						sprintf(filename,"%s//%s", filename, dir);
8000388c:	1a d7       	st.w	--sp,r7
8000388e:	1a d3       	st.w	--sp,r3
80003890:	00 9b       	mov	r11,r0
80003892:	06 9c       	mov	r12,r3
80003894:	f0 1f 00 30 	mcall	80003954 <fl_read_func+0x15c>
						dir = strtok(NULL,"/");					
80003898:	4a 2b       	lddpc	r11,80003920 <fl_read_func+0x128>
8000389a:	30 0c       	mov	r12,0
8000389c:	f0 1f 00 2b 	mcall	80003948 <fl_read_func+0x150>
800038a0:	18 97       	mov	r7,r12
			char * dir = strtok(path_bk,"/");
			sprintf(filename,"//%s", dir);		
			dir = strtok(NULL,"/");
			while(TRUE)
			{
				if(NULL != dir)
800038a2:	2f ed       	sub	sp,-8
800038a4:	58 0c       	cp.w	r12,0
800038a6:	ce 81       	brne	80003876 <fl_read_func+0x7e>
800038a8:	c0 88       	rjmp	800038b8 <fl_read_func+0xc0>
						sprintf(filename,"%s//%s", filename, dir);
						dir = strtok(NULL,"/");					
					}
					else
					{
						f_mount(NULL, "/", 1);	
800038aa:	30 1a       	mov	r10,1
800038ac:	49 db       	lddpc	r11,80003920 <fl_read_func+0x128>
800038ae:	30 0c       	mov	r12,0
800038b0:	f0 1f 00 1e 	mcall	80003928 <fl_read_func+0x130>
800038b4:	30 4c       	mov	r12,4
						return new_dir_err;
800038b6:	c3 38       	rjmp	8000391c <fl_read_func+0x124>
					}
				
				}
				else
				{
					res	= f_open (&fl, path, FA_READ | FA_OPEN_EXISTING);
800038b8:	30 1a       	mov	r10,1
800038ba:	02 9b       	mov	r11,r1
800038bc:	49 cc       	lddpc	r12,8000392c <fl_read_func+0x134>
800038be:	f0 1f 00 1d 	mcall	80003930 <fl_read_func+0x138>
					if(res != FR_OK)
800038c2:	c1 10       	breq	800038e4 <fl_read_func+0xec>
					{					
						f_mount(NULL, "/", 1);	
800038c4:	30 1a       	mov	r10,1
800038c6:	49 7b       	lddpc	r11,80003920 <fl_read_func+0x128>
800038c8:	30 0c       	mov	r12,0
800038ca:	f0 1f 00 18 	mcall	80003928 <fl_read_func+0x130>
800038ce:	30 3c       	mov	r12,3
						return open_fl_err;
800038d0:	c2 68       	rjmp	8000391c <fl_read_func+0x124>
					}
					break;
				}
			}
		}
		else if(res != FR_OK)
800038d2:	58 0c       	cp.w	r12,0
800038d4:	c0 80       	breq	800038e4 <fl_read_func+0xec>
		{
			f_mount(NULL, "/", 1);
800038d6:	30 1a       	mov	r10,1
800038d8:	49 2b       	lddpc	r11,80003920 <fl_read_func+0x128>
800038da:	30 0c       	mov	r12,0
800038dc:	f0 1f 00 13 	mcall	80003928 <fl_read_func+0x130>
800038e0:	30 3c       	mov	r12,3
			return open_fl_err;
800038e2:	c1 d8       	rjmp	8000391c <fl_read_func+0x124>
		}
	
		if(offset == FILE_END)
800038e4:	5b f6       	cp.w	r6,-1
800038e6:	c0 61       	brne	800038f2 <fl_read_func+0xfa>
		{
			f_lseek(&fl, fl.fsize);
800038e8:	49 1c       	lddpc	r12,8000392c <fl_read_func+0x134>
800038ea:	78 3b       	ld.w	r11,r12[0xc]
800038ec:	f0 1f 00 1d 	mcall	80003960 <fl_read_func+0x168>
800038f0:	c0 58       	rjmp	800038fa <fl_read_func+0x102>
		}
		else
		{
			f_lseek(&fl, offset);
800038f2:	0c 9b       	mov	r11,r6
800038f4:	48 ec       	lddpc	r12,8000392c <fl_read_func+0x134>
800038f6:	f0 1f 00 1b 	mcall	80003960 <fl_read_func+0x168>
		}
	
		UINT w;
		f_read (&fl, buffer, length, &w );
800038fa:	48 d7       	lddpc	r7,8000392c <fl_read_func+0x134>
800038fc:	1a 99       	mov	r9,sp
800038fe:	0a 9a       	mov	r10,r5
80003900:	08 9b       	mov	r11,r4
80003902:	0e 9c       	mov	r12,r7
80003904:	f0 1f 00 18 	mcall	80003964 <fl_read_func+0x16c>

		f_close (&fl);
80003908:	0e 9c       	mov	r12,r7
8000390a:	f0 1f 00 18 	mcall	80003968 <fl_read_func+0x170>
		
		f_mount(NULL, "/", 1);		
8000390e:	30 1a       	mov	r10,1
80003910:	48 4b       	lddpc	r11,80003920 <fl_read_func+0x128>
80003912:	30 0c       	mov	r12,0
80003914:	f0 1f 00 05 	mcall	80003928 <fl_read_func+0x130>
80003918:	c0 28       	rjmp	8000391c <fl_read_func+0x124>
	
	
	
	
	
}
8000391a:	30 2c       	mov	r12,2
8000391c:	2f fd       	sub	sp,-4
8000391e:	d8 32       	popm	r0-r7,pc
80003920:	80 01       	ld.sh	r1,r0[0x0]
80003922:	09 e4       	ld.ub	r4,r4[0x6]
80003924:	00 00       	add	r0,r0
80003926:	0a b0       	st.h	r5++,r0
80003928:	80 00       	ld.sh	r0,r0[0x0]
8000392a:	73 c8       	ld.w	r8,r9[0x70]
8000392c:	00 00       	add	r0,r0
8000392e:	0d c8       	ld.ub	r8,r6[0x4]
80003930:	80 00       	ld.sh	r0,r0[0x0]
80003932:	83 94       	st.w	r1[0x24],r4
80003934:	00 00       	add	r0,r0
80003936:	0c e0       	st.h	--r6,r0
80003938:	80 00       	ld.sh	r0,r0[0x0]
8000393a:	81 58       	st.w	r0[0x14],r8
8000393c:	80 00       	ld.sh	r0,r0[0x0]
8000393e:	ad 8a       	lsr	r10,0xc
80003940:	00 00       	add	r0,r0
80003942:	0a 6c       	and	r12,r5
80003944:	80 00       	ld.sh	r0,r0[0x0]
80003946:	a9 06       	ld.d	r6,r4
80003948:	80 00       	ld.sh	r0,r0[0x0]
8000394a:	ad c0       	cbr	r0,0xc
8000394c:	80 01       	ld.sh	r1,r0[0x0]
8000394e:	0a 00       	add	r0,r5
80003950:	00 00       	add	r0,r0
80003952:	0d 00       	ld.w	r0,r6++
80003954:	80 00       	ld.sh	r0,r0[0x0]
80003956:	ad 3c       	mul	r12,r6
80003958:	80 01       	ld.sh	r1,r0[0x0]
8000395a:	0a 08       	add	r8,r5
8000395c:	80 00       	ld.sh	r0,r0[0x0]
8000395e:	81 dc       	st.w	r0[0x34],r12
80003960:	80 00       	ld.sh	r0,r0[0x0]
80003962:	86 34       	ld.sh	r4,r3[0x6]
80003964:	80 00       	ld.sh	r0,r0[0x0]
80003966:	8a c8       	ld.uh	r8,r5[0x8]
80003968:	80 00       	ld.sh	r0,r0[0x0]
8000396a:	75 14       	ld.w	r4,r10[0x44]

8000396c <fl_oper_process>:



static void fl_oper_process(void * pvParameters)
{
8000396c:	eb cd 40 fc 	pushm	r2-r7,lr
	fl_oper_t * fl_oper = pvPortMalloc(sizeof(fl_oper_t));
80003970:	30 8c       	mov	r12,8
80003972:	f0 1f 00 23 	mcall	800039fc <fl_oper_process+0x90>
80003976:	18 97       	mov	r7,r12
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( fl_oper_queue, fl_oper, portMAX_DELAY ))
80003978:	4a 26       	lddpc	r6,80003a00 <fl_oper_process+0x94>
8000397a:	30 05       	mov	r5,0
8000397c:	3f f4       	mov	r4,-1
		{  
			switch(fl_oper->opcode)
8000397e:	e0 63 40 00 	mov	r3,16384
80003982:	e0 62 40 01 	mov	r2,16385
static void fl_oper_process(void * pvParameters)
{
	fl_oper_t * fl_oper = pvPortMalloc(sizeof(fl_oper_t));
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( fl_oper_queue, fl_oper, portMAX_DELAY ))
80003986:	6c 0c       	ld.w	r12,r6[0x0]
80003988:	0a 99       	mov	r9,r5
8000398a:	08 9a       	mov	r10,r4
8000398c:	0e 9b       	mov	r11,r7
8000398e:	f0 1f 00 1e 	mcall	80003a04 <fl_oper_process+0x98>
80003992:	58 1c       	cp.w	r12,1
80003994:	cf 91       	brne	80003986 <fl_oper_process+0x1a>
		{  
			switch(fl_oper->opcode)
80003996:	8e 08       	ld.sh	r8,r7[0x0]
80003998:	e6 08 19 00 	cp.h	r8,r3
8000399c:	c0 50       	breq	800039a6 <fl_oper_process+0x3a>
8000399e:	e4 08 19 00 	cp.h	r8,r2
800039a2:	c2 61       	brne	800039ee <fl_oper_process+0x82>
800039a4:	c1 38       	rjmp	800039ca <fl_oper_process+0x5e>
			{
			case FL_WRITE:
			
				if(NULL != fl_oper->payload)
800039a6:	6e 1c       	ld.w	r12,r7[0x4]
800039a8:	58 0c       	cp.w	r12,0
800039aa:	ce e0       	breq	80003986 <fl_oper_process+0x1a>
				{
					if(NULL != ((fl_write_t *)(fl_oper->payload))->buffer)
800039ac:	79 2a       	ld.w	r10,r12[0x48]
800039ae:	58 0a       	cp.w	r10,0
800039b0:	c0 90       	breq	800039c2 <fl_oper_process+0x56>
					{
						fl_write_func(((fl_write_t *)(fl_oper->payload))->path
800039b2:	79 19       	ld.w	r9,r12[0x44]
800039b4:	79 0b       	ld.w	r11,r12[0x40]
800039b6:	f0 1f 00 15 	mcall	80003a08 <fl_oper_process+0x9c>
							, ((fl_write_t *)(fl_oper->payload))->offset
							, ((fl_write_t *)(fl_oper->payload))->buffer
							, ((fl_write_t *)(fl_oper->payload))->length);
						
						vPortFree(((fl_write_t *)(fl_oper->payload))->buffer);
800039ba:	6e 18       	ld.w	r8,r7[0x4]
800039bc:	71 2c       	ld.w	r12,r8[0x48]
800039be:	f0 1f 00 14 	mcall	80003a0c <fl_oper_process+0xa0>
					}
					vPortFree(fl_oper->payload);					
800039c2:	6e 1c       	ld.w	r12,r7[0x4]
800039c4:	f0 1f 00 12 	mcall	80003a0c <fl_oper_process+0xa0>
800039c8:	cd fb       	rjmp	80003986 <fl_oper_process+0x1a>
				}
				break;
				
			case FL_READ:
			
				if(NULL != fl_oper->payload)
800039ca:	6e 1c       	ld.w	r12,r7[0x4]
800039cc:	58 0c       	cp.w	r12,0
800039ce:	cd c0       	breq	80003986 <fl_oper_process+0x1a>
				{
					if(NULL != ((fl_read_t *)(fl_oper->payload))->buffer)
800039d0:	79 2a       	ld.w	r10,r12[0x48]
800039d2:	58 0a       	cp.w	r10,0
800039d4:	c0 90       	breq	800039e6 <fl_oper_process+0x7a>
					{
						fl_read_func(((fl_read_t *)(fl_oper->payload))->path
800039d6:	79 19       	ld.w	r9,r12[0x44]
800039d8:	79 0b       	ld.w	r11,r12[0x40]
800039da:	f0 1f 00 0e 	mcall	80003a10 <fl_oper_process+0xa4>
						, ((fl_read_t *)(fl_oper->payload))->offset
						, ((fl_read_t *)(fl_oper->payload))->buffer
						, ((fl_read_t *)(fl_oper->payload))->length);
						
						vPortFree(((fl_read_t *)(fl_oper->payload))->buffer);
800039de:	6e 18       	ld.w	r8,r7[0x4]
800039e0:	71 2c       	ld.w	r12,r8[0x48]
800039e2:	f0 1f 00 0b 	mcall	80003a0c <fl_oper_process+0xa0>
					}
					vPortFree(fl_oper->payload);
800039e6:	6e 1c       	ld.w	r12,r7[0x4]
800039e8:	f0 1f 00 09 	mcall	80003a0c <fl_oper_process+0xa0>
800039ec:	cc db       	rjmp	80003986 <fl_oper_process+0x1a>
				break;
			
			   
								
			default:
				if(NULL != fl_oper->payload)
800039ee:	6e 1c       	ld.w	r12,r7[0x4]
800039f0:	58 0c       	cp.w	r12,0
800039f2:	cc a0       	breq	80003986 <fl_oper_process+0x1a>
				{
					vPortFree(fl_oper->payload);
800039f4:	f0 1f 00 06 	mcall	80003a0c <fl_oper_process+0xa0>
800039f8:	cc 7b       	rjmp	80003986 <fl_oper_process+0x1a>
800039fa:	00 00       	add	r0,r0
800039fc:	80 00       	ld.sh	r0,r0[0x0]
800039fe:	8f fc       	st.w	r7[0x3c],r12
80003a00:	00 00       	add	r0,r0
80003a02:	0d 40       	ld.w	r0,--r6
80003a04:	80 00       	ld.sh	r0,r0[0x0]
80003a06:	91 44       	st.w	r8[0x10],r4
80003a08:	80 00       	ld.sh	r0,r0[0x0]
80003a0a:	36 84       	mov	r4,104
80003a0c:	80 00       	ld.sh	r0,r0[0x0]
80003a0e:	8f d4       	st.w	r7[0x34],r4
80003a10:	80 00       	ld.sh	r0,r0[0x0]
80003a12:	37 f8       	mov	r8,127

80003a14 <disk_init>:
APP_RES_OKDISK_OPERATION_ERRORSDFILE_OPERATION_ERROR
*/
//

fs_err_t disk_init(void)
{
80003a14:	d4 01       	pushm	lr
80003a16:	20 3d       	sub	sp,12
	char str[MAX_DISK_LABEL_SIZE];
	
	/*initialize disk*/
	if(MAL_InitConfig())
80003a18:	f0 1f 00 41 	mcall	80003b1c <disk_init+0x108>
80003a1c:	5c 8c       	casts.h	r12
80003a1e:	c0 30       	breq	80003a24 <disk_init+0x10>
80003a20:	30 1c       	mov	r12,1
80003a22:	c7 a8       	rjmp	80003b16 <disk_init+0x102>
	{
		return disk_err;
	}	
		
	if(f_mount(&fs, "/", 1) != FR_OK)
80003a24:	30 1a       	mov	r10,1
80003a26:	4b fb       	lddpc	r11,80003b20 <disk_init+0x10c>
80003a28:	4b fc       	lddpc	r12,80003b24 <disk_init+0x110>
80003a2a:	f0 1f 00 40 	mcall	80003b28 <disk_init+0x114>
80003a2e:	c0 30       	breq	80003a34 <disk_init+0x20>
80003a30:	30 2c       	mov	r12,2
80003a32:	c7 28       	rjmp	80003b16 <disk_init+0x102>
	{
		return amount_err;
	}
	
	FRESULT res = f_getfree("/", &clust, &pfs);
80003a34:	4b ea       	lddpc	r10,80003b2c <disk_init+0x118>
80003a36:	4b fb       	lddpc	r11,80003b30 <disk_init+0x11c>
80003a38:	4b ac       	lddpc	r12,80003b20 <disk_init+0x10c>
80003a3a:	f0 1f 00 3f 	mcall	80003b34 <disk_init+0x120>
	if(res == FR_NO_FILESYSTEM) 
80003a3e:	58 dc       	cp.w	r12,13
80003a40:	c1 41       	brne	80003a68 <disk_init+0x54>
	{
		/* Create a file system on the drive */
		res = f_mkfs (0, 0, 4096);
80003a42:	e0 6a 10 00 	mov	r10,4096
80003a46:	30 0b       	mov	r11,0
80003a48:	16 9c       	mov	r12,r11
80003a4a:	f0 1f 00 3c 	mcall	80003b38 <disk_init+0x124>
		if( f_getfree("/", &clust, &pfs) != FR_OK)
80003a4e:	4b 8a       	lddpc	r10,80003b2c <disk_init+0x118>
80003a50:	4b 8b       	lddpc	r11,80003b30 <disk_init+0x11c>
80003a52:	4b 4c       	lddpc	r12,80003b20 <disk_init+0x10c>
80003a54:	f0 1f 00 38 	mcall	80003b34 <disk_init+0x120>
80003a58:	c1 10       	breq	80003a7a <disk_init+0x66>
		{
			f_mount(NULL, "/", 1);	
80003a5a:	30 1a       	mov	r10,1
80003a5c:	4b 1b       	lddpc	r11,80003b20 <disk_init+0x10c>
80003a5e:	30 0c       	mov	r12,0
80003a60:	f0 1f 00 32 	mcall	80003b28 <disk_init+0x114>
80003a64:	30 5c       	mov	r12,5
			return no_fs;
80003a66:	c5 88       	rjmp	80003b16 <disk_init+0x102>
		}
	}
	else if(res != FR_OK)
80003a68:	58 0c       	cp.w	r12,0
80003a6a:	c0 80       	breq	80003a7a <disk_init+0x66>
	{
		f_mount(NULL, "/", 1);
80003a6c:	30 1a       	mov	r10,1
80003a6e:	4a db       	lddpc	r11,80003b20 <disk_init+0x10c>
80003a70:	30 0c       	mov	r12,0
80003a72:	f0 1f 00 2e 	mcall	80003b28 <disk_init+0x114>
80003a76:	30 6c       	mov	r12,6
		return fs_err;
80003a78:	c4 f8       	rjmp	80003b16 <disk_init+0x102>
	}
	
	
	//pdisk->freecap = ((clust*(pfs->csize)/1024/1024)*512);
	
	memset(str,0,MAX_DISK_LABEL_SIZE);
80003a7a:	1a 9b       	mov	r11,sp
80003a7c:	30 08       	mov	r8,0
80003a7e:	30 09       	mov	r9,0
80003a80:	fa e9 00 00 	st.d	sp[0],r8
80003a84:	30 0a       	mov	r10,0
80003a86:	50 2a       	stdsp	sp[0x8],r10
	if(f_getlabel("/", str, 0) != FR_OK)
80003a88:	4a 6c       	lddpc	r12,80003b20 <disk_init+0x10c>
80003a8a:	f0 1f 00 2d 	mcall	80003b3c <disk_init+0x128>
80003a8e:	c0 80       	breq	80003a9e <disk_init+0x8a>
	{
		f_mount(NULL, "/", 1);
80003a90:	30 1a       	mov	r10,1
80003a92:	4a 4b       	lddpc	r11,80003b20 <disk_init+0x10c>
80003a94:	30 0c       	mov	r12,0
80003a96:	f0 1f 00 25 	mcall	80003b28 <disk_init+0x114>
80003a9a:	30 6c       	mov	r12,6
		return fs_err;
80003a9c:	c3 d8       	rjmp	80003b16 <disk_init+0x102>
	}
		
	if(memcmp(DiskLabel, str, sizeof(DiskLabel) - 1) != 0)
80003a9e:	30 7a       	mov	r10,7
80003aa0:	1a 9b       	mov	r11,sp
80003aa2:	4a 8c       	lddpc	r12,80003b40 <disk_init+0x12c>
80003aa4:	f0 1f 00 28 	mcall	80003b44 <disk_init+0x130>
80003aa8:	c0 c0       	breq	80003ac0 <disk_init+0xac>
	{
		if(f_setlabel("MOTOREC") != FR_OK)
80003aaa:	4a 8c       	lddpc	r12,80003b48 <disk_init+0x134>
80003aac:	f0 1f 00 28 	mcall	80003b4c <disk_init+0x138>
80003ab0:	c0 80       	breq	80003ac0 <disk_init+0xac>
		{
			f_mount(NULL, "/", 1);
80003ab2:	30 1a       	mov	r10,1
80003ab4:	49 bb       	lddpc	r11,80003b20 <disk_init+0x10c>
80003ab6:	30 0c       	mov	r12,0
80003ab8:	f0 1f 00 1c 	mcall	80003b28 <disk_init+0x114>
80003abc:	30 6c       	mov	r12,6
			return fs_err;
80003abe:	c2 c8       	rjmp	80003b16 <disk_init+0x102>
		}
	}
			
	if ( f_opendir(&dirs, "/") == FR_OK)
80003ac0:	49 8b       	lddpc	r11,80003b20 <disk_init+0x10c>
80003ac2:	4a 4c       	lddpc	r12,80003b50 <disk_init+0x13c>
80003ac4:	f0 1f 00 24 	mcall	80003b54 <disk_init+0x140>
80003ac8:	c2 11       	brne	80003b0a <disk_init+0xf6>
	{
		if(f_open(&fl, "sys.ini", FA_CREATE_ALWAYS | FA_WRITE) == FR_OK )
80003aca:	30 aa       	mov	r10,10
80003acc:	4a 3b       	lddpc	r11,80003b58 <disk_init+0x144>
80003ace:	4a 4c       	lddpc	r12,80003b5c <disk_init+0x148>
80003ad0:	f0 1f 00 24 	mcall	80003b60 <disk_init+0x14c>
80003ad4:	c1 41       	brne	80003afc <disk_init+0xe8>
		{
			f_close(&fl);
80003ad6:	4a 2c       	lddpc	r12,80003b5c <disk_init+0x148>
80003ad8:	f0 1f 00 23 	mcall	80003b64 <disk_init+0x150>
		{
			f_mount(NULL, "/", 1);
			return fs_err;
		}
				
		f_mkdir("/REC");			
80003adc:	4a 3c       	lddpc	r12,80003b68 <disk_init+0x154>
80003ade:	f0 1f 00 24 	mcall	80003b6c <disk_init+0x158>
		f_mkdir("/REC/ZONE01");			
80003ae2:	4a 4c       	lddpc	r12,80003b70 <disk_init+0x15c>
80003ae4:	f0 1f 00 22 	mcall	80003b6c <disk_init+0x158>
		f_mkdir("/REC/ZONE01/CH01");		
80003ae8:	4a 3c       	lddpc	r12,80003b74 <disk_init+0x160>
80003aea:	f0 1f 00 21 	mcall	80003b6c <disk_init+0x158>
	{
		f_mount(NULL, "/", 1);
		return fs_err;
	}
	
	f_mount(NULL, "/", 1);		
80003aee:	30 1a       	mov	r10,1
80003af0:	48 cb       	lddpc	r11,80003b20 <disk_init+0x10c>
80003af2:	30 0c       	mov	r12,0
80003af4:	f0 1f 00 0d 	mcall	80003b28 <disk_init+0x114>
80003af8:	30 0c       	mov	r12,0
	return fs_ok;
80003afa:	c0 e8       	rjmp	80003b16 <disk_init+0x102>
		{
			f_close(&fl);
		}
		else 
		{
			f_mount(NULL, "/", 1);
80003afc:	30 1a       	mov	r10,1
80003afe:	48 9b       	lddpc	r11,80003b20 <disk_init+0x10c>
80003b00:	30 0c       	mov	r12,0
80003b02:	f0 1f 00 0a 	mcall	80003b28 <disk_init+0x114>
80003b06:	30 6c       	mov	r12,6
			return fs_err;
80003b08:	c0 78       	rjmp	80003b16 <disk_init+0x102>
		f_mkdir("/REC/ZONE01");			
		f_mkdir("/REC/ZONE01/CH01");		
	}
	else 
	{
		f_mount(NULL, "/", 1);
80003b0a:	30 1a       	mov	r10,1
80003b0c:	48 5b       	lddpc	r11,80003b20 <disk_init+0x10c>
80003b0e:	30 0c       	mov	r12,0
80003b10:	f0 1f 00 06 	mcall	80003b28 <disk_init+0x114>
80003b14:	30 6c       	mov	r12,6
		return fs_err;
	}
	
	f_mount(NULL, "/", 1);		
	return fs_ok;
}
80003b16:	2f dd       	sub	sp,-12
80003b18:	d8 02       	popm	pc
80003b1a:	00 00       	add	r0,r0
80003b1c:	80 00       	ld.sh	r0,r0[0x0]
80003b1e:	35 50       	mov	r0,85
80003b20:	80 01       	ld.sh	r1,r0[0x0]
80003b22:	09 e4       	ld.ub	r4,r4[0x6]
80003b24:	00 00       	add	r0,r0
80003b26:	0a b0       	st.h	r5++,r0
80003b28:	80 00       	ld.sh	r0,r0[0x0]
80003b2a:	73 c8       	ld.w	r8,r9[0x70]
80003b2c:	00 00       	add	r0,r0
80003b2e:	0d 84       	ld.ub	r4,r6[0x0]
80003b30:	00 00       	add	r0,r0
80003b32:	0a ac       	st.w	r5++,r12
80003b34:	80 00       	ld.sh	r0,r0[0x0]
80003b36:	85 48       	st.w	r2[0x10],r8
80003b38:	80 00       	ld.sh	r0,r0[0x0]
80003b3a:	68 8c       	ld.w	r12,r4[0x20]
80003b3c:	80 00       	ld.sh	r0,r0[0x0]
80003b3e:	7a c4       	ld.w	r4,sp[0x30]
80003b40:	00 00       	add	r0,r0
80003b42:	04 f4       	st.b	--r2,r4
80003b44:	80 00       	ld.sh	r0,r0[0x0]
80003b46:	a8 e0       	st.b	r4[0x6],r0
80003b48:	80 01       	ld.sh	r1,r0[0x0]
80003b4a:	0a 10       	sub	r0,r5
80003b4c:	80 00       	ld.sh	r0,r0[0x0]
80003b4e:	7c 10       	ld.w	r0,lr[0x4]
80003b50:	00 00       	add	r0,r0
80003b52:	0c e0       	st.h	--r6,r0
80003b54:	80 00       	ld.sh	r0,r0[0x0]
80003b56:	81 58       	st.w	r0[0x14],r8
80003b58:	80 01       	ld.sh	r1,r0[0x0]
80003b5a:	0a 18       	sub	r8,r5
80003b5c:	00 00       	add	r0,r0
80003b5e:	0d c8       	ld.ub	r8,r6[0x4]
80003b60:	80 00       	ld.sh	r0,r0[0x0]
80003b62:	83 94       	st.w	r1[0x24],r4
80003b64:	80 00       	ld.sh	r0,r0[0x0]
80003b66:	75 14       	ld.w	r4,r10[0x44]
80003b68:	80 01       	ld.sh	r1,r0[0x0]
80003b6a:	0a 20       	rsub	r0,r5
80003b6c:	80 00       	ld.sh	r0,r0[0x0]
80003b6e:	81 dc       	st.w	r0[0x34],r12
80003b70:	80 01       	ld.sh	r1,r0[0x0]
80003b72:	0a 28       	rsub	r8,r5
80003b74:	80 01       	ld.sh	r1,r0[0x0]
80003b76:	0a 34       	cp.w	r4,r5

80003b78 <fs_init>:
}



fs_err_t fs_init(void)
{
80003b78:	eb cd 40 80 	pushm	r7,lr
	fs_err_t res = disk_init();
80003b7c:	f0 1f 00 0d 	mcall	80003bb0 <fs_init+0x38>
80003b80:	18 97       	mov	r7,r12
	if( fs_ok ==  res)
80003b82:	c1 31       	brne	80003ba8 <fs_init+0x30>
	{
		fl_oper_queue = xQueueCreate(20, sizeof(fl_oper_t)); //20*512bytes = 10k
80003b84:	30 8b       	mov	r11,8
80003b86:	31 4c       	mov	r12,20
80003b88:	f0 1f 00 0b 	mcall	80003bb4 <fs_init+0x3c>
80003b8c:	48 b8       	lddpc	r8,80003bb8 <fs_init+0x40>
80003b8e:	91 0c       	st.w	r8[0x0],r12
		
		/*create a task for files operation*/
		xTaskCreate(
80003b90:	30 09       	mov	r9,0
80003b92:	1a d9       	st.w	--sp,r9
80003b94:	1a d9       	st.w	--sp,r9
80003b96:	1a d9       	st.w	--sp,r9
80003b98:	30 28       	mov	r8,2
80003b9a:	e0 6a 02 00 	mov	r10,512
80003b9e:	48 8b       	lddpc	r11,80003bbc <fs_init+0x44>
80003ba0:	48 8c       	lddpc	r12,80003bc0 <fs_init+0x48>
80003ba2:	f0 1f 00 09 	mcall	80003bc4 <fs_init+0x4c>
		,  NULL
		,  2//1
		,  NULL
		);		
		
		return fs_ok;		
80003ba6:	2f dd       	sub	sp,-12
	}
	else
	{
		return res;
	}
}
80003ba8:	0e 9c       	mov	r12,r7
80003baa:	e3 cd 80 80 	ldm	sp++,r7,pc
80003bae:	00 00       	add	r0,r0
80003bb0:	80 00       	ld.sh	r0,r0[0x0]
80003bb2:	3a 14       	mov	r4,-95
80003bb4:	80 00       	ld.sh	r0,r0[0x0]
80003bb6:	94 a8       	ld.uh	r8,r10[0x4]
80003bb8:	00 00       	add	r0,r0
80003bba:	0d 40       	ld.w	r0,--r6
80003bbc:	80 01       	ld.sh	r1,r0[0x0]
80003bbe:	0a 48       	or	r8,r5
80003bc0:	80 00       	ld.sh	r0,r0[0x0]
80003bc2:	39 6c       	mov	r12,-106
80003bc4:	80 00       	ld.sh	r0,r0[0x0]
80003bc6:	9b 7c       	st.w	sp[0x1c],r12

80003bc8 <CalculateBurst>:
Calls:
Called By: phy_payload_rx
*/

volatile RxAMBEBurstType CalculateBurst(U8 vf_sn)
{
80003bc8:	20 1c       	sub	r12,1
80003bca:	5c 5c       	castu.b	r12
80003bcc:	31 18       	mov	r8,17
80003bce:	f0 0c 18 00 	cp.b	r12,r8
80003bd2:	e0 88 00 03 	brls	80003bd8 <CalculateBurst+0x10>
80003bd6:	5e fd       	retal	0
80003bd8:	48 28       	lddpc	r8,80003be0 <CalculateBurst+0x18>
80003bda:	f0 0c 03 2c 	ld.w	r12,r8[r12<<0x2]
			Burst_ID = 0x00;
			return VOICE_WATING;
		
	}
	
}
80003bde:	5e fc       	retal	r12
80003be0:	80 01       	ld.sh	r1,r0[0x0]
80003be2:	0a 60       	and	r0,r5

80003be4 <payload_init>:
	Create the corresponding task;
Calls: xTaskCreate--freertos
Called By:app_init -- app.c
*/
void payload_init(void ( *payload_rx_func)(void * ), void ( *payload_tx_func)(void * ) )
{				
80003be4:	eb cd 40 80 	pushm	r7,lr
	payload_rx_exec = payload_rx_func;
80003be8:	48 f8       	lddpc	r8,80003c24 <payload_init+0x40>
80003bea:	91 0c       	st.w	r8[0x0],r12
	payload_tx_exec = payload_tx_func;
80003bec:	48 f8       	lddpc	r8,80003c28 <payload_init+0x44>
80003bee:	91 0b       	st.w	r8[0x0],r11
	
	
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
80003bf0:	30 07       	mov	r7,0
80003bf2:	1a d7       	st.w	--sp,r7
80003bf4:	1a d7       	st.w	--sp,r7
80003bf6:	1a d7       	st.w	--sp,r7
80003bf8:	30 28       	mov	r8,2
80003bfa:	0e 99       	mov	r9,r7
80003bfc:	e0 6a 04 00 	mov	r10,1024
80003c00:	48 bb       	lddpc	r11,80003c2c <payload_init+0x48>
80003c02:	48 cc       	lddpc	r12,80003c30 <payload_init+0x4c>
80003c04:	f0 1f 00 0c 	mcall	80003c34 <payload_init+0x50>
	,  2
	,  NULL
	);
	
	/*this task is used to transmit  payload message*/
	xTaskCreate(
80003c08:	1a d7       	st.w	--sp,r7
80003c0a:	1a d7       	st.w	--sp,r7
80003c0c:	1a d7       	st.w	--sp,r7
80003c0e:	30 28       	mov	r8,2
80003c10:	0e 99       	mov	r9,r7
80003c12:	e0 6a 04 00 	mov	r10,1024
80003c16:	48 9b       	lddpc	r11,80003c38 <payload_init+0x54>
80003c18:	48 9c       	lddpc	r12,80003c3c <payload_init+0x58>
80003c1a:	f0 1f 00 07 	mcall	80003c34 <payload_init+0x50>
80003c1e:	2f ad       	sub	sp,-24
	,  2
	,  NULL
	);
	
	
}
80003c20:	e3 cd 80 80 	ldm	sp++,r7,pc
80003c24:	00 00       	add	r0,r0
80003c26:	0f f0       	ld.ub	r0,r7[0x7]
80003c28:	00 00       	add	r0,r0
80003c2a:	0f f4       	ld.ub	r4,r7[0x7]
80003c2c:	80 01       	ld.sh	r1,r0[0x0]
80003c2e:	0a a8       	st.w	r5++,r8
80003c30:	80 00       	ld.sh	r0,r0[0x0]
80003c32:	3c 8c       	mov	r12,-56
80003c34:	80 00       	ld.sh	r0,r0[0x0]
80003c36:	9b 7c       	st.w	sp[0x1c],r12
80003c38:	80 01       	ld.sh	r1,r0[0x0]
80003c3a:	0a b4       	st.h	r5++,r4
80003c3c:	80 00       	ld.sh	r0,r0[0x0]
80003c3e:	3c 40       	mov	r0,-60

80003c40 <payload_tx_process>:
Description: Transmit the payload
Calls:
Called By:task
*/
static void payload_tx_process(void * pvParameters)
{
80003c40:	eb cd 40 f8 	pushm	r3-r7,lr
80003c44:	20 1d       	sub	sp,4
	/*To store the elements in the queue*/
	U16  * payload_ptr;
	
	if(NULL == phy_payload_frame_tx)
80003c46:	48 e8       	lddpc	r8,80003c7c <payload_tx_process+0x3c>
80003c48:	70 08       	ld.w	r8,r8[0x0]
80003c4a:	58 08       	cp.w	r8,0
80003c4c:	c0 71       	brne	80003c5a <payload_tx_process+0x1a>
	{
		phy_payload_frame_tx = xQueueCreate(TX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
80003c4e:	30 4b       	mov	r11,4
80003c50:	30 5c       	mov	r12,5
80003c52:	f0 1f 00 0c 	mcall	80003c80 <payload_tx_process+0x40>
80003c56:	48 a8       	lddpc	r8,80003c7c <payload_tx_process+0x3c>
80003c58:	91 0c       	st.w	r8[0x0],r12
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_tx, &payload_ptr,portMAX_DELAY ))
80003c5a:	48 96       	lddpc	r6,80003c7c <payload_tx_process+0x3c>
80003c5c:	30 05       	mov	r5,0
80003c5e:	3f f4       	mov	r4,-1
		{
			payload_tx_exec(payload_ptr);//app_payload_tx_proc();
80003c60:	48 93       	lddpc	r3,80003c84 <payload_tx_process+0x44>
		phy_payload_frame_tx = xQueueCreate(TX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_tx, &payload_ptr,portMAX_DELAY ))
80003c62:	6c 0c       	ld.w	r12,r6[0x0]
80003c64:	0a 99       	mov	r9,r5
80003c66:	08 9a       	mov	r10,r4
80003c68:	1a 9b       	mov	r11,sp
80003c6a:	f0 1f 00 08 	mcall	80003c88 <payload_tx_process+0x48>
80003c6e:	58 1c       	cp.w	r12,1
80003c70:	cf 91       	brne	80003c62 <payload_tx_process+0x22>
		{
			payload_tx_exec(payload_ptr);//app_payload_tx_proc();
80003c72:	66 08       	ld.w	r8,r3[0x0]
80003c74:	40 0c       	lddsp	r12,sp[0x0]
80003c76:	5d 18       	icall	r8
80003c78:	cf 5b       	rjmp	80003c62 <payload_tx_process+0x22>
80003c7a:	00 00       	add	r0,r0
80003c7c:	00 00       	add	r0,r0
80003c7e:	10 44       	or	r4,r8
80003c80:	80 00       	ld.sh	r0,r0[0x0]
80003c82:	94 a8       	ld.uh	r8,r10[0x4]
80003c84:	00 00       	add	r0,r0
80003c86:	0f f4       	ld.ub	r4,r7[0x7]
80003c88:	80 00       	ld.sh	r0,r0[0x0]
80003c8a:	91 44       	st.w	r8[0x10],r4

80003c8c <payload_rx_process>:
Description: Receive the payload
Calls:
Called By:task
*/
static void payload_rx_process(void * pvParameters)
{
80003c8c:	eb cd 40 f8 	pushm	r3-r7,lr
80003c90:	20 1d       	sub	sp,4
	/*To store the elements in the queue*/
	U16  * payload_ptr;
		
	if(NULL ==   phy_payload_frame_rx)
80003c92:	48 e8       	lddpc	r8,80003cc8 <payload_rx_process+0x3c>
80003c94:	70 08       	ld.w	r8,r8[0x0]
80003c96:	58 08       	cp.w	r8,0
80003c98:	c0 71       	brne	80003ca6 <payload_rx_process+0x1a>
	{
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
80003c9a:	30 4b       	mov	r11,4
80003c9c:	30 5c       	mov	r12,5
80003c9e:	f0 1f 00 0c 	mcall	80003ccc <payload_rx_process+0x40>
80003ca2:	48 a8       	lddpc	r8,80003cc8 <payload_rx_process+0x3c>
80003ca4:	91 0c       	st.w	r8[0x0],r12
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_rx, &payload_ptr,portMAX_DELAY ))
80003ca6:	48 96       	lddpc	r6,80003cc8 <payload_rx_process+0x3c>
80003ca8:	30 05       	mov	r5,0
80003caa:	3f f4       	mov	r4,-1
		{			
			payload_rx_exec(payload_ptr);//app_payload_rx_proc();
80003cac:	48 93       	lddpc	r3,80003cd0 <payload_rx_process+0x44>
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_rx, &payload_ptr,portMAX_DELAY ))
80003cae:	6c 0c       	ld.w	r12,r6[0x0]
80003cb0:	0a 99       	mov	r9,r5
80003cb2:	08 9a       	mov	r10,r4
80003cb4:	1a 9b       	mov	r11,sp
80003cb6:	f0 1f 00 08 	mcall	80003cd4 <payload_rx_process+0x48>
80003cba:	58 1c       	cp.w	r12,1
80003cbc:	cf 91       	brne	80003cae <payload_rx_process+0x22>
		{			
			payload_rx_exec(payload_ptr);//app_payload_rx_proc();
80003cbe:	66 08       	ld.w	r8,r3[0x0]
80003cc0:	40 0c       	lddsp	r12,sp[0x0]
80003cc2:	5d 18       	icall	r8
80003cc4:	cf 5b       	rjmp	80003cae <payload_rx_process+0x22>
80003cc6:	00 00       	add	r0,r0
80003cc8:	00 00       	add	r0,r0
80003cca:	10 0c       	add	r12,r8
80003ccc:	80 00       	ld.sh	r0,r0[0x0]
80003cce:	94 a8       	ld.uh	r8,r10[0x4]
80003cd0:	00 00       	add	r0,r0
80003cd2:	0f f0       	ld.ub	r0,r7[0x7]
80003cd4:	80 00       	ld.sh	r0,r0[0x0]
80003cd6:	91 44       	st.w	r8[0x10],r4

80003cd8 <set_idle_store_isr>:
{
	xQueueSend(store, &ptr, 0);
}

void set_idle_store_isr(xQueueHandle store, void * ptr)
{
80003cd8:	d4 01       	pushm	lr
80003cda:	20 2d       	sub	sp,8
80003cdc:	50 0b       	stdsp	sp[0x0],r11
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80003cde:	30 09       	mov	r9,0
80003ce0:	fa ca ff f8 	sub	r10,sp,-8
80003ce4:	14 d9       	st.w	--r10,r9
	xQueueSendFromISR(store, &ptr, &xHigherPriorityTaskWoken);
80003ce6:	1a 9b       	mov	r11,sp
80003ce8:	f0 1f 00 02 	mcall	80003cf0 <set_idle_store_isr+0x18>
}
80003cec:	2f ed       	sub	sp,-8
80003cee:	d8 02       	popm	pc
80003cf0:	80 00       	ld.sh	r0,r0[0x0]
80003cf2:	93 00       	st.w	r9[0x0],r0

80003cf4 <phy_rx>:
	xQueueSendFromISR -- freertos
Called By: phy_xnl_rx
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
80003cf4:	d4 01       	pushm	lr
80003cf6:	20 2d       	sub	sp,8
80003cf8:	50 0c       	stdsp	sp[0x0],r12
	//memcpy(xx, phy_ptr, sizeof(phy_fragment_t));
	//set_phy_idle_isr(&phy_ptr, &xHigherPriorityTaskWoken);
	
	Bool res = FALSE;
	
	if(NULL == phy_ptr)
80003cfa:	58 0c       	cp.w	r12,0
80003cfc:	c1 10       	breq	80003d1e <phy_rx+0x2a>
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
    /*variables are used to store the push result in interrupt*/
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80003cfe:	30 08       	mov	r8,0
80003d00:	50 18       	stdsp	sp[0x4],r8
	if(NULL == phy_ptr)
	{
		return;
	}
	
    U16 phy_ctrl = phy_ptr->xnl_fragment.phy_header.phy_control;
80003d02:	98 88       	ld.uh	r8,r12[0x0]
80003d04:	e2 18 f0 00 	andl	r8,0xf000,COH
80003d08:	e0 48 40 00 	cp.w	r8,16384
80003d0c:	c0 91       	brne	80003d1e <phy_rx+0x2a>

    if (XCMPXNL_DATA == (phy_ctrl & 0xF000))
    {
        /*push the xnl packet to queue*/
        if( pdTRUE == xQueueSendFromISR(
80003d0e:	48 68       	lddpc	r8,80003d24 <phy_rx+0x30>
80003d10:	70 0c       	ld.w	r12,r8[0x0]
80003d12:	30 09       	mov	r9,0
80003d14:	fa ca ff fc 	sub	r10,sp,-4
80003d18:	1a 9b       	mov	r11,sp
80003d1a:	f0 1f 00 04 	mcall	80003d28 <phy_rx+0x34>
		}	

    }
		
 
}
80003d1e:	2f ed       	sub	sp,-8
80003d20:	d8 02       	popm	pc
80003d22:	00 00       	add	r0,r0
80003d24:	00 00       	add	r0,r0
80003d26:	10 4c       	or	r12,r8
80003d28:	80 00       	ld.sh	r0,r0[0x0]
80003d2a:	93 00       	st.w	r9[0x0],r0

80003d2c <set_idle_store>:
	}
}


void set_idle_store(xQueueHandle store, void * ptr)
{
80003d2c:	eb cd 40 80 	pushm	r7,lr
80003d30:	20 1d       	sub	sp,4
80003d32:	fa c7 ff fc 	sub	r7,sp,-4
80003d36:	0e db       	st.w	--r7,r11
	xQueueSend(store, &ptr, 0);
80003d38:	30 09       	mov	r9,0
80003d3a:	12 9a       	mov	r10,r9
80003d3c:	1a 9b       	mov	r11,sp
80003d3e:	f0 1f 00 03 	mcall	80003d48 <set_idle_store+0x1c>
}
80003d42:	2f fd       	sub	sp,-4
80003d44:	e3 cd 80 80 	ldm	sp++,r7,pc
80003d48:	80 00       	ld.sh	r0,r0[0x0]
80003d4a:	93 50       	st.w	r9[0x14],r0

80003d4c <phy_tx>:
Calls:   
	xQueueSend -- freertos
Called By: xnl_tx -- xnl.c
*/
void phy_tx(phy_fragment_t * phy)
{	
80003d4c:	d4 01       	pushm	lr
80003d4e:	20 1d       	sub	sp,4
80003d50:	50 0c       	stdsp	sp[0x0],r12
	
	//phy_fragment_t * phy_ptr = malloc(sizeof(phy_fragment_t));
	//memcpy(phy_ptr, phy, sizeof(phy_fragment_t));
	//log("\n\r T_xcmp:%4x \n\r", phy->xnl_fragment.xnl_payload.xnl_content_data_msg.xcmp_opcode);
	//log("T_xnl-opcode:%4x", xnl->xnl_header.opcode);//log:R_xnl	
	if(XCMPXNL_DATA == (phy_ctrl & 0xF000))
80003d52:	98 88       	ld.uh	r8,r12[0x0]
80003d54:	e2 18 f0 00 	andl	r8,0xf000,COH
80003d58:	e0 48 40 00 	cp.w	r8,16384
80003d5c:	c0 d1       	brne	80003d76 <phy_tx+0x2a>
	{
		/*push the xnl packet to queue to send */
		if(NULL != phy_xnl_frame_tx)
80003d5e:	49 08       	lddpc	r8,80003d9c <phy_tx+0x50>
80003d60:	70 08       	ld.w	r8,r8[0x0]
80003d62:	58 08       	cp.w	r8,0
80003d64:	c1 a0       	breq	80003d98 <phy_tx+0x4c>
		{
			if( pdTRUE == xQueueSend(phy_xnl_frame_tx, &phy, 0))
80003d66:	48 e8       	lddpc	r8,80003d9c <phy_tx+0x50>
80003d68:	70 0c       	ld.w	r12,r8[0x0]
80003d6a:	30 09       	mov	r9,0
80003d6c:	12 9a       	mov	r10,r9
80003d6e:	1a 9b       	mov	r11,sp
80003d70:	f0 1f 00 0c 	mcall	80003da0 <phy_tx+0x54>
80003d74:	c1 28       	rjmp	80003d98 <phy_tx+0x4c>
		}
	}
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE		
	else if((SPEAKER_DATA == (phy_ctrl & 0xF000))
80003d76:	e0 48 10 00 	cp.w	r8,4096
80003d7a:	5f 0a       	sreq	r10
80003d7c:	e0 48 20 00 	cp.w	r8,8192
80003d80:	5f 09       	sreq	r9
80003d82:	f5 e9 10 09 	or	r9,r10,r9
80003d86:	c0 71       	brne	80003d94 <phy_tx+0x48>
80003d88:	e0 48 50 00 	cp.w	r8,20480
80003d8c:	c0 40       	breq	80003d94 <phy_tx+0x48>
80003d8e:	e0 48 60 00 	cp.w	r8,24576
80003d92:	c0 31       	brne	80003d98 <phy_tx+0x4c>
	    || (MIC_DATA  == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_RX == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_TX == (phy_ctrl & 0xF000))
	)
	{		
		if(NULL == phy_payload_frame_tx)
80003d94:	48 48       	lddpc	r8,80003da4 <phy_tx+0x58>
80003d96:	70 08       	ld.w	r8,r8[0x0]
	
	if(res != TRUE)
	{
		//vPortFree(phy_ptr);
	}
}
80003d98:	2f fd       	sub	sp,-4
80003d9a:	d8 02       	popm	pc
80003d9c:	00 00       	add	r0,r0
80003d9e:	10 60       	and	r0,r8
80003da0:	80 00       	ld.sh	r0,r0[0x0]
80003da2:	93 50       	st.w	r9[0x14],r0
80003da4:	00 00       	add	r0,r0
80003da6:	10 44       	or	r4,r8

80003da8 <get_idle_store_isr>:
		return NULL;
	}
}

void * get_idle_store_isr(xQueueHandle store)
{
80003da8:	d4 01       	pushm	lr
80003daa:	20 2d       	sub	sp,8
	void * ptr = NULL;
80003dac:	30 08       	mov	r8,0
80003dae:	50 18       	stdsp	sp[0x4],r8
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80003db0:	50 08       	stdsp	sp[0x0],r8
	
	if(pdTRUE == xQueueReceiveFromISR(store, &ptr, &xHigherPriorityTaskWoken))
80003db2:	1a 9a       	mov	r10,sp
80003db4:	fa cb ff fc 	sub	r11,sp,-4
80003db8:	f0 1f 00 05 	mcall	80003dcc <get_idle_store_isr+0x24>
80003dbc:	58 1c       	cp.w	r12,1
80003dbe:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80003dc2:	fb fc 00 01 	ld.weq	r12,sp[0x4]
	}
	else
	{
		return NULL;
	}
}
80003dc6:	2f ed       	sub	sp,-8
80003dc8:	d8 02       	popm	pc
80003dca:	00 00       	add	r0,r0
80003dcc:	80 00       	ld.sh	r0,r0[0x0]
80003dce:	90 54       	ld.sh	r4,r8[0xa]

80003dd0 <phy_tx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_tx_func( void * ssc)
{
80003dd0:	eb cd 40 c0 	pushm	r6-r7,lr
80003dd4:	20 1d       	sub	sp,4
80003dd6:	18 97       	mov	r7,r12
    if(NULL != phy_xnl_frame_tx)
80003dd8:	fe f8 05 54 	ld.w	r8,pc[1364]
80003ddc:	70 08       	ld.w	r8,r8[0x0]
80003dde:	58 08       	cp.w	r8,0
80003de0:	c7 40       	breq	80003ec8 <phy_tx_func+0xf8>
    {
  	  	/*send ssc data in xnl frame*/
  	  	phy_xnl_tx(&(((ssc_fragment_t * )ssc)->xnl_channel));		
80003de2:	18 96       	mov	r6,r12
Called By:phy_tx_func
*/
static void phy_xnl_tx(xnl_channel_t * xnl_tx_channel)
{
	/*variables are used to store the push result in interrupt*/
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80003de4:	30 08       	mov	r8,0
80003de6:	50 08       	stdsp	sp[0x0],r8
	
	static S16 phy_tx_expexted_length = 0;
	static U8 phy_tx_index = 0;
	
	/*his is the code for handling any outgoing XNL Phy message*/
	switch(phy_tx_state)
80003de8:	fe f8 05 48 	ld.w	r8,pc[1352]
80003dec:	70 08       	ld.w	r8,r8[0x0]
80003dee:	58 18       	cp.w	r8,1
80003df0:	c2 90       	breq	80003e42 <phy_tx_func+0x72>
80003df2:	c0 43       	brcs	80003dfa <phy_tx_func+0x2a>
80003df4:	58 28       	cp.w	r8,2
80003df6:	c6 91       	brne	80003ec8 <phy_tx_func+0xf8>
80003df8:	c6 18       	rjmp	80003eba <phy_tx_func+0xea>
	{
		/*Waiting for the send xnl packet*/
		case WAITING_FOR_PHY_TX:			
			if( pdTRUE == xQueueReceiveFromISR(
80003dfa:	fe f8 05 32 	ld.w	r8,pc[1330]
80003dfe:	70 0c       	ld.w	r12,r8[0x0]
80003e00:	1a 9a       	mov	r10,sp
80003e02:	fe fb 05 32 	ld.w	r11,pc[1330]
80003e06:	f0 1f 01 4d 	mcall	80004338 <phy_tx_func+0x568>
80003e0a:	58 1c       	cp.w	r12,1
80003e0c:	c1 51       	brne	80003e36 <phy_tx_func+0x66>
				  phy_xnl_frame_tx
				, &phy_ptr
				, &xHigherPriorityTaskWoken 
			))
			{								
				phy_tx_expexted_length = 
80003e0e:	fe f8 05 26 	ld.w	r8,pc[1318]
80003e12:	70 08       	ld.w	r8,r8[0x0]
80003e14:	11 9a       	ld.ub	r10,r8[0x1]
80003e16:	fe f9 05 26 	ld.w	r9,pc[1318]
80003e1a:	b2 0a       	st.h	r9[0x0],r10
				*/
				xnl_tx_channel->dword = 
				                   phy_ptr->xnl_fragment.phy_header.phy_control;
				
				/*Transmit 0xABCD0000 | Type/Length.*/
				xnl_tx_channel->dword |= PHYHEADER32;
80003e1c:	90 88       	ld.uh	r8,r8[0x0]
80003e1e:	ea 18 ab cd 	orh	r8,0xabcd
80003e22:	8f 18       	st.w	r7[0x4],r8
				
				phy_tx_index = 1;
80003e24:	30 19       	mov	r9,1
80003e26:	fe f8 05 1a 	ld.w	r8,pc[1306]
80003e2a:	b0 89       	st.b	r8[0x0],r9
				phy_tx_state = WRITE_NEXT_DWORD;	
80003e2c:	30 19       	mov	r9,1
80003e2e:	fe f8 05 02 	ld.w	r8,pc[1282]
80003e32:	91 09       	st.w	r8[0x0],r9
80003e34:	c4 a8       	rjmp	80003ec8 <phy_tx_func+0xf8>
				/*The new transmission has started.*/
			}
			else
			{
				/*Nothing new to transmit, send an idle frame*/
				xnl_tx_channel->dword = XNL_IDLE;
80003e36:	e0 68 5a 5a 	mov	r8,23130
80003e3a:	ea 18 ab cd 	orh	r8,0xabcd
80003e3e:	8f 18       	st.w	r7[0x4],r8
80003e40:	c4 48       	rjmp	80003ec8 <phy_tx_func+0xf8>
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80003e42:	fe f9 04 fe 	ld.w	r9,pc[1278]
80003e46:	13 88       	ld.ub	r8,r9[0x0]
				xnl_tx_channel->dword = XNL_IDLE;
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
80003e48:	fe fa 04 ec 	ld.w	r10,pc[1260]
80003e4c:	74 0a       	ld.w	r10,r10[0x0]
80003e4e:	f4 08 05 1a 	ld.uh	r10,r10[r8<<0x1]
80003e52:	b1 6a       	lsl	r10,0x10
80003e54:	99 1a       	st.w	r12[0x4],r10
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80003e56:	2f f8       	sub	r8,-1
80003e58:	5c 58       	castu.b	r8
80003e5a:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
80003e5c:	fe fa 04 e0 	ld.w	r10,pc[1248]
80003e60:	94 09       	ld.sh	r9,r10[0x0]
80003e62:	20 29       	sub	r9,2
80003e64:	b4 09       	st.h	r10[0x0],r9
			
			/*have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80003e66:	30 0a       	mov	r10,0
80003e68:	f4 09 19 00 	cp.h	r9,r10
80003e6c:	e0 89 00 0b 	brgt	80003e82 <phy_tx_func+0xb2>
			{
				/*Must immediately send 0x00BA in Slot 4.*/
				xnl_tx_channel->dword |= PHYTERMRIGHT;
80003e70:	78 18       	ld.w	r8,r12[0x4]
80003e72:	e8 18 00 ba 	orl	r8,0xba
80003e76:	99 18       	st.w	r12[0x4],r8
				
				/*Go back to waiting.*/
				//vPortFree(phy_ptr);
				phy_tx_state = WAITING_FOR_PHY_TX;
80003e78:	30 09       	mov	r9,0
80003e7a:	fe f8 04 b6 	ld.w	r8,pc[1206]
80003e7e:	91 09       	st.w	r8[0x0],r9
80003e80:	c2 48       	rjmp	80003ec8 <phy_tx_func+0xf8>
				break;
			}

			/*Have not broken. Transmit 2nd hWord.*/
			xnl_tx_channel->dword |=  phy_ptr->fragment_element[phy_tx_index++];
80003e82:	fe f9 04 b2 	ld.w	r9,pc[1202]
80003e86:	72 09       	ld.w	r9,r9[0x0]
80003e88:	f2 08 05 19 	ld.uh	r9,r9[r8<<0x1]
80003e8c:	78 1a       	ld.w	r10,r12[0x4]
80003e8e:	f5 e9 10 09 	or	r9,r10,r9
80003e92:	99 19       	st.w	r12[0x4],r9
80003e94:	2f f8       	sub	r8,-1
80003e96:	fe f9 04 aa 	ld.w	r9,pc[1194]
80003e9a:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
80003e9c:	fe f9 04 a0 	ld.w	r9,pc[1184]
80003ea0:	92 08       	ld.sh	r8,r9[0x0]
80003ea2:	20 28       	sub	r8,2
80003ea4:	b2 08       	st.h	r9[0x0],r8
			
			/*Have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80003ea6:	30 09       	mov	r9,0
80003ea8:	f2 08 19 00 	cp.h	r8,r9
80003eac:	e0 89 00 0e 	brgt	80003ec8 <phy_tx_func+0xf8>
			{
				/*Must send 0x00BA0000 next interrupt in Slot 3&4*/
				phy_tx_state = SEND_TAILED;
80003eb0:	30 29       	mov	r9,2
80003eb2:	fe f8 04 7e 	ld.w	r8,pc[1150]
80003eb6:	91 09       	st.w	r8[0x0],r9
80003eb8:	c0 88       	rjmp	80003ec8 <phy_tx_func+0xf8>
			}
			break;

		case SEND_TAILED:
			/*send 0x00BA0000*/
			xnl_tx_channel->dword = PHYTERMLEFT;
80003eba:	fc 18 00 ba 	movh	r8,0xba
80003ebe:	99 18       	st.w	r12[0x4],r8
			
			/*Go back to waiting.*/	
			//vPortFree(phy_ptr);		
			phy_tx_state = WAITING_FOR_PHY_TX;		
80003ec0:	30 09       	mov	r9,0
80003ec2:	fe f8 04 6e 	ld.w	r8,pc[1134]
80003ec6:	91 09       	st.w	r8[0x0],r9
	static U32 i = 0;
	//static U8 frame_5_end = 0;
	//static U16 pay[256];
	
	//Send-AMBE-data
	if (AMBE_flag)
80003ec8:	fe f8 04 7c 	ld.w	r8,pc[1148]
80003ecc:	11 89       	ld.ub	r9,r8[0x0]
80003ece:	30 08       	mov	r8,0
80003ed0:	f0 09 18 00 	cp.b	r9,r8
80003ed4:	e0 80 00 c6 	breq	80004060 <phy_tx_func+0x290>
	{

	  //AMBE_flag
		switch(payload_tx_state)
80003ed8:	fe f8 04 70 	ld.w	r8,pc[1136]
80003edc:	11 88       	ld.ub	r8,r8[0x0]
80003ede:	30 19       	mov	r9,1
80003ee0:	f2 08 18 00 	cp.b	r8,r9
80003ee4:	c3 e0       	breq	80003f60 <phy_tx_func+0x190>
80003ee6:	c0 73       	brcs	80003ef4 <phy_tx_func+0x124>
80003ee8:	30 29       	mov	r9,2
80003eea:	f2 08 18 00 	cp.b	r8,r9
80003eee:	e0 81 02 1b 	brne	80004324 <phy_tx_func+0x554>
80003ef2:	c9 28       	rjmp	80004016 <phy_tx_func+0x246>
		{
			case 0:
		
				if ((m_RxBurstType == VOICE_WATING) || (m_RxBurstType == VOICETERMINATOR)  || (m_RxBurstType == VOICEHEADER))
80003ef4:	fe f8 04 58 	ld.w	r8,pc[1112]
80003ef8:	70 08       	ld.w	r8,r8[0x0]
80003efa:	58 08       	cp.w	r8,0
80003efc:	c0 b0       	breq	80003f12 <phy_tx_func+0x142>
80003efe:	fe f8 04 4e 	ld.w	r8,pc[1102]
80003f02:	70 08       	ld.w	r8,r8[0x0]
80003f04:	58 98       	cp.w	r8,9
80003f06:	c0 60       	breq	80003f12 <phy_tx_func+0x142>
80003f08:	fe f8 04 44 	ld.w	r8,pc[1092]
80003f0c:	70 08       	ld.w	r8,r8[0x0]
80003f0e:	58 18       	cp.w	r8,1
80003f10:	c0 a1       	brne	80003f24 <phy_tx_func+0x154>
				{
							
					payload_tx_channel->dword[0] = PAYLOADIDLE0;
80003f12:	e0 68 5a 5a 	mov	r8,23130
80003f16:	ea 18 ab cd 	orh	r8,0xabcd
80003f1a:	8f 28       	st.w	r7[0x8],r8
					payload_tx_channel->dword[1] = PAYLOADIDLE1;
80003f1c:	30 08       	mov	r8,0
80003f1e:	8f 38       	st.w	r7[0xc],r8
80003f20:	e0 8f 02 02 	bral	80004324 <phy_tx_func+0x554>
			
				}
				else if((m_RxBurstType == UNSUREDATA))
80003f24:	fe f8 04 28 	ld.w	r8,pc[1064]
80003f28:	70 08       	ld.w	r8,r8[0x0]
80003f2a:	58 28       	cp.w	r8,2
80003f2c:	c0 91       	brne	80003f3e <phy_tx_func+0x16e>
				{
					payload_tx_channel->dword[0] = AMBE_HT[0];
80003f2e:	fe f8 04 22 	ld.w	r8,pc[1058]
80003f32:	70 09       	ld.w	r9,r8[0x0]
80003f34:	8f 29       	st.w	r7[0x8],r9
					payload_tx_channel->dword[1] = AMBE_HT[1];
80003f36:	70 18       	ld.w	r8,r8[0x4]
80003f38:	8f 38       	st.w	r7[0xc],r8
80003f3a:	e0 8f 01 f5 	bral	80004324 <phy_tx_func+0x554>
				}
				else
				{
					payload_tx_state = 1;
80003f3e:	30 19       	mov	r9,1
80003f40:	fe f8 04 08 	ld.w	r8,pc[1032]
80003f44:	b0 89       	st.b	r8[0x0],r9
					
					//0xABCDCOOE
					payload_tx_channel->dword[0] = EN_OB_PAYLOAD;//49bits
80003f46:	e0 68 c0 0e 	mov	r8,49166
80003f4a:	ea 18 ab cd 	orh	r8,0xabcd
80003f4e:	8f 28       	st.w	r7[0x8],r8
					//0x8212
					payload_tx_channel->word[2] = VBSP_data[0];
80003f50:	fe f8 04 04 	ld.w	r8,pc[1028]
80003f54:	90 09       	ld.sh	r9,r8[0x0]
80003f56:	ae 69       	st.h	r7[0xc],r9
					//0xF00x
					payload_tx_channel->word[3] = VBSP_data[1];
80003f58:	90 18       	ld.sh	r8,r8[0x2]
80003f5a:	ae 78       	st.h	r7[0xe],r8
80003f5c:	e0 8f 01 e4 	bral	80004324 <phy_tx_func+0x554>
				break;
			
			case 1:
			
				//0x88F2
				payload_tx_channel->word[0] = ENCODER_PAYLOAD;//49bits
80003f60:	fe 78 88 f2 	mov	r8,-30478
80003f64:	ae 48       	st.h	r7[0x8],r8
			
				switch (m_RxBurstType)//
80003f66:	fe f8 03 e6 	ld.w	r8,pc[998]
80003f6a:	70 08       	ld.w	r8,r8[0x0]
80003f6c:	58 38       	cp.w	r8,3
80003f6e:	c0 60       	breq	80003f7a <phy_tx_func+0x1aa>
80003f70:	c4 73       	brcs	80003ffe <phy_tx_func+0x22e>
80003f72:	58 88       	cp.w	r8,8
80003f74:	e0 8b 00 45 	brhi	80003ffe <phy_tx_func+0x22e>
80003f78:	c2 a8       	rjmp	80003fcc <phy_tx_func+0x1fc>
				{
					case VOICEBURST_A:
							if (VF_SN == 1)
80003f7a:	fe f8 03 de 	ld.w	r8,pc[990]
80003f7e:	11 89       	ld.ub	r9,r8[0x0]
80003f80:	30 18       	mov	r8,1
80003f82:	f0 09 18 00 	cp.b	r9,r8
80003f86:	c0 a1       	brne	80003f9a <phy_tx_func+0x1ca>
							{	
								//Place public key
								payload_tx_channel->word[1] = Public_AMBEkey[0];
80003f88:	fe f8 03 d4 	ld.w	r8,pc[980]
80003f8c:	90 09       	ld.sh	r9,r8[0x0]
80003f8e:	ae 59       	st.h	r7[0xa],r9
								payload_tx_channel->word[2] = Public_AMBEkey[1];
80003f90:	90 19       	ld.sh	r9,r8[0x2]
80003f92:	ae 69       	st.h	r7[0xc],r9
								payload_tx_channel->word[3] = Public_AMBEkey[2];
80003f94:	90 28       	ld.sh	r8,r8[0x4]
80003f96:	ae 78       	st.h	r7[0xe],r8
80003f98:	c1 48       	rjmp	80003fc0 <phy_tx_func+0x1f0>
								//logFromISR("\n\r MMQ \n\r");
							}
							else//VF_SN==2/3
							{
								//Encrypted AMBE data(XOR)
								payload_tx_channel->word[1] = ((Public_AMBEkey[0]) ^ (AMBEBurst_rawdata[0])) ;
80003f9a:	fe f9 03 c6 	ld.w	r9,pc[966]
80003f9e:	92 0b       	ld.sh	r11,r9[0x0]
80003fa0:	fe f8 03 bc 	ld.w	r8,pc[956]
80003fa4:	90 0a       	ld.sh	r10,r8[0x0]
80003fa6:	f7 ea 20 0a 	eor	r10,r11,r10
80003faa:	ae 5a       	st.h	r7[0xa],r10
								payload_tx_channel->word[2] = ((Public_AMBEkey[1]) ^ (AMBEBurst_rawdata[1])) ;
80003fac:	92 1b       	ld.sh	r11,r9[0x2]
80003fae:	90 1a       	ld.sh	r10,r8[0x2]
80003fb0:	f7 ea 20 0a 	eor	r10,r11,r10
80003fb4:	ae 6a       	st.h	r7[0xc],r10
								payload_tx_channel->word[3] = ((Public_AMBEkey[2]) ^ (AMBEBurst_rawdata[2])) ;
80003fb6:	92 29       	ld.sh	r9,r9[0x4]
80003fb8:	90 28       	ld.sh	r8,r8[0x4]
80003fba:	f3 e8 20 08 	eor	r8,r9,r8
80003fbe:	ae 78       	st.h	r7[0xe],r8
								//payload_tx_channel->word[2] = AMBEBurst_rawdata[1];
								//payload_tx_channel->word[3] = AMBEBurst_rawdata[2];
						
							}
					
							payload_tx_state = 2;
80003fc0:	30 29       	mov	r9,2
80003fc2:	fe f8 03 86 	ld.w	r8,pc[902]
80003fc6:	b0 89       	st.b	r8[0x0],r9
80003fc8:	e0 8f 01 ae 	bral	80004324 <phy_tx_func+0x554>
							//Encrypted AMBE data(XOR)
						
							//payload_tx_channel->word[1] = AMBEBurst_rawdata[0];
							//payload_tx_channel->word[2] = AMBEBurst_rawdata[1];
							//payload_tx_channel->word[3] = AMBEBurst_rawdata[2];
							payload_tx_channel->word[1] = ((Public_AMBEkey[0]) ^ (AMBEBurst_rawdata[0])) ;
80003fcc:	fe f9 03 94 	ld.w	r9,pc[916]
80003fd0:	92 0b       	ld.sh	r11,r9[0x0]
80003fd2:	fe f8 03 8a 	ld.w	r8,pc[906]
80003fd6:	90 0a       	ld.sh	r10,r8[0x0]
80003fd8:	f7 ea 20 0a 	eor	r10,r11,r10
80003fdc:	ae 5a       	st.h	r7[0xa],r10
							payload_tx_channel->word[2] = ((Public_AMBEkey[1]) ^ (AMBEBurst_rawdata[1])) ;
80003fde:	92 1b       	ld.sh	r11,r9[0x2]
80003fe0:	90 1a       	ld.sh	r10,r8[0x2]
80003fe2:	f7 ea 20 0a 	eor	r10,r11,r10
80003fe6:	ae 6a       	st.h	r7[0xc],r10
							payload_tx_channel->word[3] = ((Public_AMBEkey[2]) ^ (AMBEBurst_rawdata[2])) ;
80003fe8:	92 29       	ld.sh	r9,r9[0x4]
80003fea:	90 28       	ld.sh	r8,r8[0x4]
80003fec:	f3 e8 20 08 	eor	r8,r9,r8
80003ff0:	ae 78       	st.h	r7[0xe],r8
						
							payload_tx_state = 2;
80003ff2:	30 29       	mov	r9,2
80003ff4:	fe f8 03 54 	ld.w	r8,pc[852]
80003ff8:	b0 89       	st.b	r8[0x0],r9
80003ffa:	e0 8f 01 95 	bral	80004324 <phy_tx_func+0x554>
				
						break;
					default://This shouldn't happen, but must check;
					
							payload_tx_channel->dword[0] = PAYLOADIDLE0;
80003ffe:	e0 68 5a 5a 	mov	r8,23130
80004002:	ea 18 ab cd 	orh	r8,0xabcd
80004006:	8f 28       	st.w	r7[0x8],r8
							payload_tx_channel->dword[1] = PAYLOADIDLE1;
80004008:	30 08       	mov	r8,0
8000400a:	8f 38       	st.w	r7[0xc],r8
							payload_tx_state = 0;
8000400c:	fe f9 03 3c 	ld.w	r9,pc[828]
80004010:	b2 88       	st.b	r9[0x0],r8
80004012:	e0 8f 01 89 	bral	80004324 <phy_tx_func+0x554>
			
			case 2:
					//Encrypted AMBE data(XOR)
					//payload_tx_channel->word[0] = AMBEBurst_rawdata[3];
				
					if ((m_RxBurstType == VOICEBURST_A) && (VF_SN == 1))
80004016:	fe f8 03 36 	ld.w	r8,pc[822]
8000401a:	70 08       	ld.w	r8,r8[0x0]
8000401c:	58 38       	cp.w	r8,3
8000401e:	c0 d1       	brne	80004038 <phy_tx_func+0x268>
80004020:	fe f8 03 38 	ld.w	r8,pc[824]
80004024:	11 89       	ld.ub	r9,r8[0x0]
80004026:	30 18       	mov	r8,1
80004028:	f0 09 18 00 	cp.b	r9,r8
8000402c:	c0 61       	brne	80004038 <phy_tx_func+0x268>
					{
						payload_tx_channel->word[0]	= ((Public_AMBEkey[3])) ;
8000402e:	fe f8 03 2e 	ld.w	r8,pc[814]
80004032:	90 38       	ld.sh	r8,r8[0x6]
80004034:	ae 48       	st.h	r7[0x8],r8
80004036:	c0 a8       	rjmp	8000404a <phy_tx_func+0x27a>
					}
					else{
					
						payload_tx_channel->word[0]	= ((Public_AMBEkey[3]) ^ (AMBEBurst_rawdata[3])) ;
80004038:	fe f8 03 28 	ld.w	r8,pc[808]
8000403c:	90 39       	ld.sh	r9,r8[0x6]
8000403e:	fe f8 03 1e 	ld.w	r8,pc[798]
80004042:	90 38       	ld.sh	r8,r8[0x6]
80004044:	f3 e8 20 08 	eor	r8,r9,r8
80004048:	ae 48       	st.h	r7[0x8],r8
					
					}
					payload_tx_channel->word[1]	= 0x00BA ; 
8000404a:	e0 68 00 ba 	mov	r8,186
8000404e:	ae 58       	st.h	r7[0xa],r8
					payload_tx_channel->word[2]	= 0x0000 ;
80004050:	30 08       	mov	r8,0
80004052:	ae 68       	st.h	r7[0xc],r8
					payload_tx_channel->word[3]	= 0x0000 ;
80004054:	ae 78       	st.h	r7[0xe],r8
				
					payload_tx_state = 0;
80004056:	fe f9 02 f2 	ld.w	r9,pc[754]
8000405a:	b2 88       	st.b	r9[0x0],r8
8000405c:	e0 8f 01 64 	bral	80004324 <phy_tx_func+0x554>

#if 1
else//Send-PCM-data40bytes/2.5ms.
{
	
	index = (index >=30240) ? 0 : index;
80004060:	fe f8 03 04 	ld.w	r8,pc[772]
80004064:	70 08       	ld.w	r8,r8[0x0]
80004066:	e0 48 76 20 	cp.w	r8,30240
8000406a:	f9 b8 02 00 	movhs	r8,0
8000406e:	fe f9 02 f6 	ld.w	r9,pc[758]
80004072:	93 08       	st.w	r9[0x0],r8
	
	if(is_unmute == 1)counter++;
80004074:	fe f8 02 f4 	ld.w	r8,pc[756]
80004078:	11 89       	ld.ub	r9,r8[0x0]
8000407a:	30 18       	mov	r8,1
8000407c:	f0 09 18 00 	cp.b	r9,r8
80004080:	c0 61       	brne	8000408c <phy_tx_func+0x2bc>
80004082:	fe f8 02 ea 	ld.w	r8,pc[746]
80004086:	70 09       	ld.w	r9,r8[0x0]
80004088:	2f f9       	sub	r9,-1
8000408a:	91 09       	st.w	r8[0x0],r9
	
	switch(payload_tx_state)
8000408c:	fe f8 02 bc 	ld.w	r8,pc[700]
80004090:	11 88       	ld.ub	r8,r8[0x0]
80004092:	30 19       	mov	r9,1
80004094:	f2 08 18 00 	cp.b	r8,r9
80004098:	c3 60       	breq	80004104 <phy_tx_func+0x334>
8000409a:	c0 73       	brcs	800040a8 <phy_tx_func+0x2d8>
8000409c:	30 29       	mov	r9,2
8000409e:	f2 08 18 00 	cp.b	r8,r9
800040a2:	e0 81 01 3e 	brne	8000431e <phy_tx_func+0x54e>
800040a6:	c7 c8       	rjmp	8000419e <phy_tx_func+0x3ce>
	{
		case 0:
		
			payload_tx_channel->dword[0] = PAYLOADIDLE0;
800040a8:	e0 68 5a 5a 	mov	r8,23130
800040ac:	ea 18 ab cd 	orh	r8,0xabcd
800040b0:	8f 28       	st.w	r7[0x8],r8
			payload_tx_channel->dword[1] = PAYLOADIDLE1;
800040b2:	30 08       	mov	r8,0
800040b4:	8f 38       	st.w	r7[0xc],r8
		
			if(((counter % 20 )== 0) && (counter != 0) &&(is_unmute == 1))//20*125us = 2.5ms.
800040b6:	fe f8 02 b6 	ld.w	r8,pc[694]
800040ba:	70 08       	ld.w	r8,r8[0x0]
800040bc:	e0 6b cc cd 	mov	r11,52429
800040c0:	ea 1b cc cc 	orh	r11,0xcccc
800040c4:	f0 0b 06 4a 	mulu.d	r10,r8,r11
800040c8:	f6 09 16 04 	lsr	r9,r11,0x4
800040cc:	f2 09 00 29 	add	r9,r9,r9<<0x2
800040d0:	f0 09 01 29 	sub	r9,r8,r9<<0x2
800040d4:	c1 21       	brne	800040f8 <phy_tx_func+0x328>
800040d6:	58 08       	cp.w	r8,0
800040d8:	c1 00       	breq	800040f8 <phy_tx_func+0x328>
800040da:	fe f8 02 8e 	ld.w	r8,pc[654]
800040de:	11 89       	ld.ub	r9,r8[0x0]
800040e0:	30 18       	mov	r8,1
800040e2:	f0 09 18 00 	cp.b	r9,r8
800040e6:	c0 91       	brne	800040f8 <phy_tx_func+0x328>
			{
				payload_tx_state = 1;
800040e8:	10 99       	mov	r9,r8
800040ea:	fe f8 02 5e 	ld.w	r8,pc[606]
800040ee:	b0 89       	st.b	r8[0x0],r9
				//payload_tx_state = 0;
				frame_number = 0;
800040f0:	30 09       	mov	r9,0
800040f2:	fe f8 02 7e 	ld.w	r8,pc[638]
800040f6:	b0 89       	st.b	r8[0x0],r9
	
			}
		
			send_num++;
800040f8:	fe f8 02 7c 	ld.w	r8,pc[636]
800040fc:	70 09       	ld.w	r9,r8[0x0]
800040fe:	2f f9       	sub	r9,-1
80004100:	91 09       	st.w	r8[0x0],r9
80004102:	c1 19       	rjmp	80004324 <phy_tx_func+0x554>
			break;
		
		case 1:
		
	
			payload_tx_channel->word[0] = 0xABCD; 
80004104:	fe 78 ab cd 	mov	r8,-21555
80004108:	ae 48       	st.h	r7[0x8],r8
		
			if(frame_number == 0)
8000410a:	fe f8 02 66 	ld.w	r8,pc[614]
8000410e:	11 89       	ld.ub	r9,r8[0x0]
80004110:	30 08       	mov	r8,0
80004112:	f0 09 18 00 	cp.b	r9,r8
80004116:	c1 b1       	brne	8000414c <phy_tx_func+0x37c>
			{
				if (Silent_flag == 1)
80004118:	fe f8 02 60 	ld.w	r8,pc[608]
8000411c:	11 89       	ld.ub	r9,r8[0x0]
8000411e:	30 18       	mov	r8,1
80004120:	f0 09 18 00 	cp.b	r9,r8
80004124:	c0 91       	brne	80004136 <phy_tx_func+0x366>
				{
					//44betes-4bytes= 40bytes
					expexted_length = 0x2C;//One Descriptor Indicator
80004126:	32 c9       	mov	r9,44
80004128:	fe f8 02 54 	ld.w	r8,pc[596]
8000412c:	b0 09       	st.h	r8[0x0],r9
					payload_tx_channel->word[1] = 0x102C;//44betes-4bytes= 40bytes
8000412e:	e0 68 10 2c 	mov	r8,4140
80004132:	ae 58       	st.h	r7[0xa],r8
80004134:	c0 88       	rjmp	80004144 <phy_tx_func+0x374>
				}
				
				else
				{
					//first frame
					expexted_length = 0x2A;
80004136:	32 a9       	mov	r9,42
80004138:	fe f8 02 44 	ld.w	r8,pc[580]
8000413c:	b0 09       	st.h	r8[0x0],r9
					payload_tx_channel->word[1] = 0x102A;//42-2= 40 bytes;	
8000413e:	e0 68 10 2a 	mov	r8,4138
80004142:	ae 58       	st.h	r7[0xa],r8
				}
				
					last_frame = TRUE;
80004144:	30 19       	mov	r9,1
80004146:	fe f8 02 3a 	ld.w	r8,pc[570]
8000414a:	b0 89       	st.b	r8[0x0],r9
			//
			//
			//}
			//else//
			
			if (Silent_flag == 1)//
8000414c:	fe f8 02 2c 	ld.w	r8,pc[556]
80004150:	11 89       	ld.ub	r9,r8[0x0]
80004152:	30 18       	mov	r8,1
80004154:	f0 09 18 00 	cp.b	r9,r8
80004158:	c0 61       	brne	80004164 <phy_tx_func+0x394>
			{
			
				payload_tx_channel->word[2] = 0x0001;//Array Descriptor Length
8000415a:	30 18       	mov	r8,1
8000415c:	ae 68       	st.h	r7[0xc],r8
				payload_tx_channel->word[3] =  0x0004;//Silent Descriptor Indicator
8000415e:	30 48       	mov	r8,4
80004160:	ae 78       	st.h	r7[0xe],r8
80004162:	c1 38       	rjmp	80004188 <phy_tx_func+0x3b8>

			}
			else
			{
			
				payload_tx_channel->word[2] = 0x0000;
80004164:	30 08       	mov	r8,0
80004166:	ae 68       	st.h	r7[0xc],r8
				payload_tx_channel->word[3] =  ((AudioData[index]<<8 )+ AudioData[index+1] );
80004168:	4f f8       	lddpc	r8,80004364 <phy_tx_func+0x594>
8000416a:	70 09       	ld.w	r9,r8[0x0]
8000416c:	fe fa 02 18 	ld.w	r10,pc[536]
80004170:	f4 09 00 0b 	add	r11,r10,r9
80004174:	17 9b       	ld.ub	r11,r11[0x1]
80004176:	f4 09 07 09 	ld.ub	r9,r10[r9]
8000417a:	a9 69       	lsl	r9,0x8
8000417c:	f6 09 00 09 	add	r9,r11,r9
80004180:	ae 79       	st.h	r7[0xe],r9
				index+=2;
80004182:	70 09       	ld.w	r9,r8[0x0]
80004184:	2f e9       	sub	r9,-2
80004186:	91 09       	st.w	r8[0x0],r9
			
			}
		
			expexted_length -= 4;
80004188:	4f d8       	lddpc	r8,8000437c <phy_tx_func+0x5ac>
8000418a:	90 09       	ld.sh	r9,r8[0x0]
8000418c:	20 49       	sub	r9,4
8000418e:	b0 09       	st.h	r8[0x0],r9
		
			//frame_number++;
			payload_tx_state = 2;
80004190:	30 29       	mov	r9,2
80004192:	4e e8       	lddpc	r8,80004348 <phy_tx_func+0x578>
80004194:	b0 89       	st.b	r8[0x0],r9
		
			i = 0;
80004196:	30 09       	mov	r9,0
80004198:	4f c8       	lddpc	r8,80004388 <phy_tx_func+0x5b8>
8000419a:	91 09       	st.w	r8[0x0],r9
8000419c:	cc 48       	rjmp	80004324 <phy_tx_func+0x554>
		
			break;
		
		case 2:
		
			if(expexted_length <= 0)
8000419e:	4f 88       	lddpc	r8,8000437c <phy_tx_func+0x5ac>
800041a0:	90 09       	ld.sh	r9,r8[0x0]
800041a2:	30 08       	mov	r8,0
800041a4:	f0 09 19 00 	cp.h	r9,r8
800041a8:	e0 89 00 12 	brgt	800041cc <phy_tx_func+0x3fc>
			{
				//last word 0x00BA
				payload_tx_state = last_frame ? 0 : 1;
800041ac:	4f 58       	lddpc	r8,80004380 <phy_tx_func+0x5b0>
800041ae:	11 89       	ld.ub	r9,r8[0x0]
800041b0:	30 08       	mov	r8,0
800041b2:	f0 09 18 00 	cp.b	r9,r8
800041b6:	5f 09       	sreq	r9
800041b8:	4e 48       	lddpc	r8,80004348 <phy_tx_func+0x578>
800041ba:	b0 89       	st.b	r8[0x0],r9
				payload_tx_channel->word[0] = 0x00BA;
800041bc:	e0 68 00 ba 	mov	r8,186
800041c0:	ae 48       	st.h	r7[0x8],r8
				payload_tx_channel->word[1] = 0x0000;
800041c2:	30 08       	mov	r8,0
800041c4:	ae 58       	st.h	r7[0xa],r8
				payload_tx_channel->word[2] = 0x0000;
800041c6:	ae 68       	st.h	r7[0xc],r8
				payload_tx_channel->word[3] = 0x0000;
800041c8:	ae 78       	st.h	r7[0xe],r8
800041ca:	ca d8       	rjmp	80004324 <phy_tx_func+0x554>
				break;
			}
		
			if(Silent_flag == 1)
800041cc:	4e b8       	lddpc	r8,80004378 <phy_tx_func+0x5a8>
800041ce:	11 89       	ld.ub	r9,r8[0x0]
800041d0:	30 18       	mov	r8,1
800041d2:	f0 09 18 00 	cp.b	r9,r8
800041d6:	c0 41       	brne	800041de <phy_tx_func+0x40e>
			{
				payload_tx_channel->word[0] =  0x0000;
800041d8:	30 08       	mov	r8,0
800041da:	ae 48       	st.h	r7[0x8],r8
800041dc:	c1 08       	rjmp	800041fc <phy_tx_func+0x42c>
			}
			else
			{
				//payload_tx_channel->word[0] = AudioData[index++] + (AudioData[index++] << 8);
				payload_tx_channel->word[0] =  ((AudioData[index]<<8 )+ AudioData[index+1] );
800041de:	4e 28       	lddpc	r8,80004364 <phy_tx_func+0x594>
800041e0:	70 09       	ld.w	r9,r8[0x0]
800041e2:	4e 9a       	lddpc	r10,80004384 <phy_tx_func+0x5b4>
800041e4:	f4 09 00 0b 	add	r11,r10,r9
800041e8:	17 9b       	ld.ub	r11,r11[0x1]
800041ea:	f4 09 07 09 	ld.ub	r9,r10[r9]
800041ee:	a9 69       	lsl	r9,0x8
800041f0:	f6 09 00 09 	add	r9,r11,r9
800041f4:	ae 49       	st.h	r7[0x8],r9
				index+=2;
800041f6:	70 09       	ld.w	r9,r8[0x0]
800041f8:	2f e9       	sub	r9,-2
800041fa:	91 09       	st.w	r8[0x0],r9
			
			}

			expexted_length -= 2;
800041fc:	4e 09       	lddpc	r9,8000437c <phy_tx_func+0x5ac>
800041fe:	92 08       	ld.sh	r8,r9[0x0]
80004200:	20 28       	sub	r8,2
80004202:	b2 08       	st.h	r9[0x0],r8
			if(expexted_length <= 0)
80004204:	30 09       	mov	r9,0
80004206:	f2 08 19 00 	cp.h	r8,r9
8000420a:	e0 89 00 11 	brgt	8000422c <phy_tx_func+0x45c>
			{
				//last word 0x00BA
				payload_tx_state = last_frame ? 0 : 1;
8000420e:	4d d8       	lddpc	r8,80004380 <phy_tx_func+0x5b0>
80004210:	11 89       	ld.ub	r9,r8[0x0]
80004212:	30 08       	mov	r8,0
80004214:	f0 09 18 00 	cp.b	r9,r8
80004218:	5f 09       	sreq	r9
8000421a:	4c c8       	lddpc	r8,80004348 <phy_tx_func+0x578>
8000421c:	b0 89       	st.b	r8[0x0],r9
				payload_tx_channel->word[1] = 0x00BA;
8000421e:	e0 68 00 ba 	mov	r8,186
80004222:	ae 58       	st.h	r7[0xa],r8
				payload_tx_channel->word[2] = 0x0000;
80004224:	30 08       	mov	r8,0
80004226:	ae 68       	st.h	r7[0xc],r8
				payload_tx_channel->word[3] = 0x0000;
80004228:	ae 78       	st.h	r7[0xe],r8
8000422a:	c7 d8       	rjmp	80004324 <phy_tx_func+0x554>
				break;
			}
		
			if(Silent_flag == 1)
8000422c:	4d 38       	lddpc	r8,80004378 <phy_tx_func+0x5a8>
8000422e:	11 89       	ld.ub	r9,r8[0x0]
80004230:	30 18       	mov	r8,1
80004232:	f0 09 18 00 	cp.b	r9,r8
80004236:	c0 41       	brne	8000423e <phy_tx_func+0x46e>
			{
				payload_tx_channel->word[1] =  0x0000;
80004238:	30 08       	mov	r8,0
8000423a:	ae 58       	st.h	r7[0xa],r8
8000423c:	c1 08       	rjmp	8000425c <phy_tx_func+0x48c>
			}
			else
			{
			
				payload_tx_channel->word[1] =  ((AudioData[index]<<8 )+ AudioData[index+1] );
8000423e:	4c a8       	lddpc	r8,80004364 <phy_tx_func+0x594>
80004240:	70 09       	ld.w	r9,r8[0x0]
80004242:	4d 1a       	lddpc	r10,80004384 <phy_tx_func+0x5b4>
80004244:	f4 09 00 0b 	add	r11,r10,r9
80004248:	17 9b       	ld.ub	r11,r11[0x1]
8000424a:	f4 09 07 09 	ld.ub	r9,r10[r9]
8000424e:	a9 69       	lsl	r9,0x8
80004250:	f6 09 00 09 	add	r9,r11,r9
80004254:	ae 59       	st.h	r7[0xa],r9
				index+=2;
80004256:	70 09       	ld.w	r9,r8[0x0]
80004258:	2f e9       	sub	r9,-2
8000425a:	91 09       	st.w	r8[0x0],r9
			}
			//payload_tx_channel->word[1] =  ((AudioData[index]<<8 )+ AudioData[index+1] );
		
			expexted_length -= 2;
8000425c:	4c 89       	lddpc	r9,8000437c <phy_tx_func+0x5ac>
8000425e:	92 08       	ld.sh	r8,r9[0x0]
80004260:	20 28       	sub	r8,2
80004262:	b2 08       	st.h	r9[0x0],r8
			if(expexted_length <= 0)
80004264:	30 09       	mov	r9,0
80004266:	f2 08 19 00 	cp.h	r8,r9
8000426a:	e0 89 00 10 	brgt	8000428a <phy_tx_func+0x4ba>
			{
				//last word 0x00BA
				payload_tx_state = last_frame ? 0 : 1;
8000426e:	4c 58       	lddpc	r8,80004380 <phy_tx_func+0x5b0>
80004270:	11 89       	ld.ub	r9,r8[0x0]
80004272:	30 08       	mov	r8,0
80004274:	f0 09 18 00 	cp.b	r9,r8
80004278:	5f 09       	sreq	r9
8000427a:	4b 48       	lddpc	r8,80004348 <phy_tx_func+0x578>
8000427c:	b0 89       	st.b	r8[0x0],r9
				payload_tx_channel->word[2] = 0x00BA;
8000427e:	e0 68 00 ba 	mov	r8,186
80004282:	ae 68       	st.h	r7[0xc],r8
				payload_tx_channel->word[3] = 0x0000;
80004284:	30 08       	mov	r8,0
80004286:	ae 78       	st.h	r7[0xe],r8
80004288:	c4 e8       	rjmp	80004324 <phy_tx_func+0x554>
				break;
			}
		
			if(Silent_flag == 1)
8000428a:	4b c8       	lddpc	r8,80004378 <phy_tx_func+0x5a8>
8000428c:	11 89       	ld.ub	r9,r8[0x0]
8000428e:	30 18       	mov	r8,1
80004290:	f0 09 18 00 	cp.b	r9,r8
80004294:	c0 41       	brne	8000429c <phy_tx_func+0x4cc>
			{
				payload_tx_channel->word[2] =  0x0000;
80004296:	30 08       	mov	r8,0
80004298:	ae 68       	st.h	r7[0xc],r8
8000429a:	c1 08       	rjmp	800042ba <phy_tx_func+0x4ea>
			}
			else
			{
			
				payload_tx_channel->word[2] =  ((AudioData[index]<<8 )+ AudioData[index+1] );
8000429c:	4b 28       	lddpc	r8,80004364 <phy_tx_func+0x594>
8000429e:	70 09       	ld.w	r9,r8[0x0]
800042a0:	4b 9a       	lddpc	r10,80004384 <phy_tx_func+0x5b4>
800042a2:	f4 09 00 0b 	add	r11,r10,r9
800042a6:	17 9b       	ld.ub	r11,r11[0x1]
800042a8:	f4 09 07 09 	ld.ub	r9,r10[r9]
800042ac:	a9 69       	lsl	r9,0x8
800042ae:	f6 09 00 09 	add	r9,r11,r9
800042b2:	ae 69       	st.h	r7[0xc],r9
				index+=2;
800042b4:	70 09       	ld.w	r9,r8[0x0]
800042b6:	2f e9       	sub	r9,-2
800042b8:	91 09       	st.w	r8[0x0],r9
			}
			//payload_tx_channel->word[2] =  ((AudioData[index]<<8 )+ AudioData[index+1] );
		
			expexted_length -= 2;
800042ba:	4b 19       	lddpc	r9,8000437c <phy_tx_func+0x5ac>
800042bc:	92 08       	ld.sh	r8,r9[0x0]
800042be:	20 28       	sub	r8,2
800042c0:	b2 08       	st.h	r9[0x0],r8
			if(expexted_length <= 0)
800042c2:	30 09       	mov	r9,0
800042c4:	f2 08 19 00 	cp.h	r8,r9
800042c8:	e0 89 00 0e 	brgt	800042e4 <phy_tx_func+0x514>
			{
				//last word 0x00BA
				payload_tx_state = last_frame ? 0 : 1;
800042cc:	4a d8       	lddpc	r8,80004380 <phy_tx_func+0x5b0>
800042ce:	11 89       	ld.ub	r9,r8[0x0]
800042d0:	30 08       	mov	r8,0
800042d2:	f0 09 18 00 	cp.b	r9,r8
800042d6:	5f 09       	sreq	r9
800042d8:	49 c8       	lddpc	r8,80004348 <phy_tx_func+0x578>
800042da:	b0 89       	st.b	r8[0x0],r9
				payload_tx_channel->word[3] = 0x00BA;
800042dc:	e0 68 00 ba 	mov	r8,186
800042e0:	ae 78       	st.h	r7[0xe],r8
800042e2:	c2 18       	rjmp	80004324 <phy_tx_func+0x554>
				break;
			}
		
			if(Silent_flag == 1)
800042e4:	4a 58       	lddpc	r8,80004378 <phy_tx_func+0x5a8>
800042e6:	11 89       	ld.ub	r9,r8[0x0]
800042e8:	30 18       	mov	r8,1
800042ea:	f0 09 18 00 	cp.b	r9,r8
800042ee:	c0 41       	brne	800042f6 <phy_tx_func+0x526>
			{
				payload_tx_channel->word[3] =  0x0000;
800042f0:	30 08       	mov	r8,0
800042f2:	ae 78       	st.h	r7[0xe],r8
800042f4:	c1 08       	rjmp	80004314 <phy_tx_func+0x544>
			}
			else
			{
			
				payload_tx_channel->word[3] =  ((AudioData[index]<<8 )+ AudioData[index+1] );
800042f6:	49 c8       	lddpc	r8,80004364 <phy_tx_func+0x594>
800042f8:	70 09       	ld.w	r9,r8[0x0]
800042fa:	4a 3a       	lddpc	r10,80004384 <phy_tx_func+0x5b4>
800042fc:	f4 09 00 0b 	add	r11,r10,r9
80004300:	17 9b       	ld.ub	r11,r11[0x1]
80004302:	f4 09 07 09 	ld.ub	r9,r10[r9]
80004306:	a9 69       	lsl	r9,0x8
80004308:	f6 09 00 09 	add	r9,r11,r9
8000430c:	ae 79       	st.h	r7[0xe],r9
				index+=2;
8000430e:	70 09       	ld.w	r9,r8[0x0]
80004310:	2f e9       	sub	r9,-2
80004312:	91 09       	st.w	r8[0x0],r9
			}
		
			//payload_tx_channel->word[3] =  ((AudioData[index]<<8 )+ AudioData[index+1] );
		
			expexted_length -= 2;
80004314:	49 a8       	lddpc	r8,8000437c <phy_tx_func+0x5ac>
80004316:	90 09       	ld.sh	r9,r8[0x0]
80004318:	20 29       	sub	r9,2
8000431a:	b0 09       	st.h	r8[0x0],r9
8000431c:	c0 48       	rjmp	80004324 <phy_tx_func+0x554>
		
			break;
		
		default:
			payload_tx_state = 0;
8000431e:	30 09       	mov	r9,0
80004320:	48 a8       	lddpc	r8,80004348 <phy_tx_func+0x578>
80004322:	b0 89       	st.b	r8[0x0],r9
	#else
	/*send idle frame*/	
	((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
	((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
	#endif /*end if*/
}
80004324:	2f fd       	sub	sp,-4
80004326:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000432a:	00 00       	add	r0,r0
8000432c:	00 00       	add	r0,r0
8000432e:	10 60       	and	r0,r8
80004330:	00 00       	add	r0,r0
80004332:	10 2c       	rsub	r12,r8
80004334:	00 00       	add	r0,r0
80004336:	0f f8       	ld.ub	r8,r7[0x7]
80004338:	80 00       	ld.sh	r0,r0[0x0]
8000433a:	90 54       	ld.sh	r4,r8[0xa]
8000433c:	00 00       	add	r0,r0
8000433e:	10 4a       	or	r10,r8
80004340:	00 00       	add	r0,r0
80004342:	10 41       	or	r1,r8
80004344:	00 00       	add	r0,r0
80004346:	0a 42       	or	r2,r5
80004348:	00 00       	add	r0,r0
8000434a:	10 42       	or	r2,r8
8000434c:	00 00       	add	r0,r0
8000434e:	10 00       	add	r0,r8
80004350:	00 00       	add	r0,r0
80004352:	10 30       	cp.w	r0,r8
80004354:	00 00       	add	r0,r0
80004356:	14 4c       	or	r12,r10
80004358:	00 00       	add	r0,r0
8000435a:	0a 40       	or	r0,r5
8000435c:	80 01       	ld.sh	r1,r0[0x0]
8000435e:	0a 58       	eor	r8,r5
80004360:	00 00       	add	r0,r0
80004362:	13 54       	ld.sh	r4,--r9
80004364:	00 00       	add	r0,r0
80004366:	10 20       	rsub	r0,r8
80004368:	00 00       	add	r0,r0
8000436a:	0a 48       	or	r8,r5
8000436c:	00 00       	add	r0,r0
8000436e:	10 64       	and	r4,r8
80004370:	00 00       	add	r0,r0
80004372:	10 40       	or	r0,r8
80004374:	00 00       	add	r0,r0
80004376:	10 58       	eor	r8,r8
80004378:	00 00       	add	r0,r0
8000437a:	0a 50       	eor	r0,r5
8000437c:	00 00       	add	r0,r0
8000437e:	10 70       	tst	r0,r8
80004380:	00 00       	add	r0,r0
80004382:	10 08       	add	r8,r8
80004384:	80 01       	ld.sh	r1,r0[0x0]
80004386:	0a c0       	st.b	r5++,r0
80004388:	00 00       	add	r0,r0
8000438a:	10 74       	tst	r4,r8

8000438c <get_idle_store>:
	}//End of RxMedia Phy Handler.
}
#endif /*end if*/

void * get_idle_store(xQueueHandle store)
{
8000438c:	d4 01       	pushm	lr
8000438e:	20 1d       	sub	sp,4
	void * ptr = NULL;
80004390:	30 0a       	mov	r10,0
80004392:	fa cb ff fc 	sub	r11,sp,-4
80004396:	16 da       	st.w	--r11,r10

	if(pdTRUE == xQueueReceive(store, &ptr, 0))
80004398:	14 99       	mov	r9,r10
8000439a:	1a 9b       	mov	r11,sp
8000439c:	f0 1f 00 05 	mcall	800043b0 <get_idle_store+0x24>
800043a0:	58 1c       	cp.w	r12,1
800043a2:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
800043a6:	fb fc 00 00 	ld.weq	r12,sp[0x0]
	}
	else
	{
		return NULL;
	}
}
800043aa:	2f fd       	sub	sp,-4
800043ac:	d8 02       	popm	pc
800043ae:	00 00       	add	r0,r0
800043b0:	80 00       	ld.sh	r0,r0[0x0]
800043b2:	91 44       	st.w	r8[0x10],r4

800043b4 <phy_init>:
    register_rx_tx_func -- ssc.c
	xQueueCreate -- freertos
Called By: xnl_init -- xnl.c
*/
void phy_init( void )
{
800043b4:	eb cd 40 e0 	pushm	r5-r7,lr
    /*initialize the SSC*/
    ssc_init();
800043b8:	f0 1f 00 21 	mcall	8000443c <phy_init+0x88>

    /*register the func to send/receive ssc packet*/
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
800043bc:	4a 1b       	lddpc	r11,80004440 <phy_init+0x8c>
800043be:	4a 2c       	lddpc	r12,80004444 <phy_init+0x90>
800043c0:	f0 1f 00 22 	mcall	80004448 <phy_init+0x94>
	
	/*if enable send/receive payload(media), defined in physical.h*/	
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
800043c4:	30 4b       	mov	r11,4
800043c6:	31 ec       	mov	r12,30
800043c8:	f0 1f 00 21 	mcall	8000444c <phy_init+0x98>
800043cc:	4a 18       	lddpc	r8,80004450 <phy_init+0x9c>
800043ce:	91 0c       	st.w	r8[0x0],r12
800043d0:	30 07       	mov	r7,0
	phy_fragment_t * xnl_ptr = NULL;
	for(int i= 0; i < MAX_XNL_STORE; i++ )
	{
		set_xnl_idle(&xnl_store[i]);
800043d2:	10 96       	mov	r6,r8
800043d4:	4a 05       	lddpc	r5,80004454 <phy_init+0xa0>
800043d6:	6c 0c       	ld.w	r12,r6[0x0]
800043d8:	ea 07 00 0b 	add	r11,r5,r7
800043dc:	f0 1f 00 1f 	mcall	80004458 <phy_init+0xa4>
800043e0:	ee c7 ff 00 	sub	r7,r7,-256
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
	
	/*if enable send/receive payload(media), defined in physical.h*/	
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
	phy_fragment_t * xnl_ptr = NULL;
	for(int i= 0; i < MAX_XNL_STORE; i++ )
800043e4:	e0 47 1e 00 	cp.w	r7,7680
800043e8:	cf 71       	brne	800043d6 <phy_init+0x22>
	{
		set_xnl_idle(&xnl_store[i]);
	}
		
    /*initialize the queue to send/receive xnl packet */	
    phy_xnl_frame_tx = xQueueCreate(TX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
800043ea:	30 4b       	mov	r11,4
800043ec:	31 4c       	mov	r12,20
800043ee:	f0 1f 00 18 	mcall	8000444c <phy_init+0x98>
800043f2:	49 b8       	lddpc	r8,8000445c <phy_init+0xa8>
800043f4:	91 0c       	st.w	r8[0x0],r12
    phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
800043f6:	30 4b       	mov	r11,4
800043f8:	30 ac       	mov	r12,10
800043fa:	f0 1f 00 15 	mcall	8000444c <phy_init+0x98>
800043fe:	49 98       	lddpc	r8,80004460 <phy_init+0xac>
80004400:	91 0c       	st.w	r8[0x0],r12
	
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
80004402:	30 4b       	mov	r11,4
80004404:	30 ac       	mov	r12,10
80004406:	f0 1f 00 12 	mcall	8000444c <phy_init+0x98>
8000440a:	49 78       	lddpc	r8,80004464 <phy_init+0xb0>
8000440c:	91 0c       	st.w	r8[0x0],r12
8000440e:	30 07       	mov	r7,0
	U8 * payload_ptr = NULL;
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
	{
		set_payload_idle(payload_store[i]);
80004410:	10 96       	mov	r6,r8
80004412:	49 65       	lddpc	r5,80004468 <phy_init+0xb4>
80004414:	6c 0c       	ld.w	r12,r6[0x0]
80004416:	ea 07 00 0b 	add	r11,r5,r7
8000441a:	f0 1f 00 10 	mcall	80004458 <phy_init+0xa4>
8000441e:	ee c7 fe 00 	sub	r7,r7,-512
    phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
	
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
	U8 * payload_ptr = NULL;
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
80004422:	e0 47 14 00 	cp.w	r7,5120
80004426:	cf 71       	brne	80004414 <phy_init+0x60>
		set_payload_idle(payload_store[i]);
	}
		
	/*initialize the queue to send/receive xnl packet */
	phy_payload_frame_tx =
	xQueueCreate(TX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t));
80004428:	e0 6b 01 00 	mov	r11,256
8000442c:	30 5c       	mov	r12,5
8000442e:	f0 1f 00 08 	mcall	8000444c <phy_init+0x98>
	{
		set_payload_idle(payload_store[i]);
	}
		
	/*initialize the queue to send/receive xnl packet */
	phy_payload_frame_tx =
80004432:	48 f8       	lddpc	r8,8000446c <phy_init+0xb8>
80004434:	91 0c       	st.w	r8[0x0],r12
		
	//phy_payload_frame_rx =
	//xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
	#endif /*end if*/
	
}
80004436:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000443a:	00 00       	add	r0,r0
8000443c:	80 00       	ld.sh	r0,r0[0x0]
8000443e:	50 74       	stdsp	sp[0x1c],r4
80004440:	80 00       	ld.sh	r0,r0[0x0]
80004442:	3d d0       	mov	r0,-35
80004444:	80 00       	ld.sh	r0,r0[0x0]
80004446:	44 d0       	lddsp	r0,sp[0x134]
80004448:	80 00       	ld.sh	r0,r0[0x0]
8000444a:	50 60       	stdsp	sp[0x18],r0
8000444c:	80 00       	ld.sh	r0,r0[0x0]
8000444e:	94 a8       	ld.uh	r8,r10[0x4]
80004450:	00 00       	add	r0,r0
80004452:	10 38       	cp.w	r8,r8
80004454:	00 00       	add	r0,r0
80004456:	28 50       	sub	r0,-123
80004458:	80 00       	ld.sh	r0,r0[0x0]
8000445a:	3d 2c       	mov	r12,-46
8000445c:	00 00       	add	r0,r0
8000445e:	10 60       	and	r0,r8
80004460:	00 00       	add	r0,r0
80004462:	10 4c       	or	r12,r8
80004464:	00 00       	add	r0,r0
80004466:	10 28       	rsub	r8,r8
80004468:	00 00       	add	r0,r0
8000446a:	14 50       	eor	r0,r10
8000446c:	00 00       	add	r0,r0
8000446e:	10 44       	or	r4,r8

80004470 <payload_rx>:




static void payload_rx(void * payload)
{
80004470:	d4 01       	pushm	lr
80004472:	20 2d       	sub	sp,8
80004474:	50 0c       	stdsp	sp[0x0],r12
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80004476:	30 08       	mov	r8,0
80004478:	50 18       	stdsp	sp[0x4],r8
	
	//set_payload_idle(payload);
	if(NULL == phy_payload_frame_rx)
8000447a:	48 f8       	lddpc	r8,800044b4 <payload_rx+0x44>
8000447c:	70 08       	ld.w	r8,r8[0x0]
8000447e:	58 08       	cp.w	r8,0
80004480:	c0 71       	brne	8000448e <payload_rx+0x1e>
	{
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));		
80004482:	30 4b       	mov	r11,4
80004484:	30 5c       	mov	r12,5
80004486:	f0 1f 00 0d 	mcall	800044b8 <payload_rx+0x48>
8000448a:	48 b8       	lddpc	r8,800044b4 <payload_rx+0x44>
8000448c:	91 0c       	st.w	r8[0x0],r12
	}

	if(errQUEUE_FULL == xQueueSendFromISR(phy_payload_frame_rx, &payload, &xHigherPriorityTaskWoken))
8000448e:	48 a8       	lddpc	r8,800044b4 <payload_rx+0x44>
80004490:	70 0c       	ld.w	r12,r8[0x0]
80004492:	30 09       	mov	r9,0
80004494:	fa ca ff fc 	sub	r10,sp,-4
80004498:	1a 9b       	mov	r11,sp
8000449a:	f0 1f 00 09 	mcall	800044bc <payload_rx+0x4c>
8000449e:	c0 91       	brne	800044b0 <payload_rx+0x40>
	//if(errQUEUE_FULL == xQueueSend(phy_payload_frame_rx, &payload, 0))
	{	//To payload_rx_process();	
		
		set_payload_idle_isr(payload);
800044a0:	48 88       	lddpc	r8,800044c0 <payload_rx+0x50>
800044a2:	70 0c       	ld.w	r12,r8[0x0]
800044a4:	40 0b       	lddsp	r11,sp[0x0]
800044a6:	f0 1f 00 08 	mcall	800044c4 <payload_rx+0x54>
		logFromISR("mm");
800044aa:	48 8c       	lddpc	r12,800044c8 <payload_rx+0x58>
800044ac:	f0 1f 00 08 	mcall	800044cc <payload_rx+0x5c>
			
		}
		//set_payload_idle_isr(payload);
		//logFromISR("ss");
	}
}
800044b0:	2f ed       	sub	sp,-8
800044b2:	d8 02       	popm	pc
800044b4:	00 00       	add	r0,r0
800044b6:	10 0c       	add	r12,r8
800044b8:	80 00       	ld.sh	r0,r0[0x0]
800044ba:	94 a8       	ld.uh	r8,r10[0x4]
800044bc:	80 00       	ld.sh	r0,r0[0x0]
800044be:	93 00       	st.w	r9[0x0],r0
800044c0:	00 00       	add	r0,r0
800044c2:	10 28       	rsub	r8,r8
800044c4:	80 00       	ld.sh	r0,r0[0x0]
800044c6:	3c d8       	mov	r8,-51
800044c8:	80 01       	ld.sh	r1,r0[0x0]
800044ca:	8e 70       	ld.sh	r0,r7[0xe]
800044cc:	80 00       	ld.sh	r0,r0[0x0]
800044ce:	a0 cc       	st.b	r0[0x4],r12

800044d0 <phy_rx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_rx_func( void * ssc)
{    
800044d0:	eb cd 40 e0 	pushm	r5-r7,lr
800044d4:	18 97       	mov	r7,r12
		
	if(NULL != phy_xnl_frame_rx)
800044d6:	fe f8 09 de 	ld.w	r8,pc[2526]
800044da:	70 08       	ld.w	r8,r8[0x0]
800044dc:	58 08       	cp.w	r8,0
800044de:	e0 80 01 05 	breq	800046e8 <phy_rx_func+0x218>
	static U16 phy_check_sum = 0;

	static phy_rx_state_t  phy_rx_state = WAITING_FOR_HEADER;
	static U32 phy_rx_count = 0;

	U32 phy_dword = xnl_rx_channel->dword;	
800044e2:	78 16       	ld.w	r6,r12[0x4]

	phy_rx_count++;
800044e4:	fe f8 09 d4 	ld.w	r8,pc[2516]
800044e8:	70 09       	ld.w	r9,r8[0x0]
800044ea:	2f f9       	sub	r9,-1
800044ec:	91 09       	st.w	r8[0x0],r9
	
	/*This is the code for parsing the incoming physical message.*/
	switch (phy_rx_state)
800044ee:	fe f8 09 ce 	ld.w	r8,pc[2510]
800044f2:	70 08       	ld.w	r8,r8[0x0]
800044f4:	58 18       	cp.w	r8,1
800044f6:	e0 80 00 84 	breq	800045fe <phy_rx_func+0x12e>
800044fa:	c0 73       	brcs	80004508 <phy_rx_func+0x38>
800044fc:	58 28       	cp.w	r8,2
800044fe:	c5 b0       	breq	800045b4 <phy_rx_func+0xe4>
80004500:	58 38       	cp.w	r8,3
80004502:	e0 81 00 f3 	brne	800046e8 <phy_rx_func+0x218>
80004506:	cd 38       	rjmp	800046ac <phy_rx_func+0x1dc>

        /*Waiting for something. Most frequent visit.*/		
		case WAITING_FOR_HEADER:
		
			/*Ignore Idles.*/
			if (0xABCD5A5A == phy_dword)
80004508:	e0 6a 5a 5a 	mov	r10,23130
8000450c:	ea 1a ab cd 	orh	r10,0xabcd
80004510:	14 36       	cp.w	r6,r10
80004512:	e0 80 00 eb 	breq	800046e8 <phy_rx_func+0x218>
			{
				break;
			}	

			/*Skip until Header.*/		
			if (0xABCD != (phy_dword >> 16))
80004516:	ec 08 16 10 	lsr	r8,r6,0x10
8000451a:	e0 48 ab cd 	cp.w	r8,43981
8000451e:	e0 81 00 e5 	brne	800046e8 <phy_rx_func+0x218>
			{			
				break;
			}
		
			/*Length excluding CSUM.*/
			phy_rx_expexted_length = (phy_dword & 0x000000FF) - 2;
80004522:	eb d6 b0 10 	bfexts	r5,r6,0x0,0x10
80004526:	f1 d5 c0 08 	bfextu	r8,r5,0x0,0x8
8000452a:	20 28       	sub	r8,2
8000452c:	fe f9 09 94 	ld.w	r9,pc[2452]
80004530:	b2 08       	st.h	r9[0x0],r8
			
			/*Discard degenerate message.*/
			if (phy_rx_expexted_length <= 0)
80004532:	30 09       	mov	r9,0
80004534:	f2 08 19 00 	cp.h	r8,r9
80004538:	e0 8a 00 d8 	brle	800046e8 <phy_rx_func+0x218>
			{
				break;
			}
		
			phy_rx_length = 0;
8000453c:	fe f8 09 88 	ld.w	r8,pc[2440]
80004540:	b0 09       	st.h	r8[0x0],r9
			
			//get_xnl_idle_isr(&phy_frame_ptr, &xHigherPriorityTaskWoken);
			phy_frame_ptr = get_xnl_idle_isr();
80004542:	fe f8 09 86 	ld.w	r8,pc[2438]
80004546:	70 0c       	ld.w	r12,r8[0x0]
80004548:	f0 1f 02 61 	mcall	80004ecc <phy_rx_func+0x9fc>
8000454c:	fe f8 09 84 	ld.w	r8,pc[2436]
80004550:	91 0c       	st.w	r8[0x0],r12
			if(NULL == phy_frame_ptr)
80004552:	58 0c       	cp.w	r12,0
80004554:	e0 80 00 ca 	breq	800046e8 <phy_rx_func+0x218>
			//
			//xQueueReceiveFromISR(phy_store_idle, &phy_frame_ptr, &xHigherPriorityTaskWoken);
			
			//phy_frame_ptr = pvPortMalloc(sizeof(phy_fragment_t));
					
			phy_frame_ptr->fragment_element[phy_rx_length++] = phy_dword;
80004558:	fe f8 09 6c 	ld.w	r8,pc[2412]
8000455c:	90 09       	ld.sh	r9,r8[0x0]
8000455e:	f8 09 0a 15 	st.h	r12[r9<<0x1],r5
80004562:	2f f9       	sub	r9,-1
80004564:	5c 89       	casts.h	r9
			
			/*time stamp*/
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
80004566:	fe fa 09 6a 	ld.w	r10,pc[2410]
8000456a:	74 0a       	ld.w	r10,r10[0x0]
8000456c:	fe fb 09 4c 	ld.w	r11,pc[2380]
80004570:	76 0b       	ld.w	r11,r11[0x0]
80004572:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
80004576:	2f f9       	sub	r9,-1
80004578:	b0 09       	st.h	r8[0x0],r9
													(phy_rx_count) & 0x0000FFFF;
			
			/*This switch tests the fragment type, and adjusts receiver state
			accordingly.*/
			/*Check frag type*/
			switch (phy_dword & 0x00000F00)
8000457a:	e2 16 0f 00 	andl	r6,0xf00,COH
8000457e:	e0 46 01 00 	cp.w	r6,256
80004582:	c0 c0       	breq	8000459a <phy_rx_func+0xca>
80004584:	e0 8b 00 05 	brhi	8000458e <phy_rx_func+0xbe>
80004588:	58 06       	cp.w	r6,0
8000458a:	c0 80       	breq	8000459a <phy_rx_func+0xca>
8000458c:	c0 c8       	rjmp	800045a4 <phy_rx_func+0xd4>
8000458e:	e0 46 02 00 	cp.w	r6,512
80004592:	c0 40       	breq	8000459a <phy_rx_func+0xca>
80004594:	e0 46 03 00 	cp.w	r6,768
80004598:	c0 61       	brne	800045a4 <phy_rx_func+0xd4>
			{
				case SINGLE_FRAGMENT:  //Only Fragment.
				case FIRST_FRAGMENT:   //First of Multi-fragment.
				case MIDDLE_FRAGMENT:  //Continuing Multi-fragment.
				case LAST_FRAGMENT:    //Last Multi-fragment.
					phy_rx_state = WAITING_CHECK_SUM;
8000459a:	30 29       	mov	r9,2
8000459c:	fe f8 09 20 	ld.w	r8,pc[2336]
800045a0:	91 09       	st.w	r8[0x0],r9
800045a2:	ca 38       	rjmp	800046e8 <phy_rx_func+0x218>
				break;
				default:
					vPortFree(phy_frame_ptr);
800045a4:	fe f6 09 2c 	ld.w	r6,pc[2348]
800045a8:	6c 0c       	ld.w	r12,r6[0x0]
800045aa:	f0 1f 02 4b 	mcall	80004ed4 <phy_rx_func+0xa04>
					phy_frame_ptr = NULL;					
800045ae:	30 08       	mov	r8,0
800045b0:	8d 08       	st.w	r6[0x0],r8
800045b2:	c9 b8       	rjmp	800046e8 <phy_rx_func+0x218>
		
			/*Stores CSUM*/
			phy_check_sum  = (phy_dword & 0xFFFF0000) >> 16;
			
			/*sums in first hWord*/
			phy_check_sum += (phy_dword & 0x0000FFFF);		
800045b4:	f5 d6 b0 10 	bfexts	r10,r6,0x0,0x10
800045b8:	b1 86       	lsr	r6,0x10
800045ba:	14 06       	add	r6,r10
800045bc:	fe f8 09 1c 	ld.w	r8,pc[2332]
800045c0:	b0 06       	st.h	r8[0x0],r6
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
800045c2:	fe f8 09 02 	ld.w	r8,pc[2306]
800045c6:	90 09       	ld.sh	r9,r8[0x0]
800045c8:	fe fb 09 08 	ld.w	r11,pc[2312]
800045cc:	76 0b       	ld.w	r11,r11[0x0]
800045ce:	f6 09 0a 1a 	st.h	r11[r9<<0x1],r10
800045d2:	2f f9       	sub	r9,-1
800045d4:	b0 09       	st.h	r8[0x0],r9
														 phy_dword & 0x0000FFFF;
					
			phy_rx_expexted_length -= 2;
800045d6:	fe f9 08 ea 	ld.w	r9,pc[2282]
800045da:	92 08       	ld.sh	r8,r9[0x0]
800045dc:	20 28       	sub	r8,2
800045de:	b2 08       	st.h	r9[0x0],r8
			
			/*Normal case for greater than one byte payloads.*/
			if (phy_rx_expexted_length > 0)
800045e0:	30 09       	mov	r9,0
800045e2:	f2 08 19 00 	cp.h	r8,r9
800045e6:	e0 8a 00 07 	brle	800045f4 <phy_rx_func+0x124>
			{					  
				phy_rx_state = READING_FRAGMENT;
800045ea:	30 19       	mov	r9,1
800045ec:	fe f8 08 d0 	ld.w	r8,pc[2256]
800045f0:	91 09       	st.w	r8[0x0],r9
800045f2:	c7 b8       	rjmp	800046e8 <phy_rx_func+0x218>
	    		Note that all segments must align with a 32-bit boundary and
				beginning of each XCMP/XNL payload frame must start on slot 3
				Thus, segments of odd length must append a 0x0000 at the end
				(slot 4) to ensure alignment. [9.1.3]
				*/
				phy_rx_state = WAITING_LAST_TERM;
800045f4:	30 39       	mov	r9,3
800045f6:	fe f8 08 c6 	ld.w	r8,pc[2246]
800045fa:	91 09       	st.w	r8[0x0],r9
800045fc:	c7 68       	rjmp	800046e8 <phy_rx_func+0x218>
			}			
		
			break;

		case READING_FRAGMENT:
			phy_check_sum += (phy_dword & 0xFFFF0000) >> 16;
800045fe:	ec 0a 14 10 	asr	r10,r6,0x10
80004602:	fe f8 08 d6 	ld.w	r8,pc[2262]
80004606:	90 09       	ld.sh	r9,r8[0x0]
80004608:	14 09       	add	r9,r10
8000460a:	b0 09       	st.h	r8[0x0],r9
	
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
8000460c:	fe f9 08 b8 	ld.w	r9,pc[2232]
80004610:	92 08       	ld.sh	r8,r9[0x0]
80004612:	fe fb 08 be 	ld.w	r11,pc[2238]
80004616:	76 0b       	ld.w	r11,r11[0x0]
80004618:	f6 08 0a 1a 	st.h	r11[r8<<0x1],r10
8000461c:	2f f8       	sub	r8,-1
8000461e:	5c 88       	casts.h	r8
80004620:	b2 08       	st.h	r9[0x0],r8
												 (phy_dword & 0xFFFF0000) >> 16;
	
			phy_rx_expexted_length -= 2;
80004622:	fe fa 08 9e 	ld.w	r10,pc[2206]
80004626:	94 09       	ld.sh	r9,r10[0x0]
80004628:	20 29       	sub	r9,2
8000462a:	b4 09       	st.h	r10[0x0],r9
			if (phy_rx_expexted_length <= 0)
8000462c:	30 0a       	mov	r10,0
8000462e:	f4 09 19 00 	cp.h	r9,r10
80004632:	e0 89 00 1f 	brgt	80004670 <phy_rx_func+0x1a0>
				Terminator should be in 2nd hWord.
				Shaoqun says useful bits not used. The packet will always end
				with $00BA. [9.1.2.8]	
				*/
				
				if ((0x000000BA == (phy_dword  & 0x0000FFFF)) 
80004636:	ed d6 c0 10 	bfextu	r6,r6,0x0,0x10
8000463a:	e0 46 00 ba 	cp.w	r6,186
8000463e:	c0 d1       	brne	80004658 <phy_rx_func+0x188>
80004640:	fe f8 08 98 	ld.w	r8,pc[2200]
80004644:	90 09       	ld.sh	r9,r8[0x0]
80004646:	f4 09 19 00 	cp.h	r9,r10
8000464a:	c0 71       	brne	80004658 <phy_rx_func+0x188>
					&& (phy_check_sum == 0))
				{
					phy_rx(phy_frame_ptr);
8000464c:	fe f8 08 84 	ld.w	r8,pc[2180]
80004650:	70 0c       	ld.w	r12,r8[0x0]
80004652:	f0 1f 02 23 	mcall	80004edc <phy_rx_func+0xa0c>
80004656:	c0 88       	rjmp	80004666 <phy_rx_func+0x196>
				}
				else
				{
					vPortFree(phy_frame_ptr);
80004658:	fe f6 08 78 	ld.w	r6,pc[2168]
8000465c:	6c 0c       	ld.w	r12,r6[0x0]
8000465e:	f0 1f 02 1e 	mcall	80004ed4 <phy_rx_func+0xa04>
					phy_frame_ptr = NULL;
80004662:	30 08       	mov	r8,0
80004664:	8d 08       	st.w	r6[0x0],r8
				}

				phy_rx_state = WAITING_FOR_HEADER;
80004666:	30 09       	mov	r9,0
80004668:	fe f8 08 54 	ld.w	r8,pc[2132]
8000466c:	91 09       	st.w	r8[0x0],r9
8000466e:	c3 d8       	rjmp	800046e8 <phy_rx_func+0x218>
				break;
			}
		
			/*Have not broken. 2nd hWord contains payload.*/
			phy_check_sum += (phy_dword & 0x0000FFFF);
80004670:	5c 86       	casts.h	r6
80004672:	fe f9 08 66 	ld.w	r9,pc[2150]
80004676:	92 0a       	ld.sh	r10,r9[0x0]
80004678:	0c 0a       	add	r10,r6
8000467a:	b2 0a       	st.h	r9[0x0],r10
		
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
8000467c:	fe f9 08 54 	ld.w	r9,pc[2132]
80004680:	72 09       	ld.w	r9,r9[0x0]
80004682:	f2 08 0a 16 	st.h	r9[r8<<0x1],r6
80004686:	2f f8       	sub	r8,-1
80004688:	fe f9 08 3c 	ld.w	r9,pc[2108]
8000468c:	b2 08       	st.h	r9[0x0],r8
													   (phy_dword & 0x0000FFFF);
		
			phy_rx_expexted_length -= 2;
8000468e:	fe f9 08 32 	ld.w	r9,pc[2098]
80004692:	92 08       	ld.sh	r8,r9[0x0]
80004694:	20 28       	sub	r8,2
80004696:	b2 08       	st.h	r9[0x0],r8
			if (phy_rx_expexted_length <= 0)
80004698:	30 09       	mov	r9,0
8000469a:	f2 08 19 00 	cp.h	r8,r9
8000469e:	e0 89 00 25 	brgt	800046e8 <phy_rx_func+0x218>
			{
				/*All read in. Next Word should be 0x00BA0000.*/
				phy_rx_state = WAITING_LAST_TERM;
800046a2:	30 39       	mov	r9,3
800046a4:	fe f8 08 18 	ld.w	r8,pc[2072]
800046a8:	91 09       	st.w	r8[0x0],r9
800046aa:	c1 f8       	rjmp	800046e8 <phy_rx_func+0x218>
			}/*else, next Word contains more payload.*/
			break;

		/*Expecting last terminator 0x00BA0000.*/	
		case WAITING_LAST_TERM:			
			if ((0x00BA0000 == (phy_dword  & 0x00FF0000)) /*Expected found.*/
800046ac:	e6 16 00 ff 	andh	r6,0xff,COH
800046b0:	fc 19 00 ba 	movh	r9,0xba
800046b4:	12 36       	cp.w	r6,r9
800046b6:	c0 e1       	brne	800046d2 <phy_rx_func+0x202>
800046b8:	fe f8 08 20 	ld.w	r8,pc[2080]
800046bc:	90 09       	ld.sh	r9,r8[0x0]
800046be:	30 08       	mov	r8,0
800046c0:	f0 09 19 00 	cp.h	r9,r8
800046c4:	c0 71       	brne	800046d2 <phy_rx_func+0x202>
				&& (phy_check_sum == 0))/*Good checksum*/
			{
				phy_rx(phy_frame_ptr);
800046c6:	fe f8 08 0a 	ld.w	r8,pc[2058]
800046ca:	70 0c       	ld.w	r12,r8[0x0]
800046cc:	f0 1f 02 04 	mcall	80004edc <phy_rx_func+0xa0c>
800046d0:	c0 88       	rjmp	800046e0 <phy_rx_func+0x210>

			}
			else
			{
				vPortFree(phy_frame_ptr);
800046d2:	fe f6 07 fe 	ld.w	r6,pc[2046]
800046d6:	6c 0c       	ld.w	r12,r6[0x0]
800046d8:	f0 1f 01 ff 	mcall	80004ed4 <phy_rx_func+0xa04>
				phy_frame_ptr = NULL;
800046dc:	30 08       	mov	r8,0
800046de:	8d 08       	st.w	r6[0x0],r8
			}
				
			phy_rx_state = WAITING_FOR_HEADER;
800046e0:	30 09       	mov	r9,0
800046e2:	fe f8 07 da 	ld.w	r8,pc[2010]
800046e6:	91 09       	st.w	r8[0x0],r9
			
	//payload_ptr_t *AMBE_payload_ptr;		
				
	
	
	if(is_first == FALSE)
800046e8:	fe f8 07 f8 	ld.w	r8,pc[2040]
800046ec:	11 89       	ld.ub	r9,r8[0x0]
800046ee:	30 08       	mov	r8,0
800046f0:	f0 09 18 00 	cp.b	r9,r8
800046f4:	c1 31       	brne	8000471a <phy_rx_func+0x24a>
	{
		payload_ptr = get_payload_idle_isr();
800046f6:	fe f6 07 ee 	ld.w	r6,pc[2030]
800046fa:	6c 0c       	ld.w	r12,r6[0x0]
800046fc:	f0 1f 01 f4 	mcall	80004ecc <phy_rx_func+0x9fc>
80004700:	fe f8 07 e8 	ld.w	r8,pc[2024]
80004704:	91 0c       	st.w	r8[0x0],r12
		AMBE_payload_ptr = get_payload_idle_isr();
80004706:	6c 0c       	ld.w	r12,r6[0x0]
80004708:	f0 1f 01 f1 	mcall	80004ecc <phy_rx_func+0x9fc>
8000470c:	fe f8 07 e0 	ld.w	r8,pc[2016]
80004710:	91 0c       	st.w	r8[0x0],r12
		is_first = TRUE;
80004712:	30 19       	mov	r9,1
80004714:	fe f8 07 cc 	ld.w	r8,pc[1996]
80004718:	b0 89       	st.b	r8[0x0],r9
	}	
	
	//This is the RxMedia Phy Handler.
	switch (RxMediaState)
8000471a:	fe f8 07 d6 	ld.w	r8,pc[2006]
8000471e:	70 08       	ld.w	r8,r8[0x0]
80004720:	58 28       	cp.w	r8,2
80004722:	e0 80 01 72 	breq	80004a06 <phy_rx_func+0x536>
80004726:	58 38       	cp.w	r8,3
80004728:	e0 80 02 30 	breq	80004b88 <phy_rx_func+0x6b8>
8000472c:	58 08       	cp.w	r8,0
8000472e:	e0 81 03 c0 	brne	80004eae <phy_rx_func+0x9de>
	{
		case WAITINGABAB:

			
			if (payload_rx_channel->dword[0] == 0xABCD5A5A)//Ignore Idles.
80004732:	6e 28       	ld.w	r8,r7[0x8]
80004734:	e0 6a 5a 5a 	mov	r10,23130
80004738:	ea 1a ab cd 	orh	r10,0xabcd
8000473c:	14 38       	cp.w	r8,r10
8000473e:	c0 71       	brne	8000474c <phy_rx_func+0x27c>
			{
				m_RxBurstType = VOICE_WATING;
80004740:	30 09       	mov	r9,0
80004742:	fe f8 07 b2 	ld.w	r8,pc[1970]
80004746:	91 09       	st.w	r8[0x0],r9
80004748:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
				//Upon receiving the idle frame, the m Rx Burst Type into an idle state in order to transmit the synchronization wait
				 break; 
			}
            
			if ((payload_rx_channel->dword[0]  & 0xFFFF0000) != 0xABCD0000)break; //Skip until Header. 
8000474c:	10 99       	mov	r9,r8
8000474e:	e0 19 00 00 	andl	r9,0x0
80004752:	fc 1a ab cd 	movh	r10,0xabcd
80004756:	14 39       	cp.w	r9,r10
80004758:	e0 81 03 ab 	brne	80004eae <phy_rx_func+0x9de>
			}
			//logFromISR("\n\r P: %X \n\r", payload_rx_channel->word[1]);//
			
			#endif
			
			RxBytesWaiting = payload_rx_channel->dword[0] & 0x000000FF;
8000475c:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
80004760:	fe f9 07 98 	ld.w	r9,pc[1944]
80004764:	93 08       	st.w	r9[0x0],r8
		
			if((NULL== payload_ptr) || (NULL== AMBE_payload_ptr))
80004766:	fe f8 07 82 	ld.w	r8,pc[1922]
8000476a:	70 08       	ld.w	r8,r8[0x0]
8000476c:	58 08       	cp.w	r8,0
8000476e:	c0 60       	breq	8000477a <phy_rx_func+0x2aa>
80004770:	fe f8 07 7c 	ld.w	r8,pc[1916]
80004774:	70 08       	ld.w	r8,r8[0x0]
80004776:	58 08       	cp.w	r8,0
80004778:	c1 61       	brne	800047a4 <phy_rx_func+0x2d4>
			{
				payload_ptr = get_payload_idle_isr();
8000477a:	fe f6 07 6a 	ld.w	r6,pc[1898]
8000477e:	6c 0c       	ld.w	r12,r6[0x0]
80004780:	f0 1f 01 d3 	mcall	80004ecc <phy_rx_func+0x9fc>
80004784:	fe f5 07 64 	ld.w	r5,pc[1892]
80004788:	8b 0c       	st.w	r5[0x0],r12
				AMBE_payload_ptr = get_payload_idle_isr();
8000478a:	6c 0c       	ld.w	r12,r6[0x0]
8000478c:	f0 1f 01 d0 	mcall	80004ecc <phy_rx_func+0x9fc>
80004790:	fe f8 07 5c 	ld.w	r8,pc[1884]
80004794:	91 0c       	st.w	r8[0x0],r12
				
				if((NULL== payload_ptr) || (NULL== AMBE_payload_ptr))
80004796:	6a 08       	ld.w	r8,r5[0x0]
80004798:	58 08       	cp.w	r8,0
8000479a:	e0 80 03 8a 	breq	80004eae <phy_rx_func+0x9de>
8000479e:	58 0c       	cp.w	r12,0
800047a0:	e0 80 03 87 	breq	80004eae <phy_rx_func+0x9de>
			}
			
		
			/****Note AMBE stream protocol frame structure and the PCM frame structure is different*****/
					
			if ((payload_rx_channel->dword[0] & 0x0000F000 ) == PAYLOAD_DATA_ENH )//PAYLOAD_DATA_ENH (0x0c))
800047a4:	6e 28       	ld.w	r8,r7[0x8]
800047a6:	e2 18 f0 00 	andl	r8,0xf000,COH
800047aa:	e0 48 c0 00 	cp.w	r8,49152
800047ae:	e0 81 00 99 	brne	800048e0 <phy_rx_func+0x410>
			{
				AMBE_flag = 1;
800047b2:	30 19       	mov	r9,1
800047b4:	fe f8 07 48 	ld.w	r8,pc[1864]
800047b8:	b0 89       	st.b	r8[0x0],r9
								
				Item_ID = payload_rx_channel->byte[5];
800047ba:	ef 39 00 0d 	ld.ub	r9,r7[13]
800047be:	fe f8 07 42 	ld.w	r8,pc[1858]
800047c2:	b0 89       	st.b	r8[0x0],r9
				
				VF_SN = payload_rx_channel->byte[7];//This parameter is very important to the loop back Radio, as a reference.
800047c4:	ef 3c 00 0f 	ld.ub	r12,r7[15]
800047c8:	fe f9 07 3c 	ld.w	r9,pc[1852]
800047cc:	b2 8c       	st.b	r9[0x0],r12
					
				//The OB know the Call begin and discard the Voice Header
				//The OB know the Call end and discard the Voice  Terminator			
				if (Item_ID == Raw_Tx_Data_HT)
800047ce:	11 89       	ld.ub	r9,r8[0x0]
800047d0:	3f 08       	mov	r8,-16
800047d2:	f0 09 18 00 	cp.b	r9,r8
800047d6:	c3 61       	brne	80004842 <phy_rx_func+0x372>
				{
					//HT_index = 0;
					//AMBE_HT[0] = payload_rx_channel->dword[0];
					//AMBE_HT[1] = payload_rx_channel->dword[1];
					//
					if ((payload_rx_channel->byte[6] & 0xF0 )== 0x10)//header
800047d8:	ef 38 00 0e 	ld.ub	r8,r7[14]
800047dc:	e2 18 00 f0 	andl	r8,0xf0,COH
800047e0:	59 08       	cp.w	r8,16
800047e2:	c0 71       	brne	800047f0 <phy_rx_func+0x320>
					{
						m_RxBurstType = VOICEHEADER;		
800047e4:	30 19       	mov	r9,1
800047e6:	fe f8 07 0e 	ld.w	r8,pc[1806]
800047ea:	91 09       	st.w	r8[0x0],r9
800047ec:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

					}
					else if ((payload_rx_channel->byte[6] & 0xF0) == 0x20)//Terminator
800047f0:	e0 48 00 20 	cp.w	r8,32
800047f4:	c2 11       	brne	80004836 <phy_rx_func+0x366>
					{
						m_RxBurstType = VOICETERMINATOR;
800047f6:	30 99       	mov	r9,9
800047f8:	fe f8 06 fc 	ld.w	r8,pc[1788]
800047fc:	91 09       	st.w	r8[0x0],r9
						//AMBE-data and PCM-data is not the same. AMBE is compressed data,
						//if there was a missing portion, a clear voice is difficult to extract the data. 
						//It must ensure that all the data received AMBE.
						
						//0
						memset((AMBE_payload_ptr+ (RxAMBE_IsFillingNext8 +1)), 0x00, (512-(RxAMBE_IsFillingNext8 + 1)));
800047fe:	fe f6 07 0a 	ld.w	r6,pc[1802]
80004802:	6c 08       	ld.w	r8,r6[0x0]
80004804:	f0 0a 11 ff 	rsub	r10,r8,-1
80004808:	fe f7 06 e4 	ld.w	r7,pc[1764]
8000480c:	2f f8       	sub	r8,-1
8000480e:	6e 0c       	ld.w	r12,r7[0x0]
80004810:	f4 ca fe 00 	sub	r10,r10,-512
80004814:	30 0b       	mov	r11,0
80004816:	10 0c       	add	r12,r8
80004818:	f0 1f 01 bd 	mcall	80004f0c <phy_rx_func+0xa3c>
						
						RxAMBE_IsFillingNext8 = 0;
8000481c:	30 08       	mov	r8,0
8000481e:	8d 08       	st.w	r6[0x0],r8
						payload_rx(AMBE_payload_ptr);
80004820:	6e 0c       	ld.w	r12,r7[0x0]
80004822:	f0 1f 01 bc 	mcall	80004f10 <phy_rx_func+0xa40>
						AMBE_payload_ptr = get_payload_idle_isr();
80004826:	fe f8 06 be 	ld.w	r8,pc[1726]
8000482a:	70 0c       	ld.w	r12,r8[0x0]
8000482c:	f0 1f 01 a8 	mcall	80004ecc <phy_rx_func+0x9fc>
80004830:	8f 0c       	st.w	r7[0x0],r12
80004832:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						//logFromISR("\n\r QQ1 \n\r");
						
					}
					else//error voice
					{
						m_RxBurstType = VOICE_WATING;
80004836:	30 09       	mov	r9,0
80004838:	fe f8 06 bc 	ld.w	r8,pc[1724]
8000483c:	91 09       	st.w	r8[0x0],r9
8000483e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					
					break;//WAITINGABAB.
		
						
				}
				else if (Item_ID == Vocoder_Bit_Stream_Parameter)//Vocoder Bits Stream Parameter
80004842:	fe f8 06 be 	ld.w	r8,pc[1726]
80004846:	11 89       	ld.ub	r9,r8[0x0]
80004848:	31 28       	mov	r8,18
8000484a:	f0 09 18 00 	cp.b	r9,r8
8000484e:	c0 d1       	brne	80004868 <phy_rx_func+0x398>
				{	
						
						VBSP_data[0] = payload_rx_channel->word[2];
80004850:	8e 69       	ld.sh	r9,r7[0xc]
80004852:	fe f8 06 c2 	ld.w	r8,pc[1730]
80004856:	b0 09       	st.h	r8[0x0],r9
						VBSP_data[1] = payload_rx_channel->word[3];
80004858:	8e 79       	ld.sh	r9,r7[0xe]
8000485a:	b0 19       	st.h	r8[0x2],r9
						m_RxBurstType = CalculateBurst(VF_SN);
8000485c:	f0 1f 01 af 	mcall	80004f18 <phy_rx_func+0xa48>
80004860:	fe f8 06 94 	ld.w	r8,pc[1684]
80004864:	91 0c       	st.w	r8[0x0],r12
80004866:	c3 78       	rjmp	800048d4 <phy_rx_func+0x404>

				}
				else if ((Item_ID == 0x04) || (Item_ID == 0x03) )//Unknown type data directly back hair
80004868:	fe f8 06 98 	ld.w	r8,pc[1688]
8000486c:	11 89       	ld.ub	r9,r8[0x0]
8000486e:	30 48       	mov	r8,4
80004870:	f0 09 18 00 	cp.b	r9,r8
80004874:	c0 80       	breq	80004884 <phy_rx_func+0x3b4>
80004876:	fe f8 06 8a 	ld.w	r8,pc[1674]
8000487a:	11 89       	ld.ub	r9,r8[0x0]
8000487c:	30 38       	mov	r8,3
8000487e:	f0 09 18 00 	cp.b	r9,r8
80004882:	c1 c1       	brne	800048ba <phy_rx_func+0x3ea>
				{
					//break;
					m_RxBurstType = UNSUREDATA;
80004884:	30 29       	mov	r9,2
80004886:	fe f8 06 6e 	ld.w	r8,pc[1646]
8000488a:	91 09       	st.w	r8[0x0],r9
					AMBE_HT[0] = payload_rx_channel->dword[0];
8000488c:	6e 29       	ld.w	r9,r7[0x8]
8000488e:	fe f8 06 8e 	ld.w	r8,pc[1678]
80004892:	91 09       	st.w	r8[0x0],r9
					AMBE_HT[1] = payload_rx_channel->dword[1];
80004894:	6e 39       	ld.w	r9,r7[0xc]
80004896:	91 19       	st.w	r8[0x4],r9
					
					if (RxBytesWaiting == 0x00000014)
80004898:	fe f8 06 60 	ld.w	r8,pc[1632]
8000489c:	70 08       	ld.w	r8,r8[0x0]
8000489e:	59 48       	cp.w	r8,20
800048a0:	c0 61       	brne	800048ac <phy_rx_func+0x3dc>
					{
						RxBytesWaiting = 0x18;//24 Reassigned
800048a2:	31 89       	mov	r9,24
800048a4:	fe f8 06 54 	ld.w	r8,pc[1620]
800048a8:	91 09       	st.w	r8[0x0],r9
800048aa:	c1 58       	rjmp	800048d4 <phy_rx_func+0x404>
						//_flag =0;
							
					}
					if (RxBytesWaiting == 0x00000010)
800048ac:	59 08       	cp.w	r8,16
800048ae:	c1 31       	brne	800048d4 <phy_rx_func+0x404>
					{
						RxBytesWaiting = 0x10;//16 Reassigned
800048b0:	31 09       	mov	r9,16
800048b2:	fe f8 06 46 	ld.w	r8,pc[1606]
800048b6:	91 09       	st.w	r8[0x0],r9
800048b8:	c0 e8       	rjmp	800048d4 <phy_rx_func+0x404>
					
				}
				else
				{
					
					logFromISR("\n\r Item_ID:%x \n\r", payload_rx_channel->word[2]);
800048ba:	8e e8       	ld.uh	r8,r7[0xc]
800048bc:	1a d8       	st.w	--sp,r8
800048be:	fe fc 06 62 	ld.w	r12,pc[1634]
800048c2:	f0 1f 01 99 	mcall	80004f24 <phy_rx_func+0xa54>
					logFromISR("\n\r Axiba \n\r");
800048c6:	fe fc 06 62 	ld.w	r12,pc[1634]
800048ca:	f0 1f 01 97 	mcall	80004f24 <phy_rx_func+0xa54>
800048ce:	2f fd       	sub	sp,-4
800048d0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					//Radio Internal Parameter(0x7F):
					//The OB should use the route back this item to radio without change content.
					break;
				}
				
				RxMediaState = READING_AMBE_MEDIA;//Jump
800048d4:	30 39       	mov	r9,3
800048d6:	fe f8 06 1a 	ld.w	r8,pc[1562]
800048da:	91 09       	st.w	r8[0x0],r9
800048dc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
			else//PCM-media-data
			{	
				//logFromISR("\n\r RX:%x \n\r", payload_rx_channel->dword[0]);
				//SPEAKER_DATA or  //MIC_DATA
				if (((payload_rx_channel->dword[0] & 0x0000F000 ) != SPEAKER_DATA ) 
800048e0:	e0 48 10 00 	cp.w	r8,4096
800048e4:	5f 19       	srne	r9
800048e6:	e0 48 20 00 	cp.w	r8,8192
800048ea:	5f 18       	srne	r8
800048ec:	f3 e8 00 08 	and	r8,r9,r8
800048f0:	e0 81 02 df 	brne	80004eae <phy_rx_func+0x9de>
					&& ((payload_rx_channel->dword[0] & 0x0000F000 ) != MIC_DATA ))break;
				
				AMBE_flag = 0;
800048f4:	fe f9 06 08 	ld.w	r9,pc[1544]
800048f8:	b2 88       	st.b	r9[0x0],r8
				
				Item_ID = 0;//To make sure your save PCM data.
800048fa:	fe f9 06 06 	ld.w	r9,pc[1542]
800048fe:	b2 88       	st.b	r9[0x0],r8
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80004900:	6e 28       	ld.w	r8,r7[0x8]
80004902:	e2 18 0f 00 	andl	r8,0xf00,COH
80004906:	58 18       	cp.w	r8,1
80004908:	e0 8b 00 4d 	brhi	800049a2 <phy_rx_func+0x4d2>
				
				if ((payload_rx_channel->dword[0]  & 0x00000F00) <= 1){  //Flag type must process Array Descriptor.
				//The first word of the media access payload must be the Array descriptor length. And the
				//unit of the length is in word (16-bit). The length field itself does not count into the length.
				//When there is no array descriptor, the length must be set to zero.[9.1.4.1]
				if ((RxBytesWaiting -= 4) <= 0) break;          //Nothing beyond this Phy buffer. Keep looking for Header
8000490c:	fe f9 05 ec 	ld.w	r9,pc[1516]
80004910:	72 08       	ld.w	r8,r9[0x0]
80004912:	20 48       	sub	r8,4
80004914:	93 08       	st.w	r9[0x0],r8
80004916:	e0 80 02 cc 	breq	80004eae <phy_rx_func+0x9de>
				ArrayDiscLength = payload_rx_channel->word[2];
8000491a:	8e 68       	ld.sh	r8,r7[0xc]
8000491c:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
80004920:	fe f9 06 0c 	ld.w	r9,pc[1548]
80004924:	93 0a       	st.w	r9[0x0],r10
				
				switch (ArrayDiscLength){
80004926:	30 09       	mov	r9,0
80004928:	f2 08 19 00 	cp.h	r8,r9
8000492c:	c0 70       	breq	8000493a <phy_rx_func+0x46a>
8000492e:	30 19       	mov	r9,1
80004930:	f2 08 19 00 	cp.h	r8,r9
80004934:	e0 81 02 bd 	brne	80004eae <phy_rx_func+0x9de>
80004938:	c2 68       	rjmp	80004984 <phy_rx_func+0x4b4>
					case 0:          //The usual case. Remaining word in Phy buffer is Audio.
								
						payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
8000493a:	fe f8 05 f6 	ld.w	r8,pc[1526]
8000493e:	70 0a       	ld.w	r10,r8[0x0]
80004940:	fe f9 05 a8 	ld.w	r9,pc[1448]
80004944:	72 09       	ld.w	r9,r9[0x0]
80004946:	8e 7b       	ld.sh	r11,r7[0xe]
80004948:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
						RxMedia_IsFillingNext16 += 1;
8000494c:	70 09       	ld.w	r9,r8[0x0]
8000494e:	2f f9       	sub	r9,-1
80004950:	91 09       	st.w	r8[0x0],r9
						if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80004952:	e0 49 00 ff 	cp.w	r9,255
80004956:	e0 88 00 11 	brls	80004978 <phy_rx_func+0x4a8>
						{
							RxMedia_IsFillingNext16 = 0;	
8000495a:	30 09       	mov	r9,0
8000495c:	91 09       	st.w	r8[0x0],r9
							payload_rx(payload_ptr);	
8000495e:	fe f7 05 8a 	ld.w	r7,pc[1418]
80004962:	6e 0c       	ld.w	r12,r7[0x0]
80004964:	f0 1f 01 6b 	mcall	80004f10 <phy_rx_func+0xa40>
							payload_ptr = get_payload_idle_isr();
80004968:	fe f8 05 7c 	ld.w	r8,pc[1404]
8000496c:	70 0c       	ld.w	r12,r8[0x0]
8000496e:	f0 1f 01 58 	mcall	80004ecc <phy_rx_func+0x9fc>
80004972:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == payload_ptr)
80004974:	e0 80 02 9d 	breq	80004eae <phy_rx_func+0x9de>
							{
								break;
							}				
						}
							RxMediaState = READINGMEDIA;
80004978:	30 29       	mov	r9,2
8000497a:	fe f8 05 76 	ld.w	r8,pc[1398]
8000497e:	91 09       	st.w	r8[0x0],r9
80004980:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80004984:	8e 79       	ld.sh	r9,r7[0xe]
80004986:	30 38       	mov	r8,3
80004988:	f0 09 19 00 	cp.h	r9,r8
8000498c:	c0 51       	brne	80004996 <phy_rx_func+0x4c6>
				
					case 1: //The next usual case.
							//In general case, add code to process single word Array descriptor.
							if (payload_rx_channel->word[3] == 0x0003)//Stream Terminator
							{
								Terminator_Flag = 1;
8000498e:	30 19       	mov	r9,1
80004990:	fe f8 05 a4 	ld.w	r8,pc[1444]
80004994:	b0 89       	st.b	r8[0x0],r9
							{
								//Terminator_Flag = 0;
							}
					
					
							RxMediaState = READINGMEDIA;
80004996:	30 29       	mov	r9,2
80004998:	fe f8 05 58 	ld.w	r8,pc[1368]
8000499c:	91 09       	st.w	r8[0x0],r9
8000499e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
				break;
				}
		
				//Code gets here on Middle or last Fragment. No Array descriptor.
				if (RxBytesWaiting < 2) break;//This shouldn't happen, but must check.
800049a2:	fe f8 05 56 	ld.w	r8,pc[1366]
800049a6:	70 08       	ld.w	r8,r8[0x0]
800049a8:	58 18       	cp.w	r8,1
800049aa:	e0 88 02 82 	brls	80004eae <phy_rx_func+0x9de>
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->dword[1] & 0x0000FFFF;
800049ae:	fe f8 05 82 	ld.w	r8,pc[1410]
800049b2:	70 0a       	ld.w	r10,r8[0x0]
800049b4:	fe f9 05 34 	ld.w	r9,pc[1332]
800049b8:	72 09       	ld.w	r9,r9[0x0]
800049ba:	6e 3b       	ld.w	r11,r7[0xc]
800049bc:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
800049c0:	70 09       	ld.w	r9,r8[0x0]
800049c2:	2f f9       	sub	r9,-1
800049c4:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800049c6:	e0 49 00 ff 	cp.w	r9,255
800049ca:	e0 88 00 11 	brls	800049ec <phy_rx_func+0x51c>
				{
					RxMedia_IsFillingNext16 = 0;
800049ce:	30 09       	mov	r9,0
800049d0:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);
800049d2:	fe f7 05 16 	ld.w	r7,pc[1302]
800049d6:	6e 0c       	ld.w	r12,r7[0x0]
800049d8:	f0 1f 01 4e 	mcall	80004f10 <phy_rx_func+0xa40>
								payload_ptr = get_payload_idle_isr();
800049dc:	fe f8 05 08 	ld.w	r8,pc[1288]
800049e0:	70 0c       	ld.w	r12,r8[0x0]
800049e2:	f0 1f 01 3b 	mcall	80004ecc <phy_rx_func+0x9fc>
800049e6:	8f 0c       	st.w	r7[0x0],r12
													if(NULL == payload_ptr)
800049e8:	e0 80 02 63 	breq	80004eae <phy_rx_func+0x9de>
													{
														break;
													}
				}
				if ((RxBytesWaiting -= 2) <= 0) break;  //This shouldn't happen, but must check;
800049ec:	fe f9 05 0c 	ld.w	r9,pc[1292]
800049f0:	72 08       	ld.w	r8,r9[0x0]
800049f2:	20 28       	sub	r8,2
800049f4:	93 08       	st.w	r9[0x0],r8
800049f6:	e0 80 02 5c 	breq	80004eae <phy_rx_func+0x9de>
				RxMediaState = READINGMEDIA;
800049fa:	30 29       	mov	r9,2
800049fc:	fe f8 04 f4 	ld.w	r8,pc[1268]
80004a00:	91 09       	st.w	r8[0x0],r9
80004a02:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
		case READINGMEDIA:
				
			/***PCM-media-data ****/
			{
				
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[0];
80004a06:	fe f8 05 2a 	ld.w	r8,pc[1322]
80004a0a:	70 0a       	ld.w	r10,r8[0x0]
80004a0c:	fe f9 04 dc 	ld.w	r9,pc[1244]
80004a10:	72 09       	ld.w	r9,r9[0x0]
80004a12:	8e 4b       	ld.sh	r11,r7[0x8]
80004a14:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;	
80004a18:	70 09       	ld.w	r9,r8[0x0]
80004a1a:	2f f9       	sub	r9,-1
80004a1c:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80004a1e:	e0 49 00 ff 	cp.w	r9,255
80004a22:	e0 88 00 16 	brls	80004a4e <phy_rx_func+0x57e>
					{
							RxMedia_IsFillingNext16 = 0;
80004a26:	30 09       	mov	r9,0
80004a28:	91 09       	st.w	r8[0x0],r9
							payload_rx(payload_ptr);
80004a2a:	fe f6 04 be 	ld.w	r6,pc[1214]
80004a2e:	6c 0c       	ld.w	r12,r6[0x0]
80004a30:	f0 1f 01 38 	mcall	80004f10 <phy_rx_func+0xa40>
							payload_ptr = get_payload_idle_isr();
80004a34:	fe f8 04 b0 	ld.w	r8,pc[1200]
80004a38:	70 0c       	ld.w	r12,r8[0x0]
80004a3a:	f0 1f 01 25 	mcall	80004ecc <phy_rx_func+0x9fc>
80004a3e:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == payload_ptr)
80004a40:	c0 71       	brne	80004a4e <phy_rx_func+0x57e>
							{
								RxMediaState = WAITINGABAB;
80004a42:	30 09       	mov	r9,0
80004a44:	fe f8 04 ac 	ld.w	r8,pc[1196]
80004a48:	91 09       	st.w	r8[0x0],r9
80004a4a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
					}
				if ((RxBytesWaiting -= 2) <= 0)
80004a4e:	fe f9 04 aa 	ld.w	r9,pc[1194]
80004a52:	72 08       	ld.w	r8,r9[0x0]
80004a54:	20 28       	sub	r8,2
80004a56:	93 08       	st.w	r9[0x0],r8
80004a58:	c0 71       	brne	80004a66 <phy_rx_func+0x596>
				{
					RxMediaState = WAITINGABAB;
80004a5a:	30 09       	mov	r9,0
80004a5c:	fe f8 04 94 	ld.w	r8,pc[1172]
80004a60:	91 09       	st.w	r8[0x0],r9
80004a62:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[1];
80004a66:	fe f8 04 ca 	ld.w	r8,pc[1226]
80004a6a:	70 0a       	ld.w	r10,r8[0x0]
80004a6c:	fe f9 04 7c 	ld.w	r9,pc[1148]
80004a70:	72 09       	ld.w	r9,r9[0x0]
80004a72:	8e 5b       	ld.sh	r11,r7[0xa]
80004a74:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80004a78:	70 09       	ld.w	r9,r8[0x0]
80004a7a:	2f f9       	sub	r9,-1
80004a7c:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80004a7e:	e0 49 00 ff 	cp.w	r9,255
80004a82:	e0 88 00 16 	brls	80004aae <phy_rx_func+0x5de>
						{
							RxMedia_IsFillingNext16 = 0;
80004a86:	30 09       	mov	r9,0
80004a88:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);
80004a8a:	fe f6 04 5e 	ld.w	r6,pc[1118]
80004a8e:	6c 0c       	ld.w	r12,r6[0x0]
80004a90:	f0 1f 01 20 	mcall	80004f10 <phy_rx_func+0xa40>
								payload_ptr = get_payload_idle_isr();
80004a94:	fe f8 04 50 	ld.w	r8,pc[1104]
80004a98:	70 0c       	ld.w	r12,r8[0x0]
80004a9a:	f0 1f 01 0d 	mcall	80004ecc <phy_rx_func+0x9fc>
80004a9e:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == payload_ptr)
80004aa0:	c0 71       	brne	80004aae <phy_rx_func+0x5de>
								{
									RxMediaState = WAITINGABAB;
80004aa2:	30 09       	mov	r9,0
80004aa4:	fe f8 04 4c 	ld.w	r8,pc[1100]
80004aa8:	91 09       	st.w	r8[0x0],r9
80004aaa:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
						}
				if ((RxBytesWaiting -= 2) <= 0){
80004aae:	fe f9 04 4a 	ld.w	r9,pc[1098]
80004ab2:	72 08       	ld.w	r8,r9[0x0]
80004ab4:	20 28       	sub	r8,2
80004ab6:	93 08       	st.w	r9[0x0],r8
80004ab8:	c0 71       	brne	80004ac6 <phy_rx_func+0x5f6>
					RxMediaState = WAITINGABAB;
80004aba:	30 09       	mov	r9,0
80004abc:	fe f8 04 34 	ld.w	r8,pc[1076]
80004ac0:	91 09       	st.w	r8[0x0],r9
80004ac2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}

				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[2];
80004ac6:	fe f8 04 6a 	ld.w	r8,pc[1130]
80004aca:	70 0a       	ld.w	r10,r8[0x0]
80004acc:	fe f9 04 1c 	ld.w	r9,pc[1052]
80004ad0:	72 09       	ld.w	r9,r9[0x0]
80004ad2:	8e 6b       	ld.sh	r11,r7[0xc]
80004ad4:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80004ad8:	70 09       	ld.w	r9,r8[0x0]
80004ada:	2f f9       	sub	r9,-1
80004adc:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80004ade:	e0 49 00 ff 	cp.w	r9,255
80004ae2:	e0 88 00 16 	brls	80004b0e <phy_rx_func+0x63e>
						{
							RxMedia_IsFillingNext16 = 0;
80004ae6:	30 09       	mov	r9,0
80004ae8:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);
80004aea:	fe f6 03 fe 	ld.w	r6,pc[1022]
80004aee:	6c 0c       	ld.w	r12,r6[0x0]
80004af0:	f0 1f 01 08 	mcall	80004f10 <phy_rx_func+0xa40>
									payload_ptr = get_payload_idle_isr();
80004af4:	fe f8 03 f0 	ld.w	r8,pc[1008]
80004af8:	70 0c       	ld.w	r12,r8[0x0]
80004afa:	f0 1f 00 f5 	mcall	80004ecc <phy_rx_func+0x9fc>
80004afe:	8d 0c       	st.w	r6[0x0],r12
									if(NULL == payload_ptr)
80004b00:	c0 71       	brne	80004b0e <phy_rx_func+0x63e>
									{
										RxMediaState = WAITINGABAB;
80004b02:	30 09       	mov	r9,0
80004b04:	fe f8 03 ec 	ld.w	r8,pc[1004]
80004b08:	91 09       	st.w	r8[0x0],r9
80004b0a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
						}
				if ((RxBytesWaiting -= 2) <= 0){
80004b0e:	fe f9 03 ea 	ld.w	r9,pc[1002]
80004b12:	72 08       	ld.w	r8,r9[0x0]
80004b14:	20 28       	sub	r8,2
80004b16:	93 08       	st.w	r9[0x0],r8
80004b18:	c0 71       	brne	80004b26 <phy_rx_func+0x656>
					RxMediaState = WAITINGABAB;
80004b1a:	30 09       	mov	r9,0
80004b1c:	fe f8 03 d4 	ld.w	r8,pc[980]
80004b20:	91 09       	st.w	r8[0x0],r9
80004b22:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
80004b26:	fe f8 04 0a 	ld.w	r8,pc[1034]
80004b2a:	70 0a       	ld.w	r10,r8[0x0]
80004b2c:	fe f9 03 bc 	ld.w	r9,pc[956]
80004b30:	72 09       	ld.w	r9,r9[0x0]
80004b32:	8e 7b       	ld.sh	r11,r7[0xe]
80004b34:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80004b38:	70 09       	ld.w	r9,r8[0x0]
80004b3a:	2f f9       	sub	r9,-1
80004b3c:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80004b3e:	e0 49 00 ff 	cp.w	r9,255
80004b42:	e0 88 00 16 	brls	80004b6e <phy_rx_func+0x69e>
						{
							RxMedia_IsFillingNext16 = 0;
80004b46:	30 09       	mov	r9,0
80004b48:	91 09       	st.w	r8[0x0],r9
							payload_rx(payload_ptr);
80004b4a:	fe f7 03 9e 	ld.w	r7,pc[926]
80004b4e:	6e 0c       	ld.w	r12,r7[0x0]
80004b50:	f0 1f 00 f0 	mcall	80004f10 <phy_rx_func+0xa40>
							payload_ptr = get_payload_idle_isr();
80004b54:	fe f8 03 90 	ld.w	r8,pc[912]
80004b58:	70 0c       	ld.w	r12,r8[0x0]
80004b5a:	f0 1f 00 dd 	mcall	80004ecc <phy_rx_func+0x9fc>
80004b5e:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == payload_ptr)
80004b60:	c0 71       	brne	80004b6e <phy_rx_func+0x69e>
							{
								RxMediaState = WAITINGABAB;
80004b62:	30 09       	mov	r9,0
80004b64:	fe f8 03 8c 	ld.w	r8,pc[908]
80004b68:	91 09       	st.w	r8[0x0],r9
80004b6a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
				if ((RxBytesWaiting -= 2) <= 0){
80004b6e:	fe f9 03 8a 	ld.w	r9,pc[906]
80004b72:	72 08       	ld.w	r8,r9[0x0]
80004b74:	20 28       	sub	r8,2
80004b76:	93 08       	st.w	r9[0x0],r8
80004b78:	e0 81 01 9b 	brne	80004eae <phy_rx_func+0x9de>
					RxMediaState = WAITINGABAB;
80004b7c:	30 09       	mov	r9,0
80004b7e:	fe f8 03 72 	ld.w	r8,pc[882]
80004b82:	91 09       	st.w	r8[0x0],r9
80004b84:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			}
			break; //End of READINGMEDIA.

		case READING_AMBE_MEDIA:
			
					if ((Item_ID == Vocoder_Bit_Stream_Parameter))//PAYLOAD_DATA_ENH (0x0c))
80004b88:	fe f8 03 78 	ld.w	r8,pc[888]
80004b8c:	11 89       	ld.ub	r9,r8[0x0]
80004b8e:	31 28       	mov	r8,18
80004b90:	f0 09 18 00 	cp.b	r9,r8
80004b94:	e0 81 01 32 	brne	80004df8 <phy_rx_func+0x928>
					{
						Item_ID = payload_rx_channel->byte[1];
80004b98:	ef 39 00 09 	ld.ub	r9,r7[9]
80004b9c:	fe f8 03 64 	ld.w	r8,pc[868]
80004ba0:	b0 89       	st.b	r8[0x0],r9
						if (Item_ID == Post_Voice_Encoder_Data)
80004ba2:	11 89       	ld.ub	r9,r8[0x0]
80004ba4:	3f 28       	mov	r8,-14
80004ba6:	f0 09 18 00 	cp.b	r9,r8
80004baa:	e0 81 01 22 	brne	80004dee <phy_rx_func+0x91e>
						{
							
							RxBytesWaiting = ((payload_rx_channel->dword[0] & 0x7F000000) >>24);//Test calculations are correct; 8
80004bae:	6e 29       	ld.w	r9,r7[0x8]
80004bb0:	f3 d9 c3 07 	bfextu	r9,r9,0x18,0x7
80004bb4:	fe f8 03 44 	ld.w	r8,pc[836]
80004bb8:	91 09       	st.w	r8[0x0],r9
							
							//For looping back to Radio
							AMBEBurst_rawdata[0] = payload_rx_channel->word[1];
80004bba:	8e 59       	ld.sh	r9,r7[0xa]
80004bbc:	fe f8 03 7c 	ld.w	r8,pc[892]
80004bc0:	b0 09       	st.h	r8[0x0],r9
							AMBEBurst_rawdata[1] = payload_rx_channel->word[2];
80004bc2:	8e 69       	ld.sh	r9,r7[0xc]
80004bc4:	b0 19       	st.h	r8[0x2],r9
							AMBEBurst_rawdata[2] = payload_rx_channel->word[3];
80004bc6:	8e 79       	ld.sh	r9,r7[0xe]
80004bc8:	b0 29       	st.h	r8[0x4],r9
							
							//To be tested. Also locally stored RAW-AMBER-DATA
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//1
80004bca:	fe f8 03 3e 	ld.w	r8,pc[830]
80004bce:	fe f9 03 1e 	ld.w	r9,pc[798]
80004bd2:	72 0a       	ld.w	r10,r9[0x0]
80004bd4:	70 09       	ld.w	r9,r8[0x0]
80004bd6:	ef 3b 00 0a 	ld.ub	r11,r7[10]
80004bda:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80004bde:	70 09       	ld.w	r9,r8[0x0]
80004be0:	2f f9       	sub	r9,-1
80004be2:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80004be4:	e0 49 01 ff 	cp.w	r9,511
80004be8:	e0 88 00 16 	brls	80004c14 <phy_rx_func+0x744>
							{
								RxAMBE_IsFillingNext8 = 0;
80004bec:	30 09       	mov	r9,0
80004bee:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80004bf0:	fe f6 02 fc 	ld.w	r6,pc[764]
80004bf4:	6c 0c       	ld.w	r12,r6[0x0]
80004bf6:	f0 1f 00 c7 	mcall	80004f10 <phy_rx_func+0xa40>
								AMBE_payload_ptr = get_payload_idle_isr();
80004bfa:	fe f8 02 ea 	ld.w	r8,pc[746]
80004bfe:	70 0c       	ld.w	r12,r8[0x0]
80004c00:	f0 1f 00 b3 	mcall	80004ecc <phy_rx_func+0x9fc>
80004c04:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80004c06:	c0 71       	brne	80004c14 <phy_rx_func+0x744>
								{
									RxMediaState = WAITINGABAB;
80004c08:	30 09       	mov	r9,0
80004c0a:	fe f8 02 e6 	ld.w	r8,pc[742]
80004c0e:	91 09       	st.w	r8[0x0],r9
80004c10:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80004c14:	fe f9 02 e4 	ld.w	r9,pc[740]
80004c18:	72 08       	ld.w	r8,r9[0x0]
80004c1a:	20 18       	sub	r8,1
80004c1c:	93 08       	st.w	r9[0x0],r8
80004c1e:	c0 71       	brne	80004c2c <phy_rx_func+0x75c>
								RxMediaState = WAITINGABAB;
80004c20:	30 09       	mov	r9,0
80004c22:	fe f8 02 ce 	ld.w	r8,pc[718]
80004c26:	91 09       	st.w	r8[0x0],r9
80004c28:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}			
							
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//2
80004c2c:	fe f8 02 dc 	ld.w	r8,pc[732]
80004c30:	fe f9 02 bc 	ld.w	r9,pc[700]
80004c34:	72 0a       	ld.w	r10,r9[0x0]
80004c36:	70 09       	ld.w	r9,r8[0x0]
80004c38:	ef 3b 00 0b 	ld.ub	r11,r7[11]
80004c3c:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80004c40:	70 09       	ld.w	r9,r8[0x0]
80004c42:	2f f9       	sub	r9,-1
80004c44:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80004c46:	e0 49 01 ff 	cp.w	r9,511
80004c4a:	e0 88 00 16 	brls	80004c76 <phy_rx_func+0x7a6>
							{
								RxAMBE_IsFillingNext8 = 0;
80004c4e:	30 09       	mov	r9,0
80004c50:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80004c52:	fe f6 02 9a 	ld.w	r6,pc[666]
80004c56:	6c 0c       	ld.w	r12,r6[0x0]
80004c58:	f0 1f 00 ae 	mcall	80004f10 <phy_rx_func+0xa40>
								AMBE_payload_ptr = get_payload_idle_isr();
80004c5c:	fe f8 02 88 	ld.w	r8,pc[648]
80004c60:	70 0c       	ld.w	r12,r8[0x0]
80004c62:	f0 1f 00 9b 	mcall	80004ecc <phy_rx_func+0x9fc>
80004c66:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80004c68:	c0 71       	brne	80004c76 <phy_rx_func+0x7a6>
								{
									RxMediaState = WAITINGABAB;
80004c6a:	30 09       	mov	r9,0
80004c6c:	fe f8 02 84 	ld.w	r8,pc[644]
80004c70:	91 09       	st.w	r8[0x0],r9
80004c72:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80004c76:	fe f9 02 82 	ld.w	r9,pc[642]
80004c7a:	72 08       	ld.w	r8,r9[0x0]
80004c7c:	20 18       	sub	r8,1
80004c7e:	93 08       	st.w	r9[0x0],r8
80004c80:	c0 71       	brne	80004c8e <phy_rx_func+0x7be>
								RxMediaState = WAITINGABAB;
80004c82:	30 09       	mov	r9,0
80004c84:	fe f8 02 6c 	ld.w	r8,pc[620]
80004c88:	91 09       	st.w	r8[0x0],r9
80004c8a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}		
						
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//3
80004c8e:	fe f8 02 7a 	ld.w	r8,pc[634]
80004c92:	fe f9 02 5a 	ld.w	r9,pc[602]
80004c96:	72 0a       	ld.w	r10,r9[0x0]
80004c98:	70 09       	ld.w	r9,r8[0x0]
80004c9a:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80004c9e:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80004ca2:	70 09       	ld.w	r9,r8[0x0]
80004ca4:	2f f9       	sub	r9,-1
80004ca6:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80004ca8:	e0 49 01 ff 	cp.w	r9,511
80004cac:	e0 88 00 16 	brls	80004cd8 <phy_rx_func+0x808>
							{
								RxAMBE_IsFillingNext8 = 0;
80004cb0:	30 09       	mov	r9,0
80004cb2:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80004cb4:	fe f6 02 38 	ld.w	r6,pc[568]
80004cb8:	6c 0c       	ld.w	r12,r6[0x0]
80004cba:	f0 1f 00 96 	mcall	80004f10 <phy_rx_func+0xa40>
								AMBE_payload_ptr = get_payload_idle_isr();
80004cbe:	fe f8 02 26 	ld.w	r8,pc[550]
80004cc2:	70 0c       	ld.w	r12,r8[0x0]
80004cc4:	f0 1f 00 82 	mcall	80004ecc <phy_rx_func+0x9fc>
80004cc8:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80004cca:	c0 71       	brne	80004cd8 <phy_rx_func+0x808>
								{
									RxMediaState = WAITINGABAB;
80004ccc:	30 09       	mov	r9,0
80004cce:	fe f8 02 22 	ld.w	r8,pc[546]
80004cd2:	91 09       	st.w	r8[0x0],r9
80004cd4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80004cd8:	fe f9 02 20 	ld.w	r9,pc[544]
80004cdc:	72 08       	ld.w	r8,r9[0x0]
80004cde:	20 18       	sub	r8,1
80004ce0:	93 08       	st.w	r9[0x0],r8
80004ce2:	c0 71       	brne	80004cf0 <phy_rx_func+0x820>
								RxMediaState = WAITINGABAB;
80004ce4:	30 09       	mov	r9,0
80004ce6:	fe f8 02 0a 	ld.w	r8,pc[522]
80004cea:	91 09       	st.w	r8[0x0],r9
80004cec:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[5];//4
80004cf0:	fe f8 02 18 	ld.w	r8,pc[536]
80004cf4:	4f e9       	lddpc	r9,80004eec <phy_rx_func+0xa1c>
80004cf6:	72 0a       	ld.w	r10,r9[0x0]
80004cf8:	70 09       	ld.w	r9,r8[0x0]
80004cfa:	ef 3b 00 0d 	ld.ub	r11,r7[13]
80004cfe:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80004d02:	70 09       	ld.w	r9,r8[0x0]
80004d04:	2f f9       	sub	r9,-1
80004d06:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80004d08:	e0 49 01 ff 	cp.w	r9,511
80004d0c:	e0 88 00 13 	brls	80004d32 <phy_rx_func+0x862>
							{
								RxAMBE_IsFillingNext8 = 0;
80004d10:	30 09       	mov	r9,0
80004d12:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80004d14:	4f 66       	lddpc	r6,80004eec <phy_rx_func+0xa1c>
80004d16:	6c 0c       	ld.w	r12,r6[0x0]
80004d18:	f0 1f 00 7e 	mcall	80004f10 <phy_rx_func+0xa40>
								AMBE_payload_ptr = get_payload_idle_isr();
80004d1c:	4f 28       	lddpc	r8,80004ee4 <phy_rx_func+0xa14>
80004d1e:	70 0c       	ld.w	r12,r8[0x0]
80004d20:	f0 1f 00 6b 	mcall	80004ecc <phy_rx_func+0x9fc>
80004d24:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80004d26:	c0 61       	brne	80004d32 <phy_rx_func+0x862>
								{
									RxMediaState = WAITINGABAB;
80004d28:	30 09       	mov	r9,0
80004d2a:	4f 28       	lddpc	r8,80004ef0 <phy_rx_func+0xa20>
80004d2c:	91 09       	st.w	r8[0x0],r9
80004d2e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80004d32:	4f 29       	lddpc	r9,80004ef8 <phy_rx_func+0xa28>
80004d34:	72 08       	ld.w	r8,r9[0x0]
80004d36:	20 18       	sub	r8,1
80004d38:	93 08       	st.w	r9[0x0],r8
80004d3a:	c0 61       	brne	80004d46 <phy_rx_func+0x876>
								RxMediaState = WAITINGABAB;
80004d3c:	30 09       	mov	r9,0
80004d3e:	4e d8       	lddpc	r8,80004ef0 <phy_rx_func+0xa20>
80004d40:	91 09       	st.w	r8[0x0],r9
80004d42:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//5
80004d46:	4f 18       	lddpc	r8,80004f08 <phy_rx_func+0xa38>
80004d48:	4e 99       	lddpc	r9,80004eec <phy_rx_func+0xa1c>
80004d4a:	72 0a       	ld.w	r10,r9[0x0]
80004d4c:	70 09       	ld.w	r9,r8[0x0]
80004d4e:	ef 3b 00 0e 	ld.ub	r11,r7[14]
80004d52:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80004d56:	70 09       	ld.w	r9,r8[0x0]
80004d58:	2f f9       	sub	r9,-1
80004d5a:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80004d5c:	e0 49 01 ff 	cp.w	r9,511
80004d60:	e0 88 00 13 	brls	80004d86 <phy_rx_func+0x8b6>
							{
								RxAMBE_IsFillingNext8 = 0;
80004d64:	30 09       	mov	r9,0
80004d66:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80004d68:	4e 16       	lddpc	r6,80004eec <phy_rx_func+0xa1c>
80004d6a:	6c 0c       	ld.w	r12,r6[0x0]
80004d6c:	f0 1f 00 69 	mcall	80004f10 <phy_rx_func+0xa40>
								AMBE_payload_ptr = get_payload_idle_isr();
80004d70:	4d d8       	lddpc	r8,80004ee4 <phy_rx_func+0xa14>
80004d72:	70 0c       	ld.w	r12,r8[0x0]
80004d74:	f0 1f 00 56 	mcall	80004ecc <phy_rx_func+0x9fc>
80004d78:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80004d7a:	c0 61       	brne	80004d86 <phy_rx_func+0x8b6>
								{
									RxMediaState = WAITINGABAB;
80004d7c:	30 09       	mov	r9,0
80004d7e:	4d d8       	lddpc	r8,80004ef0 <phy_rx_func+0xa20>
80004d80:	91 09       	st.w	r8[0x0],r9
80004d82:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80004d86:	4d d9       	lddpc	r9,80004ef8 <phy_rx_func+0xa28>
80004d88:	72 08       	ld.w	r8,r9[0x0]
80004d8a:	20 18       	sub	r8,1
80004d8c:	93 08       	st.w	r9[0x0],r8
80004d8e:	c0 61       	brne	80004d9a <phy_rx_func+0x8ca>
								RxMediaState = WAITINGABAB;
80004d90:	30 09       	mov	r9,0
80004d92:	4d 88       	lddpc	r8,80004ef0 <phy_rx_func+0xa20>
80004d94:	91 09       	st.w	r8[0x0],r9
80004d96:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//6
80004d9a:	4d c8       	lddpc	r8,80004f08 <phy_rx_func+0xa38>
80004d9c:	4d 49       	lddpc	r9,80004eec <phy_rx_func+0xa1c>
80004d9e:	72 0a       	ld.w	r10,r9[0x0]
80004da0:	70 09       	ld.w	r9,r8[0x0]
80004da2:	ef 3b 00 0f 	ld.ub	r11,r7[15]
80004da6:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80004daa:	70 09       	ld.w	r9,r8[0x0]
80004dac:	2f f9       	sub	r9,-1
80004dae:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80004db0:	e0 49 01 ff 	cp.w	r9,511
80004db4:	e0 88 00 13 	brls	80004dda <phy_rx_func+0x90a>
							{
								RxAMBE_IsFillingNext8 = 0;
80004db8:	30 09       	mov	r9,0
80004dba:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80004dbc:	4c c7       	lddpc	r7,80004eec <phy_rx_func+0xa1c>
80004dbe:	6e 0c       	ld.w	r12,r7[0x0]
80004dc0:	f0 1f 00 54 	mcall	80004f10 <phy_rx_func+0xa40>
								AMBE_payload_ptr = get_payload_idle_isr();
80004dc4:	4c 88       	lddpc	r8,80004ee4 <phy_rx_func+0xa14>
80004dc6:	70 0c       	ld.w	r12,r8[0x0]
80004dc8:	f0 1f 00 41 	mcall	80004ecc <phy_rx_func+0x9fc>
80004dcc:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == AMBE_payload_ptr)
80004dce:	c0 61       	brne	80004dda <phy_rx_func+0x90a>
								{
									RxMediaState = WAITINGABAB;
80004dd0:	30 09       	mov	r9,0
80004dd2:	4c 88       	lddpc	r8,80004ef0 <phy_rx_func+0xa20>
80004dd4:	91 09       	st.w	r8[0x0],r9
80004dd6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80004dda:	4c 89       	lddpc	r9,80004ef8 <phy_rx_func+0xa28>
80004ddc:	72 08       	ld.w	r8,r9[0x0]
80004dde:	20 18       	sub	r8,1
80004de0:	93 08       	st.w	r9[0x0],r8
80004de2:	c6 61       	brne	80004eae <phy_rx_func+0x9de>
								RxMediaState = WAITINGABAB;
80004de4:	30 09       	mov	r9,0
80004de6:	4c 38       	lddpc	r8,80004ef0 <phy_rx_func+0xa20>
80004de8:	91 09       	st.w	r8[0x0],r9
80004dea:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							//}
							
						}
						else//error
						{
							RxMediaState = WAITINGABAB;
80004dee:	30 09       	mov	r9,0
80004df0:	4c 08       	lddpc	r8,80004ef0 <phy_rx_func+0xa20>
80004df2:	91 09       	st.w	r8[0x0],r9
80004df4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
					}
					else if (Item_ID == Post_Voice_Encoder_Data)//(bit48~Pad-bits)
80004df8:	4c 28       	lddpc	r8,80004f00 <phy_rx_func+0xa30>
80004dfa:	11 89       	ld.ub	r9,r8[0x0]
80004dfc:	3f 28       	mov	r8,-14
80004dfe:	f0 09 18 00 	cp.b	r9,r8
80004e02:	c3 81       	brne	80004e72 <phy_rx_func+0x9a2>
					{
						
						
						AMBEBurst_rawdata[3] = payload_rx_channel->word[0];//(bit48~Pad-bits)
80004e04:	8e 49       	ld.sh	r9,r7[0x8]
80004e06:	4c d8       	lddpc	r8,80004f38 <phy_rx_func+0xa68>
80004e08:	b0 39       	st.h	r8[0x6],r9
						//AMBE_Per_Burst_Flag = 1;
						
						//MOTO.bitpad-bits
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//7
80004e0a:	4c 08       	lddpc	r8,80004f08 <phy_rx_func+0xa38>
80004e0c:	4b 89       	lddpc	r9,80004eec <phy_rx_func+0xa1c>
80004e0e:	72 0a       	ld.w	r10,r9[0x0]
80004e10:	70 09       	ld.w	r9,r8[0x0]
80004e12:	ef 3b 00 08 	ld.ub	r11,r7[8]
80004e16:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80004e1a:	70 09       	ld.w	r9,r8[0x0]
80004e1c:	2f f9       	sub	r9,-1
80004e1e:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80004e20:	e0 49 01 ff 	cp.w	r9,511
80004e24:	e0 88 00 13 	brls	80004e4a <phy_rx_func+0x97a>
						{
							RxAMBE_IsFillingNext8 = 0;
80004e28:	30 09       	mov	r9,0
80004e2a:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80004e2c:	4b 07       	lddpc	r7,80004eec <phy_rx_func+0xa1c>
80004e2e:	6e 0c       	ld.w	r12,r7[0x0]
80004e30:	f0 1f 00 38 	mcall	80004f10 <phy_rx_func+0xa40>
							AMBE_payload_ptr = get_payload_idle_isr();
80004e34:	4a c8       	lddpc	r8,80004ee4 <phy_rx_func+0xa14>
80004e36:	70 0c       	ld.w	r12,r8[0x0]
80004e38:	f0 1f 00 25 	mcall	80004ecc <phy_rx_func+0x9fc>
80004e3c:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
80004e3e:	c0 61       	brne	80004e4a <phy_rx_func+0x97a>
							{
								RxMediaState = WAITINGABAB;
80004e40:	30 09       	mov	r9,0
80004e42:	4a c8       	lddpc	r8,80004ef0 <phy_rx_func+0xa20>
80004e44:	91 09       	st.w	r8[0x0],r9
80004e46:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80004e4a:	4a c9       	lddpc	r9,80004ef8 <phy_rx_func+0xa28>
80004e4c:	72 08       	ld.w	r8,r9[0x0]
80004e4e:	20 18       	sub	r8,1
80004e50:	93 08       	st.w	r9[0x0],r8
80004e52:	c0 61       	brne	80004e5e <phy_rx_func+0x98e>
							RxMediaState = WAITINGABAB;
80004e54:	30 09       	mov	r9,0
80004e56:	4a 78       	lddpc	r8,80004ef0 <phy_rx_func+0xa20>
80004e58:	91 09       	st.w	r8[0x0],r9
80004e5a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
						if ((RxBytesWaiting -= 1) <= 0){//AMBE Vocoder Bits Stream(bit59~63),
80004e5e:	20 18       	sub	r8,1
80004e60:	4a 69       	lddpc	r9,80004ef8 <phy_rx_func+0xa28>
80004e62:	93 08       	st.w	r9[0x0],r8
80004e64:	58 08       	cp.w	r8,0
80004e66:	c2 41       	brne	80004eae <phy_rx_func+0x9de>
							RxMediaState = WAITINGABAB;
80004e68:	30 09       	mov	r9,0
80004e6a:	4a 28       	lddpc	r8,80004ef0 <phy_rx_func+0xa20>
80004e6c:	91 09       	st.w	r8[0x0],r9
80004e6e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						*******************/
						
								
					}
					
					else if ((Item_ID == 0x04)  ||  (Item_ID == 0x03))//Unknown type data directly back hair
80004e72:	4a 48       	lddpc	r8,80004f00 <phy_rx_func+0xa30>
80004e74:	11 89       	ld.ub	r9,r8[0x0]
80004e76:	30 48       	mov	r8,4
80004e78:	f0 09 18 00 	cp.b	r9,r8
80004e7c:	c0 70       	breq	80004e8a <phy_rx_func+0x9ba>
80004e7e:	4a 18       	lddpc	r8,80004f00 <phy_rx_func+0xa30>
80004e80:	11 89       	ld.ub	r9,r8[0x0]
80004e82:	30 38       	mov	r8,3
80004e84:	f0 09 18 00 	cp.b	r9,r8
80004e88:	c1 01       	brne	80004ea8 <phy_rx_func+0x9d8>
					{
						AMBE_HT[0] = payload_rx_channel->dword[0];
80004e8a:	6e 29       	ld.w	r9,r7[0x8]
80004e8c:	4a 48       	lddpc	r8,80004f1c <phy_rx_func+0xa4c>
80004e8e:	91 09       	st.w	r8[0x0],r9
						AMBE_HT[1] = payload_rx_channel->dword[1];				
80004e90:	6e 39       	ld.w	r9,r7[0xc]
80004e92:	91 19       	st.w	r8[0x4],r9
						
						if ((RxBytesWaiting -= 8) <= 0)//Consider two cases 0xABCDC014 and 0xABCDC010
80004e94:	49 99       	lddpc	r9,80004ef8 <phy_rx_func+0xa28>
80004e96:	72 08       	ld.w	r8,r9[0x0]
80004e98:	20 88       	sub	r8,8
80004e9a:	93 08       	st.w	r9[0x0],r8
80004e9c:	c0 91       	brne	80004eae <phy_rx_func+0x9de>
						{
					
							RxBytesWaiting = 0;
80004e9e:	93 08       	st.w	r9[0x0],r8
							RxMediaState = WAITINGABAB;
80004ea0:	49 49       	lddpc	r9,80004ef0 <phy_rx_func+0xa20>
80004ea2:	93 08       	st.w	r9[0x0],r8
80004ea4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					//}
					
					else
					{
						
						RxMediaState  = WAITINGABAB;
80004ea8:	30 09       	mov	r9,0
80004eaa:	49 28       	lddpc	r8,80004ef0 <phy_rx_func+0xa20>
80004eac:	91 09       	st.w	r8[0x0],r9
80004eae:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80004eb2:	00 00       	add	r0,r0
80004eb4:	00 00       	add	r0,r0
80004eb6:	10 4c       	or	r12,r8
80004eb8:	00 00       	add	r0,r0
80004eba:	10 68       	and	r8,r8
80004ebc:	00 00       	add	r0,r0
80004ebe:	10 3c       	cp.w	r12,r8
80004ec0:	00 00       	add	r0,r0
80004ec2:	10 24       	rsub	r4,r8
80004ec4:	00 00       	add	r0,r0
80004ec6:	10 1a       	sub	r10,r8
80004ec8:	00 00       	add	r0,r0
80004eca:	10 38       	cp.w	r8,r8
80004ecc:	80 00       	ld.sh	r0,r0[0x0]
80004ece:	3d a8       	mov	r8,-38
80004ed0:	00 00       	add	r0,r0
80004ed2:	10 6c       	and	r12,r8
80004ed4:	80 00       	ld.sh	r0,r0[0x0]
80004ed6:	8f d4       	st.w	r7[0x34],r4
80004ed8:	00 00       	add	r0,r0
80004eda:	10 48       	or	r8,r8
80004edc:	80 00       	ld.sh	r0,r0[0x0]
80004ede:	3c f4       	mov	r4,-49
80004ee0:	00 00       	add	r0,r0
80004ee2:	10 50       	eor	r0,r8
80004ee4:	00 00       	add	r0,r0
80004ee6:	10 28       	rsub	r8,r8
80004ee8:	00 00       	add	r0,r0
80004eea:	10 04       	add	r4,r8
80004eec:	00 00       	add	r0,r0
80004eee:	0f fc       	ld.ub	r12,r7[0x7]
80004ef0:	00 00       	add	r0,r0
80004ef2:	10 5c       	eor	r12,r8
80004ef4:	00 00       	add	r0,r0
80004ef6:	10 00       	add	r0,r8
80004ef8:	00 00       	add	r0,r0
80004efa:	10 14       	sub	r4,r8
80004efc:	00 00       	add	r0,r0
80004efe:	0a 42       	or	r2,r5
80004f00:	00 00       	add	r0,r0
80004f02:	10 18       	sub	r8,r8
80004f04:	00 00       	add	r0,r0
80004f06:	0a 40       	or	r0,r5
80004f08:	00 00       	add	r0,r0
80004f0a:	10 10       	sub	r0,r8
80004f0c:	80 00       	ld.sh	r0,r0[0x0]
80004f0e:	aa 4e       	st.h	r5[0x8],lr
80004f10:	80 00       	ld.sh	r0,r0[0x0]
80004f12:	44 70       	lddsp	r0,sp[0x11c]
80004f14:	00 00       	add	r0,r0
80004f16:	14 4c       	or	r12,r10
80004f18:	80 00       	ld.sh	r0,r0[0x0]
80004f1a:	3b c8       	mov	r8,-68
80004f1c:	00 00       	add	r0,r0
80004f1e:	10 30       	cp.w	r0,r8
80004f20:	80 01       	ld.sh	r1,r0[0x0]
80004f22:	8e 74       	ld.sh	r4,r7[0xe]
80004f24:	80 00       	ld.sh	r0,r0[0x0]
80004f26:	a0 cc       	st.b	r0[0x4],r12
80004f28:	80 01       	ld.sh	r1,r0[0x0]
80004f2a:	8e 88       	ld.uh	r8,r7[0x0]
80004f2c:	00 00       	add	r0,r0
80004f2e:	10 1c       	sub	r12,r8
80004f30:	00 00       	add	r0,r0
80004f32:	10 54       	eor	r4,r8
80004f34:	00 00       	add	r0,r0
80004f36:	0a 41       	or	r1,r5
80004f38:	00 00       	add	r0,r0
80004f3a:	13 54       	ld.sh	r4,--r9

80004f3c <pdca_int_handler>:
    void (*phy_rx_exec)(void *)--callback function for receive SSC data 
Called By: interrupt
*/
__attribute__((__interrupt__))
static void pdca_int_handler(void)
{
80004f3c:	d4 01       	pushm	lr
    
	//intStartCount = Get_system_register(AVR32_COUNT);
	
	/*Toggle Index*/
    BufferIndex ^= 0x01;
80004f3e:	49 88       	lddpc	r8,80004f9c <pdca_int_handler+0x60>
80004f40:	11 89       	ld.ub	r9,r8[0x0]
80004f42:	ec 19 00 01 	eorl	r9,0x1
80004f46:	b0 89       	st.b	r8[0x0],r9
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);
80004f48:	11 89       	ld.ub	r9,r8[0x0]
80004f4a:	a5 69       	lsl	r9,0x4
80004f4c:	2f c9       	sub	r9,-4
80004f4e:	49 5a       	lddpc	r10,80004fa0 <pdca_int_handler+0x64>
80004f50:	14 09       	add	r9,r10
	
	/*Toggle Index*/
    BufferIndex ^= 0x01;
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
80004f52:	fe 7a 00 40 	mov	r10,-65472
80004f56:	95 39       	st.w	r10[0xc],r9
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80004f58:	30 39       	mov	r9,3
80004f5a:	95 49       	st.w	r10[0x10],r9

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);
80004f5c:	11 8a       	ld.ub	r10,r8[0x0]
80004f5e:	a5 6a       	lsl	r10,0x4
80004f60:	2f ca       	sub	r10,-4
80004f62:	49 18       	lddpc	r8,80004fa4 <pdca_int_handler+0x68>
80004f64:	10 0a       	add	r10,r8
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
80004f66:	fe 78 00 00 	mov	r8,-65536
80004f6a:	91 3a       	st.w	r8[0xc],r10
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80004f6c:	91 49       	st.w	r8[0x10],r9
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr;
80004f6e:	70 b8       	ld.w	r8,r8[0x2c]
	
	/*receive SSC data*/
    if(phy_rx_exec != NULL)phy_rx_exec((void *)&RxBuffer[BufferIndex]);
80004f70:	48 e8       	lddpc	r8,80004fa8 <pdca_int_handler+0x6c>
80004f72:	70 08       	ld.w	r8,r8[0x0]
80004f74:	58 08       	cp.w	r8,0
80004f76:	c0 70       	breq	80004f84 <pdca_int_handler+0x48>
80004f78:	48 99       	lddpc	r9,80004f9c <pdca_int_handler+0x60>
80004f7a:	13 89       	ld.ub	r9,r9[0x0]
80004f7c:	a5 69       	lsl	r9,0x4
80004f7e:	48 ac       	lddpc	r12,80004fa4 <pdca_int_handler+0x68>
80004f80:	12 0c       	add	r12,r9
80004f82:	5d 18       	icall	r8

    /*transmit SSC data*/

	if(phy_tx_exec != NULL)phy_tx_exec((void *)&TxBuffer[BufferIndex]);//phy_tx_func, phy_rx_func
80004f84:	48 a8       	lddpc	r8,80004fac <pdca_int_handler+0x70>
80004f86:	70 08       	ld.w	r8,r8[0x0]
80004f88:	58 08       	cp.w	r8,0
80004f8a:	c0 70       	breq	80004f98 <pdca_int_handler+0x5c>
80004f8c:	48 49       	lddpc	r9,80004f9c <pdca_int_handler+0x60>
80004f8e:	13 89       	ld.ub	r9,r9[0x0]
80004f90:	a5 69       	lsl	r9,0x4
80004f92:	48 4c       	lddpc	r12,80004fa0 <pdca_int_handler+0x64>
80004f94:	12 0c       	add	r12,r9
80004f96:	5d 18       	icall	r8

	
	//intDuration = Get_system_register(AVR32_COUNT) - intStartCount;
	
	
}/*End of pdca_int_handler.*/
80004f98:	d4 02       	popm	lr
80004f9a:	d6 03       	rete
80004f9c:	00 00       	add	r0,r0
80004f9e:	46 54       	lddsp	r4,sp[0x194]
80004fa0:	00 00       	add	r0,r0
80004fa2:	46 7c       	lddsp	r12,sp[0x19c]
80004fa4:	00 00       	add	r0,r0
80004fa6:	46 5c       	lddsp	r12,sp[0x194]
80004fa8:	00 00       	add	r0,r0
80004faa:	10 78       	tst	r8,r8
80004fac:	00 00       	add	r0,r0
80004fae:	10 7c       	tst	r12,r8

80004fb0 <local_start_SSC>:
void local_start_SSC(void)
{
    /*Assign GPIO to SSC.
    gpio_enable_module
    gpio_enable_module_pin*/
    AVR32_GPIO.port[1].pmr0c = 0x00000DC0;
80004fb0:	fe 78 10 00 	mov	r8,-61440
80004fb4:	e0 69 0d c0 	mov	r9,3520
80004fb8:	f1 49 01 18 	st.w	r8[280],r9
    AVR32_GPIO.port[1].pmr1c = 0x00000DC0;
80004fbc:	f1 49 01 28 	st.w	r8[296],r9
    AVR32_GPIO.port[1].gperc = 0x00000DC0;
80004fc0:	f1 49 01 08 	st.w	r8[264],r9

    /*Software reset SSC*/
    (&AVR32_SSC)->cr = AVR32_SSC_CR_SWRST_MASK;
80004fc4:	fe 78 34 00 	mov	r8,-52224
80004fc8:	e0 69 80 00 	mov	r9,32768
80004fcc:	91 09       	st.w	r8[0x0],r9
    (&AVR32_SSC)->cmr 
80004fce:	30 09       	mov	r9,0
80004fd0:	91 19       	st.w	r8[0x4],r9
                     = AVR32_SSC_CMR_DIV_NOT_ACTIVE << AVR32_SSC_CMR_DIV_OFFSET;

    /*For Slave*/
    (&AVR32_SSC)->tcmr =
80004fd2:	e0 69 04 21 	mov	r9,1057
80004fd6:	ea 19 3f 20 	orh	r9,0x3f20
80004fda:	91 69       	st.w	r8[0x18],r9
	    | 32 << AVR32_SSC_TCMR_STTDLY_OFFSET
	    | 63 << AVR32_SSC_TCMR_PERIOD_OFFSET;


    /*For Slave*/
    (&AVR32_SSC)->tfmr = 31 << AVR32_SSC_TFMR_DATLEN_OFFSET 
80004fdc:	e0 69 02 9f 	mov	r9,671
80004fe0:	ea 19 01 00 	orh	r9,0x100
80004fe4:	91 79       	st.w	r8[0x1c],r9
	    | 0 << AVR32_SSC_TFMR_FSDEN_OFFSET
	    | 1 << AVR32_SSC_TFMR_FSEDGE_OFFSET;

	/*For Slave*/

	(&AVR32_SSC)->rcmr = AVR32_SSC_RCMR_CKS_RK_PIN << AVR32_SSC_RCMR_CKS_OFFSET
80004fe6:	e0 6a 04 02 	mov	r10,1026
80004fea:	ea 1a 3f 20 	orh	r10,0x3f20
80004fee:	91 4a       	st.w	r8[0x10],r10
	    | 0 << AVR32_SSC_RCMR_STOP_OFFSET
	    | 32 << AVR32_SSC_RCMR_STTDLY_OFFSET
	    | 63 << AVR32_SSC_RCMR_PERIOD_OFFSET;

	/*For Slave*/
	(&AVR32_SSC)->rfmr = 31 << AVR32_SSC_RFMR_DATLEN_OFFSET
80004ff0:	91 59       	st.w	r8[0x14],r9
	    | 1 << AVR32_SSC_RFMR_MSBF_OFFSET
	    | 2 << AVR32_SSC_RFMR_DATNB_OFFSET
	    | 0 << AVR32_SSC_RFMR_FSLEN_OFFSET
	    | AVR32_SSC_RFMR_FSOS_INPUT_ONLY << AVR32_SSC_RFMR_FSOS_OFFSET
	    | 1 << AVR32_SSC_RFMR_FSEDGE_OFFSET;
}/*End of local_start_SSC.*/
80004ff2:	5e fc       	retal	r12

80004ff4 <local_start_PDC>:
Function: local_start_PDC
Description: none
Called By: void ssc_init(void) -- ssc.c
*/
void local_start_PDC(void)
{
80004ff4:	d4 01       	pushm	lr
    /*Toggle Index*/	
    BufferIndex = 1;
80004ff6:	30 19       	mov	r9,1
80004ff8:	49 78       	lddpc	r8,80005054 <local_start_PDC+0x60>
80004ffa:	b0 89       	st.b	r8[0x0],r9
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
80004ffc:	fe 78 00 00 	mov	r8,-65536
80005000:	30 7b       	mov	r11,7
80005002:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
80005004:	70 b9       	ld.w	r9,r8[0x2c]
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
80005006:	49 59       	lddpc	r9,80005058 <local_start_PDC+0x64>
80005008:	f2 ca ff fc 	sub	r10,r9,-4
    BufferIndex = 1;
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
8000500c:	91 0a       	st.w	r8[0x0],r10
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
8000500e:	30 3a       	mov	r10,3
80005010:	91 2a       	st.w	r8[0x8],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
80005012:	30 1c       	mov	r12,1
80005014:	91 1c       	st.w	r8[0x4],r12
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
80005016:	2e c9       	sub	r9,-20
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
80005018:	91 39       	st.w	r8[0xc],r9
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
8000501a:	91 4a       	st.w	r8[0x10],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mr = AVR32_PDCA_WORD;
8000501c:	30 2c       	mov	r12,2
8000501e:	91 6c       	st.w	r8[0x18],r12

	TxBuffer[0].xnl_channel.dword = XNL_IDLE;
80005020:	48 f9       	lddpc	r9,8000505c <local_start_PDC+0x68>
80005022:	e0 68 5a 5a 	mov	r8,23130
80005026:	ea 18 ab cd 	orh	r8,0xabcd
8000502a:	93 18       	st.w	r9[0x4],r8
	TxBuffer[0].payload_channel.dword[0] = PAYLOADIDLE0;
8000502c:	93 28       	st.w	r9[0x8],r8
	TxBuffer[0].payload_channel.dword[1] = PAYLOADIDLE1;
8000502e:	30 0e       	mov	lr,0
80005030:	93 3e       	st.w	r9[0xc],lr
	TxBuffer[1].xnl_channel.dword = XNL_IDLE;
80005032:	93 58       	st.w	r9[0x14],r8
	TxBuffer[1].payload_channel.dword[0] = PAYLOADIDLE0;
80005034:	93 68       	st.w	r9[0x18],r8
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;
80005036:	93 7e       	st.w	r9[0x1c],lr

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
80005038:	fe 78 00 40 	mov	r8,-65472
8000503c:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
8000503e:	70 be       	ld.w	lr,r8[0x2c]
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
80005040:	f2 ce ff fc 	sub	lr,r9,-4
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
80005044:	91 0e       	st.w	r8[0x0],lr
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
80005046:	91 2a       	st.w	r8[0x8],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
80005048:	91 1b       	st.w	r8[0x4],r11
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
8000504a:	2e c9       	sub	r9,-20
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
8000504c:	91 39       	st.w	r8[0xc],r9
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
8000504e:	91 4a       	st.w	r8[0x10],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80005050:	91 6c       	st.w	r8[0x18],r12
}/*End of local_start_PDC.*/
80005052:	d8 02       	popm	pc
80005054:	00 00       	add	r0,r0
80005056:	46 54       	lddsp	r4,sp[0x194]
80005058:	00 00       	add	r0,r0
8000505a:	46 5c       	lddsp	r12,sp[0x194]
8000505c:	00 00       	add	r0,r0
8000505e:	46 7c       	lddsp	r12,sp[0x19c]

80005060 <register_rx_tx_func>:
Description: register the rx function(callback function)
Called By: phy_init -- physical.c
*/
void register_rx_tx_func(void (*rx_exec)(void *),  void ( *tx_exec)(void *))
{
	 phy_rx_exec = rx_exec;
80005060:	48 38       	lddpc	r8,8000506c <register_rx_tx_func+0xc>
80005062:	91 0c       	st.w	r8[0x0],r12
	 phy_tx_exec = tx_exec;//phy_tx_func, phy_rx_func
80005064:	48 38       	lddpc	r8,80005070 <register_rx_tx_func+0x10>
80005066:	91 0b       	st.w	r8[0x0],r11
	 
}/*End of register_tx_rx_func.*/
80005068:	5e fc       	retal	r12
8000506a:	00 00       	add	r0,r0
8000506c:	00 00       	add	r0,r0
8000506e:	10 78       	tst	r8,r8
80005070:	00 00       	add	r0,r0
80005072:	10 7c       	tst	r12,r8

80005074 <ssc_init>:
    local_start_SSC -- ssc.c
    local_start_PDC -- ssc.c
Called By: phy_init -- physical.c
*/
void ssc_init(void)
{		
80005074:	d4 01       	pushm	lr
    /*Set up PB03 to watch FS.*/
    AVR32_GPIO.port[1].oderc = 0x00000002;
80005076:	fe 78 10 00 	mov	r8,-61440
8000507a:	30 29       	mov	r9,2
8000507c:	f1 49 01 48 	st.w	r8[328],r9
    AVR32_GPIO.port[1].gpers = 0x00000002;
80005080:	f1 49 01 04 	st.w	r8[260],r9

    /*Waits for radio to start making FSYNC.*/
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
80005084:	10 99       	mov	r9,r8
80005086:	f2 f8 01 60 	ld.w	r8,r9[352]
8000508a:	e2 18 00 02 	andl	r8,0x2,COH
8000508e:	cf c0       	breq	80005086 <ssc_init+0x12>
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
80005090:	fe 79 10 00 	mov	r9,-61440
80005094:	f2 f8 01 60 	ld.w	r8,r9[352]
80005098:	e2 18 00 02 	andl	r8,0x2,COH
8000509c:	cf c1       	brne	80005094 <ssc_init+0x20>
				
    INTC_register_interrupt (
8000509e:	30 3a       	mov	r10,3
800050a0:	36 0b       	mov	r11,96
800050a2:	48 bc       	lddpc	r12,800050cc <ssc_init+0x58>
800050a4:	f0 1f 00 0b 	mcall	800050d0 <ssc_init+0x5c>
        , AVR32_PDCA_IRQ_0
        , AVR32_INTC_INT3
    );
				
    /*config the SSC*/
    local_start_SSC();
800050a8:	f0 1f 00 0b 	mcall	800050d4 <ssc_init+0x60>

    /*config the PDCA*/
    local_start_PDC();
800050ac:	f0 1f 00 0b 	mcall	800050d8 <ssc_init+0x64>
		
    /*Start the SSC Physical Layer.*/

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
800050b0:	fe 79 00 00 	mov	r9,-65536
800050b4:	30 18       	mov	r8,1
800050b6:	93 58       	st.w	r9[0x14],r8
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
800050b8:	fe 7a 00 40 	mov	r10,-65472
800050bc:	95 58       	st.w	r10[0x14],r8
    (&AVR32_SSC)->cr = AVR32_SSC_CR_RXEN_MASK | AVR32_SSC_CR_TXEN_MASK;
800050be:	e0 6b 01 01 	mov	r11,257
800050c2:	fe 7a 34 00 	mov	r10,-52224
800050c6:	95 0b       	st.w	r10[0x0],r11
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->ier = 
800050c8:	93 88       	st.w	r9[0x20],r8
                                                            AVR32_PDCA_RCZ_MASK;
}/*End of ssc_init.*/
800050ca:	d8 02       	popm	pc
800050cc:	80 00       	ld.sh	r0,r0[0x0]
800050ce:	4f 3c       	lddpc	r12,80005298 <xcmp_exec_func+0x38>
800050d0:	80 00       	ld.sh	r0,r0[0x0]
800050d2:	5c bc       	swap.b	r12
800050d4:	80 00       	ld.sh	r0,r0[0x0]
800050d6:	4f b0       	lddpc	r0,800052c0 <xcmp_init+0x18>
800050d8:	80 00       	ld.sh	r0,r0[0x0]
800050da:	4f f4       	lddpc	r4,800052d4 <xcmp_init+0x2c>

800050dc <xcmp_register_app_list>:
Calls: 
Called By: app_init -- app.c
*/
void xcmp_register_app_list(void * list)
{
	app_list = (app_exec_t *)list;
800050dc:	48 28       	lddpc	r8,800050e4 <xcmp_register_app_list+0x8>
800050de:	91 0c       	st.w	r8[0x0],r12
}
800050e0:	5e fc       	retal	r12
800050e2:	00 00       	add	r0,r0
800050e4:	00 00       	add	r0,r0
800050e6:	46 9c       	lddsp	r12,sp[0x1a4]

800050e8 <xcmp_tx>:
Calls:   
	xnl_tx -- xnl.c
Called By: ...
*/
static void xcmp_tx( xcmp_fragment_t * xcmp, U8 payload_len)
{
800050e8:	eb cd 40 80 	pushm	r7,lr
800050ec:	fa cd 01 00 	sub	sp,sp,256
800050f0:	16 97       	mov	r7,r11
	Length :xnl length + checksum
	= checksum + xnl header + xcmp opcode + xcmp payload
	= 0x02 + 0x0C + 0x02 + xcmp payload
	= 0x10 + xcmp payload
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | ( 0x10 + payload_len);
800050f2:	16 98       	mov	r8,r11
800050f4:	2f 08       	sub	r8,-16
800050f6:	af a8       	sbr	r8,0xe
800050f8:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE; 
800050fa:	3f f8       	mov	r8,-1
800050fc:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG;
800050fe:	30 b9       	mov	r9,11
80005100:	ba 29       	st.h	sp[0x4],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;	
80005102:	ba 38       	st.h	sp[0x6],r8
	xnl_frame.xnl_header.destination = DEFAULT_VALUE;
80005104:	ba 48       	st.h	sp[0x8],r8
	xnl_frame.xnl_header.source = DEFAULT_VALUE;	
80005106:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80005108:	ba 68       	st.h	sp[0xc],r8
	
	/*insert xcmp frame data*/
	memcpy(&xnl_frame.xnl_payload.xnl_content_data_msg, xcmp, payload_len + 2);
8000510a:	f6 ca ff fe 	sub	r10,r11,-2
8000510e:	18 9b       	mov	r11,r12
80005110:	fa cc ff f0 	sub	r12,sp,-16
80005114:	f0 1f 00 05 	mcall	80005128 <xcmp_tx+0x40>
	xnl_frame.xnl_header.payload_length = payload_len + 2;	
80005118:	2f e7       	sub	r7,-2
8000511a:	ba 77       	st.h	sp[0xe],r7
	
	/* send xnl frame*/	
	xnl_tx(&xnl_frame);
8000511c:	1a 9c       	mov	r12,sp
8000511e:	f0 1f 00 04 	mcall	8000512c <xcmp_tx+0x44>
}
80005122:	2c 0d       	sub	sp,-256
80005124:	e3 cd 80 80 	ldm	sp++,r7,pc
80005128:	80 00       	ld.sh	r0,r0[0x0]
8000512a:	a9 06       	ld.d	r6,r4
8000512c:	80 00       	ld.sh	r0,r0[0x0]
8000512e:	55 a4       	stdsp	sp[0x168],r4

80005130 <xcmp_exit_device_control_mode>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_exit_device_control_mode(void)
{
80005130:	d4 01       	pushm	lr
80005132:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DEVICE_CONTROL_MODE;
80005136:	e0 68 04 21 	mov	r8,1057
8000513a:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceControlMode_req_t * ptr = (DeviceControlMode_req_t *)xcmp_farme.u8;
8000513c:	fa c8 ff fc 	sub	r8,sp,-4
	
	ptr->Function = DCM_EXIT;
80005140:	30 09       	mov	r9,0
80005142:	b0 89       	st.b	r8[0x0],r9
	ptr->ControlTypeSize = 1;
80005144:	30 19       	mov	r9,1
80005146:	b0 99       	st.b	r8[0x1],r9
	ptr->ControlType = 0x03;//DCM_SPEAKER_CTRL;
80005148:	30 39       	mov	r9,3
8000514a:	b0 a9       	st.b	r8[0x2],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(DeviceControlMode_req_t));
8000514c:	30 3b       	mov	r11,3
8000514e:	fa cc ff fe 	sub	r12,sp,-2
80005152:	f0 1f 00 03 	mcall	8000515c <xcmp_exit_device_control_mode+0x2c>
}
80005156:	2c dd       	sub	sp,-204
80005158:	d8 02       	popm	pc
8000515a:	00 00       	add	r0,r0
8000515c:	80 00       	ld.sh	r0,r0[0x0]
8000515e:	50 e8       	stdsp	sp[0x38],r8

80005160 <xcmp_enter_device_control_mode>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_enter_device_control_mode(void)
{
80005160:	d4 01       	pushm	lr
80005162:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DEVICE_CONTROL_MODE;
80005166:	e0 68 04 21 	mov	r8,1057
8000516a:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceControlMode_req_t * ptr = (DeviceControlMode_req_t *)xcmp_farme.u8;
8000516c:	fa c8 ff fc 	sub	r8,sp,-4
	
	ptr->Function = DCM_ENTER;
80005170:	30 19       	mov	r9,1
80005172:	b0 89       	st.b	r8[0x0],r9
	ptr->ControlTypeSize = 1;
80005174:	b0 99       	st.b	r8[0x1],r9
	ptr->ControlType = 0x03;// 0xEB;//user-input
80005176:	30 39       	mov	r9,3
80005178:	b0 a9       	st.b	r8[0x2],r9
	//ptr->ControlType = DCM_SPEAKER_CTRL;
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(DeviceControlMode_req_t));
8000517a:	30 3b       	mov	r11,3
8000517c:	fa cc ff fe 	sub	r12,sp,-2
80005180:	f0 1f 00 02 	mcall	80005188 <xcmp_enter_device_control_mode+0x28>
}
80005184:	2c dd       	sub	sp,-204
80005186:	d8 02       	popm	pc
80005188:	80 00       	ld.sh	r0,r0[0x0]
8000518a:	50 e8       	stdsp	sp[0x38],r8

8000518c <xcmp_audio_route_AMBE>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_audio_route_AMBE(void)
{
8000518c:	d4 01       	pushm	lr
8000518e:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | AUDIO_ROUTING_CONTROL;
80005192:	e0 68 04 14 	mov	r8,1044
80005196:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	AudioRoutingControl_req_t * ptr = (AudioRoutingControl_req_t *)xcmp_farme.u8;
80005198:	fa c8 ff fc 	sub	r8,sp,-4
	
	ptr->Function = Routing_Func_Update_Source;
8000519c:	30 19       	mov	r9,1
8000519e:	b0 89       	st.b	r8[0x0],r9
	
	
	unsigned short NumberofRoutings = 4;//2;
	ptr->NumberofRoutings[0] = (NumberofRoutings >> 8) & 0xFF;
800051a0:	30 09       	mov	r9,0
800051a2:	b0 99       	st.b	r8[0x1],r9
	ptr->NumberofRoutings[1] =  NumberofRoutings & 0xFF;
800051a4:	30 49       	mov	r9,4
800051a6:	b0 a9       	st.b	r8[0x2],r9
	
	//ptr->RoutingData[0].audioInput = IN_Microphone;//Post_AMBE_Encoder;//IN_Pre_Speaker_Audio_Data;//IN_Microphone;//IN_Option_Board;
	//ptr->RoutingData[0].audioOutput = OUT_Option_Board;//Post_AMBE_Encoder;//OUT_Microphone_Data;//
	//
	ptr->RoutingData[0].audioInput = Post_AMBE_Encoder;//IN_Option_Board;
800051a8:	30 fa       	mov	r10,15
800051aa:	b0 ba       	st.b	r8[0x3],r10
	ptr->RoutingData[0].audioOutput = OUT_Option_Board;// OUT_Speaker;
800051ac:	30 c9       	mov	r9,12
800051ae:	b0 c9       	st.b	r8[0x4],r9
	ptr->RoutingData[1].audioInput = IN_Option_Board;//IN_Option_Board;
800051b0:	b0 d9       	st.b	r8[0x5],r9
	ptr->RoutingData[1].audioOutput = Post_AMBE_Encoder;// OUT_Speaker;
800051b2:	b0 ea       	st.b	r8[0x6],r10

	
	ptr->RoutingData[2].audioInput = Tx_Voice_Header;//IN_Option_Board;
800051b4:	31 1a       	mov	r10,17
800051b6:	b0 fa       	st.b	r8[0x7],r10
	ptr->RoutingData[2].audioOutput = OUT_Option_Board;// OUT_Speaker;
800051b8:	f1 69 00 08 	st.b	r8[8],r9
	//ptr->RoutingData[3].audioInput = IN_Option_Board;//IN_Option_Board;
	//ptr->RoutingData[3].audioOutput = Tx_Voice_Header;// OUT_Speaker;
	
	ptr->RoutingData[3].audioInput = Tx_Voice_Terminator;//IN_Option_Board;
800051bc:	31 3a       	mov	r10,19
800051be:	f1 6a 00 09 	st.b	r8[9],r10
	ptr->RoutingData[3].audioOutput = OUT_Option_Board;// OUT_Speaker;
800051c2:	f1 69 00 0a 	st.b	r8[10],r9
	
	//ptr->RoutingData[1].audioInput = IN_Option_Board;
	//ptr->RoutingData[1].audioOutput = OUT_Microphone_Data;//OUT_Speaker;//
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(AudioRoutingControl_req_t) - (MAX_ROUTING_CTR - NumberofRoutings) * sizeof(RoutingData_t));
800051c6:	30 bb       	mov	r11,11
800051c8:	fa cc ff fe 	sub	r12,sp,-2
800051cc:	f0 1f 00 02 	mcall	800051d4 <xcmp_audio_route_AMBE+0x48>
}
800051d0:	2c dd       	sub	sp,-204
800051d2:	d8 02       	popm	pc
800051d4:	80 00       	ld.sh	r0,r0[0x0]
800051d6:	50 e8       	stdsp	sp[0x38],r8

800051d8 <xcmp_enter_enhanced_OB_mode>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_enter_enhanced_OB_mode(void)
{
800051d8:	d4 01       	pushm	lr
800051da:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | EN_OB_CONTROL;
800051de:	e0 68 04 65 	mov	r8,1125
800051e2:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	En_OB_Control_req_t * ptr = (En_OB_Control_req_t *)xcmp_farme.u8;
	
	ptr->Function = EN_OB_Enter;
800051e4:	fa cc ff fe 	sub	r12,sp,-2
800051e8:	30 18       	mov	r8,1
800051ea:	b8 a8       	st.b	r12[0x2],r8
		
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(En_OB_Control_req_t));
800051ec:	30 1b       	mov	r11,1
800051ee:	f0 1f 00 03 	mcall	800051f8 <xcmp_enter_enhanced_OB_mode+0x20>
}
800051f2:	2c dd       	sub	sp,-204
800051f4:	d8 02       	popm	pc
800051f6:	00 00       	add	r0,r0
800051f8:	80 00       	ld.sh	r0,r0[0x0]
800051fa:	50 e8       	stdsp	sp[0x38],r8

800051fc <xcmp_DeviceInitializationStatus_request>:
Description: send device initialization status request
Calls: xcmp_tx
Called By:...
*/
void xcmp_DeviceInitializationStatus_request(void)
{
800051fc:	d4 01       	pushm	lr
800051fe:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
		
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_BRDCAST | DEVICE_INITIALIZATION_STATUS;
80005202:	fe 78 b4 00 	mov	r8,-19456
80005206:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceInitializationStatus_brdcst_t * ptr 
						 = (DeviceInitializationStatus_brdcst_t *)xcmp_farme.u8;
80005208:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*xcmp version 8.1.0.5*///
	ptr->XCMPVersion[0] = 0x08;
8000520c:	30 89       	mov	r9,8
8000520e:	b0 89       	st.b	r8[0x0],r9
	ptr->XCMPVersion[1] = 0x01;
80005210:	30 19       	mov	r9,1
80005212:	b0 99       	st.b	r8[0x1],r9
	ptr->XCMPVersion[2] = 0x00;
80005214:	30 09       	mov	r9,0
80005216:	b0 a9       	st.b	r8[0x2],r9
	ptr->XCMPVersion[3] = 0x05;
80005218:	30 5a       	mov	r10,5
8000521a:	b0 ba       	st.b	r8[0x3],r10
	/*
	0x00:
	This is the message that the device sends at power up or after a reset. It 
	will give the initial status and capabilities for the device.
	*/
	ptr->DeviceInitType = 0x00;
8000521c:	b0 c9       	st.b	r8[0x4],r9
	types of devices may provide a set of services to the radio system, but do 
	not have the ability to be the master.
	
	0x07:OptionBoard,3rd party Option Board-based application.
	*/
	ptr->DeviceStatusInfo.DeviceType = 0x07;
8000521e:	30 7a       	mov	r10,7
80005220:	b0 da       	st.b	r8[0x5],r10
	
	/*Power Up Success, Device has powered up with no errors*/
	ptr->DeviceStatusInfo.DeviceStatus[0] = 0x00;
80005222:	b0 e9       	st.b	r8[0x6],r9
	ptr->DeviceStatusInfo.DeviceStatus[1] = 0x00;
80005224:	b0 f9       	st.b	r8[0x7],r9
	
	/*
	This number is the size of the Device Descriptor data structure with a 
	maximum size not exceeding 255 bytes.
	*/
	ptr->DeviceStatusInfo.DeviceDescriptorSize = 0x00;
80005226:	f1 69 00 08 	st.b	r8[8],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme
8000522a:	30 9b       	mov	r11,9
8000522c:	fa cc ff fe 	sub	r12,sp,-2
80005230:	f0 1f 00 02 	mcall	80005238 <xcmp_DeviceInitializationStatus_request+0x3c>
		, sizeof(DeviceInitializationStatus_brdcst_t) - MAX_DEVICE_DESC_SIZE);
}
80005234:	2c dd       	sub	sp,-204
80005236:	d8 02       	popm	pc
80005238:	80 00       	ld.sh	r0,r0[0x0]
8000523a:	50 e8       	stdsp	sp[0x38],r8

8000523c <xcmp_opcode_not_supported>:
Description: register the app list
Calls: xcmp_tx
Called By:...
*/
void xcmp_opcode_not_supported( void )
{
8000523c:	d4 01       	pushm	lr
8000523e:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REPLY;
80005242:	fe 78 80 00 	mov	r8,-32768
80005246:	ba 18       	st.h	sp[0x2],r8
	
	/*The radio does not support this opcode.*/
	xcmp_farme.u8[0] = xcmp_Res_Opcode_Not_Supported;
80005248:	30 38       	mov	r8,3
8000524a:	ba c8       	st.b	sp[0x4],r8
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, 1);
8000524c:	30 1b       	mov	r11,1
8000524e:	fa cc ff fe 	sub	r12,sp,-2
80005252:	f0 1f 00 03 	mcall	8000525c <xcmp_opcode_not_supported+0x20>
}
80005256:	2c dd       	sub	sp,-204
80005258:	d8 02       	popm	pc
8000525a:	00 00       	add	r0,r0
8000525c:	80 00       	ld.sh	r0,r0[0x0]
8000525e:	50 e8       	stdsp	sp[0x38],r8

80005260 <xcmp_exec_func>:
Description: Perform XCMP corresponding functions
Calls:   
Called By: xcmp_rx_process--task
*/
static void xcmp_exec_func(app_exec_t * exec, xcmp_fragment_t * xcmp)
{
80005260:	d4 01       	pushm	lr
	/*The message types*/
	switch(xcmp->xcmp_opcode & 0xF000)
80005262:	96 88       	ld.uh	r8,r11[0x0]
80005264:	e2 18 f0 00 	andl	r8,0xf000,COH
80005268:	e0 48 80 00 	cp.w	r8,32768
8000526c:	c0 f0       	breq	8000528a <xcmp_exec_func+0x2a>
8000526e:	e0 48 b0 00 	cp.w	r8,45056
80005272:	c1 20       	breq	80005296 <xcmp_exec_func+0x36>
80005274:	58 08       	cp.w	r8,0
80005276:	c1 51       	brne	800052a0 <xcmp_exec_func+0x40>
	{
		case XCMP_REQUEST:
			if(NULL != exec->xcmp_rx_req)
80005278:	78 08       	ld.w	r8,r12[0x0]
8000527a:	58 08       	cp.w	r8,0
8000527c:	c0 40       	breq	80005284 <xcmp_exec_func+0x24>
			{
				exec->xcmp_rx_req(xcmp);
8000527e:	16 9c       	mov	r12,r11
80005280:	5d 18       	icall	r8
80005282:	d8 02       	popm	pc
			}
			else 
			{
				/*No function to register the request message*/
				/*send not supported opcode to raido */
				xcmp_opcode_not_supported();
80005284:	f0 1f 00 08 	mcall	800052a4 <xcmp_exec_func+0x44>
80005288:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_REPLY:		
			if(NULL != exec->xcmp_rx_reply)
8000528a:	78 18       	ld.w	r8,r12[0x4]
8000528c:	58 08       	cp.w	r8,0
8000528e:	c0 90       	breq	800052a0 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_reply(xcmp);
80005290:	16 9c       	mov	r12,r11
80005292:	5d 18       	icall	r8
80005294:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_BRDCAST:	
			if(NULL != exec->xcmp_rx_brdcst)
80005296:	78 28       	ld.w	r8,r12[0x8]
80005298:	58 08       	cp.w	r8,0
8000529a:	c0 30       	breq	800052a0 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_brdcst(xcmp);
8000529c:	16 9c       	mov	r12,r11
8000529e:	5d 18       	icall	r8
800052a0:	d8 02       	popm	pc
800052a2:	00 00       	add	r0,r0
800052a4:	80 00       	ld.sh	r0,r0[0x0]
800052a6:	52 3c       	stdsp	sp[0x8c],r12

800052a8 <xcmp_init>:
	xQueueCreate -- freertos
	xTaskCreate -- freertos
Called By: main -- main.c
*/
void xcmp_init(void)
{
800052a8:	d4 01       	pushm	lr
	/*initialize the xnl*/
	xnl_init();
800052aa:	f0 1f 00 0d 	mcall	800052dc <xcmp_init+0x34>
	
	/*register the xcmp function(callback function)*/
	xnl_register_xcmp_func( xcmp_rx );
800052ae:	48 dc       	lddpc	r12,800052e0 <xcmp_init+0x38>
800052b0:	f0 1f 00 0d 	mcall	800052e4 <xcmp_init+0x3c>
	
	/*initialize the queue*/
	//xcmp_frame_rx = xQueueCreate(10, sizeof(xcmp_fragment_t *));
	
	xcmp_frame_rx = xQueueCreate(20, sizeof(xcmp_fragment_t *));
800052b4:	30 4b       	mov	r11,4
800052b6:	31 4c       	mov	r12,20
800052b8:	f0 1f 00 0c 	mcall	800052e8 <xcmp_init+0x40>
800052bc:	48 c8       	lddpc	r8,800052ec <xcmp_init+0x44>
800052be:	91 0c       	st.w	r8[0x0],r12
	/*create task*/	
	/*this task is used to execute xcmp message*/
	xTaskCreate(
800052c0:	30 09       	mov	r9,0
800052c2:	1a d9       	st.w	--sp,r9
800052c4:	1a d9       	st.w	--sp,r9
800052c6:	1a d9       	st.w	--sp,r9
800052c8:	30 38       	mov	r8,3
800052ca:	e0 6a 01 80 	mov	r10,384
800052ce:	48 9b       	lddpc	r11,800052f0 <xcmp_init+0x48>
800052d0:	48 9c       	lddpc	r12,800052f4 <xcmp_init+0x4c>
800052d2:	f0 1f 00 0a 	mcall	800052f8 <xcmp_init+0x50>
800052d6:	2f dd       	sub	sp,-12
	,  384
	,  NULL
	,  tskXCMP_PRIORITY
	,  NULL
	);
}
800052d8:	d8 02       	popm	pc
800052da:	00 00       	add	r0,r0
800052dc:	80 00       	ld.sh	r0,r0[0x0]
800052de:	56 88       	stdsp	sp[0x1a0],r8
800052e0:	80 00       	ld.sh	r0,r0[0x0]
800052e2:	53 f8       	stdsp	sp[0xfc],r8
800052e4:	80 00       	ld.sh	r0,r0[0x0]
800052e6:	54 44       	stdsp	sp[0x110],r4
800052e8:	80 00       	ld.sh	r0,r0[0x0]
800052ea:	94 a8       	ld.uh	r8,r10[0x4]
800052ec:	00 00       	add	r0,r0
800052ee:	10 8c       	andn	r12,r8
800052f0:	80 01       	ld.sh	r1,r0[0x0]
800052f2:	8e 94       	ld.uh	r4,r7[0x2]
800052f4:	80 00       	ld.sh	r0,r0[0x0]
800052f6:	52 fc       	stdsp	sp[0xbc],r12
800052f8:	80 00       	ld.sh	r0,r0[0x0]
800052fa:	9b 7c       	st.w	sp[0x1c],r12

800052fc <xcmp_rx_process>:
Calls: xQueueReceive -- freerots
	xcmp_exec_func
Called By: task
*/
static void xcmp_rx_process(void * pvParameters)
{
800052fc:	d4 31       	pushm	r0-r7,lr
800052fe:	20 1d       	sub	sp,4
	xcmp_fragment_t xcmp;
	xcmp_fragment_t * ptr;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//10ms
80005300:	4b 16       	lddpc	r6,800053c4 <xcmp_rx_process+0xc8>
80005302:	30 05       	mov	r5,0
80005304:	31 44       	mov	r4,20
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
80005306:	4b 13       	lddpc	r3,800053c8 <xcmp_rx_process+0xcc>
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
					break;
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
80005308:	4b 12       	lddpc	r2,800053cc <xcmp_rx_process+0xd0>
						, ptr);
					break;
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
8000530a:	4b 21       	lddpc	r1,800053d0 <xcmp_rx_process+0xd4>
					break;
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
8000530c:	4b 20       	lddpc	r0,800053d4 <xcmp_rx_process+0xd8>
	xcmp_fragment_t xcmp;
	xcmp_fragment_t * ptr;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//10ms
8000530e:	6c 0c       	ld.w	r12,r6[0x0]
80005310:	0a 99       	mov	r9,r5
80005312:	08 9a       	mov	r10,r4
80005314:	1a 9b       	mov	r11,sp
80005316:	f0 1f 00 31 	mcall	800053d8 <xcmp_rx_process+0xdc>
8000531a:	58 1c       	cp.w	r12,1
8000531c:	cf 91       	brne	8000530e <xcmp_rx_process+0x12>
		{									
			if(NULL == ptr)
8000531e:	40 0b       	lddsp	r11,sp[0x0]
80005320:	58 0b       	cp.w	r11,0
80005322:	cf 60       	breq	8000530e <xcmp_rx_process+0x12>
				continue;
			}
			
			//log("\n\r R_xcmp : %4x \n\r",ptr->xcmp_opcode);//log:R_xcmp	
						
			switch(ptr->xcmp_opcode & 0x0FFF)
80005324:	96 0a       	ld.sh	r10,r11[0x0]
80005326:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
8000532a:	f1 d9 c0 0c 	bfextu	r8,r9,0x0,0xc
8000532e:	59 c8       	cp.w	r8,28
80005330:	c1 e0       	breq	8000536c <xcmp_rx_process+0x70>
80005332:	e0 89 00 07 	brgt	80005340 <xcmp_rx_process+0x44>
80005336:	58 e8       	cp.w	r8,14
80005338:	c0 e0       	breq	80005354 <xcmp_rx_process+0x58>
8000533a:	58 f8       	cp.w	r8,15
8000533c:	c2 41       	brne	80005384 <xcmp_rx_process+0x88>
8000533e:	c0 f8       	rjmp	8000535c <xcmp_rx_process+0x60>
80005340:	e0 48 01 09 	cp.w	r8,265
80005344:	c1 80       	breq	80005374 <xcmp_rx_process+0x78>
80005346:	e0 48 01 0a 	cp.w	r8,266
8000534a:	c1 90       	breq	8000537c <xcmp_rx_process+0x80>
8000534c:	e0 48 00 2c 	cp.w	r8,44
80005350:	c1 a1       	brne	80005384 <xcmp_rx_process+0x88>
80005352:	c0 98       	rjmp	80005364 <xcmp_rx_process+0x68>
			{
				case RADIO_STATUS:				
					xcmp_exec_func(&radio_status, ptr);
80005354:	4a 2c       	lddpc	r12,800053dc <xcmp_rx_process+0xe0>
80005356:	f0 1f 00 23 	mcall	800053e0 <xcmp_rx_process+0xe4>
					break;
8000535a:	c2 f8       	rjmp	800053b8 <xcmp_rx_process+0xbc>
					
				case VERSION_INFORMATION:
					xcmp_exec_func(&version_information, ptr);
8000535c:	4a 2c       	lddpc	r12,800053e4 <xcmp_rx_process+0xe8>
8000535e:	f0 1f 00 21 	mcall	800053e0 <xcmp_rx_process+0xe4>
					break;
80005362:	c2 b8       	rjmp	800053b8 <xcmp_rx_process+0xbc>
					
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
80005364:	4a 1c       	lddpc	r12,800053e8 <xcmp_rx_process+0xec>
80005366:	f0 1f 00 1f 	mcall	800053e0 <xcmp_rx_process+0xe4>
					break;
8000536a:	c2 78       	rjmp	800053b8 <xcmp_rx_process+0xbc>
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
8000536c:	04 9c       	mov	r12,r2
8000536e:	f0 1f 00 1d 	mcall	800053e0 <xcmp_rx_process+0xe4>
						, ptr);
					break;
80005372:	c2 38       	rjmp	800053b8 <xcmp_rx_process+0xbc>
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
80005374:	02 9c       	mov	r12,r1
80005376:	f0 1f 00 1b 	mcall	800053e0 <xcmp_rx_process+0xe4>
					break;
8000537a:	c1 f8       	rjmp	800053b8 <xcmp_rx_process+0xbc>
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
8000537c:	00 9c       	mov	r12,r0
8000537e:	f0 1f 00 19 	mcall	800053e0 <xcmp_rx_process+0xe4>
					break;
80005382:	c1 b8       	rjmp	800053b8 <xcmp_rx_process+0xbc>
					
				default:
				
					/*the xcmp message not in order list*/
					/*over the length of the list*/
					if((0x0400 != (ptr->xcmp_opcode & 0x0400)) 
80005384:	12 98       	mov	r8,r9
80005386:	e2 18 04 00 	andl	r8,0x400,COH
8000538a:	c0 70       	breq	80005398 <xcmp_rx_process+0x9c>
8000538c:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
80005390:	e0 48 00 68 	cp.w	r8,104
80005394:	e0 8a 00 08 	brle	800053a4 <xcmp_rx_process+0xa8>
						|| (MAX_APP_FUNC <= (ptr->xcmp_opcode & 0x00FF))
					)
					{
						/*xcmp request*/
						if( XCMP_REQUEST == (ptr->xcmp_opcode & 0xF000))
80005398:	e2 19 f0 00 	andl	r9,0xf000,COH
8000539c:	c0 e1       	brne	800053b8 <xcmp_rx_process+0xbc>
						{
							/*send not supported opcode to raido */
							xcmp_opcode_not_supported();
8000539e:	f0 1f 00 14 	mcall	800053ec <xcmp_rx_process+0xf0>
800053a2:	c0 b8       	rjmp	800053b8 <xcmp_rx_process+0xbc>
						}
					}
					else
					{					
						xcmp_exec_func( &app_list[ptr->xcmp_opcode & 0x00FF]
800053a4:	f9 da c0 08 	bfextu	r12,r10,0x0,0x8
800053a8:	f8 0c 00 1c 	add	r12,r12,r12<<0x1
800053ac:	49 19       	lddpc	r9,800053f0 <xcmp_rx_process+0xf4>
800053ae:	72 08       	ld.w	r8,r9[0x0]
800053b0:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800053b4:	f0 1f 00 0b 	mcall	800053e0 <xcmp_rx_process+0xe4>
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
800053b8:	66 0c       	ld.w	r12,r3[0x0]
800053ba:	40 0b       	lddsp	r11,sp[0x0]
800053bc:	f0 1f 00 0e 	mcall	800053f4 <xcmp_rx_process+0xf8>
800053c0:	ca 7b       	rjmp	8000530e <xcmp_rx_process+0x12>
800053c2:	00 00       	add	r0,r0
800053c4:	00 00       	add	r0,r0
800053c6:	10 8c       	andn	r12,r8
800053c8:	00 00       	add	r0,r0
800053ca:	10 38       	cp.w	r8,r8
800053cc:	00 00       	add	r0,r0
800053ce:	10 9c       	mov	r12,r8
800053d0:	00 00       	add	r0,r0
800053d2:	10 90       	mov	r0,r8
800053d4:	00 00       	add	r0,r0
800053d6:	10 a8       	st.w	r8++,r8
800053d8:	80 00       	ld.sh	r0,r0[0x0]
800053da:	91 44       	st.w	r8[0x10],r4
800053dc:	00 00       	add	r0,r0
800053de:	10 c0       	st.b	r8++,r0
800053e0:	80 00       	ld.sh	r0,r0[0x0]
800053e2:	52 60       	stdsp	sp[0x98],r0
800053e4:	00 00       	add	r0,r0
800053e6:	10 80       	andn	r0,r8
800053e8:	00 00       	add	r0,r0
800053ea:	10 b4       	st.h	r8++,r4
800053ec:	80 00       	ld.sh	r0,r0[0x0]
800053ee:	52 3c       	stdsp	sp[0x8c],r12
800053f0:	00 00       	add	r0,r0
800053f2:	46 9c       	lddsp	r12,sp[0x1a4]
800053f4:	80 00       	ld.sh	r0,r0[0x0]
800053f6:	3d 2c       	mov	r12,-46

800053f8 <xcmp_rx>:
Calls:   
	xQueueSend -- xnl.c
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
800053f8:	eb cd 40 90 	pushm	r4,r7,lr
800053fc:	20 1d       	sub	sp,4
800053fe:	fa c4 ff f0 	sub	r4,sp,-16
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
80005402:	48 c8       	lddpc	r8,80005430 <xcmp_rx+0x38>
80005404:	70 0c       	ld.w	r12,r8[0x0]
80005406:	f0 1f 00 0c 	mcall	80005434 <xcmp_rx+0x3c>
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
8000540a:	c1 00       	breq	8000542a <xcmp_rx+0x32>
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
8000540c:	fa c7 ff fc 	sub	r7,sp,-4
80005410:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
	{
		memcpy(xcmp_ptr, &xcmp, sizeof(xcmp_fragment_t));				
80005412:	e0 6a 00 ca 	mov	r10,202
80005416:	08 9b       	mov	r11,r4
80005418:	f0 1f 00 08 	mcall	80005438 <xcmp_rx+0x40>
		xQueueSend(xcmp_frame_rx, &xcmp_ptr, 0);	
8000541c:	48 88       	lddpc	r8,8000543c <xcmp_rx+0x44>
8000541e:	70 0c       	ld.w	r12,r8[0x0]
80005420:	30 09       	mov	r9,0
80005422:	12 9a       	mov	r10,r9
80005424:	1a 9b       	mov	r11,sp
80005426:	f0 1f 00 07 	mcall	80005440 <xcmp_rx+0x48>
	}	
}
8000542a:	2f fd       	sub	sp,-4
8000542c:	e3 cd 80 90 	ldm	sp++,r4,r7,pc
80005430:	00 00       	add	r0,r0
80005432:	10 38       	cp.w	r8,r8
80005434:	80 00       	ld.sh	r0,r0[0x0]
80005436:	43 8c       	lddsp	r12,sp[0xe0]
80005438:	80 00       	ld.sh	r0,r0[0x0]
8000543a:	a9 06       	ld.d	r6,r4
8000543c:	00 00       	add	r0,r0
8000543e:	10 8c       	andn	r12,r8
80005440:	80 00       	ld.sh	r0,r0[0x0]
80005442:	93 50       	st.w	r9[0x14],r0

80005444 <xnl_register_xcmp_func>:
Function: xnl_register_xcmp_func
Description: register the xcmp function(callback function)
*/
void xnl_register_xcmp_func( void ( *func)(xnl_content_data_msg_t))
{
	 xcmp_exec = func;
80005444:	48 28       	lddpc	r8,8000544c <xnl_register_xcmp_func+0x8>
80005446:	91 0c       	st.w	r8[0x0],r12
}
80005448:	5e fc       	retal	r12
8000544a:	00 00       	add	r0,r0
8000544c:	00 00       	add	r0,r0
8000544e:	10 f0       	st.b	--r8,r0

80005450 <xnl_get_msg_ack_func>:
Description: process while receive msg ack.
Calls:xSemaphoreGive--freertos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
80005450:	d4 01       	pushm	lr
	
	DestinationAddress = xnl->xnl_header.destination;
	/*No timeout*/		
	 //One relationship is controlled by a state machine, only the current MSG received the ACK, 
	//then the program will clear the current MSG sending address and out of standby and will jump to the sending state.
	if (DestinationAddress == xnl_information.device_address )
80005452:	48 88       	lddpc	r8,80005470 <xnl_get_msg_ack_func+0x20>
80005454:	90 28       	ld.sh	r8,r8[0x4]
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
	U16 DestinationAddress;
	U16 TransactionID;
	
	DestinationAddress = xnl->xnl_header.destination;
80005456:	98 49       	ld.sh	r9,r12[0x8]
80005458:	f0 09 19 00 	cp.h	r9,r8
8000545c:	c0 81       	brne	8000546c <xnl_get_msg_ack_func+0x1c>
	if (DestinationAddress == xnl_information.device_address )
	{
		//The ack is for me.
		
		TransactionID = xnl->xnl_header.transaction_id;
		xSemaphoreGive(xnl_timeout_semphr);	
8000545e:	48 68       	lddpc	r8,80005474 <xnl_get_msg_ack_func+0x24>
80005460:	70 0c       	ld.w	r12,r8[0x0]
80005462:	30 09       	mov	r9,0
80005464:	12 9a       	mov	r10,r9
80005466:	12 9b       	mov	r11,r9
80005468:	f0 1f 00 04 	mcall	80005478 <xnl_get_msg_ack_func+0x28>
8000546c:	d8 02       	popm	pc
8000546e:	00 00       	add	r0,r0
80005470:	00 00       	add	r0,r0
80005472:	10 d0       	st.w	--r8,r0
80005474:	00 00       	add	r0,r0
80005476:	10 cc       	st.b	r8++,r12
80005478:	80 00       	ld.sh	r0,r0[0x0]
8000547a:	93 50       	st.w	r9[0x14],r0

8000547c <xnl_tx_process>:
	xSemaphoreTake--freertos 
	phy_tx -- physical.c
Called By: task
*/
static void xnl_tx_process(void * pvParameters)
{
8000547c:	d4 31       	pushm	r0-r7,lr
	static  xnl_fragment_t * ptr;//
	
	
	for(;;)
	{		
		switch(xnl_tx_state)
8000547e:	4a 86       	lddpc	r6,8000551c <xnl_tx_process+0xa0>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
80005480:	4a 82       	lddpc	r2,80005520 <xnl_tx_process+0xa4>
80005482:	4a 94       	lddpc	r4,80005524 <xnl_tx_process+0xa8>
80005484:	30 07       	mov	r7,0
80005486:	3f f1       	mov	r1,-1
					if(NULL == ptr)
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
80005488:	30 00       	mov	r0,0
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;
8000548a:	4a 85       	lddpc	r5,80005528 <xnl_tx_process+0xac>
					
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
8000548c:	4a 83       	lddpc	r3,8000552c <xnl_tx_process+0xb0>
	static  xnl_fragment_t * ptr;//
	
	
	for(;;)
	{		
		switch(xnl_tx_state)
8000548e:	6c 08       	ld.w	r8,r6[0x0]
80005490:	58 08       	cp.w	r8,0
80005492:	c0 40       	breq	8000549a <xnl_tx_process+0x1e>
80005494:	58 18       	cp.w	r8,1
80005496:	cf d1       	brne	80005490 <xnl_tx_process+0x14>
80005498:	c2 08       	rjmp	800054d8 <xnl_tx_process+0x5c>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
8000549a:	64 0c       	ld.w	r12,r2[0x0]
8000549c:	0e 99       	mov	r9,r7
8000549e:	02 9a       	mov	r10,r1
800054a0:	08 9b       	mov	r11,r4
800054a2:	f0 1f 00 24 	mcall	80005530 <xnl_tx_process+0xb4>
800054a6:	58 1c       	cp.w	r12,1
800054a8:	cf 31       	brne	8000548e <xnl_tx_process+0x12>
					, portMAX_DELAY ))
				{				
					if(NULL == ptr)
800054aa:	68 0c       	ld.w	r12,r4[0x0]
800054ac:	58 0c       	cp.w	r12,0
800054ae:	cf 00       	breq	8000548e <xnl_tx_process+0x12>
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
800054b0:	98 28       	ld.sh	r8,r12[0x4]
800054b2:	e0 08 19 00 	cp.h	r8,r0
800054b6:	c0 41       	brne	800054be <xnl_tx_process+0x42>
					{
						/*invalid XNL opcode*/
						vPortFree(ptr);
800054b8:	f0 1f 00 1f 	mcall	80005534 <xnl_tx_process+0xb8>
						break;
800054bc:	ce 9b       	rjmp	8000548e <xnl_tx_process+0x12>
					}
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
800054be:	f0 1f 00 1f 	mcall	80005538 <xnl_tx_process+0xbc>
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;
800054c2:	30 18       	mov	r8,1
800054c4:	8b 08       	st.w	r5[0x0],r8
					
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
800054c6:	66 0c       	ld.w	r12,r3[0x0]
800054c8:	0e 99       	mov	r9,r7
800054ca:	0e 9a       	mov	r10,r7
800054cc:	0e 9b       	mov	r11,r7
800054ce:	f0 1f 00 19 	mcall	80005530 <xnl_tx_process+0xb4>
					xnl_tx_state = WAITING_FOR_REPLY;
800054d2:	30 18       	mov	r8,1
800054d4:	8d 08       	st.w	r6[0x0],r8
800054d6:	cd cb       	rjmp	8000548e <xnl_tx_process+0x12>
				}
				break;
			
			/*wait XNL reply*/			
			case WAITING_FOR_REPLY://ACKdata/control
				if(pdTRUE == xSemaphoreTake( xnl_timeout_semphr
800054d8:	66 0c       	ld.w	r12,r3[0x0]
800054da:	0e 99       	mov	r9,r7
800054dc:	36 4a       	mov	r10,100
800054de:	0e 9b       	mov	r11,r7
800054e0:	f0 1f 00 14 	mcall	80005530 <xnl_tx_process+0xb4>
800054e4:	58 1c       	cp.w	r12,1
800054e6:	c0 81       	brne	800054f6 <xnl_tx_process+0x7a>
					, ( portTickType )50*2/ portTICK_RATE_MS))//ADK500ms,freertos
				{
					/*No timeout*/
					//vPortFree(ptr);	
					set_xnl_idle(ptr);			
800054e8:	49 58       	lddpc	r8,8000553c <xnl_tx_process+0xc0>
800054ea:	70 0c       	ld.w	r12,r8[0x0]
800054ec:	68 0b       	ld.w	r11,r4[0x0]
800054ee:	f0 1f 00 15 	mcall	80005540 <xnl_tx_process+0xc4>
					xnl_tx_state = WAITING_FOR_TX;
800054f2:	8d 07       	st.w	r6[0x0],r7
800054f4:	cc db       	rjmp	8000548e <xnl_tx_process+0x12>
				}
				else
				{
					/*time out*/
					if(xnl_send_times <= MIN_RESEND_TIMES)
800054f6:	6a 08       	ld.w	r8,r5[0x0]
800054f8:	58 38       	cp.w	r8,3
800054fa:	e0 89 00 09 	brgt	8000550c <xnl_tx_process+0x90>
					{
						/*If times smaller than A supermarket, then resend the 
						instructions*/
						phy_tx((phy_fragment_t *)ptr);
800054fe:	68 0c       	ld.w	r12,r4[0x0]
80005500:	f0 1f 00 0e 	mcall	80005538 <xnl_tx_process+0xbc>
						xnl_send_times++;
80005504:	6a 08       	ld.w	r8,r5[0x0]
80005506:	2f f8       	sub	r8,-1
80005508:	8b 08       	st.w	r5[0x0],r8
8000550a:	cc 2b       	rjmp	8000548e <xnl_tx_process+0x12>
					}
					else
					{
						//can not send data, disconnected						
						//vPortFree(ptr);	
						set_xnl_idle(ptr);									
8000550c:	48 c8       	lddpc	r8,8000553c <xnl_tx_process+0xc0>
8000550e:	70 0c       	ld.w	r12,r8[0x0]
80005510:	68 0b       	ld.w	r11,r4[0x0]
80005512:	f0 1f 00 0c 	mcall	80005540 <xnl_tx_process+0xc4>
						xnl_tx_state = WAITING_FOR_TX;
80005516:	8d 07       	st.w	r6[0x0],r7
80005518:	cb bb       	rjmp	8000548e <xnl_tx_process+0x12>
8000551a:	00 00       	add	r0,r0
8000551c:	00 00       	add	r0,r0
8000551e:	10 e4       	st.h	--r8,r4
80005520:	00 00       	add	r0,r0
80005522:	10 e0       	st.h	--r8,r0
80005524:	00 00       	add	r0,r0
80005526:	10 dc       	st.w	--r8,r12
80005528:	00 00       	add	r0,r0
8000552a:	10 e8       	st.h	--r8,r8
8000552c:	00 00       	add	r0,r0
8000552e:	10 cc       	st.b	r8++,r12
80005530:	80 00       	ld.sh	r0,r0[0x0]
80005532:	91 44       	st.w	r8[0x10],r4
80005534:	80 00       	ld.sh	r0,r0[0x0]
80005536:	8f d4       	st.w	r7[0x34],r4
80005538:	80 00       	ld.sh	r0,r0[0x0]
8000553a:	3d 4c       	mov	r12,-44
8000553c:	00 00       	add	r0,r0
8000553e:	10 38       	cp.w	r8,r8
80005540:	80 00       	ld.sh	r0,r0[0x0]
80005542:	3d 2c       	mov	r12,-46

80005544 <xnl_rx_process>:
Description: Receive the XNL
Calls: 
Called By:task
*/
static void xnl_rx_process(void * pvParameters)
{
80005544:	eb cd 40 fe 	pushm	r1-r7,lr
80005548:	20 1d       	sub	sp,4
	/*To ptr the elements in the queue*/
	xnl_fragment_t * xnl_ptr;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
8000554a:	49 26       	lddpc	r6,80005590 <xnl_rx_process+0x4c>
8000554c:	30 05       	mov	r5,0
8000554e:	3f f4       	mov	r4,-1
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
80005550:	30 c3       	mov	r3,12
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
80005552:	49 11       	lddpc	r1,80005594 <xnl_rx_process+0x50>
	if(xnl->xnl_header.opcode > 0x0C)	
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
80005554:	49 12       	lddpc	r2,80005598 <xnl_rx_process+0x54>
	/*To ptr the elements in the queue*/
	xnl_fragment_t * xnl_ptr;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
80005556:	6c 0c       	ld.w	r12,r6[0x0]
80005558:	0a 99       	mov	r9,r5
8000555a:	08 9a       	mov	r10,r4
8000555c:	1a 9b       	mov	r11,sp
8000555e:	f0 1f 00 10 	mcall	8000559c <xnl_rx_process+0x58>
80005562:	58 1c       	cp.w	r12,1
80005564:	cf 91       	brne	80005556 <xnl_rx_process+0x12>
		, portMAX_DELAY ))
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
80005566:	40 0c       	lddsp	r12,sp[0x0]
80005568:	58 0c       	cp.w	r12,0
8000556a:	cf 60       	breq	80005556 <xnl_rx_process+0x12>
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
8000556c:	98 28       	ld.sh	r8,r12[0x4]
8000556e:	e6 08 19 00 	cp.h	r8,r3
80005572:	e0 8b 00 0a 	brhi	80005586 <xnl_rx_process+0x42>
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
80005576:	5c 78       	castu.h	r8
80005578:	e4 08 03 29 	ld.w	r9,r2[r8<<0x2]
8000557c:	58 09       	cp.w	r9,0
8000557e:	c0 40       	breq	80005586 <xnl_rx_process+0x42>
	{
		//log("\n\r R_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:R_xnl
		/*execute the function in list*/
		xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec(xnl);
80005580:	e4 08 03 28 	ld.w	r8,r2[r8<<0x2]
80005584:	5d 18       	icall	r8
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
80005586:	62 0c       	ld.w	r12,r1[0x0]
80005588:	40 0b       	lddsp	r11,sp[0x0]
8000558a:	f0 1f 00 06 	mcall	800055a0 <xnl_rx_process+0x5c>
8000558e:	ce 4b       	rjmp	80005556 <xnl_rx_process+0x12>
80005590:	00 00       	add	r0,r0
80005592:	10 4c       	or	r12,r8
80005594:	00 00       	add	r0,r0
80005596:	10 38       	cp.w	r8,r8
80005598:	00 00       	add	r0,r0
8000559a:	04 fc       	st.b	--r2,r12
8000559c:	80 00       	ld.sh	r0,r0[0x0]
8000559e:	91 44       	st.w	r8[0x10],r4
800055a0:	80 00       	ld.sh	r0,r0[0x0]
800055a2:	3d 2c       	mov	r12,-46

800055a4 <xnl_tx>:
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
{
800055a4:	eb cd 40 c0 	pushm	r6-r7,lr
800055a8:	20 1d       	sub	sp,4
800055aa:	18 96       	mov	r6,r12
	message that is sent. The same value should be used for all retries.
	*/
	static U8 flags = 0;
	
	/*If the value is DEFAULT_VALUE, the value will be modified*/
	if(DEFAULT_VALUE == xnl->xnl_header.flags)
800055ac:	98 39       	ld.sh	r9,r12[0x6]
800055ae:	3f f8       	mov	r8,-1
800055b0:	f0 09 19 00 	cp.h	r9,r8
800055b4:	c0 a1       	brne	800055c8 <xnl_tx+0x24>
	{
		xnl->xnl_header.flags =  0x0100 | ((++flags) & 0x07);
800055b6:	4a e9       	lddpc	r9,8000566c <xnl_tx+0xc8>
800055b8:	13 88       	ld.ub	r8,r9[0x0]
800055ba:	2f f8       	sub	r8,-1
800055bc:	5c 58       	castu.b	r8
800055be:	b2 88       	st.b	r9[0x0],r8
800055c0:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
800055c4:	a9 a8       	sbr	r8,0x8
800055c6:	b8 38       	st.h	r12[0x6],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.destination)
800055c8:	8c 49       	ld.sh	r9,r6[0x8]
800055ca:	3f f8       	mov	r8,-1
800055cc:	f0 09 19 00 	cp.h	r9,r8
800055d0:	c0 41       	brne	800055d8 <xnl_tx+0x34>
	{		
		/*Use actual Master address.*/
		xnl->xnl_header.destination = xnl_information.master_address;
800055d2:	4a 88       	lddpc	r8,80005670 <xnl_tx+0xcc>
800055d4:	90 18       	ld.sh	r8,r8[0x2]
800055d6:	ac 48       	st.h	r6[0x8],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.source)
800055d8:	8c 59       	ld.sh	r9,r6[0xa]
800055da:	3f f8       	mov	r8,-1
800055dc:	f0 09 19 00 	cp.h	r9,r8
800055e0:	c0 41       	brne	800055e8 <xnl_tx+0x44>
	{
		/*Use Temporary address.*/	
		xnl->xnl_header.source = xnl_information.device_address;
800055e2:	4a 48       	lddpc	r8,80005670 <xnl_tx+0xcc>
800055e4:	90 28       	ld.sh	r8,r8[0x4]
800055e6:	ac 58       	st.h	r6[0xa],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
800055e8:	8c 69       	ld.sh	r9,r6[0xc]
800055ea:	3f f8       	mov	r8,-1
800055ec:	f0 09 19 00 	cp.h	r9,r8
800055f0:	c0 e1       	brne	8000560c <xnl_tx+0x68>
	{		
		xnl->xnl_header.transaction_id = 
		  ((++xnl_information.transaction_id) & 0xFF) 
800055f2:	4a 08       	lddpc	r8,80005670 <xnl_tx+0xcc>
800055f4:	90 49       	ld.sh	r9,r8[0x8]
800055f6:	2f f9       	sub	r9,-1
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
800055f8:	b0 49       	st.h	r8[0x8],r9
		  ((++xnl_information.transaction_id) & 0xFF) 
800055fa:	90 4a       	ld.sh	r10,r8[0x8]
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
800055fc:	90 49       	ld.sh	r9,r8[0x8]
800055fe:	e0 19 ff 00 	andl	r9,0xff00
80005602:	f1 da c0 08 	bfextu	r8,r10,0x0,0x8
80005606:	f3 e8 10 08 	or	r8,r9,r8
8000560a:	ac 68       	st.h	r6[0xc],r8
	U16  sumScratch;
	U32  indextohWord;
	S32  hWordswithinFrag;
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
8000560c:	0d 98       	ld.ub	r8,r6[0x1]
8000560e:	20 28       	sub	r8,2
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
80005610:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
80005614:	10 0c       	add	r12,r8
80005616:	a1 5c       	asr	r12,0x1
	indextohWord = 2;
	while (hWordswithinFrag > 0)
80005618:	58 0c       	cp.w	r12,0
8000561a:	e0 89 00 04 	brgt	80005622 <xnl_tx+0x7e>
8000561e:	30 09       	mov	r9,0
80005620:	c0 d8       	rjmp	8000563a <xnl_tx+0x96>
80005622:	ec ca ff fc 	sub	r10,r6,-4
Parameters: xnl_fragment_t * 
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
80005626:	2f ec       	sub	r12,-2
80005628:	30 09       	mov	r9,0
8000562a:	30 28       	mov	r8,2
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
	{
		sumScratch += *((U16*)xnl + indextohWord);
8000562c:	15 1b       	ld.sh	r11,r10++
8000562e:	f6 09 00 09 	add	r9,r11,r9
80005632:	5c 89       	casts.h	r9
		indextohWord     += 1;
80005634:	2f f8       	sub	r8,-1
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
80005636:	18 38       	cp.w	r8,r12
80005638:	cf a1       	brne	8000562c <xnl_tx+0x88>
		  ((++xnl_information.transaction_id) & 0xFF) 
		| (xnl_information.transaction_id & 0xFF00);
	}
	
	/*count check sum */
	xnl->phy_header.check_sum = check_sum( xnl );
8000563a:	5c 39       	neg	r9
8000563c:	ac 19       	st.h	r6[0x2],r9
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
8000563e:	48 e8       	lddpc	r8,80005674 <xnl_tx+0xd0>
80005640:	70 0c       	ld.w	r12,r8[0x0]
80005642:	f0 1f 00 0e 	mcall	80005678 <xnl_tx+0xd4>
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
80005646:	c1 00       	breq	80005666 <xnl_tx+0xc2>
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
80005648:	fa c7 ff fc 	sub	r7,sp,-4
8000564c:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
	{
		memcpy(ptr, xnl, sizeof(xnl_fragment_t));
8000564e:	e0 6a 01 00 	mov	r10,256
80005652:	0c 9b       	mov	r11,r6
80005654:	f0 1f 00 0a 	mcall	8000567c <xnl_tx+0xd8>
	
		/*push to queue and send*/
		
		//log("ptr -%8x", ptr);
		
		xQueueSend(xnl_frame_tx, &ptr, 0);
80005658:	48 a8       	lddpc	r8,80005680 <xnl_tx+0xdc>
8000565a:	70 0c       	ld.w	r12,r8[0x0]
8000565c:	30 09       	mov	r9,0
8000565e:	12 9a       	mov	r10,r9
80005660:	1a 9b       	mov	r11,sp
80005662:	f0 1f 00 09 	mcall	80005684 <xnl_tx+0xe0>
		//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
		
		//vPortFree(ptr);
	}
}
80005666:	2f fd       	sub	sp,-4
80005668:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000566c:	00 00       	add	r0,r0
8000566e:	10 ec       	st.h	--r8,r12
80005670:	00 00       	add	r0,r0
80005672:	10 d0       	st.w	--r8,r0
80005674:	00 00       	add	r0,r0
80005676:	10 38       	cp.w	r8,r8
80005678:	80 00       	ld.sh	r0,r0[0x0]
8000567a:	43 8c       	lddsp	r12,sp[0xe0]
8000567c:	80 00       	ld.sh	r0,r0[0x0]
8000567e:	a9 06       	ld.d	r6,r4
80005680:	00 00       	add	r0,r0
80005682:	10 e0       	st.h	--r8,r0
80005684:	80 00       	ld.sh	r0,r0[0x0]
80005686:	93 50       	st.w	r9[0x14],r0

80005688 <xnl_init>:
	xTaskCreate--freertos
	xnl_send_device_master_query
Called By:xcmp_init -- xcmp.c
*/
void xnl_init(void)
{
80005688:	eb cd 40 80 	pushm	r7,lr
8000568c:	fa cd 01 00 	sub	sp,sp,256
	/*initialize the physical layer*/
	phy_init();
80005690:	f0 1f 00 27 	mcall	8000572c <xnl_init+0xa4>
	
	xnl_information.is_connected = FALSE;
80005694:	30 09       	mov	r9,0
80005696:	4a 78       	lddpc	r8,80005730 <xnl_init+0xa8>
80005698:	b0 89       	st.b	r8[0x0],r9

	/*initialize the semaphore and queue*/
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
8000569a:	30 0b       	mov	r11,0
8000569c:	30 1c       	mov	r12,1
8000569e:	f0 1f 00 26 	mcall	80005734 <xnl_init+0xac>
800056a2:	4a 68       	lddpc	r8,80005738 <xnl_init+0xb0>
800056a4:	91 0c       	st.w	r8[0x0],r12
800056a6:	70 08       	ld.w	r8,r8[0x0]
800056a8:	58 08       	cp.w	r8,0
800056aa:	c0 80       	breq	800056ba <xnl_init+0x32>
800056ac:	4a 38       	lddpc	r8,80005738 <xnl_init+0xb0>
800056ae:	70 0c       	ld.w	r12,r8[0x0]
800056b0:	30 09       	mov	r9,0
800056b2:	12 9a       	mov	r10,r9
800056b4:	12 9b       	mov	r11,r9
800056b6:	f0 1f 00 22 	mcall	8000573c <xnl_init+0xb4>
	//xnl_frame_tx = xQueueCreate(10, sizeof(xnl_fragment_t *)); 
	
	xnl_frame_tx = xQueueCreate(20, sizeof(xnl_fragment_t *)); //xnl_frame_tx
800056ba:	30 4b       	mov	r11,4
800056bc:	31 4c       	mov	r12,20
800056be:	f0 1f 00 1e 	mcall	80005734 <xnl_init+0xac>
800056c2:	4a 08       	lddpc	r8,80005740 <xnl_init+0xb8>
800056c4:	91 0c       	st.w	r8[0x0],r12
		
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
800056c6:	30 07       	mov	r7,0
800056c8:	1a d7       	st.w	--sp,r7
800056ca:	1a d7       	st.w	--sp,r7
800056cc:	1a d7       	st.w	--sp,r7
800056ce:	30 38       	mov	r8,3
800056d0:	0e 99       	mov	r9,r7
800056d2:	e0 6a 02 00 	mov	r10,512
800056d6:	49 cb       	lddpc	r11,80005744 <xnl_init+0xbc>
800056d8:	49 cc       	lddpc	r12,80005748 <xnl_init+0xc0>
800056da:	f0 1f 00 1d 	mcall	8000574c <xnl_init+0xc4>
	,  tskXNL_PRIORITY //+ 1
	,  NULL
	);
	
	/*this task is used to send xnl message*/
	xTaskCreate(
800056de:	1a d7       	st.w	--sp,r7
800056e0:	1a d7       	st.w	--sp,r7
800056e2:	1a d7       	st.w	--sp,r7
800056e4:	30 38       	mov	r8,3
800056e6:	0e 99       	mov	r9,r7
800056e8:	e0 6a 03 20 	mov	r10,800
800056ec:	49 9b       	lddpc	r11,80005750 <xnl_init+0xc8>
800056ee:	49 ac       	lddpc	r12,80005754 <xnl_init+0xcc>
800056f0:	f0 1f 00 17 	mcall	8000574c <xnl_init+0xc4>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
800056f4:	e0 68 40 0e 	mov	r8,16398
800056f8:	fb 58 00 18 	st.h	sp[24],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
800056fc:	3f f8       	mov	r8,-1
800056fe:	fb 58 00 1a 	st.h	sp[26],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_MASTER_QUERY;
80005702:	30 38       	mov	r8,3
80005704:	fb 58 00 1c 	st.h	sp[28],r8
	
	/*The initial value*/
	xnl_frame.xnl_header.flags = 0;
80005708:	fb 57 00 1e 	st.h	sp[30],r7
	
	/*XNL address of the master device, if known;otherwise 0x0000*/
	xnl_frame.xnl_header.destination = 0;
8000570c:	fb 57 00 20 	st.h	sp[32],r7
	
	/*XNL address, if assigned; otherwise 0x0000*/
	xnl_frame.xnl_header.source = 0;
80005710:	fb 57 00 22 	st.h	sp[34],r7
	
	/*No transaction ID required for this message*/
	xnl_frame.xnl_header.transaction_id = 0;
80005714:	fb 57 00 24 	st.h	sp[36],r7
	
	/*This message contains no payload*/
	xnl_frame.xnl_header.payload_length = 0;
80005718:	fb 57 00 26 	st.h	sp[38],r7

	/*send XNL message*/
	xnl_tx(&xnl_frame);
8000571c:	fa cc ff e8 	sub	r12,sp,-24
80005720:	f0 1f 00 0e 	mcall	80005758 <xnl_init+0xd0>
80005724:	2f ad       	sub	sp,-24
	,  NULL
	);
	
	/*send device_master_query to connect radio*/	
	xnl_send_device_master_query();
}
80005726:	2c 0d       	sub	sp,-256
80005728:	e3 cd 80 80 	ldm	sp++,r7,pc
8000572c:	80 00       	ld.sh	r0,r0[0x0]
8000572e:	43 b4       	lddsp	r4,sp[0xec]
80005730:	00 00       	add	r0,r0
80005732:	10 d0       	st.w	--r8,r0
80005734:	80 00       	ld.sh	r0,r0[0x0]
80005736:	94 a8       	ld.uh	r8,r10[0x4]
80005738:	00 00       	add	r0,r0
8000573a:	10 cc       	st.b	r8++,r12
8000573c:	80 00       	ld.sh	r0,r0[0x0]
8000573e:	93 50       	st.w	r9[0x14],r0
80005740:	00 00       	add	r0,r0
80005742:	10 e0       	st.h	--r8,r0
80005744:	80 01       	ld.sh	r1,r0[0x0]
80005746:	8e 9c       	ld.uh	r12,r7[0x2]
80005748:	80 00       	ld.sh	r0,r0[0x0]
8000574a:	55 44       	stdsp	sp[0x150],r4
8000574c:	80 00       	ld.sh	r0,r0[0x0]
8000574e:	9b 7c       	st.w	sp[0x1c],r12
80005750:	80 01       	ld.sh	r1,r0[0x0]
80005752:	02 00       	add	r0,r1
80005754:	80 00       	ld.sh	r0,r0[0x0]
80005756:	54 7c       	stdsp	sp[0x11c],r12
80005758:	80 00       	ld.sh	r0,r0[0x0]
8000575a:	55 a4       	stdsp	sp[0x168],r4

8000575c <xnl_data_msg_func>:
Description: process while receive data message.
Calls:xnl_send_msg_ack, xcmp_exec(function in xcmp)
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_data_msg_func(xnl_fragment_t * xnl)
{
8000575c:	eb cd 40 80 	pushm	r7,lr
80005760:	fa cd 01 00 	sub	sp,sp,256
80005764:	18 97       	mov	r7,r12
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80005766:	e0 68 40 0e 	mov	r8,16398
8000576a:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
8000576c:	3f f8       	mov	r8,-1
8000576e:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG_ACK;
80005770:	30 c8       	mov	r8,12
80005772:	ba 28       	st.h	sp[0x4],r8
	
	/*Turn around Flags.*/	
	xnl_frame.xnl_header.flags = hdr->flags;
80005774:	98 38       	ld.sh	r8,r12[0x6]
80005776:	ba 38       	st.h	sp[0x6],r8
	
	/*ACK Destination Address is Source of XNL_Message.*/
	xnl_frame.xnl_header.destination = hdr->source;
80005778:	98 58       	ld.sh	r8,r12[0xa]
8000577a:	ba 48       	st.h	sp[0x8],r8
	
	/*ACK Source Address is my address.*/
	xnl_frame.xnl_header.source = hdr->destination;
8000577c:	98 48       	ld.sh	r8,r12[0x8]
8000577e:	ba 58       	st.h	sp[0xa],r8
	
	/*Turn around Transaction ID.*/
	xnl_frame.xnl_header.transaction_id = hdr->transaction_id;
80005780:	98 68       	ld.sh	r8,r12[0xc]
80005782:	ba 68       	st.h	sp[0xc],r8
	xnl_frame.xnl_header.payload_length = 0;
80005784:	30 08       	mov	r8,0
80005786:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
80005788:	1a 9c       	mov	r12,sp
8000578a:	f0 1f 00 0a 	mcall	800057b0 <xnl_data_msg_func+0x54>
	transmitter, but possibly is waiting in Queue with immediate timeout.
	 */
	xnl_send_msg_ack(&xnl->xnl_header);
	
	/*exec xcmp function*/
	xcmp_exec(xnl->xnl_payload.xnl_content_data_msg);//xcmp_rx
8000578e:	fa cd 00 cc 	sub	sp,sp,204
80005792:	e0 6a 00 ca 	mov	r10,202
80005796:	ee cb ff f0 	sub	r11,r7,-16
8000579a:	1a 9c       	mov	r12,sp
8000579c:	f0 1f 00 06 	mcall	800057b4 <xnl_data_msg_func+0x58>
800057a0:	48 68       	lddpc	r8,800057b8 <xnl_data_msg_func+0x5c>
800057a2:	70 08       	ld.w	r8,r8[0x0]
800057a4:	5d 18       	icall	r8
800057a6:	fa cd ff 34 	sub	sp,sp,-204
}
800057aa:	2c 0d       	sub	sp,-256
800057ac:	e3 cd 80 80 	ldm	sp++,r7,pc
800057b0:	80 00       	ld.sh	r0,r0[0x0]
800057b2:	55 a4       	stdsp	sp[0x168],r4
800057b4:	80 00       	ld.sh	r0,r0[0x0]
800057b6:	a9 06       	ld.d	r6,r4
800057b8:	00 00       	add	r0,r0
800057ba:	10 f0       	st.b	--r8,r0

800057bc <xnl_device_auth_reply_func>:
Description: process while receive device auth reply.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_auth_reply_func(xnl_fragment_t * xnl)
{
800057bc:	d4 21       	pushm	r4-r7,lr
800057be:	fa cd 01 00 	sub	sp,sp,256
800057c2:	18 97       	mov	r7,r12
	the receiving device and will be used to authenticate the connection 
	request. 5.4.4
	*/
	//log("R_xnl-opcode:%4x", xnl->xnl_header.opcode);
	
	if(xnl_information.is_connected)
800057c4:	4c 28       	lddpc	r8,800058cc <xnl_device_auth_reply_func+0x110>
800057c6:	11 88       	ld.ub	r8,r8[0x0]
800057c8:	58 08       	cp.w	r8,0
800057ca:	c7 e1       	brne	800058c6 <xnl_device_auth_reply_func+0x10a>
	{
		return;		
	}
	
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);
800057cc:	4c 18       	lddpc	r8,800058d0 <xnl_device_auth_reply_func+0x114>
800057ce:	70 0c       	ld.w	r12,r8[0x0]
800057d0:	30 09       	mov	r9,0
800057d2:	12 9a       	mov	r10,r9
800057d4:	12 9b       	mov	r11,r9
800057d6:	f0 1f 00 40 	mcall	800058d4 <xnl_device_auth_reply_func+0x118>

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
800057da:	ef 09 00 10 	ld.sh	r9,r7[16]
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
800057de:	4b c8       	lddpc	r8,800058cc <xnl_device_auth_reply_func+0x110>
800057e0:	b0 29       	st.h	r8[0x4],r9
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
	
	/*Get Array of values to be encrypted into an aligned 2X32bits.*/
	v_vector[0] =
800057e2:	ef 39 00 12 	ld.ub	r9,r7[18]
800057e6:	ef 38 00 13 	ld.ub	r8,r7[19]
800057ea:	b1 68       	lsl	r8,0x10
800057ec:	f1 e9 11 89 	or	r9,r8,r9<<0x18
800057f0:	ef 38 00 15 	ld.ub	r8,r7[21]
800057f4:	f3 e8 10 08 	or	r8,r9,r8
800057f8:	ef 39 00 14 	ld.ub	r9,r7[20]
800057fc:	f1 e9 10 89 	or	r9,r8,r9<<0x8
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[2])<<8	  
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[3]);
	
	v_vector[1] =
80005800:	ef 3a 00 16 	ld.ub	r10,r7[22]
80005804:	ef 38 00 17 	ld.ub	r8,r7[23]
80005808:	b1 68       	lsl	r8,0x10
8000580a:	f1 ea 11 8a 	or	r10,r8,r10<<0x18
8000580e:	ef 38 00 19 	ld.ub	r8,r7[25]
80005812:	f5 e8 10 08 	or	r8,r10,r8
80005816:	ef 3a 00 18 	ld.ub	r10,r7[24]
8000581a:	f1 ea 10 88 	or	r8,r8,r10<<0x8
8000581e:	30 0a       	mov	r10,0
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
80005820:	e0 64 79 b9 	mov	r4,31161
80005824:	ea 14 9e 37 	orh	r4,0x9e37
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
80005828:	e0 65 45 07 	mov	r5,17671
8000582c:	ea 15 8a bd 	orh	r5,0x8abd
80005830:	e0 66 f9 3d 	mov	r6,63805
80005834:	ea 16 99 68 	orh	r6,0x9968
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
80005838:	e0 6e b8 cf 	mov	lr,47311
8000583c:	ea 1e 36 83 	orh	lr,0x3683
80005840:	e0 67 aa 1c 	mov	r7,43548
80005844:	ea 17 9c 36 	orh	r7,0x9c36
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
80005848:	08 0a       	add	r10,r4
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
8000584a:	f4 08 00 0c 	add	r12,r10,r8
8000584e:	f0 0b 15 04 	lsl	r11,r8,0x4
80005852:	0a 0b       	add	r11,r5
80005854:	f9 eb 20 0b 	eor	r11,r12,r11
80005858:	f0 0c 16 05 	lsr	r12,r8,0x5
8000585c:	0c 0c       	add	r12,r6
8000585e:	18 5b       	eor	r11,r12
80005860:	16 09       	add	r9,r11
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
80005862:	f2 0c 15 04 	lsl	r12,r9,0x4
80005866:	1c 0c       	add	r12,lr
80005868:	f2 0b 16 05 	lsr	r11,r9,0x5
8000586c:	0e 0b       	add	r11,r7
8000586e:	f9 eb 20 0b 	eor	r11,r12,r11
80005872:	f2 0a 00 0c 	add	r12,r9,r10
80005876:	18 5b       	eor	r11,r12
80005878:	16 08       	add	r8,r11
{
	register U32 y=v[0], z=v[1], sum=0;
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
8000587a:	e0 6b 37 20 	mov	r11,14112
8000587e:	ea 1b c6 ef 	orh	r11,0xc6ef
80005882:	16 3a       	cp.w	r10,r11
80005884:	ce 21       	brne	80005848 <xnl_device_auth_reply_func+0x8c>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :24 + 2(xnl length(24) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 24 + 2;
80005886:	e0 6a 40 1a 	mov	r10,16410
8000588a:	ba 0a       	st.h	sp[0x0],r10
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
8000588c:	3f fa       	mov	r10,-1
8000588e:	ba 1a       	st.h	sp[0x2],r10
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_CONN_REQUEST;
80005890:	30 6b       	mov	r11,6
80005892:	ba 2b       	st.h	sp[0x4],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
80005894:	ba 3a       	st.h	sp[0x6],r10
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
80005896:	48 eb       	lddpc	r11,800058cc <xnl_device_auth_reply_func+0x110>
80005898:	96 1c       	ld.sh	r12,r11[0x2]
8000589a:	ba 4c       	st.h	sp[0x8],r12
	message here, and all will receive the same DEVICE_CONN_REPLY. Not real 
	sure what's going to happen with multiple conrol heads, etc. One suspects 
	the Rocket Scientists will eventually figure this out, and demand a 
	transaction ID based on Device Type in the XNL_DEVICE_AUTH_KEY_REQUEST.
	*/
	xnl_frame.xnl_header.source = xnl_information.device_address;
8000589c:	96 2b       	ld.sh	r11,r11[0x4]
8000589e:	ba 5b       	st.h	sp[0xa],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
800058a0:	ba 6a       	st.h	sp[0xc],r10
	
    /*his message contains 12 payload bytes*/	
	xnl_frame.xnl_header.payload_length = 0x000C;
800058a2:	30 ca       	mov	r10,12
800058a4:	ba 7a       	st.h	sp[0xe],r10
	
	/*No Preferred XNL Address*/
	xnl_frame.xnl_payload.xnl_content_device_conn_req.preferred_xnl_address = 
800058a6:	30 0a       	mov	r10,0
800058a8:	fb 5a 00 10 	st.h	sp[16],r10
	XCMP/XNL Development Specification Section 4.5.3.2.1.
	Same as in MOTOTRBO?XCMP/XNL Development Specification?
	evice_type--Option Board(0x07)
	authentication_index--Option Board(0x02)
	*/	
	xnl_frame.xnl_payload.xnl_content_device_conn_req.device_type = 0x07;
800058ac:	30 7a       	mov	r10,7
800058ae:	fb 6a 00 12 	st.b	sp[18],r10
	xnl_frame.xnl_payload.xnl_content_device_conn_req.authentication_index =
800058b2:	30 2a       	mov	r10,2
800058b4:	fb 6a 00 13 	st.b	sp[19],r10
	                                                                       0x02;
		
	//We know encrypted array happens to be aligned to 32-bit boundary.
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
800058b8:	fa ca ff ec 	sub	r10,sp,-20
800058bc:	95 09       	st.w	r10[0x0],r9
	                         .encrypted_authentication_value[0])) = w_vector[0];
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
800058be:	95 18       	st.w	r10[0x4],r8
	                         .encrypted_authentication_value[4])) = w_vector[1];
	
	/*send XNL message*/
	xnl_tx(&xnl_frame);
800058c0:	1a 9c       	mov	r12,sp
800058c2:	f0 1f 00 06 	mcall	800058d8 <xnl_device_auth_reply_func+0x11c>
}
800058c6:	2c 0d       	sub	sp,-256
800058c8:	d8 22       	popm	r4-r7,pc
800058ca:	00 00       	add	r0,r0
800058cc:	00 00       	add	r0,r0
800058ce:	10 d0       	st.w	--r8,r0
800058d0:	00 00       	add	r0,r0
800058d2:	10 cc       	st.b	r8++,r12
800058d4:	80 00       	ld.sh	r0,r0[0x0]
800058d6:	93 50       	st.w	r9[0x14],r0
800058d8:	80 00       	ld.sh	r0,r0[0x0]
800058da:	55 a4       	stdsp	sp[0x168],r4

800058dc <xnl_master_status_brdcst_func>:
Description: process while receive master status boardcast.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_master_status_brdcst_func(xnl_fragment_t * xnl)
{	
800058dc:	eb cd 40 80 	pushm	r7,lr
800058e0:	fa cd 01 00 	sub	sp,sp,256
800058e4:	18 97       	mov	r7,r12
	not an XNL_DATA_MSG has been sent out. This will indicate to a connecting 
	device that it has missed messages. The XNL header will contain the 
	master?XNL address. 5.4.1
	*/
	
	if(xnl_information.is_connected)
800058e6:	49 28       	lddpc	r8,8000592c <xnl_master_status_brdcst_func+0x50>
800058e8:	11 88       	ld.ub	r8,r8[0x0]
800058ea:	58 08       	cp.w	r8,0
800058ec:	c1 c1       	brne	80005924 <xnl_master_status_brdcst_func+0x48>
	{
		return;	
	}
		
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);	
800058ee:	49 18       	lddpc	r8,80005930 <xnl_master_status_brdcst_func+0x54>
800058f0:	70 0c       	ld.w	r12,r8[0x0]
800058f2:	30 09       	mov	r9,0
800058f4:	12 9a       	mov	r10,r9
800058f6:	12 9b       	mov	r11,r9
800058f8:	f0 1f 00 0f 	mcall	80005934 <xnl_master_status_brdcst_func+0x58>

	//log("xnl-ma:%4x", xnl->xnl_header.source);
	/*get the master adderss from this message*/	
	xnl_information.master_address = xnl->xnl_header.source;	
800058fc:	8e 58       	ld.sh	r8,r7[0xa]
800058fe:	48 c9       	lddpc	r9,8000592c <xnl_master_status_brdcst_func+0x50>
80005900:	b2 18       	st.h	r9[0x2],r8
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80005902:	e0 68 40 0e 	mov	r8,16398
80005906:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80005908:	3f f8       	mov	r8,-1
8000590a:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_AUTH_KEY_REQUEST;
8000590c:	30 4a       	mov	r10,4
8000590e:	ba 2a       	st.h	sp[0x4],r10
		
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/	
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
80005910:	ba 38       	st.h	sp[0x6],r8
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
80005912:	92 19       	ld.sh	r9,r9[0x2]
80005914:	ba 49       	st.h	sp[0x8],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.source = DEFAULT_VALUE;
80005916:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80005918:	ba 68       	st.h	sp[0xc],r8
		
	xnl_frame.xnl_header.payload_length = 0;
8000591a:	30 08       	mov	r8,0
8000591c:	ba 78       	st.h	sp[0xe],r8
	
	/*send XNL message*/	
	xnl_tx(&xnl_frame);
8000591e:	1a 9c       	mov	r12,sp
80005920:	f0 1f 00 06 	mcall	80005938 <xnl_master_status_brdcst_func+0x5c>
}
80005924:	2c 0d       	sub	sp,-256
80005926:	e3 cd 80 80 	ldm	sp++,r7,pc
8000592a:	00 00       	add	r0,r0
8000592c:	00 00       	add	r0,r0
8000592e:	10 d0       	st.w	--r8,r0
80005930:	00 00       	add	r0,r0
80005932:	10 cc       	st.b	r8++,r12
80005934:	80 00       	ld.sh	r0,r0[0x0]
80005936:	93 50       	st.w	r9[0x14],r0
80005938:	80 00       	ld.sh	r0,r0[0x0]
8000593a:	55 a4       	stdsp	sp[0x168],r4

8000593c <xnl_device_conn_reply_func>:
Description: process while receive device conn reply.
Calls:xSemaphoreGive--freestos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_conn_reply_func(xnl_fragment_t * xnl)
{
8000593c:	eb cd 40 80 	pushm	r7,lr
80005940:	18 97       	mov	r7,r12
	transaction ID and an 8-byte encrypted value that the device can use to 
	authenticate the master. XCMP/XNL Development Guide 5.4.6
	*/
	
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);
80005942:	49 38       	lddpc	r8,8000598c <xnl_device_conn_reply_func+0x50>
80005944:	70 0c       	ld.w	r12,r8[0x0]
80005946:	30 09       	mov	r9,0
80005948:	12 9a       	mov	r10,r9
8000594a:	12 9b       	mov	r11,r9
8000594c:	f0 1f 00 11 	mcall	80005990 <xnl_device_conn_reply_func+0x54>

	/*Test result code*/
	if((xnl->xnl_payload.xnl_content_device_conn_reply.result_base & 0x0000FF00)
80005950:	ef 18 00 10 	ld.uh	r8,r7[16]
80005954:	10 99       	mov	r9,r8
80005956:	e2 19 ff 00 	andl	r9,0xff00,COH
8000595a:	e0 49 01 00 	cp.w	r9,256
8000595e:	c0 60       	breq	8000596a <xnl_device_conn_reply_func+0x2e>
		/*
		Rejected. The device must retry the authentication process at this 
		point by sending out a new AUTH_KEY_REQUEST message. XCMP/XNL 
		Development Guide Section 5.2.3
		*/
		xnl_master_status_brdcst_func(xnl);			
80005960:	0e 9c       	mov	r12,r7
80005962:	f0 1f 00 0d 	mcall	80005994 <xnl_device_conn_reply_func+0x58>
80005966:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/*connection accepted*/		
		/*Record Transaction ID Base*/
		xnl_information.transaction_id =  
8000596a:	a9 68       	lsl	r8,0x8
8000596c:	48 b9       	lddpc	r9,80005998 <xnl_device_conn_reply_func+0x5c>
8000596e:	b2 48       	st.h	r9[0x8],r8
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
80005970:	ef 08 00 14 	ld.sh	r8,r7[20]
		xnl_information.transaction_id =  
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
80005974:	b2 38       	st.h	r9[0x6],r8
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
80005976:	ef 08 00 12 	ld.sh	r8,r7[18]
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
8000597a:	b2 28       	st.h	r9[0x4],r8
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
		
		/*connect finish*/
		xnl_information.is_connected = TRUE;
8000597c:	30 18       	mov	r8,1
8000597e:	b2 88       	st.b	r9[0x0],r8
		
		log("connected finish");
80005980:	48 7c       	lddpc	r12,8000599c <xnl_device_conn_reply_func+0x60>
80005982:	f0 1f 00 08 	mcall	800059a0 <xnl_device_conn_reply_func+0x64>
80005986:	e3 cd 80 80 	ldm	sp++,r7,pc
8000598a:	00 00       	add	r0,r0
8000598c:	00 00       	add	r0,r0
8000598e:	10 cc       	st.b	r8++,r12
80005990:	80 00       	ld.sh	r0,r0[0x0]
80005992:	93 50       	st.w	r9[0x14],r0
80005994:	80 00       	ld.sh	r0,r0[0x0]
80005996:	58 dc       	cp.w	r12,13
80005998:	00 00       	add	r0,r0
8000599a:	10 d0       	st.w	--r8,r0
8000599c:	80 01       	ld.sh	r1,r0[0x0]
8000599e:	8e a4       	ld.uh	r4,r7[0x4]
800059a0:	80 00       	ld.sh	r0,r0[0x0]
800059a2:	9f 40       	st.w	pc[0x10],r0

800059a4 <local_start_pll0>:
	//pm_switch_to_osc0(pm, 12000000, 3);
	//    pm_enable_osc0_crystal(pm, 12000000);
	//         pm_set_osc0_mode(pm,AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);  0x00000007
	//    pm_enable_clk0(pm, 3);
	//         pm_enable_clk0_no_wait(pm, 3);
	(&AVR32_PM)->oscctrl0 = 0x00000307;
800059a4:	fe 78 0c 00 	mov	r8,-62464
800059a8:	e0 69 03 07 	mov	r9,775
800059ac:	91 a9       	st.w	r8[0x28],r9
	(&AVR32_PM)->mcctrl   = 0x00000004;
800059ae:	30 49       	mov	r9,4
800059b0:	91 09       	st.w	r8[0x0],r9
	//         pm_wait_for_clk0_ready(pm);
	while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
800059b2:	71 59       	ld.w	r9,r8[0x54]
800059b4:	e2 19 00 80 	andl	r9,0x80,COH
800059b8:	cf d0       	breq	800059b2 <local_start_pll0+0xe>
	//    pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);
	(&AVR32_PM)->mcctrl   = 0x00000005;
800059ba:	fe 78 0c 00 	mov	r8,-62464
800059be:	30 59       	mov	r9,5
800059c0:	91 09       	st.w	r8[0x0],r9
	//pm_pll_set_option(pm, 0, //PLL number 0
	//                        1, //freq Set to 1 for VCO frequency range 80-180MHz
	//                        1, //div2 Divide the PLL output frequency by 2
	//                        0);//0 to enable the Wide-Bandith Mode
	//pm_pll_enable(pm,0);
	(&AVR32_PM)->pll[0] = 0x1007010D;
800059c2:	e0 69 01 0d 	mov	r9,269
800059c6:	ea 19 10 07 	orh	r9,0x1007
800059ca:	91 89       	st.w	r8[0x20],r9


	//pm_wait_for_pll0_locked(pm);
	while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_LOCK0_MASK));
800059cc:	71 59       	ld.w	r9,r8[0x54]
800059ce:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
800059d2:	cf d0       	breq	800059cc <local_start_pll0+0x28>
	//             0,  //Bus A select = 0 (PBA clock = 48MHz/2 = 24MHz).
	//             0,  //B clock divisor enable = 0
	//             0,  //Bus B select = 0
	//             0,  //HS Bus clock divisor enable = 0
	//             0); //HS Bus select = 0
	(&AVR32_PM)->cksel = 0x00800000;
800059d4:	fe 78 0c 00 	mov	r8,-62464
800059d8:	fc 19 00 80 	movh	r9,0x80
800059dc:	91 19       	st.w	r8[0x4],r9

	//flashc_set_wait_state(1);
	AVR32_FLASHC.fcr = 0x00000040;
800059de:	34 0a       	mov	r10,64
800059e0:	fe 69 14 00 	mov	r9,-125952
800059e4:	93 0a       	st.w	r9[0x0],r10

	//pm_switch_to_clock(pm, AVR32_PM_MCSEL_PLL0);
	(&AVR32_PM)->mcctrl   = 0x00000006;
800059e6:	30 69       	mov	r9,6
800059e8:	91 09       	st.w	r8[0x0],r9


	AVR32_HMATRIX.mcfg[AVR32_HMATRIX_MASTER_CPU_INSTRUCTION] = 0x1;
800059ea:	30 19       	mov	r9,1
800059ec:	fe 68 10 00 	mov	r8,-126976
800059f0:	91 19       	st.w	r8[0x4],r9
}
800059f2:	5e fc       	retal	r12

800059f4 <read_a_byte>:
*/
U32 read_a_byte(U32 subaddress, S8 *datareceived)
{
	U32 TWI_Status = 0;

	AVR32_TWI.cr   =  AVR32_TWI_CR_MSEN_MASK | AVR32_TWI_CR_SVDIS_MASK;
800059f4:	fe 78 2c 00 	mov	r8,-54272
800059f8:	32 49       	mov	r9,36
800059fa:	91 09       	st.w	r8[0x0],r9
	AVR32_TWI.mmr  =  PCF8563_ADDRESS        << AVR32_TWI_MMR_DADR_OFFSET   |
800059fc:	e0 69 11 00 	mov	r9,4352
80005a00:	ea 19 00 51 	orh	r9,0x51
80005a04:	91 19       	st.w	r8[0x4],r9
	PCF8563_ADDR_LGT		<< AVR32_TWI_MMR_IADRSZ_OFFSET |
	1					<< AVR32_TWI_MMR_MREAD_OFFSET;
	AVR32_TWI.iadr =  subaddress;
80005a06:	91 3c       	st.w	r8[0xc],r12

	AVR32_TWI.cr   =  AVR32_TWI_START_MASK | AVR32_TWI_STOP_MASK;
80005a08:	30 39       	mov	r9,3
80005a0a:	91 09       	st.w	r8[0x0],r9

	do
	{
		TWI_Status =  AVR32_TWI.sr & 0x00000102;
80005a0c:	70 8c       	ld.w	r12,r8[0x20]
80005a0e:	e2 1c 01 02 	andl	r12,0x102,COH
	}
	while (TWI_Status == 0);
80005a12:	cf d0       	breq	80005a0c <read_a_byte+0x18>

	if (!(TWI_Status & 0x00000100))
80005a14:	18 98       	mov	r8,r12
80005a16:	e2 18 01 00 	andl	r8,0x100,COH
80005a1a:	c0 51       	brne	80005a24 <read_a_byte+0x30>
	{
		*datareceived = AVR32_TWI.rhr;
80005a1c:	fe 78 2c 00 	mov	r8,-54272
80005a20:	70 c8       	ld.w	r8,r8[0x30]
80005a22:	b6 88       	st.b	r11[0x0],r8
	}
	while ((AVR32_TWI.sr & 0x00000001) == 0x00000000); //Wait for complete.
80005a24:	fe 78 2c 00 	mov	r8,-54272
80005a28:	70 89       	ld.w	r9,r8[0x20]
80005a2a:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
80005a2e:	cf d0       	breq	80005a28 <read_a_byte+0x34>
	return (TWI_Status);
}
80005a30:	5e fc       	retal	r12
80005a32:	d7 03       	nop

80005a34 <rtc_read_time>:
Calls: 
    my_writeabyte
Return:rtc_err_t
*/
rtc_err_t rtc_read_time(date_time_t * t)
{	
80005a34:	eb cd 40 e0 	pushm	r5-r7,lr
80005a38:	20 2d       	sub	sp,8
80005a3a:	18 97       	mov	r7,r12
	if(NULL != rtc_mutex)
80005a3c:	4c 28       	lddpc	r8,80005b44 <rtc_read_time+0x110>
80005a3e:	70 08       	ld.w	r8,r8[0x0]
80005a40:	58 08       	cp.w	r8,0
80005a42:	c0 31       	brne	80005a48 <rtc_read_time+0x14>
80005a44:	30 3c       	mov	r12,3
80005a46:	c7 b8       	rjmp	80005b3c <rtc_read_time+0x108>
	{
		/*See if we can obtain the semaphore. If the semaphore is not available wait aways to see if it becomes free*/
		xSemaphoreTake( rtc_mutex, portMAX_DELAY);
80005a48:	4b f6       	lddpc	r6,80005b44 <rtc_read_time+0x110>
80005a4a:	6c 0c       	ld.w	r12,r6[0x0]
80005a4c:	30 09       	mov	r9,0
80005a4e:	3f fa       	mov	r10,-1
80005a50:	12 9b       	mov	r11,r9
80005a52:	f0 1f 00 3e 	mcall	80005b48 <rtc_read_time+0x114>
	int RTC_Status;
	
	unsigned char time[8];
	
	/*read second*/
	res = read_a_byte(0x02, &time[0]);	
80005a56:	1a 9b       	mov	r11,sp
80005a58:	30 2c       	mov	r12,2
80005a5a:	f0 1f 00 3d 	mcall	80005b4c <rtc_read_time+0x118>
	t->second = ((time[0] & 0x7F) >> 4) * 10 + (time[0] & 0x0F);
80005a5e:	1b 88       	ld.ub	r8,sp[0x0]
80005a60:	f3 d8 c0 83 	bfextu	r9,r8,0x4,0x3
80005a64:	f2 09 00 29 	add	r9,r9,r9<<0x2
80005a68:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
80005a6c:	f0 09 00 19 	add	r9,r8,r9<<0x1
80005a70:	ae f9       	st.b	r7[0x7],r9
	
	/*read minute*/
	res = read_a_byte(0x03, &time[1]);
80005a72:	fa cb ff ff 	sub	r11,sp,-1
80005a76:	30 3c       	mov	r12,3
80005a78:	f0 1f 00 35 	mcall	80005b4c <rtc_read_time+0x118>
	t->minute = ((time[1] & 0x7F) >> 4) * 10 + (time[1] & 0x0F);
80005a7c:	1b 98       	ld.ub	r8,sp[0x1]
80005a7e:	f3 d8 c0 83 	bfextu	r9,r8,0x4,0x3
80005a82:	f2 09 00 29 	add	r9,r9,r9<<0x2
80005a86:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
80005a8a:	f0 09 00 19 	add	r9,r8,r9<<0x1
80005a8e:	ae e9       	st.b	r7[0x6],r9
	
	/*read hour*/
	res = read_a_byte(0x04, &time[2]);
80005a90:	fa cb ff fe 	sub	r11,sp,-2
80005a94:	30 4c       	mov	r12,4
80005a96:	f0 1f 00 2e 	mcall	80005b4c <rtc_read_time+0x118>
	t->hour = ((time[2] & 0x3F) >> 4) * 10 + (time[2] & 0x0F);
80005a9a:	1b a8       	ld.ub	r8,sp[0x2]
80005a9c:	f3 d8 c0 82 	bfextu	r9,r8,0x4,0x2
80005aa0:	f2 09 00 29 	add	r9,r9,r9<<0x2
80005aa4:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
80005aa8:	f0 09 00 19 	add	r9,r8,r9<<0x1
80005aac:	ae d9       	st.b	r7[0x5],r9
	
	/*read day*/
	res = read_a_byte(0x05, &time[3]);
80005aae:	fa cb ff fd 	sub	r11,sp,-3
80005ab2:	30 5c       	mov	r12,5
80005ab4:	f0 1f 00 26 	mcall	80005b4c <rtc_read_time+0x118>
	t->day = ((time[3] & 0x3F) >> 4) * 10 + (time[3] & 0x0F);
80005ab8:	1b b8       	ld.ub	r8,sp[0x3]
80005aba:	f3 d8 c0 82 	bfextu	r9,r8,0x4,0x2
80005abe:	f2 09 00 29 	add	r9,r9,r9<<0x2
80005ac2:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
80005ac6:	f0 09 00 19 	add	r9,r8,r9<<0x1
80005aca:	ae b9       	st.b	r7[0x3],r9
	
	/*read week*/
	res = read_a_byte(0x06, &time[4]);
80005acc:	fa cb ff fc 	sub	r11,sp,-4
80005ad0:	30 6c       	mov	r12,6
80005ad2:	f0 1f 00 1f 	mcall	80005b4c <rtc_read_time+0x118>
	t->week = (time[4] & 0x0F);
80005ad6:	1b c8       	ld.ub	r8,sp[0x4]
80005ad8:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
80005adc:	ae c8       	st.b	r7[0x4],r8
	
	/*read month*/
	res = read_a_byte(0x07, &time[5]);
80005ade:	fa cb ff fb 	sub	r11,sp,-5
80005ae2:	30 7c       	mov	r12,7
80005ae4:	f0 1f 00 1a 	mcall	80005b4c <rtc_read_time+0x118>
	t->month = ((time[5] & 0x1F) >> 4) * 10 + (time[5] & 0x0F);
80005ae8:	1b d8       	ld.ub	r8,sp[0x5]
80005aea:	f3 d8 c0 81 	bfextu	r9,r8,0x4,0x1
80005aee:	f2 0a 15 02 	lsl	r10,r9,0x2
80005af2:	14 09       	add	r9,r10
80005af4:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
80005af8:	f0 09 00 18 	add	r8,r8,r9<<0x1
80005afc:	ae a8       	st.b	r7[0x2],r8
	
	/*read year*/
	res = read_a_byte(0x08, &time[6]);
80005afe:	fa cb ff fa 	sub	r11,sp,-6
80005b02:	30 8c       	mov	r12,8
80005b04:	f0 1f 00 12 	mcall	80005b4c <rtc_read_time+0x118>
80005b08:	18 95       	mov	r5,r12
	t->year = ((time[6] & 0xFF) >> 4) * 10 + (time[6] & 0x0F) + 2000;
80005b0a:	1b e9       	ld.ub	r9,sp[0x6]
80005b0c:	f1 d9 c0 04 	bfextu	r8,r9,0x0,0x4
80005b10:	f0 c8 f8 30 	sub	r8,r8,-2000
80005b14:	a5 89       	lsr	r9,0x4
80005b16:	f2 09 10 0a 	mul	r9,r9,10
80005b1a:	12 08       	add	r8,r9
80005b1c:	5c 78       	castu.h	r8
80005b1e:	30 0b       	mov	r11,0
80005b20:	f0 09 16 08 	lsr	r9,r8,0x8
80005b24:	ae 89       	st.b	r7[0x0],r9
80005b26:	ae 98       	st.b	r7[0x1],r8
	
	/*finished accessing the shared resource.Release the semaphore.*/	
	xSemaphoreGive(rtc_mutex);	
80005b28:	6c 0c       	ld.w	r12,r6[0x0]
80005b2a:	16 99       	mov	r9,r11
80005b2c:	16 9a       	mov	r10,r11
80005b2e:	f0 1f 00 09 	mcall	80005b50 <rtc_read_time+0x11c>
		
	if(res)
80005b32:	58 05       	cp.w	r5,0
80005b34:	f9 bc 01 00 	movne	r12,0
80005b38:	f9 bc 00 02 	moveq	r12,2
	{
		return rtc_success;
	}

	return rtc_write_err;
}
80005b3c:	2f ed       	sub	sp,-8
80005b3e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80005b42:	00 00       	add	r0,r0
80005b44:	00 00       	add	r0,r0
80005b46:	11 00       	ld.w	r0,r8++
80005b48:	80 00       	ld.sh	r0,r0[0x0]
80005b4a:	91 44       	st.w	r8[0x10],r4
80005b4c:	80 00       	ld.sh	r0,r0[0x0]
80005b4e:	59 f4       	cp.w	r4,31
80005b50:	80 00       	ld.sh	r0,r0[0x0]
80005b52:	93 50       	st.w	r9[0x14],r0

80005b54 <getTime>:
Description: define now
Calls:
Return:date_time_t *
*/
date_time_t * getTime(void)
{
80005b54:	eb cd 40 80 	pushm	r7,lr
	rtc_read_time(&date_time);
80005b58:	48 47       	lddpc	r7,80005b68 <getTime+0x14>
80005b5a:	0e 9c       	mov	r12,r7
80005b5c:	f0 1f 00 04 	mcall	80005b6c <getTime+0x18>
	return &date_time;
80005b60:	0e 9c       	mov	r12,r7
80005b62:	e3 cd 80 80 	ldm	sp++,r7,pc
80005b66:	00 00       	add	r0,r0
80005b68:	00 00       	add	r0,r0
80005b6a:	10 f8       	st.b	--r8,r8
80005b6c:	80 00       	ld.sh	r0,r0[0x0]
80005b6e:	5a 34       	cp.w	r4,-29

80005b70 <rtc_init>:
    PCF8563_init
Called By: ..
Return:rtc_err_t
*/
rtc_err_t rtc_init(void)
{
80005b70:	eb cd 40 c0 	pushm	r6-r7,lr
80005b74:	20 3d       	sub	sp,12
	/* Create the mutex semaphore to guard a shared RTC(TWI).*/	
	rtc_mutex = xSemaphoreCreateMutex();
80005b76:	f0 1f 00 1a 	mcall	80005bdc <rtc_init+0x6c>
80005b7a:	49 a8       	lddpc	r8,80005be0 <rtc_init+0x70>
80005b7c:	91 0c       	st.w	r8[0x0],r12
	
	if(NULL != rtc_mutex)
80005b7e:	70 08       	ld.w	r8,r8[0x0]
80005b80:	58 08       	cp.w	r8,0
80005b82:	c0 31       	brne	80005b88 <rtc_init+0x18>
80005b84:	30 3c       	mov	r12,3
80005b86:	c2 78       	rjmp	80005bd4 <rtc_init+0x64>
	{
		/*See if we can obtain the semaphore. If the semaphore is not available wait aways to see if it becomes free*/
		xSemaphoreTake( rtc_mutex, portMAX_DELAY);
80005b88:	49 66       	lddpc	r6,80005be0 <rtc_init+0x70>
80005b8a:	6c 0c       	ld.w	r12,r6[0x0]
80005b8c:	30 09       	mov	r9,0
80005b8e:	3f fa       	mov	r10,-1
80005b90:	12 9b       	mov	r11,r9
80005b92:	f0 1f 00 15 	mcall	80005be4 <rtc_init+0x74>
	
	/*twi_package_t packet, packet_received*/
	static int status;

	/*TWI gpio pins configuration*/	
	gpio_enable_module(TWI_GPIO_MAP, sizeof(TWI_GPIO_MAP) / sizeof(TWI_GPIO_MAP[0]));
80005b96:	30 2b       	mov	r11,2
80005b98:	49 4c       	lddpc	r12,80005be8 <rtc_init+0x78>
80005b9a:	f0 1f 00 15 	mcall	80005bec <rtc_init+0x7c>
	
	/* options settings*/
	opt.pba_hz = RTC_PBACLK_FREQ_HZ;//FOSC0;24Mhz
80005b9e:	e0 68 36 00 	mov	r8,13824
80005ba2:	ea 18 01 6e 	orh	r8,0x16e
80005ba6:	50 08       	stdsp	sp[0x0],r8
	opt.speed  = TWI_SPEED;//200Khz
80005ba8:	e2 78 0d 40 	mov	r8,200000
80005bac:	50 18       	stdsp	sp[0x4],r8
	opt.chip   = PCF8563_ADDRESS;
80005bae:	35 18       	mov	r8,81
80005bb0:	fb 68 00 08 	st.b	sp[8],r8

	/*initialize TWI driver with options*/
	status = twi_master_init(&AVR32_TWI, &opt);
80005bb4:	1a 9b       	mov	r11,sp
80005bb6:	fe 7c 2c 00 	mov	r12,-54272
80005bba:	f0 1f 00 0e 	mcall	80005bf0 <rtc_init+0x80>
80005bbe:	48 e7       	lddpc	r7,80005bf4 <rtc_init+0x84>
80005bc0:	8f 0c       	st.w	r7[0x0],r12
	
	/*finished accessing the shared resource.Release the semaphore.*/
	xSemaphoreGive(rtc_mutex);		
80005bc2:	6c 0c       	ld.w	r12,r6[0x0]
80005bc4:	30 09       	mov	r9,0
80005bc6:	12 9a       	mov	r10,r9
80005bc8:	12 9b       	mov	r11,r9
80005bca:	f0 1f 00 0c 	mcall	80005bf8 <rtc_init+0x88>
80005bce:	6e 08       	ld.w	r8,r7[0x0]
80005bd0:	58 08       	cp.w	r8,0
80005bd2:	5f 1c       	srne	r12
	{
		return rtc_success;
	}
		
	return rtc_init_err;
}
80005bd4:	2f dd       	sub	sp,-12
80005bd6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005bda:	00 00       	add	r0,r0
80005bdc:	80 00       	ld.sh	r0,r0[0x0]
80005bde:	94 50       	ld.sh	r0,r10[0xa]
80005be0:	00 00       	add	r0,r0
80005be2:	11 00       	ld.w	r0,r8++
80005be4:	80 00       	ld.sh	r0,r0[0x0]
80005be6:	91 44       	st.w	r8[0x10],r4
80005be8:	80 01       	ld.sh	r1,r0[0x0]
80005bea:	8e b8       	ld.uh	r8,r7[0x6]
80005bec:	80 00       	ld.sh	r0,r0[0x0]
80005bee:	a3 e0       	*unknown*
80005bf0:	80 00       	ld.sh	r0,r0[0x0]
80005bf2:	62 5c       	ld.w	r12,r1[0x14]
80005bf4:	00 00       	add	r0,r0
80005bf6:	10 f4       	st.b	--r8,r4
80005bf8:	80 00       	ld.sh	r0,r0[0x0]
80005bfa:	93 50       	st.w	r9[0x14],r0

80005bfc <local_start_timer>:
//	MAKO_RX					AVR32_SSC_RX_DATA_0_PIN				[39 PortB Pin  7 00000080 Func 0]
//
void local_start_timer(void)
{
	//Route CLK to Timer
	AVR32_GPIO.port[0].pmr0s = 0x00100000;
80005bfc:	fe 78 10 00 	mov	r8,-61440
80005c00:	fc 19 00 10 	movh	r9,0x10
80005c04:	91 59       	st.w	r8[0x14],r9
	AVR32_GPIO.port[0].pmr1c = 0x00100000;
80005c06:	91 a9       	st.w	r8[0x28],r9
	AVR32_GPIO.port[0].gperc = 0x00100000;
80005c08:	91 29       	st.w	r8[0x8],r9
	//Route FS and Tri-State to Timer.
	AVR32_GPIO.port[1].pmr0c = 0x00000003;
80005c0a:	30 39       	mov	r9,3
80005c0c:	f1 49 01 18 	st.w	r8[280],r9
	AVR32_GPIO.port[1].pmr1c = 0x00000003;
80005c10:	f1 49 01 28 	st.w	r8[296],r9
	AVR32_GPIO.port[1].gperc = 0x00000003;
80005c14:	f1 49 01 08 	st.w	r8[264],r9

	(&AVR32_TC)->bmr = 4;
80005c18:	fe 78 38 00 	mov	r8,-51200
80005c1c:	30 49       	mov	r9,4
80005c1e:	f1 49 00 c4 	st.w	r8[196],r9
	(&AVR32_TC)->channel[0].cmr =
80005c22:	e0 69 91 0d 	mov	r9,37133
80005c26:	ea 19 00 52 	orh	r9,0x52
80005c2a:	91 19       	st.w	r8[0x4],r9
	1                          << AVR32_TC_CLKI_OFFSET     |
	AVR32_TC_TCCLKS_XC0        << AVR32_TC_TCCLKS_OFFSET;



	(&AVR32_TC)->channel[0].ra = 32;
80005c2c:	32 09       	mov	r9,32
80005c2e:	91 59       	st.w	r8[0x14],r9
	(&AVR32_TC)->channel[0].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
80005c30:	30 59       	mov	r9,5
80005c32:	91 09       	st.w	r8[0x0],r9
}
80005c34:	5e fc       	retal	r12
80005c36:	d7 03       	nop

80005c38 <tc_init>:
 * - fPBA/8 is used as clock source for TC
 * - Enables RC compare match interrupt
 * \param tc Base address of the TC module
 */
void tc_init()
{
80005c38:	d4 01       	pushm	lr

	volatile avr32_tc_t * tc = EXAMPLE_TC;
	
	INTC_register_interrupt(&_tc_interrupt, AVR32_TC_IRQ1, AVR32_INTC_INT2);
80005c3a:	30 2a       	mov	r10,2
80005c3c:	e0 6b 01 c1 	mov	r11,449
80005c40:	48 ec       	lddpc	r12,80005c78 <tc_init+0x40>
80005c42:	f0 1f 00 0f 	mcall	80005c7c <tc_init+0x44>
		.cpas  = 0,
		.lovrs = 0,
		.covfs = 0
	};
	// Initialize the timer/counter.
	tc_init_waveform(tc, &waveform_opt);
80005c46:	48 fb       	lddpc	r11,80005c80 <tc_init+0x48>
80005c48:	fe 7c 38 00 	mov	r12,-51200
80005c4c:	f0 1f 00 0e 	mcall	80005c84 <tc_init+0x4c>
	 * We want: (1 / (fPBA / 8)) * RC = 10 ms, hence RC = (fPBA / 8) / 100
	 * to get an interrupt every 10 ms.
	 */
	//tc_write_rc(tc, EXAMPLE_TC_CHANNEL, (sysclk_get_pba_hz() / 8 / 100));
	
	tc_write_rc(tc, EXAMPLE_TC_CHANNEL, ((FOSC0*2) / 8 / 100));
80005c50:	e0 6a 75 30 	mov	r10,30000
80005c54:	30 1b       	mov	r11,1
80005c56:	fe 7c 38 00 	mov	r12,-51200
80005c5a:	f0 1f 00 0c 	mcall	80005c88 <tc_init+0x50>
	
	//tc_write_rc(tc, EXAMPLE_TC_CHANNEL, (FOSC0 / 8 / 100000));
	
	
	// configure the timer interrupt
	tc_configure_interrupts(tc, EXAMPLE_TC_CHANNEL, &tc_interrupt);
80005c5e:	48 ca       	lddpc	r10,80005c8c <tc_init+0x54>
80005c60:	30 1b       	mov	r11,1
80005c62:	fe 7c 38 00 	mov	r12,-51200
80005c66:	f0 1f 00 0b 	mcall	80005c90 <tc_init+0x58>
	// Start the timer/counter.
	tc_start(tc, EXAMPLE_TC_CHANNEL);
80005c6a:	30 1b       	mov	r11,1
80005c6c:	fe 7c 38 00 	mov	r12,-51200
80005c70:	f0 1f 00 09 	mcall	80005c94 <tc_init+0x5c>
80005c74:	d8 02       	popm	pc
80005c76:	00 00       	add	r0,r0
80005c78:	80 00       	ld.sh	r0,r0[0x0]
80005c7a:	5c 98       	brev	r8
80005c7c:	80 00       	ld.sh	r0,r0[0x0]
80005c7e:	5c bc       	swap.b	r12
80005c80:	80 01       	ld.sh	r1,r0[0x0]
80005c82:	8e cc       	ld.uh	r12,r7[0x8]
80005c84:	80 00       	ld.sh	r0,r0[0x0]
80005c86:	5f a2       	srle	r2
80005c88:	80 00       	ld.sh	r0,r0[0x0]
80005c8a:	60 62       	ld.w	r2,r0[0x18]
80005c8c:	80 01       	ld.sh	r1,r0[0x0]
80005c8e:	8e c8       	ld.uh	r8,r7[0x8]
80005c90:	80 00       	ld.sh	r0,r0[0x0]
80005c92:	60 96       	ld.w	r6,r0[0x24]
80005c94:	80 00       	ld.sh	r0,r0[0x0]
80005c96:	60 3e       	ld.w	lr,r0[0xc]

80005c98 <_tc_interrupt>:
volatile U32 tc_tick = 0;

//brief Default interrupt handler.
__attribute__((__interrupt__))
static void _tc_interrupt(void)
 {
80005c98:	d4 01       	pushm	lr
	// Increment the 10ms seconds counter
	tc_tick++;
80005c9a:	48 68       	lddpc	r8,80005cb0 <_tc_interrupt+0x18>
80005c9c:	70 09       	ld.w	r9,r8[0x0]
80005c9e:	2f f9       	sub	r9,-1
80005ca0:	91 09       	st.w	r8[0x0],r9
	/*
	 * TODO: Place a breakpoint here and watch the update of tc_tick variable
	 * in the Watch Window.
	 */
	// Clear the interrupt flag. This is a side effect of reading the TC SR.
	tc_read_sr(EXAMPLE_TC, EXAMPLE_TC_CHANNEL);
80005ca2:	30 1b       	mov	r11,1
80005ca4:	fe 7c 38 00 	mov	r12,-51200
80005ca8:	f0 1f 00 03 	mcall	80005cb4 <_tc_interrupt+0x1c>
	
}
80005cac:	d4 02       	popm	lr
80005cae:	d6 03       	rete
80005cb0:	00 00       	add	r0,r0
80005cb2:	11 04       	ld.w	r4,r8++
80005cb4:	80 00       	ld.sh	r0,r0[0x0]
80005cb6:	60 50       	ld.w	r0,r0[0x14]

80005cb8 <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
80005cb8:	c0 08       	rjmp	80005cb8 <_unhandled_interrupt>
80005cba:	d7 03       	nop

80005cbc <INTC_register_interrupt>:
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
80005cbc:	f6 08 16 05 	lsr	r8,r11,0x5

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
80005cc0:	49 99       	lddpc	r9,80005d24 <INTC_register_interrupt+0x68>
80005cc2:	f2 08 00 39 	add	r9,r9,r8<<0x3
80005cc6:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
80005cca:	72 19       	ld.w	r9,r9[0x4]
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
80005ccc:	f2 0b 09 2c 	st.w	r9[r11<<0x2],r12
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
80005cd0:	58 0a       	cp.w	r10,0
80005cd2:	c0 91       	brne	80005ce4 <INTC_register_interrupt+0x28>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80005cd4:	49 59       	lddpc	r9,80005d28 <INTC_register_interrupt+0x6c>
80005cd6:	49 6a       	lddpc	r10,80005d2c <INTC_register_interrupt+0x70>
80005cd8:	12 1a       	sub	r10,r9
80005cda:	fe 79 08 00 	mov	r9,-63488
80005cde:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80005ce2:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT1) {
80005ce4:	58 1a       	cp.w	r10,1
80005ce6:	c0 a1       	brne	80005cfa <INTC_register_interrupt+0x3e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
80005ce8:	49 09       	lddpc	r9,80005d28 <INTC_register_interrupt+0x6c>
80005cea:	49 2a       	lddpc	r10,80005d30 <INTC_register_interrupt+0x74>
80005cec:	12 1a       	sub	r10,r9
80005cee:	bf aa       	sbr	r10,0x1e
80005cf0:	fe 79 08 00 	mov	r9,-63488
80005cf4:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80005cf8:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT2) {
80005cfa:	58 2a       	cp.w	r10,2
80005cfc:	c0 a1       	brne	80005d10 <INTC_register_interrupt+0x54>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
80005cfe:	48 b9       	lddpc	r9,80005d28 <INTC_register_interrupt+0x6c>
80005d00:	48 da       	lddpc	r10,80005d34 <INTC_register_interrupt+0x78>
80005d02:	12 1a       	sub	r10,r9
80005d04:	bf ba       	sbr	r10,0x1f
80005d06:	fe 79 08 00 	mov	r9,-63488
80005d0a:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80005d0e:	5e fc       	retal	r12
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
80005d10:	48 69       	lddpc	r9,80005d28 <INTC_register_interrupt+0x6c>
80005d12:	48 aa       	lddpc	r10,80005d38 <INTC_register_interrupt+0x7c>
80005d14:	12 1a       	sub	r10,r9
80005d16:	ea 1a c0 00 	orh	r10,0xc000
80005d1a:	fe 79 08 00 	mov	r9,-63488
80005d1e:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80005d22:	5e fc       	retal	r12
80005d24:	80 01       	ld.sh	r1,r0[0x0]
80005d26:	8e d4       	ld.uh	r4,r7[0xa]
80005d28:	80 01       	ld.sh	r1,r0[0x0]
80005d2a:	00 00       	add	r0,r0
80005d2c:	80 01       	ld.sh	r1,r0[0x0]
80005d2e:	01 04       	ld.w	r4,r0++
80005d30:	80 01       	ld.sh	r1,r0[0x0]
80005d32:	01 12       	ld.sh	r2,r0++
80005d34:	80 01       	ld.sh	r1,r0[0x0]
80005d36:	01 20       	ld.uh	r0,r0++
80005d38:	80 01       	ld.sh	r1,r0[0x0]
80005d3a:	01 2e       	ld.uh	lr,r0++

80005d3c <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
80005d3c:	d4 21       	pushm	r4-r7,lr
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
80005d3e:	49 18       	lddpc	r8,80005d80 <INTC_init_interrupts+0x44>
80005d40:	e3 b8 00 01 	mtsr	0x4,r8
80005d44:	49 0e       	lddpc	lr,80005d84 <INTC_init_interrupts+0x48>
80005d46:	30 07       	mov	r7,0
80005d48:	0e 94       	mov	r4,r7
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80005d4a:	49 0c       	lddpc	r12,80005d88 <INTC_init_interrupts+0x4c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80005d4c:	49 05       	lddpc	r5,80005d8c <INTC_init_interrupts+0x50>
80005d4e:	10 15       	sub	r5,r8
80005d50:	fe 76 08 00 	mov	r6,-63488
80005d54:	c1 08       	rjmp	80005d74 <INTC_init_interrupts+0x38>
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
80005d56:	08 98       	mov	r8,r4
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
80005d58:	7c 1b       	ld.w	r11,lr[0x4]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80005d5a:	7c 0a       	ld.w	r10,lr[0x0]
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80005d5c:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
80005d60:	2f f8       	sub	r8,-1

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80005d62:	10 3a       	cp.w	r10,r8
80005d64:	fe 9b ff fc 	brhi	80005d5c <INTC_init_interrupts+0x20>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80005d68:	ec 07 09 25 	st.w	r6[r7<<0x2],r5
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
80005d6c:	2f f7       	sub	r7,-1
80005d6e:	2f 8e       	sub	lr,-8
80005d70:	59 37       	cp.w	r7,19
80005d72:	c0 50       	breq	80005d7c <INTC_init_interrupts+0x40>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80005d74:	7c 08       	ld.w	r8,lr[0x0]
80005d76:	58 08       	cp.w	r8,0
80005d78:	ce f1       	brne	80005d56 <INTC_init_interrupts+0x1a>
80005d7a:	cf 7b       	rjmp	80005d68 <INTC_init_interrupts+0x2c>
80005d7c:	d8 22       	popm	r4-r7,pc
80005d7e:	00 00       	add	r0,r0
80005d80:	80 01       	ld.sh	r1,r0[0x0]
80005d82:	00 00       	add	r0,r0
80005d84:	80 01       	ld.sh	r1,r0[0x0]
80005d86:	8e d4       	ld.uh	r4,r7[0xa]
80005d88:	80 00       	ld.sh	r0,r0[0x0]
80005d8a:	5c b8       	swap.b	r8
80005d8c:	80 01       	ld.sh	r1,r0[0x0]
80005d8e:	01 04       	ld.w	r4,r0++

80005d90 <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
80005d90:	fe 78 08 00 	mov	r8,-63488
80005d94:	e0 69 00 83 	mov	r9,131
80005d98:	f2 0c 01 0c 	sub	r12,r9,r12
80005d9c:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
80005da0:	f2 ca ff c0 	sub	r10,r9,-64
80005da4:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	
	return (int_req)
80005da8:	58 08       	cp.w	r8,0
80005daa:	c0 21       	brne	80005dae <_get_interrupt_handler+0x1e>
80005dac:	5e fd       	retal	0
		? _int_handler_table[int_grp]._int_line_handler_table[32
80005dae:	f0 08 12 00 	clz	r8,r8
80005db2:	48 5a       	lddpc	r10,80005dc4 <_get_interrupt_handler+0x34>
80005db4:	f4 09 00 39 	add	r9,r10,r9<<0x3
80005db8:	f0 08 11 1f 	rsub	r8,r8,31
80005dbc:	72 19       	ld.w	r9,r9[0x4]
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	
	return (int_req)
80005dbe:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
80005dc2:	5e fc       	retal	r12
80005dc4:	80 01       	ld.sh	r1,r0[0x0]
80005dc6:	8e d4       	ld.uh	r4,r7[0xa]

80005dc8 <spi_initMaster>:

spi_status_t spi_initMaster(volatile avr32_spi_t *spi, const spi_options_t *options)
{
  u_avr32_spi_mr_t u_avr32_spi_mr;

  if (options->modfdis > 1) {
80005dc8:	f7 39 00 0d 	ld.ub	r9,r11[13]
80005dcc:	30 18       	mov	r8,1
80005dce:	f0 09 18 00 	cp.b	r9,r8
80005dd2:	e0 88 00 04 	brls	80005dda <spi_initMaster+0x12>
80005dd6:	30 2c       	mov	r12,2
80005dd8:	5e fc       	retal	r12
    return SPI_ERROR_ARGUMENT;
  }

  // Reset.
  spi->cr = AVR32_SPI_CR_SWRST_MASK;
80005dda:	e0 68 00 80 	mov	r8,128
80005dde:	99 08       	st.w	r12[0x0],r8

  // Master Mode.
  u_avr32_spi_mr.mr = spi->mr;
80005de0:	78 18       	ld.w	r8,r12[0x4]
  u_avr32_spi_mr.MR.mstr = 1;
80005de2:	30 19       	mov	r9,1
80005de4:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
  u_avr32_spi_mr.MR.modfdis = options->modfdis;
80005de8:	f7 39 00 0d 	ld.ub	r9,r11[13]
80005dec:	f1 d9 d0 81 	bfins	r8,r9,0x4,0x1
  u_avr32_spi_mr.MR.llb = 0;
80005df0:	30 09       	mov	r9,0
80005df2:	f1 d9 d0 e1 	bfins	r8,r9,0x7,0x1
  u_avr32_spi_mr.MR.pcs = (1 << AVR32_SPI_MR_PCS_SIZE) - 1;
80005df6:	30 fa       	mov	r10,15
80005df8:	f1 da d2 04 	bfins	r8,r10,0x10,0x4
  spi->mr = u_avr32_spi_mr.mr;
80005dfc:	99 18       	st.w	r12[0x4],r8
80005dfe:	5e f9       	retal	r9

80005e00 <spi_selectionMode>:

spi_status_t spi_selectionMode(volatile avr32_spi_t *spi,
                               unsigned char variable_ps,
                               unsigned char pcs_decode,
                               unsigned char delay)
{
80005e00:	d4 01       	pushm	lr
  u_avr32_spi_mr_t u_avr32_spi_mr;

  if (variable_ps > 1 ||
80005e02:	30 18       	mov	r8,1
80005e04:	f0 0b 18 00 	cp.b	r11,r8
80005e08:	5f be       	srhi	lr
80005e0a:	f0 0a 18 00 	cp.b	r10,r8
80005e0e:	5f b8       	srhi	r8
80005e10:	fd e8 10 08 	or	r8,lr,r8
80005e14:	c0 30       	breq	80005e1a <spi_selectionMode+0x1a>
80005e16:	30 2c       	mov	r12,2
80005e18:	d8 02       	popm	pc
      pcs_decode > 1) {
    return SPI_ERROR_ARGUMENT;
  }

  u_avr32_spi_mr.mr = spi->mr;
80005e1a:	78 18       	ld.w	r8,r12[0x4]
  u_avr32_spi_mr.MR.ps = variable_ps;
80005e1c:	f1 db d0 21 	bfins	r8,r11,0x1,0x1
  u_avr32_spi_mr.MR.pcsdec = pcs_decode;
80005e20:	f1 da d0 41 	bfins	r8,r10,0x2,0x1
  u_avr32_spi_mr.MR.dlybcs = delay;
80005e24:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8
  spi->mr = u_avr32_spi_mr.mr;
80005e28:	99 18       	st.w	r12[0x4],r8
80005e2a:	d8 0a       	popm	pc,r12=0

80005e2c <spi_selectChip>:
   */
  while (pdFALSE == xSemaphoreTake(xSPIMutex, 20));
#endif

  // Assert all lines; no peripheral is selected.
  spi->mr |= AVR32_SPI_MR_PCS_MASK;
80005e2c:	78 18       	ld.w	r8,r12[0x4]
80005e2e:	ea 18 00 0f 	orh	r8,0xf
80005e32:	99 18       	st.w	r12[0x4],r8

  if (spi->mr & AVR32_SPI_MR_PCSDEC_MASK) {
80005e34:	78 18       	ld.w	r8,r12[0x4]
80005e36:	e2 18 00 04 	andl	r8,0x4,COH
80005e3a:	c0 f0       	breq	80005e58 <spi_selectChip+0x2c>
    // The signal is decoded; allow up to 15 chips.
    if (chip > 14) {
80005e3c:	30 e8       	mov	r8,14
80005e3e:	f0 0b 18 00 	cp.b	r11,r8
80005e42:	e0 8b 00 19 	brhi	80005e74 <spi_selectChip+0x48>
      return SPI_ERROR_ARGUMENT;
    }

    spi->mr &= ~AVR32_SPI_MR_PCS_MASK | (chip << AVR32_SPI_MR_PCS_OFFSET);
80005e46:	78 18       	ld.w	r8,r12[0x4]
80005e48:	b1 6b       	lsl	r11,0x10
80005e4a:	ea 1b ff f0 	orh	r11,0xfff0
80005e4e:	e8 1b ff ff 	orl	r11,0xffff
80005e52:	10 6b       	and	r11,r8
80005e54:	99 1b       	st.w	r12[0x4],r11
80005e56:	5e fd       	retal	0
  } else {
    if (chip > 3) {
80005e58:	30 38       	mov	r8,3
80005e5a:	f0 0b 18 00 	cp.b	r11,r8
80005e5e:	e0 8b 00 0b 	brhi	80005e74 <spi_selectChip+0x48>
      return SPI_ERROR_ARGUMENT;
    }

    spi->mr &= ~(1 << (AVR32_SPI_MR_PCS_OFFSET + chip));
80005e62:	78 18       	ld.w	r8,r12[0x4]
80005e64:	2f 0b       	sub	r11,-16
80005e66:	30 19       	mov	r9,1
80005e68:	f2 0b 09 4b 	lsl	r11,r9,r11
80005e6c:	5c db       	com	r11
80005e6e:	10 6b       	and	r11,r8
80005e70:	99 1b       	st.w	r12[0x4],r11
80005e72:	5e fd       	retal	0
80005e74:	30 2c       	mov	r12,2
  }

  return SPI_OK;
}
80005e76:	5e fc       	retal	r12

80005e78 <spi_unselectChip>:


spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, unsigned char chip)
{
80005e78:	e0 68 27 10 	mov	r8,10000
  unsigned int timeout = SPI_TIMEOUT;

  while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
80005e7c:	c0 58       	rjmp	80005e86 <spi_unselectChip+0xe>
    if (!timeout--) {
80005e7e:	58 08       	cp.w	r8,0
80005e80:	c0 21       	brne	80005e84 <spi_unselectChip+0xc>
80005e82:	5e ff       	retal	1
80005e84:	20 18       	sub	r8,1

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, unsigned char chip)
{
  unsigned int timeout = SPI_TIMEOUT;

  while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
80005e86:	78 49       	ld.w	r9,r12[0x10]
80005e88:	e2 19 02 00 	andl	r9,0x200,COH
80005e8c:	cf 90       	breq	80005e7e <spi_unselectChip+0x6>
      return SPI_ERROR_TIMEOUT;
    }
  }

  // Assert all lines; no peripheral is selected.
  spi->mr |= AVR32_SPI_MR_PCS_MASK;
80005e8e:	78 18       	ld.w	r8,r12[0x4]
80005e90:	ea 18 00 0f 	orh	r8,0xf
80005e94:	99 18       	st.w	r12[0x4],r8

  // Last transfer, so deassert the current NPCS if CSAAT is set.
  spi->cr = AVR32_SPI_CR_LASTXFER_MASK;
80005e96:	fc 18 01 00 	movh	r8,0x100
80005e9a:	99 08       	st.w	r12[0x0],r8
80005e9c:	5e fd       	retal	0

80005e9e <spi_setupChipReg>:


spi_status_t spi_setupChipReg(volatile avr32_spi_t *spi,
                              const spi_options_t *options,
                              unsigned int pba_hz)
{
80005e9e:	eb cd 40 c0 	pushm	r6-r7,lr
  u_avr32_spi_csr_t u_avr32_spi_csr;

  if (options->spi_mode > 3 ||
80005ea2:	f7 38 00 0c 	ld.ub	r8,r11[12]
80005ea6:	30 39       	mov	r9,3
80005ea8:	f2 08 18 00 	cp.b	r8,r9
80005eac:	e0 8b 00 57 	brhi	80005f5a <spi_setupChipReg+0xbc>
      options->stay_act > 1 ||
80005eb0:	f7 39 00 0b 	ld.ub	r9,r11[11]
                              const spi_options_t *options,
                              unsigned int pba_hz)
{
  u_avr32_spi_csr_t u_avr32_spi_csr;

  if (options->spi_mode > 3 ||
80005eb4:	30 1e       	mov	lr,1
80005eb6:	fc 09 18 00 	cp.b	r9,lr
80005eba:	e0 8b 00 50 	brhi	80005f5a <spi_setupChipReg+0xbc>
      options->stay_act > 1 ||
      options->bits < 8 || options->bits > 16) {
80005ebe:	f7 3e 00 08 	ld.ub	lr,r11[8]
                              const spi_options_t *options,
                              unsigned int pba_hz)
{
  u_avr32_spi_csr_t u_avr32_spi_csr;

  if (options->spi_mode > 3 ||
80005ec2:	30 77       	mov	r7,7
80005ec4:	ee 0e 18 00 	cp.b	lr,r7
80005ec8:	e0 88 00 49 	brls	80005f5a <spi_setupChipReg+0xbc>
80005ecc:	31 07       	mov	r7,16
80005ece:	ee 0e 18 00 	cp.b	lr,r7
80005ed2:	e0 8b 00 44 	brhi	80005f5a <spi_setupChipReg+0xbc>
 *   \retval >=0  Success.
 *   \retval  <0  Error.
 */
static int getBaudDiv(const spi_options_t *options, unsigned int pba_hz)
{
  int baudDiv = (pba_hz + options->baudrate / 2) / options->baudrate;
80005ed6:	76 17       	ld.w	r7,r11[0x4]
80005ed8:	ee 06 16 01 	lsr	r6,r7,0x1
80005edc:	0c 0a       	add	r10,r6
80005ede:	f4 07 0d 06 	divu	r6,r10,r7

  if (baudDiv <= 0 || baudDiv > 255) {
80005ee2:	ec c7 00 01 	sub	r7,r6,1
80005ee6:	e0 47 00 fe 	cp.w	r7,254
80005eea:	e0 8b 00 38 	brhi	80005f5a <spi_setupChipReg+0xbc>
 *   \retval >=0  Success.
 *   \retval  <0  Error.
 */
static int getBaudDiv(const spi_options_t *options, unsigned int pba_hz)
{
  int baudDiv = (pba_hz + options->baudrate / 2) / options->baudrate;
80005eee:	0c 97       	mov	r7,r6
    return SPI_ERROR_ARGUMENT;
  }

  int baudDiv = getBaudDiv(options, pba_hz);

  if (baudDiv < 0) {
80005ef0:	58 06       	cp.w	r6,0
80005ef2:	c3 45       	brlt	80005f5a <spi_setupChipReg+0xbc>
    return SPI_ERROR_ARGUMENT;
  }

  // Will use CSR0 offsets; these are the same for CSR0 to CSR3.
  u_avr32_spi_csr.csr = 0;
80005ef4:	30 0a       	mov	r10,0
  u_avr32_spi_csr.CSR.cpol = options->spi_mode >> 1;
80005ef6:	f0 06 16 01 	lsr	r6,r8,0x1
80005efa:	f5 d6 d0 01 	bfins	r10,r6,0x0,0x1
  u_avr32_spi_csr.CSR.ncpha = (options->spi_mode & 0x1) ^ 0x1;
80005efe:	ec 18 00 01 	eorl	r8,0x1
80005f02:	f5 d8 d0 21 	bfins	r10,r8,0x1,0x1
  u_avr32_spi_csr.CSR.csaat = options->stay_act;
80005f06:	f5 d9 d0 61 	bfins	r10,r9,0x3,0x1
  u_avr32_spi_csr.CSR.bits = options->bits - 8;
80005f0a:	20 8e       	sub	lr,8
80005f0c:	f5 de d0 84 	bfins	r10,lr,0x4,0x4
  u_avr32_spi_csr.CSR.scbr = baudDiv;
80005f10:	f5 d7 d1 08 	bfins	r10,r7,0x8,0x8
  u_avr32_spi_csr.CSR.dlybs = options->spck_delay;
80005f14:	f7 38 00 09 	ld.ub	r8,r11[9]
80005f18:	f5 d8 d2 08 	bfins	r10,r8,0x10,0x8
  u_avr32_spi_csr.CSR.dlybct = options->trans_delay;
80005f1c:	f7 38 00 0a 	ld.ub	r8,r11[10]
80005f20:	f5 d8 d3 08 	bfins	r10,r8,0x18,0x8

  switch(options->reg) {
80005f24:	17 88       	ld.ub	r8,r11[0x0]
80005f26:	30 19       	mov	r9,1
80005f28:	f2 08 18 00 	cp.b	r8,r9
80005f2c:	c0 e0       	breq	80005f48 <spi_setupChipReg+0xaa>
80005f2e:	c0 a3       	brcs	80005f42 <spi_setupChipReg+0xa4>
80005f30:	30 29       	mov	r9,2
80005f32:	f2 08 18 00 	cp.b	r8,r9
80005f36:	c0 c0       	breq	80005f4e <spi_setupChipReg+0xb0>
80005f38:	30 39       	mov	r9,3
80005f3a:	f2 08 18 00 	cp.b	r8,r9
80005f3e:	c0 e1       	brne	80005f5a <spi_setupChipReg+0xbc>
80005f40:	c0 a8       	rjmp	80005f54 <spi_setupChipReg+0xb6>
    case 0:
      spi->csr0 = u_avr32_spi_csr.csr;
80005f42:	99 ca       	st.w	r12[0x30],r10
80005f44:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
      break;
    case 1:
      spi->csr1 = u_avr32_spi_csr.csr;
80005f48:	99 da       	st.w	r12[0x34],r10
80005f4a:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
      break;
    case 2:
      spi->csr2 = u_avr32_spi_csr.csr;
80005f4e:	99 ea       	st.w	r12[0x38],r10
80005f50:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
      break;
    case 3:
      spi->csr3 = u_avr32_spi_csr.csr;
80005f54:	99 fa       	st.w	r12[0x3c],r10
80005f56:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
      break;
80005f5a:	30 2c       	mov	r12,2
    }
  }
#endif

  return SPI_OK;
}
80005f5c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

80005f60 <spi_enable>:


void spi_enable(volatile avr32_spi_t *spi)
{
  spi->cr = AVR32_SPI_CR_SPIEN_MASK;
80005f60:	30 18       	mov	r8,1
80005f62:	99 08       	st.w	r12[0x0],r8
}
80005f64:	5e fc       	retal	r12

80005f66 <spi_write>:
  return ((spi->sr & AVR32_SPI_SR_TDRE_MASK) != 0);
}


spi_status_t spi_write(volatile avr32_spi_t *spi, unsigned short data)
{
80005f66:	e0 68 27 10 	mov	r8,10000
  unsigned int timeout = SPI_TIMEOUT;

  while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80005f6a:	c0 58       	rjmp	80005f74 <spi_write+0xe>
    if (!timeout--) {
80005f6c:	58 08       	cp.w	r8,0
80005f6e:	c0 21       	brne	80005f72 <spi_write+0xc>
80005f70:	5e ff       	retal	1
80005f72:	20 18       	sub	r8,1

spi_status_t spi_write(volatile avr32_spi_t *spi, unsigned short data)
{
  unsigned int timeout = SPI_TIMEOUT;

  while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80005f74:	78 49       	ld.w	r9,r12[0x10]
80005f76:	e2 19 00 02 	andl	r9,0x2,COH
80005f7a:	cf 90       	breq	80005f6c <spi_write+0x6>
    if (!timeout--) {
      return SPI_ERROR_TIMEOUT;
    }
  }

  spi->tdr = data << AVR32_SPI_TDR_TD_OFFSET;
80005f7c:	5c 7b       	castu.h	r11
80005f7e:	99 3b       	st.w	r12[0xc],r11
80005f80:	5e fd       	retal	0

80005f82 <spi_read>:
  return ((spi->sr & AVR32_SPI_SR_RDRF_MASK) != 0);
}


spi_status_t spi_read(volatile avr32_spi_t *spi, unsigned short *data)
{
80005f82:	e0 68 27 10 	mov	r8,10000
  unsigned int timeout = SPI_TIMEOUT;

  while ((spi->sr & (AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) !=
80005f86:	c0 58       	rjmp	80005f90 <spi_read+0xe>
         (AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) {
    if (!timeout--) {
80005f88:	58 08       	cp.w	r8,0
80005f8a:	c0 21       	brne	80005f8e <spi_read+0xc>
80005f8c:	5e ff       	retal	1
80005f8e:	20 18       	sub	r8,1

spi_status_t spi_read(volatile avr32_spi_t *spi, unsigned short *data)
{
  unsigned int timeout = SPI_TIMEOUT;

  while ((spi->sr & (AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) !=
80005f90:	78 49       	ld.w	r9,r12[0x10]
80005f92:	e2 19 02 01 	andl	r9,0x201,COH
80005f96:	e0 49 02 01 	cp.w	r9,513
80005f9a:	cf 71       	brne	80005f88 <spi_read+0x6>
    if (!timeout--) {
      return SPI_ERROR_TIMEOUT;
    }
  }

  *data = spi->rdr >> AVR32_SPI_RDR_RD_OFFSET;
80005f9c:	78 28       	ld.w	r8,r12[0x8]
80005f9e:	b6 08       	st.h	r11[0x0],r8
80005fa0:	5e fd       	retal	0

80005fa2 <tc_init_waveform>:


int tc_init_waveform(volatile avr32_tc_t *tc, const tc_waveform_opt_t *opt)
{
  // Check for valid input.
  if (opt->channel >= TC_NUMBER_OF_CHANNELS)
80005fa2:	76 09       	ld.w	r9,r11[0x0]
80005fa4:	58 29       	cp.w	r9,2
80005fa6:	e0 88 00 03 	brls	80005fac <tc_init_waveform+0xa>
80005faa:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  // GENERATE SIGNALS: Waveform operating mode.
  tc->channel[opt->channel].cmr = opt->bswtrg << AVR32_TC_BSWTRG_OFFSET |
80005fac:	76 18       	ld.w	r8,r11[0x4]
80005fae:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
80005fb2:	af ba       	sbr	r10,0xf
80005fb4:	10 9b       	mov	r11,r8
80005fb6:	e6 1b c0 00 	andh	r11,0xc000,COH
80005fba:	16 4a       	or	r10,r11
80005fbc:	10 9b       	mov	r11,r8
80005fbe:	e6 1b 30 00 	andh	r11,0x3000,COH
80005fc2:	16 4a       	or	r10,r11
80005fc4:	10 9b       	mov	r11,r8
80005fc6:	e6 1b 0c 00 	andh	r11,0xc00,COH
80005fca:	16 4a       	or	r10,r11
80005fcc:	10 9b       	mov	r11,r8
80005fce:	e6 1b 03 00 	andh	r11,0x300,COH
80005fd2:	16 4a       	or	r10,r11
80005fd4:	10 9b       	mov	r11,r8
80005fd6:	e6 1b 00 c0 	andh	r11,0xc0,COH
80005fda:	16 4a       	or	r10,r11
80005fdc:	10 9b       	mov	r11,r8
80005fde:	e6 1b 00 30 	andh	r11,0x30,COH
80005fe2:	16 4a       	or	r10,r11
80005fe4:	10 9b       	mov	r11,r8
80005fe6:	e6 1b 00 0c 	andh	r11,0xc,COH
80005fea:	16 4a       	or	r10,r11
80005fec:	10 9b       	mov	r11,r8
80005fee:	e6 1b 00 03 	andh	r11,0x3,COH
80005ff2:	16 4a       	or	r10,r11
80005ff4:	10 9b       	mov	r11,r8
80005ff6:	e2 1b 60 00 	andl	r11,0x6000,COH
80005ffa:	16 4a       	or	r10,r11
80005ffc:	f7 d8 c1 81 	bfextu	r11,r8,0xc,0x1
80006000:	f5 eb 10 ca 	or	r10,r10,r11<<0xc
80006004:	10 9b       	mov	r11,r8
80006006:	e2 1b 0c 00 	andl	r11,0xc00,COH
8000600a:	16 4a       	or	r10,r11
8000600c:	10 9b       	mov	r11,r8
8000600e:	e2 1b 03 00 	andl	r11,0x300,COH
80006012:	16 4a       	or	r10,r11
80006014:	f7 d8 c0 e1 	bfextu	r11,r8,0x7,0x1
80006018:	f5 eb 10 7a 	or	r10,r10,r11<<0x7
8000601c:	f7 d8 c0 c1 	bfextu	r11,r8,0x6,0x1
80006020:	f5 eb 10 6a 	or	r10,r10,r11<<0x6
80006024:	10 9b       	mov	r11,r8
80006026:	e2 1b 00 30 	andl	r11,0x30,COH
8000602a:	16 4a       	or	r10,r11
8000602c:	f1 d8 c0 61 	bfextu	r8,r8,0x3,0x1
80006030:	f5 e8 10 38 	or	r8,r10,r8<<0x3
80006034:	a5 69       	lsl	r9,0x4
80006036:	2f f9       	sub	r9,-1
80006038:	f8 09 09 28 	st.w	r12[r9<<0x2],r8
8000603c:	5e fd       	retal	0

8000603e <tc_start>:


int tc_start(volatile avr32_tc_t *tc, unsigned int channel)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
8000603e:	58 2b       	cp.w	r11,2
80006040:	e0 88 00 03 	brls	80006046 <tc_start+0x8>
80006044:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  // Enable, reset and start the selected timer/counter channel.
  tc->channel[channel].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
80006046:	a7 6b       	lsl	r11,0x6
80006048:	16 0c       	add	r12,r11
8000604a:	30 58       	mov	r8,5
8000604c:	99 08       	st.w	r12[0x0],r8
8000604e:	5e fd       	retal	0

80006050 <tc_read_sr>:


int tc_read_sr(volatile avr32_tc_t *tc, unsigned int channel)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80006050:	58 2b       	cp.w	r11,2
80006052:	e0 88 00 03 	brls	80006058 <tc_read_sr+0x8>
80006056:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  return tc->channel[channel].sr;
80006058:	a7 6b       	lsl	r11,0x6
8000605a:	2e 0b       	sub	r11,-32
8000605c:	16 0c       	add	r12,r11
8000605e:	78 0c       	ld.w	r12,r12[0x0]
}
80006060:	5e fc       	retal	r12

80006062 <tc_write_rc>:


int tc_write_rc(volatile avr32_tc_t *tc, unsigned int channel, unsigned short value)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80006062:	58 2b       	cp.w	r11,2
80006064:	e0 88 00 03 	brls	8000606a <tc_write_rc+0x8>
80006068:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  // This function is only available in WAVEFORM mode.
  if (Tst_bits(tc->channel[channel].cmr, AVR32_TC_WAVE_MASK))
8000606a:	f6 08 15 04 	lsl	r8,r11,0x4
8000606e:	2f f8       	sub	r8,-1
80006070:	f8 08 03 28 	ld.w	r8,r12[r8<<0x2]
80006074:	e2 18 80 00 	andl	r8,0x8000,COH
80006078:	c0 c0       	breq	80006090 <tc_write_rc+0x2e>
    Wr_bitfield(tc->channel[channel].rc, AVR32_TC_RC_MASK, value);
8000607a:	a7 6b       	lsl	r11,0x6
8000607c:	16 0c       	add	r12,r11
8000607e:	2e 4c       	sub	r12,-28
80006080:	78 08       	ld.w	r8,r12[0x0]
80006082:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
80006086:	e0 18 00 00 	andl	r8,0x0
8000608a:	f3 e8 10 08 	or	r8,r9,r8
8000608e:	99 08       	st.w	r12[0x0],r8

  return value;
80006090:	f9 da c0 10 	bfextu	r12,r10,0x0,0x10
}
80006094:	5e fc       	retal	r12

80006096 <tc_configure_interrupts>:
  return tc->channel[channel].imr;
}


int tc_configure_interrupts(volatile avr32_tc_t *tc, unsigned int channel, const tc_interrupt_t *bitfield)
{
80006096:	eb cd 40 fc 	pushm	r2-r7,lr
  bool global_interrupt_enabled = Is_global_interrupt_enabled();
8000609a:	e1 b9 00 00 	mfsr	r9,0x0

  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
8000609e:	58 2b       	cp.w	r11,2
800060a0:	e0 88 00 04 	brls	800060a8 <tc_configure_interrupts+0x12>
800060a4:	e3 cf c0 fc 	ldm	sp++,r2-r7,pc,r12=-1
	return flags;
}

static inline bool cpu_irq_is_enabled_flags(irqflags_t flags)
{
	return !(flags & AVR32_SR_GM_MASK);
800060a8:	ee 19 00 01 	eorh	r9,0x1
800060ac:	f3 d9 c2 01 	bfextu	r9,r9,0x10,0x1
    return TC_INVALID_ARGUMENT;

  // Enable the appropriate interrupts.
  tc->channel[channel].ier = bitfield->etrgs << AVR32_TC_ETRGS_OFFSET |
800060b0:	74 08       	ld.w	r8,r10[0x0]
800060b2:	ef d8 c0 e1 	bfextu	r7,r8,0x7,0x1
800060b6:	fd d8 c0 c1 	bfextu	lr,r8,0x6,0x1
800060ba:	a7 6e       	lsl	lr,0x6
800060bc:	fd e7 10 7e 	or	lr,lr,r7<<0x7
800060c0:	ef d8 c0 01 	bfextu	r7,r8,0x0,0x1
800060c4:	0e 4e       	or	lr,r7
800060c6:	ef d8 c0 a1 	bfextu	r7,r8,0x5,0x1
800060ca:	fd e7 10 5e 	or	lr,lr,r7<<0x5
800060ce:	ef d8 c0 81 	bfextu	r7,r8,0x4,0x1
800060d2:	fd e7 10 4e 	or	lr,lr,r7<<0x4
800060d6:	ef d8 c0 61 	bfextu	r7,r8,0x3,0x1
800060da:	fd e7 10 3e 	or	lr,lr,r7<<0x3
800060de:	ef d8 c0 41 	bfextu	r7,r8,0x2,0x1
800060e2:	fd e7 10 2e 	or	lr,lr,r7<<0x2
800060e6:	f1 d8 c0 21 	bfextu	r8,r8,0x1,0x1
800060ea:	fd e8 10 18 	or	r8,lr,r8<<0x1
800060ee:	f6 0e 15 06 	lsl	lr,r11,0x6
800060f2:	f8 0e 00 0e 	add	lr,r12,lr
800060f6:	2d ce       	sub	lr,-36
800060f8:	9d 08       	st.w	lr[0x0],r8
                             bitfield->cpas << AVR32_TC_CPAS_OFFSET |
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;

  // Disable the appropriate interrupts.
  if (global_interrupt_enabled) Disable_global_interrupt();
800060fa:	58 09       	cp.w	r9,0
800060fc:	c0 20       	breq	80006100 <tc_configure_interrupts+0x6a>
800060fe:	d3 03       	ssrf	0x10
  tc->channel[channel].idr = (~bitfield->etrgs & 1) << AVR32_TC_ETRGS_OFFSET |
80006100:	74 08       	ld.w	r8,r10[0x0]
80006102:	f1 d8 c0 e1 	bfextu	r8,r8,0x7,0x1
80006106:	e0 65 00 80 	mov	r5,128
8000610a:	f9 b5 01 00 	movne	r5,0
                             (~bitfield->ldrbs & 1) << AVR32_TC_LDRBS_OFFSET |
8000610e:	74 08       	ld.w	r8,r10[0x0]
80006110:	f1 d8 c0 c1 	bfextu	r8,r8,0x6,0x1
80006114:	f9 b4 00 40 	moveq	r4,64
80006118:	f9 b4 01 00 	movne	r4,0
                             (~bitfield->ldras & 1) << AVR32_TC_LDRAS_OFFSET |
8000611c:	74 08       	ld.w	r8,r10[0x0]
8000611e:	f1 d8 c0 a1 	bfextu	r8,r8,0x5,0x1
80006122:	f9 b3 00 20 	moveq	r3,32
80006126:	f9 b3 01 00 	movne	r3,0
                             (~bitfield->cpcs & 1) << AVR32_TC_CPCS_OFFSET |
8000612a:	74 08       	ld.w	r8,r10[0x0]
8000612c:	f1 d8 c0 81 	bfextu	r8,r8,0x4,0x1
80006130:	f9 b2 00 10 	moveq	r2,16
80006134:	f9 b2 01 00 	movne	r2,0
                             (~bitfield->cpbs & 1) << AVR32_TC_CPBS_OFFSET |
80006138:	74 08       	ld.w	r8,r10[0x0]
8000613a:	f1 d8 c0 61 	bfextu	r8,r8,0x3,0x1
8000613e:	f9 b6 00 08 	moveq	r6,8
80006142:	f9 b6 01 00 	movne	r6,0
                             (~bitfield->cpas & 1) << AVR32_TC_CPAS_OFFSET |
80006146:	74 08       	ld.w	r8,r10[0x0]
80006148:	f1 d8 c0 41 	bfextu	r8,r8,0x2,0x1
8000614c:	f9 b7 00 04 	moveq	r7,4
80006150:	f9 b7 01 00 	movne	r7,0
                             (~bitfield->lovrs & 1) << AVR32_TC_LOVRS_OFFSET |
80006154:	74 08       	ld.w	r8,r10[0x0]
80006156:	f1 d8 c0 21 	bfextu	r8,r8,0x1,0x1
8000615a:	f9 be 00 02 	moveq	lr,2
8000615e:	f9 be 01 00 	movne	lr,0
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;

  // Disable the appropriate interrupts.
  if (global_interrupt_enabled) Disable_global_interrupt();
  tc->channel[channel].idr = (~bitfield->etrgs & 1) << AVR32_TC_ETRGS_OFFSET |
80006162:	74 08       	ld.w	r8,r10[0x0]
80006164:	ec 18 00 01 	eorl	r8,0x1
80006168:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000616c:	eb e8 10 08 	or	r8,r5,r8
80006170:	08 48       	or	r8,r4
80006172:	06 48       	or	r8,r3
80006174:	04 48       	or	r8,r2
80006176:	0c 48       	or	r8,r6
80006178:	0e 48       	or	r8,r7
8000617a:	1c 48       	or	r8,lr
8000617c:	f6 0a 15 06 	lsl	r10,r11,0x6
80006180:	f8 0a 00 0a 	add	r10,r12,r10
80006184:	2d 8a       	sub	r10,-40
80006186:	95 08       	st.w	r10[0x0],r8
                             (~bitfield->cpcs & 1) << AVR32_TC_CPCS_OFFSET |
                             (~bitfield->cpbs & 1) << AVR32_TC_CPBS_OFFSET |
                             (~bitfield->cpas & 1) << AVR32_TC_CPAS_OFFSET |
                             (~bitfield->lovrs & 1) << AVR32_TC_LOVRS_OFFSET |
                             (~bitfield->covfs & 1) << AVR32_TC_COVFS_OFFSET;
  tc->channel[channel].sr;
80006188:	a7 6b       	lsl	r11,0x6
8000618a:	2e 0b       	sub	r11,-32
8000618c:	16 0c       	add	r12,r11
8000618e:	78 08       	ld.w	r8,r12[0x0]
  if (global_interrupt_enabled) Enable_global_interrupt();
80006190:	58 09       	cp.w	r9,0
80006192:	c0 31       	brne	80006198 <tc_configure_interrupts+0x102>
80006194:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0
80006198:	d5 03       	csrf	0x10
8000619a:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0
8000619e:	d7 03       	nop

800061a0 <twi_master_interrupt_handler>:
/*! \brief TWI interrupt handler.
 */
ISR(twi_master_interrupt_handler, CONF_TWI_IRQ_GROUP, CONF_TWI_IRQ_LEVEL)
{
	// get masked status register value
	int status = twi_inst->sr & twi_it_mask;
800061a0:	4a 78       	lddpc	r8,8000623c <twi_master_interrupt_handler+0x9c>
800061a2:	70 08       	ld.w	r8,r8[0x0]
800061a4:	70 89       	ld.w	r9,r8[0x20]
800061a6:	4a 7a       	lddpc	r10,80006240 <twi_master_interrupt_handler+0xa0>
800061a8:	74 0a       	ld.w	r10,r10[0x0]
800061aa:	f5 e9 00 09 	and	r9,r10,r9

	// this is a NACK
	if (status & AVR32_TWI_SR_NACK_MASK) {
800061ae:	12 9a       	mov	r10,r9
800061b0:	e2 1a 01 00 	andl	r10,0x100,COH
800061b4:	c3 91       	brne	80006226 <twi_master_interrupt_handler+0x86>
		goto nack;
	}
	// this is a RXRDY
	else if (status & AVR32_TWI_SR_RXRDY_MASK) {
800061b6:	12 9a       	mov	r10,r9
800061b8:	e2 1a 00 02 	andl	r10,0x2,COH
800061bc:	c1 70       	breq	800061ea <twi_master_interrupt_handler+0x4a>
		// get data from Receive Holding Register
		*twi_rx_data = twi_inst->rhr;
800061be:	4a 29       	lddpc	r9,80006244 <twi_master_interrupt_handler+0xa4>
800061c0:	72 0a       	ld.w	r10,r9[0x0]
800061c2:	70 cb       	ld.w	r11,r8[0x30]
800061c4:	b4 8b       	st.b	r10[0x0],r11
		twi_rx_data++;
800061c6:	72 0a       	ld.w	r10,r9[0x0]
800061c8:	2f fa       	sub	r10,-1
800061ca:	93 0a       	st.w	r9[0x0],r10
		// last byte to receive
		if (--twi_rx_nb_bytes == 1) {
800061cc:	49 f9       	lddpc	r9,80006248 <twi_master_interrupt_handler+0xa8>
800061ce:	72 0a       	ld.w	r10,r9[0x0]
800061d0:	20 1a       	sub	r10,1
800061d2:	93 0a       	st.w	r9[0x0],r10
800061d4:	72 09       	ld.w	r9,r9[0x0]
			// set stop bit
			twi_inst->cr = AVR32_TWI_STOP_MASK;
800061d6:	58 19       	cp.w	r9,1
800061d8:	f9 b9 00 02 	moveq	r9,2
800061dc:	f1 f9 0a 00 	st.weq	r8[0x0],r9
		}
		// receive complete
		if (twi_rx_nb_bytes == 0) {
800061e0:	49 a9       	lddpc	r9,80006248 <twi_master_interrupt_handler+0xa8>
800061e2:	72 09       	ld.w	r9,r9[0x0]
800061e4:	58 09       	cp.w	r9,0
800061e6:	c2 30       	breq	8000622c <twi_master_interrupt_handler+0x8c>
800061e8:	d6 03       	rete
			// finish the receive operation
			goto complete;
		}
	}
	// this is a TXRDY
	else if (status & AVR32_TWI_SR_TXRDY_MASK) {
800061ea:	12 9a       	mov	r10,r9
800061ec:	e2 1a 00 04 	andl	r10,0x4,COH
800061f0:	c1 70       	breq	8000621e <twi_master_interrupt_handler+0x7e>
		// decrease transmitted bytes number
		twi_tx_nb_bytes--;
800061f2:	49 79       	lddpc	r9,8000624c <twi_master_interrupt_handler+0xac>
800061f4:	72 0a       	ld.w	r10,r9[0x0]
800061f6:	20 1a       	sub	r10,1
800061f8:	93 0a       	st.w	r9[0x0],r10
		// no more bytes to transmit
		if (twi_tx_nb_bytes <= 0) {
800061fa:	72 09       	ld.w	r9,r9[0x0]
800061fc:	58 09       	cp.w	r9,0
800061fe:	e0 89 00 0a 	brgt	80006212 <twi_master_interrupt_handler+0x72>
			// enable TXCOMP IT and unmask all others IT
			twi_it_mask = AVR32_TWI_IER_TXCOMP_MASK;
80006202:	49 09       	lddpc	r9,80006240 <twi_master_interrupt_handler+0xa0>
80006204:	30 1a       	mov	r10,1
80006206:	93 0a       	st.w	r9[0x0],r10
			twi_inst->idr = ~0UL;
80006208:	3f fa       	mov	r10,-1
8000620a:	91 aa       	st.w	r8[0x28],r10
			twi_inst->ier = twi_it_mask;
8000620c:	72 09       	ld.w	r9,r9[0x0]
8000620e:	91 99       	st.w	r8[0x24],r9
80006210:	d6 03       	rete
		} else {
			// put the byte in the Transmit Holding Register
			twi_inst->thr = *twi_tx_data++;
80006212:	49 0a       	lddpc	r10,80006250 <twi_master_interrupt_handler+0xb0>
80006214:	74 09       	ld.w	r9,r10[0x0]
80006216:	13 3b       	ld.ub	r11,r9++
80006218:	91 db       	st.w	r8[0x34],r11
8000621a:	95 09       	st.w	r10[0x0],r9
8000621c:	d6 03       	rete
		}
	}
	// this is a TXCOMP
	else if (status & AVR32_TWI_SR_TXCOMP_MASK) {
8000621e:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
80006222:	c0 51       	brne	8000622c <twi_master_interrupt_handler+0x8c>
80006224:	d6 03       	rete
	}

	return;

nack:
	twi_nack = true;
80006226:	30 1a       	mov	r10,1
80006228:	48 b9       	lddpc	r9,80006254 <twi_master_interrupt_handler+0xb4>
8000622a:	b2 8a       	st.b	r9[0x0],r10

complete:
	// disable all interrupts
	twi_inst->idr = ~0UL;
8000622c:	3f f9       	mov	r9,-1
8000622e:	91 a9       	st.w	r8[0x28],r9
	twi_inst->sr;
80006230:	70 88       	ld.w	r8,r8[0x20]
	twi_busy = false;
80006232:	30 09       	mov	r9,0
80006234:	48 98       	lddpc	r8,80006258 <twi_master_interrupt_handler+0xb8>
80006236:	b0 89       	st.b	r8[0x0],r9
80006238:	d6 03       	rete
8000623a:	00 00       	add	r0,r0
8000623c:	00 00       	add	r0,r0
8000623e:	11 bc       	ld.ub	r12,r8[0x3]
80006240:	00 00       	add	r0,r0
80006242:	11 b8       	ld.ub	r8,r8[0x3]
80006244:	00 00       	add	r0,r0
80006246:	11 c8       	ld.ub	r8,r8[0x4]
80006248:	00 00       	add	r0,r0
8000624a:	11 c4       	ld.ub	r4,r8[0x4]
8000624c:	00 00       	add	r0,r0
8000624e:	11 b4       	ld.ub	r4,r8[0x3]
80006250:	00 00       	add	r0,r0
80006252:	11 c0       	ld.ub	r0,r8[0x4]
80006254:	00 00       	add	r0,r0
80006256:	11 b1       	ld.ub	r1,r8[0x3]
80006258:	00 00       	add	r0,r0
8000625a:	11 b0       	ld.ub	r0,r8[0x3]

8000625c <twi_master_init>:
	return TWI_SUCCESS;
}


int twi_master_init(volatile avr32_twi_t *twi, const twi_options_t *opt)
{
8000625c:	eb cd 40 e0 	pushm	r5-r7,lr
80006260:	18 97       	mov	r7,r12
80006262:	16 95       	mov	r5,r11
	irqflags_t flags = sysreg_read(AVR32_SR);
80006264:	e1 b8 00 00 	mfsr	r8,0x0
	int status = TWI_SUCCESS;

	// Set pointer to TWIM instance for IT
	twi_inst = twi;
80006268:	49 f9       	lddpc	r9,800062e4 <twi_master_init+0x88>
8000626a:	93 0c       	st.w	r9[0x0],r12

	// Disable TWI interrupts
	cpu_irq_disable();
8000626c:	d3 03       	ssrf	0x10
	twi->idr = ~0UL;
8000626e:	3f f9       	mov	r9,-1
80006270:	99 a9       	st.w	r12[0x28],r9
	twi->sr;
80006272:	78 89       	ld.w	r9,r12[0x20]

	// Reset TWI
	twi->cr = AVR32_TWI_CR_SWRST_MASK;
80006274:	e0 69 00 80 	mov	r9,128
80006278:	99 09       	st.w	r12[0x0],r9
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
8000627a:	e6 18 00 01 	andh	r8,0x1,COH
8000627e:	c0 21       	brne	80006282 <twi_master_init+0x26>
      cpu_irq_enable();
80006280:	d5 03       	csrf	0x10
	cpu_irq_restore(flags);

	// Dummy read in SR
	twi->sr;
80006282:	6e 88       	ld.w	r8,r7[0x20]

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80006284:	e1 b6 00 00 	mfsr	r6,0x0
	cpu_irq_disable();
80006288:	d3 03       	ssrf	0x10
	
	// register Register twim_master_interrupt_handler interrupt
	// on level CONF_TWI_IRQ_LEVEL
	flags = cpu_irq_save();

	irq_register_handler(&twi_master_interrupt_handler, CONF_TWI_IRQ_LINE, CONF_TWI_IRQ_LEVEL);
8000628a:	30 3a       	mov	r10,3
8000628c:	e0 6b 01 60 	mov	r11,352
80006290:	49 6c       	lddpc	r12,800062e8 <twi_master_init+0x8c>
80006292:	f0 1f 00 17 	mcall	800062ec <twi_master_init+0x90>
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80006296:	e6 16 00 01 	andh	r6,0x1,COH
8000629a:	c0 21       	brne	8000629e <twi_master_init+0x42>
      cpu_irq_enable();
8000629c:	d5 03       	csrf	0x10
		unsigned long pba_hz)
{
	unsigned int ckdiv = 0;
	unsigned int c_lh_div;

	c_lh_div = pba_hz / (speed * 2) - 4;
8000629e:	6a 19       	ld.w	r9,r5[0x4]
800062a0:	a1 79       	lsl	r9,0x1
800062a2:	6a 08       	ld.w	r8,r5[0x0]
800062a4:	f0 09 0d 08 	divu	r8,r8,r9
800062a8:	20 48       	sub	r8,4

	// cldiv must fit in 8 bits, ckdiv must fit in 3 bits
	while ((c_lh_div > 0xFF) && (ckdiv < 0x7)) {
800062aa:	e0 48 00 ff 	cp.w	r8,255
800062ae:	e0 8b 00 04 	brhi	800062b6 <twi_master_init+0x5a>
800062b2:	30 09       	mov	r9,0
800062b4:	c0 f8       	rjmp	800062d2 <twi_master_init+0x76>
800062b6:	30 09       	mov	r9,0
800062b8:	30 0c       	mov	r12,0
		// increase clock divider
		ckdiv++;
800062ba:	2f f9       	sub	r9,-1

		// divide cldiv value
		c_lh_div /= 2;
800062bc:	a1 98       	lsr	r8,0x1
	unsigned int c_lh_div;

	c_lh_div = pba_hz / (speed * 2) - 4;

	// cldiv must fit in 8 bits, ckdiv must fit in 3 bits
	while ((c_lh_div > 0xFF) && (ckdiv < 0x7)) {
800062be:	e0 48 00 ff 	cp.w	r8,255
800062c2:	5f bb       	srhi	r11
800062c4:	58 69       	cp.w	r9,6
800062c6:	5f 8a       	srls	r10
800062c8:	f7 ea 00 0a 	and	r10,r11,r10
800062cc:	f8 0a 18 00 	cp.b	r10,r12
800062d0:	cf 51       	brne	800062ba <twi_master_init+0x5e>
		// divide cldiv value
		c_lh_div /= 2;
	}

	// set clock waveform generator register
	twi->cwgr = ((c_lh_div << AVR32_TWI_CWGR_CLDIV_OFFSET) |
800062d2:	b1 69       	lsl	r9,0x10
800062d4:	f3 e8 10 89 	or	r9,r9,r8<<0x8
800062d8:	f3 e8 10 08 	or	r8,r9,r8
800062dc:	8f 48       	st.w	r7[0x10],r8

	//Probe the component
	//status = twi_probe(twi, opt->chip);

	return status;
}
800062de:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
800062e2:	00 00       	add	r0,r0
800062e4:	00 00       	add	r0,r0
800062e6:	11 bc       	ld.ub	r12,r8[0x3]
800062e8:	80 00       	ld.sh	r0,r0[0x0]
800062ea:	61 a0       	ld.w	r0,r0[0x68]
800062ec:	80 00       	ld.sh	r0,r0[0x0]
800062ee:	5c bc       	swap.b	r12

800062f0 <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
800062f0:	d4 01       	pushm	lr
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
800062f2:	f6 08 15 04 	lsl	r8,r11,0x4
800062f6:	14 38       	cp.w	r8,r10
800062f8:	f9 b8 08 10 	movls	r8,16
800062fc:	f9 b8 0b 08 	movhi	r8,8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
80006300:	f0 0b 02 4b 	mul	r11,r8,r11
80006304:	f6 09 16 01 	lsr	r9,r11,0x1
80006308:	f2 0a 00 3a 	add	r10,r9,r10<<0x3
8000630c:	f4 0b 0d 0a 	divu	r10,r10,r11
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
80006310:	f4 09 16 03 	lsr	r9,r10,0x3
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
80006314:	f2 cb 00 01 	sub	r11,r9,1
80006318:	e0 4b ff fe 	cp.w	r11,65534
8000631c:	e0 88 00 03 	brls	80006322 <usart_set_async_baudrate+0x32>
80006320:	da 0a       	popm	pc,r12=1
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
80006322:	78 1b       	ld.w	r11,r12[0x4]
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
80006324:	e8 6e 00 00 	mov	lr,524288
80006328:	59 08       	cp.w	r8,16
8000632a:	fc 08 17 10 	movne	r8,lr
8000632e:	f9 b8 00 00 	moveq	r8,0
80006332:	e4 1b ff f7 	andh	r11,0xfff7
80006336:	e0 1b fe cf 	andl	r11,0xfecf
8000633a:	16 48       	or	r8,r11
8000633c:	99 18       	st.w	r12[0x4],r8
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
8000633e:	f5 da c0 03 	bfextu	r10,r10,0x0,0x3
80006342:	f3 ea 11 09 	or	r9,r9,r10<<0x10
80006346:	99 89       	st.w	r12[0x20],r9
80006348:	d8 0a       	popm	pc,r12=0

8000634a <usart_write_char>:
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
8000634a:	78 58       	ld.w	r8,r12[0x14]
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
  if (usart_tx_ready(usart))
8000634c:	e2 18 00 02 	andl	r8,0x2,COH
80006350:	c0 31       	brne	80006356 <usart_write_char+0xc>
80006352:	30 2c       	mov	r12,2
80006354:	5e fc       	retal	r12
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
80006356:	f7 db c0 09 	bfextu	r11,r11,0x0,0x9
8000635a:	99 7b       	st.w	r12[0x1c],r11
8000635c:	5e fd       	retal	0
8000635e:	d7 03       	nop

80006360 <usart_putchar>:
    return USART_TX_BUSY;
}


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
80006360:	eb cd 40 e0 	pushm	r5-r7,lr
80006364:	18 96       	mov	r6,r12
80006366:	16 95       	mov	r5,r11
80006368:	e0 67 27 0f 	mov	r7,9999
8000636c:	c0 68       	rjmp	80006378 <usart_putchar+0x18>
  int timeout = USART_DEFAULT_TIMEOUT;

  do
  {
    if (!timeout--) return USART_FAILURE;
8000636e:	58 07       	cp.w	r7,0
80006370:	c0 31       	brne	80006376 <usart_putchar+0x16>
80006372:	e3 cf c0 e0 	ldm	sp++,r5-r7,pc,r12=-1
80006376:	20 17       	sub	r7,1
  } while (usart_write_char(usart, c) != USART_SUCCESS);
80006378:	0a 9b       	mov	r11,r5
8000637a:	0c 9c       	mov	r12,r6
8000637c:	f0 1f 00 03 	mcall	80006388 <usart_putchar+0x28>
80006380:	cf 71       	brne	8000636e <usart_putchar+0xe>

  return USART_SUCCESS;
}
80006382:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80006386:	00 00       	add	r0,r0
80006388:	80 00       	ld.sh	r0,r0[0x0]
8000638a:	63 4a       	ld.w	r10,r1[0x50]

8000638c <usart_read_char>:

int usart_read_char(volatile avr32_usart_t *usart, int *c)
{
  // Check for errors: frame, parity and overrun. In RS485 mode, a parity error
  // would mean that an address char has been received.
  if (usart->csr & (AVR32_USART_CSR_OVRE_MASK |
8000638c:	78 58       	ld.w	r8,r12[0x14]
8000638e:	e2 18 00 e0 	andl	r8,0xe0,COH
80006392:	c0 30       	breq	80006398 <usart_read_char+0xc>
80006394:	30 4c       	mov	r12,4
80006396:	5e fc       	retal	r12
 *
 * \return \c 1 if the USART Receive Holding Register is full, otherwise \c 0.
 */
__always_inline static int usart_test_hit(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_RXRDY_MASK) != 0;
80006398:	78 58       	ld.w	r8,r12[0x14]
                    AVR32_USART_CSR_FRAME_MASK |
                    AVR32_USART_CSR_PARE_MASK))
    return USART_RX_ERROR;

  // No error; if we really did receive a char, read it and return SUCCESS.
  if (usart_test_hit(usart))
8000639a:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000639e:	c0 31       	brne	800063a4 <usart_read_char+0x18>
800063a0:	30 3c       	mov	r12,3
800063a2:	5e fc       	retal	r12
  {
    *c = (usart->rhr & AVR32_USART_RHR_RXCHR_MASK) >> AVR32_USART_RHR_RXCHR_OFFSET;
800063a4:	78 68       	ld.w	r8,r12[0x18]
800063a6:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
800063aa:	97 08       	st.w	r11[0x0],r8
800063ac:	5e fd       	retal	0
800063ae:	d7 03       	nop

800063b0 <usart_getchar>:
    return USART_RX_EMPTY;
}


int usart_getchar(volatile avr32_usart_t *usart)
{
800063b0:	eb cd 40 c0 	pushm	r6-r7,lr
800063b4:	20 1d       	sub	sp,4
800063b6:	18 96       	mov	r6,r12
  int c, ret;

  while ((ret = usart_read_char(usart, &c)) == USART_RX_EMPTY);
800063b8:	1a 97       	mov	r7,sp
800063ba:	1a 9b       	mov	r11,sp
800063bc:	0c 9c       	mov	r12,r6
800063be:	f0 1f 00 07 	mcall	800063d8 <usart_getchar+0x28>
800063c2:	58 3c       	cp.w	r12,3
800063c4:	cf b0       	breq	800063ba <usart_getchar+0xa>

  if (ret == USART_RX_ERROR)
800063c6:	58 4c       	cp.w	r12,4
800063c8:	f9 bc 00 ff 	moveq	r12,-1
    return USART_FAILURE;

  return c;
800063cc:	fb fc 10 00 	ld.wne	r12,sp[0x0]
}
800063d0:	2f fd       	sub	sp,-4
800063d2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800063d6:	00 00       	add	r0,r0
800063d8:	80 00       	ld.sh	r0,r0[0x0]
800063da:	63 8c       	ld.w	r12,r1[0x60]

800063dc <usart_write_line>:


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
800063dc:	eb cd 40 c0 	pushm	r6-r7,lr
800063e0:	18 96       	mov	r6,r12
800063e2:	16 97       	mov	r7,r11
  while (*string != '\0')
800063e4:	17 8b       	ld.ub	r11,r11[0x0]
800063e6:	58 0b       	cp.w	r11,0
800063e8:	c0 80       	breq	800063f8 <usart_write_line+0x1c>
    usart_putchar(usart, *string++);
800063ea:	2f f7       	sub	r7,-1
800063ec:	0c 9c       	mov	r12,r6
800063ee:	f0 1f 00 04 	mcall	800063fc <usart_write_line+0x20>
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
800063f2:	0f 8b       	ld.ub	r11,r7[0x0]
800063f4:	58 0b       	cp.w	r11,0
800063f6:	cf a1       	brne	800063ea <usart_write_line+0xe>
800063f8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800063fc:	80 00       	ld.sh	r0,r0[0x0]
800063fe:	63 60       	ld.w	r0,r1[0x58]

80006400 <usart_reset>:
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
80006400:	e1 b8 00 00 	mfsr	r8,0x0

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
80006404:	e6 18 00 01 	andh	r8,0x1,COH
80006408:	c0 71       	brne	80006416 <usart_reset+0x16>
8000640a:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
8000640c:	3f f8       	mov	r8,-1
8000640e:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80006410:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
80006412:	d5 03       	csrf	0x10
80006414:	c0 48       	rjmp	8000641c <usart_reset+0x1c>
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
  usart->idr = 0xFFFFFFFF;
80006416:	3f f8       	mov	r8,-1
80006418:	99 38       	st.w	r12[0xc],r8
  usart->csr;
8000641a:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
8000641c:	30 08       	mov	r8,0
8000641e:	99 18       	st.w	r12[0x4],r8
  usart->rtor = 0;
80006420:	99 98       	st.w	r12[0x24],r8
  usart->ttgr = 0;
80006422:	99 a8       	st.w	r12[0x28],r8

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
80006424:	ea 68 61 0c 	mov	r8,680204
80006428:	99 08       	st.w	r12[0x0],r8
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
8000642a:	5e fc       	retal	r12

8000642c <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
8000642c:	eb cd 40 e0 	pushm	r5-r7,lr
80006430:	18 96       	mov	r6,r12
80006432:	16 97       	mov	r7,r11
80006434:	14 95       	mov	r5,r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
80006436:	f0 1f 00 2f 	mcall	800064f0 <usart_init_rs232+0xc4>

  // Check input values.
  if (!opt || // Null pointer.
8000643a:	58 07       	cp.w	r7,0
8000643c:	c5 80       	breq	800064ec <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
8000643e:	0f c8       	ld.ub	r8,r7[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80006440:	30 49       	mov	r9,4
80006442:	f2 08 18 00 	cp.b	r8,r9
80006446:	e0 88 00 53 	brls	800064ec <usart_init_rs232+0xc0>
8000644a:	30 99       	mov	r9,9
8000644c:	f2 08 18 00 	cp.b	r8,r9
80006450:	e0 8b 00 4e 	brhi	800064ec <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
80006454:	0f d9       	ld.ub	r9,r7[0x5]
80006456:	30 78       	mov	r8,7
80006458:	f0 09 18 00 	cp.b	r9,r8
8000645c:	e0 8b 00 48 	brhi	800064ec <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
80006460:	8e 39       	ld.sh	r9,r7[0x6]
80006462:	e0 68 01 01 	mov	r8,257
80006466:	f0 09 19 00 	cp.h	r9,r8
8000646a:	e0 8b 00 41 	brhi	800064ec <usart_init_rs232+0xc0>
      opt->channelmode > 3 ||
8000646e:	ef 39 00 08 	ld.ub	r9,r7[8]
80006472:	30 38       	mov	r8,3
80006474:	f0 09 18 00 	cp.b	r9,r8
80006478:	e0 8b 00 3a 	brhi	800064ec <usart_init_rs232+0xc0>
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
8000647c:	0a 9a       	mov	r10,r5
8000647e:	6e 0b       	ld.w	r11,r7[0x0]
80006480:	0c 9c       	mov	r12,r6
80006482:	f0 1f 00 1d 	mcall	800064f4 <usart_init_rs232+0xc8>
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80006486:	58 1c       	cp.w	r12,1
80006488:	c3 20       	breq	800064ec <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;

  if (opt->charlength == 9)
8000648a:	0f c8       	ld.ub	r8,r7[0x4]
8000648c:	30 99       	mov	r9,9
8000648e:	f2 08 18 00 	cp.b	r8,r9
80006492:	c0 51       	brne	8000649c <usart_init_rs232+0x70>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
80006494:	6c 18       	ld.w	r8,r6[0x4]
80006496:	b1 b8       	sbr	r8,0x11
80006498:	8d 18       	st.w	r6[0x4],r8
8000649a:	c0 68       	rjmp	800064a6 <usart_init_rs232+0x7a>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
8000649c:	6c 19       	ld.w	r9,r6[0x4]
8000649e:	20 58       	sub	r8,5
800064a0:	f3 e8 10 68 	or	r8,r9,r8<<0x6
800064a4:	8d 18       	st.w	r6[0x4],r8
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
800064a6:	6c 19       	ld.w	r9,r6[0x4]
800064a8:	ef 3a 00 08 	ld.ub	r10,r7[8]
800064ac:	0f d8       	ld.ub	r8,r7[0x5]
800064ae:	a9 78       	lsl	r8,0x9
800064b0:	f1 ea 10 e8 	or	r8,r8,r10<<0xe
800064b4:	12 48       	or	r8,r9
800064b6:	8d 18       	st.w	r6[0x4],r8
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
800064b8:	8e 38       	ld.sh	r8,r7[0x6]
800064ba:	30 29       	mov	r9,2
800064bc:	f2 08 19 00 	cp.h	r8,r9
800064c0:	e0 88 00 09 	brls	800064d2 <usart_init_rs232+0xa6>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
800064c4:	6c 18       	ld.w	r8,r6[0x4]
800064c6:	ad b8       	sbr	r8,0xd
800064c8:	8d 18       	st.w	r6[0x4],r8
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
800064ca:	8e b8       	ld.uh	r8,r7[0x6]
800064cc:	20 28       	sub	r8,2
800064ce:	8d a8       	st.w	r6[0x28],r8
800064d0:	c0 68       	rjmp	800064dc <usart_init_rs232+0xb0>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
800064d2:	6c 19       	ld.w	r9,r6[0x4]
800064d4:	5c 78       	castu.h	r8
800064d6:	f3 e8 10 c8 	or	r8,r9,r8<<0xc
800064da:	8d 18       	st.w	r6[0x4],r8

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
800064dc:	6c 18       	ld.w	r8,r6[0x4]
800064de:	e0 18 ff f0 	andl	r8,0xfff0
800064e2:	8d 18       	st.w	r6[0x4],r8
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
800064e4:	35 08       	mov	r8,80
800064e6:	8d 08       	st.w	r6[0x0],r8
800064e8:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
800064ec:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
800064f0:	80 00       	ld.sh	r0,r0[0x0]
800064f2:	64 00       	ld.w	r0,r2[0x0]
800064f4:	80 00       	ld.sh	r0,r0[0x0]
800064f6:	62 f0       	ld.w	r0,r1[0x3c]

800064f8 <disk_status>:


	return RES_OK;

	
}
800064f8:	5e fd       	retal	0

800064fa <disk_initialize>:
	//}
	//return STA_NOINIT;

	return stat;
	
}
800064fa:	5e fd       	retal	0

800064fc <get_fattime>:
	
}
#endif

DWORD get_fattime(void)
{
800064fc:	d4 01       	pushm	lr
	DWORD current_time = 0;
	date_time_t *t = now();
800064fe:	f0 1f 00 0e 	mcall	80006534 <get_fattime+0x38>

	current_time = (t->year - 1980) << 25;
80006502:	19 89       	ld.ub	r9,r12[0x0]
80006504:	19 98       	ld.ub	r8,r12[0x1]
80006506:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000650a:	f0 c8 07 bc 	sub	r8,r8,1980
8000650e:	b9 78       	lsl	r8,0x19
	current_time += t->month << 21;
80006510:	19 aa       	ld.ub	r10,r12[0x2]
80006512:	b5 7a       	lsl	r10,0x15
80006514:	19 b9       	ld.ub	r9,r12[0x3]
80006516:	b1 69       	lsl	r9,0x10
80006518:	12 0a       	add	r10,r9
	current_time += t->day << 16;
8000651a:	19 f9       	ld.ub	r9,r12[0x7]
8000651c:	a1 99       	lsr	r9,0x1
8000651e:	12 0a       	add	r10,r9
	current_time += t->hour << 11;
80006520:	19 d9       	ld.ub	r9,r12[0x5]
80006522:	ab 79       	lsl	r9,0xb
80006524:	12 0a       	add	r10,r9
	current_time += t->minute << 5;
80006526:	19 e9       	ld.ub	r9,r12[0x6]
80006528:	a5 79       	lsl	r9,0x5
8000652a:	f4 09 00 0c 	add	r12,r10,r9
	current_time += t->second / 2;
	
	return current_time;
8000652e:	10 0c       	add	r12,r8
80006530:	d8 02       	popm	pc
80006532:	00 00       	add	r0,r0
80006534:	80 00       	ld.sh	r0,r0[0x0]
80006536:	5b 54       	cp.w	r4,-11

80006538 <disk_ioctl>:
DRESULT disk_ioctl (
	BYTE pdrv,		/* Physical drive nmuber (0..) */
	BYTE cmd,		/* Control code */
	void *buff		/* Buffer to send/receive control data */
)
{
80006538:	eb cd 40 80 	pushm	r7,lr
8000653c:	14 97       	mov	r7,r10
	
	DRESULT res = RES_OK ;
	
	switch (cmd)
8000653e:	30 18       	mov	r8,1
80006540:	f0 0b 18 00 	cp.b	r11,r8
80006544:	c1 a0       	breq	80006578 <disk_ioctl+0x40>
80006546:	58 0b       	cp.w	r11,0
80006548:	c0 c0       	breq	80006560 <disk_ioctl+0x28>
8000654a:	30 28       	mov	r8,2
8000654c:	f0 0b 18 00 	cp.b	r11,r8
80006550:	c0 a0       	breq	80006564 <disk_ioctl+0x2c>
80006552:	30 38       	mov	r8,3
80006554:	f0 0b 18 00 	cp.b	r11,r8
80006558:	c0 b0       	breq	8000656e <disk_ioctl+0x36>
8000655a:	30 4c       	mov	r12,4
8000655c:	e3 cd 80 80 	ldm	sp++,r7,pc
80006560:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
	  
			break;
	  
		case GET_SECTOR_SIZE:
		
			*(WORD*)buff = 512;
80006564:	e0 68 02 00 	mov	r8,512
80006568:	b4 08       	st.h	r10[0x0],r8
8000656a:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
		
			break;	
		
		case GET_BLOCK_SIZE:
		
			*(WORD*)buff = 512;
8000656e:	e0 68 02 00 	mov	r8,512
80006572:	b4 08       	st.h	r10[0x0],r8
80006574:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
		
			break;
		
		case GET_SECTOR_COUNT:
		
			*(DWORD*)buff = SD_GetSectorCount();
80006578:	f0 1f 00 03 	mcall	80006584 <disk_ioctl+0x4c>
8000657c:	8f 0c       	st.w	r7[0x0],r12
8000657e:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
80006582:	00 00       	add	r0,r0
80006584:	80 00       	ld.sh	r0,r0[0x0]
80006586:	34 d0       	mov	r0,77

80006588 <disk_write>:
	BYTE pdrv,			/* Physical drive nmuber to identify the drive */
	const BYTE *buff,	/* Data to be written */
	DWORD sector,		/* Sector address in LBA */
	UINT count			/* Number of sectors to write */
)
{
80006588:	d4 01       	pushm	lr
8000658a:	16 9c       	mov	r12,r11
8000658c:	14 9b       	mov	r11,r10


	*******************************/

	
	 if(MAL_WriteDisk(buff, sector, BLOCK_BYTE_SIZE, count)==WRITE_DATA_SUCCESS)
8000658e:	5c 59       	castu.b	r9
80006590:	e0 6a 02 00 	mov	r10,512
80006594:	f0 1f 00 03 	mcall	800065a0 <disk_write+0x18>
80006598:	58 4c       	cp.w	r12,4
	 return RES_ERROR;
	



}
8000659a:	5f 1c       	srne	r12
8000659c:	d8 02       	popm	pc
8000659e:	00 00       	add	r0,r0
800065a0:	80 00       	ld.sh	r0,r0[0x0]
800065a2:	34 f0       	mov	r0,79

800065a4 <disk_read>:
	BYTE pdrv,		/* Physical drive nmuber to identify the drive */
	BYTE *buff,		/* Data buffer to store read data */
	DWORD sector,	/* Sector address in LBA */
	UINT count		/* Number of sectors to read */
)
{
800065a4:	d4 01       	pushm	lr
800065a6:	16 9c       	mov	r12,r11
800065a8:	14 9b       	mov	r11,r10

	***********************************/

	

	if(MAL_ReadDisk(buff, sector, BLOCK_BYTE_SIZE, count)==READ_DATA_SUCCESS)
800065aa:	5c 59       	castu.b	r9
800065ac:	e0 6a 02 00 	mov	r10,512
800065b0:	f0 1f 00 03 	mcall	800065bc <disk_read+0x18>
800065b4:	58 8c       	cp.w	r12,8
   		return RES_ERROR;




}
800065b6:	5f 1c       	srne	r12
800065b8:	d8 02       	popm	pc
800065ba:	00 00       	add	r0,r0
800065bc:	80 00       	ld.sh	r0,r0[0x0]
800065be:	35 20       	mov	r0,82

800065c0 <mem_cpy>:
		*(int*)d = *(int*)s;
		d += sizeof (int); s += sizeof (int);
		cnt -= sizeof (int);
	}
#endif
	while (cnt--)
800065c0:	58 0a       	cp.w	r10,0
800065c2:	5e 0c       	reteq	r12
800065c4:	30 08       	mov	r8,0
		*d++ = *s++;
800065c6:	f6 08 07 09 	ld.ub	r9,r11[r8]
800065ca:	f8 08 0b 09 	st.b	r12[r8],r9
800065ce:	2f f8       	sub	r8,-1
		*(int*)d = *(int*)s;
		d += sizeof (int); s += sizeof (int);
		cnt -= sizeof (int);
	}
#endif
	while (cnt--)
800065d0:	14 38       	cp.w	r8,r10
800065d2:	cf a1       	brne	800065c6 <mem_cpy+0x6>
800065d4:	5e fc       	retal	r12

800065d6 <mem_set>:
/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
800065d6:	58 0a       	cp.w	r10,0
800065d8:	5e 0c       	reteq	r12
		*d++ = (BYTE)val;
800065da:	18 cb       	st.b	r12++,r11
800065dc:	20 1a       	sub	r10,1
/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
800065de:	cf e1       	brne	800065da <mem_set+0x4>
800065e0:	5e fc       	retal	r12

800065e2 <chk_chr>:
	return r;
}

/* Check if chr is contained in the string */
static
int chk_chr (const char* str, int chr) {
800065e2:	18 98       	mov	r8,r12
	while (*str && *str != chr) str++;
800065e4:	19 8c       	ld.ub	r12,r12[0x0]
800065e6:	58 0c       	cp.w	r12,0
800065e8:	5e 0c       	reteq	r12
800065ea:	16 3c       	cp.w	r12,r11
800065ec:	5e 0c       	reteq	r12
800065ee:	2f f8       	sub	r8,-1
800065f0:	11 8c       	ld.ub	r12,r8[0x0]
800065f2:	58 0c       	cp.w	r12,0
800065f4:	5e 0c       	reteq	r12
800065f6:	16 3c       	cp.w	r12,r11
800065f8:	cf b1       	brne	800065ee <chk_chr+0xc>
	return *str;
}
800065fa:	5e fc       	retal	r12

800065fc <clust2sect>:
DWORD clust2sect (	/* !=0:Sector number, 0:Failed (invalid cluster#) */
	FATFS* fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
800065fc:	20 2b       	sub	r11,2
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
800065fe:	78 58       	ld.w	r8,r12[0x14]
80006600:	20 28       	sub	r8,2
80006602:	10 3b       	cp.w	r11,r8
80006604:	c0 23       	brcs	80006608 <clust2sect+0xc>
80006606:	5e fd       	retal	0
	return clst * fs->csize + fs->database;
80006608:	19 a8       	ld.ub	r8,r12[0x2]
8000660a:	b1 3b       	mul	r11,r8
8000660c:	78 a8       	ld.w	r8,r12[0x28]
8000660e:	f6 08 00 0c 	add	r12,r11,r8
}
80006612:	5e fc       	retal	r12

80006614 <clmt_clust>:
)
{
	DWORD cl, ncl, *tbl;


	tbl = fp->cltbl + 1;	/* Top of CLMT */
80006614:	78 9a       	ld.w	r10,r12[0x24]
80006616:	2f ca       	sub	r10,-4
	cl = ofs / SS(fp->fs) / fp->fs->csize;	/* Cluster order from top of the file */
80006618:	78 08       	ld.w	r8,r12[0x0]
8000661a:	11 a8       	ld.ub	r8,r8[0x2]
	for (;;) {
		ncl = *tbl++;			/* Number of cluters in the fragment */
8000661c:	74 0c       	ld.w	r12,r10[0x0]
		if (!ncl) return 0;		/* End of table? (error) */
8000661e:	58 0c       	cp.w	r12,0
80006620:	c1 80       	breq	80006650 <clmt_clust+0x3c>
{
	DWORD cl, ncl, *tbl;


	tbl = fp->cltbl + 1;	/* Top of CLMT */
	cl = ofs / SS(fp->fs) / fp->fs->csize;	/* Cluster order from top of the file */
80006622:	f6 09 16 09 	lsr	r9,r11,0x9
80006626:	f2 08 0d 08 	divu	r8,r9,r8
8000662a:	10 99       	mov	r9,r8
	for (;;) {
		ncl = *tbl++;			/* Number of cluters in the fragment */
8000662c:	2f ca       	sub	r10,-4
		if (!ncl) return 0;		/* End of table? (error) */
		if (cl < ncl) break;	/* In this fragment? */
8000662e:	18 38       	cp.w	r8,r12
80006630:	c0 82       	brcc	80006640 <clmt_clust+0x2c>
80006632:	c0 b8       	rjmp	80006648 <clmt_clust+0x34>
		cl -= ncl; tbl++;		/* Next fragment */
80006634:	18 19       	sub	r9,r12
/* FAT handling - Convert offset into cluster with link map table        */
/*-----------------------------------------------------------------------*/

#if _USE_FASTSEEK
static
DWORD clmt_clust (	/* <2:Error, >=2:Cluster number */
80006636:	2f 8a       	sub	r10,-8
	tbl = fp->cltbl + 1;	/* Top of CLMT */
	cl = ofs / SS(fp->fs) / fp->fs->csize;	/* Cluster order from top of the file */
	for (;;) {
		ncl = *tbl++;			/* Number of cluters in the fragment */
		if (!ncl) return 0;		/* End of table? (error) */
		if (cl < ncl) break;	/* In this fragment? */
80006638:	12 38       	cp.w	r8,r9
8000663a:	e0 8b 00 07 	brhi	80006648 <clmt_clust+0x34>
8000663e:	10 9c       	mov	r12,r8


	tbl = fp->cltbl + 1;	/* Top of CLMT */
	cl = ofs / SS(fp->fs) / fp->fs->csize;	/* Cluster order from top of the file */
	for (;;) {
		ncl = *tbl++;			/* Number of cluters in the fragment */
80006640:	74 18       	ld.w	r8,r10[0x4]
		if (!ncl) return 0;		/* End of table? (error) */
80006642:	58 08       	cp.w	r8,0
80006644:	cf 81       	brne	80006634 <clmt_clust+0x20>
80006646:	c0 58       	rjmp	80006650 <clmt_clust+0x3c>
		if (cl < ncl) break;	/* In this fragment? */
		cl -= ncl; tbl++;		/* Next fragment */
	}
	return cl + *tbl;	/* Return the cluster number */
80006648:	74 0c       	ld.w	r12,r10[0x0]
8000664a:	f2 0c 00 0c 	add	r12,r9,r12
8000664e:	5e fc       	retal	r12
80006650:	5e fd       	retal	0

80006652 <ld_clust>:
	const BYTE* dir	/* Pointer to the SFN entry */
)
{
	DWORD cl;

	cl = LD_WORD(dir + DIR_FstClusLO);
80006652:	f7 39 00 1b 	ld.ub	r9,r11[27]
80006656:	f7 38 00 1a 	ld.ub	r8,r11[26]
8000665a:	f1 e9 10 88 	or	r8,r8,r9<<0x8
	if (fs->fs_type == FS_FAT32)
8000665e:	19 8a       	ld.ub	r10,r12[0x0]
80006660:	30 39       	mov	r9,3
80006662:	f2 0a 18 00 	cp.b	r10,r9
80006666:	c0 91       	brne	80006678 <ld_clust+0x26>
		cl |= (DWORD)LD_WORD(dir + DIR_FstClusHI) << 16;
80006668:	f7 3a 00 15 	ld.ub	r10,r11[21]
8000666c:	f7 39 00 14 	ld.ub	r9,r11[20]
80006670:	f3 ea 10 89 	or	r9,r9,r10<<0x8
80006674:	f1 e9 11 08 	or	r8,r8,r9<<0x10

	return cl;
}
80006678:	5e f8       	retal	r8

8000667a <st_clust>:
void st_clust (
	BYTE* dir,	/* Pointer to the SFN entry */
	DWORD cl	/* Value to be set */
)
{
	ST_WORD(dir + DIR_FstClusLO, cl);
8000667a:	f9 6b 00 1a 	st.b	r12[26],r11
8000667e:	f1 db c1 08 	bfextu	r8,r11,0x8,0x8
80006682:	f9 68 00 1b 	st.b	r12[27],r8
	ST_WORD(dir + DIR_FstClusHI, cl >> 16);
80006686:	b1 8b       	lsr	r11,0x10
80006688:	f9 6b 00 14 	st.b	r12[20],r11
8000668c:	a9 8b       	lsr	r11,0x8
8000668e:	f9 6b 00 15 	st.b	r12[21],r11
}
80006692:	5e fc       	retal	r12

80006694 <get_ldnumber>:

static
int get_ldnumber (		/* Returns logical drive number (-1:invalid drive) */
	const TCHAR** path	/* Pointer to pointer to the path name */
)
{
80006694:	d4 21       	pushm	r4-r7,lr
	char c;
	TCHAR tc;
#endif


	if (*path) {	/* If the pointer is not a null */
80006696:	78 05       	ld.w	r5,r12[0x0]
80006698:	58 05       	cp.w	r5,0
8000669a:	c5 50       	breq	80006744 <get_ldnumber+0xb0>
		for (tt = *path; (UINT)*tt >= (_USE_LFN ? ' ' : '!') && *tt != ':'; tt++) ;	/* Find ':' in the path */
8000669c:	0b 84       	ld.ub	r4,r5[0x0]
8000669e:	32 08       	mov	r8,32
800066a0:	f0 04 18 00 	cp.b	r4,r8
800066a4:	5f b9       	srhi	r9
800066a6:	33 a8       	mov	r8,58
800066a8:	f0 04 18 00 	cp.b	r4,r8
800066ac:	5f 18       	srne	r8
800066ae:	f3 e8 00 08 	and	r8,r9,r8
800066b2:	c0 41       	brne	800066ba <get_ldnumber+0x26>
800066b4:	08 99       	mov	r9,r4
800066b6:	0a 98       	mov	r8,r5
800066b8:	c1 28       	rjmp	800066dc <get_ldnumber+0x48>
800066ba:	0a 98       	mov	r8,r5
800066bc:	32 06       	mov	r6,32
800066be:	33 a7       	mov	r7,58
800066c0:	30 0e       	mov	lr,0
800066c2:	2f f8       	sub	r8,-1
800066c4:	11 89       	ld.ub	r9,r8[0x0]
800066c6:	ec 09 18 00 	cp.b	r9,r6
800066ca:	5f bb       	srhi	r11
800066cc:	ee 09 18 00 	cp.b	r9,r7
800066d0:	5f 1a       	srne	r10
800066d2:	f7 ea 00 0a 	and	r10,r11,r10
800066d6:	fc 0a 18 00 	cp.b	r10,lr
800066da:	cf 41       	brne	800066c2 <get_ldnumber+0x2e>
		if (*tt == ':') {	/* If a ':' is exist in the path name */
800066dc:	33 aa       	mov	r10,58
800066de:	f4 09 18 00 	cp.b	r9,r10
800066e2:	c0 30       	breq	800066e8 <get_ldnumber+0x54>
800066e4:	30 04       	mov	r4,0
800066e6:	c3 08       	rjmp	80006746 <get_ldnumber+0xb2>
			tp = *path;
			i = *tp++ - '0'; 
800066e8:	23 04       	sub	r4,48
			if (i < 10 && tp == tt) {	/* Is there a numeric drive id? */
800066ea:	58 94       	cp.w	r4,9
800066ec:	5f 8a       	srls	r10
800066ee:	ea c9 ff ff 	sub	r9,r5,-1
800066f2:	12 38       	cp.w	r8,r9
800066f4:	5f 09       	sreq	r9
800066f6:	f5 e9 00 09 	and	r9,r10,r9
800066fa:	c0 60       	breq	80006706 <get_ldnumber+0x72>
				if (i < _VOLUMES) {	/* If a drive id is found, get the value and strip it */
800066fc:	58 04       	cp.w	r4,0
800066fe:	c2 31       	brne	80006744 <get_ldnumber+0xb0>
					vol = (int)i;
					*path = ++tt;
80006700:	2f f8       	sub	r8,-1
80006702:	99 08       	st.w	r12[0x0],r8
80006704:	c2 18       	rjmp	80006746 <get_ldnumber+0xb2>
				}
			}
#if _STR_VOLUME_ID
			 else {	/* No numeric drive number, find string drive id */
				i = 0; tt++;
80006706:	2f f8       	sub	r8,-1
				do {
					sp = str[i]; tp = *path;
80006708:	49 17       	lddpc	r7,8000674c <get_ldnumber+0xb8>
					do {	/* Compare a string drive id with path name */
						c = *sp++; tc = *tp++;
						if (IsLower(tc)) tc -= 0x20;
8000670a:	31 96       	mov	r6,25
					} while (c && (TCHAR)c == tc);
8000670c:	30 0e       	mov	lr,0
			 else {	/* No numeric drive number, find string drive id */
				i = 0; tt++;
				do {
					sp = str[i]; tp = *path;
					do {	/* Compare a string drive id with path name */
						c = *sp++; tc = *tp++;
8000670e:	0f 3a       	ld.ub	r10,r7++
80006710:	0b 39       	ld.ub	r9,r5++
						if (IsLower(tc)) tc -= 0x20;
80006712:	f2 cb 00 61 	sub	r11,r9,97
80006716:	ec 0b 18 00 	cp.b	r11,r6
8000671a:	e0 8b 00 03 	brhi	80006720 <get_ldnumber+0x8c>
8000671e:	22 09       	sub	r9,32
					} while (c && (TCHAR)c == tc);
80006720:	fc 0a 18 00 	cp.b	r10,lr
80006724:	5f 1b       	srne	r11
80006726:	f2 0a 18 00 	cp.b	r10,r9
8000672a:	5f 09       	sreq	r9
8000672c:	f7 e9 00 09 	and	r9,r11,r9
80006730:	fc 09 18 00 	cp.b	r9,lr
80006734:	ce d1       	brne	8000670e <get_ldnumber+0x7a>
				} while ((c || tp != tt) && ++i < _VOLUMES);	/* Repeat for each id until pattern match */
				if (i < _VOLUMES) {	/* If a drive id is found, get the value and strip it */
80006736:	10 35       	cp.w	r5,r8
80006738:	5f 19       	srne	r9
8000673a:	12 4b       	or	r11,r9
8000673c:	c0 41       	brne	80006744 <get_ldnumber+0xb0>
					vol = (int)i;
					*path = tt;
8000673e:	99 08       	st.w	r12[0x0],r8
80006740:	30 04       	mov	r4,0
80006742:	c0 28       	rjmp	80006746 <get_ldnumber+0xb2>
80006744:	3f f4       	mov	r4,-1
#else
		vol = 0;		/* Drive 0 */
#endif
	}
	return vol;
}
80006746:	08 9c       	mov	r12,r4
80006748:	d8 22       	popm	r4-r7,pc
8000674a:	00 00       	add	r0,r0
8000674c:	80 01       	ld.sh	r1,r0[0x0]
8000674e:	8f 98       	st.w	r7[0x24],r8

80006750 <sync_window>:
#if !_FS_READONLY
static
FRESULT sync_window (	/* FR_OK:succeeded, !=0:error */
	FATFS* fs		/* File system object */
)
{
80006750:	eb cd 40 f8 	pushm	r3-r7,lr
80006754:	18 97       	mov	r7,r12
	DWORD wsect;
	UINT nf;
	FRESULT res = FR_OK;


	if (fs->wflag) {	/* Write back the sector if it is dirty */
80006756:	19 c9       	ld.ub	r9,r12[0x4]
80006758:	30 08       	mov	r8,0
8000675a:	f0 09 18 00 	cp.b	r9,r8
8000675e:	c2 60       	breq	800067aa <sync_window+0x5a>
		wsect = fs->winsect;	/* Current sector number */
80006760:	78 b6       	ld.w	r6,r12[0x2c]
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK) {
80006762:	f8 c4 ff d0 	sub	r4,r12,-48
80006766:	30 19       	mov	r9,1
80006768:	0c 9a       	mov	r10,r6
8000676a:	08 9b       	mov	r11,r4
8000676c:	19 9c       	ld.ub	r12,r12[0x1]
8000676e:	f0 1f 00 11 	mcall	800067b0 <sync_window+0x60>
80006772:	c0 30       	breq	80006778 <sync_window+0x28>
80006774:	e3 cf 90 f8 	ldm	sp++,r3-r7,pc,r12=1
			res = FR_DISK_ERR;
		} else {
			fs->wflag = 0;
80006778:	30 08       	mov	r8,0
8000677a:	ae c8       	st.b	r7[0x4],r8
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
8000677c:	6e 89       	ld.w	r9,r7[0x20]
8000677e:	ec 09 01 09 	sub	r9,r6,r9
80006782:	6e 68       	ld.w	r8,r7[0x18]
80006784:	10 39       	cp.w	r9,r8
80006786:	c1 22       	brcc	800067aa <sync_window+0x5a>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
80006788:	0f b5       	ld.ub	r5,r7[0x3]
8000678a:	58 15       	cp.w	r5,1
8000678c:	e0 88 00 0f 	brls	800067aa <sync_window+0x5a>
					wsect += fs->fsize;
					disk_write(fs->drv, fs->win, wsect, 1);
80006790:	30 13       	mov	r3,1
			res = FR_DISK_ERR;
		} else {
			fs->wflag = 0;
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
					wsect += fs->fsize;
80006792:	6e 68       	ld.w	r8,r7[0x18]
80006794:	10 06       	add	r6,r8
					disk_write(fs->drv, fs->win, wsect, 1);
80006796:	06 99       	mov	r9,r3
80006798:	0c 9a       	mov	r10,r6
8000679a:	08 9b       	mov	r11,r4
8000679c:	0f 9c       	ld.ub	r12,r7[0x1]
8000679e:	f0 1f 00 05 	mcall	800067b0 <sync_window+0x60>
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK) {
			res = FR_DISK_ERR;
		} else {
			fs->wflag = 0;
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
800067a2:	20 15       	sub	r5,1
800067a4:	58 15       	cp.w	r5,1
800067a6:	fe 9b ff f6 	brhi	80006792 <sync_window+0x42>
800067aa:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
800067ae:	00 00       	add	r0,r0
800067b0:	80 00       	ld.sh	r0,r0[0x0]
800067b2:	65 88       	ld.w	r8,r2[0x60]

800067b4 <sync_fs>:
#if !_FS_READONLY
static
FRESULT sync_fs (	/* FR_OK:succeeded, !=0:error */
	FATFS* fs		/* File system object */
)
{
800067b4:	eb cd 40 e0 	pushm	r5-r7,lr
800067b8:	18 96       	mov	r6,r12
	FRESULT res;


	res = sync_window(fs);
800067ba:	f0 1f 00 31 	mcall	8000687c <sync_fs+0xc8>
800067be:	18 97       	mov	r7,r12
	if (res == FR_OK) {
800067c0:	c5 a1       	brne	80006874 <sync_fs+0xc0>
		/* Update FSInfo sector if needed */
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag == 1) {
800067c2:	0d 89       	ld.ub	r9,r6[0x0]
800067c4:	30 38       	mov	r8,3
800067c6:	f0 09 18 00 	cp.b	r9,r8
800067ca:	c4 e1       	brne	80006866 <sync_fs+0xb2>
800067cc:	0d d9       	ld.ub	r9,r6[0x5]
800067ce:	30 18       	mov	r8,1
800067d0:	f0 09 18 00 	cp.b	r9,r8
800067d4:	c4 91       	brne	80006866 <sync_fs+0xb2>
			/* Create FSInfo structure */
			mem_set(fs->win, 0, SS(fs));
800067d6:	ec c5 ff d0 	sub	r5,r6,-48
800067da:	e0 6a 02 00 	mov	r10,512
800067de:	30 0b       	mov	r11,0
800067e0:	0a 9c       	mov	r12,r5
800067e2:	f0 1f 00 28 	mcall	80006880 <sync_fs+0xcc>
			ST_WORD(fs->win + BS_55AA, 0xAA55);
800067e6:	35 58       	mov	r8,85
800067e8:	ed 68 02 2e 	st.b	r6[558],r8
800067ec:	3a a8       	mov	r8,-86
800067ee:	ed 68 02 2f 	st.b	r6[559],r8
			ST_DWORD(fs->win + FSI_LeadSig, 0x41615252);
800067f2:	35 28       	mov	r8,82
800067f4:	ed 68 00 30 	st.b	r6[48],r8
800067f8:	ed 68 00 31 	st.b	r6[49],r8
800067fc:	36 18       	mov	r8,97
800067fe:	ed 68 00 32 	st.b	r6[50],r8
80006802:	34 19       	mov	r9,65
80006804:	ed 69 00 33 	st.b	r6[51],r9
			ST_DWORD(fs->win + FSI_StrucSig, 0x61417272);
80006808:	37 2a       	mov	r10,114
8000680a:	ed 6a 02 14 	st.b	r6[532],r10
8000680e:	ed 6a 02 15 	st.b	r6[533],r10
80006812:	ed 69 02 16 	st.b	r6[534],r9
80006816:	ed 68 02 17 	st.b	r6[535],r8
			ST_DWORD(fs->win + FSI_Free_Count, fs->free_clust);
8000681a:	6c 48       	ld.w	r8,r6[0x10]
8000681c:	ed 68 02 18 	st.b	r6[536],r8
80006820:	f3 d8 c1 08 	bfextu	r9,r8,0x8,0x8
80006824:	ed 69 02 19 	st.b	r6[537],r9
80006828:	f0 09 16 10 	lsr	r9,r8,0x10
8000682c:	ed 69 02 1a 	st.b	r6[538],r9
80006830:	b9 88       	lsr	r8,0x18
80006832:	ed 68 02 1b 	st.b	r6[539],r8
			ST_DWORD(fs->win + FSI_Nxt_Free, fs->last_clust);
80006836:	6c 38       	ld.w	r8,r6[0xc]
80006838:	ed 68 02 1c 	st.b	r6[540],r8
8000683c:	f3 d8 c1 08 	bfextu	r9,r8,0x8,0x8
80006840:	ed 69 02 1d 	st.b	r6[541],r9
80006844:	f0 09 16 10 	lsr	r9,r8,0x10
80006848:	ed 69 02 1e 	st.b	r6[542],r9
8000684c:	b9 88       	lsr	r8,0x18
8000684e:	ed 68 02 1f 	st.b	r6[543],r8
			/* Write it into the FSInfo sector */
			fs->winsect = fs->volbase + 1;
80006852:	6c 7a       	ld.w	r10,r6[0x1c]
80006854:	2f fa       	sub	r10,-1
80006856:	8d ba       	st.w	r6[0x2c],r10
			disk_write(fs->drv, fs->win, fs->winsect, 1);
80006858:	30 19       	mov	r9,1
8000685a:	0a 9b       	mov	r11,r5
8000685c:	0d 9c       	ld.ub	r12,r6[0x1]
8000685e:	f0 1f 00 0a 	mcall	80006884 <sync_fs+0xd0>
			fs->fsi_flag = 0;
80006862:	30 08       	mov	r8,0
80006864:	ac d8       	st.b	r6[0x5],r8
		}
		/* Make sure that no pending write process in the physical drive */
		if (disk_ioctl(fs->drv, CTRL_SYNC, 0) != RES_OK)
80006866:	30 0a       	mov	r10,0
80006868:	14 9b       	mov	r11,r10
8000686a:	0d 9c       	ld.ub	r12,r6[0x1]
8000686c:	f0 1f 00 07 	mcall	80006888 <sync_fs+0xd4>
80006870:	f9 b7 01 01 	movne	r7,1
			res = FR_DISK_ERR;
	}

	return res;
}
80006874:	0e 9c       	mov	r12,r7
80006876:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000687a:	00 00       	add	r0,r0
8000687c:	80 00       	ld.sh	r0,r0[0x0]
8000687e:	67 50       	ld.w	r0,r3[0x54]
80006880:	80 00       	ld.sh	r0,r0[0x0]
80006882:	65 d6       	ld.w	r6,r2[0x74]
80006884:	80 00       	ld.sh	r0,r0[0x0]
80006886:	65 88       	ld.w	r8,r2[0x60]
80006888:	80 00       	ld.sh	r0,r0[0x0]
8000688a:	65 38       	ld.w	r8,r2[0x4c]

8000688c <f_mkfs>:
FRESULT f_mkfs (
	const TCHAR* path,	/* Logical drive number */
	BYTE sfd,			/* Partitioning rule 0:FDISK, 1:SFD */
	UINT au				/* Size of allocation unit in unit of byte or sector */
)
{
8000688c:	d4 31       	pushm	r0-r7,lr
8000688e:	20 ad       	sub	sp,40
80006890:	50 7c       	stdsp	sp[0x1c],r12
80006892:	16 97       	mov	r7,r11
80006894:	14 96       	mov	r6,r10
	DWORD eb[2];
#endif


	/* Check mounted drive and clear work area */
	if (sfd > 1) return FR_INVALID_PARAMETER;
80006896:	30 18       	mov	r8,1
80006898:	f0 0b 18 00 	cp.b	r11,r8
8000689c:	e0 88 00 05 	brls	800068a6 <f_mkfs+0x1a>
800068a0:	31 3c       	mov	r12,19
800068a2:	e0 8f 03 16 	bral	80006ece <f_mkfs+0x642>
	vol = get_ldnumber(&path);
800068a6:	fa cc ff e4 	sub	r12,sp,-28
800068aa:	f0 1f 01 8e 	mcall	80006ee0 <f_mkfs+0x654>
	if (vol < 0) return FR_INVALID_DRIVE;
800068ae:	c0 44       	brge	800068b6 <f_mkfs+0x2a>
800068b0:	30 bc       	mov	r12,11
800068b2:	e0 8f 03 0e 	bral	80006ece <f_mkfs+0x642>
	fs = FatFs[vol];
800068b6:	fe f8 06 2e 	ld.w	r8,pc[1582]
800068ba:	f0 0c 03 25 	ld.w	r5,r8[r12<<0x2]
	if (!fs) return FR_NOT_ENABLED;
800068be:	58 05       	cp.w	r5,0
800068c0:	c0 41       	brne	800068c8 <f_mkfs+0x3c>
800068c2:	30 cc       	mov	r12,12
800068c4:	e0 8f 03 05 	bral	80006ece <f_mkfs+0x642>
	fs->fs_type = 0;
800068c8:	30 08       	mov	r8,0
800068ca:	aa 88       	st.b	r5[0x0],r8
	pdrv = LD2PD(vol);	/* Physical drive */
	part = LD2PT(vol);	/* Partition (0:auto detect, 1-4:get from partition table)*/

	/* Get disk statics */
	stat = disk_initialize(pdrv);
800068cc:	e9 dc c0 08 	bfextu	r4,r12,0x0,0x8
800068d0:	08 9c       	mov	r12,r4
800068d2:	f0 1f 01 86 	mcall	80006ee8 <f_mkfs+0x65c>
	if (stat & STA_NOINIT) return FR_NOT_READY;
800068d6:	f1 dc c0 01 	bfextu	r8,r12,0x0,0x1
800068da:	c0 40       	breq	800068e2 <f_mkfs+0x56>
800068dc:	30 3c       	mov	r12,3
800068de:	e0 8f 02 f8 	bral	80006ece <f_mkfs+0x642>
	if (stat & STA_PROTECT) return FR_WRITE_PROTECTED;
800068e2:	e2 1c 00 04 	andl	r12,0x4,COH
800068e6:	c0 40       	breq	800068ee <f_mkfs+0x62>
800068e8:	30 ac       	mov	r12,10
800068ea:	e0 8f 02 f2 	bral	80006ece <f_mkfs+0x642>
		if (!tbl[4]) return FR_MKFS_ABORTED;	/* No partition? */
		b_vol = LD_DWORD(tbl + 8);	/* Volume start sector */
		n_vol = LD_DWORD(tbl + 12);	/* Volume size */
	} else {
		/* Create a partition in this function */
		if (disk_ioctl(pdrv, GET_SECTOR_COUNT, &n_vol) != RES_OK || n_vol < 128)
800068ee:	fa ca ff e0 	sub	r10,sp,-32
800068f2:	30 1b       	mov	r11,1
800068f4:	08 9c       	mov	r12,r4
800068f6:	f0 1f 01 7e 	mcall	80006eec <f_mkfs+0x660>
800068fa:	e0 81 02 e7 	brne	80006ec8 <f_mkfs+0x63c>
800068fe:	40 89       	lddsp	r9,sp[0x20]
80006900:	e0 49 00 7f 	cp.w	r9,127
80006904:	e0 88 02 e2 	brls	80006ec8 <f_mkfs+0x63c>
			return FR_DISK_ERR;
		b_vol = (sfd) ? 0 : 63;		/* Volume start sector */
80006908:	58 07       	cp.w	r7,0
8000690a:	f9 b1 01 00 	movne	r1,0
8000690e:	f9 b1 00 3f 	moveq	r1,63
		n_vol -= b_vol;				/* Volume size */
80006912:	02 19       	sub	r9,r1
80006914:	50 89       	stdsp	sp[0x20],r9
	}

	if (au & (au - 1)) au = 0;
80006916:	ec c8 00 01 	sub	r8,r6,1
8000691a:	0c 68       	and	r8,r6
8000691c:	c0 31       	brne	80006922 <f_mkfs+0x96>
	if (!au) {						/* AU auto selection */
8000691e:	58 06       	cp.w	r6,0
80006920:	c1 a1       	brne	80006954 <f_mkfs+0xc8>
		vs = n_vol / (2000 / (SS(fs) / 512));
80006922:	e0 6b 4d d3 	mov	r11,19923
80006926:	ea 1b 10 62 	orh	r11,0x1062
8000692a:	f2 0b 06 4a 	mulu.d	r10,r9,r11
8000692e:	f6 0c 16 07 	lsr	r12,r11,0x7
		for (i = 0; vs < vst[i]; i++) ;
80006932:	e0 4c 04 00 	cp.w	r12,1024
80006936:	c0 33       	brcs	8000693c <f_mkfs+0xb0>
80006938:	30 08       	mov	r8,0
8000693a:	c0 98       	rjmp	8000694c <f_mkfs+0xc0>
8000693c:	fe fa 05 b4 	ld.w	r10,pc[1460]
80006940:	2f ea       	sub	r10,-2
80006942:	30 08       	mov	r8,0
80006944:	2f f8       	sub	r8,-1
80006946:	15 2b       	ld.uh	r11,r10++
80006948:	16 3c       	cp.w	r12,r11
8000694a:	cf d3       	brcs	80006944 <f_mkfs+0xb8>
		au = cst[i];
8000694c:	fe fa 05 a8 	ld.w	r10,pc[1448]
80006950:	f4 08 05 16 	ld.uh	r6,r10[r8<<0x1]
	}
	if (au >= _MIN_SS) au /= SS(fs);	/* Number of sectors per cluster */
80006954:	e0 46 01 ff 	cp.w	r6,511
80006958:	e0 88 00 03 	brls	8000695e <f_mkfs+0xd2>
8000695c:	a9 96       	lsr	r6,0x9
	if (!au) au = 1;
8000695e:	58 06       	cp.w	r6,0
80006960:	f9 b6 00 01 	moveq	r6,1
80006964:	e0 60 00 80 	mov	r0,128
80006968:	00 36       	cp.w	r6,r0
8000696a:	ec 00 17 80 	movls	r0,r6
	if (au > 128) au = 128;

	/* Pre-compute number of clusters and FAT sub-type */
	n_clst = n_vol / au;
8000696e:	f2 00 0d 0a 	divu	r10,r9,r0
80006972:	14 98       	mov	r8,r10
	fmt = FS_FAT12;
	if (n_clst >= MIN_FAT16) fmt = FS_FAT16;
80006974:	e0 4a 0f f6 	cp.w	r10,4086
80006978:	f9 b3 03 01 	movlo	r3,1
8000697c:	f9 b3 02 02 	movhs	r3,2
	if (n_clst >= MIN_FAT32) fmt = FS_FAT32;
80006980:	e0 4a ff f5 	cp.w	r10,65525
80006984:	e0 88 00 04 	brls	8000698c <f_mkfs+0x100>
80006988:	30 33       	mov	r3,3
8000698a:	c0 58       	rjmp	80006994 <f_mkfs+0x108>

	/* Determine offset and size of FAT structure */
	if (fmt == FS_FAT32) {
8000698c:	30 3a       	mov	r10,3
8000698e:	f4 03 18 00 	cp.b	r3,r10
80006992:	c0 a1       	brne	800069a6 <f_mkfs+0x11a>
		n_fat = ((n_clst * 4) + 8 + SS(fs) - 1) / SS(fs);
80006994:	a3 68       	lsl	r8,0x2
80006996:	f0 c2 fd f9 	sub	r2,r8,-519
8000699a:	a9 92       	lsr	r2,0x9
8000699c:	30 0b       	mov	r11,0
8000699e:	50 2b       	stdsp	sp[0x8],r11
800069a0:	32 0a       	mov	r10,32
800069a2:	50 0a       	stdsp	sp[0x0],r10
800069a4:	c1 68       	rjmp	800069d0 <f_mkfs+0x144>
		n_rsv = 32;
		n_dir = 0;
	} else {
		n_fat = (fmt == FS_FAT12) ? (n_clst * 3 + 1) / 2 + 3 : (n_clst * 2) + 4;
800069a6:	30 1a       	mov	r10,1
800069a8:	f4 03 18 00 	cp.b	r3,r10
800069ac:	c0 81       	brne	800069bc <f_mkfs+0x130>
800069ae:	f0 08 00 18 	add	r8,r8,r8<<0x1
800069b2:	f0 c2 ff ff 	sub	r2,r8,-1
800069b6:	a1 92       	lsr	r2,0x1
800069b8:	2f d2       	sub	r2,-3
800069ba:	c0 48       	rjmp	800069c2 <f_mkfs+0x136>
800069bc:	2f e8       	sub	r8,-2
800069be:	f0 02 15 01 	lsl	r2,r8,0x1
		n_fat = (n_fat + SS(fs) - 1) / SS(fs);
800069c2:	e4 c2 fe 01 	sub	r2,r2,-511
800069c6:	a9 92       	lsr	r2,0x9
800069c8:	32 08       	mov	r8,32
800069ca:	50 28       	stdsp	sp[0x8],r8
800069cc:	30 1c       	mov	r12,1
800069ce:	50 0c       	stdsp	sp[0x0],r12
		n_rsv = 1;
		n_dir = (DWORD)N_ROOTDIR * SZ_DIRE / SS(fs);
	}
	b_fat = b_vol + n_rsv;				/* FAT area start sector */
800069d0:	40 0b       	lddsp	r11,sp[0x0]
800069d2:	02 0b       	add	r11,r1
800069d4:	50 1b       	stdsp	sp[0x4],r11
	b_dir = b_fat + n_fat * N_FATS;		/* Directory area start sector */
	b_data = b_dir + n_dir;				/* Data area start sector */
800069d6:	40 26       	lddsp	r6,sp[0x8]
800069d8:	04 06       	add	r6,r2
800069da:	16 06       	add	r6,r11
	if (n_vol < b_data + au - b_vol) return FR_MKFS_ABORTED;	/* Too small volume */
800069dc:	e0 01 01 08 	sub	r8,r0,r1
800069e0:	0c 08       	add	r8,r6
800069e2:	10 39       	cp.w	r9,r8
800069e4:	e0 83 02 74 	brlo	80006ecc <f_mkfs+0x640>

	/* Align data start sector to erase block boundary (for flash memory media) */
	if (disk_ioctl(pdrv, GET_BLOCK_SIZE, &n) != RES_OK || !n || n > 32768) n = 1;
800069e8:	fa ca ff dc 	sub	r10,sp,-36
800069ec:	30 3b       	mov	r11,3
800069ee:	08 9c       	mov	r12,r4
800069f0:	f0 1f 01 3f 	mcall	80006eec <f_mkfs+0x660>
800069f4:	c0 81       	brne	80006a04 <f_mkfs+0x178>
800069f6:	40 98       	lddsp	r8,sp[0x24]
800069f8:	58 08       	cp.w	r8,0
800069fa:	c0 50       	breq	80006a04 <f_mkfs+0x178>
800069fc:	e0 48 80 00 	cp.w	r8,32768
80006a00:	e0 88 00 04 	brls	80006a08 <f_mkfs+0x17c>
80006a04:	30 18       	mov	r8,1
80006a06:	50 98       	stdsp	sp[0x24],r8
	n = (b_data + n - 1) & ~(n - 1);	/* Next nearest erase block from current data start */
80006a08:	40 98       	lddsp	r8,sp[0x24]
	n = (n - b_data) / N_FATS;
80006a0a:	f0 c9 00 01 	sub	r9,r8,1
80006a0e:	0c 09       	add	r9,r6
80006a10:	5c 38       	neg	r8
80006a12:	f3 e8 00 08 	and	r8,r9,r8
80006a16:	f0 06 01 06 	sub	r6,r8,r6
80006a1a:	50 96       	stdsp	sp[0x24],r6
	if (fmt == FS_FAT32) {		/* FAT32: Move FAT offset */
80006a1c:	30 38       	mov	r8,3
80006a1e:	f0 03 18 00 	cp.b	r3,r8
80006a22:	c1 d1       	brne	80006a5c <f_mkfs+0x1d0>
		n_rsv += n;
80006a24:	40 0a       	lddsp	r10,sp[0x0]
80006a26:	0c 0a       	add	r10,r6
80006a28:	50 0a       	stdsp	sp[0x0],r10
		b_fat += n;
80006a2a:	40 19       	lddsp	r9,sp[0x4]
80006a2c:	0c 09       	add	r9,r6
80006a2e:	50 19       	stdsp	sp[0x4],r9
	} else {					/* FAT12/16: Expand FAT size */
		n_fat += n;
	}

	/* Determine number of clusters and final check of validity of the FAT sub-type */
	n_clst = (n_vol - n_rsv - n_fat * N_FATS - n_dir) / au;
80006a30:	40 88       	lddsp	r8,sp[0x20]
80006a32:	f0 0a 01 0b 	sub	r11,r8,r10
80006a36:	04 1b       	sub	r11,r2
80006a38:	40 2c       	lddsp	r12,sp[0x8]
80006a3a:	18 1b       	sub	r11,r12
80006a3c:	f6 00 0d 0a 	divu	r10,r11,r0
80006a40:	50 4a       	stdsp	sp[0x10],r10
	if (   (fmt == FS_FAT16 && n_clst < MIN_FAT16)
		|| (fmt == FS_FAT32 && n_clst < MIN_FAT32))
80006a42:	30 39       	mov	r9,3
80006a44:	f2 03 18 00 	cp.b	r3,r9
80006a48:	5f 0b       	sreq	r11
80006a4a:	50 3b       	stdsp	sp[0xc],r11
		n_fat += n;
	}

	/* Determine number of clusters and final check of validity of the FAT sub-type */
	n_clst = (n_vol - n_rsv - n_fat * N_FATS - n_dir) / au;
	if (   (fmt == FS_FAT16 && n_clst < MIN_FAT16)
80006a4c:	e0 4a ff f5 	cp.w	r10,65525
80006a50:	5f 89       	srls	r9
80006a52:	f7 e9 00 09 	and	r9,r11,r9
80006a56:	e0 81 02 3b 	brne	80006ecc <f_mkfs+0x640>
80006a5a:	c1 a8       	rjmp	80006a8e <f_mkfs+0x202>
	n = (n - b_data) / N_FATS;
	if (fmt == FS_FAT32) {		/* FAT32: Move FAT offset */
		n_rsv += n;
		b_fat += n;
	} else {					/* FAT12/16: Expand FAT size */
		n_fat += n;
80006a5c:	0c 02       	add	r2,r6
	}

	/* Determine number of clusters and final check of validity of the FAT sub-type */
	n_clst = (n_vol - n_rsv - n_fat * N_FATS - n_dir) / au;
80006a5e:	40 88       	lddsp	r8,sp[0x20]
80006a60:	40 0a       	lddsp	r10,sp[0x0]
80006a62:	f0 0a 01 0b 	sub	r11,r8,r10
80006a66:	04 1b       	sub	r11,r2
80006a68:	40 29       	lddsp	r9,sp[0x8]
80006a6a:	12 1b       	sub	r11,r9
80006a6c:	f6 00 0d 0a 	divu	r10,r11,r0
80006a70:	50 4a       	stdsp	sp[0x10],r10
	if (   (fmt == FS_FAT16 && n_clst < MIN_FAT16)
80006a72:	30 29       	mov	r9,2
80006a74:	f2 03 18 00 	cp.b	r3,r9
80006a78:	5f 0a       	sreq	r10
80006a7a:	40 4c       	lddsp	r12,sp[0x10]
80006a7c:	e0 4c 0f f5 	cp.w	r12,4085
80006a80:	5f 89       	srls	r9
80006a82:	f5 e9 00 09 	and	r9,r10,r9
80006a86:	e0 80 02 26 	breq	80006ed2 <f_mkfs+0x646>
80006a8a:	e0 8f 02 21 	bral	80006ecc <f_mkfs+0x640>
		|| (fmt == FS_FAT32 && n_clst < MIN_FAT32))
		return FR_MKFS_ABORTED;

	/* Determine system ID in the partition table */
	if (fmt == FS_FAT32) {
80006a8e:	40 3b       	lddsp	r11,sp[0xc]
80006a90:	58 0b       	cp.w	r11,0
80006a92:	c0 30       	breq	80006a98 <f_mkfs+0x20c>
80006a94:	30 c6       	mov	r6,12
80006a96:	c1 28       	rjmp	80006aba <f_mkfs+0x22e>
		sys = 0x0C;		/* FAT32X */
	} else {
		if (fmt == FS_FAT12 && n_vol < 0x10000) {
80006a98:	30 19       	mov	r9,1
80006a9a:	f2 03 18 00 	cp.b	r3,r9
80006a9e:	c0 71       	brne	80006aac <f_mkfs+0x220>
80006aa0:	e0 48 ff ff 	cp.w	r8,65535
80006aa4:	e0 8b 00 0a 	brhi	80006ab8 <f_mkfs+0x22c>
80006aa8:	30 16       	mov	r6,1
80006aaa:	c0 88       	rjmp	80006aba <f_mkfs+0x22e>
			sys = 0x01;	/* FAT12(<65536) */
		} else {
			sys = (n_vol < 0x10000) ? 0x04 : 0x06;	/* FAT16(<65536) : FAT12/16(>=65536) */
80006aac:	e0 48 ff ff 	cp.w	r8,65535
80006ab0:	e0 8b 00 04 	brhi	80006ab8 <f_mkfs+0x22c>
80006ab4:	30 46       	mov	r6,4
80006ab6:	c0 28       	rjmp	80006aba <f_mkfs+0x22e>
80006ab8:	30 66       	mov	r6,6
		tbl[4] = sys;
		if (disk_write(pdrv, fs->win, 0, 1) != RES_OK)	/* Write it to teh MBR */
			return FR_DISK_ERR;
		md = 0xF8;
	} else {
		if (sfd) {	/* No partition table (SFD) */
80006aba:	58 07       	cp.w	r7,0
80006abc:	c0 40       	breq	80006ac4 <f_mkfs+0x238>
80006abe:	e0 67 00 f0 	mov	r7,240
80006ac2:	c5 68       	rjmp	80006b6e <f_mkfs+0x2e2>
			md = 0xF0;
		} else {	/* Create partition table (FDISK) */
			mem_set(fs->win, 0, SS(fs));
80006ac4:	ea ca ff d0 	sub	r10,r5,-48
80006ac8:	50 5a       	stdsp	sp[0x14],r10
80006aca:	e0 6a 02 00 	mov	r10,512
80006ace:	30 0b       	mov	r11,0
80006ad0:	40 5c       	lddsp	r12,sp[0x14]
80006ad2:	f0 1f 01 0a 	mcall	80006ef8 <f_mkfs+0x66c>
			tbl = fs->win + MBR_Table;	/* Create partition table for single partition in the drive */
80006ad6:	ea c8 fe 12 	sub	r8,r5,-494
			tbl[1] = 1;						/* Partition start head */
80006ada:	30 19       	mov	r9,1
80006adc:	b0 99       	st.b	r8[0x1],r9
			tbl[2] = 1;						/* Partition start sector */
80006ade:	b0 a9       	st.b	r8[0x2],r9
			tbl[3] = 0;						/* Partition start cylinder */
80006ae0:	30 09       	mov	r9,0
80006ae2:	b0 b9       	st.b	r8[0x3],r9
			tbl[4] = sys;					/* System type */
80006ae4:	b0 c6       	st.b	r8[0x4],r6
			tbl[5] = 254;					/* Partition end head */
80006ae6:	3f ea       	mov	r10,-2
80006ae8:	b0 da       	st.b	r8[0x5],r10
			n = (b_vol + n_vol) / 63 / 255;
80006aea:	40 8b       	lddsp	r11,sp[0x20]
80006aec:	e2 0b 00 0b 	add	r11,r1,r11
80006af0:	e0 6a 56 5b 	mov	r10,22107
80006af4:	ea 1a 05 15 	orh	r10,0x515
80006af8:	f6 0a 06 46 	mulu.d	r6,r11,r10
80006afc:	0e 9c       	mov	r12,r7
80006afe:	f6 0c 01 0a 	sub	r10,r11,r12
80006b02:	a1 9a       	lsr	r10,0x1
80006b04:	f4 0c 00 07 	add	r7,r10,r12
80006b08:	ee 0a 16 0d 	lsr	r10,r7,0xd
80006b0c:	50 9a       	stdsp	sp[0x24],r10
			tbl[6] = (BYTE)(n >> 2 | 63);	/* Partition end sector */
80006b0e:	ee 0b 16 0f 	lsr	r11,r7,0xf
80006b12:	16 97       	mov	r7,r11
80006b14:	e8 17 00 3f 	orl	r7,0x3f
80006b18:	b0 e7       	st.b	r8[0x6],r7
			tbl[7] = (BYTE)n;				/* End cylinder */
80006b1a:	40 9a       	lddsp	r10,sp[0x24]
80006b1c:	b0 fa       	st.b	r8[0x7],r10
			ST_DWORD(tbl + 8, 63);			/* Partition start in LBA */
80006b1e:	33 fa       	mov	r10,63
80006b20:	f1 6a 00 08 	st.b	r8[8],r10
80006b24:	f1 69 00 09 	st.b	r8[9],r9
80006b28:	f1 69 00 0a 	st.b	r8[10],r9
80006b2c:	f1 69 00 0b 	st.b	r8[11],r9
			ST_DWORD(tbl + 12, n_vol);		/* Partition size in LBA */
80006b30:	40 89       	lddsp	r9,sp[0x20]
80006b32:	f1 69 00 0c 	st.b	r8[12],r9
80006b36:	fb 39 00 22 	ld.ub	r9,sp[34]
80006b3a:	f1 69 00 0d 	st.b	r8[13],r9
80006b3e:	fb 19 00 20 	ld.uh	r9,sp[32]
80006b42:	f1 69 00 0e 	st.b	r8[14],r9
80006b46:	fb 39 00 20 	ld.ub	r9,sp[32]
80006b4a:	f1 69 00 0f 	st.b	r8[15],r9
			ST_WORD(fs->win + BS_55AA, 0xAA55);	/* MBR signature */
80006b4e:	35 58       	mov	r8,85
80006b50:	eb 68 02 2e 	st.b	r5[558],r8
80006b54:	3a a8       	mov	r8,-86
80006b56:	eb 68 02 2f 	st.b	r5[559],r8
			if (disk_write(pdrv, fs->win, 0, 1) != RES_OK)	/* Write it to the MBR */
80006b5a:	30 19       	mov	r9,1
80006b5c:	30 0a       	mov	r10,0
80006b5e:	40 5b       	lddsp	r11,sp[0x14]
80006b60:	08 9c       	mov	r12,r4
80006b62:	f0 1f 00 e7 	mcall	80006efc <f_mkfs+0x670>
80006b66:	e0 81 01 b1 	brne	80006ec8 <f_mkfs+0x63c>
80006b6a:	e0 67 00 f8 	mov	r7,248
			md = 0xF8;
		}
	}

	/* Create BPB in the VBR */
	tbl = fs->win;							/* Clear sector */
80006b6e:	ea c6 ff d0 	sub	r6,r5,-48
	mem_set(tbl, 0, SS(fs));
80006b72:	e0 6a 02 00 	mov	r10,512
80006b76:	30 0b       	mov	r11,0
80006b78:	0c 9c       	mov	r12,r6
80006b7a:	f0 1f 00 e0 	mcall	80006ef8 <f_mkfs+0x66c>
	mem_cpy(tbl, "\xEB\xFE\x90" "MSDOS5.0", 11);/* Boot jump code, OEM name */
80006b7e:	30 ba       	mov	r10,11
80006b80:	fe fb 03 80 	ld.w	r11,pc[896]
80006b84:	0c 9c       	mov	r12,r6
80006b86:	f0 1f 00 e0 	mcall	80006f04 <f_mkfs+0x678>
	i = SS(fs);								/* Sector size */
	ST_WORD(tbl + BPB_BytsPerSec, i);
80006b8a:	ea ca ff c5 	sub	r10,r5,-59
80006b8e:	50 5a       	stdsp	sp[0x14],r10
80006b90:	30 08       	mov	r8,0
80006b92:	b4 88       	st.b	r10[0x0],r8
80006b94:	30 28       	mov	r8,2
80006b96:	ed 68 00 0c 	st.b	r6[12],r8
	tbl[BPB_SecPerClus] = (BYTE)au;			/* Sectors per cluster */
80006b9a:	ed 60 00 0d 	st.b	r6[13],r0
	ST_WORD(tbl + BPB_RsvdSecCnt, n_rsv);	/* Reserved sectors */
80006b9e:	40 09       	lddsp	r9,sp[0x0]
80006ba0:	ed 69 00 0e 	st.b	r6[14],r9
80006ba4:	f1 d9 c1 08 	bfextu	r8,r9,0x8,0x8
80006ba8:	ed 68 00 0f 	st.b	r6[15],r8
	tbl[BPB_NumFATs] = N_FATS;				/* Number of FATs */
80006bac:	30 18       	mov	r8,1
80006bae:	ed 68 00 10 	st.b	r6[16],r8
	i = (fmt == FS_FAT32) ? 0 : N_ROOTDIR;	/* Number of root directory entries */
80006bb2:	e0 68 02 00 	mov	r8,512
80006bb6:	40 3c       	lddsp	r12,sp[0xc]
80006bb8:	58 0c       	cp.w	r12,0
80006bba:	f9 b8 01 00 	movne	r8,0
	ST_WORD(tbl + BPB_RootEntCnt, i);
80006bbe:	ed 68 00 11 	st.b	r6[17],r8
80006bc2:	58 08       	cp.w	r8,0
80006bc4:	f9 b8 01 02 	movne	r8,2
80006bc8:	f9 b8 00 00 	moveq	r8,0
80006bcc:	ed 68 00 12 	st.b	r6[18],r8
	if (n_vol < 0x10000) {					/* Number of total sectors */
80006bd0:	40 88       	lddsp	r8,sp[0x20]
80006bd2:	e0 48 ff ff 	cp.w	r8,65535
80006bd6:	e0 8b 00 09 	brhi	80006be8 <f_mkfs+0x35c>
		ST_WORD(tbl + BPB_TotSec16, n_vol);
80006bda:	ed 68 00 13 	st.b	r6[19],r8
80006bde:	fb 38 00 22 	ld.ub	r8,sp[34]
80006be2:	ed 68 00 14 	st.b	r6[20],r8
80006be6:	c0 f8       	rjmp	80006c04 <f_mkfs+0x378>
	} else {
		ST_DWORD(tbl + BPB_TotSec32, n_vol);
80006be8:	ed 68 00 20 	st.b	r6[32],r8
80006bec:	fb 38 00 22 	ld.ub	r8,sp[34]
80006bf0:	ed 68 00 21 	st.b	r6[33],r8
80006bf4:	fb 18 00 20 	ld.uh	r8,sp[32]
80006bf8:	ed 68 00 22 	st.b	r6[34],r8
80006bfc:	fb 38 00 20 	ld.ub	r8,sp[32]
80006c00:	ed 68 00 23 	st.b	r6[35],r8
	}
	tbl[BPB_Media] = md;					/* Media descriptor */
80006c04:	ed 67 00 15 	st.b	r6[21],r7
	ST_WORD(tbl + BPB_SecPerTrk, 63);		/* Number of sectors per track */
80006c08:	33 f8       	mov	r8,63
80006c0a:	ed 68 00 18 	st.b	r6[24],r8
80006c0e:	30 08       	mov	r8,0
80006c10:	ed 68 00 19 	st.b	r6[25],r8
	ST_WORD(tbl + BPB_NumHeads, 255);		/* Number of heads */
80006c14:	3f f9       	mov	r9,-1
80006c16:	ed 69 00 1a 	st.b	r6[26],r9
80006c1a:	ed 68 00 1b 	st.b	r6[27],r8
	ST_DWORD(tbl + BPB_HiddSec, b_vol);		/* Hidden sectors */
80006c1e:	ed 61 00 1c 	st.b	r6[28],r1
80006c22:	30 08       	mov	r8,0
80006c24:	ed 68 00 1d 	st.b	r6[29],r8
80006c28:	e2 08 16 10 	lsr	r8,r1,0x10
80006c2c:	ed 68 00 1e 	st.b	r6[30],r8
80006c30:	e2 08 16 18 	lsr	r8,r1,0x18
80006c34:	ed 68 00 1f 	st.b	r6[31],r8
	n = GET_FATTIME();						/* Use current time as VSN */
80006c38:	f0 1f 00 b4 	mcall	80006f08 <f_mkfs+0x67c>
80006c3c:	50 9c       	stdsp	sp[0x24],r12
	if (fmt == FS_FAT32) {
80006c3e:	40 3a       	lddsp	r10,sp[0xc]
80006c40:	58 0a       	cp.w	r10,0
80006c42:	c3 f0       	breq	80006cc0 <f_mkfs+0x434>
		ST_DWORD(tbl + BS_VolID32, n);		/* VSN */
80006c44:	ed 6c 00 43 	st.b	r6[67],r12
80006c48:	fb 38 00 26 	ld.ub	r8,sp[38]
80006c4c:	ed 68 00 44 	st.b	r6[68],r8
80006c50:	fb 18 00 24 	ld.uh	r8,sp[36]
80006c54:	ed 68 00 45 	st.b	r6[69],r8
80006c58:	fb 38 00 24 	ld.ub	r8,sp[36]
80006c5c:	ed 68 00 46 	st.b	r6[70],r8
		ST_DWORD(tbl + BPB_FATSz32, n_fat);	/* Number of sectors per FAT */
80006c60:	ed 62 00 24 	st.b	r6[36],r2
80006c64:	f1 d2 c1 08 	bfextu	r8,r2,0x8,0x8
80006c68:	ed 68 00 25 	st.b	r6[37],r8
80006c6c:	e4 08 16 10 	lsr	r8,r2,0x10
80006c70:	ed 68 00 26 	st.b	r6[38],r8
80006c74:	e4 08 16 18 	lsr	r8,r2,0x18
80006c78:	ed 68 00 27 	st.b	r6[39],r8
		ST_DWORD(tbl + BPB_RootClus, 2);	/* Root directory start cluster (2) */
80006c7c:	30 28       	mov	r8,2
80006c7e:	ed 68 00 2c 	st.b	r6[44],r8
80006c82:	30 08       	mov	r8,0
80006c84:	ed 68 00 2d 	st.b	r6[45],r8
80006c88:	ed 68 00 2e 	st.b	r6[46],r8
80006c8c:	ed 68 00 2f 	st.b	r6[47],r8
		ST_WORD(tbl + BPB_FSInfo, 1);		/* FSINFO record offset (VBR + 1) */
80006c90:	30 19       	mov	r9,1
80006c92:	ed 69 00 30 	st.b	r6[48],r9
80006c96:	ed 68 00 31 	st.b	r6[49],r8
		ST_WORD(tbl + BPB_BkBootSec, 6);	/* Backup boot record offset (VBR + 6) */
80006c9a:	30 69       	mov	r9,6
80006c9c:	ed 69 00 32 	st.b	r6[50],r9
80006ca0:	ed 68 00 33 	st.b	r6[51],r8
		tbl[BS_DrvNum32] = 0x80;			/* Drive number */
80006ca4:	38 08       	mov	r8,-128
80006ca6:	ed 68 00 40 	st.b	r6[64],r8
		tbl[BS_BootSig32] = 0x29;			/* Extended boot signature */
80006caa:	32 98       	mov	r8,41
80006cac:	ed 68 00 42 	st.b	r6[66],r8
		mem_cpy(tbl + BS_VolLab32, "NO NAME    " "FAT32   ", 19);	/* Volume label, FAT signature */
80006cb0:	31 3a       	mov	r10,19
80006cb2:	fe fb 02 5a 	ld.w	r11,pc[602]
80006cb6:	ec cc ff b9 	sub	r12,r6,-71
80006cba:	f0 1f 00 93 	mcall	80006f04 <f_mkfs+0x678>
80006cbe:	c2 28       	rjmp	80006d02 <f_mkfs+0x476>
	} else {
		ST_DWORD(tbl + BS_VolID, n);		/* VSN */
80006cc0:	ed 6c 00 27 	st.b	r6[39],r12
80006cc4:	fb 38 00 26 	ld.ub	r8,sp[38]
80006cc8:	ed 68 00 28 	st.b	r6[40],r8
80006ccc:	fb 18 00 24 	ld.uh	r8,sp[36]
80006cd0:	ed 68 00 29 	st.b	r6[41],r8
80006cd4:	fb 38 00 24 	ld.ub	r8,sp[36]
80006cd8:	ed 68 00 2a 	st.b	r6[42],r8
		ST_WORD(tbl + BPB_FATSz16, n_fat);	/* Number of sectors per FAT */
80006cdc:	ed 62 00 16 	st.b	r6[22],r2
80006ce0:	f1 d2 c1 08 	bfextu	r8,r2,0x8,0x8
80006ce4:	ed 68 00 17 	st.b	r6[23],r8
		tbl[BS_DrvNum] = 0x80;				/* Drive number */
80006ce8:	38 08       	mov	r8,-128
80006cea:	ed 68 00 24 	st.b	r6[36],r8
		tbl[BS_BootSig] = 0x29;				/* Extended boot signature */
80006cee:	32 98       	mov	r8,41
80006cf0:	ed 68 00 26 	st.b	r6[38],r8
		mem_cpy(tbl + BS_VolLab, "NO NAME    " "FAT     ", 19);	/* Volume label, FAT signature */
80006cf4:	31 3a       	mov	r10,19
80006cf6:	fe fb 02 1a 	ld.w	r11,pc[538]
80006cfa:	ec cc ff d5 	sub	r12,r6,-43
80006cfe:	f0 1f 00 82 	mcall	80006f04 <f_mkfs+0x678>
	}
	ST_WORD(tbl + BS_55AA, 0xAA55);			/* Signature (Offset is fixed here regardless of sector size) */
80006d02:	ec c9 fe 02 	sub	r9,r6,-510
80006d06:	50 69       	stdsp	sp[0x18],r9
80006d08:	35 58       	mov	r8,85
80006d0a:	b2 88       	st.b	r9[0x0],r8
80006d0c:	ec c8 fe 01 	sub	r8,r6,-511
80006d10:	50 08       	stdsp	sp[0x0],r8
80006d12:	3a a8       	mov	r8,-86
80006d14:	40 0c       	lddsp	r12,sp[0x0]
80006d16:	b8 88       	st.b	r12[0x0],r8
	if (disk_write(pdrv, tbl, b_vol, 1) != RES_OK)	/* Write it to the VBR sector */
80006d18:	30 19       	mov	r9,1
80006d1a:	02 9a       	mov	r10,r1
80006d1c:	0c 9b       	mov	r11,r6
80006d1e:	08 9c       	mov	r12,r4
80006d20:	f0 1f 00 77 	mcall	80006efc <f_mkfs+0x670>
80006d24:	e0 81 00 d2 	brne	80006ec8 <f_mkfs+0x63c>
		return FR_DISK_ERR;
	if (fmt == FS_FAT32)					/* Write it to the backup VBR if needed (VBR + 6) */
80006d28:	40 3b       	lddsp	r11,sp[0xc]
80006d2a:	58 0b       	cp.w	r11,0
80006d2c:	c0 80       	breq	80006d3c <f_mkfs+0x4b0>
		disk_write(pdrv, tbl, b_vol + 6, 1);
80006d2e:	30 19       	mov	r9,1
80006d30:	e2 ca ff fa 	sub	r10,r1,-6
80006d34:	0c 9b       	mov	r11,r6
80006d36:	08 9c       	mov	r12,r4
80006d38:	f0 1f 00 71 	mcall	80006efc <f_mkfs+0x670>

	/* Initialize FAT area */
	wsect = b_fat;
	for (i = 0; i < N_FATS; i++) {		/* Initialize each FAT copy */
		mem_set(tbl, 0, SS(fs));			/* 1st sector of the FAT  */
80006d3c:	e0 6a 02 00 	mov	r10,512
80006d40:	30 0b       	mov	r11,0
80006d42:	0c 9c       	mov	r12,r6
80006d44:	f0 1f 00 6d 	mcall	80006ef8 <f_mkfs+0x66c>
		n = md;								/* Media descriptor byte */
		if (fmt != FS_FAT32) {
80006d48:	30 38       	mov	r8,3
80006d4a:	f0 03 18 00 	cp.b	r3,r8
80006d4e:	c1 d0       	breq	80006d88 <f_mkfs+0x4fc>
			n |= (fmt == FS_FAT12) ? 0x00FFFF00 : 0xFFFFFF00;
80006d50:	30 18       	mov	r8,1
80006d52:	fe 7a ff 00 	mov	r10,-256
80006d56:	e0 69 ff 00 	mov	r9,65280
80006d5a:	ea 19 00 ff 	orh	r9,0xff
80006d5e:	e6 08 18 00 	cp.b	r8,r3
80006d62:	f2 08 17 00 	moveq	r8,r9
80006d66:	f4 08 17 10 	movne	r8,r10
80006d6a:	f1 e7 10 07 	or	r7,r8,r7
80006d6e:	50 97       	stdsp	sp[0x24],r7
			ST_DWORD(tbl + 0, n);			/* Reserve cluster #0-1 (FAT12/16) */
80006d70:	eb 67 00 30 	st.b	r5[48],r7
80006d74:	fb 38 00 26 	ld.ub	r8,sp[38]
80006d78:	ac 98       	st.b	r6[0x1],r8
80006d7a:	fb 18 00 24 	ld.uh	r8,sp[36]
80006d7e:	ac a8       	st.b	r6[0x2],r8
80006d80:	fb 38 00 24 	ld.ub	r8,sp[36]
80006d84:	ac b8       	st.b	r6[0x3],r8
80006d86:	c1 f8       	rjmp	80006dc4 <f_mkfs+0x538>
		} else {
			n |= 0xFFFFFF00;
80006d88:	ea 17 ff ff 	orh	r7,0xffff
80006d8c:	e8 17 ff 00 	orl	r7,0xff00
80006d90:	50 97       	stdsp	sp[0x24],r7
			ST_DWORD(tbl + 0, n);			/* Reserve cluster #0-1 (FAT32) */
80006d92:	eb 67 00 30 	st.b	r5[48],r7
80006d96:	fb 38 00 26 	ld.ub	r8,sp[38]
80006d9a:	ac 98       	st.b	r6[0x1],r8
80006d9c:	fb 18 00 24 	ld.uh	r8,sp[36]
80006da0:	ac a8       	st.b	r6[0x2],r8
80006da2:	fb 38 00 24 	ld.ub	r8,sp[36]
80006da6:	ac b8       	st.b	r6[0x3],r8
			ST_DWORD(tbl + 4, 0xFFFFFFFF);
80006da8:	3f f8       	mov	r8,-1
80006daa:	ac c8       	st.b	r6[0x4],r8
80006dac:	ac d8       	st.b	r6[0x5],r8
80006dae:	ac e8       	st.b	r6[0x6],r8
80006db0:	ac f8       	st.b	r6[0x7],r8
			ST_DWORD(tbl + 8, 0x0FFFFFFF);	/* Reserve cluster #2 for root directory */
80006db2:	ed 68 00 08 	st.b	r6[8],r8
80006db6:	ed 68 00 09 	st.b	r6[9],r8
80006dba:	ed 68 00 0a 	st.b	r6[10],r8
80006dbe:	30 f8       	mov	r8,15
80006dc0:	40 5a       	lddsp	r10,sp[0x14]
80006dc2:	b4 88       	st.b	r10[0x0],r8
		}
		if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
80006dc4:	30 19       	mov	r9,1
80006dc6:	40 1a       	lddsp	r10,sp[0x4]
80006dc8:	0c 9b       	mov	r11,r6
80006dca:	08 9c       	mov	r12,r4
80006dcc:	f0 1f 00 4c 	mcall	80006efc <f_mkfs+0x670>
80006dd0:	c7 c1       	brne	80006ec8 <f_mkfs+0x63c>
80006dd2:	40 13       	lddsp	r3,sp[0x4]
80006dd4:	2f f3       	sub	r3,-1
			return FR_DISK_ERR;
		mem_set(tbl, 0, SS(fs));			/* Fill following FAT entries with zero */
80006dd6:	e0 6a 02 00 	mov	r10,512
80006dda:	30 0b       	mov	r11,0
80006ddc:	0c 9c       	mov	r12,r6
80006dde:	f0 1f 00 47 	mcall	80006ef8 <f_mkfs+0x66c>
		for (n = 1; n < n_fat; n++) {		/* This loop may take a time on FAT32 volume due to many single sector writes */
80006de2:	30 18       	mov	r8,1
80006de4:	50 98       	stdsp	sp[0x24],r8
80006de6:	10 32       	cp.w	r2,r8
80006de8:	e0 88 00 11 	brls	80006e0a <f_mkfs+0x57e>
			if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
80006dec:	10 97       	mov	r7,r8
80006dee:	0e 99       	mov	r9,r7
80006df0:	06 9a       	mov	r10,r3
80006df2:	0c 9b       	mov	r11,r6
80006df4:	08 9c       	mov	r12,r4
80006df6:	f0 1f 00 42 	mcall	80006efc <f_mkfs+0x670>
80006dfa:	c6 71       	brne	80006ec8 <f_mkfs+0x63c>
80006dfc:	2f f3       	sub	r3,-1
			ST_DWORD(tbl + 8, 0x0FFFFFFF);	/* Reserve cluster #2 for root directory */
		}
		if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
			return FR_DISK_ERR;
		mem_set(tbl, 0, SS(fs));			/* Fill following FAT entries with zero */
		for (n = 1; n < n_fat; n++) {		/* This loop may take a time on FAT32 volume due to many single sector writes */
80006dfe:	40 98       	lddsp	r8,sp[0x24]
80006e00:	2f f8       	sub	r8,-1
80006e02:	50 98       	stdsp	sp[0x24],r8
80006e04:	10 32       	cp.w	r2,r8
80006e06:	fe 9b ff f4 	brhi	80006dee <f_mkfs+0x562>
				return FR_DISK_ERR;
		}
	}

	/* Initialize root directory */
	i = (fmt == FS_FAT32) ? au : (UINT)n_dir;
80006e0a:	40 29       	lddsp	r9,sp[0x8]
80006e0c:	40 38       	lddsp	r8,sp[0xc]
80006e0e:	58 08       	cp.w	r8,0
80006e10:	f2 00 17 00 	moveq	r0,r9
	do {
		if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
80006e14:	30 12       	mov	r2,1
80006e16:	06 9a       	mov	r10,r3
80006e18:	f4 c7 ff ff 	sub	r7,r10,-1
80006e1c:	04 99       	mov	r9,r2
80006e1e:	0c 9b       	mov	r11,r6
80006e20:	08 9c       	mov	r12,r4
80006e22:	f0 1f 00 37 	mcall	80006efc <f_mkfs+0x670>
80006e26:	c5 11       	brne	80006ec8 <f_mkfs+0x63c>
			return FR_DISK_ERR;
	} while (--i);
80006e28:	20 10       	sub	r0,1
80006e2a:	c0 30       	breq	80006e30 <f_mkfs+0x5a4>
80006e2c:	0e 9a       	mov	r10,r7
80006e2e:	cf 5b       	rjmp	80006e18 <f_mkfs+0x58c>
		disk_ioctl(pdrv, CTRL_TRIM, eb);
	}
#endif

	/* Create FSINFO if needed */
	if (fmt == FS_FAT32) {
80006e30:	40 3c       	lddsp	r12,sp[0xc]
80006e32:	58 0c       	cp.w	r12,0
80006e34:	c4 30       	breq	80006eba <f_mkfs+0x62e>
		ST_DWORD(tbl + FSI_LeadSig, 0x41615252);
80006e36:	35 28       	mov	r8,82
80006e38:	eb 68 00 30 	st.b	r5[48],r8
80006e3c:	ac 98       	st.b	r6[0x1],r8
80006e3e:	36 18       	mov	r8,97
80006e40:	ac a8       	st.b	r6[0x2],r8
80006e42:	34 19       	mov	r9,65
80006e44:	ac b9       	st.b	r6[0x3],r9
		ST_DWORD(tbl + FSI_StrucSig, 0x61417272);
80006e46:	37 2a       	mov	r10,114
80006e48:	ed 6a 01 e4 	st.b	r6[484],r10
80006e4c:	ed 6a 01 e5 	st.b	r6[485],r10
80006e50:	ed 69 01 e6 	st.b	r6[486],r9
80006e54:	ed 68 01 e7 	st.b	r6[487],r8
		ST_DWORD(tbl + FSI_Free_Count, n_clst - 1);	/* Number of free clusters */
80006e58:	40 48       	lddsp	r8,sp[0x10]
80006e5a:	20 18       	sub	r8,1
80006e5c:	ed 68 01 e8 	st.b	r6[488],r8
80006e60:	40 48       	lddsp	r8,sp[0x10]
80006e62:	20 18       	sub	r8,1
80006e64:	f1 d8 c1 08 	bfextu	r8,r8,0x8,0x8
80006e68:	ed 68 01 e9 	st.b	r6[489],r8
80006e6c:	40 48       	lddsp	r8,sp[0x10]
80006e6e:	20 18       	sub	r8,1
80006e70:	f0 09 16 10 	lsr	r9,r8,0x10
80006e74:	ed 69 01 ea 	st.b	r6[490],r9
80006e78:	b9 88       	lsr	r8,0x18
80006e7a:	ed 68 01 eb 	st.b	r6[491],r8
		ST_DWORD(tbl + FSI_Nxt_Free, 2);			/* Last allocated cluster# */
80006e7e:	30 28       	mov	r8,2
80006e80:	ed 68 01 ec 	st.b	r6[492],r8
80006e84:	30 08       	mov	r8,0
80006e86:	ed 68 01 ed 	st.b	r6[493],r8
80006e8a:	ed 68 01 ee 	st.b	r6[494],r8
80006e8e:	ed 68 01 ef 	st.b	r6[495],r8
		ST_WORD(tbl + BS_55AA, 0xAA55);
80006e92:	35 58       	mov	r8,85
80006e94:	40 6b       	lddsp	r11,sp[0x18]
80006e96:	b6 88       	st.b	r11[0x0],r8
80006e98:	3a a8       	mov	r8,-86
80006e9a:	40 0a       	lddsp	r10,sp[0x0]
80006e9c:	b4 88       	st.b	r10[0x0],r8
		disk_write(pdrv, tbl, b_vol + 1, 1);	/* Write original (VBR + 1) */
80006e9e:	30 19       	mov	r9,1
80006ea0:	e2 09 00 0a 	add	r10,r1,r9
80006ea4:	0c 9b       	mov	r11,r6
80006ea6:	08 9c       	mov	r12,r4
80006ea8:	f0 1f 00 15 	mcall	80006efc <f_mkfs+0x670>
		disk_write(pdrv, tbl, b_vol + 7, 1);	/* Write backup (VBR + 7) */
80006eac:	30 19       	mov	r9,1
80006eae:	e2 ca ff f9 	sub	r10,r1,-7
80006eb2:	0c 9b       	mov	r11,r6
80006eb4:	08 9c       	mov	r12,r4
80006eb6:	f0 1f 00 12 	mcall	80006efc <f_mkfs+0x670>
	}

	return (disk_ioctl(pdrv, CTRL_SYNC, 0) == RES_OK) ? FR_OK : FR_DISK_ERR;
80006eba:	30 0a       	mov	r10,0
80006ebc:	14 9b       	mov	r11,r10
80006ebe:	08 9c       	mov	r12,r4
80006ec0:	f0 1f 00 0b 	mcall	80006eec <f_mkfs+0x660>
80006ec4:	5f 1c       	srne	r12
80006ec6:	c0 48       	rjmp	80006ece <f_mkfs+0x642>
80006ec8:	30 1c       	mov	r12,1
80006eca:	c0 28       	rjmp	80006ece <f_mkfs+0x642>
80006ecc:	30 ec       	mov	r12,14
}
80006ece:	2f 6d       	sub	sp,-40
80006ed0:	d8 32       	popm	r0-r7,pc
	}

	/* Determine number of clusters and final check of validity of the FAT sub-type */
	n_clst = (n_vol - n_rsv - n_fat * N_FATS - n_dir) / au;
	if (   (fmt == FS_FAT16 && n_clst < MIN_FAT16)
		|| (fmt == FS_FAT32 && n_clst < MIN_FAT32))
80006ed2:	30 39       	mov	r9,3
80006ed4:	f2 03 18 00 	cp.b	r3,r9
80006ed8:	5f 09       	sreq	r9
80006eda:	50 39       	stdsp	sp[0xc],r9
80006edc:	fe 9f fd d9 	bral	80006a8e <f_mkfs+0x202>
80006ee0:	80 00       	ld.sh	r0,r0[0x0]
80006ee2:	66 94       	ld.w	r4,r3[0x24]
80006ee4:	00 00       	add	r0,r0
80006ee6:	11 d0       	ld.ub	r0,r8[0x5]
80006ee8:	80 00       	ld.sh	r0,r0[0x0]
80006eea:	64 fa       	ld.w	r10,r2[0x3c]
80006eec:	80 00       	ld.sh	r0,r0[0x0]
80006eee:	65 38       	ld.w	r8,r2[0x4c]
80006ef0:	80 01       	ld.sh	r1,r0[0x0]
80006ef2:	8f 82       	st.w	r7[0x20],r2
80006ef4:	80 01       	ld.sh	r1,r0[0x0]
80006ef6:	8f 6c       	st.w	r7[0x18],r12
80006ef8:	80 00       	ld.sh	r0,r0[0x0]
80006efa:	65 d6       	ld.w	r6,r2[0x74]
80006efc:	80 00       	ld.sh	r0,r0[0x0]
80006efe:	65 88       	ld.w	r8,r2[0x60]
80006f00:	80 01       	ld.sh	r1,r0[0x0]
80006f02:	8f 9c       	st.w	r7[0x24],r12
80006f04:	80 00       	ld.sh	r0,r0[0x0]
80006f06:	65 c0       	ld.w	r0,r2[0x70]
80006f08:	80 00       	ld.sh	r0,r0[0x0]
80006f0a:	64 fc       	ld.w	r12,r2[0x3c]
80006f0c:	80 01       	ld.sh	r1,r0[0x0]
80006f0e:	8f a8       	st.w	r7[0x28],r8
80006f10:	80 01       	ld.sh	r1,r0[0x0]
80006f12:	8f bc       	st.w	r7[0x2c],r12

80006f14 <validate>:

static
FRESULT validate (	/* FR_OK(0): The object is valid, !=0: Invalid */
	void* obj		/* Pointer to the object FIL/DIR to check validity */
)
{
80006f14:	d4 01       	pushm	lr
	FIL *fil = (FIL*)obj;	/* Assuming offset of .fs and .id in the FIL/DIR structure is identical */


	if (!fil || !fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id || (disk_status(fil->fs->drv) & STA_NOINIT))
80006f16:	58 0c       	cp.w	r12,0
80006f18:	c1 40       	breq	80006f40 <validate+0x2c>
80006f1a:	78 08       	ld.w	r8,r12[0x0]
80006f1c:	58 08       	cp.w	r8,0
80006f1e:	c1 10       	breq	80006f40 <validate+0x2c>
80006f20:	11 8a       	ld.ub	r10,r8[0x0]
80006f22:	30 09       	mov	r9,0
80006f24:	f2 0a 18 00 	cp.b	r10,r9
80006f28:	c0 c0       	breq	80006f40 <validate+0x2c>
80006f2a:	90 3a       	ld.sh	r10,r8[0x6]
80006f2c:	98 29       	ld.sh	r9,r12[0x4]
80006f2e:	f2 0a 19 00 	cp.h	r10,r9
80006f32:	c0 71       	brne	80006f40 <validate+0x2c>
80006f34:	11 9c       	ld.ub	r12,r8[0x1]
80006f36:	f0 1f 00 04 	mcall	80006f44 <validate+0x30>
80006f3a:	f9 dc c0 01 	bfextu	r12,r12,0x0,0x1
80006f3e:	c0 20       	breq	80006f42 <validate+0x2e>
80006f40:	30 9c       	mov	r12,9
		return FR_INVALID_OBJECT;

	ENTER_FF(fil->fs);		/* Lock file system */

	return FR_OK;
}
80006f42:	d8 02       	popm	pc
80006f44:	80 00       	ld.sh	r0,r0[0x0]
80006f46:	64 f8       	ld.w	r8,r2[0x3c]

80006f48 <move_window>:
static
FRESULT move_window (	/* FR_OK(0):succeeded, !=0:error */
	FATFS* fs,		/* File system object */
	DWORD sector	/* Sector number to make appearance in the fs->win[] */
)
{
80006f48:	eb cd 40 e0 	pushm	r5-r7,lr
80006f4c:	18 97       	mov	r7,r12
80006f4e:	16 95       	mov	r5,r11
	FRESULT res = FR_OK;


	if (sector != fs->winsect) {	/* Window offset changed? */
80006f50:	78 b8       	ld.w	r8,r12[0x2c]
80006f52:	16 38       	cp.w	r8,r11
80006f54:	c0 31       	brne	80006f5a <move_window+0x12>
80006f56:	30 06       	mov	r6,0
80006f58:	c1 18       	rjmp	80006f7a <move_window+0x32>
#if !_FS_READONLY
		res = sync_window(fs);		/* Write-back changes */
80006f5a:	f0 1f 00 0a 	mcall	80006f80 <move_window+0x38>
80006f5e:	18 96       	mov	r6,r12
#endif
		if (res == FR_OK) {			/* Fill sector window with new data */
80006f60:	c0 d1       	brne	80006f7a <move_window+0x32>
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
80006f62:	30 19       	mov	r9,1
80006f64:	0a 9a       	mov	r10,r5
80006f66:	ee cb ff d0 	sub	r11,r7,-48
80006f6a:	0f 9c       	ld.ub	r12,r7[0x1]
80006f6c:	f0 1f 00 06 	mcall	80006f84 <move_window+0x3c>
80006f70:	f9 b6 01 01 	movne	r6,1
80006f74:	f9 b5 01 ff 	movne	r5,-1
				sector = 0xFFFFFFFF;	/* Invalidate window if data is not reliable */
				res = FR_DISK_ERR;
			}
			fs->winsect = sector;
80006f78:	8f b5       	st.w	r7[0x2c],r5
		}
	}
	return res;
}
80006f7a:	0c 9c       	mov	r12,r6
80006f7c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80006f80:	80 00       	ld.sh	r0,r0[0x0]
80006f82:	67 50       	ld.w	r0,r3[0x54]
80006f84:	80 00       	ld.sh	r0,r0[0x0]
80006f86:	65 a4       	ld.w	r4,r2[0x68]

80006f88 <check_fs>:
static
BYTE check_fs (	/* 0:Valid FAT-BS, 1:Valid BS but not FAT, 2:Not a BS, 3:Disk error */
	FATFS* fs,	/* File system object */
	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
)
{
80006f88:	eb cd 40 80 	pushm	r7,lr
80006f8c:	18 97       	mov	r7,r12
	fs->wflag = 0; fs->winsect = 0xFFFFFFFF;	/* Invaidate window */
80006f8e:	30 08       	mov	r8,0
80006f90:	b8 c8       	st.b	r12[0x4],r8
80006f92:	3f f8       	mov	r8,-1
80006f94:	99 b8       	st.w	r12[0x2c],r8
	if (move_window(fs, sect) != FR_OK)			/* Load boot record */
80006f96:	f0 1f 00 23 	mcall	80007020 <check_fs+0x98>
80006f9a:	c0 40       	breq	80006fa2 <check_fs+0x1a>
80006f9c:	30 3c       	mov	r12,3
80006f9e:	e3 cd 80 80 	ldm	sp++,r7,pc
		return 3;

	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)	/* Check boot record signature (always placed at offset 510 even if the sector size is >512) */
80006fa2:	ef 39 02 2f 	ld.ub	r9,r7[559]
80006fa6:	ef 38 02 2e 	ld.ub	r8,r7[558]
80006faa:	f1 e9 10 89 	or	r9,r8,r9<<0x8
80006fae:	fe 78 aa 55 	mov	r8,-21931
80006fb2:	f0 09 19 00 	cp.h	r9,r8
80006fb6:	c0 40       	breq	80006fbe <check_fs+0x36>
80006fb8:	30 2c       	mov	r12,2
80006fba:	e3 cd 80 80 	ldm	sp++,r7,pc
		return 2;

	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)		/* Check "FAT" string */
80006fbe:	ef 39 00 69 	ld.ub	r9,r7[105]
80006fc2:	ef 38 00 68 	ld.ub	r8,r7[104]
80006fc6:	b1 68       	lsl	r8,0x10
80006fc8:	f1 e9 11 88 	or	r8,r8,r9<<0x18
80006fcc:	ef 39 00 66 	ld.ub	r9,r7[102]
80006fd0:	12 48       	or	r8,r9
80006fd2:	ef 39 00 67 	ld.ub	r9,r7[103]
80006fd6:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80006fda:	f1 d8 c0 18 	bfextu	r8,r8,0x0,0x18
80006fde:	e0 69 41 46 	mov	r9,16710
80006fe2:	ea 19 00 54 	orh	r9,0x54
80006fe6:	12 38       	cp.w	r8,r9
80006fe8:	c0 31       	brne	80006fee <check_fs+0x66>
80006fea:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
80006fee:	ef 39 00 85 	ld.ub	r9,r7[133]
80006ff2:	ef 38 00 84 	ld.ub	r8,r7[132]
80006ff6:	b1 68       	lsl	r8,0x10
80006ff8:	f1 e9 11 88 	or	r8,r8,r9<<0x18
80006ffc:	ef 39 00 82 	ld.ub	r9,r7[130]
80007000:	12 48       	or	r8,r9
80007002:	ef 39 00 83 	ld.ub	r9,r7[131]
80007006:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000700a:	f1 d8 c0 18 	bfextu	r8,r8,0x0,0x18
8000700e:	e0 69 41 46 	mov	r9,16710
80007012:	ea 19 00 54 	orh	r9,0x54
80007016:	12 38       	cp.w	r8,r9
80007018:	5f 1c       	srne	r12
		return 0;
	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
		return 0;

	return 1;
}
8000701a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000701e:	00 00       	add	r0,r0
80007020:	80 00       	ld.sh	r0,r0[0x0]
80007022:	6f 48       	ld.w	r8,r7[0x50]

80007024 <find_volume>:
FRESULT find_volume (	/* FR_OK(0): successful, !=0: any error occurred */
	FATFS** rfs,		/* Pointer to pointer to the found file system object */
	const TCHAR** path,	/* Pointer to pointer to the path name (drive number) */
	BYTE wmode			/* !=0: Check write protection for write access */
)
{
80007024:	eb cd 40 fb 	pushm	r0-r1,r3-r7,lr
80007028:	20 4d       	sub	sp,16
8000702a:	18 95       	mov	r5,r12
8000702c:	14 94       	mov	r4,r10
	FATFS *fs;
	UINT i;


	/* Get logical drive number from the path name */
	*rfs = 0;
8000702e:	30 08       	mov	r8,0
80007030:	99 08       	st.w	r12[0x0],r8
	vol = get_ldnumber(path);
80007032:	16 9c       	mov	r12,r11
80007034:	f0 1f 00 de 	mcall	800073ac <find_volume+0x388>
80007038:	18 96       	mov	r6,r12
	if (vol < 0) return FR_INVALID_DRIVE;
8000703a:	c0 34       	brge	80007040 <find_volume+0x1c>
8000703c:	30 bc       	mov	r12,11
8000703e:	ca a9       	rjmp	80007392 <find_volume+0x36e>

	/* Check if the file system object is valid or not */
	fs = FatFs[vol];					/* Get pointer to the file system object */
80007040:	fe f8 03 70 	ld.w	r8,pc[880]
80007044:	f0 0c 03 27 	ld.w	r7,r8[r12<<0x2]
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
80007048:	58 07       	cp.w	r7,0
8000704a:	c0 31       	brne	80007050 <find_volume+0x2c>
8000704c:	30 cc       	mov	r12,12
8000704e:	ca 29       	rjmp	80007392 <find_volume+0x36e>

	ENTER_FF(fs);						/* Lock the volume */
	*rfs = fs;							/* Return pointer to the file system object */
80007050:	8b 07       	st.w	r5[0x0],r7

	if (fs->fs_type) {					/* If the volume has been mounted */
80007052:	0f 89       	ld.ub	r9,r7[0x0]
80007054:	30 08       	mov	r8,0
80007056:	f0 09 18 00 	cp.b	r9,r8
8000705a:	c0 f0       	breq	80007078 <find_volume+0x54>
		stat = disk_status(fs->drv);
8000705c:	0f 9c       	ld.ub	r12,r7[0x1]
8000705e:	f0 1f 00 d6 	mcall	800073b4 <find_volume+0x390>
		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized */
80007062:	f1 dc c0 01 	bfextu	r8,r12,0x0,0x1
80007066:	c0 91       	brne	80007078 <find_volume+0x54>
			if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check write protection if needed */
80007068:	58 04       	cp.w	r4,0
8000706a:	e0 80 01 91 	breq	8000738c <find_volume+0x368>
8000706e:	e2 1c 00 04 	andl	r12,0x4,COH
80007072:	e0 81 01 8b 	brne	80007388 <find_volume+0x364>
80007076:	c8 b9       	rjmp	8000738c <find_volume+0x368>
	}

	/* The file system object is not valid. */
	/* Following code attempts to mount the volume. (analyze BPB and initialize the fs object) */

	fs->fs_type = 0;					/* Clear the file system object */
80007078:	30 08       	mov	r8,0
8000707a:	ae 88       	st.b	r7[0x0],r8
	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
8000707c:	f9 d6 c0 08 	bfextu	r12,r6,0x0,0x8
80007080:	ae 9c       	st.b	r7[0x1],r12
	stat = disk_initialize(fs->drv);	/* Initialize the physical drive */
80007082:	f0 1f 00 ce 	mcall	800073b8 <find_volume+0x394>
	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
80007086:	f1 dc c0 01 	bfextu	r8,r12,0x0,0x1
8000708a:	c0 30       	breq	80007090 <find_volume+0x6c>
8000708c:	30 3c       	mov	r12,3
8000708e:	c8 29       	rjmp	80007392 <find_volume+0x36e>
		return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
	if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check disk write protection if needed */
80007090:	58 04       	cp.w	r4,0
80007092:	c0 50       	breq	8000709c <find_volume+0x78>
80007094:	e2 1c 00 04 	andl	r12,0x4,COH
80007098:	e0 81 01 78 	brne	80007388 <find_volume+0x364>
	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &SS(fs)) != RES_OK
		|| SS(fs) < _MIN_SS || SS(fs) > _MAX_SS) return FR_DISK_ERR;
#endif
	/* Find an FAT partition on the drive. Supports only generic partitioning, FDISK and SFD. */
	bsect = 0;
	fmt = check_fs(fs, bsect);					/* Load sector 0 and check if it is an FAT boot sector as SFD */
8000709c:	30 0b       	mov	r11,0
8000709e:	0e 9c       	mov	r12,r7
800070a0:	f0 1f 00 c7 	mcall	800073bc <find_volume+0x398>
	if (fmt == 1 || (!fmt && (LD2PT(vol)))) {	/* Not an FAT boot sector or forced partition number */
800070a4:	30 18       	mov	r8,1
800070a6:	f0 0c 18 00 	cp.b	r12,r8
800070aa:	c0 30       	breq	800070b0 <find_volume+0x8c>
800070ac:	30 05       	mov	r5,0
800070ae:	c3 48       	rjmp	80007116 <find_volume+0xf2>
800070b0:	1a 96       	mov	r6,sp
800070b2:	1a 9a       	mov	r10,sp
800070b4:	e0 68 01 be 	mov	r8,446
		for (i = 0; i < 4; i++) {			/* Get partition offset */
			pt = fs->win + MBR_Table + i * SZ_PTE;
			br[i] = pt[4] ? LD_DWORD(&pt[8]) : 0;
800070b8:	30 0c       	mov	r12,0
800070ba:	30 04       	mov	r4,0
	/* Find an FAT partition on the drive. Supports only generic partitioning, FDISK and SFD. */
	bsect = 0;
	fmt = check_fs(fs, bsect);					/* Load sector 0 and check if it is an FAT boot sector as SFD */
	if (fmt == 1 || (!fmt && (LD2PT(vol)))) {	/* Not an FAT boot sector or forced partition number */
		for (i = 0; i < 4; i++) {			/* Get partition offset */
			pt = fs->win + MBR_Table + i * SZ_PTE;
800070bc:	f0 c9 ff d0 	sub	r9,r8,-48
800070c0:	ee 09 00 09 	add	r9,r7,r9
			br[i] = pt[4] ? LD_DWORD(&pt[8]) : 0;
800070c4:	13 cb       	ld.ub	r11,r9[0x4]
800070c6:	f8 0b 18 00 	cp.b	r11,r12
800070ca:	c0 31       	brne	800070d0 <find_volume+0xac>
800070cc:	08 99       	mov	r9,r4
800070ce:	c0 f8       	rjmp	800070ec <find_volume+0xc8>
800070d0:	f3 35 00 0b 	ld.ub	r5,r9[11]
800070d4:	f3 3b 00 0a 	ld.ub	r11,r9[10]
800070d8:	b1 6b       	lsl	r11,0x10
800070da:	f7 e5 11 8b 	or	r11,r11,r5<<0x18
800070de:	f3 35 00 08 	ld.ub	r5,r9[8]
800070e2:	0a 4b       	or	r11,r5
800070e4:	f3 39 00 09 	ld.ub	r9,r9[9]
800070e8:	f7 e9 10 89 	or	r9,r11,r9<<0x8
800070ec:	14 a9       	st.w	r10++,r9
800070ee:	2f 08       	sub	r8,-16
#endif
	/* Find an FAT partition on the drive. Supports only generic partitioning, FDISK and SFD. */
	bsect = 0;
	fmt = check_fs(fs, bsect);					/* Load sector 0 and check if it is an FAT boot sector as SFD */
	if (fmt == 1 || (!fmt && (LD2PT(vol)))) {	/* Not an FAT boot sector or forced partition number */
		for (i = 0; i < 4; i++) {			/* Get partition offset */
800070f0:	e0 48 01 fe 	cp.w	r8,510
800070f4:	ce 41       	brne	800070bc <find_volume+0x98>
/*-----------------------------------------------------------------------*/
/* Find logical drive and check if the volume is mounted                 */
/*-----------------------------------------------------------------------*/

static
FRESULT find_volume (	/* FR_OK(0): successful, !=0: any error occurred */
800070f6:	fa c4 ff f0 	sub	r4,sp,-16
		}
		i = LD2PT(vol);						/* Partition number: 0:auto, 1-4:forced */
		if (i) i--;
		do {								/* Find an FAT volume */
			bsect = br[i];
			fmt = bsect ? check_fs(fs, bsect) : 2;	/* Check the partition */
800070fa:	30 23       	mov	r3,2
			br[i] = pt[4] ? LD_DWORD(&pt[8]) : 0;
		}
		i = LD2PT(vol);						/* Partition number: 0:auto, 1-4:forced */
		if (i) i--;
		do {								/* Find an FAT volume */
			bsect = br[i];
800070fc:	6c 05       	ld.w	r5,r6[0x0]
			fmt = bsect ? check_fs(fs, bsect) : 2;	/* Check the partition */
800070fe:	58 05       	cp.w	r5,0
80007100:	c0 31       	brne	80007106 <find_volume+0xe2>
80007102:	06 9c       	mov	r12,r3
80007104:	c0 68       	rjmp	80007110 <find_volume+0xec>
80007106:	0a 9b       	mov	r11,r5
80007108:	0e 9c       	mov	r12,r7
8000710a:	f0 1f 00 ad 	mcall	800073bc <find_volume+0x398>
		} while (!LD2PT(vol) && fmt && ++i < 4);
8000710e:	c0 d0       	breq	80007128 <find_volume+0x104>
80007110:	2f c6       	sub	r6,-4
80007112:	08 36       	cp.w	r6,r4
80007114:	cf 41       	brne	800070fc <find_volume+0xd8>
	}
	if (fmt == 3) return FR_DISK_ERR;		/* An error occured in the disk I/O layer */
80007116:	30 38       	mov	r8,3
80007118:	f0 0c 18 00 	cp.b	r12,r8
8000711c:	c0 31       	brne	80007122 <find_volume+0xfe>
8000711e:	30 1c       	mov	r12,1
80007120:	c3 99       	rjmp	80007392 <find_volume+0x36e>
	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
80007122:	58 0c       	cp.w	r12,0
80007124:	e0 81 01 36 	brne	80007390 <find_volume+0x36c>

	/* An FAT volume is found. Following code initializes the file system object */

	if (LD_WORD(fs->win + BPB_BytsPerSec) != SS(fs))	/* (BPB_BytsPerSec must be equal to the physical sector size) */
80007128:	ef 39 00 3c 	ld.ub	r9,r7[60]
8000712c:	ef 38 00 3b 	ld.ub	r8,r7[59]
80007130:	f1 e9 10 89 	or	r9,r8,r9<<0x8
80007134:	e0 68 02 00 	mov	r8,512
80007138:	f0 09 19 00 	cp.h	r9,r8
8000713c:	e0 81 01 2a 	brne	80007390 <find_volume+0x36c>
		return FR_NO_FILESYSTEM;

	fasize = LD_WORD(fs->win + BPB_FATSz16);			/* Number of sectors per FAT */
80007140:	ef 39 00 47 	ld.ub	r9,r7[71]
80007144:	ef 38 00 46 	ld.ub	r8,r7[70]
80007148:	f1 e9 10 88 	or	r8,r8,r9<<0x8
	if (!fasize) fasize = LD_DWORD(fs->win + BPB_FATSz32);
8000714c:	c1 01       	brne	8000716c <find_volume+0x148>
8000714e:	ef 39 00 57 	ld.ub	r9,r7[87]
80007152:	ef 38 00 56 	ld.ub	r8,r7[86]
80007156:	b1 68       	lsl	r8,0x10
80007158:	f1 e9 11 89 	or	r9,r8,r9<<0x18
8000715c:	ef 38 00 54 	ld.ub	r8,r7[84]
80007160:	f3 e8 10 08 	or	r8,r9,r8
80007164:	ef 39 00 55 	ld.ub	r9,r7[85]
80007168:	f1 e9 10 88 	or	r8,r8,r9<<0x8
	fs->fsize = fasize;
8000716c:	8f 68       	st.w	r7[0x18],r8

	fs->n_fats = fs->win[BPB_NumFATs];					/* Number of FAT copies */
8000716e:	ef 39 00 40 	ld.ub	r9,r7[64]
80007172:	ae b9       	st.b	r7[0x3],r9
	if (fs->n_fats != 1 && fs->n_fats != 2)				/* (Must be 1 or 2) */
80007174:	f2 cb 00 01 	sub	r11,r9,1
80007178:	30 1a       	mov	r10,1
8000717a:	f4 0b 18 00 	cp.b	r11,r10
8000717e:	e0 8b 01 09 	brhi	80007390 <find_volume+0x36c>
		return FR_NO_FILESYSTEM;
	fasize *= fs->n_fats;								/* Number of sectors for FAT area */

	fs->csize = fs->win[BPB_SecPerClus];				/* Number of sectors per cluster */
80007182:	ef 3a 00 3d 	ld.ub	r10,r7[61]
80007186:	ae aa       	st.b	r7[0x2],r10
	if (!fs->csize || (fs->csize & (fs->csize - 1)))	/* (Must be power of 2) */
80007188:	58 0a       	cp.w	r10,0
8000718a:	e0 80 01 03 	breq	80007390 <find_volume+0x36c>
8000718e:	f4 cb 00 01 	sub	r11,r10,1
80007192:	14 6b       	and	r11,r10
80007194:	e0 81 00 fe 	brne	80007390 <find_volume+0x36c>
		return FR_NO_FILESYSTEM;

	fs->n_rootdir = LD_WORD(fs->win + BPB_RootEntCnt);	/* Number of root directory entries */
80007198:	ef 3c 00 42 	ld.ub	r12,r7[66]
8000719c:	ef 3b 00 41 	ld.ub	r11,r7[65]
800071a0:	f7 ec 10 8b 	or	r11,r11,r12<<0x8
800071a4:	5c 8b       	casts.h	r11
800071a6:	ae 4b       	st.h	r7[0x8],r11
	if (fs->n_rootdir % (SS(fs) / SZ_DIRE))				/* (Must be sector aligned) */
800071a8:	f9 db c0 04 	bfextu	r12,r11,0x0,0x4
800071ac:	e0 81 00 f2 	brne	80007390 <find_volume+0x36c>
		return FR_NO_FILESYSTEM;

	tsect = LD_WORD(fs->win + BPB_TotSec16);			/* Number of sectors on the volume */
800071b0:	ef 36 00 44 	ld.ub	r6,r7[68]
800071b4:	ef 3c 00 43 	ld.ub	r12,r7[67]
800071b8:	f9 e6 10 8c 	or	r12,r12,r6<<0x8
	if (!tsect) tsect = LD_DWORD(fs->win + BPB_TotSec32);
800071bc:	c1 01       	brne	800071dc <find_volume+0x1b8>
800071be:	ef 36 00 53 	ld.ub	r6,r7[83]
800071c2:	ef 3c 00 52 	ld.ub	r12,r7[82]
800071c6:	b1 6c       	lsl	r12,0x10
800071c8:	f9 e6 11 86 	or	r6,r12,r6<<0x18
800071cc:	ef 3c 00 50 	ld.ub	r12,r7[80]
800071d0:	ed ec 10 0c 	or	r12,r6,r12
800071d4:	ef 36 00 51 	ld.ub	r6,r7[81]
800071d8:	f9 e6 10 8c 	or	r12,r12,r6<<0x8

	nrsv = LD_WORD(fs->win + BPB_RsvdSecCnt);			/* Number of reserved sectors */
800071dc:	ef 34 00 3f 	ld.ub	r4,r7[63]
800071e0:	ef 36 00 3e 	ld.ub	r6,r7[62]
800071e4:	ed e4 10 86 	or	r6,r6,r4<<0x8
800071e8:	5c 86       	casts.h	r6
	if (!nrsv) return FR_NO_FILESYSTEM;					/* (Must not be 0) */
800071ea:	e0 80 00 d3 	breq	80007390 <find_volume+0x36c>
	fs->fsize = fasize;

	fs->n_fats = fs->win[BPB_NumFATs];					/* Number of FAT copies */
	if (fs->n_fats != 1 && fs->n_fats != 2)				/* (Must be 1 or 2) */
		return FR_NO_FILESYSTEM;
	fasize *= fs->n_fats;								/* Number of sectors for FAT area */
800071ee:	b3 38       	mul	r8,r9

	nrsv = LD_WORD(fs->win + BPB_RsvdSecCnt);			/* Number of reserved sectors */
	if (!nrsv) return FR_NO_FILESYSTEM;					/* (Must not be 0) */

	/* Determine the FAT sub type */
	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIRE);	/* RSV + FAT + DIR */
800071f0:	e7 d6 c0 10 	bfextu	r3,r6,0x0,0x10
800071f4:	e9 db c0 8c 	bfextu	r4,r11,0x4,0xc
800071f8:	06 04       	add	r4,r3
800071fa:	10 04       	add	r4,r8
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
800071fc:	08 3c       	cp.w	r12,r4
800071fe:	e0 83 00 c9 	brlo	80007390 <find_volume+0x36c>
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
80007202:	f8 04 01 01 	sub	r1,r12,r4
80007206:	e2 0a 0d 00 	divu	r0,r1,r10
8000720a:	00 99       	mov	r9,r0
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
8000720c:	58 00       	cp.w	r0,0
8000720e:	e0 80 00 c1 	breq	80007390 <find_volume+0x36c>
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
80007212:	e0 40 0f f6 	cp.w	r0,4086
80007216:	f9 b6 03 01 	movlo	r6,1
8000721a:	f9 b6 02 02 	movhs	r6,2
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
8000721e:	e0 40 ff f5 	cp.w	r0,65525
80007222:	e0 8b 00 bb 	brhi	80007398 <find_volume+0x374>

	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
80007226:	2f e9       	sub	r9,-2
80007228:	8f 59       	st.w	r7[0x14],r9
	fs->volbase = bsect;								/* Volume start sector */
8000722a:	8f 75       	st.w	r7[0x1c],r5
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
8000722c:	ea 03 00 03 	add	r3,r5,r3
80007230:	8f 83       	st.w	r7[0x20],r3
	fs->database = bsect + sysect;						/* Data start sector */
80007232:	0a 04       	add	r4,r5
80007234:	8f a4       	st.w	r7[0x28],r4
	if (fmt == FS_FAT32) {
80007236:	30 3a       	mov	r10,3
80007238:	f4 06 18 00 	cp.b	r6,r10
8000723c:	c1 61       	brne	80007268 <find_volume+0x244>
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
8000723e:	58 0b       	cp.w	r11,0
80007240:	e0 81 00 a8 	brne	80007390 <find_volume+0x36c>
		fs->dirbase = LD_DWORD(fs->win + BPB_RootClus);	/* Root directory start cluster */
80007244:	ef 3a 00 5f 	ld.ub	r10,r7[95]
80007248:	ef 38 00 5e 	ld.ub	r8,r7[94]
8000724c:	b1 68       	lsl	r8,0x10
8000724e:	f1 ea 11 8a 	or	r10,r8,r10<<0x18
80007252:	ef 38 00 5c 	ld.ub	r8,r7[92]
80007256:	f5 e8 10 08 	or	r8,r10,r8
8000725a:	ef 3a 00 5d 	ld.ub	r10,r7[93]
8000725e:	f1 ea 10 88 	or	r8,r8,r10<<0x8
80007262:	8f 98       	st.w	r7[0x24],r8
		szbfat = fs->n_fatent * 4;						/* (Needed FAT size) */
80007264:	a3 69       	lsl	r9,0x2
80007266:	c1 38       	rjmp	8000728c <find_volume+0x268>
	} else {
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
80007268:	58 0b       	cp.w	r11,0
8000726a:	e0 80 00 93 	breq	80007390 <find_volume+0x36c>
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
8000726e:	06 08       	add	r8,r3
80007270:	8f 98       	st.w	r7[0x24],r8
		szbfat = (fmt == FS_FAT16) ?					/* (Needed FAT size) */
80007272:	30 28       	mov	r8,2
80007274:	f0 06 18 00 	cp.b	r6,r8
80007278:	c0 31       	brne	8000727e <find_volume+0x25a>
8000727a:	a1 79       	lsl	r9,0x1
8000727c:	c0 88       	rjmp	8000728c <find_volume+0x268>
8000727e:	f2 09 00 18 	add	r8,r9,r9<<0x1
80007282:	a1 98       	lsr	r8,0x1
80007284:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
80007288:	f0 09 00 09 	add	r9,r8,r9
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
	}
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than the size needed) */
8000728c:	f2 c8 fe 01 	sub	r8,r9,-511
80007290:	a9 98       	lsr	r8,0x9
80007292:	6e 69       	ld.w	r9,r7[0x18]
80007294:	10 39       	cp.w	r9,r8
80007296:	c7 d3       	brcs	80007390 <find_volume+0x36c>
		return FR_NO_FILESYSTEM;

#if !_FS_READONLY
	/* Initialize cluster allocation information */
	fs->last_clust = fs->free_clust = 0xFFFFFFFF;
80007298:	3f f8       	mov	r8,-1
8000729a:	8f 48       	st.w	r7[0x10],r8
8000729c:	8f 38       	st.w	r7[0xc],r8

	/* Get fsinfo if available */
	fs->fsi_flag = 0x80;
8000729e:	38 08       	mov	r8,-128
800072a0:	ae d8       	st.b	r7[0x5],r8
#if (_FS_NOFSINFO & 3) != 3
	if (fmt == FS_FAT32				/* Enable FSINFO only if FAT32 and BPB_FSInfo == 1 */
800072a2:	30 38       	mov	r8,3
800072a4:	f0 06 18 00 	cp.b	r6,r8
800072a8:	c6 81       	brne	80007378 <find_volume+0x354>
		&& LD_WORD(fs->win + BPB_FSInfo) == 1
800072aa:	ef 39 00 61 	ld.ub	r9,r7[97]
800072ae:	ef 38 00 60 	ld.ub	r8,r7[96]
800072b2:	f1 e9 10 89 	or	r9,r8,r9<<0x8
800072b6:	30 18       	mov	r8,1
800072b8:	f0 09 19 00 	cp.h	r9,r8
800072bc:	c5 e1       	brne	80007378 <find_volume+0x354>
		&& move_window(fs, bsect + 1) == FR_OK)
800072be:	ea cb ff ff 	sub	r11,r5,-1
800072c2:	0e 9c       	mov	r12,r7
800072c4:	f0 1f 00 3f 	mcall	800073c0 <find_volume+0x39c>
	fs->last_clust = fs->free_clust = 0xFFFFFFFF;

	/* Get fsinfo if available */
	fs->fsi_flag = 0x80;
#if (_FS_NOFSINFO & 3) != 3
	if (fmt == FS_FAT32				/* Enable FSINFO only if FAT32 and BPB_FSInfo == 1 */
800072c8:	c5 81       	brne	80007378 <find_volume+0x354>
		&& LD_WORD(fs->win + BPB_FSInfo) == 1
		&& move_window(fs, bsect + 1) == FR_OK)
	{
		fs->fsi_flag = 0;
800072ca:	30 08       	mov	r8,0
800072cc:	ae d8       	st.b	r7[0x5],r8
		if (LD_WORD(fs->win + BS_55AA) == 0xAA55	/* Load FSINFO data if available */
800072ce:	ef 39 02 2f 	ld.ub	r9,r7[559]
800072d2:	ef 38 02 2e 	ld.ub	r8,r7[558]
800072d6:	f1 e9 10 89 	or	r9,r8,r9<<0x8
800072da:	fe 78 aa 55 	mov	r8,-21931
800072de:	f0 09 19 00 	cp.h	r9,r8
800072e2:	c4 b1       	brne	80007378 <find_volume+0x354>
			&& LD_DWORD(fs->win + FSI_LeadSig) == 0x41615252
800072e4:	ef 39 00 33 	ld.ub	r9,r7[51]
800072e8:	ef 38 00 32 	ld.ub	r8,r7[50]
800072ec:	b1 68       	lsl	r8,0x10
800072ee:	f1 e9 11 89 	or	r9,r8,r9<<0x18
800072f2:	ef 38 00 30 	ld.ub	r8,r7[48]
800072f6:	f3 e8 10 08 	or	r8,r9,r8
800072fa:	ef 39 00 31 	ld.ub	r9,r7[49]
800072fe:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80007302:	e0 69 52 52 	mov	r9,21074
80007306:	ea 19 41 61 	orh	r9,0x4161
8000730a:	12 38       	cp.w	r8,r9
8000730c:	c3 61       	brne	80007378 <find_volume+0x354>
			&& LD_DWORD(fs->win + FSI_StrucSig) == 0x61417272)
8000730e:	ef 39 02 17 	ld.ub	r9,r7[535]
80007312:	ef 38 02 16 	ld.ub	r8,r7[534]
80007316:	b1 68       	lsl	r8,0x10
80007318:	f1 e9 11 89 	or	r9,r8,r9<<0x18
8000731c:	ef 38 02 14 	ld.ub	r8,r7[532]
80007320:	f3 e8 10 08 	or	r8,r9,r8
80007324:	ef 39 02 15 	ld.ub	r9,r7[533]
80007328:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000732c:	e0 69 72 72 	mov	r9,29298
80007330:	ea 19 61 41 	orh	r9,0x6141
80007334:	12 38       	cp.w	r8,r9
80007336:	c2 11       	brne	80007378 <find_volume+0x354>
		{
#if (_FS_NOFSINFO & 1) == 0
			fs->free_clust = LD_DWORD(fs->win + FSI_Free_Count);
80007338:	ef 39 02 1b 	ld.ub	r9,r7[539]
8000733c:	ef 38 02 1a 	ld.ub	r8,r7[538]
80007340:	b1 68       	lsl	r8,0x10
80007342:	f1 e9 11 89 	or	r9,r8,r9<<0x18
80007346:	ef 38 02 18 	ld.ub	r8,r7[536]
8000734a:	f3 e8 10 08 	or	r8,r9,r8
8000734e:	ef 39 02 19 	ld.ub	r9,r7[537]
80007352:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80007356:	8f 48       	st.w	r7[0x10],r8
#endif
#if (_FS_NOFSINFO & 2) == 0
			fs->last_clust = LD_DWORD(fs->win + FSI_Nxt_Free);
80007358:	ef 39 02 1f 	ld.ub	r9,r7[543]
8000735c:	ef 38 02 1e 	ld.ub	r8,r7[542]
80007360:	b1 68       	lsl	r8,0x10
80007362:	f1 e9 11 89 	or	r9,r8,r9<<0x18
80007366:	ef 38 02 1c 	ld.ub	r8,r7[540]
8000736a:	f3 e8 10 08 	or	r8,r9,r8
8000736e:	ef 39 02 1d 	ld.ub	r9,r7[541]
80007372:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80007376:	8f 38       	st.w	r7[0xc],r8
#endif
		}
	}
#endif
#endif
	fs->fs_type = fmt;	/* FAT sub-type */
80007378:	ae 86       	st.b	r7[0x0],r6
	fs->id = ++Fsid;	/* File system mount ID */
8000737a:	49 39       	lddpc	r9,800073c4 <find_volume+0x3a0>
8000737c:	92 08       	ld.sh	r8,r9[0x0]
8000737e:	2f f8       	sub	r8,-1
80007380:	b2 08       	st.h	r9[0x0],r8
80007382:	ae 38       	st.h	r7[0x6],r8
80007384:	30 0c       	mov	r12,0
#endif
#if _FS_LOCK			/* Clear file lock semaphores */
	clear_lock(fs);
#endif

	return FR_OK;
80007386:	c0 68       	rjmp	80007392 <find_volume+0x36e>
80007388:	30 ac       	mov	r12,10
8000738a:	c0 48       	rjmp	80007392 <find_volume+0x36e>
8000738c:	30 0c       	mov	r12,0
8000738e:	c0 28       	rjmp	80007392 <find_volume+0x36e>
80007390:	30 dc       	mov	r12,13
}
80007392:	2f cd       	sub	sp,-16
80007394:	e3 cd 80 fb 	ldm	sp++,r0-r1,r3-r7,pc
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;

	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
80007398:	2f e9       	sub	r9,-2
8000739a:	8f 59       	st.w	r7[0x14],r9
	fs->volbase = bsect;								/* Volume start sector */
8000739c:	8f 75       	st.w	r7[0x1c],r5
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
8000739e:	ea 03 00 03 	add	r3,r5,r3
800073a2:	8f 83       	st.w	r7[0x20],r3
	fs->database = bsect + sysect;						/* Data start sector */
800073a4:	0a 04       	add	r4,r5
800073a6:	8f a4       	st.w	r7[0x28],r4
800073a8:	30 36       	mov	r6,3
800073aa:	c4 ab       	rjmp	8000723e <find_volume+0x21a>
800073ac:	80 00       	ld.sh	r0,r0[0x0]
800073ae:	66 94       	ld.w	r4,r3[0x24]
800073b0:	00 00       	add	r0,r0
800073b2:	11 d0       	ld.ub	r0,r8[0x5]
800073b4:	80 00       	ld.sh	r0,r0[0x0]
800073b6:	64 f8       	ld.w	r8,r2[0x3c]
800073b8:	80 00       	ld.sh	r0,r0[0x0]
800073ba:	64 fa       	ld.w	r10,r2[0x3c]
800073bc:	80 00       	ld.sh	r0,r0[0x0]
800073be:	6f 88       	ld.w	r8,r7[0x60]
800073c0:	80 00       	ld.sh	r0,r0[0x0]
800073c2:	6f 48       	ld.w	r8,r7[0x50]
800073c4:	00 00       	add	r0,r0
800073c6:	11 cc       	ld.ub	r12,r8[0x4]

800073c8 <f_mount>:
FRESULT f_mount (
	FATFS* fs,			/* Pointer to the file system object (NULL:unmount)*/
	const TCHAR* path,	/* Logical drive number to be mounted/unmounted */
	BYTE opt			/* 0:Do not mount (delayed mount), 1:Mount immediately */
)
{
800073c8:	eb cd 40 40 	pushm	r6,lr
800073cc:	20 3d       	sub	sp,12
800073ce:	50 1c       	stdsp	sp[0x4],r12
800073d0:	50 0b       	stdsp	sp[0x0],r11
800073d2:	14 96       	mov	r6,r10
	FATFS *cfs;
	int vol;
	FRESULT res;
	const TCHAR *rp = path;
800073d4:	fa cc ff f4 	sub	r12,sp,-12
800073d8:	18 db       	st.w	--r12,r11


	vol = get_ldnumber(&rp);
800073da:	f0 1f 00 1a 	mcall	80007440 <f_mount+0x78>
	if (vol < 0) return FR_INVALID_DRIVE;
800073de:	c0 34       	brge	800073e4 <f_mount+0x1c>
800073e0:	30 bc       	mov	r12,11
800073e2:	c2 58       	rjmp	8000742c <f_mount+0x64>
	cfs = FatFs[vol];					/* Pointer to fs object */
800073e4:	49 88       	lddpc	r8,80007444 <f_mount+0x7c>
800073e6:	f0 0c 03 28 	ld.w	r8,r8[r12<<0x2]
		clear_lock(cfs);
#endif
#if _FS_REENTRANT						/* Discard sync object of the current volume */
		if (!ff_del_syncobj(cfs->sobj)) return FR_INT_ERR;
#endif
		cfs->fs_type = 0;				/* Clear old fs object */
800073ea:	58 08       	cp.w	r8,0
800073ec:	f9 b9 01 00 	movne	r9,0
800073f0:	f1 f9 1e 00 	st.bne	r8[0x0],r9
	}

	if (fs) {
800073f4:	40 18       	lddsp	r8,sp[0x4]
800073f6:	58 08       	cp.w	r8,0
800073f8:	c1 d0       	breq	80007432 <f_mount+0x6a>
		fs->fs_type = 0;				/* Clear new fs object */
800073fa:	30 09       	mov	r9,0
800073fc:	b0 89       	st.b	r8[0x0],r9
#if _FS_REENTRANT						/* Create sync object for the new volume */
		if (!ff_cre_syncobj((BYTE)vol, &fs->sobj)) return FR_INT_ERR;
#endif
	}
	FatFs[vol] = fs;					/* Register new fs object */
800073fe:	40 18       	lddsp	r8,sp[0x4]
80007400:	49 1a       	lddpc	r10,80007444 <f_mount+0x7c>
80007402:	f4 0c 09 28 	st.w	r10[r12<<0x2],r8

	if (!fs || opt != 1) return FR_OK;	/* Do not mount now, it will be mounted later */
80007406:	58 08       	cp.w	r8,0
80007408:	5f 0a       	sreq	r10
8000740a:	30 18       	mov	r8,1
8000740c:	f0 06 18 00 	cp.b	r6,r8
80007410:	5f 18       	srne	r8
80007412:	f5 e8 10 08 	or	r8,r10,r8
80007416:	f2 08 18 00 	cp.b	r8,r9
8000741a:	c0 30       	breq	80007420 <f_mount+0x58>
8000741c:	30 0c       	mov	r12,0
8000741e:	c0 78       	rjmp	8000742c <f_mount+0x64>

	res = find_volume(&fs, &path, 0);	/* Force mounted the volume */
80007420:	30 0a       	mov	r10,0
80007422:	1a 9b       	mov	r11,sp
80007424:	fa cc ff fc 	sub	r12,sp,-4
80007428:	f0 1f 00 08 	mcall	80007448 <f_mount+0x80>
	LEAVE_FF(fs, res);
}
8000742c:	2f dd       	sub	sp,-12
8000742e:	e3 cd 80 40 	ldm	sp++,r6,pc
		fs->fs_type = 0;				/* Clear new fs object */
#if _FS_REENTRANT						/* Create sync object for the new volume */
		if (!ff_cre_syncobj((BYTE)vol, &fs->sobj)) return FR_INT_ERR;
#endif
	}
	FatFs[vol] = fs;					/* Register new fs object */
80007432:	30 08       	mov	r8,0
80007434:	48 49       	lddpc	r9,80007444 <f_mount+0x7c>
80007436:	f2 0c 09 28 	st.w	r9[r12<<0x2],r8
8000743a:	10 9c       	mov	r12,r8
8000743c:	cf 8b       	rjmp	8000742c <f_mount+0x64>
8000743e:	00 00       	add	r0,r0
80007440:	80 00       	ld.sh	r0,r0[0x0]
80007442:	66 94       	ld.w	r4,r3[0x24]
80007444:	00 00       	add	r0,r0
80007446:	11 d0       	ld.ub	r0,r8[0x5]
80007448:	80 00       	ld.sh	r0,r0[0x0]
8000744a:	70 24       	ld.w	r4,r8[0x8]

8000744c <f_sync>:
/*-----------------------------------------------------------------------*/

FRESULT f_sync (
	FIL* fp		/* Pointer to the file object */
)
{
8000744c:	eb cd 40 c0 	pushm	r6-r7,lr
80007450:	18 97       	mov	r7,r12
	FRESULT res;
	DWORD tm;
	BYTE *dir;


	res = validate(fp);					/* Check validity of the object */
80007452:	f0 1f 00 2b 	mcall	800074fc <f_sync+0xb0>
	if (res == FR_OK) {
80007456:	c5 11       	brne	800074f8 <f_sync+0xac>
		if (fp->flag & FA__WRITTEN) {	/* Is there any change to the file? */
80007458:	0f e8       	ld.ub	r8,r7[0x6]
8000745a:	10 99       	mov	r9,r8
8000745c:	e2 19 00 20 	andl	r9,0x20,COH
80007460:	c4 c0       	breq	800074f8 <f_sync+0xac>
#if !_FS_TINY
			if (fp->flag & FA__DIRTY) {	/* Write-back cached data if needed */
80007462:	e2 18 00 40 	andl	r8,0x40,COH
80007466:	c0 f0       	breq	80007484 <f_sync+0x38>
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
80007468:	6e 08       	ld.w	r8,r7[0x0]
8000746a:	30 19       	mov	r9,1
8000746c:	6e 6a       	ld.w	r10,r7[0x18]
8000746e:	ee cb ff d8 	sub	r11,r7,-40
80007472:	11 9c       	ld.ub	r12,r8[0x1]
80007474:	f0 1f 00 23 	mcall	80007500 <f_sync+0xb4>
80007478:	c0 30       	breq	8000747e <f_sync+0x32>
8000747a:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
					LEAVE_FF(fp->fs, FR_DISK_ERR);
				fp->flag &= ~FA__DIRTY;
8000747e:	0f e8       	ld.ub	r8,r7[0x6]
80007480:	a7 c8       	cbr	r8,0x6
80007482:	ae e8       	st.b	r7[0x6],r8
			}
#endif
			/* Update the directory entry */
			res = move_window(fp->fs, fp->dir_sect);
80007484:	6e 7b       	ld.w	r11,r7[0x1c]
80007486:	6e 0c       	ld.w	r12,r7[0x0]
80007488:	f0 1f 00 1f 	mcall	80007504 <f_sync+0xb8>
			if (res == FR_OK) {
8000748c:	c3 61       	brne	800074f8 <f_sync+0xac>
				dir = fp->dir_ptr;
8000748e:	6e 86       	ld.w	r6,r7[0x20]
				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
80007490:	ec c8 ff f5 	sub	r8,r6,-11
80007494:	11 89       	ld.ub	r9,r8[0x0]
80007496:	a5 b9       	sbr	r9,0x5
80007498:	b0 89       	st.b	r8[0x0],r9
				ST_DWORD(dir + DIR_FileSize, fp->fsize);	/* Update file size */
8000749a:	6e 38       	ld.w	r8,r7[0xc]
8000749c:	ed 68 00 1c 	st.b	r6[28],r8
800074a0:	ef 38 00 0e 	ld.ub	r8,r7[14]
800074a4:	ed 68 00 1d 	st.b	r6[29],r8
800074a8:	8e e8       	ld.uh	r8,r7[0xc]
800074aa:	ed 68 00 1e 	st.b	r6[30],r8
800074ae:	ef 38 00 0c 	ld.ub	r8,r7[12]
800074b2:	ed 68 00 1f 	st.b	r6[31],r8
				st_clust(dir, fp->sclust);					/* Update start cluster */
800074b6:	6e 4b       	ld.w	r11,r7[0x10]
800074b8:	0c 9c       	mov	r12,r6
800074ba:	f0 1f 00 14 	mcall	80007508 <f_sync+0xbc>
				tm = GET_FATTIME();							/* Update modified time */
800074be:	f0 1f 00 14 	mcall	8000750c <f_sync+0xc0>
				ST_DWORD(dir + DIR_WrtTime, tm);
800074c2:	ed 6c 00 16 	st.b	r6[22],r12
800074c6:	f1 dc c1 08 	bfextu	r8,r12,0x8,0x8
800074ca:	ed 68 00 17 	st.b	r6[23],r8
800074ce:	f8 08 16 10 	lsr	r8,r12,0x10
800074d2:	ed 68 00 18 	st.b	r6[24],r8
800074d6:	b9 8c       	lsr	r12,0x18
800074d8:	ed 6c 00 19 	st.b	r6[25],r12
				ST_WORD(dir + DIR_LstAccDate, 0);
800074dc:	30 08       	mov	r8,0
800074de:	ed 68 00 12 	st.b	r6[18],r8
800074e2:	ed 68 00 13 	st.b	r6[19],r8
				fp->flag &= ~FA__WRITTEN;
800074e6:	0f e8       	ld.ub	r8,r7[0x6]
800074e8:	a5 d8       	cbr	r8,0x5
800074ea:	ae e8       	st.b	r7[0x6],r8
				fp->fs->wflag = 1;
800074ec:	6e 08       	ld.w	r8,r7[0x0]
800074ee:	30 19       	mov	r9,1
800074f0:	b0 c9       	st.b	r8[0x4],r9
				res = sync_fs(fp->fs);
800074f2:	6e 0c       	ld.w	r12,r7[0x0]
800074f4:	f0 1f 00 07 	mcall	80007510 <f_sync+0xc4>
			}
		}
	}

	LEAVE_FF(fp->fs, res);
}
800074f8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800074fc:	80 00       	ld.sh	r0,r0[0x0]
800074fe:	6f 14       	ld.w	r4,r7[0x44]
80007500:	80 00       	ld.sh	r0,r0[0x0]
80007502:	65 88       	ld.w	r8,r2[0x60]
80007504:	80 00       	ld.sh	r0,r0[0x0]
80007506:	6f 48       	ld.w	r8,r7[0x50]
80007508:	80 00       	ld.sh	r0,r0[0x0]
8000750a:	66 7a       	ld.w	r10,r3[0x1c]
8000750c:	80 00       	ld.sh	r0,r0[0x0]
8000750e:	64 fc       	ld.w	r12,r2[0x3c]
80007510:	80 00       	ld.sh	r0,r0[0x0]
80007512:	67 b4       	ld.w	r4,r3[0x6c]

80007514 <f_close>:
/*-----------------------------------------------------------------------*/

FRESULT f_close (
	FIL *fp		/* Pointer to the file object to be closed */
)
{
80007514:	eb cd 40 80 	pushm	r7,lr
80007518:	18 97       	mov	r7,r12
	FRESULT res;


#if !_FS_READONLY
	res = f_sync(fp);					/* Flush cached data */
8000751a:	f0 1f 00 07 	mcall	80007534 <f_close+0x20>
	if (res == FR_OK)
8000751e:	c0 81       	brne	8000752e <f_close+0x1a>
#endif
	{
		res = validate(fp);				/* Lock volume */
80007520:	0e 9c       	mov	r12,r7
80007522:	f0 1f 00 06 	mcall	80007538 <f_close+0x24>
#endif
#if _FS_LOCK
			res = dec_lock(fp->lockid);	/* Decrement file open counter */
			if (res == FR_OK)
#endif
				fp->fs = 0;				/* Invalidate file object */
80007526:	f9 b8 00 00 	moveq	r8,0
8000752a:	ef f8 0a 00 	st.weq	r7[0x0],r8
			unlock_fs(fs, FR_OK);		/* Unlock volume */
#endif
		}
	}
	return res;
}
8000752e:	e3 cd 80 80 	ldm	sp++,r7,pc
80007532:	00 00       	add	r0,r0
80007534:	80 00       	ld.sh	r0,r0[0x0]
80007536:	74 4c       	ld.w	r12,r10[0x10]
80007538:	80 00       	ld.sh	r0,r0[0x0]
8000753a:	6f 14       	ld.w	r4,r7[0x44]

8000753c <put_fat>:
FRESULT put_fat (	/* FR_OK(0):succeeded, !=0:error */
	FATFS* fs,		/* File system object */
	DWORD clst,		/* FAT index number (cluster number) to be changed */
	DWORD val		/* New value to be set to the entry */
)
{
8000753c:	d4 21       	pushm	r4-r7,lr
8000753e:	18 97       	mov	r7,r12
80007540:	16 96       	mov	r6,r11
80007542:	14 95       	mov	r5,r10
	UINT bc;
	BYTE *p;
	FRESULT res;


	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
80007544:	58 1b       	cp.w	r11,1
80007546:	e0 88 00 90 	brls	80007666 <put_fat+0x12a>
8000754a:	78 58       	ld.w	r8,r12[0x14]
8000754c:	10 3b       	cp.w	r11,r8
8000754e:	e0 82 00 8c 	brhs	80007666 <put_fat+0x12a>
		res = FR_INT_ERR;

	} else {
		switch (fs->fs_type) {
80007552:	19 88       	ld.ub	r8,r12[0x0]
80007554:	30 29       	mov	r9,2
80007556:	f2 08 18 00 	cp.b	r8,r9
8000755a:	c4 d0       	breq	800075f4 <put_fat+0xb8>
8000755c:	30 39       	mov	r9,3
8000755e:	f2 08 18 00 	cp.b	r8,r9
80007562:	c5 e0       	breq	8000761e <put_fat+0xe2>
80007564:	30 19       	mov	r9,1
80007566:	f2 08 18 00 	cp.b	r8,r9
8000756a:	c7 e1       	brne	80007666 <put_fat+0x12a>
		case FS_FAT12 :
			bc = (UINT)clst; bc += bc / 2;
8000756c:	f6 04 16 01 	lsr	r4,r11,0x1
80007570:	16 04       	add	r4,r11
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
80007572:	e8 0b 16 09 	lsr	r11,r4,0x9
80007576:	78 88       	ld.w	r8,r12[0x20]
80007578:	10 0b       	add	r11,r8
8000757a:	f0 1f 00 3d 	mcall	8000766c <put_fat+0x130>
			if (res != FR_OK) break;
8000757e:	c7 51       	brne	80007668 <put_fat+0x12c>
			p = &fs->win[bc++ % SS(fs)];
80007580:	f1 d4 c0 09 	bfextu	r8,r4,0x0,0x9
80007584:	2f f4       	sub	r4,-1
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
80007586:	ed d6 c0 01 	bfextu	r6,r6,0x0,0x1
8000758a:	c0 d0       	breq	800075a4 <put_fat+0x68>
8000758c:	ee 08 00 09 	add	r9,r7,r8
80007590:	f3 39 00 30 	ld.ub	r9,r9[48]
80007594:	f5 d5 c0 08 	bfextu	r10,r5,0x0,0x8
80007598:	f3 d9 c0 04 	bfextu	r9,r9,0x0,0x4
8000759c:	f3 ea 10 49 	or	r9,r9,r10<<0x4
800075a0:	5c 59       	castu.b	r9
800075a2:	c0 38       	rjmp	800075a8 <put_fat+0x6c>
800075a4:	f3 d5 c0 08 	bfextu	r9,r5,0x0,0x8
800075a8:	ee 08 00 08 	add	r8,r7,r8
800075ac:	f1 69 00 30 	st.b	r8[48],r9
			fs->wflag = 1;
800075b0:	30 18       	mov	r8,1
800075b2:	ae c8       	st.b	r7[0x4],r8
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
800075b4:	e8 0b 16 09 	lsr	r11,r4,0x9
800075b8:	6e 88       	ld.w	r8,r7[0x20]
800075ba:	10 0b       	add	r11,r8
800075bc:	0e 9c       	mov	r12,r7
800075be:	f0 1f 00 2c 	mcall	8000766c <put_fat+0x130>
			if (res != FR_OK) break;
800075c2:	c5 31       	brne	80007668 <put_fat+0x12c>
			p = &fs->win[bc % SS(fs)];
800075c4:	e9 d4 c0 09 	bfextu	r4,r4,0x0,0x9
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
800075c8:	58 06       	cp.w	r6,0
800075ca:	c0 40       	breq	800075d2 <put_fat+0x96>
800075cc:	eb d5 c0 88 	bfextu	r5,r5,0x4,0x8
800075d0:	c0 b8       	rjmp	800075e6 <put_fat+0xaa>
800075d2:	ee 04 00 08 	add	r8,r7,r4
800075d6:	f1 38 00 30 	ld.ub	r8,r8[48]
800075da:	eb d5 c1 04 	bfextu	r5,r5,0x8,0x4
800075de:	e2 18 00 f0 	andl	r8,0xf0,COH
800075e2:	f1 e5 10 05 	or	r5,r8,r5
800075e6:	ee 04 00 04 	add	r4,r7,r4
800075ea:	e9 65 00 30 	st.b	r4[48],r5
			fs->wflag = 1;
800075ee:	30 18       	mov	r8,1
800075f0:	ae c8       	st.b	r7[0x4],r8
			break;
800075f2:	d8 22       	popm	r4-r7,pc

		case FS_FAT16 :
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
800075f4:	a9 8b       	lsr	r11,0x8
800075f6:	78 88       	ld.w	r8,r12[0x20]
800075f8:	10 0b       	add	r11,r8
800075fa:	f0 1f 00 1d 	mcall	8000766c <put_fat+0x130>
			if (res != FR_OK) break;
800075fe:	c3 51       	brne	80007668 <put_fat+0x12c>
			p = &fs->win[clst * 2 % SS(fs)];
80007600:	a1 76       	lsl	r6,0x1
80007602:	ed d6 c0 09 	bfextu	r6,r6,0x0,0x9
			ST_WORD(p, (WORD)val);
80007606:	ee 06 00 08 	add	r8,r7,r6
8000760a:	f1 65 00 30 	st.b	r8[48],r5
8000760e:	10 96       	mov	r6,r8
80007610:	eb d5 c1 08 	bfextu	r5,r5,0x8,0x8
80007614:	f1 65 00 31 	st.b	r8[49],r5
			fs->wflag = 1;
80007618:	30 18       	mov	r8,1
8000761a:	ae c8       	st.b	r7[0x4],r8
			break;
8000761c:	d8 22       	popm	r4-r7,pc

		case FS_FAT32 :
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
8000761e:	a7 9b       	lsr	r11,0x7
80007620:	78 88       	ld.w	r8,r12[0x20]
80007622:	10 0b       	add	r11,r8
80007624:	f0 1f 00 12 	mcall	8000766c <put_fat+0x130>
			if (res != FR_OK) break;
80007628:	c2 01       	brne	80007668 <put_fat+0x12c>
			p = &fs->win[clst * 4 % SS(fs)];
8000762a:	a3 66       	lsl	r6,0x2
8000762c:	ed d6 c0 09 	bfextu	r6,r6,0x0,0x9
80007630:	ec c8 ff d0 	sub	r8,r6,-48
80007634:	ee 08 00 08 	add	r8,r7,r8
			val |= LD_DWORD(p) & 0xF0000000;
80007638:	f0 c9 ff fd 	sub	r9,r8,-3
8000763c:	13 8a       	ld.ub	r10,r9[0x0]
8000763e:	b9 6a       	lsl	r10,0x18
80007640:	ee 06 00 06 	add	r6,r7,r6
80007644:	e6 1a f0 00 	andh	r10,0xf000,COH
80007648:	f5 e5 10 05 	or	r5,r10,r5
			ST_DWORD(p, val);
8000764c:	ed 65 00 30 	st.b	r6[48],r5
80007650:	f5 d5 c1 08 	bfextu	r10,r5,0x8,0x8
80007654:	b0 9a       	st.b	r8[0x1],r10
80007656:	ea 0a 16 10 	lsr	r10,r5,0x10
8000765a:	b0 aa       	st.b	r8[0x2],r10
8000765c:	b9 85       	lsr	r5,0x18
8000765e:	b2 85       	st.b	r9[0x0],r5
			fs->wflag = 1;
80007660:	30 18       	mov	r8,1
80007662:	ae c8       	st.b	r7[0x4],r8
			break;
80007664:	d8 22       	popm	r4-r7,pc
80007666:	30 2c       	mov	r12,2
			res = FR_INT_ERR;
		}
	}

	return res;
}
80007668:	d8 22       	popm	r4-r7,pc
8000766a:	00 00       	add	r0,r0
8000766c:	80 00       	ld.sh	r0,r0[0x0]
8000766e:	6f 48       	ld.w	r8,r7[0x50]

80007670 <get_fat>:

DWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Internal error, 2..0x0FFFFFFF:Cluster status */
	FATFS* fs,	/* File system object */
	DWORD clst	/* FAT index number (cluster number) to get the value */
)
{
80007670:	d4 21       	pushm	r4-r7,lr
80007672:	18 97       	mov	r7,r12
80007674:	16 96       	mov	r6,r11
	UINT wc, bc;
	BYTE *p;
	DWORD val;


	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
80007676:	58 1b       	cp.w	r11,1
80007678:	e0 88 00 69 	brls	8000774a <get_fat+0xda>
8000767c:	78 58       	ld.w	r8,r12[0x14]
8000767e:	10 3b       	cp.w	r11,r8
80007680:	c6 52       	brcc	8000774a <get_fat+0xda>
		val = 1;	/* Internal error */

	} else {
		val = 0xFFFFFFFF;	/* Default value falls on disk error */

		switch (fs->fs_type) {
80007682:	19 88       	ld.ub	r8,r12[0x0]
80007684:	30 29       	mov	r9,2
80007686:	f2 08 18 00 	cp.b	r8,r9
8000768a:	c3 10       	breq	800076ec <get_fat+0x7c>
8000768c:	30 39       	mov	r9,3
8000768e:	f2 08 18 00 	cp.b	r8,r9
80007692:	c4 00       	breq	80007712 <get_fat+0xa2>
80007694:	30 19       	mov	r9,1
80007696:	f2 08 18 00 	cp.b	r8,r9
8000769a:	c5 81       	brne	8000774a <get_fat+0xda>
		case FS_FAT12 :
			bc = (UINT)clst; bc += bc / 2;
8000769c:	f6 05 16 01 	lsr	r5,r11,0x1
800076a0:	16 05       	add	r5,r11
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
800076a2:	ea 0b 16 09 	lsr	r11,r5,0x9
800076a6:	78 88       	ld.w	r8,r12[0x20]
800076a8:	10 0b       	add	r11,r8
800076aa:	f0 1f 00 2a 	mcall	80007750 <get_fat+0xe0>
800076ae:	c4 f1       	brne	8000774c <get_fat+0xdc>
			wc = fs->win[bc++ % SS(fs)];
800076b0:	f1 d5 c0 09 	bfextu	r8,r5,0x0,0x9
800076b4:	ee 08 00 08 	add	r8,r7,r8
800076b8:	f1 34 00 30 	ld.ub	r4,r8[48]
800076bc:	2f f5       	sub	r5,-1
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
800076be:	ea 0b 16 09 	lsr	r11,r5,0x9
800076c2:	6e 88       	ld.w	r8,r7[0x20]
800076c4:	10 0b       	add	r11,r8
800076c6:	0e 9c       	mov	r12,r7
800076c8:	f0 1f 00 22 	mcall	80007750 <get_fat+0xe0>
800076cc:	c4 01       	brne	8000774c <get_fat+0xdc>
			wc |= fs->win[bc % SS(fs)] << 8;
800076ce:	eb d5 c0 09 	bfextu	r5,r5,0x0,0x9
800076d2:	0a 07       	add	r7,r5
800076d4:	ef 3c 00 30 	ld.ub	r12,r7[48]
800076d8:	e9 ec 10 8c 	or	r12,r4,r12<<0x8
			val = clst & 1 ? wc >> 4 : (wc & 0xFFF);
800076dc:	ed d6 c0 01 	bfextu	r6,r6,0x0,0x1
800076e0:	c0 30       	breq	800076e6 <get_fat+0x76>
800076e2:	a5 8c       	lsr	r12,0x4
800076e4:	d8 22       	popm	r4-r7,pc
800076e6:	f9 dc c0 0c 	bfextu	r12,r12,0x0,0xc
800076ea:	d8 22       	popm	r4-r7,pc
			break;

		case FS_FAT16 :
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))) != FR_OK) break;
800076ec:	a9 8b       	lsr	r11,0x8
800076ee:	78 88       	ld.w	r8,r12[0x20]
800076f0:	10 0b       	add	r11,r8
800076f2:	f0 1f 00 18 	mcall	80007750 <get_fat+0xe0>
800076f6:	c2 b1       	brne	8000774c <get_fat+0xdc>
			p = &fs->win[clst * 2 % SS(fs)];
800076f8:	a1 76       	lsl	r6,0x1
800076fa:	ed d6 c0 09 	bfextu	r6,r6,0x0,0x9
			val = LD_WORD(p);
800076fe:	ee 06 00 08 	add	r8,r7,r6
80007702:	10 97       	mov	r7,r8
80007704:	f1 3c 00 31 	ld.ub	r12,r8[49]
80007708:	f1 38 00 30 	ld.ub	r8,r8[48]
8000770c:	f1 ec 10 8c 	or	r12,r8,r12<<0x8
			break;
80007710:	d8 22       	popm	r4-r7,pc

		case FS_FAT32 :
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
80007712:	a7 9b       	lsr	r11,0x7
80007714:	78 88       	ld.w	r8,r12[0x20]
80007716:	10 0b       	add	r11,r8
80007718:	f0 1f 00 0e 	mcall	80007750 <get_fat+0xe0>
8000771c:	c1 81       	brne	8000774c <get_fat+0xdc>
			p = &fs->win[clst * 4 % SS(fs)];
8000771e:	a3 66       	lsl	r6,0x2
80007720:	ed d6 c0 09 	bfextu	r6,r6,0x0,0x9
80007724:	ec c8 ff d0 	sub	r8,r6,-48
80007728:	ee 08 00 08 	add	r8,r7,r8
			val = LD_DWORD(p) & 0x0FFFFFFF;
8000772c:	11 a9       	ld.ub	r9,r8[0x2]
8000772e:	11 bc       	ld.ub	r12,r8[0x3]
80007730:	b9 6c       	lsl	r12,0x18
80007732:	f9 e9 11 0c 	or	r12,r12,r9<<0x10
80007736:	11 98       	ld.ub	r8,r8[0x1]
80007738:	f9 e8 10 8c 	or	r12,r12,r8<<0x8
8000773c:	0c 07       	add	r7,r6
8000773e:	ef 38 00 30 	ld.ub	r8,r7[48]
80007742:	10 4c       	or	r12,r8
80007744:	f9 dc c0 1c 	bfextu	r12,r12,0x0,0x1c
			break;
80007748:	d8 22       	popm	r4-r7,pc
8000774a:	da 2a       	popm	r4-r7,pc,r12=1
8000774c:	dc 2a       	popm	r4-r7,pc,r12=-1
8000774e:	00 00       	add	r0,r0
80007750:	80 00       	ld.sh	r0,r0[0x0]
80007752:	6f 48       	ld.w	r8,r7[0x50]

80007754 <dir_sdi>:
static
FRESULT dir_sdi (	/* FR_OK(0):succeeded, !=0:error */
	DIR* dp,		/* Pointer to directory object */
	UINT idx		/* Index of directory table */
)
{
80007754:	eb cd 40 f8 	pushm	r3-r7,lr
80007758:	18 96       	mov	r6,r12
8000775a:	16 95       	mov	r5,r11
	DWORD clst, sect;
	UINT ic;


	dp->index = (WORD)idx;	/* Current index */
8000775c:	ac 3b       	st.h	r6[0x6],r11
	clst = dp->sclust;		/* Table start cluster (0:root) */
8000775e:	78 28       	ld.w	r8,r12[0x8]
	if (clst == 1 || clst >= dp->fs->n_fatent)	/* Check start cluster range */
80007760:	58 18       	cp.w	r8,1
80007762:	c4 c0       	breq	800077fa <dir_sdi+0xa6>
80007764:	78 09       	ld.w	r9,r12[0x0]
80007766:	72 5a       	ld.w	r10,r9[0x14]
80007768:	14 38       	cp.w	r8,r10
8000776a:	c4 82       	brcc	800077fa <dir_sdi+0xa6>
		return FR_INT_ERR;
	if (!clst && dp->fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
8000776c:	58 08       	cp.w	r8,0
8000776e:	c0 f1       	brne	8000778c <dir_sdi+0x38>
80007770:	13 8b       	ld.ub	r11,r9[0x0]
80007772:	30 3a       	mov	r10,3
80007774:	f4 0b 18 00 	cp.b	r11,r10
80007778:	c0 41       	brne	80007780 <dir_sdi+0x2c>
		clst = dp->fs->dirbase;
8000777a:	72 97       	ld.w	r7,r9[0x24]

	if (clst == 0) {	/* Static table (root-directory in FAT12/16) */
8000777c:	58 07       	cp.w	r7,0
8000777e:	c0 81       	brne	8000778e <dir_sdi+0x3a>
		if (idx >= dp->fs->n_rootdir)	/* Is index out of range? */
80007780:	92 ca       	ld.uh	r10,r9[0x8]
80007782:	14 35       	cp.w	r5,r10
80007784:	c3 b2       	brcc	800077fa <dir_sdi+0xa6>
			return FR_INT_ERR;
		sect = dp->fs->dirbase;
80007786:	72 9c       	ld.w	r12,r9[0x24]
80007788:	10 97       	mov	r7,r8
8000778a:	c2 68       	rjmp	800077d6 <dir_sdi+0x82>
8000778c:	10 97       	mov	r7,r8
	}
	else {				/* Dynamic table (root-directory in FAT32 or sub-directory) */
		ic = SS(dp->fs) / SZ_DIRE * dp->fs->csize;	/* Entries per cluster */
8000778e:	13 a4       	ld.ub	r4,r9[0x2]
80007790:	a5 64       	lsl	r4,0x4
		while (idx >= ic) {	/* Follow cluster chain */
80007792:	08 35       	cp.w	r5,r4
80007794:	c1 d3       	brcs	800077ce <dir_sdi+0x7a>
/*-----------------------------------------------------------------------*/
/* Directory handling - Set directory index                              */
/*-----------------------------------------------------------------------*/

static
FRESULT dir_sdi (	/* FR_OK(0):succeeded, !=0:error */
80007796:	e8 03 11 00 	rsub	r3,r4,0
8000779a:	08 15       	sub	r5,r4
		sect = dp->fs->dirbase;
	}
	else {				/* Dynamic table (root-directory in FAT32 or sub-directory) */
		ic = SS(dp->fs) / SZ_DIRE * dp->fs->csize;	/* Entries per cluster */
		while (idx >= ic) {	/* Follow cluster chain */
			clst = get_fat(dp->fs, clst);				/* Get next cluster */
8000779c:	0e 9b       	mov	r11,r7
8000779e:	6c 0c       	ld.w	r12,r6[0x0]
800077a0:	f0 1f 00 18 	mcall	80007800 <dir_sdi+0xac>
800077a4:	18 97       	mov	r7,r12
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
800077a6:	5b fc       	cp.w	r12,-1
800077a8:	c0 31       	brne	800077ae <dir_sdi+0x5a>
800077aa:	e3 cf 90 f8 	ldm	sp++,r3-r7,pc,r12=1
			if (clst < 2 || clst >= dp->fs->n_fatent)	/* Reached to end of table or internal error */
800077ae:	58 1c       	cp.w	r12,1
800077b0:	e0 88 00 25 	brls	800077fa <dir_sdi+0xa6>
800077b4:	6c 08       	ld.w	r8,r6[0x0]
800077b6:	70 58       	ld.w	r8,r8[0x14]
800077b8:	10 3c       	cp.w	r12,r8
800077ba:	c2 02       	brcc	800077fa <dir_sdi+0xa6>
800077bc:	ea 03 00 08 	add	r8,r5,r3
			return FR_INT_ERR;
		sect = dp->fs->dirbase;
	}
	else {				/* Dynamic table (root-directory in FAT32 or sub-directory) */
		ic = SS(dp->fs) / SZ_DIRE * dp->fs->csize;	/* Entries per cluster */
		while (idx >= ic) {	/* Follow cluster chain */
800077c0:	f0 04 00 09 	add	r9,r8,r4
800077c4:	12 34       	cp.w	r4,r9
800077c6:	e0 8b 00 04 	brhi	800077ce <dir_sdi+0x7a>
800077ca:	10 95       	mov	r5,r8
800077cc:	ce 8b       	rjmp	8000779c <dir_sdi+0x48>
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
			if (clst < 2 || clst >= dp->fs->n_fatent)	/* Reached to end of table or internal error */
				return FR_INT_ERR;
			idx -= ic;
		}
		sect = clust2sect(dp->fs, clst);
800077ce:	0e 9b       	mov	r11,r7
800077d0:	6c 0c       	ld.w	r12,r6[0x0]
800077d2:	f0 1f 00 0d 	mcall	80007804 <dir_sdi+0xb0>
	}
	dp->clust = clst;	/* Current cluster# */
800077d6:	8d 37       	st.w	r6[0xc],r7
	if (!sect) return FR_INT_ERR;
800077d8:	58 0c       	cp.w	r12,0
800077da:	c1 00       	breq	800077fa <dir_sdi+0xa6>
	dp->sect = sect + idx / (SS(dp->fs) / SZ_DIRE);					/* Sector# of the directory entry */
800077dc:	ea 08 16 04 	lsr	r8,r5,0x4
800077e0:	f0 0c 00 0c 	add	r12,r8,r12
800077e4:	8d 4c       	st.w	r6[0x10],r12
	dp->dir = dp->fs->win + (idx % (SS(dp->fs) / SZ_DIRE)) * SZ_DIRE;	/* Ptr to the entry in the sector */
800077e6:	6c 08       	ld.w	r8,r6[0x0]
800077e8:	2d 08       	sub	r8,-48
800077ea:	eb d5 c0 04 	bfextu	r5,r5,0x0,0x4
800077ee:	a5 75       	lsl	r5,0x5
800077f0:	f0 05 00 05 	add	r5,r8,r5
800077f4:	8d 55       	st.w	r6[0x14],r5
800077f6:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0

	return FR_OK;
800077fa:	30 2c       	mov	r12,2
}
800077fc:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80007800:	80 00       	ld.sh	r0,r0[0x0]
80007802:	76 70       	ld.w	r0,r11[0x1c]
80007804:	80 00       	ld.sh	r0,r0[0x0]
80007806:	65 fc       	ld.w	r12,r2[0x7c]

80007808 <create_chain>:
static
DWORD create_chain (	/* 0:No free cluster, 1:Internal error, 0xFFFFFFFF:Disk error, >=2:New cluster# */
	FATFS* fs,			/* File system object */
	DWORD clst			/* Cluster# to stretch, 0:Create a new chain */
)
{
80007808:	eb cd 40 fc 	pushm	r2-r7,lr
8000780c:	18 96       	mov	r6,r12
8000780e:	16 92       	mov	r2,r11
	DWORD cs, ncl, scl;
	FRESULT res;


	if (clst == 0) {		/* Create a new chain */
80007810:	58 0b       	cp.w	r11,0
80007812:	c0 81       	brne	80007822 <create_chain+0x1a>
		scl = fs->last_clust;			/* Get suggested start point */
80007814:	78 35       	ld.w	r5,r12[0xc]
		if (!scl || scl >= fs->n_fatent) scl = 1;
80007816:	58 05       	cp.w	r5,0
80007818:	c1 10       	breq	8000783a <create_chain+0x32>
8000781a:	78 58       	ld.w	r8,r12[0x14]
8000781c:	10 35       	cp.w	r5,r8
8000781e:	c0 e2       	brcc	8000783a <create_chain+0x32>
80007820:	c0 e8       	rjmp	8000783c <create_chain+0x34>
	}
	else {					/* Stretch the current chain */
		cs = get_fat(fs, clst);			/* Check the cluster status */
80007822:	f0 1f 00 2c 	mcall	800078d0 <create_chain+0xc8>
		if (cs < 2) return 1;			/* Invalid value */
80007826:	58 1c       	cp.w	r12,1
80007828:	e0 88 00 4f 	brls	800078c6 <create_chain+0xbe>
		if (cs == 0xFFFFFFFF) return cs;	/* A disk error occurred */
8000782c:	5b fc       	cp.w	r12,-1
8000782e:	c4 f0       	breq	800078cc <create_chain+0xc4>
		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
80007830:	6c 58       	ld.w	r8,r6[0x14]
80007832:	10 3c       	cp.w	r12,r8
80007834:	c4 c3       	brcs	800078cc <create_chain+0xc4>
80007836:	04 95       	mov	r5,r2
80007838:	c0 28       	rjmp	8000783c <create_chain+0x34>
8000783a:	30 15       	mov	r5,1
8000783c:	0a 97       	mov	r7,r5
	ncl = scl;				/* Start cluster */
	for (;;) {
		ncl++;							/* Next cluster */
		if (ncl >= fs->n_fatent) {		/* Check wrap around */
			ncl = 2;
			if (ncl > scl) return 0;	/* No free cluster */
8000783e:	30 23       	mov	r3,2
		}
		cs = get_fat(fs, ncl);			/* Get the cluster status */
		if (cs == 0) break;				/* Found a free cluster */
		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
80007840:	30 04       	mov	r4,0
		scl = clst;
	}

	ncl = scl;				/* Start cluster */
	for (;;) {
		ncl++;							/* Next cluster */
80007842:	2f f7       	sub	r7,-1
		if (ncl >= fs->n_fatent) {		/* Check wrap around */
80007844:	6c 58       	ld.w	r8,r6[0x14]
80007846:	10 37       	cp.w	r7,r8
80007848:	c0 53       	brcs	80007852 <create_chain+0x4a>
			ncl = 2;
			if (ncl > scl) return 0;	/* No free cluster */
8000784a:	58 15       	cp.w	r5,1
8000784c:	e0 88 00 3f 	brls	800078ca <create_chain+0xc2>
80007850:	06 97       	mov	r7,r3
		}
		cs = get_fat(fs, ncl);			/* Get the cluster status */
80007852:	0e 9b       	mov	r11,r7
80007854:	0c 9c       	mov	r12,r6
80007856:	f0 1f 00 1f 	mcall	800078d0 <create_chain+0xc8>
		if (cs == 0) break;				/* Found a free cluster */
8000785a:	c0 d0       	breq	80007874 <create_chain+0x6c>
		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
8000785c:	5b fc       	cp.w	r12,-1
8000785e:	5f 09       	sreq	r9
80007860:	58 1c       	cp.w	r12,1
80007862:	5f 08       	sreq	r8
80007864:	f3 e8 10 08 	or	r8,r9,r8
80007868:	e8 08 18 00 	cp.b	r8,r4
8000786c:	c3 01       	brne	800078cc <create_chain+0xc4>
			return cs;
		if (ncl == scl) return 0;		/* No free cluster */
8000786e:	0a 37       	cp.w	r7,r5
80007870:	ce 91       	brne	80007842 <create_chain+0x3a>
80007872:	c2 c8       	rjmp	800078ca <create_chain+0xc2>
80007874:	0e 95       	mov	r5,r7
	}

	res = put_fat(fs, ncl, 0x0FFFFFFF);	/* Mark the new cluster "last link" */
80007876:	e0 6a ff ff 	mov	r10,65535
8000787a:	ea 1a 0f ff 	orh	r10,0xfff
8000787e:	0e 9b       	mov	r11,r7
80007880:	0c 9c       	mov	r12,r6
80007882:	f0 1f 00 15 	mcall	800078d4 <create_chain+0xcc>
	if (res == FR_OK && clst != 0) {
80007886:	5f 09       	sreq	r9
80007888:	58 02       	cp.w	r2,0
8000788a:	5f 18       	srne	r8
8000788c:	f3 e8 00 08 	and	r8,r9,r8
80007890:	c0 60       	breq	8000789c <create_chain+0x94>
		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
80007892:	0e 9a       	mov	r10,r7
80007894:	04 9b       	mov	r11,r2
80007896:	0c 9c       	mov	r12,r6
80007898:	f0 1f 00 0f 	mcall	800078d4 <create_chain+0xcc>
	}
	if (res == FR_OK) {
8000789c:	58 0c       	cp.w	r12,0
8000789e:	c1 01       	brne	800078be <create_chain+0xb6>
		fs->last_clust = ncl;			/* Update FSINFO */
800078a0:	8d 35       	st.w	r6[0xc],r5
		if (fs->free_clust != 0xFFFFFFFF) {
800078a2:	6c 48       	ld.w	r8,r6[0x10]
800078a4:	5b f8       	cp.w	r8,-1
800078a6:	c0 41       	brne	800078ae <create_chain+0xa6>
800078a8:	0e 9c       	mov	r12,r7
800078aa:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
			fs->free_clust--;
800078ae:	20 18       	sub	r8,1
800078b0:	8d 48       	st.w	r6[0x10],r8
			fs->fsi_flag |= 1;
800078b2:	0d d8       	ld.ub	r8,r6[0x5]
800078b4:	a1 a8       	sbr	r8,0x0
800078b6:	ac d8       	st.b	r6[0x5],r8
800078b8:	0e 9c       	mov	r12,r7
800078ba:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
		}
	} else {
		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
800078be:	58 1c       	cp.w	r12,1
800078c0:	c0 31       	brne	800078c6 <create_chain+0xbe>
800078c2:	e3 cf c0 fc 	ldm	sp++,r2-r7,pc,r12=-1
800078c6:	e3 cf 90 fc 	ldm	sp++,r2-r7,pc,r12=1
800078ca:	30 0c       	mov	r12,0
	}

	return ncl;		/* Return new cluster number or error code */
}
800078cc:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800078d0:	80 00       	ld.sh	r0,r0[0x0]
800078d2:	76 70       	ld.w	r0,r11[0x1c]
800078d4:	80 00       	ld.sh	r0,r0[0x0]
800078d6:	75 3c       	ld.w	r12,r10[0x4c]

800078d8 <dir_next>:
static
FRESULT dir_next (	/* FR_OK(0):succeeded, FR_NO_FILE:End of table, FR_DENIED:Could not stretch */
	DIR* dp,		/* Pointer to the directory object */
	int stretch		/* 0: Do not stretch table, 1: Stretch table if needed */
)
{
800078d8:	eb cd 40 fc 	pushm	r2-r7,lr
800078dc:	18 97       	mov	r7,r12
800078de:	16 96       	mov	r6,r11
#if !_FS_READONLY
	UINT c;
#endif


	i = dp->index + 1;
800078e0:	98 b5       	ld.uh	r5,r12[0x6]
800078e2:	2f f5       	sub	r5,-1
	if (!(i & 0xFFFF) || !dp->sect)	/* Report EOT when index has reached 65535 */
800078e4:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
800078e8:	c6 d0       	breq	800079c2 <dir_next+0xea>
800078ea:	78 48       	ld.w	r8,r12[0x10]
800078ec:	58 08       	cp.w	r8,0
800078ee:	c6 a0       	breq	800079c2 <dir_next+0xea>
		return FR_NO_FILE;

	if (!(i % (SS(dp->fs) / SZ_DIRE))) {	/* Sector changed? */
800078f0:	e9 d5 c0 04 	bfextu	r4,r5,0x0,0x4
800078f4:	c5 e1       	brne	800079b0 <dir_next+0xd8>
		dp->sect++;					/* Next sector */
800078f6:	2f f8       	sub	r8,-1
800078f8:	99 48       	st.w	r12[0x10],r8

		if (!dp->clust) {		/* Static table */
800078fa:	78 3b       	ld.w	r11,r12[0xc]
800078fc:	58 0b       	cp.w	r11,0
800078fe:	c0 61       	brne	8000790a <dir_next+0x32>
			if (i >= dp->fs->n_rootdir)	/* Report EOT if it reached end of static table */
80007900:	78 08       	ld.w	r8,r12[0x0]
80007902:	90 c8       	ld.uh	r8,r8[0x8]
80007904:	10 35       	cp.w	r5,r8
80007906:	c5 53       	brcs	800079b0 <dir_next+0xd8>
80007908:	c5 d8       	rjmp	800079c2 <dir_next+0xea>
				return FR_NO_FILE;
		}
		else {					/* Dynamic table */
			if (((i / (SS(dp->fs) / SZ_DIRE)) & (dp->fs->csize - 1)) == 0) {	/* Cluster changed? */
8000790a:	78 0c       	ld.w	r12,r12[0x0]
8000790c:	19 a8       	ld.ub	r8,r12[0x2]
8000790e:	20 18       	sub	r8,1
80007910:	f1 e5 02 48 	and	r8,r8,r5>>0x4
80007914:	c4 e1       	brne	800079b0 <dir_next+0xd8>
				clst = get_fat(dp->fs, dp->clust);				/* Get next cluster */
80007916:	f0 1f 00 30 	mcall	800079d4 <dir_next+0xfc>
8000791a:	18 93       	mov	r3,r12
				if (clst <= 1) return FR_INT_ERR;
8000791c:	58 1c       	cp.w	r12,1
8000791e:	e0 88 00 55 	brls	800079c8 <dir_next+0xf0>
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
80007922:	5b fc       	cp.w	r12,-1
80007924:	c5 50       	breq	800079ce <dir_next+0xf6>
				if (clst >= dp->fs->n_fatent) {					/* If it reached end of dynamic table, */
80007926:	6e 0c       	ld.w	r12,r7[0x0]
80007928:	78 58       	ld.w	r8,r12[0x14]
8000792a:	10 33       	cp.w	r3,r8
8000792c:	c3 c3       	brcs	800079a4 <dir_next+0xcc>
#if !_FS_READONLY
					if (!stretch) return FR_NO_FILE;			/* If do not stretch, report EOT */
8000792e:	58 06       	cp.w	r6,0
80007930:	c4 90       	breq	800079c2 <dir_next+0xea>
					clst = create_chain(dp->fs, dp->clust);		/* Stretch cluster chain */
80007932:	6e 3b       	ld.w	r11,r7[0xc]
80007934:	f0 1f 00 29 	mcall	800079d8 <dir_next+0x100>
80007938:	18 93       	mov	r3,r12
					if (clst == 0) return FR_DENIED;			/* No free cluster */
8000793a:	c0 41       	brne	80007942 <dir_next+0x6a>
8000793c:	30 7c       	mov	r12,7
8000793e:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
					if (clst == 1) return FR_INT_ERR;
80007942:	58 1c       	cp.w	r12,1
80007944:	c4 20       	breq	800079c8 <dir_next+0xf0>
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
80007946:	5b fc       	cp.w	r12,-1
80007948:	c4 30       	breq	800079ce <dir_next+0xf6>
					/* Clean-up stretched table */
					if (sync_window(dp->fs)) return FR_DISK_ERR;/* Flush disk access window */
8000794a:	6e 0c       	ld.w	r12,r7[0x0]
8000794c:	f0 1f 00 24 	mcall	800079dc <dir_next+0x104>
80007950:	c3 f1       	brne	800079ce <dir_next+0xf6>
					mem_set(dp->fs->win, 0, SS(dp->fs));		/* Clear window buffer */
80007952:	6e 0c       	ld.w	r12,r7[0x0]
80007954:	e0 6a 02 00 	mov	r10,512
80007958:	30 0b       	mov	r11,0
8000795a:	2d 0c       	sub	r12,-48
8000795c:	f0 1f 00 21 	mcall	800079e0 <dir_next+0x108>
					dp->fs->winsect = clust2sect(dp->fs, clst);	/* Cluster start sector */
80007960:	6e 06       	ld.w	r6,r7[0x0]
80007962:	06 9b       	mov	r11,r3
80007964:	0c 9c       	mov	r12,r6
80007966:	f0 1f 00 20 	mcall	800079e4 <dir_next+0x10c>
8000796a:	8d bc       	st.w	r6[0x2c],r12
					for (c = 0; c < dp->fs->csize; c++) {		/* Fill the new cluster with 0 */
8000796c:	6e 08       	ld.w	r8,r7[0x0]
8000796e:	11 aa       	ld.ub	r10,r8[0x2]
80007970:	30 09       	mov	r9,0
80007972:	f2 0a 18 00 	cp.b	r10,r9
80007976:	c0 31       	brne	8000797c <dir_next+0xa4>
80007978:	30 06       	mov	r6,0
8000797a:	c1 28       	rjmp	8000799e <dir_next+0xc6>
8000797c:	30 06       	mov	r6,0
						dp->fs->wflag = 1;
8000797e:	30 12       	mov	r2,1
80007980:	b0 c2       	st.b	r8[0x4],r2
						if (sync_window(dp->fs)) return FR_DISK_ERR;
80007982:	6e 0c       	ld.w	r12,r7[0x0]
80007984:	f0 1f 00 16 	mcall	800079dc <dir_next+0x104>
80007988:	c2 31       	brne	800079ce <dir_next+0xf6>
						dp->fs->winsect++;
8000798a:	6e 08       	ld.w	r8,r7[0x0]
8000798c:	70 b9       	ld.w	r9,r8[0x2c]
8000798e:	2f f9       	sub	r9,-1
80007990:	91 b9       	st.w	r8[0x2c],r9
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
					/* Clean-up stretched table */
					if (sync_window(dp->fs)) return FR_DISK_ERR;/* Flush disk access window */
					mem_set(dp->fs->win, 0, SS(dp->fs));		/* Clear window buffer */
					dp->fs->winsect = clust2sect(dp->fs, clst);	/* Cluster start sector */
					for (c = 0; c < dp->fs->csize; c++) {		/* Fill the new cluster with 0 */
80007992:	2f f6       	sub	r6,-1
80007994:	6e 08       	ld.w	r8,r7[0x0]
80007996:	11 a9       	ld.ub	r9,r8[0x2]
80007998:	0c 39       	cp.w	r9,r6
8000799a:	fe 9b ff f3 	brhi	80007980 <dir_next+0xa8>
						dp->fs->wflag = 1;
						if (sync_window(dp->fs)) return FR_DISK_ERR;
						dp->fs->winsect++;
					}
					dp->fs->winsect -= c;						/* Rewind window offset */
8000799e:	70 b9       	ld.w	r9,r8[0x2c]
800079a0:	0c 19       	sub	r9,r6
800079a2:	91 b9       	st.w	r8[0x2c],r9
#else
					if (!stretch) return FR_NO_FILE;			/* If do not stretch, report EOT (this is to suppress warning) */
					return FR_NO_FILE;							/* Report EOT */
#endif
				}
				dp->clust = clst;				/* Initialize data for new cluster */
800079a4:	8f 33       	st.w	r7[0xc],r3
				dp->sect = clust2sect(dp->fs, clst);
800079a6:	06 9b       	mov	r11,r3
800079a8:	6e 0c       	ld.w	r12,r7[0x0]
800079aa:	f0 1f 00 0f 	mcall	800079e4 <dir_next+0x10c>
800079ae:	8f 4c       	st.w	r7[0x10],r12
			}
		}
	}

	dp->index = (WORD)i;	/* Current index */
800079b0:	ae 35       	st.h	r7[0x6],r5
	dp->dir = dp->fs->win + (i % (SS(dp->fs) / SZ_DIRE)) * SZ_DIRE;	/* Current entry in the window */
800079b2:	6e 08       	ld.w	r8,r7[0x0]
800079b4:	2d 08       	sub	r8,-48
800079b6:	a5 74       	lsl	r4,0x5
800079b8:	f0 04 00 04 	add	r4,r8,r4
800079bc:	8f 54       	st.w	r7[0x14],r4
800079be:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0

	return FR_OK;
800079c2:	30 4c       	mov	r12,4
800079c4:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800079c8:	30 2c       	mov	r12,2
800079ca:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800079ce:	e3 cf 90 fc 	ldm	sp++,r2-r7,pc,r12=1
800079d2:	00 00       	add	r0,r0
800079d4:	80 00       	ld.sh	r0,r0[0x0]
800079d6:	76 70       	ld.w	r0,r11[0x1c]
800079d8:	80 00       	ld.sh	r0,r0[0x0]
800079da:	78 08       	ld.w	r8,r12[0x0]
800079dc:	80 00       	ld.sh	r0,r0[0x0]
800079de:	67 50       	ld.w	r0,r3[0x54]
800079e0:	80 00       	ld.sh	r0,r0[0x0]
800079e2:	65 d6       	ld.w	r6,r2[0x74]
800079e4:	80 00       	ld.sh	r0,r0[0x0]
800079e6:	65 fc       	ld.w	r12,r2[0x7c]

800079e8 <remove_chain>:
static
FRESULT remove_chain (	/* FR_OK(0):succeeded, !=0:error */
	FATFS* fs,			/* File system object */
	DWORD clst			/* Cluster# to remove a chain from */
)
{
800079e8:	d4 21       	pushm	r4-r7,lr
800079ea:	18 97       	mov	r7,r12
800079ec:	16 95       	mov	r5,r11
	DWORD nxt;
#if _USE_TRIM
	DWORD scl = clst, ecl = clst, rt[2];
#endif

	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
800079ee:	58 1b       	cp.w	r11,1
800079f0:	e0 88 00 26 	brls	80007a3c <remove_chain+0x54>
800079f4:	78 58       	ld.w	r8,r12[0x14]
800079f6:	10 3b       	cp.w	r11,r8
800079f8:	c2 22       	brcc	80007a3c <remove_chain+0x54>
		while (clst < fs->n_fatent) {			/* Not a last link? */
			nxt = get_fat(fs, clst);			/* Get cluster status */
			if (nxt == 0) break;				/* Empty cluster? */
			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
800079fa:	30 04       	mov	r4,0
		res = FR_INT_ERR;

	} else {
		res = FR_OK;
		while (clst < fs->n_fatent) {			/* Not a last link? */
			nxt = get_fat(fs, clst);			/* Get cluster status */
800079fc:	0a 9b       	mov	r11,r5
800079fe:	0e 9c       	mov	r12,r7
80007a00:	f0 1f 00 10 	mcall	80007a40 <remove_chain+0x58>
80007a04:	18 96       	mov	r6,r12
			if (nxt == 0) break;				/* Empty cluster? */
80007a06:	c0 21       	brne	80007a0a <remove_chain+0x22>
80007a08:	d8 2a       	popm	r4-r7,pc,r12=0
			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
80007a0a:	58 1c       	cp.w	r12,1
80007a0c:	c1 80       	breq	80007a3c <remove_chain+0x54>
			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
80007a0e:	5b fc       	cp.w	r12,-1
80007a10:	c0 21       	brne	80007a14 <remove_chain+0x2c>
80007a12:	da 2a       	popm	r4-r7,pc,r12=1
			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
80007a14:	08 9a       	mov	r10,r4
80007a16:	0a 9b       	mov	r11,r5
80007a18:	0e 9c       	mov	r12,r7
80007a1a:	f0 1f 00 0b 	mcall	80007a44 <remove_chain+0x5c>
			if (res != FR_OK) break;
80007a1e:	c1 01       	brne	80007a3e <remove_chain+0x56>
			if (fs->free_clust != 0xFFFFFFFF) {	/* Update FSINFO */
80007a20:	6e 48       	ld.w	r8,r7[0x10]
80007a22:	5b f8       	cp.w	r8,-1
80007a24:	c0 60       	breq	80007a30 <remove_chain+0x48>
				fs->free_clust++;
80007a26:	2f f8       	sub	r8,-1
80007a28:	8f 48       	st.w	r7[0x10],r8
				fs->fsi_flag |= 1;
80007a2a:	0f d8       	ld.ub	r8,r7[0x5]
80007a2c:	a1 a8       	sbr	r8,0x0
80007a2e:	ae d8       	st.b	r7[0x5],r8
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
		res = FR_INT_ERR;

	} else {
		res = FR_OK;
		while (clst < fs->n_fatent) {			/* Not a last link? */
80007a30:	6e 58       	ld.w	r8,r7[0x14]
80007a32:	0c 38       	cp.w	r8,r6
80007a34:	e0 88 00 05 	brls	80007a3e <remove_chain+0x56>
80007a38:	0c 95       	mov	r5,r6
80007a3a:	ce 1b       	rjmp	800079fc <remove_chain+0x14>
80007a3c:	30 2c       	mov	r12,2
			clst = nxt;	/* Next cluster */
		}
	}

	return res;
}
80007a3e:	d8 22       	popm	r4-r7,pc
80007a40:	80 00       	ld.sh	r0,r0[0x0]
80007a42:	76 70       	ld.w	r0,r11[0x1c]
80007a44:	80 00       	ld.sh	r0,r0[0x0]
80007a46:	75 3c       	ld.w	r12,r10[0x4c]

80007a48 <dir_read>:
static
FRESULT dir_read (
	DIR* dp,		/* Pointer to the directory object */
	int vol			/* Filtered by 0:file/directory or 1:volume label */
)
{
80007a48:	eb cd 40 fe 	pushm	r1-r7,lr
80007a4c:	18 97       	mov	r7,r12
80007a4e:	16 91       	mov	r1,r11
80007a50:	30 4c       	mov	r12,4
					dp->lfn_idx = 0xFFFF;		/* It has no LFN. */
				break;
			}
		}
#else		/* Non LFN configuration */
		if (c != DDEM && (_FS_RPATH || c != '.') && a != AM_LFN && (int)((a & ~AM_ARC) == AM_VOL) == vol)	/* Is it a valid entry? */
80007a52:	3e 56       	mov	r6,-27
80007a54:	32 e5       	mov	r5,46
80007a56:	30 04       	mov	r4,0
80007a58:	30 f2       	mov	r2,15
			break;
#endif
		res = dir_next(dp, 0);				/* Next entry */
80007a5a:	30 03       	mov	r3,0
#if _USE_LFN
	BYTE ord = 0xFF, sum = 0xFF;
#endif

	res = FR_NO_FILE;
	while (dp->sect) {
80007a5c:	c2 58       	rjmp	80007aa6 <dir_read+0x5e>
		res = move_window(dp->fs, dp->sect);
80007a5e:	6e 0c       	ld.w	r12,r7[0x0]
80007a60:	f0 1f 00 17 	mcall	80007abc <dir_read+0x74>
		if (res != FR_OK) break;
80007a64:	c2 61       	brne	80007ab0 <dir_read+0x68>
		dir = dp->dir;					/* Ptr to the directory entry of current index */
80007a66:	6e 59       	ld.w	r9,r7[0x14]
		c = dir[DIR_Name];
80007a68:	13 88       	ld.ub	r8,r9[0x0]
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
80007a6a:	58 08       	cp.w	r8,0
80007a6c:	c2 60       	breq	80007ab8 <dir_read+0x70>
		a = dir[DIR_Attr] & AM_MASK;
80007a6e:	f3 3a 00 0b 	ld.ub	r10,r9[11]
					dp->lfn_idx = 0xFFFF;		/* It has no LFN. */
				break;
			}
		}
#else		/* Non LFN configuration */
		if (c != DDEM && (_FS_RPATH || c != '.') && a != AM_LFN && (int)((a & ~AM_ARC) == AM_VOL) == vol)	/* Is it a valid entry? */
80007a72:	ec 08 18 00 	cp.b	r8,r6
80007a76:	5f 19       	srne	r9
80007a78:	ea 08 18 00 	cp.b	r8,r5
80007a7c:	5f 18       	srne	r8
80007a7e:	f3 e8 00 08 	and	r8,r9,r8
80007a82:	e8 08 18 00 	cp.b	r8,r4
80007a86:	c0 b0       	breq	80007a9c <dir_read+0x54>
		res = move_window(dp->fs, dp->sect);
		if (res != FR_OK) break;
		dir = dp->dir;					/* Ptr to the directory entry of current index */
		c = dir[DIR_Name];
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
		a = dir[DIR_Attr] & AM_MASK;
80007a88:	f1 da c0 06 	bfextu	r8,r10,0x0,0x6
					dp->lfn_idx = 0xFFFF;		/* It has no LFN. */
				break;
			}
		}
#else		/* Non LFN configuration */
		if (c != DDEM && (_FS_RPATH || c != '.') && a != AM_LFN && (int)((a & ~AM_ARC) == AM_VOL) == vol)	/* Is it a valid entry? */
80007a8c:	e4 08 18 00 	cp.b	r8,r2
80007a90:	c0 60       	breq	80007a9c <dir_read+0x54>
80007a92:	a5 d8       	cbr	r8,0x5
80007a94:	58 88       	cp.w	r8,8
80007a96:	5f 08       	sreq	r8
80007a98:	02 38       	cp.w	r8,r1
80007a9a:	c0 d0       	breq	80007ab4 <dir_read+0x6c>
			break;
#endif
		res = dir_next(dp, 0);				/* Next entry */
80007a9c:	06 9b       	mov	r11,r3
80007a9e:	0e 9c       	mov	r12,r7
80007aa0:	f0 1f 00 08 	mcall	80007ac0 <dir_read+0x78>
		if (res != FR_OK) break;
80007aa4:	c0 61       	brne	80007ab0 <dir_read+0x68>
#if _USE_LFN
	BYTE ord = 0xFF, sum = 0xFF;
#endif

	res = FR_NO_FILE;
	while (dp->sect) {
80007aa6:	6e 4b       	ld.w	r11,r7[0x10]
80007aa8:	58 0b       	cp.w	r11,0
80007aaa:	cd a1       	brne	80007a5e <dir_read+0x16>
#endif
		res = dir_next(dp, 0);				/* Next entry */
		if (res != FR_OK) break;
	}

	if (res != FR_OK) dp->sect = 0;
80007aac:	58 0c       	cp.w	r12,0
80007aae:	c0 30       	breq	80007ab4 <dir_read+0x6c>
80007ab0:	30 08       	mov	r8,0
80007ab2:	8f 48       	st.w	r7[0x10],r8

	return res;
}
80007ab4:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
#endif
		res = dir_next(dp, 0);				/* Next entry */
		if (res != FR_OK) break;
	}

	if (res != FR_OK) dp->sect = 0;
80007ab8:	30 4c       	mov	r12,4
80007aba:	cf bb       	rjmp	80007ab0 <dir_read+0x68>
80007abc:	80 00       	ld.sh	r0,r0[0x0]
80007abe:	6f 48       	ld.w	r8,r7[0x50]
80007ac0:	80 00       	ld.sh	r0,r0[0x0]
80007ac2:	78 d8       	ld.w	r8,r12[0x34]

80007ac4 <f_getlabel>:
FRESULT f_getlabel (
	const TCHAR* path,	/* Path name of the logical drive number */
	TCHAR* label,		/* Pointer to a buffer to return the volume label */
	DWORD* vsn			/* Pointer to a variable to return the volume serial number */
)
{
80007ac4:	d4 21       	pushm	r4-r7,lr
80007ac6:	20 9d       	sub	sp,36
80007ac8:	50 0c       	stdsp	sp[0x0],r12
80007aca:	16 96       	mov	r6,r11
80007acc:	14 95       	mov	r5,r10
	WCHAR w;
#endif


	/* Get logical drive number */
	res = find_volume(&dj.fs, &path, 0);
80007ace:	30 0a       	mov	r10,0
80007ad0:	1a 9b       	mov	r11,sp
80007ad2:	fa cc ff fc 	sub	r12,sp,-4
80007ad6:	f0 1f 00 30 	mcall	80007b94 <f_getlabel+0xd0>
80007ada:	18 97       	mov	r7,r12

	/* Get volume label */
	if (res == FR_OK && label) {
80007adc:	5f 09       	sreq	r9
80007ade:	58 06       	cp.w	r6,0
80007ae0:	5f 18       	srne	r8
80007ae2:	f3 e8 00 08 	and	r8,r9,r8
80007ae6:	c2 d0       	breq	80007b40 <f_getlabel+0x7c>
		dj.sclust = 0;					/* Open root directory */
80007ae8:	30 0b       	mov	r11,0
80007aea:	50 3b       	stdsp	sp[0xc],r11
		res = dir_sdi(&dj, 0);
80007aec:	fa cc ff fc 	sub	r12,sp,-4
80007af0:	f0 1f 00 2a 	mcall	80007b98 <f_getlabel+0xd4>
80007af4:	18 97       	mov	r7,r12
		if (res == FR_OK) {
80007af6:	c4 c1       	brne	80007b8e <f_getlabel+0xca>
			res = dir_read(&dj, 1);		/* Get an entry with AM_VOL */
80007af8:	30 1b       	mov	r11,1
80007afa:	fa cc ff fc 	sub	r12,sp,-4
80007afe:	f0 1f 00 28 	mcall	80007b9c <f_getlabel+0xd8>
80007b02:	18 94       	mov	r4,r12
			if (res == FR_OK) {			/* A volume label is exist */
80007b04:	c1 81       	brne	80007b34 <f_getlabel+0x70>
					if (IsDBCS1(w) && i < 11 && IsDBCS2(dj.dir[i]))
						w = w << 8 | dj.dir[i++];
					label[j++] = ff_convert(w, 1);	/* OEM -> Unicode */
				} while (j < 11);
#else
				mem_cpy(label, dj.dir, 11);
80007b06:	30 ba       	mov	r10,11
80007b08:	40 6b       	lddsp	r11,sp[0x18]
80007b0a:	0c 9c       	mov	r12,r6
80007b0c:	f0 1f 00 25 	mcall	80007ba0 <f_getlabel+0xdc>
#endif
				j = 11;
				do {
					label[j] = 0;
80007b10:	30 08       	mov	r8,0
80007b12:	ed 68 00 0b 	st.b	r6[11],r8
80007b16:	2f 66       	sub	r6,-10
80007b18:	30 b8       	mov	r8,11
					if (!j) break;
				} while (label[--j] == ' ');
80007b1a:	32 0a       	mov	r10,32
#else
				mem_cpy(label, dj.dir, 11);
#endif
				j = 11;
				do {
					label[j] = 0;
80007b1c:	30 0b       	mov	r11,0
80007b1e:	c0 58       	rjmp	80007b28 <f_getlabel+0x64>
80007b20:	ac 8b       	st.b	r6[0x0],r11
80007b22:	20 16       	sub	r6,1
					if (!j) break;
80007b24:	58 08       	cp.w	r8,0
80007b26:	c0 c0       	breq	80007b3e <f_getlabel+0x7a>
				} while (label[--j] == ' ');
80007b28:	20 18       	sub	r8,1
80007b2a:	0d 89       	ld.ub	r9,r6[0x0]
80007b2c:	f4 09 18 00 	cp.b	r9,r10
80007b30:	cf 80       	breq	80007b20 <f_getlabel+0x5c>
80007b32:	c0 68       	rjmp	80007b3e <f_getlabel+0x7a>
			}
			if (res == FR_NO_FILE) {	/* No label, return nul string */
80007b34:	58 4c       	cp.w	r12,4
80007b36:	c0 41       	brne	80007b3e <f_getlabel+0x7a>
				label[0] = 0;
80007b38:	30 08       	mov	r8,0
80007b3a:	ac 88       	st.b	r6[0x0],r8
80007b3c:	c0 28       	rjmp	80007b40 <f_getlabel+0x7c>
80007b3e:	08 97       	mov	r7,r4
			}
		}
	}

	/* Get volume serial number */
	if (res == FR_OK && vsn) {
80007b40:	58 07       	cp.w	r7,0
80007b42:	5f 09       	sreq	r9
80007b44:	58 05       	cp.w	r5,0
80007b46:	5f 18       	srne	r8
80007b48:	f3 e8 00 08 	and	r8,r9,r8
80007b4c:	c2 10       	breq	80007b8e <f_getlabel+0xca>
		res = move_window(dj.fs, dj.fs->volbase);
80007b4e:	40 1c       	lddsp	r12,sp[0x4]
80007b50:	78 7b       	ld.w	r11,r12[0x1c]
80007b52:	f0 1f 00 15 	mcall	80007ba4 <f_getlabel+0xe0>
80007b56:	18 97       	mov	r7,r12
		if (res == FR_OK) {
80007b58:	c1 b1       	brne	80007b8e <f_getlabel+0xca>
			i = dj.fs->fs_type == FS_FAT32 ? BS_VolID32 : BS_VolID;
80007b5a:	40 19       	lddsp	r9,sp[0x4]
80007b5c:	13 8a       	ld.ub	r10,r9[0x0]
80007b5e:	30 38       	mov	r8,3
80007b60:	f0 0a 18 00 	cp.b	r10,r8
80007b64:	f9 b8 00 43 	moveq	r8,67
80007b68:	f9 b8 01 27 	movne	r8,39
			*vsn = LD_DWORD(&dj.fs->win[i]);
80007b6c:	f2 08 00 08 	add	r8,r9,r8
80007b70:	f1 3a 00 33 	ld.ub	r10,r8[51]
80007b74:	f1 39 00 32 	ld.ub	r9,r8[50]
80007b78:	b1 69       	lsl	r9,0x10
80007b7a:	f3 ea 11 89 	or	r9,r9,r10<<0x18
80007b7e:	f1 3a 00 30 	ld.ub	r10,r8[48]
80007b82:	14 49       	or	r9,r10
80007b84:	f1 38 00 31 	ld.ub	r8,r8[49]
80007b88:	f3 e8 10 88 	or	r8,r9,r8<<0x8
80007b8c:	8b 08       	st.w	r5[0x0],r8
		}
	}

	LEAVE_FF(dj.fs, res);
}
80007b8e:	0e 9c       	mov	r12,r7
80007b90:	2f 7d       	sub	sp,-36
80007b92:	d8 22       	popm	r4-r7,pc
80007b94:	80 00       	ld.sh	r0,r0[0x0]
80007b96:	70 24       	ld.w	r4,r8[0x8]
80007b98:	80 00       	ld.sh	r0,r0[0x0]
80007b9a:	77 54       	ld.w	r4,r11[0x54]
80007b9c:	80 00       	ld.sh	r0,r0[0x0]
80007b9e:	7a 48       	ld.w	r8,sp[0x10]
80007ba0:	80 00       	ld.sh	r0,r0[0x0]
80007ba2:	65 c0       	ld.w	r0,r2[0x70]
80007ba4:	80 00       	ld.sh	r0,r0[0x0]
80007ba6:	6f 48       	ld.w	r8,r7[0x50]

80007ba8 <dir_alloc>:
static
FRESULT dir_alloc (	/* FR_OK(0):succeeded, !=0:error */
	DIR* dp,		/* Pointer to the directory object */
	UINT nent		/* Number of contiguous entries to allocate (1-21) */
)
{
80007ba8:	eb cd 40 fe 	pushm	r1-r7,lr
80007bac:	18 97       	mov	r7,r12
80007bae:	16 92       	mov	r2,r11
	FRESULT res;
	UINT n;


	res = dir_sdi(dp, 0);
80007bb0:	30 0b       	mov	r11,0
80007bb2:	f0 1f 00 15 	mcall	80007c04 <dir_alloc+0x5c>
	if (res == FR_OK) {
80007bb6:	c2 21       	brne	80007bfa <dir_alloc+0x52>
80007bb8:	30 05       	mov	r5,0
		n = 0;
		do {
			res = move_window(dp->fs, dp->sect);
			if (res != FR_OK) break;
			if (dp->dir[0] == DDEM || dp->dir[0] == 0) {	/* Is it a free entry? */
80007bba:	3e 54       	mov	r4,-27
80007bbc:	30 06       	mov	r6,0
80007bbe:	0a 91       	mov	r1,r5
				if (++n == nent) break;	/* A block of contiguous free entries is found */
			} else {
				n = 0;					/* Not a blank entry. Restart to search */
			}
			res = dir_next(dp, 1);		/* Next entry with table stretch enabled */
80007bc0:	30 13       	mov	r3,1

	res = dir_sdi(dp, 0);
	if (res == FR_OK) {
		n = 0;
		do {
			res = move_window(dp->fs, dp->sect);
80007bc2:	6e 4b       	ld.w	r11,r7[0x10]
80007bc4:	6e 0c       	ld.w	r12,r7[0x0]
80007bc6:	f0 1f 00 11 	mcall	80007c08 <dir_alloc+0x60>
			if (res != FR_OK) break;
80007bca:	c1 81       	brne	80007bfa <dir_alloc+0x52>
			if (dp->dir[0] == DDEM || dp->dir[0] == 0) {	/* Is it a free entry? */
80007bcc:	6e 58       	ld.w	r8,r7[0x14]
80007bce:	11 88       	ld.ub	r8,r8[0x0]
80007bd0:	e8 08 18 00 	cp.b	r8,r4
80007bd4:	5f 09       	sreq	r9
80007bd6:	ec 08 18 00 	cp.b	r8,r6
80007bda:	5f 08       	sreq	r8
80007bdc:	f3 e8 10 08 	or	r8,r9,r8
80007be0:	ec 08 18 00 	cp.b	r8,r6
80007be4:	c0 31       	brne	80007bea <dir_alloc+0x42>
80007be6:	02 95       	mov	r5,r1
80007be8:	c0 48       	rjmp	80007bf0 <dir_alloc+0x48>
				if (++n == nent) break;	/* A block of contiguous free entries is found */
80007bea:	2f f5       	sub	r5,-1
80007bec:	04 35       	cp.w	r5,r2
80007bee:	c0 90       	breq	80007c00 <dir_alloc+0x58>
			} else {
				n = 0;					/* Not a blank entry. Restart to search */
			}
			res = dir_next(dp, 1);		/* Next entry with table stretch enabled */
80007bf0:	06 9b       	mov	r11,r3
80007bf2:	0e 9c       	mov	r12,r7
80007bf4:	f0 1f 00 06 	mcall	80007c0c <dir_alloc+0x64>
		} while (res == FR_OK);
80007bf8:	ce 50       	breq	80007bc2 <dir_alloc+0x1a>
	}
	if (res == FR_NO_FILE) res = FR_DENIED;	/* No directory entry to allocate */
80007bfa:	58 4c       	cp.w	r12,4
80007bfc:	f9 bc 00 07 	moveq	r12,7
	return res;
}
80007c00:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
80007c04:	80 00       	ld.sh	r0,r0[0x0]
80007c06:	77 54       	ld.w	r4,r11[0x54]
80007c08:	80 00       	ld.sh	r0,r0[0x0]
80007c0a:	6f 48       	ld.w	r8,r7[0x50]
80007c0c:	80 00       	ld.sh	r0,r0[0x0]
80007c0e:	78 d8       	ld.w	r8,r12[0x34]

80007c10 <f_setlabel>:
/*-----------------------------------------------------------------------*/

FRESULT f_setlabel (
	const TCHAR* label	/* Pointer to the volume label to set */
)
{
80007c10:	d4 31       	pushm	r0-r7,lr
80007c12:	20 cd       	sub	sp,48
80007c14:	50 0c       	stdsp	sp[0x0],r12
	WCHAR w;
	DWORD tm;


	/* Get logical drive number */
	res = find_volume(&dj.fs, &label, 1);
80007c16:	30 1a       	mov	r10,1
80007c18:	1a 9b       	mov	r11,sp
80007c1a:	fa cc ff f0 	sub	r12,sp,-16
80007c1e:	f0 1f 00 8b 	mcall	80007e48 <f_setlabel+0x238>
	if (res) LEAVE_FF(dj.fs, res);
80007c22:	e0 81 01 08 	brne	80007e32 <f_setlabel+0x222>

	/* Create a volume label in directory form */
	vn[0] = 0;
80007c26:	30 08       	mov	r8,0
80007c28:	ba c8       	st.b	sp[0x4],r8
	for (sl = 0; label[sl]; sl++) ;				/* Get name length */
80007c2a:	40 0a       	lddsp	r10,sp[0x0]
80007c2c:	15 89       	ld.ub	r9,r10[0x0]
80007c2e:	f0 09 18 00 	cp.b	r9,r8
80007c32:	e0 80 00 90 	breq	80007d52 <f_setlabel+0x142>
80007c36:	30 07       	mov	r7,0
80007c38:	2f f7       	sub	r7,-1
80007c3a:	f4 07 07 09 	ld.ub	r9,r10[r7]
80007c3e:	f0 09 18 00 	cp.b	r9,r8
80007c42:	cf b1       	brne	80007c38 <f_setlabel+0x28>
80007c44:	0e 98       	mov	r8,r7
	for ( ; sl && label[sl - 1] == ' '; sl--) ;	/* Remove trailing spaces */
80007c46:	58 07       	cp.w	r7,0
80007c48:	e0 80 00 85 	breq	80007d52 <f_setlabel+0x142>
80007c4c:	f4 07 00 09 	add	r9,r10,r7
80007c50:	f3 3b ff ff 	ld.ub	r11,r9[-1]
80007c54:	32 09       	mov	r9,32
80007c56:	f2 0b 18 00 	cp.b	r11,r9
80007c5a:	e0 81 00 ee 	brne	80007e36 <f_setlabel+0x226>
80007c5e:	20 28       	sub	r8,2
80007c60:	f4 08 00 08 	add	r8,r10,r8
80007c64:	12 9a       	mov	r10,r9
80007c66:	20 17       	sub	r7,1
80007c68:	c7 50       	breq	80007d52 <f_setlabel+0x142>
80007c6a:	11 89       	ld.ub	r9,r8[0x0]
80007c6c:	20 18       	sub	r8,1
80007c6e:	f4 09 18 00 	cp.b	r9,r10
80007c72:	cf a0       	breq	80007c66 <f_setlabel+0x56>
80007c74:	ce 18       	rjmp	80007e36 <f_setlabel+0x226>
		i = j = 0;
		do {
#if _USE_LFN && _LFN_UNICODE
			w = ff_convert(ff_wtoupper(label[i++]), 0);
#else
			w = (BYTE)label[i++];
80007c76:	40 08       	lddsp	r8,sp[0x0]
80007c78:	f0 04 07 06 	ld.ub	r6,r8[r4]
80007c7c:	2f f4       	sub	r4,-1
			if (IsDBCS1(w))
80007c7e:	ec c9 ff 81 	sub	r9,r6,-127
80007c82:	e4 09 18 00 	cp.b	r9,r2
80007c86:	e0 8b 00 24 	brhi	80007cce <f_setlabel+0xbe>
				w = (j < 10 && i < sl && IsDBCS2(label[i])) ? w << 8 | (BYTE)label[i++] : 0;
80007c8a:	58 95       	cp.w	r5,9
80007c8c:	5f 8a       	srls	r10
80007c8e:	0e 34       	cp.w	r4,r7
80007c90:	5f 39       	srlo	r9
80007c92:	f5 e9 00 09 	and	r9,r10,r9
80007c96:	e2 09 18 00 	cp.b	r9,r1
80007c9a:	e0 80 00 c9 	breq	80007e2c <f_setlabel+0x21c>
80007c9e:	f0 04 07 08 	ld.ub	r8,r8[r4]
80007ca2:	f0 c9 00 40 	sub	r9,r8,64
80007ca6:	33 eb       	mov	r11,62
80007ca8:	f6 09 18 00 	cp.b	r9,r11
80007cac:	5f 8a       	srls	r10
80007cae:	f0 c9 00 80 	sub	r9,r8,128
80007cb2:	37 eb       	mov	r11,126
80007cb4:	f6 09 18 00 	cp.b	r9,r11
80007cb8:	5f 89       	srls	r9
80007cba:	f5 e9 10 09 	or	r9,r10,r9
80007cbe:	e2 09 18 00 	cp.b	r9,r1
80007cc2:	e0 80 00 b5 	breq	80007e2c <f_setlabel+0x21c>
80007cc6:	f1 e6 10 86 	or	r6,r8,r6<<0x8
80007cca:	5c 86       	casts.h	r6
80007ccc:	2f f4       	sub	r4,-1
#if _USE_LFN
			w = ff_convert(ff_wtoupper(ff_convert(w, 1)), 0);
#else
			if (IsLower(w)) w -= 0x20;			/* To upper ASCII characters */
80007cce:	ec c8 00 61 	sub	r8,r6,97
80007cd2:	31 9a       	mov	r10,25
80007cd4:	f4 08 19 00 	cp.h	r8,r10
80007cd8:	e0 8b 00 04 	brhi	80007ce0 <f_setlabel+0xd0>
80007cdc:	22 06       	sub	r6,32
80007cde:	5c 86       	casts.h	r6
#else
			if (!_DF1S && w >= 0x80) w = 0;		/* Reject extended characters (ASCII cfg) */
#endif
#endif
#endif
			if (!w || chk_chr("\"*+,.:;<=>\?[]|\x7F", w) || j >= (UINT)((w >= 0x100) ? 10 : 11)) /* Reject invalid characters for volume label */
80007ce0:	58 06       	cp.w	r6,0
80007ce2:	e0 80 00 a5 	breq	80007e2c <f_setlabel+0x21c>
80007ce6:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
80007cea:	00 9c       	mov	r12,r0
80007cec:	f0 1f 00 58 	mcall	80007e4c <f_setlabel+0x23c>
80007cf0:	e0 81 00 9e 	brne	80007e2c <f_setlabel+0x21c>
80007cf4:	ec 03 19 00 	cp.h	r3,r6
80007cf8:	f9 b8 03 0a 	movlo	r8,10
80007cfc:	f9 b8 02 0b 	movhs	r8,11
80007d00:	10 35       	cp.w	r5,r8
80007d02:	e0 82 00 95 	brhs	80007e2c <f_setlabel+0x21c>
				LEAVE_FF(dj.fs, FR_INVALID_NAME);
			if (w >= 0x100) vn[j++] = (BYTE)(w >> 8);
80007d06:	e6 06 19 00 	cp.h	r6,r3
80007d0a:	e0 88 00 0a 	brls	80007d1e <f_setlabel+0x10e>
80007d0e:	fa c8 ff d0 	sub	r8,sp,-48
80007d12:	0a 08       	add	r8,r5
80007d14:	f3 d6 c1 08 	bfextu	r9,r6,0x8,0x8
80007d18:	f1 69 ff d4 	st.b	r8[-44],r9
80007d1c:	2f f5       	sub	r5,-1
			vn[j++] = (BYTE)w;
80007d1e:	fa c8 ff d0 	sub	r8,sp,-48
80007d22:	0a 08       	add	r8,r5
80007d24:	f1 66 ff d4 	st.b	r8[-44],r6
80007d28:	2f f5       	sub	r5,-1
		} while (i < sl);
80007d2a:	0e 34       	cp.w	r4,r7
80007d2c:	ca 53       	brcs	80007c76 <f_setlabel+0x66>
		while (j < 11) vn[j++] = ' ';	/* Fill remaining name field */
80007d2e:	58 a5       	cp.w	r5,10
80007d30:	e0 8b 00 0c 	brhi	80007d48 <f_setlabel+0x138>
80007d34:	fa c9 ff fc 	sub	r9,sp,-4
80007d38:	f2 05 00 08 	add	r8,r9,r5
80007d3c:	32 09       	mov	r9,32
80007d3e:	10 c9       	st.b	r8++,r9
80007d40:	2f f5       	sub	r5,-1
80007d42:	58 a5       	cp.w	r5,10
80007d44:	fe 98 ff fd 	brls	80007d3e <f_setlabel+0x12e>
		if (vn[0] == DDEM) LEAVE_FF(dj.fs, FR_INVALID_NAME);	/* Reject illegal name (heading DDEM) */
80007d48:	3e 58       	mov	r8,-27
80007d4a:	1b c9       	ld.ub	r9,sp[0x4]
80007d4c:	f0 09 18 00 	cp.b	r9,r8
80007d50:	c6 e0       	breq	80007e2c <f_setlabel+0x21c>
	}

	/* Set volume label */
	dj.sclust = 0;					/* Open root directory */
80007d52:	30 0b       	mov	r11,0
80007d54:	50 6b       	stdsp	sp[0x18],r11
	res = dir_sdi(&dj, 0);
80007d56:	fa cc ff f0 	sub	r12,sp,-16
80007d5a:	f0 1f 00 3e 	mcall	80007e50 <f_setlabel+0x240>
80007d5e:	18 97       	mov	r7,r12
	if (res == FR_OK) {
80007d60:	c6 81       	brne	80007e30 <f_setlabel+0x220>
		res = dir_read(&dj, 1);		/* Get an entry with AM_VOL */
80007d62:	30 1b       	mov	r11,1
80007d64:	fa cc ff f0 	sub	r12,sp,-16
80007d68:	f0 1f 00 3b 	mcall	80007e54 <f_setlabel+0x244>
		if (res == FR_OK) {			/* A volume label is found */
80007d6c:	c2 a1       	brne	80007dc0 <f_setlabel+0x1b0>
			if (vn[0]) {
80007d6e:	30 08       	mov	r8,0
80007d70:	1b c9       	ld.ub	r9,sp[0x4]
80007d72:	f0 09 18 00 	cp.b	r9,r8
80007d76:	c1 b0       	breq	80007dac <f_setlabel+0x19c>
				mem_cpy(dj.dir, vn, 11);	/* Change the volume label name */
80007d78:	30 ba       	mov	r10,11
80007d7a:	fa cb ff fc 	sub	r11,sp,-4
80007d7e:	40 9c       	lddsp	r12,sp[0x24]
80007d80:	f0 1f 00 36 	mcall	80007e58 <f_setlabel+0x248>
				tm = GET_FATTIME();
80007d84:	f0 1f 00 36 	mcall	80007e5c <f_setlabel+0x24c>
				ST_DWORD(dj.dir + DIR_WrtTime, tm);
80007d88:	40 98       	lddsp	r8,sp[0x24]
80007d8a:	f1 6c 00 16 	st.b	r8[22],r12
80007d8e:	f3 dc c1 08 	bfextu	r9,r12,0x8,0x8
80007d92:	40 98       	lddsp	r8,sp[0x24]
80007d94:	f1 69 00 17 	st.b	r8[23],r9
80007d98:	f8 09 16 10 	lsr	r9,r12,0x10
80007d9c:	40 98       	lddsp	r8,sp[0x24]
80007d9e:	f1 69 00 18 	st.b	r8[24],r9
80007da2:	b9 8c       	lsr	r12,0x18
80007da4:	40 98       	lddsp	r8,sp[0x24]
80007da6:	f1 6c 00 19 	st.b	r8[25],r12
80007daa:	c0 48       	rjmp	80007db2 <f_setlabel+0x1a2>
			} else {
				dj.dir[0] = DDEM;			/* Remove the volume label */
80007dac:	3e 59       	mov	r9,-27
80007dae:	40 98       	lddsp	r8,sp[0x24]
80007db0:	b0 89       	st.b	r8[0x0],r9
			}
			dj.fs->wflag = 1;
80007db2:	30 19       	mov	r9,1
80007db4:	40 48       	lddsp	r8,sp[0x10]
80007db6:	b0 c9       	st.b	r8[0x4],r9
			res = sync_fs(dj.fs);
80007db8:	40 4c       	lddsp	r12,sp[0x10]
80007dba:	f0 1f 00 2a 	mcall	80007e60 <f_setlabel+0x250>
80007dbe:	c3 a8       	rjmp	80007e32 <f_setlabel+0x222>
		} else {					/* No volume label is found or error */
			if (res == FR_NO_FILE) {
80007dc0:	58 4c       	cp.w	r12,4
80007dc2:	c3 81       	brne	80007e32 <f_setlabel+0x222>
				res = FR_OK;
				if (vn[0]) {				/* Create volume label as new */
80007dc4:	30 08       	mov	r8,0
80007dc6:	1b c9       	ld.ub	r9,sp[0x4]
80007dc8:	f0 09 18 00 	cp.b	r9,r8
80007dcc:	c3 20       	breq	80007e30 <f_setlabel+0x220>
					res = dir_alloc(&dj, 1);	/* Allocate an entry for volume label */
80007dce:	30 1b       	mov	r11,1
80007dd0:	fa cc ff f0 	sub	r12,sp,-16
80007dd4:	f0 1f 00 24 	mcall	80007e64 <f_setlabel+0x254>
					if (res == FR_OK) {
80007dd8:	c2 d1       	brne	80007e32 <f_setlabel+0x222>
						mem_set(dj.dir, 0, SZ_DIRE);	/* Set volume label */
80007dda:	32 0a       	mov	r10,32
80007ddc:	30 0b       	mov	r11,0
80007dde:	40 9c       	lddsp	r12,sp[0x24]
80007de0:	f0 1f 00 22 	mcall	80007e68 <f_setlabel+0x258>
						mem_cpy(dj.dir, vn, 11);
80007de4:	30 ba       	mov	r10,11
80007de6:	fa cb ff fc 	sub	r11,sp,-4
80007dea:	40 9c       	lddsp	r12,sp[0x24]
80007dec:	f0 1f 00 1b 	mcall	80007e58 <f_setlabel+0x248>
						dj.dir[DIR_Attr] = AM_VOL;
80007df0:	30 89       	mov	r9,8
80007df2:	40 98       	lddsp	r8,sp[0x24]
80007df4:	f1 69 00 0b 	st.b	r8[11],r9
						tm = GET_FATTIME();
80007df8:	f0 1f 00 19 	mcall	80007e5c <f_setlabel+0x24c>
						ST_DWORD(dj.dir + DIR_WrtTime, tm);
80007dfc:	40 98       	lddsp	r8,sp[0x24]
80007dfe:	f1 6c 00 16 	st.b	r8[22],r12
80007e02:	f3 dc c1 08 	bfextu	r9,r12,0x8,0x8
80007e06:	40 98       	lddsp	r8,sp[0x24]
80007e08:	f1 69 00 17 	st.b	r8[23],r9
80007e0c:	f8 09 16 10 	lsr	r9,r12,0x10
80007e10:	40 98       	lddsp	r8,sp[0x24]
80007e12:	f1 69 00 18 	st.b	r8[24],r9
80007e16:	b9 8c       	lsr	r12,0x18
80007e18:	40 98       	lddsp	r8,sp[0x24]
80007e1a:	f1 6c 00 19 	st.b	r8[25],r12
						dj.fs->wflag = 1;
80007e1e:	30 19       	mov	r9,1
80007e20:	40 48       	lddsp	r8,sp[0x10]
80007e22:	b0 c9       	st.b	r8[0x4],r9
						res = sync_fs(dj.fs);
80007e24:	40 4c       	lddsp	r12,sp[0x10]
80007e26:	f0 1f 00 0f 	mcall	80007e60 <f_setlabel+0x250>
80007e2a:	c0 48       	rjmp	80007e32 <f_setlabel+0x222>
80007e2c:	30 6c       	mov	r12,6
80007e2e:	c0 28       	rjmp	80007e32 <f_setlabel+0x222>
80007e30:	0e 9c       	mov	r12,r7
			}
		}
	}

	LEAVE_FF(dj.fs, res);
}
80007e32:	2f 4d       	sub	sp,-48
80007e34:	d8 32       	popm	r0-r7,pc
						mem_cpy(dj.dir, vn, 11);
						dj.dir[DIR_Attr] = AM_VOL;
						tm = GET_FATTIME();
						ST_DWORD(dj.dir + DIR_WrtTime, tm);
						dj.fs->wflag = 1;
						res = sync_fs(dj.fs);
80007e36:	30 05       	mov	r5,0
80007e38:	0a 94       	mov	r4,r5
		do {
#if _USE_LFN && _LFN_UNICODE
			w = ff_convert(ff_wtoupper(label[i++]), 0);
#else
			w = (BYTE)label[i++];
			if (IsDBCS1(w))
80007e3a:	37 d2       	mov	r2,125
				w = (j < 10 && i < sl && IsDBCS2(label[i])) ? w << 8 | (BYTE)label[i++] : 0;
80007e3c:	30 01       	mov	r1,0
#else
			if (!_DF1S && w >= 0x80) w = 0;		/* Reject extended characters (ASCII cfg) */
#endif
#endif
#endif
			if (!w || chk_chr("\"*+,.:;<=>\?[]|\x7F", w) || j >= (UINT)((w >= 0x100) ? 10 : 11)) /* Reject invalid characters for volume label */
80007e3e:	48 c0       	lddpc	r0,80007e6c <f_setlabel+0x25c>
80007e40:	e0 63 00 ff 	mov	r3,255
80007e44:	c1 9b       	rjmp	80007c76 <f_setlabel+0x66>
80007e46:	00 00       	add	r0,r0
80007e48:	80 00       	ld.sh	r0,r0[0x0]
80007e4a:	70 24       	ld.w	r4,r8[0x8]
80007e4c:	80 00       	ld.sh	r0,r0[0x0]
80007e4e:	65 e2       	ld.w	r2,r2[0x78]
80007e50:	80 00       	ld.sh	r0,r0[0x0]
80007e52:	77 54       	ld.w	r4,r11[0x54]
80007e54:	80 00       	ld.sh	r0,r0[0x0]
80007e56:	7a 48       	ld.w	r8,sp[0x10]
80007e58:	80 00       	ld.sh	r0,r0[0x0]
80007e5a:	65 c0       	ld.w	r0,r2[0x70]
80007e5c:	80 00       	ld.sh	r0,r0[0x0]
80007e5e:	64 fc       	ld.w	r12,r2[0x3c]
80007e60:	80 00       	ld.sh	r0,r0[0x0]
80007e62:	67 b4       	ld.w	r4,r3[0x6c]
80007e64:	80 00       	ld.sh	r0,r0[0x0]
80007e66:	7b a8       	ld.w	r8,sp[0x68]
80007e68:	80 00       	ld.sh	r0,r0[0x0]
80007e6a:	65 d6       	ld.w	r6,r2[0x74]
80007e6c:	80 01       	ld.sh	r1,r0[0x0]
80007e6e:	8f d0       	st.w	r7[0x34],r0

80007e70 <dir_register>:
#if !_FS_READONLY
static
FRESULT dir_register (	/* FR_OK:succeeded, FR_DENIED:no free entry or too many SFN collision, FR_DISK_ERR:disk error */
	DIR* dp				/* Target directory with object name to be created */
)
{
80007e70:	eb cd 40 c0 	pushm	r6-r7,lr
80007e74:	18 96       	mov	r6,r12
				res = dir_next(dp, 0);	/* Next entry */
			} while (res == FR_OK && --nent);
		}
	}
#else	/* Non LFN configuration */
	res = dir_alloc(dp, 1);		/* Allocate an entry for SFN */
80007e76:	30 1b       	mov	r11,1
80007e78:	f0 1f 00 0d 	mcall	80007eac <dir_register+0x3c>
80007e7c:	18 97       	mov	r7,r12
#endif

	if (res == FR_OK) {				/* Set SFN entry */
80007e7e:	c1 41       	brne	80007ea6 <dir_register+0x36>
		res = move_window(dp->fs, dp->sect);
80007e80:	6c 4b       	ld.w	r11,r6[0x10]
80007e82:	6c 0c       	ld.w	r12,r6[0x0]
80007e84:	f0 1f 00 0b 	mcall	80007eb0 <dir_register+0x40>
80007e88:	18 97       	mov	r7,r12
		if (res == FR_OK) {
80007e8a:	c0 e1       	brne	80007ea6 <dir_register+0x36>
			mem_set(dp->dir, 0, SZ_DIRE);	/* Clean the entry */
80007e8c:	32 0a       	mov	r10,32
80007e8e:	30 0b       	mov	r11,0
80007e90:	6c 5c       	ld.w	r12,r6[0x14]
80007e92:	f0 1f 00 09 	mcall	80007eb4 <dir_register+0x44>
			mem_cpy(dp->dir, dp->fn, 11);	/* Put SFN */
80007e96:	30 ba       	mov	r10,11
80007e98:	6c 6b       	ld.w	r11,r6[0x18]
80007e9a:	6c 5c       	ld.w	r12,r6[0x14]
80007e9c:	f0 1f 00 07 	mcall	80007eb8 <dir_register+0x48>
#if _USE_LFN
			dp->dir[DIR_NTres] = dp->fn[NSFLAG] & (NS_BODY | NS_EXT);	/* Put NT flag */
#endif
			dp->fs->wflag = 1;
80007ea0:	6c 08       	ld.w	r8,r6[0x0]
80007ea2:	30 19       	mov	r9,1
80007ea4:	b0 c9       	st.b	r8[0x4],r9
		}
	}

	return res;
}
80007ea6:	0e 9c       	mov	r12,r7
80007ea8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80007eac:	80 00       	ld.sh	r0,r0[0x0]
80007eae:	7b a8       	ld.w	r8,sp[0x68]
80007eb0:	80 00       	ld.sh	r0,r0[0x0]
80007eb2:	6f 48       	ld.w	r8,r7[0x50]
80007eb4:	80 00       	ld.sh	r0,r0[0x0]
80007eb6:	65 d6       	ld.w	r6,r2[0x74]
80007eb8:	80 00       	ld.sh	r0,r0[0x0]
80007eba:	65 c0       	ld.w	r0,r2[0x70]

80007ebc <follow_path>:
static
FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
	DIR* dp,			/* Directory object to return last directory and found object */
	const TCHAR* path	/* Full-path string to find a file or directory */
)
{
80007ebc:	d4 31       	pushm	r0-r7,lr
80007ebe:	20 3d       	sub	sp,12
80007ec0:	18 92       	mov	r2,r12
80007ec2:	16 97       	mov	r7,r11
		path++;	dp->sclust = 0;				/* Strip it and start from the root directory */
	} else {								/* No heading separator */
		dp->sclust = dp->fs->cdir;			/* Start from the current directory */
	}
#else
	if (*path == '/' || *path == '\\')		/* Strip heading separator if exist */
80007ec4:	17 88       	ld.ub	r8,r11[0x0]
80007ec6:	32 f9       	mov	r9,47
80007ec8:	f2 08 18 00 	cp.b	r8,r9
80007ecc:	5f 09       	sreq	r9
80007ece:	35 ca       	mov	r10,92
80007ed0:	f4 08 18 00 	cp.b	r8,r10
80007ed4:	5f 08       	sreq	r8
80007ed6:	f3 e8 10 08 	or	r8,r9,r8
		path++;
80007eda:	f7 b7 01 ff 	subne	r7,-1
	dp->sclust = 0;							/* Always start from the root directory */
80007ede:	30 08       	mov	r8,0
80007ee0:	99 28       	st.w	r12[0x8],r8
#endif

	if ((UINT)*path < ' ') {				/* Null path name is the origin directory itself */
80007ee2:	0f 89       	ld.ub	r9,r7[0x0]
80007ee4:	31 f8       	mov	r8,31
80007ee6:	f0 09 18 00 	cp.b	r9,r8
80007eea:	e0 8b 00 08 	brhi	80007efa <follow_path+0x3e>
		res = dir_sdi(dp, 0);
80007eee:	30 0b       	mov	r11,0
80007ef0:	f0 1f 00 93 	mcall	8000813c <follow_path+0x280>
		dp->dir = 0;
80007ef4:	30 08       	mov	r8,0
80007ef6:	85 58       	st.w	r2[0x14],r8
80007ef8:	c1 49       	rjmp	80008120 <follow_path+0x264>
	BYTE b, c, d, *sfn;
	UINT ni, si, i;
	const char *p;

	/* Create file name in directory form */
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Skip duplicated separator */
80007efa:	32 f4       	mov	r4,47
80007efc:	35 c3       	mov	r3,92
80007efe:	30 06       	mov	r6,0
80007f00:	0f 88       	ld.ub	r8,r7[0x0]
80007f02:	e8 08 18 00 	cp.b	r8,r4
80007f06:	5f 09       	sreq	r9
80007f08:	e6 08 18 00 	cp.b	r8,r3
80007f0c:	5f 08       	sreq	r8
80007f0e:	f3 e8 10 08 	or	r8,r9,r8
80007f12:	ec 08 18 00 	cp.b	r8,r6
80007f16:	c0 e0       	breq	80007f32 <follow_path+0x76>
80007f18:	2f f7       	sub	r7,-1
80007f1a:	0f 88       	ld.ub	r8,r7[0x0]
80007f1c:	e8 08 18 00 	cp.b	r8,r4
80007f20:	5f 09       	sreq	r9
80007f22:	e6 08 18 00 	cp.b	r8,r3
80007f26:	5f 08       	sreq	r8
80007f28:	f3 e8 10 08 	or	r8,r9,r8
80007f2c:	ec 08 18 00 	cp.b	r8,r6
80007f30:	cf 41       	brne	80007f18 <follow_path+0x5c>
	sfn = dp->fn;
80007f32:	64 6a       	ld.w	r10,r2[0x18]
80007f34:	50 2a       	stdsp	sp[0x8],r10
	mem_set(sfn, ' ', 11);
80007f36:	30 ba       	mov	r10,11
80007f38:	32 0b       	mov	r11,32
80007f3a:	40 2c       	lddsp	r12,sp[0x8]
80007f3c:	f0 1f 00 81 	mcall	80008140 <follow_path+0x284>
80007f40:	30 89       	mov	r9,8
80007f42:	50 09       	stdsp	sp[0x0],r9
80007f44:	30 08       	mov	r8,0
80007f46:	50 18       	stdsp	sp[0x4],r8
80007f48:	10 90       	mov	r0,r8
80007f4a:	10 91       	mov	r1,r8
#endif
#endif
		}
		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false at SBCS cfg.) */
			d = (BYTE)p[si++];			/* Get 2nd byte */
			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
80007f4c:	0e 95       	mov	r5,r7
		sfn[NSFLAG] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
		return FR_OK;
	}
#endif
	for (;;) {
		c = (BYTE)p[si++];
80007f4e:	ea 01 07 07 	ld.ub	r7,r5[r1]
80007f52:	2f f1       	sub	r1,-1
		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
80007f54:	32 09       	mov	r9,32
80007f56:	f2 07 18 00 	cp.b	r7,r9
80007f5a:	5f 88       	srls	r8
80007f5c:	e8 07 18 00 	cp.b	r7,r4
80007f60:	5f 09       	sreq	r9
80007f62:	f1 e9 10 09 	or	r9,r8,r9
80007f66:	ec 09 18 00 	cp.b	r9,r6
80007f6a:	c7 51       	brne	80008054 <follow_path+0x198>
80007f6c:	e6 07 18 00 	cp.b	r7,r3
80007f70:	c7 20       	breq	80008054 <follow_path+0x198>
		if (c == '.' || i >= ni) {
80007f72:	32 e8       	mov	r8,46
80007f74:	f0 07 18 00 	cp.b	r7,r8
80007f78:	5f 09       	sreq	r9
80007f7a:	40 0a       	lddsp	r10,sp[0x0]
80007f7c:	14 30       	cp.w	r0,r10
80007f7e:	5f 28       	srhs	r8
80007f80:	f3 e8 10 08 	or	r8,r9,r8
80007f84:	ec 08 18 00 	cp.b	r8,r6
80007f88:	c1 50       	breq	80007fb2 <follow_path+0xf6>
			if (ni != 8 || c != '.') return FR_INVALID_NAME;
80007f8a:	58 8a       	cp.w	r10,8
80007f8c:	5f 19       	srne	r9
80007f8e:	32 e8       	mov	r8,46
80007f90:	f0 07 18 00 	cp.b	r7,r8
80007f94:	5f 18       	srne	r8
80007f96:	f3 e8 10 08 	or	r8,r9,r8
80007f9a:	ec 08 18 00 	cp.b	r8,r6
80007f9e:	e0 81 00 be 	brne	8000811a <follow_path+0x25e>
			i = 8; ni = 11;
			b <<= 2; continue;
80007fa2:	40 18       	lddsp	r8,sp[0x4]
80007fa4:	a3 68       	lsl	r8,0x2
80007fa6:	5c 58       	castu.b	r8
80007fa8:	50 18       	stdsp	sp[0x4],r8
80007faa:	30 ba       	mov	r10,11
80007fac:	50 0a       	stdsp	sp[0x0],r10
80007fae:	30 80       	mov	r0,8
80007fb0:	cc fb       	rjmp	80007f4e <follow_path+0x92>
		}
		if (c >= 0x80) {				/* Extended character? */
80007fb2:	ec 07 18 00 	cp.b	r7,r6
80007fb6:	c0 54       	brge	80007fc0 <follow_path+0x104>
			b |= 3;						/* Eliminate NT flag */
80007fb8:	40 18       	lddsp	r8,sp[0x4]
80007fba:	e8 18 00 03 	orl	r8,0x3
80007fbe:	50 18       	stdsp	sp[0x4],r8
#if !_DF1S
			return FR_INVALID_NAME;		/* Reject extended characters (ASCII cfg) */
#endif
#endif
		}
		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false at SBCS cfg.) */
80007fc0:	0e 98       	mov	r8,r7
80007fc2:	28 18       	sub	r8,-127
80007fc4:	37 da       	mov	r10,125
80007fc6:	f4 08 18 00 	cp.b	r8,r10
80007fca:	e0 8b 00 23 	brhi	80008010 <follow_path+0x154>
			d = (BYTE)p[si++];			/* Get 2nd byte */
80007fce:	ea 01 07 08 	ld.ub	r8,r5[r1]
			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
80007fd2:	f0 c9 00 40 	sub	r9,r8,64
80007fd6:	33 ea       	mov	r10,62
80007fd8:	f4 09 18 00 	cp.b	r9,r10
80007fdc:	5f b9       	srhi	r9
80007fde:	f0 cb 00 80 	sub	r11,r8,128
80007fe2:	37 ea       	mov	r10,126
80007fe4:	f4 0b 18 00 	cp.b	r11,r10
80007fe8:	5f ba       	srhi	r10
80007fea:	14 69       	and	r9,r10
80007fec:	ec 09 18 00 	cp.b	r9,r6
80007ff0:	e0 81 00 95 	brne	8000811a <follow_path+0x25e>
80007ff4:	40 09       	lddsp	r9,sp[0x0]
80007ff6:	20 19       	sub	r9,1
80007ff8:	12 30       	cp.w	r0,r9
80007ffa:	e0 82 00 90 	brhs	8000811a <follow_path+0x25e>
			return FR_INVALID_NAME;		/* Reject extended characters (ASCII cfg) */
#endif
#endif
		}
		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false at SBCS cfg.) */
			d = (BYTE)p[si++];			/* Get 2nd byte */
80007ffe:	2f f1       	sub	r1,-1
			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
				return FR_INVALID_NAME;
			sfn[i++] = c;
80008000:	40 29       	lddsp	r9,sp[0x8]
80008002:	f2 00 0b 07 	st.b	r9[r0],r7
80008006:	2f f0       	sub	r0,-1
			sfn[i++] = d;
80008008:	f2 00 0b 08 	st.b	r9[r0],r8
8000800c:	2f f0       	sub	r0,-1
8000800e:	ca 0b       	rjmp	80007f4e <follow_path+0x92>
		} else {						/* SBC */
			if (chk_chr("\"*+,:;<=>\?[]|\x7F", c))	/* Reject illegal chrs for SFN */
80008010:	0e 9b       	mov	r11,r7
80008012:	4c dc       	lddpc	r12,80008144 <follow_path+0x288>
80008014:	f0 1f 00 4d 	mcall	80008148 <follow_path+0x28c>
80008018:	e0 81 00 81 	brne	8000811a <follow_path+0x25e>
				return FR_INVALID_NAME;
			if (IsUpper(c)) {			/* ASCII large capital? */
8000801c:	0e 98       	mov	r8,r7
8000801e:	24 18       	sub	r8,65
80008020:	31 99       	mov	r9,25
80008022:	f2 08 18 00 	cp.b	r8,r9
80008026:	e0 8b 00 06 	brhi	80008032 <follow_path+0x176>
				b |= 2;
8000802a:	40 18       	lddsp	r8,sp[0x4]
8000802c:	a1 b8       	sbr	r8,0x1
8000802e:	50 18       	stdsp	sp[0x4],r8
80008030:	c0 d8       	rjmp	8000804a <follow_path+0x18e>
			} else {
				if (IsLower(c)) {		/* ASCII small capital? */
80008032:	0e 98       	mov	r8,r7
80008034:	26 18       	sub	r8,97
80008036:	31 9a       	mov	r10,25
80008038:	f4 08 18 00 	cp.b	r8,r10
8000803c:	e0 8b 00 07 	brhi	8000804a <follow_path+0x18e>
					b |= 1; c -= 0x20;
80008040:	40 19       	lddsp	r9,sp[0x4]
80008042:	a1 a9       	sbr	r9,0x0
80008044:	50 19       	stdsp	sp[0x4],r9
80008046:	22 07       	sub	r7,32
80008048:	5c 57       	castu.b	r7
				}
			}
			sfn[i++] = c;
8000804a:	40 28       	lddsp	r8,sp[0x8]
8000804c:	f0 00 0b 07 	st.b	r8[r0],r7
80008050:	2f f0       	sub	r0,-1
80008052:	c7 eb       	rjmp	80007f4e <follow_path+0x92>
80008054:	0a 97       	mov	r7,r5
		}
	}
	*path = &p[si];						/* Return pointer to the next segment */
	c = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
80008056:	58 08       	cp.w	r8,0
80008058:	f9 b8 01 04 	movne	r8,4
8000805c:	f9 b8 00 00 	moveq	r8,0

	if (!i) return FR_INVALID_NAME;		/* Reject nul string */
80008060:	58 00       	cp.w	r0,0
80008062:	c5 c0       	breq	8000811a <follow_path+0x25e>
	if (sfn[0] == DDEM) sfn[0] = RDDEM;	/* When first character collides with DDEM, replace it with RDDEM */
80008064:	40 29       	lddsp	r9,sp[0x8]
80008066:	13 8a       	ld.ub	r10,r9[0x0]
80008068:	3e 59       	mov	r9,-27
8000806a:	f2 0a 18 00 	cp.b	r10,r9
8000806e:	f9 b9 00 05 	moveq	r9,5
80008072:	fb fa 00 02 	ld.weq	r10,sp[0x8]
80008076:	f5 f9 0e 00 	st.beq	r10[0x0],r9

	if (ni == 8) b <<= 2;
8000807a:	40 09       	lddsp	r9,sp[0x0]
8000807c:	58 89       	cp.w	r9,8
8000807e:	c0 51       	brne	80008088 <follow_path+0x1cc>
80008080:	40 19       	lddsp	r9,sp[0x4]
80008082:	a3 69       	lsl	r9,0x2
80008084:	5c 59       	castu.b	r9
80008086:	50 19       	stdsp	sp[0x4],r9
	if ((b & 0x03) == 0x01) c |= NS_EXT;	/* NT flag (Name extension has only small capital) */
80008088:	40 19       	lddsp	r9,sp[0x4]
8000808a:	f5 d9 c0 02 	bfextu	r10,r9,0x0,0x2
8000808e:	58 1a       	cp.w	r10,1
80008090:	c0 21       	brne	80008094 <follow_path+0x1d8>
80008092:	a5 a8       	sbr	r8,0x4
	if ((b & 0x0C) == 0x04) c |= NS_BODY;	/* NT flag (Name body has only small capital) */
80008094:	e2 19 00 0c 	andl	r9,0xc,COH
80008098:	58 49       	cp.w	r9,4
8000809a:	c0 21       	brne	8000809e <follow_path+0x1e2>
8000809c:	a3 b8       	sbr	r8,0x3

	sfn[NSFLAG] = c;		/* Store NT flag, File name is created */
8000809e:	40 2a       	lddsp	r10,sp[0x8]
800080a0:	f5 68 00 0b 	st.b	r10[11],r8
	BYTE c, *dir;
#if _USE_LFN
	BYTE a, ord, sum;
#endif

	res = dir_sdi(dp, 0);			/* Rewind directory object */
800080a4:	30 0b       	mov	r11,0
800080a6:	04 9c       	mov	r12,r2
800080a8:	f0 1f 00 25 	mcall	8000813c <follow_path+0x280>
	if (res != FR_OK) return res;
800080ac:	c2 11       	brne	800080ee <follow_path+0x232>

#if _USE_LFN
	ord = sum = 0xFF; dp->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
#endif
	do {
		res = move_window(dp->fs, dp->sect);
800080ae:	64 4b       	ld.w	r11,r2[0x10]
800080b0:	64 0c       	ld.w	r12,r2[0x0]
800080b2:	f0 1f 00 27 	mcall	8000814c <follow_path+0x290>
		if (res != FR_OK) break;
800080b6:	c1 c1       	brne	800080ee <follow_path+0x232>
		dir = dp->dir;					/* Ptr to the directory entry of current index */
800080b8:	64 59       	ld.w	r9,r2[0x14]
		c = dir[DIR_Name];
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
800080ba:	13 88       	ld.ub	r8,r9[0x0]
800080bc:	ec 08 18 00 	cp.b	r8,r6
800080c0:	c3 90       	breq	80008132 <follow_path+0x276>
				if (!(dp->fn[NSFLAG] & NS_LOSS) && !mem_cmp(dir, dp->fn, 11)) break;	/* SFN matched? */
				ord = 0xFF; dp->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
			}
		}
#else		/* Non LFN configuration */
		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dp->fn, 11)) /* Is it a valid entry? */
800080c2:	f3 38 00 0b 	ld.ub	r8,r9[11]
800080c6:	e2 18 00 08 	andl	r8,0x8,COH
800080ca:	c0 d1       	brne	800080e4 <follow_path+0x228>
800080cc:	64 65       	ld.w	r5,r2[0x18]
800080ce:	c0 48       	rjmp	800080d6 <follow_path+0x21a>
800080d0:	2f f8       	sub	r8,-1
static
int mem_cmp (const void* dst, const void* src, UINT cnt) {
	const BYTE *d = (const BYTE *)dst, *s = (const BYTE *)src;
	int r = 0;

	while (cnt-- && (r = *d++ - *s++) == 0) ;
800080d2:	58 b8       	cp.w	r8,11
800080d4:	c2 80       	breq	80008124 <follow_path+0x268>
800080d6:	f2 08 07 0b 	ld.ub	r11,r9[r8]
800080da:	ea 08 07 0a 	ld.ub	r10,r5[r8]
800080de:	f4 0b 18 00 	cp.b	r11,r10
800080e2:	cf 70       	breq	800080d0 <follow_path+0x214>
		}
#else		/* Non LFN configuration */
		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dp->fn, 11)) /* Is it a valid entry? */
			break;
#endif
		res = dir_next(dp, 0);		/* Next entry */
800080e4:	30 0b       	mov	r11,0
800080e6:	04 9c       	mov	r12,r2
800080e8:	f0 1f 00 1a 	mcall	80008150 <follow_path+0x294>
	} while (res == FR_OK);
800080ec:	ce 10       	breq	800080ae <follow_path+0x1f2>
	} else {								/* Follow path */
		for (;;) {
			res = create_name(dp, &path);	/* Get a segment name of the path */
			if (res != FR_OK) break;
			res = dir_find(dp);				/* Find an object with the sagment name */
			ns = dp->fn[NSFLAG];
800080ee:	64 68       	ld.w	r8,r2[0x18]
800080f0:	f1 38 00 0b 	ld.ub	r8,r8[11]
			if (res != FR_OK) {				/* Failed to find the object */
				if (res == FR_NO_FILE) {	/* Object is not found */
800080f4:	58 4c       	cp.w	r12,4
800080f6:	c1 51       	brne	80008120 <follow_path+0x264>
					if (_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exist, */
						dp->sclust = 0; dp->dir = 0;	/* it is the root directory and stay there */
						if (!(ns & NS_LAST)) continue;	/* Continue to follow if not last segment */
						res = FR_OK;					/* Ended at the root directroy. Function completed. */
					} else {							/* Could not find the object */
						if (!(ns & NS_LAST)) res = FR_NO_PATH;	/* Adjust error code if not last segment */
800080f8:	e2 18 00 04 	andl	r8,0x4,COH
800080fc:	c1 10       	breq	8000811e <follow_path+0x262>
800080fe:	30 4c       	mov	r12,4
80008100:	c1 08       	rjmp	80008120 <follow_path+0x264>
					}
				}
				break;
			}
			if (ns & NS_LAST) break;			/* Last segment matched. Function completed. */
			dir = dp->dir;						/* Follow the sub-directory */
80008102:	64 5b       	ld.w	r11,r2[0x14]
			if (!(dir[DIR_Attr] & AM_DIR)) {	/* It is not a sub-directory and cannot follow */
80008104:	f7 38 00 0b 	ld.ub	r8,r11[11]
80008108:	e2 18 00 10 	andl	r8,0x10,COH
8000810c:	c0 90       	breq	8000811e <follow_path+0x262>
				}
			}
			sfn[i++] = c;
		}
	}
	*path = &p[si];						/* Return pointer to the next segment */
8000810e:	02 07       	add	r7,r1
			if (ns & NS_LAST) break;			/* Last segment matched. Function completed. */
			dir = dp->dir;						/* Follow the sub-directory */
			if (!(dir[DIR_Attr] & AM_DIR)) {	/* It is not a sub-directory and cannot follow */
				res = FR_NO_PATH; break;
			}
			dp->sclust = ld_clust(dp->fs, dir);
80008110:	64 0c       	ld.w	r12,r2[0x0]
80008112:	f0 1f 00 11 	mcall	80008154 <follow_path+0x298>
80008116:	85 2c       	st.w	r2[0x8],r12
		}
80008118:	cf 4a       	rjmp	80007f00 <follow_path+0x44>
8000811a:	30 6c       	mov	r12,6
8000811c:	c0 28       	rjmp	80008120 <follow_path+0x264>
8000811e:	30 5c       	mov	r12,5
	}

	return res;
}
80008120:	2f dd       	sub	sp,-12
80008122:	d8 32       	popm	r0-r7,pc
	} else {								/* Follow path */
		for (;;) {
			res = create_name(dp, &path);	/* Get a segment name of the path */
			if (res != FR_OK) break;
			res = dir_find(dp);				/* Find an object with the sagment name */
			ns = dp->fn[NSFLAG];
80008124:	64 68       	ld.w	r8,r2[0x18]
80008126:	f1 38 00 0b 	ld.ub	r8,r8[11]
8000812a:	e2 18 00 04 	andl	r8,0x4,COH
8000812e:	ce a0       	breq	80008102 <follow_path+0x246>
80008130:	cf 8b       	rjmp	80008120 <follow_path+0x264>
80008132:	64 68       	ld.w	r8,r2[0x18]
80008134:	f1 38 00 0b 	ld.ub	r8,r8[11]
80008138:	ce 0b       	rjmp	800080f8 <follow_path+0x23c>
8000813a:	00 00       	add	r0,r0
8000813c:	80 00       	ld.sh	r0,r0[0x0]
8000813e:	77 54       	ld.w	r4,r11[0x54]
80008140:	80 00       	ld.sh	r0,r0[0x0]
80008142:	65 d6       	ld.w	r6,r2[0x74]
80008144:	80 01       	ld.sh	r1,r0[0x0]
80008146:	8f e0       	st.w	r7[0x38],r0
80008148:	80 00       	ld.sh	r0,r0[0x0]
8000814a:	65 e2       	ld.w	r2,r2[0x78]
8000814c:	80 00       	ld.sh	r0,r0[0x0]
8000814e:	6f 48       	ld.w	r8,r7[0x50]
80008150:	80 00       	ld.sh	r0,r0[0x0]
80008152:	78 d8       	ld.w	r8,r12[0x34]
80008154:	80 00       	ld.sh	r0,r0[0x0]
80008156:	66 52       	ld.w	r2,r3[0x14]

80008158 <f_opendir>:

FRESULT f_opendir (
	DIR* dp,			/* Pointer to directory object to create */
	const TCHAR* path	/* Pointer to the directory path */
)
{
80008158:	eb cd 40 80 	pushm	r7,lr
8000815c:	20 5d       	sub	sp,20
8000815e:	18 97       	mov	r7,r12
80008160:	50 0b       	stdsp	sp[0x0],r11
	FRESULT res;
	FATFS* fs;
	DEFINE_NAMEBUF;


	if (!dp) return FR_INVALID_OBJECT;
80008162:	58 0c       	cp.w	r12,0
80008164:	c0 31       	brne	8000816a <f_opendir+0x12>
80008166:	30 9c       	mov	r12,9
80008168:	c2 d8       	rjmp	800081c2 <f_opendir+0x6a>

	/* Get logical drive number */
	res = find_volume(&fs, &path, 0);
8000816a:	30 0a       	mov	r10,0
8000816c:	1a 9b       	mov	r11,sp
8000816e:	fa cc ff f0 	sub	r12,sp,-16
80008172:	f0 1f 00 17 	mcall	800081cc <f_opendir+0x74>
	if (res == FR_OK) {
80008176:	c2 41       	brne	800081be <f_opendir+0x66>
		dp->fs = fs;
80008178:	40 48       	lddsp	r8,sp[0x10]
8000817a:	8f 08       	st.w	r7[0x0],r8
		INIT_BUF(*dp);
8000817c:	fa c8 ff fc 	sub	r8,sp,-4
80008180:	8f 68       	st.w	r7[0x18],r8
		res = follow_path(dp, path);			/* Follow the path to the directory */
80008182:	40 0b       	lddsp	r11,sp[0x0]
80008184:	0e 9c       	mov	r12,r7
80008186:	f0 1f 00 13 	mcall	800081d0 <f_opendir+0x78>
		FREE_BUF();
		if (res == FR_OK) {						/* Follow completed */
8000818a:	c1 61       	brne	800081b6 <f_opendir+0x5e>
			if (dp->dir) {						/* It is not the origin directory itself */
8000818c:	6e 5b       	ld.w	r11,r7[0x14]
8000818e:	58 0b       	cp.w	r11,0
80008190:	c0 c0       	breq	800081a8 <f_opendir+0x50>
				if (dp->dir[DIR_Attr] & AM_DIR)	/* The object is a sub directory */
80008192:	f7 38 00 0b 	ld.ub	r8,r11[11]
80008196:	e2 18 00 10 	andl	r8,0x10,COH
8000819a:	c0 31       	brne	800081a0 <f_opendir+0x48>
8000819c:	30 5c       	mov	r12,5
8000819e:	c0 e8       	rjmp	800081ba <f_opendir+0x62>
					dp->sclust = ld_clust(fs, dp->dir);
800081a0:	40 4c       	lddsp	r12,sp[0x10]
800081a2:	f0 1f 00 0d 	mcall	800081d4 <f_opendir+0x7c>
800081a6:	8f 2c       	st.w	r7[0x8],r12
				else							/* The object is a file */
					res = FR_NO_PATH;
			}
			if (res == FR_OK) {
				dp->id = fs->id;
800081a8:	40 48       	lddsp	r8,sp[0x10]
800081aa:	90 38       	ld.sh	r8,r8[0x6]
800081ac:	ae 28       	st.h	r7[0x4],r8
				res = dir_sdi(dp, 0);			/* Rewind directory */
800081ae:	30 0b       	mov	r11,0
800081b0:	0e 9c       	mov	r12,r7
800081b2:	f0 1f 00 0a 	mcall	800081d8 <f_opendir+0x80>
					}
				}
#endif
			}
		}
		if (res == FR_NO_FILE) res = FR_NO_PATH;
800081b6:	58 4c       	cp.w	r12,4
800081b8:	c0 80       	breq	800081c8 <f_opendir+0x70>
	}
	if (res != FR_OK) dp->fs = 0;		/* Invalidate the directory object if function faild */
800081ba:	58 0c       	cp.w	r12,0
800081bc:	c0 30       	breq	800081c2 <f_opendir+0x6a>
800081be:	30 08       	mov	r8,0
800081c0:	8f 08       	st.w	r7[0x0],r8

	LEAVE_FF(fs, res);
}
800081c2:	2f bd       	sub	sp,-20
800081c4:	e3 cd 80 80 	ldm	sp++,r7,pc
#endif
			}
		}
		if (res == FR_NO_FILE) res = FR_NO_PATH;
	}
	if (res != FR_OK) dp->fs = 0;		/* Invalidate the directory object if function faild */
800081c8:	30 5c       	mov	r12,5
800081ca:	cf ab       	rjmp	800081be <f_opendir+0x66>
800081cc:	80 00       	ld.sh	r0,r0[0x0]
800081ce:	70 24       	ld.w	r4,r8[0x8]
800081d0:	80 00       	ld.sh	r0,r0[0x0]
800081d2:	7e bc       	ld.w	r12,pc[0x2c]
800081d4:	80 00       	ld.sh	r0,r0[0x0]
800081d6:	66 52       	ld.w	r2,r3[0x14]
800081d8:	80 00       	ld.sh	r0,r0[0x0]
800081da:	77 54       	ld.w	r4,r11[0x54]

800081dc <f_mkdir>:
/*-----------------------------------------------------------------------*/

FRESULT f_mkdir (
	const TCHAR* path		/* Pointer to the directory path */
)
{
800081dc:	d4 31       	pushm	r0-r7,lr
800081de:	21 0d       	sub	sp,64
800081e0:	50 4c       	stdsp	sp[0x10],r12
	FRESULT res;
	DIR dj;
	BYTE *dir, n;
	DWORD dsc, dcl, pcl, tm = GET_FATTIME();
800081e2:	f0 1f 00 61 	mcall	80008364 <f_mkdir+0x188>
800081e6:	18 95       	mov	r5,r12
	DEFINE_NAMEBUF;


	/* Get logical drive number */
	res = find_volume(&dj.fs, &path, 1);
800081e8:	30 1a       	mov	r10,1
800081ea:	fa cb ff f0 	sub	r11,sp,-16
800081ee:	fa cc ff e0 	sub	r12,sp,-32
800081f2:	f0 1f 00 5e 	mcall	80008368 <f_mkdir+0x18c>
800081f6:	18 97       	mov	r7,r12
	if (res == FR_OK) {
800081f8:	c0 30       	breq	800081fe <f_mkdir+0x22>
800081fa:	18 96       	mov	r6,r12
800081fc:	ca 78       	rjmp	8000834a <f_mkdir+0x16e>
		INIT_BUF(dj);
800081fe:	fa c8 ff ec 	sub	r8,sp,-20
80008202:	50 e8       	stdsp	sp[0x38],r8
		res = follow_path(&dj, path);			/* Follow the file path */
80008204:	40 4b       	lddsp	r11,sp[0x10]
80008206:	fa cc ff e0 	sub	r12,sp,-32
8000820a:	f0 1f 00 59 	mcall	8000836c <f_mkdir+0x190>
8000820e:	18 96       	mov	r6,r12
		if (res == FR_OK) res = FR_EXIST;		/* Any object with same name is already existing */
80008210:	c0 31       	brne	80008216 <f_mkdir+0x3a>
80008212:	30 86       	mov	r6,8
80008214:	c9 b8       	rjmp	8000834a <f_mkdir+0x16e>
		if (_FS_RPATH && res == FR_NO_FILE && (dj.fn[NSFLAG] & NS_DOT))
			res = FR_INVALID_NAME;
		if (res == FR_NO_FILE) {				/* Can create a new directory */
80008216:	58 4c       	cp.w	r12,4
80008218:	e0 81 00 99 	brne	8000834a <f_mkdir+0x16e>
			dcl = create_chain(dj.fs, 0);		/* Allocate a cluster for the new directory table */
8000821c:	30 0b       	mov	r11,0
8000821e:	40 8c       	lddsp	r12,sp[0x20]
80008220:	f0 1f 00 54 	mcall	80008370 <f_mkdir+0x194>
80008224:	18 92       	mov	r2,r12
			res = FR_OK;
			if (dcl == 0) res = FR_DENIED;		/* No space to allocate a new cluster */
80008226:	c0 31       	brne	8000822c <f_mkdir+0x50>
80008228:	30 77       	mov	r7,7
8000822a:	c0 88       	rjmp	8000823a <f_mkdir+0x5e>
			if (dcl == 1) res = FR_INT_ERR;
8000822c:	58 1c       	cp.w	r12,1
8000822e:	c0 31       	brne	80008234 <f_mkdir+0x58>
80008230:	30 27       	mov	r7,2
80008232:	c6 c8       	rjmp	8000830a <f_mkdir+0x12e>
			if (dcl == 0xFFFFFFFF) res = FR_DISK_ERR;
80008234:	5b fc       	cp.w	r12,-1
80008236:	e0 80 00 8d 	breq	80008350 <f_mkdir+0x174>
			if (res == FR_OK)					/* Flush FAT */
8000823a:	58 07       	cp.w	r7,0
8000823c:	c6 71       	brne	8000830a <f_mkdir+0x12e>
				res = sync_window(dj.fs);
8000823e:	40 8c       	lddsp	r12,sp[0x20]
80008240:	f0 1f 00 4d 	mcall	80008374 <f_mkdir+0x198>
80008244:	18 97       	mov	r7,r12
			if (res == FR_OK) {					/* Initialize the new directory table */
80008246:	c6 21       	brne	8000830a <f_mkdir+0x12e>
				dsc = clust2sect(dj.fs, dcl);
80008248:	40 87       	lddsp	r7,sp[0x20]
8000824a:	04 9b       	mov	r11,r2
8000824c:	0e 9c       	mov	r12,r7
8000824e:	f0 1f 00 4b 	mcall	80008378 <f_mkdir+0x19c>
80008252:	18 94       	mov	r4,r12
				dir = dj.fs->win;
80008254:	ee c3 ff d0 	sub	r3,r7,-48
				mem_set(dir, 0, SS(dj.fs));
80008258:	e0 6a 02 00 	mov	r10,512
8000825c:	30 0b       	mov	r11,0
8000825e:	06 9c       	mov	r12,r3
80008260:	f0 1f 00 47 	mcall	8000837c <f_mkdir+0x1a0>
				mem_set(dir + DIR_Name, ' ', 11);	/* Create "." entry */
80008264:	30 ba       	mov	r10,11
80008266:	32 0b       	mov	r11,32
80008268:	06 9c       	mov	r12,r3
8000826a:	f0 1f 00 45 	mcall	8000837c <f_mkdir+0x1a0>
				dir[DIR_Name] = '.';
8000826e:	32 e6       	mov	r6,46
80008270:	ef 66 00 30 	st.b	r7[48],r6
				dir[DIR_Attr] = AM_DIR;
80008274:	31 08       	mov	r8,16
80008276:	e7 68 00 0b 	st.b	r3[11],r8
				ST_DWORD(dir + DIR_WrtTime, tm);
8000827a:	f1 d5 c0 08 	bfextu	r8,r5,0x0,0x8
8000827e:	50 38       	stdsp	sp[0xc],r8
80008280:	e7 68 00 16 	st.b	r3[22],r8
80008284:	f1 d5 c1 08 	bfextu	r8,r5,0x8,0x8
80008288:	50 28       	stdsp	sp[0x8],r8
8000828a:	e7 68 00 17 	st.b	r3[23],r8
8000828e:	f1 d5 c2 08 	bfextu	r8,r5,0x10,0x8
80008292:	50 18       	stdsp	sp[0x4],r8
80008294:	e7 68 00 18 	st.b	r3[24],r8
80008298:	b9 85       	lsr	r5,0x18
8000829a:	50 05       	stdsp	sp[0x0],r5
8000829c:	e7 65 00 19 	st.b	r3[25],r5
				st_clust(dir, dcl);
800082a0:	04 9b       	mov	r11,r2
800082a2:	06 9c       	mov	r12,r3
800082a4:	f0 1f 00 37 	mcall	80008380 <f_mkdir+0x1a4>
				mem_cpy(dir + SZ_DIRE, dir, SZ_DIRE); 	/* Create ".." entry */
800082a8:	2b 07       	sub	r7,-80
800082aa:	32 0a       	mov	r10,32
800082ac:	06 9b       	mov	r11,r3
800082ae:	0e 9c       	mov	r12,r7
800082b0:	f0 1f 00 35 	mcall	80008384 <f_mkdir+0x1a8>
				dir[SZ_DIRE + 1] = '.'; pcl = dj.sclust;
800082b4:	e7 66 00 21 	st.b	r3[33],r6
800082b8:	40 ab       	lddsp	r11,sp[0x28]
				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
800082ba:	40 88       	lddsp	r8,sp[0x20]
800082bc:	11 8a       	ld.ub	r10,r8[0x0]
800082be:	30 39       	mov	r9,3
800082c0:	f2 0a 18 00 	cp.b	r10,r9
800082c4:	c0 51       	brne	800082ce <f_mkdir+0xf2>
800082c6:	70 98       	ld.w	r8,r8[0x24]
800082c8:	16 38       	cp.w	r8,r11
800082ca:	f9 bb 00 00 	moveq	r11,0
					pcl = 0;
				st_clust(dir + SZ_DIRE, pcl);
800082ce:	0e 9c       	mov	r12,r7
800082d0:	f0 1f 00 2c 	mcall	80008380 <f_mkdir+0x1a4>
				for (n = dj.fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
800082d4:	40 88       	lddsp	r8,sp[0x20]
800082d6:	11 a6       	ld.ub	r6,r8[0x2]
800082d8:	58 06       	cp.w	r6,0
800082da:	c3 d0       	breq	80008354 <f_mkdir+0x178>
					dj.fs->winsect = dsc++;
					dj.fs->wflag = 1;
800082dc:	30 15       	mov	r5,1
					res = sync_window(dj.fs);
					if (res != FR_OK) break;
					mem_set(dir, 0, SS(dj.fs));
800082de:	e0 61 02 00 	mov	r1,512
800082e2:	30 00       	mov	r0,0
				dir[SZ_DIRE + 1] = '.'; pcl = dj.sclust;
				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
					pcl = 0;
				st_clust(dir + SZ_DIRE, pcl);
				for (n = dj.fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
					dj.fs->winsect = dsc++;
800082e4:	40 88       	lddsp	r8,sp[0x20]
800082e6:	91 b4       	st.w	r8[0x2c],r4
800082e8:	2f f4       	sub	r4,-1
					dj.fs->wflag = 1;
800082ea:	40 88       	lddsp	r8,sp[0x20]
800082ec:	b0 c5       	st.b	r8[0x4],r5
					res = sync_window(dj.fs);
800082ee:	40 8c       	lddsp	r12,sp[0x20]
800082f0:	f0 1f 00 21 	mcall	80008374 <f_mkdir+0x198>
					if (res != FR_OK) break;
800082f4:	c0 a1       	brne	80008308 <f_mkdir+0x12c>
					mem_set(dir, 0, SS(dj.fs));
800082f6:	02 9a       	mov	r10,r1
800082f8:	00 9b       	mov	r11,r0
800082fa:	06 9c       	mov	r12,r3
800082fc:	f0 1f 00 20 	mcall	8000837c <f_mkdir+0x1a0>
				mem_cpy(dir + SZ_DIRE, dir, SZ_DIRE); 	/* Create ".." entry */
				dir[SZ_DIRE + 1] = '.'; pcl = dj.sclust;
				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
					pcl = 0;
				st_clust(dir + SZ_DIRE, pcl);
				for (n = dj.fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
80008300:	20 16       	sub	r6,1
80008302:	5c 56       	castu.b	r6
80008304:	cf 01       	brne	800082e4 <f_mkdir+0x108>
80008306:	c2 78       	rjmp	80008354 <f_mkdir+0x178>
80008308:	18 97       	mov	r7,r12
8000830a:	0e 96       	mov	r6,r7
					mem_set(dir, 0, SS(dj.fs));
				}
			}
			if (res == FR_OK) res = dir_register(&dj);	/* Register the object to the directoy */
			if (res != FR_OK) {
				remove_chain(dj.fs, dcl);			/* Could not register, remove cluster chain */
8000830c:	04 9b       	mov	r11,r2
8000830e:	40 8c       	lddsp	r12,sp[0x20]
80008310:	f0 1f 00 1e 	mcall	80008388 <f_mkdir+0x1ac>
80008314:	c1 b8       	rjmp	8000834a <f_mkdir+0x16e>
			} else {
				dir = dj.dir;
80008316:	40 dc       	lddsp	r12,sp[0x34]
				dir[DIR_Attr] = AM_DIR;				/* Attribute */
80008318:	31 08       	mov	r8,16
8000831a:	f9 68 00 0b 	st.b	r12[11],r8
				ST_DWORD(dir + DIR_WrtTime, tm);	/* Created time */
8000831e:	40 38       	lddsp	r8,sp[0xc]
80008320:	f9 68 00 16 	st.b	r12[22],r8
80008324:	40 28       	lddsp	r8,sp[0x8]
80008326:	f9 68 00 17 	st.b	r12[23],r8
8000832a:	40 18       	lddsp	r8,sp[0x4]
8000832c:	f9 68 00 18 	st.b	r12[24],r8
80008330:	40 08       	lddsp	r8,sp[0x0]
80008332:	f9 68 00 19 	st.b	r12[25],r8
				st_clust(dir, dcl);					/* Table start cluster */
80008336:	04 9b       	mov	r11,r2
80008338:	f0 1f 00 12 	mcall	80008380 <f_mkdir+0x1a4>
				dj.fs->wflag = 1;
8000833c:	30 19       	mov	r9,1
8000833e:	40 88       	lddsp	r8,sp[0x20]
80008340:	b0 c9       	st.b	r8[0x4],r9
				res = sync_fs(dj.fs);
80008342:	40 8c       	lddsp	r12,sp[0x20]
80008344:	f0 1f 00 12 	mcall	8000838c <f_mkdir+0x1b0>
80008348:	18 96       	mov	r6,r12
		}
		FREE_BUF();
	}

	LEAVE_FF(dj.fs, res);
}
8000834a:	0c 9c       	mov	r12,r6
8000834c:	2f 0d       	sub	sp,-64
8000834e:	d8 32       	popm	r0-r7,pc
				dir = dj.dir;
				dir[DIR_Attr] = AM_DIR;				/* Attribute */
				ST_DWORD(dir + DIR_WrtTime, tm);	/* Created time */
				st_clust(dir, dcl);					/* Table start cluster */
				dj.fs->wflag = 1;
				res = sync_fs(dj.fs);
80008350:	30 17       	mov	r7,1
80008352:	cd cb       	rjmp	8000830a <f_mkdir+0x12e>
					res = sync_window(dj.fs);
					if (res != FR_OK) break;
					mem_set(dir, 0, SS(dj.fs));
				}
			}
			if (res == FR_OK) res = dir_register(&dj);	/* Register the object to the directoy */
80008354:	fa cc ff e0 	sub	r12,sp,-32
80008358:	f0 1f 00 0e 	mcall	80008390 <f_mkdir+0x1b4>
8000835c:	18 96       	mov	r6,r12
			if (res != FR_OK) {
8000835e:	cd c0       	breq	80008316 <f_mkdir+0x13a>
80008360:	cd 6b       	rjmp	8000830c <f_mkdir+0x130>
80008362:	00 00       	add	r0,r0
80008364:	80 00       	ld.sh	r0,r0[0x0]
80008366:	64 fc       	ld.w	r12,r2[0x3c]
80008368:	80 00       	ld.sh	r0,r0[0x0]
8000836a:	70 24       	ld.w	r4,r8[0x8]
8000836c:	80 00       	ld.sh	r0,r0[0x0]
8000836e:	7e bc       	ld.w	r12,pc[0x2c]
80008370:	80 00       	ld.sh	r0,r0[0x0]
80008372:	78 08       	ld.w	r8,r12[0x0]
80008374:	80 00       	ld.sh	r0,r0[0x0]
80008376:	67 50       	ld.w	r0,r3[0x54]
80008378:	80 00       	ld.sh	r0,r0[0x0]
8000837a:	65 fc       	ld.w	r12,r2[0x7c]
8000837c:	80 00       	ld.sh	r0,r0[0x0]
8000837e:	65 d6       	ld.w	r6,r2[0x74]
80008380:	80 00       	ld.sh	r0,r0[0x0]
80008382:	66 7a       	ld.w	r10,r3[0x1c]
80008384:	80 00       	ld.sh	r0,r0[0x0]
80008386:	65 c0       	ld.w	r0,r2[0x70]
80008388:	80 00       	ld.sh	r0,r0[0x0]
8000838a:	79 e8       	ld.w	r8,r12[0x78]
8000838c:	80 00       	ld.sh	r0,r0[0x0]
8000838e:	67 b4       	ld.w	r4,r3[0x6c]
80008390:	80 00       	ld.sh	r0,r0[0x0]
80008392:	7e 70       	ld.w	r0,pc[0x1c]

80008394 <f_open>:
FRESULT f_open (
	FIL* fp,			/* Pointer to the blank file object */
	const TCHAR* path,	/* Pointer to the file name */
	BYTE mode			/* Access mode and file open mode flags */
)
{
80008394:	eb cd 40 fc 	pushm	r2-r7,lr
80008398:	20 cd       	sub	sp,48
8000839a:	18 97       	mov	r7,r12
8000839c:	50 0b       	stdsp	sp[0x0],r11
#if !_FS_READONLY
	DWORD dw, cl;
#endif


	if (!fp) return FR_INVALID_OBJECT;
8000839e:	58 0c       	cp.w	r12,0
800083a0:	c0 31       	brne	800083a6 <f_open+0x12>
800083a2:	30 96       	mov	r6,9
800083a4:	cb 68       	rjmp	80008510 <f_open+0x17c>
	fp->fs = 0;			/* Clear file object */
800083a6:	30 08       	mov	r8,0
800083a8:	99 08       	st.w	r12[0x0],r8

	/* Get logical drive number */
#if !_FS_READONLY
	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
800083aa:	eb da c0 05 	bfextu	r5,r10,0x0,0x5
	res = find_volume(&dj.fs, &path, (BYTE)(mode & ~FA_READ));
800083ae:	0a 93       	mov	r3,r5
800083b0:	e2 1a 00 1e 	andl	r10,0x1e,COH
800083b4:	1a 9b       	mov	r11,sp
800083b6:	fa cc ff f0 	sub	r12,sp,-16
800083ba:	f0 1f 00 5c 	mcall	80008528 <f_open+0x194>
800083be:	18 96       	mov	r6,r12
#else
	mode &= FA_READ;
	res = find_volume(&dj.fs, &path, 0);
#endif
	if (res == FR_OK) {
800083c0:	e0 81 00 a8 	brne	80008510 <f_open+0x17c>
		INIT_BUF(dj);
800083c4:	fa c8 ff fc 	sub	r8,sp,-4
800083c8:	50 a8       	stdsp	sp[0x28],r8
		res = follow_path(&dj, path);	/* Follow the file path */
800083ca:	40 0b       	lddsp	r11,sp[0x0]
800083cc:	fa cc ff f0 	sub	r12,sp,-16
800083d0:	f0 1f 00 57 	mcall	8000852c <f_open+0x198>
		dir = dj.dir;
800083d4:	40 94       	lddsp	r4,sp[0x24]
#if !_FS_READONLY	/* R/W configuration */
		if (res == FR_OK) {
800083d6:	c0 41       	brne	800083de <f_open+0x4a>
			if (!dir)	/* Default directory itself */
800083d8:	58 04       	cp.w	r4,0
800083da:	f9 bc 00 06 	moveq	r12,6
			else
				res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
#endif
		}
		/* Create or Open a file */
		if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
800083de:	06 98       	mov	r8,r3
800083e0:	e2 18 00 1c 	andl	r8,0x1c,COH
800083e4:	c5 f0       	breq	800084a2 <f_open+0x10e>
			if (res != FR_OK) {					/* No file, create new */
800083e6:	58 0c       	cp.w	r12,0
800083e8:	c0 d0       	breq	80008402 <f_open+0x6e>
				if (res == FR_NO_FILE)			/* There is no file to open, create a new entry */
800083ea:	58 4c       	cp.w	r12,4
800083ec:	e0 81 00 91 	brne	8000850e <f_open+0x17a>
#if _FS_LOCK
					res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
#else
					res = dir_register(&dj);
800083f0:	fa cc ff f0 	sub	r12,sp,-16
800083f4:	f0 1f 00 4f 	mcall	80008530 <f_open+0x19c>
#endif
				mode |= FA_CREATE_ALWAYS;		/* File is created */
				dir = dj.dir;					/* New entry */
800083f8:	40 94       	lddsp	r4,sp[0x24]
				} else {
					if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
						res = FR_EXIST;
				}
			}
			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
800083fa:	e0 81 00 8a 	brne	8000850e <f_open+0x17a>
#if _FS_LOCK
					res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
#else
					res = dir_register(&dj);
#endif
				mode |= FA_CREATE_ALWAYS;		/* File is created */
800083fe:	a3 b5       	sbr	r5,0x3
80008400:	c0 c8       	rjmp	80008418 <f_open+0x84>
				dir = dj.dir;					/* New entry */
			}
			else {								/* Any object is already existing */
				if (dir[DIR_Attr] & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
80008402:	e9 38 00 0b 	ld.ub	r8,r4[11]
80008406:	e2 18 00 11 	andl	r8,0x11,COH
8000840a:	c0 30       	breq	80008410 <f_open+0x7c>
8000840c:	30 7c       	mov	r12,7
8000840e:	c8 08       	rjmp	8000850e <f_open+0x17a>
					res = FR_DENIED;
				} else {
					if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
80008410:	e2 13 00 04 	andl	r3,0x4,COH
80008414:	e0 81 00 82 	brne	80008518 <f_open+0x184>
						res = FR_EXIST;
				}
			}
			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
80008418:	0a 98       	mov	r8,r5
8000841a:	e2 18 00 08 	andl	r8,0x8,COH
8000841e:	c7 f0       	breq	8000851c <f_open+0x188>
				dw = GET_FATTIME();
80008420:	f0 1f 00 45 	mcall	80008534 <f_open+0x1a0>
				ST_DWORD(dir + DIR_CrtTime, dw);/* Set created time */
80008424:	f5 dc c0 08 	bfextu	r10,r12,0x0,0x8
80008428:	e9 6a 00 0e 	st.b	r4[14],r10
8000842c:	f3 dc c1 08 	bfextu	r9,r12,0x8,0x8
80008430:	e9 69 00 0f 	st.b	r4[15],r9
80008434:	f1 dc c2 08 	bfextu	r8,r12,0x10,0x8
80008438:	e9 68 00 10 	st.b	r4[16],r8
8000843c:	b9 8c       	lsr	r12,0x18
8000843e:	e9 6c 00 11 	st.b	r4[17],r12
				ST_DWORD(dir + DIR_WrtTime, dw);/* Set modified time */
80008442:	e9 6a 00 16 	st.b	r4[22],r10
80008446:	e9 69 00 17 	st.b	r4[23],r9
8000844a:	e9 68 00 18 	st.b	r4[24],r8
8000844e:	e9 6c 00 19 	st.b	r4[25],r12
				dir[DIR_Attr] = 0;				/* Reset attribute */
80008452:	30 08       	mov	r8,0
80008454:	e9 68 00 0b 	st.b	r4[11],r8
				ST_DWORD(dir + DIR_FileSize, 0);/* Reset file size */
80008458:	e9 68 00 1c 	st.b	r4[28],r8
8000845c:	e9 68 00 1d 	st.b	r4[29],r8
80008460:	e9 68 00 1e 	st.b	r4[30],r8
80008464:	e9 68 00 1f 	st.b	r4[31],r8
				cl = ld_clust(dj.fs, dir);		/* Get cluster chain */
80008468:	08 9b       	mov	r11,r4
8000846a:	40 4c       	lddsp	r12,sp[0x10]
8000846c:	f0 1f 00 33 	mcall	80008538 <f_open+0x1a4>
80008470:	18 93       	mov	r3,r12
				st_clust(dir, 0);				/* Reset cluster */
80008472:	30 0b       	mov	r11,0
80008474:	08 9c       	mov	r12,r4
80008476:	f0 1f 00 32 	mcall	8000853c <f_open+0x1a8>
				dj.fs->wflag = 1;
8000847a:	30 19       	mov	r9,1
8000847c:	40 48       	lddsp	r8,sp[0x10]
8000847e:	b0 c9       	st.b	r8[0x4],r9
				if (cl) {						/* Remove the cluster chain if exist */
80008480:	58 03       	cp.w	r3,0
80008482:	c4 d0       	breq	8000851c <f_open+0x188>
					dw = dj.fs->winsect;
80008484:	40 4c       	lddsp	r12,sp[0x10]
80008486:	78 b2       	ld.w	r2,r12[0x2c]
					res = remove_chain(dj.fs, cl);
80008488:	06 9b       	mov	r11,r3
8000848a:	f0 1f 00 2e 	mcall	80008540 <f_open+0x1ac>
					if (res == FR_OK) {
8000848e:	c4 01       	brne	8000850e <f_open+0x17a>
						dj.fs->last_clust = cl - 1;	/* Reuse the cluster hole */
80008490:	20 13       	sub	r3,1
80008492:	40 48       	lddsp	r8,sp[0x10]
80008494:	91 33       	st.w	r8[0xc],r3
						res = move_window(dj.fs, dw);
80008496:	04 9b       	mov	r11,r2
80008498:	40 4c       	lddsp	r12,sp[0x10]
8000849a:	f0 1f 00 2b 	mcall	80008544 <f_open+0x1b0>
					if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
						res = FR_DENIED;
				}
			}
		}
		if (res == FR_OK) {
8000849e:	c1 40       	breq	800084c6 <f_open+0x132>
800084a0:	c3 78       	rjmp	8000850e <f_open+0x17a>
					}
				}
			}
		}
		else {	/* Open an existing file */
			if (res == FR_OK) {					/* Following succeeded */
800084a2:	58 0c       	cp.w	r12,0
800084a4:	c3 51       	brne	8000850e <f_open+0x17a>
				if (dir[DIR_Attr] & AM_DIR) {	/* It is a directory */
800084a6:	e9 38 00 0b 	ld.ub	r8,r4[11]
800084aa:	10 99       	mov	r9,r8
800084ac:	e2 19 00 10 	andl	r9,0x10,COH
800084b0:	c0 30       	breq	800084b6 <f_open+0x122>
800084b2:	30 4c       	mov	r12,4
800084b4:	c2 d8       	rjmp	8000850e <f_open+0x17a>
					res = FR_NO_FILE;
				} else {
					if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
800084b6:	e2 13 00 02 	andl	r3,0x2,COH
800084ba:	c3 10       	breq	8000851c <f_open+0x188>
800084bc:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800084c0:	c2 e0       	breq	8000851c <f_open+0x188>
800084c2:	30 7c       	mov	r12,7
800084c4:	c2 58       	rjmp	8000850e <f_open+0x17a>
				}
			}
		}
		if (res == FR_OK) {
			if (mode & FA_CREATE_ALWAYS)		/* Set file change flag if created or overwritten */
				mode |= FA__WRITTEN;
800084c6:	a5 b5       	sbr	r5,0x5
			fp->dir_sect = dj.fs->winsect;		/* Pointer to the directory entry */
800084c8:	40 43       	lddsp	r3,sp[0x10]
800084ca:	66 b8       	ld.w	r8,r3[0x2c]
800084cc:	8f 78       	st.w	r7[0x1c],r8
			fp->dir_ptr = dir;
800084ce:	8f 84       	st.w	r7[0x20],r4
		}
#endif
		FREE_BUF();

		if (res == FR_OK) {
			fp->flag = mode;					/* File access mode */
800084d0:	ae e5       	st.b	r7[0x6],r5
			fp->err = 0;						/* Clear error flag */
800084d2:	30 08       	mov	r8,0
800084d4:	ae f8       	st.b	r7[0x7],r8
			fp->sclust = ld_clust(dj.fs, dir);	/* File start cluster */
800084d6:	08 9b       	mov	r11,r4
800084d8:	06 9c       	mov	r12,r3
800084da:	f0 1f 00 18 	mcall	80008538 <f_open+0x1a4>
800084de:	8f 4c       	st.w	r7[0x10],r12
			fp->fsize = LD_DWORD(dir + DIR_FileSize);	/* File size */
800084e0:	e9 39 00 1f 	ld.ub	r9,r4[31]
800084e4:	e9 38 00 1e 	ld.ub	r8,r4[30]
800084e8:	b1 68       	lsl	r8,0x10
800084ea:	f1 e9 11 88 	or	r8,r8,r9<<0x18
800084ee:	e9 39 00 1c 	ld.ub	r9,r4[28]
800084f2:	12 48       	or	r8,r9
800084f4:	e9 39 00 1d 	ld.ub	r9,r4[29]
800084f8:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800084fc:	8f 38       	st.w	r7[0xc],r8
			fp->fptr = 0;						/* File pointer */
800084fe:	30 08       	mov	r8,0
80008500:	8f 28       	st.w	r7[0x8],r8
			fp->dsect = 0;
80008502:	8f 68       	st.w	r7[0x18],r8
#if _USE_FASTSEEK
			fp->cltbl = 0;						/* Normal seek mode */
80008504:	8f 98       	st.w	r7[0x24],r8
#endif
			fp->fs = dj.fs;	 					/* Validate file object */
80008506:	8f 03       	st.w	r7[0x0],r3
			fp->id = fp->fs->id;
80008508:	86 38       	ld.sh	r8,r3[0x6]
8000850a:	ae 28       	st.h	r7[0x4],r8
8000850c:	c0 28       	rjmp	80008510 <f_open+0x17c>
8000850e:	18 96       	mov	r6,r12
		}
	}

	LEAVE_FF(dj.fs, res);
}
80008510:	0c 9c       	mov	r12,r6
80008512:	2f 4d       	sub	sp,-48
80008514:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
			fp->dsect = 0;
#if _USE_FASTSEEK
			fp->cltbl = 0;						/* Normal seek mode */
#endif
			fp->fs = dj.fs;	 					/* Validate file object */
			fp->id = fp->fs->id;
80008518:	30 8c       	mov	r12,8
8000851a:	cf ab       	rjmp	8000850e <f_open+0x17a>
						res = FR_DENIED;
				}
			}
		}
		if (res == FR_OK) {
			if (mode & FA_CREATE_ALWAYS)		/* Set file change flag if created or overwritten */
8000851c:	0a 98       	mov	r8,r5
8000851e:	e2 18 00 08 	andl	r8,0x8,COH
80008522:	cd 30       	breq	800084c8 <f_open+0x134>
80008524:	cd 1b       	rjmp	800084c6 <f_open+0x132>
80008526:	00 00       	add	r0,r0
80008528:	80 00       	ld.sh	r0,r0[0x0]
8000852a:	70 24       	ld.w	r4,r8[0x8]
8000852c:	80 00       	ld.sh	r0,r0[0x0]
8000852e:	7e bc       	ld.w	r12,pc[0x2c]
80008530:	80 00       	ld.sh	r0,r0[0x0]
80008532:	7e 70       	ld.w	r0,pc[0x1c]
80008534:	80 00       	ld.sh	r0,r0[0x0]
80008536:	64 fc       	ld.w	r12,r2[0x3c]
80008538:	80 00       	ld.sh	r0,r0[0x0]
8000853a:	66 52       	ld.w	r2,r3[0x14]
8000853c:	80 00       	ld.sh	r0,r0[0x0]
8000853e:	66 7a       	ld.w	r10,r3[0x1c]
80008540:	80 00       	ld.sh	r0,r0[0x0]
80008542:	79 e8       	ld.w	r8,r12[0x78]
80008544:	80 00       	ld.sh	r0,r0[0x0]
80008546:	6f 48       	ld.w	r8,r7[0x50]

80008548 <f_getfree>:
FRESULT f_getfree (
	const TCHAR* path,	/* Path name of the logical drive number */
	DWORD* nclst,		/* Pointer to a variable to return number of free clusters */
	FATFS** fatfs		/* Pointer to return pointer to corresponding file system object */
)
{
80008548:	d4 31       	pushm	r0-r7,lr
8000854a:	20 2d       	sub	sp,8
8000854c:	fa c7 ff f8 	sub	r7,sp,-8
80008550:	0e dc       	st.w	--r7,r12
80008552:	16 90       	mov	r0,r11
80008554:	14 96       	mov	r6,r10
	UINT i;
	BYTE fat, *p;


	/* Get logical drive number */
	res = find_volume(fatfs, &path, 0);
80008556:	30 0a       	mov	r10,0
80008558:	0e 9b       	mov	r11,r7
8000855a:	0c 9c       	mov	r12,r6
8000855c:	f0 1f 00 33 	mcall	80008628 <f_getfree+0xe0>
80008560:	18 93       	mov	r3,r12
	fs = *fatfs;
80008562:	6c 06       	ld.w	r6,r6[0x0]
	if (res == FR_OK) {
80008564:	c5 f1       	brne	80008622 <f_getfree+0xda>
		/* If free_clust is valid, return it without full cluster scan */
		if (fs->free_clust <= fs->n_fatent - 2) {
80008566:	6c 48       	ld.w	r8,r6[0x10]
80008568:	6c 57       	ld.w	r7,r6[0x14]
8000856a:	ee c9 00 02 	sub	r9,r7,2
8000856e:	12 38       	cp.w	r8,r9
80008570:	e0 8b 00 04 	brhi	80008578 <f_getfree+0x30>
			*nclst = fs->free_clust;
80008574:	81 08       	st.w	r0[0x0],r8
80008576:	c5 68       	rjmp	80008622 <f_getfree+0xda>
		} else {
			/* Get number of free clusters */
			fat = fs->fs_type;
80008578:	0d 84       	ld.ub	r4,r6[0x0]
			nfree = 0;
			if (fat == FS_FAT12) {	/* Sector unalighed entries: Search FAT via regular routine. */
8000857a:	30 18       	mov	r8,1
8000857c:	f0 04 18 00 	cp.b	r4,r8
80008580:	c1 71       	brne	800085ae <f_getfree+0x66>
80008582:	30 27       	mov	r7,2
80008584:	30 05       	mov	r5,0
				clst = 2;
				do {
					stat = get_fat(fs, clst);
80008586:	0e 9b       	mov	r11,r7
80008588:	0c 9c       	mov	r12,r6
8000858a:	f0 1f 00 29 	mcall	8000862c <f_getfree+0xe4>
					if (stat == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }
8000858e:	5b fc       	cp.w	r12,-1
80008590:	c0 31       	brne	80008596 <f_getfree+0x4e>
80008592:	30 1c       	mov	r12,1
80008594:	c4 28       	rjmp	80008618 <f_getfree+0xd0>
					if (stat == 1) { res = FR_INT_ERR; break; }
80008596:	58 1c       	cp.w	r12,1
80008598:	c0 31       	brne	8000859e <f_getfree+0x56>
8000859a:	30 2c       	mov	r12,2
8000859c:	c3 e8       	rjmp	80008618 <f_getfree+0xd0>
					if (stat == 0) nfree++;
8000859e:	58 0c       	cp.w	r12,0
800085a0:	f7 b5 00 ff 	subeq	r5,-1
				} while (++clst < fs->n_fatent);
800085a4:	2f f7       	sub	r7,-1
800085a6:	6c 58       	ld.w	r8,r6[0x14]
800085a8:	10 37       	cp.w	r7,r8
800085aa:	ce e3       	brcs	80008586 <f_getfree+0x3e>
800085ac:	c3 58       	rjmp	80008616 <f_getfree+0xce>
			} else {				/* Sector alighed entries: Accelerate the FAT search. */
				clst = fs->n_fatent; sect = fs->fatbase;
800085ae:	6c 81       	ld.w	r1,r6[0x20]
				i = 0; p = 0;
				do {
					if (!i) {
						res = move_window(fs, sect++);
						if (res != FR_OK) break;
						p = fs->win;
800085b0:	30 08       	mov	r8,0
800085b2:	10 99       	mov	r9,r8
800085b4:	10 95       	mov	r5,r8
			} else {				/* Sector alighed entries: Accelerate the FAT search. */
				clst = fs->n_fatent; sect = fs->fatbase;
				i = 0; p = 0;
				do {
					if (!i) {
						res = move_window(fs, sect++);
800085b6:	ec ca ff d0 	sub	r10,r6,-48
800085ba:	50 0a       	stdsp	sp[0x0],r10
						if (res != FR_OK) break;
						p = fs->win;
						i = SS(fs);
					}
					if (fat == FS_FAT16) {
800085bc:	30 22       	mov	r2,2
				} while (++clst < fs->n_fatent);
			} else {				/* Sector alighed entries: Accelerate the FAT search. */
				clst = fs->n_fatent; sect = fs->fatbase;
				i = 0; p = 0;
				do {
					if (!i) {
800085be:	58 09       	cp.w	r9,0
800085c0:	c0 a1       	brne	800085d4 <f_getfree+0x8c>
						res = move_window(fs, sect++);
800085c2:	02 9b       	mov	r11,r1
800085c4:	0c 9c       	mov	r12,r6
800085c6:	f0 1f 00 1b 	mcall	80008630 <f_getfree+0xe8>
						if (res != FR_OK) break;
800085ca:	c2 71       	brne	80008618 <f_getfree+0xd0>
			} else {				/* Sector alighed entries: Accelerate the FAT search. */
				clst = fs->n_fatent; sect = fs->fatbase;
				i = 0; p = 0;
				do {
					if (!i) {
						res = move_window(fs, sect++);
800085cc:	2f f1       	sub	r1,-1
800085ce:	40 08       	lddsp	r8,sp[0x0]
800085d0:	e0 69 02 00 	mov	r9,512
						if (res != FR_OK) break;
						p = fs->win;
						i = SS(fs);
					}
					if (fat == FS_FAT16) {
800085d4:	e4 04 18 00 	cp.b	r4,r2
800085d8:	c0 d1       	brne	800085f2 <f_getfree+0xaa>
						if (LD_WORD(p) == 0) nfree++;
800085da:	11 9b       	ld.ub	r11,r8[0x1]
800085dc:	11 8a       	ld.ub	r10,r8[0x0]
800085de:	f5 eb 10 8a 	or	r10,r10,r11<<0x8
800085e2:	30 0b       	mov	r11,0
800085e4:	f6 0a 19 00 	cp.h	r10,r11
800085e8:	f7 b5 00 ff 	subeq	r5,-1
						p += 2; i -= 2;
800085ec:	2f e8       	sub	r8,-2
800085ee:	20 29       	sub	r9,2
800085f0:	c1 18       	rjmp	80008612 <f_getfree+0xca>
					} else {
						if ((LD_DWORD(p) & 0x0FFFFFFF) == 0) nfree++;
800085f2:	11 bb       	ld.ub	r11,r8[0x3]
800085f4:	11 aa       	ld.ub	r10,r8[0x2]
800085f6:	b1 6a       	lsl	r10,0x10
800085f8:	f5 eb 11 8a 	or	r10,r10,r11<<0x18
800085fc:	11 8b       	ld.ub	r11,r8[0x0]
800085fe:	16 4a       	or	r10,r11
80008600:	11 9b       	ld.ub	r11,r8[0x1]
80008602:	f5 eb 10 8a 	or	r10,r10,r11<<0x8
80008606:	f5 da c0 1c 	bfextu	r10,r10,0x0,0x1c
8000860a:	f7 b5 00 ff 	subeq	r5,-1
						p += 4; i -= 4;
8000860e:	2f c8       	sub	r8,-4
80008610:	20 49       	sub	r9,4
					}
				} while (--clst);
80008612:	20 17       	sub	r7,1
80008614:	cd 51       	brne	800085be <f_getfree+0x76>
80008616:	06 9c       	mov	r12,r3
			}
			fs->free_clust = nfree;	/* free_clust is valid */
80008618:	8d 45       	st.w	r6[0x10],r5
			fs->fsi_flag |= 1;		/* FSInfo is to be updated */
8000861a:	0d d8       	ld.ub	r8,r6[0x5]
8000861c:	a1 a8       	sbr	r8,0x0
8000861e:	ac d8       	st.b	r6[0x5],r8
			*nclst = nfree;			/* Return the free clusters */
80008620:	81 05       	st.w	r0[0x0],r5
		}
	}
	LEAVE_FF(fs, res);
}
80008622:	2f ed       	sub	sp,-8
80008624:	d8 32       	popm	r0-r7,pc
80008626:	00 00       	add	r0,r0
80008628:	80 00       	ld.sh	r0,r0[0x0]
8000862a:	70 24       	ld.w	r4,r8[0x8]
8000862c:	80 00       	ld.sh	r0,r0[0x0]
8000862e:	76 70       	ld.w	r0,r11[0x1c]
80008630:	80 00       	ld.sh	r0,r0[0x0]
80008632:	6f 48       	ld.w	r8,r7[0x50]

80008634 <f_lseek>:

FRESULT f_lseek (
	FIL* fp,		/* Pointer to the file object */
	DWORD ofs		/* File pointer from top of file */
)
{
80008634:	d4 31       	pushm	r0-r7,lr
80008636:	18 97       	mov	r7,r12
80008638:	16 95       	mov	r5,r11
#if _USE_FASTSEEK
	DWORD cl, pcl, ncl, tcl, dsc, tlen, ulen, *tbl;
#endif


	res = validate(fp);					/* Check validity of the object */
8000863a:	f0 1f 00 a5 	mcall	800088cc <f_lseek+0x298>
8000863e:	18 96       	mov	r6,r12
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
80008640:	e0 81 01 44 	brne	800088c8 <f_lseek+0x294>
	if (fp->err)						/* Check error */
80008644:	0f f8       	ld.ub	r8,r7[0x7]
80008646:	58 08       	cp.w	r8,0
80008648:	c0 30       	breq	8000864e <f_lseek+0x1a>
		LEAVE_FF(fp->fs, (FRESULT)fp->err);
8000864a:	10 96       	mov	r6,r8
8000864c:	c3 e9       	rjmp	800088c8 <f_lseek+0x294>

#if _USE_FASTSEEK
	if (fp->cltbl) {	/* Fast seek */
8000864e:	6e 93       	ld.w	r3,r7[0x24]
80008650:	58 03       	cp.w	r3,0
80008652:	e0 80 00 85 	breq	8000875c <f_lseek+0x128>
		if (ofs == CREATE_LINKMAP) {	/* Create CLMT */
80008656:	5b f5       	cp.w	r5,-1
80008658:	c3 71       	brne	800086c6 <f_lseek+0x92>
			tbl = fp->cltbl;
			tlen = *tbl++; ulen = 2;	/* Given table size and required table size */
8000865a:	07 00       	ld.w	r0,r3++
			cl = fp->sclust;			/* Top of the chain */
8000865c:	6e 41       	ld.w	r1,r7[0x10]
			if (cl) {
8000865e:	58 01       	cp.w	r1,0
80008660:	c2 80       	breq	800086b0 <f_lseek+0x7c>
80008662:	30 22       	mov	r2,2
80008664:	02 95       	mov	r5,r1
80008666:	30 04       	mov	r4,0
				do {
					/* Get a fragment */
					tcl = cl; ncl = 0; ulen += 2;	/* Top, length and used items */
					do {
						pcl = cl; ncl++;
						cl = get_fat(fp->fs, cl);
80008668:	0a 9b       	mov	r11,r5
8000866a:	6e 0c       	ld.w	r12,r7[0x0]
8000866c:	f0 1f 00 99 	mcall	800088d0 <f_lseek+0x29c>
						if (cl <= 1) ABORT(fp->fs, FR_INT_ERR);
80008670:	58 1c       	cp.w	r12,1
80008672:	e0 8b 00 06 	brhi	8000867e <f_lseek+0x4a>
80008676:	30 28       	mov	r8,2
80008678:	ae f8       	st.b	r7[0x7],r8
8000867a:	30 26       	mov	r6,2
8000867c:	c2 69       	rjmp	800088c8 <f_lseek+0x294>
						if (cl == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
8000867e:	5b fc       	cp.w	r12,-1
80008680:	c0 51       	brne	8000868a <f_lseek+0x56>
80008682:	30 18       	mov	r8,1
80008684:	ae f8       	st.b	r7[0x7],r8
80008686:	30 16       	mov	r6,1
80008688:	c2 09       	rjmp	800088c8 <f_lseek+0x294>
			if (cl) {
				do {
					/* Get a fragment */
					tcl = cl; ncl = 0; ulen += 2;	/* Top, length and used items */
					do {
						pcl = cl; ncl++;
8000868a:	2f f4       	sub	r4,-1
						cl = get_fat(fp->fs, cl);
						if (cl <= 1) ABORT(fp->fs, FR_INT_ERR);
						if (cl == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
					} while (cl == pcl + 1);
8000868c:	2f f5       	sub	r5,-1
8000868e:	0a 3c       	cp.w	r12,r5
80008690:	c0 31       	brne	80008696 <f_lseek+0x62>
80008692:	18 95       	mov	r5,r12
80008694:	ce ab       	rjmp	80008668 <f_lseek+0x34>
80008696:	18 98       	mov	r8,r12
			tlen = *tbl++; ulen = 2;	/* Given table size and required table size */
			cl = fp->sclust;			/* Top of the chain */
			if (cl) {
				do {
					/* Get a fragment */
					tcl = cl; ncl = 0; ulen += 2;	/* Top, length and used items */
80008698:	2f e2       	sub	r2,-2
						pcl = cl; ncl++;
						cl = get_fat(fp->fs, cl);
						if (cl <= 1) ABORT(fp->fs, FR_INT_ERR);
						if (cl == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
					} while (cl == pcl + 1);
					if (ulen <= tlen) {		/* Store the length and top of the fragment */
8000869a:	04 30       	cp.w	r0,r2
8000869c:	c0 33       	brcs	800086a2 <f_lseek+0x6e>
						*tbl++ = ncl; *tbl++ = tcl;
8000869e:	06 a4       	st.w	r3++,r4
800086a0:	06 a1       	st.w	r3++,r1
					}
				} while (cl < fp->fs->n_fatent);	/* Repeat until end of chain */
800086a2:	6e 09       	ld.w	r9,r7[0x0]
800086a4:	72 59       	ld.w	r9,r9[0x14]
800086a6:	10 39       	cp.w	r9,r8
800086a8:	e0 88 00 05 	brls	800086b2 <f_lseek+0x7e>
800086ac:	18 91       	mov	r1,r12
800086ae:	cd bb       	rjmp	80008664 <f_lseek+0x30>
800086b0:	30 22       	mov	r2,2
			}
			*fp->cltbl = ulen;	/* Number of items used */
800086b2:	6e 98       	ld.w	r8,r7[0x24]
800086b4:	91 02       	st.w	r8[0x0],r2
			if (ulen <= tlen)
800086b6:	00 32       	cp.w	r2,r0
800086b8:	f9 b6 0b 11 	movhi	r6,17
				*tbl = 0;		/* Terminate table */
800086bc:	f9 b8 08 00 	movls	r8,0
800086c0:	e7 f8 8a 00 	st.wls	r3[0x0],r8
800086c4:	c0 29       	rjmp	800088c8 <f_lseek+0x294>
800086c6:	6e 34       	ld.w	r4,r7[0xc]
800086c8:	08 35       	cp.w	r5,r4
800086ca:	e8 05 17 b0 	movhi	r5,r4
				res = FR_NOT_ENOUGH_CORE;	/* Given table size is smaller than required */

		} else {						/* Fast seek */
			if (ofs > fp->fsize)		/* Clip offset at the file size */
				ofs = fp->fsize;
			fp->fptr = ofs;				/* Set file pointer */
800086ce:	8f 25       	st.w	r7[0x8],r5
			if (ofs) {
800086d0:	58 05       	cp.w	r5,0
800086d2:	e0 80 00 fb 	breq	800088c8 <f_lseek+0x294>
				fp->clust = clmt_clust(fp, ofs - 1);
800086d6:	ea c4 00 01 	sub	r4,r5,1
800086da:	08 9b       	mov	r11,r4
800086dc:	0e 9c       	mov	r12,r7
800086de:	f0 1f 00 7e 	mcall	800088d4 <f_lseek+0x2a0>
800086e2:	18 9b       	mov	r11,r12
800086e4:	8f 5c       	st.w	r7[0x14],r12
				dsc = clust2sect(fp->fs, fp->clust);
800086e6:	6e 05       	ld.w	r5,r7[0x0]
800086e8:	0a 9c       	mov	r12,r5
800086ea:	f0 1f 00 7c 	mcall	800088d8 <f_lseek+0x2a4>
				if (!dsc) ABORT(fp->fs, FR_INT_ERR);
800086ee:	c0 51       	brne	800086f8 <f_lseek+0xc4>
800086f0:	30 28       	mov	r8,2
800086f2:	ae f8       	st.b	r7[0x7],r8
800086f4:	30 26       	mov	r6,2
800086f6:	ce 98       	rjmp	800088c8 <f_lseek+0x294>
				dsc += (ofs - 1) / SS(fp->fs) & (fp->fs->csize - 1);
800086f8:	0b a9       	ld.ub	r9,r5[0x2]
				if (fp->fptr % SS(fp->fs) && dsc != fp->dsect) {	/* Refill sector cache if needed */
800086fa:	6e 28       	ld.w	r8,r7[0x8]
800086fc:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
80008700:	e0 80 00 e4 	breq	800088c8 <f_lseek+0x294>
			fp->fptr = ofs;				/* Set file pointer */
			if (ofs) {
				fp->clust = clmt_clust(fp, ofs - 1);
				dsc = clust2sect(fp->fs, fp->clust);
				if (!dsc) ABORT(fp->fs, FR_INT_ERR);
				dsc += (ofs - 1) / SS(fp->fs) & (fp->fs->csize - 1);
80008704:	20 19       	sub	r9,1
80008706:	f3 e4 02 94 	and	r4,r9,r4>>0x9
8000870a:	f8 04 00 04 	add	r4,r12,r4
				if (fp->fptr % SS(fp->fs) && dsc != fp->dsect) {	/* Refill sector cache if needed */
8000870e:	6e 6a       	ld.w	r10,r7[0x18]
80008710:	08 3a       	cp.w	r10,r4
80008712:	e0 80 00 db 	breq	800088c8 <f_lseek+0x294>
#if !_FS_TINY
#if !_FS_READONLY
					if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
80008716:	0f e8       	ld.ub	r8,r7[0x6]
80008718:	e2 18 00 40 	andl	r8,0x40,COH
8000871c:	c0 f0       	breq	8000873a <f_lseek+0x106>
						if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
8000871e:	30 19       	mov	r9,1
80008720:	ee cb ff d8 	sub	r11,r7,-40
80008724:	0b 9c       	ld.ub	r12,r5[0x1]
80008726:	f0 1f 00 6e 	mcall	800088dc <f_lseek+0x2a8>
8000872a:	c0 50       	breq	80008734 <f_lseek+0x100>
							ABORT(fp->fs, FR_DISK_ERR);
8000872c:	30 18       	mov	r8,1
8000872e:	ae f8       	st.b	r7[0x7],r8
80008730:	30 16       	mov	r6,1
80008732:	cc b8       	rjmp	800088c8 <f_lseek+0x294>
						fp->flag &= ~FA__DIRTY;
80008734:	0f e8       	ld.ub	r8,r7[0x6]
80008736:	a7 c8       	cbr	r8,0x6
80008738:	ae e8       	st.b	r7[0x6],r8
					}
#endif
					if (disk_read(fp->fs->drv, fp->buf, dsc, 1) != RES_OK)	/* Load current sector */
8000873a:	6e 08       	ld.w	r8,r7[0x0]
8000873c:	30 19       	mov	r9,1
8000873e:	08 9a       	mov	r10,r4
80008740:	ee cb ff d8 	sub	r11,r7,-40
80008744:	11 9c       	ld.ub	r12,r8[0x1]
80008746:	f0 1f 00 67 	mcall	800088e0 <f_lseek+0x2ac>
						ABORT(fp->fs, FR_DISK_ERR);
8000874a:	f9 b8 01 01 	movne	r8,1
8000874e:	ef f8 1e 07 	st.bne	r7[0x7],r8
80008752:	f9 b6 01 01 	movne	r6,1
#endif
					fp->dsect = dsc;
80008756:	ef f4 0a 06 	st.weq	r7[0x18],r4
8000875a:	cb 78       	rjmp	800088c8 <f_lseek+0x294>

	/* Normal Seek */
	{
		if (ofs > fp->fsize					/* In read-only mode, clip offset with the file size */
#if !_FS_READONLY
			 && !(fp->flag & FA_WRITE)
8000875c:	6e 34       	ld.w	r4,r7[0xc]
	} else
#endif

	/* Normal Seek */
	{
		if (ofs > fp->fsize					/* In read-only mode, clip offset with the file size */
8000875e:	08 35       	cp.w	r5,r4
80008760:	e0 88 00 06 	brls	8000876c <f_lseek+0x138>
#if !_FS_READONLY
			 && !(fp->flag & FA_WRITE)
80008764:	0f e8       	ld.ub	r8,r7[0x6]
80008766:	e2 18 00 02 	andl	r8,0x2,COH
8000876a:	c0 20       	breq	8000876e <f_lseek+0x13a>
8000876c:	0a 94       	mov	r4,r5
#endif
			) ofs = fp->fsize;

		ifptr = fp->fptr;
8000876e:	6e 29       	ld.w	r9,r7[0x8]
		fp->fptr = nsect = 0;
80008770:	30 08       	mov	r8,0
80008772:	8f 28       	st.w	r7[0x8],r8
		if (ofs) {
80008774:	58 04       	cp.w	r4,0
80008776:	e0 80 00 a9 	breq	800088c8 <f_lseek+0x294>
			bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
8000877a:	6e 08       	ld.w	r8,r7[0x0]
8000877c:	11 a5       	ld.ub	r5,r8[0x2]
8000877e:	a9 75       	lsl	r5,0x9
			if (ifptr > 0 &&
80008780:	58 09       	cp.w	r9,0
80008782:	c1 30       	breq	800087a8 <f_lseek+0x174>
				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
80008784:	20 19       	sub	r9,1

		ifptr = fp->fptr;
		fp->fptr = nsect = 0;
		if (ofs) {
			bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
			if (ifptr > 0 &&
80008786:	e8 cb 00 01 	sub	r11,r4,1
8000878a:	f6 05 0d 0a 	divu	r10,r11,r5
8000878e:	14 9b       	mov	r11,r10
80008790:	f2 05 0d 02 	divu	r2,r9,r5
80008794:	04 3b       	cp.w	r11,r2
80008796:	c0 93       	brcs	800087a8 <f_lseek+0x174>
				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
				fp->fptr = (ifptr - 1) & ~(bcs - 1);	/* start from the current cluster */
80008798:	ea 08 11 00 	rsub	r8,r5,0
8000879c:	f1 e9 00 09 	and	r9,r8,r9
800087a0:	8f 29       	st.w	r7[0x8],r9
				ofs -= fp->fptr;
800087a2:	12 14       	sub	r4,r9
				clst = fp->clust;
800087a4:	6e 5c       	ld.w	r12,r7[0x14]

		ifptr = fp->fptr;
		fp->fptr = nsect = 0;
		if (ofs) {
			bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
			if (ifptr > 0 &&
800087a6:	c1 68       	rjmp	800087d2 <f_lseek+0x19e>
				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
				fp->fptr = (ifptr - 1) & ~(bcs - 1);	/* start from the current cluster */
				ofs -= fp->fptr;
				clst = fp->clust;
			} else {									/* When seek to back cluster, */
				clst = fp->sclust;						/* start from the first cluster */
800087a8:	6e 4c       	ld.w	r12,r7[0x10]
#if !_FS_READONLY
				if (clst == 0) {						/* If no cluster chain, create a new chain */
800087aa:	58 0c       	cp.w	r12,0
800087ac:	c1 21       	brne	800087d0 <f_lseek+0x19c>
					clst = create_chain(fp->fs, 0);
800087ae:	30 0b       	mov	r11,0
800087b0:	10 9c       	mov	r12,r8
800087b2:	f0 1f 00 4d 	mcall	800088e4 <f_lseek+0x2b0>
					if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
800087b6:	58 1c       	cp.w	r12,1
800087b8:	c0 51       	brne	800087c2 <f_lseek+0x18e>
800087ba:	30 28       	mov	r8,2
800087bc:	ae f8       	st.b	r7[0x7],r8
800087be:	30 26       	mov	r6,2
800087c0:	c8 48       	rjmp	800088c8 <f_lseek+0x294>
					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
800087c2:	5b fc       	cp.w	r12,-1
800087c4:	c0 51       	brne	800087ce <f_lseek+0x19a>
800087c6:	30 18       	mov	r8,1
800087c8:	ae f8       	st.b	r7[0x7],r8
800087ca:	30 16       	mov	r6,1
800087cc:	c7 e8       	rjmp	800088c8 <f_lseek+0x294>
					fp->sclust = clst;
800087ce:	8f 4c       	st.w	r7[0x10],r12
				}
#endif
				fp->clust = clst;
800087d0:	8f 5c       	st.w	r7[0x14],r12
			}
			if (clst != 0) {
800087d2:	58 0c       	cp.w	r12,0
800087d4:	c4 80       	breq	80008864 <f_lseek+0x230>
				while (ofs > bcs) {						/* Cluster following loop */
800087d6:	0a 34       	cp.w	r4,r5
800087d8:	e0 88 00 32 	brls	8000883c <f_lseek+0x208>
#if _FS_MINIMIZE <= 2
/*-----------------------------------------------------------------------*/
/* Seek File R/W Pointer                                                 */
/*-----------------------------------------------------------------------*/

FRESULT f_lseek (
800087dc:	ea 03 11 00 	rsub	r3,r5,0
800087e0:	0a 14       	sub	r4,r5
				fp->clust = clst;
			}
			if (clst != 0) {
				while (ofs > bcs) {						/* Cluster following loop */
#if !_FS_READONLY
					if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
800087e2:	0f e8       	ld.ub	r8,r7[0x6]
800087e4:	e2 18 00 02 	andl	r8,0x2,COH
800087e8:	c0 70       	breq	800087f6 <f_lseek+0x1c2>
						clst = create_chain(fp->fs, clst);	/* Force stretch if in write mode */
800087ea:	18 9b       	mov	r11,r12
800087ec:	6e 0c       	ld.w	r12,r7[0x0]
800087ee:	f0 1f 00 3e 	mcall	800088e4 <f_lseek+0x2b0>
						if (clst == 0) {				/* When disk gets full, clip file size */
800087f2:	c0 61       	brne	800087fe <f_lseek+0x1ca>
800087f4:	c2 38       	rjmp	8000883a <f_lseek+0x206>
							ofs = bcs; break;
						}
					} else
#endif
						clst = get_fat(fp->fs, clst);	/* Follow cluster chain if not in write mode */
800087f6:	18 9b       	mov	r11,r12
800087f8:	6e 0c       	ld.w	r12,r7[0x0]
800087fa:	f0 1f 00 36 	mcall	800088d0 <f_lseek+0x29c>
					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
800087fe:	5b fc       	cp.w	r12,-1
80008800:	c0 51       	brne	8000880a <f_lseek+0x1d6>
80008802:	30 18       	mov	r8,1
80008804:	ae f8       	st.b	r7[0x7],r8
80008806:	30 16       	mov	r6,1
80008808:	c6 08       	rjmp	800088c8 <f_lseek+0x294>
					if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
8000880a:	58 1c       	cp.w	r12,1
8000880c:	e0 88 00 06 	brls	80008818 <f_lseek+0x1e4>
80008810:	6e 08       	ld.w	r8,r7[0x0]
80008812:	70 58       	ld.w	r8,r8[0x14]
80008814:	10 3c       	cp.w	r12,r8
80008816:	c0 53       	brcs	80008820 <f_lseek+0x1ec>
80008818:	30 28       	mov	r8,2
8000881a:	ae f8       	st.b	r7[0x7],r8
8000881c:	30 26       	mov	r6,2
8000881e:	c5 58       	rjmp	800088c8 <f_lseek+0x294>
					fp->clust = clst;
80008820:	8f 5c       	st.w	r7[0x14],r12
					fp->fptr += bcs;
80008822:	6e 28       	ld.w	r8,r7[0x8]
80008824:	0a 08       	add	r8,r5
80008826:	8f 28       	st.w	r7[0x8],r8
80008828:	e8 03 00 08 	add	r8,r4,r3
				}
#endif
				fp->clust = clst;
			}
			if (clst != 0) {
				while (ofs > bcs) {						/* Cluster following loop */
8000882c:	f0 05 00 09 	add	r9,r8,r5
80008830:	0a 39       	cp.w	r9,r5
80008832:	e0 88 00 05 	brls	8000883c <f_lseek+0x208>
80008836:	10 94       	mov	r4,r8
80008838:	cd 5b       	rjmp	800087e2 <f_lseek+0x1ae>
8000883a:	0a 94       	mov	r4,r5
					if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
					fp->clust = clst;
					fp->fptr += bcs;
					ofs -= bcs;
				}
				fp->fptr += ofs;
8000883c:	6e 28       	ld.w	r8,r7[0x8]
8000883e:	08 08       	add	r8,r4
80008840:	8f 28       	st.w	r7[0x8],r8
				if (ofs % SS(fp->fs)) {
80008842:	f1 d4 c0 09 	bfextu	r8,r4,0x0,0x9
80008846:	c0 f0       	breq	80008864 <f_lseek+0x230>
					nsect = clust2sect(fp->fs, clst);	/* Current sector */
80008848:	18 9b       	mov	r11,r12
8000884a:	6e 0c       	ld.w	r12,r7[0x0]
8000884c:	f0 1f 00 23 	mcall	800088d8 <f_lseek+0x2a4>
					if (!nsect) ABORT(fp->fs, FR_INT_ERR);
80008850:	c0 51       	brne	8000885a <f_lseek+0x226>
80008852:	30 28       	mov	r8,2
80008854:	ae f8       	st.b	r7[0x7],r8
80008856:	30 26       	mov	r6,2
80008858:	c3 88       	rjmp	800088c8 <f_lseek+0x294>
					nsect += ofs / SS(fp->fs);
8000885a:	e8 05 16 09 	lsr	r5,r4,0x9
8000885e:	f8 05 00 05 	add	r5,r12,r5
80008862:	c0 28       	rjmp	80008866 <f_lseek+0x232>
80008864:	30 05       	mov	r5,0
				}
			}
		}
		if (fp->fptr % SS(fp->fs) && nsect != fp->dsect) {	/* Fill sector cache if needed */
80008866:	6e 28       	ld.w	r8,r7[0x8]
80008868:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
8000886c:	c2 50       	breq	800088b6 <f_lseek+0x282>
8000886e:	6e 6a       	ld.w	r10,r7[0x18]
80008870:	0a 3a       	cp.w	r10,r5
80008872:	c2 20       	breq	800088b6 <f_lseek+0x282>
#if !_FS_TINY
#if !_FS_READONLY
			if (fp->flag & FA__DIRTY) {			/* Write-back dirty sector cache */
80008874:	0f e8       	ld.ub	r8,r7[0x6]
80008876:	e2 18 00 40 	andl	r8,0x40,COH
8000887a:	c1 00       	breq	8000889a <f_lseek+0x266>
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
8000887c:	6e 08       	ld.w	r8,r7[0x0]
8000887e:	30 19       	mov	r9,1
80008880:	ee cb ff d8 	sub	r11,r7,-40
80008884:	11 9c       	ld.ub	r12,r8[0x1]
80008886:	f0 1f 00 16 	mcall	800088dc <f_lseek+0x2a8>
8000888a:	c0 50       	breq	80008894 <f_lseek+0x260>
					ABORT(fp->fs, FR_DISK_ERR);
8000888c:	30 18       	mov	r8,1
8000888e:	ae f8       	st.b	r7[0x7],r8
80008890:	30 16       	mov	r6,1
80008892:	c1 b8       	rjmp	800088c8 <f_lseek+0x294>
				fp->flag &= ~FA__DIRTY;
80008894:	0f e8       	ld.ub	r8,r7[0x6]
80008896:	a7 c8       	cbr	r8,0x6
80008898:	ae e8       	st.b	r7[0x6],r8
			}
#endif
			if (disk_read(fp->fs->drv, fp->buf, nsect, 1) != RES_OK)	/* Fill sector cache */
8000889a:	6e 08       	ld.w	r8,r7[0x0]
8000889c:	30 19       	mov	r9,1
8000889e:	0a 9a       	mov	r10,r5
800088a0:	ee cb ff d8 	sub	r11,r7,-40
800088a4:	11 9c       	ld.ub	r12,r8[0x1]
800088a6:	f0 1f 00 0f 	mcall	800088e0 <f_lseek+0x2ac>
800088aa:	c0 50       	breq	800088b4 <f_lseek+0x280>
				ABORT(fp->fs, FR_DISK_ERR);
800088ac:	30 18       	mov	r8,1
800088ae:	ae f8       	st.b	r7[0x7],r8
800088b0:	30 16       	mov	r6,1
800088b2:	c0 b8       	rjmp	800088c8 <f_lseek+0x294>
#endif
			fp->dsect = nsect;
800088b4:	8f 65       	st.w	r7[0x18],r5
		}
#if !_FS_READONLY
		if (fp->fptr > fp->fsize) {			/* Set file change flag if the file size is extended */
800088b6:	6e 28       	ld.w	r8,r7[0x8]
800088b8:	6e 39       	ld.w	r9,r7[0xc]
800088ba:	12 38       	cp.w	r8,r9
800088bc:	e0 88 00 06 	brls	800088c8 <f_lseek+0x294>
			fp->fsize = fp->fptr;
800088c0:	8f 38       	st.w	r7[0xc],r8
			fp->flag |= FA__WRITTEN;
800088c2:	0f e8       	ld.ub	r8,r7[0x6]
800088c4:	a5 b8       	sbr	r8,0x5
800088c6:	ae e8       	st.b	r7[0x6],r8
		}
#endif
	}

	LEAVE_FF(fp->fs, res);
}
800088c8:	0c 9c       	mov	r12,r6
800088ca:	d8 32       	popm	r0-r7,pc
800088cc:	80 00       	ld.sh	r0,r0[0x0]
800088ce:	6f 14       	ld.w	r4,r7[0x44]
800088d0:	80 00       	ld.sh	r0,r0[0x0]
800088d2:	76 70       	ld.w	r0,r11[0x1c]
800088d4:	80 00       	ld.sh	r0,r0[0x0]
800088d6:	66 14       	ld.w	r4,r3[0x4]
800088d8:	80 00       	ld.sh	r0,r0[0x0]
800088da:	65 fc       	ld.w	r12,r2[0x7c]
800088dc:	80 00       	ld.sh	r0,r0[0x0]
800088de:	65 88       	ld.w	r8,r2[0x60]
800088e0:	80 00       	ld.sh	r0,r0[0x0]
800088e2:	65 a4       	ld.w	r4,r2[0x68]
800088e4:	80 00       	ld.sh	r0,r0[0x0]
800088e6:	78 08       	ld.w	r8,r12[0x0]

800088e8 <f_write>:
	FIL* fp,			/* Pointer to the file object */
	const void *buff,	/* Pointer to the data to be written */
	UINT btw,			/* Number of bytes to write */
	UINT* bw			/* Pointer to number of bytes written */
)
{
800088e8:	d4 31       	pushm	r0-r7,lr
800088ea:	20 3d       	sub	sp,12
800088ec:	18 97       	mov	r7,r12
800088ee:	16 93       	mov	r3,r11
800088f0:	14 96       	mov	r6,r10
800088f2:	12 94       	mov	r4,r9
	UINT wcnt, cc;
	const BYTE *wbuff = (const BYTE*)buff;
	BYTE csect;


	*bw = 0;	/* Clear write byte counter */
800088f4:	30 08       	mov	r8,0
800088f6:	93 08       	st.w	r9[0x0],r8

	res = validate(fp);						/* Check validity */
800088f8:	f0 1f 00 6d 	mcall	80008aac <f_write+0x1c4>
800088fc:	18 92       	mov	r2,r12
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
800088fe:	e0 81 00 d3 	brne	80008aa4 <f_write+0x1bc>
	if (fp->err)							/* Check error */
80008902:	0f f8       	ld.ub	r8,r7[0x7]
80008904:	58 08       	cp.w	r8,0
80008906:	c0 30       	breq	8000890c <f_write+0x24>
		LEAVE_FF(fp->fs, (FRESULT)fp->err);
80008908:	10 92       	mov	r2,r8
8000890a:	cc d8       	rjmp	80008aa4 <f_write+0x1bc>
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
8000890c:	0f e8       	ld.ub	r8,r7[0x6]
8000890e:	e2 18 00 02 	andl	r8,0x2,COH
80008912:	c0 31       	brne	80008918 <f_write+0x30>
80008914:	30 72       	mov	r2,7
80008916:	cc 78       	rjmp	80008aa4 <f_write+0x1bc>
		LEAVE_FF(fp->fs, FR_DENIED);
	if (fp->fptr + btw < fp->fptr) btw = 0;	/* File size cannot reach 4GB */
80008918:	6e 28       	ld.w	r8,r7[0x8]
8000891a:	ec 08 00 09 	add	r9,r6,r8
8000891e:	12 38       	cp.w	r8,r9
80008920:	e0 8b 00 ba 	brhi	80008a94 <f_write+0x1ac>

	for ( ;  btw;							/* Repeat until all data written */
80008924:	58 06       	cp.w	r6,0
80008926:	e0 80 00 b7 	breq	80008a94 <f_write+0x1ac>
#if _FS_TINY
			if (fp->fs->winsect == fp->dsect && sync_window(fp->fs))	/* Write-back sector cache */
				ABORT(fp->fs, FR_DISK_ERR);
#else
			if (fp->flag & FA__DIRTY) {		/* Write-back sector cache */
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
8000892a:	ee c8 ff d8 	sub	r8,r7,-40
8000892e:	50 18       	stdsp	sp[0x4],r8
					mem_cpy(fp->fs->win, wbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), SS(fp->fs));
					fp->fs->wflag = 0;
				}
#else
				if (fp->dsect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
					mem_cpy(fp->buf, wbuff + ((fp->dsect - sect) * SS(fp->fs)), SS(fp->fs));
80008930:	50 08       	stdsp	sp[0x0],r8
			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
			if (!csect) {					/* On the cluster boundary? */
				if (fp->fptr == 0) {		/* On the top of the file? */
					clst = fp->sclust;		/* Follow from the origin */
					if (clst == 0)			/* When no cluster is allocated, */
						clst = create_chain(fp->fs, 0);	/* Create a new cluster chain */
80008932:	50 2c       	stdsp	sp[0x8],r12
80008934:	0c 95       	mov	r5,r6
		LEAVE_FF(fp->fs, FR_DENIED);
	if (fp->fptr + btw < fp->fptr) btw = 0;	/* File size cannot reach 4GB */

	for ( ;  btw;							/* Repeat until all data written */
		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
		if ((fp->fptr % SS(fp->fs)) == 0) {	/* On the sector boundary? */
80008936:	6e 2b       	ld.w	r11,r7[0x8]
80008938:	f1 db c0 09 	bfextu	r8,r11,0x0,0x9
8000893c:	e0 81 00 8c 	brne	80008a54 <f_write+0x16c>
			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
80008940:	6e 08       	ld.w	r8,r7[0x0]
80008942:	11 a6       	ld.ub	r6,r8[0x2]
80008944:	20 16       	sub	r6,1
80008946:	ed eb 02 96 	and	r6,r6,r11>>0x9
8000894a:	5c 56       	castu.b	r6
			if (!csect) {					/* On the cluster boundary? */
8000894c:	c2 91       	brne	8000899e <f_write+0xb6>
				if (fp->fptr == 0) {		/* On the top of the file? */
8000894e:	58 0b       	cp.w	r11,0
80008950:	c0 81       	brne	80008960 <f_write+0x78>
					clst = fp->sclust;		/* Follow from the origin */
80008952:	6e 4c       	ld.w	r12,r7[0x10]
					if (clst == 0)			/* When no cluster is allocated, */
80008954:	58 0c       	cp.w	r12,0
80008956:	c1 31       	brne	8000897c <f_write+0x94>
						clst = create_chain(fp->fs, 0);	/* Create a new cluster chain */
80008958:	10 9c       	mov	r12,r8
8000895a:	f0 1f 00 56 	mcall	80008ab0 <f_write+0x1c8>
8000895e:	c0 c8       	rjmp	80008976 <f_write+0x8e>
				} else {					/* Middle or end of the file */
#if _USE_FASTSEEK
					if (fp->cltbl)
80008960:	6e 99       	ld.w	r9,r7[0x24]
80008962:	58 09       	cp.w	r9,0
80008964:	c0 50       	breq	8000896e <f_write+0x86>
						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
80008966:	0e 9c       	mov	r12,r7
80008968:	f0 1f 00 53 	mcall	80008ab4 <f_write+0x1cc>
8000896c:	c0 58       	rjmp	80008976 <f_write+0x8e>
					else
#endif
						clst = create_chain(fp->fs, fp->clust);	/* Follow or stretch cluster chain on the FAT */
8000896e:	6e 5b       	ld.w	r11,r7[0x14]
80008970:	10 9c       	mov	r12,r8
80008972:	f0 1f 00 50 	mcall	80008ab0 <f_write+0x1c8>
				}
				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
80008976:	58 0c       	cp.w	r12,0
80008978:	e0 80 00 8b 	breq	80008a8e <f_write+0x1a6>
				if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
8000897c:	58 1c       	cp.w	r12,1
8000897e:	c0 51       	brne	80008988 <f_write+0xa0>
80008980:	30 28       	mov	r8,2
80008982:	ae f8       	st.b	r7[0x7],r8
80008984:	30 22       	mov	r2,2
80008986:	c8 f8       	rjmp	80008aa4 <f_write+0x1bc>
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
80008988:	5b fc       	cp.w	r12,-1
8000898a:	c0 51       	brne	80008994 <f_write+0xac>
8000898c:	30 18       	mov	r8,1
8000898e:	ae f8       	st.b	r7[0x7],r8
80008990:	30 12       	mov	r2,1
80008992:	c8 98       	rjmp	80008aa4 <f_write+0x1bc>
				fp->clust = clst;			/* Update current cluster */
80008994:	8f 5c       	st.w	r7[0x14],r12
				if (fp->sclust == 0) fp->sclust = clst;	/* Set start cluster if the first write */
80008996:	6e 48       	ld.w	r8,r7[0x10]
80008998:	58 08       	cp.w	r8,0
8000899a:	ef fc 0a 04 	st.weq	r7[0x10],r12
			}
#if _FS_TINY
			if (fp->fs->winsect == fp->dsect && sync_window(fp->fs))	/* Write-back sector cache */
				ABORT(fp->fs, FR_DISK_ERR);
#else
			if (fp->flag & FA__DIRTY) {		/* Write-back sector cache */
8000899e:	0f e8       	ld.ub	r8,r7[0x6]
800089a0:	e2 18 00 40 	andl	r8,0x40,COH
800089a4:	c1 00       	breq	800089c4 <f_write+0xdc>
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
800089a6:	6e 08       	ld.w	r8,r7[0x0]
800089a8:	30 19       	mov	r9,1
800089aa:	6e 6a       	ld.w	r10,r7[0x18]
800089ac:	40 1b       	lddsp	r11,sp[0x4]
800089ae:	11 9c       	ld.ub	r12,r8[0x1]
800089b0:	f0 1f 00 42 	mcall	80008ab8 <f_write+0x1d0>
800089b4:	c0 50       	breq	800089be <f_write+0xd6>
					ABORT(fp->fs, FR_DISK_ERR);
800089b6:	30 18       	mov	r8,1
800089b8:	ae f8       	st.b	r7[0x7],r8
800089ba:	30 12       	mov	r2,1
800089bc:	c7 48       	rjmp	80008aa4 <f_write+0x1bc>
				fp->flag &= ~FA__DIRTY;
800089be:	0f e8       	ld.ub	r8,r7[0x6]
800089c0:	a7 c8       	cbr	r8,0x6
800089c2:	ae e8       	st.b	r7[0x6],r8
			}
#endif
			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
800089c4:	6e 01       	ld.w	r1,r7[0x0]
800089c6:	6e 5b       	ld.w	r11,r7[0x14]
800089c8:	02 9c       	mov	r12,r1
800089ca:	f0 1f 00 3d 	mcall	80008abc <f_write+0x1d4>
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
800089ce:	c0 51       	brne	800089d8 <f_write+0xf0>
800089d0:	30 28       	mov	r8,2
800089d2:	ae f8       	st.b	r7[0x7],r8
800089d4:	30 22       	mov	r2,2
800089d6:	c6 78       	rjmp	80008aa4 <f_write+0x1bc>
			sect += csect;
800089d8:	f8 06 00 00 	add	r0,r12,r6
			cc = btw / SS(fp->fs);			/* When remaining bytes >= sector size, */
800089dc:	ea 02 16 09 	lsr	r2,r5,0x9
			if (cc) {						/* Write maximum contiguous sectors directly */
800089e0:	c2 70       	breq	80008a2e <f_write+0x146>
				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
800089e2:	03 a9       	ld.ub	r9,r1[0x2]
800089e4:	e4 06 00 08 	add	r8,r2,r6
					cc = fp->fs->csize - csect;
800089e8:	12 38       	cp.w	r8,r9
800089ea:	f3 d6 eb 12 	subhi	r2,r9,r6
				if (disk_write(fp->fs->drv, wbuff, sect, cc) != RES_OK)
800089ee:	04 99       	mov	r9,r2
800089f0:	00 9a       	mov	r10,r0
800089f2:	06 9b       	mov	r11,r3
800089f4:	03 9c       	ld.ub	r12,r1[0x1]
800089f6:	f0 1f 00 31 	mcall	80008ab8 <f_write+0x1d0>
800089fa:	c0 50       	breq	80008a04 <f_write+0x11c>
					ABORT(fp->fs, FR_DISK_ERR);
800089fc:	30 18       	mov	r8,1
800089fe:	ae f8       	st.b	r7[0x7],r8
80008a00:	30 12       	mov	r2,1
80008a02:	c5 18       	rjmp	80008aa4 <f_write+0x1bc>
				if (fp->fs->winsect - sect < cc) {	/* Refill sector cache if it gets invalidated by the direct write */
					mem_cpy(fp->fs->win, wbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), SS(fp->fs));
					fp->fs->wflag = 0;
				}
#else
				if (fp->dsect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
80008a04:	6e 6b       	ld.w	r11,r7[0x18]
80008a06:	f6 00 01 00 	sub	r0,r11,r0
80008a0a:	00 32       	cp.w	r2,r0
80008a0c:	e0 88 00 0e 	brls	80008a28 <f_write+0x140>
					mem_cpy(fp->buf, wbuff + ((fp->dsect - sect) * SS(fp->fs)), SS(fp->fs));
80008a10:	e0 0b 15 09 	lsl	r11,r0,0x9
80008a14:	e0 6a 02 00 	mov	r10,512
80008a18:	e6 0b 00 0b 	add	r11,r3,r11
80008a1c:	40 0c       	lddsp	r12,sp[0x0]
80008a1e:	f0 1f 00 29 	mcall	80008ac0 <f_write+0x1d8>
					fp->flag &= ~FA__DIRTY;
80008a22:	0f e8       	ld.ub	r8,r7[0x6]
80008a24:	a7 c8       	cbr	r8,0x6
80008a26:	ae e8       	st.b	r7[0x6],r8
				}
#endif
#endif
				wcnt = SS(fp->fs) * cc;		/* Number of bytes transferred */
80008a28:	e4 06 15 09 	lsl	r6,r2,0x9
				continue;
80008a2c:	c2 78       	rjmp	80008a7a <f_write+0x192>
			if (fp->fptr >= fp->fsize) {	/* Avoid silly cache filling at growing edge */
				if (sync_window(fp->fs)) ABORT(fp->fs, FR_DISK_ERR);
				fp->fs->winsect = sect;
			}
#else
			if (fp->dsect != sect) {		/* Fill sector cache with file data */
80008a2e:	6e 68       	ld.w	r8,r7[0x18]
80008a30:	00 38       	cp.w	r8,r0
80008a32:	c1 00       	breq	80008a52 <f_write+0x16a>
				if (fp->fptr < fp->fsize &&
80008a34:	6e 29       	ld.w	r9,r7[0x8]
80008a36:	6e 38       	ld.w	r8,r7[0xc]
80008a38:	10 39       	cp.w	r9,r8
80008a3a:	c0 c2       	brcc	80008a52 <f_write+0x16a>
					disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)
80008a3c:	30 19       	mov	r9,1
80008a3e:	00 9a       	mov	r10,r0
80008a40:	40 1b       	lddsp	r11,sp[0x4]
80008a42:	03 9c       	ld.ub	r12,r1[0x1]
80008a44:	f0 1f 00 20 	mcall	80008ac4 <f_write+0x1dc>
				if (sync_window(fp->fs)) ABORT(fp->fs, FR_DISK_ERR);
				fp->fs->winsect = sect;
			}
#else
			if (fp->dsect != sect) {		/* Fill sector cache with file data */
				if (fp->fptr < fp->fsize &&
80008a48:	c0 50       	breq	80008a52 <f_write+0x16a>
					disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)
						ABORT(fp->fs, FR_DISK_ERR);
80008a4a:	30 18       	mov	r8,1
80008a4c:	ae f8       	st.b	r7[0x7],r8
80008a4e:	30 12       	mov	r2,1
80008a50:	c2 a8       	rjmp	80008aa4 <f_write+0x1bc>
			}
#endif
			fp->dsect = sect;
80008a52:	8f 60       	st.w	r7[0x18],r0
		}
		wcnt = SS(fp->fs) - ((UINT)fp->fptr % SS(fp->fs));/* Put partial sector into file I/O buffer */
80008a54:	6e 2c       	ld.w	r12,r7[0x8]
80008a56:	f9 dc c0 09 	bfextu	r12,r12,0x0,0x9
80008a5a:	e0 66 02 00 	mov	r6,512
80008a5e:	18 16       	sub	r6,r12
80008a60:	0c 35       	cp.w	r5,r6
80008a62:	ea 06 17 80 	movls	r6,r5
		if (move_window(fp->fs, fp->dsect) != FR_OK)	/* Move sector window */
			ABORT(fp->fs, FR_DISK_ERR);
		mem_cpy(&fp->fs->win[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
		fp->fs->wflag = 1;
#else
		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
80008a66:	0c 9a       	mov	r10,r6
80008a68:	06 9b       	mov	r11,r3
80008a6a:	40 08       	lddsp	r8,sp[0x0]
80008a6c:	f0 0c 00 0c 	add	r12,r8,r12
80008a70:	f0 1f 00 14 	mcall	80008ac0 <f_write+0x1d8>
		fp->flag |= FA__DIRTY;
80008a74:	0f e8       	ld.ub	r8,r7[0x6]
80008a76:	a7 a8       	sbr	r8,0x6
80008a78:	ae e8       	st.b	r7[0x6],r8
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
	if (fp->fptr + btw < fp->fptr) btw = 0;	/* File size cannot reach 4GB */

	for ( ;  btw;							/* Repeat until all data written */
		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
80008a7a:	6e 28       	ld.w	r8,r7[0x8]
80008a7c:	0c 08       	add	r8,r6
80008a7e:	8f 28       	st.w	r7[0x8],r8
80008a80:	68 08       	ld.w	r8,r4[0x0]
80008a82:	0c 08       	add	r8,r6
80008a84:	89 08       	st.w	r4[0x0],r8
80008a86:	0c 15       	sub	r5,r6
		LEAVE_FF(fp->fs, (FRESULT)fp->err);
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
	if (fp->fptr + btw < fp->fptr) btw = 0;	/* File size cannot reach 4GB */

	for ( ;  btw;							/* Repeat until all data written */
80008a88:	c0 50       	breq	80008a92 <f_write+0x1aa>
		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
80008a8a:	0c 03       	add	r3,r6
80008a8c:	c5 5b       	rjmp	80008936 <f_write+0x4e>
80008a8e:	40 22       	lddsp	r2,sp[0x8]
80008a90:	c0 28       	rjmp	80008a94 <f_write+0x1ac>
80008a92:	40 22       	lddsp	r2,sp[0x8]
		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
		fp->flag |= FA__DIRTY;
#endif
	}

	if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;	/* Update file size if needed */
80008a94:	6e 28       	ld.w	r8,r7[0x8]
80008a96:	6e 39       	ld.w	r9,r7[0xc]
80008a98:	12 38       	cp.w	r8,r9
80008a9a:	ef f8 ba 03 	st.whi	r7[0xc],r8
	fp->flag |= FA__WRITTEN;						/* Set file change flag */
80008a9e:	0f e8       	ld.ub	r8,r7[0x6]
80008aa0:	a5 b8       	sbr	r8,0x5
80008aa2:	ae e8       	st.b	r7[0x6],r8

	LEAVE_FF(fp->fs, FR_OK);
}
80008aa4:	04 9c       	mov	r12,r2
80008aa6:	2f dd       	sub	sp,-12
80008aa8:	d8 32       	popm	r0-r7,pc
80008aaa:	00 00       	add	r0,r0
80008aac:	80 00       	ld.sh	r0,r0[0x0]
80008aae:	6f 14       	ld.w	r4,r7[0x44]
80008ab0:	80 00       	ld.sh	r0,r0[0x0]
80008ab2:	78 08       	ld.w	r8,r12[0x0]
80008ab4:	80 00       	ld.sh	r0,r0[0x0]
80008ab6:	66 14       	ld.w	r4,r3[0x4]
80008ab8:	80 00       	ld.sh	r0,r0[0x0]
80008aba:	65 88       	ld.w	r8,r2[0x60]
80008abc:	80 00       	ld.sh	r0,r0[0x0]
80008abe:	65 fc       	ld.w	r12,r2[0x7c]
80008ac0:	80 00       	ld.sh	r0,r0[0x0]
80008ac2:	65 c0       	ld.w	r0,r2[0x70]
80008ac4:	80 00       	ld.sh	r0,r0[0x0]
80008ac6:	65 a4       	ld.w	r4,r2[0x68]

80008ac8 <f_read>:
	FIL* fp, 		/* Pointer to the file object */
	void* buff,		/* Pointer to data buffer */
	UINT btr,		/* Number of bytes to read */
	UINT* br		/* Pointer to number of bytes read */
)
{
80008ac8:	d4 31       	pushm	r0-r7,lr
80008aca:	20 3d       	sub	sp,12
80008acc:	18 97       	mov	r7,r12
80008ace:	16 93       	mov	r3,r11
80008ad0:	14 96       	mov	r6,r10
80008ad2:	12 94       	mov	r4,r9
	DWORD clst, sect, remain;
	UINT rcnt, cc;
	BYTE csect, *rbuff = (BYTE*)buff;


	*br = 0;	/* Clear read byte counter */
80008ad4:	30 08       	mov	r8,0
80008ad6:	93 08       	st.w	r9[0x0],r8

	res = validate(fp);							/* Check validity */
80008ad8:	f0 1f 00 5e 	mcall	80008c50 <f_read+0x188>
80008adc:	18 92       	mov	r2,r12
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
80008ade:	e0 81 00 b5 	brne	80008c48 <f_read+0x180>
	if (fp->err)								/* Check error */
80008ae2:	0f f8       	ld.ub	r8,r7[0x7]
80008ae4:	58 08       	cp.w	r8,0
80008ae6:	c0 30       	breq	80008aec <f_read+0x24>
		LEAVE_FF(fp->fs, (FRESULT)fp->err);
80008ae8:	10 92       	mov	r2,r8
80008aea:	ca f8       	rjmp	80008c48 <f_read+0x180>
	if (!(fp->flag & FA_READ)) 					/* Check access mode */
80008aec:	0f e8       	ld.ub	r8,r7[0x6]
80008aee:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80008af2:	e0 80 00 a8 	breq	80008c42 <f_read+0x17a>
80008af6:	6e 35       	ld.w	r5,r7[0xc]
80008af8:	6e 28       	ld.w	r8,r7[0x8]
80008afa:	10 15       	sub	r5,r8
80008afc:	0a 36       	cp.w	r6,r5
80008afe:	ec 05 17 80 	movls	r5,r6
		LEAVE_FF(fp->fs, FR_DENIED);
	remain = fp->fsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */

	for ( ;  btr;								/* Repeat until all data read */
80008b02:	58 05       	cp.w	r5,0
80008b04:	e0 80 00 a2 	breq	80008c48 <f_read+0x180>
#if _FS_TINY
				if (fp->fs->wflag && fp->fs->winsect - sect < cc)
					mem_cpy(rbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), fp->fs->win, SS(fp->fs));
#else
				if ((fp->flag & FA__DIRTY) && fp->dsect - sect < cc)
					mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf, SS(fp->fs));
80008b08:	ee c8 ff d8 	sub	r8,r7,-40
80008b0c:	50 08       	stdsp	sp[0x0],r8
			}
#if !_FS_TINY
			if (fp->dsect != sect) {			/* Load data sector if not in cache */
#if !_FS_READONLY
				if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
					if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
80008b0e:	50 18       	stdsp	sp[0x4],r8
#if _FS_TINY
				if (fp->fs->wflag && fp->fs->winsect - sect < cc)
					mem_cpy(rbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), fp->fs->win, SS(fp->fs));
#else
				if ((fp->flag & FA__DIRTY) && fp->dsect - sect < cc)
					mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf, SS(fp->fs));
80008b10:	50 2c       	stdsp	sp[0x8],r12
	remain = fp->fsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */

	for ( ;  btr;								/* Repeat until all data read */
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
		if ((fp->fptr % SS(fp->fs)) == 0) {		/* On the sector boundary? */
80008b12:	6e 2b       	ld.w	r11,r7[0x8]
80008b14:	f1 db c0 09 	bfextu	r8,r11,0x0,0x9
80008b18:	c7 b1       	brne	80008c0e <f_read+0x146>
			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
80008b1a:	6e 0c       	ld.w	r12,r7[0x0]
80008b1c:	19 a6       	ld.ub	r6,r12[0x2]
80008b1e:	20 16       	sub	r6,1
80008b20:	ed eb 02 96 	and	r6,r6,r11>>0x9
80008b24:	5c 56       	castu.b	r6
			if (!csect) {						/* On the cluster boundary? */
80008b26:	c1 d1       	brne	80008b60 <f_read+0x98>
				if (fp->fptr == 0) {			/* On the top of the file? */
80008b28:	58 0b       	cp.w	r11,0
80008b2a:	c0 31       	brne	80008b30 <f_read+0x68>
					clst = fp->sclust;			/* Follow from the origin */
80008b2c:	6e 4c       	ld.w	r12,r7[0x10]
80008b2e:	c0 b8       	rjmp	80008b44 <f_read+0x7c>
				} else {						/* Middle or end of the file */
#if _USE_FASTSEEK
					if (fp->cltbl)
80008b30:	6e 98       	ld.w	r8,r7[0x24]
80008b32:	58 08       	cp.w	r8,0
80008b34:	c0 50       	breq	80008b3e <f_read+0x76>
						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
80008b36:	0e 9c       	mov	r12,r7
80008b38:	f0 1f 00 47 	mcall	80008c54 <f_read+0x18c>
80008b3c:	c0 48       	rjmp	80008b44 <f_read+0x7c>
					else
#endif
						clst = get_fat(fp->fs, fp->clust);	/* Follow cluster chain on the FAT */
80008b3e:	6e 5b       	ld.w	r11,r7[0x14]
80008b40:	f0 1f 00 46 	mcall	80008c58 <f_read+0x190>
				}
				if (clst < 2) ABORT(fp->fs, FR_INT_ERR);
80008b44:	58 1c       	cp.w	r12,1
80008b46:	e0 8b 00 06 	brhi	80008b52 <f_read+0x8a>
80008b4a:	30 28       	mov	r8,2
80008b4c:	ae f8       	st.b	r7[0x7],r8
80008b4e:	30 22       	mov	r2,2
80008b50:	c7 c8       	rjmp	80008c48 <f_read+0x180>
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
80008b52:	5b fc       	cp.w	r12,-1
80008b54:	c0 51       	brne	80008b5e <f_read+0x96>
80008b56:	30 18       	mov	r8,1
80008b58:	ae f8       	st.b	r7[0x7],r8
80008b5a:	30 12       	mov	r2,1
80008b5c:	c7 68       	rjmp	80008c48 <f_read+0x180>
				fp->clust = clst;				/* Update current cluster */
80008b5e:	8f 5c       	st.w	r7[0x14],r12
			}
			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
80008b60:	6e 01       	ld.w	r1,r7[0x0]
80008b62:	6e 5b       	ld.w	r11,r7[0x14]
80008b64:	02 9c       	mov	r12,r1
80008b66:	f0 1f 00 3e 	mcall	80008c5c <f_read+0x194>
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
80008b6a:	c0 51       	brne	80008b74 <f_read+0xac>
80008b6c:	30 28       	mov	r8,2
80008b6e:	ae f8       	st.b	r7[0x7],r8
80008b70:	30 22       	mov	r2,2
80008b72:	c6 b8       	rjmp	80008c48 <f_read+0x180>
			sect += csect;
80008b74:	f8 06 00 00 	add	r0,r12,r6
			cc = btr / SS(fp->fs);				/* When remaining bytes >= sector size, */
80008b78:	ea 02 16 09 	lsr	r2,r5,0x9
			if (cc) {							/* Read maximum contiguous sectors directly */
80008b7c:	c2 80       	breq	80008bcc <f_read+0x104>
				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
80008b7e:	03 a9       	ld.ub	r9,r1[0x2]
80008b80:	e4 06 00 08 	add	r8,r2,r6
					cc = fp->fs->csize - csect;
80008b84:	12 38       	cp.w	r8,r9
80008b86:	f3 d6 eb 12 	subhi	r2,r9,r6
				if (disk_read(fp->fs->drv, rbuff, sect, cc) != RES_OK)
80008b8a:	04 99       	mov	r9,r2
80008b8c:	00 9a       	mov	r10,r0
80008b8e:	06 9b       	mov	r11,r3
80008b90:	03 9c       	ld.ub	r12,r1[0x1]
80008b92:	f0 1f 00 34 	mcall	80008c60 <f_read+0x198>
80008b96:	c0 50       	breq	80008ba0 <f_read+0xd8>
					ABORT(fp->fs, FR_DISK_ERR);
80008b98:	30 18       	mov	r8,1
80008b9a:	ae f8       	st.b	r7[0x7],r8
80008b9c:	30 12       	mov	r2,1
80008b9e:	c5 58       	rjmp	80008c48 <f_read+0x180>
#if !_FS_READONLY && _FS_MINIMIZE <= 2			/* Replace one of the read sectors with cached data if it contains a dirty sector */
#if _FS_TINY
				if (fp->fs->wflag && fp->fs->winsect - sect < cc)
					mem_cpy(rbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), fp->fs->win, SS(fp->fs));
#else
				if ((fp->flag & FA__DIRTY) && fp->dsect - sect < cc)
80008ba0:	0f e8       	ld.ub	r8,r7[0x6]
80008ba2:	e2 18 00 40 	andl	r8,0x40,COH
80008ba6:	c1 00       	breq	80008bc6 <f_read+0xfe>
80008ba8:	6e 6c       	ld.w	r12,r7[0x18]
80008baa:	f8 00 01 00 	sub	r0,r12,r0
80008bae:	00 32       	cp.w	r2,r0
80008bb0:	e0 88 00 0b 	brls	80008bc6 <f_read+0xfe>
					mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf, SS(fp->fs));
80008bb4:	e0 0c 15 09 	lsl	r12,r0,0x9
80008bb8:	e0 6a 02 00 	mov	r10,512
80008bbc:	40 0b       	lddsp	r11,sp[0x0]
80008bbe:	e6 0c 00 0c 	add	r12,r3,r12
80008bc2:	f0 1f 00 29 	mcall	80008c64 <f_read+0x19c>
#endif
#endif
				rcnt = SS(fp->fs) * cc;			/* Number of bytes transferred */
80008bc6:	e4 06 15 09 	lsl	r6,r2,0x9
				continue;
80008bca:	c3 28       	rjmp	80008c2e <f_read+0x166>
			}
#if !_FS_TINY
			if (fp->dsect != sect) {			/* Load data sector if not in cache */
80008bcc:	6e 6a       	ld.w	r10,r7[0x18]
80008bce:	00 3a       	cp.w	r10,r0
80008bd0:	c1 e0       	breq	80008c0c <f_read+0x144>
#if !_FS_READONLY
				if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
80008bd2:	0f e8       	ld.ub	r8,r7[0x6]
80008bd4:	e2 18 00 40 	andl	r8,0x40,COH
80008bd8:	c0 e0       	breq	80008bf4 <f_read+0x12c>
					if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
80008bda:	30 19       	mov	r9,1
80008bdc:	40 1b       	lddsp	r11,sp[0x4]
80008bde:	03 9c       	ld.ub	r12,r1[0x1]
80008be0:	f0 1f 00 22 	mcall	80008c68 <f_read+0x1a0>
80008be4:	c0 50       	breq	80008bee <f_read+0x126>
						ABORT(fp->fs, FR_DISK_ERR);
80008be6:	30 18       	mov	r8,1
80008be8:	ae f8       	st.b	r7[0x7],r8
80008bea:	30 12       	mov	r2,1
80008bec:	c2 e8       	rjmp	80008c48 <f_read+0x180>
					fp->flag &= ~FA__DIRTY;
80008bee:	0f e8       	ld.ub	r8,r7[0x6]
80008bf0:	a7 c8       	cbr	r8,0x6
80008bf2:	ae e8       	st.b	r7[0x6],r8
				}
#endif
				if (disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)	/* Fill sector cache */
80008bf4:	6e 08       	ld.w	r8,r7[0x0]
80008bf6:	30 19       	mov	r9,1
80008bf8:	00 9a       	mov	r10,r0
80008bfa:	40 1b       	lddsp	r11,sp[0x4]
80008bfc:	11 9c       	ld.ub	r12,r8[0x1]
80008bfe:	f0 1f 00 19 	mcall	80008c60 <f_read+0x198>
80008c02:	c0 50       	breq	80008c0c <f_read+0x144>
					ABORT(fp->fs, FR_DISK_ERR);
80008c04:	30 18       	mov	r8,1
80008c06:	ae f8       	st.b	r7[0x7],r8
80008c08:	30 12       	mov	r2,1
80008c0a:	c1 f8       	rjmp	80008c48 <f_read+0x180>
			}
#endif
			fp->dsect = sect;
80008c0c:	8f 60       	st.w	r7[0x18],r0
		}
		rcnt = SS(fp->fs) - ((UINT)fp->fptr % SS(fp->fs));	/* Get partial sector data from sector buffer */
80008c0e:	6e 2b       	ld.w	r11,r7[0x8]
80008c10:	f7 db c0 09 	bfextu	r11,r11,0x0,0x9
80008c14:	e0 66 02 00 	mov	r6,512
80008c18:	16 16       	sub	r6,r11
80008c1a:	0c 35       	cp.w	r5,r6
80008c1c:	ea 06 17 80 	movls	r6,r5
#if _FS_TINY
		if (move_window(fp->fs, fp->dsect) != FR_OK)		/* Move sector window */
			ABORT(fp->fs, FR_DISK_ERR);
		mem_cpy(rbuff, &fp->fs->win[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
#else
		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
80008c20:	0c 9a       	mov	r10,r6
80008c22:	40 08       	lddsp	r8,sp[0x0]
80008c24:	f0 0b 00 0b 	add	r11,r8,r11
80008c28:	06 9c       	mov	r12,r3
80008c2a:	f0 1f 00 0f 	mcall	80008c64 <f_read+0x19c>
		LEAVE_FF(fp->fs, FR_DENIED);
	remain = fp->fsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */

	for ( ;  btr;								/* Repeat until all data read */
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
80008c2e:	6e 28       	ld.w	r8,r7[0x8]
80008c30:	0c 08       	add	r8,r6
80008c32:	8f 28       	st.w	r7[0x8],r8
80008c34:	68 08       	ld.w	r8,r4[0x0]
80008c36:	0c 08       	add	r8,r6
80008c38:	89 08       	st.w	r4[0x0],r8
80008c3a:	0c 15       	sub	r5,r6
	if (!(fp->flag & FA_READ)) 					/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
	remain = fp->fsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */

	for ( ;  btr;								/* Repeat until all data read */
80008c3c:	c0 50       	breq	80008c46 <f_read+0x17e>
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
80008c3e:	0c 03       	add	r3,r6
80008c40:	c6 9b       	rjmp	80008b12 <f_read+0x4a>
80008c42:	30 72       	mov	r2,7
80008c44:	c0 28       	rjmp	80008c48 <f_read+0x180>
80008c46:	40 22       	lddsp	r2,sp[0x8]
		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
#endif
	}

	LEAVE_FF(fp->fs, FR_OK);
}
80008c48:	04 9c       	mov	r12,r2
80008c4a:	2f dd       	sub	sp,-12
80008c4c:	d8 32       	popm	r0-r7,pc
80008c4e:	00 00       	add	r0,r0
80008c50:	80 00       	ld.sh	r0,r0[0x0]
80008c52:	6f 14       	ld.w	r4,r7[0x44]
80008c54:	80 00       	ld.sh	r0,r0[0x0]
80008c56:	66 14       	ld.w	r4,r3[0x4]
80008c58:	80 00       	ld.sh	r0,r0[0x0]
80008c5a:	76 70       	ld.w	r0,r11[0x1c]
80008c5c:	80 00       	ld.sh	r0,r0[0x0]
80008c5e:	65 fc       	ld.w	r12,r2[0x7c]
80008c60:	80 00       	ld.sh	r0,r0[0x0]
80008c62:	65 a4       	ld.w	r4,r2[0x68]
80008c64:	80 00       	ld.sh	r0,r0[0x0]
80008c66:	65 c0       	ld.w	r0,r2[0x70]
80008c68:	80 00       	ld.sh	r0,r0[0x0]
80008c6a:	65 88       	ld.w	r8,r2[0x60]

80008c6c <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
80008c6c:	f8 c8 ff f8 	sub	r8,r12,-8
80008c70:	99 18       	st.w	r12[0x4],r8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
80008c72:	3f f9       	mov	r9,-1
80008c74:	99 29       	st.w	r12[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
80008c76:	99 38       	st.w	r12[0xc],r8
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
80008c78:	99 48       	st.w	r12[0x10],r8

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
80008c7a:	30 08       	mov	r8,0
80008c7c:	99 08       	st.w	r12[0x0],r8
}
80008c7e:	5e fc       	retal	r12

80008c80 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
80008c80:	30 08       	mov	r8,0
80008c82:	99 48       	st.w	r12[0x10],r8
}
80008c84:	5e fc       	retal	r12

80008c86 <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
80008c86:	78 18       	ld.w	r8,r12[0x4]

	pxNewListItem->pxNext = pxIndex->pxNext;
80008c88:	70 19       	ld.w	r9,r8[0x4]
80008c8a:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
80008c8c:	78 19       	ld.w	r9,r12[0x4]
80008c8e:	97 29       	st.w	r11[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80008c90:	70 19       	ld.w	r9,r8[0x4]
80008c92:	93 2b       	st.w	r9[0x8],r11
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
80008c94:	91 1b       	st.w	r8[0x4],r11
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
80008c96:	99 1b       	st.w	r12[0x4],r11

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80008c98:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80008c9a:	78 08       	ld.w	r8,r12[0x0]
80008c9c:	2f f8       	sub	r8,-1
80008c9e:	99 08       	st.w	r12[0x0],r8
}
80008ca0:	5e fc       	retal	r12

80008ca2 <vListInsert>:
{
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
80008ca2:	76 0a       	ld.w	r10,r11[0x0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
80008ca4:	5b fa       	cp.w	r10,-1
80008ca6:	c0 31       	brne	80008cac <vListInsert+0xa>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
80008ca8:	78 48       	ld.w	r8,r12[0x10]
80008caa:	c0 c8       	rjmp	80008cc2 <vListInsert+0x20>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
80008cac:	f8 c8 ff f8 	sub	r8,r12,-8
80008cb0:	70 19       	ld.w	r9,r8[0x4]
80008cb2:	72 09       	ld.w	r9,r9[0x0]
80008cb4:	12 3a       	cp.w	r10,r9
80008cb6:	c0 63       	brcs	80008cc2 <vListInsert+0x20>
80008cb8:	70 18       	ld.w	r8,r8[0x4]
80008cba:	70 19       	ld.w	r9,r8[0x4]
80008cbc:	72 09       	ld.w	r9,r9[0x0]
80008cbe:	12 3a       	cp.w	r10,r9
80008cc0:	cf c2       	brcc	80008cb8 <vListInsert+0x16>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
80008cc2:	70 19       	ld.w	r9,r8[0x4]
80008cc4:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80008cc6:	93 2b       	st.w	r9[0x8],r11
	pxNewListItem->pxPrevious = pxIterator;
80008cc8:	97 28       	st.w	r11[0x8],r8
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
80008cca:	91 1b       	st.w	r8[0x4],r11

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80008ccc:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80008cce:	78 08       	ld.w	r8,r12[0x0]
80008cd0:	2f f8       	sub	r8,-1
80008cd2:	99 08       	st.w	r12[0x0],r8
}
80008cd4:	5e fc       	retal	r12

80008cd6 <vListRemove>:

void vListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
80008cd6:	78 18       	ld.w	r8,r12[0x4]
80008cd8:	78 29       	ld.w	r9,r12[0x8]
80008cda:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
80008cdc:	78 28       	ld.w	r8,r12[0x8]
80008cde:	78 19       	ld.w	r9,r12[0x4]
80008ce0:	91 19       	st.w	r8[0x4],r9

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
80008ce2:	78 48       	ld.w	r8,r12[0x10]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
80008ce4:	70 19       	ld.w	r9,r8[0x4]
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
80008ce6:	18 39       	cp.w	r9,r12
80008ce8:	f9 f9 00 02 	ld.weq	r9,r12[0x8]
80008cec:	f1 f9 0a 01 	st.weq	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
80008cf0:	30 09       	mov	r9,0
80008cf2:	99 49       	st.w	r12[0x10],r9
	( pxList->uxNumberOfItems )--;
80008cf4:	70 09       	ld.w	r9,r8[0x0]
80008cf6:	20 19       	sub	r9,1
80008cf8:	91 09       	st.w	r8[0x0],r9
}
80008cfa:	5e fc       	retal	r12

80008cfc <pxPortInitialiseStack>:
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x08080808;					/* R8 */
80008cfc:	e0 68 08 08 	mov	r8,2056
80008d00:	ea 18 08 08 	orh	r8,0x808
80008d04:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x09090909;					/* R9 */
80008d06:	e0 68 09 09 	mov	r8,2313
80008d0a:	ea 18 09 09 	orh	r8,0x909
80008d0e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0A0A0A0A;					/* R10 */
80008d10:	e0 68 0a 0a 	mov	r8,2570
80008d14:	ea 18 0a 0a 	orh	r8,0xa0a
80008d18:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0B0B0B0B;					/* R11 */
80008d1a:	e0 68 0b 0b 	mov	r8,2827
80008d1e:	ea 18 0b 0b 	orh	r8,0xb0b
80008d22:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pvParameters;					/* R12 */
80008d24:	18 da       	st.w	--r12,r10
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xDEADBEEF;					/* R14/LR */
80008d26:	e0 68 be ef 	mov	r8,48879
80008d2a:	ea 18 de ad 	orh	r8,0xdead
80008d2e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
80008d30:	18 db       	st.w	--r12,r11
	*pxTopOfStack-- = ( portSTACK_TYPE ) portINITIAL_SR;				/* SR */
80008d32:	fc 18 00 40 	movh	r8,0x40
80008d36:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xFF0000FF;					/* R0 */
80008d38:	e0 68 00 ff 	mov	r8,255
80008d3c:	ea 18 ff 00 	orh	r8,0xff00
80008d40:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x01010101;					/* R1 */
80008d42:	e0 68 01 01 	mov	r8,257
80008d46:	ea 18 01 01 	orh	r8,0x101
80008d4a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x02020202;					/* R2 */
80008d4c:	e0 68 02 02 	mov	r8,514
80008d50:	ea 18 02 02 	orh	r8,0x202
80008d54:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x03030303;					/* R3 */
80008d56:	e0 68 03 03 	mov	r8,771
80008d5a:	ea 18 03 03 	orh	r8,0x303
80008d5e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x04040404;					/* R4 */
80008d60:	e0 68 04 04 	mov	r8,1028
80008d64:	ea 18 04 04 	orh	r8,0x404
80008d68:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x05050505;					/* R5 */
80008d6a:	e0 68 05 05 	mov	r8,1285
80008d6e:	ea 18 05 05 	orh	r8,0x505
80008d72:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x06060606;					/* R6 */
80008d74:	e0 68 06 06 	mov	r8,1542
80008d78:	ea 18 06 06 	orh	r8,0x606
80008d7c:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x07070707;					/* R7 */
80008d7e:	e0 68 07 07 	mov	r8,1799
80008d82:	ea 18 07 07 	orh	r8,0x707
80008d86:	18 d8       	st.w	--r12,r8
	*pxTopOfStack = ( portSTACK_TYPE ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
80008d88:	30 08       	mov	r8,0
80008d8a:	18 d8       	st.w	--r12,r8

	return pxTopOfStack;
}
80008d8c:	5e fc       	retal	r12
80008d8e:	d7 03       	nop

80008d90 <vPortEnterCritical>:
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
80008d90:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
80008d92:	48 38       	lddpc	r8,80008d9c <vPortEnterCritical+0xc>
80008d94:	70 09       	ld.w	r9,r8[0x0]
80008d96:	2f f9       	sub	r9,-1
80008d98:	91 09       	st.w	r8[0x0],r9
}
80008d9a:	5e fc       	retal	r12
80008d9c:	00 00       	add	r0,r0
80008d9e:	05 30       	ld.ub	r0,r2++

80008da0 <xPortStartScheduler>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
80008da0:	d4 01       	pushm	lr
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
80008da2:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
80008da4:	30 0a       	mov	r10,0
80008da6:	14 9b       	mov	r11,r10
80008da8:	49 2c       	lddpc	r12,80008df0 <xPortStartScheduler+0x50>
80008daa:	f0 1f 00 13 	mcall	80008df4 <xPortStartScheduler+0x54>
/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);//cause!!!
80008dae:	e0 68 5d c0 	mov	r8,24000
80008db2:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
80008db6:	30 08       	mov	r8,0
80008db8:	e3 b8 00 42 	mtsr	0x108,r8
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Start the first task. */
	portRESTORE_CONTEXT();
80008dbc:	e0 68 12 a4 	mov	r8,4772
80008dc0:	ea 18 00 00 	orh	r8,0x0
80008dc4:	70 00       	ld.w	r0,r8[0x0]
80008dc6:	60 0d       	ld.w	sp,r0[0x0]
80008dc8:	1b 00       	ld.w	r0,sp++
80008dca:	e0 68 05 30 	mov	r8,1328
80008dce:	ea 18 00 00 	orh	r8,0x0
80008dd2:	91 00       	st.w	r8[0x0],r0
80008dd4:	e3 cd 00 ff 	ldm	sp++,r0-r7
80008dd8:	2f ed       	sub	sp,-8
80008dda:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
80008dde:	fa f0 ff e0 	ld.w	r0,sp[-32]
80008de2:	e3 b0 00 00 	mtsr	0x0,r0
80008de6:	fa f0 ff dc 	ld.w	r0,sp[-36]
80008dea:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
}
80008dee:	d8 0a       	popm	pc,r12=0
80008df0:	80 00       	ld.sh	r0,r0[0x0]
80008df2:	8e bc       	ld.uh	r12,r7[0x6]
80008df4:	80 00       	ld.sh	r0,r0[0x0]
80008df6:	5c bc       	swap.b	r12

80008df8 <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
80008df8:	20 6d       	sub	sp,24
80008dfa:	eb cd 00 ff 	pushm	r0-r7
80008dfe:	fa c7 ff c0 	sub	r7,sp,-64
80008e02:	ee f0 ff f8 	ld.w	r0,r7[-8]
80008e06:	ef 40 ff e0 	st.w	r7[-32],r0
80008e0a:	ee f0 ff fc 	ld.w	r0,r7[-4]
80008e0e:	ef 40 ff e4 	st.w	r7[-28],r0
80008e12:	eb c7 5f 00 	stm	--r7,r8-r12,lr
80008e16:	e0 68 05 30 	mov	r8,1328
80008e1a:	ea 18 00 00 	orh	r8,0x0
80008e1e:	70 00       	ld.w	r0,r8[0x0]
80008e20:	1a d0       	st.w	--sp,r0
80008e22:	f0 1f 00 1a 	mcall	80008e88 <LABEL_RET_SCALL_263+0x14>
80008e26:	e0 68 12 a4 	mov	r8,4772
80008e2a:	ea 18 00 00 	orh	r8,0x0
80008e2e:	70 00       	ld.w	r0,r8[0x0]
80008e30:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
80008e32:	f0 1f 00 17 	mcall	80008e8c <LABEL_RET_SCALL_263+0x18>
	portRESTORE_CONTEXT_SCALL();
80008e36:	e0 68 12 a4 	mov	r8,4772
80008e3a:	ea 18 00 00 	orh	r8,0x0
80008e3e:	70 00       	ld.w	r0,r8[0x0]
80008e40:	60 0d       	ld.w	sp,r0[0x0]
80008e42:	1b 00       	ld.w	r0,sp++
80008e44:	e0 68 05 30 	mov	r8,1328
80008e48:	ea 18 00 00 	orh	r8,0x0
80008e4c:	91 00       	st.w	r8[0x0],r0
80008e4e:	fa c7 ff d8 	sub	r7,sp,-40
80008e52:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
80008e56:	ee f0 ff e0 	ld.w	r0,r7[-32]
80008e5a:	e0 61 05 30 	mov	r1,1328
80008e5e:	ea 11 00 00 	orh	r1,0x0
80008e62:	62 02       	ld.w	r2,r1[0x0]
80008e64:	58 02       	cp.w	r2,0
80008e66:	c0 70       	breq	80008e74 <LABEL_RET_SCALL_263>
80008e68:	e4 c2 00 01 	sub	r2,r2,1
80008e6c:	83 02       	st.w	r1[0x0],r2
80008e6e:	58 02       	cp.w	r2,0
80008e70:	c0 21       	brne	80008e74 <LABEL_RET_SCALL_263>
80008e72:	b1 c0       	cbr	r0,0x10

80008e74 <LABEL_RET_SCALL_263>:
80008e74:	ef 40 ff f8 	st.w	r7[-8],r0
80008e78:	ee f0 ff e4 	ld.w	r0,r7[-28]
80008e7c:	ef 40 ff fc 	st.w	r7[-4],r0
80008e80:	e3 cd 00 ff 	ldm	sp++,r0-r7
80008e84:	2f ad       	sub	sp,-24
80008e86:	d6 13       	rets
80008e88:	80 00       	ld.sh	r0,r0[0x0]
80008e8a:	8d 90       	st.w	r6[0x24],r0
80008e8c:	80 00       	ld.sh	r0,r0[0x0]
80008e8e:	95 2c       	st.w	r10[0x8],r12

80008e90 <prvClearCcInt>:
		Set_system_register(AVR32_COUNT, 0);
	}

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
80008e90:	e1 b8 00 43 	mfsr	r8,0x10c
80008e94:	e3 b8 00 43 	mtsr	0x10c,r8
	}
80008e98:	5e fc       	retal	r12
80008e9a:	d7 03       	nop

80008e9c <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
80008e9c:	48 78       	lddpc	r8,80008eb8 <vPortExitCritical+0x1c>
80008e9e:	70 08       	ld.w	r8,r8[0x0]
80008ea0:	58 08       	cp.w	r8,0
80008ea2:	5e 0c       	reteq	r12
	{
		ulCriticalNesting--;
80008ea4:	48 58       	lddpc	r8,80008eb8 <vPortExitCritical+0x1c>
80008ea6:	70 09       	ld.w	r9,r8[0x0]
80008ea8:	20 19       	sub	r9,1
80008eaa:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
80008eac:	70 08       	ld.w	r8,r8[0x0]
80008eae:	58 08       	cp.w	r8,0
80008eb0:	5e 1c       	retne	r12
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
80008eb2:	d5 03       	csrf	0x10
80008eb4:	5e fc       	retal	r12
80008eb6:	00 00       	add	r0,r0
80008eb8:	00 00       	add	r0,r0
80008eba:	05 30       	ld.ub	r0,r2++

80008ebc <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
80008ebc:	eb cd 00 ff 	pushm	r0-r7
80008ec0:	e0 68 05 30 	mov	r8,1328
80008ec4:	ea 18 00 00 	orh	r8,0x0
80008ec8:	70 00       	ld.w	r0,r8[0x0]
80008eca:	1a d0       	st.w	--sp,r0
80008ecc:	7a 90       	ld.w	r0,sp[0x24]
80008ece:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80008ed2:	58 10       	cp.w	r0,1
80008ed4:	e0 8b 00 08 	brhi	80008ee4 <LABEL_INT_SKIP_SAVE_CONTEXT_237>
80008ed8:	e0 68 12 a4 	mov	r8,4772
80008edc:	ea 18 00 00 	orh	r8,0x0
80008ee0:	70 00       	ld.w	r0,r8[0x0]
80008ee2:	81 0d       	st.w	r0[0x0],sp

80008ee4 <LABEL_INT_SKIP_SAVE_CONTEXT_237>:
	#if( configTICK_USE_TC==1 )
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Clear the interrupt flag. */
		prvClearCcInt();
80008ee4:	f0 1f 00 12 	mcall	80008f2c <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
80008ee8:	f0 1f 00 12 	mcall	80008f30 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
		vTaskIncrementTick();
80008eec:	f0 1f 00 12 	mcall	80008f34 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x1c>
	portEXIT_CRITICAL();
80008ef0:	f0 1f 00 12 	mcall	80008f38 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
80008ef4:	7a 90       	ld.w	r0,sp[0x24]
80008ef6:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80008efa:	58 10       	cp.w	r0,1
80008efc:	e0 8b 00 0e 	brhi	80008f18 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>
80008f00:	f0 1f 00 0c 	mcall	80008f30 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
80008f04:	f0 1f 00 0e 	mcall	80008f3c <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x24>
80008f08:	f0 1f 00 0c 	mcall	80008f38 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>
80008f0c:	e0 68 12 a4 	mov	r8,4772
80008f10:	ea 18 00 00 	orh	r8,0x0
80008f14:	70 00       	ld.w	r0,r8[0x0]
80008f16:	60 0d       	ld.w	sp,r0[0x0]

80008f18 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>:
80008f18:	1b 00       	ld.w	r0,sp++
80008f1a:	e0 68 05 30 	mov	r8,1328
80008f1e:	ea 18 00 00 	orh	r8,0x0
80008f22:	91 00       	st.w	r8[0x0],r0
80008f24:	e3 cd 00 ff 	ldm	sp++,r0-r7
80008f28:	d6 03       	rete
80008f2a:	00 00       	add	r0,r0
80008f2c:	80 00       	ld.sh	r0,r0[0x0]
80008f2e:	8e 90       	ld.uh	r0,r7[0x2]
80008f30:	80 00       	ld.sh	r0,r0[0x0]
80008f32:	8d 90       	st.w	r6[0x24],r0
80008f34:	80 00       	ld.sh	r0,r0[0x0]
80008f36:	97 30       	st.w	r11[0xc],r0
80008f38:	80 00       	ld.sh	r0,r0[0x0]
80008f3a:	8e 9c       	ld.uh	r12,r7[0x2]
80008f3c:	80 00       	ld.sh	r0,r0[0x0]
80008f3e:	95 2c       	st.w	r10[0x8],r12

80008f40 <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
80008f40:	d4 01       	pushm	lr
	vTaskSuspendAll();
80008f42:	f0 1f 00 02 	mcall	80008f48 <__malloc_lock+0x8>
}
80008f46:	d8 02       	popm	pc
80008f48:	80 00       	ld.sh	r0,r0[0x0]
80008f4a:	95 1c       	st.w	r10[0x4],r12

80008f4c <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
80008f4c:	d4 01       	pushm	lr
	xTaskResumeAll();
80008f4e:	f0 1f 00 02 	mcall	80008f54 <__malloc_unlock+0x8>
}
80008f52:	d8 02       	popm	pc
80008f54:	80 00       	ld.sh	r0,r0[0x0]
80008f56:	98 d8       	ld.uh	r8,r12[0xa]

80008f58 <_read>:
/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
{
80008f58:	d4 21       	pushm	r4-r7,lr
80008f5a:	16 95       	mov	r5,r11
80008f5c:	14 96       	mov	r6,r10
  int nChars = 0;

  if (file != 0)
80008f5e:	58 0c       	cp.w	r12,0
80008f60:	c0 30       	breq	80008f66 <_read+0xe>
80008f62:	3f f7       	mov	r7,-1
80008f64:	c1 48       	rjmp	80008f8c <_read+0x34>
    return -1;

  for (; len > 0; --len)
80008f66:	58 0a       	cp.w	r10,0
80008f68:	e0 89 00 04 	brgt	80008f70 <_read+0x18>
80008f6c:	30 07       	mov	r7,0
80008f6e:	c0 f8       	rjmp	80008f8c <_read+0x34>
80008f70:	30 07       	mov	r7,0
  {
    int c = usart_getchar(stdio_usart_base);
80008f72:	48 84       	lddpc	r4,80008f90 <_read+0x38>
80008f74:	68 0c       	ld.w	r12,r4[0x0]
80008f76:	f0 1f 00 08 	mcall	80008f94 <_read+0x3c>
    if (c < 0)
80008f7a:	c0 95       	brlt	80008f8c <_read+0x34>
      break;

    *ptr++ = c;
80008f7c:	ea 07 0b 0c 	st.b	r5[r7],r12
    ++nChars;
80008f80:	2f f7       	sub	r7,-1

/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
80008f82:	ec 07 01 08 	sub	r8,r6,r7
  int nChars = 0;

  if (file != 0)
    return -1;

  for (; len > 0; --len)
80008f86:	58 08       	cp.w	r8,0
80008f88:	fe 99 ff f6 	brgt	80008f74 <_read+0x1c>
    *ptr++ = c;
    ++nChars;
  }

  return nChars;
}
80008f8c:	0e 9c       	mov	r12,r7
80008f8e:	d8 22       	popm	r4-r7,pc
80008f90:	00 00       	add	r0,r0
80008f92:	46 a0       	lddsp	r0,sp[0x1a8]
80008f94:	80 00       	ld.sh	r0,r0[0x0]
80008f96:	63 b0       	ld.w	r0,r1[0x6c]

80008f98 <_write>:
 * 1 and 2 is stdout and stderr which goes to usart
 * 3 is framebuffer
 */
int __attribute__((weak))
_write (int file, char * ptr, int len)
{
80008f98:	d4 21       	pushm	r4-r7,lr
80008f9a:	16 95       	mov	r5,r11
80008f9c:	14 96       	mov	r6,r10
  int nChars = 0;

  if ( (file != 1)
80008f9e:	20 1c       	sub	r12,1
80008fa0:	58 2c       	cp.w	r12,2
80008fa2:	e0 8b 00 12 	brhi	80008fc6 <_write+0x2e>
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80008fa6:	58 0a       	cp.w	r10,0
80008fa8:	c0 31       	brne	80008fae <_write+0x16>
80008faa:	30 07       	mov	r7,0
80008fac:	c0 e8       	rjmp	80008fc8 <_write+0x30>
80008fae:	30 07       	mov	r7,0
  {
    if (usart_putchar(stdio_usart_base, *ptr++) < 0)
80008fb0:	48 74       	lddpc	r4,80008fcc <_write+0x34>
80008fb2:	68 0c       	ld.w	r12,r4[0x0]
80008fb4:	ea 07 07 0b 	ld.ub	r11,r5[r7]
80008fb8:	f0 1f 00 06 	mcall	80008fd0 <_write+0x38>
80008fbc:	c0 55       	brlt	80008fc6 <_write+0x2e>
    {
      return -1;
    }

    ++nChars;
80008fbe:	2f f7       	sub	r7,-1

  if ( (file != 1)
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80008fc0:	0e 36       	cp.w	r6,r7
80008fc2:	cf 81       	brne	80008fb2 <_write+0x1a>
80008fc4:	c0 28       	rjmp	80008fc8 <_write+0x30>
80008fc6:	3f f7       	mov	r7,-1

    ++nChars;
  }

  return nChars;
}
80008fc8:	0e 9c       	mov	r12,r7
80008fca:	d8 22       	popm	r4-r7,pc
80008fcc:	00 00       	add	r0,r0
80008fce:	46 a0       	lddsp	r0,sp[0x1a8]
80008fd0:	80 00       	ld.sh	r0,r0[0x0]
80008fd2:	63 60       	ld.w	r0,r1[0x58]

80008fd4 <vPortFree>:
	return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
80008fd4:	eb cd 40 80 	pushm	r7,lr
80008fd8:	18 97       	mov	r7,r12
	if( pv )
80008fda:	58 0c       	cp.w	r12,0
80008fdc:	c0 80       	breq	80008fec <vPortFree+0x18>
	{
		vTaskSuspendAll();
80008fde:	f0 1f 00 05 	mcall	80008ff0 <vPortFree+0x1c>
		{
			free( pv );
80008fe2:	0e 9c       	mov	r12,r7
80008fe4:	f0 1f 00 04 	mcall	80008ff4 <vPortFree+0x20>
		}
		xTaskResumeAll();
80008fe8:	f0 1f 00 04 	mcall	80008ff8 <vPortFree+0x24>
80008fec:	e3 cd 80 80 	ldm	sp++,r7,pc
80008ff0:	80 00       	ld.sh	r0,r0[0x0]
80008ff2:	95 1c       	st.w	r10[0x4],r12
80008ff4:	80 00       	ld.sh	r0,r0[0x0]
80008ff6:	a4 88       	st.b	r2[0x0],r8
80008ff8:	80 00       	ld.sh	r0,r0[0x0]
80008ffa:	98 d8       	ld.uh	r8,r12[0xa]

80008ffc <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
80008ffc:	eb cd 40 80 	pushm	r7,lr
80009000:	18 97       	mov	r7,r12
void *pvReturn;

	vTaskSuspendAll();
80009002:	f0 1f 00 06 	mcall	80009018 <pvPortMalloc+0x1c>
	{
		pvReturn = malloc( xWantedSize );
80009006:	0e 9c       	mov	r12,r7
80009008:	f0 1f 00 05 	mcall	8000901c <pvPortMalloc+0x20>
8000900c:	18 97       	mov	r7,r12
	}
	xTaskResumeAll();
8000900e:	f0 1f 00 05 	mcall	80009020 <pvPortMalloc+0x24>
		}
	}
	#endif

	return pvReturn;
}
80009012:	0e 9c       	mov	r12,r7
80009014:	e3 cd 80 80 	ldm	sp++,r7,pc
80009018:	80 00       	ld.sh	r0,r0[0x0]
8000901a:	95 1c       	st.w	r10[0x4],r12
8000901c:	80 00       	ld.sh	r0,r0[0x0]
8000901e:	a4 98       	st.b	r2[0x1],r8
80009020:	80 00       	ld.sh	r0,r0[0x0]
80009022:	98 d8       	ld.uh	r8,r12[0xa]

80009024 <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
80009024:	d4 01       	pushm	lr
80009026:	16 98       	mov	r8,r11
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
80009028:	78 09       	ld.w	r9,r12[0x0]
8000902a:	58 09       	cp.w	r9,0
8000902c:	c1 10       	breq	8000904e <prvCopyDataFromQueue+0x2a>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
8000902e:	78 3a       	ld.w	r10,r12[0xc]
80009030:	79 09       	ld.w	r9,r12[0x40]
80009032:	f4 09 00 09 	add	r9,r10,r9
80009036:	99 39       	st.w	r12[0xc],r9
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
80009038:	78 1a       	ld.w	r10,r12[0x4]
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
8000903a:	14 39       	cp.w	r9,r10
8000903c:	f9 f9 20 00 	ld.wcc	r9,r12[0x0]
80009040:	f9 f9 2a 03 	st.wcc	r12[0xc],r9
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
80009044:	79 0a       	ld.w	r10,r12[0x40]
80009046:	78 3b       	ld.w	r11,r12[0xc]
80009048:	10 9c       	mov	r12,r8
8000904a:	f0 1f 00 02 	mcall	80009050 <prvCopyDataFromQueue+0x2c>
8000904e:	d8 02       	popm	pc
80009050:	80 00       	ld.sh	r0,r0[0x0]
80009052:	a9 06       	ld.d	r6,r4

80009054 <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
80009054:	eb cd 40 c0 	pushm	r6-r7,lr
80009058:	18 97       	mov	r7,r12
8000905a:	14 96       	mov	r6,r10
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
8000905c:	78 e8       	ld.w	r8,r12[0x38]
8000905e:	58 08       	cp.w	r8,0
80009060:	c0 31       	brne	80009066 <xQueueReceiveFromISR+0x12>
80009062:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
80009066:	f0 1f 00 0e 	mcall	8000909c <xQueueReceiveFromISR+0x48>
			--( pxQueue->uxMessagesWaiting );
8000906a:	6e e8       	ld.w	r8,r7[0x38]
8000906c:	20 18       	sub	r8,1
8000906e:	8f e8       	st.w	r7[0x38],r8

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
80009070:	6f 18       	ld.w	r8,r7[0x44]
80009072:	5b f8       	cp.w	r8,-1
80009074:	c0 d1       	brne	8000908e <xQueueReceiveFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80009076:	6e 48       	ld.w	r8,r7[0x10]
80009078:	58 08       	cp.w	r8,0
8000907a:	c0 f0       	breq	80009098 <xQueueReceiveFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
8000907c:	ee cc ff f0 	sub	r12,r7,-16
80009080:	f0 1f 00 08 	mcall	800090a0 <xQueueReceiveFromISR+0x4c>
80009084:	c0 a0       	breq	80009098 <xQueueReceiveFromISR+0x44>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
80009086:	30 1c       	mov	r12,1
80009088:	8d 0c       	st.w	r6[0x0],r12
8000908a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
8000908e:	2f f8       	sub	r8,-1
80009090:	ef 48 00 44 	st.w	r7[68],r8
80009094:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80009098:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
8000909c:	80 00       	ld.sh	r0,r0[0x0]
8000909e:	90 24       	ld.sh	r4,r8[0x4]
800090a0:	80 00       	ld.sh	r0,r0[0x0]
800090a2:	96 b4       	ld.uh	r4,r11[0x6]

800090a4 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
800090a4:	eb cd 40 c0 	pushm	r6-r7,lr
800090a8:	18 97       	mov	r7,r12

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
800090aa:	f0 1f 00 23 	mcall	80009134 <prvUnlockQueue+0x90>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
800090ae:	6f 28       	ld.w	r8,r7[0x48]
800090b0:	58 08       	cp.w	r8,0
800090b2:	e0 8a 00 18 	brle	800090e2 <prvUnlockQueue+0x3e>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800090b6:	6e 98       	ld.w	r8,r7[0x24]
800090b8:	58 08       	cp.w	r8,0
800090ba:	c1 40       	breq	800090e2 <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
800090bc:	ee c6 ff dc 	sub	r6,r7,-36
800090c0:	c0 48       	rjmp	800090c8 <prvUnlockQueue+0x24>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800090c2:	6e 98       	ld.w	r8,r7[0x24]
800090c4:	58 08       	cp.w	r8,0
800090c6:	c0 e0       	breq	800090e2 <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
800090c8:	0c 9c       	mov	r12,r6
800090ca:	f0 1f 00 1c 	mcall	80009138 <prvUnlockQueue+0x94>
800090ce:	c0 30       	breq	800090d4 <prvUnlockQueue+0x30>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
800090d0:	f0 1f 00 1b 	mcall	8000913c <prvUnlockQueue+0x98>
				}

				--( pxQueue->xTxLock );
800090d4:	6f 28       	ld.w	r8,r7[0x48]
800090d6:	20 18       	sub	r8,1
800090d8:	ef 48 00 48 	st.w	r7[72],r8
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
800090dc:	58 08       	cp.w	r8,0
800090de:	fe 99 ff f2 	brgt	800090c2 <prvUnlockQueue+0x1e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
800090e2:	3f f8       	mov	r8,-1
800090e4:	ef 48 00 48 	st.w	r7[72],r8
	}
	taskEXIT_CRITICAL();
800090e8:	f0 1f 00 16 	mcall	80009140 <prvUnlockQueue+0x9c>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
800090ec:	f0 1f 00 12 	mcall	80009134 <prvUnlockQueue+0x90>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
800090f0:	6f 18       	ld.w	r8,r7[0x44]
800090f2:	58 08       	cp.w	r8,0
800090f4:	e0 8a 00 18 	brle	80009124 <prvUnlockQueue+0x80>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
800090f8:	6e 48       	ld.w	r8,r7[0x10]
800090fa:	58 08       	cp.w	r8,0
800090fc:	c1 40       	breq	80009124 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
800090fe:	ee c6 ff f0 	sub	r6,r7,-16
80009102:	c0 48       	rjmp	8000910a <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80009104:	6e 48       	ld.w	r8,r7[0x10]
80009106:	58 08       	cp.w	r8,0
80009108:	c0 e0       	breq	80009124 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
8000910a:	0c 9c       	mov	r12,r6
8000910c:	f0 1f 00 0b 	mcall	80009138 <prvUnlockQueue+0x94>
80009110:	c0 30       	breq	80009116 <prvUnlockQueue+0x72>
				{
					vTaskMissedYield();
80009112:	f0 1f 00 0b 	mcall	8000913c <prvUnlockQueue+0x98>
				}

				--( pxQueue->xRxLock );
80009116:	6f 18       	ld.w	r8,r7[0x44]
80009118:	20 18       	sub	r8,1
8000911a:	ef 48 00 44 	st.w	r7[68],r8
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
8000911e:	58 08       	cp.w	r8,0
80009120:	fe 99 ff f2 	brgt	80009104 <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
80009124:	3f f8       	mov	r8,-1
80009126:	ef 48 00 44 	st.w	r7[68],r8
	}
	taskEXIT_CRITICAL();
8000912a:	f0 1f 00 06 	mcall	80009140 <prvUnlockQueue+0x9c>
}
8000912e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80009132:	00 00       	add	r0,r0
80009134:	80 00       	ld.sh	r0,r0[0x0]
80009136:	8d 90       	st.w	r6[0x24],r0
80009138:	80 00       	ld.sh	r0,r0[0x0]
8000913a:	96 b4       	ld.uh	r4,r11[0x6]
8000913c:	80 00       	ld.sh	r0,r0[0x0]
8000913e:	95 c0       	st.w	r10[0x30],r0
80009140:	80 00       	ld.sh	r0,r0[0x0]
80009142:	8e 9c       	ld.uh	r12,r7[0x2]

80009144 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
80009144:	d4 31       	pushm	r0-r7,lr
80009146:	20 5d       	sub	sp,20
80009148:	18 97       	mov	r7,r12
8000914a:	50 0b       	stdsp	sp[0x0],r11
8000914c:	50 2a       	stdsp	sp[0x8],r10
8000914e:	50 19       	stdsp	sp[0x4],r9
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80009150:	f8 c2 ff dc 	sub	r2,r12,-36
80009154:	30 05       	mov	r5,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80009156:	fa c4 ff f4 	sub	r4,sp,-12
8000915a:	30 10       	mov	r0,1

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
8000915c:	0a 91       	mov	r1,r5

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
8000915e:	fa c3 ff f8 	sub	r3,sp,-8
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
80009162:	f0 1f 00 3e 	mcall	80009258 <xQueueGenericReceive+0x114>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80009166:	6e e8       	ld.w	r8,r7[0x38]
80009168:	58 08       	cp.w	r8,0
8000916a:	c2 a0       	breq	800091be <xQueueGenericReceive+0x7a>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
8000916c:	6e 36       	ld.w	r6,r7[0xc]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
8000916e:	40 0b       	lddsp	r11,sp[0x0]
80009170:	0e 9c       	mov	r12,r7
80009172:	f0 1f 00 3b 	mcall	8000925c <xQueueGenericReceive+0x118>

				if( xJustPeeking == pdFALSE )
80009176:	40 18       	lddsp	r8,sp[0x4]
80009178:	58 08       	cp.w	r8,0
8000917a:	c1 51       	brne	800091a4 <xQueueGenericReceive+0x60>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
8000917c:	6e e8       	ld.w	r8,r7[0x38]
8000917e:	20 18       	sub	r8,1
80009180:	8f e8       	st.w	r7[0x38],r8

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80009182:	6e 08       	ld.w	r8,r7[0x0]
80009184:	58 08       	cp.w	r8,0
80009186:	c0 41       	brne	8000918e <xQueueGenericReceive+0x4a>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
80009188:	f0 1f 00 36 	mcall	80009260 <xQueueGenericReceive+0x11c>
8000918c:	8f 1c       	st.w	r7[0x4],r12
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
8000918e:	6e 48       	ld.w	r8,r7[0x10]
80009190:	58 08       	cp.w	r8,0
80009192:	c1 20       	breq	800091b6 <xQueueGenericReceive+0x72>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
80009194:	ee cc ff f0 	sub	r12,r7,-16
80009198:	f0 1f 00 33 	mcall	80009264 <xQueueGenericReceive+0x120>
8000919c:	58 1c       	cp.w	r12,1
8000919e:	c0 c1       	brne	800091b6 <xQueueGenericReceive+0x72>
						{
							portYIELD_WITHIN_API();
800091a0:	d7 33       	scall
800091a2:	c0 a8       	rjmp	800091b6 <xQueueGenericReceive+0x72>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
800091a4:	8f 36       	st.w	r7[0xc],r6

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800091a6:	6e 98       	ld.w	r8,r7[0x24]
800091a8:	58 08       	cp.w	r8,0
800091aa:	c0 60       	breq	800091b6 <xQueueGenericReceive+0x72>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
800091ac:	04 9c       	mov	r12,r2
800091ae:	f0 1f 00 2e 	mcall	80009264 <xQueueGenericReceive+0x120>
800091b2:	c0 20       	breq	800091b6 <xQueueGenericReceive+0x72>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
800091b4:	d7 33       	scall
						}
					}

				}

				taskEXIT_CRITICAL();
800091b6:	f0 1f 00 2d 	mcall	80009268 <xQueueGenericReceive+0x124>
800091ba:	30 1c       	mov	r12,1
				return pdPASS;
800091bc:	c4 c8       	rjmp	80009254 <xQueueGenericReceive+0x110>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
800091be:	40 28       	lddsp	r8,sp[0x8]
800091c0:	58 08       	cp.w	r8,0
800091c2:	c0 51       	brne	800091cc <xQueueGenericReceive+0x88>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
800091c4:	f0 1f 00 29 	mcall	80009268 <xQueueGenericReceive+0x124>
800091c8:	30 0c       	mov	r12,0
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
800091ca:	c4 58       	rjmp	80009254 <xQueueGenericReceive+0x110>
				}
				else if( xEntryTimeSet == pdFALSE )
800091cc:	58 05       	cp.w	r5,0
800091ce:	c0 51       	brne	800091d8 <xQueueGenericReceive+0x94>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
800091d0:	08 9c       	mov	r12,r4
800091d2:	f0 1f 00 27 	mcall	8000926c <xQueueGenericReceive+0x128>
800091d6:	00 95       	mov	r5,r0
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
800091d8:	f0 1f 00 24 	mcall	80009268 <xQueueGenericReceive+0x124>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
800091dc:	f0 1f 00 25 	mcall	80009270 <xQueueGenericReceive+0x12c>
		prvLockQueue( pxQueue );
800091e0:	f0 1f 00 1e 	mcall	80009258 <xQueueGenericReceive+0x114>
800091e4:	6f 18       	ld.w	r8,r7[0x44]
800091e6:	5b f8       	cp.w	r8,-1
800091e8:	ef f1 0a 11 	st.weq	r7[0x44],r1
800091ec:	6f 28       	ld.w	r8,r7[0x48]
800091ee:	5b f8       	cp.w	r8,-1
800091f0:	ef f1 0a 12 	st.weq	r7[0x48],r1
800091f4:	f0 1f 00 1d 	mcall	80009268 <xQueueGenericReceive+0x124>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800091f8:	06 9b       	mov	r11,r3
800091fa:	08 9c       	mov	r12,r4
800091fc:	f0 1f 00 1e 	mcall	80009274 <xQueueGenericReceive+0x130>
80009200:	c2 41       	brne	80009248 <xQueueGenericReceive+0x104>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80009202:	f0 1f 00 16 	mcall	80009258 <xQueueGenericReceive+0x114>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
80009206:	6e e6       	ld.w	r6,r7[0x38]
	taskEXIT_CRITICAL();
80009208:	f0 1f 00 18 	mcall	80009268 <xQueueGenericReceive+0x124>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
8000920c:	58 06       	cp.w	r6,0
8000920e:	c1 71       	brne	8000923c <xQueueGenericReceive+0xf8>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80009210:	6e 08       	ld.w	r8,r7[0x0]
80009212:	58 08       	cp.w	r8,0
80009214:	c0 81       	brne	80009224 <xQueueGenericReceive+0xe0>
					{
						portENTER_CRITICAL();
80009216:	f0 1f 00 11 	mcall	80009258 <xQueueGenericReceive+0x114>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
8000921a:	6e 1c       	ld.w	r12,r7[0x4]
8000921c:	f0 1f 00 17 	mcall	80009278 <xQueueGenericReceive+0x134>
						}
						portEXIT_CRITICAL();
80009220:	f0 1f 00 12 	mcall	80009268 <xQueueGenericReceive+0x124>
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80009224:	40 2b       	lddsp	r11,sp[0x8]
80009226:	04 9c       	mov	r12,r2
80009228:	f0 1f 00 15 	mcall	8000927c <xQueueGenericReceive+0x138>
				prvUnlockQueue( pxQueue );
8000922c:	0e 9c       	mov	r12,r7
8000922e:	f0 1f 00 15 	mcall	80009280 <xQueueGenericReceive+0x13c>
				if( !xTaskResumeAll() )
80009232:	f0 1f 00 15 	mcall	80009284 <xQueueGenericReceive+0x140>
80009236:	c9 61       	brne	80009162 <xQueueGenericReceive+0x1e>
				{
					portYIELD_WITHIN_API();
80009238:	d7 33       	scall
8000923a:	c9 4b       	rjmp	80009162 <xQueueGenericReceive+0x1e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
8000923c:	0e 9c       	mov	r12,r7
8000923e:	f0 1f 00 11 	mcall	80009280 <xQueueGenericReceive+0x13c>
				( void ) xTaskResumeAll();
80009242:	f0 1f 00 11 	mcall	80009284 <xQueueGenericReceive+0x140>
80009246:	c8 eb       	rjmp	80009162 <xQueueGenericReceive+0x1e>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
80009248:	0e 9c       	mov	r12,r7
8000924a:	f0 1f 00 0e 	mcall	80009280 <xQueueGenericReceive+0x13c>
			( void ) xTaskResumeAll();
8000924e:	f0 1f 00 0e 	mcall	80009284 <xQueueGenericReceive+0x140>
80009252:	30 0c       	mov	r12,0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
80009254:	2f bd       	sub	sp,-20
80009256:	d8 32       	popm	r0-r7,pc
80009258:	80 00       	ld.sh	r0,r0[0x0]
8000925a:	8d 90       	st.w	r6[0x24],r0
8000925c:	80 00       	ld.sh	r0,r0[0x0]
8000925e:	90 24       	ld.sh	r4,r8[0x4]
80009260:	80 00       	ld.sh	r0,r0[0x0]
80009262:	95 cc       	st.w	r10[0x30],r12
80009264:	80 00       	ld.sh	r0,r0[0x0]
80009266:	96 b4       	ld.uh	r4,r11[0x6]
80009268:	80 00       	ld.sh	r0,r0[0x0]
8000926a:	8e 9c       	ld.uh	r12,r7[0x2]
8000926c:	80 00       	ld.sh	r0,r0[0x0]
8000926e:	95 a8       	st.w	r10[0x28],r8
80009270:	80 00       	ld.sh	r0,r0[0x0]
80009272:	95 1c       	st.w	r10[0x4],r12
80009274:	80 00       	ld.sh	r0,r0[0x0]
80009276:	98 44       	ld.sh	r4,r12[0x8]
80009278:	80 00       	ld.sh	r0,r0[0x0]
8000927a:	96 30       	ld.sh	r0,r11[0x6]
8000927c:	80 00       	ld.sh	r0,r0[0x0]
8000927e:	9a 9c       	ld.uh	r12,sp[0x2]
80009280:	80 00       	ld.sh	r0,r0[0x0]
80009282:	90 a4       	ld.uh	r4,r8[0x4]
80009284:	80 00       	ld.sh	r0,r0[0x0]
80009286:	98 d8       	ld.uh	r8,r12[0xa]

80009288 <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
80009288:	eb cd 40 80 	pushm	r7,lr
8000928c:	18 97       	mov	r7,r12
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
8000928e:	79 08       	ld.w	r8,r12[0x40]
80009290:	58 08       	cp.w	r8,0
80009292:	c0 a1       	brne	800092a6 <prvCopyDataToQueue+0x1e>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80009294:	78 08       	ld.w	r8,r12[0x0]
80009296:	58 08       	cp.w	r8,0
80009298:	c2 b1       	brne	800092ee <prvCopyDataToQueue+0x66>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
8000929a:	78 1c       	ld.w	r12,r12[0x4]
8000929c:	f0 1f 00 17 	mcall	800092f8 <prvCopyDataToQueue+0x70>
				pxQueue->pxMutexHolder = NULL;
800092a0:	30 08       	mov	r8,0
800092a2:	8f 18       	st.w	r7[0x4],r8
800092a4:	c2 58       	rjmp	800092ee <prvCopyDataToQueue+0x66>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
800092a6:	58 0a       	cp.w	r10,0
800092a8:	c1 01       	brne	800092c8 <prvCopyDataToQueue+0x40>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
800092aa:	10 9a       	mov	r10,r8
800092ac:	78 2c       	ld.w	r12,r12[0x8]
800092ae:	f0 1f 00 14 	mcall	800092fc <prvCopyDataToQueue+0x74>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
800092b2:	6e 29       	ld.w	r9,r7[0x8]
800092b4:	6f 08       	ld.w	r8,r7[0x40]
800092b6:	f2 08 00 08 	add	r8,r9,r8
800092ba:	8f 28       	st.w	r7[0x8],r8
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
800092bc:	6e 19       	ld.w	r9,r7[0x4]
800092be:	12 38       	cp.w	r8,r9
800092c0:	c1 73       	brcs	800092ee <prvCopyDataToQueue+0x66>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
800092c2:	6e 08       	ld.w	r8,r7[0x0]
800092c4:	8f 28       	st.w	r7[0x8],r8
800092c6:	c1 48       	rjmp	800092ee <prvCopyDataToQueue+0x66>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
800092c8:	10 9a       	mov	r10,r8
800092ca:	78 3c       	ld.w	r12,r12[0xc]
800092cc:	f0 1f 00 0c 	mcall	800092fc <prvCopyDataToQueue+0x74>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
800092d0:	6f 08       	ld.w	r8,r7[0x40]
800092d2:	6e 39       	ld.w	r9,r7[0xc]
800092d4:	f2 08 01 08 	sub	r8,r9,r8
800092d8:	8f 38       	st.w	r7[0xc],r8
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
800092da:	6e 09       	ld.w	r9,r7[0x0]
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
800092dc:	12 38       	cp.w	r8,r9
800092de:	ef f8 30 10 	ld.wcs	r8,r7[0x40]
800092e2:	ef f9 30 01 	ld.wcs	r9,r7[0x4]
800092e6:	f3 d8 e3 19 	subcs	r9,r9,r8
800092ea:	ef f9 3a 03 	st.wcs	r7[0xc],r9
		}
	}

	++( pxQueue->uxMessagesWaiting );
800092ee:	6e e8       	ld.w	r8,r7[0x38]
800092f0:	2f f8       	sub	r8,-1
800092f2:	8f e8       	st.w	r7[0x38],r8
}
800092f4:	e3 cd 80 80 	ldm	sp++,r7,pc
800092f8:	80 00       	ld.sh	r0,r0[0x0]
800092fa:	95 d8       	st.w	r10[0x34],r8
800092fc:	80 00       	ld.sh	r0,r0[0x0]
800092fe:	a9 06       	ld.d	r6,r4

80009300 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
80009300:	eb cd 40 c0 	pushm	r6-r7,lr
80009304:	18 97       	mov	r7,r12
80009306:	14 96       	mov	r6,r10
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80009308:	78 ec       	ld.w	r12,r12[0x38]
8000930a:	6e f8       	ld.w	r8,r7[0x3c]
8000930c:	10 3c       	cp.w	r12,r8
8000930e:	c0 33       	brcs	80009314 <xQueueGenericSendFromISR+0x14>
80009310:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80009314:	12 9a       	mov	r10,r9
80009316:	0e 9c       	mov	r12,r7
80009318:	f0 1f 00 0c 	mcall	80009348 <xQueueGenericSendFromISR+0x48>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
8000931c:	6f 28       	ld.w	r8,r7[0x48]
8000931e:	5b f8       	cp.w	r8,-1
80009320:	c0 d1       	brne	8000933a <xQueueGenericSendFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80009322:	6e 98       	ld.w	r8,r7[0x24]
80009324:	58 08       	cp.w	r8,0
80009326:	c0 f0       	breq	80009344 <xQueueGenericSendFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80009328:	ee cc ff dc 	sub	r12,r7,-36
8000932c:	f0 1f 00 08 	mcall	8000934c <xQueueGenericSendFromISR+0x4c>
80009330:	c0 a0       	breq	80009344 <xQueueGenericSendFromISR+0x44>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
80009332:	30 1c       	mov	r12,1
80009334:	8d 0c       	st.w	r6[0x0],r12
80009336:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
8000933a:	2f f8       	sub	r8,-1
8000933c:	ef 48 00 48 	st.w	r7[72],r8
80009340:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80009344:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80009348:	80 00       	ld.sh	r0,r0[0x0]
8000934a:	92 88       	ld.uh	r8,r9[0x0]
8000934c:	80 00       	ld.sh	r0,r0[0x0]
8000934e:	96 b4       	ld.uh	r4,r11[0x6]

80009350 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
80009350:	d4 31       	pushm	r0-r7,lr
80009352:	20 5d       	sub	sp,20
80009354:	18 97       	mov	r7,r12
80009356:	50 0b       	stdsp	sp[0x0],r11
80009358:	50 2a       	stdsp	sp[0x8],r10
8000935a:	50 19       	stdsp	sp[0x4],r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
8000935c:	f8 c0 ff f0 	sub	r0,r12,-16
80009360:	30 04       	mov	r4,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80009362:	fa c3 ff f4 	sub	r3,sp,-12

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80009366:	08 91       	mov	r1,r4

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80009368:	fa c2 ff f8 	sub	r2,sp,-8
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
8000936c:	f0 1f 00 2f 	mcall	80009428 <xQueueGenericSend+0xd8>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80009370:	6e e9       	ld.w	r9,r7[0x38]
80009372:	6e f8       	ld.w	r8,r7[0x3c]
80009374:	10 39       	cp.w	r9,r8
80009376:	c1 42       	brcc	8000939e <xQueueGenericSend+0x4e>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80009378:	40 1a       	lddsp	r10,sp[0x4]
8000937a:	40 0b       	lddsp	r11,sp[0x0]
8000937c:	0e 9c       	mov	r12,r7
8000937e:	f0 1f 00 2c 	mcall	8000942c <xQueueGenericSend+0xdc>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80009382:	6e 98       	ld.w	r8,r7[0x24]
80009384:	58 08       	cp.w	r8,0
80009386:	c0 80       	breq	80009396 <xQueueGenericSend+0x46>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
80009388:	ee cc ff dc 	sub	r12,r7,-36
8000938c:	f0 1f 00 29 	mcall	80009430 <xQueueGenericSend+0xe0>
80009390:	58 1c       	cp.w	r12,1
80009392:	c0 21       	brne	80009396 <xQueueGenericSend+0x46>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
80009394:	d7 33       	scall
					}
				}

				taskEXIT_CRITICAL();
80009396:	f0 1f 00 28 	mcall	80009434 <xQueueGenericSend+0xe4>
8000939a:	30 1c       	mov	r12,1

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
8000939c:	c4 38       	rjmp	80009422 <xQueueGenericSend+0xd2>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
8000939e:	40 28       	lddsp	r8,sp[0x8]
800093a0:	58 08       	cp.w	r8,0
800093a2:	c0 51       	brne	800093ac <xQueueGenericSend+0x5c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
800093a4:	f0 1f 00 24 	mcall	80009434 <xQueueGenericSend+0xe4>
800093a8:	30 0c       	mov	r12,0

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
800093aa:	c3 c8       	rjmp	80009422 <xQueueGenericSend+0xd2>
				}
				else if( xEntryTimeSet == pdFALSE )
800093ac:	58 04       	cp.w	r4,0
800093ae:	c0 51       	brne	800093b8 <xQueueGenericSend+0x68>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
800093b0:	06 9c       	mov	r12,r3
800093b2:	f0 1f 00 22 	mcall	80009438 <xQueueGenericSend+0xe8>
800093b6:	30 14       	mov	r4,1
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
800093b8:	f0 1f 00 1f 	mcall	80009434 <xQueueGenericSend+0xe4>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
800093bc:	f0 1f 00 20 	mcall	8000943c <xQueueGenericSend+0xec>
		prvLockQueue( pxQueue );
800093c0:	f0 1f 00 1a 	mcall	80009428 <xQueueGenericSend+0xd8>
800093c4:	6f 18       	ld.w	r8,r7[0x44]
800093c6:	5b f8       	cp.w	r8,-1
800093c8:	ef f1 0a 11 	st.weq	r7[0x44],r1
800093cc:	6f 28       	ld.w	r8,r7[0x48]
800093ce:	5b f8       	cp.w	r8,-1
800093d0:	ef f1 0a 12 	st.weq	r7[0x48],r1
800093d4:	f0 1f 00 18 	mcall	80009434 <xQueueGenericSend+0xe4>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800093d8:	04 9b       	mov	r11,r2
800093da:	06 9c       	mov	r12,r3
800093dc:	f0 1f 00 19 	mcall	80009440 <xQueueGenericSend+0xf0>
800093e0:	c1 b1       	brne	80009416 <xQueueGenericSend+0xc6>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
800093e2:	f0 1f 00 12 	mcall	80009428 <xQueueGenericSend+0xd8>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
800093e6:	6e e5       	ld.w	r5,r7[0x38]
800093e8:	6e f6       	ld.w	r6,r7[0x3c]
	taskEXIT_CRITICAL();
800093ea:	f0 1f 00 13 	mcall	80009434 <xQueueGenericSend+0xe4>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
800093ee:	0c 35       	cp.w	r5,r6
800093f0:	c0 d1       	brne	8000940a <xQueueGenericSend+0xba>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
800093f2:	40 2b       	lddsp	r11,sp[0x8]
800093f4:	00 9c       	mov	r12,r0
800093f6:	f0 1f 00 14 	mcall	80009444 <xQueueGenericSend+0xf4>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
800093fa:	0e 9c       	mov	r12,r7
800093fc:	f0 1f 00 13 	mcall	80009448 <xQueueGenericSend+0xf8>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
80009400:	f0 1f 00 13 	mcall	8000944c <xQueueGenericSend+0xfc>
80009404:	cb 41       	brne	8000936c <xQueueGenericSend+0x1c>
				{
					portYIELD_WITHIN_API();
80009406:	d7 33       	scall
80009408:	cb 2b       	rjmp	8000936c <xQueueGenericSend+0x1c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
8000940a:	0e 9c       	mov	r12,r7
8000940c:	f0 1f 00 0f 	mcall	80009448 <xQueueGenericSend+0xf8>
				( void ) xTaskResumeAll();
80009410:	f0 1f 00 0f 	mcall	8000944c <xQueueGenericSend+0xfc>
80009414:	ca cb       	rjmp	8000936c <xQueueGenericSend+0x1c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
80009416:	0e 9c       	mov	r12,r7
80009418:	f0 1f 00 0c 	mcall	80009448 <xQueueGenericSend+0xf8>
			( void ) xTaskResumeAll();
8000941c:	f0 1f 00 0c 	mcall	8000944c <xQueueGenericSend+0xfc>
80009420:	30 0c       	mov	r12,0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
80009422:	2f bd       	sub	sp,-20
80009424:	d8 32       	popm	r0-r7,pc
80009426:	00 00       	add	r0,r0
80009428:	80 00       	ld.sh	r0,r0[0x0]
8000942a:	8d 90       	st.w	r6[0x24],r0
8000942c:	80 00       	ld.sh	r0,r0[0x0]
8000942e:	92 88       	ld.uh	r8,r9[0x0]
80009430:	80 00       	ld.sh	r0,r0[0x0]
80009432:	96 b4       	ld.uh	r4,r11[0x6]
80009434:	80 00       	ld.sh	r0,r0[0x0]
80009436:	8e 9c       	ld.uh	r12,r7[0x2]
80009438:	80 00       	ld.sh	r0,r0[0x0]
8000943a:	95 a8       	st.w	r10[0x28],r8
8000943c:	80 00       	ld.sh	r0,r0[0x0]
8000943e:	95 1c       	st.w	r10[0x4],r12
80009440:	80 00       	ld.sh	r0,r0[0x0]
80009442:	98 44       	ld.sh	r4,r12[0x8]
80009444:	80 00       	ld.sh	r0,r0[0x0]
80009446:	9a 9c       	ld.uh	r12,sp[0x2]
80009448:	80 00       	ld.sh	r0,r0[0x0]
8000944a:	90 a4       	ld.uh	r4,r8[0x4]
8000944c:	80 00       	ld.sh	r0,r0[0x0]
8000944e:	98 d8       	ld.uh	r8,r12[0xa]

80009450 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	xQueueHandle xQueueCreateMutex( void )
	{
80009450:	eb cd 40 c0 	pushm	r6-r7,lr
	xQUEUE *pxNewQueue;

		/* Allocate the new queue structure. */
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
80009454:	34 cc       	mov	r12,76
80009456:	f0 1f 00 12 	mcall	8000949c <xQueueCreateMutex+0x4c>
8000945a:	18 97       	mov	r7,r12
		if( pxNewQueue != NULL )
8000945c:	c1 d0       	breq	80009496 <xQueueCreateMutex+0x46>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
8000945e:	30 06       	mov	r6,0
80009460:	99 16       	st.w	r12[0x4],r6
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
80009462:	99 06       	st.w	r12[0x0],r6

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
80009464:	99 26       	st.w	r12[0x8],r6
			pxNewQueue->pcReadFrom = NULL;
80009466:	99 36       	st.w	r12[0xc],r6

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
80009468:	99 e6       	st.w	r12[0x38],r6
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
8000946a:	30 18       	mov	r8,1
8000946c:	99 f8       	st.w	r12[0x3c],r8
			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
8000946e:	f9 46 00 40 	st.w	r12[64],r6
			pxNewQueue->xRxLock = queueUNLOCKED;
80009472:	3f f8       	mov	r8,-1
80009474:	f9 48 00 44 	st.w	r12[68],r8
			pxNewQueue->xTxLock = queueUNLOCKED;
80009478:	f9 48 00 48 	st.w	r12[72],r8

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
8000947c:	2f 0c       	sub	r12,-16
8000947e:	f0 1f 00 09 	mcall	800094a0 <xQueueCreateMutex+0x50>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
80009482:	ee cc ff dc 	sub	r12,r7,-36
80009486:	f0 1f 00 07 	mcall	800094a0 <xQueueCreateMutex+0x50>

			/* Start with the semaphore in the expected state. */
			xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
8000948a:	0c 99       	mov	r9,r6
8000948c:	0c 9a       	mov	r10,r6
8000948e:	0c 9b       	mov	r11,r6
80009490:	0e 9c       	mov	r12,r7
80009492:	f0 1f 00 05 	mcall	800094a4 <xQueueCreateMutex+0x54>
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
80009496:	0e 9c       	mov	r12,r7
80009498:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000949c:	80 00       	ld.sh	r0,r0[0x0]
8000949e:	8f fc       	st.w	r7[0x3c],r12
800094a0:	80 00       	ld.sh	r0,r0[0x0]
800094a2:	8c 6c       	ld.sh	r12,r6[0xc]
800094a4:	80 00       	ld.sh	r0,r0[0x0]
800094a6:	93 50       	st.w	r9[0x14],r0

800094a8 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
800094a8:	d4 21       	pushm	r4-r7,lr
800094aa:	18 97       	mov	r7,r12
800094ac:	16 96       	mov	r6,r11
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
800094ae:	58 0c       	cp.w	r12,0
800094b0:	c2 f0       	breq	8000950e <xQueueCreate+0x66>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
800094b2:	34 cc       	mov	r12,76
800094b4:	f0 1f 00 17 	mcall	80009510 <xQueueCreate+0x68>
800094b8:	18 95       	mov	r5,r12
		if( pxNewQueue != NULL )
800094ba:	c2 a0       	breq	8000950e <xQueueCreate+0x66>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
800094bc:	ec 07 02 44 	mul	r4,r6,r7

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
800094c0:	e8 cc ff ff 	sub	r12,r4,-1
800094c4:	f0 1f 00 13 	mcall	80009510 <xQueueCreate+0x68>
800094c8:	8b 0c       	st.w	r5[0x0],r12
			if( pxNewQueue->pcHead != NULL )
800094ca:	c1 e0       	breq	80009506 <xQueueCreate+0x5e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
800094cc:	f8 04 00 04 	add	r4,r12,r4
800094d0:	8b 14       	st.w	r5[0x4],r4
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
800094d2:	30 08       	mov	r8,0
800094d4:	8b e8       	st.w	r5[0x38],r8
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
800094d6:	8b 2c       	st.w	r5[0x8],r12
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
800094d8:	ee c8 00 01 	sub	r8,r7,1
800094dc:	ad 38       	mul	r8,r6
800094de:	10 0c       	add	r12,r8
800094e0:	8b 3c       	st.w	r5[0xc],r12
				pxNewQueue->uxLength = uxQueueLength;
800094e2:	8b f7       	st.w	r5[0x3c],r7
				pxNewQueue->uxItemSize = uxItemSize;
800094e4:	eb 46 00 40 	st.w	r5[64],r6
				pxNewQueue->xRxLock = queueUNLOCKED;
800094e8:	3f f8       	mov	r8,-1
800094ea:	eb 48 00 44 	st.w	r5[68],r8
				pxNewQueue->xTxLock = queueUNLOCKED;
800094ee:	eb 48 00 48 	st.w	r5[72],r8

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
800094f2:	ea cc ff f0 	sub	r12,r5,-16
800094f6:	f0 1f 00 08 	mcall	80009514 <xQueueCreate+0x6c>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
800094fa:	ea cc ff dc 	sub	r12,r5,-36
800094fe:	f0 1f 00 06 	mcall	80009514 <xQueueCreate+0x6c>
80009502:	0a 9c       	mov	r12,r5
80009504:	d8 22       	popm	r4-r7,pc
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
80009506:	0a 9c       	mov	r12,r5
80009508:	f0 1f 00 04 	mcall	80009518 <xQueueCreate+0x70>
8000950c:	d8 2a       	popm	r4-r7,pc,r12=0
8000950e:	d8 2a       	popm	r4-r7,pc,r12=0
80009510:	80 00       	ld.sh	r0,r0[0x0]
80009512:	8f fc       	st.w	r7[0x3c],r12
80009514:	80 00       	ld.sh	r0,r0[0x0]
80009516:	8c 6c       	ld.sh	r12,r6[0xc]
80009518:	80 00       	ld.sh	r0,r0[0x0]
8000951a:	8f d4       	st.w	r7[0x34],r4

8000951c <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
8000951c:	48 38       	lddpc	r8,80009528 <vTaskSuspendAll+0xc>
8000951e:	70 09       	ld.w	r9,r8[0x0]
80009520:	2f f9       	sub	r9,-1
80009522:	91 09       	st.w	r8[0x0],r9
}
80009524:	5e fc       	retal	r12
80009526:	00 00       	add	r0,r0
80009528:	00 00       	add	r0,r0
8000952a:	12 d4       	st.w	--r9,r4

8000952c <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
8000952c:	49 a8       	lddpc	r8,80009594 <vTaskSwitchContext+0x68>
8000952e:	70 08       	ld.w	r8,r8[0x0]
80009530:	58 08       	cp.w	r8,0
80009532:	c0 b1       	brne	80009548 <vTaskSwitchContext+0x1c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80009534:	49 98       	lddpc	r8,80009598 <vTaskSwitchContext+0x6c>
80009536:	70 08       	ld.w	r8,r8[0x0]
80009538:	f0 08 00 28 	add	r8,r8,r8<<0x2
8000953c:	49 89       	lddpc	r9,8000959c <vTaskSwitchContext+0x70>
8000953e:	f2 08 03 28 	ld.w	r8,r9[r8<<0x2]
80009542:	58 08       	cp.w	r8,0
80009544:	c0 60       	breq	80009550 <vTaskSwitchContext+0x24>
80009546:	c1 18       	rjmp	80009568 <vTaskSwitchContext+0x3c>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
80009548:	30 19       	mov	r9,1
8000954a:	49 68       	lddpc	r8,800095a0 <vTaskSwitchContext+0x74>
8000954c:	91 09       	st.w	r8[0x0],r9
8000954e:	5e fc       	retal	r12

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80009550:	49 28       	lddpc	r8,80009598 <vTaskSwitchContext+0x6c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80009552:	49 3a       	lddpc	r10,8000959c <vTaskSwitchContext+0x70>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80009554:	70 09       	ld.w	r9,r8[0x0]
80009556:	20 19       	sub	r9,1
80009558:	91 09       	st.w	r8[0x0],r9

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
8000955a:	70 09       	ld.w	r9,r8[0x0]
8000955c:	f2 09 00 29 	add	r9,r9,r9<<0x2
80009560:	f4 09 03 29 	ld.w	r9,r10[r9<<0x2]
80009564:	58 09       	cp.w	r9,0
80009566:	cf 70       	breq	80009554 <vTaskSwitchContext+0x28>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
80009568:	48 c8       	lddpc	r8,80009598 <vTaskSwitchContext+0x6c>
8000956a:	70 08       	ld.w	r8,r8[0x0]
8000956c:	f0 08 00 28 	add	r8,r8,r8<<0x2
80009570:	48 b9       	lddpc	r9,8000959c <vTaskSwitchContext+0x70>
80009572:	f2 08 00 28 	add	r8,r9,r8<<0x2
80009576:	70 19       	ld.w	r9,r8[0x4]
80009578:	72 19       	ld.w	r9,r9[0x4]
8000957a:	91 19       	st.w	r8[0x4],r9
8000957c:	f0 ca ff f8 	sub	r10,r8,-8
80009580:	14 39       	cp.w	r9,r10
80009582:	f3 f9 00 01 	ld.weq	r9,r9[0x4]
80009586:	f1 f9 0a 01 	st.weq	r8[0x4],r9
8000958a:	70 18       	ld.w	r8,r8[0x4]
8000958c:	70 39       	ld.w	r9,r8[0xc]
8000958e:	48 68       	lddpc	r8,800095a4 <vTaskSwitchContext+0x78>
80009590:	91 09       	st.w	r8[0x0],r9
80009592:	5e fc       	retal	r12
80009594:	00 00       	add	r0,r0
80009596:	12 d4       	st.w	--r9,r4
80009598:	00 00       	add	r0,r0
8000959a:	13 0c       	ld.w	r12,r9++
8000959c:	00 00       	add	r0,r0
8000959e:	11 f0       	ld.ub	r0,r8[0x7]
800095a0:	00 00       	add	r0,r0
800095a2:	12 f4       	st.b	--r9,r4
800095a4:	00 00       	add	r0,r0
800095a6:	12 a4       	st.w	r9++,r4

800095a8 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
800095a8:	48 48       	lddpc	r8,800095b8 <vTaskSetTimeOutState+0x10>
800095aa:	70 08       	ld.w	r8,r8[0x0]
800095ac:	99 08       	st.w	r12[0x0],r8
	pxTimeOut->xTimeOnEntering = xTickCount;
800095ae:	48 48       	lddpc	r8,800095bc <vTaskSetTimeOutState+0x14>
800095b0:	70 08       	ld.w	r8,r8[0x0]
800095b2:	99 18       	st.w	r12[0x4],r8
}
800095b4:	5e fc       	retal	r12
800095b6:	00 00       	add	r0,r0
800095b8:	00 00       	add	r0,r0
800095ba:	11 e8       	ld.ub	r8,r8[0x6]
800095bc:	00 00       	add	r0,r0
800095be:	12 d0       	st.w	--r9,r0

800095c0 <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
800095c0:	30 19       	mov	r9,1
800095c2:	48 28       	lddpc	r8,800095c8 <vTaskMissedYield+0x8>
800095c4:	91 09       	st.w	r8[0x0],r9
}
800095c6:	5e fc       	retal	r12
800095c8:	00 00       	add	r0,r0
800095ca:	12 f4       	st.b	--r9,r4

800095cc <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
800095cc:	48 28       	lddpc	r8,800095d4 <xTaskGetCurrentTaskHandle+0x8>
800095ce:	70 0c       	ld.w	r12,r8[0x0]

		return xReturn;
	}
800095d0:	5e fc       	retal	r12
800095d2:	00 00       	add	r0,r0
800095d4:	00 00       	add	r0,r0
800095d6:	12 a4       	st.w	r9++,r4

800095d8 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
800095d8:	eb cd 40 c0 	pushm	r6-r7,lr
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
800095dc:	58 0c       	cp.w	r12,0
800095de:	c1 f0       	breq	8000961c <vTaskPriorityDisinherit+0x44>

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
800095e0:	18 97       	mov	r7,r12

		if( pxMutexHolder != NULL )
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
800095e2:	78 b9       	ld.w	r9,r12[0x2c]
800095e4:	79 18       	ld.w	r8,r12[0x44]
800095e6:	10 39       	cp.w	r9,r8
800095e8:	c1 a0       	breq	8000961c <vTaskPriorityDisinherit+0x44>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
800095ea:	f8 c6 ff fc 	sub	r6,r12,-4
800095ee:	0c 9c       	mov	r12,r6
800095f0:	f0 1f 00 0c 	mcall	80009620 <vTaskPriorityDisinherit+0x48>

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
800095f4:	6f 1c       	ld.w	r12,r7[0x44]
800095f6:	8f bc       	st.w	r7[0x2c],r12
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
800095f8:	f8 08 11 08 	rsub	r8,r12,8
800095fc:	8f 68       	st.w	r7[0x18],r8
				prvAddTaskToReadyQueue( pxTCB );
800095fe:	48 a8       	lddpc	r8,80009624 <vTaskPriorityDisinherit+0x4c>
80009600:	70 08       	ld.w	r8,r8[0x0]
80009602:	10 3c       	cp.w	r12,r8
80009604:	e0 88 00 04 	brls	8000960c <vTaskPriorityDisinherit+0x34>
80009608:	48 78       	lddpc	r8,80009624 <vTaskPriorityDisinherit+0x4c>
8000960a:	91 0c       	st.w	r8[0x0],r12
8000960c:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80009610:	0c 9b       	mov	r11,r6
80009612:	48 68       	lddpc	r8,80009628 <vTaskPriorityDisinherit+0x50>
80009614:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80009618:	f0 1f 00 05 	mcall	8000962c <vTaskPriorityDisinherit+0x54>
8000961c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80009620:	80 00       	ld.sh	r0,r0[0x0]
80009622:	8c d6       	ld.uh	r6,r6[0xa]
80009624:	00 00       	add	r0,r0
80009626:	13 0c       	ld.w	r12,r9++
80009628:	00 00       	add	r0,r0
8000962a:	11 f0       	ld.ub	r0,r8[0x7]
8000962c:	80 00       	ld.sh	r0,r0[0x0]
8000962e:	8c 86       	ld.uh	r6,r6[0x0]

80009630 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
80009630:	eb cd 40 c0 	pushm	r6-r7,lr
80009634:	18 97       	mov	r7,r12
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
80009636:	49 b8       	lddpc	r8,800096a0 <vTaskPriorityInherit+0x70>
80009638:	70 08       	ld.w	r8,r8[0x0]
8000963a:	78 b9       	ld.w	r9,r12[0x2c]
8000963c:	70 b8       	ld.w	r8,r8[0x2c]
8000963e:	10 39       	cp.w	r9,r8
80009640:	c2 d2       	brcc	8000969a <vTaskPriorityInherit+0x6a>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
80009642:	49 88       	lddpc	r8,800096a0 <vTaskPriorityInherit+0x70>
80009644:	70 08       	ld.w	r8,r8[0x0]
80009646:	70 b8       	ld.w	r8,r8[0x2c]
80009648:	f0 08 11 08 	rsub	r8,r8,8
8000964c:	99 68       	st.w	r12[0x18],r8

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
8000964e:	f2 09 00 28 	add	r8,r9,r9<<0x2
80009652:	49 59       	lddpc	r9,800096a4 <vTaskPriorityInherit+0x74>
80009654:	f2 08 00 28 	add	r8,r9,r8<<0x2
80009658:	78 59       	ld.w	r9,r12[0x14]
8000965a:	10 39       	cp.w	r9,r8
8000965c:	c1 b1       	brne	80009692 <vTaskPriorityInherit+0x62>
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
8000965e:	f8 c6 ff fc 	sub	r6,r12,-4
80009662:	0c 9c       	mov	r12,r6
80009664:	f0 1f 00 11 	mcall	800096a8 <vTaskPriorityInherit+0x78>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
80009668:	48 e8       	lddpc	r8,800096a0 <vTaskPriorityInherit+0x70>
8000966a:	70 08       	ld.w	r8,r8[0x0]
8000966c:	70 bc       	ld.w	r12,r8[0x2c]
8000966e:	8f bc       	st.w	r7[0x2c],r12
				prvAddTaskToReadyQueue( pxTCB );
80009670:	48 f8       	lddpc	r8,800096ac <vTaskPriorityInherit+0x7c>
80009672:	70 08       	ld.w	r8,r8[0x0]
80009674:	10 3c       	cp.w	r12,r8
80009676:	e0 88 00 04 	brls	8000967e <vTaskPriorityInherit+0x4e>
8000967a:	48 d8       	lddpc	r8,800096ac <vTaskPriorityInherit+0x7c>
8000967c:	91 0c       	st.w	r8[0x0],r12
8000967e:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80009682:	0c 9b       	mov	r11,r6
80009684:	48 88       	lddpc	r8,800096a4 <vTaskPriorityInherit+0x74>
80009686:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
8000968a:	f0 1f 00 0a 	mcall	800096b0 <vTaskPriorityInherit+0x80>
8000968e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
80009692:	48 48       	lddpc	r8,800096a0 <vTaskPriorityInherit+0x70>
80009694:	70 08       	ld.w	r8,r8[0x0]
80009696:	70 b8       	ld.w	r8,r8[0x2c]
80009698:	99 b8       	st.w	r12[0x2c],r8
8000969a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000969e:	00 00       	add	r0,r0
800096a0:	00 00       	add	r0,r0
800096a2:	12 a4       	st.w	r9++,r4
800096a4:	00 00       	add	r0,r0
800096a6:	11 f0       	ld.ub	r0,r8[0x7]
800096a8:	80 00       	ld.sh	r0,r0[0x0]
800096aa:	8c d6       	ld.uh	r6,r6[0xa]
800096ac:	00 00       	add	r0,r0
800096ae:	13 0c       	ld.w	r12,r9++
800096b0:	80 00       	ld.sh	r0,r0[0x0]
800096b2:	8c 86       	ld.uh	r6,r6[0x0]

800096b4 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
800096b4:	eb cd 40 c0 	pushm	r6-r7,lr
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
800096b8:	78 38       	ld.w	r8,r12[0xc]
800096ba:	70 37       	ld.w	r7,r8[0xc]
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
800096bc:	ee c6 ff e8 	sub	r6,r7,-24
800096c0:	0c 9c       	mov	r12,r6
800096c2:	f0 1f 00 15 	mcall	80009714 <xTaskRemoveFromEventList+0x60>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
800096c6:	49 58       	lddpc	r8,80009718 <xTaskRemoveFromEventList+0x64>
800096c8:	70 08       	ld.w	r8,r8[0x0]
800096ca:	58 08       	cp.w	r8,0
800096cc:	c1 71       	brne	800096fa <xTaskRemoveFromEventList+0x46>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
800096ce:	ee c6 ff fc 	sub	r6,r7,-4
800096d2:	0c 9c       	mov	r12,r6
800096d4:	f0 1f 00 10 	mcall	80009714 <xTaskRemoveFromEventList+0x60>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
800096d8:	6e bc       	ld.w	r12,r7[0x2c]
800096da:	49 18       	lddpc	r8,8000971c <xTaskRemoveFromEventList+0x68>
800096dc:	70 08       	ld.w	r8,r8[0x0]
800096de:	10 3c       	cp.w	r12,r8
800096e0:	e0 88 00 04 	brls	800096e8 <xTaskRemoveFromEventList+0x34>
800096e4:	48 e8       	lddpc	r8,8000971c <xTaskRemoveFromEventList+0x68>
800096e6:	91 0c       	st.w	r8[0x0],r12
800096e8:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800096ec:	0c 9b       	mov	r11,r6
800096ee:	48 d8       	lddpc	r8,80009720 <xTaskRemoveFromEventList+0x6c>
800096f0:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800096f4:	f0 1f 00 0c 	mcall	80009724 <xTaskRemoveFromEventList+0x70>
800096f8:	c0 58       	rjmp	80009702 <xTaskRemoveFromEventList+0x4e>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
800096fa:	0c 9b       	mov	r11,r6
800096fc:	48 bc       	lddpc	r12,80009728 <xTaskRemoveFromEventList+0x74>
800096fe:	f0 1f 00 0a 	mcall	80009724 <xTaskRemoveFromEventList+0x70>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
80009702:	48 b8       	lddpc	r8,8000972c <xTaskRemoveFromEventList+0x78>
80009704:	70 08       	ld.w	r8,r8[0x0]
80009706:	6e b9       	ld.w	r9,r7[0x2c]
80009708:	70 b8       	ld.w	r8,r8[0x2c]
8000970a:	10 39       	cp.w	r9,r8
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
8000970c:	5f 2c       	srhs	r12
8000970e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80009712:	00 00       	add	r0,r0
80009714:	80 00       	ld.sh	r0,r0[0x0]
80009716:	8c d6       	ld.uh	r6,r6[0xa]
80009718:	00 00       	add	r0,r0
8000971a:	12 d4       	st.w	--r9,r4
8000971c:	00 00       	add	r0,r0
8000971e:	13 0c       	ld.w	r12,r9++
80009720:	00 00       	add	r0,r0
80009722:	11 f0       	ld.ub	r0,r8[0x7]
80009724:	80 00       	ld.sh	r0,r0[0x0]
80009726:	8c 86       	ld.uh	r6,r6[0x0]
80009728:	00 00       	add	r0,r0
8000972a:	12 a8       	st.w	r9++,r8
8000972c:	00 00       	add	r0,r0
8000972e:	12 a4       	st.w	r9++,r4

80009730 <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
80009730:	eb cd 40 fc 	pushm	r2-r7,lr
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80009734:	4b 98       	lddpc	r8,80009818 <vTaskIncrementTick+0xe8>
80009736:	70 08       	ld.w	r8,r8[0x0]
80009738:	58 08       	cp.w	r8,0
8000973a:	c6 91       	brne	8000980c <vTaskIncrementTick+0xdc>
	{
		++xTickCount;
8000973c:	4b 88       	lddpc	r8,8000981c <vTaskIncrementTick+0xec>
8000973e:	70 09       	ld.w	r9,r8[0x0]
80009740:	2f f9       	sub	r9,-1
80009742:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
80009744:	70 08       	ld.w	r8,r8[0x0]
80009746:	58 08       	cp.w	r8,0
80009748:	c1 a1       	brne	8000977c <vTaskIncrementTick+0x4c>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
8000974a:	4b 68       	lddpc	r8,80009820 <vTaskIncrementTick+0xf0>
8000974c:	70 0a       	ld.w	r10,r8[0x0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
8000974e:	4b 69       	lddpc	r9,80009824 <vTaskIncrementTick+0xf4>
80009750:	72 0b       	ld.w	r11,r9[0x0]
80009752:	91 0b       	st.w	r8[0x0],r11
			pxOverflowDelayedTaskList = pxTemp;
80009754:	93 0a       	st.w	r9[0x0],r10
			xNumOfOverflows++;
80009756:	4b 59       	lddpc	r9,80009828 <vTaskIncrementTick+0xf8>
80009758:	72 0a       	ld.w	r10,r9[0x0]
8000975a:	2f fa       	sub	r10,-1
8000975c:	93 0a       	st.w	r9[0x0],r10

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
8000975e:	70 08       	ld.w	r8,r8[0x0]
80009760:	70 08       	ld.w	r8,r8[0x0]
80009762:	58 08       	cp.w	r8,0
80009764:	c0 51       	brne	8000976e <vTaskIncrementTick+0x3e>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
80009766:	3f f9       	mov	r9,-1
80009768:	4b 18       	lddpc	r8,8000982c <vTaskIncrementTick+0xfc>
8000976a:	91 09       	st.w	r8[0x0],r9
8000976c:	c0 88       	rjmp	8000977c <vTaskIncrementTick+0x4c>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
8000976e:	4a d8       	lddpc	r8,80009820 <vTaskIncrementTick+0xf0>
80009770:	70 08       	ld.w	r8,r8[0x0]
80009772:	70 38       	ld.w	r8,r8[0xc]
80009774:	70 38       	ld.w	r8,r8[0xc]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
80009776:	70 19       	ld.w	r9,r8[0x4]
80009778:	4a d8       	lddpc	r8,8000982c <vTaskIncrementTick+0xfc>
8000977a:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
8000977c:	4a 88       	lddpc	r8,8000981c <vTaskIncrementTick+0xec>
8000977e:	70 09       	ld.w	r9,r8[0x0]
80009780:	4a b8       	lddpc	r8,8000982c <vTaskIncrementTick+0xfc>
80009782:	70 08       	ld.w	r8,r8[0x0]
80009784:	10 39       	cp.w	r9,r8
80009786:	c4 73       	brcs	80009814 <vTaskIncrementTick+0xe4>
80009788:	4a 68       	lddpc	r8,80009820 <vTaskIncrementTick+0xf0>
8000978a:	70 08       	ld.w	r8,r8[0x0]
8000978c:	70 08       	ld.w	r8,r8[0x0]
8000978e:	58 08       	cp.w	r8,0
80009790:	c0 c0       	breq	800097a8 <vTaskIncrementTick+0x78>
80009792:	4a 48       	lddpc	r8,80009820 <vTaskIncrementTick+0xf0>
80009794:	70 08       	ld.w	r8,r8[0x0]
80009796:	70 38       	ld.w	r8,r8[0xc]
80009798:	70 37       	ld.w	r7,r8[0xc]
8000979a:	6e 18       	ld.w	r8,r7[0x4]
8000979c:	4a 09       	lddpc	r9,8000981c <vTaskIncrementTick+0xec>
8000979e:	72 09       	ld.w	r9,r9[0x0]
800097a0:	12 38       	cp.w	r8,r9
800097a2:	e0 88 00 14 	brls	800097ca <vTaskIncrementTick+0x9a>
800097a6:	c0 e8       	rjmp	800097c2 <vTaskIncrementTick+0x92>
800097a8:	3f f9       	mov	r9,-1
800097aa:	4a 18       	lddpc	r8,8000982c <vTaskIncrementTick+0xfc>
800097ac:	91 09       	st.w	r8[0x0],r9
800097ae:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800097b2:	6a 08       	ld.w	r8,r5[0x0]
800097b4:	70 38       	ld.w	r8,r8[0xc]
800097b6:	70 37       	ld.w	r7,r8[0xc]
800097b8:	6e 18       	ld.w	r8,r7[0x4]
800097ba:	64 09       	ld.w	r9,r2[0x0]
800097bc:	12 38       	cp.w	r8,r9
800097be:	e0 88 00 0a 	brls	800097d2 <vTaskIncrementTick+0xa2>
800097c2:	49 b9       	lddpc	r9,8000982c <vTaskIncrementTick+0xfc>
800097c4:	93 08       	st.w	r9[0x0],r8
800097c6:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800097ca:	49 a4       	lddpc	r4,80009830 <vTaskIncrementTick+0x100>
800097cc:	49 a3       	lddpc	r3,80009834 <vTaskIncrementTick+0x104>
800097ce:	49 55       	lddpc	r5,80009820 <vTaskIncrementTick+0xf0>
800097d0:	49 32       	lddpc	r2,8000981c <vTaskIncrementTick+0xec>
800097d2:	ee c6 ff fc 	sub	r6,r7,-4
800097d6:	0c 9c       	mov	r12,r6
800097d8:	f0 1f 00 18 	mcall	80009838 <vTaskIncrementTick+0x108>
800097dc:	6e a8       	ld.w	r8,r7[0x28]
800097de:	58 08       	cp.w	r8,0
800097e0:	c0 50       	breq	800097ea <vTaskIncrementTick+0xba>
800097e2:	ee cc ff e8 	sub	r12,r7,-24
800097e6:	f0 1f 00 15 	mcall	80009838 <vTaskIncrementTick+0x108>
800097ea:	6e bc       	ld.w	r12,r7[0x2c]
800097ec:	68 08       	ld.w	r8,r4[0x0]
800097ee:	10 3c       	cp.w	r12,r8
800097f0:	e9 fc ba 00 	st.whi	r4[0x0],r12
800097f4:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800097f8:	0c 9b       	mov	r11,r6
800097fa:	e6 0c 00 2c 	add	r12,r3,r12<<0x2
800097fe:	f0 1f 00 10 	mcall	8000983c <vTaskIncrementTick+0x10c>
80009802:	6a 08       	ld.w	r8,r5[0x0]
80009804:	70 08       	ld.w	r8,r8[0x0]
80009806:	58 08       	cp.w	r8,0
80009808:	cd 51       	brne	800097b2 <vTaskIncrementTick+0x82>
8000980a:	cc fb       	rjmp	800097a8 <vTaskIncrementTick+0x78>
	}
	else
	{
		++uxMissedTicks;
8000980c:	48 d8       	lddpc	r8,80009840 <vTaskIncrementTick+0x110>
8000980e:	70 09       	ld.w	r9,r8[0x0]
80009810:	2f f9       	sub	r9,-1
80009812:	91 09       	st.w	r8[0x0],r9
80009814:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80009818:	00 00       	add	r0,r0
8000981a:	12 d4       	st.w	--r9,r4
8000981c:	00 00       	add	r0,r0
8000981e:	12 d0       	st.w	--r9,r0
80009820:	00 00       	add	r0,r0
80009822:	11 dc       	ld.ub	r12,r8[0x5]
80009824:	00 00       	add	r0,r0
80009826:	11 ec       	ld.ub	r12,r8[0x6]
80009828:	00 00       	add	r0,r0
8000982a:	11 e8       	ld.ub	r8,r8[0x6]
8000982c:	00 00       	add	r0,r0
8000982e:	05 34       	ld.ub	r4,r2++
80009830:	00 00       	add	r0,r0
80009832:	13 0c       	ld.w	r12,r9++
80009834:	00 00       	add	r0,r0
80009836:	11 f0       	ld.ub	r0,r8[0x7]
80009838:	80 00       	ld.sh	r0,r0[0x0]
8000983a:	8c d6       	ld.uh	r6,r6[0xa]
8000983c:	80 00       	ld.sh	r0,r0[0x0]
8000983e:	8c 86       	ld.uh	r6,r6[0x0]
80009840:	00 00       	add	r0,r0
80009842:	11 d4       	ld.ub	r4,r8[0x5]

80009844 <xTaskCheckForTimeOut>:
	pxTimeOut->xTimeOnEntering = xTickCount;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
80009844:	eb cd 40 c0 	pushm	r6-r7,lr
80009848:	18 97       	mov	r7,r12
8000984a:	16 96       	mov	r6,r11
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
8000984c:	f0 1f 00 15 	mcall	800098a0 <xTaskCheckForTimeOut+0x5c>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
80009850:	6c 08       	ld.w	r8,r6[0x0]
80009852:	5b f8       	cp.w	r8,-1
80009854:	c0 31       	brne	8000985a <xTaskCheckForTimeOut+0x16>
80009856:	30 07       	mov	r7,0
80009858:	c1 f8       	rjmp	80009896 <xTaskCheckForTimeOut+0x52>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
8000985a:	49 39       	lddpc	r9,800098a4 <xTaskCheckForTimeOut+0x60>
8000985c:	72 09       	ld.w	r9,r9[0x0]
8000985e:	6e 0a       	ld.w	r10,r7[0x0]
80009860:	12 3a       	cp.w	r10,r9
80009862:	c0 70       	breq	80009870 <xTaskCheckForTimeOut+0x2c>
80009864:	49 19       	lddpc	r9,800098a8 <xTaskCheckForTimeOut+0x64>
80009866:	72 09       	ld.w	r9,r9[0x0]
80009868:	6e 1a       	ld.w	r10,r7[0x4]
8000986a:	12 3a       	cp.w	r10,r9
8000986c:	e0 88 00 14 	brls	80009894 <xTaskCheckForTimeOut+0x50>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
80009870:	48 e9       	lddpc	r9,800098a8 <xTaskCheckForTimeOut+0x64>
80009872:	72 0a       	ld.w	r10,r9[0x0]
80009874:	6e 19       	ld.w	r9,r7[0x4]
80009876:	12 1a       	sub	r10,r9
80009878:	14 38       	cp.w	r8,r10
8000987a:	e0 88 00 0d 	brls	80009894 <xTaskCheckForTimeOut+0x50>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
8000987e:	48 ba       	lddpc	r10,800098a8 <xTaskCheckForTimeOut+0x64>
80009880:	74 0a       	ld.w	r10,r10[0x0]
80009882:	14 19       	sub	r9,r10
80009884:	f2 08 00 08 	add	r8,r9,r8
80009888:	8d 08       	st.w	r6[0x0],r8
			vTaskSetTimeOutState( pxTimeOut );
8000988a:	0e 9c       	mov	r12,r7
8000988c:	f0 1f 00 08 	mcall	800098ac <xTaskCheckForTimeOut+0x68>
80009890:	30 07       	mov	r7,0
80009892:	c0 28       	rjmp	80009896 <xTaskCheckForTimeOut+0x52>
80009894:	30 17       	mov	r7,1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
80009896:	f0 1f 00 07 	mcall	800098b0 <xTaskCheckForTimeOut+0x6c>

	return xReturn;
}
8000989a:	0e 9c       	mov	r12,r7
8000989c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800098a0:	80 00       	ld.sh	r0,r0[0x0]
800098a2:	8d 90       	st.w	r6[0x24],r0
800098a4:	00 00       	add	r0,r0
800098a6:	11 e8       	ld.ub	r8,r8[0x6]
800098a8:	00 00       	add	r0,r0
800098aa:	12 d0       	st.w	--r9,r0
800098ac:	80 00       	ld.sh	r0,r0[0x0]
800098ae:	95 a8       	st.w	r10[0x28],r8
800098b0:	80 00       	ld.sh	r0,r0[0x0]
800098b2:	8e 9c       	ld.uh	r12,r7[0x2]

800098b4 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
800098b4:	eb cd 40 80 	pushm	r7,lr
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
800098b8:	f0 1f 00 05 	mcall	800098cc <xTaskGetTickCount+0x18>
	{
		xTicks = xTickCount;
800098bc:	48 58       	lddpc	r8,800098d0 <xTaskGetTickCount+0x1c>
800098be:	70 07       	ld.w	r7,r8[0x0]
	}
	taskEXIT_CRITICAL();
800098c0:	f0 1f 00 05 	mcall	800098d4 <xTaskGetTickCount+0x20>

	return xTicks;
}
800098c4:	0e 9c       	mov	r12,r7
800098c6:	e3 cd 80 80 	ldm	sp++,r7,pc
800098ca:	00 00       	add	r0,r0
800098cc:	80 00       	ld.sh	r0,r0[0x0]
800098ce:	8d 90       	st.w	r6[0x24],r0
800098d0:	00 00       	add	r0,r0
800098d2:	12 d0       	st.w	--r9,r0
800098d4:	80 00       	ld.sh	r0,r0[0x0]
800098d6:	8e 9c       	ld.uh	r12,r7[0x2]

800098d8 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
800098d8:	eb cd 40 fe 	pushm	r1-r7,lr
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
800098dc:	f0 1f 00 2c 	mcall	8000998c <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;
800098e0:	4a c8       	lddpc	r8,80009990 <xTaskResumeAll+0xb8>
800098e2:	70 09       	ld.w	r9,r8[0x0]
800098e4:	20 19       	sub	r9,1
800098e6:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
800098e8:	70 08       	ld.w	r8,r8[0x0]
800098ea:	58 08       	cp.w	r8,0
800098ec:	c4 91       	brne	8000997e <xTaskResumeAll+0xa6>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
800098ee:	4a a8       	lddpc	r8,80009994 <xTaskResumeAll+0xbc>
800098f0:	70 08       	ld.w	r8,r8[0x0]
800098f2:	58 08       	cp.w	r8,0
800098f4:	c4 50       	breq	8000997e <xTaskResumeAll+0xa6>
800098f6:	30 04       	mov	r4,0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
800098f8:	4a 85       	lddpc	r5,80009998 <xTaskResumeAll+0xc0>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
800098fa:	4a 93       	lddpc	r3,8000999c <xTaskResumeAll+0xc4>
800098fc:	4a 92       	lddpc	r2,800099a0 <xTaskResumeAll+0xc8>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
800098fe:	4a a1       	lddpc	r1,800099a4 <xTaskResumeAll+0xcc>
80009900:	c1 e8       	rjmp	8000993c <xTaskResumeAll+0x64>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
80009902:	6a 38       	ld.w	r8,r5[0xc]
80009904:	70 37       	ld.w	r7,r8[0xc]
					vListRemove( &( pxTCB->xEventListItem ) );
80009906:	ee cc ff e8 	sub	r12,r7,-24
8000990a:	f0 1f 00 28 	mcall	800099a8 <xTaskResumeAll+0xd0>
					vListRemove( &( pxTCB->xGenericListItem ) );
8000990e:	ee c6 ff fc 	sub	r6,r7,-4
80009912:	0c 9c       	mov	r12,r6
80009914:	f0 1f 00 25 	mcall	800099a8 <xTaskResumeAll+0xd0>
					prvAddTaskToReadyQueue( pxTCB );
80009918:	6e bc       	ld.w	r12,r7[0x2c]
8000991a:	66 08       	ld.w	r8,r3[0x0]
8000991c:	10 3c       	cp.w	r12,r8
8000991e:	e7 fc ba 00 	st.whi	r3[0x0],r12
80009922:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80009926:	0c 9b       	mov	r11,r6
80009928:	e4 0c 00 2c 	add	r12,r2,r12<<0x2
8000992c:	f0 1f 00 20 	mcall	800099ac <xTaskResumeAll+0xd4>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80009930:	62 08       	ld.w	r8,r1[0x0]
80009932:	6e b9       	ld.w	r9,r7[0x2c]
80009934:	70 b8       	ld.w	r8,r8[0x2c]
80009936:	10 39       	cp.w	r9,r8
80009938:	f9 b4 02 01 	movhs	r4,1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
8000993c:	6a 08       	ld.w	r8,r5[0x0]
8000993e:	58 08       	cp.w	r8,0
80009940:	ce 11       	brne	80009902 <xTaskResumeAll+0x2a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80009942:	49 c8       	lddpc	r8,800099b0 <xTaskResumeAll+0xd8>
80009944:	70 08       	ld.w	r8,r8[0x0]
80009946:	58 08       	cp.w	r8,0
80009948:	c0 f0       	breq	80009966 <xTaskResumeAll+0x8e>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
8000994a:	49 a8       	lddpc	r8,800099b0 <xTaskResumeAll+0xd8>
8000994c:	70 08       	ld.w	r8,r8[0x0]
8000994e:	58 08       	cp.w	r8,0
80009950:	c1 10       	breq	80009972 <xTaskResumeAll+0x9a>
					{
						vTaskIncrementTick();
						--uxMissedTicks;
80009952:	49 87       	lddpc	r7,800099b0 <xTaskResumeAll+0xd8>
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
80009954:	f0 1f 00 18 	mcall	800099b4 <xTaskResumeAll+0xdc>
						--uxMissedTicks;
80009958:	6e 08       	ld.w	r8,r7[0x0]
8000995a:	20 18       	sub	r8,1
8000995c:	8f 08       	st.w	r7[0x0],r8
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
8000995e:	6e 08       	ld.w	r8,r7[0x0]
80009960:	58 08       	cp.w	r8,0
80009962:	cf 91       	brne	80009954 <xTaskResumeAll+0x7c>
80009964:	c0 78       	rjmp	80009972 <xTaskResumeAll+0x9a>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
80009966:	58 14       	cp.w	r4,1
80009968:	c0 50       	breq	80009972 <xTaskResumeAll+0x9a>
8000996a:	49 48       	lddpc	r8,800099b8 <xTaskResumeAll+0xe0>
8000996c:	70 08       	ld.w	r8,r8[0x0]
8000996e:	58 18       	cp.w	r8,1
80009970:	c0 71       	brne	8000997e <xTaskResumeAll+0xa6>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
80009972:	30 09       	mov	r9,0
80009974:	49 18       	lddpc	r8,800099b8 <xTaskResumeAll+0xe0>
80009976:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
80009978:	d7 33       	scall
8000997a:	30 17       	mov	r7,1
8000997c:	c0 28       	rjmp	80009980 <xTaskResumeAll+0xa8>
8000997e:	30 07       	mov	r7,0
				}
			}
		}
	}
	taskEXIT_CRITICAL();
80009980:	f0 1f 00 0f 	mcall	800099bc <xTaskResumeAll+0xe4>

	return xAlreadyYielded;
}
80009984:	0e 9c       	mov	r12,r7
80009986:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
8000998a:	00 00       	add	r0,r0
8000998c:	80 00       	ld.sh	r0,r0[0x0]
8000998e:	8d 90       	st.w	r6[0x24],r0
80009990:	00 00       	add	r0,r0
80009992:	12 d4       	st.w	--r9,r4
80009994:	00 00       	add	r0,r0
80009996:	12 f0       	st.b	--r9,r0
80009998:	00 00       	add	r0,r0
8000999a:	12 a8       	st.w	r9++,r8
8000999c:	00 00       	add	r0,r0
8000999e:	13 0c       	ld.w	r12,r9++
800099a0:	00 00       	add	r0,r0
800099a2:	11 f0       	ld.ub	r0,r8[0x7]
800099a4:	00 00       	add	r0,r0
800099a6:	12 a4       	st.w	r9++,r4
800099a8:	80 00       	ld.sh	r0,r0[0x0]
800099aa:	8c d6       	ld.uh	r6,r6[0xa]
800099ac:	80 00       	ld.sh	r0,r0[0x0]
800099ae:	8c 86       	ld.uh	r6,r6[0x0]
800099b0:	00 00       	add	r0,r0
800099b2:	11 d4       	ld.ub	r4,r8[0x5]
800099b4:	80 00       	ld.sh	r0,r0[0x0]
800099b6:	97 30       	st.w	r11[0xc],r0
800099b8:	00 00       	add	r0,r0
800099ba:	12 f4       	st.b	--r9,r4
800099bc:	80 00       	ld.sh	r0,r0[0x0]
800099be:	8e 9c       	ld.uh	r12,r7[0x2]

800099c0 <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
800099c0:	eb cd 40 80 	pushm	r7,lr
800099c4:	18 97       	mov	r7,r12
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
800099c6:	49 08       	lddpc	r8,80009a04 <prvAddCurrentTaskToDelayedList+0x44>
800099c8:	70 08       	ld.w	r8,r8[0x0]
800099ca:	91 1c       	st.w	r8[0x4],r12

	if( xTimeToWake < xTickCount )
800099cc:	48 f8       	lddpc	r8,80009a08 <prvAddCurrentTaskToDelayedList+0x48>
800099ce:	70 08       	ld.w	r8,r8[0x0]
800099d0:	10 3c       	cp.w	r12,r8
800099d2:	c0 a2       	brcc	800099e6 <prvAddCurrentTaskToDelayedList+0x26>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800099d4:	48 c8       	lddpc	r8,80009a04 <prvAddCurrentTaskToDelayedList+0x44>
800099d6:	70 0b       	ld.w	r11,r8[0x0]
800099d8:	48 d8       	lddpc	r8,80009a0c <prvAddCurrentTaskToDelayedList+0x4c>
800099da:	70 0c       	ld.w	r12,r8[0x0]
800099dc:	2f cb       	sub	r11,-4
800099de:	f0 1f 00 0d 	mcall	80009a10 <prvAddCurrentTaskToDelayedList+0x50>
800099e2:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800099e6:	48 88       	lddpc	r8,80009a04 <prvAddCurrentTaskToDelayedList+0x44>
800099e8:	70 0b       	ld.w	r11,r8[0x0]
800099ea:	48 b8       	lddpc	r8,80009a14 <prvAddCurrentTaskToDelayedList+0x54>
800099ec:	70 0c       	ld.w	r12,r8[0x0]
800099ee:	2f cb       	sub	r11,-4
800099f0:	f0 1f 00 08 	mcall	80009a10 <prvAddCurrentTaskToDelayedList+0x50>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
800099f4:	48 98       	lddpc	r8,80009a18 <prvAddCurrentTaskToDelayedList+0x58>
800099f6:	70 08       	ld.w	r8,r8[0x0]
800099f8:	10 37       	cp.w	r7,r8
800099fa:	c0 32       	brcc	80009a00 <prvAddCurrentTaskToDelayedList+0x40>
		{
			xNextTaskUnblockTime = xTimeToWake;
800099fc:	48 78       	lddpc	r8,80009a18 <prvAddCurrentTaskToDelayedList+0x58>
800099fe:	91 07       	st.w	r8[0x0],r7
80009a00:	e3 cd 80 80 	ldm	sp++,r7,pc
80009a04:	00 00       	add	r0,r0
80009a06:	12 a4       	st.w	r9++,r4
80009a08:	00 00       	add	r0,r0
80009a0a:	12 d0       	st.w	--r9,r0
80009a0c:	00 00       	add	r0,r0
80009a0e:	11 ec       	ld.ub	r12,r8[0x6]
80009a10:	80 00       	ld.sh	r0,r0[0x0]
80009a12:	8c a2       	ld.uh	r2,r6[0x4]
80009a14:	00 00       	add	r0,r0
80009a16:	11 dc       	ld.ub	r12,r8[0x5]
80009a18:	00 00       	add	r0,r0
80009a1a:	05 34       	ld.ub	r4,r2++

80009a1c <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
80009a1c:	eb cd 40 c0 	pushm	r6-r7,lr
80009a20:	18 96       	mov	r6,r12
80009a22:	16 97       	mov	r7,r11
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0 ) );

		vTaskSuspendAll();
80009a24:	f0 1f 00 18 	mcall	80009a84 <vTaskDelayUntil+0x68>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
80009a28:	6c 08       	ld.w	r8,r6[0x0]
80009a2a:	10 07       	add	r7,r8

			if( xTickCount < *pxPreviousWakeTime )
80009a2c:	49 79       	lddpc	r9,80009a88 <vTaskDelayUntil+0x6c>
80009a2e:	72 09       	ld.w	r9,r9[0x0]
80009a30:	12 38       	cp.w	r8,r9
80009a32:	e0 88 00 0c 	brls	80009a4a <vTaskDelayUntil+0x2e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
80009a36:	0e 38       	cp.w	r8,r7
80009a38:	e0 88 00 22 	brls	80009a7c <vTaskDelayUntil+0x60>
80009a3c:	49 38       	lddpc	r8,80009a88 <vTaskDelayUntil+0x6c>
80009a3e:	70 08       	ld.w	r8,r8[0x0]
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80009a40:	8d 07       	st.w	r6[0x0],r7

			if( xShouldDelay != pdFALSE )
80009a42:	10 37       	cp.w	r7,r8
80009a44:	e0 88 00 14 	brls	80009a6c <vTaskDelayUntil+0x50>
80009a48:	c0 a8       	rjmp	80009a5c <vTaskDelayUntil+0x40>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
80009a4a:	0e 38       	cp.w	r8,r7
80009a4c:	e0 8b 00 16 	brhi	80009a78 <vTaskDelayUntil+0x5c>
80009a50:	48 e8       	lddpc	r8,80009a88 <vTaskDelayUntil+0x6c>
80009a52:	70 08       	ld.w	r8,r8[0x0]
80009a54:	10 37       	cp.w	r7,r8
80009a56:	e0 8b 00 11 	brhi	80009a78 <vTaskDelayUntil+0x5c>
80009a5a:	c1 18       	rjmp	80009a7c <vTaskDelayUntil+0x60>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80009a5c:	48 c8       	lddpc	r8,80009a8c <vTaskDelayUntil+0x70>
80009a5e:	70 0c       	ld.w	r12,r8[0x0]
80009a60:	2f cc       	sub	r12,-4
80009a62:	f0 1f 00 0c 	mcall	80009a90 <vTaskDelayUntil+0x74>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
80009a66:	0e 9c       	mov	r12,r7
80009a68:	f0 1f 00 0b 	mcall	80009a94 <vTaskDelayUntil+0x78>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
80009a6c:	f0 1f 00 0b 	mcall	80009a98 <vTaskDelayUntil+0x7c>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
80009a70:	c0 81       	brne	80009a80 <vTaskDelayUntil+0x64>
		{
			portYIELD_WITHIN_API();
80009a72:	d7 33       	scall
80009a74:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80009a78:	8d 07       	st.w	r6[0x0],r7
80009a7a:	cf 1b       	rjmp	80009a5c <vTaskDelayUntil+0x40>
80009a7c:	8d 07       	st.w	r6[0x0],r7
80009a7e:	cf 7b       	rjmp	80009a6c <vTaskDelayUntil+0x50>
80009a80:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80009a84:	80 00       	ld.sh	r0,r0[0x0]
80009a86:	95 1c       	st.w	r10[0x4],r12
80009a88:	00 00       	add	r0,r0
80009a8a:	12 d0       	st.w	--r9,r0
80009a8c:	00 00       	add	r0,r0
80009a8e:	12 a4       	st.w	r9++,r4
80009a90:	80 00       	ld.sh	r0,r0[0x0]
80009a92:	8c d6       	ld.uh	r6,r6[0xa]
80009a94:	80 00       	ld.sh	r0,r0[0x0]
80009a96:	99 c0       	st.w	r12[0x30],r0
80009a98:	80 00       	ld.sh	r0,r0[0x0]
80009a9a:	98 d8       	ld.uh	r8,r12[0xa]

80009a9c <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
80009a9c:	eb cd 40 c0 	pushm	r6-r7,lr
80009aa0:	16 96       	mov	r6,r11
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
80009aa2:	48 e7       	lddpc	r7,80009ad8 <vTaskPlaceOnEventList+0x3c>
80009aa4:	6e 0b       	ld.w	r11,r7[0x0]
80009aa6:	2e 8b       	sub	r11,-24
80009aa8:	f0 1f 00 0d 	mcall	80009adc <vTaskPlaceOnEventList+0x40>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80009aac:	6e 0c       	ld.w	r12,r7[0x0]
80009aae:	2f cc       	sub	r12,-4
80009ab0:	f0 1f 00 0c 	mcall	80009ae0 <vTaskPlaceOnEventList+0x44>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
80009ab4:	5b f6       	cp.w	r6,-1
80009ab6:	c0 81       	brne	80009ac6 <vTaskPlaceOnEventList+0x2a>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80009ab8:	6e 0b       	ld.w	r11,r7[0x0]
80009aba:	2f cb       	sub	r11,-4
80009abc:	48 ac       	lddpc	r12,80009ae4 <vTaskPlaceOnEventList+0x48>
80009abe:	f0 1f 00 0b 	mcall	80009ae8 <vTaskPlaceOnEventList+0x4c>
80009ac2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
80009ac6:	48 a8       	lddpc	r8,80009aec <vTaskPlaceOnEventList+0x50>
80009ac8:	70 0c       	ld.w	r12,r8[0x0]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
80009aca:	ec 0c 00 0c 	add	r12,r6,r12
80009ace:	f0 1f 00 09 	mcall	80009af0 <vTaskPlaceOnEventList+0x54>
80009ad2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80009ad6:	00 00       	add	r0,r0
80009ad8:	00 00       	add	r0,r0
80009ada:	12 a4       	st.w	r9++,r4
80009adc:	80 00       	ld.sh	r0,r0[0x0]
80009ade:	8c a2       	ld.uh	r2,r6[0x4]
80009ae0:	80 00       	ld.sh	r0,r0[0x0]
80009ae2:	8c d6       	ld.uh	r6,r6[0xa]
80009ae4:	00 00       	add	r0,r0
80009ae6:	12 f8       	st.b	--r9,r8
80009ae8:	80 00       	ld.sh	r0,r0[0x0]
80009aea:	8c 86       	ld.uh	r6,r6[0x0]
80009aec:	00 00       	add	r0,r0
80009aee:	12 d0       	st.w	--r9,r0
80009af0:	80 00       	ld.sh	r0,r0[0x0]
80009af2:	99 c0       	st.w	r12[0x30],r0

80009af4 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
80009af4:	eb cd 40 f8 	pushm	r3-r7,lr
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80009af8:	49 67       	lddpc	r7,80009b50 <prvIdleTask+0x5c>
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80009afa:	49 74       	lddpc	r4,80009b54 <prvIdleTask+0x60>

				taskENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					--uxCurrentNumberOfTasks;
80009afc:	49 73       	lddpc	r3,80009b58 <prvIdleTask+0x64>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80009afe:	49 85       	lddpc	r5,80009b5c <prvIdleTask+0x68>
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80009b00:	6e 08       	ld.w	r8,r7[0x0]
80009b02:	58 08       	cp.w	r8,0
80009b04:	c1 e0       	breq	80009b40 <prvIdleTask+0x4c>
		{
			vTaskSuspendAll();
80009b06:	f0 1f 00 17 	mcall	80009b60 <prvIdleTask+0x6c>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80009b0a:	68 06       	ld.w	r6,r4[0x0]
			xTaskResumeAll();
80009b0c:	f0 1f 00 16 	mcall	80009b64 <prvIdleTask+0x70>

			if( xListIsEmpty == pdFALSE )
80009b10:	58 06       	cp.w	r6,0
80009b12:	c1 70       	breq	80009b40 <prvIdleTask+0x4c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
80009b14:	f0 1f 00 15 	mcall	80009b68 <prvIdleTask+0x74>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
80009b18:	68 38       	ld.w	r8,r4[0xc]
80009b1a:	70 36       	ld.w	r6,r8[0xc]
					vListRemove( &( pxTCB->xGenericListItem ) );
80009b1c:	ec cc ff fc 	sub	r12,r6,-4
80009b20:	f0 1f 00 13 	mcall	80009b6c <prvIdleTask+0x78>
					--uxCurrentNumberOfTasks;
80009b24:	66 08       	ld.w	r8,r3[0x0]
80009b26:	20 18       	sub	r8,1
80009b28:	87 08       	st.w	r3[0x0],r8
					--uxTasksDeleted;
80009b2a:	6e 08       	ld.w	r8,r7[0x0]
80009b2c:	20 18       	sub	r8,1
80009b2e:	8f 08       	st.w	r7[0x0],r8
				}
				taskEXIT_CRITICAL();
80009b30:	f0 1f 00 10 	mcall	80009b70 <prvIdleTask+0x7c>

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
80009b34:	6c cc       	ld.w	r12,r6[0x30]
80009b36:	f0 1f 00 10 	mcall	80009b74 <prvIdleTask+0x80>
		vPortFree( pxTCB );
80009b3a:	0c 9c       	mov	r12,r6
80009b3c:	f0 1f 00 0e 	mcall	80009b74 <prvIdleTask+0x80>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80009b40:	6a 08       	ld.w	r8,r5[0x0]
80009b42:	58 18       	cp.w	r8,1
80009b44:	e0 88 00 03 	brls	80009b4a <prvIdleTask+0x56>
			{
				taskYIELD();
80009b48:	d7 33       	scall
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
80009b4a:	f0 1f 00 0c 	mcall	80009b78 <prvIdleTask+0x84>
		}
		#endif
	}
80009b4e:	cd 9b       	rjmp	80009b00 <prvIdleTask+0xc>
80009b50:	00 00       	add	r0,r0
80009b52:	11 e4       	ld.ub	r4,r8[0x6]
80009b54:	00 00       	add	r0,r0
80009b56:	12 90       	mov	r0,r9
80009b58:	00 00       	add	r0,r0
80009b5a:	12 f0       	st.b	--r9,r0
80009b5c:	00 00       	add	r0,r0
80009b5e:	11 f0       	ld.ub	r0,r8[0x7]
80009b60:	80 00       	ld.sh	r0,r0[0x0]
80009b62:	95 1c       	st.w	r10[0x4],r12
80009b64:	80 00       	ld.sh	r0,r0[0x0]
80009b66:	98 d8       	ld.uh	r8,r12[0xa]
80009b68:	80 00       	ld.sh	r0,r0[0x0]
80009b6a:	8d 90       	st.w	r6[0x24],r0
80009b6c:	80 00       	ld.sh	r0,r0[0x0]
80009b6e:	8c d6       	ld.uh	r6,r6[0xa]
80009b70:	80 00       	ld.sh	r0,r0[0x0]
80009b72:	8e 9c       	ld.uh	r12,r7[0x2]
80009b74:	80 00       	ld.sh	r0,r0[0x0]
80009b76:	8f d4       	st.w	r7[0x34],r4
80009b78:	80 00       	ld.sh	r0,r0[0x0]
80009b7a:	20 38       	sub	r8,3

80009b7c <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
80009b7c:	d4 31       	pushm	r0-r7,lr
80009b7e:	20 1d       	sub	sp,4
80009b80:	fa c4 ff d8 	sub	r4,sp,-40
80009b84:	50 0c       	stdsp	sp[0x0],r12
80009b86:	16 91       	mov	r1,r11
80009b88:	14 97       	mov	r7,r10
80009b8a:	12 90       	mov	r0,r9
80009b8c:	10 93       	mov	r3,r8
80009b8e:	68 02       	ld.w	r2,r4[0x0]
80009b90:	68 16       	ld.w	r6,r4[0x4]
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
80009b92:	34 8c       	mov	r12,72
80009b94:	f0 1f 00 5c 	mcall	80009d04 <xTaskGenericCreate+0x188>
80009b98:	18 95       	mov	r5,r12

	if( pxNewTCB != NULL )
80009b9a:	c0 31       	brne	80009ba0 <xTaskGenericCreate+0x24>
80009b9c:	3f fc       	mov	r12,-1
80009b9e:	ca f8       	rjmp	80009cfc <xTaskGenericCreate+0x180>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80009ba0:	58 06       	cp.w	r6,0
80009ba2:	e0 81 00 af 	brne	80009d00 <xTaskGenericCreate+0x184>
80009ba6:	0e 9c       	mov	r12,r7
80009ba8:	5c 7c       	castu.h	r12
80009baa:	a3 6c       	lsl	r12,0x2
80009bac:	f0 1f 00 56 	mcall	80009d04 <xTaskGenericCreate+0x188>
80009bb0:	18 96       	mov	r6,r12
80009bb2:	8b cc       	st.w	r5[0x30],r12

		if( pxNewTCB->pxStack == NULL )
80009bb4:	c0 61       	brne	80009bc0 <xTaskGenericCreate+0x44>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
80009bb6:	0a 9c       	mov	r12,r5
80009bb8:	f0 1f 00 54 	mcall	80009d08 <xTaskGenericCreate+0x18c>
80009bbc:	3f fc       	mov	r12,-1
80009bbe:	c9 f8       	rjmp	80009cfc <xTaskGenericCreate+0x180>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
80009bc0:	5c 77       	castu.h	r7
80009bc2:	ee 0a 15 02 	lsl	r10,r7,0x2
80009bc6:	e0 6b 00 a5 	mov	r11,165
80009bca:	0c 9c       	mov	r12,r6
80009bcc:	f0 1f 00 50 	mcall	80009d0c <xTaskGenericCreate+0x190>
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
80009bd0:	ee c6 00 01 	sub	r6,r7,1
80009bd4:	6a c8       	ld.w	r8,r5[0x30]
80009bd6:	f0 06 00 26 	add	r6,r8,r6<<0x2
80009bda:	e0 16 ff fc 	andl	r6,0xfffc
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
80009bde:	31 0a       	mov	r10,16
80009be0:	02 9b       	mov	r11,r1
80009be2:	ea cc ff cc 	sub	r12,r5,-52
80009be6:	f0 1f 00 4b 	mcall	80009d10 <xTaskGenericCreate+0x194>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
80009bea:	30 08       	mov	r8,0
80009bec:	eb 68 00 43 	st.b	r5[67],r8
80009bf0:	58 73       	cp.w	r3,7
80009bf2:	e6 07 17 80 	movls	r7,r3
80009bf6:	f9 b7 0b 07 	movhi	r7,7
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
80009bfa:	8b b7       	st.w	r5[0x2c],r7
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
80009bfc:	eb 47 00 44 	st.w	r5[68],r7
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
80009c00:	ea c4 ff fc 	sub	r4,r5,-4
80009c04:	08 9c       	mov	r12,r4
80009c06:	f0 1f 00 44 	mcall	80009d14 <xTaskGenericCreate+0x198>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
80009c0a:	ea cc ff e8 	sub	r12,r5,-24
80009c0e:	f0 1f 00 42 	mcall	80009d14 <xTaskGenericCreate+0x198>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
80009c12:	8b 45       	st.w	r5[0x10],r5

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
80009c14:	ee 07 11 08 	rsub	r7,r7,8
80009c18:	8b 67       	st.w	r5[0x18],r7
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
80009c1a:	8b 95       	st.w	r5[0x24],r5
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
80009c1c:	00 9a       	mov	r10,r0
80009c1e:	40 0b       	lddsp	r11,sp[0x0]
80009c20:	0c 9c       	mov	r12,r6
80009c22:	f0 1f 00 3e 	mcall	80009d18 <xTaskGenericCreate+0x19c>
80009c26:	8b 0c       	st.w	r5[0x0],r12
		if( ( void * ) pxCreatedTask != NULL )
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
80009c28:	58 02       	cp.w	r2,0
80009c2a:	e5 f5 1a 00 	st.wne	r2[0x0],r5
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
80009c2e:	f0 1f 00 3c 	mcall	80009d1c <xTaskGenericCreate+0x1a0>
		{
			uxCurrentNumberOfTasks++;
80009c32:	4b c8       	lddpc	r8,80009d20 <xTaskGenericCreate+0x1a4>
80009c34:	70 09       	ld.w	r9,r8[0x0]
80009c36:	2f f9       	sub	r9,-1
80009c38:	91 09       	st.w	r8[0x0],r9
			if( pxCurrentTCB == NULL )
80009c3a:	4b b8       	lddpc	r8,80009d24 <xTaskGenericCreate+0x1a8>
80009c3c:	70 08       	ld.w	r8,r8[0x0]
80009c3e:	58 08       	cp.w	r8,0
80009c40:	c2 61       	brne	80009c8c <xTaskGenericCreate+0x110>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
80009c42:	4b 98       	lddpc	r8,80009d24 <xTaskGenericCreate+0x1a8>
80009c44:	91 05       	st.w	r8[0x0],r5

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
80009c46:	4b 78       	lddpc	r8,80009d20 <xTaskGenericCreate+0x1a4>
80009c48:	70 08       	ld.w	r8,r8[0x0]
80009c4a:	58 18       	cp.w	r8,1
80009c4c:	c2 b1       	brne	80009ca2 <xTaskGenericCreate+0x126>
80009c4e:	4b 77       	lddpc	r7,80009d28 <xTaskGenericCreate+0x1ac>

/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
80009c50:	ee c6 ff 60 	sub	r6,r7,-160
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
80009c54:	0e 9c       	mov	r12,r7
80009c56:	f0 1f 00 36 	mcall	80009d2c <xTaskGenericCreate+0x1b0>
80009c5a:	2e c7       	sub	r7,-20

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
80009c5c:	0c 37       	cp.w	r7,r6
80009c5e:	cf b1       	brne	80009c54 <xTaskGenericCreate+0xd8>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
80009c60:	4b 47       	lddpc	r7,80009d30 <xTaskGenericCreate+0x1b4>
80009c62:	0e 9c       	mov	r12,r7
80009c64:	f0 1f 00 32 	mcall	80009d2c <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
80009c68:	4b 36       	lddpc	r6,80009d34 <xTaskGenericCreate+0x1b8>
80009c6a:	0c 9c       	mov	r12,r6
80009c6c:	f0 1f 00 30 	mcall	80009d2c <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xPendingReadyList );
80009c70:	4b 2c       	lddpc	r12,80009d38 <xTaskGenericCreate+0x1bc>
80009c72:	f0 1f 00 2f 	mcall	80009d2c <xTaskGenericCreate+0x1b0>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
80009c76:	4b 2c       	lddpc	r12,80009d3c <xTaskGenericCreate+0x1c0>
80009c78:	f0 1f 00 2d 	mcall	80009d2c <xTaskGenericCreate+0x1b0>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
80009c7c:	4b 1c       	lddpc	r12,80009d40 <xTaskGenericCreate+0x1c4>
80009c7e:	f0 1f 00 2c 	mcall	80009d2c <xTaskGenericCreate+0x1b0>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
80009c82:	4b 18       	lddpc	r8,80009d44 <xTaskGenericCreate+0x1c8>
80009c84:	91 07       	st.w	r8[0x0],r7
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
80009c86:	4b 18       	lddpc	r8,80009d48 <xTaskGenericCreate+0x1cc>
80009c88:	91 06       	st.w	r8[0x0],r6
80009c8a:	c0 c8       	rjmp	80009ca2 <xTaskGenericCreate+0x126>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
80009c8c:	4b 08       	lddpc	r8,80009d4c <xTaskGenericCreate+0x1d0>
80009c8e:	70 08       	ld.w	r8,r8[0x0]
80009c90:	58 08       	cp.w	r8,0
80009c92:	c0 81       	brne	80009ca2 <xTaskGenericCreate+0x126>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
80009c94:	4a 48       	lddpc	r8,80009d24 <xTaskGenericCreate+0x1a8>
80009c96:	70 08       	ld.w	r8,r8[0x0]
80009c98:	70 b8       	ld.w	r8,r8[0x2c]
80009c9a:	10 33       	cp.w	r3,r8
80009c9c:	c0 33       	brcs	80009ca2 <xTaskGenericCreate+0x126>
					{
						pxCurrentTCB = pxNewTCB;
80009c9e:	4a 28       	lddpc	r8,80009d24 <xTaskGenericCreate+0x1a8>
80009ca0:	91 05       	st.w	r8[0x0],r5
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
80009ca2:	6a b8       	ld.w	r8,r5[0x2c]
80009ca4:	4a b9       	lddpc	r9,80009d50 <xTaskGenericCreate+0x1d4>
80009ca6:	72 09       	ld.w	r9,r9[0x0]
80009ca8:	12 38       	cp.w	r8,r9
80009caa:	e0 88 00 04 	brls	80009cb2 <xTaskGenericCreate+0x136>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
80009cae:	4a 99       	lddpc	r9,80009d50 <xTaskGenericCreate+0x1d4>
80009cb0:	93 08       	st.w	r9[0x0],r8
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
80009cb2:	4a 98       	lddpc	r8,80009d54 <xTaskGenericCreate+0x1d8>
80009cb4:	70 09       	ld.w	r9,r8[0x0]
80009cb6:	2f f9       	sub	r9,-1
80009cb8:	91 09       	st.w	r8[0x0],r9

			prvAddTaskToReadyQueue( pxNewTCB );
80009cba:	6a b8       	ld.w	r8,r5[0x2c]
80009cbc:	4a 79       	lddpc	r9,80009d58 <xTaskGenericCreate+0x1dc>
80009cbe:	72 09       	ld.w	r9,r9[0x0]
80009cc0:	12 38       	cp.w	r8,r9
80009cc2:	e0 88 00 04 	brls	80009cca <xTaskGenericCreate+0x14e>
80009cc6:	4a 59       	lddpc	r9,80009d58 <xTaskGenericCreate+0x1dc>
80009cc8:	93 08       	st.w	r9[0x0],r8
80009cca:	6a bc       	ld.w	r12,r5[0x2c]
80009ccc:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80009cd0:	08 9b       	mov	r11,r4
80009cd2:	49 68       	lddpc	r8,80009d28 <xTaskGenericCreate+0x1ac>
80009cd4:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80009cd8:	f0 1f 00 21 	mcall	80009d5c <xTaskGenericCreate+0x1e0>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
80009cdc:	f0 1f 00 21 	mcall	80009d60 <xTaskGenericCreate+0x1e4>
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
80009ce0:	49 b8       	lddpc	r8,80009d4c <xTaskGenericCreate+0x1d0>
80009ce2:	70 08       	ld.w	r8,r8[0x0]
80009ce4:	58 08       	cp.w	r8,0
80009ce6:	c0 a0       	breq	80009cfa <xTaskGenericCreate+0x17e>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
80009ce8:	48 f8       	lddpc	r8,80009d24 <xTaskGenericCreate+0x1a8>
80009cea:	70 08       	ld.w	r8,r8[0x0]
80009cec:	70 b8       	ld.w	r8,r8[0x2c]
80009cee:	10 33       	cp.w	r3,r8
80009cf0:	e0 88 00 05 	brls	80009cfa <xTaskGenericCreate+0x17e>
			{
				portYIELD_WITHIN_API();
80009cf4:	d7 33       	scall
80009cf6:	30 1c       	mov	r12,1
80009cf8:	c0 28       	rjmp	80009cfc <xTaskGenericCreate+0x180>
80009cfa:	30 1c       	mov	r12,1
			}
		}
	}

	return xReturn;
}
80009cfc:	2f fd       	sub	sp,-4
80009cfe:	d8 32       	popm	r0-r7,pc
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80009d00:	99 c6       	st.w	r12[0x30],r6
80009d02:	c5 fb       	rjmp	80009bc0 <xTaskGenericCreate+0x44>
80009d04:	80 00       	ld.sh	r0,r0[0x0]
80009d06:	8f fc       	st.w	r7[0x3c],r12
80009d08:	80 00       	ld.sh	r0,r0[0x0]
80009d0a:	8f d4       	st.w	r7[0x34],r4
80009d0c:	80 00       	ld.sh	r0,r0[0x0]
80009d0e:	aa 4e       	st.h	r5[0x8],lr
80009d10:	80 00       	ld.sh	r0,r0[0x0]
80009d12:	ad a0       	sbr	r0,0xc
80009d14:	80 00       	ld.sh	r0,r0[0x0]
80009d16:	8c 80       	ld.uh	r0,r6[0x0]
80009d18:	80 00       	ld.sh	r0,r0[0x0]
80009d1a:	8c fc       	ld.uh	r12,r6[0xe]
80009d1c:	80 00       	ld.sh	r0,r0[0x0]
80009d1e:	8d 90       	st.w	r6[0x24],r0
80009d20:	00 00       	add	r0,r0
80009d22:	12 f0       	st.b	--r9,r0
80009d24:	00 00       	add	r0,r0
80009d26:	12 a4       	st.w	r9++,r4
80009d28:	00 00       	add	r0,r0
80009d2a:	11 f0       	ld.ub	r0,r8[0x7]
80009d2c:	80 00       	ld.sh	r0,r0[0x0]
80009d2e:	8c 6c       	ld.sh	r12,r6[0xc]
80009d30:	00 00       	add	r0,r0
80009d32:	12 bc       	st.h	r9++,r12
80009d34:	00 00       	add	r0,r0
80009d36:	12 d8       	st.w	--r9,r8
80009d38:	00 00       	add	r0,r0
80009d3a:	12 a8       	st.w	r9++,r8
80009d3c:	00 00       	add	r0,r0
80009d3e:	12 90       	mov	r0,r9
80009d40:	00 00       	add	r0,r0
80009d42:	12 f8       	st.b	--r9,r8
80009d44:	00 00       	add	r0,r0
80009d46:	11 dc       	ld.ub	r12,r8[0x5]
80009d48:	00 00       	add	r0,r0
80009d4a:	11 ec       	ld.ub	r12,r8[0x6]
80009d4c:	00 00       	add	r0,r0
80009d4e:	11 e0       	ld.ub	r0,r8[0x6]
80009d50:	00 00       	add	r0,r0
80009d52:	11 d8       	ld.ub	r8,r8[0x5]
80009d54:	00 00       	add	r0,r0
80009d56:	12 ec       	st.h	--r9,r12
80009d58:	00 00       	add	r0,r0
80009d5a:	13 0c       	ld.w	r12,r9++
80009d5c:	80 00       	ld.sh	r0,r0[0x0]
80009d5e:	8c 86       	ld.uh	r6,r6[0x0]
80009d60:	80 00       	ld.sh	r0,r0[0x0]
80009d62:	8e 9c       	ld.uh	r12,r7[0x2]

80009d64 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
80009d64:	d4 01       	pushm	lr
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
80009d66:	30 09       	mov	r9,0
80009d68:	1a d9       	st.w	--sp,r9
80009d6a:	1a d9       	st.w	--sp,r9
80009d6c:	1a d9       	st.w	--sp,r9
80009d6e:	12 98       	mov	r8,r9
80009d70:	e0 6a 01 00 	mov	r10,256
80009d74:	48 9b       	lddpc	r11,80009d98 <vTaskStartScheduler+0x34>
80009d76:	48 ac       	lddpc	r12,80009d9c <vTaskStartScheduler+0x38>
80009d78:	f0 1f 00 0a 	mcall	80009da0 <vTaskStartScheduler+0x3c>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
80009d7c:	2f dd       	sub	sp,-12
80009d7e:	58 1c       	cp.w	r12,1
80009d80:	c0 a1       	brne	80009d94 <vTaskStartScheduler+0x30>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
80009d82:	d3 03       	ssrf	0x10

		xSchedulerRunning = pdTRUE;
80009d84:	30 19       	mov	r9,1
80009d86:	48 88       	lddpc	r8,80009da4 <vTaskStartScheduler+0x40>
80009d88:	91 09       	st.w	r8[0x0],r9
		xTickCount = ( portTickType ) 0;
80009d8a:	30 09       	mov	r9,0
80009d8c:	48 78       	lddpc	r8,80009da8 <vTaskStartScheduler+0x44>
80009d8e:	91 09       	st.w	r8[0x0],r9
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
80009d90:	f0 1f 00 07 	mcall	80009dac <vTaskStartScheduler+0x48>
80009d94:	d8 02       	popm	pc
80009d96:	00 00       	add	r0,r0
80009d98:	80 01       	ld.sh	r1,r0[0x0]
80009d9a:	8f f0       	st.w	r7[0x3c],r0
80009d9c:	80 00       	ld.sh	r0,r0[0x0]
80009d9e:	9a f4       	ld.uh	r4,sp[0xe]
80009da0:	80 00       	ld.sh	r0,r0[0x0]
80009da2:	9b 7c       	st.w	sp[0x1c],r12
80009da4:	00 00       	add	r0,r0
80009da6:	11 e0       	ld.ub	r0,r8[0x6]
80009da8:	00 00       	add	r0,r0
80009daa:	12 d0       	st.w	--r9,r0
80009dac:	80 00       	ld.sh	r0,r0[0x0]
80009dae:	8d a0       	st.w	r6[0x28],r0

80009db0 <PrintChar>:
	
static void task_log(void * pvParameters);

char *  PrintChar(char c, char * str)
{
	*str++ = c;
80009db0:	16 cc       	st.b	r11++,r12
	return str;
}
80009db2:	5e fb       	retal	r11

80009db4 <PrintHex>:
	
	return str;
}

char * PrintHex(int i,char len, char * str)
{
80009db4:	eb cd 40 c0 	pushm	r6-r7,lr
80009db8:	20 3d       	sub	sp,12
80009dba:	18 98       	mov	r8,r12
	char * p = str;
	char s[12];
	memset(s, 0 , 12);
80009dbc:	30 06       	mov	r6,0
80009dbe:	30 07       	mov	r7,0
80009dc0:	fa e7 00 00 	st.d	sp[0],r6
80009dc4:	30 0c       	mov	r12,0
80009dc6:	50 2c       	stdsp	sp[0x8],r12
	int cnt=0;
	
	if(i)
80009dc8:	58 08       	cp.w	r8,0
80009dca:	c1 30       	breq	80009df0 <PrintHex+0x3c>
80009dcc:	18 99       	mov	r9,r12
	while(i)
	{
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
80009dce:	1a 9c       	mov	r12,sp
80009dd0:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80009dd4:	58 9e       	cp.w	lr,9
80009dd6:	e0 8a 00 04 	brle	80009dde <PrintHex+0x2a>
80009dda:	2c 9e       	sub	lr,-55
80009ddc:	c0 48       	rjmp	80009de4 <PrintHex+0x30>
80009dde:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80009de2:	2d 0e       	sub	lr,-48
80009de4:	f8 09 0b 0e 	st.b	r12[r9],lr
80009de8:	2f f9       	sub	r9,-1
		i = (i >> 4 ) & 0x0FFFFFFF;
80009dea:	a5 88       	lsr	r8,0x4
	char s[12];
	memset(s, 0 , 12);
	int cnt=0;
	
	if(i)
	while(i)
80009dec:	cf 21       	brne	80009dd0 <PrintHex+0x1c>
80009dee:	c0 48       	rjmp	80009df6 <PrintHex+0x42>
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
		i = (i >> 4 ) & 0x0FFFFFFF;
		//i >>= 4
	}
	else
	s[cnt++] = '0';
80009df0:	33 08       	mov	r8,48
80009df2:	ba 88       	st.b	sp[0x0],r8
80009df4:	30 19       	mov	r9,1
	
	if(len - cnt > 0 )
80009df6:	f6 09 01 08 	sub	r8,r11,r9
80009dfa:	58 08       	cp.w	r8,0
80009dfc:	e0 8a 00 13 	brle	80009e22 <PrintHex+0x6e>
	{
		char num = len - cnt;
80009e00:	12 1b       	sub	r11,r9
80009e02:	f9 db c0 08 	bfextu	r12,r11,0x0,0x8
		for(int i = 0; i < num; i++)
80009e06:	18 9e       	mov	lr,r12
80009e08:	58 0c       	cp.w	r12,0
80009e0a:	e0 8a 00 0c 	brle	80009e22 <PrintHex+0x6e>
80009e0e:	1a 9b       	mov	r11,sp
80009e10:	12 0b       	add	r11,r9
80009e12:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80009e14:	33 07       	mov	r7,48
80009e16:	16 c7       	st.b	r11++,r7
	s[cnt++] = '0';
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80009e18:	2f f8       	sub	r8,-1
80009e1a:	1c 38       	cp.w	r8,lr
80009e1c:	cf d5       	brlt	80009e16 <PrintHex+0x62>
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80009e1e:	f8 09 00 09 	add	r9,r12,r9
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80009e22:	f2 c8 ff ff 	sub	r8,r9,-1
	s[cnt++] = '0';
	
	while(cnt>0)
80009e26:	f0 cb ff ff 	sub	r11,r8,-1
80009e2a:	58 0b       	cp.w	r11,0
80009e2c:	e0 8a 00 19 	brle	80009e5e <PrintHex+0xaa>
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80009e30:	fa cb ff f4 	sub	r11,sp,-12
80009e34:	f6 09 00 09 	add	r9,r11,r9
80009e38:	37 8b       	mov	r11,120
80009e3a:	f3 6b ff f4 	st.b	r9[-12],r11
	s[cnt++] = '0';
80009e3e:	fa c9 ff f4 	sub	r9,sp,-12
80009e42:	10 09       	add	r9,r8
80009e44:	33 0b       	mov	r11,48
80009e46:	f3 6b ff f4 	st.b	r9[-12],r11
80009e4a:	fa 08 00 08 	add	r8,sp,r8
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80009e4e:	fa ce 00 01 	sub	lr,sp,1
80009e52:	14 99       	mov	r9,r10
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
	*p++ = s[--cnt];
80009e54:	11 8b       	ld.ub	r11,r8[0x0]
80009e56:	12 cb       	st.b	r9++,r11
80009e58:	20 18       	sub	r8,1
	}
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
80009e5a:	1c 38       	cp.w	r8,lr
80009e5c:	cf c1       	brne	80009e54 <PrintHex+0xa0>
	*p++ = s[--cnt];
		
	return str;
}
80009e5e:	14 9c       	mov	r12,r10
80009e60:	2f dd       	sub	sp,-12
80009e62:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

80009e66 <PrintDec>:
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
{
80009e66:	d4 21       	pushm	r4-r7,lr
80009e68:	20 3d       	sub	sp,12
80009e6a:	18 98       	mov	r8,r12
	char * p = str;
	
	int sign = i>=0 ? 0 : 1;
	char s[10];
	memset(s, 0 , 10);
80009e6c:	30 06       	mov	r6,0
80009e6e:	30 07       	mov	r7,0
80009e70:	fa e7 00 00 	st.d	sp[0],r6
80009e74:	30 0c       	mov	r12,0
80009e76:	ba 4c       	st.h	sp[0x8],r12
	int cnt=0;
	if(sign)
80009e78:	58 08       	cp.w	r8,0
80009e7a:	c0 35       	brlt	80009e80 <PrintDec+0x1a>
80009e7c:	14 97       	mov	r7,r10
80009e7e:	c0 58       	rjmp	80009e88 <PrintDec+0x22>
	{
		*p++ = '-';
80009e80:	14 97       	mov	r7,r10
80009e82:	32 d9       	mov	r9,45
80009e84:	0e c9       	st.b	r7++,r9
		i = -i;
80009e86:	5c 38       	neg	r8
	}
	
	if(i == 0 )s[cnt++] = '0';
80009e88:	58 08       	cp.w	r8,0
80009e8a:	c0 51       	brne	80009e94 <PrintDec+0x2e>
80009e8c:	33 08       	mov	r8,48
80009e8e:	ba 88       	st.b	sp[0x0],r8
80009e90:	30 1e       	mov	lr,1
80009e92:	c2 f8       	rjmp	80009ef0 <PrintDec+0x8a>
	
	int ten = i%10;
80009e94:	e0 65 66 67 	mov	r5,26215
80009e98:	ea 15 66 66 	orh	r5,0x6666
80009e9c:	f0 05 04 44 	muls.d	r4,r8,r5
80009ea0:	ea 0c 14 02 	asr	r12,r5,0x2
80009ea4:	f0 09 14 1f 	asr	r9,r8,0x1f
80009ea8:	f8 09 01 09 	sub	r9,r12,r9
80009eac:	f2 09 00 29 	add	r9,r9,r9<<0x2
80009eb0:	f0 09 01 19 	sub	r9,r8,r9<<0x1
80009eb4:	30 0e       	mov	lr,0
	while(i)
	{
		s[cnt] = ten+'0';
80009eb6:	1a 9c       	mov	r12,sp
		cnt++;
		i /= 10;
80009eb8:	e0 66 66 67 	mov	r6,26215
80009ebc:	ea 16 66 66 	orh	r6,0x6666
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
	{
		s[cnt] = ten+'0';
80009ec0:	2d 09       	sub	r9,-48
80009ec2:	f8 0e 0b 09 	st.b	r12[lr],r9
		cnt++;
80009ec6:	2f fe       	sub	lr,-1
		i /= 10;
80009ec8:	f0 06 04 44 	muls.d	r4,r8,r6
80009ecc:	ea 09 14 02 	asr	r9,r5,0x2
80009ed0:	bf 58       	asr	r8,0x1f
80009ed2:	f2 08 01 08 	sub	r8,r9,r8
		ten = i%10;
80009ed6:	f0 06 04 44 	muls.d	r4,r8,r6
80009eda:	ea 09 14 02 	asr	r9,r5,0x2
80009ede:	f0 05 14 1f 	asr	r5,r8,0x1f
80009ee2:	0a 19       	sub	r9,r5
80009ee4:	f2 09 00 29 	add	r9,r9,r9<<0x2
80009ee8:	f0 09 01 19 	sub	r9,r8,r9<<0x1
	}
	
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
80009eec:	58 08       	cp.w	r8,0
80009eee:	ce 91       	brne	80009ec0 <PrintDec+0x5a>
		cnt++;
		i /= 10;
		ten = i%10;
	}
	
	if(len - cnt > 0 )
80009ef0:	f6 0e 01 08 	sub	r8,r11,lr
80009ef4:	58 08       	cp.w	r8,0
80009ef6:	e0 89 00 06 	brgt	80009f02 <PrintDec+0x9c>
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80009efa:	58 0e       	cp.w	lr,0
80009efc:	e0 89 00 14 	brgt	80009f24 <PrintDec+0xbe>
80009f00:	c1 d8       	rjmp	80009f3a <PrintDec+0xd4>
		ten = i%10;
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
80009f02:	1c 1b       	sub	r11,lr
80009f04:	5c 5b       	castu.b	r11
		for(int i = 0; i < num; i++)
80009f06:	16 9c       	mov	r12,r11
80009f08:	58 0b       	cp.w	r11,0
80009f0a:	fe 9a ff f8 	brle	80009efa <PrintDec+0x94>
80009f0e:	1a 99       	mov	r9,sp
80009f10:	1c 09       	add	r9,lr
80009f12:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80009f14:	33 06       	mov	r6,48
80009f16:	12 c6       	st.b	r9++,r6
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80009f18:	2f f8       	sub	r8,-1
80009f1a:	18 38       	cp.w	r8,r12
80009f1c:	cf d5       	brlt	80009f16 <PrintDec+0xb0>
{
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
80009f1e:	f6 0e 00 0e 	add	lr,r11,lr
80009f22:	ce cb       	rjmp	80009efa <PrintDec+0x94>
80009f24:	fa c8 ff f4 	sub	r8,sp,-12
80009f28:	1c 08       	add	r8,lr
80009f2a:	20 d8       	sub	r8,13
80009f2c:	fa cb 00 01 	sub	r11,sp,1
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
	*p++ = s[--cnt];
80009f30:	11 89       	ld.ub	r9,r8[0x0]
80009f32:	0e c9       	st.b	r7++,r9
80009f34:	20 18       	sub	r8,1
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80009f36:	16 38       	cp.w	r8,r11
80009f38:	cf c1       	brne	80009f30 <PrintDec+0xca>
	*p++ = s[--cnt];
	
	return str;
}
80009f3a:	14 9c       	mov	r12,r10
80009f3c:	2f dd       	sub	sp,-12
80009f3e:	d8 22       	popm	r4-r7,pc

80009f40 <log>:
	,  NULL );
	
}

int log(char * content, ...)
{
80009f40:	d4 31       	pushm	r0-r7,lr
80009f42:	fa cd 02 08 	sub	sp,sp,520
80009f46:	18 97       	mov	r7,r12
	
	
	char logTmp[MAX_LOG_LINE_SIZE];
	memset(logTmp, '\0', MAX_LOG_LINE_SIZE);	
80009f48:	e0 6a 01 00 	mov	r10,256
80009f4c:	30 0b       	mov	r11,0
80009f4e:	fa cc fe f8 	sub	r12,sp,-264
80009f52:	f0 1f 00 4e 	mcall	8000a088 <log+0x148>
	,  tskLOG_PRIORITY
	,  NULL );
	
}

int log(char * content, ...)
80009f56:	fa c4 fd d4 	sub	r4,sp,-556
80009f5a:	30 0a       	mov	r10,0
80009f5c:	50 0a       	stdsp	sp[0x0],r10
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80009f5e:	fa c3 ff fc 	sub	r3,sp,-4
80009f62:	e0 61 01 00 	mov	r1,256
80009f66:	14 90       	mov	r0,r10
			
					if(*str == '%')
80009f68:	32 52       	mov	r2,37
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
80009f6a:	fa c6 fe f8 	sub	r6,sp,-264
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80009f6e:	02 9a       	mov	r10,r1
80009f70:	00 9b       	mov	r11,r0
80009f72:	06 9c       	mov	r12,r3
80009f74:	f0 1f 00 45 	mcall	8000a088 <log+0x148>
			
					if(*str == '%')
80009f78:	0f 88       	ld.ub	r8,r7[0x0]
80009f7a:	e4 08 18 00 	cp.b	r8,r2
80009f7e:	c5 71       	brne	8000a02c <log+0xec>
					{
						static char lench = 0;
						lench =*(str + 1);
80009f80:	ee c8 ff ff 	sub	r8,r7,-1
80009f84:	11 89       	ld.ub	r9,r8[0x0]
80009f86:	4c 2a       	lddpc	r10,8000a08c <log+0x14c>
80009f88:	b4 89       	st.b	r10[0x0],r9
						if((lench >= '0') &&  (lench <= '9'))
80009f8a:	23 09       	sub	r9,48
80009f8c:	30 9a       	mov	r10,9
80009f8e:	f4 09 18 00 	cp.b	r9,r10
80009f92:	ee 08 17 b0 	movhi	r8,r7
						{
							len = *(++str) - '0';
80009f96:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
80009f9a:	f7 b9 08 30 	subls	r9,48
80009f9e:	fb f9 8a 00 	st.wls	sp[0x0],r9
						}
						
						str++;
80009fa2:	f0 c7 ff ff 	sub	r7,r8,-1
						
						switch(*(str))
80009fa6:	0f 88       	ld.ub	r8,r7[0x0]
80009fa8:	22 58       	sub	r8,37
80009faa:	e0 48 00 53 	cp.w	r8,83
80009fae:	e0 8b 00 31 	brhi	8000a010 <log+0xd0>
80009fb2:	4b 89       	lddpc	r9,8000a090 <log+0x150>
80009fb4:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
						{
							case('i'):
							case('I'):
							case('d'):
							case('D'):
							x = va_arg(arg_ptr,int);
80009fb8:	e8 c5 ff fc 	sub	r5,r4,-4
							strTmp = PrintDec(x, len, strTmp);
80009fbc:	06 9a       	mov	r10,r3
80009fbe:	40 0b       	lddsp	r11,sp[0x0]
80009fc0:	5c 5b       	castu.b	r11
80009fc2:	68 0c       	ld.w	r12,r4[0x0]
80009fc4:	f0 1f 00 34 	mcall	8000a094 <log+0x154>
							break;
80009fc8:	c2 98       	rjmp	8000a01a <log+0xda>
							
							case('f')://
							case('F'):
							//f = va_arg(arg_ptr,int);
							//strTmp = PrintDec(x, len, strTmp);
							log("I need float.");
80009fca:	4b 4c       	lddpc	r12,8000a098 <log+0x158>
80009fcc:	f0 1f 00 34 	mcall	8000a09c <log+0x15c>
80009fd0:	08 95       	mov	r5,r4
80009fd2:	06 9c       	mov	r12,r3
							break;
80009fd4:	c2 38       	rjmp	8000a01a <log+0xda>
							
							
							case('x'):
							case('X'):
							x = va_arg(arg_ptr,int);
80009fd6:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintHex(x,len, strTmp);
80009fda:	06 9a       	mov	r10,r3
80009fdc:	40 0b       	lddsp	r11,sp[0x0]
80009fde:	5c 5b       	castu.b	r11
80009fe0:	68 0c       	ld.w	r12,r4[0x0]
80009fe2:	f0 1f 00 30 	mcall	8000a0a0 <log+0x160>
80009fe6:	06 9c       	mov	r12,r3
							break;
80009fe8:	c1 98       	rjmp	8000a01a <log+0xda>
							
							case('c'):
							case('C'):
							y = va_arg(arg_ptr,int);
80009fea:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintChar(y, strTmp);
80009fee:	06 9b       	mov	r11,r3
80009ff0:	09 bc       	ld.ub	r12,r4[0x3]
80009ff2:	f0 1f 00 2d 	mcall	8000a0a4 <log+0x164>
80009ff6:	06 9c       	mov	r12,r3
							break;
80009ff8:	c1 18       	rjmp	8000a01a <log+0xda>
							
							case('s'):
							case('S'):
							strTmp = va_arg(arg_ptr,char*);
80009ffa:	e8 c5 ff fc 	sub	r5,r4,-4
80009ffe:	68 0c       	ld.w	r12,r4[0x0]
							//PrintStr(s);
							break;
8000a000:	c0 d8       	rjmp	8000a01a <log+0xda>
							
							case('%'):
							PrintChar('%', strTmp);
8000a002:	06 9b       	mov	r11,r3
8000a004:	32 5c       	mov	r12,37
8000a006:	f0 1f 00 28 	mcall	8000a0a4 <log+0x164>
8000a00a:	08 95       	mov	r5,r4
8000a00c:	06 9c       	mov	r12,r3
							//PrintChar('%');
							break;
8000a00e:	c0 68       	rjmp	8000a01a <log+0xda>
							
							default:
							log("I need relax.");
8000a010:	4a 6c       	lddpc	r12,8000a0a8 <log+0x168>
8000a012:	f0 1f 00 23 	mcall	8000a09c <log+0x15c>
8000a016:	08 95       	mov	r5,r4
8000a018:	06 9c       	mov	r12,r3
						}
						str++;
8000a01a:	2f f7       	sub	r7,-1
						
						length = sprintf(logTmp,"%s%s",logTmp,strTmp );
8000a01c:	1a dc       	st.w	--sp,r12
8000a01e:	1a d6       	st.w	--sp,r6
8000a020:	4a 3b       	lddpc	r11,8000a0ac <log+0x16c>
8000a022:	0c 9c       	mov	r12,r6
8000a024:	f0 1f 00 23 	mcall	8000a0b0 <log+0x170>
8000a028:	2f ed       	sub	sp,-8
8000a02a:	c0 a8       	rjmp	8000a03e <log+0xfe>
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
8000a02c:	2f f7       	sub	r7,-1
8000a02e:	1a d8       	st.w	--sp,r8
8000a030:	1a d6       	st.w	--sp,r6
8000a032:	4a 1b       	lddpc	r11,8000a0b4 <log+0x174>
8000a034:	0c 9c       	mov	r12,r6
8000a036:	f0 1f 00 1f 	mcall	8000a0b0 <log+0x170>
8000a03a:	08 95       	mov	r5,r4
8000a03c:	2f ed       	sub	sp,-8
			
			
			
	}while(*str != '\0');
8000a03e:	0f 89       	ld.ub	r9,r7[0x0]
8000a040:	30 08       	mov	r8,0
8000a042:	f0 09 18 00 	cp.b	r9,r8
8000a046:	c0 30       	breq	8000a04c <log+0x10c>
8000a048:	0a 94       	mov	r4,r5
8000a04a:	c9 2b       	rjmp	80009f6e <log+0x2e>
		
		
				
	va_end(arg_ptr);
	//while(1)		
	length = sprintf(logTmp,"%s\r\n",logTmp);
8000a04c:	fa c7 fe f8 	sub	r7,sp,-264
8000a050:	1a d7       	st.w	--sp,r7
8000a052:	49 ab       	lddpc	r11,8000a0b8 <log+0x178>
8000a054:	0e 9c       	mov	r12,r7
8000a056:	f0 1f 00 17 	mcall	8000a0b0 <log+0x170>
	
	char * p = pvPortMalloc(length+1);
8000a05a:	5c 5c       	castu.b	r12
8000a05c:	f8 c6 ff ff 	sub	r6,r12,-1
8000a060:	0c 9c       	mov	r12,r6
8000a062:	f0 1f 00 17 	mcall	8000a0bc <log+0x17c>
8000a066:	54 2c       	stdsp	sp[0x108],r12
	memcpy(p, logTmp, length+1);
8000a068:	0c 9a       	mov	r10,r6
8000a06a:	0e 9b       	mov	r11,r7
8000a06c:	f0 1f 00 15 	mcall	8000a0c0 <log+0x180>
	//
	//usart_write_line(EXAMPLE_USART, logTmp);
	xQueueSend( logQueue, &p, 5);
8000a070:	30 09       	mov	r9,0
8000a072:	30 5a       	mov	r10,5
8000a074:	fa cb fe f8 	sub	r11,sp,-264
8000a078:	49 38       	lddpc	r8,8000a0c4 <log+0x184>
8000a07a:	70 0c       	ld.w	r12,r8[0x0]
8000a07c:	f0 1f 00 13 	mcall	8000a0c8 <log+0x188>
8000a080:	2f fd       	sub	sp,-4
}
8000a082:	fe 3d fd f8 	sub	sp,-520
8000a086:	d8 32       	popm	r0-r7,pc
8000a088:	80 00       	ld.sh	r0,r0[0x0]
8000a08a:	aa 4e       	st.h	r5[0x8],lr
8000a08c:	00 00       	add	r0,r0
8000a08e:	13 10       	ld.sh	r0,r9++
8000a090:	80 01       	ld.sh	r1,r0[0x0]
8000a092:	8f f8       	st.w	r7[0x3c],r8
8000a094:	80 00       	ld.sh	r0,r0[0x0]
8000a096:	9e 66       	ld.sh	r6,pc[0xc]
8000a098:	80 01       	ld.sh	r1,r0[0x0]
8000a09a:	92 a4       	ld.uh	r4,r9[0x4]
8000a09c:	80 00       	ld.sh	r0,r0[0x0]
8000a09e:	9f 40       	st.w	pc[0x10],r0
8000a0a0:	80 00       	ld.sh	r0,r0[0x0]
8000a0a2:	9d b4       	st.w	lr[0x2c],r4
8000a0a4:	80 00       	ld.sh	r0,r0[0x0]
8000a0a6:	9d b0       	st.w	lr[0x2c],r0
8000a0a8:	80 01       	ld.sh	r1,r0[0x0]
8000a0aa:	92 b4       	ld.uh	r4,r9[0x6]
8000a0ac:	80 01       	ld.sh	r1,r0[0x0]
8000a0ae:	92 c4       	ld.uh	r4,r9[0x8]
8000a0b0:	80 00       	ld.sh	r0,r0[0x0]
8000a0b2:	ad 3c       	mul	r12,r6
8000a0b4:	80 01       	ld.sh	r1,r0[0x0]
8000a0b6:	92 cc       	ld.uh	r12,r9[0x8]
8000a0b8:	80 01       	ld.sh	r1,r0[0x0]
8000a0ba:	92 d4       	ld.uh	r4,r9[0xa]
8000a0bc:	80 00       	ld.sh	r0,r0[0x0]
8000a0be:	8f fc       	st.w	r7[0x3c],r12
8000a0c0:	80 00       	ld.sh	r0,r0[0x0]
8000a0c2:	a9 06       	ld.d	r6,r4
8000a0c4:	00 00       	add	r0,r0
8000a0c6:	46 a4       	lddsp	r4,sp[0x1a8]
8000a0c8:	80 00       	ld.sh	r0,r0[0x0]
8000a0ca:	93 50       	st.w	r9[0x14],r0

8000a0cc <logFromISR>:
	
	
int logFromISR(char * content, ...)
	{
8000a0cc:	d4 31       	pushm	r0-r7,lr
8000a0ce:	fa cd 02 0c 	sub	sp,sp,524
8000a0d2:	18 97       	mov	r7,r12
		
		
		char logTmp[MAX_LOG_LINE_SIZE];
		memset(logTmp, '\0', MAX_LOG_LINE_SIZE);
8000a0d4:	e0 6a 01 00 	mov	r10,256
8000a0d8:	30 0b       	mov	r11,0
8000a0da:	fa cc fe f4 	sub	r12,sp,-268
8000a0de:	f0 1f 00 4c 	mcall	8000a20c <logFromISR+0x140>
	//usart_write_line(EXAMPLE_USART, logTmp);
	xQueueSend( logQueue, &p, 5);
}
	
	
int logFromISR(char * content, ...)
8000a0e2:	fa c4 fd d0 	sub	r4,sp,-560
8000a0e6:	30 0a       	mov	r10,0
8000a0e8:	50 0a       	stdsp	sp[0x0],r10
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
8000a0ea:	fa c3 ff fc 	sub	r3,sp,-4
8000a0ee:	e0 61 01 00 	mov	r1,256
8000a0f2:	14 90       	mov	r0,r10
			
			if(*str == '%')
8000a0f4:	32 52       	mov	r2,37
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
8000a0f6:	fa c6 fe f4 	sub	r6,sp,-268
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
8000a0fa:	02 9a       	mov	r10,r1
8000a0fc:	00 9b       	mov	r11,r0
8000a0fe:	06 9c       	mov	r12,r3
8000a100:	f0 1f 00 43 	mcall	8000a20c <logFromISR+0x140>
			
			if(*str == '%')
8000a104:	0f 88       	ld.ub	r8,r7[0x0]
8000a106:	e4 08 18 00 	cp.b	r8,r2
8000a10a:	c5 11       	brne	8000a1ac <logFromISR+0xe0>
			{
				static char lench = 0;
				lench =*(str + 1);
8000a10c:	ee c8 ff ff 	sub	r8,r7,-1
8000a110:	11 89       	ld.ub	r9,r8[0x0]
8000a112:	4c 0a       	lddpc	r10,8000a210 <logFromISR+0x144>
8000a114:	b4 89       	st.b	r10[0x0],r9
				if((lench >= '0') &&  (lench <= '9'))
8000a116:	23 09       	sub	r9,48
8000a118:	30 9a       	mov	r10,9
8000a11a:	f4 09 18 00 	cp.b	r9,r10
8000a11e:	ee 08 17 b0 	movhi	r8,r7
				{
					len = *(++str) - '0';
8000a122:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
8000a126:	f7 b9 08 30 	subls	r9,48
8000a12a:	fb f9 8a 00 	st.wls	sp[0x0],r9
				}
				
				str++;
8000a12e:	f0 c7 ff ff 	sub	r7,r8,-1
				
				switch(*(str))
8000a132:	0f 88       	ld.ub	r8,r7[0x0]
8000a134:	22 58       	sub	r8,37
8000a136:	e0 48 00 53 	cp.w	r8,83
8000a13a:	e0 8b 00 2b 	brhi	8000a190 <logFromISR+0xc4>
8000a13e:	4b 69       	lddpc	r9,8000a214 <logFromISR+0x148>
8000a140:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
				{
					case('d'):
					case('D'):
					x = va_arg(arg_ptr,int);
8000a144:	e8 c5 ff fc 	sub	r5,r4,-4
					strTmp = PrintDec(x, len, strTmp);
8000a148:	06 9a       	mov	r10,r3
8000a14a:	40 0b       	lddsp	r11,sp[0x0]
8000a14c:	5c 5b       	castu.b	r11
8000a14e:	68 0c       	ld.w	r12,r4[0x0]
8000a150:	f0 1f 00 32 	mcall	8000a218 <logFromISR+0x14c>
					break;
8000a154:	c2 38       	rjmp	8000a19a <logFromISR+0xce>
					case('x'):
					case('X'):
					x = va_arg(arg_ptr,int);
8000a156:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintHex(x,len, strTmp);
8000a15a:	06 9a       	mov	r10,r3
8000a15c:	40 0b       	lddsp	r11,sp[0x0]
8000a15e:	5c 5b       	castu.b	r11
8000a160:	68 0c       	ld.w	r12,r4[0x0]
8000a162:	f0 1f 00 2f 	mcall	8000a21c <logFromISR+0x150>
8000a166:	06 9c       	mov	r12,r3
					break;
8000a168:	c1 98       	rjmp	8000a19a <logFromISR+0xce>
					case('c'):
					case('C'):
					y = va_arg(arg_ptr,int);
8000a16a:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintChar(y, strTmp);
8000a16e:	06 9b       	mov	r11,r3
8000a170:	09 bc       	ld.ub	r12,r4[0x3]
8000a172:	f0 1f 00 2c 	mcall	8000a220 <logFromISR+0x154>
8000a176:	06 9c       	mov	r12,r3
					break;
8000a178:	c1 18       	rjmp	8000a19a <logFromISR+0xce>
					case('s'):
					case('S'):
					strTmp = va_arg(arg_ptr,char*);
8000a17a:	e8 c5 ff fc 	sub	r5,r4,-4
8000a17e:	68 0c       	ld.w	r12,r4[0x0]
					//PrintStr(s);
					break;
8000a180:	c0 d8       	rjmp	8000a19a <logFromISR+0xce>
					case('%'):
					PrintChar('%', strTmp);
8000a182:	06 9b       	mov	r11,r3
8000a184:	32 5c       	mov	r12,37
8000a186:	f0 1f 00 27 	mcall	8000a220 <logFromISR+0x154>
8000a18a:	08 95       	mov	r5,r4
8000a18c:	06 9c       	mov	r12,r3
					//PrintChar('%');
					break;
8000a18e:	c0 68       	rjmp	8000a19a <logFromISR+0xce>
					default:
					log("I need relax.");
8000a190:	4a 5c       	lddpc	r12,8000a224 <logFromISR+0x158>
8000a192:	f0 1f 00 26 	mcall	8000a228 <logFromISR+0x15c>
8000a196:	08 95       	mov	r5,r4
8000a198:	06 9c       	mov	r12,r3
				}
				str++;
8000a19a:	2f f7       	sub	r7,-1
				
				length = sprintf(logTmp,"%s%s",logTmp,strTmp );
8000a19c:	1a dc       	st.w	--sp,r12
8000a19e:	1a d6       	st.w	--sp,r6
8000a1a0:	4a 3b       	lddpc	r11,8000a22c <logFromISR+0x160>
8000a1a2:	0c 9c       	mov	r12,r6
8000a1a4:	f0 1f 00 23 	mcall	8000a230 <logFromISR+0x164>
8000a1a8:	2f ed       	sub	sp,-8
8000a1aa:	c0 a8       	rjmp	8000a1be <logFromISR+0xf2>
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
8000a1ac:	2f f7       	sub	r7,-1
8000a1ae:	1a d8       	st.w	--sp,r8
8000a1b0:	1a d6       	st.w	--sp,r6
8000a1b2:	4a 1b       	lddpc	r11,8000a234 <logFromISR+0x168>
8000a1b4:	0c 9c       	mov	r12,r6
8000a1b6:	f0 1f 00 1f 	mcall	8000a230 <logFromISR+0x164>
8000a1ba:	08 95       	mov	r5,r4
8000a1bc:	2f ed       	sub	sp,-8
			
			
			
		}while(*str != '\0');
8000a1be:	0f 89       	ld.ub	r9,r7[0x0]
8000a1c0:	30 08       	mov	r8,0
8000a1c2:	f0 09 18 00 	cp.b	r9,r8
8000a1c6:	c0 30       	breq	8000a1cc <logFromISR+0x100>
8000a1c8:	0a 94       	mov	r4,r5
8000a1ca:	c9 8b       	rjmp	8000a0fa <logFromISR+0x2e>
		
		
		
		va_end(arg_ptr);
		//while(1)
		length = sprintf(logTmp,"%s\r\n",logTmp);
8000a1cc:	fa c7 fe f4 	sub	r7,sp,-268
8000a1d0:	1a d7       	st.w	--sp,r7
8000a1d2:	49 ab       	lddpc	r11,8000a238 <logFromISR+0x16c>
8000a1d4:	0e 9c       	mov	r12,r7
8000a1d6:	f0 1f 00 17 	mcall	8000a230 <logFromISR+0x164>
		
		char * p = pvPortMalloc(length+1);
8000a1da:	5c 5c       	castu.b	r12
8000a1dc:	f8 c6 ff ff 	sub	r6,r12,-1
8000a1e0:	0c 9c       	mov	r12,r6
8000a1e2:	f0 1f 00 17 	mcall	8000a23c <logFromISR+0x170>
8000a1e6:	54 3c       	stdsp	sp[0x10c],r12
		memcpy(p, logTmp, length+1);
8000a1e8:	0c 9a       	mov	r10,r6
8000a1ea:	0e 9b       	mov	r11,r7
8000a1ec:	f0 1f 00 15 	mcall	8000a240 <logFromISR+0x174>
		//
		portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
8000a1f0:	30 09       	mov	r9,0
8000a1f2:	54 29       	stdsp	sp[0x108],r9
		
		//usart_write_line(EXAMPLE_USART, p);
		//vPortFree(p);
		xQueueSendFromISR( logQueue, &p, &xHigherPriorityTaskWoken );
8000a1f4:	fa ca fe f8 	sub	r10,sp,-264
8000a1f8:	fa cb fe f4 	sub	r11,sp,-268
8000a1fc:	49 28       	lddpc	r8,8000a244 <logFromISR+0x178>
8000a1fe:	70 0c       	ld.w	r12,r8[0x0]
8000a200:	f0 1f 00 12 	mcall	8000a248 <logFromISR+0x17c>
8000a204:	2f fd       	sub	sp,-4
		//if (xHigherPriorityTaskWoken == pdTRUE)
		//{
			////taskYIELD();
		//}
	}
8000a206:	fe 3d fd f4 	sub	sp,-524
8000a20a:	d8 32       	popm	r0-r7,pc
8000a20c:	80 00       	ld.sh	r0,r0[0x0]
8000a20e:	aa 4e       	st.h	r5[0x8],lr
8000a210:	00 00       	add	r0,r0
8000a212:	13 11       	ld.sh	r1,r9++
8000a214:	80 01       	ld.sh	r1,r0[0x0]
8000a216:	91 48       	st.w	r8[0x10],r8
8000a218:	80 00       	ld.sh	r0,r0[0x0]
8000a21a:	9e 66       	ld.sh	r6,pc[0xc]
8000a21c:	80 00       	ld.sh	r0,r0[0x0]
8000a21e:	9d b4       	st.w	lr[0x2c],r4
8000a220:	80 00       	ld.sh	r0,r0[0x0]
8000a222:	9d b0       	st.w	lr[0x2c],r0
8000a224:	80 01       	ld.sh	r1,r0[0x0]
8000a226:	92 b4       	ld.uh	r4,r9[0x6]
8000a228:	80 00       	ld.sh	r0,r0[0x0]
8000a22a:	9f 40       	st.w	pc[0x10],r0
8000a22c:	80 01       	ld.sh	r1,r0[0x0]
8000a22e:	92 c4       	ld.uh	r4,r9[0x8]
8000a230:	80 00       	ld.sh	r0,r0[0x0]
8000a232:	ad 3c       	mul	r12,r6
8000a234:	80 01       	ld.sh	r1,r0[0x0]
8000a236:	92 cc       	ld.uh	r12,r9[0x8]
8000a238:	80 01       	ld.sh	r1,r0[0x0]
8000a23a:	92 d4       	ld.uh	r4,r9[0xa]
8000a23c:	80 00       	ld.sh	r0,r0[0x0]
8000a23e:	8f fc       	st.w	r7[0x3c],r12
8000a240:	80 00       	ld.sh	r0,r0[0x0]
8000a242:	a9 06       	ld.d	r6,r4
8000a244:	00 00       	add	r0,r0
8000a246:	46 a4       	lddsp	r4,sp[0x1a8]
8000a248:	80 00       	ld.sh	r0,r0[0x0]
8000a24a:	93 00       	st.w	r9[0x0],r0

8000a24c <log_init>:
		
	return str;
}

void log_init(void)
{
8000a24c:	d4 01       	pushm	lr
		.stopbits     = USART_1_STOPBIT,
		.channelmode  = USART_NORMAL_CHMODE
	};

	// Assign GPIO to USART.
	gpio_enable_module(USART_GPIO_MAP,
8000a24e:	30 2b       	mov	r11,2
8000a250:	49 0c       	lddpc	r12,8000a290 <log_init+0x44>
8000a252:	f0 1f 00 11 	mcall	8000a294 <log_init+0x48>
	sizeof(USART_GPIO_MAP) / sizeof(USART_GPIO_MAP[0]));

	// Initialize USART in RS232 mode.
	usart_init_rs232(EXAMPLE_USART, &USART_OPTIONS, EXAMPLE_TARGET_PBACLK_FREQ_HZ);			
8000a256:	e0 6a 36 00 	mov	r10,13824
8000a25a:	ea 1a 01 6e 	orh	r10,0x16e
8000a25e:	48 fb       	lddpc	r11,8000a298 <log_init+0x4c>
8000a260:	fe 7c 18 00 	mov	r12,-59392
8000a264:	f0 1f 00 0e 	mcall	8000a29c <log_init+0x50>
			
	logQueue  = xQueueCreate(50, sizeof(char *));
8000a268:	30 4b       	mov	r11,4
8000a26a:	33 2c       	mov	r12,50
8000a26c:	f0 1f 00 0d 	mcall	8000a2a0 <log_init+0x54>
8000a270:	48 d8       	lddpc	r8,8000a2a4 <log_init+0x58>
8000a272:	91 0c       	st.w	r8[0x0],r12
	
	xTaskCreate(
8000a274:	30 09       	mov	r9,0
8000a276:	1a d9       	st.w	--sp,r9
8000a278:	1a d9       	st.w	--sp,r9
8000a27a:	1a d9       	st.w	--sp,r9
8000a27c:	30 28       	mov	r8,2
8000a27e:	e0 6a 01 80 	mov	r10,384
8000a282:	48 ab       	lddpc	r11,8000a2a8 <log_init+0x5c>
8000a284:	48 ac       	lddpc	r12,8000a2ac <log_init+0x60>
8000a286:	f0 1f 00 0b 	mcall	8000a2b0 <log_init+0x64>
8000a28a:	2f dd       	sub	sp,-12
	,  384
	,  NULL
	,  tskLOG_PRIORITY
	,  NULL );
	
}
8000a28c:	d8 02       	popm	pc
8000a28e:	00 00       	add	r0,r0
8000a290:	80 01       	ld.sh	r1,r0[0x0]
8000a292:	92 e0       	ld.uh	r0,r9[0xc]
8000a294:	80 00       	ld.sh	r0,r0[0x0]
8000a296:	a3 e0       	*unknown*
8000a298:	80 01       	ld.sh	r1,r0[0x0]
8000a29a:	92 98       	ld.uh	r8,r9[0x2]
8000a29c:	80 00       	ld.sh	r0,r0[0x0]
8000a29e:	64 2c       	ld.w	r12,r2[0x8]
8000a2a0:	80 00       	ld.sh	r0,r0[0x0]
8000a2a2:	94 a8       	ld.uh	r8,r10[0x4]
8000a2a4:	00 00       	add	r0,r0
8000a2a6:	46 a4       	lddsp	r4,sp[0x1a8]
8000a2a8:	80 01       	ld.sh	r1,r0[0x0]
8000a2aa:	92 dc       	ld.uh	r12,r9[0xa]
8000a2ac:	80 00       	ld.sh	r0,r0[0x0]
8000a2ae:	a2 b4       	st.b	r1[0x3],r4
8000a2b0:	80 00       	ld.sh	r0,r0[0x0]
8000a2b2:	9b 7c       	st.w	sp[0x1c],r12

8000a2b4 <task_log>:
			////taskYIELD();
		//}
	}
	
static void task_log(void * pvParameters)
{
8000a2b4:	eb cd 40 f8 	pushm	r3-r7,lr
8000a2b8:	20 1d       	sub	sp,4
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
8000a2ba:	48 c7       	lddpc	r7,8000a2e8 <task_log+0x34>
8000a2bc:	30 05       	mov	r5,0
8000a2be:	3f f4       	mov	r4,-1
		{
			if( NULL != str)
			{
				usart_write_line(EXAMPLE_USART, str);
8000a2c0:	fe 73 18 00 	mov	r3,-59392
{
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
8000a2c4:	0a 99       	mov	r9,r5
8000a2c6:	08 9a       	mov	r10,r4
8000a2c8:	1a 9b       	mov	r11,sp
8000a2ca:	6e 0c       	ld.w	r12,r7[0x0]
8000a2cc:	f0 1f 00 08 	mcall	8000a2ec <task_log+0x38>
8000a2d0:	58 1c       	cp.w	r12,1
8000a2d2:	cf 91       	brne	8000a2c4 <task_log+0x10>
		{
			if( NULL != str)
8000a2d4:	40 0b       	lddsp	r11,sp[0x0]
8000a2d6:	58 0b       	cp.w	r11,0
8000a2d8:	cf 60       	breq	8000a2c4 <task_log+0x10>
			{
				usart_write_line(EXAMPLE_USART, str);
8000a2da:	06 9c       	mov	r12,r3
8000a2dc:	f0 1f 00 05 	mcall	8000a2f0 <task_log+0x3c>
				vPortFree(str);
8000a2e0:	40 0c       	lddsp	r12,sp[0x0]
8000a2e2:	f0 1f 00 05 	mcall	8000a2f4 <task_log+0x40>
8000a2e6:	ce fb       	rjmp	8000a2c4 <task_log+0x10>
8000a2e8:	00 00       	add	r0,r0
8000a2ea:	46 a4       	lddsp	r4,sp[0x1a8]
8000a2ec:	80 00       	ld.sh	r0,r0[0x0]
8000a2ee:	91 44       	st.w	r8[0x10],r4
8000a2f0:	80 00       	ld.sh	r0,r0[0x0]
8000a2f2:	63 dc       	ld.w	r12,r1[0x74]
8000a2f4:	80 00       	ld.sh	r0,r0[0x0]
8000a2f6:	8f d4       	st.w	r7[0x34],r4

8000a2f8 <main>:

#include "fs/fs.h"
#include "rtc/rtc.h"

int main(void)
{
8000a2f8:	d4 01       	pushm	lr
	//Force SSC_TX_DATA_ENABLE Disabled as soon as possible.
	AVR32_GPIO.port[1].ovrs  =  0x00000001;  //Value will be high.
8000a2fa:	fe 78 10 00 	mov	r8,-61440
8000a2fe:	30 19       	mov	r9,1
8000a300:	f1 49 01 54 	st.w	r8[340],r9
	AVR32_GPIO.port[1].oders =  0x00000001;  //Output Driver will be Enabled.
8000a304:	f1 49 01 44 	st.w	r8[324],r9
	AVR32_GPIO.port[1].gpers =  0x00000001;  //Enable as GPIO.
8000a308:	f1 49 01 04 	st.w	r8[260],r9
	
	Disable_global_interrupt();
8000a30c:	d3 03       	ssrf	0x10
	local_start_pll0();
8000a30e:	f0 1f 00 14 	mcall	8000a35c <main+0x64>
		
	INTC_init_interrupts();
8000a312:	f0 1f 00 14 	mcall	8000a360 <main+0x68>
	
	log_init();		
8000a316:	f0 1f 00 14 	mcall	8000a364 <main+0x6c>
	log("----start debug----");	
8000a31a:	49 4c       	lddpc	r12,8000a368 <main+0x70>
8000a31c:	f0 1f 00 14 	mcall	8000a36c <main+0x74>
		
	rtc_init();
8000a320:	f0 1f 00 14 	mcall	8000a370 <main+0x78>
	
	fs_init();//65795
8000a324:	f0 1f 00 14 	mcall	8000a374 <main+0x7c>

	tc_init();	
8000a328:	f0 1f 00 14 	mcall	8000a378 <main+0x80>
			
	xcmp_init();
8000a32c:	f0 1f 00 14 	mcall	8000a37c <main+0x84>
	
	app_init();
8000a330:	f0 1f 00 14 	mcall	8000a380 <main+0x88>
		
	while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
8000a334:	fe 79 10 00 	mov	r9,-61440
8000a338:	f2 f8 01 60 	ld.w	r8,r9[352]
8000a33c:	e2 18 00 02 	andl	r8,0x2,COH
8000a340:	cf c0       	breq	8000a338 <main+0x40>
	while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
8000a342:	fe 79 10 00 	mov	r9,-61440
8000a346:	f2 f8 01 60 	ld.w	r8,r9[352]
8000a34a:	e2 18 00 02 	andl	r8,0x2,COH
8000a34e:	cf c1       	brne	8000a346 <main+0x4e>
	local_start_timer();
8000a350:	f0 1f 00 0d 	mcall	8000a384 <main+0x8c>
	
	Enable_global_interrupt();
8000a354:	d5 03       	csrf	0x10
	
	vTaskStartScheduler();		
8000a356:	f0 1f 00 0d 	mcall	8000a388 <main+0x90>
	return 0;
}
8000a35a:	d8 0a       	popm	pc,r12=0
8000a35c:	80 00       	ld.sh	r0,r0[0x0]
8000a35e:	59 a4       	cp.w	r4,26
8000a360:	80 00       	ld.sh	r0,r0[0x0]
8000a362:	5d 3c       	musfr	r12
8000a364:	80 00       	ld.sh	r0,r0[0x0]
8000a366:	a2 4c       	st.h	r1[0x8],r12
8000a368:	80 01       	ld.sh	r1,r0[0x0]
8000a36a:	92 f0       	ld.uh	r0,r9[0xe]
8000a36c:	80 00       	ld.sh	r0,r0[0x0]
8000a36e:	9f 40       	st.w	pc[0x10],r0
8000a370:	80 00       	ld.sh	r0,r0[0x0]
8000a372:	5b 70       	cp.w	r0,-9
8000a374:	80 00       	ld.sh	r0,r0[0x0]
8000a376:	3b 78       	mov	r8,-73
8000a378:	80 00       	ld.sh	r0,r0[0x0]
8000a37a:	5c 38       	neg	r8
8000a37c:	80 00       	ld.sh	r0,r0[0x0]
8000a37e:	52 a8       	stdsp	sp[0xa8],r8
8000a380:	80 00       	ld.sh	r0,r0[0x0]
8000a382:	20 48       	sub	r8,4
8000a384:	80 00       	ld.sh	r0,r0[0x0]
8000a386:	5b fc       	cp.w	r12,-1
8000a388:	80 00       	ld.sh	r0,r0[0x0]
8000a38a:	9d 64       	st.w	lr[0x18],r4

8000a38c <gpio_enable_module_pin>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
8000a38c:	f8 08 16 05 	lsr	r8,r12,0x5
8000a390:	a9 68       	lsl	r8,0x8
8000a392:	e0 28 f0 00 	sub	r8,61440

	/* Enable the correct function. */
	switch (function) {
8000a396:	58 1b       	cp.w	r11,1
8000a398:	c0 d0       	breq	8000a3b2 <gpio_enable_module_pin+0x26>
8000a39a:	c0 63       	brcs	8000a3a6 <gpio_enable_module_pin+0x1a>
8000a39c:	58 2b       	cp.w	r11,2
8000a39e:	c1 00       	breq	8000a3be <gpio_enable_module_pin+0x32>
8000a3a0:	58 3b       	cp.w	r11,3
8000a3a2:	c1 40       	breq	8000a3ca <gpio_enable_module_pin+0x3e>
8000a3a4:	5e ff       	retal	1
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
8000a3a6:	30 19       	mov	r9,1
8000a3a8:	f2 0c 09 49 	lsl	r9,r9,r12
8000a3ac:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
8000a3ae:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
8000a3b0:	c1 28       	rjmp	8000a3d4 <gpio_enable_module_pin+0x48>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
8000a3b2:	30 19       	mov	r9,1
8000a3b4:	f2 0c 09 49 	lsl	r9,r9,r12
8000a3b8:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
8000a3ba:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
8000a3bc:	c0 c8       	rjmp	8000a3d4 <gpio_enable_module_pin+0x48>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
8000a3be:	30 19       	mov	r9,1
8000a3c0:	f2 0c 09 49 	lsl	r9,r9,r12
8000a3c4:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
8000a3c6:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
8000a3c8:	c0 68       	rjmp	8000a3d4 <gpio_enable_module_pin+0x48>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
8000a3ca:	30 19       	mov	r9,1
8000a3cc:	f2 0c 09 49 	lsl	r9,r9,r12
8000a3d0:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
8000a3d2:	91 99       	st.w	r8[0x24],r9
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
8000a3d4:	30 19       	mov	r9,1
8000a3d6:	f2 0c 09 4c 	lsl	r12,r9,r12
8000a3da:	91 2c       	st.w	r8[0x8],r12
8000a3dc:	5e fd       	retal	0
8000a3de:	d7 03       	nop

8000a3e0 <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
8000a3e0:	d4 21       	pushm	r4-r7,lr
8000a3e2:	18 97       	mov	r7,r12
8000a3e4:	16 94       	mov	r4,r11
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
8000a3e6:	58 0b       	cp.w	r11,0
8000a3e8:	c0 31       	brne	8000a3ee <gpio_enable_module+0xe>
8000a3ea:	30 05       	mov	r5,0
8000a3ec:	c0 d8       	rjmp	8000a406 <gpio_enable_module+0x26>
8000a3ee:	30 06       	mov	r6,0
8000a3f0:	0c 95       	mov	r5,r6
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
8000a3f2:	6e 1b       	ld.w	r11,r7[0x4]
8000a3f4:	6e 0c       	ld.w	r12,r7[0x0]
8000a3f6:	f0 1f 00 06 	mcall	8000a40c <gpio_enable_module+0x2c>
8000a3fa:	18 45       	or	r5,r12
		gpiomap++;
8000a3fc:	2f 87       	sub	r7,-8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
8000a3fe:	2f f6       	sub	r6,-1
8000a400:	0c 34       	cp.w	r4,r6
8000a402:	fe 9b ff f8 	brhi	8000a3f2 <gpio_enable_module+0x12>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
}
8000a406:	0a 9c       	mov	r12,r5
8000a408:	d8 22       	popm	r4-r7,pc
8000a40a:	00 00       	add	r0,r0
8000a40c:	80 00       	ld.sh	r0,r0[0x0]
8000a40e:	a3 8c       	lsr	r12,0x2

8000a410 <gpio_set_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_set_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
8000a410:	f8 08 16 05 	lsr	r8,r12,0x5
8000a414:	a9 68       	lsl	r8,0x8
8000a416:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 1. */
	gpio_port->ovrs  = 1 << (pin & 0x1F);																				
8000a41a:	30 19       	mov	r9,1
8000a41c:	f2 0c 09 4c 	lsl	r12,r9,r12
8000a420:	f1 4c 00 54 	st.w	r8[84],r12
	/* The GPIO output driver is enabled for that pin. */ 
	gpio_port->oders = 1 << (pin & 0x1F);
8000a424:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
8000a428:	91 1c       	st.w	r8[0x4],r12
}
8000a42a:	5e fc       	retal	r12

8000a42c <gpio_clr_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_clr_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
8000a42c:	f8 08 16 05 	lsr	r8,r12,0x5
8000a430:	a9 68       	lsl	r8,0x8
8000a432:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 0. */
	gpio_port->ovrc  = 1 << (pin & 0x1F);
8000a436:	30 19       	mov	r9,1
8000a438:	f2 0c 09 4c 	lsl	r12,r9,r12
8000a43c:	f1 4c 00 58 	st.w	r8[88],r12
	/* The GPIO output driver is enabled for that pin. */
	gpio_port->oders = 1 << (pin & 0x1F);
8000a440:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
8000a444:	91 1c       	st.w	r8[0x4],r12
}
8000a446:	5e fc       	retal	r12

8000a448 <_stext>:

  .global _stext
  .type _stext, @function
_stext:
  // Set initial stack pointer.
  lda.w   sp, _estack
8000a448:	e0 7d 80 00 	mov	sp,98304

  // Set up EVBA so interrupts can be enabled.
  lda.w   r0, _evba
  mtsr    AVR32_EVBA, r0
8000a44c:	fe c0 a4 4c 	sub	r0,pc,-23476

  // Enable the exception processing.
  csrf    AVR32_SR_EM_OFFSET
8000a450:	e3 b0 00 01 	mtsr	0x4,r0

  // Load initialized data having a global lifetime from the data LMA.
  lda.w   r0, _data
  lda.w   r1, _edata
8000a454:	d5 53       	csrf	0x15
  cp      r0, r1
8000a456:	30 80       	mov	r0,8
  brhs    idata_load_loop_end
8000a458:	e0 61 0a 40 	mov	r1,2624
  lda.w   r2, _data_lma
idata_load_loop:
  ld.d    r4, r2++
8000a45c:	02 30       	cp.w	r0,r1
  st.d    r0++, r4
8000a45e:	c0 62       	brcc	8000a46a <idata_load_loop_end>
  cp      r0, r1
8000a460:	48 92       	lddpc	r2,8000a484 <udata_clear_loop_end+0x4>

8000a462 <idata_load_loop>:
  brlo    idata_load_loop
8000a462:	a5 05       	ld.d	r4,r2++
idata_load_loop_end:

  // Clear uninitialized data having a global lifetime in the blank static storage section.
  lda.w   r0, __bss_start
8000a464:	a1 24       	st.d	r0++,r4
  lda.w   r1, _end
8000a466:	02 30       	cp.w	r0,r1
  cp      r0, r1
8000a468:	cf d3       	brcs	8000a462 <idata_load_loop>

8000a46a <idata_load_loop_end>:
  brhs    udata_clear_loop_end
8000a46a:	e0 60 0a 40 	mov	r0,2624
  mov     r2, 0
  mov     r3, 0
8000a46e:	e0 61 46 b0 	mov	r1,18096
udata_clear_loop:
  st.d    r0++, r2
  cp      r0, r1
8000a472:	02 30       	cp.w	r0,r1
  brlo    udata_clear_loop
8000a474:	c0 62       	brcc	8000a480 <udata_clear_loop_end>
  // Safety: Set the default "return" @ to the exit routine address.
  lda.w   lr, exit
#endif

  // Start the show.
  lda.w   pc, main
8000a476:	30 02       	mov	r2,0
8000a478:	30 03       	mov	r3,0

8000a47a <udata_clear_loop>:
8000a47a:	a1 22       	st.d	r0++,r2
8000a47c:	02 30       	cp.w	r0,r1
8000a47e:	cf e3       	brcs	8000a47a <udata_clear_loop>

8000a480 <udata_clear_loop_end>:
8000a480:	fe cf 01 88 	sub	pc,pc,392
8000a484:	80 01       	ld.sh	r1,r0[0x0]
8000a486:	98 88       	ld.uh	r8,r12[0x0]

8000a488 <free>:
8000a488:	d4 01       	pushm	lr
8000a48a:	e0 68 0a 38 	mov	r8,2616
8000a48e:	18 9b       	mov	r11,r12
8000a490:	70 0c       	ld.w	r12,r8[0x0]
8000a492:	e0 a0 1f 19 	rcall	8000e2c4 <_free_r>
8000a496:	d8 02       	popm	pc

8000a498 <malloc>:
8000a498:	d4 01       	pushm	lr
8000a49a:	e0 68 0a 38 	mov	r8,2616
8000a49e:	18 9b       	mov	r11,r12
8000a4a0:	70 0c       	ld.w	r12,r8[0x0]
8000a4a2:	c0 3c       	rcall	8000a4a8 <_malloc_r>
8000a4a4:	d8 02       	popm	pc
8000a4a6:	d7 03       	nop

8000a4a8 <_malloc_r>:
8000a4a8:	d4 31       	pushm	r0-r7,lr
8000a4aa:	f6 c8 ff f5 	sub	r8,r11,-11
8000a4ae:	18 95       	mov	r5,r12
8000a4b0:	10 97       	mov	r7,r8
8000a4b2:	e0 17 ff f8 	andl	r7,0xfff8
8000a4b6:	59 68       	cp.w	r8,22
8000a4b8:	f9 b7 08 10 	movls	r7,16
8000a4bc:	16 37       	cp.w	r7,r11
8000a4be:	5f 38       	srlo	r8
8000a4c0:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
8000a4c4:	c0 50       	breq	8000a4ce <_malloc_r+0x26>
8000a4c6:	30 c8       	mov	r8,12
8000a4c8:	99 38       	st.w	r12[0xc],r8
8000a4ca:	e0 8f 01 fa 	bral	8000a8be <_malloc_r+0x416>
8000a4ce:	fe b0 f5 39 	rcall	80008f40 <__malloc_lock>
8000a4d2:	e0 47 01 f7 	cp.w	r7,503
8000a4d6:	e0 8b 00 1d 	brhi	8000a510 <_malloc_r+0x68>
8000a4da:	ee 03 16 03 	lsr	r3,r7,0x3
8000a4de:	e0 68 05 38 	mov	r8,1336
8000a4e2:	f0 03 00 38 	add	r8,r8,r3<<0x3
8000a4e6:	70 36       	ld.w	r6,r8[0xc]
8000a4e8:	10 36       	cp.w	r6,r8
8000a4ea:	c0 61       	brne	8000a4f6 <_malloc_r+0x4e>
8000a4ec:	ec c8 ff f8 	sub	r8,r6,-8
8000a4f0:	70 36       	ld.w	r6,r8[0xc]
8000a4f2:	10 36       	cp.w	r6,r8
8000a4f4:	c0 c0       	breq	8000a50c <_malloc_r+0x64>
8000a4f6:	6c 18       	ld.w	r8,r6[0x4]
8000a4f8:	e0 18 ff fc 	andl	r8,0xfffc
8000a4fc:	6c 3a       	ld.w	r10,r6[0xc]
8000a4fe:	ec 08 00 09 	add	r9,r6,r8
8000a502:	0a 9c       	mov	r12,r5
8000a504:	6c 28       	ld.w	r8,r6[0x8]
8000a506:	95 28       	st.w	r10[0x8],r8
8000a508:	91 3a       	st.w	r8[0xc],r10
8000a50a:	c4 78       	rjmp	8000a598 <_malloc_r+0xf0>
8000a50c:	2f e3       	sub	r3,-2
8000a50e:	c4 d8       	rjmp	8000a5a8 <_malloc_r+0x100>
8000a510:	ee 03 16 09 	lsr	r3,r7,0x9
8000a514:	c0 41       	brne	8000a51c <_malloc_r+0x74>
8000a516:	ee 03 16 03 	lsr	r3,r7,0x3
8000a51a:	c2 68       	rjmp	8000a566 <_malloc_r+0xbe>
8000a51c:	58 43       	cp.w	r3,4
8000a51e:	e0 8b 00 06 	brhi	8000a52a <_malloc_r+0x82>
8000a522:	ee 03 16 06 	lsr	r3,r7,0x6
8000a526:	2c 83       	sub	r3,-56
8000a528:	c1 f8       	rjmp	8000a566 <_malloc_r+0xbe>
8000a52a:	59 43       	cp.w	r3,20
8000a52c:	e0 8b 00 04 	brhi	8000a534 <_malloc_r+0x8c>
8000a530:	2a 53       	sub	r3,-91
8000a532:	c1 a8       	rjmp	8000a566 <_malloc_r+0xbe>
8000a534:	e0 43 00 54 	cp.w	r3,84
8000a538:	e0 8b 00 06 	brhi	8000a544 <_malloc_r+0x9c>
8000a53c:	ee 03 16 0c 	lsr	r3,r7,0xc
8000a540:	29 23       	sub	r3,-110
8000a542:	c1 28       	rjmp	8000a566 <_malloc_r+0xbe>
8000a544:	e0 43 01 54 	cp.w	r3,340
8000a548:	e0 8b 00 06 	brhi	8000a554 <_malloc_r+0xac>
8000a54c:	ee 03 16 0f 	lsr	r3,r7,0xf
8000a550:	28 93       	sub	r3,-119
8000a552:	c0 a8       	rjmp	8000a566 <_malloc_r+0xbe>
8000a554:	e0 43 05 54 	cp.w	r3,1364
8000a558:	e0 88 00 04 	brls	8000a560 <_malloc_r+0xb8>
8000a55c:	37 e3       	mov	r3,126
8000a55e:	c0 48       	rjmp	8000a566 <_malloc_r+0xbe>
8000a560:	ee 03 16 12 	lsr	r3,r7,0x12
8000a564:	28 43       	sub	r3,-124
8000a566:	e0 6a 05 38 	mov	r10,1336
8000a56a:	f4 03 00 3a 	add	r10,r10,r3<<0x3
8000a56e:	74 36       	ld.w	r6,r10[0xc]
8000a570:	c1 98       	rjmp	8000a5a2 <_malloc_r+0xfa>
8000a572:	6c 19       	ld.w	r9,r6[0x4]
8000a574:	e0 19 ff fc 	andl	r9,0xfffc
8000a578:	f2 07 01 0b 	sub	r11,r9,r7
8000a57c:	58 fb       	cp.w	r11,15
8000a57e:	e0 8a 00 04 	brle	8000a586 <_malloc_r+0xde>
8000a582:	20 13       	sub	r3,1
8000a584:	c1 18       	rjmp	8000a5a6 <_malloc_r+0xfe>
8000a586:	6c 38       	ld.w	r8,r6[0xc]
8000a588:	58 0b       	cp.w	r11,0
8000a58a:	c0 b5       	brlt	8000a5a0 <_malloc_r+0xf8>
8000a58c:	6c 2a       	ld.w	r10,r6[0x8]
8000a58e:	ec 09 00 09 	add	r9,r6,r9
8000a592:	0a 9c       	mov	r12,r5
8000a594:	91 2a       	st.w	r8[0x8],r10
8000a596:	95 38       	st.w	r10[0xc],r8
8000a598:	72 18       	ld.w	r8,r9[0x4]
8000a59a:	a1 a8       	sbr	r8,0x0
8000a59c:	93 18       	st.w	r9[0x4],r8
8000a59e:	cb c8       	rjmp	8000a716 <_malloc_r+0x26e>
8000a5a0:	10 96       	mov	r6,r8
8000a5a2:	14 36       	cp.w	r6,r10
8000a5a4:	ce 71       	brne	8000a572 <_malloc_r+0xca>
8000a5a6:	2f f3       	sub	r3,-1
8000a5a8:	e0 6a 05 38 	mov	r10,1336
8000a5ac:	f4 cc ff f8 	sub	r12,r10,-8
8000a5b0:	78 26       	ld.w	r6,r12[0x8]
8000a5b2:	18 36       	cp.w	r6,r12
8000a5b4:	c6 c0       	breq	8000a68c <_malloc_r+0x1e4>
8000a5b6:	6c 19       	ld.w	r9,r6[0x4]
8000a5b8:	e0 19 ff fc 	andl	r9,0xfffc
8000a5bc:	f2 07 01 08 	sub	r8,r9,r7
8000a5c0:	58 f8       	cp.w	r8,15
8000a5c2:	e0 89 00 8f 	brgt	8000a6e0 <_malloc_r+0x238>
8000a5c6:	99 3c       	st.w	r12[0xc],r12
8000a5c8:	99 2c       	st.w	r12[0x8],r12
8000a5ca:	58 08       	cp.w	r8,0
8000a5cc:	c0 55       	brlt	8000a5d6 <_malloc_r+0x12e>
8000a5ce:	ec 09 00 09 	add	r9,r6,r9
8000a5d2:	0a 9c       	mov	r12,r5
8000a5d4:	ce 2b       	rjmp	8000a598 <_malloc_r+0xf0>
8000a5d6:	e0 49 01 ff 	cp.w	r9,511
8000a5da:	e0 8b 00 13 	brhi	8000a600 <_malloc_r+0x158>
8000a5de:	a3 99       	lsr	r9,0x3
8000a5e0:	f4 09 00 38 	add	r8,r10,r9<<0x3
8000a5e4:	70 2b       	ld.w	r11,r8[0x8]
8000a5e6:	8d 38       	st.w	r6[0xc],r8
8000a5e8:	8d 2b       	st.w	r6[0x8],r11
8000a5ea:	97 36       	st.w	r11[0xc],r6
8000a5ec:	91 26       	st.w	r8[0x8],r6
8000a5ee:	a3 49       	asr	r9,0x2
8000a5f0:	74 18       	ld.w	r8,r10[0x4]
8000a5f2:	30 1b       	mov	r11,1
8000a5f4:	f6 09 09 49 	lsl	r9,r11,r9
8000a5f8:	f1 e9 10 09 	or	r9,r8,r9
8000a5fc:	95 19       	st.w	r10[0x4],r9
8000a5fe:	c4 78       	rjmp	8000a68c <_malloc_r+0x1e4>
8000a600:	f2 0a 16 09 	lsr	r10,r9,0x9
8000a604:	58 4a       	cp.w	r10,4
8000a606:	e0 8b 00 07 	brhi	8000a614 <_malloc_r+0x16c>
8000a60a:	f2 0a 16 06 	lsr	r10,r9,0x6
8000a60e:	2c 8a       	sub	r10,-56
8000a610:	c2 08       	rjmp	8000a650 <_malloc_r+0x1a8>
8000a612:	d7 03       	nop
8000a614:	59 4a       	cp.w	r10,20
8000a616:	e0 8b 00 04 	brhi	8000a61e <_malloc_r+0x176>
8000a61a:	2a 5a       	sub	r10,-91
8000a61c:	c1 a8       	rjmp	8000a650 <_malloc_r+0x1a8>
8000a61e:	e0 4a 00 54 	cp.w	r10,84
8000a622:	e0 8b 00 06 	brhi	8000a62e <_malloc_r+0x186>
8000a626:	f2 0a 16 0c 	lsr	r10,r9,0xc
8000a62a:	29 2a       	sub	r10,-110
8000a62c:	c1 28       	rjmp	8000a650 <_malloc_r+0x1a8>
8000a62e:	e0 4a 01 54 	cp.w	r10,340
8000a632:	e0 8b 00 06 	brhi	8000a63e <_malloc_r+0x196>
8000a636:	f2 0a 16 0f 	lsr	r10,r9,0xf
8000a63a:	28 9a       	sub	r10,-119
8000a63c:	c0 a8       	rjmp	8000a650 <_malloc_r+0x1a8>
8000a63e:	e0 4a 05 54 	cp.w	r10,1364
8000a642:	e0 88 00 04 	brls	8000a64a <_malloc_r+0x1a2>
8000a646:	37 ea       	mov	r10,126
8000a648:	c0 48       	rjmp	8000a650 <_malloc_r+0x1a8>
8000a64a:	f2 0a 16 12 	lsr	r10,r9,0x12
8000a64e:	28 4a       	sub	r10,-124
8000a650:	e0 6b 05 38 	mov	r11,1336
8000a654:	f6 0a 00 34 	add	r4,r11,r10<<0x3
8000a658:	68 28       	ld.w	r8,r4[0x8]
8000a65a:	08 38       	cp.w	r8,r4
8000a65c:	c0 e1       	brne	8000a678 <_malloc_r+0x1d0>
8000a65e:	76 19       	ld.w	r9,r11[0x4]
8000a660:	a3 4a       	asr	r10,0x2
8000a662:	30 1e       	mov	lr,1
8000a664:	fc 0a 09 4a 	lsl	r10,lr,r10
8000a668:	f3 ea 10 0a 	or	r10,r9,r10
8000a66c:	10 99       	mov	r9,r8
8000a66e:	97 1a       	st.w	r11[0x4],r10
8000a670:	c0 a8       	rjmp	8000a684 <_malloc_r+0x1dc>
8000a672:	70 28       	ld.w	r8,r8[0x8]
8000a674:	08 38       	cp.w	r8,r4
8000a676:	c0 60       	breq	8000a682 <_malloc_r+0x1da>
8000a678:	70 1a       	ld.w	r10,r8[0x4]
8000a67a:	e0 1a ff fc 	andl	r10,0xfffc
8000a67e:	14 39       	cp.w	r9,r10
8000a680:	cf 93       	brcs	8000a672 <_malloc_r+0x1ca>
8000a682:	70 39       	ld.w	r9,r8[0xc]
8000a684:	8d 39       	st.w	r6[0xc],r9
8000a686:	8d 28       	st.w	r6[0x8],r8
8000a688:	91 36       	st.w	r8[0xc],r6
8000a68a:	93 26       	st.w	r9[0x8],r6
8000a68c:	e6 08 14 02 	asr	r8,r3,0x2
8000a690:	30 1b       	mov	r11,1
8000a692:	e0 64 05 38 	mov	r4,1336
8000a696:	f6 08 09 4b 	lsl	r11,r11,r8
8000a69a:	68 18       	ld.w	r8,r4[0x4]
8000a69c:	10 3b       	cp.w	r11,r8
8000a69e:	e0 8b 00 6b 	brhi	8000a774 <_malloc_r+0x2cc>
8000a6a2:	f7 e8 00 09 	and	r9,r11,r8
8000a6a6:	c0 b1       	brne	8000a6bc <_malloc_r+0x214>
8000a6a8:	e0 13 ff fc 	andl	r3,0xfffc
8000a6ac:	a1 7b       	lsl	r11,0x1
8000a6ae:	2f c3       	sub	r3,-4
8000a6b0:	c0 38       	rjmp	8000a6b6 <_malloc_r+0x20e>
8000a6b2:	2f c3       	sub	r3,-4
8000a6b4:	a1 7b       	lsl	r11,0x1
8000a6b6:	f7 e8 00 09 	and	r9,r11,r8
8000a6ba:	cf c0       	breq	8000a6b2 <_malloc_r+0x20a>
8000a6bc:	e8 03 00 3e 	add	lr,r4,r3<<0x3
8000a6c0:	06 92       	mov	r2,r3
8000a6c2:	1c 91       	mov	r1,lr
8000a6c4:	62 36       	ld.w	r6,r1[0xc]
8000a6c6:	c2 e8       	rjmp	8000a722 <_malloc_r+0x27a>
8000a6c8:	6c 1a       	ld.w	r10,r6[0x4]
8000a6ca:	e0 1a ff fc 	andl	r10,0xfffc
8000a6ce:	f4 07 01 08 	sub	r8,r10,r7
8000a6d2:	58 f8       	cp.w	r8,15
8000a6d4:	e0 8a 00 15 	brle	8000a6fe <_malloc_r+0x256>
8000a6d8:	6c 3a       	ld.w	r10,r6[0xc]
8000a6da:	6c 29       	ld.w	r9,r6[0x8]
8000a6dc:	95 29       	st.w	r10[0x8],r9
8000a6de:	93 3a       	st.w	r9[0xc],r10
8000a6e0:	0e 99       	mov	r9,r7
8000a6e2:	ec 07 00 07 	add	r7,r6,r7
8000a6e6:	a1 a9       	sbr	r9,0x0
8000a6e8:	99 37       	st.w	r12[0xc],r7
8000a6ea:	99 27       	st.w	r12[0x8],r7
8000a6ec:	8d 19       	st.w	r6[0x4],r9
8000a6ee:	ee 08 09 08 	st.w	r7[r8],r8
8000a6f2:	8f 2c       	st.w	r7[0x8],r12
8000a6f4:	8f 3c       	st.w	r7[0xc],r12
8000a6f6:	a1 a8       	sbr	r8,0x0
8000a6f8:	0a 9c       	mov	r12,r5
8000a6fa:	8f 18       	st.w	r7[0x4],r8
8000a6fc:	c0 d8       	rjmp	8000a716 <_malloc_r+0x26e>
8000a6fe:	6c 39       	ld.w	r9,r6[0xc]
8000a700:	58 08       	cp.w	r8,0
8000a702:	c0 f5       	brlt	8000a720 <_malloc_r+0x278>
8000a704:	ec 0a 00 0a 	add	r10,r6,r10
8000a708:	74 18       	ld.w	r8,r10[0x4]
8000a70a:	a1 a8       	sbr	r8,0x0
8000a70c:	0a 9c       	mov	r12,r5
8000a70e:	95 18       	st.w	r10[0x4],r8
8000a710:	6c 28       	ld.w	r8,r6[0x8]
8000a712:	93 28       	st.w	r9[0x8],r8
8000a714:	91 39       	st.w	r8[0xc],r9
8000a716:	fe b0 f4 1b 	rcall	80008f4c <__malloc_unlock>
8000a71a:	ec cc ff f8 	sub	r12,r6,-8
8000a71e:	d8 32       	popm	r0-r7,pc
8000a720:	12 96       	mov	r6,r9
8000a722:	02 36       	cp.w	r6,r1
8000a724:	cd 21       	brne	8000a6c8 <_malloc_r+0x220>
8000a726:	2f f2       	sub	r2,-1
8000a728:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
8000a72c:	c0 30       	breq	8000a732 <_malloc_r+0x28a>
8000a72e:	2f 81       	sub	r1,-8
8000a730:	cc ab       	rjmp	8000a6c4 <_malloc_r+0x21c>
8000a732:	1c 98       	mov	r8,lr
8000a734:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
8000a738:	c0 81       	brne	8000a748 <_malloc_r+0x2a0>
8000a73a:	68 19       	ld.w	r9,r4[0x4]
8000a73c:	f6 08 11 ff 	rsub	r8,r11,-1
8000a740:	f3 e8 00 08 	and	r8,r9,r8
8000a744:	89 18       	st.w	r4[0x4],r8
8000a746:	c0 78       	rjmp	8000a754 <_malloc_r+0x2ac>
8000a748:	f0 c9 00 08 	sub	r9,r8,8
8000a74c:	20 13       	sub	r3,1
8000a74e:	70 08       	ld.w	r8,r8[0x0]
8000a750:	12 38       	cp.w	r8,r9
8000a752:	cf 10       	breq	8000a734 <_malloc_r+0x28c>
8000a754:	a1 7b       	lsl	r11,0x1
8000a756:	68 18       	ld.w	r8,r4[0x4]
8000a758:	10 3b       	cp.w	r11,r8
8000a75a:	e0 8b 00 0d 	brhi	8000a774 <_malloc_r+0x2cc>
8000a75e:	58 0b       	cp.w	r11,0
8000a760:	c0 a0       	breq	8000a774 <_malloc_r+0x2cc>
8000a762:	04 93       	mov	r3,r2
8000a764:	c0 38       	rjmp	8000a76a <_malloc_r+0x2c2>
8000a766:	2f c3       	sub	r3,-4
8000a768:	a1 7b       	lsl	r11,0x1
8000a76a:	f7 e8 00 09 	and	r9,r11,r8
8000a76e:	ca 71       	brne	8000a6bc <_malloc_r+0x214>
8000a770:	cf bb       	rjmp	8000a766 <_malloc_r+0x2be>
8000a772:	d7 03       	nop
8000a774:	68 23       	ld.w	r3,r4[0x8]
8000a776:	66 12       	ld.w	r2,r3[0x4]
8000a778:	e0 12 ff fc 	andl	r2,0xfffc
8000a77c:	0e 32       	cp.w	r2,r7
8000a77e:	5f 39       	srlo	r9
8000a780:	e4 07 01 08 	sub	r8,r2,r7
8000a784:	58 f8       	cp.w	r8,15
8000a786:	5f aa       	srle	r10
8000a788:	f5 e9 10 09 	or	r9,r10,r9
8000a78c:	e0 80 00 9a 	breq	8000a8c0 <_malloc_r+0x418>
8000a790:	e0 68 13 1c 	mov	r8,4892
8000a794:	70 01       	ld.w	r1,r8[0x0]
8000a796:	e0 68 09 44 	mov	r8,2372
8000a79a:	2f 01       	sub	r1,-16
8000a79c:	70 08       	ld.w	r8,r8[0x0]
8000a79e:	0e 01       	add	r1,r7
8000a7a0:	5b f8       	cp.w	r8,-1
8000a7a2:	c0 40       	breq	8000a7aa <_malloc_r+0x302>
8000a7a4:	28 11       	sub	r1,-127
8000a7a6:	e0 11 ff 80 	andl	r1,0xff80
8000a7aa:	02 9b       	mov	r11,r1
8000a7ac:	0a 9c       	mov	r12,r5
8000a7ae:	e0 a0 02 b7 	rcall	8000ad1c <_sbrk_r>
8000a7b2:	18 96       	mov	r6,r12
8000a7b4:	5b fc       	cp.w	r12,-1
8000a7b6:	c7 50       	breq	8000a8a0 <_malloc_r+0x3f8>
8000a7b8:	e6 02 00 08 	add	r8,r3,r2
8000a7bc:	10 3c       	cp.w	r12,r8
8000a7be:	c0 32       	brcc	8000a7c4 <_malloc_r+0x31c>
8000a7c0:	08 33       	cp.w	r3,r4
8000a7c2:	c6 f1       	brne	8000a8a0 <_malloc_r+0x3f8>
8000a7c4:	e0 6a 13 20 	mov	r10,4896
8000a7c8:	74 09       	ld.w	r9,r10[0x0]
8000a7ca:	e2 09 00 09 	add	r9,r1,r9
8000a7ce:	95 09       	st.w	r10[0x0],r9
8000a7d0:	10 36       	cp.w	r6,r8
8000a7d2:	c0 a1       	brne	8000a7e6 <_malloc_r+0x33e>
8000a7d4:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
8000a7d8:	c0 71       	brne	8000a7e6 <_malloc_r+0x33e>
8000a7da:	e2 02 00 02 	add	r2,r1,r2
8000a7de:	68 28       	ld.w	r8,r4[0x8]
8000a7e0:	a1 a2       	sbr	r2,0x0
8000a7e2:	91 12       	st.w	r8[0x4],r2
8000a7e4:	c4 f8       	rjmp	8000a882 <_malloc_r+0x3da>
8000a7e6:	e0 6a 09 44 	mov	r10,2372
8000a7ea:	74 0b       	ld.w	r11,r10[0x0]
8000a7ec:	5b fb       	cp.w	r11,-1
8000a7ee:	c0 31       	brne	8000a7f4 <_malloc_r+0x34c>
8000a7f0:	95 06       	st.w	r10[0x0],r6
8000a7f2:	c0 78       	rjmp	8000a800 <_malloc_r+0x358>
8000a7f4:	ec 09 00 09 	add	r9,r6,r9
8000a7f8:	e0 6a 13 20 	mov	r10,4896
8000a7fc:	10 19       	sub	r9,r8
8000a7fe:	95 09       	st.w	r10[0x0],r9
8000a800:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
8000a804:	f0 09 11 08 	rsub	r9,r8,8
8000a808:	58 08       	cp.w	r8,0
8000a80a:	f2 08 17 10 	movne	r8,r9
8000a80e:	ed d8 e1 06 	addne	r6,r6,r8
8000a812:	28 08       	sub	r8,-128
8000a814:	ec 01 00 01 	add	r1,r6,r1
8000a818:	0a 9c       	mov	r12,r5
8000a81a:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
8000a81e:	f0 01 01 01 	sub	r1,r8,r1
8000a822:	02 9b       	mov	r11,r1
8000a824:	e0 a0 02 7c 	rcall	8000ad1c <_sbrk_r>
8000a828:	e0 68 13 20 	mov	r8,4896
8000a82c:	5b fc       	cp.w	r12,-1
8000a82e:	ec 0c 17 00 	moveq	r12,r6
8000a832:	f9 b1 00 00 	moveq	r1,0
8000a836:	70 09       	ld.w	r9,r8[0x0]
8000a838:	0c 1c       	sub	r12,r6
8000a83a:	89 26       	st.w	r4[0x8],r6
8000a83c:	02 0c       	add	r12,r1
8000a83e:	12 01       	add	r1,r9
8000a840:	a1 ac       	sbr	r12,0x0
8000a842:	91 01       	st.w	r8[0x0],r1
8000a844:	8d 1c       	st.w	r6[0x4],r12
8000a846:	08 33       	cp.w	r3,r4
8000a848:	c1 d0       	breq	8000a882 <_malloc_r+0x3da>
8000a84a:	58 f2       	cp.w	r2,15
8000a84c:	e0 8b 00 05 	brhi	8000a856 <_malloc_r+0x3ae>
8000a850:	30 18       	mov	r8,1
8000a852:	8d 18       	st.w	r6[0x4],r8
8000a854:	c2 68       	rjmp	8000a8a0 <_malloc_r+0x3f8>
8000a856:	30 59       	mov	r9,5
8000a858:	20 c2       	sub	r2,12
8000a85a:	e0 12 ff f8 	andl	r2,0xfff8
8000a85e:	e6 02 00 08 	add	r8,r3,r2
8000a862:	91 29       	st.w	r8[0x8],r9
8000a864:	91 19       	st.w	r8[0x4],r9
8000a866:	66 18       	ld.w	r8,r3[0x4]
8000a868:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000a86c:	e5 e8 10 08 	or	r8,r2,r8
8000a870:	87 18       	st.w	r3[0x4],r8
8000a872:	58 f2       	cp.w	r2,15
8000a874:	e0 88 00 07 	brls	8000a882 <_malloc_r+0x3da>
8000a878:	e6 cb ff f8 	sub	r11,r3,-8
8000a87c:	0a 9c       	mov	r12,r5
8000a87e:	e0 a0 1d 23 	rcall	8000e2c4 <_free_r>
8000a882:	e0 69 13 18 	mov	r9,4888
8000a886:	72 0a       	ld.w	r10,r9[0x0]
8000a888:	e0 68 13 20 	mov	r8,4896
8000a88c:	70 08       	ld.w	r8,r8[0x0]
8000a88e:	14 38       	cp.w	r8,r10
8000a890:	f3 f8 ba 00 	st.whi	r9[0x0],r8
8000a894:	e0 69 13 14 	mov	r9,4884
8000a898:	72 0a       	ld.w	r10,r9[0x0]
8000a89a:	14 38       	cp.w	r8,r10
8000a89c:	f3 f8 ba 00 	st.whi	r9[0x0],r8
8000a8a0:	68 28       	ld.w	r8,r4[0x8]
8000a8a2:	70 18       	ld.w	r8,r8[0x4]
8000a8a4:	e0 18 ff fc 	andl	r8,0xfffc
8000a8a8:	0e 38       	cp.w	r8,r7
8000a8aa:	5f 39       	srlo	r9
8000a8ac:	0e 18       	sub	r8,r7
8000a8ae:	58 f8       	cp.w	r8,15
8000a8b0:	5f aa       	srle	r10
8000a8b2:	f5 e9 10 09 	or	r9,r10,r9
8000a8b6:	c0 50       	breq	8000a8c0 <_malloc_r+0x418>
8000a8b8:	0a 9c       	mov	r12,r5
8000a8ba:	fe b0 f3 49 	rcall	80008f4c <__malloc_unlock>
8000a8be:	d8 3a       	popm	r0-r7,pc,r12=0
8000a8c0:	68 26       	ld.w	r6,r4[0x8]
8000a8c2:	a1 a8       	sbr	r8,0x0
8000a8c4:	0e 99       	mov	r9,r7
8000a8c6:	a1 a9       	sbr	r9,0x0
8000a8c8:	8d 19       	st.w	r6[0x4],r9
8000a8ca:	ec 07 00 07 	add	r7,r6,r7
8000a8ce:	0a 9c       	mov	r12,r5
8000a8d0:	89 27       	st.w	r4[0x8],r7
8000a8d2:	8f 18       	st.w	r7[0x4],r8
8000a8d4:	fe b0 f3 3c 	rcall	80008f4c <__malloc_unlock>
8000a8d8:	ec cc ff f8 	sub	r12,r6,-8
8000a8dc:	d8 32       	popm	r0-r7,pc
8000a8de:	d7 03       	nop

8000a8e0 <memcmp>:
8000a8e0:	d4 01       	pushm	lr
8000a8e2:	30 08       	mov	r8,0
8000a8e4:	c0 d8       	rjmp	8000a8fe <memcmp+0x1e>
8000a8e6:	f8 08 07 0e 	ld.ub	lr,r12[r8]
8000a8ea:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000a8ee:	20 1a       	sub	r10,1
8000a8f0:	2f f8       	sub	r8,-1
8000a8f2:	f2 0e 18 00 	cp.b	lr,r9
8000a8f6:	c0 40       	breq	8000a8fe <memcmp+0x1e>
8000a8f8:	fc 09 01 0c 	sub	r12,lr,r9
8000a8fc:	d8 02       	popm	pc
8000a8fe:	58 0a       	cp.w	r10,0
8000a900:	cf 31       	brne	8000a8e6 <memcmp+0x6>
8000a902:	14 9c       	mov	r12,r10
8000a904:	d8 02       	popm	pc

8000a906 <memcpy>:
8000a906:	58 8a       	cp.w	r10,8
8000a908:	c2 f5       	brlt	8000a966 <memcpy+0x60>
8000a90a:	f9 eb 10 09 	or	r9,r12,r11
8000a90e:	e2 19 00 03 	andl	r9,0x3,COH
8000a912:	e0 81 00 97 	brne	8000aa40 <memcpy+0x13a>
8000a916:	e0 4a 00 20 	cp.w	r10,32
8000a91a:	c3 b4       	brge	8000a990 <memcpy+0x8a>
8000a91c:	f4 08 14 02 	asr	r8,r10,0x2
8000a920:	f0 09 11 08 	rsub	r9,r8,8
8000a924:	fe 09 00 2f 	add	pc,pc,r9<<0x2
8000a928:	76 69       	ld.w	r9,r11[0x18]
8000a92a:	99 69       	st.w	r12[0x18],r9
8000a92c:	76 59       	ld.w	r9,r11[0x14]
8000a92e:	99 59       	st.w	r12[0x14],r9
8000a930:	76 49       	ld.w	r9,r11[0x10]
8000a932:	99 49       	st.w	r12[0x10],r9
8000a934:	76 39       	ld.w	r9,r11[0xc]
8000a936:	99 39       	st.w	r12[0xc],r9
8000a938:	76 29       	ld.w	r9,r11[0x8]
8000a93a:	99 29       	st.w	r12[0x8],r9
8000a93c:	76 19       	ld.w	r9,r11[0x4]
8000a93e:	99 19       	st.w	r12[0x4],r9
8000a940:	76 09       	ld.w	r9,r11[0x0]
8000a942:	99 09       	st.w	r12[0x0],r9
8000a944:	f6 08 00 2b 	add	r11,r11,r8<<0x2
8000a948:	f8 08 00 28 	add	r8,r12,r8<<0x2
8000a94c:	e0 1a 00 03 	andl	r10,0x3
8000a950:	f4 0a 11 04 	rsub	r10,r10,4
8000a954:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
8000a958:	17 a9       	ld.ub	r9,r11[0x2]
8000a95a:	b0 a9       	st.b	r8[0x2],r9
8000a95c:	17 99       	ld.ub	r9,r11[0x1]
8000a95e:	b0 99       	st.b	r8[0x1],r9
8000a960:	17 89       	ld.ub	r9,r11[0x0]
8000a962:	b0 89       	st.b	r8[0x0],r9
8000a964:	5e fc       	retal	r12
8000a966:	f4 0a 11 09 	rsub	r10,r10,9
8000a96a:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
8000a96e:	17 f9       	ld.ub	r9,r11[0x7]
8000a970:	b8 f9       	st.b	r12[0x7],r9
8000a972:	17 e9       	ld.ub	r9,r11[0x6]
8000a974:	b8 e9       	st.b	r12[0x6],r9
8000a976:	17 d9       	ld.ub	r9,r11[0x5]
8000a978:	b8 d9       	st.b	r12[0x5],r9
8000a97a:	17 c9       	ld.ub	r9,r11[0x4]
8000a97c:	b8 c9       	st.b	r12[0x4],r9
8000a97e:	17 b9       	ld.ub	r9,r11[0x3]
8000a980:	b8 b9       	st.b	r12[0x3],r9
8000a982:	17 a9       	ld.ub	r9,r11[0x2]
8000a984:	b8 a9       	st.b	r12[0x2],r9
8000a986:	17 99       	ld.ub	r9,r11[0x1]
8000a988:	b8 99       	st.b	r12[0x1],r9
8000a98a:	17 89       	ld.ub	r9,r11[0x0]
8000a98c:	b8 89       	st.b	r12[0x0],r9
8000a98e:	5e fc       	retal	r12
8000a990:	eb cd 40 c0 	pushm	r6-r7,lr
8000a994:	18 99       	mov	r9,r12
8000a996:	22 0a       	sub	r10,32
8000a998:	b7 07       	ld.d	r6,r11++
8000a99a:	b3 26       	st.d	r9++,r6
8000a99c:	b7 07       	ld.d	r6,r11++
8000a99e:	b3 26       	st.d	r9++,r6
8000a9a0:	b7 07       	ld.d	r6,r11++
8000a9a2:	b3 26       	st.d	r9++,r6
8000a9a4:	b7 07       	ld.d	r6,r11++
8000a9a6:	b3 26       	st.d	r9++,r6
8000a9a8:	22 0a       	sub	r10,32
8000a9aa:	cf 74       	brge	8000a998 <memcpy+0x92>
8000a9ac:	2f 0a       	sub	r10,-16
8000a9ae:	c0 65       	brlt	8000a9ba <memcpy+0xb4>
8000a9b0:	b7 07       	ld.d	r6,r11++
8000a9b2:	b3 26       	st.d	r9++,r6
8000a9b4:	b7 07       	ld.d	r6,r11++
8000a9b6:	b3 26       	st.d	r9++,r6
8000a9b8:	21 0a       	sub	r10,16
8000a9ba:	5c 3a       	neg	r10
8000a9bc:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
8000a9c0:	d7 03       	nop
8000a9c2:	d7 03       	nop
8000a9c4:	f7 36 00 0e 	ld.ub	r6,r11[14]
8000a9c8:	f3 66 00 0e 	st.b	r9[14],r6
8000a9cc:	f7 36 00 0d 	ld.ub	r6,r11[13]
8000a9d0:	f3 66 00 0d 	st.b	r9[13],r6
8000a9d4:	f7 36 00 0c 	ld.ub	r6,r11[12]
8000a9d8:	f3 66 00 0c 	st.b	r9[12],r6
8000a9dc:	f7 36 00 0b 	ld.ub	r6,r11[11]
8000a9e0:	f3 66 00 0b 	st.b	r9[11],r6
8000a9e4:	f7 36 00 0a 	ld.ub	r6,r11[10]
8000a9e8:	f3 66 00 0a 	st.b	r9[10],r6
8000a9ec:	f7 36 00 09 	ld.ub	r6,r11[9]
8000a9f0:	f3 66 00 09 	st.b	r9[9],r6
8000a9f4:	f7 36 00 08 	ld.ub	r6,r11[8]
8000a9f8:	f3 66 00 08 	st.b	r9[8],r6
8000a9fc:	f7 36 00 07 	ld.ub	r6,r11[7]
8000aa00:	f3 66 00 07 	st.b	r9[7],r6
8000aa04:	f7 36 00 06 	ld.ub	r6,r11[6]
8000aa08:	f3 66 00 06 	st.b	r9[6],r6
8000aa0c:	f7 36 00 05 	ld.ub	r6,r11[5]
8000aa10:	f3 66 00 05 	st.b	r9[5],r6
8000aa14:	f7 36 00 04 	ld.ub	r6,r11[4]
8000aa18:	f3 66 00 04 	st.b	r9[4],r6
8000aa1c:	f7 36 00 03 	ld.ub	r6,r11[3]
8000aa20:	f3 66 00 03 	st.b	r9[3],r6
8000aa24:	f7 36 00 02 	ld.ub	r6,r11[2]
8000aa28:	f3 66 00 02 	st.b	r9[2],r6
8000aa2c:	f7 36 00 01 	ld.ub	r6,r11[1]
8000aa30:	f3 66 00 01 	st.b	r9[1],r6
8000aa34:	f7 36 00 00 	ld.ub	r6,r11[0]
8000aa38:	f3 66 00 00 	st.b	r9[0],r6
8000aa3c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000aa40:	20 1a       	sub	r10,1
8000aa42:	f6 0a 07 09 	ld.ub	r9,r11[r10]
8000aa46:	f8 0a 0b 09 	st.b	r12[r10],r9
8000aa4a:	cf b1       	brne	8000aa40 <memcpy+0x13a>
8000aa4c:	5e fc       	retal	r12

8000aa4e <memset>:
8000aa4e:	18 98       	mov	r8,r12
8000aa50:	c0 38       	rjmp	8000aa56 <memset+0x8>
8000aa52:	10 cb       	st.b	r8++,r11
8000aa54:	20 1a       	sub	r10,1
8000aa56:	58 0a       	cp.w	r10,0
8000aa58:	cf d1       	brne	8000aa52 <memset+0x4>
8000aa5a:	5e fc       	retal	r12

8000aa5c <_realloc_r>:
8000aa5c:	d4 31       	pushm	r0-r7,lr
8000aa5e:	20 1d       	sub	sp,4
8000aa60:	16 94       	mov	r4,r11
8000aa62:	18 92       	mov	r2,r12
8000aa64:	14 9b       	mov	r11,r10
8000aa66:	58 04       	cp.w	r4,0
8000aa68:	c0 51       	brne	8000aa72 <_realloc_r+0x16>
8000aa6a:	fe b0 fd 1f 	rcall	8000a4a8 <_malloc_r>
8000aa6e:	18 95       	mov	r5,r12
8000aa70:	c5 39       	rjmp	8000ad16 <_realloc_r+0x2ba>
8000aa72:	50 0a       	stdsp	sp[0x0],r10
8000aa74:	fe b0 f2 66 	rcall	80008f40 <__malloc_lock>
8000aa78:	40 0b       	lddsp	r11,sp[0x0]
8000aa7a:	f6 c8 ff f5 	sub	r8,r11,-11
8000aa7e:	e8 c1 00 08 	sub	r1,r4,8
8000aa82:	10 96       	mov	r6,r8
8000aa84:	62 1c       	ld.w	r12,r1[0x4]
8000aa86:	e0 16 ff f8 	andl	r6,0xfff8
8000aa8a:	59 68       	cp.w	r8,22
8000aa8c:	f9 b6 08 10 	movls	r6,16
8000aa90:	16 36       	cp.w	r6,r11
8000aa92:	5f 38       	srlo	r8
8000aa94:	f1 e6 13 f8 	or	r8,r8,r6>>0x1f
8000aa98:	c0 50       	breq	8000aaa2 <_realloc_r+0x46>
8000aa9a:	30 c8       	mov	r8,12
8000aa9c:	30 05       	mov	r5,0
8000aa9e:	85 38       	st.w	r2[0xc],r8
8000aaa0:	c3 b9       	rjmp	8000ad16 <_realloc_r+0x2ba>
8000aaa2:	18 90       	mov	r0,r12
8000aaa4:	e0 10 ff fc 	andl	r0,0xfffc
8000aaa8:	0c 30       	cp.w	r0,r6
8000aaaa:	e0 84 01 0b 	brge	8000acc0 <_realloc_r+0x264>
8000aaae:	e0 68 05 38 	mov	r8,1336
8000aab2:	e2 00 00 09 	add	r9,r1,r0
8000aab6:	70 25       	ld.w	r5,r8[0x8]
8000aab8:	0a 39       	cp.w	r9,r5
8000aaba:	c0 90       	breq	8000aacc <_realloc_r+0x70>
8000aabc:	72 1a       	ld.w	r10,r9[0x4]
8000aabe:	a1 ca       	cbr	r10,0x0
8000aac0:	f2 0a 00 0a 	add	r10,r9,r10
8000aac4:	74 1a       	ld.w	r10,r10[0x4]
8000aac6:	ed ba 00 00 	bld	r10,0x0
8000aaca:	c2 20       	breq	8000ab0e <_realloc_r+0xb2>
8000aacc:	72 1a       	ld.w	r10,r9[0x4]
8000aace:	e0 1a ff fc 	andl	r10,0xfffc
8000aad2:	f4 00 00 03 	add	r3,r10,r0
8000aad6:	0a 39       	cp.w	r9,r5
8000aad8:	c1 31       	brne	8000aafe <_realloc_r+0xa2>
8000aada:	ec c7 ff f0 	sub	r7,r6,-16
8000aade:	0e 33       	cp.w	r3,r7
8000aae0:	c1 95       	brlt	8000ab12 <_realloc_r+0xb6>
8000aae2:	e2 06 00 09 	add	r9,r1,r6
8000aae6:	0c 13       	sub	r3,r6
8000aae8:	a1 a3       	sbr	r3,0x0
8000aaea:	93 13       	st.w	r9[0x4],r3
8000aaec:	91 29       	st.w	r8[0x8],r9
8000aaee:	04 9c       	mov	r12,r2
8000aaf0:	62 18       	ld.w	r8,r1[0x4]
8000aaf2:	08 95       	mov	r5,r4
8000aaf4:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000aaf8:	10 46       	or	r6,r8
8000aafa:	83 16       	st.w	r1[0x4],r6
8000aafc:	c0 b9       	rjmp	8000ad12 <_realloc_r+0x2b6>
8000aafe:	0c 33       	cp.w	r3,r6
8000ab00:	c0 95       	brlt	8000ab12 <_realloc_r+0xb6>
8000ab02:	72 28       	ld.w	r8,r9[0x8]
8000ab04:	02 97       	mov	r7,r1
8000ab06:	72 39       	ld.w	r9,r9[0xc]
8000ab08:	93 28       	st.w	r9[0x8],r8
8000ab0a:	91 39       	st.w	r8[0xc],r9
8000ab0c:	cd c8       	rjmp	8000acc4 <_realloc_r+0x268>
8000ab0e:	30 0a       	mov	r10,0
8000ab10:	14 99       	mov	r9,r10
8000ab12:	ed bc 00 00 	bld	r12,0x0
8000ab16:	e0 80 00 95 	breq	8000ac40 <_realloc_r+0x1e4>
8000ab1a:	62 07       	ld.w	r7,r1[0x0]
8000ab1c:	e2 07 01 07 	sub	r7,r1,r7
8000ab20:	6e 1c       	ld.w	r12,r7[0x4]
8000ab22:	e0 1c ff fc 	andl	r12,0xfffc
8000ab26:	58 09       	cp.w	r9,0
8000ab28:	c5 60       	breq	8000abd4 <_realloc_r+0x178>
8000ab2a:	f8 00 00 03 	add	r3,r12,r0
8000ab2e:	0a 39       	cp.w	r9,r5
8000ab30:	c4 81       	brne	8000abc0 <_realloc_r+0x164>
8000ab32:	14 03       	add	r3,r10
8000ab34:	ec c9 ff f0 	sub	r9,r6,-16
8000ab38:	12 33       	cp.w	r3,r9
8000ab3a:	c4 d5       	brlt	8000abd4 <_realloc_r+0x178>
8000ab3c:	6e 3a       	ld.w	r10,r7[0xc]
8000ab3e:	6e 29       	ld.w	r9,r7[0x8]
8000ab40:	95 29       	st.w	r10[0x8],r9
8000ab42:	93 3a       	st.w	r9[0xc],r10
8000ab44:	ee c5 ff f8 	sub	r5,r7,-8
8000ab48:	e0 ca 00 04 	sub	r10,r0,4
8000ab4c:	e0 4a 00 24 	cp.w	r10,36
8000ab50:	e0 8b 00 25 	brhi	8000ab9a <_realloc_r+0x13e>
8000ab54:	0a 99       	mov	r9,r5
8000ab56:	59 3a       	cp.w	r10,19
8000ab58:	e0 88 00 1a 	brls	8000ab8c <_realloc_r+0x130>
8000ab5c:	09 09       	ld.w	r9,r4++
8000ab5e:	8b 09       	st.w	r5[0x0],r9
8000ab60:	09 09       	ld.w	r9,r4++
8000ab62:	8f 39       	st.w	r7[0xc],r9
8000ab64:	ee c9 ff f0 	sub	r9,r7,-16
8000ab68:	59 ba       	cp.w	r10,27
8000ab6a:	e0 88 00 11 	brls	8000ab8c <_realloc_r+0x130>
8000ab6e:	09 0b       	ld.w	r11,r4++
8000ab70:	93 0b       	st.w	r9[0x0],r11
8000ab72:	09 09       	ld.w	r9,r4++
8000ab74:	8f 59       	st.w	r7[0x14],r9
8000ab76:	ee c9 ff e8 	sub	r9,r7,-24
8000ab7a:	e0 4a 00 24 	cp.w	r10,36
8000ab7e:	c0 71       	brne	8000ab8c <_realloc_r+0x130>
8000ab80:	09 0a       	ld.w	r10,r4++
8000ab82:	93 0a       	st.w	r9[0x0],r10
8000ab84:	ee c9 ff e0 	sub	r9,r7,-32
8000ab88:	09 0a       	ld.w	r10,r4++
8000ab8a:	8f 7a       	st.w	r7[0x1c],r10
8000ab8c:	09 0a       	ld.w	r10,r4++
8000ab8e:	12 aa       	st.w	r9++,r10
8000ab90:	68 0a       	ld.w	r10,r4[0x0]
8000ab92:	93 0a       	st.w	r9[0x0],r10
8000ab94:	68 1a       	ld.w	r10,r4[0x4]
8000ab96:	93 1a       	st.w	r9[0x4],r10
8000ab98:	c0 78       	rjmp	8000aba6 <_realloc_r+0x14a>
8000ab9a:	50 08       	stdsp	sp[0x0],r8
8000ab9c:	08 9b       	mov	r11,r4
8000ab9e:	0a 9c       	mov	r12,r5
8000aba0:	e0 a0 1e 35 	rcall	8000e80a <memmove>
8000aba4:	40 08       	lddsp	r8,sp[0x0]
8000aba6:	ee 06 00 09 	add	r9,r7,r6
8000abaa:	0c 13       	sub	r3,r6
8000abac:	a1 a3       	sbr	r3,0x0
8000abae:	93 13       	st.w	r9[0x4],r3
8000abb0:	91 29       	st.w	r8[0x8],r9
8000abb2:	04 9c       	mov	r12,r2
8000abb4:	6e 18       	ld.w	r8,r7[0x4]
8000abb6:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000abba:	10 46       	or	r6,r8
8000abbc:	8f 16       	st.w	r7[0x4],r6
8000abbe:	ca a8       	rjmp	8000ad12 <_realloc_r+0x2b6>
8000abc0:	14 03       	add	r3,r10
8000abc2:	0c 33       	cp.w	r3,r6
8000abc4:	c0 85       	brlt	8000abd4 <_realloc_r+0x178>
8000abc6:	72 28       	ld.w	r8,r9[0x8]
8000abc8:	72 39       	ld.w	r9,r9[0xc]
8000abca:	93 28       	st.w	r9[0x8],r8
8000abcc:	91 39       	st.w	r8[0xc],r9
8000abce:	6e 28       	ld.w	r8,r7[0x8]
8000abd0:	6e 39       	ld.w	r9,r7[0xc]
8000abd2:	c0 78       	rjmp	8000abe0 <_realloc_r+0x184>
8000abd4:	f8 00 00 03 	add	r3,r12,r0
8000abd8:	0c 33       	cp.w	r3,r6
8000abda:	c3 35       	brlt	8000ac40 <_realloc_r+0x1e4>
8000abdc:	6e 39       	ld.w	r9,r7[0xc]
8000abde:	6e 28       	ld.w	r8,r7[0x8]
8000abe0:	93 28       	st.w	r9[0x8],r8
8000abe2:	91 39       	st.w	r8[0xc],r9
8000abe4:	e0 ca 00 04 	sub	r10,r0,4
8000abe8:	ee cc ff f8 	sub	r12,r7,-8
8000abec:	e0 4a 00 24 	cp.w	r10,36
8000abf0:	e0 8b 00 24 	brhi	8000ac38 <_realloc_r+0x1dc>
8000abf4:	59 3a       	cp.w	r10,19
8000abf6:	e0 88 00 1a 	brls	8000ac2a <_realloc_r+0x1ce>
8000abfa:	09 08       	ld.w	r8,r4++
8000abfc:	99 08       	st.w	r12[0x0],r8
8000abfe:	09 08       	ld.w	r8,r4++
8000ac00:	8f 38       	st.w	r7[0xc],r8
8000ac02:	ee cc ff f0 	sub	r12,r7,-16
8000ac06:	59 ba       	cp.w	r10,27
8000ac08:	e0 88 00 11 	brls	8000ac2a <_realloc_r+0x1ce>
8000ac0c:	09 08       	ld.w	r8,r4++
8000ac0e:	99 08       	st.w	r12[0x0],r8
8000ac10:	09 08       	ld.w	r8,r4++
8000ac12:	8f 58       	st.w	r7[0x14],r8
8000ac14:	ee cc ff e8 	sub	r12,r7,-24
8000ac18:	e0 4a 00 24 	cp.w	r10,36
8000ac1c:	c0 71       	brne	8000ac2a <_realloc_r+0x1ce>
8000ac1e:	09 08       	ld.w	r8,r4++
8000ac20:	99 08       	st.w	r12[0x0],r8
8000ac22:	ee cc ff e0 	sub	r12,r7,-32
8000ac26:	09 08       	ld.w	r8,r4++
8000ac28:	8f 78       	st.w	r7[0x1c],r8
8000ac2a:	09 08       	ld.w	r8,r4++
8000ac2c:	18 a8       	st.w	r12++,r8
8000ac2e:	68 08       	ld.w	r8,r4[0x0]
8000ac30:	99 08       	st.w	r12[0x0],r8
8000ac32:	68 18       	ld.w	r8,r4[0x4]
8000ac34:	99 18       	st.w	r12[0x4],r8
8000ac36:	c4 78       	rjmp	8000acc4 <_realloc_r+0x268>
8000ac38:	08 9b       	mov	r11,r4
8000ac3a:	e0 a0 1d e8 	rcall	8000e80a <memmove>
8000ac3e:	c4 38       	rjmp	8000acc4 <_realloc_r+0x268>
8000ac40:	04 9c       	mov	r12,r2
8000ac42:	fe b0 fc 33 	rcall	8000a4a8 <_malloc_r>
8000ac46:	18 95       	mov	r5,r12
8000ac48:	c3 a0       	breq	8000acbc <_realloc_r+0x260>
8000ac4a:	62 18       	ld.w	r8,r1[0x4]
8000ac4c:	f8 c9 00 08 	sub	r9,r12,8
8000ac50:	a1 c8       	cbr	r8,0x0
8000ac52:	e2 08 00 08 	add	r8,r1,r8
8000ac56:	10 39       	cp.w	r9,r8
8000ac58:	c0 71       	brne	8000ac66 <_realloc_r+0x20a>
8000ac5a:	72 13       	ld.w	r3,r9[0x4]
8000ac5c:	02 97       	mov	r7,r1
8000ac5e:	e0 13 ff fc 	andl	r3,0xfffc
8000ac62:	00 03       	add	r3,r0
8000ac64:	c3 08       	rjmp	8000acc4 <_realloc_r+0x268>
8000ac66:	e0 ca 00 04 	sub	r10,r0,4
8000ac6a:	e0 4a 00 24 	cp.w	r10,36
8000ac6e:	e0 8b 00 20 	brhi	8000acae <_realloc_r+0x252>
8000ac72:	08 99       	mov	r9,r4
8000ac74:	18 98       	mov	r8,r12
8000ac76:	59 3a       	cp.w	r10,19
8000ac78:	e0 88 00 14 	brls	8000aca0 <_realloc_r+0x244>
8000ac7c:	13 0b       	ld.w	r11,r9++
8000ac7e:	10 ab       	st.w	r8++,r11
8000ac80:	13 0b       	ld.w	r11,r9++
8000ac82:	10 ab       	st.w	r8++,r11
8000ac84:	59 ba       	cp.w	r10,27
8000ac86:	e0 88 00 0d 	brls	8000aca0 <_realloc_r+0x244>
8000ac8a:	13 0b       	ld.w	r11,r9++
8000ac8c:	10 ab       	st.w	r8++,r11
8000ac8e:	13 0b       	ld.w	r11,r9++
8000ac90:	10 ab       	st.w	r8++,r11
8000ac92:	e0 4a 00 24 	cp.w	r10,36
8000ac96:	c0 51       	brne	8000aca0 <_realloc_r+0x244>
8000ac98:	13 0a       	ld.w	r10,r9++
8000ac9a:	10 aa       	st.w	r8++,r10
8000ac9c:	13 0a       	ld.w	r10,r9++
8000ac9e:	10 aa       	st.w	r8++,r10
8000aca0:	13 0a       	ld.w	r10,r9++
8000aca2:	10 aa       	st.w	r8++,r10
8000aca4:	72 0a       	ld.w	r10,r9[0x0]
8000aca6:	91 0a       	st.w	r8[0x0],r10
8000aca8:	72 19       	ld.w	r9,r9[0x4]
8000acaa:	91 19       	st.w	r8[0x4],r9
8000acac:	c0 48       	rjmp	8000acb4 <_realloc_r+0x258>
8000acae:	08 9b       	mov	r11,r4
8000acb0:	e0 a0 1d ad 	rcall	8000e80a <memmove>
8000acb4:	08 9b       	mov	r11,r4
8000acb6:	04 9c       	mov	r12,r2
8000acb8:	e0 a0 1b 06 	rcall	8000e2c4 <_free_r>
8000acbc:	04 9c       	mov	r12,r2
8000acbe:	c2 a8       	rjmp	8000ad12 <_realloc_r+0x2b6>
8000acc0:	00 93       	mov	r3,r0
8000acc2:	02 97       	mov	r7,r1
8000acc4:	e6 06 01 09 	sub	r9,r3,r6
8000acc8:	6e 18       	ld.w	r8,r7[0x4]
8000acca:	58 f9       	cp.w	r9,15
8000accc:	e0 88 00 16 	brls	8000acf8 <_realloc_r+0x29c>
8000acd0:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000acd4:	ed e8 10 08 	or	r8,r6,r8
8000acd8:	8f 18       	st.w	r7[0x4],r8
8000acda:	12 98       	mov	r8,r9
8000acdc:	a1 a8       	sbr	r8,0x0
8000acde:	ee 06 00 0b 	add	r11,r7,r6
8000ace2:	f6 09 00 09 	add	r9,r11,r9
8000ace6:	97 18       	st.w	r11[0x4],r8
8000ace8:	72 18       	ld.w	r8,r9[0x4]
8000acea:	a1 a8       	sbr	r8,0x0
8000acec:	2f 8b       	sub	r11,-8
8000acee:	93 18       	st.w	r9[0x4],r8
8000acf0:	04 9c       	mov	r12,r2
8000acf2:	e0 a0 1a e9 	rcall	8000e2c4 <_free_r>
8000acf6:	c0 b8       	rjmp	8000ad0c <_realloc_r+0x2b0>
8000acf8:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000acfc:	e7 e8 10 08 	or	r8,r3,r8
8000ad00:	8f 18       	st.w	r7[0x4],r8
8000ad02:	ee 03 00 03 	add	r3,r7,r3
8000ad06:	66 18       	ld.w	r8,r3[0x4]
8000ad08:	a1 a8       	sbr	r8,0x0
8000ad0a:	87 18       	st.w	r3[0x4],r8
8000ad0c:	04 9c       	mov	r12,r2
8000ad0e:	ee c5 ff f8 	sub	r5,r7,-8
8000ad12:	fe b0 f1 1d 	rcall	80008f4c <__malloc_unlock>
8000ad16:	0a 9c       	mov	r12,r5
8000ad18:	2f fd       	sub	sp,-4
8000ad1a:	d8 32       	popm	r0-r7,pc

8000ad1c <_sbrk_r>:
8000ad1c:	d4 21       	pushm	r4-r7,lr
8000ad1e:	30 08       	mov	r8,0
8000ad20:	18 97       	mov	r7,r12
8000ad22:	e0 66 46 a8 	mov	r6,18088
8000ad26:	16 9c       	mov	r12,r11
8000ad28:	8d 08       	st.w	r6[0x0],r8
8000ad2a:	c1 1d       	rcall	8000af4c <_sbrk>
8000ad2c:	5b fc       	cp.w	r12,-1
8000ad2e:	c0 51       	brne	8000ad38 <_sbrk_r+0x1c>
8000ad30:	6c 08       	ld.w	r8,r6[0x0]
8000ad32:	58 08       	cp.w	r8,0
8000ad34:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000ad38:	d8 22       	popm	r4-r7,pc
8000ad3a:	d7 03       	nop

8000ad3c <sprintf>:
8000ad3c:	d4 01       	pushm	lr
8000ad3e:	21 7d       	sub	sp,92
8000ad40:	e0 68 ff ff 	mov	r8,65535
8000ad44:	ea 18 7f ff 	orh	r8,0x7fff
8000ad48:	50 58       	stdsp	sp[0x14],r8
8000ad4a:	50 28       	stdsp	sp[0x8],r8
8000ad4c:	e0 68 02 08 	mov	r8,520
8000ad50:	ba 68       	st.h	sp[0xc],r8
8000ad52:	3f f8       	mov	r8,-1
8000ad54:	ba 78       	st.h	sp[0xe],r8
8000ad56:	e0 68 0a 38 	mov	r8,2616
8000ad5a:	50 4c       	stdsp	sp[0x10],r12
8000ad5c:	16 9a       	mov	r10,r11
8000ad5e:	50 0c       	stdsp	sp[0x0],r12
8000ad60:	fa c9 ff a0 	sub	r9,sp,-96
8000ad64:	70 0c       	ld.w	r12,r8[0x0]
8000ad66:	1a 9b       	mov	r11,sp
8000ad68:	e0 a0 02 ac 	rcall	8000b2c0 <_vfprintf_r>
8000ad6c:	30 09       	mov	r9,0
8000ad6e:	40 08       	lddsp	r8,sp[0x0]
8000ad70:	b0 89       	st.b	r8[0x0],r9
8000ad72:	2e 9d       	sub	sp,-92
8000ad74:	d8 02       	popm	pc
8000ad76:	d7 03       	nop

8000ad78 <strcpy>:
8000ad78:	30 08       	mov	r8,0
8000ad7a:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000ad7e:	f8 08 0b 09 	st.b	r12[r8],r9
8000ad82:	2f f8       	sub	r8,-1
8000ad84:	58 09       	cp.w	r9,0
8000ad86:	cf a1       	brne	8000ad7a <strcpy+0x2>
8000ad88:	5e fc       	retal	r12

8000ad8a <strlen>:
8000ad8a:	30 09       	mov	r9,0
8000ad8c:	18 98       	mov	r8,r12
8000ad8e:	c0 28       	rjmp	8000ad92 <strlen+0x8>
8000ad90:	2f f8       	sub	r8,-1
8000ad92:	11 8a       	ld.ub	r10,r8[0x0]
8000ad94:	f2 0a 18 00 	cp.b	r10,r9
8000ad98:	cf c1       	brne	8000ad90 <strlen+0x6>
8000ad9a:	f0 0c 01 0c 	sub	r12,r8,r12
8000ad9e:	5e fc       	retal	r12

8000ada0 <strncpy>:
8000ada0:	30 08       	mov	r8,0
8000ada2:	10 3a       	cp.w	r10,r8
8000ada4:	5e 0c       	reteq	r12
8000ada6:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000adaa:	f8 08 0b 09 	st.b	r12[r8],r9
8000adae:	2f f8       	sub	r8,-1
8000adb0:	58 09       	cp.w	r9,0
8000adb2:	cf 81       	brne	8000ada2 <strncpy+0x2>
8000adb4:	10 3a       	cp.w	r10,r8
8000adb6:	5e 0c       	reteq	r12
8000adb8:	f8 08 0b 09 	st.b	r12[r8],r9
8000adbc:	2f f8       	sub	r8,-1
8000adbe:	cf bb       	rjmp	8000adb4 <strncpy+0x14>

8000adc0 <strtok>:
8000adc0:	d4 21       	pushm	r4-r7,lr
8000adc2:	20 1d       	sub	sp,4
8000adc4:	e0 65 0a 38 	mov	r5,2616
8000adc8:	18 97       	mov	r7,r12
8000adca:	6a 04       	ld.w	r4,r5[0x0]
8000adcc:	e8 f6 00 e8 	ld.w	r6,r4[232]
8000add0:	58 06       	cp.w	r6,0
8000add2:	c3 51       	brne	8000ae3c <strtok+0x7c>
8000add4:	50 0b       	stdsp	sp[0x0],r11
8000add6:	35 0c       	mov	r12,80
8000add8:	fe b0 fb 60 	rcall	8000a498 <malloc>
8000addc:	6a 08       	ld.w	r8,r5[0x0]
8000adde:	e9 4c 00 e8 	st.w	r4[232],r12
8000ade2:	f0 f9 00 e8 	ld.w	r9,r8[232]
8000ade6:	93 26       	st.w	r9[0x8],r6
8000ade8:	93 06       	st.w	r9[0x0],r6
8000adea:	93 16       	st.w	r9[0x4],r6
8000adec:	f0 f9 00 e8 	ld.w	r9,r8[232]
8000adf0:	93 46       	st.w	r9[0x10],r6
8000adf2:	93 36       	st.w	r9[0xc],r6
8000adf4:	f0 f9 00 e8 	ld.w	r9,r8[232]
8000adf8:	93 66       	st.w	r9[0x18],r6
8000adfa:	93 56       	st.w	r9[0x14],r6
8000adfc:	f0 f9 00 e8 	ld.w	r9,r8[232]
8000ae00:	93 b6       	st.w	r9[0x2c],r6
8000ae02:	93 a6       	st.w	r9[0x28],r6
8000ae04:	f0 f9 00 e8 	ld.w	r9,r8[232]
8000ae08:	93 d6       	st.w	r9[0x34],r6
8000ae0a:	93 c6       	st.w	r9[0x30],r6
8000ae0c:	f0 f9 00 e8 	ld.w	r9,r8[232]
8000ae10:	93 f6       	st.w	r9[0x3c],r6
8000ae12:	93 e6       	st.w	r9[0x38],r6
8000ae14:	f0 f9 00 e8 	ld.w	r9,r8[232]
8000ae18:	f3 46 00 44 	st.w	r9[68],r6
8000ae1c:	f3 46 00 40 	st.w	r9[64],r6
8000ae20:	f0 f9 00 e8 	ld.w	r9,r8[232]
8000ae24:	f3 46 00 4c 	st.w	r9[76],r6
8000ae28:	f3 46 00 48 	st.w	r9[72],r6
8000ae2c:	f0 f9 00 e8 	ld.w	r9,r8[232]
8000ae30:	f3 66 00 1c 	st.b	r9[28],r6
8000ae34:	f0 f8 00 e8 	ld.w	r8,r8[232]
8000ae38:	40 0b       	lddsp	r11,sp[0x0]
8000ae3a:	91 96       	st.w	r8[0x24],r6
8000ae3c:	e0 68 0a 38 	mov	r8,2616
8000ae40:	70 08       	ld.w	r8,r8[0x0]
8000ae42:	0e 9c       	mov	r12,r7
8000ae44:	f0 fa 00 e8 	ld.w	r10,r8[232]
8000ae48:	30 19       	mov	r9,1
8000ae4a:	c0 3c       	rcall	8000ae50 <__strtok_r>
8000ae4c:	2f fd       	sub	sp,-4
8000ae4e:	d8 22       	popm	r4-r7,pc

8000ae50 <__strtok_r>:
8000ae50:	d4 21       	pushm	r4-r7,lr
8000ae52:	58 0c       	cp.w	r12,0
8000ae54:	c0 41       	brne	8000ae5c <__strtok_r+0xc>
8000ae56:	74 0c       	ld.w	r12,r10[0x0]
8000ae58:	58 0c       	cp.w	r12,0
8000ae5a:	c2 90       	breq	8000aeac <__strtok_r+0x5c>
8000ae5c:	18 98       	mov	r8,r12
8000ae5e:	16 97       	mov	r7,r11
8000ae60:	11 3e       	ld.ub	lr,r8++
8000ae62:	c0 a8       	rjmp	8000ae76 <__strtok_r+0x26>
8000ae64:	0c 3e       	cp.w	lr,r6
8000ae66:	c0 81       	brne	8000ae76 <__strtok_r+0x26>
8000ae68:	58 09       	cp.w	r9,0
8000ae6a:	c0 30       	breq	8000ae70 <__strtok_r+0x20>
8000ae6c:	10 9c       	mov	r12,r8
8000ae6e:	cf 7b       	rjmp	8000ae5c <__strtok_r+0xc>
8000ae70:	95 08       	st.w	r10[0x0],r8
8000ae72:	b8 89       	st.b	r12[0x0],r9
8000ae74:	d8 22       	popm	r4-r7,pc
8000ae76:	0f 36       	ld.ub	r6,r7++
8000ae78:	58 06       	cp.w	r6,0
8000ae7a:	cf 51       	brne	8000ae64 <__strtok_r+0x14>
8000ae7c:	58 0e       	cp.w	lr,0
8000ae7e:	c0 51       	brne	8000ae88 <__strtok_r+0x38>
8000ae80:	95 0e       	st.w	r10[0x0],lr
8000ae82:	1c 9c       	mov	r12,lr
8000ae84:	d8 22       	popm	r4-r7,pc
8000ae86:	12 98       	mov	r8,r9
8000ae88:	10 99       	mov	r9,r8
8000ae8a:	16 97       	mov	r7,r11
8000ae8c:	13 3e       	ld.ub	lr,r9++
8000ae8e:	0f 36       	ld.ub	r6,r7++
8000ae90:	1c 36       	cp.w	r6,lr
8000ae92:	c0 a1       	brne	8000aea6 <__strtok_r+0x56>
8000ae94:	58 0e       	cp.w	lr,0
8000ae96:	fc 09 17 00 	moveq	r9,lr
8000ae9a:	f9 bb 01 00 	movne	r11,0
8000ae9e:	f1 fb 1e 00 	st.bne	r8[0x0],r11
8000aea2:	95 09       	st.w	r10[0x0],r9
8000aea4:	d8 22       	popm	r4-r7,pc
8000aea6:	58 06       	cp.w	r6,0
8000aea8:	cf 31       	brne	8000ae8e <__strtok_r+0x3e>
8000aeaa:	ce eb       	rjmp	8000ae86 <__strtok_r+0x36>
8000aeac:	d8 22       	popm	r4-r7,pc
8000aeae:	d7 03       	nop

8000aeb0 <_close>:
8000aeb0:	30 28       	mov	r8,2
8000aeb2:	d6 73       	breakpoint
8000aeb4:	3f fc       	mov	r12,-1
8000aeb6:	35 8b       	mov	r11,88
8000aeb8:	58 0c       	cp.w	r12,0
8000aeba:	5e 4c       	retge	r12
8000aebc:	e0 6a 46 a8 	mov	r10,18088
8000aec0:	95 0b       	st.w	r10[0x0],r11
8000aec2:	5e fc       	retal	r12

8000aec4 <_lseek>:
8000aec4:	30 58       	mov	r8,5
8000aec6:	d6 73       	breakpoint
8000aec8:	3f fc       	mov	r12,-1
8000aeca:	35 8b       	mov	r11,88
8000aecc:	58 0c       	cp.w	r12,0
8000aece:	5e 4c       	retge	r12
8000aed0:	e0 6a 46 a8 	mov	r10,18088
8000aed4:	95 0b       	st.w	r10[0x0],r11
8000aed6:	5e fc       	retal	r12

8000aed8 <isatty>:
8000aed8:	30 b8       	mov	r8,11
8000aeda:	d6 73       	breakpoint
8000aedc:	3f fc       	mov	r12,-1
8000aede:	35 8b       	mov	r11,88
8000aee0:	58 0c       	cp.w	r12,0
8000aee2:	5e 4c       	retge	r12
8000aee4:	e0 6a 46 a8 	mov	r10,18088
8000aee8:	95 0b       	st.w	r10[0x0],r11
8000aeea:	5e fc       	retal	r12

8000aeec <_fstat_host>:
8000aeec:	30 98       	mov	r8,9
8000aeee:	d6 73       	breakpoint
8000aef0:	3f fc       	mov	r12,-1
8000aef2:	35 8b       	mov	r11,88
8000aef4:	58 0c       	cp.w	r12,0
8000aef6:	5e 4c       	retge	r12
8000aef8:	e0 6a 46 a8 	mov	r10,18088
8000aefc:	95 0b       	st.w	r10[0x0],r11
8000aefe:	5e fc       	retal	r12

8000af00 <_fstat>:
8000af00:	d4 21       	pushm	r4-r7,lr
8000af02:	21 0d       	sub	sp,64
8000af04:	16 97       	mov	r7,r11
8000af06:	1a 9b       	mov	r11,sp
8000af08:	cf 2f       	rcall	8000aeec <_fstat_host>
8000af0a:	c0 34       	brge	8000af10 <_fstat+0x10>
8000af0c:	3f fc       	mov	r12,-1
8000af0e:	c1 c8       	rjmp	8000af46 <_fstat+0x46>
8000af10:	40 08       	lddsp	r8,sp[0x0]
8000af12:	ae 08       	st.h	r7[0x0],r8
8000af14:	40 18       	lddsp	r8,sp[0x4]
8000af16:	ae 18       	st.h	r7[0x2],r8
8000af18:	40 28       	lddsp	r8,sp[0x8]
8000af1a:	8f 18       	st.w	r7[0x4],r8
8000af1c:	40 38       	lddsp	r8,sp[0xc]
8000af1e:	ae 48       	st.h	r7[0x8],r8
8000af20:	40 48       	lddsp	r8,sp[0x10]
8000af22:	ae 58       	st.h	r7[0xa],r8
8000af24:	40 58       	lddsp	r8,sp[0x14]
8000af26:	ae 68       	st.h	r7[0xc],r8
8000af28:	40 68       	lddsp	r8,sp[0x18]
8000af2a:	ae 78       	st.h	r7[0xe],r8
8000af2c:	40 88       	lddsp	r8,sp[0x20]
8000af2e:	8f 48       	st.w	r7[0x10],r8
8000af30:	40 a8       	lddsp	r8,sp[0x28]
8000af32:	8f b8       	st.w	r7[0x2c],r8
8000af34:	40 c8       	lddsp	r8,sp[0x30]
8000af36:	8f c8       	st.w	r7[0x30],r8
8000af38:	40 d8       	lddsp	r8,sp[0x34]
8000af3a:	8f 58       	st.w	r7[0x14],r8
8000af3c:	40 e8       	lddsp	r8,sp[0x38]
8000af3e:	30 0c       	mov	r12,0
8000af40:	8f 78       	st.w	r7[0x1c],r8
8000af42:	40 f8       	lddsp	r8,sp[0x3c]
8000af44:	8f 98       	st.w	r7[0x24],r8
8000af46:	2f 0d       	sub	sp,-64
8000af48:	d8 22       	popm	r4-r7,pc
8000af4a:	d7 03       	nop

8000af4c <_sbrk>:
8000af4c:	d4 01       	pushm	lr
8000af4e:	e0 68 13 48 	mov	r8,4936
8000af52:	70 09       	ld.w	r9,r8[0x0]
8000af54:	58 09       	cp.w	r9,0
8000af56:	c0 41       	brne	8000af5e <_sbrk+0x12>
8000af58:	e0 69 46 b0 	mov	r9,18096
8000af5c:	91 09       	st.w	r8[0x0],r9
8000af5e:	e0 69 13 48 	mov	r9,4936
8000af62:	e0 7a 70 00 	mov	r10,94208
8000af66:	72 08       	ld.w	r8,r9[0x0]
8000af68:	f0 0c 00 0c 	add	r12,r8,r12
8000af6c:	14 3c       	cp.w	r12,r10
8000af6e:	e0 8b 00 04 	brhi	8000af76 <_sbrk+0x2a>
8000af72:	93 0c       	st.w	r9[0x0],r12
8000af74:	c0 68       	rjmp	8000af80 <_sbrk+0x34>
8000af76:	e0 a0 18 2b 	rcall	8000dfcc <__errno>
8000af7a:	30 c8       	mov	r8,12
8000af7c:	99 08       	st.w	r12[0x0],r8
8000af7e:	3f f8       	mov	r8,-1
8000af80:	10 9c       	mov	r12,r8
8000af82:	d8 02       	popm	pc

8000af84 <get_arg>:
8000af84:	d4 31       	pushm	r0-r7,lr
8000af86:	20 8d       	sub	sp,32
8000af88:	fa c4 ff bc 	sub	r4,sp,-68
8000af8c:	50 4b       	stdsp	sp[0x10],r11
8000af8e:	68 2e       	ld.w	lr,r4[0x8]
8000af90:	50 58       	stdsp	sp[0x14],r8
8000af92:	12 96       	mov	r6,r9
8000af94:	7c 0b       	ld.w	r11,lr[0x0]
8000af96:	70 05       	ld.w	r5,r8[0x0]
8000af98:	50 6e       	stdsp	sp[0x18],lr
8000af9a:	58 0b       	cp.w	r11,0
8000af9c:	f4 0b 17 00 	moveq	r11,r10
8000afa0:	68 03       	ld.w	r3,r4[0x0]
8000afa2:	68 11       	ld.w	r1,r4[0x4]
8000afa4:	40 49       	lddsp	r9,sp[0x10]
8000afa6:	30 08       	mov	r8,0
8000afa8:	c2 e9       	rjmp	8000b204 <get_arg+0x280>
8000afaa:	2f fb       	sub	r11,-1
8000afac:	32 5c       	mov	r12,37
8000afae:	17 8a       	ld.ub	r10,r11[0x0]
8000afb0:	f8 0a 18 00 	cp.b	r10,r12
8000afb4:	5f 1e       	srne	lr
8000afb6:	f0 0a 18 00 	cp.b	r10,r8
8000afba:	5f 1c       	srne	r12
8000afbc:	fd ec 00 0c 	and	r12,lr,r12
8000afc0:	f0 0c 18 00 	cp.b	r12,r8
8000afc4:	cf 31       	brne	8000afaa <get_arg+0x26>
8000afc6:	58 0a       	cp.w	r10,0
8000afc8:	e0 80 01 2b 	breq	8000b21e <get_arg+0x29a>
8000afcc:	30 0c       	mov	r12,0
8000afce:	3f fa       	mov	r10,-1
8000afd0:	18 90       	mov	r0,r12
8000afd2:	50 3a       	stdsp	sp[0xc],r10
8000afd4:	18 94       	mov	r4,r12
8000afd6:	18 92       	mov	r2,r12
8000afd8:	f8 0c 00 3c 	add	r12,r12,r12<<0x3
8000afdc:	16 97       	mov	r7,r11
8000afde:	50 7c       	stdsp	sp[0x1c],r12
8000afe0:	4c ec       	lddpc	r12,8000b118 <get_arg+0x194>
8000afe2:	0f 3a       	ld.ub	r10,r7++
8000afe4:	f8 0a 07 0e 	ld.ub	lr,r12[r10]
8000afe8:	40 7c       	lddsp	r12,sp[0x1c]
8000afea:	1c 0c       	add	r12,lr
8000afec:	4c ce       	lddpc	lr,8000b11c <get_arg+0x198>
8000afee:	fc 0c 07 0e 	ld.ub	lr,lr[r12]
8000aff2:	20 1e       	sub	lr,1
8000aff4:	50 0e       	stdsp	sp[0x0],lr
8000aff6:	4c be       	lddpc	lr,8000b120 <get_arg+0x19c>
8000aff8:	fc 0c 07 0c 	ld.ub	r12,lr[r12]
8000affc:	50 7c       	stdsp	sp[0x1c],r12
8000affe:	40 0c       	lddsp	r12,sp[0x0]
8000b000:	58 7c       	cp.w	r12,7
8000b002:	e0 8b 00 fa 	brhi	8000b1f6 <get_arg+0x272>
8000b006:	4c 8e       	lddpc	lr,8000b124 <get_arg+0x1a0>
8000b008:	fc 0c 03 2f 	ld.w	pc,lr[r12<<0x2]
8000b00c:	36 8b       	mov	r11,104
8000b00e:	f6 0a 18 00 	cp.b	r10,r11
8000b012:	e0 80 00 f2 	breq	8000b1f6 <get_arg+0x272>
8000b016:	37 1b       	mov	r11,113
8000b018:	f6 0a 18 00 	cp.b	r10,r11
8000b01c:	c0 70       	breq	8000b02a <get_arg+0xa6>
8000b01e:	34 cb       	mov	r11,76
8000b020:	f6 0a 18 00 	cp.b	r10,r11
8000b024:	c0 51       	brne	8000b02e <get_arg+0xaa>
8000b026:	a3 b4       	sbr	r4,0x3
8000b028:	ce 78       	rjmp	8000b1f6 <get_arg+0x272>
8000b02a:	a5 b4       	sbr	r4,0x5
8000b02c:	ce 58       	rjmp	8000b1f6 <get_arg+0x272>
8000b02e:	08 9a       	mov	r10,r4
8000b030:	0e 9b       	mov	r11,r7
8000b032:	a5 aa       	sbr	r10,0x4
8000b034:	17 3c       	ld.ub	r12,r11++
8000b036:	a5 b4       	sbr	r4,0x5
8000b038:	36 ce       	mov	lr,108
8000b03a:	fc 0c 18 00 	cp.b	r12,lr
8000b03e:	e0 80 00 dd 	breq	8000b1f8 <get_arg+0x274>
8000b042:	14 94       	mov	r4,r10
8000b044:	cd 98       	rjmp	8000b1f6 <get_arg+0x272>
8000b046:	eb d5 c0 05 	bfextu	r5,r5,0x0,0x5
8000b04a:	36 7c       	mov	r12,103
8000b04c:	f8 0a 18 00 	cp.b	r10,r12
8000b050:	e0 8b 00 27 	brhi	8000b09e <get_arg+0x11a>
8000b054:	36 5b       	mov	r11,101
8000b056:	f6 0a 18 00 	cp.b	r10,r11
8000b05a:	c4 82       	brcc	8000b0ea <get_arg+0x166>
8000b05c:	34 fb       	mov	r11,79
8000b05e:	f6 0a 18 00 	cp.b	r10,r11
8000b062:	c4 80       	breq	8000b0f2 <get_arg+0x16e>
8000b064:	e0 8b 00 0c 	brhi	8000b07c <get_arg+0xf8>
8000b068:	34 5b       	mov	r11,69
8000b06a:	f6 0a 18 00 	cp.b	r10,r11
8000b06e:	c3 e0       	breq	8000b0ea <get_arg+0x166>
8000b070:	34 7b       	mov	r11,71
8000b072:	f6 0a 18 00 	cp.b	r10,r11
8000b076:	c3 a0       	breq	8000b0ea <get_arg+0x166>
8000b078:	34 4b       	mov	r11,68
8000b07a:	c0 88       	rjmp	8000b08a <get_arg+0x106>
8000b07c:	35 8b       	mov	r11,88
8000b07e:	f6 0a 18 00 	cp.b	r10,r11
8000b082:	c2 c0       	breq	8000b0da <get_arg+0x156>
8000b084:	e0 8b 00 07 	brhi	8000b092 <get_arg+0x10e>
8000b088:	35 5b       	mov	r11,85
8000b08a:	f6 0a 18 00 	cp.b	r10,r11
8000b08e:	c3 51       	brne	8000b0f8 <get_arg+0x174>
8000b090:	c3 18       	rjmp	8000b0f2 <get_arg+0x16e>
8000b092:	36 3b       	mov	r11,99
8000b094:	f6 0a 18 00 	cp.b	r10,r11
8000b098:	c2 f0       	breq	8000b0f6 <get_arg+0x172>
8000b09a:	36 4b       	mov	r11,100
8000b09c:	c0 e8       	rjmp	8000b0b8 <get_arg+0x134>
8000b09e:	37 0b       	mov	r11,112
8000b0a0:	f6 0a 18 00 	cp.b	r10,r11
8000b0a4:	c2 50       	breq	8000b0ee <get_arg+0x16a>
8000b0a6:	e0 8b 00 0d 	brhi	8000b0c0 <get_arg+0x13c>
8000b0aa:	36 eb       	mov	r11,110
8000b0ac:	f6 0a 18 00 	cp.b	r10,r11
8000b0b0:	c1 f0       	breq	8000b0ee <get_arg+0x16a>
8000b0b2:	e0 8b 00 14 	brhi	8000b0da <get_arg+0x156>
8000b0b6:	36 9b       	mov	r11,105
8000b0b8:	f6 0a 18 00 	cp.b	r10,r11
8000b0bc:	c1 e1       	brne	8000b0f8 <get_arg+0x174>
8000b0be:	c0 e8       	rjmp	8000b0da <get_arg+0x156>
8000b0c0:	37 5b       	mov	r11,117
8000b0c2:	f6 0a 18 00 	cp.b	r10,r11
8000b0c6:	c0 a0       	breq	8000b0da <get_arg+0x156>
8000b0c8:	37 8b       	mov	r11,120
8000b0ca:	f6 0a 18 00 	cp.b	r10,r11
8000b0ce:	c0 60       	breq	8000b0da <get_arg+0x156>
8000b0d0:	37 3b       	mov	r11,115
8000b0d2:	f6 0a 18 00 	cp.b	r10,r11
8000b0d6:	c1 11       	brne	8000b0f8 <get_arg+0x174>
8000b0d8:	c0 b8       	rjmp	8000b0ee <get_arg+0x16a>
8000b0da:	ed b4 00 04 	bld	r4,0x4
8000b0de:	c0 a0       	breq	8000b0f2 <get_arg+0x16e>
8000b0e0:	ed b4 00 05 	bld	r4,0x5
8000b0e4:	c0 91       	brne	8000b0f6 <get_arg+0x172>
8000b0e6:	30 20       	mov	r0,2
8000b0e8:	c0 88       	rjmp	8000b0f8 <get_arg+0x174>
8000b0ea:	30 40       	mov	r0,4
8000b0ec:	c0 68       	rjmp	8000b0f8 <get_arg+0x174>
8000b0ee:	30 30       	mov	r0,3
8000b0f0:	c0 48       	rjmp	8000b0f8 <get_arg+0x174>
8000b0f2:	30 10       	mov	r0,1
8000b0f4:	c0 28       	rjmp	8000b0f8 <get_arg+0x174>
8000b0f6:	30 00       	mov	r0,0
8000b0f8:	40 3b       	lddsp	r11,sp[0xc]
8000b0fa:	5b fb       	cp.w	r11,-1
8000b0fc:	c0 40       	breq	8000b104 <get_arg+0x180>
8000b0fe:	e2 0b 09 20 	st.w	r1[r11<<0x2],r0
8000b102:	c7 a8       	rjmp	8000b1f6 <get_arg+0x272>
8000b104:	58 60       	cp.w	r0,6
8000b106:	e0 8b 00 78 	brhi	8000b1f6 <get_arg+0x272>
8000b10a:	6c 0a       	ld.w	r10,r6[0x0]
8000b10c:	ea cc ff ff 	sub	r12,r5,-1
8000b110:	48 6e       	lddpc	lr,8000b128 <get_arg+0x1a4>
8000b112:	fc 00 03 2f 	ld.w	pc,lr[r0<<0x2]
8000b116:	d7 03       	nop
8000b118:	80 01       	ld.sh	r1,r0[0x0]
8000b11a:	95 d8       	st.w	r10[0x34],r8
8000b11c:	80 01       	ld.sh	r1,r0[0x0]
8000b11e:	95 10       	st.w	r10[0x4],r0
8000b120:	80 01       	ld.sh	r1,r0[0x0]
8000b122:	94 a4       	ld.uh	r4,r10[0x4]
8000b124:	80 01       	ld.sh	r1,r0[0x0]
8000b126:	93 04       	st.w	r9[0x0],r4
8000b128:	80 01       	ld.sh	r1,r0[0x0]
8000b12a:	93 24       	st.w	r9[0x8],r4
8000b12c:	f4 cb ff f8 	sub	r11,r10,-8
8000b130:	8d 0b       	st.w	r6[0x0],r11
8000b132:	f4 ea 00 00 	ld.d	r10,r10[0]
8000b136:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
8000b13a:	c0 f8       	rjmp	8000b158 <get_arg+0x1d4>
8000b13c:	f4 cb ff fc 	sub	r11,r10,-4
8000b140:	8d 0b       	st.w	r6[0x0],r11
8000b142:	74 0a       	ld.w	r10,r10[0x0]
8000b144:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
8000b148:	c0 88       	rjmp	8000b158 <get_arg+0x1d4>
8000b14a:	f4 cb ff f8 	sub	r11,r10,-8
8000b14e:	8d 0b       	st.w	r6[0x0],r11
8000b150:	f4 ea 00 00 	ld.d	r10,r10[0]
8000b154:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
8000b158:	0e 9b       	mov	r11,r7
8000b15a:	18 95       	mov	r5,r12
8000b15c:	c4 e8       	rjmp	8000b1f8 <get_arg+0x274>
8000b15e:	62 0a       	ld.w	r10,r1[0x0]
8000b160:	5b fa       	cp.w	r10,-1
8000b162:	c0 b1       	brne	8000b178 <get_arg+0x1f4>
8000b164:	50 19       	stdsp	sp[0x4],r9
8000b166:	50 28       	stdsp	sp[0x8],r8
8000b168:	e0 6a 00 80 	mov	r10,128
8000b16c:	30 0b       	mov	r11,0
8000b16e:	02 9c       	mov	r12,r1
8000b170:	fe b0 fc 6f 	rcall	8000aa4e <memset>
8000b174:	40 28       	lddsp	r8,sp[0x8]
8000b176:	40 19       	lddsp	r9,sp[0x4]
8000b178:	e4 cc 00 01 	sub	r12,r2,1
8000b17c:	0e 9b       	mov	r11,r7
8000b17e:	50 3c       	stdsp	sp[0xc],r12
8000b180:	f2 0c 0c 49 	max	r9,r9,r12
8000b184:	c3 a8       	rjmp	8000b1f8 <get_arg+0x274>
8000b186:	62 0a       	ld.w	r10,r1[0x0]
8000b188:	5b fa       	cp.w	r10,-1
8000b18a:	c0 b1       	brne	8000b1a0 <get_arg+0x21c>
8000b18c:	50 19       	stdsp	sp[0x4],r9
8000b18e:	50 28       	stdsp	sp[0x8],r8
8000b190:	e0 6a 00 80 	mov	r10,128
8000b194:	30 0b       	mov	r11,0
8000b196:	02 9c       	mov	r12,r1
8000b198:	fe b0 fc 5b 	rcall	8000aa4e <memset>
8000b19c:	40 28       	lddsp	r8,sp[0x8]
8000b19e:	40 19       	lddsp	r9,sp[0x4]
8000b1a0:	20 12       	sub	r2,1
8000b1a2:	30 0a       	mov	r10,0
8000b1a4:	0e 9b       	mov	r11,r7
8000b1a6:	e2 02 09 2a 	st.w	r1[r2<<0x2],r10
8000b1aa:	f2 02 0c 49 	max	r9,r9,r2
8000b1ae:	c2 58       	rjmp	8000b1f8 <get_arg+0x274>
8000b1b0:	16 97       	mov	r7,r11
8000b1b2:	6c 0a       	ld.w	r10,r6[0x0]
8000b1b4:	f4 cb ff fc 	sub	r11,r10,-4
8000b1b8:	8d 0b       	st.w	r6[0x0],r11
8000b1ba:	74 0a       	ld.w	r10,r10[0x0]
8000b1bc:	0e 9b       	mov	r11,r7
8000b1be:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
8000b1c2:	2f f5       	sub	r5,-1
8000b1c4:	c1 a8       	rjmp	8000b1f8 <get_arg+0x274>
8000b1c6:	f4 c2 00 30 	sub	r2,r10,48
8000b1ca:	c0 68       	rjmp	8000b1d6 <get_arg+0x252>
8000b1cc:	e4 02 00 22 	add	r2,r2,r2<<0x2
8000b1d0:	2f f7       	sub	r7,-1
8000b1d2:	f4 02 00 12 	add	r2,r10,r2<<0x1
8000b1d6:	0f 8a       	ld.ub	r10,r7[0x0]
8000b1d8:	58 0a       	cp.w	r10,0
8000b1da:	c0 e0       	breq	8000b1f6 <get_arg+0x272>
8000b1dc:	23 0a       	sub	r10,48
8000b1de:	58 9a       	cp.w	r10,9
8000b1e0:	fe 98 ff f6 	brls	8000b1cc <get_arg+0x248>
8000b1e4:	c0 98       	rjmp	8000b1f6 <get_arg+0x272>
8000b1e6:	2f f7       	sub	r7,-1
8000b1e8:	0f 8a       	ld.ub	r10,r7[0x0]
8000b1ea:	58 0a       	cp.w	r10,0
8000b1ec:	c0 50       	breq	8000b1f6 <get_arg+0x272>
8000b1ee:	23 0a       	sub	r10,48
8000b1f0:	58 9a       	cp.w	r10,9
8000b1f2:	fe 98 ff fa 	brls	8000b1e6 <get_arg+0x262>
8000b1f6:	0e 9b       	mov	r11,r7
8000b1f8:	40 7c       	lddsp	r12,sp[0x1c]
8000b1fa:	30 ba       	mov	r10,11
8000b1fc:	f4 0c 18 00 	cp.b	r12,r10
8000b200:	fe 91 fe ec 	brne	8000afd8 <get_arg+0x54>
8000b204:	40 42       	lddsp	r2,sp[0x10]
8000b206:	17 8c       	ld.ub	r12,r11[0x0]
8000b208:	0a 32       	cp.w	r2,r5
8000b20a:	5f 4a       	srge	r10
8000b20c:	f0 0c 18 00 	cp.b	r12,r8
8000b210:	5f 1c       	srne	r12
8000b212:	f9 ea 00 0a 	and	r10,r12,r10
8000b216:	f0 0a 18 00 	cp.b	r10,r8
8000b21a:	fe 91 fe c9 	brne	8000afac <get_arg+0x28>
8000b21e:	30 08       	mov	r8,0
8000b220:	40 4e       	lddsp	lr,sp[0x10]
8000b222:	17 8a       	ld.ub	r10,r11[0x0]
8000b224:	e2 05 00 21 	add	r1,r1,r5<<0x2
8000b228:	f0 0a 18 00 	cp.b	r10,r8
8000b22c:	fc 09 17 10 	movne	r9,lr
8000b230:	e6 05 00 38 	add	r8,r3,r5<<0x3
8000b234:	06 9e       	mov	lr,r3
8000b236:	c2 a8       	rjmp	8000b28a <get_arg+0x306>
8000b238:	62 0a       	ld.w	r10,r1[0x0]
8000b23a:	58 3a       	cp.w	r10,3
8000b23c:	c1 e0       	breq	8000b278 <get_arg+0x2f4>
8000b23e:	e0 89 00 07 	brgt	8000b24c <get_arg+0x2c8>
8000b242:	58 1a       	cp.w	r10,1
8000b244:	c1 a0       	breq	8000b278 <get_arg+0x2f4>
8000b246:	58 2a       	cp.w	r10,2
8000b248:	c1 81       	brne	8000b278 <get_arg+0x2f4>
8000b24a:	c0 58       	rjmp	8000b254 <get_arg+0x2d0>
8000b24c:	58 5a       	cp.w	r10,5
8000b24e:	c0 c0       	breq	8000b266 <get_arg+0x2e2>
8000b250:	c0 b5       	brlt	8000b266 <get_arg+0x2e2>
8000b252:	c1 38       	rjmp	8000b278 <get_arg+0x2f4>
8000b254:	6c 0a       	ld.w	r10,r6[0x0]
8000b256:	f4 cc ff f8 	sub	r12,r10,-8
8000b25a:	8d 0c       	st.w	r6[0x0],r12
8000b25c:	f4 e2 00 00 	ld.d	r2,r10[0]
8000b260:	f0 e3 00 00 	st.d	r8[0],r2
8000b264:	c1 08       	rjmp	8000b284 <get_arg+0x300>
8000b266:	6c 0a       	ld.w	r10,r6[0x0]
8000b268:	f4 cc ff f8 	sub	r12,r10,-8
8000b26c:	8d 0c       	st.w	r6[0x0],r12
8000b26e:	f4 e2 00 00 	ld.d	r2,r10[0]
8000b272:	f0 e3 00 00 	st.d	r8[0],r2
8000b276:	c0 78       	rjmp	8000b284 <get_arg+0x300>
8000b278:	6c 0a       	ld.w	r10,r6[0x0]
8000b27a:	f4 cc ff fc 	sub	r12,r10,-4
8000b27e:	8d 0c       	st.w	r6[0x0],r12
8000b280:	74 0a       	ld.w	r10,r10[0x0]
8000b282:	91 0a       	st.w	r8[0x0],r10
8000b284:	2f f5       	sub	r5,-1
8000b286:	2f 88       	sub	r8,-8
8000b288:	2f c1       	sub	r1,-4
8000b28a:	12 35       	cp.w	r5,r9
8000b28c:	fe 9a ff d6 	brle	8000b238 <get_arg+0x2b4>
8000b290:	1c 93       	mov	r3,lr
8000b292:	40 52       	lddsp	r2,sp[0x14]
8000b294:	40 6e       	lddsp	lr,sp[0x18]
8000b296:	85 05       	st.w	r2[0x0],r5
8000b298:	9d 0b       	st.w	lr[0x0],r11
8000b29a:	40 4b       	lddsp	r11,sp[0x10]
8000b29c:	e6 0b 00 3c 	add	r12,r3,r11<<0x3
8000b2a0:	2f 8d       	sub	sp,-32
8000b2a2:	d8 32       	popm	r0-r7,pc

8000b2a4 <__sprint_r>:
8000b2a4:	d4 21       	pushm	r4-r7,lr
8000b2a6:	14 97       	mov	r7,r10
8000b2a8:	74 28       	ld.w	r8,r10[0x8]
8000b2aa:	58 08       	cp.w	r8,0
8000b2ac:	c0 41       	brne	8000b2b4 <__sprint_r+0x10>
8000b2ae:	95 18       	st.w	r10[0x4],r8
8000b2b0:	10 9c       	mov	r12,r8
8000b2b2:	d8 22       	popm	r4-r7,pc
8000b2b4:	e0 a0 18 ce 	rcall	8000e450 <__sfvwrite_r>
8000b2b8:	30 08       	mov	r8,0
8000b2ba:	8f 18       	st.w	r7[0x4],r8
8000b2bc:	8f 28       	st.w	r7[0x8],r8
8000b2be:	d8 22       	popm	r4-r7,pc

8000b2c0 <_vfprintf_r>:
8000b2c0:	d4 31       	pushm	r0-r7,lr
8000b2c2:	fa cd 06 bc 	sub	sp,sp,1724
8000b2c6:	51 09       	stdsp	sp[0x40],r9
8000b2c8:	16 91       	mov	r1,r11
8000b2ca:	14 97       	mov	r7,r10
8000b2cc:	18 95       	mov	r5,r12
8000b2ce:	e0 a0 1a 31 	rcall	8000e730 <_localeconv_r>
8000b2d2:	78 0c       	ld.w	r12,r12[0x0]
8000b2d4:	50 cc       	stdsp	sp[0x30],r12
8000b2d6:	58 05       	cp.w	r5,0
8000b2d8:	c0 70       	breq	8000b2e6 <_vfprintf_r+0x26>
8000b2da:	6a 68       	ld.w	r8,r5[0x18]
8000b2dc:	58 08       	cp.w	r8,0
8000b2de:	c0 41       	brne	8000b2e6 <_vfprintf_r+0x26>
8000b2e0:	0a 9c       	mov	r12,r5
8000b2e2:	e0 a0 17 57 	rcall	8000e190 <__sinit>
8000b2e6:	4d 08       	lddpc	r8,8000b424 <_vfprintf_r+0x164>
8000b2e8:	10 31       	cp.w	r1,r8
8000b2ea:	c0 31       	brne	8000b2f0 <_vfprintf_r+0x30>
8000b2ec:	6a 01       	ld.w	r1,r5[0x0]
8000b2ee:	c0 a8       	rjmp	8000b302 <_vfprintf_r+0x42>
8000b2f0:	4c e8       	lddpc	r8,8000b428 <_vfprintf_r+0x168>
8000b2f2:	10 31       	cp.w	r1,r8
8000b2f4:	c0 31       	brne	8000b2fa <_vfprintf_r+0x3a>
8000b2f6:	6a 11       	ld.w	r1,r5[0x4]
8000b2f8:	c0 58       	rjmp	8000b302 <_vfprintf_r+0x42>
8000b2fa:	4c d8       	lddpc	r8,8000b42c <_vfprintf_r+0x16c>
8000b2fc:	10 31       	cp.w	r1,r8
8000b2fe:	eb f1 00 02 	ld.weq	r1,r5[0x8]
8000b302:	82 68       	ld.sh	r8,r1[0xc]
8000b304:	ed b8 00 03 	bld	r8,0x3
8000b308:	c0 41       	brne	8000b310 <_vfprintf_r+0x50>
8000b30a:	62 48       	ld.w	r8,r1[0x10]
8000b30c:	58 08       	cp.w	r8,0
8000b30e:	c0 71       	brne	8000b31c <_vfprintf_r+0x5c>
8000b310:	02 9b       	mov	r11,r1
8000b312:	0a 9c       	mov	r12,r5
8000b314:	e0 a0 0f 6c 	rcall	8000d1ec <__swsetup_r>
8000b318:	e0 81 0f 63 	brne	8000d1de <_vfprintf_r+0x1f1e>
8000b31c:	82 68       	ld.sh	r8,r1[0xc]
8000b31e:	10 99       	mov	r9,r8
8000b320:	e2 19 00 1a 	andl	r9,0x1a,COH
8000b324:	58 a9       	cp.w	r9,10
8000b326:	c3 c1       	brne	8000b39e <_vfprintf_r+0xde>
8000b328:	82 79       	ld.sh	r9,r1[0xe]
8000b32a:	30 0a       	mov	r10,0
8000b32c:	f4 09 19 00 	cp.h	r9,r10
8000b330:	c3 75       	brlt	8000b39e <_vfprintf_r+0xde>
8000b332:	a1 d8       	cbr	r8,0x1
8000b334:	fb 58 05 d0 	st.h	sp[1488],r8
8000b338:	62 88       	ld.w	r8,r1[0x20]
8000b33a:	fb 48 05 e4 	st.w	sp[1508],r8
8000b33e:	62 a8       	ld.w	r8,r1[0x28]
8000b340:	fb 48 05 ec 	st.w	sp[1516],r8
8000b344:	fa c8 ff bc 	sub	r8,sp,-68
8000b348:	fb 48 05 d4 	st.w	sp[1492],r8
8000b34c:	fb 48 05 c4 	st.w	sp[1476],r8
8000b350:	e0 68 04 00 	mov	r8,1024
8000b354:	fb 48 05 d8 	st.w	sp[1496],r8
8000b358:	fb 48 05 cc 	st.w	sp[1484],r8
8000b35c:	30 08       	mov	r8,0
8000b35e:	fb 59 05 d2 	st.h	sp[1490],r9
8000b362:	0e 9a       	mov	r10,r7
8000b364:	41 09       	lddsp	r9,sp[0x40]
8000b366:	fa c7 fa 3c 	sub	r7,sp,-1476
8000b36a:	fb 48 05 dc 	st.w	sp[1500],r8
8000b36e:	0a 9c       	mov	r12,r5
8000b370:	0e 9b       	mov	r11,r7
8000b372:	ca 7f       	rcall	8000b2c0 <_vfprintf_r>
8000b374:	50 bc       	stdsp	sp[0x2c],r12
8000b376:	c0 95       	brlt	8000b388 <_vfprintf_r+0xc8>
8000b378:	0e 9b       	mov	r11,r7
8000b37a:	0a 9c       	mov	r12,r5
8000b37c:	e0 a0 16 2e 	rcall	8000dfd8 <_fflush_r>
8000b380:	40 be       	lddsp	lr,sp[0x2c]
8000b382:	f9 be 01 ff 	movne	lr,-1
8000b386:	50 be       	stdsp	sp[0x2c],lr
8000b388:	fb 08 05 d0 	ld.sh	r8,sp[1488]
8000b38c:	ed b8 00 06 	bld	r8,0x6
8000b390:	e0 81 0f 29 	brne	8000d1e2 <_vfprintf_r+0x1f22>
8000b394:	82 68       	ld.sh	r8,r1[0xc]
8000b396:	a7 a8       	sbr	r8,0x6
8000b398:	a2 68       	st.h	r1[0xc],r8
8000b39a:	e0 8f 0f 24 	bral	8000d1e2 <_vfprintf_r+0x1f22>
8000b39e:	30 08       	mov	r8,0
8000b3a0:	fb 48 06 b4 	st.w	sp[1716],r8
8000b3a4:	fb 48 06 90 	st.w	sp[1680],r8
8000b3a8:	fb 48 06 8c 	st.w	sp[1676],r8
8000b3ac:	fb 48 06 b0 	st.w	sp[1712],r8
8000b3b0:	30 08       	mov	r8,0
8000b3b2:	30 09       	mov	r9,0
8000b3b4:	50 a7       	stdsp	sp[0x28],r7
8000b3b6:	50 78       	stdsp	sp[0x1c],r8
8000b3b8:	fa c3 f9 e0 	sub	r3,sp,-1568
8000b3bc:	3f f8       	mov	r8,-1
8000b3be:	50 59       	stdsp	sp[0x14],r9
8000b3c0:	fb 43 06 88 	st.w	sp[1672],r3
8000b3c4:	fb 48 05 44 	st.w	sp[1348],r8
8000b3c8:	12 9c       	mov	r12,r9
8000b3ca:	50 69       	stdsp	sp[0x18],r9
8000b3cc:	50 d9       	stdsp	sp[0x34],r9
8000b3ce:	50 e9       	stdsp	sp[0x38],r9
8000b3d0:	50 b9       	stdsp	sp[0x2c],r9
8000b3d2:	12 97       	mov	r7,r9
8000b3d4:	0a 94       	mov	r4,r5
8000b3d6:	40 a2       	lddsp	r2,sp[0x28]
8000b3d8:	32 5a       	mov	r10,37
8000b3da:	30 08       	mov	r8,0
8000b3dc:	c0 28       	rjmp	8000b3e0 <_vfprintf_r+0x120>
8000b3de:	2f f2       	sub	r2,-1
8000b3e0:	05 89       	ld.ub	r9,r2[0x0]
8000b3e2:	f0 09 18 00 	cp.b	r9,r8
8000b3e6:	5f 1b       	srne	r11
8000b3e8:	f4 09 18 00 	cp.b	r9,r10
8000b3ec:	5f 19       	srne	r9
8000b3ee:	f3 eb 00 0b 	and	r11,r9,r11
8000b3f2:	f0 0b 18 00 	cp.b	r11,r8
8000b3f6:	cf 41       	brne	8000b3de <_vfprintf_r+0x11e>
8000b3f8:	40 ab       	lddsp	r11,sp[0x28]
8000b3fa:	e4 0b 01 06 	sub	r6,r2,r11
8000b3fe:	c2 50       	breq	8000b448 <_vfprintf_r+0x188>
8000b400:	fa f8 06 90 	ld.w	r8,sp[1680]
8000b404:	0c 08       	add	r8,r6
8000b406:	87 0b       	st.w	r3[0x0],r11
8000b408:	fb 48 06 90 	st.w	sp[1680],r8
8000b40c:	87 16       	st.w	r3[0x4],r6
8000b40e:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000b412:	2f f8       	sub	r8,-1
8000b414:	fb 48 06 8c 	st.w	sp[1676],r8
8000b418:	58 78       	cp.w	r8,7
8000b41a:	e0 89 00 0b 	brgt	8000b430 <_vfprintf_r+0x170>
8000b41e:	2f 83       	sub	r3,-8
8000b420:	c1 18       	rjmp	8000b442 <_vfprintf_r+0x182>
8000b422:	d7 03       	nop
8000b424:	80 01       	ld.sh	r1,r0[0x0]
8000b426:	96 e8       	ld.uh	r8,r11[0xc]
8000b428:	80 01       	ld.sh	r1,r0[0x0]
8000b42a:	97 08       	st.w	r11[0x0],r8
8000b42c:	80 01       	ld.sh	r1,r0[0x0]
8000b42e:	97 28       	st.w	r11[0x8],r8
8000b430:	fa ca f9 78 	sub	r10,sp,-1672
8000b434:	02 9b       	mov	r11,r1
8000b436:	08 9c       	mov	r12,r4
8000b438:	c3 6f       	rcall	8000b2a4 <__sprint_r>
8000b43a:	e0 81 0e ce 	brne	8000d1d6 <_vfprintf_r+0x1f16>
8000b43e:	fa c3 f9 e0 	sub	r3,sp,-1568
8000b442:	40 ba       	lddsp	r10,sp[0x2c]
8000b444:	0c 0a       	add	r10,r6
8000b446:	50 ba       	stdsp	sp[0x2c],r10
8000b448:	05 89       	ld.ub	r9,r2[0x0]
8000b44a:	30 08       	mov	r8,0
8000b44c:	f0 09 18 00 	cp.b	r9,r8
8000b450:	e0 80 0e b2 	breq	8000d1b4 <_vfprintf_r+0x1ef4>
8000b454:	30 09       	mov	r9,0
8000b456:	fb 68 06 bb 	st.b	sp[1723],r8
8000b45a:	0e 96       	mov	r6,r7
8000b45c:	e4 c8 ff ff 	sub	r8,r2,-1
8000b460:	3f fe       	mov	lr,-1
8000b462:	50 93       	stdsp	sp[0x24],r3
8000b464:	50 41       	stdsp	sp[0x10],r1
8000b466:	0e 93       	mov	r3,r7
8000b468:	04 91       	mov	r1,r2
8000b46a:	50 89       	stdsp	sp[0x20],r9
8000b46c:	50 a8       	stdsp	sp[0x28],r8
8000b46e:	50 2e       	stdsp	sp[0x8],lr
8000b470:	50 39       	stdsp	sp[0xc],r9
8000b472:	12 95       	mov	r5,r9
8000b474:	12 90       	mov	r0,r9
8000b476:	10 97       	mov	r7,r8
8000b478:	08 92       	mov	r2,r4
8000b47a:	c0 78       	rjmp	8000b488 <_vfprintf_r+0x1c8>
8000b47c:	3f fc       	mov	r12,-1
8000b47e:	08 97       	mov	r7,r4
8000b480:	50 2c       	stdsp	sp[0x8],r12
8000b482:	c0 38       	rjmp	8000b488 <_vfprintf_r+0x1c8>
8000b484:	30 0b       	mov	r11,0
8000b486:	50 3b       	stdsp	sp[0xc],r11
8000b488:	0f 38       	ld.ub	r8,r7++
8000b48a:	c0 28       	rjmp	8000b48e <_vfprintf_r+0x1ce>
8000b48c:	12 90       	mov	r0,r9
8000b48e:	f0 c9 00 20 	sub	r9,r8,32
8000b492:	e0 49 00 58 	cp.w	r9,88
8000b496:	e0 8b 0a 36 	brhi	8000c902 <_vfprintf_r+0x1642>
8000b49a:	4d 9a       	lddpc	r10,8000b5fc <_vfprintf_r+0x33c>
8000b49c:	f4 09 03 2f 	ld.w	pc,r10[r9<<0x2]
8000b4a0:	50 a7       	stdsp	sp[0x28],r7
8000b4a2:	50 80       	stdsp	sp[0x20],r0
8000b4a4:	0c 97       	mov	r7,r6
8000b4a6:	04 94       	mov	r4,r2
8000b4a8:	06 96       	mov	r6,r3
8000b4aa:	02 92       	mov	r2,r1
8000b4ac:	4d 59       	lddpc	r9,8000b600 <_vfprintf_r+0x340>
8000b4ae:	40 93       	lddsp	r3,sp[0x24]
8000b4b0:	10 90       	mov	r0,r8
8000b4b2:	40 41       	lddsp	r1,sp[0x10]
8000b4b4:	50 d9       	stdsp	sp[0x34],r9
8000b4b6:	e0 8f 08 95 	bral	8000c5e0 <_vfprintf_r+0x1320>
8000b4ba:	30 08       	mov	r8,0
8000b4bc:	fb 39 06 bb 	ld.ub	r9,sp[1723]
8000b4c0:	f0 09 18 00 	cp.b	r9,r8
8000b4c4:	ce 21       	brne	8000b488 <_vfprintf_r+0x1c8>
8000b4c6:	32 08       	mov	r8,32
8000b4c8:	c6 e8       	rjmp	8000b5a4 <_vfprintf_r+0x2e4>
8000b4ca:	a1 a5       	sbr	r5,0x0
8000b4cc:	cd eb       	rjmp	8000b488 <_vfprintf_r+0x1c8>
8000b4ce:	0f 89       	ld.ub	r9,r7[0x0]
8000b4d0:	f2 c8 00 30 	sub	r8,r9,48
8000b4d4:	58 98       	cp.w	r8,9
8000b4d6:	e0 8b 00 1d 	brhi	8000b510 <_vfprintf_r+0x250>
8000b4da:	ee c8 ff ff 	sub	r8,r7,-1
8000b4de:	30 0b       	mov	r11,0
8000b4e0:	23 09       	sub	r9,48
8000b4e2:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
8000b4e6:	f2 0b 00 1b 	add	r11,r9,r11<<0x1
8000b4ea:	11 39       	ld.ub	r9,r8++
8000b4ec:	f2 ca 00 30 	sub	r10,r9,48
8000b4f0:	58 9a       	cp.w	r10,9
8000b4f2:	fe 98 ff f7 	brls	8000b4e0 <_vfprintf_r+0x220>
8000b4f6:	e0 49 00 24 	cp.w	r9,36
8000b4fa:	cc 51       	brne	8000b484 <_vfprintf_r+0x1c4>
8000b4fc:	e0 4b 00 20 	cp.w	r11,32
8000b500:	e0 89 0e 6a 	brgt	8000d1d4 <_vfprintf_r+0x1f14>
8000b504:	20 1b       	sub	r11,1
8000b506:	fa f9 06 b4 	ld.w	r9,sp[1716]
8000b50a:	12 3b       	cp.w	r11,r9
8000b50c:	c0 95       	brlt	8000b51e <_vfprintf_r+0x25e>
8000b50e:	c1 08       	rjmp	8000b52e <_vfprintf_r+0x26e>
8000b510:	fa f9 06 b4 	ld.w	r9,sp[1716]
8000b514:	ec ca ff ff 	sub	r10,r6,-1
8000b518:	12 36       	cp.w	r6,r9
8000b51a:	c1 f5       	brlt	8000b558 <_vfprintf_r+0x298>
8000b51c:	c2 68       	rjmp	8000b568 <_vfprintf_r+0x2a8>
8000b51e:	fa ce f9 44 	sub	lr,sp,-1724
8000b522:	10 97       	mov	r7,r8
8000b524:	fc 0b 00 3b 	add	r11,lr,r11<<0x3
8000b528:	f6 f0 fd 88 	ld.w	r0,r11[-632]
8000b52c:	c3 58       	rjmp	8000b596 <_vfprintf_r+0x2d6>
8000b52e:	10 97       	mov	r7,r8
8000b530:	fa c8 f9 50 	sub	r8,sp,-1712
8000b534:	1a d8       	st.w	--sp,r8
8000b536:	fa c8 fa b8 	sub	r8,sp,-1352
8000b53a:	1a d8       	st.w	--sp,r8
8000b53c:	fa c8 fb b4 	sub	r8,sp,-1100
8000b540:	02 9a       	mov	r10,r1
8000b542:	1a d8       	st.w	--sp,r8
8000b544:	04 9c       	mov	r12,r2
8000b546:	fa c8 f9 40 	sub	r8,sp,-1728
8000b54a:	fa c9 ff b4 	sub	r9,sp,-76
8000b54e:	fe b0 fd 1b 	rcall	8000af84 <get_arg>
8000b552:	2f dd       	sub	sp,-12
8000b554:	78 00       	ld.w	r0,r12[0x0]
8000b556:	c2 08       	rjmp	8000b596 <_vfprintf_r+0x2d6>
8000b558:	fa cc f9 44 	sub	r12,sp,-1724
8000b55c:	14 96       	mov	r6,r10
8000b55e:	f8 03 00 38 	add	r8,r12,r3<<0x3
8000b562:	f0 f0 fd 88 	ld.w	r0,r8[-632]
8000b566:	c1 88       	rjmp	8000b596 <_vfprintf_r+0x2d6>
8000b568:	41 08       	lddsp	r8,sp[0x40]
8000b56a:	59 f9       	cp.w	r9,31
8000b56c:	e0 89 00 11 	brgt	8000b58e <_vfprintf_r+0x2ce>
8000b570:	f0 cb ff fc 	sub	r11,r8,-4
8000b574:	51 0b       	stdsp	sp[0x40],r11
8000b576:	70 00       	ld.w	r0,r8[0x0]
8000b578:	fa cb f9 44 	sub	r11,sp,-1724
8000b57c:	f6 09 00 38 	add	r8,r11,r9<<0x3
8000b580:	f1 40 fd 88 	st.w	r8[-632],r0
8000b584:	2f f9       	sub	r9,-1
8000b586:	14 96       	mov	r6,r10
8000b588:	fb 49 06 b4 	st.w	sp[1716],r9
8000b58c:	c0 58       	rjmp	8000b596 <_vfprintf_r+0x2d6>
8000b58e:	70 00       	ld.w	r0,r8[0x0]
8000b590:	14 96       	mov	r6,r10
8000b592:	2f c8       	sub	r8,-4
8000b594:	51 08       	stdsp	sp[0x40],r8
8000b596:	58 00       	cp.w	r0,0
8000b598:	fe 94 ff 78 	brge	8000b488 <_vfprintf_r+0x1c8>
8000b59c:	5c 30       	neg	r0
8000b59e:	a3 a5       	sbr	r5,0x2
8000b5a0:	c7 4b       	rjmp	8000b488 <_vfprintf_r+0x1c8>
8000b5a2:	32 b8       	mov	r8,43
8000b5a4:	fb 68 06 bb 	st.b	sp[1723],r8
8000b5a8:	c7 0b       	rjmp	8000b488 <_vfprintf_r+0x1c8>
8000b5aa:	0f 38       	ld.ub	r8,r7++
8000b5ac:	e0 48 00 2a 	cp.w	r8,42
8000b5b0:	c0 30       	breq	8000b5b6 <_vfprintf_r+0x2f6>
8000b5b2:	30 09       	mov	r9,0
8000b5b4:	c7 d8       	rjmp	8000b6ae <_vfprintf_r+0x3ee>
8000b5b6:	0f 88       	ld.ub	r8,r7[0x0]
8000b5b8:	f0 c9 00 30 	sub	r9,r8,48
8000b5bc:	58 99       	cp.w	r9,9
8000b5be:	e0 8b 00 23 	brhi	8000b604 <_vfprintf_r+0x344>
8000b5c2:	ee c4 ff ff 	sub	r4,r7,-1
8000b5c6:	30 0b       	mov	r11,0
8000b5c8:	23 08       	sub	r8,48
8000b5ca:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
8000b5ce:	f0 0b 00 1b 	add	r11,r8,r11<<0x1
8000b5d2:	09 38       	ld.ub	r8,r4++
8000b5d4:	f0 c9 00 30 	sub	r9,r8,48
8000b5d8:	58 99       	cp.w	r9,9
8000b5da:	fe 98 ff f7 	brls	8000b5c8 <_vfprintf_r+0x308>
8000b5de:	e0 48 00 24 	cp.w	r8,36
8000b5e2:	fe 91 ff 51 	brne	8000b484 <_vfprintf_r+0x1c4>
8000b5e6:	e0 4b 00 20 	cp.w	r11,32
8000b5ea:	e0 89 0d f5 	brgt	8000d1d4 <_vfprintf_r+0x1f14>
8000b5ee:	20 1b       	sub	r11,1
8000b5f0:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000b5f4:	10 3b       	cp.w	r11,r8
8000b5f6:	c0 e5       	brlt	8000b612 <_vfprintf_r+0x352>
8000b5f8:	c1 58       	rjmp	8000b622 <_vfprintf_r+0x362>
8000b5fa:	d7 03       	nop
8000b5fc:	80 01       	ld.sh	r1,r0[0x0]
8000b5fe:	93 40       	st.w	r9[0x10],r0
8000b600:	80 01       	ld.sh	r1,r0[0x0]
8000b602:	95 7c       	st.w	r10[0x1c],r12
8000b604:	fa fa 06 b4 	ld.w	r10,sp[1716]
8000b608:	ec c9 ff ff 	sub	r9,r6,-1
8000b60c:	14 36       	cp.w	r6,r10
8000b60e:	c1 f5       	brlt	8000b64c <_vfprintf_r+0x38c>
8000b610:	c2 88       	rjmp	8000b660 <_vfprintf_r+0x3a0>
8000b612:	fa ca f9 44 	sub	r10,sp,-1724
8000b616:	f4 0b 00 3b 	add	r11,r10,r11<<0x3
8000b61a:	f6 fb fd 88 	ld.w	r11,r11[-632]
8000b61e:	50 2b       	stdsp	sp[0x8],r11
8000b620:	c3 c8       	rjmp	8000b698 <_vfprintf_r+0x3d8>
8000b622:	fa c8 f9 50 	sub	r8,sp,-1712
8000b626:	1a d8       	st.w	--sp,r8
8000b628:	fa c8 fa b8 	sub	r8,sp,-1352
8000b62c:	1a d8       	st.w	--sp,r8
8000b62e:	fa c8 fb b4 	sub	r8,sp,-1100
8000b632:	02 9a       	mov	r10,r1
8000b634:	1a d8       	st.w	--sp,r8
8000b636:	04 9c       	mov	r12,r2
8000b638:	fa c8 f9 40 	sub	r8,sp,-1728
8000b63c:	fa c9 ff b4 	sub	r9,sp,-76
8000b640:	fe b0 fc a2 	rcall	8000af84 <get_arg>
8000b644:	2f dd       	sub	sp,-12
8000b646:	78 0c       	ld.w	r12,r12[0x0]
8000b648:	50 2c       	stdsp	sp[0x8],r12
8000b64a:	c2 78       	rjmp	8000b698 <_vfprintf_r+0x3d8>
8000b64c:	12 96       	mov	r6,r9
8000b64e:	0e 94       	mov	r4,r7
8000b650:	fa c9 f9 44 	sub	r9,sp,-1724
8000b654:	f2 03 00 38 	add	r8,r9,r3<<0x3
8000b658:	f0 f8 fd 88 	ld.w	r8,r8[-632]
8000b65c:	50 28       	stdsp	sp[0x8],r8
8000b65e:	c1 d8       	rjmp	8000b698 <_vfprintf_r+0x3d8>
8000b660:	41 08       	lddsp	r8,sp[0x40]
8000b662:	59 fa       	cp.w	r10,31
8000b664:	e0 89 00 14 	brgt	8000b68c <_vfprintf_r+0x3cc>
8000b668:	f0 cb ff fc 	sub	r11,r8,-4
8000b66c:	70 08       	ld.w	r8,r8[0x0]
8000b66e:	51 0b       	stdsp	sp[0x40],r11
8000b670:	50 28       	stdsp	sp[0x8],r8
8000b672:	fa c6 f9 44 	sub	r6,sp,-1724
8000b676:	40 2e       	lddsp	lr,sp[0x8]
8000b678:	ec 0a 00 38 	add	r8,r6,r10<<0x3
8000b67c:	f1 4e fd 88 	st.w	r8[-632],lr
8000b680:	2f fa       	sub	r10,-1
8000b682:	0e 94       	mov	r4,r7
8000b684:	fb 4a 06 b4 	st.w	sp[1716],r10
8000b688:	12 96       	mov	r6,r9
8000b68a:	c0 78       	rjmp	8000b698 <_vfprintf_r+0x3d8>
8000b68c:	70 0c       	ld.w	r12,r8[0x0]
8000b68e:	0e 94       	mov	r4,r7
8000b690:	2f c8       	sub	r8,-4
8000b692:	50 2c       	stdsp	sp[0x8],r12
8000b694:	12 96       	mov	r6,r9
8000b696:	51 08       	stdsp	sp[0x40],r8
8000b698:	40 2b       	lddsp	r11,sp[0x8]
8000b69a:	58 0b       	cp.w	r11,0
8000b69c:	fe 95 fe f0 	brlt	8000b47c <_vfprintf_r+0x1bc>
8000b6a0:	08 97       	mov	r7,r4
8000b6a2:	cf 3a       	rjmp	8000b488 <_vfprintf_r+0x1c8>
8000b6a4:	f2 09 00 29 	add	r9,r9,r9<<0x2
8000b6a8:	0f 38       	ld.ub	r8,r7++
8000b6aa:	f4 09 00 19 	add	r9,r10,r9<<0x1
8000b6ae:	f0 ca 00 30 	sub	r10,r8,48
8000b6b2:	58 9a       	cp.w	r10,9
8000b6b4:	fe 98 ff f8 	brls	8000b6a4 <_vfprintf_r+0x3e4>
8000b6b8:	3f fa       	mov	r10,-1
8000b6ba:	f2 0a 0c 49 	max	r9,r9,r10
8000b6be:	50 29       	stdsp	sp[0x8],r9
8000b6c0:	ce 7a       	rjmp	8000b48e <_vfprintf_r+0x1ce>
8000b6c2:	a7 b5       	sbr	r5,0x7
8000b6c4:	ce 2a       	rjmp	8000b488 <_vfprintf_r+0x1c8>
8000b6c6:	30 09       	mov	r9,0
8000b6c8:	23 08       	sub	r8,48
8000b6ca:	f2 09 00 29 	add	r9,r9,r9<<0x2
8000b6ce:	f0 09 00 19 	add	r9,r8,r9<<0x1
8000b6d2:	0f 38       	ld.ub	r8,r7++
8000b6d4:	f0 ca 00 30 	sub	r10,r8,48
8000b6d8:	58 9a       	cp.w	r10,9
8000b6da:	fe 98 ff f7 	brls	8000b6c8 <_vfprintf_r+0x408>
8000b6de:	e0 48 00 24 	cp.w	r8,36
8000b6e2:	fe 91 fe d5 	brne	8000b48c <_vfprintf_r+0x1cc>
8000b6e6:	e0 49 00 20 	cp.w	r9,32
8000b6ea:	e0 89 0d 75 	brgt	8000d1d4 <_vfprintf_r+0x1f14>
8000b6ee:	f2 c3 00 01 	sub	r3,r9,1
8000b6f2:	30 19       	mov	r9,1
8000b6f4:	50 39       	stdsp	sp[0xc],r9
8000b6f6:	cc 9a       	rjmp	8000b488 <_vfprintf_r+0x1c8>
8000b6f8:	a3 b5       	sbr	r5,0x3
8000b6fa:	cc 7a       	rjmp	8000b488 <_vfprintf_r+0x1c8>
8000b6fc:	a7 a5       	sbr	r5,0x6
8000b6fe:	cc 5a       	rjmp	8000b488 <_vfprintf_r+0x1c8>
8000b700:	0a 98       	mov	r8,r5
8000b702:	a5 b5       	sbr	r5,0x5
8000b704:	a5 a8       	sbr	r8,0x4
8000b706:	0f 89       	ld.ub	r9,r7[0x0]
8000b708:	36 ce       	mov	lr,108
8000b70a:	fc 09 18 00 	cp.b	r9,lr
8000b70e:	f7 b7 00 ff 	subeq	r7,-1
8000b712:	f0 05 17 10 	movne	r5,r8
8000b716:	cb 9a       	rjmp	8000b488 <_vfprintf_r+0x1c8>
8000b718:	a5 b5       	sbr	r5,0x5
8000b71a:	cb 7a       	rjmp	8000b488 <_vfprintf_r+0x1c8>
8000b71c:	50 a7       	stdsp	sp[0x28],r7
8000b71e:	50 80       	stdsp	sp[0x20],r0
8000b720:	0c 97       	mov	r7,r6
8000b722:	10 90       	mov	r0,r8
8000b724:	06 96       	mov	r6,r3
8000b726:	04 94       	mov	r4,r2
8000b728:	40 93       	lddsp	r3,sp[0x24]
8000b72a:	02 92       	mov	r2,r1
8000b72c:	0e 99       	mov	r9,r7
8000b72e:	40 41       	lddsp	r1,sp[0x10]
8000b730:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000b734:	40 3c       	lddsp	r12,sp[0xc]
8000b736:	58 0c       	cp.w	r12,0
8000b738:	c1 d0       	breq	8000b772 <_vfprintf_r+0x4b2>
8000b73a:	10 36       	cp.w	r6,r8
8000b73c:	c0 64       	brge	8000b748 <_vfprintf_r+0x488>
8000b73e:	fa cb f9 44 	sub	r11,sp,-1724
8000b742:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000b746:	c1 d8       	rjmp	8000b780 <_vfprintf_r+0x4c0>
8000b748:	fa c8 f9 50 	sub	r8,sp,-1712
8000b74c:	1a d8       	st.w	--sp,r8
8000b74e:	fa c8 fa b8 	sub	r8,sp,-1352
8000b752:	1a d8       	st.w	--sp,r8
8000b754:	fa c8 fb b4 	sub	r8,sp,-1100
8000b758:	1a d8       	st.w	--sp,r8
8000b75a:	fa c8 f9 40 	sub	r8,sp,-1728
8000b75e:	fa c9 ff b4 	sub	r9,sp,-76
8000b762:	04 9a       	mov	r10,r2
8000b764:	0c 9b       	mov	r11,r6
8000b766:	08 9c       	mov	r12,r4
8000b768:	fe b0 fc 0e 	rcall	8000af84 <get_arg>
8000b76c:	2f dd       	sub	sp,-12
8000b76e:	19 b8       	ld.ub	r8,r12[0x3]
8000b770:	c2 28       	rjmp	8000b7b4 <_vfprintf_r+0x4f4>
8000b772:	2f f7       	sub	r7,-1
8000b774:	10 39       	cp.w	r9,r8
8000b776:	c0 84       	brge	8000b786 <_vfprintf_r+0x4c6>
8000b778:	fa ca f9 44 	sub	r10,sp,-1724
8000b77c:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000b780:	ed 38 fd 8b 	ld.ub	r8,r6[-629]
8000b784:	c1 88       	rjmp	8000b7b4 <_vfprintf_r+0x4f4>
8000b786:	41 09       	lddsp	r9,sp[0x40]
8000b788:	59 f8       	cp.w	r8,31
8000b78a:	e0 89 00 12 	brgt	8000b7ae <_vfprintf_r+0x4ee>
8000b78e:	f2 ca ff fc 	sub	r10,r9,-4
8000b792:	51 0a       	stdsp	sp[0x40],r10
8000b794:	72 09       	ld.w	r9,r9[0x0]
8000b796:	fa c6 f9 44 	sub	r6,sp,-1724
8000b79a:	ec 08 00 3a 	add	r10,r6,r8<<0x3
8000b79e:	2f f8       	sub	r8,-1
8000b7a0:	f5 49 fd 88 	st.w	r10[-632],r9
8000b7a4:	fb 48 06 b4 	st.w	sp[1716],r8
8000b7a8:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
8000b7ac:	c0 48       	rjmp	8000b7b4 <_vfprintf_r+0x4f4>
8000b7ae:	13 b8       	ld.ub	r8,r9[0x3]
8000b7b0:	2f c9       	sub	r9,-4
8000b7b2:	51 09       	stdsp	sp[0x40],r9
8000b7b4:	fb 68 06 60 	st.b	sp[1632],r8
8000b7b8:	30 0e       	mov	lr,0
8000b7ba:	30 08       	mov	r8,0
8000b7bc:	30 12       	mov	r2,1
8000b7be:	fb 68 06 bb 	st.b	sp[1723],r8
8000b7c2:	50 2e       	stdsp	sp[0x8],lr
8000b7c4:	e0 8f 08 b1 	bral	8000c926 <_vfprintf_r+0x1666>
8000b7c8:	50 a7       	stdsp	sp[0x28],r7
8000b7ca:	50 80       	stdsp	sp[0x20],r0
8000b7cc:	0c 97       	mov	r7,r6
8000b7ce:	04 94       	mov	r4,r2
8000b7d0:	06 96       	mov	r6,r3
8000b7d2:	02 92       	mov	r2,r1
8000b7d4:	40 93       	lddsp	r3,sp[0x24]
8000b7d6:	10 90       	mov	r0,r8
8000b7d8:	40 41       	lddsp	r1,sp[0x10]
8000b7da:	a5 a5       	sbr	r5,0x4
8000b7dc:	c0 a8       	rjmp	8000b7f0 <_vfprintf_r+0x530>
8000b7de:	50 a7       	stdsp	sp[0x28],r7
8000b7e0:	50 80       	stdsp	sp[0x20],r0
8000b7e2:	0c 97       	mov	r7,r6
8000b7e4:	04 94       	mov	r4,r2
8000b7e6:	06 96       	mov	r6,r3
8000b7e8:	02 92       	mov	r2,r1
8000b7ea:	40 93       	lddsp	r3,sp[0x24]
8000b7ec:	10 90       	mov	r0,r8
8000b7ee:	40 41       	lddsp	r1,sp[0x10]
8000b7f0:	ed b5 00 05 	bld	r5,0x5
8000b7f4:	c5 11       	brne	8000b896 <_vfprintf_r+0x5d6>
8000b7f6:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000b7fa:	40 3c       	lddsp	r12,sp[0xc]
8000b7fc:	58 0c       	cp.w	r12,0
8000b7fe:	c1 e0       	breq	8000b83a <_vfprintf_r+0x57a>
8000b800:	10 36       	cp.w	r6,r8
8000b802:	c0 64       	brge	8000b80e <_vfprintf_r+0x54e>
8000b804:	fa cb f9 44 	sub	r11,sp,-1724
8000b808:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000b80c:	c2 08       	rjmp	8000b84c <_vfprintf_r+0x58c>
8000b80e:	fa c8 f9 50 	sub	r8,sp,-1712
8000b812:	1a d8       	st.w	--sp,r8
8000b814:	fa c8 fa b8 	sub	r8,sp,-1352
8000b818:	0c 9b       	mov	r11,r6
8000b81a:	1a d8       	st.w	--sp,r8
8000b81c:	fa c8 fb b4 	sub	r8,sp,-1100
8000b820:	1a d8       	st.w	--sp,r8
8000b822:	fa c9 ff b4 	sub	r9,sp,-76
8000b826:	fa c8 f9 40 	sub	r8,sp,-1728
8000b82a:	04 9a       	mov	r10,r2
8000b82c:	08 9c       	mov	r12,r4
8000b82e:	fe b0 fb ab 	rcall	8000af84 <get_arg>
8000b832:	2f dd       	sub	sp,-12
8000b834:	78 1b       	ld.w	r11,r12[0x4]
8000b836:	78 09       	ld.w	r9,r12[0x0]
8000b838:	c2 b8       	rjmp	8000b88e <_vfprintf_r+0x5ce>
8000b83a:	ee ca ff ff 	sub	r10,r7,-1
8000b83e:	10 37       	cp.w	r7,r8
8000b840:	c0 b4       	brge	8000b856 <_vfprintf_r+0x596>
8000b842:	fa c9 f9 44 	sub	r9,sp,-1724
8000b846:	14 97       	mov	r7,r10
8000b848:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000b84c:	ec fb fd 8c 	ld.w	r11,r6[-628]
8000b850:	ec f9 fd 88 	ld.w	r9,r6[-632]
8000b854:	c1 d8       	rjmp	8000b88e <_vfprintf_r+0x5ce>
8000b856:	41 09       	lddsp	r9,sp[0x40]
8000b858:	59 f8       	cp.w	r8,31
8000b85a:	e0 89 00 14 	brgt	8000b882 <_vfprintf_r+0x5c2>
8000b85e:	f2 cb ff f8 	sub	r11,r9,-8
8000b862:	51 0b       	stdsp	sp[0x40],r11
8000b864:	fa c6 f9 44 	sub	r6,sp,-1724
8000b868:	72 1b       	ld.w	r11,r9[0x4]
8000b86a:	ec 08 00 3c 	add	r12,r6,r8<<0x3
8000b86e:	72 09       	ld.w	r9,r9[0x0]
8000b870:	f9 4b fd 8c 	st.w	r12[-628],r11
8000b874:	f9 49 fd 88 	st.w	r12[-632],r9
8000b878:	2f f8       	sub	r8,-1
8000b87a:	14 97       	mov	r7,r10
8000b87c:	fb 48 06 b4 	st.w	sp[1716],r8
8000b880:	c0 78       	rjmp	8000b88e <_vfprintf_r+0x5ce>
8000b882:	f2 c8 ff f8 	sub	r8,r9,-8
8000b886:	72 1b       	ld.w	r11,r9[0x4]
8000b888:	14 97       	mov	r7,r10
8000b88a:	51 08       	stdsp	sp[0x40],r8
8000b88c:	72 09       	ld.w	r9,r9[0x0]
8000b88e:	16 98       	mov	r8,r11
8000b890:	fa e9 00 00 	st.d	sp[0],r8
8000b894:	ca e8       	rjmp	8000b9f0 <_vfprintf_r+0x730>
8000b896:	ed b5 00 04 	bld	r5,0x4
8000b89a:	c1 71       	brne	8000b8c8 <_vfprintf_r+0x608>
8000b89c:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000b8a0:	40 3e       	lddsp	lr,sp[0xc]
8000b8a2:	58 0e       	cp.w	lr,0
8000b8a4:	c0 80       	breq	8000b8b4 <_vfprintf_r+0x5f4>
8000b8a6:	10 36       	cp.w	r6,r8
8000b8a8:	c6 94       	brge	8000b97a <_vfprintf_r+0x6ba>
8000b8aa:	fa cc f9 44 	sub	r12,sp,-1724
8000b8ae:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000b8b2:	c8 28       	rjmp	8000b9b6 <_vfprintf_r+0x6f6>
8000b8b4:	ee ca ff ff 	sub	r10,r7,-1
8000b8b8:	10 37       	cp.w	r7,r8
8000b8ba:	e0 84 00 81 	brge	8000b9bc <_vfprintf_r+0x6fc>
8000b8be:	fa cb f9 44 	sub	r11,sp,-1724
8000b8c2:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000b8c6:	c7 78       	rjmp	8000b9b4 <_vfprintf_r+0x6f4>
8000b8c8:	ed b5 00 06 	bld	r5,0x6
8000b8cc:	c4 b1       	brne	8000b962 <_vfprintf_r+0x6a2>
8000b8ce:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000b8d2:	40 3c       	lddsp	r12,sp[0xc]
8000b8d4:	58 0c       	cp.w	r12,0
8000b8d6:	c1 d0       	breq	8000b910 <_vfprintf_r+0x650>
8000b8d8:	10 36       	cp.w	r6,r8
8000b8da:	c0 64       	brge	8000b8e6 <_vfprintf_r+0x626>
8000b8dc:	fa cb f9 44 	sub	r11,sp,-1724
8000b8e0:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000b8e4:	c1 f8       	rjmp	8000b922 <_vfprintf_r+0x662>
8000b8e6:	fa c8 f9 50 	sub	r8,sp,-1712
8000b8ea:	1a d8       	st.w	--sp,r8
8000b8ec:	fa c8 fa b8 	sub	r8,sp,-1352
8000b8f0:	1a d8       	st.w	--sp,r8
8000b8f2:	fa c8 fb b4 	sub	r8,sp,-1100
8000b8f6:	1a d8       	st.w	--sp,r8
8000b8f8:	fa c8 f9 40 	sub	r8,sp,-1728
8000b8fc:	fa c9 ff b4 	sub	r9,sp,-76
8000b900:	04 9a       	mov	r10,r2
8000b902:	0c 9b       	mov	r11,r6
8000b904:	08 9c       	mov	r12,r4
8000b906:	fe b0 fb 3f 	rcall	8000af84 <get_arg>
8000b90a:	2f dd       	sub	sp,-12
8000b90c:	98 18       	ld.sh	r8,r12[0x2]
8000b90e:	c2 68       	rjmp	8000b95a <_vfprintf_r+0x69a>
8000b910:	ee ca ff ff 	sub	r10,r7,-1
8000b914:	10 37       	cp.w	r7,r8
8000b916:	c0 94       	brge	8000b928 <_vfprintf_r+0x668>
8000b918:	fa c9 f9 44 	sub	r9,sp,-1724
8000b91c:	14 97       	mov	r7,r10
8000b91e:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000b922:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000b926:	c1 a8       	rjmp	8000b95a <_vfprintf_r+0x69a>
8000b928:	41 09       	lddsp	r9,sp[0x40]
8000b92a:	59 f8       	cp.w	r8,31
8000b92c:	e0 89 00 13 	brgt	8000b952 <_vfprintf_r+0x692>
8000b930:	f2 cb ff fc 	sub	r11,r9,-4
8000b934:	51 0b       	stdsp	sp[0x40],r11
8000b936:	72 09       	ld.w	r9,r9[0x0]
8000b938:	fa c6 f9 44 	sub	r6,sp,-1724
8000b93c:	ec 08 00 3b 	add	r11,r6,r8<<0x3
8000b940:	2f f8       	sub	r8,-1
8000b942:	f7 49 fd 88 	st.w	r11[-632],r9
8000b946:	fb 48 06 b4 	st.w	sp[1716],r8
8000b94a:	14 97       	mov	r7,r10
8000b94c:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
8000b950:	c0 58       	rjmp	8000b95a <_vfprintf_r+0x69a>
8000b952:	92 18       	ld.sh	r8,r9[0x2]
8000b954:	14 97       	mov	r7,r10
8000b956:	2f c9       	sub	r9,-4
8000b958:	51 09       	stdsp	sp[0x40],r9
8000b95a:	50 18       	stdsp	sp[0x4],r8
8000b95c:	bf 58       	asr	r8,0x1f
8000b95e:	50 08       	stdsp	sp[0x0],r8
8000b960:	c4 88       	rjmp	8000b9f0 <_vfprintf_r+0x730>
8000b962:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000b966:	40 3c       	lddsp	r12,sp[0xc]
8000b968:	58 0c       	cp.w	r12,0
8000b96a:	c1 d0       	breq	8000b9a4 <_vfprintf_r+0x6e4>
8000b96c:	10 36       	cp.w	r6,r8
8000b96e:	c0 64       	brge	8000b97a <_vfprintf_r+0x6ba>
8000b970:	fa cb f9 44 	sub	r11,sp,-1724
8000b974:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000b978:	c1 f8       	rjmp	8000b9b6 <_vfprintf_r+0x6f6>
8000b97a:	fa c8 f9 50 	sub	r8,sp,-1712
8000b97e:	1a d8       	st.w	--sp,r8
8000b980:	fa c8 fa b8 	sub	r8,sp,-1352
8000b984:	0c 9b       	mov	r11,r6
8000b986:	1a d8       	st.w	--sp,r8
8000b988:	fa c8 fb b4 	sub	r8,sp,-1100
8000b98c:	04 9a       	mov	r10,r2
8000b98e:	1a d8       	st.w	--sp,r8
8000b990:	08 9c       	mov	r12,r4
8000b992:	fa c8 f9 40 	sub	r8,sp,-1728
8000b996:	fa c9 ff b4 	sub	r9,sp,-76
8000b99a:	fe b0 fa f5 	rcall	8000af84 <get_arg>
8000b99e:	2f dd       	sub	sp,-12
8000b9a0:	78 0b       	ld.w	r11,r12[0x0]
8000b9a2:	c2 48       	rjmp	8000b9ea <_vfprintf_r+0x72a>
8000b9a4:	ee ca ff ff 	sub	r10,r7,-1
8000b9a8:	10 37       	cp.w	r7,r8
8000b9aa:	c0 94       	brge	8000b9bc <_vfprintf_r+0x6fc>
8000b9ac:	fa c9 f9 44 	sub	r9,sp,-1724
8000b9b0:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000b9b4:	14 97       	mov	r7,r10
8000b9b6:	ec fb fd 88 	ld.w	r11,r6[-632]
8000b9ba:	c1 88       	rjmp	8000b9ea <_vfprintf_r+0x72a>
8000b9bc:	41 09       	lddsp	r9,sp[0x40]
8000b9be:	59 f8       	cp.w	r8,31
8000b9c0:	e0 89 00 11 	brgt	8000b9e2 <_vfprintf_r+0x722>
8000b9c4:	f2 cb ff fc 	sub	r11,r9,-4
8000b9c8:	51 0b       	stdsp	sp[0x40],r11
8000b9ca:	fa c6 f9 44 	sub	r6,sp,-1724
8000b9ce:	72 0b       	ld.w	r11,r9[0x0]
8000b9d0:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000b9d4:	f3 4b fd 88 	st.w	r9[-632],r11
8000b9d8:	2f f8       	sub	r8,-1
8000b9da:	14 97       	mov	r7,r10
8000b9dc:	fb 48 06 b4 	st.w	sp[1716],r8
8000b9e0:	c0 58       	rjmp	8000b9ea <_vfprintf_r+0x72a>
8000b9e2:	72 0b       	ld.w	r11,r9[0x0]
8000b9e4:	14 97       	mov	r7,r10
8000b9e6:	2f c9       	sub	r9,-4
8000b9e8:	51 09       	stdsp	sp[0x40],r9
8000b9ea:	50 1b       	stdsp	sp[0x4],r11
8000b9ec:	bf 5b       	asr	r11,0x1f
8000b9ee:	50 0b       	stdsp	sp[0x0],r11
8000b9f0:	fa ea 00 00 	ld.d	r10,sp[0]
8000b9f4:	58 0a       	cp.w	r10,0
8000b9f6:	5c 2b       	cpc	r11
8000b9f8:	c0 e4       	brge	8000ba14 <_vfprintf_r+0x754>
8000b9fa:	30 08       	mov	r8,0
8000b9fc:	fa ea 00 00 	ld.d	r10,sp[0]
8000ba00:	30 09       	mov	r9,0
8000ba02:	f0 0a 01 0a 	sub	r10,r8,r10
8000ba06:	f2 0b 01 4b 	sbc	r11,r9,r11
8000ba0a:	32 d8       	mov	r8,45
8000ba0c:	fa eb 00 00 	st.d	sp[0],r10
8000ba10:	fb 68 06 bb 	st.b	sp[1723],r8
8000ba14:	30 18       	mov	r8,1
8000ba16:	e0 8f 06 fe 	bral	8000c812 <_vfprintf_r+0x1552>
8000ba1a:	50 a7       	stdsp	sp[0x28],r7
8000ba1c:	50 80       	stdsp	sp[0x20],r0
8000ba1e:	0c 97       	mov	r7,r6
8000ba20:	04 94       	mov	r4,r2
8000ba22:	06 96       	mov	r6,r3
8000ba24:	02 92       	mov	r2,r1
8000ba26:	40 93       	lddsp	r3,sp[0x24]
8000ba28:	10 90       	mov	r0,r8
8000ba2a:	40 41       	lddsp	r1,sp[0x10]
8000ba2c:	0e 99       	mov	r9,r7
8000ba2e:	ed b5 00 03 	bld	r5,0x3
8000ba32:	c4 11       	brne	8000bab4 <_vfprintf_r+0x7f4>
8000ba34:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000ba38:	40 3a       	lddsp	r10,sp[0xc]
8000ba3a:	58 0a       	cp.w	r10,0
8000ba3c:	c1 90       	breq	8000ba6e <_vfprintf_r+0x7ae>
8000ba3e:	10 36       	cp.w	r6,r8
8000ba40:	c6 45       	brlt	8000bb08 <_vfprintf_r+0x848>
8000ba42:	fa c8 f9 50 	sub	r8,sp,-1712
8000ba46:	1a d8       	st.w	--sp,r8
8000ba48:	fa c8 fa b8 	sub	r8,sp,-1352
8000ba4c:	1a d8       	st.w	--sp,r8
8000ba4e:	fa c8 fb b4 	sub	r8,sp,-1100
8000ba52:	0c 9b       	mov	r11,r6
8000ba54:	1a d8       	st.w	--sp,r8
8000ba56:	04 9a       	mov	r10,r2
8000ba58:	fa c8 f9 40 	sub	r8,sp,-1728
8000ba5c:	fa c9 ff b4 	sub	r9,sp,-76
8000ba60:	08 9c       	mov	r12,r4
8000ba62:	fe b0 fa 91 	rcall	8000af84 <get_arg>
8000ba66:	2f dd       	sub	sp,-12
8000ba68:	78 16       	ld.w	r6,r12[0x4]
8000ba6a:	50 76       	stdsp	sp[0x1c],r6
8000ba6c:	c4 88       	rjmp	8000bafc <_vfprintf_r+0x83c>
8000ba6e:	2f f7       	sub	r7,-1
8000ba70:	10 39       	cp.w	r9,r8
8000ba72:	c0 c4       	brge	8000ba8a <_vfprintf_r+0x7ca>
8000ba74:	fa ce f9 44 	sub	lr,sp,-1724
8000ba78:	fc 06 00 36 	add	r6,lr,r6<<0x3
8000ba7c:	ec fc fd 8c 	ld.w	r12,r6[-628]
8000ba80:	50 7c       	stdsp	sp[0x1c],r12
8000ba82:	ec f6 fd 88 	ld.w	r6,r6[-632]
8000ba86:	50 56       	stdsp	sp[0x14],r6
8000ba88:	c6 68       	rjmp	8000bb54 <_vfprintf_r+0x894>
8000ba8a:	41 09       	lddsp	r9,sp[0x40]
8000ba8c:	59 f8       	cp.w	r8,31
8000ba8e:	e0 89 00 10 	brgt	8000baae <_vfprintf_r+0x7ee>
8000ba92:	f2 ca ff f8 	sub	r10,r9,-8
8000ba96:	72 1b       	ld.w	r11,r9[0x4]
8000ba98:	51 0a       	stdsp	sp[0x40],r10
8000ba9a:	72 09       	ld.w	r9,r9[0x0]
8000ba9c:	fa ca f9 44 	sub	r10,sp,-1724
8000baa0:	50 7b       	stdsp	sp[0x1c],r11
8000baa2:	50 59       	stdsp	sp[0x14],r9
8000baa4:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000baa8:	40 5b       	lddsp	r11,sp[0x14]
8000baaa:	40 7a       	lddsp	r10,sp[0x1c]
8000baac:	c4 78       	rjmp	8000bb3a <_vfprintf_r+0x87a>
8000baae:	72 18       	ld.w	r8,r9[0x4]
8000bab0:	50 78       	stdsp	sp[0x1c],r8
8000bab2:	c4 c8       	rjmp	8000bb4a <_vfprintf_r+0x88a>
8000bab4:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000bab8:	40 3e       	lddsp	lr,sp[0xc]
8000baba:	58 0e       	cp.w	lr,0
8000babc:	c2 30       	breq	8000bb02 <_vfprintf_r+0x842>
8000babe:	10 36       	cp.w	r6,r8
8000bac0:	c0 94       	brge	8000bad2 <_vfprintf_r+0x812>
8000bac2:	fa cc f9 44 	sub	r12,sp,-1724
8000bac6:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000baca:	ec fb fd 8c 	ld.w	r11,r6[-628]
8000bace:	50 7b       	stdsp	sp[0x1c],r11
8000bad0:	cd 9b       	rjmp	8000ba82 <_vfprintf_r+0x7c2>
8000bad2:	fa c8 f9 50 	sub	r8,sp,-1712
8000bad6:	1a d8       	st.w	--sp,r8
8000bad8:	fa c8 fa b8 	sub	r8,sp,-1352
8000badc:	04 9a       	mov	r10,r2
8000bade:	1a d8       	st.w	--sp,r8
8000bae0:	fa c8 fb b4 	sub	r8,sp,-1100
8000bae4:	0c 9b       	mov	r11,r6
8000bae6:	1a d8       	st.w	--sp,r8
8000bae8:	08 9c       	mov	r12,r4
8000baea:	fa c8 f9 40 	sub	r8,sp,-1728
8000baee:	fa c9 ff b4 	sub	r9,sp,-76
8000baf2:	fe b0 fa 49 	rcall	8000af84 <get_arg>
8000baf6:	2f dd       	sub	sp,-12
8000baf8:	78 1a       	ld.w	r10,r12[0x4]
8000bafa:	50 7a       	stdsp	sp[0x1c],r10
8000bafc:	78 0c       	ld.w	r12,r12[0x0]
8000bafe:	50 5c       	stdsp	sp[0x14],r12
8000bb00:	c2 a8       	rjmp	8000bb54 <_vfprintf_r+0x894>
8000bb02:	2f f7       	sub	r7,-1
8000bb04:	10 39       	cp.w	r9,r8
8000bb06:	c0 94       	brge	8000bb18 <_vfprintf_r+0x858>
8000bb08:	fa c9 f9 44 	sub	r9,sp,-1724
8000bb0c:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000bb10:	ec f8 fd 8c 	ld.w	r8,r6[-628]
8000bb14:	50 78       	stdsp	sp[0x1c],r8
8000bb16:	cb 6b       	rjmp	8000ba82 <_vfprintf_r+0x7c2>
8000bb18:	41 09       	lddsp	r9,sp[0x40]
8000bb1a:	59 f8       	cp.w	r8,31
8000bb1c:	e0 89 00 15 	brgt	8000bb46 <_vfprintf_r+0x886>
8000bb20:	f2 ca ff f8 	sub	r10,r9,-8
8000bb24:	72 16       	ld.w	r6,r9[0x4]
8000bb26:	72 09       	ld.w	r9,r9[0x0]
8000bb28:	51 0a       	stdsp	sp[0x40],r10
8000bb2a:	50 59       	stdsp	sp[0x14],r9
8000bb2c:	fa ce f9 44 	sub	lr,sp,-1724
8000bb30:	50 76       	stdsp	sp[0x1c],r6
8000bb32:	fc 08 00 39 	add	r9,lr,r8<<0x3
8000bb36:	40 5b       	lddsp	r11,sp[0x14]
8000bb38:	0c 9a       	mov	r10,r6
8000bb3a:	f2 eb fd 88 	st.d	r9[-632],r10
8000bb3e:	2f f8       	sub	r8,-1
8000bb40:	fb 48 06 b4 	st.w	sp[1716],r8
8000bb44:	c0 88       	rjmp	8000bb54 <_vfprintf_r+0x894>
8000bb46:	72 1c       	ld.w	r12,r9[0x4]
8000bb48:	50 7c       	stdsp	sp[0x1c],r12
8000bb4a:	f2 c8 ff f8 	sub	r8,r9,-8
8000bb4e:	51 08       	stdsp	sp[0x40],r8
8000bb50:	72 09       	ld.w	r9,r9[0x0]
8000bb52:	50 59       	stdsp	sp[0x14],r9
8000bb54:	40 5b       	lddsp	r11,sp[0x14]
8000bb56:	40 7a       	lddsp	r10,sp[0x1c]
8000bb58:	e0 a0 19 64 	rcall	8000ee20 <__isinfd>
8000bb5c:	18 96       	mov	r6,r12
8000bb5e:	c1 50       	breq	8000bb88 <_vfprintf_r+0x8c8>
8000bb60:	30 08       	mov	r8,0
8000bb62:	30 09       	mov	r9,0
8000bb64:	40 5b       	lddsp	r11,sp[0x14]
8000bb66:	40 7a       	lddsp	r10,sp[0x1c]
8000bb68:	e0 a0 1d ba 	rcall	8000f6dc <__avr32_f64_cmp_lt>
8000bb6c:	c0 40       	breq	8000bb74 <_vfprintf_r+0x8b4>
8000bb6e:	32 d8       	mov	r8,45
8000bb70:	fb 68 06 bb 	st.b	sp[1723],r8
8000bb74:	4d 18       	lddpc	r8,8000bcb8 <_vfprintf_r+0x9f8>
8000bb76:	4d 26       	lddpc	r6,8000bcbc <_vfprintf_r+0x9fc>
8000bb78:	a7 d5       	cbr	r5,0x7
8000bb7a:	e0 40 00 47 	cp.w	r0,71
8000bb7e:	f0 06 17 a0 	movle	r6,r8
8000bb82:	30 32       	mov	r2,3
8000bb84:	e0 8f 06 d4 	bral	8000c92c <_vfprintf_r+0x166c>
8000bb88:	40 5b       	lddsp	r11,sp[0x14]
8000bb8a:	40 7a       	lddsp	r10,sp[0x1c]
8000bb8c:	e0 a0 19 5f 	rcall	8000ee4a <__isnand>
8000bb90:	c0 c0       	breq	8000bba8 <_vfprintf_r+0x8e8>
8000bb92:	50 26       	stdsp	sp[0x8],r6
8000bb94:	4c b8       	lddpc	r8,8000bcc0 <_vfprintf_r+0xa00>
8000bb96:	4c c6       	lddpc	r6,8000bcc4 <_vfprintf_r+0xa04>
8000bb98:	a7 d5       	cbr	r5,0x7
8000bb9a:	e0 40 00 47 	cp.w	r0,71
8000bb9e:	f0 06 17 a0 	movle	r6,r8
8000bba2:	30 32       	mov	r2,3
8000bba4:	e0 8f 06 ca 	bral	8000c938 <_vfprintf_r+0x1678>
8000bba8:	40 2a       	lddsp	r10,sp[0x8]
8000bbaa:	5b fa       	cp.w	r10,-1
8000bbac:	c0 41       	brne	8000bbb4 <_vfprintf_r+0x8f4>
8000bbae:	30 69       	mov	r9,6
8000bbb0:	50 29       	stdsp	sp[0x8],r9
8000bbb2:	c1 18       	rjmp	8000bbd4 <_vfprintf_r+0x914>
8000bbb4:	e0 40 00 47 	cp.w	r0,71
8000bbb8:	5f 09       	sreq	r9
8000bbba:	e0 40 00 67 	cp.w	r0,103
8000bbbe:	5f 08       	sreq	r8
8000bbc0:	f3 e8 10 08 	or	r8,r9,r8
8000bbc4:	f8 08 18 00 	cp.b	r8,r12
8000bbc8:	c0 60       	breq	8000bbd4 <_vfprintf_r+0x914>
8000bbca:	40 28       	lddsp	r8,sp[0x8]
8000bbcc:	58 08       	cp.w	r8,0
8000bbce:	f9 b8 00 01 	moveq	r8,1
8000bbd2:	50 28       	stdsp	sp[0x8],r8
8000bbd4:	40 78       	lddsp	r8,sp[0x1c]
8000bbd6:	40 59       	lddsp	r9,sp[0x14]
8000bbd8:	fa e9 06 94 	st.d	sp[1684],r8
8000bbdc:	a9 a5       	sbr	r5,0x8
8000bbde:	fa f8 06 94 	ld.w	r8,sp[1684]
8000bbe2:	58 08       	cp.w	r8,0
8000bbe4:	c0 65       	brlt	8000bbf0 <_vfprintf_r+0x930>
8000bbe6:	40 5e       	lddsp	lr,sp[0x14]
8000bbe8:	30 0c       	mov	r12,0
8000bbea:	50 6e       	stdsp	sp[0x18],lr
8000bbec:	50 9c       	stdsp	sp[0x24],r12
8000bbee:	c0 78       	rjmp	8000bbfc <_vfprintf_r+0x93c>
8000bbf0:	40 5b       	lddsp	r11,sp[0x14]
8000bbf2:	32 da       	mov	r10,45
8000bbf4:	ee 1b 80 00 	eorh	r11,0x8000
8000bbf8:	50 9a       	stdsp	sp[0x24],r10
8000bbfa:	50 6b       	stdsp	sp[0x18],r11
8000bbfc:	e0 40 00 46 	cp.w	r0,70
8000bc00:	5f 09       	sreq	r9
8000bc02:	e0 40 00 66 	cp.w	r0,102
8000bc06:	5f 08       	sreq	r8
8000bc08:	f3 e8 10 08 	or	r8,r9,r8
8000bc0c:	50 48       	stdsp	sp[0x10],r8
8000bc0e:	c0 40       	breq	8000bc16 <_vfprintf_r+0x956>
8000bc10:	40 22       	lddsp	r2,sp[0x8]
8000bc12:	30 39       	mov	r9,3
8000bc14:	c1 08       	rjmp	8000bc34 <_vfprintf_r+0x974>
8000bc16:	e0 40 00 45 	cp.w	r0,69
8000bc1a:	5f 09       	sreq	r9
8000bc1c:	e0 40 00 65 	cp.w	r0,101
8000bc20:	5f 08       	sreq	r8
8000bc22:	40 22       	lddsp	r2,sp[0x8]
8000bc24:	10 49       	or	r9,r8
8000bc26:	2f f2       	sub	r2,-1
8000bc28:	40 46       	lddsp	r6,sp[0x10]
8000bc2a:	ec 09 18 00 	cp.b	r9,r6
8000bc2e:	fb f2 00 02 	ld.weq	r2,sp[0x8]
8000bc32:	30 29       	mov	r9,2
8000bc34:	fa c8 f9 5c 	sub	r8,sp,-1700
8000bc38:	1a d8       	st.w	--sp,r8
8000bc3a:	fa c8 f9 54 	sub	r8,sp,-1708
8000bc3e:	1a d8       	st.w	--sp,r8
8000bc40:	fa c8 f9 4c 	sub	r8,sp,-1716
8000bc44:	08 9c       	mov	r12,r4
8000bc46:	1a d8       	st.w	--sp,r8
8000bc48:	04 98       	mov	r8,r2
8000bc4a:	40 9b       	lddsp	r11,sp[0x24]
8000bc4c:	40 aa       	lddsp	r10,sp[0x28]
8000bc4e:	e0 a0 0b cf 	rcall	8000d3ec <_dtoa_r>
8000bc52:	e0 40 00 47 	cp.w	r0,71
8000bc56:	5f 19       	srne	r9
8000bc58:	e0 40 00 67 	cp.w	r0,103
8000bc5c:	5f 18       	srne	r8
8000bc5e:	18 96       	mov	r6,r12
8000bc60:	2f dd       	sub	sp,-12
8000bc62:	f3 e8 00 08 	and	r8,r9,r8
8000bc66:	c0 41       	brne	8000bc6e <_vfprintf_r+0x9ae>
8000bc68:	ed b5 00 00 	bld	r5,0x0
8000bc6c:	c3 81       	brne	8000bcdc <_vfprintf_r+0xa1c>
8000bc6e:	ec 02 00 0e 	add	lr,r6,r2
8000bc72:	50 3e       	stdsp	sp[0xc],lr
8000bc74:	40 4c       	lddsp	r12,sp[0x10]
8000bc76:	58 0c       	cp.w	r12,0
8000bc78:	c1 50       	breq	8000bca2 <_vfprintf_r+0x9e2>
8000bc7a:	0d 89       	ld.ub	r9,r6[0x0]
8000bc7c:	33 08       	mov	r8,48
8000bc7e:	f0 09 18 00 	cp.b	r9,r8
8000bc82:	c0 b1       	brne	8000bc98 <_vfprintf_r+0x9d8>
8000bc84:	30 08       	mov	r8,0
8000bc86:	30 09       	mov	r9,0
8000bc88:	40 6b       	lddsp	r11,sp[0x18]
8000bc8a:	40 7a       	lddsp	r10,sp[0x1c]
8000bc8c:	e0 a0 1c e1 	rcall	8000f64e <__avr32_f64_cmp_eq>
8000bc90:	fb b2 00 01 	rsubeq	r2,1
8000bc94:	fb f2 0b ab 	st.weq	sp[0x6ac],r2
8000bc98:	40 3b       	lddsp	r11,sp[0xc]
8000bc9a:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000bc9e:	10 0b       	add	r11,r8
8000bca0:	50 3b       	stdsp	sp[0xc],r11
8000bca2:	40 6b       	lddsp	r11,sp[0x18]
8000bca4:	30 08       	mov	r8,0
8000bca6:	30 09       	mov	r9,0
8000bca8:	40 7a       	lddsp	r10,sp[0x1c]
8000bcaa:	e0 a0 1c d2 	rcall	8000f64e <__avr32_f64_cmp_eq>
8000bcae:	c1 10       	breq	8000bcd0 <_vfprintf_r+0xa10>
8000bcb0:	40 3a       	lddsp	r10,sp[0xc]
8000bcb2:	fb 4a 06 a4 	st.w	sp[1700],r10
8000bcb6:	c0 d8       	rjmp	8000bcd0 <_vfprintf_r+0xa10>
8000bcb8:	80 01       	ld.sh	r1,r0[0x0]
8000bcba:	95 90       	st.w	r10[0x24],r0
8000bcbc:	80 01       	ld.sh	r1,r0[0x0]
8000bcbe:	95 94       	st.w	r10[0x24],r4
8000bcc0:	80 01       	ld.sh	r1,r0[0x0]
8000bcc2:	95 98       	st.w	r10[0x24],r8
8000bcc4:	80 01       	ld.sh	r1,r0[0x0]
8000bcc6:	95 9c       	st.w	r10[0x24],r12
8000bcc8:	10 c9       	st.b	r8++,r9
8000bcca:	fb 48 06 a4 	st.w	sp[1700],r8
8000bcce:	c0 28       	rjmp	8000bcd2 <_vfprintf_r+0xa12>
8000bcd0:	33 09       	mov	r9,48
8000bcd2:	fa f8 06 a4 	ld.w	r8,sp[1700]
8000bcd6:	40 3e       	lddsp	lr,sp[0xc]
8000bcd8:	1c 38       	cp.w	r8,lr
8000bcda:	cf 73       	brcs	8000bcc8 <_vfprintf_r+0xa08>
8000bcdc:	e0 40 00 47 	cp.w	r0,71
8000bce0:	5f 09       	sreq	r9
8000bce2:	e0 40 00 67 	cp.w	r0,103
8000bce6:	5f 08       	sreq	r8
8000bce8:	f3 e8 10 08 	or	r8,r9,r8
8000bcec:	fa f9 06 a4 	ld.w	r9,sp[1700]
8000bcf0:	0c 19       	sub	r9,r6
8000bcf2:	50 69       	stdsp	sp[0x18],r9
8000bcf4:	58 08       	cp.w	r8,0
8000bcf6:	c0 b0       	breq	8000bd0c <_vfprintf_r+0xa4c>
8000bcf8:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000bcfc:	5b d8       	cp.w	r8,-3
8000bcfe:	c0 55       	brlt	8000bd08 <_vfprintf_r+0xa48>
8000bd00:	40 2c       	lddsp	r12,sp[0x8]
8000bd02:	18 38       	cp.w	r8,r12
8000bd04:	e0 8a 00 6a 	brle	8000bdd8 <_vfprintf_r+0xb18>
8000bd08:	20 20       	sub	r0,2
8000bd0a:	c0 58       	rjmp	8000bd14 <_vfprintf_r+0xa54>
8000bd0c:	e0 40 00 65 	cp.w	r0,101
8000bd10:	e0 89 00 46 	brgt	8000bd9c <_vfprintf_r+0xadc>
8000bd14:	fa fb 06 ac 	ld.w	r11,sp[1708]
8000bd18:	fb 60 06 9c 	st.b	sp[1692],r0
8000bd1c:	20 1b       	sub	r11,1
8000bd1e:	fb 4b 06 ac 	st.w	sp[1708],r11
8000bd22:	c0 47       	brpl	8000bd2a <_vfprintf_r+0xa6a>
8000bd24:	5c 3b       	neg	r11
8000bd26:	32 d8       	mov	r8,45
8000bd28:	c0 28       	rjmp	8000bd2c <_vfprintf_r+0xa6c>
8000bd2a:	32 b8       	mov	r8,43
8000bd2c:	fb 68 06 9d 	st.b	sp[1693],r8
8000bd30:	58 9b       	cp.w	r11,9
8000bd32:	e0 8a 00 1d 	brle	8000bd6c <_vfprintf_r+0xaac>
8000bd36:	fa c9 fa 35 	sub	r9,sp,-1483
8000bd3a:	30 aa       	mov	r10,10
8000bd3c:	12 98       	mov	r8,r9
8000bd3e:	0e 9c       	mov	r12,r7
8000bd40:	0c 92       	mov	r2,r6
8000bd42:	f6 0a 0c 06 	divs	r6,r11,r10
8000bd46:	0e 9b       	mov	r11,r7
8000bd48:	2d 0b       	sub	r11,-48
8000bd4a:	10 fb       	st.b	--r8,r11
8000bd4c:	0c 9b       	mov	r11,r6
8000bd4e:	58 96       	cp.w	r6,9
8000bd50:	fe 99 ff f9 	brgt	8000bd42 <_vfprintf_r+0xa82>
8000bd54:	2d 0b       	sub	r11,-48
8000bd56:	18 97       	mov	r7,r12
8000bd58:	04 96       	mov	r6,r2
8000bd5a:	10 fb       	st.b	--r8,r11
8000bd5c:	fa ca f9 62 	sub	r10,sp,-1694
8000bd60:	c0 38       	rjmp	8000bd66 <_vfprintf_r+0xaa6>
8000bd62:	11 3b       	ld.ub	r11,r8++
8000bd64:	14 cb       	st.b	r10++,r11
8000bd66:	12 38       	cp.w	r8,r9
8000bd68:	cf d3       	brcs	8000bd62 <_vfprintf_r+0xaa2>
8000bd6a:	c0 98       	rjmp	8000bd7c <_vfprintf_r+0xabc>
8000bd6c:	2d 0b       	sub	r11,-48
8000bd6e:	33 08       	mov	r8,48
8000bd70:	fb 6b 06 9f 	st.b	sp[1695],r11
8000bd74:	fb 68 06 9e 	st.b	sp[1694],r8
8000bd78:	fa ca f9 60 	sub	r10,sp,-1696
8000bd7c:	fa c8 f9 64 	sub	r8,sp,-1692
8000bd80:	f4 08 01 08 	sub	r8,r10,r8
8000bd84:	50 e8       	stdsp	sp[0x38],r8
8000bd86:	10 92       	mov	r2,r8
8000bd88:	40 6b       	lddsp	r11,sp[0x18]
8000bd8a:	16 02       	add	r2,r11
8000bd8c:	58 1b       	cp.w	r11,1
8000bd8e:	e0 89 00 05 	brgt	8000bd98 <_vfprintf_r+0xad8>
8000bd92:	ed b5 00 00 	bld	r5,0x0
8000bd96:	c3 51       	brne	8000be00 <_vfprintf_r+0xb40>
8000bd98:	2f f2       	sub	r2,-1
8000bd9a:	c3 38       	rjmp	8000be00 <_vfprintf_r+0xb40>
8000bd9c:	e0 40 00 66 	cp.w	r0,102
8000bda0:	c1 c1       	brne	8000bdd8 <_vfprintf_r+0xb18>
8000bda2:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000bda6:	58 02       	cp.w	r2,0
8000bda8:	e0 8a 00 0c 	brle	8000bdc0 <_vfprintf_r+0xb00>
8000bdac:	40 2a       	lddsp	r10,sp[0x8]
8000bdae:	58 0a       	cp.w	r10,0
8000bdb0:	c0 41       	brne	8000bdb8 <_vfprintf_r+0xaf8>
8000bdb2:	ed b5 00 00 	bld	r5,0x0
8000bdb6:	c2 51       	brne	8000be00 <_vfprintf_r+0xb40>
8000bdb8:	2f f2       	sub	r2,-1
8000bdba:	40 29       	lddsp	r9,sp[0x8]
8000bdbc:	12 02       	add	r2,r9
8000bdbe:	c0 b8       	rjmp	8000bdd4 <_vfprintf_r+0xb14>
8000bdc0:	40 28       	lddsp	r8,sp[0x8]
8000bdc2:	58 08       	cp.w	r8,0
8000bdc4:	c0 61       	brne	8000bdd0 <_vfprintf_r+0xb10>
8000bdc6:	ed b5 00 00 	bld	r5,0x0
8000bdca:	c0 30       	breq	8000bdd0 <_vfprintf_r+0xb10>
8000bdcc:	30 12       	mov	r2,1
8000bdce:	c1 98       	rjmp	8000be00 <_vfprintf_r+0xb40>
8000bdd0:	40 22       	lddsp	r2,sp[0x8]
8000bdd2:	2f e2       	sub	r2,-2
8000bdd4:	36 60       	mov	r0,102
8000bdd6:	c1 58       	rjmp	8000be00 <_vfprintf_r+0xb40>
8000bdd8:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000bddc:	40 6e       	lddsp	lr,sp[0x18]
8000bdde:	1c 32       	cp.w	r2,lr
8000bde0:	c0 65       	brlt	8000bdec <_vfprintf_r+0xb2c>
8000bde2:	ed b5 00 00 	bld	r5,0x0
8000bde6:	f7 b2 00 ff 	subeq	r2,-1
8000bdea:	c0 a8       	rjmp	8000bdfe <_vfprintf_r+0xb3e>
8000bdec:	e4 08 11 02 	rsub	r8,r2,2
8000bdf0:	40 6c       	lddsp	r12,sp[0x18]
8000bdf2:	58 02       	cp.w	r2,0
8000bdf4:	f0 02 17 a0 	movle	r2,r8
8000bdf8:	f9 b2 09 01 	movgt	r2,1
8000bdfc:	18 02       	add	r2,r12
8000bdfe:	36 70       	mov	r0,103
8000be00:	40 9b       	lddsp	r11,sp[0x24]
8000be02:	58 0b       	cp.w	r11,0
8000be04:	e0 80 05 94 	breq	8000c92c <_vfprintf_r+0x166c>
8000be08:	32 d8       	mov	r8,45
8000be0a:	fb 68 06 bb 	st.b	sp[1723],r8
8000be0e:	e0 8f 05 93 	bral	8000c934 <_vfprintf_r+0x1674>
8000be12:	50 a7       	stdsp	sp[0x28],r7
8000be14:	04 94       	mov	r4,r2
8000be16:	0c 97       	mov	r7,r6
8000be18:	02 92       	mov	r2,r1
8000be1a:	06 96       	mov	r6,r3
8000be1c:	40 41       	lddsp	r1,sp[0x10]
8000be1e:	40 93       	lddsp	r3,sp[0x24]
8000be20:	0e 99       	mov	r9,r7
8000be22:	ed b5 00 05 	bld	r5,0x5
8000be26:	c4 81       	brne	8000beb6 <_vfprintf_r+0xbf6>
8000be28:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000be2c:	40 3e       	lddsp	lr,sp[0xc]
8000be2e:	58 0e       	cp.w	lr,0
8000be30:	c1 d0       	breq	8000be6a <_vfprintf_r+0xbaa>
8000be32:	10 36       	cp.w	r6,r8
8000be34:	c0 64       	brge	8000be40 <_vfprintf_r+0xb80>
8000be36:	fa cc f9 44 	sub	r12,sp,-1724
8000be3a:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000be3e:	c1 d8       	rjmp	8000be78 <_vfprintf_r+0xbb8>
8000be40:	fa c8 f9 50 	sub	r8,sp,-1712
8000be44:	1a d8       	st.w	--sp,r8
8000be46:	fa c8 fa b8 	sub	r8,sp,-1352
8000be4a:	04 9a       	mov	r10,r2
8000be4c:	1a d8       	st.w	--sp,r8
8000be4e:	fa c8 fb b4 	sub	r8,sp,-1100
8000be52:	0c 9b       	mov	r11,r6
8000be54:	1a d8       	st.w	--sp,r8
8000be56:	08 9c       	mov	r12,r4
8000be58:	fa c8 f9 40 	sub	r8,sp,-1728
8000be5c:	fa c9 ff b4 	sub	r9,sp,-76
8000be60:	fe b0 f8 92 	rcall	8000af84 <get_arg>
8000be64:	2f dd       	sub	sp,-12
8000be66:	78 0a       	ld.w	r10,r12[0x0]
8000be68:	c2 08       	rjmp	8000bea8 <_vfprintf_r+0xbe8>
8000be6a:	2f f7       	sub	r7,-1
8000be6c:	10 39       	cp.w	r9,r8
8000be6e:	c0 84       	brge	8000be7e <_vfprintf_r+0xbbe>
8000be70:	fa cb f9 44 	sub	r11,sp,-1724
8000be74:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000be78:	ec fa fd 88 	ld.w	r10,r6[-632]
8000be7c:	c1 68       	rjmp	8000bea8 <_vfprintf_r+0xbe8>
8000be7e:	41 09       	lddsp	r9,sp[0x40]
8000be80:	59 f8       	cp.w	r8,31
8000be82:	e0 89 00 10 	brgt	8000bea2 <_vfprintf_r+0xbe2>
8000be86:	f2 ca ff fc 	sub	r10,r9,-4
8000be8a:	51 0a       	stdsp	sp[0x40],r10
8000be8c:	fa c6 f9 44 	sub	r6,sp,-1724
8000be90:	72 0a       	ld.w	r10,r9[0x0]
8000be92:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000be96:	f3 4a fd 88 	st.w	r9[-632],r10
8000be9a:	2f f8       	sub	r8,-1
8000be9c:	fb 48 06 b4 	st.w	sp[1716],r8
8000bea0:	c0 48       	rjmp	8000bea8 <_vfprintf_r+0xbe8>
8000bea2:	72 0a       	ld.w	r10,r9[0x0]
8000bea4:	2f c9       	sub	r9,-4
8000bea6:	51 09       	stdsp	sp[0x40],r9
8000bea8:	40 be       	lddsp	lr,sp[0x2c]
8000beaa:	1c 98       	mov	r8,lr
8000beac:	95 1e       	st.w	r10[0x4],lr
8000beae:	bf 58       	asr	r8,0x1f
8000beb0:	95 08       	st.w	r10[0x0],r8
8000beb2:	fe 9f fa 92 	bral	8000b3d6 <_vfprintf_r+0x116>
8000beb6:	ed b5 00 04 	bld	r5,0x4
8000beba:	c4 80       	breq	8000bf4a <_vfprintf_r+0xc8a>
8000bebc:	e2 15 00 40 	andl	r5,0x40,COH
8000bec0:	c4 50       	breq	8000bf4a <_vfprintf_r+0xc8a>
8000bec2:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000bec6:	40 3c       	lddsp	r12,sp[0xc]
8000bec8:	58 0c       	cp.w	r12,0
8000beca:	c1 d0       	breq	8000bf04 <_vfprintf_r+0xc44>
8000becc:	10 36       	cp.w	r6,r8
8000bece:	c0 64       	brge	8000beda <_vfprintf_r+0xc1a>
8000bed0:	fa cb f9 44 	sub	r11,sp,-1724
8000bed4:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000bed8:	c1 d8       	rjmp	8000bf12 <_vfprintf_r+0xc52>
8000beda:	fa c8 f9 50 	sub	r8,sp,-1712
8000bede:	1a d8       	st.w	--sp,r8
8000bee0:	fa c8 fa b8 	sub	r8,sp,-1352
8000bee4:	04 9a       	mov	r10,r2
8000bee6:	1a d8       	st.w	--sp,r8
8000bee8:	fa c8 fb b4 	sub	r8,sp,-1100
8000beec:	0c 9b       	mov	r11,r6
8000beee:	1a d8       	st.w	--sp,r8
8000bef0:	08 9c       	mov	r12,r4
8000bef2:	fa c8 f9 40 	sub	r8,sp,-1728
8000bef6:	fa c9 ff b4 	sub	r9,sp,-76
8000befa:	fe b0 f8 45 	rcall	8000af84 <get_arg>
8000befe:	2f dd       	sub	sp,-12
8000bf00:	78 0a       	ld.w	r10,r12[0x0]
8000bf02:	c2 08       	rjmp	8000bf42 <_vfprintf_r+0xc82>
8000bf04:	2f f7       	sub	r7,-1
8000bf06:	10 39       	cp.w	r9,r8
8000bf08:	c0 84       	brge	8000bf18 <_vfprintf_r+0xc58>
8000bf0a:	fa ca f9 44 	sub	r10,sp,-1724
8000bf0e:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000bf12:	ec fa fd 88 	ld.w	r10,r6[-632]
8000bf16:	c1 68       	rjmp	8000bf42 <_vfprintf_r+0xc82>
8000bf18:	41 09       	lddsp	r9,sp[0x40]
8000bf1a:	59 f8       	cp.w	r8,31
8000bf1c:	e0 89 00 10 	brgt	8000bf3c <_vfprintf_r+0xc7c>
8000bf20:	f2 ca ff fc 	sub	r10,r9,-4
8000bf24:	51 0a       	stdsp	sp[0x40],r10
8000bf26:	fa c6 f9 44 	sub	r6,sp,-1724
8000bf2a:	72 0a       	ld.w	r10,r9[0x0]
8000bf2c:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000bf30:	f3 4a fd 88 	st.w	r9[-632],r10
8000bf34:	2f f8       	sub	r8,-1
8000bf36:	fb 48 06 b4 	st.w	sp[1716],r8
8000bf3a:	c0 48       	rjmp	8000bf42 <_vfprintf_r+0xc82>
8000bf3c:	72 0a       	ld.w	r10,r9[0x0]
8000bf3e:	2f c9       	sub	r9,-4
8000bf40:	51 09       	stdsp	sp[0x40],r9
8000bf42:	40 be       	lddsp	lr,sp[0x2c]
8000bf44:	b4 0e       	st.h	r10[0x0],lr
8000bf46:	fe 9f fa 48 	bral	8000b3d6 <_vfprintf_r+0x116>
8000bf4a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000bf4e:	40 3c       	lddsp	r12,sp[0xc]
8000bf50:	58 0c       	cp.w	r12,0
8000bf52:	c1 d0       	breq	8000bf8c <_vfprintf_r+0xccc>
8000bf54:	10 36       	cp.w	r6,r8
8000bf56:	c0 64       	brge	8000bf62 <_vfprintf_r+0xca2>
8000bf58:	fa cb f9 44 	sub	r11,sp,-1724
8000bf5c:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000bf60:	c1 d8       	rjmp	8000bf9a <_vfprintf_r+0xcda>
8000bf62:	fa c8 f9 50 	sub	r8,sp,-1712
8000bf66:	1a d8       	st.w	--sp,r8
8000bf68:	fa c8 fa b8 	sub	r8,sp,-1352
8000bf6c:	04 9a       	mov	r10,r2
8000bf6e:	1a d8       	st.w	--sp,r8
8000bf70:	fa c8 fb b4 	sub	r8,sp,-1100
8000bf74:	0c 9b       	mov	r11,r6
8000bf76:	1a d8       	st.w	--sp,r8
8000bf78:	08 9c       	mov	r12,r4
8000bf7a:	fa c8 f9 40 	sub	r8,sp,-1728
8000bf7e:	fa c9 ff b4 	sub	r9,sp,-76
8000bf82:	fe b0 f8 01 	rcall	8000af84 <get_arg>
8000bf86:	2f dd       	sub	sp,-12
8000bf88:	78 0a       	ld.w	r10,r12[0x0]
8000bf8a:	c2 08       	rjmp	8000bfca <_vfprintf_r+0xd0a>
8000bf8c:	2f f7       	sub	r7,-1
8000bf8e:	10 39       	cp.w	r9,r8
8000bf90:	c0 84       	brge	8000bfa0 <_vfprintf_r+0xce0>
8000bf92:	fa ca f9 44 	sub	r10,sp,-1724
8000bf96:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000bf9a:	ec fa fd 88 	ld.w	r10,r6[-632]
8000bf9e:	c1 68       	rjmp	8000bfca <_vfprintf_r+0xd0a>
8000bfa0:	41 09       	lddsp	r9,sp[0x40]
8000bfa2:	59 f8       	cp.w	r8,31
8000bfa4:	e0 89 00 10 	brgt	8000bfc4 <_vfprintf_r+0xd04>
8000bfa8:	f2 ca ff fc 	sub	r10,r9,-4
8000bfac:	51 0a       	stdsp	sp[0x40],r10
8000bfae:	fa c6 f9 44 	sub	r6,sp,-1724
8000bfb2:	72 0a       	ld.w	r10,r9[0x0]
8000bfb4:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000bfb8:	f3 4a fd 88 	st.w	r9[-632],r10
8000bfbc:	2f f8       	sub	r8,-1
8000bfbe:	fb 48 06 b4 	st.w	sp[1716],r8
8000bfc2:	c0 48       	rjmp	8000bfca <_vfprintf_r+0xd0a>
8000bfc4:	72 0a       	ld.w	r10,r9[0x0]
8000bfc6:	2f c9       	sub	r9,-4
8000bfc8:	51 09       	stdsp	sp[0x40],r9
8000bfca:	40 be       	lddsp	lr,sp[0x2c]
8000bfcc:	95 0e       	st.w	r10[0x0],lr
8000bfce:	fe 9f fa 04 	bral	8000b3d6 <_vfprintf_r+0x116>
8000bfd2:	50 a7       	stdsp	sp[0x28],r7
8000bfd4:	50 80       	stdsp	sp[0x20],r0
8000bfd6:	0c 97       	mov	r7,r6
8000bfd8:	04 94       	mov	r4,r2
8000bfda:	06 96       	mov	r6,r3
8000bfdc:	02 92       	mov	r2,r1
8000bfde:	40 93       	lddsp	r3,sp[0x24]
8000bfe0:	10 90       	mov	r0,r8
8000bfe2:	40 41       	lddsp	r1,sp[0x10]
8000bfe4:	a5 a5       	sbr	r5,0x4
8000bfe6:	c0 a8       	rjmp	8000bffa <_vfprintf_r+0xd3a>
8000bfe8:	50 a7       	stdsp	sp[0x28],r7
8000bfea:	50 80       	stdsp	sp[0x20],r0
8000bfec:	0c 97       	mov	r7,r6
8000bfee:	04 94       	mov	r4,r2
8000bff0:	06 96       	mov	r6,r3
8000bff2:	02 92       	mov	r2,r1
8000bff4:	40 93       	lddsp	r3,sp[0x24]
8000bff6:	10 90       	mov	r0,r8
8000bff8:	40 41       	lddsp	r1,sp[0x10]
8000bffa:	ed b5 00 05 	bld	r5,0x5
8000bffe:	c5 d1       	brne	8000c0b8 <_vfprintf_r+0xdf8>
8000c000:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c004:	40 3c       	lddsp	r12,sp[0xc]
8000c006:	58 0c       	cp.w	r12,0
8000c008:	c2 60       	breq	8000c054 <_vfprintf_r+0xd94>
8000c00a:	10 36       	cp.w	r6,r8
8000c00c:	c0 a4       	brge	8000c020 <_vfprintf_r+0xd60>
8000c00e:	fa cb f9 44 	sub	r11,sp,-1724
8000c012:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000c016:	ec e8 fd 88 	ld.d	r8,r6[-632]
8000c01a:	fa e9 00 00 	st.d	sp[0],r8
8000c01e:	c1 88       	rjmp	8000c04e <_vfprintf_r+0xd8e>
8000c020:	fa c8 f9 50 	sub	r8,sp,-1712
8000c024:	1a d8       	st.w	--sp,r8
8000c026:	fa c8 fa b8 	sub	r8,sp,-1352
8000c02a:	04 9a       	mov	r10,r2
8000c02c:	1a d8       	st.w	--sp,r8
8000c02e:	0c 9b       	mov	r11,r6
8000c030:	fa c8 fb b4 	sub	r8,sp,-1100
8000c034:	08 9c       	mov	r12,r4
8000c036:	1a d8       	st.w	--sp,r8
8000c038:	fa c8 f9 40 	sub	r8,sp,-1728
8000c03c:	fa c9 ff b4 	sub	r9,sp,-76
8000c040:	fe b0 f7 a2 	rcall	8000af84 <get_arg>
8000c044:	2f dd       	sub	sp,-12
8000c046:	f8 ea 00 00 	ld.d	r10,r12[0]
8000c04a:	fa eb 00 00 	st.d	sp[0],r10
8000c04e:	30 08       	mov	r8,0
8000c050:	e0 8f 03 de 	bral	8000c80c <_vfprintf_r+0x154c>
8000c054:	ee ca ff ff 	sub	r10,r7,-1
8000c058:	10 37       	cp.w	r7,r8
8000c05a:	c0 b4       	brge	8000c070 <_vfprintf_r+0xdb0>
8000c05c:	fa c9 f9 44 	sub	r9,sp,-1724
8000c060:	14 97       	mov	r7,r10
8000c062:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000c066:	ec ea fd 88 	ld.d	r10,r6[-632]
8000c06a:	fa eb 00 00 	st.d	sp[0],r10
8000c06e:	c1 88       	rjmp	8000c09e <_vfprintf_r+0xdde>
8000c070:	41 09       	lddsp	r9,sp[0x40]
8000c072:	59 f8       	cp.w	r8,31
8000c074:	e0 89 00 18 	brgt	8000c0a4 <_vfprintf_r+0xde4>
8000c078:	f2 e6 00 00 	ld.d	r6,r9[0]
8000c07c:	f2 cb ff f8 	sub	r11,r9,-8
8000c080:	fa e7 00 00 	st.d	sp[0],r6
8000c084:	51 0b       	stdsp	sp[0x40],r11
8000c086:	fa c6 f9 44 	sub	r6,sp,-1724
8000c08a:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000c08e:	fa e6 00 00 	ld.d	r6,sp[0]
8000c092:	f2 e7 fd 88 	st.d	r9[-632],r6
8000c096:	2f f8       	sub	r8,-1
8000c098:	14 97       	mov	r7,r10
8000c09a:	fb 48 06 b4 	st.w	sp[1716],r8
8000c09e:	40 38       	lddsp	r8,sp[0xc]
8000c0a0:	e0 8f 03 b6 	bral	8000c80c <_vfprintf_r+0x154c>
8000c0a4:	f2 e6 00 00 	ld.d	r6,r9[0]
8000c0a8:	40 38       	lddsp	r8,sp[0xc]
8000c0aa:	fa e7 00 00 	st.d	sp[0],r6
8000c0ae:	2f 89       	sub	r9,-8
8000c0b0:	14 97       	mov	r7,r10
8000c0b2:	51 09       	stdsp	sp[0x40],r9
8000c0b4:	e0 8f 03 ac 	bral	8000c80c <_vfprintf_r+0x154c>
8000c0b8:	ed b5 00 04 	bld	r5,0x4
8000c0bc:	c1 61       	brne	8000c0e8 <_vfprintf_r+0xe28>
8000c0be:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c0c2:	40 3e       	lddsp	lr,sp[0xc]
8000c0c4:	58 0e       	cp.w	lr,0
8000c0c6:	c0 80       	breq	8000c0d6 <_vfprintf_r+0xe16>
8000c0c8:	10 36       	cp.w	r6,r8
8000c0ca:	c6 74       	brge	8000c198 <_vfprintf_r+0xed8>
8000c0cc:	fa cc f9 44 	sub	r12,sp,-1724
8000c0d0:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000c0d4:	c8 08       	rjmp	8000c1d4 <_vfprintf_r+0xf14>
8000c0d6:	ee ca ff ff 	sub	r10,r7,-1
8000c0da:	10 37       	cp.w	r7,r8
8000c0dc:	c7 f4       	brge	8000c1da <_vfprintf_r+0xf1a>
8000c0de:	fa cb f9 44 	sub	r11,sp,-1724
8000c0e2:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000c0e6:	c7 68       	rjmp	8000c1d2 <_vfprintf_r+0xf12>
8000c0e8:	ed b5 00 06 	bld	r5,0x6
8000c0ec:	c4 a1       	brne	8000c180 <_vfprintf_r+0xec0>
8000c0ee:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c0f2:	40 3c       	lddsp	r12,sp[0xc]
8000c0f4:	58 0c       	cp.w	r12,0
8000c0f6:	c1 d0       	breq	8000c130 <_vfprintf_r+0xe70>
8000c0f8:	10 36       	cp.w	r6,r8
8000c0fa:	c0 64       	brge	8000c106 <_vfprintf_r+0xe46>
8000c0fc:	fa cb f9 44 	sub	r11,sp,-1724
8000c100:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000c104:	c1 f8       	rjmp	8000c142 <_vfprintf_r+0xe82>
8000c106:	fa c8 f9 50 	sub	r8,sp,-1712
8000c10a:	1a d8       	st.w	--sp,r8
8000c10c:	fa c8 fa b8 	sub	r8,sp,-1352
8000c110:	1a d8       	st.w	--sp,r8
8000c112:	fa c8 fb b4 	sub	r8,sp,-1100
8000c116:	1a d8       	st.w	--sp,r8
8000c118:	fa c8 f9 40 	sub	r8,sp,-1728
8000c11c:	fa c9 ff b4 	sub	r9,sp,-76
8000c120:	04 9a       	mov	r10,r2
8000c122:	0c 9b       	mov	r11,r6
8000c124:	08 9c       	mov	r12,r4
8000c126:	fe b0 f7 2f 	rcall	8000af84 <get_arg>
8000c12a:	2f dd       	sub	sp,-12
8000c12c:	98 18       	ld.sh	r8,r12[0x2]
8000c12e:	c2 68       	rjmp	8000c17a <_vfprintf_r+0xeba>
8000c130:	ee ca ff ff 	sub	r10,r7,-1
8000c134:	10 37       	cp.w	r7,r8
8000c136:	c0 94       	brge	8000c148 <_vfprintf_r+0xe88>
8000c138:	fa c9 f9 44 	sub	r9,sp,-1724
8000c13c:	14 97       	mov	r7,r10
8000c13e:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000c142:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000c146:	c1 a8       	rjmp	8000c17a <_vfprintf_r+0xeba>
8000c148:	41 09       	lddsp	r9,sp[0x40]
8000c14a:	59 f8       	cp.w	r8,31
8000c14c:	e0 89 00 13 	brgt	8000c172 <_vfprintf_r+0xeb2>
8000c150:	f2 cb ff fc 	sub	r11,r9,-4
8000c154:	51 0b       	stdsp	sp[0x40],r11
8000c156:	72 09       	ld.w	r9,r9[0x0]
8000c158:	fa c6 f9 44 	sub	r6,sp,-1724
8000c15c:	ec 08 00 3b 	add	r11,r6,r8<<0x3
8000c160:	2f f8       	sub	r8,-1
8000c162:	f7 49 fd 88 	st.w	r11[-632],r9
8000c166:	fb 48 06 b4 	st.w	sp[1716],r8
8000c16a:	14 97       	mov	r7,r10
8000c16c:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
8000c170:	c0 58       	rjmp	8000c17a <_vfprintf_r+0xeba>
8000c172:	92 18       	ld.sh	r8,r9[0x2]
8000c174:	14 97       	mov	r7,r10
8000c176:	2f c9       	sub	r9,-4
8000c178:	51 09       	stdsp	sp[0x40],r9
8000c17a:	5c 78       	castu.h	r8
8000c17c:	50 18       	stdsp	sp[0x4],r8
8000c17e:	c4 68       	rjmp	8000c20a <_vfprintf_r+0xf4a>
8000c180:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c184:	40 3c       	lddsp	r12,sp[0xc]
8000c186:	58 0c       	cp.w	r12,0
8000c188:	c1 d0       	breq	8000c1c2 <_vfprintf_r+0xf02>
8000c18a:	10 36       	cp.w	r6,r8
8000c18c:	c0 64       	brge	8000c198 <_vfprintf_r+0xed8>
8000c18e:	fa cb f9 44 	sub	r11,sp,-1724
8000c192:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000c196:	c1 f8       	rjmp	8000c1d4 <_vfprintf_r+0xf14>
8000c198:	fa c8 f9 50 	sub	r8,sp,-1712
8000c19c:	1a d8       	st.w	--sp,r8
8000c19e:	fa c8 fa b8 	sub	r8,sp,-1352
8000c1a2:	0c 9b       	mov	r11,r6
8000c1a4:	1a d8       	st.w	--sp,r8
8000c1a6:	fa c8 fb b4 	sub	r8,sp,-1100
8000c1aa:	04 9a       	mov	r10,r2
8000c1ac:	1a d8       	st.w	--sp,r8
8000c1ae:	08 9c       	mov	r12,r4
8000c1b0:	fa c8 f9 40 	sub	r8,sp,-1728
8000c1b4:	fa c9 ff b4 	sub	r9,sp,-76
8000c1b8:	fe b0 f6 e6 	rcall	8000af84 <get_arg>
8000c1bc:	2f dd       	sub	sp,-12
8000c1be:	78 0b       	ld.w	r11,r12[0x0]
8000c1c0:	c2 48       	rjmp	8000c208 <_vfprintf_r+0xf48>
8000c1c2:	ee ca ff ff 	sub	r10,r7,-1
8000c1c6:	10 37       	cp.w	r7,r8
8000c1c8:	c0 94       	brge	8000c1da <_vfprintf_r+0xf1a>
8000c1ca:	fa c9 f9 44 	sub	r9,sp,-1724
8000c1ce:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000c1d2:	14 97       	mov	r7,r10
8000c1d4:	ec fb fd 88 	ld.w	r11,r6[-632]
8000c1d8:	c1 88       	rjmp	8000c208 <_vfprintf_r+0xf48>
8000c1da:	41 09       	lddsp	r9,sp[0x40]
8000c1dc:	59 f8       	cp.w	r8,31
8000c1de:	e0 89 00 11 	brgt	8000c200 <_vfprintf_r+0xf40>
8000c1e2:	f2 cb ff fc 	sub	r11,r9,-4
8000c1e6:	51 0b       	stdsp	sp[0x40],r11
8000c1e8:	fa c6 f9 44 	sub	r6,sp,-1724
8000c1ec:	72 0b       	ld.w	r11,r9[0x0]
8000c1ee:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000c1f2:	f3 4b fd 88 	st.w	r9[-632],r11
8000c1f6:	2f f8       	sub	r8,-1
8000c1f8:	14 97       	mov	r7,r10
8000c1fa:	fb 48 06 b4 	st.w	sp[1716],r8
8000c1fe:	c0 58       	rjmp	8000c208 <_vfprintf_r+0xf48>
8000c200:	72 0b       	ld.w	r11,r9[0x0]
8000c202:	14 97       	mov	r7,r10
8000c204:	2f c9       	sub	r9,-4
8000c206:	51 09       	stdsp	sp[0x40],r9
8000c208:	50 1b       	stdsp	sp[0x4],r11
8000c20a:	30 0e       	mov	lr,0
8000c20c:	50 0e       	stdsp	sp[0x0],lr
8000c20e:	1c 98       	mov	r8,lr
8000c210:	e0 8f 02 fe 	bral	8000c80c <_vfprintf_r+0x154c>
8000c214:	50 a7       	stdsp	sp[0x28],r7
8000c216:	50 80       	stdsp	sp[0x20],r0
8000c218:	0c 97       	mov	r7,r6
8000c21a:	04 94       	mov	r4,r2
8000c21c:	06 96       	mov	r6,r3
8000c21e:	02 92       	mov	r2,r1
8000c220:	40 93       	lddsp	r3,sp[0x24]
8000c222:	40 41       	lddsp	r1,sp[0x10]
8000c224:	0e 99       	mov	r9,r7
8000c226:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c22a:	40 3c       	lddsp	r12,sp[0xc]
8000c22c:	58 0c       	cp.w	r12,0
8000c22e:	c1 d0       	breq	8000c268 <_vfprintf_r+0xfa8>
8000c230:	10 36       	cp.w	r6,r8
8000c232:	c0 64       	brge	8000c23e <_vfprintf_r+0xf7e>
8000c234:	fa cb f9 44 	sub	r11,sp,-1724
8000c238:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000c23c:	c1 d8       	rjmp	8000c276 <_vfprintf_r+0xfb6>
8000c23e:	fa c8 f9 50 	sub	r8,sp,-1712
8000c242:	1a d8       	st.w	--sp,r8
8000c244:	fa c8 fa b8 	sub	r8,sp,-1352
8000c248:	1a d8       	st.w	--sp,r8
8000c24a:	fa c8 fb b4 	sub	r8,sp,-1100
8000c24e:	1a d8       	st.w	--sp,r8
8000c250:	fa c9 ff b4 	sub	r9,sp,-76
8000c254:	fa c8 f9 40 	sub	r8,sp,-1728
8000c258:	04 9a       	mov	r10,r2
8000c25a:	0c 9b       	mov	r11,r6
8000c25c:	08 9c       	mov	r12,r4
8000c25e:	fe b0 f6 93 	rcall	8000af84 <get_arg>
8000c262:	2f dd       	sub	sp,-12
8000c264:	78 09       	ld.w	r9,r12[0x0]
8000c266:	c2 18       	rjmp	8000c2a8 <_vfprintf_r+0xfe8>
8000c268:	2f f7       	sub	r7,-1
8000c26a:	10 39       	cp.w	r9,r8
8000c26c:	c0 84       	brge	8000c27c <_vfprintf_r+0xfbc>
8000c26e:	fa ca f9 44 	sub	r10,sp,-1724
8000c272:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000c276:	ec f9 fd 88 	ld.w	r9,r6[-632]
8000c27a:	c1 78       	rjmp	8000c2a8 <_vfprintf_r+0xfe8>
8000c27c:	41 09       	lddsp	r9,sp[0x40]
8000c27e:	59 f8       	cp.w	r8,31
8000c280:	e0 89 00 10 	brgt	8000c2a0 <_vfprintf_r+0xfe0>
8000c284:	f2 ca ff fc 	sub	r10,r9,-4
8000c288:	51 0a       	stdsp	sp[0x40],r10
8000c28a:	fa c6 f9 44 	sub	r6,sp,-1724
8000c28e:	72 09       	ld.w	r9,r9[0x0]
8000c290:	ec 08 00 3a 	add	r10,r6,r8<<0x3
8000c294:	f5 49 fd 88 	st.w	r10[-632],r9
8000c298:	2f f8       	sub	r8,-1
8000c29a:	fb 48 06 b4 	st.w	sp[1716],r8
8000c29e:	c0 58       	rjmp	8000c2a8 <_vfprintf_r+0xfe8>
8000c2a0:	f2 c8 ff fc 	sub	r8,r9,-4
8000c2a4:	51 08       	stdsp	sp[0x40],r8
8000c2a6:	72 09       	ld.w	r9,r9[0x0]
8000c2a8:	33 08       	mov	r8,48
8000c2aa:	fb 68 06 b8 	st.b	sp[1720],r8
8000c2ae:	37 88       	mov	r8,120
8000c2b0:	30 0e       	mov	lr,0
8000c2b2:	fb 68 06 b9 	st.b	sp[1721],r8
8000c2b6:	4c ac       	lddpc	r12,8000c3dc <_vfprintf_r+0x111c>
8000c2b8:	50 19       	stdsp	sp[0x4],r9
8000c2ba:	a1 b5       	sbr	r5,0x1
8000c2bc:	50 0e       	stdsp	sp[0x0],lr
8000c2be:	50 dc       	stdsp	sp[0x34],r12
8000c2c0:	30 28       	mov	r8,2
8000c2c2:	37 80       	mov	r0,120
8000c2c4:	e0 8f 02 a4 	bral	8000c80c <_vfprintf_r+0x154c>
8000c2c8:	50 a7       	stdsp	sp[0x28],r7
8000c2ca:	50 80       	stdsp	sp[0x20],r0
8000c2cc:	10 90       	mov	r0,r8
8000c2ce:	30 08       	mov	r8,0
8000c2d0:	fb 68 06 bb 	st.b	sp[1723],r8
8000c2d4:	0c 97       	mov	r7,r6
8000c2d6:	04 94       	mov	r4,r2
8000c2d8:	06 96       	mov	r6,r3
8000c2da:	02 92       	mov	r2,r1
8000c2dc:	40 93       	lddsp	r3,sp[0x24]
8000c2de:	40 41       	lddsp	r1,sp[0x10]
8000c2e0:	0e 99       	mov	r9,r7
8000c2e2:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c2e6:	40 3b       	lddsp	r11,sp[0xc]
8000c2e8:	58 0b       	cp.w	r11,0
8000c2ea:	c1 d0       	breq	8000c324 <_vfprintf_r+0x1064>
8000c2ec:	10 36       	cp.w	r6,r8
8000c2ee:	c0 64       	brge	8000c2fa <_vfprintf_r+0x103a>
8000c2f0:	fa ca f9 44 	sub	r10,sp,-1724
8000c2f4:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000c2f8:	c1 d8       	rjmp	8000c332 <_vfprintf_r+0x1072>
8000c2fa:	fa c8 f9 50 	sub	r8,sp,-1712
8000c2fe:	1a d8       	st.w	--sp,r8
8000c300:	fa c8 fa b8 	sub	r8,sp,-1352
8000c304:	1a d8       	st.w	--sp,r8
8000c306:	fa c8 fb b4 	sub	r8,sp,-1100
8000c30a:	0c 9b       	mov	r11,r6
8000c30c:	1a d8       	st.w	--sp,r8
8000c30e:	04 9a       	mov	r10,r2
8000c310:	fa c8 f9 40 	sub	r8,sp,-1728
8000c314:	fa c9 ff b4 	sub	r9,sp,-76
8000c318:	08 9c       	mov	r12,r4
8000c31a:	fe b0 f6 35 	rcall	8000af84 <get_arg>
8000c31e:	2f dd       	sub	sp,-12
8000c320:	78 06       	ld.w	r6,r12[0x0]
8000c322:	c2 08       	rjmp	8000c362 <_vfprintf_r+0x10a2>
8000c324:	2f f7       	sub	r7,-1
8000c326:	10 39       	cp.w	r9,r8
8000c328:	c0 84       	brge	8000c338 <_vfprintf_r+0x1078>
8000c32a:	fa c9 f9 44 	sub	r9,sp,-1724
8000c32e:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000c332:	ec f6 fd 88 	ld.w	r6,r6[-632]
8000c336:	c1 68       	rjmp	8000c362 <_vfprintf_r+0x10a2>
8000c338:	41 09       	lddsp	r9,sp[0x40]
8000c33a:	59 f8       	cp.w	r8,31
8000c33c:	e0 89 00 10 	brgt	8000c35c <_vfprintf_r+0x109c>
8000c340:	f2 ca ff fc 	sub	r10,r9,-4
8000c344:	51 0a       	stdsp	sp[0x40],r10
8000c346:	72 06       	ld.w	r6,r9[0x0]
8000c348:	fa ce f9 44 	sub	lr,sp,-1724
8000c34c:	fc 08 00 39 	add	r9,lr,r8<<0x3
8000c350:	f3 46 fd 88 	st.w	r9[-632],r6
8000c354:	2f f8       	sub	r8,-1
8000c356:	fb 48 06 b4 	st.w	sp[1716],r8
8000c35a:	c0 48       	rjmp	8000c362 <_vfprintf_r+0x10a2>
8000c35c:	72 06       	ld.w	r6,r9[0x0]
8000c35e:	2f c9       	sub	r9,-4
8000c360:	51 09       	stdsp	sp[0x40],r9
8000c362:	40 2c       	lddsp	r12,sp[0x8]
8000c364:	58 0c       	cp.w	r12,0
8000c366:	c1 05       	brlt	8000c386 <_vfprintf_r+0x10c6>
8000c368:	18 9a       	mov	r10,r12
8000c36a:	30 0b       	mov	r11,0
8000c36c:	0c 9c       	mov	r12,r6
8000c36e:	e0 a0 12 43 	rcall	8000e7f4 <memchr>
8000c372:	e0 80 02 e0 	breq	8000c932 <_vfprintf_r+0x1672>
8000c376:	f8 06 01 02 	sub	r2,r12,r6
8000c37a:	40 2b       	lddsp	r11,sp[0x8]
8000c37c:	16 32       	cp.w	r2,r11
8000c37e:	e0 89 02 da 	brgt	8000c932 <_vfprintf_r+0x1672>
8000c382:	e0 8f 02 d5 	bral	8000c92c <_vfprintf_r+0x166c>
8000c386:	30 0a       	mov	r10,0
8000c388:	0c 9c       	mov	r12,r6
8000c38a:	50 2a       	stdsp	sp[0x8],r10
8000c38c:	fe b0 f4 ff 	rcall	8000ad8a <strlen>
8000c390:	18 92       	mov	r2,r12
8000c392:	e0 8f 02 d3 	bral	8000c938 <_vfprintf_r+0x1678>
8000c396:	50 a7       	stdsp	sp[0x28],r7
8000c398:	50 80       	stdsp	sp[0x20],r0
8000c39a:	0c 97       	mov	r7,r6
8000c39c:	04 94       	mov	r4,r2
8000c39e:	06 96       	mov	r6,r3
8000c3a0:	02 92       	mov	r2,r1
8000c3a2:	40 93       	lddsp	r3,sp[0x24]
8000c3a4:	10 90       	mov	r0,r8
8000c3a6:	40 41       	lddsp	r1,sp[0x10]
8000c3a8:	a5 a5       	sbr	r5,0x4
8000c3aa:	c0 a8       	rjmp	8000c3be <_vfprintf_r+0x10fe>
8000c3ac:	50 a7       	stdsp	sp[0x28],r7
8000c3ae:	50 80       	stdsp	sp[0x20],r0
8000c3b0:	0c 97       	mov	r7,r6
8000c3b2:	04 94       	mov	r4,r2
8000c3b4:	06 96       	mov	r6,r3
8000c3b6:	02 92       	mov	r2,r1
8000c3b8:	40 93       	lddsp	r3,sp[0x24]
8000c3ba:	10 90       	mov	r0,r8
8000c3bc:	40 41       	lddsp	r1,sp[0x10]
8000c3be:	ed b5 00 05 	bld	r5,0x5
8000c3c2:	c5 71       	brne	8000c470 <_vfprintf_r+0x11b0>
8000c3c4:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c3c8:	40 39       	lddsp	r9,sp[0xc]
8000c3ca:	58 09       	cp.w	r9,0
8000c3cc:	c2 20       	breq	8000c410 <_vfprintf_r+0x1150>
8000c3ce:	10 36       	cp.w	r6,r8
8000c3d0:	c0 84       	brge	8000c3e0 <_vfprintf_r+0x1120>
8000c3d2:	fa c8 f9 44 	sub	r8,sp,-1724
8000c3d6:	f0 06 00 36 	add	r6,r8,r6<<0x3
8000c3da:	c2 48       	rjmp	8000c422 <_vfprintf_r+0x1162>
8000c3dc:	80 01       	ld.sh	r1,r0[0x0]
8000c3de:	95 a0       	st.w	r10[0x28],r0
8000c3e0:	fa c8 f9 50 	sub	r8,sp,-1712
8000c3e4:	1a d8       	st.w	--sp,r8
8000c3e6:	fa c8 fa b8 	sub	r8,sp,-1352
8000c3ea:	1a d8       	st.w	--sp,r8
8000c3ec:	fa c8 fb b4 	sub	r8,sp,-1100
8000c3f0:	1a d8       	st.w	--sp,r8
8000c3f2:	fa c8 f9 40 	sub	r8,sp,-1728
8000c3f6:	fa c9 ff b4 	sub	r9,sp,-76
8000c3fa:	04 9a       	mov	r10,r2
8000c3fc:	0c 9b       	mov	r11,r6
8000c3fe:	08 9c       	mov	r12,r4
8000c400:	fe b0 f5 c2 	rcall	8000af84 <get_arg>
8000c404:	2f dd       	sub	sp,-12
8000c406:	f8 e8 00 00 	ld.d	r8,r12[0]
8000c40a:	fa e9 00 00 	st.d	sp[0],r8
8000c40e:	c2 e8       	rjmp	8000c46a <_vfprintf_r+0x11aa>
8000c410:	ee ca ff ff 	sub	r10,r7,-1
8000c414:	10 37       	cp.w	r7,r8
8000c416:	c0 b4       	brge	8000c42c <_vfprintf_r+0x116c>
8000c418:	fa c8 f9 44 	sub	r8,sp,-1724
8000c41c:	14 97       	mov	r7,r10
8000c41e:	f0 06 00 36 	add	r6,r8,r6<<0x3
8000c422:	ec ea fd 88 	ld.d	r10,r6[-632]
8000c426:	fa eb 00 00 	st.d	sp[0],r10
8000c42a:	c2 08       	rjmp	8000c46a <_vfprintf_r+0x11aa>
8000c42c:	41 09       	lddsp	r9,sp[0x40]
8000c42e:	59 f8       	cp.w	r8,31
8000c430:	e0 89 00 16 	brgt	8000c45c <_vfprintf_r+0x119c>
8000c434:	f2 e6 00 00 	ld.d	r6,r9[0]
8000c438:	f2 cb ff f8 	sub	r11,r9,-8
8000c43c:	fa e7 00 00 	st.d	sp[0],r6
8000c440:	51 0b       	stdsp	sp[0x40],r11
8000c442:	fa c6 f9 44 	sub	r6,sp,-1724
8000c446:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000c44a:	fa e6 00 00 	ld.d	r6,sp[0]
8000c44e:	f2 e7 fd 88 	st.d	r9[-632],r6
8000c452:	2f f8       	sub	r8,-1
8000c454:	14 97       	mov	r7,r10
8000c456:	fb 48 06 b4 	st.w	sp[1716],r8
8000c45a:	c0 88       	rjmp	8000c46a <_vfprintf_r+0x11aa>
8000c45c:	f2 e6 00 00 	ld.d	r6,r9[0]
8000c460:	2f 89       	sub	r9,-8
8000c462:	fa e7 00 00 	st.d	sp[0],r6
8000c466:	51 09       	stdsp	sp[0x40],r9
8000c468:	14 97       	mov	r7,r10
8000c46a:	30 18       	mov	r8,1
8000c46c:	e0 8f 01 d0 	bral	8000c80c <_vfprintf_r+0x154c>
8000c470:	ed b5 00 04 	bld	r5,0x4
8000c474:	c1 61       	brne	8000c4a0 <_vfprintf_r+0x11e0>
8000c476:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c47a:	40 3e       	lddsp	lr,sp[0xc]
8000c47c:	58 0e       	cp.w	lr,0
8000c47e:	c0 80       	breq	8000c48e <_vfprintf_r+0x11ce>
8000c480:	10 36       	cp.w	r6,r8
8000c482:	c6 74       	brge	8000c550 <_vfprintf_r+0x1290>
8000c484:	fa cc f9 44 	sub	r12,sp,-1724
8000c488:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000c48c:	c8 08       	rjmp	8000c58c <_vfprintf_r+0x12cc>
8000c48e:	ee ca ff ff 	sub	r10,r7,-1
8000c492:	10 37       	cp.w	r7,r8
8000c494:	c7 f4       	brge	8000c592 <_vfprintf_r+0x12d2>
8000c496:	fa cb f9 44 	sub	r11,sp,-1724
8000c49a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000c49e:	c7 68       	rjmp	8000c58a <_vfprintf_r+0x12ca>
8000c4a0:	ed b5 00 06 	bld	r5,0x6
8000c4a4:	c4 a1       	brne	8000c538 <_vfprintf_r+0x1278>
8000c4a6:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c4aa:	40 3c       	lddsp	r12,sp[0xc]
8000c4ac:	58 0c       	cp.w	r12,0
8000c4ae:	c1 d0       	breq	8000c4e8 <_vfprintf_r+0x1228>
8000c4b0:	10 36       	cp.w	r6,r8
8000c4b2:	c0 64       	brge	8000c4be <_vfprintf_r+0x11fe>
8000c4b4:	fa cb f9 44 	sub	r11,sp,-1724
8000c4b8:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000c4bc:	c1 f8       	rjmp	8000c4fa <_vfprintf_r+0x123a>
8000c4be:	fa c8 f9 50 	sub	r8,sp,-1712
8000c4c2:	1a d8       	st.w	--sp,r8
8000c4c4:	fa c8 fa b8 	sub	r8,sp,-1352
8000c4c8:	1a d8       	st.w	--sp,r8
8000c4ca:	fa c8 fb b4 	sub	r8,sp,-1100
8000c4ce:	1a d8       	st.w	--sp,r8
8000c4d0:	fa c8 f9 40 	sub	r8,sp,-1728
8000c4d4:	fa c9 ff b4 	sub	r9,sp,-76
8000c4d8:	04 9a       	mov	r10,r2
8000c4da:	0c 9b       	mov	r11,r6
8000c4dc:	08 9c       	mov	r12,r4
8000c4de:	fe b0 f5 53 	rcall	8000af84 <get_arg>
8000c4e2:	2f dd       	sub	sp,-12
8000c4e4:	98 18       	ld.sh	r8,r12[0x2]
8000c4e6:	c2 68       	rjmp	8000c532 <_vfprintf_r+0x1272>
8000c4e8:	ee ca ff ff 	sub	r10,r7,-1
8000c4ec:	10 37       	cp.w	r7,r8
8000c4ee:	c0 94       	brge	8000c500 <_vfprintf_r+0x1240>
8000c4f0:	fa c9 f9 44 	sub	r9,sp,-1724
8000c4f4:	14 97       	mov	r7,r10
8000c4f6:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000c4fa:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000c4fe:	c1 a8       	rjmp	8000c532 <_vfprintf_r+0x1272>
8000c500:	41 09       	lddsp	r9,sp[0x40]
8000c502:	59 f8       	cp.w	r8,31
8000c504:	e0 89 00 13 	brgt	8000c52a <_vfprintf_r+0x126a>
8000c508:	f2 cb ff fc 	sub	r11,r9,-4
8000c50c:	51 0b       	stdsp	sp[0x40],r11
8000c50e:	72 09       	ld.w	r9,r9[0x0]
8000c510:	fa c6 f9 44 	sub	r6,sp,-1724
8000c514:	ec 08 00 3b 	add	r11,r6,r8<<0x3
8000c518:	2f f8       	sub	r8,-1
8000c51a:	f7 49 fd 88 	st.w	r11[-632],r9
8000c51e:	fb 48 06 b4 	st.w	sp[1716],r8
8000c522:	14 97       	mov	r7,r10
8000c524:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
8000c528:	c0 58       	rjmp	8000c532 <_vfprintf_r+0x1272>
8000c52a:	92 18       	ld.sh	r8,r9[0x2]
8000c52c:	14 97       	mov	r7,r10
8000c52e:	2f c9       	sub	r9,-4
8000c530:	51 09       	stdsp	sp[0x40],r9
8000c532:	5c 78       	castu.h	r8
8000c534:	50 18       	stdsp	sp[0x4],r8
8000c536:	c4 68       	rjmp	8000c5c2 <_vfprintf_r+0x1302>
8000c538:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c53c:	40 3c       	lddsp	r12,sp[0xc]
8000c53e:	58 0c       	cp.w	r12,0
8000c540:	c1 d0       	breq	8000c57a <_vfprintf_r+0x12ba>
8000c542:	10 36       	cp.w	r6,r8
8000c544:	c0 64       	brge	8000c550 <_vfprintf_r+0x1290>
8000c546:	fa cb f9 44 	sub	r11,sp,-1724
8000c54a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000c54e:	c1 f8       	rjmp	8000c58c <_vfprintf_r+0x12cc>
8000c550:	fa c8 f9 50 	sub	r8,sp,-1712
8000c554:	1a d8       	st.w	--sp,r8
8000c556:	fa c8 fa b8 	sub	r8,sp,-1352
8000c55a:	0c 9b       	mov	r11,r6
8000c55c:	1a d8       	st.w	--sp,r8
8000c55e:	fa c8 fb b4 	sub	r8,sp,-1100
8000c562:	04 9a       	mov	r10,r2
8000c564:	1a d8       	st.w	--sp,r8
8000c566:	08 9c       	mov	r12,r4
8000c568:	fa c8 f9 40 	sub	r8,sp,-1728
8000c56c:	fa c9 ff b4 	sub	r9,sp,-76
8000c570:	fe b0 f5 0a 	rcall	8000af84 <get_arg>
8000c574:	2f dd       	sub	sp,-12
8000c576:	78 0b       	ld.w	r11,r12[0x0]
8000c578:	c2 48       	rjmp	8000c5c0 <_vfprintf_r+0x1300>
8000c57a:	ee ca ff ff 	sub	r10,r7,-1
8000c57e:	10 37       	cp.w	r7,r8
8000c580:	c0 94       	brge	8000c592 <_vfprintf_r+0x12d2>
8000c582:	fa c9 f9 44 	sub	r9,sp,-1724
8000c586:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000c58a:	14 97       	mov	r7,r10
8000c58c:	ec fb fd 88 	ld.w	r11,r6[-632]
8000c590:	c1 88       	rjmp	8000c5c0 <_vfprintf_r+0x1300>
8000c592:	41 09       	lddsp	r9,sp[0x40]
8000c594:	59 f8       	cp.w	r8,31
8000c596:	e0 89 00 11 	brgt	8000c5b8 <_vfprintf_r+0x12f8>
8000c59a:	f2 cb ff fc 	sub	r11,r9,-4
8000c59e:	51 0b       	stdsp	sp[0x40],r11
8000c5a0:	fa c6 f9 44 	sub	r6,sp,-1724
8000c5a4:	72 0b       	ld.w	r11,r9[0x0]
8000c5a6:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000c5aa:	f3 4b fd 88 	st.w	r9[-632],r11
8000c5ae:	2f f8       	sub	r8,-1
8000c5b0:	14 97       	mov	r7,r10
8000c5b2:	fb 48 06 b4 	st.w	sp[1716],r8
8000c5b6:	c0 58       	rjmp	8000c5c0 <_vfprintf_r+0x1300>
8000c5b8:	72 0b       	ld.w	r11,r9[0x0]
8000c5ba:	14 97       	mov	r7,r10
8000c5bc:	2f c9       	sub	r9,-4
8000c5be:	51 09       	stdsp	sp[0x40],r9
8000c5c0:	50 1b       	stdsp	sp[0x4],r11
8000c5c2:	30 0e       	mov	lr,0
8000c5c4:	30 18       	mov	r8,1
8000c5c6:	50 0e       	stdsp	sp[0x0],lr
8000c5c8:	c2 29       	rjmp	8000c80c <_vfprintf_r+0x154c>
8000c5ca:	50 a7       	stdsp	sp[0x28],r7
8000c5cc:	50 80       	stdsp	sp[0x20],r0
8000c5ce:	0c 97       	mov	r7,r6
8000c5d0:	04 94       	mov	r4,r2
8000c5d2:	06 96       	mov	r6,r3
8000c5d4:	02 92       	mov	r2,r1
8000c5d6:	4d 3c       	lddpc	r12,8000c720 <_vfprintf_r+0x1460>
8000c5d8:	40 93       	lddsp	r3,sp[0x24]
8000c5da:	10 90       	mov	r0,r8
8000c5dc:	40 41       	lddsp	r1,sp[0x10]
8000c5de:	50 dc       	stdsp	sp[0x34],r12
8000c5e0:	ed b5 00 05 	bld	r5,0x5
8000c5e4:	c5 51       	brne	8000c68e <_vfprintf_r+0x13ce>
8000c5e6:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c5ea:	40 3b       	lddsp	r11,sp[0xc]
8000c5ec:	58 0b       	cp.w	r11,0
8000c5ee:	c2 20       	breq	8000c632 <_vfprintf_r+0x1372>
8000c5f0:	10 36       	cp.w	r6,r8
8000c5f2:	c0 a4       	brge	8000c606 <_vfprintf_r+0x1346>
8000c5f4:	fa ca f9 44 	sub	r10,sp,-1724
8000c5f8:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000c5fc:	ec e8 fd 88 	ld.d	r8,r6[-632]
8000c600:	fa e9 00 00 	st.d	sp[0],r8
8000c604:	cf 38       	rjmp	8000c7ea <_vfprintf_r+0x152a>
8000c606:	fa c8 f9 50 	sub	r8,sp,-1712
8000c60a:	1a d8       	st.w	--sp,r8
8000c60c:	fa c8 fa b8 	sub	r8,sp,-1352
8000c610:	04 9a       	mov	r10,r2
8000c612:	1a d8       	st.w	--sp,r8
8000c614:	0c 9b       	mov	r11,r6
8000c616:	fa c8 fb b4 	sub	r8,sp,-1100
8000c61a:	08 9c       	mov	r12,r4
8000c61c:	1a d8       	st.w	--sp,r8
8000c61e:	fa c8 f9 40 	sub	r8,sp,-1728
8000c622:	fa c9 ff b4 	sub	r9,sp,-76
8000c626:	fe b0 f4 af 	rcall	8000af84 <get_arg>
8000c62a:	2f dd       	sub	sp,-12
8000c62c:	f8 ea 00 00 	ld.d	r10,r12[0]
8000c630:	c0 c8       	rjmp	8000c648 <_vfprintf_r+0x1388>
8000c632:	ee ca ff ff 	sub	r10,r7,-1
8000c636:	10 37       	cp.w	r7,r8
8000c638:	c0 b4       	brge	8000c64e <_vfprintf_r+0x138e>
8000c63a:	fa c9 f9 44 	sub	r9,sp,-1724
8000c63e:	14 97       	mov	r7,r10
8000c640:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000c644:	ec ea fd 88 	ld.d	r10,r6[-632]
8000c648:	fa eb 00 00 	st.d	sp[0],r10
8000c64c:	cc f8       	rjmp	8000c7ea <_vfprintf_r+0x152a>
8000c64e:	41 09       	lddsp	r9,sp[0x40]
8000c650:	59 f8       	cp.w	r8,31
8000c652:	e0 89 00 16 	brgt	8000c67e <_vfprintf_r+0x13be>
8000c656:	f2 e6 00 00 	ld.d	r6,r9[0]
8000c65a:	f2 cb ff f8 	sub	r11,r9,-8
8000c65e:	fa e7 00 00 	st.d	sp[0],r6
8000c662:	51 0b       	stdsp	sp[0x40],r11
8000c664:	fa c6 f9 44 	sub	r6,sp,-1724
8000c668:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000c66c:	fa e6 00 00 	ld.d	r6,sp[0]
8000c670:	f2 e7 fd 88 	st.d	r9[-632],r6
8000c674:	2f f8       	sub	r8,-1
8000c676:	14 97       	mov	r7,r10
8000c678:	fb 48 06 b4 	st.w	sp[1716],r8
8000c67c:	cb 78       	rjmp	8000c7ea <_vfprintf_r+0x152a>
8000c67e:	f2 e6 00 00 	ld.d	r6,r9[0]
8000c682:	2f 89       	sub	r9,-8
8000c684:	fa e7 00 00 	st.d	sp[0],r6
8000c688:	51 09       	stdsp	sp[0x40],r9
8000c68a:	14 97       	mov	r7,r10
8000c68c:	ca f8       	rjmp	8000c7ea <_vfprintf_r+0x152a>
8000c68e:	ed b5 00 04 	bld	r5,0x4
8000c692:	c1 71       	brne	8000c6c0 <_vfprintf_r+0x1400>
8000c694:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c698:	40 3e       	lddsp	lr,sp[0xc]
8000c69a:	58 0e       	cp.w	lr,0
8000c69c:	c0 80       	breq	8000c6ac <_vfprintf_r+0x13ec>
8000c69e:	10 36       	cp.w	r6,r8
8000c6a0:	c6 a4       	brge	8000c774 <_vfprintf_r+0x14b4>
8000c6a2:	fa cc f9 44 	sub	r12,sp,-1724
8000c6a6:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000c6aa:	c8 38       	rjmp	8000c7b0 <_vfprintf_r+0x14f0>
8000c6ac:	ee ca ff ff 	sub	r10,r7,-1
8000c6b0:	10 37       	cp.w	r7,r8
8000c6b2:	e0 84 00 82 	brge	8000c7b6 <_vfprintf_r+0x14f6>
8000c6b6:	fa cb f9 44 	sub	r11,sp,-1724
8000c6ba:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000c6be:	c7 88       	rjmp	8000c7ae <_vfprintf_r+0x14ee>
8000c6c0:	ed b5 00 06 	bld	r5,0x6
8000c6c4:	c4 c1       	brne	8000c75c <_vfprintf_r+0x149c>
8000c6c6:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c6ca:	40 3c       	lddsp	r12,sp[0xc]
8000c6cc:	58 0c       	cp.w	r12,0
8000c6ce:	c1 d0       	breq	8000c708 <_vfprintf_r+0x1448>
8000c6d0:	10 36       	cp.w	r6,r8
8000c6d2:	c0 64       	brge	8000c6de <_vfprintf_r+0x141e>
8000c6d4:	fa cb f9 44 	sub	r11,sp,-1724
8000c6d8:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000c6dc:	c1 f8       	rjmp	8000c71a <_vfprintf_r+0x145a>
8000c6de:	fa c8 f9 50 	sub	r8,sp,-1712
8000c6e2:	1a d8       	st.w	--sp,r8
8000c6e4:	fa c8 fa b8 	sub	r8,sp,-1352
8000c6e8:	1a d8       	st.w	--sp,r8
8000c6ea:	fa c8 fb b4 	sub	r8,sp,-1100
8000c6ee:	1a d8       	st.w	--sp,r8
8000c6f0:	fa c8 f9 40 	sub	r8,sp,-1728
8000c6f4:	fa c9 ff b4 	sub	r9,sp,-76
8000c6f8:	04 9a       	mov	r10,r2
8000c6fa:	0c 9b       	mov	r11,r6
8000c6fc:	08 9c       	mov	r12,r4
8000c6fe:	fe b0 f4 43 	rcall	8000af84 <get_arg>
8000c702:	2f dd       	sub	sp,-12
8000c704:	98 18       	ld.sh	r8,r12[0x2]
8000c706:	c2 88       	rjmp	8000c756 <_vfprintf_r+0x1496>
8000c708:	ee ca ff ff 	sub	r10,r7,-1
8000c70c:	10 37       	cp.w	r7,r8
8000c70e:	c0 b4       	brge	8000c724 <_vfprintf_r+0x1464>
8000c710:	fa c9 f9 44 	sub	r9,sp,-1724
8000c714:	14 97       	mov	r7,r10
8000c716:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000c71a:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000c71e:	c1 c8       	rjmp	8000c756 <_vfprintf_r+0x1496>
8000c720:	80 01       	ld.sh	r1,r0[0x0]
8000c722:	95 a0       	st.w	r10[0x28],r0
8000c724:	41 09       	lddsp	r9,sp[0x40]
8000c726:	59 f8       	cp.w	r8,31
8000c728:	e0 89 00 13 	brgt	8000c74e <_vfprintf_r+0x148e>
8000c72c:	f2 cb ff fc 	sub	r11,r9,-4
8000c730:	51 0b       	stdsp	sp[0x40],r11
8000c732:	72 09       	ld.w	r9,r9[0x0]
8000c734:	fa c6 f9 44 	sub	r6,sp,-1724
8000c738:	ec 08 00 3b 	add	r11,r6,r8<<0x3
8000c73c:	2f f8       	sub	r8,-1
8000c73e:	f7 49 fd 88 	st.w	r11[-632],r9
8000c742:	fb 48 06 b4 	st.w	sp[1716],r8
8000c746:	14 97       	mov	r7,r10
8000c748:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
8000c74c:	c0 58       	rjmp	8000c756 <_vfprintf_r+0x1496>
8000c74e:	92 18       	ld.sh	r8,r9[0x2]
8000c750:	14 97       	mov	r7,r10
8000c752:	2f c9       	sub	r9,-4
8000c754:	51 09       	stdsp	sp[0x40],r9
8000c756:	5c 78       	castu.h	r8
8000c758:	50 18       	stdsp	sp[0x4],r8
8000c75a:	c4 68       	rjmp	8000c7e6 <_vfprintf_r+0x1526>
8000c75c:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c760:	40 3c       	lddsp	r12,sp[0xc]
8000c762:	58 0c       	cp.w	r12,0
8000c764:	c1 d0       	breq	8000c79e <_vfprintf_r+0x14de>
8000c766:	10 36       	cp.w	r6,r8
8000c768:	c0 64       	brge	8000c774 <_vfprintf_r+0x14b4>
8000c76a:	fa cb f9 44 	sub	r11,sp,-1724
8000c76e:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000c772:	c1 f8       	rjmp	8000c7b0 <_vfprintf_r+0x14f0>
8000c774:	fa c8 f9 50 	sub	r8,sp,-1712
8000c778:	1a d8       	st.w	--sp,r8
8000c77a:	fa c8 fa b8 	sub	r8,sp,-1352
8000c77e:	0c 9b       	mov	r11,r6
8000c780:	1a d8       	st.w	--sp,r8
8000c782:	fa c8 fb b4 	sub	r8,sp,-1100
8000c786:	04 9a       	mov	r10,r2
8000c788:	1a d8       	st.w	--sp,r8
8000c78a:	08 9c       	mov	r12,r4
8000c78c:	fa c8 f9 40 	sub	r8,sp,-1728
8000c790:	fa c9 ff b4 	sub	r9,sp,-76
8000c794:	fe b0 f3 f8 	rcall	8000af84 <get_arg>
8000c798:	2f dd       	sub	sp,-12
8000c79a:	78 0b       	ld.w	r11,r12[0x0]
8000c79c:	c2 48       	rjmp	8000c7e4 <_vfprintf_r+0x1524>
8000c79e:	ee ca ff ff 	sub	r10,r7,-1
8000c7a2:	10 37       	cp.w	r7,r8
8000c7a4:	c0 94       	brge	8000c7b6 <_vfprintf_r+0x14f6>
8000c7a6:	fa c9 f9 44 	sub	r9,sp,-1724
8000c7aa:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000c7ae:	14 97       	mov	r7,r10
8000c7b0:	ec fb fd 88 	ld.w	r11,r6[-632]
8000c7b4:	c1 88       	rjmp	8000c7e4 <_vfprintf_r+0x1524>
8000c7b6:	41 09       	lddsp	r9,sp[0x40]
8000c7b8:	59 f8       	cp.w	r8,31
8000c7ba:	e0 89 00 11 	brgt	8000c7dc <_vfprintf_r+0x151c>
8000c7be:	f2 cb ff fc 	sub	r11,r9,-4
8000c7c2:	51 0b       	stdsp	sp[0x40],r11
8000c7c4:	fa c6 f9 44 	sub	r6,sp,-1724
8000c7c8:	72 0b       	ld.w	r11,r9[0x0]
8000c7ca:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000c7ce:	f3 4b fd 88 	st.w	r9[-632],r11
8000c7d2:	2f f8       	sub	r8,-1
8000c7d4:	14 97       	mov	r7,r10
8000c7d6:	fb 48 06 b4 	st.w	sp[1716],r8
8000c7da:	c0 58       	rjmp	8000c7e4 <_vfprintf_r+0x1524>
8000c7dc:	72 0b       	ld.w	r11,r9[0x0]
8000c7de:	14 97       	mov	r7,r10
8000c7e0:	2f c9       	sub	r9,-4
8000c7e2:	51 09       	stdsp	sp[0x40],r9
8000c7e4:	50 1b       	stdsp	sp[0x4],r11
8000c7e6:	30 0e       	mov	lr,0
8000c7e8:	50 0e       	stdsp	sp[0x0],lr
8000c7ea:	40 08       	lddsp	r8,sp[0x0]
8000c7ec:	40 1c       	lddsp	r12,sp[0x4]
8000c7ee:	18 48       	or	r8,r12
8000c7f0:	5f 19       	srne	r9
8000c7f2:	0a 98       	mov	r8,r5
8000c7f4:	eb e9 00 09 	and	r9,r5,r9
8000c7f8:	a1 b8       	sbr	r8,0x1
8000c7fa:	58 09       	cp.w	r9,0
8000c7fc:	c0 70       	breq	8000c80a <_vfprintf_r+0x154a>
8000c7fe:	10 95       	mov	r5,r8
8000c800:	fb 60 06 b9 	st.b	sp[1721],r0
8000c804:	33 08       	mov	r8,48
8000c806:	fb 68 06 b8 	st.b	sp[1720],r8
8000c80a:	30 28       	mov	r8,2
8000c80c:	30 09       	mov	r9,0
8000c80e:	fb 69 06 bb 	st.b	sp[1723],r9
8000c812:	0a 99       	mov	r9,r5
8000c814:	a7 d9       	cbr	r9,0x7
8000c816:	40 2b       	lddsp	r11,sp[0x8]
8000c818:	40 16       	lddsp	r6,sp[0x4]
8000c81a:	58 0b       	cp.w	r11,0
8000c81c:	5f 1a       	srne	r10
8000c81e:	f2 05 17 40 	movge	r5,r9
8000c822:	fa c2 f9 78 	sub	r2,sp,-1672
8000c826:	40 09       	lddsp	r9,sp[0x0]
8000c828:	0c 49       	or	r9,r6
8000c82a:	5f 19       	srne	r9
8000c82c:	f5 e9 10 09 	or	r9,r10,r9
8000c830:	c5 c0       	breq	8000c8e8 <_vfprintf_r+0x1628>
8000c832:	30 19       	mov	r9,1
8000c834:	f2 08 18 00 	cp.b	r8,r9
8000c838:	c0 60       	breq	8000c844 <_vfprintf_r+0x1584>
8000c83a:	30 29       	mov	r9,2
8000c83c:	f2 08 18 00 	cp.b	r8,r9
8000c840:	c0 41       	brne	8000c848 <_vfprintf_r+0x1588>
8000c842:	c3 c8       	rjmp	8000c8ba <_vfprintf_r+0x15fa>
8000c844:	04 96       	mov	r6,r2
8000c846:	c3 08       	rjmp	8000c8a6 <_vfprintf_r+0x15e6>
8000c848:	04 96       	mov	r6,r2
8000c84a:	fa e8 00 00 	ld.d	r8,sp[0]
8000c84e:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
8000c852:	2d 0a       	sub	r10,-48
8000c854:	0c fa       	st.b	--r6,r10
8000c856:	f0 0b 16 03 	lsr	r11,r8,0x3
8000c85a:	f2 0c 16 03 	lsr	r12,r9,0x3
8000c85e:	f7 e9 11 db 	or	r11,r11,r9<<0x1d
8000c862:	18 99       	mov	r9,r12
8000c864:	16 98       	mov	r8,r11
8000c866:	58 08       	cp.w	r8,0
8000c868:	5c 29       	cpc	r9
8000c86a:	cf 21       	brne	8000c84e <_vfprintf_r+0x158e>
8000c86c:	fa e9 00 00 	st.d	sp[0],r8
8000c870:	ed b5 00 00 	bld	r5,0x0
8000c874:	c4 51       	brne	8000c8fe <_vfprintf_r+0x163e>
8000c876:	33 09       	mov	r9,48
8000c878:	f2 0a 18 00 	cp.b	r10,r9
8000c87c:	c4 10       	breq	8000c8fe <_vfprintf_r+0x163e>
8000c87e:	0c f9       	st.b	--r6,r9
8000c880:	c3 f8       	rjmp	8000c8fe <_vfprintf_r+0x163e>
8000c882:	fa ea 00 00 	ld.d	r10,sp[0]
8000c886:	30 a8       	mov	r8,10
8000c888:	30 09       	mov	r9,0
8000c88a:	e0 a0 1a 1b 	rcall	8000fcc0 <__avr32_umod64>
8000c88e:	30 a8       	mov	r8,10
8000c890:	2d 0a       	sub	r10,-48
8000c892:	30 09       	mov	r9,0
8000c894:	ac 8a       	st.b	r6[0x0],r10
8000c896:	fa ea 00 00 	ld.d	r10,sp[0]
8000c89a:	e0 a0 18 e1 	rcall	8000fa5c <__avr32_udiv64>
8000c89e:	16 99       	mov	r9,r11
8000c8a0:	14 98       	mov	r8,r10
8000c8a2:	fa e9 00 00 	st.d	sp[0],r8
8000c8a6:	20 16       	sub	r6,1
8000c8a8:	fa ea 00 00 	ld.d	r10,sp[0]
8000c8ac:	58 9a       	cp.w	r10,9
8000c8ae:	5c 2b       	cpc	r11
8000c8b0:	fe 9b ff e9 	brhi	8000c882 <_vfprintf_r+0x15c2>
8000c8b4:	1b f8       	ld.ub	r8,sp[0x7]
8000c8b6:	2d 08       	sub	r8,-48
8000c8b8:	c2 08       	rjmp	8000c8f8 <_vfprintf_r+0x1638>
8000c8ba:	04 96       	mov	r6,r2
8000c8bc:	fa e8 00 00 	ld.d	r8,sp[0]
8000c8c0:	f5 d8 c0 04 	bfextu	r10,r8,0x0,0x4
8000c8c4:	40 de       	lddsp	lr,sp[0x34]
8000c8c6:	fc 0a 07 0a 	ld.ub	r10,lr[r10]
8000c8ca:	0c fa       	st.b	--r6,r10
8000c8cc:	f2 0b 16 04 	lsr	r11,r9,0x4
8000c8d0:	f0 0a 16 04 	lsr	r10,r8,0x4
8000c8d4:	f5 e9 11 ca 	or	r10,r10,r9<<0x1c
8000c8d8:	16 99       	mov	r9,r11
8000c8da:	14 98       	mov	r8,r10
8000c8dc:	58 08       	cp.w	r8,0
8000c8de:	5c 29       	cpc	r9
8000c8e0:	cf 01       	brne	8000c8c0 <_vfprintf_r+0x1600>
8000c8e2:	fa e9 00 00 	st.d	sp[0],r8
8000c8e6:	c0 c8       	rjmp	8000c8fe <_vfprintf_r+0x163e>
8000c8e8:	58 08       	cp.w	r8,0
8000c8ea:	c0 91       	brne	8000c8fc <_vfprintf_r+0x163c>
8000c8ec:	ed b5 00 00 	bld	r5,0x0
8000c8f0:	c0 61       	brne	8000c8fc <_vfprintf_r+0x163c>
8000c8f2:	fa c6 f9 79 	sub	r6,sp,-1671
8000c8f6:	33 08       	mov	r8,48
8000c8f8:	ac 88       	st.b	r6[0x0],r8
8000c8fa:	c0 28       	rjmp	8000c8fe <_vfprintf_r+0x163e>
8000c8fc:	04 96       	mov	r6,r2
8000c8fe:	0c 12       	sub	r2,r6
8000c900:	c1 c8       	rjmp	8000c938 <_vfprintf_r+0x1678>
8000c902:	50 a7       	stdsp	sp[0x28],r7
8000c904:	50 80       	stdsp	sp[0x20],r0
8000c906:	40 93       	lddsp	r3,sp[0x24]
8000c908:	0c 97       	mov	r7,r6
8000c90a:	10 90       	mov	r0,r8
8000c90c:	04 94       	mov	r4,r2
8000c90e:	40 41       	lddsp	r1,sp[0x10]
8000c910:	58 08       	cp.w	r8,0
8000c912:	e0 80 04 51 	breq	8000d1b4 <_vfprintf_r+0x1ef4>
8000c916:	fb 68 06 60 	st.b	sp[1632],r8
8000c91a:	30 0c       	mov	r12,0
8000c91c:	30 08       	mov	r8,0
8000c91e:	30 12       	mov	r2,1
8000c920:	fb 68 06 bb 	st.b	sp[1723],r8
8000c924:	50 2c       	stdsp	sp[0x8],r12
8000c926:	fa c6 f9 a0 	sub	r6,sp,-1632
8000c92a:	c0 78       	rjmp	8000c938 <_vfprintf_r+0x1678>
8000c92c:	30 0b       	mov	r11,0
8000c92e:	50 2b       	stdsp	sp[0x8],r11
8000c930:	c0 48       	rjmp	8000c938 <_vfprintf_r+0x1678>
8000c932:	40 22       	lddsp	r2,sp[0x8]
8000c934:	30 0a       	mov	r10,0
8000c936:	50 2a       	stdsp	sp[0x8],r10
8000c938:	40 29       	lddsp	r9,sp[0x8]
8000c93a:	e4 09 0c 49 	max	r9,r2,r9
8000c93e:	fb 38 06 bb 	ld.ub	r8,sp[1723]
8000c942:	50 39       	stdsp	sp[0xc],r9
8000c944:	0a 9e       	mov	lr,r5
8000c946:	30 09       	mov	r9,0
8000c948:	e2 1e 00 02 	andl	lr,0x2,COH
8000c94c:	f2 08 18 00 	cp.b	r8,r9
8000c950:	fb f8 10 03 	ld.wne	r8,sp[0xc]
8000c954:	f7 b8 01 ff 	subne	r8,-1
8000c958:	fb f8 1a 03 	st.wne	sp[0xc],r8
8000c95c:	0a 9b       	mov	r11,r5
8000c95e:	58 0e       	cp.w	lr,0
8000c960:	fb fc 10 03 	ld.wne	r12,sp[0xc]
8000c964:	f7 bc 01 fe 	subne	r12,-2
8000c968:	fb fc 1a 03 	st.wne	sp[0xc],r12
8000c96c:	e2 1b 00 84 	andl	r11,0x84,COH
8000c970:	50 fe       	stdsp	sp[0x3c],lr
8000c972:	50 9b       	stdsp	sp[0x24],r11
8000c974:	c4 51       	brne	8000c9fe <_vfprintf_r+0x173e>
8000c976:	40 8a       	lddsp	r10,sp[0x20]
8000c978:	40 39       	lddsp	r9,sp[0xc]
8000c97a:	12 1a       	sub	r10,r9
8000c97c:	50 4a       	stdsp	sp[0x10],r10
8000c97e:	58 0a       	cp.w	r10,0
8000c980:	e0 89 00 1f 	brgt	8000c9be <_vfprintf_r+0x16fe>
8000c984:	c3 d8       	rjmp	8000c9fe <_vfprintf_r+0x173e>
8000c986:	2f 09       	sub	r9,-16
8000c988:	2f f8       	sub	r8,-1
8000c98a:	4c ee       	lddpc	lr,8000cac0 <_vfprintf_r+0x1800>
8000c98c:	31 0c       	mov	r12,16
8000c98e:	fb 49 06 90 	st.w	sp[1680],r9
8000c992:	87 0e       	st.w	r3[0x0],lr
8000c994:	87 1c       	st.w	r3[0x4],r12
8000c996:	fb 48 06 8c 	st.w	sp[1676],r8
8000c99a:	58 78       	cp.w	r8,7
8000c99c:	e0 89 00 04 	brgt	8000c9a4 <_vfprintf_r+0x16e4>
8000c9a0:	2f 83       	sub	r3,-8
8000c9a2:	c0 b8       	rjmp	8000c9b8 <_vfprintf_r+0x16f8>
8000c9a4:	fa ca f9 78 	sub	r10,sp,-1672
8000c9a8:	02 9b       	mov	r11,r1
8000c9aa:	08 9c       	mov	r12,r4
8000c9ac:	fe b0 f4 7c 	rcall	8000b2a4 <__sprint_r>
8000c9b0:	e0 81 04 13 	brne	8000d1d6 <_vfprintf_r+0x1f16>
8000c9b4:	fa c3 f9 e0 	sub	r3,sp,-1568
8000c9b8:	40 4b       	lddsp	r11,sp[0x10]
8000c9ba:	21 0b       	sub	r11,16
8000c9bc:	50 4b       	stdsp	sp[0x10],r11
8000c9be:	fa f9 06 90 	ld.w	r9,sp[1680]
8000c9c2:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000c9c6:	4b fa       	lddpc	r10,8000cac0 <_vfprintf_r+0x1800>
8000c9c8:	40 4e       	lddsp	lr,sp[0x10]
8000c9ca:	59 0e       	cp.w	lr,16
8000c9cc:	fe 99 ff dd 	brgt	8000c986 <_vfprintf_r+0x16c6>
8000c9d0:	1c 09       	add	r9,lr
8000c9d2:	2f f8       	sub	r8,-1
8000c9d4:	87 0a       	st.w	r3[0x0],r10
8000c9d6:	fb 49 06 90 	st.w	sp[1680],r9
8000c9da:	87 1e       	st.w	r3[0x4],lr
8000c9dc:	fb 48 06 8c 	st.w	sp[1676],r8
8000c9e0:	58 78       	cp.w	r8,7
8000c9e2:	e0 89 00 04 	brgt	8000c9ea <_vfprintf_r+0x172a>
8000c9e6:	2f 83       	sub	r3,-8
8000c9e8:	c0 b8       	rjmp	8000c9fe <_vfprintf_r+0x173e>
8000c9ea:	fa ca f9 78 	sub	r10,sp,-1672
8000c9ee:	02 9b       	mov	r11,r1
8000c9f0:	08 9c       	mov	r12,r4
8000c9f2:	fe b0 f4 59 	rcall	8000b2a4 <__sprint_r>
8000c9f6:	e0 81 03 f0 	brne	8000d1d6 <_vfprintf_r+0x1f16>
8000c9fa:	fa c3 f9 e0 	sub	r3,sp,-1568
8000c9fe:	30 09       	mov	r9,0
8000ca00:	fb 38 06 bb 	ld.ub	r8,sp[1723]
8000ca04:	f2 08 18 00 	cp.b	r8,r9
8000ca08:	c1 f0       	breq	8000ca46 <_vfprintf_r+0x1786>
8000ca0a:	fa f8 06 90 	ld.w	r8,sp[1680]
8000ca0e:	fa c9 f9 45 	sub	r9,sp,-1723
8000ca12:	2f f8       	sub	r8,-1
8000ca14:	87 09       	st.w	r3[0x0],r9
8000ca16:	fb 48 06 90 	st.w	sp[1680],r8
8000ca1a:	30 19       	mov	r9,1
8000ca1c:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000ca20:	87 19       	st.w	r3[0x4],r9
8000ca22:	2f f8       	sub	r8,-1
8000ca24:	fb 48 06 8c 	st.w	sp[1676],r8
8000ca28:	58 78       	cp.w	r8,7
8000ca2a:	e0 89 00 04 	brgt	8000ca32 <_vfprintf_r+0x1772>
8000ca2e:	2f 83       	sub	r3,-8
8000ca30:	c0 b8       	rjmp	8000ca46 <_vfprintf_r+0x1786>
8000ca32:	fa ca f9 78 	sub	r10,sp,-1672
8000ca36:	02 9b       	mov	r11,r1
8000ca38:	08 9c       	mov	r12,r4
8000ca3a:	fe b0 f4 35 	rcall	8000b2a4 <__sprint_r>
8000ca3e:	e0 81 03 cc 	brne	8000d1d6 <_vfprintf_r+0x1f16>
8000ca42:	fa c3 f9 e0 	sub	r3,sp,-1568
8000ca46:	40 fc       	lddsp	r12,sp[0x3c]
8000ca48:	58 0c       	cp.w	r12,0
8000ca4a:	c1 f0       	breq	8000ca88 <_vfprintf_r+0x17c8>
8000ca4c:	fa f8 06 90 	ld.w	r8,sp[1680]
8000ca50:	fa c9 f9 48 	sub	r9,sp,-1720
8000ca54:	2f e8       	sub	r8,-2
8000ca56:	87 09       	st.w	r3[0x0],r9
8000ca58:	fb 48 06 90 	st.w	sp[1680],r8
8000ca5c:	30 29       	mov	r9,2
8000ca5e:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000ca62:	87 19       	st.w	r3[0x4],r9
8000ca64:	2f f8       	sub	r8,-1
8000ca66:	fb 48 06 8c 	st.w	sp[1676],r8
8000ca6a:	58 78       	cp.w	r8,7
8000ca6c:	e0 89 00 04 	brgt	8000ca74 <_vfprintf_r+0x17b4>
8000ca70:	2f 83       	sub	r3,-8
8000ca72:	c0 b8       	rjmp	8000ca88 <_vfprintf_r+0x17c8>
8000ca74:	fa ca f9 78 	sub	r10,sp,-1672
8000ca78:	02 9b       	mov	r11,r1
8000ca7a:	08 9c       	mov	r12,r4
8000ca7c:	fe b0 f4 14 	rcall	8000b2a4 <__sprint_r>
8000ca80:	e0 81 03 ab 	brne	8000d1d6 <_vfprintf_r+0x1f16>
8000ca84:	fa c3 f9 e0 	sub	r3,sp,-1568
8000ca88:	40 9b       	lddsp	r11,sp[0x24]
8000ca8a:	e0 4b 00 80 	cp.w	r11,128
8000ca8e:	c4 a1       	brne	8000cb22 <_vfprintf_r+0x1862>
8000ca90:	40 8a       	lddsp	r10,sp[0x20]
8000ca92:	40 39       	lddsp	r9,sp[0xc]
8000ca94:	12 1a       	sub	r10,r9
8000ca96:	50 4a       	stdsp	sp[0x10],r10
8000ca98:	58 0a       	cp.w	r10,0
8000ca9a:	e0 89 00 24 	brgt	8000cae2 <_vfprintf_r+0x1822>
8000ca9e:	c4 28       	rjmp	8000cb22 <_vfprintf_r+0x1862>
8000caa0:	2f 09       	sub	r9,-16
8000caa2:	2f f8       	sub	r8,-1
8000caa4:	48 8e       	lddpc	lr,8000cac4 <_vfprintf_r+0x1804>
8000caa6:	31 0c       	mov	r12,16
8000caa8:	fb 49 06 90 	st.w	sp[1680],r9
8000caac:	87 0e       	st.w	r3[0x0],lr
8000caae:	87 1c       	st.w	r3[0x4],r12
8000cab0:	fb 48 06 8c 	st.w	sp[1676],r8
8000cab4:	58 78       	cp.w	r8,7
8000cab6:	e0 89 00 09 	brgt	8000cac8 <_vfprintf_r+0x1808>
8000caba:	2f 83       	sub	r3,-8
8000cabc:	c1 08       	rjmp	8000cadc <_vfprintf_r+0x181c>
8000cabe:	d7 03       	nop
8000cac0:	80 01       	ld.sh	r1,r0[0x0]
8000cac2:	95 b8       	st.w	r10[0x2c],r8
8000cac4:	80 01       	ld.sh	r1,r0[0x0]
8000cac6:	95 c8       	st.w	r10[0x30],r8
8000cac8:	fa ca f9 78 	sub	r10,sp,-1672
8000cacc:	02 9b       	mov	r11,r1
8000cace:	08 9c       	mov	r12,r4
8000cad0:	fe b0 f3 ea 	rcall	8000b2a4 <__sprint_r>
8000cad4:	e0 81 03 81 	brne	8000d1d6 <_vfprintf_r+0x1f16>
8000cad8:	fa c3 f9 e0 	sub	r3,sp,-1568
8000cadc:	40 4b       	lddsp	r11,sp[0x10]
8000cade:	21 0b       	sub	r11,16
8000cae0:	50 4b       	stdsp	sp[0x10],r11
8000cae2:	fa f9 06 90 	ld.w	r9,sp[1680]
8000cae6:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000caea:	4c 6a       	lddpc	r10,8000cc00 <_vfprintf_r+0x1940>
8000caec:	40 4e       	lddsp	lr,sp[0x10]
8000caee:	59 0e       	cp.w	lr,16
8000caf0:	fe 99 ff d8 	brgt	8000caa0 <_vfprintf_r+0x17e0>
8000caf4:	1c 09       	add	r9,lr
8000caf6:	2f f8       	sub	r8,-1
8000caf8:	87 0a       	st.w	r3[0x0],r10
8000cafa:	fb 49 06 90 	st.w	sp[1680],r9
8000cafe:	87 1e       	st.w	r3[0x4],lr
8000cb00:	fb 48 06 8c 	st.w	sp[1676],r8
8000cb04:	58 78       	cp.w	r8,7
8000cb06:	e0 89 00 04 	brgt	8000cb0e <_vfprintf_r+0x184e>
8000cb0a:	2f 83       	sub	r3,-8
8000cb0c:	c0 b8       	rjmp	8000cb22 <_vfprintf_r+0x1862>
8000cb0e:	fa ca f9 78 	sub	r10,sp,-1672
8000cb12:	02 9b       	mov	r11,r1
8000cb14:	08 9c       	mov	r12,r4
8000cb16:	fe b0 f3 c7 	rcall	8000b2a4 <__sprint_r>
8000cb1a:	e0 81 03 5e 	brne	8000d1d6 <_vfprintf_r+0x1f16>
8000cb1e:	fa c3 f9 e0 	sub	r3,sp,-1568
8000cb22:	40 2c       	lddsp	r12,sp[0x8]
8000cb24:	04 1c       	sub	r12,r2
8000cb26:	50 2c       	stdsp	sp[0x8],r12
8000cb28:	58 0c       	cp.w	r12,0
8000cb2a:	e0 89 00 1f 	brgt	8000cb68 <_vfprintf_r+0x18a8>
8000cb2e:	c3 d8       	rjmp	8000cba8 <_vfprintf_r+0x18e8>
8000cb30:	2f 09       	sub	r9,-16
8000cb32:	2f f8       	sub	r8,-1
8000cb34:	4b 3b       	lddpc	r11,8000cc00 <_vfprintf_r+0x1940>
8000cb36:	31 0a       	mov	r10,16
8000cb38:	fb 49 06 90 	st.w	sp[1680],r9
8000cb3c:	87 0b       	st.w	r3[0x0],r11
8000cb3e:	87 1a       	st.w	r3[0x4],r10
8000cb40:	fb 48 06 8c 	st.w	sp[1676],r8
8000cb44:	58 78       	cp.w	r8,7
8000cb46:	e0 89 00 04 	brgt	8000cb4e <_vfprintf_r+0x188e>
8000cb4a:	2f 83       	sub	r3,-8
8000cb4c:	c0 b8       	rjmp	8000cb62 <_vfprintf_r+0x18a2>
8000cb4e:	fa ca f9 78 	sub	r10,sp,-1672
8000cb52:	02 9b       	mov	r11,r1
8000cb54:	08 9c       	mov	r12,r4
8000cb56:	fe b0 f3 a7 	rcall	8000b2a4 <__sprint_r>
8000cb5a:	e0 81 03 3e 	brne	8000d1d6 <_vfprintf_r+0x1f16>
8000cb5e:	fa c3 f9 e0 	sub	r3,sp,-1568
8000cb62:	40 29       	lddsp	r9,sp[0x8]
8000cb64:	21 09       	sub	r9,16
8000cb66:	50 29       	stdsp	sp[0x8],r9
8000cb68:	fa f9 06 90 	ld.w	r9,sp[1680]
8000cb6c:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000cb70:	4a 4a       	lddpc	r10,8000cc00 <_vfprintf_r+0x1940>
8000cb72:	40 2e       	lddsp	lr,sp[0x8]
8000cb74:	59 0e       	cp.w	lr,16
8000cb76:	fe 99 ff dd 	brgt	8000cb30 <_vfprintf_r+0x1870>
8000cb7a:	1c 09       	add	r9,lr
8000cb7c:	2f f8       	sub	r8,-1
8000cb7e:	87 0a       	st.w	r3[0x0],r10
8000cb80:	fb 49 06 90 	st.w	sp[1680],r9
8000cb84:	87 1e       	st.w	r3[0x4],lr
8000cb86:	fb 48 06 8c 	st.w	sp[1676],r8
8000cb8a:	58 78       	cp.w	r8,7
8000cb8c:	e0 89 00 04 	brgt	8000cb94 <_vfprintf_r+0x18d4>
8000cb90:	2f 83       	sub	r3,-8
8000cb92:	c0 b8       	rjmp	8000cba8 <_vfprintf_r+0x18e8>
8000cb94:	fa ca f9 78 	sub	r10,sp,-1672
8000cb98:	02 9b       	mov	r11,r1
8000cb9a:	08 9c       	mov	r12,r4
8000cb9c:	fe b0 f3 84 	rcall	8000b2a4 <__sprint_r>
8000cba0:	e0 81 03 1b 	brne	8000d1d6 <_vfprintf_r+0x1f16>
8000cba4:	fa c3 f9 e0 	sub	r3,sp,-1568
8000cba8:	ed b5 00 08 	bld	r5,0x8
8000cbac:	c0 b0       	breq	8000cbc2 <_vfprintf_r+0x1902>
8000cbae:	fa f8 06 90 	ld.w	r8,sp[1680]
8000cbb2:	87 12       	st.w	r3[0x4],r2
8000cbb4:	87 06       	st.w	r3[0x0],r6
8000cbb6:	f0 02 00 02 	add	r2,r8,r2
8000cbba:	fb 42 06 90 	st.w	sp[1680],r2
8000cbbe:	e0 8f 01 d5 	bral	8000cf68 <_vfprintf_r+0x1ca8>
8000cbc2:	e0 40 00 65 	cp.w	r0,101
8000cbc6:	e0 8a 01 d7 	brle	8000cf74 <_vfprintf_r+0x1cb4>
8000cbca:	30 08       	mov	r8,0
8000cbcc:	30 09       	mov	r9,0
8000cbce:	40 5b       	lddsp	r11,sp[0x14]
8000cbd0:	40 7a       	lddsp	r10,sp[0x1c]
8000cbd2:	e0 a0 15 3e 	rcall	8000f64e <__avr32_f64_cmp_eq>
8000cbd6:	c7 a0       	breq	8000ccca <_vfprintf_r+0x1a0a>
8000cbd8:	fa f8 06 90 	ld.w	r8,sp[1680]
8000cbdc:	48 a9       	lddpc	r9,8000cc04 <_vfprintf_r+0x1944>
8000cbde:	2f f8       	sub	r8,-1
8000cbe0:	87 09       	st.w	r3[0x0],r9
8000cbe2:	fb 48 06 90 	st.w	sp[1680],r8
8000cbe6:	30 19       	mov	r9,1
8000cbe8:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000cbec:	87 19       	st.w	r3[0x4],r9
8000cbee:	2f f8       	sub	r8,-1
8000cbf0:	fb 48 06 8c 	st.w	sp[1676],r8
8000cbf4:	58 78       	cp.w	r8,7
8000cbf6:	e0 89 00 09 	brgt	8000cc08 <_vfprintf_r+0x1948>
8000cbfa:	2f 83       	sub	r3,-8
8000cbfc:	c1 08       	rjmp	8000cc1c <_vfprintf_r+0x195c>
8000cbfe:	d7 03       	nop
8000cc00:	80 01       	ld.sh	r1,r0[0x0]
8000cc02:	95 c8       	st.w	r10[0x30],r8
8000cc04:	80 01       	ld.sh	r1,r0[0x0]
8000cc06:	95 b4       	st.w	r10[0x2c],r4
8000cc08:	fa ca f9 78 	sub	r10,sp,-1672
8000cc0c:	02 9b       	mov	r11,r1
8000cc0e:	08 9c       	mov	r12,r4
8000cc10:	fe b0 f3 4a 	rcall	8000b2a4 <__sprint_r>
8000cc14:	e0 81 02 e1 	brne	8000d1d6 <_vfprintf_r+0x1f16>
8000cc18:	fa c3 f9 e0 	sub	r3,sp,-1568
8000cc1c:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000cc20:	40 6c       	lddsp	r12,sp[0x18]
8000cc22:	18 38       	cp.w	r8,r12
8000cc24:	c0 55       	brlt	8000cc2e <_vfprintf_r+0x196e>
8000cc26:	ed b5 00 00 	bld	r5,0x0
8000cc2a:	e0 81 02 69 	brne	8000d0fc <_vfprintf_r+0x1e3c>
8000cc2e:	fa f8 06 90 	ld.w	r8,sp[1680]
8000cc32:	2f f8       	sub	r8,-1
8000cc34:	40 cb       	lddsp	r11,sp[0x30]
8000cc36:	fb 48 06 90 	st.w	sp[1680],r8
8000cc3a:	30 19       	mov	r9,1
8000cc3c:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000cc40:	87 0b       	st.w	r3[0x0],r11
8000cc42:	2f f8       	sub	r8,-1
8000cc44:	87 19       	st.w	r3[0x4],r9
8000cc46:	fb 48 06 8c 	st.w	sp[1676],r8
8000cc4a:	58 78       	cp.w	r8,7
8000cc4c:	e0 89 00 04 	brgt	8000cc54 <_vfprintf_r+0x1994>
8000cc50:	2f 83       	sub	r3,-8
8000cc52:	c0 b8       	rjmp	8000cc68 <_vfprintf_r+0x19a8>
8000cc54:	fa ca f9 78 	sub	r10,sp,-1672
8000cc58:	02 9b       	mov	r11,r1
8000cc5a:	08 9c       	mov	r12,r4
8000cc5c:	fe b0 f3 24 	rcall	8000b2a4 <__sprint_r>
8000cc60:	e0 81 02 bb 	brne	8000d1d6 <_vfprintf_r+0x1f16>
8000cc64:	fa c3 f9 e0 	sub	r3,sp,-1568
8000cc68:	40 66       	lddsp	r6,sp[0x18]
8000cc6a:	20 16       	sub	r6,1
8000cc6c:	58 06       	cp.w	r6,0
8000cc6e:	e0 89 00 1d 	brgt	8000cca8 <_vfprintf_r+0x19e8>
8000cc72:	e0 8f 02 45 	bral	8000d0fc <_vfprintf_r+0x1e3c>
8000cc76:	2f 09       	sub	r9,-16
8000cc78:	2f f8       	sub	r8,-1
8000cc7a:	fb 49 06 90 	st.w	sp[1680],r9
8000cc7e:	87 02       	st.w	r3[0x0],r2
8000cc80:	87 10       	st.w	r3[0x4],r0
8000cc82:	fb 48 06 8c 	st.w	sp[1676],r8
8000cc86:	58 78       	cp.w	r8,7
8000cc88:	e0 89 00 04 	brgt	8000cc90 <_vfprintf_r+0x19d0>
8000cc8c:	2f 83       	sub	r3,-8
8000cc8e:	c0 b8       	rjmp	8000cca4 <_vfprintf_r+0x19e4>
8000cc90:	fa ca f9 78 	sub	r10,sp,-1672
8000cc94:	02 9b       	mov	r11,r1
8000cc96:	08 9c       	mov	r12,r4
8000cc98:	fe b0 f3 06 	rcall	8000b2a4 <__sprint_r>
8000cc9c:	e0 81 02 9d 	brne	8000d1d6 <_vfprintf_r+0x1f16>
8000cca0:	fa c3 f9 e0 	sub	r3,sp,-1568
8000cca4:	21 06       	sub	r6,16
8000cca6:	c0 38       	rjmp	8000ccac <_vfprintf_r+0x19ec>
8000cca8:	4d 22       	lddpc	r2,8000cdf0 <_vfprintf_r+0x1b30>
8000ccaa:	31 00       	mov	r0,16
8000ccac:	fa f9 06 90 	ld.w	r9,sp[1680]
8000ccb0:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000ccb4:	4c fa       	lddpc	r10,8000cdf0 <_vfprintf_r+0x1b30>
8000ccb6:	59 06       	cp.w	r6,16
8000ccb8:	fe 99 ff df 	brgt	8000cc76 <_vfprintf_r+0x19b6>
8000ccbc:	0c 09       	add	r9,r6
8000ccbe:	87 0a       	st.w	r3[0x0],r10
8000ccc0:	fb 49 06 90 	st.w	sp[1680],r9
8000ccc4:	2f f8       	sub	r8,-1
8000ccc6:	87 16       	st.w	r3[0x4],r6
8000ccc8:	c5 39       	rjmp	8000cf6e <_vfprintf_r+0x1cae>
8000ccca:	fa fa 06 ac 	ld.w	r10,sp[1708]
8000ccce:	58 0a       	cp.w	r10,0
8000ccd0:	e0 89 00 94 	brgt	8000cdf8 <_vfprintf_r+0x1b38>
8000ccd4:	fa f8 06 90 	ld.w	r8,sp[1680]
8000ccd8:	4c 79       	lddpc	r9,8000cdf4 <_vfprintf_r+0x1b34>
8000ccda:	2f f8       	sub	r8,-1
8000ccdc:	87 09       	st.w	r3[0x0],r9
8000ccde:	fb 48 06 90 	st.w	sp[1680],r8
8000cce2:	30 19       	mov	r9,1
8000cce4:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000cce8:	87 19       	st.w	r3[0x4],r9
8000ccea:	2f f8       	sub	r8,-1
8000ccec:	fb 48 06 8c 	st.w	sp[1676],r8
8000ccf0:	58 78       	cp.w	r8,7
8000ccf2:	e0 89 00 04 	brgt	8000ccfa <_vfprintf_r+0x1a3a>
8000ccf6:	2f 83       	sub	r3,-8
8000ccf8:	c0 b8       	rjmp	8000cd0e <_vfprintf_r+0x1a4e>
8000ccfa:	fa ca f9 78 	sub	r10,sp,-1672
8000ccfe:	02 9b       	mov	r11,r1
8000cd00:	08 9c       	mov	r12,r4
8000cd02:	fe b0 f2 d1 	rcall	8000b2a4 <__sprint_r>
8000cd06:	e0 81 02 68 	brne	8000d1d6 <_vfprintf_r+0x1f16>
8000cd0a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000cd0e:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000cd12:	58 08       	cp.w	r8,0
8000cd14:	c0 81       	brne	8000cd24 <_vfprintf_r+0x1a64>
8000cd16:	40 6a       	lddsp	r10,sp[0x18]
8000cd18:	58 0a       	cp.w	r10,0
8000cd1a:	c0 51       	brne	8000cd24 <_vfprintf_r+0x1a64>
8000cd1c:	ed b5 00 00 	bld	r5,0x0
8000cd20:	e0 81 01 ee 	brne	8000d0fc <_vfprintf_r+0x1e3c>
8000cd24:	40 c9       	lddsp	r9,sp[0x30]
8000cd26:	fa f8 06 90 	ld.w	r8,sp[1680]
8000cd2a:	2f f8       	sub	r8,-1
8000cd2c:	87 09       	st.w	r3[0x0],r9
8000cd2e:	fb 48 06 90 	st.w	sp[1680],r8
8000cd32:	30 19       	mov	r9,1
8000cd34:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000cd38:	87 19       	st.w	r3[0x4],r9
8000cd3a:	2f f8       	sub	r8,-1
8000cd3c:	fb 48 06 8c 	st.w	sp[1676],r8
8000cd40:	58 78       	cp.w	r8,7
8000cd42:	e0 89 00 04 	brgt	8000cd4a <_vfprintf_r+0x1a8a>
8000cd46:	2f 83       	sub	r3,-8
8000cd48:	c0 b8       	rjmp	8000cd5e <_vfprintf_r+0x1a9e>
8000cd4a:	fa ca f9 78 	sub	r10,sp,-1672
8000cd4e:	02 9b       	mov	r11,r1
8000cd50:	08 9c       	mov	r12,r4
8000cd52:	fe b0 f2 a9 	rcall	8000b2a4 <__sprint_r>
8000cd56:	e0 81 02 40 	brne	8000d1d6 <_vfprintf_r+0x1f16>
8000cd5a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000cd5e:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000cd62:	5c 32       	neg	r2
8000cd64:	58 02       	cp.w	r2,0
8000cd66:	e0 89 00 1d 	brgt	8000cda0 <_vfprintf_r+0x1ae0>
8000cd6a:	c3 b8       	rjmp	8000cde0 <_vfprintf_r+0x1b20>
8000cd6c:	2f 09       	sub	r9,-16
8000cd6e:	2f f8       	sub	r8,-1
8000cd70:	31 0e       	mov	lr,16
8000cd72:	fb 49 06 90 	st.w	sp[1680],r9
8000cd76:	87 00       	st.w	r3[0x0],r0
8000cd78:	87 1e       	st.w	r3[0x4],lr
8000cd7a:	fb 48 06 8c 	st.w	sp[1676],r8
8000cd7e:	58 78       	cp.w	r8,7
8000cd80:	e0 89 00 04 	brgt	8000cd88 <_vfprintf_r+0x1ac8>
8000cd84:	2f 83       	sub	r3,-8
8000cd86:	c0 b8       	rjmp	8000cd9c <_vfprintf_r+0x1adc>
8000cd88:	fa ca f9 78 	sub	r10,sp,-1672
8000cd8c:	02 9b       	mov	r11,r1
8000cd8e:	08 9c       	mov	r12,r4
8000cd90:	fe b0 f2 8a 	rcall	8000b2a4 <__sprint_r>
8000cd94:	e0 81 02 21 	brne	8000d1d6 <_vfprintf_r+0x1f16>
8000cd98:	fa c3 f9 e0 	sub	r3,sp,-1568
8000cd9c:	21 02       	sub	r2,16
8000cd9e:	c0 28       	rjmp	8000cda2 <_vfprintf_r+0x1ae2>
8000cda0:	49 40       	lddpc	r0,8000cdf0 <_vfprintf_r+0x1b30>
8000cda2:	fa f9 06 90 	ld.w	r9,sp[1680]
8000cda6:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000cdaa:	49 2a       	lddpc	r10,8000cdf0 <_vfprintf_r+0x1b30>
8000cdac:	59 02       	cp.w	r2,16
8000cdae:	fe 99 ff df 	brgt	8000cd6c <_vfprintf_r+0x1aac>
8000cdb2:	04 09       	add	r9,r2
8000cdb4:	2f f8       	sub	r8,-1
8000cdb6:	87 0a       	st.w	r3[0x0],r10
8000cdb8:	fb 49 06 90 	st.w	sp[1680],r9
8000cdbc:	87 12       	st.w	r3[0x4],r2
8000cdbe:	fb 48 06 8c 	st.w	sp[1676],r8
8000cdc2:	58 78       	cp.w	r8,7
8000cdc4:	e0 89 00 04 	brgt	8000cdcc <_vfprintf_r+0x1b0c>
8000cdc8:	2f 83       	sub	r3,-8
8000cdca:	c0 b8       	rjmp	8000cde0 <_vfprintf_r+0x1b20>
8000cdcc:	fa ca f9 78 	sub	r10,sp,-1672
8000cdd0:	02 9b       	mov	r11,r1
8000cdd2:	08 9c       	mov	r12,r4
8000cdd4:	fe b0 f2 68 	rcall	8000b2a4 <__sprint_r>
8000cdd8:	e0 81 01 ff 	brne	8000d1d6 <_vfprintf_r+0x1f16>
8000cddc:	fa c3 f9 e0 	sub	r3,sp,-1568
8000cde0:	40 6c       	lddsp	r12,sp[0x18]
8000cde2:	fa f8 06 90 	ld.w	r8,sp[1680]
8000cde6:	87 06       	st.w	r3[0x0],r6
8000cde8:	87 1c       	st.w	r3[0x4],r12
8000cdea:	18 08       	add	r8,r12
8000cdec:	cb c8       	rjmp	8000cf64 <_vfprintf_r+0x1ca4>
8000cdee:	d7 03       	nop
8000cdf0:	80 01       	ld.sh	r1,r0[0x0]
8000cdf2:	95 c8       	st.w	r10[0x30],r8
8000cdf4:	80 01       	ld.sh	r1,r0[0x0]
8000cdf6:	95 b4       	st.w	r10[0x2c],r4
8000cdf8:	fa f9 06 90 	ld.w	r9,sp[1680]
8000cdfc:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000ce00:	40 6b       	lddsp	r11,sp[0x18]
8000ce02:	16 3a       	cp.w	r10,r11
8000ce04:	c6 d5       	brlt	8000cede <_vfprintf_r+0x1c1e>
8000ce06:	16 09       	add	r9,r11
8000ce08:	2f f8       	sub	r8,-1
8000ce0a:	87 06       	st.w	r3[0x0],r6
8000ce0c:	fb 49 06 90 	st.w	sp[1680],r9
8000ce10:	87 1b       	st.w	r3[0x4],r11
8000ce12:	fb 48 06 8c 	st.w	sp[1676],r8
8000ce16:	58 78       	cp.w	r8,7
8000ce18:	e0 89 00 04 	brgt	8000ce20 <_vfprintf_r+0x1b60>
8000ce1c:	2f 83       	sub	r3,-8
8000ce1e:	c0 b8       	rjmp	8000ce34 <_vfprintf_r+0x1b74>
8000ce20:	fa ca f9 78 	sub	r10,sp,-1672
8000ce24:	02 9b       	mov	r11,r1
8000ce26:	08 9c       	mov	r12,r4
8000ce28:	fe b0 f2 3e 	rcall	8000b2a4 <__sprint_r>
8000ce2c:	e0 81 01 d5 	brne	8000d1d6 <_vfprintf_r+0x1f16>
8000ce30:	fa c3 f9 e0 	sub	r3,sp,-1568
8000ce34:	fa f6 06 ac 	ld.w	r6,sp[1708]
8000ce38:	40 6a       	lddsp	r10,sp[0x18]
8000ce3a:	14 16       	sub	r6,r10
8000ce3c:	58 06       	cp.w	r6,0
8000ce3e:	e0 89 00 1c 	brgt	8000ce76 <_vfprintf_r+0x1bb6>
8000ce42:	c3 b8       	rjmp	8000ceb8 <_vfprintf_r+0x1bf8>
8000ce44:	2f 09       	sub	r9,-16
8000ce46:	2f f8       	sub	r8,-1
8000ce48:	fb 49 06 90 	st.w	sp[1680],r9
8000ce4c:	87 02       	st.w	r3[0x0],r2
8000ce4e:	87 10       	st.w	r3[0x4],r0
8000ce50:	fb 48 06 8c 	st.w	sp[1676],r8
8000ce54:	58 78       	cp.w	r8,7
8000ce56:	e0 89 00 04 	brgt	8000ce5e <_vfprintf_r+0x1b9e>
8000ce5a:	2f 83       	sub	r3,-8
8000ce5c:	c0 b8       	rjmp	8000ce72 <_vfprintf_r+0x1bb2>
8000ce5e:	fa ca f9 78 	sub	r10,sp,-1672
8000ce62:	02 9b       	mov	r11,r1
8000ce64:	08 9c       	mov	r12,r4
8000ce66:	fe b0 f2 1f 	rcall	8000b2a4 <__sprint_r>
8000ce6a:	e0 81 01 b6 	brne	8000d1d6 <_vfprintf_r+0x1f16>
8000ce6e:	fa c3 f9 e0 	sub	r3,sp,-1568
8000ce72:	21 06       	sub	r6,16
8000ce74:	c0 38       	rjmp	8000ce7a <_vfprintf_r+0x1bba>
8000ce76:	4d c2       	lddpc	r2,8000cfe4 <_vfprintf_r+0x1d24>
8000ce78:	31 00       	mov	r0,16
8000ce7a:	fa f9 06 90 	ld.w	r9,sp[1680]
8000ce7e:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000ce82:	4d 9a       	lddpc	r10,8000cfe4 <_vfprintf_r+0x1d24>
8000ce84:	59 06       	cp.w	r6,16
8000ce86:	fe 99 ff df 	brgt	8000ce44 <_vfprintf_r+0x1b84>
8000ce8a:	0c 09       	add	r9,r6
8000ce8c:	2f f8       	sub	r8,-1
8000ce8e:	87 0a       	st.w	r3[0x0],r10
8000ce90:	fb 49 06 90 	st.w	sp[1680],r9
8000ce94:	87 16       	st.w	r3[0x4],r6
8000ce96:	fb 48 06 8c 	st.w	sp[1676],r8
8000ce9a:	58 78       	cp.w	r8,7
8000ce9c:	e0 89 00 04 	brgt	8000cea4 <_vfprintf_r+0x1be4>
8000cea0:	2f 83       	sub	r3,-8
8000cea2:	c0 b8       	rjmp	8000ceb8 <_vfprintf_r+0x1bf8>
8000cea4:	fa ca f9 78 	sub	r10,sp,-1672
8000cea8:	02 9b       	mov	r11,r1
8000ceaa:	08 9c       	mov	r12,r4
8000ceac:	fe b0 f1 fc 	rcall	8000b2a4 <__sprint_r>
8000ceb0:	e0 81 01 93 	brne	8000d1d6 <_vfprintf_r+0x1f16>
8000ceb4:	fa c3 f9 e0 	sub	r3,sp,-1568
8000ceb8:	ed b5 00 00 	bld	r5,0x0
8000cebc:	e0 81 01 20 	brne	8000d0fc <_vfprintf_r+0x1e3c>
8000cec0:	40 c9       	lddsp	r9,sp[0x30]
8000cec2:	fa f8 06 90 	ld.w	r8,sp[1680]
8000cec6:	2f f8       	sub	r8,-1
8000cec8:	87 09       	st.w	r3[0x0],r9
8000ceca:	fb 48 06 90 	st.w	sp[1680],r8
8000cece:	30 19       	mov	r9,1
8000ced0:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000ced4:	87 19       	st.w	r3[0x4],r9
8000ced6:	2f f8       	sub	r8,-1
8000ced8:	fb 48 06 8c 	st.w	sp[1676],r8
8000cedc:	c0 29       	rjmp	8000d0e0 <_vfprintf_r+0x1e20>
8000cede:	14 09       	add	r9,r10
8000cee0:	2f f8       	sub	r8,-1
8000cee2:	fb 49 06 90 	st.w	sp[1680],r9
8000cee6:	87 06       	st.w	r3[0x0],r6
8000cee8:	87 1a       	st.w	r3[0x4],r10
8000ceea:	fb 48 06 8c 	st.w	sp[1676],r8
8000ceee:	58 78       	cp.w	r8,7
8000cef0:	e0 89 00 04 	brgt	8000cef8 <_vfprintf_r+0x1c38>
8000cef4:	2f 83       	sub	r3,-8
8000cef6:	c0 b8       	rjmp	8000cf0c <_vfprintf_r+0x1c4c>
8000cef8:	fa ca f9 78 	sub	r10,sp,-1672
8000cefc:	02 9b       	mov	r11,r1
8000cefe:	08 9c       	mov	r12,r4
8000cf00:	fe b0 f1 d2 	rcall	8000b2a4 <__sprint_r>
8000cf04:	e0 81 01 69 	brne	8000d1d6 <_vfprintf_r+0x1f16>
8000cf08:	fa c3 f9 e0 	sub	r3,sp,-1568
8000cf0c:	40 c8       	lddsp	r8,sp[0x30]
8000cf0e:	87 08       	st.w	r3[0x0],r8
8000cf10:	fa f8 06 90 	ld.w	r8,sp[1680]
8000cf14:	2f f8       	sub	r8,-1
8000cf16:	30 19       	mov	r9,1
8000cf18:	fb 48 06 90 	st.w	sp[1680],r8
8000cf1c:	87 19       	st.w	r3[0x4],r9
8000cf1e:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000cf22:	2f f8       	sub	r8,-1
8000cf24:	fb 48 06 8c 	st.w	sp[1676],r8
8000cf28:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000cf2c:	58 78       	cp.w	r8,7
8000cf2e:	e0 89 00 04 	brgt	8000cf36 <_vfprintf_r+0x1c76>
8000cf32:	2f 83       	sub	r3,-8
8000cf34:	c0 b8       	rjmp	8000cf4a <_vfprintf_r+0x1c8a>
8000cf36:	fa ca f9 78 	sub	r10,sp,-1672
8000cf3a:	02 9b       	mov	r11,r1
8000cf3c:	08 9c       	mov	r12,r4
8000cf3e:	fe b0 f1 b3 	rcall	8000b2a4 <__sprint_r>
8000cf42:	e0 81 01 4a 	brne	8000d1d6 <_vfprintf_r+0x1f16>
8000cf46:	fa c3 f9 e0 	sub	r3,sp,-1568
8000cf4a:	04 06       	add	r6,r2
8000cf4c:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000cf50:	87 06       	st.w	r3[0x0],r6
8000cf52:	fa f9 06 90 	ld.w	r9,sp[1680]
8000cf56:	40 66       	lddsp	r6,sp[0x18]
8000cf58:	40 6e       	lddsp	lr,sp[0x18]
8000cf5a:	10 16       	sub	r6,r8
8000cf5c:	f2 08 01 08 	sub	r8,r9,r8
8000cf60:	87 16       	st.w	r3[0x4],r6
8000cf62:	1c 08       	add	r8,lr
8000cf64:	fb 48 06 90 	st.w	sp[1680],r8
8000cf68:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000cf6c:	2f f8       	sub	r8,-1
8000cf6e:	fb 48 06 8c 	st.w	sp[1676],r8
8000cf72:	cb 78       	rjmp	8000d0e0 <_vfprintf_r+0x1e20>
8000cf74:	40 6c       	lddsp	r12,sp[0x18]
8000cf76:	58 1c       	cp.w	r12,1
8000cf78:	e0 89 00 06 	brgt	8000cf84 <_vfprintf_r+0x1cc4>
8000cf7c:	ed b5 00 00 	bld	r5,0x0
8000cf80:	e0 81 00 85 	brne	8000d08a <_vfprintf_r+0x1dca>
8000cf84:	fa f8 06 90 	ld.w	r8,sp[1680]
8000cf88:	2f f8       	sub	r8,-1
8000cf8a:	30 19       	mov	r9,1
8000cf8c:	fb 48 06 90 	st.w	sp[1680],r8
8000cf90:	87 06       	st.w	r3[0x0],r6
8000cf92:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000cf96:	87 19       	st.w	r3[0x4],r9
8000cf98:	2f f8       	sub	r8,-1
8000cf9a:	fb 48 06 8c 	st.w	sp[1676],r8
8000cf9e:	58 78       	cp.w	r8,7
8000cfa0:	e0 89 00 04 	brgt	8000cfa8 <_vfprintf_r+0x1ce8>
8000cfa4:	2f 83       	sub	r3,-8
8000cfa6:	c0 b8       	rjmp	8000cfbc <_vfprintf_r+0x1cfc>
8000cfa8:	fa ca f9 78 	sub	r10,sp,-1672
8000cfac:	02 9b       	mov	r11,r1
8000cfae:	08 9c       	mov	r12,r4
8000cfb0:	fe b0 f1 7a 	rcall	8000b2a4 <__sprint_r>
8000cfb4:	e0 81 01 11 	brne	8000d1d6 <_vfprintf_r+0x1f16>
8000cfb8:	fa c3 f9 e0 	sub	r3,sp,-1568
8000cfbc:	fa f8 06 90 	ld.w	r8,sp[1680]
8000cfc0:	2f f8       	sub	r8,-1
8000cfc2:	40 cb       	lddsp	r11,sp[0x30]
8000cfc4:	fb 48 06 90 	st.w	sp[1680],r8
8000cfc8:	30 19       	mov	r9,1
8000cfca:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000cfce:	87 0b       	st.w	r3[0x0],r11
8000cfd0:	2f f8       	sub	r8,-1
8000cfd2:	87 19       	st.w	r3[0x4],r9
8000cfd4:	fb 48 06 8c 	st.w	sp[1676],r8
8000cfd8:	58 78       	cp.w	r8,7
8000cfda:	e0 89 00 07 	brgt	8000cfe8 <_vfprintf_r+0x1d28>
8000cfde:	2f 83       	sub	r3,-8
8000cfe0:	c0 e8       	rjmp	8000cffc <_vfprintf_r+0x1d3c>
8000cfe2:	d7 03       	nop
8000cfe4:	80 01       	ld.sh	r1,r0[0x0]
8000cfe6:	95 c8       	st.w	r10[0x30],r8
8000cfe8:	fa ca f9 78 	sub	r10,sp,-1672
8000cfec:	02 9b       	mov	r11,r1
8000cfee:	08 9c       	mov	r12,r4
8000cff0:	fe b0 f1 5a 	rcall	8000b2a4 <__sprint_r>
8000cff4:	e0 81 00 f1 	brne	8000d1d6 <_vfprintf_r+0x1f16>
8000cff8:	fa c3 f9 e0 	sub	r3,sp,-1568
8000cffc:	30 08       	mov	r8,0
8000cffe:	30 09       	mov	r9,0
8000d000:	40 5b       	lddsp	r11,sp[0x14]
8000d002:	40 7a       	lddsp	r10,sp[0x1c]
8000d004:	e0 a0 13 25 	rcall	8000f64e <__avr32_f64_cmp_eq>
8000d008:	40 68       	lddsp	r8,sp[0x18]
8000d00a:	20 18       	sub	r8,1
8000d00c:	58 0c       	cp.w	r12,0
8000d00e:	c0 d1       	brne	8000d028 <_vfprintf_r+0x1d68>
8000d010:	2f f6       	sub	r6,-1
8000d012:	87 18       	st.w	r3[0x4],r8
8000d014:	87 06       	st.w	r3[0x0],r6
8000d016:	fa f6 06 90 	ld.w	r6,sp[1680]
8000d01a:	10 06       	add	r6,r8
8000d01c:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000d020:	fb 46 06 90 	st.w	sp[1680],r6
8000d024:	2f f8       	sub	r8,-1
8000d026:	c2 f8       	rjmp	8000d084 <_vfprintf_r+0x1dc4>
8000d028:	10 96       	mov	r6,r8
8000d02a:	58 08       	cp.w	r8,0
8000d02c:	e0 89 00 1c 	brgt	8000d064 <_vfprintf_r+0x1da4>
8000d030:	c4 98       	rjmp	8000d0c2 <_vfprintf_r+0x1e02>
8000d032:	2f 09       	sub	r9,-16
8000d034:	2f f8       	sub	r8,-1
8000d036:	fb 49 06 90 	st.w	sp[1680],r9
8000d03a:	87 02       	st.w	r3[0x0],r2
8000d03c:	87 10       	st.w	r3[0x4],r0
8000d03e:	fb 48 06 8c 	st.w	sp[1676],r8
8000d042:	58 78       	cp.w	r8,7
8000d044:	e0 89 00 04 	brgt	8000d04c <_vfprintf_r+0x1d8c>
8000d048:	2f 83       	sub	r3,-8
8000d04a:	c0 b8       	rjmp	8000d060 <_vfprintf_r+0x1da0>
8000d04c:	fa ca f9 78 	sub	r10,sp,-1672
8000d050:	02 9b       	mov	r11,r1
8000d052:	08 9c       	mov	r12,r4
8000d054:	fe b0 f1 28 	rcall	8000b2a4 <__sprint_r>
8000d058:	e0 81 00 bf 	brne	8000d1d6 <_vfprintf_r+0x1f16>
8000d05c:	fa c3 f9 e0 	sub	r3,sp,-1568
8000d060:	21 06       	sub	r6,16
8000d062:	c0 38       	rjmp	8000d068 <_vfprintf_r+0x1da8>
8000d064:	4d 22       	lddpc	r2,8000d1ac <_vfprintf_r+0x1eec>
8000d066:	31 00       	mov	r0,16
8000d068:	fa f9 06 90 	ld.w	r9,sp[1680]
8000d06c:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000d070:	4c fa       	lddpc	r10,8000d1ac <_vfprintf_r+0x1eec>
8000d072:	59 06       	cp.w	r6,16
8000d074:	fe 99 ff df 	brgt	8000d032 <_vfprintf_r+0x1d72>
8000d078:	0c 09       	add	r9,r6
8000d07a:	87 0a       	st.w	r3[0x0],r10
8000d07c:	fb 49 06 90 	st.w	sp[1680],r9
8000d080:	2f f8       	sub	r8,-1
8000d082:	87 16       	st.w	r3[0x4],r6
8000d084:	fb 48 06 8c 	st.w	sp[1676],r8
8000d088:	c0 e8       	rjmp	8000d0a4 <_vfprintf_r+0x1de4>
8000d08a:	fa f8 06 90 	ld.w	r8,sp[1680]
8000d08e:	2f f8       	sub	r8,-1
8000d090:	30 19       	mov	r9,1
8000d092:	fb 48 06 90 	st.w	sp[1680],r8
8000d096:	87 06       	st.w	r3[0x0],r6
8000d098:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000d09c:	87 19       	st.w	r3[0x4],r9
8000d09e:	2f f8       	sub	r8,-1
8000d0a0:	fb 48 06 8c 	st.w	sp[1676],r8
8000d0a4:	58 78       	cp.w	r8,7
8000d0a6:	e0 89 00 04 	brgt	8000d0ae <_vfprintf_r+0x1dee>
8000d0aa:	2f 83       	sub	r3,-8
8000d0ac:	c0 b8       	rjmp	8000d0c2 <_vfprintf_r+0x1e02>
8000d0ae:	fa ca f9 78 	sub	r10,sp,-1672
8000d0b2:	02 9b       	mov	r11,r1
8000d0b4:	08 9c       	mov	r12,r4
8000d0b6:	fe b0 f0 f7 	rcall	8000b2a4 <__sprint_r>
8000d0ba:	e0 81 00 8e 	brne	8000d1d6 <_vfprintf_r+0x1f16>
8000d0be:	fa c3 f9 e0 	sub	r3,sp,-1568
8000d0c2:	40 ea       	lddsp	r10,sp[0x38]
8000d0c4:	fa f8 06 90 	ld.w	r8,sp[1680]
8000d0c8:	14 08       	add	r8,r10
8000d0ca:	fa c9 f9 64 	sub	r9,sp,-1692
8000d0ce:	fb 48 06 90 	st.w	sp[1680],r8
8000d0d2:	87 1a       	st.w	r3[0x4],r10
8000d0d4:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000d0d8:	87 09       	st.w	r3[0x0],r9
8000d0da:	2f f8       	sub	r8,-1
8000d0dc:	fb 48 06 8c 	st.w	sp[1676],r8
8000d0e0:	58 78       	cp.w	r8,7
8000d0e2:	e0 89 00 04 	brgt	8000d0ea <_vfprintf_r+0x1e2a>
8000d0e6:	2f 83       	sub	r3,-8
8000d0e8:	c0 a8       	rjmp	8000d0fc <_vfprintf_r+0x1e3c>
8000d0ea:	fa ca f9 78 	sub	r10,sp,-1672
8000d0ee:	02 9b       	mov	r11,r1
8000d0f0:	08 9c       	mov	r12,r4
8000d0f2:	fe b0 f0 d9 	rcall	8000b2a4 <__sprint_r>
8000d0f6:	c7 01       	brne	8000d1d6 <_vfprintf_r+0x1f16>
8000d0f8:	fa c3 f9 e0 	sub	r3,sp,-1568
8000d0fc:	e2 15 00 04 	andl	r5,0x4,COH
8000d100:	c3 d0       	breq	8000d17a <_vfprintf_r+0x1eba>
8000d102:	40 86       	lddsp	r6,sp[0x20]
8000d104:	40 39       	lddsp	r9,sp[0xc]
8000d106:	12 16       	sub	r6,r9
8000d108:	58 06       	cp.w	r6,0
8000d10a:	e0 89 00 1a 	brgt	8000d13e <_vfprintf_r+0x1e7e>
8000d10e:	c3 68       	rjmp	8000d17a <_vfprintf_r+0x1eba>
8000d110:	2f 09       	sub	r9,-16
8000d112:	2f f8       	sub	r8,-1
8000d114:	fb 49 06 90 	st.w	sp[1680],r9
8000d118:	87 05       	st.w	r3[0x0],r5
8000d11a:	87 12       	st.w	r3[0x4],r2
8000d11c:	fb 48 06 8c 	st.w	sp[1676],r8
8000d120:	58 78       	cp.w	r8,7
8000d122:	e0 89 00 04 	brgt	8000d12a <_vfprintf_r+0x1e6a>
8000d126:	2f 83       	sub	r3,-8
8000d128:	c0 98       	rjmp	8000d13a <_vfprintf_r+0x1e7a>
8000d12a:	00 9a       	mov	r10,r0
8000d12c:	02 9b       	mov	r11,r1
8000d12e:	08 9c       	mov	r12,r4
8000d130:	fe b0 f0 ba 	rcall	8000b2a4 <__sprint_r>
8000d134:	c5 11       	brne	8000d1d6 <_vfprintf_r+0x1f16>
8000d136:	fa c3 f9 e0 	sub	r3,sp,-1568
8000d13a:	21 06       	sub	r6,16
8000d13c:	c0 58       	rjmp	8000d146 <_vfprintf_r+0x1e86>
8000d13e:	49 d5       	lddpc	r5,8000d1b0 <_vfprintf_r+0x1ef0>
8000d140:	31 02       	mov	r2,16
8000d142:	fa c0 f9 78 	sub	r0,sp,-1672
8000d146:	fa f9 06 90 	ld.w	r9,sp[1680]
8000d14a:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000d14e:	49 9a       	lddpc	r10,8000d1b0 <_vfprintf_r+0x1ef0>
8000d150:	59 06       	cp.w	r6,16
8000d152:	fe 99 ff df 	brgt	8000d110 <_vfprintf_r+0x1e50>
8000d156:	0c 09       	add	r9,r6
8000d158:	2f f8       	sub	r8,-1
8000d15a:	87 0a       	st.w	r3[0x0],r10
8000d15c:	87 16       	st.w	r3[0x4],r6
8000d15e:	fb 49 06 90 	st.w	sp[1680],r9
8000d162:	fb 48 06 8c 	st.w	sp[1676],r8
8000d166:	58 78       	cp.w	r8,7
8000d168:	e0 8a 00 09 	brle	8000d17a <_vfprintf_r+0x1eba>
8000d16c:	fa ca f9 78 	sub	r10,sp,-1672
8000d170:	02 9b       	mov	r11,r1
8000d172:	08 9c       	mov	r12,r4
8000d174:	fe b0 f0 98 	rcall	8000b2a4 <__sprint_r>
8000d178:	c2 f1       	brne	8000d1d6 <_vfprintf_r+0x1f16>
8000d17a:	40 bc       	lddsp	r12,sp[0x2c]
8000d17c:	40 36       	lddsp	r6,sp[0xc]
8000d17e:	40 8e       	lddsp	lr,sp[0x20]
8000d180:	ec 0e 0c 48 	max	r8,r6,lr
8000d184:	10 0c       	add	r12,r8
8000d186:	50 bc       	stdsp	sp[0x2c],r12
8000d188:	fa f8 06 90 	ld.w	r8,sp[1680]
8000d18c:	58 08       	cp.w	r8,0
8000d18e:	c0 80       	breq	8000d19e <_vfprintf_r+0x1ede>
8000d190:	fa ca f9 78 	sub	r10,sp,-1672
8000d194:	02 9b       	mov	r11,r1
8000d196:	08 9c       	mov	r12,r4
8000d198:	fe b0 f0 86 	rcall	8000b2a4 <__sprint_r>
8000d19c:	c1 d1       	brne	8000d1d6 <_vfprintf_r+0x1f16>
8000d19e:	30 0b       	mov	r11,0
8000d1a0:	fa c3 f9 e0 	sub	r3,sp,-1568
8000d1a4:	fb 4b 06 8c 	st.w	sp[1676],r11
8000d1a8:	fe 9f f1 17 	bral	8000b3d6 <_vfprintf_r+0x116>
8000d1ac:	80 01       	ld.sh	r1,r0[0x0]
8000d1ae:	95 c8       	st.w	r10[0x30],r8
8000d1b0:	80 01       	ld.sh	r1,r0[0x0]
8000d1b2:	95 b8       	st.w	r10[0x2c],r8
8000d1b4:	08 95       	mov	r5,r4
8000d1b6:	fa f8 06 90 	ld.w	r8,sp[1680]
8000d1ba:	58 08       	cp.w	r8,0
8000d1bc:	c0 80       	breq	8000d1cc <_vfprintf_r+0x1f0c>
8000d1be:	08 9c       	mov	r12,r4
8000d1c0:	fa ca f9 78 	sub	r10,sp,-1672
8000d1c4:	02 9b       	mov	r11,r1
8000d1c6:	fe b0 f0 6f 	rcall	8000b2a4 <__sprint_r>
8000d1ca:	c0 61       	brne	8000d1d6 <_vfprintf_r+0x1f16>
8000d1cc:	30 08       	mov	r8,0
8000d1ce:	fb 48 06 8c 	st.w	sp[1676],r8
8000d1d2:	c0 28       	rjmp	8000d1d6 <_vfprintf_r+0x1f16>
8000d1d4:	40 41       	lddsp	r1,sp[0x10]
8000d1d6:	82 68       	ld.sh	r8,r1[0xc]
8000d1d8:	ed b8 00 06 	bld	r8,0x6
8000d1dc:	c0 31       	brne	8000d1e2 <_vfprintf_r+0x1f22>
8000d1de:	3f fa       	mov	r10,-1
8000d1e0:	50 ba       	stdsp	sp[0x2c],r10
8000d1e2:	40 bc       	lddsp	r12,sp[0x2c]
8000d1e4:	fe 3d f9 44 	sub	sp,-1724
8000d1e8:	d8 32       	popm	r0-r7,pc
8000d1ea:	d7 03       	nop

8000d1ec <__swsetup_r>:
8000d1ec:	d4 21       	pushm	r4-r7,lr
8000d1ee:	e0 68 0a 38 	mov	r8,2616
8000d1f2:	18 96       	mov	r6,r12
8000d1f4:	16 97       	mov	r7,r11
8000d1f6:	70 0c       	ld.w	r12,r8[0x0]
8000d1f8:	58 0c       	cp.w	r12,0
8000d1fa:	c0 60       	breq	8000d206 <__swsetup_r+0x1a>
8000d1fc:	78 68       	ld.w	r8,r12[0x18]
8000d1fe:	58 08       	cp.w	r8,0
8000d200:	c0 31       	brne	8000d206 <__swsetup_r+0x1a>
8000d202:	e0 a0 07 c7 	rcall	8000e190 <__sinit>
8000d206:	4a f8       	lddpc	r8,8000d2c0 <__swsetup_r+0xd4>
8000d208:	10 37       	cp.w	r7,r8
8000d20a:	c0 61       	brne	8000d216 <__swsetup_r+0x2a>
8000d20c:	e0 68 0a 38 	mov	r8,2616
8000d210:	70 08       	ld.w	r8,r8[0x0]
8000d212:	70 07       	ld.w	r7,r8[0x0]
8000d214:	c1 08       	rjmp	8000d234 <__swsetup_r+0x48>
8000d216:	4a c8       	lddpc	r8,8000d2c4 <__swsetup_r+0xd8>
8000d218:	10 37       	cp.w	r7,r8
8000d21a:	c0 61       	brne	8000d226 <__swsetup_r+0x3a>
8000d21c:	e0 68 0a 38 	mov	r8,2616
8000d220:	70 08       	ld.w	r8,r8[0x0]
8000d222:	70 17       	ld.w	r7,r8[0x4]
8000d224:	c0 88       	rjmp	8000d234 <__swsetup_r+0x48>
8000d226:	4a 98       	lddpc	r8,8000d2c8 <__swsetup_r+0xdc>
8000d228:	10 37       	cp.w	r7,r8
8000d22a:	c0 51       	brne	8000d234 <__swsetup_r+0x48>
8000d22c:	e0 68 0a 38 	mov	r8,2616
8000d230:	70 08       	ld.w	r8,r8[0x0]
8000d232:	70 27       	ld.w	r7,r8[0x8]
8000d234:	8e 68       	ld.sh	r8,r7[0xc]
8000d236:	ed b8 00 03 	bld	r8,0x3
8000d23a:	c1 e0       	breq	8000d276 <__swsetup_r+0x8a>
8000d23c:	ed b8 00 04 	bld	r8,0x4
8000d240:	c3 e1       	brne	8000d2bc <__swsetup_r+0xd0>
8000d242:	ed b8 00 02 	bld	r8,0x2
8000d246:	c1 51       	brne	8000d270 <__swsetup_r+0x84>
8000d248:	6e db       	ld.w	r11,r7[0x34]
8000d24a:	58 0b       	cp.w	r11,0
8000d24c:	c0 a0       	breq	8000d260 <__swsetup_r+0x74>
8000d24e:	ee c8 ff bc 	sub	r8,r7,-68
8000d252:	10 3b       	cp.w	r11,r8
8000d254:	c0 40       	breq	8000d25c <__swsetup_r+0x70>
8000d256:	0c 9c       	mov	r12,r6
8000d258:	e0 a0 08 36 	rcall	8000e2c4 <_free_r>
8000d25c:	30 08       	mov	r8,0
8000d25e:	8f d8       	st.w	r7[0x34],r8
8000d260:	8e 68       	ld.sh	r8,r7[0xc]
8000d262:	e0 18 ff db 	andl	r8,0xffdb
8000d266:	ae 68       	st.h	r7[0xc],r8
8000d268:	30 08       	mov	r8,0
8000d26a:	8f 18       	st.w	r7[0x4],r8
8000d26c:	6e 48       	ld.w	r8,r7[0x10]
8000d26e:	8f 08       	st.w	r7[0x0],r8
8000d270:	8e 68       	ld.sh	r8,r7[0xc]
8000d272:	a3 b8       	sbr	r8,0x3
8000d274:	ae 68       	st.h	r7[0xc],r8
8000d276:	6e 48       	ld.w	r8,r7[0x10]
8000d278:	58 08       	cp.w	r8,0
8000d27a:	c0 b1       	brne	8000d290 <__swsetup_r+0xa4>
8000d27c:	8e 68       	ld.sh	r8,r7[0xc]
8000d27e:	e2 18 02 80 	andl	r8,0x280,COH
8000d282:	e0 48 02 00 	cp.w	r8,512
8000d286:	c0 50       	breq	8000d290 <__swsetup_r+0xa4>
8000d288:	0c 9c       	mov	r12,r6
8000d28a:	0e 9b       	mov	r11,r7
8000d28c:	e0 a0 0a 56 	rcall	8000e738 <__smakebuf_r>
8000d290:	8e 69       	ld.sh	r9,r7[0xc]
8000d292:	f1 d9 c0 01 	bfextu	r8,r9,0x0,0x1
8000d296:	c0 70       	breq	8000d2a4 <__swsetup_r+0xb8>
8000d298:	30 08       	mov	r8,0
8000d29a:	8f 28       	st.w	r7[0x8],r8
8000d29c:	6e 58       	ld.w	r8,r7[0x14]
8000d29e:	5c 38       	neg	r8
8000d2a0:	8f 68       	st.w	r7[0x18],r8
8000d2a2:	c0 68       	rjmp	8000d2ae <__swsetup_r+0xc2>
8000d2a4:	ed b9 00 01 	bld	r9,0x1
8000d2a8:	ef f8 10 05 	ld.wne	r8,r7[0x14]
8000d2ac:	8f 28       	st.w	r7[0x8],r8
8000d2ae:	6e 48       	ld.w	r8,r7[0x10]
8000d2b0:	58 08       	cp.w	r8,0
8000d2b2:	c0 61       	brne	8000d2be <__swsetup_r+0xd2>
8000d2b4:	8e 68       	ld.sh	r8,r7[0xc]
8000d2b6:	ed b8 00 07 	bld	r8,0x7
8000d2ba:	c0 21       	brne	8000d2be <__swsetup_r+0xd2>
8000d2bc:	dc 2a       	popm	r4-r7,pc,r12=-1
8000d2be:	d8 2a       	popm	r4-r7,pc,r12=0
8000d2c0:	80 01       	ld.sh	r1,r0[0x0]
8000d2c2:	96 e8       	ld.uh	r8,r11[0xc]
8000d2c4:	80 01       	ld.sh	r1,r0[0x0]
8000d2c6:	97 08       	st.w	r11[0x0],r8
8000d2c8:	80 01       	ld.sh	r1,r0[0x0]
8000d2ca:	97 28       	st.w	r11[0x8],r8

8000d2cc <quorem>:
8000d2cc:	d4 31       	pushm	r0-r7,lr
8000d2ce:	20 2d       	sub	sp,8
8000d2d0:	18 97       	mov	r7,r12
8000d2d2:	78 48       	ld.w	r8,r12[0x10]
8000d2d4:	76 46       	ld.w	r6,r11[0x10]
8000d2d6:	0c 38       	cp.w	r8,r6
8000d2d8:	c0 34       	brge	8000d2de <quorem+0x12>
8000d2da:	30 0c       	mov	r12,0
8000d2dc:	c8 58       	rjmp	8000d3e6 <quorem+0x11a>
8000d2de:	ec c2 ff fc 	sub	r2,r6,-4
8000d2e2:	f6 c3 ff ec 	sub	r3,r11,-20
8000d2e6:	f6 02 03 29 	ld.w	r9,r11[r2<<0x2]
8000d2ea:	f8 02 03 2c 	ld.w	r12,r12[r2<<0x2]
8000d2ee:	2f f9       	sub	r9,-1
8000d2f0:	20 16       	sub	r6,1
8000d2f2:	f8 09 0d 08 	divu	r8,r12,r9
8000d2f6:	f6 02 00 22 	add	r2,r11,r2<<0x2
8000d2fa:	ee c4 ff ec 	sub	r4,r7,-20
8000d2fe:	10 95       	mov	r5,r8
8000d300:	58 08       	cp.w	r8,0
8000d302:	c4 10       	breq	8000d384 <quorem+0xb8>
8000d304:	30 09       	mov	r9,0
8000d306:	06 9a       	mov	r10,r3
8000d308:	08 98       	mov	r8,r4
8000d30a:	12 91       	mov	r1,r9
8000d30c:	50 0b       	stdsp	sp[0x0],r11
8000d30e:	70 0e       	ld.w	lr,r8[0x0]
8000d310:	b1 8e       	lsr	lr,0x10
8000d312:	50 1e       	stdsp	sp[0x4],lr
8000d314:	15 0e       	ld.w	lr,r10++
8000d316:	fc 00 16 10 	lsr	r0,lr,0x10
8000d31a:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000d31e:	ea 0e 03 41 	mac	r1,r5,lr
8000d322:	fd d1 c0 10 	bfextu	lr,r1,0x0,0x10
8000d326:	b1 81       	lsr	r1,0x10
8000d328:	40 1b       	lddsp	r11,sp[0x4]
8000d32a:	ea 00 02 40 	mul	r0,r5,r0
8000d32e:	e2 00 00 00 	add	r0,r1,r0
8000d332:	e3 d0 c0 10 	bfextu	r1,r0,0x0,0x10
8000d336:	02 1b       	sub	r11,r1
8000d338:	50 1b       	stdsp	sp[0x4],r11
8000d33a:	70 0b       	ld.w	r11,r8[0x0]
8000d33c:	e3 db c0 10 	bfextu	r1,r11,0x0,0x10
8000d340:	02 09       	add	r9,r1
8000d342:	f2 0e 01 0e 	sub	lr,r9,lr
8000d346:	b0 1e       	st.h	r8[0x2],lr
8000d348:	fc 09 14 10 	asr	r9,lr,0x10
8000d34c:	40 1e       	lddsp	lr,sp[0x4]
8000d34e:	fc 09 00 09 	add	r9,lr,r9
8000d352:	b0 09       	st.h	r8[0x0],r9
8000d354:	e0 01 16 10 	lsr	r1,r0,0x10
8000d358:	2f c8       	sub	r8,-4
8000d35a:	b1 49       	asr	r9,0x10
8000d35c:	04 3a       	cp.w	r10,r2
8000d35e:	fe 98 ff d8 	brls	8000d30e <quorem+0x42>
8000d362:	40 0b       	lddsp	r11,sp[0x0]
8000d364:	58 0c       	cp.w	r12,0
8000d366:	c0 f1       	brne	8000d384 <quorem+0xb8>
8000d368:	ec c8 ff fb 	sub	r8,r6,-5
8000d36c:	ee 08 00 28 	add	r8,r7,r8<<0x2
8000d370:	c0 28       	rjmp	8000d374 <quorem+0xa8>
8000d372:	20 16       	sub	r6,1
8000d374:	20 48       	sub	r8,4
8000d376:	08 38       	cp.w	r8,r4
8000d378:	e0 88 00 05 	brls	8000d382 <quorem+0xb6>
8000d37c:	70 09       	ld.w	r9,r8[0x0]
8000d37e:	58 09       	cp.w	r9,0
8000d380:	cf 90       	breq	8000d372 <quorem+0xa6>
8000d382:	8f 46       	st.w	r7[0x10],r6
8000d384:	0e 9c       	mov	r12,r7
8000d386:	e0 a0 0a d8 	rcall	8000e936 <__mcmp>
8000d38a:	c2 d5       	brlt	8000d3e4 <quorem+0x118>
8000d38c:	2f f5       	sub	r5,-1
8000d38e:	08 98       	mov	r8,r4
8000d390:	30 09       	mov	r9,0
8000d392:	07 0b       	ld.w	r11,r3++
8000d394:	f6 0a 16 10 	lsr	r10,r11,0x10
8000d398:	70 0c       	ld.w	r12,r8[0x0]
8000d39a:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000d39e:	f8 0e 16 10 	lsr	lr,r12,0x10
8000d3a2:	14 1e       	sub	lr,r10
8000d3a4:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000d3a8:	16 1a       	sub	r10,r11
8000d3aa:	12 0a       	add	r10,r9
8000d3ac:	b0 1a       	st.h	r8[0x2],r10
8000d3ae:	b1 4a       	asr	r10,0x10
8000d3b0:	fc 0a 00 09 	add	r9,lr,r10
8000d3b4:	b0 09       	st.h	r8[0x0],r9
8000d3b6:	2f c8       	sub	r8,-4
8000d3b8:	b1 49       	asr	r9,0x10
8000d3ba:	04 33       	cp.w	r3,r2
8000d3bc:	fe 98 ff eb 	brls	8000d392 <quorem+0xc6>
8000d3c0:	ec c8 ff fb 	sub	r8,r6,-5
8000d3c4:	ee 08 03 29 	ld.w	r9,r7[r8<<0x2]
8000d3c8:	58 09       	cp.w	r9,0
8000d3ca:	c0 d1       	brne	8000d3e4 <quorem+0x118>
8000d3cc:	ee 08 00 28 	add	r8,r7,r8<<0x2
8000d3d0:	c0 28       	rjmp	8000d3d4 <quorem+0x108>
8000d3d2:	20 16       	sub	r6,1
8000d3d4:	20 48       	sub	r8,4
8000d3d6:	08 38       	cp.w	r8,r4
8000d3d8:	e0 88 00 05 	brls	8000d3e2 <quorem+0x116>
8000d3dc:	70 09       	ld.w	r9,r8[0x0]
8000d3de:	58 09       	cp.w	r9,0
8000d3e0:	cf 90       	breq	8000d3d2 <quorem+0x106>
8000d3e2:	8f 46       	st.w	r7[0x10],r6
8000d3e4:	0a 9c       	mov	r12,r5
8000d3e6:	2f ed       	sub	sp,-8
8000d3e8:	d8 32       	popm	r0-r7,pc
8000d3ea:	d7 03       	nop

8000d3ec <_dtoa_r>:
8000d3ec:	d4 31       	pushm	r0-r7,lr
8000d3ee:	21 ad       	sub	sp,104
8000d3f0:	fa c4 ff 74 	sub	r4,sp,-140
8000d3f4:	18 97       	mov	r7,r12
8000d3f6:	16 95       	mov	r5,r11
8000d3f8:	68 2c       	ld.w	r12,r4[0x8]
8000d3fa:	50 c9       	stdsp	sp[0x30],r9
8000d3fc:	68 16       	ld.w	r6,r4[0x4]
8000d3fe:	68 09       	ld.w	r9,r4[0x0]
8000d400:	50 e8       	stdsp	sp[0x38],r8
8000d402:	14 94       	mov	r4,r10
8000d404:	51 2c       	stdsp	sp[0x48],r12
8000d406:	fa e5 00 08 	st.d	sp[8],r4
8000d40a:	51 59       	stdsp	sp[0x54],r9
8000d40c:	6e 95       	ld.w	r5,r7[0x24]
8000d40e:	58 05       	cp.w	r5,0
8000d410:	c0 91       	brne	8000d422 <_dtoa_r+0x36>
8000d412:	31 0c       	mov	r12,16
8000d414:	fe b0 e8 42 	rcall	8000a498 <malloc>
8000d418:	99 35       	st.w	r12[0xc],r5
8000d41a:	8f 9c       	st.w	r7[0x24],r12
8000d41c:	99 15       	st.w	r12[0x4],r5
8000d41e:	99 25       	st.w	r12[0x8],r5
8000d420:	99 05       	st.w	r12[0x0],r5
8000d422:	6e 99       	ld.w	r9,r7[0x24]
8000d424:	72 08       	ld.w	r8,r9[0x0]
8000d426:	58 08       	cp.w	r8,0
8000d428:	c0 f0       	breq	8000d446 <_dtoa_r+0x5a>
8000d42a:	72 1a       	ld.w	r10,r9[0x4]
8000d42c:	91 1a       	st.w	r8[0x4],r10
8000d42e:	30 1a       	mov	r10,1
8000d430:	72 19       	ld.w	r9,r9[0x4]
8000d432:	f4 09 09 49 	lsl	r9,r10,r9
8000d436:	10 9b       	mov	r11,r8
8000d438:	91 29       	st.w	r8[0x8],r9
8000d43a:	0e 9c       	mov	r12,r7
8000d43c:	e0 a0 0a 96 	rcall	8000e968 <_Bfree>
8000d440:	6e 98       	ld.w	r8,r7[0x24]
8000d442:	30 09       	mov	r9,0
8000d444:	91 09       	st.w	r8[0x0],r9
8000d446:	40 28       	lddsp	r8,sp[0x8]
8000d448:	10 94       	mov	r4,r8
8000d44a:	58 08       	cp.w	r8,0
8000d44c:	c0 64       	brge	8000d458 <_dtoa_r+0x6c>
8000d44e:	f1 d8 c0 1f 	bfextu	r8,r8,0x0,0x1f
8000d452:	50 28       	stdsp	sp[0x8],r8
8000d454:	30 18       	mov	r8,1
8000d456:	c0 28       	rjmp	8000d45a <_dtoa_r+0x6e>
8000d458:	30 08       	mov	r8,0
8000d45a:	8d 08       	st.w	r6[0x0],r8
8000d45c:	fc 1c 7f f0 	movh	r12,0x7ff0
8000d460:	40 26       	lddsp	r6,sp[0x8]
8000d462:	0c 98       	mov	r8,r6
8000d464:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000d468:	18 38       	cp.w	r8,r12
8000d46a:	c1 e1       	brne	8000d4a6 <_dtoa_r+0xba>
8000d46c:	e0 68 27 0f 	mov	r8,9999
8000d470:	41 5b       	lddsp	r11,sp[0x54]
8000d472:	97 08       	st.w	r11[0x0],r8
8000d474:	40 3a       	lddsp	r10,sp[0xc]
8000d476:	58 0a       	cp.w	r10,0
8000d478:	c0 61       	brne	8000d484 <_dtoa_r+0x98>
8000d47a:	ed d6 c0 14 	bfextu	r6,r6,0x0,0x14
8000d47e:	c0 31       	brne	8000d484 <_dtoa_r+0x98>
8000d480:	4a cc       	lddpc	r12,8000d530 <_dtoa_r+0x144>
8000d482:	c0 28       	rjmp	8000d486 <_dtoa_r+0x9a>
8000d484:	4a cc       	lddpc	r12,8000d534 <_dtoa_r+0x148>
8000d486:	41 29       	lddsp	r9,sp[0x48]
8000d488:	58 09       	cp.w	r9,0
8000d48a:	e0 80 05 9e 	breq	8000dfc6 <_dtoa_r+0xbda>
8000d48e:	f8 c8 ff fd 	sub	r8,r12,-3
8000d492:	f8 c9 ff f8 	sub	r9,r12,-8
8000d496:	11 8b       	ld.ub	r11,r8[0x0]
8000d498:	30 0a       	mov	r10,0
8000d49a:	41 25       	lddsp	r5,sp[0x48]
8000d49c:	f4 0b 18 00 	cp.b	r11,r10
8000d4a0:	f2 08 17 10 	movne	r8,r9
8000d4a4:	c1 58       	rjmp	8000d4ce <_dtoa_r+0xe2>
8000d4a6:	fa ea 00 08 	ld.d	r10,sp[8]
8000d4aa:	30 08       	mov	r8,0
8000d4ac:	fa eb 00 3c 	st.d	sp[60],r10
8000d4b0:	30 09       	mov	r9,0
8000d4b2:	e0 a0 10 ce 	rcall	8000f64e <__avr32_f64_cmp_eq>
8000d4b6:	c0 f0       	breq	8000d4d4 <_dtoa_r+0xe8>
8000d4b8:	30 18       	mov	r8,1
8000d4ba:	41 5a       	lddsp	r10,sp[0x54]
8000d4bc:	95 08       	st.w	r10[0x0],r8
8000d4be:	49 fc       	lddpc	r12,8000d538 <_dtoa_r+0x14c>
8000d4c0:	41 29       	lddsp	r9,sp[0x48]
8000d4c2:	f8 08 00 08 	add	r8,r12,r8
8000d4c6:	58 09       	cp.w	r9,0
8000d4c8:	e0 80 05 7f 	breq	8000dfc6 <_dtoa_r+0xbda>
8000d4cc:	12 95       	mov	r5,r9
8000d4ce:	8b 08       	st.w	r5[0x0],r8
8000d4d0:	e0 8f 05 7b 	bral	8000dfc6 <_dtoa_r+0xbda>
8000d4d4:	fa c8 ff 9c 	sub	r8,sp,-100
8000d4d8:	fa c9 ff a0 	sub	r9,sp,-96
8000d4dc:	fa ea 00 3c 	ld.d	r10,sp[60]
8000d4e0:	0e 9c       	mov	r12,r7
8000d4e2:	eb d6 c2 8b 	bfextu	r5,r6,0x14,0xb
8000d4e6:	e0 a0 0a 93 	rcall	8000ea0c <__d2b>
8000d4ea:	18 93       	mov	r3,r12
8000d4ec:	58 05       	cp.w	r5,0
8000d4ee:	c0 d0       	breq	8000d508 <_dtoa_r+0x11c>
8000d4f0:	fa ea 00 3c 	ld.d	r10,sp[60]
8000d4f4:	30 04       	mov	r4,0
8000d4f6:	f1 db c0 14 	bfextu	r8,r11,0x0,0x14
8000d4fa:	ea c5 03 ff 	sub	r5,r5,1023
8000d4fe:	10 9b       	mov	r11,r8
8000d500:	51 74       	stdsp	sp[0x5c],r4
8000d502:	ea 1b 3f f0 	orh	r11,0x3ff0
8000d506:	c2 a8       	rjmp	8000d55a <_dtoa_r+0x16e>
8000d508:	41 88       	lddsp	r8,sp[0x60]
8000d50a:	41 9c       	lddsp	r12,sp[0x64]
8000d50c:	10 0c       	add	r12,r8
8000d50e:	f8 c5 fb ce 	sub	r5,r12,-1074
8000d512:	e0 45 00 20 	cp.w	r5,32
8000d516:	e0 8a 00 13 	brle	8000d53c <_dtoa_r+0x150>
8000d51a:	f8 cc fb ee 	sub	r12,r12,-1042
8000d51e:	40 3b       	lddsp	r11,sp[0xc]
8000d520:	ea 08 11 40 	rsub	r8,r5,64
8000d524:	f6 0c 0a 4c 	lsr	r12,r11,r12
8000d528:	ec 08 09 46 	lsl	r6,r6,r8
8000d52c:	0c 4c       	or	r12,r6
8000d52e:	c0 c8       	rjmp	8000d546 <_dtoa_r+0x15a>
8000d530:	80 01       	ld.sh	r1,r0[0x0]
8000d532:	96 d8       	ld.uh	r8,r11[0xa]
8000d534:	80 01       	ld.sh	r1,r0[0x0]
8000d536:	96 e4       	ld.uh	r4,r11[0xc]
8000d538:	80 01       	ld.sh	r1,r0[0x0]
8000d53a:	95 b4       	st.w	r10[0x2c],r4
8000d53c:	ea 0c 11 20 	rsub	r12,r5,32
8000d540:	40 3a       	lddsp	r10,sp[0xc]
8000d542:	f4 0c 09 4c 	lsl	r12,r10,r12
8000d546:	e0 a0 10 10 	rcall	8000f566 <__avr32_u32_to_f64>
8000d54a:	fc 18 fe 10 	movh	r8,0xfe10
8000d54e:	30 19       	mov	r9,1
8000d550:	ea c5 04 33 	sub	r5,r5,1075
8000d554:	f0 0b 00 0b 	add	r11,r8,r11
8000d558:	51 79       	stdsp	sp[0x5c],r9
8000d55a:	30 08       	mov	r8,0
8000d55c:	fc 19 3f f8 	movh	r9,0x3ff8
8000d560:	e0 a0 0e 98 	rcall	8000f290 <__avr32_f64_sub>
8000d564:	e0 68 43 61 	mov	r8,17249
8000d568:	ea 18 63 6f 	orh	r8,0x636f
8000d56c:	e0 69 87 a7 	mov	r9,34727
8000d570:	ea 19 3f d2 	orh	r9,0x3fd2
8000d574:	e0 a0 0d a2 	rcall	8000f0b8 <__avr32_f64_mul>
8000d578:	e0 68 c8 b3 	mov	r8,51379
8000d57c:	ea 18 8b 60 	orh	r8,0x8b60
8000d580:	e0 69 8a 28 	mov	r9,35368
8000d584:	ea 19 3f c6 	orh	r9,0x3fc6
8000d588:	e0 a0 0f 52 	rcall	8000f42c <__avr32_f64_add>
8000d58c:	0a 9c       	mov	r12,r5
8000d58e:	14 90       	mov	r0,r10
8000d590:	16 91       	mov	r1,r11
8000d592:	e0 a0 0f ee 	rcall	8000f56e <__avr32_s32_to_f64>
8000d596:	e0 68 79 fb 	mov	r8,31227
8000d59a:	ea 18 50 9f 	orh	r8,0x509f
8000d59e:	e0 69 44 13 	mov	r9,17427
8000d5a2:	ea 19 3f d3 	orh	r9,0x3fd3
8000d5a6:	e0 a0 0d 89 	rcall	8000f0b8 <__avr32_f64_mul>
8000d5aa:	14 98       	mov	r8,r10
8000d5ac:	16 99       	mov	r9,r11
8000d5ae:	00 9a       	mov	r10,r0
8000d5b0:	02 9b       	mov	r11,r1
8000d5b2:	e0 a0 0f 3d 	rcall	8000f42c <__avr32_f64_add>
8000d5b6:	14 90       	mov	r0,r10
8000d5b8:	16 91       	mov	r1,r11
8000d5ba:	e0 a0 0f c3 	rcall	8000f540 <__avr32_f64_to_s32>
8000d5be:	30 08       	mov	r8,0
8000d5c0:	18 96       	mov	r6,r12
8000d5c2:	30 09       	mov	r9,0
8000d5c4:	00 9a       	mov	r10,r0
8000d5c6:	02 9b       	mov	r11,r1
8000d5c8:	e0 a0 10 8a 	rcall	8000f6dc <__avr32_f64_cmp_lt>
8000d5cc:	c0 c0       	breq	8000d5e4 <_dtoa_r+0x1f8>
8000d5ce:	0c 9c       	mov	r12,r6
8000d5d0:	e0 a0 0f cf 	rcall	8000f56e <__avr32_s32_to_f64>
8000d5d4:	14 98       	mov	r8,r10
8000d5d6:	16 99       	mov	r9,r11
8000d5d8:	00 9a       	mov	r10,r0
8000d5da:	02 9b       	mov	r11,r1
8000d5dc:	e0 a0 10 39 	rcall	8000f64e <__avr32_f64_cmp_eq>
8000d5e0:	f7 b6 00 01 	subeq	r6,1
8000d5e4:	59 66       	cp.w	r6,22
8000d5e6:	e0 88 00 05 	brls	8000d5f0 <_dtoa_r+0x204>
8000d5ea:	30 18       	mov	r8,1
8000d5ec:	51 48       	stdsp	sp[0x50],r8
8000d5ee:	c1 28       	rjmp	8000d612 <_dtoa_r+0x226>
8000d5f0:	4c 08       	lddpc	r8,8000d6f0 <_dtoa_r+0x304>
8000d5f2:	fa ea 00 3c 	ld.d	r10,sp[60]
8000d5f6:	f0 06 02 38 	ld.d	r8,r8[r6<<0x3]
8000d5fa:	e0 a0 10 71 	rcall	8000f6dc <__avr32_f64_cmp_lt>
8000d5fe:	f9 b4 00 00 	moveq	r4,0
8000d602:	fb f4 0a 14 	st.weq	sp[0x50],r4
8000d606:	f7 b6 01 01 	subne	r6,1
8000d60a:	f9 bc 01 00 	movne	r12,0
8000d60e:	fb fc 1a 14 	st.wne	sp[0x50],r12
8000d612:	41 90       	lddsp	r0,sp[0x64]
8000d614:	20 10       	sub	r0,1
8000d616:	0a 10       	sub	r0,r5
8000d618:	c0 46       	brmi	8000d620 <_dtoa_r+0x234>
8000d61a:	50 40       	stdsp	sp[0x10],r0
8000d61c:	30 00       	mov	r0,0
8000d61e:	c0 48       	rjmp	8000d626 <_dtoa_r+0x23a>
8000d620:	30 0b       	mov	r11,0
8000d622:	5c 30       	neg	r0
8000d624:	50 4b       	stdsp	sp[0x10],r11
8000d626:	ec 02 11 00 	rsub	r2,r6,0
8000d62a:	58 06       	cp.w	r6,0
8000d62c:	fb fa 40 04 	ld.wge	r10,sp[0x10]
8000d630:	f5 d6 e4 0a 	addge	r10,r10,r6
8000d634:	fb fa 4a 04 	st.wge	sp[0x10],r10
8000d638:	fb f6 4a 11 	st.wge	sp[0x44],r6
8000d63c:	f9 b2 04 00 	movge	r2,0
8000d640:	e1 d6 e5 10 	sublt	r0,r0,r6
8000d644:	f9 b9 05 00 	movlt	r9,0
8000d648:	fb f9 5a 11 	st.wlt	sp[0x44],r9
8000d64c:	40 c8       	lddsp	r8,sp[0x30]
8000d64e:	58 98       	cp.w	r8,9
8000d650:	e0 8b 00 20 	brhi	8000d690 <_dtoa_r+0x2a4>
8000d654:	58 58       	cp.w	r8,5
8000d656:	f9 b4 0a 01 	movle	r4,1
8000d65a:	fb f5 90 0c 	ld.wgt	r5,sp[0x30]
8000d65e:	f7 b5 09 04 	subgt	r5,4
8000d662:	fb f5 9a 0c 	st.wgt	sp[0x30],r5
8000d666:	f9 b4 09 00 	movgt	r4,0
8000d66a:	40 cc       	lddsp	r12,sp[0x30]
8000d66c:	58 3c       	cp.w	r12,3
8000d66e:	c2 d0       	breq	8000d6c8 <_dtoa_r+0x2dc>
8000d670:	e0 89 00 05 	brgt	8000d67a <_dtoa_r+0x28e>
8000d674:	58 2c       	cp.w	r12,2
8000d676:	c1 01       	brne	8000d696 <_dtoa_r+0x2aa>
8000d678:	c1 88       	rjmp	8000d6a8 <_dtoa_r+0x2bc>
8000d67a:	40 cb       	lddsp	r11,sp[0x30]
8000d67c:	58 4b       	cp.w	r11,4
8000d67e:	c0 60       	breq	8000d68a <_dtoa_r+0x29e>
8000d680:	58 5b       	cp.w	r11,5
8000d682:	c0 a1       	brne	8000d696 <_dtoa_r+0x2aa>
8000d684:	30 1a       	mov	r10,1
8000d686:	50 da       	stdsp	sp[0x34],r10
8000d688:	c2 28       	rjmp	8000d6cc <_dtoa_r+0x2e0>
8000d68a:	30 19       	mov	r9,1
8000d68c:	50 d9       	stdsp	sp[0x34],r9
8000d68e:	c0 f8       	rjmp	8000d6ac <_dtoa_r+0x2c0>
8000d690:	30 08       	mov	r8,0
8000d692:	30 14       	mov	r4,1
8000d694:	50 c8       	stdsp	sp[0x30],r8
8000d696:	3f f5       	mov	r5,-1
8000d698:	30 1c       	mov	r12,1
8000d69a:	30 0b       	mov	r11,0
8000d69c:	50 95       	stdsp	sp[0x24],r5
8000d69e:	50 dc       	stdsp	sp[0x34],r12
8000d6a0:	0a 91       	mov	r1,r5
8000d6a2:	31 28       	mov	r8,18
8000d6a4:	50 eb       	stdsp	sp[0x38],r11
8000d6a6:	c2 08       	rjmp	8000d6e6 <_dtoa_r+0x2fa>
8000d6a8:	30 0a       	mov	r10,0
8000d6aa:	50 da       	stdsp	sp[0x34],r10
8000d6ac:	40 e9       	lddsp	r9,sp[0x38]
8000d6ae:	58 09       	cp.w	r9,0
8000d6b0:	e0 89 00 07 	brgt	8000d6be <_dtoa_r+0x2d2>
8000d6b4:	30 18       	mov	r8,1
8000d6b6:	50 98       	stdsp	sp[0x24],r8
8000d6b8:	10 91       	mov	r1,r8
8000d6ba:	50 e8       	stdsp	sp[0x38],r8
8000d6bc:	c1 58       	rjmp	8000d6e6 <_dtoa_r+0x2fa>
8000d6be:	40 e5       	lddsp	r5,sp[0x38]
8000d6c0:	50 95       	stdsp	sp[0x24],r5
8000d6c2:	0a 91       	mov	r1,r5
8000d6c4:	0a 98       	mov	r8,r5
8000d6c6:	c1 08       	rjmp	8000d6e6 <_dtoa_r+0x2fa>
8000d6c8:	30 0c       	mov	r12,0
8000d6ca:	50 dc       	stdsp	sp[0x34],r12
8000d6cc:	40 eb       	lddsp	r11,sp[0x38]
8000d6ce:	ec 0b 00 0b 	add	r11,r6,r11
8000d6d2:	50 9b       	stdsp	sp[0x24],r11
8000d6d4:	16 98       	mov	r8,r11
8000d6d6:	2f f8       	sub	r8,-1
8000d6d8:	58 08       	cp.w	r8,0
8000d6da:	e0 89 00 05 	brgt	8000d6e4 <_dtoa_r+0x2f8>
8000d6de:	10 91       	mov	r1,r8
8000d6e0:	30 18       	mov	r8,1
8000d6e2:	c0 28       	rjmp	8000d6e6 <_dtoa_r+0x2fa>
8000d6e4:	10 91       	mov	r1,r8
8000d6e6:	30 09       	mov	r9,0
8000d6e8:	6e 9a       	ld.w	r10,r7[0x24]
8000d6ea:	95 19       	st.w	r10[0x4],r9
8000d6ec:	30 49       	mov	r9,4
8000d6ee:	c0 78       	rjmp	8000d6fc <_dtoa_r+0x310>
8000d6f0:	80 01       	ld.sh	r1,r0[0x0]
8000d6f2:	97 98       	st.w	r11[0x24],r8
8000d6f4:	6a 1a       	ld.w	r10,r5[0x4]
8000d6f6:	a1 79       	lsl	r9,0x1
8000d6f8:	2f fa       	sub	r10,-1
8000d6fa:	8b 1a       	st.w	r5[0x4],r10
8000d6fc:	6e 95       	ld.w	r5,r7[0x24]
8000d6fe:	f2 ca ff ec 	sub	r10,r9,-20
8000d702:	10 3a       	cp.w	r10,r8
8000d704:	fe 98 ff f8 	brls	8000d6f4 <_dtoa_r+0x308>
8000d708:	6a 1b       	ld.w	r11,r5[0x4]
8000d70a:	0e 9c       	mov	r12,r7
8000d70c:	e0 a0 09 48 	rcall	8000e99c <_Balloc>
8000d710:	58 e1       	cp.w	r1,14
8000d712:	5f 88       	srls	r8
8000d714:	8b 0c       	st.w	r5[0x0],r12
8000d716:	f1 e4 00 04 	and	r4,r8,r4
8000d71a:	6e 98       	ld.w	r8,r7[0x24]
8000d71c:	70 08       	ld.w	r8,r8[0x0]
8000d71e:	50 88       	stdsp	sp[0x20],r8
8000d720:	e0 80 01 82 	breq	8000da24 <_dtoa_r+0x638>
8000d724:	58 06       	cp.w	r6,0
8000d726:	e0 8a 00 40 	brle	8000d7a6 <_dtoa_r+0x3ba>
8000d72a:	f3 d6 c0 04 	bfextu	r9,r6,0x0,0x4
8000d72e:	4c b8       	lddpc	r8,8000d858 <_dtoa_r+0x46c>
8000d730:	f0 09 02 34 	ld.d	r4,r8[r9<<0x3]
8000d734:	fa e5 00 18 	st.d	sp[24],r4
8000d738:	ec 04 14 04 	asr	r4,r6,0x4
8000d73c:	ed b4 00 04 	bld	r4,0x4
8000d740:	c0 30       	breq	8000d746 <_dtoa_r+0x35a>
8000d742:	30 25       	mov	r5,2
8000d744:	c0 f8       	rjmp	8000d762 <_dtoa_r+0x376>
8000d746:	4c 68       	lddpc	r8,8000d85c <_dtoa_r+0x470>
8000d748:	f0 e8 00 20 	ld.d	r8,r8[32]
8000d74c:	fa ea 00 3c 	ld.d	r10,sp[60]
8000d750:	e9 d4 c0 04 	bfextu	r4,r4,0x0,0x4
8000d754:	e0 a0 0f f8 	rcall	8000f744 <__avr32_f64_div>
8000d758:	30 35       	mov	r5,3
8000d75a:	14 98       	mov	r8,r10
8000d75c:	16 99       	mov	r9,r11
8000d75e:	fa e9 00 08 	st.d	sp[8],r8
8000d762:	4b fc       	lddpc	r12,8000d85c <_dtoa_r+0x470>
8000d764:	50 a3       	stdsp	sp[0x28],r3
8000d766:	0c 93       	mov	r3,r6
8000d768:	18 96       	mov	r6,r12
8000d76a:	c0 f8       	rjmp	8000d788 <_dtoa_r+0x39c>
8000d76c:	fa ea 00 18 	ld.d	r10,sp[24]
8000d770:	ed b4 00 00 	bld	r4,0x0
8000d774:	c0 81       	brne	8000d784 <_dtoa_r+0x398>
8000d776:	ec e8 00 00 	ld.d	r8,r6[0]
8000d77a:	2f f5       	sub	r5,-1
8000d77c:	e0 a0 0c 9e 	rcall	8000f0b8 <__avr32_f64_mul>
8000d780:	fa eb 00 18 	st.d	sp[24],r10
8000d784:	a1 54       	asr	r4,0x1
8000d786:	2f 86       	sub	r6,-8
8000d788:	58 04       	cp.w	r4,0
8000d78a:	cf 11       	brne	8000d76c <_dtoa_r+0x380>
8000d78c:	fa e8 00 18 	ld.d	r8,sp[24]
8000d790:	fa ea 00 08 	ld.d	r10,sp[8]
8000d794:	06 96       	mov	r6,r3
8000d796:	e0 a0 0f d7 	rcall	8000f744 <__avr32_f64_div>
8000d79a:	40 a3       	lddsp	r3,sp[0x28]
8000d79c:	14 98       	mov	r8,r10
8000d79e:	16 99       	mov	r9,r11
8000d7a0:	fa e9 00 08 	st.d	sp[8],r8
8000d7a4:	c2 d8       	rjmp	8000d7fe <_dtoa_r+0x412>
8000d7a6:	ec 08 11 00 	rsub	r8,r6,0
8000d7aa:	c0 31       	brne	8000d7b0 <_dtoa_r+0x3c4>
8000d7ac:	30 25       	mov	r5,2
8000d7ae:	c2 88       	rjmp	8000d7fe <_dtoa_r+0x412>
8000d7b0:	4a bc       	lddpc	r12,8000d85c <_dtoa_r+0x470>
8000d7b2:	f0 04 14 04 	asr	r4,r8,0x4
8000d7b6:	50 1c       	stdsp	sp[0x4],r12
8000d7b8:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
8000d7bc:	4a 79       	lddpc	r9,8000d858 <_dtoa_r+0x46c>
8000d7be:	fa ea 00 3c 	ld.d	r10,sp[60]
8000d7c2:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000d7c6:	e0 a0 0c 79 	rcall	8000f0b8 <__avr32_f64_mul>
8000d7ca:	40 1c       	lddsp	r12,sp[0x4]
8000d7cc:	50 63       	stdsp	sp[0x18],r3
8000d7ce:	30 25       	mov	r5,2
8000d7d0:	0c 93       	mov	r3,r6
8000d7d2:	fa eb 00 08 	st.d	sp[8],r10
8000d7d6:	18 96       	mov	r6,r12
8000d7d8:	c0 f8       	rjmp	8000d7f6 <_dtoa_r+0x40a>
8000d7da:	fa ea 00 08 	ld.d	r10,sp[8]
8000d7de:	ed b4 00 00 	bld	r4,0x0
8000d7e2:	c0 81       	brne	8000d7f2 <_dtoa_r+0x406>
8000d7e4:	ec e8 00 00 	ld.d	r8,r6[0]
8000d7e8:	2f f5       	sub	r5,-1
8000d7ea:	e0 a0 0c 67 	rcall	8000f0b8 <__avr32_f64_mul>
8000d7ee:	fa eb 00 08 	st.d	sp[8],r10
8000d7f2:	a1 54       	asr	r4,0x1
8000d7f4:	2f 86       	sub	r6,-8
8000d7f6:	58 04       	cp.w	r4,0
8000d7f8:	cf 11       	brne	8000d7da <_dtoa_r+0x3ee>
8000d7fa:	06 96       	mov	r6,r3
8000d7fc:	40 63       	lddsp	r3,sp[0x18]
8000d7fe:	41 4a       	lddsp	r10,sp[0x50]
8000d800:	58 0a       	cp.w	r10,0
8000d802:	c2 f0       	breq	8000d860 <_dtoa_r+0x474>
8000d804:	fa e8 00 08 	ld.d	r8,sp[8]
8000d808:	58 01       	cp.w	r1,0
8000d80a:	5f 94       	srgt	r4
8000d80c:	fa e9 00 18 	st.d	sp[24],r8
8000d810:	30 08       	mov	r8,0
8000d812:	fc 19 3f f0 	movh	r9,0x3ff0
8000d816:	fa ea 00 18 	ld.d	r10,sp[24]
8000d81a:	e0 a0 0f 61 	rcall	8000f6dc <__avr32_f64_cmp_lt>
8000d81e:	f9 bc 00 00 	moveq	r12,0
8000d822:	f9 bc 01 01 	movne	r12,1
8000d826:	e9 ec 00 0c 	and	r12,r4,r12
8000d82a:	c1 b0       	breq	8000d860 <_dtoa_r+0x474>
8000d82c:	40 98       	lddsp	r8,sp[0x24]
8000d82e:	58 08       	cp.w	r8,0
8000d830:	e0 8a 00 f6 	brle	8000da1c <_dtoa_r+0x630>
8000d834:	30 08       	mov	r8,0
8000d836:	fc 19 40 24 	movh	r9,0x4024
8000d83a:	ec c4 00 01 	sub	r4,r6,1
8000d83e:	fa ea 00 18 	ld.d	r10,sp[24]
8000d842:	2f f5       	sub	r5,-1
8000d844:	50 64       	stdsp	sp[0x18],r4
8000d846:	e0 a0 0c 39 	rcall	8000f0b8 <__avr32_f64_mul>
8000d84a:	40 94       	lddsp	r4,sp[0x24]
8000d84c:	14 98       	mov	r8,r10
8000d84e:	16 99       	mov	r9,r11
8000d850:	fa e9 00 08 	st.d	sp[8],r8
8000d854:	c0 88       	rjmp	8000d864 <_dtoa_r+0x478>
8000d856:	d7 03       	nop
8000d858:	80 01       	ld.sh	r1,r0[0x0]
8000d85a:	97 98       	st.w	r11[0x24],r8
8000d85c:	80 01       	ld.sh	r1,r0[0x0]
8000d85e:	98 60       	ld.sh	r0,r12[0xc]
8000d860:	50 66       	stdsp	sp[0x18],r6
8000d862:	02 94       	mov	r4,r1
8000d864:	0a 9c       	mov	r12,r5
8000d866:	e0 a0 0e 84 	rcall	8000f56e <__avr32_s32_to_f64>
8000d86a:	fa e8 00 08 	ld.d	r8,sp[8]
8000d86e:	e0 a0 0c 25 	rcall	8000f0b8 <__avr32_f64_mul>
8000d872:	30 08       	mov	r8,0
8000d874:	fc 19 40 1c 	movh	r9,0x401c
8000d878:	e0 a0 0d da 	rcall	8000f42c <__avr32_f64_add>
8000d87c:	14 98       	mov	r8,r10
8000d87e:	16 99       	mov	r9,r11
8000d880:	fa e9 00 28 	st.d	sp[40],r8
8000d884:	fc 18 fc c0 	movh	r8,0xfcc0
8000d888:	40 a5       	lddsp	r5,sp[0x28]
8000d88a:	10 05       	add	r5,r8
8000d88c:	50 a5       	stdsp	sp[0x28],r5
8000d88e:	58 04       	cp.w	r4,0
8000d890:	c2 11       	brne	8000d8d2 <_dtoa_r+0x4e6>
8000d892:	fa ea 00 08 	ld.d	r10,sp[8]
8000d896:	30 08       	mov	r8,0
8000d898:	fc 19 40 14 	movh	r9,0x4014
8000d89c:	e0 a0 0c fa 	rcall	8000f290 <__avr32_f64_sub>
8000d8a0:	40 bc       	lddsp	r12,sp[0x2c]
8000d8a2:	fa eb 00 08 	st.d	sp[8],r10
8000d8a6:	14 98       	mov	r8,r10
8000d8a8:	16 99       	mov	r9,r11
8000d8aa:	18 9a       	mov	r10,r12
8000d8ac:	0a 9b       	mov	r11,r5
8000d8ae:	e0 a0 0f 17 	rcall	8000f6dc <__avr32_f64_cmp_lt>
8000d8b2:	e0 81 02 54 	brne	8000dd5a <_dtoa_r+0x96e>
8000d8b6:	0a 98       	mov	r8,r5
8000d8b8:	40 b9       	lddsp	r9,sp[0x2c]
8000d8ba:	ee 18 80 00 	eorh	r8,0x8000
8000d8be:	fa ea 00 08 	ld.d	r10,sp[8]
8000d8c2:	10 95       	mov	r5,r8
8000d8c4:	12 98       	mov	r8,r9
8000d8c6:	0a 99       	mov	r9,r5
8000d8c8:	e0 a0 0f 0a 	rcall	8000f6dc <__avr32_f64_cmp_lt>
8000d8cc:	e0 81 02 3e 	brne	8000dd48 <_dtoa_r+0x95c>
8000d8d0:	ca 68       	rjmp	8000da1c <_dtoa_r+0x630>
8000d8d2:	4c e9       	lddpc	r9,8000da08 <_dtoa_r+0x61c>
8000d8d4:	e8 c8 00 01 	sub	r8,r4,1
8000d8d8:	40 d5       	lddsp	r5,sp[0x34]
8000d8da:	58 05       	cp.w	r5,0
8000d8dc:	c4 f0       	breq	8000d97a <_dtoa_r+0x58e>
8000d8de:	30 0c       	mov	r12,0
8000d8e0:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000d8e4:	51 3c       	stdsp	sp[0x4c],r12
8000d8e6:	30 0a       	mov	r10,0
8000d8e8:	fc 1b 3f e0 	movh	r11,0x3fe0
8000d8ec:	e0 a0 0f 2c 	rcall	8000f744 <__avr32_f64_div>
8000d8f0:	fa e8 00 28 	ld.d	r8,sp[40]
8000d8f4:	40 85       	lddsp	r5,sp[0x20]
8000d8f6:	e0 a0 0c cd 	rcall	8000f290 <__avr32_f64_sub>
8000d8fa:	fa eb 00 28 	st.d	sp[40],r10
8000d8fe:	fa ea 00 08 	ld.d	r10,sp[8]
8000d902:	e0 a0 0e 1f 	rcall	8000f540 <__avr32_f64_to_s32>
8000d906:	51 6c       	stdsp	sp[0x58],r12
8000d908:	e0 a0 0e 33 	rcall	8000f56e <__avr32_s32_to_f64>
8000d90c:	14 98       	mov	r8,r10
8000d90e:	16 99       	mov	r9,r11
8000d910:	fa ea 00 08 	ld.d	r10,sp[8]
8000d914:	e0 a0 0c be 	rcall	8000f290 <__avr32_f64_sub>
8000d918:	fa eb 00 08 	st.d	sp[8],r10
8000d91c:	41 68       	lddsp	r8,sp[0x58]
8000d91e:	2d 08       	sub	r8,-48
8000d920:	0a c8       	st.b	r5++,r8
8000d922:	41 39       	lddsp	r9,sp[0x4c]
8000d924:	2f f9       	sub	r9,-1
8000d926:	51 39       	stdsp	sp[0x4c],r9
8000d928:	fa e8 00 28 	ld.d	r8,sp[40]
8000d92c:	e0 a0 0e d8 	rcall	8000f6dc <__avr32_f64_cmp_lt>
8000d930:	e0 81 03 3a 	brne	8000dfa4 <_dtoa_r+0xbb8>
8000d934:	fa e8 00 08 	ld.d	r8,sp[8]
8000d938:	30 0a       	mov	r10,0
8000d93a:	fc 1b 3f f0 	movh	r11,0x3ff0
8000d93e:	e0 a0 0c a9 	rcall	8000f290 <__avr32_f64_sub>
8000d942:	fa e8 00 28 	ld.d	r8,sp[40]
8000d946:	e0 a0 0e cb 	rcall	8000f6dc <__avr32_f64_cmp_lt>
8000d94a:	fa ea 00 28 	ld.d	r10,sp[40]
8000d94e:	30 08       	mov	r8,0
8000d950:	fc 19 40 24 	movh	r9,0x4024
8000d954:	e0 81 00 da 	brne	8000db08 <_dtoa_r+0x71c>
8000d958:	41 3c       	lddsp	r12,sp[0x4c]
8000d95a:	08 3c       	cp.w	r12,r4
8000d95c:	c6 04       	brge	8000da1c <_dtoa_r+0x630>
8000d95e:	e0 a0 0b ad 	rcall	8000f0b8 <__avr32_f64_mul>
8000d962:	30 08       	mov	r8,0
8000d964:	fa eb 00 28 	st.d	sp[40],r10
8000d968:	fc 19 40 24 	movh	r9,0x4024
8000d96c:	fa ea 00 08 	ld.d	r10,sp[8]
8000d970:	e0 a0 0b a4 	rcall	8000f0b8 <__avr32_f64_mul>
8000d974:	fa eb 00 08 	st.d	sp[8],r10
8000d978:	cc 3b       	rjmp	8000d8fe <_dtoa_r+0x512>
8000d97a:	40 85       	lddsp	r5,sp[0x20]
8000d97c:	08 05       	add	r5,r4
8000d97e:	f2 08 02 3a 	ld.d	r10,r9[r8<<0x3]
8000d982:	51 35       	stdsp	sp[0x4c],r5
8000d984:	fa e8 00 28 	ld.d	r8,sp[40]
8000d988:	40 85       	lddsp	r5,sp[0x20]
8000d98a:	e0 a0 0b 97 	rcall	8000f0b8 <__avr32_f64_mul>
8000d98e:	fa eb 00 28 	st.d	sp[40],r10
8000d992:	fa ea 00 08 	ld.d	r10,sp[8]
8000d996:	e0 a0 0d d5 	rcall	8000f540 <__avr32_f64_to_s32>
8000d99a:	51 6c       	stdsp	sp[0x58],r12
8000d99c:	e0 a0 0d e9 	rcall	8000f56e <__avr32_s32_to_f64>
8000d9a0:	14 98       	mov	r8,r10
8000d9a2:	16 99       	mov	r9,r11
8000d9a4:	fa ea 00 08 	ld.d	r10,sp[8]
8000d9a8:	e0 a0 0c 74 	rcall	8000f290 <__avr32_f64_sub>
8000d9ac:	fa eb 00 08 	st.d	sp[8],r10
8000d9b0:	41 68       	lddsp	r8,sp[0x58]
8000d9b2:	2d 08       	sub	r8,-48
8000d9b4:	0a c8       	st.b	r5++,r8
8000d9b6:	41 3c       	lddsp	r12,sp[0x4c]
8000d9b8:	18 35       	cp.w	r5,r12
8000d9ba:	c2 91       	brne	8000da0c <_dtoa_r+0x620>
8000d9bc:	30 08       	mov	r8,0
8000d9be:	fc 19 3f e0 	movh	r9,0x3fe0
8000d9c2:	fa ea 00 28 	ld.d	r10,sp[40]
8000d9c6:	e0 a0 0d 33 	rcall	8000f42c <__avr32_f64_add>
8000d9ca:	40 85       	lddsp	r5,sp[0x20]
8000d9cc:	fa e8 00 08 	ld.d	r8,sp[8]
8000d9d0:	08 05       	add	r5,r4
8000d9d2:	e0 a0 0e 85 	rcall	8000f6dc <__avr32_f64_cmp_lt>
8000d9d6:	e0 81 00 99 	brne	8000db08 <_dtoa_r+0x71c>
8000d9da:	fa e8 00 28 	ld.d	r8,sp[40]
8000d9de:	30 0a       	mov	r10,0
8000d9e0:	fc 1b 3f e0 	movh	r11,0x3fe0
8000d9e4:	e0 a0 0c 56 	rcall	8000f290 <__avr32_f64_sub>
8000d9e8:	14 98       	mov	r8,r10
8000d9ea:	16 99       	mov	r9,r11
8000d9ec:	fa ea 00 08 	ld.d	r10,sp[8]
8000d9f0:	e0 a0 0e 76 	rcall	8000f6dc <__avr32_f64_cmp_lt>
8000d9f4:	c1 40       	breq	8000da1c <_dtoa_r+0x630>
8000d9f6:	33 09       	mov	r9,48
8000d9f8:	0a 98       	mov	r8,r5
8000d9fa:	11 7a       	ld.ub	r10,--r8
8000d9fc:	f2 0a 18 00 	cp.b	r10,r9
8000da00:	e0 81 02 d2 	brne	8000dfa4 <_dtoa_r+0xbb8>
8000da04:	10 95       	mov	r5,r8
8000da06:	cf 9b       	rjmp	8000d9f8 <_dtoa_r+0x60c>
8000da08:	80 01       	ld.sh	r1,r0[0x0]
8000da0a:	97 98       	st.w	r11[0x24],r8
8000da0c:	30 08       	mov	r8,0
8000da0e:	fc 19 40 24 	movh	r9,0x4024
8000da12:	e0 a0 0b 53 	rcall	8000f0b8 <__avr32_f64_mul>
8000da16:	fa eb 00 08 	st.d	sp[8],r10
8000da1a:	cb cb       	rjmp	8000d992 <_dtoa_r+0x5a6>
8000da1c:	fa ea 00 3c 	ld.d	r10,sp[60]
8000da20:	fa eb 00 08 	st.d	sp[8],r10
8000da24:	58 e6       	cp.w	r6,14
8000da26:	5f ab       	srle	r11
8000da28:	41 8a       	lddsp	r10,sp[0x60]
8000da2a:	30 08       	mov	r8,0
8000da2c:	f4 09 11 ff 	rsub	r9,r10,-1
8000da30:	f7 e9 03 f9 	and	r9,r11,r9>>0x1f
8000da34:	f0 09 18 00 	cp.b	r9,r8
8000da38:	e0 80 00 81 	breq	8000db3a <_dtoa_r+0x74e>
8000da3c:	40 ea       	lddsp	r10,sp[0x38]
8000da3e:	58 01       	cp.w	r1,0
8000da40:	5f a9       	srle	r9
8000da42:	f3 ea 03 f9 	and	r9,r9,r10>>0x1f
8000da46:	4c 9a       	lddpc	r10,8000db68 <_dtoa_r+0x77c>
8000da48:	f4 06 02 34 	ld.d	r4,r10[r6<<0x3]
8000da4c:	fa e5 00 10 	st.d	sp[16],r4
8000da50:	f0 09 18 00 	cp.b	r9,r8
8000da54:	c1 40       	breq	8000da7c <_dtoa_r+0x690>
8000da56:	58 01       	cp.w	r1,0
8000da58:	e0 81 01 78 	brne	8000dd48 <_dtoa_r+0x95c>
8000da5c:	30 08       	mov	r8,0
8000da5e:	fc 19 40 14 	movh	r9,0x4014
8000da62:	08 9a       	mov	r10,r4
8000da64:	0a 9b       	mov	r11,r5
8000da66:	e0 a0 0b 29 	rcall	8000f0b8 <__avr32_f64_mul>
8000da6a:	fa e8 00 08 	ld.d	r8,sp[8]
8000da6e:	e0 a0 0e 03 	rcall	8000f674 <__avr32_f64_cmp_ge>
8000da72:	e0 81 01 6b 	brne	8000dd48 <_dtoa_r+0x95c>
8000da76:	02 92       	mov	r2,r1
8000da78:	e0 8f 01 73 	bral	8000dd5e <_dtoa_r+0x972>
8000da7c:	40 85       	lddsp	r5,sp[0x20]
8000da7e:	30 14       	mov	r4,1
8000da80:	fa e8 00 10 	ld.d	r8,sp[16]
8000da84:	fa ea 00 08 	ld.d	r10,sp[8]
8000da88:	e0 a0 0e 5e 	rcall	8000f744 <__avr32_f64_div>
8000da8c:	e0 a0 0d 5a 	rcall	8000f540 <__avr32_f64_to_s32>
8000da90:	18 92       	mov	r2,r12
8000da92:	e0 a0 0d 6e 	rcall	8000f56e <__avr32_s32_to_f64>
8000da96:	fa e8 00 10 	ld.d	r8,sp[16]
8000da9a:	e0 a0 0b 0f 	rcall	8000f0b8 <__avr32_f64_mul>
8000da9e:	14 98       	mov	r8,r10
8000daa0:	16 99       	mov	r9,r11
8000daa2:	fa ea 00 08 	ld.d	r10,sp[8]
8000daa6:	e0 a0 0b f5 	rcall	8000f290 <__avr32_f64_sub>
8000daaa:	fa eb 00 08 	st.d	sp[8],r10
8000daae:	e4 c8 ff d0 	sub	r8,r2,-48
8000dab2:	0a c8       	st.b	r5++,r8
8000dab4:	fc 19 40 24 	movh	r9,0x4024
8000dab8:	30 08       	mov	r8,0
8000daba:	02 34       	cp.w	r4,r1
8000dabc:	c3 31       	brne	8000db22 <_dtoa_r+0x736>
8000dabe:	fa e8 00 08 	ld.d	r8,sp[8]
8000dac2:	e0 a0 0c b5 	rcall	8000f42c <__avr32_f64_add>
8000dac6:	16 91       	mov	r1,r11
8000dac8:	14 90       	mov	r0,r10
8000daca:	14 98       	mov	r8,r10
8000dacc:	02 99       	mov	r9,r1
8000dace:	fa ea 00 10 	ld.d	r10,sp[16]
8000dad2:	e0 a0 0e 05 	rcall	8000f6dc <__avr32_f64_cmp_lt>
8000dad6:	c1 a1       	brne	8000db0a <_dtoa_r+0x71e>
8000dad8:	fa e8 00 10 	ld.d	r8,sp[16]
8000dadc:	00 9a       	mov	r10,r0
8000dade:	02 9b       	mov	r11,r1
8000dae0:	e0 a0 0d b7 	rcall	8000f64e <__avr32_f64_cmp_eq>
8000dae4:	e0 80 02 5f 	breq	8000dfa2 <_dtoa_r+0xbb6>
8000dae8:	e5 d2 c0 01 	bfextu	r2,r2,0x0,0x1
8000daec:	c0 f1       	brne	8000db0a <_dtoa_r+0x71e>
8000daee:	e0 8f 02 5a 	bral	8000dfa2 <_dtoa_r+0xbb6>
8000daf2:	40 8a       	lddsp	r10,sp[0x20]
8000daf4:	14 38       	cp.w	r8,r10
8000daf6:	c0 30       	breq	8000dafc <_dtoa_r+0x710>
8000daf8:	10 95       	mov	r5,r8
8000dafa:	c0 98       	rjmp	8000db0c <_dtoa_r+0x720>
8000dafc:	33 08       	mov	r8,48
8000dafe:	40 89       	lddsp	r9,sp[0x20]
8000db00:	2f f6       	sub	r6,-1
8000db02:	b2 88       	st.b	r9[0x0],r8
8000db04:	40 88       	lddsp	r8,sp[0x20]
8000db06:	c0 88       	rjmp	8000db16 <_dtoa_r+0x72a>
8000db08:	40 66       	lddsp	r6,sp[0x18]
8000db0a:	33 99       	mov	r9,57
8000db0c:	0a 98       	mov	r8,r5
8000db0e:	11 7a       	ld.ub	r10,--r8
8000db10:	f2 0a 18 00 	cp.b	r10,r9
8000db14:	ce f0       	breq	8000daf2 <_dtoa_r+0x706>
8000db16:	50 66       	stdsp	sp[0x18],r6
8000db18:	11 89       	ld.ub	r9,r8[0x0]
8000db1a:	2f f9       	sub	r9,-1
8000db1c:	b0 89       	st.b	r8[0x0],r9
8000db1e:	e0 8f 02 43 	bral	8000dfa4 <_dtoa_r+0xbb8>
8000db22:	e0 a0 0a cb 	rcall	8000f0b8 <__avr32_f64_mul>
8000db26:	2f f4       	sub	r4,-1
8000db28:	fa eb 00 08 	st.d	sp[8],r10
8000db2c:	30 08       	mov	r8,0
8000db2e:	30 09       	mov	r9,0
8000db30:	e0 a0 0d 8f 	rcall	8000f64e <__avr32_f64_cmp_eq>
8000db34:	ca 60       	breq	8000da80 <_dtoa_r+0x694>
8000db36:	e0 8f 02 36 	bral	8000dfa2 <_dtoa_r+0xbb6>
8000db3a:	40 d8       	lddsp	r8,sp[0x34]
8000db3c:	58 08       	cp.w	r8,0
8000db3e:	c0 51       	brne	8000db48 <_dtoa_r+0x75c>
8000db40:	04 98       	mov	r8,r2
8000db42:	00 95       	mov	r5,r0
8000db44:	40 d4       	lddsp	r4,sp[0x34]
8000db46:	c3 88       	rjmp	8000dbb6 <_dtoa_r+0x7ca>
8000db48:	40 c5       	lddsp	r5,sp[0x30]
8000db4a:	58 15       	cp.w	r5,1
8000db4c:	e0 89 00 10 	brgt	8000db6c <_dtoa_r+0x780>
8000db50:	41 74       	lddsp	r4,sp[0x5c]
8000db52:	58 04       	cp.w	r4,0
8000db54:	c0 40       	breq	8000db5c <_dtoa_r+0x770>
8000db56:	f4 c9 fb cd 	sub	r9,r10,-1075
8000db5a:	c0 48       	rjmp	8000db62 <_dtoa_r+0x776>
8000db5c:	41 99       	lddsp	r9,sp[0x64]
8000db5e:	f2 09 11 36 	rsub	r9,r9,54
8000db62:	04 98       	mov	r8,r2
8000db64:	00 95       	mov	r5,r0
8000db66:	c1 d8       	rjmp	8000dba0 <_dtoa_r+0x7b4>
8000db68:	80 01       	ld.sh	r1,r0[0x0]
8000db6a:	97 98       	st.w	r11[0x24],r8
8000db6c:	e2 c8 00 01 	sub	r8,r1,1
8000db70:	58 01       	cp.w	r1,0
8000db72:	e0 05 17 40 	movge	r5,r0
8000db76:	e2 09 17 40 	movge	r9,r1
8000db7a:	e1 d1 e5 15 	sublt	r5,r0,r1
8000db7e:	f9 b9 05 00 	movlt	r9,0
8000db82:	10 32       	cp.w	r2,r8
8000db84:	e5 d8 e4 18 	subge	r8,r2,r8
8000db88:	f1 d2 e5 18 	sublt	r8,r8,r2
8000db8c:	e5 d8 e5 02 	addlt	r2,r2,r8
8000db90:	fb fc 50 11 	ld.wlt	r12,sp[0x44]
8000db94:	f9 d8 e5 0c 	addlt	r12,r12,r8
8000db98:	fb fc 5a 11 	st.wlt	sp[0x44],r12
8000db9c:	f9 b8 05 00 	movlt	r8,0
8000dba0:	40 4b       	lddsp	r11,sp[0x10]
8000dba2:	12 0b       	add	r11,r9
8000dba4:	50 08       	stdsp	sp[0x0],r8
8000dba6:	50 4b       	stdsp	sp[0x10],r11
8000dba8:	12 00       	add	r0,r9
8000dbaa:	30 1b       	mov	r11,1
8000dbac:	0e 9c       	mov	r12,r7
8000dbae:	e0 a0 08 ab 	rcall	8000ed04 <__i2b>
8000dbb2:	40 08       	lddsp	r8,sp[0x0]
8000dbb4:	18 94       	mov	r4,r12
8000dbb6:	40 4a       	lddsp	r10,sp[0x10]
8000dbb8:	58 05       	cp.w	r5,0
8000dbba:	5f 99       	srgt	r9
8000dbbc:	58 0a       	cp.w	r10,0
8000dbbe:	5f 9a       	srgt	r10
8000dbc0:	f5 e9 00 09 	and	r9,r10,r9
8000dbc4:	c0 80       	breq	8000dbd4 <_dtoa_r+0x7e8>
8000dbc6:	40 4c       	lddsp	r12,sp[0x10]
8000dbc8:	f8 05 0d 49 	min	r9,r12,r5
8000dbcc:	12 1c       	sub	r12,r9
8000dbce:	12 10       	sub	r0,r9
8000dbd0:	50 4c       	stdsp	sp[0x10],r12
8000dbd2:	12 15       	sub	r5,r9
8000dbd4:	58 02       	cp.w	r2,0
8000dbd6:	e0 8a 00 27 	brle	8000dc24 <_dtoa_r+0x838>
8000dbda:	40 db       	lddsp	r11,sp[0x34]
8000dbdc:	58 0b       	cp.w	r11,0
8000dbde:	c1 d0       	breq	8000dc18 <_dtoa_r+0x82c>
8000dbe0:	58 08       	cp.w	r8,0
8000dbe2:	e0 8a 00 17 	brle	8000dc10 <_dtoa_r+0x824>
8000dbe6:	10 9a       	mov	r10,r8
8000dbe8:	50 08       	stdsp	sp[0x0],r8
8000dbea:	08 9b       	mov	r11,r4
8000dbec:	0e 9c       	mov	r12,r7
8000dbee:	e0 a0 08 d1 	rcall	8000ed90 <__pow5mult>
8000dbf2:	06 9a       	mov	r10,r3
8000dbf4:	18 9b       	mov	r11,r12
8000dbf6:	18 94       	mov	r4,r12
8000dbf8:	0e 9c       	mov	r12,r7
8000dbfa:	e0 a0 08 05 	rcall	8000ec04 <__multiply>
8000dbfe:	18 99       	mov	r9,r12
8000dc00:	06 9b       	mov	r11,r3
8000dc02:	50 19       	stdsp	sp[0x4],r9
8000dc04:	0e 9c       	mov	r12,r7
8000dc06:	e0 a0 06 b1 	rcall	8000e968 <_Bfree>
8000dc0a:	40 19       	lddsp	r9,sp[0x4]
8000dc0c:	40 08       	lddsp	r8,sp[0x0]
8000dc0e:	12 93       	mov	r3,r9
8000dc10:	e4 08 01 0a 	sub	r10,r2,r8
8000dc14:	c0 80       	breq	8000dc24 <_dtoa_r+0x838>
8000dc16:	c0 28       	rjmp	8000dc1a <_dtoa_r+0x82e>
8000dc18:	04 9a       	mov	r10,r2
8000dc1a:	06 9b       	mov	r11,r3
8000dc1c:	0e 9c       	mov	r12,r7
8000dc1e:	e0 a0 08 b9 	rcall	8000ed90 <__pow5mult>
8000dc22:	18 93       	mov	r3,r12
8000dc24:	30 1b       	mov	r11,1
8000dc26:	0e 9c       	mov	r12,r7
8000dc28:	e0 a0 08 6e 	rcall	8000ed04 <__i2b>
8000dc2c:	41 1a       	lddsp	r10,sp[0x44]
8000dc2e:	18 92       	mov	r2,r12
8000dc30:	58 0a       	cp.w	r10,0
8000dc32:	e0 8a 00 07 	brle	8000dc40 <_dtoa_r+0x854>
8000dc36:	18 9b       	mov	r11,r12
8000dc38:	0e 9c       	mov	r12,r7
8000dc3a:	e0 a0 08 ab 	rcall	8000ed90 <__pow5mult>
8000dc3e:	18 92       	mov	r2,r12
8000dc40:	40 c9       	lddsp	r9,sp[0x30]
8000dc42:	58 19       	cp.w	r9,1
8000dc44:	e0 89 00 14 	brgt	8000dc6c <_dtoa_r+0x880>
8000dc48:	40 38       	lddsp	r8,sp[0xc]
8000dc4a:	58 08       	cp.w	r8,0
8000dc4c:	c1 01       	brne	8000dc6c <_dtoa_r+0x880>
8000dc4e:	40 29       	lddsp	r9,sp[0x8]
8000dc50:	f1 d9 c0 14 	bfextu	r8,r9,0x0,0x14
8000dc54:	c0 c1       	brne	8000dc6c <_dtoa_r+0x880>
8000dc56:	12 98       	mov	r8,r9
8000dc58:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000dc5c:	c0 80       	breq	8000dc6c <_dtoa_r+0x880>
8000dc5e:	40 4c       	lddsp	r12,sp[0x10]
8000dc60:	30 1b       	mov	r11,1
8000dc62:	2f fc       	sub	r12,-1
8000dc64:	2f f0       	sub	r0,-1
8000dc66:	50 4c       	stdsp	sp[0x10],r12
8000dc68:	50 6b       	stdsp	sp[0x18],r11
8000dc6a:	c0 38       	rjmp	8000dc70 <_dtoa_r+0x884>
8000dc6c:	30 0a       	mov	r10,0
8000dc6e:	50 6a       	stdsp	sp[0x18],r10
8000dc70:	41 19       	lddsp	r9,sp[0x44]
8000dc72:	58 09       	cp.w	r9,0
8000dc74:	c0 31       	brne	8000dc7a <_dtoa_r+0x88e>
8000dc76:	30 1c       	mov	r12,1
8000dc78:	c0 98       	rjmp	8000dc8a <_dtoa_r+0x89e>
8000dc7a:	64 48       	ld.w	r8,r2[0x10]
8000dc7c:	2f c8       	sub	r8,-4
8000dc7e:	e4 08 03 2c 	ld.w	r12,r2[r8<<0x2]
8000dc82:	e0 a0 05 e3 	rcall	8000e848 <__hi0bits>
8000dc86:	f8 0c 11 20 	rsub	r12,r12,32
8000dc8a:	40 4b       	lddsp	r11,sp[0x10]
8000dc8c:	f8 0b 00 08 	add	r8,r12,r11
8000dc90:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000dc94:	c0 c0       	breq	8000dcac <_dtoa_r+0x8c0>
8000dc96:	f0 08 11 20 	rsub	r8,r8,32
8000dc9a:	58 48       	cp.w	r8,4
8000dc9c:	e0 8a 00 06 	brle	8000dca8 <_dtoa_r+0x8bc>
8000dca0:	20 48       	sub	r8,4
8000dca2:	10 0b       	add	r11,r8
8000dca4:	50 4b       	stdsp	sp[0x10],r11
8000dca6:	c0 78       	rjmp	8000dcb4 <_dtoa_r+0x8c8>
8000dca8:	58 48       	cp.w	r8,4
8000dcaa:	c0 70       	breq	8000dcb8 <_dtoa_r+0x8cc>
8000dcac:	40 4a       	lddsp	r10,sp[0x10]
8000dcae:	2e 48       	sub	r8,-28
8000dcb0:	10 0a       	add	r10,r8
8000dcb2:	50 4a       	stdsp	sp[0x10],r10
8000dcb4:	10 00       	add	r0,r8
8000dcb6:	10 05       	add	r5,r8
8000dcb8:	58 00       	cp.w	r0,0
8000dcba:	e0 8a 00 08 	brle	8000dcca <_dtoa_r+0x8de>
8000dcbe:	06 9b       	mov	r11,r3
8000dcc0:	00 9a       	mov	r10,r0
8000dcc2:	0e 9c       	mov	r12,r7
8000dcc4:	e0 a0 07 5c 	rcall	8000eb7c <__lshift>
8000dcc8:	18 93       	mov	r3,r12
8000dcca:	40 49       	lddsp	r9,sp[0x10]
8000dccc:	58 09       	cp.w	r9,0
8000dcce:	e0 8a 00 08 	brle	8000dcde <_dtoa_r+0x8f2>
8000dcd2:	04 9b       	mov	r11,r2
8000dcd4:	12 9a       	mov	r10,r9
8000dcd6:	0e 9c       	mov	r12,r7
8000dcd8:	e0 a0 07 52 	rcall	8000eb7c <__lshift>
8000dcdc:	18 92       	mov	r2,r12
8000dcde:	41 48       	lddsp	r8,sp[0x50]
8000dce0:	58 08       	cp.w	r8,0
8000dce2:	c1 b0       	breq	8000dd18 <_dtoa_r+0x92c>
8000dce4:	04 9b       	mov	r11,r2
8000dce6:	06 9c       	mov	r12,r3
8000dce8:	e0 a0 06 27 	rcall	8000e936 <__mcmp>
8000dcec:	c1 64       	brge	8000dd18 <_dtoa_r+0x92c>
8000dcee:	06 9b       	mov	r11,r3
8000dcf0:	30 09       	mov	r9,0
8000dcf2:	30 aa       	mov	r10,10
8000dcf4:	0e 9c       	mov	r12,r7
8000dcf6:	e0 a0 08 0f 	rcall	8000ed14 <__multadd>
8000dcfa:	20 16       	sub	r6,1
8000dcfc:	18 93       	mov	r3,r12
8000dcfe:	40 dc       	lddsp	r12,sp[0x34]
8000dd00:	58 0c       	cp.w	r12,0
8000dd02:	c0 31       	brne	8000dd08 <_dtoa_r+0x91c>
8000dd04:	40 91       	lddsp	r1,sp[0x24]
8000dd06:	c0 98       	rjmp	8000dd18 <_dtoa_r+0x92c>
8000dd08:	08 9b       	mov	r11,r4
8000dd0a:	40 91       	lddsp	r1,sp[0x24]
8000dd0c:	30 09       	mov	r9,0
8000dd0e:	30 aa       	mov	r10,10
8000dd10:	0e 9c       	mov	r12,r7
8000dd12:	e0 a0 08 01 	rcall	8000ed14 <__multadd>
8000dd16:	18 94       	mov	r4,r12
8000dd18:	58 01       	cp.w	r1,0
8000dd1a:	5f a9       	srle	r9
8000dd1c:	40 cb       	lddsp	r11,sp[0x30]
8000dd1e:	58 2b       	cp.w	r11,2
8000dd20:	5f 98       	srgt	r8
8000dd22:	f3 e8 00 08 	and	r8,r9,r8
8000dd26:	c2 50       	breq	8000dd70 <_dtoa_r+0x984>
8000dd28:	58 01       	cp.w	r1,0
8000dd2a:	c1 11       	brne	8000dd4c <_dtoa_r+0x960>
8000dd2c:	04 9b       	mov	r11,r2
8000dd2e:	02 99       	mov	r9,r1
8000dd30:	30 5a       	mov	r10,5
8000dd32:	0e 9c       	mov	r12,r7
8000dd34:	e0 a0 07 f0 	rcall	8000ed14 <__multadd>
8000dd38:	18 92       	mov	r2,r12
8000dd3a:	18 9b       	mov	r11,r12
8000dd3c:	06 9c       	mov	r12,r3
8000dd3e:	e0 a0 05 fc 	rcall	8000e936 <__mcmp>
8000dd42:	e0 89 00 0f 	brgt	8000dd60 <_dtoa_r+0x974>
8000dd46:	c0 38       	rjmp	8000dd4c <_dtoa_r+0x960>
8000dd48:	30 02       	mov	r2,0
8000dd4a:	04 94       	mov	r4,r2
8000dd4c:	40 ea       	lddsp	r10,sp[0x38]
8000dd4e:	30 09       	mov	r9,0
8000dd50:	5c da       	com	r10
8000dd52:	40 85       	lddsp	r5,sp[0x20]
8000dd54:	50 6a       	stdsp	sp[0x18],r10
8000dd56:	50 49       	stdsp	sp[0x10],r9
8000dd58:	c0 f9       	rjmp	8000df76 <_dtoa_r+0xb8a>
8000dd5a:	08 92       	mov	r2,r4
8000dd5c:	40 66       	lddsp	r6,sp[0x18]
8000dd5e:	04 94       	mov	r4,r2
8000dd60:	2f f6       	sub	r6,-1
8000dd62:	50 66       	stdsp	sp[0x18],r6
8000dd64:	33 18       	mov	r8,49
8000dd66:	40 85       	lddsp	r5,sp[0x20]
8000dd68:	0a c8       	st.b	r5++,r8
8000dd6a:	30 08       	mov	r8,0
8000dd6c:	50 48       	stdsp	sp[0x10],r8
8000dd6e:	c0 49       	rjmp	8000df76 <_dtoa_r+0xb8a>
8000dd70:	40 dc       	lddsp	r12,sp[0x34]
8000dd72:	58 0c       	cp.w	r12,0
8000dd74:	e0 80 00 b5 	breq	8000dede <_dtoa_r+0xaf2>
8000dd78:	58 05       	cp.w	r5,0
8000dd7a:	e0 8a 00 08 	brle	8000dd8a <_dtoa_r+0x99e>
8000dd7e:	08 9b       	mov	r11,r4
8000dd80:	0a 9a       	mov	r10,r5
8000dd82:	0e 9c       	mov	r12,r7
8000dd84:	e0 a0 06 fc 	rcall	8000eb7c <__lshift>
8000dd88:	18 94       	mov	r4,r12
8000dd8a:	40 6b       	lddsp	r11,sp[0x18]
8000dd8c:	58 0b       	cp.w	r11,0
8000dd8e:	c0 31       	brne	8000dd94 <_dtoa_r+0x9a8>
8000dd90:	08 9c       	mov	r12,r4
8000dd92:	c1 38       	rjmp	8000ddb8 <_dtoa_r+0x9cc>
8000dd94:	68 1b       	ld.w	r11,r4[0x4]
8000dd96:	0e 9c       	mov	r12,r7
8000dd98:	e0 a0 06 02 	rcall	8000e99c <_Balloc>
8000dd9c:	68 4a       	ld.w	r10,r4[0x10]
8000dd9e:	18 95       	mov	r5,r12
8000dda0:	e8 cb ff f4 	sub	r11,r4,-12
8000dda4:	2f ea       	sub	r10,-2
8000dda6:	2f 4c       	sub	r12,-12
8000dda8:	a3 6a       	lsl	r10,0x2
8000ddaa:	fe b0 e5 ae 	rcall	8000a906 <memcpy>
8000ddae:	0a 9b       	mov	r11,r5
8000ddb0:	30 1a       	mov	r10,1
8000ddb2:	0e 9c       	mov	r12,r7
8000ddb4:	e0 a0 06 e4 	rcall	8000eb7c <__lshift>
8000ddb8:	50 44       	stdsp	sp[0x10],r4
8000ddba:	40 3a       	lddsp	r10,sp[0xc]
8000ddbc:	30 19       	mov	r9,1
8000ddbe:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
8000ddc2:	18 94       	mov	r4,r12
8000ddc4:	50 da       	stdsp	sp[0x34],r10
8000ddc6:	40 85       	lddsp	r5,sp[0x20]
8000ddc8:	50 99       	stdsp	sp[0x24],r9
8000ddca:	50 26       	stdsp	sp[0x8],r6
8000ddcc:	50 e1       	stdsp	sp[0x38],r1
8000ddce:	04 9b       	mov	r11,r2
8000ddd0:	06 9c       	mov	r12,r3
8000ddd2:	fe b0 fa 7d 	rcall	8000d2cc <quorem>
8000ddd6:	40 4b       	lddsp	r11,sp[0x10]
8000ddd8:	f8 c0 ff d0 	sub	r0,r12,-48
8000dddc:	06 9c       	mov	r12,r3
8000ddde:	e0 a0 05 ac 	rcall	8000e936 <__mcmp>
8000dde2:	08 9a       	mov	r10,r4
8000dde4:	50 6c       	stdsp	sp[0x18],r12
8000dde6:	04 9b       	mov	r11,r2
8000dde8:	0e 9c       	mov	r12,r7
8000ddea:	e0 a0 06 61 	rcall	8000eaac <__mdiff>
8000ddee:	18 91       	mov	r1,r12
8000ddf0:	78 38       	ld.w	r8,r12[0xc]
8000ddf2:	58 08       	cp.w	r8,0
8000ddf4:	c0 30       	breq	8000ddfa <_dtoa_r+0xa0e>
8000ddf6:	30 16       	mov	r6,1
8000ddf8:	c0 68       	rjmp	8000de04 <_dtoa_r+0xa18>
8000ddfa:	18 9b       	mov	r11,r12
8000ddfc:	06 9c       	mov	r12,r3
8000ddfe:	e0 a0 05 9c 	rcall	8000e936 <__mcmp>
8000de02:	18 96       	mov	r6,r12
8000de04:	0e 9c       	mov	r12,r7
8000de06:	02 9b       	mov	r11,r1
8000de08:	e0 a0 05 b0 	rcall	8000e968 <_Bfree>
8000de0c:	40 cc       	lddsp	r12,sp[0x30]
8000de0e:	ed ec 10 08 	or	r8,r6,r12
8000de12:	c0 d1       	brne	8000de2c <_dtoa_r+0xa40>
8000de14:	40 db       	lddsp	r11,sp[0x34]
8000de16:	58 0b       	cp.w	r11,0
8000de18:	c0 a1       	brne	8000de2c <_dtoa_r+0xa40>
8000de1a:	40 26       	lddsp	r6,sp[0x8]
8000de1c:	e0 40 00 39 	cp.w	r0,57
8000de20:	c3 00       	breq	8000de80 <_dtoa_r+0xa94>
8000de22:	40 6a       	lddsp	r10,sp[0x18]
8000de24:	58 0a       	cp.w	r10,0
8000de26:	e0 89 00 24 	brgt	8000de6e <_dtoa_r+0xa82>
8000de2a:	c2 f8       	rjmp	8000de88 <_dtoa_r+0xa9c>
8000de2c:	40 69       	lddsp	r9,sp[0x18]
8000de2e:	58 09       	cp.w	r9,0
8000de30:	c0 85       	brlt	8000de40 <_dtoa_r+0xa54>
8000de32:	12 98       	mov	r8,r9
8000de34:	40 cc       	lddsp	r12,sp[0x30]
8000de36:	18 48       	or	r8,r12
8000de38:	c1 d1       	brne	8000de72 <_dtoa_r+0xa86>
8000de3a:	40 db       	lddsp	r11,sp[0x34]
8000de3c:	58 0b       	cp.w	r11,0
8000de3e:	c1 a1       	brne	8000de72 <_dtoa_r+0xa86>
8000de40:	0c 99       	mov	r9,r6
8000de42:	40 26       	lddsp	r6,sp[0x8]
8000de44:	58 09       	cp.w	r9,0
8000de46:	e0 8a 00 21 	brle	8000de88 <_dtoa_r+0xa9c>
8000de4a:	06 9b       	mov	r11,r3
8000de4c:	30 1a       	mov	r10,1
8000de4e:	0e 9c       	mov	r12,r7
8000de50:	e0 a0 06 96 	rcall	8000eb7c <__lshift>
8000de54:	04 9b       	mov	r11,r2
8000de56:	18 93       	mov	r3,r12
8000de58:	e0 a0 05 6f 	rcall	8000e936 <__mcmp>
8000de5c:	e0 89 00 06 	brgt	8000de68 <_dtoa_r+0xa7c>
8000de60:	c1 41       	brne	8000de88 <_dtoa_r+0xa9c>
8000de62:	ed b0 00 00 	bld	r0,0x0
8000de66:	c1 11       	brne	8000de88 <_dtoa_r+0xa9c>
8000de68:	e0 40 00 39 	cp.w	r0,57
8000de6c:	c0 a0       	breq	8000de80 <_dtoa_r+0xa94>
8000de6e:	2f f0       	sub	r0,-1
8000de70:	c0 c8       	rjmp	8000de88 <_dtoa_r+0xa9c>
8000de72:	58 06       	cp.w	r6,0
8000de74:	e0 8a 00 0c 	brle	8000de8c <_dtoa_r+0xaa0>
8000de78:	40 26       	lddsp	r6,sp[0x8]
8000de7a:	e0 40 00 39 	cp.w	r0,57
8000de7e:	c0 41       	brne	8000de86 <_dtoa_r+0xa9a>
8000de80:	33 98       	mov	r8,57
8000de82:	0a c8       	st.b	r5++,r8
8000de84:	c6 78       	rjmp	8000df52 <_dtoa_r+0xb66>
8000de86:	2f f0       	sub	r0,-1
8000de88:	0a c0       	st.b	r5++,r0
8000de8a:	c7 58       	rjmp	8000df74 <_dtoa_r+0xb88>
8000de8c:	0a c0       	st.b	r5++,r0
8000de8e:	40 9a       	lddsp	r10,sp[0x24]
8000de90:	40 e9       	lddsp	r9,sp[0x38]
8000de92:	12 3a       	cp.w	r10,r9
8000de94:	c4 30       	breq	8000df1a <_dtoa_r+0xb2e>
8000de96:	06 9b       	mov	r11,r3
8000de98:	30 09       	mov	r9,0
8000de9a:	30 aa       	mov	r10,10
8000de9c:	0e 9c       	mov	r12,r7
8000de9e:	e0 a0 07 3b 	rcall	8000ed14 <__multadd>
8000dea2:	40 48       	lddsp	r8,sp[0x10]
8000dea4:	18 93       	mov	r3,r12
8000dea6:	08 38       	cp.w	r8,r4
8000dea8:	c0 91       	brne	8000deba <_dtoa_r+0xace>
8000deaa:	10 9b       	mov	r11,r8
8000deac:	30 09       	mov	r9,0
8000deae:	30 aa       	mov	r10,10
8000deb0:	0e 9c       	mov	r12,r7
8000deb2:	e0 a0 07 31 	rcall	8000ed14 <__multadd>
8000deb6:	50 4c       	stdsp	sp[0x10],r12
8000deb8:	c0 e8       	rjmp	8000ded4 <_dtoa_r+0xae8>
8000deba:	40 4b       	lddsp	r11,sp[0x10]
8000debc:	30 09       	mov	r9,0
8000debe:	30 aa       	mov	r10,10
8000dec0:	0e 9c       	mov	r12,r7
8000dec2:	e0 a0 07 29 	rcall	8000ed14 <__multadd>
8000dec6:	08 9b       	mov	r11,r4
8000dec8:	50 4c       	stdsp	sp[0x10],r12
8000deca:	30 09       	mov	r9,0
8000decc:	30 aa       	mov	r10,10
8000dece:	0e 9c       	mov	r12,r7
8000ded0:	e0 a0 07 22 	rcall	8000ed14 <__multadd>
8000ded4:	18 94       	mov	r4,r12
8000ded6:	40 9c       	lddsp	r12,sp[0x24]
8000ded8:	2f fc       	sub	r12,-1
8000deda:	50 9c       	stdsp	sp[0x24],r12
8000dedc:	c7 9b       	rjmp	8000ddce <_dtoa_r+0x9e2>
8000dede:	30 18       	mov	r8,1
8000dee0:	06 90       	mov	r0,r3
8000dee2:	40 85       	lddsp	r5,sp[0x20]
8000dee4:	08 93       	mov	r3,r4
8000dee6:	0c 94       	mov	r4,r6
8000dee8:	10 96       	mov	r6,r8
8000deea:	04 9b       	mov	r11,r2
8000deec:	00 9c       	mov	r12,r0
8000deee:	fe b0 f9 ef 	rcall	8000d2cc <quorem>
8000def2:	2d 0c       	sub	r12,-48
8000def4:	0a cc       	st.b	r5++,r12
8000def6:	02 36       	cp.w	r6,r1
8000def8:	c0 a4       	brge	8000df0c <_dtoa_r+0xb20>
8000defa:	00 9b       	mov	r11,r0
8000defc:	30 09       	mov	r9,0
8000defe:	30 aa       	mov	r10,10
8000df00:	0e 9c       	mov	r12,r7
8000df02:	2f f6       	sub	r6,-1
8000df04:	e0 a0 07 08 	rcall	8000ed14 <__multadd>
8000df08:	18 90       	mov	r0,r12
8000df0a:	cf 0b       	rjmp	8000deea <_dtoa_r+0xafe>
8000df0c:	08 96       	mov	r6,r4
8000df0e:	30 0b       	mov	r11,0
8000df10:	06 94       	mov	r4,r3
8000df12:	50 4b       	stdsp	sp[0x10],r11
8000df14:	00 93       	mov	r3,r0
8000df16:	18 90       	mov	r0,r12
8000df18:	c0 28       	rjmp	8000df1c <_dtoa_r+0xb30>
8000df1a:	40 26       	lddsp	r6,sp[0x8]
8000df1c:	06 9b       	mov	r11,r3
8000df1e:	30 1a       	mov	r10,1
8000df20:	0e 9c       	mov	r12,r7
8000df22:	e0 a0 06 2d 	rcall	8000eb7c <__lshift>
8000df26:	04 9b       	mov	r11,r2
8000df28:	18 93       	mov	r3,r12
8000df2a:	e0 a0 05 06 	rcall	8000e936 <__mcmp>
8000df2e:	e0 89 00 12 	brgt	8000df52 <_dtoa_r+0xb66>
8000df32:	c1 b1       	brne	8000df68 <_dtoa_r+0xb7c>
8000df34:	e1 d0 c0 01 	bfextu	r0,r0,0x0,0x1
8000df38:	c0 d1       	brne	8000df52 <_dtoa_r+0xb66>
8000df3a:	c1 78       	rjmp	8000df68 <_dtoa_r+0xb7c>
8000df3c:	40 89       	lddsp	r9,sp[0x20]
8000df3e:	12 38       	cp.w	r8,r9
8000df40:	c0 30       	breq	8000df46 <_dtoa_r+0xb5a>
8000df42:	10 95       	mov	r5,r8
8000df44:	c0 88       	rjmp	8000df54 <_dtoa_r+0xb68>
8000df46:	2f f6       	sub	r6,-1
8000df48:	50 66       	stdsp	sp[0x18],r6
8000df4a:	33 18       	mov	r8,49
8000df4c:	40 8c       	lddsp	r12,sp[0x20]
8000df4e:	b8 88       	st.b	r12[0x0],r8
8000df50:	c1 38       	rjmp	8000df76 <_dtoa_r+0xb8a>
8000df52:	33 9a       	mov	r10,57
8000df54:	0a 98       	mov	r8,r5
8000df56:	11 79       	ld.ub	r9,--r8
8000df58:	f4 09 18 00 	cp.b	r9,r10
8000df5c:	cf 00       	breq	8000df3c <_dtoa_r+0xb50>
8000df5e:	2f f9       	sub	r9,-1
8000df60:	b0 89       	st.b	r8[0x0],r9
8000df62:	c0 98       	rjmp	8000df74 <_dtoa_r+0xb88>
8000df64:	10 95       	mov	r5,r8
8000df66:	c0 28       	rjmp	8000df6a <_dtoa_r+0xb7e>
8000df68:	33 09       	mov	r9,48
8000df6a:	0a 98       	mov	r8,r5
8000df6c:	11 7a       	ld.ub	r10,--r8
8000df6e:	f2 0a 18 00 	cp.b	r10,r9
8000df72:	cf 90       	breq	8000df64 <_dtoa_r+0xb78>
8000df74:	50 66       	stdsp	sp[0x18],r6
8000df76:	04 9b       	mov	r11,r2
8000df78:	0e 9c       	mov	r12,r7
8000df7a:	e0 a0 04 f7 	rcall	8000e968 <_Bfree>
8000df7e:	58 04       	cp.w	r4,0
8000df80:	c1 20       	breq	8000dfa4 <_dtoa_r+0xbb8>
8000df82:	40 4b       	lddsp	r11,sp[0x10]
8000df84:	08 3b       	cp.w	r11,r4
8000df86:	5f 19       	srne	r9
8000df88:	58 0b       	cp.w	r11,0
8000df8a:	5f 18       	srne	r8
8000df8c:	f3 e8 00 08 	and	r8,r9,r8
8000df90:	c0 40       	breq	8000df98 <_dtoa_r+0xbac>
8000df92:	0e 9c       	mov	r12,r7
8000df94:	e0 a0 04 ea 	rcall	8000e968 <_Bfree>
8000df98:	08 9b       	mov	r11,r4
8000df9a:	0e 9c       	mov	r12,r7
8000df9c:	e0 a0 04 e6 	rcall	8000e968 <_Bfree>
8000dfa0:	c0 28       	rjmp	8000dfa4 <_dtoa_r+0xbb8>
8000dfa2:	50 66       	stdsp	sp[0x18],r6
8000dfa4:	0e 9c       	mov	r12,r7
8000dfa6:	06 9b       	mov	r11,r3
8000dfa8:	e0 a0 04 e0 	rcall	8000e968 <_Bfree>
8000dfac:	30 08       	mov	r8,0
8000dfae:	aa 88       	st.b	r5[0x0],r8
8000dfb0:	40 68       	lddsp	r8,sp[0x18]
8000dfb2:	41 5a       	lddsp	r10,sp[0x54]
8000dfb4:	2f f8       	sub	r8,-1
8000dfb6:	41 29       	lddsp	r9,sp[0x48]
8000dfb8:	95 08       	st.w	r10[0x0],r8
8000dfba:	40 8c       	lddsp	r12,sp[0x20]
8000dfbc:	58 09       	cp.w	r9,0
8000dfbe:	fb f8 10 12 	ld.wne	r8,sp[0x48]
8000dfc2:	f1 f5 1a 00 	st.wne	r8[0x0],r5
8000dfc6:	2e 6d       	sub	sp,-104
8000dfc8:	d8 32       	popm	r0-r7,pc
8000dfca:	d7 03       	nop

8000dfcc <__errno>:
8000dfcc:	e0 68 0a 38 	mov	r8,2616
8000dfd0:	70 0c       	ld.w	r12,r8[0x0]
8000dfd2:	2f 4c       	sub	r12,-12
8000dfd4:	5e fc       	retal	r12
8000dfd6:	d7 03       	nop

8000dfd8 <_fflush_r>:
8000dfd8:	d4 21       	pushm	r4-r7,lr
8000dfda:	16 97       	mov	r7,r11
8000dfdc:	18 96       	mov	r6,r12
8000dfde:	76 48       	ld.w	r8,r11[0x10]
8000dfe0:	58 08       	cp.w	r8,0
8000dfe2:	c7 c0       	breq	8000e0da <_fflush_r+0x102>
8000dfe4:	58 0c       	cp.w	r12,0
8000dfe6:	c0 50       	breq	8000dff0 <_fflush_r+0x18>
8000dfe8:	78 68       	ld.w	r8,r12[0x18]
8000dfea:	58 08       	cp.w	r8,0
8000dfec:	c0 21       	brne	8000dff0 <_fflush_r+0x18>
8000dfee:	cd 1c       	rcall	8000e190 <__sinit>
8000dff0:	4b b8       	lddpc	r8,8000e0dc <_fflush_r+0x104>
8000dff2:	10 37       	cp.w	r7,r8
8000dff4:	c0 31       	brne	8000dffa <_fflush_r+0x22>
8000dff6:	6c 07       	ld.w	r7,r6[0x0]
8000dff8:	c0 a8       	rjmp	8000e00c <_fflush_r+0x34>
8000dffa:	4b a8       	lddpc	r8,8000e0e0 <_fflush_r+0x108>
8000dffc:	10 37       	cp.w	r7,r8
8000dffe:	c0 31       	brne	8000e004 <_fflush_r+0x2c>
8000e000:	6c 17       	ld.w	r7,r6[0x4]
8000e002:	c0 58       	rjmp	8000e00c <_fflush_r+0x34>
8000e004:	4b 88       	lddpc	r8,8000e0e4 <_fflush_r+0x10c>
8000e006:	10 37       	cp.w	r7,r8
8000e008:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000e00c:	8e 6a       	ld.sh	r10,r7[0xc]
8000e00e:	14 98       	mov	r8,r10
8000e010:	ed ba 00 03 	bld	r10,0x3
8000e014:	c4 20       	breq	8000e098 <_fflush_r+0xc0>
8000e016:	ab ba       	sbr	r10,0xb
8000e018:	ae 6a       	st.h	r7[0xc],r10
8000e01a:	6e 18       	ld.w	r8,r7[0x4]
8000e01c:	58 08       	cp.w	r8,0
8000e01e:	e0 89 00 06 	brgt	8000e02a <_fflush_r+0x52>
8000e022:	6f 08       	ld.w	r8,r7[0x40]
8000e024:	58 08       	cp.w	r8,0
8000e026:	e0 8a 00 5a 	brle	8000e0da <_fflush_r+0x102>
8000e02a:	6e b8       	ld.w	r8,r7[0x2c]
8000e02c:	58 08       	cp.w	r8,0
8000e02e:	c5 60       	breq	8000e0da <_fflush_r+0x102>
8000e030:	e2 1a 10 00 	andl	r10,0x1000,COH
8000e034:	c0 30       	breq	8000e03a <_fflush_r+0x62>
8000e036:	6f 55       	ld.w	r5,r7[0x54]
8000e038:	c0 f8       	rjmp	8000e056 <_fflush_r+0x7e>
8000e03a:	30 19       	mov	r9,1
8000e03c:	6e 8b       	ld.w	r11,r7[0x20]
8000e03e:	0c 9c       	mov	r12,r6
8000e040:	5d 18       	icall	r8
8000e042:	18 95       	mov	r5,r12
8000e044:	5b fc       	cp.w	r12,-1
8000e046:	c0 81       	brne	8000e056 <_fflush_r+0x7e>
8000e048:	6c 38       	ld.w	r8,r6[0xc]
8000e04a:	59 d8       	cp.w	r8,29
8000e04c:	c4 70       	breq	8000e0da <_fflush_r+0x102>
8000e04e:	8e 68       	ld.sh	r8,r7[0xc]
8000e050:	a7 a8       	sbr	r8,0x6
8000e052:	ae 68       	st.h	r7[0xc],r8
8000e054:	d8 22       	popm	r4-r7,pc
8000e056:	8e 68       	ld.sh	r8,r7[0xc]
8000e058:	ed b8 00 02 	bld	r8,0x2
8000e05c:	c0 91       	brne	8000e06e <_fflush_r+0x96>
8000e05e:	6e 18       	ld.w	r8,r7[0x4]
8000e060:	10 15       	sub	r5,r8
8000e062:	6e d8       	ld.w	r8,r7[0x34]
8000e064:	58 08       	cp.w	r8,0
8000e066:	ef f8 10 10 	ld.wne	r8,r7[0x40]
8000e06a:	eb d8 e1 15 	subne	r5,r5,r8
8000e06e:	6e b8       	ld.w	r8,r7[0x2c]
8000e070:	0c 9c       	mov	r12,r6
8000e072:	30 09       	mov	r9,0
8000e074:	0a 9a       	mov	r10,r5
8000e076:	6e 8b       	ld.w	r11,r7[0x20]
8000e078:	5d 18       	icall	r8
8000e07a:	8e 68       	ld.sh	r8,r7[0xc]
8000e07c:	0a 3c       	cp.w	r12,r5
8000e07e:	c2 61       	brne	8000e0ca <_fflush_r+0xf2>
8000e080:	ab d8       	cbr	r8,0xb
8000e082:	30 0c       	mov	r12,0
8000e084:	6e 49       	ld.w	r9,r7[0x10]
8000e086:	ae 68       	st.h	r7[0xc],r8
8000e088:	8f 1c       	st.w	r7[0x4],r12
8000e08a:	8f 09       	st.w	r7[0x0],r9
8000e08c:	ed b8 00 0c 	bld	r8,0xc
8000e090:	c2 51       	brne	8000e0da <_fflush_r+0x102>
8000e092:	ef 45 00 54 	st.w	r7[84],r5
8000e096:	d8 22       	popm	r4-r7,pc
8000e098:	6e 45       	ld.w	r5,r7[0x10]
8000e09a:	58 05       	cp.w	r5,0
8000e09c:	c1 f0       	breq	8000e0da <_fflush_r+0x102>
8000e09e:	6e 04       	ld.w	r4,r7[0x0]
8000e0a0:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
8000e0a4:	8f 05       	st.w	r7[0x0],r5
8000e0a6:	f9 b8 01 00 	movne	r8,0
8000e0aa:	ef f8 00 05 	ld.weq	r8,r7[0x14]
8000e0ae:	0a 14       	sub	r4,r5
8000e0b0:	8f 28       	st.w	r7[0x8],r8
8000e0b2:	c1 18       	rjmp	8000e0d4 <_fflush_r+0xfc>
8000e0b4:	08 99       	mov	r9,r4
8000e0b6:	0a 9a       	mov	r10,r5
8000e0b8:	6e a8       	ld.w	r8,r7[0x28]
8000e0ba:	6e 8b       	ld.w	r11,r7[0x20]
8000e0bc:	0c 9c       	mov	r12,r6
8000e0be:	5d 18       	icall	r8
8000e0c0:	18 14       	sub	r4,r12
8000e0c2:	58 0c       	cp.w	r12,0
8000e0c4:	e0 89 00 07 	brgt	8000e0d2 <_fflush_r+0xfa>
8000e0c8:	8e 68       	ld.sh	r8,r7[0xc]
8000e0ca:	a7 a8       	sbr	r8,0x6
8000e0cc:	3f fc       	mov	r12,-1
8000e0ce:	ae 68       	st.h	r7[0xc],r8
8000e0d0:	d8 22       	popm	r4-r7,pc
8000e0d2:	18 05       	add	r5,r12
8000e0d4:	58 04       	cp.w	r4,0
8000e0d6:	fe 99 ff ef 	brgt	8000e0b4 <_fflush_r+0xdc>
8000e0da:	d8 2a       	popm	r4-r7,pc,r12=0
8000e0dc:	80 01       	ld.sh	r1,r0[0x0]
8000e0de:	96 e8       	ld.uh	r8,r11[0xc]
8000e0e0:	80 01       	ld.sh	r1,r0[0x0]
8000e0e2:	97 08       	st.w	r11[0x0],r8
8000e0e4:	80 01       	ld.sh	r1,r0[0x0]
8000e0e6:	97 28       	st.w	r11[0x8],r8

8000e0e8 <__sfp_lock_acquire>:
8000e0e8:	5e fc       	retal	r12

8000e0ea <__sfp_lock_release>:
8000e0ea:	5e fc       	retal	r12

8000e0ec <_cleanup_r>:
8000e0ec:	d4 01       	pushm	lr
8000e0ee:	fe cb f0 ba 	sub	r11,pc,-3910
8000e0f2:	e0 a0 02 f9 	rcall	8000e6e4 <_fwalk>
8000e0f6:	d8 02       	popm	pc

8000e0f8 <__sfmoreglue>:
8000e0f8:	d4 21       	pushm	r4-r7,lr
8000e0fa:	16 95       	mov	r5,r11
8000e0fc:	f6 06 10 5c 	mul	r6,r11,92
8000e100:	ec cb ff f4 	sub	r11,r6,-12
8000e104:	fe b0 e1 d2 	rcall	8000a4a8 <_malloc_r>
8000e108:	18 97       	mov	r7,r12
8000e10a:	c0 90       	breq	8000e11c <__sfmoreglue+0x24>
8000e10c:	99 15       	st.w	r12[0x4],r5
8000e10e:	30 0b       	mov	r11,0
8000e110:	2f 4c       	sub	r12,-12
8000e112:	0c 9a       	mov	r10,r6
8000e114:	8f 2c       	st.w	r7[0x8],r12
8000e116:	8f 0b       	st.w	r7[0x0],r11
8000e118:	fe b0 e4 9b 	rcall	8000aa4e <memset>
8000e11c:	0e 9c       	mov	r12,r7
8000e11e:	d8 22       	popm	r4-r7,pc

8000e120 <__sfp>:
8000e120:	d4 21       	pushm	r4-r7,lr
8000e122:	49 b8       	lddpc	r8,8000e18c <__sfp+0x6c>
8000e124:	18 96       	mov	r6,r12
8000e126:	70 07       	ld.w	r7,r8[0x0]
8000e128:	6e 68       	ld.w	r8,r7[0x18]
8000e12a:	58 08       	cp.w	r8,0
8000e12c:	c0 31       	brne	8000e132 <__sfp+0x12>
8000e12e:	0e 9c       	mov	r12,r7
8000e130:	c3 0c       	rcall	8000e190 <__sinit>
8000e132:	ee c7 ff 28 	sub	r7,r7,-216
8000e136:	30 05       	mov	r5,0
8000e138:	6e 2c       	ld.w	r12,r7[0x8]
8000e13a:	6e 18       	ld.w	r8,r7[0x4]
8000e13c:	c0 68       	rjmp	8000e148 <__sfp+0x28>
8000e13e:	98 69       	ld.sh	r9,r12[0xc]
8000e140:	ea 09 19 00 	cp.h	r9,r5
8000e144:	c1 10       	breq	8000e166 <__sfp+0x46>
8000e146:	2a 4c       	sub	r12,-92
8000e148:	20 18       	sub	r8,1
8000e14a:	cf a7       	brpl	8000e13e <__sfp+0x1e>
8000e14c:	6e 08       	ld.w	r8,r7[0x0]
8000e14e:	58 08       	cp.w	r8,0
8000e150:	c0 61       	brne	8000e15c <__sfp+0x3c>
8000e152:	30 4b       	mov	r11,4
8000e154:	0c 9c       	mov	r12,r6
8000e156:	cd 1f       	rcall	8000e0f8 <__sfmoreglue>
8000e158:	8f 0c       	st.w	r7[0x0],r12
8000e15a:	c0 30       	breq	8000e160 <__sfp+0x40>
8000e15c:	6e 07       	ld.w	r7,r7[0x0]
8000e15e:	ce db       	rjmp	8000e138 <__sfp+0x18>
8000e160:	30 c8       	mov	r8,12
8000e162:	8d 38       	st.w	r6[0xc],r8
8000e164:	d8 22       	popm	r4-r7,pc
8000e166:	30 08       	mov	r8,0
8000e168:	f9 48 00 4c 	st.w	r12[76],r8
8000e16c:	99 08       	st.w	r12[0x0],r8
8000e16e:	99 28       	st.w	r12[0x8],r8
8000e170:	99 18       	st.w	r12[0x4],r8
8000e172:	99 48       	st.w	r12[0x10],r8
8000e174:	99 58       	st.w	r12[0x14],r8
8000e176:	99 68       	st.w	r12[0x18],r8
8000e178:	99 d8       	st.w	r12[0x34],r8
8000e17a:	99 e8       	st.w	r12[0x38],r8
8000e17c:	f9 48 00 48 	st.w	r12[72],r8
8000e180:	3f f8       	mov	r8,-1
8000e182:	b8 78       	st.h	r12[0xe],r8
8000e184:	30 18       	mov	r8,1
8000e186:	b8 68       	st.h	r12[0xc],r8
8000e188:	d8 22       	popm	r4-r7,pc
8000e18a:	d7 03       	nop
8000e18c:	80 01       	ld.sh	r1,r0[0x0]
8000e18e:	97 4c       	st.w	r11[0x10],r12

8000e190 <__sinit>:
8000e190:	d4 21       	pushm	r4-r7,lr
8000e192:	18 96       	mov	r6,r12
8000e194:	78 67       	ld.w	r7,r12[0x18]
8000e196:	58 07       	cp.w	r7,0
8000e198:	c4 91       	brne	8000e22a <__sinit+0x9a>
8000e19a:	fe c8 00 ae 	sub	r8,pc,174
8000e19e:	30 15       	mov	r5,1
8000e1a0:	99 a8       	st.w	r12[0x28],r8
8000e1a2:	f9 47 00 d8 	st.w	r12[216],r7
8000e1a6:	f9 47 00 dc 	st.w	r12[220],r7
8000e1aa:	f9 47 00 e0 	st.w	r12[224],r7
8000e1ae:	99 65       	st.w	r12[0x18],r5
8000e1b0:	cb 8f       	rcall	8000e120 <__sfp>
8000e1b2:	8d 0c       	st.w	r6[0x0],r12
8000e1b4:	0c 9c       	mov	r12,r6
8000e1b6:	cb 5f       	rcall	8000e120 <__sfp>
8000e1b8:	8d 1c       	st.w	r6[0x4],r12
8000e1ba:	0c 9c       	mov	r12,r6
8000e1bc:	cb 2f       	rcall	8000e120 <__sfp>
8000e1be:	6c 09       	ld.w	r9,r6[0x0]
8000e1c0:	30 48       	mov	r8,4
8000e1c2:	93 07       	st.w	r9[0x0],r7
8000e1c4:	b2 68       	st.h	r9[0xc],r8
8000e1c6:	93 17       	st.w	r9[0x4],r7
8000e1c8:	93 27       	st.w	r9[0x8],r7
8000e1ca:	6c 18       	ld.w	r8,r6[0x4]
8000e1cc:	b2 77       	st.h	r9[0xe],r7
8000e1ce:	93 47       	st.w	r9[0x10],r7
8000e1d0:	93 57       	st.w	r9[0x14],r7
8000e1d2:	93 67       	st.w	r9[0x18],r7
8000e1d4:	93 89       	st.w	r9[0x20],r9
8000e1d6:	91 07       	st.w	r8[0x0],r7
8000e1d8:	91 17       	st.w	r8[0x4],r7
8000e1da:	91 27       	st.w	r8[0x8],r7
8000e1dc:	fe ce f3 20 	sub	lr,pc,-3296
8000e1e0:	fe cb f3 50 	sub	r11,pc,-3248
8000e1e4:	93 9e       	st.w	r9[0x24],lr
8000e1e6:	93 ab       	st.w	r9[0x28],r11
8000e1e8:	fe ca f3 78 	sub	r10,pc,-3208
8000e1ec:	fe c4 f3 84 	sub	r4,pc,-3196
8000e1f0:	93 ba       	st.w	r9[0x2c],r10
8000e1f2:	93 c4       	st.w	r9[0x30],r4
8000e1f4:	30 99       	mov	r9,9
8000e1f6:	b0 69       	st.h	r8[0xc],r9
8000e1f8:	b0 75       	st.h	r8[0xe],r5
8000e1fa:	91 c4       	st.w	r8[0x30],r4
8000e1fc:	91 47       	st.w	r8[0x10],r7
8000e1fe:	91 57       	st.w	r8[0x14],r7
8000e200:	91 67       	st.w	r8[0x18],r7
8000e202:	91 88       	st.w	r8[0x20],r8
8000e204:	91 9e       	st.w	r8[0x24],lr
8000e206:	91 ab       	st.w	r8[0x28],r11
8000e208:	91 ba       	st.w	r8[0x2c],r10
8000e20a:	8d 2c       	st.w	r6[0x8],r12
8000e20c:	31 28       	mov	r8,18
8000e20e:	99 07       	st.w	r12[0x0],r7
8000e210:	b8 68       	st.h	r12[0xc],r8
8000e212:	99 17       	st.w	r12[0x4],r7
8000e214:	99 27       	st.w	r12[0x8],r7
8000e216:	30 28       	mov	r8,2
8000e218:	b8 78       	st.h	r12[0xe],r8
8000e21a:	99 c4       	st.w	r12[0x30],r4
8000e21c:	99 67       	st.w	r12[0x18],r7
8000e21e:	99 9e       	st.w	r12[0x24],lr
8000e220:	99 ab       	st.w	r12[0x28],r11
8000e222:	99 ba       	st.w	r12[0x2c],r10
8000e224:	99 47       	st.w	r12[0x10],r7
8000e226:	99 57       	st.w	r12[0x14],r7
8000e228:	99 8c       	st.w	r12[0x20],r12
8000e22a:	d8 22       	popm	r4-r7,pc

8000e22c <_malloc_trim_r>:
8000e22c:	d4 21       	pushm	r4-r7,lr
8000e22e:	16 95       	mov	r5,r11
8000e230:	18 97       	mov	r7,r12
8000e232:	fe b0 d6 87 	rcall	80008f40 <__malloc_lock>
8000e236:	e0 64 05 38 	mov	r4,1336
8000e23a:	68 28       	ld.w	r8,r4[0x8]
8000e23c:	70 16       	ld.w	r6,r8[0x4]
8000e23e:	e0 16 ff fc 	andl	r6,0xfffc
8000e242:	ec c8 ff 91 	sub	r8,r6,-111
8000e246:	f0 05 01 05 	sub	r5,r8,r5
8000e24a:	e0 15 ff 80 	andl	r5,0xff80
8000e24e:	ea c5 00 80 	sub	r5,r5,128
8000e252:	e0 45 00 7f 	cp.w	r5,127
8000e256:	e0 8a 00 25 	brle	8000e2a0 <_malloc_trim_r+0x74>
8000e25a:	30 0b       	mov	r11,0
8000e25c:	0e 9c       	mov	r12,r7
8000e25e:	fe b0 e5 5f 	rcall	8000ad1c <_sbrk_r>
8000e262:	68 28       	ld.w	r8,r4[0x8]
8000e264:	0c 08       	add	r8,r6
8000e266:	10 3c       	cp.w	r12,r8
8000e268:	c1 c1       	brne	8000e2a0 <_malloc_trim_r+0x74>
8000e26a:	ea 0b 11 00 	rsub	r11,r5,0
8000e26e:	0e 9c       	mov	r12,r7
8000e270:	fe b0 e5 56 	rcall	8000ad1c <_sbrk_r>
8000e274:	5b fc       	cp.w	r12,-1
8000e276:	c1 91       	brne	8000e2a8 <_malloc_trim_r+0x7c>
8000e278:	30 0b       	mov	r11,0
8000e27a:	0e 9c       	mov	r12,r7
8000e27c:	fe b0 e5 50 	rcall	8000ad1c <_sbrk_r>
8000e280:	68 28       	ld.w	r8,r4[0x8]
8000e282:	f8 08 01 09 	sub	r9,r12,r8
8000e286:	58 f9       	cp.w	r9,15
8000e288:	e0 8a 00 0c 	brle	8000e2a0 <_malloc_trim_r+0x74>
8000e28c:	a1 a9       	sbr	r9,0x0
8000e28e:	91 19       	st.w	r8[0x4],r9
8000e290:	e0 68 09 44 	mov	r8,2372
8000e294:	70 09       	ld.w	r9,r8[0x0]
8000e296:	e0 68 13 20 	mov	r8,4896
8000e29a:	f8 09 01 09 	sub	r9,r12,r9
8000e29e:	91 09       	st.w	r8[0x0],r9
8000e2a0:	0e 9c       	mov	r12,r7
8000e2a2:	fe b0 d6 55 	rcall	80008f4c <__malloc_unlock>
8000e2a6:	d8 2a       	popm	r4-r7,pc,r12=0
8000e2a8:	68 28       	ld.w	r8,r4[0x8]
8000e2aa:	0a 16       	sub	r6,r5
8000e2ac:	a1 a6       	sbr	r6,0x0
8000e2ae:	91 16       	st.w	r8[0x4],r6
8000e2b0:	e0 68 13 20 	mov	r8,4896
8000e2b4:	70 09       	ld.w	r9,r8[0x0]
8000e2b6:	0a 19       	sub	r9,r5
8000e2b8:	0e 9c       	mov	r12,r7
8000e2ba:	91 09       	st.w	r8[0x0],r9
8000e2bc:	fe b0 d6 48 	rcall	80008f4c <__malloc_unlock>
8000e2c0:	da 2a       	popm	r4-r7,pc,r12=1
8000e2c2:	d7 03       	nop

8000e2c4 <_free_r>:
8000e2c4:	d4 21       	pushm	r4-r7,lr
8000e2c6:	16 96       	mov	r6,r11
8000e2c8:	18 97       	mov	r7,r12
8000e2ca:	58 0b       	cp.w	r11,0
8000e2cc:	e0 80 00 c0 	breq	8000e44c <_free_r+0x188>
8000e2d0:	fe b0 d6 38 	rcall	80008f40 <__malloc_lock>
8000e2d4:	20 86       	sub	r6,8
8000e2d6:	e0 6a 05 38 	mov	r10,1336
8000e2da:	6c 18       	ld.w	r8,r6[0x4]
8000e2dc:	74 2e       	ld.w	lr,r10[0x8]
8000e2de:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
8000e2e2:	a1 c8       	cbr	r8,0x0
8000e2e4:	ec 08 00 09 	add	r9,r6,r8
8000e2e8:	72 1b       	ld.w	r11,r9[0x4]
8000e2ea:	e0 1b ff fc 	andl	r11,0xfffc
8000e2ee:	1c 39       	cp.w	r9,lr
8000e2f0:	c1 e1       	brne	8000e32c <_free_r+0x68>
8000e2f2:	f6 08 00 08 	add	r8,r11,r8
8000e2f6:	58 0c       	cp.w	r12,0
8000e2f8:	c0 81       	brne	8000e308 <_free_r+0x44>
8000e2fa:	6c 09       	ld.w	r9,r6[0x0]
8000e2fc:	12 16       	sub	r6,r9
8000e2fe:	12 08       	add	r8,r9
8000e300:	6c 3b       	ld.w	r11,r6[0xc]
8000e302:	6c 29       	ld.w	r9,r6[0x8]
8000e304:	97 29       	st.w	r11[0x8],r9
8000e306:	93 3b       	st.w	r9[0xc],r11
8000e308:	10 99       	mov	r9,r8
8000e30a:	95 26       	st.w	r10[0x8],r6
8000e30c:	a1 a9       	sbr	r9,0x0
8000e30e:	8d 19       	st.w	r6[0x4],r9
8000e310:	e0 69 09 40 	mov	r9,2368
8000e314:	72 09       	ld.w	r9,r9[0x0]
8000e316:	12 38       	cp.w	r8,r9
8000e318:	c0 63       	brcs	8000e324 <_free_r+0x60>
8000e31a:	e0 68 13 1c 	mov	r8,4892
8000e31e:	0e 9c       	mov	r12,r7
8000e320:	70 0b       	ld.w	r11,r8[0x0]
8000e322:	c8 5f       	rcall	8000e22c <_malloc_trim_r>
8000e324:	0e 9c       	mov	r12,r7
8000e326:	fe b0 d6 13 	rcall	80008f4c <__malloc_unlock>
8000e32a:	d8 22       	popm	r4-r7,pc
8000e32c:	93 1b       	st.w	r9[0x4],r11
8000e32e:	58 0c       	cp.w	r12,0
8000e330:	c0 30       	breq	8000e336 <_free_r+0x72>
8000e332:	30 0c       	mov	r12,0
8000e334:	c1 08       	rjmp	8000e354 <_free_r+0x90>
8000e336:	6c 0e       	ld.w	lr,r6[0x0]
8000e338:	f4 c5 ff f8 	sub	r5,r10,-8
8000e33c:	1c 16       	sub	r6,lr
8000e33e:	1c 08       	add	r8,lr
8000e340:	6c 2e       	ld.w	lr,r6[0x8]
8000e342:	0a 3e       	cp.w	lr,r5
8000e344:	f9 bc 00 01 	moveq	r12,1
8000e348:	ed f5 10 03 	ld.wne	r5,r6[0xc]
8000e34c:	eb fe 1a 02 	st.wne	r5[0x8],lr
8000e350:	fd f5 1a 03 	st.wne	lr[0xc],r5
8000e354:	f2 0b 00 0e 	add	lr,r9,r11
8000e358:	7c 1e       	ld.w	lr,lr[0x4]
8000e35a:	ed be 00 00 	bld	lr,0x0
8000e35e:	c1 40       	breq	8000e386 <_free_r+0xc2>
8000e360:	16 08       	add	r8,r11
8000e362:	58 0c       	cp.w	r12,0
8000e364:	c0 d1       	brne	8000e37e <_free_r+0xba>
8000e366:	e0 6e 05 38 	mov	lr,1336
8000e36a:	72 2b       	ld.w	r11,r9[0x8]
8000e36c:	2f 8e       	sub	lr,-8
8000e36e:	1c 3b       	cp.w	r11,lr
8000e370:	c0 71       	brne	8000e37e <_free_r+0xba>
8000e372:	97 36       	st.w	r11[0xc],r6
8000e374:	97 26       	st.w	r11[0x8],r6
8000e376:	8d 2b       	st.w	r6[0x8],r11
8000e378:	8d 3b       	st.w	r6[0xc],r11
8000e37a:	30 1c       	mov	r12,1
8000e37c:	c0 58       	rjmp	8000e386 <_free_r+0xc2>
8000e37e:	72 2b       	ld.w	r11,r9[0x8]
8000e380:	72 39       	ld.w	r9,r9[0xc]
8000e382:	93 2b       	st.w	r9[0x8],r11
8000e384:	97 39       	st.w	r11[0xc],r9
8000e386:	10 99       	mov	r9,r8
8000e388:	ec 08 09 08 	st.w	r6[r8],r8
8000e38c:	a1 a9       	sbr	r9,0x0
8000e38e:	8d 19       	st.w	r6[0x4],r9
8000e390:	58 0c       	cp.w	r12,0
8000e392:	c5 a1       	brne	8000e446 <_free_r+0x182>
8000e394:	e0 48 01 ff 	cp.w	r8,511
8000e398:	e0 8b 00 13 	brhi	8000e3be <_free_r+0xfa>
8000e39c:	a3 98       	lsr	r8,0x3
8000e39e:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000e3a2:	72 2b       	ld.w	r11,r9[0x8]
8000e3a4:	8d 39       	st.w	r6[0xc],r9
8000e3a6:	8d 2b       	st.w	r6[0x8],r11
8000e3a8:	97 36       	st.w	r11[0xc],r6
8000e3aa:	93 26       	st.w	r9[0x8],r6
8000e3ac:	a3 48       	asr	r8,0x2
8000e3ae:	74 19       	ld.w	r9,r10[0x4]
8000e3b0:	30 1b       	mov	r11,1
8000e3b2:	f6 08 09 48 	lsl	r8,r11,r8
8000e3b6:	f3 e8 10 08 	or	r8,r9,r8
8000e3ba:	95 18       	st.w	r10[0x4],r8
8000e3bc:	c4 58       	rjmp	8000e446 <_free_r+0x182>
8000e3be:	f0 0b 16 09 	lsr	r11,r8,0x9
8000e3c2:	58 4b       	cp.w	r11,4
8000e3c4:	e0 8b 00 06 	brhi	8000e3d0 <_free_r+0x10c>
8000e3c8:	f0 0b 16 06 	lsr	r11,r8,0x6
8000e3cc:	2c 8b       	sub	r11,-56
8000e3ce:	c2 08       	rjmp	8000e40e <_free_r+0x14a>
8000e3d0:	59 4b       	cp.w	r11,20
8000e3d2:	e0 8b 00 04 	brhi	8000e3da <_free_r+0x116>
8000e3d6:	2a 5b       	sub	r11,-91
8000e3d8:	c1 b8       	rjmp	8000e40e <_free_r+0x14a>
8000e3da:	e0 4b 00 54 	cp.w	r11,84
8000e3de:	e0 8b 00 06 	brhi	8000e3ea <_free_r+0x126>
8000e3e2:	f0 0b 16 0c 	lsr	r11,r8,0xc
8000e3e6:	29 2b       	sub	r11,-110
8000e3e8:	c1 38       	rjmp	8000e40e <_free_r+0x14a>
8000e3ea:	e0 4b 01 54 	cp.w	r11,340
8000e3ee:	e0 8b 00 06 	brhi	8000e3fa <_free_r+0x136>
8000e3f2:	f0 0b 16 0f 	lsr	r11,r8,0xf
8000e3f6:	28 9b       	sub	r11,-119
8000e3f8:	c0 b8       	rjmp	8000e40e <_free_r+0x14a>
8000e3fa:	e0 4b 05 54 	cp.w	r11,1364
8000e3fe:	e0 88 00 05 	brls	8000e408 <_free_r+0x144>
8000e402:	37 eb       	mov	r11,126
8000e404:	c0 58       	rjmp	8000e40e <_free_r+0x14a>
8000e406:	d7 03       	nop
8000e408:	f0 0b 16 12 	lsr	r11,r8,0x12
8000e40c:	28 4b       	sub	r11,-124
8000e40e:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
8000e412:	78 29       	ld.w	r9,r12[0x8]
8000e414:	18 39       	cp.w	r9,r12
8000e416:	c0 e1       	brne	8000e432 <_free_r+0x16e>
8000e418:	74 18       	ld.w	r8,r10[0x4]
8000e41a:	a3 4b       	asr	r11,0x2
8000e41c:	30 1c       	mov	r12,1
8000e41e:	f8 0b 09 4b 	lsl	r11,r12,r11
8000e422:	f1 eb 10 0b 	or	r11,r8,r11
8000e426:	12 98       	mov	r8,r9
8000e428:	95 1b       	st.w	r10[0x4],r11
8000e42a:	c0 a8       	rjmp	8000e43e <_free_r+0x17a>
8000e42c:	72 29       	ld.w	r9,r9[0x8]
8000e42e:	18 39       	cp.w	r9,r12
8000e430:	c0 60       	breq	8000e43c <_free_r+0x178>
8000e432:	72 1a       	ld.w	r10,r9[0x4]
8000e434:	e0 1a ff fc 	andl	r10,0xfffc
8000e438:	14 38       	cp.w	r8,r10
8000e43a:	cf 93       	brcs	8000e42c <_free_r+0x168>
8000e43c:	72 38       	ld.w	r8,r9[0xc]
8000e43e:	8d 38       	st.w	r6[0xc],r8
8000e440:	8d 29       	st.w	r6[0x8],r9
8000e442:	93 36       	st.w	r9[0xc],r6
8000e444:	91 26       	st.w	r8[0x8],r6
8000e446:	0e 9c       	mov	r12,r7
8000e448:	fe b0 d5 82 	rcall	80008f4c <__malloc_unlock>
8000e44c:	d8 22       	popm	r4-r7,pc
8000e44e:	d7 03       	nop

8000e450 <__sfvwrite_r>:
8000e450:	d4 31       	pushm	r0-r7,lr
8000e452:	20 3d       	sub	sp,12
8000e454:	14 94       	mov	r4,r10
8000e456:	18 95       	mov	r5,r12
8000e458:	16 97       	mov	r7,r11
8000e45a:	74 28       	ld.w	r8,r10[0x8]
8000e45c:	58 08       	cp.w	r8,0
8000e45e:	e0 80 01 40 	breq	8000e6de <__sfvwrite_r+0x28e>
8000e462:	96 68       	ld.sh	r8,r11[0xc]
8000e464:	ed b8 00 03 	bld	r8,0x3
8000e468:	c0 41       	brne	8000e470 <__sfvwrite_r+0x20>
8000e46a:	76 48       	ld.w	r8,r11[0x10]
8000e46c:	58 08       	cp.w	r8,0
8000e46e:	c0 c1       	brne	8000e486 <__sfvwrite_r+0x36>
8000e470:	0e 9b       	mov	r11,r7
8000e472:	0a 9c       	mov	r12,r5
8000e474:	fe b0 f6 bc 	rcall	8000d1ec <__swsetup_r>
8000e478:	c0 70       	breq	8000e486 <__sfvwrite_r+0x36>
8000e47a:	8e 68       	ld.sh	r8,r7[0xc]
8000e47c:	a7 a8       	sbr	r8,0x6
8000e47e:	ae 68       	st.h	r7[0xc],r8
8000e480:	30 98       	mov	r8,9
8000e482:	8b 38       	st.w	r5[0xc],r8
8000e484:	c2 b9       	rjmp	8000e6da <__sfvwrite_r+0x28a>
8000e486:	8e 63       	ld.sh	r3,r7[0xc]
8000e488:	68 00       	ld.w	r0,r4[0x0]
8000e48a:	06 96       	mov	r6,r3
8000e48c:	e2 16 00 02 	andl	r6,0x2,COH
8000e490:	c2 10       	breq	8000e4d2 <__sfvwrite_r+0x82>
8000e492:	30 03       	mov	r3,0
8000e494:	e0 62 04 00 	mov	r2,1024
8000e498:	06 96       	mov	r6,r3
8000e49a:	c0 48       	rjmp	8000e4a2 <__sfvwrite_r+0x52>
8000e49c:	60 03       	ld.w	r3,r0[0x0]
8000e49e:	60 16       	ld.w	r6,r0[0x4]
8000e4a0:	2f 80       	sub	r0,-8
8000e4a2:	58 06       	cp.w	r6,0
8000e4a4:	cf c0       	breq	8000e49c <__sfvwrite_r+0x4c>
8000e4a6:	e0 46 04 00 	cp.w	r6,1024
8000e4aa:	ec 09 17 80 	movls	r9,r6
8000e4ae:	e4 09 17 b0 	movhi	r9,r2
8000e4b2:	06 9a       	mov	r10,r3
8000e4b4:	6e a8       	ld.w	r8,r7[0x28]
8000e4b6:	6e 8b       	ld.w	r11,r7[0x20]
8000e4b8:	0a 9c       	mov	r12,r5
8000e4ba:	5d 18       	icall	r8
8000e4bc:	18 16       	sub	r6,r12
8000e4be:	58 0c       	cp.w	r12,0
8000e4c0:	e0 8a 01 0a 	brle	8000e6d4 <__sfvwrite_r+0x284>
8000e4c4:	68 28       	ld.w	r8,r4[0x8]
8000e4c6:	18 18       	sub	r8,r12
8000e4c8:	89 28       	st.w	r4[0x8],r8
8000e4ca:	e0 80 01 0a 	breq	8000e6de <__sfvwrite_r+0x28e>
8000e4ce:	18 03       	add	r3,r12
8000e4d0:	ce 9b       	rjmp	8000e4a2 <__sfvwrite_r+0x52>
8000e4d2:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
8000e4d6:	c0 70       	breq	8000e4e4 <__sfvwrite_r+0x94>
8000e4d8:	50 06       	stdsp	sp[0x0],r6
8000e4da:	0c 93       	mov	r3,r6
8000e4dc:	0c 91       	mov	r1,r6
8000e4de:	50 15       	stdsp	sp[0x4],r5
8000e4e0:	08 92       	mov	r2,r4
8000e4e2:	c9 c8       	rjmp	8000e61a <__sfvwrite_r+0x1ca>
8000e4e4:	06 96       	mov	r6,r3
8000e4e6:	08 91       	mov	r1,r4
8000e4e8:	c0 48       	rjmp	8000e4f0 <__sfvwrite_r+0xa0>
8000e4ea:	60 03       	ld.w	r3,r0[0x0]
8000e4ec:	60 16       	ld.w	r6,r0[0x4]
8000e4ee:	2f 80       	sub	r0,-8
8000e4f0:	58 06       	cp.w	r6,0
8000e4f2:	cf c0       	breq	8000e4ea <__sfvwrite_r+0x9a>
8000e4f4:	8e 68       	ld.sh	r8,r7[0xc]
8000e4f6:	6e 24       	ld.w	r4,r7[0x8]
8000e4f8:	10 99       	mov	r9,r8
8000e4fa:	e2 19 02 00 	andl	r9,0x200,COH
8000e4fe:	c5 50       	breq	8000e5a8 <__sfvwrite_r+0x158>
8000e500:	08 36       	cp.w	r6,r4
8000e502:	c4 43       	brcs	8000e58a <__sfvwrite_r+0x13a>
8000e504:	10 99       	mov	r9,r8
8000e506:	e2 19 04 80 	andl	r9,0x480,COH
8000e50a:	c4 00       	breq	8000e58a <__sfvwrite_r+0x13a>
8000e50c:	6e 4b       	ld.w	r11,r7[0x10]
8000e50e:	6e 09       	ld.w	r9,r7[0x0]
8000e510:	16 19       	sub	r9,r11
8000e512:	50 09       	stdsp	sp[0x0],r9
8000e514:	6e 59       	ld.w	r9,r7[0x14]
8000e516:	10 9c       	mov	r12,r8
8000e518:	f2 09 00 1a 	add	r10,r9,r9<<0x1
8000e51c:	30 28       	mov	r8,2
8000e51e:	f4 08 0c 08 	divs	r8,r10,r8
8000e522:	fa e9 00 04 	st.d	sp[4],r8
8000e526:	10 94       	mov	r4,r8
8000e528:	40 09       	lddsp	r9,sp[0x0]
8000e52a:	e2 1c 04 00 	andl	r12,0x400,COH
8000e52e:	2f f9       	sub	r9,-1
8000e530:	0c 09       	add	r9,r6
8000e532:	12 38       	cp.w	r8,r9
8000e534:	f2 04 17 30 	movlo	r4,r9
8000e538:	58 0c       	cp.w	r12,0
8000e53a:	c1 10       	breq	8000e55c <__sfvwrite_r+0x10c>
8000e53c:	08 9b       	mov	r11,r4
8000e53e:	0a 9c       	mov	r12,r5
8000e540:	fe b0 df b4 	rcall	8000a4a8 <_malloc_r>
8000e544:	18 92       	mov	r2,r12
8000e546:	c1 40       	breq	8000e56e <__sfvwrite_r+0x11e>
8000e548:	40 0a       	lddsp	r10,sp[0x0]
8000e54a:	6e 4b       	ld.w	r11,r7[0x10]
8000e54c:	fe b0 e1 dd 	rcall	8000a906 <memcpy>
8000e550:	8e 68       	ld.sh	r8,r7[0xc]
8000e552:	e0 18 fb 7f 	andl	r8,0xfb7f
8000e556:	a7 b8       	sbr	r8,0x7
8000e558:	ae 68       	st.h	r7[0xc],r8
8000e55a:	c0 d8       	rjmp	8000e574 <__sfvwrite_r+0x124>
8000e55c:	08 9a       	mov	r10,r4
8000e55e:	0a 9c       	mov	r12,r5
8000e560:	fe b0 e2 7e 	rcall	8000aa5c <_realloc_r>
8000e564:	18 92       	mov	r2,r12
8000e566:	c0 71       	brne	8000e574 <__sfvwrite_r+0x124>
8000e568:	6e 4b       	ld.w	r11,r7[0x10]
8000e56a:	0a 9c       	mov	r12,r5
8000e56c:	ca ce       	rcall	8000e2c4 <_free_r>
8000e56e:	30 c8       	mov	r8,12
8000e570:	8b 38       	st.w	r5[0xc],r8
8000e572:	cb 18       	rjmp	8000e6d4 <__sfvwrite_r+0x284>
8000e574:	40 0a       	lddsp	r10,sp[0x0]
8000e576:	40 09       	lddsp	r9,sp[0x0]
8000e578:	e8 0a 01 0a 	sub	r10,r4,r10
8000e57c:	e4 09 00 08 	add	r8,r2,r9
8000e580:	8f 54       	st.w	r7[0x14],r4
8000e582:	8f 2a       	st.w	r7[0x8],r10
8000e584:	8f 08       	st.w	r7[0x0],r8
8000e586:	8f 42       	st.w	r7[0x10],r2
8000e588:	0c 94       	mov	r4,r6
8000e58a:	08 36       	cp.w	r6,r4
8000e58c:	ec 04 17 30 	movlo	r4,r6
8000e590:	06 9b       	mov	r11,r3
8000e592:	08 9a       	mov	r10,r4
8000e594:	6e 0c       	ld.w	r12,r7[0x0]
8000e596:	c3 ad       	rcall	8000e80a <memmove>
8000e598:	6e 08       	ld.w	r8,r7[0x0]
8000e59a:	08 08       	add	r8,r4
8000e59c:	8f 08       	st.w	r7[0x0],r8
8000e59e:	6e 28       	ld.w	r8,r7[0x8]
8000e5a0:	08 18       	sub	r8,r4
8000e5a2:	0c 94       	mov	r4,r6
8000e5a4:	8f 28       	st.w	r7[0x8],r8
8000e5a6:	c2 e8       	rjmp	8000e602 <__sfvwrite_r+0x1b2>
8000e5a8:	08 36       	cp.w	r6,r4
8000e5aa:	5f ba       	srhi	r10
8000e5ac:	6e 0c       	ld.w	r12,r7[0x0]
8000e5ae:	6e 48       	ld.w	r8,r7[0x10]
8000e5b0:	10 3c       	cp.w	r12,r8
8000e5b2:	5f b8       	srhi	r8
8000e5b4:	f5 e8 00 08 	and	r8,r10,r8
8000e5b8:	f2 08 18 00 	cp.b	r8,r9
8000e5bc:	c0 d0       	breq	8000e5d6 <__sfvwrite_r+0x186>
8000e5be:	06 9b       	mov	r11,r3
8000e5c0:	08 9a       	mov	r10,r4
8000e5c2:	c2 4d       	rcall	8000e80a <memmove>
8000e5c4:	6e 08       	ld.w	r8,r7[0x0]
8000e5c6:	08 08       	add	r8,r4
8000e5c8:	0e 9b       	mov	r11,r7
8000e5ca:	8f 08       	st.w	r7[0x0],r8
8000e5cc:	0a 9c       	mov	r12,r5
8000e5ce:	fe b0 fd 05 	rcall	8000dfd8 <_fflush_r>
8000e5d2:	c1 80       	breq	8000e602 <__sfvwrite_r+0x1b2>
8000e5d4:	c8 08       	rjmp	8000e6d4 <__sfvwrite_r+0x284>
8000e5d6:	6e 59       	ld.w	r9,r7[0x14]
8000e5d8:	12 36       	cp.w	r6,r9
8000e5da:	c0 a3       	brcs	8000e5ee <__sfvwrite_r+0x19e>
8000e5dc:	6e a8       	ld.w	r8,r7[0x28]
8000e5de:	06 9a       	mov	r10,r3
8000e5e0:	6e 8b       	ld.w	r11,r7[0x20]
8000e5e2:	0a 9c       	mov	r12,r5
8000e5e4:	5d 18       	icall	r8
8000e5e6:	18 94       	mov	r4,r12
8000e5e8:	e0 89 00 0d 	brgt	8000e602 <__sfvwrite_r+0x1b2>
8000e5ec:	c7 48       	rjmp	8000e6d4 <__sfvwrite_r+0x284>
8000e5ee:	0c 9a       	mov	r10,r6
8000e5f0:	06 9b       	mov	r11,r3
8000e5f2:	c0 cd       	rcall	8000e80a <memmove>
8000e5f4:	6e 08       	ld.w	r8,r7[0x0]
8000e5f6:	0c 08       	add	r8,r6
8000e5f8:	0c 94       	mov	r4,r6
8000e5fa:	8f 08       	st.w	r7[0x0],r8
8000e5fc:	6e 28       	ld.w	r8,r7[0x8]
8000e5fe:	0c 18       	sub	r8,r6
8000e600:	8f 28       	st.w	r7[0x8],r8
8000e602:	62 28       	ld.w	r8,r1[0x8]
8000e604:	08 18       	sub	r8,r4
8000e606:	83 28       	st.w	r1[0x8],r8
8000e608:	c6 b0       	breq	8000e6de <__sfvwrite_r+0x28e>
8000e60a:	08 16       	sub	r6,r4
8000e60c:	08 03       	add	r3,r4
8000e60e:	c7 1b       	rjmp	8000e4f0 <__sfvwrite_r+0xa0>
8000e610:	60 03       	ld.w	r3,r0[0x0]
8000e612:	60 11       	ld.w	r1,r0[0x4]
8000e614:	30 08       	mov	r8,0
8000e616:	2f 80       	sub	r0,-8
8000e618:	50 08       	stdsp	sp[0x0],r8
8000e61a:	58 01       	cp.w	r1,0
8000e61c:	cf a0       	breq	8000e610 <__sfvwrite_r+0x1c0>
8000e61e:	40 0a       	lddsp	r10,sp[0x0]
8000e620:	58 0a       	cp.w	r10,0
8000e622:	c1 41       	brne	8000e64a <__sfvwrite_r+0x1fa>
8000e624:	e2 c6 ff ff 	sub	r6,r1,-1
8000e628:	02 9a       	mov	r10,r1
8000e62a:	30 ab       	mov	r11,10
8000e62c:	06 9c       	mov	r12,r3
8000e62e:	ce 3c       	rcall	8000e7f4 <memchr>
8000e630:	f8 c8 ff ff 	sub	r8,r12,-1
8000e634:	58 0c       	cp.w	r12,0
8000e636:	f1 d3 e1 16 	subne	r6,r8,r3
8000e63a:	f9 b9 01 01 	movne	r9,1
8000e63e:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000e642:	f9 b8 00 01 	moveq	r8,1
8000e646:	fb f8 0a 00 	st.weq	sp[0x0],r8
8000e64a:	02 36       	cp.w	r6,r1
8000e64c:	ec 04 17 80 	movls	r4,r6
8000e650:	e2 04 17 b0 	movhi	r4,r1
8000e654:	6e 59       	ld.w	r9,r7[0x14]
8000e656:	6e 25       	ld.w	r5,r7[0x8]
8000e658:	f2 05 00 05 	add	r5,r9,r5
8000e65c:	0a 34       	cp.w	r4,r5
8000e65e:	5f 9a       	srgt	r10
8000e660:	6e 0c       	ld.w	r12,r7[0x0]
8000e662:	6e 48       	ld.w	r8,r7[0x10]
8000e664:	10 3c       	cp.w	r12,r8
8000e666:	5f b8       	srhi	r8
8000e668:	f5 e8 00 08 	and	r8,r10,r8
8000e66c:	30 0a       	mov	r10,0
8000e66e:	f4 08 18 00 	cp.b	r8,r10
8000e672:	c0 d0       	breq	8000e68c <__sfvwrite_r+0x23c>
8000e674:	06 9b       	mov	r11,r3
8000e676:	0a 9a       	mov	r10,r5
8000e678:	cc 9c       	rcall	8000e80a <memmove>
8000e67a:	6e 08       	ld.w	r8,r7[0x0]
8000e67c:	0a 08       	add	r8,r5
8000e67e:	0e 9b       	mov	r11,r7
8000e680:	8f 08       	st.w	r7[0x0],r8
8000e682:	40 1c       	lddsp	r12,sp[0x4]
8000e684:	fe b0 fc aa 	rcall	8000dfd8 <_fflush_r>
8000e688:	c1 70       	breq	8000e6b6 <__sfvwrite_r+0x266>
8000e68a:	c2 58       	rjmp	8000e6d4 <__sfvwrite_r+0x284>
8000e68c:	12 34       	cp.w	r4,r9
8000e68e:	c0 a5       	brlt	8000e6a2 <__sfvwrite_r+0x252>
8000e690:	6e a8       	ld.w	r8,r7[0x28]
8000e692:	06 9a       	mov	r10,r3
8000e694:	6e 8b       	ld.w	r11,r7[0x20]
8000e696:	40 1c       	lddsp	r12,sp[0x4]
8000e698:	5d 18       	icall	r8
8000e69a:	18 95       	mov	r5,r12
8000e69c:	e0 89 00 0d 	brgt	8000e6b6 <__sfvwrite_r+0x266>
8000e6a0:	c1 a8       	rjmp	8000e6d4 <__sfvwrite_r+0x284>
8000e6a2:	08 9a       	mov	r10,r4
8000e6a4:	06 9b       	mov	r11,r3
8000e6a6:	cb 2c       	rcall	8000e80a <memmove>
8000e6a8:	6e 08       	ld.w	r8,r7[0x0]
8000e6aa:	08 08       	add	r8,r4
8000e6ac:	08 95       	mov	r5,r4
8000e6ae:	8f 08       	st.w	r7[0x0],r8
8000e6b0:	6e 28       	ld.w	r8,r7[0x8]
8000e6b2:	08 18       	sub	r8,r4
8000e6b4:	8f 28       	st.w	r7[0x8],r8
8000e6b6:	0a 16       	sub	r6,r5
8000e6b8:	c0 71       	brne	8000e6c6 <__sfvwrite_r+0x276>
8000e6ba:	0e 9b       	mov	r11,r7
8000e6bc:	40 1c       	lddsp	r12,sp[0x4]
8000e6be:	fe b0 fc 8d 	rcall	8000dfd8 <_fflush_r>
8000e6c2:	c0 91       	brne	8000e6d4 <__sfvwrite_r+0x284>
8000e6c4:	50 06       	stdsp	sp[0x0],r6
8000e6c6:	64 28       	ld.w	r8,r2[0x8]
8000e6c8:	0a 18       	sub	r8,r5
8000e6ca:	85 28       	st.w	r2[0x8],r8
8000e6cc:	c0 90       	breq	8000e6de <__sfvwrite_r+0x28e>
8000e6ce:	0a 11       	sub	r1,r5
8000e6d0:	0a 03       	add	r3,r5
8000e6d2:	ca 4b       	rjmp	8000e61a <__sfvwrite_r+0x1ca>
8000e6d4:	8e 68       	ld.sh	r8,r7[0xc]
8000e6d6:	a7 a8       	sbr	r8,0x6
8000e6d8:	ae 68       	st.h	r7[0xc],r8
8000e6da:	3f fc       	mov	r12,-1
8000e6dc:	c0 28       	rjmp	8000e6e0 <__sfvwrite_r+0x290>
8000e6de:	30 0c       	mov	r12,0
8000e6e0:	2f dd       	sub	sp,-12
8000e6e2:	d8 32       	popm	r0-r7,pc

8000e6e4 <_fwalk>:
8000e6e4:	d4 31       	pushm	r0-r7,lr
8000e6e6:	30 05       	mov	r5,0
8000e6e8:	16 91       	mov	r1,r11
8000e6ea:	f8 c7 ff 28 	sub	r7,r12,-216
8000e6ee:	0a 92       	mov	r2,r5
8000e6f0:	fe b0 fc fc 	rcall	8000e0e8 <__sfp_lock_acquire>
8000e6f4:	3f f3       	mov	r3,-1
8000e6f6:	c1 68       	rjmp	8000e722 <_fwalk+0x3e>
8000e6f8:	6e 26       	ld.w	r6,r7[0x8]
8000e6fa:	6e 14       	ld.w	r4,r7[0x4]
8000e6fc:	2f 46       	sub	r6,-12
8000e6fe:	c0 c8       	rjmp	8000e716 <_fwalk+0x32>
8000e700:	8c 08       	ld.sh	r8,r6[0x0]
8000e702:	e4 08 19 00 	cp.h	r8,r2
8000e706:	c0 70       	breq	8000e714 <_fwalk+0x30>
8000e708:	8c 18       	ld.sh	r8,r6[0x2]
8000e70a:	e6 08 19 00 	cp.h	r8,r3
8000e70e:	c0 30       	breq	8000e714 <_fwalk+0x30>
8000e710:	5d 11       	icall	r1
8000e712:	18 45       	or	r5,r12
8000e714:	2a 46       	sub	r6,-92
8000e716:	20 14       	sub	r4,1
8000e718:	ec cc 00 0c 	sub	r12,r6,12
8000e71c:	58 04       	cp.w	r4,0
8000e71e:	cf 14       	brge	8000e700 <_fwalk+0x1c>
8000e720:	6e 07       	ld.w	r7,r7[0x0]
8000e722:	58 07       	cp.w	r7,0
8000e724:	ce a1       	brne	8000e6f8 <_fwalk+0x14>
8000e726:	fe b0 fc e2 	rcall	8000e0ea <__sfp_lock_release>
8000e72a:	0a 9c       	mov	r12,r5
8000e72c:	d8 32       	popm	r0-r7,pc
8000e72e:	d7 03       	nop

8000e730 <_localeconv_r>:
8000e730:	48 1c       	lddpc	r12,8000e734 <_localeconv_r+0x4>
8000e732:	5e fc       	retal	r12
8000e734:	80 01       	ld.sh	r1,r0[0x0]
8000e736:	97 50       	st.w	r11[0x14],r0

8000e738 <__smakebuf_r>:
8000e738:	d4 21       	pushm	r4-r7,lr
8000e73a:	20 fd       	sub	sp,60
8000e73c:	96 68       	ld.sh	r8,r11[0xc]
8000e73e:	16 97       	mov	r7,r11
8000e740:	18 96       	mov	r6,r12
8000e742:	e2 18 00 02 	andl	r8,0x2,COH
8000e746:	c3 d1       	brne	8000e7c0 <__smakebuf_r+0x88>
8000e748:	96 7b       	ld.sh	r11,r11[0xe]
8000e74a:	f0 0b 19 00 	cp.h	r11,r8
8000e74e:	c0 55       	brlt	8000e758 <__smakebuf_r+0x20>
8000e750:	1a 9a       	mov	r10,sp
8000e752:	e0 a0 04 79 	rcall	8000f044 <_fstat_r>
8000e756:	c0 f4       	brge	8000e774 <__smakebuf_r+0x3c>
8000e758:	8e 65       	ld.sh	r5,r7[0xc]
8000e75a:	0a 98       	mov	r8,r5
8000e75c:	ab b8       	sbr	r8,0xb
8000e75e:	e2 15 00 80 	andl	r5,0x80,COH
8000e762:	ae 68       	st.h	r7[0xc],r8
8000e764:	30 04       	mov	r4,0
8000e766:	e0 68 04 00 	mov	r8,1024
8000e76a:	f9 b5 01 40 	movne	r5,64
8000e76e:	f0 05 17 00 	moveq	r5,r8
8000e772:	c1 c8       	rjmp	8000e7aa <__smakebuf_r+0x72>
8000e774:	40 18       	lddsp	r8,sp[0x4]
8000e776:	e2 18 f0 00 	andl	r8,0xf000,COH
8000e77a:	e0 48 20 00 	cp.w	r8,8192
8000e77e:	5f 04       	sreq	r4
8000e780:	e0 48 80 00 	cp.w	r8,32768
8000e784:	c0 e1       	brne	8000e7a0 <__smakebuf_r+0x68>
8000e786:	6e b9       	ld.w	r9,r7[0x2c]
8000e788:	fe c8 f9 18 	sub	r8,pc,-1768
8000e78c:	10 39       	cp.w	r9,r8
8000e78e:	c0 91       	brne	8000e7a0 <__smakebuf_r+0x68>
8000e790:	8e 68       	ld.sh	r8,r7[0xc]
8000e792:	e0 65 04 00 	mov	r5,1024
8000e796:	ab a8       	sbr	r8,0xa
8000e798:	ef 45 00 50 	st.w	r7[80],r5
8000e79c:	ae 68       	st.h	r7[0xc],r8
8000e79e:	c0 68       	rjmp	8000e7aa <__smakebuf_r+0x72>
8000e7a0:	8e 68       	ld.sh	r8,r7[0xc]
8000e7a2:	e0 65 04 00 	mov	r5,1024
8000e7a6:	ab b8       	sbr	r8,0xb
8000e7a8:	ae 68       	st.h	r7[0xc],r8
8000e7aa:	0a 9b       	mov	r11,r5
8000e7ac:	0c 9c       	mov	r12,r6
8000e7ae:	fe b0 de 7d 	rcall	8000a4a8 <_malloc_r>
8000e7b2:	8e 68       	ld.sh	r8,r7[0xc]
8000e7b4:	c0 d1       	brne	8000e7ce <__smakebuf_r+0x96>
8000e7b6:	ed b8 00 09 	bld	r8,0x9
8000e7ba:	c1 b0       	breq	8000e7f0 <__smakebuf_r+0xb8>
8000e7bc:	a1 b8       	sbr	r8,0x1
8000e7be:	ae 68       	st.h	r7[0xc],r8
8000e7c0:	ee c8 ff b9 	sub	r8,r7,-71
8000e7c4:	8f 48       	st.w	r7[0x10],r8
8000e7c6:	8f 08       	st.w	r7[0x0],r8
8000e7c8:	30 18       	mov	r8,1
8000e7ca:	8f 58       	st.w	r7[0x14],r8
8000e7cc:	c1 28       	rjmp	8000e7f0 <__smakebuf_r+0xb8>
8000e7ce:	a7 b8       	sbr	r8,0x7
8000e7d0:	8f 4c       	st.w	r7[0x10],r12
8000e7d2:	ae 68       	st.h	r7[0xc],r8
8000e7d4:	8f 55       	st.w	r7[0x14],r5
8000e7d6:	fe c8 06 ea 	sub	r8,pc,1770
8000e7da:	8f 0c       	st.w	r7[0x0],r12
8000e7dc:	8d a8       	st.w	r6[0x28],r8
8000e7de:	58 04       	cp.w	r4,0
8000e7e0:	c0 80       	breq	8000e7f0 <__smakebuf_r+0xb8>
8000e7e2:	8e 7c       	ld.sh	r12,r7[0xe]
8000e7e4:	fe b0 e3 7a 	rcall	8000aed8 <isatty>
8000e7e8:	c0 40       	breq	8000e7f0 <__smakebuf_r+0xb8>
8000e7ea:	8e 68       	ld.sh	r8,r7[0xc]
8000e7ec:	a1 a8       	sbr	r8,0x0
8000e7ee:	ae 68       	st.h	r7[0xc],r8
8000e7f0:	2f 1d       	sub	sp,-60
8000e7f2:	d8 22       	popm	r4-r7,pc

8000e7f4 <memchr>:
8000e7f4:	f7 db c0 08 	bfextu	r11,r11,0x0,0x8
8000e7f8:	c0 68       	rjmp	8000e804 <memchr+0x10>
8000e7fa:	20 1a       	sub	r10,1
8000e7fc:	19 88       	ld.ub	r8,r12[0x0]
8000e7fe:	16 38       	cp.w	r8,r11
8000e800:	5e 0c       	reteq	r12
8000e802:	2f fc       	sub	r12,-1
8000e804:	58 0a       	cp.w	r10,0
8000e806:	cf a1       	brne	8000e7fa <memchr+0x6>
8000e808:	5e fa       	retal	r10

8000e80a <memmove>:
8000e80a:	d4 01       	pushm	lr
8000e80c:	18 3b       	cp.w	r11,r12
8000e80e:	c1 92       	brcc	8000e840 <memmove+0x36>
8000e810:	f6 0a 00 09 	add	r9,r11,r10
8000e814:	12 3c       	cp.w	r12,r9
8000e816:	c1 52       	brcc	8000e840 <memmove+0x36>
8000e818:	f8 0a 00 0b 	add	r11,r12,r10
8000e81c:	30 08       	mov	r8,0
8000e81e:	c0 68       	rjmp	8000e82a <memmove+0x20>
8000e820:	f2 08 07 0e 	ld.ub	lr,r9[r8]
8000e824:	20 1a       	sub	r10,1
8000e826:	f6 08 0b 0e 	st.b	r11[r8],lr
8000e82a:	20 18       	sub	r8,1
8000e82c:	58 0a       	cp.w	r10,0
8000e82e:	cf 91       	brne	8000e820 <memmove+0x16>
8000e830:	d8 02       	popm	pc
8000e832:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000e836:	20 1a       	sub	r10,1
8000e838:	f8 08 0b 09 	st.b	r12[r8],r9
8000e83c:	2f f8       	sub	r8,-1
8000e83e:	c0 28       	rjmp	8000e842 <memmove+0x38>
8000e840:	30 08       	mov	r8,0
8000e842:	58 0a       	cp.w	r10,0
8000e844:	cf 71       	brne	8000e832 <memmove+0x28>
8000e846:	d8 02       	popm	pc

8000e848 <__hi0bits>:
8000e848:	18 98       	mov	r8,r12
8000e84a:	e0 1c 00 00 	andl	r12,0x0
8000e84e:	f0 09 15 10 	lsl	r9,r8,0x10
8000e852:	58 0c       	cp.w	r12,0
8000e854:	f2 08 17 00 	moveq	r8,r9
8000e858:	f9 bc 00 10 	moveq	r12,16
8000e85c:	f9 bc 01 00 	movne	r12,0
8000e860:	10 9a       	mov	r10,r8
8000e862:	f0 09 15 08 	lsl	r9,r8,0x8
8000e866:	e6 1a ff 00 	andh	r10,0xff00,COH
8000e86a:	f7 bc 00 f8 	subeq	r12,-8
8000e86e:	f2 08 17 00 	moveq	r8,r9
8000e872:	10 9a       	mov	r10,r8
8000e874:	f0 09 15 04 	lsl	r9,r8,0x4
8000e878:	e6 1a f0 00 	andh	r10,0xf000,COH
8000e87c:	f7 bc 00 fc 	subeq	r12,-4
8000e880:	f2 08 17 00 	moveq	r8,r9
8000e884:	10 9a       	mov	r10,r8
8000e886:	f0 09 15 02 	lsl	r9,r8,0x2
8000e88a:	e6 1a c0 00 	andh	r10,0xc000,COH
8000e88e:	f7 bc 00 fe 	subeq	r12,-2
8000e892:	f2 08 17 00 	moveq	r8,r9
8000e896:	58 08       	cp.w	r8,0
8000e898:	5e 5c       	retlt	r12
8000e89a:	ed b8 00 1e 	bld	r8,0x1e
8000e89e:	f9 bc 01 20 	movne	r12,32
8000e8a2:	f7 bc 00 ff 	subeq	r12,-1
8000e8a6:	5e fc       	retal	r12

8000e8a8 <__lo0bits>:
8000e8a8:	18 99       	mov	r9,r12
8000e8aa:	78 08       	ld.w	r8,r12[0x0]
8000e8ac:	f9 d8 c0 03 	bfextu	r12,r8,0x0,0x3
8000e8b0:	c1 50       	breq	8000e8da <__lo0bits+0x32>
8000e8b2:	ed b8 00 00 	bld	r8,0x0
8000e8b6:	c0 21       	brne	8000e8ba <__lo0bits+0x12>
8000e8b8:	5e fd       	retal	0
8000e8ba:	10 9b       	mov	r11,r8
8000e8bc:	f0 0a 16 01 	lsr	r10,r8,0x1
8000e8c0:	e2 1b 00 02 	andl	r11,0x2,COH
8000e8c4:	a3 88       	lsr	r8,0x2
8000e8c6:	58 0b       	cp.w	r11,0
8000e8c8:	f3 fa 1a 00 	st.wne	r9[0x0],r10
8000e8cc:	f9 bc 01 01 	movne	r12,1
8000e8d0:	f3 f8 0a 00 	st.weq	r9[0x0],r8
8000e8d4:	f9 bc 00 02 	moveq	r12,2
8000e8d8:	5e fc       	retal	r12
8000e8da:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8000e8de:	f0 0b 16 10 	lsr	r11,r8,0x10
8000e8e2:	58 0a       	cp.w	r10,0
8000e8e4:	f6 08 17 00 	moveq	r8,r11
8000e8e8:	f9 bc 00 10 	moveq	r12,16
8000e8ec:	f7 d8 c0 08 	bfextu	r11,r8,0x0,0x8
8000e8f0:	f0 0a 16 08 	lsr	r10,r8,0x8
8000e8f4:	58 0b       	cp.w	r11,0
8000e8f6:	f7 bc 00 f8 	subeq	r12,-8
8000e8fa:	f4 08 17 00 	moveq	r8,r10
8000e8fe:	f7 d8 c0 04 	bfextu	r11,r8,0x0,0x4
8000e902:	f0 0a 16 04 	lsr	r10,r8,0x4
8000e906:	58 0b       	cp.w	r11,0
8000e908:	f7 bc 00 fc 	subeq	r12,-4
8000e90c:	f4 08 17 00 	moveq	r8,r10
8000e910:	f7 d8 c0 02 	bfextu	r11,r8,0x0,0x2
8000e914:	f0 0a 16 02 	lsr	r10,r8,0x2
8000e918:	58 0b       	cp.w	r11,0
8000e91a:	f7 bc 00 fe 	subeq	r12,-2
8000e91e:	f4 08 17 00 	moveq	r8,r10
8000e922:	ed b8 00 00 	bld	r8,0x0
8000e926:	c0 60       	breq	8000e932 <__lo0bits+0x8a>
8000e928:	a1 98       	lsr	r8,0x1
8000e92a:	c0 31       	brne	8000e930 <__lo0bits+0x88>
8000e92c:	32 0c       	mov	r12,32
8000e92e:	5e fc       	retal	r12
8000e930:	2f fc       	sub	r12,-1
8000e932:	93 08       	st.w	r9[0x0],r8
8000e934:	5e fc       	retal	r12

8000e936 <__mcmp>:
8000e936:	d4 01       	pushm	lr
8000e938:	18 98       	mov	r8,r12
8000e93a:	76 49       	ld.w	r9,r11[0x10]
8000e93c:	78 4c       	ld.w	r12,r12[0x10]
8000e93e:	12 1c       	sub	r12,r9
8000e940:	c1 31       	brne	8000e966 <__mcmp+0x30>
8000e942:	2f b9       	sub	r9,-5
8000e944:	a3 69       	lsl	r9,0x2
8000e946:	12 0b       	add	r11,r9
8000e948:	f0 09 00 09 	add	r9,r8,r9
8000e94c:	2e c8       	sub	r8,-20
8000e94e:	13 4e       	ld.w	lr,--r9
8000e950:	17 4a       	ld.w	r10,--r11
8000e952:	14 3e       	cp.w	lr,r10
8000e954:	c0 60       	breq	8000e960 <__mcmp+0x2a>
8000e956:	f9 bc 03 ff 	movlo	r12,-1
8000e95a:	f9 bc 02 01 	movhs	r12,1
8000e95e:	d8 02       	popm	pc
8000e960:	10 39       	cp.w	r9,r8
8000e962:	fe 9b ff f6 	brhi	8000e94e <__mcmp+0x18>
8000e966:	d8 02       	popm	pc

8000e968 <_Bfree>:
8000e968:	d4 21       	pushm	r4-r7,lr
8000e96a:	18 97       	mov	r7,r12
8000e96c:	16 95       	mov	r5,r11
8000e96e:	78 96       	ld.w	r6,r12[0x24]
8000e970:	58 06       	cp.w	r6,0
8000e972:	c0 91       	brne	8000e984 <_Bfree+0x1c>
8000e974:	31 0c       	mov	r12,16
8000e976:	fe b0 dd 91 	rcall	8000a498 <malloc>
8000e97a:	99 36       	st.w	r12[0xc],r6
8000e97c:	8f 9c       	st.w	r7[0x24],r12
8000e97e:	99 16       	st.w	r12[0x4],r6
8000e980:	99 26       	st.w	r12[0x8],r6
8000e982:	99 06       	st.w	r12[0x0],r6
8000e984:	58 05       	cp.w	r5,0
8000e986:	c0 90       	breq	8000e998 <_Bfree+0x30>
8000e988:	6a 19       	ld.w	r9,r5[0x4]
8000e98a:	6e 98       	ld.w	r8,r7[0x24]
8000e98c:	70 38       	ld.w	r8,r8[0xc]
8000e98e:	f0 09 03 2a 	ld.w	r10,r8[r9<<0x2]
8000e992:	8b 0a       	st.w	r5[0x0],r10
8000e994:	f0 09 09 25 	st.w	r8[r9<<0x2],r5
8000e998:	d8 22       	popm	r4-r7,pc
8000e99a:	d7 03       	nop

8000e99c <_Balloc>:
8000e99c:	d4 21       	pushm	r4-r7,lr
8000e99e:	18 97       	mov	r7,r12
8000e9a0:	16 96       	mov	r6,r11
8000e9a2:	78 95       	ld.w	r5,r12[0x24]
8000e9a4:	58 05       	cp.w	r5,0
8000e9a6:	c0 91       	brne	8000e9b8 <_Balloc+0x1c>
8000e9a8:	31 0c       	mov	r12,16
8000e9aa:	fe b0 dd 77 	rcall	8000a498 <malloc>
8000e9ae:	99 35       	st.w	r12[0xc],r5
8000e9b0:	8f 9c       	st.w	r7[0x24],r12
8000e9b2:	99 15       	st.w	r12[0x4],r5
8000e9b4:	99 25       	st.w	r12[0x8],r5
8000e9b6:	99 05       	st.w	r12[0x0],r5
8000e9b8:	6e 95       	ld.w	r5,r7[0x24]
8000e9ba:	6a 38       	ld.w	r8,r5[0xc]
8000e9bc:	58 08       	cp.w	r8,0
8000e9be:	c0 b1       	brne	8000e9d4 <_Balloc+0x38>
8000e9c0:	31 0a       	mov	r10,16
8000e9c2:	30 4b       	mov	r11,4
8000e9c4:	0e 9c       	mov	r12,r7
8000e9c6:	e0 a0 02 9d 	rcall	8000ef00 <_calloc_r>
8000e9ca:	8b 3c       	st.w	r5[0xc],r12
8000e9cc:	6e 98       	ld.w	r8,r7[0x24]
8000e9ce:	70 3c       	ld.w	r12,r8[0xc]
8000e9d0:	58 0c       	cp.w	r12,0
8000e9d2:	c1 b0       	breq	8000ea08 <_Balloc+0x6c>
8000e9d4:	6e 98       	ld.w	r8,r7[0x24]
8000e9d6:	70 38       	ld.w	r8,r8[0xc]
8000e9d8:	f0 06 00 28 	add	r8,r8,r6<<0x2
8000e9dc:	70 0c       	ld.w	r12,r8[0x0]
8000e9de:	58 0c       	cp.w	r12,0
8000e9e0:	c0 40       	breq	8000e9e8 <_Balloc+0x4c>
8000e9e2:	78 09       	ld.w	r9,r12[0x0]
8000e9e4:	91 09       	st.w	r8[0x0],r9
8000e9e6:	c0 e8       	rjmp	8000ea02 <_Balloc+0x66>
8000e9e8:	0e 9c       	mov	r12,r7
8000e9ea:	30 17       	mov	r7,1
8000e9ec:	0e 9b       	mov	r11,r7
8000e9ee:	ee 06 09 47 	lsl	r7,r7,r6
8000e9f2:	ee ca ff fb 	sub	r10,r7,-5
8000e9f6:	a3 6a       	lsl	r10,0x2
8000e9f8:	e0 a0 02 84 	rcall	8000ef00 <_calloc_r>
8000e9fc:	c0 60       	breq	8000ea08 <_Balloc+0x6c>
8000e9fe:	99 16       	st.w	r12[0x4],r6
8000ea00:	99 27       	st.w	r12[0x8],r7
8000ea02:	30 08       	mov	r8,0
8000ea04:	99 38       	st.w	r12[0xc],r8
8000ea06:	99 48       	st.w	r12[0x10],r8
8000ea08:	d8 22       	popm	r4-r7,pc
8000ea0a:	d7 03       	nop

8000ea0c <__d2b>:
8000ea0c:	d4 31       	pushm	r0-r7,lr
8000ea0e:	20 2d       	sub	sp,8
8000ea10:	16 93       	mov	r3,r11
8000ea12:	12 96       	mov	r6,r9
8000ea14:	10 95       	mov	r5,r8
8000ea16:	14 92       	mov	r2,r10
8000ea18:	30 1b       	mov	r11,1
8000ea1a:	cc 1f       	rcall	8000e99c <_Balloc>
8000ea1c:	f3 d3 c0 14 	bfextu	r9,r3,0x0,0x14
8000ea20:	50 09       	stdsp	sp[0x0],r9
8000ea22:	f1 d3 c0 1f 	bfextu	r8,r3,0x0,0x1f
8000ea26:	b5 a9       	sbr	r9,0x14
8000ea28:	f0 01 16 14 	lsr	r1,r8,0x14
8000ea2c:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000ea30:	18 94       	mov	r4,r12
8000ea32:	58 02       	cp.w	r2,0
8000ea34:	c1 d0       	breq	8000ea6e <__d2b+0x62>
8000ea36:	fa cc ff f8 	sub	r12,sp,-8
8000ea3a:	18 d2       	st.w	--r12,r2
8000ea3c:	c3 6f       	rcall	8000e8a8 <__lo0bits>
8000ea3e:	40 18       	lddsp	r8,sp[0x4]
8000ea40:	c0 d0       	breq	8000ea5a <__d2b+0x4e>
8000ea42:	40 09       	lddsp	r9,sp[0x0]
8000ea44:	f8 0a 11 20 	rsub	r10,r12,32
8000ea48:	f2 0a 09 4a 	lsl	r10,r9,r10
8000ea4c:	f5 e8 10 08 	or	r8,r10,r8
8000ea50:	89 58       	st.w	r4[0x14],r8
8000ea52:	f2 0c 0a 49 	lsr	r9,r9,r12
8000ea56:	50 09       	stdsp	sp[0x0],r9
8000ea58:	c0 28       	rjmp	8000ea5c <__d2b+0x50>
8000ea5a:	89 58       	st.w	r4[0x14],r8
8000ea5c:	40 08       	lddsp	r8,sp[0x0]
8000ea5e:	58 08       	cp.w	r8,0
8000ea60:	f9 b3 01 02 	movne	r3,2
8000ea64:	f9 b3 00 01 	moveq	r3,1
8000ea68:	89 68       	st.w	r4[0x18],r8
8000ea6a:	89 43       	st.w	r4[0x10],r3
8000ea6c:	c0 88       	rjmp	8000ea7c <__d2b+0x70>
8000ea6e:	1a 9c       	mov	r12,sp
8000ea70:	c1 cf       	rcall	8000e8a8 <__lo0bits>
8000ea72:	30 13       	mov	r3,1
8000ea74:	40 08       	lddsp	r8,sp[0x0]
8000ea76:	2e 0c       	sub	r12,-32
8000ea78:	89 43       	st.w	r4[0x10],r3
8000ea7a:	89 58       	st.w	r4[0x14],r8
8000ea7c:	58 01       	cp.w	r1,0
8000ea7e:	c0 90       	breq	8000ea90 <__d2b+0x84>
8000ea80:	e2 c1 04 33 	sub	r1,r1,1075
8000ea84:	18 01       	add	r1,r12
8000ea86:	8d 01       	st.w	r6[0x0],r1
8000ea88:	f8 0c 11 35 	rsub	r12,r12,53
8000ea8c:	8b 0c       	st.w	r5[0x0],r12
8000ea8e:	c0 c8       	rjmp	8000eaa6 <__d2b+0x9a>
8000ea90:	e6 c8 ff fc 	sub	r8,r3,-4
8000ea94:	f8 cc 04 32 	sub	r12,r12,1074
8000ea98:	a5 73       	lsl	r3,0x5
8000ea9a:	8d 0c       	st.w	r6[0x0],r12
8000ea9c:	e8 08 03 2c 	ld.w	r12,r4[r8<<0x2]
8000eaa0:	cd 4e       	rcall	8000e848 <__hi0bits>
8000eaa2:	18 13       	sub	r3,r12
8000eaa4:	8b 03       	st.w	r5[0x0],r3
8000eaa6:	08 9c       	mov	r12,r4
8000eaa8:	2f ed       	sub	sp,-8
8000eaaa:	d8 32       	popm	r0-r7,pc

8000eaac <__mdiff>:
8000eaac:	d4 31       	pushm	r0-r7,lr
8000eaae:	74 48       	ld.w	r8,r10[0x10]
8000eab0:	76 45       	ld.w	r5,r11[0x10]
8000eab2:	16 97       	mov	r7,r11
8000eab4:	14 96       	mov	r6,r10
8000eab6:	10 15       	sub	r5,r8
8000eab8:	c1 31       	brne	8000eade <__mdiff+0x32>
8000eaba:	2f b8       	sub	r8,-5
8000eabc:	ee ce ff ec 	sub	lr,r7,-20
8000eac0:	a3 68       	lsl	r8,0x2
8000eac2:	f4 08 00 0b 	add	r11,r10,r8
8000eac6:	ee 08 00 08 	add	r8,r7,r8
8000eaca:	11 4a       	ld.w	r10,--r8
8000eacc:	17 49       	ld.w	r9,--r11
8000eace:	12 3a       	cp.w	r10,r9
8000ead0:	c0 30       	breq	8000ead6 <__mdiff+0x2a>
8000ead2:	c0 e2       	brcc	8000eaee <__mdiff+0x42>
8000ead4:	c0 78       	rjmp	8000eae2 <__mdiff+0x36>
8000ead6:	1c 38       	cp.w	r8,lr
8000ead8:	fe 9b ff f9 	brhi	8000eaca <__mdiff+0x1e>
8000eadc:	c4 98       	rjmp	8000eb6e <__mdiff+0xc2>
8000eade:	58 05       	cp.w	r5,0
8000eae0:	c0 64       	brge	8000eaec <__mdiff+0x40>
8000eae2:	0e 98       	mov	r8,r7
8000eae4:	30 15       	mov	r5,1
8000eae6:	0c 97       	mov	r7,r6
8000eae8:	10 96       	mov	r6,r8
8000eaea:	c0 28       	rjmp	8000eaee <__mdiff+0x42>
8000eaec:	30 05       	mov	r5,0
8000eaee:	6e 1b       	ld.w	r11,r7[0x4]
8000eaf0:	c5 6f       	rcall	8000e99c <_Balloc>
8000eaf2:	6e 49       	ld.w	r9,r7[0x10]
8000eaf4:	6c 44       	ld.w	r4,r6[0x10]
8000eaf6:	99 35       	st.w	r12[0xc],r5
8000eaf8:	2f b4       	sub	r4,-5
8000eafa:	f2 c5 ff fb 	sub	r5,r9,-5
8000eafe:	ec 04 00 24 	add	r4,r6,r4<<0x2
8000eb02:	ee 05 00 25 	add	r5,r7,r5<<0x2
8000eb06:	2e c6       	sub	r6,-20
8000eb08:	2e c7       	sub	r7,-20
8000eb0a:	f8 c8 ff ec 	sub	r8,r12,-20
8000eb0e:	30 0a       	mov	r10,0
8000eb10:	0f 0e       	ld.w	lr,r7++
8000eb12:	0d 0b       	ld.w	r11,r6++
8000eb14:	fc 02 16 10 	lsr	r2,lr,0x10
8000eb18:	f6 03 16 10 	lsr	r3,r11,0x10
8000eb1c:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000eb20:	e4 03 01 03 	sub	r3,r2,r3
8000eb24:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000eb28:	fc 0b 01 0b 	sub	r11,lr,r11
8000eb2c:	f6 0a 00 0a 	add	r10,r11,r10
8000eb30:	b0 1a       	st.h	r8[0x2],r10
8000eb32:	b1 4a       	asr	r10,0x10
8000eb34:	e6 0a 00 0a 	add	r10,r3,r10
8000eb38:	b0 0a       	st.h	r8[0x0],r10
8000eb3a:	2f c8       	sub	r8,-4
8000eb3c:	b1 4a       	asr	r10,0x10
8000eb3e:	08 36       	cp.w	r6,r4
8000eb40:	ce 83       	brcs	8000eb10 <__mdiff+0x64>
8000eb42:	c0 d8       	rjmp	8000eb5c <__mdiff+0xb0>
8000eb44:	0f 0b       	ld.w	r11,r7++
8000eb46:	f6 0e 16 10 	lsr	lr,r11,0x10
8000eb4a:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000eb4e:	16 0a       	add	r10,r11
8000eb50:	b0 1a       	st.h	r8[0x2],r10
8000eb52:	b1 4a       	asr	r10,0x10
8000eb54:	1c 0a       	add	r10,lr
8000eb56:	b0 0a       	st.h	r8[0x0],r10
8000eb58:	2f c8       	sub	r8,-4
8000eb5a:	b1 4a       	asr	r10,0x10
8000eb5c:	0a 37       	cp.w	r7,r5
8000eb5e:	cf 33       	brcs	8000eb44 <__mdiff+0x98>
8000eb60:	c0 28       	rjmp	8000eb64 <__mdiff+0xb8>
8000eb62:	20 19       	sub	r9,1
8000eb64:	11 4a       	ld.w	r10,--r8
8000eb66:	58 0a       	cp.w	r10,0
8000eb68:	cf d0       	breq	8000eb62 <__mdiff+0xb6>
8000eb6a:	99 49       	st.w	r12[0x10],r9
8000eb6c:	d8 32       	popm	r0-r7,pc
8000eb6e:	30 0b       	mov	r11,0
8000eb70:	c1 6f       	rcall	8000e99c <_Balloc>
8000eb72:	30 18       	mov	r8,1
8000eb74:	99 48       	st.w	r12[0x10],r8
8000eb76:	30 08       	mov	r8,0
8000eb78:	99 58       	st.w	r12[0x14],r8
8000eb7a:	d8 32       	popm	r0-r7,pc

8000eb7c <__lshift>:
8000eb7c:	d4 31       	pushm	r0-r7,lr
8000eb7e:	16 97       	mov	r7,r11
8000eb80:	76 46       	ld.w	r6,r11[0x10]
8000eb82:	f4 02 14 05 	asr	r2,r10,0x5
8000eb86:	2f f6       	sub	r6,-1
8000eb88:	14 93       	mov	r3,r10
8000eb8a:	18 94       	mov	r4,r12
8000eb8c:	04 06       	add	r6,r2
8000eb8e:	76 1b       	ld.w	r11,r11[0x4]
8000eb90:	6e 28       	ld.w	r8,r7[0x8]
8000eb92:	c0 38       	rjmp	8000eb98 <__lshift+0x1c>
8000eb94:	2f fb       	sub	r11,-1
8000eb96:	a1 78       	lsl	r8,0x1
8000eb98:	10 36       	cp.w	r6,r8
8000eb9a:	fe 99 ff fd 	brgt	8000eb94 <__lshift+0x18>
8000eb9e:	08 9c       	mov	r12,r4
8000eba0:	cf ee       	rcall	8000e99c <_Balloc>
8000eba2:	30 09       	mov	r9,0
8000eba4:	18 95       	mov	r5,r12
8000eba6:	f8 c8 ff ec 	sub	r8,r12,-20
8000ebaa:	12 9a       	mov	r10,r9
8000ebac:	c0 38       	rjmp	8000ebb2 <__lshift+0x36>
8000ebae:	10 aa       	st.w	r8++,r10
8000ebb0:	2f f9       	sub	r9,-1
8000ebb2:	04 39       	cp.w	r9,r2
8000ebb4:	cf d5       	brlt	8000ebae <__lshift+0x32>
8000ebb6:	6e 4b       	ld.w	r11,r7[0x10]
8000ebb8:	e7 d3 c0 05 	bfextu	r3,r3,0x0,0x5
8000ebbc:	2f bb       	sub	r11,-5
8000ebbe:	ee c9 ff ec 	sub	r9,r7,-20
8000ebc2:	ee 0b 00 2b 	add	r11,r7,r11<<0x2
8000ebc6:	58 03       	cp.w	r3,0
8000ebc8:	c1 30       	breq	8000ebee <__lshift+0x72>
8000ebca:	e6 0c 11 20 	rsub	r12,r3,32
8000ebce:	30 0a       	mov	r10,0
8000ebd0:	72 02       	ld.w	r2,r9[0x0]
8000ebd2:	e4 03 09 42 	lsl	r2,r2,r3
8000ebd6:	04 4a       	or	r10,r2
8000ebd8:	10 aa       	st.w	r8++,r10
8000ebda:	13 0a       	ld.w	r10,r9++
8000ebdc:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000ebe0:	16 39       	cp.w	r9,r11
8000ebe2:	cf 73       	brcs	8000ebd0 <__lshift+0x54>
8000ebe4:	91 0a       	st.w	r8[0x0],r10
8000ebe6:	58 0a       	cp.w	r10,0
8000ebe8:	c0 70       	breq	8000ebf6 <__lshift+0x7a>
8000ebea:	2f f6       	sub	r6,-1
8000ebec:	c0 58       	rjmp	8000ebf6 <__lshift+0x7a>
8000ebee:	13 0a       	ld.w	r10,r9++
8000ebf0:	10 aa       	st.w	r8++,r10
8000ebf2:	16 39       	cp.w	r9,r11
8000ebf4:	cf d3       	brcs	8000ebee <__lshift+0x72>
8000ebf6:	08 9c       	mov	r12,r4
8000ebf8:	20 16       	sub	r6,1
8000ebfa:	0e 9b       	mov	r11,r7
8000ebfc:	8b 46       	st.w	r5[0x10],r6
8000ebfe:	cb 5e       	rcall	8000e968 <_Bfree>
8000ec00:	0a 9c       	mov	r12,r5
8000ec02:	d8 32       	popm	r0-r7,pc

8000ec04 <__multiply>:
8000ec04:	d4 31       	pushm	r0-r7,lr
8000ec06:	20 2d       	sub	sp,8
8000ec08:	76 49       	ld.w	r9,r11[0x10]
8000ec0a:	74 48       	ld.w	r8,r10[0x10]
8000ec0c:	16 96       	mov	r6,r11
8000ec0e:	14 95       	mov	r5,r10
8000ec10:	10 39       	cp.w	r9,r8
8000ec12:	ec 08 17 50 	movlt	r8,r6
8000ec16:	ea 06 17 50 	movlt	r6,r5
8000ec1a:	f0 05 17 50 	movlt	r5,r8
8000ec1e:	6c 28       	ld.w	r8,r6[0x8]
8000ec20:	76 43       	ld.w	r3,r11[0x10]
8000ec22:	74 42       	ld.w	r2,r10[0x10]
8000ec24:	76 1b       	ld.w	r11,r11[0x4]
8000ec26:	e4 03 00 07 	add	r7,r2,r3
8000ec2a:	10 37       	cp.w	r7,r8
8000ec2c:	f7 bb 09 ff 	subgt	r11,-1
8000ec30:	cb 6e       	rcall	8000e99c <_Balloc>
8000ec32:	ee c4 ff fb 	sub	r4,r7,-5
8000ec36:	f8 c9 ff ec 	sub	r9,r12,-20
8000ec3a:	f8 04 00 24 	add	r4,r12,r4<<0x2
8000ec3e:	30 0a       	mov	r10,0
8000ec40:	12 98       	mov	r8,r9
8000ec42:	c0 28       	rjmp	8000ec46 <__multiply+0x42>
8000ec44:	10 aa       	st.w	r8++,r10
8000ec46:	08 38       	cp.w	r8,r4
8000ec48:	cf e3       	brcs	8000ec44 <__multiply+0x40>
8000ec4a:	2f b3       	sub	r3,-5
8000ec4c:	2f b2       	sub	r2,-5
8000ec4e:	ec 03 00 23 	add	r3,r6,r3<<0x2
8000ec52:	ea 02 00 22 	add	r2,r5,r2<<0x2
8000ec56:	ec cb ff ec 	sub	r11,r6,-20
8000ec5a:	50 12       	stdsp	sp[0x4],r2
8000ec5c:	ea ca ff ec 	sub	r10,r5,-20
8000ec60:	c4 48       	rjmp	8000ece8 <__multiply+0xe4>
8000ec62:	94 95       	ld.uh	r5,r10[0x2]
8000ec64:	58 05       	cp.w	r5,0
8000ec66:	c2 00       	breq	8000eca6 <__multiply+0xa2>
8000ec68:	12 98       	mov	r8,r9
8000ec6a:	16 96       	mov	r6,r11
8000ec6c:	30 0e       	mov	lr,0
8000ec6e:	50 09       	stdsp	sp[0x0],r9
8000ec70:	0d 02       	ld.w	r2,r6++
8000ec72:	e4 00 16 10 	lsr	r0,r2,0x10
8000ec76:	70 01       	ld.w	r1,r8[0x0]
8000ec78:	70 09       	ld.w	r9,r8[0x0]
8000ec7a:	b1 81       	lsr	r1,0x10
8000ec7c:	e5 d2 c0 10 	bfextu	r2,r2,0x0,0x10
8000ec80:	e0 05 03 41 	mac	r1,r0,r5
8000ec84:	ab 32       	mul	r2,r5
8000ec86:	e1 d9 c0 10 	bfextu	r0,r9,0x0,0x10
8000ec8a:	00 02       	add	r2,r0
8000ec8c:	e4 0e 00 0e 	add	lr,r2,lr
8000ec90:	b0 1e       	st.h	r8[0x2],lr
8000ec92:	b1 8e       	lsr	lr,0x10
8000ec94:	1c 01       	add	r1,lr
8000ec96:	b0 01       	st.h	r8[0x0],r1
8000ec98:	e2 0e 16 10 	lsr	lr,r1,0x10
8000ec9c:	2f c8       	sub	r8,-4
8000ec9e:	06 36       	cp.w	r6,r3
8000eca0:	ce 83       	brcs	8000ec70 <__multiply+0x6c>
8000eca2:	40 09       	lddsp	r9,sp[0x0]
8000eca4:	91 0e       	st.w	r8[0x0],lr
8000eca6:	94 86       	ld.uh	r6,r10[0x0]
8000eca8:	58 06       	cp.w	r6,0
8000ecaa:	c1 d0       	breq	8000ece4 <__multiply+0xe0>
8000ecac:	72 02       	ld.w	r2,r9[0x0]
8000ecae:	12 98       	mov	r8,r9
8000ecb0:	16 9e       	mov	lr,r11
8000ecb2:	30 05       	mov	r5,0
8000ecb4:	b0 12       	st.h	r8[0x2],r2
8000ecb6:	1d 01       	ld.w	r1,lr++
8000ecb8:	90 82       	ld.uh	r2,r8[0x0]
8000ecba:	e1 d1 c0 10 	bfextu	r0,r1,0x0,0x10
8000ecbe:	ad 30       	mul	r0,r6
8000ecc0:	e0 02 00 02 	add	r2,r0,r2
8000ecc4:	e4 05 00 05 	add	r5,r2,r5
8000ecc8:	b0 05       	st.h	r8[0x0],r5
8000ecca:	b1 85       	lsr	r5,0x10
8000eccc:	b1 81       	lsr	r1,0x10
8000ecce:	2f c8       	sub	r8,-4
8000ecd0:	ad 31       	mul	r1,r6
8000ecd2:	90 92       	ld.uh	r2,r8[0x2]
8000ecd4:	e2 02 00 02 	add	r2,r1,r2
8000ecd8:	0a 02       	add	r2,r5
8000ecda:	e4 05 16 10 	lsr	r5,r2,0x10
8000ecde:	06 3e       	cp.w	lr,r3
8000ece0:	ce a3       	brcs	8000ecb4 <__multiply+0xb0>
8000ece2:	91 02       	st.w	r8[0x0],r2
8000ece4:	2f ca       	sub	r10,-4
8000ece6:	2f c9       	sub	r9,-4
8000ece8:	40 18       	lddsp	r8,sp[0x4]
8000ecea:	10 3a       	cp.w	r10,r8
8000ecec:	cb b3       	brcs	8000ec62 <__multiply+0x5e>
8000ecee:	c0 28       	rjmp	8000ecf2 <__multiply+0xee>
8000ecf0:	20 17       	sub	r7,1
8000ecf2:	58 07       	cp.w	r7,0
8000ecf4:	e0 8a 00 05 	brle	8000ecfe <__multiply+0xfa>
8000ecf8:	09 48       	ld.w	r8,--r4
8000ecfa:	58 08       	cp.w	r8,0
8000ecfc:	cf a0       	breq	8000ecf0 <__multiply+0xec>
8000ecfe:	99 47       	st.w	r12[0x10],r7
8000ed00:	2f ed       	sub	sp,-8
8000ed02:	d8 32       	popm	r0-r7,pc

8000ed04 <__i2b>:
8000ed04:	d4 21       	pushm	r4-r7,lr
8000ed06:	16 97       	mov	r7,r11
8000ed08:	30 1b       	mov	r11,1
8000ed0a:	c4 9e       	rcall	8000e99c <_Balloc>
8000ed0c:	30 19       	mov	r9,1
8000ed0e:	99 57       	st.w	r12[0x14],r7
8000ed10:	99 49       	st.w	r12[0x10],r9
8000ed12:	d8 22       	popm	r4-r7,pc

8000ed14 <__multadd>:
8000ed14:	d4 31       	pushm	r0-r7,lr
8000ed16:	30 08       	mov	r8,0
8000ed18:	12 95       	mov	r5,r9
8000ed1a:	16 97       	mov	r7,r11
8000ed1c:	18 96       	mov	r6,r12
8000ed1e:	76 44       	ld.w	r4,r11[0x10]
8000ed20:	f6 c9 ff ec 	sub	r9,r11,-20
8000ed24:	72 0b       	ld.w	r11,r9[0x0]
8000ed26:	f6 0c 16 10 	lsr	r12,r11,0x10
8000ed2a:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000ed2e:	f4 0c 02 4c 	mul	r12,r10,r12
8000ed32:	f4 0b 03 45 	mac	r5,r10,r11
8000ed36:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
8000ed3a:	b1 85       	lsr	r5,0x10
8000ed3c:	18 05       	add	r5,r12
8000ed3e:	ea 0c 15 10 	lsl	r12,r5,0x10
8000ed42:	f8 0b 00 0b 	add	r11,r12,r11
8000ed46:	12 ab       	st.w	r9++,r11
8000ed48:	2f f8       	sub	r8,-1
8000ed4a:	b1 85       	lsr	r5,0x10
8000ed4c:	08 38       	cp.w	r8,r4
8000ed4e:	ce b5       	brlt	8000ed24 <__multadd+0x10>
8000ed50:	58 05       	cp.w	r5,0
8000ed52:	c1 c0       	breq	8000ed8a <__multadd+0x76>
8000ed54:	6e 28       	ld.w	r8,r7[0x8]
8000ed56:	10 34       	cp.w	r4,r8
8000ed58:	c1 35       	brlt	8000ed7e <__multadd+0x6a>
8000ed5a:	6e 1b       	ld.w	r11,r7[0x4]
8000ed5c:	0c 9c       	mov	r12,r6
8000ed5e:	2f fb       	sub	r11,-1
8000ed60:	c1 ee       	rcall	8000e99c <_Balloc>
8000ed62:	6e 4a       	ld.w	r10,r7[0x10]
8000ed64:	ee cb ff f4 	sub	r11,r7,-12
8000ed68:	18 93       	mov	r3,r12
8000ed6a:	2f ea       	sub	r10,-2
8000ed6c:	2f 4c       	sub	r12,-12
8000ed6e:	a3 6a       	lsl	r10,0x2
8000ed70:	fe b0 dd cb 	rcall	8000a906 <memcpy>
8000ed74:	0e 9b       	mov	r11,r7
8000ed76:	0c 9c       	mov	r12,r6
8000ed78:	fe b0 fd f8 	rcall	8000e968 <_Bfree>
8000ed7c:	06 97       	mov	r7,r3
8000ed7e:	e8 c8 ff ff 	sub	r8,r4,-1
8000ed82:	2f b4       	sub	r4,-5
8000ed84:	8f 48       	st.w	r7[0x10],r8
8000ed86:	ee 04 09 25 	st.w	r7[r4<<0x2],r5
8000ed8a:	0e 9c       	mov	r12,r7
8000ed8c:	d8 32       	popm	r0-r7,pc
8000ed8e:	d7 03       	nop

8000ed90 <__pow5mult>:
8000ed90:	d4 31       	pushm	r0-r7,lr
8000ed92:	14 96       	mov	r6,r10
8000ed94:	18 97       	mov	r7,r12
8000ed96:	16 94       	mov	r4,r11
8000ed98:	f1 da c0 02 	bfextu	r8,r10,0x0,0x2
8000ed9c:	c0 80       	breq	8000edac <__pow5mult+0x1c>
8000ed9e:	20 18       	sub	r8,1
8000eda0:	49 f9       	lddpc	r9,8000ee1c <__pow5mult+0x8c>
8000eda2:	f2 08 03 2a 	ld.w	r10,r9[r8<<0x2]
8000eda6:	30 09       	mov	r9,0
8000eda8:	cb 6f       	rcall	8000ed14 <__multadd>
8000edaa:	18 94       	mov	r4,r12
8000edac:	a3 46       	asr	r6,0x2
8000edae:	c3 40       	breq	8000ee16 <__pow5mult+0x86>
8000edb0:	6e 95       	ld.w	r5,r7[0x24]
8000edb2:	58 05       	cp.w	r5,0
8000edb4:	c0 91       	brne	8000edc6 <__pow5mult+0x36>
8000edb6:	31 0c       	mov	r12,16
8000edb8:	fe b0 db 70 	rcall	8000a498 <malloc>
8000edbc:	99 35       	st.w	r12[0xc],r5
8000edbe:	8f 9c       	st.w	r7[0x24],r12
8000edc0:	99 15       	st.w	r12[0x4],r5
8000edc2:	99 25       	st.w	r12[0x8],r5
8000edc4:	99 05       	st.w	r12[0x0],r5
8000edc6:	6e 93       	ld.w	r3,r7[0x24]
8000edc8:	66 25       	ld.w	r5,r3[0x8]
8000edca:	58 05       	cp.w	r5,0
8000edcc:	c0 c1       	brne	8000ede4 <__pow5mult+0x54>
8000edce:	e0 6b 02 71 	mov	r11,625
8000edd2:	0e 9c       	mov	r12,r7
8000edd4:	c9 8f       	rcall	8000ed04 <__i2b>
8000edd6:	87 2c       	st.w	r3[0x8],r12
8000edd8:	30 08       	mov	r8,0
8000edda:	18 95       	mov	r5,r12
8000eddc:	99 08       	st.w	r12[0x0],r8
8000edde:	c0 38       	rjmp	8000ede4 <__pow5mult+0x54>
8000ede0:	06 9c       	mov	r12,r3
8000ede2:	18 95       	mov	r5,r12
8000ede4:	ed b6 00 00 	bld	r6,0x0
8000ede8:	c0 b1       	brne	8000edfe <__pow5mult+0x6e>
8000edea:	08 9b       	mov	r11,r4
8000edec:	0a 9a       	mov	r10,r5
8000edee:	0e 9c       	mov	r12,r7
8000edf0:	c0 af       	rcall	8000ec04 <__multiply>
8000edf2:	08 9b       	mov	r11,r4
8000edf4:	18 93       	mov	r3,r12
8000edf6:	0e 9c       	mov	r12,r7
8000edf8:	06 94       	mov	r4,r3
8000edfa:	fe b0 fd b7 	rcall	8000e968 <_Bfree>
8000edfe:	a1 56       	asr	r6,0x1
8000ee00:	c0 b0       	breq	8000ee16 <__pow5mult+0x86>
8000ee02:	6a 03       	ld.w	r3,r5[0x0]
8000ee04:	58 03       	cp.w	r3,0
8000ee06:	ce d1       	brne	8000ede0 <__pow5mult+0x50>
8000ee08:	0a 9a       	mov	r10,r5
8000ee0a:	0a 9b       	mov	r11,r5
8000ee0c:	0e 9c       	mov	r12,r7
8000ee0e:	cf be       	rcall	8000ec04 <__multiply>
8000ee10:	8b 0c       	st.w	r5[0x0],r12
8000ee12:	99 03       	st.w	r12[0x0],r3
8000ee14:	ce 7b       	rjmp	8000ede2 <__pow5mult+0x52>
8000ee16:	08 9c       	mov	r12,r4
8000ee18:	d8 32       	popm	r0-r7,pc
8000ee1a:	d7 03       	nop
8000ee1c:	80 01       	ld.sh	r1,r0[0x0]
8000ee1e:	97 8c       	st.w	r11[0x20],r12

8000ee20 <__isinfd>:
8000ee20:	14 98       	mov	r8,r10
8000ee22:	fc 19 7f f0 	movh	r9,0x7ff0
8000ee26:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000ee2a:	f0 0b 11 00 	rsub	r11,r8,0
8000ee2e:	f7 e8 10 08 	or	r8,r11,r8
8000ee32:	f5 e8 13 f8 	or	r8,r10,r8>>0x1f
8000ee36:	f2 08 01 08 	sub	r8,r9,r8
8000ee3a:	f0 0c 11 00 	rsub	r12,r8,0
8000ee3e:	f9 e8 10 08 	or	r8,r12,r8
8000ee42:	f0 0c 14 1f 	asr	r12,r8,0x1f
8000ee46:	2f fc       	sub	r12,-1
8000ee48:	5e fc       	retal	r12

8000ee4a <__isnand>:
8000ee4a:	14 98       	mov	r8,r10
8000ee4c:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000ee50:	f0 0c 11 00 	rsub	r12,r8,0
8000ee54:	10 4c       	or	r12,r8
8000ee56:	fc 18 7f f0 	movh	r8,0x7ff0
8000ee5a:	f5 ec 13 fc 	or	r12,r10,r12>>0x1f
8000ee5e:	f0 0c 01 0c 	sub	r12,r8,r12
8000ee62:	bf 9c       	lsr	r12,0x1f
8000ee64:	5e fc       	retal	r12
8000ee66:	d7 03       	nop

8000ee68 <__sclose>:
8000ee68:	d4 01       	pushm	lr
8000ee6a:	96 7b       	ld.sh	r11,r11[0xe]
8000ee6c:	c7 6c       	rcall	8000ef58 <_close_r>
8000ee6e:	d8 02       	popm	pc

8000ee70 <__sseek>:
8000ee70:	d4 21       	pushm	r4-r7,lr
8000ee72:	16 97       	mov	r7,r11
8000ee74:	96 7b       	ld.sh	r11,r11[0xe]
8000ee76:	cf 9c       	rcall	8000f068 <_lseek_r>
8000ee78:	8e 68       	ld.sh	r8,r7[0xc]
8000ee7a:	10 99       	mov	r9,r8
8000ee7c:	ad c8       	cbr	r8,0xc
8000ee7e:	ad a9       	sbr	r9,0xc
8000ee80:	5b fc       	cp.w	r12,-1
8000ee82:	ef f8 0c 06 	st.heq	r7[0xc],r8
8000ee86:	ef f9 1c 06 	st.hne	r7[0xc],r9
8000ee8a:	ef fc 1a 15 	st.wne	r7[0x54],r12
8000ee8e:	d8 22       	popm	r4-r7,pc

8000ee90 <__swrite>:
8000ee90:	d4 21       	pushm	r4-r7,lr
8000ee92:	96 68       	ld.sh	r8,r11[0xc]
8000ee94:	16 97       	mov	r7,r11
8000ee96:	14 95       	mov	r5,r10
8000ee98:	12 94       	mov	r4,r9
8000ee9a:	e2 18 01 00 	andl	r8,0x100,COH
8000ee9e:	18 96       	mov	r6,r12
8000eea0:	c0 50       	breq	8000eeaa <__swrite+0x1a>
8000eea2:	30 29       	mov	r9,2
8000eea4:	30 0a       	mov	r10,0
8000eea6:	96 7b       	ld.sh	r11,r11[0xe]
8000eea8:	ce 0c       	rcall	8000f068 <_lseek_r>
8000eeaa:	8e 68       	ld.sh	r8,r7[0xc]
8000eeac:	ad c8       	cbr	r8,0xc
8000eeae:	08 99       	mov	r9,r4
8000eeb0:	0a 9a       	mov	r10,r5
8000eeb2:	8e 7b       	ld.sh	r11,r7[0xe]
8000eeb4:	0c 9c       	mov	r12,r6
8000eeb6:	ae 68       	st.h	r7[0xc],r8
8000eeb8:	c1 0c       	rcall	8000eed8 <_write_r>
8000eeba:	d8 22       	popm	r4-r7,pc

8000eebc <__sread>:
8000eebc:	d4 21       	pushm	r4-r7,lr
8000eebe:	16 97       	mov	r7,r11
8000eec0:	96 7b       	ld.sh	r11,r11[0xe]
8000eec2:	ce 7c       	rcall	8000f090 <_read_r>
8000eec4:	c0 65       	brlt	8000eed0 <__sread+0x14>
8000eec6:	6f 58       	ld.w	r8,r7[0x54]
8000eec8:	18 08       	add	r8,r12
8000eeca:	ef 48 00 54 	st.w	r7[84],r8
8000eece:	d8 22       	popm	r4-r7,pc
8000eed0:	8e 68       	ld.sh	r8,r7[0xc]
8000eed2:	ad c8       	cbr	r8,0xc
8000eed4:	ae 68       	st.h	r7[0xc],r8
8000eed6:	d8 22       	popm	r4-r7,pc

8000eed8 <_write_r>:
8000eed8:	d4 21       	pushm	r4-r7,lr
8000eeda:	16 98       	mov	r8,r11
8000eedc:	18 97       	mov	r7,r12
8000eede:	10 9c       	mov	r12,r8
8000eee0:	30 08       	mov	r8,0
8000eee2:	14 9b       	mov	r11,r10
8000eee4:	e0 66 46 a8 	mov	r6,18088
8000eee8:	12 9a       	mov	r10,r9
8000eeea:	8d 08       	st.w	r6[0x0],r8
8000eeec:	fe b0 d0 56 	rcall	80008f98 <_write>
8000eef0:	5b fc       	cp.w	r12,-1
8000eef2:	c0 51       	brne	8000eefc <_write_r+0x24>
8000eef4:	6c 08       	ld.w	r8,r6[0x0]
8000eef6:	58 08       	cp.w	r8,0
8000eef8:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000eefc:	d8 22       	popm	r4-r7,pc
8000eefe:	d7 03       	nop

8000ef00 <_calloc_r>:
8000ef00:	d4 21       	pushm	r4-r7,lr
8000ef02:	f4 0b 02 4b 	mul	r11,r10,r11
8000ef06:	fe b0 da d1 	rcall	8000a4a8 <_malloc_r>
8000ef0a:	18 97       	mov	r7,r12
8000ef0c:	c2 30       	breq	8000ef52 <_calloc_r+0x52>
8000ef0e:	f8 fa ff fc 	ld.w	r10,r12[-4]
8000ef12:	e0 1a ff fc 	andl	r10,0xfffc
8000ef16:	20 4a       	sub	r10,4
8000ef18:	e0 4a 00 24 	cp.w	r10,36
8000ef1c:	e0 8b 00 18 	brhi	8000ef4c <_calloc_r+0x4c>
8000ef20:	18 98       	mov	r8,r12
8000ef22:	59 3a       	cp.w	r10,19
8000ef24:	e0 88 00 0f 	brls	8000ef42 <_calloc_r+0x42>
8000ef28:	30 09       	mov	r9,0
8000ef2a:	10 a9       	st.w	r8++,r9
8000ef2c:	10 a9       	st.w	r8++,r9
8000ef2e:	59 ba       	cp.w	r10,27
8000ef30:	e0 88 00 09 	brls	8000ef42 <_calloc_r+0x42>
8000ef34:	10 a9       	st.w	r8++,r9
8000ef36:	10 a9       	st.w	r8++,r9
8000ef38:	e0 4a 00 24 	cp.w	r10,36
8000ef3c:	c0 31       	brne	8000ef42 <_calloc_r+0x42>
8000ef3e:	10 a9       	st.w	r8++,r9
8000ef40:	10 a9       	st.w	r8++,r9
8000ef42:	30 09       	mov	r9,0
8000ef44:	10 a9       	st.w	r8++,r9
8000ef46:	91 19       	st.w	r8[0x4],r9
8000ef48:	91 09       	st.w	r8[0x0],r9
8000ef4a:	c0 48       	rjmp	8000ef52 <_calloc_r+0x52>
8000ef4c:	30 0b       	mov	r11,0
8000ef4e:	fe b0 dd 80 	rcall	8000aa4e <memset>
8000ef52:	0e 9c       	mov	r12,r7
8000ef54:	d8 22       	popm	r4-r7,pc
8000ef56:	d7 03       	nop

8000ef58 <_close_r>:
8000ef58:	d4 21       	pushm	r4-r7,lr
8000ef5a:	30 08       	mov	r8,0
8000ef5c:	18 97       	mov	r7,r12
8000ef5e:	e0 66 46 a8 	mov	r6,18088
8000ef62:	16 9c       	mov	r12,r11
8000ef64:	8d 08       	st.w	r6[0x0],r8
8000ef66:	fe b0 df a5 	rcall	8000aeb0 <_close>
8000ef6a:	5b fc       	cp.w	r12,-1
8000ef6c:	c0 51       	brne	8000ef76 <_close_r+0x1e>
8000ef6e:	6c 08       	ld.w	r8,r6[0x0]
8000ef70:	58 08       	cp.w	r8,0
8000ef72:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000ef76:	d8 22       	popm	r4-r7,pc

8000ef78 <_fclose_r>:
8000ef78:	d4 21       	pushm	r4-r7,lr
8000ef7a:	18 96       	mov	r6,r12
8000ef7c:	16 97       	mov	r7,r11
8000ef7e:	58 0b       	cp.w	r11,0
8000ef80:	c0 31       	brne	8000ef86 <_fclose_r+0xe>
8000ef82:	16 95       	mov	r5,r11
8000ef84:	c5 08       	rjmp	8000f024 <_fclose_r+0xac>
8000ef86:	fe b0 f8 b1 	rcall	8000e0e8 <__sfp_lock_acquire>
8000ef8a:	58 06       	cp.w	r6,0
8000ef8c:	c0 70       	breq	8000ef9a <_fclose_r+0x22>
8000ef8e:	6c 68       	ld.w	r8,r6[0x18]
8000ef90:	58 08       	cp.w	r8,0
8000ef92:	c0 41       	brne	8000ef9a <_fclose_r+0x22>
8000ef94:	0c 9c       	mov	r12,r6
8000ef96:	fe b0 f8 fd 	rcall	8000e190 <__sinit>
8000ef9a:	4a 48       	lddpc	r8,8000f028 <_fclose_r+0xb0>
8000ef9c:	10 37       	cp.w	r7,r8
8000ef9e:	c0 31       	brne	8000efa4 <_fclose_r+0x2c>
8000efa0:	6c 07       	ld.w	r7,r6[0x0]
8000efa2:	c0 a8       	rjmp	8000efb6 <_fclose_r+0x3e>
8000efa4:	4a 28       	lddpc	r8,8000f02c <_fclose_r+0xb4>
8000efa6:	10 37       	cp.w	r7,r8
8000efa8:	c0 31       	brne	8000efae <_fclose_r+0x36>
8000efaa:	6c 17       	ld.w	r7,r6[0x4]
8000efac:	c0 58       	rjmp	8000efb6 <_fclose_r+0x3e>
8000efae:	4a 18       	lddpc	r8,8000f030 <_fclose_r+0xb8>
8000efb0:	10 37       	cp.w	r7,r8
8000efb2:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000efb6:	8e 69       	ld.sh	r9,r7[0xc]
8000efb8:	30 08       	mov	r8,0
8000efba:	f0 09 19 00 	cp.h	r9,r8
8000efbe:	c0 51       	brne	8000efc8 <_fclose_r+0x50>
8000efc0:	fe b0 f8 95 	rcall	8000e0ea <__sfp_lock_release>
8000efc4:	30 05       	mov	r5,0
8000efc6:	c2 f8       	rjmp	8000f024 <_fclose_r+0xac>
8000efc8:	0e 9b       	mov	r11,r7
8000efca:	0c 9c       	mov	r12,r6
8000efcc:	fe b0 f8 06 	rcall	8000dfd8 <_fflush_r>
8000efd0:	6e c8       	ld.w	r8,r7[0x30]
8000efd2:	18 95       	mov	r5,r12
8000efd4:	58 08       	cp.w	r8,0
8000efd6:	c0 60       	breq	8000efe2 <_fclose_r+0x6a>
8000efd8:	6e 8b       	ld.w	r11,r7[0x20]
8000efda:	0c 9c       	mov	r12,r6
8000efdc:	5d 18       	icall	r8
8000efde:	f9 b5 05 ff 	movlt	r5,-1
8000efe2:	8e 68       	ld.sh	r8,r7[0xc]
8000efe4:	ed b8 00 07 	bld	r8,0x7
8000efe8:	c0 51       	brne	8000eff2 <_fclose_r+0x7a>
8000efea:	6e 4b       	ld.w	r11,r7[0x10]
8000efec:	0c 9c       	mov	r12,r6
8000efee:	fe b0 f9 6b 	rcall	8000e2c4 <_free_r>
8000eff2:	6e db       	ld.w	r11,r7[0x34]
8000eff4:	58 0b       	cp.w	r11,0
8000eff6:	c0 a0       	breq	8000f00a <_fclose_r+0x92>
8000eff8:	ee c8 ff bc 	sub	r8,r7,-68
8000effc:	10 3b       	cp.w	r11,r8
8000effe:	c0 40       	breq	8000f006 <_fclose_r+0x8e>
8000f000:	0c 9c       	mov	r12,r6
8000f002:	fe b0 f9 61 	rcall	8000e2c4 <_free_r>
8000f006:	30 08       	mov	r8,0
8000f008:	8f d8       	st.w	r7[0x34],r8
8000f00a:	6f 2b       	ld.w	r11,r7[0x48]
8000f00c:	58 0b       	cp.w	r11,0
8000f00e:	c0 70       	breq	8000f01c <_fclose_r+0xa4>
8000f010:	0c 9c       	mov	r12,r6
8000f012:	fe b0 f9 59 	rcall	8000e2c4 <_free_r>
8000f016:	30 08       	mov	r8,0
8000f018:	ef 48 00 48 	st.w	r7[72],r8
8000f01c:	30 08       	mov	r8,0
8000f01e:	ae 68       	st.h	r7[0xc],r8
8000f020:	fe b0 f8 65 	rcall	8000e0ea <__sfp_lock_release>
8000f024:	0a 9c       	mov	r12,r5
8000f026:	d8 22       	popm	r4-r7,pc
8000f028:	80 01       	ld.sh	r1,r0[0x0]
8000f02a:	96 e8       	ld.uh	r8,r11[0xc]
8000f02c:	80 01       	ld.sh	r1,r0[0x0]
8000f02e:	97 08       	st.w	r11[0x0],r8
8000f030:	80 01       	ld.sh	r1,r0[0x0]
8000f032:	97 28       	st.w	r11[0x8],r8

8000f034 <fclose>:
8000f034:	d4 01       	pushm	lr
8000f036:	e0 68 0a 38 	mov	r8,2616
8000f03a:	18 9b       	mov	r11,r12
8000f03c:	70 0c       	ld.w	r12,r8[0x0]
8000f03e:	c9 df       	rcall	8000ef78 <_fclose_r>
8000f040:	d8 02       	popm	pc
8000f042:	d7 03       	nop

8000f044 <_fstat_r>:
8000f044:	d4 21       	pushm	r4-r7,lr
8000f046:	16 98       	mov	r8,r11
8000f048:	18 97       	mov	r7,r12
8000f04a:	10 9c       	mov	r12,r8
8000f04c:	30 08       	mov	r8,0
8000f04e:	e0 66 46 a8 	mov	r6,18088
8000f052:	14 9b       	mov	r11,r10
8000f054:	8d 08       	st.w	r6[0x0],r8
8000f056:	fe b0 df 55 	rcall	8000af00 <_fstat>
8000f05a:	5b fc       	cp.w	r12,-1
8000f05c:	c0 51       	brne	8000f066 <_fstat_r+0x22>
8000f05e:	6c 08       	ld.w	r8,r6[0x0]
8000f060:	58 08       	cp.w	r8,0
8000f062:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000f066:	d8 22       	popm	r4-r7,pc

8000f068 <_lseek_r>:
8000f068:	d4 21       	pushm	r4-r7,lr
8000f06a:	16 98       	mov	r8,r11
8000f06c:	18 97       	mov	r7,r12
8000f06e:	10 9c       	mov	r12,r8
8000f070:	30 08       	mov	r8,0
8000f072:	14 9b       	mov	r11,r10
8000f074:	e0 66 46 a8 	mov	r6,18088
8000f078:	12 9a       	mov	r10,r9
8000f07a:	8d 08       	st.w	r6[0x0],r8
8000f07c:	fe b0 df 24 	rcall	8000aec4 <_lseek>
8000f080:	5b fc       	cp.w	r12,-1
8000f082:	c0 51       	brne	8000f08c <_lseek_r+0x24>
8000f084:	6c 08       	ld.w	r8,r6[0x0]
8000f086:	58 08       	cp.w	r8,0
8000f088:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000f08c:	d8 22       	popm	r4-r7,pc
8000f08e:	d7 03       	nop

8000f090 <_read_r>:
8000f090:	d4 21       	pushm	r4-r7,lr
8000f092:	16 98       	mov	r8,r11
8000f094:	18 97       	mov	r7,r12
8000f096:	10 9c       	mov	r12,r8
8000f098:	30 08       	mov	r8,0
8000f09a:	14 9b       	mov	r11,r10
8000f09c:	e0 66 46 a8 	mov	r6,18088
8000f0a0:	12 9a       	mov	r10,r9
8000f0a2:	8d 08       	st.w	r6[0x0],r8
8000f0a4:	fe b0 cf 5a 	rcall	80008f58 <_read>
8000f0a8:	5b fc       	cp.w	r12,-1
8000f0aa:	c0 51       	brne	8000f0b4 <_read_r+0x24>
8000f0ac:	6c 08       	ld.w	r8,r6[0x0]
8000f0ae:	58 08       	cp.w	r8,0
8000f0b0:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000f0b4:	d8 22       	popm	r4-r7,pc
8000f0b6:	d7 03       	nop

8000f0b8 <__avr32_f64_mul>:
8000f0b8:	f5 eb 10 1c 	or	r12,r10,r11<<0x1
8000f0bc:	e0 80 00 dc 	breq	8000f274 <__avr32_f64_mul_op1_zero>
8000f0c0:	d4 21       	pushm	r4-r7,lr
8000f0c2:	f7 e9 20 0e 	eor	lr,r11,r9
8000f0c6:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000f0ca:	30 15       	mov	r5,1
8000f0cc:	c4 30       	breq	8000f152 <__avr32_f64_mul_op1_subnormal>
8000f0ce:	ab 6b       	lsl	r11,0xa
8000f0d0:	f7 ea 13 6b 	or	r11,r11,r10>>0x16
8000f0d4:	ab 6a       	lsl	r10,0xa
8000f0d6:	f7 d5 d3 c2 	bfins	r11,r5,0x1e,0x2
8000f0da:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000f0de:	c5 c0       	breq	8000f196 <__avr32_f64_mul_op2_subnormal>
8000f0e0:	a1 78       	lsl	r8,0x1
8000f0e2:	5c f9       	rol	r9
8000f0e4:	f3 d5 d2 ab 	bfins	r9,r5,0x15,0xb
8000f0e8:	e0 47 07 ff 	cp.w	r7,2047
8000f0ec:	c7 70       	breq	8000f1da <__avr32_f64_mul_op_nan_or_inf>
8000f0ee:	e0 46 07 ff 	cp.w	r6,2047
8000f0f2:	c7 40       	breq	8000f1da <__avr32_f64_mul_op_nan_or_inf>
8000f0f4:	ee 06 00 0c 	add	r12,r7,r6
8000f0f8:	e0 2c 03 fe 	sub	r12,1022
8000f0fc:	f6 08 06 44 	mulu.d	r4,r11,r8
8000f100:	f4 09 07 44 	macu.d	r4,r10,r9
8000f104:	f4 08 06 46 	mulu.d	r6,r10,r8
8000f108:	f6 09 06 4a 	mulu.d	r10,r11,r9
8000f10c:	08 07       	add	r7,r4
8000f10e:	f4 05 00 4a 	adc	r10,r10,r5
8000f112:	5c 0b       	acr	r11
8000f114:	ed bb 00 14 	bld	r11,0x14
8000f118:	c0 50       	breq	8000f122 <__avr32_f64_mul+0x6a>
8000f11a:	a1 77       	lsl	r7,0x1
8000f11c:	5c fa       	rol	r10
8000f11e:	5c fb       	rol	r11
8000f120:	20 1c       	sub	r12,1
8000f122:	58 0c       	cp.w	r12,0
8000f124:	e0 8a 00 6f 	brle	8000f202 <__avr32_f64_mul_res_subnormal>
8000f128:	e0 4c 07 ff 	cp.w	r12,2047
8000f12c:	e0 84 00 9c 	brge	8000f264 <__avr32_f64_mul_res_inf>
8000f130:	f7 dc d2 8b 	bfins	r11,r12,0x14,0xb
8000f134:	ed ea 11 f6 	or	r6,r6,r10<<0x1f
8000f138:	ef e6 12 17 	or	r7,r7,r6>>0x1
8000f13c:	ee 17 80 00 	eorh	r7,0x8000
8000f140:	f1 b7 04 20 	satu	r7,0x1
8000f144:	0e 0a       	add	r10,r7
8000f146:	5c 0b       	acr	r11
8000f148:	ed be 00 1f 	bld	lr,0x1f
8000f14c:	ef bb 00 1f 	bst	r11,0x1f
8000f150:	d8 22       	popm	r4-r7,pc

8000f152 <__avr32_f64_mul_op1_subnormal>:
8000f152:	e4 1b 00 0f 	andh	r11,0xf
8000f156:	f4 0c 12 00 	clz	r12,r10
8000f15a:	f6 06 12 00 	clz	r6,r11
8000f15e:	f7 bc 03 e1 	sublo	r12,-31
8000f162:	f8 06 17 30 	movlo	r6,r12
8000f166:	f7 b6 02 01 	subhs	r6,1
8000f16a:	e0 46 00 20 	cp.w	r6,32
8000f16e:	c0 d4       	brge	8000f188 <__avr32_f64_mul_op1_subnormal+0x36>
8000f170:	ec 0c 11 20 	rsub	r12,r6,32
8000f174:	f6 06 09 4b 	lsl	r11,r11,r6
8000f178:	f4 0c 0a 4c 	lsr	r12,r10,r12
8000f17c:	18 4b       	or	r11,r12
8000f17e:	f4 06 09 4a 	lsl	r10,r10,r6
8000f182:	20 b6       	sub	r6,11
8000f184:	0c 17       	sub	r7,r6
8000f186:	ca ab       	rjmp	8000f0da <__avr32_f64_mul+0x22>
8000f188:	f4 06 09 4b 	lsl	r11,r10,r6
8000f18c:	c6 40       	breq	8000f254 <__avr32_f64_mul_res_zero>
8000f18e:	30 0a       	mov	r10,0
8000f190:	20 b6       	sub	r6,11
8000f192:	0c 17       	sub	r7,r6
8000f194:	ca 3b       	rjmp	8000f0da <__avr32_f64_mul+0x22>

8000f196 <__avr32_f64_mul_op2_subnormal>:
8000f196:	e4 19 00 0f 	andh	r9,0xf
8000f19a:	f0 0c 12 00 	clz	r12,r8
8000f19e:	f2 05 12 00 	clz	r5,r9
8000f1a2:	f7 bc 03 ea 	sublo	r12,-22
8000f1a6:	f8 05 17 30 	movlo	r5,r12
8000f1aa:	f7 b5 02 0a 	subhs	r5,10
8000f1ae:	e0 45 00 20 	cp.w	r5,32
8000f1b2:	c0 d4       	brge	8000f1cc <__avr32_f64_mul_op2_subnormal+0x36>
8000f1b4:	ea 0c 11 20 	rsub	r12,r5,32
8000f1b8:	f2 05 09 49 	lsl	r9,r9,r5
8000f1bc:	f0 0c 0a 4c 	lsr	r12,r8,r12
8000f1c0:	18 49       	or	r9,r12
8000f1c2:	f0 05 09 48 	lsl	r8,r8,r5
8000f1c6:	20 25       	sub	r5,2
8000f1c8:	0a 16       	sub	r6,r5
8000f1ca:	c8 fb       	rjmp	8000f0e8 <__avr32_f64_mul+0x30>
8000f1cc:	f0 05 09 49 	lsl	r9,r8,r5
8000f1d0:	c4 20       	breq	8000f254 <__avr32_f64_mul_res_zero>
8000f1d2:	30 08       	mov	r8,0
8000f1d4:	20 25       	sub	r5,2
8000f1d6:	0a 16       	sub	r6,r5
8000f1d8:	c8 8b       	rjmp	8000f0e8 <__avr32_f64_mul+0x30>

8000f1da <__avr32_f64_mul_op_nan_or_inf>:
8000f1da:	e4 19 00 0f 	andh	r9,0xf
8000f1de:	e4 1b 00 0f 	andh	r11,0xf
8000f1e2:	14 4b       	or	r11,r10
8000f1e4:	10 49       	or	r9,r8
8000f1e6:	e0 47 07 ff 	cp.w	r7,2047
8000f1ea:	c0 91       	brne	8000f1fc <__avr32_f64_mul_op1_not_naninf>
8000f1ec:	58 0b       	cp.w	r11,0
8000f1ee:	c3 81       	brne	8000f25e <__avr32_f64_mul_res_nan>
8000f1f0:	e0 46 07 ff 	cp.w	r6,2047
8000f1f4:	c3 81       	brne	8000f264 <__avr32_f64_mul_res_inf>
8000f1f6:	58 09       	cp.w	r9,0
8000f1f8:	c3 60       	breq	8000f264 <__avr32_f64_mul_res_inf>
8000f1fa:	c3 28       	rjmp	8000f25e <__avr32_f64_mul_res_nan>

8000f1fc <__avr32_f64_mul_op1_not_naninf>:
8000f1fc:	58 09       	cp.w	r9,0
8000f1fe:	c3 30       	breq	8000f264 <__avr32_f64_mul_res_inf>
8000f200:	c2 f8       	rjmp	8000f25e <__avr32_f64_mul_res_nan>

8000f202 <__avr32_f64_mul_res_subnormal>:
8000f202:	5c 3c       	neg	r12
8000f204:	2f fc       	sub	r12,-1
8000f206:	f1 bc 04 c0 	satu	r12,0x6
8000f20a:	e0 4c 00 20 	cp.w	r12,32
8000f20e:	c1 14       	brge	8000f230 <__avr32_f64_mul_res_subnormal+0x2e>
8000f210:	f8 08 11 20 	rsub	r8,r12,32
8000f214:	0e 46       	or	r6,r7
8000f216:	ee 0c 0a 47 	lsr	r7,r7,r12
8000f21a:	f4 08 09 49 	lsl	r9,r10,r8
8000f21e:	12 47       	or	r7,r9
8000f220:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000f224:	f6 08 09 49 	lsl	r9,r11,r8
8000f228:	12 4a       	or	r10,r9
8000f22a:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000f22e:	c8 3b       	rjmp	8000f134 <__avr32_f64_mul+0x7c>
8000f230:	f8 08 11 20 	rsub	r8,r12,32
8000f234:	f9 b9 00 00 	moveq	r9,0
8000f238:	c0 30       	breq	8000f23e <__avr32_f64_mul_res_subnormal+0x3c>
8000f23a:	f6 08 09 49 	lsl	r9,r11,r8
8000f23e:	0e 46       	or	r6,r7
8000f240:	ed ea 10 16 	or	r6,r6,r10<<0x1
8000f244:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000f248:	f3 ea 10 07 	or	r7,r9,r10
8000f24c:	f6 0c 0a 4a 	lsr	r10,r11,r12
8000f250:	30 0b       	mov	r11,0
8000f252:	c7 1b       	rjmp	8000f134 <__avr32_f64_mul+0x7c>

8000f254 <__avr32_f64_mul_res_zero>:
8000f254:	1c 9b       	mov	r11,lr
8000f256:	e6 1b 80 00 	andh	r11,0x8000,COH
8000f25a:	30 0a       	mov	r10,0
8000f25c:	d8 22       	popm	r4-r7,pc

8000f25e <__avr32_f64_mul_res_nan>:
8000f25e:	3f fb       	mov	r11,-1
8000f260:	3f fa       	mov	r10,-1
8000f262:	d8 22       	popm	r4-r7,pc

8000f264 <__avr32_f64_mul_res_inf>:
8000f264:	f0 6b 00 00 	mov	r11,-1048576
8000f268:	ed be 00 1f 	bld	lr,0x1f
8000f26c:	ef bb 00 1f 	bst	r11,0x1f
8000f270:	30 0a       	mov	r10,0
8000f272:	d8 22       	popm	r4-r7,pc

8000f274 <__avr32_f64_mul_op1_zero>:
8000f274:	f7 e9 20 0b 	eor	r11,r11,r9
8000f278:	e6 1b 80 00 	andh	r11,0x8000,COH
8000f27c:	f9 d9 c2 8b 	bfextu	r12,r9,0x14,0xb
8000f280:	e0 4c 07 ff 	cp.w	r12,2047
8000f284:	5e 1c       	retne	r12
8000f286:	3f fa       	mov	r10,-1
8000f288:	3f fb       	mov	r11,-1
8000f28a:	5e fc       	retal	r12

8000f28c <__avr32_f64_sub_from_add>:
8000f28c:	ee 19 80 00 	eorh	r9,0x8000

8000f290 <__avr32_f64_sub>:
8000f290:	f7 e9 20 0c 	eor	r12,r11,r9
8000f294:	e0 86 00 ca 	brmi	8000f428 <__avr32_f64_add_from_sub>
8000f298:	eb cd 40 e0 	pushm	r5-r7,lr
8000f29c:	16 9c       	mov	r12,r11
8000f29e:	e6 1c 80 00 	andh	r12,0x8000,COH
8000f2a2:	bf db       	cbr	r11,0x1f
8000f2a4:	bf d9       	cbr	r9,0x1f
8000f2a6:	10 3a       	cp.w	r10,r8
8000f2a8:	f2 0b 13 00 	cpc	r11,r9
8000f2ac:	c0 92       	brcc	8000f2be <__avr32_f64_sub+0x2e>
8000f2ae:	16 97       	mov	r7,r11
8000f2b0:	12 9b       	mov	r11,r9
8000f2b2:	0e 99       	mov	r9,r7
8000f2b4:	14 97       	mov	r7,r10
8000f2b6:	10 9a       	mov	r10,r8
8000f2b8:	0e 98       	mov	r8,r7
8000f2ba:	ee 1c 80 00 	eorh	r12,0x8000
8000f2be:	f6 07 16 14 	lsr	r7,r11,0x14
8000f2c2:	ab 7b       	lsl	r11,0xb
8000f2c4:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000f2c8:	ab 7a       	lsl	r10,0xb
8000f2ca:	bf bb       	sbr	r11,0x1f
8000f2cc:	f2 06 16 14 	lsr	r6,r9,0x14
8000f2d0:	c4 40       	breq	8000f358 <__avr32_f64_sub_opL_subnormal>
8000f2d2:	ab 79       	lsl	r9,0xb
8000f2d4:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000f2d8:	ab 78       	lsl	r8,0xb
8000f2da:	bf b9       	sbr	r9,0x1f

8000f2dc <__avr32_f64_sub_opL_subnormal_done>:
8000f2dc:	e0 47 07 ff 	cp.w	r7,2047
8000f2e0:	c4 f0       	breq	8000f37e <__avr32_f64_sub_opH_nan_or_inf>
8000f2e2:	0e 26       	rsub	r6,r7
8000f2e4:	c1 20       	breq	8000f308 <__avr32_f64_sub_shift_done>
8000f2e6:	ec 05 11 20 	rsub	r5,r6,32
8000f2ea:	e0 46 00 20 	cp.w	r6,32
8000f2ee:	c7 c2       	brcc	8000f3e6 <__avr32_f64_sub_longshift>
8000f2f0:	f0 05 09 4e 	lsl	lr,r8,r5
8000f2f4:	f2 05 09 45 	lsl	r5,r9,r5
8000f2f8:	f0 06 0a 48 	lsr	r8,r8,r6
8000f2fc:	f2 06 0a 49 	lsr	r9,r9,r6
8000f300:	0a 48       	or	r8,r5
8000f302:	58 0e       	cp.w	lr,0
8000f304:	5f 1e       	srne	lr
8000f306:	1c 48       	or	r8,lr

8000f308 <__avr32_f64_sub_shift_done>:
8000f308:	10 1a       	sub	r10,r8
8000f30a:	f6 09 01 4b 	sbc	r11,r11,r9
8000f30e:	f6 06 12 00 	clz	r6,r11
8000f312:	c0 e0       	breq	8000f32e <__avr32_f64_sub_longnormalize_done>
8000f314:	c7 83       	brcs	8000f404 <__avr32_f64_sub_longnormalize>
8000f316:	ec 0e 11 20 	rsub	lr,r6,32
8000f31a:	f6 06 09 4b 	lsl	r11,r11,r6
8000f31e:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000f322:	1c 4b       	or	r11,lr
8000f324:	f4 06 09 4a 	lsl	r10,r10,r6
8000f328:	0c 17       	sub	r7,r6
8000f32a:	e0 8a 00 39 	brle	8000f39c <__avr32_f64_sub_subnormal_result>

8000f32e <__avr32_f64_sub_longnormalize_done>:
8000f32e:	f4 09 15 15 	lsl	r9,r10,0x15
8000f332:	ab 9a       	lsr	r10,0xb
8000f334:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000f338:	ab 9b       	lsr	r11,0xb
8000f33a:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000f33e:	18 4b       	or	r11,r12

8000f340 <__avr32_f64_sub_round>:
8000f340:	fc 17 80 00 	movh	r7,0x8000
8000f344:	ed ba 00 00 	bld	r10,0x0
8000f348:	f7 b7 01 ff 	subne	r7,-1
8000f34c:	0e 39       	cp.w	r9,r7
8000f34e:	5f 29       	srhs	r9
8000f350:	12 0a       	add	r10,r9
8000f352:	5c 0b       	acr	r11
8000f354:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000f358 <__avr32_f64_sub_opL_subnormal>:
8000f358:	ab 79       	lsl	r9,0xb
8000f35a:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000f35e:	ab 78       	lsl	r8,0xb
8000f360:	f3 e8 10 0e 	or	lr,r9,r8
8000f364:	f9 b6 01 01 	movne	r6,1
8000f368:	ee 0e 11 00 	rsub	lr,r7,0
8000f36c:	f9 b7 00 01 	moveq	r7,1
8000f370:	ef bb 00 1f 	bst	r11,0x1f
8000f374:	f7 ea 10 0e 	or	lr,r11,r10
8000f378:	f9 b7 00 00 	moveq	r7,0
8000f37c:	cb 0b       	rjmp	8000f2dc <__avr32_f64_sub_opL_subnormal_done>

8000f37e <__avr32_f64_sub_opH_nan_or_inf>:
8000f37e:	bf db       	cbr	r11,0x1f
8000f380:	f7 ea 10 0e 	or	lr,r11,r10
8000f384:	c0 81       	brne	8000f394 <__avr32_f64_sub_return_nan>
8000f386:	e0 46 07 ff 	cp.w	r6,2047
8000f38a:	c0 50       	breq	8000f394 <__avr32_f64_sub_return_nan>
8000f38c:	f9 e7 11 4b 	or	r11,r12,r7<<0x14
8000f390:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000f394 <__avr32_f64_sub_return_nan>:
8000f394:	3f fa       	mov	r10,-1
8000f396:	3f fb       	mov	r11,-1
8000f398:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000f39c <__avr32_f64_sub_subnormal_result>:
8000f39c:	5c 37       	neg	r7
8000f39e:	2f f7       	sub	r7,-1
8000f3a0:	f1 b7 04 c0 	satu	r7,0x6
8000f3a4:	e0 47 00 20 	cp.w	r7,32
8000f3a8:	c1 14       	brge	8000f3ca <__avr32_f64_sub_subnormal_result+0x2e>
8000f3aa:	ee 08 11 20 	rsub	r8,r7,32
8000f3ae:	f4 08 09 49 	lsl	r9,r10,r8
8000f3b2:	5f 16       	srne	r6
8000f3b4:	f4 07 0a 4a 	lsr	r10,r10,r7
8000f3b8:	0c 4a       	or	r10,r6
8000f3ba:	f6 08 09 49 	lsl	r9,r11,r8
8000f3be:	f5 e9 10 0a 	or	r10,r10,r9
8000f3c2:	f4 07 0a 4b 	lsr	r11,r10,r7
8000f3c6:	30 07       	mov	r7,0
8000f3c8:	cb 3b       	rjmp	8000f32e <__avr32_f64_sub_longnormalize_done>
8000f3ca:	ee 08 11 40 	rsub	r8,r7,64
8000f3ce:	f6 08 09 49 	lsl	r9,r11,r8
8000f3d2:	14 49       	or	r9,r10
8000f3d4:	5f 16       	srne	r6
8000f3d6:	f6 07 0a 4a 	lsr	r10,r11,r7
8000f3da:	0c 4a       	or	r10,r6
8000f3dc:	30 0b       	mov	r11,0
8000f3de:	30 07       	mov	r7,0
8000f3e0:	ca 7b       	rjmp	8000f32e <__avr32_f64_sub_longnormalize_done>
8000f3e2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000f3e6 <__avr32_f64_sub_longshift>:
8000f3e6:	f1 b6 04 c0 	satu	r6,0x6
8000f3ea:	f0 0e 17 00 	moveq	lr,r8
8000f3ee:	c0 40       	breq	8000f3f6 <__avr32_f64_sub_longshift+0x10>
8000f3f0:	f2 05 09 4e 	lsl	lr,r9,r5
8000f3f4:	10 4e       	or	lr,r8
8000f3f6:	f2 06 0a 48 	lsr	r8,r9,r6
8000f3fa:	30 09       	mov	r9,0
8000f3fc:	58 0e       	cp.w	lr,0
8000f3fe:	5f 1e       	srne	lr
8000f400:	1c 48       	or	r8,lr
8000f402:	c8 3b       	rjmp	8000f308 <__avr32_f64_sub_shift_done>

8000f404 <__avr32_f64_sub_longnormalize>:
8000f404:	f4 06 12 00 	clz	r6,r10
8000f408:	f9 b7 03 00 	movlo	r7,0
8000f40c:	f9 b6 03 00 	movlo	r6,0
8000f410:	f9 bc 03 00 	movlo	r12,0
8000f414:	f7 b6 02 e0 	subhs	r6,-32
8000f418:	f4 06 09 4b 	lsl	r11,r10,r6
8000f41c:	30 0a       	mov	r10,0
8000f41e:	0c 17       	sub	r7,r6
8000f420:	fe 9a ff be 	brle	8000f39c <__avr32_f64_sub_subnormal_result>
8000f424:	c8 5b       	rjmp	8000f32e <__avr32_f64_sub_longnormalize_done>
8000f426:	d7 03       	nop

8000f428 <__avr32_f64_add_from_sub>:
8000f428:	ee 19 80 00 	eorh	r9,0x8000

8000f42c <__avr32_f64_add>:
8000f42c:	f7 e9 20 0c 	eor	r12,r11,r9
8000f430:	fe 96 ff 2e 	brmi	8000f28c <__avr32_f64_sub_from_add>
8000f434:	eb cd 40 e0 	pushm	r5-r7,lr
8000f438:	16 9c       	mov	r12,r11
8000f43a:	e6 1c 80 00 	andh	r12,0x8000,COH
8000f43e:	bf db       	cbr	r11,0x1f
8000f440:	bf d9       	cbr	r9,0x1f
8000f442:	12 3b       	cp.w	r11,r9
8000f444:	c0 72       	brcc	8000f452 <__avr32_f64_add+0x26>
8000f446:	16 97       	mov	r7,r11
8000f448:	12 9b       	mov	r11,r9
8000f44a:	0e 99       	mov	r9,r7
8000f44c:	14 97       	mov	r7,r10
8000f44e:	10 9a       	mov	r10,r8
8000f450:	0e 98       	mov	r8,r7
8000f452:	30 0e       	mov	lr,0
8000f454:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000f458:	f7 db c0 14 	bfextu	r11,r11,0x0,0x14
8000f45c:	b5 ab       	sbr	r11,0x14
8000f45e:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000f462:	c6 20       	breq	8000f526 <__avr32_f64_add_op2_subnormal>
8000f464:	f3 d9 c0 14 	bfextu	r9,r9,0x0,0x14
8000f468:	b5 a9       	sbr	r9,0x14
8000f46a:	e0 47 07 ff 	cp.w	r7,2047
8000f46e:	c2 80       	breq	8000f4be <__avr32_f64_add_opH_nan_or_inf>
8000f470:	0e 26       	rsub	r6,r7
8000f472:	c1 20       	breq	8000f496 <__avr32_f64_add_shift_done>
8000f474:	e0 46 00 36 	cp.w	r6,54
8000f478:	c1 52       	brcc	8000f4a2 <__avr32_f64_add_res_of_done>
8000f47a:	ec 05 11 20 	rsub	r5,r6,32
8000f47e:	e0 46 00 20 	cp.w	r6,32
8000f482:	c3 52       	brcc	8000f4ec <__avr32_f64_add_longshift>
8000f484:	f0 05 09 4e 	lsl	lr,r8,r5
8000f488:	f2 05 09 45 	lsl	r5,r9,r5
8000f48c:	f0 06 0a 48 	lsr	r8,r8,r6
8000f490:	f2 06 0a 49 	lsr	r9,r9,r6
8000f494:	0a 48       	or	r8,r5

8000f496 <__avr32_f64_add_shift_done>:
8000f496:	10 0a       	add	r10,r8
8000f498:	f6 09 00 4b 	adc	r11,r11,r9
8000f49c:	ed bb 00 15 	bld	r11,0x15
8000f4a0:	c3 40       	breq	8000f508 <__avr32_f64_add_res_of>

8000f4a2 <__avr32_f64_add_res_of_done>:
8000f4a2:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000f4a6:	18 4b       	or	r11,r12

8000f4a8 <__avr32_f64_add_round>:
8000f4a8:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
8000f4ac:	18 4e       	or	lr,r12
8000f4ae:	ee 1e 80 00 	eorh	lr,0x8000
8000f4b2:	f1 be 04 20 	satu	lr,0x1
8000f4b6:	1c 0a       	add	r10,lr
8000f4b8:	5c 0b       	acr	r11
8000f4ba:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000f4be <__avr32_f64_add_opH_nan_or_inf>:
8000f4be:	b5 cb       	cbr	r11,0x14
8000f4c0:	f7 ea 10 0e 	or	lr,r11,r10
8000f4c4:	c1 01       	brne	8000f4e4 <__avr32_f64_add_return_nan>
8000f4c6:	e0 46 07 ff 	cp.w	r6,2047
8000f4ca:	c0 30       	breq	8000f4d0 <__avr32_f64_add_opL_nan_or_inf>
8000f4cc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000f4d0 <__avr32_f64_add_opL_nan_or_inf>:
8000f4d0:	b5 c9       	cbr	r9,0x14
8000f4d2:	f3 e8 10 0e 	or	lr,r9,r8
8000f4d6:	c0 71       	brne	8000f4e4 <__avr32_f64_add_return_nan>
8000f4d8:	30 0a       	mov	r10,0
8000f4da:	fc 1b 7f f0 	movh	r11,0x7ff0
8000f4de:	18 4b       	or	r11,r12
8000f4e0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000f4e4 <__avr32_f64_add_return_nan>:
8000f4e4:	3f fa       	mov	r10,-1
8000f4e6:	3f fb       	mov	r11,-1
8000f4e8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000f4ec <__avr32_f64_add_longshift>:
8000f4ec:	f1 b6 04 c0 	satu	r6,0x6
8000f4f0:	f0 0e 17 00 	moveq	lr,r8
8000f4f4:	c0 60       	breq	8000f500 <__avr32_f64_add_longshift+0x14>
8000f4f6:	f2 05 09 4e 	lsl	lr,r9,r5
8000f4fa:	58 08       	cp.w	r8,0
8000f4fc:	5f 18       	srne	r8
8000f4fe:	10 4e       	or	lr,r8
8000f500:	f2 06 0a 48 	lsr	r8,r9,r6
8000f504:	30 09       	mov	r9,0
8000f506:	cc 8b       	rjmp	8000f496 <__avr32_f64_add_shift_done>

8000f508 <__avr32_f64_add_res_of>:
8000f508:	fd ee 10 1e 	or	lr,lr,lr<<0x1
8000f50c:	a1 9b       	lsr	r11,0x1
8000f50e:	5d 0a       	ror	r10
8000f510:	5d 0e       	ror	lr
8000f512:	2f f7       	sub	r7,-1
8000f514:	e0 47 07 ff 	cp.w	r7,2047
8000f518:	f9 ba 00 00 	moveq	r10,0
8000f51c:	f9 bb 00 00 	moveq	r11,0
8000f520:	f9 be 00 00 	moveq	lr,0
8000f524:	cb fb       	rjmp	8000f4a2 <__avr32_f64_add_res_of_done>

8000f526 <__avr32_f64_add_op2_subnormal>:
8000f526:	30 16       	mov	r6,1
8000f528:	58 07       	cp.w	r7,0
8000f52a:	ca 01       	brne	8000f46a <__avr32_f64_add+0x3e>
8000f52c:	b5 cb       	cbr	r11,0x14
8000f52e:	10 0a       	add	r10,r8
8000f530:	f6 09 00 4b 	adc	r11,r11,r9
8000f534:	18 4b       	or	r11,r12
8000f536:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000f53a:	d7 03       	nop

8000f53c <__avr32_f64_to_u32>:
8000f53c:	58 0b       	cp.w	r11,0
8000f53e:	5e 6d       	retmi	0

8000f540 <__avr32_f64_to_s32>:
8000f540:	f6 0c 15 01 	lsl	r12,r11,0x1
8000f544:	b5 9c       	lsr	r12,0x15
8000f546:	e0 2c 03 ff 	sub	r12,1023
8000f54a:	5e 3d       	retlo	0
8000f54c:	f8 0c 11 1f 	rsub	r12,r12,31
8000f550:	16 99       	mov	r9,r11
8000f552:	ab 7b       	lsl	r11,0xb
8000f554:	bf bb       	sbr	r11,0x1f
8000f556:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000f55a:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000f55e:	a1 79       	lsl	r9,0x1
8000f560:	5e 2b       	reths	r11
8000f562:	5c 3b       	neg	r11
8000f564:	5e fb       	retal	r11

8000f566 <__avr32_u32_to_f64>:
8000f566:	f8 cb 00 00 	sub	r11,r12,0
8000f56a:	30 0c       	mov	r12,0
8000f56c:	c0 38       	rjmp	8000f572 <__avr32_s32_to_f64+0x4>

8000f56e <__avr32_s32_to_f64>:
8000f56e:	18 9b       	mov	r11,r12
8000f570:	5c 4b       	abs	r11
8000f572:	30 0a       	mov	r10,0
8000f574:	5e 0b       	reteq	r11
8000f576:	d4 01       	pushm	lr
8000f578:	e0 69 04 1e 	mov	r9,1054
8000f57c:	f6 08 12 00 	clz	r8,r11
8000f580:	c1 70       	breq	8000f5ae <__avr32_s32_to_f64+0x40>
8000f582:	c0 c3       	brcs	8000f59a <__avr32_s32_to_f64+0x2c>
8000f584:	f0 0e 11 20 	rsub	lr,r8,32
8000f588:	f6 08 09 4b 	lsl	r11,r11,r8
8000f58c:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000f590:	1c 4b       	or	r11,lr
8000f592:	f4 08 09 4a 	lsl	r10,r10,r8
8000f596:	10 19       	sub	r9,r8
8000f598:	c0 b8       	rjmp	8000f5ae <__avr32_s32_to_f64+0x40>
8000f59a:	f4 08 12 00 	clz	r8,r10
8000f59e:	f9 b8 03 00 	movlo	r8,0
8000f5a2:	f7 b8 02 e0 	subhs	r8,-32
8000f5a6:	f4 08 09 4b 	lsl	r11,r10,r8
8000f5aa:	30 0a       	mov	r10,0
8000f5ac:	10 19       	sub	r9,r8
8000f5ae:	58 09       	cp.w	r9,0
8000f5b0:	e0 89 00 30 	brgt	8000f610 <__avr32_s32_to_f64+0xa2>
8000f5b4:	5c 39       	neg	r9
8000f5b6:	2f f9       	sub	r9,-1
8000f5b8:	e0 49 00 36 	cp.w	r9,54
8000f5bc:	c0 43       	brcs	8000f5c4 <__avr32_s32_to_f64+0x56>
8000f5be:	30 0b       	mov	r11,0
8000f5c0:	30 0a       	mov	r10,0
8000f5c2:	c2 68       	rjmp	8000f60e <__avr32_s32_to_f64+0xa0>
8000f5c4:	2f 69       	sub	r9,-10
8000f5c6:	f2 08 11 20 	rsub	r8,r9,32
8000f5ca:	e0 49 00 20 	cp.w	r9,32
8000f5ce:	c0 b2       	brcc	8000f5e4 <__avr32_s32_to_f64+0x76>
8000f5d0:	f4 08 09 4e 	lsl	lr,r10,r8
8000f5d4:	f6 08 09 48 	lsl	r8,r11,r8
8000f5d8:	f4 09 0a 4a 	lsr	r10,r10,r9
8000f5dc:	f6 09 0a 4b 	lsr	r11,r11,r9
8000f5e0:	10 4b       	or	r11,r8
8000f5e2:	c0 88       	rjmp	8000f5f2 <__avr32_s32_to_f64+0x84>
8000f5e4:	f6 08 09 4e 	lsl	lr,r11,r8
8000f5e8:	14 4e       	or	lr,r10
8000f5ea:	16 9a       	mov	r10,r11
8000f5ec:	30 0b       	mov	r11,0
8000f5ee:	f4 09 0a 4a 	lsr	r10,r10,r9
8000f5f2:	ed ba 00 00 	bld	r10,0x0
8000f5f6:	c0 92       	brcc	8000f608 <__avr32_s32_to_f64+0x9a>
8000f5f8:	1c 7e       	tst	lr,lr
8000f5fa:	c0 41       	brne	8000f602 <__avr32_s32_to_f64+0x94>
8000f5fc:	ed ba 00 01 	bld	r10,0x1
8000f600:	c0 42       	brcc	8000f608 <__avr32_s32_to_f64+0x9a>
8000f602:	2f fa       	sub	r10,-1
8000f604:	f7 bb 02 ff 	subhs	r11,-1
8000f608:	5c fc       	rol	r12
8000f60a:	5d 0b       	ror	r11
8000f60c:	5d 0a       	ror	r10
8000f60e:	d8 02       	popm	pc
8000f610:	e0 68 03 ff 	mov	r8,1023
8000f614:	ed ba 00 0b 	bld	r10,0xb
8000f618:	f7 b8 00 ff 	subeq	r8,-1
8000f61c:	10 0a       	add	r10,r8
8000f61e:	5c 0b       	acr	r11
8000f620:	f7 b9 03 fe 	sublo	r9,-2
8000f624:	e0 49 07 ff 	cp.w	r9,2047
8000f628:	c0 55       	brlt	8000f632 <__avr32_s32_to_f64+0xc4>
8000f62a:	30 0a       	mov	r10,0
8000f62c:	fc 1b ff e0 	movh	r11,0xffe0
8000f630:	c0 c8       	rjmp	8000f648 <__floatsidf_return_op1>
8000f632:	ed bb 00 1f 	bld	r11,0x1f
8000f636:	f7 b9 01 01 	subne	r9,1
8000f63a:	ab 9a       	lsr	r10,0xb
8000f63c:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000f640:	a1 7b       	lsl	r11,0x1
8000f642:	ab 9b       	lsr	r11,0xb
8000f644:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

8000f648 <__floatsidf_return_op1>:
8000f648:	a1 7c       	lsl	r12,0x1
8000f64a:	5d 0b       	ror	r11
8000f64c:	d8 02       	popm	pc

8000f64e <__avr32_f64_cmp_eq>:
8000f64e:	10 3a       	cp.w	r10,r8
8000f650:	f2 0b 13 00 	cpc	r11,r9
8000f654:	c0 80       	breq	8000f664 <__avr32_f64_cmp_eq+0x16>
8000f656:	a1 7b       	lsl	r11,0x1
8000f658:	a1 79       	lsl	r9,0x1
8000f65a:	14 4b       	or	r11,r10
8000f65c:	12 4b       	or	r11,r9
8000f65e:	10 4b       	or	r11,r8
8000f660:	5e 0f       	reteq	1
8000f662:	5e fd       	retal	0
8000f664:	a1 7b       	lsl	r11,0x1
8000f666:	fc 1c ff e0 	movh	r12,0xffe0
8000f66a:	58 0a       	cp.w	r10,0
8000f66c:	f8 0b 13 00 	cpc	r11,r12
8000f670:	5e 8f       	retls	1
8000f672:	5e fd       	retal	0

8000f674 <__avr32_f64_cmp_ge>:
8000f674:	1a de       	st.w	--sp,lr
8000f676:	1a d7       	st.w	--sp,r7
8000f678:	a1 7b       	lsl	r11,0x1
8000f67a:	5f 3c       	srlo	r12
8000f67c:	a1 79       	lsl	r9,0x1
8000f67e:	5f 37       	srlo	r7
8000f680:	5c fc       	rol	r12
8000f682:	fc 1e ff e0 	movh	lr,0xffe0
8000f686:	58 0a       	cp.w	r10,0
8000f688:	fc 0b 13 00 	cpc	r11,lr
8000f68c:	e0 8b 00 1d 	brhi	8000f6c6 <__avr32_f64_cmp_ge+0x52>
8000f690:	58 08       	cp.w	r8,0
8000f692:	fc 09 13 00 	cpc	r9,lr
8000f696:	e0 8b 00 18 	brhi	8000f6c6 <__avr32_f64_cmp_ge+0x52>
8000f69a:	58 0b       	cp.w	r11,0
8000f69c:	f5 ba 00 00 	subfeq	r10,0
8000f6a0:	c1 50       	breq	8000f6ca <__avr32_f64_cmp_ge+0x56>
8000f6a2:	1b 07       	ld.w	r7,sp++
8000f6a4:	1b 0e       	ld.w	lr,sp++
8000f6a6:	58 3c       	cp.w	r12,3
8000f6a8:	c0 a0       	breq	8000f6bc <__avr32_f64_cmp_ge+0x48>
8000f6aa:	58 1c       	cp.w	r12,1
8000f6ac:	c0 33       	brcs	8000f6b2 <__avr32_f64_cmp_ge+0x3e>
8000f6ae:	5e 0f       	reteq	1
8000f6b0:	5e 1d       	retne	0
8000f6b2:	10 3a       	cp.w	r10,r8
8000f6b4:	f2 0b 13 00 	cpc	r11,r9
8000f6b8:	5e 2f       	reths	1
8000f6ba:	5e 3d       	retlo	0
8000f6bc:	14 38       	cp.w	r8,r10
8000f6be:	f6 09 13 00 	cpc	r9,r11
8000f6c2:	5e 2f       	reths	1
8000f6c4:	5e 3d       	retlo	0
8000f6c6:	1b 07       	ld.w	r7,sp++
8000f6c8:	d8 0a       	popm	pc,r12=0
8000f6ca:	58 17       	cp.w	r7,1
8000f6cc:	5f 0c       	sreq	r12
8000f6ce:	58 09       	cp.w	r9,0
8000f6d0:	f5 b8 00 00 	subfeq	r8,0
8000f6d4:	1b 07       	ld.w	r7,sp++
8000f6d6:	1b 0e       	ld.w	lr,sp++
8000f6d8:	5e 0f       	reteq	1
8000f6da:	5e fc       	retal	r12

8000f6dc <__avr32_f64_cmp_lt>:
8000f6dc:	1a de       	st.w	--sp,lr
8000f6de:	1a d7       	st.w	--sp,r7
8000f6e0:	a1 7b       	lsl	r11,0x1
8000f6e2:	5f 3c       	srlo	r12
8000f6e4:	a1 79       	lsl	r9,0x1
8000f6e6:	5f 37       	srlo	r7
8000f6e8:	5c fc       	rol	r12
8000f6ea:	fc 1e ff e0 	movh	lr,0xffe0
8000f6ee:	58 0a       	cp.w	r10,0
8000f6f0:	fc 0b 13 00 	cpc	r11,lr
8000f6f4:	e0 8b 00 1d 	brhi	8000f72e <__avr32_f64_cmp_lt+0x52>
8000f6f8:	58 08       	cp.w	r8,0
8000f6fa:	fc 09 13 00 	cpc	r9,lr
8000f6fe:	e0 8b 00 18 	brhi	8000f72e <__avr32_f64_cmp_lt+0x52>
8000f702:	58 0b       	cp.w	r11,0
8000f704:	f5 ba 00 00 	subfeq	r10,0
8000f708:	c1 50       	breq	8000f732 <__avr32_f64_cmp_lt+0x56>
8000f70a:	1b 07       	ld.w	r7,sp++
8000f70c:	1b 0e       	ld.w	lr,sp++
8000f70e:	58 3c       	cp.w	r12,3
8000f710:	c0 a0       	breq	8000f724 <__avr32_f64_cmp_lt+0x48>
8000f712:	58 1c       	cp.w	r12,1
8000f714:	c0 33       	brcs	8000f71a <__avr32_f64_cmp_lt+0x3e>
8000f716:	5e 0d       	reteq	0
8000f718:	5e 1f       	retne	1
8000f71a:	10 3a       	cp.w	r10,r8
8000f71c:	f2 0b 13 00 	cpc	r11,r9
8000f720:	5e 2d       	reths	0
8000f722:	5e 3f       	retlo	1
8000f724:	14 38       	cp.w	r8,r10
8000f726:	f6 09 13 00 	cpc	r9,r11
8000f72a:	5e 2d       	reths	0
8000f72c:	5e 3f       	retlo	1
8000f72e:	1b 07       	ld.w	r7,sp++
8000f730:	d8 0a       	popm	pc,r12=0
8000f732:	58 17       	cp.w	r7,1
8000f734:	5f 1c       	srne	r12
8000f736:	58 09       	cp.w	r9,0
8000f738:	f5 b8 00 00 	subfeq	r8,0
8000f73c:	1b 07       	ld.w	r7,sp++
8000f73e:	1b 0e       	ld.w	lr,sp++
8000f740:	5e 0d       	reteq	0
8000f742:	5e fc       	retal	r12

8000f744 <__avr32_f64_div>:
8000f744:	eb cd 40 ff 	pushm	r0-r7,lr
8000f748:	f7 e9 20 0e 	eor	lr,r11,r9
8000f74c:	f6 07 16 14 	lsr	r7,r11,0x14
8000f750:	a9 7b       	lsl	r11,0x9
8000f752:	f7 ea 13 7b 	or	r11,r11,r10>>0x17
8000f756:	a9 7a       	lsl	r10,0x9
8000f758:	bd bb       	sbr	r11,0x1d
8000f75a:	e4 1b 3f ff 	andh	r11,0x3fff
8000f75e:	ab d7       	cbr	r7,0xb
8000f760:	e0 80 00 cc 	breq	8000f8f8 <__avr32_f64_div_round_subnormal+0x54>
8000f764:	e0 47 07 ff 	cp.w	r7,2047
8000f768:	e0 84 00 b5 	brge	8000f8d2 <__avr32_f64_div_round_subnormal+0x2e>
8000f76c:	f2 06 16 14 	lsr	r6,r9,0x14
8000f770:	a9 79       	lsl	r9,0x9
8000f772:	f3 e8 13 79 	or	r9,r9,r8>>0x17
8000f776:	a9 78       	lsl	r8,0x9
8000f778:	bd b9       	sbr	r9,0x1d
8000f77a:	e4 19 3f ff 	andh	r9,0x3fff
8000f77e:	ab d6       	cbr	r6,0xb
8000f780:	e0 80 00 e2 	breq	8000f944 <__avr32_f64_div_round_subnormal+0xa0>
8000f784:	e0 46 07 ff 	cp.w	r6,2047
8000f788:	e0 84 00 b2 	brge	8000f8ec <__avr32_f64_div_round_subnormal+0x48>
8000f78c:	0c 17       	sub	r7,r6
8000f78e:	fe 37 fc 01 	sub	r7,-1023
8000f792:	fc 1c 80 00 	movh	r12,0x8000
8000f796:	f8 03 16 01 	lsr	r3,r12,0x1
8000f79a:	e9 d9 c3 62 	bfextu	r4,r9,0x1b,0x2
8000f79e:	5c d4       	com	r4
8000f7a0:	e7 d4 d3 82 	bfins	r3,r4,0x1c,0x2
8000f7a4:	e6 09 06 44 	mulu.d	r4,r3,r9
8000f7a8:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000f7ac:	e6 05 06 44 	mulu.d	r4,r3,r5
8000f7b0:	ea 03 15 02 	lsl	r3,r5,0x2
8000f7b4:	e6 09 06 44 	mulu.d	r4,r3,r9
8000f7b8:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000f7bc:	e6 05 06 44 	mulu.d	r4,r3,r5
8000f7c0:	ea 03 15 02 	lsl	r3,r5,0x2
8000f7c4:	e6 09 06 44 	mulu.d	r4,r3,r9
8000f7c8:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000f7cc:	e6 05 06 44 	mulu.d	r4,r3,r5
8000f7d0:	ea 03 15 02 	lsl	r3,r5,0x2
8000f7d4:	e6 08 06 40 	mulu.d	r0,r3,r8
8000f7d8:	e4 09 07 40 	macu.d	r0,r2,r9
8000f7dc:	e6 09 06 44 	mulu.d	r4,r3,r9
8000f7e0:	02 04       	add	r4,r1
8000f7e2:	5c 05       	acr	r5
8000f7e4:	a3 65       	lsl	r5,0x2
8000f7e6:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000f7ea:	a3 64       	lsl	r4,0x2
8000f7ec:	5c 34       	neg	r4
8000f7ee:	f8 05 01 45 	sbc	r5,r12,r5
8000f7f2:	e6 04 06 40 	mulu.d	r0,r3,r4
8000f7f6:	e4 05 07 40 	macu.d	r0,r2,r5
8000f7fa:	e6 05 06 44 	mulu.d	r4,r3,r5
8000f7fe:	02 04       	add	r4,r1
8000f800:	5c 05       	acr	r5
8000f802:	ea 03 15 02 	lsl	r3,r5,0x2
8000f806:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000f80a:	e8 02 15 02 	lsl	r2,r4,0x2
8000f80e:	e6 08 06 40 	mulu.d	r0,r3,r8
8000f812:	e4 09 07 40 	macu.d	r0,r2,r9
8000f816:	e6 09 06 44 	mulu.d	r4,r3,r9
8000f81a:	02 04       	add	r4,r1
8000f81c:	5c 05       	acr	r5
8000f81e:	a3 65       	lsl	r5,0x2
8000f820:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000f824:	a3 64       	lsl	r4,0x2
8000f826:	5c 34       	neg	r4
8000f828:	f8 05 01 45 	sbc	r5,r12,r5
8000f82c:	e6 04 06 40 	mulu.d	r0,r3,r4
8000f830:	e4 05 07 40 	macu.d	r0,r2,r5
8000f834:	e6 05 06 44 	mulu.d	r4,r3,r5
8000f838:	02 04       	add	r4,r1
8000f83a:	5c 05       	acr	r5
8000f83c:	ea 03 15 02 	lsl	r3,r5,0x2
8000f840:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000f844:	e8 02 15 02 	lsl	r2,r4,0x2
8000f848:	e6 0a 06 40 	mulu.d	r0,r3,r10
8000f84c:	e4 0b 07 40 	macu.d	r0,r2,r11
8000f850:	e6 0b 06 42 	mulu.d	r2,r3,r11
8000f854:	02 02       	add	r2,r1
8000f856:	5c 03       	acr	r3
8000f858:	ed b3 00 1c 	bld	r3,0x1c
8000f85c:	c0 90       	breq	8000f86e <__avr32_f64_div+0x12a>
8000f85e:	a1 72       	lsl	r2,0x1
8000f860:	5c f3       	rol	r3
8000f862:	20 17       	sub	r7,1
8000f864:	a3 9a       	lsr	r10,0x3
8000f866:	f5 eb 11 da 	or	r10,r10,r11<<0x1d
8000f86a:	a3 9b       	lsr	r11,0x3
8000f86c:	c0 58       	rjmp	8000f876 <__avr32_f64_div+0x132>
8000f86e:	a5 8a       	lsr	r10,0x4
8000f870:	f5 eb 11 ca 	or	r10,r10,r11<<0x1c
8000f874:	a5 8b       	lsr	r11,0x4
8000f876:	58 07       	cp.w	r7,0
8000f878:	e0 8a 00 8b 	brle	8000f98e <__avr32_f64_div_res_subnormal>
8000f87c:	e0 12 ff 00 	andl	r2,0xff00
8000f880:	e8 12 00 80 	orl	r2,0x80
8000f884:	e6 08 06 40 	mulu.d	r0,r3,r8
8000f888:	e4 09 07 40 	macu.d	r0,r2,r9
8000f88c:	e4 08 06 44 	mulu.d	r4,r2,r8
8000f890:	e6 09 06 48 	mulu.d	r8,r3,r9
8000f894:	00 05       	add	r5,r0
8000f896:	f0 01 00 48 	adc	r8,r8,r1
8000f89a:	5c 09       	acr	r9
8000f89c:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000f8a0:	58 04       	cp.w	r4,0
8000f8a2:	5c 25       	cpc	r5

8000f8a4 <__avr32_f64_div_round_subnormal>:
8000f8a4:	f4 08 13 00 	cpc	r8,r10
8000f8a8:	f6 09 13 00 	cpc	r9,r11
8000f8ac:	5f 36       	srlo	r6
8000f8ae:	f8 06 17 00 	moveq	r6,r12
8000f8b2:	e4 0a 16 08 	lsr	r10,r2,0x8
8000f8b6:	f5 e3 11 8a 	or	r10,r10,r3<<0x18
8000f8ba:	e6 0b 16 08 	lsr	r11,r3,0x8
8000f8be:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000f8c2:	ed be 00 1f 	bld	lr,0x1f
8000f8c6:	ef bb 00 1f 	bst	r11,0x1f
8000f8ca:	0c 0a       	add	r10,r6
8000f8cc:	5c 0b       	acr	r11
8000f8ce:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000f8d2:	e4 1b 00 0f 	andh	r11,0xf
8000f8d6:	14 4b       	or	r11,r10
8000f8d8:	e0 81 00 a7 	brne	8000fa26 <__avr32_f64_div_res_subnormal+0x98>
8000f8dc:	f2 06 16 14 	lsr	r6,r9,0x14
8000f8e0:	ab d6       	cbr	r6,0xb
8000f8e2:	e0 46 07 ff 	cp.w	r6,2047
8000f8e6:	e0 81 00 a4 	brne	8000fa2e <__avr32_f64_div_res_subnormal+0xa0>
8000f8ea:	c9 e8       	rjmp	8000fa26 <__avr32_f64_div_res_subnormal+0x98>
8000f8ec:	e4 19 00 0f 	andh	r9,0xf
8000f8f0:	10 49       	or	r9,r8
8000f8f2:	e0 81 00 9a 	brne	8000fa26 <__avr32_f64_div_res_subnormal+0x98>
8000f8f6:	c9 28       	rjmp	8000fa1a <__avr32_f64_div_res_subnormal+0x8c>
8000f8f8:	a3 7b       	lsl	r11,0x3
8000f8fa:	f7 ea 13 db 	or	r11,r11,r10>>0x1d
8000f8fe:	a3 7a       	lsl	r10,0x3
8000f900:	f5 eb 10 04 	or	r4,r10,r11
8000f904:	e0 80 00 a0 	breq	8000fa44 <__avr32_f64_div_op1_zero>
8000f908:	f6 04 12 00 	clz	r4,r11
8000f90c:	c1 70       	breq	8000f93a <__avr32_f64_div_round_subnormal+0x96>
8000f90e:	c0 c3       	brcs	8000f926 <__avr32_f64_div_round_subnormal+0x82>
8000f910:	e8 05 11 20 	rsub	r5,r4,32
8000f914:	f6 04 09 4b 	lsl	r11,r11,r4
8000f918:	f4 05 0a 45 	lsr	r5,r10,r5
8000f91c:	0a 4b       	or	r11,r5
8000f91e:	f4 04 09 4a 	lsl	r10,r10,r4
8000f922:	08 17       	sub	r7,r4
8000f924:	c0 b8       	rjmp	8000f93a <__avr32_f64_div_round_subnormal+0x96>
8000f926:	f4 04 12 00 	clz	r4,r10
8000f92a:	f9 b4 03 00 	movlo	r4,0
8000f92e:	f7 b4 02 e0 	subhs	r4,-32
8000f932:	f4 04 09 4b 	lsl	r11,r10,r4
8000f936:	30 0a       	mov	r10,0
8000f938:	08 17       	sub	r7,r4
8000f93a:	a3 8a       	lsr	r10,0x2
8000f93c:	f5 eb 11 ea 	or	r10,r10,r11<<0x1e
8000f940:	a3 8b       	lsr	r11,0x2
8000f942:	c1 1b       	rjmp	8000f764 <__avr32_f64_div+0x20>
8000f944:	a3 79       	lsl	r9,0x3
8000f946:	f3 e8 13 d9 	or	r9,r9,r8>>0x1d
8000f94a:	a3 78       	lsl	r8,0x3
8000f94c:	f3 e8 10 04 	or	r4,r9,r8
8000f950:	c6 f0       	breq	8000fa2e <__avr32_f64_div_res_subnormal+0xa0>
8000f952:	f2 04 12 00 	clz	r4,r9
8000f956:	c1 70       	breq	8000f984 <__avr32_f64_div_round_subnormal+0xe0>
8000f958:	c0 c3       	brcs	8000f970 <__avr32_f64_div_round_subnormal+0xcc>
8000f95a:	e8 05 11 20 	rsub	r5,r4,32
8000f95e:	f2 04 09 49 	lsl	r9,r9,r4
8000f962:	f0 05 0a 45 	lsr	r5,r8,r5
8000f966:	0a 49       	or	r9,r5
8000f968:	f0 04 09 48 	lsl	r8,r8,r4
8000f96c:	08 16       	sub	r6,r4
8000f96e:	c0 b8       	rjmp	8000f984 <__avr32_f64_div_round_subnormal+0xe0>
8000f970:	f0 04 12 00 	clz	r4,r8
8000f974:	f9 b4 03 00 	movlo	r4,0
8000f978:	f7 b4 02 e0 	subhs	r4,-32
8000f97c:	f0 04 09 49 	lsl	r9,r8,r4
8000f980:	30 08       	mov	r8,0
8000f982:	08 16       	sub	r6,r4
8000f984:	a3 88       	lsr	r8,0x2
8000f986:	f1 e9 11 e8 	or	r8,r8,r9<<0x1e
8000f98a:	a3 89       	lsr	r9,0x2
8000f98c:	cf ca       	rjmp	8000f784 <__avr32_f64_div+0x40>

8000f98e <__avr32_f64_div_res_subnormal>:
8000f98e:	5c 37       	neg	r7
8000f990:	2f f7       	sub	r7,-1
8000f992:	f1 b7 04 c0 	satu	r7,0x6
8000f996:	e0 47 00 20 	cp.w	r7,32
8000f99a:	c1 54       	brge	8000f9c4 <__avr32_f64_div_res_subnormal+0x36>
8000f99c:	ee 06 11 20 	rsub	r6,r7,32
8000f9a0:	e4 07 0a 42 	lsr	r2,r2,r7
8000f9a4:	e6 06 09 4c 	lsl	r12,r3,r6
8000f9a8:	18 42       	or	r2,r12
8000f9aa:	e6 07 0a 43 	lsr	r3,r3,r7
8000f9ae:	f4 06 09 41 	lsl	r1,r10,r6
8000f9b2:	f4 07 0a 4a 	lsr	r10,r10,r7
8000f9b6:	f6 06 09 4c 	lsl	r12,r11,r6
8000f9ba:	18 4a       	or	r10,r12
8000f9bc:	f6 07 0a 4b 	lsr	r11,r11,r7
8000f9c0:	30 00       	mov	r0,0
8000f9c2:	c1 58       	rjmp	8000f9ec <__avr32_f64_div_res_subnormal+0x5e>
8000f9c4:	ee 06 11 20 	rsub	r6,r7,32
8000f9c8:	f9 b0 00 00 	moveq	r0,0
8000f9cc:	f9 bc 00 00 	moveq	r12,0
8000f9d0:	c0 50       	breq	8000f9da <__avr32_f64_div_res_subnormal+0x4c>
8000f9d2:	f4 06 09 40 	lsl	r0,r10,r6
8000f9d6:	f6 06 09 4c 	lsl	r12,r11,r6
8000f9da:	e6 07 0a 42 	lsr	r2,r3,r7
8000f9de:	30 03       	mov	r3,0
8000f9e0:	f4 07 0a 41 	lsr	r1,r10,r7
8000f9e4:	18 41       	or	r1,r12
8000f9e6:	f6 07 0a 4a 	lsr	r10,r11,r7
8000f9ea:	30 0b       	mov	r11,0
8000f9ec:	e0 12 ff 00 	andl	r2,0xff00
8000f9f0:	e8 12 00 80 	orl	r2,0x80
8000f9f4:	e6 08 06 46 	mulu.d	r6,r3,r8
8000f9f8:	e4 09 07 46 	macu.d	r6,r2,r9
8000f9fc:	e4 08 06 44 	mulu.d	r4,r2,r8
8000fa00:	e6 09 06 48 	mulu.d	r8,r3,r9
8000fa04:	0c 05       	add	r5,r6
8000fa06:	f0 07 00 48 	adc	r8,r8,r7
8000fa0a:	5c 09       	acr	r9
8000fa0c:	30 07       	mov	r7,0
8000fa0e:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000fa12:	00 34       	cp.w	r4,r0
8000fa14:	e2 05 13 00 	cpc	r5,r1
8000fa18:	c4 6b       	rjmp	8000f8a4 <__avr32_f64_div_round_subnormal>
8000fa1a:	1c 9b       	mov	r11,lr
8000fa1c:	e6 1b 80 00 	andh	r11,0x8000,COH
8000fa20:	30 0a       	mov	r10,0
8000fa22:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000fa26:	3f fb       	mov	r11,-1
8000fa28:	30 0a       	mov	r10,0
8000fa2a:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000fa2e:	f5 eb 10 04 	or	r4,r10,r11
8000fa32:	c0 90       	breq	8000fa44 <__avr32_f64_div_op1_zero>
8000fa34:	1c 9b       	mov	r11,lr
8000fa36:	e6 1b 80 00 	andh	r11,0x8000,COH
8000fa3a:	ea 1b 7f f0 	orh	r11,0x7ff0
8000fa3e:	30 0a       	mov	r10,0
8000fa40:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc

8000fa44 <__avr32_f64_div_op1_zero>:
8000fa44:	f1 e9 10 15 	or	r5,r8,r9<<0x1
8000fa48:	ce f0       	breq	8000fa26 <__avr32_f64_div_res_subnormal+0x98>
8000fa4a:	e9 d9 c2 8b 	bfextu	r4,r9,0x14,0xb
8000fa4e:	e0 44 07 ff 	cp.w	r4,2047
8000fa52:	ce 41       	brne	8000fa1a <__avr32_f64_div_res_subnormal+0x8c>
8000fa54:	f1 e9 10 c5 	or	r5,r8,r9<<0xc
8000fa58:	ce 10       	breq	8000fa1a <__avr32_f64_div_res_subnormal+0x8c>
8000fa5a:	ce 6b       	rjmp	8000fa26 <__avr32_f64_div_res_subnormal+0x98>

8000fa5c <__avr32_udiv64>:
8000fa5c:	d4 31       	pushm	r0-r7,lr
8000fa5e:	1a 97       	mov	r7,sp
8000fa60:	20 3d       	sub	sp,12
8000fa62:	10 9c       	mov	r12,r8
8000fa64:	12 9e       	mov	lr,r9
8000fa66:	14 93       	mov	r3,r10
8000fa68:	58 09       	cp.w	r9,0
8000fa6a:	e0 81 00 bd 	brne	8000fbe4 <__avr32_udiv64+0x188>
8000fa6e:	16 38       	cp.w	r8,r11
8000fa70:	e0 88 00 40 	brls	8000faf0 <__avr32_udiv64+0x94>
8000fa74:	f0 08 12 00 	clz	r8,r8
8000fa78:	c0 d0       	breq	8000fa92 <__avr32_udiv64+0x36>
8000fa7a:	f6 08 09 4b 	lsl	r11,r11,r8
8000fa7e:	f0 09 11 20 	rsub	r9,r8,32
8000fa82:	f8 08 09 4c 	lsl	r12,r12,r8
8000fa86:	f4 09 0a 49 	lsr	r9,r10,r9
8000fa8a:	f4 08 09 43 	lsl	r3,r10,r8
8000fa8e:	f3 eb 10 0b 	or	r11,r9,r11
8000fa92:	f8 0e 16 10 	lsr	lr,r12,0x10
8000fa96:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000fa9a:	f6 0e 0d 00 	divu	r0,r11,lr
8000fa9e:	e6 0b 16 10 	lsr	r11,r3,0x10
8000faa2:	00 99       	mov	r9,r0
8000faa4:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000faa8:	e0 0a 02 48 	mul	r8,r0,r10
8000faac:	10 3b       	cp.w	r11,r8
8000faae:	c0 a2       	brcc	8000fac2 <__avr32_udiv64+0x66>
8000fab0:	20 19       	sub	r9,1
8000fab2:	18 0b       	add	r11,r12
8000fab4:	18 3b       	cp.w	r11,r12
8000fab6:	c0 63       	brcs	8000fac2 <__avr32_udiv64+0x66>
8000fab8:	10 3b       	cp.w	r11,r8
8000faba:	f7 b9 03 01 	sublo	r9,1
8000fabe:	f7 dc e3 0b 	addcs	r11,r11,r12
8000fac2:	f6 08 01 01 	sub	r1,r11,r8
8000fac6:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000faca:	e2 0e 0d 00 	divu	r0,r1,lr
8000face:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000fad2:	00 98       	mov	r8,r0
8000fad4:	e0 0a 02 4a 	mul	r10,r0,r10
8000fad8:	14 33       	cp.w	r3,r10
8000fada:	c0 82       	brcc	8000faea <__avr32_udiv64+0x8e>
8000fadc:	20 18       	sub	r8,1
8000fade:	18 03       	add	r3,r12
8000fae0:	18 33       	cp.w	r3,r12
8000fae2:	c0 43       	brcs	8000faea <__avr32_udiv64+0x8e>
8000fae4:	14 33       	cp.w	r3,r10
8000fae6:	f7 b8 03 01 	sublo	r8,1
8000faea:	f1 e9 11 08 	or	r8,r8,r9<<0x10
8000faee:	cd f8       	rjmp	8000fcac <__avr32_udiv64+0x250>
8000faf0:	58 08       	cp.w	r8,0
8000faf2:	c0 51       	brne	8000fafc <__avr32_udiv64+0xa0>
8000faf4:	30 19       	mov	r9,1
8000faf6:	f2 08 0d 08 	divu	r8,r9,r8
8000fafa:	10 9c       	mov	r12,r8
8000fafc:	f8 06 12 00 	clz	r6,r12
8000fb00:	c0 41       	brne	8000fb08 <__avr32_udiv64+0xac>
8000fb02:	18 1b       	sub	r11,r12
8000fb04:	30 19       	mov	r9,1
8000fb06:	c4 08       	rjmp	8000fb86 <__avr32_udiv64+0x12a>
8000fb08:	ec 01 11 20 	rsub	r1,r6,32
8000fb0c:	f4 01 0a 49 	lsr	r9,r10,r1
8000fb10:	f8 06 09 4c 	lsl	r12,r12,r6
8000fb14:	f6 06 09 48 	lsl	r8,r11,r6
8000fb18:	f6 01 0a 41 	lsr	r1,r11,r1
8000fb1c:	f3 e8 10 08 	or	r8,r9,r8
8000fb20:	f8 03 16 10 	lsr	r3,r12,0x10
8000fb24:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000fb28:	e2 03 0d 00 	divu	r0,r1,r3
8000fb2c:	f0 0b 16 10 	lsr	r11,r8,0x10
8000fb30:	00 9e       	mov	lr,r0
8000fb32:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000fb36:	e0 05 02 49 	mul	r9,r0,r5
8000fb3a:	12 3b       	cp.w	r11,r9
8000fb3c:	c0 a2       	brcc	8000fb50 <__avr32_udiv64+0xf4>
8000fb3e:	20 1e       	sub	lr,1
8000fb40:	18 0b       	add	r11,r12
8000fb42:	18 3b       	cp.w	r11,r12
8000fb44:	c0 63       	brcs	8000fb50 <__avr32_udiv64+0xf4>
8000fb46:	12 3b       	cp.w	r11,r9
8000fb48:	f7 be 03 01 	sublo	lr,1
8000fb4c:	f7 dc e3 0b 	addcs	r11,r11,r12
8000fb50:	12 1b       	sub	r11,r9
8000fb52:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
8000fb56:	f6 03 0d 02 	divu	r2,r11,r3
8000fb5a:	f1 e3 11 08 	or	r8,r8,r3<<0x10
8000fb5e:	04 99       	mov	r9,r2
8000fb60:	e4 05 02 4b 	mul	r11,r2,r5
8000fb64:	16 38       	cp.w	r8,r11
8000fb66:	c0 a2       	brcc	8000fb7a <__avr32_udiv64+0x11e>
8000fb68:	20 19       	sub	r9,1
8000fb6a:	18 08       	add	r8,r12
8000fb6c:	18 38       	cp.w	r8,r12
8000fb6e:	c0 63       	brcs	8000fb7a <__avr32_udiv64+0x11e>
8000fb70:	16 38       	cp.w	r8,r11
8000fb72:	f7 b9 03 01 	sublo	r9,1
8000fb76:	f1 dc e3 08 	addcs	r8,r8,r12
8000fb7a:	f4 06 09 43 	lsl	r3,r10,r6
8000fb7e:	f0 0b 01 0b 	sub	r11,r8,r11
8000fb82:	f3 ee 11 09 	or	r9,r9,lr<<0x10
8000fb86:	f8 06 16 10 	lsr	r6,r12,0x10
8000fb8a:	fd dc c0 10 	bfextu	lr,r12,0x0,0x10
8000fb8e:	f6 06 0d 00 	divu	r0,r11,r6
8000fb92:	e6 0b 16 10 	lsr	r11,r3,0x10
8000fb96:	00 9a       	mov	r10,r0
8000fb98:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000fb9c:	e0 0e 02 48 	mul	r8,r0,lr
8000fba0:	10 3b       	cp.w	r11,r8
8000fba2:	c0 a2       	brcc	8000fbb6 <__avr32_udiv64+0x15a>
8000fba4:	20 1a       	sub	r10,1
8000fba6:	18 0b       	add	r11,r12
8000fba8:	18 3b       	cp.w	r11,r12
8000fbaa:	c0 63       	brcs	8000fbb6 <__avr32_udiv64+0x15a>
8000fbac:	10 3b       	cp.w	r11,r8
8000fbae:	f7 ba 03 01 	sublo	r10,1
8000fbb2:	f7 dc e3 0b 	addcs	r11,r11,r12
8000fbb6:	f6 08 01 01 	sub	r1,r11,r8
8000fbba:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000fbbe:	e2 06 0d 00 	divu	r0,r1,r6
8000fbc2:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000fbc6:	00 98       	mov	r8,r0
8000fbc8:	e0 0e 02 4b 	mul	r11,r0,lr
8000fbcc:	16 33       	cp.w	r3,r11
8000fbce:	c0 82       	brcc	8000fbde <__avr32_udiv64+0x182>
8000fbd0:	20 18       	sub	r8,1
8000fbd2:	18 03       	add	r3,r12
8000fbd4:	18 33       	cp.w	r3,r12
8000fbd6:	c0 43       	brcs	8000fbde <__avr32_udiv64+0x182>
8000fbd8:	16 33       	cp.w	r3,r11
8000fbda:	f7 b8 03 01 	sublo	r8,1
8000fbde:	f1 ea 11 08 	or	r8,r8,r10<<0x10
8000fbe2:	c6 98       	rjmp	8000fcb4 <__avr32_udiv64+0x258>
8000fbe4:	16 39       	cp.w	r9,r11
8000fbe6:	e0 8b 00 65 	brhi	8000fcb0 <__avr32_udiv64+0x254>
8000fbea:	f2 09 12 00 	clz	r9,r9
8000fbee:	c0 b1       	brne	8000fc04 <__avr32_udiv64+0x1a8>
8000fbf0:	10 3a       	cp.w	r10,r8
8000fbf2:	5f 2a       	srhs	r10
8000fbf4:	1c 3b       	cp.w	r11,lr
8000fbf6:	5f b8       	srhi	r8
8000fbf8:	10 4a       	or	r10,r8
8000fbfa:	f2 0a 18 00 	cp.b	r10,r9
8000fbfe:	c5 90       	breq	8000fcb0 <__avr32_udiv64+0x254>
8000fc00:	30 18       	mov	r8,1
8000fc02:	c5 98       	rjmp	8000fcb4 <__avr32_udiv64+0x258>
8000fc04:	f0 09 09 46 	lsl	r6,r8,r9
8000fc08:	f2 03 11 20 	rsub	r3,r9,32
8000fc0c:	fc 09 09 4e 	lsl	lr,lr,r9
8000fc10:	f0 03 0a 48 	lsr	r8,r8,r3
8000fc14:	f6 09 09 4c 	lsl	r12,r11,r9
8000fc18:	f4 03 0a 42 	lsr	r2,r10,r3
8000fc1c:	ef 46 ff f4 	st.w	r7[-12],r6
8000fc20:	f6 03 0a 43 	lsr	r3,r11,r3
8000fc24:	18 42       	or	r2,r12
8000fc26:	f1 ee 10 0c 	or	r12,r8,lr
8000fc2a:	f8 01 16 10 	lsr	r1,r12,0x10
8000fc2e:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000fc32:	e6 01 0d 04 	divu	r4,r3,r1
8000fc36:	e4 03 16 10 	lsr	r3,r2,0x10
8000fc3a:	08 9e       	mov	lr,r4
8000fc3c:	e7 e5 11 03 	or	r3,r3,r5<<0x10
8000fc40:	e8 06 02 48 	mul	r8,r4,r6
8000fc44:	10 33       	cp.w	r3,r8
8000fc46:	c0 a2       	brcc	8000fc5a <__avr32_udiv64+0x1fe>
8000fc48:	20 1e       	sub	lr,1
8000fc4a:	18 03       	add	r3,r12
8000fc4c:	18 33       	cp.w	r3,r12
8000fc4e:	c0 63       	brcs	8000fc5a <__avr32_udiv64+0x1fe>
8000fc50:	10 33       	cp.w	r3,r8
8000fc52:	f7 be 03 01 	sublo	lr,1
8000fc56:	e7 dc e3 03 	addcs	r3,r3,r12
8000fc5a:	10 13       	sub	r3,r8
8000fc5c:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
8000fc60:	e6 01 0d 00 	divu	r0,r3,r1
8000fc64:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000fc68:	00 98       	mov	r8,r0
8000fc6a:	e0 06 02 46 	mul	r6,r0,r6
8000fc6e:	0c 3b       	cp.w	r11,r6
8000fc70:	c0 a2       	brcc	8000fc84 <__avr32_udiv64+0x228>
8000fc72:	20 18       	sub	r8,1
8000fc74:	18 0b       	add	r11,r12
8000fc76:	18 3b       	cp.w	r11,r12
8000fc78:	c0 63       	brcs	8000fc84 <__avr32_udiv64+0x228>
8000fc7a:	0c 3b       	cp.w	r11,r6
8000fc7c:	f7 dc e3 0b 	addcs	r11,r11,r12
8000fc80:	f7 b8 03 01 	sublo	r8,1
8000fc84:	f1 ee 11 08 	or	r8,r8,lr<<0x10
8000fc88:	ee f4 ff f4 	ld.w	r4,r7[-12]
8000fc8c:	0c 1b       	sub	r11,r6
8000fc8e:	f0 04 06 42 	mulu.d	r2,r8,r4
8000fc92:	06 95       	mov	r5,r3
8000fc94:	16 35       	cp.w	r5,r11
8000fc96:	e0 8b 00 0a 	brhi	8000fcaa <__avr32_udiv64+0x24e>
8000fc9a:	5f 0b       	sreq	r11
8000fc9c:	f4 09 09 49 	lsl	r9,r10,r9
8000fca0:	12 32       	cp.w	r2,r9
8000fca2:	5f b9       	srhi	r9
8000fca4:	f7 e9 00 09 	and	r9,r11,r9
8000fca8:	c0 60       	breq	8000fcb4 <__avr32_udiv64+0x258>
8000fcaa:	20 18       	sub	r8,1
8000fcac:	30 09       	mov	r9,0
8000fcae:	c0 38       	rjmp	8000fcb4 <__avr32_udiv64+0x258>
8000fcb0:	30 09       	mov	r9,0
8000fcb2:	12 98       	mov	r8,r9
8000fcb4:	10 9a       	mov	r10,r8
8000fcb6:	12 93       	mov	r3,r9
8000fcb8:	10 92       	mov	r2,r8
8000fcba:	12 9b       	mov	r11,r9
8000fcbc:	2f dd       	sub	sp,-12
8000fcbe:	d8 32       	popm	r0-r7,pc

8000fcc0 <__avr32_umod64>:
8000fcc0:	d4 31       	pushm	r0-r7,lr
8000fcc2:	1a 97       	mov	r7,sp
8000fcc4:	20 3d       	sub	sp,12
8000fcc6:	10 9c       	mov	r12,r8
8000fcc8:	12 95       	mov	r5,r9
8000fcca:	14 9e       	mov	lr,r10
8000fccc:	16 91       	mov	r1,r11
8000fcce:	16 96       	mov	r6,r11
8000fcd0:	58 09       	cp.w	r9,0
8000fcd2:	e0 81 00 81 	brne	8000fdd4 <__avr32_umod64+0x114>
8000fcd6:	16 38       	cp.w	r8,r11
8000fcd8:	e0 88 00 12 	brls	8000fcfc <__avr32_umod64+0x3c>
8000fcdc:	f0 08 12 00 	clz	r8,r8
8000fce0:	c4 e0       	breq	8000fd7c <__avr32_umod64+0xbc>
8000fce2:	f6 08 09 46 	lsl	r6,r11,r8
8000fce6:	f8 08 09 4c 	lsl	r12,r12,r8
8000fcea:	f0 0b 11 20 	rsub	r11,r8,32
8000fcee:	f4 08 09 4e 	lsl	lr,r10,r8
8000fcf2:	f4 0b 0a 4b 	lsr	r11,r10,r11
8000fcf6:	f7 e6 10 06 	or	r6,r11,r6
8000fcfa:	c4 18       	rjmp	8000fd7c <__avr32_umod64+0xbc>
8000fcfc:	58 08       	cp.w	r8,0
8000fcfe:	c0 51       	brne	8000fd08 <__avr32_umod64+0x48>
8000fd00:	30 19       	mov	r9,1
8000fd02:	f2 08 0d 08 	divu	r8,r9,r8
8000fd06:	10 9c       	mov	r12,r8
8000fd08:	f8 08 12 00 	clz	r8,r12
8000fd0c:	c0 31       	brne	8000fd12 <__avr32_umod64+0x52>
8000fd0e:	18 16       	sub	r6,r12
8000fd10:	c3 68       	rjmp	8000fd7c <__avr32_umod64+0xbc>
8000fd12:	f0 03 11 20 	rsub	r3,r8,32
8000fd16:	f4 03 0a 4b 	lsr	r11,r10,r3
8000fd1a:	f8 08 09 4c 	lsl	r12,r12,r8
8000fd1e:	ec 08 09 49 	lsl	r9,r6,r8
8000fd22:	ec 03 0a 43 	lsr	r3,r6,r3
8000fd26:	f7 e9 10 09 	or	r9,r11,r9
8000fd2a:	f8 05 16 10 	lsr	r5,r12,0x10
8000fd2e:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000fd32:	e6 05 0d 02 	divu	r2,r3,r5
8000fd36:	f2 0e 16 10 	lsr	lr,r9,0x10
8000fd3a:	ec 02 02 4b 	mul	r11,r6,r2
8000fd3e:	fd e3 11 0e 	or	lr,lr,r3<<0x10
8000fd42:	16 3e       	cp.w	lr,r11
8000fd44:	c0 72       	brcc	8000fd52 <__avr32_umod64+0x92>
8000fd46:	18 0e       	add	lr,r12
8000fd48:	18 3e       	cp.w	lr,r12
8000fd4a:	c0 43       	brcs	8000fd52 <__avr32_umod64+0x92>
8000fd4c:	16 3e       	cp.w	lr,r11
8000fd4e:	fd dc e3 0e 	addcs	lr,lr,r12
8000fd52:	fc 0b 01 03 	sub	r3,lr,r11
8000fd56:	f3 d9 c0 10 	bfextu	r9,r9,0x0,0x10
8000fd5a:	e6 05 0d 02 	divu	r2,r3,r5
8000fd5e:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000fd62:	a5 36       	mul	r6,r2
8000fd64:	0c 39       	cp.w	r9,r6
8000fd66:	c0 72       	brcc	8000fd74 <__avr32_umod64+0xb4>
8000fd68:	18 09       	add	r9,r12
8000fd6a:	18 39       	cp.w	r9,r12
8000fd6c:	c0 43       	brcs	8000fd74 <__avr32_umod64+0xb4>
8000fd6e:	0c 39       	cp.w	r9,r6
8000fd70:	f3 dc e3 09 	addcs	r9,r9,r12
8000fd74:	f2 06 01 06 	sub	r6,r9,r6
8000fd78:	f4 08 09 4e 	lsl	lr,r10,r8
8000fd7c:	f8 0a 16 10 	lsr	r10,r12,0x10
8000fd80:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000fd84:	ec 0a 0d 02 	divu	r2,r6,r10
8000fd88:	fc 09 16 10 	lsr	r9,lr,0x10
8000fd8c:	ea 02 02 4b 	mul	r11,r5,r2
8000fd90:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000fd94:	16 39       	cp.w	r9,r11
8000fd96:	c0 72       	brcc	8000fda4 <__avr32_umod64+0xe4>
8000fd98:	18 09       	add	r9,r12
8000fd9a:	18 39       	cp.w	r9,r12
8000fd9c:	c0 43       	brcs	8000fda4 <__avr32_umod64+0xe4>
8000fd9e:	16 39       	cp.w	r9,r11
8000fda0:	f3 dc e3 09 	addcs	r9,r9,r12
8000fda4:	f2 0b 01 0b 	sub	r11,r9,r11
8000fda8:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000fdac:	f6 0a 0d 0a 	divu	r10,r11,r10
8000fdb0:	fd eb 11 0e 	or	lr,lr,r11<<0x10
8000fdb4:	ea 0a 02 4a 	mul	r10,r5,r10
8000fdb8:	14 3e       	cp.w	lr,r10
8000fdba:	c0 72       	brcc	8000fdc8 <__avr32_umod64+0x108>
8000fdbc:	18 0e       	add	lr,r12
8000fdbe:	18 3e       	cp.w	lr,r12
8000fdc0:	c0 43       	brcs	8000fdc8 <__avr32_umod64+0x108>
8000fdc2:	14 3e       	cp.w	lr,r10
8000fdc4:	fd dc e3 0e 	addcs	lr,lr,r12
8000fdc8:	fc 0a 01 0a 	sub	r10,lr,r10
8000fdcc:	30 0b       	mov	r11,0
8000fdce:	f4 08 0a 4a 	lsr	r10,r10,r8
8000fdd2:	c7 b8       	rjmp	8000fec8 <__avr32_umod64+0x208>
8000fdd4:	16 39       	cp.w	r9,r11
8000fdd6:	e0 8b 00 79 	brhi	8000fec8 <__avr32_umod64+0x208>
8000fdda:	f2 09 12 00 	clz	r9,r9
8000fdde:	c1 21       	brne	8000fe02 <__avr32_umod64+0x142>
8000fde0:	10 3a       	cp.w	r10,r8
8000fde2:	5f 2b       	srhs	r11
8000fde4:	0a 31       	cp.w	r1,r5
8000fde6:	5f ba       	srhi	r10
8000fde8:	f7 ea 10 0a 	or	r10,r11,r10
8000fdec:	f2 0a 18 00 	cp.b	r10,r9
8000fdf0:	c0 60       	breq	8000fdfc <__avr32_umod64+0x13c>
8000fdf2:	fc 08 01 0c 	sub	r12,lr,r8
8000fdf6:	e2 05 01 46 	sbc	r6,r1,r5
8000fdfa:	18 9e       	mov	lr,r12
8000fdfc:	0c 9b       	mov	r11,r6
8000fdfe:	1c 9a       	mov	r10,lr
8000fe00:	c6 48       	rjmp	8000fec8 <__avr32_umod64+0x208>
8000fe02:	ea 09 09 4c 	lsl	r12,r5,r9
8000fe06:	f2 06 11 20 	rsub	r6,r9,32
8000fe0a:	f6 09 09 4b 	lsl	r11,r11,r9
8000fe0e:	f0 09 09 42 	lsl	r2,r8,r9
8000fe12:	ef 46 ff f4 	st.w	r7[-12],r6
8000fe16:	f0 06 0a 48 	lsr	r8,r8,r6
8000fe1a:	18 48       	or	r8,r12
8000fe1c:	e2 06 0a 4c 	lsr	r12,r1,r6
8000fe20:	f4 09 09 43 	lsl	r3,r10,r9
8000fe24:	fd d8 c0 10 	bfextu	lr,r8,0x0,0x10
8000fe28:	f4 06 0a 4a 	lsr	r10,r10,r6
8000fe2c:	16 4a       	or	r10,r11
8000fe2e:	f0 0b 16 10 	lsr	r11,r8,0x10
8000fe32:	f8 0b 0d 04 	divu	r4,r12,r11
8000fe36:	f4 0c 16 10 	lsr	r12,r10,0x10
8000fe3a:	08 91       	mov	r1,r4
8000fe3c:	f9 e5 11 0c 	or	r12,r12,r5<<0x10
8000fe40:	e8 0e 02 46 	mul	r6,r4,lr
8000fe44:	0c 3c       	cp.w	r12,r6
8000fe46:	c0 a2       	brcc	8000fe5a <__avr32_umod64+0x19a>
8000fe48:	20 11       	sub	r1,1
8000fe4a:	10 0c       	add	r12,r8
8000fe4c:	10 3c       	cp.w	r12,r8
8000fe4e:	c0 63       	brcs	8000fe5a <__avr32_umod64+0x19a>
8000fe50:	0c 3c       	cp.w	r12,r6
8000fe52:	f7 b1 03 01 	sublo	r1,1
8000fe56:	f9 d8 e3 0c 	addcs	r12,r12,r8
8000fe5a:	0c 1c       	sub	r12,r6
8000fe5c:	f5 da c0 10 	bfextu	r10,r10,0x0,0x10
8000fe60:	f8 0b 0d 04 	divu	r4,r12,r11
8000fe64:	f5 e5 11 0b 	or	r11,r10,r5<<0x10
8000fe68:	08 96       	mov	r6,r4
8000fe6a:	e8 0e 02 4e 	mul	lr,r4,lr
8000fe6e:	1c 3b       	cp.w	r11,lr
8000fe70:	c0 a2       	brcc	8000fe84 <__avr32_umod64+0x1c4>
8000fe72:	20 16       	sub	r6,1
8000fe74:	10 0b       	add	r11,r8
8000fe76:	10 3b       	cp.w	r11,r8
8000fe78:	c0 63       	brcs	8000fe84 <__avr32_umod64+0x1c4>
8000fe7a:	1c 3b       	cp.w	r11,lr
8000fe7c:	f7 b6 03 01 	sublo	r6,1
8000fe80:	f7 d8 e3 0b 	addcs	r11,r11,r8
8000fe84:	ed e1 11 01 	or	r1,r6,r1<<0x10
8000fe88:	1c 1b       	sub	r11,lr
8000fe8a:	e2 02 06 40 	mulu.d	r0,r1,r2
8000fe8e:	00 9e       	mov	lr,r0
8000fe90:	02 9c       	mov	r12,r1
8000fe92:	16 3c       	cp.w	r12,r11
8000fe94:	e0 8b 00 08 	brhi	8000fea4 <__avr32_umod64+0x1e4>
8000fe98:	5f 06       	sreq	r6
8000fe9a:	06 30       	cp.w	r0,r3
8000fe9c:	5f ba       	srhi	r10
8000fe9e:	ed ea 00 0a 	and	r10,r6,r10
8000fea2:	c0 60       	breq	8000feae <__avr32_umod64+0x1ee>
8000fea4:	fc 02 01 04 	sub	r4,lr,r2
8000fea8:	f8 08 01 4c 	sbc	r12,r12,r8
8000feac:	08 9e       	mov	lr,r4
8000feae:	e6 0e 01 0a 	sub	r10,r3,lr
8000feb2:	f6 0c 01 4c 	sbc	r12,r11,r12
8000feb6:	ee f1 ff f4 	ld.w	r1,r7[-12]
8000feba:	f8 09 0a 4b 	lsr	r11,r12,r9
8000febe:	f4 09 0a 4a 	lsr	r10,r10,r9
8000fec2:	f8 01 09 4c 	lsl	r12,r12,r1
8000fec6:	18 4a       	or	r10,r12
8000fec8:	2f dd       	sub	sp,-12
8000feca:	d8 32       	popm	r0-r7,pc

Disassembly of section .exception:

80010000 <_evba>:
_evba:

        .org  0x000
        // Unrecoverable Exception.
_handle_Unrecoverable_Exception:
        rjmp $
80010000:	c0 08       	rjmp	80010000 <_evba>
	...

80010004 <_handle_TLB_Multiple_Hit>:

        .org  0x004
        // TLB Multiple Hit: UNUSED IN AVR32UC.
_handle_TLB_Multiple_Hit:
        rjmp $
80010004:	c0 08       	rjmp	80010004 <_handle_TLB_Multiple_Hit>
	...

80010008 <_handle_Bus_Error_Data_Fetch>:

        .org  0x008
        // Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
        rjmp $
80010008:	c0 08       	rjmp	80010008 <_handle_Bus_Error_Data_Fetch>
	...

8001000c <_handle_Bus_Error_Instruction_Fetch>:

        .org  0x00C
         // Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
        rjmp $
8001000c:	c0 08       	rjmp	8001000c <_handle_Bus_Error_Instruction_Fetch>
	...

80010010 <_handle_NMI>:

        .org  0x010
        // NMI.
_handle_NMI:
        rjmp $
80010010:	c0 08       	rjmp	80010010 <_handle_NMI>
	...

80010014 <_handle_Instruction_Address>:

        .org  0x014
        // Instruction Address.
_handle_Instruction_Address:
        rjmp $
80010014:	c0 08       	rjmp	80010014 <_handle_Instruction_Address>
	...

80010018 <_handle_ITLB_Protection>:

        .org  0x018
        // ITLB Protection.
_handle_ITLB_Protection:
        rjmp $
80010018:	c0 08       	rjmp	80010018 <_handle_ITLB_Protection>
	...

8001001c <_handle_Breakpoint>:

        .org  0x01C
        // Breakpoint.
_handle_Breakpoint:
        rjmp $
8001001c:	c0 08       	rjmp	8001001c <_handle_Breakpoint>
	...

80010020 <_handle_Illegal_Opcode>:

        .org  0x020
        // Illegal Opcode.
_handle_Illegal_Opcode:
        rjmp $
80010020:	c0 08       	rjmp	80010020 <_handle_Illegal_Opcode>
	...

80010024 <_handle_Unimplemented_Instruction>:

        .org  0x024
        // Unimplemented Instruction.
_handle_Unimplemented_Instruction:
        rjmp $
80010024:	c0 08       	rjmp	80010024 <_handle_Unimplemented_Instruction>
	...

80010028 <_handle_Privilege_Violation>:

        .org  0x028
        // Privilege Violation.
_handle_Privilege_Violation:
        rjmp $
80010028:	c0 08       	rjmp	80010028 <_handle_Privilege_Violation>
	...

8001002c <_handle_Floating_Point>:

        .org  0x02C
        // Floating-Point: UNUSED IN AVR32UC.
_handle_Floating_Point:
        rjmp $
8001002c:	c0 08       	rjmp	8001002c <_handle_Floating_Point>
	...

80010030 <_handle_Coprocessor_Absent>:

        .org  0x030
        // Coprocessor Absent: UNUSED IN AVR32UC.
_handle_Coprocessor_Absent:
        rjmp $
80010030:	c0 08       	rjmp	80010030 <_handle_Coprocessor_Absent>
	...

80010034 <_handle_Data_Address_Read>:

        .org  0x034
        // Data Address (Read).
_handle_Data_Address_Read:
        rjmp $
80010034:	c0 08       	rjmp	80010034 <_handle_Data_Address_Read>
	...

80010038 <_handle_Data_Address_Write>:

        .org  0x038
        // Data Address (Write).
_handle_Data_Address_Write:
        rjmp $
80010038:	c0 08       	rjmp	80010038 <_handle_Data_Address_Write>
	...

8001003c <_handle_DTLB_Protection_Read>:

        .org  0x03C
        // DTLB Protection (Read).
_handle_DTLB_Protection_Read:
        rjmp $
8001003c:	c0 08       	rjmp	8001003c <_handle_DTLB_Protection_Read>
	...

80010040 <_handle_DTLB_Protection_Write>:

        .org  0x040
        // DTLB Protection (Write).
_handle_DTLB_Protection_Write:
        rjmp $
80010040:	c0 08       	rjmp	80010040 <_handle_DTLB_Protection_Write>
	...

80010044 <_handle_DTLB_Modified>:

        .org  0x044
        // DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
        rjmp $
80010044:	c0 08       	rjmp	80010044 <_handle_DTLB_Modified>
	...

80010050 <_handle_ITLB_Miss>:

        .org  0x050
        // ITLB Miss: UNUSED IN AVR32UC.
_handle_ITLB_Miss:
        rjmp $
80010050:	c0 08       	rjmp	80010050 <_handle_ITLB_Miss>
	...

80010060 <_handle_DTLB_Miss_Read>:

        .org  0x060
        // DTLB Miss (Read): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Read:
        rjmp $
80010060:	c0 08       	rjmp	80010060 <_handle_DTLB_Miss_Read>
	...

80010070 <_handle_DTLB_Miss_Write>:

        .org  0x070
        // DTLB Miss (Write): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Write:
        rjmp $
80010070:	c0 08       	rjmp	80010070 <_handle_DTLB_Miss_Write>
	...

80010100 <_handle_Supervisor_Call>:

        .org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
80010100:	fe cf 73 08 	sub	pc,pc,29448

80010104 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
80010104:	30 0c       	mov	r12,0
80010106:	fe b0 ae 45 	rcall	80005d90 <_get_interrupt_handler>
8001010a:	58 0c       	cp.w	r12,0
8001010c:	f8 0f 17 10 	movne	pc,r12
80010110:	d6 03       	rete

80010112 <_int1>:
80010112:	30 1c       	mov	r12,1
80010114:	fe b0 ae 3e 	rcall	80005d90 <_get_interrupt_handler>
80010118:	58 0c       	cp.w	r12,0
8001011a:	f8 0f 17 10 	movne	pc,r12
8001011e:	d6 03       	rete

80010120 <_int2>:
80010120:	30 2c       	mov	r12,2
80010122:	fe b0 ae 37 	rcall	80005d90 <_get_interrupt_handler>
80010126:	58 0c       	cp.w	r12,0
80010128:	f8 0f 17 10 	movne	pc,r12
8001012c:	d6 03       	rete

8001012e <_int3>:
8001012e:	30 3c       	mov	r12,3
80010130:	fe b0 ae 30 	rcall	80005d90 <_get_interrupt_handler>
80010134:	58 0c       	cp.w	r12,0
80010136:	f8 0f 17 10 	movne	pc,r12
8001013a:	d6 03       	rete

8001013c <ipr_val>:
8001013c:	00 00 01 04 40 00 01 12 80 00 01 20 c0 00 01 2e     ....@...... ....
8001014c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8001015c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8001016c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8001017c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8001018c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8001019c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
800101ac:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
800101bc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
800101cc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
800101dc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
800101ec:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
800101fc:	d7 03 d7 03                                         ....
