
moto_gob_prj.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002008  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80002008  80002008  00002408  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         0000a2e0  80002008  80002008  00002408  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  8000c400  8000c400  0000c800  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       00001760  8000c600  8000c600  0000ca00  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .dalign       00000004  00000004  00000004  00000000  2**0
                  ALLOC
  6 .data         00000a34  00000008  8000dd60  0000e408  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .balign       00000004  00000a3c  8000e794  0000ee3c  2**0
                  ALLOC
  8 .bss          000036e0  00000a40  00000a40  00000000  2**2
                  ALLOC
  9 .heap         00012ee0  00004120  00004120  00000000  2**0
                  ALLOC
 10 .comment      00000030  00000000  00000000  0000ee3c  2**0
                  CONTENTS, READONLY
 11 .debug_aranges 00001140  00000000  00000000  0000ee70  2**3
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_pubnames 000024d9  00000000  00000000  0000ffb0  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_info   000282f0  00000000  00000000  00012489  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_abbrev 000067f6  00000000  00000000  0003a779  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_line   0000c1e5  00000000  00000000  00040f6f  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_frame  00002d28  00000000  00000000  0004d154  2**2
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_str    00006ccf  00000000  00000000  0004fe7c  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_loc    0000ca3e  00000000  00000000  00056b4b  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .stack        00001000  00017000  00017000  00000000  2**0
                  ALLOC
 20 .debug_ranges 00001228  00000000  00000000  00063590  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_start>:

  .global _start
  .type _start, @function
_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80000000:	fe cf 96 3c 	sub	pc,pc,-27076

80000004 <_trampoline>:
80000004:	e0 8f 10 00 	bral	80002004 <program_start>
	...

80002004 <program_start>:
  rjmp    program_start

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002004:	fe cf b6 40 	sub	pc,pc,-18880

Disassembly of section .text:

80002008 <DeviceManagement_brdcst_func>:
80002008:	19 a9       	ld.ub	r9,r12[0x2]
8000200a:	30 18       	mov	r8,1
		U8 temp = 0;
		temp  = xcmp->u8[1] << 8;
		temp |= xcmp->u8[2];
		//if (temp == theXNL_Ctrlr.XNL_DeviceLogicalAddress)
		{
			if (xcmp->u8[0] == 0x01)
8000200c:	f0 09 18 00 	cp.b	r9,r8
80002010:	c0 61       	brne	8000201c <DeviceManagement_brdcst_func+0x14>
			{
				bunchofrandomstatusflags |= 0x00000002;
80002012:	48 68       	lddpc	r8,80002028 <DeviceManagement_brdcst_func+0x20>
80002014:	70 09       	ld.w	r9,r8[0x0]
80002016:	a1 b9       	sbr	r9,0x1
80002018:	91 09       	st.w	r8[0x0],r9
8000201a:	5e fc       	retal	r12
			}
			else
			{
				bunchofrandomstatusflags &= 0xFFFFFFFD;
8000201c:	48 38       	lddpc	r8,80002028 <DeviceManagement_brdcst_func+0x20>
8000201e:	70 09       	ld.w	r9,r8[0x0]
80002020:	a1 d9       	cbr	r9,0x1
80002022:	91 09       	st.w	r8[0x0],r9
80002024:	5e fc       	retal	r12
80002026:	00 00       	add	r0,r0
80002028:	00 00       	add	r0,r0
8000202a:	0d b0       	ld.ub	r0,r6[0x3]

8000202c <Volume_brdcst_func>:
	//log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
	
	//log("\n\r Audio_Parameter: %x \n\r", ptr->Audio_Parameter);
	
	
}
8000202c:	5e fc       	retal	r12
8000202e:	d7 03       	nop

80002030 <vApplicationIdleHook>:
}

void vApplicationIdleHook( void )
{
	/* This hook function does nothing but increment a counter. */
	ulIdleCycleCount++;
80002030:	48 38       	lddpc	r8,8000203c <vApplicationIdleHook+0xc>
80002032:	70 09       	ld.w	r9,r8[0x0]
80002034:	2f f9       	sub	r9,-1
80002036:	91 09       	st.w	r8[0x0],r9
	
}
80002038:	5e fc       	retal	r12
8000203a:	00 00       	add	r0,r0
8000203c:	00 00       	add	r0,r0
8000203e:	0a 60       	and	r0,r5

80002040 <app_init>:
														
		
};

void app_init(void)
{	
80002040:	d4 01       	pushm	lr
	//将app_payload_rx_proc更改为PCM加密功能
	payload_init( app_payload_rx_proc , app_payload_tx_proc );	
80002042:	48 cb       	lddpc	r11,80002070 <app_init+0x30>
80002044:	48 cc       	lddpc	r12,80002074 <app_init+0x34>
80002046:	f0 1f 00 0d 	mcall	80002078 <app_init+0x38>
	xcmp_register_app_list(the_app_list);
8000204a:	48 dc       	lddpc	r12,8000207c <app_init+0x3c>
8000204c:	f0 1f 00 0d 	mcall	80002080 <app_init+0x40>
			
	static portBASE_TYPE res = 0;
	 res = xTaskCreate(
80002050:	30 09       	mov	r9,0
80002052:	1a d9       	st.w	--sp,r9
80002054:	1a d9       	st.w	--sp,r9
80002056:	1a d9       	st.w	--sp,r9
80002058:	30 18       	mov	r8,1
8000205a:	e0 6a 01 80 	mov	r10,384
8000205e:	48 ab       	lddpc	r11,80002084 <app_init+0x44>
80002060:	48 ac       	lddpc	r12,80002088 <app_init+0x48>
80002062:	f0 1f 00 0b 	mcall	8000208c <app_init+0x4c>
80002066:	48 b8       	lddpc	r8,80002090 <app_init+0x50>
80002068:	91 0c       	st.w	r8[0x0],r12
8000206a:	2f dd       	sub	sp,-12
	,  NULL
	,  1
	,  NULL );
	
	
}
8000206c:	d8 02       	popm	pc
8000206e:	00 00       	add	r0,r0
80002070:	80 00       	ld.sh	r0,r0[0x0]
80002072:	21 08       	sub	r8,16
80002074:	80 00       	ld.sh	r0,r0[0x0]
80002076:	28 44       	sub	r4,-124
80002078:	80 00       	ld.sh	r0,r0[0x0]
8000207a:	29 30       	sub	r0,-109
8000207c:	00 00       	add	r0,r0
8000207e:	00 08       	add	r8,r0
80002080:	80 00       	ld.sh	r0,r0[0x0]
80002082:	41 94       	lddsp	r4,sp[0x64]
80002084:	80 00       	ld.sh	r0,r0[0x0]
80002086:	c6 00       	breq	80002146 <FD_request_func+0x2>
80002088:	80 00       	ld.sh	r0,r0[0x0]
8000208a:	20 94       	sub	r4,9
8000208c:	80 00       	ld.sh	r0,r0[0x0]
8000208e:	61 38       	ld.w	r8,r0[0x4c]
80002090:	00 00       	add	r0,r0
80002092:	0a 4c       	or	r12,r5

80002094 <app_cfg>:

extern  char AudioData[];
extern U32 tc_tick;

static __app_Thread_(app_cfg)
{
80002094:	d4 31       	pushm	r0-r7,lr
	static  U32 isAudioRouting = 0;
	static  portTickType xLastWakeTime;
	const portTickType xFrequency = 4000;//2s,定时问题已经修正。2s x  2000hz = 4000
	U8 Burst_ID = 0;
	
	 xLastWakeTime = xTaskGetTickCount();
80002096:	f0 1f 00 17 	mcall	800020f0 <app_cfg+0x5c>
8000209a:	49 78       	lddpc	r8,800020f4 <app_cfg+0x60>
8000209c:	91 0c       	st.w	r8[0x0],r12
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003))//确认连接成功了，再发送请求
8000209e:	49 76       	lddpc	r6,800020f8 <app_cfg+0x64>
				//{
					////xcmp_transmit_dekeycontrol();
					//
				//}
				
				if(isAudioRouting == 0)
800020a0:	49 74       	lddpc	r4,800020fc <app_cfg+0x68>
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_exit_enhanced_OB_mode();
					//xcmp_mute_speaker();
					//xcmp_enhanced_OB_mode();
					isAudioRouting = 4;
800020a2:	30 40       	mov	r0,4
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_mute_speaker();	
					//log("\n\r time: %d \n\r", tc_tick); 
					isAudioRouting = 3;
800020a4:	30 31       	mov	r1,3
					//xcmp_button_config();
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//log("\n\r time: %d \n\r", tc_tick);
					
					isAudioRouting = 2;
800020a6:	30 22       	mov	r2,2
					//xcmp_enter_device_control_mode();//调换3个命令的顺序，则不会导致掉线。。。奇葩
					//xcmp_unmute_speaker();
					//is_unmute = 1;
					//xcmp_function_mic();
					
					isAudioRouting = 1;
800020a8:	30 13       	mov	r3,1
			
		}
		//vTaskDelay(300*2 / portTICK_RATE_MS);//延迟300ms
		//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
		
		vTaskDelayUntil( &xLastWakeTime, 2000*2 / portTICK_RATE_MS  );//精确的以2000ms为周期执行。
800020aa:	10 97       	mov	r7,r8
800020ac:	e0 65 0f a0 	mov	r5,4000
	
	 xLastWakeTime = xTaskGetTickCount();
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003))//确认连接成功了，再发送请求
800020b0:	6c 08       	ld.w	r8,r6[0x0]
800020b2:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
800020b6:	58 38       	cp.w	r8,3
800020b8:	c1 71       	brne	800020e6 <app_cfg+0x52>
				//{
					////xcmp_transmit_dekeycontrol();
					//
				//}
				
				if(isAudioRouting == 0)
800020ba:	68 08       	ld.w	r8,r4[0x0]
800020bc:	58 08       	cp.w	r8,0
800020be:	c0 51       	brne	800020c8 <app_cfg+0x34>
				{
					//xcmp_data_session();
					//xcmp_audio_route_mic();
					//xcmp_button_config();
					xcmp_audio_route_speaker();
800020c0:	f0 1f 00 10 	mcall	80002100 <app_cfg+0x6c>
					//xcmp_enter_device_control_mode();//调换3个命令的顺序，则不会导致掉线。。。奇葩
					//xcmp_unmute_speaker();
					//is_unmute = 1;
					//xcmp_function_mic();
					
					isAudioRouting = 1;
800020c4:	89 03       	st.w	r4[0x0],r3
800020c6:	c1 08       	rjmp	800020e6 <app_cfg+0x52>
				}
				else if(isAudioRouting == 1)
800020c8:	58 18       	cp.w	r8,1
800020ca:	c0 31       	brne	800020d0 <app_cfg+0x3c>
					//xcmp_button_config();
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//log("\n\r time: %d \n\r", tc_tick);
					
					isAudioRouting = 2;
800020cc:	89 02       	st.w	r4[0x0],r2
800020ce:	c0 c8       	rjmp	800020e6 <app_cfg+0x52>
					//isAudioRouting++;
				}
				else if(isAudioRouting == 2)
800020d0:	58 28       	cp.w	r8,2
800020d2:	c0 31       	brne	800020d8 <app_cfg+0x44>
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_mute_speaker();	
					//log("\n\r time: %d \n\r", tc_tick); 
					isAudioRouting = 3;
800020d4:	89 01       	st.w	r4[0x0],r1
800020d6:	c0 88       	rjmp	800020e6 <app_cfg+0x52>
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_exit_enhanced_OB_mode();
					//xcmp_mute_speaker();
					//xcmp_enhanced_OB_mode();
					isAudioRouting = 4;
800020d8:	58 38       	cp.w	r8,3
800020da:	e9 f0 0a 00 	st.weq	r4[0x0],r0
					
				}
				else
				{
					isAudioRouting++;
800020de:	f7 b8 01 ff 	subne	r8,-1
800020e2:	e9 f8 1a 00 	st.wne	r4[0x0],r8
			
		}
		//vTaskDelay(300*2 / portTICK_RATE_MS);//延迟300ms
		//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
		
		vTaskDelayUntil( &xLastWakeTime, 2000*2 / portTICK_RATE_MS  );//精确的以2000ms为周期执行。
800020e6:	0a 9b       	mov	r11,r5
800020e8:	0e 9c       	mov	r12,r7
800020ea:	f0 1f 00 07 	mcall	80002104 <app_cfg+0x70>
	}
800020ee:	ce 1b       	rjmp	800020b0 <app_cfg+0x1c>
800020f0:	80 00       	ld.sh	r0,r0[0x0]
800020f2:	5e 70       	retpl	r0
800020f4:	00 00       	add	r0,r0
800020f6:	0a 48       	or	r8,r5
800020f8:	00 00       	add	r0,r0
800020fa:	0d b0       	ld.ub	r0,r6[0x3]
800020fc:	00 00       	add	r0,r0
800020fe:	0a 44       	or	r4,r5
80002100:	80 00       	ld.sh	r0,r0[0x0]
80002102:	41 e8       	lddsp	r8,sp[0x78]
80002104:	80 00       	ld.sh	r0,r0[0x0]
80002106:	5f d8       	srvc	r8

80002108 <app_payload_tx_proc>:

}


static void app_payload_tx_proc(void  * payload)
{
80002108:	d4 01       	pushm	lr
  log("R");
8000210a:	48 3c       	lddpc	r12,80002114 <app_payload_tx_proc+0xc>
8000210c:	f0 1f 00 03 	mcall	80002118 <app_payload_tx_proc+0x10>
  //
  //
  //set_payload_idle(payload);


}
80002110:	d8 02       	popm	pc
80002112:	00 00       	add	r0,r0
80002114:	80 00       	ld.sh	r0,r0[0x0]
80002116:	c6 08       	rjmp	800021d6 <EnOB_reply_func+0x6a>
80002118:	80 00       	ld.sh	r0,r0[0x0]
8000211a:	64 fc       	ld.w	r12,r2[0x3c]

8000211c <FD_brdcst_func>:
	
	
}

void FD_brdcst_func(xcmp_fragment_t * xcmp)
{
8000211c:	d4 01       	pushm	lr
	
	
	log("\n\r Forward Data Broadcast \n\r");
8000211e:	48 3c       	lddpc	r12,80002128 <FD_brdcst_func+0xc>
80002120:	f0 1f 00 03 	mcall	8000212c <FD_brdcst_func+0x10>
	
}
80002124:	d8 02       	popm	pc
80002126:	00 00       	add	r0,r0
80002128:	80 00       	ld.sh	r0,r0[0x0]
8000212a:	c6 0c       	rcall	800021ea <SingleDetection_brdcst_func+0xe>
8000212c:	80 00       	ld.sh	r0,r0[0x0]
8000212e:	64 fc       	ld.w	r12,r2[0x3c]

80002130 <FD_reply_func>:
	
	
}

void FD_reply_func(xcmp_fragment_t * xcmp)
{
80002130:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Reply \n\r");
80002132:	48 3c       	lddpc	r12,8000213c <FD_reply_func+0xc>
80002134:	f0 1f 00 03 	mcall	80002140 <FD_reply_func+0x10>
	
	
}
80002138:	d8 02       	popm	pc
8000213a:	00 00       	add	r0,r0
8000213c:	80 00       	ld.sh	r0,r0[0x0]
8000213e:	c6 2c       	rcall	80002202 <SingleDetection_brdcst_func+0x26>
80002140:	80 00       	ld.sh	r0,r0[0x0]
80002142:	64 fc       	ld.w	r12,r2[0x3c]

80002144 <FD_request_func>:
}



void FD_request_func(xcmp_fragment_t * xcmp)
{
80002144:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Request \n\r");
80002146:	48 3c       	lddpc	r12,80002150 <FD_request_func+0xc>
80002148:	f0 1f 00 03 	mcall	80002154 <FD_request_func+0x10>
	
	
}
8000214c:	d8 02       	popm	pc
8000214e:	00 00       	add	r0,r0
80002150:	80 00       	ld.sh	r0,r0[0x0]
80002152:	c6 48       	rjmp	8000221a <SingleDetection_brdcst_func+0x3e>
80002154:	80 00       	ld.sh	r0,r0[0x0]
80002156:	64 fc       	ld.w	r12,r2[0x3c]

80002158 <EnOB_brdcst_func>:
	
	
}

void EnOB_brdcst_func(xcmp_fragment_t * xcmp)
{
80002158:	d4 01       	pushm	lr
	
	
	log("\n\r En_OB Broadcast \n\r");
8000215a:	48 3c       	lddpc	r12,80002164 <EnOB_brdcst_func+0xc>
8000215c:	f0 1f 00 03 	mcall	80002168 <EnOB_brdcst_func+0x10>
}
80002160:	d8 02       	popm	pc
80002162:	00 00       	add	r0,r0
80002164:	80 00       	ld.sh	r0,r0[0x0]
80002166:	c6 64       	brge	80002232 <ButtonConfig_brdcst_func+0x16>
80002168:	80 00       	ld.sh	r0,r0[0x0]
8000216a:	64 fc       	ld.w	r12,r2[0x3c]

8000216c <EnOB_reply_func>:
}



void EnOB_reply_func(xcmp_fragment_t * xcmp)
{
8000216c:	eb cd 40 80 	pushm	r7,lr
80002170:	18 97       	mov	r7,r12
		/*point to xcmp payload*/
	//En_OB_Control_reply_t *ptr = (En_OB_Control_reply_t* )xcmp->u8;
	//log("\n\r Xcmp_opcode: %x \n\r", xcmp->xcmp_opcode);
	
	if (xcmp->u8[0]== xcmp_Res_Success)
80002172:	19 a9       	ld.ub	r9,r12[0x2]
80002174:	30 08       	mov	r8,0
80002176:	f0 09 18 00 	cp.b	r9,r8
8000217a:	c1 91       	brne	800021ac <EnOB_reply_func+0x40>
	{
		if (xcmp->u8[1] == EN_OB_Enter)
8000217c:	19 b8       	ld.ub	r8,r12[0x3]
8000217e:	30 19       	mov	r9,1
80002180:	f2 08 18 00 	cp.b	r8,r9
80002184:	c0 61       	brne	80002190 <EnOB_reply_func+0x24>
		{
		
			log("\n\r En_OB_Enter OK \n\r");
80002186:	49 0c       	lddpc	r12,800021c4 <EnOB_reply_func+0x58>
80002188:	f0 1f 00 10 	mcall	800021c8 <EnOB_reply_func+0x5c>
8000218c:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else if (xcmp->u8[1] == EN_OB_Exit )
80002190:	58 08       	cp.w	r8,0
80002192:	c0 61       	brne	8000219e <EnOB_reply_func+0x32>
		{
			log("\n\r En_OB_Exit OK \n\r");
80002194:	48 ec       	lddpc	r12,800021cc <EnOB_reply_func+0x60>
80002196:	f0 1f 00 0d 	mcall	800021c8 <EnOB_reply_func+0x5c>
8000219a:	e3 cd 80 80 	ldm	sp++,r7,pc
		}
		else
		{
			
			log("\n\r En_OB_Control: %x \n\r", xcmp->u8[1]);
8000219e:	1a d8       	st.w	--sp,r8
800021a0:	48 cc       	lddpc	r12,800021d0 <EnOB_reply_func+0x64>
800021a2:	f0 1f 00 0a 	mcall	800021c8 <EnOB_reply_func+0x5c>
800021a6:	2f fd       	sub	sp,-4
800021a8:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r En_OB_Control error \n\r");
800021ac:	48 ac       	lddpc	r12,800021d4 <EnOB_reply_func+0x68>
800021ae:	f0 1f 00 07 	mcall	800021c8 <EnOB_reply_func+0x5c>
		log("\n\r En_OB_result: %x \n\r", xcmp->u8[0]);
800021b2:	0f a8       	ld.ub	r8,r7[0x2]
800021b4:	1a d8       	st.w	--sp,r8
800021b6:	48 9c       	lddpc	r12,800021d8 <EnOB_reply_func+0x6c>
800021b8:	f0 1f 00 04 	mcall	800021c8 <EnOB_reply_func+0x5c>
800021bc:	2f fd       	sub	sp,-4
800021be:	e3 cd 80 80 	ldm	sp++,r7,pc
800021c2:	00 00       	add	r0,r0
800021c4:	80 00       	ld.sh	r0,r0[0x0]
800021c6:	c6 7c       	rcall	80002294 <ButtonConfig_brdcst_func+0x78>
800021c8:	80 00       	ld.sh	r0,r0[0x0]
800021ca:	64 fc       	ld.w	r12,r2[0x3c]
800021cc:	80 00       	ld.sh	r0,r0[0x0]
800021ce:	c6 94       	brge	800022a0 <ButtonConfig_brdcst_func+0x84>
800021d0:	80 00       	ld.sh	r0,r0[0x0]
800021d2:	c6 a8       	rjmp	800022a6 <ButtonConfig_brdcst_func+0x8a>
800021d4:	80 00       	ld.sh	r0,r0[0x0]
800021d6:	c6 c0       	breq	800022ae <ButtonConfig_brdcst_func+0x92>
800021d8:	80 00       	ld.sh	r0,r0[0x0]
800021da:	c6 dc       	rcall	800022b4 <ButtonConfig_brdcst_func+0x98>

800021dc <SingleDetection_brdcst_func>:
	
}


void SingleDetection_brdcst_func(xcmp_fragment_t * xcmp)
{
800021dc:	eb cd 40 80 	pushm	r7,lr
800021e0:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == 0x11)
800021e2:	19 a9       	ld.ub	r9,r12[0x2]
800021e4:	31 18       	mov	r8,17
800021e6:	f0 09 18 00 	cp.b	r9,r8
800021ea:	c0 61       	brne	800021f6 <SingleDetection_brdcst_func+0x1a>
	{
		log("\n\r DMR_CSBK OK \n\r");
800021ec:	48 8c       	lddpc	r12,8000220c <SingleDetection_brdcst_func+0x30>
800021ee:	f0 1f 00 09 	mcall	80002210 <SingleDetection_brdcst_func+0x34>
800021f2:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	//if(xcmp->u8[1] == 0x11)
	else
	{
		log("SIGBRCST error");
800021f6:	48 8c       	lddpc	r12,80002214 <SingleDetection_brdcst_func+0x38>
800021f8:	f0 1f 00 06 	mcall	80002210 <SingleDetection_brdcst_func+0x34>
		log("\n\r Signal_type: %X \n\r", xcmp->u8[0] );
800021fc:	0f a8       	ld.ub	r8,r7[0x2]
800021fe:	1a d8       	st.w	--sp,r8
80002200:	48 6c       	lddpc	r12,80002218 <SingleDetection_brdcst_func+0x3c>
80002202:	f0 1f 00 04 	mcall	80002210 <SingleDetection_brdcst_func+0x34>
80002206:	2f fd       	sub	sp,-4
80002208:	e3 cd 80 80 	ldm	sp++,r7,pc
8000220c:	80 00       	ld.sh	r0,r0[0x0]
8000220e:	c6 f4       	brge	800022ec <ButtonConfig_brdcst_func+0xd0>
80002210:	80 00       	ld.sh	r0,r0[0x0]
80002212:	64 fc       	ld.w	r12,r2[0x3c]
80002214:	80 00       	ld.sh	r0,r0[0x0]
80002216:	c7 08       	rjmp	800022f6 <ButtonConfig_brdcst_func+0xda>
80002218:	80 00       	ld.sh	r0,r0[0x0]
8000221a:	c7 18       	rjmp	800022fc <Phyuserinput_brdcst_func+0x4>

8000221c <ButtonConfig_brdcst_func>:
	
}


void ButtonConfig_brdcst_func(xcmp_fragment_t * xcmp)
{
8000221c:	d4 31       	pushm	r0-r7,lr
	U8 Num_Button =0;
	U8 i = 0 ;
	/*point to xcmp payload*/
	ButtonConfig_brdcst_t  *ptr = (ButtonConfig_brdcst_t* )xcmp->u8;
8000221e:	f8 c7 ff fe 	sub	r7,r12,-2
	
	Num_Button = ptr->NumOfButtons;
80002222:	0f 95       	ld.ub	r5,r7[0x1]
	
	log("\n\r ButtonConfig_broadcast  \n\r"  );
80002224:	4a bc       	lddpc	r12,800022d0 <ButtonConfig_brdcst_func+0xb4>
80002226:	f0 1f 00 2c 	mcall	800022d4 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r Function: %X \n\r" , ptr->Function );
8000222a:	0f 88       	ld.ub	r8,r7[0x0]
8000222c:	1a d8       	st.w	--sp,r8
8000222e:	4a bc       	lddpc	r12,800022d8 <ButtonConfig_brdcst_func+0xbc>
80002230:	f0 1f 00 29 	mcall	800022d4 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
80002234:	1a d5       	st.w	--sp,r5
80002236:	4a ac       	lddpc	r12,800022dc <ButtonConfig_brdcst_func+0xc0>
80002238:	f0 1f 00 27 	mcall	800022d4 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
8000223c:	0f a8       	ld.ub	r8,r7[0x2]
8000223e:	1a d8       	st.w	--sp,r8
80002240:	4a 8c       	lddpc	r12,800022e0 <ButtonConfig_brdcst_func+0xc4>
80002242:	f0 1f 00 25 	mcall	800022d4 <ButtonConfig_brdcst_func+0xb8>
	
	for (i; i<Num_Button; i++)
80002246:	2f dd       	sub	sp,-12
80002248:	58 05       	cp.w	r5,0
8000224a:	c4 10       	breq	800022cc <ButtonConfig_brdcst_func+0xb0>
8000224c:	30 06       	mov	r6,0
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
8000224e:	4a 64       	lddpc	r4,800022e4 <ButtonConfig_brdcst_func+0xc8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
80002250:	4a 63       	lddpc	r3,800022e8 <ButtonConfig_brdcst_func+0xcc>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
80002252:	4a 72       	lddpc	r2,800022ec <ButtonConfig_brdcst_func+0xd0>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
80002254:	4a 71       	lddpc	r1,800022f0 <ButtonConfig_brdcst_func+0xd4>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
80002256:	4a 80       	lddpc	r0,800022f4 <ButtonConfig_brdcst_func+0xd8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
80002258:	0f b9       	ld.ub	r9,r7[0x3]
8000225a:	0f c8       	ld.ub	r8,r7[0x4]
8000225c:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002260:	1a d8       	st.w	--sp,r8
80002262:	1a d6       	st.w	--sp,r6
80002264:	08 9c       	mov	r12,r4
80002266:	f0 1f 00 1c 	mcall	800022d4 <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
8000226a:	0f d9       	ld.ub	r9,r7[0x5]
8000226c:	0f e8       	ld.ub	r8,r7[0x6]
8000226e:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002272:	1a d8       	st.w	--sp,r8
80002274:	1a d6       	st.w	--sp,r6
80002276:	06 9c       	mov	r12,r3
80002278:	f0 1f 00 17 	mcall	800022d4 <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
8000227c:	0f f9       	ld.ub	r9,r7[0x7]
8000227e:	ef 38 00 08 	ld.ub	r8,r7[8]
80002282:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002286:	1a d8       	st.w	--sp,r8
80002288:	1a d6       	st.w	--sp,r6
8000228a:	04 9c       	mov	r12,r2
8000228c:	f0 1f 00 12 	mcall	800022d4 <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
80002290:	ef 39 00 09 	ld.ub	r9,r7[9]
80002294:	ef 38 00 0a 	ld.ub	r8,r7[10]
80002298:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000229c:	1a d8       	st.w	--sp,r8
8000229e:	1a d6       	st.w	--sp,r6
800022a0:	02 9c       	mov	r12,r1
800022a2:	f0 1f 00 0d 	mcall	800022d4 <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
800022a6:	2f 8d       	sub	sp,-32
800022a8:	ef 39 00 0b 	ld.ub	r9,r7[11]
800022ac:	ef 38 00 0c 	ld.ub	r8,r7[12]
800022b0:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800022b4:	1a d8       	st.w	--sp,r8
800022b6:	1a d6       	st.w	--sp,r6
800022b8:	00 9c       	mov	r12,r0
800022ba:	f0 1f 00 07 	mcall	800022d4 <ButtonConfig_brdcst_func+0xb8>
800022be:	2f f6       	sub	r6,-1
800022c0:	2f 67       	sub	r7,-10
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
800022c2:	2f ed       	sub	sp,-8
800022c4:	ec 05 18 00 	cp.b	r5,r6
800022c8:	fe 9b ff c8 	brhi	80002258 <ButtonConfig_brdcst_func+0x3c>
800022cc:	d8 32       	popm	r0-r7,pc
800022ce:	00 00       	add	r0,r0
800022d0:	80 00       	ld.sh	r0,r0[0x0]
800022d2:	c7 30       	breq	800023b8 <DataSession_brdcst_func+0x4>
800022d4:	80 00       	ld.sh	r0,r0[0x0]
800022d6:	64 fc       	ld.w	r12,r2[0x3c]
800022d8:	80 00       	ld.sh	r0,r0[0x0]
800022da:	c7 50       	breq	800023c4 <DataSession_brdcst_func+0x10>
800022dc:	80 00       	ld.sh	r0,r0[0x0]
800022de:	c7 64       	brge	800023ca <DataSession_brdcst_func+0x16>
800022e0:	80 00       	ld.sh	r0,r0[0x0]
800022e2:	c7 7c       	rcall	800023d0 <DataSession_brdcst_func+0x1c>
800022e4:	80 00       	ld.sh	r0,r0[0x0]
800022e6:	c7 9c       	rcall	800023d8 <DataSession_brdcst_func+0x24>
800022e8:	80 00       	ld.sh	r0,r0[0x0]
800022ea:	c7 c4       	brge	800023e2 <DataSession_brdcst_func+0x2e>
800022ec:	80 00       	ld.sh	r0,r0[0x0]
800022ee:	c7 ec       	rcall	800023ea <DataSession_brdcst_func+0x36>
800022f0:	80 00       	ld.sh	r0,r0[0x0]
800022f2:	c8 10       	breq	800021f4 <SingleDetection_brdcst_func+0x18>
800022f4:	80 00       	ld.sh	r0,r0[0x0]
800022f6:	c8 38       	rjmp	800023fc <DataSession_brdcst_func+0x48>

800022f8 <Phyuserinput_brdcst_func>:
	
}


void Phyuserinput_brdcst_func(xcmp_fragment_t * xcmp)
{
800022f8:	eb cd 40 fc 	pushm	r2-r7,lr
	U16 PUI_ID =0;
	U8 PUI_State =0;
	U8 PUI_State_Min_Value =0;
	U8 PUI_State_Max_Value =0;
	
	PUI_Source = xcmp->u8[0];
800022fc:	19 a6       	ld.ub	r6,r12[0x2]
	PUI_Type = xcmp ->u8[1];
800022fe:	19 b5       	ld.ub	r5,r12[0x3]
	PUI_ID = ((xcmp->u8[2]<<8) | xcmp->u8[3]);
80002300:	19 c7       	ld.ub	r7,r12[0x4]
80002302:	19 d8       	ld.ub	r8,r12[0x5]
80002304:	f1 e7 10 87 	or	r7,r8,r7<<0x8
	PUI_State = xcmp->u8[4];
80002308:	19 e4       	ld.ub	r4,r12[0x6]
	PUI_State_Min_Value = xcmp->u8[5];
8000230a:	19 f3       	ld.ub	r3,r12[0x7]
	PUI_State_Max_Value = xcmp->u8[6];
8000230c:	f9 32 00 08 	ld.ub	r2,r12[8]
	
	log("\n\r PhysicalUserInput_broadcast  \n\r"  );
80002310:	49 0c       	lddpc	r12,80002350 <Phyuserinput_brdcst_func+0x58>
80002312:	f0 1f 00 11 	mcall	80002354 <Phyuserinput_brdcst_func+0x5c>
	
	log("\n\r PUI_Source: %X \n\r" , PUI_Source);
80002316:	1a d6       	st.w	--sp,r6
80002318:	49 0c       	lddpc	r12,80002358 <Phyuserinput_brdcst_func+0x60>
8000231a:	f0 1f 00 0f 	mcall	80002354 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_Type: %X \n\r" , PUI_Type);
8000231e:	1a d5       	st.w	--sp,r5
80002320:	48 fc       	lddpc	r12,8000235c <Phyuserinput_brdcst_func+0x64>
80002322:	f0 1f 00 0d 	mcall	80002354 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_ID: %X \n\r" , PUI_ID);
80002326:	5c 77       	castu.h	r7
80002328:	1a d7       	st.w	--sp,r7
8000232a:	48 ec       	lddpc	r12,80002360 <Phyuserinput_brdcst_func+0x68>
8000232c:	f0 1f 00 0a 	mcall	80002354 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_State: %X \n\r" , PUI_State);
80002330:	1a d4       	st.w	--sp,r4
80002332:	48 dc       	lddpc	r12,80002364 <Phyuserinput_brdcst_func+0x6c>
80002334:	f0 1f 00 08 	mcall	80002354 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_State_Min_Value: %X \n\r" , PUI_State_Min_Value);
80002338:	1a d3       	st.w	--sp,r3
8000233a:	48 cc       	lddpc	r12,80002368 <Phyuserinput_brdcst_func+0x70>
8000233c:	f0 1f 00 06 	mcall	80002354 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_State_Max_Value: %X \n\r" , PUI_State_Max_Value);
80002340:	1a d2       	st.w	--sp,r2
80002342:	48 bc       	lddpc	r12,8000236c <Phyuserinput_brdcst_func+0x74>
80002344:	f0 1f 00 04 	mcall	80002354 <Phyuserinput_brdcst_func+0x5c>
80002348:	2f ad       	sub	sp,-24
	
	
	
	
	
}
8000234a:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
8000234e:	00 00       	add	r0,r0
80002350:	80 00       	ld.sh	r0,r0[0x0]
80002352:	c8 5c       	rcall	8000245c <DataSession_reply_func+0x24>
80002354:	80 00       	ld.sh	r0,r0[0x0]
80002356:	64 fc       	ld.w	r12,r2[0x3c]
80002358:	80 00       	ld.sh	r0,r0[0x0]
8000235a:	c8 80       	breq	8000226a <ButtonConfig_brdcst_func+0x4e>
8000235c:	80 00       	ld.sh	r0,r0[0x0]
8000235e:	c8 98       	rjmp	80002470 <DataSession_reply_func+0x38>
80002360:	80 00       	ld.sh	r0,r0[0x0]
80002362:	c8 ac       	rcall	80002476 <DataSession_reply_func+0x3e>
80002364:	80 00       	ld.sh	r0,r0[0x0]
80002366:	c8 c0       	breq	8000227e <ButtonConfig_brdcst_func+0x62>
80002368:	80 00       	ld.sh	r0,r0[0x0]
8000236a:	c8 d4       	brge	80002284 <ButtonConfig_brdcst_func+0x68>
8000236c:	80 00       	ld.sh	r0,r0[0x0]
8000236e:	c8 f4       	brge	8000228c <ButtonConfig_brdcst_func+0x70>

80002370 <ButtonConfig_reply_func>:
	}
	
}

void ButtonConfig_reply_func(xcmp_fragment_t * xcmp)
{
80002370:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	ButtonConfig_reply_t *ptr = (ButtonConfig_reply_t* )(xcmp->u8);
80002374:	f8 c7 ff fe 	sub	r7,r12,-2
	if (ptr->Result == xcmp_Res_Success)
80002378:	0f 89       	ld.ub	r9,r7[0x0]
8000237a:	30 08       	mov	r8,0
8000237c:	f0 09 18 00 	cp.b	r9,r8
80002380:	c0 c1       	brne	80002398 <ButtonConfig_reply_func+0x28>
	{
		log("\n\r Button_Config OK \n\r");
80002382:	48 9c       	lddpc	r12,800023a4 <ButtonConfig_reply_func+0x34>
80002384:	f0 1f 00 09 	mcall	800023a8 <ButtonConfig_reply_func+0x38>
		
		log("\n\r Function: %X \n\r" , ptr->Function );
80002388:	0f 98       	ld.ub	r8,r7[0x1]
8000238a:	1a d8       	st.w	--sp,r8
8000238c:	48 8c       	lddpc	r12,800023ac <ButtonConfig_reply_func+0x3c>
8000238e:	f0 1f 00 07 	mcall	800023a8 <ButtonConfig_reply_func+0x38>
80002392:	2f fd       	sub	sp,-4
80002394:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r Button_Request error \n\r");
80002398:	48 6c       	lddpc	r12,800023b0 <ButtonConfig_reply_func+0x40>
8000239a:	f0 1f 00 04 	mcall	800023a8 <ButtonConfig_reply_func+0x38>
8000239e:	e3 cd 80 80 	ldm	sp++,r7,pc
800023a2:	00 00       	add	r0,r0
800023a4:	80 00       	ld.sh	r0,r0[0x0]
800023a6:	c9 14       	brge	800022c8 <ButtonConfig_brdcst_func+0xac>
800023a8:	80 00       	ld.sh	r0,r0[0x0]
800023aa:	64 fc       	ld.w	r12,r2[0x3c]
800023ac:	80 00       	ld.sh	r0,r0[0x0]
800023ae:	c7 50       	breq	80002498 <TransmitControl_brdcst_func+0x8>
800023b0:	80 00       	ld.sh	r0,r0[0x0]
800023b2:	c9 2c       	rcall	800024d6 <TransmitControl_brdcst_func+0x46>

800023b4 <DataSession_brdcst_func>:
	}
	
}

void DataSession_brdcst_func(xcmp_fragment_t * xcmp)
{
800023b4:	d4 21       	pushm	r4-r7,lr
	U8 Session_number = 0;
	U16 data_length = 0;
	U8 i = 0;
	/*point to xcmp payload*/
	DataSession_brdcst_t *ptr = (DataSession_brdcst_t* )xcmp->u8;
800023b6:	f8 c6 ff fe 	sub	r6,r12,-2

	if (ptr->State == CSBK_DATA_RX_Suc)
800023ba:	0d 88       	ld.ub	r8,r6[0x0]
800023bc:	32 49       	mov	r9,36
800023be:	f2 08 18 00 	cp.b	r8,r9
800023c2:	c2 91       	brne	80002414 <DataSession_brdcst_func+0x60>
	{
		
		log("\n\r CSBK_RX OK \n\r");
800023c4:	49 7c       	lddpc	r12,80002420 <DataSession_brdcst_func+0x6c>
800023c6:	f0 1f 00 18 	mcall	80002424 <DataSession_brdcst_func+0x70>
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
800023ca:	0d a5       	ld.ub	r5,r6[0x2]
800023cc:	0d b8       	ld.ub	r8,r6[0x3]
800023ce:	f1 e5 10 85 	or	r5,r8,r5<<0x8
800023d2:	5c 85       	casts.h	r5

		log("\n\r Session_ID: %x \n\r",Session_number );
800023d4:	0d 98       	ld.ub	r8,r6[0x1]
800023d6:	1a d8       	st.w	--sp,r8
800023d8:	49 4c       	lddpc	r12,80002428 <DataSession_brdcst_func+0x74>
800023da:	f0 1f 00 13 	mcall	80002424 <DataSession_brdcst_func+0x70>
		log("\n\r paylaod_length: %d \n\r",data_length );
800023de:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
800023e2:	1a d8       	st.w	--sp,r8
800023e4:	49 2c       	lddpc	r12,8000242c <DataSession_brdcst_func+0x78>
800023e6:	f0 1f 00 10 	mcall	80002424 <DataSession_brdcst_func+0x70>
		for(i=0; i<data_length; i++)
800023ea:	2f ed       	sub	sp,-8
800023ec:	58 05       	cp.w	r5,0
800023ee:	c1 80       	breq	8000241e <DataSession_brdcst_func+0x6a>
800023f0:	30 07       	mov	r7,0
		{
			
			//log("\n\r payload[%d]: %X \n\r", i, xcmp->u8[4+i]);
			log("\n\r payload[%d]: %X \n\r", i, ptr->DataPayload.DataPayload[i]);
800023f2:	49 04       	lddpc	r4,80002430 <DataSession_brdcst_func+0x7c>
800023f4:	ec 07 00 08 	add	r8,r6,r7
800023f8:	11 c8       	ld.ub	r8,r8[0x4]
800023fa:	1a d8       	st.w	--sp,r8
800023fc:	1a d7       	st.w	--sp,r7
800023fe:	08 9c       	mov	r12,r4
80002400:	f0 1f 00 09 	mcall	80002424 <DataSession_brdcst_func+0x70>
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);

		log("\n\r Session_ID: %x \n\r",Session_number );
		log("\n\r paylaod_length: %d \n\r",data_length );
		for(i=0; i<data_length; i++)
80002404:	2f f7       	sub	r7,-1
80002406:	5c 57       	castu.b	r7
80002408:	2f ed       	sub	sp,-8
8000240a:	ee 05 19 00 	cp.h	r5,r7
8000240e:	fe 9b ff f3 	brhi	800023f4 <DataSession_brdcst_func+0x40>
80002412:	d8 22       	popm	r4-r7,pc
		
	}
	else
	{
		//log("\n\r State: 0x %X \n\r", xcmp->u8[0]);
		log("\n\r State: 0x %X \n\r", ptr->State);
80002414:	1a d8       	st.w	--sp,r8
80002416:	48 8c       	lddpc	r12,80002434 <DataSession_brdcst_func+0x80>
80002418:	f0 1f 00 03 	mcall	80002424 <DataSession_brdcst_func+0x70>
8000241c:	2f fd       	sub	sp,-4
8000241e:	d8 22       	popm	r4-r7,pc
80002420:	80 00       	ld.sh	r0,r0[0x0]
80002422:	c9 48       	rjmp	8000254a <AudioRoutingControl_brdcst_func+0x12>
80002424:	80 00       	ld.sh	r0,r0[0x0]
80002426:	64 fc       	ld.w	r12,r2[0x3c]
80002428:	80 00       	ld.sh	r0,r0[0x0]
8000242a:	c9 5c       	rcall	80002554 <AudioRoutingControl_brdcst_func+0x1c>
8000242c:	80 00       	ld.sh	r0,r0[0x0]
8000242e:	c9 74       	brge	8000235c <Phyuserinput_brdcst_func+0x64>
80002430:	80 00       	ld.sh	r0,r0[0x0]
80002432:	c9 90       	breq	80002364 <Phyuserinput_brdcst_func+0x6c>
80002434:	80 00       	ld.sh	r0,r0[0x0]
80002436:	c9 a8       	rjmp	8000256a <AudioRoutingControl_brdcst_func+0x32>

80002438 <DataSession_reply_func>:
	
}


void DataSession_reply_func(xcmp_fragment_t * xcmp)
{
80002438:	eb cd 40 80 	pushm	r7,lr
8000243c:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
8000243e:	19 a8       	ld.ub	r8,r12[0x2]
80002440:	58 08       	cp.w	r8,0
80002442:	c0 61       	brne	8000244e <DataSession_reply_func+0x16>
	{
		log("\n\r DATArep OK \n\r");
80002444:	48 dc       	lddpc	r12,80002478 <DataSession_reply_func+0x40>
80002446:	f0 1f 00 0e 	mcall	8000247c <DataSession_reply_func+0x44>
8000244a:	e3 cd 80 80 	ldm	sp++,r7,pc
		//log("\n\r ID: 0x %X \n\r", xcmp->u8[2]);
		
	}
	else
	{
		log("\n\r Result:  %X \n\r", xcmp->u8[0]);
8000244e:	1a d8       	st.w	--sp,r8
80002450:	48 cc       	lddpc	r12,80002480 <DataSession_reply_func+0x48>
80002452:	f0 1f 00 0b 	mcall	8000247c <DataSession_reply_func+0x44>
		log("\n\r DATArep error \n\r");
80002456:	48 cc       	lddpc	r12,80002484 <DataSession_reply_func+0x4c>
80002458:	f0 1f 00 09 	mcall	8000247c <DataSession_reply_func+0x44>
		log("\n\r Func:  %X \n\r", xcmp->u8[1]);
8000245c:	0f b8       	ld.ub	r8,r7[0x3]
8000245e:	1a d8       	st.w	--sp,r8
80002460:	48 ac       	lddpc	r12,80002488 <DataSession_reply_func+0x50>
80002462:	f0 1f 00 07 	mcall	8000247c <DataSession_reply_func+0x44>
		log("\n\r ID:  %X \n\r", xcmp->u8[2]);
80002466:	0f c8       	ld.ub	r8,r7[0x4]
80002468:	1a d8       	st.w	--sp,r8
8000246a:	48 9c       	lddpc	r12,8000248c <DataSession_reply_func+0x54>
8000246c:	f0 1f 00 04 	mcall	8000247c <DataSession_reply_func+0x44>
80002470:	2f dd       	sub	sp,-12
80002472:	e3 cd 80 80 	ldm	sp++,r7,pc
80002476:	00 00       	add	r0,r0
80002478:	80 00       	ld.sh	r0,r0[0x0]
8000247a:	c9 bc       	rcall	800025b0 <AudioRoutingControl_brdcst_func+0x78>
8000247c:	80 00       	ld.sh	r0,r0[0x0]
8000247e:	64 fc       	ld.w	r12,r2[0x3c]
80002480:	80 00       	ld.sh	r0,r0[0x0]
80002482:	c9 d0       	breq	800023bc <DataSession_brdcst_func+0x8>
80002484:	80 00       	ld.sh	r0,r0[0x0]
80002486:	c9 e4       	brge	800023c2 <DataSession_brdcst_func+0xe>
80002488:	80 00       	ld.sh	r0,r0[0x0]
8000248a:	c9 f8       	rjmp	800025c8 <Volume_reply_func>
8000248c:	80 00       	ld.sh	r0,r0[0x0]
8000248e:	ca 08       	rjmp	800025ce <Volume_reply_func+0x6>

80002490 <TransmitControl_brdcst_func>:

}


void TransmitControl_brdcst_func(xcmp_fragment_t * xcmp)
{
80002490:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//is_unmute = 1;
	
	TransmitControl_brdcast_t *ptr = (TransmitControl_brdcast_t* )xcmp->u8;
80002494:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  TransmitControl broadcast \n\r ");
	//log("\n\r  Mode_Of_Operation: %x \n\r ", ptr->Mode_Of_Operation );
	if (ptr->State == 0x00)
80002498:	0f 99       	ld.ub	r9,r7[0x1]
8000249a:	30 08       	mov	r8,0
8000249c:	f0 09 18 00 	cp.b	r9,r8
800024a0:	c0 71       	brne	800024ae <TransmitControl_brdcst_func+0x1e>
	{
		log("\n\r  Standby-Receive \n\r ");
800024a2:	48 ac       	lddpc	r12,800024c8 <TransmitControl_brdcst_func+0x38>
800024a4:	f0 1f 00 0a 	mcall	800024cc <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 0;
800024a8:	30 09       	mov	r9,0
800024aa:	48 a8       	lddpc	r8,800024d0 <TransmitControl_brdcst_func+0x40>
800024ac:	b0 89       	st.b	r8[0x0],r9
	}
	if (ptr->State == 0x01)
800024ae:	0f 99       	ld.ub	r9,r7[0x1]
800024b0:	30 18       	mov	r8,1
800024b2:	f0 09 18 00 	cp.b	r9,r8
800024b6:	c0 71       	brne	800024c4 <TransmitControl_brdcst_func+0x34>
	{
		log("\n\r  Transmit \n\r ");
800024b8:	48 7c       	lddpc	r12,800024d4 <TransmitControl_brdcst_func+0x44>
800024ba:	f0 1f 00 05 	mcall	800024cc <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 1;
800024be:	30 19       	mov	r9,1
800024c0:	48 48       	lddpc	r8,800024d0 <TransmitControl_brdcst_func+0x40>
800024c2:	b0 89       	st.b	r8[0x0],r9
800024c4:	e3 cd 80 80 	ldm	sp++,r7,pc
800024c8:	80 00       	ld.sh	r0,r0[0x0]
800024ca:	ca 18       	rjmp	8000260c <Volume_reply_func+0x44>
800024cc:	80 00       	ld.sh	r0,r0[0x0]
800024ce:	64 fc       	ld.w	r12,r2[0x3c]
800024d0:	00 00       	add	r0,r0
800024d2:	0a 50       	eor	r0,r5
800024d4:	80 00       	ld.sh	r0,r0[0x0]
800024d6:	ca 30       	breq	8000241c <DataSession_brdcst_func+0x68>

800024d8 <TransmitControl_reply_func>:




void TransmitControl_reply_func(xcmp_fragment_t * xcmp)
{
800024d8:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	TransmitControl_reply_t *ptr = (TransmitControl_reply_t* )xcmp->u8;
800024dc:	f8 c7 ff fe 	sub	r7,r12,-2
	
	if (ptr->Result == xcmp_Res_Success)
800024e0:	0f 89       	ld.ub	r9,r7[0x0]
800024e2:	30 08       	mov	r8,0
800024e4:	f0 09 18 00 	cp.b	r9,r8
800024e8:	c1 61       	brne	80002514 <TransmitControl_reply_func+0x3c>
	{
		
		log("\n\r  TransmitControl OK \n\r ");
800024ea:	48 ec       	lddpc	r12,80002520 <TransmitControl_reply_func+0x48>
800024ec:	f0 1f 00 0e 	mcall	80002524 <TransmitControl_reply_func+0x4c>
		log("\n\r Function: %x \n\r", ptr->Function);
800024f0:	0f 98       	ld.ub	r8,r7[0x1]
800024f2:	1a d8       	st.w	--sp,r8
800024f4:	48 dc       	lddpc	r12,80002528 <TransmitControl_reply_func+0x50>
800024f6:	f0 1f 00 0c 	mcall	80002524 <TransmitControl_reply_func+0x4c>
		log("\n\r Mode of Operation: %x \n\r", ptr->Mode_Of_Operation);
800024fa:	0f a8       	ld.ub	r8,r7[0x2]
800024fc:	1a d8       	st.w	--sp,r8
800024fe:	48 cc       	lddpc	r12,8000252c <TransmitControl_reply_func+0x54>
80002500:	f0 1f 00 09 	mcall	80002524 <TransmitControl_reply_func+0x4c>
		log("\n\r State: %x \n\r", ptr->State);
80002504:	0f b8       	ld.ub	r8,r7[0x3]
80002506:	1a d8       	st.w	--sp,r8
80002508:	48 ac       	lddpc	r12,80002530 <TransmitControl_reply_func+0x58>
8000250a:	f0 1f 00 07 	mcall	80002524 <TransmitControl_reply_func+0x4c>
8000250e:	2f dd       	sub	sp,-12
80002510:	e3 cd 80 80 	ldm	sp++,r7,pc
		
		//Silent_flag = 1;
	}
	else
	{
		log("TransmitControl error");
80002514:	48 8c       	lddpc	r12,80002534 <TransmitControl_reply_func+0x5c>
80002516:	f0 1f 00 04 	mcall	80002524 <TransmitControl_reply_func+0x4c>
8000251a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000251e:	00 00       	add	r0,r0
80002520:	80 00       	ld.sh	r0,r0[0x0]
80002522:	ca 44       	brge	8000246a <DataSession_reply_func+0x32>
80002524:	80 00       	ld.sh	r0,r0[0x0]
80002526:	64 fc       	ld.w	r12,r2[0x3c]
80002528:	80 00       	ld.sh	r0,r0[0x0]
8000252a:	ca 60       	breq	80002476 <DataSession_reply_func+0x3e>
8000252c:	80 00       	ld.sh	r0,r0[0x0]
8000252e:	ca 74       	brge	8000247c <DataSession_reply_func+0x44>
80002530:	80 00       	ld.sh	r0,r0[0x0]
80002532:	ca 90       	breq	80002484 <DataSession_reply_func+0x4c>
80002534:	80 00       	ld.sh	r0,r0[0x0]
80002536:	ca a0       	breq	8000248a <DataSession_reply_func+0x52>

80002538 <AudioRoutingControl_brdcst_func>:
	}
}


void AudioRoutingControl_brdcst_func(xcmp_fragment_t * xcmp)
{
80002538:	d4 31       	pushm	r0-r7,lr
8000253a:	18 95       	mov	r5,r12
	
	U16 num_routings = 0;
	U8 j = 0 ;
	
	num_routings = ((xcmp->u8[0]<< 8) | (xcmp->u8[1]) );
8000253c:	19 a3       	ld.ub	r3,r12[0x2]
8000253e:	19 b8       	ld.ub	r8,r12[0x3]
80002540:	f1 e3 10 83 	or	r3,r8,r3<<0x8
80002544:	5c 83       	casts.h	r3
	log("\n\r num_routings: %d \n\r", num_routings);
80002546:	f1 d3 c0 10 	bfextu	r8,r3,0x0,0x10
8000254a:	1a d8       	st.w	--sp,r8
8000254c:	49 ac       	lddpc	r12,800025b4 <AudioRoutingControl_brdcst_func+0x7c>
8000254e:	f0 1f 00 1b 	mcall	800025b8 <AudioRoutingControl_brdcst_func+0x80>
	
	for(j = 0; j< num_routings ; j++ )
80002552:	2f fd       	sub	sp,-4
80002554:	58 03       	cp.w	r3,0
80002556:	c2 d0       	breq	800025b0 <AudioRoutingControl_brdcst_func+0x78>
80002558:	30 07       	mov	r7,0
	{
		
		
		log("\n\r Audio-Input: %x \n\r", xcmp->u8[2+j*2]);
8000255a:	49 91       	lddpc	r1,800025bc <AudioRoutingControl_brdcst_func+0x84>
		log("\n\r Audio-Output: %x \n\r", xcmp->u8[3+j*2]);
8000255c:	49 90       	lddpc	r0,800025c0 <AudioRoutingControl_brdcst_func+0x88>
		if (xcmp->u8[2+j*2] == 0x0d)
8000255e:	30 d2       	mov	r2,13
	
	for(j = 0; j< num_routings ; j++ )
	{
		
		
		log("\n\r Audio-Input: %x \n\r", xcmp->u8[2+j*2]);
80002560:	ee c6 ff ff 	sub	r6,r7,-1
80002564:	ea 06 00 16 	add	r6,r5,r6<<0x1
80002568:	0d a8       	ld.ub	r8,r6[0x2]
8000256a:	1a d8       	st.w	--sp,r8
8000256c:	02 9c       	mov	r12,r1
8000256e:	f0 1f 00 13 	mcall	800025b8 <AudioRoutingControl_brdcst_func+0x80>
		log("\n\r Audio-Output: %x \n\r", xcmp->u8[3+j*2]);
80002572:	ee 04 15 01 	lsl	r4,r7,0x1
80002576:	2f d4       	sub	r4,-3
80002578:	ea 04 00 08 	add	r8,r5,r4
8000257c:	11 a8       	ld.ub	r8,r8[0x2]
8000257e:	1a d8       	st.w	--sp,r8
80002580:	00 9c       	mov	r12,r0
80002582:	f0 1f 00 0e 	mcall	800025b8 <AudioRoutingControl_brdcst_func+0x80>
		if (xcmp->u8[2+j*2] == 0x0d)
80002586:	2f ed       	sub	sp,-8
80002588:	0d a8       	ld.ub	r8,r6[0x2]
8000258a:	e4 08 18 00 	cp.b	r8,r2
8000258e:	c0 b1       	brne	800025a4 <AudioRoutingControl_brdcst_func+0x6c>
		{
			if (xcmp->u8[3+j*2] == 0x0c)
80002590:	ea 04 00 04 	add	r4,r5,r4
80002594:	09 a8       	ld.ub	r8,r4[0x2]
80002596:	30 c9       	mov	r9,12
80002598:	f2 08 18 00 	cp.b	r8,r9
8000259c:	c0 41       	brne	800025a4 <AudioRoutingControl_brdcst_func+0x6c>
			{
				//Speaker_is_unmute = 1;
				log("Speaker IA OK");
8000259e:	48 ac       	lddpc	r12,800025c4 <AudioRoutingControl_brdcst_func+0x8c>
800025a0:	f0 1f 00 06 	mcall	800025b8 <AudioRoutingControl_brdcst_func+0x80>
	U8 j = 0 ;
	
	num_routings = ((xcmp->u8[0]<< 8) | (xcmp->u8[1]) );
	log("\n\r num_routings: %d \n\r", num_routings);
	
	for(j = 0; j< num_routings ; j++ )
800025a4:	2f f7       	sub	r7,-1
800025a6:	5c 57       	castu.b	r7
800025a8:	ee 03 19 00 	cp.h	r3,r7
800025ac:	fe 9b ff da 	brhi	80002560 <AudioRoutingControl_brdcst_func+0x28>
800025b0:	d8 32       	popm	r0-r7,pc
800025b2:	00 00       	add	r0,r0
800025b4:	80 00       	ld.sh	r0,r0[0x0]
800025b6:	ca b8       	rjmp	8000270c <mic_reply_func+0x34>
800025b8:	80 00       	ld.sh	r0,r0[0x0]
800025ba:	64 fc       	ld.w	r12,r2[0x3c]
800025bc:	80 00       	ld.sh	r0,r0[0x0]
800025be:	ca d0       	breq	80002518 <TransmitControl_reply_func+0x40>
800025c0:	80 00       	ld.sh	r0,r0[0x0]
800025c2:	ca e8       	rjmp	8000271e <mic_reply_func+0x46>
800025c4:	80 00       	ld.sh	r0,r0[0x0]
800025c6:	cb 00       	breq	80002526 <TransmitControl_reply_func+0x4e>

800025c8 <Volume_reply_func>:
	
}


void Volume_reply_func(xcmp_fragment_t * xcmp)
{
800025c8:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	VolumeControl_reply_t *ptr = (VolumeControl_reply_t* )xcmp->u8;
800025cc:	f8 c7 ff fe 	sub	r7,r12,-2
	
		if (ptr->Result == xcmp_Res_Success)
800025d0:	0f 89       	ld.ub	r9,r7[0x0]
800025d2:	30 08       	mov	r8,0
800025d4:	f0 09 18 00 	cp.b	r9,r8
800025d8:	c1 b1       	brne	8000260e <Volume_reply_func+0x46>
		{
			if (ptr->Function == Enable_IntelligentAudio)
800025da:	0f b8       	ld.ub	r8,r7[0x3]
800025dc:	31 09       	mov	r9,16
800025de:	f2 08 18 00 	cp.b	r8,r9
800025e2:	c0 f1       	brne	80002600 <Volume_reply_func+0x38>
			{
				log("\n\r Enable_IA OK \n\r");
800025e4:	48 dc       	lddpc	r12,80002618 <Volume_reply_func+0x50>
800025e6:	f0 1f 00 0e 	mcall	8000261c <Volume_reply_func+0x54>
				log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
800025ea:	0f 99       	ld.ub	r9,r7[0x1]
800025ec:	0f a8       	ld.ub	r8,r7[0x2]
800025ee:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800025f2:	1a d8       	st.w	--sp,r8
800025f4:	48 bc       	lddpc	r12,80002620 <Volume_reply_func+0x58>
800025f6:	f0 1f 00 0a 	mcall	8000261c <Volume_reply_func+0x54>
800025fa:	2f fd       	sub	sp,-4
800025fc:	e3 cd 80 80 	ldm	sp++,r7,pc
	
			}
			else
			{
				
				log("\n\r VolumeControl: %x \n\r", ptr->Function);
80002600:	1a d8       	st.w	--sp,r8
80002602:	48 9c       	lddpc	r12,80002624 <Volume_reply_func+0x5c>
80002604:	f0 1f 00 06 	mcall	8000261c <Volume_reply_func+0x54>
80002608:	2f fd       	sub	sp,-4
8000260a:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		
		else
		{
			log("\n\r Enable_IA error \n\r");
8000260e:	48 7c       	lddpc	r12,80002628 <Volume_reply_func+0x60>
80002610:	f0 1f 00 03 	mcall	8000261c <Volume_reply_func+0x54>
80002614:	e3 cd 80 80 	ldm	sp++,r7,pc
80002618:	80 00       	ld.sh	r0,r0[0x0]
8000261a:	cb 10       	breq	8000257c <AudioRoutingControl_brdcst_func+0x44>
8000261c:	80 00       	ld.sh	r0,r0[0x0]
8000261e:	64 fc       	ld.w	r12,r2[0x3c]
80002620:	80 00       	ld.sh	r0,r0[0x0]
80002622:	cb 24       	brge	80002586 <AudioRoutingControl_brdcst_func+0x4e>
80002624:	80 00       	ld.sh	r0,r0[0x0]
80002626:	cb 40       	breq	8000258e <AudioRoutingControl_brdcst_func+0x56>
80002628:	80 00       	ld.sh	r0,r0[0x0]
8000262a:	cb 58       	rjmp	80002794 <dcm_brdcst_func+0x28>

8000262c <spk_brdcst_func>:
		log("spk error");
	}
}

void spk_brdcst_func(xcmp_fragment_t * xcmp)
{
8000262c:	d4 01       	pushm	lr
	if (xcmp->u8[3] == xcmp_Res_Success)//0x0000:mute
8000262e:	19 d9       	ld.ub	r9,r12[0x5]
80002630:	30 08       	mov	r8,0
80002632:	f0 09 18 00 	cp.b	r9,r8
80002636:	c0 81       	brne	80002646 <spk_brdcst_func+0x1a>
	{
		Speaker_is_unmute =0;
80002638:	10 99       	mov	r9,r8
8000263a:	48 68       	lddpc	r8,80002650 <spk_brdcst_func+0x24>
8000263c:	b0 89       	st.b	r8[0x0],r9
		//Silent_flag = 0;
		log("spk_s_close ");
8000263e:	48 6c       	lddpc	r12,80002654 <spk_brdcst_func+0x28>
80002640:	f0 1f 00 06 	mcall	80002658 <spk_brdcst_func+0x2c>
80002644:	d8 02       	popm	pc
	}
	else
	{
		//Silent_flag = 1;
		//Speaker_is_unmute = 1;
		log("spk_s_open ");
80002646:	48 6c       	lddpc	r12,8000265c <spk_brdcst_func+0x30>
80002648:	f0 1f 00 04 	mcall	80002658 <spk_brdcst_func+0x2c>
8000264c:	d8 02       	popm	pc
8000264e:	00 00       	add	r0,r0
80002650:	00 00       	add	r0,r0
80002652:	0a 40       	or	r0,r5
80002654:	80 00       	ld.sh	r0,r0[0x0]
80002656:	cb 70       	breq	800025c4 <AudioRoutingControl_brdcst_func+0x8c>
80002658:	80 00       	ld.sh	r0,r0[0x0]
8000265a:	64 fc       	ld.w	r12,r2[0x3c]
8000265c:	80 00       	ld.sh	r0,r0[0x0]
8000265e:	cb 80       	breq	800025ce <Volume_reply_func+0x6>

80002660 <spk_reply_func>:
			
	
}

void spk_reply_func(xcmp_fragment_t * xcmp)
{
80002660:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
80002662:	19 a9       	ld.ub	r9,r12[0x2]
80002664:	30 08       	mov	r8,0
80002666:	f0 09 18 00 	cp.b	r9,r8
8000266a:	c0 81       	brne	8000267a <spk_reply_func+0x1a>
		{
			//Speaker_is_unmute = 1;
			
			//Silent_flag = 1;
		}
		log("spk OK -st%2x", xcmp->u8[4] );
8000266c:	19 e8       	ld.ub	r8,r12[0x6]
8000266e:	1a d8       	st.w	--sp,r8
80002670:	48 5c       	lddpc	r12,80002684 <spk_reply_func+0x24>
80002672:	f0 1f 00 06 	mcall	80002688 <spk_reply_func+0x28>
80002676:	2f fd       	sub	sp,-4
80002678:	d8 02       	popm	pc
		
	}
	else
	{
		log("spk error");
8000267a:	48 5c       	lddpc	r12,8000268c <spk_reply_func+0x2c>
8000267c:	f0 1f 00 03 	mcall	80002688 <spk_reply_func+0x28>
80002680:	d8 02       	popm	pc
80002682:	00 00       	add	r0,r0
80002684:	80 00       	ld.sh	r0,r0[0x0]
80002686:	cb 8c       	rcall	800027f6 <dcm_reply_func+0x42>
80002688:	80 00       	ld.sh	r0,r0[0x0]
8000268a:	64 fc       	ld.w	r12,r2[0x3c]
8000268c:	80 00       	ld.sh	r0,r0[0x0]
8000268e:	cb 9c       	rcall	80002800 <dcm_reply_func+0x4c>

80002690 <mic_brdcst_func>:
	
	
}

void mic_brdcst_func(xcmp_fragment_t * xcmp)
{
80002690:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_brdcast_t *ptr = (MicControl_brdcast_t* )xcmp->u8;
80002694:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r Mic_brdcst \n\r");		
	//log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
	//log("\n\r Signal_type: %x \n\r " ,  ptr->Signaling_Type);
	if (ptr->Mic_State == 0x00)
80002698:	0f a9       	ld.ub	r9,r7[0x2]
8000269a:	30 08       	mov	r8,0
8000269c:	f0 09 18 00 	cp.b	r9,r8
800026a0:	c0 71       	brne	800026ae <mic_brdcst_func+0x1e>
	{
		log("\n\r Mic_Disabled \n\r");	
800026a2:	48 ac       	lddpc	r12,800026c8 <mic_brdcst_func+0x38>
800026a4:	f0 1f 00 0a 	mcall	800026cc <mic_brdcst_func+0x3c>
		Mic_is_Enabled = 0;
800026a8:	30 09       	mov	r9,0
800026aa:	48 a8       	lddpc	r8,800026d0 <mic_brdcst_func+0x40>
800026ac:	b0 89       	st.b	r8[0x0],r9
	} 
	if(ptr->Mic_State == 0x11)
800026ae:	0f a9       	ld.ub	r9,r7[0x2]
800026b0:	31 18       	mov	r8,17
800026b2:	f0 09 18 00 	cp.b	r9,r8
800026b6:	c0 71       	brne	800026c4 <mic_brdcst_func+0x34>
	{
		log("\n\r Mic_Enabled \n\r");	
800026b8:	48 7c       	lddpc	r12,800026d4 <mic_brdcst_func+0x44>
800026ba:	f0 1f 00 05 	mcall	800026cc <mic_brdcst_func+0x3c>
		Mic_is_Enabled = 1;
800026be:	30 19       	mov	r9,1
800026c0:	48 48       	lddpc	r8,800026d0 <mic_brdcst_func+0x40>
800026c2:	b0 89       	st.b	r8[0x0],r9
800026c4:	e3 cd 80 80 	ldm	sp++,r7,pc
800026c8:	80 00       	ld.sh	r0,r0[0x0]
800026ca:	cb a8       	rjmp	8000283e <ToneControl_reply_func+0x22>
800026cc:	80 00       	ld.sh	r0,r0[0x0]
800026ce:	64 fc       	ld.w	r12,r2[0x3c]
800026d0:	00 00       	add	r0,r0
800026d2:	0a 5b       	eor	r11,r5
800026d4:	80 00       	ld.sh	r0,r0[0x0]
800026d6:	cb bc       	rcall	8000284c <app_payload_rx_proc+0x8>

800026d8 <mic_reply_func>:
	
	
}

void mic_reply_func(xcmp_fragment_t * xcmp)
{
800026d8:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_reply_t *ptr = (MicControl_reply_t* )xcmp->u8;
800026dc:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Mic_reply \n\r");
800026e0:	49 ac       	lddpc	r12,80002748 <mic_reply_func+0x70>
800026e2:	f0 1f 00 1b 	mcall	8000274c <mic_reply_func+0x74>
	if (ptr->Result == 0x00)
800026e6:	0f 89       	ld.ub	r9,r7[0x0]
800026e8:	30 08       	mov	r8,0
800026ea:	f0 09 18 00 	cp.b	r9,r8
800026ee:	c2 71       	brne	8000273c <mic_reply_func+0x64>
	{
		
		if (ptr->Function == Mic_Disable)
800026f0:	0f 98       	ld.ub	r8,r7[0x1]
800026f2:	30 29       	mov	r9,2
800026f4:	f2 08 18 00 	cp.b	r8,r9
800026f8:	c1 b1       	brne	8000272e <mic_reply_func+0x56>
		{
		
			log("\n\r Mic_close_ok \n\r " );
800026fa:	49 6c       	lddpc	r12,80002750 <mic_reply_func+0x78>
800026fc:	f0 1f 00 14 	mcall	8000274c <mic_reply_func+0x74>
			log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
80002700:	0f a8       	ld.ub	r8,r7[0x2]
80002702:	1a d8       	st.w	--sp,r8
80002704:	49 4c       	lddpc	r12,80002754 <mic_reply_func+0x7c>
80002706:	f0 1f 00 12 	mcall	8000274c <mic_reply_func+0x74>
			log("\n\r Signaling_type: %x \n\r " ,  ptr->Signaling_Type);
8000270a:	0f b8       	ld.ub	r8,r7[0x3]
8000270c:	1a d8       	st.w	--sp,r8
8000270e:	49 3c       	lddpc	r12,80002758 <mic_reply_func+0x80>
80002710:	f0 1f 00 0f 	mcall	8000274c <mic_reply_func+0x74>
			log("\n\r Mic_state: %x \n\r " ,  ptr->Mic_State);
80002714:	0f c8       	ld.ub	r8,r7[0x4]
80002716:	1a d8       	st.w	--sp,r8
80002718:	49 1c       	lddpc	r12,8000275c <mic_reply_func+0x84>
8000271a:	f0 1f 00 0d 	mcall	8000274c <mic_reply_func+0x74>
			log("\n\r Gain_offset: %x \n\r " ,  ptr->Gain_Offset);
8000271e:	0f d8       	ld.ub	r8,r7[0x5]
80002720:	1a d8       	st.w	--sp,r8
80002722:	49 0c       	lddpc	r12,80002760 <mic_reply_func+0x88>
80002724:	f0 1f 00 0a 	mcall	8000274c <mic_reply_func+0x74>
80002728:	2f cd       	sub	sp,-16
8000272a:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else
		{
			log("\n\r Mic_function: %x \n\r ", ptr->Function );
8000272e:	1a d8       	st.w	--sp,r8
80002730:	48 dc       	lddpc	r12,80002764 <mic_reply_func+0x8c>
80002732:	f0 1f 00 07 	mcall	8000274c <mic_reply_func+0x74>
80002736:	2f fd       	sub	sp,-4
80002738:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else 
	{
		
	
		log("\n\r Mic error \n\r");
8000273c:	48 bc       	lddpc	r12,80002768 <mic_reply_func+0x90>
8000273e:	f0 1f 00 04 	mcall	8000274c <mic_reply_func+0x74>
80002742:	e3 cd 80 80 	ldm	sp++,r7,pc
80002746:	00 00       	add	r0,r0
80002748:	80 00       	ld.sh	r0,r0[0x0]
8000274a:	cb d0       	breq	800026c4 <mic_brdcst_func+0x34>
8000274c:	80 00       	ld.sh	r0,r0[0x0]
8000274e:	64 fc       	ld.w	r12,r2[0x3c]
80002750:	80 00       	ld.sh	r0,r0[0x0]
80002752:	cb e0       	breq	800026ce <mic_brdcst_func+0x3e>
80002754:	80 00       	ld.sh	r0,r0[0x0]
80002756:	cb f4       	brge	800026d4 <mic_brdcst_func+0x44>
80002758:	80 00       	ld.sh	r0,r0[0x0]
8000275a:	cc 08       	rjmp	800028da <AudioRoutingControl_reply_func+0x52>
8000275c:	80 00       	ld.sh	r0,r0[0x0]
8000275e:	cc 24       	brge	800026e2 <mic_reply_func+0xa>
80002760:	80 00       	ld.sh	r0,r0[0x0]
80002762:	cc 3c       	rcall	800028e8 <DeviceInitializationStatus_brdcst_func+0xc>
80002764:	80 00       	ld.sh	r0,r0[0x0]
80002766:	cc 54       	brge	800026f0 <mic_reply_func+0x18>
80002768:	80 00       	ld.sh	r0,r0[0x0]
8000276a:	cc 6c       	rcall	800028f6 <DeviceInitializationStatus_brdcst_func+0x1a>

8000276c <dcm_brdcst_func>:
	}
}


void dcm_brdcst_func(xcmp_fragment_t * xcmp)
{
8000276c:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	DeviceControlMode_brdcst_t *ptr = (DeviceControlMode_brdcst_t* )xcmp->u8;
80002770:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Dcm_brdcst \n\r");		
80002774:	48 bc       	lddpc	r12,800027a0 <dcm_brdcst_func+0x34>
80002776:	f0 1f 00 0c 	mcall	800027a4 <dcm_brdcst_func+0x38>
	log("\n\r Function: %x \n\r " ,  ptr->Function);
8000277a:	0f 88       	ld.ub	r8,r7[0x0]
8000277c:	1a d8       	st.w	--sp,r8
8000277e:	48 bc       	lddpc	r12,800027a8 <dcm_brdcst_func+0x3c>
80002780:	f0 1f 00 09 	mcall	800027a4 <dcm_brdcst_func+0x38>
	log("\n\r ControlType: %x \n\r " ,  ptr->ControlType);
80002784:	0f a8       	ld.ub	r8,r7[0x2]
80002786:	1a d8       	st.w	--sp,r8
80002788:	48 9c       	lddpc	r12,800027ac <dcm_brdcst_func+0x40>
8000278a:	f0 1f 00 07 	mcall	800027a4 <dcm_brdcst_func+0x38>
	log("\n\r ControlTypeSize: %x \n\r " ,  ptr->ControlTypeSize);
8000278e:	0f 98       	ld.ub	r8,r7[0x1]
80002790:	1a d8       	st.w	--sp,r8
80002792:	48 8c       	lddpc	r12,800027b0 <dcm_brdcst_func+0x44>
80002794:	f0 1f 00 04 	mcall	800027a4 <dcm_brdcst_func+0x38>
80002798:	2f dd       	sub	sp,-12
	
	
}
8000279a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000279e:	00 00       	add	r0,r0
800027a0:	80 00       	ld.sh	r0,r0[0x0]
800027a2:	cc 7c       	rcall	80002930 <payload_init>
800027a4:	80 00       	ld.sh	r0,r0[0x0]
800027a6:	64 fc       	ld.w	r12,r2[0x3c]
800027a8:	80 00       	ld.sh	r0,r0[0x0]
800027aa:	cc 90       	breq	8000273c <mic_reply_func+0x64>
800027ac:	80 00       	ld.sh	r0,r0[0x0]
800027ae:	cc a4       	brge	80002742 <mic_reply_func+0x6a>
800027b0:	80 00       	ld.sh	r0,r0[0x0]
800027b2:	cc bc       	rcall	80002948 <payload_init+0x18>

800027b4 <dcm_reply_func>:
		log("Tone error");
	}
}

void dcm_reply_func(xcmp_fragment_t * xcmp)
{
800027b4:	eb cd 40 80 	pushm	r7,lr
800027b8:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
800027ba:	19 a9       	ld.ub	r9,r12[0x2]
800027bc:	30 08       	mov	r8,0
800027be:	f0 09 18 00 	cp.b	r9,r8
800027c2:	c1 b1       	brne	800027f8 <dcm_reply_func+0x44>
	{
		if(xcmp->u8[1] == DCM_ENTER)
800027c4:	19 b8       	ld.ub	r8,r12[0x3]
800027c6:	30 19       	mov	r9,1
800027c8:	f2 08 18 00 	cp.b	r8,r9
800027cc:	c0 51       	brne	800027d6 <dcm_reply_func+0x22>
		{
			log("\n\r Dcm-Enter OK \n\r");
800027ce:	48 ec       	lddpc	r12,80002804 <dcm_reply_func+0x50>
800027d0:	f0 1f 00 0e 	mcall	80002808 <dcm_reply_func+0x54>
800027d4:	c0 a8       	rjmp	800027e8 <dcm_reply_func+0x34>
			
		}
		else if (xcmp->u8[1] == DCM_EXIT)
800027d6:	58 08       	cp.w	r8,0
800027d8:	c0 51       	brne	800027e2 <dcm_reply_func+0x2e>
		{
			log("\n\r Dcm-Exit OK \n\r");
800027da:	48 dc       	lddpc	r12,8000280c <dcm_reply_func+0x58>
800027dc:	f0 1f 00 0b 	mcall	80002808 <dcm_reply_func+0x54>
800027e0:	c0 48       	rjmp	800027e8 <dcm_reply_func+0x34>
		}
		else
		{
			log("\n\r Dcm-Revoke \n\r");
800027e2:	48 cc       	lddpc	r12,80002810 <dcm_reply_func+0x5c>
800027e4:	f0 1f 00 09 	mcall	80002808 <dcm_reply_func+0x54>
		}
		
		log("dcm OK-mo%X", xcmp->u8[3]);
800027e8:	0f d8       	ld.ub	r8,r7[0x5]
800027ea:	1a d8       	st.w	--sp,r8
800027ec:	48 ac       	lddpc	r12,80002814 <dcm_reply_func+0x60>
800027ee:	f0 1f 00 07 	mcall	80002808 <dcm_reply_func+0x54>
800027f2:	2f fd       	sub	sp,-4
800027f4:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		log("dcm error");
800027f8:	48 8c       	lddpc	r12,80002818 <dcm_reply_func+0x64>
800027fa:	f0 1f 00 04 	mcall	80002808 <dcm_reply_func+0x54>
800027fe:	e3 cd 80 80 	ldm	sp++,r7,pc
80002802:	00 00       	add	r0,r0
80002804:	80 00       	ld.sh	r0,r0[0x0]
80002806:	cc d8       	rjmp	800029a0 <payload_rx_process+0x38>
80002808:	80 00       	ld.sh	r0,r0[0x0]
8000280a:	64 fc       	ld.w	r12,r2[0x3c]
8000280c:	80 00       	ld.sh	r0,r0[0x0]
8000280e:	cc ec       	rcall	800029aa <payload_rx_process+0x42>
80002810:	80 00       	ld.sh	r0,r0[0x0]
80002812:	cd 00       	breq	800027b2 <dcm_brdcst_func+0x46>
80002814:	80 00       	ld.sh	r0,r0[0x0]
80002816:	cd 14       	brge	800027b8 <dcm_reply_func+0x4>
80002818:	80 00       	ld.sh	r0,r0[0x0]
8000281a:	cd 20       	breq	800027be <dcm_reply_func+0xa>

8000281c <ToneControl_reply_func>:
			}
		}
}

void ToneControl_reply_func(xcmp_fragment_t * xcmp)
{
8000281c:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
8000281e:	19 a9       	ld.ub	r9,r12[0x2]
80002820:	30 08       	mov	r8,0
80002822:	f0 09 18 00 	cp.b	r9,r8
80002826:	c0 51       	brne	80002830 <ToneControl_reply_func+0x14>
	{		
		log("Tone OK");
80002828:	48 4c       	lddpc	r12,80002838 <ToneControl_reply_func+0x1c>
8000282a:	f0 1f 00 05 	mcall	8000283c <ToneControl_reply_func+0x20>
8000282e:	d8 02       	popm	pc
		//fl_write("/test.txt", FILE_END, (void *)"send tone ok\r\n", sizeof("send tone ok\r\n") - 1);
	}
	else
	{
		log("Tone error");
80002830:	48 4c       	lddpc	r12,80002840 <ToneControl_reply_func+0x24>
80002832:	f0 1f 00 03 	mcall	8000283c <ToneControl_reply_func+0x20>
80002836:	d8 02       	popm	pc
80002838:	80 00       	ld.sh	r0,r0[0x0]
8000283a:	cd 2c       	rcall	800029de <phy_rx+0xe>
8000283c:	80 00       	ld.sh	r0,r0[0x0]
8000283e:	64 fc       	ld.w	r12,r2[0x3c]
80002840:	80 00       	ld.sh	r0,r0[0x0]
80002842:	cd 34       	brge	800027e8 <dcm_reply_func+0x34>

80002844 <app_payload_rx_proc>:
	}
}


static void app_payload_rx_proc(void  * payload)
{
80002844:	eb cd 40 80 	pushm	r7,lr
80002848:	18 97       	mov	r7,r12
	static  U8 times_counter = 0;
	
	times_counter++;
8000284a:	48 b9       	lddpc	r9,80002874 <app_payload_rx_proc+0x30>
8000284c:	13 88       	ld.ub	r8,r9[0x0]
8000284e:	2f f8       	sub	r8,-1
80002850:	b2 88       	st.b	r9[0x0],r8
	if (times_counter == 110)
80002852:	36 e9       	mov	r9,110
80002854:	f2 08 18 00 	cp.b	r8,r9
80002858:	c0 71       	brne	80002866 <app_payload_rx_proc+0x22>
	{
		times_counter = 0 ;
8000285a:	30 09       	mov	r9,0
8000285c:	48 68       	lddpc	r8,80002874 <app_payload_rx_proc+0x30>
8000285e:	b0 89       	st.b	r8[0x0],r9
		log("\n\r w: \n\r");
80002860:	48 6c       	lddpc	r12,80002878 <app_payload_rx_proc+0x34>
80002862:	f0 1f 00 07 	mcall	8000287c <app_payload_rx_proc+0x38>
	{
		//fl_write("PCMvo.pcm", FILE_END, payload, MAX_PAYLOAD_BUFF_SIZE * 2);
	}
	
	//payload_fragment_t * ptr = (payload_fragment_t *)payload;
	set_payload_idle(payload);
80002866:	48 78       	lddpc	r8,80002880 <app_payload_rx_proc+0x3c>
80002868:	70 0c       	ld.w	r12,r8[0x0]
8000286a:	0e 9b       	mov	r11,r7
8000286c:	f0 1f 00 06 	mcall	80002884 <app_payload_rx_proc+0x40>

}
80002870:	e3 cd 80 80 	ldm	sp++,r7,pc
80002874:	00 00       	add	r0,r0
80002876:	0a 59       	eor	r9,r5
80002878:	80 00       	ld.sh	r0,r0[0x0]
8000287a:	cd 40       	breq	80002822 <ToneControl_reply_func+0x6>
8000287c:	80 00       	ld.sh	r0,r0[0x0]
8000287e:	64 fc       	ld.w	r12,r2[0x3c]
80002880:	00 00       	add	r0,r0
80002882:	0a 78       	tst	r8,r5
80002884:	80 00       	ld.sh	r0,r0[0x0]
80002886:	2a 08       	sub	r8,-96

80002888 <AudioRoutingControl_reply_func>:
	
}


void AudioRoutingControl_reply_func(xcmp_fragment_t * xcmp)
{
80002888:	eb cd 40 80 	pushm	r7,lr
8000288c:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
8000288e:	19 a9       	ld.ub	r9,r12[0x2]
80002890:	30 08       	mov	r8,0
80002892:	f0 09 18 00 	cp.b	r9,r8
80002896:	c0 e1       	brne	800028b2 <AudioRoutingControl_reply_func+0x2a>
	{
		
		log("AudioRouting OK");
80002898:	48 cc       	lddpc	r12,800028c8 <AudioRoutingControl_reply_func+0x40>
8000289a:	f0 1f 00 0d 	mcall	800028cc <AudioRoutingControl_reply_func+0x44>
		xcmp_IdleTestTone();//提示通道配置成功
8000289e:	f0 1f 00 0d 	mcall	800028d0 <AudioRoutingControl_reply_func+0x48>
		xcmp_IdleTestTone();
800028a2:	f0 1f 00 0c 	mcall	800028d0 <AudioRoutingControl_reply_func+0x48>
		xcmp_IdleTestTone();
800028a6:	f0 1f 00 0b 	mcall	800028d0 <AudioRoutingControl_reply_func+0x48>
		xcmp_IdleTestTone();
800028aa:	f0 1f 00 0a 	mcall	800028d0 <AudioRoutingControl_reply_func+0x48>
800028ae:	e3 cd 80 80 	ldm	sp++,r7,pc
		//is_unmute = 1;
	}
	else
	{
		log("AudioRouting error");
800028b2:	48 9c       	lddpc	r12,800028d4 <AudioRoutingControl_reply_func+0x4c>
800028b4:	f0 1f 00 06 	mcall	800028cc <AudioRoutingControl_reply_func+0x44>
		log("\n\r AudioRouting result: %x \n\r", xcmp->u8[0]);
800028b8:	0f a8       	ld.ub	r8,r7[0x2]
800028ba:	1a d8       	st.w	--sp,r8
800028bc:	48 7c       	lddpc	r12,800028d8 <AudioRoutingControl_reply_func+0x50>
800028be:	f0 1f 00 04 	mcall	800028cc <AudioRoutingControl_reply_func+0x44>
800028c2:	2f fd       	sub	sp,-4
800028c4:	e3 cd 80 80 	ldm	sp++,r7,pc
800028c8:	80 00       	ld.sh	r0,r0[0x0]
800028ca:	cd 4c       	rcall	80002a72 <phy_tx+0x4a>
800028cc:	80 00       	ld.sh	r0,r0[0x0]
800028ce:	64 fc       	ld.w	r12,r2[0x3c]
800028d0:	80 00       	ld.sh	r0,r0[0x0]
800028d2:	42 d0       	lddsp	r0,sp[0xb4]
800028d4:	80 00       	ld.sh	r0,r0[0x0]
800028d6:	cd 5c       	rcall	80002a80 <phy_tx+0x58>
800028d8:	80 00       	ld.sh	r0,r0[0x0]
800028da:	cd 70       	breq	80002888 <AudioRoutingControl_reply_func>

800028dc <DeviceInitializationStatus_brdcst_func>:
static void app_payload_tx_proc(void  * payload);

//app func--list

void DeviceInitializationStatus_brdcst_func(xcmp_fragment_t  * xcmp)
{
800028dc:	d4 01       	pushm	lr
	if (xcmp->u8[4] == 0x01)
800028de:	19 e8       	ld.ub	r8,r12[0x6]
800028e0:	30 19       	mov	r9,1
800028e2:	f2 08 18 00 	cp.b	r8,r9
800028e6:	c0 61       	brne	800028f2 <DeviceInitializationStatus_brdcst_func+0x16>
	{
		bunchofrandomstatusflags |= 0x01;  //Need do nothing else.
800028e8:	48 98       	lddpc	r8,8000290c <DeviceInitializationStatus_brdcst_func+0x30>
800028ea:	70 09       	ld.w	r9,r8[0x0]
800028ec:	a1 a9       	sbr	r9,0x0
800028ee:	91 09       	st.w	r8[0x0],r9
800028f0:	d8 02       	popm	pc
	}
	else if(xcmp->u8[4] != 0x02)
800028f2:	30 29       	mov	r9,2
800028f4:	f2 08 18 00 	cp.b	r8,r9
800028f8:	c0 80       	breq	80002908 <DeviceInitializationStatus_brdcst_func+0x2c>
	{
		bunchofrandomstatusflags  &= 0xFFFFFFFC; //Device Init no longer Complete.
800028fa:	48 58       	lddpc	r8,8000290c <DeviceInitializationStatus_brdcst_func+0x30>
800028fc:	70 09       	ld.w	r9,r8[0x0]
800028fe:	e0 19 ff fc 	andl	r9,0xfffc
80002902:	91 09       	st.w	r8[0x0],r9
		xcmp_DeviceInitializationStatus_request();
80002904:	f0 1f 00 03 	mcall	80002910 <DeviceInitializationStatus_brdcst_func+0x34>
80002908:	d8 02       	popm	pc
8000290a:	00 00       	add	r0,r0
8000290c:	00 00       	add	r0,r0
8000290e:	0d b0       	ld.ub	r0,r6[0x3]
80002910:	80 00       	ld.sh	r0,r0[0x0]
80002912:	42 24       	lddsp	r4,sp[0x88]

80002914 <CalculateBurst>:
Calls:
Called By: phy_payload_rx
*/

volatile RxAMBEBurstType CalculateBurst(U8 vf_sn)
{
80002914:	20 1c       	sub	r12,1
80002916:	5c 5c       	castu.b	r12
80002918:	31 18       	mov	r8,17
8000291a:	f0 0c 18 00 	cp.b	r12,r8
8000291e:	e0 88 00 03 	brls	80002924 <CalculateBurst+0x10>
80002922:	5e fd       	retal	0
80002924:	48 28       	lddpc	r8,8000292c <CalculateBurst+0x18>
80002926:	f0 0c 03 2c 	ld.w	r12,r8[r12<<0x2]
			Burst_ID = 0x00;
			return VOICE_WATING;
		
	}
	
}
8000292a:	5e fc       	retal	r12
8000292c:	80 00       	ld.sh	r0,r0[0x0]
8000292e:	cd 90       	breq	800028e0 <DeviceInitializationStatus_brdcst_func+0x4>

80002930 <payload_init>:
	Create the corresponding task;
Calls: xTaskCreate--freertos
Called By:app_init -- app.c
*/
void payload_init(void ( *payload_rx_func)(void * ), void ( *payload_tx_func)(void * ) )
{				
80002930:	d4 01       	pushm	lr
	payload_rx_exec = payload_rx_func;
80002932:	48 98       	lddpc	r8,80002954 <payload_init+0x24>
80002934:	91 0c       	st.w	r8[0x0],r12
	payload_tx_exec = payload_tx_func;
80002936:	48 98       	lddpc	r8,80002958 <payload_init+0x28>
80002938:	91 0b       	st.w	r8[0x0],r11
	
	
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
8000293a:	30 09       	mov	r9,0
8000293c:	1a d9       	st.w	--sp,r9
8000293e:	1a d9       	st.w	--sp,r9
80002940:	1a d9       	st.w	--sp,r9
80002942:	30 28       	mov	r8,2
80002944:	e0 6a 04 00 	mov	r10,1024
80002948:	48 5b       	lddpc	r11,8000295c <payload_init+0x2c>
8000294a:	48 6c       	lddpc	r12,80002960 <payload_init+0x30>
8000294c:	f0 1f 00 06 	mcall	80002964 <payload_init+0x34>
80002950:	2f dd       	sub	sp,-12
	//,  2
	//,  NULL
	//);
	//
	
}
80002952:	d8 02       	popm	pc
80002954:	00 00       	add	r0,r0
80002956:	0a 64       	and	r4,r5
80002958:	00 00       	add	r0,r0
8000295a:	0a 68       	and	r8,r5
8000295c:	80 00       	ld.sh	r0,r0[0x0]
8000295e:	d3 88       	*unknown*
80002960:	80 00       	ld.sh	r0,r0[0x0]
80002962:	29 68       	sub	r8,-106
80002964:	80 00       	ld.sh	r0,r0[0x0]
80002966:	61 38       	ld.w	r8,r0[0x4c]

80002968 <payload_rx_process>:
Description: Receive the payload
Calls:
Called By:task
*/
static void payload_rx_process(void * pvParameters)
{
80002968:	eb cd 40 f8 	pushm	r3-r7,lr
8000296c:	20 1d       	sub	sp,4
	/*To store the elements in the queue*/
	U16  * payload_ptr;
		
	if(NULL ==   phy_payload_frame_rx)
8000296e:	48 e8       	lddpc	r8,800029a4 <payload_rx_process+0x3c>
80002970:	70 08       	ld.w	r8,r8[0x0]
80002972:	58 08       	cp.w	r8,0
80002974:	c0 71       	brne	80002982 <payload_rx_process+0x1a>
	{
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
80002976:	30 4b       	mov	r11,4
80002978:	30 5c       	mov	r12,5
8000297a:	f0 1f 00 0c 	mcall	800029a8 <payload_rx_process+0x40>
8000297e:	48 a8       	lddpc	r8,800029a4 <payload_rx_process+0x3c>
80002980:	91 0c       	st.w	r8[0x0],r12
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_rx, &payload_ptr,portMAX_DELAY ))
80002982:	48 96       	lddpc	r6,800029a4 <payload_rx_process+0x3c>
80002984:	30 05       	mov	r5,0
80002986:	3f f4       	mov	r4,-1
		{			
			payload_rx_exec(payload_ptr);//app_payload_rx_proc();//此处跳转。。。。
80002988:	48 93       	lddpc	r3,800029ac <payload_rx_process+0x44>
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_rx, &payload_ptr,portMAX_DELAY ))
8000298a:	6c 0c       	ld.w	r12,r6[0x0]
8000298c:	0a 99       	mov	r9,r5
8000298e:	08 9a       	mov	r10,r4
80002990:	1a 9b       	mov	r11,sp
80002992:	f0 1f 00 08 	mcall	800029b0 <payload_rx_process+0x48>
80002996:	58 1c       	cp.w	r12,1
80002998:	cf 91       	brne	8000298a <payload_rx_process+0x22>
		{			
			payload_rx_exec(payload_ptr);//app_payload_rx_proc();//此处跳转。。。。
8000299a:	66 08       	ld.w	r8,r3[0x0]
8000299c:	40 0c       	lddsp	r12,sp[0x0]
8000299e:	5d 18       	icall	r8
800029a0:	cf 5b       	rjmp	8000298a <payload_rx_process+0x22>
800029a2:	00 00       	add	r0,r0
800029a4:	00 00       	add	r0,r0
800029a6:	0a 7c       	tst	r12,r5
800029a8:	80 00       	ld.sh	r0,r0[0x0]
800029aa:	5a 64       	cp.w	r4,-26
800029ac:	00 00       	add	r0,r0
800029ae:	0a 64       	and	r4,r5
800029b0:	80 00       	ld.sh	r0,r0[0x0]
800029b2:	57 00       	stdsp	sp[0x1c0],r0

800029b4 <set_idle_store_isr>:
{
	xQueueSend(store, &ptr, 0);
}

void set_idle_store_isr(xQueueHandle store, void * ptr)
{
800029b4:	d4 01       	pushm	lr
800029b6:	20 2d       	sub	sp,8
800029b8:	50 0b       	stdsp	sp[0x0],r11
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
800029ba:	30 09       	mov	r9,0
800029bc:	fa ca ff f8 	sub	r10,sp,-8
800029c0:	14 d9       	st.w	--r10,r9
	xQueueSendFromISR(store, &ptr, &xHigherPriorityTaskWoken);
800029c2:	1a 9b       	mov	r11,sp
800029c4:	f0 1f 00 02 	mcall	800029cc <set_idle_store_isr+0x18>
}
800029c8:	2f ed       	sub	sp,-8
800029ca:	d8 02       	popm	pc
800029cc:	80 00       	ld.sh	r0,r0[0x0]
800029ce:	58 bc       	cp.w	r12,11

800029d0 <phy_rx>:
	xQueueSendFromISR -- freertos
Called By: phy_xnl_rx
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
800029d0:	d4 01       	pushm	lr
800029d2:	20 2d       	sub	sp,8
800029d4:	50 0c       	stdsp	sp[0x0],r12
	//memcpy(xx, phy_ptr, sizeof(phy_fragment_t));
	//set_phy_idle_isr(&phy_ptr, &xHigherPriorityTaskWoken);
	
	Bool res = FALSE;
	
	if(NULL == phy_ptr)
800029d6:	58 0c       	cp.w	r12,0
800029d8:	c1 10       	breq	800029fa <phy_rx+0x2a>
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
    /*variables are used to store the push result in interrupt*/
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
800029da:	30 08       	mov	r8,0
800029dc:	50 18       	stdsp	sp[0x4],r8
	if(NULL == phy_ptr)
	{
		return;
	}
	
    U16 phy_ctrl = phy_ptr->xnl_fragment.phy_header.phy_control;
800029de:	98 88       	ld.uh	r8,r12[0x0]
800029e0:	e2 18 f0 00 	andl	r8,0xf000,COH
800029e4:	e0 48 40 00 	cp.w	r8,16384
800029e8:	c0 91       	brne	800029fa <phy_rx+0x2a>

    if (XCMPXNL_DATA == (phy_ctrl & 0xF000))
    {
        /*push the xnl packet to queue*/
        if( pdTRUE == xQueueSendFromISR(
800029ea:	48 68       	lddpc	r8,80002a00 <phy_rx+0x30>
800029ec:	70 0c       	ld.w	r12,r8[0x0]
800029ee:	30 09       	mov	r9,0
800029f0:	fa ca ff fc 	sub	r10,sp,-4
800029f4:	1a 9b       	mov	r11,sp
800029f6:	f0 1f 00 04 	mcall	80002a04 <phy_rx+0x34>
		}	

    }
		
 
}
800029fa:	2f ed       	sub	sp,-8
800029fc:	d8 02       	popm	pc
800029fe:	00 00       	add	r0,r0
80002a00:	00 00       	add	r0,r0
80002a02:	0a bc       	st.h	r5++,r12
80002a04:	80 00       	ld.sh	r0,r0[0x0]
80002a06:	58 bc       	cp.w	r12,11

80002a08 <set_idle_store>:
	}
}


void set_idle_store(xQueueHandle store, void * ptr)
{
80002a08:	eb cd 40 80 	pushm	r7,lr
80002a0c:	20 1d       	sub	sp,4
80002a0e:	fa c7 ff fc 	sub	r7,sp,-4
80002a12:	0e db       	st.w	--r7,r11
	xQueueSend(store, &ptr, 0);
80002a14:	30 09       	mov	r9,0
80002a16:	12 9a       	mov	r10,r9
80002a18:	1a 9b       	mov	r11,sp
80002a1a:	f0 1f 00 03 	mcall	80002a24 <set_idle_store+0x1c>
}
80002a1e:	2f fd       	sub	sp,-4
80002a20:	e3 cd 80 80 	ldm	sp++,r7,pc
80002a24:	80 00       	ld.sh	r0,r0[0x0]
80002a26:	59 0c       	cp.w	r12,16

80002a28 <phy_tx>:
Calls:   
	xQueueSend -- freertos
Called By: xnl_tx -- xnl.c
*/
void phy_tx(phy_fragment_t * phy)
{	
80002a28:	d4 01       	pushm	lr
80002a2a:	20 1d       	sub	sp,4
80002a2c:	50 0c       	stdsp	sp[0x0],r12
	
	//phy_fragment_t * phy_ptr = malloc(sizeof(phy_fragment_t));
	//memcpy(phy_ptr, phy, sizeof(phy_fragment_t));
	//log("\n\r T_xcmp:%4x \n\r", phy->xnl_fragment.xnl_payload.xnl_content_data_msg.xcmp_opcode);
	//log("T_xnl-opcode:%4x", xnl->xnl_header.opcode);//log:R_xnl指令	
	if(XCMPXNL_DATA == (phy_ctrl & 0xF000))
80002a2e:	98 88       	ld.uh	r8,r12[0x0]
80002a30:	e2 18 f0 00 	andl	r8,0xf000,COH
80002a34:	e0 48 40 00 	cp.w	r8,16384
80002a38:	c0 d1       	brne	80002a52 <phy_tx+0x2a>
	{
		/*push the xnl packet to queue to send */
		if(NULL != phy_xnl_frame_tx)
80002a3a:	49 08       	lddpc	r8,80002a78 <phy_tx+0x50>
80002a3c:	70 08       	ld.w	r8,r8[0x0]
80002a3e:	58 08       	cp.w	r8,0
80002a40:	c1 a0       	breq	80002a74 <phy_tx+0x4c>
		{
			if( pdTRUE == xQueueSend(phy_xnl_frame_tx, &phy, 0))
80002a42:	48 e8       	lddpc	r8,80002a78 <phy_tx+0x50>
80002a44:	70 0c       	ld.w	r12,r8[0x0]
80002a46:	30 09       	mov	r9,0
80002a48:	12 9a       	mov	r10,r9
80002a4a:	1a 9b       	mov	r11,sp
80002a4c:	f0 1f 00 0c 	mcall	80002a7c <phy_tx+0x54>
80002a50:	c1 28       	rjmp	80002a74 <phy_tx+0x4c>
		}
	}
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE		
	else if((SPEAKER_DATA == (phy_ctrl & 0xF000))
80002a52:	e0 48 10 00 	cp.w	r8,4096
80002a56:	5f 0a       	sreq	r10
80002a58:	e0 48 20 00 	cp.w	r8,8192
80002a5c:	5f 09       	sreq	r9
80002a5e:	f5 e9 10 09 	or	r9,r10,r9
80002a62:	c0 71       	brne	80002a70 <phy_tx+0x48>
80002a64:	e0 48 50 00 	cp.w	r8,20480
80002a68:	c0 40       	breq	80002a70 <phy_tx+0x48>
80002a6a:	e0 48 60 00 	cp.w	r8,24576
80002a6e:	c0 31       	brne	80002a74 <phy_tx+0x4c>
	    || (MIC_DATA  == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_RX == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_TX == (phy_ctrl & 0xF000))
	)
	{		
		if(NULL == phy_payload_frame_tx)
80002a70:	48 48       	lddpc	r8,80002a80 <phy_tx+0x58>
80002a72:	70 08       	ld.w	r8,r8[0x0]
	
	if(res != TRUE)
	{
		//vPortFree(phy_ptr);
	}
}
80002a74:	2f fd       	sub	sp,-4
80002a76:	d8 02       	popm	pc
80002a78:	00 00       	add	r0,r0
80002a7a:	0a d8       	st.w	--r5,r8
80002a7c:	80 00       	ld.sh	r0,r0[0x0]
80002a7e:	59 0c       	cp.w	r12,16
80002a80:	00 00       	add	r0,r0
80002a82:	0a b0       	st.h	r5++,r0

80002a84 <get_idle_store_isr>:
		return NULL;
	}
}

void * get_idle_store_isr(xQueueHandle store)
{
80002a84:	d4 01       	pushm	lr
80002a86:	20 2d       	sub	sp,8
	void * ptr = NULL;
80002a88:	30 08       	mov	r8,0
80002a8a:	50 18       	stdsp	sp[0x4],r8
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002a8c:	50 08       	stdsp	sp[0x0],r8
	
	if(pdTRUE == xQueueReceiveFromISR(store, &ptr, &xHigherPriorityTaskWoken))
80002a8e:	1a 9a       	mov	r10,sp
80002a90:	fa cb ff fc 	sub	r11,sp,-4
80002a94:	f0 1f 00 05 	mcall	80002aa8 <get_idle_store_isr+0x24>
80002a98:	58 1c       	cp.w	r12,1
80002a9a:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80002a9e:	fb fc 00 01 	ld.weq	r12,sp[0x4]
	}
	else
	{
		return NULL;
	}
}
80002aa2:	2f ed       	sub	sp,-8
80002aa4:	d8 02       	popm	pc
80002aa6:	00 00       	add	r0,r0
80002aa8:	80 00       	ld.sh	r0,r0[0x0]
80002aaa:	56 10       	stdsp	sp[0x184],r0

80002aac <phy_tx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_tx_func( void * ssc)
{
80002aac:	eb cd 40 c0 	pushm	r6-r7,lr
80002ab0:	20 1d       	sub	sp,4
80002ab2:	18 97       	mov	r7,r12
    if(NULL != phy_xnl_frame_tx)
80002ab4:	fe f8 04 78 	ld.w	r8,pc[1144]
80002ab8:	70 08       	ld.w	r8,r8[0x0]
80002aba:	58 08       	cp.w	r8,0
80002abc:	c7 40       	breq	80002ba4 <phy_tx_func+0xf8>
    {
  	  	/*send ssc data in xnl frame*/
  	  	phy_xnl_tx(&(((ssc_fragment_t * )ssc)->xnl_channel));		
80002abe:	18 96       	mov	r6,r12
Called By:phy_tx_func
*/
static void phy_xnl_tx(xnl_channel_t * xnl_tx_channel)
{
	/*variables are used to store the push result in interrupt*/
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002ac0:	30 08       	mov	r8,0
80002ac2:	50 08       	stdsp	sp[0x0],r8
	
	static S16 phy_tx_expexted_length = 0;
	static U8 phy_tx_index = 0;
	
	/*his is the code for handling any outgoing XNL Phy message*/
	switch(phy_tx_state)
80002ac4:	fe f8 04 6c 	ld.w	r8,pc[1132]
80002ac8:	70 08       	ld.w	r8,r8[0x0]
80002aca:	58 18       	cp.w	r8,1
80002acc:	c2 90       	breq	80002b1e <phy_tx_func+0x72>
80002ace:	c0 43       	brcs	80002ad6 <phy_tx_func+0x2a>
80002ad0:	58 28       	cp.w	r8,2
80002ad2:	c6 91       	brne	80002ba4 <phy_tx_func+0xf8>
80002ad4:	c6 18       	rjmp	80002b96 <phy_tx_func+0xea>
	{
		/*Waiting for the send xnl packet*/
		case WAITING_FOR_PHY_TX:			
			if( pdTRUE == xQueueReceiveFromISR(
80002ad6:	fe f8 04 56 	ld.w	r8,pc[1110]
80002ada:	70 0c       	ld.w	r12,r8[0x0]
80002adc:	1a 9a       	mov	r10,sp
80002ade:	fe fb 04 56 	ld.w	r11,pc[1110]
80002ae2:	f0 1f 01 16 	mcall	80002f38 <phy_tx_func+0x48c>
80002ae6:	58 1c       	cp.w	r12,1
80002ae8:	c1 51       	brne	80002b12 <phy_tx_func+0x66>
				  phy_xnl_frame_tx
				, &phy_ptr
				, &xHigherPriorityTaskWoken 
			))
			{								
				phy_tx_expexted_length = 
80002aea:	fe f8 04 4a 	ld.w	r8,pc[1098]
80002aee:	70 08       	ld.w	r8,r8[0x0]
80002af0:	11 9a       	ld.ub	r10,r8[0x1]
80002af2:	fe f9 04 4a 	ld.w	r9,pc[1098]
80002af6:	b2 0a       	st.h	r9[0x0],r10
				*/
				xnl_tx_channel->dword = 
				                   phy_ptr->xnl_fragment.phy_header.phy_control;
				
				/*Transmit 0xABCD0000 | Type/Length.*/
				xnl_tx_channel->dword |= PHYHEADER32;
80002af8:	90 88       	ld.uh	r8,r8[0x0]
80002afa:	ea 18 ab cd 	orh	r8,0xabcd
80002afe:	8f 18       	st.w	r7[0x4],r8
				
				phy_tx_index = 1;
80002b00:	30 19       	mov	r9,1
80002b02:	fe f8 04 3e 	ld.w	r8,pc[1086]
80002b06:	b0 89       	st.b	r8[0x0],r9
				phy_tx_state = WRITE_NEXT_DWORD;	
80002b08:	30 19       	mov	r9,1
80002b0a:	fe f8 04 26 	ld.w	r8,pc[1062]
80002b0e:	91 09       	st.w	r8[0x0],r9
80002b10:	c4 a8       	rjmp	80002ba4 <phy_tx_func+0xf8>
				/*The new transmission has started.*/
			}
			else
			{
				/*Nothing new to transmit, send an idle frame*/
				xnl_tx_channel->dword = XNL_IDLE;
80002b12:	e0 68 5a 5a 	mov	r8,23130
80002b16:	ea 18 ab cd 	orh	r8,0xabcd
80002b1a:	8f 18       	st.w	r7[0x4],r8
80002b1c:	c4 48       	rjmp	80002ba4 <phy_tx_func+0xf8>
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80002b1e:	fe f9 04 22 	ld.w	r9,pc[1058]
80002b22:	13 88       	ld.ub	r8,r9[0x0]
				xnl_tx_channel->dword = XNL_IDLE;
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
80002b24:	fe fa 04 10 	ld.w	r10,pc[1040]
80002b28:	74 0a       	ld.w	r10,r10[0x0]
80002b2a:	f4 08 05 1a 	ld.uh	r10,r10[r8<<0x1]
80002b2e:	b1 6a       	lsl	r10,0x10
80002b30:	99 1a       	st.w	r12[0x4],r10
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80002b32:	2f f8       	sub	r8,-1
80002b34:	5c 58       	castu.b	r8
80002b36:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
80002b38:	fe fa 04 04 	ld.w	r10,pc[1028]
80002b3c:	94 09       	ld.sh	r9,r10[0x0]
80002b3e:	20 29       	sub	r9,2
80002b40:	b4 09       	st.h	r10[0x0],r9
			
			/*have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80002b42:	30 0a       	mov	r10,0
80002b44:	f4 09 19 00 	cp.h	r9,r10
80002b48:	e0 89 00 0b 	brgt	80002b5e <phy_tx_func+0xb2>
			{
				/*Must immediately send 0x00BA in Slot 4.*/
				xnl_tx_channel->dword |= PHYTERMRIGHT;
80002b4c:	78 18       	ld.w	r8,r12[0x4]
80002b4e:	e8 18 00 ba 	orl	r8,0xba
80002b52:	99 18       	st.w	r12[0x4],r8
				
				/*Go back to waiting.*/
				//vPortFree(phy_ptr);
				phy_tx_state = WAITING_FOR_PHY_TX;
80002b54:	30 09       	mov	r9,0
80002b56:	fe f8 03 da 	ld.w	r8,pc[986]
80002b5a:	91 09       	st.w	r8[0x0],r9
80002b5c:	c2 48       	rjmp	80002ba4 <phy_tx_func+0xf8>
				break;
			}

			/*Have not broken. Transmit 2nd hWord.*/
			xnl_tx_channel->dword |=  phy_ptr->fragment_element[phy_tx_index++];
80002b5e:	fe f9 03 d6 	ld.w	r9,pc[982]
80002b62:	72 09       	ld.w	r9,r9[0x0]
80002b64:	f2 08 05 19 	ld.uh	r9,r9[r8<<0x1]
80002b68:	78 1a       	ld.w	r10,r12[0x4]
80002b6a:	f5 e9 10 09 	or	r9,r10,r9
80002b6e:	99 19       	st.w	r12[0x4],r9
80002b70:	2f f8       	sub	r8,-1
80002b72:	fe f9 03 ce 	ld.w	r9,pc[974]
80002b76:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
80002b78:	fe f9 03 c4 	ld.w	r9,pc[964]
80002b7c:	92 08       	ld.sh	r8,r9[0x0]
80002b7e:	20 28       	sub	r8,2
80002b80:	b2 08       	st.h	r9[0x0],r8
			
			/*Have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80002b82:	30 09       	mov	r9,0
80002b84:	f2 08 19 00 	cp.h	r8,r9
80002b88:	e0 89 00 0e 	brgt	80002ba4 <phy_tx_func+0xf8>
			{
				/*Must send 0x00BA0000 next interrupt in Slot 3&4*/
				phy_tx_state = SEND_TAILED;
80002b8c:	30 29       	mov	r9,2
80002b8e:	fe f8 03 a2 	ld.w	r8,pc[930]
80002b92:	91 09       	st.w	r8[0x0],r9
80002b94:	c0 88       	rjmp	80002ba4 <phy_tx_func+0xf8>
			}
			break;

		case SEND_TAILED:
			/*send 0x00BA0000*/
			xnl_tx_channel->dword = PHYTERMLEFT;
80002b96:	fc 18 00 ba 	movh	r8,0xba
80002b9a:	99 18       	st.w	r12[0x4],r8
			
			/*Go back to waiting.*/	
			//vPortFree(phy_ptr);		
			phy_tx_state = WAITING_FOR_PHY_TX;		
80002b9c:	30 09       	mov	r9,0
80002b9e:	fe f8 03 92 	ld.w	r8,pc[914]
80002ba2:	91 09       	st.w	r8[0x0],r9
	
	//static U8 frame_5_end = 0;
	//static U16 pay[256];
	
	//Send-AMBE-data
	if ((AMBE_tx_flag == TRUE) || (AMBE_rx_flag == TRUE))
80002ba4:	fe f8 03 a0 	ld.w	r8,pc[928]
80002ba8:	11 89       	ld.ub	r9,r8[0x0]
80002baa:	30 18       	mov	r8,1
80002bac:	f0 09 18 00 	cp.b	r9,r8
80002bb0:	c0 90       	breq	80002bc2 <phy_tx_func+0x116>
80002bb2:	fe f8 03 96 	ld.w	r8,pc[918]
80002bb6:	11 89       	ld.ub	r9,r8[0x0]
80002bb8:	30 18       	mov	r8,1
80002bba:	f0 09 18 00 	cp.b	r9,r8
80002bbe:	e0 81 01 4f 	brne	80002e5c <phy_tx_func+0x3b0>
	{
		A_index = (A_index >=1456) ? 0 : A_index;
80002bc2:	fe f8 03 8a 	ld.w	r8,pc[906]
80002bc6:	70 08       	ld.w	r8,r8[0x0]
80002bc8:	e0 48 05 b0 	cp.w	r8,1456
80002bcc:	f9 b8 02 00 	movhs	r8,0
80002bd0:	fe f9 03 7c 	ld.w	r9,pc[892]
80002bd4:	93 08       	st.w	r9[0x0],r8

	  //AMBE_flag
		switch(AMBEpayload_tx_state)
80002bd6:	fe f9 03 7a 	ld.w	r9,pc[890]
80002bda:	72 09       	ld.w	r9,r9[0x0]
80002bdc:	58 29       	cp.w	r9,2
80002bde:	e0 80 00 91 	breq	80002d00 <phy_tx_func+0x254>
80002be2:	e0 8b 00 08 	brhi	80002bf2 <phy_tx_func+0x146>
80002be6:	58 09       	cp.w	r9,0
80002be8:	c0 e0       	breq	80002c04 <phy_tx_func+0x158>
80002bea:	58 19       	cp.w	r9,1
80002bec:	e0 81 01 2e 	brne	80002e48 <phy_tx_func+0x39c>
80002bf0:	c5 78       	rjmp	80002c9e <phy_tx_func+0x1f2>
80002bf2:	58 49       	cp.w	r9,4
80002bf4:	e0 80 00 c1 	breq	80002d76 <phy_tx_func+0x2ca>
80002bf8:	e0 83 00 9a 	brlo	80002d2c <phy_tx_func+0x280>
80002bfc:	58 59       	cp.w	r9,5
80002bfe:	e0 81 01 25 	brne	80002e48 <phy_tx_func+0x39c>
80002c02:	c1 89       	rjmp	80002e32 <phy_tx_func+0x386>
		{
			case AMBE_IDLE:
		
				if ((m_RxBurstType == VOICE_WATING) || (m_RxBurstType == VOICETERMINATOR)  || (m_RxBurstType == VOICEHEADER))
80002c04:	fe f8 03 50 	ld.w	r8,pc[848]
80002c08:	70 08       	ld.w	r8,r8[0x0]
80002c0a:	58 08       	cp.w	r8,0
80002c0c:	c0 b0       	breq	80002c22 <phy_tx_func+0x176>
80002c0e:	fe f8 03 46 	ld.w	r8,pc[838]
80002c12:	70 08       	ld.w	r8,r8[0x0]
80002c14:	58 a8       	cp.w	r8,10
80002c16:	c0 60       	breq	80002c22 <phy_tx_func+0x176>
80002c18:	fe f8 03 3c 	ld.w	r8,pc[828]
80002c1c:	70 08       	ld.w	r8,r8[0x0]
80002c1e:	58 18       	cp.w	r8,1
80002c20:	c0 a1       	brne	80002c34 <phy_tx_func+0x188>
				{
							
					payload_tx_channel->dword[0] = PAYLOADIDLE0;
80002c22:	e0 68 5a 5a 	mov	r8,23130
80002c26:	ea 18 ab cd 	orh	r8,0xabcd
80002c2a:	8f 28       	st.w	r7[0x8],r8
					payload_tx_channel->dword[1] = PAYLOADIDLE1;
80002c2c:	30 08       	mov	r8,0
80002c2e:	8f 38       	st.w	r7[0xc],r8
80002c30:	e0 8f 01 7a 	bral	80002f24 <phy_tx_func+0x478>
			
				}
				else if((m_RxBurstType == UNSUREDATA))
80002c34:	fe f8 03 20 	ld.w	r8,pc[800]
80002c38:	70 08       	ld.w	r8,r8[0x0]
80002c3a:	58 38       	cp.w	r8,3
80002c3c:	c0 91       	brne	80002c4e <phy_tx_func+0x1a2>
				{
					payload_tx_channel->dword[0] = AMBE_HT[0];
80002c3e:	fe f8 03 1a 	ld.w	r8,pc[794]
80002c42:	70 09       	ld.w	r9,r8[0x0]
80002c44:	8f 29       	st.w	r7[0x8],r9
					payload_tx_channel->dword[1] = AMBE_HT[1];
80002c46:	70 18       	ld.w	r8,r8[0x4]
80002c48:	8f 38       	st.w	r7[0xc],r8
80002c4a:	e0 8f 01 6d 	bral	80002f24 <phy_tx_func+0x478>
				else//加密和解密的激励类型
				{
					
					//Radio Internal Parameter + Vocoder Bits Stream Parameter + 1st 20ms AMBE bits of Voice Burst A 
					//assemble 3 items into 1 Command. Send it to Radio.
					if (m_RxBurstType == RADIOINTERNAL)//解密数据
80002c4e:	fe f8 03 06 	ld.w	r8,pc[774]
80002c52:	70 08       	ld.w	r8,r8[0x0]
80002c54:	58 28       	cp.w	r8,2
80002c56:	c1 31       	brne	80002c7c <phy_tx_func+0x1d0>
					{
						//0xABCDCO14
						payload_tx_channel->dword[0] = DE_OB_PAYLOAD;//49bits
80002c58:	e0 68 c0 14 	mov	r8,49172
80002c5c:	ea 18 ab cd 	orh	r8,0xabcd
80002c60:	8f 28       	st.w	r7[0x8],r8
						//0x847F
						payload_tx_channel->word[2] = RIP_PAYLOAD;
80002c62:	fe 78 84 7f 	mov	r8,-31617
80002c66:	ae 68       	st.h	r7[0xc],r8
						//0xxxxx
						payload_tx_channel->word[3] = Radio_Internal_Data[0];
80002c68:	fe f8 02 f4 	ld.w	r8,pc[756]
80002c6c:	90 08       	ld.sh	r8,r8[0x0]
80002c6e:	ae 78       	st.h	r7[0xe],r8
						
						AMBEpayload_tx_state = AMBE_DE_FIRST;
80002c70:	30 39       	mov	r9,3
80002c72:	fe f8 02 de 	ld.w	r8,pc[734]
80002c76:	91 09       	st.w	r8[0x0],r9
80002c78:	e0 8f 01 56 	bral	80002f24 <phy_tx_func+0x478>
					
					else//加密数据
					{
	
						//0xABCDCOOE
						payload_tx_channel->dword[0] = EN_OB_PAYLOAD;//49bits
80002c7c:	e0 68 c0 0e 	mov	r8,49166
80002c80:	ea 18 ab cd 	orh	r8,0xabcd
80002c84:	8f 28       	st.w	r7[0x8],r8
						//0x8212
						payload_tx_channel->word[2] = VBSP_data[0];
80002c86:	fe f8 02 da 	ld.w	r8,pc[730]
80002c8a:	90 09       	ld.sh	r9,r8[0x0]
80002c8c:	ae 69       	st.h	r7[0xc],r9
						//0xF00x
						payload_tx_channel->word[3] = VBSP_data[1];
80002c8e:	90 18       	ld.sh	r8,r8[0x2]
80002c90:	ae 78       	st.h	r7[0xe],r8
						
						AMBEpayload_tx_state = AMBE_EN_FIRST;
80002c92:	30 19       	mov	r9,1
80002c94:	fe f8 02 bc 	ld.w	r8,pc[700]
80002c98:	91 09       	st.w	r8[0x0],r9
80002c9a:	e0 8f 01 45 	bral	80002f24 <phy_tx_func+0x478>
			
			case AMBE_EN_FIRST:
			
			
				//0x88F2
				payload_tx_channel->word[0] = ENCODER_PAYLOAD;//49bits
80002c9e:	fe 78 88 f2 	mov	r8,-30478
80002ca2:	ae 48       	st.h	r7[0x8],r8
				
				payload_tx_channel->word[1] = ((AMBE_AudioData[A_index]<<8) + AMBE_AudioData[A_index+1]) ;
80002ca4:	fe f8 02 a8 	ld.w	r8,pc[680]
80002ca8:	70 0a       	ld.w	r10,r8[0x0]
80002caa:	fe f9 02 ba 	ld.w	r9,pc[698]
80002cae:	f2 0a 00 0b 	add	r11,r9,r10
80002cb2:	17 9b       	ld.ub	r11,r11[0x1]
80002cb4:	f2 0a 07 0a 	ld.ub	r10,r9[r10]
80002cb8:	a9 6a       	lsl	r10,0x8
80002cba:	f6 0a 00 0a 	add	r10,r11,r10
80002cbe:	ae 5a       	st.h	r7[0xa],r10
				A_index+=2;
80002cc0:	70 0a       	ld.w	r10,r8[0x0]
80002cc2:	2f ea       	sub	r10,-2
80002cc4:	91 0a       	st.w	r8[0x0],r10
				
				payload_tx_channel->word[2] = ((AMBE_AudioData[A_index]<<8) + AMBE_AudioData[A_index+1]) ;
80002cc6:	f2 0a 00 0b 	add	r11,r9,r10
80002cca:	17 9b       	ld.ub	r11,r11[0x1]
80002ccc:	f2 0a 07 0a 	ld.ub	r10,r9[r10]
80002cd0:	a9 6a       	lsl	r10,0x8
80002cd2:	f6 0a 00 0a 	add	r10,r11,r10
80002cd6:	ae 6a       	st.h	r7[0xc],r10
				A_index+=2;
80002cd8:	70 0a       	ld.w	r10,r8[0x0]
80002cda:	2f ea       	sub	r10,-2
80002cdc:	91 0a       	st.w	r8[0x0],r10
				
				payload_tx_channel->word[3] = ((AMBE_AudioData[A_index]<<8) + AMBE_AudioData[A_index+1]) ;
80002cde:	f2 0a 00 0b 	add	r11,r9,r10
80002ce2:	17 9b       	ld.ub	r11,r11[0x1]
80002ce4:	f2 0a 07 09 	ld.ub	r9,r9[r10]
80002ce8:	a9 69       	lsl	r9,0x8
80002cea:	f6 09 00 09 	add	r9,r11,r9
80002cee:	ae 79       	st.h	r7[0xe],r9
				A_index+=2;
80002cf0:	70 09       	ld.w	r9,r8[0x0]
80002cf2:	2f e9       	sub	r9,-2
80002cf4:	91 09       	st.w	r8[0x0],r9
				
				AMBEpayload_tx_state = AMBE_EN_LAST;
80002cf6:	30 29       	mov	r9,2
80002cf8:	fe f8 02 58 	ld.w	r8,pc[600]
80002cfc:	91 09       	st.w	r8[0x0],r9
80002cfe:	c1 39       	rjmp	80002f24 <phy_tx_func+0x478>
						payload_tx_channel->word[0]	= ((Public_AMBEkey[3]) ^ (AMBEBurst_rawdata[3])) ;
					
					}
					
					***/
					payload_tx_channel->word[0] = ((AMBE_AudioData[A_index]<<8) + 0x00) ;//需要补充Pad_bits位
80002d00:	fe f9 02 64 	ld.w	r9,pc[612]
80002d04:	f2 08 07 08 	ld.ub	r8,r9[r8]
80002d08:	a9 68       	lsl	r8,0x8
80002d0a:	ae 48       	st.h	r7[0x8],r8
					A_index+=1;
80002d0c:	fe f8 02 40 	ld.w	r8,pc[576]
80002d10:	70 09       	ld.w	r9,r8[0x0]
80002d12:	2f f9       	sub	r9,-1
80002d14:	91 09       	st.w	r8[0x0],r9
					
					payload_tx_channel->word[1]	= 0x00BA ; 
80002d16:	e0 68 00 ba 	mov	r8,186
80002d1a:	ae 58       	st.h	r7[0xa],r8
					payload_tx_channel->word[2]	= 0x0000 ;
80002d1c:	30 08       	mov	r8,0
80002d1e:	ae 68       	st.h	r7[0xc],r8
					payload_tx_channel->word[3]	= 0x0000 ;
80002d20:	ae 78       	st.h	r7[0xe],r8
				
					AMBEpayload_tx_state = AMBE_IDLE;
80002d22:	30 09       	mov	r9,0
80002d24:	fe f8 02 2c 	ld.w	r8,pc[556]
80002d28:	91 09       	st.w	r8[0x0],r9
80002d2a:	cf d8       	rjmp	80002f24 <phy_tx_func+0x478>
				break;
				
			case AMBE_DE_FIRST:
				
					//0xxxxx
					payload_tx_channel->word[0] = Radio_Internal_Data[1];
80002d2c:	fe f8 02 30 	ld.w	r8,pc[560]
80002d30:	90 18       	ld.sh	r8,r8[0x2]
80002d32:	ae 48       	st.h	r7[0x8],r8
					//0x8212
					payload_tx_channel->word[1] = VBSP_data[0];
80002d34:	fe f8 02 2c 	ld.w	r8,pc[556]
80002d38:	90 08       	ld.sh	r8,r8[0x0]
80002d3a:	ae 58       	st.h	r7[0xa],r8
					
					if ((m_RxBurstType == VOICEBURST_A) && (VF_SN == 1) )
80002d3c:	fe f8 02 18 	ld.w	r8,pc[536]
80002d40:	70 08       	ld.w	r8,r8[0x0]
80002d42:	58 48       	cp.w	r8,4
80002d44:	c0 e1       	brne	80002d60 <phy_tx_func+0x2b4>
80002d46:	fe f8 02 22 	ld.w	r8,pc[546]
80002d4a:	11 89       	ld.ub	r9,r8[0x0]
80002d4c:	30 18       	mov	r8,1
80002d4e:	f0 09 18 00 	cp.b	r9,r8
80002d52:	c0 71       	brne	80002d60 <phy_tx_func+0x2b4>
					{
						// Vocoder Bits Stream Parameter("E" flag = 1)
						//0xF08x
						payload_tx_channel->word[2] = ((VBSP_data[1]) | (0x0080));
80002d54:	fe f8 02 0c 	ld.w	r8,pc[524]
80002d58:	90 18       	ld.sh	r8,r8[0x2]
80002d5a:	a7 b8       	sbr	r8,0x7
80002d5c:	ae 68       	st.h	r7[0xc],r8
80002d5e:	c0 58       	rjmp	80002d68 <phy_tx_func+0x2bc>
					}
					else
						//0xF00x
						payload_tx_channel->word[2] = (VBSP_data[1]) ;
80002d60:	fe f8 02 00 	ld.w	r8,pc[512]
80002d64:	90 18       	ld.sh	r8,r8[0x2]
80002d66:	ae 68       	st.h	r7[0xc],r8
					
					//0x88F3
					payload_tx_channel->word[3] = DECODER_PAYLOAD;
80002d68:	fe 78 88 f3 	mov	r8,-30477
80002d6c:	ae 78       	st.h	r7[0xe],r8
		
					AMBEpayload_tx_state = AMBE_DE_SECOND;
80002d6e:	30 49       	mov	r9,4
80002d70:	4f 88       	lddpc	r8,80002f50 <phy_tx_func+0x4a4>
80002d72:	91 09       	st.w	r8[0x0],r9
80002d74:	cd 88       	rjmp	80002f24 <phy_tx_func+0x478>
					
				break;
			case AMBE_DE_SECOND:
					
				switch (m_RxBurstType)//在发送函数中去做解密处理
80002d76:	4f 88       	lddpc	r8,80002f54 <phy_tx_func+0x4a8>
80002d78:	70 08       	ld.w	r8,r8[0x0]
80002d7a:	58 48       	cp.w	r8,4
80002d7c:	c0 60       	breq	80002d88 <phy_tx_func+0x2dc>
80002d7e:	c5 03       	brcs	80002e1e <phy_tx_func+0x372>
80002d80:	58 98       	cp.w	r8,9
80002d82:	e0 8b 00 4e 	brhi	80002e1e <phy_tx_func+0x372>
80002d86:	c3 38       	rjmp	80002dec <phy_tx_func+0x340>
				{
					case VOICEBURST_A:
							if (VF_SN == 1)
80002d88:	4f 88       	lddpc	r8,80002f68 <phy_tx_func+0x4bc>
80002d8a:	11 89       	ld.ub	r9,r8[0x0]
80002d8c:	30 18       	mov	r8,1
80002d8e:	f0 09 18 00 	cp.b	r9,r8
80002d92:	c1 41       	brne	80002dba <phy_tx_func+0x30e>
							{	
								//Pick up public key
								
								AMBE_DecryptionKey[0] = AMBEBurst_rawdata[0];
80002d94:	4f 68       	lddpc	r8,80002f6c <phy_tx_func+0x4c0>
80002d96:	90 0a       	ld.sh	r10,r8[0x0]
80002d98:	4f 69       	lddpc	r9,80002f70 <phy_tx_func+0x4c4>
80002d9a:	b2 0a       	st.h	r9[0x0],r10
								AMBE_DecryptionKey[1] = AMBEBurst_rawdata[1];
80002d9c:	90 1a       	ld.sh	r10,r8[0x2]
80002d9e:	b2 1a       	st.h	r9[0x2],r10
								AMBE_DecryptionKey[2] = AMBEBurst_rawdata[2];
80002da0:	90 2a       	ld.sh	r10,r8[0x4]
80002da2:	b2 2a       	st.h	r9[0x4],r10
								AMBE_DecryptionKey[3] = AMBEBurst_rawdata[3];
80002da4:	90 3a       	ld.sh	r10,r8[0x6]
80002da6:	b2 3a       	st.h	r9[0x6],r10
								
								//Post back data
								payload_tx_channel->word[0] = AMBEBurst_rawdata[0] ;
80002da8:	90 09       	ld.sh	r9,r8[0x0]
80002daa:	ae 49       	st.h	r7[0x8],r9
								payload_tx_channel->word[1] = AMBEBurst_rawdata[1] ;
80002dac:	90 19       	ld.sh	r9,r8[0x2]
80002dae:	ae 59       	st.h	r7[0xa],r9
								payload_tx_channel->word[2] = AMBEBurst_rawdata[2] ;
80002db0:	90 29       	ld.sh	r9,r8[0x4]
80002db2:	ae 69       	st.h	r7[0xc],r9
								payload_tx_channel->word[3] = AMBEBurst_rawdata[3] ;
80002db4:	90 38       	ld.sh	r8,r8[0x6]
80002db6:	ae 78       	st.h	r7[0xe],r8
80002db8:	c1 68       	rjmp	80002de4 <phy_tx_func+0x338>
								
								
						
								//Decrypt AMBE data(XOR) 
								//Recover data
								payload_tx_channel->word[0] = ((AMBE_DecryptionKey[0]) ^ (AMBEBurst_rawdata[0])) ;
80002dba:	4e e9       	lddpc	r9,80002f70 <phy_tx_func+0x4c4>
80002dbc:	92 0a       	ld.sh	r10,r9[0x0]
80002dbe:	4e c8       	lddpc	r8,80002f6c <phy_tx_func+0x4c0>
80002dc0:	90 0b       	ld.sh	r11,r8[0x0]
80002dc2:	f7 ea 20 0a 	eor	r10,r11,r10
80002dc6:	ae 4a       	st.h	r7[0x8],r10
								payload_tx_channel->word[1] = ((AMBE_DecryptionKey[1]) ^ (AMBEBurst_rawdata[1])) ;
80002dc8:	92 1a       	ld.sh	r10,r9[0x2]
80002dca:	90 1b       	ld.sh	r11,r8[0x2]
80002dcc:	f7 ea 20 0a 	eor	r10,r11,r10
80002dd0:	ae 5a       	st.h	r7[0xa],r10
								payload_tx_channel->word[2] = ((AMBE_DecryptionKey[2]) ^ (AMBEBurst_rawdata[2])) ;
80002dd2:	92 2a       	ld.sh	r10,r9[0x4]
80002dd4:	90 2b       	ld.sh	r11,r8[0x4]
80002dd6:	f7 ea 20 0a 	eor	r10,r11,r10
80002dda:	ae 6a       	st.h	r7[0xc],r10
								payload_tx_channel->word[3] = ((AMBE_DecryptionKey[3]) ^ (AMBEBurst_rawdata[3])) ;
80002ddc:	92 39       	ld.sh	r9,r9[0x6]
80002dde:	90 38       	ld.sh	r8,r8[0x6]
80002de0:	12 58       	eor	r8,r9
80002de2:	ae 78       	st.h	r7[0xe],r8
								//payload_tx_channel->word[3] = AMBEBurst_rawdata[2];
							
						
							}
					
							AMBEpayload_tx_state = AMBE_DE_LAST;
80002de4:	30 59       	mov	r9,5
80002de6:	4d b8       	lddpc	r8,80002f50 <phy_tx_func+0x4a4>
80002de8:	91 09       	st.w	r8[0x0],r9
80002dea:	c9 d8       	rjmp	80002f24 <phy_tx_func+0x478>
						
							//Encrypted AMBE data(XOR)
						
							//Decrypt AMBE data(XOR)
							//Recover data
							payload_tx_channel->word[0] = ((AMBE_DecryptionKey[0]) ^ (AMBEBurst_rawdata[0])) ;
80002dec:	4e 19       	lddpc	r9,80002f70 <phy_tx_func+0x4c4>
80002dee:	92 0a       	ld.sh	r10,r9[0x0]
80002df0:	4d f8       	lddpc	r8,80002f6c <phy_tx_func+0x4c0>
80002df2:	90 0b       	ld.sh	r11,r8[0x0]
80002df4:	f7 ea 20 0a 	eor	r10,r11,r10
80002df8:	ae 4a       	st.h	r7[0x8],r10
							payload_tx_channel->word[1] = ((AMBE_DecryptionKey[1]) ^ (AMBEBurst_rawdata[1])) ;
80002dfa:	92 1a       	ld.sh	r10,r9[0x2]
80002dfc:	90 1b       	ld.sh	r11,r8[0x2]
80002dfe:	f7 ea 20 0a 	eor	r10,r11,r10
80002e02:	ae 5a       	st.h	r7[0xa],r10
							payload_tx_channel->word[2] = ((AMBE_DecryptionKey[2]) ^ (AMBEBurst_rawdata[2])) ;
80002e04:	92 2a       	ld.sh	r10,r9[0x4]
80002e06:	90 2b       	ld.sh	r11,r8[0x4]
80002e08:	f7 ea 20 0a 	eor	r10,r11,r10
80002e0c:	ae 6a       	st.h	r7[0xc],r10
							payload_tx_channel->word[3] = ((AMBE_DecryptionKey[3]) ^ (AMBEBurst_rawdata[3])) ;
80002e0e:	92 39       	ld.sh	r9,r9[0x6]
80002e10:	90 38       	ld.sh	r8,r8[0x6]
80002e12:	12 58       	eor	r8,r9
80002e14:	ae 78       	st.h	r7[0xe],r8
						
							AMBEpayload_tx_state = AMBE_DE_LAST;
80002e16:	30 59       	mov	r9,5
80002e18:	4c e8       	lddpc	r8,80002f50 <phy_tx_func+0x4a4>
80002e1a:	91 09       	st.w	r8[0x0],r9
80002e1c:	c8 48       	rjmp	80002f24 <phy_tx_func+0x478>
				
						break;
					default://This shouldn't happen, but must check;
					
							payload_tx_channel->dword[0] = PAYLOADIDLE0;
80002e1e:	e0 68 5a 5a 	mov	r8,23130
80002e22:	ea 18 ab cd 	orh	r8,0xabcd
80002e26:	8f 28       	st.w	r7[0x8],r8
							payload_tx_channel->dword[1] = PAYLOADIDLE1;
80002e28:	30 08       	mov	r8,0
80002e2a:	8f 38       	st.w	r7[0xc],r8
							AMBEpayload_tx_state = AMBE_IDLE;
80002e2c:	4c 99       	lddpc	r9,80002f50 <phy_tx_func+0x4a4>
80002e2e:	93 08       	st.w	r9[0x0],r8
80002e30:	c7 a8       	rjmp	80002f24 <phy_tx_func+0x478>
		
				break;
				
			case AMBE_DE_LAST:
				
					payload_tx_channel->word[0]	= 0x00BA ;
80002e32:	e0 68 00 ba 	mov	r8,186
80002e36:	ae 48       	st.h	r7[0x8],r8
					payload_tx_channel->word[1]	= 0x0000 ;
80002e38:	30 08       	mov	r8,0
80002e3a:	ae 58       	st.h	r7[0xa],r8
					payload_tx_channel->word[2]	= 0x0000 ;
80002e3c:	ae 68       	st.h	r7[0xc],r8
					payload_tx_channel->word[3]	= 0x0000 ;
80002e3e:	ae 78       	st.h	r7[0xe],r8
					
					AMBEpayload_tx_state = AMBE_IDLE;
80002e40:	30 09       	mov	r9,0
80002e42:	4c 48       	lddpc	r8,80002f50 <phy_tx_func+0x4a4>
80002e44:	91 09       	st.w	r8[0x0],r9
80002e46:	c6 f8       	rjmp	80002f24 <phy_tx_func+0x478>
				
				break;
		
			default:
			
					payload_tx_channel->dword[0] = PAYLOADIDLE0;
80002e48:	e0 68 5a 5a 	mov	r8,23130
80002e4c:	ea 18 ab cd 	orh	r8,0xabcd
80002e50:	8f 28       	st.w	r7[0x8],r8
					payload_tx_channel->dword[1] = PAYLOADIDLE1;
80002e52:	30 08       	mov	r8,0
80002e54:	8f 38       	st.w	r7[0xc],r8
					
					AMBEpayload_tx_state = AMBE_IDLE;
80002e56:	4b f9       	lddpc	r9,80002f50 <phy_tx_func+0x4a4>
80002e58:	93 08       	st.w	r9[0x0],r8
80002e5a:	c6 58       	rjmp	80002f24 <phy_tx_func+0x478>

	else//Send-PCM-data（注意测试回放时：数字信道码流为320bytes/20ms)
	{
		
		
		Payload_frame_DATA_1 = ((PCM_frame_Payload[0]<<16) | (PCM_frame_Payload[1]));
80002e5c:	4c 68       	lddpc	r8,80002f74 <phy_tx_func+0x4c8>
80002e5e:	90 0a       	ld.sh	r10,r8[0x0]
80002e60:	90 19       	ld.sh	r9,r8[0x2]
80002e62:	5c 79       	castu.h	r9
80002e64:	f3 ea 11 09 	or	r9,r9,r10<<0x10
80002e68:	4c 4a       	lddpc	r10,80002f78 <phy_tx_func+0x4cc>
80002e6a:	95 09       	st.w	r10[0x0],r9
		Payload_frame_DATA_2 = ((PCM_frame_Payload[2]<<16) | (PCM_frame_Payload[3]));
80002e6c:	90 2a       	ld.sh	r10,r8[0x4]
80002e6e:	90 38       	ld.sh	r8,r8[0x6]
80002e70:	5c 78       	castu.h	r8
80002e72:	f1 ea 11 08 	or	r8,r8,r10<<0x10
80002e76:	4c 2a       	lddpc	r10,80002f7c <phy_tx_func+0x4d0>
80002e78:	95 08       	st.w	r10[0x0],r8
		
		if ((Payload_frame_DATA_1 == PAYLOADIDLE0) || (0x00000003 != (bunchofrandomstatusflags & 0x00000003)))
80002e7a:	e0 6c 5a 5a 	mov	r12,23130
80002e7e:	ea 1c ab cd 	orh	r12,0xabcd
80002e82:	18 39       	cp.w	r9,r12
80002e84:	c0 70       	breq	80002e92 <phy_tx_func+0x3e6>
80002e86:	4b fa       	lddpc	r10,80002f80 <phy_tx_func+0x4d4>
80002e88:	74 0a       	ld.w	r10,r10[0x0]
80002e8a:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
80002e8e:	58 3a       	cp.w	r10,3
80002e90:	c0 90       	breq	80002ea2 <phy_tx_func+0x3f6>
		{
			payload_tx_channel->dword[0] = PAYLOADIDLE0;
80002e92:	e0 68 5a 5a 	mov	r8,23130
80002e96:	ea 18 ab cd 	orh	r8,0xabcd
80002e9a:	8f 28       	st.w	r7[0x8],r8
			payload_tx_channel->dword[1] = PAYLOADIDLE1;
80002e9c:	30 08       	mov	r8,0
80002e9e:	8f 38       	st.w	r7[0xc],r8
80002ea0:	c4 28       	rjmp	80002f24 <phy_tx_func+0x478>
				
				//if((Radio_Transmit_State == 1) && (Mic_is_Enabled == 1))//加密发送
				//发送方加密				
					//头和尾数据不变
					
					if ( ((Payload_frame_DATA_1 & 0xFFFFF000) == 0xABCD2000) || ((Payload_frame_DATA_1 & 0xFFFFF000) == 0xABCD1000)
80002ea2:	12 9a       	mov	r10,r9
80002ea4:	e0 1a f0 00 	andl	r10,0xf000
80002ea8:	e0 6b 20 00 	mov	r11,8192
80002eac:	ea 1b ab cd 	orh	r11,0xabcd
80002eb0:	16 3a       	cp.w	r10,r11
80002eb2:	5f 0b       	sreq	r11
80002eb4:	e0 6c 10 00 	mov	r12,4096
80002eb8:	ea 1c ab cd 	orh	r12,0xabcd
80002ebc:	18 3a       	cp.w	r10,r12
80002ebe:	5f 0a       	sreq	r10
80002ec0:	f7 ea 10 0a 	or	r10,r11,r10
80002ec4:	c1 71       	brne	80002ef2 <phy_tx_func+0x446>
80002ec6:	12 9a       	mov	r10,r9
80002ec8:	e0 1a 00 00 	andl	r10,0x0
80002ecc:	fc 1b 00 ba 	movh	r11,0xba
80002ed0:	16 3a       	cp.w	r10,r11
80002ed2:	c1 00       	breq	80002ef2 <phy_tx_func+0x446>
80002ed4:	f5 d9 c0 10 	bfextu	r10,r9,0x0,0x10
80002ed8:	e0 4a 00 ba 	cp.w	r10,186
80002edc:	c0 b0       	breq	80002ef2 <phy_tx_func+0x446>
80002ede:	10 9a       	mov	r10,r8
80002ee0:	e0 1a 00 00 	andl	r10,0x0
80002ee4:	16 3a       	cp.w	r10,r11
80002ee6:	c0 60       	breq	80002ef2 <phy_tx_func+0x446>
80002ee8:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
80002eec:	e0 48 00 ba 	cp.w	r8,186
80002ef0:	c0 61       	brne	80002efc <phy_tx_func+0x450>
					|| ((Payload_frame_DATA_2 & 0xFFFF0000) == 0x00BA0000) || ((Payload_frame_DATA_2 & 0x0000FFFF) == 0x000000BA) )//header terminator
					{
				
							//logFromISR("\n\r MMQ:%X \n\r", Payload_frame_DATA_1);
							
							payload_tx_channel->dword[0] = Payload_frame_DATA_1;
80002ef2:	8f 29       	st.w	r7[0x8],r9
							payload_tx_channel->dword[1] = Payload_frame_DATA_2;
80002ef4:	4a 28       	lddpc	r8,80002f7c <phy_tx_func+0x4d0>
80002ef6:	70 08       	ld.w	r8,r8[0x0]
80002ef8:	8f 38       	st.w	r7[0xc],r8
80002efa:	c1 58       	rjmp	80002f24 <phy_tx_func+0x478>
					//中间数据
					else//PCM encryption
					{
						//(Tone_flag == 1) 
						//logFromISR("\n\r MMQ:%X \n\r", Payload_frame_DATA_1);
						if (Silent_flag)
80002efc:	4a 28       	lddpc	r8,80002f84 <phy_tx_func+0x4d8>
80002efe:	11 8a       	ld.ub	r10,r8[0x0]
80002f00:	30 08       	mov	r8,0
80002f02:	f0 0a 18 00 	cp.b	r10,r8
80002f06:	c0 60       	breq	80002f12 <phy_tx_func+0x466>
						{
							//logFromISR("\n\r MMQ:%X \n\r", Payload_frame_DATA_1);
							payload_tx_channel->dword[0] = Payload_frame_DATA_1;
80002f08:	8f 29       	st.w	r7[0x8],r9
							payload_tx_channel->dword[1] = Payload_frame_DATA_2;
80002f0a:	49 d8       	lddpc	r8,80002f7c <phy_tx_func+0x4d0>
80002f0c:	70 08       	ld.w	r8,r8[0x0]
80002f0e:	8f 38       	st.w	r7[0xc],r8
80002f10:	c0 a8       	rjmp	80002f24 <phy_tx_func+0x478>
						else
						{
							//if(0x00000003 == (bunchofrandomstatusflags & 0x00000003))
							{
								//logFromISR("\n\r XXQ:%X \n\r", Payload_frame_DATA_1);
								payload_tx_channel->word[0] = (PCM_frame_Payload[0]);
80002f12:	49 98       	lddpc	r8,80002f74 <phy_tx_func+0x4c8>
80002f14:	90 09       	ld.sh	r9,r8[0x0]
80002f16:	ae 49       	st.h	r7[0x8],r9
								payload_tx_channel->word[1] = (PCM_frame_Payload[1]);
80002f18:	90 19       	ld.sh	r9,r8[0x2]
80002f1a:	ae 59       	st.h	r7[0xa],r9
								payload_tx_channel->word[2] = (PCM_frame_Payload[2] );//^ Public_PCMkey);
80002f1c:	90 29       	ld.sh	r9,r8[0x4]
80002f1e:	ae 69       	st.h	r7[0xc],r9
								payload_tx_channel->word[3] = (PCM_frame_Payload[3] );//^ Public_PCMkey);//加密方有bug,尝试用逻辑分析仪查看
80002f20:	90 38       	ld.sh	r8,r8[0x6]
80002f22:	ae 78       	st.h	r7[0xe],r8
	#else
	/*send idle frame*/	
	((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
	((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
	#endif /*end if*/
}
80002f24:	2f fd       	sub	sp,-4
80002f26:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002f2a:	00 00       	add	r0,r0
80002f2c:	00 00       	add	r0,r0
80002f2e:	0a d8       	st.w	--r5,r8
80002f30:	00 00       	add	r0,r0
80002f32:	0a a4       	st.w	r5++,r4
80002f34:	00 00       	add	r0,r0
80002f36:	0a 88       	andn	r8,r5
80002f38:	80 00       	ld.sh	r0,r0[0x0]
80002f3a:	56 10       	stdsp	sp[0x184],r0
80002f3c:	00 00       	add	r0,r0
80002f3e:	0a d4       	st.w	--r5,r4
80002f40:	00 00       	add	r0,r0
80002f42:	0a 94       	mov	r4,r5
80002f44:	00 00       	add	r0,r0
80002f46:	0a 5c       	eor	r12,r5
80002f48:	00 00       	add	r0,r0
80002f4a:	0a 41       	or	r1,r5
80002f4c:	00 00       	add	r0,r0
80002f4e:	0a cc       	st.b	r5++,r12
80002f50:	00 00       	add	r0,r0
80002f52:	0a c0       	st.b	r5++,r0
80002f54:	00 00       	add	r0,r0
80002f56:	0a 70       	tst	r0,r5
80002f58:	00 00       	add	r0,r0
80002f5a:	0a 80       	andn	r0,r5
80002f5c:	00 00       	add	r0,r0
80002f5e:	0d c4       	ld.ub	r4,r6[0x4]
80002f60:	00 00       	add	r0,r0
80002f62:	0e c0       	st.b	r7++,r0
80002f64:	80 00       	ld.sh	r0,r0[0x0]
80002f66:	cd d8       	rjmp	80003120 <phy_rx_func+0x44>
80002f68:	00 00       	add	r0,r0
80002f6a:	0a 5a       	eor	r10,r5
80002f6c:	00 00       	add	r0,r0
80002f6e:	0d bc       	ld.ub	r12,r6[0x3]
80002f70:	00 00       	add	r0,r0
80002f72:	0d c8       	ld.ub	r8,r6[0x4]
80002f74:	00 00       	add	r0,r0
80002f76:	04 f4       	st.b	--r2,r4
80002f78:	00 00       	add	r0,r0
80002f7a:	0a 6c       	and	r12,r5
80002f7c:	00 00       	add	r0,r0
80002f7e:	0a 8c       	andn	r12,r5
80002f80:	00 00       	add	r0,r0
80002f82:	0d b0       	ld.ub	r0,r6[0x3]
80002f84:	00 00       	add	r0,r0
80002f86:	0a 5d       	eor	sp,r5

80002f88 <get_idle_store>:
	}//End of RxMedia Phy Handler.
}
#endif /*end if*/

void * get_idle_store(xQueueHandle store)
{
80002f88:	d4 01       	pushm	lr
80002f8a:	20 1d       	sub	sp,4
	void * ptr = NULL;
80002f8c:	30 0a       	mov	r10,0
80002f8e:	fa cb ff fc 	sub	r11,sp,-4
80002f92:	16 da       	st.w	--r11,r10

	if(pdTRUE == xQueueReceive(store, &ptr, 0))
80002f94:	14 99       	mov	r9,r10
80002f96:	1a 9b       	mov	r11,sp
80002f98:	f0 1f 00 05 	mcall	80002fac <get_idle_store+0x24>
80002f9c:	58 1c       	cp.w	r12,1
80002f9e:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80002fa2:	fb fc 00 00 	ld.weq	r12,sp[0x0]
	}
	else
	{
		return NULL;
	}
}
80002fa6:	2f fd       	sub	sp,-4
80002fa8:	d8 02       	popm	pc
80002faa:	00 00       	add	r0,r0
80002fac:	80 00       	ld.sh	r0,r0[0x0]
80002fae:	57 00       	stdsp	sp[0x1c0],r0

80002fb0 <phy_init>:
    register_rx_tx_func -- ssc.c
	xQueueCreate -- freertos
Called By: xnl_init -- xnl.c
*/
void phy_init( void )
{
80002fb0:	eb cd 40 e0 	pushm	r5-r7,lr
    /*initialize the SSC*/
    ssc_init();
80002fb4:	f0 1f 00 24 	mcall	80003044 <phy_init+0x94>

    /*register the func to send/receive ssc packet*/
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
80002fb8:	4a 4b       	lddpc	r11,80003048 <phy_init+0x98>
80002fba:	4a 5c       	lddpc	r12,8000304c <phy_init+0x9c>
80002fbc:	f0 1f 00 25 	mcall	80003050 <phy_init+0xa0>
	
	/*if enable send/receive payload(media), defined in physical.h*/	
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
80002fc0:	30 4b       	mov	r11,4
80002fc2:	31 ec       	mov	r12,30
80002fc4:	f0 1f 00 24 	mcall	80003054 <phy_init+0xa4>
80002fc8:	4a 48       	lddpc	r8,80003058 <phy_init+0xa8>
80002fca:	91 0c       	st.w	r8[0x0],r12
80002fcc:	30 07       	mov	r7,0
	phy_fragment_t * xnl_ptr = NULL;
	for(int i= 0; i < MAX_XNL_STORE; i++ )
	{
		set_xnl_idle(&xnl_store[i]);
80002fce:	10 96       	mov	r6,r8
80002fd0:	4a 35       	lddpc	r5,8000305c <phy_init+0xac>
80002fd2:	6c 0c       	ld.w	r12,r6[0x0]
80002fd4:	ea 07 00 0b 	add	r11,r5,r7
80002fd8:	f0 1f 00 22 	mcall	80003060 <phy_init+0xb0>
80002fdc:	ee c7 ff 00 	sub	r7,r7,-256
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
	
	/*if enable send/receive payload(media), defined in physical.h*/	
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
	phy_fragment_t * xnl_ptr = NULL;
	for(int i= 0; i < MAX_XNL_STORE; i++ )
80002fe0:	e0 47 1e 00 	cp.w	r7,7680
80002fe4:	cf 71       	brne	80002fd2 <phy_init+0x22>
	{
		set_xnl_idle(&xnl_store[i]);
	}
		
    /*initialize the queue to send/receive xnl packet */	
    phy_xnl_frame_tx = xQueueCreate(TX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
80002fe6:	30 4b       	mov	r11,4
80002fe8:	31 4c       	mov	r12,20
80002fea:	f0 1f 00 1b 	mcall	80003054 <phy_init+0xa4>
80002fee:	49 e8       	lddpc	r8,80003064 <phy_init+0xb4>
80002ff0:	91 0c       	st.w	r8[0x0],r12
    phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
80002ff2:	30 4b       	mov	r11,4
80002ff4:	30 ac       	mov	r12,10
80002ff6:	f0 1f 00 18 	mcall	80003054 <phy_init+0xa4>
80002ffa:	49 c8       	lddpc	r8,80003068 <phy_init+0xb8>
80002ffc:	91 0c       	st.w	r8[0x0],r12
	
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
80002ffe:	30 4b       	mov	r11,4
80003000:	30 ac       	mov	r12,10
80003002:	f0 1f 00 15 	mcall	80003054 <phy_init+0xa4>
80003006:	49 a8       	lddpc	r8,8000306c <phy_init+0xbc>
80003008:	91 0c       	st.w	r8[0x0],r12
8000300a:	30 07       	mov	r7,0
	U8 * payload_ptr = NULL;
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
	{
		set_payload_idle(payload_store[i]);
8000300c:	10 96       	mov	r6,r8
8000300e:	49 95       	lddpc	r5,80003070 <phy_init+0xc0>
80003010:	6c 0c       	ld.w	r12,r6[0x0]
80003012:	ea 07 00 0b 	add	r11,r5,r7
80003016:	f0 1f 00 13 	mcall	80003060 <phy_init+0xb0>
8000301a:	ee c7 fe 00 	sub	r7,r7,-512
    phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
	
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
	U8 * payload_ptr = NULL;
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
8000301e:	e0 47 14 00 	cp.w	r7,5120
80003022:	cf 71       	brne	80003010 <phy_init+0x60>
		
	/*initialize the queue to send/receive xnl packet */
	
		
	phy_payload_frame_rx =
	xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
80003024:	30 4b       	mov	r11,4
80003026:	30 5c       	mov	r12,5
80003028:	f0 1f 00 0b 	mcall	80003054 <phy_init+0xa4>
	}
		
	/*initialize the queue to send/receive xnl packet */
	
		
	phy_payload_frame_rx =
8000302c:	49 28       	lddpc	r8,80003074 <phy_init+0xc4>
8000302e:	91 0c       	st.w	r8[0x0],r12
	xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
	
	phy_payload_frame_tx =
	xQueueCreate(TX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t));//未知bug不能屏蔽
80003030:	e0 6b 01 00 	mov	r11,256
80003034:	30 5c       	mov	r12,5
80003036:	f0 1f 00 08 	mcall	80003054 <phy_init+0xa4>
	
		
	phy_payload_frame_rx =
	xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
	
	phy_payload_frame_tx =
8000303a:	49 08       	lddpc	r8,80003078 <phy_init+0xc8>
8000303c:	91 0c       	st.w	r8[0x0],r12
	xQueueCreate(TX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t));//未知bug不能屏蔽
	#endif /*end if*/
	
}
8000303e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003042:	00 00       	add	r0,r0
80003044:	80 00       	ld.sh	r0,r0[0x0]
80003046:	41 2c       	lddsp	r12,sp[0x48]
80003048:	80 00       	ld.sh	r0,r0[0x0]
8000304a:	2a ac       	sub	r12,-86
8000304c:	80 00       	ld.sh	r0,r0[0x0]
8000304e:	30 dc       	mov	r12,13
80003050:	80 00       	ld.sh	r0,r0[0x0]
80003052:	41 18       	lddsp	r8,sp[0x44]
80003054:	80 00       	ld.sh	r0,r0[0x0]
80003056:	5a 64       	cp.w	r4,-26
80003058:	00 00       	add	r0,r0
8000305a:	0a 9c       	mov	r12,r5
8000305c:	00 00       	add	r0,r0
8000305e:	22 c4       	sub	r4,44
80003060:	80 00       	ld.sh	r0,r0[0x0]
80003062:	2a 08       	sub	r8,-96
80003064:	00 00       	add	r0,r0
80003066:	0a d8       	st.w	--r5,r8
80003068:	00 00       	add	r0,r0
8000306a:	0a bc       	st.h	r5++,r12
8000306c:	00 00       	add	r0,r0
8000306e:	0a 78       	tst	r8,r5
80003070:	00 00       	add	r0,r0
80003072:	0e c4       	st.b	r7++,r4
80003074:	00 00       	add	r0,r0
80003076:	0a 7c       	tst	r12,r5
80003078:	00 00       	add	r0,r0
8000307a:	0a b0       	st.h	r5++,r0

8000307c <payload_rx>:




static void payload_rx(void * payload)
{
8000307c:	d4 01       	pushm	lr
8000307e:	20 2d       	sub	sp,8
80003080:	50 0c       	stdsp	sp[0x0],r12
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80003082:	30 08       	mov	r8,0
80003084:	50 18       	stdsp	sp[0x4],r8
	
	//set_payload_idle(payload);
	if(NULL == phy_payload_frame_rx)
80003086:	48 f8       	lddpc	r8,800030c0 <payload_rx+0x44>
80003088:	70 08       	ld.w	r8,r8[0x0]
8000308a:	58 08       	cp.w	r8,0
8000308c:	c0 71       	brne	8000309a <payload_rx+0x1e>
	{
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));		
8000308e:	30 4b       	mov	r11,4
80003090:	30 5c       	mov	r12,5
80003092:	f0 1f 00 0d 	mcall	800030c4 <payload_rx+0x48>
80003096:	48 b8       	lddpc	r8,800030c0 <payload_rx+0x44>
80003098:	91 0c       	st.w	r8[0x0],r12
	}

	if(errQUEUE_FULL == xQueueSendFromISR(phy_payload_frame_rx, &payload, &xHigherPriorityTaskWoken))
8000309a:	48 a8       	lddpc	r8,800030c0 <payload_rx+0x44>
8000309c:	70 0c       	ld.w	r12,r8[0x0]
8000309e:	30 09       	mov	r9,0
800030a0:	fa ca ff fc 	sub	r10,sp,-4
800030a4:	1a 9b       	mov	r11,sp
800030a6:	f0 1f 00 09 	mcall	800030c8 <payload_rx+0x4c>
800030aa:	c0 91       	brne	800030bc <payload_rx+0x40>
	//if(errQUEUE_FULL == xQueueSend(phy_payload_frame_rx, &payload, 0))
	{	//To payload_rx_process();	
		
		set_payload_idle_isr(payload);
800030ac:	48 88       	lddpc	r8,800030cc <payload_rx+0x50>
800030ae:	70 0c       	ld.w	r12,r8[0x0]
800030b0:	40 0b       	lddsp	r11,sp[0x0]
800030b2:	f0 1f 00 08 	mcall	800030d0 <payload_rx+0x54>
		logFromISR("mm");//触发未知BUG时，此处会被触发。
800030b6:	48 8c       	lddpc	r12,800030d4 <payload_rx+0x58>
800030b8:	f0 1f 00 08 	mcall	800030d8 <payload_rx+0x5c>
			
		}
		//set_payload_idle_isr(payload);
		//logFromISR("ss");
	}
}
800030bc:	2f ed       	sub	sp,-8
800030be:	d8 02       	popm	pc
800030c0:	00 00       	add	r0,r0
800030c2:	0a 7c       	tst	r12,r5
800030c4:	80 00       	ld.sh	r0,r0[0x0]
800030c6:	5a 64       	cp.w	r4,-26
800030c8:	80 00       	ld.sh	r0,r0[0x0]
800030ca:	58 bc       	cp.w	r12,11
800030cc:	00 00       	add	r0,r0
800030ce:	0a 78       	tst	r8,r5
800030d0:	80 00       	ld.sh	r0,r0[0x0]
800030d2:	29 b4       	sub	r4,-101
800030d4:	80 00       	ld.sh	r0,r0[0x0]
800030d6:	d3 94       	*unknown*
800030d8:	80 00       	ld.sh	r0,r0[0x0]
800030da:	66 88       	ld.w	r8,r3[0x20]

800030dc <phy_rx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_rx_func( void * ssc)
{    
800030dc:	eb cd 40 e0 	pushm	r5-r7,lr
800030e0:	18 97       	mov	r7,r12
		
	if(NULL != phy_xnl_frame_rx)
800030e2:	fe f8 0e 66 	ld.w	r8,pc[3686]
800030e6:	70 08       	ld.w	r8,r8[0x0]
800030e8:	58 08       	cp.w	r8,0
800030ea:	e0 80 01 05 	breq	800032f4 <phy_rx_func+0x218>
	static U16 phy_check_sum = 0;

	static phy_rx_state_t  phy_rx_state = WAITING_FOR_HEADER;
	static U32 phy_rx_count = 0;

	U32 phy_dword = xnl_rx_channel->dword;	
800030ee:	78 16       	ld.w	r6,r12[0x4]

	phy_rx_count++;
800030f0:	fe f8 0e 5c 	ld.w	r8,pc[3676]
800030f4:	70 09       	ld.w	r9,r8[0x0]
800030f6:	2f f9       	sub	r9,-1
800030f8:	91 09       	st.w	r8[0x0],r9
	
	/*This is the code for parsing the incoming physical message.*/
	switch (phy_rx_state)
800030fa:	fe f8 0e 56 	ld.w	r8,pc[3670]
800030fe:	70 08       	ld.w	r8,r8[0x0]
80003100:	58 18       	cp.w	r8,1
80003102:	e0 80 00 84 	breq	8000320a <phy_rx_func+0x12e>
80003106:	c0 73       	brcs	80003114 <phy_rx_func+0x38>
80003108:	58 28       	cp.w	r8,2
8000310a:	c5 b0       	breq	800031c0 <phy_rx_func+0xe4>
8000310c:	58 38       	cp.w	r8,3
8000310e:	e0 81 00 f3 	brne	800032f4 <phy_rx_func+0x218>
80003112:	cd 38       	rjmp	800032b8 <phy_rx_func+0x1dc>

        /*Waiting for something. Most frequent visit.*/		
		case WAITING_FOR_HEADER:
		
			/*Ignore Idles.*/
			if (0xABCD5A5A == phy_dword)
80003114:	e0 6a 5a 5a 	mov	r10,23130
80003118:	ea 1a ab cd 	orh	r10,0xabcd
8000311c:	14 36       	cp.w	r6,r10
8000311e:	e0 80 00 eb 	breq	800032f4 <phy_rx_func+0x218>
			{
				break;
			}	

			/*Skip until Header.*/		
			if (0xABCD != (phy_dword >> 16))
80003122:	ec 08 16 10 	lsr	r8,r6,0x10
80003126:	e0 48 ab cd 	cp.w	r8,43981
8000312a:	e0 81 00 e5 	brne	800032f4 <phy_rx_func+0x218>
			{			
				break;
			}
		
			/*Length excluding CSUM.*/
			phy_rx_expexted_length = (phy_dword & 0x000000FF) - 2;
8000312e:	eb d6 b0 10 	bfexts	r5,r6,0x0,0x10
80003132:	f1 d5 c0 08 	bfextu	r8,r5,0x0,0x8
80003136:	20 28       	sub	r8,2
80003138:	fe f9 0e 1c 	ld.w	r9,pc[3612]
8000313c:	b2 08       	st.h	r9[0x0],r8
			
			/*Discard degenerate message.*/
			if (phy_rx_expexted_length <= 0)
8000313e:	30 09       	mov	r9,0
80003140:	f2 08 19 00 	cp.h	r8,r9
80003144:	e0 8a 00 d8 	brle	800032f4 <phy_rx_func+0x218>
			{
				break;
			}
		
			phy_rx_length = 0;
80003148:	fe f8 0e 10 	ld.w	r8,pc[3600]
8000314c:	b0 09       	st.h	r8[0x0],r9
			
			//get_xnl_idle_isr(&phy_frame_ptr, &xHigherPriorityTaskWoken);
			phy_frame_ptr = get_xnl_idle_isr();
8000314e:	fe f8 0e 0e 	ld.w	r8,pc[3598]
80003152:	70 0c       	ld.w	r12,r8[0x0]
80003154:	f0 1f 03 83 	mcall	80003f60 <phy_rx_func+0xe84>
80003158:	fe f8 0e 0c 	ld.w	r8,pc[3596]
8000315c:	91 0c       	st.w	r8[0x0],r12
			if(NULL == phy_frame_ptr)
8000315e:	58 0c       	cp.w	r12,0
80003160:	e0 80 00 ca 	breq	800032f4 <phy_rx_func+0x218>
			//
			//xQueueReceiveFromISR(phy_store_idle, &phy_frame_ptr, &xHigherPriorityTaskWoken);
			
			//phy_frame_ptr = pvPortMalloc(sizeof(phy_fragment_t));
					
			phy_frame_ptr->fragment_element[phy_rx_length++] = phy_dword;
80003164:	fe f8 0d f4 	ld.w	r8,pc[3572]
80003168:	90 09       	ld.sh	r9,r8[0x0]
8000316a:	f8 09 0a 15 	st.h	r12[r9<<0x1],r5
8000316e:	2f f9       	sub	r9,-1
80003170:	5c 89       	casts.h	r9
			
			/*time stamp*/
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
80003172:	fe fa 0d f2 	ld.w	r10,pc[3570]
80003176:	74 0a       	ld.w	r10,r10[0x0]
80003178:	fe fb 0d d4 	ld.w	r11,pc[3540]
8000317c:	76 0b       	ld.w	r11,r11[0x0]
8000317e:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
80003182:	2f f9       	sub	r9,-1
80003184:	b0 09       	st.h	r8[0x0],r9
													(phy_rx_count) & 0x0000FFFF;
			
			/*This switch tests the fragment type, and adjusts receiver state
			accordingly.*/
			/*Check frag type*/
			switch (phy_dword & 0x00000F00)
80003186:	e2 16 0f 00 	andl	r6,0xf00,COH
8000318a:	e0 46 01 00 	cp.w	r6,256
8000318e:	c0 c0       	breq	800031a6 <phy_rx_func+0xca>
80003190:	e0 8b 00 05 	brhi	8000319a <phy_rx_func+0xbe>
80003194:	58 06       	cp.w	r6,0
80003196:	c0 80       	breq	800031a6 <phy_rx_func+0xca>
80003198:	c0 c8       	rjmp	800031b0 <phy_rx_func+0xd4>
8000319a:	e0 46 02 00 	cp.w	r6,512
8000319e:	c0 40       	breq	800031a6 <phy_rx_func+0xca>
800031a0:	e0 46 03 00 	cp.w	r6,768
800031a4:	c0 61       	brne	800031b0 <phy_rx_func+0xd4>
			{
				case SINGLE_FRAGMENT:  //Only Fragment.
				case FIRST_FRAGMENT:   //First of Multi-fragment.
				case MIDDLE_FRAGMENT:  //Continuing Multi-fragment.
				case LAST_FRAGMENT:    //Last Multi-fragment.
					phy_rx_state = WAITING_CHECK_SUM;
800031a6:	30 29       	mov	r9,2
800031a8:	fe f8 0d a8 	ld.w	r8,pc[3496]
800031ac:	91 09       	st.w	r8[0x0],r9
800031ae:	ca 38       	rjmp	800032f4 <phy_rx_func+0x218>
				break;
				default:
					vPortFree(phy_frame_ptr);
800031b0:	fe f6 0d b4 	ld.w	r6,pc[3508]
800031b4:	6c 0c       	ld.w	r12,r6[0x0]
800031b6:	f0 1f 03 6d 	mcall	80003f68 <phy_rx_func+0xe8c>
					phy_frame_ptr = NULL;					
800031ba:	30 08       	mov	r8,0
800031bc:	8d 08       	st.w	r6[0x0],r8
800031be:	c9 b8       	rjmp	800032f4 <phy_rx_func+0x218>
		
			/*Stores CSUM*/
			phy_check_sum  = (phy_dword & 0xFFFF0000) >> 16;
			
			/*sums in first hWord*/
			phy_check_sum += (phy_dword & 0x0000FFFF);		
800031c0:	f5 d6 b0 10 	bfexts	r10,r6,0x0,0x10
800031c4:	b1 86       	lsr	r6,0x10
800031c6:	14 06       	add	r6,r10
800031c8:	fe f8 0d a4 	ld.w	r8,pc[3492]
800031cc:	b0 06       	st.h	r8[0x0],r6
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
800031ce:	fe f8 0d 8a 	ld.w	r8,pc[3466]
800031d2:	90 09       	ld.sh	r9,r8[0x0]
800031d4:	fe fb 0d 90 	ld.w	r11,pc[3472]
800031d8:	76 0b       	ld.w	r11,r11[0x0]
800031da:	f6 09 0a 1a 	st.h	r11[r9<<0x1],r10
800031de:	2f f9       	sub	r9,-1
800031e0:	b0 09       	st.h	r8[0x0],r9
														 phy_dword & 0x0000FFFF;
					
			phy_rx_expexted_length -= 2;
800031e2:	fe f9 0d 72 	ld.w	r9,pc[3442]
800031e6:	92 08       	ld.sh	r8,r9[0x0]
800031e8:	20 28       	sub	r8,2
800031ea:	b2 08       	st.h	r9[0x0],r8
			
			/*Normal case for greater than one byte payloads.*/
			if (phy_rx_expexted_length > 0)
800031ec:	30 09       	mov	r9,0
800031ee:	f2 08 19 00 	cp.h	r8,r9
800031f2:	e0 8a 00 07 	brle	80003200 <phy_rx_func+0x124>
			{					  
				phy_rx_state = READING_FRAGMENT;
800031f6:	30 19       	mov	r9,1
800031f8:	fe f8 0d 58 	ld.w	r8,pc[3416]
800031fc:	91 09       	st.w	r8[0x0],r9
800031fe:	c7 b8       	rjmp	800032f4 <phy_rx_func+0x218>
	    		Note that all segments must align with a 32-bit boundary and
				beginning of each XCMP/XNL payload frame must start on slot 3
				Thus, segments of odd length must append a 0x0000 at the end
				(slot 4) to ensure alignment. [9.1.3]
				*/
				phy_rx_state = WAITING_LAST_TERM;
80003200:	30 39       	mov	r9,3
80003202:	fe f8 0d 4e 	ld.w	r8,pc[3406]
80003206:	91 09       	st.w	r8[0x0],r9
80003208:	c7 68       	rjmp	800032f4 <phy_rx_func+0x218>
			}			
		
			break;

		case READING_FRAGMENT:
			phy_check_sum += (phy_dword & 0xFFFF0000) >> 16;
8000320a:	ec 0a 14 10 	asr	r10,r6,0x10
8000320e:	fe f8 0d 5e 	ld.w	r8,pc[3422]
80003212:	90 09       	ld.sh	r9,r8[0x0]
80003214:	14 09       	add	r9,r10
80003216:	b0 09       	st.h	r8[0x0],r9
	
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
80003218:	fe f9 0d 40 	ld.w	r9,pc[3392]
8000321c:	92 08       	ld.sh	r8,r9[0x0]
8000321e:	fe fb 0d 46 	ld.w	r11,pc[3398]
80003222:	76 0b       	ld.w	r11,r11[0x0]
80003224:	f6 08 0a 1a 	st.h	r11[r8<<0x1],r10
80003228:	2f f8       	sub	r8,-1
8000322a:	5c 88       	casts.h	r8
8000322c:	b2 08       	st.h	r9[0x0],r8
												 (phy_dword & 0xFFFF0000) >> 16;
	
			phy_rx_expexted_length -= 2;
8000322e:	fe fa 0d 26 	ld.w	r10,pc[3366]
80003232:	94 09       	ld.sh	r9,r10[0x0]
80003234:	20 29       	sub	r9,2
80003236:	b4 09       	st.h	r10[0x0],r9
			if (phy_rx_expexted_length <= 0)
80003238:	30 0a       	mov	r10,0
8000323a:	f4 09 19 00 	cp.h	r9,r10
8000323e:	e0 89 00 1f 	brgt	8000327c <phy_rx_func+0x1a0>
				Terminator should be in 2nd hWord.
				Shaoqun says useful bits not used. The packet will always end
				with $00BA. [9.1.2.8]	
				*/
				
				if ((0x000000BA == (phy_dword  & 0x0000FFFF)) 
80003242:	ed d6 c0 10 	bfextu	r6,r6,0x0,0x10
80003246:	e0 46 00 ba 	cp.w	r6,186
8000324a:	c0 d1       	brne	80003264 <phy_rx_func+0x188>
8000324c:	fe f8 0d 20 	ld.w	r8,pc[3360]
80003250:	90 09       	ld.sh	r9,r8[0x0]
80003252:	f4 09 19 00 	cp.h	r9,r10
80003256:	c0 71       	brne	80003264 <phy_rx_func+0x188>
					&& (phy_check_sum == 0))
				{
					phy_rx(phy_frame_ptr);
80003258:	fe f8 0d 0c 	ld.w	r8,pc[3340]
8000325c:	70 0c       	ld.w	r12,r8[0x0]
8000325e:	f0 1f 03 45 	mcall	80003f70 <phy_rx_func+0xe94>
80003262:	c0 88       	rjmp	80003272 <phy_rx_func+0x196>
				}
				else
				{
					vPortFree(phy_frame_ptr);
80003264:	fe f6 0d 00 	ld.w	r6,pc[3328]
80003268:	6c 0c       	ld.w	r12,r6[0x0]
8000326a:	f0 1f 03 40 	mcall	80003f68 <phy_rx_func+0xe8c>
					phy_frame_ptr = NULL;
8000326e:	30 08       	mov	r8,0
80003270:	8d 08       	st.w	r6[0x0],r8
				}

				phy_rx_state = WAITING_FOR_HEADER;
80003272:	30 09       	mov	r9,0
80003274:	fe f8 0c dc 	ld.w	r8,pc[3292]
80003278:	91 09       	st.w	r8[0x0],r9
8000327a:	c3 d8       	rjmp	800032f4 <phy_rx_func+0x218>
				break;
			}
		
			/*Have not broken. 2nd hWord contains payload.*/
			phy_check_sum += (phy_dword & 0x0000FFFF);
8000327c:	5c 86       	casts.h	r6
8000327e:	fe f9 0c ee 	ld.w	r9,pc[3310]
80003282:	92 0a       	ld.sh	r10,r9[0x0]
80003284:	0c 0a       	add	r10,r6
80003286:	b2 0a       	st.h	r9[0x0],r10
		
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
80003288:	fe f9 0c dc 	ld.w	r9,pc[3292]
8000328c:	72 09       	ld.w	r9,r9[0x0]
8000328e:	f2 08 0a 16 	st.h	r9[r8<<0x1],r6
80003292:	2f f8       	sub	r8,-1
80003294:	fe f9 0c c4 	ld.w	r9,pc[3268]
80003298:	b2 08       	st.h	r9[0x0],r8
													   (phy_dword & 0x0000FFFF);
		
			phy_rx_expexted_length -= 2;
8000329a:	fe f9 0c ba 	ld.w	r9,pc[3258]
8000329e:	92 08       	ld.sh	r8,r9[0x0]
800032a0:	20 28       	sub	r8,2
800032a2:	b2 08       	st.h	r9[0x0],r8
			if (phy_rx_expexted_length <= 0)
800032a4:	30 09       	mov	r9,0
800032a6:	f2 08 19 00 	cp.h	r8,r9
800032aa:	e0 89 00 25 	brgt	800032f4 <phy_rx_func+0x218>
			{
				/*All read in. Next Word should be 0x00BA0000.*/
				phy_rx_state = WAITING_LAST_TERM;
800032ae:	30 39       	mov	r9,3
800032b0:	fe f8 0c a0 	ld.w	r8,pc[3232]
800032b4:	91 09       	st.w	r8[0x0],r9
800032b6:	c1 f8       	rjmp	800032f4 <phy_rx_func+0x218>
			}/*else, next Word contains more payload.*/
			break;

		/*Expecting last terminator 0x00BA0000.*/	
		case WAITING_LAST_TERM:			
			if ((0x00BA0000 == (phy_dword  & 0x00FF0000)) /*Expected found.*/
800032b8:	e6 16 00 ff 	andh	r6,0xff,COH
800032bc:	fc 19 00 ba 	movh	r9,0xba
800032c0:	12 36       	cp.w	r6,r9
800032c2:	c0 e1       	brne	800032de <phy_rx_func+0x202>
800032c4:	fe f8 0c a8 	ld.w	r8,pc[3240]
800032c8:	90 09       	ld.sh	r9,r8[0x0]
800032ca:	30 08       	mov	r8,0
800032cc:	f0 09 19 00 	cp.h	r9,r8
800032d0:	c0 71       	brne	800032de <phy_rx_func+0x202>
				&& (phy_check_sum == 0))/*Good checksum*/
			{
				phy_rx(phy_frame_ptr);
800032d2:	fe f8 0c 92 	ld.w	r8,pc[3218]
800032d6:	70 0c       	ld.w	r12,r8[0x0]
800032d8:	f0 1f 03 26 	mcall	80003f70 <phy_rx_func+0xe94>
800032dc:	c0 88       	rjmp	800032ec <phy_rx_func+0x210>

			}
			else
			{
				vPortFree(phy_frame_ptr);
800032de:	fe f6 0c 86 	ld.w	r6,pc[3206]
800032e2:	6c 0c       	ld.w	r12,r6[0x0]
800032e4:	f0 1f 03 21 	mcall	80003f68 <phy_rx_func+0xe8c>
				phy_frame_ptr = NULL;
800032e8:	30 08       	mov	r8,0
800032ea:	8d 08       	st.w	r6[0x0],r8
			}
				
			phy_rx_state = WAITING_FOR_HEADER;
800032ec:	30 09       	mov	r9,0
800032ee:	fe f8 0c 62 	ld.w	r8,pc[3170]
800032f2:	91 09       	st.w	r8[0x0],r9
			
	//payload_ptr_t *AMBE_payload_ptr;		
				
	
	
	if(is_first == FALSE)
800032f4:	fe f8 0c 80 	ld.w	r8,pc[3200]
800032f8:	11 89       	ld.ub	r9,r8[0x0]
800032fa:	30 08       	mov	r8,0
800032fc:	f0 09 18 00 	cp.b	r9,r8
80003300:	c1 31       	brne	80003326 <phy_rx_func+0x24a>
	{
		payload_ptr = get_payload_idle_isr();
80003302:	fe f6 0c 76 	ld.w	r6,pc[3190]
80003306:	6c 0c       	ld.w	r12,r6[0x0]
80003308:	f0 1f 03 16 	mcall	80003f60 <phy_rx_func+0xe84>
8000330c:	fe f8 0c 70 	ld.w	r8,pc[3184]
80003310:	91 0c       	st.w	r8[0x0],r12
		AMBE_payload_ptr = get_payload_idle_isr();
80003312:	6c 0c       	ld.w	r12,r6[0x0]
80003314:	f0 1f 03 13 	mcall	80003f60 <phy_rx_func+0xe84>
80003318:	fe f8 0c 68 	ld.w	r8,pc[3176]
8000331c:	91 0c       	st.w	r8[0x0],r12
		is_first = TRUE;
8000331e:	30 19       	mov	r9,1
80003320:	fe f8 0c 54 	ld.w	r8,pc[3156]
80003324:	b0 89       	st.b	r8[0x0],r9
	}	
	
	
	PCM_frame_Payload[0] = payload_rx_channel->word[0];
80003326:	8e 49       	ld.sh	r9,r7[0x8]
80003328:	fe f8 0c 5c 	ld.w	r8,pc[3164]
8000332c:	b0 09       	st.h	r8[0x0],r9
	PCM_frame_Payload[1] = payload_rx_channel->word[1];
8000332e:	8e 59       	ld.sh	r9,r7[0xa]
80003330:	b0 19       	st.h	r8[0x2],r9
	PCM_frame_Payload[2] = payload_rx_channel->word[2];
80003332:	8e 69       	ld.sh	r9,r7[0xc]
80003334:	b0 29       	st.h	r8[0x4],r9
	PCM_frame_Payload[3] = payload_rx_channel->word[3];
80003336:	8e 79       	ld.sh	r9,r7[0xe]
80003338:	b0 39       	st.h	r8[0x6],r9
	
	//This is the RxMedia Phy Handler.
	switch (RxMediaState)
8000333a:	fe f8 0c 4e 	ld.w	r8,pc[3150]
8000333e:	70 08       	ld.w	r8,r8[0x0]
80003340:	58 28       	cp.w	r8,2
80003342:	e0 80 01 e1 	breq	80003704 <phy_rx_func+0x628>
80003346:	e0 8b 00 06 	brhi	80003352 <phy_rx_func+0x276>
8000334a:	58 08       	cp.w	r8,0
8000334c:	c0 b0       	breq	80003362 <phy_rx_func+0x286>
8000334e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003352:	58 38       	cp.w	r8,3
80003354:	e0 80 05 b4 	breq	80003ebc <phy_rx_func+0xde0>
80003358:	58 48       	cp.w	r8,4
8000335a:	e0 81 05 f5 	brne	80003f44 <phy_rx_func+0xe68>
8000335e:	e0 8f 02 94 	bral	80003886 <phy_rx_func+0x7aa>
	{
		case WAITINGABAB:

			
			if (payload_rx_channel->dword[0] == 0xABCD5A5A)//Ignore Idles.
80003362:	6e 28       	ld.w	r8,r7[0x8]
80003364:	e0 6a 5a 5a 	mov	r10,23130
80003368:	ea 1a ab cd 	orh	r10,0xabcd
8000336c:	14 38       	cp.w	r8,r10
8000336e:	c0 71       	brne	8000337c <phy_rx_func+0x2a0>
			{
				
				m_RxBurstType = VOICE_WATING;
80003370:	30 09       	mov	r9,0
80003372:	fe f8 0c 1a 	ld.w	r8,pc[3098]
80003376:	91 09       	st.w	r8[0x0],r9
80003378:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
				//Upon receiving the idle frame, the m Rx Burst Type into an idle state in order to transmit the synchronization wait
				 break; 
			}
            
			if ((payload_rx_channel->dword[0]  & 0xFFFF0000) != 0xABCD0000)break; //Skip until Header. 
8000337c:	10 99       	mov	r9,r8
8000337e:	e0 19 00 00 	andl	r9,0x0
80003382:	fc 1a ab cd 	movh	r10,0xabcd
80003386:	14 39       	cp.w	r9,r10
80003388:	e0 81 05 de 	brne	80003f44 <phy_rx_func+0xe68>
			}
			//logFromISR("\n\r P: %X \n\r", payload_rx_channel->word[1]);//测试收到的数据
			
			#endif
			
			RxBytesWaiting = payload_rx_channel->dword[0] & 0x000000FF;
8000338c:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
80003390:	fe f9 0c 00 	ld.w	r9,pc[3072]
80003394:	93 08       	st.w	r9[0x0],r8
		
			if((NULL== payload_ptr) || (NULL== AMBE_payload_ptr))
80003396:	fe f8 0b e6 	ld.w	r8,pc[3046]
8000339a:	70 08       	ld.w	r8,r8[0x0]
8000339c:	58 08       	cp.w	r8,0
8000339e:	c0 60       	breq	800033aa <phy_rx_func+0x2ce>
800033a0:	fe f8 0b e0 	ld.w	r8,pc[3040]
800033a4:	70 08       	ld.w	r8,r8[0x0]
800033a6:	58 08       	cp.w	r8,0
800033a8:	c1 a1       	brne	800033dc <phy_rx_func+0x300>
			{
				payload_ptr = get_payload_idle_isr();
800033aa:	fe f6 0b ce 	ld.w	r6,pc[3022]
800033ae:	6c 0c       	ld.w	r12,r6[0x0]
800033b0:	f0 1f 02 ec 	mcall	80003f60 <phy_rx_func+0xe84>
800033b4:	fe f5 0b c8 	ld.w	r5,pc[3016]
800033b8:	8b 0c       	st.w	r5[0x0],r12
				AMBE_payload_ptr = get_payload_idle_isr();
800033ba:	6c 0c       	ld.w	r12,r6[0x0]
800033bc:	f0 1f 02 e9 	mcall	80003f60 <phy_rx_func+0xe84>
800033c0:	fe f8 0b c0 	ld.w	r8,pc[3008]
800033c4:	91 0c       	st.w	r8[0x0],r12
				
				if((NULL== payload_ptr) || (NULL== AMBE_payload_ptr))
800033c6:	6a 08       	ld.w	r8,r5[0x0]
800033c8:	58 08       	cp.w	r8,0
800033ca:	c0 30       	breq	800033d0 <phy_rx_func+0x2f4>
800033cc:	58 0c       	cp.w	r12,0
800033ce:	c0 71       	brne	800033dc <phy_rx_func+0x300>
				{
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
800033d0:	fe fc 0b c4 	ld.w	r12,pc[3012]
800033d4:	f0 1f 02 f1 	mcall	80003f98 <phy_rx_func+0xebc>
800033d8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			}
			
		
			/****Note AMBE stream protocol frame structure and the PCM frame structure is different*****/
					
			if ((payload_rx_channel->dword[0] & 0x0000F000 ) == PAYLOAD_DATA_ENH )//PAYLOAD_DATA_ENH (0x0c))
800033dc:	6e 28       	ld.w	r8,r7[0x8]
800033de:	e2 18 f0 00 	andl	r8,0xf000,COH
800033e2:	e0 48 c0 00 	cp.w	r8,49152
800033e6:	e0 81 00 c7 	brne	80003574 <phy_rx_func+0x498>
			{
											
				Item_ID = payload_rx_channel->byte[5];
800033ea:	ef 39 00 0d 	ld.ub	r9,r7[13]
800033ee:	fe f8 0b ae 	ld.w	r8,pc[2990]
800033f2:	b0 89       	st.b	r8[0x0],r9
				
				Item_Length = (payload_rx_channel->byte[4] & 0x7F);//7bits
800033f4:	ef 3a 00 0c 	ld.ub	r10,r7[12]
800033f8:	f5 da c0 07 	bfextu	r10,r10,0x0,0x7
800033fc:	fe f9 0b a4 	ld.w	r9,pc[2980]
80003400:	93 0a       	st.w	r9[0x0],r10
								
				switch(Item_ID)
80003402:	11 88       	ld.ub	r8,r8[0x0]
80003404:	37 f9       	mov	r9,127
80003406:	f2 08 18 00 	cp.b	r8,r9
8000340a:	c6 b0       	breq	800034e0 <phy_rx_func+0x404>
8000340c:	e0 8b 00 0c 	brhi	80003424 <phy_rx_func+0x348>
80003410:	31 29       	mov	r9,18
80003412:	f2 08 18 00 	cp.b	r8,r9
80003416:	c4 20       	breq	8000349a <phy_rx_func+0x3be>
80003418:	31 39       	mov	r9,19
8000341a:	f2 08 18 00 	cp.b	r8,r9
8000341e:	e0 81 00 8b 	brne	80003534 <phy_rx_func+0x458>
80003422:	c5 98       	rjmp	800034d4 <phy_rx_func+0x3f8>
80003424:	2f 08       	sub	r8,-16
80003426:	30 19       	mov	r9,1
80003428:	f2 08 18 00 	cp.b	r8,r9
8000342c:	e0 8b 00 84 	brhi	80003534 <phy_rx_func+0x458>
					//The OB know the Call begin and discard the Voice Header
					//The OB know the Call end and discard the Voice  Terminator
					case Raw_Tx_Data_HT://0xF0
					case Raw_Rx_Data_HT://0xF1
					
							if ((payload_rx_channel->byte[6] & 0xF0 )== 0x10)//header
80003430:	ef 38 00 0e 	ld.ub	r8,r7[14]
80003434:	e2 18 00 f0 	andl	r8,0xf0,COH
80003438:	59 08       	cp.w	r8,16
8000343a:	c0 71       	brne	80003448 <phy_rx_func+0x36c>
							{
								m_RxBurstType = VOICEHEADER;
8000343c:	30 19       	mov	r9,1
8000343e:	fe f8 0b 4e 	ld.w	r8,pc[2894]
80003442:	91 09       	st.w	r8[0x0],r9
80003444:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

							}
							else if ((payload_rx_channel->byte[6] & 0xF0) == 0x20)//Terminator
80003448:	e0 48 00 20 	cp.w	r8,32
8000344c:	c2 11       	brne	8000348e <phy_rx_func+0x3b2>
							{
								m_RxBurstType = VOICETERMINATOR;
8000344e:	30 a9       	mov	r9,10
80003450:	fe f8 0b 3c 	ld.w	r8,pc[2876]
80003454:	91 09       	st.w	r8[0x0],r9
								//AMBE-data and PCM-data is not the same. AMBE is compressed data,
								//if there was a missing portion, a clear voice is difficult to extract the data.
								//It must ensure that all the data received AMBE.
								
								//注意！！！考虑是否需要把剩余的空间置0。
								memset((AMBE_payload_ptr+ (RxAMBE_IsFillingNext8 +1)), 0x00, (512-(RxAMBE_IsFillingNext8 + 1)));
80003456:	fe f6 0b 4e 	ld.w	r6,pc[2894]
8000345a:	6c 08       	ld.w	r8,r6[0x0]
8000345c:	f0 0a 11 ff 	rsub	r10,r8,-1
80003460:	fe f7 0b 20 	ld.w	r7,pc[2848]
80003464:	2f f8       	sub	r8,-1
80003466:	6e 0c       	ld.w	r12,r7[0x0]
80003468:	f4 ca fe 00 	sub	r10,r10,-512
8000346c:	30 0b       	mov	r11,0
8000346e:	10 0c       	add	r12,r8
80003470:	f0 1f 02 ce 	mcall	80003fa8 <phy_rx_func+0xecc>
								
								RxAMBE_IsFillingNext8 = 0;
80003474:	30 08       	mov	r8,0
80003476:	8d 08       	st.w	r6[0x0],r8
								payload_rx(AMBE_payload_ptr);
80003478:	6e 0c       	ld.w	r12,r7[0x0]
8000347a:	f0 1f 02 cd 	mcall	80003fac <phy_rx_func+0xed0>
								AMBE_payload_ptr = get_payload_idle_isr();
8000347e:	fe f8 0a fa 	ld.w	r8,pc[2810]
80003482:	70 0c       	ld.w	r12,r8[0x0]
80003484:	f0 1f 02 b7 	mcall	80003f60 <phy_rx_func+0xe84>
80003488:	8f 0c       	st.w	r7[0x0],r12
8000348a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								//logFromISR("\n\r QQ1 \n\r");
								
							}
							else//error voice
							{
								m_RxBurstType = VOICE_WATING;
8000348e:	30 09       	mov	r9,0
80003490:	fe f8 0a fc 	ld.w	r8,pc[2812]
80003494:	91 09       	st.w	r8[0x0],r9
80003496:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;//WAITINGABAB.
					
		
					case Vocoder_Bit_Stream_Parameter://0x12
							
							if ((RxBytesWaiting -= 4) <= 0) break;
8000349a:	fe f9 0a f6 	ld.w	r9,pc[2806]
8000349e:	72 08       	ld.w	r8,r9[0x0]
800034a0:	20 48       	sub	r8,4
800034a2:	93 08       	st.w	r9[0x0],r8
800034a4:	e0 80 05 50 	breq	80003f44 <phy_rx_func+0xe68>
					
							//Vocoder Bits Stream Parameter
							VF_SN = payload_rx_channel->byte[7];//This parameter is very important to the loop back Radio, as a reference.
800034a8:	ef 3c 00 0f 	ld.ub	r12,r7[15]
800034ac:	fe f8 0b 04 	ld.w	r8,pc[2820]
800034b0:	b0 8c       	st.b	r8[0x0],r12
							
							VBSP_data[0] = payload_rx_channel->word[2];
800034b2:	8e 69       	ld.sh	r9,r7[0xc]
800034b4:	fe f8 0b 00 	ld.w	r8,pc[2816]
800034b8:	b0 09       	st.h	r8[0x0],r9
							VBSP_data[1] = payload_rx_channel->word[3];
800034ba:	8e 79       	ld.sh	r9,r7[0xe]
800034bc:	b0 19       	st.h	r8[0x2],r9
							
							m_RxBurstType = CalculateBurst(VF_SN);
800034be:	f0 1f 02 bf 	mcall	80003fb8 <phy_rx_func+0xedc>
800034c2:	fe f8 0a ca 	ld.w	r8,pc[2762]
800034c6:	91 0c       	st.w	r8[0x0],r12
							
							RxMediaState = READING_AMBE_MEDIA;//Jump
800034c8:	30 49       	mov	r9,4
800034ca:	fe f8 0a be 	ld.w	r8,pc[2750]
800034ce:	91 09       	st.w	r8[0x0],r9
800034d0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							
					//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
					// or discard it to reduce payload size.	
					//This shouldn't happen, but must check.	
					case Soft_Decision_Value://0x13
						m_RxBurstType = VOICE_WATING;
800034d4:	30 09       	mov	r9,0
800034d6:	fe f8 0a b6 	ld.w	r8,pc[2742]
800034da:	91 09       	st.w	r8[0x0],r9
800034dc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;//WAITINGABAB.
							
								
					case Radio_Internal_Parameter://0x7F
							
							logFromISR("\n\r Item_Length:%d\n\r", Item_Length);
800034e0:	fe f8 0a c0 	ld.w	r8,pc[2752]
800034e4:	70 08       	ld.w	r8,r8[0x0]
800034e6:	1a d8       	st.w	--sp,r8
800034e8:	fe fc 0a d4 	ld.w	r12,pc[2772]
800034ec:	f0 1f 02 ab 	mcall	80003f98 <phy_rx_func+0xebc>
							
							if ((RxBytesWaiting -= 4) <= 0) break;
800034f0:	fe f9 0a a0 	ld.w	r9,pc[2720]
800034f4:	72 08       	ld.w	r8,r9[0x0]
800034f6:	20 48       	sub	r8,4
800034f8:	93 08       	st.w	r9[0x0],r8
800034fa:	2f fd       	sub	sp,-4
800034fc:	58 08       	cp.w	r8,0
800034fe:	e0 80 05 23 	breq	80003f44 <phy_rx_func+0xe68>
							//Radio Internal Parameter
							Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[3];
80003502:	fe f8 0a be 	ld.w	r8,pc[2750]
80003506:	70 09       	ld.w	r9,r8[0x0]
80003508:	8e 7b       	ld.sh	r11,r7[0xe]
8000350a:	fe fa 0a ba 	ld.w	r10,pc[2746]
8000350e:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
							RxData_IsFillingNext16 += 1; 
80003512:	2f f9       	sub	r9,-1
80003514:	91 09       	st.w	r8[0x0],r9
							Item_Length -= 2 ;
80003516:	fe f8 0a 8a 	ld.w	r8,pc[2698]
8000351a:	70 09       	ld.w	r9,r8[0x0]
8000351c:	20 29       	sub	r9,2
8000351e:	91 09       	st.w	r8[0x0],r9
							//....................................................
							m_RxBurstType = RADIOINTERNAL;
80003520:	30 29       	mov	r9,2
80003522:	fe f8 0a 6a 	ld.w	r8,pc[2666]
80003526:	91 09       	st.w	r8[0x0],r9

							RxMediaState = READING_AMBE_AUX;//Jump
80003528:	30 39       	mov	r9,3
8000352a:	fe f8 0a 5e 	ld.w	r8,pc[2654]
8000352e:	91 09       	st.w	r8[0x0],r9
80003530:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									
					default://0x03,0x04
						
						//((Item_ID == 0x04) || (Item_ID == 0x03) )//Unknown type data directly back hair
							//break;
							m_RxBurstType = UNSUREDATA;
80003534:	30 39       	mov	r9,3
80003536:	fe f8 0a 56 	ld.w	r8,pc[2646]
8000353a:	91 09       	st.w	r8[0x0],r9
							AMBE_HT[0] = payload_rx_channel->dword[0];
8000353c:	6e 29       	ld.w	r9,r7[0x8]
8000353e:	fe f8 0a 8a 	ld.w	r8,pc[2698]
80003542:	91 09       	st.w	r8[0x0],r9
							AMBE_HT[1] = payload_rx_channel->dword[1];
80003544:	6e 39       	ld.w	r9,r7[0xc]
80003546:	91 19       	st.w	r8[0x4],r9
							
							if (RxBytesWaiting == 0x00000014)
80003548:	fe f8 0a 48 	ld.w	r8,pc[2632]
8000354c:	70 08       	ld.w	r8,r8[0x0]
8000354e:	59 48       	cp.w	r8,20
80003550:	c0 61       	brne	8000355c <phy_rx_func+0x480>
							{
								RxBytesWaiting = 0x18;//24 Reassigned
80003552:	31 89       	mov	r9,24
80003554:	fe f8 0a 3c 	ld.w	r8,pc[2620]
80003558:	91 09       	st.w	r8[0x0],r9
8000355a:	c0 78       	rjmp	80003568 <phy_rx_func+0x48c>
								//_flag =0;
								
							}
							if (RxBytesWaiting == 0x00000010)
8000355c:	59 08       	cp.w	r8,16
8000355e:	c0 51       	brne	80003568 <phy_rx_func+0x48c>
							{
								RxBytesWaiting = 0x10;//16 Reassigned
80003560:	31 09       	mov	r9,16
80003562:	fe f8 0a 2e 	ld.w	r8,pc[2606]
80003566:	91 09       	st.w	r8[0x0],r9
								//_flag =1;
							}
					
							RxMediaState = READING_AMBE_MEDIA;//Jump
80003568:	30 49       	mov	r9,4
8000356a:	fe f8 0a 1e 	ld.w	r8,pc[2590]
8000356e:	91 09       	st.w	r8[0x0],r9
80003570:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
			else//PCM-media-data
			{	
				//logFromISR("\n\r RX:%x \n\r", payload_rx_channel->dword[0]);
				//SPEAKER_DATA or  //MIC_DATA
				if (((payload_rx_channel->dword[0] & 0x0000F000 ) != SPEAKER_DATA ) 
80003574:	e0 48 10 00 	cp.w	r8,4096
80003578:	5f 19       	srne	r9
8000357a:	e0 48 20 00 	cp.w	r8,8192
8000357e:	5f 18       	srne	r8
80003580:	f3 e8 00 08 	and	r8,r9,r8
80003584:	e0 81 04 e0 	brne	80003f44 <phy_rx_func+0xe68>
							
					//if ((payload_rx_channel->dword[0] & 0x0000F000 ) == SPEAKER_DATA)
					//{
						//break;//65794的机器通道有问题
					//}
				AMBE_tx_flag = 0;
80003588:	fe f9 0a 44 	ld.w	r9,pc[2628]
8000358c:	b2 88       	st.b	r9[0x0],r8
				AMBE_rx_flag = 0;
8000358e:	fe f9 0a 42 	ld.w	r9,pc[2626]
80003592:	b2 88       	st.b	r9[0x0],r8
				
				Item_ID = 0;//To make sure your save PCM data.
80003594:	fe f9 0a 08 	ld.w	r9,pc[2568]
80003598:	b2 88       	st.b	r9[0x0],r8
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
8000359a:	6e 28       	ld.w	r8,r7[0x8]
8000359c:	e2 18 0f 00 	andl	r8,0xf00,COH
800035a0:	58 18       	cp.w	r8,1
800035a2:	e0 8b 00 7f 	brhi	800036a0 <phy_rx_func+0x5c4>
				
				if ((payload_rx_channel->dword[0]  & 0x00000F00) <= 1){  //Flag type must process Array Descriptor.
				//The first word of the media access payload must be the Array descriptor length. And the
				//unit of the length is in word (16-bit). The length field itself does not count into the length.
				//When there is no array descriptor, the length must be set to zero.[9.1.4.1]
				if ((RxBytesWaiting -= 4) <= 0) break;          //Nothing beyond this Phy buffer. Keep looking for Header
800035a6:	fe f9 09 ea 	ld.w	r9,pc[2538]
800035aa:	72 08       	ld.w	r8,r9[0x0]
800035ac:	20 48       	sub	r8,4
800035ae:	93 08       	st.w	r9[0x0],r8
800035b0:	e0 80 04 ca 	breq	80003f44 <phy_rx_func+0xe68>
				ArrayDiscLength = payload_rx_channel->word[2];
800035b4:	8e 68       	ld.sh	r8,r7[0xc]
800035b6:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
800035ba:	fe f9 0a 1a 	ld.w	r9,pc[2586]
800035be:	93 0a       	st.w	r9[0x0],r10
				
				switch (ArrayDiscLength){
800035c0:	30 09       	mov	r9,0
800035c2:	f2 08 19 00 	cp.h	r8,r9
800035c6:	c0 70       	breq	800035d4 <phy_rx_func+0x4f8>
800035c8:	30 19       	mov	r9,1
800035ca:	f2 08 19 00 	cp.h	r8,r9
800035ce:	e0 81 04 bb 	brne	80003f44 <phy_rx_func+0xe68>
800035d2:	c3 08       	rjmp	80003632 <phy_rx_func+0x556>
					case 0:          //The usual case. Remaining word in Phy buffer is Audio.
							
							Terminator_Flag = 0;
800035d4:	30 08       	mov	r8,0
800035d6:	fe f9 0a 02 	ld.w	r9,pc[2562]
800035da:	b2 88       	st.b	r9[0x0],r8
							Silent_flag = 0;
800035dc:	fe f9 0a 00 	ld.w	r9,pc[2560]
800035e0:	b2 88       	st.b	r9[0x0],r8
							Tone_flag = 0;
800035e2:	fe f9 09 fe 	ld.w	r9,pc[2558]
800035e6:	b2 88       	st.b	r9[0x0],r8
							
							payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
800035e8:	fe f8 09 fc 	ld.w	r8,pc[2556]
800035ec:	70 0a       	ld.w	r10,r8[0x0]
800035ee:	fe f9 09 8e 	ld.w	r9,pc[2446]
800035f2:	72 09       	ld.w	r9,r9[0x0]
800035f4:	8e 7b       	ld.sh	r11,r7[0xe]
800035f6:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
							RxMedia_IsFillingNext16 += 1;
800035fa:	70 09       	ld.w	r9,r8[0x0]
800035fc:	2f f9       	sub	r9,-1
800035fe:	91 09       	st.w	r8[0x0],r9
							if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003600:	e0 49 00 ff 	cp.w	r9,255
80003604:	e0 88 00 11 	brls	80003626 <phy_rx_func+0x54a>
							{
								RxMedia_IsFillingNext16 = 0;
80003608:	30 09       	mov	r9,0
8000360a:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);
8000360c:	fe f7 09 70 	ld.w	r7,pc[2416]
80003610:	6e 0c       	ld.w	r12,r7[0x0]
80003612:	f0 1f 02 67 	mcall	80003fac <phy_rx_func+0xed0>
								payload_ptr = get_payload_idle_isr();
80003616:	fe f8 09 62 	ld.w	r8,pc[2402]
8000361a:	70 0c       	ld.w	r12,r8[0x0]
8000361c:	f0 1f 02 51 	mcall	80003f60 <phy_rx_func+0xe84>
80003620:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == payload_ptr)
80003622:	e0 80 04 91 	breq	80003f44 <phy_rx_func+0xe68>
								{
									break;
								}
							}
							RxMediaState = READINGMEDIA;
80003626:	30 29       	mov	r9,2
80003628:	fe f8 09 60 	ld.w	r8,pc[2400]
8000362c:	91 09       	st.w	r8[0x0],r9
8000362e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
				
					case 1: //The next usual case.
							//In general case, add code to process single word Array descriptor.
							if (payload_rx_channel->word[3] == 0x0003)//Stream Terminator
80003632:	8e 78       	ld.sh	r8,r7[0xe]
80003634:	30 39       	mov	r9,3
80003636:	f2 08 19 00 	cp.h	r8,r9
8000363a:	c0 61       	brne	80003646 <phy_rx_func+0x56a>
							{
								Terminator_Flag = 1;
8000363c:	30 19       	mov	r9,1
8000363e:	fe f8 09 9a 	ld.w	r8,pc[2458]
80003642:	b0 89       	st.b	r8[0x0],r9
80003644:	c2 88       	rjmp	80003694 <phy_rx_func+0x5b8>

							}
							else if(payload_rx_channel->word[3] == 0x0004)//Silent Descriptor
80003646:	30 49       	mov	r9,4
80003648:	f2 08 19 00 	cp.h	r8,r9
8000364c:	c0 61       	brne	80003658 <phy_rx_func+0x57c>
							{
							
								Silent_flag = 1;
8000364e:	30 19       	mov	r9,1
80003650:	fe f8 09 8c 	ld.w	r8,pc[2444]
80003654:	b0 89       	st.b	r8[0x0],r9
80003656:	c1 f8       	rjmp	80003694 <phy_rx_func+0x5b8>
							}
							else if (payload_rx_channel->word[3] == 0x1026)//Tone Descriptor
80003658:	e0 69 10 26 	mov	r9,4134
8000365c:	f2 08 19 00 	cp.h	r8,r9
80003660:	c1 01       	brne	80003680 <phy_rx_func+0x5a4>
							{
								
								Tone_flag = 1;
80003662:	30 19       	mov	r9,1
80003664:	fe f8 09 7c 	ld.w	r8,pc[2428]
80003668:	b0 89       	st.b	r8[0x0],r9
								Tone_Counters++;
8000366a:	fe f8 09 7e 	ld.w	r8,pc[2430]
8000366e:	70 09       	ld.w	r9,r8[0x0]
80003670:	2f f9       	sub	r9,-1
80003672:	91 09       	st.w	r8[0x0],r9
								RxMediaState = WAITINGABAB;
80003674:	30 09       	mov	r9,0
80003676:	fe f8 09 12 	ld.w	r8,pc[2322]
8000367a:	91 09       	st.w	r8[0x0],r9
8000367c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;	//Tone_flag = 1;//屏蔽掉此类型数据
							
							}
							else
							{
								Terminator_Flag = 0;
80003680:	30 08       	mov	r8,0
80003682:	fe f9 09 56 	ld.w	r9,pc[2390]
80003686:	b2 88       	st.b	r9[0x0],r8
								Silent_flag = 0;
80003688:	fe f9 09 54 	ld.w	r9,pc[2388]
8000368c:	b2 88       	st.b	r9[0x0],r8
								Tone_flag = 0;
8000368e:	fe f9 09 52 	ld.w	r9,pc[2386]
80003692:	b2 88       	st.b	r9[0x0],r8
								
							}
					
					
							RxMediaState = READINGMEDIA;
80003694:	30 29       	mov	r9,2
80003696:	fe f8 08 f2 	ld.w	r8,pc[2290]
8000369a:	91 09       	st.w	r8[0x0],r9
8000369c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					
				break;
				}
		
				//Code gets here on Middle or last Fragment. No Array descriptor.
				if (RxBytesWaiting < 2) break;//This shouldn't happen, but must check.
800036a0:	fe f8 08 f0 	ld.w	r8,pc[2288]
800036a4:	70 08       	ld.w	r8,r8[0x0]
800036a6:	58 18       	cp.w	r8,1
800036a8:	e0 88 04 4e 	brls	80003f44 <phy_rx_func+0xe68>
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->dword[1] & 0x0000FFFF;
800036ac:	fe f8 09 38 	ld.w	r8,pc[2360]
800036b0:	70 0a       	ld.w	r10,r8[0x0]
800036b2:	fe f9 08 ca 	ld.w	r9,pc[2250]
800036b6:	72 09       	ld.w	r9,r9[0x0]
800036b8:	6e 3b       	ld.w	r11,r7[0xc]
800036ba:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
800036be:	70 09       	ld.w	r9,r8[0x0]
800036c0:	2f f9       	sub	r9,-1
800036c2:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800036c4:	e0 49 00 ff 	cp.w	r9,255
800036c8:	e0 88 00 11 	brls	800036ea <phy_rx_func+0x60e>
				{
					RxMedia_IsFillingNext16 = 0;
800036cc:	30 09       	mov	r9,0
800036ce:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);
800036d0:	fe f7 08 ac 	ld.w	r7,pc[2220]
800036d4:	6e 0c       	ld.w	r12,r7[0x0]
800036d6:	f0 1f 02 36 	mcall	80003fac <phy_rx_func+0xed0>
								payload_ptr = get_payload_idle_isr();
800036da:	fe f8 08 9e 	ld.w	r8,pc[2206]
800036de:	70 0c       	ld.w	r12,r8[0x0]
800036e0:	f0 1f 02 20 	mcall	80003f60 <phy_rx_func+0xe84>
800036e4:	8f 0c       	st.w	r7[0x0],r12
													if(NULL == payload_ptr)
800036e6:	e0 80 04 2f 	breq	80003f44 <phy_rx_func+0xe68>
													{
														break;
													}
				}
				if ((RxBytesWaiting -= 2) <= 0) break;  //This shouldn't happen, but must check;
800036ea:	fe f9 08 a6 	ld.w	r9,pc[2214]
800036ee:	72 08       	ld.w	r8,r9[0x0]
800036f0:	20 28       	sub	r8,2
800036f2:	93 08       	st.w	r9[0x0],r8
800036f4:	e0 80 04 28 	breq	80003f44 <phy_rx_func+0xe68>
				RxMediaState = READINGMEDIA;
800036f8:	30 29       	mov	r9,2
800036fa:	fe f8 08 8e 	ld.w	r8,pc[2190]
800036fe:	91 09       	st.w	r8[0x0],r9
80003700:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
		case READINGMEDIA:
				
			/***PCM-media-data ****/
			{
						
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[0];
80003704:	fe f8 08 e0 	ld.w	r8,pc[2272]
80003708:	70 0a       	ld.w	r10,r8[0x0]
8000370a:	fe f9 08 72 	ld.w	r9,pc[2162]
8000370e:	72 09       	ld.w	r9,r9[0x0]
80003710:	8e 4b       	ld.sh	r11,r7[0x8]
80003712:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;	
80003716:	70 09       	ld.w	r9,r8[0x0]
80003718:	2f f9       	sub	r9,-1
8000371a:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
8000371c:	e0 49 00 ff 	cp.w	r9,255
80003720:	e0 88 00 16 	brls	8000374c <phy_rx_func+0x670>
					{
							RxMedia_IsFillingNext16 = 0;
80003724:	30 09       	mov	r9,0
80003726:	91 09       	st.w	r8[0x0],r9
							payload_rx(payload_ptr);
80003728:	fe f6 08 54 	ld.w	r6,pc[2132]
8000372c:	6c 0c       	ld.w	r12,r6[0x0]
8000372e:	f0 1f 02 20 	mcall	80003fac <phy_rx_func+0xed0>
							payload_ptr = get_payload_idle_isr();
80003732:	fe f8 08 46 	ld.w	r8,pc[2118]
80003736:	70 0c       	ld.w	r12,r8[0x0]
80003738:	f0 1f 02 0a 	mcall	80003f60 <phy_rx_func+0xe84>
8000373c:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == payload_ptr)
8000373e:	c0 71       	brne	8000374c <phy_rx_func+0x670>
							{
								RxMediaState = WAITINGABAB;
80003740:	30 09       	mov	r9,0
80003742:	fe f8 08 46 	ld.w	r8,pc[2118]
80003746:	91 09       	st.w	r8[0x0],r9
80003748:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
					}
				if ((RxBytesWaiting -= 2) <= 0)
8000374c:	fe f9 08 44 	ld.w	r9,pc[2116]
80003750:	72 08       	ld.w	r8,r9[0x0]
80003752:	20 28       	sub	r8,2
80003754:	93 08       	st.w	r9[0x0],r8
80003756:	c0 71       	brne	80003764 <phy_rx_func+0x688>
				{
					RxMediaState = WAITINGABAB;
80003758:	30 09       	mov	r9,0
8000375a:	fe f8 08 2e 	ld.w	r8,pc[2094]
8000375e:	91 09       	st.w	r8[0x0],r9
80003760:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[1];
80003764:	fe f8 08 80 	ld.w	r8,pc[2176]
80003768:	70 0a       	ld.w	r10,r8[0x0]
8000376a:	fe f9 08 12 	ld.w	r9,pc[2066]
8000376e:	72 09       	ld.w	r9,r9[0x0]
80003770:	8e 5b       	ld.sh	r11,r7[0xa]
80003772:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80003776:	70 09       	ld.w	r9,r8[0x0]
80003778:	2f f9       	sub	r9,-1
8000377a:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
8000377c:	e0 49 00 ff 	cp.w	r9,255
80003780:	e0 88 00 16 	brls	800037ac <phy_rx_func+0x6d0>
						{
							RxMedia_IsFillingNext16 = 0;
80003784:	30 09       	mov	r9,0
80003786:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);
80003788:	fe f6 07 f4 	ld.w	r6,pc[2036]
8000378c:	6c 0c       	ld.w	r12,r6[0x0]
8000378e:	f0 1f 02 08 	mcall	80003fac <phy_rx_func+0xed0>
								payload_ptr = get_payload_idle_isr();
80003792:	fe f8 07 e6 	ld.w	r8,pc[2022]
80003796:	70 0c       	ld.w	r12,r8[0x0]
80003798:	f0 1f 01 f2 	mcall	80003f60 <phy_rx_func+0xe84>
8000379c:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == payload_ptr)
8000379e:	c0 71       	brne	800037ac <phy_rx_func+0x6d0>
								{
									RxMediaState = WAITINGABAB;
800037a0:	30 09       	mov	r9,0
800037a2:	fe f8 07 e6 	ld.w	r8,pc[2022]
800037a6:	91 09       	st.w	r8[0x0],r9
800037a8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
						}
				if ((RxBytesWaiting -= 2) <= 0){
800037ac:	fe f9 07 e4 	ld.w	r9,pc[2020]
800037b0:	72 08       	ld.w	r8,r9[0x0]
800037b2:	20 28       	sub	r8,2
800037b4:	93 08       	st.w	r9[0x0],r8
800037b6:	c0 71       	brne	800037c4 <phy_rx_func+0x6e8>
					RxMediaState = WAITINGABAB;
800037b8:	30 09       	mov	r9,0
800037ba:	fe f8 07 ce 	ld.w	r8,pc[1998]
800037be:	91 09       	st.w	r8[0x0],r9
800037c0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}

				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[2];
800037c4:	fe f8 08 20 	ld.w	r8,pc[2080]
800037c8:	70 0a       	ld.w	r10,r8[0x0]
800037ca:	fe f9 07 b2 	ld.w	r9,pc[1970]
800037ce:	72 09       	ld.w	r9,r9[0x0]
800037d0:	8e 6b       	ld.sh	r11,r7[0xc]
800037d2:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
800037d6:	70 09       	ld.w	r9,r8[0x0]
800037d8:	2f f9       	sub	r9,-1
800037da:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800037dc:	e0 49 00 ff 	cp.w	r9,255
800037e0:	e0 88 00 16 	brls	8000380c <phy_rx_func+0x730>
						{
							RxMedia_IsFillingNext16 = 0;
800037e4:	30 09       	mov	r9,0
800037e6:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);
800037e8:	fe f6 07 94 	ld.w	r6,pc[1940]
800037ec:	6c 0c       	ld.w	r12,r6[0x0]
800037ee:	f0 1f 01 f0 	mcall	80003fac <phy_rx_func+0xed0>
									payload_ptr = get_payload_idle_isr();
800037f2:	fe f8 07 86 	ld.w	r8,pc[1926]
800037f6:	70 0c       	ld.w	r12,r8[0x0]
800037f8:	f0 1f 01 da 	mcall	80003f60 <phy_rx_func+0xe84>
800037fc:	8d 0c       	st.w	r6[0x0],r12
									if(NULL == payload_ptr)
800037fe:	c0 71       	brne	8000380c <phy_rx_func+0x730>
									{
										RxMediaState = WAITINGABAB;
80003800:	30 09       	mov	r9,0
80003802:	fe f8 07 86 	ld.w	r8,pc[1926]
80003806:	91 09       	st.w	r8[0x0],r9
80003808:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
						}
				if ((RxBytesWaiting -= 2) <= 0){
8000380c:	fe f9 07 84 	ld.w	r9,pc[1924]
80003810:	72 08       	ld.w	r8,r9[0x0]
80003812:	20 28       	sub	r8,2
80003814:	93 08       	st.w	r9[0x0],r8
80003816:	c0 71       	brne	80003824 <phy_rx_func+0x748>
					RxMediaState = WAITINGABAB;
80003818:	30 09       	mov	r9,0
8000381a:	fe f8 07 6e 	ld.w	r8,pc[1902]
8000381e:	91 09       	st.w	r8[0x0],r9
80003820:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
80003824:	fe f8 07 c0 	ld.w	r8,pc[1984]
80003828:	70 0a       	ld.w	r10,r8[0x0]
8000382a:	fe f9 07 52 	ld.w	r9,pc[1874]
8000382e:	72 09       	ld.w	r9,r9[0x0]
80003830:	8e 7b       	ld.sh	r11,r7[0xe]
80003832:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80003836:	70 09       	ld.w	r9,r8[0x0]
80003838:	2f f9       	sub	r9,-1
8000383a:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
8000383c:	e0 49 00 ff 	cp.w	r9,255
80003840:	e0 88 00 16 	brls	8000386c <phy_rx_func+0x790>
						{
							RxMedia_IsFillingNext16 = 0;
80003844:	30 09       	mov	r9,0
80003846:	91 09       	st.w	r8[0x0],r9
							payload_rx(payload_ptr);
80003848:	fe f7 07 34 	ld.w	r7,pc[1844]
8000384c:	6e 0c       	ld.w	r12,r7[0x0]
8000384e:	f0 1f 01 d8 	mcall	80003fac <phy_rx_func+0xed0>
							payload_ptr = get_payload_idle_isr();
80003852:	fe f8 07 26 	ld.w	r8,pc[1830]
80003856:	70 0c       	ld.w	r12,r8[0x0]
80003858:	f0 1f 01 c2 	mcall	80003f60 <phy_rx_func+0xe84>
8000385c:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == payload_ptr)
8000385e:	c0 71       	brne	8000386c <phy_rx_func+0x790>
							{
								RxMediaState = WAITINGABAB;
80003860:	30 09       	mov	r9,0
80003862:	fe f8 07 26 	ld.w	r8,pc[1830]
80003866:	91 09       	st.w	r8[0x0],r9
80003868:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
				if ((RxBytesWaiting -= 2) <= 0){
8000386c:	fe f9 07 24 	ld.w	r9,pc[1828]
80003870:	72 08       	ld.w	r8,r9[0x0]
80003872:	20 28       	sub	r8,2
80003874:	93 08       	st.w	r9[0x0],r8
80003876:	e0 81 03 67 	brne	80003f44 <phy_rx_func+0xe68>
					RxMediaState = WAITINGABAB;
8000387a:	30 09       	mov	r9,0
8000387c:	fe f8 07 0c 	ld.w	r8,pc[1804]
80003880:	91 09       	st.w	r8[0x0],r9
80003882:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

		case READING_AMBE_MEDIA:
		
			/****AMBE-media-data ****/
		
					if ((Item_ID == Vocoder_Bit_Stream_Parameter))//PAYLOAD_DATA_ENH (0x0c))
80003886:	fe f8 07 16 	ld.w	r8,pc[1814]
8000388a:	11 89       	ld.ub	r9,r8[0x0]
8000388c:	31 28       	mov	r8,18
8000388e:	f0 09 18 00 	cp.b	r9,r8
80003892:	e0 81 01 4c 	brne	80003b2a <phy_rx_func+0xa4e>
					{
						Item_ID = payload_rx_channel->byte[1];
80003896:	ef 39 00 09 	ld.ub	r9,r7[9]
8000389a:	fe f8 07 02 	ld.w	r8,pc[1794]
8000389e:	b0 89       	st.b	r8[0x0],r9
						if (Item_ID == Post_Voice_Encoder_Data)//发送方的压缩类型数据
800038a0:	11 89       	ld.ub	r9,r8[0x0]
800038a2:	3f 28       	mov	r8,-14
800038a4:	f0 09 18 00 	cp.b	r9,r8
800038a8:	e0 81 01 3b 	brne	80003b1e <phy_rx_func+0xa42>
						{
							AMBE_tx_flag = 1;
800038ac:	30 19       	mov	r9,1
800038ae:	fe f8 07 1e 	ld.w	r8,pc[1822]
800038b2:	b0 89       	st.b	r8[0x0],r9
							
							RxBytesWaiting = ((payload_rx_channel->dword[0] & 0x7F000000) >>24);//Test calculations are correct; 8
800038b4:	6e 29       	ld.w	r9,r7[0x8]
800038b6:	f3 d9 c3 07 	bfextu	r9,r9,0x18,0x7
800038ba:	fe f8 06 d6 	ld.w	r8,pc[1750]
800038be:	91 09       	st.w	r8[0x0],r9
							
							//For looping back to Radio
							AMBEBurst_rawdata[0] = payload_rx_channel->word[1];
800038c0:	8e 59       	ld.sh	r9,r7[0xa]
800038c2:	fe f8 07 2a 	ld.w	r8,pc[1834]
800038c6:	b0 09       	st.h	r8[0x0],r9
							AMBEBurst_rawdata[1] = payload_rx_channel->word[2];
800038c8:	8e 69       	ld.sh	r9,r7[0xc]
800038ca:	b0 19       	st.h	r8[0x2],r9
							AMBEBurst_rawdata[2] = payload_rx_channel->word[3];
800038cc:	8e 79       	ld.sh	r9,r7[0xe]
800038ce:	b0 29       	st.h	r8[0x4],r9
							
							//To be tested. Also locally stored RAW-AMBER-DATA
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//1
800038d0:	fe f8 06 d4 	ld.w	r8,pc[1748]
800038d4:	fe f9 06 ac 	ld.w	r9,pc[1708]
800038d8:	72 0a       	ld.w	r10,r9[0x0]
800038da:	70 09       	ld.w	r9,r8[0x0]
800038dc:	ef 3b 00 0a 	ld.ub	r11,r7[10]
800038e0:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
800038e4:	70 09       	ld.w	r9,r8[0x0]
800038e6:	2f f9       	sub	r9,-1
800038e8:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800038ea:	e0 49 01 ff 	cp.w	r9,511
800038ee:	e0 88 00 16 	brls	8000391a <phy_rx_func+0x83e>
							{
								RxAMBE_IsFillingNext8 = 0;
800038f2:	30 09       	mov	r9,0
800038f4:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800038f6:	fe f6 06 8a 	ld.w	r6,pc[1674]
800038fa:	6c 0c       	ld.w	r12,r6[0x0]
800038fc:	f0 1f 01 ac 	mcall	80003fac <phy_rx_func+0xed0>
								AMBE_payload_ptr = get_payload_idle_isr();
80003900:	fe f8 06 78 	ld.w	r8,pc[1656]
80003904:	70 0c       	ld.w	r12,r8[0x0]
80003906:	f0 1f 01 97 	mcall	80003f60 <phy_rx_func+0xe84>
8000390a:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
8000390c:	c0 71       	brne	8000391a <phy_rx_func+0x83e>
								{
									RxMediaState = WAITINGABAB;
8000390e:	30 09       	mov	r9,0
80003910:	fe f8 06 78 	ld.w	r8,pc[1656]
80003914:	91 09       	st.w	r8[0x0],r9
80003916:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
8000391a:	fe f9 06 76 	ld.w	r9,pc[1654]
8000391e:	72 08       	ld.w	r8,r9[0x0]
80003920:	20 18       	sub	r8,1
80003922:	93 08       	st.w	r9[0x0],r8
80003924:	c0 71       	brne	80003932 <phy_rx_func+0x856>
								RxMediaState = WAITINGABAB;
80003926:	30 09       	mov	r9,0
80003928:	fe f8 06 60 	ld.w	r8,pc[1632]
8000392c:	91 09       	st.w	r8[0x0],r9
8000392e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}			
							
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//2
80003932:	fe f8 06 72 	ld.w	r8,pc[1650]
80003936:	fe f9 06 4a 	ld.w	r9,pc[1610]
8000393a:	72 0a       	ld.w	r10,r9[0x0]
8000393c:	70 09       	ld.w	r9,r8[0x0]
8000393e:	ef 3b 00 0b 	ld.ub	r11,r7[11]
80003942:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003946:	70 09       	ld.w	r9,r8[0x0]
80003948:	2f f9       	sub	r9,-1
8000394a:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000394c:	e0 49 01 ff 	cp.w	r9,511
80003950:	e0 88 00 16 	brls	8000397c <phy_rx_func+0x8a0>
							{
								RxAMBE_IsFillingNext8 = 0;
80003954:	30 09       	mov	r9,0
80003956:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003958:	fe f6 06 28 	ld.w	r6,pc[1576]
8000395c:	6c 0c       	ld.w	r12,r6[0x0]
8000395e:	f0 1f 01 94 	mcall	80003fac <phy_rx_func+0xed0>
								AMBE_payload_ptr = get_payload_idle_isr();
80003962:	fe f8 06 16 	ld.w	r8,pc[1558]
80003966:	70 0c       	ld.w	r12,r8[0x0]
80003968:	f0 1f 01 7e 	mcall	80003f60 <phy_rx_func+0xe84>
8000396c:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
8000396e:	c0 71       	brne	8000397c <phy_rx_func+0x8a0>
								{
									RxMediaState = WAITINGABAB;
80003970:	30 09       	mov	r9,0
80003972:	fe f8 06 16 	ld.w	r8,pc[1558]
80003976:	91 09       	st.w	r8[0x0],r9
80003978:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
8000397c:	fe f9 06 14 	ld.w	r9,pc[1556]
80003980:	72 08       	ld.w	r8,r9[0x0]
80003982:	20 18       	sub	r8,1
80003984:	93 08       	st.w	r9[0x0],r8
80003986:	c0 71       	brne	80003994 <phy_rx_func+0x8b8>
								RxMediaState = WAITINGABAB;
80003988:	30 09       	mov	r9,0
8000398a:	fe f8 05 fe 	ld.w	r8,pc[1534]
8000398e:	91 09       	st.w	r8[0x0],r9
80003990:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}		
						
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//3
80003994:	fe f8 06 10 	ld.w	r8,pc[1552]
80003998:	fe f9 05 e8 	ld.w	r9,pc[1512]
8000399c:	72 0a       	ld.w	r10,r9[0x0]
8000399e:	70 09       	ld.w	r9,r8[0x0]
800039a0:	ef 3b 00 0c 	ld.ub	r11,r7[12]
800039a4:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
800039a8:	70 09       	ld.w	r9,r8[0x0]
800039aa:	2f f9       	sub	r9,-1
800039ac:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800039ae:	e0 49 01 ff 	cp.w	r9,511
800039b2:	e0 88 00 16 	brls	800039de <phy_rx_func+0x902>
							{
								RxAMBE_IsFillingNext8 = 0;
800039b6:	30 09       	mov	r9,0
800039b8:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800039ba:	fe f6 05 c6 	ld.w	r6,pc[1478]
800039be:	6c 0c       	ld.w	r12,r6[0x0]
800039c0:	f0 1f 01 7b 	mcall	80003fac <phy_rx_func+0xed0>
								AMBE_payload_ptr = get_payload_idle_isr();
800039c4:	fe f8 05 b4 	ld.w	r8,pc[1460]
800039c8:	70 0c       	ld.w	r12,r8[0x0]
800039ca:	f0 1f 01 66 	mcall	80003f60 <phy_rx_func+0xe84>
800039ce:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
800039d0:	c0 71       	brne	800039de <phy_rx_func+0x902>
								{
									RxMediaState = WAITINGABAB;
800039d2:	30 09       	mov	r9,0
800039d4:	fe f8 05 b4 	ld.w	r8,pc[1460]
800039d8:	91 09       	st.w	r8[0x0],r9
800039da:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800039de:	fe f9 05 b2 	ld.w	r9,pc[1458]
800039e2:	72 08       	ld.w	r8,r9[0x0]
800039e4:	20 18       	sub	r8,1
800039e6:	93 08       	st.w	r9[0x0],r8
800039e8:	c0 71       	brne	800039f6 <phy_rx_func+0x91a>
								RxMediaState = WAITINGABAB;
800039ea:	30 09       	mov	r9,0
800039ec:	fe f8 05 9c 	ld.w	r8,pc[1436]
800039f0:	91 09       	st.w	r8[0x0],r9
800039f2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[5];//4
800039f6:	fe f8 05 ae 	ld.w	r8,pc[1454]
800039fa:	fe f9 05 86 	ld.w	r9,pc[1414]
800039fe:	72 0a       	ld.w	r10,r9[0x0]
80003a00:	70 09       	ld.w	r9,r8[0x0]
80003a02:	ef 3b 00 0d 	ld.ub	r11,r7[13]
80003a06:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003a0a:	70 09       	ld.w	r9,r8[0x0]
80003a0c:	2f f9       	sub	r9,-1
80003a0e:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003a10:	e0 49 01 ff 	cp.w	r9,511
80003a14:	e0 88 00 16 	brls	80003a40 <phy_rx_func+0x964>
							{
								RxAMBE_IsFillingNext8 = 0;
80003a18:	30 09       	mov	r9,0
80003a1a:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003a1c:	fe f6 05 64 	ld.w	r6,pc[1380]
80003a20:	6c 0c       	ld.w	r12,r6[0x0]
80003a22:	f0 1f 01 63 	mcall	80003fac <phy_rx_func+0xed0>
								AMBE_payload_ptr = get_payload_idle_isr();
80003a26:	fe f8 05 52 	ld.w	r8,pc[1362]
80003a2a:	70 0c       	ld.w	r12,r8[0x0]
80003a2c:	f0 1f 01 4d 	mcall	80003f60 <phy_rx_func+0xe84>
80003a30:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003a32:	c0 71       	brne	80003a40 <phy_rx_func+0x964>
								{
									RxMediaState = WAITINGABAB;
80003a34:	30 09       	mov	r9,0
80003a36:	fe f8 05 52 	ld.w	r8,pc[1362]
80003a3a:	91 09       	st.w	r8[0x0],r9
80003a3c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003a40:	fe f9 05 50 	ld.w	r9,pc[1360]
80003a44:	72 08       	ld.w	r8,r9[0x0]
80003a46:	20 18       	sub	r8,1
80003a48:	93 08       	st.w	r9[0x0],r8
80003a4a:	c0 71       	brne	80003a58 <phy_rx_func+0x97c>
								RxMediaState = WAITINGABAB;
80003a4c:	30 09       	mov	r9,0
80003a4e:	fe f8 05 3a 	ld.w	r8,pc[1338]
80003a52:	91 09       	st.w	r8[0x0],r9
80003a54:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//5
80003a58:	fe f8 05 4c 	ld.w	r8,pc[1356]
80003a5c:	fe f9 05 24 	ld.w	r9,pc[1316]
80003a60:	72 0a       	ld.w	r10,r9[0x0]
80003a62:	70 09       	ld.w	r9,r8[0x0]
80003a64:	ef 3b 00 0e 	ld.ub	r11,r7[14]
80003a68:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003a6c:	70 09       	ld.w	r9,r8[0x0]
80003a6e:	2f f9       	sub	r9,-1
80003a70:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003a72:	e0 49 01 ff 	cp.w	r9,511
80003a76:	e0 88 00 16 	brls	80003aa2 <phy_rx_func+0x9c6>
							{
								RxAMBE_IsFillingNext8 = 0;
80003a7a:	30 09       	mov	r9,0
80003a7c:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003a7e:	fe f6 05 02 	ld.w	r6,pc[1282]
80003a82:	6c 0c       	ld.w	r12,r6[0x0]
80003a84:	f0 1f 01 4a 	mcall	80003fac <phy_rx_func+0xed0>
								AMBE_payload_ptr = get_payload_idle_isr();
80003a88:	fe f8 04 f0 	ld.w	r8,pc[1264]
80003a8c:	70 0c       	ld.w	r12,r8[0x0]
80003a8e:	f0 1f 01 35 	mcall	80003f60 <phy_rx_func+0xe84>
80003a92:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003a94:	c0 71       	brne	80003aa2 <phy_rx_func+0x9c6>
								{
									RxMediaState = WAITINGABAB;
80003a96:	30 09       	mov	r9,0
80003a98:	fe f8 04 f0 	ld.w	r8,pc[1264]
80003a9c:	91 09       	st.w	r8[0x0],r9
80003a9e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003aa2:	fe f9 04 ee 	ld.w	r9,pc[1262]
80003aa6:	72 08       	ld.w	r8,r9[0x0]
80003aa8:	20 18       	sub	r8,1
80003aaa:	93 08       	st.w	r9[0x0],r8
80003aac:	c0 71       	brne	80003aba <phy_rx_func+0x9de>
								RxMediaState = WAITINGABAB;
80003aae:	30 09       	mov	r9,0
80003ab0:	fe f8 04 d8 	ld.w	r8,pc[1240]
80003ab4:	91 09       	st.w	r8[0x0],r9
80003ab6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//6
80003aba:	fe f8 04 ea 	ld.w	r8,pc[1258]
80003abe:	fe f9 04 c2 	ld.w	r9,pc[1218]
80003ac2:	72 0a       	ld.w	r10,r9[0x0]
80003ac4:	70 09       	ld.w	r9,r8[0x0]
80003ac6:	ef 3b 00 0f 	ld.ub	r11,r7[15]
80003aca:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003ace:	70 09       	ld.w	r9,r8[0x0]
80003ad0:	2f f9       	sub	r9,-1
80003ad2:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003ad4:	e0 49 01 ff 	cp.w	r9,511
80003ad8:	e0 88 00 16 	brls	80003b04 <phy_rx_func+0xa28>
							{
								RxAMBE_IsFillingNext8 = 0;
80003adc:	30 09       	mov	r9,0
80003ade:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003ae0:	fe f7 04 a0 	ld.w	r7,pc[1184]
80003ae4:	6e 0c       	ld.w	r12,r7[0x0]
80003ae6:	f0 1f 01 32 	mcall	80003fac <phy_rx_func+0xed0>
								AMBE_payload_ptr = get_payload_idle_isr();
80003aea:	fe f8 04 8e 	ld.w	r8,pc[1166]
80003aee:	70 0c       	ld.w	r12,r8[0x0]
80003af0:	f0 1f 01 1c 	mcall	80003f60 <phy_rx_func+0xe84>
80003af4:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003af6:	c0 71       	brne	80003b04 <phy_rx_func+0xa28>
								{
									RxMediaState = WAITINGABAB;
80003af8:	30 09       	mov	r9,0
80003afa:	fe f8 04 8e 	ld.w	r8,pc[1166]
80003afe:	91 09       	st.w	r8[0x0],r9
80003b00:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003b04:	fe f9 04 8c 	ld.w	r9,pc[1164]
80003b08:	72 08       	ld.w	r8,r9[0x0]
80003b0a:	20 18       	sub	r8,1
80003b0c:	93 08       	st.w	r9[0x0],r8
80003b0e:	e0 81 02 1b 	brne	80003f44 <phy_rx_func+0xe68>
								RxMediaState = WAITINGABAB;
80003b12:	30 09       	mov	r9,0
80003b14:	fe f8 04 74 	ld.w	r8,pc[1140]
80003b18:	91 09       	st.w	r8[0x0],r9
80003b1a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							//}
							
						}
						else//error
						{
							RxMediaState = WAITINGABAB;
80003b1e:	30 09       	mov	r9,0
80003b20:	fe f8 04 68 	ld.w	r8,pc[1128]
80003b24:	91 09       	st.w	r8[0x0],r9
80003b26:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
					}
					else if (Item_ID == Post_Voice_Encoder_Data)//(bit48~Pad-bits)
80003b2a:	fe f8 04 72 	ld.w	r8,pc[1138]
80003b2e:	11 89       	ld.ub	r9,r8[0x0]
80003b30:	3f 28       	mov	r8,-14
80003b32:	f0 09 18 00 	cp.b	r9,r8
80003b36:	c4 31       	brne	80003bbc <phy_rx_func+0xae0>
					{
					
						AMBEBurst_rawdata[3] = payload_rx_channel->word[0];//(bit48~Pad-bits)
80003b38:	8e 49       	ld.sh	r9,r7[0x8]
80003b3a:	fe f8 04 b2 	ld.w	r8,pc[1202]
80003b3e:	b0 39       	st.h	r8[0x6],r9
						//AMBE_Per_Burst_Flag = 1;
						
						//根据MOTO.bit文件数据分布，建议测试pad-bits的最后一个字节不保存。
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//7
80003b40:	fe f8 04 64 	ld.w	r8,pc[1124]
80003b44:	fe f9 04 3c 	ld.w	r9,pc[1084]
80003b48:	72 0a       	ld.w	r10,r9[0x0]
80003b4a:	70 09       	ld.w	r9,r8[0x0]
80003b4c:	ef 3b 00 08 	ld.ub	r11,r7[8]
80003b50:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003b54:	70 09       	ld.w	r9,r8[0x0]
80003b56:	2f f9       	sub	r9,-1
80003b58:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003b5a:	e0 49 01 ff 	cp.w	r9,511
80003b5e:	e0 88 00 16 	brls	80003b8a <phy_rx_func+0xaae>
						{
							RxAMBE_IsFillingNext8 = 0;
80003b62:	30 09       	mov	r9,0
80003b64:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003b66:	fe f7 04 1a 	ld.w	r7,pc[1050]
80003b6a:	6e 0c       	ld.w	r12,r7[0x0]
80003b6c:	f0 1f 01 10 	mcall	80003fac <phy_rx_func+0xed0>
							AMBE_payload_ptr = get_payload_idle_isr();
80003b70:	fe f8 04 08 	ld.w	r8,pc[1032]
80003b74:	70 0c       	ld.w	r12,r8[0x0]
80003b76:	f0 1f 00 fb 	mcall	80003f60 <phy_rx_func+0xe84>
80003b7a:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003b7c:	c0 71       	brne	80003b8a <phy_rx_func+0xaae>
							{
								RxMediaState = WAITINGABAB;
80003b7e:	30 09       	mov	r9,0
80003b80:	fe f8 04 08 	ld.w	r8,pc[1032]
80003b84:	91 09       	st.w	r8[0x0],r9
80003b86:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003b8a:	fe f9 04 06 	ld.w	r9,pc[1030]
80003b8e:	72 08       	ld.w	r8,r9[0x0]
80003b90:	20 18       	sub	r8,1
80003b92:	93 08       	st.w	r9[0x0],r8
80003b94:	c0 71       	brne	80003ba2 <phy_rx_func+0xac6>
							RxMediaState = WAITINGABAB;
80003b96:	30 09       	mov	r9,0
80003b98:	fe f8 03 f0 	ld.w	r8,pc[1008]
80003b9c:	91 09       	st.w	r8[0x0],r9
80003b9e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
						if ((RxBytesWaiting -= 1) <= 0){//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
80003ba2:	20 18       	sub	r8,1
80003ba4:	fe f9 03 ec 	ld.w	r9,pc[1004]
80003ba8:	93 08       	st.w	r9[0x0],r8
80003baa:	58 08       	cp.w	r8,0
80003bac:	e0 81 01 cc 	brne	80003f44 <phy_rx_func+0xe68>
							RxMediaState = WAITINGABAB;
80003bb0:	30 09       	mov	r9,0
80003bb2:	fe f8 03 d6 	ld.w	r8,pc[982]
80003bb6:	91 09       	st.w	r8[0x0],r9
80003bb8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
								
					}
					else if (Item_ID == Pre_Voice_Decoder_Data)//bit0~bit63
80003bbc:	fe f8 03 e0 	ld.w	r8,pc[992]
80003bc0:	11 89       	ld.ub	r9,r8[0x0]
80003bc2:	3f 38       	mov	r8,-13
80003bc4:	f0 09 18 00 	cp.b	r9,r8
80003bc8:	e0 81 01 5a 	brne	80003e7c <phy_rx_func+0xda0>
					{
						//接收方的解压类型数据
						//For looping back to Radio
						AMBEBurst_rawdata[0] = payload_rx_channel->word[0];
80003bcc:	8e 49       	ld.sh	r9,r7[0x8]
80003bce:	fe f8 04 1e 	ld.w	r8,pc[1054]
80003bd2:	b0 09       	st.h	r8[0x0],r9
						AMBEBurst_rawdata[1] = payload_rx_channel->word[1];
80003bd4:	8e 59       	ld.sh	r9,r7[0xa]
80003bd6:	b0 19       	st.h	r8[0x2],r9
						AMBEBurst_rawdata[2] = payload_rx_channel->word[2];
80003bd8:	8e 69       	ld.sh	r9,r7[0xc]
80003bda:	b0 29       	st.h	r8[0x4],r9
						AMBEBurst_rawdata[3] = payload_rx_channel->word[3];
80003bdc:	8e 79       	ld.sh	r9,r7[0xe]
80003bde:	b0 39       	st.h	r8[0x6],r9
						
						//To be tested. Also locally stored RAW-AMBER-DATA
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//1
80003be0:	fe f8 03 c4 	ld.w	r8,pc[964]
80003be4:	fe f9 03 9c 	ld.w	r9,pc[924]
80003be8:	72 0a       	ld.w	r10,r9[0x0]
80003bea:	70 09       	ld.w	r9,r8[0x0]
80003bec:	ef 3b 00 08 	ld.ub	r11,r7[8]
80003bf0:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003bf4:	70 09       	ld.w	r9,r8[0x0]
80003bf6:	2f f9       	sub	r9,-1
80003bf8:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003bfa:	e0 49 01 ff 	cp.w	r9,511
80003bfe:	e0 88 00 16 	brls	80003c2a <phy_rx_func+0xb4e>
						{
							RxAMBE_IsFillingNext8 = 0;
80003c02:	30 09       	mov	r9,0
80003c04:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003c06:	fe f6 03 7a 	ld.w	r6,pc[890]
80003c0a:	6c 0c       	ld.w	r12,r6[0x0]
80003c0c:	f0 1f 00 e8 	mcall	80003fac <phy_rx_func+0xed0>
							AMBE_payload_ptr = get_payload_idle_isr();
80003c10:	fe f8 03 68 	ld.w	r8,pc[872]
80003c14:	70 0c       	ld.w	r12,r8[0x0]
80003c16:	f0 1f 00 d3 	mcall	80003f60 <phy_rx_func+0xe84>
80003c1a:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003c1c:	c0 71       	brne	80003c2a <phy_rx_func+0xb4e>
							{
								RxMediaState = WAITINGABAB;
80003c1e:	30 09       	mov	r9,0
80003c20:	fe f8 03 68 	ld.w	r8,pc[872]
80003c24:	91 09       	st.w	r8[0x0],r9
80003c26:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003c2a:	fe f9 03 66 	ld.w	r9,pc[870]
80003c2e:	72 08       	ld.w	r8,r9[0x0]
80003c30:	20 18       	sub	r8,1
80003c32:	93 08       	st.w	r9[0x0],r8
80003c34:	c0 71       	brne	80003c42 <phy_rx_func+0xb66>
							RxMediaState = WAITINGABAB;
80003c36:	30 09       	mov	r9,0
80003c38:	fe f8 03 50 	ld.w	r8,pc[848]
80003c3c:	91 09       	st.w	r8[0x0],r9
80003c3e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[1];//2
80003c42:	fe f8 03 62 	ld.w	r8,pc[866]
80003c46:	fe f9 03 3a 	ld.w	r9,pc[826]
80003c4a:	72 0a       	ld.w	r10,r9[0x0]
80003c4c:	70 09       	ld.w	r9,r8[0x0]
80003c4e:	ef 3b 00 09 	ld.ub	r11,r7[9]
80003c52:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003c56:	70 09       	ld.w	r9,r8[0x0]
80003c58:	2f f9       	sub	r9,-1
80003c5a:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003c5c:	e0 49 01 ff 	cp.w	r9,511
80003c60:	e0 88 00 16 	brls	80003c8c <phy_rx_func+0xbb0>
						{
							RxAMBE_IsFillingNext8 = 0;
80003c64:	30 09       	mov	r9,0
80003c66:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003c68:	fe f6 03 18 	ld.w	r6,pc[792]
80003c6c:	6c 0c       	ld.w	r12,r6[0x0]
80003c6e:	f0 1f 00 d0 	mcall	80003fac <phy_rx_func+0xed0>
							AMBE_payload_ptr = get_payload_idle_isr();
80003c72:	fe f8 03 06 	ld.w	r8,pc[774]
80003c76:	70 0c       	ld.w	r12,r8[0x0]
80003c78:	f0 1f 00 ba 	mcall	80003f60 <phy_rx_func+0xe84>
80003c7c:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003c7e:	c0 71       	brne	80003c8c <phy_rx_func+0xbb0>
							{
								RxMediaState = WAITINGABAB;
80003c80:	30 09       	mov	r9,0
80003c82:	fe f8 03 06 	ld.w	r8,pc[774]
80003c86:	91 09       	st.w	r8[0x0],r9
80003c88:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003c8c:	fe f9 03 04 	ld.w	r9,pc[772]
80003c90:	72 08       	ld.w	r8,r9[0x0]
80003c92:	20 18       	sub	r8,1
80003c94:	93 08       	st.w	r9[0x0],r8
80003c96:	c0 71       	brne	80003ca4 <phy_rx_func+0xbc8>
							RxMediaState = WAITINGABAB;
80003c98:	30 09       	mov	r9,0
80003c9a:	fe f8 02 ee 	ld.w	r8,pc[750]
80003c9e:	91 09       	st.w	r8[0x0],r9
80003ca0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//3
80003ca4:	fe f8 03 00 	ld.w	r8,pc[768]
80003ca8:	fe f9 02 d8 	ld.w	r9,pc[728]
80003cac:	72 0a       	ld.w	r10,r9[0x0]
80003cae:	70 09       	ld.w	r9,r8[0x0]
80003cb0:	ef 3b 00 0a 	ld.ub	r11,r7[10]
80003cb4:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003cb8:	70 09       	ld.w	r9,r8[0x0]
80003cba:	2f f9       	sub	r9,-1
80003cbc:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003cbe:	e0 49 01 ff 	cp.w	r9,511
80003cc2:	e0 88 00 16 	brls	80003cee <phy_rx_func+0xc12>
						{
							RxAMBE_IsFillingNext8 = 0;
80003cc6:	30 09       	mov	r9,0
80003cc8:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003cca:	fe f6 02 b6 	ld.w	r6,pc[694]
80003cce:	6c 0c       	ld.w	r12,r6[0x0]
80003cd0:	f0 1f 00 b7 	mcall	80003fac <phy_rx_func+0xed0>
							AMBE_payload_ptr = get_payload_idle_isr();
80003cd4:	fe f8 02 a4 	ld.w	r8,pc[676]
80003cd8:	70 0c       	ld.w	r12,r8[0x0]
80003cda:	f0 1f 00 a2 	mcall	80003f60 <phy_rx_func+0xe84>
80003cde:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003ce0:	c0 71       	brne	80003cee <phy_rx_func+0xc12>
							{
								RxMediaState = WAITINGABAB;
80003ce2:	30 09       	mov	r9,0
80003ce4:	fe f8 02 a4 	ld.w	r8,pc[676]
80003ce8:	91 09       	st.w	r8[0x0],r9
80003cea:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003cee:	fe f9 02 a2 	ld.w	r9,pc[674]
80003cf2:	72 08       	ld.w	r8,r9[0x0]
80003cf4:	20 18       	sub	r8,1
80003cf6:	93 08       	st.w	r9[0x0],r8
80003cf8:	c0 71       	brne	80003d06 <phy_rx_func+0xc2a>
							RxMediaState = WAITINGABAB;
80003cfa:	30 09       	mov	r9,0
80003cfc:	fe f8 02 8c 	ld.w	r8,pc[652]
80003d00:	91 09       	st.w	r8[0x0],r9
80003d02:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//4
80003d06:	fe f8 02 9e 	ld.w	r8,pc[670]
80003d0a:	fe f9 02 76 	ld.w	r9,pc[630]
80003d0e:	72 0a       	ld.w	r10,r9[0x0]
80003d10:	70 09       	ld.w	r9,r8[0x0]
80003d12:	ef 3b 00 0b 	ld.ub	r11,r7[11]
80003d16:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003d1a:	70 09       	ld.w	r9,r8[0x0]
80003d1c:	2f f9       	sub	r9,-1
80003d1e:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003d20:	e0 49 01 ff 	cp.w	r9,511
80003d24:	e0 88 00 16 	brls	80003d50 <phy_rx_func+0xc74>
						{
							RxAMBE_IsFillingNext8 = 0;
80003d28:	30 09       	mov	r9,0
80003d2a:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003d2c:	fe f6 02 54 	ld.w	r6,pc[596]
80003d30:	6c 0c       	ld.w	r12,r6[0x0]
80003d32:	f0 1f 00 9f 	mcall	80003fac <phy_rx_func+0xed0>
							AMBE_payload_ptr = get_payload_idle_isr();
80003d36:	fe f8 02 42 	ld.w	r8,pc[578]
80003d3a:	70 0c       	ld.w	r12,r8[0x0]
80003d3c:	f0 1f 00 89 	mcall	80003f60 <phy_rx_func+0xe84>
80003d40:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003d42:	c0 71       	brne	80003d50 <phy_rx_func+0xc74>
							{
								RxMediaState = WAITINGABAB;
80003d44:	30 09       	mov	r9,0
80003d46:	fe f8 02 42 	ld.w	r8,pc[578]
80003d4a:	91 09       	st.w	r8[0x0],r9
80003d4c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003d50:	fe f9 02 40 	ld.w	r9,pc[576]
80003d54:	72 08       	ld.w	r8,r9[0x0]
80003d56:	20 18       	sub	r8,1
80003d58:	93 08       	st.w	r9[0x0],r8
80003d5a:	c0 71       	brne	80003d68 <phy_rx_func+0xc8c>
							RxMediaState = WAITINGABAB;
80003d5c:	30 09       	mov	r9,0
80003d5e:	fe f8 02 2a 	ld.w	r8,pc[554]
80003d62:	91 09       	st.w	r8[0x0],r9
80003d64:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//5
80003d68:	fe f8 02 3c 	ld.w	r8,pc[572]
80003d6c:	fe f9 02 14 	ld.w	r9,pc[532]
80003d70:	72 0a       	ld.w	r10,r9[0x0]
80003d72:	70 09       	ld.w	r9,r8[0x0]
80003d74:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80003d78:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003d7c:	70 09       	ld.w	r9,r8[0x0]
80003d7e:	2f f9       	sub	r9,-1
80003d80:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003d82:	e0 49 01 ff 	cp.w	r9,511
80003d86:	e0 88 00 13 	brls	80003dac <phy_rx_func+0xcd0>
						{
							RxAMBE_IsFillingNext8 = 0;
80003d8a:	30 09       	mov	r9,0
80003d8c:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003d8e:	4f d6       	lddpc	r6,80003f80 <phy_rx_func+0xea4>
80003d90:	6c 0c       	ld.w	r12,r6[0x0]
80003d92:	f0 1f 00 87 	mcall	80003fac <phy_rx_func+0xed0>
							AMBE_payload_ptr = get_payload_idle_isr();
80003d96:	4f 98       	lddpc	r8,80003f78 <phy_rx_func+0xe9c>
80003d98:	70 0c       	ld.w	r12,r8[0x0]
80003d9a:	f0 1f 00 72 	mcall	80003f60 <phy_rx_func+0xe84>
80003d9e:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003da0:	c0 61       	brne	80003dac <phy_rx_func+0xcd0>
							{
								RxMediaState = WAITINGABAB;
80003da2:	30 09       	mov	r9,0
80003da4:	4f 98       	lddpc	r8,80003f88 <phy_rx_func+0xeac>
80003da6:	91 09       	st.w	r8[0x0],r9
80003da8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003dac:	4f 99       	lddpc	r9,80003f90 <phy_rx_func+0xeb4>
80003dae:	72 08       	ld.w	r8,r9[0x0]
80003db0:	20 18       	sub	r8,1
80003db2:	93 08       	st.w	r9[0x0],r8
80003db4:	c0 61       	brne	80003dc0 <phy_rx_func+0xce4>
							RxMediaState = WAITINGABAB;
80003db6:	30 09       	mov	r9,0
80003db8:	4f 48       	lddpc	r8,80003f88 <phy_rx_func+0xeac>
80003dba:	91 09       	st.w	r8[0x0],r9
80003dbc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[5];//6
80003dc0:	4f 98       	lddpc	r8,80003fa4 <phy_rx_func+0xec8>
80003dc2:	4f 09       	lddpc	r9,80003f80 <phy_rx_func+0xea4>
80003dc4:	72 0a       	ld.w	r10,r9[0x0]
80003dc6:	70 09       	ld.w	r9,r8[0x0]
80003dc8:	ef 3b 00 0d 	ld.ub	r11,r7[13]
80003dcc:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003dd0:	70 09       	ld.w	r9,r8[0x0]
80003dd2:	2f f9       	sub	r9,-1
80003dd4:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003dd6:	e0 49 01 ff 	cp.w	r9,511
80003dda:	e0 88 00 13 	brls	80003e00 <phy_rx_func+0xd24>
						{
							RxAMBE_IsFillingNext8 = 0;
80003dde:	30 09       	mov	r9,0
80003de0:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003de2:	4e 86       	lddpc	r6,80003f80 <phy_rx_func+0xea4>
80003de4:	6c 0c       	ld.w	r12,r6[0x0]
80003de6:	f0 1f 00 72 	mcall	80003fac <phy_rx_func+0xed0>
							AMBE_payload_ptr = get_payload_idle_isr();
80003dea:	4e 48       	lddpc	r8,80003f78 <phy_rx_func+0xe9c>
80003dec:	70 0c       	ld.w	r12,r8[0x0]
80003dee:	f0 1f 00 5d 	mcall	80003f60 <phy_rx_func+0xe84>
80003df2:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003df4:	c0 61       	brne	80003e00 <phy_rx_func+0xd24>
							{
								RxMediaState = WAITINGABAB;
80003df6:	30 09       	mov	r9,0
80003df8:	4e 48       	lddpc	r8,80003f88 <phy_rx_func+0xeac>
80003dfa:	91 09       	st.w	r8[0x0],r9
80003dfc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003e00:	4e 49       	lddpc	r9,80003f90 <phy_rx_func+0xeb4>
80003e02:	72 08       	ld.w	r8,r9[0x0]
80003e04:	20 18       	sub	r8,1
80003e06:	93 08       	st.w	r9[0x0],r8
80003e08:	c0 61       	brne	80003e14 <phy_rx_func+0xd38>
							RxMediaState = WAITINGABAB;
80003e0a:	30 09       	mov	r9,0
80003e0c:	4d f8       	lddpc	r8,80003f88 <phy_rx_func+0xeac>
80003e0e:	91 09       	st.w	r8[0x0],r9
80003e10:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//7
80003e14:	4e 48       	lddpc	r8,80003fa4 <phy_rx_func+0xec8>
80003e16:	4d b9       	lddpc	r9,80003f80 <phy_rx_func+0xea4>
80003e18:	72 0a       	ld.w	r10,r9[0x0]
80003e1a:	70 09       	ld.w	r9,r8[0x0]
80003e1c:	ef 3b 00 0e 	ld.ub	r11,r7[14]
80003e20:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003e24:	70 09       	ld.w	r9,r8[0x0]
80003e26:	2f f9       	sub	r9,-1
80003e28:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003e2a:	e0 49 01 ff 	cp.w	r9,511
80003e2e:	e0 88 00 13 	brls	80003e54 <phy_rx_func+0xd78>
						{
							RxAMBE_IsFillingNext8 = 0;
80003e32:	30 09       	mov	r9,0
80003e34:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003e36:	4d 37       	lddpc	r7,80003f80 <phy_rx_func+0xea4>
80003e38:	6e 0c       	ld.w	r12,r7[0x0]
80003e3a:	f0 1f 00 5d 	mcall	80003fac <phy_rx_func+0xed0>
							AMBE_payload_ptr = get_payload_idle_isr();
80003e3e:	4c f8       	lddpc	r8,80003f78 <phy_rx_func+0xe9c>
80003e40:	70 0c       	ld.w	r12,r8[0x0]
80003e42:	f0 1f 00 48 	mcall	80003f60 <phy_rx_func+0xe84>
80003e46:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003e48:	c0 61       	brne	80003e54 <phy_rx_func+0xd78>
							{
								RxMediaState = WAITINGABAB;
80003e4a:	30 09       	mov	r9,0
80003e4c:	4c f8       	lddpc	r8,80003f88 <phy_rx_func+0xeac>
80003e4e:	91 09       	st.w	r8[0x0],r9
80003e50:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003e54:	4c f9       	lddpc	r9,80003f90 <phy_rx_func+0xeb4>
80003e56:	72 08       	ld.w	r8,r9[0x0]
80003e58:	20 18       	sub	r8,1
80003e5a:	93 08       	st.w	r9[0x0],r8
80003e5c:	c0 61       	brne	80003e68 <phy_rx_func+0xd8c>
							RxMediaState = WAITINGABAB;
80003e5e:	30 09       	mov	r9,0
80003e60:	4c a8       	lddpc	r8,80003f88 <phy_rx_func+0xeac>
80003e62:	91 09       	st.w	r8[0x0],r9
80003e64:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
						if ((RxBytesWaiting -= 1) <= 0){
80003e68:	20 18       	sub	r8,1
80003e6a:	4c a9       	lddpc	r9,80003f90 <phy_rx_func+0xeb4>
80003e6c:	93 08       	st.w	r9[0x0],r8
80003e6e:	58 08       	cp.w	r8,0
80003e70:	c6 a1       	brne	80003f44 <phy_rx_func+0xe68>
							
							//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
							//or discard it to reduce payload size.
							
							RxMediaState = WAITINGABAB;
80003e72:	30 09       	mov	r9,0
80003e74:	4c 58       	lddpc	r8,80003f88 <phy_rx_func+0xeac>
80003e76:	91 09       	st.w	r8[0x0],r9
80003e78:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
					}
					else if ((Item_ID == 0x04)  ||  (Item_ID == 0x03))//Unknown type data directly back hair
80003e7c:	4c 88       	lddpc	r8,80003f9c <phy_rx_func+0xec0>
80003e7e:	11 89       	ld.ub	r9,r8[0x0]
80003e80:	30 48       	mov	r8,4
80003e82:	f0 09 18 00 	cp.b	r9,r8
80003e86:	c0 70       	breq	80003e94 <phy_rx_func+0xdb8>
80003e88:	4c 58       	lddpc	r8,80003f9c <phy_rx_func+0xec0>
80003e8a:	11 89       	ld.ub	r9,r8[0x0]
80003e8c:	30 38       	mov	r8,3
80003e8e:	f0 09 18 00 	cp.b	r9,r8
80003e92:	c1 01       	brne	80003eb2 <phy_rx_func+0xdd6>
					{
						AMBE_HT[0] = payload_rx_channel->dword[0];
80003e94:	6e 29       	ld.w	r9,r7[0x8]
80003e96:	4c d8       	lddpc	r8,80003fc8 <phy_rx_func+0xeec>
80003e98:	91 09       	st.w	r8[0x0],r9
						AMBE_HT[1] = payload_rx_channel->dword[1];				
80003e9a:	6e 39       	ld.w	r9,r7[0xc]
80003e9c:	91 19       	st.w	r8[0x4],r9
						
						if ((RxBytesWaiting -= 8) <= 0)//Consider two cases 0xABCDC014 and 0xABCDC010
80003e9e:	4b d9       	lddpc	r9,80003f90 <phy_rx_func+0xeb4>
80003ea0:	72 08       	ld.w	r8,r9[0x0]
80003ea2:	20 88       	sub	r8,8
80003ea4:	93 08       	st.w	r9[0x0],r8
80003ea6:	c4 f1       	brne	80003f44 <phy_rx_func+0xe68>
						{
					
							RxBytesWaiting = 0;
80003ea8:	93 08       	st.w	r9[0x0],r8
							RxMediaState = WAITINGABAB;
80003eaa:	4b 89       	lddpc	r9,80003f88 <phy_rx_func+0xeac>
80003eac:	93 08       	st.w	r9[0x0],r8
80003eae:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					
					else
					{
						
						RxMediaState  = WAITINGABAB;
80003eb2:	30 09       	mov	r9,0
80003eb4:	4b 58       	lddpc	r8,80003f88 <phy_rx_func+0xeac>
80003eb6:	91 09       	st.w	r8[0x0],r9
80003eb8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
			break;//End of READING_AMBE_MEDIA.

        case READING_AMBE_AUX:
			
				Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[0];
80003ebc:	4c 18       	lddpc	r8,80003fc0 <phy_rx_func+0xee4>
80003ebe:	70 09       	ld.w	r9,r8[0x0]
80003ec0:	8e 4b       	ld.sh	r11,r7[0x8]
80003ec2:	4c 1a       	lddpc	r10,80003fc4 <phy_rx_func+0xee8>
80003ec4:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
				RxData_IsFillingNext16 += 1;
80003ec8:	2f f9       	sub	r9,-1
80003eca:	91 09       	st.w	r8[0x0],r9
			
				if ((Item_Length -= 2) <= 0)
80003ecc:	4b 58       	lddpc	r8,80003fa0 <phy_rx_func+0xec4>
80003ece:	70 09       	ld.w	r9,r8[0x0]
80003ed0:	20 29       	sub	r9,2
80003ed2:	91 09       	st.w	r8[0x0],r9
80003ed4:	70 08       	ld.w	r8,r8[0x0]
80003ed6:	58 08       	cp.w	r8,0
80003ed8:	c3 01       	brne	80003f38 <phy_rx_func+0xe5c>
				{
					RxData_IsFillingNext16 = 0;
80003eda:	30 09       	mov	r9,0
80003edc:	4b 98       	lddpc	r8,80003fc0 <phy_rx_func+0xee4>
80003ede:	91 09       	st.w	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003ee0:	8e 59       	ld.sh	r9,r7[0xa]
80003ee2:	fe 78 82 12 	mov	r8,-32238
80003ee6:	f0 09 19 00 	cp.h	r9,r8
80003eea:	c2 21       	brne	80003f2e <phy_rx_func+0xe52>
				
					if (payload_rx_channel->word[1] == 0x8212 )
					{
						//Item_ID = Vocoder_Bit_Stream_Parameter;
						//Vocoder Bits Stream Parameter
						VF_SN = payload_rx_channel->byte[5];//This parameter is very important to the loop back Radio, as a reference.
80003eec:	ef 3c 00 0d 	ld.ub	r12,r7[13]
80003ef0:	4b 08       	lddpc	r8,80003fb0 <phy_rx_func+0xed4>
80003ef2:	b0 8c       	st.b	r8[0x0],r12
							
						VBSP_data[0] = payload_rx_channel->word[1];
80003ef4:	8e 59       	ld.sh	r9,r7[0xa]
80003ef6:	4b 08       	lddpc	r8,80003fb4 <phy_rx_func+0xed8>
80003ef8:	b0 09       	st.h	r8[0x0],r9
						VBSP_data[1] = payload_rx_channel->word[2];
80003efa:	8e 69       	ld.sh	r9,r7[0xc]
80003efc:	b0 19       	st.h	r8[0x2],r9
							
						m_RxBurstType = CalculateBurst(VF_SN);
80003efe:	f0 1f 00 2f 	mcall	80003fb8 <phy_rx_func+0xedc>
80003f02:	4a 38       	lddpc	r8,80003f8c <phy_rx_func+0xeb0>
80003f04:	91 0c       	st.w	r8[0x0],r12
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003f06:	ef 39 00 0f 	ld.ub	r9,r7[15]
80003f0a:	3f 38       	mov	r8,-13
80003f0c:	f0 09 18 00 	cp.b	r9,r8
80003f10:	c0 a1       	brne	80003f24 <phy_rx_func+0xe48>
							
						m_RxBurstType = CalculateBurst(VF_SN);
						
						if (payload_rx_channel->byte[7] == Pre_Voice_Decoder_Data)//0xF3
						{
							Item_ID = Pre_Voice_Decoder_Data;
80003f12:	10 99       	mov	r9,r8
80003f14:	4a 28       	lddpc	r8,80003f9c <phy_rx_func+0xec0>
80003f16:	b0 89       	st.b	r8[0x0],r9
							RxBytesWaiting = ((payload_rx_channel->dword[1] & 0x00007F00) >>24);//Test calculations are correct; 8
80003f18:	30 09       	mov	r9,0
80003f1a:	49 e8       	lddpc	r8,80003f90 <phy_rx_func+0xeb4>
80003f1c:	91 09       	st.w	r8[0x0],r9
							AMBE_rx_flag = 1;//本地作为AMBE数据的解密方
80003f1e:	30 19       	mov	r9,1
80003f20:	4a c8       	lddpc	r8,80003fd0 <phy_rx_func+0xef4>
80003f22:	b0 89       	st.b	r8[0x0],r9
						}
							
						RxMediaState = READING_AMBE_MEDIA;//Jump
80003f24:	30 49       	mov	r9,4
80003f26:	49 98       	lddpc	r8,80003f88 <phy_rx_func+0xeac>
80003f28:	91 09       	st.w	r8[0x0],r9
80003f2a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					else
					{
						RxMediaState = WAITINGABAB;//Jump
80003f2e:	30 09       	mov	r9,0
80003f30:	49 68       	lddpc	r8,80003f88 <phy_rx_func+0xeac>
80003f32:	91 09       	st.w	r8[0x0],r9
80003f34:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}

				}
				else
				{//测试看看是几个字节数据
					logFromISR("\n\r Radio Internal parameter length error \n\r");
80003f38:	4a ec       	lddpc	r12,80003ff0 <phy_rx_func+0xf14>
80003f3a:	f0 1f 00 18 	mcall	80003f98 <phy_rx_func+0xebc>
					RxMediaState = WAITINGABAB;//Jump
80003f3e:	30 09       	mov	r9,0
80003f40:	49 28       	lddpc	r8,80003f88 <phy_rx_func+0xeac>
80003f42:	91 09       	st.w	r8[0x0],r9
80003f44:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003f48:	00 00       	add	r0,r0
80003f4a:	0a bc       	st.h	r5++,r12
80003f4c:	00 00       	add	r0,r0
80003f4e:	0a b4       	st.h	r5++,r4
80003f50:	00 00       	add	r0,r0
80003f52:	0a 98       	mov	r8,r5
80003f54:	00 00       	add	r0,r0
80003f56:	0a e8       	st.h	--r5,r8
80003f58:	00 00       	add	r0,r0
80003f5a:	0a e0       	st.h	--r5,r0
80003f5c:	00 00       	add	r0,r0
80003f5e:	0a 9c       	mov	r12,r5
80003f60:	80 00       	ld.sh	r0,r0[0x0]
80003f62:	2a 84       	sub	r4,-88
80003f64:	00 00       	add	r0,r0
80003f66:	0a 74       	tst	r4,r5
80003f68:	80 00       	ld.sh	r0,r0[0x0]
80003f6a:	55 90       	stdsp	sp[0x164],r0
80003f6c:	00 00       	add	r0,r0
80003f6e:	0a a0       	st.w	r5++,r0
80003f70:	80 00       	ld.sh	r0,r0[0x0]
80003f72:	29 d0       	sub	r0,-99
80003f74:	00 00       	add	r0,r0
80003f76:	0a a3       	st.w	r5++,r3
80003f78:	00 00       	add	r0,r0
80003f7a:	0a 78       	tst	r8,r5
80003f7c:	00 00       	add	r0,r0
80003f7e:	0a d0       	st.w	--r5,r0
80003f80:	00 00       	add	r0,r0
80003f82:	0a 90       	mov	r0,r5
80003f84:	00 00       	add	r0,r0
80003f86:	04 f4       	st.b	--r2,r4
80003f88:	00 00       	add	r0,r0
80003f8a:	0a c4       	st.b	r5++,r4
80003f8c:	00 00       	add	r0,r0
80003f8e:	0a 70       	tst	r0,r5
80003f90:	00 00       	add	r0,r0
80003f92:	0a c8       	st.b	r5++,r8
80003f94:	80 00       	ld.sh	r0,r0[0x0]
80003f96:	d3 98       	*unknown*
80003f98:	80 00       	ld.sh	r0,r0[0x0]
80003f9a:	66 88       	ld.w	r8,r3[0x20]
80003f9c:	00 00       	add	r0,r0
80003f9e:	0a a2       	st.w	r5++,r2
80003fa0:	00 00       	add	r0,r0
80003fa2:	0a ac       	st.w	r5++,r12
80003fa4:	00 00       	add	r0,r0
80003fa6:	0a e4       	st.h	--r5,r4
80003fa8:	80 00       	ld.sh	r0,r0[0x0]
80003faa:	6f a4       	ld.w	r4,r7[0x68]
80003fac:	80 00       	ld.sh	r0,r0[0x0]
80003fae:	30 7c       	mov	r12,7
80003fb0:	00 00       	add	r0,r0
80003fb2:	0a 5a       	eor	r10,r5
80003fb4:	00 00       	add	r0,r0
80003fb6:	0e c0       	st.b	r7++,r0
80003fb8:	80 00       	ld.sh	r0,r0[0x0]
80003fba:	29 14       	sub	r4,-111
80003fbc:	80 00       	ld.sh	r0,r0[0x0]
80003fbe:	d3 b0       	acall	0x3b
80003fc0:	00 00       	add	r0,r0
80003fc2:	0a b8       	st.h	r5++,r8
80003fc4:	00 00       	add	r0,r0
80003fc6:	0d c4       	ld.ub	r4,r6[0x4]
80003fc8:	00 00       	add	r0,r0
80003fca:	0a 80       	andn	r0,r5
80003fcc:	00 00       	add	r0,r0
80003fce:	0a 5c       	eor	r12,r5
80003fd0:	00 00       	add	r0,r0
80003fd2:	0a 41       	or	r1,r5
80003fd4:	00 00       	add	r0,r0
80003fd6:	0a dc       	st.w	--r5,r12
80003fd8:	00 00       	add	r0,r0
80003fda:	0a 5e       	eor	lr,r5
80003fdc:	00 00       	add	r0,r0
80003fde:	0a 5d       	eor	sp,r5
80003fe0:	00 00       	add	r0,r0
80003fe2:	0a 58       	eor	r8,r5
80003fe4:	00 00       	add	r0,r0
80003fe6:	0a a8       	st.w	r5++,r8
80003fe8:	00 00       	add	r0,r0
80003fea:	0a 54       	eor	r4,r5
80003fec:	00 00       	add	r0,r0
80003fee:	0d bc       	ld.ub	r12,r6[0x3]
80003ff0:	80 00       	ld.sh	r0,r0[0x0]
80003ff2:	d3 c4       	*unknown*

80003ff4 <pdca_int_handler>:
    void (*phy_rx_exec)(void *)--callback function for receive SSC data 
Called By: interrupt
*/
__attribute__((__interrupt__))
static void pdca_int_handler(void)
{
80003ff4:	d4 01       	pushm	lr
    
	//intStartCount = Get_system_register(AVR32_COUNT);
	
	/*Toggle Index*/
    BufferIndex ^= 0x01;
80003ff6:	49 88       	lddpc	r8,80004054 <pdca_int_handler+0x60>
80003ff8:	11 89       	ld.ub	r9,r8[0x0]
80003ffa:	ec 19 00 01 	eorl	r9,0x1
80003ffe:	b0 89       	st.b	r8[0x0],r9
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);
80004000:	11 89       	ld.ub	r9,r8[0x0]
80004002:	a5 69       	lsl	r9,0x4
80004004:	2f c9       	sub	r9,-4
80004006:	49 5a       	lddpc	r10,80004058 <pdca_int_handler+0x64>
80004008:	14 09       	add	r9,r10
	
	/*Toggle Index*/
    BufferIndex ^= 0x01;
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
8000400a:	fe 7a 00 40 	mov	r10,-65472
8000400e:	95 39       	st.w	r10[0xc],r9
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80004010:	30 39       	mov	r9,3
80004012:	95 49       	st.w	r10[0x10],r9

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);
80004014:	11 8a       	ld.ub	r10,r8[0x0]
80004016:	a5 6a       	lsl	r10,0x4
80004018:	2f ca       	sub	r10,-4
8000401a:	49 18       	lddpc	r8,8000405c <pdca_int_handler+0x68>
8000401c:	10 0a       	add	r10,r8
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
8000401e:	fe 78 00 00 	mov	r8,-65536
80004022:	91 3a       	st.w	r8[0xc],r10
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80004024:	91 49       	st.w	r8[0x10],r9
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr;
80004026:	70 b8       	ld.w	r8,r8[0x2c]
	
	/*receive SSC data*/
    if(phy_rx_exec != NULL)phy_rx_exec((void *)&RxBuffer[BufferIndex]);
80004028:	48 e8       	lddpc	r8,80004060 <pdca_int_handler+0x6c>
8000402a:	70 08       	ld.w	r8,r8[0x0]
8000402c:	58 08       	cp.w	r8,0
8000402e:	c0 70       	breq	8000403c <pdca_int_handler+0x48>
80004030:	48 99       	lddpc	r9,80004054 <pdca_int_handler+0x60>
80004032:	13 89       	ld.ub	r9,r9[0x0]
80004034:	a5 69       	lsl	r9,0x4
80004036:	48 ac       	lddpc	r12,8000405c <pdca_int_handler+0x68>
80004038:	12 0c       	add	r12,r9
8000403a:	5d 18       	icall	r8

    /*transmit SSC data*/

	if(phy_tx_exec != NULL)phy_tx_exec((void *)&TxBuffer[BufferIndex]);//phy_tx_func, phy_rx_func
8000403c:	48 a8       	lddpc	r8,80004064 <pdca_int_handler+0x70>
8000403e:	70 08       	ld.w	r8,r8[0x0]
80004040:	58 08       	cp.w	r8,0
80004042:	c0 70       	breq	80004050 <pdca_int_handler+0x5c>
80004044:	48 49       	lddpc	r9,80004054 <pdca_int_handler+0x60>
80004046:	13 89       	ld.ub	r9,r9[0x0]
80004048:	a5 69       	lsl	r9,0x4
8000404a:	48 4c       	lddpc	r12,80004058 <pdca_int_handler+0x64>
8000404c:	12 0c       	add	r12,r9
8000404e:	5d 18       	icall	r8

	
	//intDuration = Get_system_register(AVR32_COUNT) - intStartCount;
	
	
}/*End of pdca_int_handler.*/
80004050:	d4 02       	popm	lr
80004052:	d6 03       	rete
80004054:	00 00       	add	r0,r0
80004056:	40 c8       	lddsp	r8,sp[0x30]
80004058:	00 00       	add	r0,r0
8000405a:	40 f0       	lddsp	r0,sp[0x3c]
8000405c:	00 00       	add	r0,r0
8000405e:	40 d0       	lddsp	r0,sp[0x34]
80004060:	00 00       	add	r0,r0
80004062:	0a ec       	st.h	--r5,r12
80004064:	00 00       	add	r0,r0
80004066:	0a f0       	st.b	--r5,r0

80004068 <local_start_SSC>:
void local_start_SSC(void)
{
    /*Assign GPIO to SSC.
    gpio_enable_module
    gpio_enable_module_pin*/
    AVR32_GPIO.port[1].pmr0c = 0x00000DC0;
80004068:	fe 78 10 00 	mov	r8,-61440
8000406c:	e0 69 0d c0 	mov	r9,3520
80004070:	f1 49 01 18 	st.w	r8[280],r9
    AVR32_GPIO.port[1].pmr1c = 0x00000DC0;
80004074:	f1 49 01 28 	st.w	r8[296],r9
    AVR32_GPIO.port[1].gperc = 0x00000DC0;
80004078:	f1 49 01 08 	st.w	r8[264],r9

    /*Software reset SSC*/
    (&AVR32_SSC)->cr = AVR32_SSC_CR_SWRST_MASK;
8000407c:	fe 78 34 00 	mov	r8,-52224
80004080:	e0 69 80 00 	mov	r9,32768
80004084:	91 09       	st.w	r8[0x0],r9
    (&AVR32_SSC)->cmr 
80004086:	30 09       	mov	r9,0
80004088:	91 19       	st.w	r8[0x4],r9
                     = AVR32_SSC_CMR_DIV_NOT_ACTIVE << AVR32_SSC_CMR_DIV_OFFSET;

    /*For Slave*/
    (&AVR32_SSC)->tcmr =
8000408a:	e0 69 04 21 	mov	r9,1057
8000408e:	ea 19 3f 20 	orh	r9,0x3f20
80004092:	91 69       	st.w	r8[0x18],r9
	    | 32 << AVR32_SSC_TCMR_STTDLY_OFFSET
	    | 63 << AVR32_SSC_TCMR_PERIOD_OFFSET;


    /*For Slave*/
    (&AVR32_SSC)->tfmr = 31 << AVR32_SSC_TFMR_DATLEN_OFFSET 
80004094:	e0 69 02 9f 	mov	r9,671
80004098:	ea 19 01 00 	orh	r9,0x100
8000409c:	91 79       	st.w	r8[0x1c],r9
	    | 0 << AVR32_SSC_TFMR_FSDEN_OFFSET
	    | 1 << AVR32_SSC_TFMR_FSEDGE_OFFSET;

	/*For Slave*/

	(&AVR32_SSC)->rcmr = AVR32_SSC_RCMR_CKS_RK_PIN << AVR32_SSC_RCMR_CKS_OFFSET
8000409e:	e0 6a 04 02 	mov	r10,1026
800040a2:	ea 1a 3f 20 	orh	r10,0x3f20
800040a6:	91 4a       	st.w	r8[0x10],r10
	    | 0 << AVR32_SSC_RCMR_STOP_OFFSET
	    | 32 << AVR32_SSC_RCMR_STTDLY_OFFSET
	    | 63 << AVR32_SSC_RCMR_PERIOD_OFFSET;

	/*For Slave*/
	(&AVR32_SSC)->rfmr = 31 << AVR32_SSC_RFMR_DATLEN_OFFSET
800040a8:	91 59       	st.w	r8[0x14],r9
	    | 1 << AVR32_SSC_RFMR_MSBF_OFFSET
	    | 2 << AVR32_SSC_RFMR_DATNB_OFFSET
	    | 0 << AVR32_SSC_RFMR_FSLEN_OFFSET
	    | AVR32_SSC_RFMR_FSOS_INPUT_ONLY << AVR32_SSC_RFMR_FSOS_OFFSET
	    | 1 << AVR32_SSC_RFMR_FSEDGE_OFFSET;
}/*End of local_start_SSC.*/
800040aa:	5e fc       	retal	r12

800040ac <local_start_PDC>:
Function: local_start_PDC
Description: none
Called By: void ssc_init(void) -- ssc.c
*/
void local_start_PDC(void)
{
800040ac:	d4 01       	pushm	lr
    /*Toggle Index*/	
    BufferIndex = 1;
800040ae:	30 19       	mov	r9,1
800040b0:	49 78       	lddpc	r8,8000410c <local_start_PDC+0x60>
800040b2:	b0 89       	st.b	r8[0x0],r9
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
800040b4:	fe 78 00 00 	mov	r8,-65536
800040b8:	30 7b       	mov	r11,7
800040ba:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
800040bc:	70 b9       	ld.w	r9,r8[0x2c]
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
800040be:	49 59       	lddpc	r9,80004110 <local_start_PDC+0x64>
800040c0:	f2 ca ff fc 	sub	r10,r9,-4
    BufferIndex = 1;
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
800040c4:	91 0a       	st.w	r8[0x0],r10
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
800040c6:	30 3a       	mov	r10,3
800040c8:	91 2a       	st.w	r8[0x8],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
800040ca:	30 1c       	mov	r12,1
800040cc:	91 1c       	st.w	r8[0x4],r12
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
800040ce:	2e c9       	sub	r9,-20
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
800040d0:	91 39       	st.w	r8[0xc],r9
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
800040d2:	91 4a       	st.w	r8[0x10],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mr = AVR32_PDCA_WORD;
800040d4:	30 2c       	mov	r12,2
800040d6:	91 6c       	st.w	r8[0x18],r12

	TxBuffer[0].xnl_channel.dword = XNL_IDLE;
800040d8:	48 f9       	lddpc	r9,80004114 <local_start_PDC+0x68>
800040da:	e0 68 5a 5a 	mov	r8,23130
800040de:	ea 18 ab cd 	orh	r8,0xabcd
800040e2:	93 18       	st.w	r9[0x4],r8
	TxBuffer[0].payload_channel.dword[0] = PAYLOADIDLE0;
800040e4:	93 28       	st.w	r9[0x8],r8
	TxBuffer[0].payload_channel.dword[1] = PAYLOADIDLE1;
800040e6:	30 0e       	mov	lr,0
800040e8:	93 3e       	st.w	r9[0xc],lr
	TxBuffer[1].xnl_channel.dword = XNL_IDLE;
800040ea:	93 58       	st.w	r9[0x14],r8
	TxBuffer[1].payload_channel.dword[0] = PAYLOADIDLE0;
800040ec:	93 68       	st.w	r9[0x18],r8
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;
800040ee:	93 7e       	st.w	r9[0x1c],lr

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
800040f0:	fe 78 00 40 	mov	r8,-65472
800040f4:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
800040f6:	70 be       	ld.w	lr,r8[0x2c]
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
800040f8:	f2 ce ff fc 	sub	lr,r9,-4
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
800040fc:	91 0e       	st.w	r8[0x0],lr
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
800040fe:	91 2a       	st.w	r8[0x8],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
80004100:	91 1b       	st.w	r8[0x4],r11
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
80004102:	2e c9       	sub	r9,-20
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
80004104:	91 39       	st.w	r8[0xc],r9
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80004106:	91 4a       	st.w	r8[0x10],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80004108:	91 6c       	st.w	r8[0x18],r12
}/*End of local_start_PDC.*/
8000410a:	d8 02       	popm	pc
8000410c:	00 00       	add	r0,r0
8000410e:	40 c8       	lddsp	r8,sp[0x30]
80004110:	00 00       	add	r0,r0
80004112:	40 d0       	lddsp	r0,sp[0x34]
80004114:	00 00       	add	r0,r0
80004116:	40 f0       	lddsp	r0,sp[0x3c]

80004118 <register_rx_tx_func>:
Description: register the rx function(callback function)
Called By: phy_init -- physical.c
*/
void register_rx_tx_func(void (*rx_exec)(void *),  void ( *tx_exec)(void *))
{
	 phy_rx_exec = rx_exec;
80004118:	48 38       	lddpc	r8,80004124 <register_rx_tx_func+0xc>
8000411a:	91 0c       	st.w	r8[0x0],r12
	 phy_tx_exec = tx_exec;//phy_tx_func, phy_rx_func
8000411c:	48 38       	lddpc	r8,80004128 <register_rx_tx_func+0x10>
8000411e:	91 0b       	st.w	r8[0x0],r11
	 
}/*End of register_tx_rx_func.*/
80004120:	5e fc       	retal	r12
80004122:	00 00       	add	r0,r0
80004124:	00 00       	add	r0,r0
80004126:	0a ec       	st.h	--r5,r12
80004128:	00 00       	add	r0,r0
8000412a:	0a f0       	st.b	--r5,r0

8000412c <ssc_init>:
    local_start_SSC -- ssc.c
    local_start_PDC -- ssc.c
Called By: phy_init -- physical.c
*/
void ssc_init(void)
{		
8000412c:	d4 01       	pushm	lr
    /*Set up PB03 to watch FS.*/
    AVR32_GPIO.port[1].oderc = 0x00000002;
8000412e:	fe 78 10 00 	mov	r8,-61440
80004132:	30 29       	mov	r9,2
80004134:	f1 49 01 48 	st.w	r8[328],r9
    AVR32_GPIO.port[1].gpers = 0x00000002;
80004138:	f1 49 01 04 	st.w	r8[260],r9

    /*Waits for radio to start making FSYNC.*/
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
8000413c:	10 99       	mov	r9,r8
8000413e:	f2 f8 01 60 	ld.w	r8,r9[352]
80004142:	e2 18 00 02 	andl	r8,0x2,COH
80004146:	cf c0       	breq	8000413e <ssc_init+0x12>
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
80004148:	fe 79 10 00 	mov	r9,-61440
8000414c:	f2 f8 01 60 	ld.w	r8,r9[352]
80004150:	e2 18 00 02 	andl	r8,0x2,COH
80004154:	cf c1       	brne	8000414c <ssc_init+0x20>
				
    INTC_register_interrupt (
80004156:	30 3a       	mov	r10,3
80004158:	36 0b       	mov	r11,96
8000415a:	48 bc       	lddpc	r12,80004184 <ssc_init+0x58>
8000415c:	f0 1f 00 0b 	mcall	80004188 <ssc_init+0x5c>
        , AVR32_PDCA_IRQ_0
        , AVR32_INTC_INT3
    );
				
    /*config the SSC*/
    local_start_SSC();
80004160:	f0 1f 00 0b 	mcall	8000418c <ssc_init+0x60>

    /*config the PDCA*/
    local_start_PDC();
80004164:	f0 1f 00 0b 	mcall	80004190 <ssc_init+0x64>
		
    /*Start the SSC Physical Layer.*/

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80004168:	fe 79 00 00 	mov	r9,-65536
8000416c:	30 18       	mov	r8,1
8000416e:	93 58       	st.w	r9[0x14],r8
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80004170:	fe 7a 00 40 	mov	r10,-65472
80004174:	95 58       	st.w	r10[0x14],r8
    (&AVR32_SSC)->cr = AVR32_SSC_CR_RXEN_MASK | AVR32_SSC_CR_TXEN_MASK;
80004176:	e0 6b 01 01 	mov	r11,257
8000417a:	fe 7a 34 00 	mov	r10,-52224
8000417e:	95 0b       	st.w	r10[0x0],r11
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->ier = 
80004180:	93 88       	st.w	r9[0x20],r8
                                                            AVR32_PDCA_RCZ_MASK;
}/*End of ssc_init.*/
80004182:	d8 02       	popm	pc
80004184:	80 00       	ld.sh	r0,r0[0x0]
80004186:	3f f4       	mov	r4,-1
80004188:	80 00       	ld.sh	r0,r0[0x0]
8000418a:	4b c8       	lddpc	r8,80004278 <xcmp_opcode_not_supported+0x14>
8000418c:	80 00       	ld.sh	r0,r0[0x0]
8000418e:	40 68       	lddsp	r8,sp[0x18]
80004190:	80 00       	ld.sh	r0,r0[0x0]
80004192:	40 ac       	lddsp	r12,sp[0x28]

80004194 <xcmp_register_app_list>:
Calls: 
Called By: app_init -- app.c
*/
void xcmp_register_app_list(void * list)
{
	app_list = (app_exec_t *)list;
80004194:	48 28       	lddpc	r8,8000419c <xcmp_register_app_list+0x8>
80004196:	91 0c       	st.w	r8[0x0],r12
}
80004198:	5e fc       	retal	r12
8000419a:	00 00       	add	r0,r0
8000419c:	00 00       	add	r0,r0
8000419e:	41 10       	lddsp	r0,sp[0x44]

800041a0 <xcmp_tx>:
Calls:   
	xnl_tx -- xnl.c
Called By: ...
*/
static void xcmp_tx( xcmp_fragment_t * xcmp, U8 payload_len)
{
800041a0:	eb cd 40 80 	pushm	r7,lr
800041a4:	fa cd 01 00 	sub	sp,sp,256
800041a8:	16 97       	mov	r7,r11
	Length :xnl length + checksum
	= checksum + xnl header + xcmp opcode + xcmp payload
	= 0x02 + 0x0C + 0x02 + xcmp payload
	= 0x10 + xcmp payload
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | ( 0x10 + payload_len);
800041aa:	16 98       	mov	r8,r11
800041ac:	2f 08       	sub	r8,-16
800041ae:	af a8       	sbr	r8,0xe
800041b0:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE; 
800041b2:	3f f8       	mov	r8,-1
800041b4:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG;
800041b6:	30 b9       	mov	r9,11
800041b8:	ba 29       	st.h	sp[0x4],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;	
800041ba:	ba 38       	st.h	sp[0x6],r8
	xnl_frame.xnl_header.destination = DEFAULT_VALUE;
800041bc:	ba 48       	st.h	sp[0x8],r8
	xnl_frame.xnl_header.source = DEFAULT_VALUE;	
800041be:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
800041c0:	ba 68       	st.h	sp[0xc],r8
	
	/*insert xcmp frame data*/
	memcpy(&xnl_frame.xnl_payload.xnl_content_data_msg, xcmp, payload_len + 2);
800041c2:	f6 ca ff fe 	sub	r10,r11,-2
800041c6:	18 9b       	mov	r11,r12
800041c8:	fa cc ff f0 	sub	r12,sp,-16
800041cc:	f0 1f 00 05 	mcall	800041e0 <xcmp_tx+0x40>
	xnl_frame.xnl_header.payload_length = payload_len + 2;	
800041d0:	2f e7       	sub	r7,-2
800041d2:	ba 77       	st.h	sp[0xe],r7
	
	/* send xnl frame*/	
	xnl_tx(&xnl_frame);
800041d4:	1a 9c       	mov	r12,sp
800041d6:	f0 1f 00 04 	mcall	800041e4 <xcmp_tx+0x44>
}
800041da:	2c 0d       	sub	sp,-256
800041dc:	e3 cd 80 80 	ldm	sp++,r7,pc
800041e0:	80 00       	ld.sh	r0,r0[0x0]
800041e2:	6e 5c       	ld.w	r12,r7[0x14]
800041e4:	80 00       	ld.sh	r0,r0[0x0]
800041e6:	46 2c       	lddsp	r12,sp[0x188]

800041e8 <xcmp_audio_route_speaker>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_audio_route_speaker(void)
{
800041e8:	d4 01       	pushm	lr
800041ea:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
		
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | AUDIO_ROUTING_CONTROL;
800041ee:	e0 68 04 14 	mov	r8,1044
800041f2:	ba 18       	st.h	sp[0x2],r8
		
	/*point to xcmp payload*/
	AudioRoutingControl_req_t * ptr = (AudioRoutingControl_req_t *)xcmp_farme.u8;
800041f4:	fa c8 ff fc 	sub	r8,sp,-4
		
	ptr->Function = Routing_Func_Update_Source;
800041f8:	30 19       	mov	r9,1
800041fa:	b0 89       	st.b	r8[0x0],r9
		
		
	unsigned short NumberofRoutings =  2;//2;
	ptr->NumberofRoutings[0] = (NumberofRoutings >> 8) & 0xFF;
800041fc:	30 0a       	mov	r10,0
800041fe:	b0 9a       	st.b	r8[0x1],r10
	ptr->NumberofRoutings[1] =  NumberofRoutings & 0xFF;
80004200:	30 2a       	mov	r10,2
80004202:	b0 aa       	st.b	r8[0x2],r10
		
	
	ptr->RoutingData[0].audioInput = IN_Pre_Speaker_Audio_Data;//IN_Pre_Speaker_Audio_Data;//IN_Microphone;//IN_Option_Board;
80004204:	30 da       	mov	r10,13
80004206:	b0 ba       	st.b	r8[0x3],r10
	ptr->RoutingData[0].audioOutput = OUT_Option_Board;//OUT_Option_Board;//OUT_Microphone_Data;//测试
80004208:	30 ca       	mov	r10,12
8000420a:	b0 ca       	st.b	r8[0x4],r10
	
	
	//ptr->RoutingData[0].audioInput = IN_Microphone;//IN_Option_Board;
	//ptr->RoutingData[0].audioOutput =OUT_Option_Board;// OUT_Speaker;
	
	ptr->RoutingData[1].audioInput = IN_Option_Board;//IN_Option_Board;
8000420c:	b0 da       	st.b	r8[0x5],r10
	ptr->RoutingData[1].audioOutput = OUT_Speaker;//OUT_Microphone_Data;//测试
8000420e:	b0 e9       	st.b	r8[0x6],r9
	
	//ptr->RoutingData[1].audioInput = IN_Option_Board;
	//ptr->RoutingData[1].audioOutput = OUT_Microphone_Data;//测试OUT_Speaker;//
		
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(AudioRoutingControl_req_t) - (MAX_ROUTING_CTR - NumberofRoutings) * sizeof(RoutingData_t));
80004210:	30 7b       	mov	r11,7
80004212:	fa cc ff fe 	sub	r12,sp,-2
80004216:	f0 1f 00 03 	mcall	80004220 <xcmp_audio_route_speaker+0x38>
}
8000421a:	2c dd       	sub	sp,-204
8000421c:	d8 02       	popm	pc
8000421e:	00 00       	add	r0,r0
80004220:	80 00       	ld.sh	r0,r0[0x0]
80004222:	41 a0       	lddsp	r0,sp[0x68]

80004224 <xcmp_DeviceInitializationStatus_request>:
Description: send device initialization status request
Calls: xcmp_tx
Called By:...
*/
void xcmp_DeviceInitializationStatus_request(void)
{
80004224:	d4 01       	pushm	lr
80004226:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
		
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_BRDCAST | DEVICE_INITIALIZATION_STATUS;
8000422a:	fe 78 b4 00 	mov	r8,-19456
8000422e:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceInitializationStatus_brdcst_t * ptr 
						 = (DeviceInitializationStatus_brdcst_t *)xcmp_farme.u8;
80004230:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*xcmp version 8.1.0.5*///版本号未正确填写，纠正
	ptr->XCMPVersion[0] = 0x08;
80004234:	30 89       	mov	r9,8
80004236:	b0 89       	st.b	r8[0x0],r9
	ptr->XCMPVersion[1] = 0x01;
80004238:	30 19       	mov	r9,1
8000423a:	b0 99       	st.b	r8[0x1],r9
	ptr->XCMPVersion[2] = 0x00;
8000423c:	30 09       	mov	r9,0
8000423e:	b0 a9       	st.b	r8[0x2],r9
	ptr->XCMPVersion[3] = 0x05;
80004240:	30 5a       	mov	r10,5
80004242:	b0 ba       	st.b	r8[0x3],r10
	/*
	0x00:
	This is the message that the device sends at power up or after a reset. It 
	will give the initial status and capabilities for the device.
	*/
	ptr->DeviceInitType = 0x00;
80004244:	b0 c9       	st.b	r8[0x4],r9
	types of devices may provide a set of services to the radio system, but do 
	not have the ability to be the master.
	
	0x07:OptionBoard,3rd party Option Board-based application.
	*/
	ptr->DeviceStatusInfo.DeviceType = 0x07;
80004246:	30 7a       	mov	r10,7
80004248:	b0 da       	st.b	r8[0x5],r10
	
	/*Power Up Success, Device has powered up with no errors*/
	ptr->DeviceStatusInfo.DeviceStatus[0] = 0x00;
8000424a:	b0 e9       	st.b	r8[0x6],r9
	ptr->DeviceStatusInfo.DeviceStatus[1] = 0x00;
8000424c:	b0 f9       	st.b	r8[0x7],r9
	
	/*
	This number is the size of the Device Descriptor data structure with a 
	maximum size not exceeding 255 bytes.
	*/
	ptr->DeviceStatusInfo.DeviceDescriptorSize = 0x00;
8000424e:	f1 69 00 08 	st.b	r8[8],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme
80004252:	30 9b       	mov	r11,9
80004254:	fa cc ff fe 	sub	r12,sp,-2
80004258:	f0 1f 00 02 	mcall	80004260 <xcmp_DeviceInitializationStatus_request+0x3c>
		, sizeof(DeviceInitializationStatus_brdcst_t) - MAX_DEVICE_DESC_SIZE);
}
8000425c:	2c dd       	sub	sp,-204
8000425e:	d8 02       	popm	pc
80004260:	80 00       	ld.sh	r0,r0[0x0]
80004262:	41 a0       	lddsp	r0,sp[0x68]

80004264 <xcmp_opcode_not_supported>:
Description: register the app list
Calls: xcmp_tx
Called By:...
*/
void xcmp_opcode_not_supported( void )
{
80004264:	d4 01       	pushm	lr
80004266:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REPLY;
8000426a:	fe 78 80 00 	mov	r8,-32768
8000426e:	ba 18       	st.h	sp[0x2],r8
	
	/*The radio does not support this opcode.*/
	xcmp_farme.u8[0] = xcmp_Res_Opcode_Not_Supported;
80004270:	30 38       	mov	r8,3
80004272:	ba c8       	st.b	sp[0x4],r8
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, 1);
80004274:	30 1b       	mov	r11,1
80004276:	fa cc ff fe 	sub	r12,sp,-2
8000427a:	f0 1f 00 03 	mcall	80004284 <xcmp_opcode_not_supported+0x20>
}
8000427e:	2c dd       	sub	sp,-204
80004280:	d8 02       	popm	pc
80004282:	00 00       	add	r0,r0
80004284:	80 00       	ld.sh	r0,r0[0x0]
80004286:	41 a0       	lddsp	r0,sp[0x68]

80004288 <xcmp_exec_func>:
Description: Perform XCMP corresponding functions
Calls:   
Called By: xcmp_rx_process--task
*/
static void xcmp_exec_func(app_exec_t * exec, xcmp_fragment_t * xcmp)
{
80004288:	d4 01       	pushm	lr
	/*The message types*/
	switch(xcmp->xcmp_opcode & 0xF000)
8000428a:	96 88       	ld.uh	r8,r11[0x0]
8000428c:	e2 18 f0 00 	andl	r8,0xf000,COH
80004290:	e0 48 80 00 	cp.w	r8,32768
80004294:	c0 f0       	breq	800042b2 <xcmp_exec_func+0x2a>
80004296:	e0 48 b0 00 	cp.w	r8,45056
8000429a:	c1 20       	breq	800042be <xcmp_exec_func+0x36>
8000429c:	58 08       	cp.w	r8,0
8000429e:	c1 51       	brne	800042c8 <xcmp_exec_func+0x40>
	{
		case XCMP_REQUEST:
			if(NULL != exec->xcmp_rx_req)
800042a0:	78 08       	ld.w	r8,r12[0x0]
800042a2:	58 08       	cp.w	r8,0
800042a4:	c0 40       	breq	800042ac <xcmp_exec_func+0x24>
			{
				exec->xcmp_rx_req(xcmp);
800042a6:	16 9c       	mov	r12,r11
800042a8:	5d 18       	icall	r8
800042aa:	d8 02       	popm	pc
			}
			else 
			{
				/*No function to register the request message*/
				/*send not supported opcode to raido */
				xcmp_opcode_not_supported();
800042ac:	f0 1f 00 08 	mcall	800042cc <xcmp_exec_func+0x44>
800042b0:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_REPLY:		
			if(NULL != exec->xcmp_rx_reply)
800042b2:	78 18       	ld.w	r8,r12[0x4]
800042b4:	58 08       	cp.w	r8,0
800042b6:	c0 90       	breq	800042c8 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_reply(xcmp);
800042b8:	16 9c       	mov	r12,r11
800042ba:	5d 18       	icall	r8
800042bc:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_BRDCAST:	
			if(NULL != exec->xcmp_rx_brdcst)
800042be:	78 28       	ld.w	r8,r12[0x8]
800042c0:	58 08       	cp.w	r8,0
800042c2:	c0 30       	breq	800042c8 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_brdcst(xcmp);
800042c4:	16 9c       	mov	r12,r11
800042c6:	5d 18       	icall	r8
800042c8:	d8 02       	popm	pc
800042ca:	00 00       	add	r0,r0
800042cc:	80 00       	ld.sh	r0,r0[0x0]
800042ce:	42 64       	lddsp	r4,sp[0x98]

800042d0 <xcmp_IdleTestTone>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_IdleTestTone(void)
{
800042d0:	d4 01       	pushm	lr
800042d2:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | TONE_CONTROL;
800042d6:	e0 68 04 09 	mov	r8,1033
800042da:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	ToneControl_req_t * ptr = (ToneControl_req_t *)xcmp_farme.u8;
800042dc:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*Starts the specific tone*/	
	ptr->Function = Tone_Start;
800042e0:	30 19       	mov	r9,1
800042e2:	b0 89       	st.b	r8[0x0],r9
	
	/*This tone shall be sounded when radio landed on a priority channel*/
	ptr->ToneIdentifier[0] = (Priority_Beep >> 8) & 0xFF;
800042e4:	30 09       	mov	r9,0
800042e6:	b0 99       	st.b	r8[0x1],r9
	ptr->ToneIdentifier[1] = Priority_Beep & 0xFF;
800042e8:	30 ca       	mov	r10,12
800042ea:	b0 aa       	st.b	r8[0x2],r10
	
	/*
	The alert tone is played according to any rules for alert tones, given the 
	current volume setting. Settings for this field are 8 to 255 (0x08 ?0xFF).
	*/
	ptr->ToneVolumeControl = Current_Volume;
800042ec:	b0 b9       	st.b	r8[0x3],r9
	
	/*clear reserved*/
	memset(ptr->Reserved, 0, 8);
800042ee:	fb 69 00 08 	st.b	sp[8],r9
800042f2:	fa c8 ff f7 	sub	r8,sp,-9
800042f6:	b0 89       	st.b	r8[0x0],r9
800042f8:	fa c8 ff f6 	sub	r8,sp,-10
800042fc:	b0 89       	st.b	r8[0x0],r9
800042fe:	fa c8 ff f5 	sub	r8,sp,-11
80004302:	b0 89       	st.b	r8[0x0],r9
80004304:	fa c8 ff f4 	sub	r8,sp,-12
80004308:	b0 89       	st.b	r8[0x0],r9
8000430a:	fa c8 ff f3 	sub	r8,sp,-13
8000430e:	b0 89       	st.b	r8[0x0],r9
80004310:	fa c8 ff f2 	sub	r8,sp,-14
80004314:	b0 89       	st.b	r8[0x0],r9
80004316:	fa c8 ff f1 	sub	r8,sp,-15
8000431a:	b0 89       	st.b	r8[0x0],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(ToneControl_req_t));
8000431c:	30 cb       	mov	r11,12
8000431e:	fa cc ff fe 	sub	r12,sp,-2
80004322:	f0 1f 00 03 	mcall	8000432c <xcmp_IdleTestTone+0x5c>
}
80004326:	2c dd       	sub	sp,-204
80004328:	d8 02       	popm	pc
8000432a:	00 00       	add	r0,r0
8000432c:	80 00       	ld.sh	r0,r0[0x0]
8000432e:	41 a0       	lddsp	r0,sp[0x68]

80004330 <xcmp_init>:
	xQueueCreate -- freertos
	xTaskCreate -- freertos
Called By: main -- main.c
*/
void xcmp_init(void)
{
80004330:	d4 01       	pushm	lr
	/*initialize the xnl*/
	xnl_init();
80004332:	f0 1f 00 0d 	mcall	80004364 <xcmp_init+0x34>
	
	/*register the xcmp function(callback function)*/
	xnl_register_xcmp_func( xcmp_rx );
80004336:	48 dc       	lddpc	r12,80004368 <xcmp_init+0x38>
80004338:	f0 1f 00 0d 	mcall	8000436c <xcmp_init+0x3c>
	
	/*initialize the queue*/
	//xcmp_frame_rx = xQueueCreate(10, sizeof(xcmp_fragment_t *));
	
	xcmp_frame_rx = xQueueCreate(20, sizeof(xcmp_fragment_t *));
8000433c:	30 4b       	mov	r11,4
8000433e:	31 4c       	mov	r12,20
80004340:	f0 1f 00 0c 	mcall	80004370 <xcmp_init+0x40>
80004344:	48 c8       	lddpc	r8,80004374 <xcmp_init+0x44>
80004346:	91 0c       	st.w	r8[0x0],r12
	/*create task*/	
	/*this task is used to execute xcmp message*/
	xTaskCreate(
80004348:	30 09       	mov	r9,0
8000434a:	1a d9       	st.w	--sp,r9
8000434c:	1a d9       	st.w	--sp,r9
8000434e:	1a d9       	st.w	--sp,r9
80004350:	30 38       	mov	r8,3
80004352:	e0 6a 01 80 	mov	r10,384
80004356:	48 9b       	lddpc	r11,80004378 <xcmp_init+0x48>
80004358:	48 9c       	lddpc	r12,8000437c <xcmp_init+0x4c>
8000435a:	f0 1f 00 0a 	mcall	80004380 <xcmp_init+0x50>
8000435e:	2f dd       	sub	sp,-12
	,  384
	,  NULL
	,  tskXCMP_PRIORITY
	,  NULL
	);
}
80004360:	d8 02       	popm	pc
80004362:	00 00       	add	r0,r0
80004364:	80 00       	ld.sh	r0,r0[0x0]
80004366:	47 10       	lddsp	r0,sp[0x1c4]
80004368:	80 00       	ld.sh	r0,r0[0x0]
8000436a:	44 80       	lddsp	r0,sp[0x120]
8000436c:	80 00       	ld.sh	r0,r0[0x0]
8000436e:	44 cc       	lddsp	r12,sp[0x130]
80004370:	80 00       	ld.sh	r0,r0[0x0]
80004372:	5a 64       	cp.w	r4,-26
80004374:	00 00       	add	r0,r0
80004376:	0b 00       	ld.w	r0,r5++
80004378:	80 00       	ld.sh	r0,r0[0x0]
8000437a:	d3 f0       	acall	0x3f
8000437c:	80 00       	ld.sh	r0,r0[0x0]
8000437e:	43 84       	lddsp	r4,sp[0xe0]
80004380:	80 00       	ld.sh	r0,r0[0x0]
80004382:	61 38       	ld.w	r8,r0[0x4c]

80004384 <xcmp_rx_process>:
Calls: xQueueReceive -- freerots
	xcmp_exec_func
Called By: task
*/
static void xcmp_rx_process(void * pvParameters)
{
80004384:	d4 31       	pushm	r0-r7,lr
80004386:	20 1d       	sub	sp,4
	xcmp_fragment_t xcmp;
	xcmp_fragment_t * ptr;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
80004388:	4b 16       	lddpc	r6,8000444c <xcmp_rx_process+0xc8>
8000438a:	30 05       	mov	r5,0
8000438c:	31 44       	mov	r4,20
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
8000438e:	4b 13       	lddpc	r3,80004450 <xcmp_rx_process+0xcc>
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
					break;
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
80004390:	4b 12       	lddpc	r2,80004454 <xcmp_rx_process+0xd0>
						, ptr);
					break;
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
80004392:	4b 21       	lddpc	r1,80004458 <xcmp_rx_process+0xd4>
					break;
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
80004394:	4b 20       	lddpc	r0,8000445c <xcmp_rx_process+0xd8>
	xcmp_fragment_t xcmp;
	xcmp_fragment_t * ptr;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
80004396:	6c 0c       	ld.w	r12,r6[0x0]
80004398:	0a 99       	mov	r9,r5
8000439a:	08 9a       	mov	r10,r4
8000439c:	1a 9b       	mov	r11,sp
8000439e:	f0 1f 00 31 	mcall	80004460 <xcmp_rx_process+0xdc>
800043a2:	58 1c       	cp.w	r12,1
800043a4:	cf 91       	brne	80004396 <xcmp_rx_process+0x12>
		{									
			if(NULL == ptr)
800043a6:	40 0b       	lddsp	r11,sp[0x0]
800043a8:	58 0b       	cp.w	r11,0
800043aa:	cf 60       	breq	80004396 <xcmp_rx_process+0x12>
				continue;
			}
			
			//log("\n\r R_xcmp : %4x \n\r",ptr->xcmp_opcode);//log:R_xcmp指令	
						
			switch(ptr->xcmp_opcode & 0x0FFF)
800043ac:	96 0a       	ld.sh	r10,r11[0x0]
800043ae:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
800043b2:	f1 d9 c0 0c 	bfextu	r8,r9,0x0,0xc
800043b6:	59 c8       	cp.w	r8,28
800043b8:	c1 e0       	breq	800043f4 <xcmp_rx_process+0x70>
800043ba:	e0 89 00 07 	brgt	800043c8 <xcmp_rx_process+0x44>
800043be:	58 e8       	cp.w	r8,14
800043c0:	c0 e0       	breq	800043dc <xcmp_rx_process+0x58>
800043c2:	58 f8       	cp.w	r8,15
800043c4:	c2 41       	brne	8000440c <xcmp_rx_process+0x88>
800043c6:	c0 f8       	rjmp	800043e4 <xcmp_rx_process+0x60>
800043c8:	e0 48 01 09 	cp.w	r8,265
800043cc:	c1 80       	breq	800043fc <xcmp_rx_process+0x78>
800043ce:	e0 48 01 0a 	cp.w	r8,266
800043d2:	c1 90       	breq	80004404 <xcmp_rx_process+0x80>
800043d4:	e0 48 00 2c 	cp.w	r8,44
800043d8:	c1 a1       	brne	8000440c <xcmp_rx_process+0x88>
800043da:	c0 98       	rjmp	800043ec <xcmp_rx_process+0x68>
			{
				case RADIO_STATUS:				
					xcmp_exec_func(&radio_status, ptr);
800043dc:	4a 2c       	lddpc	r12,80004464 <xcmp_rx_process+0xe0>
800043de:	f0 1f 00 23 	mcall	80004468 <xcmp_rx_process+0xe4>
					break;
800043e2:	c2 f8       	rjmp	80004440 <xcmp_rx_process+0xbc>
					
				case VERSION_INFORMATION:
					xcmp_exec_func(&version_information, ptr);
800043e4:	4a 2c       	lddpc	r12,8000446c <xcmp_rx_process+0xe8>
800043e6:	f0 1f 00 21 	mcall	80004468 <xcmp_rx_process+0xe4>
					break;
800043ea:	c2 b8       	rjmp	80004440 <xcmp_rx_process+0xbc>
					
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
800043ec:	4a 1c       	lddpc	r12,80004470 <xcmp_rx_process+0xec>
800043ee:	f0 1f 00 1f 	mcall	80004468 <xcmp_rx_process+0xe4>
					break;
800043f2:	c2 78       	rjmp	80004440 <xcmp_rx_process+0xbc>
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
800043f4:	04 9c       	mov	r12,r2
800043f6:	f0 1f 00 1d 	mcall	80004468 <xcmp_rx_process+0xe4>
						, ptr);
					break;
800043fa:	c2 38       	rjmp	80004440 <xcmp_rx_process+0xbc>
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
800043fc:	02 9c       	mov	r12,r1
800043fe:	f0 1f 00 1b 	mcall	80004468 <xcmp_rx_process+0xe4>
					break;
80004402:	c1 f8       	rjmp	80004440 <xcmp_rx_process+0xbc>
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
80004404:	00 9c       	mov	r12,r0
80004406:	f0 1f 00 19 	mcall	80004468 <xcmp_rx_process+0xe4>
					break;
8000440a:	c1 b8       	rjmp	80004440 <xcmp_rx_process+0xbc>
					
				default:
				
					/*the xcmp message not in order list*/
					/*over the length of the list*/
					if((0x0400 != (ptr->xcmp_opcode & 0x0400)) 
8000440c:	12 98       	mov	r8,r9
8000440e:	e2 18 04 00 	andl	r8,0x400,COH
80004412:	c0 70       	breq	80004420 <xcmp_rx_process+0x9c>
80004414:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
80004418:	e0 48 00 68 	cp.w	r8,104
8000441c:	e0 8a 00 08 	brle	8000442c <xcmp_rx_process+0xa8>
						|| (MAX_APP_FUNC <= (ptr->xcmp_opcode & 0x00FF))
					)
					{
						/*xcmp request*/
						if( XCMP_REQUEST == (ptr->xcmp_opcode & 0xF000))
80004420:	e2 19 f0 00 	andl	r9,0xf000,COH
80004424:	c0 e1       	brne	80004440 <xcmp_rx_process+0xbc>
						{
							/*send not supported opcode to raido */
							xcmp_opcode_not_supported();
80004426:	f0 1f 00 14 	mcall	80004474 <xcmp_rx_process+0xf0>
8000442a:	c0 b8       	rjmp	80004440 <xcmp_rx_process+0xbc>
						}
					}
					else
					{					
						xcmp_exec_func( &app_list[ptr->xcmp_opcode & 0x00FF]
8000442c:	f9 da c0 08 	bfextu	r12,r10,0x0,0x8
80004430:	f8 0c 00 1c 	add	r12,r12,r12<<0x1
80004434:	49 19       	lddpc	r9,80004478 <xcmp_rx_process+0xf4>
80004436:	72 08       	ld.w	r8,r9[0x0]
80004438:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
8000443c:	f0 1f 00 0b 	mcall	80004468 <xcmp_rx_process+0xe4>
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
80004440:	66 0c       	ld.w	r12,r3[0x0]
80004442:	40 0b       	lddsp	r11,sp[0x0]
80004444:	f0 1f 00 0e 	mcall	8000447c <xcmp_rx_process+0xf8>
80004448:	ca 7b       	rjmp	80004396 <xcmp_rx_process+0x12>
8000444a:	00 00       	add	r0,r0
8000444c:	00 00       	add	r0,r0
8000444e:	0b 00       	ld.w	r0,r5++
80004450:	00 00       	add	r0,r0
80004452:	0a 9c       	mov	r12,r5
80004454:	00 00       	add	r0,r0
80004456:	0b 10       	ld.sh	r0,r5++
80004458:	00 00       	add	r0,r0
8000445a:	0b 04       	ld.w	r4,r5++
8000445c:	00 00       	add	r0,r0
8000445e:	0b 1c       	ld.sh	r12,r5++
80004460:	80 00       	ld.sh	r0,r0[0x0]
80004462:	57 00       	stdsp	sp[0x1c0],r0
80004464:	00 00       	add	r0,r0
80004466:	0b 34       	ld.ub	r4,r5++
80004468:	80 00       	ld.sh	r0,r0[0x0]
8000446a:	42 88       	lddsp	r8,sp[0xa0]
8000446c:	00 00       	add	r0,r0
8000446e:	0a f4       	st.b	--r5,r4
80004470:	00 00       	add	r0,r0
80004472:	0b 28       	ld.uh	r8,r5++
80004474:	80 00       	ld.sh	r0,r0[0x0]
80004476:	42 64       	lddsp	r4,sp[0x98]
80004478:	00 00       	add	r0,r0
8000447a:	41 10       	lddsp	r0,sp[0x44]
8000447c:	80 00       	ld.sh	r0,r0[0x0]
8000447e:	2a 08       	sub	r8,-96

80004480 <xcmp_rx>:
Calls:   
	xQueueSend -- xnl.c
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
80004480:	eb cd 40 90 	pushm	r4,r7,lr
80004484:	20 1d       	sub	sp,4
80004486:	fa c4 ff f0 	sub	r4,sp,-16
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
8000448a:	48 c8       	lddpc	r8,800044b8 <xcmp_rx+0x38>
8000448c:	70 0c       	ld.w	r12,r8[0x0]
8000448e:	f0 1f 00 0c 	mcall	800044bc <xcmp_rx+0x3c>
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
80004492:	c1 00       	breq	800044b2 <xcmp_rx+0x32>
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
80004494:	fa c7 ff fc 	sub	r7,sp,-4
80004498:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
	{
		memcpy(xcmp_ptr, &xcmp, sizeof(xcmp_fragment_t));				
8000449a:	e0 6a 00 ca 	mov	r10,202
8000449e:	08 9b       	mov	r11,r4
800044a0:	f0 1f 00 08 	mcall	800044c0 <xcmp_rx+0x40>
		xQueueSend(xcmp_frame_rx, &xcmp_ptr, 0);	
800044a4:	48 88       	lddpc	r8,800044c4 <xcmp_rx+0x44>
800044a6:	70 0c       	ld.w	r12,r8[0x0]
800044a8:	30 09       	mov	r9,0
800044aa:	12 9a       	mov	r10,r9
800044ac:	1a 9b       	mov	r11,sp
800044ae:	f0 1f 00 07 	mcall	800044c8 <xcmp_rx+0x48>
	}	
}
800044b2:	2f fd       	sub	sp,-4
800044b4:	e3 cd 80 90 	ldm	sp++,r4,r7,pc
800044b8:	00 00       	add	r0,r0
800044ba:	0a 9c       	mov	r12,r5
800044bc:	80 00       	ld.sh	r0,r0[0x0]
800044be:	2f 88       	sub	r8,-8
800044c0:	80 00       	ld.sh	r0,r0[0x0]
800044c2:	6e 5c       	ld.w	r12,r7[0x14]
800044c4:	00 00       	add	r0,r0
800044c6:	0b 00       	ld.w	r0,r5++
800044c8:	80 00       	ld.sh	r0,r0[0x0]
800044ca:	59 0c       	cp.w	r12,16

800044cc <xnl_register_xcmp_func>:
Function: xnl_register_xcmp_func
Description: register the xcmp function(callback function)
*/
void xnl_register_xcmp_func( void ( *func)(xnl_content_data_msg_t))
{
	 xcmp_exec = func;
800044cc:	48 28       	lddpc	r8,800044d4 <xnl_register_xcmp_func+0x8>
800044ce:	91 0c       	st.w	r8[0x0],r12
}
800044d0:	5e fc       	retal	r12
800044d2:	00 00       	add	r0,r0
800044d4:	00 00       	add	r0,r0
800044d6:	0b 64       	ld.uh	r4,--r5

800044d8 <xnl_get_msg_ack_func>:
Description: process while receive msg ack.
Calls:xSemaphoreGive--freertos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
800044d8:	d4 01       	pushm	lr
	
	DestinationAddress = xnl->xnl_header.destination;
	/*No timeout*/		
	 //One relationship is controlled by a state machine, only the current MSG received the ACK, 
	//then the program will clear the current MSG sending address and out of standby and will jump to the sending state.
	if (DestinationAddress == xnl_information.device_address )
800044da:	48 88       	lddpc	r8,800044f8 <xnl_get_msg_ack_func+0x20>
800044dc:	90 28       	ld.sh	r8,r8[0x4]
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
	U16 DestinationAddress;
	U16 TransactionID;
	
	DestinationAddress = xnl->xnl_header.destination;
800044de:	98 49       	ld.sh	r9,r12[0x8]
800044e0:	f0 09 19 00 	cp.h	r9,r8
800044e4:	c0 81       	brne	800044f4 <xnl_get_msg_ack_func+0x1c>
	if (DestinationAddress == xnl_information.device_address )
	{
		//The ack is for me.
		
		TransactionID = xnl->xnl_header.transaction_id;
		xSemaphoreGive(xnl_timeout_semphr);	
800044e6:	48 68       	lddpc	r8,800044fc <xnl_get_msg_ack_func+0x24>
800044e8:	70 0c       	ld.w	r12,r8[0x0]
800044ea:	30 09       	mov	r9,0
800044ec:	12 9a       	mov	r10,r9
800044ee:	12 9b       	mov	r11,r9
800044f0:	f0 1f 00 04 	mcall	80004500 <xnl_get_msg_ack_func+0x28>
800044f4:	d8 02       	popm	pc
800044f6:	00 00       	add	r0,r0
800044f8:	00 00       	add	r0,r0
800044fa:	0b 44       	ld.w	r4,--r5
800044fc:	00 00       	add	r0,r0
800044fe:	0b 40       	ld.w	r0,--r5
80004500:	80 00       	ld.sh	r0,r0[0x0]
80004502:	59 0c       	cp.w	r12,16

80004504 <xnl_tx_process>:
	xSemaphoreTake--freertos 
	phy_tx -- physical.c
Called By: task
*/
static void xnl_tx_process(void * pvParameters)
{
80004504:	d4 31       	pushm	r0-r7,lr
	static  xnl_fragment_t * ptr;//是否可以修缮为静态变量？请关注
	
	
	for(;;)
	{		
		switch(xnl_tx_state)
80004506:	4a 86       	lddpc	r6,800045a4 <xnl_tx_process+0xa0>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
80004508:	4a 82       	lddpc	r2,800045a8 <xnl_tx_process+0xa4>
8000450a:	4a 94       	lddpc	r4,800045ac <xnl_tx_process+0xa8>
8000450c:	30 07       	mov	r7,0
8000450e:	3f f1       	mov	r1,-1
					if(NULL == ptr)
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
80004510:	30 00       	mov	r0,0
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;
80004512:	4a 85       	lddpc	r5,800045b0 <xnl_tx_process+0xac>
					
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
80004514:	4a 83       	lddpc	r3,800045b4 <xnl_tx_process+0xb0>
	static  xnl_fragment_t * ptr;//是否可以修缮为静态变量？请关注
	
	
	for(;;)
	{		
		switch(xnl_tx_state)
80004516:	6c 08       	ld.w	r8,r6[0x0]
80004518:	58 08       	cp.w	r8,0
8000451a:	c0 40       	breq	80004522 <xnl_tx_process+0x1e>
8000451c:	58 18       	cp.w	r8,1
8000451e:	cf d1       	brne	80004518 <xnl_tx_process+0x14>
80004520:	c2 08       	rjmp	80004560 <xnl_tx_process+0x5c>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
80004522:	64 0c       	ld.w	r12,r2[0x0]
80004524:	0e 99       	mov	r9,r7
80004526:	02 9a       	mov	r10,r1
80004528:	08 9b       	mov	r11,r4
8000452a:	f0 1f 00 24 	mcall	800045b8 <xnl_tx_process+0xb4>
8000452e:	58 1c       	cp.w	r12,1
80004530:	cf 31       	brne	80004516 <xnl_tx_process+0x12>
					, portMAX_DELAY ))
				{				
					if(NULL == ptr)
80004532:	68 0c       	ld.w	r12,r4[0x0]
80004534:	58 0c       	cp.w	r12,0
80004536:	cf 00       	breq	80004516 <xnl_tx_process+0x12>
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
80004538:	98 28       	ld.sh	r8,r12[0x4]
8000453a:	e0 08 19 00 	cp.h	r8,r0
8000453e:	c0 41       	brne	80004546 <xnl_tx_process+0x42>
					{
						/*invalid XNL opcode*/
						vPortFree(ptr);
80004540:	f0 1f 00 1f 	mcall	800045bc <xnl_tx_process+0xb8>
						break;
80004544:	ce 9b       	rjmp	80004516 <xnl_tx_process+0x12>
					}
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
80004546:	f0 1f 00 1f 	mcall	800045c0 <xnl_tx_process+0xbc>
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;
8000454a:	30 18       	mov	r8,1
8000454c:	8b 08       	st.w	r5[0x0],r8
					
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
8000454e:	66 0c       	ld.w	r12,r3[0x0]
80004550:	0e 99       	mov	r9,r7
80004552:	0e 9a       	mov	r10,r7
80004554:	0e 9b       	mov	r11,r7
80004556:	f0 1f 00 19 	mcall	800045b8 <xnl_tx_process+0xb4>
					xnl_tx_state = WAITING_FOR_REPLY;
8000455a:	30 18       	mov	r8,1
8000455c:	8d 08       	st.w	r6[0x0],r8
8000455e:	cd cb       	rjmp	80004516 <xnl_tx_process+0x12>
				}
				break;
			
			/*wait XNL reply*/			
			case WAITING_FOR_REPLY://直到回答ACK才再发送下一条data/control
				if(pdTRUE == xSemaphoreTake( xnl_timeout_semphr
80004560:	66 0c       	ld.w	r12,r3[0x0]
80004562:	0e 99       	mov	r9,r7
80004564:	36 4a       	mov	r10,100
80004566:	0e 9b       	mov	r11,r7
80004568:	f0 1f 00 14 	mcall	800045b8 <xnl_tx_process+0xb4>
8000456c:	58 1c       	cp.w	r12,1
8000456e:	c0 81       	brne	8000457e <xnl_tx_process+0x7a>
					, ( portTickType )50*2/ portTICK_RATE_MS))//按ADK文档中提示500ms一次超时,但是实际情况下程序中启用freertos的任务延时不够精准。因此根据经验需要降低延时等待的时间
				{
					/*No timeout*/
					//vPortFree(ptr);	
					set_xnl_idle(ptr);			
80004570:	49 58       	lddpc	r8,800045c4 <xnl_tx_process+0xc0>
80004572:	70 0c       	ld.w	r12,r8[0x0]
80004574:	68 0b       	ld.w	r11,r4[0x0]
80004576:	f0 1f 00 15 	mcall	800045c8 <xnl_tx_process+0xc4>
					xnl_tx_state = WAITING_FOR_TX;
8000457a:	8d 07       	st.w	r6[0x0],r7
8000457c:	cc db       	rjmp	80004516 <xnl_tx_process+0x12>
				}
				else
				{
					/*time out*/
					if(xnl_send_times <= MIN_RESEND_TIMES)
8000457e:	6a 08       	ld.w	r8,r5[0x0]
80004580:	58 38       	cp.w	r8,3
80004582:	e0 89 00 09 	brgt	80004594 <xnl_tx_process+0x90>
					{
						/*If times smaller than A supermarket, then resend the 
						instructions*/
						phy_tx((phy_fragment_t *)ptr);
80004586:	68 0c       	ld.w	r12,r4[0x0]
80004588:	f0 1f 00 0e 	mcall	800045c0 <xnl_tx_process+0xbc>
						xnl_send_times++;
8000458c:	6a 08       	ld.w	r8,r5[0x0]
8000458e:	2f f8       	sub	r8,-1
80004590:	8b 08       	st.w	r5[0x0],r8
80004592:	cc 2b       	rjmp	80004516 <xnl_tx_process+0x12>
					}
					else
					{
						//can not send data, disconnected						
						//vPortFree(ptr);	
						set_xnl_idle(ptr);									
80004594:	48 c8       	lddpc	r8,800045c4 <xnl_tx_process+0xc0>
80004596:	70 0c       	ld.w	r12,r8[0x0]
80004598:	68 0b       	ld.w	r11,r4[0x0]
8000459a:	f0 1f 00 0c 	mcall	800045c8 <xnl_tx_process+0xc4>
						xnl_tx_state = WAITING_FOR_TX;
8000459e:	8d 07       	st.w	r6[0x0],r7
800045a0:	cb bb       	rjmp	80004516 <xnl_tx_process+0x12>
800045a2:	00 00       	add	r0,r0
800045a4:	00 00       	add	r0,r0
800045a6:	0b 60       	ld.uh	r0,--r5
800045a8:	00 00       	add	r0,r0
800045aa:	0b 54       	ld.sh	r4,--r5
800045ac:	00 00       	add	r0,r0
800045ae:	0b 58       	ld.sh	r8,--r5
800045b0:	00 00       	add	r0,r0
800045b2:	0b 50       	ld.sh	r0,--r5
800045b4:	00 00       	add	r0,r0
800045b6:	0b 40       	ld.w	r0,--r5
800045b8:	80 00       	ld.sh	r0,r0[0x0]
800045ba:	57 00       	stdsp	sp[0x1c0],r0
800045bc:	80 00       	ld.sh	r0,r0[0x0]
800045be:	55 90       	stdsp	sp[0x164],r0
800045c0:	80 00       	ld.sh	r0,r0[0x0]
800045c2:	2a 28       	sub	r8,-94
800045c4:	00 00       	add	r0,r0
800045c6:	0a 9c       	mov	r12,r5
800045c8:	80 00       	ld.sh	r0,r0[0x0]
800045ca:	2a 08       	sub	r8,-96

800045cc <xnl_rx_process>:
Description: Receive the XNL
Calls: 
Called By:task
*/
static void xnl_rx_process(void * pvParameters)
{
800045cc:	eb cd 40 fe 	pushm	r1-r7,lr
800045d0:	20 1d       	sub	sp,4
	/*To ptr the elements in the queue*/
	xnl_fragment_t * xnl_ptr;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
800045d2:	49 26       	lddpc	r6,80004618 <xnl_rx_process+0x4c>
800045d4:	30 05       	mov	r5,0
800045d6:	3f f4       	mov	r4,-1
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
800045d8:	30 c3       	mov	r3,12
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
800045da:	49 11       	lddpc	r1,8000461c <xnl_rx_process+0x50>
	if(xnl->xnl_header.opcode > 0x0C)	
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
800045dc:	49 12       	lddpc	r2,80004620 <xnl_rx_process+0x54>
	/*To ptr the elements in the queue*/
	xnl_fragment_t * xnl_ptr;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
800045de:	6c 0c       	ld.w	r12,r6[0x0]
800045e0:	0a 99       	mov	r9,r5
800045e2:	08 9a       	mov	r10,r4
800045e4:	1a 9b       	mov	r11,sp
800045e6:	f0 1f 00 10 	mcall	80004624 <xnl_rx_process+0x58>
800045ea:	58 1c       	cp.w	r12,1
800045ec:	cf 91       	brne	800045de <xnl_rx_process+0x12>
		, portMAX_DELAY ))
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
800045ee:	40 0c       	lddsp	r12,sp[0x0]
800045f0:	58 0c       	cp.w	r12,0
800045f2:	cf 60       	breq	800045de <xnl_rx_process+0x12>
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
800045f4:	98 28       	ld.sh	r8,r12[0x4]
800045f6:	e6 08 19 00 	cp.h	r8,r3
800045fa:	e0 8b 00 0a 	brhi	8000460e <xnl_rx_process+0x42>
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
800045fe:	5c 78       	castu.h	r8
80004600:	e4 08 03 29 	ld.w	r9,r2[r8<<0x2]
80004604:	58 09       	cp.w	r9,0
80004606:	c0 40       	breq	8000460e <xnl_rx_process+0x42>
	{
		//log("\n\r R_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:R_xnl指令
		/*execute the function in list*/
		xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec(xnl);
80004608:	e4 08 03 28 	ld.w	r8,r2[r8<<0x2]
8000460c:	5d 18       	icall	r8
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
8000460e:	62 0c       	ld.w	r12,r1[0x0]
80004610:	40 0b       	lddsp	r11,sp[0x0]
80004612:	f0 1f 00 06 	mcall	80004628 <xnl_rx_process+0x5c>
80004616:	ce 4b       	rjmp	800045de <xnl_rx_process+0x12>
80004618:	00 00       	add	r0,r0
8000461a:	0a bc       	st.h	r5++,r12
8000461c:	00 00       	add	r0,r0
8000461e:	0a 9c       	mov	r12,r5
80004620:	00 00       	add	r0,r0
80004622:	04 fc       	st.b	--r2,r12
80004624:	80 00       	ld.sh	r0,r0[0x0]
80004626:	57 00       	stdsp	sp[0x1c0],r0
80004628:	80 00       	ld.sh	r0,r0[0x0]
8000462a:	2a 08       	sub	r8,-96

8000462c <xnl_tx>:
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
{
8000462c:	eb cd 40 c0 	pushm	r6-r7,lr
80004630:	20 1d       	sub	sp,4
80004632:	18 96       	mov	r6,r12
	message that is sent. The same value should be used for all retries.
	*/
	static U8 flags = 0;
	
	/*If the value is DEFAULT_VALUE, the value will be modified*/
	if(DEFAULT_VALUE == xnl->xnl_header.flags)
80004634:	98 39       	ld.sh	r9,r12[0x6]
80004636:	3f f8       	mov	r8,-1
80004638:	f0 09 19 00 	cp.h	r9,r8
8000463c:	c0 a1       	brne	80004650 <xnl_tx+0x24>
	{
		xnl->xnl_header.flags =  0x0100 | ((++flags) & 0x07);
8000463e:	4a e9       	lddpc	r9,800046f4 <xnl_tx+0xc8>
80004640:	13 88       	ld.ub	r8,r9[0x0]
80004642:	2f f8       	sub	r8,-1
80004644:	5c 58       	castu.b	r8
80004646:	b2 88       	st.b	r9[0x0],r8
80004648:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
8000464c:	a9 a8       	sbr	r8,0x8
8000464e:	b8 38       	st.h	r12[0x6],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.destination)
80004650:	8c 49       	ld.sh	r9,r6[0x8]
80004652:	3f f8       	mov	r8,-1
80004654:	f0 09 19 00 	cp.h	r9,r8
80004658:	c0 41       	brne	80004660 <xnl_tx+0x34>
	{		
		/*Use actual Master address.*/
		xnl->xnl_header.destination = xnl_information.master_address;
8000465a:	4a 88       	lddpc	r8,800046f8 <xnl_tx+0xcc>
8000465c:	90 18       	ld.sh	r8,r8[0x2]
8000465e:	ac 48       	st.h	r6[0x8],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.source)
80004660:	8c 59       	ld.sh	r9,r6[0xa]
80004662:	3f f8       	mov	r8,-1
80004664:	f0 09 19 00 	cp.h	r9,r8
80004668:	c0 41       	brne	80004670 <xnl_tx+0x44>
	{
		/*Use Temporary address.*/	
		xnl->xnl_header.source = xnl_information.device_address;
8000466a:	4a 48       	lddpc	r8,800046f8 <xnl_tx+0xcc>
8000466c:	90 28       	ld.sh	r8,r8[0x4]
8000466e:	ac 58       	st.h	r6[0xa],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
80004670:	8c 69       	ld.sh	r9,r6[0xc]
80004672:	3f f8       	mov	r8,-1
80004674:	f0 09 19 00 	cp.h	r9,r8
80004678:	c0 e1       	brne	80004694 <xnl_tx+0x68>
	{		
		xnl->xnl_header.transaction_id = 
		  ((++xnl_information.transaction_id) & 0xFF) 
8000467a:	4a 08       	lddpc	r8,800046f8 <xnl_tx+0xcc>
8000467c:	90 49       	ld.sh	r9,r8[0x8]
8000467e:	2f f9       	sub	r9,-1
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
80004680:	b0 49       	st.h	r8[0x8],r9
		  ((++xnl_information.transaction_id) & 0xFF) 
80004682:	90 4a       	ld.sh	r10,r8[0x8]
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
80004684:	90 49       	ld.sh	r9,r8[0x8]
80004686:	e0 19 ff 00 	andl	r9,0xff00
8000468a:	f1 da c0 08 	bfextu	r8,r10,0x0,0x8
8000468e:	f3 e8 10 08 	or	r8,r9,r8
80004692:	ac 68       	st.h	r6[0xc],r8
	U16  sumScratch;
	U32  indextohWord;
	S32  hWordswithinFrag;
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
80004694:	0d 98       	ld.ub	r8,r6[0x1]
80004696:	20 28       	sub	r8,2
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
80004698:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
8000469c:	10 0c       	add	r12,r8
8000469e:	a1 5c       	asr	r12,0x1
	indextohWord = 2;
	while (hWordswithinFrag > 0)
800046a0:	58 0c       	cp.w	r12,0
800046a2:	e0 89 00 04 	brgt	800046aa <xnl_tx+0x7e>
800046a6:	30 09       	mov	r9,0
800046a8:	c0 d8       	rjmp	800046c2 <xnl_tx+0x96>
800046aa:	ec ca ff fc 	sub	r10,r6,-4
Parameters: xnl_fragment_t * 
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
800046ae:	2f ec       	sub	r12,-2
800046b0:	30 09       	mov	r9,0
800046b2:	30 28       	mov	r8,2
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
	{
		sumScratch += *((U16*)xnl + indextohWord);
800046b4:	15 1b       	ld.sh	r11,r10++
800046b6:	f6 09 00 09 	add	r9,r11,r9
800046ba:	5c 89       	casts.h	r9
		indextohWord     += 1;
800046bc:	2f f8       	sub	r8,-1
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
800046be:	18 38       	cp.w	r8,r12
800046c0:	cf a1       	brne	800046b4 <xnl_tx+0x88>
		  ((++xnl_information.transaction_id) & 0xFF) 
		| (xnl_information.transaction_id & 0xFF00);
	}
	
	/*count check sum */
	xnl->phy_header.check_sum = check_sum( xnl );
800046c2:	5c 39       	neg	r9
800046c4:	ac 19       	st.h	r6[0x2],r9
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
800046c6:	48 e8       	lddpc	r8,800046fc <xnl_tx+0xd0>
800046c8:	70 0c       	ld.w	r12,r8[0x0]
800046ca:	f0 1f 00 0e 	mcall	80004700 <xnl_tx+0xd4>
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
800046ce:	c1 00       	breq	800046ee <xnl_tx+0xc2>
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
800046d0:	fa c7 ff fc 	sub	r7,sp,-4
800046d4:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
	{
		memcpy(ptr, xnl, sizeof(xnl_fragment_t));
800046d6:	e0 6a 01 00 	mov	r10,256
800046da:	0c 9b       	mov	r11,r6
800046dc:	f0 1f 00 0a 	mcall	80004704 <xnl_tx+0xd8>
	
		/*push to queue and send*/
		
		//log("ptr -%8x", ptr);
		
		xQueueSend(xnl_frame_tx, &ptr, 0);
800046e0:	48 a8       	lddpc	r8,80004708 <xnl_tx+0xdc>
800046e2:	70 0c       	ld.w	r12,r8[0x0]
800046e4:	30 09       	mov	r9,0
800046e6:	12 9a       	mov	r10,r9
800046e8:	1a 9b       	mov	r11,sp
800046ea:	f0 1f 00 09 	mcall	8000470c <xnl_tx+0xe0>
		//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
		
		//vPortFree(ptr);
	}
}
800046ee:	2f fd       	sub	sp,-4
800046f0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800046f4:	00 00       	add	r0,r0
800046f6:	0b 5c       	ld.sh	r12,--r5
800046f8:	00 00       	add	r0,r0
800046fa:	0b 44       	ld.w	r4,--r5
800046fc:	00 00       	add	r0,r0
800046fe:	0a 9c       	mov	r12,r5
80004700:	80 00       	ld.sh	r0,r0[0x0]
80004702:	2f 88       	sub	r8,-8
80004704:	80 00       	ld.sh	r0,r0[0x0]
80004706:	6e 5c       	ld.w	r12,r7[0x14]
80004708:	00 00       	add	r0,r0
8000470a:	0b 54       	ld.sh	r4,--r5
8000470c:	80 00       	ld.sh	r0,r0[0x0]
8000470e:	59 0c       	cp.w	r12,16

80004710 <xnl_init>:
	xTaskCreate--freertos
	xnl_send_device_master_query
Called By:xcmp_init -- xcmp.c
*/
void xnl_init(void)
{
80004710:	eb cd 40 80 	pushm	r7,lr
80004714:	fa cd 01 00 	sub	sp,sp,256
	/*initialize the physical layer*/
	phy_init();
80004718:	f0 1f 00 27 	mcall	800047b4 <xnl_init+0xa4>
	
	xnl_information.is_connected = FALSE;
8000471c:	30 09       	mov	r9,0
8000471e:	4a 78       	lddpc	r8,800047b8 <xnl_init+0xa8>
80004720:	b0 89       	st.b	r8[0x0],r9

	/*initialize the semaphore and queue*/
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
80004722:	30 0b       	mov	r11,0
80004724:	30 1c       	mov	r12,1
80004726:	f0 1f 00 26 	mcall	800047bc <xnl_init+0xac>
8000472a:	4a 68       	lddpc	r8,800047c0 <xnl_init+0xb0>
8000472c:	91 0c       	st.w	r8[0x0],r12
8000472e:	70 08       	ld.w	r8,r8[0x0]
80004730:	58 08       	cp.w	r8,0
80004732:	c0 80       	breq	80004742 <xnl_init+0x32>
80004734:	4a 38       	lddpc	r8,800047c0 <xnl_init+0xb0>
80004736:	70 0c       	ld.w	r12,r8[0x0]
80004738:	30 09       	mov	r9,0
8000473a:	12 9a       	mov	r10,r9
8000473c:	12 9b       	mov	r11,r9
8000473e:	f0 1f 00 22 	mcall	800047c4 <xnl_init+0xb4>
	//xnl_frame_tx = xQueueCreate(10, sizeof(xnl_fragment_t *)); 
	
	xnl_frame_tx = xQueueCreate(20, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
80004742:	30 4b       	mov	r11,4
80004744:	31 4c       	mov	r12,20
80004746:	f0 1f 00 1e 	mcall	800047bc <xnl_init+0xac>
8000474a:	4a 08       	lddpc	r8,800047c8 <xnl_init+0xb8>
8000474c:	91 0c       	st.w	r8[0x0],r12
		
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
8000474e:	30 07       	mov	r7,0
80004750:	1a d7       	st.w	--sp,r7
80004752:	1a d7       	st.w	--sp,r7
80004754:	1a d7       	st.w	--sp,r7
80004756:	30 38       	mov	r8,3
80004758:	0e 99       	mov	r9,r7
8000475a:	e0 6a 02 00 	mov	r10,512
8000475e:	49 cb       	lddpc	r11,800047cc <xnl_init+0xbc>
80004760:	49 cc       	lddpc	r12,800047d0 <xnl_init+0xc0>
80004762:	f0 1f 00 1d 	mcall	800047d4 <xnl_init+0xc4>
	,  tskXNL_PRIORITY //+ 1
	,  NULL
	);
	
	/*this task is used to send xnl message*/
	xTaskCreate(
80004766:	1a d7       	st.w	--sp,r7
80004768:	1a d7       	st.w	--sp,r7
8000476a:	1a d7       	st.w	--sp,r7
8000476c:	30 38       	mov	r8,3
8000476e:	0e 99       	mov	r9,r7
80004770:	e0 6a 03 20 	mov	r10,800
80004774:	49 9b       	lddpc	r11,800047d8 <xnl_init+0xc8>
80004776:	49 ac       	lddpc	r12,800047dc <xnl_init+0xcc>
80004778:	f0 1f 00 17 	mcall	800047d4 <xnl_init+0xc4>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
8000477c:	e0 68 40 0e 	mov	r8,16398
80004780:	fb 58 00 18 	st.h	sp[24],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004784:	3f f8       	mov	r8,-1
80004786:	fb 58 00 1a 	st.h	sp[26],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_MASTER_QUERY;
8000478a:	30 38       	mov	r8,3
8000478c:	fb 58 00 1c 	st.h	sp[28],r8
	
	/*The initial value*/
	xnl_frame.xnl_header.flags = 0;
80004790:	fb 57 00 1e 	st.h	sp[30],r7
	
	/*XNL address of the master device, if known;otherwise 0x0000*/
	xnl_frame.xnl_header.destination = 0;
80004794:	fb 57 00 20 	st.h	sp[32],r7
	
	/*XNL address, if assigned; otherwise 0x0000*/
	xnl_frame.xnl_header.source = 0;
80004798:	fb 57 00 22 	st.h	sp[34],r7
	
	/*No transaction ID required for this message*/
	xnl_frame.xnl_header.transaction_id = 0;
8000479c:	fb 57 00 24 	st.h	sp[36],r7
	
	/*This message contains no payload*/
	xnl_frame.xnl_header.payload_length = 0;
800047a0:	fb 57 00 26 	st.h	sp[38],r7

	/*send XNL message*/
	xnl_tx(&xnl_frame);
800047a4:	fa cc ff e8 	sub	r12,sp,-24
800047a8:	f0 1f 00 0e 	mcall	800047e0 <xnl_init+0xd0>
800047ac:	2f ad       	sub	sp,-24
	,  NULL
	);
	
	/*send device_master_query to connect radio*/	
	xnl_send_device_master_query();
}
800047ae:	2c 0d       	sub	sp,-256
800047b0:	e3 cd 80 80 	ldm	sp++,r7,pc
800047b4:	80 00       	ld.sh	r0,r0[0x0]
800047b6:	2f b0       	sub	r0,-5
800047b8:	00 00       	add	r0,r0
800047ba:	0b 44       	ld.w	r4,--r5
800047bc:	80 00       	ld.sh	r0,r0[0x0]
800047be:	5a 64       	cp.w	r4,-26
800047c0:	00 00       	add	r0,r0
800047c2:	0b 40       	ld.w	r0,--r5
800047c4:	80 00       	ld.sh	r0,r0[0x0]
800047c6:	59 0c       	cp.w	r12,16
800047c8:	00 00       	add	r0,r0
800047ca:	0b 54       	ld.sh	r4,--r5
800047cc:	80 00       	ld.sh	r0,r0[0x0]
800047ce:	d3 f8       	*unknown*
800047d0:	80 00       	ld.sh	r0,r0[0x0]
800047d2:	45 cc       	lddsp	r12,sp[0x170]
800047d4:	80 00       	ld.sh	r0,r0[0x0]
800047d6:	61 38       	ld.w	r8,r0[0x4c]
800047d8:	80 00       	ld.sh	r0,r0[0x0]
800047da:	c6 00       	breq	8000489a <xnl_device_auth_reply_func+0x56>
800047dc:	80 00       	ld.sh	r0,r0[0x0]
800047de:	45 04       	lddsp	r4,sp[0x140]
800047e0:	80 00       	ld.sh	r0,r0[0x0]
800047e2:	46 2c       	lddsp	r12,sp[0x188]

800047e4 <xnl_data_msg_func>:
Description: process while receive data message.
Calls:xnl_send_msg_ack, xcmp_exec(function in xcmp)
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_data_msg_func(xnl_fragment_t * xnl)
{
800047e4:	eb cd 40 80 	pushm	r7,lr
800047e8:	fa cd 01 00 	sub	sp,sp,256
800047ec:	18 97       	mov	r7,r12
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
800047ee:	e0 68 40 0e 	mov	r8,16398
800047f2:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
800047f4:	3f f8       	mov	r8,-1
800047f6:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG_ACK;
800047f8:	30 c8       	mov	r8,12
800047fa:	ba 28       	st.h	sp[0x4],r8
	
	/*Turn around Flags.*/	
	xnl_frame.xnl_header.flags = hdr->flags;
800047fc:	98 38       	ld.sh	r8,r12[0x6]
800047fe:	ba 38       	st.h	sp[0x6],r8
	
	/*ACK Destination Address is Source of XNL_Message.*/
	xnl_frame.xnl_header.destination = hdr->source;
80004800:	98 58       	ld.sh	r8,r12[0xa]
80004802:	ba 48       	st.h	sp[0x8],r8
	
	/*ACK Source Address is my address.*/
	xnl_frame.xnl_header.source = hdr->destination;
80004804:	98 48       	ld.sh	r8,r12[0x8]
80004806:	ba 58       	st.h	sp[0xa],r8
	
	/*Turn around Transaction ID.*/
	xnl_frame.xnl_header.transaction_id = hdr->transaction_id;
80004808:	98 68       	ld.sh	r8,r12[0xc]
8000480a:	ba 68       	st.h	sp[0xc],r8
	xnl_frame.xnl_header.payload_length = 0;
8000480c:	30 08       	mov	r8,0
8000480e:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004810:	1a 9c       	mov	r12,sp
80004812:	f0 1f 00 0a 	mcall	80004838 <xnl_data_msg_func+0x54>
	transmitter, but possibly is waiting in Queue with immediate timeout.
	 */
	xnl_send_msg_ack(&xnl->xnl_header);
	
	/*exec xcmp function*/
	xcmp_exec(xnl->xnl_payload.xnl_content_data_msg);//xcmp_rx
80004816:	fa cd 00 cc 	sub	sp,sp,204
8000481a:	e0 6a 00 ca 	mov	r10,202
8000481e:	ee cb ff f0 	sub	r11,r7,-16
80004822:	1a 9c       	mov	r12,sp
80004824:	f0 1f 00 06 	mcall	8000483c <xnl_data_msg_func+0x58>
80004828:	48 68       	lddpc	r8,80004840 <xnl_data_msg_func+0x5c>
8000482a:	70 08       	ld.w	r8,r8[0x0]
8000482c:	5d 18       	icall	r8
8000482e:	fa cd ff 34 	sub	sp,sp,-204
}
80004832:	2c 0d       	sub	sp,-256
80004834:	e3 cd 80 80 	ldm	sp++,r7,pc
80004838:	80 00       	ld.sh	r0,r0[0x0]
8000483a:	46 2c       	lddsp	r12,sp[0x188]
8000483c:	80 00       	ld.sh	r0,r0[0x0]
8000483e:	6e 5c       	ld.w	r12,r7[0x14]
80004840:	00 00       	add	r0,r0
80004842:	0b 64       	ld.uh	r4,--r5

80004844 <xnl_device_auth_reply_func>:
Description: process while receive device auth reply.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_auth_reply_func(xnl_fragment_t * xnl)
{
80004844:	d4 21       	pushm	r4-r7,lr
80004846:	fa cd 01 00 	sub	sp,sp,256
8000484a:	18 97       	mov	r7,r12
	the receiving device and will be used to authenticate the connection 
	request. 5.4.4
	*/
	//log("R_xnl-opcode:%4x", xnl->xnl_header.opcode);
	
	if(xnl_information.is_connected)
8000484c:	4c 28       	lddpc	r8,80004954 <xnl_device_auth_reply_func+0x110>
8000484e:	11 88       	ld.ub	r8,r8[0x0]
80004850:	58 08       	cp.w	r8,0
80004852:	e0 81 00 7f 	brne	80004950 <xnl_device_auth_reply_func+0x10c>
	{
		return;		
	}
	
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);
80004856:	4c 18       	lddpc	r8,80004958 <xnl_device_auth_reply_func+0x114>
80004858:	70 0c       	ld.w	r12,r8[0x0]
8000485a:	30 09       	mov	r9,0
8000485c:	12 9a       	mov	r10,r9
8000485e:	12 9b       	mov	r11,r9
80004860:	f0 1f 00 3f 	mcall	8000495c <xnl_device_auth_reply_func+0x118>

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
80004864:	ef 09 00 10 	ld.sh	r9,r7[16]
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
80004868:	4b b8       	lddpc	r8,80004954 <xnl_device_auth_reply_func+0x110>
8000486a:	b0 29       	st.h	r8[0x4],r9
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
	
	/*Get Array of values to be encrypted into an aligned 2X32bits.*/
	v_vector[0] =
8000486c:	ef 39 00 12 	ld.ub	r9,r7[18]
80004870:	ef 38 00 13 	ld.ub	r8,r7[19]
80004874:	b1 68       	lsl	r8,0x10
80004876:	f1 e9 11 89 	or	r9,r8,r9<<0x18
8000487a:	ef 38 00 15 	ld.ub	r8,r7[21]
8000487e:	f3 e8 10 08 	or	r8,r9,r8
80004882:	ef 39 00 14 	ld.ub	r9,r7[20]
80004886:	f1 e9 10 89 	or	r9,r8,r9<<0x8
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[2])<<8	  
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[3]);
	
	v_vector[1] =
8000488a:	ef 3a 00 16 	ld.ub	r10,r7[22]
8000488e:	ef 38 00 17 	ld.ub	r8,r7[23]
80004892:	b1 68       	lsl	r8,0x10
80004894:	f1 ea 11 8a 	or	r10,r8,r10<<0x18
80004898:	ef 38 00 19 	ld.ub	r8,r7[25]
8000489c:	f5 e8 10 08 	or	r8,r10,r8
800048a0:	ef 3a 00 18 	ld.ub	r10,r7[24]
800048a4:	f1 ea 10 88 	or	r8,r8,r10<<0x8
800048a8:	30 0a       	mov	r10,0
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
800048aa:	e0 64 79 b9 	mov	r4,31161
800048ae:	ea 14 9e 37 	orh	r4,0x9e37
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
800048b2:	e0 65 45 07 	mov	r5,17671
800048b6:	ea 15 8a bd 	orh	r5,0x8abd
800048ba:	e0 66 f9 3d 	mov	r6,63805
800048be:	ea 16 99 68 	orh	r6,0x9968
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
800048c2:	e0 6e b8 cf 	mov	lr,47311
800048c6:	ea 1e 36 83 	orh	lr,0x3683
800048ca:	e0 67 aa 1c 	mov	r7,43548
800048ce:	ea 17 9c 36 	orh	r7,0x9c36
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
800048d2:	08 0a       	add	r10,r4
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
800048d4:	f4 08 00 0c 	add	r12,r10,r8
800048d8:	f0 0b 15 04 	lsl	r11,r8,0x4
800048dc:	0a 0b       	add	r11,r5
800048de:	f9 eb 20 0b 	eor	r11,r12,r11
800048e2:	f0 0c 16 05 	lsr	r12,r8,0x5
800048e6:	0c 0c       	add	r12,r6
800048e8:	18 5b       	eor	r11,r12
800048ea:	16 09       	add	r9,r11
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
800048ec:	f2 0c 15 04 	lsl	r12,r9,0x4
800048f0:	1c 0c       	add	r12,lr
800048f2:	f2 0b 16 05 	lsr	r11,r9,0x5
800048f6:	0e 0b       	add	r11,r7
800048f8:	f9 eb 20 0b 	eor	r11,r12,r11
800048fc:	f2 0a 00 0c 	add	r12,r9,r10
80004900:	18 5b       	eor	r11,r12
80004902:	16 08       	add	r8,r11
{
	register U32 y=v[0], z=v[1], sum=0;
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
80004904:	e0 6b 37 20 	mov	r11,14112
80004908:	ea 1b c6 ef 	orh	r11,0xc6ef
8000490c:	16 3a       	cp.w	r10,r11
8000490e:	ce 21       	brne	800048d2 <xnl_device_auth_reply_func+0x8e>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :24 + 2(xnl length(24) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 24 + 2;
80004910:	e0 6a 40 1a 	mov	r10,16410
80004914:	ba 0a       	st.h	sp[0x0],r10
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004916:	3f fa       	mov	r10,-1
80004918:	ba 1a       	st.h	sp[0x2],r10
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_CONN_REQUEST;
8000491a:	30 6b       	mov	r11,6
8000491c:	ba 2b       	st.h	sp[0x4],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
8000491e:	ba 3a       	st.h	sp[0x6],r10
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
80004920:	48 db       	lddpc	r11,80004954 <xnl_device_auth_reply_func+0x110>
80004922:	96 1c       	ld.sh	r12,r11[0x2]
80004924:	ba 4c       	st.h	sp[0x8],r12
	message here, and all will receive the same DEVICE_CONN_REPLY. Not real 
	sure what's going to happen with multiple conrol heads, etc. One suspects 
	the Rocket Scientists will eventually figure this out, and demand a 
	transaction ID based on Device Type in the XNL_DEVICE_AUTH_KEY_REQUEST.
	*/
	xnl_frame.xnl_header.source = xnl_information.device_address;
80004926:	96 2b       	ld.sh	r11,r11[0x4]
80004928:	ba 5b       	st.h	sp[0xa],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
8000492a:	ba 6a       	st.h	sp[0xc],r10
	
    /*his message contains 12 payload bytes*/	
	xnl_frame.xnl_header.payload_length = 0x000C;
8000492c:	30 ca       	mov	r10,12
8000492e:	ba 7a       	st.h	sp[0xe],r10
	
	/*No Preferred XNL Address*/
	xnl_frame.xnl_payload.xnl_content_device_conn_req.preferred_xnl_address = 
80004930:	30 0a       	mov	r10,0
80004932:	fb 5a 00 10 	st.h	sp[16],r10
	XCMP/XNL Development Specification Section 4.5.3.2.1.
	Same as in MOTOTRBO?XCMP/XNL Development Specification?
	evice_type--Option Board(0x07)
	authentication_index--Option Board(0x02)
	*/	
	xnl_frame.xnl_payload.xnl_content_device_conn_req.device_type = 0x07;
80004936:	30 7a       	mov	r10,7
80004938:	fb 6a 00 12 	st.b	sp[18],r10
	xnl_frame.xnl_payload.xnl_content_device_conn_req.authentication_index =
8000493c:	30 2a       	mov	r10,2
8000493e:	fb 6a 00 13 	st.b	sp[19],r10
	                                                                       0x02;
		
	//We know encrypted array happens to be aligned to 32-bit boundary.
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
80004942:	fa ca ff ec 	sub	r10,sp,-20
80004946:	95 09       	st.w	r10[0x0],r9
	                         .encrypted_authentication_value[0])) = w_vector[0];
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
80004948:	95 18       	st.w	r10[0x4],r8
	                         .encrypted_authentication_value[4])) = w_vector[1];
	
	/*send XNL message*/
	xnl_tx(&xnl_frame);
8000494a:	1a 9c       	mov	r12,sp
8000494c:	f0 1f 00 05 	mcall	80004960 <xnl_device_auth_reply_func+0x11c>
}
80004950:	2c 0d       	sub	sp,-256
80004952:	d8 22       	popm	r4-r7,pc
80004954:	00 00       	add	r0,r0
80004956:	0b 44       	ld.w	r4,--r5
80004958:	00 00       	add	r0,r0
8000495a:	0b 40       	ld.w	r0,--r5
8000495c:	80 00       	ld.sh	r0,r0[0x0]
8000495e:	59 0c       	cp.w	r12,16
80004960:	80 00       	ld.sh	r0,r0[0x0]
80004962:	46 2c       	lddsp	r12,sp[0x188]

80004964 <xnl_master_status_brdcst_func>:
Description: process while receive master status boardcast.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_master_status_brdcst_func(xnl_fragment_t * xnl)
{	
80004964:	eb cd 40 80 	pushm	r7,lr
80004968:	fa cd 01 00 	sub	sp,sp,256
8000496c:	18 97       	mov	r7,r12
	not an XNL_DATA_MSG has been sent out. This will indicate to a connecting 
	device that it has missed messages. The XNL header will contain the 
	master?XNL address. 5.4.1
	*/
	
	if(xnl_information.is_connected)
8000496e:	49 28       	lddpc	r8,800049b4 <xnl_master_status_brdcst_func+0x50>
80004970:	11 88       	ld.ub	r8,r8[0x0]
80004972:	58 08       	cp.w	r8,0
80004974:	c1 c1       	brne	800049ac <xnl_master_status_brdcst_func+0x48>
	{
		return;	
	}
		
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);	
80004976:	49 18       	lddpc	r8,800049b8 <xnl_master_status_brdcst_func+0x54>
80004978:	70 0c       	ld.w	r12,r8[0x0]
8000497a:	30 09       	mov	r9,0
8000497c:	12 9a       	mov	r10,r9
8000497e:	12 9b       	mov	r11,r9
80004980:	f0 1f 00 0f 	mcall	800049bc <xnl_master_status_brdcst_func+0x58>

	//log("xnl-ma:%4x", xnl->xnl_header.source);
	/*get the master adderss from this message*/	
	xnl_information.master_address = xnl->xnl_header.source;	
80004984:	8e 58       	ld.sh	r8,r7[0xa]
80004986:	48 c9       	lddpc	r9,800049b4 <xnl_master_status_brdcst_func+0x50>
80004988:	b2 18       	st.h	r9[0x2],r8
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
8000498a:	e0 68 40 0e 	mov	r8,16398
8000498e:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004990:	3f f8       	mov	r8,-1
80004992:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_AUTH_KEY_REQUEST;
80004994:	30 4a       	mov	r10,4
80004996:	ba 2a       	st.h	sp[0x4],r10
		
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/	
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
80004998:	ba 38       	st.h	sp[0x6],r8
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
8000499a:	92 19       	ld.sh	r9,r9[0x2]
8000499c:	ba 49       	st.h	sp[0x8],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.source = DEFAULT_VALUE;
8000499e:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
800049a0:	ba 68       	st.h	sp[0xc],r8
		
	xnl_frame.xnl_header.payload_length = 0;
800049a2:	30 08       	mov	r8,0
800049a4:	ba 78       	st.h	sp[0xe],r8
	
	/*send XNL message*/	
	xnl_tx(&xnl_frame);
800049a6:	1a 9c       	mov	r12,sp
800049a8:	f0 1f 00 06 	mcall	800049c0 <xnl_master_status_brdcst_func+0x5c>
}
800049ac:	2c 0d       	sub	sp,-256
800049ae:	e3 cd 80 80 	ldm	sp++,r7,pc
800049b2:	00 00       	add	r0,r0
800049b4:	00 00       	add	r0,r0
800049b6:	0b 44       	ld.w	r4,--r5
800049b8:	00 00       	add	r0,r0
800049ba:	0b 40       	ld.w	r0,--r5
800049bc:	80 00       	ld.sh	r0,r0[0x0]
800049be:	59 0c       	cp.w	r12,16
800049c0:	80 00       	ld.sh	r0,r0[0x0]
800049c2:	46 2c       	lddsp	r12,sp[0x188]

800049c4 <xnl_device_conn_reply_func>:
Description: process while receive device conn reply.
Calls:xSemaphoreGive--freestos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_conn_reply_func(xnl_fragment_t * xnl)
{
800049c4:	eb cd 40 80 	pushm	r7,lr
800049c8:	18 97       	mov	r7,r12
	transaction ID and an 8-byte encrypted value that the device can use to 
	authenticate the master. XCMP/XNL Development Guide 5.4.6
	*/
	
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);
800049ca:	49 38       	lddpc	r8,80004a14 <xnl_device_conn_reply_func+0x50>
800049cc:	70 0c       	ld.w	r12,r8[0x0]
800049ce:	30 09       	mov	r9,0
800049d0:	12 9a       	mov	r10,r9
800049d2:	12 9b       	mov	r11,r9
800049d4:	f0 1f 00 11 	mcall	80004a18 <xnl_device_conn_reply_func+0x54>

	/*Test result code*/
	if((xnl->xnl_payload.xnl_content_device_conn_reply.result_base & 0x0000FF00)
800049d8:	ef 18 00 10 	ld.uh	r8,r7[16]
800049dc:	10 99       	mov	r9,r8
800049de:	e2 19 ff 00 	andl	r9,0xff00,COH
800049e2:	e0 49 01 00 	cp.w	r9,256
800049e6:	c0 60       	breq	800049f2 <xnl_device_conn_reply_func+0x2e>
		/*
		Rejected. The device must retry the authentication process at this 
		point by sending out a new AUTH_KEY_REQUEST message. XCMP/XNL 
		Development Guide Section 5.2.3
		*/
		xnl_master_status_brdcst_func(xnl);			
800049e8:	0e 9c       	mov	r12,r7
800049ea:	f0 1f 00 0d 	mcall	80004a1c <xnl_device_conn_reply_func+0x58>
800049ee:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/*connection accepted*/		
		/*Record Transaction ID Base*/
		xnl_information.transaction_id =  
800049f2:	a9 68       	lsl	r8,0x8
800049f4:	48 b9       	lddpc	r9,80004a20 <xnl_device_conn_reply_func+0x5c>
800049f6:	b2 48       	st.h	r9[0x8],r8
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
800049f8:	ef 08 00 14 	ld.sh	r8,r7[20]
		xnl_information.transaction_id =  
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
800049fc:	b2 38       	st.h	r9[0x6],r8
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
800049fe:	ef 08 00 12 	ld.sh	r8,r7[18]
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
80004a02:	b2 28       	st.h	r9[0x4],r8
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
		
		/*connect finish*/
		xnl_information.is_connected = TRUE;
80004a04:	30 18       	mov	r8,1
80004a06:	b2 88       	st.b	r9[0x0],r8
		
		log("connected finish");
80004a08:	48 7c       	lddpc	r12,80004a24 <xnl_device_conn_reply_func+0x60>
80004a0a:	f0 1f 00 08 	mcall	80004a28 <xnl_device_conn_reply_func+0x64>
80004a0e:	e3 cd 80 80 	ldm	sp++,r7,pc
80004a12:	00 00       	add	r0,r0
80004a14:	00 00       	add	r0,r0
80004a16:	0b 40       	ld.w	r0,--r5
80004a18:	80 00       	ld.sh	r0,r0[0x0]
80004a1a:	59 0c       	cp.w	r12,16
80004a1c:	80 00       	ld.sh	r0,r0[0x0]
80004a1e:	49 64       	lddpc	r4,80004a74 <local_start_pll0+0x48>
80004a20:	00 00       	add	r0,r0
80004a22:	0b 44       	ld.w	r4,--r5
80004a24:	80 00       	ld.sh	r0,r0[0x0]
80004a26:	d4 00       	acall	0x40
80004a28:	80 00       	ld.sh	r0,r0[0x0]
80004a2a:	64 fc       	ld.w	r12,r2[0x3c]

80004a2c <local_start_pll0>:
	//pm_switch_to_osc0(pm, 12000000, 3);
	//    pm_enable_osc0_crystal(pm, 12000000);
	//         pm_set_osc0_mode(pm,AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);  0x00000007
	//    pm_enable_clk0(pm, 3);
	//         pm_enable_clk0_no_wait(pm, 3);
	(&AVR32_PM)->oscctrl0 = 0x00000307;
80004a2c:	fe 78 0c 00 	mov	r8,-62464
80004a30:	e0 69 03 07 	mov	r9,775
80004a34:	91 a9       	st.w	r8[0x28],r9
	(&AVR32_PM)->mcctrl   = 0x00000004;
80004a36:	30 49       	mov	r9,4
80004a38:	91 09       	st.w	r8[0x0],r9
	//         pm_wait_for_clk0_ready(pm);
	while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
80004a3a:	71 59       	ld.w	r9,r8[0x54]
80004a3c:	e2 19 00 80 	andl	r9,0x80,COH
80004a40:	cf d0       	breq	80004a3a <local_start_pll0+0xe>
	//    pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);
	(&AVR32_PM)->mcctrl   = 0x00000005;
80004a42:	fe 78 0c 00 	mov	r8,-62464
80004a46:	30 59       	mov	r9,5
80004a48:	91 09       	st.w	r8[0x0],r9
	//pm_pll_set_option(pm, 0, //PLL number 0
	//                        1, //freq Set to 1 for VCO frequency range 80-180MHz
	//                        1, //div2 Divide the PLL output frequency by 2
	//                        0);//0 to enable the Wide-Bandith Mode
	//pm_pll_enable(pm,0);
	(&AVR32_PM)->pll[0] = 0x1007010D;
80004a4a:	e0 69 01 0d 	mov	r9,269
80004a4e:	ea 19 10 07 	orh	r9,0x1007
80004a52:	91 89       	st.w	r8[0x20],r9


	//pm_wait_for_pll0_locked(pm);
	while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_LOCK0_MASK));
80004a54:	71 59       	ld.w	r9,r8[0x54]
80004a56:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
80004a5a:	cf d0       	breq	80004a54 <local_start_pll0+0x28>
	//             0,  //Bus A select = 0 (PBA clock = 48MHz/2 = 24MHz).
	//             0,  //B clock divisor enable = 0
	//             0,  //Bus B select = 0
	//             0,  //HS Bus clock divisor enable = 0
	//             0); //HS Bus select = 0
	(&AVR32_PM)->cksel = 0x00800000;
80004a5c:	fe 78 0c 00 	mov	r8,-62464
80004a60:	fc 19 00 80 	movh	r9,0x80
80004a64:	91 19       	st.w	r8[0x4],r9

	//flashc_set_wait_state(1);
	AVR32_FLASHC.fcr = 0x00000040;
80004a66:	34 0a       	mov	r10,64
80004a68:	fe 69 14 00 	mov	r9,-125952
80004a6c:	93 0a       	st.w	r9[0x0],r10

	//pm_switch_to_clock(pm, AVR32_PM_MCSEL_PLL0);
	(&AVR32_PM)->mcctrl   = 0x00000006;
80004a6e:	30 69       	mov	r9,6
80004a70:	91 09       	st.w	r8[0x0],r9


	AVR32_HMATRIX.mcfg[AVR32_HMATRIX_MASTER_CPU_INSTRUCTION] = 0x1;
80004a72:	30 19       	mov	r9,1
80004a74:	fe 68 10 00 	mov	r8,-126976
80004a78:	91 19       	st.w	r8[0x4],r9
}
80004a7a:	5e fc       	retal	r12

80004a7c <rtc_init>:
    PCF8563_init
Called By: ..
Return:rtc_err_t
*/
rtc_err_t rtc_init(void)
{
80004a7c:	eb cd 40 c0 	pushm	r6-r7,lr
80004a80:	20 3d       	sub	sp,12
	/* Create the mutex semaphore to guard a shared RTC(TWI).*/	
	rtc_mutex = xSemaphoreCreateMutex();
80004a82:	f0 1f 00 1a 	mcall	80004ae8 <rtc_init+0x6c>
80004a86:	49 a8       	lddpc	r8,80004aec <rtc_init+0x70>
80004a88:	91 0c       	st.w	r8[0x0],r12
	
	if(NULL != rtc_mutex)
80004a8a:	70 08       	ld.w	r8,r8[0x0]
80004a8c:	58 08       	cp.w	r8,0
80004a8e:	c0 31       	brne	80004a94 <rtc_init+0x18>
80004a90:	30 3c       	mov	r12,3
80004a92:	c2 78       	rjmp	80004ae0 <rtc_init+0x64>
	{
		/*See if we can obtain the semaphore. If the semaphore is not available wait aways to see if it becomes free*/
		xSemaphoreTake( rtc_mutex, portMAX_DELAY);
80004a94:	49 66       	lddpc	r6,80004aec <rtc_init+0x70>
80004a96:	6c 0c       	ld.w	r12,r6[0x0]
80004a98:	30 09       	mov	r9,0
80004a9a:	3f fa       	mov	r10,-1
80004a9c:	12 9b       	mov	r11,r9
80004a9e:	f0 1f 00 15 	mcall	80004af0 <rtc_init+0x74>
	
	/*twi_package_t packet, packet_received*/
	static int status;

	/*TWI gpio pins configuration*/	
	gpio_enable_module(TWI_GPIO_MAP, sizeof(TWI_GPIO_MAP) / sizeof(TWI_GPIO_MAP[0]));
80004aa2:	30 2b       	mov	r11,2
80004aa4:	49 4c       	lddpc	r12,80004af4 <rtc_init+0x78>
80004aa6:	f0 1f 00 15 	mcall	80004af8 <rtc_init+0x7c>
	
	/* options settings*/
	opt.pba_hz = RTC_PBACLK_FREQ_HZ;//FOSC0;24Mhz
80004aaa:	e0 68 36 00 	mov	r8,13824
80004aae:	ea 18 01 6e 	orh	r8,0x16e
80004ab2:	50 08       	stdsp	sp[0x0],r8
	opt.speed  = TWI_SPEED;//200Khz
80004ab4:	e2 78 0d 40 	mov	r8,200000
80004ab8:	50 18       	stdsp	sp[0x4],r8
	opt.chip   = PCF8563_ADDRESS;
80004aba:	35 18       	mov	r8,81
80004abc:	fb 68 00 08 	st.b	sp[8],r8

	/*initialize TWI driver with options*/
	status = twi_master_init(&AVR32_TWI, &opt);
80004ac0:	1a 9b       	mov	r11,sp
80004ac2:	fe 7c 2c 00 	mov	r12,-54272
80004ac6:	f0 1f 00 0e 	mcall	80004afc <rtc_init+0x80>
80004aca:	48 e7       	lddpc	r7,80004b00 <rtc_init+0x84>
80004acc:	8f 0c       	st.w	r7[0x0],r12
	
	/*finished accessing the shared resource.Release the semaphore.*/
	xSemaphoreGive(rtc_mutex);		
80004ace:	6c 0c       	ld.w	r12,r6[0x0]
80004ad0:	30 09       	mov	r9,0
80004ad2:	12 9a       	mov	r10,r9
80004ad4:	12 9b       	mov	r11,r9
80004ad6:	f0 1f 00 0c 	mcall	80004b04 <rtc_init+0x88>
80004ada:	6e 08       	ld.w	r8,r7[0x0]
80004adc:	58 08       	cp.w	r8,0
80004ade:	5f 1c       	srne	r12
	{
		return rtc_success;
	}
		
	return rtc_init_err;
}
80004ae0:	2f dd       	sub	sp,-12
80004ae2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004ae6:	00 00       	add	r0,r0
80004ae8:	80 00       	ld.sh	r0,r0[0x0]
80004aea:	5a 0c       	cp.w	r12,-32
80004aec:	00 00       	add	r0,r0
80004aee:	0b 6c       	ld.uh	r12,--r5
80004af0:	80 00       	ld.sh	r0,r0[0x0]
80004af2:	57 00       	stdsp	sp[0x1c0],r0
80004af4:	80 00       	ld.sh	r0,r0[0x0]
80004af6:	d4 14       	*unknown*
80004af8:	80 00       	ld.sh	r0,r0[0x0]
80004afa:	69 94       	ld.w	r4,r4[0x64]
80004afc:	80 00       	ld.sh	r0,r0[0x0]
80004afe:	4f 8c       	lddpc	r12,80004cdc <tc_init_waveform+0x8>
80004b00:	00 00       	add	r0,r0
80004b02:	0b 68       	ld.uh	r8,--r5
80004b04:	80 00       	ld.sh	r0,r0[0x0]
80004b06:	59 0c       	cp.w	r12,16

80004b08 <local_start_timer>:
//	MAKO_RX					AVR32_SSC_RX_DATA_0_PIN				[39 PortB Pin  7 00000080 Func 0]
//
void local_start_timer(void)
{
	//Route CLK to Timer
	AVR32_GPIO.port[0].pmr0s = 0x00100000;
80004b08:	fe 78 10 00 	mov	r8,-61440
80004b0c:	fc 19 00 10 	movh	r9,0x10
80004b10:	91 59       	st.w	r8[0x14],r9
	AVR32_GPIO.port[0].pmr1c = 0x00100000;
80004b12:	91 a9       	st.w	r8[0x28],r9
	AVR32_GPIO.port[0].gperc = 0x00100000;
80004b14:	91 29       	st.w	r8[0x8],r9
	//Route FS and Tri-State to Timer.
	AVR32_GPIO.port[1].pmr0c = 0x00000003;
80004b16:	30 39       	mov	r9,3
80004b18:	f1 49 01 18 	st.w	r8[280],r9
	AVR32_GPIO.port[1].pmr1c = 0x00000003;
80004b1c:	f1 49 01 28 	st.w	r8[296],r9
	AVR32_GPIO.port[1].gperc = 0x00000003;
80004b20:	f1 49 01 08 	st.w	r8[264],r9

	(&AVR32_TC)->bmr = 4;
80004b24:	fe 78 38 00 	mov	r8,-51200
80004b28:	30 49       	mov	r9,4
80004b2a:	f1 49 00 c4 	st.w	r8[196],r9
	(&AVR32_TC)->channel[0].cmr =
80004b2e:	e0 69 91 0d 	mov	r9,37133
80004b32:	ea 19 00 52 	orh	r9,0x52
80004b36:	91 19       	st.w	r8[0x4],r9
	1                          << AVR32_TC_CLKI_OFFSET     |
	AVR32_TC_TCCLKS_XC0        << AVR32_TC_TCCLKS_OFFSET;



	(&AVR32_TC)->channel[0].ra = 32;
80004b38:	32 09       	mov	r9,32
80004b3a:	91 59       	st.w	r8[0x14],r9
	(&AVR32_TC)->channel[0].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
80004b3c:	30 59       	mov	r9,5
80004b3e:	91 09       	st.w	r8[0x0],r9
}
80004b40:	5e fc       	retal	r12
80004b42:	d7 03       	nop

80004b44 <tc_init>:
 * - fPBA/8 is used as clock source for TC
 * - Enables RC compare match interrupt
 * \param tc Base address of the TC module
 */
void tc_init()
{
80004b44:	d4 01       	pushm	lr

	volatile avr32_tc_t * tc = EXAMPLE_TC;
	
	INTC_register_interrupt(&_tc_interrupt, AVR32_TC_IRQ1, AVR32_INTC_INT2);
80004b46:	30 2a       	mov	r10,2
80004b48:	e0 6b 01 c1 	mov	r11,449
80004b4c:	48 ec       	lddpc	r12,80004b84 <tc_init+0x40>
80004b4e:	f0 1f 00 0f 	mcall	80004b88 <tc_init+0x44>
		.cpas  = 0,
		.lovrs = 0,
		.covfs = 0
	};
	// Initialize the timer/counter.
	tc_init_waveform(tc, &waveform_opt);
80004b52:	48 fb       	lddpc	r11,80004b8c <tc_init+0x48>
80004b54:	fe 7c 38 00 	mov	r12,-51200
80004b58:	f0 1f 00 0e 	mcall	80004b90 <tc_init+0x4c>
	 * We want: (1 / (fPBA / 8)) * RC = 10 ms, hence RC = (fPBA / 8) / 100
	 * to get an interrupt every 10 ms.
	 */
	//tc_write_rc(tc, EXAMPLE_TC_CHANNEL, (sysclk_get_pba_hz() / 8 / 100));
	
	tc_write_rc(tc, EXAMPLE_TC_CHANNEL, ((FOSC0*2) / 8 / 100));
80004b5c:	e0 6a 75 30 	mov	r10,30000
80004b60:	30 1b       	mov	r11,1
80004b62:	fe 7c 38 00 	mov	r12,-51200
80004b66:	f0 1f 00 0c 	mcall	80004b94 <tc_init+0x50>
	
	//tc_write_rc(tc, EXAMPLE_TC_CHANNEL, (FOSC0 / 8 / 100000));
	
	
	// configure the timer interrupt
	tc_configure_interrupts(tc, EXAMPLE_TC_CHANNEL, &tc_interrupt);
80004b6a:	48 ca       	lddpc	r10,80004b98 <tc_init+0x54>
80004b6c:	30 1b       	mov	r11,1
80004b6e:	fe 7c 38 00 	mov	r12,-51200
80004b72:	f0 1f 00 0b 	mcall	80004b9c <tc_init+0x58>
	// Start the timer/counter.
	tc_start(tc, EXAMPLE_TC_CHANNEL);
80004b76:	30 1b       	mov	r11,1
80004b78:	fe 7c 38 00 	mov	r12,-51200
80004b7c:	f0 1f 00 09 	mcall	80004ba0 <tc_init+0x5c>
80004b80:	d8 02       	popm	pc
80004b82:	00 00       	add	r0,r0
80004b84:	80 00       	ld.sh	r0,r0[0x0]
80004b86:	4b a4       	lddpc	r4,80004c6c <INTC_init_interrupts+0x24>
80004b88:	80 00       	ld.sh	r0,r0[0x0]
80004b8a:	4b c8       	lddpc	r8,80004c78 <INTC_init_interrupts+0x30>
80004b8c:	80 00       	ld.sh	r0,r0[0x0]
80004b8e:	d4 28       	*unknown*
80004b90:	80 00       	ld.sh	r0,r0[0x0]
80004b92:	4c d4       	lddpc	r4,80004cc4 <_get_interrupt_handler+0x28>
80004b94:	80 00       	ld.sh	r0,r0[0x0]
80004b96:	4d 94       	lddpc	r4,80004cf8 <tc_init_waveform+0x24>
80004b98:	80 00       	ld.sh	r0,r0[0x0]
80004b9a:	d4 24       	*unknown*
80004b9c:	80 00       	ld.sh	r0,r0[0x0]
80004b9e:	4d c8       	lddpc	r8,80004d0c <tc_init_waveform+0x38>
80004ba0:	80 00       	ld.sh	r0,r0[0x0]
80004ba2:	4d 70       	lddpc	r0,80004cfc <tc_init_waveform+0x28>

80004ba4 <_tc_interrupt>:
volatile U32 tc_tick = 0;

//brief Default interrupt handler.
__attribute__((__interrupt__))
static void _tc_interrupt(void)
 {
80004ba4:	d4 01       	pushm	lr
	// Increment the 10ms seconds counter
	tc_tick++;
80004ba6:	48 68       	lddpc	r8,80004bbc <_tc_interrupt+0x18>
80004ba8:	70 09       	ld.w	r9,r8[0x0]
80004baa:	2f f9       	sub	r9,-1
80004bac:	91 09       	st.w	r8[0x0],r9
	/*
	 * TODO: Place a breakpoint here and watch the update of tc_tick variable
	 * in the Watch Window.
	 */
	// Clear the interrupt flag. This is a side effect of reading the TC SR.
	tc_read_sr(EXAMPLE_TC, EXAMPLE_TC_CHANNEL);
80004bae:	30 1b       	mov	r11,1
80004bb0:	fe 7c 38 00 	mov	r12,-51200
80004bb4:	f0 1f 00 03 	mcall	80004bc0 <_tc_interrupt+0x1c>
	
}
80004bb8:	d4 02       	popm	lr
80004bba:	d6 03       	rete
80004bbc:	00 00       	add	r0,r0
80004bbe:	0b 70       	ld.ub	r0,--r5
80004bc0:	80 00       	ld.sh	r0,r0[0x0]
80004bc2:	4d 82       	lddpc	r2,80004d20 <tc_init_waveform+0x4c>

80004bc4 <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
80004bc4:	c0 08       	rjmp	80004bc4 <_unhandled_interrupt>
80004bc6:	d7 03       	nop

80004bc8 <INTC_register_interrupt>:
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
80004bc8:	f6 08 16 05 	lsr	r8,r11,0x5

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
80004bcc:	49 99       	lddpc	r9,80004c30 <INTC_register_interrupt+0x68>
80004bce:	f2 08 00 39 	add	r9,r9,r8<<0x3
80004bd2:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
80004bd6:	72 19       	ld.w	r9,r9[0x4]
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
80004bd8:	f2 0b 09 2c 	st.w	r9[r11<<0x2],r12
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
80004bdc:	58 0a       	cp.w	r10,0
80004bde:	c0 91       	brne	80004bf0 <INTC_register_interrupt+0x28>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80004be0:	49 59       	lddpc	r9,80004c34 <INTC_register_interrupt+0x6c>
80004be2:	49 6a       	lddpc	r10,80004c38 <INTC_register_interrupt+0x70>
80004be4:	12 1a       	sub	r10,r9
80004be6:	fe 79 08 00 	mov	r9,-63488
80004bea:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80004bee:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT1) {
80004bf0:	58 1a       	cp.w	r10,1
80004bf2:	c0 a1       	brne	80004c06 <INTC_register_interrupt+0x3e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
80004bf4:	49 09       	lddpc	r9,80004c34 <INTC_register_interrupt+0x6c>
80004bf6:	49 2a       	lddpc	r10,80004c3c <INTC_register_interrupt+0x74>
80004bf8:	12 1a       	sub	r10,r9
80004bfa:	bf aa       	sbr	r10,0x1e
80004bfc:	fe 79 08 00 	mov	r9,-63488
80004c00:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80004c04:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT2) {
80004c06:	58 2a       	cp.w	r10,2
80004c08:	c0 a1       	brne	80004c1c <INTC_register_interrupt+0x54>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
80004c0a:	48 b9       	lddpc	r9,80004c34 <INTC_register_interrupt+0x6c>
80004c0c:	48 da       	lddpc	r10,80004c40 <INTC_register_interrupt+0x78>
80004c0e:	12 1a       	sub	r10,r9
80004c10:	bf ba       	sbr	r10,0x1f
80004c12:	fe 79 08 00 	mov	r9,-63488
80004c16:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80004c1a:	5e fc       	retal	r12
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
80004c1c:	48 69       	lddpc	r9,80004c34 <INTC_register_interrupt+0x6c>
80004c1e:	48 aa       	lddpc	r10,80004c44 <INTC_register_interrupt+0x7c>
80004c20:	12 1a       	sub	r10,r9
80004c22:	ea 1a c0 00 	orh	r10,0xc000
80004c26:	fe 79 08 00 	mov	r9,-63488
80004c2a:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80004c2e:	5e fc       	retal	r12
80004c30:	80 00       	ld.sh	r0,r0[0x0]
80004c32:	d4 30       	acall	0x43
80004c34:	80 00       	ld.sh	r0,r0[0x0]
80004c36:	c4 00       	breq	80004cb6 <_get_interrupt_handler+0x1a>
80004c38:	80 00       	ld.sh	r0,r0[0x0]
80004c3a:	c5 04       	brge	80004cda <tc_init_waveform+0x6>
80004c3c:	80 00       	ld.sh	r0,r0[0x0]
80004c3e:	c5 12       	brcc	80004ce0 <tc_init_waveform+0xc>
80004c40:	80 00       	ld.sh	r0,r0[0x0]
80004c42:	c5 20       	breq	80004ce6 <tc_init_waveform+0x12>
80004c44:	80 00       	ld.sh	r0,r0[0x0]
80004c46:	c5 2e       	rcall	800048ea <xnl_device_auth_reply_func+0xa6>

80004c48 <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
80004c48:	d4 21       	pushm	r4-r7,lr
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
80004c4a:	49 18       	lddpc	r8,80004c8c <INTC_init_interrupts+0x44>
80004c4c:	e3 b8 00 01 	mtsr	0x4,r8
80004c50:	49 0e       	lddpc	lr,80004c90 <INTC_init_interrupts+0x48>
80004c52:	30 07       	mov	r7,0
80004c54:	0e 94       	mov	r4,r7
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80004c56:	49 0c       	lddpc	r12,80004c94 <INTC_init_interrupts+0x4c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80004c58:	49 05       	lddpc	r5,80004c98 <INTC_init_interrupts+0x50>
80004c5a:	10 15       	sub	r5,r8
80004c5c:	fe 76 08 00 	mov	r6,-63488
80004c60:	c1 08       	rjmp	80004c80 <INTC_init_interrupts+0x38>
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
80004c62:	08 98       	mov	r8,r4
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
80004c64:	7c 1b       	ld.w	r11,lr[0x4]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80004c66:	7c 0a       	ld.w	r10,lr[0x0]
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80004c68:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
80004c6c:	2f f8       	sub	r8,-1

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80004c6e:	10 3a       	cp.w	r10,r8
80004c70:	fe 9b ff fc 	brhi	80004c68 <INTC_init_interrupts+0x20>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80004c74:	ec 07 09 25 	st.w	r6[r7<<0x2],r5
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
80004c78:	2f f7       	sub	r7,-1
80004c7a:	2f 8e       	sub	lr,-8
80004c7c:	59 37       	cp.w	r7,19
80004c7e:	c0 50       	breq	80004c88 <INTC_init_interrupts+0x40>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80004c80:	7c 08       	ld.w	r8,lr[0x0]
80004c82:	58 08       	cp.w	r8,0
80004c84:	ce f1       	brne	80004c62 <INTC_init_interrupts+0x1a>
80004c86:	cf 7b       	rjmp	80004c74 <INTC_init_interrupts+0x2c>
80004c88:	d8 22       	popm	r4-r7,pc
80004c8a:	00 00       	add	r0,r0
80004c8c:	80 00       	ld.sh	r0,r0[0x0]
80004c8e:	c4 00       	breq	80004d0e <tc_init_waveform+0x3a>
80004c90:	80 00       	ld.sh	r0,r0[0x0]
80004c92:	d4 30       	acall	0x43
80004c94:	80 00       	ld.sh	r0,r0[0x0]
80004c96:	4b c4       	lddpc	r4,80004d84 <tc_read_sr+0x2>
80004c98:	80 00       	ld.sh	r0,r0[0x0]
80004c9a:	c5 04       	brge	80004d3a <tc_init_waveform+0x66>

80004c9c <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
80004c9c:	fe 78 08 00 	mov	r8,-63488
80004ca0:	e0 69 00 83 	mov	r9,131
80004ca4:	f2 0c 01 0c 	sub	r12,r9,r12
80004ca8:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
80004cac:	f2 ca ff c0 	sub	r10,r9,-64
80004cb0:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	
	return (int_req)
80004cb4:	58 08       	cp.w	r8,0
80004cb6:	c0 21       	brne	80004cba <_get_interrupt_handler+0x1e>
80004cb8:	5e fd       	retal	0
		? _int_handler_table[int_grp]._int_line_handler_table[32
80004cba:	f0 08 12 00 	clz	r8,r8
80004cbe:	48 5a       	lddpc	r10,80004cd0 <_get_interrupt_handler+0x34>
80004cc0:	f4 09 00 39 	add	r9,r10,r9<<0x3
80004cc4:	f0 08 11 1f 	rsub	r8,r8,31
80004cc8:	72 19       	ld.w	r9,r9[0x4]
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	
	return (int_req)
80004cca:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
80004cce:	5e fc       	retal	r12
80004cd0:	80 00       	ld.sh	r0,r0[0x0]
80004cd2:	d4 30       	acall	0x43

80004cd4 <tc_init_waveform>:


int tc_init_waveform(volatile avr32_tc_t *tc, const tc_waveform_opt_t *opt)
{
  // Check for valid input.
  if (opt->channel >= TC_NUMBER_OF_CHANNELS)
80004cd4:	76 09       	ld.w	r9,r11[0x0]
80004cd6:	58 29       	cp.w	r9,2
80004cd8:	e0 88 00 03 	brls	80004cde <tc_init_waveform+0xa>
80004cdc:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  // GENERATE SIGNALS: Waveform operating mode.
  tc->channel[opt->channel].cmr = opt->bswtrg << AVR32_TC_BSWTRG_OFFSET |
80004cde:	76 18       	ld.w	r8,r11[0x4]
80004ce0:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
80004ce4:	af ba       	sbr	r10,0xf
80004ce6:	10 9b       	mov	r11,r8
80004ce8:	e6 1b c0 00 	andh	r11,0xc000,COH
80004cec:	16 4a       	or	r10,r11
80004cee:	10 9b       	mov	r11,r8
80004cf0:	e6 1b 30 00 	andh	r11,0x3000,COH
80004cf4:	16 4a       	or	r10,r11
80004cf6:	10 9b       	mov	r11,r8
80004cf8:	e6 1b 0c 00 	andh	r11,0xc00,COH
80004cfc:	16 4a       	or	r10,r11
80004cfe:	10 9b       	mov	r11,r8
80004d00:	e6 1b 03 00 	andh	r11,0x300,COH
80004d04:	16 4a       	or	r10,r11
80004d06:	10 9b       	mov	r11,r8
80004d08:	e6 1b 00 c0 	andh	r11,0xc0,COH
80004d0c:	16 4a       	or	r10,r11
80004d0e:	10 9b       	mov	r11,r8
80004d10:	e6 1b 00 30 	andh	r11,0x30,COH
80004d14:	16 4a       	or	r10,r11
80004d16:	10 9b       	mov	r11,r8
80004d18:	e6 1b 00 0c 	andh	r11,0xc,COH
80004d1c:	16 4a       	or	r10,r11
80004d1e:	10 9b       	mov	r11,r8
80004d20:	e6 1b 00 03 	andh	r11,0x3,COH
80004d24:	16 4a       	or	r10,r11
80004d26:	10 9b       	mov	r11,r8
80004d28:	e2 1b 60 00 	andl	r11,0x6000,COH
80004d2c:	16 4a       	or	r10,r11
80004d2e:	f7 d8 c1 81 	bfextu	r11,r8,0xc,0x1
80004d32:	f5 eb 10 ca 	or	r10,r10,r11<<0xc
80004d36:	10 9b       	mov	r11,r8
80004d38:	e2 1b 0c 00 	andl	r11,0xc00,COH
80004d3c:	16 4a       	or	r10,r11
80004d3e:	10 9b       	mov	r11,r8
80004d40:	e2 1b 03 00 	andl	r11,0x300,COH
80004d44:	16 4a       	or	r10,r11
80004d46:	f7 d8 c0 e1 	bfextu	r11,r8,0x7,0x1
80004d4a:	f5 eb 10 7a 	or	r10,r10,r11<<0x7
80004d4e:	f7 d8 c0 c1 	bfextu	r11,r8,0x6,0x1
80004d52:	f5 eb 10 6a 	or	r10,r10,r11<<0x6
80004d56:	10 9b       	mov	r11,r8
80004d58:	e2 1b 00 30 	andl	r11,0x30,COH
80004d5c:	16 4a       	or	r10,r11
80004d5e:	f1 d8 c0 61 	bfextu	r8,r8,0x3,0x1
80004d62:	f5 e8 10 38 	or	r8,r10,r8<<0x3
80004d66:	a5 69       	lsl	r9,0x4
80004d68:	2f f9       	sub	r9,-1
80004d6a:	f8 09 09 28 	st.w	r12[r9<<0x2],r8
80004d6e:	5e fd       	retal	0

80004d70 <tc_start>:


int tc_start(volatile avr32_tc_t *tc, unsigned int channel)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80004d70:	58 2b       	cp.w	r11,2
80004d72:	e0 88 00 03 	brls	80004d78 <tc_start+0x8>
80004d76:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  // Enable, reset and start the selected timer/counter channel.
  tc->channel[channel].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
80004d78:	a7 6b       	lsl	r11,0x6
80004d7a:	16 0c       	add	r12,r11
80004d7c:	30 58       	mov	r8,5
80004d7e:	99 08       	st.w	r12[0x0],r8
80004d80:	5e fd       	retal	0

80004d82 <tc_read_sr>:


int tc_read_sr(volatile avr32_tc_t *tc, unsigned int channel)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80004d82:	58 2b       	cp.w	r11,2
80004d84:	e0 88 00 03 	brls	80004d8a <tc_read_sr+0x8>
80004d88:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  return tc->channel[channel].sr;
80004d8a:	a7 6b       	lsl	r11,0x6
80004d8c:	2e 0b       	sub	r11,-32
80004d8e:	16 0c       	add	r12,r11
80004d90:	78 0c       	ld.w	r12,r12[0x0]
}
80004d92:	5e fc       	retal	r12

80004d94 <tc_write_rc>:


int tc_write_rc(volatile avr32_tc_t *tc, unsigned int channel, unsigned short value)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80004d94:	58 2b       	cp.w	r11,2
80004d96:	e0 88 00 03 	brls	80004d9c <tc_write_rc+0x8>
80004d9a:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  // This function is only available in WAVEFORM mode.
  if (Tst_bits(tc->channel[channel].cmr, AVR32_TC_WAVE_MASK))
80004d9c:	f6 08 15 04 	lsl	r8,r11,0x4
80004da0:	2f f8       	sub	r8,-1
80004da2:	f8 08 03 28 	ld.w	r8,r12[r8<<0x2]
80004da6:	e2 18 80 00 	andl	r8,0x8000,COH
80004daa:	c0 c0       	breq	80004dc2 <tc_write_rc+0x2e>
    Wr_bitfield(tc->channel[channel].rc, AVR32_TC_RC_MASK, value);
80004dac:	a7 6b       	lsl	r11,0x6
80004dae:	16 0c       	add	r12,r11
80004db0:	2e 4c       	sub	r12,-28
80004db2:	78 08       	ld.w	r8,r12[0x0]
80004db4:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
80004db8:	e0 18 00 00 	andl	r8,0x0
80004dbc:	f3 e8 10 08 	or	r8,r9,r8
80004dc0:	99 08       	st.w	r12[0x0],r8

  return value;
80004dc2:	f9 da c0 10 	bfextu	r12,r10,0x0,0x10
}
80004dc6:	5e fc       	retal	r12

80004dc8 <tc_configure_interrupts>:
  return tc->channel[channel].imr;
}


int tc_configure_interrupts(volatile avr32_tc_t *tc, unsigned int channel, const tc_interrupt_t *bitfield)
{
80004dc8:	eb cd 40 fc 	pushm	r2-r7,lr
  bool global_interrupt_enabled = Is_global_interrupt_enabled();
80004dcc:	e1 b9 00 00 	mfsr	r9,0x0

  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80004dd0:	58 2b       	cp.w	r11,2
80004dd2:	e0 88 00 04 	brls	80004dda <tc_configure_interrupts+0x12>
80004dd6:	e3 cf c0 fc 	ldm	sp++,r2-r7,pc,r12=-1
	return flags;
}

static inline bool cpu_irq_is_enabled_flags(irqflags_t flags)
{
	return !(flags & AVR32_SR_GM_MASK);
80004dda:	ee 19 00 01 	eorh	r9,0x1
80004dde:	f3 d9 c2 01 	bfextu	r9,r9,0x10,0x1
    return TC_INVALID_ARGUMENT;

  // Enable the appropriate interrupts.
  tc->channel[channel].ier = bitfield->etrgs << AVR32_TC_ETRGS_OFFSET |
80004de2:	74 08       	ld.w	r8,r10[0x0]
80004de4:	ef d8 c0 e1 	bfextu	r7,r8,0x7,0x1
80004de8:	fd d8 c0 c1 	bfextu	lr,r8,0x6,0x1
80004dec:	a7 6e       	lsl	lr,0x6
80004dee:	fd e7 10 7e 	or	lr,lr,r7<<0x7
80004df2:	ef d8 c0 01 	bfextu	r7,r8,0x0,0x1
80004df6:	0e 4e       	or	lr,r7
80004df8:	ef d8 c0 a1 	bfextu	r7,r8,0x5,0x1
80004dfc:	fd e7 10 5e 	or	lr,lr,r7<<0x5
80004e00:	ef d8 c0 81 	bfextu	r7,r8,0x4,0x1
80004e04:	fd e7 10 4e 	or	lr,lr,r7<<0x4
80004e08:	ef d8 c0 61 	bfextu	r7,r8,0x3,0x1
80004e0c:	fd e7 10 3e 	or	lr,lr,r7<<0x3
80004e10:	ef d8 c0 41 	bfextu	r7,r8,0x2,0x1
80004e14:	fd e7 10 2e 	or	lr,lr,r7<<0x2
80004e18:	f1 d8 c0 21 	bfextu	r8,r8,0x1,0x1
80004e1c:	fd e8 10 18 	or	r8,lr,r8<<0x1
80004e20:	f6 0e 15 06 	lsl	lr,r11,0x6
80004e24:	f8 0e 00 0e 	add	lr,r12,lr
80004e28:	2d ce       	sub	lr,-36
80004e2a:	9d 08       	st.w	lr[0x0],r8
                             bitfield->cpas << AVR32_TC_CPAS_OFFSET |
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;

  // Disable the appropriate interrupts.
  if (global_interrupt_enabled) Disable_global_interrupt();
80004e2c:	58 09       	cp.w	r9,0
80004e2e:	c0 20       	breq	80004e32 <tc_configure_interrupts+0x6a>
80004e30:	d3 03       	ssrf	0x10
  tc->channel[channel].idr = (~bitfield->etrgs & 1) << AVR32_TC_ETRGS_OFFSET |
80004e32:	74 08       	ld.w	r8,r10[0x0]
80004e34:	f1 d8 c0 e1 	bfextu	r8,r8,0x7,0x1
80004e38:	e0 65 00 80 	mov	r5,128
80004e3c:	f9 b5 01 00 	movne	r5,0
                             (~bitfield->ldrbs & 1) << AVR32_TC_LDRBS_OFFSET |
80004e40:	74 08       	ld.w	r8,r10[0x0]
80004e42:	f1 d8 c0 c1 	bfextu	r8,r8,0x6,0x1
80004e46:	f9 b4 00 40 	moveq	r4,64
80004e4a:	f9 b4 01 00 	movne	r4,0
                             (~bitfield->ldras & 1) << AVR32_TC_LDRAS_OFFSET |
80004e4e:	74 08       	ld.w	r8,r10[0x0]
80004e50:	f1 d8 c0 a1 	bfextu	r8,r8,0x5,0x1
80004e54:	f9 b3 00 20 	moveq	r3,32
80004e58:	f9 b3 01 00 	movne	r3,0
                             (~bitfield->cpcs & 1) << AVR32_TC_CPCS_OFFSET |
80004e5c:	74 08       	ld.w	r8,r10[0x0]
80004e5e:	f1 d8 c0 81 	bfextu	r8,r8,0x4,0x1
80004e62:	f9 b2 00 10 	moveq	r2,16
80004e66:	f9 b2 01 00 	movne	r2,0
                             (~bitfield->cpbs & 1) << AVR32_TC_CPBS_OFFSET |
80004e6a:	74 08       	ld.w	r8,r10[0x0]
80004e6c:	f1 d8 c0 61 	bfextu	r8,r8,0x3,0x1
80004e70:	f9 b6 00 08 	moveq	r6,8
80004e74:	f9 b6 01 00 	movne	r6,0
                             (~bitfield->cpas & 1) << AVR32_TC_CPAS_OFFSET |
80004e78:	74 08       	ld.w	r8,r10[0x0]
80004e7a:	f1 d8 c0 41 	bfextu	r8,r8,0x2,0x1
80004e7e:	f9 b7 00 04 	moveq	r7,4
80004e82:	f9 b7 01 00 	movne	r7,0
                             (~bitfield->lovrs & 1) << AVR32_TC_LOVRS_OFFSET |
80004e86:	74 08       	ld.w	r8,r10[0x0]
80004e88:	f1 d8 c0 21 	bfextu	r8,r8,0x1,0x1
80004e8c:	f9 be 00 02 	moveq	lr,2
80004e90:	f9 be 01 00 	movne	lr,0
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;

  // Disable the appropriate interrupts.
  if (global_interrupt_enabled) Disable_global_interrupt();
  tc->channel[channel].idr = (~bitfield->etrgs & 1) << AVR32_TC_ETRGS_OFFSET |
80004e94:	74 08       	ld.w	r8,r10[0x0]
80004e96:	ec 18 00 01 	eorl	r8,0x1
80004e9a:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80004e9e:	eb e8 10 08 	or	r8,r5,r8
80004ea2:	08 48       	or	r8,r4
80004ea4:	06 48       	or	r8,r3
80004ea6:	04 48       	or	r8,r2
80004ea8:	0c 48       	or	r8,r6
80004eaa:	0e 48       	or	r8,r7
80004eac:	1c 48       	or	r8,lr
80004eae:	f6 0a 15 06 	lsl	r10,r11,0x6
80004eb2:	f8 0a 00 0a 	add	r10,r12,r10
80004eb6:	2d 8a       	sub	r10,-40
80004eb8:	95 08       	st.w	r10[0x0],r8
                             (~bitfield->cpcs & 1) << AVR32_TC_CPCS_OFFSET |
                             (~bitfield->cpbs & 1) << AVR32_TC_CPBS_OFFSET |
                             (~bitfield->cpas & 1) << AVR32_TC_CPAS_OFFSET |
                             (~bitfield->lovrs & 1) << AVR32_TC_LOVRS_OFFSET |
                             (~bitfield->covfs & 1) << AVR32_TC_COVFS_OFFSET;
  tc->channel[channel].sr;
80004eba:	a7 6b       	lsl	r11,0x6
80004ebc:	2e 0b       	sub	r11,-32
80004ebe:	16 0c       	add	r12,r11
80004ec0:	78 08       	ld.w	r8,r12[0x0]
  if (global_interrupt_enabled) Enable_global_interrupt();
80004ec2:	58 09       	cp.w	r9,0
80004ec4:	c0 31       	brne	80004eca <tc_configure_interrupts+0x102>
80004ec6:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0
80004eca:	d5 03       	csrf	0x10
80004ecc:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0

80004ed0 <twi_master_interrupt_handler>:
/*! \brief TWI interrupt handler.
 */
ISR(twi_master_interrupt_handler, CONF_TWI_IRQ_GROUP, CONF_TWI_IRQ_LEVEL)
{
	// get masked status register value
	int status = twi_inst->sr & twi_it_mask;
80004ed0:	4a 78       	lddpc	r8,80004f6c <twi_master_interrupt_handler+0x9c>
80004ed2:	70 08       	ld.w	r8,r8[0x0]
80004ed4:	70 89       	ld.w	r9,r8[0x20]
80004ed6:	4a 7a       	lddpc	r10,80004f70 <twi_master_interrupt_handler+0xa0>
80004ed8:	74 0a       	ld.w	r10,r10[0x0]
80004eda:	f5 e9 00 09 	and	r9,r10,r9

	// this is a NACK
	if (status & AVR32_TWI_SR_NACK_MASK) {
80004ede:	12 9a       	mov	r10,r9
80004ee0:	e2 1a 01 00 	andl	r10,0x100,COH
80004ee4:	c3 91       	brne	80004f56 <twi_master_interrupt_handler+0x86>
		goto nack;
	}
	// this is a RXRDY
	else if (status & AVR32_TWI_SR_RXRDY_MASK) {
80004ee6:	12 9a       	mov	r10,r9
80004ee8:	e2 1a 00 02 	andl	r10,0x2,COH
80004eec:	c1 70       	breq	80004f1a <twi_master_interrupt_handler+0x4a>
		// get data from Receive Holding Register
		*twi_rx_data = twi_inst->rhr;
80004eee:	4a 29       	lddpc	r9,80004f74 <twi_master_interrupt_handler+0xa4>
80004ef0:	72 0a       	ld.w	r10,r9[0x0]
80004ef2:	70 cb       	ld.w	r11,r8[0x30]
80004ef4:	b4 8b       	st.b	r10[0x0],r11
		twi_rx_data++;
80004ef6:	72 0a       	ld.w	r10,r9[0x0]
80004ef8:	2f fa       	sub	r10,-1
80004efa:	93 0a       	st.w	r9[0x0],r10
		// last byte to receive
		if (--twi_rx_nb_bytes == 1) {
80004efc:	49 f9       	lddpc	r9,80004f78 <twi_master_interrupt_handler+0xa8>
80004efe:	72 0a       	ld.w	r10,r9[0x0]
80004f00:	20 1a       	sub	r10,1
80004f02:	93 0a       	st.w	r9[0x0],r10
80004f04:	72 09       	ld.w	r9,r9[0x0]
			// set stop bit
			twi_inst->cr = AVR32_TWI_STOP_MASK;
80004f06:	58 19       	cp.w	r9,1
80004f08:	f9 b9 00 02 	moveq	r9,2
80004f0c:	f1 f9 0a 00 	st.weq	r8[0x0],r9
		}
		// receive complete
		if (twi_rx_nb_bytes == 0) {
80004f10:	49 a9       	lddpc	r9,80004f78 <twi_master_interrupt_handler+0xa8>
80004f12:	72 09       	ld.w	r9,r9[0x0]
80004f14:	58 09       	cp.w	r9,0
80004f16:	c2 30       	breq	80004f5c <twi_master_interrupt_handler+0x8c>
80004f18:	d6 03       	rete
			// finish the receive operation
			goto complete;
		}
	}
	// this is a TXRDY
	else if (status & AVR32_TWI_SR_TXRDY_MASK) {
80004f1a:	12 9a       	mov	r10,r9
80004f1c:	e2 1a 00 04 	andl	r10,0x4,COH
80004f20:	c1 70       	breq	80004f4e <twi_master_interrupt_handler+0x7e>
		// decrease transmitted bytes number
		twi_tx_nb_bytes--;
80004f22:	49 79       	lddpc	r9,80004f7c <twi_master_interrupt_handler+0xac>
80004f24:	72 0a       	ld.w	r10,r9[0x0]
80004f26:	20 1a       	sub	r10,1
80004f28:	93 0a       	st.w	r9[0x0],r10
		// no more bytes to transmit
		if (twi_tx_nb_bytes <= 0) {
80004f2a:	72 09       	ld.w	r9,r9[0x0]
80004f2c:	58 09       	cp.w	r9,0
80004f2e:	e0 89 00 0a 	brgt	80004f42 <twi_master_interrupt_handler+0x72>
			// enable TXCOMP IT and unmask all others IT
			twi_it_mask = AVR32_TWI_IER_TXCOMP_MASK;
80004f32:	49 09       	lddpc	r9,80004f70 <twi_master_interrupt_handler+0xa0>
80004f34:	30 1a       	mov	r10,1
80004f36:	93 0a       	st.w	r9[0x0],r10
			twi_inst->idr = ~0UL;
80004f38:	3f fa       	mov	r10,-1
80004f3a:	91 aa       	st.w	r8[0x28],r10
			twi_inst->ier = twi_it_mask;
80004f3c:	72 09       	ld.w	r9,r9[0x0]
80004f3e:	91 99       	st.w	r8[0x24],r9
80004f40:	d6 03       	rete
		} else {
			// put the byte in the Transmit Holding Register
			twi_inst->thr = *twi_tx_data++;
80004f42:	49 0a       	lddpc	r10,80004f80 <twi_master_interrupt_handler+0xb0>
80004f44:	74 09       	ld.w	r9,r10[0x0]
80004f46:	13 3b       	ld.ub	r11,r9++
80004f48:	91 db       	st.w	r8[0x34],r11
80004f4a:	95 09       	st.w	r10[0x0],r9
80004f4c:	d6 03       	rete
		}
	}
	// this is a TXCOMP
	else if (status & AVR32_TWI_SR_TXCOMP_MASK) {
80004f4e:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
80004f52:	c0 51       	brne	80004f5c <twi_master_interrupt_handler+0x8c>
80004f54:	d6 03       	rete
	}

	return;

nack:
	twi_nack = true;
80004f56:	30 1a       	mov	r10,1
80004f58:	48 b9       	lddpc	r9,80004f84 <twi_master_interrupt_handler+0xb4>
80004f5a:	b2 8a       	st.b	r9[0x0],r10

complete:
	// disable all interrupts
	twi_inst->idr = ~0UL;
80004f5c:	3f f9       	mov	r9,-1
80004f5e:	91 a9       	st.w	r8[0x28],r9
	twi_inst->sr;
80004f60:	70 88       	ld.w	r8,r8[0x20]
	twi_busy = false;
80004f62:	30 09       	mov	r9,0
80004f64:	48 98       	lddpc	r8,80004f88 <twi_master_interrupt_handler+0xb8>
80004f66:	b0 89       	st.b	r8[0x0],r9
80004f68:	d6 03       	rete
80004f6a:	00 00       	add	r0,r0
80004f6c:	00 00       	add	r0,r0
80004f6e:	0c 28       	rsub	r8,r6
80004f70:	00 00       	add	r0,r0
80004f72:	0c 24       	rsub	r4,r6
80004f74:	00 00       	add	r0,r0
80004f76:	0c 34       	cp.w	r4,r6
80004f78:	00 00       	add	r0,r0
80004f7a:	0c 30       	cp.w	r0,r6
80004f7c:	00 00       	add	r0,r0
80004f7e:	0c 20       	rsub	r0,r6
80004f80:	00 00       	add	r0,r0
80004f82:	0c 2c       	rsub	r12,r6
80004f84:	00 00       	add	r0,r0
80004f86:	0c 1d       	sub	sp,r6
80004f88:	00 00       	add	r0,r0
80004f8a:	0c 1c       	sub	r12,r6

80004f8c <twi_master_init>:
	return TWI_SUCCESS;
}


int twi_master_init(volatile avr32_twi_t *twi, const twi_options_t *opt)
{
80004f8c:	eb cd 40 e0 	pushm	r5-r7,lr
80004f90:	18 97       	mov	r7,r12
80004f92:	16 95       	mov	r5,r11
	irqflags_t flags = sysreg_read(AVR32_SR);
80004f94:	e1 b8 00 00 	mfsr	r8,0x0
	int status = TWI_SUCCESS;

	// Set pointer to TWIM instance for IT
	twi_inst = twi;
80004f98:	49 f9       	lddpc	r9,80005014 <twi_master_init+0x88>
80004f9a:	93 0c       	st.w	r9[0x0],r12

	// Disable TWI interrupts
	cpu_irq_disable();
80004f9c:	d3 03       	ssrf	0x10
	twi->idr = ~0UL;
80004f9e:	3f f9       	mov	r9,-1
80004fa0:	99 a9       	st.w	r12[0x28],r9
	twi->sr;
80004fa2:	78 89       	ld.w	r9,r12[0x20]

	// Reset TWI
	twi->cr = AVR32_TWI_CR_SWRST_MASK;
80004fa4:	e0 69 00 80 	mov	r9,128
80004fa8:	99 09       	st.w	r12[0x0],r9
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80004faa:	e6 18 00 01 	andh	r8,0x1,COH
80004fae:	c0 21       	brne	80004fb2 <twi_master_init+0x26>
      cpu_irq_enable();
80004fb0:	d5 03       	csrf	0x10
	cpu_irq_restore(flags);

	// Dummy read in SR
	twi->sr;
80004fb2:	6e 88       	ld.w	r8,r7[0x20]

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80004fb4:	e1 b6 00 00 	mfsr	r6,0x0
	cpu_irq_disable();
80004fb8:	d3 03       	ssrf	0x10
	
	// register Register twim_master_interrupt_handler interrupt
	// on level CONF_TWI_IRQ_LEVEL
	flags = cpu_irq_save();

	irq_register_handler(&twi_master_interrupt_handler, CONF_TWI_IRQ_LINE, CONF_TWI_IRQ_LEVEL);
80004fba:	30 3a       	mov	r10,3
80004fbc:	e0 6b 01 60 	mov	r11,352
80004fc0:	49 6c       	lddpc	r12,80005018 <twi_master_init+0x8c>
80004fc2:	f0 1f 00 17 	mcall	8000501c <twi_master_init+0x90>
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80004fc6:	e6 16 00 01 	andh	r6,0x1,COH
80004fca:	c0 21       	brne	80004fce <twi_master_init+0x42>
      cpu_irq_enable();
80004fcc:	d5 03       	csrf	0x10
		unsigned long pba_hz)
{
	unsigned int ckdiv = 0;
	unsigned int c_lh_div;

	c_lh_div = pba_hz / (speed * 2) - 4;
80004fce:	6a 19       	ld.w	r9,r5[0x4]
80004fd0:	a1 79       	lsl	r9,0x1
80004fd2:	6a 08       	ld.w	r8,r5[0x0]
80004fd4:	f0 09 0d 08 	divu	r8,r8,r9
80004fd8:	20 48       	sub	r8,4

	// cldiv must fit in 8 bits, ckdiv must fit in 3 bits
	while ((c_lh_div > 0xFF) && (ckdiv < 0x7)) {
80004fda:	e0 48 00 ff 	cp.w	r8,255
80004fde:	e0 8b 00 04 	brhi	80004fe6 <twi_master_init+0x5a>
80004fe2:	30 09       	mov	r9,0
80004fe4:	c0 f8       	rjmp	80005002 <twi_master_init+0x76>
80004fe6:	30 09       	mov	r9,0
80004fe8:	30 0c       	mov	r12,0
		// increase clock divider
		ckdiv++;
80004fea:	2f f9       	sub	r9,-1

		// divide cldiv value
		c_lh_div /= 2;
80004fec:	a1 98       	lsr	r8,0x1
	unsigned int c_lh_div;

	c_lh_div = pba_hz / (speed * 2) - 4;

	// cldiv must fit in 8 bits, ckdiv must fit in 3 bits
	while ((c_lh_div > 0xFF) && (ckdiv < 0x7)) {
80004fee:	e0 48 00 ff 	cp.w	r8,255
80004ff2:	5f bb       	srhi	r11
80004ff4:	58 69       	cp.w	r9,6
80004ff6:	5f 8a       	srls	r10
80004ff8:	f7 ea 00 0a 	and	r10,r11,r10
80004ffc:	f8 0a 18 00 	cp.b	r10,r12
80005000:	cf 51       	brne	80004fea <twi_master_init+0x5e>
		// divide cldiv value
		c_lh_div /= 2;
	}

	// set clock waveform generator register
	twi->cwgr = ((c_lh_div << AVR32_TWI_CWGR_CLDIV_OFFSET) |
80005002:	b1 69       	lsl	r9,0x10
80005004:	f3 e8 10 89 	or	r9,r9,r8<<0x8
80005008:	f3 e8 10 08 	or	r8,r9,r8
8000500c:	8f 48       	st.w	r7[0x10],r8

	//Probe the component
	//status = twi_probe(twi, opt->chip);

	return status;
}
8000500e:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
80005012:	00 00       	add	r0,r0
80005014:	00 00       	add	r0,r0
80005016:	0c 28       	rsub	r8,r6
80005018:	80 00       	ld.sh	r0,r0[0x0]
8000501a:	4e d0       	lddpc	r0,800051cc <usart_init_rs232+0x70>
8000501c:	80 00       	ld.sh	r0,r0[0x0]
8000501e:	4b c8       	lddpc	r8,8000510c <usart_write_line>

80005020 <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
80005020:	d4 01       	pushm	lr
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
80005022:	f6 08 15 04 	lsl	r8,r11,0x4
80005026:	14 38       	cp.w	r8,r10
80005028:	f9 b8 08 10 	movls	r8,16
8000502c:	f9 b8 0b 08 	movhi	r8,8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
80005030:	f0 0b 02 4b 	mul	r11,r8,r11
80005034:	f6 09 16 01 	lsr	r9,r11,0x1
80005038:	f2 0a 00 3a 	add	r10,r9,r10<<0x3
8000503c:	f4 0b 0d 0a 	divu	r10,r10,r11
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
80005040:	f4 09 16 03 	lsr	r9,r10,0x3
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
80005044:	f2 cb 00 01 	sub	r11,r9,1
80005048:	e0 4b ff fe 	cp.w	r11,65534
8000504c:	e0 88 00 03 	brls	80005052 <usart_set_async_baudrate+0x32>
80005050:	da 0a       	popm	pc,r12=1
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
80005052:	78 1b       	ld.w	r11,r12[0x4]
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
80005054:	e8 6e 00 00 	mov	lr,524288
80005058:	59 08       	cp.w	r8,16
8000505a:	fc 08 17 10 	movne	r8,lr
8000505e:	f9 b8 00 00 	moveq	r8,0
80005062:	e4 1b ff f7 	andh	r11,0xfff7
80005066:	e0 1b fe cf 	andl	r11,0xfecf
8000506a:	16 48       	or	r8,r11
8000506c:	99 18       	st.w	r12[0x4],r8
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
8000506e:	f5 da c0 03 	bfextu	r10,r10,0x0,0x3
80005072:	f3 ea 11 09 	or	r9,r9,r10<<0x10
80005076:	99 89       	st.w	r12[0x20],r9
80005078:	d8 0a       	popm	pc,r12=0

8000507a <usart_write_char>:
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
8000507a:	78 58       	ld.w	r8,r12[0x14]
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
  if (usart_tx_ready(usart))
8000507c:	e2 18 00 02 	andl	r8,0x2,COH
80005080:	c0 31       	brne	80005086 <usart_write_char+0xc>
80005082:	30 2c       	mov	r12,2
80005084:	5e fc       	retal	r12
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
80005086:	f7 db c0 09 	bfextu	r11,r11,0x0,0x9
8000508a:	99 7b       	st.w	r12[0x1c],r11
8000508c:	5e fd       	retal	0
8000508e:	d7 03       	nop

80005090 <usart_putchar>:
    return USART_TX_BUSY;
}


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
80005090:	eb cd 40 e0 	pushm	r5-r7,lr
80005094:	18 96       	mov	r6,r12
80005096:	16 95       	mov	r5,r11
80005098:	e0 67 27 0f 	mov	r7,9999
8000509c:	c0 68       	rjmp	800050a8 <usart_putchar+0x18>
  int timeout = USART_DEFAULT_TIMEOUT;

  do
  {
    if (!timeout--) return USART_FAILURE;
8000509e:	58 07       	cp.w	r7,0
800050a0:	c0 31       	brne	800050a6 <usart_putchar+0x16>
800050a2:	e3 cf c0 e0 	ldm	sp++,r5-r7,pc,r12=-1
800050a6:	20 17       	sub	r7,1
  } while (usart_write_char(usart, c) != USART_SUCCESS);
800050a8:	0a 9b       	mov	r11,r5
800050aa:	0c 9c       	mov	r12,r6
800050ac:	f0 1f 00 03 	mcall	800050b8 <usart_putchar+0x28>
800050b0:	cf 71       	brne	8000509e <usart_putchar+0xe>

  return USART_SUCCESS;
}
800050b2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800050b6:	00 00       	add	r0,r0
800050b8:	80 00       	ld.sh	r0,r0[0x0]
800050ba:	50 7a       	stdsp	sp[0x1c],r10

800050bc <usart_read_char>:

int usart_read_char(volatile avr32_usart_t *usart, int *c)
{
  // Check for errors: frame, parity and overrun. In RS485 mode, a parity error
  // would mean that an address char has been received.
  if (usart->csr & (AVR32_USART_CSR_OVRE_MASK |
800050bc:	78 58       	ld.w	r8,r12[0x14]
800050be:	e2 18 00 e0 	andl	r8,0xe0,COH
800050c2:	c0 30       	breq	800050c8 <usart_read_char+0xc>
800050c4:	30 4c       	mov	r12,4
800050c6:	5e fc       	retal	r12
 *
 * \return \c 1 if the USART Receive Holding Register is full, otherwise \c 0.
 */
__always_inline static int usart_test_hit(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_RXRDY_MASK) != 0;
800050c8:	78 58       	ld.w	r8,r12[0x14]
                    AVR32_USART_CSR_FRAME_MASK |
                    AVR32_USART_CSR_PARE_MASK))
    return USART_RX_ERROR;

  // No error; if we really did receive a char, read it and return SUCCESS.
  if (usart_test_hit(usart))
800050ca:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800050ce:	c0 31       	brne	800050d4 <usart_read_char+0x18>
800050d0:	30 3c       	mov	r12,3
800050d2:	5e fc       	retal	r12
  {
    *c = (usart->rhr & AVR32_USART_RHR_RXCHR_MASK) >> AVR32_USART_RHR_RXCHR_OFFSET;
800050d4:	78 68       	ld.w	r8,r12[0x18]
800050d6:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
800050da:	97 08       	st.w	r11[0x0],r8
800050dc:	5e fd       	retal	0
800050de:	d7 03       	nop

800050e0 <usart_getchar>:
    return USART_RX_EMPTY;
}


int usart_getchar(volatile avr32_usart_t *usart)
{
800050e0:	eb cd 40 c0 	pushm	r6-r7,lr
800050e4:	20 1d       	sub	sp,4
800050e6:	18 96       	mov	r6,r12
  int c, ret;

  while ((ret = usart_read_char(usart, &c)) == USART_RX_EMPTY);
800050e8:	1a 97       	mov	r7,sp
800050ea:	1a 9b       	mov	r11,sp
800050ec:	0c 9c       	mov	r12,r6
800050ee:	f0 1f 00 07 	mcall	80005108 <usart_getchar+0x28>
800050f2:	58 3c       	cp.w	r12,3
800050f4:	cf b0       	breq	800050ea <usart_getchar+0xa>

  if (ret == USART_RX_ERROR)
800050f6:	58 4c       	cp.w	r12,4
800050f8:	f9 bc 00 ff 	moveq	r12,-1
    return USART_FAILURE;

  return c;
800050fc:	fb fc 10 00 	ld.wne	r12,sp[0x0]
}
80005100:	2f fd       	sub	sp,-4
80005102:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005106:	00 00       	add	r0,r0
80005108:	80 00       	ld.sh	r0,r0[0x0]
8000510a:	50 bc       	stdsp	sp[0x2c],r12

8000510c <usart_write_line>:


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
8000510c:	eb cd 40 c0 	pushm	r6-r7,lr
80005110:	18 96       	mov	r6,r12
80005112:	16 97       	mov	r7,r11
  while (*string != '\0')
80005114:	17 8b       	ld.ub	r11,r11[0x0]
80005116:	58 0b       	cp.w	r11,0
80005118:	c0 80       	breq	80005128 <usart_write_line+0x1c>
    usart_putchar(usart, *string++);
8000511a:	2f f7       	sub	r7,-1
8000511c:	0c 9c       	mov	r12,r6
8000511e:	f0 1f 00 04 	mcall	8000512c <usart_write_line+0x20>
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
80005122:	0f 8b       	ld.ub	r11,r7[0x0]
80005124:	58 0b       	cp.w	r11,0
80005126:	cf a1       	brne	8000511a <usart_write_line+0xe>
80005128:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000512c:	80 00       	ld.sh	r0,r0[0x0]
8000512e:	50 90       	stdsp	sp[0x24],r0

80005130 <usart_reset>:
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
80005130:	e1 b8 00 00 	mfsr	r8,0x0

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
80005134:	e6 18 00 01 	andh	r8,0x1,COH
80005138:	c0 71       	brne	80005146 <usart_reset+0x16>
8000513a:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
8000513c:	3f f8       	mov	r8,-1
8000513e:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80005140:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
80005142:	d5 03       	csrf	0x10
80005144:	c0 48       	rjmp	8000514c <usart_reset+0x1c>
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
  usart->idr = 0xFFFFFFFF;
80005146:	3f f8       	mov	r8,-1
80005148:	99 38       	st.w	r12[0xc],r8
  usart->csr;
8000514a:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
8000514c:	30 08       	mov	r8,0
8000514e:	99 18       	st.w	r12[0x4],r8
  usart->rtor = 0;
80005150:	99 98       	st.w	r12[0x24],r8
  usart->ttgr = 0;
80005152:	99 a8       	st.w	r12[0x28],r8

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
80005154:	ea 68 61 0c 	mov	r8,680204
80005158:	99 08       	st.w	r12[0x0],r8
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
8000515a:	5e fc       	retal	r12

8000515c <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
8000515c:	eb cd 40 e0 	pushm	r5-r7,lr
80005160:	18 96       	mov	r6,r12
80005162:	16 97       	mov	r7,r11
80005164:	14 95       	mov	r5,r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
80005166:	f0 1f 00 2f 	mcall	80005220 <usart_init_rs232+0xc4>

  // Check input values.
  if (!opt || // Null pointer.
8000516a:	58 07       	cp.w	r7,0
8000516c:	c5 80       	breq	8000521c <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
8000516e:	0f c8       	ld.ub	r8,r7[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80005170:	30 49       	mov	r9,4
80005172:	f2 08 18 00 	cp.b	r8,r9
80005176:	e0 88 00 53 	brls	8000521c <usart_init_rs232+0xc0>
8000517a:	30 99       	mov	r9,9
8000517c:	f2 08 18 00 	cp.b	r8,r9
80005180:	e0 8b 00 4e 	brhi	8000521c <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
80005184:	0f d9       	ld.ub	r9,r7[0x5]
80005186:	30 78       	mov	r8,7
80005188:	f0 09 18 00 	cp.b	r9,r8
8000518c:	e0 8b 00 48 	brhi	8000521c <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
80005190:	8e 39       	ld.sh	r9,r7[0x6]
80005192:	e0 68 01 01 	mov	r8,257
80005196:	f0 09 19 00 	cp.h	r9,r8
8000519a:	e0 8b 00 41 	brhi	8000521c <usart_init_rs232+0xc0>
      opt->channelmode > 3 ||
8000519e:	ef 39 00 08 	ld.ub	r9,r7[8]
800051a2:	30 38       	mov	r8,3
800051a4:	f0 09 18 00 	cp.b	r9,r8
800051a8:	e0 8b 00 3a 	brhi	8000521c <usart_init_rs232+0xc0>
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
800051ac:	0a 9a       	mov	r10,r5
800051ae:	6e 0b       	ld.w	r11,r7[0x0]
800051b0:	0c 9c       	mov	r12,r6
800051b2:	f0 1f 00 1d 	mcall	80005224 <usart_init_rs232+0xc8>
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
800051b6:	58 1c       	cp.w	r12,1
800051b8:	c3 20       	breq	8000521c <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;

  if (opt->charlength == 9)
800051ba:	0f c8       	ld.ub	r8,r7[0x4]
800051bc:	30 99       	mov	r9,9
800051be:	f2 08 18 00 	cp.b	r8,r9
800051c2:	c0 51       	brne	800051cc <usart_init_rs232+0x70>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
800051c4:	6c 18       	ld.w	r8,r6[0x4]
800051c6:	b1 b8       	sbr	r8,0x11
800051c8:	8d 18       	st.w	r6[0x4],r8
800051ca:	c0 68       	rjmp	800051d6 <usart_init_rs232+0x7a>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
800051cc:	6c 19       	ld.w	r9,r6[0x4]
800051ce:	20 58       	sub	r8,5
800051d0:	f3 e8 10 68 	or	r8,r9,r8<<0x6
800051d4:	8d 18       	st.w	r6[0x4],r8
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
800051d6:	6c 19       	ld.w	r9,r6[0x4]
800051d8:	ef 3a 00 08 	ld.ub	r10,r7[8]
800051dc:	0f d8       	ld.ub	r8,r7[0x5]
800051de:	a9 78       	lsl	r8,0x9
800051e0:	f1 ea 10 e8 	or	r8,r8,r10<<0xe
800051e4:	12 48       	or	r8,r9
800051e6:	8d 18       	st.w	r6[0x4],r8
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
800051e8:	8e 38       	ld.sh	r8,r7[0x6]
800051ea:	30 29       	mov	r9,2
800051ec:	f2 08 19 00 	cp.h	r8,r9
800051f0:	e0 88 00 09 	brls	80005202 <usart_init_rs232+0xa6>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
800051f4:	6c 18       	ld.w	r8,r6[0x4]
800051f6:	ad b8       	sbr	r8,0xd
800051f8:	8d 18       	st.w	r6[0x4],r8
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
800051fa:	8e b8       	ld.uh	r8,r7[0x6]
800051fc:	20 28       	sub	r8,2
800051fe:	8d a8       	st.w	r6[0x28],r8
80005200:	c0 68       	rjmp	8000520c <usart_init_rs232+0xb0>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
80005202:	6c 19       	ld.w	r9,r6[0x4]
80005204:	5c 78       	castu.h	r8
80005206:	f3 e8 10 c8 	or	r8,r9,r8<<0xc
8000520a:	8d 18       	st.w	r6[0x4],r8

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
8000520c:	6c 18       	ld.w	r8,r6[0x4]
8000520e:	e0 18 ff f0 	andl	r8,0xfff0
80005212:	8d 18       	st.w	r6[0x4],r8
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
80005214:	35 08       	mov	r8,80
80005216:	8d 08       	st.w	r6[0x0],r8
80005218:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
8000521c:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
80005220:	80 00       	ld.sh	r0,r0[0x0]
80005222:	51 30       	stdsp	sp[0x4c],r0
80005224:	80 00       	ld.sh	r0,r0[0x0]
80005226:	50 20       	stdsp	sp[0x8],r0

80005228 <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
80005228:	f8 c8 ff f8 	sub	r8,r12,-8
8000522c:	99 18       	st.w	r12[0x4],r8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
8000522e:	3f f9       	mov	r9,-1
80005230:	99 29       	st.w	r12[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
80005232:	99 38       	st.w	r12[0xc],r8
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
80005234:	99 48       	st.w	r12[0x10],r8

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
80005236:	30 08       	mov	r8,0
80005238:	99 08       	st.w	r12[0x0],r8
}
8000523a:	5e fc       	retal	r12

8000523c <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
8000523c:	30 08       	mov	r8,0
8000523e:	99 48       	st.w	r12[0x10],r8
}
80005240:	5e fc       	retal	r12

80005242 <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
80005242:	78 18       	ld.w	r8,r12[0x4]

	pxNewListItem->pxNext = pxIndex->pxNext;
80005244:	70 19       	ld.w	r9,r8[0x4]
80005246:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
80005248:	78 19       	ld.w	r9,r12[0x4]
8000524a:	97 29       	st.w	r11[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
8000524c:	70 19       	ld.w	r9,r8[0x4]
8000524e:	93 2b       	st.w	r9[0x8],r11
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
80005250:	91 1b       	st.w	r8[0x4],r11
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
80005252:	99 1b       	st.w	r12[0x4],r11

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80005254:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80005256:	78 08       	ld.w	r8,r12[0x0]
80005258:	2f f8       	sub	r8,-1
8000525a:	99 08       	st.w	r12[0x0],r8
}
8000525c:	5e fc       	retal	r12

8000525e <vListInsert>:
{
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
8000525e:	76 0a       	ld.w	r10,r11[0x0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
80005260:	5b fa       	cp.w	r10,-1
80005262:	c0 31       	brne	80005268 <vListInsert+0xa>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
80005264:	78 48       	ld.w	r8,r12[0x10]
80005266:	c0 c8       	rjmp	8000527e <vListInsert+0x20>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
80005268:	f8 c8 ff f8 	sub	r8,r12,-8
8000526c:	70 19       	ld.w	r9,r8[0x4]
8000526e:	72 09       	ld.w	r9,r9[0x0]
80005270:	12 3a       	cp.w	r10,r9
80005272:	c0 63       	brcs	8000527e <vListInsert+0x20>
80005274:	70 18       	ld.w	r8,r8[0x4]
80005276:	70 19       	ld.w	r9,r8[0x4]
80005278:	72 09       	ld.w	r9,r9[0x0]
8000527a:	12 3a       	cp.w	r10,r9
8000527c:	cf c2       	brcc	80005274 <vListInsert+0x16>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
8000527e:	70 19       	ld.w	r9,r8[0x4]
80005280:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80005282:	93 2b       	st.w	r9[0x8],r11
	pxNewListItem->pxPrevious = pxIterator;
80005284:	97 28       	st.w	r11[0x8],r8
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
80005286:	91 1b       	st.w	r8[0x4],r11

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80005288:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
8000528a:	78 08       	ld.w	r8,r12[0x0]
8000528c:	2f f8       	sub	r8,-1
8000528e:	99 08       	st.w	r12[0x0],r8
}
80005290:	5e fc       	retal	r12

80005292 <vListRemove>:

void vListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
80005292:	78 18       	ld.w	r8,r12[0x4]
80005294:	78 29       	ld.w	r9,r12[0x8]
80005296:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
80005298:	78 28       	ld.w	r8,r12[0x8]
8000529a:	78 19       	ld.w	r9,r12[0x4]
8000529c:	91 19       	st.w	r8[0x4],r9

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
8000529e:	78 48       	ld.w	r8,r12[0x10]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
800052a0:	70 19       	ld.w	r9,r8[0x4]
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
800052a2:	18 39       	cp.w	r9,r12
800052a4:	f9 f9 00 02 	ld.weq	r9,r12[0x8]
800052a8:	f1 f9 0a 01 	st.weq	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
800052ac:	30 09       	mov	r9,0
800052ae:	99 49       	st.w	r12[0x10],r9
	( pxList->uxNumberOfItems )--;
800052b0:	70 09       	ld.w	r9,r8[0x0]
800052b2:	20 19       	sub	r9,1
800052b4:	91 09       	st.w	r8[0x0],r9
}
800052b6:	5e fc       	retal	r12

800052b8 <pxPortInitialiseStack>:
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x08080808;					/* R8 */
800052b8:	e0 68 08 08 	mov	r8,2056
800052bc:	ea 18 08 08 	orh	r8,0x808
800052c0:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x09090909;					/* R9 */
800052c2:	e0 68 09 09 	mov	r8,2313
800052c6:	ea 18 09 09 	orh	r8,0x909
800052ca:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0A0A0A0A;					/* R10 */
800052cc:	e0 68 0a 0a 	mov	r8,2570
800052d0:	ea 18 0a 0a 	orh	r8,0xa0a
800052d4:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0B0B0B0B;					/* R11 */
800052d6:	e0 68 0b 0b 	mov	r8,2827
800052da:	ea 18 0b 0b 	orh	r8,0xb0b
800052de:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pvParameters;					/* R12 */
800052e0:	18 da       	st.w	--r12,r10
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xDEADBEEF;					/* R14/LR */
800052e2:	e0 68 be ef 	mov	r8,48879
800052e6:	ea 18 de ad 	orh	r8,0xdead
800052ea:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
800052ec:	18 db       	st.w	--r12,r11
	*pxTopOfStack-- = ( portSTACK_TYPE ) portINITIAL_SR;				/* SR */
800052ee:	fc 18 00 40 	movh	r8,0x40
800052f2:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xFF0000FF;					/* R0 */
800052f4:	e0 68 00 ff 	mov	r8,255
800052f8:	ea 18 ff 00 	orh	r8,0xff00
800052fc:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x01010101;					/* R1 */
800052fe:	e0 68 01 01 	mov	r8,257
80005302:	ea 18 01 01 	orh	r8,0x101
80005306:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x02020202;					/* R2 */
80005308:	e0 68 02 02 	mov	r8,514
8000530c:	ea 18 02 02 	orh	r8,0x202
80005310:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x03030303;					/* R3 */
80005312:	e0 68 03 03 	mov	r8,771
80005316:	ea 18 03 03 	orh	r8,0x303
8000531a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x04040404;					/* R4 */
8000531c:	e0 68 04 04 	mov	r8,1028
80005320:	ea 18 04 04 	orh	r8,0x404
80005324:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x05050505;					/* R5 */
80005326:	e0 68 05 05 	mov	r8,1285
8000532a:	ea 18 05 05 	orh	r8,0x505
8000532e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x06060606;					/* R6 */
80005330:	e0 68 06 06 	mov	r8,1542
80005334:	ea 18 06 06 	orh	r8,0x606
80005338:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x07070707;					/* R7 */
8000533a:	e0 68 07 07 	mov	r8,1799
8000533e:	ea 18 07 07 	orh	r8,0x707
80005342:	18 d8       	st.w	--r12,r8
	*pxTopOfStack = ( portSTACK_TYPE ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
80005344:	30 08       	mov	r8,0
80005346:	18 d8       	st.w	--r12,r8

	return pxTopOfStack;
}
80005348:	5e fc       	retal	r12
8000534a:	d7 03       	nop

8000534c <vPortEnterCritical>:
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
8000534c:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
8000534e:	48 38       	lddpc	r8,80005358 <vPortEnterCritical+0xc>
80005350:	70 09       	ld.w	r9,r8[0x0]
80005352:	2f f9       	sub	r9,-1
80005354:	91 09       	st.w	r8[0x0],r9
}
80005356:	5e fc       	retal	r12
80005358:	00 00       	add	r0,r0
8000535a:	05 30       	ld.ub	r0,r2++

8000535c <xPortStartScheduler>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
8000535c:	d4 01       	pushm	lr
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
8000535e:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
80005360:	30 0a       	mov	r10,0
80005362:	14 9b       	mov	r11,r10
80005364:	49 2c       	lddpc	r12,800053ac <xPortStartScheduler+0x50>
80005366:	f0 1f 00 13 	mcall	800053b0 <xPortStartScheduler+0x54>
/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);//cause!!!
8000536a:	e0 68 5d c0 	mov	r8,24000
8000536e:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
80005372:	30 08       	mov	r8,0
80005374:	e3 b8 00 42 	mtsr	0x108,r8
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Start the first task. */
	portRESTORE_CONTEXT();
80005378:	e0 68 0d 08 	mov	r8,3336
8000537c:	ea 18 00 00 	orh	r8,0x0
80005380:	70 00       	ld.w	r0,r8[0x0]
80005382:	60 0d       	ld.w	sp,r0[0x0]
80005384:	1b 00       	ld.w	r0,sp++
80005386:	e0 68 05 30 	mov	r8,1328
8000538a:	ea 18 00 00 	orh	r8,0x0
8000538e:	91 00       	st.w	r8[0x0],r0
80005390:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005394:	2f ed       	sub	sp,-8
80005396:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
8000539a:	fa f0 ff e0 	ld.w	r0,sp[-32]
8000539e:	e3 b0 00 00 	mtsr	0x0,r0
800053a2:	fa f0 ff dc 	ld.w	r0,sp[-36]
800053a6:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
}
800053aa:	d8 0a       	popm	pc,r12=0
800053ac:	80 00       	ld.sh	r0,r0[0x0]
800053ae:	54 78       	stdsp	sp[0x11c],r8
800053b0:	80 00       	ld.sh	r0,r0[0x0]
800053b2:	4b c8       	lddpc	r8,800054a0 <LABEL_INT_SKIP_SAVE_CONTEXT_237>

800053b4 <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
800053b4:	20 6d       	sub	sp,24
800053b6:	eb cd 00 ff 	pushm	r0-r7
800053ba:	fa c7 ff c0 	sub	r7,sp,-64
800053be:	ee f0 ff f8 	ld.w	r0,r7[-8]
800053c2:	ef 40 ff e0 	st.w	r7[-32],r0
800053c6:	ee f0 ff fc 	ld.w	r0,r7[-4]
800053ca:	ef 40 ff e4 	st.w	r7[-28],r0
800053ce:	eb c7 5f 00 	stm	--r7,r8-r12,lr
800053d2:	e0 68 05 30 	mov	r8,1328
800053d6:	ea 18 00 00 	orh	r8,0x0
800053da:	70 00       	ld.w	r0,r8[0x0]
800053dc:	1a d0       	st.w	--sp,r0
800053de:	f0 1f 00 1a 	mcall	80005444 <LABEL_RET_SCALL_263+0x14>
800053e2:	e0 68 0d 08 	mov	r8,3336
800053e6:	ea 18 00 00 	orh	r8,0x0
800053ea:	70 00       	ld.w	r0,r8[0x0]
800053ec:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
800053ee:	f0 1f 00 17 	mcall	80005448 <LABEL_RET_SCALL_263+0x18>
	portRESTORE_CONTEXT_SCALL();
800053f2:	e0 68 0d 08 	mov	r8,3336
800053f6:	ea 18 00 00 	orh	r8,0x0
800053fa:	70 00       	ld.w	r0,r8[0x0]
800053fc:	60 0d       	ld.w	sp,r0[0x0]
800053fe:	1b 00       	ld.w	r0,sp++
80005400:	e0 68 05 30 	mov	r8,1328
80005404:	ea 18 00 00 	orh	r8,0x0
80005408:	91 00       	st.w	r8[0x0],r0
8000540a:	fa c7 ff d8 	sub	r7,sp,-40
8000540e:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
80005412:	ee f0 ff e0 	ld.w	r0,r7[-32]
80005416:	e0 61 05 30 	mov	r1,1328
8000541a:	ea 11 00 00 	orh	r1,0x0
8000541e:	62 02       	ld.w	r2,r1[0x0]
80005420:	58 02       	cp.w	r2,0
80005422:	c0 70       	breq	80005430 <LABEL_RET_SCALL_263>
80005424:	e4 c2 00 01 	sub	r2,r2,1
80005428:	83 02       	st.w	r1[0x0],r2
8000542a:	58 02       	cp.w	r2,0
8000542c:	c0 21       	brne	80005430 <LABEL_RET_SCALL_263>
8000542e:	b1 c0       	cbr	r0,0x10

80005430 <LABEL_RET_SCALL_263>:
80005430:	ef 40 ff f8 	st.w	r7[-8],r0
80005434:	ee f0 ff e4 	ld.w	r0,r7[-28]
80005438:	ef 40 ff fc 	st.w	r7[-4],r0
8000543c:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005440:	2f ad       	sub	sp,-24
80005442:	d6 13       	rets
80005444:	80 00       	ld.sh	r0,r0[0x0]
80005446:	53 4c       	stdsp	sp[0xd0],r12
80005448:	80 00       	ld.sh	r0,r0[0x0]
8000544a:	5a e8       	cp.w	r8,-18

8000544c <prvClearCcInt>:
		Set_system_register(AVR32_COUNT, 0);
	}

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
8000544c:	e1 b8 00 43 	mfsr	r8,0x10c
80005450:	e3 b8 00 43 	mtsr	0x10c,r8
	}
80005454:	5e fc       	retal	r12
80005456:	d7 03       	nop

80005458 <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
80005458:	48 78       	lddpc	r8,80005474 <vPortExitCritical+0x1c>
8000545a:	70 08       	ld.w	r8,r8[0x0]
8000545c:	58 08       	cp.w	r8,0
8000545e:	5e 0c       	reteq	r12
	{
		ulCriticalNesting--;
80005460:	48 58       	lddpc	r8,80005474 <vPortExitCritical+0x1c>
80005462:	70 09       	ld.w	r9,r8[0x0]
80005464:	20 19       	sub	r9,1
80005466:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
80005468:	70 08       	ld.w	r8,r8[0x0]
8000546a:	58 08       	cp.w	r8,0
8000546c:	5e 1c       	retne	r12
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
8000546e:	d5 03       	csrf	0x10
80005470:	5e fc       	retal	r12
80005472:	00 00       	add	r0,r0
80005474:	00 00       	add	r0,r0
80005476:	05 30       	ld.ub	r0,r2++

80005478 <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
80005478:	eb cd 00 ff 	pushm	r0-r7
8000547c:	e0 68 05 30 	mov	r8,1328
80005480:	ea 18 00 00 	orh	r8,0x0
80005484:	70 00       	ld.w	r0,r8[0x0]
80005486:	1a d0       	st.w	--sp,r0
80005488:	7a 90       	ld.w	r0,sp[0x24]
8000548a:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
8000548e:	58 10       	cp.w	r0,1
80005490:	e0 8b 00 08 	brhi	800054a0 <LABEL_INT_SKIP_SAVE_CONTEXT_237>
80005494:	e0 68 0d 08 	mov	r8,3336
80005498:	ea 18 00 00 	orh	r8,0x0
8000549c:	70 00       	ld.w	r0,r8[0x0]
8000549e:	81 0d       	st.w	r0[0x0],sp

800054a0 <LABEL_INT_SKIP_SAVE_CONTEXT_237>:
	#if( configTICK_USE_TC==1 )
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Clear the interrupt flag. */
		prvClearCcInt();
800054a0:	f0 1f 00 12 	mcall	800054e8 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
800054a4:	f0 1f 00 12 	mcall	800054ec <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
		vTaskIncrementTick();
800054a8:	f0 1f 00 12 	mcall	800054f0 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x1c>
	portEXIT_CRITICAL();
800054ac:	f0 1f 00 12 	mcall	800054f4 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
800054b0:	7a 90       	ld.w	r0,sp[0x24]
800054b2:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
800054b6:	58 10       	cp.w	r0,1
800054b8:	e0 8b 00 0e 	brhi	800054d4 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>
800054bc:	f0 1f 00 0c 	mcall	800054ec <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
800054c0:	f0 1f 00 0e 	mcall	800054f8 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x24>
800054c4:	f0 1f 00 0c 	mcall	800054f4 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>
800054c8:	e0 68 0d 08 	mov	r8,3336
800054cc:	ea 18 00 00 	orh	r8,0x0
800054d0:	70 00       	ld.w	r0,r8[0x0]
800054d2:	60 0d       	ld.w	sp,r0[0x0]

800054d4 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>:
800054d4:	1b 00       	ld.w	r0,sp++
800054d6:	e0 68 05 30 	mov	r8,1328
800054da:	ea 18 00 00 	orh	r8,0x0
800054de:	91 00       	st.w	r8[0x0],r0
800054e0:	e3 cd 00 ff 	ldm	sp++,r0-r7
800054e4:	d6 03       	rete
800054e6:	00 00       	add	r0,r0
800054e8:	80 00       	ld.sh	r0,r0[0x0]
800054ea:	54 4c       	stdsp	sp[0x110],r12
800054ec:	80 00       	ld.sh	r0,r0[0x0]
800054ee:	53 4c       	stdsp	sp[0xd0],r12
800054f0:	80 00       	ld.sh	r0,r0[0x0]
800054f2:	5c ec       	tnbz	r12
800054f4:	80 00       	ld.sh	r0,r0[0x0]
800054f6:	54 58       	stdsp	sp[0x114],r8
800054f8:	80 00       	ld.sh	r0,r0[0x0]
800054fa:	5a e8       	cp.w	r8,-18

800054fc <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
800054fc:	d4 01       	pushm	lr
	vTaskSuspendAll();
800054fe:	f0 1f 00 02 	mcall	80005504 <__malloc_lock+0x8>
}
80005502:	d8 02       	popm	pc
80005504:	80 00       	ld.sh	r0,r0[0x0]
80005506:	5a d8       	cp.w	r8,-19

80005508 <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
80005508:	d4 01       	pushm	lr
	xTaskResumeAll();
8000550a:	f0 1f 00 02 	mcall	80005510 <__malloc_unlock+0x8>
}
8000550e:	d8 02       	popm	pc
80005510:	80 00       	ld.sh	r0,r0[0x0]
80005512:	5e 94       	retgt	r4

80005514 <_read>:
/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
{
80005514:	d4 21       	pushm	r4-r7,lr
80005516:	16 95       	mov	r5,r11
80005518:	14 96       	mov	r6,r10
  int nChars = 0;

  if (file != 0)
8000551a:	58 0c       	cp.w	r12,0
8000551c:	c0 30       	breq	80005522 <_read+0xe>
8000551e:	3f f7       	mov	r7,-1
80005520:	c1 48       	rjmp	80005548 <_read+0x34>
    return -1;

  for (; len > 0; --len)
80005522:	58 0a       	cp.w	r10,0
80005524:	e0 89 00 04 	brgt	8000552c <_read+0x18>
80005528:	30 07       	mov	r7,0
8000552a:	c0 f8       	rjmp	80005548 <_read+0x34>
8000552c:	30 07       	mov	r7,0
  {
    int c = usart_getchar(stdio_usart_base);
8000552e:	48 84       	lddpc	r4,8000554c <_read+0x38>
80005530:	68 0c       	ld.w	r12,r4[0x0]
80005532:	f0 1f 00 08 	mcall	80005550 <_read+0x3c>
    if (c < 0)
80005536:	c0 95       	brlt	80005548 <_read+0x34>
      break;

    *ptr++ = c;
80005538:	ea 07 0b 0c 	st.b	r5[r7],r12
    ++nChars;
8000553c:	2f f7       	sub	r7,-1

/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
8000553e:	ec 07 01 08 	sub	r8,r6,r7
  int nChars = 0;

  if (file != 0)
    return -1;

  for (; len > 0; --len)
80005542:	58 08       	cp.w	r8,0
80005544:	fe 99 ff f6 	brgt	80005530 <_read+0x1c>
    *ptr++ = c;
    ++nChars;
  }

  return nChars;
}
80005548:	0e 9c       	mov	r12,r7
8000554a:	d8 22       	popm	r4-r7,pc
8000554c:	00 00       	add	r0,r0
8000554e:	41 14       	lddsp	r4,sp[0x44]
80005550:	80 00       	ld.sh	r0,r0[0x0]
80005552:	50 e0       	stdsp	sp[0x38],r0

80005554 <_write>:
 * 1 and 2 is stdout and stderr which goes to usart
 * 3 is framebuffer
 */
int __attribute__((weak))
_write (int file, char * ptr, int len)
{
80005554:	d4 21       	pushm	r4-r7,lr
80005556:	16 95       	mov	r5,r11
80005558:	14 96       	mov	r6,r10
  int nChars = 0;

  if ( (file != 1)
8000555a:	20 1c       	sub	r12,1
8000555c:	58 2c       	cp.w	r12,2
8000555e:	e0 8b 00 12 	brhi	80005582 <_write+0x2e>
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80005562:	58 0a       	cp.w	r10,0
80005564:	c0 31       	brne	8000556a <_write+0x16>
80005566:	30 07       	mov	r7,0
80005568:	c0 e8       	rjmp	80005584 <_write+0x30>
8000556a:	30 07       	mov	r7,0
  {
    if (usart_putchar(stdio_usart_base, *ptr++) < 0)
8000556c:	48 74       	lddpc	r4,80005588 <_write+0x34>
8000556e:	68 0c       	ld.w	r12,r4[0x0]
80005570:	ea 07 07 0b 	ld.ub	r11,r5[r7]
80005574:	f0 1f 00 06 	mcall	8000558c <_write+0x38>
80005578:	c0 55       	brlt	80005582 <_write+0x2e>
    {
      return -1;
    }

    ++nChars;
8000557a:	2f f7       	sub	r7,-1

  if ( (file != 1)
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
8000557c:	0e 36       	cp.w	r6,r7
8000557e:	cf 81       	brne	8000556e <_write+0x1a>
80005580:	c0 28       	rjmp	80005584 <_write+0x30>
80005582:	3f f7       	mov	r7,-1

    ++nChars;
  }

  return nChars;
}
80005584:	0e 9c       	mov	r12,r7
80005586:	d8 22       	popm	r4-r7,pc
80005588:	00 00       	add	r0,r0
8000558a:	41 14       	lddsp	r4,sp[0x44]
8000558c:	80 00       	ld.sh	r0,r0[0x0]
8000558e:	50 90       	stdsp	sp[0x24],r0

80005590 <vPortFree>:
	return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
80005590:	eb cd 40 80 	pushm	r7,lr
80005594:	18 97       	mov	r7,r12
	if( pv )
80005596:	58 0c       	cp.w	r12,0
80005598:	c0 80       	breq	800055a8 <vPortFree+0x18>
	{
		vTaskSuspendAll();
8000559a:	f0 1f 00 05 	mcall	800055ac <vPortFree+0x1c>
		{
			free( pv );
8000559e:	0e 9c       	mov	r12,r7
800055a0:	f0 1f 00 04 	mcall	800055b0 <vPortFree+0x20>
		}
		xTaskResumeAll();
800055a4:	f0 1f 00 04 	mcall	800055b4 <vPortFree+0x24>
800055a8:	e3 cd 80 80 	ldm	sp++,r7,pc
800055ac:	80 00       	ld.sh	r0,r0[0x0]
800055ae:	5a d8       	cp.w	r8,-19
800055b0:	80 00       	ld.sh	r0,r0[0x0]
800055b2:	6a 04       	ld.w	r4,r5[0x0]
800055b4:	80 00       	ld.sh	r0,r0[0x0]
800055b6:	5e 94       	retgt	r4

800055b8 <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
800055b8:	eb cd 40 80 	pushm	r7,lr
800055bc:	18 97       	mov	r7,r12
void *pvReturn;

	vTaskSuspendAll();
800055be:	f0 1f 00 06 	mcall	800055d4 <pvPortMalloc+0x1c>
	{
		pvReturn = malloc( xWantedSize );
800055c2:	0e 9c       	mov	r12,r7
800055c4:	f0 1f 00 05 	mcall	800055d8 <pvPortMalloc+0x20>
800055c8:	18 97       	mov	r7,r12
	}
	xTaskResumeAll();
800055ca:	f0 1f 00 05 	mcall	800055dc <pvPortMalloc+0x24>
		}
	}
	#endif

	return pvReturn;
}
800055ce:	0e 9c       	mov	r12,r7
800055d0:	e3 cd 80 80 	ldm	sp++,r7,pc
800055d4:	80 00       	ld.sh	r0,r0[0x0]
800055d6:	5a d8       	cp.w	r8,-19
800055d8:	80 00       	ld.sh	r0,r0[0x0]
800055da:	6a 14       	ld.w	r4,r5[0x4]
800055dc:	80 00       	ld.sh	r0,r0[0x0]
800055de:	5e 94       	retgt	r4

800055e0 <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
800055e0:	d4 01       	pushm	lr
800055e2:	16 98       	mov	r8,r11
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
800055e4:	78 09       	ld.w	r9,r12[0x0]
800055e6:	58 09       	cp.w	r9,0
800055e8:	c1 10       	breq	8000560a <prvCopyDataFromQueue+0x2a>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
800055ea:	78 3a       	ld.w	r10,r12[0xc]
800055ec:	79 09       	ld.w	r9,r12[0x40]
800055ee:	f4 09 00 09 	add	r9,r10,r9
800055f2:	99 39       	st.w	r12[0xc],r9
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
800055f4:	78 1a       	ld.w	r10,r12[0x4]
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
800055f6:	14 39       	cp.w	r9,r10
800055f8:	f9 f9 20 00 	ld.wcc	r9,r12[0x0]
800055fc:	f9 f9 2a 03 	st.wcc	r12[0xc],r9
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
80005600:	79 0a       	ld.w	r10,r12[0x40]
80005602:	78 3b       	ld.w	r11,r12[0xc]
80005604:	10 9c       	mov	r12,r8
80005606:	f0 1f 00 02 	mcall	8000560c <prvCopyDataFromQueue+0x2c>
8000560a:	d8 02       	popm	pc
8000560c:	80 00       	ld.sh	r0,r0[0x0]
8000560e:	6e 5c       	ld.w	r12,r7[0x14]

80005610 <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
80005610:	eb cd 40 c0 	pushm	r6-r7,lr
80005614:	18 97       	mov	r7,r12
80005616:	14 96       	mov	r6,r10
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80005618:	78 e8       	ld.w	r8,r12[0x38]
8000561a:	58 08       	cp.w	r8,0
8000561c:	c0 31       	brne	80005622 <xQueueReceiveFromISR+0x12>
8000561e:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
80005622:	f0 1f 00 0e 	mcall	80005658 <xQueueReceiveFromISR+0x48>
			--( pxQueue->uxMessagesWaiting );
80005626:	6e e8       	ld.w	r8,r7[0x38]
80005628:	20 18       	sub	r8,1
8000562a:	8f e8       	st.w	r7[0x38],r8

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
8000562c:	6f 18       	ld.w	r8,r7[0x44]
8000562e:	5b f8       	cp.w	r8,-1
80005630:	c0 d1       	brne	8000564a <xQueueReceiveFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005632:	6e 48       	ld.w	r8,r7[0x10]
80005634:	58 08       	cp.w	r8,0
80005636:	c0 f0       	breq	80005654 <xQueueReceiveFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80005638:	ee cc ff f0 	sub	r12,r7,-16
8000563c:	f0 1f 00 08 	mcall	8000565c <xQueueReceiveFromISR+0x4c>
80005640:	c0 a0       	breq	80005654 <xQueueReceiveFromISR+0x44>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
80005642:	30 1c       	mov	r12,1
80005644:	8d 0c       	st.w	r6[0x0],r12
80005646:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
8000564a:	2f f8       	sub	r8,-1
8000564c:	ef 48 00 44 	st.w	r7[68],r8
80005650:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80005654:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80005658:	80 00       	ld.sh	r0,r0[0x0]
8000565a:	55 e0       	stdsp	sp[0x178],r0
8000565c:	80 00       	ld.sh	r0,r0[0x0]
8000565e:	5c 70       	castu.h	r0

80005660 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
80005660:	eb cd 40 c0 	pushm	r6-r7,lr
80005664:	18 97       	mov	r7,r12

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
80005666:	f0 1f 00 23 	mcall	800056f0 <prvUnlockQueue+0x90>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
8000566a:	6f 28       	ld.w	r8,r7[0x48]
8000566c:	58 08       	cp.w	r8,0
8000566e:	e0 8a 00 18 	brle	8000569e <prvUnlockQueue+0x3e>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005672:	6e 98       	ld.w	r8,r7[0x24]
80005674:	58 08       	cp.w	r8,0
80005676:	c1 40       	breq	8000569e <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80005678:	ee c6 ff dc 	sub	r6,r7,-36
8000567c:	c0 48       	rjmp	80005684 <prvUnlockQueue+0x24>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
8000567e:	6e 98       	ld.w	r8,r7[0x24]
80005680:	58 08       	cp.w	r8,0
80005682:	c0 e0       	breq	8000569e <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80005684:	0c 9c       	mov	r12,r6
80005686:	f0 1f 00 1c 	mcall	800056f4 <prvUnlockQueue+0x94>
8000568a:	c0 30       	breq	80005690 <prvUnlockQueue+0x30>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
8000568c:	f0 1f 00 1b 	mcall	800056f8 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xTxLock );
80005690:	6f 28       	ld.w	r8,r7[0x48]
80005692:	20 18       	sub	r8,1
80005694:	ef 48 00 48 	st.w	r7[72],r8
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80005698:	58 08       	cp.w	r8,0
8000569a:	fe 99 ff f2 	brgt	8000567e <prvUnlockQueue+0x1e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
8000569e:	3f f8       	mov	r8,-1
800056a0:	ef 48 00 48 	st.w	r7[72],r8
	}
	taskEXIT_CRITICAL();
800056a4:	f0 1f 00 16 	mcall	800056fc <prvUnlockQueue+0x9c>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
800056a8:	f0 1f 00 12 	mcall	800056f0 <prvUnlockQueue+0x90>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
800056ac:	6f 18       	ld.w	r8,r7[0x44]
800056ae:	58 08       	cp.w	r8,0
800056b0:	e0 8a 00 18 	brle	800056e0 <prvUnlockQueue+0x80>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
800056b4:	6e 48       	ld.w	r8,r7[0x10]
800056b6:	58 08       	cp.w	r8,0
800056b8:	c1 40       	breq	800056e0 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
800056ba:	ee c6 ff f0 	sub	r6,r7,-16
800056be:	c0 48       	rjmp	800056c6 <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
800056c0:	6e 48       	ld.w	r8,r7[0x10]
800056c2:	58 08       	cp.w	r8,0
800056c4:	c0 e0       	breq	800056e0 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
800056c6:	0c 9c       	mov	r12,r6
800056c8:	f0 1f 00 0b 	mcall	800056f4 <prvUnlockQueue+0x94>
800056cc:	c0 30       	breq	800056d2 <prvUnlockQueue+0x72>
				{
					vTaskMissedYield();
800056ce:	f0 1f 00 0b 	mcall	800056f8 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xRxLock );
800056d2:	6f 18       	ld.w	r8,r7[0x44]
800056d4:	20 18       	sub	r8,1
800056d6:	ef 48 00 44 	st.w	r7[68],r8
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
800056da:	58 08       	cp.w	r8,0
800056dc:	fe 99 ff f2 	brgt	800056c0 <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
800056e0:	3f f8       	mov	r8,-1
800056e2:	ef 48 00 44 	st.w	r7[68],r8
	}
	taskEXIT_CRITICAL();
800056e6:	f0 1f 00 06 	mcall	800056fc <prvUnlockQueue+0x9c>
}
800056ea:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800056ee:	00 00       	add	r0,r0
800056f0:	80 00       	ld.sh	r0,r0[0x0]
800056f2:	53 4c       	stdsp	sp[0xd0],r12
800056f4:	80 00       	ld.sh	r0,r0[0x0]
800056f6:	5c 70       	castu.h	r0
800056f8:	80 00       	ld.sh	r0,r0[0x0]
800056fa:	5b 7c       	cp.w	r12,-9
800056fc:	80 00       	ld.sh	r0,r0[0x0]
800056fe:	54 58       	stdsp	sp[0x114],r8

80005700 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
80005700:	d4 31       	pushm	r0-r7,lr
80005702:	20 5d       	sub	sp,20
80005704:	18 97       	mov	r7,r12
80005706:	50 0b       	stdsp	sp[0x0],r11
80005708:	50 2a       	stdsp	sp[0x8],r10
8000570a:	50 19       	stdsp	sp[0x4],r9
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
8000570c:	f8 c2 ff dc 	sub	r2,r12,-36
80005710:	30 05       	mov	r5,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80005712:	fa c4 ff f4 	sub	r4,sp,-12
80005716:	30 10       	mov	r0,1

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80005718:	0a 91       	mov	r1,r5

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
8000571a:	fa c3 ff f8 	sub	r3,sp,-8
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
8000571e:	f0 1f 00 3e 	mcall	80005814 <xQueueGenericReceive+0x114>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80005722:	6e e8       	ld.w	r8,r7[0x38]
80005724:	58 08       	cp.w	r8,0
80005726:	c2 a0       	breq	8000577a <xQueueGenericReceive+0x7a>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
80005728:	6e 36       	ld.w	r6,r7[0xc]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
8000572a:	40 0b       	lddsp	r11,sp[0x0]
8000572c:	0e 9c       	mov	r12,r7
8000572e:	f0 1f 00 3b 	mcall	80005818 <xQueueGenericReceive+0x118>

				if( xJustPeeking == pdFALSE )
80005732:	40 18       	lddsp	r8,sp[0x4]
80005734:	58 08       	cp.w	r8,0
80005736:	c1 51       	brne	80005760 <xQueueGenericReceive+0x60>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
80005738:	6e e8       	ld.w	r8,r7[0x38]
8000573a:	20 18       	sub	r8,1
8000573c:	8f e8       	st.w	r7[0x38],r8

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
8000573e:	6e 08       	ld.w	r8,r7[0x0]
80005740:	58 08       	cp.w	r8,0
80005742:	c0 41       	brne	8000574a <xQueueGenericReceive+0x4a>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
80005744:	f0 1f 00 36 	mcall	8000581c <xQueueGenericReceive+0x11c>
80005748:	8f 1c       	st.w	r7[0x4],r12
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
8000574a:	6e 48       	ld.w	r8,r7[0x10]
8000574c:	58 08       	cp.w	r8,0
8000574e:	c1 20       	breq	80005772 <xQueueGenericReceive+0x72>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
80005750:	ee cc ff f0 	sub	r12,r7,-16
80005754:	f0 1f 00 33 	mcall	80005820 <xQueueGenericReceive+0x120>
80005758:	58 1c       	cp.w	r12,1
8000575a:	c0 c1       	brne	80005772 <xQueueGenericReceive+0x72>
						{
							portYIELD_WITHIN_API();
8000575c:	d7 33       	scall
8000575e:	c0 a8       	rjmp	80005772 <xQueueGenericReceive+0x72>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
80005760:	8f 36       	st.w	r7[0xc],r6

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005762:	6e 98       	ld.w	r8,r7[0x24]
80005764:	58 08       	cp.w	r8,0
80005766:	c0 60       	breq	80005772 <xQueueGenericReceive+0x72>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80005768:	04 9c       	mov	r12,r2
8000576a:	f0 1f 00 2e 	mcall	80005820 <xQueueGenericReceive+0x120>
8000576e:	c0 20       	breq	80005772 <xQueueGenericReceive+0x72>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
80005770:	d7 33       	scall
						}
					}

				}

				taskEXIT_CRITICAL();
80005772:	f0 1f 00 2d 	mcall	80005824 <xQueueGenericReceive+0x124>
80005776:	30 1c       	mov	r12,1
				return pdPASS;
80005778:	c4 c8       	rjmp	80005810 <xQueueGenericReceive+0x110>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
8000577a:	40 28       	lddsp	r8,sp[0x8]
8000577c:	58 08       	cp.w	r8,0
8000577e:	c0 51       	brne	80005788 <xQueueGenericReceive+0x88>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80005780:	f0 1f 00 29 	mcall	80005824 <xQueueGenericReceive+0x124>
80005784:	30 0c       	mov	r12,0
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
80005786:	c4 58       	rjmp	80005810 <xQueueGenericReceive+0x110>
				}
				else if( xEntryTimeSet == pdFALSE )
80005788:	58 05       	cp.w	r5,0
8000578a:	c0 51       	brne	80005794 <xQueueGenericReceive+0x94>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
8000578c:	08 9c       	mov	r12,r4
8000578e:	f0 1f 00 27 	mcall	80005828 <xQueueGenericReceive+0x128>
80005792:	00 95       	mov	r5,r0
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80005794:	f0 1f 00 24 	mcall	80005824 <xQueueGenericReceive+0x124>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80005798:	f0 1f 00 25 	mcall	8000582c <xQueueGenericReceive+0x12c>
		prvLockQueue( pxQueue );
8000579c:	f0 1f 00 1e 	mcall	80005814 <xQueueGenericReceive+0x114>
800057a0:	6f 18       	ld.w	r8,r7[0x44]
800057a2:	5b f8       	cp.w	r8,-1
800057a4:	ef f1 0a 11 	st.weq	r7[0x44],r1
800057a8:	6f 28       	ld.w	r8,r7[0x48]
800057aa:	5b f8       	cp.w	r8,-1
800057ac:	ef f1 0a 12 	st.weq	r7[0x48],r1
800057b0:	f0 1f 00 1d 	mcall	80005824 <xQueueGenericReceive+0x124>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800057b4:	06 9b       	mov	r11,r3
800057b6:	08 9c       	mov	r12,r4
800057b8:	f0 1f 00 1e 	mcall	80005830 <xQueueGenericReceive+0x130>
800057bc:	c2 41       	brne	80005804 <xQueueGenericReceive+0x104>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
800057be:	f0 1f 00 16 	mcall	80005814 <xQueueGenericReceive+0x114>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
800057c2:	6e e6       	ld.w	r6,r7[0x38]
	taskEXIT_CRITICAL();
800057c4:	f0 1f 00 18 	mcall	80005824 <xQueueGenericReceive+0x124>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
800057c8:	58 06       	cp.w	r6,0
800057ca:	c1 71       	brne	800057f8 <xQueueGenericReceive+0xf8>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
800057cc:	6e 08       	ld.w	r8,r7[0x0]
800057ce:	58 08       	cp.w	r8,0
800057d0:	c0 81       	brne	800057e0 <xQueueGenericReceive+0xe0>
					{
						portENTER_CRITICAL();
800057d2:	f0 1f 00 11 	mcall	80005814 <xQueueGenericReceive+0x114>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
800057d6:	6e 1c       	ld.w	r12,r7[0x4]
800057d8:	f0 1f 00 17 	mcall	80005834 <xQueueGenericReceive+0x134>
						}
						portEXIT_CRITICAL();
800057dc:	f0 1f 00 12 	mcall	80005824 <xQueueGenericReceive+0x124>
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
800057e0:	40 2b       	lddsp	r11,sp[0x8]
800057e2:	04 9c       	mov	r12,r2
800057e4:	f0 1f 00 15 	mcall	80005838 <xQueueGenericReceive+0x138>
				prvUnlockQueue( pxQueue );
800057e8:	0e 9c       	mov	r12,r7
800057ea:	f0 1f 00 15 	mcall	8000583c <xQueueGenericReceive+0x13c>
				if( !xTaskResumeAll() )
800057ee:	f0 1f 00 15 	mcall	80005840 <xQueueGenericReceive+0x140>
800057f2:	c9 61       	brne	8000571e <xQueueGenericReceive+0x1e>
				{
					portYIELD_WITHIN_API();
800057f4:	d7 33       	scall
800057f6:	c9 4b       	rjmp	8000571e <xQueueGenericReceive+0x1e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
800057f8:	0e 9c       	mov	r12,r7
800057fa:	f0 1f 00 11 	mcall	8000583c <xQueueGenericReceive+0x13c>
				( void ) xTaskResumeAll();
800057fe:	f0 1f 00 11 	mcall	80005840 <xQueueGenericReceive+0x140>
80005802:	c8 eb       	rjmp	8000571e <xQueueGenericReceive+0x1e>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
80005804:	0e 9c       	mov	r12,r7
80005806:	f0 1f 00 0e 	mcall	8000583c <xQueueGenericReceive+0x13c>
			( void ) xTaskResumeAll();
8000580a:	f0 1f 00 0e 	mcall	80005840 <xQueueGenericReceive+0x140>
8000580e:	30 0c       	mov	r12,0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
80005810:	2f bd       	sub	sp,-20
80005812:	d8 32       	popm	r0-r7,pc
80005814:	80 00       	ld.sh	r0,r0[0x0]
80005816:	53 4c       	stdsp	sp[0xd0],r12
80005818:	80 00       	ld.sh	r0,r0[0x0]
8000581a:	55 e0       	stdsp	sp[0x178],r0
8000581c:	80 00       	ld.sh	r0,r0[0x0]
8000581e:	5b 88       	cp.w	r8,-8
80005820:	80 00       	ld.sh	r0,r0[0x0]
80005822:	5c 70       	castu.h	r0
80005824:	80 00       	ld.sh	r0,r0[0x0]
80005826:	54 58       	stdsp	sp[0x114],r8
80005828:	80 00       	ld.sh	r0,r0[0x0]
8000582a:	5b 64       	cp.w	r4,-10
8000582c:	80 00       	ld.sh	r0,r0[0x0]
8000582e:	5a d8       	cp.w	r8,-19
80005830:	80 00       	ld.sh	r0,r0[0x0]
80005832:	5e 00       	reteq	r0
80005834:	80 00       	ld.sh	r0,r0[0x0]
80005836:	5b ec       	cp.w	r12,-2
80005838:	80 00       	ld.sh	r0,r0[0x0]
8000583a:	60 58       	ld.w	r8,r0[0x14]
8000583c:	80 00       	ld.sh	r0,r0[0x0]
8000583e:	56 60       	stdsp	sp[0x198],r0
80005840:	80 00       	ld.sh	r0,r0[0x0]
80005842:	5e 94       	retgt	r4

80005844 <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
80005844:	eb cd 40 80 	pushm	r7,lr
80005848:	18 97       	mov	r7,r12
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
8000584a:	79 08       	ld.w	r8,r12[0x40]
8000584c:	58 08       	cp.w	r8,0
8000584e:	c0 a1       	brne	80005862 <prvCopyDataToQueue+0x1e>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80005850:	78 08       	ld.w	r8,r12[0x0]
80005852:	58 08       	cp.w	r8,0
80005854:	c2 b1       	brne	800058aa <prvCopyDataToQueue+0x66>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
80005856:	78 1c       	ld.w	r12,r12[0x4]
80005858:	f0 1f 00 17 	mcall	800058b4 <prvCopyDataToQueue+0x70>
				pxQueue->pxMutexHolder = NULL;
8000585c:	30 08       	mov	r8,0
8000585e:	8f 18       	st.w	r7[0x4],r8
80005860:	c2 58       	rjmp	800058aa <prvCopyDataToQueue+0x66>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
80005862:	58 0a       	cp.w	r10,0
80005864:	c1 01       	brne	80005884 <prvCopyDataToQueue+0x40>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80005866:	10 9a       	mov	r10,r8
80005868:	78 2c       	ld.w	r12,r12[0x8]
8000586a:	f0 1f 00 14 	mcall	800058b8 <prvCopyDataToQueue+0x74>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
8000586e:	6e 29       	ld.w	r9,r7[0x8]
80005870:	6f 08       	ld.w	r8,r7[0x40]
80005872:	f2 08 00 08 	add	r8,r9,r8
80005876:	8f 28       	st.w	r7[0x8],r8
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
80005878:	6e 19       	ld.w	r9,r7[0x4]
8000587a:	12 38       	cp.w	r8,r9
8000587c:	c1 73       	brcs	800058aa <prvCopyDataToQueue+0x66>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
8000587e:	6e 08       	ld.w	r8,r7[0x0]
80005880:	8f 28       	st.w	r7[0x8],r8
80005882:	c1 48       	rjmp	800058aa <prvCopyDataToQueue+0x66>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80005884:	10 9a       	mov	r10,r8
80005886:	78 3c       	ld.w	r12,r12[0xc]
80005888:	f0 1f 00 0c 	mcall	800058b8 <prvCopyDataToQueue+0x74>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
8000588c:	6f 08       	ld.w	r8,r7[0x40]
8000588e:	6e 39       	ld.w	r9,r7[0xc]
80005890:	f2 08 01 08 	sub	r8,r9,r8
80005894:	8f 38       	st.w	r7[0xc],r8
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
80005896:	6e 09       	ld.w	r9,r7[0x0]
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
80005898:	12 38       	cp.w	r8,r9
8000589a:	ef f8 30 10 	ld.wcs	r8,r7[0x40]
8000589e:	ef f9 30 01 	ld.wcs	r9,r7[0x4]
800058a2:	f3 d8 e3 19 	subcs	r9,r9,r8
800058a6:	ef f9 3a 03 	st.wcs	r7[0xc],r9
		}
	}

	++( pxQueue->uxMessagesWaiting );
800058aa:	6e e8       	ld.w	r8,r7[0x38]
800058ac:	2f f8       	sub	r8,-1
800058ae:	8f e8       	st.w	r7[0x38],r8
}
800058b0:	e3 cd 80 80 	ldm	sp++,r7,pc
800058b4:	80 00       	ld.sh	r0,r0[0x0]
800058b6:	5b 94       	cp.w	r4,-7
800058b8:	80 00       	ld.sh	r0,r0[0x0]
800058ba:	6e 5c       	ld.w	r12,r7[0x14]

800058bc <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
800058bc:	eb cd 40 c0 	pushm	r6-r7,lr
800058c0:	18 97       	mov	r7,r12
800058c2:	14 96       	mov	r6,r10
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
800058c4:	78 ec       	ld.w	r12,r12[0x38]
800058c6:	6e f8       	ld.w	r8,r7[0x3c]
800058c8:	10 3c       	cp.w	r12,r8
800058ca:	c0 33       	brcs	800058d0 <xQueueGenericSendFromISR+0x14>
800058cc:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
800058d0:	12 9a       	mov	r10,r9
800058d2:	0e 9c       	mov	r12,r7
800058d4:	f0 1f 00 0c 	mcall	80005904 <xQueueGenericSendFromISR+0x48>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
800058d8:	6f 28       	ld.w	r8,r7[0x48]
800058da:	5b f8       	cp.w	r8,-1
800058dc:	c0 d1       	brne	800058f6 <xQueueGenericSendFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800058de:	6e 98       	ld.w	r8,r7[0x24]
800058e0:	58 08       	cp.w	r8,0
800058e2:	c0 f0       	breq	80005900 <xQueueGenericSendFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
800058e4:	ee cc ff dc 	sub	r12,r7,-36
800058e8:	f0 1f 00 08 	mcall	80005908 <xQueueGenericSendFromISR+0x4c>
800058ec:	c0 a0       	breq	80005900 <xQueueGenericSendFromISR+0x44>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
800058ee:	30 1c       	mov	r12,1
800058f0:	8d 0c       	st.w	r6[0x0],r12
800058f2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
800058f6:	2f f8       	sub	r8,-1
800058f8:	ef 48 00 48 	st.w	r7[72],r8
800058fc:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80005900:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80005904:	80 00       	ld.sh	r0,r0[0x0]
80005906:	58 44       	cp.w	r4,4
80005908:	80 00       	ld.sh	r0,r0[0x0]
8000590a:	5c 70       	castu.h	r0

8000590c <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
8000590c:	d4 31       	pushm	r0-r7,lr
8000590e:	20 5d       	sub	sp,20
80005910:	18 97       	mov	r7,r12
80005912:	50 0b       	stdsp	sp[0x0],r11
80005914:	50 2a       	stdsp	sp[0x8],r10
80005916:	50 19       	stdsp	sp[0x4],r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
80005918:	f8 c0 ff f0 	sub	r0,r12,-16
8000591c:	30 04       	mov	r4,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
8000591e:	fa c3 ff f4 	sub	r3,sp,-12

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80005922:	08 91       	mov	r1,r4

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80005924:	fa c2 ff f8 	sub	r2,sp,-8
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
80005928:	f0 1f 00 2f 	mcall	800059e4 <xQueueGenericSend+0xd8>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
8000592c:	6e e9       	ld.w	r9,r7[0x38]
8000592e:	6e f8       	ld.w	r8,r7[0x3c]
80005930:	10 39       	cp.w	r9,r8
80005932:	c1 42       	brcc	8000595a <xQueueGenericSend+0x4e>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80005934:	40 1a       	lddsp	r10,sp[0x4]
80005936:	40 0b       	lddsp	r11,sp[0x0]
80005938:	0e 9c       	mov	r12,r7
8000593a:	f0 1f 00 2c 	mcall	800059e8 <xQueueGenericSend+0xdc>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
8000593e:	6e 98       	ld.w	r8,r7[0x24]
80005940:	58 08       	cp.w	r8,0
80005942:	c0 80       	breq	80005952 <xQueueGenericSend+0x46>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
80005944:	ee cc ff dc 	sub	r12,r7,-36
80005948:	f0 1f 00 29 	mcall	800059ec <xQueueGenericSend+0xe0>
8000594c:	58 1c       	cp.w	r12,1
8000594e:	c0 21       	brne	80005952 <xQueueGenericSend+0x46>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
80005950:	d7 33       	scall
					}
				}

				taskEXIT_CRITICAL();
80005952:	f0 1f 00 28 	mcall	800059f0 <xQueueGenericSend+0xe4>
80005956:	30 1c       	mov	r12,1

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
80005958:	c4 38       	rjmp	800059de <xQueueGenericSend+0xd2>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
8000595a:	40 28       	lddsp	r8,sp[0x8]
8000595c:	58 08       	cp.w	r8,0
8000595e:	c0 51       	brne	80005968 <xQueueGenericSend+0x5c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80005960:	f0 1f 00 24 	mcall	800059f0 <xQueueGenericSend+0xe4>
80005964:	30 0c       	mov	r12,0

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
80005966:	c3 c8       	rjmp	800059de <xQueueGenericSend+0xd2>
				}
				else if( xEntryTimeSet == pdFALSE )
80005968:	58 04       	cp.w	r4,0
8000596a:	c0 51       	brne	80005974 <xQueueGenericSend+0x68>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
8000596c:	06 9c       	mov	r12,r3
8000596e:	f0 1f 00 22 	mcall	800059f4 <xQueueGenericSend+0xe8>
80005972:	30 14       	mov	r4,1
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80005974:	f0 1f 00 1f 	mcall	800059f0 <xQueueGenericSend+0xe4>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80005978:	f0 1f 00 20 	mcall	800059f8 <xQueueGenericSend+0xec>
		prvLockQueue( pxQueue );
8000597c:	f0 1f 00 1a 	mcall	800059e4 <xQueueGenericSend+0xd8>
80005980:	6f 18       	ld.w	r8,r7[0x44]
80005982:	5b f8       	cp.w	r8,-1
80005984:	ef f1 0a 11 	st.weq	r7[0x44],r1
80005988:	6f 28       	ld.w	r8,r7[0x48]
8000598a:	5b f8       	cp.w	r8,-1
8000598c:	ef f1 0a 12 	st.weq	r7[0x48],r1
80005990:	f0 1f 00 18 	mcall	800059f0 <xQueueGenericSend+0xe4>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80005994:	04 9b       	mov	r11,r2
80005996:	06 9c       	mov	r12,r3
80005998:	f0 1f 00 19 	mcall	800059fc <xQueueGenericSend+0xf0>
8000599c:	c1 b1       	brne	800059d2 <xQueueGenericSend+0xc6>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
8000599e:	f0 1f 00 12 	mcall	800059e4 <xQueueGenericSend+0xd8>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
800059a2:	6e e5       	ld.w	r5,r7[0x38]
800059a4:	6e f6       	ld.w	r6,r7[0x3c]
	taskEXIT_CRITICAL();
800059a6:	f0 1f 00 13 	mcall	800059f0 <xQueueGenericSend+0xe4>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
800059aa:	0c 35       	cp.w	r5,r6
800059ac:	c0 d1       	brne	800059c6 <xQueueGenericSend+0xba>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
800059ae:	40 2b       	lddsp	r11,sp[0x8]
800059b0:	00 9c       	mov	r12,r0
800059b2:	f0 1f 00 14 	mcall	80005a00 <xQueueGenericSend+0xf4>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
800059b6:	0e 9c       	mov	r12,r7
800059b8:	f0 1f 00 13 	mcall	80005a04 <xQueueGenericSend+0xf8>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
800059bc:	f0 1f 00 13 	mcall	80005a08 <xQueueGenericSend+0xfc>
800059c0:	cb 41       	brne	80005928 <xQueueGenericSend+0x1c>
				{
					portYIELD_WITHIN_API();
800059c2:	d7 33       	scall
800059c4:	cb 2b       	rjmp	80005928 <xQueueGenericSend+0x1c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
800059c6:	0e 9c       	mov	r12,r7
800059c8:	f0 1f 00 0f 	mcall	80005a04 <xQueueGenericSend+0xf8>
				( void ) xTaskResumeAll();
800059cc:	f0 1f 00 0f 	mcall	80005a08 <xQueueGenericSend+0xfc>
800059d0:	ca cb       	rjmp	80005928 <xQueueGenericSend+0x1c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
800059d2:	0e 9c       	mov	r12,r7
800059d4:	f0 1f 00 0c 	mcall	80005a04 <xQueueGenericSend+0xf8>
			( void ) xTaskResumeAll();
800059d8:	f0 1f 00 0c 	mcall	80005a08 <xQueueGenericSend+0xfc>
800059dc:	30 0c       	mov	r12,0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
800059de:	2f bd       	sub	sp,-20
800059e0:	d8 32       	popm	r0-r7,pc
800059e2:	00 00       	add	r0,r0
800059e4:	80 00       	ld.sh	r0,r0[0x0]
800059e6:	53 4c       	stdsp	sp[0xd0],r12
800059e8:	80 00       	ld.sh	r0,r0[0x0]
800059ea:	58 44       	cp.w	r4,4
800059ec:	80 00       	ld.sh	r0,r0[0x0]
800059ee:	5c 70       	castu.h	r0
800059f0:	80 00       	ld.sh	r0,r0[0x0]
800059f2:	54 58       	stdsp	sp[0x114],r8
800059f4:	80 00       	ld.sh	r0,r0[0x0]
800059f6:	5b 64       	cp.w	r4,-10
800059f8:	80 00       	ld.sh	r0,r0[0x0]
800059fa:	5a d8       	cp.w	r8,-19
800059fc:	80 00       	ld.sh	r0,r0[0x0]
800059fe:	5e 00       	reteq	r0
80005a00:	80 00       	ld.sh	r0,r0[0x0]
80005a02:	60 58       	ld.w	r8,r0[0x14]
80005a04:	80 00       	ld.sh	r0,r0[0x0]
80005a06:	56 60       	stdsp	sp[0x198],r0
80005a08:	80 00       	ld.sh	r0,r0[0x0]
80005a0a:	5e 94       	retgt	r4

80005a0c <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	xQueueHandle xQueueCreateMutex( void )
	{
80005a0c:	eb cd 40 c0 	pushm	r6-r7,lr
	xQUEUE *pxNewQueue;

		/* Allocate the new queue structure. */
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
80005a10:	34 cc       	mov	r12,76
80005a12:	f0 1f 00 12 	mcall	80005a58 <xQueueCreateMutex+0x4c>
80005a16:	18 97       	mov	r7,r12
		if( pxNewQueue != NULL )
80005a18:	c1 d0       	breq	80005a52 <xQueueCreateMutex+0x46>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
80005a1a:	30 06       	mov	r6,0
80005a1c:	99 16       	st.w	r12[0x4],r6
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
80005a1e:	99 06       	st.w	r12[0x0],r6

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
80005a20:	99 26       	st.w	r12[0x8],r6
			pxNewQueue->pcReadFrom = NULL;
80005a22:	99 36       	st.w	r12[0xc],r6

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
80005a24:	99 e6       	st.w	r12[0x38],r6
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
80005a26:	30 18       	mov	r8,1
80005a28:	99 f8       	st.w	r12[0x3c],r8
			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
80005a2a:	f9 46 00 40 	st.w	r12[64],r6
			pxNewQueue->xRxLock = queueUNLOCKED;
80005a2e:	3f f8       	mov	r8,-1
80005a30:	f9 48 00 44 	st.w	r12[68],r8
			pxNewQueue->xTxLock = queueUNLOCKED;
80005a34:	f9 48 00 48 	st.w	r12[72],r8

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
80005a38:	2f 0c       	sub	r12,-16
80005a3a:	f0 1f 00 09 	mcall	80005a5c <xQueueCreateMutex+0x50>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
80005a3e:	ee cc ff dc 	sub	r12,r7,-36
80005a42:	f0 1f 00 07 	mcall	80005a5c <xQueueCreateMutex+0x50>

			/* Start with the semaphore in the expected state. */
			xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
80005a46:	0c 99       	mov	r9,r6
80005a48:	0c 9a       	mov	r10,r6
80005a4a:	0c 9b       	mov	r11,r6
80005a4c:	0e 9c       	mov	r12,r7
80005a4e:	f0 1f 00 05 	mcall	80005a60 <xQueueCreateMutex+0x54>
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
80005a52:	0e 9c       	mov	r12,r7
80005a54:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005a58:	80 00       	ld.sh	r0,r0[0x0]
80005a5a:	55 b8       	stdsp	sp[0x16c],r8
80005a5c:	80 00       	ld.sh	r0,r0[0x0]
80005a5e:	52 28       	stdsp	sp[0x88],r8
80005a60:	80 00       	ld.sh	r0,r0[0x0]
80005a62:	59 0c       	cp.w	r12,16

80005a64 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
80005a64:	d4 21       	pushm	r4-r7,lr
80005a66:	18 97       	mov	r7,r12
80005a68:	16 96       	mov	r6,r11
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
80005a6a:	58 0c       	cp.w	r12,0
80005a6c:	c2 f0       	breq	80005aca <xQueueCreate+0x66>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
80005a6e:	34 cc       	mov	r12,76
80005a70:	f0 1f 00 17 	mcall	80005acc <xQueueCreate+0x68>
80005a74:	18 95       	mov	r5,r12
		if( pxNewQueue != NULL )
80005a76:	c2 a0       	breq	80005aca <xQueueCreate+0x66>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
80005a78:	ec 07 02 44 	mul	r4,r6,r7

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
80005a7c:	e8 cc ff ff 	sub	r12,r4,-1
80005a80:	f0 1f 00 13 	mcall	80005acc <xQueueCreate+0x68>
80005a84:	8b 0c       	st.w	r5[0x0],r12
			if( pxNewQueue->pcHead != NULL )
80005a86:	c1 e0       	breq	80005ac2 <xQueueCreate+0x5e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
80005a88:	f8 04 00 04 	add	r4,r12,r4
80005a8c:	8b 14       	st.w	r5[0x4],r4
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
80005a8e:	30 08       	mov	r8,0
80005a90:	8b e8       	st.w	r5[0x38],r8
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
80005a92:	8b 2c       	st.w	r5[0x8],r12
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
80005a94:	ee c8 00 01 	sub	r8,r7,1
80005a98:	ad 38       	mul	r8,r6
80005a9a:	10 0c       	add	r12,r8
80005a9c:	8b 3c       	st.w	r5[0xc],r12
				pxNewQueue->uxLength = uxQueueLength;
80005a9e:	8b f7       	st.w	r5[0x3c],r7
				pxNewQueue->uxItemSize = uxItemSize;
80005aa0:	eb 46 00 40 	st.w	r5[64],r6
				pxNewQueue->xRxLock = queueUNLOCKED;
80005aa4:	3f f8       	mov	r8,-1
80005aa6:	eb 48 00 44 	st.w	r5[68],r8
				pxNewQueue->xTxLock = queueUNLOCKED;
80005aaa:	eb 48 00 48 	st.w	r5[72],r8

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
80005aae:	ea cc ff f0 	sub	r12,r5,-16
80005ab2:	f0 1f 00 08 	mcall	80005ad0 <xQueueCreate+0x6c>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
80005ab6:	ea cc ff dc 	sub	r12,r5,-36
80005aba:	f0 1f 00 06 	mcall	80005ad0 <xQueueCreate+0x6c>
80005abe:	0a 9c       	mov	r12,r5
80005ac0:	d8 22       	popm	r4-r7,pc
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
80005ac2:	0a 9c       	mov	r12,r5
80005ac4:	f0 1f 00 04 	mcall	80005ad4 <xQueueCreate+0x70>
80005ac8:	d8 2a       	popm	r4-r7,pc,r12=0
80005aca:	d8 2a       	popm	r4-r7,pc,r12=0
80005acc:	80 00       	ld.sh	r0,r0[0x0]
80005ace:	55 b8       	stdsp	sp[0x16c],r8
80005ad0:	80 00       	ld.sh	r0,r0[0x0]
80005ad2:	52 28       	stdsp	sp[0x88],r8
80005ad4:	80 00       	ld.sh	r0,r0[0x0]
80005ad6:	55 90       	stdsp	sp[0x164],r0

80005ad8 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
80005ad8:	48 38       	lddpc	r8,80005ae4 <vTaskSuspendAll+0xc>
80005ada:	70 09       	ld.w	r9,r8[0x0]
80005adc:	2f f9       	sub	r9,-1
80005ade:	91 09       	st.w	r8[0x0],r9
}
80005ae0:	5e fc       	retal	r12
80005ae2:	00 00       	add	r0,r0
80005ae4:	00 00       	add	r0,r0
80005ae6:	0d 38       	ld.ub	r8,r6++

80005ae8 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
80005ae8:	49 a8       	lddpc	r8,80005b50 <vTaskSwitchContext+0x68>
80005aea:	70 08       	ld.w	r8,r8[0x0]
80005aec:	58 08       	cp.w	r8,0
80005aee:	c0 b1       	brne	80005b04 <vTaskSwitchContext+0x1c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80005af0:	49 98       	lddpc	r8,80005b54 <vTaskSwitchContext+0x6c>
80005af2:	70 08       	ld.w	r8,r8[0x0]
80005af4:	f0 08 00 28 	add	r8,r8,r8<<0x2
80005af8:	49 89       	lddpc	r9,80005b58 <vTaskSwitchContext+0x70>
80005afa:	f2 08 03 28 	ld.w	r8,r9[r8<<0x2]
80005afe:	58 08       	cp.w	r8,0
80005b00:	c0 60       	breq	80005b0c <vTaskSwitchContext+0x24>
80005b02:	c1 18       	rjmp	80005b24 <vTaskSwitchContext+0x3c>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
80005b04:	30 19       	mov	r9,1
80005b06:	49 68       	lddpc	r8,80005b5c <vTaskSwitchContext+0x74>
80005b08:	91 09       	st.w	r8[0x0],r9
80005b0a:	5e fc       	retal	r12

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80005b0c:	49 28       	lddpc	r8,80005b54 <vTaskSwitchContext+0x6c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80005b0e:	49 3a       	lddpc	r10,80005b58 <vTaskSwitchContext+0x70>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80005b10:	70 09       	ld.w	r9,r8[0x0]
80005b12:	20 19       	sub	r9,1
80005b14:	91 09       	st.w	r8[0x0],r9

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80005b16:	70 09       	ld.w	r9,r8[0x0]
80005b18:	f2 09 00 29 	add	r9,r9,r9<<0x2
80005b1c:	f4 09 03 29 	ld.w	r9,r10[r9<<0x2]
80005b20:	58 09       	cp.w	r9,0
80005b22:	cf 70       	breq	80005b10 <vTaskSwitchContext+0x28>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
80005b24:	48 c8       	lddpc	r8,80005b54 <vTaskSwitchContext+0x6c>
80005b26:	70 08       	ld.w	r8,r8[0x0]
80005b28:	f0 08 00 28 	add	r8,r8,r8<<0x2
80005b2c:	48 b9       	lddpc	r9,80005b58 <vTaskSwitchContext+0x70>
80005b2e:	f2 08 00 28 	add	r8,r9,r8<<0x2
80005b32:	70 19       	ld.w	r9,r8[0x4]
80005b34:	72 19       	ld.w	r9,r9[0x4]
80005b36:	91 19       	st.w	r8[0x4],r9
80005b38:	f0 ca ff f8 	sub	r10,r8,-8
80005b3c:	14 39       	cp.w	r9,r10
80005b3e:	f3 f9 00 01 	ld.weq	r9,r9[0x4]
80005b42:	f1 f9 0a 01 	st.weq	r8[0x4],r9
80005b46:	70 18       	ld.w	r8,r8[0x4]
80005b48:	70 39       	ld.w	r9,r8[0xc]
80005b4a:	48 68       	lddpc	r8,80005b60 <vTaskSwitchContext+0x78>
80005b4c:	91 09       	st.w	r8[0x0],r9
80005b4e:	5e fc       	retal	r12
80005b50:	00 00       	add	r0,r0
80005b52:	0d 38       	ld.ub	r8,r6++
80005b54:	00 00       	add	r0,r0
80005b56:	0d 70       	ld.ub	r0,--r6
80005b58:	00 00       	add	r0,r0
80005b5a:	0c 54       	eor	r4,r6
80005b5c:	00 00       	add	r0,r0
80005b5e:	0d 58       	ld.sh	r8,--r6
80005b60:	00 00       	add	r0,r0
80005b62:	0d 08       	ld.w	r8,r6++

80005b64 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
80005b64:	48 48       	lddpc	r8,80005b74 <vTaskSetTimeOutState+0x10>
80005b66:	70 08       	ld.w	r8,r8[0x0]
80005b68:	99 08       	st.w	r12[0x0],r8
	pxTimeOut->xTimeOnEntering = xTickCount;
80005b6a:	48 48       	lddpc	r8,80005b78 <vTaskSetTimeOutState+0x14>
80005b6c:	70 08       	ld.w	r8,r8[0x0]
80005b6e:	99 18       	st.w	r12[0x4],r8
}
80005b70:	5e fc       	retal	r12
80005b72:	00 00       	add	r0,r0
80005b74:	00 00       	add	r0,r0
80005b76:	0c 4c       	or	r12,r6
80005b78:	00 00       	add	r0,r0
80005b7a:	0d 34       	ld.ub	r4,r6++

80005b7c <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
80005b7c:	30 19       	mov	r9,1
80005b7e:	48 28       	lddpc	r8,80005b84 <vTaskMissedYield+0x8>
80005b80:	91 09       	st.w	r8[0x0],r9
}
80005b82:	5e fc       	retal	r12
80005b84:	00 00       	add	r0,r0
80005b86:	0d 58       	ld.sh	r8,--r6

80005b88 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
80005b88:	48 28       	lddpc	r8,80005b90 <xTaskGetCurrentTaskHandle+0x8>
80005b8a:	70 0c       	ld.w	r12,r8[0x0]

		return xReturn;
	}
80005b8c:	5e fc       	retal	r12
80005b8e:	00 00       	add	r0,r0
80005b90:	00 00       	add	r0,r0
80005b92:	0d 08       	ld.w	r8,r6++

80005b94 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
80005b94:	eb cd 40 c0 	pushm	r6-r7,lr
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
80005b98:	58 0c       	cp.w	r12,0
80005b9a:	c1 f0       	breq	80005bd8 <vTaskPriorityDisinherit+0x44>

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
80005b9c:	18 97       	mov	r7,r12

		if( pxMutexHolder != NULL )
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
80005b9e:	78 b9       	ld.w	r9,r12[0x2c]
80005ba0:	79 18       	ld.w	r8,r12[0x44]
80005ba2:	10 39       	cp.w	r9,r8
80005ba4:	c1 a0       	breq	80005bd8 <vTaskPriorityDisinherit+0x44>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
80005ba6:	f8 c6 ff fc 	sub	r6,r12,-4
80005baa:	0c 9c       	mov	r12,r6
80005bac:	f0 1f 00 0c 	mcall	80005bdc <vTaskPriorityDisinherit+0x48>

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
80005bb0:	6f 1c       	ld.w	r12,r7[0x44]
80005bb2:	8f bc       	st.w	r7[0x2c],r12
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
80005bb4:	f8 08 11 08 	rsub	r8,r12,8
80005bb8:	8f 68       	st.w	r7[0x18],r8
				prvAddTaskToReadyQueue( pxTCB );
80005bba:	48 a8       	lddpc	r8,80005be0 <vTaskPriorityDisinherit+0x4c>
80005bbc:	70 08       	ld.w	r8,r8[0x0]
80005bbe:	10 3c       	cp.w	r12,r8
80005bc0:	e0 88 00 04 	brls	80005bc8 <vTaskPriorityDisinherit+0x34>
80005bc4:	48 78       	lddpc	r8,80005be0 <vTaskPriorityDisinherit+0x4c>
80005bc6:	91 0c       	st.w	r8[0x0],r12
80005bc8:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005bcc:	0c 9b       	mov	r11,r6
80005bce:	48 68       	lddpc	r8,80005be4 <vTaskPriorityDisinherit+0x50>
80005bd0:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80005bd4:	f0 1f 00 05 	mcall	80005be8 <vTaskPriorityDisinherit+0x54>
80005bd8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005bdc:	80 00       	ld.sh	r0,r0[0x0]
80005bde:	52 92       	stdsp	sp[0xa4],r2
80005be0:	00 00       	add	r0,r0
80005be2:	0d 70       	ld.ub	r0,--r6
80005be4:	00 00       	add	r0,r0
80005be6:	0c 54       	eor	r4,r6
80005be8:	80 00       	ld.sh	r0,r0[0x0]
80005bea:	52 42       	stdsp	sp[0x90],r2

80005bec <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
80005bec:	eb cd 40 c0 	pushm	r6-r7,lr
80005bf0:	18 97       	mov	r7,r12
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
80005bf2:	49 b8       	lddpc	r8,80005c5c <vTaskPriorityInherit+0x70>
80005bf4:	70 08       	ld.w	r8,r8[0x0]
80005bf6:	78 b9       	ld.w	r9,r12[0x2c]
80005bf8:	70 b8       	ld.w	r8,r8[0x2c]
80005bfa:	10 39       	cp.w	r9,r8
80005bfc:	c2 d2       	brcc	80005c56 <vTaskPriorityInherit+0x6a>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
80005bfe:	49 88       	lddpc	r8,80005c5c <vTaskPriorityInherit+0x70>
80005c00:	70 08       	ld.w	r8,r8[0x0]
80005c02:	70 b8       	ld.w	r8,r8[0x2c]
80005c04:	f0 08 11 08 	rsub	r8,r8,8
80005c08:	99 68       	st.w	r12[0x18],r8

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
80005c0a:	f2 09 00 28 	add	r8,r9,r9<<0x2
80005c0e:	49 59       	lddpc	r9,80005c60 <vTaskPriorityInherit+0x74>
80005c10:	f2 08 00 28 	add	r8,r9,r8<<0x2
80005c14:	78 59       	ld.w	r9,r12[0x14]
80005c16:	10 39       	cp.w	r9,r8
80005c18:	c1 b1       	brne	80005c4e <vTaskPriorityInherit+0x62>
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
80005c1a:	f8 c6 ff fc 	sub	r6,r12,-4
80005c1e:	0c 9c       	mov	r12,r6
80005c20:	f0 1f 00 11 	mcall	80005c64 <vTaskPriorityInherit+0x78>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
80005c24:	48 e8       	lddpc	r8,80005c5c <vTaskPriorityInherit+0x70>
80005c26:	70 08       	ld.w	r8,r8[0x0]
80005c28:	70 bc       	ld.w	r12,r8[0x2c]
80005c2a:	8f bc       	st.w	r7[0x2c],r12
				prvAddTaskToReadyQueue( pxTCB );
80005c2c:	48 f8       	lddpc	r8,80005c68 <vTaskPriorityInherit+0x7c>
80005c2e:	70 08       	ld.w	r8,r8[0x0]
80005c30:	10 3c       	cp.w	r12,r8
80005c32:	e0 88 00 04 	brls	80005c3a <vTaskPriorityInherit+0x4e>
80005c36:	48 d8       	lddpc	r8,80005c68 <vTaskPriorityInherit+0x7c>
80005c38:	91 0c       	st.w	r8[0x0],r12
80005c3a:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005c3e:	0c 9b       	mov	r11,r6
80005c40:	48 88       	lddpc	r8,80005c60 <vTaskPriorityInherit+0x74>
80005c42:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80005c46:	f0 1f 00 0a 	mcall	80005c6c <vTaskPriorityInherit+0x80>
80005c4a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
80005c4e:	48 48       	lddpc	r8,80005c5c <vTaskPriorityInherit+0x70>
80005c50:	70 08       	ld.w	r8,r8[0x0]
80005c52:	70 b8       	ld.w	r8,r8[0x2c]
80005c54:	99 b8       	st.w	r12[0x2c],r8
80005c56:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005c5a:	00 00       	add	r0,r0
80005c5c:	00 00       	add	r0,r0
80005c5e:	0d 08       	ld.w	r8,r6++
80005c60:	00 00       	add	r0,r0
80005c62:	0c 54       	eor	r4,r6
80005c64:	80 00       	ld.sh	r0,r0[0x0]
80005c66:	52 92       	stdsp	sp[0xa4],r2
80005c68:	00 00       	add	r0,r0
80005c6a:	0d 70       	ld.ub	r0,--r6
80005c6c:	80 00       	ld.sh	r0,r0[0x0]
80005c6e:	52 42       	stdsp	sp[0x90],r2

80005c70 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
80005c70:	eb cd 40 c0 	pushm	r6-r7,lr
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
80005c74:	78 38       	ld.w	r8,r12[0xc]
80005c76:	70 37       	ld.w	r7,r8[0xc]
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
80005c78:	ee c6 ff e8 	sub	r6,r7,-24
80005c7c:	0c 9c       	mov	r12,r6
80005c7e:	f0 1f 00 15 	mcall	80005cd0 <xTaskRemoveFromEventList+0x60>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80005c82:	49 58       	lddpc	r8,80005cd4 <xTaskRemoveFromEventList+0x64>
80005c84:	70 08       	ld.w	r8,r8[0x0]
80005c86:	58 08       	cp.w	r8,0
80005c88:	c1 71       	brne	80005cb6 <xTaskRemoveFromEventList+0x46>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
80005c8a:	ee c6 ff fc 	sub	r6,r7,-4
80005c8e:	0c 9c       	mov	r12,r6
80005c90:	f0 1f 00 10 	mcall	80005cd0 <xTaskRemoveFromEventList+0x60>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
80005c94:	6e bc       	ld.w	r12,r7[0x2c]
80005c96:	49 18       	lddpc	r8,80005cd8 <xTaskRemoveFromEventList+0x68>
80005c98:	70 08       	ld.w	r8,r8[0x0]
80005c9a:	10 3c       	cp.w	r12,r8
80005c9c:	e0 88 00 04 	brls	80005ca4 <xTaskRemoveFromEventList+0x34>
80005ca0:	48 e8       	lddpc	r8,80005cd8 <xTaskRemoveFromEventList+0x68>
80005ca2:	91 0c       	st.w	r8[0x0],r12
80005ca4:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005ca8:	0c 9b       	mov	r11,r6
80005caa:	48 d8       	lddpc	r8,80005cdc <xTaskRemoveFromEventList+0x6c>
80005cac:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80005cb0:	f0 1f 00 0c 	mcall	80005ce0 <xTaskRemoveFromEventList+0x70>
80005cb4:	c0 58       	rjmp	80005cbe <xTaskRemoveFromEventList+0x4e>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
80005cb6:	0c 9b       	mov	r11,r6
80005cb8:	48 bc       	lddpc	r12,80005ce4 <xTaskRemoveFromEventList+0x74>
80005cba:	f0 1f 00 0a 	mcall	80005ce0 <xTaskRemoveFromEventList+0x70>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
80005cbe:	48 b8       	lddpc	r8,80005ce8 <xTaskRemoveFromEventList+0x78>
80005cc0:	70 08       	ld.w	r8,r8[0x0]
80005cc2:	6e b9       	ld.w	r9,r7[0x2c]
80005cc4:	70 b8       	ld.w	r8,r8[0x2c]
80005cc6:	10 39       	cp.w	r9,r8
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
80005cc8:	5f 2c       	srhs	r12
80005cca:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005cce:	00 00       	add	r0,r0
80005cd0:	80 00       	ld.sh	r0,r0[0x0]
80005cd2:	52 92       	stdsp	sp[0xa4],r2
80005cd4:	00 00       	add	r0,r0
80005cd6:	0d 38       	ld.ub	r8,r6++
80005cd8:	00 00       	add	r0,r0
80005cda:	0d 70       	ld.ub	r0,--r6
80005cdc:	00 00       	add	r0,r0
80005cde:	0c 54       	eor	r4,r6
80005ce0:	80 00       	ld.sh	r0,r0[0x0]
80005ce2:	52 42       	stdsp	sp[0x90],r2
80005ce4:	00 00       	add	r0,r0
80005ce6:	0d 0c       	ld.w	r12,r6++
80005ce8:	00 00       	add	r0,r0
80005cea:	0d 08       	ld.w	r8,r6++

80005cec <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
80005cec:	eb cd 40 fc 	pushm	r2-r7,lr
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80005cf0:	4b 98       	lddpc	r8,80005dd4 <vTaskIncrementTick+0xe8>
80005cf2:	70 08       	ld.w	r8,r8[0x0]
80005cf4:	58 08       	cp.w	r8,0
80005cf6:	c6 91       	brne	80005dc8 <vTaskIncrementTick+0xdc>
	{
		++xTickCount;
80005cf8:	4b 88       	lddpc	r8,80005dd8 <vTaskIncrementTick+0xec>
80005cfa:	70 09       	ld.w	r9,r8[0x0]
80005cfc:	2f f9       	sub	r9,-1
80005cfe:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
80005d00:	70 08       	ld.w	r8,r8[0x0]
80005d02:	58 08       	cp.w	r8,0
80005d04:	c1 a1       	brne	80005d38 <vTaskIncrementTick+0x4c>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
80005d06:	4b 68       	lddpc	r8,80005ddc <vTaskIncrementTick+0xf0>
80005d08:	70 0a       	ld.w	r10,r8[0x0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
80005d0a:	4b 69       	lddpc	r9,80005de0 <vTaskIncrementTick+0xf4>
80005d0c:	72 0b       	ld.w	r11,r9[0x0]
80005d0e:	91 0b       	st.w	r8[0x0],r11
			pxOverflowDelayedTaskList = pxTemp;
80005d10:	93 0a       	st.w	r9[0x0],r10
			xNumOfOverflows++;
80005d12:	4b 59       	lddpc	r9,80005de4 <vTaskIncrementTick+0xf8>
80005d14:	72 0a       	ld.w	r10,r9[0x0]
80005d16:	2f fa       	sub	r10,-1
80005d18:	93 0a       	st.w	r9[0x0],r10

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
80005d1a:	70 08       	ld.w	r8,r8[0x0]
80005d1c:	70 08       	ld.w	r8,r8[0x0]
80005d1e:	58 08       	cp.w	r8,0
80005d20:	c0 51       	brne	80005d2a <vTaskIncrementTick+0x3e>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
80005d22:	3f f9       	mov	r9,-1
80005d24:	4b 18       	lddpc	r8,80005de8 <vTaskIncrementTick+0xfc>
80005d26:	91 09       	st.w	r8[0x0],r9
80005d28:	c0 88       	rjmp	80005d38 <vTaskIncrementTick+0x4c>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
80005d2a:	4a d8       	lddpc	r8,80005ddc <vTaskIncrementTick+0xf0>
80005d2c:	70 08       	ld.w	r8,r8[0x0]
80005d2e:	70 38       	ld.w	r8,r8[0xc]
80005d30:	70 38       	ld.w	r8,r8[0xc]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
80005d32:	70 19       	ld.w	r9,r8[0x4]
80005d34:	4a d8       	lddpc	r8,80005de8 <vTaskIncrementTick+0xfc>
80005d36:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
80005d38:	4a 88       	lddpc	r8,80005dd8 <vTaskIncrementTick+0xec>
80005d3a:	70 09       	ld.w	r9,r8[0x0]
80005d3c:	4a b8       	lddpc	r8,80005de8 <vTaskIncrementTick+0xfc>
80005d3e:	70 08       	ld.w	r8,r8[0x0]
80005d40:	10 39       	cp.w	r9,r8
80005d42:	c4 73       	brcs	80005dd0 <vTaskIncrementTick+0xe4>
80005d44:	4a 68       	lddpc	r8,80005ddc <vTaskIncrementTick+0xf0>
80005d46:	70 08       	ld.w	r8,r8[0x0]
80005d48:	70 08       	ld.w	r8,r8[0x0]
80005d4a:	58 08       	cp.w	r8,0
80005d4c:	c0 c0       	breq	80005d64 <vTaskIncrementTick+0x78>
80005d4e:	4a 48       	lddpc	r8,80005ddc <vTaskIncrementTick+0xf0>
80005d50:	70 08       	ld.w	r8,r8[0x0]
80005d52:	70 38       	ld.w	r8,r8[0xc]
80005d54:	70 37       	ld.w	r7,r8[0xc]
80005d56:	6e 18       	ld.w	r8,r7[0x4]
80005d58:	4a 09       	lddpc	r9,80005dd8 <vTaskIncrementTick+0xec>
80005d5a:	72 09       	ld.w	r9,r9[0x0]
80005d5c:	12 38       	cp.w	r8,r9
80005d5e:	e0 88 00 14 	brls	80005d86 <vTaskIncrementTick+0x9a>
80005d62:	c0 e8       	rjmp	80005d7e <vTaskIncrementTick+0x92>
80005d64:	3f f9       	mov	r9,-1
80005d66:	4a 18       	lddpc	r8,80005de8 <vTaskIncrementTick+0xfc>
80005d68:	91 09       	st.w	r8[0x0],r9
80005d6a:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80005d6e:	6a 08       	ld.w	r8,r5[0x0]
80005d70:	70 38       	ld.w	r8,r8[0xc]
80005d72:	70 37       	ld.w	r7,r8[0xc]
80005d74:	6e 18       	ld.w	r8,r7[0x4]
80005d76:	64 09       	ld.w	r9,r2[0x0]
80005d78:	12 38       	cp.w	r8,r9
80005d7a:	e0 88 00 0a 	brls	80005d8e <vTaskIncrementTick+0xa2>
80005d7e:	49 b9       	lddpc	r9,80005de8 <vTaskIncrementTick+0xfc>
80005d80:	93 08       	st.w	r9[0x0],r8
80005d82:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80005d86:	49 a4       	lddpc	r4,80005dec <vTaskIncrementTick+0x100>
80005d88:	49 a3       	lddpc	r3,80005df0 <vTaskIncrementTick+0x104>
80005d8a:	49 55       	lddpc	r5,80005ddc <vTaskIncrementTick+0xf0>
80005d8c:	49 32       	lddpc	r2,80005dd8 <vTaskIncrementTick+0xec>
80005d8e:	ee c6 ff fc 	sub	r6,r7,-4
80005d92:	0c 9c       	mov	r12,r6
80005d94:	f0 1f 00 18 	mcall	80005df4 <vTaskIncrementTick+0x108>
80005d98:	6e a8       	ld.w	r8,r7[0x28]
80005d9a:	58 08       	cp.w	r8,0
80005d9c:	c0 50       	breq	80005da6 <vTaskIncrementTick+0xba>
80005d9e:	ee cc ff e8 	sub	r12,r7,-24
80005da2:	f0 1f 00 15 	mcall	80005df4 <vTaskIncrementTick+0x108>
80005da6:	6e bc       	ld.w	r12,r7[0x2c]
80005da8:	68 08       	ld.w	r8,r4[0x0]
80005daa:	10 3c       	cp.w	r12,r8
80005dac:	e9 fc ba 00 	st.whi	r4[0x0],r12
80005db0:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005db4:	0c 9b       	mov	r11,r6
80005db6:	e6 0c 00 2c 	add	r12,r3,r12<<0x2
80005dba:	f0 1f 00 10 	mcall	80005df8 <vTaskIncrementTick+0x10c>
80005dbe:	6a 08       	ld.w	r8,r5[0x0]
80005dc0:	70 08       	ld.w	r8,r8[0x0]
80005dc2:	58 08       	cp.w	r8,0
80005dc4:	cd 51       	brne	80005d6e <vTaskIncrementTick+0x82>
80005dc6:	cc fb       	rjmp	80005d64 <vTaskIncrementTick+0x78>
	}
	else
	{
		++uxMissedTicks;
80005dc8:	48 d8       	lddpc	r8,80005dfc <vTaskIncrementTick+0x110>
80005dca:	70 09       	ld.w	r9,r8[0x0]
80005dcc:	2f f9       	sub	r9,-1
80005dce:	91 09       	st.w	r8[0x0],r9
80005dd0:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80005dd4:	00 00       	add	r0,r0
80005dd6:	0d 38       	ld.ub	r8,r6++
80005dd8:	00 00       	add	r0,r0
80005dda:	0d 34       	ld.ub	r4,r6++
80005ddc:	00 00       	add	r0,r0
80005dde:	0c 40       	or	r0,r6
80005de0:	00 00       	add	r0,r0
80005de2:	0c 50       	eor	r0,r6
80005de4:	00 00       	add	r0,r0
80005de6:	0c 4c       	or	r12,r6
80005de8:	00 00       	add	r0,r0
80005dea:	05 34       	ld.ub	r4,r2++
80005dec:	00 00       	add	r0,r0
80005dee:	0d 70       	ld.ub	r0,--r6
80005df0:	00 00       	add	r0,r0
80005df2:	0c 54       	eor	r4,r6
80005df4:	80 00       	ld.sh	r0,r0[0x0]
80005df6:	52 92       	stdsp	sp[0xa4],r2
80005df8:	80 00       	ld.sh	r0,r0[0x0]
80005dfa:	52 42       	stdsp	sp[0x90],r2
80005dfc:	00 00       	add	r0,r0
80005dfe:	0c 38       	cp.w	r8,r6

80005e00 <xTaskCheckForTimeOut>:
	pxTimeOut->xTimeOnEntering = xTickCount;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
80005e00:	eb cd 40 c0 	pushm	r6-r7,lr
80005e04:	18 97       	mov	r7,r12
80005e06:	16 96       	mov	r6,r11
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
80005e08:	f0 1f 00 15 	mcall	80005e5c <xTaskCheckForTimeOut+0x5c>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
80005e0c:	6c 08       	ld.w	r8,r6[0x0]
80005e0e:	5b f8       	cp.w	r8,-1
80005e10:	c0 31       	brne	80005e16 <xTaskCheckForTimeOut+0x16>
80005e12:	30 07       	mov	r7,0
80005e14:	c1 f8       	rjmp	80005e52 <xTaskCheckForTimeOut+0x52>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
80005e16:	49 39       	lddpc	r9,80005e60 <xTaskCheckForTimeOut+0x60>
80005e18:	72 09       	ld.w	r9,r9[0x0]
80005e1a:	6e 0a       	ld.w	r10,r7[0x0]
80005e1c:	12 3a       	cp.w	r10,r9
80005e1e:	c0 70       	breq	80005e2c <xTaskCheckForTimeOut+0x2c>
80005e20:	49 19       	lddpc	r9,80005e64 <xTaskCheckForTimeOut+0x64>
80005e22:	72 09       	ld.w	r9,r9[0x0]
80005e24:	6e 1a       	ld.w	r10,r7[0x4]
80005e26:	12 3a       	cp.w	r10,r9
80005e28:	e0 88 00 14 	brls	80005e50 <xTaskCheckForTimeOut+0x50>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
80005e2c:	48 e9       	lddpc	r9,80005e64 <xTaskCheckForTimeOut+0x64>
80005e2e:	72 0a       	ld.w	r10,r9[0x0]
80005e30:	6e 19       	ld.w	r9,r7[0x4]
80005e32:	12 1a       	sub	r10,r9
80005e34:	14 38       	cp.w	r8,r10
80005e36:	e0 88 00 0d 	brls	80005e50 <xTaskCheckForTimeOut+0x50>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
80005e3a:	48 ba       	lddpc	r10,80005e64 <xTaskCheckForTimeOut+0x64>
80005e3c:	74 0a       	ld.w	r10,r10[0x0]
80005e3e:	14 19       	sub	r9,r10
80005e40:	f2 08 00 08 	add	r8,r9,r8
80005e44:	8d 08       	st.w	r6[0x0],r8
			vTaskSetTimeOutState( pxTimeOut );
80005e46:	0e 9c       	mov	r12,r7
80005e48:	f0 1f 00 08 	mcall	80005e68 <xTaskCheckForTimeOut+0x68>
80005e4c:	30 07       	mov	r7,0
80005e4e:	c0 28       	rjmp	80005e52 <xTaskCheckForTimeOut+0x52>
80005e50:	30 17       	mov	r7,1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
80005e52:	f0 1f 00 07 	mcall	80005e6c <xTaskCheckForTimeOut+0x6c>

	return xReturn;
}
80005e56:	0e 9c       	mov	r12,r7
80005e58:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005e5c:	80 00       	ld.sh	r0,r0[0x0]
80005e5e:	53 4c       	stdsp	sp[0xd0],r12
80005e60:	00 00       	add	r0,r0
80005e62:	0c 4c       	or	r12,r6
80005e64:	00 00       	add	r0,r0
80005e66:	0d 34       	ld.ub	r4,r6++
80005e68:	80 00       	ld.sh	r0,r0[0x0]
80005e6a:	5b 64       	cp.w	r4,-10
80005e6c:	80 00       	ld.sh	r0,r0[0x0]
80005e6e:	54 58       	stdsp	sp[0x114],r8

80005e70 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
80005e70:	eb cd 40 80 	pushm	r7,lr
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
80005e74:	f0 1f 00 05 	mcall	80005e88 <xTaskGetTickCount+0x18>
	{
		xTicks = xTickCount;
80005e78:	48 58       	lddpc	r8,80005e8c <xTaskGetTickCount+0x1c>
80005e7a:	70 07       	ld.w	r7,r8[0x0]
	}
	taskEXIT_CRITICAL();
80005e7c:	f0 1f 00 05 	mcall	80005e90 <xTaskGetTickCount+0x20>

	return xTicks;
}
80005e80:	0e 9c       	mov	r12,r7
80005e82:	e3 cd 80 80 	ldm	sp++,r7,pc
80005e86:	00 00       	add	r0,r0
80005e88:	80 00       	ld.sh	r0,r0[0x0]
80005e8a:	53 4c       	stdsp	sp[0xd0],r12
80005e8c:	00 00       	add	r0,r0
80005e8e:	0d 34       	ld.ub	r4,r6++
80005e90:	80 00       	ld.sh	r0,r0[0x0]
80005e92:	54 58       	stdsp	sp[0x114],r8

80005e94 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
80005e94:	eb cd 40 fe 	pushm	r1-r7,lr
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
80005e98:	f0 1f 00 2c 	mcall	80005f48 <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;
80005e9c:	4a c8       	lddpc	r8,80005f4c <xTaskResumeAll+0xb8>
80005e9e:	70 09       	ld.w	r9,r8[0x0]
80005ea0:	20 19       	sub	r9,1
80005ea2:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80005ea4:	70 08       	ld.w	r8,r8[0x0]
80005ea6:	58 08       	cp.w	r8,0
80005ea8:	c4 91       	brne	80005f3a <xTaskResumeAll+0xa6>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
80005eaa:	4a a8       	lddpc	r8,80005f50 <xTaskResumeAll+0xbc>
80005eac:	70 08       	ld.w	r8,r8[0x0]
80005eae:	58 08       	cp.w	r8,0
80005eb0:	c4 50       	breq	80005f3a <xTaskResumeAll+0xa6>
80005eb2:	30 04       	mov	r4,0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80005eb4:	4a 85       	lddpc	r5,80005f54 <xTaskResumeAll+0xc0>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
80005eb6:	4a 93       	lddpc	r3,80005f58 <xTaskResumeAll+0xc4>
80005eb8:	4a 92       	lddpc	r2,80005f5c <xTaskResumeAll+0xc8>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80005eba:	4a a1       	lddpc	r1,80005f60 <xTaskResumeAll+0xcc>
80005ebc:	c1 e8       	rjmp	80005ef8 <xTaskResumeAll+0x64>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
80005ebe:	6a 38       	ld.w	r8,r5[0xc]
80005ec0:	70 37       	ld.w	r7,r8[0xc]
					vListRemove( &( pxTCB->xEventListItem ) );
80005ec2:	ee cc ff e8 	sub	r12,r7,-24
80005ec6:	f0 1f 00 28 	mcall	80005f64 <xTaskResumeAll+0xd0>
					vListRemove( &( pxTCB->xGenericListItem ) );
80005eca:	ee c6 ff fc 	sub	r6,r7,-4
80005ece:	0c 9c       	mov	r12,r6
80005ed0:	f0 1f 00 25 	mcall	80005f64 <xTaskResumeAll+0xd0>
					prvAddTaskToReadyQueue( pxTCB );
80005ed4:	6e bc       	ld.w	r12,r7[0x2c]
80005ed6:	66 08       	ld.w	r8,r3[0x0]
80005ed8:	10 3c       	cp.w	r12,r8
80005eda:	e7 fc ba 00 	st.whi	r3[0x0],r12
80005ede:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005ee2:	0c 9b       	mov	r11,r6
80005ee4:	e4 0c 00 2c 	add	r12,r2,r12<<0x2
80005ee8:	f0 1f 00 20 	mcall	80005f68 <xTaskResumeAll+0xd4>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80005eec:	62 08       	ld.w	r8,r1[0x0]
80005eee:	6e b9       	ld.w	r9,r7[0x2c]
80005ef0:	70 b8       	ld.w	r8,r8[0x2c]
80005ef2:	10 39       	cp.w	r9,r8
80005ef4:	f9 b4 02 01 	movhs	r4,1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80005ef8:	6a 08       	ld.w	r8,r5[0x0]
80005efa:	58 08       	cp.w	r8,0
80005efc:	ce 11       	brne	80005ebe <xTaskResumeAll+0x2a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80005efe:	49 c8       	lddpc	r8,80005f6c <xTaskResumeAll+0xd8>
80005f00:	70 08       	ld.w	r8,r8[0x0]
80005f02:	58 08       	cp.w	r8,0
80005f04:	c0 f0       	breq	80005f22 <xTaskResumeAll+0x8e>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80005f06:	49 a8       	lddpc	r8,80005f6c <xTaskResumeAll+0xd8>
80005f08:	70 08       	ld.w	r8,r8[0x0]
80005f0a:	58 08       	cp.w	r8,0
80005f0c:	c1 10       	breq	80005f2e <xTaskResumeAll+0x9a>
					{
						vTaskIncrementTick();
						--uxMissedTicks;
80005f0e:	49 87       	lddpc	r7,80005f6c <xTaskResumeAll+0xd8>
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
80005f10:	f0 1f 00 18 	mcall	80005f70 <xTaskResumeAll+0xdc>
						--uxMissedTicks;
80005f14:	6e 08       	ld.w	r8,r7[0x0]
80005f16:	20 18       	sub	r8,1
80005f18:	8f 08       	st.w	r7[0x0],r8
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80005f1a:	6e 08       	ld.w	r8,r7[0x0]
80005f1c:	58 08       	cp.w	r8,0
80005f1e:	cf 91       	brne	80005f10 <xTaskResumeAll+0x7c>
80005f20:	c0 78       	rjmp	80005f2e <xTaskResumeAll+0x9a>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
80005f22:	58 14       	cp.w	r4,1
80005f24:	c0 50       	breq	80005f2e <xTaskResumeAll+0x9a>
80005f26:	49 48       	lddpc	r8,80005f74 <xTaskResumeAll+0xe0>
80005f28:	70 08       	ld.w	r8,r8[0x0]
80005f2a:	58 18       	cp.w	r8,1
80005f2c:	c0 71       	brne	80005f3a <xTaskResumeAll+0xa6>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
80005f2e:	30 09       	mov	r9,0
80005f30:	49 18       	lddpc	r8,80005f74 <xTaskResumeAll+0xe0>
80005f32:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
80005f34:	d7 33       	scall
80005f36:	30 17       	mov	r7,1
80005f38:	c0 28       	rjmp	80005f3c <xTaskResumeAll+0xa8>
80005f3a:	30 07       	mov	r7,0
				}
			}
		}
	}
	taskEXIT_CRITICAL();
80005f3c:	f0 1f 00 0f 	mcall	80005f78 <xTaskResumeAll+0xe4>

	return xAlreadyYielded;
}
80005f40:	0e 9c       	mov	r12,r7
80005f42:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
80005f46:	00 00       	add	r0,r0
80005f48:	80 00       	ld.sh	r0,r0[0x0]
80005f4a:	53 4c       	stdsp	sp[0xd0],r12
80005f4c:	00 00       	add	r0,r0
80005f4e:	0d 38       	ld.ub	r8,r6++
80005f50:	00 00       	add	r0,r0
80005f52:	0d 54       	ld.sh	r4,--r6
80005f54:	00 00       	add	r0,r0
80005f56:	0d 0c       	ld.w	r12,r6++
80005f58:	00 00       	add	r0,r0
80005f5a:	0d 70       	ld.ub	r0,--r6
80005f5c:	00 00       	add	r0,r0
80005f5e:	0c 54       	eor	r4,r6
80005f60:	00 00       	add	r0,r0
80005f62:	0d 08       	ld.w	r8,r6++
80005f64:	80 00       	ld.sh	r0,r0[0x0]
80005f66:	52 92       	stdsp	sp[0xa4],r2
80005f68:	80 00       	ld.sh	r0,r0[0x0]
80005f6a:	52 42       	stdsp	sp[0x90],r2
80005f6c:	00 00       	add	r0,r0
80005f6e:	0c 38       	cp.w	r8,r6
80005f70:	80 00       	ld.sh	r0,r0[0x0]
80005f72:	5c ec       	tnbz	r12
80005f74:	00 00       	add	r0,r0
80005f76:	0d 58       	ld.sh	r8,--r6
80005f78:	80 00       	ld.sh	r0,r0[0x0]
80005f7a:	54 58       	stdsp	sp[0x114],r8

80005f7c <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
80005f7c:	eb cd 40 80 	pushm	r7,lr
80005f80:	18 97       	mov	r7,r12
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
80005f82:	49 08       	lddpc	r8,80005fc0 <prvAddCurrentTaskToDelayedList+0x44>
80005f84:	70 08       	ld.w	r8,r8[0x0]
80005f86:	91 1c       	st.w	r8[0x4],r12

	if( xTimeToWake < xTickCount )
80005f88:	48 f8       	lddpc	r8,80005fc4 <prvAddCurrentTaskToDelayedList+0x48>
80005f8a:	70 08       	ld.w	r8,r8[0x0]
80005f8c:	10 3c       	cp.w	r12,r8
80005f8e:	c0 a2       	brcc	80005fa2 <prvAddCurrentTaskToDelayedList+0x26>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005f90:	48 c8       	lddpc	r8,80005fc0 <prvAddCurrentTaskToDelayedList+0x44>
80005f92:	70 0b       	ld.w	r11,r8[0x0]
80005f94:	48 d8       	lddpc	r8,80005fc8 <prvAddCurrentTaskToDelayedList+0x4c>
80005f96:	70 0c       	ld.w	r12,r8[0x0]
80005f98:	2f cb       	sub	r11,-4
80005f9a:	f0 1f 00 0d 	mcall	80005fcc <prvAddCurrentTaskToDelayedList+0x50>
80005f9e:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005fa2:	48 88       	lddpc	r8,80005fc0 <prvAddCurrentTaskToDelayedList+0x44>
80005fa4:	70 0b       	ld.w	r11,r8[0x0]
80005fa6:	48 b8       	lddpc	r8,80005fd0 <prvAddCurrentTaskToDelayedList+0x54>
80005fa8:	70 0c       	ld.w	r12,r8[0x0]
80005faa:	2f cb       	sub	r11,-4
80005fac:	f0 1f 00 08 	mcall	80005fcc <prvAddCurrentTaskToDelayedList+0x50>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
80005fb0:	48 98       	lddpc	r8,80005fd4 <prvAddCurrentTaskToDelayedList+0x58>
80005fb2:	70 08       	ld.w	r8,r8[0x0]
80005fb4:	10 37       	cp.w	r7,r8
80005fb6:	c0 32       	brcc	80005fbc <prvAddCurrentTaskToDelayedList+0x40>
		{
			xNextTaskUnblockTime = xTimeToWake;
80005fb8:	48 78       	lddpc	r8,80005fd4 <prvAddCurrentTaskToDelayedList+0x58>
80005fba:	91 07       	st.w	r8[0x0],r7
80005fbc:	e3 cd 80 80 	ldm	sp++,r7,pc
80005fc0:	00 00       	add	r0,r0
80005fc2:	0d 08       	ld.w	r8,r6++
80005fc4:	00 00       	add	r0,r0
80005fc6:	0d 34       	ld.ub	r4,r6++
80005fc8:	00 00       	add	r0,r0
80005fca:	0c 50       	eor	r0,r6
80005fcc:	80 00       	ld.sh	r0,r0[0x0]
80005fce:	52 5e       	stdsp	sp[0x94],lr
80005fd0:	00 00       	add	r0,r0
80005fd2:	0c 40       	or	r0,r6
80005fd4:	00 00       	add	r0,r0
80005fd6:	05 34       	ld.ub	r4,r2++

80005fd8 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
80005fd8:	eb cd 40 c0 	pushm	r6-r7,lr
80005fdc:	18 96       	mov	r6,r12
80005fde:	16 97       	mov	r7,r11
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0 ) );

		vTaskSuspendAll();
80005fe0:	f0 1f 00 18 	mcall	80006040 <vTaskDelayUntil+0x68>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
80005fe4:	6c 08       	ld.w	r8,r6[0x0]
80005fe6:	10 07       	add	r7,r8

			if( xTickCount < *pxPreviousWakeTime )
80005fe8:	49 79       	lddpc	r9,80006044 <vTaskDelayUntil+0x6c>
80005fea:	72 09       	ld.w	r9,r9[0x0]
80005fec:	12 38       	cp.w	r8,r9
80005fee:	e0 88 00 0c 	brls	80006006 <vTaskDelayUntil+0x2e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
80005ff2:	0e 38       	cp.w	r8,r7
80005ff4:	e0 88 00 22 	brls	80006038 <vTaskDelayUntil+0x60>
80005ff8:	49 38       	lddpc	r8,80006044 <vTaskDelayUntil+0x6c>
80005ffa:	70 08       	ld.w	r8,r8[0x0]
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80005ffc:	8d 07       	st.w	r6[0x0],r7

			if( xShouldDelay != pdFALSE )
80005ffe:	10 37       	cp.w	r7,r8
80006000:	e0 88 00 14 	brls	80006028 <vTaskDelayUntil+0x50>
80006004:	c0 a8       	rjmp	80006018 <vTaskDelayUntil+0x40>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
80006006:	0e 38       	cp.w	r8,r7
80006008:	e0 8b 00 16 	brhi	80006034 <vTaskDelayUntil+0x5c>
8000600c:	48 e8       	lddpc	r8,80006044 <vTaskDelayUntil+0x6c>
8000600e:	70 08       	ld.w	r8,r8[0x0]
80006010:	10 37       	cp.w	r7,r8
80006012:	e0 8b 00 11 	brhi	80006034 <vTaskDelayUntil+0x5c>
80006016:	c1 18       	rjmp	80006038 <vTaskDelayUntil+0x60>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006018:	48 c8       	lddpc	r8,80006048 <vTaskDelayUntil+0x70>
8000601a:	70 0c       	ld.w	r12,r8[0x0]
8000601c:	2f cc       	sub	r12,-4
8000601e:	f0 1f 00 0c 	mcall	8000604c <vTaskDelayUntil+0x74>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
80006022:	0e 9c       	mov	r12,r7
80006024:	f0 1f 00 0b 	mcall	80006050 <vTaskDelayUntil+0x78>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
80006028:	f0 1f 00 0b 	mcall	80006054 <vTaskDelayUntil+0x7c>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
8000602c:	c0 81       	brne	8000603c <vTaskDelayUntil+0x64>
		{
			portYIELD_WITHIN_API();
8000602e:	d7 33       	scall
80006030:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80006034:	8d 07       	st.w	r6[0x0],r7
80006036:	cf 1b       	rjmp	80006018 <vTaskDelayUntil+0x40>
80006038:	8d 07       	st.w	r6[0x0],r7
8000603a:	cf 7b       	rjmp	80006028 <vTaskDelayUntil+0x50>
8000603c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006040:	80 00       	ld.sh	r0,r0[0x0]
80006042:	5a d8       	cp.w	r8,-19
80006044:	00 00       	add	r0,r0
80006046:	0d 34       	ld.ub	r4,r6++
80006048:	00 00       	add	r0,r0
8000604a:	0d 08       	ld.w	r8,r6++
8000604c:	80 00       	ld.sh	r0,r0[0x0]
8000604e:	52 92       	stdsp	sp[0xa4],r2
80006050:	80 00       	ld.sh	r0,r0[0x0]
80006052:	5f 7c       	srpl	r12
80006054:	80 00       	ld.sh	r0,r0[0x0]
80006056:	5e 94       	retgt	r4

80006058 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
80006058:	eb cd 40 c0 	pushm	r6-r7,lr
8000605c:	16 96       	mov	r6,r11
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
8000605e:	48 e7       	lddpc	r7,80006094 <vTaskPlaceOnEventList+0x3c>
80006060:	6e 0b       	ld.w	r11,r7[0x0]
80006062:	2e 8b       	sub	r11,-24
80006064:	f0 1f 00 0d 	mcall	80006098 <vTaskPlaceOnEventList+0x40>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006068:	6e 0c       	ld.w	r12,r7[0x0]
8000606a:	2f cc       	sub	r12,-4
8000606c:	f0 1f 00 0c 	mcall	8000609c <vTaskPlaceOnEventList+0x44>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
80006070:	5b f6       	cp.w	r6,-1
80006072:	c0 81       	brne	80006082 <vTaskPlaceOnEventList+0x2a>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006074:	6e 0b       	ld.w	r11,r7[0x0]
80006076:	2f cb       	sub	r11,-4
80006078:	48 ac       	lddpc	r12,800060a0 <vTaskPlaceOnEventList+0x48>
8000607a:	f0 1f 00 0b 	mcall	800060a4 <vTaskPlaceOnEventList+0x4c>
8000607e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
80006082:	48 a8       	lddpc	r8,800060a8 <vTaskPlaceOnEventList+0x50>
80006084:	70 0c       	ld.w	r12,r8[0x0]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
80006086:	ec 0c 00 0c 	add	r12,r6,r12
8000608a:	f0 1f 00 09 	mcall	800060ac <vTaskPlaceOnEventList+0x54>
8000608e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006092:	00 00       	add	r0,r0
80006094:	00 00       	add	r0,r0
80006096:	0d 08       	ld.w	r8,r6++
80006098:	80 00       	ld.sh	r0,r0[0x0]
8000609a:	52 5e       	stdsp	sp[0x94],lr
8000609c:	80 00       	ld.sh	r0,r0[0x0]
8000609e:	52 92       	stdsp	sp[0xa4],r2
800060a0:	00 00       	add	r0,r0
800060a2:	0d 5c       	ld.sh	r12,--r6
800060a4:	80 00       	ld.sh	r0,r0[0x0]
800060a6:	52 42       	stdsp	sp[0x90],r2
800060a8:	00 00       	add	r0,r0
800060aa:	0d 34       	ld.ub	r4,r6++
800060ac:	80 00       	ld.sh	r0,r0[0x0]
800060ae:	5f 7c       	srpl	r12

800060b0 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
800060b0:	eb cd 40 f8 	pushm	r3-r7,lr
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
800060b4:	49 67       	lddpc	r7,8000610c <prvIdleTask+0x5c>
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
800060b6:	49 74       	lddpc	r4,80006110 <prvIdleTask+0x60>

				taskENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					--uxCurrentNumberOfTasks;
800060b8:	49 73       	lddpc	r3,80006114 <prvIdleTask+0x64>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
800060ba:	49 85       	lddpc	r5,80006118 <prvIdleTask+0x68>
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
800060bc:	6e 08       	ld.w	r8,r7[0x0]
800060be:	58 08       	cp.w	r8,0
800060c0:	c1 e0       	breq	800060fc <prvIdleTask+0x4c>
		{
			vTaskSuspendAll();
800060c2:	f0 1f 00 17 	mcall	8000611c <prvIdleTask+0x6c>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
800060c6:	68 06       	ld.w	r6,r4[0x0]
			xTaskResumeAll();
800060c8:	f0 1f 00 16 	mcall	80006120 <prvIdleTask+0x70>

			if( xListIsEmpty == pdFALSE )
800060cc:	58 06       	cp.w	r6,0
800060ce:	c1 70       	breq	800060fc <prvIdleTask+0x4c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
800060d0:	f0 1f 00 15 	mcall	80006124 <prvIdleTask+0x74>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
800060d4:	68 38       	ld.w	r8,r4[0xc]
800060d6:	70 36       	ld.w	r6,r8[0xc]
					vListRemove( &( pxTCB->xGenericListItem ) );
800060d8:	ec cc ff fc 	sub	r12,r6,-4
800060dc:	f0 1f 00 13 	mcall	80006128 <prvIdleTask+0x78>
					--uxCurrentNumberOfTasks;
800060e0:	66 08       	ld.w	r8,r3[0x0]
800060e2:	20 18       	sub	r8,1
800060e4:	87 08       	st.w	r3[0x0],r8
					--uxTasksDeleted;
800060e6:	6e 08       	ld.w	r8,r7[0x0]
800060e8:	20 18       	sub	r8,1
800060ea:	8f 08       	st.w	r7[0x0],r8
				}
				taskEXIT_CRITICAL();
800060ec:	f0 1f 00 10 	mcall	8000612c <prvIdleTask+0x7c>

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
800060f0:	6c cc       	ld.w	r12,r6[0x30]
800060f2:	f0 1f 00 10 	mcall	80006130 <prvIdleTask+0x80>
		vPortFree( pxTCB );
800060f6:	0c 9c       	mov	r12,r6
800060f8:	f0 1f 00 0e 	mcall	80006130 <prvIdleTask+0x80>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
800060fc:	6a 08       	ld.w	r8,r5[0x0]
800060fe:	58 18       	cp.w	r8,1
80006100:	e0 88 00 03 	brls	80006106 <prvIdleTask+0x56>
			{
				taskYIELD();
80006104:	d7 33       	scall
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
80006106:	f0 1f 00 0c 	mcall	80006134 <prvIdleTask+0x84>
		}
		#endif
	}
8000610a:	cd 9b       	rjmp	800060bc <prvIdleTask+0xc>
8000610c:	00 00       	add	r0,r0
8000610e:	0c 48       	or	r8,r6
80006110:	00 00       	add	r0,r0
80006112:	0c f4       	st.b	--r6,r4
80006114:	00 00       	add	r0,r0
80006116:	0d 54       	ld.sh	r4,--r6
80006118:	00 00       	add	r0,r0
8000611a:	0c 54       	eor	r4,r6
8000611c:	80 00       	ld.sh	r0,r0[0x0]
8000611e:	5a d8       	cp.w	r8,-19
80006120:	80 00       	ld.sh	r0,r0[0x0]
80006122:	5e 94       	retgt	r4
80006124:	80 00       	ld.sh	r0,r0[0x0]
80006126:	53 4c       	stdsp	sp[0xd0],r12
80006128:	80 00       	ld.sh	r0,r0[0x0]
8000612a:	52 92       	stdsp	sp[0xa4],r2
8000612c:	80 00       	ld.sh	r0,r0[0x0]
8000612e:	54 58       	stdsp	sp[0x114],r8
80006130:	80 00       	ld.sh	r0,r0[0x0]
80006132:	55 90       	stdsp	sp[0x164],r0
80006134:	80 00       	ld.sh	r0,r0[0x0]
80006136:	20 30       	sub	r0,3

80006138 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
80006138:	d4 31       	pushm	r0-r7,lr
8000613a:	20 1d       	sub	sp,4
8000613c:	fa c4 ff d8 	sub	r4,sp,-40
80006140:	50 0c       	stdsp	sp[0x0],r12
80006142:	16 91       	mov	r1,r11
80006144:	14 97       	mov	r7,r10
80006146:	12 90       	mov	r0,r9
80006148:	10 93       	mov	r3,r8
8000614a:	68 02       	ld.w	r2,r4[0x0]
8000614c:	68 16       	ld.w	r6,r4[0x4]
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
8000614e:	34 8c       	mov	r12,72
80006150:	f0 1f 00 5c 	mcall	800062c0 <xTaskGenericCreate+0x188>
80006154:	18 95       	mov	r5,r12

	if( pxNewTCB != NULL )
80006156:	c0 31       	brne	8000615c <xTaskGenericCreate+0x24>
80006158:	3f fc       	mov	r12,-1
8000615a:	ca f8       	rjmp	800062b8 <xTaskGenericCreate+0x180>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
8000615c:	58 06       	cp.w	r6,0
8000615e:	e0 81 00 af 	brne	800062bc <xTaskGenericCreate+0x184>
80006162:	0e 9c       	mov	r12,r7
80006164:	5c 7c       	castu.h	r12
80006166:	a3 6c       	lsl	r12,0x2
80006168:	f0 1f 00 56 	mcall	800062c0 <xTaskGenericCreate+0x188>
8000616c:	18 96       	mov	r6,r12
8000616e:	8b cc       	st.w	r5[0x30],r12

		if( pxNewTCB->pxStack == NULL )
80006170:	c0 61       	brne	8000617c <xTaskGenericCreate+0x44>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
80006172:	0a 9c       	mov	r12,r5
80006174:	f0 1f 00 54 	mcall	800062c4 <xTaskGenericCreate+0x18c>
80006178:	3f fc       	mov	r12,-1
8000617a:	c9 f8       	rjmp	800062b8 <xTaskGenericCreate+0x180>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
8000617c:	5c 77       	castu.h	r7
8000617e:	ee 0a 15 02 	lsl	r10,r7,0x2
80006182:	e0 6b 00 a5 	mov	r11,165
80006186:	0c 9c       	mov	r12,r6
80006188:	f0 1f 00 50 	mcall	800062c8 <xTaskGenericCreate+0x190>
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
8000618c:	ee c6 00 01 	sub	r6,r7,1
80006190:	6a c8       	ld.w	r8,r5[0x30]
80006192:	f0 06 00 26 	add	r6,r8,r6<<0x2
80006196:	e0 16 ff fc 	andl	r6,0xfffc
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
8000619a:	31 0a       	mov	r10,16
8000619c:	02 9b       	mov	r11,r1
8000619e:	ea cc ff cc 	sub	r12,r5,-52
800061a2:	f0 1f 00 4b 	mcall	800062cc <xTaskGenericCreate+0x194>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
800061a6:	30 08       	mov	r8,0
800061a8:	eb 68 00 43 	st.b	r5[67],r8
800061ac:	58 73       	cp.w	r3,7
800061ae:	e6 07 17 80 	movls	r7,r3
800061b2:	f9 b7 0b 07 	movhi	r7,7
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
800061b6:	8b b7       	st.w	r5[0x2c],r7
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
800061b8:	eb 47 00 44 	st.w	r5[68],r7
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
800061bc:	ea c4 ff fc 	sub	r4,r5,-4
800061c0:	08 9c       	mov	r12,r4
800061c2:	f0 1f 00 44 	mcall	800062d0 <xTaskGenericCreate+0x198>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
800061c6:	ea cc ff e8 	sub	r12,r5,-24
800061ca:	f0 1f 00 42 	mcall	800062d0 <xTaskGenericCreate+0x198>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
800061ce:	8b 45       	st.w	r5[0x10],r5

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
800061d0:	ee 07 11 08 	rsub	r7,r7,8
800061d4:	8b 67       	st.w	r5[0x18],r7
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
800061d6:	8b 95       	st.w	r5[0x24],r5
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
800061d8:	00 9a       	mov	r10,r0
800061da:	40 0b       	lddsp	r11,sp[0x0]
800061dc:	0c 9c       	mov	r12,r6
800061de:	f0 1f 00 3e 	mcall	800062d4 <xTaskGenericCreate+0x19c>
800061e2:	8b 0c       	st.w	r5[0x0],r12
		if( ( void * ) pxCreatedTask != NULL )
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
800061e4:	58 02       	cp.w	r2,0
800061e6:	e5 f5 1a 00 	st.wne	r2[0x0],r5
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
800061ea:	f0 1f 00 3c 	mcall	800062d8 <xTaskGenericCreate+0x1a0>
		{
			uxCurrentNumberOfTasks++;
800061ee:	4b c8       	lddpc	r8,800062dc <xTaskGenericCreate+0x1a4>
800061f0:	70 09       	ld.w	r9,r8[0x0]
800061f2:	2f f9       	sub	r9,-1
800061f4:	91 09       	st.w	r8[0x0],r9
			if( pxCurrentTCB == NULL )
800061f6:	4b b8       	lddpc	r8,800062e0 <xTaskGenericCreate+0x1a8>
800061f8:	70 08       	ld.w	r8,r8[0x0]
800061fa:	58 08       	cp.w	r8,0
800061fc:	c2 61       	brne	80006248 <xTaskGenericCreate+0x110>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
800061fe:	4b 98       	lddpc	r8,800062e0 <xTaskGenericCreate+0x1a8>
80006200:	91 05       	st.w	r8[0x0],r5

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
80006202:	4b 78       	lddpc	r8,800062dc <xTaskGenericCreate+0x1a4>
80006204:	70 08       	ld.w	r8,r8[0x0]
80006206:	58 18       	cp.w	r8,1
80006208:	c2 b1       	brne	8000625e <xTaskGenericCreate+0x126>
8000620a:	4b 77       	lddpc	r7,800062e4 <xTaskGenericCreate+0x1ac>

/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
8000620c:	ee c6 ff 60 	sub	r6,r7,-160
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
80006210:	0e 9c       	mov	r12,r7
80006212:	f0 1f 00 36 	mcall	800062e8 <xTaskGenericCreate+0x1b0>
80006216:	2e c7       	sub	r7,-20

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
80006218:	0c 37       	cp.w	r7,r6
8000621a:	cf b1       	brne	80006210 <xTaskGenericCreate+0xd8>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
8000621c:	4b 47       	lddpc	r7,800062ec <xTaskGenericCreate+0x1b4>
8000621e:	0e 9c       	mov	r12,r7
80006220:	f0 1f 00 32 	mcall	800062e8 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
80006224:	4b 36       	lddpc	r6,800062f0 <xTaskGenericCreate+0x1b8>
80006226:	0c 9c       	mov	r12,r6
80006228:	f0 1f 00 30 	mcall	800062e8 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xPendingReadyList );
8000622c:	4b 2c       	lddpc	r12,800062f4 <xTaskGenericCreate+0x1bc>
8000622e:	f0 1f 00 2f 	mcall	800062e8 <xTaskGenericCreate+0x1b0>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
80006232:	4b 2c       	lddpc	r12,800062f8 <xTaskGenericCreate+0x1c0>
80006234:	f0 1f 00 2d 	mcall	800062e8 <xTaskGenericCreate+0x1b0>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
80006238:	4b 1c       	lddpc	r12,800062fc <xTaskGenericCreate+0x1c4>
8000623a:	f0 1f 00 2c 	mcall	800062e8 <xTaskGenericCreate+0x1b0>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
8000623e:	4b 18       	lddpc	r8,80006300 <xTaskGenericCreate+0x1c8>
80006240:	91 07       	st.w	r8[0x0],r7
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
80006242:	4b 18       	lddpc	r8,80006304 <xTaskGenericCreate+0x1cc>
80006244:	91 06       	st.w	r8[0x0],r6
80006246:	c0 c8       	rjmp	8000625e <xTaskGenericCreate+0x126>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
80006248:	4b 08       	lddpc	r8,80006308 <xTaskGenericCreate+0x1d0>
8000624a:	70 08       	ld.w	r8,r8[0x0]
8000624c:	58 08       	cp.w	r8,0
8000624e:	c0 81       	brne	8000625e <xTaskGenericCreate+0x126>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
80006250:	4a 48       	lddpc	r8,800062e0 <xTaskGenericCreate+0x1a8>
80006252:	70 08       	ld.w	r8,r8[0x0]
80006254:	70 b8       	ld.w	r8,r8[0x2c]
80006256:	10 33       	cp.w	r3,r8
80006258:	c0 33       	brcs	8000625e <xTaskGenericCreate+0x126>
					{
						pxCurrentTCB = pxNewTCB;
8000625a:	4a 28       	lddpc	r8,800062e0 <xTaskGenericCreate+0x1a8>
8000625c:	91 05       	st.w	r8[0x0],r5
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
8000625e:	6a b8       	ld.w	r8,r5[0x2c]
80006260:	4a b9       	lddpc	r9,8000630c <xTaskGenericCreate+0x1d4>
80006262:	72 09       	ld.w	r9,r9[0x0]
80006264:	12 38       	cp.w	r8,r9
80006266:	e0 88 00 04 	brls	8000626e <xTaskGenericCreate+0x136>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
8000626a:	4a 99       	lddpc	r9,8000630c <xTaskGenericCreate+0x1d4>
8000626c:	93 08       	st.w	r9[0x0],r8
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
8000626e:	4a 98       	lddpc	r8,80006310 <xTaskGenericCreate+0x1d8>
80006270:	70 09       	ld.w	r9,r8[0x0]
80006272:	2f f9       	sub	r9,-1
80006274:	91 09       	st.w	r8[0x0],r9

			prvAddTaskToReadyQueue( pxNewTCB );
80006276:	6a b8       	ld.w	r8,r5[0x2c]
80006278:	4a 79       	lddpc	r9,80006314 <xTaskGenericCreate+0x1dc>
8000627a:	72 09       	ld.w	r9,r9[0x0]
8000627c:	12 38       	cp.w	r8,r9
8000627e:	e0 88 00 04 	brls	80006286 <xTaskGenericCreate+0x14e>
80006282:	4a 59       	lddpc	r9,80006314 <xTaskGenericCreate+0x1dc>
80006284:	93 08       	st.w	r9[0x0],r8
80006286:	6a bc       	ld.w	r12,r5[0x2c]
80006288:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
8000628c:	08 9b       	mov	r11,r4
8000628e:	49 68       	lddpc	r8,800062e4 <xTaskGenericCreate+0x1ac>
80006290:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80006294:	f0 1f 00 21 	mcall	80006318 <xTaskGenericCreate+0x1e0>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
80006298:	f0 1f 00 21 	mcall	8000631c <xTaskGenericCreate+0x1e4>
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
8000629c:	49 b8       	lddpc	r8,80006308 <xTaskGenericCreate+0x1d0>
8000629e:	70 08       	ld.w	r8,r8[0x0]
800062a0:	58 08       	cp.w	r8,0
800062a2:	c0 a0       	breq	800062b6 <xTaskGenericCreate+0x17e>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
800062a4:	48 f8       	lddpc	r8,800062e0 <xTaskGenericCreate+0x1a8>
800062a6:	70 08       	ld.w	r8,r8[0x0]
800062a8:	70 b8       	ld.w	r8,r8[0x2c]
800062aa:	10 33       	cp.w	r3,r8
800062ac:	e0 88 00 05 	brls	800062b6 <xTaskGenericCreate+0x17e>
			{
				portYIELD_WITHIN_API();
800062b0:	d7 33       	scall
800062b2:	30 1c       	mov	r12,1
800062b4:	c0 28       	rjmp	800062b8 <xTaskGenericCreate+0x180>
800062b6:	30 1c       	mov	r12,1
			}
		}
	}

	return xReturn;
}
800062b8:	2f fd       	sub	sp,-4
800062ba:	d8 32       	popm	r0-r7,pc
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
800062bc:	99 c6       	st.w	r12[0x30],r6
800062be:	c5 fb       	rjmp	8000617c <xTaskGenericCreate+0x44>
800062c0:	80 00       	ld.sh	r0,r0[0x0]
800062c2:	55 b8       	stdsp	sp[0x16c],r8
800062c4:	80 00       	ld.sh	r0,r0[0x0]
800062c6:	55 90       	stdsp	sp[0x164],r0
800062c8:	80 00       	ld.sh	r0,r0[0x0]
800062ca:	6f a4       	ld.w	r4,r7[0x68]
800062cc:	80 00       	ld.sh	r0,r0[0x0]
800062ce:	72 e8       	ld.w	r8,r9[0x38]
800062d0:	80 00       	ld.sh	r0,r0[0x0]
800062d2:	52 3c       	stdsp	sp[0x8c],r12
800062d4:	80 00       	ld.sh	r0,r0[0x0]
800062d6:	52 b8       	stdsp	sp[0xac],r8
800062d8:	80 00       	ld.sh	r0,r0[0x0]
800062da:	53 4c       	stdsp	sp[0xd0],r12
800062dc:	00 00       	add	r0,r0
800062de:	0d 54       	ld.sh	r4,--r6
800062e0:	00 00       	add	r0,r0
800062e2:	0d 08       	ld.w	r8,r6++
800062e4:	00 00       	add	r0,r0
800062e6:	0c 54       	eor	r4,r6
800062e8:	80 00       	ld.sh	r0,r0[0x0]
800062ea:	52 28       	stdsp	sp[0x88],r8
800062ec:	00 00       	add	r0,r0
800062ee:	0d 20       	ld.uh	r0,r6++
800062f0:	00 00       	add	r0,r0
800062f2:	0d 3c       	ld.ub	r12,r6++
800062f4:	00 00       	add	r0,r0
800062f6:	0d 0c       	ld.w	r12,r6++
800062f8:	00 00       	add	r0,r0
800062fa:	0c f4       	st.b	--r6,r4
800062fc:	00 00       	add	r0,r0
800062fe:	0d 5c       	ld.sh	r12,--r6
80006300:	00 00       	add	r0,r0
80006302:	0c 40       	or	r0,r6
80006304:	00 00       	add	r0,r0
80006306:	0c 50       	eor	r0,r6
80006308:	00 00       	add	r0,r0
8000630a:	0c 44       	or	r4,r6
8000630c:	00 00       	add	r0,r0
8000630e:	0c 3c       	cp.w	r12,r6
80006310:	00 00       	add	r0,r0
80006312:	0d 50       	ld.sh	r0,--r6
80006314:	00 00       	add	r0,r0
80006316:	0d 70       	ld.ub	r0,--r6
80006318:	80 00       	ld.sh	r0,r0[0x0]
8000631a:	52 42       	stdsp	sp[0x90],r2
8000631c:	80 00       	ld.sh	r0,r0[0x0]
8000631e:	54 58       	stdsp	sp[0x114],r8

80006320 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
80006320:	d4 01       	pushm	lr
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
80006322:	30 09       	mov	r9,0
80006324:	1a d9       	st.w	--sp,r9
80006326:	1a d9       	st.w	--sp,r9
80006328:	1a d9       	st.w	--sp,r9
8000632a:	12 98       	mov	r8,r9
8000632c:	e0 6a 01 00 	mov	r10,256
80006330:	48 9b       	lddpc	r11,80006354 <vTaskStartScheduler+0x34>
80006332:	48 ac       	lddpc	r12,80006358 <vTaskStartScheduler+0x38>
80006334:	f0 1f 00 0a 	mcall	8000635c <vTaskStartScheduler+0x3c>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
80006338:	2f dd       	sub	sp,-12
8000633a:	58 1c       	cp.w	r12,1
8000633c:	c0 a1       	brne	80006350 <vTaskStartScheduler+0x30>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
8000633e:	d3 03       	ssrf	0x10

		xSchedulerRunning = pdTRUE;
80006340:	30 19       	mov	r9,1
80006342:	48 88       	lddpc	r8,80006360 <vTaskStartScheduler+0x40>
80006344:	91 09       	st.w	r8[0x0],r9
		xTickCount = ( portTickType ) 0;
80006346:	30 09       	mov	r9,0
80006348:	48 78       	lddpc	r8,80006364 <vTaskStartScheduler+0x44>
8000634a:	91 09       	st.w	r8[0x0],r9
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
8000634c:	f0 1f 00 07 	mcall	80006368 <vTaskStartScheduler+0x48>
80006350:	d8 02       	popm	pc
80006352:	00 00       	add	r0,r0
80006354:	80 00       	ld.sh	r0,r0[0x0]
80006356:	d4 c8       	*unknown*
80006358:	80 00       	ld.sh	r0,r0[0x0]
8000635a:	60 b0       	ld.w	r0,r0[0x2c]
8000635c:	80 00       	ld.sh	r0,r0[0x0]
8000635e:	61 38       	ld.w	r8,r0[0x4c]
80006360:	00 00       	add	r0,r0
80006362:	0c 44       	or	r4,r6
80006364:	00 00       	add	r0,r0
80006366:	0d 34       	ld.ub	r4,r6++
80006368:	80 00       	ld.sh	r0,r0[0x0]
8000636a:	53 5c       	stdsp	sp[0xd4],r12

8000636c <PrintChar>:
	
static void task_log(void * pvParameters);

char *  PrintChar(char c, char * str)
{
	*str++ = c;
8000636c:	16 cc       	st.b	r11++,r12
	return str;
}
8000636e:	5e fb       	retal	r11

80006370 <PrintHex>:
	
	return str;
}

char * PrintHex(int i,char len, char * str)
{
80006370:	eb cd 40 c0 	pushm	r6-r7,lr
80006374:	20 3d       	sub	sp,12
80006376:	18 98       	mov	r8,r12
	char * p = str;
	char s[12];
	memset(s, 0 , 12);
80006378:	30 06       	mov	r6,0
8000637a:	30 07       	mov	r7,0
8000637c:	fa e7 00 00 	st.d	sp[0],r6
80006380:	30 0c       	mov	r12,0
80006382:	50 2c       	stdsp	sp[0x8],r12
	int cnt=0;
	
	if(i)
80006384:	58 08       	cp.w	r8,0
80006386:	c1 30       	breq	800063ac <PrintHex+0x3c>
80006388:	18 99       	mov	r9,r12
	while(i)
	{
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
8000638a:	1a 9c       	mov	r12,sp
8000638c:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80006390:	58 9e       	cp.w	lr,9
80006392:	e0 8a 00 04 	brle	8000639a <PrintHex+0x2a>
80006396:	2c 9e       	sub	lr,-55
80006398:	c0 48       	rjmp	800063a0 <PrintHex+0x30>
8000639a:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
8000639e:	2d 0e       	sub	lr,-48
800063a0:	f8 09 0b 0e 	st.b	r12[r9],lr
800063a4:	2f f9       	sub	r9,-1
		i = (i >> 4 ) & 0x0FFFFFFF;
800063a6:	a5 88       	lsr	r8,0x4
	char s[12];
	memset(s, 0 , 12);
	int cnt=0;
	
	if(i)
	while(i)
800063a8:	cf 21       	brne	8000638c <PrintHex+0x1c>
800063aa:	c0 48       	rjmp	800063b2 <PrintHex+0x42>
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
		i = (i >> 4 ) & 0x0FFFFFFF;
		//i >>= 4
	}
	else
	s[cnt++] = '0';
800063ac:	33 08       	mov	r8,48
800063ae:	ba 88       	st.b	sp[0x0],r8
800063b0:	30 19       	mov	r9,1
	
	if(len - cnt > 0 )
800063b2:	f6 09 01 08 	sub	r8,r11,r9
800063b6:	58 08       	cp.w	r8,0
800063b8:	e0 8a 00 13 	brle	800063de <PrintHex+0x6e>
	{
		char num = len - cnt;
800063bc:	12 1b       	sub	r11,r9
800063be:	f9 db c0 08 	bfextu	r12,r11,0x0,0x8
		for(int i = 0; i < num; i++)
800063c2:	18 9e       	mov	lr,r12
800063c4:	58 0c       	cp.w	r12,0
800063c6:	e0 8a 00 0c 	brle	800063de <PrintHex+0x6e>
800063ca:	1a 9b       	mov	r11,sp
800063cc:	12 0b       	add	r11,r9
800063ce:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
800063d0:	33 07       	mov	r7,48
800063d2:	16 c7       	st.b	r11++,r7
	s[cnt++] = '0';
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
800063d4:	2f f8       	sub	r8,-1
800063d6:	1c 38       	cp.w	r8,lr
800063d8:	cf d5       	brlt	800063d2 <PrintHex+0x62>
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
800063da:	f8 09 00 09 	add	r9,r12,r9
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
800063de:	f2 c8 ff ff 	sub	r8,r9,-1
	s[cnt++] = '0';
	
	while(cnt>0)
800063e2:	f0 cb ff ff 	sub	r11,r8,-1
800063e6:	58 0b       	cp.w	r11,0
800063e8:	e0 8a 00 19 	brle	8000641a <PrintHex+0xaa>
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
800063ec:	fa cb ff f4 	sub	r11,sp,-12
800063f0:	f6 09 00 09 	add	r9,r11,r9
800063f4:	37 8b       	mov	r11,120
800063f6:	f3 6b ff f4 	st.b	r9[-12],r11
	s[cnt++] = '0';
800063fa:	fa c9 ff f4 	sub	r9,sp,-12
800063fe:	10 09       	add	r9,r8
80006400:	33 0b       	mov	r11,48
80006402:	f3 6b ff f4 	st.b	r9[-12],r11
80006406:	fa 08 00 08 	add	r8,sp,r8
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
8000640a:	fa ce 00 01 	sub	lr,sp,1
8000640e:	14 99       	mov	r9,r10
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
	*p++ = s[--cnt];
80006410:	11 8b       	ld.ub	r11,r8[0x0]
80006412:	12 cb       	st.b	r9++,r11
80006414:	20 18       	sub	r8,1
	}
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
80006416:	1c 38       	cp.w	r8,lr
80006418:	cf c1       	brne	80006410 <PrintHex+0xa0>
	*p++ = s[--cnt];
		
	return str;
}
8000641a:	14 9c       	mov	r12,r10
8000641c:	2f dd       	sub	sp,-12
8000641e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

80006422 <PrintDec>:
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
{
80006422:	d4 21       	pushm	r4-r7,lr
80006424:	20 3d       	sub	sp,12
80006426:	18 98       	mov	r8,r12
	char * p = str;
	
	int sign = i>=0 ? 0 : 1;
	char s[10];
	memset(s, 0 , 10);
80006428:	30 06       	mov	r6,0
8000642a:	30 07       	mov	r7,0
8000642c:	fa e7 00 00 	st.d	sp[0],r6
80006430:	30 0c       	mov	r12,0
80006432:	ba 4c       	st.h	sp[0x8],r12
	int cnt=0;
	if(sign)
80006434:	58 08       	cp.w	r8,0
80006436:	c0 35       	brlt	8000643c <PrintDec+0x1a>
80006438:	14 97       	mov	r7,r10
8000643a:	c0 58       	rjmp	80006444 <PrintDec+0x22>
	{
		*p++ = '-';
8000643c:	14 97       	mov	r7,r10
8000643e:	32 d9       	mov	r9,45
80006440:	0e c9       	st.b	r7++,r9
		i = -i;
80006442:	5c 38       	neg	r8
	}
	
	if(i == 0 )s[cnt++] = '0';
80006444:	58 08       	cp.w	r8,0
80006446:	c0 51       	brne	80006450 <PrintDec+0x2e>
80006448:	33 08       	mov	r8,48
8000644a:	ba 88       	st.b	sp[0x0],r8
8000644c:	30 1e       	mov	lr,1
8000644e:	c2 f8       	rjmp	800064ac <PrintDec+0x8a>
	
	int ten = i%10;
80006450:	e0 65 66 67 	mov	r5,26215
80006454:	ea 15 66 66 	orh	r5,0x6666
80006458:	f0 05 04 44 	muls.d	r4,r8,r5
8000645c:	ea 0c 14 02 	asr	r12,r5,0x2
80006460:	f0 09 14 1f 	asr	r9,r8,0x1f
80006464:	f8 09 01 09 	sub	r9,r12,r9
80006468:	f2 09 00 29 	add	r9,r9,r9<<0x2
8000646c:	f0 09 01 19 	sub	r9,r8,r9<<0x1
80006470:	30 0e       	mov	lr,0
	while(i)
	{
		s[cnt] = ten+'0';
80006472:	1a 9c       	mov	r12,sp
		cnt++;
		i /= 10;
80006474:	e0 66 66 67 	mov	r6,26215
80006478:	ea 16 66 66 	orh	r6,0x6666
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
	{
		s[cnt] = ten+'0';
8000647c:	2d 09       	sub	r9,-48
8000647e:	f8 0e 0b 09 	st.b	r12[lr],r9
		cnt++;
80006482:	2f fe       	sub	lr,-1
		i /= 10;
80006484:	f0 06 04 44 	muls.d	r4,r8,r6
80006488:	ea 09 14 02 	asr	r9,r5,0x2
8000648c:	bf 58       	asr	r8,0x1f
8000648e:	f2 08 01 08 	sub	r8,r9,r8
		ten = i%10;
80006492:	f0 06 04 44 	muls.d	r4,r8,r6
80006496:	ea 09 14 02 	asr	r9,r5,0x2
8000649a:	f0 05 14 1f 	asr	r5,r8,0x1f
8000649e:	0a 19       	sub	r9,r5
800064a0:	f2 09 00 29 	add	r9,r9,r9<<0x2
800064a4:	f0 09 01 19 	sub	r9,r8,r9<<0x1
	}
	
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
800064a8:	58 08       	cp.w	r8,0
800064aa:	ce 91       	brne	8000647c <PrintDec+0x5a>
		cnt++;
		i /= 10;
		ten = i%10;
	}
	
	if(len - cnt > 0 )
800064ac:	f6 0e 01 08 	sub	r8,r11,lr
800064b0:	58 08       	cp.w	r8,0
800064b2:	e0 89 00 06 	brgt	800064be <PrintDec+0x9c>
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
800064b6:	58 0e       	cp.w	lr,0
800064b8:	e0 89 00 14 	brgt	800064e0 <PrintDec+0xbe>
800064bc:	c1 d8       	rjmp	800064f6 <PrintDec+0xd4>
		ten = i%10;
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
800064be:	1c 1b       	sub	r11,lr
800064c0:	5c 5b       	castu.b	r11
		for(int i = 0; i < num; i++)
800064c2:	16 9c       	mov	r12,r11
800064c4:	58 0b       	cp.w	r11,0
800064c6:	fe 9a ff f8 	brle	800064b6 <PrintDec+0x94>
800064ca:	1a 99       	mov	r9,sp
800064cc:	1c 09       	add	r9,lr
800064ce:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
800064d0:	33 06       	mov	r6,48
800064d2:	12 c6       	st.b	r9++,r6
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
800064d4:	2f f8       	sub	r8,-1
800064d6:	18 38       	cp.w	r8,r12
800064d8:	cf d5       	brlt	800064d2 <PrintDec+0xb0>
{
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
800064da:	f6 0e 00 0e 	add	lr,r11,lr
800064de:	ce cb       	rjmp	800064b6 <PrintDec+0x94>
800064e0:	fa c8 ff f4 	sub	r8,sp,-12
800064e4:	1c 08       	add	r8,lr
800064e6:	20 d8       	sub	r8,13
800064e8:	fa cb 00 01 	sub	r11,sp,1
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
	*p++ = s[--cnt];
800064ec:	11 89       	ld.ub	r9,r8[0x0]
800064ee:	0e c9       	st.b	r7++,r9
800064f0:	20 18       	sub	r8,1
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
800064f2:	16 38       	cp.w	r8,r11
800064f4:	cf c1       	brne	800064ec <PrintDec+0xca>
	*p++ = s[--cnt];
	
	return str;
}
800064f6:	14 9c       	mov	r12,r10
800064f8:	2f dd       	sub	sp,-12
800064fa:	d8 22       	popm	r4-r7,pc

800064fc <log>:
	,  NULL );
	
}

int log(char * content, ...)
{
800064fc:	d4 31       	pushm	r0-r7,lr
800064fe:	fa cd 02 08 	sub	sp,sp,520
80006502:	18 97       	mov	r7,r12
	
	
	char logTmp[MAX_LOG_LINE_SIZE];
	memset(logTmp, '\0', MAX_LOG_LINE_SIZE);	
80006504:	e0 6a 01 00 	mov	r10,256
80006508:	30 0b       	mov	r11,0
8000650a:	fa cc fe f8 	sub	r12,sp,-264
8000650e:	f0 1f 00 4e 	mcall	80006644 <log+0x148>
	,  tskLOG_PRIORITY
	,  NULL );
	
}

int log(char * content, ...)
80006512:	fa c4 fd d4 	sub	r4,sp,-556
80006516:	30 0a       	mov	r10,0
80006518:	50 0a       	stdsp	sp[0x0],r10
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
8000651a:	fa c3 ff fc 	sub	r3,sp,-4
8000651e:	e0 61 01 00 	mov	r1,256
80006522:	14 90       	mov	r0,r10
			
					if(*str == '%')
80006524:	32 52       	mov	r2,37
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
80006526:	fa c6 fe f8 	sub	r6,sp,-264
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
8000652a:	02 9a       	mov	r10,r1
8000652c:	00 9b       	mov	r11,r0
8000652e:	06 9c       	mov	r12,r3
80006530:	f0 1f 00 45 	mcall	80006644 <log+0x148>
			
					if(*str == '%')
80006534:	0f 88       	ld.ub	r8,r7[0x0]
80006536:	e4 08 18 00 	cp.b	r8,r2
8000653a:	c5 71       	brne	800065e8 <log+0xec>
					{
						static char lench = 0;
						lench =*(str + 1);
8000653c:	ee c8 ff ff 	sub	r8,r7,-1
80006540:	11 89       	ld.ub	r9,r8[0x0]
80006542:	4c 2a       	lddpc	r10,80006648 <log+0x14c>
80006544:	b4 89       	st.b	r10[0x0],r9
						if((lench >= '0') &&  (lench <= '9'))
80006546:	23 09       	sub	r9,48
80006548:	30 9a       	mov	r10,9
8000654a:	f4 09 18 00 	cp.b	r9,r10
8000654e:	ee 08 17 b0 	movhi	r8,r7
						{
							len = *(++str) - '0';
80006552:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
80006556:	f7 b9 08 30 	subls	r9,48
8000655a:	fb f9 8a 00 	st.wls	sp[0x0],r9
						}
						
						str++;
8000655e:	f0 c7 ff ff 	sub	r7,r8,-1
						
						switch(*(str))
80006562:	0f 88       	ld.ub	r8,r7[0x0]
80006564:	22 58       	sub	r8,37
80006566:	e0 48 00 53 	cp.w	r8,83
8000656a:	e0 8b 00 31 	brhi	800065cc <log+0xd0>
8000656e:	4b 89       	lddpc	r9,8000664c <log+0x150>
80006570:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
						{
							case('i'):
							case('I'):
							case('d'):
							case('D'):
							x = va_arg(arg_ptr,int);
80006574:	e8 c5 ff fc 	sub	r5,r4,-4
							strTmp = PrintDec(x, len, strTmp);
80006578:	06 9a       	mov	r10,r3
8000657a:	40 0b       	lddsp	r11,sp[0x0]
8000657c:	5c 5b       	castu.b	r11
8000657e:	68 0c       	ld.w	r12,r4[0x0]
80006580:	f0 1f 00 34 	mcall	80006650 <log+0x154>
							break;
80006584:	c2 98       	rjmp	800065d6 <log+0xda>
							
							case('f')://浮点数输出
							case('F'):
							//f = va_arg(arg_ptr,int);
							//strTmp = PrintDec(x, len, strTmp);
							log("I need float.");
80006586:	4b 4c       	lddpc	r12,80006654 <log+0x158>
80006588:	f0 1f 00 34 	mcall	80006658 <log+0x15c>
8000658c:	08 95       	mov	r5,r4
8000658e:	06 9c       	mov	r12,r3
							break;
80006590:	c2 38       	rjmp	800065d6 <log+0xda>
							
							
							case('x'):
							case('X'):
							x = va_arg(arg_ptr,int);
80006592:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintHex(x,len, strTmp);
80006596:	06 9a       	mov	r10,r3
80006598:	40 0b       	lddsp	r11,sp[0x0]
8000659a:	5c 5b       	castu.b	r11
8000659c:	68 0c       	ld.w	r12,r4[0x0]
8000659e:	f0 1f 00 30 	mcall	8000665c <log+0x160>
800065a2:	06 9c       	mov	r12,r3
							break;
800065a4:	c1 98       	rjmp	800065d6 <log+0xda>
							
							case('c'):
							case('C'):
							y = va_arg(arg_ptr,int);
800065a6:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintChar(y, strTmp);
800065aa:	06 9b       	mov	r11,r3
800065ac:	09 bc       	ld.ub	r12,r4[0x3]
800065ae:	f0 1f 00 2d 	mcall	80006660 <log+0x164>
800065b2:	06 9c       	mov	r12,r3
							break;
800065b4:	c1 18       	rjmp	800065d6 <log+0xda>
							
							case('s'):
							case('S'):
							strTmp = va_arg(arg_ptr,char*);
800065b6:	e8 c5 ff fc 	sub	r5,r4,-4
800065ba:	68 0c       	ld.w	r12,r4[0x0]
							//PrintStr(s);
							break;
800065bc:	c0 d8       	rjmp	800065d6 <log+0xda>
							
							case('%'):
							PrintChar('%', strTmp);
800065be:	06 9b       	mov	r11,r3
800065c0:	32 5c       	mov	r12,37
800065c2:	f0 1f 00 28 	mcall	80006660 <log+0x164>
800065c6:	08 95       	mov	r5,r4
800065c8:	06 9c       	mov	r12,r3
							//PrintChar('%');
							break;
800065ca:	c0 68       	rjmp	800065d6 <log+0xda>
							
							default:
							log("I need relax.");
800065cc:	4a 6c       	lddpc	r12,80006664 <log+0x168>
800065ce:	f0 1f 00 23 	mcall	80006658 <log+0x15c>
800065d2:	08 95       	mov	r5,r4
800065d4:	06 9c       	mov	r12,r3
						}
						str++;
800065d6:	2f f7       	sub	r7,-1
						
						length = sprintf(logTmp,"%s%s",logTmp,strTmp );
800065d8:	1a dc       	st.w	--sp,r12
800065da:	1a d6       	st.w	--sp,r6
800065dc:	4a 3b       	lddpc	r11,80006668 <log+0x16c>
800065de:	0c 9c       	mov	r12,r6
800065e0:	f0 1f 00 23 	mcall	8000666c <log+0x170>
800065e4:	2f ed       	sub	sp,-8
800065e6:	c0 a8       	rjmp	800065fa <log+0xfe>
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
800065e8:	2f f7       	sub	r7,-1
800065ea:	1a d8       	st.w	--sp,r8
800065ec:	1a d6       	st.w	--sp,r6
800065ee:	4a 1b       	lddpc	r11,80006670 <log+0x174>
800065f0:	0c 9c       	mov	r12,r6
800065f2:	f0 1f 00 1f 	mcall	8000666c <log+0x170>
800065f6:	08 95       	mov	r5,r4
800065f8:	2f ed       	sub	sp,-8
			
			
			
	}while(*str != '\0');
800065fa:	0f 89       	ld.ub	r9,r7[0x0]
800065fc:	30 08       	mov	r8,0
800065fe:	f0 09 18 00 	cp.b	r9,r8
80006602:	c0 30       	breq	80006608 <log+0x10c>
80006604:	0a 94       	mov	r4,r5
80006606:	c9 2b       	rjmp	8000652a <log+0x2e>
		
		
				
	va_end(arg_ptr);
	//while(1)		
	length = sprintf(logTmp,"%s\r\n",logTmp);
80006608:	fa c7 fe f8 	sub	r7,sp,-264
8000660c:	1a d7       	st.w	--sp,r7
8000660e:	49 ab       	lddpc	r11,80006674 <log+0x178>
80006610:	0e 9c       	mov	r12,r7
80006612:	f0 1f 00 17 	mcall	8000666c <log+0x170>
	
	char * p = pvPortMalloc(length+1);
80006616:	5c 5c       	castu.b	r12
80006618:	f8 c6 ff ff 	sub	r6,r12,-1
8000661c:	0c 9c       	mov	r12,r6
8000661e:	f0 1f 00 17 	mcall	80006678 <log+0x17c>
80006622:	54 2c       	stdsp	sp[0x108],r12
	memcpy(p, logTmp, length+1);
80006624:	0c 9a       	mov	r10,r6
80006626:	0e 9b       	mov	r11,r7
80006628:	f0 1f 00 15 	mcall	8000667c <log+0x180>
	//
	//usart_write_line(EXAMPLE_USART, logTmp);
	xQueueSend( logQueue, &p, 5);
8000662c:	30 09       	mov	r9,0
8000662e:	30 5a       	mov	r10,5
80006630:	fa cb fe f8 	sub	r11,sp,-264
80006634:	49 38       	lddpc	r8,80006680 <log+0x184>
80006636:	70 0c       	ld.w	r12,r8[0x0]
80006638:	f0 1f 00 13 	mcall	80006684 <log+0x188>
8000663c:	2f fd       	sub	sp,-4
}
8000663e:	fe 3d fd f8 	sub	sp,-520
80006642:	d8 32       	popm	r0-r7,pc
80006644:	80 00       	ld.sh	r0,r0[0x0]
80006646:	6f a4       	ld.w	r4,r7[0x68]
80006648:	00 00       	add	r0,r0
8000664a:	0d 74       	ld.ub	r4,--r6
8000664c:	80 00       	ld.sh	r0,r0[0x0]
8000664e:	d4 d0       	acall	0x4d
80006650:	80 00       	ld.sh	r0,r0[0x0]
80006652:	64 22       	ld.w	r2,r2[0x8]
80006654:	80 00       	ld.sh	r0,r0[0x0]
80006656:	d7 7c       	*unknown*
80006658:	80 00       	ld.sh	r0,r0[0x0]
8000665a:	64 fc       	ld.w	r12,r2[0x3c]
8000665c:	80 00       	ld.sh	r0,r0[0x0]
8000665e:	63 70       	ld.w	r0,r1[0x5c]
80006660:	80 00       	ld.sh	r0,r0[0x0]
80006662:	63 6c       	ld.w	r12,r1[0x58]
80006664:	80 00       	ld.sh	r0,r0[0x0]
80006666:	d7 8c       	*unknown*
80006668:	80 00       	ld.sh	r0,r0[0x0]
8000666a:	d7 9c       	*unknown*
8000666c:	80 00       	ld.sh	r0,r0[0x0]
8000666e:	72 94       	ld.w	r4,r9[0x24]
80006670:	80 00       	ld.sh	r0,r0[0x0]
80006672:	d7 a4       	*unknown*
80006674:	80 00       	ld.sh	r0,r0[0x0]
80006676:	d7 ac       	*unknown*
80006678:	80 00       	ld.sh	r0,r0[0x0]
8000667a:	55 b8       	stdsp	sp[0x16c],r8
8000667c:	80 00       	ld.sh	r0,r0[0x0]
8000667e:	6e 5c       	ld.w	r12,r7[0x14]
80006680:	00 00       	add	r0,r0
80006682:	41 18       	lddsp	r8,sp[0x44]
80006684:	80 00       	ld.sh	r0,r0[0x0]
80006686:	59 0c       	cp.w	r12,16

80006688 <logFromISR>:
	
	
int logFromISR(char * content, ...)
	{
80006688:	d4 31       	pushm	r0-r7,lr
8000668a:	fa cd 02 0c 	sub	sp,sp,524
8000668e:	18 97       	mov	r7,r12
		
		
		char logTmp[MAX_LOG_LINE_SIZE];
		memset(logTmp, '\0', MAX_LOG_LINE_SIZE);
80006690:	e0 6a 01 00 	mov	r10,256
80006694:	30 0b       	mov	r11,0
80006696:	fa cc fe f4 	sub	r12,sp,-268
8000669a:	f0 1f 00 4c 	mcall	800067c8 <logFromISR+0x140>
	//usart_write_line(EXAMPLE_USART, logTmp);
	xQueueSend( logQueue, &p, 5);
}
	
	
int logFromISR(char * content, ...)
8000669e:	fa c4 fd d0 	sub	r4,sp,-560
800066a2:	30 0a       	mov	r10,0
800066a4:	50 0a       	stdsp	sp[0x0],r10
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
800066a6:	fa c3 ff fc 	sub	r3,sp,-4
800066aa:	e0 61 01 00 	mov	r1,256
800066ae:	14 90       	mov	r0,r10
			
			if(*str == '%')
800066b0:	32 52       	mov	r2,37
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
800066b2:	fa c6 fe f4 	sub	r6,sp,-268
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
800066b6:	02 9a       	mov	r10,r1
800066b8:	00 9b       	mov	r11,r0
800066ba:	06 9c       	mov	r12,r3
800066bc:	f0 1f 00 43 	mcall	800067c8 <logFromISR+0x140>
			
			if(*str == '%')
800066c0:	0f 88       	ld.ub	r8,r7[0x0]
800066c2:	e4 08 18 00 	cp.b	r8,r2
800066c6:	c5 11       	brne	80006768 <logFromISR+0xe0>
			{
				static char lench = 0;
				lench =*(str + 1);
800066c8:	ee c8 ff ff 	sub	r8,r7,-1
800066cc:	11 89       	ld.ub	r9,r8[0x0]
800066ce:	4c 0a       	lddpc	r10,800067cc <logFromISR+0x144>
800066d0:	b4 89       	st.b	r10[0x0],r9
				if((lench >= '0') &&  (lench <= '9'))
800066d2:	23 09       	sub	r9,48
800066d4:	30 9a       	mov	r10,9
800066d6:	f4 09 18 00 	cp.b	r9,r10
800066da:	ee 08 17 b0 	movhi	r8,r7
				{
					len = *(++str) - '0';
800066de:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
800066e2:	f7 b9 08 30 	subls	r9,48
800066e6:	fb f9 8a 00 	st.wls	sp[0x0],r9
				}
				
				str++;
800066ea:	f0 c7 ff ff 	sub	r7,r8,-1
				
				switch(*(str))
800066ee:	0f 88       	ld.ub	r8,r7[0x0]
800066f0:	22 58       	sub	r8,37
800066f2:	e0 48 00 53 	cp.w	r8,83
800066f6:	e0 8b 00 2b 	brhi	8000674c <logFromISR+0xc4>
800066fa:	4b 69       	lddpc	r9,800067d0 <logFromISR+0x148>
800066fc:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
				{
					case('d'):
					case('D'):
					x = va_arg(arg_ptr,int);
80006700:	e8 c5 ff fc 	sub	r5,r4,-4
					strTmp = PrintDec(x, len, strTmp);
80006704:	06 9a       	mov	r10,r3
80006706:	40 0b       	lddsp	r11,sp[0x0]
80006708:	5c 5b       	castu.b	r11
8000670a:	68 0c       	ld.w	r12,r4[0x0]
8000670c:	f0 1f 00 32 	mcall	800067d4 <logFromISR+0x14c>
					break;
80006710:	c2 38       	rjmp	80006756 <logFromISR+0xce>
					case('x'):
					case('X'):
					x = va_arg(arg_ptr,int);
80006712:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintHex(x,len, strTmp);
80006716:	06 9a       	mov	r10,r3
80006718:	40 0b       	lddsp	r11,sp[0x0]
8000671a:	5c 5b       	castu.b	r11
8000671c:	68 0c       	ld.w	r12,r4[0x0]
8000671e:	f0 1f 00 2f 	mcall	800067d8 <logFromISR+0x150>
80006722:	06 9c       	mov	r12,r3
					break;
80006724:	c1 98       	rjmp	80006756 <logFromISR+0xce>
					case('c'):
					case('C'):
					y = va_arg(arg_ptr,int);
80006726:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintChar(y, strTmp);
8000672a:	06 9b       	mov	r11,r3
8000672c:	09 bc       	ld.ub	r12,r4[0x3]
8000672e:	f0 1f 00 2c 	mcall	800067dc <logFromISR+0x154>
80006732:	06 9c       	mov	r12,r3
					break;
80006734:	c1 18       	rjmp	80006756 <logFromISR+0xce>
					case('s'):
					case('S'):
					strTmp = va_arg(arg_ptr,char*);
80006736:	e8 c5 ff fc 	sub	r5,r4,-4
8000673a:	68 0c       	ld.w	r12,r4[0x0]
					//PrintStr(s);
					break;
8000673c:	c0 d8       	rjmp	80006756 <logFromISR+0xce>
					case('%'):
					PrintChar('%', strTmp);
8000673e:	06 9b       	mov	r11,r3
80006740:	32 5c       	mov	r12,37
80006742:	f0 1f 00 27 	mcall	800067dc <logFromISR+0x154>
80006746:	08 95       	mov	r5,r4
80006748:	06 9c       	mov	r12,r3
					//PrintChar('%');
					break;
8000674a:	c0 68       	rjmp	80006756 <logFromISR+0xce>
					default:
					log("I need relax.");
8000674c:	4a 5c       	lddpc	r12,800067e0 <logFromISR+0x158>
8000674e:	f0 1f 00 26 	mcall	800067e4 <logFromISR+0x15c>
80006752:	08 95       	mov	r5,r4
80006754:	06 9c       	mov	r12,r3
				}
				str++;
80006756:	2f f7       	sub	r7,-1
				
				length = sprintf(logTmp,"%s%s",logTmp,strTmp );
80006758:	1a dc       	st.w	--sp,r12
8000675a:	1a d6       	st.w	--sp,r6
8000675c:	4a 3b       	lddpc	r11,800067e8 <logFromISR+0x160>
8000675e:	0c 9c       	mov	r12,r6
80006760:	f0 1f 00 23 	mcall	800067ec <logFromISR+0x164>
80006764:	2f ed       	sub	sp,-8
80006766:	c0 a8       	rjmp	8000677a <logFromISR+0xf2>
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
80006768:	2f f7       	sub	r7,-1
8000676a:	1a d8       	st.w	--sp,r8
8000676c:	1a d6       	st.w	--sp,r6
8000676e:	4a 1b       	lddpc	r11,800067f0 <logFromISR+0x168>
80006770:	0c 9c       	mov	r12,r6
80006772:	f0 1f 00 1f 	mcall	800067ec <logFromISR+0x164>
80006776:	08 95       	mov	r5,r4
80006778:	2f ed       	sub	sp,-8
			
			
			
		}while(*str != '\0');
8000677a:	0f 89       	ld.ub	r9,r7[0x0]
8000677c:	30 08       	mov	r8,0
8000677e:	f0 09 18 00 	cp.b	r9,r8
80006782:	c0 30       	breq	80006788 <logFromISR+0x100>
80006784:	0a 94       	mov	r4,r5
80006786:	c9 8b       	rjmp	800066b6 <logFromISR+0x2e>
		
		
		
		va_end(arg_ptr);
		//while(1)
		length = sprintf(logTmp,"%s\r\n",logTmp);
80006788:	fa c7 fe f4 	sub	r7,sp,-268
8000678c:	1a d7       	st.w	--sp,r7
8000678e:	49 ab       	lddpc	r11,800067f4 <logFromISR+0x16c>
80006790:	0e 9c       	mov	r12,r7
80006792:	f0 1f 00 17 	mcall	800067ec <logFromISR+0x164>
		
		char * p = pvPortMalloc(length+1);
80006796:	5c 5c       	castu.b	r12
80006798:	f8 c6 ff ff 	sub	r6,r12,-1
8000679c:	0c 9c       	mov	r12,r6
8000679e:	f0 1f 00 17 	mcall	800067f8 <logFromISR+0x170>
800067a2:	54 3c       	stdsp	sp[0x10c],r12
		memcpy(p, logTmp, length+1);
800067a4:	0c 9a       	mov	r10,r6
800067a6:	0e 9b       	mov	r11,r7
800067a8:	f0 1f 00 15 	mcall	800067fc <logFromISR+0x174>
		//
		portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
800067ac:	30 09       	mov	r9,0
800067ae:	54 29       	stdsp	sp[0x108],r9
		
		//usart_write_line(EXAMPLE_USART, p);
		//vPortFree(p);
		xQueueSendFromISR( logQueue, &p, &xHigherPriorityTaskWoken );
800067b0:	fa ca fe f8 	sub	r10,sp,-264
800067b4:	fa cb fe f4 	sub	r11,sp,-268
800067b8:	49 28       	lddpc	r8,80006800 <logFromISR+0x178>
800067ba:	70 0c       	ld.w	r12,r8[0x0]
800067bc:	f0 1f 00 12 	mcall	80006804 <logFromISR+0x17c>
800067c0:	2f fd       	sub	sp,-4
		//if (xHigherPriorityTaskWoken == pdTRUE)
		//{
			////taskYIELD();
		//}
	}
800067c2:	fe 3d fd f4 	sub	sp,-524
800067c6:	d8 32       	popm	r0-r7,pc
800067c8:	80 00       	ld.sh	r0,r0[0x0]
800067ca:	6f a4       	ld.w	r4,r7[0x68]
800067cc:	00 00       	add	r0,r0
800067ce:	0d 75       	ld.ub	r5,--r6
800067d0:	80 00       	ld.sh	r0,r0[0x0]
800067d2:	d6 20       	acall	0x62
800067d4:	80 00       	ld.sh	r0,r0[0x0]
800067d6:	64 22       	ld.w	r2,r2[0x8]
800067d8:	80 00       	ld.sh	r0,r0[0x0]
800067da:	63 70       	ld.w	r0,r1[0x5c]
800067dc:	80 00       	ld.sh	r0,r0[0x0]
800067de:	63 6c       	ld.w	r12,r1[0x58]
800067e0:	80 00       	ld.sh	r0,r0[0x0]
800067e2:	d7 8c       	*unknown*
800067e4:	80 00       	ld.sh	r0,r0[0x0]
800067e6:	64 fc       	ld.w	r12,r2[0x3c]
800067e8:	80 00       	ld.sh	r0,r0[0x0]
800067ea:	d7 9c       	*unknown*
800067ec:	80 00       	ld.sh	r0,r0[0x0]
800067ee:	72 94       	ld.w	r4,r9[0x24]
800067f0:	80 00       	ld.sh	r0,r0[0x0]
800067f2:	d7 a4       	*unknown*
800067f4:	80 00       	ld.sh	r0,r0[0x0]
800067f6:	d7 ac       	*unknown*
800067f8:	80 00       	ld.sh	r0,r0[0x0]
800067fa:	55 b8       	stdsp	sp[0x16c],r8
800067fc:	80 00       	ld.sh	r0,r0[0x0]
800067fe:	6e 5c       	ld.w	r12,r7[0x14]
80006800:	00 00       	add	r0,r0
80006802:	41 18       	lddsp	r8,sp[0x44]
80006804:	80 00       	ld.sh	r0,r0[0x0]
80006806:	58 bc       	cp.w	r12,11

80006808 <log_init>:
		
	return str;
}

void log_init(void)
{
80006808:	d4 01       	pushm	lr
		.stopbits     = USART_1_STOPBIT,
		.channelmode  = USART_NORMAL_CHMODE
	};

	// Assign GPIO to USART.
	gpio_enable_module(USART_GPIO_MAP,
8000680a:	30 2b       	mov	r11,2
8000680c:	49 0c       	lddpc	r12,8000684c <log_init+0x44>
8000680e:	f0 1f 00 11 	mcall	80006850 <log_init+0x48>
	sizeof(USART_GPIO_MAP) / sizeof(USART_GPIO_MAP[0]));

	// Initialize USART in RS232 mode.
	usart_init_rs232(EXAMPLE_USART, &USART_OPTIONS, EXAMPLE_TARGET_PBACLK_FREQ_HZ);			
80006812:	e0 6a 36 00 	mov	r10,13824
80006816:	ea 1a 01 6e 	orh	r10,0x16e
8000681a:	48 fb       	lddpc	r11,80006854 <log_init+0x4c>
8000681c:	fe 7c 18 00 	mov	r12,-59392
80006820:	f0 1f 00 0e 	mcall	80006858 <log_init+0x50>
			
	logQueue  = xQueueCreate(50, sizeof(char *));
80006824:	30 4b       	mov	r11,4
80006826:	33 2c       	mov	r12,50
80006828:	f0 1f 00 0d 	mcall	8000685c <log_init+0x54>
8000682c:	48 d8       	lddpc	r8,80006860 <log_init+0x58>
8000682e:	91 0c       	st.w	r8[0x0],r12
	
	xTaskCreate(
80006830:	30 09       	mov	r9,0
80006832:	1a d9       	st.w	--sp,r9
80006834:	1a d9       	st.w	--sp,r9
80006836:	1a d9       	st.w	--sp,r9
80006838:	30 28       	mov	r8,2
8000683a:	e0 6a 01 80 	mov	r10,384
8000683e:	48 ab       	lddpc	r11,80006864 <log_init+0x5c>
80006840:	48 ac       	lddpc	r12,80006868 <log_init+0x60>
80006842:	f0 1f 00 0b 	mcall	8000686c <log_init+0x64>
80006846:	2f dd       	sub	sp,-12
	,  384
	,  NULL
	,  tskLOG_PRIORITY
	,  NULL );
	
}
80006848:	d8 02       	popm	pc
8000684a:	00 00       	add	r0,r0
8000684c:	80 00       	ld.sh	r0,r0[0x0]
8000684e:	d7 b8       	*unknown*
80006850:	80 00       	ld.sh	r0,r0[0x0]
80006852:	69 94       	ld.w	r4,r4[0x64]
80006854:	80 00       	ld.sh	r0,r0[0x0]
80006856:	d7 70       	acall	0x77
80006858:	80 00       	ld.sh	r0,r0[0x0]
8000685a:	51 5c       	stdsp	sp[0x54],r12
8000685c:	80 00       	ld.sh	r0,r0[0x0]
8000685e:	5a 64       	cp.w	r4,-26
80006860:	00 00       	add	r0,r0
80006862:	41 18       	lddsp	r8,sp[0x44]
80006864:	80 00       	ld.sh	r0,r0[0x0]
80006866:	d7 b4       	*unknown*
80006868:	80 00       	ld.sh	r0,r0[0x0]
8000686a:	68 70       	ld.w	r0,r4[0x1c]
8000686c:	80 00       	ld.sh	r0,r0[0x0]
8000686e:	61 38       	ld.w	r8,r0[0x4c]

80006870 <task_log>:
			////taskYIELD();
		//}
	}
	
static void task_log(void * pvParameters)
{
80006870:	eb cd 40 f8 	pushm	r3-r7,lr
80006874:	20 1d       	sub	sp,4
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
80006876:	48 c7       	lddpc	r7,800068a4 <task_log+0x34>
80006878:	30 05       	mov	r5,0
8000687a:	3f f4       	mov	r4,-1
		{
			if( NULL != str)
			{
				usart_write_line(EXAMPLE_USART, str);
8000687c:	fe 73 18 00 	mov	r3,-59392
{
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
80006880:	0a 99       	mov	r9,r5
80006882:	08 9a       	mov	r10,r4
80006884:	1a 9b       	mov	r11,sp
80006886:	6e 0c       	ld.w	r12,r7[0x0]
80006888:	f0 1f 00 08 	mcall	800068a8 <task_log+0x38>
8000688c:	58 1c       	cp.w	r12,1
8000688e:	cf 91       	brne	80006880 <task_log+0x10>
		{
			if( NULL != str)
80006890:	40 0b       	lddsp	r11,sp[0x0]
80006892:	58 0b       	cp.w	r11,0
80006894:	cf 60       	breq	80006880 <task_log+0x10>
			{
				usart_write_line(EXAMPLE_USART, str);
80006896:	06 9c       	mov	r12,r3
80006898:	f0 1f 00 05 	mcall	800068ac <task_log+0x3c>
				vPortFree(str);
8000689c:	40 0c       	lddsp	r12,sp[0x0]
8000689e:	f0 1f 00 05 	mcall	800068b0 <task_log+0x40>
800068a2:	ce fb       	rjmp	80006880 <task_log+0x10>
800068a4:	00 00       	add	r0,r0
800068a6:	41 18       	lddsp	r8,sp[0x44]
800068a8:	80 00       	ld.sh	r0,r0[0x0]
800068aa:	57 00       	stdsp	sp[0x1c0],r0
800068ac:	80 00       	ld.sh	r0,r0[0x0]
800068ae:	51 0c       	stdsp	sp[0x40],r12
800068b0:	80 00       	ld.sh	r0,r0[0x0]
800068b2:	55 90       	stdsp	sp[0x164],r0

800068b4 <main>:

#include "fs/fs.h"
#include "rtc/rtc.h"

int main(void)
{
800068b4:	d4 01       	pushm	lr
	//Force SSC_TX_DATA_ENABLE Disabled as soon as possible.
	AVR32_GPIO.port[1].ovrs  =  0x00000001;  //Value will be high.
800068b6:	fe 78 10 00 	mov	r8,-61440
800068ba:	30 19       	mov	r9,1
800068bc:	f1 49 01 54 	st.w	r8[340],r9
	AVR32_GPIO.port[1].oders =  0x00000001;  //Output Driver will be Enabled.
800068c0:	f1 49 01 44 	st.w	r8[324],r9
	AVR32_GPIO.port[1].gpers =  0x00000001;  //Enable as GPIO.
800068c4:	f1 49 01 04 	st.w	r8[260],r9
	
	Disable_global_interrupt();
800068c8:	d3 03       	ssrf	0x10
	local_start_pll0();
800068ca:	f0 1f 00 13 	mcall	80006914 <main+0x60>
		
	INTC_init_interrupts();
800068ce:	f0 1f 00 13 	mcall	80006918 <main+0x64>
	
	log_init();		
800068d2:	f0 1f 00 13 	mcall	8000691c <main+0x68>
	log("----start debug----");	
800068d6:	49 3c       	lddpc	r12,80006920 <main+0x6c>
800068d8:	f0 1f 00 13 	mcall	80006924 <main+0x70>
		
	rtc_init();
800068dc:	f0 1f 00 13 	mcall	80006928 <main+0x74>
	
	//fs_init();//65795机器无法通过文件系统初始化

	tc_init();	
800068e0:	f0 1f 00 13 	mcall	8000692c <main+0x78>
			
	xcmp_init();
800068e4:	f0 1f 00 13 	mcall	80006930 <main+0x7c>
	
	app_init();
800068e8:	f0 1f 00 13 	mcall	80006934 <main+0x80>
		
	while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
800068ec:	fe 79 10 00 	mov	r9,-61440
800068f0:	f2 f8 01 60 	ld.w	r8,r9[352]
800068f4:	e2 18 00 02 	andl	r8,0x2,COH
800068f8:	cf c0       	breq	800068f0 <main+0x3c>
	while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
800068fa:	fe 79 10 00 	mov	r9,-61440
800068fe:	f2 f8 01 60 	ld.w	r8,r9[352]
80006902:	e2 18 00 02 	andl	r8,0x2,COH
80006906:	cf c1       	brne	800068fe <main+0x4a>
	local_start_timer();
80006908:	f0 1f 00 0c 	mcall	80006938 <main+0x84>
	
	Enable_global_interrupt();
8000690c:	d5 03       	csrf	0x10
	
	vTaskStartScheduler();		
8000690e:	f0 1f 00 0c 	mcall	8000693c <main+0x88>
	return 0;
}
80006912:	d8 0a       	popm	pc,r12=0
80006914:	80 00       	ld.sh	r0,r0[0x0]
80006916:	4a 2c       	lddpc	r12,8000699c <gpio_enable_module+0x8>
80006918:	80 00       	ld.sh	r0,r0[0x0]
8000691a:	4c 48       	lddpc	r8,80006a28 <_malloc_r+0x4>
8000691c:	80 00       	ld.sh	r0,r0[0x0]
8000691e:	68 08       	ld.w	r8,r4[0x0]
80006920:	80 00       	ld.sh	r0,r0[0x0]
80006922:	d7 c8       	*unknown*
80006924:	80 00       	ld.sh	r0,r0[0x0]
80006926:	64 fc       	ld.w	r12,r2[0x3c]
80006928:	80 00       	ld.sh	r0,r0[0x0]
8000692a:	4a 7c       	lddpc	r12,800069c4 <_stext>
8000692c:	80 00       	ld.sh	r0,r0[0x0]
8000692e:	4b 44       	lddpc	r4,800069fc <udata_clear_loop+0x4>
80006930:	80 00       	ld.sh	r0,r0[0x0]
80006932:	43 30       	lddsp	r0,sp[0xcc]
80006934:	80 00       	ld.sh	r0,r0[0x0]
80006936:	20 40       	sub	r0,4
80006938:	80 00       	ld.sh	r0,r0[0x0]
8000693a:	4b 08       	lddpc	r8,800069f8 <udata_clear_loop>
8000693c:	80 00       	ld.sh	r0,r0[0x0]
8000693e:	63 20       	ld.w	r0,r1[0x48]

80006940 <gpio_enable_module_pin>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80006940:	f8 08 16 05 	lsr	r8,r12,0x5
80006944:	a9 68       	lsl	r8,0x8
80006946:	e0 28 f0 00 	sub	r8,61440

	/* Enable the correct function. */
	switch (function) {
8000694a:	58 1b       	cp.w	r11,1
8000694c:	c0 d0       	breq	80006966 <gpio_enable_module_pin+0x26>
8000694e:	c0 63       	brcs	8000695a <gpio_enable_module_pin+0x1a>
80006950:	58 2b       	cp.w	r11,2
80006952:	c1 00       	breq	80006972 <gpio_enable_module_pin+0x32>
80006954:	58 3b       	cp.w	r11,3
80006956:	c1 40       	breq	8000697e <gpio_enable_module_pin+0x3e>
80006958:	5e ff       	retal	1
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
8000695a:	30 19       	mov	r9,1
8000695c:	f2 0c 09 49 	lsl	r9,r9,r12
80006960:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80006962:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80006964:	c1 28       	rjmp	80006988 <gpio_enable_module_pin+0x48>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80006966:	30 19       	mov	r9,1
80006968:	f2 0c 09 49 	lsl	r9,r9,r12
8000696c:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
8000696e:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80006970:	c0 c8       	rjmp	80006988 <gpio_enable_module_pin+0x48>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80006972:	30 19       	mov	r9,1
80006974:	f2 0c 09 49 	lsl	r9,r9,r12
80006978:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
8000697a:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
8000697c:	c0 68       	rjmp	80006988 <gpio_enable_module_pin+0x48>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
8000697e:	30 19       	mov	r9,1
80006980:	f2 0c 09 49 	lsl	r9,r9,r12
80006984:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80006986:	91 99       	st.w	r8[0x24],r9
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
80006988:	30 19       	mov	r9,1
8000698a:	f2 0c 09 4c 	lsl	r12,r9,r12
8000698e:	91 2c       	st.w	r8[0x8],r12
80006990:	5e fd       	retal	0
80006992:	d7 03       	nop

80006994 <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
80006994:	d4 21       	pushm	r4-r7,lr
80006996:	18 97       	mov	r7,r12
80006998:	16 94       	mov	r4,r11
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
8000699a:	58 0b       	cp.w	r11,0
8000699c:	c0 31       	brne	800069a2 <gpio_enable_module+0xe>
8000699e:	30 05       	mov	r5,0
800069a0:	c0 d8       	rjmp	800069ba <gpio_enable_module+0x26>
800069a2:	30 06       	mov	r6,0
800069a4:	0c 95       	mov	r5,r6
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
800069a6:	6e 1b       	ld.w	r11,r7[0x4]
800069a8:	6e 0c       	ld.w	r12,r7[0x0]
800069aa:	f0 1f 00 06 	mcall	800069c0 <gpio_enable_module+0x2c>
800069ae:	18 45       	or	r5,r12
		gpiomap++;
800069b0:	2f 87       	sub	r7,-8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
800069b2:	2f f6       	sub	r6,-1
800069b4:	0c 34       	cp.w	r4,r6
800069b6:	fe 9b ff f8 	brhi	800069a6 <gpio_enable_module+0x12>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
}
800069ba:	0a 9c       	mov	r12,r5
800069bc:	d8 22       	popm	r4-r7,pc
800069be:	00 00       	add	r0,r0
800069c0:	80 00       	ld.sh	r0,r0[0x0]
800069c2:	69 40       	ld.w	r0,r4[0x50]

800069c4 <_stext>:

  .global _stext
  .type _stext, @function
_stext:
  // Set initial stack pointer.
  lda.w   sp, _estack
800069c4:	e0 7d 80 00 	mov	sp,98304

  // Set up EVBA so interrupts can be enabled.
  lda.w   r0, _evba
  mtsr    AVR32_EVBA, r0
800069c8:	fe c0 a5 c8 	sub	r0,pc,-23096

  // Enable the exception processing.
  csrf    AVR32_SR_EM_OFFSET
800069cc:	e3 b0 00 01 	mtsr	0x4,r0

  // Load initialized data having a global lifetime from the data LMA.
  lda.w   r0, _data
  lda.w   r1, _edata
800069d0:	d5 53       	csrf	0x15
  cp      r0, r1
800069d2:	30 80       	mov	r0,8
  brhs    idata_load_loop_end
800069d4:	e0 61 0a 40 	mov	r1,2624
  lda.w   r2, _data_lma
idata_load_loop:
  ld.d    r4, r2++
800069d8:	02 30       	cp.w	r0,r1
  st.d    r0++, r4
800069da:	c0 72       	brcc	800069e8 <idata_load_loop_end>
  cp      r0, r1
800069dc:	fe c2 8c 7c 	sub	r2,pc,-29572

800069e0 <idata_load_loop>:
  brlo    idata_load_loop
idata_load_loop_end:

  // Clear uninitialized data having a global lifetime in the blank static storage section.
  lda.w   r0, __bss_start
800069e0:	a5 05       	ld.d	r4,r2++
  lda.w   r1, _end
800069e2:	a1 24       	st.d	r0++,r4
  cp      r0, r1
800069e4:	02 30       	cp.w	r0,r1
  brhs    udata_clear_loop_end
800069e6:	cf d3       	brcs	800069e0 <idata_load_loop>

800069e8 <idata_load_loop_end>:
  mov     r2, 0
800069e8:	e0 60 0a 40 	mov	r0,2624
  mov     r3, 0
udata_clear_loop:
  st.d    r0++, r2
800069ec:	e0 61 41 20 	mov	r1,16672
  cp      r0, r1
  brlo    udata_clear_loop
800069f0:	02 30       	cp.w	r0,r1
  // Safety: Set the default "return" @ to the exit routine address.
  lda.w   lr, exit
#endif

  // Start the show.
  lda.w   pc, main
800069f2:	c0 62       	brcc	800069fe <udata_clear_loop_end>
800069f4:	30 02       	mov	r2,0
800069f6:	30 03       	mov	r3,0

800069f8 <udata_clear_loop>:
800069f8:	a1 22       	st.d	r0++,r2
800069fa:	02 30       	cp.w	r0,r1
800069fc:	cf e3       	brcs	800069f8 <udata_clear_loop>

800069fe <udata_clear_loop_end>:
800069fe:	fe cf 01 4a 	sub	pc,pc,330
80006a02:	d7 03       	nop

80006a04 <free>:
80006a04:	d4 01       	pushm	lr
80006a06:	e0 68 0a 38 	mov	r8,2616
80006a0a:	18 9b       	mov	r11,r12
80006a0c:	70 0c       	ld.w	r12,r8[0x0]
80006a0e:	e0 a0 1e 6d 	rcall	8000a6e8 <_free_r>
80006a12:	d8 02       	popm	pc

80006a14 <malloc>:
80006a14:	d4 01       	pushm	lr
80006a16:	e0 68 0a 38 	mov	r8,2616
80006a1a:	18 9b       	mov	r11,r12
80006a1c:	70 0c       	ld.w	r12,r8[0x0]
80006a1e:	c0 3c       	rcall	80006a24 <_malloc_r>
80006a20:	d8 02       	popm	pc
80006a22:	d7 03       	nop

80006a24 <_malloc_r>:
80006a24:	d4 31       	pushm	r0-r7,lr
80006a26:	f6 c8 ff f5 	sub	r8,r11,-11
80006a2a:	18 95       	mov	r5,r12
80006a2c:	10 97       	mov	r7,r8
80006a2e:	e0 17 ff f8 	andl	r7,0xfff8
80006a32:	59 68       	cp.w	r8,22
80006a34:	f9 b7 08 10 	movls	r7,16
80006a38:	16 37       	cp.w	r7,r11
80006a3a:	5f 38       	srlo	r8
80006a3c:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
80006a40:	c0 50       	breq	80006a4a <_malloc_r+0x26>
80006a42:	30 c8       	mov	r8,12
80006a44:	99 38       	st.w	r12[0xc],r8
80006a46:	e0 8f 01 fa 	bral	80006e3a <_malloc_r+0x416>
80006a4a:	fe b0 f5 59 	rcall	800054fc <__malloc_lock>
80006a4e:	e0 47 01 f7 	cp.w	r7,503
80006a52:	e0 8b 00 1d 	brhi	80006a8c <_malloc_r+0x68>
80006a56:	ee 03 16 03 	lsr	r3,r7,0x3
80006a5a:	e0 68 05 38 	mov	r8,1336
80006a5e:	f0 03 00 38 	add	r8,r8,r3<<0x3
80006a62:	70 36       	ld.w	r6,r8[0xc]
80006a64:	10 36       	cp.w	r6,r8
80006a66:	c0 61       	brne	80006a72 <_malloc_r+0x4e>
80006a68:	ec c8 ff f8 	sub	r8,r6,-8
80006a6c:	70 36       	ld.w	r6,r8[0xc]
80006a6e:	10 36       	cp.w	r6,r8
80006a70:	c0 c0       	breq	80006a88 <_malloc_r+0x64>
80006a72:	6c 18       	ld.w	r8,r6[0x4]
80006a74:	e0 18 ff fc 	andl	r8,0xfffc
80006a78:	6c 3a       	ld.w	r10,r6[0xc]
80006a7a:	ec 08 00 09 	add	r9,r6,r8
80006a7e:	0a 9c       	mov	r12,r5
80006a80:	6c 28       	ld.w	r8,r6[0x8]
80006a82:	95 28       	st.w	r10[0x8],r8
80006a84:	91 3a       	st.w	r8[0xc],r10
80006a86:	c4 78       	rjmp	80006b14 <_malloc_r+0xf0>
80006a88:	2f e3       	sub	r3,-2
80006a8a:	c4 d8       	rjmp	80006b24 <_malloc_r+0x100>
80006a8c:	ee 03 16 09 	lsr	r3,r7,0x9
80006a90:	c0 41       	brne	80006a98 <_malloc_r+0x74>
80006a92:	ee 03 16 03 	lsr	r3,r7,0x3
80006a96:	c2 68       	rjmp	80006ae2 <_malloc_r+0xbe>
80006a98:	58 43       	cp.w	r3,4
80006a9a:	e0 8b 00 06 	brhi	80006aa6 <_malloc_r+0x82>
80006a9e:	ee 03 16 06 	lsr	r3,r7,0x6
80006aa2:	2c 83       	sub	r3,-56
80006aa4:	c1 f8       	rjmp	80006ae2 <_malloc_r+0xbe>
80006aa6:	59 43       	cp.w	r3,20
80006aa8:	e0 8b 00 04 	brhi	80006ab0 <_malloc_r+0x8c>
80006aac:	2a 53       	sub	r3,-91
80006aae:	c1 a8       	rjmp	80006ae2 <_malloc_r+0xbe>
80006ab0:	e0 43 00 54 	cp.w	r3,84
80006ab4:	e0 8b 00 06 	brhi	80006ac0 <_malloc_r+0x9c>
80006ab8:	ee 03 16 0c 	lsr	r3,r7,0xc
80006abc:	29 23       	sub	r3,-110
80006abe:	c1 28       	rjmp	80006ae2 <_malloc_r+0xbe>
80006ac0:	e0 43 01 54 	cp.w	r3,340
80006ac4:	e0 8b 00 06 	brhi	80006ad0 <_malloc_r+0xac>
80006ac8:	ee 03 16 0f 	lsr	r3,r7,0xf
80006acc:	28 93       	sub	r3,-119
80006ace:	c0 a8       	rjmp	80006ae2 <_malloc_r+0xbe>
80006ad0:	e0 43 05 54 	cp.w	r3,1364
80006ad4:	e0 88 00 04 	brls	80006adc <_malloc_r+0xb8>
80006ad8:	37 e3       	mov	r3,126
80006ada:	c0 48       	rjmp	80006ae2 <_malloc_r+0xbe>
80006adc:	ee 03 16 12 	lsr	r3,r7,0x12
80006ae0:	28 43       	sub	r3,-124
80006ae2:	e0 6a 05 38 	mov	r10,1336
80006ae6:	f4 03 00 3a 	add	r10,r10,r3<<0x3
80006aea:	74 36       	ld.w	r6,r10[0xc]
80006aec:	c1 98       	rjmp	80006b1e <_malloc_r+0xfa>
80006aee:	6c 19       	ld.w	r9,r6[0x4]
80006af0:	e0 19 ff fc 	andl	r9,0xfffc
80006af4:	f2 07 01 0b 	sub	r11,r9,r7
80006af8:	58 fb       	cp.w	r11,15
80006afa:	e0 8a 00 04 	brle	80006b02 <_malloc_r+0xde>
80006afe:	20 13       	sub	r3,1
80006b00:	c1 18       	rjmp	80006b22 <_malloc_r+0xfe>
80006b02:	6c 38       	ld.w	r8,r6[0xc]
80006b04:	58 0b       	cp.w	r11,0
80006b06:	c0 b5       	brlt	80006b1c <_malloc_r+0xf8>
80006b08:	6c 2a       	ld.w	r10,r6[0x8]
80006b0a:	ec 09 00 09 	add	r9,r6,r9
80006b0e:	0a 9c       	mov	r12,r5
80006b10:	91 2a       	st.w	r8[0x8],r10
80006b12:	95 38       	st.w	r10[0xc],r8
80006b14:	72 18       	ld.w	r8,r9[0x4]
80006b16:	a1 a8       	sbr	r8,0x0
80006b18:	93 18       	st.w	r9[0x4],r8
80006b1a:	cb c8       	rjmp	80006c92 <_malloc_r+0x26e>
80006b1c:	10 96       	mov	r6,r8
80006b1e:	14 36       	cp.w	r6,r10
80006b20:	ce 71       	brne	80006aee <_malloc_r+0xca>
80006b22:	2f f3       	sub	r3,-1
80006b24:	e0 6a 05 38 	mov	r10,1336
80006b28:	f4 cc ff f8 	sub	r12,r10,-8
80006b2c:	78 26       	ld.w	r6,r12[0x8]
80006b2e:	18 36       	cp.w	r6,r12
80006b30:	c6 c0       	breq	80006c08 <_malloc_r+0x1e4>
80006b32:	6c 19       	ld.w	r9,r6[0x4]
80006b34:	e0 19 ff fc 	andl	r9,0xfffc
80006b38:	f2 07 01 08 	sub	r8,r9,r7
80006b3c:	58 f8       	cp.w	r8,15
80006b3e:	e0 89 00 8f 	brgt	80006c5c <_malloc_r+0x238>
80006b42:	99 3c       	st.w	r12[0xc],r12
80006b44:	99 2c       	st.w	r12[0x8],r12
80006b46:	58 08       	cp.w	r8,0
80006b48:	c0 55       	brlt	80006b52 <_malloc_r+0x12e>
80006b4a:	ec 09 00 09 	add	r9,r6,r9
80006b4e:	0a 9c       	mov	r12,r5
80006b50:	ce 2b       	rjmp	80006b14 <_malloc_r+0xf0>
80006b52:	e0 49 01 ff 	cp.w	r9,511
80006b56:	e0 8b 00 13 	brhi	80006b7c <_malloc_r+0x158>
80006b5a:	a3 99       	lsr	r9,0x3
80006b5c:	f4 09 00 38 	add	r8,r10,r9<<0x3
80006b60:	70 2b       	ld.w	r11,r8[0x8]
80006b62:	8d 38       	st.w	r6[0xc],r8
80006b64:	8d 2b       	st.w	r6[0x8],r11
80006b66:	97 36       	st.w	r11[0xc],r6
80006b68:	91 26       	st.w	r8[0x8],r6
80006b6a:	a3 49       	asr	r9,0x2
80006b6c:	74 18       	ld.w	r8,r10[0x4]
80006b6e:	30 1b       	mov	r11,1
80006b70:	f6 09 09 49 	lsl	r9,r11,r9
80006b74:	f1 e9 10 09 	or	r9,r8,r9
80006b78:	95 19       	st.w	r10[0x4],r9
80006b7a:	c4 78       	rjmp	80006c08 <_malloc_r+0x1e4>
80006b7c:	f2 0a 16 09 	lsr	r10,r9,0x9
80006b80:	58 4a       	cp.w	r10,4
80006b82:	e0 8b 00 07 	brhi	80006b90 <_malloc_r+0x16c>
80006b86:	f2 0a 16 06 	lsr	r10,r9,0x6
80006b8a:	2c 8a       	sub	r10,-56
80006b8c:	c2 08       	rjmp	80006bcc <_malloc_r+0x1a8>
80006b8e:	d7 03       	nop
80006b90:	59 4a       	cp.w	r10,20
80006b92:	e0 8b 00 04 	brhi	80006b9a <_malloc_r+0x176>
80006b96:	2a 5a       	sub	r10,-91
80006b98:	c1 a8       	rjmp	80006bcc <_malloc_r+0x1a8>
80006b9a:	e0 4a 00 54 	cp.w	r10,84
80006b9e:	e0 8b 00 06 	brhi	80006baa <_malloc_r+0x186>
80006ba2:	f2 0a 16 0c 	lsr	r10,r9,0xc
80006ba6:	29 2a       	sub	r10,-110
80006ba8:	c1 28       	rjmp	80006bcc <_malloc_r+0x1a8>
80006baa:	e0 4a 01 54 	cp.w	r10,340
80006bae:	e0 8b 00 06 	brhi	80006bba <_malloc_r+0x196>
80006bb2:	f2 0a 16 0f 	lsr	r10,r9,0xf
80006bb6:	28 9a       	sub	r10,-119
80006bb8:	c0 a8       	rjmp	80006bcc <_malloc_r+0x1a8>
80006bba:	e0 4a 05 54 	cp.w	r10,1364
80006bbe:	e0 88 00 04 	brls	80006bc6 <_malloc_r+0x1a2>
80006bc2:	37 ea       	mov	r10,126
80006bc4:	c0 48       	rjmp	80006bcc <_malloc_r+0x1a8>
80006bc6:	f2 0a 16 12 	lsr	r10,r9,0x12
80006bca:	28 4a       	sub	r10,-124
80006bcc:	e0 6b 05 38 	mov	r11,1336
80006bd0:	f6 0a 00 34 	add	r4,r11,r10<<0x3
80006bd4:	68 28       	ld.w	r8,r4[0x8]
80006bd6:	08 38       	cp.w	r8,r4
80006bd8:	c0 e1       	brne	80006bf4 <_malloc_r+0x1d0>
80006bda:	76 19       	ld.w	r9,r11[0x4]
80006bdc:	a3 4a       	asr	r10,0x2
80006bde:	30 1e       	mov	lr,1
80006be0:	fc 0a 09 4a 	lsl	r10,lr,r10
80006be4:	f3 ea 10 0a 	or	r10,r9,r10
80006be8:	10 99       	mov	r9,r8
80006bea:	97 1a       	st.w	r11[0x4],r10
80006bec:	c0 a8       	rjmp	80006c00 <_malloc_r+0x1dc>
80006bee:	70 28       	ld.w	r8,r8[0x8]
80006bf0:	08 38       	cp.w	r8,r4
80006bf2:	c0 60       	breq	80006bfe <_malloc_r+0x1da>
80006bf4:	70 1a       	ld.w	r10,r8[0x4]
80006bf6:	e0 1a ff fc 	andl	r10,0xfffc
80006bfa:	14 39       	cp.w	r9,r10
80006bfc:	cf 93       	brcs	80006bee <_malloc_r+0x1ca>
80006bfe:	70 39       	ld.w	r9,r8[0xc]
80006c00:	8d 39       	st.w	r6[0xc],r9
80006c02:	8d 28       	st.w	r6[0x8],r8
80006c04:	91 36       	st.w	r8[0xc],r6
80006c06:	93 26       	st.w	r9[0x8],r6
80006c08:	e6 08 14 02 	asr	r8,r3,0x2
80006c0c:	30 1b       	mov	r11,1
80006c0e:	e0 64 05 38 	mov	r4,1336
80006c12:	f6 08 09 4b 	lsl	r11,r11,r8
80006c16:	68 18       	ld.w	r8,r4[0x4]
80006c18:	10 3b       	cp.w	r11,r8
80006c1a:	e0 8b 00 6b 	brhi	80006cf0 <_malloc_r+0x2cc>
80006c1e:	f7 e8 00 09 	and	r9,r11,r8
80006c22:	c0 b1       	brne	80006c38 <_malloc_r+0x214>
80006c24:	e0 13 ff fc 	andl	r3,0xfffc
80006c28:	a1 7b       	lsl	r11,0x1
80006c2a:	2f c3       	sub	r3,-4
80006c2c:	c0 38       	rjmp	80006c32 <_malloc_r+0x20e>
80006c2e:	2f c3       	sub	r3,-4
80006c30:	a1 7b       	lsl	r11,0x1
80006c32:	f7 e8 00 09 	and	r9,r11,r8
80006c36:	cf c0       	breq	80006c2e <_malloc_r+0x20a>
80006c38:	e8 03 00 3e 	add	lr,r4,r3<<0x3
80006c3c:	06 92       	mov	r2,r3
80006c3e:	1c 91       	mov	r1,lr
80006c40:	62 36       	ld.w	r6,r1[0xc]
80006c42:	c2 e8       	rjmp	80006c9e <_malloc_r+0x27a>
80006c44:	6c 1a       	ld.w	r10,r6[0x4]
80006c46:	e0 1a ff fc 	andl	r10,0xfffc
80006c4a:	f4 07 01 08 	sub	r8,r10,r7
80006c4e:	58 f8       	cp.w	r8,15
80006c50:	e0 8a 00 15 	brle	80006c7a <_malloc_r+0x256>
80006c54:	6c 3a       	ld.w	r10,r6[0xc]
80006c56:	6c 29       	ld.w	r9,r6[0x8]
80006c58:	95 29       	st.w	r10[0x8],r9
80006c5a:	93 3a       	st.w	r9[0xc],r10
80006c5c:	0e 99       	mov	r9,r7
80006c5e:	ec 07 00 07 	add	r7,r6,r7
80006c62:	a1 a9       	sbr	r9,0x0
80006c64:	99 37       	st.w	r12[0xc],r7
80006c66:	99 27       	st.w	r12[0x8],r7
80006c68:	8d 19       	st.w	r6[0x4],r9
80006c6a:	ee 08 09 08 	st.w	r7[r8],r8
80006c6e:	8f 2c       	st.w	r7[0x8],r12
80006c70:	8f 3c       	st.w	r7[0xc],r12
80006c72:	a1 a8       	sbr	r8,0x0
80006c74:	0a 9c       	mov	r12,r5
80006c76:	8f 18       	st.w	r7[0x4],r8
80006c78:	c0 d8       	rjmp	80006c92 <_malloc_r+0x26e>
80006c7a:	6c 39       	ld.w	r9,r6[0xc]
80006c7c:	58 08       	cp.w	r8,0
80006c7e:	c0 f5       	brlt	80006c9c <_malloc_r+0x278>
80006c80:	ec 0a 00 0a 	add	r10,r6,r10
80006c84:	74 18       	ld.w	r8,r10[0x4]
80006c86:	a1 a8       	sbr	r8,0x0
80006c88:	0a 9c       	mov	r12,r5
80006c8a:	95 18       	st.w	r10[0x4],r8
80006c8c:	6c 28       	ld.w	r8,r6[0x8]
80006c8e:	93 28       	st.w	r9[0x8],r8
80006c90:	91 39       	st.w	r8[0xc],r9
80006c92:	fe b0 f4 3b 	rcall	80005508 <__malloc_unlock>
80006c96:	ec cc ff f8 	sub	r12,r6,-8
80006c9a:	d8 32       	popm	r0-r7,pc
80006c9c:	12 96       	mov	r6,r9
80006c9e:	02 36       	cp.w	r6,r1
80006ca0:	cd 21       	brne	80006c44 <_malloc_r+0x220>
80006ca2:	2f f2       	sub	r2,-1
80006ca4:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
80006ca8:	c0 30       	breq	80006cae <_malloc_r+0x28a>
80006caa:	2f 81       	sub	r1,-8
80006cac:	cc ab       	rjmp	80006c40 <_malloc_r+0x21c>
80006cae:	1c 98       	mov	r8,lr
80006cb0:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
80006cb4:	c0 81       	brne	80006cc4 <_malloc_r+0x2a0>
80006cb6:	68 19       	ld.w	r9,r4[0x4]
80006cb8:	f6 08 11 ff 	rsub	r8,r11,-1
80006cbc:	f3 e8 00 08 	and	r8,r9,r8
80006cc0:	89 18       	st.w	r4[0x4],r8
80006cc2:	c0 78       	rjmp	80006cd0 <_malloc_r+0x2ac>
80006cc4:	f0 c9 00 08 	sub	r9,r8,8
80006cc8:	20 13       	sub	r3,1
80006cca:	70 08       	ld.w	r8,r8[0x0]
80006ccc:	12 38       	cp.w	r8,r9
80006cce:	cf 10       	breq	80006cb0 <_malloc_r+0x28c>
80006cd0:	a1 7b       	lsl	r11,0x1
80006cd2:	68 18       	ld.w	r8,r4[0x4]
80006cd4:	10 3b       	cp.w	r11,r8
80006cd6:	e0 8b 00 0d 	brhi	80006cf0 <_malloc_r+0x2cc>
80006cda:	58 0b       	cp.w	r11,0
80006cdc:	c0 a0       	breq	80006cf0 <_malloc_r+0x2cc>
80006cde:	04 93       	mov	r3,r2
80006ce0:	c0 38       	rjmp	80006ce6 <_malloc_r+0x2c2>
80006ce2:	2f c3       	sub	r3,-4
80006ce4:	a1 7b       	lsl	r11,0x1
80006ce6:	f7 e8 00 09 	and	r9,r11,r8
80006cea:	ca 71       	brne	80006c38 <_malloc_r+0x214>
80006cec:	cf bb       	rjmp	80006ce2 <_malloc_r+0x2be>
80006cee:	d7 03       	nop
80006cf0:	68 23       	ld.w	r3,r4[0x8]
80006cf2:	66 12       	ld.w	r2,r3[0x4]
80006cf4:	e0 12 ff fc 	andl	r2,0xfffc
80006cf8:	0e 32       	cp.w	r2,r7
80006cfa:	5f 39       	srlo	r9
80006cfc:	e4 07 01 08 	sub	r8,r2,r7
80006d00:	58 f8       	cp.w	r8,15
80006d02:	5f aa       	srle	r10
80006d04:	f5 e9 10 09 	or	r9,r10,r9
80006d08:	e0 80 00 9a 	breq	80006e3c <_malloc_r+0x418>
80006d0c:	e0 68 0d 80 	mov	r8,3456
80006d10:	70 01       	ld.w	r1,r8[0x0]
80006d12:	e0 68 09 44 	mov	r8,2372
80006d16:	2f 01       	sub	r1,-16
80006d18:	70 08       	ld.w	r8,r8[0x0]
80006d1a:	0e 01       	add	r1,r7
80006d1c:	5b f8       	cp.w	r8,-1
80006d1e:	c0 40       	breq	80006d26 <_malloc_r+0x302>
80006d20:	28 11       	sub	r1,-127
80006d22:	e0 11 ff 80 	andl	r1,0xff80
80006d26:	02 9b       	mov	r11,r1
80006d28:	0a 9c       	mov	r12,r5
80006d2a:	e0 a0 02 a5 	rcall	80007274 <_sbrk_r>
80006d2e:	18 96       	mov	r6,r12
80006d30:	5b fc       	cp.w	r12,-1
80006d32:	c7 50       	breq	80006e1c <_malloc_r+0x3f8>
80006d34:	e6 02 00 08 	add	r8,r3,r2
80006d38:	10 3c       	cp.w	r12,r8
80006d3a:	c0 32       	brcc	80006d40 <_malloc_r+0x31c>
80006d3c:	08 33       	cp.w	r3,r4
80006d3e:	c6 f1       	brne	80006e1c <_malloc_r+0x3f8>
80006d40:	e0 6a 0d 84 	mov	r10,3460
80006d44:	74 09       	ld.w	r9,r10[0x0]
80006d46:	e2 09 00 09 	add	r9,r1,r9
80006d4a:	95 09       	st.w	r10[0x0],r9
80006d4c:	10 36       	cp.w	r6,r8
80006d4e:	c0 a1       	brne	80006d62 <_malloc_r+0x33e>
80006d50:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
80006d54:	c0 71       	brne	80006d62 <_malloc_r+0x33e>
80006d56:	e2 02 00 02 	add	r2,r1,r2
80006d5a:	68 28       	ld.w	r8,r4[0x8]
80006d5c:	a1 a2       	sbr	r2,0x0
80006d5e:	91 12       	st.w	r8[0x4],r2
80006d60:	c4 f8       	rjmp	80006dfe <_malloc_r+0x3da>
80006d62:	e0 6a 09 44 	mov	r10,2372
80006d66:	74 0b       	ld.w	r11,r10[0x0]
80006d68:	5b fb       	cp.w	r11,-1
80006d6a:	c0 31       	brne	80006d70 <_malloc_r+0x34c>
80006d6c:	95 06       	st.w	r10[0x0],r6
80006d6e:	c0 78       	rjmp	80006d7c <_malloc_r+0x358>
80006d70:	ec 09 00 09 	add	r9,r6,r9
80006d74:	e0 6a 0d 84 	mov	r10,3460
80006d78:	10 19       	sub	r9,r8
80006d7a:	95 09       	st.w	r10[0x0],r9
80006d7c:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
80006d80:	f0 09 11 08 	rsub	r9,r8,8
80006d84:	58 08       	cp.w	r8,0
80006d86:	f2 08 17 10 	movne	r8,r9
80006d8a:	ed d8 e1 06 	addne	r6,r6,r8
80006d8e:	28 08       	sub	r8,-128
80006d90:	ec 01 00 01 	add	r1,r6,r1
80006d94:	0a 9c       	mov	r12,r5
80006d96:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
80006d9a:	f0 01 01 01 	sub	r1,r8,r1
80006d9e:	02 9b       	mov	r11,r1
80006da0:	e0 a0 02 6a 	rcall	80007274 <_sbrk_r>
80006da4:	e0 68 0d 84 	mov	r8,3460
80006da8:	5b fc       	cp.w	r12,-1
80006daa:	ec 0c 17 00 	moveq	r12,r6
80006dae:	f9 b1 00 00 	moveq	r1,0
80006db2:	70 09       	ld.w	r9,r8[0x0]
80006db4:	0c 1c       	sub	r12,r6
80006db6:	89 26       	st.w	r4[0x8],r6
80006db8:	02 0c       	add	r12,r1
80006dba:	12 01       	add	r1,r9
80006dbc:	a1 ac       	sbr	r12,0x0
80006dbe:	91 01       	st.w	r8[0x0],r1
80006dc0:	8d 1c       	st.w	r6[0x4],r12
80006dc2:	08 33       	cp.w	r3,r4
80006dc4:	c1 d0       	breq	80006dfe <_malloc_r+0x3da>
80006dc6:	58 f2       	cp.w	r2,15
80006dc8:	e0 8b 00 05 	brhi	80006dd2 <_malloc_r+0x3ae>
80006dcc:	30 18       	mov	r8,1
80006dce:	8d 18       	st.w	r6[0x4],r8
80006dd0:	c2 68       	rjmp	80006e1c <_malloc_r+0x3f8>
80006dd2:	30 59       	mov	r9,5
80006dd4:	20 c2       	sub	r2,12
80006dd6:	e0 12 ff f8 	andl	r2,0xfff8
80006dda:	e6 02 00 08 	add	r8,r3,r2
80006dde:	91 29       	st.w	r8[0x8],r9
80006de0:	91 19       	st.w	r8[0x4],r9
80006de2:	66 18       	ld.w	r8,r3[0x4]
80006de4:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006de8:	e5 e8 10 08 	or	r8,r2,r8
80006dec:	87 18       	st.w	r3[0x4],r8
80006dee:	58 f2       	cp.w	r2,15
80006df0:	e0 88 00 07 	brls	80006dfe <_malloc_r+0x3da>
80006df4:	e6 cb ff f8 	sub	r11,r3,-8
80006df8:	0a 9c       	mov	r12,r5
80006dfa:	e0 a0 1c 77 	rcall	8000a6e8 <_free_r>
80006dfe:	e0 69 0d 7c 	mov	r9,3452
80006e02:	72 0a       	ld.w	r10,r9[0x0]
80006e04:	e0 68 0d 84 	mov	r8,3460
80006e08:	70 08       	ld.w	r8,r8[0x0]
80006e0a:	14 38       	cp.w	r8,r10
80006e0c:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80006e10:	e0 69 0d 78 	mov	r9,3448
80006e14:	72 0a       	ld.w	r10,r9[0x0]
80006e16:	14 38       	cp.w	r8,r10
80006e18:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80006e1c:	68 28       	ld.w	r8,r4[0x8]
80006e1e:	70 18       	ld.w	r8,r8[0x4]
80006e20:	e0 18 ff fc 	andl	r8,0xfffc
80006e24:	0e 38       	cp.w	r8,r7
80006e26:	5f 39       	srlo	r9
80006e28:	0e 18       	sub	r8,r7
80006e2a:	58 f8       	cp.w	r8,15
80006e2c:	5f aa       	srle	r10
80006e2e:	f5 e9 10 09 	or	r9,r10,r9
80006e32:	c0 50       	breq	80006e3c <_malloc_r+0x418>
80006e34:	0a 9c       	mov	r12,r5
80006e36:	fe b0 f3 69 	rcall	80005508 <__malloc_unlock>
80006e3a:	d8 3a       	popm	r0-r7,pc,r12=0
80006e3c:	68 26       	ld.w	r6,r4[0x8]
80006e3e:	a1 a8       	sbr	r8,0x0
80006e40:	0e 99       	mov	r9,r7
80006e42:	a1 a9       	sbr	r9,0x0
80006e44:	8d 19       	st.w	r6[0x4],r9
80006e46:	ec 07 00 07 	add	r7,r6,r7
80006e4a:	0a 9c       	mov	r12,r5
80006e4c:	89 27       	st.w	r4[0x8],r7
80006e4e:	8f 18       	st.w	r7[0x4],r8
80006e50:	fe b0 f3 5c 	rcall	80005508 <__malloc_unlock>
80006e54:	ec cc ff f8 	sub	r12,r6,-8
80006e58:	d8 32       	popm	r0-r7,pc
80006e5a:	d7 03       	nop

80006e5c <memcpy>:
80006e5c:	58 8a       	cp.w	r10,8
80006e5e:	c2 f5       	brlt	80006ebc <memcpy+0x60>
80006e60:	f9 eb 10 09 	or	r9,r12,r11
80006e64:	e2 19 00 03 	andl	r9,0x3,COH
80006e68:	e0 81 00 97 	brne	80006f96 <memcpy+0x13a>
80006e6c:	e0 4a 00 20 	cp.w	r10,32
80006e70:	c3 b4       	brge	80006ee6 <memcpy+0x8a>
80006e72:	f4 08 14 02 	asr	r8,r10,0x2
80006e76:	f0 09 11 08 	rsub	r9,r8,8
80006e7a:	fe 09 00 2f 	add	pc,pc,r9<<0x2
80006e7e:	76 69       	ld.w	r9,r11[0x18]
80006e80:	99 69       	st.w	r12[0x18],r9
80006e82:	76 59       	ld.w	r9,r11[0x14]
80006e84:	99 59       	st.w	r12[0x14],r9
80006e86:	76 49       	ld.w	r9,r11[0x10]
80006e88:	99 49       	st.w	r12[0x10],r9
80006e8a:	76 39       	ld.w	r9,r11[0xc]
80006e8c:	99 39       	st.w	r12[0xc],r9
80006e8e:	76 29       	ld.w	r9,r11[0x8]
80006e90:	99 29       	st.w	r12[0x8],r9
80006e92:	76 19       	ld.w	r9,r11[0x4]
80006e94:	99 19       	st.w	r12[0x4],r9
80006e96:	76 09       	ld.w	r9,r11[0x0]
80006e98:	99 09       	st.w	r12[0x0],r9
80006e9a:	f6 08 00 2b 	add	r11,r11,r8<<0x2
80006e9e:	f8 08 00 28 	add	r8,r12,r8<<0x2
80006ea2:	e0 1a 00 03 	andl	r10,0x3
80006ea6:	f4 0a 11 04 	rsub	r10,r10,4
80006eaa:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80006eae:	17 a9       	ld.ub	r9,r11[0x2]
80006eb0:	b0 a9       	st.b	r8[0x2],r9
80006eb2:	17 99       	ld.ub	r9,r11[0x1]
80006eb4:	b0 99       	st.b	r8[0x1],r9
80006eb6:	17 89       	ld.ub	r9,r11[0x0]
80006eb8:	b0 89       	st.b	r8[0x0],r9
80006eba:	5e fc       	retal	r12
80006ebc:	f4 0a 11 09 	rsub	r10,r10,9
80006ec0:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80006ec4:	17 f9       	ld.ub	r9,r11[0x7]
80006ec6:	b8 f9       	st.b	r12[0x7],r9
80006ec8:	17 e9       	ld.ub	r9,r11[0x6]
80006eca:	b8 e9       	st.b	r12[0x6],r9
80006ecc:	17 d9       	ld.ub	r9,r11[0x5]
80006ece:	b8 d9       	st.b	r12[0x5],r9
80006ed0:	17 c9       	ld.ub	r9,r11[0x4]
80006ed2:	b8 c9       	st.b	r12[0x4],r9
80006ed4:	17 b9       	ld.ub	r9,r11[0x3]
80006ed6:	b8 b9       	st.b	r12[0x3],r9
80006ed8:	17 a9       	ld.ub	r9,r11[0x2]
80006eda:	b8 a9       	st.b	r12[0x2],r9
80006edc:	17 99       	ld.ub	r9,r11[0x1]
80006ede:	b8 99       	st.b	r12[0x1],r9
80006ee0:	17 89       	ld.ub	r9,r11[0x0]
80006ee2:	b8 89       	st.b	r12[0x0],r9
80006ee4:	5e fc       	retal	r12
80006ee6:	eb cd 40 c0 	pushm	r6-r7,lr
80006eea:	18 99       	mov	r9,r12
80006eec:	22 0a       	sub	r10,32
80006eee:	b7 07       	ld.d	r6,r11++
80006ef0:	b3 26       	st.d	r9++,r6
80006ef2:	b7 07       	ld.d	r6,r11++
80006ef4:	b3 26       	st.d	r9++,r6
80006ef6:	b7 07       	ld.d	r6,r11++
80006ef8:	b3 26       	st.d	r9++,r6
80006efa:	b7 07       	ld.d	r6,r11++
80006efc:	b3 26       	st.d	r9++,r6
80006efe:	22 0a       	sub	r10,32
80006f00:	cf 74       	brge	80006eee <memcpy+0x92>
80006f02:	2f 0a       	sub	r10,-16
80006f04:	c0 65       	brlt	80006f10 <memcpy+0xb4>
80006f06:	b7 07       	ld.d	r6,r11++
80006f08:	b3 26       	st.d	r9++,r6
80006f0a:	b7 07       	ld.d	r6,r11++
80006f0c:	b3 26       	st.d	r9++,r6
80006f0e:	21 0a       	sub	r10,16
80006f10:	5c 3a       	neg	r10
80006f12:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
80006f16:	d7 03       	nop
80006f18:	d7 03       	nop
80006f1a:	f7 36 00 0e 	ld.ub	r6,r11[14]
80006f1e:	f3 66 00 0e 	st.b	r9[14],r6
80006f22:	f7 36 00 0d 	ld.ub	r6,r11[13]
80006f26:	f3 66 00 0d 	st.b	r9[13],r6
80006f2a:	f7 36 00 0c 	ld.ub	r6,r11[12]
80006f2e:	f3 66 00 0c 	st.b	r9[12],r6
80006f32:	f7 36 00 0b 	ld.ub	r6,r11[11]
80006f36:	f3 66 00 0b 	st.b	r9[11],r6
80006f3a:	f7 36 00 0a 	ld.ub	r6,r11[10]
80006f3e:	f3 66 00 0a 	st.b	r9[10],r6
80006f42:	f7 36 00 09 	ld.ub	r6,r11[9]
80006f46:	f3 66 00 09 	st.b	r9[9],r6
80006f4a:	f7 36 00 08 	ld.ub	r6,r11[8]
80006f4e:	f3 66 00 08 	st.b	r9[8],r6
80006f52:	f7 36 00 07 	ld.ub	r6,r11[7]
80006f56:	f3 66 00 07 	st.b	r9[7],r6
80006f5a:	f7 36 00 06 	ld.ub	r6,r11[6]
80006f5e:	f3 66 00 06 	st.b	r9[6],r6
80006f62:	f7 36 00 05 	ld.ub	r6,r11[5]
80006f66:	f3 66 00 05 	st.b	r9[5],r6
80006f6a:	f7 36 00 04 	ld.ub	r6,r11[4]
80006f6e:	f3 66 00 04 	st.b	r9[4],r6
80006f72:	f7 36 00 03 	ld.ub	r6,r11[3]
80006f76:	f3 66 00 03 	st.b	r9[3],r6
80006f7a:	f7 36 00 02 	ld.ub	r6,r11[2]
80006f7e:	f3 66 00 02 	st.b	r9[2],r6
80006f82:	f7 36 00 01 	ld.ub	r6,r11[1]
80006f86:	f3 66 00 01 	st.b	r9[1],r6
80006f8a:	f7 36 00 00 	ld.ub	r6,r11[0]
80006f8e:	f3 66 00 00 	st.b	r9[0],r6
80006f92:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006f96:	20 1a       	sub	r10,1
80006f98:	f6 0a 07 09 	ld.ub	r9,r11[r10]
80006f9c:	f8 0a 0b 09 	st.b	r12[r10],r9
80006fa0:	cf b1       	brne	80006f96 <memcpy+0x13a>
80006fa2:	5e fc       	retal	r12

80006fa4 <memset>:
80006fa4:	18 98       	mov	r8,r12
80006fa6:	c0 38       	rjmp	80006fac <memset+0x8>
80006fa8:	10 cb       	st.b	r8++,r11
80006faa:	20 1a       	sub	r10,1
80006fac:	58 0a       	cp.w	r10,0
80006fae:	cf d1       	brne	80006fa8 <memset+0x4>
80006fb0:	5e fc       	retal	r12
80006fb2:	d7 03       	nop

80006fb4 <_realloc_r>:
80006fb4:	d4 31       	pushm	r0-r7,lr
80006fb6:	20 1d       	sub	sp,4
80006fb8:	16 94       	mov	r4,r11
80006fba:	18 92       	mov	r2,r12
80006fbc:	14 9b       	mov	r11,r10
80006fbe:	58 04       	cp.w	r4,0
80006fc0:	c0 51       	brne	80006fca <_realloc_r+0x16>
80006fc2:	fe b0 fd 31 	rcall	80006a24 <_malloc_r>
80006fc6:	18 95       	mov	r5,r12
80006fc8:	c5 39       	rjmp	8000726e <_realloc_r+0x2ba>
80006fca:	50 0a       	stdsp	sp[0x0],r10
80006fcc:	fe b0 f2 98 	rcall	800054fc <__malloc_lock>
80006fd0:	40 0b       	lddsp	r11,sp[0x0]
80006fd2:	f6 c8 ff f5 	sub	r8,r11,-11
80006fd6:	e8 c1 00 08 	sub	r1,r4,8
80006fda:	10 96       	mov	r6,r8
80006fdc:	62 1c       	ld.w	r12,r1[0x4]
80006fde:	e0 16 ff f8 	andl	r6,0xfff8
80006fe2:	59 68       	cp.w	r8,22
80006fe4:	f9 b6 08 10 	movls	r6,16
80006fe8:	16 36       	cp.w	r6,r11
80006fea:	5f 38       	srlo	r8
80006fec:	f1 e6 13 f8 	or	r8,r8,r6>>0x1f
80006ff0:	c0 50       	breq	80006ffa <_realloc_r+0x46>
80006ff2:	30 c8       	mov	r8,12
80006ff4:	30 05       	mov	r5,0
80006ff6:	85 38       	st.w	r2[0xc],r8
80006ff8:	c3 b9       	rjmp	8000726e <_realloc_r+0x2ba>
80006ffa:	18 90       	mov	r0,r12
80006ffc:	e0 10 ff fc 	andl	r0,0xfffc
80007000:	0c 30       	cp.w	r0,r6
80007002:	e0 84 01 0b 	brge	80007218 <_realloc_r+0x264>
80007006:	e0 68 05 38 	mov	r8,1336
8000700a:	e2 00 00 09 	add	r9,r1,r0
8000700e:	70 25       	ld.w	r5,r8[0x8]
80007010:	0a 39       	cp.w	r9,r5
80007012:	c0 90       	breq	80007024 <_realloc_r+0x70>
80007014:	72 1a       	ld.w	r10,r9[0x4]
80007016:	a1 ca       	cbr	r10,0x0
80007018:	f2 0a 00 0a 	add	r10,r9,r10
8000701c:	74 1a       	ld.w	r10,r10[0x4]
8000701e:	ed ba 00 00 	bld	r10,0x0
80007022:	c2 20       	breq	80007066 <_realloc_r+0xb2>
80007024:	72 1a       	ld.w	r10,r9[0x4]
80007026:	e0 1a ff fc 	andl	r10,0xfffc
8000702a:	f4 00 00 03 	add	r3,r10,r0
8000702e:	0a 39       	cp.w	r9,r5
80007030:	c1 31       	brne	80007056 <_realloc_r+0xa2>
80007032:	ec c7 ff f0 	sub	r7,r6,-16
80007036:	0e 33       	cp.w	r3,r7
80007038:	c1 95       	brlt	8000706a <_realloc_r+0xb6>
8000703a:	e2 06 00 09 	add	r9,r1,r6
8000703e:	0c 13       	sub	r3,r6
80007040:	a1 a3       	sbr	r3,0x0
80007042:	93 13       	st.w	r9[0x4],r3
80007044:	91 29       	st.w	r8[0x8],r9
80007046:	04 9c       	mov	r12,r2
80007048:	62 18       	ld.w	r8,r1[0x4]
8000704a:	08 95       	mov	r5,r4
8000704c:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007050:	10 46       	or	r6,r8
80007052:	83 16       	st.w	r1[0x4],r6
80007054:	c0 b9       	rjmp	8000726a <_realloc_r+0x2b6>
80007056:	0c 33       	cp.w	r3,r6
80007058:	c0 95       	brlt	8000706a <_realloc_r+0xb6>
8000705a:	72 28       	ld.w	r8,r9[0x8]
8000705c:	02 97       	mov	r7,r1
8000705e:	72 39       	ld.w	r9,r9[0xc]
80007060:	93 28       	st.w	r9[0x8],r8
80007062:	91 39       	st.w	r8[0xc],r9
80007064:	cd c8       	rjmp	8000721c <_realloc_r+0x268>
80007066:	30 0a       	mov	r10,0
80007068:	14 99       	mov	r9,r10
8000706a:	ed bc 00 00 	bld	r12,0x0
8000706e:	e0 80 00 95 	breq	80007198 <_realloc_r+0x1e4>
80007072:	62 07       	ld.w	r7,r1[0x0]
80007074:	e2 07 01 07 	sub	r7,r1,r7
80007078:	6e 1c       	ld.w	r12,r7[0x4]
8000707a:	e0 1c ff fc 	andl	r12,0xfffc
8000707e:	58 09       	cp.w	r9,0
80007080:	c5 60       	breq	8000712c <_realloc_r+0x178>
80007082:	f8 00 00 03 	add	r3,r12,r0
80007086:	0a 39       	cp.w	r9,r5
80007088:	c4 81       	brne	80007118 <_realloc_r+0x164>
8000708a:	14 03       	add	r3,r10
8000708c:	ec c9 ff f0 	sub	r9,r6,-16
80007090:	12 33       	cp.w	r3,r9
80007092:	c4 d5       	brlt	8000712c <_realloc_r+0x178>
80007094:	6e 3a       	ld.w	r10,r7[0xc]
80007096:	6e 29       	ld.w	r9,r7[0x8]
80007098:	95 29       	st.w	r10[0x8],r9
8000709a:	93 3a       	st.w	r9[0xc],r10
8000709c:	ee c5 ff f8 	sub	r5,r7,-8
800070a0:	e0 ca 00 04 	sub	r10,r0,4
800070a4:	e0 4a 00 24 	cp.w	r10,36
800070a8:	e0 8b 00 25 	brhi	800070f2 <_realloc_r+0x13e>
800070ac:	0a 99       	mov	r9,r5
800070ae:	59 3a       	cp.w	r10,19
800070b0:	e0 88 00 1a 	brls	800070e4 <_realloc_r+0x130>
800070b4:	09 09       	ld.w	r9,r4++
800070b6:	8b 09       	st.w	r5[0x0],r9
800070b8:	09 09       	ld.w	r9,r4++
800070ba:	8f 39       	st.w	r7[0xc],r9
800070bc:	ee c9 ff f0 	sub	r9,r7,-16
800070c0:	59 ba       	cp.w	r10,27
800070c2:	e0 88 00 11 	brls	800070e4 <_realloc_r+0x130>
800070c6:	09 0b       	ld.w	r11,r4++
800070c8:	93 0b       	st.w	r9[0x0],r11
800070ca:	09 09       	ld.w	r9,r4++
800070cc:	8f 59       	st.w	r7[0x14],r9
800070ce:	ee c9 ff e8 	sub	r9,r7,-24
800070d2:	e0 4a 00 24 	cp.w	r10,36
800070d6:	c0 71       	brne	800070e4 <_realloc_r+0x130>
800070d8:	09 0a       	ld.w	r10,r4++
800070da:	93 0a       	st.w	r9[0x0],r10
800070dc:	ee c9 ff e0 	sub	r9,r7,-32
800070e0:	09 0a       	ld.w	r10,r4++
800070e2:	8f 7a       	st.w	r7[0x1c],r10
800070e4:	09 0a       	ld.w	r10,r4++
800070e6:	12 aa       	st.w	r9++,r10
800070e8:	68 0a       	ld.w	r10,r4[0x0]
800070ea:	93 0a       	st.w	r9[0x0],r10
800070ec:	68 1a       	ld.w	r10,r4[0x4]
800070ee:	93 1a       	st.w	r9[0x4],r10
800070f0:	c0 78       	rjmp	800070fe <_realloc_r+0x14a>
800070f2:	50 08       	stdsp	sp[0x0],r8
800070f4:	08 9b       	mov	r11,r4
800070f6:	0a 9c       	mov	r12,r5
800070f8:	e0 a0 1d 9b 	rcall	8000ac2e <memmove>
800070fc:	40 08       	lddsp	r8,sp[0x0]
800070fe:	ee 06 00 09 	add	r9,r7,r6
80007102:	0c 13       	sub	r3,r6
80007104:	a1 a3       	sbr	r3,0x0
80007106:	93 13       	st.w	r9[0x4],r3
80007108:	91 29       	st.w	r8[0x8],r9
8000710a:	04 9c       	mov	r12,r2
8000710c:	6e 18       	ld.w	r8,r7[0x4]
8000710e:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007112:	10 46       	or	r6,r8
80007114:	8f 16       	st.w	r7[0x4],r6
80007116:	ca a8       	rjmp	8000726a <_realloc_r+0x2b6>
80007118:	14 03       	add	r3,r10
8000711a:	0c 33       	cp.w	r3,r6
8000711c:	c0 85       	brlt	8000712c <_realloc_r+0x178>
8000711e:	72 28       	ld.w	r8,r9[0x8]
80007120:	72 39       	ld.w	r9,r9[0xc]
80007122:	93 28       	st.w	r9[0x8],r8
80007124:	91 39       	st.w	r8[0xc],r9
80007126:	6e 28       	ld.w	r8,r7[0x8]
80007128:	6e 39       	ld.w	r9,r7[0xc]
8000712a:	c0 78       	rjmp	80007138 <_realloc_r+0x184>
8000712c:	f8 00 00 03 	add	r3,r12,r0
80007130:	0c 33       	cp.w	r3,r6
80007132:	c3 35       	brlt	80007198 <_realloc_r+0x1e4>
80007134:	6e 39       	ld.w	r9,r7[0xc]
80007136:	6e 28       	ld.w	r8,r7[0x8]
80007138:	93 28       	st.w	r9[0x8],r8
8000713a:	91 39       	st.w	r8[0xc],r9
8000713c:	e0 ca 00 04 	sub	r10,r0,4
80007140:	ee cc ff f8 	sub	r12,r7,-8
80007144:	e0 4a 00 24 	cp.w	r10,36
80007148:	e0 8b 00 24 	brhi	80007190 <_realloc_r+0x1dc>
8000714c:	59 3a       	cp.w	r10,19
8000714e:	e0 88 00 1a 	brls	80007182 <_realloc_r+0x1ce>
80007152:	09 08       	ld.w	r8,r4++
80007154:	99 08       	st.w	r12[0x0],r8
80007156:	09 08       	ld.w	r8,r4++
80007158:	8f 38       	st.w	r7[0xc],r8
8000715a:	ee cc ff f0 	sub	r12,r7,-16
8000715e:	59 ba       	cp.w	r10,27
80007160:	e0 88 00 11 	brls	80007182 <_realloc_r+0x1ce>
80007164:	09 08       	ld.w	r8,r4++
80007166:	99 08       	st.w	r12[0x0],r8
80007168:	09 08       	ld.w	r8,r4++
8000716a:	8f 58       	st.w	r7[0x14],r8
8000716c:	ee cc ff e8 	sub	r12,r7,-24
80007170:	e0 4a 00 24 	cp.w	r10,36
80007174:	c0 71       	brne	80007182 <_realloc_r+0x1ce>
80007176:	09 08       	ld.w	r8,r4++
80007178:	99 08       	st.w	r12[0x0],r8
8000717a:	ee cc ff e0 	sub	r12,r7,-32
8000717e:	09 08       	ld.w	r8,r4++
80007180:	8f 78       	st.w	r7[0x1c],r8
80007182:	09 08       	ld.w	r8,r4++
80007184:	18 a8       	st.w	r12++,r8
80007186:	68 08       	ld.w	r8,r4[0x0]
80007188:	99 08       	st.w	r12[0x0],r8
8000718a:	68 18       	ld.w	r8,r4[0x4]
8000718c:	99 18       	st.w	r12[0x4],r8
8000718e:	c4 78       	rjmp	8000721c <_realloc_r+0x268>
80007190:	08 9b       	mov	r11,r4
80007192:	e0 a0 1d 4e 	rcall	8000ac2e <memmove>
80007196:	c4 38       	rjmp	8000721c <_realloc_r+0x268>
80007198:	04 9c       	mov	r12,r2
8000719a:	fe b0 fc 45 	rcall	80006a24 <_malloc_r>
8000719e:	18 95       	mov	r5,r12
800071a0:	c3 a0       	breq	80007214 <_realloc_r+0x260>
800071a2:	62 18       	ld.w	r8,r1[0x4]
800071a4:	f8 c9 00 08 	sub	r9,r12,8
800071a8:	a1 c8       	cbr	r8,0x0
800071aa:	e2 08 00 08 	add	r8,r1,r8
800071ae:	10 39       	cp.w	r9,r8
800071b0:	c0 71       	brne	800071be <_realloc_r+0x20a>
800071b2:	72 13       	ld.w	r3,r9[0x4]
800071b4:	02 97       	mov	r7,r1
800071b6:	e0 13 ff fc 	andl	r3,0xfffc
800071ba:	00 03       	add	r3,r0
800071bc:	c3 08       	rjmp	8000721c <_realloc_r+0x268>
800071be:	e0 ca 00 04 	sub	r10,r0,4
800071c2:	e0 4a 00 24 	cp.w	r10,36
800071c6:	e0 8b 00 20 	brhi	80007206 <_realloc_r+0x252>
800071ca:	08 99       	mov	r9,r4
800071cc:	18 98       	mov	r8,r12
800071ce:	59 3a       	cp.w	r10,19
800071d0:	e0 88 00 14 	brls	800071f8 <_realloc_r+0x244>
800071d4:	13 0b       	ld.w	r11,r9++
800071d6:	10 ab       	st.w	r8++,r11
800071d8:	13 0b       	ld.w	r11,r9++
800071da:	10 ab       	st.w	r8++,r11
800071dc:	59 ba       	cp.w	r10,27
800071de:	e0 88 00 0d 	brls	800071f8 <_realloc_r+0x244>
800071e2:	13 0b       	ld.w	r11,r9++
800071e4:	10 ab       	st.w	r8++,r11
800071e6:	13 0b       	ld.w	r11,r9++
800071e8:	10 ab       	st.w	r8++,r11
800071ea:	e0 4a 00 24 	cp.w	r10,36
800071ee:	c0 51       	brne	800071f8 <_realloc_r+0x244>
800071f0:	13 0a       	ld.w	r10,r9++
800071f2:	10 aa       	st.w	r8++,r10
800071f4:	13 0a       	ld.w	r10,r9++
800071f6:	10 aa       	st.w	r8++,r10
800071f8:	13 0a       	ld.w	r10,r9++
800071fa:	10 aa       	st.w	r8++,r10
800071fc:	72 0a       	ld.w	r10,r9[0x0]
800071fe:	91 0a       	st.w	r8[0x0],r10
80007200:	72 19       	ld.w	r9,r9[0x4]
80007202:	91 19       	st.w	r8[0x4],r9
80007204:	c0 48       	rjmp	8000720c <_realloc_r+0x258>
80007206:	08 9b       	mov	r11,r4
80007208:	e0 a0 1d 13 	rcall	8000ac2e <memmove>
8000720c:	08 9b       	mov	r11,r4
8000720e:	04 9c       	mov	r12,r2
80007210:	e0 a0 1a 6c 	rcall	8000a6e8 <_free_r>
80007214:	04 9c       	mov	r12,r2
80007216:	c2 a8       	rjmp	8000726a <_realloc_r+0x2b6>
80007218:	00 93       	mov	r3,r0
8000721a:	02 97       	mov	r7,r1
8000721c:	e6 06 01 09 	sub	r9,r3,r6
80007220:	6e 18       	ld.w	r8,r7[0x4]
80007222:	58 f9       	cp.w	r9,15
80007224:	e0 88 00 16 	brls	80007250 <_realloc_r+0x29c>
80007228:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000722c:	ed e8 10 08 	or	r8,r6,r8
80007230:	8f 18       	st.w	r7[0x4],r8
80007232:	12 98       	mov	r8,r9
80007234:	a1 a8       	sbr	r8,0x0
80007236:	ee 06 00 0b 	add	r11,r7,r6
8000723a:	f6 09 00 09 	add	r9,r11,r9
8000723e:	97 18       	st.w	r11[0x4],r8
80007240:	72 18       	ld.w	r8,r9[0x4]
80007242:	a1 a8       	sbr	r8,0x0
80007244:	2f 8b       	sub	r11,-8
80007246:	93 18       	st.w	r9[0x4],r8
80007248:	04 9c       	mov	r12,r2
8000724a:	e0 a0 1a 4f 	rcall	8000a6e8 <_free_r>
8000724e:	c0 b8       	rjmp	80007264 <_realloc_r+0x2b0>
80007250:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007254:	e7 e8 10 08 	or	r8,r3,r8
80007258:	8f 18       	st.w	r7[0x4],r8
8000725a:	ee 03 00 03 	add	r3,r7,r3
8000725e:	66 18       	ld.w	r8,r3[0x4]
80007260:	a1 a8       	sbr	r8,0x0
80007262:	87 18       	st.w	r3[0x4],r8
80007264:	04 9c       	mov	r12,r2
80007266:	ee c5 ff f8 	sub	r5,r7,-8
8000726a:	fe b0 f1 4f 	rcall	80005508 <__malloc_unlock>
8000726e:	0a 9c       	mov	r12,r5
80007270:	2f fd       	sub	sp,-4
80007272:	d8 32       	popm	r0-r7,pc

80007274 <_sbrk_r>:
80007274:	d4 21       	pushm	r4-r7,lr
80007276:	30 08       	mov	r8,0
80007278:	18 97       	mov	r7,r12
8000727a:	e0 66 41 1c 	mov	r6,16668
8000727e:	16 9c       	mov	r12,r11
80007280:	8d 08       	st.w	r6[0x0],r8
80007282:	c9 1c       	rcall	800073a4 <_sbrk>
80007284:	5b fc       	cp.w	r12,-1
80007286:	c0 51       	brne	80007290 <_sbrk_r+0x1c>
80007288:	6c 08       	ld.w	r8,r6[0x0]
8000728a:	58 08       	cp.w	r8,0
8000728c:	ef f8 1a 03 	st.wne	r7[0xc],r8
80007290:	d8 22       	popm	r4-r7,pc
80007292:	d7 03       	nop

80007294 <sprintf>:
80007294:	d4 01       	pushm	lr
80007296:	21 7d       	sub	sp,92
80007298:	e0 68 ff ff 	mov	r8,65535
8000729c:	ea 18 7f ff 	orh	r8,0x7fff
800072a0:	50 58       	stdsp	sp[0x14],r8
800072a2:	50 28       	stdsp	sp[0x8],r8
800072a4:	e0 68 02 08 	mov	r8,520
800072a8:	ba 68       	st.h	sp[0xc],r8
800072aa:	3f f8       	mov	r8,-1
800072ac:	ba 78       	st.h	sp[0xe],r8
800072ae:	e0 68 0a 38 	mov	r8,2616
800072b2:	50 4c       	stdsp	sp[0x10],r12
800072b4:	16 9a       	mov	r10,r11
800072b6:	50 0c       	stdsp	sp[0x0],r12
800072b8:	fa c9 ff a0 	sub	r9,sp,-96
800072bc:	70 0c       	ld.w	r12,r8[0x0]
800072be:	1a 9b       	mov	r11,sp
800072c0:	e0 a0 02 26 	rcall	8000770c <_vfprintf_r>
800072c4:	30 09       	mov	r9,0
800072c6:	40 08       	lddsp	r8,sp[0x0]
800072c8:	b0 89       	st.b	r8[0x0],r9
800072ca:	2e 9d       	sub	sp,-92
800072cc:	d8 02       	popm	pc
800072ce:	d7 03       	nop

800072d0 <strlen>:
800072d0:	30 09       	mov	r9,0
800072d2:	18 98       	mov	r8,r12
800072d4:	c0 28       	rjmp	800072d8 <strlen+0x8>
800072d6:	2f f8       	sub	r8,-1
800072d8:	11 8a       	ld.ub	r10,r8[0x0]
800072da:	f2 0a 18 00 	cp.b	r10,r9
800072de:	cf c1       	brne	800072d6 <strlen+0x6>
800072e0:	f0 0c 01 0c 	sub	r12,r8,r12
800072e4:	5e fc       	retal	r12
800072e6:	d7 03       	nop

800072e8 <strncpy>:
800072e8:	30 08       	mov	r8,0
800072ea:	10 3a       	cp.w	r10,r8
800072ec:	5e 0c       	reteq	r12
800072ee:	f6 08 07 09 	ld.ub	r9,r11[r8]
800072f2:	f8 08 0b 09 	st.b	r12[r8],r9
800072f6:	2f f8       	sub	r8,-1
800072f8:	58 09       	cp.w	r9,0
800072fa:	cf 81       	brne	800072ea <strncpy+0x2>
800072fc:	10 3a       	cp.w	r10,r8
800072fe:	5e 0c       	reteq	r12
80007300:	f8 08 0b 09 	st.b	r12[r8],r9
80007304:	2f f8       	sub	r8,-1
80007306:	cf bb       	rjmp	800072fc <strncpy+0x14>

80007308 <_close>:
80007308:	30 28       	mov	r8,2
8000730a:	d6 73       	breakpoint
8000730c:	3f fc       	mov	r12,-1
8000730e:	35 8b       	mov	r11,88
80007310:	58 0c       	cp.w	r12,0
80007312:	5e 4c       	retge	r12
80007314:	e0 6a 41 1c 	mov	r10,16668
80007318:	95 0b       	st.w	r10[0x0],r11
8000731a:	5e fc       	retal	r12

8000731c <_lseek>:
8000731c:	30 58       	mov	r8,5
8000731e:	d6 73       	breakpoint
80007320:	3f fc       	mov	r12,-1
80007322:	35 8b       	mov	r11,88
80007324:	58 0c       	cp.w	r12,0
80007326:	5e 4c       	retge	r12
80007328:	e0 6a 41 1c 	mov	r10,16668
8000732c:	95 0b       	st.w	r10[0x0],r11
8000732e:	5e fc       	retal	r12

80007330 <isatty>:
80007330:	30 b8       	mov	r8,11
80007332:	d6 73       	breakpoint
80007334:	3f fc       	mov	r12,-1
80007336:	35 8b       	mov	r11,88
80007338:	58 0c       	cp.w	r12,0
8000733a:	5e 4c       	retge	r12
8000733c:	e0 6a 41 1c 	mov	r10,16668
80007340:	95 0b       	st.w	r10[0x0],r11
80007342:	5e fc       	retal	r12

80007344 <_fstat_host>:
80007344:	30 98       	mov	r8,9
80007346:	d6 73       	breakpoint
80007348:	3f fc       	mov	r12,-1
8000734a:	35 8b       	mov	r11,88
8000734c:	58 0c       	cp.w	r12,0
8000734e:	5e 4c       	retge	r12
80007350:	e0 6a 41 1c 	mov	r10,16668
80007354:	95 0b       	st.w	r10[0x0],r11
80007356:	5e fc       	retal	r12

80007358 <_fstat>:
80007358:	d4 21       	pushm	r4-r7,lr
8000735a:	21 0d       	sub	sp,64
8000735c:	16 97       	mov	r7,r11
8000735e:	1a 9b       	mov	r11,sp
80007360:	cf 2f       	rcall	80007344 <_fstat_host>
80007362:	c0 34       	brge	80007368 <_fstat+0x10>
80007364:	3f fc       	mov	r12,-1
80007366:	c1 c8       	rjmp	8000739e <_fstat+0x46>
80007368:	40 08       	lddsp	r8,sp[0x0]
8000736a:	ae 08       	st.h	r7[0x0],r8
8000736c:	40 18       	lddsp	r8,sp[0x4]
8000736e:	ae 18       	st.h	r7[0x2],r8
80007370:	40 28       	lddsp	r8,sp[0x8]
80007372:	8f 18       	st.w	r7[0x4],r8
80007374:	40 38       	lddsp	r8,sp[0xc]
80007376:	ae 48       	st.h	r7[0x8],r8
80007378:	40 48       	lddsp	r8,sp[0x10]
8000737a:	ae 58       	st.h	r7[0xa],r8
8000737c:	40 58       	lddsp	r8,sp[0x14]
8000737e:	ae 68       	st.h	r7[0xc],r8
80007380:	40 68       	lddsp	r8,sp[0x18]
80007382:	ae 78       	st.h	r7[0xe],r8
80007384:	40 88       	lddsp	r8,sp[0x20]
80007386:	8f 48       	st.w	r7[0x10],r8
80007388:	40 a8       	lddsp	r8,sp[0x28]
8000738a:	8f b8       	st.w	r7[0x2c],r8
8000738c:	40 c8       	lddsp	r8,sp[0x30]
8000738e:	8f c8       	st.w	r7[0x30],r8
80007390:	40 d8       	lddsp	r8,sp[0x34]
80007392:	8f 58       	st.w	r7[0x14],r8
80007394:	40 e8       	lddsp	r8,sp[0x38]
80007396:	30 0c       	mov	r12,0
80007398:	8f 78       	st.w	r7[0x1c],r8
8000739a:	40 f8       	lddsp	r8,sp[0x3c]
8000739c:	8f 98       	st.w	r7[0x24],r8
8000739e:	2f 0d       	sub	sp,-64
800073a0:	d8 22       	popm	r4-r7,pc
800073a2:	d7 03       	nop

800073a4 <_sbrk>:
800073a4:	d4 01       	pushm	lr
800073a6:	e0 68 0d ac 	mov	r8,3500
800073aa:	70 09       	ld.w	r9,r8[0x0]
800073ac:	58 09       	cp.w	r9,0
800073ae:	c0 41       	brne	800073b6 <_sbrk+0x12>
800073b0:	e0 69 41 20 	mov	r9,16672
800073b4:	91 09       	st.w	r8[0x0],r9
800073b6:	e0 69 0d ac 	mov	r9,3500
800073ba:	e0 7a 70 00 	mov	r10,94208
800073be:	72 08       	ld.w	r8,r9[0x0]
800073c0:	f0 0c 00 0c 	add	r12,r8,r12
800073c4:	14 3c       	cp.w	r12,r10
800073c6:	e0 8b 00 04 	brhi	800073ce <_sbrk+0x2a>
800073ca:	93 0c       	st.w	r9[0x0],r12
800073cc:	c0 68       	rjmp	800073d8 <_sbrk+0x34>
800073ce:	e0 a0 18 15 	rcall	8000a3f8 <__errno>
800073d2:	30 c8       	mov	r8,12
800073d4:	99 08       	st.w	r12[0x0],r8
800073d6:	3f f8       	mov	r8,-1
800073d8:	10 9c       	mov	r12,r8
800073da:	d8 02       	popm	pc

800073dc <get_arg>:
800073dc:	d4 31       	pushm	r0-r7,lr
800073de:	20 8d       	sub	sp,32
800073e0:	fa c4 ff bc 	sub	r4,sp,-68
800073e4:	50 4b       	stdsp	sp[0x10],r11
800073e6:	68 2e       	ld.w	lr,r4[0x8]
800073e8:	50 58       	stdsp	sp[0x14],r8
800073ea:	12 96       	mov	r6,r9
800073ec:	7c 0b       	ld.w	r11,lr[0x0]
800073ee:	70 05       	ld.w	r5,r8[0x0]
800073f0:	50 6e       	stdsp	sp[0x18],lr
800073f2:	58 0b       	cp.w	r11,0
800073f4:	f4 0b 17 00 	moveq	r11,r10
800073f8:	68 03       	ld.w	r3,r4[0x0]
800073fa:	68 11       	ld.w	r1,r4[0x4]
800073fc:	40 49       	lddsp	r9,sp[0x10]
800073fe:	30 08       	mov	r8,0
80007400:	c2 89       	rjmp	80007650 <get_arg+0x274>
80007402:	2f fb       	sub	r11,-1
80007404:	32 5c       	mov	r12,37
80007406:	17 8a       	ld.ub	r10,r11[0x0]
80007408:	f8 0a 18 00 	cp.b	r10,r12
8000740c:	5f 1e       	srne	lr
8000740e:	f0 0a 18 00 	cp.b	r10,r8
80007412:	5f 1c       	srne	r12
80007414:	fd ec 00 0c 	and	r12,lr,r12
80007418:	f0 0c 18 00 	cp.b	r12,r8
8000741c:	cf 31       	brne	80007402 <get_arg+0x26>
8000741e:	58 0a       	cp.w	r10,0
80007420:	e0 80 01 25 	breq	8000766a <get_arg+0x28e>
80007424:	30 0c       	mov	r12,0
80007426:	3f fa       	mov	r10,-1
80007428:	18 90       	mov	r0,r12
8000742a:	50 3a       	stdsp	sp[0xc],r10
8000742c:	18 94       	mov	r4,r12
8000742e:	18 92       	mov	r2,r12
80007430:	f8 0c 00 3c 	add	r12,r12,r12<<0x3
80007434:	16 97       	mov	r7,r11
80007436:	50 7c       	stdsp	sp[0x1c],r12
80007438:	fe cc 99 88 	sub	r12,pc,-26232
8000743c:	0f 3a       	ld.ub	r10,r7++
8000743e:	f8 0a 07 0e 	ld.ub	lr,r12[r10]
80007442:	40 7c       	lddsp	r12,sp[0x1c]
80007444:	1c 0c       	add	r12,lr
80007446:	fe ce 9a 5e 	sub	lr,pc,-26018
8000744a:	fc 0c 07 0e 	ld.ub	lr,lr[r12]
8000744e:	20 1e       	sub	lr,1
80007450:	50 0e       	stdsp	sp[0x0],lr
80007452:	fe ce 9a d6 	sub	lr,pc,-25898
80007456:	fc 0c 07 0c 	ld.ub	r12,lr[r12]
8000745a:	50 7c       	stdsp	sp[0x1c],r12
8000745c:	40 0c       	lddsp	r12,sp[0x0]
8000745e:	58 7c       	cp.w	r12,7
80007460:	e0 8b 00 f1 	brhi	80007642 <get_arg+0x266>
80007464:	fe ce 9c 88 	sub	lr,pc,-25464
80007468:	fc 0c 03 2f 	ld.w	pc,lr[r12<<0x2]
8000746c:	36 8b       	mov	r11,104
8000746e:	f6 0a 18 00 	cp.b	r10,r11
80007472:	e0 80 00 e8 	breq	80007642 <get_arg+0x266>
80007476:	37 1b       	mov	r11,113
80007478:	f6 0a 18 00 	cp.b	r10,r11
8000747c:	c0 70       	breq	8000748a <get_arg+0xae>
8000747e:	34 cb       	mov	r11,76
80007480:	f6 0a 18 00 	cp.b	r10,r11
80007484:	c0 51       	brne	8000748e <get_arg+0xb2>
80007486:	a3 b4       	sbr	r4,0x3
80007488:	cd d8       	rjmp	80007642 <get_arg+0x266>
8000748a:	a5 b4       	sbr	r4,0x5
8000748c:	cd b8       	rjmp	80007642 <get_arg+0x266>
8000748e:	08 9a       	mov	r10,r4
80007490:	0e 9b       	mov	r11,r7
80007492:	a5 aa       	sbr	r10,0x4
80007494:	17 3c       	ld.ub	r12,r11++
80007496:	a5 b4       	sbr	r4,0x5
80007498:	36 ce       	mov	lr,108
8000749a:	fc 0c 18 00 	cp.b	r12,lr
8000749e:	e0 80 00 d3 	breq	80007644 <get_arg+0x268>
800074a2:	14 94       	mov	r4,r10
800074a4:	cc f8       	rjmp	80007642 <get_arg+0x266>
800074a6:	eb d5 c0 05 	bfextu	r5,r5,0x0,0x5
800074aa:	36 7c       	mov	r12,103
800074ac:	f8 0a 18 00 	cp.b	r10,r12
800074b0:	e0 8b 00 27 	brhi	800074fe <get_arg+0x122>
800074b4:	36 5b       	mov	r11,101
800074b6:	f6 0a 18 00 	cp.b	r10,r11
800074ba:	c4 82       	brcc	8000754a <get_arg+0x16e>
800074bc:	34 fb       	mov	r11,79
800074be:	f6 0a 18 00 	cp.b	r10,r11
800074c2:	c4 80       	breq	80007552 <get_arg+0x176>
800074c4:	e0 8b 00 0c 	brhi	800074dc <get_arg+0x100>
800074c8:	34 5b       	mov	r11,69
800074ca:	f6 0a 18 00 	cp.b	r10,r11
800074ce:	c3 e0       	breq	8000754a <get_arg+0x16e>
800074d0:	34 7b       	mov	r11,71
800074d2:	f6 0a 18 00 	cp.b	r10,r11
800074d6:	c3 a0       	breq	8000754a <get_arg+0x16e>
800074d8:	34 4b       	mov	r11,68
800074da:	c0 88       	rjmp	800074ea <get_arg+0x10e>
800074dc:	35 8b       	mov	r11,88
800074de:	f6 0a 18 00 	cp.b	r10,r11
800074e2:	c2 c0       	breq	8000753a <get_arg+0x15e>
800074e4:	e0 8b 00 07 	brhi	800074f2 <get_arg+0x116>
800074e8:	35 5b       	mov	r11,85
800074ea:	f6 0a 18 00 	cp.b	r10,r11
800074ee:	c3 51       	brne	80007558 <get_arg+0x17c>
800074f0:	c3 18       	rjmp	80007552 <get_arg+0x176>
800074f2:	36 3b       	mov	r11,99
800074f4:	f6 0a 18 00 	cp.b	r10,r11
800074f8:	c2 f0       	breq	80007556 <get_arg+0x17a>
800074fa:	36 4b       	mov	r11,100
800074fc:	c0 e8       	rjmp	80007518 <get_arg+0x13c>
800074fe:	37 0b       	mov	r11,112
80007500:	f6 0a 18 00 	cp.b	r10,r11
80007504:	c2 50       	breq	8000754e <get_arg+0x172>
80007506:	e0 8b 00 0d 	brhi	80007520 <get_arg+0x144>
8000750a:	36 eb       	mov	r11,110
8000750c:	f6 0a 18 00 	cp.b	r10,r11
80007510:	c1 f0       	breq	8000754e <get_arg+0x172>
80007512:	e0 8b 00 14 	brhi	8000753a <get_arg+0x15e>
80007516:	36 9b       	mov	r11,105
80007518:	f6 0a 18 00 	cp.b	r10,r11
8000751c:	c1 e1       	brne	80007558 <get_arg+0x17c>
8000751e:	c0 e8       	rjmp	8000753a <get_arg+0x15e>
80007520:	37 5b       	mov	r11,117
80007522:	f6 0a 18 00 	cp.b	r10,r11
80007526:	c0 a0       	breq	8000753a <get_arg+0x15e>
80007528:	37 8b       	mov	r11,120
8000752a:	f6 0a 18 00 	cp.b	r10,r11
8000752e:	c0 60       	breq	8000753a <get_arg+0x15e>
80007530:	37 3b       	mov	r11,115
80007532:	f6 0a 18 00 	cp.b	r10,r11
80007536:	c1 11       	brne	80007558 <get_arg+0x17c>
80007538:	c0 b8       	rjmp	8000754e <get_arg+0x172>
8000753a:	ed b4 00 04 	bld	r4,0x4
8000753e:	c0 a0       	breq	80007552 <get_arg+0x176>
80007540:	ed b4 00 05 	bld	r4,0x5
80007544:	c0 91       	brne	80007556 <get_arg+0x17a>
80007546:	30 20       	mov	r0,2
80007548:	c0 88       	rjmp	80007558 <get_arg+0x17c>
8000754a:	30 40       	mov	r0,4
8000754c:	c0 68       	rjmp	80007558 <get_arg+0x17c>
8000754e:	30 30       	mov	r0,3
80007550:	c0 48       	rjmp	80007558 <get_arg+0x17c>
80007552:	30 10       	mov	r0,1
80007554:	c0 28       	rjmp	80007558 <get_arg+0x17c>
80007556:	30 00       	mov	r0,0
80007558:	40 3b       	lddsp	r11,sp[0xc]
8000755a:	5b fb       	cp.w	r11,-1
8000755c:	c0 40       	breq	80007564 <get_arg+0x188>
8000755e:	e2 0b 09 20 	st.w	r1[r11<<0x2],r0
80007562:	c7 08       	rjmp	80007642 <get_arg+0x266>
80007564:	58 60       	cp.w	r0,6
80007566:	e0 8b 00 6e 	brhi	80007642 <get_arg+0x266>
8000756a:	6c 0a       	ld.w	r10,r6[0x0]
8000756c:	ea cc ff ff 	sub	r12,r5,-1
80007570:	fe ce 9d 74 	sub	lr,pc,-25228
80007574:	fc 00 03 2f 	ld.w	pc,lr[r0<<0x2]
80007578:	f4 cb ff f8 	sub	r11,r10,-8
8000757c:	8d 0b       	st.w	r6[0x0],r11
8000757e:	f4 ea 00 00 	ld.d	r10,r10[0]
80007582:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80007586:	c0 f8       	rjmp	800075a4 <get_arg+0x1c8>
80007588:	f4 cb ff fc 	sub	r11,r10,-4
8000758c:	8d 0b       	st.w	r6[0x0],r11
8000758e:	74 0a       	ld.w	r10,r10[0x0]
80007590:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80007594:	c0 88       	rjmp	800075a4 <get_arg+0x1c8>
80007596:	f4 cb ff f8 	sub	r11,r10,-8
8000759a:	8d 0b       	st.w	r6[0x0],r11
8000759c:	f4 ea 00 00 	ld.d	r10,r10[0]
800075a0:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
800075a4:	0e 9b       	mov	r11,r7
800075a6:	18 95       	mov	r5,r12
800075a8:	c4 e8       	rjmp	80007644 <get_arg+0x268>
800075aa:	62 0a       	ld.w	r10,r1[0x0]
800075ac:	5b fa       	cp.w	r10,-1
800075ae:	c0 b1       	brne	800075c4 <get_arg+0x1e8>
800075b0:	50 19       	stdsp	sp[0x4],r9
800075b2:	50 28       	stdsp	sp[0x8],r8
800075b4:	e0 6a 00 80 	mov	r10,128
800075b8:	30 0b       	mov	r11,0
800075ba:	02 9c       	mov	r12,r1
800075bc:	fe b0 fc f4 	rcall	80006fa4 <memset>
800075c0:	40 28       	lddsp	r8,sp[0x8]
800075c2:	40 19       	lddsp	r9,sp[0x4]
800075c4:	e4 cc 00 01 	sub	r12,r2,1
800075c8:	0e 9b       	mov	r11,r7
800075ca:	50 3c       	stdsp	sp[0xc],r12
800075cc:	f2 0c 0c 49 	max	r9,r9,r12
800075d0:	c3 a8       	rjmp	80007644 <get_arg+0x268>
800075d2:	62 0a       	ld.w	r10,r1[0x0]
800075d4:	5b fa       	cp.w	r10,-1
800075d6:	c0 b1       	brne	800075ec <get_arg+0x210>
800075d8:	50 19       	stdsp	sp[0x4],r9
800075da:	50 28       	stdsp	sp[0x8],r8
800075dc:	e0 6a 00 80 	mov	r10,128
800075e0:	30 0b       	mov	r11,0
800075e2:	02 9c       	mov	r12,r1
800075e4:	fe b0 fc e0 	rcall	80006fa4 <memset>
800075e8:	40 28       	lddsp	r8,sp[0x8]
800075ea:	40 19       	lddsp	r9,sp[0x4]
800075ec:	20 12       	sub	r2,1
800075ee:	30 0a       	mov	r10,0
800075f0:	0e 9b       	mov	r11,r7
800075f2:	e2 02 09 2a 	st.w	r1[r2<<0x2],r10
800075f6:	f2 02 0c 49 	max	r9,r9,r2
800075fa:	c2 58       	rjmp	80007644 <get_arg+0x268>
800075fc:	16 97       	mov	r7,r11
800075fe:	6c 0a       	ld.w	r10,r6[0x0]
80007600:	f4 cb ff fc 	sub	r11,r10,-4
80007604:	8d 0b       	st.w	r6[0x0],r11
80007606:	74 0a       	ld.w	r10,r10[0x0]
80007608:	0e 9b       	mov	r11,r7
8000760a:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
8000760e:	2f f5       	sub	r5,-1
80007610:	c1 a8       	rjmp	80007644 <get_arg+0x268>
80007612:	f4 c2 00 30 	sub	r2,r10,48
80007616:	c0 68       	rjmp	80007622 <get_arg+0x246>
80007618:	e4 02 00 22 	add	r2,r2,r2<<0x2
8000761c:	2f f7       	sub	r7,-1
8000761e:	f4 02 00 12 	add	r2,r10,r2<<0x1
80007622:	0f 8a       	ld.ub	r10,r7[0x0]
80007624:	58 0a       	cp.w	r10,0
80007626:	c0 e0       	breq	80007642 <get_arg+0x266>
80007628:	23 0a       	sub	r10,48
8000762a:	58 9a       	cp.w	r10,9
8000762c:	fe 98 ff f6 	brls	80007618 <get_arg+0x23c>
80007630:	c0 98       	rjmp	80007642 <get_arg+0x266>
80007632:	2f f7       	sub	r7,-1
80007634:	0f 8a       	ld.ub	r10,r7[0x0]
80007636:	58 0a       	cp.w	r10,0
80007638:	c0 50       	breq	80007642 <get_arg+0x266>
8000763a:	23 0a       	sub	r10,48
8000763c:	58 9a       	cp.w	r10,9
8000763e:	fe 98 ff fa 	brls	80007632 <get_arg+0x256>
80007642:	0e 9b       	mov	r11,r7
80007644:	40 7c       	lddsp	r12,sp[0x1c]
80007646:	30 ba       	mov	r10,11
80007648:	f4 0c 18 00 	cp.b	r12,r10
8000764c:	fe 91 fe f2 	brne	80007430 <get_arg+0x54>
80007650:	40 42       	lddsp	r2,sp[0x10]
80007652:	17 8c       	ld.ub	r12,r11[0x0]
80007654:	0a 32       	cp.w	r2,r5
80007656:	5f 4a       	srge	r10
80007658:	f0 0c 18 00 	cp.b	r12,r8
8000765c:	5f 1c       	srne	r12
8000765e:	f9 ea 00 0a 	and	r10,r12,r10
80007662:	f0 0a 18 00 	cp.b	r10,r8
80007666:	fe 91 fe cf 	brne	80007404 <get_arg+0x28>
8000766a:	30 08       	mov	r8,0
8000766c:	40 4e       	lddsp	lr,sp[0x10]
8000766e:	17 8a       	ld.ub	r10,r11[0x0]
80007670:	e2 05 00 21 	add	r1,r1,r5<<0x2
80007674:	f0 0a 18 00 	cp.b	r10,r8
80007678:	fc 09 17 10 	movne	r9,lr
8000767c:	e6 05 00 38 	add	r8,r3,r5<<0x3
80007680:	06 9e       	mov	lr,r3
80007682:	c2 a8       	rjmp	800076d6 <get_arg+0x2fa>
80007684:	62 0a       	ld.w	r10,r1[0x0]
80007686:	58 3a       	cp.w	r10,3
80007688:	c1 e0       	breq	800076c4 <get_arg+0x2e8>
8000768a:	e0 89 00 07 	brgt	80007698 <get_arg+0x2bc>
8000768e:	58 1a       	cp.w	r10,1
80007690:	c1 a0       	breq	800076c4 <get_arg+0x2e8>
80007692:	58 2a       	cp.w	r10,2
80007694:	c1 81       	brne	800076c4 <get_arg+0x2e8>
80007696:	c0 58       	rjmp	800076a0 <get_arg+0x2c4>
80007698:	58 5a       	cp.w	r10,5
8000769a:	c0 c0       	breq	800076b2 <get_arg+0x2d6>
8000769c:	c0 b5       	brlt	800076b2 <get_arg+0x2d6>
8000769e:	c1 38       	rjmp	800076c4 <get_arg+0x2e8>
800076a0:	6c 0a       	ld.w	r10,r6[0x0]
800076a2:	f4 cc ff f8 	sub	r12,r10,-8
800076a6:	8d 0c       	st.w	r6[0x0],r12
800076a8:	f4 e2 00 00 	ld.d	r2,r10[0]
800076ac:	f0 e3 00 00 	st.d	r8[0],r2
800076b0:	c1 08       	rjmp	800076d0 <get_arg+0x2f4>
800076b2:	6c 0a       	ld.w	r10,r6[0x0]
800076b4:	f4 cc ff f8 	sub	r12,r10,-8
800076b8:	8d 0c       	st.w	r6[0x0],r12
800076ba:	f4 e2 00 00 	ld.d	r2,r10[0]
800076be:	f0 e3 00 00 	st.d	r8[0],r2
800076c2:	c0 78       	rjmp	800076d0 <get_arg+0x2f4>
800076c4:	6c 0a       	ld.w	r10,r6[0x0]
800076c6:	f4 cc ff fc 	sub	r12,r10,-4
800076ca:	8d 0c       	st.w	r6[0x0],r12
800076cc:	74 0a       	ld.w	r10,r10[0x0]
800076ce:	91 0a       	st.w	r8[0x0],r10
800076d0:	2f f5       	sub	r5,-1
800076d2:	2f 88       	sub	r8,-8
800076d4:	2f c1       	sub	r1,-4
800076d6:	12 35       	cp.w	r5,r9
800076d8:	fe 9a ff d6 	brle	80007684 <get_arg+0x2a8>
800076dc:	1c 93       	mov	r3,lr
800076de:	40 52       	lddsp	r2,sp[0x14]
800076e0:	40 6e       	lddsp	lr,sp[0x18]
800076e2:	85 05       	st.w	r2[0x0],r5
800076e4:	9d 0b       	st.w	lr[0x0],r11
800076e6:	40 4b       	lddsp	r11,sp[0x10]
800076e8:	e6 0b 00 3c 	add	r12,r3,r11<<0x3
800076ec:	2f 8d       	sub	sp,-32
800076ee:	d8 32       	popm	r0-r7,pc

800076f0 <__sprint_r>:
800076f0:	d4 21       	pushm	r4-r7,lr
800076f2:	14 97       	mov	r7,r10
800076f4:	74 28       	ld.w	r8,r10[0x8]
800076f6:	58 08       	cp.w	r8,0
800076f8:	c0 41       	brne	80007700 <__sprint_r+0x10>
800076fa:	95 18       	st.w	r10[0x4],r8
800076fc:	10 9c       	mov	r12,r8
800076fe:	d8 22       	popm	r4-r7,pc
80007700:	e0 a0 18 ba 	rcall	8000a874 <__sfvwrite_r>
80007704:	30 08       	mov	r8,0
80007706:	8f 18       	st.w	r7[0x4],r8
80007708:	8f 28       	st.w	r7[0x8],r8
8000770a:	d8 22       	popm	r4-r7,pc

8000770c <_vfprintf_r>:
8000770c:	d4 31       	pushm	r0-r7,lr
8000770e:	fa cd 06 bc 	sub	sp,sp,1724
80007712:	51 09       	stdsp	sp[0x40],r9
80007714:	16 91       	mov	r1,r11
80007716:	14 97       	mov	r7,r10
80007718:	18 95       	mov	r5,r12
8000771a:	e0 a0 1a 1d 	rcall	8000ab54 <_localeconv_r>
8000771e:	78 0c       	ld.w	r12,r12[0x0]
80007720:	50 cc       	stdsp	sp[0x30],r12
80007722:	58 05       	cp.w	r5,0
80007724:	c0 70       	breq	80007732 <_vfprintf_r+0x26>
80007726:	6a 68       	ld.w	r8,r5[0x18]
80007728:	58 08       	cp.w	r8,0
8000772a:	c0 41       	brne	80007732 <_vfprintf_r+0x26>
8000772c:	0a 9c       	mov	r12,r5
8000772e:	e0 a0 17 43 	rcall	8000a5b4 <__sinit>
80007732:	fe c8 9b 72 	sub	r8,pc,-25742
80007736:	10 31       	cp.w	r1,r8
80007738:	c0 31       	brne	8000773e <_vfprintf_r+0x32>
8000773a:	6a 01       	ld.w	r1,r5[0x0]
8000773c:	c0 c8       	rjmp	80007754 <_vfprintf_r+0x48>
8000773e:	fe c8 9b 5e 	sub	r8,pc,-25762
80007742:	10 31       	cp.w	r1,r8
80007744:	c0 31       	brne	8000774a <_vfprintf_r+0x3e>
80007746:	6a 11       	ld.w	r1,r5[0x4]
80007748:	c0 68       	rjmp	80007754 <_vfprintf_r+0x48>
8000774a:	fe c8 9b 4a 	sub	r8,pc,-25782
8000774e:	10 31       	cp.w	r1,r8
80007750:	eb f1 00 02 	ld.weq	r1,r5[0x8]
80007754:	82 68       	ld.sh	r8,r1[0xc]
80007756:	ed b8 00 03 	bld	r8,0x3
8000775a:	c0 41       	brne	80007762 <_vfprintf_r+0x56>
8000775c:	62 48       	ld.w	r8,r1[0x10]
8000775e:	58 08       	cp.w	r8,0
80007760:	c0 71       	brne	8000776e <_vfprintf_r+0x62>
80007762:	02 9b       	mov	r11,r1
80007764:	0a 9c       	mov	r12,r5
80007766:	e0 a0 0f 5d 	rcall	80009620 <__swsetup_r>
8000776a:	e0 81 0f 54 	brne	80009612 <_vfprintf_r+0x1f06>
8000776e:	82 68       	ld.sh	r8,r1[0xc]
80007770:	10 99       	mov	r9,r8
80007772:	e2 19 00 1a 	andl	r9,0x1a,COH
80007776:	58 a9       	cp.w	r9,10
80007778:	c3 c1       	brne	800077f0 <_vfprintf_r+0xe4>
8000777a:	82 79       	ld.sh	r9,r1[0xe]
8000777c:	30 0a       	mov	r10,0
8000777e:	f4 09 19 00 	cp.h	r9,r10
80007782:	c3 75       	brlt	800077f0 <_vfprintf_r+0xe4>
80007784:	a1 d8       	cbr	r8,0x1
80007786:	fb 58 05 d0 	st.h	sp[1488],r8
8000778a:	62 88       	ld.w	r8,r1[0x20]
8000778c:	fb 48 05 e4 	st.w	sp[1508],r8
80007790:	62 a8       	ld.w	r8,r1[0x28]
80007792:	fb 48 05 ec 	st.w	sp[1516],r8
80007796:	fa c8 ff bc 	sub	r8,sp,-68
8000779a:	fb 48 05 d4 	st.w	sp[1492],r8
8000779e:	fb 48 05 c4 	st.w	sp[1476],r8
800077a2:	e0 68 04 00 	mov	r8,1024
800077a6:	fb 48 05 d8 	st.w	sp[1496],r8
800077aa:	fb 48 05 cc 	st.w	sp[1484],r8
800077ae:	30 08       	mov	r8,0
800077b0:	fb 59 05 d2 	st.h	sp[1490],r9
800077b4:	0e 9a       	mov	r10,r7
800077b6:	41 09       	lddsp	r9,sp[0x40]
800077b8:	fa c7 fa 3c 	sub	r7,sp,-1476
800077bc:	fb 48 05 dc 	st.w	sp[1500],r8
800077c0:	0a 9c       	mov	r12,r5
800077c2:	0e 9b       	mov	r11,r7
800077c4:	ca 4f       	rcall	8000770c <_vfprintf_r>
800077c6:	50 bc       	stdsp	sp[0x2c],r12
800077c8:	c0 95       	brlt	800077da <_vfprintf_r+0xce>
800077ca:	0e 9b       	mov	r11,r7
800077cc:	0a 9c       	mov	r12,r5
800077ce:	e0 a0 16 1b 	rcall	8000a404 <_fflush_r>
800077d2:	40 be       	lddsp	lr,sp[0x2c]
800077d4:	f9 be 01 ff 	movne	lr,-1
800077d8:	50 be       	stdsp	sp[0x2c],lr
800077da:	fb 08 05 d0 	ld.sh	r8,sp[1488]
800077de:	ed b8 00 06 	bld	r8,0x6
800077e2:	e0 81 0f 1a 	brne	80009616 <_vfprintf_r+0x1f0a>
800077e6:	82 68       	ld.sh	r8,r1[0xc]
800077e8:	a7 a8       	sbr	r8,0x6
800077ea:	a2 68       	st.h	r1[0xc],r8
800077ec:	e0 8f 0f 15 	bral	80009616 <_vfprintf_r+0x1f0a>
800077f0:	30 08       	mov	r8,0
800077f2:	fb 48 06 b4 	st.w	sp[1716],r8
800077f6:	fb 48 06 90 	st.w	sp[1680],r8
800077fa:	fb 48 06 8c 	st.w	sp[1676],r8
800077fe:	fb 48 06 b0 	st.w	sp[1712],r8
80007802:	30 08       	mov	r8,0
80007804:	30 09       	mov	r9,0
80007806:	50 a7       	stdsp	sp[0x28],r7
80007808:	50 78       	stdsp	sp[0x1c],r8
8000780a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000780e:	3f f8       	mov	r8,-1
80007810:	50 59       	stdsp	sp[0x14],r9
80007812:	fb 43 06 88 	st.w	sp[1672],r3
80007816:	fb 48 05 44 	st.w	sp[1348],r8
8000781a:	12 9c       	mov	r12,r9
8000781c:	50 69       	stdsp	sp[0x18],r9
8000781e:	50 d9       	stdsp	sp[0x34],r9
80007820:	50 e9       	stdsp	sp[0x38],r9
80007822:	50 b9       	stdsp	sp[0x2c],r9
80007824:	12 97       	mov	r7,r9
80007826:	0a 94       	mov	r4,r5
80007828:	40 a2       	lddsp	r2,sp[0x28]
8000782a:	32 5a       	mov	r10,37
8000782c:	30 08       	mov	r8,0
8000782e:	c0 28       	rjmp	80007832 <_vfprintf_r+0x126>
80007830:	2f f2       	sub	r2,-1
80007832:	05 89       	ld.ub	r9,r2[0x0]
80007834:	f0 09 18 00 	cp.b	r9,r8
80007838:	5f 1b       	srne	r11
8000783a:	f4 09 18 00 	cp.b	r9,r10
8000783e:	5f 19       	srne	r9
80007840:	f3 eb 00 0b 	and	r11,r9,r11
80007844:	f0 0b 18 00 	cp.b	r11,r8
80007848:	cf 41       	brne	80007830 <_vfprintf_r+0x124>
8000784a:	40 ab       	lddsp	r11,sp[0x28]
8000784c:	e4 0b 01 06 	sub	r6,r2,r11
80007850:	c1 e0       	breq	8000788c <_vfprintf_r+0x180>
80007852:	fa f8 06 90 	ld.w	r8,sp[1680]
80007856:	0c 08       	add	r8,r6
80007858:	87 0b       	st.w	r3[0x0],r11
8000785a:	fb 48 06 90 	st.w	sp[1680],r8
8000785e:	87 16       	st.w	r3[0x4],r6
80007860:	fa f8 06 8c 	ld.w	r8,sp[1676]
80007864:	2f f8       	sub	r8,-1
80007866:	fb 48 06 8c 	st.w	sp[1676],r8
8000786a:	58 78       	cp.w	r8,7
8000786c:	e0 89 00 04 	brgt	80007874 <_vfprintf_r+0x168>
80007870:	2f 83       	sub	r3,-8
80007872:	c0 a8       	rjmp	80007886 <_vfprintf_r+0x17a>
80007874:	fa ca f9 78 	sub	r10,sp,-1672
80007878:	02 9b       	mov	r11,r1
8000787a:	08 9c       	mov	r12,r4
8000787c:	c3 af       	rcall	800076f0 <__sprint_r>
8000787e:	e0 81 0e c6 	brne	8000960a <_vfprintf_r+0x1efe>
80007882:	fa c3 f9 e0 	sub	r3,sp,-1568
80007886:	40 ba       	lddsp	r10,sp[0x2c]
80007888:	0c 0a       	add	r10,r6
8000788a:	50 ba       	stdsp	sp[0x2c],r10
8000788c:	05 89       	ld.ub	r9,r2[0x0]
8000788e:	30 08       	mov	r8,0
80007890:	f0 09 18 00 	cp.b	r9,r8
80007894:	e0 80 0e aa 	breq	800095e8 <_vfprintf_r+0x1edc>
80007898:	30 09       	mov	r9,0
8000789a:	fb 68 06 bb 	st.b	sp[1723],r8
8000789e:	0e 96       	mov	r6,r7
800078a0:	e4 c8 ff ff 	sub	r8,r2,-1
800078a4:	3f fe       	mov	lr,-1
800078a6:	50 93       	stdsp	sp[0x24],r3
800078a8:	50 41       	stdsp	sp[0x10],r1
800078aa:	0e 93       	mov	r3,r7
800078ac:	04 91       	mov	r1,r2
800078ae:	50 89       	stdsp	sp[0x20],r9
800078b0:	50 a8       	stdsp	sp[0x28],r8
800078b2:	50 2e       	stdsp	sp[0x8],lr
800078b4:	50 39       	stdsp	sp[0xc],r9
800078b6:	12 95       	mov	r5,r9
800078b8:	12 90       	mov	r0,r9
800078ba:	10 97       	mov	r7,r8
800078bc:	08 92       	mov	r2,r4
800078be:	c0 78       	rjmp	800078cc <_vfprintf_r+0x1c0>
800078c0:	3f fc       	mov	r12,-1
800078c2:	08 97       	mov	r7,r4
800078c4:	50 2c       	stdsp	sp[0x8],r12
800078c6:	c0 38       	rjmp	800078cc <_vfprintf_r+0x1c0>
800078c8:	30 0b       	mov	r11,0
800078ca:	50 3b       	stdsp	sp[0xc],r11
800078cc:	0f 38       	ld.ub	r8,r7++
800078ce:	c0 28       	rjmp	800078d2 <_vfprintf_r+0x1c6>
800078d0:	12 90       	mov	r0,r9
800078d2:	f0 c9 00 20 	sub	r9,r8,32
800078d6:	e0 49 00 58 	cp.w	r9,88
800078da:	e0 8b 0a 30 	brhi	80008d3a <_vfprintf_r+0x162e>
800078de:	fe ca a0 c6 	sub	r10,pc,-24378
800078e2:	f4 09 03 2f 	ld.w	pc,r10[r9<<0x2]
800078e6:	50 a7       	stdsp	sp[0x28],r7
800078e8:	50 80       	stdsp	sp[0x20],r0
800078ea:	0c 97       	mov	r7,r6
800078ec:	04 94       	mov	r4,r2
800078ee:	06 96       	mov	r6,r3
800078f0:	02 92       	mov	r2,r1
800078f2:	fe c9 9e 9e 	sub	r9,pc,-24930
800078f6:	40 93       	lddsp	r3,sp[0x24]
800078f8:	10 90       	mov	r0,r8
800078fa:	40 41       	lddsp	r1,sp[0x10]
800078fc:	50 d9       	stdsp	sp[0x34],r9
800078fe:	e0 8f 08 8e 	bral	80008a1a <_vfprintf_r+0x130e>
80007902:	30 08       	mov	r8,0
80007904:	fb 39 06 bb 	ld.ub	r9,sp[1723]
80007908:	f0 09 18 00 	cp.b	r9,r8
8000790c:	ce 01       	brne	800078cc <_vfprintf_r+0x1c0>
8000790e:	32 08       	mov	r8,32
80007910:	c6 e8       	rjmp	800079ec <_vfprintf_r+0x2e0>
80007912:	a1 a5       	sbr	r5,0x0
80007914:	cd cb       	rjmp	800078cc <_vfprintf_r+0x1c0>
80007916:	0f 89       	ld.ub	r9,r7[0x0]
80007918:	f2 c8 00 30 	sub	r8,r9,48
8000791c:	58 98       	cp.w	r8,9
8000791e:	e0 8b 00 1d 	brhi	80007958 <_vfprintf_r+0x24c>
80007922:	ee c8 ff ff 	sub	r8,r7,-1
80007926:	30 0b       	mov	r11,0
80007928:	23 09       	sub	r9,48
8000792a:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
8000792e:	f2 0b 00 1b 	add	r11,r9,r11<<0x1
80007932:	11 39       	ld.ub	r9,r8++
80007934:	f2 ca 00 30 	sub	r10,r9,48
80007938:	58 9a       	cp.w	r10,9
8000793a:	fe 98 ff f7 	brls	80007928 <_vfprintf_r+0x21c>
8000793e:	e0 49 00 24 	cp.w	r9,36
80007942:	cc 31       	brne	800078c8 <_vfprintf_r+0x1bc>
80007944:	e0 4b 00 20 	cp.w	r11,32
80007948:	e0 89 0e 60 	brgt	80009608 <_vfprintf_r+0x1efc>
8000794c:	20 1b       	sub	r11,1
8000794e:	fa f9 06 b4 	ld.w	r9,sp[1716]
80007952:	12 3b       	cp.w	r11,r9
80007954:	c0 95       	brlt	80007966 <_vfprintf_r+0x25a>
80007956:	c1 08       	rjmp	80007976 <_vfprintf_r+0x26a>
80007958:	fa f9 06 b4 	ld.w	r9,sp[1716]
8000795c:	ec ca ff ff 	sub	r10,r6,-1
80007960:	12 36       	cp.w	r6,r9
80007962:	c1 f5       	brlt	800079a0 <_vfprintf_r+0x294>
80007964:	c2 68       	rjmp	800079b0 <_vfprintf_r+0x2a4>
80007966:	fa ce f9 44 	sub	lr,sp,-1724
8000796a:	10 97       	mov	r7,r8
8000796c:	fc 0b 00 3b 	add	r11,lr,r11<<0x3
80007970:	f6 f0 fd 88 	ld.w	r0,r11[-632]
80007974:	c3 58       	rjmp	800079de <_vfprintf_r+0x2d2>
80007976:	10 97       	mov	r7,r8
80007978:	fa c8 f9 50 	sub	r8,sp,-1712
8000797c:	1a d8       	st.w	--sp,r8
8000797e:	fa c8 fa b8 	sub	r8,sp,-1352
80007982:	1a d8       	st.w	--sp,r8
80007984:	fa c8 fb b4 	sub	r8,sp,-1100
80007988:	02 9a       	mov	r10,r1
8000798a:	1a d8       	st.w	--sp,r8
8000798c:	04 9c       	mov	r12,r2
8000798e:	fa c8 f9 40 	sub	r8,sp,-1728
80007992:	fa c9 ff b4 	sub	r9,sp,-76
80007996:	fe b0 fd 23 	rcall	800073dc <get_arg>
8000799a:	2f dd       	sub	sp,-12
8000799c:	78 00       	ld.w	r0,r12[0x0]
8000799e:	c2 08       	rjmp	800079de <_vfprintf_r+0x2d2>
800079a0:	fa cc f9 44 	sub	r12,sp,-1724
800079a4:	14 96       	mov	r6,r10
800079a6:	f8 03 00 38 	add	r8,r12,r3<<0x3
800079aa:	f0 f0 fd 88 	ld.w	r0,r8[-632]
800079ae:	c1 88       	rjmp	800079de <_vfprintf_r+0x2d2>
800079b0:	41 08       	lddsp	r8,sp[0x40]
800079b2:	59 f9       	cp.w	r9,31
800079b4:	e0 89 00 11 	brgt	800079d6 <_vfprintf_r+0x2ca>
800079b8:	f0 cb ff fc 	sub	r11,r8,-4
800079bc:	51 0b       	stdsp	sp[0x40],r11
800079be:	70 00       	ld.w	r0,r8[0x0]
800079c0:	fa cb f9 44 	sub	r11,sp,-1724
800079c4:	f6 09 00 38 	add	r8,r11,r9<<0x3
800079c8:	f1 40 fd 88 	st.w	r8[-632],r0
800079cc:	2f f9       	sub	r9,-1
800079ce:	14 96       	mov	r6,r10
800079d0:	fb 49 06 b4 	st.w	sp[1716],r9
800079d4:	c0 58       	rjmp	800079de <_vfprintf_r+0x2d2>
800079d6:	70 00       	ld.w	r0,r8[0x0]
800079d8:	14 96       	mov	r6,r10
800079da:	2f c8       	sub	r8,-4
800079dc:	51 08       	stdsp	sp[0x40],r8
800079de:	58 00       	cp.w	r0,0
800079e0:	fe 94 ff 76 	brge	800078cc <_vfprintf_r+0x1c0>
800079e4:	5c 30       	neg	r0
800079e6:	a3 a5       	sbr	r5,0x2
800079e8:	c7 2b       	rjmp	800078cc <_vfprintf_r+0x1c0>
800079ea:	32 b8       	mov	r8,43
800079ec:	fb 68 06 bb 	st.b	sp[1723],r8
800079f0:	c6 eb       	rjmp	800078cc <_vfprintf_r+0x1c0>
800079f2:	0f 38       	ld.ub	r8,r7++
800079f4:	e0 48 00 2a 	cp.w	r8,42
800079f8:	c0 30       	breq	800079fe <_vfprintf_r+0x2f2>
800079fa:	30 09       	mov	r9,0
800079fc:	c7 98       	rjmp	80007aee <_vfprintf_r+0x3e2>
800079fe:	0f 88       	ld.ub	r8,r7[0x0]
80007a00:	f0 c9 00 30 	sub	r9,r8,48
80007a04:	58 99       	cp.w	r9,9
80007a06:	e0 8b 00 1f 	brhi	80007a44 <_vfprintf_r+0x338>
80007a0a:	ee c4 ff ff 	sub	r4,r7,-1
80007a0e:	30 0b       	mov	r11,0
80007a10:	23 08       	sub	r8,48
80007a12:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
80007a16:	f0 0b 00 1b 	add	r11,r8,r11<<0x1
80007a1a:	09 38       	ld.ub	r8,r4++
80007a1c:	f0 c9 00 30 	sub	r9,r8,48
80007a20:	58 99       	cp.w	r9,9
80007a22:	fe 98 ff f7 	brls	80007a10 <_vfprintf_r+0x304>
80007a26:	e0 48 00 24 	cp.w	r8,36
80007a2a:	fe 91 ff 4f 	brne	800078c8 <_vfprintf_r+0x1bc>
80007a2e:	e0 4b 00 20 	cp.w	r11,32
80007a32:	e0 89 0d eb 	brgt	80009608 <_vfprintf_r+0x1efc>
80007a36:	20 1b       	sub	r11,1
80007a38:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007a3c:	10 3b       	cp.w	r11,r8
80007a3e:	c0 a5       	brlt	80007a52 <_vfprintf_r+0x346>
80007a40:	c1 18       	rjmp	80007a62 <_vfprintf_r+0x356>
80007a42:	d7 03       	nop
80007a44:	fa fa 06 b4 	ld.w	r10,sp[1716]
80007a48:	ec c9 ff ff 	sub	r9,r6,-1
80007a4c:	14 36       	cp.w	r6,r10
80007a4e:	c1 f5       	brlt	80007a8c <_vfprintf_r+0x380>
80007a50:	c2 88       	rjmp	80007aa0 <_vfprintf_r+0x394>
80007a52:	fa ca f9 44 	sub	r10,sp,-1724
80007a56:	f4 0b 00 3b 	add	r11,r10,r11<<0x3
80007a5a:	f6 fb fd 88 	ld.w	r11,r11[-632]
80007a5e:	50 2b       	stdsp	sp[0x8],r11
80007a60:	c3 c8       	rjmp	80007ad8 <_vfprintf_r+0x3cc>
80007a62:	fa c8 f9 50 	sub	r8,sp,-1712
80007a66:	1a d8       	st.w	--sp,r8
80007a68:	fa c8 fa b8 	sub	r8,sp,-1352
80007a6c:	1a d8       	st.w	--sp,r8
80007a6e:	fa c8 fb b4 	sub	r8,sp,-1100
80007a72:	02 9a       	mov	r10,r1
80007a74:	1a d8       	st.w	--sp,r8
80007a76:	04 9c       	mov	r12,r2
80007a78:	fa c8 f9 40 	sub	r8,sp,-1728
80007a7c:	fa c9 ff b4 	sub	r9,sp,-76
80007a80:	fe b0 fc ae 	rcall	800073dc <get_arg>
80007a84:	2f dd       	sub	sp,-12
80007a86:	78 0c       	ld.w	r12,r12[0x0]
80007a88:	50 2c       	stdsp	sp[0x8],r12
80007a8a:	c2 78       	rjmp	80007ad8 <_vfprintf_r+0x3cc>
80007a8c:	12 96       	mov	r6,r9
80007a8e:	0e 94       	mov	r4,r7
80007a90:	fa c9 f9 44 	sub	r9,sp,-1724
80007a94:	f2 03 00 38 	add	r8,r9,r3<<0x3
80007a98:	f0 f8 fd 88 	ld.w	r8,r8[-632]
80007a9c:	50 28       	stdsp	sp[0x8],r8
80007a9e:	c1 d8       	rjmp	80007ad8 <_vfprintf_r+0x3cc>
80007aa0:	41 08       	lddsp	r8,sp[0x40]
80007aa2:	59 fa       	cp.w	r10,31
80007aa4:	e0 89 00 14 	brgt	80007acc <_vfprintf_r+0x3c0>
80007aa8:	f0 cb ff fc 	sub	r11,r8,-4
80007aac:	70 08       	ld.w	r8,r8[0x0]
80007aae:	51 0b       	stdsp	sp[0x40],r11
80007ab0:	50 28       	stdsp	sp[0x8],r8
80007ab2:	fa c6 f9 44 	sub	r6,sp,-1724
80007ab6:	40 2e       	lddsp	lr,sp[0x8]
80007ab8:	ec 0a 00 38 	add	r8,r6,r10<<0x3
80007abc:	f1 4e fd 88 	st.w	r8[-632],lr
80007ac0:	2f fa       	sub	r10,-1
80007ac2:	0e 94       	mov	r4,r7
80007ac4:	fb 4a 06 b4 	st.w	sp[1716],r10
80007ac8:	12 96       	mov	r6,r9
80007aca:	c0 78       	rjmp	80007ad8 <_vfprintf_r+0x3cc>
80007acc:	70 0c       	ld.w	r12,r8[0x0]
80007ace:	0e 94       	mov	r4,r7
80007ad0:	2f c8       	sub	r8,-4
80007ad2:	50 2c       	stdsp	sp[0x8],r12
80007ad4:	12 96       	mov	r6,r9
80007ad6:	51 08       	stdsp	sp[0x40],r8
80007ad8:	40 2b       	lddsp	r11,sp[0x8]
80007ada:	58 0b       	cp.w	r11,0
80007adc:	fe 95 fe f2 	brlt	800078c0 <_vfprintf_r+0x1b4>
80007ae0:	08 97       	mov	r7,r4
80007ae2:	cf 5a       	rjmp	800078cc <_vfprintf_r+0x1c0>
80007ae4:	f2 09 00 29 	add	r9,r9,r9<<0x2
80007ae8:	0f 38       	ld.ub	r8,r7++
80007aea:	f4 09 00 19 	add	r9,r10,r9<<0x1
80007aee:	f0 ca 00 30 	sub	r10,r8,48
80007af2:	58 9a       	cp.w	r10,9
80007af4:	fe 98 ff f8 	brls	80007ae4 <_vfprintf_r+0x3d8>
80007af8:	3f fa       	mov	r10,-1
80007afa:	f2 0a 0c 49 	max	r9,r9,r10
80007afe:	50 29       	stdsp	sp[0x8],r9
80007b00:	ce 9a       	rjmp	800078d2 <_vfprintf_r+0x1c6>
80007b02:	a7 b5       	sbr	r5,0x7
80007b04:	ce 4a       	rjmp	800078cc <_vfprintf_r+0x1c0>
80007b06:	30 09       	mov	r9,0
80007b08:	23 08       	sub	r8,48
80007b0a:	f2 09 00 29 	add	r9,r9,r9<<0x2
80007b0e:	f0 09 00 19 	add	r9,r8,r9<<0x1
80007b12:	0f 38       	ld.ub	r8,r7++
80007b14:	f0 ca 00 30 	sub	r10,r8,48
80007b18:	58 9a       	cp.w	r10,9
80007b1a:	fe 98 ff f7 	brls	80007b08 <_vfprintf_r+0x3fc>
80007b1e:	e0 48 00 24 	cp.w	r8,36
80007b22:	fe 91 fe d7 	brne	800078d0 <_vfprintf_r+0x1c4>
80007b26:	e0 49 00 20 	cp.w	r9,32
80007b2a:	e0 89 0d 6f 	brgt	80009608 <_vfprintf_r+0x1efc>
80007b2e:	f2 c3 00 01 	sub	r3,r9,1
80007b32:	30 19       	mov	r9,1
80007b34:	50 39       	stdsp	sp[0xc],r9
80007b36:	cc ba       	rjmp	800078cc <_vfprintf_r+0x1c0>
80007b38:	a3 b5       	sbr	r5,0x3
80007b3a:	cc 9a       	rjmp	800078cc <_vfprintf_r+0x1c0>
80007b3c:	a7 a5       	sbr	r5,0x6
80007b3e:	cc 7a       	rjmp	800078cc <_vfprintf_r+0x1c0>
80007b40:	0a 98       	mov	r8,r5
80007b42:	a5 b5       	sbr	r5,0x5
80007b44:	a5 a8       	sbr	r8,0x4
80007b46:	0f 89       	ld.ub	r9,r7[0x0]
80007b48:	36 ce       	mov	lr,108
80007b4a:	fc 09 18 00 	cp.b	r9,lr
80007b4e:	f7 b7 00 ff 	subeq	r7,-1
80007b52:	f0 05 17 10 	movne	r5,r8
80007b56:	cb ba       	rjmp	800078cc <_vfprintf_r+0x1c0>
80007b58:	a5 b5       	sbr	r5,0x5
80007b5a:	cb 9a       	rjmp	800078cc <_vfprintf_r+0x1c0>
80007b5c:	50 a7       	stdsp	sp[0x28],r7
80007b5e:	50 80       	stdsp	sp[0x20],r0
80007b60:	0c 97       	mov	r7,r6
80007b62:	10 90       	mov	r0,r8
80007b64:	06 96       	mov	r6,r3
80007b66:	04 94       	mov	r4,r2
80007b68:	40 93       	lddsp	r3,sp[0x24]
80007b6a:	02 92       	mov	r2,r1
80007b6c:	0e 99       	mov	r9,r7
80007b6e:	40 41       	lddsp	r1,sp[0x10]
80007b70:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007b74:	40 3c       	lddsp	r12,sp[0xc]
80007b76:	58 0c       	cp.w	r12,0
80007b78:	c1 d0       	breq	80007bb2 <_vfprintf_r+0x4a6>
80007b7a:	10 36       	cp.w	r6,r8
80007b7c:	c0 64       	brge	80007b88 <_vfprintf_r+0x47c>
80007b7e:	fa cb f9 44 	sub	r11,sp,-1724
80007b82:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007b86:	c1 d8       	rjmp	80007bc0 <_vfprintf_r+0x4b4>
80007b88:	fa c8 f9 50 	sub	r8,sp,-1712
80007b8c:	1a d8       	st.w	--sp,r8
80007b8e:	fa c8 fa b8 	sub	r8,sp,-1352
80007b92:	1a d8       	st.w	--sp,r8
80007b94:	fa c8 fb b4 	sub	r8,sp,-1100
80007b98:	1a d8       	st.w	--sp,r8
80007b9a:	fa c8 f9 40 	sub	r8,sp,-1728
80007b9e:	fa c9 ff b4 	sub	r9,sp,-76
80007ba2:	04 9a       	mov	r10,r2
80007ba4:	0c 9b       	mov	r11,r6
80007ba6:	08 9c       	mov	r12,r4
80007ba8:	fe b0 fc 1a 	rcall	800073dc <get_arg>
80007bac:	2f dd       	sub	sp,-12
80007bae:	19 b8       	ld.ub	r8,r12[0x3]
80007bb0:	c2 28       	rjmp	80007bf4 <_vfprintf_r+0x4e8>
80007bb2:	2f f7       	sub	r7,-1
80007bb4:	10 39       	cp.w	r9,r8
80007bb6:	c0 84       	brge	80007bc6 <_vfprintf_r+0x4ba>
80007bb8:	fa ca f9 44 	sub	r10,sp,-1724
80007bbc:	f4 06 00 36 	add	r6,r10,r6<<0x3
80007bc0:	ed 38 fd 8b 	ld.ub	r8,r6[-629]
80007bc4:	c1 88       	rjmp	80007bf4 <_vfprintf_r+0x4e8>
80007bc6:	41 09       	lddsp	r9,sp[0x40]
80007bc8:	59 f8       	cp.w	r8,31
80007bca:	e0 89 00 12 	brgt	80007bee <_vfprintf_r+0x4e2>
80007bce:	f2 ca ff fc 	sub	r10,r9,-4
80007bd2:	51 0a       	stdsp	sp[0x40],r10
80007bd4:	72 09       	ld.w	r9,r9[0x0]
80007bd6:	fa c6 f9 44 	sub	r6,sp,-1724
80007bda:	ec 08 00 3a 	add	r10,r6,r8<<0x3
80007bde:	2f f8       	sub	r8,-1
80007be0:	f5 49 fd 88 	st.w	r10[-632],r9
80007be4:	fb 48 06 b4 	st.w	sp[1716],r8
80007be8:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
80007bec:	c0 48       	rjmp	80007bf4 <_vfprintf_r+0x4e8>
80007bee:	13 b8       	ld.ub	r8,r9[0x3]
80007bf0:	2f c9       	sub	r9,-4
80007bf2:	51 09       	stdsp	sp[0x40],r9
80007bf4:	fb 68 06 60 	st.b	sp[1632],r8
80007bf8:	30 0e       	mov	lr,0
80007bfa:	30 08       	mov	r8,0
80007bfc:	30 12       	mov	r2,1
80007bfe:	fb 68 06 bb 	st.b	sp[1723],r8
80007c02:	50 2e       	stdsp	sp[0x8],lr
80007c04:	e0 8f 08 ad 	bral	80008d5e <_vfprintf_r+0x1652>
80007c08:	50 a7       	stdsp	sp[0x28],r7
80007c0a:	50 80       	stdsp	sp[0x20],r0
80007c0c:	0c 97       	mov	r7,r6
80007c0e:	04 94       	mov	r4,r2
80007c10:	06 96       	mov	r6,r3
80007c12:	02 92       	mov	r2,r1
80007c14:	40 93       	lddsp	r3,sp[0x24]
80007c16:	10 90       	mov	r0,r8
80007c18:	40 41       	lddsp	r1,sp[0x10]
80007c1a:	a5 a5       	sbr	r5,0x4
80007c1c:	c0 a8       	rjmp	80007c30 <_vfprintf_r+0x524>
80007c1e:	50 a7       	stdsp	sp[0x28],r7
80007c20:	50 80       	stdsp	sp[0x20],r0
80007c22:	0c 97       	mov	r7,r6
80007c24:	04 94       	mov	r4,r2
80007c26:	06 96       	mov	r6,r3
80007c28:	02 92       	mov	r2,r1
80007c2a:	40 93       	lddsp	r3,sp[0x24]
80007c2c:	10 90       	mov	r0,r8
80007c2e:	40 41       	lddsp	r1,sp[0x10]
80007c30:	ed b5 00 05 	bld	r5,0x5
80007c34:	c5 11       	brne	80007cd6 <_vfprintf_r+0x5ca>
80007c36:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007c3a:	40 3c       	lddsp	r12,sp[0xc]
80007c3c:	58 0c       	cp.w	r12,0
80007c3e:	c1 e0       	breq	80007c7a <_vfprintf_r+0x56e>
80007c40:	10 36       	cp.w	r6,r8
80007c42:	c0 64       	brge	80007c4e <_vfprintf_r+0x542>
80007c44:	fa cb f9 44 	sub	r11,sp,-1724
80007c48:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007c4c:	c2 08       	rjmp	80007c8c <_vfprintf_r+0x580>
80007c4e:	fa c8 f9 50 	sub	r8,sp,-1712
80007c52:	1a d8       	st.w	--sp,r8
80007c54:	fa c8 fa b8 	sub	r8,sp,-1352
80007c58:	0c 9b       	mov	r11,r6
80007c5a:	1a d8       	st.w	--sp,r8
80007c5c:	fa c8 fb b4 	sub	r8,sp,-1100
80007c60:	1a d8       	st.w	--sp,r8
80007c62:	fa c9 ff b4 	sub	r9,sp,-76
80007c66:	fa c8 f9 40 	sub	r8,sp,-1728
80007c6a:	04 9a       	mov	r10,r2
80007c6c:	08 9c       	mov	r12,r4
80007c6e:	fe b0 fb b7 	rcall	800073dc <get_arg>
80007c72:	2f dd       	sub	sp,-12
80007c74:	78 1b       	ld.w	r11,r12[0x4]
80007c76:	78 09       	ld.w	r9,r12[0x0]
80007c78:	c2 b8       	rjmp	80007cce <_vfprintf_r+0x5c2>
80007c7a:	ee ca ff ff 	sub	r10,r7,-1
80007c7e:	10 37       	cp.w	r7,r8
80007c80:	c0 b4       	brge	80007c96 <_vfprintf_r+0x58a>
80007c82:	fa c9 f9 44 	sub	r9,sp,-1724
80007c86:	14 97       	mov	r7,r10
80007c88:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007c8c:	ec fb fd 8c 	ld.w	r11,r6[-628]
80007c90:	ec f9 fd 88 	ld.w	r9,r6[-632]
80007c94:	c1 d8       	rjmp	80007cce <_vfprintf_r+0x5c2>
80007c96:	41 09       	lddsp	r9,sp[0x40]
80007c98:	59 f8       	cp.w	r8,31
80007c9a:	e0 89 00 14 	brgt	80007cc2 <_vfprintf_r+0x5b6>
80007c9e:	f2 cb ff f8 	sub	r11,r9,-8
80007ca2:	51 0b       	stdsp	sp[0x40],r11
80007ca4:	fa c6 f9 44 	sub	r6,sp,-1724
80007ca8:	72 1b       	ld.w	r11,r9[0x4]
80007caa:	ec 08 00 3c 	add	r12,r6,r8<<0x3
80007cae:	72 09       	ld.w	r9,r9[0x0]
80007cb0:	f9 4b fd 8c 	st.w	r12[-628],r11
80007cb4:	f9 49 fd 88 	st.w	r12[-632],r9
80007cb8:	2f f8       	sub	r8,-1
80007cba:	14 97       	mov	r7,r10
80007cbc:	fb 48 06 b4 	st.w	sp[1716],r8
80007cc0:	c0 78       	rjmp	80007cce <_vfprintf_r+0x5c2>
80007cc2:	f2 c8 ff f8 	sub	r8,r9,-8
80007cc6:	72 1b       	ld.w	r11,r9[0x4]
80007cc8:	14 97       	mov	r7,r10
80007cca:	51 08       	stdsp	sp[0x40],r8
80007ccc:	72 09       	ld.w	r9,r9[0x0]
80007cce:	16 98       	mov	r8,r11
80007cd0:	fa e9 00 00 	st.d	sp[0],r8
80007cd4:	ca e8       	rjmp	80007e30 <_vfprintf_r+0x724>
80007cd6:	ed b5 00 04 	bld	r5,0x4
80007cda:	c1 71       	brne	80007d08 <_vfprintf_r+0x5fc>
80007cdc:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007ce0:	40 3e       	lddsp	lr,sp[0xc]
80007ce2:	58 0e       	cp.w	lr,0
80007ce4:	c0 80       	breq	80007cf4 <_vfprintf_r+0x5e8>
80007ce6:	10 36       	cp.w	r6,r8
80007ce8:	c6 94       	brge	80007dba <_vfprintf_r+0x6ae>
80007cea:	fa cc f9 44 	sub	r12,sp,-1724
80007cee:	f8 06 00 36 	add	r6,r12,r6<<0x3
80007cf2:	c8 28       	rjmp	80007df6 <_vfprintf_r+0x6ea>
80007cf4:	ee ca ff ff 	sub	r10,r7,-1
80007cf8:	10 37       	cp.w	r7,r8
80007cfa:	e0 84 00 81 	brge	80007dfc <_vfprintf_r+0x6f0>
80007cfe:	fa cb f9 44 	sub	r11,sp,-1724
80007d02:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007d06:	c7 78       	rjmp	80007df4 <_vfprintf_r+0x6e8>
80007d08:	ed b5 00 06 	bld	r5,0x6
80007d0c:	c4 b1       	brne	80007da2 <_vfprintf_r+0x696>
80007d0e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007d12:	40 3c       	lddsp	r12,sp[0xc]
80007d14:	58 0c       	cp.w	r12,0
80007d16:	c1 d0       	breq	80007d50 <_vfprintf_r+0x644>
80007d18:	10 36       	cp.w	r6,r8
80007d1a:	c0 64       	brge	80007d26 <_vfprintf_r+0x61a>
80007d1c:	fa cb f9 44 	sub	r11,sp,-1724
80007d20:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007d24:	c1 f8       	rjmp	80007d62 <_vfprintf_r+0x656>
80007d26:	fa c8 f9 50 	sub	r8,sp,-1712
80007d2a:	1a d8       	st.w	--sp,r8
80007d2c:	fa c8 fa b8 	sub	r8,sp,-1352
80007d30:	1a d8       	st.w	--sp,r8
80007d32:	fa c8 fb b4 	sub	r8,sp,-1100
80007d36:	1a d8       	st.w	--sp,r8
80007d38:	fa c8 f9 40 	sub	r8,sp,-1728
80007d3c:	fa c9 ff b4 	sub	r9,sp,-76
80007d40:	04 9a       	mov	r10,r2
80007d42:	0c 9b       	mov	r11,r6
80007d44:	08 9c       	mov	r12,r4
80007d46:	fe b0 fb 4b 	rcall	800073dc <get_arg>
80007d4a:	2f dd       	sub	sp,-12
80007d4c:	98 18       	ld.sh	r8,r12[0x2]
80007d4e:	c2 68       	rjmp	80007d9a <_vfprintf_r+0x68e>
80007d50:	ee ca ff ff 	sub	r10,r7,-1
80007d54:	10 37       	cp.w	r7,r8
80007d56:	c0 94       	brge	80007d68 <_vfprintf_r+0x65c>
80007d58:	fa c9 f9 44 	sub	r9,sp,-1724
80007d5c:	14 97       	mov	r7,r10
80007d5e:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007d62:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80007d66:	c1 a8       	rjmp	80007d9a <_vfprintf_r+0x68e>
80007d68:	41 09       	lddsp	r9,sp[0x40]
80007d6a:	59 f8       	cp.w	r8,31
80007d6c:	e0 89 00 13 	brgt	80007d92 <_vfprintf_r+0x686>
80007d70:	f2 cb ff fc 	sub	r11,r9,-4
80007d74:	51 0b       	stdsp	sp[0x40],r11
80007d76:	72 09       	ld.w	r9,r9[0x0]
80007d78:	fa c6 f9 44 	sub	r6,sp,-1724
80007d7c:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80007d80:	2f f8       	sub	r8,-1
80007d82:	f7 49 fd 88 	st.w	r11[-632],r9
80007d86:	fb 48 06 b4 	st.w	sp[1716],r8
80007d8a:	14 97       	mov	r7,r10
80007d8c:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80007d90:	c0 58       	rjmp	80007d9a <_vfprintf_r+0x68e>
80007d92:	92 18       	ld.sh	r8,r9[0x2]
80007d94:	14 97       	mov	r7,r10
80007d96:	2f c9       	sub	r9,-4
80007d98:	51 09       	stdsp	sp[0x40],r9
80007d9a:	50 18       	stdsp	sp[0x4],r8
80007d9c:	bf 58       	asr	r8,0x1f
80007d9e:	50 08       	stdsp	sp[0x0],r8
80007da0:	c4 88       	rjmp	80007e30 <_vfprintf_r+0x724>
80007da2:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007da6:	40 3c       	lddsp	r12,sp[0xc]
80007da8:	58 0c       	cp.w	r12,0
80007daa:	c1 d0       	breq	80007de4 <_vfprintf_r+0x6d8>
80007dac:	10 36       	cp.w	r6,r8
80007dae:	c0 64       	brge	80007dba <_vfprintf_r+0x6ae>
80007db0:	fa cb f9 44 	sub	r11,sp,-1724
80007db4:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007db8:	c1 f8       	rjmp	80007df6 <_vfprintf_r+0x6ea>
80007dba:	fa c8 f9 50 	sub	r8,sp,-1712
80007dbe:	1a d8       	st.w	--sp,r8
80007dc0:	fa c8 fa b8 	sub	r8,sp,-1352
80007dc4:	0c 9b       	mov	r11,r6
80007dc6:	1a d8       	st.w	--sp,r8
80007dc8:	fa c8 fb b4 	sub	r8,sp,-1100
80007dcc:	04 9a       	mov	r10,r2
80007dce:	1a d8       	st.w	--sp,r8
80007dd0:	08 9c       	mov	r12,r4
80007dd2:	fa c8 f9 40 	sub	r8,sp,-1728
80007dd6:	fa c9 ff b4 	sub	r9,sp,-76
80007dda:	fe b0 fb 01 	rcall	800073dc <get_arg>
80007dde:	2f dd       	sub	sp,-12
80007de0:	78 0b       	ld.w	r11,r12[0x0]
80007de2:	c2 48       	rjmp	80007e2a <_vfprintf_r+0x71e>
80007de4:	ee ca ff ff 	sub	r10,r7,-1
80007de8:	10 37       	cp.w	r7,r8
80007dea:	c0 94       	brge	80007dfc <_vfprintf_r+0x6f0>
80007dec:	fa c9 f9 44 	sub	r9,sp,-1724
80007df0:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007df4:	14 97       	mov	r7,r10
80007df6:	ec fb fd 88 	ld.w	r11,r6[-632]
80007dfa:	c1 88       	rjmp	80007e2a <_vfprintf_r+0x71e>
80007dfc:	41 09       	lddsp	r9,sp[0x40]
80007dfe:	59 f8       	cp.w	r8,31
80007e00:	e0 89 00 11 	brgt	80007e22 <_vfprintf_r+0x716>
80007e04:	f2 cb ff fc 	sub	r11,r9,-4
80007e08:	51 0b       	stdsp	sp[0x40],r11
80007e0a:	fa c6 f9 44 	sub	r6,sp,-1724
80007e0e:	72 0b       	ld.w	r11,r9[0x0]
80007e10:	ec 08 00 39 	add	r9,r6,r8<<0x3
80007e14:	f3 4b fd 88 	st.w	r9[-632],r11
80007e18:	2f f8       	sub	r8,-1
80007e1a:	14 97       	mov	r7,r10
80007e1c:	fb 48 06 b4 	st.w	sp[1716],r8
80007e20:	c0 58       	rjmp	80007e2a <_vfprintf_r+0x71e>
80007e22:	72 0b       	ld.w	r11,r9[0x0]
80007e24:	14 97       	mov	r7,r10
80007e26:	2f c9       	sub	r9,-4
80007e28:	51 09       	stdsp	sp[0x40],r9
80007e2a:	50 1b       	stdsp	sp[0x4],r11
80007e2c:	bf 5b       	asr	r11,0x1f
80007e2e:	50 0b       	stdsp	sp[0x0],r11
80007e30:	fa ea 00 00 	ld.d	r10,sp[0]
80007e34:	58 0a       	cp.w	r10,0
80007e36:	5c 2b       	cpc	r11
80007e38:	c0 e4       	brge	80007e54 <_vfprintf_r+0x748>
80007e3a:	30 08       	mov	r8,0
80007e3c:	fa ea 00 00 	ld.d	r10,sp[0]
80007e40:	30 09       	mov	r9,0
80007e42:	f0 0a 01 0a 	sub	r10,r8,r10
80007e46:	f2 0b 01 4b 	sbc	r11,r9,r11
80007e4a:	32 d8       	mov	r8,45
80007e4c:	fa eb 00 00 	st.d	sp[0],r10
80007e50:	fb 68 06 bb 	st.b	sp[1723],r8
80007e54:	30 18       	mov	r8,1
80007e56:	e0 8f 06 fa 	bral	80008c4a <_vfprintf_r+0x153e>
80007e5a:	50 a7       	stdsp	sp[0x28],r7
80007e5c:	50 80       	stdsp	sp[0x20],r0
80007e5e:	0c 97       	mov	r7,r6
80007e60:	04 94       	mov	r4,r2
80007e62:	06 96       	mov	r6,r3
80007e64:	02 92       	mov	r2,r1
80007e66:	40 93       	lddsp	r3,sp[0x24]
80007e68:	10 90       	mov	r0,r8
80007e6a:	40 41       	lddsp	r1,sp[0x10]
80007e6c:	0e 99       	mov	r9,r7
80007e6e:	ed b5 00 03 	bld	r5,0x3
80007e72:	c4 11       	brne	80007ef4 <_vfprintf_r+0x7e8>
80007e74:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007e78:	40 3a       	lddsp	r10,sp[0xc]
80007e7a:	58 0a       	cp.w	r10,0
80007e7c:	c1 90       	breq	80007eae <_vfprintf_r+0x7a2>
80007e7e:	10 36       	cp.w	r6,r8
80007e80:	c6 45       	brlt	80007f48 <_vfprintf_r+0x83c>
80007e82:	fa c8 f9 50 	sub	r8,sp,-1712
80007e86:	1a d8       	st.w	--sp,r8
80007e88:	fa c8 fa b8 	sub	r8,sp,-1352
80007e8c:	1a d8       	st.w	--sp,r8
80007e8e:	fa c8 fb b4 	sub	r8,sp,-1100
80007e92:	0c 9b       	mov	r11,r6
80007e94:	1a d8       	st.w	--sp,r8
80007e96:	04 9a       	mov	r10,r2
80007e98:	fa c8 f9 40 	sub	r8,sp,-1728
80007e9c:	fa c9 ff b4 	sub	r9,sp,-76
80007ea0:	08 9c       	mov	r12,r4
80007ea2:	fe b0 fa 9d 	rcall	800073dc <get_arg>
80007ea6:	2f dd       	sub	sp,-12
80007ea8:	78 16       	ld.w	r6,r12[0x4]
80007eaa:	50 76       	stdsp	sp[0x1c],r6
80007eac:	c4 88       	rjmp	80007f3c <_vfprintf_r+0x830>
80007eae:	2f f7       	sub	r7,-1
80007eb0:	10 39       	cp.w	r9,r8
80007eb2:	c0 c4       	brge	80007eca <_vfprintf_r+0x7be>
80007eb4:	fa ce f9 44 	sub	lr,sp,-1724
80007eb8:	fc 06 00 36 	add	r6,lr,r6<<0x3
80007ebc:	ec fc fd 8c 	ld.w	r12,r6[-628]
80007ec0:	50 7c       	stdsp	sp[0x1c],r12
80007ec2:	ec f6 fd 88 	ld.w	r6,r6[-632]
80007ec6:	50 56       	stdsp	sp[0x14],r6
80007ec8:	c6 68       	rjmp	80007f94 <_vfprintf_r+0x888>
80007eca:	41 09       	lddsp	r9,sp[0x40]
80007ecc:	59 f8       	cp.w	r8,31
80007ece:	e0 89 00 10 	brgt	80007eee <_vfprintf_r+0x7e2>
80007ed2:	f2 ca ff f8 	sub	r10,r9,-8
80007ed6:	72 1b       	ld.w	r11,r9[0x4]
80007ed8:	51 0a       	stdsp	sp[0x40],r10
80007eda:	72 09       	ld.w	r9,r9[0x0]
80007edc:	fa ca f9 44 	sub	r10,sp,-1724
80007ee0:	50 7b       	stdsp	sp[0x1c],r11
80007ee2:	50 59       	stdsp	sp[0x14],r9
80007ee4:	f4 08 00 39 	add	r9,r10,r8<<0x3
80007ee8:	40 5b       	lddsp	r11,sp[0x14]
80007eea:	40 7a       	lddsp	r10,sp[0x1c]
80007eec:	c4 78       	rjmp	80007f7a <_vfprintf_r+0x86e>
80007eee:	72 18       	ld.w	r8,r9[0x4]
80007ef0:	50 78       	stdsp	sp[0x1c],r8
80007ef2:	c4 c8       	rjmp	80007f8a <_vfprintf_r+0x87e>
80007ef4:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007ef8:	40 3e       	lddsp	lr,sp[0xc]
80007efa:	58 0e       	cp.w	lr,0
80007efc:	c2 30       	breq	80007f42 <_vfprintf_r+0x836>
80007efe:	10 36       	cp.w	r6,r8
80007f00:	c0 94       	brge	80007f12 <_vfprintf_r+0x806>
80007f02:	fa cc f9 44 	sub	r12,sp,-1724
80007f06:	f8 06 00 36 	add	r6,r12,r6<<0x3
80007f0a:	ec fb fd 8c 	ld.w	r11,r6[-628]
80007f0e:	50 7b       	stdsp	sp[0x1c],r11
80007f10:	cd 9b       	rjmp	80007ec2 <_vfprintf_r+0x7b6>
80007f12:	fa c8 f9 50 	sub	r8,sp,-1712
80007f16:	1a d8       	st.w	--sp,r8
80007f18:	fa c8 fa b8 	sub	r8,sp,-1352
80007f1c:	04 9a       	mov	r10,r2
80007f1e:	1a d8       	st.w	--sp,r8
80007f20:	fa c8 fb b4 	sub	r8,sp,-1100
80007f24:	0c 9b       	mov	r11,r6
80007f26:	1a d8       	st.w	--sp,r8
80007f28:	08 9c       	mov	r12,r4
80007f2a:	fa c8 f9 40 	sub	r8,sp,-1728
80007f2e:	fa c9 ff b4 	sub	r9,sp,-76
80007f32:	fe b0 fa 55 	rcall	800073dc <get_arg>
80007f36:	2f dd       	sub	sp,-12
80007f38:	78 1a       	ld.w	r10,r12[0x4]
80007f3a:	50 7a       	stdsp	sp[0x1c],r10
80007f3c:	78 0c       	ld.w	r12,r12[0x0]
80007f3e:	50 5c       	stdsp	sp[0x14],r12
80007f40:	c2 a8       	rjmp	80007f94 <_vfprintf_r+0x888>
80007f42:	2f f7       	sub	r7,-1
80007f44:	10 39       	cp.w	r9,r8
80007f46:	c0 94       	brge	80007f58 <_vfprintf_r+0x84c>
80007f48:	fa c9 f9 44 	sub	r9,sp,-1724
80007f4c:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007f50:	ec f8 fd 8c 	ld.w	r8,r6[-628]
80007f54:	50 78       	stdsp	sp[0x1c],r8
80007f56:	cb 6b       	rjmp	80007ec2 <_vfprintf_r+0x7b6>
80007f58:	41 09       	lddsp	r9,sp[0x40]
80007f5a:	59 f8       	cp.w	r8,31
80007f5c:	e0 89 00 15 	brgt	80007f86 <_vfprintf_r+0x87a>
80007f60:	f2 ca ff f8 	sub	r10,r9,-8
80007f64:	72 16       	ld.w	r6,r9[0x4]
80007f66:	72 09       	ld.w	r9,r9[0x0]
80007f68:	51 0a       	stdsp	sp[0x40],r10
80007f6a:	50 59       	stdsp	sp[0x14],r9
80007f6c:	fa ce f9 44 	sub	lr,sp,-1724
80007f70:	50 76       	stdsp	sp[0x1c],r6
80007f72:	fc 08 00 39 	add	r9,lr,r8<<0x3
80007f76:	40 5b       	lddsp	r11,sp[0x14]
80007f78:	0c 9a       	mov	r10,r6
80007f7a:	f2 eb fd 88 	st.d	r9[-632],r10
80007f7e:	2f f8       	sub	r8,-1
80007f80:	fb 48 06 b4 	st.w	sp[1716],r8
80007f84:	c0 88       	rjmp	80007f94 <_vfprintf_r+0x888>
80007f86:	72 1c       	ld.w	r12,r9[0x4]
80007f88:	50 7c       	stdsp	sp[0x1c],r12
80007f8a:	f2 c8 ff f8 	sub	r8,r9,-8
80007f8e:	51 08       	stdsp	sp[0x40],r8
80007f90:	72 09       	ld.w	r9,r9[0x0]
80007f92:	50 59       	stdsp	sp[0x14],r9
80007f94:	40 5b       	lddsp	r11,sp[0x14]
80007f96:	40 7a       	lddsp	r10,sp[0x1c]
80007f98:	e0 a0 19 54 	rcall	8000b240 <__isinfd>
80007f9c:	18 96       	mov	r6,r12
80007f9e:	c1 70       	breq	80007fcc <_vfprintf_r+0x8c0>
80007fa0:	30 08       	mov	r8,0
80007fa2:	30 09       	mov	r9,0
80007fa4:	40 5b       	lddsp	r11,sp[0x14]
80007fa6:	40 7a       	lddsp	r10,sp[0x1c]
80007fa8:	e0 a0 1d a8 	rcall	8000baf8 <__avr32_f64_cmp_lt>
80007fac:	c0 40       	breq	80007fb4 <_vfprintf_r+0x8a8>
80007fae:	32 d8       	mov	r8,45
80007fb0:	fb 68 06 bb 	st.b	sp[1723],r8
80007fb4:	fe c8 a5 4c 	sub	r8,pc,-23220
80007fb8:	fe c6 a5 4c 	sub	r6,pc,-23220
80007fbc:	a7 d5       	cbr	r5,0x7
80007fbe:	e0 40 00 47 	cp.w	r0,71
80007fc2:	f0 06 17 a0 	movle	r6,r8
80007fc6:	30 32       	mov	r2,3
80007fc8:	e0 8f 06 ce 	bral	80008d64 <_vfprintf_r+0x1658>
80007fcc:	40 5b       	lddsp	r11,sp[0x14]
80007fce:	40 7a       	lddsp	r10,sp[0x1c]
80007fd0:	e0 a0 19 4d 	rcall	8000b26a <__isnand>
80007fd4:	c0 e0       	breq	80007ff0 <_vfprintf_r+0x8e4>
80007fd6:	50 26       	stdsp	sp[0x8],r6
80007fd8:	fe c8 a5 68 	sub	r8,pc,-23192
80007fdc:	fe c6 a5 68 	sub	r6,pc,-23192
80007fe0:	a7 d5       	cbr	r5,0x7
80007fe2:	e0 40 00 47 	cp.w	r0,71
80007fe6:	f0 06 17 a0 	movle	r6,r8
80007fea:	30 32       	mov	r2,3
80007fec:	e0 8f 06 c2 	bral	80008d70 <_vfprintf_r+0x1664>
80007ff0:	40 2a       	lddsp	r10,sp[0x8]
80007ff2:	5b fa       	cp.w	r10,-1
80007ff4:	c0 41       	brne	80007ffc <_vfprintf_r+0x8f0>
80007ff6:	30 69       	mov	r9,6
80007ff8:	50 29       	stdsp	sp[0x8],r9
80007ffa:	c1 18       	rjmp	8000801c <_vfprintf_r+0x910>
80007ffc:	e0 40 00 47 	cp.w	r0,71
80008000:	5f 09       	sreq	r9
80008002:	e0 40 00 67 	cp.w	r0,103
80008006:	5f 08       	sreq	r8
80008008:	f3 e8 10 08 	or	r8,r9,r8
8000800c:	f8 08 18 00 	cp.b	r8,r12
80008010:	c0 60       	breq	8000801c <_vfprintf_r+0x910>
80008012:	40 28       	lddsp	r8,sp[0x8]
80008014:	58 08       	cp.w	r8,0
80008016:	f9 b8 00 01 	moveq	r8,1
8000801a:	50 28       	stdsp	sp[0x8],r8
8000801c:	40 78       	lddsp	r8,sp[0x1c]
8000801e:	40 59       	lddsp	r9,sp[0x14]
80008020:	fa e9 06 94 	st.d	sp[1684],r8
80008024:	a9 a5       	sbr	r5,0x8
80008026:	fa f8 06 94 	ld.w	r8,sp[1684]
8000802a:	58 08       	cp.w	r8,0
8000802c:	c0 65       	brlt	80008038 <_vfprintf_r+0x92c>
8000802e:	40 5e       	lddsp	lr,sp[0x14]
80008030:	30 0c       	mov	r12,0
80008032:	50 6e       	stdsp	sp[0x18],lr
80008034:	50 9c       	stdsp	sp[0x24],r12
80008036:	c0 78       	rjmp	80008044 <_vfprintf_r+0x938>
80008038:	40 5b       	lddsp	r11,sp[0x14]
8000803a:	32 da       	mov	r10,45
8000803c:	ee 1b 80 00 	eorh	r11,0x8000
80008040:	50 9a       	stdsp	sp[0x24],r10
80008042:	50 6b       	stdsp	sp[0x18],r11
80008044:	e0 40 00 46 	cp.w	r0,70
80008048:	5f 09       	sreq	r9
8000804a:	e0 40 00 66 	cp.w	r0,102
8000804e:	5f 08       	sreq	r8
80008050:	f3 e8 10 08 	or	r8,r9,r8
80008054:	50 48       	stdsp	sp[0x10],r8
80008056:	c0 40       	breq	8000805e <_vfprintf_r+0x952>
80008058:	40 22       	lddsp	r2,sp[0x8]
8000805a:	30 39       	mov	r9,3
8000805c:	c1 08       	rjmp	8000807c <_vfprintf_r+0x970>
8000805e:	e0 40 00 45 	cp.w	r0,69
80008062:	5f 09       	sreq	r9
80008064:	e0 40 00 65 	cp.w	r0,101
80008068:	5f 08       	sreq	r8
8000806a:	40 22       	lddsp	r2,sp[0x8]
8000806c:	10 49       	or	r9,r8
8000806e:	2f f2       	sub	r2,-1
80008070:	40 46       	lddsp	r6,sp[0x10]
80008072:	ec 09 18 00 	cp.b	r9,r6
80008076:	fb f2 00 02 	ld.weq	r2,sp[0x8]
8000807a:	30 29       	mov	r9,2
8000807c:	fa c8 f9 5c 	sub	r8,sp,-1700
80008080:	1a d8       	st.w	--sp,r8
80008082:	fa c8 f9 54 	sub	r8,sp,-1708
80008086:	1a d8       	st.w	--sp,r8
80008088:	fa c8 f9 4c 	sub	r8,sp,-1716
8000808c:	08 9c       	mov	r12,r4
8000808e:	1a d8       	st.w	--sp,r8
80008090:	04 98       	mov	r8,r2
80008092:	40 9b       	lddsp	r11,sp[0x24]
80008094:	40 aa       	lddsp	r10,sp[0x28]
80008096:	e0 a0 0b c3 	rcall	8000981c <_dtoa_r>
8000809a:	e0 40 00 47 	cp.w	r0,71
8000809e:	5f 19       	srne	r9
800080a0:	e0 40 00 67 	cp.w	r0,103
800080a4:	5f 18       	srne	r8
800080a6:	18 96       	mov	r6,r12
800080a8:	2f dd       	sub	sp,-12
800080aa:	f3 e8 00 08 	and	r8,r9,r8
800080ae:	c0 41       	brne	800080b6 <_vfprintf_r+0x9aa>
800080b0:	ed b5 00 00 	bld	r5,0x0
800080b4:	c3 01       	brne	80008114 <_vfprintf_r+0xa08>
800080b6:	ec 02 00 0e 	add	lr,r6,r2
800080ba:	50 3e       	stdsp	sp[0xc],lr
800080bc:	40 4c       	lddsp	r12,sp[0x10]
800080be:	58 0c       	cp.w	r12,0
800080c0:	c1 50       	breq	800080ea <_vfprintf_r+0x9de>
800080c2:	0d 89       	ld.ub	r9,r6[0x0]
800080c4:	33 08       	mov	r8,48
800080c6:	f0 09 18 00 	cp.b	r9,r8
800080ca:	c0 b1       	brne	800080e0 <_vfprintf_r+0x9d4>
800080cc:	30 08       	mov	r8,0
800080ce:	30 09       	mov	r9,0
800080d0:	40 6b       	lddsp	r11,sp[0x18]
800080d2:	40 7a       	lddsp	r10,sp[0x1c]
800080d4:	e0 a0 1c cb 	rcall	8000ba6a <__avr32_f64_cmp_eq>
800080d8:	fb b2 00 01 	rsubeq	r2,1
800080dc:	fb f2 0b ab 	st.weq	sp[0x6ac],r2
800080e0:	40 3b       	lddsp	r11,sp[0xc]
800080e2:	fa f8 06 ac 	ld.w	r8,sp[1708]
800080e6:	10 0b       	add	r11,r8
800080e8:	50 3b       	stdsp	sp[0xc],r11
800080ea:	40 6b       	lddsp	r11,sp[0x18]
800080ec:	30 08       	mov	r8,0
800080ee:	30 09       	mov	r9,0
800080f0:	40 7a       	lddsp	r10,sp[0x1c]
800080f2:	e0 a0 1c bc 	rcall	8000ba6a <__avr32_f64_cmp_eq>
800080f6:	c0 90       	breq	80008108 <_vfprintf_r+0x9fc>
800080f8:	40 3a       	lddsp	r10,sp[0xc]
800080fa:	fb 4a 06 a4 	st.w	sp[1700],r10
800080fe:	c0 58       	rjmp	80008108 <_vfprintf_r+0x9fc>
80008100:	10 c9       	st.b	r8++,r9
80008102:	fb 48 06 a4 	st.w	sp[1700],r8
80008106:	c0 28       	rjmp	8000810a <_vfprintf_r+0x9fe>
80008108:	33 09       	mov	r9,48
8000810a:	fa f8 06 a4 	ld.w	r8,sp[1700]
8000810e:	40 3e       	lddsp	lr,sp[0xc]
80008110:	1c 38       	cp.w	r8,lr
80008112:	cf 73       	brcs	80008100 <_vfprintf_r+0x9f4>
80008114:	e0 40 00 47 	cp.w	r0,71
80008118:	5f 09       	sreq	r9
8000811a:	e0 40 00 67 	cp.w	r0,103
8000811e:	5f 08       	sreq	r8
80008120:	f3 e8 10 08 	or	r8,r9,r8
80008124:	fa f9 06 a4 	ld.w	r9,sp[1700]
80008128:	0c 19       	sub	r9,r6
8000812a:	50 69       	stdsp	sp[0x18],r9
8000812c:	58 08       	cp.w	r8,0
8000812e:	c0 b0       	breq	80008144 <_vfprintf_r+0xa38>
80008130:	fa f8 06 ac 	ld.w	r8,sp[1708]
80008134:	5b d8       	cp.w	r8,-3
80008136:	c0 55       	brlt	80008140 <_vfprintf_r+0xa34>
80008138:	40 2c       	lddsp	r12,sp[0x8]
8000813a:	18 38       	cp.w	r8,r12
8000813c:	e0 8a 00 6a 	brle	80008210 <_vfprintf_r+0xb04>
80008140:	20 20       	sub	r0,2
80008142:	c0 58       	rjmp	8000814c <_vfprintf_r+0xa40>
80008144:	e0 40 00 65 	cp.w	r0,101
80008148:	e0 89 00 46 	brgt	800081d4 <_vfprintf_r+0xac8>
8000814c:	fa fb 06 ac 	ld.w	r11,sp[1708]
80008150:	fb 60 06 9c 	st.b	sp[1692],r0
80008154:	20 1b       	sub	r11,1
80008156:	fb 4b 06 ac 	st.w	sp[1708],r11
8000815a:	c0 47       	brpl	80008162 <_vfprintf_r+0xa56>
8000815c:	5c 3b       	neg	r11
8000815e:	32 d8       	mov	r8,45
80008160:	c0 28       	rjmp	80008164 <_vfprintf_r+0xa58>
80008162:	32 b8       	mov	r8,43
80008164:	fb 68 06 9d 	st.b	sp[1693],r8
80008168:	58 9b       	cp.w	r11,9
8000816a:	e0 8a 00 1d 	brle	800081a4 <_vfprintf_r+0xa98>
8000816e:	fa c9 fa 35 	sub	r9,sp,-1483
80008172:	30 aa       	mov	r10,10
80008174:	12 98       	mov	r8,r9
80008176:	0e 9c       	mov	r12,r7
80008178:	0c 92       	mov	r2,r6
8000817a:	f6 0a 0c 06 	divs	r6,r11,r10
8000817e:	0e 9b       	mov	r11,r7
80008180:	2d 0b       	sub	r11,-48
80008182:	10 fb       	st.b	--r8,r11
80008184:	0c 9b       	mov	r11,r6
80008186:	58 96       	cp.w	r6,9
80008188:	fe 99 ff f9 	brgt	8000817a <_vfprintf_r+0xa6e>
8000818c:	2d 0b       	sub	r11,-48
8000818e:	18 97       	mov	r7,r12
80008190:	04 96       	mov	r6,r2
80008192:	10 fb       	st.b	--r8,r11
80008194:	fa ca f9 62 	sub	r10,sp,-1694
80008198:	c0 38       	rjmp	8000819e <_vfprintf_r+0xa92>
8000819a:	11 3b       	ld.ub	r11,r8++
8000819c:	14 cb       	st.b	r10++,r11
8000819e:	12 38       	cp.w	r8,r9
800081a0:	cf d3       	brcs	8000819a <_vfprintf_r+0xa8e>
800081a2:	c0 98       	rjmp	800081b4 <_vfprintf_r+0xaa8>
800081a4:	2d 0b       	sub	r11,-48
800081a6:	33 08       	mov	r8,48
800081a8:	fb 6b 06 9f 	st.b	sp[1695],r11
800081ac:	fb 68 06 9e 	st.b	sp[1694],r8
800081b0:	fa ca f9 60 	sub	r10,sp,-1696
800081b4:	fa c8 f9 64 	sub	r8,sp,-1692
800081b8:	f4 08 01 08 	sub	r8,r10,r8
800081bc:	50 e8       	stdsp	sp[0x38],r8
800081be:	10 92       	mov	r2,r8
800081c0:	40 6b       	lddsp	r11,sp[0x18]
800081c2:	16 02       	add	r2,r11
800081c4:	58 1b       	cp.w	r11,1
800081c6:	e0 89 00 05 	brgt	800081d0 <_vfprintf_r+0xac4>
800081ca:	ed b5 00 00 	bld	r5,0x0
800081ce:	c3 51       	brne	80008238 <_vfprintf_r+0xb2c>
800081d0:	2f f2       	sub	r2,-1
800081d2:	c3 38       	rjmp	80008238 <_vfprintf_r+0xb2c>
800081d4:	e0 40 00 66 	cp.w	r0,102
800081d8:	c1 c1       	brne	80008210 <_vfprintf_r+0xb04>
800081da:	fa f2 06 ac 	ld.w	r2,sp[1708]
800081de:	58 02       	cp.w	r2,0
800081e0:	e0 8a 00 0c 	brle	800081f8 <_vfprintf_r+0xaec>
800081e4:	40 2a       	lddsp	r10,sp[0x8]
800081e6:	58 0a       	cp.w	r10,0
800081e8:	c0 41       	brne	800081f0 <_vfprintf_r+0xae4>
800081ea:	ed b5 00 00 	bld	r5,0x0
800081ee:	c2 51       	brne	80008238 <_vfprintf_r+0xb2c>
800081f0:	2f f2       	sub	r2,-1
800081f2:	40 29       	lddsp	r9,sp[0x8]
800081f4:	12 02       	add	r2,r9
800081f6:	c0 b8       	rjmp	8000820c <_vfprintf_r+0xb00>
800081f8:	40 28       	lddsp	r8,sp[0x8]
800081fa:	58 08       	cp.w	r8,0
800081fc:	c0 61       	brne	80008208 <_vfprintf_r+0xafc>
800081fe:	ed b5 00 00 	bld	r5,0x0
80008202:	c0 30       	breq	80008208 <_vfprintf_r+0xafc>
80008204:	30 12       	mov	r2,1
80008206:	c1 98       	rjmp	80008238 <_vfprintf_r+0xb2c>
80008208:	40 22       	lddsp	r2,sp[0x8]
8000820a:	2f e2       	sub	r2,-2
8000820c:	36 60       	mov	r0,102
8000820e:	c1 58       	rjmp	80008238 <_vfprintf_r+0xb2c>
80008210:	fa f2 06 ac 	ld.w	r2,sp[1708]
80008214:	40 6e       	lddsp	lr,sp[0x18]
80008216:	1c 32       	cp.w	r2,lr
80008218:	c0 65       	brlt	80008224 <_vfprintf_r+0xb18>
8000821a:	ed b5 00 00 	bld	r5,0x0
8000821e:	f7 b2 00 ff 	subeq	r2,-1
80008222:	c0 a8       	rjmp	80008236 <_vfprintf_r+0xb2a>
80008224:	e4 08 11 02 	rsub	r8,r2,2
80008228:	40 6c       	lddsp	r12,sp[0x18]
8000822a:	58 02       	cp.w	r2,0
8000822c:	f0 02 17 a0 	movle	r2,r8
80008230:	f9 b2 09 01 	movgt	r2,1
80008234:	18 02       	add	r2,r12
80008236:	36 70       	mov	r0,103
80008238:	40 9b       	lddsp	r11,sp[0x24]
8000823a:	58 0b       	cp.w	r11,0
8000823c:	e0 80 05 94 	breq	80008d64 <_vfprintf_r+0x1658>
80008240:	32 d8       	mov	r8,45
80008242:	fb 68 06 bb 	st.b	sp[1723],r8
80008246:	e0 8f 05 93 	bral	80008d6c <_vfprintf_r+0x1660>
8000824a:	50 a7       	stdsp	sp[0x28],r7
8000824c:	04 94       	mov	r4,r2
8000824e:	0c 97       	mov	r7,r6
80008250:	02 92       	mov	r2,r1
80008252:	06 96       	mov	r6,r3
80008254:	40 41       	lddsp	r1,sp[0x10]
80008256:	40 93       	lddsp	r3,sp[0x24]
80008258:	0e 99       	mov	r9,r7
8000825a:	ed b5 00 05 	bld	r5,0x5
8000825e:	c4 81       	brne	800082ee <_vfprintf_r+0xbe2>
80008260:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008264:	40 3e       	lddsp	lr,sp[0xc]
80008266:	58 0e       	cp.w	lr,0
80008268:	c1 d0       	breq	800082a2 <_vfprintf_r+0xb96>
8000826a:	10 36       	cp.w	r6,r8
8000826c:	c0 64       	brge	80008278 <_vfprintf_r+0xb6c>
8000826e:	fa cc f9 44 	sub	r12,sp,-1724
80008272:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008276:	c1 d8       	rjmp	800082b0 <_vfprintf_r+0xba4>
80008278:	fa c8 f9 50 	sub	r8,sp,-1712
8000827c:	1a d8       	st.w	--sp,r8
8000827e:	fa c8 fa b8 	sub	r8,sp,-1352
80008282:	04 9a       	mov	r10,r2
80008284:	1a d8       	st.w	--sp,r8
80008286:	fa c8 fb b4 	sub	r8,sp,-1100
8000828a:	0c 9b       	mov	r11,r6
8000828c:	1a d8       	st.w	--sp,r8
8000828e:	08 9c       	mov	r12,r4
80008290:	fa c8 f9 40 	sub	r8,sp,-1728
80008294:	fa c9 ff b4 	sub	r9,sp,-76
80008298:	fe b0 f8 a2 	rcall	800073dc <get_arg>
8000829c:	2f dd       	sub	sp,-12
8000829e:	78 0a       	ld.w	r10,r12[0x0]
800082a0:	c2 08       	rjmp	800082e0 <_vfprintf_r+0xbd4>
800082a2:	2f f7       	sub	r7,-1
800082a4:	10 39       	cp.w	r9,r8
800082a6:	c0 84       	brge	800082b6 <_vfprintf_r+0xbaa>
800082a8:	fa cb f9 44 	sub	r11,sp,-1724
800082ac:	f6 06 00 36 	add	r6,r11,r6<<0x3
800082b0:	ec fa fd 88 	ld.w	r10,r6[-632]
800082b4:	c1 68       	rjmp	800082e0 <_vfprintf_r+0xbd4>
800082b6:	41 09       	lddsp	r9,sp[0x40]
800082b8:	59 f8       	cp.w	r8,31
800082ba:	e0 89 00 10 	brgt	800082da <_vfprintf_r+0xbce>
800082be:	f2 ca ff fc 	sub	r10,r9,-4
800082c2:	51 0a       	stdsp	sp[0x40],r10
800082c4:	fa c6 f9 44 	sub	r6,sp,-1724
800082c8:	72 0a       	ld.w	r10,r9[0x0]
800082ca:	ec 08 00 39 	add	r9,r6,r8<<0x3
800082ce:	f3 4a fd 88 	st.w	r9[-632],r10
800082d2:	2f f8       	sub	r8,-1
800082d4:	fb 48 06 b4 	st.w	sp[1716],r8
800082d8:	c0 48       	rjmp	800082e0 <_vfprintf_r+0xbd4>
800082da:	72 0a       	ld.w	r10,r9[0x0]
800082dc:	2f c9       	sub	r9,-4
800082de:	51 09       	stdsp	sp[0x40],r9
800082e0:	40 be       	lddsp	lr,sp[0x2c]
800082e2:	1c 98       	mov	r8,lr
800082e4:	95 1e       	st.w	r10[0x4],lr
800082e6:	bf 58       	asr	r8,0x1f
800082e8:	95 08       	st.w	r10[0x0],r8
800082ea:	fe 9f fa 9f 	bral	80007828 <_vfprintf_r+0x11c>
800082ee:	ed b5 00 04 	bld	r5,0x4
800082f2:	c4 80       	breq	80008382 <_vfprintf_r+0xc76>
800082f4:	e2 15 00 40 	andl	r5,0x40,COH
800082f8:	c4 50       	breq	80008382 <_vfprintf_r+0xc76>
800082fa:	fa f8 06 b4 	ld.w	r8,sp[1716]
800082fe:	40 3c       	lddsp	r12,sp[0xc]
80008300:	58 0c       	cp.w	r12,0
80008302:	c1 d0       	breq	8000833c <_vfprintf_r+0xc30>
80008304:	10 36       	cp.w	r6,r8
80008306:	c0 64       	brge	80008312 <_vfprintf_r+0xc06>
80008308:	fa cb f9 44 	sub	r11,sp,-1724
8000830c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008310:	c1 d8       	rjmp	8000834a <_vfprintf_r+0xc3e>
80008312:	fa c8 f9 50 	sub	r8,sp,-1712
80008316:	1a d8       	st.w	--sp,r8
80008318:	fa c8 fa b8 	sub	r8,sp,-1352
8000831c:	04 9a       	mov	r10,r2
8000831e:	1a d8       	st.w	--sp,r8
80008320:	fa c8 fb b4 	sub	r8,sp,-1100
80008324:	0c 9b       	mov	r11,r6
80008326:	1a d8       	st.w	--sp,r8
80008328:	08 9c       	mov	r12,r4
8000832a:	fa c8 f9 40 	sub	r8,sp,-1728
8000832e:	fa c9 ff b4 	sub	r9,sp,-76
80008332:	fe b0 f8 55 	rcall	800073dc <get_arg>
80008336:	2f dd       	sub	sp,-12
80008338:	78 0a       	ld.w	r10,r12[0x0]
8000833a:	c2 08       	rjmp	8000837a <_vfprintf_r+0xc6e>
8000833c:	2f f7       	sub	r7,-1
8000833e:	10 39       	cp.w	r9,r8
80008340:	c0 84       	brge	80008350 <_vfprintf_r+0xc44>
80008342:	fa ca f9 44 	sub	r10,sp,-1724
80008346:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000834a:	ec fa fd 88 	ld.w	r10,r6[-632]
8000834e:	c1 68       	rjmp	8000837a <_vfprintf_r+0xc6e>
80008350:	41 09       	lddsp	r9,sp[0x40]
80008352:	59 f8       	cp.w	r8,31
80008354:	e0 89 00 10 	brgt	80008374 <_vfprintf_r+0xc68>
80008358:	f2 ca ff fc 	sub	r10,r9,-4
8000835c:	51 0a       	stdsp	sp[0x40],r10
8000835e:	fa c6 f9 44 	sub	r6,sp,-1724
80008362:	72 0a       	ld.w	r10,r9[0x0]
80008364:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008368:	f3 4a fd 88 	st.w	r9[-632],r10
8000836c:	2f f8       	sub	r8,-1
8000836e:	fb 48 06 b4 	st.w	sp[1716],r8
80008372:	c0 48       	rjmp	8000837a <_vfprintf_r+0xc6e>
80008374:	72 0a       	ld.w	r10,r9[0x0]
80008376:	2f c9       	sub	r9,-4
80008378:	51 09       	stdsp	sp[0x40],r9
8000837a:	40 be       	lddsp	lr,sp[0x2c]
8000837c:	b4 0e       	st.h	r10[0x0],lr
8000837e:	fe 9f fa 55 	bral	80007828 <_vfprintf_r+0x11c>
80008382:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008386:	40 3c       	lddsp	r12,sp[0xc]
80008388:	58 0c       	cp.w	r12,0
8000838a:	c1 d0       	breq	800083c4 <_vfprintf_r+0xcb8>
8000838c:	10 36       	cp.w	r6,r8
8000838e:	c0 64       	brge	8000839a <_vfprintf_r+0xc8e>
80008390:	fa cb f9 44 	sub	r11,sp,-1724
80008394:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008398:	c1 d8       	rjmp	800083d2 <_vfprintf_r+0xcc6>
8000839a:	fa c8 f9 50 	sub	r8,sp,-1712
8000839e:	1a d8       	st.w	--sp,r8
800083a0:	fa c8 fa b8 	sub	r8,sp,-1352
800083a4:	04 9a       	mov	r10,r2
800083a6:	1a d8       	st.w	--sp,r8
800083a8:	fa c8 fb b4 	sub	r8,sp,-1100
800083ac:	0c 9b       	mov	r11,r6
800083ae:	1a d8       	st.w	--sp,r8
800083b0:	08 9c       	mov	r12,r4
800083b2:	fa c8 f9 40 	sub	r8,sp,-1728
800083b6:	fa c9 ff b4 	sub	r9,sp,-76
800083ba:	fe b0 f8 11 	rcall	800073dc <get_arg>
800083be:	2f dd       	sub	sp,-12
800083c0:	78 0a       	ld.w	r10,r12[0x0]
800083c2:	c2 08       	rjmp	80008402 <_vfprintf_r+0xcf6>
800083c4:	2f f7       	sub	r7,-1
800083c6:	10 39       	cp.w	r9,r8
800083c8:	c0 84       	brge	800083d8 <_vfprintf_r+0xccc>
800083ca:	fa ca f9 44 	sub	r10,sp,-1724
800083ce:	f4 06 00 36 	add	r6,r10,r6<<0x3
800083d2:	ec fa fd 88 	ld.w	r10,r6[-632]
800083d6:	c1 68       	rjmp	80008402 <_vfprintf_r+0xcf6>
800083d8:	41 09       	lddsp	r9,sp[0x40]
800083da:	59 f8       	cp.w	r8,31
800083dc:	e0 89 00 10 	brgt	800083fc <_vfprintf_r+0xcf0>
800083e0:	f2 ca ff fc 	sub	r10,r9,-4
800083e4:	51 0a       	stdsp	sp[0x40],r10
800083e6:	fa c6 f9 44 	sub	r6,sp,-1724
800083ea:	72 0a       	ld.w	r10,r9[0x0]
800083ec:	ec 08 00 39 	add	r9,r6,r8<<0x3
800083f0:	f3 4a fd 88 	st.w	r9[-632],r10
800083f4:	2f f8       	sub	r8,-1
800083f6:	fb 48 06 b4 	st.w	sp[1716],r8
800083fa:	c0 48       	rjmp	80008402 <_vfprintf_r+0xcf6>
800083fc:	72 0a       	ld.w	r10,r9[0x0]
800083fe:	2f c9       	sub	r9,-4
80008400:	51 09       	stdsp	sp[0x40],r9
80008402:	40 be       	lddsp	lr,sp[0x2c]
80008404:	95 0e       	st.w	r10[0x0],lr
80008406:	fe 9f fa 11 	bral	80007828 <_vfprintf_r+0x11c>
8000840a:	50 a7       	stdsp	sp[0x28],r7
8000840c:	50 80       	stdsp	sp[0x20],r0
8000840e:	0c 97       	mov	r7,r6
80008410:	04 94       	mov	r4,r2
80008412:	06 96       	mov	r6,r3
80008414:	02 92       	mov	r2,r1
80008416:	40 93       	lddsp	r3,sp[0x24]
80008418:	10 90       	mov	r0,r8
8000841a:	40 41       	lddsp	r1,sp[0x10]
8000841c:	a5 a5       	sbr	r5,0x4
8000841e:	c0 a8       	rjmp	80008432 <_vfprintf_r+0xd26>
80008420:	50 a7       	stdsp	sp[0x28],r7
80008422:	50 80       	stdsp	sp[0x20],r0
80008424:	0c 97       	mov	r7,r6
80008426:	04 94       	mov	r4,r2
80008428:	06 96       	mov	r6,r3
8000842a:	02 92       	mov	r2,r1
8000842c:	40 93       	lddsp	r3,sp[0x24]
8000842e:	10 90       	mov	r0,r8
80008430:	40 41       	lddsp	r1,sp[0x10]
80008432:	ed b5 00 05 	bld	r5,0x5
80008436:	c5 d1       	brne	800084f0 <_vfprintf_r+0xde4>
80008438:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000843c:	40 3c       	lddsp	r12,sp[0xc]
8000843e:	58 0c       	cp.w	r12,0
80008440:	c2 60       	breq	8000848c <_vfprintf_r+0xd80>
80008442:	10 36       	cp.w	r6,r8
80008444:	c0 a4       	brge	80008458 <_vfprintf_r+0xd4c>
80008446:	fa cb f9 44 	sub	r11,sp,-1724
8000844a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000844e:	ec e8 fd 88 	ld.d	r8,r6[-632]
80008452:	fa e9 00 00 	st.d	sp[0],r8
80008456:	c1 88       	rjmp	80008486 <_vfprintf_r+0xd7a>
80008458:	fa c8 f9 50 	sub	r8,sp,-1712
8000845c:	1a d8       	st.w	--sp,r8
8000845e:	fa c8 fa b8 	sub	r8,sp,-1352
80008462:	04 9a       	mov	r10,r2
80008464:	1a d8       	st.w	--sp,r8
80008466:	0c 9b       	mov	r11,r6
80008468:	fa c8 fb b4 	sub	r8,sp,-1100
8000846c:	08 9c       	mov	r12,r4
8000846e:	1a d8       	st.w	--sp,r8
80008470:	fa c8 f9 40 	sub	r8,sp,-1728
80008474:	fa c9 ff b4 	sub	r9,sp,-76
80008478:	fe b0 f7 b2 	rcall	800073dc <get_arg>
8000847c:	2f dd       	sub	sp,-12
8000847e:	f8 ea 00 00 	ld.d	r10,r12[0]
80008482:	fa eb 00 00 	st.d	sp[0],r10
80008486:	30 08       	mov	r8,0
80008488:	e0 8f 03 de 	bral	80008c44 <_vfprintf_r+0x1538>
8000848c:	ee ca ff ff 	sub	r10,r7,-1
80008490:	10 37       	cp.w	r7,r8
80008492:	c0 b4       	brge	800084a8 <_vfprintf_r+0xd9c>
80008494:	fa c9 f9 44 	sub	r9,sp,-1724
80008498:	14 97       	mov	r7,r10
8000849a:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000849e:	ec ea fd 88 	ld.d	r10,r6[-632]
800084a2:	fa eb 00 00 	st.d	sp[0],r10
800084a6:	c1 88       	rjmp	800084d6 <_vfprintf_r+0xdca>
800084a8:	41 09       	lddsp	r9,sp[0x40]
800084aa:	59 f8       	cp.w	r8,31
800084ac:	e0 89 00 18 	brgt	800084dc <_vfprintf_r+0xdd0>
800084b0:	f2 e6 00 00 	ld.d	r6,r9[0]
800084b4:	f2 cb ff f8 	sub	r11,r9,-8
800084b8:	fa e7 00 00 	st.d	sp[0],r6
800084bc:	51 0b       	stdsp	sp[0x40],r11
800084be:	fa c6 f9 44 	sub	r6,sp,-1724
800084c2:	ec 08 00 39 	add	r9,r6,r8<<0x3
800084c6:	fa e6 00 00 	ld.d	r6,sp[0]
800084ca:	f2 e7 fd 88 	st.d	r9[-632],r6
800084ce:	2f f8       	sub	r8,-1
800084d0:	14 97       	mov	r7,r10
800084d2:	fb 48 06 b4 	st.w	sp[1716],r8
800084d6:	40 38       	lddsp	r8,sp[0xc]
800084d8:	e0 8f 03 b6 	bral	80008c44 <_vfprintf_r+0x1538>
800084dc:	f2 e6 00 00 	ld.d	r6,r9[0]
800084e0:	40 38       	lddsp	r8,sp[0xc]
800084e2:	fa e7 00 00 	st.d	sp[0],r6
800084e6:	2f 89       	sub	r9,-8
800084e8:	14 97       	mov	r7,r10
800084ea:	51 09       	stdsp	sp[0x40],r9
800084ec:	e0 8f 03 ac 	bral	80008c44 <_vfprintf_r+0x1538>
800084f0:	ed b5 00 04 	bld	r5,0x4
800084f4:	c1 61       	brne	80008520 <_vfprintf_r+0xe14>
800084f6:	fa f8 06 b4 	ld.w	r8,sp[1716]
800084fa:	40 3e       	lddsp	lr,sp[0xc]
800084fc:	58 0e       	cp.w	lr,0
800084fe:	c0 80       	breq	8000850e <_vfprintf_r+0xe02>
80008500:	10 36       	cp.w	r6,r8
80008502:	c6 74       	brge	800085d0 <_vfprintf_r+0xec4>
80008504:	fa cc f9 44 	sub	r12,sp,-1724
80008508:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000850c:	c8 08       	rjmp	8000860c <_vfprintf_r+0xf00>
8000850e:	ee ca ff ff 	sub	r10,r7,-1
80008512:	10 37       	cp.w	r7,r8
80008514:	c7 f4       	brge	80008612 <_vfprintf_r+0xf06>
80008516:	fa cb f9 44 	sub	r11,sp,-1724
8000851a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000851e:	c7 68       	rjmp	8000860a <_vfprintf_r+0xefe>
80008520:	ed b5 00 06 	bld	r5,0x6
80008524:	c4 a1       	brne	800085b8 <_vfprintf_r+0xeac>
80008526:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000852a:	40 3c       	lddsp	r12,sp[0xc]
8000852c:	58 0c       	cp.w	r12,0
8000852e:	c1 d0       	breq	80008568 <_vfprintf_r+0xe5c>
80008530:	10 36       	cp.w	r6,r8
80008532:	c0 64       	brge	8000853e <_vfprintf_r+0xe32>
80008534:	fa cb f9 44 	sub	r11,sp,-1724
80008538:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000853c:	c1 f8       	rjmp	8000857a <_vfprintf_r+0xe6e>
8000853e:	fa c8 f9 50 	sub	r8,sp,-1712
80008542:	1a d8       	st.w	--sp,r8
80008544:	fa c8 fa b8 	sub	r8,sp,-1352
80008548:	1a d8       	st.w	--sp,r8
8000854a:	fa c8 fb b4 	sub	r8,sp,-1100
8000854e:	1a d8       	st.w	--sp,r8
80008550:	fa c8 f9 40 	sub	r8,sp,-1728
80008554:	fa c9 ff b4 	sub	r9,sp,-76
80008558:	04 9a       	mov	r10,r2
8000855a:	0c 9b       	mov	r11,r6
8000855c:	08 9c       	mov	r12,r4
8000855e:	fe b0 f7 3f 	rcall	800073dc <get_arg>
80008562:	2f dd       	sub	sp,-12
80008564:	98 18       	ld.sh	r8,r12[0x2]
80008566:	c2 68       	rjmp	800085b2 <_vfprintf_r+0xea6>
80008568:	ee ca ff ff 	sub	r10,r7,-1
8000856c:	10 37       	cp.w	r7,r8
8000856e:	c0 94       	brge	80008580 <_vfprintf_r+0xe74>
80008570:	fa c9 f9 44 	sub	r9,sp,-1724
80008574:	14 97       	mov	r7,r10
80008576:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000857a:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000857e:	c1 a8       	rjmp	800085b2 <_vfprintf_r+0xea6>
80008580:	41 09       	lddsp	r9,sp[0x40]
80008582:	59 f8       	cp.w	r8,31
80008584:	e0 89 00 13 	brgt	800085aa <_vfprintf_r+0xe9e>
80008588:	f2 cb ff fc 	sub	r11,r9,-4
8000858c:	51 0b       	stdsp	sp[0x40],r11
8000858e:	72 09       	ld.w	r9,r9[0x0]
80008590:	fa c6 f9 44 	sub	r6,sp,-1724
80008594:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008598:	2f f8       	sub	r8,-1
8000859a:	f7 49 fd 88 	st.w	r11[-632],r9
8000859e:	fb 48 06 b4 	st.w	sp[1716],r8
800085a2:	14 97       	mov	r7,r10
800085a4:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
800085a8:	c0 58       	rjmp	800085b2 <_vfprintf_r+0xea6>
800085aa:	92 18       	ld.sh	r8,r9[0x2]
800085ac:	14 97       	mov	r7,r10
800085ae:	2f c9       	sub	r9,-4
800085b0:	51 09       	stdsp	sp[0x40],r9
800085b2:	5c 78       	castu.h	r8
800085b4:	50 18       	stdsp	sp[0x4],r8
800085b6:	c4 68       	rjmp	80008642 <_vfprintf_r+0xf36>
800085b8:	fa f8 06 b4 	ld.w	r8,sp[1716]
800085bc:	40 3c       	lddsp	r12,sp[0xc]
800085be:	58 0c       	cp.w	r12,0
800085c0:	c1 d0       	breq	800085fa <_vfprintf_r+0xeee>
800085c2:	10 36       	cp.w	r6,r8
800085c4:	c0 64       	brge	800085d0 <_vfprintf_r+0xec4>
800085c6:	fa cb f9 44 	sub	r11,sp,-1724
800085ca:	f6 06 00 36 	add	r6,r11,r6<<0x3
800085ce:	c1 f8       	rjmp	8000860c <_vfprintf_r+0xf00>
800085d0:	fa c8 f9 50 	sub	r8,sp,-1712
800085d4:	1a d8       	st.w	--sp,r8
800085d6:	fa c8 fa b8 	sub	r8,sp,-1352
800085da:	0c 9b       	mov	r11,r6
800085dc:	1a d8       	st.w	--sp,r8
800085de:	fa c8 fb b4 	sub	r8,sp,-1100
800085e2:	04 9a       	mov	r10,r2
800085e4:	1a d8       	st.w	--sp,r8
800085e6:	08 9c       	mov	r12,r4
800085e8:	fa c8 f9 40 	sub	r8,sp,-1728
800085ec:	fa c9 ff b4 	sub	r9,sp,-76
800085f0:	fe b0 f6 f6 	rcall	800073dc <get_arg>
800085f4:	2f dd       	sub	sp,-12
800085f6:	78 0b       	ld.w	r11,r12[0x0]
800085f8:	c2 48       	rjmp	80008640 <_vfprintf_r+0xf34>
800085fa:	ee ca ff ff 	sub	r10,r7,-1
800085fe:	10 37       	cp.w	r7,r8
80008600:	c0 94       	brge	80008612 <_vfprintf_r+0xf06>
80008602:	fa c9 f9 44 	sub	r9,sp,-1724
80008606:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000860a:	14 97       	mov	r7,r10
8000860c:	ec fb fd 88 	ld.w	r11,r6[-632]
80008610:	c1 88       	rjmp	80008640 <_vfprintf_r+0xf34>
80008612:	41 09       	lddsp	r9,sp[0x40]
80008614:	59 f8       	cp.w	r8,31
80008616:	e0 89 00 11 	brgt	80008638 <_vfprintf_r+0xf2c>
8000861a:	f2 cb ff fc 	sub	r11,r9,-4
8000861e:	51 0b       	stdsp	sp[0x40],r11
80008620:	fa c6 f9 44 	sub	r6,sp,-1724
80008624:	72 0b       	ld.w	r11,r9[0x0]
80008626:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000862a:	f3 4b fd 88 	st.w	r9[-632],r11
8000862e:	2f f8       	sub	r8,-1
80008630:	14 97       	mov	r7,r10
80008632:	fb 48 06 b4 	st.w	sp[1716],r8
80008636:	c0 58       	rjmp	80008640 <_vfprintf_r+0xf34>
80008638:	72 0b       	ld.w	r11,r9[0x0]
8000863a:	14 97       	mov	r7,r10
8000863c:	2f c9       	sub	r9,-4
8000863e:	51 09       	stdsp	sp[0x40],r9
80008640:	50 1b       	stdsp	sp[0x4],r11
80008642:	30 0e       	mov	lr,0
80008644:	50 0e       	stdsp	sp[0x0],lr
80008646:	1c 98       	mov	r8,lr
80008648:	e0 8f 02 fe 	bral	80008c44 <_vfprintf_r+0x1538>
8000864c:	50 a7       	stdsp	sp[0x28],r7
8000864e:	50 80       	stdsp	sp[0x20],r0
80008650:	0c 97       	mov	r7,r6
80008652:	04 94       	mov	r4,r2
80008654:	06 96       	mov	r6,r3
80008656:	02 92       	mov	r2,r1
80008658:	40 93       	lddsp	r3,sp[0x24]
8000865a:	40 41       	lddsp	r1,sp[0x10]
8000865c:	0e 99       	mov	r9,r7
8000865e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008662:	40 3c       	lddsp	r12,sp[0xc]
80008664:	58 0c       	cp.w	r12,0
80008666:	c1 d0       	breq	800086a0 <_vfprintf_r+0xf94>
80008668:	10 36       	cp.w	r6,r8
8000866a:	c0 64       	brge	80008676 <_vfprintf_r+0xf6a>
8000866c:	fa cb f9 44 	sub	r11,sp,-1724
80008670:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008674:	c1 d8       	rjmp	800086ae <_vfprintf_r+0xfa2>
80008676:	fa c8 f9 50 	sub	r8,sp,-1712
8000867a:	1a d8       	st.w	--sp,r8
8000867c:	fa c8 fa b8 	sub	r8,sp,-1352
80008680:	1a d8       	st.w	--sp,r8
80008682:	fa c8 fb b4 	sub	r8,sp,-1100
80008686:	1a d8       	st.w	--sp,r8
80008688:	fa c9 ff b4 	sub	r9,sp,-76
8000868c:	fa c8 f9 40 	sub	r8,sp,-1728
80008690:	04 9a       	mov	r10,r2
80008692:	0c 9b       	mov	r11,r6
80008694:	08 9c       	mov	r12,r4
80008696:	fe b0 f6 a3 	rcall	800073dc <get_arg>
8000869a:	2f dd       	sub	sp,-12
8000869c:	78 09       	ld.w	r9,r12[0x0]
8000869e:	c2 18       	rjmp	800086e0 <_vfprintf_r+0xfd4>
800086a0:	2f f7       	sub	r7,-1
800086a2:	10 39       	cp.w	r9,r8
800086a4:	c0 84       	brge	800086b4 <_vfprintf_r+0xfa8>
800086a6:	fa ca f9 44 	sub	r10,sp,-1724
800086aa:	f4 06 00 36 	add	r6,r10,r6<<0x3
800086ae:	ec f9 fd 88 	ld.w	r9,r6[-632]
800086b2:	c1 78       	rjmp	800086e0 <_vfprintf_r+0xfd4>
800086b4:	41 09       	lddsp	r9,sp[0x40]
800086b6:	59 f8       	cp.w	r8,31
800086b8:	e0 89 00 10 	brgt	800086d8 <_vfprintf_r+0xfcc>
800086bc:	f2 ca ff fc 	sub	r10,r9,-4
800086c0:	51 0a       	stdsp	sp[0x40],r10
800086c2:	fa c6 f9 44 	sub	r6,sp,-1724
800086c6:	72 09       	ld.w	r9,r9[0x0]
800086c8:	ec 08 00 3a 	add	r10,r6,r8<<0x3
800086cc:	f5 49 fd 88 	st.w	r10[-632],r9
800086d0:	2f f8       	sub	r8,-1
800086d2:	fb 48 06 b4 	st.w	sp[1716],r8
800086d6:	c0 58       	rjmp	800086e0 <_vfprintf_r+0xfd4>
800086d8:	f2 c8 ff fc 	sub	r8,r9,-4
800086dc:	51 08       	stdsp	sp[0x40],r8
800086de:	72 09       	ld.w	r9,r9[0x0]
800086e0:	33 08       	mov	r8,48
800086e2:	fb 68 06 b8 	st.b	sp[1720],r8
800086e6:	37 88       	mov	r8,120
800086e8:	30 0e       	mov	lr,0
800086ea:	fb 68 06 b9 	st.b	sp[1721],r8
800086ee:	fe cc ac 76 	sub	r12,pc,-21386
800086f2:	50 19       	stdsp	sp[0x4],r9
800086f4:	a1 b5       	sbr	r5,0x1
800086f6:	50 0e       	stdsp	sp[0x0],lr
800086f8:	50 dc       	stdsp	sp[0x34],r12
800086fa:	30 28       	mov	r8,2
800086fc:	37 80       	mov	r0,120
800086fe:	e0 8f 02 a3 	bral	80008c44 <_vfprintf_r+0x1538>
80008702:	50 a7       	stdsp	sp[0x28],r7
80008704:	50 80       	stdsp	sp[0x20],r0
80008706:	10 90       	mov	r0,r8
80008708:	30 08       	mov	r8,0
8000870a:	fb 68 06 bb 	st.b	sp[1723],r8
8000870e:	0c 97       	mov	r7,r6
80008710:	04 94       	mov	r4,r2
80008712:	06 96       	mov	r6,r3
80008714:	02 92       	mov	r2,r1
80008716:	40 93       	lddsp	r3,sp[0x24]
80008718:	40 41       	lddsp	r1,sp[0x10]
8000871a:	0e 99       	mov	r9,r7
8000871c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008720:	40 3b       	lddsp	r11,sp[0xc]
80008722:	58 0b       	cp.w	r11,0
80008724:	c1 d0       	breq	8000875e <_vfprintf_r+0x1052>
80008726:	10 36       	cp.w	r6,r8
80008728:	c0 64       	brge	80008734 <_vfprintf_r+0x1028>
8000872a:	fa ca f9 44 	sub	r10,sp,-1724
8000872e:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008732:	c1 d8       	rjmp	8000876c <_vfprintf_r+0x1060>
80008734:	fa c8 f9 50 	sub	r8,sp,-1712
80008738:	1a d8       	st.w	--sp,r8
8000873a:	fa c8 fa b8 	sub	r8,sp,-1352
8000873e:	1a d8       	st.w	--sp,r8
80008740:	fa c8 fb b4 	sub	r8,sp,-1100
80008744:	0c 9b       	mov	r11,r6
80008746:	1a d8       	st.w	--sp,r8
80008748:	04 9a       	mov	r10,r2
8000874a:	fa c8 f9 40 	sub	r8,sp,-1728
8000874e:	fa c9 ff b4 	sub	r9,sp,-76
80008752:	08 9c       	mov	r12,r4
80008754:	fe b0 f6 44 	rcall	800073dc <get_arg>
80008758:	2f dd       	sub	sp,-12
8000875a:	78 06       	ld.w	r6,r12[0x0]
8000875c:	c2 08       	rjmp	8000879c <_vfprintf_r+0x1090>
8000875e:	2f f7       	sub	r7,-1
80008760:	10 39       	cp.w	r9,r8
80008762:	c0 84       	brge	80008772 <_vfprintf_r+0x1066>
80008764:	fa c9 f9 44 	sub	r9,sp,-1724
80008768:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000876c:	ec f6 fd 88 	ld.w	r6,r6[-632]
80008770:	c1 68       	rjmp	8000879c <_vfprintf_r+0x1090>
80008772:	41 09       	lddsp	r9,sp[0x40]
80008774:	59 f8       	cp.w	r8,31
80008776:	e0 89 00 10 	brgt	80008796 <_vfprintf_r+0x108a>
8000877a:	f2 ca ff fc 	sub	r10,r9,-4
8000877e:	51 0a       	stdsp	sp[0x40],r10
80008780:	72 06       	ld.w	r6,r9[0x0]
80008782:	fa ce f9 44 	sub	lr,sp,-1724
80008786:	fc 08 00 39 	add	r9,lr,r8<<0x3
8000878a:	f3 46 fd 88 	st.w	r9[-632],r6
8000878e:	2f f8       	sub	r8,-1
80008790:	fb 48 06 b4 	st.w	sp[1716],r8
80008794:	c0 48       	rjmp	8000879c <_vfprintf_r+0x1090>
80008796:	72 06       	ld.w	r6,r9[0x0]
80008798:	2f c9       	sub	r9,-4
8000879a:	51 09       	stdsp	sp[0x40],r9
8000879c:	40 2c       	lddsp	r12,sp[0x8]
8000879e:	58 0c       	cp.w	r12,0
800087a0:	c1 05       	brlt	800087c0 <_vfprintf_r+0x10b4>
800087a2:	18 9a       	mov	r10,r12
800087a4:	30 0b       	mov	r11,0
800087a6:	0c 9c       	mov	r12,r6
800087a8:	e0 a0 12 38 	rcall	8000ac18 <memchr>
800087ac:	e0 80 02 df 	breq	80008d6a <_vfprintf_r+0x165e>
800087b0:	f8 06 01 02 	sub	r2,r12,r6
800087b4:	40 2b       	lddsp	r11,sp[0x8]
800087b6:	16 32       	cp.w	r2,r11
800087b8:	e0 89 02 d9 	brgt	80008d6a <_vfprintf_r+0x165e>
800087bc:	e0 8f 02 d4 	bral	80008d64 <_vfprintf_r+0x1658>
800087c0:	30 0a       	mov	r10,0
800087c2:	0c 9c       	mov	r12,r6
800087c4:	50 2a       	stdsp	sp[0x8],r10
800087c6:	fe b0 f5 85 	rcall	800072d0 <strlen>
800087ca:	18 92       	mov	r2,r12
800087cc:	e0 8f 02 d2 	bral	80008d70 <_vfprintf_r+0x1664>
800087d0:	50 a7       	stdsp	sp[0x28],r7
800087d2:	50 80       	stdsp	sp[0x20],r0
800087d4:	0c 97       	mov	r7,r6
800087d6:	04 94       	mov	r4,r2
800087d8:	06 96       	mov	r6,r3
800087da:	02 92       	mov	r2,r1
800087dc:	40 93       	lddsp	r3,sp[0x24]
800087de:	10 90       	mov	r0,r8
800087e0:	40 41       	lddsp	r1,sp[0x10]
800087e2:	a5 a5       	sbr	r5,0x4
800087e4:	c0 a8       	rjmp	800087f8 <_vfprintf_r+0x10ec>
800087e6:	50 a7       	stdsp	sp[0x28],r7
800087e8:	50 80       	stdsp	sp[0x20],r0
800087ea:	0c 97       	mov	r7,r6
800087ec:	04 94       	mov	r4,r2
800087ee:	06 96       	mov	r6,r3
800087f0:	02 92       	mov	r2,r1
800087f2:	40 93       	lddsp	r3,sp[0x24]
800087f4:	10 90       	mov	r0,r8
800087f6:	40 41       	lddsp	r1,sp[0x10]
800087f8:	ed b5 00 05 	bld	r5,0x5
800087fc:	c5 61       	brne	800088a8 <_vfprintf_r+0x119c>
800087fe:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008802:	40 39       	lddsp	r9,sp[0xc]
80008804:	58 09       	cp.w	r9,0
80008806:	c2 10       	breq	80008848 <_vfprintf_r+0x113c>
80008808:	10 36       	cp.w	r6,r8
8000880a:	c0 74       	brge	80008818 <_vfprintf_r+0x110c>
8000880c:	fa c8 f9 44 	sub	r8,sp,-1724
80008810:	f0 06 00 36 	add	r6,r8,r6<<0x3
80008814:	c2 38       	rjmp	8000885a <_vfprintf_r+0x114e>
80008816:	d7 03       	nop
80008818:	fa c8 f9 50 	sub	r8,sp,-1712
8000881c:	1a d8       	st.w	--sp,r8
8000881e:	fa c8 fa b8 	sub	r8,sp,-1352
80008822:	1a d8       	st.w	--sp,r8
80008824:	fa c8 fb b4 	sub	r8,sp,-1100
80008828:	1a d8       	st.w	--sp,r8
8000882a:	fa c8 f9 40 	sub	r8,sp,-1728
8000882e:	fa c9 ff b4 	sub	r9,sp,-76
80008832:	04 9a       	mov	r10,r2
80008834:	0c 9b       	mov	r11,r6
80008836:	08 9c       	mov	r12,r4
80008838:	fe b0 f5 d2 	rcall	800073dc <get_arg>
8000883c:	2f dd       	sub	sp,-12
8000883e:	f8 e8 00 00 	ld.d	r8,r12[0]
80008842:	fa e9 00 00 	st.d	sp[0],r8
80008846:	c2 e8       	rjmp	800088a2 <_vfprintf_r+0x1196>
80008848:	ee ca ff ff 	sub	r10,r7,-1
8000884c:	10 37       	cp.w	r7,r8
8000884e:	c0 b4       	brge	80008864 <_vfprintf_r+0x1158>
80008850:	fa c8 f9 44 	sub	r8,sp,-1724
80008854:	14 97       	mov	r7,r10
80008856:	f0 06 00 36 	add	r6,r8,r6<<0x3
8000885a:	ec ea fd 88 	ld.d	r10,r6[-632]
8000885e:	fa eb 00 00 	st.d	sp[0],r10
80008862:	c2 08       	rjmp	800088a2 <_vfprintf_r+0x1196>
80008864:	41 09       	lddsp	r9,sp[0x40]
80008866:	59 f8       	cp.w	r8,31
80008868:	e0 89 00 16 	brgt	80008894 <_vfprintf_r+0x1188>
8000886c:	f2 e6 00 00 	ld.d	r6,r9[0]
80008870:	f2 cb ff f8 	sub	r11,r9,-8
80008874:	fa e7 00 00 	st.d	sp[0],r6
80008878:	51 0b       	stdsp	sp[0x40],r11
8000887a:	fa c6 f9 44 	sub	r6,sp,-1724
8000887e:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008882:	fa e6 00 00 	ld.d	r6,sp[0]
80008886:	f2 e7 fd 88 	st.d	r9[-632],r6
8000888a:	2f f8       	sub	r8,-1
8000888c:	14 97       	mov	r7,r10
8000888e:	fb 48 06 b4 	st.w	sp[1716],r8
80008892:	c0 88       	rjmp	800088a2 <_vfprintf_r+0x1196>
80008894:	f2 e6 00 00 	ld.d	r6,r9[0]
80008898:	2f 89       	sub	r9,-8
8000889a:	fa e7 00 00 	st.d	sp[0],r6
8000889e:	51 09       	stdsp	sp[0x40],r9
800088a0:	14 97       	mov	r7,r10
800088a2:	30 18       	mov	r8,1
800088a4:	e0 8f 01 d0 	bral	80008c44 <_vfprintf_r+0x1538>
800088a8:	ed b5 00 04 	bld	r5,0x4
800088ac:	c1 61       	brne	800088d8 <_vfprintf_r+0x11cc>
800088ae:	fa f8 06 b4 	ld.w	r8,sp[1716]
800088b2:	40 3e       	lddsp	lr,sp[0xc]
800088b4:	58 0e       	cp.w	lr,0
800088b6:	c0 80       	breq	800088c6 <_vfprintf_r+0x11ba>
800088b8:	10 36       	cp.w	r6,r8
800088ba:	c6 74       	brge	80008988 <_vfprintf_r+0x127c>
800088bc:	fa cc f9 44 	sub	r12,sp,-1724
800088c0:	f8 06 00 36 	add	r6,r12,r6<<0x3
800088c4:	c8 08       	rjmp	800089c4 <_vfprintf_r+0x12b8>
800088c6:	ee ca ff ff 	sub	r10,r7,-1
800088ca:	10 37       	cp.w	r7,r8
800088cc:	c7 f4       	brge	800089ca <_vfprintf_r+0x12be>
800088ce:	fa cb f9 44 	sub	r11,sp,-1724
800088d2:	f6 06 00 36 	add	r6,r11,r6<<0x3
800088d6:	c7 68       	rjmp	800089c2 <_vfprintf_r+0x12b6>
800088d8:	ed b5 00 06 	bld	r5,0x6
800088dc:	c4 a1       	brne	80008970 <_vfprintf_r+0x1264>
800088de:	fa f8 06 b4 	ld.w	r8,sp[1716]
800088e2:	40 3c       	lddsp	r12,sp[0xc]
800088e4:	58 0c       	cp.w	r12,0
800088e6:	c1 d0       	breq	80008920 <_vfprintf_r+0x1214>
800088e8:	10 36       	cp.w	r6,r8
800088ea:	c0 64       	brge	800088f6 <_vfprintf_r+0x11ea>
800088ec:	fa cb f9 44 	sub	r11,sp,-1724
800088f0:	f6 06 00 36 	add	r6,r11,r6<<0x3
800088f4:	c1 f8       	rjmp	80008932 <_vfprintf_r+0x1226>
800088f6:	fa c8 f9 50 	sub	r8,sp,-1712
800088fa:	1a d8       	st.w	--sp,r8
800088fc:	fa c8 fa b8 	sub	r8,sp,-1352
80008900:	1a d8       	st.w	--sp,r8
80008902:	fa c8 fb b4 	sub	r8,sp,-1100
80008906:	1a d8       	st.w	--sp,r8
80008908:	fa c8 f9 40 	sub	r8,sp,-1728
8000890c:	fa c9 ff b4 	sub	r9,sp,-76
80008910:	04 9a       	mov	r10,r2
80008912:	0c 9b       	mov	r11,r6
80008914:	08 9c       	mov	r12,r4
80008916:	fe b0 f5 63 	rcall	800073dc <get_arg>
8000891a:	2f dd       	sub	sp,-12
8000891c:	98 18       	ld.sh	r8,r12[0x2]
8000891e:	c2 68       	rjmp	8000896a <_vfprintf_r+0x125e>
80008920:	ee ca ff ff 	sub	r10,r7,-1
80008924:	10 37       	cp.w	r7,r8
80008926:	c0 94       	brge	80008938 <_vfprintf_r+0x122c>
80008928:	fa c9 f9 44 	sub	r9,sp,-1724
8000892c:	14 97       	mov	r7,r10
8000892e:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008932:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80008936:	c1 a8       	rjmp	8000896a <_vfprintf_r+0x125e>
80008938:	41 09       	lddsp	r9,sp[0x40]
8000893a:	59 f8       	cp.w	r8,31
8000893c:	e0 89 00 13 	brgt	80008962 <_vfprintf_r+0x1256>
80008940:	f2 cb ff fc 	sub	r11,r9,-4
80008944:	51 0b       	stdsp	sp[0x40],r11
80008946:	72 09       	ld.w	r9,r9[0x0]
80008948:	fa c6 f9 44 	sub	r6,sp,-1724
8000894c:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008950:	2f f8       	sub	r8,-1
80008952:	f7 49 fd 88 	st.w	r11[-632],r9
80008956:	fb 48 06 b4 	st.w	sp[1716],r8
8000895a:	14 97       	mov	r7,r10
8000895c:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008960:	c0 58       	rjmp	8000896a <_vfprintf_r+0x125e>
80008962:	92 18       	ld.sh	r8,r9[0x2]
80008964:	14 97       	mov	r7,r10
80008966:	2f c9       	sub	r9,-4
80008968:	51 09       	stdsp	sp[0x40],r9
8000896a:	5c 78       	castu.h	r8
8000896c:	50 18       	stdsp	sp[0x4],r8
8000896e:	c4 68       	rjmp	800089fa <_vfprintf_r+0x12ee>
80008970:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008974:	40 3c       	lddsp	r12,sp[0xc]
80008976:	58 0c       	cp.w	r12,0
80008978:	c1 d0       	breq	800089b2 <_vfprintf_r+0x12a6>
8000897a:	10 36       	cp.w	r6,r8
8000897c:	c0 64       	brge	80008988 <_vfprintf_r+0x127c>
8000897e:	fa cb f9 44 	sub	r11,sp,-1724
80008982:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008986:	c1 f8       	rjmp	800089c4 <_vfprintf_r+0x12b8>
80008988:	fa c8 f9 50 	sub	r8,sp,-1712
8000898c:	1a d8       	st.w	--sp,r8
8000898e:	fa c8 fa b8 	sub	r8,sp,-1352
80008992:	0c 9b       	mov	r11,r6
80008994:	1a d8       	st.w	--sp,r8
80008996:	fa c8 fb b4 	sub	r8,sp,-1100
8000899a:	04 9a       	mov	r10,r2
8000899c:	1a d8       	st.w	--sp,r8
8000899e:	08 9c       	mov	r12,r4
800089a0:	fa c8 f9 40 	sub	r8,sp,-1728
800089a4:	fa c9 ff b4 	sub	r9,sp,-76
800089a8:	fe b0 f5 1a 	rcall	800073dc <get_arg>
800089ac:	2f dd       	sub	sp,-12
800089ae:	78 0b       	ld.w	r11,r12[0x0]
800089b0:	c2 48       	rjmp	800089f8 <_vfprintf_r+0x12ec>
800089b2:	ee ca ff ff 	sub	r10,r7,-1
800089b6:	10 37       	cp.w	r7,r8
800089b8:	c0 94       	brge	800089ca <_vfprintf_r+0x12be>
800089ba:	fa c9 f9 44 	sub	r9,sp,-1724
800089be:	f2 06 00 36 	add	r6,r9,r6<<0x3
800089c2:	14 97       	mov	r7,r10
800089c4:	ec fb fd 88 	ld.w	r11,r6[-632]
800089c8:	c1 88       	rjmp	800089f8 <_vfprintf_r+0x12ec>
800089ca:	41 09       	lddsp	r9,sp[0x40]
800089cc:	59 f8       	cp.w	r8,31
800089ce:	e0 89 00 11 	brgt	800089f0 <_vfprintf_r+0x12e4>
800089d2:	f2 cb ff fc 	sub	r11,r9,-4
800089d6:	51 0b       	stdsp	sp[0x40],r11
800089d8:	fa c6 f9 44 	sub	r6,sp,-1724
800089dc:	72 0b       	ld.w	r11,r9[0x0]
800089de:	ec 08 00 39 	add	r9,r6,r8<<0x3
800089e2:	f3 4b fd 88 	st.w	r9[-632],r11
800089e6:	2f f8       	sub	r8,-1
800089e8:	14 97       	mov	r7,r10
800089ea:	fb 48 06 b4 	st.w	sp[1716],r8
800089ee:	c0 58       	rjmp	800089f8 <_vfprintf_r+0x12ec>
800089f0:	72 0b       	ld.w	r11,r9[0x0]
800089f2:	14 97       	mov	r7,r10
800089f4:	2f c9       	sub	r9,-4
800089f6:	51 09       	stdsp	sp[0x40],r9
800089f8:	50 1b       	stdsp	sp[0x4],r11
800089fa:	30 0e       	mov	lr,0
800089fc:	30 18       	mov	r8,1
800089fe:	50 0e       	stdsp	sp[0x0],lr
80008a00:	c2 29       	rjmp	80008c44 <_vfprintf_r+0x1538>
80008a02:	50 a7       	stdsp	sp[0x28],r7
80008a04:	50 80       	stdsp	sp[0x20],r0
80008a06:	0c 97       	mov	r7,r6
80008a08:	04 94       	mov	r4,r2
80008a0a:	06 96       	mov	r6,r3
80008a0c:	02 92       	mov	r2,r1
80008a0e:	fe cc af 96 	sub	r12,pc,-20586
80008a12:	40 93       	lddsp	r3,sp[0x24]
80008a14:	10 90       	mov	r0,r8
80008a16:	40 41       	lddsp	r1,sp[0x10]
80008a18:	50 dc       	stdsp	sp[0x34],r12
80008a1a:	ed b5 00 05 	bld	r5,0x5
80008a1e:	c5 51       	brne	80008ac8 <_vfprintf_r+0x13bc>
80008a20:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008a24:	40 3b       	lddsp	r11,sp[0xc]
80008a26:	58 0b       	cp.w	r11,0
80008a28:	c2 20       	breq	80008a6c <_vfprintf_r+0x1360>
80008a2a:	10 36       	cp.w	r6,r8
80008a2c:	c0 a4       	brge	80008a40 <_vfprintf_r+0x1334>
80008a2e:	fa ca f9 44 	sub	r10,sp,-1724
80008a32:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008a36:	ec e8 fd 88 	ld.d	r8,r6[-632]
80008a3a:	fa e9 00 00 	st.d	sp[0],r8
80008a3e:	cf 28       	rjmp	80008c22 <_vfprintf_r+0x1516>
80008a40:	fa c8 f9 50 	sub	r8,sp,-1712
80008a44:	1a d8       	st.w	--sp,r8
80008a46:	fa c8 fa b8 	sub	r8,sp,-1352
80008a4a:	04 9a       	mov	r10,r2
80008a4c:	1a d8       	st.w	--sp,r8
80008a4e:	0c 9b       	mov	r11,r6
80008a50:	fa c8 fb b4 	sub	r8,sp,-1100
80008a54:	08 9c       	mov	r12,r4
80008a56:	1a d8       	st.w	--sp,r8
80008a58:	fa c8 f9 40 	sub	r8,sp,-1728
80008a5c:	fa c9 ff b4 	sub	r9,sp,-76
80008a60:	fe b0 f4 be 	rcall	800073dc <get_arg>
80008a64:	2f dd       	sub	sp,-12
80008a66:	f8 ea 00 00 	ld.d	r10,r12[0]
80008a6a:	c0 c8       	rjmp	80008a82 <_vfprintf_r+0x1376>
80008a6c:	ee ca ff ff 	sub	r10,r7,-1
80008a70:	10 37       	cp.w	r7,r8
80008a72:	c0 b4       	brge	80008a88 <_vfprintf_r+0x137c>
80008a74:	fa c9 f9 44 	sub	r9,sp,-1724
80008a78:	14 97       	mov	r7,r10
80008a7a:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008a7e:	ec ea fd 88 	ld.d	r10,r6[-632]
80008a82:	fa eb 00 00 	st.d	sp[0],r10
80008a86:	cc e8       	rjmp	80008c22 <_vfprintf_r+0x1516>
80008a88:	41 09       	lddsp	r9,sp[0x40]
80008a8a:	59 f8       	cp.w	r8,31
80008a8c:	e0 89 00 16 	brgt	80008ab8 <_vfprintf_r+0x13ac>
80008a90:	f2 e6 00 00 	ld.d	r6,r9[0]
80008a94:	f2 cb ff f8 	sub	r11,r9,-8
80008a98:	fa e7 00 00 	st.d	sp[0],r6
80008a9c:	51 0b       	stdsp	sp[0x40],r11
80008a9e:	fa c6 f9 44 	sub	r6,sp,-1724
80008aa2:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008aa6:	fa e6 00 00 	ld.d	r6,sp[0]
80008aaa:	f2 e7 fd 88 	st.d	r9[-632],r6
80008aae:	2f f8       	sub	r8,-1
80008ab0:	14 97       	mov	r7,r10
80008ab2:	fb 48 06 b4 	st.w	sp[1716],r8
80008ab6:	cb 68       	rjmp	80008c22 <_vfprintf_r+0x1516>
80008ab8:	f2 e6 00 00 	ld.d	r6,r9[0]
80008abc:	2f 89       	sub	r9,-8
80008abe:	fa e7 00 00 	st.d	sp[0],r6
80008ac2:	51 09       	stdsp	sp[0x40],r9
80008ac4:	14 97       	mov	r7,r10
80008ac6:	ca e8       	rjmp	80008c22 <_vfprintf_r+0x1516>
80008ac8:	ed b5 00 04 	bld	r5,0x4
80008acc:	c1 71       	brne	80008afa <_vfprintf_r+0x13ee>
80008ace:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008ad2:	40 3e       	lddsp	lr,sp[0xc]
80008ad4:	58 0e       	cp.w	lr,0
80008ad6:	c0 80       	breq	80008ae6 <_vfprintf_r+0x13da>
80008ad8:	10 36       	cp.w	r6,r8
80008ada:	c6 94       	brge	80008bac <_vfprintf_r+0x14a0>
80008adc:	fa cc f9 44 	sub	r12,sp,-1724
80008ae0:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008ae4:	c8 28       	rjmp	80008be8 <_vfprintf_r+0x14dc>
80008ae6:	ee ca ff ff 	sub	r10,r7,-1
80008aea:	10 37       	cp.w	r7,r8
80008aec:	e0 84 00 81 	brge	80008bee <_vfprintf_r+0x14e2>
80008af0:	fa cb f9 44 	sub	r11,sp,-1724
80008af4:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008af8:	c7 78       	rjmp	80008be6 <_vfprintf_r+0x14da>
80008afa:	ed b5 00 06 	bld	r5,0x6
80008afe:	c4 b1       	brne	80008b94 <_vfprintf_r+0x1488>
80008b00:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008b04:	40 3c       	lddsp	r12,sp[0xc]
80008b06:	58 0c       	cp.w	r12,0
80008b08:	c1 d0       	breq	80008b42 <_vfprintf_r+0x1436>
80008b0a:	10 36       	cp.w	r6,r8
80008b0c:	c0 64       	brge	80008b18 <_vfprintf_r+0x140c>
80008b0e:	fa cb f9 44 	sub	r11,sp,-1724
80008b12:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008b16:	c1 f8       	rjmp	80008b54 <_vfprintf_r+0x1448>
80008b18:	fa c8 f9 50 	sub	r8,sp,-1712
80008b1c:	1a d8       	st.w	--sp,r8
80008b1e:	fa c8 fa b8 	sub	r8,sp,-1352
80008b22:	1a d8       	st.w	--sp,r8
80008b24:	fa c8 fb b4 	sub	r8,sp,-1100
80008b28:	1a d8       	st.w	--sp,r8
80008b2a:	fa c8 f9 40 	sub	r8,sp,-1728
80008b2e:	fa c9 ff b4 	sub	r9,sp,-76
80008b32:	04 9a       	mov	r10,r2
80008b34:	0c 9b       	mov	r11,r6
80008b36:	08 9c       	mov	r12,r4
80008b38:	fe b0 f4 52 	rcall	800073dc <get_arg>
80008b3c:	2f dd       	sub	sp,-12
80008b3e:	98 18       	ld.sh	r8,r12[0x2]
80008b40:	c2 78       	rjmp	80008b8e <_vfprintf_r+0x1482>
80008b42:	ee ca ff ff 	sub	r10,r7,-1
80008b46:	10 37       	cp.w	r7,r8
80008b48:	c0 a4       	brge	80008b5c <_vfprintf_r+0x1450>
80008b4a:	fa c9 f9 44 	sub	r9,sp,-1724
80008b4e:	14 97       	mov	r7,r10
80008b50:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008b54:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80008b58:	c1 b8       	rjmp	80008b8e <_vfprintf_r+0x1482>
80008b5a:	d7 03       	nop
80008b5c:	41 09       	lddsp	r9,sp[0x40]
80008b5e:	59 f8       	cp.w	r8,31
80008b60:	e0 89 00 13 	brgt	80008b86 <_vfprintf_r+0x147a>
80008b64:	f2 cb ff fc 	sub	r11,r9,-4
80008b68:	51 0b       	stdsp	sp[0x40],r11
80008b6a:	72 09       	ld.w	r9,r9[0x0]
80008b6c:	fa c6 f9 44 	sub	r6,sp,-1724
80008b70:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008b74:	2f f8       	sub	r8,-1
80008b76:	f7 49 fd 88 	st.w	r11[-632],r9
80008b7a:	fb 48 06 b4 	st.w	sp[1716],r8
80008b7e:	14 97       	mov	r7,r10
80008b80:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008b84:	c0 58       	rjmp	80008b8e <_vfprintf_r+0x1482>
80008b86:	92 18       	ld.sh	r8,r9[0x2]
80008b88:	14 97       	mov	r7,r10
80008b8a:	2f c9       	sub	r9,-4
80008b8c:	51 09       	stdsp	sp[0x40],r9
80008b8e:	5c 78       	castu.h	r8
80008b90:	50 18       	stdsp	sp[0x4],r8
80008b92:	c4 68       	rjmp	80008c1e <_vfprintf_r+0x1512>
80008b94:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008b98:	40 3c       	lddsp	r12,sp[0xc]
80008b9a:	58 0c       	cp.w	r12,0
80008b9c:	c1 d0       	breq	80008bd6 <_vfprintf_r+0x14ca>
80008b9e:	10 36       	cp.w	r6,r8
80008ba0:	c0 64       	brge	80008bac <_vfprintf_r+0x14a0>
80008ba2:	fa cb f9 44 	sub	r11,sp,-1724
80008ba6:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008baa:	c1 f8       	rjmp	80008be8 <_vfprintf_r+0x14dc>
80008bac:	fa c8 f9 50 	sub	r8,sp,-1712
80008bb0:	1a d8       	st.w	--sp,r8
80008bb2:	fa c8 fa b8 	sub	r8,sp,-1352
80008bb6:	0c 9b       	mov	r11,r6
80008bb8:	1a d8       	st.w	--sp,r8
80008bba:	fa c8 fb b4 	sub	r8,sp,-1100
80008bbe:	04 9a       	mov	r10,r2
80008bc0:	1a d8       	st.w	--sp,r8
80008bc2:	08 9c       	mov	r12,r4
80008bc4:	fa c8 f9 40 	sub	r8,sp,-1728
80008bc8:	fa c9 ff b4 	sub	r9,sp,-76
80008bcc:	fe b0 f4 08 	rcall	800073dc <get_arg>
80008bd0:	2f dd       	sub	sp,-12
80008bd2:	78 0b       	ld.w	r11,r12[0x0]
80008bd4:	c2 48       	rjmp	80008c1c <_vfprintf_r+0x1510>
80008bd6:	ee ca ff ff 	sub	r10,r7,-1
80008bda:	10 37       	cp.w	r7,r8
80008bdc:	c0 94       	brge	80008bee <_vfprintf_r+0x14e2>
80008bde:	fa c9 f9 44 	sub	r9,sp,-1724
80008be2:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008be6:	14 97       	mov	r7,r10
80008be8:	ec fb fd 88 	ld.w	r11,r6[-632]
80008bec:	c1 88       	rjmp	80008c1c <_vfprintf_r+0x1510>
80008bee:	41 09       	lddsp	r9,sp[0x40]
80008bf0:	59 f8       	cp.w	r8,31
80008bf2:	e0 89 00 11 	brgt	80008c14 <_vfprintf_r+0x1508>
80008bf6:	f2 cb ff fc 	sub	r11,r9,-4
80008bfa:	51 0b       	stdsp	sp[0x40],r11
80008bfc:	fa c6 f9 44 	sub	r6,sp,-1724
80008c00:	72 0b       	ld.w	r11,r9[0x0]
80008c02:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008c06:	f3 4b fd 88 	st.w	r9[-632],r11
80008c0a:	2f f8       	sub	r8,-1
80008c0c:	14 97       	mov	r7,r10
80008c0e:	fb 48 06 b4 	st.w	sp[1716],r8
80008c12:	c0 58       	rjmp	80008c1c <_vfprintf_r+0x1510>
80008c14:	72 0b       	ld.w	r11,r9[0x0]
80008c16:	14 97       	mov	r7,r10
80008c18:	2f c9       	sub	r9,-4
80008c1a:	51 09       	stdsp	sp[0x40],r9
80008c1c:	50 1b       	stdsp	sp[0x4],r11
80008c1e:	30 0e       	mov	lr,0
80008c20:	50 0e       	stdsp	sp[0x0],lr
80008c22:	40 08       	lddsp	r8,sp[0x0]
80008c24:	40 1c       	lddsp	r12,sp[0x4]
80008c26:	18 48       	or	r8,r12
80008c28:	5f 19       	srne	r9
80008c2a:	0a 98       	mov	r8,r5
80008c2c:	eb e9 00 09 	and	r9,r5,r9
80008c30:	a1 b8       	sbr	r8,0x1
80008c32:	58 09       	cp.w	r9,0
80008c34:	c0 70       	breq	80008c42 <_vfprintf_r+0x1536>
80008c36:	10 95       	mov	r5,r8
80008c38:	fb 60 06 b9 	st.b	sp[1721],r0
80008c3c:	33 08       	mov	r8,48
80008c3e:	fb 68 06 b8 	st.b	sp[1720],r8
80008c42:	30 28       	mov	r8,2
80008c44:	30 09       	mov	r9,0
80008c46:	fb 69 06 bb 	st.b	sp[1723],r9
80008c4a:	0a 99       	mov	r9,r5
80008c4c:	a7 d9       	cbr	r9,0x7
80008c4e:	40 2b       	lddsp	r11,sp[0x8]
80008c50:	40 16       	lddsp	r6,sp[0x4]
80008c52:	58 0b       	cp.w	r11,0
80008c54:	5f 1a       	srne	r10
80008c56:	f2 05 17 40 	movge	r5,r9
80008c5a:	fa c2 f9 78 	sub	r2,sp,-1672
80008c5e:	40 09       	lddsp	r9,sp[0x0]
80008c60:	0c 49       	or	r9,r6
80008c62:	5f 19       	srne	r9
80008c64:	f5 e9 10 09 	or	r9,r10,r9
80008c68:	c5 c0       	breq	80008d20 <_vfprintf_r+0x1614>
80008c6a:	30 19       	mov	r9,1
80008c6c:	f2 08 18 00 	cp.b	r8,r9
80008c70:	c0 60       	breq	80008c7c <_vfprintf_r+0x1570>
80008c72:	30 29       	mov	r9,2
80008c74:	f2 08 18 00 	cp.b	r8,r9
80008c78:	c0 41       	brne	80008c80 <_vfprintf_r+0x1574>
80008c7a:	c3 c8       	rjmp	80008cf2 <_vfprintf_r+0x15e6>
80008c7c:	04 96       	mov	r6,r2
80008c7e:	c3 08       	rjmp	80008cde <_vfprintf_r+0x15d2>
80008c80:	04 96       	mov	r6,r2
80008c82:	fa e8 00 00 	ld.d	r8,sp[0]
80008c86:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
80008c8a:	2d 0a       	sub	r10,-48
80008c8c:	0c fa       	st.b	--r6,r10
80008c8e:	f0 0b 16 03 	lsr	r11,r8,0x3
80008c92:	f2 0c 16 03 	lsr	r12,r9,0x3
80008c96:	f7 e9 11 db 	or	r11,r11,r9<<0x1d
80008c9a:	18 99       	mov	r9,r12
80008c9c:	16 98       	mov	r8,r11
80008c9e:	58 08       	cp.w	r8,0
80008ca0:	5c 29       	cpc	r9
80008ca2:	cf 21       	brne	80008c86 <_vfprintf_r+0x157a>
80008ca4:	fa e9 00 00 	st.d	sp[0],r8
80008ca8:	ed b5 00 00 	bld	r5,0x0
80008cac:	c4 51       	brne	80008d36 <_vfprintf_r+0x162a>
80008cae:	33 09       	mov	r9,48
80008cb0:	f2 0a 18 00 	cp.b	r10,r9
80008cb4:	c4 10       	breq	80008d36 <_vfprintf_r+0x162a>
80008cb6:	0c f9       	st.b	--r6,r9
80008cb8:	c3 f8       	rjmp	80008d36 <_vfprintf_r+0x162a>
80008cba:	fa ea 00 00 	ld.d	r10,sp[0]
80008cbe:	30 a8       	mov	r8,10
80008cc0:	30 09       	mov	r9,0
80008cc2:	e0 a0 1a 0d 	rcall	8000c0dc <__avr32_umod64>
80008cc6:	30 a8       	mov	r8,10
80008cc8:	2d 0a       	sub	r10,-48
80008cca:	30 09       	mov	r9,0
80008ccc:	ac 8a       	st.b	r6[0x0],r10
80008cce:	fa ea 00 00 	ld.d	r10,sp[0]
80008cd2:	e0 a0 18 d3 	rcall	8000be78 <__avr32_udiv64>
80008cd6:	16 99       	mov	r9,r11
80008cd8:	14 98       	mov	r8,r10
80008cda:	fa e9 00 00 	st.d	sp[0],r8
80008cde:	20 16       	sub	r6,1
80008ce0:	fa ea 00 00 	ld.d	r10,sp[0]
80008ce4:	58 9a       	cp.w	r10,9
80008ce6:	5c 2b       	cpc	r11
80008ce8:	fe 9b ff e9 	brhi	80008cba <_vfprintf_r+0x15ae>
80008cec:	1b f8       	ld.ub	r8,sp[0x7]
80008cee:	2d 08       	sub	r8,-48
80008cf0:	c2 08       	rjmp	80008d30 <_vfprintf_r+0x1624>
80008cf2:	04 96       	mov	r6,r2
80008cf4:	fa e8 00 00 	ld.d	r8,sp[0]
80008cf8:	f5 d8 c0 04 	bfextu	r10,r8,0x0,0x4
80008cfc:	40 de       	lddsp	lr,sp[0x34]
80008cfe:	fc 0a 07 0a 	ld.ub	r10,lr[r10]
80008d02:	0c fa       	st.b	--r6,r10
80008d04:	f2 0b 16 04 	lsr	r11,r9,0x4
80008d08:	f0 0a 16 04 	lsr	r10,r8,0x4
80008d0c:	f5 e9 11 ca 	or	r10,r10,r9<<0x1c
80008d10:	16 99       	mov	r9,r11
80008d12:	14 98       	mov	r8,r10
80008d14:	58 08       	cp.w	r8,0
80008d16:	5c 29       	cpc	r9
80008d18:	cf 01       	brne	80008cf8 <_vfprintf_r+0x15ec>
80008d1a:	fa e9 00 00 	st.d	sp[0],r8
80008d1e:	c0 c8       	rjmp	80008d36 <_vfprintf_r+0x162a>
80008d20:	58 08       	cp.w	r8,0
80008d22:	c0 91       	brne	80008d34 <_vfprintf_r+0x1628>
80008d24:	ed b5 00 00 	bld	r5,0x0
80008d28:	c0 61       	brne	80008d34 <_vfprintf_r+0x1628>
80008d2a:	fa c6 f9 79 	sub	r6,sp,-1671
80008d2e:	33 08       	mov	r8,48
80008d30:	ac 88       	st.b	r6[0x0],r8
80008d32:	c0 28       	rjmp	80008d36 <_vfprintf_r+0x162a>
80008d34:	04 96       	mov	r6,r2
80008d36:	0c 12       	sub	r2,r6
80008d38:	c1 c8       	rjmp	80008d70 <_vfprintf_r+0x1664>
80008d3a:	50 a7       	stdsp	sp[0x28],r7
80008d3c:	50 80       	stdsp	sp[0x20],r0
80008d3e:	40 93       	lddsp	r3,sp[0x24]
80008d40:	0c 97       	mov	r7,r6
80008d42:	10 90       	mov	r0,r8
80008d44:	04 94       	mov	r4,r2
80008d46:	40 41       	lddsp	r1,sp[0x10]
80008d48:	58 08       	cp.w	r8,0
80008d4a:	e0 80 04 4f 	breq	800095e8 <_vfprintf_r+0x1edc>
80008d4e:	fb 68 06 60 	st.b	sp[1632],r8
80008d52:	30 0c       	mov	r12,0
80008d54:	30 08       	mov	r8,0
80008d56:	30 12       	mov	r2,1
80008d58:	fb 68 06 bb 	st.b	sp[1723],r8
80008d5c:	50 2c       	stdsp	sp[0x8],r12
80008d5e:	fa c6 f9 a0 	sub	r6,sp,-1632
80008d62:	c0 78       	rjmp	80008d70 <_vfprintf_r+0x1664>
80008d64:	30 0b       	mov	r11,0
80008d66:	50 2b       	stdsp	sp[0x8],r11
80008d68:	c0 48       	rjmp	80008d70 <_vfprintf_r+0x1664>
80008d6a:	40 22       	lddsp	r2,sp[0x8]
80008d6c:	30 0a       	mov	r10,0
80008d6e:	50 2a       	stdsp	sp[0x8],r10
80008d70:	40 29       	lddsp	r9,sp[0x8]
80008d72:	e4 09 0c 49 	max	r9,r2,r9
80008d76:	fb 38 06 bb 	ld.ub	r8,sp[1723]
80008d7a:	50 39       	stdsp	sp[0xc],r9
80008d7c:	0a 9e       	mov	lr,r5
80008d7e:	30 09       	mov	r9,0
80008d80:	e2 1e 00 02 	andl	lr,0x2,COH
80008d84:	f2 08 18 00 	cp.b	r8,r9
80008d88:	fb f8 10 03 	ld.wne	r8,sp[0xc]
80008d8c:	f7 b8 01 ff 	subne	r8,-1
80008d90:	fb f8 1a 03 	st.wne	sp[0xc],r8
80008d94:	0a 9b       	mov	r11,r5
80008d96:	58 0e       	cp.w	lr,0
80008d98:	fb fc 10 03 	ld.wne	r12,sp[0xc]
80008d9c:	f7 bc 01 fe 	subne	r12,-2
80008da0:	fb fc 1a 03 	st.wne	sp[0xc],r12
80008da4:	e2 1b 00 84 	andl	r11,0x84,COH
80008da8:	50 fe       	stdsp	sp[0x3c],lr
80008daa:	50 9b       	stdsp	sp[0x24],r11
80008dac:	c4 71       	brne	80008e3a <_vfprintf_r+0x172e>
80008dae:	40 8a       	lddsp	r10,sp[0x20]
80008db0:	40 39       	lddsp	r9,sp[0xc]
80008db2:	12 1a       	sub	r10,r9
80008db4:	50 4a       	stdsp	sp[0x10],r10
80008db6:	58 0a       	cp.w	r10,0
80008db8:	e0 89 00 20 	brgt	80008df8 <_vfprintf_r+0x16ec>
80008dbc:	c3 f8       	rjmp	80008e3a <_vfprintf_r+0x172e>
80008dbe:	2f 09       	sub	r9,-16
80008dc0:	2f f8       	sub	r8,-1
80008dc2:	fe ce b3 32 	sub	lr,pc,-19662
80008dc6:	31 0c       	mov	r12,16
80008dc8:	fb 49 06 90 	st.w	sp[1680],r9
80008dcc:	87 0e       	st.w	r3[0x0],lr
80008dce:	87 1c       	st.w	r3[0x4],r12
80008dd0:	fb 48 06 8c 	st.w	sp[1676],r8
80008dd4:	58 78       	cp.w	r8,7
80008dd6:	e0 89 00 04 	brgt	80008dde <_vfprintf_r+0x16d2>
80008dda:	2f 83       	sub	r3,-8
80008ddc:	c0 b8       	rjmp	80008df2 <_vfprintf_r+0x16e6>
80008dde:	fa ca f9 78 	sub	r10,sp,-1672
80008de2:	02 9b       	mov	r11,r1
80008de4:	08 9c       	mov	r12,r4
80008de6:	fe b0 f4 85 	rcall	800076f0 <__sprint_r>
80008dea:	e0 81 04 10 	brne	8000960a <_vfprintf_r+0x1efe>
80008dee:	fa c3 f9 e0 	sub	r3,sp,-1568
80008df2:	40 4b       	lddsp	r11,sp[0x10]
80008df4:	21 0b       	sub	r11,16
80008df6:	50 4b       	stdsp	sp[0x10],r11
80008df8:	fa f9 06 90 	ld.w	r9,sp[1680]
80008dfc:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008e00:	fe ca b3 70 	sub	r10,pc,-19600
80008e04:	40 4e       	lddsp	lr,sp[0x10]
80008e06:	59 0e       	cp.w	lr,16
80008e08:	fe 99 ff db 	brgt	80008dbe <_vfprintf_r+0x16b2>
80008e0c:	1c 09       	add	r9,lr
80008e0e:	2f f8       	sub	r8,-1
80008e10:	87 0a       	st.w	r3[0x0],r10
80008e12:	fb 49 06 90 	st.w	sp[1680],r9
80008e16:	87 1e       	st.w	r3[0x4],lr
80008e18:	fb 48 06 8c 	st.w	sp[1676],r8
80008e1c:	58 78       	cp.w	r8,7
80008e1e:	e0 89 00 04 	brgt	80008e26 <_vfprintf_r+0x171a>
80008e22:	2f 83       	sub	r3,-8
80008e24:	c0 b8       	rjmp	80008e3a <_vfprintf_r+0x172e>
80008e26:	fa ca f9 78 	sub	r10,sp,-1672
80008e2a:	02 9b       	mov	r11,r1
80008e2c:	08 9c       	mov	r12,r4
80008e2e:	fe b0 f4 61 	rcall	800076f0 <__sprint_r>
80008e32:	e0 81 03 ec 	brne	8000960a <_vfprintf_r+0x1efe>
80008e36:	fa c3 f9 e0 	sub	r3,sp,-1568
80008e3a:	30 09       	mov	r9,0
80008e3c:	fb 38 06 bb 	ld.ub	r8,sp[1723]
80008e40:	f2 08 18 00 	cp.b	r8,r9
80008e44:	c1 f0       	breq	80008e82 <_vfprintf_r+0x1776>
80008e46:	fa f8 06 90 	ld.w	r8,sp[1680]
80008e4a:	fa c9 f9 45 	sub	r9,sp,-1723
80008e4e:	2f f8       	sub	r8,-1
80008e50:	87 09       	st.w	r3[0x0],r9
80008e52:	fb 48 06 90 	st.w	sp[1680],r8
80008e56:	30 19       	mov	r9,1
80008e58:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008e5c:	87 19       	st.w	r3[0x4],r9
80008e5e:	2f f8       	sub	r8,-1
80008e60:	fb 48 06 8c 	st.w	sp[1676],r8
80008e64:	58 78       	cp.w	r8,7
80008e66:	e0 89 00 04 	brgt	80008e6e <_vfprintf_r+0x1762>
80008e6a:	2f 83       	sub	r3,-8
80008e6c:	c0 b8       	rjmp	80008e82 <_vfprintf_r+0x1776>
80008e6e:	fa ca f9 78 	sub	r10,sp,-1672
80008e72:	02 9b       	mov	r11,r1
80008e74:	08 9c       	mov	r12,r4
80008e76:	fe b0 f4 3d 	rcall	800076f0 <__sprint_r>
80008e7a:	e0 81 03 c8 	brne	8000960a <_vfprintf_r+0x1efe>
80008e7e:	fa c3 f9 e0 	sub	r3,sp,-1568
80008e82:	40 fc       	lddsp	r12,sp[0x3c]
80008e84:	58 0c       	cp.w	r12,0
80008e86:	c1 f0       	breq	80008ec4 <_vfprintf_r+0x17b8>
80008e88:	fa f8 06 90 	ld.w	r8,sp[1680]
80008e8c:	fa c9 f9 48 	sub	r9,sp,-1720
80008e90:	2f e8       	sub	r8,-2
80008e92:	87 09       	st.w	r3[0x0],r9
80008e94:	fb 48 06 90 	st.w	sp[1680],r8
80008e98:	30 29       	mov	r9,2
80008e9a:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008e9e:	87 19       	st.w	r3[0x4],r9
80008ea0:	2f f8       	sub	r8,-1
80008ea2:	fb 48 06 8c 	st.w	sp[1676],r8
80008ea6:	58 78       	cp.w	r8,7
80008ea8:	e0 89 00 04 	brgt	80008eb0 <_vfprintf_r+0x17a4>
80008eac:	2f 83       	sub	r3,-8
80008eae:	c0 b8       	rjmp	80008ec4 <_vfprintf_r+0x17b8>
80008eb0:	fa ca f9 78 	sub	r10,sp,-1672
80008eb4:	02 9b       	mov	r11,r1
80008eb6:	08 9c       	mov	r12,r4
80008eb8:	fe b0 f4 1c 	rcall	800076f0 <__sprint_r>
80008ebc:	e0 81 03 a7 	brne	8000960a <_vfprintf_r+0x1efe>
80008ec0:	fa c3 f9 e0 	sub	r3,sp,-1568
80008ec4:	40 9b       	lddsp	r11,sp[0x24]
80008ec6:	e0 4b 00 80 	cp.w	r11,128
80008eca:	c4 71       	brne	80008f58 <_vfprintf_r+0x184c>
80008ecc:	40 8a       	lddsp	r10,sp[0x20]
80008ece:	40 39       	lddsp	r9,sp[0xc]
80008ed0:	12 1a       	sub	r10,r9
80008ed2:	50 4a       	stdsp	sp[0x10],r10
80008ed4:	58 0a       	cp.w	r10,0
80008ed6:	e0 89 00 20 	brgt	80008f16 <_vfprintf_r+0x180a>
80008eda:	c3 f8       	rjmp	80008f58 <_vfprintf_r+0x184c>
80008edc:	2f 09       	sub	r9,-16
80008ede:	2f f8       	sub	r8,-1
80008ee0:	fe ce b4 40 	sub	lr,pc,-19392
80008ee4:	31 0c       	mov	r12,16
80008ee6:	fb 49 06 90 	st.w	sp[1680],r9
80008eea:	87 0e       	st.w	r3[0x0],lr
80008eec:	87 1c       	st.w	r3[0x4],r12
80008eee:	fb 48 06 8c 	st.w	sp[1676],r8
80008ef2:	58 78       	cp.w	r8,7
80008ef4:	e0 89 00 04 	brgt	80008efc <_vfprintf_r+0x17f0>
80008ef8:	2f 83       	sub	r3,-8
80008efa:	c0 b8       	rjmp	80008f10 <_vfprintf_r+0x1804>
80008efc:	fa ca f9 78 	sub	r10,sp,-1672
80008f00:	02 9b       	mov	r11,r1
80008f02:	08 9c       	mov	r12,r4
80008f04:	fe b0 f3 f6 	rcall	800076f0 <__sprint_r>
80008f08:	e0 81 03 81 	brne	8000960a <_vfprintf_r+0x1efe>
80008f0c:	fa c3 f9 e0 	sub	r3,sp,-1568
80008f10:	40 4b       	lddsp	r11,sp[0x10]
80008f12:	21 0b       	sub	r11,16
80008f14:	50 4b       	stdsp	sp[0x10],r11
80008f16:	fa f9 06 90 	ld.w	r9,sp[1680]
80008f1a:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008f1e:	fe ca b4 7e 	sub	r10,pc,-19330
80008f22:	40 4e       	lddsp	lr,sp[0x10]
80008f24:	59 0e       	cp.w	lr,16
80008f26:	fe 99 ff db 	brgt	80008edc <_vfprintf_r+0x17d0>
80008f2a:	1c 09       	add	r9,lr
80008f2c:	2f f8       	sub	r8,-1
80008f2e:	87 0a       	st.w	r3[0x0],r10
80008f30:	fb 49 06 90 	st.w	sp[1680],r9
80008f34:	87 1e       	st.w	r3[0x4],lr
80008f36:	fb 48 06 8c 	st.w	sp[1676],r8
80008f3a:	58 78       	cp.w	r8,7
80008f3c:	e0 89 00 04 	brgt	80008f44 <_vfprintf_r+0x1838>
80008f40:	2f 83       	sub	r3,-8
80008f42:	c0 b8       	rjmp	80008f58 <_vfprintf_r+0x184c>
80008f44:	fa ca f9 78 	sub	r10,sp,-1672
80008f48:	02 9b       	mov	r11,r1
80008f4a:	08 9c       	mov	r12,r4
80008f4c:	fe b0 f3 d2 	rcall	800076f0 <__sprint_r>
80008f50:	e0 81 03 5d 	brne	8000960a <_vfprintf_r+0x1efe>
80008f54:	fa c3 f9 e0 	sub	r3,sp,-1568
80008f58:	40 2c       	lddsp	r12,sp[0x8]
80008f5a:	04 1c       	sub	r12,r2
80008f5c:	50 2c       	stdsp	sp[0x8],r12
80008f5e:	58 0c       	cp.w	r12,0
80008f60:	e0 89 00 20 	brgt	80008fa0 <_vfprintf_r+0x1894>
80008f64:	c3 f8       	rjmp	80008fe2 <_vfprintf_r+0x18d6>
80008f66:	2f 09       	sub	r9,-16
80008f68:	2f f8       	sub	r8,-1
80008f6a:	fe cb b4 ca 	sub	r11,pc,-19254
80008f6e:	31 0a       	mov	r10,16
80008f70:	fb 49 06 90 	st.w	sp[1680],r9
80008f74:	87 0b       	st.w	r3[0x0],r11
80008f76:	87 1a       	st.w	r3[0x4],r10
80008f78:	fb 48 06 8c 	st.w	sp[1676],r8
80008f7c:	58 78       	cp.w	r8,7
80008f7e:	e0 89 00 04 	brgt	80008f86 <_vfprintf_r+0x187a>
80008f82:	2f 83       	sub	r3,-8
80008f84:	c0 b8       	rjmp	80008f9a <_vfprintf_r+0x188e>
80008f86:	fa ca f9 78 	sub	r10,sp,-1672
80008f8a:	02 9b       	mov	r11,r1
80008f8c:	08 9c       	mov	r12,r4
80008f8e:	fe b0 f3 b1 	rcall	800076f0 <__sprint_r>
80008f92:	e0 81 03 3c 	brne	8000960a <_vfprintf_r+0x1efe>
80008f96:	fa c3 f9 e0 	sub	r3,sp,-1568
80008f9a:	40 29       	lddsp	r9,sp[0x8]
80008f9c:	21 09       	sub	r9,16
80008f9e:	50 29       	stdsp	sp[0x8],r9
80008fa0:	fa f9 06 90 	ld.w	r9,sp[1680]
80008fa4:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008fa8:	fe ca b5 08 	sub	r10,pc,-19192
80008fac:	40 2e       	lddsp	lr,sp[0x8]
80008fae:	59 0e       	cp.w	lr,16
80008fb0:	fe 99 ff db 	brgt	80008f66 <_vfprintf_r+0x185a>
80008fb4:	1c 09       	add	r9,lr
80008fb6:	2f f8       	sub	r8,-1
80008fb8:	87 0a       	st.w	r3[0x0],r10
80008fba:	fb 49 06 90 	st.w	sp[1680],r9
80008fbe:	87 1e       	st.w	r3[0x4],lr
80008fc0:	fb 48 06 8c 	st.w	sp[1676],r8
80008fc4:	58 78       	cp.w	r8,7
80008fc6:	e0 89 00 04 	brgt	80008fce <_vfprintf_r+0x18c2>
80008fca:	2f 83       	sub	r3,-8
80008fcc:	c0 b8       	rjmp	80008fe2 <_vfprintf_r+0x18d6>
80008fce:	fa ca f9 78 	sub	r10,sp,-1672
80008fd2:	02 9b       	mov	r11,r1
80008fd4:	08 9c       	mov	r12,r4
80008fd6:	fe b0 f3 8d 	rcall	800076f0 <__sprint_r>
80008fda:	e0 81 03 18 	brne	8000960a <_vfprintf_r+0x1efe>
80008fde:	fa c3 f9 e0 	sub	r3,sp,-1568
80008fe2:	ed b5 00 08 	bld	r5,0x8
80008fe6:	c0 b0       	breq	80008ffc <_vfprintf_r+0x18f0>
80008fe8:	fa f8 06 90 	ld.w	r8,sp[1680]
80008fec:	87 12       	st.w	r3[0x4],r2
80008fee:	87 06       	st.w	r3[0x0],r6
80008ff0:	f0 02 00 02 	add	r2,r8,r2
80008ff4:	fb 42 06 90 	st.w	sp[1680],r2
80008ff8:	e0 8f 01 d4 	bral	800093a0 <_vfprintf_r+0x1c94>
80008ffc:	e0 40 00 65 	cp.w	r0,101
80009000:	e0 8a 01 d6 	brle	800093ac <_vfprintf_r+0x1ca0>
80009004:	30 08       	mov	r8,0
80009006:	30 09       	mov	r9,0
80009008:	40 5b       	lddsp	r11,sp[0x14]
8000900a:	40 7a       	lddsp	r10,sp[0x1c]
8000900c:	e0 a0 15 2f 	rcall	8000ba6a <__avr32_f64_cmp_eq>
80009010:	c7 90       	breq	80009102 <_vfprintf_r+0x19f6>
80009012:	fa f8 06 90 	ld.w	r8,sp[1680]
80009016:	fe c9 b5 8a 	sub	r9,pc,-19062
8000901a:	2f f8       	sub	r8,-1
8000901c:	87 09       	st.w	r3[0x0],r9
8000901e:	fb 48 06 90 	st.w	sp[1680],r8
80009022:	30 19       	mov	r9,1
80009024:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009028:	87 19       	st.w	r3[0x4],r9
8000902a:	2f f8       	sub	r8,-1
8000902c:	fb 48 06 8c 	st.w	sp[1676],r8
80009030:	58 78       	cp.w	r8,7
80009032:	e0 89 00 05 	brgt	8000903c <_vfprintf_r+0x1930>
80009036:	2f 83       	sub	r3,-8
80009038:	c0 c8       	rjmp	80009050 <_vfprintf_r+0x1944>
8000903a:	d7 03       	nop
8000903c:	fa ca f9 78 	sub	r10,sp,-1672
80009040:	02 9b       	mov	r11,r1
80009042:	08 9c       	mov	r12,r4
80009044:	fe b0 f3 56 	rcall	800076f0 <__sprint_r>
80009048:	e0 81 02 e1 	brne	8000960a <_vfprintf_r+0x1efe>
8000904c:	fa c3 f9 e0 	sub	r3,sp,-1568
80009050:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009054:	40 6c       	lddsp	r12,sp[0x18]
80009056:	18 38       	cp.w	r8,r12
80009058:	c0 55       	brlt	80009062 <_vfprintf_r+0x1956>
8000905a:	ed b5 00 00 	bld	r5,0x0
8000905e:	e0 81 02 6b 	brne	80009534 <_vfprintf_r+0x1e28>
80009062:	fa f8 06 90 	ld.w	r8,sp[1680]
80009066:	2f f8       	sub	r8,-1
80009068:	40 cb       	lddsp	r11,sp[0x30]
8000906a:	fb 48 06 90 	st.w	sp[1680],r8
8000906e:	30 19       	mov	r9,1
80009070:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009074:	87 0b       	st.w	r3[0x0],r11
80009076:	2f f8       	sub	r8,-1
80009078:	87 19       	st.w	r3[0x4],r9
8000907a:	fb 48 06 8c 	st.w	sp[1676],r8
8000907e:	58 78       	cp.w	r8,7
80009080:	e0 89 00 04 	brgt	80009088 <_vfprintf_r+0x197c>
80009084:	2f 83       	sub	r3,-8
80009086:	c0 b8       	rjmp	8000909c <_vfprintf_r+0x1990>
80009088:	fa ca f9 78 	sub	r10,sp,-1672
8000908c:	02 9b       	mov	r11,r1
8000908e:	08 9c       	mov	r12,r4
80009090:	fe b0 f3 30 	rcall	800076f0 <__sprint_r>
80009094:	e0 81 02 bb 	brne	8000960a <_vfprintf_r+0x1efe>
80009098:	fa c3 f9 e0 	sub	r3,sp,-1568
8000909c:	40 66       	lddsp	r6,sp[0x18]
8000909e:	20 16       	sub	r6,1
800090a0:	58 06       	cp.w	r6,0
800090a2:	e0 89 00 1d 	brgt	800090dc <_vfprintf_r+0x19d0>
800090a6:	e0 8f 02 47 	bral	80009534 <_vfprintf_r+0x1e28>
800090aa:	2f 09       	sub	r9,-16
800090ac:	2f f8       	sub	r8,-1
800090ae:	fb 49 06 90 	st.w	sp[1680],r9
800090b2:	87 02       	st.w	r3[0x0],r2
800090b4:	87 10       	st.w	r3[0x4],r0
800090b6:	fb 48 06 8c 	st.w	sp[1676],r8
800090ba:	58 78       	cp.w	r8,7
800090bc:	e0 89 00 04 	brgt	800090c4 <_vfprintf_r+0x19b8>
800090c0:	2f 83       	sub	r3,-8
800090c2:	c0 b8       	rjmp	800090d8 <_vfprintf_r+0x19cc>
800090c4:	fa ca f9 78 	sub	r10,sp,-1672
800090c8:	02 9b       	mov	r11,r1
800090ca:	08 9c       	mov	r12,r4
800090cc:	fe b0 f3 12 	rcall	800076f0 <__sprint_r>
800090d0:	e0 81 02 9d 	brne	8000960a <_vfprintf_r+0x1efe>
800090d4:	fa c3 f9 e0 	sub	r3,sp,-1568
800090d8:	21 06       	sub	r6,16
800090da:	c0 48       	rjmp	800090e2 <_vfprintf_r+0x19d6>
800090dc:	fe c2 b6 3c 	sub	r2,pc,-18884
800090e0:	31 00       	mov	r0,16
800090e2:	fa f9 06 90 	ld.w	r9,sp[1680]
800090e6:	fa f8 06 8c 	ld.w	r8,sp[1676]
800090ea:	fe ca b6 4a 	sub	r10,pc,-18870
800090ee:	59 06       	cp.w	r6,16
800090f0:	fe 99 ff dd 	brgt	800090aa <_vfprintf_r+0x199e>
800090f4:	0c 09       	add	r9,r6
800090f6:	87 0a       	st.w	r3[0x0],r10
800090f8:	fb 49 06 90 	st.w	sp[1680],r9
800090fc:	2f f8       	sub	r8,-1
800090fe:	87 16       	st.w	r3[0x4],r6
80009100:	c5 39       	rjmp	800093a6 <_vfprintf_r+0x1c9a>
80009102:	fa fa 06 ac 	ld.w	r10,sp[1708]
80009106:	58 0a       	cp.w	r10,0
80009108:	e0 89 00 92 	brgt	8000922c <_vfprintf_r+0x1b20>
8000910c:	fa f8 06 90 	ld.w	r8,sp[1680]
80009110:	fe c9 b6 84 	sub	r9,pc,-18812
80009114:	2f f8       	sub	r8,-1
80009116:	87 09       	st.w	r3[0x0],r9
80009118:	fb 48 06 90 	st.w	sp[1680],r8
8000911c:	30 19       	mov	r9,1
8000911e:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009122:	87 19       	st.w	r3[0x4],r9
80009124:	2f f8       	sub	r8,-1
80009126:	fb 48 06 8c 	st.w	sp[1676],r8
8000912a:	58 78       	cp.w	r8,7
8000912c:	e0 89 00 04 	brgt	80009134 <_vfprintf_r+0x1a28>
80009130:	2f 83       	sub	r3,-8
80009132:	c0 b8       	rjmp	80009148 <_vfprintf_r+0x1a3c>
80009134:	fa ca f9 78 	sub	r10,sp,-1672
80009138:	02 9b       	mov	r11,r1
8000913a:	08 9c       	mov	r12,r4
8000913c:	fe b0 f2 da 	rcall	800076f0 <__sprint_r>
80009140:	e0 81 02 65 	brne	8000960a <_vfprintf_r+0x1efe>
80009144:	fa c3 f9 e0 	sub	r3,sp,-1568
80009148:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000914c:	58 08       	cp.w	r8,0
8000914e:	c0 81       	brne	8000915e <_vfprintf_r+0x1a52>
80009150:	40 6a       	lddsp	r10,sp[0x18]
80009152:	58 0a       	cp.w	r10,0
80009154:	c0 51       	brne	8000915e <_vfprintf_r+0x1a52>
80009156:	ed b5 00 00 	bld	r5,0x0
8000915a:	e0 81 01 ed 	brne	80009534 <_vfprintf_r+0x1e28>
8000915e:	40 c9       	lddsp	r9,sp[0x30]
80009160:	fa f8 06 90 	ld.w	r8,sp[1680]
80009164:	2f f8       	sub	r8,-1
80009166:	87 09       	st.w	r3[0x0],r9
80009168:	fb 48 06 90 	st.w	sp[1680],r8
8000916c:	30 19       	mov	r9,1
8000916e:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009172:	87 19       	st.w	r3[0x4],r9
80009174:	2f f8       	sub	r8,-1
80009176:	fb 48 06 8c 	st.w	sp[1676],r8
8000917a:	58 78       	cp.w	r8,7
8000917c:	e0 89 00 04 	brgt	80009184 <_vfprintf_r+0x1a78>
80009180:	2f 83       	sub	r3,-8
80009182:	c0 b8       	rjmp	80009198 <_vfprintf_r+0x1a8c>
80009184:	fa ca f9 78 	sub	r10,sp,-1672
80009188:	02 9b       	mov	r11,r1
8000918a:	08 9c       	mov	r12,r4
8000918c:	fe b0 f2 b2 	rcall	800076f0 <__sprint_r>
80009190:	e0 81 02 3d 	brne	8000960a <_vfprintf_r+0x1efe>
80009194:	fa c3 f9 e0 	sub	r3,sp,-1568
80009198:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000919c:	5c 32       	neg	r2
8000919e:	58 02       	cp.w	r2,0
800091a0:	e0 89 00 1d 	brgt	800091da <_vfprintf_r+0x1ace>
800091a4:	c3 d8       	rjmp	8000921e <_vfprintf_r+0x1b12>
800091a6:	2f 09       	sub	r9,-16
800091a8:	2f f8       	sub	r8,-1
800091aa:	31 0e       	mov	lr,16
800091ac:	fb 49 06 90 	st.w	sp[1680],r9
800091b0:	87 00       	st.w	r3[0x0],r0
800091b2:	87 1e       	st.w	r3[0x4],lr
800091b4:	fb 48 06 8c 	st.w	sp[1676],r8
800091b8:	58 78       	cp.w	r8,7
800091ba:	e0 89 00 04 	brgt	800091c2 <_vfprintf_r+0x1ab6>
800091be:	2f 83       	sub	r3,-8
800091c0:	c0 b8       	rjmp	800091d6 <_vfprintf_r+0x1aca>
800091c2:	fa ca f9 78 	sub	r10,sp,-1672
800091c6:	02 9b       	mov	r11,r1
800091c8:	08 9c       	mov	r12,r4
800091ca:	fe b0 f2 93 	rcall	800076f0 <__sprint_r>
800091ce:	e0 81 02 1e 	brne	8000960a <_vfprintf_r+0x1efe>
800091d2:	fa c3 f9 e0 	sub	r3,sp,-1568
800091d6:	21 02       	sub	r2,16
800091d8:	c0 38       	rjmp	800091de <_vfprintf_r+0x1ad2>
800091da:	fe c0 b7 3a 	sub	r0,pc,-18630
800091de:	fa f9 06 90 	ld.w	r9,sp[1680]
800091e2:	fa f8 06 8c 	ld.w	r8,sp[1676]
800091e6:	fe ca b7 46 	sub	r10,pc,-18618
800091ea:	59 02       	cp.w	r2,16
800091ec:	fe 99 ff dd 	brgt	800091a6 <_vfprintf_r+0x1a9a>
800091f0:	04 09       	add	r9,r2
800091f2:	2f f8       	sub	r8,-1
800091f4:	87 0a       	st.w	r3[0x0],r10
800091f6:	fb 49 06 90 	st.w	sp[1680],r9
800091fa:	87 12       	st.w	r3[0x4],r2
800091fc:	fb 48 06 8c 	st.w	sp[1676],r8
80009200:	58 78       	cp.w	r8,7
80009202:	e0 89 00 04 	brgt	8000920a <_vfprintf_r+0x1afe>
80009206:	2f 83       	sub	r3,-8
80009208:	c0 b8       	rjmp	8000921e <_vfprintf_r+0x1b12>
8000920a:	fa ca f9 78 	sub	r10,sp,-1672
8000920e:	02 9b       	mov	r11,r1
80009210:	08 9c       	mov	r12,r4
80009212:	fe b0 f2 6f 	rcall	800076f0 <__sprint_r>
80009216:	e0 81 01 fa 	brne	8000960a <_vfprintf_r+0x1efe>
8000921a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000921e:	40 6c       	lddsp	r12,sp[0x18]
80009220:	fa f8 06 90 	ld.w	r8,sp[1680]
80009224:	87 06       	st.w	r3[0x0],r6
80009226:	87 1c       	st.w	r3[0x4],r12
80009228:	18 08       	add	r8,r12
8000922a:	cb 98       	rjmp	8000939c <_vfprintf_r+0x1c90>
8000922c:	fa f9 06 90 	ld.w	r9,sp[1680]
80009230:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009234:	40 6b       	lddsp	r11,sp[0x18]
80009236:	16 3a       	cp.w	r10,r11
80009238:	c6 f5       	brlt	80009316 <_vfprintf_r+0x1c0a>
8000923a:	16 09       	add	r9,r11
8000923c:	2f f8       	sub	r8,-1
8000923e:	87 06       	st.w	r3[0x0],r6
80009240:	fb 49 06 90 	st.w	sp[1680],r9
80009244:	87 1b       	st.w	r3[0x4],r11
80009246:	fb 48 06 8c 	st.w	sp[1676],r8
8000924a:	58 78       	cp.w	r8,7
8000924c:	e0 89 00 04 	brgt	80009254 <_vfprintf_r+0x1b48>
80009250:	2f 83       	sub	r3,-8
80009252:	c0 b8       	rjmp	80009268 <_vfprintf_r+0x1b5c>
80009254:	fa ca f9 78 	sub	r10,sp,-1672
80009258:	02 9b       	mov	r11,r1
8000925a:	08 9c       	mov	r12,r4
8000925c:	fe b0 f2 4a 	rcall	800076f0 <__sprint_r>
80009260:	e0 81 01 d5 	brne	8000960a <_vfprintf_r+0x1efe>
80009264:	fa c3 f9 e0 	sub	r3,sp,-1568
80009268:	fa f6 06 ac 	ld.w	r6,sp[1708]
8000926c:	40 6a       	lddsp	r10,sp[0x18]
8000926e:	14 16       	sub	r6,r10
80009270:	58 06       	cp.w	r6,0
80009272:	e0 89 00 1c 	brgt	800092aa <_vfprintf_r+0x1b9e>
80009276:	c3 d8       	rjmp	800092f0 <_vfprintf_r+0x1be4>
80009278:	2f 09       	sub	r9,-16
8000927a:	2f f8       	sub	r8,-1
8000927c:	fb 49 06 90 	st.w	sp[1680],r9
80009280:	87 02       	st.w	r3[0x0],r2
80009282:	87 10       	st.w	r3[0x4],r0
80009284:	fb 48 06 8c 	st.w	sp[1676],r8
80009288:	58 78       	cp.w	r8,7
8000928a:	e0 89 00 04 	brgt	80009292 <_vfprintf_r+0x1b86>
8000928e:	2f 83       	sub	r3,-8
80009290:	c0 b8       	rjmp	800092a6 <_vfprintf_r+0x1b9a>
80009292:	fa ca f9 78 	sub	r10,sp,-1672
80009296:	02 9b       	mov	r11,r1
80009298:	08 9c       	mov	r12,r4
8000929a:	fe b0 f2 2b 	rcall	800076f0 <__sprint_r>
8000929e:	e0 81 01 b6 	brne	8000960a <_vfprintf_r+0x1efe>
800092a2:	fa c3 f9 e0 	sub	r3,sp,-1568
800092a6:	21 06       	sub	r6,16
800092a8:	c0 48       	rjmp	800092b0 <_vfprintf_r+0x1ba4>
800092aa:	fe c2 b8 0a 	sub	r2,pc,-18422
800092ae:	31 00       	mov	r0,16
800092b0:	fa f9 06 90 	ld.w	r9,sp[1680]
800092b4:	fa f8 06 8c 	ld.w	r8,sp[1676]
800092b8:	fe ca b8 18 	sub	r10,pc,-18408
800092bc:	59 06       	cp.w	r6,16
800092be:	fe 99 ff dd 	brgt	80009278 <_vfprintf_r+0x1b6c>
800092c2:	0c 09       	add	r9,r6
800092c4:	2f f8       	sub	r8,-1
800092c6:	87 0a       	st.w	r3[0x0],r10
800092c8:	fb 49 06 90 	st.w	sp[1680],r9
800092cc:	87 16       	st.w	r3[0x4],r6
800092ce:	fb 48 06 8c 	st.w	sp[1676],r8
800092d2:	58 78       	cp.w	r8,7
800092d4:	e0 89 00 04 	brgt	800092dc <_vfprintf_r+0x1bd0>
800092d8:	2f 83       	sub	r3,-8
800092da:	c0 b8       	rjmp	800092f0 <_vfprintf_r+0x1be4>
800092dc:	fa ca f9 78 	sub	r10,sp,-1672
800092e0:	02 9b       	mov	r11,r1
800092e2:	08 9c       	mov	r12,r4
800092e4:	fe b0 f2 06 	rcall	800076f0 <__sprint_r>
800092e8:	e0 81 01 91 	brne	8000960a <_vfprintf_r+0x1efe>
800092ec:	fa c3 f9 e0 	sub	r3,sp,-1568
800092f0:	ed b5 00 00 	bld	r5,0x0
800092f4:	e0 81 01 20 	brne	80009534 <_vfprintf_r+0x1e28>
800092f8:	40 c9       	lddsp	r9,sp[0x30]
800092fa:	fa f8 06 90 	ld.w	r8,sp[1680]
800092fe:	2f f8       	sub	r8,-1
80009300:	87 09       	st.w	r3[0x0],r9
80009302:	fb 48 06 90 	st.w	sp[1680],r8
80009306:	30 19       	mov	r9,1
80009308:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000930c:	87 19       	st.w	r3[0x4],r9
8000930e:	2f f8       	sub	r8,-1
80009310:	fb 48 06 8c 	st.w	sp[1676],r8
80009314:	c0 29       	rjmp	80009518 <_vfprintf_r+0x1e0c>
80009316:	14 09       	add	r9,r10
80009318:	2f f8       	sub	r8,-1
8000931a:	fb 49 06 90 	st.w	sp[1680],r9
8000931e:	87 06       	st.w	r3[0x0],r6
80009320:	87 1a       	st.w	r3[0x4],r10
80009322:	fb 48 06 8c 	st.w	sp[1676],r8
80009326:	58 78       	cp.w	r8,7
80009328:	e0 89 00 04 	brgt	80009330 <_vfprintf_r+0x1c24>
8000932c:	2f 83       	sub	r3,-8
8000932e:	c0 b8       	rjmp	80009344 <_vfprintf_r+0x1c38>
80009330:	fa ca f9 78 	sub	r10,sp,-1672
80009334:	02 9b       	mov	r11,r1
80009336:	08 9c       	mov	r12,r4
80009338:	fe b0 f1 dc 	rcall	800076f0 <__sprint_r>
8000933c:	e0 81 01 67 	brne	8000960a <_vfprintf_r+0x1efe>
80009340:	fa c3 f9 e0 	sub	r3,sp,-1568
80009344:	40 c8       	lddsp	r8,sp[0x30]
80009346:	87 08       	st.w	r3[0x0],r8
80009348:	fa f8 06 90 	ld.w	r8,sp[1680]
8000934c:	2f f8       	sub	r8,-1
8000934e:	30 19       	mov	r9,1
80009350:	fb 48 06 90 	st.w	sp[1680],r8
80009354:	87 19       	st.w	r3[0x4],r9
80009356:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000935a:	2f f8       	sub	r8,-1
8000935c:	fb 48 06 8c 	st.w	sp[1676],r8
80009360:	fa f2 06 ac 	ld.w	r2,sp[1708]
80009364:	58 78       	cp.w	r8,7
80009366:	e0 89 00 04 	brgt	8000936e <_vfprintf_r+0x1c62>
8000936a:	2f 83       	sub	r3,-8
8000936c:	c0 b8       	rjmp	80009382 <_vfprintf_r+0x1c76>
8000936e:	fa ca f9 78 	sub	r10,sp,-1672
80009372:	02 9b       	mov	r11,r1
80009374:	08 9c       	mov	r12,r4
80009376:	fe b0 f1 bd 	rcall	800076f0 <__sprint_r>
8000937a:	e0 81 01 48 	brne	8000960a <_vfprintf_r+0x1efe>
8000937e:	fa c3 f9 e0 	sub	r3,sp,-1568
80009382:	04 06       	add	r6,r2
80009384:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009388:	87 06       	st.w	r3[0x0],r6
8000938a:	fa f9 06 90 	ld.w	r9,sp[1680]
8000938e:	40 66       	lddsp	r6,sp[0x18]
80009390:	40 6e       	lddsp	lr,sp[0x18]
80009392:	10 16       	sub	r6,r8
80009394:	f2 08 01 08 	sub	r8,r9,r8
80009398:	87 16       	st.w	r3[0x4],r6
8000939a:	1c 08       	add	r8,lr
8000939c:	fb 48 06 90 	st.w	sp[1680],r8
800093a0:	fa f8 06 8c 	ld.w	r8,sp[1676]
800093a4:	2f f8       	sub	r8,-1
800093a6:	fb 48 06 8c 	st.w	sp[1676],r8
800093aa:	cb 78       	rjmp	80009518 <_vfprintf_r+0x1e0c>
800093ac:	40 6c       	lddsp	r12,sp[0x18]
800093ae:	58 1c       	cp.w	r12,1
800093b0:	e0 89 00 06 	brgt	800093bc <_vfprintf_r+0x1cb0>
800093b4:	ed b5 00 00 	bld	r5,0x0
800093b8:	e0 81 00 85 	brne	800094c2 <_vfprintf_r+0x1db6>
800093bc:	fa f8 06 90 	ld.w	r8,sp[1680]
800093c0:	2f f8       	sub	r8,-1
800093c2:	30 19       	mov	r9,1
800093c4:	fb 48 06 90 	st.w	sp[1680],r8
800093c8:	87 06       	st.w	r3[0x0],r6
800093ca:	fa f8 06 8c 	ld.w	r8,sp[1676]
800093ce:	87 19       	st.w	r3[0x4],r9
800093d0:	2f f8       	sub	r8,-1
800093d2:	fb 48 06 8c 	st.w	sp[1676],r8
800093d6:	58 78       	cp.w	r8,7
800093d8:	e0 89 00 04 	brgt	800093e0 <_vfprintf_r+0x1cd4>
800093dc:	2f 83       	sub	r3,-8
800093de:	c0 b8       	rjmp	800093f4 <_vfprintf_r+0x1ce8>
800093e0:	fa ca f9 78 	sub	r10,sp,-1672
800093e4:	02 9b       	mov	r11,r1
800093e6:	08 9c       	mov	r12,r4
800093e8:	fe b0 f1 84 	rcall	800076f0 <__sprint_r>
800093ec:	e0 81 01 0f 	brne	8000960a <_vfprintf_r+0x1efe>
800093f0:	fa c3 f9 e0 	sub	r3,sp,-1568
800093f4:	fa f8 06 90 	ld.w	r8,sp[1680]
800093f8:	2f f8       	sub	r8,-1
800093fa:	40 cb       	lddsp	r11,sp[0x30]
800093fc:	fb 48 06 90 	st.w	sp[1680],r8
80009400:	30 19       	mov	r9,1
80009402:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009406:	87 0b       	st.w	r3[0x0],r11
80009408:	2f f8       	sub	r8,-1
8000940a:	87 19       	st.w	r3[0x4],r9
8000940c:	fb 48 06 8c 	st.w	sp[1676],r8
80009410:	58 78       	cp.w	r8,7
80009412:	e0 89 00 05 	brgt	8000941c <_vfprintf_r+0x1d10>
80009416:	2f 83       	sub	r3,-8
80009418:	c0 c8       	rjmp	80009430 <_vfprintf_r+0x1d24>
8000941a:	d7 03       	nop
8000941c:	fa ca f9 78 	sub	r10,sp,-1672
80009420:	02 9b       	mov	r11,r1
80009422:	08 9c       	mov	r12,r4
80009424:	fe b0 f1 66 	rcall	800076f0 <__sprint_r>
80009428:	e0 81 00 f1 	brne	8000960a <_vfprintf_r+0x1efe>
8000942c:	fa c3 f9 e0 	sub	r3,sp,-1568
80009430:	30 08       	mov	r8,0
80009432:	30 09       	mov	r9,0
80009434:	40 5b       	lddsp	r11,sp[0x14]
80009436:	40 7a       	lddsp	r10,sp[0x1c]
80009438:	e0 a0 13 19 	rcall	8000ba6a <__avr32_f64_cmp_eq>
8000943c:	40 68       	lddsp	r8,sp[0x18]
8000943e:	20 18       	sub	r8,1
80009440:	58 0c       	cp.w	r12,0
80009442:	c0 d1       	brne	8000945c <_vfprintf_r+0x1d50>
80009444:	2f f6       	sub	r6,-1
80009446:	87 18       	st.w	r3[0x4],r8
80009448:	87 06       	st.w	r3[0x0],r6
8000944a:	fa f6 06 90 	ld.w	r6,sp[1680]
8000944e:	10 06       	add	r6,r8
80009450:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009454:	fb 46 06 90 	st.w	sp[1680],r6
80009458:	2f f8       	sub	r8,-1
8000945a:	c3 18       	rjmp	800094bc <_vfprintf_r+0x1db0>
8000945c:	10 96       	mov	r6,r8
8000945e:	58 08       	cp.w	r8,0
80009460:	e0 89 00 1c 	brgt	80009498 <_vfprintf_r+0x1d8c>
80009464:	c4 b8       	rjmp	800094fa <_vfprintf_r+0x1dee>
80009466:	2f 09       	sub	r9,-16
80009468:	2f f8       	sub	r8,-1
8000946a:	fb 49 06 90 	st.w	sp[1680],r9
8000946e:	87 02       	st.w	r3[0x0],r2
80009470:	87 10       	st.w	r3[0x4],r0
80009472:	fb 48 06 8c 	st.w	sp[1676],r8
80009476:	58 78       	cp.w	r8,7
80009478:	e0 89 00 04 	brgt	80009480 <_vfprintf_r+0x1d74>
8000947c:	2f 83       	sub	r3,-8
8000947e:	c0 b8       	rjmp	80009494 <_vfprintf_r+0x1d88>
80009480:	fa ca f9 78 	sub	r10,sp,-1672
80009484:	02 9b       	mov	r11,r1
80009486:	08 9c       	mov	r12,r4
80009488:	fe b0 f1 34 	rcall	800076f0 <__sprint_r>
8000948c:	e0 81 00 bf 	brne	8000960a <_vfprintf_r+0x1efe>
80009490:	fa c3 f9 e0 	sub	r3,sp,-1568
80009494:	21 06       	sub	r6,16
80009496:	c0 48       	rjmp	8000949e <_vfprintf_r+0x1d92>
80009498:	fe c2 b9 f8 	sub	r2,pc,-17928
8000949c:	31 00       	mov	r0,16
8000949e:	fa f9 06 90 	ld.w	r9,sp[1680]
800094a2:	fa f8 06 8c 	ld.w	r8,sp[1676]
800094a6:	fe ca ba 06 	sub	r10,pc,-17914
800094aa:	59 06       	cp.w	r6,16
800094ac:	fe 99 ff dd 	brgt	80009466 <_vfprintf_r+0x1d5a>
800094b0:	0c 09       	add	r9,r6
800094b2:	87 0a       	st.w	r3[0x0],r10
800094b4:	fb 49 06 90 	st.w	sp[1680],r9
800094b8:	2f f8       	sub	r8,-1
800094ba:	87 16       	st.w	r3[0x4],r6
800094bc:	fb 48 06 8c 	st.w	sp[1676],r8
800094c0:	c0 e8       	rjmp	800094dc <_vfprintf_r+0x1dd0>
800094c2:	fa f8 06 90 	ld.w	r8,sp[1680]
800094c6:	2f f8       	sub	r8,-1
800094c8:	30 19       	mov	r9,1
800094ca:	fb 48 06 90 	st.w	sp[1680],r8
800094ce:	87 06       	st.w	r3[0x0],r6
800094d0:	fa f8 06 8c 	ld.w	r8,sp[1676]
800094d4:	87 19       	st.w	r3[0x4],r9
800094d6:	2f f8       	sub	r8,-1
800094d8:	fb 48 06 8c 	st.w	sp[1676],r8
800094dc:	58 78       	cp.w	r8,7
800094de:	e0 89 00 04 	brgt	800094e6 <_vfprintf_r+0x1dda>
800094e2:	2f 83       	sub	r3,-8
800094e4:	c0 b8       	rjmp	800094fa <_vfprintf_r+0x1dee>
800094e6:	fa ca f9 78 	sub	r10,sp,-1672
800094ea:	02 9b       	mov	r11,r1
800094ec:	08 9c       	mov	r12,r4
800094ee:	fe b0 f1 01 	rcall	800076f0 <__sprint_r>
800094f2:	e0 81 00 8c 	brne	8000960a <_vfprintf_r+0x1efe>
800094f6:	fa c3 f9 e0 	sub	r3,sp,-1568
800094fa:	40 ea       	lddsp	r10,sp[0x38]
800094fc:	fa f8 06 90 	ld.w	r8,sp[1680]
80009500:	14 08       	add	r8,r10
80009502:	fa c9 f9 64 	sub	r9,sp,-1692
80009506:	fb 48 06 90 	st.w	sp[1680],r8
8000950a:	87 1a       	st.w	r3[0x4],r10
8000950c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009510:	87 09       	st.w	r3[0x0],r9
80009512:	2f f8       	sub	r8,-1
80009514:	fb 48 06 8c 	st.w	sp[1676],r8
80009518:	58 78       	cp.w	r8,7
8000951a:	e0 89 00 04 	brgt	80009522 <_vfprintf_r+0x1e16>
8000951e:	2f 83       	sub	r3,-8
80009520:	c0 a8       	rjmp	80009534 <_vfprintf_r+0x1e28>
80009522:	fa ca f9 78 	sub	r10,sp,-1672
80009526:	02 9b       	mov	r11,r1
80009528:	08 9c       	mov	r12,r4
8000952a:	fe b0 f0 e3 	rcall	800076f0 <__sprint_r>
8000952e:	c6 e1       	brne	8000960a <_vfprintf_r+0x1efe>
80009530:	fa c3 f9 e0 	sub	r3,sp,-1568
80009534:	e2 15 00 04 	andl	r5,0x4,COH
80009538:	c3 f0       	breq	800095b6 <_vfprintf_r+0x1eaa>
8000953a:	40 86       	lddsp	r6,sp[0x20]
8000953c:	40 39       	lddsp	r9,sp[0xc]
8000953e:	12 16       	sub	r6,r9
80009540:	58 06       	cp.w	r6,0
80009542:	e0 89 00 1a 	brgt	80009576 <_vfprintf_r+0x1e6a>
80009546:	c3 88       	rjmp	800095b6 <_vfprintf_r+0x1eaa>
80009548:	2f 09       	sub	r9,-16
8000954a:	2f f8       	sub	r8,-1
8000954c:	fb 49 06 90 	st.w	sp[1680],r9
80009550:	87 05       	st.w	r3[0x0],r5
80009552:	87 12       	st.w	r3[0x4],r2
80009554:	fb 48 06 8c 	st.w	sp[1676],r8
80009558:	58 78       	cp.w	r8,7
8000955a:	e0 89 00 04 	brgt	80009562 <_vfprintf_r+0x1e56>
8000955e:	2f 83       	sub	r3,-8
80009560:	c0 98       	rjmp	80009572 <_vfprintf_r+0x1e66>
80009562:	00 9a       	mov	r10,r0
80009564:	02 9b       	mov	r11,r1
80009566:	08 9c       	mov	r12,r4
80009568:	fe b0 f0 c4 	rcall	800076f0 <__sprint_r>
8000956c:	c4 f1       	brne	8000960a <_vfprintf_r+0x1efe>
8000956e:	fa c3 f9 e0 	sub	r3,sp,-1568
80009572:	21 06       	sub	r6,16
80009574:	c0 68       	rjmp	80009580 <_vfprintf_r+0x1e74>
80009576:	fe c5 ba e6 	sub	r5,pc,-17690
8000957a:	31 02       	mov	r2,16
8000957c:	fa c0 f9 78 	sub	r0,sp,-1672
80009580:	fa f9 06 90 	ld.w	r9,sp[1680]
80009584:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009588:	fe ca ba f8 	sub	r10,pc,-17672
8000958c:	59 06       	cp.w	r6,16
8000958e:	fe 99 ff dd 	brgt	80009548 <_vfprintf_r+0x1e3c>
80009592:	0c 09       	add	r9,r6
80009594:	2f f8       	sub	r8,-1
80009596:	87 0a       	st.w	r3[0x0],r10
80009598:	87 16       	st.w	r3[0x4],r6
8000959a:	fb 49 06 90 	st.w	sp[1680],r9
8000959e:	fb 48 06 8c 	st.w	sp[1676],r8
800095a2:	58 78       	cp.w	r8,7
800095a4:	e0 8a 00 09 	brle	800095b6 <_vfprintf_r+0x1eaa>
800095a8:	fa ca f9 78 	sub	r10,sp,-1672
800095ac:	02 9b       	mov	r11,r1
800095ae:	08 9c       	mov	r12,r4
800095b0:	fe b0 f0 a0 	rcall	800076f0 <__sprint_r>
800095b4:	c2 b1       	brne	8000960a <_vfprintf_r+0x1efe>
800095b6:	40 bc       	lddsp	r12,sp[0x2c]
800095b8:	40 36       	lddsp	r6,sp[0xc]
800095ba:	40 8e       	lddsp	lr,sp[0x20]
800095bc:	ec 0e 0c 48 	max	r8,r6,lr
800095c0:	10 0c       	add	r12,r8
800095c2:	50 bc       	stdsp	sp[0x2c],r12
800095c4:	fa f8 06 90 	ld.w	r8,sp[1680]
800095c8:	58 08       	cp.w	r8,0
800095ca:	c0 80       	breq	800095da <_vfprintf_r+0x1ece>
800095cc:	fa ca f9 78 	sub	r10,sp,-1672
800095d0:	02 9b       	mov	r11,r1
800095d2:	08 9c       	mov	r12,r4
800095d4:	fe b0 f0 8e 	rcall	800076f0 <__sprint_r>
800095d8:	c1 91       	brne	8000960a <_vfprintf_r+0x1efe>
800095da:	30 0b       	mov	r11,0
800095dc:	fa c3 f9 e0 	sub	r3,sp,-1568
800095e0:	fb 4b 06 8c 	st.w	sp[1676],r11
800095e4:	fe 9f f1 22 	bral	80007828 <_vfprintf_r+0x11c>
800095e8:	08 95       	mov	r5,r4
800095ea:	fa f8 06 90 	ld.w	r8,sp[1680]
800095ee:	58 08       	cp.w	r8,0
800095f0:	c0 80       	breq	80009600 <_vfprintf_r+0x1ef4>
800095f2:	08 9c       	mov	r12,r4
800095f4:	fa ca f9 78 	sub	r10,sp,-1672
800095f8:	02 9b       	mov	r11,r1
800095fa:	fe b0 f0 7b 	rcall	800076f0 <__sprint_r>
800095fe:	c0 61       	brne	8000960a <_vfprintf_r+0x1efe>
80009600:	30 08       	mov	r8,0
80009602:	fb 48 06 8c 	st.w	sp[1676],r8
80009606:	c0 28       	rjmp	8000960a <_vfprintf_r+0x1efe>
80009608:	40 41       	lddsp	r1,sp[0x10]
8000960a:	82 68       	ld.sh	r8,r1[0xc]
8000960c:	ed b8 00 06 	bld	r8,0x6
80009610:	c0 31       	brne	80009616 <_vfprintf_r+0x1f0a>
80009612:	3f fa       	mov	r10,-1
80009614:	50 ba       	stdsp	sp[0x2c],r10
80009616:	40 bc       	lddsp	r12,sp[0x2c]
80009618:	fe 3d f9 44 	sub	sp,-1724
8000961c:	d8 32       	popm	r0-r7,pc
8000961e:	d7 03       	nop

80009620 <__swsetup_r>:
80009620:	d4 21       	pushm	r4-r7,lr
80009622:	e0 68 0a 38 	mov	r8,2616
80009626:	18 96       	mov	r6,r12
80009628:	16 97       	mov	r7,r11
8000962a:	70 0c       	ld.w	r12,r8[0x0]
8000962c:	58 0c       	cp.w	r12,0
8000962e:	c0 60       	breq	8000963a <__swsetup_r+0x1a>
80009630:	78 68       	ld.w	r8,r12[0x18]
80009632:	58 08       	cp.w	r8,0
80009634:	c0 31       	brne	8000963a <__swsetup_r+0x1a>
80009636:	e0 a0 07 bf 	rcall	8000a5b4 <__sinit>
8000963a:	fe c8 ba 7a 	sub	r8,pc,-17798
8000963e:	10 37       	cp.w	r7,r8
80009640:	c0 61       	brne	8000964c <__swsetup_r+0x2c>
80009642:	e0 68 0a 38 	mov	r8,2616
80009646:	70 08       	ld.w	r8,r8[0x0]
80009648:	70 07       	ld.w	r7,r8[0x0]
8000964a:	c1 28       	rjmp	8000966e <__swsetup_r+0x4e>
8000964c:	fe c8 ba 6c 	sub	r8,pc,-17812
80009650:	10 37       	cp.w	r7,r8
80009652:	c0 61       	brne	8000965e <__swsetup_r+0x3e>
80009654:	e0 68 0a 38 	mov	r8,2616
80009658:	70 08       	ld.w	r8,r8[0x0]
8000965a:	70 17       	ld.w	r7,r8[0x4]
8000965c:	c0 98       	rjmp	8000966e <__swsetup_r+0x4e>
8000965e:	fe c8 ba 5e 	sub	r8,pc,-17826
80009662:	10 37       	cp.w	r7,r8
80009664:	c0 51       	brne	8000966e <__swsetup_r+0x4e>
80009666:	e0 68 0a 38 	mov	r8,2616
8000966a:	70 08       	ld.w	r8,r8[0x0]
8000966c:	70 27       	ld.w	r7,r8[0x8]
8000966e:	8e 68       	ld.sh	r8,r7[0xc]
80009670:	ed b8 00 03 	bld	r8,0x3
80009674:	c1 e0       	breq	800096b0 <__swsetup_r+0x90>
80009676:	ed b8 00 04 	bld	r8,0x4
8000967a:	c3 e1       	brne	800096f6 <__swsetup_r+0xd6>
8000967c:	ed b8 00 02 	bld	r8,0x2
80009680:	c1 51       	brne	800096aa <__swsetup_r+0x8a>
80009682:	6e db       	ld.w	r11,r7[0x34]
80009684:	58 0b       	cp.w	r11,0
80009686:	c0 a0       	breq	8000969a <__swsetup_r+0x7a>
80009688:	ee c8 ff bc 	sub	r8,r7,-68
8000968c:	10 3b       	cp.w	r11,r8
8000968e:	c0 40       	breq	80009696 <__swsetup_r+0x76>
80009690:	0c 9c       	mov	r12,r6
80009692:	e0 a0 08 2b 	rcall	8000a6e8 <_free_r>
80009696:	30 08       	mov	r8,0
80009698:	8f d8       	st.w	r7[0x34],r8
8000969a:	8e 68       	ld.sh	r8,r7[0xc]
8000969c:	e0 18 ff db 	andl	r8,0xffdb
800096a0:	ae 68       	st.h	r7[0xc],r8
800096a2:	30 08       	mov	r8,0
800096a4:	8f 18       	st.w	r7[0x4],r8
800096a6:	6e 48       	ld.w	r8,r7[0x10]
800096a8:	8f 08       	st.w	r7[0x0],r8
800096aa:	8e 68       	ld.sh	r8,r7[0xc]
800096ac:	a3 b8       	sbr	r8,0x3
800096ae:	ae 68       	st.h	r7[0xc],r8
800096b0:	6e 48       	ld.w	r8,r7[0x10]
800096b2:	58 08       	cp.w	r8,0
800096b4:	c0 b1       	brne	800096ca <__swsetup_r+0xaa>
800096b6:	8e 68       	ld.sh	r8,r7[0xc]
800096b8:	e2 18 02 80 	andl	r8,0x280,COH
800096bc:	e0 48 02 00 	cp.w	r8,512
800096c0:	c0 50       	breq	800096ca <__swsetup_r+0xaa>
800096c2:	0c 9c       	mov	r12,r6
800096c4:	0e 9b       	mov	r11,r7
800096c6:	e0 a0 0a 4b 	rcall	8000ab5c <__smakebuf_r>
800096ca:	8e 69       	ld.sh	r9,r7[0xc]
800096cc:	f1 d9 c0 01 	bfextu	r8,r9,0x0,0x1
800096d0:	c0 70       	breq	800096de <__swsetup_r+0xbe>
800096d2:	30 08       	mov	r8,0
800096d4:	8f 28       	st.w	r7[0x8],r8
800096d6:	6e 58       	ld.w	r8,r7[0x14]
800096d8:	5c 38       	neg	r8
800096da:	8f 68       	st.w	r7[0x18],r8
800096dc:	c0 68       	rjmp	800096e8 <__swsetup_r+0xc8>
800096de:	ed b9 00 01 	bld	r9,0x1
800096e2:	ef f8 10 05 	ld.wne	r8,r7[0x14]
800096e6:	8f 28       	st.w	r7[0x8],r8
800096e8:	6e 48       	ld.w	r8,r7[0x10]
800096ea:	58 08       	cp.w	r8,0
800096ec:	c0 61       	brne	800096f8 <__swsetup_r+0xd8>
800096ee:	8e 68       	ld.sh	r8,r7[0xc]
800096f0:	ed b8 00 07 	bld	r8,0x7
800096f4:	c0 21       	brne	800096f8 <__swsetup_r+0xd8>
800096f6:	dc 2a       	popm	r4-r7,pc,r12=-1
800096f8:	d8 2a       	popm	r4-r7,pc,r12=0
800096fa:	d7 03       	nop

800096fc <quorem>:
800096fc:	d4 31       	pushm	r0-r7,lr
800096fe:	20 2d       	sub	sp,8
80009700:	18 97       	mov	r7,r12
80009702:	78 48       	ld.w	r8,r12[0x10]
80009704:	76 46       	ld.w	r6,r11[0x10]
80009706:	0c 38       	cp.w	r8,r6
80009708:	c0 34       	brge	8000970e <quorem+0x12>
8000970a:	30 0c       	mov	r12,0
8000970c:	c8 58       	rjmp	80009816 <quorem+0x11a>
8000970e:	ec c2 ff fc 	sub	r2,r6,-4
80009712:	f6 c3 ff ec 	sub	r3,r11,-20
80009716:	f6 02 03 29 	ld.w	r9,r11[r2<<0x2]
8000971a:	f8 02 03 2c 	ld.w	r12,r12[r2<<0x2]
8000971e:	2f f9       	sub	r9,-1
80009720:	20 16       	sub	r6,1
80009722:	f8 09 0d 08 	divu	r8,r12,r9
80009726:	f6 02 00 22 	add	r2,r11,r2<<0x2
8000972a:	ee c4 ff ec 	sub	r4,r7,-20
8000972e:	10 95       	mov	r5,r8
80009730:	58 08       	cp.w	r8,0
80009732:	c4 10       	breq	800097b4 <quorem+0xb8>
80009734:	30 09       	mov	r9,0
80009736:	06 9a       	mov	r10,r3
80009738:	08 98       	mov	r8,r4
8000973a:	12 91       	mov	r1,r9
8000973c:	50 0b       	stdsp	sp[0x0],r11
8000973e:	70 0e       	ld.w	lr,r8[0x0]
80009740:	b1 8e       	lsr	lr,0x10
80009742:	50 1e       	stdsp	sp[0x4],lr
80009744:	15 0e       	ld.w	lr,r10++
80009746:	fc 00 16 10 	lsr	r0,lr,0x10
8000974a:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000974e:	ea 0e 03 41 	mac	r1,r5,lr
80009752:	fd d1 c0 10 	bfextu	lr,r1,0x0,0x10
80009756:	b1 81       	lsr	r1,0x10
80009758:	40 1b       	lddsp	r11,sp[0x4]
8000975a:	ea 00 02 40 	mul	r0,r5,r0
8000975e:	e2 00 00 00 	add	r0,r1,r0
80009762:	e3 d0 c0 10 	bfextu	r1,r0,0x0,0x10
80009766:	02 1b       	sub	r11,r1
80009768:	50 1b       	stdsp	sp[0x4],r11
8000976a:	70 0b       	ld.w	r11,r8[0x0]
8000976c:	e3 db c0 10 	bfextu	r1,r11,0x0,0x10
80009770:	02 09       	add	r9,r1
80009772:	f2 0e 01 0e 	sub	lr,r9,lr
80009776:	b0 1e       	st.h	r8[0x2],lr
80009778:	fc 09 14 10 	asr	r9,lr,0x10
8000977c:	40 1e       	lddsp	lr,sp[0x4]
8000977e:	fc 09 00 09 	add	r9,lr,r9
80009782:	b0 09       	st.h	r8[0x0],r9
80009784:	e0 01 16 10 	lsr	r1,r0,0x10
80009788:	2f c8       	sub	r8,-4
8000978a:	b1 49       	asr	r9,0x10
8000978c:	04 3a       	cp.w	r10,r2
8000978e:	fe 98 ff d8 	brls	8000973e <quorem+0x42>
80009792:	40 0b       	lddsp	r11,sp[0x0]
80009794:	58 0c       	cp.w	r12,0
80009796:	c0 f1       	brne	800097b4 <quorem+0xb8>
80009798:	ec c8 ff fb 	sub	r8,r6,-5
8000979c:	ee 08 00 28 	add	r8,r7,r8<<0x2
800097a0:	c0 28       	rjmp	800097a4 <quorem+0xa8>
800097a2:	20 16       	sub	r6,1
800097a4:	20 48       	sub	r8,4
800097a6:	08 38       	cp.w	r8,r4
800097a8:	e0 88 00 05 	brls	800097b2 <quorem+0xb6>
800097ac:	70 09       	ld.w	r9,r8[0x0]
800097ae:	58 09       	cp.w	r9,0
800097b0:	cf 90       	breq	800097a2 <quorem+0xa6>
800097b2:	8f 46       	st.w	r7[0x10],r6
800097b4:	0e 9c       	mov	r12,r7
800097b6:	e0 a0 0a d2 	rcall	8000ad5a <__mcmp>
800097ba:	c2 d5       	brlt	80009814 <quorem+0x118>
800097bc:	2f f5       	sub	r5,-1
800097be:	08 98       	mov	r8,r4
800097c0:	30 09       	mov	r9,0
800097c2:	07 0b       	ld.w	r11,r3++
800097c4:	f6 0a 16 10 	lsr	r10,r11,0x10
800097c8:	70 0c       	ld.w	r12,r8[0x0]
800097ca:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
800097ce:	f8 0e 16 10 	lsr	lr,r12,0x10
800097d2:	14 1e       	sub	lr,r10
800097d4:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
800097d8:	16 1a       	sub	r10,r11
800097da:	12 0a       	add	r10,r9
800097dc:	b0 1a       	st.h	r8[0x2],r10
800097de:	b1 4a       	asr	r10,0x10
800097e0:	fc 0a 00 09 	add	r9,lr,r10
800097e4:	b0 09       	st.h	r8[0x0],r9
800097e6:	2f c8       	sub	r8,-4
800097e8:	b1 49       	asr	r9,0x10
800097ea:	04 33       	cp.w	r3,r2
800097ec:	fe 98 ff eb 	brls	800097c2 <quorem+0xc6>
800097f0:	ec c8 ff fb 	sub	r8,r6,-5
800097f4:	ee 08 03 29 	ld.w	r9,r7[r8<<0x2]
800097f8:	58 09       	cp.w	r9,0
800097fa:	c0 d1       	brne	80009814 <quorem+0x118>
800097fc:	ee 08 00 28 	add	r8,r7,r8<<0x2
80009800:	c0 28       	rjmp	80009804 <quorem+0x108>
80009802:	20 16       	sub	r6,1
80009804:	20 48       	sub	r8,4
80009806:	08 38       	cp.w	r8,r4
80009808:	e0 88 00 05 	brls	80009812 <quorem+0x116>
8000980c:	70 09       	ld.w	r9,r8[0x0]
8000980e:	58 09       	cp.w	r9,0
80009810:	cf 90       	breq	80009802 <quorem+0x106>
80009812:	8f 46       	st.w	r7[0x10],r6
80009814:	0a 9c       	mov	r12,r5
80009816:	2f ed       	sub	sp,-8
80009818:	d8 32       	popm	r0-r7,pc
8000981a:	d7 03       	nop

8000981c <_dtoa_r>:
8000981c:	d4 31       	pushm	r0-r7,lr
8000981e:	21 ad       	sub	sp,104
80009820:	fa c4 ff 74 	sub	r4,sp,-140
80009824:	18 97       	mov	r7,r12
80009826:	16 95       	mov	r5,r11
80009828:	68 2c       	ld.w	r12,r4[0x8]
8000982a:	50 c9       	stdsp	sp[0x30],r9
8000982c:	68 16       	ld.w	r6,r4[0x4]
8000982e:	68 09       	ld.w	r9,r4[0x0]
80009830:	50 e8       	stdsp	sp[0x38],r8
80009832:	14 94       	mov	r4,r10
80009834:	51 2c       	stdsp	sp[0x48],r12
80009836:	fa e5 00 08 	st.d	sp[8],r4
8000983a:	51 59       	stdsp	sp[0x54],r9
8000983c:	6e 95       	ld.w	r5,r7[0x24]
8000983e:	58 05       	cp.w	r5,0
80009840:	c0 91       	brne	80009852 <_dtoa_r+0x36>
80009842:	31 0c       	mov	r12,16
80009844:	fe b0 e8 e8 	rcall	80006a14 <malloc>
80009848:	99 35       	st.w	r12[0xc],r5
8000984a:	8f 9c       	st.w	r7[0x24],r12
8000984c:	99 15       	st.w	r12[0x4],r5
8000984e:	99 25       	st.w	r12[0x8],r5
80009850:	99 05       	st.w	r12[0x0],r5
80009852:	6e 99       	ld.w	r9,r7[0x24]
80009854:	72 08       	ld.w	r8,r9[0x0]
80009856:	58 08       	cp.w	r8,0
80009858:	c0 f0       	breq	80009876 <_dtoa_r+0x5a>
8000985a:	72 1a       	ld.w	r10,r9[0x4]
8000985c:	91 1a       	st.w	r8[0x4],r10
8000985e:	30 1a       	mov	r10,1
80009860:	72 19       	ld.w	r9,r9[0x4]
80009862:	f4 09 09 49 	lsl	r9,r10,r9
80009866:	10 9b       	mov	r11,r8
80009868:	91 29       	st.w	r8[0x8],r9
8000986a:	0e 9c       	mov	r12,r7
8000986c:	e0 a0 0a 90 	rcall	8000ad8c <_Bfree>
80009870:	6e 98       	ld.w	r8,r7[0x24]
80009872:	30 09       	mov	r9,0
80009874:	91 09       	st.w	r8[0x0],r9
80009876:	40 28       	lddsp	r8,sp[0x8]
80009878:	10 94       	mov	r4,r8
8000987a:	58 08       	cp.w	r8,0
8000987c:	c0 64       	brge	80009888 <_dtoa_r+0x6c>
8000987e:	f1 d8 c0 1f 	bfextu	r8,r8,0x0,0x1f
80009882:	50 28       	stdsp	sp[0x8],r8
80009884:	30 18       	mov	r8,1
80009886:	c0 28       	rjmp	8000988a <_dtoa_r+0x6e>
80009888:	30 08       	mov	r8,0
8000988a:	8d 08       	st.w	r6[0x0],r8
8000988c:	fc 1c 7f f0 	movh	r12,0x7ff0
80009890:	40 26       	lddsp	r6,sp[0x8]
80009892:	0c 98       	mov	r8,r6
80009894:	e6 18 7f f0 	andh	r8,0x7ff0,COH
80009898:	18 38       	cp.w	r8,r12
8000989a:	c2 01       	brne	800098da <_dtoa_r+0xbe>
8000989c:	e0 68 27 0f 	mov	r8,9999
800098a0:	41 5b       	lddsp	r11,sp[0x54]
800098a2:	97 08       	st.w	r11[0x0],r8
800098a4:	40 3a       	lddsp	r10,sp[0xc]
800098a6:	58 0a       	cp.w	r10,0
800098a8:	c0 71       	brne	800098b6 <_dtoa_r+0x9a>
800098aa:	ed d6 c0 14 	bfextu	r6,r6,0x0,0x14
800098ae:	c0 41       	brne	800098b6 <_dtoa_r+0x9a>
800098b0:	fe cc bd 00 	sub	r12,pc,-17152
800098b4:	c0 38       	rjmp	800098ba <_dtoa_r+0x9e>
800098b6:	fe cc bc fa 	sub	r12,pc,-17158
800098ba:	41 29       	lddsp	r9,sp[0x48]
800098bc:	58 09       	cp.w	r9,0
800098be:	e0 80 05 9a 	breq	8000a3f2 <_dtoa_r+0xbd6>
800098c2:	f8 c8 ff fd 	sub	r8,r12,-3
800098c6:	f8 c9 ff f8 	sub	r9,r12,-8
800098ca:	11 8b       	ld.ub	r11,r8[0x0]
800098cc:	30 0a       	mov	r10,0
800098ce:	41 25       	lddsp	r5,sp[0x48]
800098d0:	f4 0b 18 00 	cp.b	r11,r10
800098d4:	f2 08 17 10 	movne	r8,r9
800098d8:	c1 68       	rjmp	80009904 <_dtoa_r+0xe8>
800098da:	fa ea 00 08 	ld.d	r10,sp[8]
800098de:	30 08       	mov	r8,0
800098e0:	fa eb 00 3c 	st.d	sp[60],r10
800098e4:	30 09       	mov	r9,0
800098e6:	e0 a0 10 c2 	rcall	8000ba6a <__avr32_f64_cmp_eq>
800098ea:	c1 00       	breq	8000990a <_dtoa_r+0xee>
800098ec:	30 18       	mov	r8,1
800098ee:	41 5a       	lddsp	r10,sp[0x54]
800098f0:	95 08       	st.w	r10[0x0],r8
800098f2:	fe cc be 66 	sub	r12,pc,-16794
800098f6:	41 29       	lddsp	r9,sp[0x48]
800098f8:	f8 08 00 08 	add	r8,r12,r8
800098fc:	58 09       	cp.w	r9,0
800098fe:	e0 80 05 7a 	breq	8000a3f2 <_dtoa_r+0xbd6>
80009902:	12 95       	mov	r5,r9
80009904:	8b 08       	st.w	r5[0x0],r8
80009906:	e0 8f 05 76 	bral	8000a3f2 <_dtoa_r+0xbd6>
8000990a:	fa c8 ff 9c 	sub	r8,sp,-100
8000990e:	fa c9 ff a0 	sub	r9,sp,-96
80009912:	fa ea 00 3c 	ld.d	r10,sp[60]
80009916:	0e 9c       	mov	r12,r7
80009918:	eb d6 c2 8b 	bfextu	r5,r6,0x14,0xb
8000991c:	e0 a0 0a 8a 	rcall	8000ae30 <__d2b>
80009920:	18 93       	mov	r3,r12
80009922:	58 05       	cp.w	r5,0
80009924:	c0 d0       	breq	8000993e <_dtoa_r+0x122>
80009926:	fa ea 00 3c 	ld.d	r10,sp[60]
8000992a:	30 04       	mov	r4,0
8000992c:	f1 db c0 14 	bfextu	r8,r11,0x0,0x14
80009930:	ea c5 03 ff 	sub	r5,r5,1023
80009934:	10 9b       	mov	r11,r8
80009936:	51 74       	stdsp	sp[0x5c],r4
80009938:	ea 1b 3f f0 	orh	r11,0x3ff0
8000993c:	c2 58       	rjmp	80009986 <_dtoa_r+0x16a>
8000993e:	41 88       	lddsp	r8,sp[0x60]
80009940:	41 9c       	lddsp	r12,sp[0x64]
80009942:	10 0c       	add	r12,r8
80009944:	f8 c5 fb ce 	sub	r5,r12,-1074
80009948:	e0 45 00 20 	cp.w	r5,32
8000994c:	e0 8a 00 0e 	brle	80009968 <_dtoa_r+0x14c>
80009950:	f8 cc fb ee 	sub	r12,r12,-1042
80009954:	40 3b       	lddsp	r11,sp[0xc]
80009956:	ea 08 11 40 	rsub	r8,r5,64
8000995a:	f6 0c 0a 4c 	lsr	r12,r11,r12
8000995e:	ec 08 09 46 	lsl	r6,r6,r8
80009962:	0c 4c       	or	r12,r6
80009964:	c0 78       	rjmp	80009972 <_dtoa_r+0x156>
80009966:	d7 03       	nop
80009968:	ea 0c 11 20 	rsub	r12,r5,32
8000996c:	40 3a       	lddsp	r10,sp[0xc]
8000996e:	f4 0c 09 4c 	lsl	r12,r10,r12
80009972:	e0 a0 10 08 	rcall	8000b982 <__avr32_u32_to_f64>
80009976:	fc 18 fe 10 	movh	r8,0xfe10
8000997a:	30 19       	mov	r9,1
8000997c:	ea c5 04 33 	sub	r5,r5,1075
80009980:	f0 0b 00 0b 	add	r11,r8,r11
80009984:	51 79       	stdsp	sp[0x5c],r9
80009986:	30 08       	mov	r8,0
80009988:	fc 19 3f f8 	movh	r9,0x3ff8
8000998c:	e0 a0 0e 90 	rcall	8000b6ac <__avr32_f64_sub>
80009990:	e0 68 43 61 	mov	r8,17249
80009994:	ea 18 63 6f 	orh	r8,0x636f
80009998:	e0 69 87 a7 	mov	r9,34727
8000999c:	ea 19 3f d2 	orh	r9,0x3fd2
800099a0:	e0 a0 0d 9a 	rcall	8000b4d4 <__avr32_f64_mul>
800099a4:	e0 68 c8 b3 	mov	r8,51379
800099a8:	ea 18 8b 60 	orh	r8,0x8b60
800099ac:	e0 69 8a 28 	mov	r9,35368
800099b0:	ea 19 3f c6 	orh	r9,0x3fc6
800099b4:	e0 a0 0f 4a 	rcall	8000b848 <__avr32_f64_add>
800099b8:	0a 9c       	mov	r12,r5
800099ba:	14 90       	mov	r0,r10
800099bc:	16 91       	mov	r1,r11
800099be:	e0 a0 0f e6 	rcall	8000b98a <__avr32_s32_to_f64>
800099c2:	e0 68 79 fb 	mov	r8,31227
800099c6:	ea 18 50 9f 	orh	r8,0x509f
800099ca:	e0 69 44 13 	mov	r9,17427
800099ce:	ea 19 3f d3 	orh	r9,0x3fd3
800099d2:	e0 a0 0d 81 	rcall	8000b4d4 <__avr32_f64_mul>
800099d6:	14 98       	mov	r8,r10
800099d8:	16 99       	mov	r9,r11
800099da:	00 9a       	mov	r10,r0
800099dc:	02 9b       	mov	r11,r1
800099de:	e0 a0 0f 35 	rcall	8000b848 <__avr32_f64_add>
800099e2:	14 90       	mov	r0,r10
800099e4:	16 91       	mov	r1,r11
800099e6:	e0 a0 0f bb 	rcall	8000b95c <__avr32_f64_to_s32>
800099ea:	30 08       	mov	r8,0
800099ec:	18 96       	mov	r6,r12
800099ee:	30 09       	mov	r9,0
800099f0:	00 9a       	mov	r10,r0
800099f2:	02 9b       	mov	r11,r1
800099f4:	e0 a0 10 82 	rcall	8000baf8 <__avr32_f64_cmp_lt>
800099f8:	c0 c0       	breq	80009a10 <_dtoa_r+0x1f4>
800099fa:	0c 9c       	mov	r12,r6
800099fc:	e0 a0 0f c7 	rcall	8000b98a <__avr32_s32_to_f64>
80009a00:	14 98       	mov	r8,r10
80009a02:	16 99       	mov	r9,r11
80009a04:	00 9a       	mov	r10,r0
80009a06:	02 9b       	mov	r11,r1
80009a08:	e0 a0 10 31 	rcall	8000ba6a <__avr32_f64_cmp_eq>
80009a0c:	f7 b6 00 01 	subeq	r6,1
80009a10:	59 66       	cp.w	r6,22
80009a12:	e0 88 00 05 	brls	80009a1c <_dtoa_r+0x200>
80009a16:	30 18       	mov	r8,1
80009a18:	51 48       	stdsp	sp[0x50],r8
80009a1a:	c1 38       	rjmp	80009a40 <_dtoa_r+0x224>
80009a1c:	fe c8 bd ac 	sub	r8,pc,-16980
80009a20:	fa ea 00 3c 	ld.d	r10,sp[60]
80009a24:	f0 06 02 38 	ld.d	r8,r8[r6<<0x3]
80009a28:	e0 a0 10 68 	rcall	8000baf8 <__avr32_f64_cmp_lt>
80009a2c:	f9 b4 00 00 	moveq	r4,0
80009a30:	fb f4 0a 14 	st.weq	sp[0x50],r4
80009a34:	f7 b6 01 01 	subne	r6,1
80009a38:	f9 bc 01 00 	movne	r12,0
80009a3c:	fb fc 1a 14 	st.wne	sp[0x50],r12
80009a40:	41 90       	lddsp	r0,sp[0x64]
80009a42:	20 10       	sub	r0,1
80009a44:	0a 10       	sub	r0,r5
80009a46:	c0 46       	brmi	80009a4e <_dtoa_r+0x232>
80009a48:	50 40       	stdsp	sp[0x10],r0
80009a4a:	30 00       	mov	r0,0
80009a4c:	c0 48       	rjmp	80009a54 <_dtoa_r+0x238>
80009a4e:	30 0b       	mov	r11,0
80009a50:	5c 30       	neg	r0
80009a52:	50 4b       	stdsp	sp[0x10],r11
80009a54:	ec 02 11 00 	rsub	r2,r6,0
80009a58:	58 06       	cp.w	r6,0
80009a5a:	fb fa 40 04 	ld.wge	r10,sp[0x10]
80009a5e:	f5 d6 e4 0a 	addge	r10,r10,r6
80009a62:	fb fa 4a 04 	st.wge	sp[0x10],r10
80009a66:	fb f6 4a 11 	st.wge	sp[0x44],r6
80009a6a:	f9 b2 04 00 	movge	r2,0
80009a6e:	e1 d6 e5 10 	sublt	r0,r0,r6
80009a72:	f9 b9 05 00 	movlt	r9,0
80009a76:	fb f9 5a 11 	st.wlt	sp[0x44],r9
80009a7a:	40 c8       	lddsp	r8,sp[0x30]
80009a7c:	58 98       	cp.w	r8,9
80009a7e:	e0 8b 00 20 	brhi	80009abe <_dtoa_r+0x2a2>
80009a82:	58 58       	cp.w	r8,5
80009a84:	f9 b4 0a 01 	movle	r4,1
80009a88:	fb f5 90 0c 	ld.wgt	r5,sp[0x30]
80009a8c:	f7 b5 09 04 	subgt	r5,4
80009a90:	fb f5 9a 0c 	st.wgt	sp[0x30],r5
80009a94:	f9 b4 09 00 	movgt	r4,0
80009a98:	40 cc       	lddsp	r12,sp[0x30]
80009a9a:	58 3c       	cp.w	r12,3
80009a9c:	c2 d0       	breq	80009af6 <_dtoa_r+0x2da>
80009a9e:	e0 89 00 05 	brgt	80009aa8 <_dtoa_r+0x28c>
80009aa2:	58 2c       	cp.w	r12,2
80009aa4:	c1 01       	brne	80009ac4 <_dtoa_r+0x2a8>
80009aa6:	c1 88       	rjmp	80009ad6 <_dtoa_r+0x2ba>
80009aa8:	40 cb       	lddsp	r11,sp[0x30]
80009aaa:	58 4b       	cp.w	r11,4
80009aac:	c0 60       	breq	80009ab8 <_dtoa_r+0x29c>
80009aae:	58 5b       	cp.w	r11,5
80009ab0:	c0 a1       	brne	80009ac4 <_dtoa_r+0x2a8>
80009ab2:	30 1a       	mov	r10,1
80009ab4:	50 da       	stdsp	sp[0x34],r10
80009ab6:	c2 28       	rjmp	80009afa <_dtoa_r+0x2de>
80009ab8:	30 19       	mov	r9,1
80009aba:	50 d9       	stdsp	sp[0x34],r9
80009abc:	c0 f8       	rjmp	80009ada <_dtoa_r+0x2be>
80009abe:	30 08       	mov	r8,0
80009ac0:	30 14       	mov	r4,1
80009ac2:	50 c8       	stdsp	sp[0x30],r8
80009ac4:	3f f5       	mov	r5,-1
80009ac6:	30 1c       	mov	r12,1
80009ac8:	30 0b       	mov	r11,0
80009aca:	50 95       	stdsp	sp[0x24],r5
80009acc:	50 dc       	stdsp	sp[0x34],r12
80009ace:	0a 91       	mov	r1,r5
80009ad0:	31 28       	mov	r8,18
80009ad2:	50 eb       	stdsp	sp[0x38],r11
80009ad4:	c2 08       	rjmp	80009b14 <_dtoa_r+0x2f8>
80009ad6:	30 0a       	mov	r10,0
80009ad8:	50 da       	stdsp	sp[0x34],r10
80009ada:	40 e9       	lddsp	r9,sp[0x38]
80009adc:	58 09       	cp.w	r9,0
80009ade:	e0 89 00 07 	brgt	80009aec <_dtoa_r+0x2d0>
80009ae2:	30 18       	mov	r8,1
80009ae4:	50 98       	stdsp	sp[0x24],r8
80009ae6:	10 91       	mov	r1,r8
80009ae8:	50 e8       	stdsp	sp[0x38],r8
80009aea:	c1 58       	rjmp	80009b14 <_dtoa_r+0x2f8>
80009aec:	40 e5       	lddsp	r5,sp[0x38]
80009aee:	50 95       	stdsp	sp[0x24],r5
80009af0:	0a 91       	mov	r1,r5
80009af2:	0a 98       	mov	r8,r5
80009af4:	c1 08       	rjmp	80009b14 <_dtoa_r+0x2f8>
80009af6:	30 0c       	mov	r12,0
80009af8:	50 dc       	stdsp	sp[0x34],r12
80009afa:	40 eb       	lddsp	r11,sp[0x38]
80009afc:	ec 0b 00 0b 	add	r11,r6,r11
80009b00:	50 9b       	stdsp	sp[0x24],r11
80009b02:	16 98       	mov	r8,r11
80009b04:	2f f8       	sub	r8,-1
80009b06:	58 08       	cp.w	r8,0
80009b08:	e0 89 00 05 	brgt	80009b12 <_dtoa_r+0x2f6>
80009b0c:	10 91       	mov	r1,r8
80009b0e:	30 18       	mov	r8,1
80009b10:	c0 28       	rjmp	80009b14 <_dtoa_r+0x2f8>
80009b12:	10 91       	mov	r1,r8
80009b14:	30 09       	mov	r9,0
80009b16:	6e 9a       	ld.w	r10,r7[0x24]
80009b18:	95 19       	st.w	r10[0x4],r9
80009b1a:	30 49       	mov	r9,4
80009b1c:	c0 68       	rjmp	80009b28 <_dtoa_r+0x30c>
80009b1e:	d7 03       	nop
80009b20:	6a 1a       	ld.w	r10,r5[0x4]
80009b22:	a1 79       	lsl	r9,0x1
80009b24:	2f fa       	sub	r10,-1
80009b26:	8b 1a       	st.w	r5[0x4],r10
80009b28:	6e 95       	ld.w	r5,r7[0x24]
80009b2a:	f2 ca ff ec 	sub	r10,r9,-20
80009b2e:	10 3a       	cp.w	r10,r8
80009b30:	fe 98 ff f8 	brls	80009b20 <_dtoa_r+0x304>
80009b34:	6a 1b       	ld.w	r11,r5[0x4]
80009b36:	0e 9c       	mov	r12,r7
80009b38:	e0 a0 09 44 	rcall	8000adc0 <_Balloc>
80009b3c:	58 e1       	cp.w	r1,14
80009b3e:	5f 88       	srls	r8
80009b40:	8b 0c       	st.w	r5[0x0],r12
80009b42:	f1 e4 00 04 	and	r4,r8,r4
80009b46:	6e 98       	ld.w	r8,r7[0x24]
80009b48:	70 08       	ld.w	r8,r8[0x0]
80009b4a:	50 88       	stdsp	sp[0x20],r8
80009b4c:	e0 80 01 82 	breq	80009e50 <_dtoa_r+0x634>
80009b50:	58 06       	cp.w	r6,0
80009b52:	e0 8a 00 43 	brle	80009bd8 <_dtoa_r+0x3bc>
80009b56:	f3 d6 c0 04 	bfextu	r9,r6,0x0,0x4
80009b5a:	fe c8 be ea 	sub	r8,pc,-16662
80009b5e:	f0 09 02 34 	ld.d	r4,r8[r9<<0x3]
80009b62:	fa e5 00 18 	st.d	sp[24],r4
80009b66:	ec 04 14 04 	asr	r4,r6,0x4
80009b6a:	ed b4 00 04 	bld	r4,0x4
80009b6e:	c0 30       	breq	80009b74 <_dtoa_r+0x358>
80009b70:	30 25       	mov	r5,2
80009b72:	c1 08       	rjmp	80009b92 <_dtoa_r+0x376>
80009b74:	fe c8 be 3c 	sub	r8,pc,-16836
80009b78:	f0 e8 00 20 	ld.d	r8,r8[32]
80009b7c:	fa ea 00 3c 	ld.d	r10,sp[60]
80009b80:	e9 d4 c0 04 	bfextu	r4,r4,0x0,0x4
80009b84:	e0 a0 0f ee 	rcall	8000bb60 <__avr32_f64_div>
80009b88:	30 35       	mov	r5,3
80009b8a:	14 98       	mov	r8,r10
80009b8c:	16 99       	mov	r9,r11
80009b8e:	fa e9 00 08 	st.d	sp[8],r8
80009b92:	fe cc be 5a 	sub	r12,pc,-16806
80009b96:	50 a3       	stdsp	sp[0x28],r3
80009b98:	0c 93       	mov	r3,r6
80009b9a:	18 96       	mov	r6,r12
80009b9c:	c0 f8       	rjmp	80009bba <_dtoa_r+0x39e>
80009b9e:	fa ea 00 18 	ld.d	r10,sp[24]
80009ba2:	ed b4 00 00 	bld	r4,0x0
80009ba6:	c0 81       	brne	80009bb6 <_dtoa_r+0x39a>
80009ba8:	ec e8 00 00 	ld.d	r8,r6[0]
80009bac:	2f f5       	sub	r5,-1
80009bae:	e0 a0 0c 93 	rcall	8000b4d4 <__avr32_f64_mul>
80009bb2:	fa eb 00 18 	st.d	sp[24],r10
80009bb6:	a1 54       	asr	r4,0x1
80009bb8:	2f 86       	sub	r6,-8
80009bba:	58 04       	cp.w	r4,0
80009bbc:	cf 11       	brne	80009b9e <_dtoa_r+0x382>
80009bbe:	fa e8 00 18 	ld.d	r8,sp[24]
80009bc2:	fa ea 00 08 	ld.d	r10,sp[8]
80009bc6:	06 96       	mov	r6,r3
80009bc8:	e0 a0 0f cc 	rcall	8000bb60 <__avr32_f64_div>
80009bcc:	40 a3       	lddsp	r3,sp[0x28]
80009bce:	14 98       	mov	r8,r10
80009bd0:	16 99       	mov	r9,r11
80009bd2:	fa e9 00 08 	st.d	sp[8],r8
80009bd6:	c2 f8       	rjmp	80009c34 <_dtoa_r+0x418>
80009bd8:	ec 08 11 00 	rsub	r8,r6,0
80009bdc:	c0 31       	brne	80009be2 <_dtoa_r+0x3c6>
80009bde:	30 25       	mov	r5,2
80009be0:	c2 a8       	rjmp	80009c34 <_dtoa_r+0x418>
80009be2:	fe cc be aa 	sub	r12,pc,-16726
80009be6:	f0 04 14 04 	asr	r4,r8,0x4
80009bea:	50 1c       	stdsp	sp[0x4],r12
80009bec:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
80009bf0:	fe c9 bf 80 	sub	r9,pc,-16512
80009bf4:	fa ea 00 3c 	ld.d	r10,sp[60]
80009bf8:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
80009bfc:	e0 a0 0c 6c 	rcall	8000b4d4 <__avr32_f64_mul>
80009c00:	40 1c       	lddsp	r12,sp[0x4]
80009c02:	50 63       	stdsp	sp[0x18],r3
80009c04:	30 25       	mov	r5,2
80009c06:	0c 93       	mov	r3,r6
80009c08:	fa eb 00 08 	st.d	sp[8],r10
80009c0c:	18 96       	mov	r6,r12
80009c0e:	c0 f8       	rjmp	80009c2c <_dtoa_r+0x410>
80009c10:	fa ea 00 08 	ld.d	r10,sp[8]
80009c14:	ed b4 00 00 	bld	r4,0x0
80009c18:	c0 81       	brne	80009c28 <_dtoa_r+0x40c>
80009c1a:	ec e8 00 00 	ld.d	r8,r6[0]
80009c1e:	2f f5       	sub	r5,-1
80009c20:	e0 a0 0c 5a 	rcall	8000b4d4 <__avr32_f64_mul>
80009c24:	fa eb 00 08 	st.d	sp[8],r10
80009c28:	a1 54       	asr	r4,0x1
80009c2a:	2f 86       	sub	r6,-8
80009c2c:	58 04       	cp.w	r4,0
80009c2e:	cf 11       	brne	80009c10 <_dtoa_r+0x3f4>
80009c30:	06 96       	mov	r6,r3
80009c32:	40 63       	lddsp	r3,sp[0x18]
80009c34:	41 4a       	lddsp	r10,sp[0x50]
80009c36:	58 0a       	cp.w	r10,0
80009c38:	c2 a0       	breq	80009c8c <_dtoa_r+0x470>
80009c3a:	fa e8 00 08 	ld.d	r8,sp[8]
80009c3e:	58 01       	cp.w	r1,0
80009c40:	5f 94       	srgt	r4
80009c42:	fa e9 00 18 	st.d	sp[24],r8
80009c46:	30 08       	mov	r8,0
80009c48:	fc 19 3f f0 	movh	r9,0x3ff0
80009c4c:	fa ea 00 18 	ld.d	r10,sp[24]
80009c50:	e0 a0 0f 54 	rcall	8000baf8 <__avr32_f64_cmp_lt>
80009c54:	f9 bc 00 00 	moveq	r12,0
80009c58:	f9 bc 01 01 	movne	r12,1
80009c5c:	e9 ec 00 0c 	and	r12,r4,r12
80009c60:	c1 60       	breq	80009c8c <_dtoa_r+0x470>
80009c62:	40 98       	lddsp	r8,sp[0x24]
80009c64:	58 08       	cp.w	r8,0
80009c66:	e0 8a 00 f1 	brle	80009e48 <_dtoa_r+0x62c>
80009c6a:	30 08       	mov	r8,0
80009c6c:	fc 19 40 24 	movh	r9,0x4024
80009c70:	ec c4 00 01 	sub	r4,r6,1
80009c74:	fa ea 00 18 	ld.d	r10,sp[24]
80009c78:	2f f5       	sub	r5,-1
80009c7a:	50 64       	stdsp	sp[0x18],r4
80009c7c:	e0 a0 0c 2c 	rcall	8000b4d4 <__avr32_f64_mul>
80009c80:	40 94       	lddsp	r4,sp[0x24]
80009c82:	14 98       	mov	r8,r10
80009c84:	16 99       	mov	r9,r11
80009c86:	fa e9 00 08 	st.d	sp[8],r8
80009c8a:	c0 38       	rjmp	80009c90 <_dtoa_r+0x474>
80009c8c:	50 66       	stdsp	sp[0x18],r6
80009c8e:	02 94       	mov	r4,r1
80009c90:	0a 9c       	mov	r12,r5
80009c92:	e0 a0 0e 7c 	rcall	8000b98a <__avr32_s32_to_f64>
80009c96:	fa e8 00 08 	ld.d	r8,sp[8]
80009c9a:	e0 a0 0c 1d 	rcall	8000b4d4 <__avr32_f64_mul>
80009c9e:	30 08       	mov	r8,0
80009ca0:	fc 19 40 1c 	movh	r9,0x401c
80009ca4:	e0 a0 0d d2 	rcall	8000b848 <__avr32_f64_add>
80009ca8:	14 98       	mov	r8,r10
80009caa:	16 99       	mov	r9,r11
80009cac:	fa e9 00 28 	st.d	sp[40],r8
80009cb0:	fc 18 fc c0 	movh	r8,0xfcc0
80009cb4:	40 a5       	lddsp	r5,sp[0x28]
80009cb6:	10 05       	add	r5,r8
80009cb8:	50 a5       	stdsp	sp[0x28],r5
80009cba:	58 04       	cp.w	r4,0
80009cbc:	c2 11       	brne	80009cfe <_dtoa_r+0x4e2>
80009cbe:	fa ea 00 08 	ld.d	r10,sp[8]
80009cc2:	30 08       	mov	r8,0
80009cc4:	fc 19 40 14 	movh	r9,0x4014
80009cc8:	e0 a0 0c f2 	rcall	8000b6ac <__avr32_f64_sub>
80009ccc:	40 bc       	lddsp	r12,sp[0x2c]
80009cce:	fa eb 00 08 	st.d	sp[8],r10
80009cd2:	14 98       	mov	r8,r10
80009cd4:	16 99       	mov	r9,r11
80009cd6:	18 9a       	mov	r10,r12
80009cd8:	0a 9b       	mov	r11,r5
80009cda:	e0 a0 0f 0f 	rcall	8000baf8 <__avr32_f64_cmp_lt>
80009cde:	e0 81 02 54 	brne	8000a186 <_dtoa_r+0x96a>
80009ce2:	0a 98       	mov	r8,r5
80009ce4:	40 b9       	lddsp	r9,sp[0x2c]
80009ce6:	ee 18 80 00 	eorh	r8,0x8000
80009cea:	fa ea 00 08 	ld.d	r10,sp[8]
80009cee:	10 95       	mov	r5,r8
80009cf0:	12 98       	mov	r8,r9
80009cf2:	0a 99       	mov	r9,r5
80009cf4:	e0 a0 0f 02 	rcall	8000baf8 <__avr32_f64_cmp_lt>
80009cf8:	e0 81 02 3e 	brne	8000a174 <_dtoa_r+0x958>
80009cfc:	ca 68       	rjmp	80009e48 <_dtoa_r+0x62c>
80009cfe:	fe c9 c0 8e 	sub	r9,pc,-16242
80009d02:	e8 c8 00 01 	sub	r8,r4,1
80009d06:	40 d5       	lddsp	r5,sp[0x34]
80009d08:	58 05       	cp.w	r5,0
80009d0a:	c4 f0       	breq	80009da8 <_dtoa_r+0x58c>
80009d0c:	30 0c       	mov	r12,0
80009d0e:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
80009d12:	51 3c       	stdsp	sp[0x4c],r12
80009d14:	30 0a       	mov	r10,0
80009d16:	fc 1b 3f e0 	movh	r11,0x3fe0
80009d1a:	e0 a0 0f 23 	rcall	8000bb60 <__avr32_f64_div>
80009d1e:	fa e8 00 28 	ld.d	r8,sp[40]
80009d22:	40 85       	lddsp	r5,sp[0x20]
80009d24:	e0 a0 0c c4 	rcall	8000b6ac <__avr32_f64_sub>
80009d28:	fa eb 00 28 	st.d	sp[40],r10
80009d2c:	fa ea 00 08 	ld.d	r10,sp[8]
80009d30:	e0 a0 0e 16 	rcall	8000b95c <__avr32_f64_to_s32>
80009d34:	51 6c       	stdsp	sp[0x58],r12
80009d36:	e0 a0 0e 2a 	rcall	8000b98a <__avr32_s32_to_f64>
80009d3a:	14 98       	mov	r8,r10
80009d3c:	16 99       	mov	r9,r11
80009d3e:	fa ea 00 08 	ld.d	r10,sp[8]
80009d42:	e0 a0 0c b5 	rcall	8000b6ac <__avr32_f64_sub>
80009d46:	fa eb 00 08 	st.d	sp[8],r10
80009d4a:	41 68       	lddsp	r8,sp[0x58]
80009d4c:	2d 08       	sub	r8,-48
80009d4e:	0a c8       	st.b	r5++,r8
80009d50:	41 39       	lddsp	r9,sp[0x4c]
80009d52:	2f f9       	sub	r9,-1
80009d54:	51 39       	stdsp	sp[0x4c],r9
80009d56:	fa e8 00 28 	ld.d	r8,sp[40]
80009d5a:	e0 a0 0e cf 	rcall	8000baf8 <__avr32_f64_cmp_lt>
80009d5e:	e0 81 03 39 	brne	8000a3d0 <_dtoa_r+0xbb4>
80009d62:	fa e8 00 08 	ld.d	r8,sp[8]
80009d66:	30 0a       	mov	r10,0
80009d68:	fc 1b 3f f0 	movh	r11,0x3ff0
80009d6c:	e0 a0 0c a0 	rcall	8000b6ac <__avr32_f64_sub>
80009d70:	fa e8 00 28 	ld.d	r8,sp[40]
80009d74:	e0 a0 0e c2 	rcall	8000baf8 <__avr32_f64_cmp_lt>
80009d78:	fa ea 00 28 	ld.d	r10,sp[40]
80009d7c:	30 08       	mov	r8,0
80009d7e:	fc 19 40 24 	movh	r9,0x4024
80009d82:	e0 81 00 da 	brne	80009f36 <_dtoa_r+0x71a>
80009d86:	41 3c       	lddsp	r12,sp[0x4c]
80009d88:	08 3c       	cp.w	r12,r4
80009d8a:	c5 f4       	brge	80009e48 <_dtoa_r+0x62c>
80009d8c:	e0 a0 0b a4 	rcall	8000b4d4 <__avr32_f64_mul>
80009d90:	30 08       	mov	r8,0
80009d92:	fa eb 00 28 	st.d	sp[40],r10
80009d96:	fc 19 40 24 	movh	r9,0x4024
80009d9a:	fa ea 00 08 	ld.d	r10,sp[8]
80009d9e:	e0 a0 0b 9b 	rcall	8000b4d4 <__avr32_f64_mul>
80009da2:	fa eb 00 08 	st.d	sp[8],r10
80009da6:	cc 3b       	rjmp	80009d2c <_dtoa_r+0x510>
80009da8:	40 85       	lddsp	r5,sp[0x20]
80009daa:	08 05       	add	r5,r4
80009dac:	f2 08 02 3a 	ld.d	r10,r9[r8<<0x3]
80009db0:	51 35       	stdsp	sp[0x4c],r5
80009db2:	fa e8 00 28 	ld.d	r8,sp[40]
80009db6:	40 85       	lddsp	r5,sp[0x20]
80009db8:	e0 a0 0b 8e 	rcall	8000b4d4 <__avr32_f64_mul>
80009dbc:	fa eb 00 28 	st.d	sp[40],r10
80009dc0:	fa ea 00 08 	ld.d	r10,sp[8]
80009dc4:	e0 a0 0d cc 	rcall	8000b95c <__avr32_f64_to_s32>
80009dc8:	51 6c       	stdsp	sp[0x58],r12
80009dca:	e0 a0 0d e0 	rcall	8000b98a <__avr32_s32_to_f64>
80009dce:	14 98       	mov	r8,r10
80009dd0:	16 99       	mov	r9,r11
80009dd2:	fa ea 00 08 	ld.d	r10,sp[8]
80009dd6:	e0 a0 0c 6b 	rcall	8000b6ac <__avr32_f64_sub>
80009dda:	fa eb 00 08 	st.d	sp[8],r10
80009dde:	41 68       	lddsp	r8,sp[0x58]
80009de0:	2d 08       	sub	r8,-48
80009de2:	0a c8       	st.b	r5++,r8
80009de4:	41 3c       	lddsp	r12,sp[0x4c]
80009de6:	18 35       	cp.w	r5,r12
80009de8:	c2 81       	brne	80009e38 <_dtoa_r+0x61c>
80009dea:	30 08       	mov	r8,0
80009dec:	fc 19 3f e0 	movh	r9,0x3fe0
80009df0:	fa ea 00 28 	ld.d	r10,sp[40]
80009df4:	e0 a0 0d 2a 	rcall	8000b848 <__avr32_f64_add>
80009df8:	40 85       	lddsp	r5,sp[0x20]
80009dfa:	fa e8 00 08 	ld.d	r8,sp[8]
80009dfe:	08 05       	add	r5,r4
80009e00:	e0 a0 0e 7c 	rcall	8000baf8 <__avr32_f64_cmp_lt>
80009e04:	e0 81 00 99 	brne	80009f36 <_dtoa_r+0x71a>
80009e08:	fa e8 00 28 	ld.d	r8,sp[40]
80009e0c:	30 0a       	mov	r10,0
80009e0e:	fc 1b 3f e0 	movh	r11,0x3fe0
80009e12:	e0 a0 0c 4d 	rcall	8000b6ac <__avr32_f64_sub>
80009e16:	14 98       	mov	r8,r10
80009e18:	16 99       	mov	r9,r11
80009e1a:	fa ea 00 08 	ld.d	r10,sp[8]
80009e1e:	e0 a0 0e 6d 	rcall	8000baf8 <__avr32_f64_cmp_lt>
80009e22:	c1 30       	breq	80009e48 <_dtoa_r+0x62c>
80009e24:	33 09       	mov	r9,48
80009e26:	0a 98       	mov	r8,r5
80009e28:	11 7a       	ld.ub	r10,--r8
80009e2a:	f2 0a 18 00 	cp.b	r10,r9
80009e2e:	e0 81 02 d1 	brne	8000a3d0 <_dtoa_r+0xbb4>
80009e32:	10 95       	mov	r5,r8
80009e34:	cf 9b       	rjmp	80009e26 <_dtoa_r+0x60a>
80009e36:	d7 03       	nop
80009e38:	30 08       	mov	r8,0
80009e3a:	fc 19 40 24 	movh	r9,0x4024
80009e3e:	e0 a0 0b 4b 	rcall	8000b4d4 <__avr32_f64_mul>
80009e42:	fa eb 00 08 	st.d	sp[8],r10
80009e46:	cb db       	rjmp	80009dc0 <_dtoa_r+0x5a4>
80009e48:	fa ea 00 3c 	ld.d	r10,sp[60]
80009e4c:	fa eb 00 08 	st.d	sp[8],r10
80009e50:	58 e6       	cp.w	r6,14
80009e52:	5f ab       	srle	r11
80009e54:	41 8a       	lddsp	r10,sp[0x60]
80009e56:	30 08       	mov	r8,0
80009e58:	f4 09 11 ff 	rsub	r9,r10,-1
80009e5c:	f7 e9 03 f9 	and	r9,r11,r9>>0x1f
80009e60:	f0 09 18 00 	cp.b	r9,r8
80009e64:	e0 80 00 82 	breq	80009f68 <_dtoa_r+0x74c>
80009e68:	40 ea       	lddsp	r10,sp[0x38]
80009e6a:	58 01       	cp.w	r1,0
80009e6c:	5f a9       	srle	r9
80009e6e:	f3 ea 03 f9 	and	r9,r9,r10>>0x1f
80009e72:	fe ca c2 02 	sub	r10,pc,-15870
80009e76:	f4 06 02 34 	ld.d	r4,r10[r6<<0x3]
80009e7a:	fa e5 00 10 	st.d	sp[16],r4
80009e7e:	f0 09 18 00 	cp.b	r9,r8
80009e82:	c1 40       	breq	80009eaa <_dtoa_r+0x68e>
80009e84:	58 01       	cp.w	r1,0
80009e86:	e0 81 01 77 	brne	8000a174 <_dtoa_r+0x958>
80009e8a:	30 08       	mov	r8,0
80009e8c:	fc 19 40 14 	movh	r9,0x4014
80009e90:	08 9a       	mov	r10,r4
80009e92:	0a 9b       	mov	r11,r5
80009e94:	e0 a0 0b 20 	rcall	8000b4d4 <__avr32_f64_mul>
80009e98:	fa e8 00 08 	ld.d	r8,sp[8]
80009e9c:	e0 a0 0d fa 	rcall	8000ba90 <__avr32_f64_cmp_ge>
80009ea0:	e0 81 01 6a 	brne	8000a174 <_dtoa_r+0x958>
80009ea4:	02 92       	mov	r2,r1
80009ea6:	e0 8f 01 72 	bral	8000a18a <_dtoa_r+0x96e>
80009eaa:	40 85       	lddsp	r5,sp[0x20]
80009eac:	30 14       	mov	r4,1
80009eae:	fa e8 00 10 	ld.d	r8,sp[16]
80009eb2:	fa ea 00 08 	ld.d	r10,sp[8]
80009eb6:	e0 a0 0e 55 	rcall	8000bb60 <__avr32_f64_div>
80009eba:	e0 a0 0d 51 	rcall	8000b95c <__avr32_f64_to_s32>
80009ebe:	18 92       	mov	r2,r12
80009ec0:	e0 a0 0d 65 	rcall	8000b98a <__avr32_s32_to_f64>
80009ec4:	fa e8 00 10 	ld.d	r8,sp[16]
80009ec8:	e0 a0 0b 06 	rcall	8000b4d4 <__avr32_f64_mul>
80009ecc:	14 98       	mov	r8,r10
80009ece:	16 99       	mov	r9,r11
80009ed0:	fa ea 00 08 	ld.d	r10,sp[8]
80009ed4:	e0 a0 0b ec 	rcall	8000b6ac <__avr32_f64_sub>
80009ed8:	fa eb 00 08 	st.d	sp[8],r10
80009edc:	e4 c8 ff d0 	sub	r8,r2,-48
80009ee0:	0a c8       	st.b	r5++,r8
80009ee2:	fc 19 40 24 	movh	r9,0x4024
80009ee6:	30 08       	mov	r8,0
80009ee8:	02 34       	cp.w	r4,r1
80009eea:	c3 31       	brne	80009f50 <_dtoa_r+0x734>
80009eec:	fa e8 00 08 	ld.d	r8,sp[8]
80009ef0:	e0 a0 0c ac 	rcall	8000b848 <__avr32_f64_add>
80009ef4:	16 91       	mov	r1,r11
80009ef6:	14 90       	mov	r0,r10
80009ef8:	14 98       	mov	r8,r10
80009efa:	02 99       	mov	r9,r1
80009efc:	fa ea 00 10 	ld.d	r10,sp[16]
80009f00:	e0 a0 0d fc 	rcall	8000baf8 <__avr32_f64_cmp_lt>
80009f04:	c1 a1       	brne	80009f38 <_dtoa_r+0x71c>
80009f06:	fa e8 00 10 	ld.d	r8,sp[16]
80009f0a:	00 9a       	mov	r10,r0
80009f0c:	02 9b       	mov	r11,r1
80009f0e:	e0 a0 0d ae 	rcall	8000ba6a <__avr32_f64_cmp_eq>
80009f12:	e0 80 02 5e 	breq	8000a3ce <_dtoa_r+0xbb2>
80009f16:	e5 d2 c0 01 	bfextu	r2,r2,0x0,0x1
80009f1a:	c0 f1       	brne	80009f38 <_dtoa_r+0x71c>
80009f1c:	e0 8f 02 59 	bral	8000a3ce <_dtoa_r+0xbb2>
80009f20:	40 8a       	lddsp	r10,sp[0x20]
80009f22:	14 38       	cp.w	r8,r10
80009f24:	c0 30       	breq	80009f2a <_dtoa_r+0x70e>
80009f26:	10 95       	mov	r5,r8
80009f28:	c0 98       	rjmp	80009f3a <_dtoa_r+0x71e>
80009f2a:	33 08       	mov	r8,48
80009f2c:	40 89       	lddsp	r9,sp[0x20]
80009f2e:	2f f6       	sub	r6,-1
80009f30:	b2 88       	st.b	r9[0x0],r8
80009f32:	40 88       	lddsp	r8,sp[0x20]
80009f34:	c0 88       	rjmp	80009f44 <_dtoa_r+0x728>
80009f36:	40 66       	lddsp	r6,sp[0x18]
80009f38:	33 99       	mov	r9,57
80009f3a:	0a 98       	mov	r8,r5
80009f3c:	11 7a       	ld.ub	r10,--r8
80009f3e:	f2 0a 18 00 	cp.b	r10,r9
80009f42:	ce f0       	breq	80009f20 <_dtoa_r+0x704>
80009f44:	50 66       	stdsp	sp[0x18],r6
80009f46:	11 89       	ld.ub	r9,r8[0x0]
80009f48:	2f f9       	sub	r9,-1
80009f4a:	b0 89       	st.b	r8[0x0],r9
80009f4c:	e0 8f 02 42 	bral	8000a3d0 <_dtoa_r+0xbb4>
80009f50:	e0 a0 0a c2 	rcall	8000b4d4 <__avr32_f64_mul>
80009f54:	2f f4       	sub	r4,-1
80009f56:	fa eb 00 08 	st.d	sp[8],r10
80009f5a:	30 08       	mov	r8,0
80009f5c:	30 09       	mov	r9,0
80009f5e:	e0 a0 0d 86 	rcall	8000ba6a <__avr32_f64_cmp_eq>
80009f62:	ca 60       	breq	80009eae <_dtoa_r+0x692>
80009f64:	e0 8f 02 35 	bral	8000a3ce <_dtoa_r+0xbb2>
80009f68:	40 d8       	lddsp	r8,sp[0x34]
80009f6a:	58 08       	cp.w	r8,0
80009f6c:	c0 51       	brne	80009f76 <_dtoa_r+0x75a>
80009f6e:	04 98       	mov	r8,r2
80009f70:	00 95       	mov	r5,r0
80009f72:	40 d4       	lddsp	r4,sp[0x34]
80009f74:	c3 78       	rjmp	80009fe2 <_dtoa_r+0x7c6>
80009f76:	40 c5       	lddsp	r5,sp[0x30]
80009f78:	58 15       	cp.w	r5,1
80009f7a:	e0 89 00 0f 	brgt	80009f98 <_dtoa_r+0x77c>
80009f7e:	41 74       	lddsp	r4,sp[0x5c]
80009f80:	58 04       	cp.w	r4,0
80009f82:	c0 40       	breq	80009f8a <_dtoa_r+0x76e>
80009f84:	f4 c9 fb cd 	sub	r9,r10,-1075
80009f88:	c0 48       	rjmp	80009f90 <_dtoa_r+0x774>
80009f8a:	41 99       	lddsp	r9,sp[0x64]
80009f8c:	f2 09 11 36 	rsub	r9,r9,54
80009f90:	04 98       	mov	r8,r2
80009f92:	00 95       	mov	r5,r0
80009f94:	c1 c8       	rjmp	80009fcc <_dtoa_r+0x7b0>
80009f96:	d7 03       	nop
80009f98:	e2 c8 00 01 	sub	r8,r1,1
80009f9c:	58 01       	cp.w	r1,0
80009f9e:	e0 05 17 40 	movge	r5,r0
80009fa2:	e2 09 17 40 	movge	r9,r1
80009fa6:	e1 d1 e5 15 	sublt	r5,r0,r1
80009faa:	f9 b9 05 00 	movlt	r9,0
80009fae:	10 32       	cp.w	r2,r8
80009fb0:	e5 d8 e4 18 	subge	r8,r2,r8
80009fb4:	f1 d2 e5 18 	sublt	r8,r8,r2
80009fb8:	e5 d8 e5 02 	addlt	r2,r2,r8
80009fbc:	fb fc 50 11 	ld.wlt	r12,sp[0x44]
80009fc0:	f9 d8 e5 0c 	addlt	r12,r12,r8
80009fc4:	fb fc 5a 11 	st.wlt	sp[0x44],r12
80009fc8:	f9 b8 05 00 	movlt	r8,0
80009fcc:	40 4b       	lddsp	r11,sp[0x10]
80009fce:	12 0b       	add	r11,r9
80009fd0:	50 08       	stdsp	sp[0x0],r8
80009fd2:	50 4b       	stdsp	sp[0x10],r11
80009fd4:	12 00       	add	r0,r9
80009fd6:	30 1b       	mov	r11,1
80009fd8:	0e 9c       	mov	r12,r7
80009fda:	e0 a0 08 a7 	rcall	8000b128 <__i2b>
80009fde:	40 08       	lddsp	r8,sp[0x0]
80009fe0:	18 94       	mov	r4,r12
80009fe2:	40 4a       	lddsp	r10,sp[0x10]
80009fe4:	58 05       	cp.w	r5,0
80009fe6:	5f 99       	srgt	r9
80009fe8:	58 0a       	cp.w	r10,0
80009fea:	5f 9a       	srgt	r10
80009fec:	f5 e9 00 09 	and	r9,r10,r9
80009ff0:	c0 80       	breq	8000a000 <_dtoa_r+0x7e4>
80009ff2:	40 4c       	lddsp	r12,sp[0x10]
80009ff4:	f8 05 0d 49 	min	r9,r12,r5
80009ff8:	12 1c       	sub	r12,r9
80009ffa:	12 10       	sub	r0,r9
80009ffc:	50 4c       	stdsp	sp[0x10],r12
80009ffe:	12 15       	sub	r5,r9
8000a000:	58 02       	cp.w	r2,0
8000a002:	e0 8a 00 27 	brle	8000a050 <_dtoa_r+0x834>
8000a006:	40 db       	lddsp	r11,sp[0x34]
8000a008:	58 0b       	cp.w	r11,0
8000a00a:	c1 d0       	breq	8000a044 <_dtoa_r+0x828>
8000a00c:	58 08       	cp.w	r8,0
8000a00e:	e0 8a 00 17 	brle	8000a03c <_dtoa_r+0x820>
8000a012:	10 9a       	mov	r10,r8
8000a014:	50 08       	stdsp	sp[0x0],r8
8000a016:	08 9b       	mov	r11,r4
8000a018:	0e 9c       	mov	r12,r7
8000a01a:	e0 a0 08 cd 	rcall	8000b1b4 <__pow5mult>
8000a01e:	06 9a       	mov	r10,r3
8000a020:	18 9b       	mov	r11,r12
8000a022:	18 94       	mov	r4,r12
8000a024:	0e 9c       	mov	r12,r7
8000a026:	e0 a0 08 01 	rcall	8000b028 <__multiply>
8000a02a:	18 99       	mov	r9,r12
8000a02c:	06 9b       	mov	r11,r3
8000a02e:	50 19       	stdsp	sp[0x4],r9
8000a030:	0e 9c       	mov	r12,r7
8000a032:	e0 a0 06 ad 	rcall	8000ad8c <_Bfree>
8000a036:	40 19       	lddsp	r9,sp[0x4]
8000a038:	40 08       	lddsp	r8,sp[0x0]
8000a03a:	12 93       	mov	r3,r9
8000a03c:	e4 08 01 0a 	sub	r10,r2,r8
8000a040:	c0 80       	breq	8000a050 <_dtoa_r+0x834>
8000a042:	c0 28       	rjmp	8000a046 <_dtoa_r+0x82a>
8000a044:	04 9a       	mov	r10,r2
8000a046:	06 9b       	mov	r11,r3
8000a048:	0e 9c       	mov	r12,r7
8000a04a:	e0 a0 08 b5 	rcall	8000b1b4 <__pow5mult>
8000a04e:	18 93       	mov	r3,r12
8000a050:	30 1b       	mov	r11,1
8000a052:	0e 9c       	mov	r12,r7
8000a054:	e0 a0 08 6a 	rcall	8000b128 <__i2b>
8000a058:	41 1a       	lddsp	r10,sp[0x44]
8000a05a:	18 92       	mov	r2,r12
8000a05c:	58 0a       	cp.w	r10,0
8000a05e:	e0 8a 00 07 	brle	8000a06c <_dtoa_r+0x850>
8000a062:	18 9b       	mov	r11,r12
8000a064:	0e 9c       	mov	r12,r7
8000a066:	e0 a0 08 a7 	rcall	8000b1b4 <__pow5mult>
8000a06a:	18 92       	mov	r2,r12
8000a06c:	40 c9       	lddsp	r9,sp[0x30]
8000a06e:	58 19       	cp.w	r9,1
8000a070:	e0 89 00 14 	brgt	8000a098 <_dtoa_r+0x87c>
8000a074:	40 38       	lddsp	r8,sp[0xc]
8000a076:	58 08       	cp.w	r8,0
8000a078:	c1 01       	brne	8000a098 <_dtoa_r+0x87c>
8000a07a:	40 29       	lddsp	r9,sp[0x8]
8000a07c:	f1 d9 c0 14 	bfextu	r8,r9,0x0,0x14
8000a080:	c0 c1       	brne	8000a098 <_dtoa_r+0x87c>
8000a082:	12 98       	mov	r8,r9
8000a084:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000a088:	c0 80       	breq	8000a098 <_dtoa_r+0x87c>
8000a08a:	40 4c       	lddsp	r12,sp[0x10]
8000a08c:	30 1b       	mov	r11,1
8000a08e:	2f fc       	sub	r12,-1
8000a090:	2f f0       	sub	r0,-1
8000a092:	50 4c       	stdsp	sp[0x10],r12
8000a094:	50 6b       	stdsp	sp[0x18],r11
8000a096:	c0 38       	rjmp	8000a09c <_dtoa_r+0x880>
8000a098:	30 0a       	mov	r10,0
8000a09a:	50 6a       	stdsp	sp[0x18],r10
8000a09c:	41 19       	lddsp	r9,sp[0x44]
8000a09e:	58 09       	cp.w	r9,0
8000a0a0:	c0 31       	brne	8000a0a6 <_dtoa_r+0x88a>
8000a0a2:	30 1c       	mov	r12,1
8000a0a4:	c0 98       	rjmp	8000a0b6 <_dtoa_r+0x89a>
8000a0a6:	64 48       	ld.w	r8,r2[0x10]
8000a0a8:	2f c8       	sub	r8,-4
8000a0aa:	e4 08 03 2c 	ld.w	r12,r2[r8<<0x2]
8000a0ae:	e0 a0 05 df 	rcall	8000ac6c <__hi0bits>
8000a0b2:	f8 0c 11 20 	rsub	r12,r12,32
8000a0b6:	40 4b       	lddsp	r11,sp[0x10]
8000a0b8:	f8 0b 00 08 	add	r8,r12,r11
8000a0bc:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000a0c0:	c0 c0       	breq	8000a0d8 <_dtoa_r+0x8bc>
8000a0c2:	f0 08 11 20 	rsub	r8,r8,32
8000a0c6:	58 48       	cp.w	r8,4
8000a0c8:	e0 8a 00 06 	brle	8000a0d4 <_dtoa_r+0x8b8>
8000a0cc:	20 48       	sub	r8,4
8000a0ce:	10 0b       	add	r11,r8
8000a0d0:	50 4b       	stdsp	sp[0x10],r11
8000a0d2:	c0 78       	rjmp	8000a0e0 <_dtoa_r+0x8c4>
8000a0d4:	58 48       	cp.w	r8,4
8000a0d6:	c0 70       	breq	8000a0e4 <_dtoa_r+0x8c8>
8000a0d8:	40 4a       	lddsp	r10,sp[0x10]
8000a0da:	2e 48       	sub	r8,-28
8000a0dc:	10 0a       	add	r10,r8
8000a0de:	50 4a       	stdsp	sp[0x10],r10
8000a0e0:	10 00       	add	r0,r8
8000a0e2:	10 05       	add	r5,r8
8000a0e4:	58 00       	cp.w	r0,0
8000a0e6:	e0 8a 00 08 	brle	8000a0f6 <_dtoa_r+0x8da>
8000a0ea:	06 9b       	mov	r11,r3
8000a0ec:	00 9a       	mov	r10,r0
8000a0ee:	0e 9c       	mov	r12,r7
8000a0f0:	e0 a0 07 58 	rcall	8000afa0 <__lshift>
8000a0f4:	18 93       	mov	r3,r12
8000a0f6:	40 49       	lddsp	r9,sp[0x10]
8000a0f8:	58 09       	cp.w	r9,0
8000a0fa:	e0 8a 00 08 	brle	8000a10a <_dtoa_r+0x8ee>
8000a0fe:	04 9b       	mov	r11,r2
8000a100:	12 9a       	mov	r10,r9
8000a102:	0e 9c       	mov	r12,r7
8000a104:	e0 a0 07 4e 	rcall	8000afa0 <__lshift>
8000a108:	18 92       	mov	r2,r12
8000a10a:	41 48       	lddsp	r8,sp[0x50]
8000a10c:	58 08       	cp.w	r8,0
8000a10e:	c1 b0       	breq	8000a144 <_dtoa_r+0x928>
8000a110:	04 9b       	mov	r11,r2
8000a112:	06 9c       	mov	r12,r3
8000a114:	e0 a0 06 23 	rcall	8000ad5a <__mcmp>
8000a118:	c1 64       	brge	8000a144 <_dtoa_r+0x928>
8000a11a:	06 9b       	mov	r11,r3
8000a11c:	30 09       	mov	r9,0
8000a11e:	30 aa       	mov	r10,10
8000a120:	0e 9c       	mov	r12,r7
8000a122:	e0 a0 08 0b 	rcall	8000b138 <__multadd>
8000a126:	20 16       	sub	r6,1
8000a128:	18 93       	mov	r3,r12
8000a12a:	40 dc       	lddsp	r12,sp[0x34]
8000a12c:	58 0c       	cp.w	r12,0
8000a12e:	c0 31       	brne	8000a134 <_dtoa_r+0x918>
8000a130:	40 91       	lddsp	r1,sp[0x24]
8000a132:	c0 98       	rjmp	8000a144 <_dtoa_r+0x928>
8000a134:	08 9b       	mov	r11,r4
8000a136:	40 91       	lddsp	r1,sp[0x24]
8000a138:	30 09       	mov	r9,0
8000a13a:	30 aa       	mov	r10,10
8000a13c:	0e 9c       	mov	r12,r7
8000a13e:	e0 a0 07 fd 	rcall	8000b138 <__multadd>
8000a142:	18 94       	mov	r4,r12
8000a144:	58 01       	cp.w	r1,0
8000a146:	5f a9       	srle	r9
8000a148:	40 cb       	lddsp	r11,sp[0x30]
8000a14a:	58 2b       	cp.w	r11,2
8000a14c:	5f 98       	srgt	r8
8000a14e:	f3 e8 00 08 	and	r8,r9,r8
8000a152:	c2 50       	breq	8000a19c <_dtoa_r+0x980>
8000a154:	58 01       	cp.w	r1,0
8000a156:	c1 11       	brne	8000a178 <_dtoa_r+0x95c>
8000a158:	04 9b       	mov	r11,r2
8000a15a:	02 99       	mov	r9,r1
8000a15c:	30 5a       	mov	r10,5
8000a15e:	0e 9c       	mov	r12,r7
8000a160:	e0 a0 07 ec 	rcall	8000b138 <__multadd>
8000a164:	18 92       	mov	r2,r12
8000a166:	18 9b       	mov	r11,r12
8000a168:	06 9c       	mov	r12,r3
8000a16a:	e0 a0 05 f8 	rcall	8000ad5a <__mcmp>
8000a16e:	e0 89 00 0f 	brgt	8000a18c <_dtoa_r+0x970>
8000a172:	c0 38       	rjmp	8000a178 <_dtoa_r+0x95c>
8000a174:	30 02       	mov	r2,0
8000a176:	04 94       	mov	r4,r2
8000a178:	40 ea       	lddsp	r10,sp[0x38]
8000a17a:	30 09       	mov	r9,0
8000a17c:	5c da       	com	r10
8000a17e:	40 85       	lddsp	r5,sp[0x20]
8000a180:	50 6a       	stdsp	sp[0x18],r10
8000a182:	50 49       	stdsp	sp[0x10],r9
8000a184:	c0 f9       	rjmp	8000a3a2 <_dtoa_r+0xb86>
8000a186:	08 92       	mov	r2,r4
8000a188:	40 66       	lddsp	r6,sp[0x18]
8000a18a:	04 94       	mov	r4,r2
8000a18c:	2f f6       	sub	r6,-1
8000a18e:	50 66       	stdsp	sp[0x18],r6
8000a190:	33 18       	mov	r8,49
8000a192:	40 85       	lddsp	r5,sp[0x20]
8000a194:	0a c8       	st.b	r5++,r8
8000a196:	30 08       	mov	r8,0
8000a198:	50 48       	stdsp	sp[0x10],r8
8000a19a:	c0 49       	rjmp	8000a3a2 <_dtoa_r+0xb86>
8000a19c:	40 dc       	lddsp	r12,sp[0x34]
8000a19e:	58 0c       	cp.w	r12,0
8000a1a0:	e0 80 00 b5 	breq	8000a30a <_dtoa_r+0xaee>
8000a1a4:	58 05       	cp.w	r5,0
8000a1a6:	e0 8a 00 08 	brle	8000a1b6 <_dtoa_r+0x99a>
8000a1aa:	08 9b       	mov	r11,r4
8000a1ac:	0a 9a       	mov	r10,r5
8000a1ae:	0e 9c       	mov	r12,r7
8000a1b0:	e0 a0 06 f8 	rcall	8000afa0 <__lshift>
8000a1b4:	18 94       	mov	r4,r12
8000a1b6:	40 6b       	lddsp	r11,sp[0x18]
8000a1b8:	58 0b       	cp.w	r11,0
8000a1ba:	c0 31       	brne	8000a1c0 <_dtoa_r+0x9a4>
8000a1bc:	08 9c       	mov	r12,r4
8000a1be:	c1 38       	rjmp	8000a1e4 <_dtoa_r+0x9c8>
8000a1c0:	68 1b       	ld.w	r11,r4[0x4]
8000a1c2:	0e 9c       	mov	r12,r7
8000a1c4:	e0 a0 05 fe 	rcall	8000adc0 <_Balloc>
8000a1c8:	68 4a       	ld.w	r10,r4[0x10]
8000a1ca:	18 95       	mov	r5,r12
8000a1cc:	e8 cb ff f4 	sub	r11,r4,-12
8000a1d0:	2f ea       	sub	r10,-2
8000a1d2:	2f 4c       	sub	r12,-12
8000a1d4:	a3 6a       	lsl	r10,0x2
8000a1d6:	fe b0 e6 43 	rcall	80006e5c <memcpy>
8000a1da:	0a 9b       	mov	r11,r5
8000a1dc:	30 1a       	mov	r10,1
8000a1de:	0e 9c       	mov	r12,r7
8000a1e0:	e0 a0 06 e0 	rcall	8000afa0 <__lshift>
8000a1e4:	50 44       	stdsp	sp[0x10],r4
8000a1e6:	40 3a       	lddsp	r10,sp[0xc]
8000a1e8:	30 19       	mov	r9,1
8000a1ea:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
8000a1ee:	18 94       	mov	r4,r12
8000a1f0:	50 da       	stdsp	sp[0x34],r10
8000a1f2:	40 85       	lddsp	r5,sp[0x20]
8000a1f4:	50 99       	stdsp	sp[0x24],r9
8000a1f6:	50 26       	stdsp	sp[0x8],r6
8000a1f8:	50 e1       	stdsp	sp[0x38],r1
8000a1fa:	04 9b       	mov	r11,r2
8000a1fc:	06 9c       	mov	r12,r3
8000a1fe:	fe b0 fa 7f 	rcall	800096fc <quorem>
8000a202:	40 4b       	lddsp	r11,sp[0x10]
8000a204:	f8 c0 ff d0 	sub	r0,r12,-48
8000a208:	06 9c       	mov	r12,r3
8000a20a:	e0 a0 05 a8 	rcall	8000ad5a <__mcmp>
8000a20e:	08 9a       	mov	r10,r4
8000a210:	50 6c       	stdsp	sp[0x18],r12
8000a212:	04 9b       	mov	r11,r2
8000a214:	0e 9c       	mov	r12,r7
8000a216:	e0 a0 06 5d 	rcall	8000aed0 <__mdiff>
8000a21a:	18 91       	mov	r1,r12
8000a21c:	78 38       	ld.w	r8,r12[0xc]
8000a21e:	58 08       	cp.w	r8,0
8000a220:	c0 30       	breq	8000a226 <_dtoa_r+0xa0a>
8000a222:	30 16       	mov	r6,1
8000a224:	c0 68       	rjmp	8000a230 <_dtoa_r+0xa14>
8000a226:	18 9b       	mov	r11,r12
8000a228:	06 9c       	mov	r12,r3
8000a22a:	e0 a0 05 98 	rcall	8000ad5a <__mcmp>
8000a22e:	18 96       	mov	r6,r12
8000a230:	0e 9c       	mov	r12,r7
8000a232:	02 9b       	mov	r11,r1
8000a234:	e0 a0 05 ac 	rcall	8000ad8c <_Bfree>
8000a238:	40 cc       	lddsp	r12,sp[0x30]
8000a23a:	ed ec 10 08 	or	r8,r6,r12
8000a23e:	c0 d1       	brne	8000a258 <_dtoa_r+0xa3c>
8000a240:	40 db       	lddsp	r11,sp[0x34]
8000a242:	58 0b       	cp.w	r11,0
8000a244:	c0 a1       	brne	8000a258 <_dtoa_r+0xa3c>
8000a246:	40 26       	lddsp	r6,sp[0x8]
8000a248:	e0 40 00 39 	cp.w	r0,57
8000a24c:	c3 00       	breq	8000a2ac <_dtoa_r+0xa90>
8000a24e:	40 6a       	lddsp	r10,sp[0x18]
8000a250:	58 0a       	cp.w	r10,0
8000a252:	e0 89 00 24 	brgt	8000a29a <_dtoa_r+0xa7e>
8000a256:	c2 f8       	rjmp	8000a2b4 <_dtoa_r+0xa98>
8000a258:	40 69       	lddsp	r9,sp[0x18]
8000a25a:	58 09       	cp.w	r9,0
8000a25c:	c0 85       	brlt	8000a26c <_dtoa_r+0xa50>
8000a25e:	12 98       	mov	r8,r9
8000a260:	40 cc       	lddsp	r12,sp[0x30]
8000a262:	18 48       	or	r8,r12
8000a264:	c1 d1       	brne	8000a29e <_dtoa_r+0xa82>
8000a266:	40 db       	lddsp	r11,sp[0x34]
8000a268:	58 0b       	cp.w	r11,0
8000a26a:	c1 a1       	brne	8000a29e <_dtoa_r+0xa82>
8000a26c:	0c 99       	mov	r9,r6
8000a26e:	40 26       	lddsp	r6,sp[0x8]
8000a270:	58 09       	cp.w	r9,0
8000a272:	e0 8a 00 21 	brle	8000a2b4 <_dtoa_r+0xa98>
8000a276:	06 9b       	mov	r11,r3
8000a278:	30 1a       	mov	r10,1
8000a27a:	0e 9c       	mov	r12,r7
8000a27c:	e0 a0 06 92 	rcall	8000afa0 <__lshift>
8000a280:	04 9b       	mov	r11,r2
8000a282:	18 93       	mov	r3,r12
8000a284:	e0 a0 05 6b 	rcall	8000ad5a <__mcmp>
8000a288:	e0 89 00 06 	brgt	8000a294 <_dtoa_r+0xa78>
8000a28c:	c1 41       	brne	8000a2b4 <_dtoa_r+0xa98>
8000a28e:	ed b0 00 00 	bld	r0,0x0
8000a292:	c1 11       	brne	8000a2b4 <_dtoa_r+0xa98>
8000a294:	e0 40 00 39 	cp.w	r0,57
8000a298:	c0 a0       	breq	8000a2ac <_dtoa_r+0xa90>
8000a29a:	2f f0       	sub	r0,-1
8000a29c:	c0 c8       	rjmp	8000a2b4 <_dtoa_r+0xa98>
8000a29e:	58 06       	cp.w	r6,0
8000a2a0:	e0 8a 00 0c 	brle	8000a2b8 <_dtoa_r+0xa9c>
8000a2a4:	40 26       	lddsp	r6,sp[0x8]
8000a2a6:	e0 40 00 39 	cp.w	r0,57
8000a2aa:	c0 41       	brne	8000a2b2 <_dtoa_r+0xa96>
8000a2ac:	33 98       	mov	r8,57
8000a2ae:	0a c8       	st.b	r5++,r8
8000a2b0:	c6 78       	rjmp	8000a37e <_dtoa_r+0xb62>
8000a2b2:	2f f0       	sub	r0,-1
8000a2b4:	0a c0       	st.b	r5++,r0
8000a2b6:	c7 58       	rjmp	8000a3a0 <_dtoa_r+0xb84>
8000a2b8:	0a c0       	st.b	r5++,r0
8000a2ba:	40 9a       	lddsp	r10,sp[0x24]
8000a2bc:	40 e9       	lddsp	r9,sp[0x38]
8000a2be:	12 3a       	cp.w	r10,r9
8000a2c0:	c4 30       	breq	8000a346 <_dtoa_r+0xb2a>
8000a2c2:	06 9b       	mov	r11,r3
8000a2c4:	30 09       	mov	r9,0
8000a2c6:	30 aa       	mov	r10,10
8000a2c8:	0e 9c       	mov	r12,r7
8000a2ca:	e0 a0 07 37 	rcall	8000b138 <__multadd>
8000a2ce:	40 48       	lddsp	r8,sp[0x10]
8000a2d0:	18 93       	mov	r3,r12
8000a2d2:	08 38       	cp.w	r8,r4
8000a2d4:	c0 91       	brne	8000a2e6 <_dtoa_r+0xaca>
8000a2d6:	10 9b       	mov	r11,r8
8000a2d8:	30 09       	mov	r9,0
8000a2da:	30 aa       	mov	r10,10
8000a2dc:	0e 9c       	mov	r12,r7
8000a2de:	e0 a0 07 2d 	rcall	8000b138 <__multadd>
8000a2e2:	50 4c       	stdsp	sp[0x10],r12
8000a2e4:	c0 e8       	rjmp	8000a300 <_dtoa_r+0xae4>
8000a2e6:	40 4b       	lddsp	r11,sp[0x10]
8000a2e8:	30 09       	mov	r9,0
8000a2ea:	30 aa       	mov	r10,10
8000a2ec:	0e 9c       	mov	r12,r7
8000a2ee:	e0 a0 07 25 	rcall	8000b138 <__multadd>
8000a2f2:	08 9b       	mov	r11,r4
8000a2f4:	50 4c       	stdsp	sp[0x10],r12
8000a2f6:	30 09       	mov	r9,0
8000a2f8:	30 aa       	mov	r10,10
8000a2fa:	0e 9c       	mov	r12,r7
8000a2fc:	e0 a0 07 1e 	rcall	8000b138 <__multadd>
8000a300:	18 94       	mov	r4,r12
8000a302:	40 9c       	lddsp	r12,sp[0x24]
8000a304:	2f fc       	sub	r12,-1
8000a306:	50 9c       	stdsp	sp[0x24],r12
8000a308:	c7 9b       	rjmp	8000a1fa <_dtoa_r+0x9de>
8000a30a:	30 18       	mov	r8,1
8000a30c:	06 90       	mov	r0,r3
8000a30e:	40 85       	lddsp	r5,sp[0x20]
8000a310:	08 93       	mov	r3,r4
8000a312:	0c 94       	mov	r4,r6
8000a314:	10 96       	mov	r6,r8
8000a316:	04 9b       	mov	r11,r2
8000a318:	00 9c       	mov	r12,r0
8000a31a:	fe b0 f9 f1 	rcall	800096fc <quorem>
8000a31e:	2d 0c       	sub	r12,-48
8000a320:	0a cc       	st.b	r5++,r12
8000a322:	02 36       	cp.w	r6,r1
8000a324:	c0 a4       	brge	8000a338 <_dtoa_r+0xb1c>
8000a326:	00 9b       	mov	r11,r0
8000a328:	30 09       	mov	r9,0
8000a32a:	30 aa       	mov	r10,10
8000a32c:	0e 9c       	mov	r12,r7
8000a32e:	2f f6       	sub	r6,-1
8000a330:	e0 a0 07 04 	rcall	8000b138 <__multadd>
8000a334:	18 90       	mov	r0,r12
8000a336:	cf 0b       	rjmp	8000a316 <_dtoa_r+0xafa>
8000a338:	08 96       	mov	r6,r4
8000a33a:	30 0b       	mov	r11,0
8000a33c:	06 94       	mov	r4,r3
8000a33e:	50 4b       	stdsp	sp[0x10],r11
8000a340:	00 93       	mov	r3,r0
8000a342:	18 90       	mov	r0,r12
8000a344:	c0 28       	rjmp	8000a348 <_dtoa_r+0xb2c>
8000a346:	40 26       	lddsp	r6,sp[0x8]
8000a348:	06 9b       	mov	r11,r3
8000a34a:	30 1a       	mov	r10,1
8000a34c:	0e 9c       	mov	r12,r7
8000a34e:	e0 a0 06 29 	rcall	8000afa0 <__lshift>
8000a352:	04 9b       	mov	r11,r2
8000a354:	18 93       	mov	r3,r12
8000a356:	e0 a0 05 02 	rcall	8000ad5a <__mcmp>
8000a35a:	e0 89 00 12 	brgt	8000a37e <_dtoa_r+0xb62>
8000a35e:	c1 b1       	brne	8000a394 <_dtoa_r+0xb78>
8000a360:	e1 d0 c0 01 	bfextu	r0,r0,0x0,0x1
8000a364:	c0 d1       	brne	8000a37e <_dtoa_r+0xb62>
8000a366:	c1 78       	rjmp	8000a394 <_dtoa_r+0xb78>
8000a368:	40 89       	lddsp	r9,sp[0x20]
8000a36a:	12 38       	cp.w	r8,r9
8000a36c:	c0 30       	breq	8000a372 <_dtoa_r+0xb56>
8000a36e:	10 95       	mov	r5,r8
8000a370:	c0 88       	rjmp	8000a380 <_dtoa_r+0xb64>
8000a372:	2f f6       	sub	r6,-1
8000a374:	50 66       	stdsp	sp[0x18],r6
8000a376:	33 18       	mov	r8,49
8000a378:	40 8c       	lddsp	r12,sp[0x20]
8000a37a:	b8 88       	st.b	r12[0x0],r8
8000a37c:	c1 38       	rjmp	8000a3a2 <_dtoa_r+0xb86>
8000a37e:	33 9a       	mov	r10,57
8000a380:	0a 98       	mov	r8,r5
8000a382:	11 79       	ld.ub	r9,--r8
8000a384:	f4 09 18 00 	cp.b	r9,r10
8000a388:	cf 00       	breq	8000a368 <_dtoa_r+0xb4c>
8000a38a:	2f f9       	sub	r9,-1
8000a38c:	b0 89       	st.b	r8[0x0],r9
8000a38e:	c0 98       	rjmp	8000a3a0 <_dtoa_r+0xb84>
8000a390:	10 95       	mov	r5,r8
8000a392:	c0 28       	rjmp	8000a396 <_dtoa_r+0xb7a>
8000a394:	33 09       	mov	r9,48
8000a396:	0a 98       	mov	r8,r5
8000a398:	11 7a       	ld.ub	r10,--r8
8000a39a:	f2 0a 18 00 	cp.b	r10,r9
8000a39e:	cf 90       	breq	8000a390 <_dtoa_r+0xb74>
8000a3a0:	50 66       	stdsp	sp[0x18],r6
8000a3a2:	04 9b       	mov	r11,r2
8000a3a4:	0e 9c       	mov	r12,r7
8000a3a6:	e0 a0 04 f3 	rcall	8000ad8c <_Bfree>
8000a3aa:	58 04       	cp.w	r4,0
8000a3ac:	c1 20       	breq	8000a3d0 <_dtoa_r+0xbb4>
8000a3ae:	40 4b       	lddsp	r11,sp[0x10]
8000a3b0:	08 3b       	cp.w	r11,r4
8000a3b2:	5f 19       	srne	r9
8000a3b4:	58 0b       	cp.w	r11,0
8000a3b6:	5f 18       	srne	r8
8000a3b8:	f3 e8 00 08 	and	r8,r9,r8
8000a3bc:	c0 40       	breq	8000a3c4 <_dtoa_r+0xba8>
8000a3be:	0e 9c       	mov	r12,r7
8000a3c0:	e0 a0 04 e6 	rcall	8000ad8c <_Bfree>
8000a3c4:	08 9b       	mov	r11,r4
8000a3c6:	0e 9c       	mov	r12,r7
8000a3c8:	e0 a0 04 e2 	rcall	8000ad8c <_Bfree>
8000a3cc:	c0 28       	rjmp	8000a3d0 <_dtoa_r+0xbb4>
8000a3ce:	50 66       	stdsp	sp[0x18],r6
8000a3d0:	0e 9c       	mov	r12,r7
8000a3d2:	06 9b       	mov	r11,r3
8000a3d4:	e0 a0 04 dc 	rcall	8000ad8c <_Bfree>
8000a3d8:	30 08       	mov	r8,0
8000a3da:	aa 88       	st.b	r5[0x0],r8
8000a3dc:	40 68       	lddsp	r8,sp[0x18]
8000a3de:	41 5a       	lddsp	r10,sp[0x54]
8000a3e0:	2f f8       	sub	r8,-1
8000a3e2:	41 29       	lddsp	r9,sp[0x48]
8000a3e4:	95 08       	st.w	r10[0x0],r8
8000a3e6:	40 8c       	lddsp	r12,sp[0x20]
8000a3e8:	58 09       	cp.w	r9,0
8000a3ea:	fb f8 10 12 	ld.wne	r8,sp[0x48]
8000a3ee:	f1 f5 1a 00 	st.wne	r8[0x0],r5
8000a3f2:	2e 6d       	sub	sp,-104
8000a3f4:	d8 32       	popm	r0-r7,pc
8000a3f6:	d7 03       	nop

8000a3f8 <__errno>:
8000a3f8:	e0 68 0a 38 	mov	r8,2616
8000a3fc:	70 0c       	ld.w	r12,r8[0x0]
8000a3fe:	2f 4c       	sub	r12,-12
8000a400:	5e fc       	retal	r12
8000a402:	d7 03       	nop

8000a404 <_fflush_r>:
8000a404:	d4 21       	pushm	r4-r7,lr
8000a406:	16 97       	mov	r7,r11
8000a408:	18 96       	mov	r6,r12
8000a40a:	76 48       	ld.w	r8,r11[0x10]
8000a40c:	58 08       	cp.w	r8,0
8000a40e:	c7 f0       	breq	8000a50c <_fflush_r+0x108>
8000a410:	58 0c       	cp.w	r12,0
8000a412:	c0 50       	breq	8000a41c <_fflush_r+0x18>
8000a414:	78 68       	ld.w	r8,r12[0x18]
8000a416:	58 08       	cp.w	r8,0
8000a418:	c0 21       	brne	8000a41c <_fflush_r+0x18>
8000a41a:	cc dc       	rcall	8000a5b4 <__sinit>
8000a41c:	fe c8 c8 5c 	sub	r8,pc,-14244
8000a420:	10 37       	cp.w	r7,r8
8000a422:	c0 31       	brne	8000a428 <_fflush_r+0x24>
8000a424:	6c 07       	ld.w	r7,r6[0x0]
8000a426:	c0 c8       	rjmp	8000a43e <_fflush_r+0x3a>
8000a428:	fe c8 c8 48 	sub	r8,pc,-14264
8000a42c:	10 37       	cp.w	r7,r8
8000a42e:	c0 31       	brne	8000a434 <_fflush_r+0x30>
8000a430:	6c 17       	ld.w	r7,r6[0x4]
8000a432:	c0 68       	rjmp	8000a43e <_fflush_r+0x3a>
8000a434:	fe c8 c8 34 	sub	r8,pc,-14284
8000a438:	10 37       	cp.w	r7,r8
8000a43a:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000a43e:	8e 6a       	ld.sh	r10,r7[0xc]
8000a440:	14 98       	mov	r8,r10
8000a442:	ed ba 00 03 	bld	r10,0x3
8000a446:	c4 20       	breq	8000a4ca <_fflush_r+0xc6>
8000a448:	ab ba       	sbr	r10,0xb
8000a44a:	ae 6a       	st.h	r7[0xc],r10
8000a44c:	6e 18       	ld.w	r8,r7[0x4]
8000a44e:	58 08       	cp.w	r8,0
8000a450:	e0 89 00 06 	brgt	8000a45c <_fflush_r+0x58>
8000a454:	6f 08       	ld.w	r8,r7[0x40]
8000a456:	58 08       	cp.w	r8,0
8000a458:	e0 8a 00 5a 	brle	8000a50c <_fflush_r+0x108>
8000a45c:	6e b8       	ld.w	r8,r7[0x2c]
8000a45e:	58 08       	cp.w	r8,0
8000a460:	c5 60       	breq	8000a50c <_fflush_r+0x108>
8000a462:	e2 1a 10 00 	andl	r10,0x1000,COH
8000a466:	c0 30       	breq	8000a46c <_fflush_r+0x68>
8000a468:	6f 55       	ld.w	r5,r7[0x54]
8000a46a:	c0 f8       	rjmp	8000a488 <_fflush_r+0x84>
8000a46c:	30 19       	mov	r9,1
8000a46e:	6e 8b       	ld.w	r11,r7[0x20]
8000a470:	0c 9c       	mov	r12,r6
8000a472:	5d 18       	icall	r8
8000a474:	18 95       	mov	r5,r12
8000a476:	5b fc       	cp.w	r12,-1
8000a478:	c0 81       	brne	8000a488 <_fflush_r+0x84>
8000a47a:	6c 38       	ld.w	r8,r6[0xc]
8000a47c:	59 d8       	cp.w	r8,29
8000a47e:	c4 70       	breq	8000a50c <_fflush_r+0x108>
8000a480:	8e 68       	ld.sh	r8,r7[0xc]
8000a482:	a7 a8       	sbr	r8,0x6
8000a484:	ae 68       	st.h	r7[0xc],r8
8000a486:	d8 22       	popm	r4-r7,pc
8000a488:	8e 68       	ld.sh	r8,r7[0xc]
8000a48a:	ed b8 00 02 	bld	r8,0x2
8000a48e:	c0 91       	brne	8000a4a0 <_fflush_r+0x9c>
8000a490:	6e 18       	ld.w	r8,r7[0x4]
8000a492:	10 15       	sub	r5,r8
8000a494:	6e d8       	ld.w	r8,r7[0x34]
8000a496:	58 08       	cp.w	r8,0
8000a498:	ef f8 10 10 	ld.wne	r8,r7[0x40]
8000a49c:	eb d8 e1 15 	subne	r5,r5,r8
8000a4a0:	6e b8       	ld.w	r8,r7[0x2c]
8000a4a2:	0c 9c       	mov	r12,r6
8000a4a4:	30 09       	mov	r9,0
8000a4a6:	0a 9a       	mov	r10,r5
8000a4a8:	6e 8b       	ld.w	r11,r7[0x20]
8000a4aa:	5d 18       	icall	r8
8000a4ac:	8e 68       	ld.sh	r8,r7[0xc]
8000a4ae:	0a 3c       	cp.w	r12,r5
8000a4b0:	c2 61       	brne	8000a4fc <_fflush_r+0xf8>
8000a4b2:	ab d8       	cbr	r8,0xb
8000a4b4:	30 0c       	mov	r12,0
8000a4b6:	6e 49       	ld.w	r9,r7[0x10]
8000a4b8:	ae 68       	st.h	r7[0xc],r8
8000a4ba:	8f 1c       	st.w	r7[0x4],r12
8000a4bc:	8f 09       	st.w	r7[0x0],r9
8000a4be:	ed b8 00 0c 	bld	r8,0xc
8000a4c2:	c2 51       	brne	8000a50c <_fflush_r+0x108>
8000a4c4:	ef 45 00 54 	st.w	r7[84],r5
8000a4c8:	d8 22       	popm	r4-r7,pc
8000a4ca:	6e 45       	ld.w	r5,r7[0x10]
8000a4cc:	58 05       	cp.w	r5,0
8000a4ce:	c1 f0       	breq	8000a50c <_fflush_r+0x108>
8000a4d0:	6e 04       	ld.w	r4,r7[0x0]
8000a4d2:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
8000a4d6:	8f 05       	st.w	r7[0x0],r5
8000a4d8:	f9 b8 01 00 	movne	r8,0
8000a4dc:	ef f8 00 05 	ld.weq	r8,r7[0x14]
8000a4e0:	0a 14       	sub	r4,r5
8000a4e2:	8f 28       	st.w	r7[0x8],r8
8000a4e4:	c1 18       	rjmp	8000a506 <_fflush_r+0x102>
8000a4e6:	08 99       	mov	r9,r4
8000a4e8:	0a 9a       	mov	r10,r5
8000a4ea:	6e a8       	ld.w	r8,r7[0x28]
8000a4ec:	6e 8b       	ld.w	r11,r7[0x20]
8000a4ee:	0c 9c       	mov	r12,r6
8000a4f0:	5d 18       	icall	r8
8000a4f2:	18 14       	sub	r4,r12
8000a4f4:	58 0c       	cp.w	r12,0
8000a4f6:	e0 89 00 07 	brgt	8000a504 <_fflush_r+0x100>
8000a4fa:	8e 68       	ld.sh	r8,r7[0xc]
8000a4fc:	a7 a8       	sbr	r8,0x6
8000a4fe:	3f fc       	mov	r12,-1
8000a500:	ae 68       	st.h	r7[0xc],r8
8000a502:	d8 22       	popm	r4-r7,pc
8000a504:	18 05       	add	r5,r12
8000a506:	58 04       	cp.w	r4,0
8000a508:	fe 99 ff ef 	brgt	8000a4e6 <_fflush_r+0xe2>
8000a50c:	d8 2a       	popm	r4-r7,pc,r12=0
8000a50e:	d7 03       	nop

8000a510 <__sfp_lock_acquire>:
8000a510:	5e fc       	retal	r12

8000a512 <__sfp_lock_release>:
8000a512:	5e fc       	retal	r12

8000a514 <_cleanup_r>:
8000a514:	d4 01       	pushm	lr
8000a516:	fe cb f0 c6 	sub	r11,pc,-3898
8000a51a:	e0 a0 02 f7 	rcall	8000ab08 <_fwalk>
8000a51e:	d8 02       	popm	pc

8000a520 <__sfmoreglue>:
8000a520:	d4 21       	pushm	r4-r7,lr
8000a522:	16 95       	mov	r5,r11
8000a524:	f6 06 10 5c 	mul	r6,r11,92
8000a528:	ec cb ff f4 	sub	r11,r6,-12
8000a52c:	fe b0 e2 7c 	rcall	80006a24 <_malloc_r>
8000a530:	18 97       	mov	r7,r12
8000a532:	c0 90       	breq	8000a544 <__sfmoreglue+0x24>
8000a534:	99 15       	st.w	r12[0x4],r5
8000a536:	30 0b       	mov	r11,0
8000a538:	2f 4c       	sub	r12,-12
8000a53a:	0c 9a       	mov	r10,r6
8000a53c:	8f 2c       	st.w	r7[0x8],r12
8000a53e:	8f 0b       	st.w	r7[0x0],r11
8000a540:	fe b0 e5 32 	rcall	80006fa4 <memset>
8000a544:	0e 9c       	mov	r12,r7
8000a546:	d8 22       	popm	r4-r7,pc

8000a548 <__sfp>:
8000a548:	d4 21       	pushm	r4-r7,lr
8000a54a:	fe c8 c9 26 	sub	r8,pc,-14042
8000a54e:	18 96       	mov	r6,r12
8000a550:	70 07       	ld.w	r7,r8[0x0]
8000a552:	6e 68       	ld.w	r8,r7[0x18]
8000a554:	58 08       	cp.w	r8,0
8000a556:	c0 31       	brne	8000a55c <__sfp+0x14>
8000a558:	0e 9c       	mov	r12,r7
8000a55a:	c2 dc       	rcall	8000a5b4 <__sinit>
8000a55c:	ee c7 ff 28 	sub	r7,r7,-216
8000a560:	30 05       	mov	r5,0
8000a562:	6e 2c       	ld.w	r12,r7[0x8]
8000a564:	6e 18       	ld.w	r8,r7[0x4]
8000a566:	c0 68       	rjmp	8000a572 <__sfp+0x2a>
8000a568:	98 69       	ld.sh	r9,r12[0xc]
8000a56a:	ea 09 19 00 	cp.h	r9,r5
8000a56e:	c1 10       	breq	8000a590 <__sfp+0x48>
8000a570:	2a 4c       	sub	r12,-92
8000a572:	20 18       	sub	r8,1
8000a574:	cf a7       	brpl	8000a568 <__sfp+0x20>
8000a576:	6e 08       	ld.w	r8,r7[0x0]
8000a578:	58 08       	cp.w	r8,0
8000a57a:	c0 61       	brne	8000a586 <__sfp+0x3e>
8000a57c:	30 4b       	mov	r11,4
8000a57e:	0c 9c       	mov	r12,r6
8000a580:	cd 0f       	rcall	8000a520 <__sfmoreglue>
8000a582:	8f 0c       	st.w	r7[0x0],r12
8000a584:	c0 30       	breq	8000a58a <__sfp+0x42>
8000a586:	6e 07       	ld.w	r7,r7[0x0]
8000a588:	ce db       	rjmp	8000a562 <__sfp+0x1a>
8000a58a:	30 c8       	mov	r8,12
8000a58c:	8d 38       	st.w	r6[0xc],r8
8000a58e:	d8 22       	popm	r4-r7,pc
8000a590:	30 08       	mov	r8,0
8000a592:	f9 48 00 4c 	st.w	r12[76],r8
8000a596:	99 08       	st.w	r12[0x0],r8
8000a598:	99 28       	st.w	r12[0x8],r8
8000a59a:	99 18       	st.w	r12[0x4],r8
8000a59c:	99 48       	st.w	r12[0x10],r8
8000a59e:	99 58       	st.w	r12[0x14],r8
8000a5a0:	99 68       	st.w	r12[0x18],r8
8000a5a2:	99 d8       	st.w	r12[0x34],r8
8000a5a4:	99 e8       	st.w	r12[0x38],r8
8000a5a6:	f9 48 00 48 	st.w	r12[72],r8
8000a5aa:	3f f8       	mov	r8,-1
8000a5ac:	b8 78       	st.h	r12[0xe],r8
8000a5ae:	30 18       	mov	r8,1
8000a5b0:	b8 68       	st.h	r12[0xc],r8
8000a5b2:	d8 22       	popm	r4-r7,pc

8000a5b4 <__sinit>:
8000a5b4:	d4 21       	pushm	r4-r7,lr
8000a5b6:	18 96       	mov	r6,r12
8000a5b8:	78 67       	ld.w	r7,r12[0x18]
8000a5ba:	58 07       	cp.w	r7,0
8000a5bc:	c4 91       	brne	8000a64e <__sinit+0x9a>
8000a5be:	fe c8 00 aa 	sub	r8,pc,170
8000a5c2:	30 15       	mov	r5,1
8000a5c4:	99 a8       	st.w	r12[0x28],r8
8000a5c6:	f9 47 00 d8 	st.w	r12[216],r7
8000a5ca:	f9 47 00 dc 	st.w	r12[220],r7
8000a5ce:	f9 47 00 e0 	st.w	r12[224],r7
8000a5d2:	99 65       	st.w	r12[0x18],r5
8000a5d4:	cb af       	rcall	8000a548 <__sfp>
8000a5d6:	8d 0c       	st.w	r6[0x0],r12
8000a5d8:	0c 9c       	mov	r12,r6
8000a5da:	cb 7f       	rcall	8000a548 <__sfp>
8000a5dc:	8d 1c       	st.w	r6[0x4],r12
8000a5de:	0c 9c       	mov	r12,r6
8000a5e0:	cb 4f       	rcall	8000a548 <__sfp>
8000a5e2:	6c 09       	ld.w	r9,r6[0x0]
8000a5e4:	30 48       	mov	r8,4
8000a5e6:	93 07       	st.w	r9[0x0],r7
8000a5e8:	b2 68       	st.h	r9[0xc],r8
8000a5ea:	93 17       	st.w	r9[0x4],r7
8000a5ec:	93 27       	st.w	r9[0x8],r7
8000a5ee:	6c 18       	ld.w	r8,r6[0x4]
8000a5f0:	b2 77       	st.h	r9[0xe],r7
8000a5f2:	93 47       	st.w	r9[0x10],r7
8000a5f4:	93 57       	st.w	r9[0x14],r7
8000a5f6:	93 67       	st.w	r9[0x18],r7
8000a5f8:	93 89       	st.w	r9[0x20],r9
8000a5fa:	91 07       	st.w	r8[0x0],r7
8000a5fc:	91 17       	st.w	r8[0x4],r7
8000a5fe:	91 27       	st.w	r8[0x8],r7
8000a600:	fe ce f3 24 	sub	lr,pc,-3292
8000a604:	fe cb f3 54 	sub	r11,pc,-3244
8000a608:	93 9e       	st.w	r9[0x24],lr
8000a60a:	93 ab       	st.w	r9[0x28],r11
8000a60c:	fe ca f3 7c 	sub	r10,pc,-3204
8000a610:	fe c4 f3 88 	sub	r4,pc,-3192
8000a614:	93 ba       	st.w	r9[0x2c],r10
8000a616:	93 c4       	st.w	r9[0x30],r4
8000a618:	30 99       	mov	r9,9
8000a61a:	b0 69       	st.h	r8[0xc],r9
8000a61c:	b0 75       	st.h	r8[0xe],r5
8000a61e:	91 c4       	st.w	r8[0x30],r4
8000a620:	91 47       	st.w	r8[0x10],r7
8000a622:	91 57       	st.w	r8[0x14],r7
8000a624:	91 67       	st.w	r8[0x18],r7
8000a626:	91 88       	st.w	r8[0x20],r8
8000a628:	91 9e       	st.w	r8[0x24],lr
8000a62a:	91 ab       	st.w	r8[0x28],r11
8000a62c:	91 ba       	st.w	r8[0x2c],r10
8000a62e:	8d 2c       	st.w	r6[0x8],r12
8000a630:	31 28       	mov	r8,18
8000a632:	99 07       	st.w	r12[0x0],r7
8000a634:	b8 68       	st.h	r12[0xc],r8
8000a636:	99 17       	st.w	r12[0x4],r7
8000a638:	99 27       	st.w	r12[0x8],r7
8000a63a:	30 28       	mov	r8,2
8000a63c:	b8 78       	st.h	r12[0xe],r8
8000a63e:	99 c4       	st.w	r12[0x30],r4
8000a640:	99 67       	st.w	r12[0x18],r7
8000a642:	99 9e       	st.w	r12[0x24],lr
8000a644:	99 ab       	st.w	r12[0x28],r11
8000a646:	99 ba       	st.w	r12[0x2c],r10
8000a648:	99 47       	st.w	r12[0x10],r7
8000a64a:	99 57       	st.w	r12[0x14],r7
8000a64c:	99 8c       	st.w	r12[0x20],r12
8000a64e:	d8 22       	popm	r4-r7,pc

8000a650 <_malloc_trim_r>:
8000a650:	d4 21       	pushm	r4-r7,lr
8000a652:	16 95       	mov	r5,r11
8000a654:	18 97       	mov	r7,r12
8000a656:	fe b0 d7 53 	rcall	800054fc <__malloc_lock>
8000a65a:	e0 64 05 38 	mov	r4,1336
8000a65e:	68 28       	ld.w	r8,r4[0x8]
8000a660:	70 16       	ld.w	r6,r8[0x4]
8000a662:	e0 16 ff fc 	andl	r6,0xfffc
8000a666:	ec c8 ff 91 	sub	r8,r6,-111
8000a66a:	f0 05 01 05 	sub	r5,r8,r5
8000a66e:	e0 15 ff 80 	andl	r5,0xff80
8000a672:	ea c5 00 80 	sub	r5,r5,128
8000a676:	e0 45 00 7f 	cp.w	r5,127
8000a67a:	e0 8a 00 25 	brle	8000a6c4 <_malloc_trim_r+0x74>
8000a67e:	30 0b       	mov	r11,0
8000a680:	0e 9c       	mov	r12,r7
8000a682:	fe b0 e5 f9 	rcall	80007274 <_sbrk_r>
8000a686:	68 28       	ld.w	r8,r4[0x8]
8000a688:	0c 08       	add	r8,r6
8000a68a:	10 3c       	cp.w	r12,r8
8000a68c:	c1 c1       	brne	8000a6c4 <_malloc_trim_r+0x74>
8000a68e:	ea 0b 11 00 	rsub	r11,r5,0
8000a692:	0e 9c       	mov	r12,r7
8000a694:	fe b0 e5 f0 	rcall	80007274 <_sbrk_r>
8000a698:	5b fc       	cp.w	r12,-1
8000a69a:	c1 91       	brne	8000a6cc <_malloc_trim_r+0x7c>
8000a69c:	30 0b       	mov	r11,0
8000a69e:	0e 9c       	mov	r12,r7
8000a6a0:	fe b0 e5 ea 	rcall	80007274 <_sbrk_r>
8000a6a4:	68 28       	ld.w	r8,r4[0x8]
8000a6a6:	f8 08 01 09 	sub	r9,r12,r8
8000a6aa:	58 f9       	cp.w	r9,15
8000a6ac:	e0 8a 00 0c 	brle	8000a6c4 <_malloc_trim_r+0x74>
8000a6b0:	a1 a9       	sbr	r9,0x0
8000a6b2:	91 19       	st.w	r8[0x4],r9
8000a6b4:	e0 68 09 44 	mov	r8,2372
8000a6b8:	70 09       	ld.w	r9,r8[0x0]
8000a6ba:	e0 68 0d 84 	mov	r8,3460
8000a6be:	f8 09 01 09 	sub	r9,r12,r9
8000a6c2:	91 09       	st.w	r8[0x0],r9
8000a6c4:	0e 9c       	mov	r12,r7
8000a6c6:	fe b0 d7 21 	rcall	80005508 <__malloc_unlock>
8000a6ca:	d8 2a       	popm	r4-r7,pc,r12=0
8000a6cc:	68 28       	ld.w	r8,r4[0x8]
8000a6ce:	0a 16       	sub	r6,r5
8000a6d0:	a1 a6       	sbr	r6,0x0
8000a6d2:	91 16       	st.w	r8[0x4],r6
8000a6d4:	e0 68 0d 84 	mov	r8,3460
8000a6d8:	70 09       	ld.w	r9,r8[0x0]
8000a6da:	0a 19       	sub	r9,r5
8000a6dc:	0e 9c       	mov	r12,r7
8000a6de:	91 09       	st.w	r8[0x0],r9
8000a6e0:	fe b0 d7 14 	rcall	80005508 <__malloc_unlock>
8000a6e4:	da 2a       	popm	r4-r7,pc,r12=1
8000a6e6:	d7 03       	nop

8000a6e8 <_free_r>:
8000a6e8:	d4 21       	pushm	r4-r7,lr
8000a6ea:	16 96       	mov	r6,r11
8000a6ec:	18 97       	mov	r7,r12
8000a6ee:	58 0b       	cp.w	r11,0
8000a6f0:	e0 80 00 c0 	breq	8000a870 <_free_r+0x188>
8000a6f4:	fe b0 d7 04 	rcall	800054fc <__malloc_lock>
8000a6f8:	20 86       	sub	r6,8
8000a6fa:	e0 6a 05 38 	mov	r10,1336
8000a6fe:	6c 18       	ld.w	r8,r6[0x4]
8000a700:	74 2e       	ld.w	lr,r10[0x8]
8000a702:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
8000a706:	a1 c8       	cbr	r8,0x0
8000a708:	ec 08 00 09 	add	r9,r6,r8
8000a70c:	72 1b       	ld.w	r11,r9[0x4]
8000a70e:	e0 1b ff fc 	andl	r11,0xfffc
8000a712:	1c 39       	cp.w	r9,lr
8000a714:	c1 e1       	brne	8000a750 <_free_r+0x68>
8000a716:	f6 08 00 08 	add	r8,r11,r8
8000a71a:	58 0c       	cp.w	r12,0
8000a71c:	c0 81       	brne	8000a72c <_free_r+0x44>
8000a71e:	6c 09       	ld.w	r9,r6[0x0]
8000a720:	12 16       	sub	r6,r9
8000a722:	12 08       	add	r8,r9
8000a724:	6c 3b       	ld.w	r11,r6[0xc]
8000a726:	6c 29       	ld.w	r9,r6[0x8]
8000a728:	97 29       	st.w	r11[0x8],r9
8000a72a:	93 3b       	st.w	r9[0xc],r11
8000a72c:	10 99       	mov	r9,r8
8000a72e:	95 26       	st.w	r10[0x8],r6
8000a730:	a1 a9       	sbr	r9,0x0
8000a732:	8d 19       	st.w	r6[0x4],r9
8000a734:	e0 69 09 40 	mov	r9,2368
8000a738:	72 09       	ld.w	r9,r9[0x0]
8000a73a:	12 38       	cp.w	r8,r9
8000a73c:	c0 63       	brcs	8000a748 <_free_r+0x60>
8000a73e:	e0 68 0d 80 	mov	r8,3456
8000a742:	0e 9c       	mov	r12,r7
8000a744:	70 0b       	ld.w	r11,r8[0x0]
8000a746:	c8 5f       	rcall	8000a650 <_malloc_trim_r>
8000a748:	0e 9c       	mov	r12,r7
8000a74a:	fe b0 d6 df 	rcall	80005508 <__malloc_unlock>
8000a74e:	d8 22       	popm	r4-r7,pc
8000a750:	93 1b       	st.w	r9[0x4],r11
8000a752:	58 0c       	cp.w	r12,0
8000a754:	c0 30       	breq	8000a75a <_free_r+0x72>
8000a756:	30 0c       	mov	r12,0
8000a758:	c1 08       	rjmp	8000a778 <_free_r+0x90>
8000a75a:	6c 0e       	ld.w	lr,r6[0x0]
8000a75c:	f4 c5 ff f8 	sub	r5,r10,-8
8000a760:	1c 16       	sub	r6,lr
8000a762:	1c 08       	add	r8,lr
8000a764:	6c 2e       	ld.w	lr,r6[0x8]
8000a766:	0a 3e       	cp.w	lr,r5
8000a768:	f9 bc 00 01 	moveq	r12,1
8000a76c:	ed f5 10 03 	ld.wne	r5,r6[0xc]
8000a770:	eb fe 1a 02 	st.wne	r5[0x8],lr
8000a774:	fd f5 1a 03 	st.wne	lr[0xc],r5
8000a778:	f2 0b 00 0e 	add	lr,r9,r11
8000a77c:	7c 1e       	ld.w	lr,lr[0x4]
8000a77e:	ed be 00 00 	bld	lr,0x0
8000a782:	c1 40       	breq	8000a7aa <_free_r+0xc2>
8000a784:	16 08       	add	r8,r11
8000a786:	58 0c       	cp.w	r12,0
8000a788:	c0 d1       	brne	8000a7a2 <_free_r+0xba>
8000a78a:	e0 6e 05 38 	mov	lr,1336
8000a78e:	72 2b       	ld.w	r11,r9[0x8]
8000a790:	2f 8e       	sub	lr,-8
8000a792:	1c 3b       	cp.w	r11,lr
8000a794:	c0 71       	brne	8000a7a2 <_free_r+0xba>
8000a796:	97 36       	st.w	r11[0xc],r6
8000a798:	97 26       	st.w	r11[0x8],r6
8000a79a:	8d 2b       	st.w	r6[0x8],r11
8000a79c:	8d 3b       	st.w	r6[0xc],r11
8000a79e:	30 1c       	mov	r12,1
8000a7a0:	c0 58       	rjmp	8000a7aa <_free_r+0xc2>
8000a7a2:	72 2b       	ld.w	r11,r9[0x8]
8000a7a4:	72 39       	ld.w	r9,r9[0xc]
8000a7a6:	93 2b       	st.w	r9[0x8],r11
8000a7a8:	97 39       	st.w	r11[0xc],r9
8000a7aa:	10 99       	mov	r9,r8
8000a7ac:	ec 08 09 08 	st.w	r6[r8],r8
8000a7b0:	a1 a9       	sbr	r9,0x0
8000a7b2:	8d 19       	st.w	r6[0x4],r9
8000a7b4:	58 0c       	cp.w	r12,0
8000a7b6:	c5 a1       	brne	8000a86a <_free_r+0x182>
8000a7b8:	e0 48 01 ff 	cp.w	r8,511
8000a7bc:	e0 8b 00 13 	brhi	8000a7e2 <_free_r+0xfa>
8000a7c0:	a3 98       	lsr	r8,0x3
8000a7c2:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000a7c6:	72 2b       	ld.w	r11,r9[0x8]
8000a7c8:	8d 39       	st.w	r6[0xc],r9
8000a7ca:	8d 2b       	st.w	r6[0x8],r11
8000a7cc:	97 36       	st.w	r11[0xc],r6
8000a7ce:	93 26       	st.w	r9[0x8],r6
8000a7d0:	a3 48       	asr	r8,0x2
8000a7d2:	74 19       	ld.w	r9,r10[0x4]
8000a7d4:	30 1b       	mov	r11,1
8000a7d6:	f6 08 09 48 	lsl	r8,r11,r8
8000a7da:	f3 e8 10 08 	or	r8,r9,r8
8000a7de:	95 18       	st.w	r10[0x4],r8
8000a7e0:	c4 58       	rjmp	8000a86a <_free_r+0x182>
8000a7e2:	f0 0b 16 09 	lsr	r11,r8,0x9
8000a7e6:	58 4b       	cp.w	r11,4
8000a7e8:	e0 8b 00 06 	brhi	8000a7f4 <_free_r+0x10c>
8000a7ec:	f0 0b 16 06 	lsr	r11,r8,0x6
8000a7f0:	2c 8b       	sub	r11,-56
8000a7f2:	c2 08       	rjmp	8000a832 <_free_r+0x14a>
8000a7f4:	59 4b       	cp.w	r11,20
8000a7f6:	e0 8b 00 04 	brhi	8000a7fe <_free_r+0x116>
8000a7fa:	2a 5b       	sub	r11,-91
8000a7fc:	c1 b8       	rjmp	8000a832 <_free_r+0x14a>
8000a7fe:	e0 4b 00 54 	cp.w	r11,84
8000a802:	e0 8b 00 06 	brhi	8000a80e <_free_r+0x126>
8000a806:	f0 0b 16 0c 	lsr	r11,r8,0xc
8000a80a:	29 2b       	sub	r11,-110
8000a80c:	c1 38       	rjmp	8000a832 <_free_r+0x14a>
8000a80e:	e0 4b 01 54 	cp.w	r11,340
8000a812:	e0 8b 00 06 	brhi	8000a81e <_free_r+0x136>
8000a816:	f0 0b 16 0f 	lsr	r11,r8,0xf
8000a81a:	28 9b       	sub	r11,-119
8000a81c:	c0 b8       	rjmp	8000a832 <_free_r+0x14a>
8000a81e:	e0 4b 05 54 	cp.w	r11,1364
8000a822:	e0 88 00 05 	brls	8000a82c <_free_r+0x144>
8000a826:	37 eb       	mov	r11,126
8000a828:	c0 58       	rjmp	8000a832 <_free_r+0x14a>
8000a82a:	d7 03       	nop
8000a82c:	f0 0b 16 12 	lsr	r11,r8,0x12
8000a830:	28 4b       	sub	r11,-124
8000a832:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
8000a836:	78 29       	ld.w	r9,r12[0x8]
8000a838:	18 39       	cp.w	r9,r12
8000a83a:	c0 e1       	brne	8000a856 <_free_r+0x16e>
8000a83c:	74 18       	ld.w	r8,r10[0x4]
8000a83e:	a3 4b       	asr	r11,0x2
8000a840:	30 1c       	mov	r12,1
8000a842:	f8 0b 09 4b 	lsl	r11,r12,r11
8000a846:	f1 eb 10 0b 	or	r11,r8,r11
8000a84a:	12 98       	mov	r8,r9
8000a84c:	95 1b       	st.w	r10[0x4],r11
8000a84e:	c0 a8       	rjmp	8000a862 <_free_r+0x17a>
8000a850:	72 29       	ld.w	r9,r9[0x8]
8000a852:	18 39       	cp.w	r9,r12
8000a854:	c0 60       	breq	8000a860 <_free_r+0x178>
8000a856:	72 1a       	ld.w	r10,r9[0x4]
8000a858:	e0 1a ff fc 	andl	r10,0xfffc
8000a85c:	14 38       	cp.w	r8,r10
8000a85e:	cf 93       	brcs	8000a850 <_free_r+0x168>
8000a860:	72 38       	ld.w	r8,r9[0xc]
8000a862:	8d 38       	st.w	r6[0xc],r8
8000a864:	8d 29       	st.w	r6[0x8],r9
8000a866:	93 36       	st.w	r9[0xc],r6
8000a868:	91 26       	st.w	r8[0x8],r6
8000a86a:	0e 9c       	mov	r12,r7
8000a86c:	fe b0 d6 4e 	rcall	80005508 <__malloc_unlock>
8000a870:	d8 22       	popm	r4-r7,pc
8000a872:	d7 03       	nop

8000a874 <__sfvwrite_r>:
8000a874:	d4 31       	pushm	r0-r7,lr
8000a876:	20 3d       	sub	sp,12
8000a878:	14 94       	mov	r4,r10
8000a87a:	18 95       	mov	r5,r12
8000a87c:	16 97       	mov	r7,r11
8000a87e:	74 28       	ld.w	r8,r10[0x8]
8000a880:	58 08       	cp.w	r8,0
8000a882:	e0 80 01 40 	breq	8000ab02 <__sfvwrite_r+0x28e>
8000a886:	96 68       	ld.sh	r8,r11[0xc]
8000a888:	ed b8 00 03 	bld	r8,0x3
8000a88c:	c0 41       	brne	8000a894 <__sfvwrite_r+0x20>
8000a88e:	76 48       	ld.w	r8,r11[0x10]
8000a890:	58 08       	cp.w	r8,0
8000a892:	c0 c1       	brne	8000a8aa <__sfvwrite_r+0x36>
8000a894:	0e 9b       	mov	r11,r7
8000a896:	0a 9c       	mov	r12,r5
8000a898:	fe b0 f6 c4 	rcall	80009620 <__swsetup_r>
8000a89c:	c0 70       	breq	8000a8aa <__sfvwrite_r+0x36>
8000a89e:	8e 68       	ld.sh	r8,r7[0xc]
8000a8a0:	a7 a8       	sbr	r8,0x6
8000a8a2:	ae 68       	st.h	r7[0xc],r8
8000a8a4:	30 98       	mov	r8,9
8000a8a6:	8b 38       	st.w	r5[0xc],r8
8000a8a8:	c2 b9       	rjmp	8000aafe <__sfvwrite_r+0x28a>
8000a8aa:	8e 63       	ld.sh	r3,r7[0xc]
8000a8ac:	68 00       	ld.w	r0,r4[0x0]
8000a8ae:	06 96       	mov	r6,r3
8000a8b0:	e2 16 00 02 	andl	r6,0x2,COH
8000a8b4:	c2 10       	breq	8000a8f6 <__sfvwrite_r+0x82>
8000a8b6:	30 03       	mov	r3,0
8000a8b8:	e0 62 04 00 	mov	r2,1024
8000a8bc:	06 96       	mov	r6,r3
8000a8be:	c0 48       	rjmp	8000a8c6 <__sfvwrite_r+0x52>
8000a8c0:	60 03       	ld.w	r3,r0[0x0]
8000a8c2:	60 16       	ld.w	r6,r0[0x4]
8000a8c4:	2f 80       	sub	r0,-8
8000a8c6:	58 06       	cp.w	r6,0
8000a8c8:	cf c0       	breq	8000a8c0 <__sfvwrite_r+0x4c>
8000a8ca:	e0 46 04 00 	cp.w	r6,1024
8000a8ce:	ec 09 17 80 	movls	r9,r6
8000a8d2:	e4 09 17 b0 	movhi	r9,r2
8000a8d6:	06 9a       	mov	r10,r3
8000a8d8:	6e a8       	ld.w	r8,r7[0x28]
8000a8da:	6e 8b       	ld.w	r11,r7[0x20]
8000a8dc:	0a 9c       	mov	r12,r5
8000a8de:	5d 18       	icall	r8
8000a8e0:	18 16       	sub	r6,r12
8000a8e2:	58 0c       	cp.w	r12,0
8000a8e4:	e0 8a 01 0a 	brle	8000aaf8 <__sfvwrite_r+0x284>
8000a8e8:	68 28       	ld.w	r8,r4[0x8]
8000a8ea:	18 18       	sub	r8,r12
8000a8ec:	89 28       	st.w	r4[0x8],r8
8000a8ee:	e0 80 01 0a 	breq	8000ab02 <__sfvwrite_r+0x28e>
8000a8f2:	18 03       	add	r3,r12
8000a8f4:	ce 9b       	rjmp	8000a8c6 <__sfvwrite_r+0x52>
8000a8f6:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
8000a8fa:	c0 70       	breq	8000a908 <__sfvwrite_r+0x94>
8000a8fc:	50 06       	stdsp	sp[0x0],r6
8000a8fe:	0c 93       	mov	r3,r6
8000a900:	0c 91       	mov	r1,r6
8000a902:	50 15       	stdsp	sp[0x4],r5
8000a904:	08 92       	mov	r2,r4
8000a906:	c9 c8       	rjmp	8000aa3e <__sfvwrite_r+0x1ca>
8000a908:	06 96       	mov	r6,r3
8000a90a:	08 91       	mov	r1,r4
8000a90c:	c0 48       	rjmp	8000a914 <__sfvwrite_r+0xa0>
8000a90e:	60 03       	ld.w	r3,r0[0x0]
8000a910:	60 16       	ld.w	r6,r0[0x4]
8000a912:	2f 80       	sub	r0,-8
8000a914:	58 06       	cp.w	r6,0
8000a916:	cf c0       	breq	8000a90e <__sfvwrite_r+0x9a>
8000a918:	8e 68       	ld.sh	r8,r7[0xc]
8000a91a:	6e 24       	ld.w	r4,r7[0x8]
8000a91c:	10 99       	mov	r9,r8
8000a91e:	e2 19 02 00 	andl	r9,0x200,COH
8000a922:	c5 50       	breq	8000a9cc <__sfvwrite_r+0x158>
8000a924:	08 36       	cp.w	r6,r4
8000a926:	c4 43       	brcs	8000a9ae <__sfvwrite_r+0x13a>
8000a928:	10 99       	mov	r9,r8
8000a92a:	e2 19 04 80 	andl	r9,0x480,COH
8000a92e:	c4 00       	breq	8000a9ae <__sfvwrite_r+0x13a>
8000a930:	6e 4b       	ld.w	r11,r7[0x10]
8000a932:	6e 09       	ld.w	r9,r7[0x0]
8000a934:	16 19       	sub	r9,r11
8000a936:	50 09       	stdsp	sp[0x0],r9
8000a938:	6e 59       	ld.w	r9,r7[0x14]
8000a93a:	10 9c       	mov	r12,r8
8000a93c:	f2 09 00 1a 	add	r10,r9,r9<<0x1
8000a940:	30 28       	mov	r8,2
8000a942:	f4 08 0c 08 	divs	r8,r10,r8
8000a946:	fa e9 00 04 	st.d	sp[4],r8
8000a94a:	10 94       	mov	r4,r8
8000a94c:	40 09       	lddsp	r9,sp[0x0]
8000a94e:	e2 1c 04 00 	andl	r12,0x400,COH
8000a952:	2f f9       	sub	r9,-1
8000a954:	0c 09       	add	r9,r6
8000a956:	12 38       	cp.w	r8,r9
8000a958:	f2 04 17 30 	movlo	r4,r9
8000a95c:	58 0c       	cp.w	r12,0
8000a95e:	c1 10       	breq	8000a980 <__sfvwrite_r+0x10c>
8000a960:	08 9b       	mov	r11,r4
8000a962:	0a 9c       	mov	r12,r5
8000a964:	fe b0 e0 60 	rcall	80006a24 <_malloc_r>
8000a968:	18 92       	mov	r2,r12
8000a96a:	c1 40       	breq	8000a992 <__sfvwrite_r+0x11e>
8000a96c:	40 0a       	lddsp	r10,sp[0x0]
8000a96e:	6e 4b       	ld.w	r11,r7[0x10]
8000a970:	fe b0 e2 76 	rcall	80006e5c <memcpy>
8000a974:	8e 68       	ld.sh	r8,r7[0xc]
8000a976:	e0 18 fb 7f 	andl	r8,0xfb7f
8000a97a:	a7 b8       	sbr	r8,0x7
8000a97c:	ae 68       	st.h	r7[0xc],r8
8000a97e:	c0 d8       	rjmp	8000a998 <__sfvwrite_r+0x124>
8000a980:	08 9a       	mov	r10,r4
8000a982:	0a 9c       	mov	r12,r5
8000a984:	fe b0 e3 18 	rcall	80006fb4 <_realloc_r>
8000a988:	18 92       	mov	r2,r12
8000a98a:	c0 71       	brne	8000a998 <__sfvwrite_r+0x124>
8000a98c:	6e 4b       	ld.w	r11,r7[0x10]
8000a98e:	0a 9c       	mov	r12,r5
8000a990:	ca ce       	rcall	8000a6e8 <_free_r>
8000a992:	30 c8       	mov	r8,12
8000a994:	8b 38       	st.w	r5[0xc],r8
8000a996:	cb 18       	rjmp	8000aaf8 <__sfvwrite_r+0x284>
8000a998:	40 0a       	lddsp	r10,sp[0x0]
8000a99a:	40 09       	lddsp	r9,sp[0x0]
8000a99c:	e8 0a 01 0a 	sub	r10,r4,r10
8000a9a0:	e4 09 00 08 	add	r8,r2,r9
8000a9a4:	8f 54       	st.w	r7[0x14],r4
8000a9a6:	8f 2a       	st.w	r7[0x8],r10
8000a9a8:	8f 08       	st.w	r7[0x0],r8
8000a9aa:	8f 42       	st.w	r7[0x10],r2
8000a9ac:	0c 94       	mov	r4,r6
8000a9ae:	08 36       	cp.w	r6,r4
8000a9b0:	ec 04 17 30 	movlo	r4,r6
8000a9b4:	06 9b       	mov	r11,r3
8000a9b6:	08 9a       	mov	r10,r4
8000a9b8:	6e 0c       	ld.w	r12,r7[0x0]
8000a9ba:	c3 ad       	rcall	8000ac2e <memmove>
8000a9bc:	6e 08       	ld.w	r8,r7[0x0]
8000a9be:	08 08       	add	r8,r4
8000a9c0:	8f 08       	st.w	r7[0x0],r8
8000a9c2:	6e 28       	ld.w	r8,r7[0x8]
8000a9c4:	08 18       	sub	r8,r4
8000a9c6:	0c 94       	mov	r4,r6
8000a9c8:	8f 28       	st.w	r7[0x8],r8
8000a9ca:	c2 e8       	rjmp	8000aa26 <__sfvwrite_r+0x1b2>
8000a9cc:	08 36       	cp.w	r6,r4
8000a9ce:	5f ba       	srhi	r10
8000a9d0:	6e 0c       	ld.w	r12,r7[0x0]
8000a9d2:	6e 48       	ld.w	r8,r7[0x10]
8000a9d4:	10 3c       	cp.w	r12,r8
8000a9d6:	5f b8       	srhi	r8
8000a9d8:	f5 e8 00 08 	and	r8,r10,r8
8000a9dc:	f2 08 18 00 	cp.b	r8,r9
8000a9e0:	c0 d0       	breq	8000a9fa <__sfvwrite_r+0x186>
8000a9e2:	06 9b       	mov	r11,r3
8000a9e4:	08 9a       	mov	r10,r4
8000a9e6:	c2 4d       	rcall	8000ac2e <memmove>
8000a9e8:	6e 08       	ld.w	r8,r7[0x0]
8000a9ea:	08 08       	add	r8,r4
8000a9ec:	0e 9b       	mov	r11,r7
8000a9ee:	8f 08       	st.w	r7[0x0],r8
8000a9f0:	0a 9c       	mov	r12,r5
8000a9f2:	fe b0 fd 09 	rcall	8000a404 <_fflush_r>
8000a9f6:	c1 80       	breq	8000aa26 <__sfvwrite_r+0x1b2>
8000a9f8:	c8 08       	rjmp	8000aaf8 <__sfvwrite_r+0x284>
8000a9fa:	6e 59       	ld.w	r9,r7[0x14]
8000a9fc:	12 36       	cp.w	r6,r9
8000a9fe:	c0 a3       	brcs	8000aa12 <__sfvwrite_r+0x19e>
8000aa00:	6e a8       	ld.w	r8,r7[0x28]
8000aa02:	06 9a       	mov	r10,r3
8000aa04:	6e 8b       	ld.w	r11,r7[0x20]
8000aa06:	0a 9c       	mov	r12,r5
8000aa08:	5d 18       	icall	r8
8000aa0a:	18 94       	mov	r4,r12
8000aa0c:	e0 89 00 0d 	brgt	8000aa26 <__sfvwrite_r+0x1b2>
8000aa10:	c7 48       	rjmp	8000aaf8 <__sfvwrite_r+0x284>
8000aa12:	0c 9a       	mov	r10,r6
8000aa14:	06 9b       	mov	r11,r3
8000aa16:	c0 cd       	rcall	8000ac2e <memmove>
8000aa18:	6e 08       	ld.w	r8,r7[0x0]
8000aa1a:	0c 08       	add	r8,r6
8000aa1c:	0c 94       	mov	r4,r6
8000aa1e:	8f 08       	st.w	r7[0x0],r8
8000aa20:	6e 28       	ld.w	r8,r7[0x8]
8000aa22:	0c 18       	sub	r8,r6
8000aa24:	8f 28       	st.w	r7[0x8],r8
8000aa26:	62 28       	ld.w	r8,r1[0x8]
8000aa28:	08 18       	sub	r8,r4
8000aa2a:	83 28       	st.w	r1[0x8],r8
8000aa2c:	c6 b0       	breq	8000ab02 <__sfvwrite_r+0x28e>
8000aa2e:	08 16       	sub	r6,r4
8000aa30:	08 03       	add	r3,r4
8000aa32:	c7 1b       	rjmp	8000a914 <__sfvwrite_r+0xa0>
8000aa34:	60 03       	ld.w	r3,r0[0x0]
8000aa36:	60 11       	ld.w	r1,r0[0x4]
8000aa38:	30 08       	mov	r8,0
8000aa3a:	2f 80       	sub	r0,-8
8000aa3c:	50 08       	stdsp	sp[0x0],r8
8000aa3e:	58 01       	cp.w	r1,0
8000aa40:	cf a0       	breq	8000aa34 <__sfvwrite_r+0x1c0>
8000aa42:	40 0a       	lddsp	r10,sp[0x0]
8000aa44:	58 0a       	cp.w	r10,0
8000aa46:	c1 41       	brne	8000aa6e <__sfvwrite_r+0x1fa>
8000aa48:	e2 c6 ff ff 	sub	r6,r1,-1
8000aa4c:	02 9a       	mov	r10,r1
8000aa4e:	30 ab       	mov	r11,10
8000aa50:	06 9c       	mov	r12,r3
8000aa52:	ce 3c       	rcall	8000ac18 <memchr>
8000aa54:	f8 c8 ff ff 	sub	r8,r12,-1
8000aa58:	58 0c       	cp.w	r12,0
8000aa5a:	f1 d3 e1 16 	subne	r6,r8,r3
8000aa5e:	f9 b9 01 01 	movne	r9,1
8000aa62:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000aa66:	f9 b8 00 01 	moveq	r8,1
8000aa6a:	fb f8 0a 00 	st.weq	sp[0x0],r8
8000aa6e:	02 36       	cp.w	r6,r1
8000aa70:	ec 04 17 80 	movls	r4,r6
8000aa74:	e2 04 17 b0 	movhi	r4,r1
8000aa78:	6e 59       	ld.w	r9,r7[0x14]
8000aa7a:	6e 25       	ld.w	r5,r7[0x8]
8000aa7c:	f2 05 00 05 	add	r5,r9,r5
8000aa80:	0a 34       	cp.w	r4,r5
8000aa82:	5f 9a       	srgt	r10
8000aa84:	6e 0c       	ld.w	r12,r7[0x0]
8000aa86:	6e 48       	ld.w	r8,r7[0x10]
8000aa88:	10 3c       	cp.w	r12,r8
8000aa8a:	5f b8       	srhi	r8
8000aa8c:	f5 e8 00 08 	and	r8,r10,r8
8000aa90:	30 0a       	mov	r10,0
8000aa92:	f4 08 18 00 	cp.b	r8,r10
8000aa96:	c0 d0       	breq	8000aab0 <__sfvwrite_r+0x23c>
8000aa98:	06 9b       	mov	r11,r3
8000aa9a:	0a 9a       	mov	r10,r5
8000aa9c:	cc 9c       	rcall	8000ac2e <memmove>
8000aa9e:	6e 08       	ld.w	r8,r7[0x0]
8000aaa0:	0a 08       	add	r8,r5
8000aaa2:	0e 9b       	mov	r11,r7
8000aaa4:	8f 08       	st.w	r7[0x0],r8
8000aaa6:	40 1c       	lddsp	r12,sp[0x4]
8000aaa8:	fe b0 fc ae 	rcall	8000a404 <_fflush_r>
8000aaac:	c1 70       	breq	8000aada <__sfvwrite_r+0x266>
8000aaae:	c2 58       	rjmp	8000aaf8 <__sfvwrite_r+0x284>
8000aab0:	12 34       	cp.w	r4,r9
8000aab2:	c0 a5       	brlt	8000aac6 <__sfvwrite_r+0x252>
8000aab4:	6e a8       	ld.w	r8,r7[0x28]
8000aab6:	06 9a       	mov	r10,r3
8000aab8:	6e 8b       	ld.w	r11,r7[0x20]
8000aaba:	40 1c       	lddsp	r12,sp[0x4]
8000aabc:	5d 18       	icall	r8
8000aabe:	18 95       	mov	r5,r12
8000aac0:	e0 89 00 0d 	brgt	8000aada <__sfvwrite_r+0x266>
8000aac4:	c1 a8       	rjmp	8000aaf8 <__sfvwrite_r+0x284>
8000aac6:	08 9a       	mov	r10,r4
8000aac8:	06 9b       	mov	r11,r3
8000aaca:	cb 2c       	rcall	8000ac2e <memmove>
8000aacc:	6e 08       	ld.w	r8,r7[0x0]
8000aace:	08 08       	add	r8,r4
8000aad0:	08 95       	mov	r5,r4
8000aad2:	8f 08       	st.w	r7[0x0],r8
8000aad4:	6e 28       	ld.w	r8,r7[0x8]
8000aad6:	08 18       	sub	r8,r4
8000aad8:	8f 28       	st.w	r7[0x8],r8
8000aada:	0a 16       	sub	r6,r5
8000aadc:	c0 71       	brne	8000aaea <__sfvwrite_r+0x276>
8000aade:	0e 9b       	mov	r11,r7
8000aae0:	40 1c       	lddsp	r12,sp[0x4]
8000aae2:	fe b0 fc 91 	rcall	8000a404 <_fflush_r>
8000aae6:	c0 91       	brne	8000aaf8 <__sfvwrite_r+0x284>
8000aae8:	50 06       	stdsp	sp[0x0],r6
8000aaea:	64 28       	ld.w	r8,r2[0x8]
8000aaec:	0a 18       	sub	r8,r5
8000aaee:	85 28       	st.w	r2[0x8],r8
8000aaf0:	c0 90       	breq	8000ab02 <__sfvwrite_r+0x28e>
8000aaf2:	0a 11       	sub	r1,r5
8000aaf4:	0a 03       	add	r3,r5
8000aaf6:	ca 4b       	rjmp	8000aa3e <__sfvwrite_r+0x1ca>
8000aaf8:	8e 68       	ld.sh	r8,r7[0xc]
8000aafa:	a7 a8       	sbr	r8,0x6
8000aafc:	ae 68       	st.h	r7[0xc],r8
8000aafe:	3f fc       	mov	r12,-1
8000ab00:	c0 28       	rjmp	8000ab04 <__sfvwrite_r+0x290>
8000ab02:	30 0c       	mov	r12,0
8000ab04:	2f dd       	sub	sp,-12
8000ab06:	d8 32       	popm	r0-r7,pc

8000ab08 <_fwalk>:
8000ab08:	d4 31       	pushm	r0-r7,lr
8000ab0a:	30 05       	mov	r5,0
8000ab0c:	16 91       	mov	r1,r11
8000ab0e:	f8 c7 ff 28 	sub	r7,r12,-216
8000ab12:	0a 92       	mov	r2,r5
8000ab14:	fe b0 fc fe 	rcall	8000a510 <__sfp_lock_acquire>
8000ab18:	3f f3       	mov	r3,-1
8000ab1a:	c1 68       	rjmp	8000ab46 <_fwalk+0x3e>
8000ab1c:	6e 26       	ld.w	r6,r7[0x8]
8000ab1e:	6e 14       	ld.w	r4,r7[0x4]
8000ab20:	2f 46       	sub	r6,-12
8000ab22:	c0 c8       	rjmp	8000ab3a <_fwalk+0x32>
8000ab24:	8c 08       	ld.sh	r8,r6[0x0]
8000ab26:	e4 08 19 00 	cp.h	r8,r2
8000ab2a:	c0 70       	breq	8000ab38 <_fwalk+0x30>
8000ab2c:	8c 18       	ld.sh	r8,r6[0x2]
8000ab2e:	e6 08 19 00 	cp.h	r8,r3
8000ab32:	c0 30       	breq	8000ab38 <_fwalk+0x30>
8000ab34:	5d 11       	icall	r1
8000ab36:	18 45       	or	r5,r12
8000ab38:	2a 46       	sub	r6,-92
8000ab3a:	20 14       	sub	r4,1
8000ab3c:	ec cc 00 0c 	sub	r12,r6,12
8000ab40:	58 04       	cp.w	r4,0
8000ab42:	cf 14       	brge	8000ab24 <_fwalk+0x1c>
8000ab44:	6e 07       	ld.w	r7,r7[0x0]
8000ab46:	58 07       	cp.w	r7,0
8000ab48:	ce a1       	brne	8000ab1c <_fwalk+0x14>
8000ab4a:	fe b0 fc e4 	rcall	8000a512 <__sfp_lock_release>
8000ab4e:	0a 9c       	mov	r12,r5
8000ab50:	d8 32       	popm	r0-r7,pc
8000ab52:	d7 03       	nop

8000ab54 <_localeconv_r>:
8000ab54:	fe cc cf 2c 	sub	r12,pc,-12500
8000ab58:	5e fc       	retal	r12
8000ab5a:	d7 03       	nop

8000ab5c <__smakebuf_r>:
8000ab5c:	d4 21       	pushm	r4-r7,lr
8000ab5e:	20 fd       	sub	sp,60
8000ab60:	96 68       	ld.sh	r8,r11[0xc]
8000ab62:	16 97       	mov	r7,r11
8000ab64:	18 96       	mov	r6,r12
8000ab66:	e2 18 00 02 	andl	r8,0x2,COH
8000ab6a:	c3 d1       	brne	8000abe4 <__smakebuf_r+0x88>
8000ab6c:	96 7b       	ld.sh	r11,r11[0xe]
8000ab6e:	f0 0b 19 00 	cp.h	r11,r8
8000ab72:	c0 55       	brlt	8000ab7c <__smakebuf_r+0x20>
8000ab74:	1a 9a       	mov	r10,sp
8000ab76:	e0 a0 04 75 	rcall	8000b460 <_fstat_r>
8000ab7a:	c0 f4       	brge	8000ab98 <__smakebuf_r+0x3c>
8000ab7c:	8e 65       	ld.sh	r5,r7[0xc]
8000ab7e:	0a 98       	mov	r8,r5
8000ab80:	ab b8       	sbr	r8,0xb
8000ab82:	e2 15 00 80 	andl	r5,0x80,COH
8000ab86:	ae 68       	st.h	r7[0xc],r8
8000ab88:	30 04       	mov	r4,0
8000ab8a:	e0 68 04 00 	mov	r8,1024
8000ab8e:	f9 b5 01 40 	movne	r5,64
8000ab92:	f0 05 17 00 	moveq	r5,r8
8000ab96:	c1 c8       	rjmp	8000abce <__smakebuf_r+0x72>
8000ab98:	40 18       	lddsp	r8,sp[0x4]
8000ab9a:	e2 18 f0 00 	andl	r8,0xf000,COH
8000ab9e:	e0 48 20 00 	cp.w	r8,8192
8000aba2:	5f 04       	sreq	r4
8000aba4:	e0 48 80 00 	cp.w	r8,32768
8000aba8:	c0 e1       	brne	8000abc4 <__smakebuf_r+0x68>
8000abaa:	6e b9       	ld.w	r9,r7[0x2c]
8000abac:	fe c8 f9 1c 	sub	r8,pc,-1764
8000abb0:	10 39       	cp.w	r9,r8
8000abb2:	c0 91       	brne	8000abc4 <__smakebuf_r+0x68>
8000abb4:	8e 68       	ld.sh	r8,r7[0xc]
8000abb6:	e0 65 04 00 	mov	r5,1024
8000abba:	ab a8       	sbr	r8,0xa
8000abbc:	ef 45 00 50 	st.w	r7[80],r5
8000abc0:	ae 68       	st.h	r7[0xc],r8
8000abc2:	c0 68       	rjmp	8000abce <__smakebuf_r+0x72>
8000abc4:	8e 68       	ld.sh	r8,r7[0xc]
8000abc6:	e0 65 04 00 	mov	r5,1024
8000abca:	ab b8       	sbr	r8,0xb
8000abcc:	ae 68       	st.h	r7[0xc],r8
8000abce:	0a 9b       	mov	r11,r5
8000abd0:	0c 9c       	mov	r12,r6
8000abd2:	fe b0 df 29 	rcall	80006a24 <_malloc_r>
8000abd6:	8e 68       	ld.sh	r8,r7[0xc]
8000abd8:	c0 d1       	brne	8000abf2 <__smakebuf_r+0x96>
8000abda:	ed b8 00 09 	bld	r8,0x9
8000abde:	c1 b0       	breq	8000ac14 <__smakebuf_r+0xb8>
8000abe0:	a1 b8       	sbr	r8,0x1
8000abe2:	ae 68       	st.h	r7[0xc],r8
8000abe4:	ee c8 ff b9 	sub	r8,r7,-71
8000abe8:	8f 48       	st.w	r7[0x10],r8
8000abea:	8f 08       	st.w	r7[0x0],r8
8000abec:	30 18       	mov	r8,1
8000abee:	8f 58       	st.w	r7[0x14],r8
8000abf0:	c1 28       	rjmp	8000ac14 <__smakebuf_r+0xb8>
8000abf2:	a7 b8       	sbr	r8,0x7
8000abf4:	8f 4c       	st.w	r7[0x10],r12
8000abf6:	ae 68       	st.h	r7[0xc],r8
8000abf8:	8f 55       	st.w	r7[0x14],r5
8000abfa:	fe c8 06 e6 	sub	r8,pc,1766
8000abfe:	8f 0c       	st.w	r7[0x0],r12
8000ac00:	8d a8       	st.w	r6[0x28],r8
8000ac02:	58 04       	cp.w	r4,0
8000ac04:	c0 80       	breq	8000ac14 <__smakebuf_r+0xb8>
8000ac06:	8e 7c       	ld.sh	r12,r7[0xe]
8000ac08:	fe b0 e3 94 	rcall	80007330 <isatty>
8000ac0c:	c0 40       	breq	8000ac14 <__smakebuf_r+0xb8>
8000ac0e:	8e 68       	ld.sh	r8,r7[0xc]
8000ac10:	a1 a8       	sbr	r8,0x0
8000ac12:	ae 68       	st.h	r7[0xc],r8
8000ac14:	2f 1d       	sub	sp,-60
8000ac16:	d8 22       	popm	r4-r7,pc

8000ac18 <memchr>:
8000ac18:	f7 db c0 08 	bfextu	r11,r11,0x0,0x8
8000ac1c:	c0 68       	rjmp	8000ac28 <memchr+0x10>
8000ac1e:	20 1a       	sub	r10,1
8000ac20:	19 88       	ld.ub	r8,r12[0x0]
8000ac22:	16 38       	cp.w	r8,r11
8000ac24:	5e 0c       	reteq	r12
8000ac26:	2f fc       	sub	r12,-1
8000ac28:	58 0a       	cp.w	r10,0
8000ac2a:	cf a1       	brne	8000ac1e <memchr+0x6>
8000ac2c:	5e fa       	retal	r10

8000ac2e <memmove>:
8000ac2e:	d4 01       	pushm	lr
8000ac30:	18 3b       	cp.w	r11,r12
8000ac32:	c1 92       	brcc	8000ac64 <memmove+0x36>
8000ac34:	f6 0a 00 09 	add	r9,r11,r10
8000ac38:	12 3c       	cp.w	r12,r9
8000ac3a:	c1 52       	brcc	8000ac64 <memmove+0x36>
8000ac3c:	f8 0a 00 0b 	add	r11,r12,r10
8000ac40:	30 08       	mov	r8,0
8000ac42:	c0 68       	rjmp	8000ac4e <memmove+0x20>
8000ac44:	f2 08 07 0e 	ld.ub	lr,r9[r8]
8000ac48:	20 1a       	sub	r10,1
8000ac4a:	f6 08 0b 0e 	st.b	r11[r8],lr
8000ac4e:	20 18       	sub	r8,1
8000ac50:	58 0a       	cp.w	r10,0
8000ac52:	cf 91       	brne	8000ac44 <memmove+0x16>
8000ac54:	d8 02       	popm	pc
8000ac56:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000ac5a:	20 1a       	sub	r10,1
8000ac5c:	f8 08 0b 09 	st.b	r12[r8],r9
8000ac60:	2f f8       	sub	r8,-1
8000ac62:	c0 28       	rjmp	8000ac66 <memmove+0x38>
8000ac64:	30 08       	mov	r8,0
8000ac66:	58 0a       	cp.w	r10,0
8000ac68:	cf 71       	brne	8000ac56 <memmove+0x28>
8000ac6a:	d8 02       	popm	pc

8000ac6c <__hi0bits>:
8000ac6c:	18 98       	mov	r8,r12
8000ac6e:	e0 1c 00 00 	andl	r12,0x0
8000ac72:	f0 09 15 10 	lsl	r9,r8,0x10
8000ac76:	58 0c       	cp.w	r12,0
8000ac78:	f2 08 17 00 	moveq	r8,r9
8000ac7c:	f9 bc 00 10 	moveq	r12,16
8000ac80:	f9 bc 01 00 	movne	r12,0
8000ac84:	10 9a       	mov	r10,r8
8000ac86:	f0 09 15 08 	lsl	r9,r8,0x8
8000ac8a:	e6 1a ff 00 	andh	r10,0xff00,COH
8000ac8e:	f7 bc 00 f8 	subeq	r12,-8
8000ac92:	f2 08 17 00 	moveq	r8,r9
8000ac96:	10 9a       	mov	r10,r8
8000ac98:	f0 09 15 04 	lsl	r9,r8,0x4
8000ac9c:	e6 1a f0 00 	andh	r10,0xf000,COH
8000aca0:	f7 bc 00 fc 	subeq	r12,-4
8000aca4:	f2 08 17 00 	moveq	r8,r9
8000aca8:	10 9a       	mov	r10,r8
8000acaa:	f0 09 15 02 	lsl	r9,r8,0x2
8000acae:	e6 1a c0 00 	andh	r10,0xc000,COH
8000acb2:	f7 bc 00 fe 	subeq	r12,-2
8000acb6:	f2 08 17 00 	moveq	r8,r9
8000acba:	58 08       	cp.w	r8,0
8000acbc:	5e 5c       	retlt	r12
8000acbe:	ed b8 00 1e 	bld	r8,0x1e
8000acc2:	f9 bc 01 20 	movne	r12,32
8000acc6:	f7 bc 00 ff 	subeq	r12,-1
8000acca:	5e fc       	retal	r12

8000accc <__lo0bits>:
8000accc:	18 99       	mov	r9,r12
8000acce:	78 08       	ld.w	r8,r12[0x0]
8000acd0:	f9 d8 c0 03 	bfextu	r12,r8,0x0,0x3
8000acd4:	c1 50       	breq	8000acfe <__lo0bits+0x32>
8000acd6:	ed b8 00 00 	bld	r8,0x0
8000acda:	c0 21       	brne	8000acde <__lo0bits+0x12>
8000acdc:	5e fd       	retal	0
8000acde:	10 9b       	mov	r11,r8
8000ace0:	f0 0a 16 01 	lsr	r10,r8,0x1
8000ace4:	e2 1b 00 02 	andl	r11,0x2,COH
8000ace8:	a3 88       	lsr	r8,0x2
8000acea:	58 0b       	cp.w	r11,0
8000acec:	f3 fa 1a 00 	st.wne	r9[0x0],r10
8000acf0:	f9 bc 01 01 	movne	r12,1
8000acf4:	f3 f8 0a 00 	st.weq	r9[0x0],r8
8000acf8:	f9 bc 00 02 	moveq	r12,2
8000acfc:	5e fc       	retal	r12
8000acfe:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8000ad02:	f0 0b 16 10 	lsr	r11,r8,0x10
8000ad06:	58 0a       	cp.w	r10,0
8000ad08:	f6 08 17 00 	moveq	r8,r11
8000ad0c:	f9 bc 00 10 	moveq	r12,16
8000ad10:	f7 d8 c0 08 	bfextu	r11,r8,0x0,0x8
8000ad14:	f0 0a 16 08 	lsr	r10,r8,0x8
8000ad18:	58 0b       	cp.w	r11,0
8000ad1a:	f7 bc 00 f8 	subeq	r12,-8
8000ad1e:	f4 08 17 00 	moveq	r8,r10
8000ad22:	f7 d8 c0 04 	bfextu	r11,r8,0x0,0x4
8000ad26:	f0 0a 16 04 	lsr	r10,r8,0x4
8000ad2a:	58 0b       	cp.w	r11,0
8000ad2c:	f7 bc 00 fc 	subeq	r12,-4
8000ad30:	f4 08 17 00 	moveq	r8,r10
8000ad34:	f7 d8 c0 02 	bfextu	r11,r8,0x0,0x2
8000ad38:	f0 0a 16 02 	lsr	r10,r8,0x2
8000ad3c:	58 0b       	cp.w	r11,0
8000ad3e:	f7 bc 00 fe 	subeq	r12,-2
8000ad42:	f4 08 17 00 	moveq	r8,r10
8000ad46:	ed b8 00 00 	bld	r8,0x0
8000ad4a:	c0 60       	breq	8000ad56 <__lo0bits+0x8a>
8000ad4c:	a1 98       	lsr	r8,0x1
8000ad4e:	c0 31       	brne	8000ad54 <__lo0bits+0x88>
8000ad50:	32 0c       	mov	r12,32
8000ad52:	5e fc       	retal	r12
8000ad54:	2f fc       	sub	r12,-1
8000ad56:	93 08       	st.w	r9[0x0],r8
8000ad58:	5e fc       	retal	r12

8000ad5a <__mcmp>:
8000ad5a:	d4 01       	pushm	lr
8000ad5c:	18 98       	mov	r8,r12
8000ad5e:	76 49       	ld.w	r9,r11[0x10]
8000ad60:	78 4c       	ld.w	r12,r12[0x10]
8000ad62:	12 1c       	sub	r12,r9
8000ad64:	c1 31       	brne	8000ad8a <__mcmp+0x30>
8000ad66:	2f b9       	sub	r9,-5
8000ad68:	a3 69       	lsl	r9,0x2
8000ad6a:	12 0b       	add	r11,r9
8000ad6c:	f0 09 00 09 	add	r9,r8,r9
8000ad70:	2e c8       	sub	r8,-20
8000ad72:	13 4e       	ld.w	lr,--r9
8000ad74:	17 4a       	ld.w	r10,--r11
8000ad76:	14 3e       	cp.w	lr,r10
8000ad78:	c0 60       	breq	8000ad84 <__mcmp+0x2a>
8000ad7a:	f9 bc 03 ff 	movlo	r12,-1
8000ad7e:	f9 bc 02 01 	movhs	r12,1
8000ad82:	d8 02       	popm	pc
8000ad84:	10 39       	cp.w	r9,r8
8000ad86:	fe 9b ff f6 	brhi	8000ad72 <__mcmp+0x18>
8000ad8a:	d8 02       	popm	pc

8000ad8c <_Bfree>:
8000ad8c:	d4 21       	pushm	r4-r7,lr
8000ad8e:	18 97       	mov	r7,r12
8000ad90:	16 95       	mov	r5,r11
8000ad92:	78 96       	ld.w	r6,r12[0x24]
8000ad94:	58 06       	cp.w	r6,0
8000ad96:	c0 91       	brne	8000ada8 <_Bfree+0x1c>
8000ad98:	31 0c       	mov	r12,16
8000ad9a:	fe b0 de 3d 	rcall	80006a14 <malloc>
8000ad9e:	99 36       	st.w	r12[0xc],r6
8000ada0:	8f 9c       	st.w	r7[0x24],r12
8000ada2:	99 16       	st.w	r12[0x4],r6
8000ada4:	99 26       	st.w	r12[0x8],r6
8000ada6:	99 06       	st.w	r12[0x0],r6
8000ada8:	58 05       	cp.w	r5,0
8000adaa:	c0 90       	breq	8000adbc <_Bfree+0x30>
8000adac:	6a 19       	ld.w	r9,r5[0x4]
8000adae:	6e 98       	ld.w	r8,r7[0x24]
8000adb0:	70 38       	ld.w	r8,r8[0xc]
8000adb2:	f0 09 03 2a 	ld.w	r10,r8[r9<<0x2]
8000adb6:	8b 0a       	st.w	r5[0x0],r10
8000adb8:	f0 09 09 25 	st.w	r8[r9<<0x2],r5
8000adbc:	d8 22       	popm	r4-r7,pc
8000adbe:	d7 03       	nop

8000adc0 <_Balloc>:
8000adc0:	d4 21       	pushm	r4-r7,lr
8000adc2:	18 97       	mov	r7,r12
8000adc4:	16 96       	mov	r6,r11
8000adc6:	78 95       	ld.w	r5,r12[0x24]
8000adc8:	58 05       	cp.w	r5,0
8000adca:	c0 91       	brne	8000addc <_Balloc+0x1c>
8000adcc:	31 0c       	mov	r12,16
8000adce:	fe b0 de 23 	rcall	80006a14 <malloc>
8000add2:	99 35       	st.w	r12[0xc],r5
8000add4:	8f 9c       	st.w	r7[0x24],r12
8000add6:	99 15       	st.w	r12[0x4],r5
8000add8:	99 25       	st.w	r12[0x8],r5
8000adda:	99 05       	st.w	r12[0x0],r5
8000addc:	6e 95       	ld.w	r5,r7[0x24]
8000adde:	6a 38       	ld.w	r8,r5[0xc]
8000ade0:	58 08       	cp.w	r8,0
8000ade2:	c0 b1       	brne	8000adf8 <_Balloc+0x38>
8000ade4:	31 0a       	mov	r10,16
8000ade6:	30 4b       	mov	r11,4
8000ade8:	0e 9c       	mov	r12,r7
8000adea:	e0 a0 02 9b 	rcall	8000b320 <_calloc_r>
8000adee:	8b 3c       	st.w	r5[0xc],r12
8000adf0:	6e 98       	ld.w	r8,r7[0x24]
8000adf2:	70 3c       	ld.w	r12,r8[0xc]
8000adf4:	58 0c       	cp.w	r12,0
8000adf6:	c1 b0       	breq	8000ae2c <_Balloc+0x6c>
8000adf8:	6e 98       	ld.w	r8,r7[0x24]
8000adfa:	70 38       	ld.w	r8,r8[0xc]
8000adfc:	f0 06 00 28 	add	r8,r8,r6<<0x2
8000ae00:	70 0c       	ld.w	r12,r8[0x0]
8000ae02:	58 0c       	cp.w	r12,0
8000ae04:	c0 40       	breq	8000ae0c <_Balloc+0x4c>
8000ae06:	78 09       	ld.w	r9,r12[0x0]
8000ae08:	91 09       	st.w	r8[0x0],r9
8000ae0a:	c0 e8       	rjmp	8000ae26 <_Balloc+0x66>
8000ae0c:	0e 9c       	mov	r12,r7
8000ae0e:	30 17       	mov	r7,1
8000ae10:	0e 9b       	mov	r11,r7
8000ae12:	ee 06 09 47 	lsl	r7,r7,r6
8000ae16:	ee ca ff fb 	sub	r10,r7,-5
8000ae1a:	a3 6a       	lsl	r10,0x2
8000ae1c:	e0 a0 02 82 	rcall	8000b320 <_calloc_r>
8000ae20:	c0 60       	breq	8000ae2c <_Balloc+0x6c>
8000ae22:	99 16       	st.w	r12[0x4],r6
8000ae24:	99 27       	st.w	r12[0x8],r7
8000ae26:	30 08       	mov	r8,0
8000ae28:	99 38       	st.w	r12[0xc],r8
8000ae2a:	99 48       	st.w	r12[0x10],r8
8000ae2c:	d8 22       	popm	r4-r7,pc
8000ae2e:	d7 03       	nop

8000ae30 <__d2b>:
8000ae30:	d4 31       	pushm	r0-r7,lr
8000ae32:	20 2d       	sub	sp,8
8000ae34:	16 93       	mov	r3,r11
8000ae36:	12 96       	mov	r6,r9
8000ae38:	10 95       	mov	r5,r8
8000ae3a:	14 92       	mov	r2,r10
8000ae3c:	30 1b       	mov	r11,1
8000ae3e:	cc 1f       	rcall	8000adc0 <_Balloc>
8000ae40:	f3 d3 c0 14 	bfextu	r9,r3,0x0,0x14
8000ae44:	50 09       	stdsp	sp[0x0],r9
8000ae46:	f1 d3 c0 1f 	bfextu	r8,r3,0x0,0x1f
8000ae4a:	b5 a9       	sbr	r9,0x14
8000ae4c:	f0 01 16 14 	lsr	r1,r8,0x14
8000ae50:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000ae54:	18 94       	mov	r4,r12
8000ae56:	58 02       	cp.w	r2,0
8000ae58:	c1 d0       	breq	8000ae92 <__d2b+0x62>
8000ae5a:	fa cc ff f8 	sub	r12,sp,-8
8000ae5e:	18 d2       	st.w	--r12,r2
8000ae60:	c3 6f       	rcall	8000accc <__lo0bits>
8000ae62:	40 18       	lddsp	r8,sp[0x4]
8000ae64:	c0 d0       	breq	8000ae7e <__d2b+0x4e>
8000ae66:	40 09       	lddsp	r9,sp[0x0]
8000ae68:	f8 0a 11 20 	rsub	r10,r12,32
8000ae6c:	f2 0a 09 4a 	lsl	r10,r9,r10
8000ae70:	f5 e8 10 08 	or	r8,r10,r8
8000ae74:	89 58       	st.w	r4[0x14],r8
8000ae76:	f2 0c 0a 49 	lsr	r9,r9,r12
8000ae7a:	50 09       	stdsp	sp[0x0],r9
8000ae7c:	c0 28       	rjmp	8000ae80 <__d2b+0x50>
8000ae7e:	89 58       	st.w	r4[0x14],r8
8000ae80:	40 08       	lddsp	r8,sp[0x0]
8000ae82:	58 08       	cp.w	r8,0
8000ae84:	f9 b3 01 02 	movne	r3,2
8000ae88:	f9 b3 00 01 	moveq	r3,1
8000ae8c:	89 68       	st.w	r4[0x18],r8
8000ae8e:	89 43       	st.w	r4[0x10],r3
8000ae90:	c0 88       	rjmp	8000aea0 <__d2b+0x70>
8000ae92:	1a 9c       	mov	r12,sp
8000ae94:	c1 cf       	rcall	8000accc <__lo0bits>
8000ae96:	30 13       	mov	r3,1
8000ae98:	40 08       	lddsp	r8,sp[0x0]
8000ae9a:	2e 0c       	sub	r12,-32
8000ae9c:	89 43       	st.w	r4[0x10],r3
8000ae9e:	89 58       	st.w	r4[0x14],r8
8000aea0:	58 01       	cp.w	r1,0
8000aea2:	c0 90       	breq	8000aeb4 <__d2b+0x84>
8000aea4:	e2 c1 04 33 	sub	r1,r1,1075
8000aea8:	18 01       	add	r1,r12
8000aeaa:	8d 01       	st.w	r6[0x0],r1
8000aeac:	f8 0c 11 35 	rsub	r12,r12,53
8000aeb0:	8b 0c       	st.w	r5[0x0],r12
8000aeb2:	c0 c8       	rjmp	8000aeca <__d2b+0x9a>
8000aeb4:	e6 c8 ff fc 	sub	r8,r3,-4
8000aeb8:	f8 cc 04 32 	sub	r12,r12,1074
8000aebc:	a5 73       	lsl	r3,0x5
8000aebe:	8d 0c       	st.w	r6[0x0],r12
8000aec0:	e8 08 03 2c 	ld.w	r12,r4[r8<<0x2]
8000aec4:	cd 4e       	rcall	8000ac6c <__hi0bits>
8000aec6:	18 13       	sub	r3,r12
8000aec8:	8b 03       	st.w	r5[0x0],r3
8000aeca:	08 9c       	mov	r12,r4
8000aecc:	2f ed       	sub	sp,-8
8000aece:	d8 32       	popm	r0-r7,pc

8000aed0 <__mdiff>:
8000aed0:	d4 31       	pushm	r0-r7,lr
8000aed2:	74 48       	ld.w	r8,r10[0x10]
8000aed4:	76 45       	ld.w	r5,r11[0x10]
8000aed6:	16 97       	mov	r7,r11
8000aed8:	14 96       	mov	r6,r10
8000aeda:	10 15       	sub	r5,r8
8000aedc:	c1 31       	brne	8000af02 <__mdiff+0x32>
8000aede:	2f b8       	sub	r8,-5
8000aee0:	ee ce ff ec 	sub	lr,r7,-20
8000aee4:	a3 68       	lsl	r8,0x2
8000aee6:	f4 08 00 0b 	add	r11,r10,r8
8000aeea:	ee 08 00 08 	add	r8,r7,r8
8000aeee:	11 4a       	ld.w	r10,--r8
8000aef0:	17 49       	ld.w	r9,--r11
8000aef2:	12 3a       	cp.w	r10,r9
8000aef4:	c0 30       	breq	8000aefa <__mdiff+0x2a>
8000aef6:	c0 e2       	brcc	8000af12 <__mdiff+0x42>
8000aef8:	c0 78       	rjmp	8000af06 <__mdiff+0x36>
8000aefa:	1c 38       	cp.w	r8,lr
8000aefc:	fe 9b ff f9 	brhi	8000aeee <__mdiff+0x1e>
8000af00:	c4 98       	rjmp	8000af92 <__mdiff+0xc2>
8000af02:	58 05       	cp.w	r5,0
8000af04:	c0 64       	brge	8000af10 <__mdiff+0x40>
8000af06:	0e 98       	mov	r8,r7
8000af08:	30 15       	mov	r5,1
8000af0a:	0c 97       	mov	r7,r6
8000af0c:	10 96       	mov	r6,r8
8000af0e:	c0 28       	rjmp	8000af12 <__mdiff+0x42>
8000af10:	30 05       	mov	r5,0
8000af12:	6e 1b       	ld.w	r11,r7[0x4]
8000af14:	c5 6f       	rcall	8000adc0 <_Balloc>
8000af16:	6e 49       	ld.w	r9,r7[0x10]
8000af18:	6c 44       	ld.w	r4,r6[0x10]
8000af1a:	99 35       	st.w	r12[0xc],r5
8000af1c:	2f b4       	sub	r4,-5
8000af1e:	f2 c5 ff fb 	sub	r5,r9,-5
8000af22:	ec 04 00 24 	add	r4,r6,r4<<0x2
8000af26:	ee 05 00 25 	add	r5,r7,r5<<0x2
8000af2a:	2e c6       	sub	r6,-20
8000af2c:	2e c7       	sub	r7,-20
8000af2e:	f8 c8 ff ec 	sub	r8,r12,-20
8000af32:	30 0a       	mov	r10,0
8000af34:	0f 0e       	ld.w	lr,r7++
8000af36:	0d 0b       	ld.w	r11,r6++
8000af38:	fc 02 16 10 	lsr	r2,lr,0x10
8000af3c:	f6 03 16 10 	lsr	r3,r11,0x10
8000af40:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000af44:	e4 03 01 03 	sub	r3,r2,r3
8000af48:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000af4c:	fc 0b 01 0b 	sub	r11,lr,r11
8000af50:	f6 0a 00 0a 	add	r10,r11,r10
8000af54:	b0 1a       	st.h	r8[0x2],r10
8000af56:	b1 4a       	asr	r10,0x10
8000af58:	e6 0a 00 0a 	add	r10,r3,r10
8000af5c:	b0 0a       	st.h	r8[0x0],r10
8000af5e:	2f c8       	sub	r8,-4
8000af60:	b1 4a       	asr	r10,0x10
8000af62:	08 36       	cp.w	r6,r4
8000af64:	ce 83       	brcs	8000af34 <__mdiff+0x64>
8000af66:	c0 d8       	rjmp	8000af80 <__mdiff+0xb0>
8000af68:	0f 0b       	ld.w	r11,r7++
8000af6a:	f6 0e 16 10 	lsr	lr,r11,0x10
8000af6e:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000af72:	16 0a       	add	r10,r11
8000af74:	b0 1a       	st.h	r8[0x2],r10
8000af76:	b1 4a       	asr	r10,0x10
8000af78:	1c 0a       	add	r10,lr
8000af7a:	b0 0a       	st.h	r8[0x0],r10
8000af7c:	2f c8       	sub	r8,-4
8000af7e:	b1 4a       	asr	r10,0x10
8000af80:	0a 37       	cp.w	r7,r5
8000af82:	cf 33       	brcs	8000af68 <__mdiff+0x98>
8000af84:	c0 28       	rjmp	8000af88 <__mdiff+0xb8>
8000af86:	20 19       	sub	r9,1
8000af88:	11 4a       	ld.w	r10,--r8
8000af8a:	58 0a       	cp.w	r10,0
8000af8c:	cf d0       	breq	8000af86 <__mdiff+0xb6>
8000af8e:	99 49       	st.w	r12[0x10],r9
8000af90:	d8 32       	popm	r0-r7,pc
8000af92:	30 0b       	mov	r11,0
8000af94:	c1 6f       	rcall	8000adc0 <_Balloc>
8000af96:	30 18       	mov	r8,1
8000af98:	99 48       	st.w	r12[0x10],r8
8000af9a:	30 08       	mov	r8,0
8000af9c:	99 58       	st.w	r12[0x14],r8
8000af9e:	d8 32       	popm	r0-r7,pc

8000afa0 <__lshift>:
8000afa0:	d4 31       	pushm	r0-r7,lr
8000afa2:	16 97       	mov	r7,r11
8000afa4:	76 46       	ld.w	r6,r11[0x10]
8000afa6:	f4 02 14 05 	asr	r2,r10,0x5
8000afaa:	2f f6       	sub	r6,-1
8000afac:	14 93       	mov	r3,r10
8000afae:	18 94       	mov	r4,r12
8000afb0:	04 06       	add	r6,r2
8000afb2:	76 1b       	ld.w	r11,r11[0x4]
8000afb4:	6e 28       	ld.w	r8,r7[0x8]
8000afb6:	c0 38       	rjmp	8000afbc <__lshift+0x1c>
8000afb8:	2f fb       	sub	r11,-1
8000afba:	a1 78       	lsl	r8,0x1
8000afbc:	10 36       	cp.w	r6,r8
8000afbe:	fe 99 ff fd 	brgt	8000afb8 <__lshift+0x18>
8000afc2:	08 9c       	mov	r12,r4
8000afc4:	cf ee       	rcall	8000adc0 <_Balloc>
8000afc6:	30 09       	mov	r9,0
8000afc8:	18 95       	mov	r5,r12
8000afca:	f8 c8 ff ec 	sub	r8,r12,-20
8000afce:	12 9a       	mov	r10,r9
8000afd0:	c0 38       	rjmp	8000afd6 <__lshift+0x36>
8000afd2:	10 aa       	st.w	r8++,r10
8000afd4:	2f f9       	sub	r9,-1
8000afd6:	04 39       	cp.w	r9,r2
8000afd8:	cf d5       	brlt	8000afd2 <__lshift+0x32>
8000afda:	6e 4b       	ld.w	r11,r7[0x10]
8000afdc:	e7 d3 c0 05 	bfextu	r3,r3,0x0,0x5
8000afe0:	2f bb       	sub	r11,-5
8000afe2:	ee c9 ff ec 	sub	r9,r7,-20
8000afe6:	ee 0b 00 2b 	add	r11,r7,r11<<0x2
8000afea:	58 03       	cp.w	r3,0
8000afec:	c1 30       	breq	8000b012 <__lshift+0x72>
8000afee:	e6 0c 11 20 	rsub	r12,r3,32
8000aff2:	30 0a       	mov	r10,0
8000aff4:	72 02       	ld.w	r2,r9[0x0]
8000aff6:	e4 03 09 42 	lsl	r2,r2,r3
8000affa:	04 4a       	or	r10,r2
8000affc:	10 aa       	st.w	r8++,r10
8000affe:	13 0a       	ld.w	r10,r9++
8000b000:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000b004:	16 39       	cp.w	r9,r11
8000b006:	cf 73       	brcs	8000aff4 <__lshift+0x54>
8000b008:	91 0a       	st.w	r8[0x0],r10
8000b00a:	58 0a       	cp.w	r10,0
8000b00c:	c0 70       	breq	8000b01a <__lshift+0x7a>
8000b00e:	2f f6       	sub	r6,-1
8000b010:	c0 58       	rjmp	8000b01a <__lshift+0x7a>
8000b012:	13 0a       	ld.w	r10,r9++
8000b014:	10 aa       	st.w	r8++,r10
8000b016:	16 39       	cp.w	r9,r11
8000b018:	cf d3       	brcs	8000b012 <__lshift+0x72>
8000b01a:	08 9c       	mov	r12,r4
8000b01c:	20 16       	sub	r6,1
8000b01e:	0e 9b       	mov	r11,r7
8000b020:	8b 46       	st.w	r5[0x10],r6
8000b022:	cb 5e       	rcall	8000ad8c <_Bfree>
8000b024:	0a 9c       	mov	r12,r5
8000b026:	d8 32       	popm	r0-r7,pc

8000b028 <__multiply>:
8000b028:	d4 31       	pushm	r0-r7,lr
8000b02a:	20 2d       	sub	sp,8
8000b02c:	76 49       	ld.w	r9,r11[0x10]
8000b02e:	74 48       	ld.w	r8,r10[0x10]
8000b030:	16 96       	mov	r6,r11
8000b032:	14 95       	mov	r5,r10
8000b034:	10 39       	cp.w	r9,r8
8000b036:	ec 08 17 50 	movlt	r8,r6
8000b03a:	ea 06 17 50 	movlt	r6,r5
8000b03e:	f0 05 17 50 	movlt	r5,r8
8000b042:	6c 28       	ld.w	r8,r6[0x8]
8000b044:	76 43       	ld.w	r3,r11[0x10]
8000b046:	74 42       	ld.w	r2,r10[0x10]
8000b048:	76 1b       	ld.w	r11,r11[0x4]
8000b04a:	e4 03 00 07 	add	r7,r2,r3
8000b04e:	10 37       	cp.w	r7,r8
8000b050:	f7 bb 09 ff 	subgt	r11,-1
8000b054:	cb 6e       	rcall	8000adc0 <_Balloc>
8000b056:	ee c4 ff fb 	sub	r4,r7,-5
8000b05a:	f8 c9 ff ec 	sub	r9,r12,-20
8000b05e:	f8 04 00 24 	add	r4,r12,r4<<0x2
8000b062:	30 0a       	mov	r10,0
8000b064:	12 98       	mov	r8,r9
8000b066:	c0 28       	rjmp	8000b06a <__multiply+0x42>
8000b068:	10 aa       	st.w	r8++,r10
8000b06a:	08 38       	cp.w	r8,r4
8000b06c:	cf e3       	brcs	8000b068 <__multiply+0x40>
8000b06e:	2f b3       	sub	r3,-5
8000b070:	2f b2       	sub	r2,-5
8000b072:	ec 03 00 23 	add	r3,r6,r3<<0x2
8000b076:	ea 02 00 22 	add	r2,r5,r2<<0x2
8000b07a:	ec cb ff ec 	sub	r11,r6,-20
8000b07e:	50 12       	stdsp	sp[0x4],r2
8000b080:	ea ca ff ec 	sub	r10,r5,-20
8000b084:	c4 48       	rjmp	8000b10c <__multiply+0xe4>
8000b086:	94 95       	ld.uh	r5,r10[0x2]
8000b088:	58 05       	cp.w	r5,0
8000b08a:	c2 00       	breq	8000b0ca <__multiply+0xa2>
8000b08c:	12 98       	mov	r8,r9
8000b08e:	16 96       	mov	r6,r11
8000b090:	30 0e       	mov	lr,0
8000b092:	50 09       	stdsp	sp[0x0],r9
8000b094:	0d 02       	ld.w	r2,r6++
8000b096:	e4 00 16 10 	lsr	r0,r2,0x10
8000b09a:	70 01       	ld.w	r1,r8[0x0]
8000b09c:	70 09       	ld.w	r9,r8[0x0]
8000b09e:	b1 81       	lsr	r1,0x10
8000b0a0:	e5 d2 c0 10 	bfextu	r2,r2,0x0,0x10
8000b0a4:	e0 05 03 41 	mac	r1,r0,r5
8000b0a8:	ab 32       	mul	r2,r5
8000b0aa:	e1 d9 c0 10 	bfextu	r0,r9,0x0,0x10
8000b0ae:	00 02       	add	r2,r0
8000b0b0:	e4 0e 00 0e 	add	lr,r2,lr
8000b0b4:	b0 1e       	st.h	r8[0x2],lr
8000b0b6:	b1 8e       	lsr	lr,0x10
8000b0b8:	1c 01       	add	r1,lr
8000b0ba:	b0 01       	st.h	r8[0x0],r1
8000b0bc:	e2 0e 16 10 	lsr	lr,r1,0x10
8000b0c0:	2f c8       	sub	r8,-4
8000b0c2:	06 36       	cp.w	r6,r3
8000b0c4:	ce 83       	brcs	8000b094 <__multiply+0x6c>
8000b0c6:	40 09       	lddsp	r9,sp[0x0]
8000b0c8:	91 0e       	st.w	r8[0x0],lr
8000b0ca:	94 86       	ld.uh	r6,r10[0x0]
8000b0cc:	58 06       	cp.w	r6,0
8000b0ce:	c1 d0       	breq	8000b108 <__multiply+0xe0>
8000b0d0:	72 02       	ld.w	r2,r9[0x0]
8000b0d2:	12 98       	mov	r8,r9
8000b0d4:	16 9e       	mov	lr,r11
8000b0d6:	30 05       	mov	r5,0
8000b0d8:	b0 12       	st.h	r8[0x2],r2
8000b0da:	1d 01       	ld.w	r1,lr++
8000b0dc:	90 82       	ld.uh	r2,r8[0x0]
8000b0de:	e1 d1 c0 10 	bfextu	r0,r1,0x0,0x10
8000b0e2:	ad 30       	mul	r0,r6
8000b0e4:	e0 02 00 02 	add	r2,r0,r2
8000b0e8:	e4 05 00 05 	add	r5,r2,r5
8000b0ec:	b0 05       	st.h	r8[0x0],r5
8000b0ee:	b1 85       	lsr	r5,0x10
8000b0f0:	b1 81       	lsr	r1,0x10
8000b0f2:	2f c8       	sub	r8,-4
8000b0f4:	ad 31       	mul	r1,r6
8000b0f6:	90 92       	ld.uh	r2,r8[0x2]
8000b0f8:	e2 02 00 02 	add	r2,r1,r2
8000b0fc:	0a 02       	add	r2,r5
8000b0fe:	e4 05 16 10 	lsr	r5,r2,0x10
8000b102:	06 3e       	cp.w	lr,r3
8000b104:	ce a3       	brcs	8000b0d8 <__multiply+0xb0>
8000b106:	91 02       	st.w	r8[0x0],r2
8000b108:	2f ca       	sub	r10,-4
8000b10a:	2f c9       	sub	r9,-4
8000b10c:	40 18       	lddsp	r8,sp[0x4]
8000b10e:	10 3a       	cp.w	r10,r8
8000b110:	cb b3       	brcs	8000b086 <__multiply+0x5e>
8000b112:	c0 28       	rjmp	8000b116 <__multiply+0xee>
8000b114:	20 17       	sub	r7,1
8000b116:	58 07       	cp.w	r7,0
8000b118:	e0 8a 00 05 	brle	8000b122 <__multiply+0xfa>
8000b11c:	09 48       	ld.w	r8,--r4
8000b11e:	58 08       	cp.w	r8,0
8000b120:	cf a0       	breq	8000b114 <__multiply+0xec>
8000b122:	99 47       	st.w	r12[0x10],r7
8000b124:	2f ed       	sub	sp,-8
8000b126:	d8 32       	popm	r0-r7,pc

8000b128 <__i2b>:
8000b128:	d4 21       	pushm	r4-r7,lr
8000b12a:	16 97       	mov	r7,r11
8000b12c:	30 1b       	mov	r11,1
8000b12e:	c4 9e       	rcall	8000adc0 <_Balloc>
8000b130:	30 19       	mov	r9,1
8000b132:	99 57       	st.w	r12[0x14],r7
8000b134:	99 49       	st.w	r12[0x10],r9
8000b136:	d8 22       	popm	r4-r7,pc

8000b138 <__multadd>:
8000b138:	d4 31       	pushm	r0-r7,lr
8000b13a:	30 08       	mov	r8,0
8000b13c:	12 95       	mov	r5,r9
8000b13e:	16 97       	mov	r7,r11
8000b140:	18 96       	mov	r6,r12
8000b142:	76 44       	ld.w	r4,r11[0x10]
8000b144:	f6 c9 ff ec 	sub	r9,r11,-20
8000b148:	72 0b       	ld.w	r11,r9[0x0]
8000b14a:	f6 0c 16 10 	lsr	r12,r11,0x10
8000b14e:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b152:	f4 0c 02 4c 	mul	r12,r10,r12
8000b156:	f4 0b 03 45 	mac	r5,r10,r11
8000b15a:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
8000b15e:	b1 85       	lsr	r5,0x10
8000b160:	18 05       	add	r5,r12
8000b162:	ea 0c 15 10 	lsl	r12,r5,0x10
8000b166:	f8 0b 00 0b 	add	r11,r12,r11
8000b16a:	12 ab       	st.w	r9++,r11
8000b16c:	2f f8       	sub	r8,-1
8000b16e:	b1 85       	lsr	r5,0x10
8000b170:	08 38       	cp.w	r8,r4
8000b172:	ce b5       	brlt	8000b148 <__multadd+0x10>
8000b174:	58 05       	cp.w	r5,0
8000b176:	c1 c0       	breq	8000b1ae <__multadd+0x76>
8000b178:	6e 28       	ld.w	r8,r7[0x8]
8000b17a:	10 34       	cp.w	r4,r8
8000b17c:	c1 35       	brlt	8000b1a2 <__multadd+0x6a>
8000b17e:	6e 1b       	ld.w	r11,r7[0x4]
8000b180:	0c 9c       	mov	r12,r6
8000b182:	2f fb       	sub	r11,-1
8000b184:	c1 ee       	rcall	8000adc0 <_Balloc>
8000b186:	6e 4a       	ld.w	r10,r7[0x10]
8000b188:	ee cb ff f4 	sub	r11,r7,-12
8000b18c:	18 93       	mov	r3,r12
8000b18e:	2f ea       	sub	r10,-2
8000b190:	2f 4c       	sub	r12,-12
8000b192:	a3 6a       	lsl	r10,0x2
8000b194:	fe b0 de 64 	rcall	80006e5c <memcpy>
8000b198:	0e 9b       	mov	r11,r7
8000b19a:	0c 9c       	mov	r12,r6
8000b19c:	fe b0 fd f8 	rcall	8000ad8c <_Bfree>
8000b1a0:	06 97       	mov	r7,r3
8000b1a2:	e8 c8 ff ff 	sub	r8,r4,-1
8000b1a6:	2f b4       	sub	r4,-5
8000b1a8:	8f 48       	st.w	r7[0x10],r8
8000b1aa:	ee 04 09 25 	st.w	r7[r4<<0x2],r5
8000b1ae:	0e 9c       	mov	r12,r7
8000b1b0:	d8 32       	popm	r0-r7,pc
8000b1b2:	d7 03       	nop

8000b1b4 <__pow5mult>:
8000b1b4:	d4 31       	pushm	r0-r7,lr
8000b1b6:	14 96       	mov	r6,r10
8000b1b8:	18 97       	mov	r7,r12
8000b1ba:	16 94       	mov	r4,r11
8000b1bc:	f1 da c0 02 	bfextu	r8,r10,0x0,0x2
8000b1c0:	c0 90       	breq	8000b1d2 <__pow5mult+0x1e>
8000b1c2:	20 18       	sub	r8,1
8000b1c4:	fe c9 d5 60 	sub	r9,pc,-10912
8000b1c8:	f2 08 03 2a 	ld.w	r10,r9[r8<<0x2]
8000b1cc:	30 09       	mov	r9,0
8000b1ce:	cb 5f       	rcall	8000b138 <__multadd>
8000b1d0:	18 94       	mov	r4,r12
8000b1d2:	a3 46       	asr	r6,0x2
8000b1d4:	c3 40       	breq	8000b23c <__pow5mult+0x88>
8000b1d6:	6e 95       	ld.w	r5,r7[0x24]
8000b1d8:	58 05       	cp.w	r5,0
8000b1da:	c0 91       	brne	8000b1ec <__pow5mult+0x38>
8000b1dc:	31 0c       	mov	r12,16
8000b1de:	fe b0 dc 1b 	rcall	80006a14 <malloc>
8000b1e2:	99 35       	st.w	r12[0xc],r5
8000b1e4:	8f 9c       	st.w	r7[0x24],r12
8000b1e6:	99 15       	st.w	r12[0x4],r5
8000b1e8:	99 25       	st.w	r12[0x8],r5
8000b1ea:	99 05       	st.w	r12[0x0],r5
8000b1ec:	6e 93       	ld.w	r3,r7[0x24]
8000b1ee:	66 25       	ld.w	r5,r3[0x8]
8000b1f0:	58 05       	cp.w	r5,0
8000b1f2:	c0 c1       	brne	8000b20a <__pow5mult+0x56>
8000b1f4:	e0 6b 02 71 	mov	r11,625
8000b1f8:	0e 9c       	mov	r12,r7
8000b1fa:	c9 7f       	rcall	8000b128 <__i2b>
8000b1fc:	87 2c       	st.w	r3[0x8],r12
8000b1fe:	30 08       	mov	r8,0
8000b200:	18 95       	mov	r5,r12
8000b202:	99 08       	st.w	r12[0x0],r8
8000b204:	c0 38       	rjmp	8000b20a <__pow5mult+0x56>
8000b206:	06 9c       	mov	r12,r3
8000b208:	18 95       	mov	r5,r12
8000b20a:	ed b6 00 00 	bld	r6,0x0
8000b20e:	c0 b1       	brne	8000b224 <__pow5mult+0x70>
8000b210:	08 9b       	mov	r11,r4
8000b212:	0a 9a       	mov	r10,r5
8000b214:	0e 9c       	mov	r12,r7
8000b216:	c0 9f       	rcall	8000b028 <__multiply>
8000b218:	08 9b       	mov	r11,r4
8000b21a:	18 93       	mov	r3,r12
8000b21c:	0e 9c       	mov	r12,r7
8000b21e:	06 94       	mov	r4,r3
8000b220:	fe b0 fd b6 	rcall	8000ad8c <_Bfree>
8000b224:	a1 56       	asr	r6,0x1
8000b226:	c0 b0       	breq	8000b23c <__pow5mult+0x88>
8000b228:	6a 03       	ld.w	r3,r5[0x0]
8000b22a:	58 03       	cp.w	r3,0
8000b22c:	ce d1       	brne	8000b206 <__pow5mult+0x52>
8000b22e:	0a 9a       	mov	r10,r5
8000b230:	0a 9b       	mov	r11,r5
8000b232:	0e 9c       	mov	r12,r7
8000b234:	cf ae       	rcall	8000b028 <__multiply>
8000b236:	8b 0c       	st.w	r5[0x0],r12
8000b238:	99 03       	st.w	r12[0x0],r3
8000b23a:	ce 7b       	rjmp	8000b208 <__pow5mult+0x54>
8000b23c:	08 9c       	mov	r12,r4
8000b23e:	d8 32       	popm	r0-r7,pc

8000b240 <__isinfd>:
8000b240:	14 98       	mov	r8,r10
8000b242:	fc 19 7f f0 	movh	r9,0x7ff0
8000b246:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000b24a:	f0 0b 11 00 	rsub	r11,r8,0
8000b24e:	f7 e8 10 08 	or	r8,r11,r8
8000b252:	f5 e8 13 f8 	or	r8,r10,r8>>0x1f
8000b256:	f2 08 01 08 	sub	r8,r9,r8
8000b25a:	f0 0c 11 00 	rsub	r12,r8,0
8000b25e:	f9 e8 10 08 	or	r8,r12,r8
8000b262:	f0 0c 14 1f 	asr	r12,r8,0x1f
8000b266:	2f fc       	sub	r12,-1
8000b268:	5e fc       	retal	r12

8000b26a <__isnand>:
8000b26a:	14 98       	mov	r8,r10
8000b26c:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000b270:	f0 0c 11 00 	rsub	r12,r8,0
8000b274:	10 4c       	or	r12,r8
8000b276:	fc 18 7f f0 	movh	r8,0x7ff0
8000b27a:	f5 ec 13 fc 	or	r12,r10,r12>>0x1f
8000b27e:	f0 0c 01 0c 	sub	r12,r8,r12
8000b282:	bf 9c       	lsr	r12,0x1f
8000b284:	5e fc       	retal	r12
8000b286:	d7 03       	nop

8000b288 <__sclose>:
8000b288:	d4 01       	pushm	lr
8000b28a:	96 7b       	ld.sh	r11,r11[0xe]
8000b28c:	c7 6c       	rcall	8000b378 <_close_r>
8000b28e:	d8 02       	popm	pc

8000b290 <__sseek>:
8000b290:	d4 21       	pushm	r4-r7,lr
8000b292:	16 97       	mov	r7,r11
8000b294:	96 7b       	ld.sh	r11,r11[0xe]
8000b296:	cf 7c       	rcall	8000b484 <_lseek_r>
8000b298:	8e 68       	ld.sh	r8,r7[0xc]
8000b29a:	10 99       	mov	r9,r8
8000b29c:	ad c8       	cbr	r8,0xc
8000b29e:	ad a9       	sbr	r9,0xc
8000b2a0:	5b fc       	cp.w	r12,-1
8000b2a2:	ef f8 0c 06 	st.heq	r7[0xc],r8
8000b2a6:	ef f9 1c 06 	st.hne	r7[0xc],r9
8000b2aa:	ef fc 1a 15 	st.wne	r7[0x54],r12
8000b2ae:	d8 22       	popm	r4-r7,pc

8000b2b0 <__swrite>:
8000b2b0:	d4 21       	pushm	r4-r7,lr
8000b2b2:	96 68       	ld.sh	r8,r11[0xc]
8000b2b4:	16 97       	mov	r7,r11
8000b2b6:	14 95       	mov	r5,r10
8000b2b8:	12 94       	mov	r4,r9
8000b2ba:	e2 18 01 00 	andl	r8,0x100,COH
8000b2be:	18 96       	mov	r6,r12
8000b2c0:	c0 50       	breq	8000b2ca <__swrite+0x1a>
8000b2c2:	30 29       	mov	r9,2
8000b2c4:	30 0a       	mov	r10,0
8000b2c6:	96 7b       	ld.sh	r11,r11[0xe]
8000b2c8:	cd ec       	rcall	8000b484 <_lseek_r>
8000b2ca:	8e 68       	ld.sh	r8,r7[0xc]
8000b2cc:	ad c8       	cbr	r8,0xc
8000b2ce:	08 99       	mov	r9,r4
8000b2d0:	0a 9a       	mov	r10,r5
8000b2d2:	8e 7b       	ld.sh	r11,r7[0xe]
8000b2d4:	0c 9c       	mov	r12,r6
8000b2d6:	ae 68       	st.h	r7[0xc],r8
8000b2d8:	c1 0c       	rcall	8000b2f8 <_write_r>
8000b2da:	d8 22       	popm	r4-r7,pc

8000b2dc <__sread>:
8000b2dc:	d4 21       	pushm	r4-r7,lr
8000b2de:	16 97       	mov	r7,r11
8000b2e0:	96 7b       	ld.sh	r11,r11[0xe]
8000b2e2:	ce 5c       	rcall	8000b4ac <_read_r>
8000b2e4:	c0 65       	brlt	8000b2f0 <__sread+0x14>
8000b2e6:	6f 58       	ld.w	r8,r7[0x54]
8000b2e8:	18 08       	add	r8,r12
8000b2ea:	ef 48 00 54 	st.w	r7[84],r8
8000b2ee:	d8 22       	popm	r4-r7,pc
8000b2f0:	8e 68       	ld.sh	r8,r7[0xc]
8000b2f2:	ad c8       	cbr	r8,0xc
8000b2f4:	ae 68       	st.h	r7[0xc],r8
8000b2f6:	d8 22       	popm	r4-r7,pc

8000b2f8 <_write_r>:
8000b2f8:	d4 21       	pushm	r4-r7,lr
8000b2fa:	16 98       	mov	r8,r11
8000b2fc:	18 97       	mov	r7,r12
8000b2fe:	10 9c       	mov	r12,r8
8000b300:	30 08       	mov	r8,0
8000b302:	14 9b       	mov	r11,r10
8000b304:	e0 66 41 1c 	mov	r6,16668
8000b308:	12 9a       	mov	r10,r9
8000b30a:	8d 08       	st.w	r6[0x0],r8
8000b30c:	fe b0 d1 24 	rcall	80005554 <_write>
8000b310:	5b fc       	cp.w	r12,-1
8000b312:	c0 51       	brne	8000b31c <_write_r+0x24>
8000b314:	6c 08       	ld.w	r8,r6[0x0]
8000b316:	58 08       	cp.w	r8,0
8000b318:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b31c:	d8 22       	popm	r4-r7,pc
8000b31e:	d7 03       	nop

8000b320 <_calloc_r>:
8000b320:	d4 21       	pushm	r4-r7,lr
8000b322:	f4 0b 02 4b 	mul	r11,r10,r11
8000b326:	fe b0 db 7f 	rcall	80006a24 <_malloc_r>
8000b32a:	18 97       	mov	r7,r12
8000b32c:	c2 30       	breq	8000b372 <_calloc_r+0x52>
8000b32e:	f8 fa ff fc 	ld.w	r10,r12[-4]
8000b332:	e0 1a ff fc 	andl	r10,0xfffc
8000b336:	20 4a       	sub	r10,4
8000b338:	e0 4a 00 24 	cp.w	r10,36
8000b33c:	e0 8b 00 18 	brhi	8000b36c <_calloc_r+0x4c>
8000b340:	18 98       	mov	r8,r12
8000b342:	59 3a       	cp.w	r10,19
8000b344:	e0 88 00 0f 	brls	8000b362 <_calloc_r+0x42>
8000b348:	30 09       	mov	r9,0
8000b34a:	10 a9       	st.w	r8++,r9
8000b34c:	10 a9       	st.w	r8++,r9
8000b34e:	59 ba       	cp.w	r10,27
8000b350:	e0 88 00 09 	brls	8000b362 <_calloc_r+0x42>
8000b354:	10 a9       	st.w	r8++,r9
8000b356:	10 a9       	st.w	r8++,r9
8000b358:	e0 4a 00 24 	cp.w	r10,36
8000b35c:	c0 31       	brne	8000b362 <_calloc_r+0x42>
8000b35e:	10 a9       	st.w	r8++,r9
8000b360:	10 a9       	st.w	r8++,r9
8000b362:	30 09       	mov	r9,0
8000b364:	10 a9       	st.w	r8++,r9
8000b366:	91 19       	st.w	r8[0x4],r9
8000b368:	91 09       	st.w	r8[0x0],r9
8000b36a:	c0 48       	rjmp	8000b372 <_calloc_r+0x52>
8000b36c:	30 0b       	mov	r11,0
8000b36e:	fe b0 de 1b 	rcall	80006fa4 <memset>
8000b372:	0e 9c       	mov	r12,r7
8000b374:	d8 22       	popm	r4-r7,pc
8000b376:	d7 03       	nop

8000b378 <_close_r>:
8000b378:	d4 21       	pushm	r4-r7,lr
8000b37a:	30 08       	mov	r8,0
8000b37c:	18 97       	mov	r7,r12
8000b37e:	e0 66 41 1c 	mov	r6,16668
8000b382:	16 9c       	mov	r12,r11
8000b384:	8d 08       	st.w	r6[0x0],r8
8000b386:	fe b0 df c1 	rcall	80007308 <_close>
8000b38a:	5b fc       	cp.w	r12,-1
8000b38c:	c0 51       	brne	8000b396 <_close_r+0x1e>
8000b38e:	6c 08       	ld.w	r8,r6[0x0]
8000b390:	58 08       	cp.w	r8,0
8000b392:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b396:	d8 22       	popm	r4-r7,pc

8000b398 <_fclose_r>:
8000b398:	d4 21       	pushm	r4-r7,lr
8000b39a:	18 96       	mov	r6,r12
8000b39c:	16 97       	mov	r7,r11
8000b39e:	58 0b       	cp.w	r11,0
8000b3a0:	c0 31       	brne	8000b3a6 <_fclose_r+0xe>
8000b3a2:	16 95       	mov	r5,r11
8000b3a4:	c5 38       	rjmp	8000b44a <_fclose_r+0xb2>
8000b3a6:	fe b0 f8 b5 	rcall	8000a510 <__sfp_lock_acquire>
8000b3aa:	58 06       	cp.w	r6,0
8000b3ac:	c0 70       	breq	8000b3ba <_fclose_r+0x22>
8000b3ae:	6c 68       	ld.w	r8,r6[0x18]
8000b3b0:	58 08       	cp.w	r8,0
8000b3b2:	c0 41       	brne	8000b3ba <_fclose_r+0x22>
8000b3b4:	0c 9c       	mov	r12,r6
8000b3b6:	fe b0 f8 ff 	rcall	8000a5b4 <__sinit>
8000b3ba:	fe c8 d7 fa 	sub	r8,pc,-10246
8000b3be:	10 37       	cp.w	r7,r8
8000b3c0:	c0 31       	brne	8000b3c6 <_fclose_r+0x2e>
8000b3c2:	6c 07       	ld.w	r7,r6[0x0]
8000b3c4:	c0 c8       	rjmp	8000b3dc <_fclose_r+0x44>
8000b3c6:	fe c8 d7 e6 	sub	r8,pc,-10266
8000b3ca:	10 37       	cp.w	r7,r8
8000b3cc:	c0 31       	brne	8000b3d2 <_fclose_r+0x3a>
8000b3ce:	6c 17       	ld.w	r7,r6[0x4]
8000b3d0:	c0 68       	rjmp	8000b3dc <_fclose_r+0x44>
8000b3d2:	fe c8 d7 d2 	sub	r8,pc,-10286
8000b3d6:	10 37       	cp.w	r7,r8
8000b3d8:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000b3dc:	8e 69       	ld.sh	r9,r7[0xc]
8000b3de:	30 08       	mov	r8,0
8000b3e0:	f0 09 19 00 	cp.h	r9,r8
8000b3e4:	c0 51       	brne	8000b3ee <_fclose_r+0x56>
8000b3e6:	fe b0 f8 96 	rcall	8000a512 <__sfp_lock_release>
8000b3ea:	30 05       	mov	r5,0
8000b3ec:	c2 f8       	rjmp	8000b44a <_fclose_r+0xb2>
8000b3ee:	0e 9b       	mov	r11,r7
8000b3f0:	0c 9c       	mov	r12,r6
8000b3f2:	fe b0 f8 09 	rcall	8000a404 <_fflush_r>
8000b3f6:	6e c8       	ld.w	r8,r7[0x30]
8000b3f8:	18 95       	mov	r5,r12
8000b3fa:	58 08       	cp.w	r8,0
8000b3fc:	c0 60       	breq	8000b408 <_fclose_r+0x70>
8000b3fe:	6e 8b       	ld.w	r11,r7[0x20]
8000b400:	0c 9c       	mov	r12,r6
8000b402:	5d 18       	icall	r8
8000b404:	f9 b5 05 ff 	movlt	r5,-1
8000b408:	8e 68       	ld.sh	r8,r7[0xc]
8000b40a:	ed b8 00 07 	bld	r8,0x7
8000b40e:	c0 51       	brne	8000b418 <_fclose_r+0x80>
8000b410:	6e 4b       	ld.w	r11,r7[0x10]
8000b412:	0c 9c       	mov	r12,r6
8000b414:	fe b0 f9 6a 	rcall	8000a6e8 <_free_r>
8000b418:	6e db       	ld.w	r11,r7[0x34]
8000b41a:	58 0b       	cp.w	r11,0
8000b41c:	c0 a0       	breq	8000b430 <_fclose_r+0x98>
8000b41e:	ee c8 ff bc 	sub	r8,r7,-68
8000b422:	10 3b       	cp.w	r11,r8
8000b424:	c0 40       	breq	8000b42c <_fclose_r+0x94>
8000b426:	0c 9c       	mov	r12,r6
8000b428:	fe b0 f9 60 	rcall	8000a6e8 <_free_r>
8000b42c:	30 08       	mov	r8,0
8000b42e:	8f d8       	st.w	r7[0x34],r8
8000b430:	6f 2b       	ld.w	r11,r7[0x48]
8000b432:	58 0b       	cp.w	r11,0
8000b434:	c0 70       	breq	8000b442 <_fclose_r+0xaa>
8000b436:	0c 9c       	mov	r12,r6
8000b438:	fe b0 f9 58 	rcall	8000a6e8 <_free_r>
8000b43c:	30 08       	mov	r8,0
8000b43e:	ef 48 00 48 	st.w	r7[72],r8
8000b442:	30 08       	mov	r8,0
8000b444:	ae 68       	st.h	r7[0xc],r8
8000b446:	fe b0 f8 66 	rcall	8000a512 <__sfp_lock_release>
8000b44a:	0a 9c       	mov	r12,r5
8000b44c:	d8 22       	popm	r4-r7,pc
8000b44e:	d7 03       	nop

8000b450 <fclose>:
8000b450:	d4 01       	pushm	lr
8000b452:	e0 68 0a 38 	mov	r8,2616
8000b456:	18 9b       	mov	r11,r12
8000b458:	70 0c       	ld.w	r12,r8[0x0]
8000b45a:	c9 ff       	rcall	8000b398 <_fclose_r>
8000b45c:	d8 02       	popm	pc
8000b45e:	d7 03       	nop

8000b460 <_fstat_r>:
8000b460:	d4 21       	pushm	r4-r7,lr
8000b462:	16 98       	mov	r8,r11
8000b464:	18 97       	mov	r7,r12
8000b466:	10 9c       	mov	r12,r8
8000b468:	30 08       	mov	r8,0
8000b46a:	e0 66 41 1c 	mov	r6,16668
8000b46e:	14 9b       	mov	r11,r10
8000b470:	8d 08       	st.w	r6[0x0],r8
8000b472:	fe b0 df 73 	rcall	80007358 <_fstat>
8000b476:	5b fc       	cp.w	r12,-1
8000b478:	c0 51       	brne	8000b482 <_fstat_r+0x22>
8000b47a:	6c 08       	ld.w	r8,r6[0x0]
8000b47c:	58 08       	cp.w	r8,0
8000b47e:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b482:	d8 22       	popm	r4-r7,pc

8000b484 <_lseek_r>:
8000b484:	d4 21       	pushm	r4-r7,lr
8000b486:	16 98       	mov	r8,r11
8000b488:	18 97       	mov	r7,r12
8000b48a:	10 9c       	mov	r12,r8
8000b48c:	30 08       	mov	r8,0
8000b48e:	14 9b       	mov	r11,r10
8000b490:	e0 66 41 1c 	mov	r6,16668
8000b494:	12 9a       	mov	r10,r9
8000b496:	8d 08       	st.w	r6[0x0],r8
8000b498:	fe b0 df 42 	rcall	8000731c <_lseek>
8000b49c:	5b fc       	cp.w	r12,-1
8000b49e:	c0 51       	brne	8000b4a8 <_lseek_r+0x24>
8000b4a0:	6c 08       	ld.w	r8,r6[0x0]
8000b4a2:	58 08       	cp.w	r8,0
8000b4a4:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b4a8:	d8 22       	popm	r4-r7,pc
8000b4aa:	d7 03       	nop

8000b4ac <_read_r>:
8000b4ac:	d4 21       	pushm	r4-r7,lr
8000b4ae:	16 98       	mov	r8,r11
8000b4b0:	18 97       	mov	r7,r12
8000b4b2:	10 9c       	mov	r12,r8
8000b4b4:	30 08       	mov	r8,0
8000b4b6:	14 9b       	mov	r11,r10
8000b4b8:	e0 66 41 1c 	mov	r6,16668
8000b4bc:	12 9a       	mov	r10,r9
8000b4be:	8d 08       	st.w	r6[0x0],r8
8000b4c0:	fe b0 d0 2a 	rcall	80005514 <_read>
8000b4c4:	5b fc       	cp.w	r12,-1
8000b4c6:	c0 51       	brne	8000b4d0 <_read_r+0x24>
8000b4c8:	6c 08       	ld.w	r8,r6[0x0]
8000b4ca:	58 08       	cp.w	r8,0
8000b4cc:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b4d0:	d8 22       	popm	r4-r7,pc
8000b4d2:	d7 03       	nop

8000b4d4 <__avr32_f64_mul>:
8000b4d4:	f5 eb 10 1c 	or	r12,r10,r11<<0x1
8000b4d8:	e0 80 00 dc 	breq	8000b690 <__avr32_f64_mul_op1_zero>
8000b4dc:	d4 21       	pushm	r4-r7,lr
8000b4de:	f7 e9 20 0e 	eor	lr,r11,r9
8000b4e2:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000b4e6:	30 15       	mov	r5,1
8000b4e8:	c4 30       	breq	8000b56e <__avr32_f64_mul_op1_subnormal>
8000b4ea:	ab 6b       	lsl	r11,0xa
8000b4ec:	f7 ea 13 6b 	or	r11,r11,r10>>0x16
8000b4f0:	ab 6a       	lsl	r10,0xa
8000b4f2:	f7 d5 d3 c2 	bfins	r11,r5,0x1e,0x2
8000b4f6:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000b4fa:	c5 c0       	breq	8000b5b2 <__avr32_f64_mul_op2_subnormal>
8000b4fc:	a1 78       	lsl	r8,0x1
8000b4fe:	5c f9       	rol	r9
8000b500:	f3 d5 d2 ab 	bfins	r9,r5,0x15,0xb
8000b504:	e0 47 07 ff 	cp.w	r7,2047
8000b508:	c7 70       	breq	8000b5f6 <__avr32_f64_mul_op_nan_or_inf>
8000b50a:	e0 46 07 ff 	cp.w	r6,2047
8000b50e:	c7 40       	breq	8000b5f6 <__avr32_f64_mul_op_nan_or_inf>
8000b510:	ee 06 00 0c 	add	r12,r7,r6
8000b514:	e0 2c 03 fe 	sub	r12,1022
8000b518:	f6 08 06 44 	mulu.d	r4,r11,r8
8000b51c:	f4 09 07 44 	macu.d	r4,r10,r9
8000b520:	f4 08 06 46 	mulu.d	r6,r10,r8
8000b524:	f6 09 06 4a 	mulu.d	r10,r11,r9
8000b528:	08 07       	add	r7,r4
8000b52a:	f4 05 00 4a 	adc	r10,r10,r5
8000b52e:	5c 0b       	acr	r11
8000b530:	ed bb 00 14 	bld	r11,0x14
8000b534:	c0 50       	breq	8000b53e <__avr32_f64_mul+0x6a>
8000b536:	a1 77       	lsl	r7,0x1
8000b538:	5c fa       	rol	r10
8000b53a:	5c fb       	rol	r11
8000b53c:	20 1c       	sub	r12,1
8000b53e:	58 0c       	cp.w	r12,0
8000b540:	e0 8a 00 6f 	brle	8000b61e <__avr32_f64_mul_res_subnormal>
8000b544:	e0 4c 07 ff 	cp.w	r12,2047
8000b548:	e0 84 00 9c 	brge	8000b680 <__avr32_f64_mul_res_inf>
8000b54c:	f7 dc d2 8b 	bfins	r11,r12,0x14,0xb
8000b550:	ed ea 11 f6 	or	r6,r6,r10<<0x1f
8000b554:	ef e6 12 17 	or	r7,r7,r6>>0x1
8000b558:	ee 17 80 00 	eorh	r7,0x8000
8000b55c:	f1 b7 04 20 	satu	r7,0x1
8000b560:	0e 0a       	add	r10,r7
8000b562:	5c 0b       	acr	r11
8000b564:	ed be 00 1f 	bld	lr,0x1f
8000b568:	ef bb 00 1f 	bst	r11,0x1f
8000b56c:	d8 22       	popm	r4-r7,pc

8000b56e <__avr32_f64_mul_op1_subnormal>:
8000b56e:	e4 1b 00 0f 	andh	r11,0xf
8000b572:	f4 0c 12 00 	clz	r12,r10
8000b576:	f6 06 12 00 	clz	r6,r11
8000b57a:	f7 bc 03 e1 	sublo	r12,-31
8000b57e:	f8 06 17 30 	movlo	r6,r12
8000b582:	f7 b6 02 01 	subhs	r6,1
8000b586:	e0 46 00 20 	cp.w	r6,32
8000b58a:	c0 d4       	brge	8000b5a4 <__avr32_f64_mul_op1_subnormal+0x36>
8000b58c:	ec 0c 11 20 	rsub	r12,r6,32
8000b590:	f6 06 09 4b 	lsl	r11,r11,r6
8000b594:	f4 0c 0a 4c 	lsr	r12,r10,r12
8000b598:	18 4b       	or	r11,r12
8000b59a:	f4 06 09 4a 	lsl	r10,r10,r6
8000b59e:	20 b6       	sub	r6,11
8000b5a0:	0c 17       	sub	r7,r6
8000b5a2:	ca ab       	rjmp	8000b4f6 <__avr32_f64_mul+0x22>
8000b5a4:	f4 06 09 4b 	lsl	r11,r10,r6
8000b5a8:	c6 40       	breq	8000b670 <__avr32_f64_mul_res_zero>
8000b5aa:	30 0a       	mov	r10,0
8000b5ac:	20 b6       	sub	r6,11
8000b5ae:	0c 17       	sub	r7,r6
8000b5b0:	ca 3b       	rjmp	8000b4f6 <__avr32_f64_mul+0x22>

8000b5b2 <__avr32_f64_mul_op2_subnormal>:
8000b5b2:	e4 19 00 0f 	andh	r9,0xf
8000b5b6:	f0 0c 12 00 	clz	r12,r8
8000b5ba:	f2 05 12 00 	clz	r5,r9
8000b5be:	f7 bc 03 ea 	sublo	r12,-22
8000b5c2:	f8 05 17 30 	movlo	r5,r12
8000b5c6:	f7 b5 02 0a 	subhs	r5,10
8000b5ca:	e0 45 00 20 	cp.w	r5,32
8000b5ce:	c0 d4       	brge	8000b5e8 <__avr32_f64_mul_op2_subnormal+0x36>
8000b5d0:	ea 0c 11 20 	rsub	r12,r5,32
8000b5d4:	f2 05 09 49 	lsl	r9,r9,r5
8000b5d8:	f0 0c 0a 4c 	lsr	r12,r8,r12
8000b5dc:	18 49       	or	r9,r12
8000b5de:	f0 05 09 48 	lsl	r8,r8,r5
8000b5e2:	20 25       	sub	r5,2
8000b5e4:	0a 16       	sub	r6,r5
8000b5e6:	c8 fb       	rjmp	8000b504 <__avr32_f64_mul+0x30>
8000b5e8:	f0 05 09 49 	lsl	r9,r8,r5
8000b5ec:	c4 20       	breq	8000b670 <__avr32_f64_mul_res_zero>
8000b5ee:	30 08       	mov	r8,0
8000b5f0:	20 25       	sub	r5,2
8000b5f2:	0a 16       	sub	r6,r5
8000b5f4:	c8 8b       	rjmp	8000b504 <__avr32_f64_mul+0x30>

8000b5f6 <__avr32_f64_mul_op_nan_or_inf>:
8000b5f6:	e4 19 00 0f 	andh	r9,0xf
8000b5fa:	e4 1b 00 0f 	andh	r11,0xf
8000b5fe:	14 4b       	or	r11,r10
8000b600:	10 49       	or	r9,r8
8000b602:	e0 47 07 ff 	cp.w	r7,2047
8000b606:	c0 91       	brne	8000b618 <__avr32_f64_mul_op1_not_naninf>
8000b608:	58 0b       	cp.w	r11,0
8000b60a:	c3 81       	brne	8000b67a <__avr32_f64_mul_res_nan>
8000b60c:	e0 46 07 ff 	cp.w	r6,2047
8000b610:	c3 81       	brne	8000b680 <__avr32_f64_mul_res_inf>
8000b612:	58 09       	cp.w	r9,0
8000b614:	c3 60       	breq	8000b680 <__avr32_f64_mul_res_inf>
8000b616:	c3 28       	rjmp	8000b67a <__avr32_f64_mul_res_nan>

8000b618 <__avr32_f64_mul_op1_not_naninf>:
8000b618:	58 09       	cp.w	r9,0
8000b61a:	c3 30       	breq	8000b680 <__avr32_f64_mul_res_inf>
8000b61c:	c2 f8       	rjmp	8000b67a <__avr32_f64_mul_res_nan>

8000b61e <__avr32_f64_mul_res_subnormal>:
8000b61e:	5c 3c       	neg	r12
8000b620:	2f fc       	sub	r12,-1
8000b622:	f1 bc 04 c0 	satu	r12,0x6
8000b626:	e0 4c 00 20 	cp.w	r12,32
8000b62a:	c1 14       	brge	8000b64c <__avr32_f64_mul_res_subnormal+0x2e>
8000b62c:	f8 08 11 20 	rsub	r8,r12,32
8000b630:	0e 46       	or	r6,r7
8000b632:	ee 0c 0a 47 	lsr	r7,r7,r12
8000b636:	f4 08 09 49 	lsl	r9,r10,r8
8000b63a:	12 47       	or	r7,r9
8000b63c:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000b640:	f6 08 09 49 	lsl	r9,r11,r8
8000b644:	12 4a       	or	r10,r9
8000b646:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000b64a:	c8 3b       	rjmp	8000b550 <__avr32_f64_mul+0x7c>
8000b64c:	f8 08 11 20 	rsub	r8,r12,32
8000b650:	f9 b9 00 00 	moveq	r9,0
8000b654:	c0 30       	breq	8000b65a <__avr32_f64_mul_res_subnormal+0x3c>
8000b656:	f6 08 09 49 	lsl	r9,r11,r8
8000b65a:	0e 46       	or	r6,r7
8000b65c:	ed ea 10 16 	or	r6,r6,r10<<0x1
8000b660:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000b664:	f3 ea 10 07 	or	r7,r9,r10
8000b668:	f6 0c 0a 4a 	lsr	r10,r11,r12
8000b66c:	30 0b       	mov	r11,0
8000b66e:	c7 1b       	rjmp	8000b550 <__avr32_f64_mul+0x7c>

8000b670 <__avr32_f64_mul_res_zero>:
8000b670:	1c 9b       	mov	r11,lr
8000b672:	e6 1b 80 00 	andh	r11,0x8000,COH
8000b676:	30 0a       	mov	r10,0
8000b678:	d8 22       	popm	r4-r7,pc

8000b67a <__avr32_f64_mul_res_nan>:
8000b67a:	3f fb       	mov	r11,-1
8000b67c:	3f fa       	mov	r10,-1
8000b67e:	d8 22       	popm	r4-r7,pc

8000b680 <__avr32_f64_mul_res_inf>:
8000b680:	f0 6b 00 00 	mov	r11,-1048576
8000b684:	ed be 00 1f 	bld	lr,0x1f
8000b688:	ef bb 00 1f 	bst	r11,0x1f
8000b68c:	30 0a       	mov	r10,0
8000b68e:	d8 22       	popm	r4-r7,pc

8000b690 <__avr32_f64_mul_op1_zero>:
8000b690:	f7 e9 20 0b 	eor	r11,r11,r9
8000b694:	e6 1b 80 00 	andh	r11,0x8000,COH
8000b698:	f9 d9 c2 8b 	bfextu	r12,r9,0x14,0xb
8000b69c:	e0 4c 07 ff 	cp.w	r12,2047
8000b6a0:	5e 1c       	retne	r12
8000b6a2:	3f fa       	mov	r10,-1
8000b6a4:	3f fb       	mov	r11,-1
8000b6a6:	5e fc       	retal	r12

8000b6a8 <__avr32_f64_sub_from_add>:
8000b6a8:	ee 19 80 00 	eorh	r9,0x8000

8000b6ac <__avr32_f64_sub>:
8000b6ac:	f7 e9 20 0c 	eor	r12,r11,r9
8000b6b0:	e0 86 00 ca 	brmi	8000b844 <__avr32_f64_add_from_sub>
8000b6b4:	eb cd 40 e0 	pushm	r5-r7,lr
8000b6b8:	16 9c       	mov	r12,r11
8000b6ba:	e6 1c 80 00 	andh	r12,0x8000,COH
8000b6be:	bf db       	cbr	r11,0x1f
8000b6c0:	bf d9       	cbr	r9,0x1f
8000b6c2:	10 3a       	cp.w	r10,r8
8000b6c4:	f2 0b 13 00 	cpc	r11,r9
8000b6c8:	c0 92       	brcc	8000b6da <__avr32_f64_sub+0x2e>
8000b6ca:	16 97       	mov	r7,r11
8000b6cc:	12 9b       	mov	r11,r9
8000b6ce:	0e 99       	mov	r9,r7
8000b6d0:	14 97       	mov	r7,r10
8000b6d2:	10 9a       	mov	r10,r8
8000b6d4:	0e 98       	mov	r8,r7
8000b6d6:	ee 1c 80 00 	eorh	r12,0x8000
8000b6da:	f6 07 16 14 	lsr	r7,r11,0x14
8000b6de:	ab 7b       	lsl	r11,0xb
8000b6e0:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000b6e4:	ab 7a       	lsl	r10,0xb
8000b6e6:	bf bb       	sbr	r11,0x1f
8000b6e8:	f2 06 16 14 	lsr	r6,r9,0x14
8000b6ec:	c4 40       	breq	8000b774 <__avr32_f64_sub_opL_subnormal>
8000b6ee:	ab 79       	lsl	r9,0xb
8000b6f0:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000b6f4:	ab 78       	lsl	r8,0xb
8000b6f6:	bf b9       	sbr	r9,0x1f

8000b6f8 <__avr32_f64_sub_opL_subnormal_done>:
8000b6f8:	e0 47 07 ff 	cp.w	r7,2047
8000b6fc:	c4 f0       	breq	8000b79a <__avr32_f64_sub_opH_nan_or_inf>
8000b6fe:	0e 26       	rsub	r6,r7
8000b700:	c1 20       	breq	8000b724 <__avr32_f64_sub_shift_done>
8000b702:	ec 05 11 20 	rsub	r5,r6,32
8000b706:	e0 46 00 20 	cp.w	r6,32
8000b70a:	c7 c2       	brcc	8000b802 <__avr32_f64_sub_longshift>
8000b70c:	f0 05 09 4e 	lsl	lr,r8,r5
8000b710:	f2 05 09 45 	lsl	r5,r9,r5
8000b714:	f0 06 0a 48 	lsr	r8,r8,r6
8000b718:	f2 06 0a 49 	lsr	r9,r9,r6
8000b71c:	0a 48       	or	r8,r5
8000b71e:	58 0e       	cp.w	lr,0
8000b720:	5f 1e       	srne	lr
8000b722:	1c 48       	or	r8,lr

8000b724 <__avr32_f64_sub_shift_done>:
8000b724:	10 1a       	sub	r10,r8
8000b726:	f6 09 01 4b 	sbc	r11,r11,r9
8000b72a:	f6 06 12 00 	clz	r6,r11
8000b72e:	c0 e0       	breq	8000b74a <__avr32_f64_sub_longnormalize_done>
8000b730:	c7 83       	brcs	8000b820 <__avr32_f64_sub_longnormalize>
8000b732:	ec 0e 11 20 	rsub	lr,r6,32
8000b736:	f6 06 09 4b 	lsl	r11,r11,r6
8000b73a:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000b73e:	1c 4b       	or	r11,lr
8000b740:	f4 06 09 4a 	lsl	r10,r10,r6
8000b744:	0c 17       	sub	r7,r6
8000b746:	e0 8a 00 39 	brle	8000b7b8 <__avr32_f64_sub_subnormal_result>

8000b74a <__avr32_f64_sub_longnormalize_done>:
8000b74a:	f4 09 15 15 	lsl	r9,r10,0x15
8000b74e:	ab 9a       	lsr	r10,0xb
8000b750:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000b754:	ab 9b       	lsr	r11,0xb
8000b756:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000b75a:	18 4b       	or	r11,r12

8000b75c <__avr32_f64_sub_round>:
8000b75c:	fc 17 80 00 	movh	r7,0x8000
8000b760:	ed ba 00 00 	bld	r10,0x0
8000b764:	f7 b7 01 ff 	subne	r7,-1
8000b768:	0e 39       	cp.w	r9,r7
8000b76a:	5f 29       	srhs	r9
8000b76c:	12 0a       	add	r10,r9
8000b76e:	5c 0b       	acr	r11
8000b770:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b774 <__avr32_f64_sub_opL_subnormal>:
8000b774:	ab 79       	lsl	r9,0xb
8000b776:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000b77a:	ab 78       	lsl	r8,0xb
8000b77c:	f3 e8 10 0e 	or	lr,r9,r8
8000b780:	f9 b6 01 01 	movne	r6,1
8000b784:	ee 0e 11 00 	rsub	lr,r7,0
8000b788:	f9 b7 00 01 	moveq	r7,1
8000b78c:	ef bb 00 1f 	bst	r11,0x1f
8000b790:	f7 ea 10 0e 	or	lr,r11,r10
8000b794:	f9 b7 00 00 	moveq	r7,0
8000b798:	cb 0b       	rjmp	8000b6f8 <__avr32_f64_sub_opL_subnormal_done>

8000b79a <__avr32_f64_sub_opH_nan_or_inf>:
8000b79a:	bf db       	cbr	r11,0x1f
8000b79c:	f7 ea 10 0e 	or	lr,r11,r10
8000b7a0:	c0 81       	brne	8000b7b0 <__avr32_f64_sub_return_nan>
8000b7a2:	e0 46 07 ff 	cp.w	r6,2047
8000b7a6:	c0 50       	breq	8000b7b0 <__avr32_f64_sub_return_nan>
8000b7a8:	f9 e7 11 4b 	or	r11,r12,r7<<0x14
8000b7ac:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b7b0 <__avr32_f64_sub_return_nan>:
8000b7b0:	3f fa       	mov	r10,-1
8000b7b2:	3f fb       	mov	r11,-1
8000b7b4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b7b8 <__avr32_f64_sub_subnormal_result>:
8000b7b8:	5c 37       	neg	r7
8000b7ba:	2f f7       	sub	r7,-1
8000b7bc:	f1 b7 04 c0 	satu	r7,0x6
8000b7c0:	e0 47 00 20 	cp.w	r7,32
8000b7c4:	c1 14       	brge	8000b7e6 <__avr32_f64_sub_subnormal_result+0x2e>
8000b7c6:	ee 08 11 20 	rsub	r8,r7,32
8000b7ca:	f4 08 09 49 	lsl	r9,r10,r8
8000b7ce:	5f 16       	srne	r6
8000b7d0:	f4 07 0a 4a 	lsr	r10,r10,r7
8000b7d4:	0c 4a       	or	r10,r6
8000b7d6:	f6 08 09 49 	lsl	r9,r11,r8
8000b7da:	f5 e9 10 0a 	or	r10,r10,r9
8000b7de:	f4 07 0a 4b 	lsr	r11,r10,r7
8000b7e2:	30 07       	mov	r7,0
8000b7e4:	cb 3b       	rjmp	8000b74a <__avr32_f64_sub_longnormalize_done>
8000b7e6:	ee 08 11 40 	rsub	r8,r7,64
8000b7ea:	f6 08 09 49 	lsl	r9,r11,r8
8000b7ee:	14 49       	or	r9,r10
8000b7f0:	5f 16       	srne	r6
8000b7f2:	f6 07 0a 4a 	lsr	r10,r11,r7
8000b7f6:	0c 4a       	or	r10,r6
8000b7f8:	30 0b       	mov	r11,0
8000b7fa:	30 07       	mov	r7,0
8000b7fc:	ca 7b       	rjmp	8000b74a <__avr32_f64_sub_longnormalize_done>
8000b7fe:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b802 <__avr32_f64_sub_longshift>:
8000b802:	f1 b6 04 c0 	satu	r6,0x6
8000b806:	f0 0e 17 00 	moveq	lr,r8
8000b80a:	c0 40       	breq	8000b812 <__avr32_f64_sub_longshift+0x10>
8000b80c:	f2 05 09 4e 	lsl	lr,r9,r5
8000b810:	10 4e       	or	lr,r8
8000b812:	f2 06 0a 48 	lsr	r8,r9,r6
8000b816:	30 09       	mov	r9,0
8000b818:	58 0e       	cp.w	lr,0
8000b81a:	5f 1e       	srne	lr
8000b81c:	1c 48       	or	r8,lr
8000b81e:	c8 3b       	rjmp	8000b724 <__avr32_f64_sub_shift_done>

8000b820 <__avr32_f64_sub_longnormalize>:
8000b820:	f4 06 12 00 	clz	r6,r10
8000b824:	f9 b7 03 00 	movlo	r7,0
8000b828:	f9 b6 03 00 	movlo	r6,0
8000b82c:	f9 bc 03 00 	movlo	r12,0
8000b830:	f7 b6 02 e0 	subhs	r6,-32
8000b834:	f4 06 09 4b 	lsl	r11,r10,r6
8000b838:	30 0a       	mov	r10,0
8000b83a:	0c 17       	sub	r7,r6
8000b83c:	fe 9a ff be 	brle	8000b7b8 <__avr32_f64_sub_subnormal_result>
8000b840:	c8 5b       	rjmp	8000b74a <__avr32_f64_sub_longnormalize_done>
8000b842:	d7 03       	nop

8000b844 <__avr32_f64_add_from_sub>:
8000b844:	ee 19 80 00 	eorh	r9,0x8000

8000b848 <__avr32_f64_add>:
8000b848:	f7 e9 20 0c 	eor	r12,r11,r9
8000b84c:	fe 96 ff 2e 	brmi	8000b6a8 <__avr32_f64_sub_from_add>
8000b850:	eb cd 40 e0 	pushm	r5-r7,lr
8000b854:	16 9c       	mov	r12,r11
8000b856:	e6 1c 80 00 	andh	r12,0x8000,COH
8000b85a:	bf db       	cbr	r11,0x1f
8000b85c:	bf d9       	cbr	r9,0x1f
8000b85e:	12 3b       	cp.w	r11,r9
8000b860:	c0 72       	brcc	8000b86e <__avr32_f64_add+0x26>
8000b862:	16 97       	mov	r7,r11
8000b864:	12 9b       	mov	r11,r9
8000b866:	0e 99       	mov	r9,r7
8000b868:	14 97       	mov	r7,r10
8000b86a:	10 9a       	mov	r10,r8
8000b86c:	0e 98       	mov	r8,r7
8000b86e:	30 0e       	mov	lr,0
8000b870:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000b874:	f7 db c0 14 	bfextu	r11,r11,0x0,0x14
8000b878:	b5 ab       	sbr	r11,0x14
8000b87a:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000b87e:	c6 20       	breq	8000b942 <__avr32_f64_add_op2_subnormal>
8000b880:	f3 d9 c0 14 	bfextu	r9,r9,0x0,0x14
8000b884:	b5 a9       	sbr	r9,0x14
8000b886:	e0 47 07 ff 	cp.w	r7,2047
8000b88a:	c2 80       	breq	8000b8da <__avr32_f64_add_opH_nan_or_inf>
8000b88c:	0e 26       	rsub	r6,r7
8000b88e:	c1 20       	breq	8000b8b2 <__avr32_f64_add_shift_done>
8000b890:	e0 46 00 36 	cp.w	r6,54
8000b894:	c1 52       	brcc	8000b8be <__avr32_f64_add_res_of_done>
8000b896:	ec 05 11 20 	rsub	r5,r6,32
8000b89a:	e0 46 00 20 	cp.w	r6,32
8000b89e:	c3 52       	brcc	8000b908 <__avr32_f64_add_longshift>
8000b8a0:	f0 05 09 4e 	lsl	lr,r8,r5
8000b8a4:	f2 05 09 45 	lsl	r5,r9,r5
8000b8a8:	f0 06 0a 48 	lsr	r8,r8,r6
8000b8ac:	f2 06 0a 49 	lsr	r9,r9,r6
8000b8b0:	0a 48       	or	r8,r5

8000b8b2 <__avr32_f64_add_shift_done>:
8000b8b2:	10 0a       	add	r10,r8
8000b8b4:	f6 09 00 4b 	adc	r11,r11,r9
8000b8b8:	ed bb 00 15 	bld	r11,0x15
8000b8bc:	c3 40       	breq	8000b924 <__avr32_f64_add_res_of>

8000b8be <__avr32_f64_add_res_of_done>:
8000b8be:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000b8c2:	18 4b       	or	r11,r12

8000b8c4 <__avr32_f64_add_round>:
8000b8c4:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
8000b8c8:	18 4e       	or	lr,r12
8000b8ca:	ee 1e 80 00 	eorh	lr,0x8000
8000b8ce:	f1 be 04 20 	satu	lr,0x1
8000b8d2:	1c 0a       	add	r10,lr
8000b8d4:	5c 0b       	acr	r11
8000b8d6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b8da <__avr32_f64_add_opH_nan_or_inf>:
8000b8da:	b5 cb       	cbr	r11,0x14
8000b8dc:	f7 ea 10 0e 	or	lr,r11,r10
8000b8e0:	c1 01       	brne	8000b900 <__avr32_f64_add_return_nan>
8000b8e2:	e0 46 07 ff 	cp.w	r6,2047
8000b8e6:	c0 30       	breq	8000b8ec <__avr32_f64_add_opL_nan_or_inf>
8000b8e8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b8ec <__avr32_f64_add_opL_nan_or_inf>:
8000b8ec:	b5 c9       	cbr	r9,0x14
8000b8ee:	f3 e8 10 0e 	or	lr,r9,r8
8000b8f2:	c0 71       	brne	8000b900 <__avr32_f64_add_return_nan>
8000b8f4:	30 0a       	mov	r10,0
8000b8f6:	fc 1b 7f f0 	movh	r11,0x7ff0
8000b8fa:	18 4b       	or	r11,r12
8000b8fc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b900 <__avr32_f64_add_return_nan>:
8000b900:	3f fa       	mov	r10,-1
8000b902:	3f fb       	mov	r11,-1
8000b904:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b908 <__avr32_f64_add_longshift>:
8000b908:	f1 b6 04 c0 	satu	r6,0x6
8000b90c:	f0 0e 17 00 	moveq	lr,r8
8000b910:	c0 60       	breq	8000b91c <__avr32_f64_add_longshift+0x14>
8000b912:	f2 05 09 4e 	lsl	lr,r9,r5
8000b916:	58 08       	cp.w	r8,0
8000b918:	5f 18       	srne	r8
8000b91a:	10 4e       	or	lr,r8
8000b91c:	f2 06 0a 48 	lsr	r8,r9,r6
8000b920:	30 09       	mov	r9,0
8000b922:	cc 8b       	rjmp	8000b8b2 <__avr32_f64_add_shift_done>

8000b924 <__avr32_f64_add_res_of>:
8000b924:	fd ee 10 1e 	or	lr,lr,lr<<0x1
8000b928:	a1 9b       	lsr	r11,0x1
8000b92a:	5d 0a       	ror	r10
8000b92c:	5d 0e       	ror	lr
8000b92e:	2f f7       	sub	r7,-1
8000b930:	e0 47 07 ff 	cp.w	r7,2047
8000b934:	f9 ba 00 00 	moveq	r10,0
8000b938:	f9 bb 00 00 	moveq	r11,0
8000b93c:	f9 be 00 00 	moveq	lr,0
8000b940:	cb fb       	rjmp	8000b8be <__avr32_f64_add_res_of_done>

8000b942 <__avr32_f64_add_op2_subnormal>:
8000b942:	30 16       	mov	r6,1
8000b944:	58 07       	cp.w	r7,0
8000b946:	ca 01       	brne	8000b886 <__avr32_f64_add+0x3e>
8000b948:	b5 cb       	cbr	r11,0x14
8000b94a:	10 0a       	add	r10,r8
8000b94c:	f6 09 00 4b 	adc	r11,r11,r9
8000b950:	18 4b       	or	r11,r12
8000b952:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000b956:	d7 03       	nop

8000b958 <__avr32_f64_to_u32>:
8000b958:	58 0b       	cp.w	r11,0
8000b95a:	5e 6d       	retmi	0

8000b95c <__avr32_f64_to_s32>:
8000b95c:	f6 0c 15 01 	lsl	r12,r11,0x1
8000b960:	b5 9c       	lsr	r12,0x15
8000b962:	e0 2c 03 ff 	sub	r12,1023
8000b966:	5e 3d       	retlo	0
8000b968:	f8 0c 11 1f 	rsub	r12,r12,31
8000b96c:	16 99       	mov	r9,r11
8000b96e:	ab 7b       	lsl	r11,0xb
8000b970:	bf bb       	sbr	r11,0x1f
8000b972:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000b976:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000b97a:	a1 79       	lsl	r9,0x1
8000b97c:	5e 2b       	reths	r11
8000b97e:	5c 3b       	neg	r11
8000b980:	5e fb       	retal	r11

8000b982 <__avr32_u32_to_f64>:
8000b982:	f8 cb 00 00 	sub	r11,r12,0
8000b986:	30 0c       	mov	r12,0
8000b988:	c0 38       	rjmp	8000b98e <__avr32_s32_to_f64+0x4>

8000b98a <__avr32_s32_to_f64>:
8000b98a:	18 9b       	mov	r11,r12
8000b98c:	5c 4b       	abs	r11
8000b98e:	30 0a       	mov	r10,0
8000b990:	5e 0b       	reteq	r11
8000b992:	d4 01       	pushm	lr
8000b994:	e0 69 04 1e 	mov	r9,1054
8000b998:	f6 08 12 00 	clz	r8,r11
8000b99c:	c1 70       	breq	8000b9ca <__avr32_s32_to_f64+0x40>
8000b99e:	c0 c3       	brcs	8000b9b6 <__avr32_s32_to_f64+0x2c>
8000b9a0:	f0 0e 11 20 	rsub	lr,r8,32
8000b9a4:	f6 08 09 4b 	lsl	r11,r11,r8
8000b9a8:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000b9ac:	1c 4b       	or	r11,lr
8000b9ae:	f4 08 09 4a 	lsl	r10,r10,r8
8000b9b2:	10 19       	sub	r9,r8
8000b9b4:	c0 b8       	rjmp	8000b9ca <__avr32_s32_to_f64+0x40>
8000b9b6:	f4 08 12 00 	clz	r8,r10
8000b9ba:	f9 b8 03 00 	movlo	r8,0
8000b9be:	f7 b8 02 e0 	subhs	r8,-32
8000b9c2:	f4 08 09 4b 	lsl	r11,r10,r8
8000b9c6:	30 0a       	mov	r10,0
8000b9c8:	10 19       	sub	r9,r8
8000b9ca:	58 09       	cp.w	r9,0
8000b9cc:	e0 89 00 30 	brgt	8000ba2c <__avr32_s32_to_f64+0xa2>
8000b9d0:	5c 39       	neg	r9
8000b9d2:	2f f9       	sub	r9,-1
8000b9d4:	e0 49 00 36 	cp.w	r9,54
8000b9d8:	c0 43       	brcs	8000b9e0 <__avr32_s32_to_f64+0x56>
8000b9da:	30 0b       	mov	r11,0
8000b9dc:	30 0a       	mov	r10,0
8000b9de:	c2 68       	rjmp	8000ba2a <__avr32_s32_to_f64+0xa0>
8000b9e0:	2f 69       	sub	r9,-10
8000b9e2:	f2 08 11 20 	rsub	r8,r9,32
8000b9e6:	e0 49 00 20 	cp.w	r9,32
8000b9ea:	c0 b2       	brcc	8000ba00 <__avr32_s32_to_f64+0x76>
8000b9ec:	f4 08 09 4e 	lsl	lr,r10,r8
8000b9f0:	f6 08 09 48 	lsl	r8,r11,r8
8000b9f4:	f4 09 0a 4a 	lsr	r10,r10,r9
8000b9f8:	f6 09 0a 4b 	lsr	r11,r11,r9
8000b9fc:	10 4b       	or	r11,r8
8000b9fe:	c0 88       	rjmp	8000ba0e <__avr32_s32_to_f64+0x84>
8000ba00:	f6 08 09 4e 	lsl	lr,r11,r8
8000ba04:	14 4e       	or	lr,r10
8000ba06:	16 9a       	mov	r10,r11
8000ba08:	30 0b       	mov	r11,0
8000ba0a:	f4 09 0a 4a 	lsr	r10,r10,r9
8000ba0e:	ed ba 00 00 	bld	r10,0x0
8000ba12:	c0 92       	brcc	8000ba24 <__avr32_s32_to_f64+0x9a>
8000ba14:	1c 7e       	tst	lr,lr
8000ba16:	c0 41       	brne	8000ba1e <__avr32_s32_to_f64+0x94>
8000ba18:	ed ba 00 01 	bld	r10,0x1
8000ba1c:	c0 42       	brcc	8000ba24 <__avr32_s32_to_f64+0x9a>
8000ba1e:	2f fa       	sub	r10,-1
8000ba20:	f7 bb 02 ff 	subhs	r11,-1
8000ba24:	5c fc       	rol	r12
8000ba26:	5d 0b       	ror	r11
8000ba28:	5d 0a       	ror	r10
8000ba2a:	d8 02       	popm	pc
8000ba2c:	e0 68 03 ff 	mov	r8,1023
8000ba30:	ed ba 00 0b 	bld	r10,0xb
8000ba34:	f7 b8 00 ff 	subeq	r8,-1
8000ba38:	10 0a       	add	r10,r8
8000ba3a:	5c 0b       	acr	r11
8000ba3c:	f7 b9 03 fe 	sublo	r9,-2
8000ba40:	e0 49 07 ff 	cp.w	r9,2047
8000ba44:	c0 55       	brlt	8000ba4e <__avr32_s32_to_f64+0xc4>
8000ba46:	30 0a       	mov	r10,0
8000ba48:	fc 1b ff e0 	movh	r11,0xffe0
8000ba4c:	c0 c8       	rjmp	8000ba64 <__floatsidf_return_op1>
8000ba4e:	ed bb 00 1f 	bld	r11,0x1f
8000ba52:	f7 b9 01 01 	subne	r9,1
8000ba56:	ab 9a       	lsr	r10,0xb
8000ba58:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000ba5c:	a1 7b       	lsl	r11,0x1
8000ba5e:	ab 9b       	lsr	r11,0xb
8000ba60:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

8000ba64 <__floatsidf_return_op1>:
8000ba64:	a1 7c       	lsl	r12,0x1
8000ba66:	5d 0b       	ror	r11
8000ba68:	d8 02       	popm	pc

8000ba6a <__avr32_f64_cmp_eq>:
8000ba6a:	10 3a       	cp.w	r10,r8
8000ba6c:	f2 0b 13 00 	cpc	r11,r9
8000ba70:	c0 80       	breq	8000ba80 <__avr32_f64_cmp_eq+0x16>
8000ba72:	a1 7b       	lsl	r11,0x1
8000ba74:	a1 79       	lsl	r9,0x1
8000ba76:	14 4b       	or	r11,r10
8000ba78:	12 4b       	or	r11,r9
8000ba7a:	10 4b       	or	r11,r8
8000ba7c:	5e 0f       	reteq	1
8000ba7e:	5e fd       	retal	0
8000ba80:	a1 7b       	lsl	r11,0x1
8000ba82:	fc 1c ff e0 	movh	r12,0xffe0
8000ba86:	58 0a       	cp.w	r10,0
8000ba88:	f8 0b 13 00 	cpc	r11,r12
8000ba8c:	5e 8f       	retls	1
8000ba8e:	5e fd       	retal	0

8000ba90 <__avr32_f64_cmp_ge>:
8000ba90:	1a de       	st.w	--sp,lr
8000ba92:	1a d7       	st.w	--sp,r7
8000ba94:	a1 7b       	lsl	r11,0x1
8000ba96:	5f 3c       	srlo	r12
8000ba98:	a1 79       	lsl	r9,0x1
8000ba9a:	5f 37       	srlo	r7
8000ba9c:	5c fc       	rol	r12
8000ba9e:	fc 1e ff e0 	movh	lr,0xffe0
8000baa2:	58 0a       	cp.w	r10,0
8000baa4:	fc 0b 13 00 	cpc	r11,lr
8000baa8:	e0 8b 00 1d 	brhi	8000bae2 <__avr32_f64_cmp_ge+0x52>
8000baac:	58 08       	cp.w	r8,0
8000baae:	fc 09 13 00 	cpc	r9,lr
8000bab2:	e0 8b 00 18 	brhi	8000bae2 <__avr32_f64_cmp_ge+0x52>
8000bab6:	58 0b       	cp.w	r11,0
8000bab8:	f5 ba 00 00 	subfeq	r10,0
8000babc:	c1 50       	breq	8000bae6 <__avr32_f64_cmp_ge+0x56>
8000babe:	1b 07       	ld.w	r7,sp++
8000bac0:	1b 0e       	ld.w	lr,sp++
8000bac2:	58 3c       	cp.w	r12,3
8000bac4:	c0 a0       	breq	8000bad8 <__avr32_f64_cmp_ge+0x48>
8000bac6:	58 1c       	cp.w	r12,1
8000bac8:	c0 33       	brcs	8000bace <__avr32_f64_cmp_ge+0x3e>
8000baca:	5e 0f       	reteq	1
8000bacc:	5e 1d       	retne	0
8000bace:	10 3a       	cp.w	r10,r8
8000bad0:	f2 0b 13 00 	cpc	r11,r9
8000bad4:	5e 2f       	reths	1
8000bad6:	5e 3d       	retlo	0
8000bad8:	14 38       	cp.w	r8,r10
8000bada:	f6 09 13 00 	cpc	r9,r11
8000bade:	5e 2f       	reths	1
8000bae0:	5e 3d       	retlo	0
8000bae2:	1b 07       	ld.w	r7,sp++
8000bae4:	d8 0a       	popm	pc,r12=0
8000bae6:	58 17       	cp.w	r7,1
8000bae8:	5f 0c       	sreq	r12
8000baea:	58 09       	cp.w	r9,0
8000baec:	f5 b8 00 00 	subfeq	r8,0
8000baf0:	1b 07       	ld.w	r7,sp++
8000baf2:	1b 0e       	ld.w	lr,sp++
8000baf4:	5e 0f       	reteq	1
8000baf6:	5e fc       	retal	r12

8000baf8 <__avr32_f64_cmp_lt>:
8000baf8:	1a de       	st.w	--sp,lr
8000bafa:	1a d7       	st.w	--sp,r7
8000bafc:	a1 7b       	lsl	r11,0x1
8000bafe:	5f 3c       	srlo	r12
8000bb00:	a1 79       	lsl	r9,0x1
8000bb02:	5f 37       	srlo	r7
8000bb04:	5c fc       	rol	r12
8000bb06:	fc 1e ff e0 	movh	lr,0xffe0
8000bb0a:	58 0a       	cp.w	r10,0
8000bb0c:	fc 0b 13 00 	cpc	r11,lr
8000bb10:	e0 8b 00 1d 	brhi	8000bb4a <__avr32_f64_cmp_lt+0x52>
8000bb14:	58 08       	cp.w	r8,0
8000bb16:	fc 09 13 00 	cpc	r9,lr
8000bb1a:	e0 8b 00 18 	brhi	8000bb4a <__avr32_f64_cmp_lt+0x52>
8000bb1e:	58 0b       	cp.w	r11,0
8000bb20:	f5 ba 00 00 	subfeq	r10,0
8000bb24:	c1 50       	breq	8000bb4e <__avr32_f64_cmp_lt+0x56>
8000bb26:	1b 07       	ld.w	r7,sp++
8000bb28:	1b 0e       	ld.w	lr,sp++
8000bb2a:	58 3c       	cp.w	r12,3
8000bb2c:	c0 a0       	breq	8000bb40 <__avr32_f64_cmp_lt+0x48>
8000bb2e:	58 1c       	cp.w	r12,1
8000bb30:	c0 33       	brcs	8000bb36 <__avr32_f64_cmp_lt+0x3e>
8000bb32:	5e 0d       	reteq	0
8000bb34:	5e 1f       	retne	1
8000bb36:	10 3a       	cp.w	r10,r8
8000bb38:	f2 0b 13 00 	cpc	r11,r9
8000bb3c:	5e 2d       	reths	0
8000bb3e:	5e 3f       	retlo	1
8000bb40:	14 38       	cp.w	r8,r10
8000bb42:	f6 09 13 00 	cpc	r9,r11
8000bb46:	5e 2d       	reths	0
8000bb48:	5e 3f       	retlo	1
8000bb4a:	1b 07       	ld.w	r7,sp++
8000bb4c:	d8 0a       	popm	pc,r12=0
8000bb4e:	58 17       	cp.w	r7,1
8000bb50:	5f 1c       	srne	r12
8000bb52:	58 09       	cp.w	r9,0
8000bb54:	f5 b8 00 00 	subfeq	r8,0
8000bb58:	1b 07       	ld.w	r7,sp++
8000bb5a:	1b 0e       	ld.w	lr,sp++
8000bb5c:	5e 0d       	reteq	0
8000bb5e:	5e fc       	retal	r12

8000bb60 <__avr32_f64_div>:
8000bb60:	eb cd 40 ff 	pushm	r0-r7,lr
8000bb64:	f7 e9 20 0e 	eor	lr,r11,r9
8000bb68:	f6 07 16 14 	lsr	r7,r11,0x14
8000bb6c:	a9 7b       	lsl	r11,0x9
8000bb6e:	f7 ea 13 7b 	or	r11,r11,r10>>0x17
8000bb72:	a9 7a       	lsl	r10,0x9
8000bb74:	bd bb       	sbr	r11,0x1d
8000bb76:	e4 1b 3f ff 	andh	r11,0x3fff
8000bb7a:	ab d7       	cbr	r7,0xb
8000bb7c:	e0 80 00 cc 	breq	8000bd14 <__avr32_f64_div_round_subnormal+0x54>
8000bb80:	e0 47 07 ff 	cp.w	r7,2047
8000bb84:	e0 84 00 b5 	brge	8000bcee <__avr32_f64_div_round_subnormal+0x2e>
8000bb88:	f2 06 16 14 	lsr	r6,r9,0x14
8000bb8c:	a9 79       	lsl	r9,0x9
8000bb8e:	f3 e8 13 79 	or	r9,r9,r8>>0x17
8000bb92:	a9 78       	lsl	r8,0x9
8000bb94:	bd b9       	sbr	r9,0x1d
8000bb96:	e4 19 3f ff 	andh	r9,0x3fff
8000bb9a:	ab d6       	cbr	r6,0xb
8000bb9c:	e0 80 00 e2 	breq	8000bd60 <__avr32_f64_div_round_subnormal+0xa0>
8000bba0:	e0 46 07 ff 	cp.w	r6,2047
8000bba4:	e0 84 00 b2 	brge	8000bd08 <__avr32_f64_div_round_subnormal+0x48>
8000bba8:	0c 17       	sub	r7,r6
8000bbaa:	fe 37 fc 01 	sub	r7,-1023
8000bbae:	fc 1c 80 00 	movh	r12,0x8000
8000bbb2:	f8 03 16 01 	lsr	r3,r12,0x1
8000bbb6:	e9 d9 c3 62 	bfextu	r4,r9,0x1b,0x2
8000bbba:	5c d4       	com	r4
8000bbbc:	e7 d4 d3 82 	bfins	r3,r4,0x1c,0x2
8000bbc0:	e6 09 06 44 	mulu.d	r4,r3,r9
8000bbc4:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000bbc8:	e6 05 06 44 	mulu.d	r4,r3,r5
8000bbcc:	ea 03 15 02 	lsl	r3,r5,0x2
8000bbd0:	e6 09 06 44 	mulu.d	r4,r3,r9
8000bbd4:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000bbd8:	e6 05 06 44 	mulu.d	r4,r3,r5
8000bbdc:	ea 03 15 02 	lsl	r3,r5,0x2
8000bbe0:	e6 09 06 44 	mulu.d	r4,r3,r9
8000bbe4:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000bbe8:	e6 05 06 44 	mulu.d	r4,r3,r5
8000bbec:	ea 03 15 02 	lsl	r3,r5,0x2
8000bbf0:	e6 08 06 40 	mulu.d	r0,r3,r8
8000bbf4:	e4 09 07 40 	macu.d	r0,r2,r9
8000bbf8:	e6 09 06 44 	mulu.d	r4,r3,r9
8000bbfc:	02 04       	add	r4,r1
8000bbfe:	5c 05       	acr	r5
8000bc00:	a3 65       	lsl	r5,0x2
8000bc02:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000bc06:	a3 64       	lsl	r4,0x2
8000bc08:	5c 34       	neg	r4
8000bc0a:	f8 05 01 45 	sbc	r5,r12,r5
8000bc0e:	e6 04 06 40 	mulu.d	r0,r3,r4
8000bc12:	e4 05 07 40 	macu.d	r0,r2,r5
8000bc16:	e6 05 06 44 	mulu.d	r4,r3,r5
8000bc1a:	02 04       	add	r4,r1
8000bc1c:	5c 05       	acr	r5
8000bc1e:	ea 03 15 02 	lsl	r3,r5,0x2
8000bc22:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000bc26:	e8 02 15 02 	lsl	r2,r4,0x2
8000bc2a:	e6 08 06 40 	mulu.d	r0,r3,r8
8000bc2e:	e4 09 07 40 	macu.d	r0,r2,r9
8000bc32:	e6 09 06 44 	mulu.d	r4,r3,r9
8000bc36:	02 04       	add	r4,r1
8000bc38:	5c 05       	acr	r5
8000bc3a:	a3 65       	lsl	r5,0x2
8000bc3c:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000bc40:	a3 64       	lsl	r4,0x2
8000bc42:	5c 34       	neg	r4
8000bc44:	f8 05 01 45 	sbc	r5,r12,r5
8000bc48:	e6 04 06 40 	mulu.d	r0,r3,r4
8000bc4c:	e4 05 07 40 	macu.d	r0,r2,r5
8000bc50:	e6 05 06 44 	mulu.d	r4,r3,r5
8000bc54:	02 04       	add	r4,r1
8000bc56:	5c 05       	acr	r5
8000bc58:	ea 03 15 02 	lsl	r3,r5,0x2
8000bc5c:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000bc60:	e8 02 15 02 	lsl	r2,r4,0x2
8000bc64:	e6 0a 06 40 	mulu.d	r0,r3,r10
8000bc68:	e4 0b 07 40 	macu.d	r0,r2,r11
8000bc6c:	e6 0b 06 42 	mulu.d	r2,r3,r11
8000bc70:	02 02       	add	r2,r1
8000bc72:	5c 03       	acr	r3
8000bc74:	ed b3 00 1c 	bld	r3,0x1c
8000bc78:	c0 90       	breq	8000bc8a <__avr32_f64_div+0x12a>
8000bc7a:	a1 72       	lsl	r2,0x1
8000bc7c:	5c f3       	rol	r3
8000bc7e:	20 17       	sub	r7,1
8000bc80:	a3 9a       	lsr	r10,0x3
8000bc82:	f5 eb 11 da 	or	r10,r10,r11<<0x1d
8000bc86:	a3 9b       	lsr	r11,0x3
8000bc88:	c0 58       	rjmp	8000bc92 <__avr32_f64_div+0x132>
8000bc8a:	a5 8a       	lsr	r10,0x4
8000bc8c:	f5 eb 11 ca 	or	r10,r10,r11<<0x1c
8000bc90:	a5 8b       	lsr	r11,0x4
8000bc92:	58 07       	cp.w	r7,0
8000bc94:	e0 8a 00 8b 	brle	8000bdaa <__avr32_f64_div_res_subnormal>
8000bc98:	e0 12 ff 00 	andl	r2,0xff00
8000bc9c:	e8 12 00 80 	orl	r2,0x80
8000bca0:	e6 08 06 40 	mulu.d	r0,r3,r8
8000bca4:	e4 09 07 40 	macu.d	r0,r2,r9
8000bca8:	e4 08 06 44 	mulu.d	r4,r2,r8
8000bcac:	e6 09 06 48 	mulu.d	r8,r3,r9
8000bcb0:	00 05       	add	r5,r0
8000bcb2:	f0 01 00 48 	adc	r8,r8,r1
8000bcb6:	5c 09       	acr	r9
8000bcb8:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000bcbc:	58 04       	cp.w	r4,0
8000bcbe:	5c 25       	cpc	r5

8000bcc0 <__avr32_f64_div_round_subnormal>:
8000bcc0:	f4 08 13 00 	cpc	r8,r10
8000bcc4:	f6 09 13 00 	cpc	r9,r11
8000bcc8:	5f 36       	srlo	r6
8000bcca:	f8 06 17 00 	moveq	r6,r12
8000bcce:	e4 0a 16 08 	lsr	r10,r2,0x8
8000bcd2:	f5 e3 11 8a 	or	r10,r10,r3<<0x18
8000bcd6:	e6 0b 16 08 	lsr	r11,r3,0x8
8000bcda:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000bcde:	ed be 00 1f 	bld	lr,0x1f
8000bce2:	ef bb 00 1f 	bst	r11,0x1f
8000bce6:	0c 0a       	add	r10,r6
8000bce8:	5c 0b       	acr	r11
8000bcea:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000bcee:	e4 1b 00 0f 	andh	r11,0xf
8000bcf2:	14 4b       	or	r11,r10
8000bcf4:	e0 81 00 a7 	brne	8000be42 <__avr32_f64_div_res_subnormal+0x98>
8000bcf8:	f2 06 16 14 	lsr	r6,r9,0x14
8000bcfc:	ab d6       	cbr	r6,0xb
8000bcfe:	e0 46 07 ff 	cp.w	r6,2047
8000bd02:	e0 81 00 a4 	brne	8000be4a <__avr32_f64_div_res_subnormal+0xa0>
8000bd06:	c9 e8       	rjmp	8000be42 <__avr32_f64_div_res_subnormal+0x98>
8000bd08:	e4 19 00 0f 	andh	r9,0xf
8000bd0c:	10 49       	or	r9,r8
8000bd0e:	e0 81 00 9a 	brne	8000be42 <__avr32_f64_div_res_subnormal+0x98>
8000bd12:	c9 28       	rjmp	8000be36 <__avr32_f64_div_res_subnormal+0x8c>
8000bd14:	a3 7b       	lsl	r11,0x3
8000bd16:	f7 ea 13 db 	or	r11,r11,r10>>0x1d
8000bd1a:	a3 7a       	lsl	r10,0x3
8000bd1c:	f5 eb 10 04 	or	r4,r10,r11
8000bd20:	e0 80 00 a0 	breq	8000be60 <__avr32_f64_div_op1_zero>
8000bd24:	f6 04 12 00 	clz	r4,r11
8000bd28:	c1 70       	breq	8000bd56 <__avr32_f64_div_round_subnormal+0x96>
8000bd2a:	c0 c3       	brcs	8000bd42 <__avr32_f64_div_round_subnormal+0x82>
8000bd2c:	e8 05 11 20 	rsub	r5,r4,32
8000bd30:	f6 04 09 4b 	lsl	r11,r11,r4
8000bd34:	f4 05 0a 45 	lsr	r5,r10,r5
8000bd38:	0a 4b       	or	r11,r5
8000bd3a:	f4 04 09 4a 	lsl	r10,r10,r4
8000bd3e:	08 17       	sub	r7,r4
8000bd40:	c0 b8       	rjmp	8000bd56 <__avr32_f64_div_round_subnormal+0x96>
8000bd42:	f4 04 12 00 	clz	r4,r10
8000bd46:	f9 b4 03 00 	movlo	r4,0
8000bd4a:	f7 b4 02 e0 	subhs	r4,-32
8000bd4e:	f4 04 09 4b 	lsl	r11,r10,r4
8000bd52:	30 0a       	mov	r10,0
8000bd54:	08 17       	sub	r7,r4
8000bd56:	a3 8a       	lsr	r10,0x2
8000bd58:	f5 eb 11 ea 	or	r10,r10,r11<<0x1e
8000bd5c:	a3 8b       	lsr	r11,0x2
8000bd5e:	c1 1b       	rjmp	8000bb80 <__avr32_f64_div+0x20>
8000bd60:	a3 79       	lsl	r9,0x3
8000bd62:	f3 e8 13 d9 	or	r9,r9,r8>>0x1d
8000bd66:	a3 78       	lsl	r8,0x3
8000bd68:	f3 e8 10 04 	or	r4,r9,r8
8000bd6c:	c6 f0       	breq	8000be4a <__avr32_f64_div_res_subnormal+0xa0>
8000bd6e:	f2 04 12 00 	clz	r4,r9
8000bd72:	c1 70       	breq	8000bda0 <__avr32_f64_div_round_subnormal+0xe0>
8000bd74:	c0 c3       	brcs	8000bd8c <__avr32_f64_div_round_subnormal+0xcc>
8000bd76:	e8 05 11 20 	rsub	r5,r4,32
8000bd7a:	f2 04 09 49 	lsl	r9,r9,r4
8000bd7e:	f0 05 0a 45 	lsr	r5,r8,r5
8000bd82:	0a 49       	or	r9,r5
8000bd84:	f0 04 09 48 	lsl	r8,r8,r4
8000bd88:	08 16       	sub	r6,r4
8000bd8a:	c0 b8       	rjmp	8000bda0 <__avr32_f64_div_round_subnormal+0xe0>
8000bd8c:	f0 04 12 00 	clz	r4,r8
8000bd90:	f9 b4 03 00 	movlo	r4,0
8000bd94:	f7 b4 02 e0 	subhs	r4,-32
8000bd98:	f0 04 09 49 	lsl	r9,r8,r4
8000bd9c:	30 08       	mov	r8,0
8000bd9e:	08 16       	sub	r6,r4
8000bda0:	a3 88       	lsr	r8,0x2
8000bda2:	f1 e9 11 e8 	or	r8,r8,r9<<0x1e
8000bda6:	a3 89       	lsr	r9,0x2
8000bda8:	cf ca       	rjmp	8000bba0 <__avr32_f64_div+0x40>

8000bdaa <__avr32_f64_div_res_subnormal>:
8000bdaa:	5c 37       	neg	r7
8000bdac:	2f f7       	sub	r7,-1
8000bdae:	f1 b7 04 c0 	satu	r7,0x6
8000bdb2:	e0 47 00 20 	cp.w	r7,32
8000bdb6:	c1 54       	brge	8000bde0 <__avr32_f64_div_res_subnormal+0x36>
8000bdb8:	ee 06 11 20 	rsub	r6,r7,32
8000bdbc:	e4 07 0a 42 	lsr	r2,r2,r7
8000bdc0:	e6 06 09 4c 	lsl	r12,r3,r6
8000bdc4:	18 42       	or	r2,r12
8000bdc6:	e6 07 0a 43 	lsr	r3,r3,r7
8000bdca:	f4 06 09 41 	lsl	r1,r10,r6
8000bdce:	f4 07 0a 4a 	lsr	r10,r10,r7
8000bdd2:	f6 06 09 4c 	lsl	r12,r11,r6
8000bdd6:	18 4a       	or	r10,r12
8000bdd8:	f6 07 0a 4b 	lsr	r11,r11,r7
8000bddc:	30 00       	mov	r0,0
8000bdde:	c1 58       	rjmp	8000be08 <__avr32_f64_div_res_subnormal+0x5e>
8000bde0:	ee 06 11 20 	rsub	r6,r7,32
8000bde4:	f9 b0 00 00 	moveq	r0,0
8000bde8:	f9 bc 00 00 	moveq	r12,0
8000bdec:	c0 50       	breq	8000bdf6 <__avr32_f64_div_res_subnormal+0x4c>
8000bdee:	f4 06 09 40 	lsl	r0,r10,r6
8000bdf2:	f6 06 09 4c 	lsl	r12,r11,r6
8000bdf6:	e6 07 0a 42 	lsr	r2,r3,r7
8000bdfa:	30 03       	mov	r3,0
8000bdfc:	f4 07 0a 41 	lsr	r1,r10,r7
8000be00:	18 41       	or	r1,r12
8000be02:	f6 07 0a 4a 	lsr	r10,r11,r7
8000be06:	30 0b       	mov	r11,0
8000be08:	e0 12 ff 00 	andl	r2,0xff00
8000be0c:	e8 12 00 80 	orl	r2,0x80
8000be10:	e6 08 06 46 	mulu.d	r6,r3,r8
8000be14:	e4 09 07 46 	macu.d	r6,r2,r9
8000be18:	e4 08 06 44 	mulu.d	r4,r2,r8
8000be1c:	e6 09 06 48 	mulu.d	r8,r3,r9
8000be20:	0c 05       	add	r5,r6
8000be22:	f0 07 00 48 	adc	r8,r8,r7
8000be26:	5c 09       	acr	r9
8000be28:	30 07       	mov	r7,0
8000be2a:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000be2e:	00 34       	cp.w	r4,r0
8000be30:	e2 05 13 00 	cpc	r5,r1
8000be34:	c4 6b       	rjmp	8000bcc0 <__avr32_f64_div_round_subnormal>
8000be36:	1c 9b       	mov	r11,lr
8000be38:	e6 1b 80 00 	andh	r11,0x8000,COH
8000be3c:	30 0a       	mov	r10,0
8000be3e:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000be42:	3f fb       	mov	r11,-1
8000be44:	30 0a       	mov	r10,0
8000be46:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000be4a:	f5 eb 10 04 	or	r4,r10,r11
8000be4e:	c0 90       	breq	8000be60 <__avr32_f64_div_op1_zero>
8000be50:	1c 9b       	mov	r11,lr
8000be52:	e6 1b 80 00 	andh	r11,0x8000,COH
8000be56:	ea 1b 7f f0 	orh	r11,0x7ff0
8000be5a:	30 0a       	mov	r10,0
8000be5c:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc

8000be60 <__avr32_f64_div_op1_zero>:
8000be60:	f1 e9 10 15 	or	r5,r8,r9<<0x1
8000be64:	ce f0       	breq	8000be42 <__avr32_f64_div_res_subnormal+0x98>
8000be66:	e9 d9 c2 8b 	bfextu	r4,r9,0x14,0xb
8000be6a:	e0 44 07 ff 	cp.w	r4,2047
8000be6e:	ce 41       	brne	8000be36 <__avr32_f64_div_res_subnormal+0x8c>
8000be70:	f1 e9 10 c5 	or	r5,r8,r9<<0xc
8000be74:	ce 10       	breq	8000be36 <__avr32_f64_div_res_subnormal+0x8c>
8000be76:	ce 6b       	rjmp	8000be42 <__avr32_f64_div_res_subnormal+0x98>

8000be78 <__avr32_udiv64>:
8000be78:	d4 31       	pushm	r0-r7,lr
8000be7a:	1a 97       	mov	r7,sp
8000be7c:	20 3d       	sub	sp,12
8000be7e:	10 9c       	mov	r12,r8
8000be80:	12 9e       	mov	lr,r9
8000be82:	14 93       	mov	r3,r10
8000be84:	58 09       	cp.w	r9,0
8000be86:	e0 81 00 bd 	brne	8000c000 <__avr32_udiv64+0x188>
8000be8a:	16 38       	cp.w	r8,r11
8000be8c:	e0 88 00 40 	brls	8000bf0c <__avr32_udiv64+0x94>
8000be90:	f0 08 12 00 	clz	r8,r8
8000be94:	c0 d0       	breq	8000beae <__avr32_udiv64+0x36>
8000be96:	f6 08 09 4b 	lsl	r11,r11,r8
8000be9a:	f0 09 11 20 	rsub	r9,r8,32
8000be9e:	f8 08 09 4c 	lsl	r12,r12,r8
8000bea2:	f4 09 0a 49 	lsr	r9,r10,r9
8000bea6:	f4 08 09 43 	lsl	r3,r10,r8
8000beaa:	f3 eb 10 0b 	or	r11,r9,r11
8000beae:	f8 0e 16 10 	lsr	lr,r12,0x10
8000beb2:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000beb6:	f6 0e 0d 00 	divu	r0,r11,lr
8000beba:	e6 0b 16 10 	lsr	r11,r3,0x10
8000bebe:	00 99       	mov	r9,r0
8000bec0:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000bec4:	e0 0a 02 48 	mul	r8,r0,r10
8000bec8:	10 3b       	cp.w	r11,r8
8000beca:	c0 a2       	brcc	8000bede <__avr32_udiv64+0x66>
8000becc:	20 19       	sub	r9,1
8000bece:	18 0b       	add	r11,r12
8000bed0:	18 3b       	cp.w	r11,r12
8000bed2:	c0 63       	brcs	8000bede <__avr32_udiv64+0x66>
8000bed4:	10 3b       	cp.w	r11,r8
8000bed6:	f7 b9 03 01 	sublo	r9,1
8000beda:	f7 dc e3 0b 	addcs	r11,r11,r12
8000bede:	f6 08 01 01 	sub	r1,r11,r8
8000bee2:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000bee6:	e2 0e 0d 00 	divu	r0,r1,lr
8000beea:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000beee:	00 98       	mov	r8,r0
8000bef0:	e0 0a 02 4a 	mul	r10,r0,r10
8000bef4:	14 33       	cp.w	r3,r10
8000bef6:	c0 82       	brcc	8000bf06 <__avr32_udiv64+0x8e>
8000bef8:	20 18       	sub	r8,1
8000befa:	18 03       	add	r3,r12
8000befc:	18 33       	cp.w	r3,r12
8000befe:	c0 43       	brcs	8000bf06 <__avr32_udiv64+0x8e>
8000bf00:	14 33       	cp.w	r3,r10
8000bf02:	f7 b8 03 01 	sublo	r8,1
8000bf06:	f1 e9 11 08 	or	r8,r8,r9<<0x10
8000bf0a:	cd f8       	rjmp	8000c0c8 <__avr32_udiv64+0x250>
8000bf0c:	58 08       	cp.w	r8,0
8000bf0e:	c0 51       	brne	8000bf18 <__avr32_udiv64+0xa0>
8000bf10:	30 19       	mov	r9,1
8000bf12:	f2 08 0d 08 	divu	r8,r9,r8
8000bf16:	10 9c       	mov	r12,r8
8000bf18:	f8 06 12 00 	clz	r6,r12
8000bf1c:	c0 41       	brne	8000bf24 <__avr32_udiv64+0xac>
8000bf1e:	18 1b       	sub	r11,r12
8000bf20:	30 19       	mov	r9,1
8000bf22:	c4 08       	rjmp	8000bfa2 <__avr32_udiv64+0x12a>
8000bf24:	ec 01 11 20 	rsub	r1,r6,32
8000bf28:	f4 01 0a 49 	lsr	r9,r10,r1
8000bf2c:	f8 06 09 4c 	lsl	r12,r12,r6
8000bf30:	f6 06 09 48 	lsl	r8,r11,r6
8000bf34:	f6 01 0a 41 	lsr	r1,r11,r1
8000bf38:	f3 e8 10 08 	or	r8,r9,r8
8000bf3c:	f8 03 16 10 	lsr	r3,r12,0x10
8000bf40:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000bf44:	e2 03 0d 00 	divu	r0,r1,r3
8000bf48:	f0 0b 16 10 	lsr	r11,r8,0x10
8000bf4c:	00 9e       	mov	lr,r0
8000bf4e:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000bf52:	e0 05 02 49 	mul	r9,r0,r5
8000bf56:	12 3b       	cp.w	r11,r9
8000bf58:	c0 a2       	brcc	8000bf6c <__avr32_udiv64+0xf4>
8000bf5a:	20 1e       	sub	lr,1
8000bf5c:	18 0b       	add	r11,r12
8000bf5e:	18 3b       	cp.w	r11,r12
8000bf60:	c0 63       	brcs	8000bf6c <__avr32_udiv64+0xf4>
8000bf62:	12 3b       	cp.w	r11,r9
8000bf64:	f7 be 03 01 	sublo	lr,1
8000bf68:	f7 dc e3 0b 	addcs	r11,r11,r12
8000bf6c:	12 1b       	sub	r11,r9
8000bf6e:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
8000bf72:	f6 03 0d 02 	divu	r2,r11,r3
8000bf76:	f1 e3 11 08 	or	r8,r8,r3<<0x10
8000bf7a:	04 99       	mov	r9,r2
8000bf7c:	e4 05 02 4b 	mul	r11,r2,r5
8000bf80:	16 38       	cp.w	r8,r11
8000bf82:	c0 a2       	brcc	8000bf96 <__avr32_udiv64+0x11e>
8000bf84:	20 19       	sub	r9,1
8000bf86:	18 08       	add	r8,r12
8000bf88:	18 38       	cp.w	r8,r12
8000bf8a:	c0 63       	brcs	8000bf96 <__avr32_udiv64+0x11e>
8000bf8c:	16 38       	cp.w	r8,r11
8000bf8e:	f7 b9 03 01 	sublo	r9,1
8000bf92:	f1 dc e3 08 	addcs	r8,r8,r12
8000bf96:	f4 06 09 43 	lsl	r3,r10,r6
8000bf9a:	f0 0b 01 0b 	sub	r11,r8,r11
8000bf9e:	f3 ee 11 09 	or	r9,r9,lr<<0x10
8000bfa2:	f8 06 16 10 	lsr	r6,r12,0x10
8000bfa6:	fd dc c0 10 	bfextu	lr,r12,0x0,0x10
8000bfaa:	f6 06 0d 00 	divu	r0,r11,r6
8000bfae:	e6 0b 16 10 	lsr	r11,r3,0x10
8000bfb2:	00 9a       	mov	r10,r0
8000bfb4:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000bfb8:	e0 0e 02 48 	mul	r8,r0,lr
8000bfbc:	10 3b       	cp.w	r11,r8
8000bfbe:	c0 a2       	brcc	8000bfd2 <__avr32_udiv64+0x15a>
8000bfc0:	20 1a       	sub	r10,1
8000bfc2:	18 0b       	add	r11,r12
8000bfc4:	18 3b       	cp.w	r11,r12
8000bfc6:	c0 63       	brcs	8000bfd2 <__avr32_udiv64+0x15a>
8000bfc8:	10 3b       	cp.w	r11,r8
8000bfca:	f7 ba 03 01 	sublo	r10,1
8000bfce:	f7 dc e3 0b 	addcs	r11,r11,r12
8000bfd2:	f6 08 01 01 	sub	r1,r11,r8
8000bfd6:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000bfda:	e2 06 0d 00 	divu	r0,r1,r6
8000bfde:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000bfe2:	00 98       	mov	r8,r0
8000bfe4:	e0 0e 02 4b 	mul	r11,r0,lr
8000bfe8:	16 33       	cp.w	r3,r11
8000bfea:	c0 82       	brcc	8000bffa <__avr32_udiv64+0x182>
8000bfec:	20 18       	sub	r8,1
8000bfee:	18 03       	add	r3,r12
8000bff0:	18 33       	cp.w	r3,r12
8000bff2:	c0 43       	brcs	8000bffa <__avr32_udiv64+0x182>
8000bff4:	16 33       	cp.w	r3,r11
8000bff6:	f7 b8 03 01 	sublo	r8,1
8000bffa:	f1 ea 11 08 	or	r8,r8,r10<<0x10
8000bffe:	c6 98       	rjmp	8000c0d0 <__avr32_udiv64+0x258>
8000c000:	16 39       	cp.w	r9,r11
8000c002:	e0 8b 00 65 	brhi	8000c0cc <__avr32_udiv64+0x254>
8000c006:	f2 09 12 00 	clz	r9,r9
8000c00a:	c0 b1       	brne	8000c020 <__avr32_udiv64+0x1a8>
8000c00c:	10 3a       	cp.w	r10,r8
8000c00e:	5f 2a       	srhs	r10
8000c010:	1c 3b       	cp.w	r11,lr
8000c012:	5f b8       	srhi	r8
8000c014:	10 4a       	or	r10,r8
8000c016:	f2 0a 18 00 	cp.b	r10,r9
8000c01a:	c5 90       	breq	8000c0cc <__avr32_udiv64+0x254>
8000c01c:	30 18       	mov	r8,1
8000c01e:	c5 98       	rjmp	8000c0d0 <__avr32_udiv64+0x258>
8000c020:	f0 09 09 46 	lsl	r6,r8,r9
8000c024:	f2 03 11 20 	rsub	r3,r9,32
8000c028:	fc 09 09 4e 	lsl	lr,lr,r9
8000c02c:	f0 03 0a 48 	lsr	r8,r8,r3
8000c030:	f6 09 09 4c 	lsl	r12,r11,r9
8000c034:	f4 03 0a 42 	lsr	r2,r10,r3
8000c038:	ef 46 ff f4 	st.w	r7[-12],r6
8000c03c:	f6 03 0a 43 	lsr	r3,r11,r3
8000c040:	18 42       	or	r2,r12
8000c042:	f1 ee 10 0c 	or	r12,r8,lr
8000c046:	f8 01 16 10 	lsr	r1,r12,0x10
8000c04a:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000c04e:	e6 01 0d 04 	divu	r4,r3,r1
8000c052:	e4 03 16 10 	lsr	r3,r2,0x10
8000c056:	08 9e       	mov	lr,r4
8000c058:	e7 e5 11 03 	or	r3,r3,r5<<0x10
8000c05c:	e8 06 02 48 	mul	r8,r4,r6
8000c060:	10 33       	cp.w	r3,r8
8000c062:	c0 a2       	brcc	8000c076 <__avr32_udiv64+0x1fe>
8000c064:	20 1e       	sub	lr,1
8000c066:	18 03       	add	r3,r12
8000c068:	18 33       	cp.w	r3,r12
8000c06a:	c0 63       	brcs	8000c076 <__avr32_udiv64+0x1fe>
8000c06c:	10 33       	cp.w	r3,r8
8000c06e:	f7 be 03 01 	sublo	lr,1
8000c072:	e7 dc e3 03 	addcs	r3,r3,r12
8000c076:	10 13       	sub	r3,r8
8000c078:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
8000c07c:	e6 01 0d 00 	divu	r0,r3,r1
8000c080:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c084:	00 98       	mov	r8,r0
8000c086:	e0 06 02 46 	mul	r6,r0,r6
8000c08a:	0c 3b       	cp.w	r11,r6
8000c08c:	c0 a2       	brcc	8000c0a0 <__avr32_udiv64+0x228>
8000c08e:	20 18       	sub	r8,1
8000c090:	18 0b       	add	r11,r12
8000c092:	18 3b       	cp.w	r11,r12
8000c094:	c0 63       	brcs	8000c0a0 <__avr32_udiv64+0x228>
8000c096:	0c 3b       	cp.w	r11,r6
8000c098:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c09c:	f7 b8 03 01 	sublo	r8,1
8000c0a0:	f1 ee 11 08 	or	r8,r8,lr<<0x10
8000c0a4:	ee f4 ff f4 	ld.w	r4,r7[-12]
8000c0a8:	0c 1b       	sub	r11,r6
8000c0aa:	f0 04 06 42 	mulu.d	r2,r8,r4
8000c0ae:	06 95       	mov	r5,r3
8000c0b0:	16 35       	cp.w	r5,r11
8000c0b2:	e0 8b 00 0a 	brhi	8000c0c6 <__avr32_udiv64+0x24e>
8000c0b6:	5f 0b       	sreq	r11
8000c0b8:	f4 09 09 49 	lsl	r9,r10,r9
8000c0bc:	12 32       	cp.w	r2,r9
8000c0be:	5f b9       	srhi	r9
8000c0c0:	f7 e9 00 09 	and	r9,r11,r9
8000c0c4:	c0 60       	breq	8000c0d0 <__avr32_udiv64+0x258>
8000c0c6:	20 18       	sub	r8,1
8000c0c8:	30 09       	mov	r9,0
8000c0ca:	c0 38       	rjmp	8000c0d0 <__avr32_udiv64+0x258>
8000c0cc:	30 09       	mov	r9,0
8000c0ce:	12 98       	mov	r8,r9
8000c0d0:	10 9a       	mov	r10,r8
8000c0d2:	12 93       	mov	r3,r9
8000c0d4:	10 92       	mov	r2,r8
8000c0d6:	12 9b       	mov	r11,r9
8000c0d8:	2f dd       	sub	sp,-12
8000c0da:	d8 32       	popm	r0-r7,pc

8000c0dc <__avr32_umod64>:
8000c0dc:	d4 31       	pushm	r0-r7,lr
8000c0de:	1a 97       	mov	r7,sp
8000c0e0:	20 3d       	sub	sp,12
8000c0e2:	10 9c       	mov	r12,r8
8000c0e4:	12 95       	mov	r5,r9
8000c0e6:	14 9e       	mov	lr,r10
8000c0e8:	16 91       	mov	r1,r11
8000c0ea:	16 96       	mov	r6,r11
8000c0ec:	58 09       	cp.w	r9,0
8000c0ee:	e0 81 00 81 	brne	8000c1f0 <__avr32_umod64+0x114>
8000c0f2:	16 38       	cp.w	r8,r11
8000c0f4:	e0 88 00 12 	brls	8000c118 <__avr32_umod64+0x3c>
8000c0f8:	f0 08 12 00 	clz	r8,r8
8000c0fc:	c4 e0       	breq	8000c198 <__avr32_umod64+0xbc>
8000c0fe:	f6 08 09 46 	lsl	r6,r11,r8
8000c102:	f8 08 09 4c 	lsl	r12,r12,r8
8000c106:	f0 0b 11 20 	rsub	r11,r8,32
8000c10a:	f4 08 09 4e 	lsl	lr,r10,r8
8000c10e:	f4 0b 0a 4b 	lsr	r11,r10,r11
8000c112:	f7 e6 10 06 	or	r6,r11,r6
8000c116:	c4 18       	rjmp	8000c198 <__avr32_umod64+0xbc>
8000c118:	58 08       	cp.w	r8,0
8000c11a:	c0 51       	brne	8000c124 <__avr32_umod64+0x48>
8000c11c:	30 19       	mov	r9,1
8000c11e:	f2 08 0d 08 	divu	r8,r9,r8
8000c122:	10 9c       	mov	r12,r8
8000c124:	f8 08 12 00 	clz	r8,r12
8000c128:	c0 31       	brne	8000c12e <__avr32_umod64+0x52>
8000c12a:	18 16       	sub	r6,r12
8000c12c:	c3 68       	rjmp	8000c198 <__avr32_umod64+0xbc>
8000c12e:	f0 03 11 20 	rsub	r3,r8,32
8000c132:	f4 03 0a 4b 	lsr	r11,r10,r3
8000c136:	f8 08 09 4c 	lsl	r12,r12,r8
8000c13a:	ec 08 09 49 	lsl	r9,r6,r8
8000c13e:	ec 03 0a 43 	lsr	r3,r6,r3
8000c142:	f7 e9 10 09 	or	r9,r11,r9
8000c146:	f8 05 16 10 	lsr	r5,r12,0x10
8000c14a:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000c14e:	e6 05 0d 02 	divu	r2,r3,r5
8000c152:	f2 0e 16 10 	lsr	lr,r9,0x10
8000c156:	ec 02 02 4b 	mul	r11,r6,r2
8000c15a:	fd e3 11 0e 	or	lr,lr,r3<<0x10
8000c15e:	16 3e       	cp.w	lr,r11
8000c160:	c0 72       	brcc	8000c16e <__avr32_umod64+0x92>
8000c162:	18 0e       	add	lr,r12
8000c164:	18 3e       	cp.w	lr,r12
8000c166:	c0 43       	brcs	8000c16e <__avr32_umod64+0x92>
8000c168:	16 3e       	cp.w	lr,r11
8000c16a:	fd dc e3 0e 	addcs	lr,lr,r12
8000c16e:	fc 0b 01 03 	sub	r3,lr,r11
8000c172:	f3 d9 c0 10 	bfextu	r9,r9,0x0,0x10
8000c176:	e6 05 0d 02 	divu	r2,r3,r5
8000c17a:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000c17e:	a5 36       	mul	r6,r2
8000c180:	0c 39       	cp.w	r9,r6
8000c182:	c0 72       	brcc	8000c190 <__avr32_umod64+0xb4>
8000c184:	18 09       	add	r9,r12
8000c186:	18 39       	cp.w	r9,r12
8000c188:	c0 43       	brcs	8000c190 <__avr32_umod64+0xb4>
8000c18a:	0c 39       	cp.w	r9,r6
8000c18c:	f3 dc e3 09 	addcs	r9,r9,r12
8000c190:	f2 06 01 06 	sub	r6,r9,r6
8000c194:	f4 08 09 4e 	lsl	lr,r10,r8
8000c198:	f8 0a 16 10 	lsr	r10,r12,0x10
8000c19c:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000c1a0:	ec 0a 0d 02 	divu	r2,r6,r10
8000c1a4:	fc 09 16 10 	lsr	r9,lr,0x10
8000c1a8:	ea 02 02 4b 	mul	r11,r5,r2
8000c1ac:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000c1b0:	16 39       	cp.w	r9,r11
8000c1b2:	c0 72       	brcc	8000c1c0 <__avr32_umod64+0xe4>
8000c1b4:	18 09       	add	r9,r12
8000c1b6:	18 39       	cp.w	r9,r12
8000c1b8:	c0 43       	brcs	8000c1c0 <__avr32_umod64+0xe4>
8000c1ba:	16 39       	cp.w	r9,r11
8000c1bc:	f3 dc e3 09 	addcs	r9,r9,r12
8000c1c0:	f2 0b 01 0b 	sub	r11,r9,r11
8000c1c4:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000c1c8:	f6 0a 0d 0a 	divu	r10,r11,r10
8000c1cc:	fd eb 11 0e 	or	lr,lr,r11<<0x10
8000c1d0:	ea 0a 02 4a 	mul	r10,r5,r10
8000c1d4:	14 3e       	cp.w	lr,r10
8000c1d6:	c0 72       	brcc	8000c1e4 <__avr32_umod64+0x108>
8000c1d8:	18 0e       	add	lr,r12
8000c1da:	18 3e       	cp.w	lr,r12
8000c1dc:	c0 43       	brcs	8000c1e4 <__avr32_umod64+0x108>
8000c1de:	14 3e       	cp.w	lr,r10
8000c1e0:	fd dc e3 0e 	addcs	lr,lr,r12
8000c1e4:	fc 0a 01 0a 	sub	r10,lr,r10
8000c1e8:	30 0b       	mov	r11,0
8000c1ea:	f4 08 0a 4a 	lsr	r10,r10,r8
8000c1ee:	c7 b8       	rjmp	8000c2e4 <__avr32_umod64+0x208>
8000c1f0:	16 39       	cp.w	r9,r11
8000c1f2:	e0 8b 00 79 	brhi	8000c2e4 <__avr32_umod64+0x208>
8000c1f6:	f2 09 12 00 	clz	r9,r9
8000c1fa:	c1 21       	brne	8000c21e <__avr32_umod64+0x142>
8000c1fc:	10 3a       	cp.w	r10,r8
8000c1fe:	5f 2b       	srhs	r11
8000c200:	0a 31       	cp.w	r1,r5
8000c202:	5f ba       	srhi	r10
8000c204:	f7 ea 10 0a 	or	r10,r11,r10
8000c208:	f2 0a 18 00 	cp.b	r10,r9
8000c20c:	c0 60       	breq	8000c218 <__avr32_umod64+0x13c>
8000c20e:	fc 08 01 0c 	sub	r12,lr,r8
8000c212:	e2 05 01 46 	sbc	r6,r1,r5
8000c216:	18 9e       	mov	lr,r12
8000c218:	0c 9b       	mov	r11,r6
8000c21a:	1c 9a       	mov	r10,lr
8000c21c:	c6 48       	rjmp	8000c2e4 <__avr32_umod64+0x208>
8000c21e:	ea 09 09 4c 	lsl	r12,r5,r9
8000c222:	f2 06 11 20 	rsub	r6,r9,32
8000c226:	f6 09 09 4b 	lsl	r11,r11,r9
8000c22a:	f0 09 09 42 	lsl	r2,r8,r9
8000c22e:	ef 46 ff f4 	st.w	r7[-12],r6
8000c232:	f0 06 0a 48 	lsr	r8,r8,r6
8000c236:	18 48       	or	r8,r12
8000c238:	e2 06 0a 4c 	lsr	r12,r1,r6
8000c23c:	f4 09 09 43 	lsl	r3,r10,r9
8000c240:	fd d8 c0 10 	bfextu	lr,r8,0x0,0x10
8000c244:	f4 06 0a 4a 	lsr	r10,r10,r6
8000c248:	16 4a       	or	r10,r11
8000c24a:	f0 0b 16 10 	lsr	r11,r8,0x10
8000c24e:	f8 0b 0d 04 	divu	r4,r12,r11
8000c252:	f4 0c 16 10 	lsr	r12,r10,0x10
8000c256:	08 91       	mov	r1,r4
8000c258:	f9 e5 11 0c 	or	r12,r12,r5<<0x10
8000c25c:	e8 0e 02 46 	mul	r6,r4,lr
8000c260:	0c 3c       	cp.w	r12,r6
8000c262:	c0 a2       	brcc	8000c276 <__avr32_umod64+0x19a>
8000c264:	20 11       	sub	r1,1
8000c266:	10 0c       	add	r12,r8
8000c268:	10 3c       	cp.w	r12,r8
8000c26a:	c0 63       	brcs	8000c276 <__avr32_umod64+0x19a>
8000c26c:	0c 3c       	cp.w	r12,r6
8000c26e:	f7 b1 03 01 	sublo	r1,1
8000c272:	f9 d8 e3 0c 	addcs	r12,r12,r8
8000c276:	0c 1c       	sub	r12,r6
8000c278:	f5 da c0 10 	bfextu	r10,r10,0x0,0x10
8000c27c:	f8 0b 0d 04 	divu	r4,r12,r11
8000c280:	f5 e5 11 0b 	or	r11,r10,r5<<0x10
8000c284:	08 96       	mov	r6,r4
8000c286:	e8 0e 02 4e 	mul	lr,r4,lr
8000c28a:	1c 3b       	cp.w	r11,lr
8000c28c:	c0 a2       	brcc	8000c2a0 <__avr32_umod64+0x1c4>
8000c28e:	20 16       	sub	r6,1
8000c290:	10 0b       	add	r11,r8
8000c292:	10 3b       	cp.w	r11,r8
8000c294:	c0 63       	brcs	8000c2a0 <__avr32_umod64+0x1c4>
8000c296:	1c 3b       	cp.w	r11,lr
8000c298:	f7 b6 03 01 	sublo	r6,1
8000c29c:	f7 d8 e3 0b 	addcs	r11,r11,r8
8000c2a0:	ed e1 11 01 	or	r1,r6,r1<<0x10
8000c2a4:	1c 1b       	sub	r11,lr
8000c2a6:	e2 02 06 40 	mulu.d	r0,r1,r2
8000c2aa:	00 9e       	mov	lr,r0
8000c2ac:	02 9c       	mov	r12,r1
8000c2ae:	16 3c       	cp.w	r12,r11
8000c2b0:	e0 8b 00 08 	brhi	8000c2c0 <__avr32_umod64+0x1e4>
8000c2b4:	5f 06       	sreq	r6
8000c2b6:	06 30       	cp.w	r0,r3
8000c2b8:	5f ba       	srhi	r10
8000c2ba:	ed ea 00 0a 	and	r10,r6,r10
8000c2be:	c0 60       	breq	8000c2ca <__avr32_umod64+0x1ee>
8000c2c0:	fc 02 01 04 	sub	r4,lr,r2
8000c2c4:	f8 08 01 4c 	sbc	r12,r12,r8
8000c2c8:	08 9e       	mov	lr,r4
8000c2ca:	e6 0e 01 0a 	sub	r10,r3,lr
8000c2ce:	f6 0c 01 4c 	sbc	r12,r11,r12
8000c2d2:	ee f1 ff f4 	ld.w	r1,r7[-12]
8000c2d6:	f8 09 0a 4b 	lsr	r11,r12,r9
8000c2da:	f4 09 0a 4a 	lsr	r10,r10,r9
8000c2de:	f8 01 09 4c 	lsl	r12,r12,r1
8000c2e2:	18 4a       	or	r10,r12
8000c2e4:	2f dd       	sub	sp,-12
8000c2e6:	d8 32       	popm	r0-r7,pc

Disassembly of section .exception:

8000c400 <_evba>:
_evba:

        .org  0x000
        // Unrecoverable Exception.
_handle_Unrecoverable_Exception:
        rjmp $
8000c400:	c0 08       	rjmp	8000c400 <_evba>
	...

8000c404 <_handle_TLB_Multiple_Hit>:

        .org  0x004
        // TLB Multiple Hit: UNUSED IN AVR32UC.
_handle_TLB_Multiple_Hit:
        rjmp $
8000c404:	c0 08       	rjmp	8000c404 <_handle_TLB_Multiple_Hit>
	...

8000c408 <_handle_Bus_Error_Data_Fetch>:

        .org  0x008
        // Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
        rjmp $
8000c408:	c0 08       	rjmp	8000c408 <_handle_Bus_Error_Data_Fetch>
	...

8000c40c <_handle_Bus_Error_Instruction_Fetch>:

        .org  0x00C
         // Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
        rjmp $
8000c40c:	c0 08       	rjmp	8000c40c <_handle_Bus_Error_Instruction_Fetch>
	...

8000c410 <_handle_NMI>:

        .org  0x010
        // NMI.
_handle_NMI:
        rjmp $
8000c410:	c0 08       	rjmp	8000c410 <_handle_NMI>
	...

8000c414 <_handle_Instruction_Address>:

        .org  0x014
        // Instruction Address.
_handle_Instruction_Address:
        rjmp $
8000c414:	c0 08       	rjmp	8000c414 <_handle_Instruction_Address>
	...

8000c418 <_handle_ITLB_Protection>:

        .org  0x018
        // ITLB Protection.
_handle_ITLB_Protection:
        rjmp $
8000c418:	c0 08       	rjmp	8000c418 <_handle_ITLB_Protection>
	...

8000c41c <_handle_Breakpoint>:

        .org  0x01C
        // Breakpoint.
_handle_Breakpoint:
        rjmp $
8000c41c:	c0 08       	rjmp	8000c41c <_handle_Breakpoint>
	...

8000c420 <_handle_Illegal_Opcode>:

        .org  0x020
        // Illegal Opcode.
_handle_Illegal_Opcode:
        rjmp $
8000c420:	c0 08       	rjmp	8000c420 <_handle_Illegal_Opcode>
	...

8000c424 <_handle_Unimplemented_Instruction>:

        .org  0x024
        // Unimplemented Instruction.
_handle_Unimplemented_Instruction:
        rjmp $
8000c424:	c0 08       	rjmp	8000c424 <_handle_Unimplemented_Instruction>
	...

8000c428 <_handle_Privilege_Violation>:

        .org  0x028
        // Privilege Violation.
_handle_Privilege_Violation:
        rjmp $
8000c428:	c0 08       	rjmp	8000c428 <_handle_Privilege_Violation>
	...

8000c42c <_handle_Floating_Point>:

        .org  0x02C
        // Floating-Point: UNUSED IN AVR32UC.
_handle_Floating_Point:
        rjmp $
8000c42c:	c0 08       	rjmp	8000c42c <_handle_Floating_Point>
	...

8000c430 <_handle_Coprocessor_Absent>:

        .org  0x030
        // Coprocessor Absent: UNUSED IN AVR32UC.
_handle_Coprocessor_Absent:
        rjmp $
8000c430:	c0 08       	rjmp	8000c430 <_handle_Coprocessor_Absent>
	...

8000c434 <_handle_Data_Address_Read>:

        .org  0x034
        // Data Address (Read).
_handle_Data_Address_Read:
        rjmp $
8000c434:	c0 08       	rjmp	8000c434 <_handle_Data_Address_Read>
	...

8000c438 <_handle_Data_Address_Write>:

        .org  0x038
        // Data Address (Write).
_handle_Data_Address_Write:
        rjmp $
8000c438:	c0 08       	rjmp	8000c438 <_handle_Data_Address_Write>
	...

8000c43c <_handle_DTLB_Protection_Read>:

        .org  0x03C
        // DTLB Protection (Read).
_handle_DTLB_Protection_Read:
        rjmp $
8000c43c:	c0 08       	rjmp	8000c43c <_handle_DTLB_Protection_Read>
	...

8000c440 <_handle_DTLB_Protection_Write>:

        .org  0x040
        // DTLB Protection (Write).
_handle_DTLB_Protection_Write:
        rjmp $
8000c440:	c0 08       	rjmp	8000c440 <_handle_DTLB_Protection_Write>
	...

8000c444 <_handle_DTLB_Modified>:

        .org  0x044
        // DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
        rjmp $
8000c444:	c0 08       	rjmp	8000c444 <_handle_DTLB_Modified>
	...

8000c450 <_handle_ITLB_Miss>:

        .org  0x050
        // ITLB Miss: UNUSED IN AVR32UC.
_handle_ITLB_Miss:
        rjmp $
8000c450:	c0 08       	rjmp	8000c450 <_handle_ITLB_Miss>
	...

8000c460 <_handle_DTLB_Miss_Read>:

        .org  0x060
        // DTLB Miss (Read): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Read:
        rjmp $
8000c460:	c0 08       	rjmp	8000c460 <_handle_DTLB_Miss_Read>
	...

8000c470 <_handle_DTLB_Miss_Write>:

        .org  0x070
        // DTLB Miss (Write): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Write:
        rjmp $
8000c470:	c0 08       	rjmp	8000c470 <_handle_DTLB_Miss_Write>
	...

8000c500 <_handle_Supervisor_Call>:

        .org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
8000c500:	fe cf 71 4c 	sub	pc,pc,29004

8000c504 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
8000c504:	30 0c       	mov	r12,0
8000c506:	fe b0 c3 cb 	rcall	80004c9c <_get_interrupt_handler>
8000c50a:	58 0c       	cp.w	r12,0
8000c50c:	f8 0f 17 10 	movne	pc,r12
8000c510:	d6 03       	rete

8000c512 <_int1>:
8000c512:	30 1c       	mov	r12,1
8000c514:	fe b0 c3 c4 	rcall	80004c9c <_get_interrupt_handler>
8000c518:	58 0c       	cp.w	r12,0
8000c51a:	f8 0f 17 10 	movne	pc,r12
8000c51e:	d6 03       	rete

8000c520 <_int2>:
8000c520:	30 2c       	mov	r12,2
8000c522:	fe b0 c3 bd 	rcall	80004c9c <_get_interrupt_handler>
8000c526:	58 0c       	cp.w	r12,0
8000c528:	f8 0f 17 10 	movne	pc,r12
8000c52c:	d6 03       	rete

8000c52e <_int3>:
8000c52e:	30 3c       	mov	r12,3
8000c530:	fe b0 c3 b6 	rcall	80004c9c <_get_interrupt_handler>
8000c534:	58 0c       	cp.w	r12,0
8000c536:	f8 0f 17 10 	movne	pc,r12
8000c53a:	d6 03       	rete

8000c53c <ipr_val>:
8000c53c:	00 00 01 04 40 00 01 12 80 00 01 20 c0 00 01 2e     ....@...... ....
8000c54c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c55c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c56c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c57c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c58c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c59c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c5ac:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c5bc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c5cc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c5dc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c5ec:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c5fc:	d7 03 d7 03                                         ....
