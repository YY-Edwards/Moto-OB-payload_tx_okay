
moto_gob_prj.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002008  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80002008  80002008  00002408  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         0000a65c  80002008  80002008  00002408  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  8000c800  8000c800  0000cc00  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       00009680  8000ca00  8000ca00  0000ce00  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .dalign       00000004  00000004  00000004  00000000  2**0
                  ALLOC
  6 .data         00000a38  00000008  80016080  00016808  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .bss          000048a8  00000a40  00000a40  00000000  2**2
                  ALLOC
  8 .heap         00011d18  000052e8  000052e8  00000000  2**0
                  ALLOC
  9 .comment      00000030  00000000  00000000  00017240  2**0
                  CONTENTS, READONLY
 10 .debug_aranges 000012b0  00000000  00000000  00017270  2**3
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_pubnames 000026ef  00000000  00000000  00018520  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_info   00029f3d  00000000  00000000  0001ac0f  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_abbrev 00006e6a  00000000  00000000  00044b4c  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_line   0000c9fa  00000000  00000000  0004b9b6  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_frame  00003104  00000000  00000000  000583b0  2**2
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_str    000075ab  00000000  00000000  0005b4b4  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_loc    0000d574  00000000  00000000  00062a5f  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .stack        00001000  00017000  00017000  00000000  2**0
                  ALLOC
 19 .debug_ranges 00001378  00000000  00000000  0006ffd8  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_start>:

  .global _start
  .type _start, @function
_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80000000:	fe cf 93 30 	sub	pc,pc,-27856

80000004 <_trampoline>:
80000004:	e0 8f 10 00 	bral	80002004 <program_start>
	...

80002004 <program_start>:
  rjmp    program_start

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002004:	fe cf b3 34 	sub	pc,pc,-19660

Disassembly of section .text:

80002008 <DeviceManagement_brdcst_func>:
80002008:	19 a9       	ld.ub	r9,r12[0x2]
8000200a:	30 18       	mov	r8,1
		U8 temp = 0;
		temp  = xcmp->u8[1] << 8;
		temp |= xcmp->u8[2];
		//if (temp == theXNL_Ctrlr.XNL_DeviceLogicalAddress)
		{
			if (xcmp->u8[0] == 0x01)
8000200c:	f0 09 18 00 	cp.b	r9,r8
80002010:	c0 61       	brne	8000201c <DeviceManagement_brdcst_func+0x14>
			{
				bunchofrandomstatusflags |= 0x00000002;
80002012:	48 68       	lddpc	r8,80002028 <DeviceManagement_brdcst_func+0x20>
80002014:	70 09       	ld.w	r9,r8[0x0]
80002016:	a1 b9       	sbr	r9,0x1
80002018:	91 09       	st.w	r8[0x0],r9
8000201a:	5e fc       	retal	r12
			}
			else
			{
				bunchofrandomstatusflags &= 0xFFFFFFFD;
8000201c:	48 38       	lddpc	r8,80002028 <DeviceManagement_brdcst_func+0x20>
8000201e:	70 09       	ld.w	r9,r8[0x0]
80002020:	a1 d9       	cbr	r9,0x1
80002022:	91 09       	st.w	r8[0x0],r9
80002024:	5e fc       	retal	r12
80002026:	00 00       	add	r0,r0
80002028:	00 00       	add	r0,r0
8000202a:	0d 84       	ld.ub	r4,r6[0x0]

8000202c <mic_brdcst_func>:
	//log("\n\r Signal_type: %x \n\r " ,  ptr->Signaling_Type);
	//log("\n\r Mic_state: %x \n\r " ,  ptr->Mic_State);
	//log("\n\r Gain_offset: %x \n\r " ,  ptr->Gain_Offset);
			
	
}
8000202c:	5e fc       	retal	r12

8000202e <TransmitControl_brdcst_func>:
	//log("\n\r  State: %x \n\r ", ptr->State );
	//log("\n\r  State_change_reason: %x \n\r ", ptr->State_change_reason );
	//
	
	
}
8000202e:	5e fc       	retal	r12

80002030 <vApplicationIdleHook>:
}

void vApplicationIdleHook( void )
{
	/* This hook function does nothing but increment a counter. */
	ulIdleCycleCount++;
80002030:	48 38       	lddpc	r8,8000203c <vApplicationIdleHook+0xc>
80002032:	70 09       	ld.w	r9,r8[0x0]
80002034:	2f f9       	sub	r9,-1
80002036:	91 09       	st.w	r8[0x0],r9
	
}
80002038:	5e fc       	retal	r12
8000203a:	00 00       	add	r0,r0
8000203c:	00 00       	add	r0,r0
8000203e:	0a 58       	eor	r8,r5

80002040 <app_init>:
														
		
};

void app_init(void)
{	
80002040:	d4 01       	pushm	lr
	payload_init( app_payload_rx_proc , app_payload_tx_proc );	
80002042:	48 cb       	lddpc	r11,80002070 <app_init+0x30>
80002044:	48 cc       	lddpc	r12,80002074 <app_init+0x34>
80002046:	f0 1f 00 0d 	mcall	80002078 <app_init+0x38>
	xcmp_register_app_list(the_app_list);
8000204a:	48 dc       	lddpc	r12,8000207c <app_init+0x3c>
8000204c:	f0 1f 00 0d 	mcall	80002080 <app_init+0x40>
			
	static portBASE_TYPE res = 0;
	 res = xTaskCreate(
80002050:	30 09       	mov	r9,0
80002052:	1a d9       	st.w	--sp,r9
80002054:	1a d9       	st.w	--sp,r9
80002056:	1a d9       	st.w	--sp,r9
80002058:	30 18       	mov	r8,1
8000205a:	e0 6a 01 80 	mov	r10,384
8000205e:	48 ab       	lddpc	r11,80002084 <app_init+0x44>
80002060:	48 ac       	lddpc	r12,80002088 <app_init+0x48>
80002062:	f0 1f 00 0b 	mcall	8000208c <app_init+0x4c>
80002066:	48 b8       	lddpc	r8,80002090 <app_init+0x50>
80002068:	91 0c       	st.w	r8[0x0],r12
8000206a:	2f dd       	sub	sp,-12
	,  NULL
	,  1
	,  NULL );
	
	
}
8000206c:	d8 02       	popm	pc
8000206e:	00 00       	add	r0,r0
80002070:	80 00       	ld.sh	r0,r0[0x0]
80002072:	28 30       	sub	r0,-125
80002074:	80 00       	ld.sh	r0,r0[0x0]
80002076:	28 5c       	sub	r12,-123
80002078:	80 00       	ld.sh	r0,r0[0x0]
8000207a:	30 f4       	mov	r4,15
8000207c:	00 00       	add	r0,r0
8000207e:	00 08       	add	r8,r0
80002080:	80 00       	ld.sh	r0,r0[0x0]
80002082:	45 10       	lddsp	r0,sp[0x144]
80002084:	80 00       	ld.sh	r0,r0[0x0]
80002086:	ca 00       	breq	80001fc6 <_trampoline+0x1fc2>
80002088:	80 00       	ld.sh	r0,r0[0x0]
8000208a:	20 94       	sub	r4,9
8000208c:	80 00       	ld.sh	r0,r0[0x0]
8000208e:	64 10       	ld.w	r0,r2[0x4]
80002090:	00 00       	add	r0,r0
80002092:	0a 50       	eor	r0,r5

80002094 <app_cfg>:

extern  char AudioData[];
extern U32 tc_tick;

static __app_Thread_(app_cfg)
{
80002094:	d4 31       	pushm	r0-r7,lr
	static  U32 isAudioRouting = 0;
	static  portTickType xLastWakeTime;
	const portTickType xFrequency = 4000;//2s,定时问题已经修正。2s x  2000hz = 4000
	U8 Burst_ID = 0;
	
	 xLastWakeTime = xTaskGetTickCount();
80002096:	f0 1f 00 17 	mcall	800020f0 <app_cfg+0x5c>
8000209a:	49 78       	lddpc	r8,800020f4 <app_cfg+0x60>
8000209c:	91 0c       	st.w	r8[0x0],r12
		
	for(;;)
	{
		//if((++coun) % 200 ==0)
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003))//确认连接成功了，再发送请求
8000209e:	49 76       	lddpc	r6,800020f8 <app_cfg+0x64>
				{
					//xcmp_transmit_dekeycontrol();
					
				}
				
				if(isAudioRouting == 0)
800020a0:	49 74       	lddpc	r4,800020fc <app_cfg+0x68>
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_exit_enhanced_OB_mode();
					//xcmp_mute_speaker();
					//xcmp_enhanced_OB_mode();
					isAudioRouting = 4;
800020a2:	30 40       	mov	r0,4
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_mute_speaker();	
					//log("\n\r time: %d \n\r", tc_tick); 
					isAudioRouting = 3;
800020a4:	30 31       	mov	r1,3
					//xcmp_button_config();
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//log("\n\r time: %d \n\r", tc_tick);
					
					isAudioRouting = 2;
800020a6:	30 22       	mov	r2,2
					//xcmp_unmute_speaker();
					
					//is_unmute = 1;
					//xcmp_function_mic();
					
					isAudioRouting = 1;
800020a8:	30 13       	mov	r3,1
			//log("testtime:%d", now->second);
		}
		//vTaskDelay(300*2 / portTICK_RATE_MS);//延迟300ms
		//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
		
		vTaskDelayUntil( &xLastWakeTime, 2000*2 / portTICK_RATE_MS  );//精确的以2000ms为周期执行。
800020aa:	10 97       	mov	r7,r8
800020ac:	e0 65 0f a0 	mov	r5,4000
	 xLastWakeTime = xTaskGetTickCount();
		
	for(;;)
	{
		//if((++coun) % 200 ==0)
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003))//确认连接成功了，再发送请求
800020b0:	6c 08       	ld.w	r8,r6[0x0]
800020b2:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
800020b6:	58 38       	cp.w	r8,3
800020b8:	c1 71       	brne	800020e6 <app_cfg+0x52>
		{	
			//if((++coun) % 3 ==0)		
			{
				
				// xcmp_audio_route_speaker();
				xcmp_IdleTestTone();
800020ba:	f0 1f 00 12 	mcall	80002100 <app_cfg+0x6c>
				{
					//xcmp_transmit_dekeycontrol();
					
				}
				
				if(isAudioRouting == 0)
800020be:	68 08       	ld.w	r8,r4[0x0]
800020c0:	58 08       	cp.w	r8,0
800020c2:	c0 31       	brne	800020c8 <app_cfg+0x34>
					//xcmp_unmute_speaker();
					
					//is_unmute = 1;
					//xcmp_function_mic();
					
					isAudioRouting = 1;
800020c4:	89 03       	st.w	r4[0x0],r3
800020c6:	c1 08       	rjmp	800020e6 <app_cfg+0x52>
				}
				else if(isAudioRouting == 1)
800020c8:	58 18       	cp.w	r8,1
800020ca:	c0 31       	brne	800020d0 <app_cfg+0x3c>
					//xcmp_button_config();
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//log("\n\r time: %d \n\r", tc_tick);
					
					isAudioRouting = 2;
800020cc:	89 02       	st.w	r4[0x0],r2
800020ce:	c0 c8       	rjmp	800020e6 <app_cfg+0x52>
					//isAudioRouting++;
				}
				else if(isAudioRouting == 2)
800020d0:	58 28       	cp.w	r8,2
800020d2:	c0 31       	brne	800020d8 <app_cfg+0x44>
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_mute_speaker();	
					//log("\n\r time: %d \n\r", tc_tick); 
					isAudioRouting = 3;
800020d4:	89 01       	st.w	r4[0x0],r1
800020d6:	c0 88       	rjmp	800020e6 <app_cfg+0x52>
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_exit_enhanced_OB_mode();
					//xcmp_mute_speaker();
					//xcmp_enhanced_OB_mode();
					isAudioRouting = 4;
800020d8:	58 38       	cp.w	r8,3
800020da:	e9 f0 0a 00 	st.weq	r4[0x0],r0
					
				}
				else
				{
					isAudioRouting++;
800020de:	f7 b8 01 ff 	subne	r8,-1
800020e2:	e9 f8 1a 00 	st.wne	r4[0x0],r8
			//log("testtime:%d", now->second);
		}
		//vTaskDelay(300*2 / portTICK_RATE_MS);//延迟300ms
		//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
		
		vTaskDelayUntil( &xLastWakeTime, 2000*2 / portTICK_RATE_MS  );//精确的以2000ms为周期执行。
800020e6:	0a 9b       	mov	r11,r5
800020e8:	0e 9c       	mov	r12,r7
800020ea:	f0 1f 00 07 	mcall	80002104 <app_cfg+0x70>
	}
800020ee:	ce 1b       	rjmp	800020b0 <app_cfg+0x1c>
800020f0:	80 00       	ld.sh	r0,r0[0x0]
800020f2:	61 48       	ld.w	r8,r0[0x50]
800020f4:	00 00       	add	r0,r0
800020f6:	0a 48       	or	r8,r5
800020f8:	00 00       	add	r0,r0
800020fa:	0d 84       	ld.ub	r4,r6[0x0]
800020fc:	00 00       	add	r0,r0
800020fe:	0a 40       	or	r0,r5
80002100:	80 00       	ld.sh	r0,r0[0x0]
80002102:	46 10       	lddsp	r0,sp[0x184]
80002104:	80 00       	ld.sh	r0,r0[0x0]
80002106:	62 b0       	ld.w	r0,r1[0x2c]

80002108 <FD_brdcst_func>:
	
	
}

void FD_brdcst_func(xcmp_fragment_t * xcmp)
{
80002108:	d4 01       	pushm	lr
	
	
	log("\n\r Forward Data Broadcast \n\r");
8000210a:	48 3c       	lddpc	r12,80002114 <FD_brdcst_func+0xc>
8000210c:	f0 1f 00 03 	mcall	80002118 <FD_brdcst_func+0x10>
	
}
80002110:	d8 02       	popm	pc
80002112:	00 00       	add	r0,r0
80002114:	80 00       	ld.sh	r0,r0[0x0]
80002116:	ca 08       	rjmp	80002256 <ButtonConfig_brdcst_func+0x4e>
80002118:	80 00       	ld.sh	r0,r0[0x0]
8000211a:	67 d4       	ld.w	r4,r3[0x74]

8000211c <FD_reply_func>:
	
	
}

void FD_reply_func(xcmp_fragment_t * xcmp)
{
8000211c:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Reply \n\r");
8000211e:	48 3c       	lddpc	r12,80002128 <FD_reply_func+0xc>
80002120:	f0 1f 00 03 	mcall	8000212c <FD_reply_func+0x10>
	
	
}
80002124:	d8 02       	popm	pc
80002126:	00 00       	add	r0,r0
80002128:	80 00       	ld.sh	r0,r0[0x0]
8000212a:	ca 28       	rjmp	8000226e <ButtonConfig_brdcst_func+0x66>
8000212c:	80 00       	ld.sh	r0,r0[0x0]
8000212e:	67 d4       	ld.w	r4,r3[0x74]

80002130 <FD_request_func>:
}



void FD_request_func(xcmp_fragment_t * xcmp)
{
80002130:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Request \n\r");
80002132:	48 3c       	lddpc	r12,8000213c <FD_request_func+0xc>
80002134:	f0 1f 00 03 	mcall	80002140 <FD_request_func+0x10>
	
	
}
80002138:	d8 02       	popm	pc
8000213a:	00 00       	add	r0,r0
8000213c:	80 00       	ld.sh	r0,r0[0x0]
8000213e:	ca 44       	brge	80002086 <app_init+0x46>
80002140:	80 00       	ld.sh	r0,r0[0x0]
80002142:	67 d4       	ld.w	r4,r3[0x74]

80002144 <EnOB_brdcst_func>:
	
	
}

void EnOB_brdcst_func(xcmp_fragment_t * xcmp)
{
80002144:	d4 01       	pushm	lr
	
	
	log("\n\r En_OB Broadcast \n\r");
80002146:	48 3c       	lddpc	r12,80002150 <EnOB_brdcst_func+0xc>
80002148:	f0 1f 00 03 	mcall	80002154 <EnOB_brdcst_func+0x10>
}
8000214c:	d8 02       	popm	pc
8000214e:	00 00       	add	r0,r0
80002150:	80 00       	ld.sh	r0,r0[0x0]
80002152:	ca 60       	breq	8000209e <app_cfg+0xa>
80002154:	80 00       	ld.sh	r0,r0[0x0]
80002156:	67 d4       	ld.w	r4,r3[0x74]

80002158 <EnOB_reply_func>:
}



void EnOB_reply_func(xcmp_fragment_t * xcmp)
{
80002158:	eb cd 40 80 	pushm	r7,lr
8000215c:	18 97       	mov	r7,r12
		/*point to xcmp payload*/
	//En_OB_Control_reply_t *ptr = (En_OB_Control_reply_t* )xcmp->u8;
	//log("\n\r Xcmp_opcode: %x \n\r", xcmp->xcmp_opcode);
	
	if (xcmp->u8[0]== xcmp_Res_Success)
8000215e:	19 a9       	ld.ub	r9,r12[0x2]
80002160:	30 08       	mov	r8,0
80002162:	f0 09 18 00 	cp.b	r9,r8
80002166:	c1 91       	brne	80002198 <EnOB_reply_func+0x40>
	{
		if (xcmp->u8[1] == EN_OB_Enter)
80002168:	19 b8       	ld.ub	r8,r12[0x3]
8000216a:	30 19       	mov	r9,1
8000216c:	f2 08 18 00 	cp.b	r8,r9
80002170:	c0 61       	brne	8000217c <EnOB_reply_func+0x24>
		{
		
			log("\n\r En_OB_Enter OK \n\r");
80002172:	49 0c       	lddpc	r12,800021b0 <EnOB_reply_func+0x58>
80002174:	f0 1f 00 10 	mcall	800021b4 <EnOB_reply_func+0x5c>
80002178:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else if (xcmp->u8[1] == EN_OB_Exit )
8000217c:	58 08       	cp.w	r8,0
8000217e:	c0 61       	brne	8000218a <EnOB_reply_func+0x32>
		{
			log("\n\r En_OB_Exit OK \n\r");
80002180:	48 ec       	lddpc	r12,800021b8 <EnOB_reply_func+0x60>
80002182:	f0 1f 00 0d 	mcall	800021b4 <EnOB_reply_func+0x5c>
80002186:	e3 cd 80 80 	ldm	sp++,r7,pc
		}
		else
		{
			
			log("\n\r En_OB_Control: %x \n\r", xcmp->u8[1]);
8000218a:	1a d8       	st.w	--sp,r8
8000218c:	48 cc       	lddpc	r12,800021bc <EnOB_reply_func+0x64>
8000218e:	f0 1f 00 0a 	mcall	800021b4 <EnOB_reply_func+0x5c>
80002192:	2f fd       	sub	sp,-4
80002194:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r En_OB_Control error \n\r");
80002198:	48 ac       	lddpc	r12,800021c0 <EnOB_reply_func+0x68>
8000219a:	f0 1f 00 07 	mcall	800021b4 <EnOB_reply_func+0x5c>
		log("\n\r En_OB_result: %x \n\r", xcmp->u8[0]);
8000219e:	0f a8       	ld.ub	r8,r7[0x2]
800021a0:	1a d8       	st.w	--sp,r8
800021a2:	48 9c       	lddpc	r12,800021c4 <EnOB_reply_func+0x6c>
800021a4:	f0 1f 00 04 	mcall	800021b4 <EnOB_reply_func+0x5c>
800021a8:	2f fd       	sub	sp,-4
800021aa:	e3 cd 80 80 	ldm	sp++,r7,pc
800021ae:	00 00       	add	r0,r0
800021b0:	80 00       	ld.sh	r0,r0[0x0]
800021b2:	ca 78       	rjmp	80002300 <Phyuserinput_brdcst_func+0x1c>
800021b4:	80 00       	ld.sh	r0,r0[0x0]
800021b6:	67 d4       	ld.w	r4,r3[0x74]
800021b8:	80 00       	ld.sh	r0,r0[0x0]
800021ba:	ca 90       	breq	8000210c <FD_brdcst_func+0x4>
800021bc:	80 00       	ld.sh	r0,r0[0x0]
800021be:	ca a4       	brge	80002112 <FD_brdcst_func+0xa>
800021c0:	80 00       	ld.sh	r0,r0[0x0]
800021c2:	ca bc       	rcall	80002318 <Phyuserinput_brdcst_func+0x34>
800021c4:	80 00       	ld.sh	r0,r0[0x0]
800021c6:	ca d8       	rjmp	80002320 <Phyuserinput_brdcst_func+0x3c>

800021c8 <SingleDetection_brdcst_func>:
	
}


void SingleDetection_brdcst_func(xcmp_fragment_t * xcmp)
{
800021c8:	eb cd 40 80 	pushm	r7,lr
800021cc:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == 0x11)
800021ce:	19 a9       	ld.ub	r9,r12[0x2]
800021d0:	31 18       	mov	r8,17
800021d2:	f0 09 18 00 	cp.b	r9,r8
800021d6:	c0 61       	brne	800021e2 <SingleDetection_brdcst_func+0x1a>
	{
		log("\n\r DMR_CSBK OK \n\r");
800021d8:	48 8c       	lddpc	r12,800021f8 <SingleDetection_brdcst_func+0x30>
800021da:	f0 1f 00 09 	mcall	800021fc <SingleDetection_brdcst_func+0x34>
800021de:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	//if(xcmp->u8[1] == 0x11)
	else
	{
		log("SIGBRCST error");
800021e2:	48 8c       	lddpc	r12,80002200 <SingleDetection_brdcst_func+0x38>
800021e4:	f0 1f 00 06 	mcall	800021fc <SingleDetection_brdcst_func+0x34>
		log("\n\r Signal_type: %X \n\r", xcmp->u8[0] );
800021e8:	0f a8       	ld.ub	r8,r7[0x2]
800021ea:	1a d8       	st.w	--sp,r8
800021ec:	48 6c       	lddpc	r12,80002204 <SingleDetection_brdcst_func+0x3c>
800021ee:	f0 1f 00 04 	mcall	800021fc <SingleDetection_brdcst_func+0x34>
800021f2:	2f fd       	sub	sp,-4
800021f4:	e3 cd 80 80 	ldm	sp++,r7,pc
800021f8:	80 00       	ld.sh	r0,r0[0x0]
800021fa:	ca f0       	breq	80002158 <EnOB_reply_func>
800021fc:	80 00       	ld.sh	r0,r0[0x0]
800021fe:	67 d4       	ld.w	r4,r3[0x74]
80002200:	80 00       	ld.sh	r0,r0[0x0]
80002202:	cb 04       	brge	80002162 <EnOB_reply_func+0xa>
80002204:	80 00       	ld.sh	r0,r0[0x0]
80002206:	cb 14       	brge	80002168 <EnOB_reply_func+0x10>

80002208 <ButtonConfig_brdcst_func>:
	
}


void ButtonConfig_brdcst_func(xcmp_fragment_t * xcmp)
{
80002208:	d4 31       	pushm	r0-r7,lr
	U8 Num_Button =0;
	U8 i = 0 ;
	/*point to xcmp payload*/
	ButtonConfig_brdcst_t  *ptr = (ButtonConfig_brdcst_t* )xcmp->u8;
8000220a:	f8 c7 ff fe 	sub	r7,r12,-2
	
	Num_Button = ptr->NumOfButtons;
8000220e:	0f 95       	ld.ub	r5,r7[0x1]
	
	log("\n\r ButtonConfig_broadcast  \n\r"  );
80002210:	4a bc       	lddpc	r12,800022bc <ButtonConfig_brdcst_func+0xb4>
80002212:	f0 1f 00 2c 	mcall	800022c0 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r Function: %X \n\r" , ptr->Function );
80002216:	0f 88       	ld.ub	r8,r7[0x0]
80002218:	1a d8       	st.w	--sp,r8
8000221a:	4a bc       	lddpc	r12,800022c4 <ButtonConfig_brdcst_func+0xbc>
8000221c:	f0 1f 00 29 	mcall	800022c0 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
80002220:	1a d5       	st.w	--sp,r5
80002222:	4a ac       	lddpc	r12,800022c8 <ButtonConfig_brdcst_func+0xc0>
80002224:	f0 1f 00 27 	mcall	800022c0 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
80002228:	0f a8       	ld.ub	r8,r7[0x2]
8000222a:	1a d8       	st.w	--sp,r8
8000222c:	4a 8c       	lddpc	r12,800022cc <ButtonConfig_brdcst_func+0xc4>
8000222e:	f0 1f 00 25 	mcall	800022c0 <ButtonConfig_brdcst_func+0xb8>
	
	for (i; i<Num_Button; i++)
80002232:	2f dd       	sub	sp,-12
80002234:	58 05       	cp.w	r5,0
80002236:	c4 10       	breq	800022b8 <ButtonConfig_brdcst_func+0xb0>
80002238:	30 06       	mov	r6,0
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
8000223a:	4a 64       	lddpc	r4,800022d0 <ButtonConfig_brdcst_func+0xc8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
8000223c:	4a 63       	lddpc	r3,800022d4 <ButtonConfig_brdcst_func+0xcc>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
8000223e:	4a 72       	lddpc	r2,800022d8 <ButtonConfig_brdcst_func+0xd0>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
80002240:	4a 71       	lddpc	r1,800022dc <ButtonConfig_brdcst_func+0xd4>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
80002242:	4a 80       	lddpc	r0,800022e0 <ButtonConfig_brdcst_func+0xd8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
80002244:	0f b9       	ld.ub	r9,r7[0x3]
80002246:	0f c8       	ld.ub	r8,r7[0x4]
80002248:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000224c:	1a d8       	st.w	--sp,r8
8000224e:	1a d6       	st.w	--sp,r6
80002250:	08 9c       	mov	r12,r4
80002252:	f0 1f 00 1c 	mcall	800022c0 <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
80002256:	0f d9       	ld.ub	r9,r7[0x5]
80002258:	0f e8       	ld.ub	r8,r7[0x6]
8000225a:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000225e:	1a d8       	st.w	--sp,r8
80002260:	1a d6       	st.w	--sp,r6
80002262:	06 9c       	mov	r12,r3
80002264:	f0 1f 00 17 	mcall	800022c0 <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
80002268:	0f f9       	ld.ub	r9,r7[0x7]
8000226a:	ef 38 00 08 	ld.ub	r8,r7[8]
8000226e:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002272:	1a d8       	st.w	--sp,r8
80002274:	1a d6       	st.w	--sp,r6
80002276:	04 9c       	mov	r12,r2
80002278:	f0 1f 00 12 	mcall	800022c0 <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
8000227c:	ef 39 00 09 	ld.ub	r9,r7[9]
80002280:	ef 38 00 0a 	ld.ub	r8,r7[10]
80002284:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002288:	1a d8       	st.w	--sp,r8
8000228a:	1a d6       	st.w	--sp,r6
8000228c:	02 9c       	mov	r12,r1
8000228e:	f0 1f 00 0d 	mcall	800022c0 <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
80002292:	2f 8d       	sub	sp,-32
80002294:	ef 39 00 0b 	ld.ub	r9,r7[11]
80002298:	ef 38 00 0c 	ld.ub	r8,r7[12]
8000229c:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800022a0:	1a d8       	st.w	--sp,r8
800022a2:	1a d6       	st.w	--sp,r6
800022a4:	00 9c       	mov	r12,r0
800022a6:	f0 1f 00 07 	mcall	800022c0 <ButtonConfig_brdcst_func+0xb8>
800022aa:	2f f6       	sub	r6,-1
800022ac:	2f 67       	sub	r7,-10
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
800022ae:	2f ed       	sub	sp,-8
800022b0:	ec 05 18 00 	cp.b	r5,r6
800022b4:	fe 9b ff c8 	brhi	80002244 <ButtonConfig_brdcst_func+0x3c>
800022b8:	d8 32       	popm	r0-r7,pc
800022ba:	00 00       	add	r0,r0
800022bc:	80 00       	ld.sh	r0,r0[0x0]
800022be:	cb 2c       	rcall	80002422 <DataSession_brdcst_func+0x82>
800022c0:	80 00       	ld.sh	r0,r0[0x0]
800022c2:	67 d4       	ld.w	r4,r3[0x74]
800022c4:	80 00       	ld.sh	r0,r0[0x0]
800022c6:	cb 4c       	rcall	8000242e <DataSession_reply_func+0xa>
800022c8:	80 00       	ld.sh	r0,r0[0x0]
800022ca:	cb 60       	breq	80002236 <ButtonConfig_brdcst_func+0x2e>
800022cc:	80 00       	ld.sh	r0,r0[0x0]
800022ce:	cb 78       	rjmp	8000243c <DataSession_reply_func+0x18>
800022d0:	80 00       	ld.sh	r0,r0[0x0]
800022d2:	cb 98       	rjmp	80002444 <DataSession_reply_func+0x20>
800022d4:	80 00       	ld.sh	r0,r0[0x0]
800022d6:	cb c0       	breq	8000224e <ButtonConfig_brdcst_func+0x46>
800022d8:	80 00       	ld.sh	r0,r0[0x0]
800022da:	cb e8       	rjmp	80002456 <DataSession_reply_func+0x32>
800022dc:	80 00       	ld.sh	r0,r0[0x0]
800022de:	cc 0c       	rcall	8000245e <DataSession_reply_func+0x3a>
800022e0:	80 00       	ld.sh	r0,r0[0x0]
800022e2:	cc 34       	brge	80002268 <ButtonConfig_brdcst_func+0x60>

800022e4 <Phyuserinput_brdcst_func>:
	
}


void Phyuserinput_brdcst_func(xcmp_fragment_t * xcmp)
{
800022e4:	eb cd 40 fc 	pushm	r2-r7,lr
	U16 PUI_ID =0;
	U8 PUI_State =0;
	U8 PUI_State_Min_Value =0;
	U8 PUI_State_Max_Value =0;
	
	PUI_Source = xcmp->u8[0];
800022e8:	19 a6       	ld.ub	r6,r12[0x2]
	PUI_Type = xcmp ->u8[1];
800022ea:	19 b5       	ld.ub	r5,r12[0x3]
	PUI_ID = ((xcmp->u8[2]<<8) | xcmp->u8[3]);
800022ec:	19 c7       	ld.ub	r7,r12[0x4]
800022ee:	19 d8       	ld.ub	r8,r12[0x5]
800022f0:	f1 e7 10 87 	or	r7,r8,r7<<0x8
	PUI_State = xcmp->u8[4];
800022f4:	19 e4       	ld.ub	r4,r12[0x6]
	PUI_State_Min_Value = xcmp->u8[5];
800022f6:	19 f3       	ld.ub	r3,r12[0x7]
	PUI_State_Max_Value = xcmp->u8[6];
800022f8:	f9 32 00 08 	ld.ub	r2,r12[8]
	
	log("\n\r PhysicalUserInput_broadcast  \n\r"  );
800022fc:	49 0c       	lddpc	r12,8000233c <Phyuserinput_brdcst_func+0x58>
800022fe:	f0 1f 00 11 	mcall	80002340 <Phyuserinput_brdcst_func+0x5c>
	
	log("\n\r PUI_Source: %X \n\r" , PUI_Source);
80002302:	1a d6       	st.w	--sp,r6
80002304:	49 0c       	lddpc	r12,80002344 <Phyuserinput_brdcst_func+0x60>
80002306:	f0 1f 00 0f 	mcall	80002340 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_Type: %X \n\r" , PUI_Type);
8000230a:	1a d5       	st.w	--sp,r5
8000230c:	48 fc       	lddpc	r12,80002348 <Phyuserinput_brdcst_func+0x64>
8000230e:	f0 1f 00 0d 	mcall	80002340 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_ID: %X \n\r" , PUI_ID);
80002312:	5c 77       	castu.h	r7
80002314:	1a d7       	st.w	--sp,r7
80002316:	48 ec       	lddpc	r12,8000234c <Phyuserinput_brdcst_func+0x68>
80002318:	f0 1f 00 0a 	mcall	80002340 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_State: %X \n\r" , PUI_State);
8000231c:	1a d4       	st.w	--sp,r4
8000231e:	48 dc       	lddpc	r12,80002350 <Phyuserinput_brdcst_func+0x6c>
80002320:	f0 1f 00 08 	mcall	80002340 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_State_Min_Value: %X \n\r" , PUI_State_Min_Value);
80002324:	1a d3       	st.w	--sp,r3
80002326:	48 cc       	lddpc	r12,80002354 <Phyuserinput_brdcst_func+0x70>
80002328:	f0 1f 00 06 	mcall	80002340 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_State_Max_Value: %X \n\r" , PUI_State_Max_Value);
8000232c:	1a d2       	st.w	--sp,r2
8000232e:	48 bc       	lddpc	r12,80002358 <Phyuserinput_brdcst_func+0x74>
80002330:	f0 1f 00 04 	mcall	80002340 <Phyuserinput_brdcst_func+0x5c>
80002334:	2f ad       	sub	sp,-24
	
	
	
	
	
}
80002336:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
8000233a:	00 00       	add	r0,r0
8000233c:	80 00       	ld.sh	r0,r0[0x0]
8000233e:	cc 58       	rjmp	800024c8 <TransmitControl_reply_func+0x4c>
80002340:	80 00       	ld.sh	r0,r0[0x0]
80002342:	67 d4       	ld.w	r4,r3[0x74]
80002344:	80 00       	ld.sh	r0,r0[0x0]
80002346:	cc 7c       	rcall	800024d4 <TransmitControl_reply_func+0x58>
80002348:	80 00       	ld.sh	r0,r0[0x0]
8000234a:	cc 94       	brge	800022dc <ButtonConfig_brdcst_func+0xd4>
8000234c:	80 00       	ld.sh	r0,r0[0x0]
8000234e:	cc a8       	rjmp	800024e2 <TransmitControl_reply_func+0x66>
80002350:	80 00       	ld.sh	r0,r0[0x0]
80002352:	cc bc       	rcall	800024e8 <TransmitControl_reply_func+0x6c>
80002354:	80 00       	ld.sh	r0,r0[0x0]
80002356:	cc d0       	breq	800022f0 <Phyuserinput_brdcst_func+0xc>
80002358:	80 00       	ld.sh	r0,r0[0x0]
8000235a:	cc f0       	breq	800022f8 <Phyuserinput_brdcst_func+0x14>

8000235c <ButtonConfig_reply_func>:
	}
	
}

void ButtonConfig_reply_func(xcmp_fragment_t * xcmp)
{
8000235c:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	ButtonConfig_reply_t *ptr = (ButtonConfig_reply_t* )(xcmp->u8);
80002360:	f8 c7 ff fe 	sub	r7,r12,-2
	if (ptr->Result == xcmp_Res_Success)
80002364:	0f 89       	ld.ub	r9,r7[0x0]
80002366:	30 08       	mov	r8,0
80002368:	f0 09 18 00 	cp.b	r9,r8
8000236c:	c0 c1       	brne	80002384 <ButtonConfig_reply_func+0x28>
	{
		log("\n\r Button_Config OK \n\r");
8000236e:	48 9c       	lddpc	r12,80002390 <ButtonConfig_reply_func+0x34>
80002370:	f0 1f 00 09 	mcall	80002394 <ButtonConfig_reply_func+0x38>
		
		log("\n\r Function: %X \n\r" , ptr->Function );
80002374:	0f 98       	ld.ub	r8,r7[0x1]
80002376:	1a d8       	st.w	--sp,r8
80002378:	48 8c       	lddpc	r12,80002398 <ButtonConfig_reply_func+0x3c>
8000237a:	f0 1f 00 07 	mcall	80002394 <ButtonConfig_reply_func+0x38>
8000237e:	2f fd       	sub	sp,-4
80002380:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r Button_Request error \n\r");
80002384:	48 6c       	lddpc	r12,8000239c <ButtonConfig_reply_func+0x40>
80002386:	f0 1f 00 04 	mcall	80002394 <ButtonConfig_reply_func+0x38>
8000238a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000238e:	00 00       	add	r0,r0
80002390:	80 00       	ld.sh	r0,r0[0x0]
80002392:	cd 10       	breq	80002334 <Phyuserinput_brdcst_func+0x50>
80002394:	80 00       	ld.sh	r0,r0[0x0]
80002396:	67 d4       	ld.w	r4,r3[0x74]
80002398:	80 00       	ld.sh	r0,r0[0x0]
8000239a:	cb 4c       	rcall	80002502 <AudioRoutingControl_brdcst_func+0xa>
8000239c:	80 00       	ld.sh	r0,r0[0x0]
8000239e:	cd 28       	rjmp	80002542 <AudioRoutingControl_brdcst_func+0x4a>

800023a0 <DataSession_brdcst_func>:
	}
	
}

void DataSession_brdcst_func(xcmp_fragment_t * xcmp)
{
800023a0:	d4 21       	pushm	r4-r7,lr
	U8 Session_number = 0;
	U16 data_length = 0;
	U8 i = 0;
	/*point to xcmp payload*/
	DataSession_brdcst_t *ptr = (DataSession_brdcst_t* )xcmp->u8;
800023a2:	f8 c6 ff fe 	sub	r6,r12,-2

	if (ptr->State == CSBK_DATA_RX_Suc)
800023a6:	0d 88       	ld.ub	r8,r6[0x0]
800023a8:	32 49       	mov	r9,36
800023aa:	f2 08 18 00 	cp.b	r8,r9
800023ae:	c2 91       	brne	80002400 <DataSession_brdcst_func+0x60>
	{
		
		log("\n\r CSBK_RX OK \n\r");
800023b0:	49 7c       	lddpc	r12,8000240c <DataSession_brdcst_func+0x6c>
800023b2:	f0 1f 00 18 	mcall	80002410 <DataSession_brdcst_func+0x70>
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
800023b6:	0d a5       	ld.ub	r5,r6[0x2]
800023b8:	0d b8       	ld.ub	r8,r6[0x3]
800023ba:	f1 e5 10 85 	or	r5,r8,r5<<0x8
800023be:	5c 85       	casts.h	r5

		log("\n\r Session_ID: %x \n\r",Session_number );
800023c0:	0d 98       	ld.ub	r8,r6[0x1]
800023c2:	1a d8       	st.w	--sp,r8
800023c4:	49 4c       	lddpc	r12,80002414 <DataSession_brdcst_func+0x74>
800023c6:	f0 1f 00 13 	mcall	80002410 <DataSession_brdcst_func+0x70>
		log("\n\r paylaod_length: %d \n\r",data_length );
800023ca:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
800023ce:	1a d8       	st.w	--sp,r8
800023d0:	49 2c       	lddpc	r12,80002418 <DataSession_brdcst_func+0x78>
800023d2:	f0 1f 00 10 	mcall	80002410 <DataSession_brdcst_func+0x70>
		for(i=0; i<data_length; i++)
800023d6:	2f ed       	sub	sp,-8
800023d8:	58 05       	cp.w	r5,0
800023da:	c1 80       	breq	8000240a <DataSession_brdcst_func+0x6a>
800023dc:	30 07       	mov	r7,0
		{
			
			//log("\n\r payload[%d]: %X \n\r", i, xcmp->u8[4+i]);
			log("\n\r payload[%d]: %X \n\r", i, ptr->DataPayload.DataPayload[i]);
800023de:	49 04       	lddpc	r4,8000241c <DataSession_brdcst_func+0x7c>
800023e0:	ec 07 00 08 	add	r8,r6,r7
800023e4:	11 c8       	ld.ub	r8,r8[0x4]
800023e6:	1a d8       	st.w	--sp,r8
800023e8:	1a d7       	st.w	--sp,r7
800023ea:	08 9c       	mov	r12,r4
800023ec:	f0 1f 00 09 	mcall	80002410 <DataSession_brdcst_func+0x70>
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);

		log("\n\r Session_ID: %x \n\r",Session_number );
		log("\n\r paylaod_length: %d \n\r",data_length );
		for(i=0; i<data_length; i++)
800023f0:	2f f7       	sub	r7,-1
800023f2:	5c 57       	castu.b	r7
800023f4:	2f ed       	sub	sp,-8
800023f6:	ee 05 19 00 	cp.h	r5,r7
800023fa:	fe 9b ff f3 	brhi	800023e0 <DataSession_brdcst_func+0x40>
800023fe:	d8 22       	popm	r4-r7,pc
		
	}
	else
	{
		//log("\n\r State: 0x %X \n\r", xcmp->u8[0]);
		log("\n\r State: 0x %X \n\r", ptr->State);
80002400:	1a d8       	st.w	--sp,r8
80002402:	48 8c       	lddpc	r12,80002420 <DataSession_brdcst_func+0x80>
80002404:	f0 1f 00 03 	mcall	80002410 <DataSession_brdcst_func+0x70>
80002408:	2f fd       	sub	sp,-4
8000240a:	d8 22       	popm	r4-r7,pc
8000240c:	80 00       	ld.sh	r0,r0[0x0]
8000240e:	cd 44       	brge	800023b6 <DataSession_brdcst_func+0x16>
80002410:	80 00       	ld.sh	r0,r0[0x0]
80002412:	67 d4       	ld.w	r4,r3[0x74]
80002414:	80 00       	ld.sh	r0,r0[0x0]
80002416:	cd 58       	rjmp	800025c0 <Volume_brdcst_func+0x8>
80002418:	80 00       	ld.sh	r0,r0[0x0]
8000241a:	cd 70       	breq	800023c8 <DataSession_brdcst_func+0x28>
8000241c:	80 00       	ld.sh	r0,r0[0x0]
8000241e:	cd 8c       	rcall	800025ce <Volume_brdcst_func+0x16>
80002420:	80 00       	ld.sh	r0,r0[0x0]
80002422:	cd a4       	brge	800023d6 <DataSession_brdcst_func+0x36>

80002424 <DataSession_reply_func>:
	
}


void DataSession_reply_func(xcmp_fragment_t * xcmp)
{
80002424:	eb cd 40 80 	pushm	r7,lr
80002428:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
8000242a:	19 a8       	ld.ub	r8,r12[0x2]
8000242c:	58 08       	cp.w	r8,0
8000242e:	c0 61       	brne	8000243a <DataSession_reply_func+0x16>
	{
		log("\n\r DATArep OK \n\r");
80002430:	48 dc       	lddpc	r12,80002464 <DataSession_reply_func+0x40>
80002432:	f0 1f 00 0e 	mcall	80002468 <DataSession_reply_func+0x44>
80002436:	e3 cd 80 80 	ldm	sp++,r7,pc
		//log("\n\r ID: 0x %X \n\r", xcmp->u8[2]);
		
	}
	else
	{
		log("\n\r Result:  %X \n\r", xcmp->u8[0]);
8000243a:	1a d8       	st.w	--sp,r8
8000243c:	48 cc       	lddpc	r12,8000246c <DataSession_reply_func+0x48>
8000243e:	f0 1f 00 0b 	mcall	80002468 <DataSession_reply_func+0x44>
		log("\n\r DATArep error \n\r");
80002442:	48 cc       	lddpc	r12,80002470 <DataSession_reply_func+0x4c>
80002444:	f0 1f 00 09 	mcall	80002468 <DataSession_reply_func+0x44>
		log("\n\r Func:  %X \n\r", xcmp->u8[1]);
80002448:	0f b8       	ld.ub	r8,r7[0x3]
8000244a:	1a d8       	st.w	--sp,r8
8000244c:	48 ac       	lddpc	r12,80002474 <DataSession_reply_func+0x50>
8000244e:	f0 1f 00 07 	mcall	80002468 <DataSession_reply_func+0x44>
		log("\n\r ID:  %X \n\r", xcmp->u8[2]);
80002452:	0f c8       	ld.ub	r8,r7[0x4]
80002454:	1a d8       	st.w	--sp,r8
80002456:	48 9c       	lddpc	r12,80002478 <DataSession_reply_func+0x54>
80002458:	f0 1f 00 04 	mcall	80002468 <DataSession_reply_func+0x44>
8000245c:	2f dd       	sub	sp,-12
8000245e:	e3 cd 80 80 	ldm	sp++,r7,pc
80002462:	00 00       	add	r0,r0
80002464:	80 00       	ld.sh	r0,r0[0x0]
80002466:	cd b8       	rjmp	8000261c <Volume_reply_func+0x30>
80002468:	80 00       	ld.sh	r0,r0[0x0]
8000246a:	67 d4       	ld.w	r4,r3[0x74]
8000246c:	80 00       	ld.sh	r0,r0[0x0]
8000246e:	cd cc       	rcall	80002626 <Volume_reply_func+0x3a>
80002470:	80 00       	ld.sh	r0,r0[0x0]
80002472:	cd e0       	breq	8000242e <DataSession_reply_func+0xa>
80002474:	80 00       	ld.sh	r0,r0[0x0]
80002476:	cd f4       	brge	80002434 <DataSession_reply_func+0x10>
80002478:	80 00       	ld.sh	r0,r0[0x0]
8000247a:	ce 04       	brge	8000243a <DataSession_reply_func+0x16>

8000247c <TransmitControl_reply_func>:




void TransmitControl_reply_func(xcmp_fragment_t * xcmp)
{
8000247c:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	TransmitControl_reply_t *ptr = (TransmitControl_reply_t* )xcmp->u8;
80002480:	f8 c7 ff fe 	sub	r7,r12,-2
	
	if (ptr->Result == xcmp_Res_Success)
80002484:	0f 89       	ld.ub	r9,r7[0x0]
80002486:	30 08       	mov	r8,0
80002488:	f0 09 18 00 	cp.b	r9,r8
8000248c:	c2 21       	brne	800024d0 <TransmitControl_reply_func+0x54>
	{
		
		log("\n\r  TransmitControl OK \n\r ");
8000248e:	49 4c       	lddpc	r12,800024dc <TransmitControl_reply_func+0x60>
80002490:	f0 1f 00 14 	mcall	800024e0 <TransmitControl_reply_func+0x64>
		log("\n\r Function: %x \n\r", ptr->Function);
80002494:	0f 98       	ld.ub	r8,r7[0x1]
80002496:	1a d8       	st.w	--sp,r8
80002498:	49 3c       	lddpc	r12,800024e4 <TransmitControl_reply_func+0x68>
8000249a:	f0 1f 00 12 	mcall	800024e0 <TransmitControl_reply_func+0x64>
		log("\n\r Mode of Operation: %x \n\r", ptr->Mode_Of_Operation);
8000249e:	0f a8       	ld.ub	r8,r7[0x2]
800024a0:	1a d8       	st.w	--sp,r8
800024a2:	49 2c       	lddpc	r12,800024e8 <TransmitControl_reply_func+0x6c>
800024a4:	f0 1f 00 0f 	mcall	800024e0 <TransmitControl_reply_func+0x64>
		log("\n\r State: %x \n\r", ptr->State);
800024a8:	0f b8       	ld.ub	r8,r7[0x3]
800024aa:	1a d8       	st.w	--sp,r8
800024ac:	49 0c       	lddpc	r12,800024ec <TransmitControl_reply_func+0x70>
800024ae:	f0 1f 00 0d 	mcall	800024e0 <TransmitControl_reply_func+0x64>
		
		if (ptr->Function == KEY_UP)
800024b2:	0f 98       	ld.ub	r8,r7[0x1]
800024b4:	2f dd       	sub	sp,-12
800024b6:	30 19       	mov	r9,1
800024b8:	f2 08 18 00 	cp.b	r8,r9
800024bc:	c0 d0       	breq	800024d6 <TransmitControl_reply_func+0x5a>
		{
			//is_unmute = 1;
		}
		else if (ptr->Function ==DE_KEY)
800024be:	30 29       	mov	r9,2
800024c0:	f2 08 18 00 	cp.b	r8,r9
800024c4:	c0 91       	brne	800024d6 <TransmitControl_reply_func+0x5a>
		{
			is_unmute = 0;
800024c6:	30 09       	mov	r9,0
800024c8:	48 a8       	lddpc	r8,800024f0 <TransmitControl_reply_func+0x74>
800024ca:	b0 89       	st.b	r8[0x0],r9
800024cc:	e3 cd 80 80 	ldm	sp++,r7,pc
		
		//Silent_flag = 1;
	}
	else
	{
		log("TransmitControl error");
800024d0:	48 9c       	lddpc	r12,800024f4 <TransmitControl_reply_func+0x78>
800024d2:	f0 1f 00 04 	mcall	800024e0 <TransmitControl_reply_func+0x64>
800024d6:	e3 cd 80 80 	ldm	sp++,r7,pc
800024da:	00 00       	add	r0,r0
800024dc:	80 00       	ld.sh	r0,r0[0x0]
800024de:	ce 14       	brge	800024a0 <TransmitControl_reply_func+0x24>
800024e0:	80 00       	ld.sh	r0,r0[0x0]
800024e2:	67 d4       	ld.w	r4,r3[0x74]
800024e4:	80 00       	ld.sh	r0,r0[0x0]
800024e6:	ce 30       	breq	800024ac <TransmitControl_reply_func+0x30>
800024e8:	80 00       	ld.sh	r0,r0[0x0]
800024ea:	ce 44       	brge	800024b2 <TransmitControl_reply_func+0x36>
800024ec:	80 00       	ld.sh	r0,r0[0x0]
800024ee:	ce 60       	breq	800024ba <TransmitControl_reply_func+0x3e>
800024f0:	00 00       	add	r0,r0
800024f2:	0a 4d       	or	sp,r5
800024f4:	80 00       	ld.sh	r0,r0[0x0]
800024f6:	ce 70       	breq	800024c4 <TransmitControl_reply_func+0x48>

800024f8 <AudioRoutingControl_brdcst_func>:
	}
}


void AudioRoutingControl_brdcst_func(xcmp_fragment_t * xcmp)
{
800024f8:	eb cd 40 f8 	pushm	r3-r7,lr
800024fc:	18 96       	mov	r6,r12
	
	U16 num_routings = 0;
	U8 j = 0 ;
	
	num_routings = ((xcmp->u8[0]<< 8) | (xcmp->u8[1]) );
800024fe:	19 a5       	ld.ub	r5,r12[0x2]
80002500:	19 b8       	ld.ub	r8,r12[0x3]
80002502:	f1 e5 10 85 	or	r5,r8,r5<<0x8
80002506:	5c 85       	casts.h	r5
	log("\n\r num_routings: %d \n\r", num_routings);
80002508:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
8000250c:	1a d8       	st.w	--sp,r8
8000250e:	49 6c       	lddpc	r12,80002564 <AudioRoutingControl_brdcst_func+0x6c>
80002510:	f0 1f 00 16 	mcall	80002568 <AudioRoutingControl_brdcst_func+0x70>
	
	for(j = 0; j< num_routings ; j++ )
80002514:	2f fd       	sub	sp,-4
80002516:	58 05       	cp.w	r5,0
80002518:	c0 31       	brne	8000251e <AudioRoutingControl_brdcst_func+0x26>
8000251a:	30 07       	mov	r7,0
8000251c:	c1 98       	rjmp	8000254e <AudioRoutingControl_brdcst_func+0x56>
8000251e:	30 07       	mov	r7,0
	{
		
		
		log("\n\r Audio-Input: %x \n\r", xcmp->u8[2+j*2]);
80002520:	49 34       	lddpc	r4,8000256c <AudioRoutingControl_brdcst_func+0x74>
		log("\n\r Audio-Output: %x \n\r", xcmp->u8[3+j*2]);
80002522:	49 43       	lddpc	r3,80002570 <AudioRoutingControl_brdcst_func+0x78>
	
	for(j = 0; j< num_routings ; j++ )
	{
		
		
		log("\n\r Audio-Input: %x \n\r", xcmp->u8[2+j*2]);
80002524:	ec 07 00 18 	add	r8,r6,r7<<0x1
80002528:	11 c8       	ld.ub	r8,r8[0x4]
8000252a:	1a d8       	st.w	--sp,r8
8000252c:	08 9c       	mov	r12,r4
8000252e:	f0 1f 00 0f 	mcall	80002568 <AudioRoutingControl_brdcst_func+0x70>
		log("\n\r Audio-Output: %x \n\r", xcmp->u8[3+j*2]);
80002532:	ec 07 00 18 	add	r8,r6,r7<<0x1
80002536:	11 d8       	ld.ub	r8,r8[0x5]
80002538:	1a d8       	st.w	--sp,r8
8000253a:	06 9c       	mov	r12,r3
8000253c:	f0 1f 00 0b 	mcall	80002568 <AudioRoutingControl_brdcst_func+0x70>
	U8 j = 0 ;
	
	num_routings = ((xcmp->u8[0]<< 8) | (xcmp->u8[1]) );
	log("\n\r num_routings: %d \n\r", num_routings);
	
	for(j = 0; j< num_routings ; j++ )
80002540:	2f f7       	sub	r7,-1
80002542:	5c 57       	castu.b	r7
80002544:	2f ed       	sub	sp,-8
80002546:	ee 05 19 00 	cp.h	r5,r7
8000254a:	fe 9b ff ed 	brhi	80002524 <AudioRoutingControl_brdcst_func+0x2c>
		log("\n\r Audio-Output: %x \n\r", xcmp->u8[3+j*2]);
		
		
	}
	
	log("\n\r Audio-Function: %x \n\r", xcmp->u8[3+j*2-1]);
8000254e:	ec 07 00 17 	add	r7,r6,r7<<0x1
80002552:	0f c8       	ld.ub	r8,r7[0x4]
80002554:	1a d8       	st.w	--sp,r8
80002556:	48 8c       	lddpc	r12,80002574 <AudioRoutingControl_brdcst_func+0x7c>
80002558:	f0 1f 00 04 	mcall	80002568 <AudioRoutingControl_brdcst_func+0x70>
8000255c:	2f fd       	sub	sp,-4
	
	
	
}
8000255e:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80002562:	00 00       	add	r0,r0
80002564:	80 00       	ld.sh	r0,r0[0x0]
80002566:	ce 88       	rjmp	80002736 <mic_reply_func+0x72>
80002568:	80 00       	ld.sh	r0,r0[0x0]
8000256a:	67 d4       	ld.w	r4,r3[0x74]
8000256c:	80 00       	ld.sh	r0,r0[0x0]
8000256e:	ce a0       	breq	80002542 <AudioRoutingControl_brdcst_func+0x4a>
80002570:	80 00       	ld.sh	r0,r0[0x0]
80002572:	ce b8       	rjmp	80002748 <mic_reply_func+0x84>
80002574:	80 00       	ld.sh	r0,r0[0x0]
80002576:	ce d0       	breq	80002550 <AudioRoutingControl_brdcst_func+0x58>

80002578 <AudioRoutingControl_reply_func>:
	
}


void AudioRoutingControl_reply_func(xcmp_fragment_t * xcmp)
{
80002578:	eb cd 40 80 	pushm	r7,lr
8000257c:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
8000257e:	19 a9       	ld.ub	r9,r12[0x2]
80002580:	30 08       	mov	r8,0
80002582:	f0 09 18 00 	cp.b	r9,r8
80002586:	c0 61       	brne	80002592 <AudioRoutingControl_reply_func+0x1a>
	{
		log("AudioRouting OK");
80002588:	48 8c       	lddpc	r12,800025a8 <AudioRoutingControl_reply_func+0x30>
8000258a:	f0 1f 00 09 	mcall	800025ac <AudioRoutingControl_reply_func+0x34>
8000258e:	e3 cd 80 80 	ldm	sp++,r7,pc
		//is_unmute = 1;
	}
	else
	{
		log("AudioRouting error");
80002592:	48 8c       	lddpc	r12,800025b0 <AudioRoutingControl_reply_func+0x38>
80002594:	f0 1f 00 06 	mcall	800025ac <AudioRoutingControl_reply_func+0x34>
		log("\n\r AudioRouting result: %x \n\r", xcmp->u8[0]);
80002598:	0f a8       	ld.ub	r8,r7[0x2]
8000259a:	1a d8       	st.w	--sp,r8
8000259c:	48 6c       	lddpc	r12,800025b4 <AudioRoutingControl_reply_func+0x3c>
8000259e:	f0 1f 00 04 	mcall	800025ac <AudioRoutingControl_reply_func+0x34>
800025a2:	2f fd       	sub	sp,-4
800025a4:	e3 cd 80 80 	ldm	sp++,r7,pc
800025a8:	80 00       	ld.sh	r0,r0[0x0]
800025aa:	ce ec       	rcall	80002786 <dcm_brdcst_func+0x2e>
800025ac:	80 00       	ld.sh	r0,r0[0x0]
800025ae:	67 d4       	ld.w	r4,r3[0x74]
800025b0:	80 00       	ld.sh	r0,r0[0x0]
800025b2:	ce fc       	rcall	80002790 <dcm_brdcst_func+0x38>
800025b4:	80 00       	ld.sh	r0,r0[0x0]
800025b6:	cf 10       	breq	80002598 <AudioRoutingControl_reply_func+0x20>

800025b8 <Volume_brdcst_func>:
	
	
}

void Volume_brdcst_func(xcmp_fragment_t * xcmp)
{
800025b8:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	VolumeControl_brdcst_t *ptr = (VolumeControl_brdcst_t* )xcmp->u8;
800025bc:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
800025c0:	0f 89       	ld.ub	r9,r7[0x0]
800025c2:	0f 98       	ld.ub	r8,r7[0x1]
800025c4:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800025c8:	1a d8       	st.w	--sp,r8
800025ca:	48 6c       	lddpc	r12,800025e0 <Volume_brdcst_func+0x28>
800025cc:	f0 1f 00 06 	mcall	800025e4 <Volume_brdcst_func+0x2c>
	
	log("\n\r Audio_Parameter: %x \n\r", ptr->Audio_Parameter);
800025d0:	0f b8       	ld.ub	r8,r7[0x3]
800025d2:	1a d8       	st.w	--sp,r8
800025d4:	48 5c       	lddpc	r12,800025e8 <Volume_brdcst_func+0x30>
800025d6:	f0 1f 00 04 	mcall	800025e4 <Volume_brdcst_func+0x2c>
800025da:	2f ed       	sub	sp,-8
	
	
}
800025dc:	e3 cd 80 80 	ldm	sp++,r7,pc
800025e0:	80 00       	ld.sh	r0,r0[0x0]
800025e2:	cf 30       	breq	800025c8 <Volume_brdcst_func+0x10>
800025e4:	80 00       	ld.sh	r0,r0[0x0]
800025e6:	67 d4       	ld.w	r4,r3[0x74]
800025e8:	80 00       	ld.sh	r0,r0[0x0]
800025ea:	cf 4c       	rcall	800027d2 <dcm_reply_func+0x32>

800025ec <Volume_reply_func>:
	
}


void Volume_reply_func(xcmp_fragment_t * xcmp)
{
800025ec:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	VolumeControl_reply_t *ptr = (VolumeControl_reply_t* )xcmp->u8;
800025f0:	f8 c7 ff fe 	sub	r7,r12,-2
	
		if (ptr->Result == xcmp_Res_Success)
800025f4:	0f 89       	ld.ub	r9,r7[0x0]
800025f6:	30 08       	mov	r8,0
800025f8:	f0 09 18 00 	cp.b	r9,r8
800025fc:	c1 b1       	brne	80002632 <Volume_reply_func+0x46>
		{
			if (ptr->Function == Enable_IntelligentAudio)
800025fe:	0f b8       	ld.ub	r8,r7[0x3]
80002600:	31 09       	mov	r9,16
80002602:	f2 08 18 00 	cp.b	r8,r9
80002606:	c0 f1       	brne	80002624 <Volume_reply_func+0x38>
			{
				log("\n\r Enable_IA OK \n\r");
80002608:	48 dc       	lddpc	r12,8000263c <Volume_reply_func+0x50>
8000260a:	f0 1f 00 0e 	mcall	80002640 <Volume_reply_func+0x54>
				log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
8000260e:	0f 99       	ld.ub	r9,r7[0x1]
80002610:	0f a8       	ld.ub	r8,r7[0x2]
80002612:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002616:	1a d8       	st.w	--sp,r8
80002618:	48 bc       	lddpc	r12,80002644 <Volume_reply_func+0x58>
8000261a:	f0 1f 00 0a 	mcall	80002640 <Volume_reply_func+0x54>
8000261e:	2f fd       	sub	sp,-4
80002620:	e3 cd 80 80 	ldm	sp++,r7,pc
	
			}
			else
			{
				
				log("\n\r VolumeControl: %x \n\r", ptr->Function);
80002624:	1a d8       	st.w	--sp,r8
80002626:	48 9c       	lddpc	r12,80002648 <Volume_reply_func+0x5c>
80002628:	f0 1f 00 06 	mcall	80002640 <Volume_reply_func+0x54>
8000262c:	2f fd       	sub	sp,-4
8000262e:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		
		else
		{
			log("\n\r Enable_IA error \n\r");
80002632:	48 7c       	lddpc	r12,8000264c <Volume_reply_func+0x60>
80002634:	f0 1f 00 03 	mcall	80002640 <Volume_reply_func+0x54>
80002638:	e3 cd 80 80 	ldm	sp++,r7,pc
8000263c:	80 00       	ld.sh	r0,r0[0x0]
8000263e:	cf 68       	rjmp	8000282a <ToneControl_reply_func+0x22>
80002640:	80 00       	ld.sh	r0,r0[0x0]
80002642:	67 d4       	ld.w	r4,r3[0x74]
80002644:	80 00       	ld.sh	r0,r0[0x0]
80002646:	cf 30       	breq	8000262c <Volume_reply_func+0x40>
80002648:	80 00       	ld.sh	r0,r0[0x0]
8000264a:	cf 7c       	rcall	80002838 <app_payload_tx_proc+0x8>
8000264c:	80 00       	ld.sh	r0,r0[0x0]
8000264e:	cf 94       	brge	80002640 <Volume_reply_func+0x54>

80002650 <spk_brdcst_func>:
		log("spk error");
	}
}

void spk_brdcst_func(xcmp_fragment_t * xcmp)
{
80002650:	d4 01       	pushm	lr
	if (xcmp->u8[3] == xcmp_Res_Success)//0x0000:mute
80002652:	19 d9       	ld.ub	r9,r12[0x5]
80002654:	30 08       	mov	r8,0
80002656:	f0 09 18 00 	cp.b	r9,r8
8000265a:	c0 91       	brne	8000266c <spk_brdcst_func+0x1c>
	{
		is_unmute =0;
8000265c:	48 99       	lddpc	r9,80002680 <spk_brdcst_func+0x30>
8000265e:	b2 88       	st.b	r9[0x0],r8
		Silent_flag = 0;
80002660:	48 99       	lddpc	r9,80002684 <spk_brdcst_func+0x34>
80002662:	b2 88       	st.b	r9[0x0],r8
		log("spk_s_close ");
80002664:	48 9c       	lddpc	r12,80002688 <spk_brdcst_func+0x38>
80002666:	f0 1f 00 0a 	mcall	8000268c <spk_brdcst_func+0x3c>
8000266a:	d8 02       	popm	pc
		
		
	}
	else
	{
		Silent_flag = 1;
8000266c:	30 18       	mov	r8,1
8000266e:	48 69       	lddpc	r9,80002684 <spk_brdcst_func+0x34>
80002670:	b2 88       	st.b	r9[0x0],r8
		is_unmute = 1;
80002672:	48 49       	lddpc	r9,80002680 <spk_brdcst_func+0x30>
80002674:	b2 88       	st.b	r9[0x0],r8
		log("spk_s_open ");
80002676:	48 7c       	lddpc	r12,80002690 <spk_brdcst_func+0x40>
80002678:	f0 1f 00 05 	mcall	8000268c <spk_brdcst_func+0x3c>
8000267c:	d8 02       	popm	pc
8000267e:	00 00       	add	r0,r0
80002680:	00 00       	add	r0,r0
80002682:	0a 4d       	or	sp,r5
80002684:	00 00       	add	r0,r0
80002686:	0a 54       	eor	r4,r5
80002688:	80 00       	ld.sh	r0,r0[0x0]
8000268a:	cf ac       	rcall	8000287e <app_payload_rx_proc+0x22>
8000268c:	80 00       	ld.sh	r0,r0[0x0]
8000268e:	67 d4       	ld.w	r4,r3[0x74]
80002690:	80 00       	ld.sh	r0,r0[0x0]
80002692:	cf bc       	rcall	80002888 <app_payload_rx_proc+0x2c>

80002694 <spk_reply_func>:
			
	
}

void spk_reply_func(xcmp_fragment_t * xcmp)
{
80002694:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
80002696:	19 a9       	ld.ub	r9,r12[0x2]
80002698:	30 08       	mov	r8,0
8000269a:	f0 09 18 00 	cp.b	r9,r8
8000269e:	c0 81       	brne	800026ae <spk_reply_func+0x1a>
		{
			//is_unmute = 1;
			
			//Silent_flag = 1;
		}
		log("spk OK -st%2x", xcmp->u8[4] );
800026a0:	19 e8       	ld.ub	r8,r12[0x6]
800026a2:	1a d8       	st.w	--sp,r8
800026a4:	48 5c       	lddpc	r12,800026b8 <spk_reply_func+0x24>
800026a6:	f0 1f 00 06 	mcall	800026bc <spk_reply_func+0x28>
800026aa:	2f fd       	sub	sp,-4
800026ac:	d8 02       	popm	pc
		
	}
	else
	{
		log("spk error");
800026ae:	48 5c       	lddpc	r12,800026c0 <spk_reply_func+0x2c>
800026b0:	f0 1f 00 03 	mcall	800026bc <spk_reply_func+0x28>
800026b4:	d8 02       	popm	pc
800026b6:	00 00       	add	r0,r0
800026b8:	80 00       	ld.sh	r0,r0[0x0]
800026ba:	cf c8       	rjmp	800028b2 <DeviceInitializationStatus_brdcst_func+0x6>
800026bc:	80 00       	ld.sh	r0,r0[0x0]
800026be:	67 d4       	ld.w	r4,r3[0x74]
800026c0:	80 00       	ld.sh	r0,r0[0x0]
800026c2:	cf d8       	rjmp	800028bc <DeviceInitializationStatus_brdcst_func+0x10>

800026c4 <mic_reply_func>:
	
	
}

void mic_reply_func(xcmp_fragment_t * xcmp)
{
800026c4:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_reply_t *ptr = (MicControl_reply_t* )xcmp->u8;
800026c8:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Mic_reply \n\r");
800026cc:	49 ac       	lddpc	r12,80002734 <mic_reply_func+0x70>
800026ce:	f0 1f 00 1b 	mcall	80002738 <mic_reply_func+0x74>
	if (ptr->Result == 0x00)
800026d2:	0f 89       	ld.ub	r9,r7[0x0]
800026d4:	30 08       	mov	r8,0
800026d6:	f0 09 18 00 	cp.b	r9,r8
800026da:	c2 71       	brne	80002728 <mic_reply_func+0x64>
	{
		
		if (ptr->Function == Mic_Disable)
800026dc:	0f 98       	ld.ub	r8,r7[0x1]
800026de:	30 29       	mov	r9,2
800026e0:	f2 08 18 00 	cp.b	r8,r9
800026e4:	c1 b1       	brne	8000271a <mic_reply_func+0x56>
		{
		
			log("\n\r Mic_close_ok \n\r " );
800026e6:	49 6c       	lddpc	r12,8000273c <mic_reply_func+0x78>
800026e8:	f0 1f 00 14 	mcall	80002738 <mic_reply_func+0x74>
			log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
800026ec:	0f a8       	ld.ub	r8,r7[0x2]
800026ee:	1a d8       	st.w	--sp,r8
800026f0:	49 4c       	lddpc	r12,80002740 <mic_reply_func+0x7c>
800026f2:	f0 1f 00 12 	mcall	80002738 <mic_reply_func+0x74>
			log("\n\r Signaling_type: %x \n\r " ,  ptr->Signaling_Type);
800026f6:	0f b8       	ld.ub	r8,r7[0x3]
800026f8:	1a d8       	st.w	--sp,r8
800026fa:	49 3c       	lddpc	r12,80002744 <mic_reply_func+0x80>
800026fc:	f0 1f 00 0f 	mcall	80002738 <mic_reply_func+0x74>
			log("\n\r Mic_state: %x \n\r " ,  ptr->Mic_State);
80002700:	0f c8       	ld.ub	r8,r7[0x4]
80002702:	1a d8       	st.w	--sp,r8
80002704:	49 1c       	lddpc	r12,80002748 <mic_reply_func+0x84>
80002706:	f0 1f 00 0d 	mcall	80002738 <mic_reply_func+0x74>
			log("\n\r Gain_offset: %x \n\r " ,  ptr->Gain_Offset);
8000270a:	0f d8       	ld.ub	r8,r7[0x5]
8000270c:	1a d8       	st.w	--sp,r8
8000270e:	49 0c       	lddpc	r12,8000274c <mic_reply_func+0x88>
80002710:	f0 1f 00 0a 	mcall	80002738 <mic_reply_func+0x74>
80002714:	2f cd       	sub	sp,-16
80002716:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else
		{
			log("\n\r Mic_function: %x \n\r ", ptr->Function );
8000271a:	1a d8       	st.w	--sp,r8
8000271c:	48 dc       	lddpc	r12,80002750 <mic_reply_func+0x8c>
8000271e:	f0 1f 00 07 	mcall	80002738 <mic_reply_func+0x74>
80002722:	2f fd       	sub	sp,-4
80002724:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else 
	{
		
	
		log("\n\r Mic error \n\r");
80002728:	48 bc       	lddpc	r12,80002754 <mic_reply_func+0x90>
8000272a:	f0 1f 00 04 	mcall	80002738 <mic_reply_func+0x74>
8000272e:	e3 cd 80 80 	ldm	sp++,r7,pc
80002732:	00 00       	add	r0,r0
80002734:	80 00       	ld.sh	r0,r0[0x0]
80002736:	cf e4       	brge	80002732 <mic_reply_func+0x6e>
80002738:	80 00       	ld.sh	r0,r0[0x0]
8000273a:	67 d4       	ld.w	r4,r3[0x74]
8000273c:	80 00       	ld.sh	r0,r0[0x0]
8000273e:	cf f4       	brge	8000273c <mic_reply_func+0x78>
80002740:	80 00       	ld.sh	r0,r0[0x0]
80002742:	d0 08       	*unknown*
80002744:	80 00       	ld.sh	r0,r0[0x0]
80002746:	d0 1c       	*unknown*
80002748:	80 00       	ld.sh	r0,r0[0x0]
8000274a:	d0 38       	*unknown*
8000274c:	80 00       	ld.sh	r0,r0[0x0]
8000274e:	d0 50       	acall	0x5
80002750:	80 00       	ld.sh	r0,r0[0x0]
80002752:	d0 68       	*unknown*
80002754:	80 00       	ld.sh	r0,r0[0x0]
80002756:	d0 80       	acall	0x8

80002758 <dcm_brdcst_func>:
	}
}


void dcm_brdcst_func(xcmp_fragment_t * xcmp)
{
80002758:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	DeviceControlMode_brdcst_t *ptr = (DeviceControlMode_brdcst_t* )xcmp->u8;
8000275c:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Dcm_brdcst \n\r");		
80002760:	48 bc       	lddpc	r12,8000278c <dcm_brdcst_func+0x34>
80002762:	f0 1f 00 0c 	mcall	80002790 <dcm_brdcst_func+0x38>
	log("\n\r Function: %x \n\r " ,  ptr->Function);
80002766:	0f 88       	ld.ub	r8,r7[0x0]
80002768:	1a d8       	st.w	--sp,r8
8000276a:	48 bc       	lddpc	r12,80002794 <dcm_brdcst_func+0x3c>
8000276c:	f0 1f 00 09 	mcall	80002790 <dcm_brdcst_func+0x38>
	log("\n\r ControlType: %x \n\r " ,  ptr->ControlType);
80002770:	0f a8       	ld.ub	r8,r7[0x2]
80002772:	1a d8       	st.w	--sp,r8
80002774:	48 9c       	lddpc	r12,80002798 <dcm_brdcst_func+0x40>
80002776:	f0 1f 00 07 	mcall	80002790 <dcm_brdcst_func+0x38>
	log("\n\r ControlTypeSize: %x \n\r " ,  ptr->ControlTypeSize);
8000277a:	0f 98       	ld.ub	r8,r7[0x1]
8000277c:	1a d8       	st.w	--sp,r8
8000277e:	48 8c       	lddpc	r12,8000279c <dcm_brdcst_func+0x44>
80002780:	f0 1f 00 04 	mcall	80002790 <dcm_brdcst_func+0x38>
80002784:	2f dd       	sub	sp,-12
	
	
}
80002786:	e3 cd 80 80 	ldm	sp++,r7,pc
8000278a:	00 00       	add	r0,r0
8000278c:	80 00       	ld.sh	r0,r0[0x0]
8000278e:	d0 90       	acall	0x9
80002790:	80 00       	ld.sh	r0,r0[0x0]
80002792:	67 d4       	ld.w	r4,r3[0x74]
80002794:	80 00       	ld.sh	r0,r0[0x0]
80002796:	d0 a4       	*unknown*
80002798:	80 00       	ld.sh	r0,r0[0x0]
8000279a:	d0 b8       	*unknown*
8000279c:	80 00       	ld.sh	r0,r0[0x0]
8000279e:	d0 d0       	acall	0xd

800027a0 <dcm_reply_func>:
		log("Tone error");
	}
}

void dcm_reply_func(xcmp_fragment_t * xcmp)
{
800027a0:	eb cd 40 80 	pushm	r7,lr
800027a4:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
800027a6:	19 a9       	ld.ub	r9,r12[0x2]
800027a8:	30 08       	mov	r8,0
800027aa:	f0 09 18 00 	cp.b	r9,r8
800027ae:	c1 b1       	brne	800027e4 <dcm_reply_func+0x44>
	{
		if(xcmp->u8[1] == DCM_ENTER)
800027b0:	19 b8       	ld.ub	r8,r12[0x3]
800027b2:	30 19       	mov	r9,1
800027b4:	f2 08 18 00 	cp.b	r8,r9
800027b8:	c0 51       	brne	800027c2 <dcm_reply_func+0x22>
		{
			log("\n\r Dcm-Enter OK \n\r");
800027ba:	48 ec       	lddpc	r12,800027f0 <dcm_reply_func+0x50>
800027bc:	f0 1f 00 0e 	mcall	800027f4 <dcm_reply_func+0x54>
800027c0:	c0 a8       	rjmp	800027d4 <dcm_reply_func+0x34>
			
		}
		else if (xcmp->u8[1] == DCM_EXIT)
800027c2:	58 08       	cp.w	r8,0
800027c4:	c0 51       	brne	800027ce <dcm_reply_func+0x2e>
		{
			log("\n\r Dcm-Exit OK \n\r");
800027c6:	48 dc       	lddpc	r12,800027f8 <dcm_reply_func+0x58>
800027c8:	f0 1f 00 0b 	mcall	800027f4 <dcm_reply_func+0x54>
800027cc:	c0 48       	rjmp	800027d4 <dcm_reply_func+0x34>
		}
		else
		{
			log("\n\r Dcm-Revoke \n\r");
800027ce:	48 cc       	lddpc	r12,800027fc <dcm_reply_func+0x5c>
800027d0:	f0 1f 00 09 	mcall	800027f4 <dcm_reply_func+0x54>
		}
		
		log("dcm OK-mo%X", xcmp->u8[3]);
800027d4:	0f d8       	ld.ub	r8,r7[0x5]
800027d6:	1a d8       	st.w	--sp,r8
800027d8:	48 ac       	lddpc	r12,80002800 <dcm_reply_func+0x60>
800027da:	f0 1f 00 07 	mcall	800027f4 <dcm_reply_func+0x54>
800027de:	2f fd       	sub	sp,-4
800027e0:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		log("dcm error");
800027e4:	48 8c       	lddpc	r12,80002804 <dcm_reply_func+0x64>
800027e6:	f0 1f 00 04 	mcall	800027f4 <dcm_reply_func+0x54>
800027ea:	e3 cd 80 80 	ldm	sp++,r7,pc
800027ee:	00 00       	add	r0,r0
800027f0:	80 00       	ld.sh	r0,r0[0x0]
800027f2:	d0 ec       	*unknown*
800027f4:	80 00       	ld.sh	r0,r0[0x0]
800027f6:	67 d4       	ld.w	r4,r3[0x74]
800027f8:	80 00       	ld.sh	r0,r0[0x0]
800027fa:	d1 00       	acall	0x10
800027fc:	80 00       	ld.sh	r0,r0[0x0]
800027fe:	d1 14       	*unknown*
80002800:	80 00       	ld.sh	r0,r0[0x0]
80002802:	d1 28       	*unknown*
80002804:	80 00       	ld.sh	r0,r0[0x0]
80002806:	d1 34       	*unknown*

80002808 <ToneControl_reply_func>:
			}
		}
}

void ToneControl_reply_func(xcmp_fragment_t * xcmp)
{
80002808:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
8000280a:	19 a9       	ld.ub	r9,r12[0x2]
8000280c:	30 08       	mov	r8,0
8000280e:	f0 09 18 00 	cp.b	r9,r8
80002812:	c0 51       	brne	8000281c <ToneControl_reply_func+0x14>
	{		
		log("Tone OK");
80002814:	48 4c       	lddpc	r12,80002824 <ToneControl_reply_func+0x1c>
80002816:	f0 1f 00 05 	mcall	80002828 <ToneControl_reply_func+0x20>
8000281a:	d8 02       	popm	pc
		//fl_write("/test.txt", FILE_END, (void *)"send tone ok\r\n", sizeof("send tone ok\r\n") - 1);
	}
	else
	{
		log("Tone error");
8000281c:	48 4c       	lddpc	r12,8000282c <ToneControl_reply_func+0x24>
8000281e:	f0 1f 00 03 	mcall	80002828 <ToneControl_reply_func+0x20>
80002822:	d8 02       	popm	pc
80002824:	80 00       	ld.sh	r0,r0[0x0]
80002826:	d1 40       	acall	0x14
80002828:	80 00       	ld.sh	r0,r0[0x0]
8000282a:	67 d4       	ld.w	r4,r3[0x74]
8000282c:	80 00       	ld.sh	r0,r0[0x0]
8000282e:	d1 48       	*unknown*

80002830 <app_payload_tx_proc>:

}


static void app_payload_tx_proc(void  * payload)
{
80002830:	eb cd 40 80 	pushm	r7,lr
80002834:	18 97       	mov	r7,r12
  log("R");
80002836:	48 6c       	lddpc	r12,8000284c <app_payload_tx_proc+0x1c>
80002838:	f0 1f 00 06 	mcall	80002850 <app_payload_tx_proc+0x20>
  //fl_write("voice.dat", FILE_END, payload, MAX_PAYLOAD_BUFF_SIZE * 2);
  
  //vTaskDelay(100);
  
  //payload_fragment_t * ptr = (payload_fragment_t *)payload;
  set_payload_idle(payload);
8000283c:	48 68       	lddpc	r8,80002854 <app_payload_tx_proc+0x24>
8000283e:	70 0c       	ld.w	r12,r8[0x0]
80002840:	0e 9b       	mov	r11,r7
80002842:	f0 1f 00 06 	mcall	80002858 <app_payload_tx_proc+0x28>

//

}
80002846:	e3 cd 80 80 	ldm	sp++,r7,pc
8000284a:	00 00       	add	r0,r0
8000284c:	80 00       	ld.sh	r0,r0[0x0]
8000284e:	d1 54       	*unknown*
80002850:	80 00       	ld.sh	r0,r0[0x0]
80002852:	67 d4       	ld.w	r4,r3[0x74]
80002854:	00 00       	add	r0,r0
80002856:	0a 8c       	andn	r12,r5
80002858:	80 00       	ld.sh	r0,r0[0x0]
8000285a:	31 cc       	mov	r12,28

8000285c <app_payload_rx_proc>:
	}
}


static void app_payload_rx_proc(void  * payload)
{
8000285c:	eb cd 40 80 	pushm	r7,lr
80002860:	18 97       	mov	r7,r12
	log("\n\r w: \n\r");
80002862:	48 cc       	lddpc	r12,80002890 <app_payload_rx_proc+0x34>
80002864:	f0 1f 00 0c 	mcall	80002894 <app_payload_rx_proc+0x38>
	if (AMBE_flag)
80002868:	48 c8       	lddpc	r8,80002898 <app_payload_rx_proc+0x3c>
8000286a:	11 89       	ld.ub	r9,r8[0x0]
8000286c:	30 08       	mov	r8,0
8000286e:	f0 09 18 00 	cp.b	r9,r8
80002872:	c0 81       	brne	80002882 <app_payload_rx_proc+0x26>
	{
		//fl_write("AMBEvo.bit", FILE_END, payload, MAX_PAYLOAD_BUFF_SIZE * 2);
	}
	else
	{
		fl_write("PCMvo.pcm", FILE_END, payload, MAX_PAYLOAD_BUFF_SIZE * 2);
80002874:	e0 69 02 00 	mov	r9,512
80002878:	0e 9a       	mov	r10,r7
8000287a:	3f fb       	mov	r11,-1
8000287c:	48 8c       	lddpc	r12,8000289c <app_payload_rx_proc+0x40>
8000287e:	f0 1f 00 09 	mcall	800028a0 <app_payload_rx_proc+0x44>
	}
	
	//payload_fragment_t * ptr = (payload_fragment_t *)payload;
	set_payload_idle(payload);
80002882:	48 98       	lddpc	r8,800028a4 <app_payload_rx_proc+0x48>
80002884:	70 0c       	ld.w	r12,r8[0x0]
80002886:	0e 9b       	mov	r11,r7
80002888:	f0 1f 00 08 	mcall	800028a8 <app_payload_rx_proc+0x4c>

}
8000288c:	e3 cd 80 80 	ldm	sp++,r7,pc
80002890:	80 00       	ld.sh	r0,r0[0x0]
80002892:	d1 58       	*unknown*
80002894:	80 00       	ld.sh	r0,r0[0x0]
80002896:	67 d4       	ld.w	r4,r3[0x74]
80002898:	00 00       	add	r0,r0
8000289a:	0a 44       	or	r4,r5
8000289c:	80 00       	ld.sh	r0,r0[0x0]
8000289e:	d1 64       	*unknown*
800028a0:	80 00       	ld.sh	r0,r0[0x0]
800028a2:	30 50       	mov	r0,5
800028a4:	00 00       	add	r0,r0
800028a6:	0a 8c       	andn	r12,r5
800028a8:	80 00       	ld.sh	r0,r0[0x0]
800028aa:	31 cc       	mov	r12,28

800028ac <DeviceInitializationStatus_brdcst_func>:
static void app_payload_tx_proc(void  * payload);

//app func--list

void DeviceInitializationStatus_brdcst_func(xcmp_fragment_t  * xcmp)
{
800028ac:	d4 01       	pushm	lr
	if (xcmp->u8[4] == 0x01)
800028ae:	19 e8       	ld.ub	r8,r12[0x6]
800028b0:	30 19       	mov	r9,1
800028b2:	f2 08 18 00 	cp.b	r8,r9
800028b6:	c0 61       	brne	800028c2 <DeviceInitializationStatus_brdcst_func+0x16>
	{
		bunchofrandomstatusflags |= 0x01;  //Need do nothing else.
800028b8:	48 98       	lddpc	r8,800028dc <DeviceInitializationStatus_brdcst_func+0x30>
800028ba:	70 09       	ld.w	r9,r8[0x0]
800028bc:	a1 a9       	sbr	r9,0x0
800028be:	91 09       	st.w	r8[0x0],r9
800028c0:	d8 02       	popm	pc
	}
	else if(xcmp->u8[4] != 0x02)
800028c2:	30 29       	mov	r9,2
800028c4:	f2 08 18 00 	cp.b	r8,r9
800028c8:	c0 80       	breq	800028d8 <DeviceInitializationStatus_brdcst_func+0x2c>
	{
		bunchofrandomstatusflags  &= 0xFFFFFFFC; //Device Init no longer Complete.
800028ca:	48 58       	lddpc	r8,800028dc <DeviceInitializationStatus_brdcst_func+0x30>
800028cc:	70 09       	ld.w	r9,r8[0x0]
800028ce:	e0 19 ff fc 	andl	r9,0xfffc
800028d2:	91 09       	st.w	r8[0x0],r9
		xcmp_DeviceInitializationStatus_request();
800028d4:	f0 1f 00 03 	mcall	800028e0 <DeviceInitializationStatus_brdcst_func+0x34>
800028d8:	d8 02       	popm	pc
800028da:	00 00       	add	r0,r0
800028dc:	00 00       	add	r0,r0
800028de:	0d 84       	ld.ub	r4,r6[0x0]
800028e0:	80 00       	ld.sh	r0,r0[0x0]
800028e2:	45 64       	lddsp	r4,sp[0x158]

800028e4 <send_flash_command>:
* ----------  --------  ----------  --------------------------------------------
* 10-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
U16 send_flash_command(U16 command, U32 address, U8 *data_ptr, U16 length)
{
800028e4:	eb cd 40 fc 	pushm	r2-r7,lr
800028e8:	20 1d       	sub	sp,4
800028ea:	18 97       	mov	r7,r12
800028ec:	14 95       	mov	r5,r10
800028ee:	12 96       	mov	r6,r9
	U16 status = 1;
800028f0:	30 18       	mov	r8,1
800028f2:	ba 18       	st.h	sp[0x2],r8
	U16 i = 0;

    /* in order to call spi_write(U16* data), change 3-bytes address to 3-U16 address */
	U16 addr[3];
	addr[2] = (address & 0x00ff0000) >> 16;
800028f4:	e9 db c2 08 	bfextu	r4,r11,0x10,0x8
	addr[1] = (address & 0x0000ff00) >> 8;
800028f8:	e7 db c1 08 	bfextu	r3,r11,0x8,0x8
	addr[0] = (address & 0x000000ff);
800028fc:	e5 db c0 08 	bfextu	r2,r11,0x0,0x8

	U16 data_u16;

	spi_selectChip(spi, DF_SPI_PCS_0);
80002900:	30 0b       	mov	r11,0
80002902:	4e 38       	lddpc	r8,80002a8c <send_flash_command+0x1a8>
80002904:	70 0c       	ld.w	r12,r8[0x0]
80002906:	f0 1f 00 63 	mcall	80002a90 <send_flash_command+0x1ac>

    switch (command)
8000290a:	30 58       	mov	r8,5
8000290c:	f0 07 19 00 	cp.h	r7,r8
80002910:	c3 40       	breq	80002978 <send_flash_command+0x94>
80002912:	e0 8b 00 18 	brhi	80002942 <send_flash_command+0x5e>
80002916:	30 28       	mov	r8,2
80002918:	f0 07 19 00 	cp.h	r7,r8
8000291c:	c5 e0       	breq	800029d8 <send_flash_command+0xf4>
8000291e:	e0 8b 00 08 	brhi	8000292e <send_flash_command+0x4a>
80002922:	30 18       	mov	r8,1
80002924:	f0 07 19 00 	cp.h	r7,r8
80002928:	e0 81 00 a9 	brne	80002a7a <send_flash_command+0x196>
8000292c:	c9 e8       	rjmp	80002a68 <send_flash_command+0x184>
8000292e:	30 38       	mov	r8,3
80002930:	f0 07 19 00 	cp.h	r7,r8
80002934:	c7 20       	breq	80002a18 <send_flash_command+0x134>
80002936:	30 48       	mov	r8,4
80002938:	f0 07 19 00 	cp.h	r7,r8
8000293c:	e0 81 00 9f 	brne	80002a7a <send_flash_command+0x196>
80002940:	c2 c8       	rjmp	80002998 <send_flash_command+0xb4>
80002942:	35 28       	mov	r8,82
80002944:	f0 07 19 00 	cp.h	r7,r8
80002948:	c2 f0       	breq	800029a6 <send_flash_command+0xc2>
8000294a:	e0 8b 00 0c 	brhi	80002962 <send_flash_command+0x7e>
8000294e:	30 68       	mov	r8,6
80002950:	f0 07 19 00 	cp.h	r7,r8
80002954:	c2 20       	breq	80002998 <send_flash_command+0xb4>
80002956:	32 08       	mov	r8,32
80002958:	f0 07 19 00 	cp.h	r7,r8
8000295c:	e0 81 00 8f 	brne	80002a7a <send_flash_command+0x196>
80002960:	c2 38       	rjmp	800029a6 <send_flash_command+0xc2>
80002962:	36 08       	mov	r8,96
80002964:	f0 07 19 00 	cp.h	r7,r8
80002968:	c3 20       	breq	800029cc <send_flash_command+0xe8>
8000296a:	e0 68 00 d8 	mov	r8,216
8000296e:	f0 07 19 00 	cp.h	r7,r8
80002972:	e0 81 00 84 	brne	80002a7a <send_flash_command+0x196>
80002976:	c1 88       	rjmp	800029a6 <send_flash_command+0xc2>
	{
		case READ_STATUS_REG:
			spi_write_byte(command);
80002978:	4c 57       	lddpc	r7,80002a8c <send_flash_command+0x1a8>
8000297a:	30 5b       	mov	r11,5
8000297c:	6e 0c       	ld.w	r12,r7[0x0]
8000297e:	f0 1f 00 46 	mcall	80002a94 <send_flash_command+0x1b0>
			spi_write_dummy();
80002982:	e0 6b 00 ff 	mov	r11,255
80002986:	6e 0c       	ld.w	r12,r7[0x0]
80002988:	f0 1f 00 43 	mcall	80002a94 <send_flash_command+0x1b0>
			spi_read_byte(&status);
8000298c:	fa cb ff fe 	sub	r11,sp,-2
80002990:	6e 0c       	ld.w	r12,r7[0x0]
80002992:	f0 1f 00 42 	mcall	80002a98 <send_flash_command+0x1b4>
			break;
80002996:	c7 28       	rjmp	80002a7a <send_flash_command+0x196>
		case WRITE_ENABLE:
		case WRITE_DISABLE:
			spi_write_byte(command);
80002998:	0e 9b       	mov	r11,r7
8000299a:	5c 7b       	castu.h	r11
8000299c:	4b c8       	lddpc	r8,80002a8c <send_flash_command+0x1a8>
8000299e:	70 0c       	ld.w	r12,r8[0x0]
800029a0:	f0 1f 00 3d 	mcall	80002a94 <send_flash_command+0x1b0>
			break;
800029a4:	c6 b8       	rjmp	80002a7a <send_flash_command+0x196>
		case BLOCK_ERASE_4KB:
		case BLOCK_ERASE_32KB:
		case BLOCK_ERASE_64KB:
			spi_write_byte(command);
800029a6:	4b a6       	lddpc	r6,80002a8c <send_flash_command+0x1a8>
800029a8:	0e 9b       	mov	r11,r7
800029aa:	5c 7b       	castu.h	r11
800029ac:	6c 0c       	ld.w	r12,r6[0x0]
800029ae:	f0 1f 00 3a 	mcall	80002a94 <send_flash_command+0x1b0>
			spi_write_byte(addr[2]);
800029b2:	08 9b       	mov	r11,r4
800029b4:	6c 0c       	ld.w	r12,r6[0x0]
800029b6:	f0 1f 00 38 	mcall	80002a94 <send_flash_command+0x1b0>
			spi_write_byte(addr[1]);
800029ba:	06 9b       	mov	r11,r3
800029bc:	6c 0c       	ld.w	r12,r6[0x0]
800029be:	f0 1f 00 36 	mcall	80002a94 <send_flash_command+0x1b0>
			spi_write_byte(addr[0]);
800029c2:	04 9b       	mov	r11,r2
800029c4:	6c 0c       	ld.w	r12,r6[0x0]
800029c6:	f0 1f 00 34 	mcall	80002a94 <send_flash_command+0x1b0>
			break;
800029ca:	c5 88       	rjmp	80002a7a <send_flash_command+0x196>
		case CHIP_ERASE:
			spi_write_byte(command);
800029cc:	36 0b       	mov	r11,96
800029ce:	4b 08       	lddpc	r8,80002a8c <send_flash_command+0x1a8>
800029d0:	70 0c       	ld.w	r12,r8[0x0]
800029d2:	f0 1f 00 31 	mcall	80002a94 <send_flash_command+0x1b0>
			break;
800029d6:	c5 28       	rjmp	80002a7a <send_flash_command+0x196>
		case BYTE_PROGRAM: /* PAGE_PROGRAM use the same value */
			spi_write_byte(command);
800029d8:	4a d7       	lddpc	r7,80002a8c <send_flash_command+0x1a8>
800029da:	30 2b       	mov	r11,2
800029dc:	6e 0c       	ld.w	r12,r7[0x0]
800029de:	f0 1f 00 2e 	mcall	80002a94 <send_flash_command+0x1b0>
			spi_write_byte(addr[2]);
800029e2:	08 9b       	mov	r11,r4
800029e4:	6e 0c       	ld.w	r12,r7[0x0]
800029e6:	f0 1f 00 2c 	mcall	80002a94 <send_flash_command+0x1b0>
			spi_write_byte(addr[1]);
800029ea:	06 9b       	mov	r11,r3
800029ec:	6e 0c       	ld.w	r12,r7[0x0]
800029ee:	f0 1f 00 2a 	mcall	80002a94 <send_flash_command+0x1b0>
			spi_write_byte(addr[0]);
800029f2:	04 9b       	mov	r11,r2
800029f4:	6e 0c       	ld.w	r12,r7[0x0]
800029f6:	f0 1f 00 28 	mcall	80002a94 <send_flash_command+0x1b0>
			for (i = 0; i < length; i++)
800029fa:	58 06       	cp.w	r6,0
800029fc:	c3 f0       	breq	80002a7a <send_flash_command+0x196>
800029fe:	0a 97       	mov	r7,r5
			{
				data_u16 = (*data_ptr)&0x00ff;//modified by huayi
				data_ptr++;
				spi_write_byte(data_u16);
80002a00:	4a 34       	lddpc	r4,80002a8c <send_flash_command+0x1a8>
			spi_write_byte(addr[2]);
			spi_write_byte(addr[1]);
			spi_write_byte(addr[0]);
			for (i = 0; i < length; i++)
			{
				data_u16 = (*data_ptr)&0x00ff;//modified by huayi
80002a02:	0f 3b       	ld.ub	r11,r7++
80002a04:	ba 0b       	st.h	sp[0x0],r11
				data_ptr++;
				spi_write_byte(data_u16);
80002a06:	68 0c       	ld.w	r12,r4[0x0]
80002a08:	f0 1f 00 23 	mcall	80002a94 <send_flash_command+0x1b0>
		case BYTE_PROGRAM: /* PAGE_PROGRAM use the same value */
			spi_write_byte(command);
			spi_write_byte(addr[2]);
			spi_write_byte(addr[1]);
			spi_write_byte(addr[0]);
			for (i = 0; i < length; i++)
80002a0c:	0e 98       	mov	r8,r7
80002a0e:	0a 18       	sub	r8,r5
80002a10:	ec 08 19 00 	cp.h	r8,r6
80002a14:	cf 73       	brcs	80002a02 <send_flash_command+0x11e>
80002a16:	c3 28       	rjmp	80002a7a <send_flash_command+0x196>
				data_ptr++;
				spi_write_byte(data_u16);
			}
			break;
		case READ_ARRAY:
			spi_write_byte(command);
80002a18:	49 d7       	lddpc	r7,80002a8c <send_flash_command+0x1a8>
80002a1a:	30 3b       	mov	r11,3
80002a1c:	6e 0c       	ld.w	r12,r7[0x0]
80002a1e:	f0 1f 00 1e 	mcall	80002a94 <send_flash_command+0x1b0>
			spi_write_byte(addr[2]);
80002a22:	08 9b       	mov	r11,r4
80002a24:	6e 0c       	ld.w	r12,r7[0x0]
80002a26:	f0 1f 00 1c 	mcall	80002a94 <send_flash_command+0x1b0>
			spi_write_byte(addr[1]);
80002a2a:	06 9b       	mov	r11,r3
80002a2c:	6e 0c       	ld.w	r12,r7[0x0]
80002a2e:	f0 1f 00 1a 	mcall	80002a94 <send_flash_command+0x1b0>
			spi_write_byte(addr[0]);
80002a32:	04 9b       	mov	r11,r2
80002a34:	6e 0c       	ld.w	r12,r7[0x0]
80002a36:	f0 1f 00 18 	mcall	80002a94 <send_flash_command+0x1b0>
			for (i = 0; i < length; i++)
80002a3a:	58 06       	cp.w	r6,0
80002a3c:	c1 f0       	breq	80002a7a <send_flash_command+0x196>
80002a3e:	0a 97       	mov	r7,r5
			{
				spi_write_dummy();
80002a40:	49 34       	lddpc	r4,80002a8c <send_flash_command+0x1a8>
80002a42:	e0 63 00 ff 	mov	r3,255
				spi_read_byte(&data_u16);
80002a46:	1a 92       	mov	r2,sp
			spi_write_byte(addr[2]);
			spi_write_byte(addr[1]);
			spi_write_byte(addr[0]);
			for (i = 0; i < length; i++)
			{
				spi_write_dummy();
80002a48:	06 9b       	mov	r11,r3
80002a4a:	68 0c       	ld.w	r12,r4[0x0]
80002a4c:	f0 1f 00 12 	mcall	80002a94 <send_flash_command+0x1b0>
				spi_read_byte(&data_u16);
80002a50:	1a 9b       	mov	r11,sp
80002a52:	68 0c       	ld.w	r12,r4[0x0]
80002a54:	f0 1f 00 11 	mcall	80002a98 <send_flash_command+0x1b4>
				*data_ptr = (U8)data_u16;
80002a58:	9a 08       	ld.sh	r8,sp[0x0]
80002a5a:	0e c8       	st.b	r7++,r8
		case READ_ARRAY:
			spi_write_byte(command);
			spi_write_byte(addr[2]);
			spi_write_byte(addr[1]);
			spi_write_byte(addr[0]);
			for (i = 0; i < length; i++)
80002a5c:	0e 98       	mov	r8,r7
80002a5e:	0a 18       	sub	r8,r5
80002a60:	ec 08 19 00 	cp.h	r8,r6
80002a64:	cf 23       	brcs	80002a48 <send_flash_command+0x164>
80002a66:	c0 a8       	rjmp	80002a7a <send_flash_command+0x196>
				*data_ptr = (U8)data_u16;
				data_ptr++;
			}
			break;
		case WRITE_STATUS_REG_BYTE_1:
			spi_write_byte(command);
80002a68:	48 97       	lddpc	r7,80002a8c <send_flash_command+0x1a8>
80002a6a:	30 1b       	mov	r11,1
80002a6c:	6e 0c       	ld.w	r12,r7[0x0]
80002a6e:	f0 1f 00 0a 	mcall	80002a94 <send_flash_command+0x1b0>
			spi_write_byte(UNPROTECT_ALL_SECTORS);
80002a72:	30 0b       	mov	r11,0
80002a74:	6e 0c       	ld.w	r12,r7[0x0]
80002a76:	f0 1f 00 08 	mcall	80002a94 <send_flash_command+0x1b0>
			break;
		default:
			break;
	}

	spi_unselectChip(spi, DF_SPI_PCS_0);
80002a7a:	30 0b       	mov	r11,0
80002a7c:	48 48       	lddpc	r8,80002a8c <send_flash_command+0x1a8>
80002a7e:	70 0c       	ld.w	r12,r8[0x0]
80002a80:	f0 1f 00 07 	mcall	80002a9c <send_flash_command+0x1b8>

	return status;
}
80002a84:	9a 1c       	ld.sh	r12,sp[0x2]
80002a86:	2f fd       	sub	sp,-4
80002a88:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80002a8c:	00 00       	add	r0,r0
80002a8e:	1f 88       	ld.ub	r8,pc[0x0]
80002a90:	80 00       	ld.sh	r0,r0[0x0]
80002a92:	4f e0       	lddpc	r0,80002c88 <data_flash_erase_block+0x54>
80002a94:	80 00       	ld.sh	r0,r0[0x0]
80002a96:	51 1a       	stdsp	sp[0x44],r10
80002a98:	80 00       	ld.sh	r0,r0[0x0]
80002a9a:	51 36       	stdsp	sp[0x4c],r6
80002a9c:	80 00       	ld.sh	r0,r0[0x0]
80002a9e:	50 2c       	stdsp	sp[0x8],r12

80002aa0 <data_flash_read_block>:
* ----------  --------  ----------  --------------------------------------------
* 25-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_read_block(U32 address, U16 length, U8 *data_ptr)
{
80002aa0:	d4 01       	pushm	lr
	/* check input parameter */
	if (data_ptr == NULL || address >= DF_MAX_ADDR || length > 0x1000)
80002aa2:	58 0a       	cp.w	r10,0
80002aa4:	5f 09       	sreq	r9
80002aa6:	e0 68 ff fe 	mov	r8,65534
80002aaa:	ea 18 00 7f 	orh	r8,0x7f
80002aae:	10 3c       	cp.w	r12,r8
80002ab0:	5f b8       	srhi	r8
80002ab2:	f3 e8 10 08 	or	r8,r9,r8
80002ab6:	c0 e1       	brne	80002ad2 <data_flash_read_block+0x32>
80002ab8:	e0 68 10 00 	mov	r8,4096
80002abc:	f0 0b 19 00 	cp.h	r11,r8
80002ac0:	e0 8b 00 09 	brhi	80002ad2 <data_flash_read_block+0x32>
	{
		return DF_INVALID_PARAM;
	}

	send_flash_command(READ_ARRAY, address, data_ptr, length);
80002ac4:	f3 db c0 10 	bfextu	r9,r11,0x0,0x10
80002ac8:	18 9b       	mov	r11,r12
80002aca:	30 3c       	mov	r12,3
80002acc:	f0 1f 00 02 	mcall	80002ad4 <data_flash_read_block+0x34>
80002ad0:	d8 0a       	popm	pc,r12=0

	return DF_OK;
80002ad2:	da 0a       	popm	pc,r12=1
80002ad4:	80 00       	ld.sh	r0,r0[0x0]
80002ad6:	28 e4       	sub	r4,-114

80002ad8 <data_flash_write_page>:
* ----------  --------  ----------  --------------------------------------------
* 25-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_write_page(U8 *data_ptr, U32 address, U16 length)
{
80002ad8:	eb cd 40 e0 	pushm	r5-r7,lr
80002adc:	18 96       	mov	r6,r12
80002ade:	16 97       	mov	r7,r11
80002ae0:	14 95       	mov	r5,r10
	U16 status = 1;
	df_status_t return_code = DF_WRITE_FAIL;
	U16 count = 0; /* to monitor write time consumption */

	/* check input parameter */
	if (data_ptr == NULL || address >= DF_MAX_ADDR || length > DF_PAGE_SIZE)
80002ae2:	58 0c       	cp.w	r12,0
80002ae4:	5f 09       	sreq	r9
80002ae6:	e0 68 ff fe 	mov	r8,65534
80002aea:	ea 18 00 7f 	orh	r8,0x7f
80002aee:	10 3b       	cp.w	r11,r8
80002af0:	5f b8       	srhi	r8
80002af2:	f3 e8 10 08 	or	r8,r9,r8
80002af6:	c3 91       	brne	80002b68 <data_flash_write_page+0x90>
80002af8:	e0 68 01 00 	mov	r8,256
80002afc:	f0 0a 19 00 	cp.h	r10,r8
80002b00:	e0 8b 00 34 	brhi	80002b68 <data_flash_write_page+0x90>
	{
		return DF_INVALID_PARAM;
	}

	status = send_flash_command(READ_STATUS_REG, 0, NULL, 0);
80002b04:	30 09       	mov	r9,0
80002b06:	12 9a       	mov	r10,r9
80002b08:	12 9b       	mov	r11,r9
80002b0a:	30 5c       	mov	r12,5
80002b0c:	f0 1f 00 19 	mcall	80002b70 <data_flash_write_page+0x98>
	if ((status & STATUS_BUSY) != 0)
80002b10:	f9 dc c0 01 	bfextu	r12,r12,0x0,0x1
80002b14:	c0 30       	breq	80002b1a <data_flash_write_page+0x42>
80002b16:	30 27       	mov	r7,2
80002b18:	c2 98       	rjmp	80002b6a <data_flash_write_page+0x92>
	{
		return DF_DEVICE_BUSY;
	}

	/* send WRITE_ENABLE command */
	send_flash_command(WRITE_ENABLE, 0, NULL, 0);
80002b1a:	30 09       	mov	r9,0
80002b1c:	12 9a       	mov	r10,r9
80002b1e:	12 9b       	mov	r11,r9
80002b20:	30 6c       	mov	r12,6
80002b22:	f0 1f 00 14 	mcall	80002b70 <data_flash_write_page+0x98>

	/* send PAGE_PROGRAM command */
	send_flash_command(PAGE_PROGRAM, address, data_ptr, length);
80002b26:	f3 d5 c0 10 	bfextu	r9,r5,0x0,0x10
80002b2a:	0c 9a       	mov	r10,r6
80002b2c:	0e 9b       	mov	r11,r7
80002b2e:	30 2c       	mov	r12,2
80002b30:	f0 1f 00 10 	mcall	80002b70 <data_flash_write_page+0x98>
	do {
		status = send_flash_command(READ_STATUS_REG, 0, NULL, 0);
80002b34:	30 05       	mov	r5,0
80002b36:	30 56       	mov	r6,5
80002b38:	0a 99       	mov	r9,r5
80002b3a:	0a 9a       	mov	r10,r5
80002b3c:	0a 9b       	mov	r11,r5
80002b3e:	0c 9c       	mov	r12,r6
80002b40:	f0 1f 00 0c 	mcall	80002b70 <data_flash_write_page+0x98>
		count++;
	} while((status & STATUS_BUSY) != 0);
80002b44:	5c 7c       	castu.h	r12
80002b46:	f1 dc c0 01 	bfextu	r8,r12,0x0,0x1
80002b4a:	cf 71       	brne	80002b38 <data_flash_write_page+0x60>

	/*  Check Status Register */
	if ((status & STATUS_ERASE_PROG_ERROR) != 0)
80002b4c:	18 97       	mov	r7,r12
80002b4e:	e2 17 00 20 	andl	r7,0x20,COH
80002b52:	f9 b7 01 06 	movne	r7,6
80002b56:	f9 b7 00 07 	moveq	r7,7
		/*  Erase Successful.  */
		return_code = DF_WRITE_COMPLETED;
	}

	/* send WRITE_DISABLE command */
	send_flash_command(WRITE_DISABLE, 0, NULL, 0);
80002b5a:	30 09       	mov	r9,0
80002b5c:	12 9a       	mov	r10,r9
80002b5e:	12 9b       	mov	r11,r9
80002b60:	30 4c       	mov	r12,4
80002b62:	f0 1f 00 04 	mcall	80002b70 <data_flash_write_page+0x98>

	return return_code;
80002b66:	c0 28       	rjmp	80002b6a <data_flash_write_page+0x92>
80002b68:	30 17       	mov	r7,1
}
80002b6a:	0e 9c       	mov	r12,r7
80002b6c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80002b70:	80 00       	ld.sh	r0,r0[0x0]
80002b72:	28 e4       	sub	r4,-114

80002b74 <data_flash_write_block>:
* ----------  --------  ----------  --------------------------------------------
* 25-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_write_block(U8 *data_ptr, U32 address, U16 data_length)
{
80002b74:	d4 31       	pushm	r0-r7,lr
80002b76:	18 94       	mov	r4,r12
80002b78:	ed da b0 10 	bfexts	r6,r10,0x0,0x10
80002b7c:	16 97       	mov	r7,r11
80002b7e:	30 7c       	mov	r12,7
	df_status_t return_code = DF_WRITE_COMPLETED;
	U32 write_addr = address;
	U16 bytes_remained = data_length;

	while (bytes_remained >= 1 && return_code == DF_WRITE_COMPLETED)
80002b80:	30 03       	mov	r3,0
80002b82:	06 92       	mov	r2,r3
	{
		if ((write_addr & 0xFF) == 0)
		{
			/* address 256 bytes aligned */

			if (bytes_remained <= DF_PAGE_SIZE)
80002b84:	e0 60 01 00 	mov	r0,256
{
	df_status_t return_code = DF_WRITE_COMPLETED;
	U32 write_addr = address;
	U16 bytes_remained = data_length;

	while (bytes_remained >= 1 && return_code == DF_WRITE_COMPLETED)
80002b88:	c4 98       	rjmp	80002c1a <data_flash_write_block+0xa6>
	{
		if ((write_addr & 0xFF) == 0)
80002b8a:	eb d7 c0 08 	bfextu	r5,r7,0x0,0x8
80002b8e:	c1 b1       	brne	80002bc4 <data_flash_write_block+0x50>
		{
			/* address 256 bytes aligned */

			if (bytes_remained <= DF_PAGE_SIZE)
80002b90:	e0 06 19 00 	cp.h	r6,r0
80002b94:	e0 8b 00 0a 	brhi	80002ba8 <data_flash_write_block+0x34>
			{
				/* bytes remained less than one page */
				return_code = data_flash_write_page(data_ptr, write_addr, bytes_remained);
80002b98:	f5 d6 c0 10 	bfextu	r10,r6,0x0,0x10
80002b9c:	0e 9b       	mov	r11,r7
80002b9e:	08 9c       	mov	r12,r4
80002ba0:	f0 1f 00 24 	mcall	80002c30 <data_flash_write_block+0xbc>
80002ba4:	30 06       	mov	r6,0
80002ba6:	c3 a8       	rjmp	80002c1a <data_flash_write_block+0xa6>
				bytes_remained = 0;	/* end while loop */
			}
			else /* (bytes_remained > DF_PAGE_SIZE) */
			{
				/* bytes remained more than one page */
				return_code = data_flash_write_page(data_ptr, write_addr, DF_PAGE_SIZE);
80002ba8:	e0 6a 01 00 	mov	r10,256
80002bac:	0e 9b       	mov	r11,r7
80002bae:	08 9c       	mov	r12,r4
80002bb0:	f0 1f 00 20 	mcall	80002c30 <data_flash_write_block+0xbc>
				bytes_remained -= DF_PAGE_SIZE;
80002bb4:	ec c6 01 00 	sub	r6,r6,256
80002bb8:	5c 86       	casts.h	r6
				data_ptr += DF_PAGE_SIZE;
80002bba:	e8 c4 ff 00 	sub	r4,r4,-256
				write_addr += DF_PAGE_SIZE;
80002bbe:	ee c7 ff 00 	sub	r7,r7,-256
80002bc2:	c2 c8       	rjmp	80002c1a <data_flash_write_block+0xa6>
		}
		else
		{
			/*(write_addr & 0xFF != 0), address not 256 bytes aligned */

			if (BEYOND_PAGE_BOUNDARY(write_addr, bytes_remained) == TRUE)
80002bc4:	f3 d6 c0 10 	bfextu	r9,r6,0x0,0x10
80002bc8:	0e 09       	add	r9,r7
80002bca:	0e 98       	mov	r8,r7
80002bcc:	e4 18 00 7f 	andh	r8,0x7f
80002bd0:	e0 18 ff 00 	andl	r8,0xff00
80002bd4:	f0 c8 ff 00 	sub	r8,r8,-256
80002bd8:	10 39       	cp.w	r9,r8
80002bda:	e0 88 00 19 	brls	80002c0c <data_flash_write_block+0x98>
			{
				/* bytes remained exceed current page, only write data within current page */
				return_code = data_flash_write_page(data_ptr, write_addr, BYTES_TO_NEXT_PAGE_BOUNDARY(write_addr));
80002bde:	0e 91       	mov	r1,r7
80002be0:	5c 51       	castu.b	r1
80002be2:	e0 6a 01 00 	mov	r10,256
80002be6:	02 1a       	sub	r10,r1
80002be8:	5c 7a       	castu.h	r10
80002bea:	0e 9b       	mov	r11,r7
80002bec:	08 9c       	mov	r12,r4
80002bee:	f0 1f 00 11 	mcall	80002c30 <data_flash_write_block+0xbc>
				bytes_remained -= BYTES_TO_NEXT_PAGE_BOUNDARY(write_addr);
80002bf2:	ec c6 01 00 	sub	r6,r6,256
80002bf6:	02 06       	add	r6,r1
80002bf8:	5c 86       	casts.h	r6
				data_ptr += BYTES_TO_NEXT_PAGE_BOUNDARY(write_addr);
80002bfa:	e0 68 01 00 	mov	r8,256
80002bfe:	f0 05 01 05 	sub	r5,r8,r5
80002c02:	0a 04       	add	r4,r5
				write_addr += BYTES_TO_NEXT_PAGE_BOUNDARY(write_addr); /* now became 256 bytes aligned */
80002c04:	e0 17 ff 00 	andl	r7,0xff00
80002c08:	10 07       	add	r7,r8
80002c0a:	c0 88       	rjmp	80002c1a <data_flash_write_block+0xa6>
			}
			else
			{
				/* bytes remained not exceed current page */
				return_code = data_flash_write_page(data_ptr, write_addr, bytes_remained);
80002c0c:	f5 d6 c0 10 	bfextu	r10,r6,0x0,0x10
80002c10:	0e 9b       	mov	r11,r7
80002c12:	08 9c       	mov	r12,r4
80002c14:	f0 1f 00 07 	mcall	80002c30 <data_flash_write_block+0xbc>
80002c18:	30 06       	mov	r6,0
{
	df_status_t return_code = DF_WRITE_COMPLETED;
	U32 write_addr = address;
	U16 bytes_remained = data_length;

	while (bytes_remained >= 1 && return_code == DF_WRITE_COMPLETED)
80002c1a:	e6 06 19 00 	cp.h	r6,r3
80002c1e:	5f 19       	srne	r9
80002c20:	58 7c       	cp.w	r12,7
80002c22:	5f 08       	sreq	r8
80002c24:	f3 e8 00 08 	and	r8,r9,r8
80002c28:	e4 08 18 00 	cp.b	r8,r2
80002c2c:	ca f1       	brne	80002b8a <data_flash_write_block+0x16>
			}
		}
	}	/* end of while */

	return return_code;
}
80002c2e:	d8 32       	popm	r0-r7,pc
80002c30:	80 00       	ld.sh	r0,r0[0x0]
80002c32:	2a d8       	sub	r8,-83

80002c34 <data_flash_erase_block>:
* ----------  --------  ----------  --------------------------------------------
* 25-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_erase_block(U32 address, df_block_size_t block_size)
{
80002c34:	eb cd 40 c0 	pushm	r6-r7,lr
80002c38:	18 97       	mov	r7,r12
	U16 erase_commond;
	df_status_t return_code = DF_ERASE_FAIL;
	U16 count = 0; /* to monitor erase time consumption */

	/* check input parameter */
	if (address >= DF_MAX_ADDR)
80002c3a:	e0 68 ff fe 	mov	r8,65534
80002c3e:	ea 18 00 7f 	orh	r8,0x7f
80002c42:	10 3c       	cp.w	r12,r8
80002c44:	e0 88 00 04 	brls	80002c4c <data_flash_erase_block+0x18>
80002c48:	30 17       	mov	r7,1
80002c4a:	c3 e8       	rjmp	80002cc6 <data_flash_erase_block+0x92>
	{
		return DF_INVALID_PARAM;
	}

	/* determine erase command to be issued */
	if (block_size == DF_BLOCK_4KB)
80002c4c:	58 1b       	cp.w	r11,1
80002c4e:	c0 31       	brne	80002c54 <data_flash_erase_block+0x20>
80002c50:	32 06       	mov	r6,32
80002c52:	c0 a8       	rjmp	80002c66 <data_flash_erase_block+0x32>
		erase_commond = BLOCK_ERASE_4KB;
	else if (block_size == DF_BLOCK_32KB)
80002c54:	58 2b       	cp.w	r11,2
80002c56:	c0 31       	brne	80002c5c <data_flash_erase_block+0x28>
80002c58:	35 26       	mov	r6,82
80002c5a:	c0 68       	rjmp	80002c66 <data_flash_erase_block+0x32>
		erase_commond = BLOCK_ERASE_32KB;
	else if(block_size == DF_BLOCK_64KB)
80002c5c:	e0 66 00 d8 	mov	r6,216
80002c60:	58 3b       	cp.w	r11,3
80002c62:	f9 b6 01 60 	movne	r6,96
		erase_commond = BLOCK_ERASE_64KB;
	else/*(block_size == DF_BLOCK_ALL)*/
		erase_commond = CHIP_ERASE;

	status = send_flash_command(READ_STATUS_REG, 0, NULL, 0);
80002c66:	30 09       	mov	r9,0
80002c68:	12 9a       	mov	r10,r9
80002c6a:	12 9b       	mov	r11,r9
80002c6c:	30 5c       	mov	r12,5
80002c6e:	f0 1f 00 18 	mcall	80002ccc <data_flash_erase_block+0x98>
	if ((status & STATUS_BUSY) != 0)
80002c72:	f9 dc c0 01 	bfextu	r12,r12,0x0,0x1
80002c76:	c0 30       	breq	80002c7c <data_flash_erase_block+0x48>
80002c78:	30 27       	mov	r7,2
80002c7a:	c2 68       	rjmp	80002cc6 <data_flash_erase_block+0x92>
	{
		return DF_DEVICE_BUSY;
	}

	/* send WRITE_ENABLE command */
	send_flash_command(WRITE_ENABLE, 0, NULL, 0);
80002c7c:	30 09       	mov	r9,0
80002c7e:	12 9a       	mov	r10,r9
80002c80:	12 9b       	mov	r11,r9
80002c82:	30 6c       	mov	r12,6
80002c84:	f0 1f 00 12 	mcall	80002ccc <data_flash_erase_block+0x98>

	/* send BLOCK_ERASE command */
	send_flash_command(erase_commond, address, NULL, 0);
80002c88:	30 09       	mov	r9,0
80002c8a:	12 9a       	mov	r10,r9
80002c8c:	0e 9b       	mov	r11,r7
80002c8e:	0c 9c       	mov	r12,r6
80002c90:	f0 1f 00 0f 	mcall	80002ccc <data_flash_erase_block+0x98>
	do {
		status = send_flash_command(READ_STATUS_REG, 0, NULL, 0);
80002c94:	30 06       	mov	r6,0
80002c96:	30 57       	mov	r7,5
80002c98:	0c 99       	mov	r9,r6
80002c9a:	0c 9a       	mov	r10,r6
80002c9c:	0c 9b       	mov	r11,r6
80002c9e:	0e 9c       	mov	r12,r7
80002ca0:	f0 1f 00 0b 	mcall	80002ccc <data_flash_erase_block+0x98>
		count++;
	} while((status & STATUS_BUSY) != 0);
80002ca4:	5c 7c       	castu.h	r12
80002ca6:	f1 dc c0 01 	bfextu	r8,r12,0x0,0x1
80002caa:	cf 71       	brne	80002c98 <data_flash_erase_block+0x64>

	/*  Check Status Register */
	if ((status & STATUS_ERASE_PROG_ERROR) != 0)
80002cac:	18 97       	mov	r7,r12
80002cae:	e2 17 00 20 	andl	r7,0x20,COH
80002cb2:	f9 b7 01 04 	movne	r7,4
80002cb6:	f9 b7 00 05 	moveq	r7,5
		/*  Erase Successful.  */
		return_code = DF_ERASE_COMPLETED;
	}

	/* send WRITE_DISABLE command */
	send_flash_command(WRITE_DISABLE, 0, NULL, 0);
80002cba:	30 09       	mov	r9,0
80002cbc:	12 9a       	mov	r10,r9
80002cbe:	12 9b       	mov	r11,r9
80002cc0:	30 4c       	mov	r12,4
80002cc2:	f0 1f 00 03 	mcall	80002ccc <data_flash_erase_block+0x98>

	return return_code;
}
80002cc6:	0e 9c       	mov	r12,r7
80002cc8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002ccc:	80 00       	ld.sh	r0,r0[0x0]
80002cce:	28 e4       	sub	r4,-114

80002cd0 <data_flash_write>:
* ----------  --------  ----------  --------------------------------------------
* 25-Fri-17   Edwards    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_write(U8 *data_ptr, U32 address, U16 data_length)
{
80002cd0:	d4 31       	pushm	r0-r7,lr
80002cd2:	20 3d       	sub	sp,12
80002cd4:	50 0c       	stdsp	sp[0x0],r12
80002cd6:	16 91       	mov	r1,r11
80002cd8:	14 95       	mov	r5,r10
	U16 secremain;
	U16 i;
	df_status_t return_code = DF_OK;

	secpos	=	address/4096;//扇区地址 0~2047 for AT25DF641 
	secoff	=	address%4096;//在扇区内的偏移
80002cda:	f5 db c0 0c 	bfextu	r10,r11,0x0,0xc
80002cde:	50 1a       	stdsp	sp[0x4],r10
	secremain	=	4096-secoff;//扇区剩余空间大小
80002ce0:	e0 69 10 00 	mov	r9,4096
80002ce4:	f2 0a 01 07 	sub	r7,r9,r10
80002ce8:	ea 07 19 00 	cp.h	r7,r5
80002cec:	ea 07 17 b0 	movhi	r7,r5
80002cf0:	5c 87       	casts.h	r7
80002cf2:	16 92       	mov	r2,r11
80002cf4:	e0 12 f0 00 	andl	r2,0xf000
	if(data_length <= secremain)secremain = data_length;//不大于4096个字节
	while(1)
	{
		data_flash_read_block(secpos*4096, 4096, FLASH_BUF);//读出整个扇区的内容
80002cf8:	4a e4       	lddpc	r4,80002db0 <data_flash_write+0xe0>
		for(i=0; i<secremain; i++)//校验数据
		{
			if(FLASH_BUF[secoff+i]!=0XFF)break;//需要擦除
80002cfa:	3f f6       	mov	r6,-1
* Date        Name      Prob#       Description
* ----------  --------  ----------  --------------------------------------------
* 25-Fri-17   Edwards    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_write(U8 *data_ptr, U32 address, U16 data_length)
80002cfc:	e8 c8 ff ff 	sub	r8,r4,-1
80002d00:	50 28       	stdsp	sp[0x8],r8
			secpos++;//扇区地址增1
			secoff=0;//偏移位置为0

			data_ptr+=secremain;  //指针偏移
			address+=secremain;//写地址偏移
			data_length-=secremain;				//字节数递减
80002d02:	12 90       	mov	r0,r9
	secoff	=	address%4096;//在扇区内的偏移
	secremain	=	4096-secoff;//扇区剩余空间大小
	if(data_length <= secremain)secremain = data_length;//不大于4096个字节
	while(1)
	{
		data_flash_read_block(secpos*4096, 4096, FLASH_BUF);//读出整个扇区的内容
80002d04:	08 9a       	mov	r10,r4
80002d06:	e0 6b 10 00 	mov	r11,4096
80002d0a:	04 9c       	mov	r12,r2
80002d0c:	f0 1f 00 2a 	mcall	80002db4 <data_flash_write+0xe4>
		for(i=0; i<secremain; i++)//校验数据
80002d10:	58 07       	cp.w	r7,0
80002d12:	c3 00       	breq	80002d72 <data_flash_write+0xa2>
		{
			if(FLASH_BUF[secoff+i]!=0XFF)break;//需要擦除
80002d14:	40 13       	lddsp	r3,sp[0x4]
80002d16:	5c 73       	castu.h	r3
80002d18:	e8 03 07 08 	ld.ub	r8,r4[r3]
80002d1c:	ec 08 18 00 	cp.b	r8,r6
80002d20:	c1 11       	brne	80002d42 <data_flash_write+0x72>
80002d22:	e6 c9 ff ff 	sub	r9,r3,-1
80002d26:	08 09       	add	r9,r4
80002d28:	30 08       	mov	r8,0
80002d2a:	c0 58       	rjmp	80002d34 <data_flash_write+0x64>
80002d2c:	13 3a       	ld.ub	r10,r9++
80002d2e:	ec 0a 18 00 	cp.b	r10,r6
80002d32:	c0 81       	brne	80002d42 <data_flash_write+0x72>
	secremain	=	4096-secoff;//扇区剩余空间大小
	if(data_length <= secremain)secremain = data_length;//不大于4096个字节
	while(1)
	{
		data_flash_read_block(secpos*4096, 4096, FLASH_BUF);//读出整个扇区的内容
		for(i=0; i<secremain; i++)//校验数据
80002d34:	2f f8       	sub	r8,-1
80002d36:	5c 88       	casts.h	r8
80002d38:	f0 07 19 00 	cp.h	r7,r8
80002d3c:	fe 9b ff f8 	brhi	80002d2c <data_flash_write+0x5c>
80002d40:	c1 98       	rjmp	80002d72 <data_flash_write+0xa2>
		{
			if(FLASH_BUF[secoff+i]!=0XFF)break;//需要擦除
		}
		if(i < secremain)//需要擦除
		{
			return_code = data_flash_erase_block(secpos*4096, DF_BLOCK_4KB);//擦除这个扇区
80002d42:	30 1b       	mov	r11,1
80002d44:	04 9c       	mov	r12,r2
80002d46:	f0 1f 00 1d 	mcall	80002db8 <data_flash_write+0xe8>
80002d4a:	40 08       	lddsp	r8,sp[0x0]
80002d4c:	08 03       	add	r3,r4
* Date        Name      Prob#       Description
* ----------  --------  ----------  --------------------------------------------
* 25-Fri-17   Edwards    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_write(U8 *data_ptr, U32 address, U16 data_length)
80002d4e:	40 2a       	lddsp	r10,sp[0x8]
80002d50:	40 19       	lddsp	r9,sp[0x4]
80002d52:	12 0a       	add	r10,r9
80002d54:	0e 99       	mov	r9,r7
80002d56:	20 19       	sub	r9,1
80002d58:	5c 79       	castu.h	r9
80002d5a:	12 0a       	add	r10,r9
		if(i < secremain)//需要擦除
		{
			return_code = data_flash_erase_block(secpos*4096, DF_BLOCK_4KB);//擦除这个扇区
			for(i=0; i<secremain; i++)	   //复制
			{
				FLASH_BUF[i+secoff]=data_ptr[i];
80002d5c:	11 39       	ld.ub	r9,r8++
80002d5e:	06 c9       	st.b	r3++,r9
			if(FLASH_BUF[secoff+i]!=0XFF)break;//需要擦除
		}
		if(i < secremain)//需要擦除
		{
			return_code = data_flash_erase_block(secpos*4096, DF_BLOCK_4KB);//擦除这个扇区
			for(i=0; i<secremain; i++)	   //复制
80002d60:	14 33       	cp.w	r3,r10
80002d62:	cf d1       	brne	80002d5c <data_flash_write+0x8c>
			{
				FLASH_BUF[i+secoff]=data_ptr[i];
			}
			return_code = data_flash_write_block(FLASH_BUF, secpos*4096, 4096);//写入整个扇区
80002d64:	e0 6a 10 00 	mov	r10,4096
80002d68:	04 9b       	mov	r11,r2
80002d6a:	08 9c       	mov	r12,r4
80002d6c:	f0 1f 00 14 	mcall	80002dbc <data_flash_write+0xec>
80002d70:	c0 78       	rjmp	80002d7e <data_flash_write+0xae>

		}
		else 
		{
			return_code = data_flash_write_block(data_ptr, address, secremain);//写已经擦除了的,直接写入扇区剩余区间.
80002d72:	0e 9a       	mov	r10,r7
80002d74:	5c 7a       	castu.h	r10
80002d76:	02 9b       	mov	r11,r1
80002d78:	40 0c       	lddsp	r12,sp[0x0]
80002d7a:	f0 1f 00 11 	mcall	80002dbc <data_flash_write+0xec>
80002d7e:	e4 c2 f0 00 	sub	r2,r2,-4096
		}
		if(data_length==secremain)break;//写入结束了
80002d82:	0e 98       	mov	r8,r7
80002d84:	ee 05 19 00 	cp.h	r5,r7
80002d88:	c1 20       	breq	80002dac <data_flash_write+0xdc>
		else//写入未结束
		{
			secpos++;//扇区地址增1
			secoff=0;//偏移位置为0

			data_ptr+=secremain;  //指针偏移
80002d8a:	5c 78       	castu.h	r8
80002d8c:	40 0a       	lddsp	r10,sp[0x0]
80002d8e:	10 0a       	add	r10,r8
80002d90:	50 0a       	stdsp	sp[0x0],r10
			address+=secremain;//写地址偏移
80002d92:	10 01       	add	r1,r8
			data_length-=secremain;				//字节数递减
80002d94:	0e 15       	sub	r5,r7
80002d96:	5c 85       	casts.h	r5
80002d98:	e0 05 19 00 	cp.h	r5,r0
80002d9c:	ea 07 17 80 	movls	r7,r5
80002da0:	e0 07 17 b0 	movhi	r7,r0
80002da4:	5c 87       	casts.h	r7
80002da6:	30 09       	mov	r9,0
80002da8:	50 19       	stdsp	sp[0x4],r9
80002daa:	ca db       	rjmp	80002d04 <data_flash_write+0x34>
		}
	}
	
	return return_code;
	
}
80002dac:	2f dd       	sub	sp,-12
80002dae:	d8 32       	popm	r0-r7,pc
80002db0:	00 00       	add	r0,r0
80002db2:	0d 88       	ld.ub	r8,r6[0x0]
80002db4:	80 00       	ld.sh	r0,r0[0x0]
80002db6:	2a a0       	sub	r0,-86
80002db8:	80 00       	ld.sh	r0,r0[0x0]
80002dba:	2c 34       	sub	r4,-61
80002dbc:	80 00       	ld.sh	r0,r0[0x0]
80002dbe:	2b 74       	sub	r4,-73

80002dc0 <data_flash_init>:
* ----------  --------  ----------  --------------------------------------------
* 10-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
void data_flash_init(void)
{
80002dc0:	d4 31       	pushm	r0-r7,lr
80002dc2:	20 7d       	sub	sp,28
		.spck_delay   = 0,
		.trans_delay  = 0,
		.stay_act     = 1,
		.spi_mode     = 0,
		.modfdis      = 1
	};
80002dc4:	fe f8 02 10 	ld.w	r8,pc[528]
80002dc8:	fa c6 ff f4 	sub	r6,sp,-12
80002dcc:	f0 ea 00 00 	ld.d	r10,r8[0]
80002dd0:	ec eb 00 00 	st.d	r6[0],r10
80002dd4:	f0 e8 00 08 	ld.d	r8,r8[8]
80002dd8:	ec e9 00 08 	st.d	r6[8],r8

	// Assign I/Os to SPI.
	gpio_enable_module(DF_SPI_GPIO_MAP, sizeof(DF_SPI_GPIO_MAP) / sizeof(DF_SPI_GPIO_MAP[0]));
80002ddc:	30 4b       	mov	r11,4
80002dde:	4f fc       	lddpc	r12,80002fd8 <data_flash_init+0x218>
80002de0:	f0 1f 00 7f 	mcall	80002fdc <data_flash_init+0x21c>

	// Configure PA25 as WP pin - 1: deasserted (allow write) always
	gpio_enable_gpio_pin(AVR32_PIN_PA25);
80002de4:	31 9c       	mov	r12,25
80002de6:	f0 1f 00 7f 	mcall	80002fe0 <data_flash_init+0x220>
 	gpio_set_gpio_pin(AVR32_PIN_PA25);
80002dea:	31 9c       	mov	r12,25
80002dec:	f0 1f 00 7e 	mcall	80002fe4 <data_flash_init+0x224>

	spi = &AVR32_SPI;
80002df0:	4f e7       	lddpc	r7,80002fe8 <data_flash_init+0x228>
80002df2:	fe 7c 24 00 	mov	r12,-56320
80002df6:	8f 0c       	st.w	r7[0x0],r12

	// Initialize as master.
	spi_initMaster(spi, &spiOptions);
80002df8:	0c 9b       	mov	r11,r6
80002dfa:	f0 1f 00 7d 	mcall	80002fec <data_flash_init+0x22c>

	// Set selection mode: variable_ps, pcs_decode, delay.
	spi_selectionMode(spi, 0, 0, 0);
80002dfe:	30 09       	mov	r9,0
80002e00:	12 9a       	mov	r10,r9
80002e02:	12 9b       	mov	r11,r9
80002e04:	6e 0c       	ld.w	r12,r7[0x0]
80002e06:	f0 1f 00 7b 	mcall	80002ff0 <data_flash_init+0x230>

	// Enable SPI.
	spi_enable(spi);
80002e0a:	6e 0c       	ld.w	r12,r7[0x0]
80002e0c:	f0 1f 00 7a 	mcall	80002ff4 <data_flash_init+0x234>

	// Initialize data flash with SPI clock Osc0.
	if (spi_setupChipReg(spi, &spiOptions, 2*FOSC0) != SPI_OK)
80002e10:	e0 6a 36 00 	mov	r10,13824
80002e14:	ea 1a 01 6e 	orh	r10,0x16e
80002e18:	0c 9b       	mov	r11,r6
80002e1a:	6e 0c       	ld.w	r12,r7[0x0]
80002e1c:	f0 1f 00 77 	mcall	80002ff8 <data_flash_init+0x238>
80002e20:	c0 50       	breq	80002e2a <data_flash_init+0x6a>
	{
		//fatal_error(FATAL_ERROR_DATA_FLASH_SPI_INIT);
		data_flash_failure = FATAL_ERROR_DATA_FLASH_SPI_INIT;
80002e22:	30 29       	mov	r9,2
80002e24:	4f 68       	lddpc	r8,80002ffc <data_flash_init+0x23c>
80002e26:	b0 89       	st.b	r8[0x0],r9
		return;
80002e28:	cd 38       	rjmp	80002fce <data_flash_init+0x20e>
* 10-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
static Bool data_flash_check_device_id(void)
{
	U16 manufacturer_device_id[2] = {0x5A5A, 0x5A5A};
80002e2a:	1a 96       	mov	r6,sp
80002e2c:	30 4a       	mov	r10,4
80002e2e:	4f 5b       	lddpc	r11,80003000 <data_flash_init+0x240>
80002e30:	1a 9c       	mov	r12,sp
80002e32:	f0 1f 00 75 	mcall	80003004 <data_flash_init+0x244>

	/* DF memory check. */
	/* Select the DF memory to check. */
	spi_selectChip(spi, DF_SPI_PCS_0);
80002e36:	4e d7       	lddpc	r7,80002fe8 <data_flash_init+0x228>
80002e38:	30 0b       	mov	r11,0
80002e3a:	6e 0c       	ld.w	r12,r7[0x0]
80002e3c:	f0 1f 00 73 	mcall	80003008 <data_flash_init+0x248>

	/* Send the Status Register Read command. */
	spi_write(spi, READ_M_D_ID);
80002e40:	e0 6b 00 9f 	mov	r11,159
80002e44:	6e 0c       	ld.w	r12,r7[0x0]
80002e46:	f0 1f 00 72 	mcall	8000300c <data_flash_init+0x24c>

	/* Send 2 dummy byte to read the status register. */
	spi_write_dummy();
80002e4a:	e0 6b 00 ff 	mov	r11,255
80002e4e:	6e 0c       	ld.w	r12,r7[0x0]
80002e50:	f0 1f 00 6f 	mcall	8000300c <data_flash_init+0x24c>
	spi_read(spi, &manufacturer_device_id[0]);
80002e54:	1a 9b       	mov	r11,sp
80002e56:	6e 0c       	ld.w	r12,r7[0x0]
80002e58:	f0 1f 00 6e 	mcall	80003010 <data_flash_init+0x250>
	spi_write_dummy();
80002e5c:	e0 6b 00 ff 	mov	r11,255
80002e60:	6e 0c       	ld.w	r12,r7[0x0]
80002e62:	f0 1f 00 6b 	mcall	8000300c <data_flash_init+0x24c>
	spi_read(spi, &manufacturer_device_id[1]);
80002e66:	fa cb ff fe 	sub	r11,sp,-2
80002e6a:	6e 0c       	ld.w	r12,r7[0x0]
80002e6c:	f0 1f 00 69 	mcall	80003010 <data_flash_init+0x250>

	/* Unselect the checked DF memory. */
	spi_unselectChip(spi, DF_SPI_PCS_0);
80002e70:	30 0b       	mov	r11,0
80002e72:	6e 0c       	ld.w	r12,r7[0x0]
80002e74:	f0 1f 00 68 	mcall	80003014 <data_flash_init+0x254>

	/* Unexpected device ID. */
    if ((manufacturer_device_id[0] != 0x1F) || (manufacturer_device_id[1] != 0x48))
80002e78:	31 f8       	mov	r8,31
80002e7a:	9a 09       	ld.sh	r9,sp[0x0]
80002e7c:	f0 09 19 00 	cp.h	r9,r8
80002e80:	c0 61       	brne	80002e8c <data_flash_init+0xcc>
80002e82:	34 88       	mov	r8,72
80002e84:	9a 19       	ld.sh	r9,sp[0x2]
80002e86:	f0 09 19 00 	cp.h	r9,r8
80002e8a:	c0 50       	breq	80002e94 <data_flash_init+0xd4>
	}

	if (data_flash_check_device_id() != TRUE)
	{
		//fatal_error(FATAL_ERROR_DATA_FLASH_READ_ID);
		data_flash_failure = FATAL_ERROR_DATA_FLASH_READ_ID;
80002e8c:	30 39       	mov	r9,3
80002e8e:	4d c8       	lddpc	r8,80002ffc <data_flash_init+0x23c>
80002e90:	b0 89       	st.b	r8[0x0],r9
		return;
80002e92:	c9 e8       	rjmp	80002fce <data_flash_init+0x20e>
	}

	// Set STATUS reg to unprotect all sect
	send_flash_command(WRITE_ENABLE, 0, NULL, 0);
80002e94:	30 09       	mov	r9,0
80002e96:	12 9a       	mov	r10,r9
80002e98:	12 9b       	mov	r11,r9
80002e9a:	30 6c       	mov	r12,6
80002e9c:	f0 1f 00 5f 	mcall	80003018 <data_flash_init+0x258>
	send_flash_command(WRITE_STATUS_REG_BYTE_1, 0, NULL, 0);
80002ea0:	30 09       	mov	r9,0
80002ea2:	12 9a       	mov	r10,r9
80002ea4:	12 9b       	mov	r11,r9
80002ea6:	30 1c       	mov	r12,1
80002ea8:	f0 1f 00 5c 	mcall	80003018 <data_flash_init+0x258>
	status = send_flash_command(READ_STATUS_REG, 0, NULL, 0);
80002eac:	30 09       	mov	r9,0
80002eae:	12 9a       	mov	r10,r9
80002eb0:	12 9b       	mov	r11,r9
80002eb2:	30 5c       	mov	r12,5
80002eb4:	f0 1f 00 59 	mcall	80003018 <data_flash_init+0x258>
{
	df_status_t return_code = DF_OK;
	unsigned int i = 0;
	unsigned int address =0x00000000;	
	char str[10];
	memset(str, 0x00, sizeof(str));
80002eb8:	30 0a       	mov	r10,0
80002eba:	30 0b       	mov	r11,0
80002ebc:	fa eb 00 00 	st.d	sp[0],r10
80002ec0:	30 09       	mov	r9,0
80002ec2:	ba 49       	st.h	sp[0x8],r9
80002ec4:	30 05       	mov	r5,0
	
start:	

	/* bytes remained less than one page */
	return_code = data_flash_read_block(LABEL_ADDRESS, LABEL_LENGTH, str);
80002ec6:	1a 97       	mov	r7,sp
80002ec8:	30 74       	mov	r4,7
80002eca:	0a 93       	mov	r3,r5
	if(return_code == DF_OK)
	{
		if(memcmp(FlashLabel, str, sizeof(FlashLabel)-1) != 0)//compare label
80002ecc:	4d 42       	lddpc	r2,8000301c <data_flash_init+0x25c>
			log("\r\n----create voice info， okay!----\r\n");									
		}
		else//success
		{	
			//Get the current voice index
			return_code = data_flash_read_block(VOICE_NUMBERS_ADDRESS, VOICE_NUMBERS_LENGTH, &current_voice_index);
80002ece:	4d 56       	lddpc	r6,80003020 <data_flash_init+0x260>
80002ed0:	30 21       	mov	r1,2
80002ed2:	30 a0       	mov	r0,10
	memset(str, 0x00, sizeof(str));
	
start:	

	/* bytes remained less than one page */
	return_code = data_flash_read_block(LABEL_ADDRESS, LABEL_LENGTH, str);
80002ed4:	1a 9a       	mov	r10,sp
80002ed6:	08 9b       	mov	r11,r4
80002ed8:	06 9c       	mov	r12,r3
80002eda:	f0 1f 00 53 	mcall	80003024 <data_flash_init+0x264>
	if(return_code == DF_OK)
80002ede:	c7 81       	brne	80002fce <data_flash_init+0x20e>
	{
		if(memcmp(FlashLabel, str, sizeof(FlashLabel)-1) != 0)//compare label
80002ee0:	08 9a       	mov	r10,r4
80002ee2:	1a 9b       	mov	r11,sp
80002ee4:	04 9c       	mov	r12,r2
80002ee6:	f0 1f 00 51 	mcall	80003028 <data_flash_init+0x268>
80002eea:	c2 50       	breq	80002f34 <data_flash_init+0x174>
80002eec:	c6 58       	rjmp	80002fb6 <data_flash_init+0x1f6>
				return_code = data_flash_erase_block(address, DF_BLOCK_64KB);
				if(return_code != DF_ERASE_COMPLETED)
				{
					return FALSE;
				}
				address+=65536;//64k*1024=65536bytes
80002eee:	fe 35 00 00 	sub	r5,-65536
		{
			ERASE:
			//erase
			for(i; i < (VOICE_LIST_BOUNDARY/(64*1024)); i++)//8*64k
			{
				return_code = data_flash_erase_block(address, DF_BLOCK_64KB);
80002ef2:	0e 9b       	mov	r11,r7
80002ef4:	0a 9c       	mov	r12,r5
80002ef6:	f0 1f 00 4e 	mcall	8000302c <data_flash_init+0x26c>
				if(return_code != DF_ERASE_COMPLETED)
80002efa:	58 5c       	cp.w	r12,5
80002efc:	c6 91       	brne	80002fce <data_flash_init+0x20e>
	{
		if(memcmp(FlashLabel, str, sizeof(FlashLabel)-1) != 0)//compare label
		{
			ERASE:
			//erase
			for(i; i < (VOICE_LIST_BOUNDARY/(64*1024)); i++)//8*64k
80002efe:	0c 35       	cp.w	r5,r6
80002f00:	cf 71       	brne	80002eee <data_flash_init+0x12e>
					return FALSE;
				}
				address+=65536;//64k*1024=65536bytes
			}
			//set label
			return_code = data_flash_write(FlashLabel, LABEL_ADDRESS, LABEL_LENGTH);
80002f02:	30 7a       	mov	r10,7
80002f04:	30 0b       	mov	r11,0
80002f06:	4c 6c       	lddpc	r12,8000301c <data_flash_init+0x25c>
80002f08:	f0 1f 00 4a 	mcall	80003030 <data_flash_init+0x270>
			//set current_voice_index
			memset(str, 0x00, sizeof(str));
80002f0c:	1a 9c       	mov	r12,sp
80002f0e:	30 08       	mov	r8,0
80002f10:	30 09       	mov	r9,0
80002f12:	fa e9 00 00 	st.d	sp[0],r8
80002f16:	30 08       	mov	r8,0
80002f18:	ba 48       	st.h	sp[0x8],r8
			return_code = data_flash_write(str, VOICE_NUMBERS_ADDRESS, VOICE_NUMBERS_LENGTH);
80002f1a:	30 2a       	mov	r10,2
80002f1c:	30 ab       	mov	r11,10
80002f1e:	f0 1f 00 45 	mcall	80003030 <data_flash_init+0x270>
			if(return_code != DF_WRITE_COMPLETED)
80002f22:	58 7c       	cp.w	r12,7
80002f24:	c5 51       	brne	80002fce <data_flash_init+0x20e>
			{
				return FALSE;
			}
			current_voice_index = 0;
80002f26:	30 09       	mov	r9,0
80002f28:	4b e8       	lddpc	r8,80003020 <data_flash_init+0x260>
80002f2a:	b0 09       	st.h	r8[0x0],r9
			log("\r\n----create voice info， okay!----\r\n");									
80002f2c:	4c 2c       	lddpc	r12,80003034 <data_flash_init+0x274>
80002f2e:	f0 1f 00 43 	mcall	80003038 <data_flash_init+0x278>
80002f32:	c4 b8       	rjmp	80002fc8 <data_flash_init+0x208>
		}
		else//success
		{	
			//Get the current voice index
			return_code = data_flash_read_block(VOICE_NUMBERS_ADDRESS, VOICE_NUMBERS_LENGTH, &current_voice_index);
80002f34:	0c 9a       	mov	r10,r6
80002f36:	02 9b       	mov	r11,r1
80002f38:	00 9c       	mov	r12,r0
80002f3a:	f0 1f 00 3b 	mcall	80003024 <data_flash_init+0x264>
			if(return_code == DF_OK) 
80002f3e:	c4 81       	brne	80002fce <data_flash_init+0x20e>
			{	
				//Calculates the offset address of the current stored voice
				if(current_voice_index != 0){
80002f40:	8c 05       	ld.sh	r5,r6[0x0]
80002f42:	58 05       	cp.w	r5,0
80002f44:	c3 f0       	breq	80002fc2 <data_flash_init+0x202>
									
					address = START_ADDRESS_OF_VOICE_INFO + ((current_voice_index -1)*VOICE_INFO_LENGTH);
80002f46:	5c 75       	castu.h	r5
80002f48:	2f f5       	sub	r5,-1
80002f4a:	a3 75       	lsl	r5,0x3
					return_code = data_flash_read_block(address, VOICE_INFO_LENGTH, (U8 *)str);
80002f4c:	1a 9a       	mov	r10,sp
80002f4e:	30 8b       	mov	r11,8
80002f50:	0a 9c       	mov	r12,r5
80002f52:	f0 1f 00 35 	mcall	80003024 <data_flash_init+0x264>
					//return_code = data_flash_read_block(LABEL_ADDRESS, 512, (U8 *)FLASH_BUF);
					if(return_code == DF_OK)
80002f56:	c3 61       	brne	80002fc2 <data_flash_init+0x202>
					{
						VoiceList_Info_t *ptr = (VoiceList_Info_t *)str;
						if(ptr->numb == current_voice_index)
80002f58:	0f 89       	ld.ub	r9,r7[0x0]
80002f5a:	0f 98       	ld.ub	r8,r7[0x1]
80002f5c:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002f60:	8c 09       	ld.sh	r9,r6[0x0]
80002f62:	f0 09 19 00 	cp.h	r9,r8
80002f66:	c2 51       	brne	80002fb0 <data_flash_init+0x1f0>
						{
							current_save_voice_offset = ptr->address + ptr->offset;
80002f68:	0f e9       	ld.ub	r9,r7[0x6]
80002f6a:	0f f8       	ld.ub	r8,r7[0x7]
80002f6c:	f1 e9 10 89 	or	r9,r8,r9<<0x8
80002f70:	0f aa       	ld.ub	r10,r7[0x2]
80002f72:	0f b8       	ld.ub	r8,r7[0x3]
80002f74:	b1 68       	lsl	r8,0x10
80002f76:	f1 ea 11 88 	or	r8,r8,r10<<0x18
80002f7a:	0f ca       	ld.ub	r10,r7[0x4]
80002f7c:	f1 ea 10 88 	or	r8,r8,r10<<0x8
80002f80:	0f da       	ld.ub	r10,r7[0x5]
80002f82:	f5 e8 10 08 	or	r8,r10,r8
80002f86:	f2 08 00 08 	add	r8,r9,r8
80002f8a:	4a d9       	lddpc	r9,8000303c <data_flash_init+0x27c>
80002f8c:	93 08       	st.w	r9[0x0],r8
							if(current_save_voice_offset > 0x7bc000){
80002f8e:	e0 69 c0 00 	mov	r9,49152
80002f92:	ea 19 00 7b 	orh	r9,0x7b
80002f96:	12 38       	cp.w	r8,r9
80002f98:	e0 88 00 15 	brls	80002fc2 <data_flash_init+0x202>
								
								log("\r\n----voice storage is full!!!----\r\n");
80002f9c:	4a 9c       	lddpc	r12,80003040 <data_flash_init+0x280>
80002f9e:	f0 1f 00 27 	mcall	80003038 <data_flash_init+0x278>
								//chip erase
								return_code = data_flash_erase_block(0, DF_BLOCK_ALL);
80002fa2:	30 4b       	mov	r11,4
80002fa4:	06 9c       	mov	r12,r3
80002fa6:	f0 1f 00 22 	mcall	8000302c <data_flash_init+0x26c>
								if(return_code == DF_ERASE_COMPLETED)goto start;
80002faa:	58 5c       	cp.w	r12,5
80002fac:	c9 40       	breq	80002ed4 <data_flash_init+0x114>
80002fae:	c1 08       	rjmp	80002fce <data_flash_init+0x20e>
									return FALSE;																						
							}						
						}
						else
						{
							log("\r\n----voice storage is err!!!----\r\n");
80002fb0:	4a 5c       	lddpc	r12,80003044 <data_flash_init+0x284>
80002fb2:	f0 1f 00 22 	mcall	80003038 <data_flash_init+0x278>
* Date        Name      Prob#       Description
* ----------  --------  ----------  --------------------------------------------
* 10-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
void data_flash_init(void)
80002fb6:	e6 78 00 00 	mov	r8,458752
80002fba:	ea 08 00 06 	add	r6,r5,r8
		{
			ERASE:
			//erase
			for(i; i < (VOICE_LIST_BOUNDARY/(64*1024)); i++)//8*64k
			{
				return_code = data_flash_erase_block(address, DF_BLOCK_64KB);
80002fbe:	30 37       	mov	r7,3
80002fc0:	c9 9b       	rjmp	80002ef2 <data_flash_init+0x132>
							goto ERASE;
							//return FALSE;	
						}
					}
				}
				log("\r\n----read voice info， okay!----\r\n");	
80002fc2:	4a 2c       	lddpc	r12,80003048 <data_flash_init+0x288>
80002fc4:	f0 1f 00 1d 	mcall	80003038 <data_flash_init+0x278>
			}
			else
				return FALSE;
		}
					
		flash_init_success_flag = 1;
80002fc8:	30 19       	mov	r9,1
80002fca:	4a 18       	lddpc	r8,8000304c <data_flash_init+0x28c>
80002fcc:	b0 89       	st.b	r8[0x0],r9
	//playback_voice_data(5);
	//playback_voice_data(4);

	
	return;
}
80002fce:	2f 9d       	sub	sp,-28
80002fd0:	d8 32       	popm	r0-r7,pc
80002fd2:	00 00       	add	r0,r0
80002fd4:	80 00       	ld.sh	r0,r0[0x0]
80002fd6:	d2 88       	*unknown*
80002fd8:	80 00       	ld.sh	r0,r0[0x0]
80002fda:	d1 70       	acall	0x17
80002fdc:	80 00       	ld.sh	r0,r0[0x0]
80002fde:	6c 6c       	ld.w	r12,r6[0x18]
80002fe0:	80 00       	ld.sh	r0,r0[0x0]
80002fe2:	6c 9c       	ld.w	r12,r6[0x24]
80002fe4:	80 00       	ld.sh	r0,r0[0x0]
80002fe6:	6c b4       	ld.w	r4,r6[0x2c]
80002fe8:	00 00       	add	r0,r0
80002fea:	1f 88       	ld.ub	r8,pc[0x0]
80002fec:	80 00       	ld.sh	r0,r0[0x0]
80002fee:	4f 7c       	lddpc	r12,800031c8 <phy_rx+0x34>
80002ff0:	80 00       	ld.sh	r0,r0[0x0]
80002ff2:	4f b4       	lddpc	r4,800031dc <set_idle_store+0x10>
80002ff4:	80 00       	ld.sh	r0,r0[0x0]
80002ff6:	51 14       	stdsp	sp[0x44],r4
80002ff8:	80 00       	ld.sh	r0,r0[0x0]
80002ffa:	50 52       	stdsp	sp[0x14],r2
80002ffc:	00 00       	add	r0,r0
80002ffe:	0a 5f       	eor	pc,r5
80003000:	80 00       	ld.sh	r0,r0[0x0]
80003002:	d2 98       	*unknown*
80003004:	80 00       	ld.sh	r0,r0[0x0]
80003006:	71 8e       	ld.w	lr,r8[0x60]
80003008:	80 00       	ld.sh	r0,r0[0x0]
8000300a:	4f e0       	lddpc	r0,80003200 <phy_tx+0x14>
8000300c:	80 00       	ld.sh	r0,r0[0x0]
8000300e:	51 1a       	stdsp	sp[0x44],r10
80003010:	80 00       	ld.sh	r0,r0[0x0]
80003012:	51 36       	stdsp	sp[0x4c],r6
80003014:	80 00       	ld.sh	r0,r0[0x0]
80003016:	50 2c       	stdsp	sp[0x8],r12
80003018:	80 00       	ld.sh	r0,r0[0x0]
8000301a:	28 e4       	sub	r4,-114
8000301c:	00 00       	add	r0,r0
8000301e:	04 f4       	st.b	--r2,r4
80003020:	00 00       	add	r0,r0
80003022:	0a 5c       	eor	r12,r5
80003024:	80 00       	ld.sh	r0,r0[0x0]
80003026:	2a a0       	sub	r0,-86
80003028:	80 00       	ld.sh	r0,r0[0x0]
8000302a:	71 68       	ld.w	r8,r8[0x58]
8000302c:	80 00       	ld.sh	r0,r0[0x0]
8000302e:	2c 34       	sub	r4,-61
80003030:	80 00       	ld.sh	r0,r0[0x0]
80003032:	2c d0       	sub	r0,-51
80003034:	80 00       	ld.sh	r0,r0[0x0]
80003036:	d1 f0       	acall	0x1f
80003038:	80 00       	ld.sh	r0,r0[0x0]
8000303a:	67 d4       	ld.w	r4,r3[0x74]
8000303c:	00 00       	add	r0,r0
8000303e:	04 fc       	st.b	--r2,r12
80003040:	80 00       	ld.sh	r0,r0[0x0]
80003042:	d2 18       	*unknown*
80003044:	80 00       	ld.sh	r0,r0[0x0]
80003046:	d2 40       	acall	0x24
80003048:	80 00       	ld.sh	r0,r0[0x0]
8000304a:	d2 64       	*unknown*
8000304c:	00 00       	add	r0,r0
8000304e:	0a 5e       	eor	lr,r5

80003050 <fl_write>:
	}
}


void fl_write(void * path, S32 offset, void * buffer, U32 length)
{
80003050:	eb cd 40 f8 	pushm	r3-r7,lr
80003054:	20 2d       	sub	sp,8
80003056:	18 95       	mov	r5,r12
80003058:	16 94       	mov	r4,r11
8000305a:	14 93       	mov	r3,r10
8000305c:	12 96       	mov	r6,r9
	
	fl_write_t * fl_write_ptr = pvPortMalloc(sizeof(fl_write_t));
8000305e:	34 cc       	mov	r12,76
80003060:	f0 1f 00 16 	mcall	800030b8 <fl_write+0x68>
80003064:	18 97       	mov	r7,r12
	
	sprintf(fl_write_ptr->path, "%s", path);
80003066:	0a 9b       	mov	r11,r5
80003068:	f0 1f 00 15 	mcall	800030bc <fl_write+0x6c>
	fl_write_ptr->offset = offset;
8000306c:	ef 44 00 40 	st.w	r7[64],r4
	fl_write_ptr->length = length;	
80003070:	ef 46 00 44 	st.w	r7[68],r6
	
	fl_write_ptr->buffer = pvPortMalloc(length);
80003074:	0c 9c       	mov	r12,r6
80003076:	f0 1f 00 11 	mcall	800030b8 <fl_write+0x68>
8000307a:	ef 4c 00 48 	st.w	r7[72],r12
	memcpy(fl_write_ptr->buffer, buffer, length);
8000307e:	0c 9a       	mov	r10,r6
80003080:	06 9b       	mov	r11,r3
80003082:	f0 1f 00 10 	mcall	800030c0 <fl_write+0x70>
	
	fl_oper_t fl_oper;
	
	fl_oper.opcode = FL_WRITE;
80003086:	e0 68 40 00 	mov	r8,16384
8000308a:	ba 08       	st.h	sp[0x0],r8
	fl_oper.payload = fl_write_ptr;
8000308c:	50 17       	stdsp	sp[0x4],r7
	
	if(pdTRUE != xQueueSend( fl_oper_queue, &fl_oper, 0 ))
8000308e:	48 e8       	lddpc	r8,800030c4 <fl_write+0x74>
80003090:	70 0c       	ld.w	r12,r8[0x0]
80003092:	30 09       	mov	r9,0
80003094:	12 9a       	mov	r10,r9
80003096:	1a 9b       	mov	r11,sp
80003098:	f0 1f 00 0c 	mcall	800030c8 <fl_write+0x78>
8000309c:	58 1c       	cp.w	r12,1
8000309e:	c0 a0       	breq	800030b2 <fl_write+0x62>
	{
		vPortFree(fl_write_ptr->buffer);
800030a0:	6f 2c       	ld.w	r12,r7[0x48]
800030a2:	f0 1f 00 0b 	mcall	800030cc <fl_write+0x7c>
		vPortFree(fl_write_ptr);
800030a6:	0e 9c       	mov	r12,r7
800030a8:	f0 1f 00 09 	mcall	800030cc <fl_write+0x7c>
		log("\n\r fsmm \n\r");//man...提升SPI_PBA时钟的频率可以有效的提升写文件的速度。
800030ac:	48 9c       	lddpc	r12,800030d0 <fl_write+0x80>
800030ae:	f0 1f 00 0a 	mcall	800030d4 <fl_write+0x84>
	}
	
}
800030b2:	2f ed       	sub	sp,-8
800030b4:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
800030b8:	80 00       	ld.sh	r0,r0[0x0]
800030ba:	58 e8       	cp.w	r8,14
800030bc:	80 00       	ld.sh	r0,r0[0x0]
800030be:	76 00       	ld.w	r0,r11[0x0]
800030c0:	80 00       	ld.sh	r0,r0[0x0]
800030c2:	71 8e       	ld.w	lr,r8[0x60]
800030c4:	00 00       	add	r0,r0
800030c6:	0a 60       	and	r0,r5
800030c8:	80 00       	ld.sh	r0,r0[0x0]
800030ca:	5c 3c       	neg	r12
800030cc:	80 00       	ld.sh	r0,r0[0x0]
800030ce:	58 c0       	cp.w	r0,12
800030d0:	80 00       	ld.sh	r0,r0[0x0]
800030d2:	d2 a0       	acall	0x2a
800030d4:	80 00       	ld.sh	r0,r0[0x0]
800030d6:	67 d4       	ld.w	r4,r3[0x74]

800030d8 <CalculateBurst>:
Calls:
Called By: phy_payload_rx
*/

volatile RxAMBEBurstType CalculateBurst(U8 vf_sn)
{
800030d8:	20 1c       	sub	r12,1
800030da:	5c 5c       	castu.b	r12
800030dc:	31 18       	mov	r8,17
800030de:	f0 0c 18 00 	cp.b	r12,r8
800030e2:	e0 88 00 03 	brls	800030e8 <CalculateBurst+0x10>
800030e6:	5e fd       	retal	0
800030e8:	48 28       	lddpc	r8,800030f0 <CalculateBurst+0x18>
800030ea:	f0 0c 03 2c 	ld.w	r12,r8[r12<<0x2]
			Burst_ID = 0x00;
			return VOICE_WATING;
		
	}
	
}
800030ee:	5e fc       	retal	r12
800030f0:	80 00       	ld.sh	r0,r0[0x0]
800030f2:	d3 0c       	*unknown*

800030f4 <payload_init>:
	Create the corresponding task;
Calls: xTaskCreate--freertos
Called By:app_init -- app.c
*/
void payload_init(void ( *payload_rx_func)(void * ), void ( *payload_tx_func)(void * ) )
{				
800030f4:	d4 01       	pushm	lr
	payload_rx_exec = payload_rx_func;
800030f6:	48 98       	lddpc	r8,80003118 <payload_init+0x24>
800030f8:	91 0c       	st.w	r8[0x0],r12
	payload_tx_exec = payload_tx_func;
800030fa:	48 98       	lddpc	r8,8000311c <payload_init+0x28>
800030fc:	91 0b       	st.w	r8[0x0],r11
	
	
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
800030fe:	30 09       	mov	r9,0
80003100:	1a d9       	st.w	--sp,r9
80003102:	1a d9       	st.w	--sp,r9
80003104:	1a d9       	st.w	--sp,r9
80003106:	30 28       	mov	r8,2
80003108:	e0 6a 04 00 	mov	r10,1024
8000310c:	48 5b       	lddpc	r11,80003120 <payload_init+0x2c>
8000310e:	48 6c       	lddpc	r12,80003124 <payload_init+0x30>
80003110:	f0 1f 00 06 	mcall	80003128 <payload_init+0x34>
80003114:	2f dd       	sub	sp,-12
	
	
	
	
	
}
80003116:	d8 02       	popm	pc
80003118:	00 00       	add	r0,r0
8000311a:	0a 64       	and	r4,r5
8000311c:	00 00       	add	r0,r0
8000311e:	0a 68       	and	r8,r5
80003120:	80 00       	ld.sh	r0,r0[0x0]
80003122:	d3 54       	*unknown*
80003124:	80 00       	ld.sh	r0,r0[0x0]
80003126:	31 2c       	mov	r12,18
80003128:	80 00       	ld.sh	r0,r0[0x0]
8000312a:	64 10       	ld.w	r0,r2[0x4]

8000312c <payload_rx_process>:
Description: Receive the payload
Calls:
Called By:task
*/
static void payload_rx_process(void * pvParameters)
{
8000312c:	eb cd 40 f8 	pushm	r3-r7,lr
80003130:	20 1d       	sub	sp,4
	/*To store the elements in the queue*/
	U16  * payload_ptr;
		
	if(NULL ==   phy_payload_frame_rx)
80003132:	48 e8       	lddpc	r8,80003168 <payload_rx_process+0x3c>
80003134:	70 08       	ld.w	r8,r8[0x0]
80003136:	58 08       	cp.w	r8,0
80003138:	c0 71       	brne	80003146 <payload_rx_process+0x1a>
	{
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
8000313a:	30 4b       	mov	r11,4
8000313c:	30 5c       	mov	r12,5
8000313e:	f0 1f 00 0c 	mcall	8000316c <payload_rx_process+0x40>
80003142:	48 a8       	lddpc	r8,80003168 <payload_rx_process+0x3c>
80003144:	91 0c       	st.w	r8[0x0],r12
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_rx, &payload_ptr,portMAX_DELAY ))
80003146:	48 96       	lddpc	r6,80003168 <payload_rx_process+0x3c>
80003148:	30 05       	mov	r5,0
8000314a:	3f f4       	mov	r4,-1
		{			
			payload_rx_exec(payload_ptr);//app_payload_rx_proc();
8000314c:	48 93       	lddpc	r3,80003170 <payload_rx_process+0x44>
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_rx, &payload_ptr,portMAX_DELAY ))
8000314e:	6c 0c       	ld.w	r12,r6[0x0]
80003150:	0a 99       	mov	r9,r5
80003152:	08 9a       	mov	r10,r4
80003154:	1a 9b       	mov	r11,sp
80003156:	f0 1f 00 08 	mcall	80003174 <payload_rx_process+0x48>
8000315a:	58 1c       	cp.w	r12,1
8000315c:	cf 91       	brne	8000314e <payload_rx_process+0x22>
		{			
			payload_rx_exec(payload_ptr);//app_payload_rx_proc();
8000315e:	66 08       	ld.w	r8,r3[0x0]
80003160:	40 0c       	lddsp	r12,sp[0x0]
80003162:	5d 18       	icall	r8
80003164:	cf 5b       	rjmp	8000314e <payload_rx_process+0x22>
80003166:	00 00       	add	r0,r0
80003168:	00 00       	add	r0,r0
8000316a:	0a 7c       	tst	r12,r5
8000316c:	80 00       	ld.sh	r0,r0[0x0]
8000316e:	5d 3c       	musfr	r12
80003170:	00 00       	add	r0,r0
80003172:	0a 64       	and	r4,r5
80003174:	80 00       	ld.sh	r0,r0[0x0]
80003176:	5a 30       	cp.w	r0,-29

80003178 <set_idle_store_isr>:
{
	xQueueSend(store, &ptr, 0);
}

void set_idle_store_isr(xQueueHandle store, void * ptr)
{
80003178:	d4 01       	pushm	lr
8000317a:	20 2d       	sub	sp,8
8000317c:	50 0b       	stdsp	sp[0x0],r11
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
8000317e:	30 09       	mov	r9,0
80003180:	fa ca ff f8 	sub	r10,sp,-8
80003184:	14 d9       	st.w	--r10,r9
	xQueueSendFromISR(store, &ptr, &xHigherPriorityTaskWoken);
80003186:	1a 9b       	mov	r11,sp
80003188:	f0 1f 00 02 	mcall	80003190 <set_idle_store_isr+0x18>
}
8000318c:	2f ed       	sub	sp,-8
8000318e:	d8 02       	popm	pc
80003190:	80 00       	ld.sh	r0,r0[0x0]
80003192:	5b ec       	cp.w	r12,-2

80003194 <phy_rx>:
	xQueueSendFromISR -- freertos
Called By: phy_xnl_rx
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
80003194:	d4 01       	pushm	lr
80003196:	20 2d       	sub	sp,8
80003198:	50 0c       	stdsp	sp[0x0],r12
	//memcpy(xx, phy_ptr, sizeof(phy_fragment_t));
	//set_phy_idle_isr(&phy_ptr, &xHigherPriorityTaskWoken);
	
	Bool res = FALSE;
	
	if(NULL == phy_ptr)
8000319a:	58 0c       	cp.w	r12,0
8000319c:	c1 10       	breq	800031be <phy_rx+0x2a>
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
    /*variables are used to store the push result in interrupt*/
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
8000319e:	30 08       	mov	r8,0
800031a0:	50 18       	stdsp	sp[0x4],r8
	if(NULL == phy_ptr)
	{
		return;
	}
	
    U16 phy_ctrl = phy_ptr->xnl_fragment.phy_header.phy_control;
800031a2:	98 88       	ld.uh	r8,r12[0x0]
800031a4:	e2 18 f0 00 	andl	r8,0xf000,COH
800031a8:	e0 48 40 00 	cp.w	r8,16384
800031ac:	c0 91       	brne	800031be <phy_rx+0x2a>

    if (XCMPXNL_DATA == (phy_ctrl & 0xF000))
    {
        /*push the xnl packet to queue*/
        if( pdTRUE == xQueueSendFromISR(
800031ae:	48 68       	lddpc	r8,800031c4 <phy_rx+0x30>
800031b0:	70 0c       	ld.w	r12,r8[0x0]
800031b2:	30 09       	mov	r9,0
800031b4:	fa ca ff fc 	sub	r10,sp,-4
800031b8:	1a 9b       	mov	r11,sp
800031ba:	f0 1f 00 04 	mcall	800031c8 <phy_rx+0x34>
		}	

    }
		
 
}
800031be:	2f ed       	sub	sp,-8
800031c0:	d8 02       	popm	pc
800031c2:	00 00       	add	r0,r0
800031c4:	00 00       	add	r0,r0
800031c6:	0a b8       	st.h	r5++,r8
800031c8:	80 00       	ld.sh	r0,r0[0x0]
800031ca:	5b ec       	cp.w	r12,-2

800031cc <set_idle_store>:
	}
}


void set_idle_store(xQueueHandle store, void * ptr)
{
800031cc:	eb cd 40 80 	pushm	r7,lr
800031d0:	20 1d       	sub	sp,4
800031d2:	fa c7 ff fc 	sub	r7,sp,-4
800031d6:	0e db       	st.w	--r7,r11
	xQueueSend(store, &ptr, 0);
800031d8:	30 09       	mov	r9,0
800031da:	12 9a       	mov	r10,r9
800031dc:	1a 9b       	mov	r11,sp
800031de:	f0 1f 00 03 	mcall	800031e8 <set_idle_store+0x1c>
}
800031e2:	2f fd       	sub	sp,-4
800031e4:	e3 cd 80 80 	ldm	sp++,r7,pc
800031e8:	80 00       	ld.sh	r0,r0[0x0]
800031ea:	5c 3c       	neg	r12

800031ec <phy_tx>:
Calls:   
	xQueueSend -- freertos
Called By: xnl_tx -- xnl.c
*/
void phy_tx(phy_fragment_t * phy)
{	
800031ec:	d4 01       	pushm	lr
800031ee:	20 1d       	sub	sp,4
800031f0:	50 0c       	stdsp	sp[0x0],r12
	
	//phy_fragment_t * phy_ptr = malloc(sizeof(phy_fragment_t));
	//memcpy(phy_ptr, phy, sizeof(phy_fragment_t));
	//log("\n\r T_xcmp:%4x \n\r", phy->xnl_fragment.xnl_payload.xnl_content_data_msg.xcmp_opcode);
	//log("T_xnl-opcode:%4x", xnl->xnl_header.opcode);//log:R_xnl指令	
	if(XCMPXNL_DATA == (phy_ctrl & 0xF000))
800031f2:	98 88       	ld.uh	r8,r12[0x0]
800031f4:	e2 18 f0 00 	andl	r8,0xf000,COH
800031f8:	e0 48 40 00 	cp.w	r8,16384
800031fc:	c0 d1       	brne	80003216 <phy_tx+0x2a>
	{
		/*push the xnl packet to queue to send */
		if(NULL != phy_xnl_frame_tx)
800031fe:	49 08       	lddpc	r8,8000323c <phy_tx+0x50>
80003200:	70 08       	ld.w	r8,r8[0x0]
80003202:	58 08       	cp.w	r8,0
80003204:	c1 a0       	breq	80003238 <phy_tx+0x4c>
		{
			if( pdTRUE == xQueueSend(phy_xnl_frame_tx, &phy, 0))
80003206:	48 e8       	lddpc	r8,8000323c <phy_tx+0x50>
80003208:	70 0c       	ld.w	r12,r8[0x0]
8000320a:	30 09       	mov	r9,0
8000320c:	12 9a       	mov	r10,r9
8000320e:	1a 9b       	mov	r11,sp
80003210:	f0 1f 00 0c 	mcall	80003240 <phy_tx+0x54>
80003214:	c1 28       	rjmp	80003238 <phy_tx+0x4c>
		}
	}
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE		
	else if((SPEAKER_DATA == (phy_ctrl & 0xF000))
80003216:	e0 48 10 00 	cp.w	r8,4096
8000321a:	5f 0a       	sreq	r10
8000321c:	e0 48 20 00 	cp.w	r8,8192
80003220:	5f 09       	sreq	r9
80003222:	f5 e9 10 09 	or	r9,r10,r9
80003226:	c0 71       	brne	80003234 <phy_tx+0x48>
80003228:	e0 48 50 00 	cp.w	r8,20480
8000322c:	c0 40       	breq	80003234 <phy_tx+0x48>
8000322e:	e0 48 60 00 	cp.w	r8,24576
80003232:	c0 31       	brne	80003238 <phy_tx+0x4c>
	    || (MIC_DATA  == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_RX == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_TX == (phy_ctrl & 0xF000))
	)
	{		
		if(NULL == phy_payload_frame_tx)
80003234:	48 48       	lddpc	r8,80003244 <phy_tx+0x58>
80003236:	70 08       	ld.w	r8,r8[0x0]
	
	if(res != TRUE)
	{
		//vPortFree(phy_ptr);
	}
}
80003238:	2f fd       	sub	sp,-4
8000323a:	d8 02       	popm	pc
8000323c:	00 00       	add	r0,r0
8000323e:	0a cc       	st.b	r5++,r12
80003240:	80 00       	ld.sh	r0,r0[0x0]
80003242:	5c 3c       	neg	r12
80003244:	00 00       	add	r0,r0
80003246:	0a b0       	st.h	r5++,r0

80003248 <get_idle_store_isr>:
		return NULL;
	}
}

void * get_idle_store_isr(xQueueHandle store)
{
80003248:	d4 01       	pushm	lr
8000324a:	20 2d       	sub	sp,8
	void * ptr = NULL;
8000324c:	30 08       	mov	r8,0
8000324e:	50 18       	stdsp	sp[0x4],r8
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80003250:	50 08       	stdsp	sp[0x0],r8
	
	if(pdTRUE == xQueueReceiveFromISR(store, &ptr, &xHigherPriorityTaskWoken))
80003252:	1a 9a       	mov	r10,sp
80003254:	fa cb ff fc 	sub	r11,sp,-4
80003258:	f0 1f 00 05 	mcall	8000326c <get_idle_store_isr+0x24>
8000325c:	58 1c       	cp.w	r12,1
8000325e:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80003262:	fb fc 00 01 	ld.weq	r12,sp[0x4]
	}
	else
	{
		return NULL;
	}
}
80003266:	2f ed       	sub	sp,-8
80003268:	d8 02       	popm	pc
8000326a:	00 00       	add	r0,r0
8000326c:	80 00       	ld.sh	r0,r0[0x0]
8000326e:	59 40       	cp.w	r0,20

80003270 <phy_tx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_tx_func( void * ssc)
{
80003270:	eb cd 40 c0 	pushm	r6-r7,lr
80003274:	20 1d       	sub	sp,4
80003276:	18 97       	mov	r7,r12
    if(NULL != phy_xnl_frame_tx)
80003278:	fe f8 05 54 	ld.w	r8,pc[1364]
8000327c:	70 08       	ld.w	r8,r8[0x0]
8000327e:	58 08       	cp.w	r8,0
80003280:	c7 40       	breq	80003368 <phy_tx_func+0xf8>
    {
  	  	/*send ssc data in xnl frame*/
  	  	phy_xnl_tx(&(((ssc_fragment_t * )ssc)->xnl_channel));		
80003282:	18 96       	mov	r6,r12
Called By:phy_tx_func
*/
static void phy_xnl_tx(xnl_channel_t * xnl_tx_channel)
{
	/*variables are used to store the push result in interrupt*/
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80003284:	30 08       	mov	r8,0
80003286:	50 08       	stdsp	sp[0x0],r8
	
	static S16 phy_tx_expexted_length = 0;
	static U8 phy_tx_index = 0;
	
	/*his is the code for handling any outgoing XNL Phy message*/
	switch(phy_tx_state)
80003288:	fe f8 05 48 	ld.w	r8,pc[1352]
8000328c:	70 08       	ld.w	r8,r8[0x0]
8000328e:	58 18       	cp.w	r8,1
80003290:	c2 90       	breq	800032e2 <phy_tx_func+0x72>
80003292:	c0 43       	brcs	8000329a <phy_tx_func+0x2a>
80003294:	58 28       	cp.w	r8,2
80003296:	c6 91       	brne	80003368 <phy_tx_func+0xf8>
80003298:	c6 18       	rjmp	8000335a <phy_tx_func+0xea>
	{
		/*Waiting for the send xnl packet*/
		case WAITING_FOR_PHY_TX:			
			if( pdTRUE == xQueueReceiveFromISR(
8000329a:	fe f8 05 32 	ld.w	r8,pc[1330]
8000329e:	70 0c       	ld.w	r12,r8[0x0]
800032a0:	1a 9a       	mov	r10,sp
800032a2:	fe fb 05 32 	ld.w	r11,pc[1330]
800032a6:	f0 1f 01 4d 	mcall	800037d8 <phy_tx_func+0x568>
800032aa:	58 1c       	cp.w	r12,1
800032ac:	c1 51       	brne	800032d6 <phy_tx_func+0x66>
				  phy_xnl_frame_tx
				, &phy_ptr
				, &xHigherPriorityTaskWoken 
			))
			{								
				phy_tx_expexted_length = 
800032ae:	fe f8 05 26 	ld.w	r8,pc[1318]
800032b2:	70 08       	ld.w	r8,r8[0x0]
800032b4:	11 9a       	ld.ub	r10,r8[0x1]
800032b6:	fe f9 05 26 	ld.w	r9,pc[1318]
800032ba:	b2 0a       	st.h	r9[0x0],r10
				*/
				xnl_tx_channel->dword = 
				                   phy_ptr->xnl_fragment.phy_header.phy_control;
				
				/*Transmit 0xABCD0000 | Type/Length.*/
				xnl_tx_channel->dword |= PHYHEADER32;
800032bc:	90 88       	ld.uh	r8,r8[0x0]
800032be:	ea 18 ab cd 	orh	r8,0xabcd
800032c2:	8f 18       	st.w	r7[0x4],r8
				
				phy_tx_index = 1;
800032c4:	30 19       	mov	r9,1
800032c6:	fe f8 05 1a 	ld.w	r8,pc[1306]
800032ca:	b0 89       	st.b	r8[0x0],r9
				phy_tx_state = WRITE_NEXT_DWORD;	
800032cc:	30 19       	mov	r9,1
800032ce:	fe f8 05 02 	ld.w	r8,pc[1282]
800032d2:	91 09       	st.w	r8[0x0],r9
800032d4:	c4 a8       	rjmp	80003368 <phy_tx_func+0xf8>
				/*The new transmission has started.*/
			}
			else
			{
				/*Nothing new to transmit, send an idle frame*/
				xnl_tx_channel->dword = XNL_IDLE;
800032d6:	e0 68 5a 5a 	mov	r8,23130
800032da:	ea 18 ab cd 	orh	r8,0xabcd
800032de:	8f 18       	st.w	r7[0x4],r8
800032e0:	c4 48       	rjmp	80003368 <phy_tx_func+0xf8>
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
800032e2:	fe f9 04 fe 	ld.w	r9,pc[1278]
800032e6:	13 88       	ld.ub	r8,r9[0x0]
				xnl_tx_channel->dword = XNL_IDLE;
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
800032e8:	fe fa 04 ec 	ld.w	r10,pc[1260]
800032ec:	74 0a       	ld.w	r10,r10[0x0]
800032ee:	f4 08 05 1a 	ld.uh	r10,r10[r8<<0x1]
800032f2:	b1 6a       	lsl	r10,0x10
800032f4:	99 1a       	st.w	r12[0x4],r10
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
800032f6:	2f f8       	sub	r8,-1
800032f8:	5c 58       	castu.b	r8
800032fa:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
800032fc:	fe fa 04 e0 	ld.w	r10,pc[1248]
80003300:	94 09       	ld.sh	r9,r10[0x0]
80003302:	20 29       	sub	r9,2
80003304:	b4 09       	st.h	r10[0x0],r9
			
			/*have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80003306:	30 0a       	mov	r10,0
80003308:	f4 09 19 00 	cp.h	r9,r10
8000330c:	e0 89 00 0b 	brgt	80003322 <phy_tx_func+0xb2>
			{
				/*Must immediately send 0x00BA in Slot 4.*/
				xnl_tx_channel->dword |= PHYTERMRIGHT;
80003310:	78 18       	ld.w	r8,r12[0x4]
80003312:	e8 18 00 ba 	orl	r8,0xba
80003316:	99 18       	st.w	r12[0x4],r8
				
				/*Go back to waiting.*/
				//vPortFree(phy_ptr);
				phy_tx_state = WAITING_FOR_PHY_TX;
80003318:	30 09       	mov	r9,0
8000331a:	fe f8 04 b6 	ld.w	r8,pc[1206]
8000331e:	91 09       	st.w	r8[0x0],r9
80003320:	c2 48       	rjmp	80003368 <phy_tx_func+0xf8>
				break;
			}

			/*Have not broken. Transmit 2nd hWord.*/
			xnl_tx_channel->dword |=  phy_ptr->fragment_element[phy_tx_index++];
80003322:	fe f9 04 b2 	ld.w	r9,pc[1202]
80003326:	72 09       	ld.w	r9,r9[0x0]
80003328:	f2 08 05 19 	ld.uh	r9,r9[r8<<0x1]
8000332c:	78 1a       	ld.w	r10,r12[0x4]
8000332e:	f5 e9 10 09 	or	r9,r10,r9
80003332:	99 19       	st.w	r12[0x4],r9
80003334:	2f f8       	sub	r8,-1
80003336:	fe f9 04 aa 	ld.w	r9,pc[1194]
8000333a:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
8000333c:	fe f9 04 a0 	ld.w	r9,pc[1184]
80003340:	92 08       	ld.sh	r8,r9[0x0]
80003342:	20 28       	sub	r8,2
80003344:	b2 08       	st.h	r9[0x0],r8
			
			/*Have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80003346:	30 09       	mov	r9,0
80003348:	f2 08 19 00 	cp.h	r8,r9
8000334c:	e0 89 00 0e 	brgt	80003368 <phy_tx_func+0xf8>
			{
				/*Must send 0x00BA0000 next interrupt in Slot 3&4*/
				phy_tx_state = SEND_TAILED;
80003350:	30 29       	mov	r9,2
80003352:	fe f8 04 7e 	ld.w	r8,pc[1150]
80003356:	91 09       	st.w	r8[0x0],r9
80003358:	c0 88       	rjmp	80003368 <phy_tx_func+0xf8>
			}
			break;

		case SEND_TAILED:
			/*send 0x00BA0000*/
			xnl_tx_channel->dword = PHYTERMLEFT;
8000335a:	fc 18 00 ba 	movh	r8,0xba
8000335e:	99 18       	st.w	r12[0x4],r8
			
			/*Go back to waiting.*/	
			//vPortFree(phy_ptr);		
			phy_tx_state = WAITING_FOR_PHY_TX;		
80003360:	30 09       	mov	r9,0
80003362:	fe f8 04 6e 	ld.w	r8,pc[1134]
80003366:	91 09       	st.w	r8[0x0],r9
	static U32 i = 0;
	//static U8 frame_5_end = 0;
	//static U16 pay[256];
	
	//Send-AMBE-data
	if (AMBE_flag)
80003368:	fe f8 04 7c 	ld.w	r8,pc[1148]
8000336c:	11 89       	ld.ub	r9,r8[0x0]
8000336e:	30 08       	mov	r8,0
80003370:	f0 09 18 00 	cp.b	r9,r8
80003374:	e0 80 00 c6 	breq	80003500 <phy_tx_func+0x290>
	{

	  //AMBE_flag
		switch(payload_tx_state)
80003378:	fe f8 04 70 	ld.w	r8,pc[1136]
8000337c:	11 88       	ld.ub	r8,r8[0x0]
8000337e:	30 19       	mov	r9,1
80003380:	f2 08 18 00 	cp.b	r8,r9
80003384:	c3 e0       	breq	80003400 <phy_tx_func+0x190>
80003386:	c0 73       	brcs	80003394 <phy_tx_func+0x124>
80003388:	30 29       	mov	r9,2
8000338a:	f2 08 18 00 	cp.b	r8,r9
8000338e:	e0 81 02 1b 	brne	800037c4 <phy_tx_func+0x554>
80003392:	c9 28       	rjmp	800034b6 <phy_tx_func+0x246>
		{
			case 0:
		
				if ((m_RxBurstType == VOICE_WATING) || (m_RxBurstType == VOICETERMINATOR)  || (m_RxBurstType == VOICEHEADER))
80003394:	fe f8 04 58 	ld.w	r8,pc[1112]
80003398:	70 08       	ld.w	r8,r8[0x0]
8000339a:	58 08       	cp.w	r8,0
8000339c:	c0 b0       	breq	800033b2 <phy_tx_func+0x142>
8000339e:	fe f8 04 4e 	ld.w	r8,pc[1102]
800033a2:	70 08       	ld.w	r8,r8[0x0]
800033a4:	58 98       	cp.w	r8,9
800033a6:	c0 60       	breq	800033b2 <phy_tx_func+0x142>
800033a8:	fe f8 04 44 	ld.w	r8,pc[1092]
800033ac:	70 08       	ld.w	r8,r8[0x0]
800033ae:	58 18       	cp.w	r8,1
800033b0:	c0 a1       	brne	800033c4 <phy_tx_func+0x154>
				{
							
					payload_tx_channel->dword[0] = PAYLOADIDLE0;
800033b2:	e0 68 5a 5a 	mov	r8,23130
800033b6:	ea 18 ab cd 	orh	r8,0xabcd
800033ba:	8f 28       	st.w	r7[0x8],r8
					payload_tx_channel->dword[1] = PAYLOADIDLE1;
800033bc:	30 08       	mov	r8,0
800033be:	8f 38       	st.w	r7[0xc],r8
800033c0:	e0 8f 02 02 	bral	800037c4 <phy_tx_func+0x554>
			
				}
				else if((m_RxBurstType == UNSUREDATA))
800033c4:	fe f8 04 28 	ld.w	r8,pc[1064]
800033c8:	70 08       	ld.w	r8,r8[0x0]
800033ca:	58 28       	cp.w	r8,2
800033cc:	c0 91       	brne	800033de <phy_tx_func+0x16e>
				{
					payload_tx_channel->dword[0] = AMBE_HT[0];
800033ce:	fe f8 04 22 	ld.w	r8,pc[1058]
800033d2:	70 09       	ld.w	r9,r8[0x0]
800033d4:	8f 29       	st.w	r7[0x8],r9
					payload_tx_channel->dword[1] = AMBE_HT[1];
800033d6:	70 18       	ld.w	r8,r8[0x4]
800033d8:	8f 38       	st.w	r7[0xc],r8
800033da:	e0 8f 01 f5 	bral	800037c4 <phy_tx_func+0x554>
				}
				else
				{
					payload_tx_state = 1;
800033de:	30 19       	mov	r9,1
800033e0:	fe f8 04 08 	ld.w	r8,pc[1032]
800033e4:	b0 89       	st.b	r8[0x0],r9
					
					//0xABCDCOOE
					payload_tx_channel->dword[0] = EN_OB_PAYLOAD;//49bits
800033e6:	e0 68 c0 0e 	mov	r8,49166
800033ea:	ea 18 ab cd 	orh	r8,0xabcd
800033ee:	8f 28       	st.w	r7[0x8],r8
					//0x8212
					payload_tx_channel->word[2] = VBSP_data[0];
800033f0:	fe f8 04 04 	ld.w	r8,pc[1028]
800033f4:	90 09       	ld.sh	r9,r8[0x0]
800033f6:	ae 69       	st.h	r7[0xc],r9
					//0xF00x
					payload_tx_channel->word[3] = VBSP_data[1];
800033f8:	90 18       	ld.sh	r8,r8[0x2]
800033fa:	ae 78       	st.h	r7[0xe],r8
800033fc:	e0 8f 01 e4 	bral	800037c4 <phy_tx_func+0x554>
				break;
			
			case 1:
			
				//0x88F2
				payload_tx_channel->word[0] = ENCODER_PAYLOAD;//49bits
80003400:	fe 78 88 f2 	mov	r8,-30478
80003404:	ae 48       	st.h	r7[0x8],r8
			
				switch (m_RxBurstType)//在发送函数中去做加密处理
80003406:	fe f8 03 e6 	ld.w	r8,pc[998]
8000340a:	70 08       	ld.w	r8,r8[0x0]
8000340c:	58 38       	cp.w	r8,3
8000340e:	c0 60       	breq	8000341a <phy_tx_func+0x1aa>
80003410:	c4 73       	brcs	8000349e <phy_tx_func+0x22e>
80003412:	58 88       	cp.w	r8,8
80003414:	e0 8b 00 45 	brhi	8000349e <phy_tx_func+0x22e>
80003418:	c2 a8       	rjmp	8000346c <phy_tx_func+0x1fc>
				{
					case VOICEBURST_A:
							if (VF_SN == 1)
8000341a:	fe f8 03 de 	ld.w	r8,pc[990]
8000341e:	11 89       	ld.ub	r9,r8[0x0]
80003420:	30 18       	mov	r8,1
80003422:	f0 09 18 00 	cp.b	r9,r8
80003426:	c0 a1       	brne	8000343a <phy_tx_func+0x1ca>
							{	
								//Place public key
								payload_tx_channel->word[1] = Public_AMBEkey[0];
80003428:	fe f8 03 d4 	ld.w	r8,pc[980]
8000342c:	90 09       	ld.sh	r9,r8[0x0]
8000342e:	ae 59       	st.h	r7[0xa],r9
								payload_tx_channel->word[2] = Public_AMBEkey[1];
80003430:	90 19       	ld.sh	r9,r8[0x2]
80003432:	ae 69       	st.h	r7[0xc],r9
								payload_tx_channel->word[3] = Public_AMBEkey[2];
80003434:	90 28       	ld.sh	r8,r8[0x4]
80003436:	ae 78       	st.h	r7[0xe],r8
80003438:	c1 48       	rjmp	80003460 <phy_tx_func+0x1f0>
								//logFromISR("\n\r MMQ \n\r");
							}
							else//VF_SN==2/3
							{
								//Encrypted AMBE data(XOR)
								payload_tx_channel->word[1] = ((Public_AMBEkey[0]) ^ (AMBEBurst_rawdata[0])) ;
8000343a:	fe f9 03 c6 	ld.w	r9,pc[966]
8000343e:	92 0b       	ld.sh	r11,r9[0x0]
80003440:	fe f8 03 bc 	ld.w	r8,pc[956]
80003444:	90 0a       	ld.sh	r10,r8[0x0]
80003446:	f7 ea 20 0a 	eor	r10,r11,r10
8000344a:	ae 5a       	st.h	r7[0xa],r10
								payload_tx_channel->word[2] = ((Public_AMBEkey[1]) ^ (AMBEBurst_rawdata[1])) ;
8000344c:	92 1b       	ld.sh	r11,r9[0x2]
8000344e:	90 1a       	ld.sh	r10,r8[0x2]
80003450:	f7 ea 20 0a 	eor	r10,r11,r10
80003454:	ae 6a       	st.h	r7[0xc],r10
								payload_tx_channel->word[3] = ((Public_AMBEkey[2]) ^ (AMBEBurst_rawdata[2])) ;
80003456:	92 29       	ld.sh	r9,r9[0x4]
80003458:	90 28       	ld.sh	r8,r8[0x4]
8000345a:	f3 e8 20 08 	eor	r8,r9,r8
8000345e:	ae 78       	st.h	r7[0xe],r8
								//payload_tx_channel->word[2] = AMBEBurst_rawdata[1];
								//payload_tx_channel->word[3] = AMBEBurst_rawdata[2];
						
							}
					
							payload_tx_state = 2;
80003460:	30 29       	mov	r9,2
80003462:	fe f8 03 86 	ld.w	r8,pc[902]
80003466:	b0 89       	st.b	r8[0x0],r9
80003468:	e0 8f 01 ae 	bral	800037c4 <phy_tx_func+0x554>
							//Encrypted AMBE data(XOR)
						
							//payload_tx_channel->word[1] = AMBEBurst_rawdata[0];
							//payload_tx_channel->word[2] = AMBEBurst_rawdata[1];
							//payload_tx_channel->word[3] = AMBEBurst_rawdata[2];
							payload_tx_channel->word[1] = ((Public_AMBEkey[0]) ^ (AMBEBurst_rawdata[0])) ;
8000346c:	fe f9 03 94 	ld.w	r9,pc[916]
80003470:	92 0b       	ld.sh	r11,r9[0x0]
80003472:	fe f8 03 8a 	ld.w	r8,pc[906]
80003476:	90 0a       	ld.sh	r10,r8[0x0]
80003478:	f7 ea 20 0a 	eor	r10,r11,r10
8000347c:	ae 5a       	st.h	r7[0xa],r10
							payload_tx_channel->word[2] = ((Public_AMBEkey[1]) ^ (AMBEBurst_rawdata[1])) ;
8000347e:	92 1b       	ld.sh	r11,r9[0x2]
80003480:	90 1a       	ld.sh	r10,r8[0x2]
80003482:	f7 ea 20 0a 	eor	r10,r11,r10
80003486:	ae 6a       	st.h	r7[0xc],r10
							payload_tx_channel->word[3] = ((Public_AMBEkey[2]) ^ (AMBEBurst_rawdata[2])) ;
80003488:	92 29       	ld.sh	r9,r9[0x4]
8000348a:	90 28       	ld.sh	r8,r8[0x4]
8000348c:	f3 e8 20 08 	eor	r8,r9,r8
80003490:	ae 78       	st.h	r7[0xe],r8
						
							payload_tx_state = 2;
80003492:	30 29       	mov	r9,2
80003494:	fe f8 03 54 	ld.w	r8,pc[852]
80003498:	b0 89       	st.b	r8[0x0],r9
8000349a:	e0 8f 01 95 	bral	800037c4 <phy_tx_func+0x554>
				
						break;
					default://This shouldn't happen, but must check;
					
							payload_tx_channel->dword[0] = PAYLOADIDLE0;
8000349e:	e0 68 5a 5a 	mov	r8,23130
800034a2:	ea 18 ab cd 	orh	r8,0xabcd
800034a6:	8f 28       	st.w	r7[0x8],r8
							payload_tx_channel->dword[1] = PAYLOADIDLE1;
800034a8:	30 08       	mov	r8,0
800034aa:	8f 38       	st.w	r7[0xc],r8
							payload_tx_state = 0;
800034ac:	fe f9 03 3c 	ld.w	r9,pc[828]
800034b0:	b2 88       	st.b	r9[0x0],r8
800034b2:	e0 8f 01 89 	bral	800037c4 <phy_tx_func+0x554>
			
			case 2:
					//Encrypted AMBE data(XOR)
					//payload_tx_channel->word[0] = AMBEBurst_rawdata[3];
				
					if ((m_RxBurstType == VOICEBURST_A) && (VF_SN == 1))
800034b6:	fe f8 03 36 	ld.w	r8,pc[822]
800034ba:	70 08       	ld.w	r8,r8[0x0]
800034bc:	58 38       	cp.w	r8,3
800034be:	c0 d1       	brne	800034d8 <phy_tx_func+0x268>
800034c0:	fe f8 03 38 	ld.w	r8,pc[824]
800034c4:	11 89       	ld.ub	r9,r8[0x0]
800034c6:	30 18       	mov	r8,1
800034c8:	f0 09 18 00 	cp.b	r9,r8
800034cc:	c0 61       	brne	800034d8 <phy_tx_func+0x268>
					{
						payload_tx_channel->word[0]	= ((Public_AMBEkey[3])) ;
800034ce:	fe f8 03 2e 	ld.w	r8,pc[814]
800034d2:	90 38       	ld.sh	r8,r8[0x6]
800034d4:	ae 48       	st.h	r7[0x8],r8
800034d6:	c0 a8       	rjmp	800034ea <phy_tx_func+0x27a>
					}
					else{
					
						payload_tx_channel->word[0]	= ((Public_AMBEkey[3]) ^ (AMBEBurst_rawdata[3])) ;
800034d8:	fe f8 03 28 	ld.w	r8,pc[808]
800034dc:	90 39       	ld.sh	r9,r8[0x6]
800034de:	fe f8 03 1e 	ld.w	r8,pc[798]
800034e2:	90 38       	ld.sh	r8,r8[0x6]
800034e4:	f3 e8 20 08 	eor	r8,r9,r8
800034e8:	ae 48       	st.h	r7[0x8],r8
					
					}
					payload_tx_channel->word[1]	= 0x00BA ; 
800034ea:	e0 68 00 ba 	mov	r8,186
800034ee:	ae 58       	st.h	r7[0xa],r8
					payload_tx_channel->word[2]	= 0x0000 ;
800034f0:	30 08       	mov	r8,0
800034f2:	ae 68       	st.h	r7[0xc],r8
					payload_tx_channel->word[3]	= 0x0000 ;
800034f4:	ae 78       	st.h	r7[0xe],r8
				
					payload_tx_state = 0;
800034f6:	fe f9 02 f2 	ld.w	r9,pc[754]
800034fa:	b2 88       	st.b	r9[0x0],r8
800034fc:	e0 8f 01 64 	bral	800037c4 <phy_tx_func+0x554>

#if 1
else//Send-PCM-data（注意测试回放时：模拟信道码流为40bytes/2.5ms.）
{
	
	index = (index >=30240) ? 0 : index;
80003500:	fe f8 03 04 	ld.w	r8,pc[772]
80003504:	70 08       	ld.w	r8,r8[0x0]
80003506:	e0 48 76 20 	cp.w	r8,30240
8000350a:	f9 b8 02 00 	movhs	r8,0
8000350e:	fe f9 02 f6 	ld.w	r9,pc[758]
80003512:	93 08       	st.w	r9[0x0],r8
	
	if(is_unmute == 1)counter++;
80003514:	fe f8 02 f4 	ld.w	r8,pc[756]
80003518:	11 89       	ld.ub	r9,r8[0x0]
8000351a:	30 18       	mov	r8,1
8000351c:	f0 09 18 00 	cp.b	r9,r8
80003520:	c0 61       	brne	8000352c <phy_tx_func+0x2bc>
80003522:	fe f8 02 ea 	ld.w	r8,pc[746]
80003526:	70 09       	ld.w	r9,r8[0x0]
80003528:	2f f9       	sub	r9,-1
8000352a:	91 09       	st.w	r8[0x0],r9
	
	switch(payload_tx_state)
8000352c:	fe f8 02 bc 	ld.w	r8,pc[700]
80003530:	11 88       	ld.ub	r8,r8[0x0]
80003532:	30 19       	mov	r9,1
80003534:	f2 08 18 00 	cp.b	r8,r9
80003538:	c3 60       	breq	800035a4 <phy_tx_func+0x334>
8000353a:	c0 73       	brcs	80003548 <phy_tx_func+0x2d8>
8000353c:	30 29       	mov	r9,2
8000353e:	f2 08 18 00 	cp.b	r8,r9
80003542:	e0 81 01 3e 	brne	800037be <phy_tx_func+0x54e>
80003546:	c7 c8       	rjmp	8000363e <phy_tx_func+0x3ce>
	{
		case 0:
		
			payload_tx_channel->dword[0] = PAYLOADIDLE0;
80003548:	e0 68 5a 5a 	mov	r8,23130
8000354c:	ea 18 ab cd 	orh	r8,0xabcd
80003550:	8f 28       	st.w	r7[0x8],r8
			payload_tx_channel->dword[1] = PAYLOADIDLE1;
80003552:	30 08       	mov	r8,0
80003554:	8f 38       	st.w	r7[0xc],r8
		
			if(((counter % 20 )== 0) && (counter != 0) &&(is_unmute == 1))//20*125us = 2.5ms.
80003556:	fe f8 02 b6 	ld.w	r8,pc[694]
8000355a:	70 08       	ld.w	r8,r8[0x0]
8000355c:	e0 6b cc cd 	mov	r11,52429
80003560:	ea 1b cc cc 	orh	r11,0xcccc
80003564:	f0 0b 06 4a 	mulu.d	r10,r8,r11
80003568:	f6 09 16 04 	lsr	r9,r11,0x4
8000356c:	f2 09 00 29 	add	r9,r9,r9<<0x2
80003570:	f0 09 01 29 	sub	r9,r8,r9<<0x2
80003574:	c1 21       	brne	80003598 <phy_tx_func+0x328>
80003576:	58 08       	cp.w	r8,0
80003578:	c1 00       	breq	80003598 <phy_tx_func+0x328>
8000357a:	fe f8 02 8e 	ld.w	r8,pc[654]
8000357e:	11 89       	ld.ub	r9,r8[0x0]
80003580:	30 18       	mov	r8,1
80003582:	f0 09 18 00 	cp.b	r9,r8
80003586:	c0 91       	brne	80003598 <phy_tx_func+0x328>
			{
				payload_tx_state = 1;
80003588:	10 99       	mov	r9,r8
8000358a:	fe f8 02 5e 	ld.w	r8,pc[606]
8000358e:	b0 89       	st.b	r8[0x0],r9
				//payload_tx_state = 0;
				frame_number = 0;
80003590:	30 09       	mov	r9,0
80003592:	fe f8 02 7e 	ld.w	r8,pc[638]
80003596:	b0 89       	st.b	r8[0x0],r9
	
			}
		
			send_num++;
80003598:	fe f8 02 7c 	ld.w	r8,pc[636]
8000359c:	70 09       	ld.w	r9,r8[0x0]
8000359e:	2f f9       	sub	r9,-1
800035a0:	91 09       	st.w	r8[0x0],r9
800035a2:	c1 19       	rjmp	800037c4 <phy_tx_func+0x554>
			break;
		
		case 1:
		
	
			payload_tx_channel->word[0] = 0xABCD; 
800035a4:	fe 78 ab cd 	mov	r8,-21555
800035a8:	ae 48       	st.h	r7[0x8],r8
		
			if(frame_number == 0)
800035aa:	fe f8 02 66 	ld.w	r8,pc[614]
800035ae:	11 89       	ld.ub	r9,r8[0x0]
800035b0:	30 08       	mov	r8,0
800035b2:	f0 09 18 00 	cp.b	r9,r8
800035b6:	c1 b1       	brne	800035ec <phy_tx_func+0x37c>
			{
				if (Silent_flag == 1)
800035b8:	fe f8 02 60 	ld.w	r8,pc[608]
800035bc:	11 89       	ld.ub	r9,r8[0x0]
800035be:	30 18       	mov	r8,1
800035c0:	f0 09 18 00 	cp.b	r9,r8
800035c4:	c0 91       	brne	800035d6 <phy_tx_func+0x366>
				{
					//即是44betes-4bytes= 40bytes
					expexted_length = 0x2C;//One Descriptor Indicator
800035c6:	32 c9       	mov	r9,44
800035c8:	fe f8 02 54 	ld.w	r8,pc[596]
800035cc:	b0 09       	st.h	r8[0x0],r9
					payload_tx_channel->word[1] = 0x102C;//44betes-4bytes= 40bytes
800035ce:	e0 68 10 2c 	mov	r8,4140
800035d2:	ae 58       	st.h	r7[0xa],r8
800035d4:	c0 88       	rjmp	800035e4 <phy_tx_func+0x374>
				}
				
				else
				{
					//first frame
					expexted_length = 0x2A;
800035d6:	32 a9       	mov	r9,42
800035d8:	fe f8 02 44 	ld.w	r8,pc[580]
800035dc:	b0 09       	st.h	r8[0x0],r9
					payload_tx_channel->word[1] = 0x102A;//42-2= 40 bytes;	
800035de:	e0 68 10 2a 	mov	r8,4138
800035e2:	ae 58       	st.h	r7[0xa],r8
				}
				
					last_frame = TRUE;
800035e4:	30 19       	mov	r9,1
800035e6:	fe f8 02 3a 	ld.w	r8,pc[570]
800035ea:	b0 89       	st.b	r8[0x0],r9
			//
			//
			//}
			//else//不执行
			
			if (Silent_flag == 1)//发送静音指令
800035ec:	fe f8 02 2c 	ld.w	r8,pc[556]
800035f0:	11 89       	ld.ub	r9,r8[0x0]
800035f2:	30 18       	mov	r8,1
800035f4:	f0 09 18 00 	cp.b	r9,r8
800035f8:	c0 61       	brne	80003604 <phy_tx_func+0x394>
			{
			
				payload_tx_channel->word[2] = 0x0001;//Array Descriptor Length
800035fa:	30 18       	mov	r8,1
800035fc:	ae 68       	st.h	r7[0xc],r8
				payload_tx_channel->word[3] =  0x0004;//Silent Descriptor Indicator
800035fe:	30 48       	mov	r8,4
80003600:	ae 78       	st.h	r7[0xe],r8
80003602:	c1 38       	rjmp	80003628 <phy_tx_func+0x3b8>

			}
			else
			{
			
				payload_tx_channel->word[2] = 0x0000;
80003604:	30 08       	mov	r8,0
80003606:	ae 68       	st.h	r7[0xc],r8
				payload_tx_channel->word[3] =  ((AudioData[index]<<8 )+ AudioData[index+1] );
80003608:	4f f8       	lddpc	r8,80003804 <phy_tx_func+0x594>
8000360a:	70 09       	ld.w	r9,r8[0x0]
8000360c:	fe fa 02 18 	ld.w	r10,pc[536]
80003610:	f4 09 00 0b 	add	r11,r10,r9
80003614:	17 9b       	ld.ub	r11,r11[0x1]
80003616:	f4 09 07 09 	ld.ub	r9,r10[r9]
8000361a:	a9 69       	lsl	r9,0x8
8000361c:	f6 09 00 09 	add	r9,r11,r9
80003620:	ae 79       	st.h	r7[0xe],r9
				index+=2;
80003622:	70 09       	ld.w	r9,r8[0x0]
80003624:	2f e9       	sub	r9,-2
80003626:	91 09       	st.w	r8[0x0],r9
			
			}
		
			expexted_length -= 4;
80003628:	4f d8       	lddpc	r8,8000381c <phy_tx_func+0x5ac>
8000362a:	90 09       	ld.sh	r9,r8[0x0]
8000362c:	20 49       	sub	r9,4
8000362e:	b0 09       	st.h	r8[0x0],r9
		
			//frame_number++;
			payload_tx_state = 2;
80003630:	30 29       	mov	r9,2
80003632:	4e e8       	lddpc	r8,800037e8 <phy_tx_func+0x578>
80003634:	b0 89       	st.b	r8[0x0],r9
		
			i = 0;
80003636:	30 09       	mov	r9,0
80003638:	4f c8       	lddpc	r8,80003828 <phy_tx_func+0x5b8>
8000363a:	91 09       	st.w	r8[0x0],r9
8000363c:	cc 48       	rjmp	800037c4 <phy_tx_func+0x554>
		
			break;
		
		case 2:
		
			if(expexted_length <= 0)
8000363e:	4f 88       	lddpc	r8,8000381c <phy_tx_func+0x5ac>
80003640:	90 09       	ld.sh	r9,r8[0x0]
80003642:	30 08       	mov	r8,0
80003644:	f0 09 19 00 	cp.h	r9,r8
80003648:	e0 89 00 12 	brgt	8000366c <phy_tx_func+0x3fc>
			{
				//last word 0x00BA
				payload_tx_state = last_frame ? 0 : 1;
8000364c:	4f 58       	lddpc	r8,80003820 <phy_tx_func+0x5b0>
8000364e:	11 89       	ld.ub	r9,r8[0x0]
80003650:	30 08       	mov	r8,0
80003652:	f0 09 18 00 	cp.b	r9,r8
80003656:	5f 09       	sreq	r9
80003658:	4e 48       	lddpc	r8,800037e8 <phy_tx_func+0x578>
8000365a:	b0 89       	st.b	r8[0x0],r9
				payload_tx_channel->word[0] = 0x00BA;
8000365c:	e0 68 00 ba 	mov	r8,186
80003660:	ae 48       	st.h	r7[0x8],r8
				payload_tx_channel->word[1] = 0x0000;
80003662:	30 08       	mov	r8,0
80003664:	ae 58       	st.h	r7[0xa],r8
				payload_tx_channel->word[2] = 0x0000;
80003666:	ae 68       	st.h	r7[0xc],r8
				payload_tx_channel->word[3] = 0x0000;
80003668:	ae 78       	st.h	r7[0xe],r8
8000366a:	ca d8       	rjmp	800037c4 <phy_tx_func+0x554>
				break;
			}
		
			if(Silent_flag == 1)
8000366c:	4e b8       	lddpc	r8,80003818 <phy_tx_func+0x5a8>
8000366e:	11 89       	ld.ub	r9,r8[0x0]
80003670:	30 18       	mov	r8,1
80003672:	f0 09 18 00 	cp.b	r9,r8
80003676:	c0 41       	brne	8000367e <phy_tx_func+0x40e>
			{
				payload_tx_channel->word[0] =  0x0000;
80003678:	30 08       	mov	r8,0
8000367a:	ae 48       	st.h	r7[0x8],r8
8000367c:	c1 08       	rjmp	8000369c <phy_tx_func+0x42c>
			}
			else
			{
				//payload_tx_channel->word[0] = AudioData[index++] + (AudioData[index++] << 8);
				payload_tx_channel->word[0] =  ((AudioData[index]<<8 )+ AudioData[index+1] );
8000367e:	4e 28       	lddpc	r8,80003804 <phy_tx_func+0x594>
80003680:	70 09       	ld.w	r9,r8[0x0]
80003682:	4e 9a       	lddpc	r10,80003824 <phy_tx_func+0x5b4>
80003684:	f4 09 00 0b 	add	r11,r10,r9
80003688:	17 9b       	ld.ub	r11,r11[0x1]
8000368a:	f4 09 07 09 	ld.ub	r9,r10[r9]
8000368e:	a9 69       	lsl	r9,0x8
80003690:	f6 09 00 09 	add	r9,r11,r9
80003694:	ae 49       	st.h	r7[0x8],r9
				index+=2;
80003696:	70 09       	ld.w	r9,r8[0x0]
80003698:	2f e9       	sub	r9,-2
8000369a:	91 09       	st.w	r8[0x0],r9
			
			}

			expexted_length -= 2;
8000369c:	4e 09       	lddpc	r9,8000381c <phy_tx_func+0x5ac>
8000369e:	92 08       	ld.sh	r8,r9[0x0]
800036a0:	20 28       	sub	r8,2
800036a2:	b2 08       	st.h	r9[0x0],r8
			if(expexted_length <= 0)
800036a4:	30 09       	mov	r9,0
800036a6:	f2 08 19 00 	cp.h	r8,r9
800036aa:	e0 89 00 11 	brgt	800036cc <phy_tx_func+0x45c>
			{
				//last word 0x00BA
				payload_tx_state = last_frame ? 0 : 1;
800036ae:	4d d8       	lddpc	r8,80003820 <phy_tx_func+0x5b0>
800036b0:	11 89       	ld.ub	r9,r8[0x0]
800036b2:	30 08       	mov	r8,0
800036b4:	f0 09 18 00 	cp.b	r9,r8
800036b8:	5f 09       	sreq	r9
800036ba:	4c c8       	lddpc	r8,800037e8 <phy_tx_func+0x578>
800036bc:	b0 89       	st.b	r8[0x0],r9
				payload_tx_channel->word[1] = 0x00BA;
800036be:	e0 68 00 ba 	mov	r8,186
800036c2:	ae 58       	st.h	r7[0xa],r8
				payload_tx_channel->word[2] = 0x0000;
800036c4:	30 08       	mov	r8,0
800036c6:	ae 68       	st.h	r7[0xc],r8
				payload_tx_channel->word[3] = 0x0000;
800036c8:	ae 78       	st.h	r7[0xe],r8
800036ca:	c7 d8       	rjmp	800037c4 <phy_tx_func+0x554>
				break;
			}
		
			if(Silent_flag == 1)
800036cc:	4d 38       	lddpc	r8,80003818 <phy_tx_func+0x5a8>
800036ce:	11 89       	ld.ub	r9,r8[0x0]
800036d0:	30 18       	mov	r8,1
800036d2:	f0 09 18 00 	cp.b	r9,r8
800036d6:	c0 41       	brne	800036de <phy_tx_func+0x46e>
			{
				payload_tx_channel->word[1] =  0x0000;
800036d8:	30 08       	mov	r8,0
800036da:	ae 58       	st.h	r7[0xa],r8
800036dc:	c1 08       	rjmp	800036fc <phy_tx_func+0x48c>
			}
			else
			{
			
				payload_tx_channel->word[1] =  ((AudioData[index]<<8 )+ AudioData[index+1] );
800036de:	4c a8       	lddpc	r8,80003804 <phy_tx_func+0x594>
800036e0:	70 09       	ld.w	r9,r8[0x0]
800036e2:	4d 1a       	lddpc	r10,80003824 <phy_tx_func+0x5b4>
800036e4:	f4 09 00 0b 	add	r11,r10,r9
800036e8:	17 9b       	ld.ub	r11,r11[0x1]
800036ea:	f4 09 07 09 	ld.ub	r9,r10[r9]
800036ee:	a9 69       	lsl	r9,0x8
800036f0:	f6 09 00 09 	add	r9,r11,r9
800036f4:	ae 59       	st.h	r7[0xa],r9
				index+=2;
800036f6:	70 09       	ld.w	r9,r8[0x0]
800036f8:	2f e9       	sub	r9,-2
800036fa:	91 09       	st.w	r8[0x0],r9
			}
			//payload_tx_channel->word[1] =  ((AudioData[index]<<8 )+ AudioData[index+1] );
		
			expexted_length -= 2;
800036fc:	4c 89       	lddpc	r9,8000381c <phy_tx_func+0x5ac>
800036fe:	92 08       	ld.sh	r8,r9[0x0]
80003700:	20 28       	sub	r8,2
80003702:	b2 08       	st.h	r9[0x0],r8
			if(expexted_length <= 0)
80003704:	30 09       	mov	r9,0
80003706:	f2 08 19 00 	cp.h	r8,r9
8000370a:	e0 89 00 10 	brgt	8000372a <phy_tx_func+0x4ba>
			{
				//last word 0x00BA
				payload_tx_state = last_frame ? 0 : 1;
8000370e:	4c 58       	lddpc	r8,80003820 <phy_tx_func+0x5b0>
80003710:	11 89       	ld.ub	r9,r8[0x0]
80003712:	30 08       	mov	r8,0
80003714:	f0 09 18 00 	cp.b	r9,r8
80003718:	5f 09       	sreq	r9
8000371a:	4b 48       	lddpc	r8,800037e8 <phy_tx_func+0x578>
8000371c:	b0 89       	st.b	r8[0x0],r9
				payload_tx_channel->word[2] = 0x00BA;
8000371e:	e0 68 00 ba 	mov	r8,186
80003722:	ae 68       	st.h	r7[0xc],r8
				payload_tx_channel->word[3] = 0x0000;
80003724:	30 08       	mov	r8,0
80003726:	ae 78       	st.h	r7[0xe],r8
80003728:	c4 e8       	rjmp	800037c4 <phy_tx_func+0x554>
				break;
			}
		
			if(Silent_flag == 1)
8000372a:	4b c8       	lddpc	r8,80003818 <phy_tx_func+0x5a8>
8000372c:	11 89       	ld.ub	r9,r8[0x0]
8000372e:	30 18       	mov	r8,1
80003730:	f0 09 18 00 	cp.b	r9,r8
80003734:	c0 41       	brne	8000373c <phy_tx_func+0x4cc>
			{
				payload_tx_channel->word[2] =  0x0000;
80003736:	30 08       	mov	r8,0
80003738:	ae 68       	st.h	r7[0xc],r8
8000373a:	c1 08       	rjmp	8000375a <phy_tx_func+0x4ea>
			}
			else
			{
			
				payload_tx_channel->word[2] =  ((AudioData[index]<<8 )+ AudioData[index+1] );
8000373c:	4b 28       	lddpc	r8,80003804 <phy_tx_func+0x594>
8000373e:	70 09       	ld.w	r9,r8[0x0]
80003740:	4b 9a       	lddpc	r10,80003824 <phy_tx_func+0x5b4>
80003742:	f4 09 00 0b 	add	r11,r10,r9
80003746:	17 9b       	ld.ub	r11,r11[0x1]
80003748:	f4 09 07 09 	ld.ub	r9,r10[r9]
8000374c:	a9 69       	lsl	r9,0x8
8000374e:	f6 09 00 09 	add	r9,r11,r9
80003752:	ae 69       	st.h	r7[0xc],r9
				index+=2;
80003754:	70 09       	ld.w	r9,r8[0x0]
80003756:	2f e9       	sub	r9,-2
80003758:	91 09       	st.w	r8[0x0],r9
			}
			//payload_tx_channel->word[2] =  ((AudioData[index]<<8 )+ AudioData[index+1] );
		
			expexted_length -= 2;
8000375a:	4b 19       	lddpc	r9,8000381c <phy_tx_func+0x5ac>
8000375c:	92 08       	ld.sh	r8,r9[0x0]
8000375e:	20 28       	sub	r8,2
80003760:	b2 08       	st.h	r9[0x0],r8
			if(expexted_length <= 0)
80003762:	30 09       	mov	r9,0
80003764:	f2 08 19 00 	cp.h	r8,r9
80003768:	e0 89 00 0e 	brgt	80003784 <phy_tx_func+0x514>
			{
				//last word 0x00BA
				payload_tx_state = last_frame ? 0 : 1;
8000376c:	4a d8       	lddpc	r8,80003820 <phy_tx_func+0x5b0>
8000376e:	11 89       	ld.ub	r9,r8[0x0]
80003770:	30 08       	mov	r8,0
80003772:	f0 09 18 00 	cp.b	r9,r8
80003776:	5f 09       	sreq	r9
80003778:	49 c8       	lddpc	r8,800037e8 <phy_tx_func+0x578>
8000377a:	b0 89       	st.b	r8[0x0],r9
				payload_tx_channel->word[3] = 0x00BA;
8000377c:	e0 68 00 ba 	mov	r8,186
80003780:	ae 78       	st.h	r7[0xe],r8
80003782:	c2 18       	rjmp	800037c4 <phy_tx_func+0x554>
				break;
			}
		
			if(Silent_flag == 1)
80003784:	4a 58       	lddpc	r8,80003818 <phy_tx_func+0x5a8>
80003786:	11 89       	ld.ub	r9,r8[0x0]
80003788:	30 18       	mov	r8,1
8000378a:	f0 09 18 00 	cp.b	r9,r8
8000378e:	c0 41       	brne	80003796 <phy_tx_func+0x526>
			{
				payload_tx_channel->word[3] =  0x0000;
80003790:	30 08       	mov	r8,0
80003792:	ae 78       	st.h	r7[0xe],r8
80003794:	c1 08       	rjmp	800037b4 <phy_tx_func+0x544>
			}
			else
			{
			
				payload_tx_channel->word[3] =  ((AudioData[index]<<8 )+ AudioData[index+1] );
80003796:	49 c8       	lddpc	r8,80003804 <phy_tx_func+0x594>
80003798:	70 09       	ld.w	r9,r8[0x0]
8000379a:	4a 3a       	lddpc	r10,80003824 <phy_tx_func+0x5b4>
8000379c:	f4 09 00 0b 	add	r11,r10,r9
800037a0:	17 9b       	ld.ub	r11,r11[0x1]
800037a2:	f4 09 07 09 	ld.ub	r9,r10[r9]
800037a6:	a9 69       	lsl	r9,0x8
800037a8:	f6 09 00 09 	add	r9,r11,r9
800037ac:	ae 79       	st.h	r7[0xe],r9
				index+=2;
800037ae:	70 09       	ld.w	r9,r8[0x0]
800037b0:	2f e9       	sub	r9,-2
800037b2:	91 09       	st.w	r8[0x0],r9
			}
		
			//payload_tx_channel->word[3] =  ((AudioData[index]<<8 )+ AudioData[index+1] );
		
			expexted_length -= 2;
800037b4:	49 a8       	lddpc	r8,8000381c <phy_tx_func+0x5ac>
800037b6:	90 09       	ld.sh	r9,r8[0x0]
800037b8:	20 29       	sub	r9,2
800037ba:	b0 09       	st.h	r8[0x0],r9
800037bc:	c0 48       	rjmp	800037c4 <phy_tx_func+0x554>
		
			break;
		
		default:
			payload_tx_state = 0;
800037be:	30 09       	mov	r9,0
800037c0:	48 a8       	lddpc	r8,800037e8 <phy_tx_func+0x578>
800037c2:	b0 89       	st.b	r8[0x0],r9
	#else
	/*send idle frame*/	
	((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
	((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
	#endif /*end if*/
}
800037c4:	2f fd       	sub	sp,-4
800037c6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800037ca:	00 00       	add	r0,r0
800037cc:	00 00       	add	r0,r0
800037ce:	0a cc       	st.b	r5++,r12
800037d0:	00 00       	add	r0,r0
800037d2:	0a 90       	mov	r0,r5
800037d4:	00 00       	add	r0,r0
800037d6:	0a 6c       	and	r12,r5
800037d8:	80 00       	ld.sh	r0,r0[0x0]
800037da:	59 40       	cp.w	r0,20
800037dc:	00 00       	add	r0,r0
800037de:	0a b6       	st.h	r5++,r6
800037e0:	00 00       	add	r0,r0
800037e2:	0a a5       	st.w	r5++,r5
800037e4:	00 00       	add	r0,r0
800037e6:	0a 44       	or	r4,r5
800037e8:	00 00       	add	r0,r0
800037ea:	0a ac       	st.w	r5++,r12
800037ec:	00 00       	add	r0,r0
800037ee:	0a 74       	tst	r4,r5
800037f0:	00 00       	add	r0,r0
800037f2:	0a 94       	mov	r4,r5
800037f4:	00 00       	add	r0,r0
800037f6:	20 84       	sub	r4,8
800037f8:	00 00       	add	r0,r0
800037fa:	0a 4c       	or	r12,r5
800037fc:	80 00       	ld.sh	r0,r0[0x0]
800037fe:	d3 04       	*unknown*
80003800:	00 00       	add	r0,r0
80003802:	1f 8c       	ld.ub	r12,pc[0x0]
80003804:	00 00       	add	r0,r0
80003806:	0a 84       	andn	r4,r5
80003808:	00 00       	add	r0,r0
8000380a:	0a 4d       	or	sp,r5
8000380c:	00 00       	add	r0,r0
8000380e:	0a d0       	st.w	--r5,r0
80003810:	00 00       	add	r0,r0
80003812:	0a a4       	st.w	r5++,r4
80003814:	00 00       	add	r0,r0
80003816:	0a c0       	st.b	r5++,r0
80003818:	00 00       	add	r0,r0
8000381a:	0a 54       	eor	r4,r5
8000381c:	00 00       	add	r0,r0
8000381e:	0a dc       	st.w	--r5,r12
80003820:	00 00       	add	r0,r0
80003822:	0a 78       	tst	r8,r5
80003824:	80 00       	ld.sh	r0,r0[0x0]
80003826:	d3 60       	acall	0x36
80003828:	00 00       	add	r0,r0
8000382a:	0a e0       	st.h	--r5,r0

8000382c <get_idle_store>:
	}//End of RxMedia Phy Handler.
}
#endif /*end if*/

void * get_idle_store(xQueueHandle store)
{
8000382c:	d4 01       	pushm	lr
8000382e:	20 1d       	sub	sp,4
	void * ptr = NULL;
80003830:	30 0a       	mov	r10,0
80003832:	fa cb ff fc 	sub	r11,sp,-4
80003836:	16 da       	st.w	--r11,r10

	if(pdTRUE == xQueueReceive(store, &ptr, 0))
80003838:	14 99       	mov	r9,r10
8000383a:	1a 9b       	mov	r11,sp
8000383c:	f0 1f 00 05 	mcall	80003850 <get_idle_store+0x24>
80003840:	58 1c       	cp.w	r12,1
80003842:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80003846:	fb fc 00 00 	ld.weq	r12,sp[0x0]
	}
	else
	{
		return NULL;
	}
}
8000384a:	2f fd       	sub	sp,-4
8000384c:	d8 02       	popm	pc
8000384e:	00 00       	add	r0,r0
80003850:	80 00       	ld.sh	r0,r0[0x0]
80003852:	5a 30       	cp.w	r0,-29

80003854 <phy_init>:
    register_rx_tx_func -- ssc.c
	xQueueCreate -- freertos
Called By: xnl_init -- xnl.c
*/
void phy_init( void )
{
80003854:	eb cd 40 e0 	pushm	r5-r7,lr
    /*initialize the SSC*/
    ssc_init();
80003858:	f0 1f 00 21 	mcall	800038dc <phy_init+0x88>

    /*register the func to send/receive ssc packet*/
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
8000385c:	4a 1b       	lddpc	r11,800038e0 <phy_init+0x8c>
8000385e:	4a 2c       	lddpc	r12,800038e4 <phy_init+0x90>
80003860:	f0 1f 00 22 	mcall	800038e8 <phy_init+0x94>
	
	/*if enable send/receive payload(media), defined in physical.h*/	
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
80003864:	30 4b       	mov	r11,4
80003866:	31 ec       	mov	r12,30
80003868:	f0 1f 00 21 	mcall	800038ec <phy_init+0x98>
8000386c:	4a 18       	lddpc	r8,800038f0 <phy_init+0x9c>
8000386e:	91 0c       	st.w	r8[0x0],r12
80003870:	30 07       	mov	r7,0
	phy_fragment_t * xnl_ptr = NULL;
	for(int i= 0; i < MAX_XNL_STORE; i++ )
	{
		set_xnl_idle(&xnl_store[i]);
80003872:	10 96       	mov	r6,r8
80003874:	4a 05       	lddpc	r5,800038f4 <phy_init+0xa0>
80003876:	6c 0c       	ld.w	r12,r6[0x0]
80003878:	ea 07 00 0b 	add	r11,r5,r7
8000387c:	f0 1f 00 1f 	mcall	800038f8 <phy_init+0xa4>
80003880:	ee c7 ff 00 	sub	r7,r7,-256
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
	
	/*if enable send/receive payload(media), defined in physical.h*/	
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
	phy_fragment_t * xnl_ptr = NULL;
	for(int i= 0; i < MAX_XNL_STORE; i++ )
80003884:	e0 47 1e 00 	cp.w	r7,7680
80003888:	cf 71       	brne	80003876 <phy_init+0x22>
	{
		set_xnl_idle(&xnl_store[i]);
	}
		
    /*initialize the queue to send/receive xnl packet */	
    phy_xnl_frame_tx = xQueueCreate(TX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
8000388a:	30 4b       	mov	r11,4
8000388c:	31 4c       	mov	r12,20
8000388e:	f0 1f 00 18 	mcall	800038ec <phy_init+0x98>
80003892:	49 b8       	lddpc	r8,800038fc <phy_init+0xa8>
80003894:	91 0c       	st.w	r8[0x0],r12
    phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
80003896:	30 4b       	mov	r11,4
80003898:	30 ac       	mov	r12,10
8000389a:	f0 1f 00 15 	mcall	800038ec <phy_init+0x98>
8000389e:	49 98       	lddpc	r8,80003900 <phy_init+0xac>
800038a0:	91 0c       	st.w	r8[0x0],r12
	
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
800038a2:	30 4b       	mov	r11,4
800038a4:	30 ac       	mov	r12,10
800038a6:	f0 1f 00 12 	mcall	800038ec <phy_init+0x98>
800038aa:	49 78       	lddpc	r8,80003904 <phy_init+0xb0>
800038ac:	91 0c       	st.w	r8[0x0],r12
800038ae:	30 07       	mov	r7,0
	U8 * payload_ptr = NULL;
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
	{
		set_payload_idle(payload_store[i]);
800038b0:	10 96       	mov	r6,r8
800038b2:	49 65       	lddpc	r5,80003908 <phy_init+0xb4>
800038b4:	6c 0c       	ld.w	r12,r6[0x0]
800038b6:	ea 07 00 0b 	add	r11,r5,r7
800038ba:	f0 1f 00 10 	mcall	800038f8 <phy_init+0xa4>
800038be:	ee c7 fe 00 	sub	r7,r7,-512
    phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
	
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
	U8 * payload_ptr = NULL;
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
800038c2:	e0 47 14 00 	cp.w	r7,5120
800038c6:	cf 71       	brne	800038b4 <phy_init+0x60>
		set_payload_idle(payload_store[i]);
	}
		
	/*initialize the queue to send/receive xnl packet */
	phy_payload_frame_tx =
	xQueueCreate(TX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t));
800038c8:	e0 6b 01 00 	mov	r11,256
800038cc:	30 5c       	mov	r12,5
800038ce:	f0 1f 00 08 	mcall	800038ec <phy_init+0x98>
	{
		set_payload_idle(payload_store[i]);
	}
		
	/*initialize the queue to send/receive xnl packet */
	phy_payload_frame_tx =
800038d2:	48 f8       	lddpc	r8,8000390c <phy_init+0xb8>
800038d4:	91 0c       	st.w	r8[0x0],r12
		
	//phy_payload_frame_rx =
	//xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
	#endif /*end if*/
	
}
800038d6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800038da:	00 00       	add	r0,r0
800038dc:	80 00       	ld.sh	r0,r0[0x0]
800038de:	44 a8       	lddsp	r8,sp[0x128]
800038e0:	80 00       	ld.sh	r0,r0[0x0]
800038e2:	32 70       	mov	r0,39
800038e4:	80 00       	ld.sh	r0,r0[0x0]
800038e6:	39 70       	mov	r0,-105
800038e8:	80 00       	ld.sh	r0,r0[0x0]
800038ea:	44 94       	lddsp	r4,sp[0x124]
800038ec:	80 00       	ld.sh	r0,r0[0x0]
800038ee:	5d 3c       	musfr	r12
800038f0:	00 00       	add	r0,r0
800038f2:	0a 9c       	mov	r12,r5
800038f4:	00 00       	add	r0,r0
800038f6:	34 88       	mov	r8,72
800038f8:	80 00       	ld.sh	r0,r0[0x0]
800038fa:	31 cc       	mov	r12,28
800038fc:	00 00       	add	r0,r0
800038fe:	0a cc       	st.b	r5++,r12
80003900:	00 00       	add	r0,r0
80003902:	0a b8       	st.h	r5++,r8
80003904:	00 00       	add	r0,r0
80003906:	0a 8c       	andn	r12,r5
80003908:	00 00       	add	r0,r0
8000390a:	20 88       	sub	r8,8
8000390c:	00 00       	add	r0,r0
8000390e:	0a b0       	st.h	r5++,r0

80003910 <payload_rx>:




static void payload_rx(void * payload)
{
80003910:	d4 01       	pushm	lr
80003912:	20 2d       	sub	sp,8
80003914:	50 0c       	stdsp	sp[0x0],r12
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80003916:	30 08       	mov	r8,0
80003918:	50 18       	stdsp	sp[0x4],r8
	
	//set_payload_idle(payload);
	if(NULL == phy_payload_frame_rx)
8000391a:	48 f8       	lddpc	r8,80003954 <payload_rx+0x44>
8000391c:	70 08       	ld.w	r8,r8[0x0]
8000391e:	58 08       	cp.w	r8,0
80003920:	c0 71       	brne	8000392e <payload_rx+0x1e>
	{
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));		
80003922:	30 4b       	mov	r11,4
80003924:	30 5c       	mov	r12,5
80003926:	f0 1f 00 0d 	mcall	80003958 <payload_rx+0x48>
8000392a:	48 b8       	lddpc	r8,80003954 <payload_rx+0x44>
8000392c:	91 0c       	st.w	r8[0x0],r12
	}

	if(errQUEUE_FULL == xQueueSendFromISR(phy_payload_frame_rx, &payload, &xHigherPriorityTaskWoken))
8000392e:	48 a8       	lddpc	r8,80003954 <payload_rx+0x44>
80003930:	70 0c       	ld.w	r12,r8[0x0]
80003932:	30 09       	mov	r9,0
80003934:	fa ca ff fc 	sub	r10,sp,-4
80003938:	1a 9b       	mov	r11,sp
8000393a:	f0 1f 00 09 	mcall	8000395c <payload_rx+0x4c>
8000393e:	c0 91       	brne	80003950 <payload_rx+0x40>
	//if(errQUEUE_FULL == xQueueSend(phy_payload_frame_rx, &payload, 0))
	{	//To payload_rx_process();	
		
		set_payload_idle_isr(payload);
80003940:	48 88       	lddpc	r8,80003960 <payload_rx+0x50>
80003942:	70 0c       	ld.w	r12,r8[0x0]
80003944:	40 0b       	lddsp	r11,sp[0x0]
80003946:	f0 1f 00 08 	mcall	80003964 <payload_rx+0x54>
		logFromISR("mm");
8000394a:	48 8c       	lddpc	r12,80003968 <payload_rx+0x58>
8000394c:	f0 1f 00 08 	mcall	8000396c <payload_rx+0x5c>
			
		}
		//set_payload_idle_isr(payload);
		//logFromISR("ss");
	}
}
80003950:	2f ed       	sub	sp,-8
80003952:	d8 02       	popm	pc
80003954:	00 00       	add	r0,r0
80003956:	0a 7c       	tst	r12,r5
80003958:	80 00       	ld.sh	r0,r0[0x0]
8000395a:	5d 3c       	musfr	r12
8000395c:	80 00       	ld.sh	r0,r0[0x0]
8000395e:	5b ec       	cp.w	r12,-2
80003960:	00 00       	add	r0,r0
80003962:	0a 8c       	andn	r12,r5
80003964:	80 00       	ld.sh	r0,r0[0x0]
80003966:	31 78       	mov	r8,23
80003968:	80 01       	ld.sh	r1,r0[0x0]
8000396a:	57 10       	stdsp	sp[0x1c4],r0
8000396c:	80 00       	ld.sh	r0,r0[0x0]
8000396e:	69 60       	ld.w	r0,r4[0x58]

80003970 <phy_rx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_rx_func( void * ssc)
{    
80003970:	eb cd 40 e0 	pushm	r5-r7,lr
80003974:	18 97       	mov	r7,r12
		
	if(NULL != phy_xnl_frame_rx)
80003976:	fe f8 09 7e 	ld.w	r8,pc[2430]
8000397a:	70 08       	ld.w	r8,r8[0x0]
8000397c:	58 08       	cp.w	r8,0
8000397e:	e0 80 01 05 	breq	80003b88 <phy_rx_func+0x218>
	static U16 phy_check_sum = 0;

	static phy_rx_state_t  phy_rx_state = WAITING_FOR_HEADER;
	static U32 phy_rx_count = 0;

	U32 phy_dword = xnl_rx_channel->dword;	
80003982:	78 16       	ld.w	r6,r12[0x4]

	phy_rx_count++;
80003984:	fe f8 09 74 	ld.w	r8,pc[2420]
80003988:	70 09       	ld.w	r9,r8[0x0]
8000398a:	2f f9       	sub	r9,-1
8000398c:	91 09       	st.w	r8[0x0],r9
	
	/*This is the code for parsing the incoming physical message.*/
	switch (phy_rx_state)
8000398e:	fe f8 09 6e 	ld.w	r8,pc[2414]
80003992:	70 08       	ld.w	r8,r8[0x0]
80003994:	58 18       	cp.w	r8,1
80003996:	e0 80 00 84 	breq	80003a9e <phy_rx_func+0x12e>
8000399a:	c0 73       	brcs	800039a8 <phy_rx_func+0x38>
8000399c:	58 28       	cp.w	r8,2
8000399e:	c5 b0       	breq	80003a54 <phy_rx_func+0xe4>
800039a0:	58 38       	cp.w	r8,3
800039a2:	e0 81 00 f3 	brne	80003b88 <phy_rx_func+0x218>
800039a6:	cd 38       	rjmp	80003b4c <phy_rx_func+0x1dc>

        /*Waiting for something. Most frequent visit.*/		
		case WAITING_FOR_HEADER:
		
			/*Ignore Idles.*/
			if (0xABCD5A5A == phy_dword)
800039a8:	e0 6a 5a 5a 	mov	r10,23130
800039ac:	ea 1a ab cd 	orh	r10,0xabcd
800039b0:	14 36       	cp.w	r6,r10
800039b2:	e0 80 00 eb 	breq	80003b88 <phy_rx_func+0x218>
			{
				break;
			}	

			/*Skip until Header.*/		
			if (0xABCD != (phy_dword >> 16))
800039b6:	ec 08 16 10 	lsr	r8,r6,0x10
800039ba:	e0 48 ab cd 	cp.w	r8,43981
800039be:	e0 81 00 e5 	brne	80003b88 <phy_rx_func+0x218>
			{			
				break;
			}
		
			/*Length excluding CSUM.*/
			phy_rx_expexted_length = (phy_dword & 0x000000FF) - 2;
800039c2:	eb d6 b0 10 	bfexts	r5,r6,0x0,0x10
800039c6:	f1 d5 c0 08 	bfextu	r8,r5,0x0,0x8
800039ca:	20 28       	sub	r8,2
800039cc:	fe f9 09 34 	ld.w	r9,pc[2356]
800039d0:	b2 08       	st.h	r9[0x0],r8
			
			/*Discard degenerate message.*/
			if (phy_rx_expexted_length <= 0)
800039d2:	30 09       	mov	r9,0
800039d4:	f2 08 19 00 	cp.h	r8,r9
800039d8:	e0 8a 00 d8 	brle	80003b88 <phy_rx_func+0x218>
			{
				break;
			}
		
			phy_rx_length = 0;
800039dc:	fe f8 09 28 	ld.w	r8,pc[2344]
800039e0:	b0 09       	st.h	r8[0x0],r9
			
			//get_xnl_idle_isr(&phy_frame_ptr, &xHigherPriorityTaskWoken);
			phy_frame_ptr = get_xnl_idle_isr();
800039e2:	fe f8 09 26 	ld.w	r8,pc[2342]
800039e6:	70 0c       	ld.w	r12,r8[0x0]
800039e8:	f0 1f 02 49 	mcall	8000430c <phy_rx_func+0x99c>
800039ec:	fe f8 09 24 	ld.w	r8,pc[2340]
800039f0:	91 0c       	st.w	r8[0x0],r12
			if(NULL == phy_frame_ptr)
800039f2:	58 0c       	cp.w	r12,0
800039f4:	e0 80 00 ca 	breq	80003b88 <phy_rx_func+0x218>
			//
			//xQueueReceiveFromISR(phy_store_idle, &phy_frame_ptr, &xHigherPriorityTaskWoken);
			
			//phy_frame_ptr = pvPortMalloc(sizeof(phy_fragment_t));
					
			phy_frame_ptr->fragment_element[phy_rx_length++] = phy_dword;
800039f8:	fe f8 09 0c 	ld.w	r8,pc[2316]
800039fc:	90 09       	ld.sh	r9,r8[0x0]
800039fe:	f8 09 0a 15 	st.h	r12[r9<<0x1],r5
80003a02:	2f f9       	sub	r9,-1
80003a04:	5c 89       	casts.h	r9
			
			/*time stamp*/
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
80003a06:	fe fa 09 0a 	ld.w	r10,pc[2314]
80003a0a:	74 0a       	ld.w	r10,r10[0x0]
80003a0c:	fe fb 08 ec 	ld.w	r11,pc[2284]
80003a10:	76 0b       	ld.w	r11,r11[0x0]
80003a12:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
80003a16:	2f f9       	sub	r9,-1
80003a18:	b0 09       	st.h	r8[0x0],r9
													(phy_rx_count) & 0x0000FFFF;
			
			/*This switch tests the fragment type, and adjusts receiver state
			accordingly.*/
			/*Check frag type*/
			switch (phy_dword & 0x00000F00)
80003a1a:	e2 16 0f 00 	andl	r6,0xf00,COH
80003a1e:	e0 46 01 00 	cp.w	r6,256
80003a22:	c0 c0       	breq	80003a3a <phy_rx_func+0xca>
80003a24:	e0 8b 00 05 	brhi	80003a2e <phy_rx_func+0xbe>
80003a28:	58 06       	cp.w	r6,0
80003a2a:	c0 80       	breq	80003a3a <phy_rx_func+0xca>
80003a2c:	c0 c8       	rjmp	80003a44 <phy_rx_func+0xd4>
80003a2e:	e0 46 02 00 	cp.w	r6,512
80003a32:	c0 40       	breq	80003a3a <phy_rx_func+0xca>
80003a34:	e0 46 03 00 	cp.w	r6,768
80003a38:	c0 61       	brne	80003a44 <phy_rx_func+0xd4>
			{
				case SINGLE_FRAGMENT:  //Only Fragment.
				case FIRST_FRAGMENT:   //First of Multi-fragment.
				case MIDDLE_FRAGMENT:  //Continuing Multi-fragment.
				case LAST_FRAGMENT:    //Last Multi-fragment.
					phy_rx_state = WAITING_CHECK_SUM;
80003a3a:	30 29       	mov	r9,2
80003a3c:	fe f8 08 c0 	ld.w	r8,pc[2240]
80003a40:	91 09       	st.w	r8[0x0],r9
80003a42:	ca 38       	rjmp	80003b88 <phy_rx_func+0x218>
				break;
				default:
					vPortFree(phy_frame_ptr);
80003a44:	fe f6 08 cc 	ld.w	r6,pc[2252]
80003a48:	6c 0c       	ld.w	r12,r6[0x0]
80003a4a:	f0 1f 02 33 	mcall	80004314 <phy_rx_func+0x9a4>
					phy_frame_ptr = NULL;					
80003a4e:	30 08       	mov	r8,0
80003a50:	8d 08       	st.w	r6[0x0],r8
80003a52:	c9 b8       	rjmp	80003b88 <phy_rx_func+0x218>
		
			/*Stores CSUM*/
			phy_check_sum  = (phy_dword & 0xFFFF0000) >> 16;
			
			/*sums in first hWord*/
			phy_check_sum += (phy_dword & 0x0000FFFF);		
80003a54:	f5 d6 b0 10 	bfexts	r10,r6,0x0,0x10
80003a58:	b1 86       	lsr	r6,0x10
80003a5a:	14 06       	add	r6,r10
80003a5c:	fe f8 08 bc 	ld.w	r8,pc[2236]
80003a60:	b0 06       	st.h	r8[0x0],r6
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
80003a62:	fe f8 08 a2 	ld.w	r8,pc[2210]
80003a66:	90 09       	ld.sh	r9,r8[0x0]
80003a68:	fe fb 08 a8 	ld.w	r11,pc[2216]
80003a6c:	76 0b       	ld.w	r11,r11[0x0]
80003a6e:	f6 09 0a 1a 	st.h	r11[r9<<0x1],r10
80003a72:	2f f9       	sub	r9,-1
80003a74:	b0 09       	st.h	r8[0x0],r9
														 phy_dword & 0x0000FFFF;
					
			phy_rx_expexted_length -= 2;
80003a76:	fe f9 08 8a 	ld.w	r9,pc[2186]
80003a7a:	92 08       	ld.sh	r8,r9[0x0]
80003a7c:	20 28       	sub	r8,2
80003a7e:	b2 08       	st.h	r9[0x0],r8
			
			/*Normal case for greater than one byte payloads.*/
			if (phy_rx_expexted_length > 0)
80003a80:	30 09       	mov	r9,0
80003a82:	f2 08 19 00 	cp.h	r8,r9
80003a86:	e0 8a 00 07 	brle	80003a94 <phy_rx_func+0x124>
			{					  
				phy_rx_state = READING_FRAGMENT;
80003a8a:	30 19       	mov	r9,1
80003a8c:	fe f8 08 70 	ld.w	r8,pc[2160]
80003a90:	91 09       	st.w	r8[0x0],r9
80003a92:	c7 b8       	rjmp	80003b88 <phy_rx_func+0x218>
	    		Note that all segments must align with a 32-bit boundary and
				beginning of each XCMP/XNL payload frame must start on slot 3
				Thus, segments of odd length must append a 0x0000 at the end
				(slot 4) to ensure alignment. [9.1.3]
				*/
				phy_rx_state = WAITING_LAST_TERM;
80003a94:	30 39       	mov	r9,3
80003a96:	fe f8 08 66 	ld.w	r8,pc[2150]
80003a9a:	91 09       	st.w	r8[0x0],r9
80003a9c:	c7 68       	rjmp	80003b88 <phy_rx_func+0x218>
			}			
		
			break;

		case READING_FRAGMENT:
			phy_check_sum += (phy_dword & 0xFFFF0000) >> 16;
80003a9e:	ec 0a 14 10 	asr	r10,r6,0x10
80003aa2:	fe f8 08 76 	ld.w	r8,pc[2166]
80003aa6:	90 09       	ld.sh	r9,r8[0x0]
80003aa8:	14 09       	add	r9,r10
80003aaa:	b0 09       	st.h	r8[0x0],r9
	
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
80003aac:	fe f9 08 58 	ld.w	r9,pc[2136]
80003ab0:	92 08       	ld.sh	r8,r9[0x0]
80003ab2:	fe fb 08 5e 	ld.w	r11,pc[2142]
80003ab6:	76 0b       	ld.w	r11,r11[0x0]
80003ab8:	f6 08 0a 1a 	st.h	r11[r8<<0x1],r10
80003abc:	2f f8       	sub	r8,-1
80003abe:	5c 88       	casts.h	r8
80003ac0:	b2 08       	st.h	r9[0x0],r8
												 (phy_dword & 0xFFFF0000) >> 16;
	
			phy_rx_expexted_length -= 2;
80003ac2:	fe fa 08 3e 	ld.w	r10,pc[2110]
80003ac6:	94 09       	ld.sh	r9,r10[0x0]
80003ac8:	20 29       	sub	r9,2
80003aca:	b4 09       	st.h	r10[0x0],r9
			if (phy_rx_expexted_length <= 0)
80003acc:	30 0a       	mov	r10,0
80003ace:	f4 09 19 00 	cp.h	r9,r10
80003ad2:	e0 89 00 1f 	brgt	80003b10 <phy_rx_func+0x1a0>
				Terminator should be in 2nd hWord.
				Shaoqun says useful bits not used. The packet will always end
				with $00BA. [9.1.2.8]	
				*/
				
				if ((0x000000BA == (phy_dword  & 0x0000FFFF)) 
80003ad6:	ed d6 c0 10 	bfextu	r6,r6,0x0,0x10
80003ada:	e0 46 00 ba 	cp.w	r6,186
80003ade:	c0 d1       	brne	80003af8 <phy_rx_func+0x188>
80003ae0:	fe f8 08 38 	ld.w	r8,pc[2104]
80003ae4:	90 09       	ld.sh	r9,r8[0x0]
80003ae6:	f4 09 19 00 	cp.h	r9,r10
80003aea:	c0 71       	brne	80003af8 <phy_rx_func+0x188>
					&& (phy_check_sum == 0))
				{
					phy_rx(phy_frame_ptr);
80003aec:	fe f8 08 24 	ld.w	r8,pc[2084]
80003af0:	70 0c       	ld.w	r12,r8[0x0]
80003af2:	f0 1f 02 0b 	mcall	8000431c <phy_rx_func+0x9ac>
80003af6:	c0 88       	rjmp	80003b06 <phy_rx_func+0x196>
				}
				else
				{
					vPortFree(phy_frame_ptr);
80003af8:	fe f6 08 18 	ld.w	r6,pc[2072]
80003afc:	6c 0c       	ld.w	r12,r6[0x0]
80003afe:	f0 1f 02 06 	mcall	80004314 <phy_rx_func+0x9a4>
					phy_frame_ptr = NULL;
80003b02:	30 08       	mov	r8,0
80003b04:	8d 08       	st.w	r6[0x0],r8
				}

				phy_rx_state = WAITING_FOR_HEADER;
80003b06:	30 09       	mov	r9,0
80003b08:	fe f8 07 f4 	ld.w	r8,pc[2036]
80003b0c:	91 09       	st.w	r8[0x0],r9
80003b0e:	c3 d8       	rjmp	80003b88 <phy_rx_func+0x218>
				break;
			}
		
			/*Have not broken. 2nd hWord contains payload.*/
			phy_check_sum += (phy_dword & 0x0000FFFF);
80003b10:	5c 86       	casts.h	r6
80003b12:	fe f9 08 06 	ld.w	r9,pc[2054]
80003b16:	92 0a       	ld.sh	r10,r9[0x0]
80003b18:	0c 0a       	add	r10,r6
80003b1a:	b2 0a       	st.h	r9[0x0],r10
		
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
80003b1c:	fe f9 07 f4 	ld.w	r9,pc[2036]
80003b20:	72 09       	ld.w	r9,r9[0x0]
80003b22:	f2 08 0a 16 	st.h	r9[r8<<0x1],r6
80003b26:	2f f8       	sub	r8,-1
80003b28:	fe f9 07 dc 	ld.w	r9,pc[2012]
80003b2c:	b2 08       	st.h	r9[0x0],r8
													   (phy_dword & 0x0000FFFF);
		
			phy_rx_expexted_length -= 2;
80003b2e:	fe f9 07 d2 	ld.w	r9,pc[2002]
80003b32:	92 08       	ld.sh	r8,r9[0x0]
80003b34:	20 28       	sub	r8,2
80003b36:	b2 08       	st.h	r9[0x0],r8
			if (phy_rx_expexted_length <= 0)
80003b38:	30 09       	mov	r9,0
80003b3a:	f2 08 19 00 	cp.h	r8,r9
80003b3e:	e0 89 00 25 	brgt	80003b88 <phy_rx_func+0x218>
			{
				/*All read in. Next Word should be 0x00BA0000.*/
				phy_rx_state = WAITING_LAST_TERM;
80003b42:	30 39       	mov	r9,3
80003b44:	fe f8 07 b8 	ld.w	r8,pc[1976]
80003b48:	91 09       	st.w	r8[0x0],r9
80003b4a:	c1 f8       	rjmp	80003b88 <phy_rx_func+0x218>
			}/*else, next Word contains more payload.*/
			break;

		/*Expecting last terminator 0x00BA0000.*/	
		case WAITING_LAST_TERM:			
			if ((0x00BA0000 == (phy_dword  & 0x00FF0000)) /*Expected found.*/
80003b4c:	e6 16 00 ff 	andh	r6,0xff,COH
80003b50:	fc 19 00 ba 	movh	r9,0xba
80003b54:	12 36       	cp.w	r6,r9
80003b56:	c0 e1       	brne	80003b72 <phy_rx_func+0x202>
80003b58:	fe f8 07 c0 	ld.w	r8,pc[1984]
80003b5c:	90 09       	ld.sh	r9,r8[0x0]
80003b5e:	30 08       	mov	r8,0
80003b60:	f0 09 19 00 	cp.h	r9,r8
80003b64:	c0 71       	brne	80003b72 <phy_rx_func+0x202>
				&& (phy_check_sum == 0))/*Good checksum*/
			{
				phy_rx(phy_frame_ptr);
80003b66:	fe f8 07 aa 	ld.w	r8,pc[1962]
80003b6a:	70 0c       	ld.w	r12,r8[0x0]
80003b6c:	f0 1f 01 ec 	mcall	8000431c <phy_rx_func+0x9ac>
80003b70:	c0 88       	rjmp	80003b80 <phy_rx_func+0x210>

			}
			else
			{
				vPortFree(phy_frame_ptr);
80003b72:	fe f6 07 9e 	ld.w	r6,pc[1950]
80003b76:	6c 0c       	ld.w	r12,r6[0x0]
80003b78:	f0 1f 01 e7 	mcall	80004314 <phy_rx_func+0x9a4>
				phy_frame_ptr = NULL;
80003b7c:	30 08       	mov	r8,0
80003b7e:	8d 08       	st.w	r6[0x0],r8
			}
				
			phy_rx_state = WAITING_FOR_HEADER;
80003b80:	30 09       	mov	r9,0
80003b82:	fe f8 07 7a 	ld.w	r8,pc[1914]
80003b86:	91 09       	st.w	r8[0x0],r9
	
	static U8 _flag = 1;//0xABCDC014时，_flag为0；
						//0xABCDC010时，_flag为1；
	
	
	if(is_first == FALSE)
80003b88:	fe f8 07 98 	ld.w	r8,pc[1944]
80003b8c:	11 89       	ld.ub	r9,r8[0x0]
80003b8e:	30 08       	mov	r8,0
80003b90:	f0 09 18 00 	cp.b	r9,r8
80003b94:	c0 d1       	brne	80003bae <phy_rx_func+0x23e>
	{
		payload_ptr = get_payload_idle_isr();
80003b96:	fe f8 07 8e 	ld.w	r8,pc[1934]
80003b9a:	70 0c       	ld.w	r12,r8[0x0]
80003b9c:	f0 1f 01 dc 	mcall	8000430c <phy_rx_func+0x99c>
80003ba0:	fe f8 07 88 	ld.w	r8,pc[1928]
80003ba4:	91 0c       	st.w	r8[0x0],r12
		is_first = TRUE;
80003ba6:	30 19       	mov	r9,1
80003ba8:	fe f8 07 78 	ld.w	r8,pc[1912]
80003bac:	b0 89       	st.b	r8[0x0],r9
	}	
	
	//This is the RxMedia Phy Handler.
	switch (RxMediaState)
80003bae:	fe f8 07 7e 	ld.w	r8,pc[1918]
80003bb2:	70 08       	ld.w	r8,r8[0x0]
80003bb4:	58 28       	cp.w	r8,2
80003bb6:	e0 80 01 58 	breq	80003e66 <phy_rx_func+0x4f6>
80003bba:	58 38       	cp.w	r8,3
80003bbc:	e0 80 02 16 	breq	80003fe8 <phy_rx_func+0x678>
80003bc0:	58 08       	cp.w	r8,0
80003bc2:	e0 81 03 96 	brne	800042ee <phy_rx_func+0x97e>
	{
		case WAITINGABAB:

			
			if (payload_rx_channel->dword[0] == 0xABCD5A5A)//Ignore Idles.
80003bc6:	6e 28       	ld.w	r8,r7[0x8]
80003bc8:	e0 6a 5a 5a 	mov	r10,23130
80003bcc:	ea 1a ab cd 	orh	r10,0xabcd
80003bd0:	14 38       	cp.w	r8,r10
80003bd2:	c0 71       	brne	80003be0 <phy_rx_func+0x270>
			{
				m_RxBurstType = VOICE_WATING;
80003bd4:	30 09       	mov	r9,0
80003bd6:	fe f8 07 5a 	ld.w	r8,pc[1882]
80003bda:	91 09       	st.w	r8[0x0],r9
80003bdc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
				//Upon receiving the idle frame, the m Rx Burst Type into an idle state in order to transmit the synchronization wait
				 break; 
			}
            
			if ((payload_rx_channel->dword[0]  & 0xFFFF0000) != 0xABCD0000)break; //Skip until Header. 
80003be0:	10 99       	mov	r9,r8
80003be2:	e0 19 00 00 	andl	r9,0x0
80003be6:	fc 1a ab cd 	movh	r10,0xabcd
80003bea:	14 39       	cp.w	r9,r10
80003bec:	e0 81 03 81 	brne	800042ee <phy_rx_func+0x97e>
			}
			//logFromISR("\n\r P: %X \n\r", payload_rx_channel->word[1]);//测试收到的数据
			
			#endif
			
			RxBytesWaiting = payload_rx_channel->dword[0] & 0x000000FF;
80003bf0:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
80003bf4:	fe f9 07 40 	ld.w	r9,pc[1856]
80003bf8:	93 08       	st.w	r9[0x0],r8
		
			if(NULL== payload_ptr)
80003bfa:	fe f8 07 2e 	ld.w	r8,pc[1838]
80003bfe:	70 08       	ld.w	r8,r8[0x0]
80003c00:	58 08       	cp.w	r8,0
80003c02:	c0 c1       	brne	80003c1a <phy_rx_func+0x2aa>
			{
				payload_ptr = get_payload_idle_isr();
80003c04:	fe f8 07 20 	ld.w	r8,pc[1824]
80003c08:	70 0c       	ld.w	r12,r8[0x0]
80003c0a:	f0 1f 01 c1 	mcall	8000430c <phy_rx_func+0x99c>
80003c0e:	fe f8 07 1a 	ld.w	r8,pc[1818]
80003c12:	91 0c       	st.w	r8[0x0],r12
				if(NULL== payload_ptr)
80003c14:	58 0c       	cp.w	r12,0
80003c16:	e0 80 03 6c 	breq	800042ee <phy_rx_func+0x97e>
				}
			}
		
			/****Note AMBE stream protocol frame structure and the PCM frame structure is different*****/
					
			if ((payload_rx_channel->dword[0] & 0x0000F000 ) == PAYLOAD_DATA_ENH )//PAYLOAD_DATA_ENH (0x0c))
80003c1a:	6e 28       	ld.w	r8,r7[0x8]
80003c1c:	e2 18 f0 00 	andl	r8,0xf000,COH
80003c20:	e0 48 c0 00 	cp.w	r8,49152
80003c24:	e0 81 00 8e 	brne	80003d40 <phy_rx_func+0x3d0>
			{
				AMBE_flag = 1;
80003c28:	30 19       	mov	r9,1
80003c2a:	fe f8 07 0e 	ld.w	r8,pc[1806]
80003c2e:	b0 89       	st.b	r8[0x0],r9
								
				Item_ID = payload_rx_channel->byte[5];
80003c30:	ef 39 00 0d 	ld.ub	r9,r7[13]
80003c34:	fe f8 07 08 	ld.w	r8,pc[1800]
80003c38:	b0 89       	st.b	r8[0x0],r9
				
				VF_SN = payload_rx_channel->byte[7];//This parameter is very important to the loopback Radio, as a reference.
80003c3a:	ef 3c 00 0f 	ld.ub	r12,r7[15]
80003c3e:	fe f9 07 02 	ld.w	r9,pc[1794]
80003c42:	b2 8c       	st.b	r9[0x0],r12
					
				//The OB know the Call begin and discard the Voice Header
				//The OB know the Call end and discard the Voice  Terminator			
				if (Item_ID == Raw_Tx_Data_HT)
80003c44:	11 89       	ld.ub	r9,r8[0x0]
80003c46:	3f 08       	mov	r8,-16
80003c48:	f0 09 18 00 	cp.b	r9,r8
80003c4c:	c2 b1       	brne	80003ca2 <phy_rx_func+0x332>
				{
					//HT_index = 0;
					//AMBE_HT[0] = payload_rx_channel->dword[0];
					//AMBE_HT[1] = payload_rx_channel->dword[1];
					//
					if ((payload_rx_channel->byte[6] & 0xF0 )== 0x10)//header
80003c4e:	ef 38 00 0e 	ld.ub	r8,r7[14]
80003c52:	e2 18 00 f0 	andl	r8,0xf0,COH
80003c56:	59 08       	cp.w	r8,16
80003c58:	c0 71       	brne	80003c66 <phy_rx_func+0x2f6>
					{
						m_RxBurstType = VOICEHEADER;		
80003c5a:	30 19       	mov	r9,1
80003c5c:	fe f8 06 d4 	ld.w	r8,pc[1748]
80003c60:	91 09       	st.w	r8[0x0],r9
80003c62:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

					}
					else if ((payload_rx_channel->byte[6] & 0xF0) == 0x20)//Terminator
80003c66:	e0 48 00 20 	cp.w	r8,32
80003c6a:	c1 61       	brne	80003c96 <phy_rx_func+0x326>
					{
						m_RxBurstType = VOICETERMINATOR;
80003c6c:	30 99       	mov	r9,9
80003c6e:	fe f8 06 c2 	ld.w	r8,pc[1730]
80003c72:	91 09       	st.w	r8[0x0],r9
						//In order to complete the save data AMBE stream to SDcard.
						//AMBE-data and PCM-data is not the same. AMBE is compressed data,
						//if there was a missing portion, a clear voice is difficult to extract the data. 
						//It must ensure that all the data received AMBE.
						RxMedia_IsFillingNext16 = 0;
80003c74:	30 09       	mov	r9,0
80003c76:	fe f8 06 ce 	ld.w	r8,pc[1742]
80003c7a:	91 09       	st.w	r8[0x0],r9
						payload_rx(payload_ptr);//注意！！！考虑是否需要把剩余的空间置0。
80003c7c:	fe f7 06 ac 	ld.w	r7,pc[1708]
80003c80:	6e 0c       	ld.w	r12,r7[0x0]
80003c82:	f0 1f 01 b2 	mcall	80004348 <phy_rx_func+0x9d8>
						payload_ptr = get_payload_idle_isr();
80003c86:	fe f8 06 9e 	ld.w	r8,pc[1694]
80003c8a:	70 0c       	ld.w	r12,r8[0x0]
80003c8c:	f0 1f 01 a0 	mcall	8000430c <phy_rx_func+0x99c>
80003c90:	8f 0c       	st.w	r7[0x0],r12
80003c92:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						//logFromISR("\n\r QQ1 \n\r");
						
					}
					else//error voice
					{
						m_RxBurstType = VOICE_WATING;
80003c96:	30 09       	mov	r9,0
80003c98:	fe f8 06 98 	ld.w	r8,pc[1688]
80003c9c:	91 09       	st.w	r8[0x0],r9
80003c9e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					
					break;//WAITINGABAB.
		
						
				}
				else if (Item_ID == Vocoder_Bit_Stream_Parameter)//Vocoder Bits Stream Parameter
80003ca2:	fe f8 06 9a 	ld.w	r8,pc[1690]
80003ca6:	11 89       	ld.ub	r9,r8[0x0]
80003ca8:	31 28       	mov	r8,18
80003caa:	f0 09 18 00 	cp.b	r9,r8
80003cae:	c0 d1       	brne	80003cc8 <phy_rx_func+0x358>
				{	
						
						VBSP_data[0] = payload_rx_channel->word[2];
80003cb0:	8e 69       	ld.sh	r9,r7[0xc]
80003cb2:	fe f8 06 9a 	ld.w	r8,pc[1690]
80003cb6:	b0 09       	st.h	r8[0x0],r9
						VBSP_data[1] = payload_rx_channel->word[3];
80003cb8:	8e 79       	ld.sh	r9,r7[0xe]
80003cba:	b0 19       	st.h	r8[0x2],r9
						m_RxBurstType = CalculateBurst(VF_SN);
80003cbc:	f0 1f 01 a5 	mcall	80004350 <phy_rx_func+0x9e0>
80003cc0:	fe f8 06 70 	ld.w	r8,pc[1648]
80003cc4:	91 0c       	st.w	r8[0x0],r12
80003cc6:	c3 78       	rjmp	80003d34 <phy_rx_func+0x3c4>

				}
				else if ((Item_ID == 0x04) || (Item_ID == 0x03) )//Unknown type data directly back hair
80003cc8:	fe f8 06 74 	ld.w	r8,pc[1652]
80003ccc:	11 89       	ld.ub	r9,r8[0x0]
80003cce:	30 48       	mov	r8,4
80003cd0:	f0 09 18 00 	cp.b	r9,r8
80003cd4:	c0 80       	breq	80003ce4 <phy_rx_func+0x374>
80003cd6:	fe f8 06 66 	ld.w	r8,pc[1638]
80003cda:	11 89       	ld.ub	r9,r8[0x0]
80003cdc:	30 38       	mov	r8,3
80003cde:	f0 09 18 00 	cp.b	r9,r8
80003ce2:	c1 c1       	brne	80003d1a <phy_rx_func+0x3aa>
				{
					//break;
					m_RxBurstType = UNSUREDATA;
80003ce4:	30 29       	mov	r9,2
80003ce6:	fe f8 06 4a 	ld.w	r8,pc[1610]
80003cea:	91 09       	st.w	r8[0x0],r9
					AMBE_HT[0] = payload_rx_channel->dword[0];
80003cec:	6e 29       	ld.w	r9,r7[0x8]
80003cee:	fe f8 06 66 	ld.w	r8,pc[1638]
80003cf2:	91 09       	st.w	r8[0x0],r9
					AMBE_HT[1] = payload_rx_channel->dword[1];
80003cf4:	6e 39       	ld.w	r9,r7[0xc]
80003cf6:	91 19       	st.w	r8[0x4],r9
					
					if (RxBytesWaiting == 0x00000014)
80003cf8:	fe f8 06 3c 	ld.w	r8,pc[1596]
80003cfc:	70 08       	ld.w	r8,r8[0x0]
80003cfe:	59 48       	cp.w	r8,20
80003d00:	c0 61       	brne	80003d0c <phy_rx_func+0x39c>
					{
						RxBytesWaiting = 0x18;//24 Reassigned
80003d02:	31 89       	mov	r9,24
80003d04:	fe f8 06 30 	ld.w	r8,pc[1584]
80003d08:	91 09       	st.w	r8[0x0],r9
80003d0a:	c1 58       	rjmp	80003d34 <phy_rx_func+0x3c4>
						//_flag =0;
							
					}
					if (RxBytesWaiting == 0x00000010)
80003d0c:	59 08       	cp.w	r8,16
80003d0e:	c1 31       	brne	80003d34 <phy_rx_func+0x3c4>
					{
						RxBytesWaiting = 0x10;//16 Reassigned
80003d10:	31 09       	mov	r9,16
80003d12:	fe f8 06 22 	ld.w	r8,pc[1570]
80003d16:	91 09       	st.w	r8[0x0],r9
80003d18:	c0 e8       	rjmp	80003d34 <phy_rx_func+0x3c4>
					
				}
				else
				{
					
					logFromISR("\n\r Item_ID:%x \n\r", payload_rx_channel->word[2]);
80003d1a:	8e e8       	ld.uh	r8,r7[0xc]
80003d1c:	1a d8       	st.w	--sp,r8
80003d1e:	fe fc 06 3a 	ld.w	r12,pc[1594]
80003d22:	f0 1f 01 8f 	mcall	8000435c <phy_rx_func+0x9ec>
					logFromISR("\n\r Axiba \n\r");
80003d26:	fe fc 06 3a 	ld.w	r12,pc[1594]
80003d2a:	f0 1f 01 8d 	mcall	8000435c <phy_rx_func+0x9ec>
80003d2e:	2f fd       	sub	sp,-4
80003d30:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					//Radio Internal Parameter(0x7F):
					//The OB should use the route back this item to radio without change content.
					break;
				}
				
				RxMediaState = READING_AMBE_MEDIA;//Jump
80003d34:	30 39       	mov	r9,3
80003d36:	fe f8 05 f6 	ld.w	r8,pc[1526]
80003d3a:	91 09       	st.w	r8[0x0],r9
80003d3c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
			else//PCM-media-data
			{	
				//logFromISR("\n\r RX:%x \n\r", payload_rx_channel->dword[0]);
				//SPEAKER_DATA or  //MIC_DATA
				if (((payload_rx_channel->dword[0] & 0x0000F000 ) != SPEAKER_DATA ) 
80003d40:	e0 48 10 00 	cp.w	r8,4096
80003d44:	5f 19       	srne	r9
80003d46:	e0 48 20 00 	cp.w	r8,8192
80003d4a:	5f 18       	srne	r8
80003d4c:	f3 e8 00 08 	and	r8,r9,r8
80003d50:	e0 81 02 cf 	brne	800042ee <phy_rx_func+0x97e>
					&& ((payload_rx_channel->dword[0] & 0x0000F000 ) != MIC_DATA ))break;
				
				AMBE_flag = 0;
80003d54:	fe f9 05 e4 	ld.w	r9,pc[1508]
80003d58:	b2 88       	st.b	r9[0x0],r8
				
				Item_ID = 0;//To make sure your save PCM data.
80003d5a:	fe f9 05 e2 	ld.w	r9,pc[1506]
80003d5e:	b2 88       	st.b	r9[0x0],r8
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003d60:	6e 28       	ld.w	r8,r7[0x8]
80003d62:	e2 18 0f 00 	andl	r8,0xf00,COH
80003d66:	58 18       	cp.w	r8,1
80003d68:	e0 8b 00 4d 	brhi	80003e02 <phy_rx_func+0x492>
				
				if ((payload_rx_channel->dword[0]  & 0x00000F00) <= 1){  //Frag type must process Array Discriptor.
				//The first word of the media access payload must be the Array descriptor length. And the
				//unit of the length is in word (16-bit). The length field itself does not count into the length.
				//When there is no array descriptor, the length must be set to zero.[9.1.4.1]
				if ((RxBytesWaiting -= 4) <= 0) break;          //Nothing beyond this Phy buffer. Keep looking for Header
80003d6c:	fe f9 05 c8 	ld.w	r9,pc[1480]
80003d70:	72 08       	ld.w	r8,r9[0x0]
80003d72:	20 48       	sub	r8,4
80003d74:	93 08       	st.w	r9[0x0],r8
80003d76:	e0 80 02 bc 	breq	800042ee <phy_rx_func+0x97e>
				ArrayDiscLength = payload_rx_channel->word[2];
80003d7a:	8e 68       	ld.sh	r8,r7[0xc]
80003d7c:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
80003d80:	fe f9 05 e4 	ld.w	r9,pc[1508]
80003d84:	93 0a       	st.w	r9[0x0],r10
				
				switch (ArrayDiscLength){
80003d86:	30 09       	mov	r9,0
80003d88:	f2 08 19 00 	cp.h	r8,r9
80003d8c:	c0 70       	breq	80003d9a <phy_rx_func+0x42a>
80003d8e:	30 19       	mov	r9,1
80003d90:	f2 08 19 00 	cp.h	r8,r9
80003d94:	e0 81 02 ad 	brne	800042ee <phy_rx_func+0x97e>
80003d98:	c2 68       	rjmp	80003de4 <phy_rx_func+0x474>
					case 0:          //The usual case. Remaining word in Phy buffer is Audio.
								
						payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
80003d9a:	fe f8 05 aa 	ld.w	r8,pc[1450]
80003d9e:	70 0a       	ld.w	r10,r8[0x0]
80003da0:	fe f9 05 88 	ld.w	r9,pc[1416]
80003da4:	72 09       	ld.w	r9,r9[0x0]
80003da6:	8e 7b       	ld.sh	r11,r7[0xe]
80003da8:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
						RxMedia_IsFillingNext16 += 1;
80003dac:	70 09       	ld.w	r9,r8[0x0]
80003dae:	2f f9       	sub	r9,-1
80003db0:	91 09       	st.w	r8[0x0],r9
						if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003db2:	e0 49 00 ff 	cp.w	r9,255
80003db6:	e0 88 00 11 	brls	80003dd8 <phy_rx_func+0x468>
						{
							RxMedia_IsFillingNext16 = 0;	
80003dba:	30 09       	mov	r9,0
80003dbc:	91 09       	st.w	r8[0x0],r9
							payload_rx(payload_ptr);	
80003dbe:	fe f7 05 6a 	ld.w	r7,pc[1386]
80003dc2:	6e 0c       	ld.w	r12,r7[0x0]
80003dc4:	f0 1f 01 61 	mcall	80004348 <phy_rx_func+0x9d8>
							payload_ptr = get_payload_idle_isr();
80003dc8:	fe f8 05 5c 	ld.w	r8,pc[1372]
80003dcc:	70 0c       	ld.w	r12,r8[0x0]
80003dce:	f0 1f 01 50 	mcall	8000430c <phy_rx_func+0x99c>
80003dd2:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == payload_ptr)
80003dd4:	e0 80 02 8d 	breq	800042ee <phy_rx_func+0x97e>
							{
								break;
							}				
						}
							RxMediaState = READINGMEDIA;
80003dd8:	30 29       	mov	r9,2
80003dda:	fe f8 05 52 	ld.w	r8,pc[1362]
80003dde:	91 09       	st.w	r8[0x0],r9
80003de0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003de4:	8e 79       	ld.sh	r9,r7[0xe]
80003de6:	30 38       	mov	r8,3
80003de8:	f0 09 19 00 	cp.h	r9,r8
80003dec:	c0 51       	brne	80003df6 <phy_rx_func+0x486>
				
					case 1: //The next usual case.
							//In general case, add code to process single word Array descriptor.
							if (payload_rx_channel->word[3] == 0x0003)//Stream Terminator
							{
								Terminator_Flag = 1;
80003dee:	30 19       	mov	r9,1
80003df0:	fe f8 05 78 	ld.w	r8,pc[1400]
80003df4:	b0 89       	st.b	r8[0x0],r9
							{
								//Terminator_Flag = 0;
							}
					
					
							RxMediaState = READINGMEDIA;
80003df6:	30 29       	mov	r9,2
80003df8:	fe f8 05 34 	ld.w	r8,pc[1332]
80003dfc:	91 09       	st.w	r8[0x0],r9
80003dfe:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
				break;
				}
		
				//Code gets here on Middle or last Fragment. No Array descriptor.
				if (RxBytesWaiting < 2) break;//This shouldn't happen, but must check.
80003e02:	fe f8 05 32 	ld.w	r8,pc[1330]
80003e06:	70 08       	ld.w	r8,r8[0x0]
80003e08:	58 18       	cp.w	r8,1
80003e0a:	e0 88 02 72 	brls	800042ee <phy_rx_func+0x97e>
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->dword[1] & 0x0000FFFF;
80003e0e:	fe f8 05 36 	ld.w	r8,pc[1334]
80003e12:	70 0a       	ld.w	r10,r8[0x0]
80003e14:	fe f9 05 14 	ld.w	r9,pc[1300]
80003e18:	72 09       	ld.w	r9,r9[0x0]
80003e1a:	6e 3b       	ld.w	r11,r7[0xc]
80003e1c:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80003e20:	70 09       	ld.w	r9,r8[0x0]
80003e22:	2f f9       	sub	r9,-1
80003e24:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003e26:	e0 49 00 ff 	cp.w	r9,255
80003e2a:	e0 88 00 11 	brls	80003e4c <phy_rx_func+0x4dc>
				{
					RxMedia_IsFillingNext16 = 0;
80003e2e:	30 09       	mov	r9,0
80003e30:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);
80003e32:	fe f7 04 f6 	ld.w	r7,pc[1270]
80003e36:	6e 0c       	ld.w	r12,r7[0x0]
80003e38:	f0 1f 01 44 	mcall	80004348 <phy_rx_func+0x9d8>
								payload_ptr = get_payload_idle_isr();
80003e3c:	fe f8 04 e8 	ld.w	r8,pc[1256]
80003e40:	70 0c       	ld.w	r12,r8[0x0]
80003e42:	f0 1f 01 33 	mcall	8000430c <phy_rx_func+0x99c>
80003e46:	8f 0c       	st.w	r7[0x0],r12
													if(NULL == payload_ptr)
80003e48:	e0 80 02 53 	breq	800042ee <phy_rx_func+0x97e>
													{
														break;
													}
				}
				if ((RxBytesWaiting -= 2) <= 0) break;  //This shouldn't happen, but must check;
80003e4c:	fe f9 04 e8 	ld.w	r9,pc[1256]
80003e50:	72 08       	ld.w	r8,r9[0x0]
80003e52:	20 28       	sub	r8,2
80003e54:	93 08       	st.w	r9[0x0],r8
80003e56:	e0 80 02 4c 	breq	800042ee <phy_rx_func+0x97e>
				RxMediaState = READINGMEDIA;
80003e5a:	30 29       	mov	r9,2
80003e5c:	fe f8 04 d0 	ld.w	r8,pc[1232]
80003e60:	91 09       	st.w	r8[0x0],r9
80003e62:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
		case READINGMEDIA:
				
			/***PCM-media-data ****/
			{
				
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[0];
80003e66:	fe f8 04 de 	ld.w	r8,pc[1246]
80003e6a:	70 0a       	ld.w	r10,r8[0x0]
80003e6c:	fe f9 04 bc 	ld.w	r9,pc[1212]
80003e70:	72 09       	ld.w	r9,r9[0x0]
80003e72:	8e 4b       	ld.sh	r11,r7[0x8]
80003e74:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;	
80003e78:	70 09       	ld.w	r9,r8[0x0]
80003e7a:	2f f9       	sub	r9,-1
80003e7c:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003e7e:	e0 49 00 ff 	cp.w	r9,255
80003e82:	e0 88 00 16 	brls	80003eae <phy_rx_func+0x53e>
					{
							RxMedia_IsFillingNext16 = 0;
80003e86:	30 09       	mov	r9,0
80003e88:	91 09       	st.w	r8[0x0],r9
							payload_rx(payload_ptr);
80003e8a:	fe f6 04 9e 	ld.w	r6,pc[1182]
80003e8e:	6c 0c       	ld.w	r12,r6[0x0]
80003e90:	f0 1f 01 2e 	mcall	80004348 <phy_rx_func+0x9d8>
							payload_ptr = get_payload_idle_isr();
80003e94:	fe f8 04 90 	ld.w	r8,pc[1168]
80003e98:	70 0c       	ld.w	r12,r8[0x0]
80003e9a:	f0 1f 01 1d 	mcall	8000430c <phy_rx_func+0x99c>
80003e9e:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == payload_ptr)
80003ea0:	c0 71       	brne	80003eae <phy_rx_func+0x53e>
							{
								RxMediaState = WAITINGABAB;
80003ea2:	30 09       	mov	r9,0
80003ea4:	fe f8 04 88 	ld.w	r8,pc[1160]
80003ea8:	91 09       	st.w	r8[0x0],r9
80003eaa:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
					}
				if ((RxBytesWaiting -= 2) <= 0)
80003eae:	fe f9 04 86 	ld.w	r9,pc[1158]
80003eb2:	72 08       	ld.w	r8,r9[0x0]
80003eb4:	20 28       	sub	r8,2
80003eb6:	93 08       	st.w	r9[0x0],r8
80003eb8:	c0 71       	brne	80003ec6 <phy_rx_func+0x556>
				{
					RxMediaState = WAITINGABAB;
80003eba:	30 09       	mov	r9,0
80003ebc:	fe f8 04 70 	ld.w	r8,pc[1136]
80003ec0:	91 09       	st.w	r8[0x0],r9
80003ec2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[1];
80003ec6:	fe f8 04 7e 	ld.w	r8,pc[1150]
80003eca:	70 0a       	ld.w	r10,r8[0x0]
80003ecc:	fe f9 04 5c 	ld.w	r9,pc[1116]
80003ed0:	72 09       	ld.w	r9,r9[0x0]
80003ed2:	8e 5b       	ld.sh	r11,r7[0xa]
80003ed4:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80003ed8:	70 09       	ld.w	r9,r8[0x0]
80003eda:	2f f9       	sub	r9,-1
80003edc:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003ede:	e0 49 00 ff 	cp.w	r9,255
80003ee2:	e0 88 00 16 	brls	80003f0e <phy_rx_func+0x59e>
						{
							RxMedia_IsFillingNext16 = 0;
80003ee6:	30 09       	mov	r9,0
80003ee8:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);
80003eea:	fe f6 04 3e 	ld.w	r6,pc[1086]
80003eee:	6c 0c       	ld.w	r12,r6[0x0]
80003ef0:	f0 1f 01 16 	mcall	80004348 <phy_rx_func+0x9d8>
								payload_ptr = get_payload_idle_isr();
80003ef4:	fe f8 04 30 	ld.w	r8,pc[1072]
80003ef8:	70 0c       	ld.w	r12,r8[0x0]
80003efa:	f0 1f 01 05 	mcall	8000430c <phy_rx_func+0x99c>
80003efe:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == payload_ptr)
80003f00:	c0 71       	brne	80003f0e <phy_rx_func+0x59e>
								{
									RxMediaState = WAITINGABAB;
80003f02:	30 09       	mov	r9,0
80003f04:	fe f8 04 28 	ld.w	r8,pc[1064]
80003f08:	91 09       	st.w	r8[0x0],r9
80003f0a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
						}
				if ((RxBytesWaiting -= 2) <= 0){
80003f0e:	fe f9 04 26 	ld.w	r9,pc[1062]
80003f12:	72 08       	ld.w	r8,r9[0x0]
80003f14:	20 28       	sub	r8,2
80003f16:	93 08       	st.w	r9[0x0],r8
80003f18:	c0 71       	brne	80003f26 <phy_rx_func+0x5b6>
					RxMediaState = WAITINGABAB;
80003f1a:	30 09       	mov	r9,0
80003f1c:	fe f8 04 10 	ld.w	r8,pc[1040]
80003f20:	91 09       	st.w	r8[0x0],r9
80003f22:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}

				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[2];
80003f26:	fe f8 04 1e 	ld.w	r8,pc[1054]
80003f2a:	70 0a       	ld.w	r10,r8[0x0]
80003f2c:	fe f9 03 fc 	ld.w	r9,pc[1020]
80003f30:	72 09       	ld.w	r9,r9[0x0]
80003f32:	8e 6b       	ld.sh	r11,r7[0xc]
80003f34:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80003f38:	70 09       	ld.w	r9,r8[0x0]
80003f3a:	2f f9       	sub	r9,-1
80003f3c:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003f3e:	e0 49 00 ff 	cp.w	r9,255
80003f42:	e0 88 00 16 	brls	80003f6e <phy_rx_func+0x5fe>
						{
							RxMedia_IsFillingNext16 = 0;
80003f46:	30 09       	mov	r9,0
80003f48:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);
80003f4a:	fe f6 03 de 	ld.w	r6,pc[990]
80003f4e:	6c 0c       	ld.w	r12,r6[0x0]
80003f50:	f0 1f 00 fe 	mcall	80004348 <phy_rx_func+0x9d8>
									payload_ptr = get_payload_idle_isr();
80003f54:	fe f8 03 d0 	ld.w	r8,pc[976]
80003f58:	70 0c       	ld.w	r12,r8[0x0]
80003f5a:	f0 1f 00 ed 	mcall	8000430c <phy_rx_func+0x99c>
80003f5e:	8d 0c       	st.w	r6[0x0],r12
									if(NULL == payload_ptr)
80003f60:	c0 71       	brne	80003f6e <phy_rx_func+0x5fe>
									{
										RxMediaState = WAITINGABAB;
80003f62:	30 09       	mov	r9,0
80003f64:	fe f8 03 c8 	ld.w	r8,pc[968]
80003f68:	91 09       	st.w	r8[0x0],r9
80003f6a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
						}
				if ((RxBytesWaiting -= 2) <= 0){
80003f6e:	fe f9 03 c6 	ld.w	r9,pc[966]
80003f72:	72 08       	ld.w	r8,r9[0x0]
80003f74:	20 28       	sub	r8,2
80003f76:	93 08       	st.w	r9[0x0],r8
80003f78:	c0 71       	brne	80003f86 <phy_rx_func+0x616>
					RxMediaState = WAITINGABAB;
80003f7a:	30 09       	mov	r9,0
80003f7c:	fe f8 03 b0 	ld.w	r8,pc[944]
80003f80:	91 09       	st.w	r8[0x0],r9
80003f82:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
80003f86:	fe f8 03 be 	ld.w	r8,pc[958]
80003f8a:	70 0a       	ld.w	r10,r8[0x0]
80003f8c:	fe f9 03 9c 	ld.w	r9,pc[924]
80003f90:	72 09       	ld.w	r9,r9[0x0]
80003f92:	8e 7b       	ld.sh	r11,r7[0xe]
80003f94:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80003f98:	70 09       	ld.w	r9,r8[0x0]
80003f9a:	2f f9       	sub	r9,-1
80003f9c:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003f9e:	e0 49 00 ff 	cp.w	r9,255
80003fa2:	e0 88 00 16 	brls	80003fce <phy_rx_func+0x65e>
						{
							RxMedia_IsFillingNext16 = 0;
80003fa6:	30 09       	mov	r9,0
80003fa8:	91 09       	st.w	r8[0x0],r9
							payload_rx(payload_ptr);
80003faa:	fe f7 03 7e 	ld.w	r7,pc[894]
80003fae:	6e 0c       	ld.w	r12,r7[0x0]
80003fb0:	f0 1f 00 e6 	mcall	80004348 <phy_rx_func+0x9d8>
							payload_ptr = get_payload_idle_isr();
80003fb4:	fe f8 03 70 	ld.w	r8,pc[880]
80003fb8:	70 0c       	ld.w	r12,r8[0x0]
80003fba:	f0 1f 00 d5 	mcall	8000430c <phy_rx_func+0x99c>
80003fbe:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == payload_ptr)
80003fc0:	c0 71       	brne	80003fce <phy_rx_func+0x65e>
							{
								RxMediaState = WAITINGABAB;
80003fc2:	30 09       	mov	r9,0
80003fc4:	fe f8 03 68 	ld.w	r8,pc[872]
80003fc8:	91 09       	st.w	r8[0x0],r9
80003fca:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
				if ((RxBytesWaiting -= 2) <= 0){
80003fce:	fe f9 03 66 	ld.w	r9,pc[870]
80003fd2:	72 08       	ld.w	r8,r9[0x0]
80003fd4:	20 28       	sub	r8,2
80003fd6:	93 08       	st.w	r9[0x0],r8
80003fd8:	e0 81 01 8b 	brne	800042ee <phy_rx_func+0x97e>
					RxMediaState = WAITINGABAB;
80003fdc:	30 09       	mov	r9,0
80003fde:	fe f8 03 4e 	ld.w	r8,pc[846]
80003fe2:	91 09       	st.w	r8[0x0],r9
80003fe4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			}
			break; //End of READINGMEDIA.

		case READING_AMBE_MEDIA:
			
					if ((Item_ID == Vocoder_Bit_Stream_Parameter))//PAYLOAD_DATA_ENH (0x0c))
80003fe8:	fe f8 03 54 	ld.w	r8,pc[852]
80003fec:	11 89       	ld.ub	r9,r8[0x0]
80003fee:	31 28       	mov	r8,18
80003ff0:	f0 09 18 00 	cp.b	r9,r8
80003ff4:	e0 81 00 b0 	brne	80004154 <phy_rx_func+0x7e4>
					{
						Item_ID = payload_rx_channel->byte[1];
80003ff8:	ef 39 00 09 	ld.ub	r9,r7[9]
80003ffc:	fe f8 03 40 	ld.w	r8,pc[832]
80004000:	b0 89       	st.b	r8[0x0],r9
						if (Item_ID == Post_Voice_Encoder_Data)
80004002:	11 89       	ld.ub	r9,r8[0x0]
80004004:	3f 28       	mov	r8,-14
80004006:	f0 09 18 00 	cp.b	r9,r8
8000400a:	e0 81 00 a0 	brne	8000414a <phy_rx_func+0x7da>
						{
							
							RxBytesWaiting = ((payload_rx_channel->dword[0] & 0x7F000000) >>24);//Test calculations are correct; 8
8000400e:	6e 29       	ld.w	r9,r7[0x8]
80004010:	f3 d9 c3 07 	bfextu	r9,r9,0x18,0x7
80004014:	fe f8 03 20 	ld.w	r8,pc[800]
80004018:	91 09       	st.w	r8[0x0],r9
							
							//For looping back to Radio
							AMBEBurst_rawdata[0] = payload_rx_channel->word[1];
8000401a:	8e 59       	ld.sh	r9,r7[0xa]
8000401c:	fe f8 03 50 	ld.w	r8,pc[848]
80004020:	b0 09       	st.h	r8[0x0],r9
							AMBEBurst_rawdata[1] = payload_rx_channel->word[2];
80004022:	8e 69       	ld.sh	r9,r7[0xc]
80004024:	b0 19       	st.h	r8[0x2],r9
							AMBEBurst_rawdata[2] = payload_rx_channel->word[3];
80004026:	8e 79       	ld.sh	r9,r7[0xe]
80004028:	b0 29       	st.h	r8[0x4],r9
							
							//To be tested. Also locally stored RAW-AMBER-DATA
							payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[1];
8000402a:	fe f8 03 1a 	ld.w	r8,pc[794]
8000402e:	70 0a       	ld.w	r10,r8[0x0]
80004030:	fe f9 02 f8 	ld.w	r9,pc[760]
80004034:	72 09       	ld.w	r9,r9[0x0]
80004036:	8e 5b       	ld.sh	r11,r7[0xa]
80004038:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
							RxMedia_IsFillingNext16 += 1;
8000403c:	70 09       	ld.w	r9,r8[0x0]
8000403e:	2f f9       	sub	r9,-1
80004040:	91 09       	st.w	r8[0x0],r9
							
							if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80004042:	e0 49 00 ff 	cp.w	r9,255
80004046:	e0 88 00 16 	brls	80004072 <phy_rx_func+0x702>
							{
								RxMedia_IsFillingNext16 = 0;
8000404a:	30 09       	mov	r9,0
8000404c:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);
8000404e:	fe f6 02 da 	ld.w	r6,pc[730]
80004052:	6c 0c       	ld.w	r12,r6[0x0]
80004054:	f0 1f 00 bd 	mcall	80004348 <phy_rx_func+0x9d8>
								payload_ptr = get_payload_idle_isr();
80004058:	fe f8 02 cc 	ld.w	r8,pc[716]
8000405c:	70 0c       	ld.w	r12,r8[0x0]
8000405e:	f0 1f 00 ac 	mcall	8000430c <phy_rx_func+0x99c>
80004062:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == payload_ptr)
80004064:	c0 71       	brne	80004072 <phy_rx_func+0x702>
								{
									RxMediaState = WAITINGABAB;
80004066:	30 09       	mov	r9,0
80004068:	fe f8 02 c4 	ld.w	r8,pc[708]
8000406c:	91 09       	st.w	r8[0x0],r9
8000406e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 2) <= 0){
80004072:	fe f9 02 c2 	ld.w	r9,pc[706]
80004076:	72 08       	ld.w	r8,r9[0x0]
80004078:	20 28       	sub	r8,2
8000407a:	93 08       	st.w	r9[0x0],r8
8000407c:	c0 71       	brne	8000408a <phy_rx_func+0x71a>
								RxMediaState = WAITINGABAB;
8000407e:	30 09       	mov	r9,0
80004080:	fe f8 02 ac 	ld.w	r8,pc[684]
80004084:	91 09       	st.w	r8[0x0],r9
80004086:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[2];
8000408a:	fe f8 02 ba 	ld.w	r8,pc[698]
8000408e:	70 0a       	ld.w	r10,r8[0x0]
80004090:	fe f9 02 98 	ld.w	r9,pc[664]
80004094:	72 09       	ld.w	r9,r9[0x0]
80004096:	8e 6b       	ld.sh	r11,r7[0xc]
80004098:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
							RxMedia_IsFillingNext16 += 1;
8000409c:	70 09       	ld.w	r9,r8[0x0]
8000409e:	2f f9       	sub	r9,-1
800040a0:	91 09       	st.w	r8[0x0],r9
							if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800040a2:	e0 49 00 ff 	cp.w	r9,255
800040a6:	e0 88 00 16 	brls	800040d2 <phy_rx_func+0x762>
							{
								RxMedia_IsFillingNext16 = 0;
800040aa:	30 09       	mov	r9,0
800040ac:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);
800040ae:	fe f6 02 7a 	ld.w	r6,pc[634]
800040b2:	6c 0c       	ld.w	r12,r6[0x0]
800040b4:	f0 1f 00 a5 	mcall	80004348 <phy_rx_func+0x9d8>
								payload_ptr = get_payload_idle_isr();
800040b8:	fe f8 02 6c 	ld.w	r8,pc[620]
800040bc:	70 0c       	ld.w	r12,r8[0x0]
800040be:	f0 1f 00 94 	mcall	8000430c <phy_rx_func+0x99c>
800040c2:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == payload_ptr)
800040c4:	c0 71       	brne	800040d2 <phy_rx_func+0x762>
								{
									RxMediaState = WAITINGABAB;
800040c6:	30 09       	mov	r9,0
800040c8:	fe f8 02 64 	ld.w	r8,pc[612]
800040cc:	91 09       	st.w	r8[0x0],r9
800040ce:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 2) <= 0){
800040d2:	fe f9 02 62 	ld.w	r9,pc[610]
800040d6:	72 08       	ld.w	r8,r9[0x0]
800040d8:	20 28       	sub	r8,2
800040da:	93 08       	st.w	r9[0x0],r8
800040dc:	c0 71       	brne	800040ea <phy_rx_func+0x77a>
								RxMediaState = WAITINGABAB;
800040de:	30 09       	mov	r9,0
800040e0:	fe f8 02 4c 	ld.w	r8,pc[588]
800040e4:	91 09       	st.w	r8[0x0],r9
800040e6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
800040ea:	fe f8 02 5a 	ld.w	r8,pc[602]
800040ee:	70 0a       	ld.w	r10,r8[0x0]
800040f0:	fe f9 02 38 	ld.w	r9,pc[568]
800040f4:	72 09       	ld.w	r9,r9[0x0]
800040f6:	8e 7b       	ld.sh	r11,r7[0xe]
800040f8:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
							RxMedia_IsFillingNext16 += 1;
800040fc:	70 09       	ld.w	r9,r8[0x0]
800040fe:	2f f9       	sub	r9,-1
80004100:	91 09       	st.w	r8[0x0],r9
							if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80004102:	e0 49 00 ff 	cp.w	r9,255
80004106:	e0 88 00 16 	brls	80004132 <phy_rx_func+0x7c2>
							{
								RxMedia_IsFillingNext16 = 0;
8000410a:	30 09       	mov	r9,0
8000410c:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);
8000410e:	fe f7 02 1a 	ld.w	r7,pc[538]
80004112:	6e 0c       	ld.w	r12,r7[0x0]
80004114:	f0 1f 00 8d 	mcall	80004348 <phy_rx_func+0x9d8>
								payload_ptr = get_payload_idle_isr();
80004118:	fe f8 02 0c 	ld.w	r8,pc[524]
8000411c:	70 0c       	ld.w	r12,r8[0x0]
8000411e:	f0 1f 00 7c 	mcall	8000430c <phy_rx_func+0x99c>
80004122:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == payload_ptr)
80004124:	c0 71       	brne	80004132 <phy_rx_func+0x7c2>
								{
									RxMediaState = WAITINGABAB;
80004126:	30 09       	mov	r9,0
80004128:	fe f8 02 04 	ld.w	r8,pc[516]
8000412c:	91 09       	st.w	r8[0x0],r9
8000412e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 2) <= 0){
80004132:	fe f9 02 02 	ld.w	r9,pc[514]
80004136:	72 08       	ld.w	r8,r9[0x0]
80004138:	20 28       	sub	r8,2
8000413a:	93 08       	st.w	r9[0x0],r8
8000413c:	e0 81 00 d9 	brne	800042ee <phy_rx_func+0x97e>
								RxMediaState = WAITINGABAB;
80004140:	30 09       	mov	r9,0
80004142:	4f b8       	lddpc	r8,8000432c <phy_rx_func+0x9bc>
80004144:	91 09       	st.w	r8[0x0],r9
80004146:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							}
							
						}
						else//error
						{
							RxMediaState = WAITINGABAB;
8000414a:	30 09       	mov	r9,0
8000414c:	4f 88       	lddpc	r8,8000432c <phy_rx_func+0x9bc>
8000414e:	91 09       	st.w	r8[0x0],r9
80004150:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
					}
					else if (Item_ID == Post_Voice_Encoder_Data)//(bit48~Pad-bits)
80004154:	4f a8       	lddpc	r8,8000433c <phy_rx_func+0x9cc>
80004156:	11 89       	ld.ub	r9,r8[0x0]
80004158:	3f 28       	mov	r8,-14
8000415a:	f0 09 18 00 	cp.b	r9,r8
8000415e:	e0 81 00 aa 	brne	800042b2 <phy_rx_func+0x942>
					{
						AMBEBurst_rawdata[3] = payload_rx_channel->word[0];//(bit48~Pad-bits)
80004162:	8e 49       	ld.sh	r9,r7[0x8]
80004164:	fe f8 02 08 	ld.w	r8,pc[520]
80004168:	b0 39       	st.h	r8[0x6],r9
						//AMBE_Per_Burst_Flag = 1;
						
						payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[0];
8000416a:	4f 78       	lddpc	r8,80004344 <phy_rx_func+0x9d4>
8000416c:	70 0a       	ld.w	r10,r8[0x0]
8000416e:	4e f9       	lddpc	r9,80004328 <phy_rx_func+0x9b8>
80004170:	72 09       	ld.w	r9,r9[0x0]
80004172:	8e 4b       	ld.sh	r11,r7[0x8]
80004174:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
						RxMedia_IsFillingNext16 += 1;
80004178:	70 09       	ld.w	r9,r8[0x0]
8000417a:	2f f9       	sub	r9,-1
8000417c:	91 09       	st.w	r8[0x0],r9
						if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
8000417e:	e0 49 00 ff 	cp.w	r9,255
80004182:	e0 88 00 13 	brls	800041a8 <phy_rx_func+0x838>
						{
							RxMedia_IsFillingNext16 = 0;
80004186:	30 09       	mov	r9,0
80004188:	91 09       	st.w	r8[0x0],r9
							payload_rx(payload_ptr);
8000418a:	4e 86       	lddpc	r6,80004328 <phy_rx_func+0x9b8>
8000418c:	6c 0c       	ld.w	r12,r6[0x0]
8000418e:	f0 1f 00 6f 	mcall	80004348 <phy_rx_func+0x9d8>
							payload_ptr = get_payload_idle_isr();
80004192:	4e 58       	lddpc	r8,80004324 <phy_rx_func+0x9b4>
80004194:	70 0c       	ld.w	r12,r8[0x0]
80004196:	f0 1f 00 5e 	mcall	8000430c <phy_rx_func+0x99c>
8000419a:	8d 0c       	st.w	r6[0x0],r12
							
							if(NULL == payload_ptr){
8000419c:	c0 61       	brne	800041a8 <phy_rx_func+0x838>
								RxMediaState = WAITINGABAB;
8000419e:	30 09       	mov	r9,0
800041a0:	4e 38       	lddpc	r8,8000432c <phy_rx_func+0x9bc>
800041a2:	91 09       	st.w	r8[0x0],r9
800041a4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
				
						if ((RxBytesWaiting -= 2) <= 0)
800041a8:	4e 39       	lddpc	r9,80004334 <phy_rx_func+0x9c4>
800041aa:	72 08       	ld.w	r8,r9[0x0]
800041ac:	20 28       	sub	r8,2
800041ae:	93 08       	st.w	r9[0x0],r8
800041b0:	c0 61       	brne	800041bc <phy_rx_func+0x84c>
						{
							RxMediaState = WAITINGABAB;
800041b2:	30 09       	mov	r9,0
800041b4:	4d e8       	lddpc	r8,8000432c <phy_rx_func+0x9bc>
800041b6:	91 09       	st.w	r8[0x0],r9
800041b8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						}
						
						/******************************
						*******************/
						//(49bits)This shouldn't happen, but must check.
						payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[1];
800041bc:	4e 28       	lddpc	r8,80004344 <phy_rx_func+0x9d4>
800041be:	70 0a       	ld.w	r10,r8[0x0]
800041c0:	4d a9       	lddpc	r9,80004328 <phy_rx_func+0x9b8>
800041c2:	72 09       	ld.w	r9,r9[0x0]
800041c4:	8e 5b       	ld.sh	r11,r7[0xa]
800041c6:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
						RxMedia_IsFillingNext16 += 1;
800041ca:	70 09       	ld.w	r9,r8[0x0]
800041cc:	2f f9       	sub	r9,-1
800041ce:	91 09       	st.w	r8[0x0],r9
						if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800041d0:	e0 49 00 ff 	cp.w	r9,255
800041d4:	e0 88 00 13 	brls	800041fa <phy_rx_func+0x88a>
						{
							RxMedia_IsFillingNext16 = 0;
800041d8:	30 09       	mov	r9,0
800041da:	91 09       	st.w	r8[0x0],r9
							payload_rx(payload_ptr);
800041dc:	4d 36       	lddpc	r6,80004328 <phy_rx_func+0x9b8>
800041de:	6c 0c       	ld.w	r12,r6[0x0]
800041e0:	f0 1f 00 5a 	mcall	80004348 <phy_rx_func+0x9d8>
							payload_ptr = get_payload_idle_isr();
800041e4:	4d 08       	lddpc	r8,80004324 <phy_rx_func+0x9b4>
800041e6:	70 0c       	ld.w	r12,r8[0x0]
800041e8:	f0 1f 00 49 	mcall	8000430c <phy_rx_func+0x99c>
800041ec:	8d 0c       	st.w	r6[0x0],r12
							
							if(NULL == payload_ptr){
800041ee:	c0 61       	brne	800041fa <phy_rx_func+0x88a>
								RxMediaState = WAITINGABAB;
800041f0:	30 09       	mov	r9,0
800041f2:	4c f8       	lddpc	r8,8000432c <phy_rx_func+0x9bc>
800041f4:	91 09       	st.w	r8[0x0],r9
800041f6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 2) <= 0){
800041fa:	4c f9       	lddpc	r9,80004334 <phy_rx_func+0x9c4>
800041fc:	72 08       	ld.w	r8,r9[0x0]
800041fe:	20 28       	sub	r8,2
80004200:	93 08       	st.w	r9[0x0],r8
80004202:	c0 61       	brne	8000420e <phy_rx_func+0x89e>
							RxMediaState = WAITINGABAB;
80004204:	30 09       	mov	r9,0
80004206:	4c a8       	lddpc	r8,8000432c <phy_rx_func+0x9bc>
80004208:	91 09       	st.w	r8[0x0],r9
8000420a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}

						payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[2];
8000420e:	4c e8       	lddpc	r8,80004344 <phy_rx_func+0x9d4>
80004210:	70 0a       	ld.w	r10,r8[0x0]
80004212:	4c 69       	lddpc	r9,80004328 <phy_rx_func+0x9b8>
80004214:	72 09       	ld.w	r9,r9[0x0]
80004216:	8e 6b       	ld.sh	r11,r7[0xc]
80004218:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
						RxMedia_IsFillingNext16 += 1;							
8000421c:	70 09       	ld.w	r9,r8[0x0]
8000421e:	2f f9       	sub	r9,-1
80004220:	91 09       	st.w	r8[0x0],r9
						if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80004222:	e0 49 00 ff 	cp.w	r9,255
80004226:	e0 88 00 13 	brls	8000424c <phy_rx_func+0x8dc>
						{
							RxMedia_IsFillingNext16 = 0;
8000422a:	30 09       	mov	r9,0
8000422c:	91 09       	st.w	r8[0x0],r9
							payload_rx(payload_ptr);
8000422e:	4b f6       	lddpc	r6,80004328 <phy_rx_func+0x9b8>
80004230:	6c 0c       	ld.w	r12,r6[0x0]
80004232:	f0 1f 00 46 	mcall	80004348 <phy_rx_func+0x9d8>
							payload_ptr = get_payload_idle_isr();
80004236:	4b c8       	lddpc	r8,80004324 <phy_rx_func+0x9b4>
80004238:	70 0c       	ld.w	r12,r8[0x0]
8000423a:	f0 1f 00 35 	mcall	8000430c <phy_rx_func+0x99c>
8000423e:	8d 0c       	st.w	r6[0x0],r12
							
							if(NULL == payload_ptr){
80004240:	c0 61       	brne	8000424c <phy_rx_func+0x8dc>
								RxMediaState = WAITINGABAB;
80004242:	30 09       	mov	r9,0
80004244:	4b a8       	lddpc	r8,8000432c <phy_rx_func+0x9bc>
80004246:	91 09       	st.w	r8[0x0],r9
80004248:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 2) <= 0){
8000424c:	4b a9       	lddpc	r9,80004334 <phy_rx_func+0x9c4>
8000424e:	72 08       	ld.w	r8,r9[0x0]
80004250:	20 28       	sub	r8,2
80004252:	93 08       	st.w	r9[0x0],r8
80004254:	c0 61       	brne	80004260 <phy_rx_func+0x8f0>
							RxMediaState = WAITINGABAB;
80004256:	30 09       	mov	r9,0
80004258:	4b 58       	lddpc	r8,8000432c <phy_rx_func+0x9bc>
8000425a:	91 09       	st.w	r8[0x0],r9
8000425c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
							
						payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
80004260:	4b 98       	lddpc	r8,80004344 <phy_rx_func+0x9d4>
80004262:	70 0a       	ld.w	r10,r8[0x0]
80004264:	4b 19       	lddpc	r9,80004328 <phy_rx_func+0x9b8>
80004266:	72 09       	ld.w	r9,r9[0x0]
80004268:	8e 7b       	ld.sh	r11,r7[0xe]
8000426a:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
						RxMedia_IsFillingNext16 += 1;
8000426e:	70 09       	ld.w	r9,r8[0x0]
80004270:	2f f9       	sub	r9,-1
80004272:	91 09       	st.w	r8[0x0],r9
						if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80004274:	e0 49 00 ff 	cp.w	r9,255
80004278:	e0 88 00 13 	brls	8000429e <phy_rx_func+0x92e>
						{
							RxMedia_IsFillingNext16 = 0;
8000427c:	30 09       	mov	r9,0
8000427e:	91 09       	st.w	r8[0x0],r9
							payload_rx(payload_ptr);
80004280:	4a a7       	lddpc	r7,80004328 <phy_rx_func+0x9b8>
80004282:	6e 0c       	ld.w	r12,r7[0x0]
80004284:	f0 1f 00 31 	mcall	80004348 <phy_rx_func+0x9d8>
							payload_ptr = get_payload_idle_isr();
80004288:	4a 78       	lddpc	r8,80004324 <phy_rx_func+0x9b4>
8000428a:	70 0c       	ld.w	r12,r8[0x0]
8000428c:	f0 1f 00 20 	mcall	8000430c <phy_rx_func+0x99c>
80004290:	8f 0c       	st.w	r7[0x0],r12
							
							if(NULL == payload_ptr){
80004292:	c0 61       	brne	8000429e <phy_rx_func+0x92e>
								RxMediaState = WAITINGABAB;
80004294:	30 09       	mov	r9,0
80004296:	4a 68       	lddpc	r8,8000432c <phy_rx_func+0x9bc>
80004298:	91 09       	st.w	r8[0x0],r9
8000429a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 2) <= 0){
8000429e:	4a 69       	lddpc	r9,80004334 <phy_rx_func+0x9c4>
800042a0:	72 08       	ld.w	r8,r9[0x0]
800042a2:	20 28       	sub	r8,2
800042a4:	93 08       	st.w	r9[0x0],r8
800042a6:	c2 41       	brne	800042ee <phy_rx_func+0x97e>
							RxMediaState = WAITINGABAB;
800042a8:	30 09       	mov	r9,0
800042aa:	4a 18       	lddpc	r8,8000432c <phy_rx_func+0x9bc>
800042ac:	91 09       	st.w	r8[0x0],r9
800042ae:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						*******************/
						
								
					}
					
					else if ((Item_ID == 0x04)  ||  (Item_ID == 0x03))//Unknown type data directly back hair
800042b2:	4a 38       	lddpc	r8,8000433c <phy_rx_func+0x9cc>
800042b4:	11 89       	ld.ub	r9,r8[0x0]
800042b6:	30 48       	mov	r8,4
800042b8:	f0 09 18 00 	cp.b	r9,r8
800042bc:	c0 70       	breq	800042ca <phy_rx_func+0x95a>
800042be:	4a 08       	lddpc	r8,8000433c <phy_rx_func+0x9cc>
800042c0:	11 89       	ld.ub	r9,r8[0x0]
800042c2:	30 38       	mov	r8,3
800042c4:	f0 09 18 00 	cp.b	r9,r8
800042c8:	c1 01       	brne	800042e8 <phy_rx_func+0x978>
					{
						AMBE_HT[0] = payload_rx_channel->dword[0];
800042ca:	6e 29       	ld.w	r9,r7[0x8]
800042cc:	4a 28       	lddpc	r8,80004354 <phy_rx_func+0x9e4>
800042ce:	91 09       	st.w	r8[0x0],r9
						AMBE_HT[1] = payload_rx_channel->dword[1];				
800042d0:	6e 39       	ld.w	r9,r7[0xc]
800042d2:	91 19       	st.w	r8[0x4],r9
						
						if ((RxBytesWaiting -= 8) <= 0)//Consider two cases 0xABCDC014 and 0xABCDC010
800042d4:	49 89       	lddpc	r9,80004334 <phy_rx_func+0x9c4>
800042d6:	72 08       	ld.w	r8,r9[0x0]
800042d8:	20 88       	sub	r8,8
800042da:	93 08       	st.w	r9[0x0],r8
800042dc:	c0 91       	brne	800042ee <phy_rx_func+0x97e>
						{
					
							RxBytesWaiting = 0;
800042de:	93 08       	st.w	r9[0x0],r8
							RxMediaState = WAITINGABAB;
800042e0:	49 39       	lddpc	r9,8000432c <phy_rx_func+0x9bc>
800042e2:	93 08       	st.w	r9[0x0],r8
800042e4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					//}
					
					else
					{
						
						RxMediaState  = WAITINGABAB;
800042e8:	30 09       	mov	r9,0
800042ea:	49 18       	lddpc	r8,8000432c <phy_rx_func+0x9bc>
800042ec:	91 09       	st.w	r8[0x0],r9
800042ee:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800042f2:	00 00       	add	r0,r0
800042f4:	00 00       	add	r0,r0
800042f6:	0a b8       	st.h	r5++,r8
800042f8:	00 00       	add	r0,r0
800042fa:	0a d4       	st.w	--r5,r4
800042fc:	00 00       	add	r0,r0
800042fe:	0a a0       	st.w	r5++,r0
80004300:	00 00       	add	r0,r0
80004302:	0a 88       	andn	r8,r5
80004304:	00 00       	add	r0,r0
80004306:	0a 82       	andn	r2,r5
80004308:	00 00       	add	r0,r0
8000430a:	0a 9c       	mov	r12,r5
8000430c:	80 00       	ld.sh	r0,r0[0x0]
8000430e:	32 48       	mov	r8,36
80004310:	00 00       	add	r0,r0
80004312:	0a d8       	st.w	--r5,r8
80004314:	80 00       	ld.sh	r0,r0[0x0]
80004316:	58 c0       	cp.w	r0,12
80004318:	00 00       	add	r0,r0
8000431a:	0a b4       	st.h	r5++,r4
8000431c:	80 00       	ld.sh	r0,r0[0x0]
8000431e:	31 94       	mov	r4,25
80004320:	00 00       	add	r0,r0
80004322:	0a 81       	andn	r1,r5
80004324:	00 00       	add	r0,r0
80004326:	0a 8c       	andn	r12,r5
80004328:	00 00       	add	r0,r0
8000432a:	0a a8       	st.w	r5++,r8
8000432c:	00 00       	add	r0,r0
8000432e:	0a c8       	st.b	r5++,r8
80004330:	00 00       	add	r0,r0
80004332:	0a 74       	tst	r4,r5
80004334:	00 00       	add	r0,r0
80004336:	0a 70       	tst	r0,r5
80004338:	00 00       	add	r0,r0
8000433a:	0a 44       	or	r4,r5
8000433c:	00 00       	add	r0,r0
8000433e:	0a 80       	andn	r0,r5
80004340:	00 00       	add	r0,r0
80004342:	0a 4c       	or	r12,r5
80004344:	00 00       	add	r0,r0
80004346:	0a bc       	st.h	r5++,r12
80004348:	80 00       	ld.sh	r0,r0[0x0]
8000434a:	39 10       	mov	r0,-111
8000434c:	00 00       	add	r0,r0
8000434e:	20 84       	sub	r4,8
80004350:	80 00       	ld.sh	r0,r0[0x0]
80004352:	30 d8       	mov	r8,13
80004354:	00 00       	add	r0,r0
80004356:	0a 94       	mov	r4,r5
80004358:	80 01       	ld.sh	r1,r0[0x0]
8000435a:	57 14       	stdsp	sp[0x1c4],r4
8000435c:	80 00       	ld.sh	r0,r0[0x0]
8000435e:	69 60       	ld.w	r0,r4[0x58]
80004360:	80 01       	ld.sh	r1,r0[0x0]
80004362:	57 28       	stdsp	sp[0x1c8],r8
80004364:	00 00       	add	r0,r0
80004366:	0a c4       	st.b	r5++,r4
80004368:	00 00       	add	r0,r0
8000436a:	0a 55       	eor	r5,r5
8000436c:	00 00       	add	r0,r0
8000436e:	1f 8c       	ld.ub	r12,pc[0x0]

80004370 <pdca_int_handler>:
    void (*phy_rx_exec)(void *)--callback function for receive SSC data 
Called By: interrupt
*/
__attribute__((__interrupt__))
static void pdca_int_handler(void)
{
80004370:	d4 01       	pushm	lr
    
	//intStartCount = Get_system_register(AVR32_COUNT);
	
	/*Toggle Index*/
    BufferIndex ^= 0x01;
80004372:	49 88       	lddpc	r8,800043d0 <pdca_int_handler+0x60>
80004374:	11 89       	ld.ub	r9,r8[0x0]
80004376:	ec 19 00 01 	eorl	r9,0x1
8000437a:	b0 89       	st.b	r8[0x0],r9
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);
8000437c:	11 89       	ld.ub	r9,r8[0x0]
8000437e:	a5 69       	lsl	r9,0x4
80004380:	2f c9       	sub	r9,-4
80004382:	49 5a       	lddpc	r10,800043d4 <pdca_int_handler+0x64>
80004384:	14 09       	add	r9,r10
	
	/*Toggle Index*/
    BufferIndex ^= 0x01;
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
80004386:	fe 7a 00 40 	mov	r10,-65472
8000438a:	95 39       	st.w	r10[0xc],r9
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
8000438c:	30 39       	mov	r9,3
8000438e:	95 49       	st.w	r10[0x10],r9

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);
80004390:	11 8a       	ld.ub	r10,r8[0x0]
80004392:	a5 6a       	lsl	r10,0x4
80004394:	2f ca       	sub	r10,-4
80004396:	49 18       	lddpc	r8,800043d8 <pdca_int_handler+0x68>
80004398:	10 0a       	add	r10,r8
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
8000439a:	fe 78 00 00 	mov	r8,-65536
8000439e:	91 3a       	st.w	r8[0xc],r10
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
800043a0:	91 49       	st.w	r8[0x10],r9
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr;
800043a2:	70 b8       	ld.w	r8,r8[0x2c]
	
	/*receive SSC data*/
    if(phy_rx_exec != NULL)phy_rx_exec((void *)&RxBuffer[BufferIndex]);
800043a4:	48 e8       	lddpc	r8,800043dc <pdca_int_handler+0x6c>
800043a6:	70 08       	ld.w	r8,r8[0x0]
800043a8:	58 08       	cp.w	r8,0
800043aa:	c0 70       	breq	800043b8 <pdca_int_handler+0x48>
800043ac:	48 99       	lddpc	r9,800043d0 <pdca_int_handler+0x60>
800043ae:	13 89       	ld.ub	r9,r9[0x0]
800043b0:	a5 69       	lsl	r9,0x4
800043b2:	48 ac       	lddpc	r12,800043d8 <pdca_int_handler+0x68>
800043b4:	12 0c       	add	r12,r9
800043b6:	5d 18       	icall	r8

    /*transmit SSC data*/

	if(phy_tx_exec != NULL)phy_tx_exec((void *)&TxBuffer[BufferIndex]);//phy_tx_func, phy_rx_func
800043b8:	48 a8       	lddpc	r8,800043e0 <pdca_int_handler+0x70>
800043ba:	70 08       	ld.w	r8,r8[0x0]
800043bc:	58 08       	cp.w	r8,0
800043be:	c0 70       	breq	800043cc <pdca_int_handler+0x5c>
800043c0:	48 49       	lddpc	r9,800043d0 <pdca_int_handler+0x60>
800043c2:	13 89       	ld.ub	r9,r9[0x0]
800043c4:	a5 69       	lsl	r9,0x4
800043c6:	48 4c       	lddpc	r12,800043d4 <pdca_int_handler+0x64>
800043c8:	12 0c       	add	r12,r9
800043ca:	5d 18       	icall	r8

	
	//intDuration = Get_system_register(AVR32_COUNT) - intStartCount;
	
	
}/*End of pdca_int_handler.*/
800043cc:	d4 02       	popm	lr
800043ce:	d6 03       	rete
800043d0:	00 00       	add	r0,r0
800043d2:	52 8c       	stdsp	sp[0xa0],r12
800043d4:	00 00       	add	r0,r0
800043d6:	52 b4       	stdsp	sp[0xac],r4
800043d8:	00 00       	add	r0,r0
800043da:	52 94       	stdsp	sp[0xa4],r4
800043dc:	00 00       	add	r0,r0
800043de:	0a e4       	st.h	--r5,r4
800043e0:	00 00       	add	r0,r0
800043e2:	0a e8       	st.h	--r5,r8

800043e4 <local_start_SSC>:
void local_start_SSC(void)
{
    /*Assign GPIO to SSC.
    gpio_enable_module
    gpio_enable_module_pin*/
    AVR32_GPIO.port[1].pmr0c = 0x00000DC0;
800043e4:	fe 78 10 00 	mov	r8,-61440
800043e8:	e0 69 0d c0 	mov	r9,3520
800043ec:	f1 49 01 18 	st.w	r8[280],r9
    AVR32_GPIO.port[1].pmr1c = 0x00000DC0;
800043f0:	f1 49 01 28 	st.w	r8[296],r9
    AVR32_GPIO.port[1].gperc = 0x00000DC0;
800043f4:	f1 49 01 08 	st.w	r8[264],r9

    /*Software reset SSC*/
    (&AVR32_SSC)->cr = AVR32_SSC_CR_SWRST_MASK;
800043f8:	fe 78 34 00 	mov	r8,-52224
800043fc:	e0 69 80 00 	mov	r9,32768
80004400:	91 09       	st.w	r8[0x0],r9
    (&AVR32_SSC)->cmr 
80004402:	30 09       	mov	r9,0
80004404:	91 19       	st.w	r8[0x4],r9
                     = AVR32_SSC_CMR_DIV_NOT_ACTIVE << AVR32_SSC_CMR_DIV_OFFSET;

    /*For Slave*/
    (&AVR32_SSC)->tcmr =
80004406:	e0 69 04 21 	mov	r9,1057
8000440a:	ea 19 3f 20 	orh	r9,0x3f20
8000440e:	91 69       	st.w	r8[0x18],r9
	    | 32 << AVR32_SSC_TCMR_STTDLY_OFFSET
	    | 63 << AVR32_SSC_TCMR_PERIOD_OFFSET;


    /*For Slave*/
    (&AVR32_SSC)->tfmr = 31 << AVR32_SSC_TFMR_DATLEN_OFFSET 
80004410:	e0 69 02 9f 	mov	r9,671
80004414:	ea 19 01 00 	orh	r9,0x100
80004418:	91 79       	st.w	r8[0x1c],r9
	    | 0 << AVR32_SSC_TFMR_FSDEN_OFFSET
	    | 1 << AVR32_SSC_TFMR_FSEDGE_OFFSET;

	/*For Slave*/

	(&AVR32_SSC)->rcmr = AVR32_SSC_RCMR_CKS_RK_PIN << AVR32_SSC_RCMR_CKS_OFFSET
8000441a:	e0 6a 04 02 	mov	r10,1026
8000441e:	ea 1a 3f 20 	orh	r10,0x3f20
80004422:	91 4a       	st.w	r8[0x10],r10
	    | 0 << AVR32_SSC_RCMR_STOP_OFFSET
	    | 32 << AVR32_SSC_RCMR_STTDLY_OFFSET
	    | 63 << AVR32_SSC_RCMR_PERIOD_OFFSET;

	/*For Slave*/
	(&AVR32_SSC)->rfmr = 31 << AVR32_SSC_RFMR_DATLEN_OFFSET
80004424:	91 59       	st.w	r8[0x14],r9
	    | 1 << AVR32_SSC_RFMR_MSBF_OFFSET
	    | 2 << AVR32_SSC_RFMR_DATNB_OFFSET
	    | 0 << AVR32_SSC_RFMR_FSLEN_OFFSET
	    | AVR32_SSC_RFMR_FSOS_INPUT_ONLY << AVR32_SSC_RFMR_FSOS_OFFSET
	    | 1 << AVR32_SSC_RFMR_FSEDGE_OFFSET;
}/*End of local_start_SSC.*/
80004426:	5e fc       	retal	r12

80004428 <local_start_PDC>:
Function: local_start_PDC
Description: none
Called By: void ssc_init(void) -- ssc.c
*/
void local_start_PDC(void)
{
80004428:	d4 01       	pushm	lr
    /*Toggle Index*/	
    BufferIndex = 1;
8000442a:	30 19       	mov	r9,1
8000442c:	49 78       	lddpc	r8,80004488 <local_start_PDC+0x60>
8000442e:	b0 89       	st.b	r8[0x0],r9
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
80004430:	fe 78 00 00 	mov	r8,-65536
80004434:	30 7b       	mov	r11,7
80004436:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
80004438:	70 b9       	ld.w	r9,r8[0x2c]
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
8000443a:	49 59       	lddpc	r9,8000448c <local_start_PDC+0x64>
8000443c:	f2 ca ff fc 	sub	r10,r9,-4
    BufferIndex = 1;
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
80004440:	91 0a       	st.w	r8[0x0],r10
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
80004442:	30 3a       	mov	r10,3
80004444:	91 2a       	st.w	r8[0x8],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
80004446:	30 1c       	mov	r12,1
80004448:	91 1c       	st.w	r8[0x4],r12
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
8000444a:	2e c9       	sub	r9,-20
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
8000444c:	91 39       	st.w	r8[0xc],r9
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
8000444e:	91 4a       	st.w	r8[0x10],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80004450:	30 2c       	mov	r12,2
80004452:	91 6c       	st.w	r8[0x18],r12

	TxBuffer[0].xnl_channel.dword = XNL_IDLE;
80004454:	48 f9       	lddpc	r9,80004490 <local_start_PDC+0x68>
80004456:	e0 68 5a 5a 	mov	r8,23130
8000445a:	ea 18 ab cd 	orh	r8,0xabcd
8000445e:	93 18       	st.w	r9[0x4],r8
	TxBuffer[0].payload_channel.dword[0] = PAYLOADIDLE0;
80004460:	93 28       	st.w	r9[0x8],r8
	TxBuffer[0].payload_channel.dword[1] = PAYLOADIDLE1;
80004462:	30 0e       	mov	lr,0
80004464:	93 3e       	st.w	r9[0xc],lr
	TxBuffer[1].xnl_channel.dword = XNL_IDLE;
80004466:	93 58       	st.w	r9[0x14],r8
	TxBuffer[1].payload_channel.dword[0] = PAYLOADIDLE0;
80004468:	93 68       	st.w	r9[0x18],r8
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;
8000446a:	93 7e       	st.w	r9[0x1c],lr

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
8000446c:	fe 78 00 40 	mov	r8,-65472
80004470:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
80004472:	70 be       	ld.w	lr,r8[0x2c]
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
80004474:	f2 ce ff fc 	sub	lr,r9,-4
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
80004478:	91 0e       	st.w	r8[0x0],lr
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
8000447a:	91 2a       	st.w	r8[0x8],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
8000447c:	91 1b       	st.w	r8[0x4],r11
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
8000447e:	2e c9       	sub	r9,-20
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
80004480:	91 39       	st.w	r8[0xc],r9
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80004482:	91 4a       	st.w	r8[0x10],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80004484:	91 6c       	st.w	r8[0x18],r12
}/*End of local_start_PDC.*/
80004486:	d8 02       	popm	pc
80004488:	00 00       	add	r0,r0
8000448a:	52 8c       	stdsp	sp[0xa0],r12
8000448c:	00 00       	add	r0,r0
8000448e:	52 94       	stdsp	sp[0xa4],r4
80004490:	00 00       	add	r0,r0
80004492:	52 b4       	stdsp	sp[0xac],r4

80004494 <register_rx_tx_func>:
Description: register the rx function(callback function)
Called By: phy_init -- physical.c
*/
void register_rx_tx_func(void (*rx_exec)(void *),  void ( *tx_exec)(void *))
{
	 phy_rx_exec = rx_exec;
80004494:	48 38       	lddpc	r8,800044a0 <register_rx_tx_func+0xc>
80004496:	91 0c       	st.w	r8[0x0],r12
	 phy_tx_exec = tx_exec;//phy_tx_func, phy_rx_func
80004498:	48 38       	lddpc	r8,800044a4 <register_rx_tx_func+0x10>
8000449a:	91 0b       	st.w	r8[0x0],r11
	 
}/*End of register_tx_rx_func.*/
8000449c:	5e fc       	retal	r12
8000449e:	00 00       	add	r0,r0
800044a0:	00 00       	add	r0,r0
800044a2:	0a e4       	st.h	--r5,r4
800044a4:	00 00       	add	r0,r0
800044a6:	0a e8       	st.h	--r5,r8

800044a8 <ssc_init>:
    local_start_SSC -- ssc.c
    local_start_PDC -- ssc.c
Called By: phy_init -- physical.c
*/
void ssc_init(void)
{		
800044a8:	d4 01       	pushm	lr
    /*Set up PB03 to watch FS.*/
    AVR32_GPIO.port[1].oderc = 0x00000002;
800044aa:	fe 78 10 00 	mov	r8,-61440
800044ae:	30 29       	mov	r9,2
800044b0:	f1 49 01 48 	st.w	r8[328],r9
    AVR32_GPIO.port[1].gpers = 0x00000002;
800044b4:	f1 49 01 04 	st.w	r8[260],r9

    /*Waits for radio to start making FSYNC.*/
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
800044b8:	10 99       	mov	r9,r8
800044ba:	f2 f8 01 60 	ld.w	r8,r9[352]
800044be:	e2 18 00 02 	andl	r8,0x2,COH
800044c2:	cf c0       	breq	800044ba <ssc_init+0x12>
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
800044c4:	fe 79 10 00 	mov	r9,-61440
800044c8:	f2 f8 01 60 	ld.w	r8,r9[352]
800044cc:	e2 18 00 02 	andl	r8,0x2,COH
800044d0:	cf c1       	brne	800044c8 <ssc_init+0x20>
				
    INTC_register_interrupt (
800044d2:	30 3a       	mov	r10,3
800044d4:	36 0b       	mov	r11,96
800044d6:	48 bc       	lddpc	r12,80004500 <ssc_init+0x58>
800044d8:	f0 1f 00 0b 	mcall	80004504 <ssc_init+0x5c>
        , AVR32_PDCA_IRQ_0
        , AVR32_INTC_INT3
    );
				
    /*config the SSC*/
    local_start_SSC();
800044dc:	f0 1f 00 0b 	mcall	80004508 <ssc_init+0x60>

    /*config the PDCA*/
    local_start_PDC();
800044e0:	f0 1f 00 0b 	mcall	8000450c <ssc_init+0x64>
		
    /*Start the SSC Physical Layer.*/

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
800044e4:	fe 79 00 00 	mov	r9,-65536
800044e8:	30 18       	mov	r8,1
800044ea:	93 58       	st.w	r9[0x14],r8
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
800044ec:	fe 7a 00 40 	mov	r10,-65472
800044f0:	95 58       	st.w	r10[0x14],r8
    (&AVR32_SSC)->cr = AVR32_SSC_CR_RXEN_MASK | AVR32_SSC_CR_TXEN_MASK;
800044f2:	e0 6b 01 01 	mov	r11,257
800044f6:	fe 7a 34 00 	mov	r10,-52224
800044fa:	95 0b       	st.w	r10[0x0],r11
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->ier = 
800044fc:	93 88       	st.w	r9[0x20],r8
                                                            AVR32_PDCA_RCZ_MASK;
}/*End of ssc_init.*/
800044fe:	d8 02       	popm	pc
80004500:	80 00       	ld.sh	r0,r0[0x0]
80004502:	43 70       	lddsp	r0,sp[0xdc]
80004504:	80 00       	ld.sh	r0,r0[0x0]
80004506:	4e 70       	lddpc	r0,800046a0 <xcmp_init+0x30>
80004508:	80 00       	ld.sh	r0,r0[0x0]
8000450a:	43 e4       	lddsp	r4,sp[0xf8]
8000450c:	80 00       	ld.sh	r0,r0[0x0]
8000450e:	44 28       	lddsp	r8,sp[0x108]

80004510 <xcmp_register_app_list>:
Calls: 
Called By: app_init -- app.c
*/
void xcmp_register_app_list(void * list)
{
	app_list = (app_exec_t *)list;
80004510:	48 28       	lddpc	r8,80004518 <xcmp_register_app_list+0x8>
80004512:	91 0c       	st.w	r8[0x0],r12
}
80004514:	5e fc       	retal	r12
80004516:	00 00       	add	r0,r0
80004518:	00 00       	add	r0,r0
8000451a:	52 d4       	stdsp	sp[0xb4],r4

8000451c <xcmp_tx>:
Calls:   
	xnl_tx -- xnl.c
Called By: ...
*/
static void xcmp_tx( xcmp_fragment_t * xcmp, U8 payload_len)
{
8000451c:	eb cd 40 80 	pushm	r7,lr
80004520:	fa cd 01 00 	sub	sp,sp,256
80004524:	16 97       	mov	r7,r11
	Length :xnl length + checksum
	= checksum + xnl header + xcmp opcode + xcmp payload
	= 0x02 + 0x0C + 0x02 + xcmp payload
	= 0x10 + xcmp payload
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | ( 0x10 + payload_len);
80004526:	16 98       	mov	r8,r11
80004528:	2f 08       	sub	r8,-16
8000452a:	af a8       	sbr	r8,0xe
8000452c:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE; 
8000452e:	3f f8       	mov	r8,-1
80004530:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG;
80004532:	30 b9       	mov	r9,11
80004534:	ba 29       	st.h	sp[0x4],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;	
80004536:	ba 38       	st.h	sp[0x6],r8
	xnl_frame.xnl_header.destination = DEFAULT_VALUE;
80004538:	ba 48       	st.h	sp[0x8],r8
	xnl_frame.xnl_header.source = DEFAULT_VALUE;	
8000453a:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
8000453c:	ba 68       	st.h	sp[0xc],r8
	
	/*insert xcmp frame data*/
	memcpy(&xnl_frame.xnl_payload.xnl_content_data_msg, xcmp, payload_len + 2);
8000453e:	f6 ca ff fe 	sub	r10,r11,-2
80004542:	18 9b       	mov	r11,r12
80004544:	fa cc ff f0 	sub	r12,sp,-16
80004548:	f0 1f 00 05 	mcall	8000455c <xcmp_tx+0x40>
	xnl_frame.xnl_header.payload_length = payload_len + 2;	
8000454c:	2f e7       	sub	r7,-2
8000454e:	ba 77       	st.h	sp[0xe],r7
	
	/* send xnl frame*/	
	xnl_tx(&xnl_frame);
80004550:	1a 9c       	mov	r12,sp
80004552:	f0 1f 00 04 	mcall	80004560 <xcmp_tx+0x44>
}
80004556:	2c 0d       	sub	sp,-256
80004558:	e3 cd 80 80 	ldm	sp++,r7,pc
8000455c:	80 00       	ld.sh	r0,r0[0x0]
8000455e:	71 8e       	ld.w	lr,r8[0x60]
80004560:	80 00       	ld.sh	r0,r0[0x0]
80004562:	49 6c       	lddpc	r12,800045b8 <xcmp_opcode_not_supported+0x14>

80004564 <xcmp_DeviceInitializationStatus_request>:
Description: send device initialization status request
Calls: xcmp_tx
Called By:...
*/
void xcmp_DeviceInitializationStatus_request(void)
{
80004564:	d4 01       	pushm	lr
80004566:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
		
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_BRDCAST | DEVICE_INITIALIZATION_STATUS;
8000456a:	fe 78 b4 00 	mov	r8,-19456
8000456e:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceInitializationStatus_brdcst_t * ptr 
						 = (DeviceInitializationStatus_brdcst_t *)xcmp_farme.u8;
80004570:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*xcmp version 8.1.0.5*///版本号未正确填写，纠正
	ptr->XCMPVersion[0] = 0x08;
80004574:	30 89       	mov	r9,8
80004576:	b0 89       	st.b	r8[0x0],r9
	ptr->XCMPVersion[1] = 0x01;
80004578:	30 19       	mov	r9,1
8000457a:	b0 99       	st.b	r8[0x1],r9
	ptr->XCMPVersion[2] = 0x00;
8000457c:	30 09       	mov	r9,0
8000457e:	b0 a9       	st.b	r8[0x2],r9
	ptr->XCMPVersion[3] = 0x05;
80004580:	30 5a       	mov	r10,5
80004582:	b0 ba       	st.b	r8[0x3],r10
	/*
	0x00:
	This is the message that the device sends at power up or after a reset. It 
	will give the initial status and capabilities for the device.
	*/
	ptr->DeviceInitType = 0x00;
80004584:	b0 c9       	st.b	r8[0x4],r9
	types of devices may provide a set of services to the radio system, but do 
	not have the ability to be the master.
	
	0x07:OptionBoard,3rd party Option Board-based application.
	*/
	ptr->DeviceStatusInfo.DeviceType = 0x07;
80004586:	30 7a       	mov	r10,7
80004588:	b0 da       	st.b	r8[0x5],r10
	
	/*Power Up Success, Device has powered up with no errors*/
	ptr->DeviceStatusInfo.DeviceStatus[0] = 0x00;
8000458a:	b0 e9       	st.b	r8[0x6],r9
	ptr->DeviceStatusInfo.DeviceStatus[1] = 0x00;
8000458c:	b0 f9       	st.b	r8[0x7],r9
	
	/*
	This number is the size of the Device Descriptor data structure with a 
	maximum size not exceeding 255 bytes.
	*/
	ptr->DeviceStatusInfo.DeviceDescriptorSize = 0x00;
8000458e:	f1 69 00 08 	st.b	r8[8],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme
80004592:	30 9b       	mov	r11,9
80004594:	fa cc ff fe 	sub	r12,sp,-2
80004598:	f0 1f 00 02 	mcall	800045a0 <xcmp_DeviceInitializationStatus_request+0x3c>
		, sizeof(DeviceInitializationStatus_brdcst_t) - MAX_DEVICE_DESC_SIZE);
}
8000459c:	2c dd       	sub	sp,-204
8000459e:	d8 02       	popm	pc
800045a0:	80 00       	ld.sh	r0,r0[0x0]
800045a2:	45 1c       	lddsp	r12,sp[0x144]

800045a4 <xcmp_opcode_not_supported>:
Description: register the app list
Calls: xcmp_tx
Called By:...
*/
void xcmp_opcode_not_supported( void )
{
800045a4:	d4 01       	pushm	lr
800045a6:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REPLY;
800045aa:	fe 78 80 00 	mov	r8,-32768
800045ae:	ba 18       	st.h	sp[0x2],r8
	
	/*The radio does not support this opcode.*/
	xcmp_farme.u8[0] = xcmp_Res_Opcode_Not_Supported;
800045b0:	30 38       	mov	r8,3
800045b2:	ba c8       	st.b	sp[0x4],r8
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, 1);
800045b4:	30 1b       	mov	r11,1
800045b6:	fa cc ff fe 	sub	r12,sp,-2
800045ba:	f0 1f 00 03 	mcall	800045c4 <xcmp_opcode_not_supported+0x20>
}
800045be:	2c dd       	sub	sp,-204
800045c0:	d8 02       	popm	pc
800045c2:	00 00       	add	r0,r0
800045c4:	80 00       	ld.sh	r0,r0[0x0]
800045c6:	45 1c       	lddsp	r12,sp[0x144]

800045c8 <xcmp_exec_func>:
Description: Perform XCMP corresponding functions
Calls:   
Called By: xcmp_rx_process--task
*/
static void xcmp_exec_func(app_exec_t * exec, xcmp_fragment_t * xcmp)
{
800045c8:	d4 01       	pushm	lr
	/*The message types*/
	switch(xcmp->xcmp_opcode & 0xF000)
800045ca:	96 88       	ld.uh	r8,r11[0x0]
800045cc:	e2 18 f0 00 	andl	r8,0xf000,COH
800045d0:	e0 48 80 00 	cp.w	r8,32768
800045d4:	c0 f0       	breq	800045f2 <xcmp_exec_func+0x2a>
800045d6:	e0 48 b0 00 	cp.w	r8,45056
800045da:	c1 20       	breq	800045fe <xcmp_exec_func+0x36>
800045dc:	58 08       	cp.w	r8,0
800045de:	c1 51       	brne	80004608 <xcmp_exec_func+0x40>
	{
		case XCMP_REQUEST:
			if(NULL != exec->xcmp_rx_req)
800045e0:	78 08       	ld.w	r8,r12[0x0]
800045e2:	58 08       	cp.w	r8,0
800045e4:	c0 40       	breq	800045ec <xcmp_exec_func+0x24>
			{
				exec->xcmp_rx_req(xcmp);
800045e6:	16 9c       	mov	r12,r11
800045e8:	5d 18       	icall	r8
800045ea:	d8 02       	popm	pc
			}
			else 
			{
				/*No function to register the request message*/
				/*send not supported opcode to raido */
				xcmp_opcode_not_supported();
800045ec:	f0 1f 00 08 	mcall	8000460c <xcmp_exec_func+0x44>
800045f0:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_REPLY:		
			if(NULL != exec->xcmp_rx_reply)
800045f2:	78 18       	ld.w	r8,r12[0x4]
800045f4:	58 08       	cp.w	r8,0
800045f6:	c0 90       	breq	80004608 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_reply(xcmp);
800045f8:	16 9c       	mov	r12,r11
800045fa:	5d 18       	icall	r8
800045fc:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_BRDCAST:	
			if(NULL != exec->xcmp_rx_brdcst)
800045fe:	78 28       	ld.w	r8,r12[0x8]
80004600:	58 08       	cp.w	r8,0
80004602:	c0 30       	breq	80004608 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_brdcst(xcmp);
80004604:	16 9c       	mov	r12,r11
80004606:	5d 18       	icall	r8
80004608:	d8 02       	popm	pc
8000460a:	00 00       	add	r0,r0
8000460c:	80 00       	ld.sh	r0,r0[0x0]
8000460e:	45 a4       	lddsp	r4,sp[0x168]

80004610 <xcmp_IdleTestTone>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_IdleTestTone(void)
{
80004610:	d4 01       	pushm	lr
80004612:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | TONE_CONTROL;
80004616:	e0 68 04 09 	mov	r8,1033
8000461a:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	ToneControl_req_t * ptr = (ToneControl_req_t *)xcmp_farme.u8;
8000461c:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*Starts the specific tone*/	
	ptr->Function = Tone_Start;
80004620:	30 19       	mov	r9,1
80004622:	b0 89       	st.b	r8[0x0],r9
	
	/*This tone shall be sounded when radio landed on a priority channel*/
	ptr->ToneIdentifier[0] = (Priority_Beep >> 8) & 0xFF;
80004624:	30 09       	mov	r9,0
80004626:	b0 99       	st.b	r8[0x1],r9
	ptr->ToneIdentifier[1] = Priority_Beep & 0xFF;
80004628:	30 ca       	mov	r10,12
8000462a:	b0 aa       	st.b	r8[0x2],r10
	
	/*
	The alert tone is played according to any rules for alert tones, given the 
	current volume setting. Settings for this field are 8 to 255 (0x08 ?0xFF).
	*/
	ptr->ToneVolumeControl = Current_Volume;
8000462c:	b0 b9       	st.b	r8[0x3],r9
	
	/*clear reserved*/
	memset(ptr->Reserved, 0, 8);
8000462e:	fb 69 00 08 	st.b	sp[8],r9
80004632:	fa c8 ff f7 	sub	r8,sp,-9
80004636:	b0 89       	st.b	r8[0x0],r9
80004638:	fa c8 ff f6 	sub	r8,sp,-10
8000463c:	b0 89       	st.b	r8[0x0],r9
8000463e:	fa c8 ff f5 	sub	r8,sp,-11
80004642:	b0 89       	st.b	r8[0x0],r9
80004644:	fa c8 ff f4 	sub	r8,sp,-12
80004648:	b0 89       	st.b	r8[0x0],r9
8000464a:	fa c8 ff f3 	sub	r8,sp,-13
8000464e:	b0 89       	st.b	r8[0x0],r9
80004650:	fa c8 ff f2 	sub	r8,sp,-14
80004654:	b0 89       	st.b	r8[0x0],r9
80004656:	fa c8 ff f1 	sub	r8,sp,-15
8000465a:	b0 89       	st.b	r8[0x0],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(ToneControl_req_t));
8000465c:	30 cb       	mov	r11,12
8000465e:	fa cc ff fe 	sub	r12,sp,-2
80004662:	f0 1f 00 03 	mcall	8000466c <xcmp_IdleTestTone+0x5c>
}
80004666:	2c dd       	sub	sp,-204
80004668:	d8 02       	popm	pc
8000466a:	00 00       	add	r0,r0
8000466c:	80 00       	ld.sh	r0,r0[0x0]
8000466e:	45 1c       	lddsp	r12,sp[0x144]

80004670 <xcmp_init>:
	xQueueCreate -- freertos
	xTaskCreate -- freertos
Called By: main -- main.c
*/
void xcmp_init(void)
{
80004670:	d4 01       	pushm	lr
	/*initialize the xnl*/
	//xnl_init();
	
	/*register the xcmp function(callback function)*/
	xnl_register_xcmp_func( xcmp_rx );
80004672:	48 dc       	lddpc	r12,800046a4 <xcmp_init+0x34>
80004674:	f0 1f 00 0d 	mcall	800046a8 <xcmp_init+0x38>
	
	/*initialize the queue*/
	//xcmp_frame_rx = xQueueCreate(10, sizeof(xcmp_fragment_t *));
	
	xcmp_frame_rx = xQueueCreate(20, sizeof(xcmp_fragment_t *));
80004678:	30 4b       	mov	r11,4
8000467a:	31 4c       	mov	r12,20
8000467c:	f0 1f 00 0c 	mcall	800046ac <xcmp_init+0x3c>
80004680:	48 c8       	lddpc	r8,800046b0 <xcmp_init+0x40>
80004682:	91 0c       	st.w	r8[0x0],r12
	/*create task*/	
	/*this task is used to execute xcmp message*/
	xTaskCreate(
80004684:	30 09       	mov	r9,0
80004686:	1a d9       	st.w	--sp,r9
80004688:	1a d9       	st.w	--sp,r9
8000468a:	1a d9       	st.w	--sp,r9
8000468c:	30 28       	mov	r8,2
8000468e:	e0 6a 01 80 	mov	r10,384
80004692:	48 9b       	lddpc	r11,800046b4 <xcmp_init+0x44>
80004694:	48 9c       	lddpc	r12,800046b8 <xcmp_init+0x48>
80004696:	f0 1f 00 0a 	mcall	800046bc <xcmp_init+0x4c>
	,  tskXCMP_PRIORITY
	,  NULL
	);
	
	
	xnl_init();
8000469a:	f0 1f 00 0a 	mcall	800046c0 <xcmp_init+0x50>
8000469e:	2f dd       	sub	sp,-12
	
}
800046a0:	d8 02       	popm	pc
800046a2:	00 00       	add	r0,r0
800046a4:	80 00       	ld.sh	r0,r0[0x0]
800046a6:	47 c0       	lddsp	r0,sp[0x1f0]
800046a8:	80 00       	ld.sh	r0,r0[0x0]
800046aa:	48 0c       	lddpc	r12,800046a8 <xcmp_init+0x38>
800046ac:	80 00       	ld.sh	r0,r0[0x0]
800046ae:	5d 3c       	musfr	r12
800046b0:	00 00       	add	r0,r0
800046b2:	0a f8       	st.b	--r5,r8
800046b4:	80 01       	ld.sh	r1,r0[0x0]
800046b6:	57 34       	stdsp	sp[0x1cc],r4
800046b8:	80 00       	ld.sh	r0,r0[0x0]
800046ba:	46 c4       	lddsp	r4,sp[0x1b0]
800046bc:	80 00       	ld.sh	r0,r0[0x0]
800046be:	64 10       	ld.w	r0,r2[0x4]
800046c0:	80 00       	ld.sh	r0,r0[0x0]
800046c2:	4a 50       	lddpc	r0,80004754 <xcmp_rx_process+0x90>

800046c4 <xcmp_rx_process>:
Calls: xQueueReceive -- freerots
	xcmp_exec_func
Called By: task
*/
static void xcmp_rx_process(void * pvParameters)
{
800046c4:	d4 31       	pushm	r0-r7,lr
800046c6:	20 1d       	sub	sp,4
	xcmp_fragment_t xcmp;
	xcmp_fragment_t * ptr;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
800046c8:	4b 16       	lddpc	r6,8000478c <xcmp_rx_process+0xc8>
800046ca:	30 05       	mov	r5,0
800046cc:	31 44       	mov	r4,20
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
800046ce:	4b 13       	lddpc	r3,80004790 <xcmp_rx_process+0xcc>
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
					break;
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
800046d0:	4b 12       	lddpc	r2,80004794 <xcmp_rx_process+0xd0>
						, ptr);
					break;
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
800046d2:	4b 21       	lddpc	r1,80004798 <xcmp_rx_process+0xd4>
					break;
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
800046d4:	4b 20       	lddpc	r0,8000479c <xcmp_rx_process+0xd8>
	xcmp_fragment_t xcmp;
	xcmp_fragment_t * ptr;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
800046d6:	6c 0c       	ld.w	r12,r6[0x0]
800046d8:	0a 99       	mov	r9,r5
800046da:	08 9a       	mov	r10,r4
800046dc:	1a 9b       	mov	r11,sp
800046de:	f0 1f 00 31 	mcall	800047a0 <xcmp_rx_process+0xdc>
800046e2:	58 1c       	cp.w	r12,1
800046e4:	cf 91       	brne	800046d6 <xcmp_rx_process+0x12>
		{									
			if(NULL == ptr)
800046e6:	40 0b       	lddsp	r11,sp[0x0]
800046e8:	58 0b       	cp.w	r11,0
800046ea:	cf 60       	breq	800046d6 <xcmp_rx_process+0x12>
				continue;
			}
			
			//log("\n\r R_xcmp : %4x \n\r",ptr->xcmp_opcode);//log:R_xcmp指令	
						
			switch(ptr->xcmp_opcode & 0x0FFF)
800046ec:	96 0a       	ld.sh	r10,r11[0x0]
800046ee:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
800046f2:	f1 d9 c0 0c 	bfextu	r8,r9,0x0,0xc
800046f6:	59 c8       	cp.w	r8,28
800046f8:	c1 e0       	breq	80004734 <xcmp_rx_process+0x70>
800046fa:	e0 89 00 07 	brgt	80004708 <xcmp_rx_process+0x44>
800046fe:	58 e8       	cp.w	r8,14
80004700:	c0 e0       	breq	8000471c <xcmp_rx_process+0x58>
80004702:	58 f8       	cp.w	r8,15
80004704:	c2 41       	brne	8000474c <xcmp_rx_process+0x88>
80004706:	c0 f8       	rjmp	80004724 <xcmp_rx_process+0x60>
80004708:	e0 48 01 09 	cp.w	r8,265
8000470c:	c1 80       	breq	8000473c <xcmp_rx_process+0x78>
8000470e:	e0 48 01 0a 	cp.w	r8,266
80004712:	c1 90       	breq	80004744 <xcmp_rx_process+0x80>
80004714:	e0 48 00 2c 	cp.w	r8,44
80004718:	c1 a1       	brne	8000474c <xcmp_rx_process+0x88>
8000471a:	c0 98       	rjmp	8000472c <xcmp_rx_process+0x68>
			{
				case RADIO_STATUS:				
					xcmp_exec_func(&radio_status, ptr);
8000471c:	4a 2c       	lddpc	r12,800047a4 <xcmp_rx_process+0xe0>
8000471e:	f0 1f 00 23 	mcall	800047a8 <xcmp_rx_process+0xe4>
					break;
80004722:	c2 f8       	rjmp	80004780 <xcmp_rx_process+0xbc>
					
				case VERSION_INFORMATION:
					xcmp_exec_func(&version_information, ptr);
80004724:	4a 2c       	lddpc	r12,800047ac <xcmp_rx_process+0xe8>
80004726:	f0 1f 00 21 	mcall	800047a8 <xcmp_rx_process+0xe4>
					break;
8000472a:	c2 b8       	rjmp	80004780 <xcmp_rx_process+0xbc>
					
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
8000472c:	4a 1c       	lddpc	r12,800047b0 <xcmp_rx_process+0xec>
8000472e:	f0 1f 00 1f 	mcall	800047a8 <xcmp_rx_process+0xe4>
					break;
80004732:	c2 78       	rjmp	80004780 <xcmp_rx_process+0xbc>
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
80004734:	04 9c       	mov	r12,r2
80004736:	f0 1f 00 1d 	mcall	800047a8 <xcmp_rx_process+0xe4>
						, ptr);
					break;
8000473a:	c2 38       	rjmp	80004780 <xcmp_rx_process+0xbc>
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
8000473c:	02 9c       	mov	r12,r1
8000473e:	f0 1f 00 1b 	mcall	800047a8 <xcmp_rx_process+0xe4>
					break;
80004742:	c1 f8       	rjmp	80004780 <xcmp_rx_process+0xbc>
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
80004744:	00 9c       	mov	r12,r0
80004746:	f0 1f 00 19 	mcall	800047a8 <xcmp_rx_process+0xe4>
					break;
8000474a:	c1 b8       	rjmp	80004780 <xcmp_rx_process+0xbc>
					
				default:
				
					/*the xcmp message not in order list*/
					/*over the length of the list*/
					if((0x0400 != (ptr->xcmp_opcode & 0x0400)) 
8000474c:	12 98       	mov	r8,r9
8000474e:	e2 18 04 00 	andl	r8,0x400,COH
80004752:	c0 70       	breq	80004760 <xcmp_rx_process+0x9c>
80004754:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
80004758:	e0 48 00 68 	cp.w	r8,104
8000475c:	e0 8a 00 08 	brle	8000476c <xcmp_rx_process+0xa8>
						|| (MAX_APP_FUNC <= (ptr->xcmp_opcode & 0x00FF))
					)
					{
						/*xcmp request*/
						if( XCMP_REQUEST == (ptr->xcmp_opcode & 0xF000))
80004760:	e2 19 f0 00 	andl	r9,0xf000,COH
80004764:	c0 e1       	brne	80004780 <xcmp_rx_process+0xbc>
						{
							/*send not supported opcode to raido */
							xcmp_opcode_not_supported();
80004766:	f0 1f 00 14 	mcall	800047b4 <xcmp_rx_process+0xf0>
8000476a:	c0 b8       	rjmp	80004780 <xcmp_rx_process+0xbc>
						}
					}
					else
					{					
						xcmp_exec_func( &app_list[ptr->xcmp_opcode & 0x00FF]
8000476c:	f9 da c0 08 	bfextu	r12,r10,0x0,0x8
80004770:	f8 0c 00 1c 	add	r12,r12,r12<<0x1
80004774:	49 19       	lddpc	r9,800047b8 <xcmp_rx_process+0xf4>
80004776:	72 08       	ld.w	r8,r9[0x0]
80004778:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
8000477c:	f0 1f 00 0b 	mcall	800047a8 <xcmp_rx_process+0xe4>
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
80004780:	66 0c       	ld.w	r12,r3[0x0]
80004782:	40 0b       	lddsp	r11,sp[0x0]
80004784:	f0 1f 00 0e 	mcall	800047bc <xcmp_rx_process+0xf8>
80004788:	ca 7b       	rjmp	800046d6 <xcmp_rx_process+0x12>
8000478a:	00 00       	add	r0,r0
8000478c:	00 00       	add	r0,r0
8000478e:	0a f8       	st.b	--r5,r8
80004790:	00 00       	add	r0,r0
80004792:	0a 9c       	mov	r12,r5
80004794:	00 00       	add	r0,r0
80004796:	0b 08       	ld.w	r8,r5++
80004798:	00 00       	add	r0,r0
8000479a:	0a fc       	st.b	--r5,r12
8000479c:	00 00       	add	r0,r0
8000479e:	0b 14       	ld.sh	r4,r5++
800047a0:	80 00       	ld.sh	r0,r0[0x0]
800047a2:	5a 30       	cp.w	r0,-29
800047a4:	00 00       	add	r0,r0
800047a6:	0b 2c       	ld.uh	r12,r5++
800047a8:	80 00       	ld.sh	r0,r0[0x0]
800047aa:	45 c8       	lddsp	r8,sp[0x170]
800047ac:	00 00       	add	r0,r0
800047ae:	0a ec       	st.h	--r5,r12
800047b0:	00 00       	add	r0,r0
800047b2:	0b 20       	ld.uh	r0,r5++
800047b4:	80 00       	ld.sh	r0,r0[0x0]
800047b6:	45 a4       	lddsp	r4,sp[0x168]
800047b8:	00 00       	add	r0,r0
800047ba:	52 d4       	stdsp	sp[0xb4],r4
800047bc:	80 00       	ld.sh	r0,r0[0x0]
800047be:	31 cc       	mov	r12,28

800047c0 <xcmp_rx>:
Calls:   
	xQueueSend -- xnl.c
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
800047c0:	eb cd 40 90 	pushm	r4,r7,lr
800047c4:	20 1d       	sub	sp,4
800047c6:	fa c4 ff f0 	sub	r4,sp,-16
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
800047ca:	48 c8       	lddpc	r8,800047f8 <xcmp_rx+0x38>
800047cc:	70 0c       	ld.w	r12,r8[0x0]
800047ce:	f0 1f 00 0c 	mcall	800047fc <xcmp_rx+0x3c>
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
800047d2:	c1 00       	breq	800047f2 <xcmp_rx+0x32>
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
800047d4:	fa c7 ff fc 	sub	r7,sp,-4
800047d8:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
	{
		memcpy(xcmp_ptr, &xcmp, sizeof(xcmp_fragment_t));				
800047da:	e0 6a 00 ca 	mov	r10,202
800047de:	08 9b       	mov	r11,r4
800047e0:	f0 1f 00 08 	mcall	80004800 <xcmp_rx+0x40>
		xQueueSend(xcmp_frame_rx, &xcmp_ptr, 0);	
800047e4:	48 88       	lddpc	r8,80004804 <xcmp_rx+0x44>
800047e6:	70 0c       	ld.w	r12,r8[0x0]
800047e8:	30 09       	mov	r9,0
800047ea:	12 9a       	mov	r10,r9
800047ec:	1a 9b       	mov	r11,sp
800047ee:	f0 1f 00 07 	mcall	80004808 <xcmp_rx+0x48>
	}	
}
800047f2:	2f fd       	sub	sp,-4
800047f4:	e3 cd 80 90 	ldm	sp++,r4,r7,pc
800047f8:	00 00       	add	r0,r0
800047fa:	0a 9c       	mov	r12,r5
800047fc:	80 00       	ld.sh	r0,r0[0x0]
800047fe:	38 2c       	mov	r12,-126
80004800:	80 00       	ld.sh	r0,r0[0x0]
80004802:	71 8e       	ld.w	lr,r8[0x60]
80004804:	00 00       	add	r0,r0
80004806:	0a f8       	st.b	--r5,r8
80004808:	80 00       	ld.sh	r0,r0[0x0]
8000480a:	5c 3c       	neg	r12

8000480c <xnl_register_xcmp_func>:
Function: xnl_register_xcmp_func
Description: register the xcmp function(callback function)
*/
void xnl_register_xcmp_func( void ( *func)(xnl_content_data_msg_t))
{
	 xcmp_exec = func;
8000480c:	48 28       	lddpc	r8,80004814 <xnl_register_xcmp_func+0x8>
8000480e:	91 0c       	st.w	r8[0x0],r12
}
80004810:	5e fc       	retal	r12
80004812:	00 00       	add	r0,r0
80004814:	00 00       	add	r0,r0
80004816:	0b 5c       	ld.sh	r12,--r5

80004818 <xnl_get_msg_ack_func>:
Description: process while receive msg ack.
Calls:xSemaphoreGive--freertos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
80004818:	d4 01       	pushm	lr
	
	DestinationAddress = xnl->xnl_header.destination;
	/*No timeout*/		
	 //One relationship is controlled by a state machine, only the current MSG received the ACK, 
	//then the program will clear the current MSG sending address and out of standby and will jump to the sending state.
	if (DestinationAddress == xnl_information.device_address )
8000481a:	48 88       	lddpc	r8,80004838 <xnl_get_msg_ack_func+0x20>
8000481c:	90 28       	ld.sh	r8,r8[0x4]
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
	U16 DestinationAddress;
	U16 TransactionID;
	
	DestinationAddress = xnl->xnl_header.destination;
8000481e:	98 49       	ld.sh	r9,r12[0x8]
80004820:	f0 09 19 00 	cp.h	r9,r8
80004824:	c0 81       	brne	80004834 <xnl_get_msg_ack_func+0x1c>
	if (DestinationAddress == xnl_information.device_address )
	{
		//The ack is for me.
		
		TransactionID = xnl->xnl_header.transaction_id;
		xSemaphoreGive(xnl_timeout_semphr);	
80004826:	48 68       	lddpc	r8,8000483c <xnl_get_msg_ack_func+0x24>
80004828:	70 0c       	ld.w	r12,r8[0x0]
8000482a:	30 09       	mov	r9,0
8000482c:	12 9a       	mov	r10,r9
8000482e:	12 9b       	mov	r11,r9
80004830:	f0 1f 00 04 	mcall	80004840 <xnl_get_msg_ack_func+0x28>
80004834:	d8 02       	popm	pc
80004836:	00 00       	add	r0,r0
80004838:	00 00       	add	r0,r0
8000483a:	0b 3c       	ld.ub	r12,r5++
8000483c:	00 00       	add	r0,r0
8000483e:	0b 38       	ld.ub	r8,r5++
80004840:	80 00       	ld.sh	r0,r0[0x0]
80004842:	5c 3c       	neg	r12

80004844 <xnl_tx_process>:
	xSemaphoreTake--freertos 
	phy_tx -- physical.c
Called By: task
*/
static void xnl_tx_process(void * pvParameters)
{
80004844:	d4 31       	pushm	r0-r7,lr
	static  xnl_fragment_t * ptr;//是否可以修缮为静态变量？请关注
	
	
	for(;;)
	{		
		switch(xnl_tx_state)
80004846:	4a 86       	lddpc	r6,800048e4 <xnl_tx_process+0xa0>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
80004848:	4a 82       	lddpc	r2,800048e8 <xnl_tx_process+0xa4>
8000484a:	4a 94       	lddpc	r4,800048ec <xnl_tx_process+0xa8>
8000484c:	30 07       	mov	r7,0
8000484e:	3f f1       	mov	r1,-1
					if(NULL == ptr)
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
80004850:	30 00       	mov	r0,0
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;
80004852:	4a 85       	lddpc	r5,800048f0 <xnl_tx_process+0xac>
					
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
80004854:	4a 83       	lddpc	r3,800048f4 <xnl_tx_process+0xb0>
	static  xnl_fragment_t * ptr;//是否可以修缮为静态变量？请关注
	
	
	for(;;)
	{		
		switch(xnl_tx_state)
80004856:	6c 08       	ld.w	r8,r6[0x0]
80004858:	58 08       	cp.w	r8,0
8000485a:	c0 40       	breq	80004862 <xnl_tx_process+0x1e>
8000485c:	58 18       	cp.w	r8,1
8000485e:	cf d1       	brne	80004858 <xnl_tx_process+0x14>
80004860:	c2 08       	rjmp	800048a0 <xnl_tx_process+0x5c>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
80004862:	64 0c       	ld.w	r12,r2[0x0]
80004864:	0e 99       	mov	r9,r7
80004866:	02 9a       	mov	r10,r1
80004868:	08 9b       	mov	r11,r4
8000486a:	f0 1f 00 24 	mcall	800048f8 <xnl_tx_process+0xb4>
8000486e:	58 1c       	cp.w	r12,1
80004870:	cf 31       	brne	80004856 <xnl_tx_process+0x12>
					, portMAX_DELAY ))
				{				
					if(NULL == ptr)
80004872:	68 0c       	ld.w	r12,r4[0x0]
80004874:	58 0c       	cp.w	r12,0
80004876:	cf 00       	breq	80004856 <xnl_tx_process+0x12>
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
80004878:	98 28       	ld.sh	r8,r12[0x4]
8000487a:	e0 08 19 00 	cp.h	r8,r0
8000487e:	c0 41       	brne	80004886 <xnl_tx_process+0x42>
					{
						/*invalid XNL opcode*/
						vPortFree(ptr);
80004880:	f0 1f 00 1f 	mcall	800048fc <xnl_tx_process+0xb8>
						break;
80004884:	ce 9b       	rjmp	80004856 <xnl_tx_process+0x12>
					}
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
80004886:	f0 1f 00 1f 	mcall	80004900 <xnl_tx_process+0xbc>
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;
8000488a:	30 18       	mov	r8,1
8000488c:	8b 08       	st.w	r5[0x0],r8
					
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
8000488e:	66 0c       	ld.w	r12,r3[0x0]
80004890:	0e 99       	mov	r9,r7
80004892:	0e 9a       	mov	r10,r7
80004894:	0e 9b       	mov	r11,r7
80004896:	f0 1f 00 19 	mcall	800048f8 <xnl_tx_process+0xb4>
					xnl_tx_state = WAITING_FOR_REPLY;
8000489a:	30 18       	mov	r8,1
8000489c:	8d 08       	st.w	r6[0x0],r8
8000489e:	cd cb       	rjmp	80004856 <xnl_tx_process+0x12>
				}
				break;
			
			/*wait XNL reply*/			
			case WAITING_FOR_REPLY://直到回答ACK才再发送下一条data/control
				if(pdTRUE == xSemaphoreTake( xnl_timeout_semphr
800048a0:	66 0c       	ld.w	r12,r3[0x0]
800048a2:	0e 99       	mov	r9,r7
800048a4:	36 4a       	mov	r10,100
800048a6:	0e 9b       	mov	r11,r7
800048a8:	f0 1f 00 14 	mcall	800048f8 <xnl_tx_process+0xb4>
800048ac:	58 1c       	cp.w	r12,1
800048ae:	c0 81       	brne	800048be <xnl_tx_process+0x7a>
					, ( portTickType )50*2/ portTICK_RATE_MS))//按ADK文档中提示500ms一次超时,但是实际情况下程序中启用freertos的任务延时不够精准。因此根据经验需要降低延时等待的时间
				{
					/*No timeout*/
					//vPortFree(ptr);	
					set_xnl_idle(ptr);			
800048b0:	49 58       	lddpc	r8,80004904 <xnl_tx_process+0xc0>
800048b2:	70 0c       	ld.w	r12,r8[0x0]
800048b4:	68 0b       	ld.w	r11,r4[0x0]
800048b6:	f0 1f 00 15 	mcall	80004908 <xnl_tx_process+0xc4>
					xnl_tx_state = WAITING_FOR_TX;
800048ba:	8d 07       	st.w	r6[0x0],r7
800048bc:	cc db       	rjmp	80004856 <xnl_tx_process+0x12>
				}
				else
				{
					/*time out*/
					if(xnl_send_times <= MIN_RESEND_TIMES)
800048be:	6a 08       	ld.w	r8,r5[0x0]
800048c0:	58 38       	cp.w	r8,3
800048c2:	e0 89 00 09 	brgt	800048d4 <xnl_tx_process+0x90>
					{
						/*If times smaller than A supermarket, then resend the 
						instructions*/
						phy_tx((phy_fragment_t *)ptr);
800048c6:	68 0c       	ld.w	r12,r4[0x0]
800048c8:	f0 1f 00 0e 	mcall	80004900 <xnl_tx_process+0xbc>
						xnl_send_times++;
800048cc:	6a 08       	ld.w	r8,r5[0x0]
800048ce:	2f f8       	sub	r8,-1
800048d0:	8b 08       	st.w	r5[0x0],r8
800048d2:	cc 2b       	rjmp	80004856 <xnl_tx_process+0x12>
					}
					else
					{
						//can not send data, disconnected						
						//vPortFree(ptr);	
						set_xnl_idle(ptr);									
800048d4:	48 c8       	lddpc	r8,80004904 <xnl_tx_process+0xc0>
800048d6:	70 0c       	ld.w	r12,r8[0x0]
800048d8:	68 0b       	ld.w	r11,r4[0x0]
800048da:	f0 1f 00 0c 	mcall	80004908 <xnl_tx_process+0xc4>
						xnl_tx_state = WAITING_FOR_TX;
800048de:	8d 07       	st.w	r6[0x0],r7
800048e0:	cb bb       	rjmp	80004856 <xnl_tx_process+0x12>
800048e2:	00 00       	add	r0,r0
800048e4:	00 00       	add	r0,r0
800048e6:	0b 50       	ld.sh	r0,--r5
800048e8:	00 00       	add	r0,r0
800048ea:	0b 4c       	ld.w	r12,--r5
800048ec:	00 00       	add	r0,r0
800048ee:	0b 48       	ld.w	r8,--r5
800048f0:	00 00       	add	r0,r0
800048f2:	0b 54       	ld.sh	r4,--r5
800048f4:	00 00       	add	r0,r0
800048f6:	0b 38       	ld.ub	r8,r5++
800048f8:	80 00       	ld.sh	r0,r0[0x0]
800048fa:	5a 30       	cp.w	r0,-29
800048fc:	80 00       	ld.sh	r0,r0[0x0]
800048fe:	58 c0       	cp.w	r0,12
80004900:	80 00       	ld.sh	r0,r0[0x0]
80004902:	31 ec       	mov	r12,30
80004904:	00 00       	add	r0,r0
80004906:	0a 9c       	mov	r12,r5
80004908:	80 00       	ld.sh	r0,r0[0x0]
8000490a:	31 cc       	mov	r12,28

8000490c <xnl_rx_process>:
Description: Receive the XNL
Calls: 
Called By:task
*/
static void xnl_rx_process(void * pvParameters)
{
8000490c:	eb cd 40 fe 	pushm	r1-r7,lr
80004910:	20 1d       	sub	sp,4
	/*To ptr the elements in the queue*/
	xnl_fragment_t * xnl_ptr;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
80004912:	49 26       	lddpc	r6,80004958 <xnl_rx_process+0x4c>
80004914:	30 05       	mov	r5,0
80004916:	3f f4       	mov	r4,-1
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
80004918:	30 c3       	mov	r3,12
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
8000491a:	49 11       	lddpc	r1,8000495c <xnl_rx_process+0x50>
	if(xnl->xnl_header.opcode > 0x0C)	
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
8000491c:	49 12       	lddpc	r2,80004960 <xnl_rx_process+0x54>
	/*To ptr the elements in the queue*/
	xnl_fragment_t * xnl_ptr;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
8000491e:	6c 0c       	ld.w	r12,r6[0x0]
80004920:	0a 99       	mov	r9,r5
80004922:	08 9a       	mov	r10,r4
80004924:	1a 9b       	mov	r11,sp
80004926:	f0 1f 00 10 	mcall	80004964 <xnl_rx_process+0x58>
8000492a:	58 1c       	cp.w	r12,1
8000492c:	cf 91       	brne	8000491e <xnl_rx_process+0x12>
		, portMAX_DELAY ))
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
8000492e:	40 0c       	lddsp	r12,sp[0x0]
80004930:	58 0c       	cp.w	r12,0
80004932:	cf 60       	breq	8000491e <xnl_rx_process+0x12>
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
80004934:	98 28       	ld.sh	r8,r12[0x4]
80004936:	e6 08 19 00 	cp.h	r8,r3
8000493a:	e0 8b 00 0a 	brhi	8000494e <xnl_rx_process+0x42>
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
8000493e:	5c 78       	castu.h	r8
80004940:	e4 08 03 29 	ld.w	r9,r2[r8<<0x2]
80004944:	58 09       	cp.w	r9,0
80004946:	c0 40       	breq	8000494e <xnl_rx_process+0x42>
	{
		//log("\n\r R_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:R_xnl指令
		/*execute the function in list*/
		xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec(xnl);
80004948:	e4 08 03 28 	ld.w	r8,r2[r8<<0x2]
8000494c:	5d 18       	icall	r8
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
8000494e:	62 0c       	ld.w	r12,r1[0x0]
80004950:	40 0b       	lddsp	r11,sp[0x0]
80004952:	f0 1f 00 06 	mcall	80004968 <xnl_rx_process+0x5c>
80004956:	ce 4b       	rjmp	8000491e <xnl_rx_process+0x12>
80004958:	00 00       	add	r0,r0
8000495a:	0a b8       	st.h	r5++,r8
8000495c:	00 00       	add	r0,r0
8000495e:	0a 9c       	mov	r12,r5
80004960:	00 00       	add	r0,r0
80004962:	05 00       	ld.w	r0,r2++
80004964:	80 00       	ld.sh	r0,r0[0x0]
80004966:	5a 30       	cp.w	r0,-29
80004968:	80 00       	ld.sh	r0,r0[0x0]
8000496a:	31 cc       	mov	r12,28

8000496c <xnl_tx>:
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
{
8000496c:	eb cd 40 c0 	pushm	r6-r7,lr
80004970:	20 1d       	sub	sp,4
80004972:	18 96       	mov	r6,r12
	message that is sent. The same value should be used for all retries.
	*/
	static U8 flags = 0;
	
	/*If the value is DEFAULT_VALUE, the value will be modified*/
	if(DEFAULT_VALUE == xnl->xnl_header.flags)
80004974:	98 39       	ld.sh	r9,r12[0x6]
80004976:	3f f8       	mov	r8,-1
80004978:	f0 09 19 00 	cp.h	r9,r8
8000497c:	c0 a1       	brne	80004990 <xnl_tx+0x24>
	{
		xnl->xnl_header.flags =  0x0100 | ((++flags) & 0x07);
8000497e:	4a e9       	lddpc	r9,80004a34 <xnl_tx+0xc8>
80004980:	13 88       	ld.ub	r8,r9[0x0]
80004982:	2f f8       	sub	r8,-1
80004984:	5c 58       	castu.b	r8
80004986:	b2 88       	st.b	r9[0x0],r8
80004988:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
8000498c:	a9 a8       	sbr	r8,0x8
8000498e:	b8 38       	st.h	r12[0x6],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.destination)
80004990:	8c 49       	ld.sh	r9,r6[0x8]
80004992:	3f f8       	mov	r8,-1
80004994:	f0 09 19 00 	cp.h	r9,r8
80004998:	c0 41       	brne	800049a0 <xnl_tx+0x34>
	{		
		/*Use actual Master address.*/
		xnl->xnl_header.destination = xnl_information.master_address;
8000499a:	4a 88       	lddpc	r8,80004a38 <xnl_tx+0xcc>
8000499c:	90 18       	ld.sh	r8,r8[0x2]
8000499e:	ac 48       	st.h	r6[0x8],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.source)
800049a0:	8c 59       	ld.sh	r9,r6[0xa]
800049a2:	3f f8       	mov	r8,-1
800049a4:	f0 09 19 00 	cp.h	r9,r8
800049a8:	c0 41       	brne	800049b0 <xnl_tx+0x44>
	{
		/*Use Temporary address.*/	
		xnl->xnl_header.source = xnl_information.device_address;
800049aa:	4a 48       	lddpc	r8,80004a38 <xnl_tx+0xcc>
800049ac:	90 28       	ld.sh	r8,r8[0x4]
800049ae:	ac 58       	st.h	r6[0xa],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
800049b0:	8c 69       	ld.sh	r9,r6[0xc]
800049b2:	3f f8       	mov	r8,-1
800049b4:	f0 09 19 00 	cp.h	r9,r8
800049b8:	c0 e1       	brne	800049d4 <xnl_tx+0x68>
	{		
		xnl->xnl_header.transaction_id = 
		  ((++xnl_information.transaction_id) & 0xFF) 
800049ba:	4a 08       	lddpc	r8,80004a38 <xnl_tx+0xcc>
800049bc:	90 49       	ld.sh	r9,r8[0x8]
800049be:	2f f9       	sub	r9,-1
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
800049c0:	b0 49       	st.h	r8[0x8],r9
		  ((++xnl_information.transaction_id) & 0xFF) 
800049c2:	90 4a       	ld.sh	r10,r8[0x8]
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
800049c4:	90 49       	ld.sh	r9,r8[0x8]
800049c6:	e0 19 ff 00 	andl	r9,0xff00
800049ca:	f1 da c0 08 	bfextu	r8,r10,0x0,0x8
800049ce:	f3 e8 10 08 	or	r8,r9,r8
800049d2:	ac 68       	st.h	r6[0xc],r8
	U16  sumScratch;
	U32  indextohWord;
	S32  hWordswithinFrag;
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
800049d4:	0d 98       	ld.ub	r8,r6[0x1]
800049d6:	20 28       	sub	r8,2
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
800049d8:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
800049dc:	10 0c       	add	r12,r8
800049de:	a1 5c       	asr	r12,0x1
	indextohWord = 2;
	while (hWordswithinFrag > 0)
800049e0:	58 0c       	cp.w	r12,0
800049e2:	e0 89 00 04 	brgt	800049ea <xnl_tx+0x7e>
800049e6:	30 09       	mov	r9,0
800049e8:	c0 d8       	rjmp	80004a02 <xnl_tx+0x96>
800049ea:	ec ca ff fc 	sub	r10,r6,-4
Parameters: xnl_fragment_t * 
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
800049ee:	2f ec       	sub	r12,-2
800049f0:	30 09       	mov	r9,0
800049f2:	30 28       	mov	r8,2
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
	{
		sumScratch += *((U16*)xnl + indextohWord);
800049f4:	15 1b       	ld.sh	r11,r10++
800049f6:	f6 09 00 09 	add	r9,r11,r9
800049fa:	5c 89       	casts.h	r9
		indextohWord     += 1;
800049fc:	2f f8       	sub	r8,-1
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
800049fe:	18 38       	cp.w	r8,r12
80004a00:	cf a1       	brne	800049f4 <xnl_tx+0x88>
		  ((++xnl_information.transaction_id) & 0xFF) 
		| (xnl_information.transaction_id & 0xFF00);
	}
	
	/*count check sum */
	xnl->phy_header.check_sum = check_sum( xnl );
80004a02:	5c 39       	neg	r9
80004a04:	ac 19       	st.h	r6[0x2],r9
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
80004a06:	48 e8       	lddpc	r8,80004a3c <xnl_tx+0xd0>
80004a08:	70 0c       	ld.w	r12,r8[0x0]
80004a0a:	f0 1f 00 0e 	mcall	80004a40 <xnl_tx+0xd4>
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
80004a0e:	c1 00       	breq	80004a2e <xnl_tx+0xc2>
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
80004a10:	fa c7 ff fc 	sub	r7,sp,-4
80004a14:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
	{
		memcpy(ptr, xnl, sizeof(xnl_fragment_t));
80004a16:	e0 6a 01 00 	mov	r10,256
80004a1a:	0c 9b       	mov	r11,r6
80004a1c:	f0 1f 00 0a 	mcall	80004a44 <xnl_tx+0xd8>
	
		/*push to queue and send*/
		
		//log("ptr -%8x", ptr);
		
		xQueueSend(xnl_frame_tx, &ptr, 0);
80004a20:	48 a8       	lddpc	r8,80004a48 <xnl_tx+0xdc>
80004a22:	70 0c       	ld.w	r12,r8[0x0]
80004a24:	30 09       	mov	r9,0
80004a26:	12 9a       	mov	r10,r9
80004a28:	1a 9b       	mov	r11,sp
80004a2a:	f0 1f 00 09 	mcall	80004a4c <xnl_tx+0xe0>
		//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
		
		//vPortFree(ptr);
	}
}
80004a2e:	2f fd       	sub	sp,-4
80004a30:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004a34:	00 00       	add	r0,r0
80004a36:	0b 58       	ld.sh	r8,--r5
80004a38:	00 00       	add	r0,r0
80004a3a:	0b 3c       	ld.ub	r12,r5++
80004a3c:	00 00       	add	r0,r0
80004a3e:	0a 9c       	mov	r12,r5
80004a40:	80 00       	ld.sh	r0,r0[0x0]
80004a42:	38 2c       	mov	r12,-126
80004a44:	80 00       	ld.sh	r0,r0[0x0]
80004a46:	71 8e       	ld.w	lr,r8[0x60]
80004a48:	00 00       	add	r0,r0
80004a4a:	0b 4c       	ld.w	r12,--r5
80004a4c:	80 00       	ld.sh	r0,r0[0x0]
80004a4e:	5c 3c       	neg	r12

80004a50 <xnl_init>:
	xTaskCreate--freertos
	xnl_send_device_master_query
Called By:xcmp_init -- xcmp.c
*/
void xnl_init(void)
{
80004a50:	eb cd 40 80 	pushm	r7,lr
80004a54:	fa cd 01 00 	sub	sp,sp,256
	///*initialize the physical layer*/
	//phy_init();
	
	xnl_information.is_connected = FALSE;
80004a58:	30 09       	mov	r9,0
80004a5a:	4a 78       	lddpc	r8,80004af4 <xnl_init+0xa4>
80004a5c:	b0 89       	st.b	r8[0x0],r9

	/*initialize the semaphore and queue*/
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
80004a5e:	30 0b       	mov	r11,0
80004a60:	30 1c       	mov	r12,1
80004a62:	f0 1f 00 26 	mcall	80004af8 <xnl_init+0xa8>
80004a66:	4a 68       	lddpc	r8,80004afc <xnl_init+0xac>
80004a68:	91 0c       	st.w	r8[0x0],r12
80004a6a:	70 08       	ld.w	r8,r8[0x0]
80004a6c:	58 08       	cp.w	r8,0
80004a6e:	c0 80       	breq	80004a7e <xnl_init+0x2e>
80004a70:	4a 38       	lddpc	r8,80004afc <xnl_init+0xac>
80004a72:	70 0c       	ld.w	r12,r8[0x0]
80004a74:	30 09       	mov	r9,0
80004a76:	12 9a       	mov	r10,r9
80004a78:	12 9b       	mov	r11,r9
80004a7a:	f0 1f 00 22 	mcall	80004b00 <xnl_init+0xb0>
	//xnl_frame_tx = xQueueCreate(10, sizeof(xnl_fragment_t *)); 
	
	xnl_frame_tx = xQueueCreate(20, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
80004a7e:	30 4b       	mov	r11,4
80004a80:	31 4c       	mov	r12,20
80004a82:	f0 1f 00 1e 	mcall	80004af8 <xnl_init+0xa8>
80004a86:	4a 08       	lddpc	r8,80004b04 <xnl_init+0xb4>
80004a88:	91 0c       	st.w	r8[0x0],r12
		
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
80004a8a:	30 07       	mov	r7,0
80004a8c:	1a d7       	st.w	--sp,r7
80004a8e:	1a d7       	st.w	--sp,r7
80004a90:	1a d7       	st.w	--sp,r7
80004a92:	30 38       	mov	r8,3
80004a94:	0e 99       	mov	r9,r7
80004a96:	e0 6a 02 00 	mov	r10,512
80004a9a:	49 cb       	lddpc	r11,80004b08 <xnl_init+0xb8>
80004a9c:	49 cc       	lddpc	r12,80004b0c <xnl_init+0xbc>
80004a9e:	f0 1f 00 1d 	mcall	80004b10 <xnl_init+0xc0>
	,  tskXNL_PRIORITY //+ 1
	,  NULL
	);
	
	/*this task is used to send xnl message*/
	xTaskCreate(
80004aa2:	1a d7       	st.w	--sp,r7
80004aa4:	1a d7       	st.w	--sp,r7
80004aa6:	1a d7       	st.w	--sp,r7
80004aa8:	30 38       	mov	r8,3
80004aaa:	0e 99       	mov	r9,r7
80004aac:	e0 6a 03 20 	mov	r10,800
80004ab0:	49 9b       	lddpc	r11,80004b14 <xnl_init+0xc4>
80004ab2:	49 ac       	lddpc	r12,80004b18 <xnl_init+0xc8>
80004ab4:	f0 1f 00 17 	mcall	80004b10 <xnl_init+0xc0>
	,  NULL
	,  tskXNL_PRIORITY//+1
	,  NULL
	);
	
	phy_init();
80004ab8:	f0 1f 00 19 	mcall	80004b1c <xnl_init+0xcc>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80004abc:	e0 68 40 0e 	mov	r8,16398
80004ac0:	fb 58 00 18 	st.h	sp[24],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004ac4:	3f f8       	mov	r8,-1
80004ac6:	fb 58 00 1a 	st.h	sp[26],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_MASTER_QUERY;
80004aca:	30 38       	mov	r8,3
80004acc:	fb 58 00 1c 	st.h	sp[28],r8
	
	/*The initial value*/
	xnl_frame.xnl_header.flags = 0;
80004ad0:	fb 57 00 1e 	st.h	sp[30],r7
	
	/*XNL address of the master device, if known;otherwise 0x0000*/
	xnl_frame.xnl_header.destination = 0;
80004ad4:	fb 57 00 20 	st.h	sp[32],r7
	
	/*XNL address, if assigned; otherwise 0x0000*/
	xnl_frame.xnl_header.source = 0;
80004ad8:	fb 57 00 22 	st.h	sp[34],r7
	
	/*No transaction ID required for this message*/
	xnl_frame.xnl_header.transaction_id = 0;
80004adc:	fb 57 00 24 	st.h	sp[36],r7
	
	/*This message contains no payload*/
	xnl_frame.xnl_header.payload_length = 0;
80004ae0:	fb 57 00 26 	st.h	sp[38],r7

	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004ae4:	fa cc ff e8 	sub	r12,sp,-24
80004ae8:	f0 1f 00 0e 	mcall	80004b20 <xnl_init+0xd0>
80004aec:	2f ad       	sub	sp,-24
	);
	
	phy_init();
	/*send device_master_query to connect radio*/	
	xnl_send_device_master_query();
}
80004aee:	2c 0d       	sub	sp,-256
80004af0:	e3 cd 80 80 	ldm	sp++,r7,pc
80004af4:	00 00       	add	r0,r0
80004af6:	0b 3c       	ld.ub	r12,r5++
80004af8:	80 00       	ld.sh	r0,r0[0x0]
80004afa:	5d 3c       	musfr	r12
80004afc:	00 00       	add	r0,r0
80004afe:	0b 38       	ld.ub	r8,r5++
80004b00:	80 00       	ld.sh	r0,r0[0x0]
80004b02:	5c 3c       	neg	r12
80004b04:	00 00       	add	r0,r0
80004b06:	0b 4c       	ld.w	r12,--r5
80004b08:	80 01       	ld.sh	r1,r0[0x0]
80004b0a:	57 3c       	stdsp	sp[0x1cc],r12
80004b0c:	80 00       	ld.sh	r0,r0[0x0]
80004b0e:	49 0c       	lddpc	r12,80004b4c <xnl_data_msg_func+0x28>
80004b10:	80 00       	ld.sh	r0,r0[0x0]
80004b12:	64 10       	ld.w	r0,r2[0x4]
80004b14:	80 00       	ld.sh	r0,r0[0x0]
80004b16:	ca 00       	breq	80004a56 <xnl_init+0x6>
80004b18:	80 00       	ld.sh	r0,r0[0x0]
80004b1a:	48 44       	lddpc	r4,80004b28 <xnl_data_msg_func+0x4>
80004b1c:	80 00       	ld.sh	r0,r0[0x0]
80004b1e:	38 54       	mov	r4,-123
80004b20:	80 00       	ld.sh	r0,r0[0x0]
80004b22:	49 6c       	lddpc	r12,80004b78 <xnl_data_msg_func+0x54>

80004b24 <xnl_data_msg_func>:
Description: process while receive data message.
Calls:xnl_send_msg_ack, xcmp_exec(function in xcmp)
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_data_msg_func(xnl_fragment_t * xnl)
{
80004b24:	eb cd 40 80 	pushm	r7,lr
80004b28:	fa cd 01 00 	sub	sp,sp,256
80004b2c:	18 97       	mov	r7,r12
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80004b2e:	e0 68 40 0e 	mov	r8,16398
80004b32:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004b34:	3f f8       	mov	r8,-1
80004b36:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG_ACK;
80004b38:	30 c8       	mov	r8,12
80004b3a:	ba 28       	st.h	sp[0x4],r8
	
	/*Turn around Flags.*/	
	xnl_frame.xnl_header.flags = hdr->flags;
80004b3c:	98 38       	ld.sh	r8,r12[0x6]
80004b3e:	ba 38       	st.h	sp[0x6],r8
	
	/*ACK Destination Address is Source of XNL_Message.*/
	xnl_frame.xnl_header.destination = hdr->source;
80004b40:	98 58       	ld.sh	r8,r12[0xa]
80004b42:	ba 48       	st.h	sp[0x8],r8
	
	/*ACK Source Address is my address.*/
	xnl_frame.xnl_header.source = hdr->destination;
80004b44:	98 48       	ld.sh	r8,r12[0x8]
80004b46:	ba 58       	st.h	sp[0xa],r8
	
	/*Turn around Transaction ID.*/
	xnl_frame.xnl_header.transaction_id = hdr->transaction_id;
80004b48:	98 68       	ld.sh	r8,r12[0xc]
80004b4a:	ba 68       	st.h	sp[0xc],r8
	xnl_frame.xnl_header.payload_length = 0;
80004b4c:	30 08       	mov	r8,0
80004b4e:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004b50:	1a 9c       	mov	r12,sp
80004b52:	f0 1f 00 0a 	mcall	80004b78 <xnl_data_msg_func+0x54>
	transmitter, but possibly is waiting in Queue with immediate timeout.
	 */
	xnl_send_msg_ack(&xnl->xnl_header);
	
	/*exec xcmp function*/
	xcmp_exec(xnl->xnl_payload.xnl_content_data_msg);//xcmp_rx
80004b56:	fa cd 00 cc 	sub	sp,sp,204
80004b5a:	e0 6a 00 ca 	mov	r10,202
80004b5e:	ee cb ff f0 	sub	r11,r7,-16
80004b62:	1a 9c       	mov	r12,sp
80004b64:	f0 1f 00 06 	mcall	80004b7c <xnl_data_msg_func+0x58>
80004b68:	48 68       	lddpc	r8,80004b80 <xnl_data_msg_func+0x5c>
80004b6a:	70 08       	ld.w	r8,r8[0x0]
80004b6c:	5d 18       	icall	r8
80004b6e:	fa cd ff 34 	sub	sp,sp,-204
}
80004b72:	2c 0d       	sub	sp,-256
80004b74:	e3 cd 80 80 	ldm	sp++,r7,pc
80004b78:	80 00       	ld.sh	r0,r0[0x0]
80004b7a:	49 6c       	lddpc	r12,80004bd0 <xnl_device_auth_reply_func+0x4c>
80004b7c:	80 00       	ld.sh	r0,r0[0x0]
80004b7e:	71 8e       	ld.w	lr,r8[0x60]
80004b80:	00 00       	add	r0,r0
80004b82:	0b 5c       	ld.sh	r12,--r5

80004b84 <xnl_device_auth_reply_func>:
Description: process while receive device auth reply.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_auth_reply_func(xnl_fragment_t * xnl)
{
80004b84:	d4 21       	pushm	r4-r7,lr
80004b86:	fa cd 01 00 	sub	sp,sp,256
80004b8a:	18 97       	mov	r7,r12
	the receiving device and will be used to authenticate the connection 
	request. 5.4.4
	*/
	//log("R_xnl-opcode:%4x", xnl->xnl_header.opcode);
	
	if(xnl_information.is_connected)
80004b8c:	4c 28       	lddpc	r8,80004c94 <xnl_device_auth_reply_func+0x110>
80004b8e:	11 88       	ld.ub	r8,r8[0x0]
80004b90:	58 08       	cp.w	r8,0
80004b92:	c7 e1       	brne	80004c8e <xnl_device_auth_reply_func+0x10a>
	{
		return;		
	}
	
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);
80004b94:	4c 18       	lddpc	r8,80004c98 <xnl_device_auth_reply_func+0x114>
80004b96:	70 0c       	ld.w	r12,r8[0x0]
80004b98:	30 09       	mov	r9,0
80004b9a:	12 9a       	mov	r10,r9
80004b9c:	12 9b       	mov	r11,r9
80004b9e:	f0 1f 00 40 	mcall	80004c9c <xnl_device_auth_reply_func+0x118>

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
80004ba2:	ef 09 00 10 	ld.sh	r9,r7[16]
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
80004ba6:	4b c8       	lddpc	r8,80004c94 <xnl_device_auth_reply_func+0x110>
80004ba8:	b0 29       	st.h	r8[0x4],r9
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
	
	/*Get Array of values to be encrypted into an aligned 2X32bits.*/
	v_vector[0] =
80004baa:	ef 39 00 12 	ld.ub	r9,r7[18]
80004bae:	ef 38 00 13 	ld.ub	r8,r7[19]
80004bb2:	b1 68       	lsl	r8,0x10
80004bb4:	f1 e9 11 89 	or	r9,r8,r9<<0x18
80004bb8:	ef 38 00 15 	ld.ub	r8,r7[21]
80004bbc:	f3 e8 10 08 	or	r8,r9,r8
80004bc0:	ef 39 00 14 	ld.ub	r9,r7[20]
80004bc4:	f1 e9 10 89 	or	r9,r8,r9<<0x8
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[2])<<8	  
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[3]);
	
	v_vector[1] =
80004bc8:	ef 3a 00 16 	ld.ub	r10,r7[22]
80004bcc:	ef 38 00 17 	ld.ub	r8,r7[23]
80004bd0:	b1 68       	lsl	r8,0x10
80004bd2:	f1 ea 11 8a 	or	r10,r8,r10<<0x18
80004bd6:	ef 38 00 19 	ld.ub	r8,r7[25]
80004bda:	f5 e8 10 08 	or	r8,r10,r8
80004bde:	ef 3a 00 18 	ld.ub	r10,r7[24]
80004be2:	f1 ea 10 88 	or	r8,r8,r10<<0x8
80004be6:	30 0a       	mov	r10,0
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
80004be8:	e0 64 79 b9 	mov	r4,31161
80004bec:	ea 14 9e 37 	orh	r4,0x9e37
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
80004bf0:	e0 65 45 07 	mov	r5,17671
80004bf4:	ea 15 8a bd 	orh	r5,0x8abd
80004bf8:	e0 66 f9 3d 	mov	r6,63805
80004bfc:	ea 16 99 68 	orh	r6,0x9968
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
80004c00:	e0 6e b8 cf 	mov	lr,47311
80004c04:	ea 1e 36 83 	orh	lr,0x3683
80004c08:	e0 67 aa 1c 	mov	r7,43548
80004c0c:	ea 17 9c 36 	orh	r7,0x9c36
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
80004c10:	08 0a       	add	r10,r4
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
80004c12:	f4 08 00 0c 	add	r12,r10,r8
80004c16:	f0 0b 15 04 	lsl	r11,r8,0x4
80004c1a:	0a 0b       	add	r11,r5
80004c1c:	f9 eb 20 0b 	eor	r11,r12,r11
80004c20:	f0 0c 16 05 	lsr	r12,r8,0x5
80004c24:	0c 0c       	add	r12,r6
80004c26:	18 5b       	eor	r11,r12
80004c28:	16 09       	add	r9,r11
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
80004c2a:	f2 0c 15 04 	lsl	r12,r9,0x4
80004c2e:	1c 0c       	add	r12,lr
80004c30:	f2 0b 16 05 	lsr	r11,r9,0x5
80004c34:	0e 0b       	add	r11,r7
80004c36:	f9 eb 20 0b 	eor	r11,r12,r11
80004c3a:	f2 0a 00 0c 	add	r12,r9,r10
80004c3e:	18 5b       	eor	r11,r12
80004c40:	16 08       	add	r8,r11
{
	register U32 y=v[0], z=v[1], sum=0;
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
80004c42:	e0 6b 37 20 	mov	r11,14112
80004c46:	ea 1b c6 ef 	orh	r11,0xc6ef
80004c4a:	16 3a       	cp.w	r10,r11
80004c4c:	ce 21       	brne	80004c10 <xnl_device_auth_reply_func+0x8c>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :24 + 2(xnl length(24) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 24 + 2;
80004c4e:	e0 6a 40 1a 	mov	r10,16410
80004c52:	ba 0a       	st.h	sp[0x0],r10
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004c54:	3f fa       	mov	r10,-1
80004c56:	ba 1a       	st.h	sp[0x2],r10
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_CONN_REQUEST;
80004c58:	30 6b       	mov	r11,6
80004c5a:	ba 2b       	st.h	sp[0x4],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
80004c5c:	ba 3a       	st.h	sp[0x6],r10
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
80004c5e:	48 eb       	lddpc	r11,80004c94 <xnl_device_auth_reply_func+0x110>
80004c60:	96 1c       	ld.sh	r12,r11[0x2]
80004c62:	ba 4c       	st.h	sp[0x8],r12
	message here, and all will receive the same DEVICE_CONN_REPLY. Not real 
	sure what's going to happen with multiple conrol heads, etc. One suspects 
	the Rocket Scientists will eventually figure this out, and demand a 
	transaction ID based on Device Type in the XNL_DEVICE_AUTH_KEY_REQUEST.
	*/
	xnl_frame.xnl_header.source = xnl_information.device_address;
80004c64:	96 2b       	ld.sh	r11,r11[0x4]
80004c66:	ba 5b       	st.h	sp[0xa],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80004c68:	ba 6a       	st.h	sp[0xc],r10
	
    /*his message contains 12 payload bytes*/	
	xnl_frame.xnl_header.payload_length = 0x000C;
80004c6a:	30 ca       	mov	r10,12
80004c6c:	ba 7a       	st.h	sp[0xe],r10
	
	/*No Preferred XNL Address*/
	xnl_frame.xnl_payload.xnl_content_device_conn_req.preferred_xnl_address = 
80004c6e:	30 0a       	mov	r10,0
80004c70:	fb 5a 00 10 	st.h	sp[16],r10
	XCMP/XNL Development Specification Section 4.5.3.2.1.
	Same as in MOTOTRBO?XCMP/XNL Development Specification?
	evice_type--Option Board(0x07)
	authentication_index--Option Board(0x02)
	*/	
	xnl_frame.xnl_payload.xnl_content_device_conn_req.device_type = 0x07;
80004c74:	30 7a       	mov	r10,7
80004c76:	fb 6a 00 12 	st.b	sp[18],r10
	xnl_frame.xnl_payload.xnl_content_device_conn_req.authentication_index =
80004c7a:	30 2a       	mov	r10,2
80004c7c:	fb 6a 00 13 	st.b	sp[19],r10
	                                                                       0x02;
		
	//We know encrypted array happens to be aligned to 32-bit boundary.
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
80004c80:	fa ca ff ec 	sub	r10,sp,-20
80004c84:	95 09       	st.w	r10[0x0],r9
	                         .encrypted_authentication_value[0])) = w_vector[0];
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
80004c86:	95 18       	st.w	r10[0x4],r8
	                         .encrypted_authentication_value[4])) = w_vector[1];
	
	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004c88:	1a 9c       	mov	r12,sp
80004c8a:	f0 1f 00 06 	mcall	80004ca0 <xnl_device_auth_reply_func+0x11c>
}
80004c8e:	2c 0d       	sub	sp,-256
80004c90:	d8 22       	popm	r4-r7,pc
80004c92:	00 00       	add	r0,r0
80004c94:	00 00       	add	r0,r0
80004c96:	0b 3c       	ld.ub	r12,r5++
80004c98:	00 00       	add	r0,r0
80004c9a:	0b 38       	ld.ub	r8,r5++
80004c9c:	80 00       	ld.sh	r0,r0[0x0]
80004c9e:	5c 3c       	neg	r12
80004ca0:	80 00       	ld.sh	r0,r0[0x0]
80004ca2:	49 6c       	lddpc	r12,80004cf8 <xnl_master_status_brdcst_func+0x54>

80004ca4 <xnl_master_status_brdcst_func>:
Description: process while receive master status boardcast.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_master_status_brdcst_func(xnl_fragment_t * xnl)
{	
80004ca4:	eb cd 40 80 	pushm	r7,lr
80004ca8:	fa cd 01 00 	sub	sp,sp,256
80004cac:	18 97       	mov	r7,r12
	not an XNL_DATA_MSG has been sent out. This will indicate to a connecting 
	device that it has missed messages. The XNL header will contain the 
	master?XNL address. 5.4.1
	*/
	
	if(xnl_information.is_connected)
80004cae:	49 28       	lddpc	r8,80004cf4 <xnl_master_status_brdcst_func+0x50>
80004cb0:	11 88       	ld.ub	r8,r8[0x0]
80004cb2:	58 08       	cp.w	r8,0
80004cb4:	c1 c1       	brne	80004cec <xnl_master_status_brdcst_func+0x48>
	{
		return;	
	}
		
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);	
80004cb6:	49 18       	lddpc	r8,80004cf8 <xnl_master_status_brdcst_func+0x54>
80004cb8:	70 0c       	ld.w	r12,r8[0x0]
80004cba:	30 09       	mov	r9,0
80004cbc:	12 9a       	mov	r10,r9
80004cbe:	12 9b       	mov	r11,r9
80004cc0:	f0 1f 00 0f 	mcall	80004cfc <xnl_master_status_brdcst_func+0x58>

	//log("xnl-ma:%4x", xnl->xnl_header.source);
	/*get the master adderss from this message*/	
	xnl_information.master_address = xnl->xnl_header.source;	
80004cc4:	8e 58       	ld.sh	r8,r7[0xa]
80004cc6:	48 c9       	lddpc	r9,80004cf4 <xnl_master_status_brdcst_func+0x50>
80004cc8:	b2 18       	st.h	r9[0x2],r8
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80004cca:	e0 68 40 0e 	mov	r8,16398
80004cce:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004cd0:	3f f8       	mov	r8,-1
80004cd2:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_AUTH_KEY_REQUEST;
80004cd4:	30 4a       	mov	r10,4
80004cd6:	ba 2a       	st.h	sp[0x4],r10
		
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/	
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
80004cd8:	ba 38       	st.h	sp[0x6],r8
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
80004cda:	92 19       	ld.sh	r9,r9[0x2]
80004cdc:	ba 49       	st.h	sp[0x8],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.source = DEFAULT_VALUE;
80004cde:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80004ce0:	ba 68       	st.h	sp[0xc],r8
		
	xnl_frame.xnl_header.payload_length = 0;
80004ce2:	30 08       	mov	r8,0
80004ce4:	ba 78       	st.h	sp[0xe],r8
	
	/*send XNL message*/	
	xnl_tx(&xnl_frame);
80004ce6:	1a 9c       	mov	r12,sp
80004ce8:	f0 1f 00 06 	mcall	80004d00 <xnl_master_status_brdcst_func+0x5c>
	//log("--1--\r\n");
}
80004cec:	2c 0d       	sub	sp,-256
80004cee:	e3 cd 80 80 	ldm	sp++,r7,pc
80004cf2:	00 00       	add	r0,r0
80004cf4:	00 00       	add	r0,r0
80004cf6:	0b 3c       	ld.ub	r12,r5++
80004cf8:	00 00       	add	r0,r0
80004cfa:	0b 38       	ld.ub	r8,r5++
80004cfc:	80 00       	ld.sh	r0,r0[0x0]
80004cfe:	5c 3c       	neg	r12
80004d00:	80 00       	ld.sh	r0,r0[0x0]
80004d02:	49 6c       	lddpc	r12,80004d58 <xnl_device_conn_reply_func+0x54>

80004d04 <xnl_device_conn_reply_func>:
Description: process while receive device conn reply.
Calls:xSemaphoreGive--freestos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_conn_reply_func(xnl_fragment_t * xnl)
{
80004d04:	eb cd 40 80 	pushm	r7,lr
80004d08:	18 97       	mov	r7,r12
	transaction ID and an 8-byte encrypted value that the device can use to 
	authenticate the master. XCMP/XNL Development Guide 5.4.6
	*/
	
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);
80004d0a:	49 28       	lddpc	r8,80004d50 <xnl_device_conn_reply_func+0x4c>
80004d0c:	70 0c       	ld.w	r12,r8[0x0]
80004d0e:	30 09       	mov	r9,0
80004d10:	12 9a       	mov	r10,r9
80004d12:	12 9b       	mov	r11,r9
80004d14:	f0 1f 00 10 	mcall	80004d54 <xnl_device_conn_reply_func+0x50>

	/*Test result code*/
	if((xnl->xnl_payload.xnl_content_device_conn_reply.result_base & 0x0000FF00)
80004d18:	ef 18 00 10 	ld.uh	r8,r7[16]
80004d1c:	10 99       	mov	r9,r8
80004d1e:	e2 19 ff 00 	andl	r9,0xff00,COH
80004d22:	e0 49 01 00 	cp.w	r9,256
80004d26:	c0 60       	breq	80004d32 <xnl_device_conn_reply_func+0x2e>
		/*
		Rejected. The device must retry the authentication process at this 
		point by sending out a new AUTH_KEY_REQUEST message. XCMP/XNL 
		Development Guide Section 5.2.3
		*/
		xnl_master_status_brdcst_func(xnl);			
80004d28:	0e 9c       	mov	r12,r7
80004d2a:	f0 1f 00 0c 	mcall	80004d58 <xnl_device_conn_reply_func+0x54>
80004d2e:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/*connection accepted*/		
		/*Record Transaction ID Base*/
		xnl_information.transaction_id =  
80004d32:	a9 68       	lsl	r8,0x8
80004d34:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
80004d38:	48 98       	lddpc	r8,80004d5c <xnl_device_conn_reply_func+0x58>
80004d3a:	b0 49       	st.h	r8[0x8],r9
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
80004d3c:	ef 09 00 14 	ld.sh	r9,r7[20]
		xnl_information.transaction_id =  
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
80004d40:	b0 39       	st.h	r8[0x6],r9
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
80004d42:	ef 09 00 12 	ld.sh	r9,r7[18]
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
80004d46:	b0 29       	st.h	r8[0x4],r9
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
		
		/*connect finish*/
		xnl_information.is_connected = TRUE;
80004d48:	30 19       	mov	r9,1
80004d4a:	b0 89       	st.b	r8[0x0],r9
80004d4c:	e3 cd 80 80 	ldm	sp++,r7,pc
80004d50:	00 00       	add	r0,r0
80004d52:	0b 38       	ld.ub	r8,r5++
80004d54:	80 00       	ld.sh	r0,r0[0x0]
80004d56:	5c 3c       	neg	r12
80004d58:	80 00       	ld.sh	r0,r0[0x0]
80004d5a:	4c a4       	lddpc	r4,80004e80 <INTC_register_interrupt+0x10>
80004d5c:	00 00       	add	r0,r0
80004d5e:	0b 3c       	ld.ub	r12,r5++

80004d60 <local_start_pll0>:
	//pm_switch_to_osc0(pm, 12000000, 3);
	//    pm_enable_osc0_crystal(pm, 12000000);
	//         pm_set_osc0_mode(pm,AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);  0x00000007
	//    pm_enable_clk0(pm, 3);
	//         pm_enable_clk0_no_wait(pm, 3);
	(&AVR32_PM)->oscctrl0 = 0x00000307;
80004d60:	fe 78 0c 00 	mov	r8,-62464
80004d64:	e0 69 03 07 	mov	r9,775
80004d68:	91 a9       	st.w	r8[0x28],r9
	(&AVR32_PM)->mcctrl   = 0x00000004;
80004d6a:	30 49       	mov	r9,4
80004d6c:	91 09       	st.w	r8[0x0],r9
	//         pm_wait_for_clk0_ready(pm);
	while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
80004d6e:	71 59       	ld.w	r9,r8[0x54]
80004d70:	e2 19 00 80 	andl	r9,0x80,COH
80004d74:	cf d0       	breq	80004d6e <local_start_pll0+0xe>
	//    pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);
	(&AVR32_PM)->mcctrl   = 0x00000005;
80004d76:	fe 78 0c 00 	mov	r8,-62464
80004d7a:	30 59       	mov	r9,5
80004d7c:	91 09       	st.w	r8[0x0],r9
	//pm_pll_set_option(pm, 0, //PLL number 0
	//                        1, //freq Set to 1 for VCO frequency range 80-180MHz
	//                        1, //div2 Divide the PLL output frequency by 2
	//                        0);//0 to enable the Wide-Bandith Mode
	//pm_pll_enable(pm,0);
	(&AVR32_PM)->pll[0] = 0x1007010D;
80004d7e:	e0 69 01 0d 	mov	r9,269
80004d82:	ea 19 10 07 	orh	r9,0x1007
80004d86:	91 89       	st.w	r8[0x20],r9


	//pm_wait_for_pll0_locked(pm);
	while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_LOCK0_MASK));
80004d88:	71 59       	ld.w	r9,r8[0x54]
80004d8a:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
80004d8e:	cf d0       	breq	80004d88 <local_start_pll0+0x28>
	//             0,  //Bus A select = 0 (PBA clock = 48MHz/2 = 24MHz).
	//             0,  //B clock divisor enable = 0
	//             0,  //Bus B select = 0
	//             0,  //HS Bus clock divisor enable = 0
	//             0); //HS Bus select = 0
	(&AVR32_PM)->cksel = 0x00800000;
80004d90:	fe 78 0c 00 	mov	r8,-62464
80004d94:	fc 19 00 80 	movh	r9,0x80
80004d98:	91 19       	st.w	r8[0x4],r9

	//flashc_set_wait_state(1);
	AVR32_FLASHC.fcr = 0x00000040;
80004d9a:	34 0a       	mov	r10,64
80004d9c:	fe 69 14 00 	mov	r9,-125952
80004da0:	93 0a       	st.w	r9[0x0],r10

	//pm_switch_to_clock(pm, AVR32_PM_MCSEL_PLL0);
	(&AVR32_PM)->mcctrl   = 0x00000006;
80004da2:	30 69       	mov	r9,6
80004da4:	91 09       	st.w	r8[0x0],r9


	AVR32_HMATRIX.mcfg[AVR32_HMATRIX_MASTER_CPU_INSTRUCTION] = 0x1;
80004da6:	30 19       	mov	r9,1
80004da8:	fe 68 10 00 	mov	r8,-126976
80004dac:	91 19       	st.w	r8[0x4],r9
}
80004dae:	5e fc       	retal	r12

80004db0 <local_start_timer>:
//	MAKO_RX					AVR32_SSC_RX_DATA_0_PIN				[39 PortB Pin  7 00000080 Func 0]
//
void local_start_timer(void)
{
	//Route CLK to Timer
	AVR32_GPIO.port[0].pmr0s = 0x00100000;
80004db0:	fe 78 10 00 	mov	r8,-61440
80004db4:	fc 19 00 10 	movh	r9,0x10
80004db8:	91 59       	st.w	r8[0x14],r9
	AVR32_GPIO.port[0].pmr1c = 0x00100000;
80004dba:	91 a9       	st.w	r8[0x28],r9
	AVR32_GPIO.port[0].gperc = 0x00100000;
80004dbc:	91 29       	st.w	r8[0x8],r9
	//Route FS and Tri-State to Timer.
	AVR32_GPIO.port[1].pmr0c = 0x00000003;
80004dbe:	30 39       	mov	r9,3
80004dc0:	f1 49 01 18 	st.w	r8[280],r9
	AVR32_GPIO.port[1].pmr1c = 0x00000003;
80004dc4:	f1 49 01 28 	st.w	r8[296],r9
	AVR32_GPIO.port[1].gperc = 0x00000003;
80004dc8:	f1 49 01 08 	st.w	r8[264],r9

	(&AVR32_TC)->bmr = 4;
80004dcc:	fe 78 38 00 	mov	r8,-51200
80004dd0:	30 49       	mov	r9,4
80004dd2:	f1 49 00 c4 	st.w	r8[196],r9
	(&AVR32_TC)->channel[0].cmr =
80004dd6:	e0 69 91 0d 	mov	r9,37133
80004dda:	ea 19 00 52 	orh	r9,0x52
80004dde:	91 19       	st.w	r8[0x4],r9
	1                          << AVR32_TC_CLKI_OFFSET     |
	AVR32_TC_TCCLKS_XC0        << AVR32_TC_TCCLKS_OFFSET;



	(&AVR32_TC)->channel[0].ra = 32;
80004de0:	32 09       	mov	r9,32
80004de2:	91 59       	st.w	r8[0x14],r9
	(&AVR32_TC)->channel[0].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
80004de4:	30 59       	mov	r9,5
80004de6:	91 09       	st.w	r8[0x0],r9
}
80004de8:	5e fc       	retal	r12
80004dea:	d7 03       	nop

80004dec <tc_init>:
 * - fPBA/8 is used as clock source for TC
 * - Enables RC compare match interrupt
 * \param tc Base address of the TC module
 */
void tc_init()
{
80004dec:	d4 01       	pushm	lr

	volatile avr32_tc_t * tc = EXAMPLE_TC;
	
	INTC_register_interrupt(&_tc_interrupt, AVR32_TC_IRQ1, AVR32_INTC_INT2);
80004dee:	30 2a       	mov	r10,2
80004df0:	e0 6b 01 c1 	mov	r11,449
80004df4:	48 ec       	lddpc	r12,80004e2c <tc_init+0x40>
80004df6:	f0 1f 00 0f 	mcall	80004e30 <tc_init+0x44>
		.cpas  = 0,
		.lovrs = 0,
		.covfs = 0
	};
	// Initialize the timer/counter.
	tc_init_waveform(tc, &waveform_opt);
80004dfa:	48 fb       	lddpc	r11,80004e34 <tc_init+0x48>
80004dfc:	fe 7c 38 00 	mov	r12,-51200
80004e00:	f0 1f 00 0e 	mcall	80004e38 <tc_init+0x4c>
	 * We want: (1 / (fPBA / 8)) * RC = 10 ms, hence RC = (fPBA / 8) / 100
	 * to get an interrupt every 10 ms.
	 */
	//tc_write_rc(tc, EXAMPLE_TC_CHANNEL, (sysclk_get_pba_hz() / 8 / 100));
	
	tc_write_rc(tc, EXAMPLE_TC_CHANNEL, ((FOSC0*2) / 8 / 100));
80004e04:	e0 6a 75 30 	mov	r10,30000
80004e08:	30 1b       	mov	r11,1
80004e0a:	fe 7c 38 00 	mov	r12,-51200
80004e0e:	f0 1f 00 0c 	mcall	80004e3c <tc_init+0x50>
	
	//tc_write_rc(tc, EXAMPLE_TC_CHANNEL, (FOSC0 / 8 / 100000));
	
	
	// configure the timer interrupt
	tc_configure_interrupts(tc, EXAMPLE_TC_CHANNEL, &tc_interrupt);
80004e12:	48 ca       	lddpc	r10,80004e40 <tc_init+0x54>
80004e14:	30 1b       	mov	r11,1
80004e16:	fe 7c 38 00 	mov	r12,-51200
80004e1a:	f0 1f 00 0b 	mcall	80004e44 <tc_init+0x58>
	// Start the timer/counter.
	tc_start(tc, EXAMPLE_TC_CHANNEL);
80004e1e:	30 1b       	mov	r11,1
80004e20:	fe 7c 38 00 	mov	r12,-51200
80004e24:	f0 1f 00 09 	mcall	80004e48 <tc_init+0x5c>
80004e28:	d8 02       	popm	pc
80004e2a:	00 00       	add	r0,r0
80004e2c:	80 00       	ld.sh	r0,r0[0x0]
80004e2e:	4e 4c       	lddpc	r12,80004fbc <spi_selectionMode+0x8>
80004e30:	80 00       	ld.sh	r0,r0[0x0]
80004e32:	4e 70       	lddpc	r0,80004fcc <spi_selectionMode+0x18>
80004e34:	80 01       	ld.sh	r1,r0[0x0]
80004e36:	57 48       	stdsp	sp[0x1d0],r8
80004e38:	80 00       	ld.sh	r0,r0[0x0]
80004e3a:	51 56       	stdsp	sp[0x54],r6
80004e3c:	80 00       	ld.sh	r0,r0[0x0]
80004e3e:	52 16       	stdsp	sp[0x84],r6
80004e40:	80 01       	ld.sh	r1,r0[0x0]
80004e42:	57 44       	stdsp	sp[0x1d0],r4
80004e44:	80 00       	ld.sh	r0,r0[0x0]
80004e46:	52 4a       	stdsp	sp[0x90],r10
80004e48:	80 00       	ld.sh	r0,r0[0x0]
80004e4a:	51 f2       	stdsp	sp[0x7c],r2

80004e4c <_tc_interrupt>:
volatile U32 tc_tick = 0;

//brief Default interrupt handler.
__attribute__((__interrupt__))
static void _tc_interrupt(void)
 {
80004e4c:	d4 01       	pushm	lr
	// Increment the 10ms seconds counter
	tc_tick++;
80004e4e:	48 68       	lddpc	r8,80004e64 <_tc_interrupt+0x18>
80004e50:	70 09       	ld.w	r9,r8[0x0]
80004e52:	2f f9       	sub	r9,-1
80004e54:	91 09       	st.w	r8[0x0],r9
	/*
	 * TODO: Place a breakpoint here and watch the update of tc_tick variable
	 * in the Watch Window.
	 */
	// Clear the interrupt flag. This is a side effect of reading the TC SR.
	tc_read_sr(EXAMPLE_TC, EXAMPLE_TC_CHANNEL);
80004e56:	30 1b       	mov	r11,1
80004e58:	fe 7c 38 00 	mov	r12,-51200
80004e5c:	f0 1f 00 03 	mcall	80004e68 <_tc_interrupt+0x1c>
	
}
80004e60:	d4 02       	popm	lr
80004e62:	d6 03       	rete
80004e64:	00 00       	add	r0,r0
80004e66:	0b 60       	ld.uh	r0,--r5
80004e68:	80 00       	ld.sh	r0,r0[0x0]
80004e6a:	52 04       	stdsp	sp[0x80],r4

80004e6c <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
80004e6c:	c0 08       	rjmp	80004e6c <_unhandled_interrupt>
80004e6e:	d7 03       	nop

80004e70 <INTC_register_interrupt>:
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
80004e70:	f6 08 16 05 	lsr	r8,r11,0x5

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
80004e74:	49 99       	lddpc	r9,80004ed8 <INTC_register_interrupt+0x68>
80004e76:	f2 08 00 39 	add	r9,r9,r8<<0x3
80004e7a:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
80004e7e:	72 19       	ld.w	r9,r9[0x4]
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
80004e80:	f2 0b 09 2c 	st.w	r9[r11<<0x2],r12
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
80004e84:	58 0a       	cp.w	r10,0
80004e86:	c0 91       	brne	80004e98 <INTC_register_interrupt+0x28>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80004e88:	49 59       	lddpc	r9,80004edc <INTC_register_interrupt+0x6c>
80004e8a:	49 6a       	lddpc	r10,80004ee0 <INTC_register_interrupt+0x70>
80004e8c:	12 1a       	sub	r10,r9
80004e8e:	fe 79 08 00 	mov	r9,-63488
80004e92:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80004e96:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT1) {
80004e98:	58 1a       	cp.w	r10,1
80004e9a:	c0 a1       	brne	80004eae <INTC_register_interrupt+0x3e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
80004e9c:	49 09       	lddpc	r9,80004edc <INTC_register_interrupt+0x6c>
80004e9e:	49 2a       	lddpc	r10,80004ee4 <INTC_register_interrupt+0x74>
80004ea0:	12 1a       	sub	r10,r9
80004ea2:	bf aa       	sbr	r10,0x1e
80004ea4:	fe 79 08 00 	mov	r9,-63488
80004ea8:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80004eac:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT2) {
80004eae:	58 2a       	cp.w	r10,2
80004eb0:	c0 a1       	brne	80004ec4 <INTC_register_interrupt+0x54>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
80004eb2:	48 b9       	lddpc	r9,80004edc <INTC_register_interrupt+0x6c>
80004eb4:	48 da       	lddpc	r10,80004ee8 <INTC_register_interrupt+0x78>
80004eb6:	12 1a       	sub	r10,r9
80004eb8:	bf ba       	sbr	r10,0x1f
80004eba:	fe 79 08 00 	mov	r9,-63488
80004ebe:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80004ec2:	5e fc       	retal	r12
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
80004ec4:	48 69       	lddpc	r9,80004edc <INTC_register_interrupt+0x6c>
80004ec6:	48 aa       	lddpc	r10,80004eec <INTC_register_interrupt+0x7c>
80004ec8:	12 1a       	sub	r10,r9
80004eca:	ea 1a c0 00 	orh	r10,0xc000
80004ece:	fe 79 08 00 	mov	r9,-63488
80004ed2:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80004ed6:	5e fc       	retal	r12
80004ed8:	80 01       	ld.sh	r1,r0[0x0]
80004eda:	57 50       	stdsp	sp[0x1d4],r0
80004edc:	80 00       	ld.sh	r0,r0[0x0]
80004ede:	c8 00       	breq	80004dde <local_start_timer+0x2e>
80004ee0:	80 00       	ld.sh	r0,r0[0x0]
80004ee2:	c9 04       	brge	80004e02 <tc_init+0x16>
80004ee4:	80 00       	ld.sh	r0,r0[0x0]
80004ee6:	c9 12       	brcc	80004e08 <tc_init+0x1c>
80004ee8:	80 00       	ld.sh	r0,r0[0x0]
80004eea:	c9 20       	breq	80004e0e <tc_init+0x22>
80004eec:	80 00       	ld.sh	r0,r0[0x0]
80004eee:	c9 2e       	rcall	80004c12 <xnl_device_auth_reply_func+0x8e>

80004ef0 <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
80004ef0:	d4 21       	pushm	r4-r7,lr
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
80004ef2:	49 18       	lddpc	r8,80004f34 <INTC_init_interrupts+0x44>
80004ef4:	e3 b8 00 01 	mtsr	0x4,r8
80004ef8:	49 0e       	lddpc	lr,80004f38 <INTC_init_interrupts+0x48>
80004efa:	30 07       	mov	r7,0
80004efc:	0e 94       	mov	r4,r7
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80004efe:	49 0c       	lddpc	r12,80004f3c <INTC_init_interrupts+0x4c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80004f00:	49 05       	lddpc	r5,80004f40 <INTC_init_interrupts+0x50>
80004f02:	10 15       	sub	r5,r8
80004f04:	fe 76 08 00 	mov	r6,-63488
80004f08:	c1 08       	rjmp	80004f28 <INTC_init_interrupts+0x38>
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
80004f0a:	08 98       	mov	r8,r4
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
80004f0c:	7c 1b       	ld.w	r11,lr[0x4]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80004f0e:	7c 0a       	ld.w	r10,lr[0x0]
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80004f10:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
80004f14:	2f f8       	sub	r8,-1

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80004f16:	10 3a       	cp.w	r10,r8
80004f18:	fe 9b ff fc 	brhi	80004f10 <INTC_init_interrupts+0x20>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80004f1c:	ec 07 09 25 	st.w	r6[r7<<0x2],r5
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
80004f20:	2f f7       	sub	r7,-1
80004f22:	2f 8e       	sub	lr,-8
80004f24:	59 37       	cp.w	r7,19
80004f26:	c0 50       	breq	80004f30 <INTC_init_interrupts+0x40>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80004f28:	7c 08       	ld.w	r8,lr[0x0]
80004f2a:	58 08       	cp.w	r8,0
80004f2c:	ce f1       	brne	80004f0a <INTC_init_interrupts+0x1a>
80004f2e:	cf 7b       	rjmp	80004f1c <INTC_init_interrupts+0x2c>
80004f30:	d8 22       	popm	r4-r7,pc
80004f32:	00 00       	add	r0,r0
80004f34:	80 00       	ld.sh	r0,r0[0x0]
80004f36:	c8 00       	breq	80004e36 <tc_init+0x4a>
80004f38:	80 01       	ld.sh	r1,r0[0x0]
80004f3a:	57 50       	stdsp	sp[0x1d4],r0
80004f3c:	80 00       	ld.sh	r0,r0[0x0]
80004f3e:	4e 6c       	lddpc	r12,800050d4 <spi_setupChipReg+0x82>
80004f40:	80 00       	ld.sh	r0,r0[0x0]
80004f42:	c9 04       	brge	80004e62 <_tc_interrupt+0x16>

80004f44 <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
80004f44:	fe 78 08 00 	mov	r8,-63488
80004f48:	e0 69 00 83 	mov	r9,131
80004f4c:	f2 0c 01 0c 	sub	r12,r9,r12
80004f50:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
80004f54:	f2 ca ff c0 	sub	r10,r9,-64
80004f58:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	
	return (int_req)
80004f5c:	58 08       	cp.w	r8,0
80004f5e:	c0 21       	brne	80004f62 <_get_interrupt_handler+0x1e>
80004f60:	5e fd       	retal	0
		? _int_handler_table[int_grp]._int_line_handler_table[32
80004f62:	f0 08 12 00 	clz	r8,r8
80004f66:	48 5a       	lddpc	r10,80004f78 <_get_interrupt_handler+0x34>
80004f68:	f4 09 00 39 	add	r9,r10,r9<<0x3
80004f6c:	f0 08 11 1f 	rsub	r8,r8,31
80004f70:	72 19       	ld.w	r9,r9[0x4]
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	
	return (int_req)
80004f72:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
80004f76:	5e fc       	retal	r12
80004f78:	80 01       	ld.sh	r1,r0[0x0]
80004f7a:	57 50       	stdsp	sp[0x1d4],r0

80004f7c <spi_initMaster>:

spi_status_t spi_initMaster(volatile avr32_spi_t *spi, const spi_options_t *options)
{
  u_avr32_spi_mr_t u_avr32_spi_mr;

  if (options->modfdis > 1) {
80004f7c:	f7 39 00 0d 	ld.ub	r9,r11[13]
80004f80:	30 18       	mov	r8,1
80004f82:	f0 09 18 00 	cp.b	r9,r8
80004f86:	e0 88 00 04 	brls	80004f8e <spi_initMaster+0x12>
80004f8a:	30 2c       	mov	r12,2
80004f8c:	5e fc       	retal	r12
    return SPI_ERROR_ARGUMENT;
  }

  // Reset.
  spi->cr = AVR32_SPI_CR_SWRST_MASK;
80004f8e:	e0 68 00 80 	mov	r8,128
80004f92:	99 08       	st.w	r12[0x0],r8

  // Master Mode.
  u_avr32_spi_mr.mr = spi->mr;
80004f94:	78 18       	ld.w	r8,r12[0x4]
  u_avr32_spi_mr.MR.mstr = 1;
80004f96:	30 19       	mov	r9,1
80004f98:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
  u_avr32_spi_mr.MR.modfdis = options->modfdis;
80004f9c:	f7 39 00 0d 	ld.ub	r9,r11[13]
80004fa0:	f1 d9 d0 81 	bfins	r8,r9,0x4,0x1
  u_avr32_spi_mr.MR.llb = 0;
80004fa4:	30 09       	mov	r9,0
80004fa6:	f1 d9 d0 e1 	bfins	r8,r9,0x7,0x1
  u_avr32_spi_mr.MR.pcs = (1 << AVR32_SPI_MR_PCS_SIZE) - 1;
80004faa:	30 fa       	mov	r10,15
80004fac:	f1 da d2 04 	bfins	r8,r10,0x10,0x4
  spi->mr = u_avr32_spi_mr.mr;
80004fb0:	99 18       	st.w	r12[0x4],r8
80004fb2:	5e f9       	retal	r9

80004fb4 <spi_selectionMode>:

spi_status_t spi_selectionMode(volatile avr32_spi_t *spi,
                               unsigned char variable_ps,
                               unsigned char pcs_decode,
                               unsigned char delay)
{
80004fb4:	d4 01       	pushm	lr
  u_avr32_spi_mr_t u_avr32_spi_mr;

  if (variable_ps > 1 ||
80004fb6:	30 18       	mov	r8,1
80004fb8:	f0 0b 18 00 	cp.b	r11,r8
80004fbc:	5f be       	srhi	lr
80004fbe:	f0 0a 18 00 	cp.b	r10,r8
80004fc2:	5f b8       	srhi	r8
80004fc4:	fd e8 10 08 	or	r8,lr,r8
80004fc8:	c0 30       	breq	80004fce <spi_selectionMode+0x1a>
80004fca:	30 2c       	mov	r12,2
80004fcc:	d8 02       	popm	pc
      pcs_decode > 1) {
    return SPI_ERROR_ARGUMENT;
  }

  u_avr32_spi_mr.mr = spi->mr;
80004fce:	78 18       	ld.w	r8,r12[0x4]
  u_avr32_spi_mr.MR.ps = variable_ps;
80004fd0:	f1 db d0 21 	bfins	r8,r11,0x1,0x1
  u_avr32_spi_mr.MR.pcsdec = pcs_decode;
80004fd4:	f1 da d0 41 	bfins	r8,r10,0x2,0x1
  u_avr32_spi_mr.MR.dlybcs = delay;
80004fd8:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8
  spi->mr = u_avr32_spi_mr.mr;
80004fdc:	99 18       	st.w	r12[0x4],r8
80004fde:	d8 0a       	popm	pc,r12=0

80004fe0 <spi_selectChip>:
   */
  while (pdFALSE == xSemaphoreTake(xSPIMutex, 20));
#endif

  // Assert all lines; no peripheral is selected.
  spi->mr |= AVR32_SPI_MR_PCS_MASK;
80004fe0:	78 18       	ld.w	r8,r12[0x4]
80004fe2:	ea 18 00 0f 	orh	r8,0xf
80004fe6:	99 18       	st.w	r12[0x4],r8

  if (spi->mr & AVR32_SPI_MR_PCSDEC_MASK) {
80004fe8:	78 18       	ld.w	r8,r12[0x4]
80004fea:	e2 18 00 04 	andl	r8,0x4,COH
80004fee:	c0 f0       	breq	8000500c <spi_selectChip+0x2c>
    // The signal is decoded; allow up to 15 chips.
    if (chip > 14) {
80004ff0:	30 e8       	mov	r8,14
80004ff2:	f0 0b 18 00 	cp.b	r11,r8
80004ff6:	e0 8b 00 19 	brhi	80005028 <spi_selectChip+0x48>
      return SPI_ERROR_ARGUMENT;
    }

    spi->mr &= ~AVR32_SPI_MR_PCS_MASK | (chip << AVR32_SPI_MR_PCS_OFFSET);
80004ffa:	78 18       	ld.w	r8,r12[0x4]
80004ffc:	b1 6b       	lsl	r11,0x10
80004ffe:	ea 1b ff f0 	orh	r11,0xfff0
80005002:	e8 1b ff ff 	orl	r11,0xffff
80005006:	10 6b       	and	r11,r8
80005008:	99 1b       	st.w	r12[0x4],r11
8000500a:	5e fd       	retal	0
  } else {
    if (chip > 3) {
8000500c:	30 38       	mov	r8,3
8000500e:	f0 0b 18 00 	cp.b	r11,r8
80005012:	e0 8b 00 0b 	brhi	80005028 <spi_selectChip+0x48>
      return SPI_ERROR_ARGUMENT;
    }

    spi->mr &= ~(1 << (AVR32_SPI_MR_PCS_OFFSET + chip));
80005016:	78 18       	ld.w	r8,r12[0x4]
80005018:	2f 0b       	sub	r11,-16
8000501a:	30 19       	mov	r9,1
8000501c:	f2 0b 09 4b 	lsl	r11,r9,r11
80005020:	5c db       	com	r11
80005022:	10 6b       	and	r11,r8
80005024:	99 1b       	st.w	r12[0x4],r11
80005026:	5e fd       	retal	0
80005028:	30 2c       	mov	r12,2
  }

  return SPI_OK;
}
8000502a:	5e fc       	retal	r12

8000502c <spi_unselectChip>:


spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, unsigned char chip)
{
8000502c:	e0 68 27 10 	mov	r8,10000
  unsigned int timeout = SPI_TIMEOUT;

  while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
80005030:	c0 58       	rjmp	8000503a <spi_unselectChip+0xe>
    if (!timeout--) {
80005032:	58 08       	cp.w	r8,0
80005034:	c0 21       	brne	80005038 <spi_unselectChip+0xc>
80005036:	5e ff       	retal	1
80005038:	20 18       	sub	r8,1

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, unsigned char chip)
{
  unsigned int timeout = SPI_TIMEOUT;

  while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
8000503a:	78 49       	ld.w	r9,r12[0x10]
8000503c:	e2 19 02 00 	andl	r9,0x200,COH
80005040:	cf 90       	breq	80005032 <spi_unselectChip+0x6>
      return SPI_ERROR_TIMEOUT;
    }
  }

  // Assert all lines; no peripheral is selected.
  spi->mr |= AVR32_SPI_MR_PCS_MASK;
80005042:	78 18       	ld.w	r8,r12[0x4]
80005044:	ea 18 00 0f 	orh	r8,0xf
80005048:	99 18       	st.w	r12[0x4],r8

  // Last transfer, so deassert the current NPCS if CSAAT is set.
  spi->cr = AVR32_SPI_CR_LASTXFER_MASK;
8000504a:	fc 18 01 00 	movh	r8,0x100
8000504e:	99 08       	st.w	r12[0x0],r8
80005050:	5e fd       	retal	0

80005052 <spi_setupChipReg>:


spi_status_t spi_setupChipReg(volatile avr32_spi_t *spi,
                              const spi_options_t *options,
                              unsigned int pba_hz)
{
80005052:	eb cd 40 c0 	pushm	r6-r7,lr
  u_avr32_spi_csr_t u_avr32_spi_csr;

  if (options->spi_mode > 3 ||
80005056:	f7 38 00 0c 	ld.ub	r8,r11[12]
8000505a:	30 39       	mov	r9,3
8000505c:	f2 08 18 00 	cp.b	r8,r9
80005060:	e0 8b 00 57 	brhi	8000510e <spi_setupChipReg+0xbc>
      options->stay_act > 1 ||
80005064:	f7 39 00 0b 	ld.ub	r9,r11[11]
                              const spi_options_t *options,
                              unsigned int pba_hz)
{
  u_avr32_spi_csr_t u_avr32_spi_csr;

  if (options->spi_mode > 3 ||
80005068:	30 1e       	mov	lr,1
8000506a:	fc 09 18 00 	cp.b	r9,lr
8000506e:	e0 8b 00 50 	brhi	8000510e <spi_setupChipReg+0xbc>
      options->stay_act > 1 ||
      options->bits < 8 || options->bits > 16) {
80005072:	f7 3e 00 08 	ld.ub	lr,r11[8]
                              const spi_options_t *options,
                              unsigned int pba_hz)
{
  u_avr32_spi_csr_t u_avr32_spi_csr;

  if (options->spi_mode > 3 ||
80005076:	30 77       	mov	r7,7
80005078:	ee 0e 18 00 	cp.b	lr,r7
8000507c:	e0 88 00 49 	brls	8000510e <spi_setupChipReg+0xbc>
80005080:	31 07       	mov	r7,16
80005082:	ee 0e 18 00 	cp.b	lr,r7
80005086:	e0 8b 00 44 	brhi	8000510e <spi_setupChipReg+0xbc>
 *   \retval >=0  Success.
 *   \retval  <0  Error.
 */
static int getBaudDiv(const spi_options_t *options, unsigned int pba_hz)
{
  int baudDiv = (pba_hz + options->baudrate / 2) / options->baudrate;
8000508a:	76 17       	ld.w	r7,r11[0x4]
8000508c:	ee 06 16 01 	lsr	r6,r7,0x1
80005090:	0c 0a       	add	r10,r6
80005092:	f4 07 0d 06 	divu	r6,r10,r7

  if (baudDiv <= 0 || baudDiv > 255) {
80005096:	ec c7 00 01 	sub	r7,r6,1
8000509a:	e0 47 00 fe 	cp.w	r7,254
8000509e:	e0 8b 00 38 	brhi	8000510e <spi_setupChipReg+0xbc>
 *   \retval >=0  Success.
 *   \retval  <0  Error.
 */
static int getBaudDiv(const spi_options_t *options, unsigned int pba_hz)
{
  int baudDiv = (pba_hz + options->baudrate / 2) / options->baudrate;
800050a2:	0c 97       	mov	r7,r6
    return SPI_ERROR_ARGUMENT;
  }

  int baudDiv = getBaudDiv(options, pba_hz);

  if (baudDiv < 0) {
800050a4:	58 06       	cp.w	r6,0
800050a6:	c3 45       	brlt	8000510e <spi_setupChipReg+0xbc>
    return SPI_ERROR_ARGUMENT;
  }

  // Will use CSR0 offsets; these are the same for CSR0 to CSR3.
  u_avr32_spi_csr.csr = 0;
800050a8:	30 0a       	mov	r10,0
  u_avr32_spi_csr.CSR.cpol = options->spi_mode >> 1;
800050aa:	f0 06 16 01 	lsr	r6,r8,0x1
800050ae:	f5 d6 d0 01 	bfins	r10,r6,0x0,0x1
  u_avr32_spi_csr.CSR.ncpha = (options->spi_mode & 0x1) ^ 0x1;
800050b2:	ec 18 00 01 	eorl	r8,0x1
800050b6:	f5 d8 d0 21 	bfins	r10,r8,0x1,0x1
  u_avr32_spi_csr.CSR.csaat = options->stay_act;
800050ba:	f5 d9 d0 61 	bfins	r10,r9,0x3,0x1
  u_avr32_spi_csr.CSR.bits = options->bits - 8;
800050be:	20 8e       	sub	lr,8
800050c0:	f5 de d0 84 	bfins	r10,lr,0x4,0x4
  u_avr32_spi_csr.CSR.scbr = baudDiv;
800050c4:	f5 d7 d1 08 	bfins	r10,r7,0x8,0x8
  u_avr32_spi_csr.CSR.dlybs = options->spck_delay;
800050c8:	f7 38 00 09 	ld.ub	r8,r11[9]
800050cc:	f5 d8 d2 08 	bfins	r10,r8,0x10,0x8
  u_avr32_spi_csr.CSR.dlybct = options->trans_delay;
800050d0:	f7 38 00 0a 	ld.ub	r8,r11[10]
800050d4:	f5 d8 d3 08 	bfins	r10,r8,0x18,0x8

  switch(options->reg) {
800050d8:	17 88       	ld.ub	r8,r11[0x0]
800050da:	30 19       	mov	r9,1
800050dc:	f2 08 18 00 	cp.b	r8,r9
800050e0:	c0 e0       	breq	800050fc <spi_setupChipReg+0xaa>
800050e2:	c0 a3       	brcs	800050f6 <spi_setupChipReg+0xa4>
800050e4:	30 29       	mov	r9,2
800050e6:	f2 08 18 00 	cp.b	r8,r9
800050ea:	c0 c0       	breq	80005102 <spi_setupChipReg+0xb0>
800050ec:	30 39       	mov	r9,3
800050ee:	f2 08 18 00 	cp.b	r8,r9
800050f2:	c0 e1       	brne	8000510e <spi_setupChipReg+0xbc>
800050f4:	c0 a8       	rjmp	80005108 <spi_setupChipReg+0xb6>
    case 0:
      spi->csr0 = u_avr32_spi_csr.csr;
800050f6:	99 ca       	st.w	r12[0x30],r10
800050f8:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
      break;
    case 1:
      spi->csr1 = u_avr32_spi_csr.csr;
800050fc:	99 da       	st.w	r12[0x34],r10
800050fe:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
      break;
    case 2:
      spi->csr2 = u_avr32_spi_csr.csr;
80005102:	99 ea       	st.w	r12[0x38],r10
80005104:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
      break;
    case 3:
      spi->csr3 = u_avr32_spi_csr.csr;
80005108:	99 fa       	st.w	r12[0x3c],r10
8000510a:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
      break;
8000510e:	30 2c       	mov	r12,2
    }
  }
#endif

  return SPI_OK;
}
80005110:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

80005114 <spi_enable>:


void spi_enable(volatile avr32_spi_t *spi)
{
  spi->cr = AVR32_SPI_CR_SPIEN_MASK;
80005114:	30 18       	mov	r8,1
80005116:	99 08       	st.w	r12[0x0],r8
}
80005118:	5e fc       	retal	r12

8000511a <spi_write>:
  return ((spi->sr & AVR32_SPI_SR_TDRE_MASK) != 0);
}


spi_status_t spi_write(volatile avr32_spi_t *spi, unsigned short data)
{
8000511a:	e0 68 27 10 	mov	r8,10000
  unsigned int timeout = SPI_TIMEOUT;

  while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
8000511e:	c0 58       	rjmp	80005128 <spi_write+0xe>
    if (!timeout--) {
80005120:	58 08       	cp.w	r8,0
80005122:	c0 21       	brne	80005126 <spi_write+0xc>
80005124:	5e ff       	retal	1
80005126:	20 18       	sub	r8,1

spi_status_t spi_write(volatile avr32_spi_t *spi, unsigned short data)
{
  unsigned int timeout = SPI_TIMEOUT;

  while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80005128:	78 49       	ld.w	r9,r12[0x10]
8000512a:	e2 19 00 02 	andl	r9,0x2,COH
8000512e:	cf 90       	breq	80005120 <spi_write+0x6>
    if (!timeout--) {
      return SPI_ERROR_TIMEOUT;
    }
  }

  spi->tdr = data << AVR32_SPI_TDR_TD_OFFSET;
80005130:	5c 7b       	castu.h	r11
80005132:	99 3b       	st.w	r12[0xc],r11
80005134:	5e fd       	retal	0

80005136 <spi_read>:
  return ((spi->sr & AVR32_SPI_SR_RDRF_MASK) != 0);
}


spi_status_t spi_read(volatile avr32_spi_t *spi, unsigned short *data)
{
80005136:	e0 68 27 10 	mov	r8,10000
  unsigned int timeout = SPI_TIMEOUT;

  while ((spi->sr & (AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) !=
8000513a:	c0 58       	rjmp	80005144 <spi_read+0xe>
         (AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) {
    if (!timeout--) {
8000513c:	58 08       	cp.w	r8,0
8000513e:	c0 21       	brne	80005142 <spi_read+0xc>
80005140:	5e ff       	retal	1
80005142:	20 18       	sub	r8,1

spi_status_t spi_read(volatile avr32_spi_t *spi, unsigned short *data)
{
  unsigned int timeout = SPI_TIMEOUT;

  while ((spi->sr & (AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) !=
80005144:	78 49       	ld.w	r9,r12[0x10]
80005146:	e2 19 02 01 	andl	r9,0x201,COH
8000514a:	e0 49 02 01 	cp.w	r9,513
8000514e:	cf 71       	brne	8000513c <spi_read+0x6>
    if (!timeout--) {
      return SPI_ERROR_TIMEOUT;
    }
  }

  *data = spi->rdr >> AVR32_SPI_RDR_RD_OFFSET;
80005150:	78 28       	ld.w	r8,r12[0x8]
80005152:	b6 08       	st.h	r11[0x0],r8
80005154:	5e fd       	retal	0

80005156 <tc_init_waveform>:


int tc_init_waveform(volatile avr32_tc_t *tc, const tc_waveform_opt_t *opt)
{
  // Check for valid input.
  if (opt->channel >= TC_NUMBER_OF_CHANNELS)
80005156:	76 09       	ld.w	r9,r11[0x0]
80005158:	58 29       	cp.w	r9,2
8000515a:	e0 88 00 03 	brls	80005160 <tc_init_waveform+0xa>
8000515e:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  // GENERATE SIGNALS: Waveform operating mode.
  tc->channel[opt->channel].cmr = opt->bswtrg << AVR32_TC_BSWTRG_OFFSET |
80005160:	76 18       	ld.w	r8,r11[0x4]
80005162:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
80005166:	af ba       	sbr	r10,0xf
80005168:	10 9b       	mov	r11,r8
8000516a:	e6 1b c0 00 	andh	r11,0xc000,COH
8000516e:	16 4a       	or	r10,r11
80005170:	10 9b       	mov	r11,r8
80005172:	e6 1b 30 00 	andh	r11,0x3000,COH
80005176:	16 4a       	or	r10,r11
80005178:	10 9b       	mov	r11,r8
8000517a:	e6 1b 0c 00 	andh	r11,0xc00,COH
8000517e:	16 4a       	or	r10,r11
80005180:	10 9b       	mov	r11,r8
80005182:	e6 1b 03 00 	andh	r11,0x300,COH
80005186:	16 4a       	or	r10,r11
80005188:	10 9b       	mov	r11,r8
8000518a:	e6 1b 00 c0 	andh	r11,0xc0,COH
8000518e:	16 4a       	or	r10,r11
80005190:	10 9b       	mov	r11,r8
80005192:	e6 1b 00 30 	andh	r11,0x30,COH
80005196:	16 4a       	or	r10,r11
80005198:	10 9b       	mov	r11,r8
8000519a:	e6 1b 00 0c 	andh	r11,0xc,COH
8000519e:	16 4a       	or	r10,r11
800051a0:	10 9b       	mov	r11,r8
800051a2:	e6 1b 00 03 	andh	r11,0x3,COH
800051a6:	16 4a       	or	r10,r11
800051a8:	10 9b       	mov	r11,r8
800051aa:	e2 1b 60 00 	andl	r11,0x6000,COH
800051ae:	16 4a       	or	r10,r11
800051b0:	f7 d8 c1 81 	bfextu	r11,r8,0xc,0x1
800051b4:	f5 eb 10 ca 	or	r10,r10,r11<<0xc
800051b8:	10 9b       	mov	r11,r8
800051ba:	e2 1b 0c 00 	andl	r11,0xc00,COH
800051be:	16 4a       	or	r10,r11
800051c0:	10 9b       	mov	r11,r8
800051c2:	e2 1b 03 00 	andl	r11,0x300,COH
800051c6:	16 4a       	or	r10,r11
800051c8:	f7 d8 c0 e1 	bfextu	r11,r8,0x7,0x1
800051cc:	f5 eb 10 7a 	or	r10,r10,r11<<0x7
800051d0:	f7 d8 c0 c1 	bfextu	r11,r8,0x6,0x1
800051d4:	f5 eb 10 6a 	or	r10,r10,r11<<0x6
800051d8:	10 9b       	mov	r11,r8
800051da:	e2 1b 00 30 	andl	r11,0x30,COH
800051de:	16 4a       	or	r10,r11
800051e0:	f1 d8 c0 61 	bfextu	r8,r8,0x3,0x1
800051e4:	f5 e8 10 38 	or	r8,r10,r8<<0x3
800051e8:	a5 69       	lsl	r9,0x4
800051ea:	2f f9       	sub	r9,-1
800051ec:	f8 09 09 28 	st.w	r12[r9<<0x2],r8
800051f0:	5e fd       	retal	0

800051f2 <tc_start>:


int tc_start(volatile avr32_tc_t *tc, unsigned int channel)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
800051f2:	58 2b       	cp.w	r11,2
800051f4:	e0 88 00 03 	brls	800051fa <tc_start+0x8>
800051f8:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  // Enable, reset and start the selected timer/counter channel.
  tc->channel[channel].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
800051fa:	a7 6b       	lsl	r11,0x6
800051fc:	16 0c       	add	r12,r11
800051fe:	30 58       	mov	r8,5
80005200:	99 08       	st.w	r12[0x0],r8
80005202:	5e fd       	retal	0

80005204 <tc_read_sr>:


int tc_read_sr(volatile avr32_tc_t *tc, unsigned int channel)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80005204:	58 2b       	cp.w	r11,2
80005206:	e0 88 00 03 	brls	8000520c <tc_read_sr+0x8>
8000520a:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  return tc->channel[channel].sr;
8000520c:	a7 6b       	lsl	r11,0x6
8000520e:	2e 0b       	sub	r11,-32
80005210:	16 0c       	add	r12,r11
80005212:	78 0c       	ld.w	r12,r12[0x0]
}
80005214:	5e fc       	retal	r12

80005216 <tc_write_rc>:


int tc_write_rc(volatile avr32_tc_t *tc, unsigned int channel, unsigned short value)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80005216:	58 2b       	cp.w	r11,2
80005218:	e0 88 00 03 	brls	8000521e <tc_write_rc+0x8>
8000521c:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  // This function is only available in WAVEFORM mode.
  if (Tst_bits(tc->channel[channel].cmr, AVR32_TC_WAVE_MASK))
8000521e:	f6 08 15 04 	lsl	r8,r11,0x4
80005222:	2f f8       	sub	r8,-1
80005224:	f8 08 03 28 	ld.w	r8,r12[r8<<0x2]
80005228:	e2 18 80 00 	andl	r8,0x8000,COH
8000522c:	c0 c0       	breq	80005244 <tc_write_rc+0x2e>
    Wr_bitfield(tc->channel[channel].rc, AVR32_TC_RC_MASK, value);
8000522e:	a7 6b       	lsl	r11,0x6
80005230:	16 0c       	add	r12,r11
80005232:	2e 4c       	sub	r12,-28
80005234:	78 08       	ld.w	r8,r12[0x0]
80005236:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
8000523a:	e0 18 00 00 	andl	r8,0x0
8000523e:	f3 e8 10 08 	or	r8,r9,r8
80005242:	99 08       	st.w	r12[0x0],r8

  return value;
80005244:	f9 da c0 10 	bfextu	r12,r10,0x0,0x10
}
80005248:	5e fc       	retal	r12

8000524a <tc_configure_interrupts>:
  return tc->channel[channel].imr;
}


int tc_configure_interrupts(volatile avr32_tc_t *tc, unsigned int channel, const tc_interrupt_t *bitfield)
{
8000524a:	eb cd 40 fc 	pushm	r2-r7,lr
  bool global_interrupt_enabled = Is_global_interrupt_enabled();
8000524e:	e1 b9 00 00 	mfsr	r9,0x0

  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80005252:	58 2b       	cp.w	r11,2
80005254:	e0 88 00 04 	brls	8000525c <tc_configure_interrupts+0x12>
80005258:	e3 cf c0 fc 	ldm	sp++,r2-r7,pc,r12=-1
	return flags;
}

static inline bool cpu_irq_is_enabled_flags(irqflags_t flags)
{
	return !(flags & AVR32_SR_GM_MASK);
8000525c:	ee 19 00 01 	eorh	r9,0x1
80005260:	f3 d9 c2 01 	bfextu	r9,r9,0x10,0x1
    return TC_INVALID_ARGUMENT;

  // Enable the appropriate interrupts.
  tc->channel[channel].ier = bitfield->etrgs << AVR32_TC_ETRGS_OFFSET |
80005264:	74 08       	ld.w	r8,r10[0x0]
80005266:	ef d8 c0 e1 	bfextu	r7,r8,0x7,0x1
8000526a:	fd d8 c0 c1 	bfextu	lr,r8,0x6,0x1
8000526e:	a7 6e       	lsl	lr,0x6
80005270:	fd e7 10 7e 	or	lr,lr,r7<<0x7
80005274:	ef d8 c0 01 	bfextu	r7,r8,0x0,0x1
80005278:	0e 4e       	or	lr,r7
8000527a:	ef d8 c0 a1 	bfextu	r7,r8,0x5,0x1
8000527e:	fd e7 10 5e 	or	lr,lr,r7<<0x5
80005282:	ef d8 c0 81 	bfextu	r7,r8,0x4,0x1
80005286:	fd e7 10 4e 	or	lr,lr,r7<<0x4
8000528a:	ef d8 c0 61 	bfextu	r7,r8,0x3,0x1
8000528e:	fd e7 10 3e 	or	lr,lr,r7<<0x3
80005292:	ef d8 c0 41 	bfextu	r7,r8,0x2,0x1
80005296:	fd e7 10 2e 	or	lr,lr,r7<<0x2
8000529a:	f1 d8 c0 21 	bfextu	r8,r8,0x1,0x1
8000529e:	fd e8 10 18 	or	r8,lr,r8<<0x1
800052a2:	f6 0e 15 06 	lsl	lr,r11,0x6
800052a6:	f8 0e 00 0e 	add	lr,r12,lr
800052aa:	2d ce       	sub	lr,-36
800052ac:	9d 08       	st.w	lr[0x0],r8
                             bitfield->cpas << AVR32_TC_CPAS_OFFSET |
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;

  // Disable the appropriate interrupts.
  if (global_interrupt_enabled) Disable_global_interrupt();
800052ae:	58 09       	cp.w	r9,0
800052b0:	c0 20       	breq	800052b4 <tc_configure_interrupts+0x6a>
800052b2:	d3 03       	ssrf	0x10
  tc->channel[channel].idr = (~bitfield->etrgs & 1) << AVR32_TC_ETRGS_OFFSET |
800052b4:	74 08       	ld.w	r8,r10[0x0]
800052b6:	f1 d8 c0 e1 	bfextu	r8,r8,0x7,0x1
800052ba:	e0 65 00 80 	mov	r5,128
800052be:	f9 b5 01 00 	movne	r5,0
                             (~bitfield->ldrbs & 1) << AVR32_TC_LDRBS_OFFSET |
800052c2:	74 08       	ld.w	r8,r10[0x0]
800052c4:	f1 d8 c0 c1 	bfextu	r8,r8,0x6,0x1
800052c8:	f9 b4 00 40 	moveq	r4,64
800052cc:	f9 b4 01 00 	movne	r4,0
                             (~bitfield->ldras & 1) << AVR32_TC_LDRAS_OFFSET |
800052d0:	74 08       	ld.w	r8,r10[0x0]
800052d2:	f1 d8 c0 a1 	bfextu	r8,r8,0x5,0x1
800052d6:	f9 b3 00 20 	moveq	r3,32
800052da:	f9 b3 01 00 	movne	r3,0
                             (~bitfield->cpcs & 1) << AVR32_TC_CPCS_OFFSET |
800052de:	74 08       	ld.w	r8,r10[0x0]
800052e0:	f1 d8 c0 81 	bfextu	r8,r8,0x4,0x1
800052e4:	f9 b2 00 10 	moveq	r2,16
800052e8:	f9 b2 01 00 	movne	r2,0
                             (~bitfield->cpbs & 1) << AVR32_TC_CPBS_OFFSET |
800052ec:	74 08       	ld.w	r8,r10[0x0]
800052ee:	f1 d8 c0 61 	bfextu	r8,r8,0x3,0x1
800052f2:	f9 b6 00 08 	moveq	r6,8
800052f6:	f9 b6 01 00 	movne	r6,0
                             (~bitfield->cpas & 1) << AVR32_TC_CPAS_OFFSET |
800052fa:	74 08       	ld.w	r8,r10[0x0]
800052fc:	f1 d8 c0 41 	bfextu	r8,r8,0x2,0x1
80005300:	f9 b7 00 04 	moveq	r7,4
80005304:	f9 b7 01 00 	movne	r7,0
                             (~bitfield->lovrs & 1) << AVR32_TC_LOVRS_OFFSET |
80005308:	74 08       	ld.w	r8,r10[0x0]
8000530a:	f1 d8 c0 21 	bfextu	r8,r8,0x1,0x1
8000530e:	f9 be 00 02 	moveq	lr,2
80005312:	f9 be 01 00 	movne	lr,0
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;

  // Disable the appropriate interrupts.
  if (global_interrupt_enabled) Disable_global_interrupt();
  tc->channel[channel].idr = (~bitfield->etrgs & 1) << AVR32_TC_ETRGS_OFFSET |
80005316:	74 08       	ld.w	r8,r10[0x0]
80005318:	ec 18 00 01 	eorl	r8,0x1
8000531c:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80005320:	eb e8 10 08 	or	r8,r5,r8
80005324:	08 48       	or	r8,r4
80005326:	06 48       	or	r8,r3
80005328:	04 48       	or	r8,r2
8000532a:	0c 48       	or	r8,r6
8000532c:	0e 48       	or	r8,r7
8000532e:	1c 48       	or	r8,lr
80005330:	f6 0a 15 06 	lsl	r10,r11,0x6
80005334:	f8 0a 00 0a 	add	r10,r12,r10
80005338:	2d 8a       	sub	r10,-40
8000533a:	95 08       	st.w	r10[0x0],r8
                             (~bitfield->cpcs & 1) << AVR32_TC_CPCS_OFFSET |
                             (~bitfield->cpbs & 1) << AVR32_TC_CPBS_OFFSET |
                             (~bitfield->cpas & 1) << AVR32_TC_CPAS_OFFSET |
                             (~bitfield->lovrs & 1) << AVR32_TC_LOVRS_OFFSET |
                             (~bitfield->covfs & 1) << AVR32_TC_COVFS_OFFSET;
  tc->channel[channel].sr;
8000533c:	a7 6b       	lsl	r11,0x6
8000533e:	2e 0b       	sub	r11,-32
80005340:	16 0c       	add	r12,r11
80005342:	78 08       	ld.w	r8,r12[0x0]
  if (global_interrupt_enabled) Enable_global_interrupt();
80005344:	58 09       	cp.w	r9,0
80005346:	c0 31       	brne	8000534c <tc_configure_interrupts+0x102>
80005348:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0
8000534c:	d5 03       	csrf	0x10
8000534e:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0

80005352 <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
80005352:	d4 01       	pushm	lr
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
80005354:	f6 08 15 04 	lsl	r8,r11,0x4
80005358:	14 38       	cp.w	r8,r10
8000535a:	f9 b8 08 10 	movls	r8,16
8000535e:	f9 b8 0b 08 	movhi	r8,8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
80005362:	f0 0b 02 4b 	mul	r11,r8,r11
80005366:	f6 09 16 01 	lsr	r9,r11,0x1
8000536a:	f2 0a 00 3a 	add	r10,r9,r10<<0x3
8000536e:	f4 0b 0d 0a 	divu	r10,r10,r11
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
80005372:	f4 09 16 03 	lsr	r9,r10,0x3
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
80005376:	f2 cb 00 01 	sub	r11,r9,1
8000537a:	e0 4b ff fe 	cp.w	r11,65534
8000537e:	e0 88 00 03 	brls	80005384 <usart_set_async_baudrate+0x32>
80005382:	da 0a       	popm	pc,r12=1
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
80005384:	78 1b       	ld.w	r11,r12[0x4]
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
80005386:	e8 6e 00 00 	mov	lr,524288
8000538a:	59 08       	cp.w	r8,16
8000538c:	fc 08 17 10 	movne	r8,lr
80005390:	f9 b8 00 00 	moveq	r8,0
80005394:	e4 1b ff f7 	andh	r11,0xfff7
80005398:	e0 1b fe cf 	andl	r11,0xfecf
8000539c:	16 48       	or	r8,r11
8000539e:	99 18       	st.w	r12[0x4],r8
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
800053a0:	f5 da c0 03 	bfextu	r10,r10,0x0,0x3
800053a4:	f3 ea 11 09 	or	r9,r9,r10<<0x10
800053a8:	99 89       	st.w	r12[0x20],r9
800053aa:	d8 0a       	popm	pc,r12=0

800053ac <usart_write_char>:
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
800053ac:	78 58       	ld.w	r8,r12[0x14]
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
  if (usart_tx_ready(usart))
800053ae:	e2 18 00 02 	andl	r8,0x2,COH
800053b2:	c0 31       	brne	800053b8 <usart_write_char+0xc>
800053b4:	30 2c       	mov	r12,2
800053b6:	5e fc       	retal	r12
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
800053b8:	f7 db c0 09 	bfextu	r11,r11,0x0,0x9
800053bc:	99 7b       	st.w	r12[0x1c],r11
800053be:	5e fd       	retal	0

800053c0 <usart_putchar>:
    return USART_TX_BUSY;
}


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
800053c0:	eb cd 40 e0 	pushm	r5-r7,lr
800053c4:	18 96       	mov	r6,r12
800053c6:	16 95       	mov	r5,r11
800053c8:	e0 67 27 0f 	mov	r7,9999
800053cc:	c0 68       	rjmp	800053d8 <usart_putchar+0x18>
  int timeout = USART_DEFAULT_TIMEOUT;

  do
  {
    if (!timeout--) return USART_FAILURE;
800053ce:	58 07       	cp.w	r7,0
800053d0:	c0 31       	brne	800053d6 <usart_putchar+0x16>
800053d2:	e3 cf c0 e0 	ldm	sp++,r5-r7,pc,r12=-1
800053d6:	20 17       	sub	r7,1
  } while (usart_write_char(usart, c) != USART_SUCCESS);
800053d8:	0a 9b       	mov	r11,r5
800053da:	0c 9c       	mov	r12,r6
800053dc:	f0 1f 00 03 	mcall	800053e8 <usart_putchar+0x28>
800053e0:	cf 71       	brne	800053ce <usart_putchar+0xe>

  return USART_SUCCESS;
}
800053e2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800053e6:	00 00       	add	r0,r0
800053e8:	80 00       	ld.sh	r0,r0[0x0]
800053ea:	53 ac       	stdsp	sp[0xe8],r12

800053ec <usart_read_char>:

int usart_read_char(volatile avr32_usart_t *usart, int *c)
{
  // Check for errors: frame, parity and overrun. In RS485 mode, a parity error
  // would mean that an address char has been received.
  if (usart->csr & (AVR32_USART_CSR_OVRE_MASK |
800053ec:	78 58       	ld.w	r8,r12[0x14]
800053ee:	e2 18 00 e0 	andl	r8,0xe0,COH
800053f2:	c0 30       	breq	800053f8 <usart_read_char+0xc>
800053f4:	30 4c       	mov	r12,4
800053f6:	5e fc       	retal	r12
 *
 * \return \c 1 if the USART Receive Holding Register is full, otherwise \c 0.
 */
__always_inline static int usart_test_hit(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_RXRDY_MASK) != 0;
800053f8:	78 58       	ld.w	r8,r12[0x14]
                    AVR32_USART_CSR_FRAME_MASK |
                    AVR32_USART_CSR_PARE_MASK))
    return USART_RX_ERROR;

  // No error; if we really did receive a char, read it and return SUCCESS.
  if (usart_test_hit(usart))
800053fa:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800053fe:	c0 31       	brne	80005404 <usart_read_char+0x18>
80005400:	30 3c       	mov	r12,3
80005402:	5e fc       	retal	r12
  {
    *c = (usart->rhr & AVR32_USART_RHR_RXCHR_MASK) >> AVR32_USART_RHR_RXCHR_OFFSET;
80005404:	78 68       	ld.w	r8,r12[0x18]
80005406:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
8000540a:	97 08       	st.w	r11[0x0],r8
8000540c:	5e fd       	retal	0
8000540e:	d7 03       	nop

80005410 <usart_getchar>:
    return USART_RX_EMPTY;
}


int usart_getchar(volatile avr32_usart_t *usart)
{
80005410:	eb cd 40 c0 	pushm	r6-r7,lr
80005414:	20 1d       	sub	sp,4
80005416:	18 96       	mov	r6,r12
  int c, ret;

  while ((ret = usart_read_char(usart, &c)) == USART_RX_EMPTY);
80005418:	1a 97       	mov	r7,sp
8000541a:	1a 9b       	mov	r11,sp
8000541c:	0c 9c       	mov	r12,r6
8000541e:	f0 1f 00 07 	mcall	80005438 <usart_getchar+0x28>
80005422:	58 3c       	cp.w	r12,3
80005424:	cf b0       	breq	8000541a <usart_getchar+0xa>

  if (ret == USART_RX_ERROR)
80005426:	58 4c       	cp.w	r12,4
80005428:	f9 bc 00 ff 	moveq	r12,-1
    return USART_FAILURE;

  return c;
8000542c:	fb fc 10 00 	ld.wne	r12,sp[0x0]
}
80005430:	2f fd       	sub	sp,-4
80005432:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005436:	00 00       	add	r0,r0
80005438:	80 00       	ld.sh	r0,r0[0x0]
8000543a:	53 ec       	stdsp	sp[0xf8],r12

8000543c <usart_write_line>:


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
8000543c:	eb cd 40 c0 	pushm	r6-r7,lr
80005440:	18 96       	mov	r6,r12
80005442:	16 97       	mov	r7,r11
  while (*string != '\0')
80005444:	17 8b       	ld.ub	r11,r11[0x0]
80005446:	58 0b       	cp.w	r11,0
80005448:	c0 80       	breq	80005458 <usart_write_line+0x1c>
    usart_putchar(usart, *string++);
8000544a:	2f f7       	sub	r7,-1
8000544c:	0c 9c       	mov	r12,r6
8000544e:	f0 1f 00 04 	mcall	8000545c <usart_write_line+0x20>
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
80005452:	0f 8b       	ld.ub	r11,r7[0x0]
80005454:	58 0b       	cp.w	r11,0
80005456:	cf a1       	brne	8000544a <usart_write_line+0xe>
80005458:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000545c:	80 00       	ld.sh	r0,r0[0x0]
8000545e:	53 c0       	stdsp	sp[0xf0],r0

80005460 <usart_reset>:
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
80005460:	e1 b8 00 00 	mfsr	r8,0x0

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
80005464:	e6 18 00 01 	andh	r8,0x1,COH
80005468:	c0 71       	brne	80005476 <usart_reset+0x16>
8000546a:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
8000546c:	3f f8       	mov	r8,-1
8000546e:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80005470:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
80005472:	d5 03       	csrf	0x10
80005474:	c0 48       	rjmp	8000547c <usart_reset+0x1c>
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
  usart->idr = 0xFFFFFFFF;
80005476:	3f f8       	mov	r8,-1
80005478:	99 38       	st.w	r12[0xc],r8
  usart->csr;
8000547a:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
8000547c:	30 08       	mov	r8,0
8000547e:	99 18       	st.w	r12[0x4],r8
  usart->rtor = 0;
80005480:	99 98       	st.w	r12[0x24],r8
  usart->ttgr = 0;
80005482:	99 a8       	st.w	r12[0x28],r8

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
80005484:	ea 68 61 0c 	mov	r8,680204
80005488:	99 08       	st.w	r12[0x0],r8
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
8000548a:	5e fc       	retal	r12

8000548c <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
8000548c:	eb cd 40 e0 	pushm	r5-r7,lr
80005490:	18 96       	mov	r6,r12
80005492:	16 97       	mov	r7,r11
80005494:	14 95       	mov	r5,r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
80005496:	f0 1f 00 2f 	mcall	80005550 <usart_init_rs232+0xc4>

  // Check input values.
  if (!opt || // Null pointer.
8000549a:	58 07       	cp.w	r7,0
8000549c:	c5 80       	breq	8000554c <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
8000549e:	0f c8       	ld.ub	r8,r7[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
800054a0:	30 49       	mov	r9,4
800054a2:	f2 08 18 00 	cp.b	r8,r9
800054a6:	e0 88 00 53 	brls	8000554c <usart_init_rs232+0xc0>
800054aa:	30 99       	mov	r9,9
800054ac:	f2 08 18 00 	cp.b	r8,r9
800054b0:	e0 8b 00 4e 	brhi	8000554c <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
800054b4:	0f d9       	ld.ub	r9,r7[0x5]
800054b6:	30 78       	mov	r8,7
800054b8:	f0 09 18 00 	cp.b	r9,r8
800054bc:	e0 8b 00 48 	brhi	8000554c <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
800054c0:	8e 39       	ld.sh	r9,r7[0x6]
800054c2:	e0 68 01 01 	mov	r8,257
800054c6:	f0 09 19 00 	cp.h	r9,r8
800054ca:	e0 8b 00 41 	brhi	8000554c <usart_init_rs232+0xc0>
      opt->channelmode > 3 ||
800054ce:	ef 39 00 08 	ld.ub	r9,r7[8]
800054d2:	30 38       	mov	r8,3
800054d4:	f0 09 18 00 	cp.b	r9,r8
800054d8:	e0 8b 00 3a 	brhi	8000554c <usart_init_rs232+0xc0>
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
800054dc:	0a 9a       	mov	r10,r5
800054de:	6e 0b       	ld.w	r11,r7[0x0]
800054e0:	0c 9c       	mov	r12,r6
800054e2:	f0 1f 00 1d 	mcall	80005554 <usart_init_rs232+0xc8>
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
800054e6:	58 1c       	cp.w	r12,1
800054e8:	c3 20       	breq	8000554c <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;

  if (opt->charlength == 9)
800054ea:	0f c8       	ld.ub	r8,r7[0x4]
800054ec:	30 99       	mov	r9,9
800054ee:	f2 08 18 00 	cp.b	r8,r9
800054f2:	c0 51       	brne	800054fc <usart_init_rs232+0x70>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
800054f4:	6c 18       	ld.w	r8,r6[0x4]
800054f6:	b1 b8       	sbr	r8,0x11
800054f8:	8d 18       	st.w	r6[0x4],r8
800054fa:	c0 68       	rjmp	80005506 <usart_init_rs232+0x7a>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
800054fc:	6c 19       	ld.w	r9,r6[0x4]
800054fe:	20 58       	sub	r8,5
80005500:	f3 e8 10 68 	or	r8,r9,r8<<0x6
80005504:	8d 18       	st.w	r6[0x4],r8
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
80005506:	6c 19       	ld.w	r9,r6[0x4]
80005508:	ef 3a 00 08 	ld.ub	r10,r7[8]
8000550c:	0f d8       	ld.ub	r8,r7[0x5]
8000550e:	a9 78       	lsl	r8,0x9
80005510:	f1 ea 10 e8 	or	r8,r8,r10<<0xe
80005514:	12 48       	or	r8,r9
80005516:	8d 18       	st.w	r6[0x4],r8
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
80005518:	8e 38       	ld.sh	r8,r7[0x6]
8000551a:	30 29       	mov	r9,2
8000551c:	f2 08 19 00 	cp.h	r8,r9
80005520:	e0 88 00 09 	brls	80005532 <usart_init_rs232+0xa6>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
80005524:	6c 18       	ld.w	r8,r6[0x4]
80005526:	ad b8       	sbr	r8,0xd
80005528:	8d 18       	st.w	r6[0x4],r8
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
8000552a:	8e b8       	ld.uh	r8,r7[0x6]
8000552c:	20 28       	sub	r8,2
8000552e:	8d a8       	st.w	r6[0x28],r8
80005530:	c0 68       	rjmp	8000553c <usart_init_rs232+0xb0>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
80005532:	6c 19       	ld.w	r9,r6[0x4]
80005534:	5c 78       	castu.h	r8
80005536:	f3 e8 10 c8 	or	r8,r9,r8<<0xc
8000553a:	8d 18       	st.w	r6[0x4],r8

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
8000553c:	6c 18       	ld.w	r8,r6[0x4]
8000553e:	e0 18 ff f0 	andl	r8,0xfff0
80005542:	8d 18       	st.w	r6[0x4],r8
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
80005544:	35 08       	mov	r8,80
80005546:	8d 08       	st.w	r6[0x0],r8
80005548:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
8000554c:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
80005550:	80 00       	ld.sh	r0,r0[0x0]
80005552:	54 60       	stdsp	sp[0x118],r0
80005554:	80 00       	ld.sh	r0,r0[0x0]
80005556:	53 52       	stdsp	sp[0xd4],r2

80005558 <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
80005558:	f8 c8 ff f8 	sub	r8,r12,-8
8000555c:	99 18       	st.w	r12[0x4],r8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
8000555e:	3f f9       	mov	r9,-1
80005560:	99 29       	st.w	r12[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
80005562:	99 38       	st.w	r12[0xc],r8
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
80005564:	99 48       	st.w	r12[0x10],r8

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
80005566:	30 08       	mov	r8,0
80005568:	99 08       	st.w	r12[0x0],r8
}
8000556a:	5e fc       	retal	r12

8000556c <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
8000556c:	30 08       	mov	r8,0
8000556e:	99 48       	st.w	r12[0x10],r8
}
80005570:	5e fc       	retal	r12

80005572 <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
80005572:	78 18       	ld.w	r8,r12[0x4]

	pxNewListItem->pxNext = pxIndex->pxNext;
80005574:	70 19       	ld.w	r9,r8[0x4]
80005576:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
80005578:	78 19       	ld.w	r9,r12[0x4]
8000557a:	97 29       	st.w	r11[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
8000557c:	70 19       	ld.w	r9,r8[0x4]
8000557e:	93 2b       	st.w	r9[0x8],r11
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
80005580:	91 1b       	st.w	r8[0x4],r11
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
80005582:	99 1b       	st.w	r12[0x4],r11

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80005584:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80005586:	78 08       	ld.w	r8,r12[0x0]
80005588:	2f f8       	sub	r8,-1
8000558a:	99 08       	st.w	r12[0x0],r8
}
8000558c:	5e fc       	retal	r12

8000558e <vListInsert>:
{
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
8000558e:	76 0a       	ld.w	r10,r11[0x0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
80005590:	5b fa       	cp.w	r10,-1
80005592:	c0 31       	brne	80005598 <vListInsert+0xa>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
80005594:	78 48       	ld.w	r8,r12[0x10]
80005596:	c0 c8       	rjmp	800055ae <vListInsert+0x20>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
80005598:	f8 c8 ff f8 	sub	r8,r12,-8
8000559c:	70 19       	ld.w	r9,r8[0x4]
8000559e:	72 09       	ld.w	r9,r9[0x0]
800055a0:	12 3a       	cp.w	r10,r9
800055a2:	c0 63       	brcs	800055ae <vListInsert+0x20>
800055a4:	70 18       	ld.w	r8,r8[0x4]
800055a6:	70 19       	ld.w	r9,r8[0x4]
800055a8:	72 09       	ld.w	r9,r9[0x0]
800055aa:	12 3a       	cp.w	r10,r9
800055ac:	cf c2       	brcc	800055a4 <vListInsert+0x16>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
800055ae:	70 19       	ld.w	r9,r8[0x4]
800055b0:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
800055b2:	93 2b       	st.w	r9[0x8],r11
	pxNewListItem->pxPrevious = pxIterator;
800055b4:	97 28       	st.w	r11[0x8],r8
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
800055b6:	91 1b       	st.w	r8[0x4],r11

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
800055b8:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
800055ba:	78 08       	ld.w	r8,r12[0x0]
800055bc:	2f f8       	sub	r8,-1
800055be:	99 08       	st.w	r12[0x0],r8
}
800055c0:	5e fc       	retal	r12

800055c2 <vListRemove>:

void vListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
800055c2:	78 18       	ld.w	r8,r12[0x4]
800055c4:	78 29       	ld.w	r9,r12[0x8]
800055c6:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
800055c8:	78 28       	ld.w	r8,r12[0x8]
800055ca:	78 19       	ld.w	r9,r12[0x4]
800055cc:	91 19       	st.w	r8[0x4],r9

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
800055ce:	78 48       	ld.w	r8,r12[0x10]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
800055d0:	70 19       	ld.w	r9,r8[0x4]
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
800055d2:	18 39       	cp.w	r9,r12
800055d4:	f9 f9 00 02 	ld.weq	r9,r12[0x8]
800055d8:	f1 f9 0a 01 	st.weq	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
800055dc:	30 09       	mov	r9,0
800055de:	99 49       	st.w	r12[0x10],r9
	( pxList->uxNumberOfItems )--;
800055e0:	70 09       	ld.w	r9,r8[0x0]
800055e2:	20 19       	sub	r9,1
800055e4:	91 09       	st.w	r8[0x0],r9
}
800055e6:	5e fc       	retal	r12

800055e8 <pxPortInitialiseStack>:
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x08080808;					/* R8 */
800055e8:	e0 68 08 08 	mov	r8,2056
800055ec:	ea 18 08 08 	orh	r8,0x808
800055f0:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x09090909;					/* R9 */
800055f2:	e0 68 09 09 	mov	r8,2313
800055f6:	ea 18 09 09 	orh	r8,0x909
800055fa:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0A0A0A0A;					/* R10 */
800055fc:	e0 68 0a 0a 	mov	r8,2570
80005600:	ea 18 0a 0a 	orh	r8,0xa0a
80005604:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0B0B0B0B;					/* R11 */
80005606:	e0 68 0b 0b 	mov	r8,2827
8000560a:	ea 18 0b 0b 	orh	r8,0xb0b
8000560e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pvParameters;					/* R12 */
80005610:	18 da       	st.w	--r12,r10
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xDEADBEEF;					/* R14/LR */
80005612:	e0 68 be ef 	mov	r8,48879
80005616:	ea 18 de ad 	orh	r8,0xdead
8000561a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
8000561c:	18 db       	st.w	--r12,r11
	*pxTopOfStack-- = ( portSTACK_TYPE ) portINITIAL_SR;				/* SR */
8000561e:	fc 18 00 40 	movh	r8,0x40
80005622:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xFF0000FF;					/* R0 */
80005624:	e0 68 00 ff 	mov	r8,255
80005628:	ea 18 ff 00 	orh	r8,0xff00
8000562c:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x01010101;					/* R1 */
8000562e:	e0 68 01 01 	mov	r8,257
80005632:	ea 18 01 01 	orh	r8,0x101
80005636:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x02020202;					/* R2 */
80005638:	e0 68 02 02 	mov	r8,514
8000563c:	ea 18 02 02 	orh	r8,0x202
80005640:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x03030303;					/* R3 */
80005642:	e0 68 03 03 	mov	r8,771
80005646:	ea 18 03 03 	orh	r8,0x303
8000564a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x04040404;					/* R4 */
8000564c:	e0 68 04 04 	mov	r8,1028
80005650:	ea 18 04 04 	orh	r8,0x404
80005654:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x05050505;					/* R5 */
80005656:	e0 68 05 05 	mov	r8,1285
8000565a:	ea 18 05 05 	orh	r8,0x505
8000565e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x06060606;					/* R6 */
80005660:	e0 68 06 06 	mov	r8,1542
80005664:	ea 18 06 06 	orh	r8,0x606
80005668:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x07070707;					/* R7 */
8000566a:	e0 68 07 07 	mov	r8,1799
8000566e:	ea 18 07 07 	orh	r8,0x707
80005672:	18 d8       	st.w	--r12,r8
	*pxTopOfStack = ( portSTACK_TYPE ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
80005674:	30 08       	mov	r8,0
80005676:	18 d8       	st.w	--r12,r8

	return pxTopOfStack;
}
80005678:	5e fc       	retal	r12
8000567a:	d7 03       	nop

8000567c <vPortEnterCritical>:
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
8000567c:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
8000567e:	48 38       	lddpc	r8,80005688 <vPortEnterCritical+0xc>
80005680:	70 09       	ld.w	r9,r8[0x0]
80005682:	2f f9       	sub	r9,-1
80005684:	91 09       	st.w	r8[0x0],r9
}
80005686:	5e fc       	retal	r12
80005688:	00 00       	add	r0,r0
8000568a:	05 34       	ld.ub	r4,r2++

8000568c <xPortStartScheduler>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
8000568c:	d4 01       	pushm	lr
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
8000568e:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
80005690:	30 0a       	mov	r10,0
80005692:	14 9b       	mov	r11,r10
80005694:	49 2c       	lddpc	r12,800056dc <xPortStartScheduler+0x50>
80005696:	f0 1f 00 13 	mcall	800056e0 <xPortStartScheduler+0x54>
/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);//cause!!!
8000569a:	e0 68 5d c0 	mov	r8,24000
8000569e:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
800056a2:	30 08       	mov	r8,0
800056a4:	e3 b8 00 42 	mtsr	0x108,r8
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Start the first task. */
	portRESTORE_CONTEXT();
800056a8:	e0 68 0c dc 	mov	r8,3292
800056ac:	ea 18 00 00 	orh	r8,0x0
800056b0:	70 00       	ld.w	r0,r8[0x0]
800056b2:	60 0d       	ld.w	sp,r0[0x0]
800056b4:	1b 00       	ld.w	r0,sp++
800056b6:	e0 68 05 34 	mov	r8,1332
800056ba:	ea 18 00 00 	orh	r8,0x0
800056be:	91 00       	st.w	r8[0x0],r0
800056c0:	e3 cd 00 ff 	ldm	sp++,r0-r7
800056c4:	2f ed       	sub	sp,-8
800056c6:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
800056ca:	fa f0 ff e0 	ld.w	r0,sp[-32]
800056ce:	e3 b0 00 00 	mtsr	0x0,r0
800056d2:	fa f0 ff dc 	ld.w	r0,sp[-36]
800056d6:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
}
800056da:	d8 0a       	popm	pc,r12=0
800056dc:	80 00       	ld.sh	r0,r0[0x0]
800056de:	57 a8       	stdsp	sp[0x1e8],r8
800056e0:	80 00       	ld.sh	r0,r0[0x0]
800056e2:	4e 70       	lddpc	r0,8000587c <_read+0x38>

800056e4 <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
800056e4:	20 6d       	sub	sp,24
800056e6:	eb cd 00 ff 	pushm	r0-r7
800056ea:	fa c7 ff c0 	sub	r7,sp,-64
800056ee:	ee f0 ff f8 	ld.w	r0,r7[-8]
800056f2:	ef 40 ff e0 	st.w	r7[-32],r0
800056f6:	ee f0 ff fc 	ld.w	r0,r7[-4]
800056fa:	ef 40 ff e4 	st.w	r7[-28],r0
800056fe:	eb c7 5f 00 	stm	--r7,r8-r12,lr
80005702:	e0 68 05 34 	mov	r8,1332
80005706:	ea 18 00 00 	orh	r8,0x0
8000570a:	70 00       	ld.w	r0,r8[0x0]
8000570c:	1a d0       	st.w	--sp,r0
8000570e:	f0 1f 00 1a 	mcall	80005774 <LABEL_RET_SCALL_263+0x14>
80005712:	e0 68 0c dc 	mov	r8,3292
80005716:	ea 18 00 00 	orh	r8,0x0
8000571a:	70 00       	ld.w	r0,r8[0x0]
8000571c:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
8000571e:	f0 1f 00 17 	mcall	80005778 <LABEL_RET_SCALL_263+0x18>
	portRESTORE_CONTEXT_SCALL();
80005722:	e0 68 0c dc 	mov	r8,3292
80005726:	ea 18 00 00 	orh	r8,0x0
8000572a:	70 00       	ld.w	r0,r8[0x0]
8000572c:	60 0d       	ld.w	sp,r0[0x0]
8000572e:	1b 00       	ld.w	r0,sp++
80005730:	e0 68 05 34 	mov	r8,1332
80005734:	ea 18 00 00 	orh	r8,0x0
80005738:	91 00       	st.w	r8[0x0],r0
8000573a:	fa c7 ff d8 	sub	r7,sp,-40
8000573e:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
80005742:	ee f0 ff e0 	ld.w	r0,r7[-32]
80005746:	e0 61 05 34 	mov	r1,1332
8000574a:	ea 11 00 00 	orh	r1,0x0
8000574e:	62 02       	ld.w	r2,r1[0x0]
80005750:	58 02       	cp.w	r2,0
80005752:	c0 70       	breq	80005760 <LABEL_RET_SCALL_263>
80005754:	e4 c2 00 01 	sub	r2,r2,1
80005758:	83 02       	st.w	r1[0x0],r2
8000575a:	58 02       	cp.w	r2,0
8000575c:	c0 21       	brne	80005760 <LABEL_RET_SCALL_263>
8000575e:	b1 c0       	cbr	r0,0x10

80005760 <LABEL_RET_SCALL_263>:
80005760:	ef 40 ff f8 	st.w	r7[-8],r0
80005764:	ee f0 ff e4 	ld.w	r0,r7[-28]
80005768:	ef 40 ff fc 	st.w	r7[-4],r0
8000576c:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005770:	2f ad       	sub	sp,-24
80005772:	d6 13       	rets
80005774:	80 00       	ld.sh	r0,r0[0x0]
80005776:	56 7c       	stdsp	sp[0x19c],r12
80005778:	80 00       	ld.sh	r0,r0[0x0]
8000577a:	5d c0       	*unknown*

8000577c <prvClearCcInt>:
		Set_system_register(AVR32_COUNT, 0);
	}

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
8000577c:	e1 b8 00 43 	mfsr	r8,0x10c
80005780:	e3 b8 00 43 	mtsr	0x10c,r8
	}
80005784:	5e fc       	retal	r12
80005786:	d7 03       	nop

80005788 <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
80005788:	48 78       	lddpc	r8,800057a4 <vPortExitCritical+0x1c>
8000578a:	70 08       	ld.w	r8,r8[0x0]
8000578c:	58 08       	cp.w	r8,0
8000578e:	5e 0c       	reteq	r12
	{
		ulCriticalNesting--;
80005790:	48 58       	lddpc	r8,800057a4 <vPortExitCritical+0x1c>
80005792:	70 09       	ld.w	r9,r8[0x0]
80005794:	20 19       	sub	r9,1
80005796:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
80005798:	70 08       	ld.w	r8,r8[0x0]
8000579a:	58 08       	cp.w	r8,0
8000579c:	5e 1c       	retne	r12
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
8000579e:	d5 03       	csrf	0x10
800057a0:	5e fc       	retal	r12
800057a2:	00 00       	add	r0,r0
800057a4:	00 00       	add	r0,r0
800057a6:	05 34       	ld.ub	r4,r2++

800057a8 <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
800057a8:	eb cd 00 ff 	pushm	r0-r7
800057ac:	e0 68 05 34 	mov	r8,1332
800057b0:	ea 18 00 00 	orh	r8,0x0
800057b4:	70 00       	ld.w	r0,r8[0x0]
800057b6:	1a d0       	st.w	--sp,r0
800057b8:	7a 90       	ld.w	r0,sp[0x24]
800057ba:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
800057be:	58 10       	cp.w	r0,1
800057c0:	e0 8b 00 08 	brhi	800057d0 <LABEL_INT_SKIP_SAVE_CONTEXT_237>
800057c4:	e0 68 0c dc 	mov	r8,3292
800057c8:	ea 18 00 00 	orh	r8,0x0
800057cc:	70 00       	ld.w	r0,r8[0x0]
800057ce:	81 0d       	st.w	r0[0x0],sp

800057d0 <LABEL_INT_SKIP_SAVE_CONTEXT_237>:
	#if( configTICK_USE_TC==1 )
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Clear the interrupt flag. */
		prvClearCcInt();
800057d0:	f0 1f 00 12 	mcall	80005818 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
800057d4:	f0 1f 00 12 	mcall	8000581c <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
		vTaskIncrementTick();
800057d8:	f0 1f 00 12 	mcall	80005820 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x1c>
	portEXIT_CRITICAL();
800057dc:	f0 1f 00 12 	mcall	80005824 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
800057e0:	7a 90       	ld.w	r0,sp[0x24]
800057e2:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
800057e6:	58 10       	cp.w	r0,1
800057e8:	e0 8b 00 0e 	brhi	80005804 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>
800057ec:	f0 1f 00 0c 	mcall	8000581c <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
800057f0:	f0 1f 00 0e 	mcall	80005828 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x24>
800057f4:	f0 1f 00 0c 	mcall	80005824 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>
800057f8:	e0 68 0c dc 	mov	r8,3292
800057fc:	ea 18 00 00 	orh	r8,0x0
80005800:	70 00       	ld.w	r0,r8[0x0]
80005802:	60 0d       	ld.w	sp,r0[0x0]

80005804 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>:
80005804:	1b 00       	ld.w	r0,sp++
80005806:	e0 68 05 34 	mov	r8,1332
8000580a:	ea 18 00 00 	orh	r8,0x0
8000580e:	91 00       	st.w	r8[0x0],r0
80005810:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005814:	d6 03       	rete
80005816:	00 00       	add	r0,r0
80005818:	80 00       	ld.sh	r0,r0[0x0]
8000581a:	57 7c       	stdsp	sp[0x1dc],r12
8000581c:	80 00       	ld.sh	r0,r0[0x0]
8000581e:	56 7c       	stdsp	sp[0x19c],r12
80005820:	80 00       	ld.sh	r0,r0[0x0]
80005822:	5f c4       	srvs	r4
80005824:	80 00       	ld.sh	r0,r0[0x0]
80005826:	57 88       	stdsp	sp[0x1e0],r8
80005828:	80 00       	ld.sh	r0,r0[0x0]
8000582a:	5d c0       	*unknown*

8000582c <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
8000582c:	d4 01       	pushm	lr
	vTaskSuspendAll();
8000582e:	f0 1f 00 02 	mcall	80005834 <__malloc_lock+0x8>
}
80005832:	d8 02       	popm	pc
80005834:	80 00       	ld.sh	r0,r0[0x0]
80005836:	5d b0       	*unknown*

80005838 <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
80005838:	d4 01       	pushm	lr
	xTaskResumeAll();
8000583a:	f0 1f 00 02 	mcall	80005840 <__malloc_unlock+0x8>
}
8000583e:	d8 02       	popm	pc
80005840:	80 00       	ld.sh	r0,r0[0x0]
80005842:	61 6c       	ld.w	r12,r0[0x58]

80005844 <_read>:
/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
{
80005844:	d4 21       	pushm	r4-r7,lr
80005846:	16 95       	mov	r5,r11
80005848:	14 96       	mov	r6,r10
  int nChars = 0;

  if (file != 0)
8000584a:	58 0c       	cp.w	r12,0
8000584c:	c0 30       	breq	80005852 <_read+0xe>
8000584e:	3f f7       	mov	r7,-1
80005850:	c1 48       	rjmp	80005878 <_read+0x34>
    return -1;

  for (; len > 0; --len)
80005852:	58 0a       	cp.w	r10,0
80005854:	e0 89 00 04 	brgt	8000585c <_read+0x18>
80005858:	30 07       	mov	r7,0
8000585a:	c0 f8       	rjmp	80005878 <_read+0x34>
8000585c:	30 07       	mov	r7,0
  {
    int c = usart_getchar(stdio_usart_base);
8000585e:	48 84       	lddpc	r4,8000587c <_read+0x38>
80005860:	68 0c       	ld.w	r12,r4[0x0]
80005862:	f0 1f 00 08 	mcall	80005880 <_read+0x3c>
    if (c < 0)
80005866:	c0 95       	brlt	80005878 <_read+0x34>
      break;

    *ptr++ = c;
80005868:	ea 07 0b 0c 	st.b	r5[r7],r12
    ++nChars;
8000586c:	2f f7       	sub	r7,-1

/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
8000586e:	ec 07 01 08 	sub	r8,r6,r7
  int nChars = 0;

  if (file != 0)
    return -1;

  for (; len > 0; --len)
80005872:	58 08       	cp.w	r8,0
80005874:	fe 99 ff f6 	brgt	80005860 <_read+0x1c>
    *ptr++ = c;
    ++nChars;
  }

  return nChars;
}
80005878:	0e 9c       	mov	r12,r7
8000587a:	d8 22       	popm	r4-r7,pc
8000587c:	00 00       	add	r0,r0
8000587e:	52 d8       	stdsp	sp[0xb4],r8
80005880:	80 00       	ld.sh	r0,r0[0x0]
80005882:	54 10       	stdsp	sp[0x104],r0

80005884 <_write>:
 * 1 and 2 is stdout and stderr which goes to usart
 * 3 is framebuffer
 */
int __attribute__((weak))
_write (int file, char * ptr, int len)
{
80005884:	d4 21       	pushm	r4-r7,lr
80005886:	16 95       	mov	r5,r11
80005888:	14 96       	mov	r6,r10
  int nChars = 0;

  if ( (file != 1)
8000588a:	20 1c       	sub	r12,1
8000588c:	58 2c       	cp.w	r12,2
8000588e:	e0 8b 00 12 	brhi	800058b2 <_write+0x2e>
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80005892:	58 0a       	cp.w	r10,0
80005894:	c0 31       	brne	8000589a <_write+0x16>
80005896:	30 07       	mov	r7,0
80005898:	c0 e8       	rjmp	800058b4 <_write+0x30>
8000589a:	30 07       	mov	r7,0
  {
    if (usart_putchar(stdio_usart_base, *ptr++) < 0)
8000589c:	48 74       	lddpc	r4,800058b8 <_write+0x34>
8000589e:	68 0c       	ld.w	r12,r4[0x0]
800058a0:	ea 07 07 0b 	ld.ub	r11,r5[r7]
800058a4:	f0 1f 00 06 	mcall	800058bc <_write+0x38>
800058a8:	c0 55       	brlt	800058b2 <_write+0x2e>
    {
      return -1;
    }

    ++nChars;
800058aa:	2f f7       	sub	r7,-1

  if ( (file != 1)
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
800058ac:	0e 36       	cp.w	r6,r7
800058ae:	cf 81       	brne	8000589e <_write+0x1a>
800058b0:	c0 28       	rjmp	800058b4 <_write+0x30>
800058b2:	3f f7       	mov	r7,-1

    ++nChars;
  }

  return nChars;
}
800058b4:	0e 9c       	mov	r12,r7
800058b6:	d8 22       	popm	r4-r7,pc
800058b8:	00 00       	add	r0,r0
800058ba:	52 d8       	stdsp	sp[0xb4],r8
800058bc:	80 00       	ld.sh	r0,r0[0x0]
800058be:	53 c0       	stdsp	sp[0xf0],r0

800058c0 <vPortFree>:
	return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
800058c0:	eb cd 40 80 	pushm	r7,lr
800058c4:	18 97       	mov	r7,r12
	if( pv )
800058c6:	58 0c       	cp.w	r12,0
800058c8:	c0 80       	breq	800058d8 <vPortFree+0x18>
	{
		vTaskSuspendAll();
800058ca:	f0 1f 00 05 	mcall	800058dc <vPortFree+0x1c>
		{
			free( pv );
800058ce:	0e 9c       	mov	r12,r7
800058d0:	f0 1f 00 04 	mcall	800058e0 <vPortFree+0x20>
		}
		xTaskResumeAll();
800058d4:	f0 1f 00 04 	mcall	800058e4 <vPortFree+0x24>
800058d8:	e3 cd 80 80 	ldm	sp++,r7,pc
800058dc:	80 00       	ld.sh	r0,r0[0x0]
800058de:	5d b0       	*unknown*
800058e0:	80 00       	ld.sh	r0,r0[0x0]
800058e2:	6d 10       	ld.w	r0,r6[0x44]
800058e4:	80 00       	ld.sh	r0,r0[0x0]
800058e6:	61 6c       	ld.w	r12,r0[0x58]

800058e8 <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
800058e8:	eb cd 40 80 	pushm	r7,lr
800058ec:	18 97       	mov	r7,r12
void *pvReturn;

	vTaskSuspendAll();
800058ee:	f0 1f 00 06 	mcall	80005904 <pvPortMalloc+0x1c>
	{
		pvReturn = malloc( xWantedSize );
800058f2:	0e 9c       	mov	r12,r7
800058f4:	f0 1f 00 05 	mcall	80005908 <pvPortMalloc+0x20>
800058f8:	18 97       	mov	r7,r12
	}
	xTaskResumeAll();
800058fa:	f0 1f 00 05 	mcall	8000590c <pvPortMalloc+0x24>
		}
	}
	#endif

	return pvReturn;
}
800058fe:	0e 9c       	mov	r12,r7
80005900:	e3 cd 80 80 	ldm	sp++,r7,pc
80005904:	80 00       	ld.sh	r0,r0[0x0]
80005906:	5d b0       	*unknown*
80005908:	80 00       	ld.sh	r0,r0[0x0]
8000590a:	6d 20       	ld.w	r0,r6[0x48]
8000590c:	80 00       	ld.sh	r0,r0[0x0]
8000590e:	61 6c       	ld.w	r12,r0[0x58]

80005910 <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
80005910:	d4 01       	pushm	lr
80005912:	16 98       	mov	r8,r11
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
80005914:	78 09       	ld.w	r9,r12[0x0]
80005916:	58 09       	cp.w	r9,0
80005918:	c1 10       	breq	8000593a <prvCopyDataFromQueue+0x2a>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
8000591a:	78 3a       	ld.w	r10,r12[0xc]
8000591c:	79 09       	ld.w	r9,r12[0x40]
8000591e:	f4 09 00 09 	add	r9,r10,r9
80005922:	99 39       	st.w	r12[0xc],r9
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
80005924:	78 1a       	ld.w	r10,r12[0x4]
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
80005926:	14 39       	cp.w	r9,r10
80005928:	f9 f9 20 00 	ld.wcc	r9,r12[0x0]
8000592c:	f9 f9 2a 03 	st.wcc	r12[0xc],r9
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
80005930:	79 0a       	ld.w	r10,r12[0x40]
80005932:	78 3b       	ld.w	r11,r12[0xc]
80005934:	10 9c       	mov	r12,r8
80005936:	f0 1f 00 02 	mcall	8000593c <prvCopyDataFromQueue+0x2c>
8000593a:	d8 02       	popm	pc
8000593c:	80 00       	ld.sh	r0,r0[0x0]
8000593e:	71 8e       	ld.w	lr,r8[0x60]

80005940 <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
80005940:	eb cd 40 c0 	pushm	r6-r7,lr
80005944:	18 97       	mov	r7,r12
80005946:	14 96       	mov	r6,r10
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80005948:	78 e8       	ld.w	r8,r12[0x38]
8000594a:	58 08       	cp.w	r8,0
8000594c:	c0 31       	brne	80005952 <xQueueReceiveFromISR+0x12>
8000594e:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
80005952:	f0 1f 00 0e 	mcall	80005988 <xQueueReceiveFromISR+0x48>
			--( pxQueue->uxMessagesWaiting );
80005956:	6e e8       	ld.w	r8,r7[0x38]
80005958:	20 18       	sub	r8,1
8000595a:	8f e8       	st.w	r7[0x38],r8

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
8000595c:	6f 18       	ld.w	r8,r7[0x44]
8000595e:	5b f8       	cp.w	r8,-1
80005960:	c0 d1       	brne	8000597a <xQueueReceiveFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005962:	6e 48       	ld.w	r8,r7[0x10]
80005964:	58 08       	cp.w	r8,0
80005966:	c0 f0       	breq	80005984 <xQueueReceiveFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80005968:	ee cc ff f0 	sub	r12,r7,-16
8000596c:	f0 1f 00 08 	mcall	8000598c <xQueueReceiveFromISR+0x4c>
80005970:	c0 a0       	breq	80005984 <xQueueReceiveFromISR+0x44>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
80005972:	30 1c       	mov	r12,1
80005974:	8d 0c       	st.w	r6[0x0],r12
80005976:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
8000597a:	2f f8       	sub	r8,-1
8000597c:	ef 48 00 44 	st.w	r7[68],r8
80005980:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80005984:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80005988:	80 00       	ld.sh	r0,r0[0x0]
8000598a:	59 10       	cp.w	r0,17
8000598c:	80 00       	ld.sh	r0,r0[0x0]
8000598e:	5f 48       	srge	r8

80005990 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
80005990:	eb cd 40 c0 	pushm	r6-r7,lr
80005994:	18 97       	mov	r7,r12

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
80005996:	f0 1f 00 23 	mcall	80005a20 <prvUnlockQueue+0x90>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
8000599a:	6f 28       	ld.w	r8,r7[0x48]
8000599c:	58 08       	cp.w	r8,0
8000599e:	e0 8a 00 18 	brle	800059ce <prvUnlockQueue+0x3e>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800059a2:	6e 98       	ld.w	r8,r7[0x24]
800059a4:	58 08       	cp.w	r8,0
800059a6:	c1 40       	breq	800059ce <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
800059a8:	ee c6 ff dc 	sub	r6,r7,-36
800059ac:	c0 48       	rjmp	800059b4 <prvUnlockQueue+0x24>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800059ae:	6e 98       	ld.w	r8,r7[0x24]
800059b0:	58 08       	cp.w	r8,0
800059b2:	c0 e0       	breq	800059ce <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
800059b4:	0c 9c       	mov	r12,r6
800059b6:	f0 1f 00 1c 	mcall	80005a24 <prvUnlockQueue+0x94>
800059ba:	c0 30       	breq	800059c0 <prvUnlockQueue+0x30>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
800059bc:	f0 1f 00 1b 	mcall	80005a28 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xTxLock );
800059c0:	6f 28       	ld.w	r8,r7[0x48]
800059c2:	20 18       	sub	r8,1
800059c4:	ef 48 00 48 	st.w	r7[72],r8
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
800059c8:	58 08       	cp.w	r8,0
800059ca:	fe 99 ff f2 	brgt	800059ae <prvUnlockQueue+0x1e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
800059ce:	3f f8       	mov	r8,-1
800059d0:	ef 48 00 48 	st.w	r7[72],r8
	}
	taskEXIT_CRITICAL();
800059d4:	f0 1f 00 16 	mcall	80005a2c <prvUnlockQueue+0x9c>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
800059d8:	f0 1f 00 12 	mcall	80005a20 <prvUnlockQueue+0x90>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
800059dc:	6f 18       	ld.w	r8,r7[0x44]
800059de:	58 08       	cp.w	r8,0
800059e0:	e0 8a 00 18 	brle	80005a10 <prvUnlockQueue+0x80>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
800059e4:	6e 48       	ld.w	r8,r7[0x10]
800059e6:	58 08       	cp.w	r8,0
800059e8:	c1 40       	breq	80005a10 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
800059ea:	ee c6 ff f0 	sub	r6,r7,-16
800059ee:	c0 48       	rjmp	800059f6 <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
800059f0:	6e 48       	ld.w	r8,r7[0x10]
800059f2:	58 08       	cp.w	r8,0
800059f4:	c0 e0       	breq	80005a10 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
800059f6:	0c 9c       	mov	r12,r6
800059f8:	f0 1f 00 0b 	mcall	80005a24 <prvUnlockQueue+0x94>
800059fc:	c0 30       	breq	80005a02 <prvUnlockQueue+0x72>
				{
					vTaskMissedYield();
800059fe:	f0 1f 00 0b 	mcall	80005a28 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xRxLock );
80005a02:	6f 18       	ld.w	r8,r7[0x44]
80005a04:	20 18       	sub	r8,1
80005a06:	ef 48 00 44 	st.w	r7[68],r8
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80005a0a:	58 08       	cp.w	r8,0
80005a0c:	fe 99 ff f2 	brgt	800059f0 <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
80005a10:	3f f8       	mov	r8,-1
80005a12:	ef 48 00 44 	st.w	r7[68],r8
	}
	taskEXIT_CRITICAL();
80005a16:	f0 1f 00 06 	mcall	80005a2c <prvUnlockQueue+0x9c>
}
80005a1a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005a1e:	00 00       	add	r0,r0
80005a20:	80 00       	ld.sh	r0,r0[0x0]
80005a22:	56 7c       	stdsp	sp[0x19c],r12
80005a24:	80 00       	ld.sh	r0,r0[0x0]
80005a26:	5f 48       	srge	r8
80005a28:	80 00       	ld.sh	r0,r0[0x0]
80005a2a:	5e 54       	retlt	r4
80005a2c:	80 00       	ld.sh	r0,r0[0x0]
80005a2e:	57 88       	stdsp	sp[0x1e0],r8

80005a30 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
80005a30:	d4 31       	pushm	r0-r7,lr
80005a32:	20 5d       	sub	sp,20
80005a34:	18 97       	mov	r7,r12
80005a36:	50 0b       	stdsp	sp[0x0],r11
80005a38:	50 2a       	stdsp	sp[0x8],r10
80005a3a:	50 19       	stdsp	sp[0x4],r9
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80005a3c:	f8 c2 ff dc 	sub	r2,r12,-36
80005a40:	30 05       	mov	r5,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80005a42:	fa c4 ff f4 	sub	r4,sp,-12
80005a46:	30 10       	mov	r0,1

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80005a48:	0a 91       	mov	r1,r5

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80005a4a:	fa c3 ff f8 	sub	r3,sp,-8
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
80005a4e:	f0 1f 00 3e 	mcall	80005b44 <xQueueGenericReceive+0x114>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80005a52:	6e e8       	ld.w	r8,r7[0x38]
80005a54:	58 08       	cp.w	r8,0
80005a56:	c2 a0       	breq	80005aaa <xQueueGenericReceive+0x7a>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
80005a58:	6e 36       	ld.w	r6,r7[0xc]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
80005a5a:	40 0b       	lddsp	r11,sp[0x0]
80005a5c:	0e 9c       	mov	r12,r7
80005a5e:	f0 1f 00 3b 	mcall	80005b48 <xQueueGenericReceive+0x118>

				if( xJustPeeking == pdFALSE )
80005a62:	40 18       	lddsp	r8,sp[0x4]
80005a64:	58 08       	cp.w	r8,0
80005a66:	c1 51       	brne	80005a90 <xQueueGenericReceive+0x60>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
80005a68:	6e e8       	ld.w	r8,r7[0x38]
80005a6a:	20 18       	sub	r8,1
80005a6c:	8f e8       	st.w	r7[0x38],r8

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80005a6e:	6e 08       	ld.w	r8,r7[0x0]
80005a70:	58 08       	cp.w	r8,0
80005a72:	c0 41       	brne	80005a7a <xQueueGenericReceive+0x4a>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
80005a74:	f0 1f 00 36 	mcall	80005b4c <xQueueGenericReceive+0x11c>
80005a78:	8f 1c       	st.w	r7[0x4],r12
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005a7a:	6e 48       	ld.w	r8,r7[0x10]
80005a7c:	58 08       	cp.w	r8,0
80005a7e:	c1 20       	breq	80005aa2 <xQueueGenericReceive+0x72>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
80005a80:	ee cc ff f0 	sub	r12,r7,-16
80005a84:	f0 1f 00 33 	mcall	80005b50 <xQueueGenericReceive+0x120>
80005a88:	58 1c       	cp.w	r12,1
80005a8a:	c0 c1       	brne	80005aa2 <xQueueGenericReceive+0x72>
						{
							portYIELD_WITHIN_API();
80005a8c:	d7 33       	scall
80005a8e:	c0 a8       	rjmp	80005aa2 <xQueueGenericReceive+0x72>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
80005a90:	8f 36       	st.w	r7[0xc],r6

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005a92:	6e 98       	ld.w	r8,r7[0x24]
80005a94:	58 08       	cp.w	r8,0
80005a96:	c0 60       	breq	80005aa2 <xQueueGenericReceive+0x72>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80005a98:	04 9c       	mov	r12,r2
80005a9a:	f0 1f 00 2e 	mcall	80005b50 <xQueueGenericReceive+0x120>
80005a9e:	c0 20       	breq	80005aa2 <xQueueGenericReceive+0x72>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
80005aa0:	d7 33       	scall
						}
					}

				}

				taskEXIT_CRITICAL();
80005aa2:	f0 1f 00 2d 	mcall	80005b54 <xQueueGenericReceive+0x124>
80005aa6:	30 1c       	mov	r12,1
				return pdPASS;
80005aa8:	c4 c8       	rjmp	80005b40 <xQueueGenericReceive+0x110>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
80005aaa:	40 28       	lddsp	r8,sp[0x8]
80005aac:	58 08       	cp.w	r8,0
80005aae:	c0 51       	brne	80005ab8 <xQueueGenericReceive+0x88>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80005ab0:	f0 1f 00 29 	mcall	80005b54 <xQueueGenericReceive+0x124>
80005ab4:	30 0c       	mov	r12,0
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
80005ab6:	c4 58       	rjmp	80005b40 <xQueueGenericReceive+0x110>
				}
				else if( xEntryTimeSet == pdFALSE )
80005ab8:	58 05       	cp.w	r5,0
80005aba:	c0 51       	brne	80005ac4 <xQueueGenericReceive+0x94>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80005abc:	08 9c       	mov	r12,r4
80005abe:	f0 1f 00 27 	mcall	80005b58 <xQueueGenericReceive+0x128>
80005ac2:	00 95       	mov	r5,r0
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80005ac4:	f0 1f 00 24 	mcall	80005b54 <xQueueGenericReceive+0x124>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80005ac8:	f0 1f 00 25 	mcall	80005b5c <xQueueGenericReceive+0x12c>
		prvLockQueue( pxQueue );
80005acc:	f0 1f 00 1e 	mcall	80005b44 <xQueueGenericReceive+0x114>
80005ad0:	6f 18       	ld.w	r8,r7[0x44]
80005ad2:	5b f8       	cp.w	r8,-1
80005ad4:	ef f1 0a 11 	st.weq	r7[0x44],r1
80005ad8:	6f 28       	ld.w	r8,r7[0x48]
80005ada:	5b f8       	cp.w	r8,-1
80005adc:	ef f1 0a 12 	st.weq	r7[0x48],r1
80005ae0:	f0 1f 00 1d 	mcall	80005b54 <xQueueGenericReceive+0x124>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80005ae4:	06 9b       	mov	r11,r3
80005ae6:	08 9c       	mov	r12,r4
80005ae8:	f0 1f 00 1e 	mcall	80005b60 <xQueueGenericReceive+0x130>
80005aec:	c2 41       	brne	80005b34 <xQueueGenericReceive+0x104>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80005aee:	f0 1f 00 16 	mcall	80005b44 <xQueueGenericReceive+0x114>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
80005af2:	6e e6       	ld.w	r6,r7[0x38]
	taskEXIT_CRITICAL();
80005af4:	f0 1f 00 18 	mcall	80005b54 <xQueueGenericReceive+0x124>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
80005af8:	58 06       	cp.w	r6,0
80005afa:	c1 71       	brne	80005b28 <xQueueGenericReceive+0xf8>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80005afc:	6e 08       	ld.w	r8,r7[0x0]
80005afe:	58 08       	cp.w	r8,0
80005b00:	c0 81       	brne	80005b10 <xQueueGenericReceive+0xe0>
					{
						portENTER_CRITICAL();
80005b02:	f0 1f 00 11 	mcall	80005b44 <xQueueGenericReceive+0x114>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
80005b06:	6e 1c       	ld.w	r12,r7[0x4]
80005b08:	f0 1f 00 17 	mcall	80005b64 <xQueueGenericReceive+0x134>
						}
						portEXIT_CRITICAL();
80005b0c:	f0 1f 00 12 	mcall	80005b54 <xQueueGenericReceive+0x124>
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80005b10:	40 2b       	lddsp	r11,sp[0x8]
80005b12:	04 9c       	mov	r12,r2
80005b14:	f0 1f 00 15 	mcall	80005b68 <xQueueGenericReceive+0x138>
				prvUnlockQueue( pxQueue );
80005b18:	0e 9c       	mov	r12,r7
80005b1a:	f0 1f 00 15 	mcall	80005b6c <xQueueGenericReceive+0x13c>
				if( !xTaskResumeAll() )
80005b1e:	f0 1f 00 15 	mcall	80005b70 <xQueueGenericReceive+0x140>
80005b22:	c9 61       	brne	80005a4e <xQueueGenericReceive+0x1e>
				{
					portYIELD_WITHIN_API();
80005b24:	d7 33       	scall
80005b26:	c9 4b       	rjmp	80005a4e <xQueueGenericReceive+0x1e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80005b28:	0e 9c       	mov	r12,r7
80005b2a:	f0 1f 00 11 	mcall	80005b6c <xQueueGenericReceive+0x13c>
				( void ) xTaskResumeAll();
80005b2e:	f0 1f 00 11 	mcall	80005b70 <xQueueGenericReceive+0x140>
80005b32:	c8 eb       	rjmp	80005a4e <xQueueGenericReceive+0x1e>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
80005b34:	0e 9c       	mov	r12,r7
80005b36:	f0 1f 00 0e 	mcall	80005b6c <xQueueGenericReceive+0x13c>
			( void ) xTaskResumeAll();
80005b3a:	f0 1f 00 0e 	mcall	80005b70 <xQueueGenericReceive+0x140>
80005b3e:	30 0c       	mov	r12,0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
80005b40:	2f bd       	sub	sp,-20
80005b42:	d8 32       	popm	r0-r7,pc
80005b44:	80 00       	ld.sh	r0,r0[0x0]
80005b46:	56 7c       	stdsp	sp[0x19c],r12
80005b48:	80 00       	ld.sh	r0,r0[0x0]
80005b4a:	59 10       	cp.w	r0,17
80005b4c:	80 00       	ld.sh	r0,r0[0x0]
80005b4e:	5e 60       	retmi	r0
80005b50:	80 00       	ld.sh	r0,r0[0x0]
80005b52:	5f 48       	srge	r8
80005b54:	80 00       	ld.sh	r0,r0[0x0]
80005b56:	57 88       	stdsp	sp[0x1e0],r8
80005b58:	80 00       	ld.sh	r0,r0[0x0]
80005b5a:	5e 3c       	retlo	r12
80005b5c:	80 00       	ld.sh	r0,r0[0x0]
80005b5e:	5d b0       	*unknown*
80005b60:	80 00       	ld.sh	r0,r0[0x0]
80005b62:	60 d8       	ld.w	r8,r0[0x34]
80005b64:	80 00       	ld.sh	r0,r0[0x0]
80005b66:	5e c4       	retvs	r4
80005b68:	80 00       	ld.sh	r0,r0[0x0]
80005b6a:	63 30       	ld.w	r0,r1[0x4c]
80005b6c:	80 00       	ld.sh	r0,r0[0x0]
80005b6e:	59 90       	cp.w	r0,25
80005b70:	80 00       	ld.sh	r0,r0[0x0]
80005b72:	61 6c       	ld.w	r12,r0[0x58]

80005b74 <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
80005b74:	eb cd 40 80 	pushm	r7,lr
80005b78:	18 97       	mov	r7,r12
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
80005b7a:	79 08       	ld.w	r8,r12[0x40]
80005b7c:	58 08       	cp.w	r8,0
80005b7e:	c0 a1       	brne	80005b92 <prvCopyDataToQueue+0x1e>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80005b80:	78 08       	ld.w	r8,r12[0x0]
80005b82:	58 08       	cp.w	r8,0
80005b84:	c2 b1       	brne	80005bda <prvCopyDataToQueue+0x66>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
80005b86:	78 1c       	ld.w	r12,r12[0x4]
80005b88:	f0 1f 00 17 	mcall	80005be4 <prvCopyDataToQueue+0x70>
				pxQueue->pxMutexHolder = NULL;
80005b8c:	30 08       	mov	r8,0
80005b8e:	8f 18       	st.w	r7[0x4],r8
80005b90:	c2 58       	rjmp	80005bda <prvCopyDataToQueue+0x66>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
80005b92:	58 0a       	cp.w	r10,0
80005b94:	c1 01       	brne	80005bb4 <prvCopyDataToQueue+0x40>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80005b96:	10 9a       	mov	r10,r8
80005b98:	78 2c       	ld.w	r12,r12[0x8]
80005b9a:	f0 1f 00 14 	mcall	80005be8 <prvCopyDataToQueue+0x74>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
80005b9e:	6e 29       	ld.w	r9,r7[0x8]
80005ba0:	6f 08       	ld.w	r8,r7[0x40]
80005ba2:	f2 08 00 08 	add	r8,r9,r8
80005ba6:	8f 28       	st.w	r7[0x8],r8
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
80005ba8:	6e 19       	ld.w	r9,r7[0x4]
80005baa:	12 38       	cp.w	r8,r9
80005bac:	c1 73       	brcs	80005bda <prvCopyDataToQueue+0x66>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
80005bae:	6e 08       	ld.w	r8,r7[0x0]
80005bb0:	8f 28       	st.w	r7[0x8],r8
80005bb2:	c1 48       	rjmp	80005bda <prvCopyDataToQueue+0x66>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80005bb4:	10 9a       	mov	r10,r8
80005bb6:	78 3c       	ld.w	r12,r12[0xc]
80005bb8:	f0 1f 00 0c 	mcall	80005be8 <prvCopyDataToQueue+0x74>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
80005bbc:	6f 08       	ld.w	r8,r7[0x40]
80005bbe:	6e 39       	ld.w	r9,r7[0xc]
80005bc0:	f2 08 01 08 	sub	r8,r9,r8
80005bc4:	8f 38       	st.w	r7[0xc],r8
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
80005bc6:	6e 09       	ld.w	r9,r7[0x0]
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
80005bc8:	12 38       	cp.w	r8,r9
80005bca:	ef f8 30 10 	ld.wcs	r8,r7[0x40]
80005bce:	ef f9 30 01 	ld.wcs	r9,r7[0x4]
80005bd2:	f3 d8 e3 19 	subcs	r9,r9,r8
80005bd6:	ef f9 3a 03 	st.wcs	r7[0xc],r9
		}
	}

	++( pxQueue->uxMessagesWaiting );
80005bda:	6e e8       	ld.w	r8,r7[0x38]
80005bdc:	2f f8       	sub	r8,-1
80005bde:	8f e8       	st.w	r7[0x38],r8
}
80005be0:	e3 cd 80 80 	ldm	sp++,r7,pc
80005be4:	80 00       	ld.sh	r0,r0[0x0]
80005be6:	5e 6c       	retmi	r12
80005be8:	80 00       	ld.sh	r0,r0[0x0]
80005bea:	71 8e       	ld.w	lr,r8[0x60]

80005bec <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
80005bec:	eb cd 40 c0 	pushm	r6-r7,lr
80005bf0:	18 97       	mov	r7,r12
80005bf2:	14 96       	mov	r6,r10
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80005bf4:	78 ec       	ld.w	r12,r12[0x38]
80005bf6:	6e f8       	ld.w	r8,r7[0x3c]
80005bf8:	10 3c       	cp.w	r12,r8
80005bfa:	c0 33       	brcs	80005c00 <xQueueGenericSendFromISR+0x14>
80005bfc:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80005c00:	12 9a       	mov	r10,r9
80005c02:	0e 9c       	mov	r12,r7
80005c04:	f0 1f 00 0c 	mcall	80005c34 <xQueueGenericSendFromISR+0x48>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
80005c08:	6f 28       	ld.w	r8,r7[0x48]
80005c0a:	5b f8       	cp.w	r8,-1
80005c0c:	c0 d1       	brne	80005c26 <xQueueGenericSendFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005c0e:	6e 98       	ld.w	r8,r7[0x24]
80005c10:	58 08       	cp.w	r8,0
80005c12:	c0 f0       	breq	80005c30 <xQueueGenericSendFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80005c14:	ee cc ff dc 	sub	r12,r7,-36
80005c18:	f0 1f 00 08 	mcall	80005c38 <xQueueGenericSendFromISR+0x4c>
80005c1c:	c0 a0       	breq	80005c30 <xQueueGenericSendFromISR+0x44>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
80005c1e:	30 1c       	mov	r12,1
80005c20:	8d 0c       	st.w	r6[0x0],r12
80005c22:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
80005c26:	2f f8       	sub	r8,-1
80005c28:	ef 48 00 48 	st.w	r7[72],r8
80005c2c:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80005c30:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80005c34:	80 00       	ld.sh	r0,r0[0x0]
80005c36:	5b 74       	cp.w	r4,-9
80005c38:	80 00       	ld.sh	r0,r0[0x0]
80005c3a:	5f 48       	srge	r8

80005c3c <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
80005c3c:	d4 31       	pushm	r0-r7,lr
80005c3e:	20 5d       	sub	sp,20
80005c40:	18 97       	mov	r7,r12
80005c42:	50 0b       	stdsp	sp[0x0],r11
80005c44:	50 2a       	stdsp	sp[0x8],r10
80005c46:	50 19       	stdsp	sp[0x4],r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
80005c48:	f8 c0 ff f0 	sub	r0,r12,-16
80005c4c:	30 04       	mov	r4,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80005c4e:	fa c3 ff f4 	sub	r3,sp,-12

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80005c52:	08 91       	mov	r1,r4

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80005c54:	fa c2 ff f8 	sub	r2,sp,-8
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
80005c58:	f0 1f 00 2f 	mcall	80005d14 <xQueueGenericSend+0xd8>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80005c5c:	6e e9       	ld.w	r9,r7[0x38]
80005c5e:	6e f8       	ld.w	r8,r7[0x3c]
80005c60:	10 39       	cp.w	r9,r8
80005c62:	c1 42       	brcc	80005c8a <xQueueGenericSend+0x4e>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80005c64:	40 1a       	lddsp	r10,sp[0x4]
80005c66:	40 0b       	lddsp	r11,sp[0x0]
80005c68:	0e 9c       	mov	r12,r7
80005c6a:	f0 1f 00 2c 	mcall	80005d18 <xQueueGenericSend+0xdc>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005c6e:	6e 98       	ld.w	r8,r7[0x24]
80005c70:	58 08       	cp.w	r8,0
80005c72:	c0 80       	breq	80005c82 <xQueueGenericSend+0x46>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
80005c74:	ee cc ff dc 	sub	r12,r7,-36
80005c78:	f0 1f 00 29 	mcall	80005d1c <xQueueGenericSend+0xe0>
80005c7c:	58 1c       	cp.w	r12,1
80005c7e:	c0 21       	brne	80005c82 <xQueueGenericSend+0x46>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
80005c80:	d7 33       	scall
					}
				}

				taskEXIT_CRITICAL();
80005c82:	f0 1f 00 28 	mcall	80005d20 <xQueueGenericSend+0xe4>
80005c86:	30 1c       	mov	r12,1

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
80005c88:	c4 38       	rjmp	80005d0e <xQueueGenericSend+0xd2>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
80005c8a:	40 28       	lddsp	r8,sp[0x8]
80005c8c:	58 08       	cp.w	r8,0
80005c8e:	c0 51       	brne	80005c98 <xQueueGenericSend+0x5c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80005c90:	f0 1f 00 24 	mcall	80005d20 <xQueueGenericSend+0xe4>
80005c94:	30 0c       	mov	r12,0

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
80005c96:	c3 c8       	rjmp	80005d0e <xQueueGenericSend+0xd2>
				}
				else if( xEntryTimeSet == pdFALSE )
80005c98:	58 04       	cp.w	r4,0
80005c9a:	c0 51       	brne	80005ca4 <xQueueGenericSend+0x68>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80005c9c:	06 9c       	mov	r12,r3
80005c9e:	f0 1f 00 22 	mcall	80005d24 <xQueueGenericSend+0xe8>
80005ca2:	30 14       	mov	r4,1
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80005ca4:	f0 1f 00 1f 	mcall	80005d20 <xQueueGenericSend+0xe4>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80005ca8:	f0 1f 00 20 	mcall	80005d28 <xQueueGenericSend+0xec>
		prvLockQueue( pxQueue );
80005cac:	f0 1f 00 1a 	mcall	80005d14 <xQueueGenericSend+0xd8>
80005cb0:	6f 18       	ld.w	r8,r7[0x44]
80005cb2:	5b f8       	cp.w	r8,-1
80005cb4:	ef f1 0a 11 	st.weq	r7[0x44],r1
80005cb8:	6f 28       	ld.w	r8,r7[0x48]
80005cba:	5b f8       	cp.w	r8,-1
80005cbc:	ef f1 0a 12 	st.weq	r7[0x48],r1
80005cc0:	f0 1f 00 18 	mcall	80005d20 <xQueueGenericSend+0xe4>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80005cc4:	04 9b       	mov	r11,r2
80005cc6:	06 9c       	mov	r12,r3
80005cc8:	f0 1f 00 19 	mcall	80005d2c <xQueueGenericSend+0xf0>
80005ccc:	c1 b1       	brne	80005d02 <xQueueGenericSend+0xc6>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80005cce:	f0 1f 00 12 	mcall	80005d14 <xQueueGenericSend+0xd8>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
80005cd2:	6e e5       	ld.w	r5,r7[0x38]
80005cd4:	6e f6       	ld.w	r6,r7[0x3c]
	taskEXIT_CRITICAL();
80005cd6:	f0 1f 00 13 	mcall	80005d20 <xQueueGenericSend+0xe4>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
80005cda:	0c 35       	cp.w	r5,r6
80005cdc:	c0 d1       	brne	80005cf6 <xQueueGenericSend+0xba>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
80005cde:	40 2b       	lddsp	r11,sp[0x8]
80005ce0:	00 9c       	mov	r12,r0
80005ce2:	f0 1f 00 14 	mcall	80005d30 <xQueueGenericSend+0xf4>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
80005ce6:	0e 9c       	mov	r12,r7
80005ce8:	f0 1f 00 13 	mcall	80005d34 <xQueueGenericSend+0xf8>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
80005cec:	f0 1f 00 13 	mcall	80005d38 <xQueueGenericSend+0xfc>
80005cf0:	cb 41       	brne	80005c58 <xQueueGenericSend+0x1c>
				{
					portYIELD_WITHIN_API();
80005cf2:	d7 33       	scall
80005cf4:	cb 2b       	rjmp	80005c58 <xQueueGenericSend+0x1c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80005cf6:	0e 9c       	mov	r12,r7
80005cf8:	f0 1f 00 0f 	mcall	80005d34 <xQueueGenericSend+0xf8>
				( void ) xTaskResumeAll();
80005cfc:	f0 1f 00 0f 	mcall	80005d38 <xQueueGenericSend+0xfc>
80005d00:	ca cb       	rjmp	80005c58 <xQueueGenericSend+0x1c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
80005d02:	0e 9c       	mov	r12,r7
80005d04:	f0 1f 00 0c 	mcall	80005d34 <xQueueGenericSend+0xf8>
			( void ) xTaskResumeAll();
80005d08:	f0 1f 00 0c 	mcall	80005d38 <xQueueGenericSend+0xfc>
80005d0c:	30 0c       	mov	r12,0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
80005d0e:	2f bd       	sub	sp,-20
80005d10:	d8 32       	popm	r0-r7,pc
80005d12:	00 00       	add	r0,r0
80005d14:	80 00       	ld.sh	r0,r0[0x0]
80005d16:	56 7c       	stdsp	sp[0x19c],r12
80005d18:	80 00       	ld.sh	r0,r0[0x0]
80005d1a:	5b 74       	cp.w	r4,-9
80005d1c:	80 00       	ld.sh	r0,r0[0x0]
80005d1e:	5f 48       	srge	r8
80005d20:	80 00       	ld.sh	r0,r0[0x0]
80005d22:	57 88       	stdsp	sp[0x1e0],r8
80005d24:	80 00       	ld.sh	r0,r0[0x0]
80005d26:	5e 3c       	retlo	r12
80005d28:	80 00       	ld.sh	r0,r0[0x0]
80005d2a:	5d b0       	*unknown*
80005d2c:	80 00       	ld.sh	r0,r0[0x0]
80005d2e:	60 d8       	ld.w	r8,r0[0x34]
80005d30:	80 00       	ld.sh	r0,r0[0x0]
80005d32:	63 30       	ld.w	r0,r1[0x4c]
80005d34:	80 00       	ld.sh	r0,r0[0x0]
80005d36:	59 90       	cp.w	r0,25
80005d38:	80 00       	ld.sh	r0,r0[0x0]
80005d3a:	61 6c       	ld.w	r12,r0[0x58]

80005d3c <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
80005d3c:	d4 21       	pushm	r4-r7,lr
80005d3e:	18 97       	mov	r7,r12
80005d40:	16 96       	mov	r6,r11
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
80005d42:	58 0c       	cp.w	r12,0
80005d44:	c2 f0       	breq	80005da2 <xQueueCreate+0x66>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
80005d46:	34 cc       	mov	r12,76
80005d48:	f0 1f 00 17 	mcall	80005da4 <xQueueCreate+0x68>
80005d4c:	18 95       	mov	r5,r12
		if( pxNewQueue != NULL )
80005d4e:	c2 a0       	breq	80005da2 <xQueueCreate+0x66>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
80005d50:	ec 07 02 44 	mul	r4,r6,r7

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
80005d54:	e8 cc ff ff 	sub	r12,r4,-1
80005d58:	f0 1f 00 13 	mcall	80005da4 <xQueueCreate+0x68>
80005d5c:	8b 0c       	st.w	r5[0x0],r12
			if( pxNewQueue->pcHead != NULL )
80005d5e:	c1 e0       	breq	80005d9a <xQueueCreate+0x5e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
80005d60:	f8 04 00 04 	add	r4,r12,r4
80005d64:	8b 14       	st.w	r5[0x4],r4
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
80005d66:	30 08       	mov	r8,0
80005d68:	8b e8       	st.w	r5[0x38],r8
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
80005d6a:	8b 2c       	st.w	r5[0x8],r12
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
80005d6c:	ee c8 00 01 	sub	r8,r7,1
80005d70:	ad 38       	mul	r8,r6
80005d72:	10 0c       	add	r12,r8
80005d74:	8b 3c       	st.w	r5[0xc],r12
				pxNewQueue->uxLength = uxQueueLength;
80005d76:	8b f7       	st.w	r5[0x3c],r7
				pxNewQueue->uxItemSize = uxItemSize;
80005d78:	eb 46 00 40 	st.w	r5[64],r6
				pxNewQueue->xRxLock = queueUNLOCKED;
80005d7c:	3f f8       	mov	r8,-1
80005d7e:	eb 48 00 44 	st.w	r5[68],r8
				pxNewQueue->xTxLock = queueUNLOCKED;
80005d82:	eb 48 00 48 	st.w	r5[72],r8

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
80005d86:	ea cc ff f0 	sub	r12,r5,-16
80005d8a:	f0 1f 00 08 	mcall	80005da8 <xQueueCreate+0x6c>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
80005d8e:	ea cc ff dc 	sub	r12,r5,-36
80005d92:	f0 1f 00 06 	mcall	80005da8 <xQueueCreate+0x6c>
80005d96:	0a 9c       	mov	r12,r5
80005d98:	d8 22       	popm	r4-r7,pc
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
80005d9a:	0a 9c       	mov	r12,r5
80005d9c:	f0 1f 00 04 	mcall	80005dac <xQueueCreate+0x70>
80005da0:	d8 2a       	popm	r4-r7,pc,r12=0
80005da2:	d8 2a       	popm	r4-r7,pc,r12=0
80005da4:	80 00       	ld.sh	r0,r0[0x0]
80005da6:	58 e8       	cp.w	r8,14
80005da8:	80 00       	ld.sh	r0,r0[0x0]
80005daa:	55 58       	stdsp	sp[0x154],r8
80005dac:	80 00       	ld.sh	r0,r0[0x0]
80005dae:	58 c0       	cp.w	r0,12

80005db0 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
80005db0:	48 38       	lddpc	r8,80005dbc <vTaskSuspendAll+0xc>
80005db2:	70 09       	ld.w	r9,r8[0x0]
80005db4:	2f f9       	sub	r9,-1
80005db6:	91 09       	st.w	r8[0x0],r9
}
80005db8:	5e fc       	retal	r12
80005dba:	00 00       	add	r0,r0
80005dbc:	00 00       	add	r0,r0
80005dbe:	0d 0c       	ld.w	r12,r6++

80005dc0 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
80005dc0:	49 a8       	lddpc	r8,80005e28 <vTaskSwitchContext+0x68>
80005dc2:	70 08       	ld.w	r8,r8[0x0]
80005dc4:	58 08       	cp.w	r8,0
80005dc6:	c0 b1       	brne	80005ddc <vTaskSwitchContext+0x1c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80005dc8:	49 98       	lddpc	r8,80005e2c <vTaskSwitchContext+0x6c>
80005dca:	70 08       	ld.w	r8,r8[0x0]
80005dcc:	f0 08 00 28 	add	r8,r8,r8<<0x2
80005dd0:	49 89       	lddpc	r9,80005e30 <vTaskSwitchContext+0x70>
80005dd2:	f2 08 03 28 	ld.w	r8,r9[r8<<0x2]
80005dd6:	58 08       	cp.w	r8,0
80005dd8:	c0 60       	breq	80005de4 <vTaskSwitchContext+0x24>
80005dda:	c1 18       	rjmp	80005dfc <vTaskSwitchContext+0x3c>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
80005ddc:	30 19       	mov	r9,1
80005dde:	49 68       	lddpc	r8,80005e34 <vTaskSwitchContext+0x74>
80005de0:	91 09       	st.w	r8[0x0],r9
80005de2:	5e fc       	retal	r12

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80005de4:	49 28       	lddpc	r8,80005e2c <vTaskSwitchContext+0x6c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80005de6:	49 3a       	lddpc	r10,80005e30 <vTaskSwitchContext+0x70>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80005de8:	70 09       	ld.w	r9,r8[0x0]
80005dea:	20 19       	sub	r9,1
80005dec:	91 09       	st.w	r8[0x0],r9

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80005dee:	70 09       	ld.w	r9,r8[0x0]
80005df0:	f2 09 00 29 	add	r9,r9,r9<<0x2
80005df4:	f4 09 03 29 	ld.w	r9,r10[r9<<0x2]
80005df8:	58 09       	cp.w	r9,0
80005dfa:	cf 70       	breq	80005de8 <vTaskSwitchContext+0x28>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
80005dfc:	48 c8       	lddpc	r8,80005e2c <vTaskSwitchContext+0x6c>
80005dfe:	70 08       	ld.w	r8,r8[0x0]
80005e00:	f0 08 00 28 	add	r8,r8,r8<<0x2
80005e04:	48 b9       	lddpc	r9,80005e30 <vTaskSwitchContext+0x70>
80005e06:	f2 08 00 28 	add	r8,r9,r8<<0x2
80005e0a:	70 19       	ld.w	r9,r8[0x4]
80005e0c:	72 19       	ld.w	r9,r9[0x4]
80005e0e:	91 19       	st.w	r8[0x4],r9
80005e10:	f0 ca ff f8 	sub	r10,r8,-8
80005e14:	14 39       	cp.w	r9,r10
80005e16:	f3 f9 00 01 	ld.weq	r9,r9[0x4]
80005e1a:	f1 f9 0a 01 	st.weq	r8[0x4],r9
80005e1e:	70 18       	ld.w	r8,r8[0x4]
80005e20:	70 39       	ld.w	r9,r8[0xc]
80005e22:	48 68       	lddpc	r8,80005e38 <vTaskSwitchContext+0x78>
80005e24:	91 09       	st.w	r8[0x0],r9
80005e26:	5e fc       	retal	r12
80005e28:	00 00       	add	r0,r0
80005e2a:	0d 0c       	ld.w	r12,r6++
80005e2c:	00 00       	add	r0,r0
80005e2e:	0d 44       	ld.w	r4,--r6
80005e30:	00 00       	add	r0,r0
80005e32:	0c 28       	rsub	r8,r6
80005e34:	00 00       	add	r0,r0
80005e36:	0d 2c       	ld.uh	r12,r6++
80005e38:	00 00       	add	r0,r0
80005e3a:	0c dc       	st.w	--r6,r12

80005e3c <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
80005e3c:	48 48       	lddpc	r8,80005e4c <vTaskSetTimeOutState+0x10>
80005e3e:	70 08       	ld.w	r8,r8[0x0]
80005e40:	99 08       	st.w	r12[0x0],r8
	pxTimeOut->xTimeOnEntering = xTickCount;
80005e42:	48 48       	lddpc	r8,80005e50 <vTaskSetTimeOutState+0x14>
80005e44:	70 08       	ld.w	r8,r8[0x0]
80005e46:	99 18       	st.w	r12[0x4],r8
}
80005e48:	5e fc       	retal	r12
80005e4a:	00 00       	add	r0,r0
80005e4c:	00 00       	add	r0,r0
80005e4e:	0c 20       	rsub	r0,r6
80005e50:	00 00       	add	r0,r0
80005e52:	0d 08       	ld.w	r8,r6++

80005e54 <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
80005e54:	30 19       	mov	r9,1
80005e56:	48 28       	lddpc	r8,80005e5c <vTaskMissedYield+0x8>
80005e58:	91 09       	st.w	r8[0x0],r9
}
80005e5a:	5e fc       	retal	r12
80005e5c:	00 00       	add	r0,r0
80005e5e:	0d 2c       	ld.uh	r12,r6++

80005e60 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
80005e60:	48 28       	lddpc	r8,80005e68 <xTaskGetCurrentTaskHandle+0x8>
80005e62:	70 0c       	ld.w	r12,r8[0x0]

		return xReturn;
	}
80005e64:	5e fc       	retal	r12
80005e66:	00 00       	add	r0,r0
80005e68:	00 00       	add	r0,r0
80005e6a:	0c dc       	st.w	--r6,r12

80005e6c <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
80005e6c:	eb cd 40 c0 	pushm	r6-r7,lr
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
80005e70:	58 0c       	cp.w	r12,0
80005e72:	c1 f0       	breq	80005eb0 <vTaskPriorityDisinherit+0x44>

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
80005e74:	18 97       	mov	r7,r12

		if( pxMutexHolder != NULL )
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
80005e76:	78 b9       	ld.w	r9,r12[0x2c]
80005e78:	79 18       	ld.w	r8,r12[0x44]
80005e7a:	10 39       	cp.w	r9,r8
80005e7c:	c1 a0       	breq	80005eb0 <vTaskPriorityDisinherit+0x44>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
80005e7e:	f8 c6 ff fc 	sub	r6,r12,-4
80005e82:	0c 9c       	mov	r12,r6
80005e84:	f0 1f 00 0c 	mcall	80005eb4 <vTaskPriorityDisinherit+0x48>

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
80005e88:	6f 1c       	ld.w	r12,r7[0x44]
80005e8a:	8f bc       	st.w	r7[0x2c],r12
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
80005e8c:	f8 08 11 08 	rsub	r8,r12,8
80005e90:	8f 68       	st.w	r7[0x18],r8
				prvAddTaskToReadyQueue( pxTCB );
80005e92:	48 a8       	lddpc	r8,80005eb8 <vTaskPriorityDisinherit+0x4c>
80005e94:	70 08       	ld.w	r8,r8[0x0]
80005e96:	10 3c       	cp.w	r12,r8
80005e98:	e0 88 00 04 	brls	80005ea0 <vTaskPriorityDisinherit+0x34>
80005e9c:	48 78       	lddpc	r8,80005eb8 <vTaskPriorityDisinherit+0x4c>
80005e9e:	91 0c       	st.w	r8[0x0],r12
80005ea0:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005ea4:	0c 9b       	mov	r11,r6
80005ea6:	48 68       	lddpc	r8,80005ebc <vTaskPriorityDisinherit+0x50>
80005ea8:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80005eac:	f0 1f 00 05 	mcall	80005ec0 <vTaskPriorityDisinherit+0x54>
80005eb0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005eb4:	80 00       	ld.sh	r0,r0[0x0]
80005eb6:	55 c2       	stdsp	sp[0x170],r2
80005eb8:	00 00       	add	r0,r0
80005eba:	0d 44       	ld.w	r4,--r6
80005ebc:	00 00       	add	r0,r0
80005ebe:	0c 28       	rsub	r8,r6
80005ec0:	80 00       	ld.sh	r0,r0[0x0]
80005ec2:	55 72       	stdsp	sp[0x15c],r2

80005ec4 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
80005ec4:	eb cd 40 c0 	pushm	r6-r7,lr
80005ec8:	18 97       	mov	r7,r12
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
80005eca:	49 b8       	lddpc	r8,80005f34 <vTaskPriorityInherit+0x70>
80005ecc:	70 08       	ld.w	r8,r8[0x0]
80005ece:	78 b9       	ld.w	r9,r12[0x2c]
80005ed0:	70 b8       	ld.w	r8,r8[0x2c]
80005ed2:	10 39       	cp.w	r9,r8
80005ed4:	c2 d2       	brcc	80005f2e <vTaskPriorityInherit+0x6a>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
80005ed6:	49 88       	lddpc	r8,80005f34 <vTaskPriorityInherit+0x70>
80005ed8:	70 08       	ld.w	r8,r8[0x0]
80005eda:	70 b8       	ld.w	r8,r8[0x2c]
80005edc:	f0 08 11 08 	rsub	r8,r8,8
80005ee0:	99 68       	st.w	r12[0x18],r8

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
80005ee2:	f2 09 00 28 	add	r8,r9,r9<<0x2
80005ee6:	49 59       	lddpc	r9,80005f38 <vTaskPriorityInherit+0x74>
80005ee8:	f2 08 00 28 	add	r8,r9,r8<<0x2
80005eec:	78 59       	ld.w	r9,r12[0x14]
80005eee:	10 39       	cp.w	r9,r8
80005ef0:	c1 b1       	brne	80005f26 <vTaskPriorityInherit+0x62>
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
80005ef2:	f8 c6 ff fc 	sub	r6,r12,-4
80005ef6:	0c 9c       	mov	r12,r6
80005ef8:	f0 1f 00 11 	mcall	80005f3c <vTaskPriorityInherit+0x78>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
80005efc:	48 e8       	lddpc	r8,80005f34 <vTaskPriorityInherit+0x70>
80005efe:	70 08       	ld.w	r8,r8[0x0]
80005f00:	70 bc       	ld.w	r12,r8[0x2c]
80005f02:	8f bc       	st.w	r7[0x2c],r12
				prvAddTaskToReadyQueue( pxTCB );
80005f04:	48 f8       	lddpc	r8,80005f40 <vTaskPriorityInherit+0x7c>
80005f06:	70 08       	ld.w	r8,r8[0x0]
80005f08:	10 3c       	cp.w	r12,r8
80005f0a:	e0 88 00 04 	brls	80005f12 <vTaskPriorityInherit+0x4e>
80005f0e:	48 d8       	lddpc	r8,80005f40 <vTaskPriorityInherit+0x7c>
80005f10:	91 0c       	st.w	r8[0x0],r12
80005f12:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005f16:	0c 9b       	mov	r11,r6
80005f18:	48 88       	lddpc	r8,80005f38 <vTaskPriorityInherit+0x74>
80005f1a:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80005f1e:	f0 1f 00 0a 	mcall	80005f44 <vTaskPriorityInherit+0x80>
80005f22:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
80005f26:	48 48       	lddpc	r8,80005f34 <vTaskPriorityInherit+0x70>
80005f28:	70 08       	ld.w	r8,r8[0x0]
80005f2a:	70 b8       	ld.w	r8,r8[0x2c]
80005f2c:	99 b8       	st.w	r12[0x2c],r8
80005f2e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005f32:	00 00       	add	r0,r0
80005f34:	00 00       	add	r0,r0
80005f36:	0c dc       	st.w	--r6,r12
80005f38:	00 00       	add	r0,r0
80005f3a:	0c 28       	rsub	r8,r6
80005f3c:	80 00       	ld.sh	r0,r0[0x0]
80005f3e:	55 c2       	stdsp	sp[0x170],r2
80005f40:	00 00       	add	r0,r0
80005f42:	0d 44       	ld.w	r4,--r6
80005f44:	80 00       	ld.sh	r0,r0[0x0]
80005f46:	55 72       	stdsp	sp[0x15c],r2

80005f48 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
80005f48:	eb cd 40 c0 	pushm	r6-r7,lr
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
80005f4c:	78 38       	ld.w	r8,r12[0xc]
80005f4e:	70 37       	ld.w	r7,r8[0xc]
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
80005f50:	ee c6 ff e8 	sub	r6,r7,-24
80005f54:	0c 9c       	mov	r12,r6
80005f56:	f0 1f 00 15 	mcall	80005fa8 <xTaskRemoveFromEventList+0x60>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80005f5a:	49 58       	lddpc	r8,80005fac <xTaskRemoveFromEventList+0x64>
80005f5c:	70 08       	ld.w	r8,r8[0x0]
80005f5e:	58 08       	cp.w	r8,0
80005f60:	c1 71       	brne	80005f8e <xTaskRemoveFromEventList+0x46>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
80005f62:	ee c6 ff fc 	sub	r6,r7,-4
80005f66:	0c 9c       	mov	r12,r6
80005f68:	f0 1f 00 10 	mcall	80005fa8 <xTaskRemoveFromEventList+0x60>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
80005f6c:	6e bc       	ld.w	r12,r7[0x2c]
80005f6e:	49 18       	lddpc	r8,80005fb0 <xTaskRemoveFromEventList+0x68>
80005f70:	70 08       	ld.w	r8,r8[0x0]
80005f72:	10 3c       	cp.w	r12,r8
80005f74:	e0 88 00 04 	brls	80005f7c <xTaskRemoveFromEventList+0x34>
80005f78:	48 e8       	lddpc	r8,80005fb0 <xTaskRemoveFromEventList+0x68>
80005f7a:	91 0c       	st.w	r8[0x0],r12
80005f7c:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005f80:	0c 9b       	mov	r11,r6
80005f82:	48 d8       	lddpc	r8,80005fb4 <xTaskRemoveFromEventList+0x6c>
80005f84:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80005f88:	f0 1f 00 0c 	mcall	80005fb8 <xTaskRemoveFromEventList+0x70>
80005f8c:	c0 58       	rjmp	80005f96 <xTaskRemoveFromEventList+0x4e>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
80005f8e:	0c 9b       	mov	r11,r6
80005f90:	48 bc       	lddpc	r12,80005fbc <xTaskRemoveFromEventList+0x74>
80005f92:	f0 1f 00 0a 	mcall	80005fb8 <xTaskRemoveFromEventList+0x70>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
80005f96:	48 b8       	lddpc	r8,80005fc0 <xTaskRemoveFromEventList+0x78>
80005f98:	70 08       	ld.w	r8,r8[0x0]
80005f9a:	6e b9       	ld.w	r9,r7[0x2c]
80005f9c:	70 b8       	ld.w	r8,r8[0x2c]
80005f9e:	10 39       	cp.w	r9,r8
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
80005fa0:	5f 2c       	srhs	r12
80005fa2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005fa6:	00 00       	add	r0,r0
80005fa8:	80 00       	ld.sh	r0,r0[0x0]
80005faa:	55 c2       	stdsp	sp[0x170],r2
80005fac:	00 00       	add	r0,r0
80005fae:	0d 0c       	ld.w	r12,r6++
80005fb0:	00 00       	add	r0,r0
80005fb2:	0d 44       	ld.w	r4,--r6
80005fb4:	00 00       	add	r0,r0
80005fb6:	0c 28       	rsub	r8,r6
80005fb8:	80 00       	ld.sh	r0,r0[0x0]
80005fba:	55 72       	stdsp	sp[0x15c],r2
80005fbc:	00 00       	add	r0,r0
80005fbe:	0c e0       	st.h	--r6,r0
80005fc0:	00 00       	add	r0,r0
80005fc2:	0c dc       	st.w	--r6,r12

80005fc4 <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
80005fc4:	eb cd 40 fc 	pushm	r2-r7,lr
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80005fc8:	4b 98       	lddpc	r8,800060ac <vTaskIncrementTick+0xe8>
80005fca:	70 08       	ld.w	r8,r8[0x0]
80005fcc:	58 08       	cp.w	r8,0
80005fce:	c6 91       	brne	800060a0 <vTaskIncrementTick+0xdc>
	{
		++xTickCount;
80005fd0:	4b 88       	lddpc	r8,800060b0 <vTaskIncrementTick+0xec>
80005fd2:	70 09       	ld.w	r9,r8[0x0]
80005fd4:	2f f9       	sub	r9,-1
80005fd6:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
80005fd8:	70 08       	ld.w	r8,r8[0x0]
80005fda:	58 08       	cp.w	r8,0
80005fdc:	c1 a1       	brne	80006010 <vTaskIncrementTick+0x4c>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
80005fde:	4b 68       	lddpc	r8,800060b4 <vTaskIncrementTick+0xf0>
80005fe0:	70 0a       	ld.w	r10,r8[0x0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
80005fe2:	4b 69       	lddpc	r9,800060b8 <vTaskIncrementTick+0xf4>
80005fe4:	72 0b       	ld.w	r11,r9[0x0]
80005fe6:	91 0b       	st.w	r8[0x0],r11
			pxOverflowDelayedTaskList = pxTemp;
80005fe8:	93 0a       	st.w	r9[0x0],r10
			xNumOfOverflows++;
80005fea:	4b 59       	lddpc	r9,800060bc <vTaskIncrementTick+0xf8>
80005fec:	72 0a       	ld.w	r10,r9[0x0]
80005fee:	2f fa       	sub	r10,-1
80005ff0:	93 0a       	st.w	r9[0x0],r10

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
80005ff2:	70 08       	ld.w	r8,r8[0x0]
80005ff4:	70 08       	ld.w	r8,r8[0x0]
80005ff6:	58 08       	cp.w	r8,0
80005ff8:	c0 51       	brne	80006002 <vTaskIncrementTick+0x3e>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
80005ffa:	3f f9       	mov	r9,-1
80005ffc:	4b 18       	lddpc	r8,800060c0 <vTaskIncrementTick+0xfc>
80005ffe:	91 09       	st.w	r8[0x0],r9
80006000:	c0 88       	rjmp	80006010 <vTaskIncrementTick+0x4c>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
80006002:	4a d8       	lddpc	r8,800060b4 <vTaskIncrementTick+0xf0>
80006004:	70 08       	ld.w	r8,r8[0x0]
80006006:	70 38       	ld.w	r8,r8[0xc]
80006008:	70 38       	ld.w	r8,r8[0xc]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
8000600a:	70 19       	ld.w	r9,r8[0x4]
8000600c:	4a d8       	lddpc	r8,800060c0 <vTaskIncrementTick+0xfc>
8000600e:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
80006010:	4a 88       	lddpc	r8,800060b0 <vTaskIncrementTick+0xec>
80006012:	70 09       	ld.w	r9,r8[0x0]
80006014:	4a b8       	lddpc	r8,800060c0 <vTaskIncrementTick+0xfc>
80006016:	70 08       	ld.w	r8,r8[0x0]
80006018:	10 39       	cp.w	r9,r8
8000601a:	c4 73       	brcs	800060a8 <vTaskIncrementTick+0xe4>
8000601c:	4a 68       	lddpc	r8,800060b4 <vTaskIncrementTick+0xf0>
8000601e:	70 08       	ld.w	r8,r8[0x0]
80006020:	70 08       	ld.w	r8,r8[0x0]
80006022:	58 08       	cp.w	r8,0
80006024:	c0 c0       	breq	8000603c <vTaskIncrementTick+0x78>
80006026:	4a 48       	lddpc	r8,800060b4 <vTaskIncrementTick+0xf0>
80006028:	70 08       	ld.w	r8,r8[0x0]
8000602a:	70 38       	ld.w	r8,r8[0xc]
8000602c:	70 37       	ld.w	r7,r8[0xc]
8000602e:	6e 18       	ld.w	r8,r7[0x4]
80006030:	4a 09       	lddpc	r9,800060b0 <vTaskIncrementTick+0xec>
80006032:	72 09       	ld.w	r9,r9[0x0]
80006034:	12 38       	cp.w	r8,r9
80006036:	e0 88 00 14 	brls	8000605e <vTaskIncrementTick+0x9a>
8000603a:	c0 e8       	rjmp	80006056 <vTaskIncrementTick+0x92>
8000603c:	3f f9       	mov	r9,-1
8000603e:	4a 18       	lddpc	r8,800060c0 <vTaskIncrementTick+0xfc>
80006040:	91 09       	st.w	r8[0x0],r9
80006042:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80006046:	6a 08       	ld.w	r8,r5[0x0]
80006048:	70 38       	ld.w	r8,r8[0xc]
8000604a:	70 37       	ld.w	r7,r8[0xc]
8000604c:	6e 18       	ld.w	r8,r7[0x4]
8000604e:	64 09       	ld.w	r9,r2[0x0]
80006050:	12 38       	cp.w	r8,r9
80006052:	e0 88 00 0a 	brls	80006066 <vTaskIncrementTick+0xa2>
80006056:	49 b9       	lddpc	r9,800060c0 <vTaskIncrementTick+0xfc>
80006058:	93 08       	st.w	r9[0x0],r8
8000605a:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
8000605e:	49 a4       	lddpc	r4,800060c4 <vTaskIncrementTick+0x100>
80006060:	49 a3       	lddpc	r3,800060c8 <vTaskIncrementTick+0x104>
80006062:	49 55       	lddpc	r5,800060b4 <vTaskIncrementTick+0xf0>
80006064:	49 32       	lddpc	r2,800060b0 <vTaskIncrementTick+0xec>
80006066:	ee c6 ff fc 	sub	r6,r7,-4
8000606a:	0c 9c       	mov	r12,r6
8000606c:	f0 1f 00 18 	mcall	800060cc <vTaskIncrementTick+0x108>
80006070:	6e a8       	ld.w	r8,r7[0x28]
80006072:	58 08       	cp.w	r8,0
80006074:	c0 50       	breq	8000607e <vTaskIncrementTick+0xba>
80006076:	ee cc ff e8 	sub	r12,r7,-24
8000607a:	f0 1f 00 15 	mcall	800060cc <vTaskIncrementTick+0x108>
8000607e:	6e bc       	ld.w	r12,r7[0x2c]
80006080:	68 08       	ld.w	r8,r4[0x0]
80006082:	10 3c       	cp.w	r12,r8
80006084:	e9 fc ba 00 	st.whi	r4[0x0],r12
80006088:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
8000608c:	0c 9b       	mov	r11,r6
8000608e:	e6 0c 00 2c 	add	r12,r3,r12<<0x2
80006092:	f0 1f 00 10 	mcall	800060d0 <vTaskIncrementTick+0x10c>
80006096:	6a 08       	ld.w	r8,r5[0x0]
80006098:	70 08       	ld.w	r8,r8[0x0]
8000609a:	58 08       	cp.w	r8,0
8000609c:	cd 51       	brne	80006046 <vTaskIncrementTick+0x82>
8000609e:	cc fb       	rjmp	8000603c <vTaskIncrementTick+0x78>
	}
	else
	{
		++uxMissedTicks;
800060a0:	48 d8       	lddpc	r8,800060d4 <vTaskIncrementTick+0x110>
800060a2:	70 09       	ld.w	r9,r8[0x0]
800060a4:	2f f9       	sub	r9,-1
800060a6:	91 09       	st.w	r8[0x0],r9
800060a8:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800060ac:	00 00       	add	r0,r0
800060ae:	0d 0c       	ld.w	r12,r6++
800060b0:	00 00       	add	r0,r0
800060b2:	0d 08       	ld.w	r8,r6++
800060b4:	00 00       	add	r0,r0
800060b6:	0c 14       	sub	r4,r6
800060b8:	00 00       	add	r0,r0
800060ba:	0c 24       	rsub	r4,r6
800060bc:	00 00       	add	r0,r0
800060be:	0c 20       	rsub	r0,r6
800060c0:	00 00       	add	r0,r0
800060c2:	05 38       	ld.ub	r8,r2++
800060c4:	00 00       	add	r0,r0
800060c6:	0d 44       	ld.w	r4,--r6
800060c8:	00 00       	add	r0,r0
800060ca:	0c 28       	rsub	r8,r6
800060cc:	80 00       	ld.sh	r0,r0[0x0]
800060ce:	55 c2       	stdsp	sp[0x170],r2
800060d0:	80 00       	ld.sh	r0,r0[0x0]
800060d2:	55 72       	stdsp	sp[0x15c],r2
800060d4:	00 00       	add	r0,r0
800060d6:	0c 0c       	add	r12,r6

800060d8 <xTaskCheckForTimeOut>:
	pxTimeOut->xTimeOnEntering = xTickCount;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
800060d8:	eb cd 40 c0 	pushm	r6-r7,lr
800060dc:	18 97       	mov	r7,r12
800060de:	16 96       	mov	r6,r11
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
800060e0:	f0 1f 00 15 	mcall	80006134 <xTaskCheckForTimeOut+0x5c>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
800060e4:	6c 08       	ld.w	r8,r6[0x0]
800060e6:	5b f8       	cp.w	r8,-1
800060e8:	c0 31       	brne	800060ee <xTaskCheckForTimeOut+0x16>
800060ea:	30 07       	mov	r7,0
800060ec:	c1 f8       	rjmp	8000612a <xTaskCheckForTimeOut+0x52>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
800060ee:	49 39       	lddpc	r9,80006138 <xTaskCheckForTimeOut+0x60>
800060f0:	72 09       	ld.w	r9,r9[0x0]
800060f2:	6e 0a       	ld.w	r10,r7[0x0]
800060f4:	12 3a       	cp.w	r10,r9
800060f6:	c0 70       	breq	80006104 <xTaskCheckForTimeOut+0x2c>
800060f8:	49 19       	lddpc	r9,8000613c <xTaskCheckForTimeOut+0x64>
800060fa:	72 09       	ld.w	r9,r9[0x0]
800060fc:	6e 1a       	ld.w	r10,r7[0x4]
800060fe:	12 3a       	cp.w	r10,r9
80006100:	e0 88 00 14 	brls	80006128 <xTaskCheckForTimeOut+0x50>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
80006104:	48 e9       	lddpc	r9,8000613c <xTaskCheckForTimeOut+0x64>
80006106:	72 0a       	ld.w	r10,r9[0x0]
80006108:	6e 19       	ld.w	r9,r7[0x4]
8000610a:	12 1a       	sub	r10,r9
8000610c:	14 38       	cp.w	r8,r10
8000610e:	e0 88 00 0d 	brls	80006128 <xTaskCheckForTimeOut+0x50>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
80006112:	48 ba       	lddpc	r10,8000613c <xTaskCheckForTimeOut+0x64>
80006114:	74 0a       	ld.w	r10,r10[0x0]
80006116:	14 19       	sub	r9,r10
80006118:	f2 08 00 08 	add	r8,r9,r8
8000611c:	8d 08       	st.w	r6[0x0],r8
			vTaskSetTimeOutState( pxTimeOut );
8000611e:	0e 9c       	mov	r12,r7
80006120:	f0 1f 00 08 	mcall	80006140 <xTaskCheckForTimeOut+0x68>
80006124:	30 07       	mov	r7,0
80006126:	c0 28       	rjmp	8000612a <xTaskCheckForTimeOut+0x52>
80006128:	30 17       	mov	r7,1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
8000612a:	f0 1f 00 07 	mcall	80006144 <xTaskCheckForTimeOut+0x6c>

	return xReturn;
}
8000612e:	0e 9c       	mov	r12,r7
80006130:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006134:	80 00       	ld.sh	r0,r0[0x0]
80006136:	56 7c       	stdsp	sp[0x19c],r12
80006138:	00 00       	add	r0,r0
8000613a:	0c 20       	rsub	r0,r6
8000613c:	00 00       	add	r0,r0
8000613e:	0d 08       	ld.w	r8,r6++
80006140:	80 00       	ld.sh	r0,r0[0x0]
80006142:	5e 3c       	retlo	r12
80006144:	80 00       	ld.sh	r0,r0[0x0]
80006146:	57 88       	stdsp	sp[0x1e0],r8

80006148 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
80006148:	eb cd 40 80 	pushm	r7,lr
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
8000614c:	f0 1f 00 05 	mcall	80006160 <xTaskGetTickCount+0x18>
	{
		xTicks = xTickCount;
80006150:	48 58       	lddpc	r8,80006164 <xTaskGetTickCount+0x1c>
80006152:	70 07       	ld.w	r7,r8[0x0]
	}
	taskEXIT_CRITICAL();
80006154:	f0 1f 00 05 	mcall	80006168 <xTaskGetTickCount+0x20>

	return xTicks;
}
80006158:	0e 9c       	mov	r12,r7
8000615a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000615e:	00 00       	add	r0,r0
80006160:	80 00       	ld.sh	r0,r0[0x0]
80006162:	56 7c       	stdsp	sp[0x19c],r12
80006164:	00 00       	add	r0,r0
80006166:	0d 08       	ld.w	r8,r6++
80006168:	80 00       	ld.sh	r0,r0[0x0]
8000616a:	57 88       	stdsp	sp[0x1e0],r8

8000616c <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
8000616c:	eb cd 40 fe 	pushm	r1-r7,lr
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
80006170:	f0 1f 00 2c 	mcall	80006220 <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;
80006174:	4a c8       	lddpc	r8,80006224 <xTaskResumeAll+0xb8>
80006176:	70 09       	ld.w	r9,r8[0x0]
80006178:	20 19       	sub	r9,1
8000617a:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
8000617c:	70 08       	ld.w	r8,r8[0x0]
8000617e:	58 08       	cp.w	r8,0
80006180:	c4 91       	brne	80006212 <xTaskResumeAll+0xa6>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
80006182:	4a a8       	lddpc	r8,80006228 <xTaskResumeAll+0xbc>
80006184:	70 08       	ld.w	r8,r8[0x0]
80006186:	58 08       	cp.w	r8,0
80006188:	c4 50       	breq	80006212 <xTaskResumeAll+0xa6>
8000618a:	30 04       	mov	r4,0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
8000618c:	4a 85       	lddpc	r5,8000622c <xTaskResumeAll+0xc0>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
8000618e:	4a 93       	lddpc	r3,80006230 <xTaskResumeAll+0xc4>
80006190:	4a 92       	lddpc	r2,80006234 <xTaskResumeAll+0xc8>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80006192:	4a a1       	lddpc	r1,80006238 <xTaskResumeAll+0xcc>
80006194:	c1 e8       	rjmp	800061d0 <xTaskResumeAll+0x64>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
80006196:	6a 38       	ld.w	r8,r5[0xc]
80006198:	70 37       	ld.w	r7,r8[0xc]
					vListRemove( &( pxTCB->xEventListItem ) );
8000619a:	ee cc ff e8 	sub	r12,r7,-24
8000619e:	f0 1f 00 28 	mcall	8000623c <xTaskResumeAll+0xd0>
					vListRemove( &( pxTCB->xGenericListItem ) );
800061a2:	ee c6 ff fc 	sub	r6,r7,-4
800061a6:	0c 9c       	mov	r12,r6
800061a8:	f0 1f 00 25 	mcall	8000623c <xTaskResumeAll+0xd0>
					prvAddTaskToReadyQueue( pxTCB );
800061ac:	6e bc       	ld.w	r12,r7[0x2c]
800061ae:	66 08       	ld.w	r8,r3[0x0]
800061b0:	10 3c       	cp.w	r12,r8
800061b2:	e7 fc ba 00 	st.whi	r3[0x0],r12
800061b6:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800061ba:	0c 9b       	mov	r11,r6
800061bc:	e4 0c 00 2c 	add	r12,r2,r12<<0x2
800061c0:	f0 1f 00 20 	mcall	80006240 <xTaskResumeAll+0xd4>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
800061c4:	62 08       	ld.w	r8,r1[0x0]
800061c6:	6e b9       	ld.w	r9,r7[0x2c]
800061c8:	70 b8       	ld.w	r8,r8[0x2c]
800061ca:	10 39       	cp.w	r9,r8
800061cc:	f9 b4 02 01 	movhs	r4,1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
800061d0:	6a 08       	ld.w	r8,r5[0x0]
800061d2:	58 08       	cp.w	r8,0
800061d4:	ce 11       	brne	80006196 <xTaskResumeAll+0x2a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
800061d6:	49 c8       	lddpc	r8,80006244 <xTaskResumeAll+0xd8>
800061d8:	70 08       	ld.w	r8,r8[0x0]
800061da:	58 08       	cp.w	r8,0
800061dc:	c0 f0       	breq	800061fa <xTaskResumeAll+0x8e>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
800061de:	49 a8       	lddpc	r8,80006244 <xTaskResumeAll+0xd8>
800061e0:	70 08       	ld.w	r8,r8[0x0]
800061e2:	58 08       	cp.w	r8,0
800061e4:	c1 10       	breq	80006206 <xTaskResumeAll+0x9a>
					{
						vTaskIncrementTick();
						--uxMissedTicks;
800061e6:	49 87       	lddpc	r7,80006244 <xTaskResumeAll+0xd8>
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
800061e8:	f0 1f 00 18 	mcall	80006248 <xTaskResumeAll+0xdc>
						--uxMissedTicks;
800061ec:	6e 08       	ld.w	r8,r7[0x0]
800061ee:	20 18       	sub	r8,1
800061f0:	8f 08       	st.w	r7[0x0],r8
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
800061f2:	6e 08       	ld.w	r8,r7[0x0]
800061f4:	58 08       	cp.w	r8,0
800061f6:	cf 91       	brne	800061e8 <xTaskResumeAll+0x7c>
800061f8:	c0 78       	rjmp	80006206 <xTaskResumeAll+0x9a>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
800061fa:	58 14       	cp.w	r4,1
800061fc:	c0 50       	breq	80006206 <xTaskResumeAll+0x9a>
800061fe:	49 48       	lddpc	r8,8000624c <xTaskResumeAll+0xe0>
80006200:	70 08       	ld.w	r8,r8[0x0]
80006202:	58 18       	cp.w	r8,1
80006204:	c0 71       	brne	80006212 <xTaskResumeAll+0xa6>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
80006206:	30 09       	mov	r9,0
80006208:	49 18       	lddpc	r8,8000624c <xTaskResumeAll+0xe0>
8000620a:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
8000620c:	d7 33       	scall
8000620e:	30 17       	mov	r7,1
80006210:	c0 28       	rjmp	80006214 <xTaskResumeAll+0xa8>
80006212:	30 07       	mov	r7,0
				}
			}
		}
	}
	taskEXIT_CRITICAL();
80006214:	f0 1f 00 0f 	mcall	80006250 <xTaskResumeAll+0xe4>

	return xAlreadyYielded;
}
80006218:	0e 9c       	mov	r12,r7
8000621a:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
8000621e:	00 00       	add	r0,r0
80006220:	80 00       	ld.sh	r0,r0[0x0]
80006222:	56 7c       	stdsp	sp[0x19c],r12
80006224:	00 00       	add	r0,r0
80006226:	0d 0c       	ld.w	r12,r6++
80006228:	00 00       	add	r0,r0
8000622a:	0d 28       	ld.uh	r8,r6++
8000622c:	00 00       	add	r0,r0
8000622e:	0c e0       	st.h	--r6,r0
80006230:	00 00       	add	r0,r0
80006232:	0d 44       	ld.w	r4,--r6
80006234:	00 00       	add	r0,r0
80006236:	0c 28       	rsub	r8,r6
80006238:	00 00       	add	r0,r0
8000623a:	0c dc       	st.w	--r6,r12
8000623c:	80 00       	ld.sh	r0,r0[0x0]
8000623e:	55 c2       	stdsp	sp[0x170],r2
80006240:	80 00       	ld.sh	r0,r0[0x0]
80006242:	55 72       	stdsp	sp[0x15c],r2
80006244:	00 00       	add	r0,r0
80006246:	0c 0c       	add	r12,r6
80006248:	80 00       	ld.sh	r0,r0[0x0]
8000624a:	5f c4       	srvs	r4
8000624c:	00 00       	add	r0,r0
8000624e:	0d 2c       	ld.uh	r12,r6++
80006250:	80 00       	ld.sh	r0,r0[0x0]
80006252:	57 88       	stdsp	sp[0x1e0],r8

80006254 <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
80006254:	eb cd 40 80 	pushm	r7,lr
80006258:	18 97       	mov	r7,r12
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
8000625a:	49 08       	lddpc	r8,80006298 <prvAddCurrentTaskToDelayedList+0x44>
8000625c:	70 08       	ld.w	r8,r8[0x0]
8000625e:	91 1c       	st.w	r8[0x4],r12

	if( xTimeToWake < xTickCount )
80006260:	48 f8       	lddpc	r8,8000629c <prvAddCurrentTaskToDelayedList+0x48>
80006262:	70 08       	ld.w	r8,r8[0x0]
80006264:	10 3c       	cp.w	r12,r8
80006266:	c0 a2       	brcc	8000627a <prvAddCurrentTaskToDelayedList+0x26>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006268:	48 c8       	lddpc	r8,80006298 <prvAddCurrentTaskToDelayedList+0x44>
8000626a:	70 0b       	ld.w	r11,r8[0x0]
8000626c:	48 d8       	lddpc	r8,800062a0 <prvAddCurrentTaskToDelayedList+0x4c>
8000626e:	70 0c       	ld.w	r12,r8[0x0]
80006270:	2f cb       	sub	r11,-4
80006272:	f0 1f 00 0d 	mcall	800062a4 <prvAddCurrentTaskToDelayedList+0x50>
80006276:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
8000627a:	48 88       	lddpc	r8,80006298 <prvAddCurrentTaskToDelayedList+0x44>
8000627c:	70 0b       	ld.w	r11,r8[0x0]
8000627e:	48 b8       	lddpc	r8,800062a8 <prvAddCurrentTaskToDelayedList+0x54>
80006280:	70 0c       	ld.w	r12,r8[0x0]
80006282:	2f cb       	sub	r11,-4
80006284:	f0 1f 00 08 	mcall	800062a4 <prvAddCurrentTaskToDelayedList+0x50>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
80006288:	48 98       	lddpc	r8,800062ac <prvAddCurrentTaskToDelayedList+0x58>
8000628a:	70 08       	ld.w	r8,r8[0x0]
8000628c:	10 37       	cp.w	r7,r8
8000628e:	c0 32       	brcc	80006294 <prvAddCurrentTaskToDelayedList+0x40>
		{
			xNextTaskUnblockTime = xTimeToWake;
80006290:	48 78       	lddpc	r8,800062ac <prvAddCurrentTaskToDelayedList+0x58>
80006292:	91 07       	st.w	r8[0x0],r7
80006294:	e3 cd 80 80 	ldm	sp++,r7,pc
80006298:	00 00       	add	r0,r0
8000629a:	0c dc       	st.w	--r6,r12
8000629c:	00 00       	add	r0,r0
8000629e:	0d 08       	ld.w	r8,r6++
800062a0:	00 00       	add	r0,r0
800062a2:	0c 24       	rsub	r4,r6
800062a4:	80 00       	ld.sh	r0,r0[0x0]
800062a6:	55 8e       	stdsp	sp[0x160],lr
800062a8:	00 00       	add	r0,r0
800062aa:	0c 14       	sub	r4,r6
800062ac:	00 00       	add	r0,r0
800062ae:	05 38       	ld.ub	r8,r2++

800062b0 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
800062b0:	eb cd 40 c0 	pushm	r6-r7,lr
800062b4:	18 96       	mov	r6,r12
800062b6:	16 97       	mov	r7,r11
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0 ) );

		vTaskSuspendAll();
800062b8:	f0 1f 00 18 	mcall	80006318 <vTaskDelayUntil+0x68>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
800062bc:	6c 08       	ld.w	r8,r6[0x0]
800062be:	10 07       	add	r7,r8

			if( xTickCount < *pxPreviousWakeTime )
800062c0:	49 79       	lddpc	r9,8000631c <vTaskDelayUntil+0x6c>
800062c2:	72 09       	ld.w	r9,r9[0x0]
800062c4:	12 38       	cp.w	r8,r9
800062c6:	e0 88 00 0c 	brls	800062de <vTaskDelayUntil+0x2e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
800062ca:	0e 38       	cp.w	r8,r7
800062cc:	e0 88 00 22 	brls	80006310 <vTaskDelayUntil+0x60>
800062d0:	49 38       	lddpc	r8,8000631c <vTaskDelayUntil+0x6c>
800062d2:	70 08       	ld.w	r8,r8[0x0]
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
800062d4:	8d 07       	st.w	r6[0x0],r7

			if( xShouldDelay != pdFALSE )
800062d6:	10 37       	cp.w	r7,r8
800062d8:	e0 88 00 14 	brls	80006300 <vTaskDelayUntil+0x50>
800062dc:	c0 a8       	rjmp	800062f0 <vTaskDelayUntil+0x40>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
800062de:	0e 38       	cp.w	r8,r7
800062e0:	e0 8b 00 16 	brhi	8000630c <vTaskDelayUntil+0x5c>
800062e4:	48 e8       	lddpc	r8,8000631c <vTaskDelayUntil+0x6c>
800062e6:	70 08       	ld.w	r8,r8[0x0]
800062e8:	10 37       	cp.w	r7,r8
800062ea:	e0 8b 00 11 	brhi	8000630c <vTaskDelayUntil+0x5c>
800062ee:	c1 18       	rjmp	80006310 <vTaskDelayUntil+0x60>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800062f0:	48 c8       	lddpc	r8,80006320 <vTaskDelayUntil+0x70>
800062f2:	70 0c       	ld.w	r12,r8[0x0]
800062f4:	2f cc       	sub	r12,-4
800062f6:	f0 1f 00 0c 	mcall	80006324 <vTaskDelayUntil+0x74>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
800062fa:	0e 9c       	mov	r12,r7
800062fc:	f0 1f 00 0b 	mcall	80006328 <vTaskDelayUntil+0x78>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
80006300:	f0 1f 00 0b 	mcall	8000632c <vTaskDelayUntil+0x7c>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
80006304:	c0 81       	brne	80006314 <vTaskDelayUntil+0x64>
		{
			portYIELD_WITHIN_API();
80006306:	d7 33       	scall
80006308:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
8000630c:	8d 07       	st.w	r6[0x0],r7
8000630e:	cf 1b       	rjmp	800062f0 <vTaskDelayUntil+0x40>
80006310:	8d 07       	st.w	r6[0x0],r7
80006312:	cf 7b       	rjmp	80006300 <vTaskDelayUntil+0x50>
80006314:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006318:	80 00       	ld.sh	r0,r0[0x0]
8000631a:	5d b0       	*unknown*
8000631c:	00 00       	add	r0,r0
8000631e:	0d 08       	ld.w	r8,r6++
80006320:	00 00       	add	r0,r0
80006322:	0c dc       	st.w	--r6,r12
80006324:	80 00       	ld.sh	r0,r0[0x0]
80006326:	55 c2       	stdsp	sp[0x170],r2
80006328:	80 00       	ld.sh	r0,r0[0x0]
8000632a:	62 54       	ld.w	r4,r1[0x14]
8000632c:	80 00       	ld.sh	r0,r0[0x0]
8000632e:	61 6c       	ld.w	r12,r0[0x58]

80006330 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
80006330:	eb cd 40 c0 	pushm	r6-r7,lr
80006334:	16 96       	mov	r6,r11
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
80006336:	48 e7       	lddpc	r7,8000636c <vTaskPlaceOnEventList+0x3c>
80006338:	6e 0b       	ld.w	r11,r7[0x0]
8000633a:	2e 8b       	sub	r11,-24
8000633c:	f0 1f 00 0d 	mcall	80006370 <vTaskPlaceOnEventList+0x40>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006340:	6e 0c       	ld.w	r12,r7[0x0]
80006342:	2f cc       	sub	r12,-4
80006344:	f0 1f 00 0c 	mcall	80006374 <vTaskPlaceOnEventList+0x44>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
80006348:	5b f6       	cp.w	r6,-1
8000634a:	c0 81       	brne	8000635a <vTaskPlaceOnEventList+0x2a>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
8000634c:	6e 0b       	ld.w	r11,r7[0x0]
8000634e:	2f cb       	sub	r11,-4
80006350:	48 ac       	lddpc	r12,80006378 <vTaskPlaceOnEventList+0x48>
80006352:	f0 1f 00 0b 	mcall	8000637c <vTaskPlaceOnEventList+0x4c>
80006356:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
8000635a:	48 a8       	lddpc	r8,80006380 <vTaskPlaceOnEventList+0x50>
8000635c:	70 0c       	ld.w	r12,r8[0x0]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
8000635e:	ec 0c 00 0c 	add	r12,r6,r12
80006362:	f0 1f 00 09 	mcall	80006384 <vTaskPlaceOnEventList+0x54>
80006366:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000636a:	00 00       	add	r0,r0
8000636c:	00 00       	add	r0,r0
8000636e:	0c dc       	st.w	--r6,r12
80006370:	80 00       	ld.sh	r0,r0[0x0]
80006372:	55 8e       	stdsp	sp[0x160],lr
80006374:	80 00       	ld.sh	r0,r0[0x0]
80006376:	55 c2       	stdsp	sp[0x170],r2
80006378:	00 00       	add	r0,r0
8000637a:	0d 30       	ld.ub	r0,r6++
8000637c:	80 00       	ld.sh	r0,r0[0x0]
8000637e:	55 72       	stdsp	sp[0x15c],r2
80006380:	00 00       	add	r0,r0
80006382:	0d 08       	ld.w	r8,r6++
80006384:	80 00       	ld.sh	r0,r0[0x0]
80006386:	62 54       	ld.w	r4,r1[0x14]

80006388 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
80006388:	eb cd 40 f8 	pushm	r3-r7,lr
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
8000638c:	49 67       	lddpc	r7,800063e4 <prvIdleTask+0x5c>
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
8000638e:	49 74       	lddpc	r4,800063e8 <prvIdleTask+0x60>

				taskENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					--uxCurrentNumberOfTasks;
80006390:	49 73       	lddpc	r3,800063ec <prvIdleTask+0x64>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80006392:	49 85       	lddpc	r5,800063f0 <prvIdleTask+0x68>
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80006394:	6e 08       	ld.w	r8,r7[0x0]
80006396:	58 08       	cp.w	r8,0
80006398:	c1 e0       	breq	800063d4 <prvIdleTask+0x4c>
		{
			vTaskSuspendAll();
8000639a:	f0 1f 00 17 	mcall	800063f4 <prvIdleTask+0x6c>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
8000639e:	68 06       	ld.w	r6,r4[0x0]
			xTaskResumeAll();
800063a0:	f0 1f 00 16 	mcall	800063f8 <prvIdleTask+0x70>

			if( xListIsEmpty == pdFALSE )
800063a4:	58 06       	cp.w	r6,0
800063a6:	c1 70       	breq	800063d4 <prvIdleTask+0x4c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
800063a8:	f0 1f 00 15 	mcall	800063fc <prvIdleTask+0x74>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
800063ac:	68 38       	ld.w	r8,r4[0xc]
800063ae:	70 36       	ld.w	r6,r8[0xc]
					vListRemove( &( pxTCB->xGenericListItem ) );
800063b0:	ec cc ff fc 	sub	r12,r6,-4
800063b4:	f0 1f 00 13 	mcall	80006400 <prvIdleTask+0x78>
					--uxCurrentNumberOfTasks;
800063b8:	66 08       	ld.w	r8,r3[0x0]
800063ba:	20 18       	sub	r8,1
800063bc:	87 08       	st.w	r3[0x0],r8
					--uxTasksDeleted;
800063be:	6e 08       	ld.w	r8,r7[0x0]
800063c0:	20 18       	sub	r8,1
800063c2:	8f 08       	st.w	r7[0x0],r8
				}
				taskEXIT_CRITICAL();
800063c4:	f0 1f 00 10 	mcall	80006404 <prvIdleTask+0x7c>

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
800063c8:	6c cc       	ld.w	r12,r6[0x30]
800063ca:	f0 1f 00 10 	mcall	80006408 <prvIdleTask+0x80>
		vPortFree( pxTCB );
800063ce:	0c 9c       	mov	r12,r6
800063d0:	f0 1f 00 0e 	mcall	80006408 <prvIdleTask+0x80>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
800063d4:	6a 08       	ld.w	r8,r5[0x0]
800063d6:	58 18       	cp.w	r8,1
800063d8:	e0 88 00 03 	brls	800063de <prvIdleTask+0x56>
			{
				taskYIELD();
800063dc:	d7 33       	scall
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
800063de:	f0 1f 00 0c 	mcall	8000640c <prvIdleTask+0x84>
		}
		#endif
	}
800063e2:	cd 9b       	rjmp	80006394 <prvIdleTask+0xc>
800063e4:	00 00       	add	r0,r0
800063e6:	0c 1c       	sub	r12,r6
800063e8:	00 00       	add	r0,r0
800063ea:	0c c8       	st.b	r6++,r8
800063ec:	00 00       	add	r0,r0
800063ee:	0d 28       	ld.uh	r8,r6++
800063f0:	00 00       	add	r0,r0
800063f2:	0c 28       	rsub	r8,r6
800063f4:	80 00       	ld.sh	r0,r0[0x0]
800063f6:	5d b0       	*unknown*
800063f8:	80 00       	ld.sh	r0,r0[0x0]
800063fa:	61 6c       	ld.w	r12,r0[0x58]
800063fc:	80 00       	ld.sh	r0,r0[0x0]
800063fe:	56 7c       	stdsp	sp[0x19c],r12
80006400:	80 00       	ld.sh	r0,r0[0x0]
80006402:	55 c2       	stdsp	sp[0x170],r2
80006404:	80 00       	ld.sh	r0,r0[0x0]
80006406:	57 88       	stdsp	sp[0x1e0],r8
80006408:	80 00       	ld.sh	r0,r0[0x0]
8000640a:	58 c0       	cp.w	r0,12
8000640c:	80 00       	ld.sh	r0,r0[0x0]
8000640e:	20 30       	sub	r0,3

80006410 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
80006410:	d4 31       	pushm	r0-r7,lr
80006412:	20 1d       	sub	sp,4
80006414:	fa c4 ff d8 	sub	r4,sp,-40
80006418:	50 0c       	stdsp	sp[0x0],r12
8000641a:	16 91       	mov	r1,r11
8000641c:	14 97       	mov	r7,r10
8000641e:	12 90       	mov	r0,r9
80006420:	10 93       	mov	r3,r8
80006422:	68 02       	ld.w	r2,r4[0x0]
80006424:	68 16       	ld.w	r6,r4[0x4]
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
80006426:	34 8c       	mov	r12,72
80006428:	f0 1f 00 5c 	mcall	80006598 <xTaskGenericCreate+0x188>
8000642c:	18 95       	mov	r5,r12

	if( pxNewTCB != NULL )
8000642e:	c0 31       	brne	80006434 <xTaskGenericCreate+0x24>
80006430:	3f fc       	mov	r12,-1
80006432:	ca f8       	rjmp	80006590 <xTaskGenericCreate+0x180>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80006434:	58 06       	cp.w	r6,0
80006436:	e0 81 00 af 	brne	80006594 <xTaskGenericCreate+0x184>
8000643a:	0e 9c       	mov	r12,r7
8000643c:	5c 7c       	castu.h	r12
8000643e:	a3 6c       	lsl	r12,0x2
80006440:	f0 1f 00 56 	mcall	80006598 <xTaskGenericCreate+0x188>
80006444:	18 96       	mov	r6,r12
80006446:	8b cc       	st.w	r5[0x30],r12

		if( pxNewTCB->pxStack == NULL )
80006448:	c0 61       	brne	80006454 <xTaskGenericCreate+0x44>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
8000644a:	0a 9c       	mov	r12,r5
8000644c:	f0 1f 00 54 	mcall	8000659c <xTaskGenericCreate+0x18c>
80006450:	3f fc       	mov	r12,-1
80006452:	c9 f8       	rjmp	80006590 <xTaskGenericCreate+0x180>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
80006454:	5c 77       	castu.h	r7
80006456:	ee 0a 15 02 	lsl	r10,r7,0x2
8000645a:	e0 6b 00 a5 	mov	r11,165
8000645e:	0c 9c       	mov	r12,r6
80006460:	f0 1f 00 50 	mcall	800065a0 <xTaskGenericCreate+0x190>
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
80006464:	ee c6 00 01 	sub	r6,r7,1
80006468:	6a c8       	ld.w	r8,r5[0x30]
8000646a:	f0 06 00 26 	add	r6,r8,r6<<0x2
8000646e:	e0 16 ff fc 	andl	r6,0xfffc
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
80006472:	31 0a       	mov	r10,16
80006474:	02 9b       	mov	r11,r1
80006476:	ea cc ff cc 	sub	r12,r5,-52
8000647a:	f0 1f 00 4b 	mcall	800065a4 <xTaskGenericCreate+0x194>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
8000647e:	30 08       	mov	r8,0
80006480:	eb 68 00 43 	st.b	r5[67],r8
80006484:	58 73       	cp.w	r3,7
80006486:	e6 07 17 80 	movls	r7,r3
8000648a:	f9 b7 0b 07 	movhi	r7,7
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
8000648e:	8b b7       	st.w	r5[0x2c],r7
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
80006490:	eb 47 00 44 	st.w	r5[68],r7
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
80006494:	ea c4 ff fc 	sub	r4,r5,-4
80006498:	08 9c       	mov	r12,r4
8000649a:	f0 1f 00 44 	mcall	800065a8 <xTaskGenericCreate+0x198>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
8000649e:	ea cc ff e8 	sub	r12,r5,-24
800064a2:	f0 1f 00 42 	mcall	800065a8 <xTaskGenericCreate+0x198>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
800064a6:	8b 45       	st.w	r5[0x10],r5

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
800064a8:	ee 07 11 08 	rsub	r7,r7,8
800064ac:	8b 67       	st.w	r5[0x18],r7
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
800064ae:	8b 95       	st.w	r5[0x24],r5
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
800064b0:	00 9a       	mov	r10,r0
800064b2:	40 0b       	lddsp	r11,sp[0x0]
800064b4:	0c 9c       	mov	r12,r6
800064b6:	f0 1f 00 3e 	mcall	800065ac <xTaskGenericCreate+0x19c>
800064ba:	8b 0c       	st.w	r5[0x0],r12
		if( ( void * ) pxCreatedTask != NULL )
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
800064bc:	58 02       	cp.w	r2,0
800064be:	e5 f5 1a 00 	st.wne	r2[0x0],r5
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
800064c2:	f0 1f 00 3c 	mcall	800065b0 <xTaskGenericCreate+0x1a0>
		{
			uxCurrentNumberOfTasks++;
800064c6:	4b c8       	lddpc	r8,800065b4 <xTaskGenericCreate+0x1a4>
800064c8:	70 09       	ld.w	r9,r8[0x0]
800064ca:	2f f9       	sub	r9,-1
800064cc:	91 09       	st.w	r8[0x0],r9
			if( pxCurrentTCB == NULL )
800064ce:	4b b8       	lddpc	r8,800065b8 <xTaskGenericCreate+0x1a8>
800064d0:	70 08       	ld.w	r8,r8[0x0]
800064d2:	58 08       	cp.w	r8,0
800064d4:	c2 61       	brne	80006520 <xTaskGenericCreate+0x110>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
800064d6:	4b 98       	lddpc	r8,800065b8 <xTaskGenericCreate+0x1a8>
800064d8:	91 05       	st.w	r8[0x0],r5

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
800064da:	4b 78       	lddpc	r8,800065b4 <xTaskGenericCreate+0x1a4>
800064dc:	70 08       	ld.w	r8,r8[0x0]
800064de:	58 18       	cp.w	r8,1
800064e0:	c2 b1       	brne	80006536 <xTaskGenericCreate+0x126>
800064e2:	4b 77       	lddpc	r7,800065bc <xTaskGenericCreate+0x1ac>

/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
800064e4:	ee c6 ff 60 	sub	r6,r7,-160
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
800064e8:	0e 9c       	mov	r12,r7
800064ea:	f0 1f 00 36 	mcall	800065c0 <xTaskGenericCreate+0x1b0>
800064ee:	2e c7       	sub	r7,-20

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
800064f0:	0c 37       	cp.w	r7,r6
800064f2:	cf b1       	brne	800064e8 <xTaskGenericCreate+0xd8>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
800064f4:	4b 47       	lddpc	r7,800065c4 <xTaskGenericCreate+0x1b4>
800064f6:	0e 9c       	mov	r12,r7
800064f8:	f0 1f 00 32 	mcall	800065c0 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
800064fc:	4b 36       	lddpc	r6,800065c8 <xTaskGenericCreate+0x1b8>
800064fe:	0c 9c       	mov	r12,r6
80006500:	f0 1f 00 30 	mcall	800065c0 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xPendingReadyList );
80006504:	4b 2c       	lddpc	r12,800065cc <xTaskGenericCreate+0x1bc>
80006506:	f0 1f 00 2f 	mcall	800065c0 <xTaskGenericCreate+0x1b0>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
8000650a:	4b 2c       	lddpc	r12,800065d0 <xTaskGenericCreate+0x1c0>
8000650c:	f0 1f 00 2d 	mcall	800065c0 <xTaskGenericCreate+0x1b0>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
80006510:	4b 1c       	lddpc	r12,800065d4 <xTaskGenericCreate+0x1c4>
80006512:	f0 1f 00 2c 	mcall	800065c0 <xTaskGenericCreate+0x1b0>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
80006516:	4b 18       	lddpc	r8,800065d8 <xTaskGenericCreate+0x1c8>
80006518:	91 07       	st.w	r8[0x0],r7
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
8000651a:	4b 18       	lddpc	r8,800065dc <xTaskGenericCreate+0x1cc>
8000651c:	91 06       	st.w	r8[0x0],r6
8000651e:	c0 c8       	rjmp	80006536 <xTaskGenericCreate+0x126>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
80006520:	4b 08       	lddpc	r8,800065e0 <xTaskGenericCreate+0x1d0>
80006522:	70 08       	ld.w	r8,r8[0x0]
80006524:	58 08       	cp.w	r8,0
80006526:	c0 81       	brne	80006536 <xTaskGenericCreate+0x126>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
80006528:	4a 48       	lddpc	r8,800065b8 <xTaskGenericCreate+0x1a8>
8000652a:	70 08       	ld.w	r8,r8[0x0]
8000652c:	70 b8       	ld.w	r8,r8[0x2c]
8000652e:	10 33       	cp.w	r3,r8
80006530:	c0 33       	brcs	80006536 <xTaskGenericCreate+0x126>
					{
						pxCurrentTCB = pxNewTCB;
80006532:	4a 28       	lddpc	r8,800065b8 <xTaskGenericCreate+0x1a8>
80006534:	91 05       	st.w	r8[0x0],r5
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
80006536:	6a b8       	ld.w	r8,r5[0x2c]
80006538:	4a b9       	lddpc	r9,800065e4 <xTaskGenericCreate+0x1d4>
8000653a:	72 09       	ld.w	r9,r9[0x0]
8000653c:	12 38       	cp.w	r8,r9
8000653e:	e0 88 00 04 	brls	80006546 <xTaskGenericCreate+0x136>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
80006542:	4a 99       	lddpc	r9,800065e4 <xTaskGenericCreate+0x1d4>
80006544:	93 08       	st.w	r9[0x0],r8
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
80006546:	4a 98       	lddpc	r8,800065e8 <xTaskGenericCreate+0x1d8>
80006548:	70 09       	ld.w	r9,r8[0x0]
8000654a:	2f f9       	sub	r9,-1
8000654c:	91 09       	st.w	r8[0x0],r9

			prvAddTaskToReadyQueue( pxNewTCB );
8000654e:	6a b8       	ld.w	r8,r5[0x2c]
80006550:	4a 79       	lddpc	r9,800065ec <xTaskGenericCreate+0x1dc>
80006552:	72 09       	ld.w	r9,r9[0x0]
80006554:	12 38       	cp.w	r8,r9
80006556:	e0 88 00 04 	brls	8000655e <xTaskGenericCreate+0x14e>
8000655a:	4a 59       	lddpc	r9,800065ec <xTaskGenericCreate+0x1dc>
8000655c:	93 08       	st.w	r9[0x0],r8
8000655e:	6a bc       	ld.w	r12,r5[0x2c]
80006560:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006564:	08 9b       	mov	r11,r4
80006566:	49 68       	lddpc	r8,800065bc <xTaskGenericCreate+0x1ac>
80006568:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
8000656c:	f0 1f 00 21 	mcall	800065f0 <xTaskGenericCreate+0x1e0>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
80006570:	f0 1f 00 21 	mcall	800065f4 <xTaskGenericCreate+0x1e4>
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
80006574:	49 b8       	lddpc	r8,800065e0 <xTaskGenericCreate+0x1d0>
80006576:	70 08       	ld.w	r8,r8[0x0]
80006578:	58 08       	cp.w	r8,0
8000657a:	c0 a0       	breq	8000658e <xTaskGenericCreate+0x17e>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
8000657c:	48 f8       	lddpc	r8,800065b8 <xTaskGenericCreate+0x1a8>
8000657e:	70 08       	ld.w	r8,r8[0x0]
80006580:	70 b8       	ld.w	r8,r8[0x2c]
80006582:	10 33       	cp.w	r3,r8
80006584:	e0 88 00 05 	brls	8000658e <xTaskGenericCreate+0x17e>
			{
				portYIELD_WITHIN_API();
80006588:	d7 33       	scall
8000658a:	30 1c       	mov	r12,1
8000658c:	c0 28       	rjmp	80006590 <xTaskGenericCreate+0x180>
8000658e:	30 1c       	mov	r12,1
			}
		}
	}

	return xReturn;
}
80006590:	2f fd       	sub	sp,-4
80006592:	d8 32       	popm	r0-r7,pc
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80006594:	99 c6       	st.w	r12[0x30],r6
80006596:	c5 fb       	rjmp	80006454 <xTaskGenericCreate+0x44>
80006598:	80 00       	ld.sh	r0,r0[0x0]
8000659a:	58 e8       	cp.w	r8,14
8000659c:	80 00       	ld.sh	r0,r0[0x0]
8000659e:	58 c0       	cp.w	r0,12
800065a0:	80 00       	ld.sh	r0,r0[0x0]
800065a2:	72 d6       	ld.w	r6,r9[0x34]
800065a4:	80 00       	ld.sh	r0,r0[0x0]
800065a6:	76 28       	ld.w	r8,r11[0x8]
800065a8:	80 00       	ld.sh	r0,r0[0x0]
800065aa:	55 6c       	stdsp	sp[0x158],r12
800065ac:	80 00       	ld.sh	r0,r0[0x0]
800065ae:	55 e8       	stdsp	sp[0x178],r8
800065b0:	80 00       	ld.sh	r0,r0[0x0]
800065b2:	56 7c       	stdsp	sp[0x19c],r12
800065b4:	00 00       	add	r0,r0
800065b6:	0d 28       	ld.uh	r8,r6++
800065b8:	00 00       	add	r0,r0
800065ba:	0c dc       	st.w	--r6,r12
800065bc:	00 00       	add	r0,r0
800065be:	0c 28       	rsub	r8,r6
800065c0:	80 00       	ld.sh	r0,r0[0x0]
800065c2:	55 58       	stdsp	sp[0x154],r8
800065c4:	00 00       	add	r0,r0
800065c6:	0c f4       	st.b	--r6,r4
800065c8:	00 00       	add	r0,r0
800065ca:	0d 10       	ld.sh	r0,r6++
800065cc:	00 00       	add	r0,r0
800065ce:	0c e0       	st.h	--r6,r0
800065d0:	00 00       	add	r0,r0
800065d2:	0c c8       	st.b	r6++,r8
800065d4:	00 00       	add	r0,r0
800065d6:	0d 30       	ld.ub	r0,r6++
800065d8:	00 00       	add	r0,r0
800065da:	0c 14       	sub	r4,r6
800065dc:	00 00       	add	r0,r0
800065de:	0c 24       	rsub	r4,r6
800065e0:	00 00       	add	r0,r0
800065e2:	0c 18       	sub	r8,r6
800065e4:	00 00       	add	r0,r0
800065e6:	0c 10       	sub	r0,r6
800065e8:	00 00       	add	r0,r0
800065ea:	0d 24       	ld.uh	r4,r6++
800065ec:	00 00       	add	r0,r0
800065ee:	0d 44       	ld.w	r4,--r6
800065f0:	80 00       	ld.sh	r0,r0[0x0]
800065f2:	55 72       	stdsp	sp[0x15c],r2
800065f4:	80 00       	ld.sh	r0,r0[0x0]
800065f6:	57 88       	stdsp	sp[0x1e0],r8

800065f8 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
800065f8:	d4 01       	pushm	lr
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
800065fa:	30 09       	mov	r9,0
800065fc:	1a d9       	st.w	--sp,r9
800065fe:	1a d9       	st.w	--sp,r9
80006600:	1a d9       	st.w	--sp,r9
80006602:	12 98       	mov	r8,r9
80006604:	e0 6a 01 00 	mov	r10,256
80006608:	48 9b       	lddpc	r11,8000662c <vTaskStartScheduler+0x34>
8000660a:	48 ac       	lddpc	r12,80006630 <vTaskStartScheduler+0x38>
8000660c:	f0 1f 00 0a 	mcall	80006634 <vTaskStartScheduler+0x3c>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
80006610:	2f dd       	sub	sp,-12
80006612:	58 1c       	cp.w	r12,1
80006614:	c0 a1       	brne	80006628 <vTaskStartScheduler+0x30>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
80006616:	d3 03       	ssrf	0x10

		xSchedulerRunning = pdTRUE;
80006618:	30 19       	mov	r9,1
8000661a:	48 88       	lddpc	r8,80006638 <vTaskStartScheduler+0x40>
8000661c:	91 09       	st.w	r8[0x0],r9
		xTickCount = ( portTickType ) 0;
8000661e:	30 09       	mov	r9,0
80006620:	48 78       	lddpc	r8,8000663c <vTaskStartScheduler+0x44>
80006622:	91 09       	st.w	r8[0x0],r9
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
80006624:	f0 1f 00 07 	mcall	80006640 <vTaskStartScheduler+0x48>
80006628:	d8 02       	popm	pc
8000662a:	00 00       	add	r0,r0
8000662c:	80 01       	ld.sh	r1,r0[0x0]
8000662e:	57 e8       	stdsp	sp[0x1f8],r8
80006630:	80 00       	ld.sh	r0,r0[0x0]
80006632:	63 88       	ld.w	r8,r1[0x60]
80006634:	80 00       	ld.sh	r0,r0[0x0]
80006636:	64 10       	ld.w	r0,r2[0x4]
80006638:	00 00       	add	r0,r0
8000663a:	0c 18       	sub	r8,r6
8000663c:	00 00       	add	r0,r0
8000663e:	0d 08       	ld.w	r8,r6++
80006640:	80 00       	ld.sh	r0,r0[0x0]
80006642:	56 8c       	stdsp	sp[0x1a0],r12

80006644 <PrintChar>:
	
static void task_log(void * pvParameters);

char *  PrintChar(char c, char * str)
{
	*str++ = c;
80006644:	16 cc       	st.b	r11++,r12
	return str;
}
80006646:	5e fb       	retal	r11

80006648 <PrintHex>:
	
	return str;
}

char * PrintHex(int i,char len, char * str)
{
80006648:	eb cd 40 c0 	pushm	r6-r7,lr
8000664c:	20 3d       	sub	sp,12
8000664e:	18 98       	mov	r8,r12
	char * p = str;
	char s[12];
	memset(s, 0 , 12);
80006650:	30 06       	mov	r6,0
80006652:	30 07       	mov	r7,0
80006654:	fa e7 00 00 	st.d	sp[0],r6
80006658:	30 0c       	mov	r12,0
8000665a:	50 2c       	stdsp	sp[0x8],r12
	int cnt=0;
	
	if(i)
8000665c:	58 08       	cp.w	r8,0
8000665e:	c1 30       	breq	80006684 <PrintHex+0x3c>
80006660:	18 99       	mov	r9,r12
	while(i)
	{
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
80006662:	1a 9c       	mov	r12,sp
80006664:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80006668:	58 9e       	cp.w	lr,9
8000666a:	e0 8a 00 04 	brle	80006672 <PrintHex+0x2a>
8000666e:	2c 9e       	sub	lr,-55
80006670:	c0 48       	rjmp	80006678 <PrintHex+0x30>
80006672:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80006676:	2d 0e       	sub	lr,-48
80006678:	f8 09 0b 0e 	st.b	r12[r9],lr
8000667c:	2f f9       	sub	r9,-1
		i = (i >> 4 ) & 0x0FFFFFFF;
8000667e:	a5 88       	lsr	r8,0x4
	char s[12];
	memset(s, 0 , 12);
	int cnt=0;
	
	if(i)
	while(i)
80006680:	cf 21       	brne	80006664 <PrintHex+0x1c>
80006682:	c0 48       	rjmp	8000668a <PrintHex+0x42>
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
		i = (i >> 4 ) & 0x0FFFFFFF;
		//i >>= 4
	}
	else
	s[cnt++] = '0';
80006684:	33 08       	mov	r8,48
80006686:	ba 88       	st.b	sp[0x0],r8
80006688:	30 19       	mov	r9,1
	
	if(len - cnt > 0 )
8000668a:	f6 09 01 08 	sub	r8,r11,r9
8000668e:	58 08       	cp.w	r8,0
80006690:	e0 8a 00 13 	brle	800066b6 <PrintHex+0x6e>
	{
		char num = len - cnt;
80006694:	12 1b       	sub	r11,r9
80006696:	f9 db c0 08 	bfextu	r12,r11,0x0,0x8
		for(int i = 0; i < num; i++)
8000669a:	18 9e       	mov	lr,r12
8000669c:	58 0c       	cp.w	r12,0
8000669e:	e0 8a 00 0c 	brle	800066b6 <PrintHex+0x6e>
800066a2:	1a 9b       	mov	r11,sp
800066a4:	12 0b       	add	r11,r9
800066a6:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
800066a8:	33 07       	mov	r7,48
800066aa:	16 c7       	st.b	r11++,r7
	s[cnt++] = '0';
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
800066ac:	2f f8       	sub	r8,-1
800066ae:	1c 38       	cp.w	r8,lr
800066b0:	cf d5       	brlt	800066aa <PrintHex+0x62>
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
800066b2:	f8 09 00 09 	add	r9,r12,r9
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
800066b6:	f2 c8 ff ff 	sub	r8,r9,-1
	s[cnt++] = '0';
	
	while(cnt>0)
800066ba:	f0 cb ff ff 	sub	r11,r8,-1
800066be:	58 0b       	cp.w	r11,0
800066c0:	e0 8a 00 19 	brle	800066f2 <PrintHex+0xaa>
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
800066c4:	fa cb ff f4 	sub	r11,sp,-12
800066c8:	f6 09 00 09 	add	r9,r11,r9
800066cc:	37 8b       	mov	r11,120
800066ce:	f3 6b ff f4 	st.b	r9[-12],r11
	s[cnt++] = '0';
800066d2:	fa c9 ff f4 	sub	r9,sp,-12
800066d6:	10 09       	add	r9,r8
800066d8:	33 0b       	mov	r11,48
800066da:	f3 6b ff f4 	st.b	r9[-12],r11
800066de:	fa 08 00 08 	add	r8,sp,r8
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
800066e2:	fa ce 00 01 	sub	lr,sp,1
800066e6:	14 99       	mov	r9,r10
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
	*p++ = s[--cnt];
800066e8:	11 8b       	ld.ub	r11,r8[0x0]
800066ea:	12 cb       	st.b	r9++,r11
800066ec:	20 18       	sub	r8,1
	}
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
800066ee:	1c 38       	cp.w	r8,lr
800066f0:	cf c1       	brne	800066e8 <PrintHex+0xa0>
	*p++ = s[--cnt];
		
	return str;
}
800066f2:	14 9c       	mov	r12,r10
800066f4:	2f dd       	sub	sp,-12
800066f6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

800066fa <PrintDec>:
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
{
800066fa:	d4 21       	pushm	r4-r7,lr
800066fc:	20 3d       	sub	sp,12
800066fe:	18 98       	mov	r8,r12
	char * p = str;
	
	int sign = i>=0 ? 0 : 1;
	char s[10];
	memset(s, 0 , 10);
80006700:	30 06       	mov	r6,0
80006702:	30 07       	mov	r7,0
80006704:	fa e7 00 00 	st.d	sp[0],r6
80006708:	30 0c       	mov	r12,0
8000670a:	ba 4c       	st.h	sp[0x8],r12
	int cnt=0;
	if(sign)
8000670c:	58 08       	cp.w	r8,0
8000670e:	c0 35       	brlt	80006714 <PrintDec+0x1a>
80006710:	14 97       	mov	r7,r10
80006712:	c0 58       	rjmp	8000671c <PrintDec+0x22>
	{
		*p++ = '-';
80006714:	14 97       	mov	r7,r10
80006716:	32 d9       	mov	r9,45
80006718:	0e c9       	st.b	r7++,r9
		i = -i;
8000671a:	5c 38       	neg	r8
	}
	
	if(i == 0 )s[cnt++] = '0';
8000671c:	58 08       	cp.w	r8,0
8000671e:	c0 51       	brne	80006728 <PrintDec+0x2e>
80006720:	33 08       	mov	r8,48
80006722:	ba 88       	st.b	sp[0x0],r8
80006724:	30 1e       	mov	lr,1
80006726:	c2 f8       	rjmp	80006784 <PrintDec+0x8a>
	
	int ten = i%10;
80006728:	e0 65 66 67 	mov	r5,26215
8000672c:	ea 15 66 66 	orh	r5,0x6666
80006730:	f0 05 04 44 	muls.d	r4,r8,r5
80006734:	ea 0c 14 02 	asr	r12,r5,0x2
80006738:	f0 09 14 1f 	asr	r9,r8,0x1f
8000673c:	f8 09 01 09 	sub	r9,r12,r9
80006740:	f2 09 00 29 	add	r9,r9,r9<<0x2
80006744:	f0 09 01 19 	sub	r9,r8,r9<<0x1
80006748:	30 0e       	mov	lr,0
	while(i)
	{
		s[cnt] = ten+'0';
8000674a:	1a 9c       	mov	r12,sp
		cnt++;
		i /= 10;
8000674c:	e0 66 66 67 	mov	r6,26215
80006750:	ea 16 66 66 	orh	r6,0x6666
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
	{
		s[cnt] = ten+'0';
80006754:	2d 09       	sub	r9,-48
80006756:	f8 0e 0b 09 	st.b	r12[lr],r9
		cnt++;
8000675a:	2f fe       	sub	lr,-1
		i /= 10;
8000675c:	f0 06 04 44 	muls.d	r4,r8,r6
80006760:	ea 09 14 02 	asr	r9,r5,0x2
80006764:	bf 58       	asr	r8,0x1f
80006766:	f2 08 01 08 	sub	r8,r9,r8
		ten = i%10;
8000676a:	f0 06 04 44 	muls.d	r4,r8,r6
8000676e:	ea 09 14 02 	asr	r9,r5,0x2
80006772:	f0 05 14 1f 	asr	r5,r8,0x1f
80006776:	0a 19       	sub	r9,r5
80006778:	f2 09 00 29 	add	r9,r9,r9<<0x2
8000677c:	f0 09 01 19 	sub	r9,r8,r9<<0x1
	}
	
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
80006780:	58 08       	cp.w	r8,0
80006782:	ce 91       	brne	80006754 <PrintDec+0x5a>
		cnt++;
		i /= 10;
		ten = i%10;
	}
	
	if(len - cnt > 0 )
80006784:	f6 0e 01 08 	sub	r8,r11,lr
80006788:	58 08       	cp.w	r8,0
8000678a:	e0 89 00 06 	brgt	80006796 <PrintDec+0x9c>
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
8000678e:	58 0e       	cp.w	lr,0
80006790:	e0 89 00 14 	brgt	800067b8 <PrintDec+0xbe>
80006794:	c1 d8       	rjmp	800067ce <PrintDec+0xd4>
		ten = i%10;
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
80006796:	1c 1b       	sub	r11,lr
80006798:	5c 5b       	castu.b	r11
		for(int i = 0; i < num; i++)
8000679a:	16 9c       	mov	r12,r11
8000679c:	58 0b       	cp.w	r11,0
8000679e:	fe 9a ff f8 	brle	8000678e <PrintDec+0x94>
800067a2:	1a 99       	mov	r9,sp
800067a4:	1c 09       	add	r9,lr
800067a6:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
800067a8:	33 06       	mov	r6,48
800067aa:	12 c6       	st.b	r9++,r6
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
800067ac:	2f f8       	sub	r8,-1
800067ae:	18 38       	cp.w	r8,r12
800067b0:	cf d5       	brlt	800067aa <PrintDec+0xb0>
{
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
800067b2:	f6 0e 00 0e 	add	lr,r11,lr
800067b6:	ce cb       	rjmp	8000678e <PrintDec+0x94>
800067b8:	fa c8 ff f4 	sub	r8,sp,-12
800067bc:	1c 08       	add	r8,lr
800067be:	20 d8       	sub	r8,13
800067c0:	fa cb 00 01 	sub	r11,sp,1
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
	*p++ = s[--cnt];
800067c4:	11 89       	ld.ub	r9,r8[0x0]
800067c6:	0e c9       	st.b	r7++,r9
800067c8:	20 18       	sub	r8,1
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
800067ca:	16 38       	cp.w	r8,r11
800067cc:	cf c1       	brne	800067c4 <PrintDec+0xca>
	*p++ = s[--cnt];
	
	return str;
}
800067ce:	14 9c       	mov	r12,r10
800067d0:	2f dd       	sub	sp,-12
800067d2:	d8 22       	popm	r4-r7,pc

800067d4 <log>:
	,  NULL );
	
}

int log(char * content, ...)
{
800067d4:	d4 31       	pushm	r0-r7,lr
800067d6:	fa cd 02 08 	sub	sp,sp,520
800067da:	18 97       	mov	r7,r12
	
	
	char logTmp[MAX_LOG_LINE_SIZE];
	memset(logTmp, '\0', MAX_LOG_LINE_SIZE);	
800067dc:	e0 6a 01 00 	mov	r10,256
800067e0:	30 0b       	mov	r11,0
800067e2:	fa cc fe f8 	sub	r12,sp,-264
800067e6:	f0 1f 00 4e 	mcall	8000691c <log+0x148>
	,  tskLOG_PRIORITY
	,  NULL );
	
}

int log(char * content, ...)
800067ea:	fa c4 fd d4 	sub	r4,sp,-556
800067ee:	30 0a       	mov	r10,0
800067f0:	50 0a       	stdsp	sp[0x0],r10
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
800067f2:	fa c3 ff fc 	sub	r3,sp,-4
800067f6:	e0 61 01 00 	mov	r1,256
800067fa:	14 90       	mov	r0,r10
			
					if(*str == '%')
800067fc:	32 52       	mov	r2,37
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
800067fe:	fa c6 fe f8 	sub	r6,sp,-264
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80006802:	02 9a       	mov	r10,r1
80006804:	00 9b       	mov	r11,r0
80006806:	06 9c       	mov	r12,r3
80006808:	f0 1f 00 45 	mcall	8000691c <log+0x148>
			
					if(*str == '%')
8000680c:	0f 88       	ld.ub	r8,r7[0x0]
8000680e:	e4 08 18 00 	cp.b	r8,r2
80006812:	c5 71       	brne	800068c0 <log+0xec>
					{
						static char lench = 0;
						lench =*(str + 1);
80006814:	ee c8 ff ff 	sub	r8,r7,-1
80006818:	11 89       	ld.ub	r9,r8[0x0]
8000681a:	4c 2a       	lddpc	r10,80006920 <log+0x14c>
8000681c:	b4 89       	st.b	r10[0x0],r9
						if((lench >= '0') &&  (lench <= '9'))
8000681e:	23 09       	sub	r9,48
80006820:	30 9a       	mov	r10,9
80006822:	f4 09 18 00 	cp.b	r9,r10
80006826:	ee 08 17 b0 	movhi	r8,r7
						{
							len = *(++str) - '0';
8000682a:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
8000682e:	f7 b9 08 30 	subls	r9,48
80006832:	fb f9 8a 00 	st.wls	sp[0x0],r9
						}
						
						str++;
80006836:	f0 c7 ff ff 	sub	r7,r8,-1
						
						switch(*(str))
8000683a:	0f 88       	ld.ub	r8,r7[0x0]
8000683c:	22 58       	sub	r8,37
8000683e:	e0 48 00 53 	cp.w	r8,83
80006842:	e0 8b 00 31 	brhi	800068a4 <log+0xd0>
80006846:	4b 89       	lddpc	r9,80006924 <log+0x150>
80006848:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
						{
							case('i'):
							case('I'):
							case('d'):
							case('D'):
							x = va_arg(arg_ptr,int);
8000684c:	e8 c5 ff fc 	sub	r5,r4,-4
							strTmp = PrintDec(x, len, strTmp);
80006850:	06 9a       	mov	r10,r3
80006852:	40 0b       	lddsp	r11,sp[0x0]
80006854:	5c 5b       	castu.b	r11
80006856:	68 0c       	ld.w	r12,r4[0x0]
80006858:	f0 1f 00 34 	mcall	80006928 <log+0x154>
							break;
8000685c:	c2 98       	rjmp	800068ae <log+0xda>
							
							case('f')://浮点数输出
							case('F'):
							//f = va_arg(arg_ptr,int);
							//strTmp = PrintDec(x, len, strTmp);
							log("I need float.");
8000685e:	4b 4c       	lddpc	r12,8000692c <log+0x158>
80006860:	f0 1f 00 34 	mcall	80006930 <log+0x15c>
80006864:	08 95       	mov	r5,r4
80006866:	06 9c       	mov	r12,r3
							break;
80006868:	c2 38       	rjmp	800068ae <log+0xda>
							
							
							case('x'):
							case('X'):
							x = va_arg(arg_ptr,int);
8000686a:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintHex(x,len, strTmp);
8000686e:	06 9a       	mov	r10,r3
80006870:	40 0b       	lddsp	r11,sp[0x0]
80006872:	5c 5b       	castu.b	r11
80006874:	68 0c       	ld.w	r12,r4[0x0]
80006876:	f0 1f 00 30 	mcall	80006934 <log+0x160>
8000687a:	06 9c       	mov	r12,r3
							break;
8000687c:	c1 98       	rjmp	800068ae <log+0xda>
							
							case('c'):
							case('C'):
							y = va_arg(arg_ptr,int);
8000687e:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintChar(y, strTmp);
80006882:	06 9b       	mov	r11,r3
80006884:	09 bc       	ld.ub	r12,r4[0x3]
80006886:	f0 1f 00 2d 	mcall	80006938 <log+0x164>
8000688a:	06 9c       	mov	r12,r3
							break;
8000688c:	c1 18       	rjmp	800068ae <log+0xda>
							
							case('s'):
							case('S'):
							strTmp = va_arg(arg_ptr,char*);
8000688e:	e8 c5 ff fc 	sub	r5,r4,-4
80006892:	68 0c       	ld.w	r12,r4[0x0]
							//PrintStr(s);
							break;
80006894:	c0 d8       	rjmp	800068ae <log+0xda>
							
							case('%'):
							PrintChar('%', strTmp);
80006896:	06 9b       	mov	r11,r3
80006898:	32 5c       	mov	r12,37
8000689a:	f0 1f 00 28 	mcall	80006938 <log+0x164>
8000689e:	08 95       	mov	r5,r4
800068a0:	06 9c       	mov	r12,r3
							//PrintChar('%');
							break;
800068a2:	c0 68       	rjmp	800068ae <log+0xda>
							
							default:
							log("I need relax.");
800068a4:	4a 6c       	lddpc	r12,8000693c <log+0x168>
800068a6:	f0 1f 00 23 	mcall	80006930 <log+0x15c>
800068aa:	08 95       	mov	r5,r4
800068ac:	06 9c       	mov	r12,r3
						}
						str++;
800068ae:	2f f7       	sub	r7,-1
						
						length = sprintf(logTmp,"%s%s",logTmp,strTmp );
800068b0:	1a dc       	st.w	--sp,r12
800068b2:	1a d6       	st.w	--sp,r6
800068b4:	4a 3b       	lddpc	r11,80006940 <log+0x16c>
800068b6:	0c 9c       	mov	r12,r6
800068b8:	f0 1f 00 23 	mcall	80006944 <log+0x170>
800068bc:	2f ed       	sub	sp,-8
800068be:	c0 a8       	rjmp	800068d2 <log+0xfe>
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
800068c0:	2f f7       	sub	r7,-1
800068c2:	1a d8       	st.w	--sp,r8
800068c4:	1a d6       	st.w	--sp,r6
800068c6:	4a 1b       	lddpc	r11,80006948 <log+0x174>
800068c8:	0c 9c       	mov	r12,r6
800068ca:	f0 1f 00 1f 	mcall	80006944 <log+0x170>
800068ce:	08 95       	mov	r5,r4
800068d0:	2f ed       	sub	sp,-8
			
			
			
	}while(*str != '\0');
800068d2:	0f 89       	ld.ub	r9,r7[0x0]
800068d4:	30 08       	mov	r8,0
800068d6:	f0 09 18 00 	cp.b	r9,r8
800068da:	c0 30       	breq	800068e0 <log+0x10c>
800068dc:	0a 94       	mov	r4,r5
800068de:	c9 2b       	rjmp	80006802 <log+0x2e>
		
		
				
	va_end(arg_ptr);
	//while(1)		
	length = sprintf(logTmp,"%s\r\n",logTmp);
800068e0:	fa c7 fe f8 	sub	r7,sp,-264
800068e4:	1a d7       	st.w	--sp,r7
800068e6:	49 ab       	lddpc	r11,8000694c <log+0x178>
800068e8:	0e 9c       	mov	r12,r7
800068ea:	f0 1f 00 17 	mcall	80006944 <log+0x170>
	
	char * p = pvPortMalloc(length+1);
800068ee:	5c 5c       	castu.b	r12
800068f0:	f8 c6 ff ff 	sub	r6,r12,-1
800068f4:	0c 9c       	mov	r12,r6
800068f6:	f0 1f 00 17 	mcall	80006950 <log+0x17c>
800068fa:	54 2c       	stdsp	sp[0x108],r12
	memcpy(p, logTmp, length+1);
800068fc:	0c 9a       	mov	r10,r6
800068fe:	0e 9b       	mov	r11,r7
80006900:	f0 1f 00 15 	mcall	80006954 <log+0x180>
	//
	//usart_write_line(EXAMPLE_USART, logTmp);
	xQueueSend( logQueue, &p, 5);
80006904:	30 09       	mov	r9,0
80006906:	30 5a       	mov	r10,5
80006908:	fa cb fe f8 	sub	r11,sp,-264
8000690c:	49 38       	lddpc	r8,80006958 <log+0x184>
8000690e:	70 0c       	ld.w	r12,r8[0x0]
80006910:	f0 1f 00 13 	mcall	8000695c <log+0x188>
80006914:	2f fd       	sub	sp,-4
}
80006916:	fe 3d fd f8 	sub	sp,-520
8000691a:	d8 32       	popm	r0-r7,pc
8000691c:	80 00       	ld.sh	r0,r0[0x0]
8000691e:	72 d6       	ld.w	r6,r9[0x34]
80006920:	00 00       	add	r0,r0
80006922:	0d 48       	ld.w	r8,--r6
80006924:	80 01       	ld.sh	r1,r0[0x0]
80006926:	57 f0       	stdsp	sp[0x1fc],r0
80006928:	80 00       	ld.sh	r0,r0[0x0]
8000692a:	66 fa       	ld.w	r10,r3[0x3c]
8000692c:	80 01       	ld.sh	r1,r0[0x0]
8000692e:	5a 9c       	cp.w	r12,-23
80006930:	80 00       	ld.sh	r0,r0[0x0]
80006932:	67 d4       	ld.w	r4,r3[0x74]
80006934:	80 00       	ld.sh	r0,r0[0x0]
80006936:	66 48       	ld.w	r8,r3[0x10]
80006938:	80 00       	ld.sh	r0,r0[0x0]
8000693a:	66 44       	ld.w	r4,r3[0x10]
8000693c:	80 01       	ld.sh	r1,r0[0x0]
8000693e:	5a ac       	cp.w	r12,-22
80006940:	80 01       	ld.sh	r1,r0[0x0]
80006942:	5a bc       	cp.w	r12,-21
80006944:	80 00       	ld.sh	r0,r0[0x0]
80006946:	75 c4       	ld.w	r4,r10[0x70]
80006948:	80 01       	ld.sh	r1,r0[0x0]
8000694a:	5a c4       	cp.w	r4,-20
8000694c:	80 01       	ld.sh	r1,r0[0x0]
8000694e:	5a cc       	cp.w	r12,-20
80006950:	80 00       	ld.sh	r0,r0[0x0]
80006952:	58 e8       	cp.w	r8,14
80006954:	80 00       	ld.sh	r0,r0[0x0]
80006956:	71 8e       	ld.w	lr,r8[0x60]
80006958:	00 00       	add	r0,r0
8000695a:	52 dc       	stdsp	sp[0xb4],r12
8000695c:	80 00       	ld.sh	r0,r0[0x0]
8000695e:	5c 3c       	neg	r12

80006960 <logFromISR>:
	
	
int logFromISR(char * content, ...)
	{
80006960:	d4 31       	pushm	r0-r7,lr
80006962:	fa cd 02 0c 	sub	sp,sp,524
80006966:	18 97       	mov	r7,r12
		
		
		char logTmp[MAX_LOG_LINE_SIZE];
		memset(logTmp, '\0', MAX_LOG_LINE_SIZE);
80006968:	e0 6a 01 00 	mov	r10,256
8000696c:	30 0b       	mov	r11,0
8000696e:	fa cc fe f4 	sub	r12,sp,-268
80006972:	f0 1f 00 4c 	mcall	80006aa0 <logFromISR+0x140>
	//usart_write_line(EXAMPLE_USART, logTmp);
	xQueueSend( logQueue, &p, 5);
}
	
	
int logFromISR(char * content, ...)
80006976:	fa c4 fd d0 	sub	r4,sp,-560
8000697a:	30 0a       	mov	r10,0
8000697c:	50 0a       	stdsp	sp[0x0],r10
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
8000697e:	fa c3 ff fc 	sub	r3,sp,-4
80006982:	e0 61 01 00 	mov	r1,256
80006986:	14 90       	mov	r0,r10
			
			if(*str == '%')
80006988:	32 52       	mov	r2,37
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
8000698a:	fa c6 fe f4 	sub	r6,sp,-268
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
8000698e:	02 9a       	mov	r10,r1
80006990:	00 9b       	mov	r11,r0
80006992:	06 9c       	mov	r12,r3
80006994:	f0 1f 00 43 	mcall	80006aa0 <logFromISR+0x140>
			
			if(*str == '%')
80006998:	0f 88       	ld.ub	r8,r7[0x0]
8000699a:	e4 08 18 00 	cp.b	r8,r2
8000699e:	c5 11       	brne	80006a40 <logFromISR+0xe0>
			{
				static char lench = 0;
				lench =*(str + 1);
800069a0:	ee c8 ff ff 	sub	r8,r7,-1
800069a4:	11 89       	ld.ub	r9,r8[0x0]
800069a6:	4c 0a       	lddpc	r10,80006aa4 <logFromISR+0x144>
800069a8:	b4 89       	st.b	r10[0x0],r9
				if((lench >= '0') &&  (lench <= '9'))
800069aa:	23 09       	sub	r9,48
800069ac:	30 9a       	mov	r10,9
800069ae:	f4 09 18 00 	cp.b	r9,r10
800069b2:	ee 08 17 b0 	movhi	r8,r7
				{
					len = *(++str) - '0';
800069b6:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
800069ba:	f7 b9 08 30 	subls	r9,48
800069be:	fb f9 8a 00 	st.wls	sp[0x0],r9
				}
				
				str++;
800069c2:	f0 c7 ff ff 	sub	r7,r8,-1
				
				switch(*(str))
800069c6:	0f 88       	ld.ub	r8,r7[0x0]
800069c8:	22 58       	sub	r8,37
800069ca:	e0 48 00 53 	cp.w	r8,83
800069ce:	e0 8b 00 2b 	brhi	80006a24 <logFromISR+0xc4>
800069d2:	4b 69       	lddpc	r9,80006aa8 <logFromISR+0x148>
800069d4:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
				{
					case('d'):
					case('D'):
					x = va_arg(arg_ptr,int);
800069d8:	e8 c5 ff fc 	sub	r5,r4,-4
					strTmp = PrintDec(x, len, strTmp);
800069dc:	06 9a       	mov	r10,r3
800069de:	40 0b       	lddsp	r11,sp[0x0]
800069e0:	5c 5b       	castu.b	r11
800069e2:	68 0c       	ld.w	r12,r4[0x0]
800069e4:	f0 1f 00 32 	mcall	80006aac <logFromISR+0x14c>
					break;
800069e8:	c2 38       	rjmp	80006a2e <logFromISR+0xce>
					case('x'):
					case('X'):
					x = va_arg(arg_ptr,int);
800069ea:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintHex(x,len, strTmp);
800069ee:	06 9a       	mov	r10,r3
800069f0:	40 0b       	lddsp	r11,sp[0x0]
800069f2:	5c 5b       	castu.b	r11
800069f4:	68 0c       	ld.w	r12,r4[0x0]
800069f6:	f0 1f 00 2f 	mcall	80006ab0 <logFromISR+0x150>
800069fa:	06 9c       	mov	r12,r3
					break;
800069fc:	c1 98       	rjmp	80006a2e <logFromISR+0xce>
					case('c'):
					case('C'):
					y = va_arg(arg_ptr,int);
800069fe:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintChar(y, strTmp);
80006a02:	06 9b       	mov	r11,r3
80006a04:	09 bc       	ld.ub	r12,r4[0x3]
80006a06:	f0 1f 00 2c 	mcall	80006ab4 <logFromISR+0x154>
80006a0a:	06 9c       	mov	r12,r3
					break;
80006a0c:	c1 18       	rjmp	80006a2e <logFromISR+0xce>
					case('s'):
					case('S'):
					strTmp = va_arg(arg_ptr,char*);
80006a0e:	e8 c5 ff fc 	sub	r5,r4,-4
80006a12:	68 0c       	ld.w	r12,r4[0x0]
					//PrintStr(s);
					break;
80006a14:	c0 d8       	rjmp	80006a2e <logFromISR+0xce>
					case('%'):
					PrintChar('%', strTmp);
80006a16:	06 9b       	mov	r11,r3
80006a18:	32 5c       	mov	r12,37
80006a1a:	f0 1f 00 27 	mcall	80006ab4 <logFromISR+0x154>
80006a1e:	08 95       	mov	r5,r4
80006a20:	06 9c       	mov	r12,r3
					//PrintChar('%');
					break;
80006a22:	c0 68       	rjmp	80006a2e <logFromISR+0xce>
					default:
					log("I need relax.");
80006a24:	4a 5c       	lddpc	r12,80006ab8 <logFromISR+0x158>
80006a26:	f0 1f 00 26 	mcall	80006abc <logFromISR+0x15c>
80006a2a:	08 95       	mov	r5,r4
80006a2c:	06 9c       	mov	r12,r3
				}
				str++;
80006a2e:	2f f7       	sub	r7,-1
				
				length = sprintf(logTmp,"%s%s",logTmp,strTmp );
80006a30:	1a dc       	st.w	--sp,r12
80006a32:	1a d6       	st.w	--sp,r6
80006a34:	4a 3b       	lddpc	r11,80006ac0 <logFromISR+0x160>
80006a36:	0c 9c       	mov	r12,r6
80006a38:	f0 1f 00 23 	mcall	80006ac4 <logFromISR+0x164>
80006a3c:	2f ed       	sub	sp,-8
80006a3e:	c0 a8       	rjmp	80006a52 <logFromISR+0xf2>
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
80006a40:	2f f7       	sub	r7,-1
80006a42:	1a d8       	st.w	--sp,r8
80006a44:	1a d6       	st.w	--sp,r6
80006a46:	4a 1b       	lddpc	r11,80006ac8 <logFromISR+0x168>
80006a48:	0c 9c       	mov	r12,r6
80006a4a:	f0 1f 00 1f 	mcall	80006ac4 <logFromISR+0x164>
80006a4e:	08 95       	mov	r5,r4
80006a50:	2f ed       	sub	sp,-8
			
			
			
		}while(*str != '\0');
80006a52:	0f 89       	ld.ub	r9,r7[0x0]
80006a54:	30 08       	mov	r8,0
80006a56:	f0 09 18 00 	cp.b	r9,r8
80006a5a:	c0 30       	breq	80006a60 <logFromISR+0x100>
80006a5c:	0a 94       	mov	r4,r5
80006a5e:	c9 8b       	rjmp	8000698e <logFromISR+0x2e>
		
		
		
		va_end(arg_ptr);
		//while(1)
		length = sprintf(logTmp,"%s\r\n",logTmp);
80006a60:	fa c7 fe f4 	sub	r7,sp,-268
80006a64:	1a d7       	st.w	--sp,r7
80006a66:	49 ab       	lddpc	r11,80006acc <logFromISR+0x16c>
80006a68:	0e 9c       	mov	r12,r7
80006a6a:	f0 1f 00 17 	mcall	80006ac4 <logFromISR+0x164>
		
		char * p = pvPortMalloc(length+1);
80006a6e:	5c 5c       	castu.b	r12
80006a70:	f8 c6 ff ff 	sub	r6,r12,-1
80006a74:	0c 9c       	mov	r12,r6
80006a76:	f0 1f 00 17 	mcall	80006ad0 <logFromISR+0x170>
80006a7a:	54 3c       	stdsp	sp[0x10c],r12
		memcpy(p, logTmp, length+1);
80006a7c:	0c 9a       	mov	r10,r6
80006a7e:	0e 9b       	mov	r11,r7
80006a80:	f0 1f 00 15 	mcall	80006ad4 <logFromISR+0x174>
		//
		portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80006a84:	30 09       	mov	r9,0
80006a86:	54 29       	stdsp	sp[0x108],r9
		
		//usart_write_line(EXAMPLE_USART, p);
		//vPortFree(p);
		xQueueSendFromISR( logQueue, &p, &xHigherPriorityTaskWoken );
80006a88:	fa ca fe f8 	sub	r10,sp,-264
80006a8c:	fa cb fe f4 	sub	r11,sp,-268
80006a90:	49 28       	lddpc	r8,80006ad8 <logFromISR+0x178>
80006a92:	70 0c       	ld.w	r12,r8[0x0]
80006a94:	f0 1f 00 12 	mcall	80006adc <logFromISR+0x17c>
80006a98:	2f fd       	sub	sp,-4
		//if (xHigherPriorityTaskWoken == pdTRUE)
		//{
			////taskYIELD();
		//}
	}
80006a9a:	fe 3d fd f4 	sub	sp,-524
80006a9e:	d8 32       	popm	r0-r7,pc
80006aa0:	80 00       	ld.sh	r0,r0[0x0]
80006aa2:	72 d6       	ld.w	r6,r9[0x34]
80006aa4:	00 00       	add	r0,r0
80006aa6:	0d 49       	ld.w	r9,--r6
80006aa8:	80 01       	ld.sh	r1,r0[0x0]
80006aaa:	59 40       	cp.w	r0,20
80006aac:	80 00       	ld.sh	r0,r0[0x0]
80006aae:	66 fa       	ld.w	r10,r3[0x3c]
80006ab0:	80 00       	ld.sh	r0,r0[0x0]
80006ab2:	66 48       	ld.w	r8,r3[0x10]
80006ab4:	80 00       	ld.sh	r0,r0[0x0]
80006ab6:	66 44       	ld.w	r4,r3[0x10]
80006ab8:	80 01       	ld.sh	r1,r0[0x0]
80006aba:	5a ac       	cp.w	r12,-22
80006abc:	80 00       	ld.sh	r0,r0[0x0]
80006abe:	67 d4       	ld.w	r4,r3[0x74]
80006ac0:	80 01       	ld.sh	r1,r0[0x0]
80006ac2:	5a bc       	cp.w	r12,-21
80006ac4:	80 00       	ld.sh	r0,r0[0x0]
80006ac6:	75 c4       	ld.w	r4,r10[0x70]
80006ac8:	80 01       	ld.sh	r1,r0[0x0]
80006aca:	5a c4       	cp.w	r4,-20
80006acc:	80 01       	ld.sh	r1,r0[0x0]
80006ace:	5a cc       	cp.w	r12,-20
80006ad0:	80 00       	ld.sh	r0,r0[0x0]
80006ad2:	58 e8       	cp.w	r8,14
80006ad4:	80 00       	ld.sh	r0,r0[0x0]
80006ad6:	71 8e       	ld.w	lr,r8[0x60]
80006ad8:	00 00       	add	r0,r0
80006ada:	52 dc       	stdsp	sp[0xb4],r12
80006adc:	80 00       	ld.sh	r0,r0[0x0]
80006ade:	5b ec       	cp.w	r12,-2

80006ae0 <log_init>:
		
	return str;
}

void log_init(void)
{
80006ae0:	d4 01       	pushm	lr
		.stopbits     = USART_1_STOPBIT,
		.channelmode  = USART_NORMAL_CHMODE
	};

	// Assign GPIO to USART.
	gpio_enable_module(USART_GPIO_MAP,
80006ae2:	30 2b       	mov	r11,2
80006ae4:	49 0c       	lddpc	r12,80006b24 <log_init+0x44>
80006ae6:	f0 1f 00 11 	mcall	80006b28 <log_init+0x48>
	sizeof(USART_GPIO_MAP) / sizeof(USART_GPIO_MAP[0]));

	// Initialize USART in RS232 mode.
	usart_init_rs232(EXAMPLE_USART, &USART_OPTIONS, EXAMPLE_TARGET_PBACLK_FREQ_HZ);			
80006aea:	e0 6a 36 00 	mov	r10,13824
80006aee:	ea 1a 01 6e 	orh	r10,0x16e
80006af2:	48 fb       	lddpc	r11,80006b2c <log_init+0x4c>
80006af4:	fe 7c 18 00 	mov	r12,-59392
80006af8:	f0 1f 00 0e 	mcall	80006b30 <log_init+0x50>
			
	logQueue  = xQueueCreate(50, sizeof(char *));
80006afc:	30 4b       	mov	r11,4
80006afe:	33 2c       	mov	r12,50
80006b00:	f0 1f 00 0d 	mcall	80006b34 <log_init+0x54>
80006b04:	48 d8       	lddpc	r8,80006b38 <log_init+0x58>
80006b06:	91 0c       	st.w	r8[0x0],r12
	
	xTaskCreate(
80006b08:	30 09       	mov	r9,0
80006b0a:	1a d9       	st.w	--sp,r9
80006b0c:	1a d9       	st.w	--sp,r9
80006b0e:	1a d9       	st.w	--sp,r9
80006b10:	30 18       	mov	r8,1
80006b12:	e0 6a 01 80 	mov	r10,384
80006b16:	48 ab       	lddpc	r11,80006b3c <log_init+0x5c>
80006b18:	48 ac       	lddpc	r12,80006b40 <log_init+0x60>
80006b1a:	f0 1f 00 0b 	mcall	80006b44 <log_init+0x64>
80006b1e:	2f dd       	sub	sp,-12
	,  384
	,  NULL
	,  tskLOG_PRIORITY
	,  NULL );
	
}
80006b20:	d8 02       	popm	pc
80006b22:	00 00       	add	r0,r0
80006b24:	80 01       	ld.sh	r1,r0[0x0]
80006b26:	5a d8       	cp.w	r8,-19
80006b28:	80 00       	ld.sh	r0,r0[0x0]
80006b2a:	6c 6c       	ld.w	r12,r6[0x18]
80006b2c:	80 01       	ld.sh	r1,r0[0x0]
80006b2e:	5a 90       	cp.w	r0,-23
80006b30:	80 00       	ld.sh	r0,r0[0x0]
80006b32:	54 8c       	stdsp	sp[0x120],r12
80006b34:	80 00       	ld.sh	r0,r0[0x0]
80006b36:	5d 3c       	musfr	r12
80006b38:	00 00       	add	r0,r0
80006b3a:	52 dc       	stdsp	sp[0xb4],r12
80006b3c:	80 01       	ld.sh	r1,r0[0x0]
80006b3e:	5a d4       	cp.w	r4,-19
80006b40:	80 00       	ld.sh	r0,r0[0x0]
80006b42:	6b 48       	ld.w	r8,r5[0x50]
80006b44:	80 00       	ld.sh	r0,r0[0x0]
80006b46:	64 10       	ld.w	r0,r2[0x4]

80006b48 <task_log>:
			////taskYIELD();
		//}
	}
	
static void task_log(void * pvParameters)
{
80006b48:	eb cd 40 f8 	pushm	r3-r7,lr
80006b4c:	20 1d       	sub	sp,4
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
80006b4e:	48 c7       	lddpc	r7,80006b7c <task_log+0x34>
80006b50:	30 05       	mov	r5,0
80006b52:	3f f4       	mov	r4,-1
		{
			if( NULL != str)
			{
				usart_write_line(EXAMPLE_USART, str);
80006b54:	fe 73 18 00 	mov	r3,-59392
{
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
80006b58:	0a 99       	mov	r9,r5
80006b5a:	08 9a       	mov	r10,r4
80006b5c:	1a 9b       	mov	r11,sp
80006b5e:	6e 0c       	ld.w	r12,r7[0x0]
80006b60:	f0 1f 00 08 	mcall	80006b80 <task_log+0x38>
80006b64:	58 1c       	cp.w	r12,1
80006b66:	cf 91       	brne	80006b58 <task_log+0x10>
		{
			if( NULL != str)
80006b68:	40 0b       	lddsp	r11,sp[0x0]
80006b6a:	58 0b       	cp.w	r11,0
80006b6c:	cf 60       	breq	80006b58 <task_log+0x10>
			{
				usart_write_line(EXAMPLE_USART, str);
80006b6e:	06 9c       	mov	r12,r3
80006b70:	f0 1f 00 05 	mcall	80006b84 <task_log+0x3c>
				vPortFree(str);
80006b74:	40 0c       	lddsp	r12,sp[0x0]
80006b76:	f0 1f 00 05 	mcall	80006b88 <task_log+0x40>
80006b7a:	ce fb       	rjmp	80006b58 <task_log+0x10>
80006b7c:	00 00       	add	r0,r0
80006b7e:	52 dc       	stdsp	sp[0xb4],r12
80006b80:	80 00       	ld.sh	r0,r0[0x0]
80006b82:	5a 30       	cp.w	r0,-29
80006b84:	80 00       	ld.sh	r0,r0[0x0]
80006b86:	54 3c       	stdsp	sp[0x10c],r12
80006b88:	80 00       	ld.sh	r0,r0[0x0]
80006b8a:	58 c0       	cp.w	r0,12

80006b8c <main>:
#include "fs/fs.h"
#include "rtc/rtc.h"
#include "flash/data_flash.h"

int main(void)
{
80006b8c:	d4 01       	pushm	lr
	//Force SSC_TX_DATA_ENABLE Disabled as soon as possible.
	AVR32_GPIO.port[1].ovrs  =  0x00000001;  //Value will be high.
80006b8e:	fe 78 10 00 	mov	r8,-61440
80006b92:	30 19       	mov	r9,1
80006b94:	f1 49 01 54 	st.w	r8[340],r9
	AVR32_GPIO.port[1].oders =  0x00000001;  //Output Driver will be Enabled.
80006b98:	f1 49 01 44 	st.w	r8[324],r9
	AVR32_GPIO.port[1].gpers =  0x00000001;  //Enable as GPIO.
80006b9c:	f1 49 01 04 	st.w	r8[260],r9
	
	Disable_global_interrupt();
80006ba0:	d3 03       	ssrf	0x10
	local_start_pll0();
80006ba2:	f0 1f 00 13 	mcall	80006bec <main+0x60>
		
	INTC_init_interrupts();
80006ba6:	f0 1f 00 13 	mcall	80006bf0 <main+0x64>
	
	log_init();		
80006baa:	f0 1f 00 13 	mcall	80006bf4 <main+0x68>
	log("----start debug----");	
80006bae:	49 3c       	lddpc	r12,80006bf8 <main+0x6c>
80006bb0:	f0 1f 00 13 	mcall	80006bfc <main+0x70>
		
	//rtc_init();
	
	//fs_init();//65795机器无法通过文件系统初始化
	
	data_flash_init();
80006bb4:	f0 1f 00 13 	mcall	80006c00 <main+0x74>

	tc_init();	
80006bb8:	f0 1f 00 13 	mcall	80006c04 <main+0x78>
	
	app_init();
80006bbc:	f0 1f 00 13 	mcall	80006c08 <main+0x7c>
			
	xcmp_init();
80006bc0:	f0 1f 00 13 	mcall	80006c0c <main+0x80>
		
	while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
80006bc4:	fe 79 10 00 	mov	r9,-61440
80006bc8:	f2 f8 01 60 	ld.w	r8,r9[352]
80006bcc:	e2 18 00 02 	andl	r8,0x2,COH
80006bd0:	cf c0       	breq	80006bc8 <main+0x3c>
	while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
80006bd2:	fe 79 10 00 	mov	r9,-61440
80006bd6:	f2 f8 01 60 	ld.w	r8,r9[352]
80006bda:	e2 18 00 02 	andl	r8,0x2,COH
80006bde:	cf c1       	brne	80006bd6 <main+0x4a>
	local_start_timer();
80006be0:	f0 1f 00 0c 	mcall	80006c10 <main+0x84>
	
	Enable_global_interrupt();
80006be4:	d5 03       	csrf	0x10
	
	vTaskStartScheduler();		
80006be6:	f0 1f 00 0c 	mcall	80006c14 <main+0x88>
	return 0;
}
80006bea:	d8 0a       	popm	pc,r12=0
80006bec:	80 00       	ld.sh	r0,r0[0x0]
80006bee:	4d 60       	lddpc	r0,80006d44 <_malloc_r+0x14>
80006bf0:	80 00       	ld.sh	r0,r0[0x0]
80006bf2:	4e f0       	lddpc	r0,80006dac <_malloc_r+0x7c>
80006bf4:	80 00       	ld.sh	r0,r0[0x0]
80006bf6:	6a e0       	ld.w	r0,r5[0x38]
80006bf8:	80 01       	ld.sh	r1,r0[0x0]
80006bfa:	5a e8       	cp.w	r8,-18
80006bfc:	80 00       	ld.sh	r0,r0[0x0]
80006bfe:	67 d4       	ld.w	r4,r3[0x74]
80006c00:	80 00       	ld.sh	r0,r0[0x0]
80006c02:	2d c0       	sub	r0,-36
80006c04:	80 00       	ld.sh	r0,r0[0x0]
80006c06:	4d ec       	lddpc	r12,80006d7c <_malloc_r+0x4c>
80006c08:	80 00       	ld.sh	r0,r0[0x0]
80006c0a:	20 40       	sub	r0,4
80006c0c:	80 00       	ld.sh	r0,r0[0x0]
80006c0e:	46 70       	lddsp	r0,sp[0x19c]
80006c10:	80 00       	ld.sh	r0,r0[0x0]
80006c12:	4d b0       	lddpc	r0,80006d7c <_malloc_r+0x4c>
80006c14:	80 00       	ld.sh	r0,r0[0x0]
80006c16:	65 f8       	ld.w	r8,r2[0x7c]

80006c18 <gpio_enable_module_pin>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80006c18:	f8 08 16 05 	lsr	r8,r12,0x5
80006c1c:	a9 68       	lsl	r8,0x8
80006c1e:	e0 28 f0 00 	sub	r8,61440

	/* Enable the correct function. */
	switch (function) {
80006c22:	58 1b       	cp.w	r11,1
80006c24:	c0 d0       	breq	80006c3e <gpio_enable_module_pin+0x26>
80006c26:	c0 63       	brcs	80006c32 <gpio_enable_module_pin+0x1a>
80006c28:	58 2b       	cp.w	r11,2
80006c2a:	c1 00       	breq	80006c4a <gpio_enable_module_pin+0x32>
80006c2c:	58 3b       	cp.w	r11,3
80006c2e:	c1 40       	breq	80006c56 <gpio_enable_module_pin+0x3e>
80006c30:	5e ff       	retal	1
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80006c32:	30 19       	mov	r9,1
80006c34:	f2 0c 09 49 	lsl	r9,r9,r12
80006c38:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80006c3a:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80006c3c:	c1 28       	rjmp	80006c60 <gpio_enable_module_pin+0x48>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80006c3e:	30 19       	mov	r9,1
80006c40:	f2 0c 09 49 	lsl	r9,r9,r12
80006c44:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80006c46:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80006c48:	c0 c8       	rjmp	80006c60 <gpio_enable_module_pin+0x48>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80006c4a:	30 19       	mov	r9,1
80006c4c:	f2 0c 09 49 	lsl	r9,r9,r12
80006c50:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80006c52:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80006c54:	c0 68       	rjmp	80006c60 <gpio_enable_module_pin+0x48>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80006c56:	30 19       	mov	r9,1
80006c58:	f2 0c 09 49 	lsl	r9,r9,r12
80006c5c:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80006c5e:	91 99       	st.w	r8[0x24],r9
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
80006c60:	30 19       	mov	r9,1
80006c62:	f2 0c 09 4c 	lsl	r12,r9,r12
80006c66:	91 2c       	st.w	r8[0x8],r12
80006c68:	5e fd       	retal	0
80006c6a:	d7 03       	nop

80006c6c <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
80006c6c:	d4 21       	pushm	r4-r7,lr
80006c6e:	18 97       	mov	r7,r12
80006c70:	16 94       	mov	r4,r11
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80006c72:	58 0b       	cp.w	r11,0
80006c74:	c0 31       	brne	80006c7a <gpio_enable_module+0xe>
80006c76:	30 05       	mov	r5,0
80006c78:	c0 d8       	rjmp	80006c92 <gpio_enable_module+0x26>
80006c7a:	30 06       	mov	r6,0
80006c7c:	0c 95       	mov	r5,r6
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
80006c7e:	6e 1b       	ld.w	r11,r7[0x4]
80006c80:	6e 0c       	ld.w	r12,r7[0x0]
80006c82:	f0 1f 00 06 	mcall	80006c98 <gpio_enable_module+0x2c>
80006c86:	18 45       	or	r5,r12
		gpiomap++;
80006c88:	2f 87       	sub	r7,-8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80006c8a:	2f f6       	sub	r6,-1
80006c8c:	0c 34       	cp.w	r4,r6
80006c8e:	fe 9b ff f8 	brhi	80006c7e <gpio_enable_module+0x12>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
}
80006c92:	0a 9c       	mov	r12,r5
80006c94:	d8 22       	popm	r4-r7,pc
80006c96:	00 00       	add	r0,r0
80006c98:	80 00       	ld.sh	r0,r0[0x0]
80006c9a:	6c 18       	ld.w	r8,r6[0x4]

80006c9c <gpio_enable_gpio_pin>:
 *            AVR32_PWM_3_PIN for PWM channel 3 can also be used to release
 *            module pins for GPIO.
 */
void gpio_enable_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80006c9c:	f8 08 16 05 	lsr	r8,r12,0x5
80006ca0:	a9 68       	lsl	r8,0x8
80006ca2:	e0 28 f0 00 	sub	r8,61440
	
	gpio_port->oderc = 1 << (pin & 0x1F);
80006ca6:	30 19       	mov	r9,1
80006ca8:	f2 0c 09 4c 	lsl	r12,r9,r12
80006cac:	f1 4c 00 48 	st.w	r8[72],r12
	gpio_port->gpers = 1 << (pin & 0x1F);
80006cb0:	91 1c       	st.w	r8[0x4],r12
}
80006cb2:	5e fc       	retal	r12

80006cb4 <gpio_set_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_set_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80006cb4:	f8 08 16 05 	lsr	r8,r12,0x5
80006cb8:	a9 68       	lsl	r8,0x8
80006cba:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 1. */
	gpio_port->ovrs  = 1 << (pin & 0x1F);																				
80006cbe:	30 19       	mov	r9,1
80006cc0:	f2 0c 09 4c 	lsl	r12,r9,r12
80006cc4:	f1 4c 00 54 	st.w	r8[84],r12
	/* The GPIO output driver is enabled for that pin. */ 
	gpio_port->oders = 1 << (pin & 0x1F);
80006cc8:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
80006ccc:	91 1c       	st.w	r8[0x4],r12
}
80006cce:	5e fc       	retal	r12

80006cd0 <_stext>:

  .global _stext
  .type _stext, @function
_stext:
  // Set initial stack pointer.
  lda.w   sp, _estack
80006cd0:	e0 7d 80 00 	mov	sp,98304

  // Set up EVBA so interrupts can be enabled.
  lda.w   r0, _evba
  mtsr    AVR32_EVBA, r0
80006cd4:	fe c0 a4 d4 	sub	r0,pc,-23340

  // Enable the exception processing.
  csrf    AVR32_SR_EM_OFFSET
80006cd8:	e3 b0 00 01 	mtsr	0x4,r0

  // Load initialized data having a global lifetime from the data LMA.
  lda.w   r0, _data
  lda.w   r1, _edata
80006cdc:	d5 53       	csrf	0x15
  cp      r0, r1
80006cde:	30 80       	mov	r0,8
  brhs    idata_load_loop_end
80006ce0:	e0 61 0a 40 	mov	r1,2624
  lda.w   r2, _data_lma
idata_load_loop:
  ld.d    r4, r2++
80006ce4:	02 30       	cp.w	r0,r1
  st.d    r0++, r4
80006ce6:	c0 62       	brcc	80006cf2 <idata_load_loop_end>
  cp      r0, r1
80006ce8:	48 92       	lddpc	r2,80006d0c <udata_clear_loop_end+0x4>

80006cea <idata_load_loop>:
  brlo    idata_load_loop
80006cea:	a5 05       	ld.d	r4,r2++
idata_load_loop_end:

  // Clear uninitialized data having a global lifetime in the blank static storage section.
  lda.w   r0, __bss_start
80006cec:	a1 24       	st.d	r0++,r4
  lda.w   r1, _end
80006cee:	02 30       	cp.w	r0,r1
  cp      r0, r1
80006cf0:	cf d3       	brcs	80006cea <idata_load_loop>

80006cf2 <idata_load_loop_end>:
  brhs    udata_clear_loop_end
80006cf2:	e0 60 0a 40 	mov	r0,2624
  mov     r2, 0
  mov     r3, 0
80006cf6:	e0 61 52 e8 	mov	r1,21224
udata_clear_loop:
  st.d    r0++, r2
  cp      r0, r1
80006cfa:	02 30       	cp.w	r0,r1
  brlo    udata_clear_loop
80006cfc:	c0 62       	brcc	80006d08 <udata_clear_loop_end>
  // Safety: Set the default "return" @ to the exit routine address.
  lda.w   lr, exit
#endif

  // Start the show.
  lda.w   pc, main
80006cfe:	30 02       	mov	r2,0
80006d00:	30 03       	mov	r3,0

80006d02 <udata_clear_loop>:
80006d02:	a1 22       	st.d	r0++,r2
80006d04:	02 30       	cp.w	r0,r1
80006d06:	cf e3       	brcs	80006d02 <udata_clear_loop>

80006d08 <udata_clear_loop_end>:
80006d08:	fe cf 01 7c 	sub	pc,pc,380
80006d0c:	80 01       	ld.sh	r1,r0[0x0]
80006d0e:	60 80       	ld.w	r0,r0[0x20]

80006d10 <free>:
80006d10:	d4 01       	pushm	lr
80006d12:	e0 68 0a 3c 	mov	r8,2620
80006d16:	18 9b       	mov	r11,r12
80006d18:	70 0c       	ld.w	r12,r8[0x0]
80006d1a:	e0 a0 1e a1 	rcall	8000aa5c <_free_r>
80006d1e:	d8 02       	popm	pc

80006d20 <malloc>:
80006d20:	d4 01       	pushm	lr
80006d22:	e0 68 0a 3c 	mov	r8,2620
80006d26:	18 9b       	mov	r11,r12
80006d28:	70 0c       	ld.w	r12,r8[0x0]
80006d2a:	c0 3c       	rcall	80006d30 <_malloc_r>
80006d2c:	d8 02       	popm	pc
80006d2e:	d7 03       	nop

80006d30 <_malloc_r>:
80006d30:	d4 31       	pushm	r0-r7,lr
80006d32:	f6 c8 ff f5 	sub	r8,r11,-11
80006d36:	18 95       	mov	r5,r12
80006d38:	10 97       	mov	r7,r8
80006d3a:	e0 17 ff f8 	andl	r7,0xfff8
80006d3e:	59 68       	cp.w	r8,22
80006d40:	f9 b7 08 10 	movls	r7,16
80006d44:	16 37       	cp.w	r7,r11
80006d46:	5f 38       	srlo	r8
80006d48:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
80006d4c:	c0 50       	breq	80006d56 <_malloc_r+0x26>
80006d4e:	30 c8       	mov	r8,12
80006d50:	99 38       	st.w	r12[0xc],r8
80006d52:	e0 8f 01 fa 	bral	80007146 <_malloc_r+0x416>
80006d56:	fe b0 f5 6b 	rcall	8000582c <__malloc_lock>
80006d5a:	e0 47 01 f7 	cp.w	r7,503
80006d5e:	e0 8b 00 1d 	brhi	80006d98 <_malloc_r+0x68>
80006d62:	ee 03 16 03 	lsr	r3,r7,0x3
80006d66:	e0 68 05 3c 	mov	r8,1340
80006d6a:	f0 03 00 38 	add	r8,r8,r3<<0x3
80006d6e:	70 36       	ld.w	r6,r8[0xc]
80006d70:	10 36       	cp.w	r6,r8
80006d72:	c0 61       	brne	80006d7e <_malloc_r+0x4e>
80006d74:	ec c8 ff f8 	sub	r8,r6,-8
80006d78:	70 36       	ld.w	r6,r8[0xc]
80006d7a:	10 36       	cp.w	r6,r8
80006d7c:	c0 c0       	breq	80006d94 <_malloc_r+0x64>
80006d7e:	6c 18       	ld.w	r8,r6[0x4]
80006d80:	e0 18 ff fc 	andl	r8,0xfffc
80006d84:	6c 3a       	ld.w	r10,r6[0xc]
80006d86:	ec 08 00 09 	add	r9,r6,r8
80006d8a:	0a 9c       	mov	r12,r5
80006d8c:	6c 28       	ld.w	r8,r6[0x8]
80006d8e:	95 28       	st.w	r10[0x8],r8
80006d90:	91 3a       	st.w	r8[0xc],r10
80006d92:	c4 78       	rjmp	80006e20 <_malloc_r+0xf0>
80006d94:	2f e3       	sub	r3,-2
80006d96:	c4 d8       	rjmp	80006e30 <_malloc_r+0x100>
80006d98:	ee 03 16 09 	lsr	r3,r7,0x9
80006d9c:	c0 41       	brne	80006da4 <_malloc_r+0x74>
80006d9e:	ee 03 16 03 	lsr	r3,r7,0x3
80006da2:	c2 68       	rjmp	80006dee <_malloc_r+0xbe>
80006da4:	58 43       	cp.w	r3,4
80006da6:	e0 8b 00 06 	brhi	80006db2 <_malloc_r+0x82>
80006daa:	ee 03 16 06 	lsr	r3,r7,0x6
80006dae:	2c 83       	sub	r3,-56
80006db0:	c1 f8       	rjmp	80006dee <_malloc_r+0xbe>
80006db2:	59 43       	cp.w	r3,20
80006db4:	e0 8b 00 04 	brhi	80006dbc <_malloc_r+0x8c>
80006db8:	2a 53       	sub	r3,-91
80006dba:	c1 a8       	rjmp	80006dee <_malloc_r+0xbe>
80006dbc:	e0 43 00 54 	cp.w	r3,84
80006dc0:	e0 8b 00 06 	brhi	80006dcc <_malloc_r+0x9c>
80006dc4:	ee 03 16 0c 	lsr	r3,r7,0xc
80006dc8:	29 23       	sub	r3,-110
80006dca:	c1 28       	rjmp	80006dee <_malloc_r+0xbe>
80006dcc:	e0 43 01 54 	cp.w	r3,340
80006dd0:	e0 8b 00 06 	brhi	80006ddc <_malloc_r+0xac>
80006dd4:	ee 03 16 0f 	lsr	r3,r7,0xf
80006dd8:	28 93       	sub	r3,-119
80006dda:	c0 a8       	rjmp	80006dee <_malloc_r+0xbe>
80006ddc:	e0 43 05 54 	cp.w	r3,1364
80006de0:	e0 88 00 04 	brls	80006de8 <_malloc_r+0xb8>
80006de4:	37 e3       	mov	r3,126
80006de6:	c0 48       	rjmp	80006dee <_malloc_r+0xbe>
80006de8:	ee 03 16 12 	lsr	r3,r7,0x12
80006dec:	28 43       	sub	r3,-124
80006dee:	e0 6a 05 3c 	mov	r10,1340
80006df2:	f4 03 00 3a 	add	r10,r10,r3<<0x3
80006df6:	74 36       	ld.w	r6,r10[0xc]
80006df8:	c1 98       	rjmp	80006e2a <_malloc_r+0xfa>
80006dfa:	6c 19       	ld.w	r9,r6[0x4]
80006dfc:	e0 19 ff fc 	andl	r9,0xfffc
80006e00:	f2 07 01 0b 	sub	r11,r9,r7
80006e04:	58 fb       	cp.w	r11,15
80006e06:	e0 8a 00 04 	brle	80006e0e <_malloc_r+0xde>
80006e0a:	20 13       	sub	r3,1
80006e0c:	c1 18       	rjmp	80006e2e <_malloc_r+0xfe>
80006e0e:	6c 38       	ld.w	r8,r6[0xc]
80006e10:	58 0b       	cp.w	r11,0
80006e12:	c0 b5       	brlt	80006e28 <_malloc_r+0xf8>
80006e14:	6c 2a       	ld.w	r10,r6[0x8]
80006e16:	ec 09 00 09 	add	r9,r6,r9
80006e1a:	0a 9c       	mov	r12,r5
80006e1c:	91 2a       	st.w	r8[0x8],r10
80006e1e:	95 38       	st.w	r10[0xc],r8
80006e20:	72 18       	ld.w	r8,r9[0x4]
80006e22:	a1 a8       	sbr	r8,0x0
80006e24:	93 18       	st.w	r9[0x4],r8
80006e26:	cb c8       	rjmp	80006f9e <_malloc_r+0x26e>
80006e28:	10 96       	mov	r6,r8
80006e2a:	14 36       	cp.w	r6,r10
80006e2c:	ce 71       	brne	80006dfa <_malloc_r+0xca>
80006e2e:	2f f3       	sub	r3,-1
80006e30:	e0 6a 05 3c 	mov	r10,1340
80006e34:	f4 cc ff f8 	sub	r12,r10,-8
80006e38:	78 26       	ld.w	r6,r12[0x8]
80006e3a:	18 36       	cp.w	r6,r12
80006e3c:	c6 c0       	breq	80006f14 <_malloc_r+0x1e4>
80006e3e:	6c 19       	ld.w	r9,r6[0x4]
80006e40:	e0 19 ff fc 	andl	r9,0xfffc
80006e44:	f2 07 01 08 	sub	r8,r9,r7
80006e48:	58 f8       	cp.w	r8,15
80006e4a:	e0 89 00 8f 	brgt	80006f68 <_malloc_r+0x238>
80006e4e:	99 3c       	st.w	r12[0xc],r12
80006e50:	99 2c       	st.w	r12[0x8],r12
80006e52:	58 08       	cp.w	r8,0
80006e54:	c0 55       	brlt	80006e5e <_malloc_r+0x12e>
80006e56:	ec 09 00 09 	add	r9,r6,r9
80006e5a:	0a 9c       	mov	r12,r5
80006e5c:	ce 2b       	rjmp	80006e20 <_malloc_r+0xf0>
80006e5e:	e0 49 01 ff 	cp.w	r9,511
80006e62:	e0 8b 00 13 	brhi	80006e88 <_malloc_r+0x158>
80006e66:	a3 99       	lsr	r9,0x3
80006e68:	f4 09 00 38 	add	r8,r10,r9<<0x3
80006e6c:	70 2b       	ld.w	r11,r8[0x8]
80006e6e:	8d 38       	st.w	r6[0xc],r8
80006e70:	8d 2b       	st.w	r6[0x8],r11
80006e72:	97 36       	st.w	r11[0xc],r6
80006e74:	91 26       	st.w	r8[0x8],r6
80006e76:	a3 49       	asr	r9,0x2
80006e78:	74 18       	ld.w	r8,r10[0x4]
80006e7a:	30 1b       	mov	r11,1
80006e7c:	f6 09 09 49 	lsl	r9,r11,r9
80006e80:	f1 e9 10 09 	or	r9,r8,r9
80006e84:	95 19       	st.w	r10[0x4],r9
80006e86:	c4 78       	rjmp	80006f14 <_malloc_r+0x1e4>
80006e88:	f2 0a 16 09 	lsr	r10,r9,0x9
80006e8c:	58 4a       	cp.w	r10,4
80006e8e:	e0 8b 00 07 	brhi	80006e9c <_malloc_r+0x16c>
80006e92:	f2 0a 16 06 	lsr	r10,r9,0x6
80006e96:	2c 8a       	sub	r10,-56
80006e98:	c2 08       	rjmp	80006ed8 <_malloc_r+0x1a8>
80006e9a:	d7 03       	nop
80006e9c:	59 4a       	cp.w	r10,20
80006e9e:	e0 8b 00 04 	brhi	80006ea6 <_malloc_r+0x176>
80006ea2:	2a 5a       	sub	r10,-91
80006ea4:	c1 a8       	rjmp	80006ed8 <_malloc_r+0x1a8>
80006ea6:	e0 4a 00 54 	cp.w	r10,84
80006eaa:	e0 8b 00 06 	brhi	80006eb6 <_malloc_r+0x186>
80006eae:	f2 0a 16 0c 	lsr	r10,r9,0xc
80006eb2:	29 2a       	sub	r10,-110
80006eb4:	c1 28       	rjmp	80006ed8 <_malloc_r+0x1a8>
80006eb6:	e0 4a 01 54 	cp.w	r10,340
80006eba:	e0 8b 00 06 	brhi	80006ec6 <_malloc_r+0x196>
80006ebe:	f2 0a 16 0f 	lsr	r10,r9,0xf
80006ec2:	28 9a       	sub	r10,-119
80006ec4:	c0 a8       	rjmp	80006ed8 <_malloc_r+0x1a8>
80006ec6:	e0 4a 05 54 	cp.w	r10,1364
80006eca:	e0 88 00 04 	brls	80006ed2 <_malloc_r+0x1a2>
80006ece:	37 ea       	mov	r10,126
80006ed0:	c0 48       	rjmp	80006ed8 <_malloc_r+0x1a8>
80006ed2:	f2 0a 16 12 	lsr	r10,r9,0x12
80006ed6:	28 4a       	sub	r10,-124
80006ed8:	e0 6b 05 3c 	mov	r11,1340
80006edc:	f6 0a 00 34 	add	r4,r11,r10<<0x3
80006ee0:	68 28       	ld.w	r8,r4[0x8]
80006ee2:	08 38       	cp.w	r8,r4
80006ee4:	c0 e1       	brne	80006f00 <_malloc_r+0x1d0>
80006ee6:	76 19       	ld.w	r9,r11[0x4]
80006ee8:	a3 4a       	asr	r10,0x2
80006eea:	30 1e       	mov	lr,1
80006eec:	fc 0a 09 4a 	lsl	r10,lr,r10
80006ef0:	f3 ea 10 0a 	or	r10,r9,r10
80006ef4:	10 99       	mov	r9,r8
80006ef6:	97 1a       	st.w	r11[0x4],r10
80006ef8:	c0 a8       	rjmp	80006f0c <_malloc_r+0x1dc>
80006efa:	70 28       	ld.w	r8,r8[0x8]
80006efc:	08 38       	cp.w	r8,r4
80006efe:	c0 60       	breq	80006f0a <_malloc_r+0x1da>
80006f00:	70 1a       	ld.w	r10,r8[0x4]
80006f02:	e0 1a ff fc 	andl	r10,0xfffc
80006f06:	14 39       	cp.w	r9,r10
80006f08:	cf 93       	brcs	80006efa <_malloc_r+0x1ca>
80006f0a:	70 39       	ld.w	r9,r8[0xc]
80006f0c:	8d 39       	st.w	r6[0xc],r9
80006f0e:	8d 28       	st.w	r6[0x8],r8
80006f10:	91 36       	st.w	r8[0xc],r6
80006f12:	93 26       	st.w	r9[0x8],r6
80006f14:	e6 08 14 02 	asr	r8,r3,0x2
80006f18:	30 1b       	mov	r11,1
80006f1a:	e0 64 05 3c 	mov	r4,1340
80006f1e:	f6 08 09 4b 	lsl	r11,r11,r8
80006f22:	68 18       	ld.w	r8,r4[0x4]
80006f24:	10 3b       	cp.w	r11,r8
80006f26:	e0 8b 00 6b 	brhi	80006ffc <_malloc_r+0x2cc>
80006f2a:	f7 e8 00 09 	and	r9,r11,r8
80006f2e:	c0 b1       	brne	80006f44 <_malloc_r+0x214>
80006f30:	e0 13 ff fc 	andl	r3,0xfffc
80006f34:	a1 7b       	lsl	r11,0x1
80006f36:	2f c3       	sub	r3,-4
80006f38:	c0 38       	rjmp	80006f3e <_malloc_r+0x20e>
80006f3a:	2f c3       	sub	r3,-4
80006f3c:	a1 7b       	lsl	r11,0x1
80006f3e:	f7 e8 00 09 	and	r9,r11,r8
80006f42:	cf c0       	breq	80006f3a <_malloc_r+0x20a>
80006f44:	e8 03 00 3e 	add	lr,r4,r3<<0x3
80006f48:	06 92       	mov	r2,r3
80006f4a:	1c 91       	mov	r1,lr
80006f4c:	62 36       	ld.w	r6,r1[0xc]
80006f4e:	c2 e8       	rjmp	80006faa <_malloc_r+0x27a>
80006f50:	6c 1a       	ld.w	r10,r6[0x4]
80006f52:	e0 1a ff fc 	andl	r10,0xfffc
80006f56:	f4 07 01 08 	sub	r8,r10,r7
80006f5a:	58 f8       	cp.w	r8,15
80006f5c:	e0 8a 00 15 	brle	80006f86 <_malloc_r+0x256>
80006f60:	6c 3a       	ld.w	r10,r6[0xc]
80006f62:	6c 29       	ld.w	r9,r6[0x8]
80006f64:	95 29       	st.w	r10[0x8],r9
80006f66:	93 3a       	st.w	r9[0xc],r10
80006f68:	0e 99       	mov	r9,r7
80006f6a:	ec 07 00 07 	add	r7,r6,r7
80006f6e:	a1 a9       	sbr	r9,0x0
80006f70:	99 37       	st.w	r12[0xc],r7
80006f72:	99 27       	st.w	r12[0x8],r7
80006f74:	8d 19       	st.w	r6[0x4],r9
80006f76:	ee 08 09 08 	st.w	r7[r8],r8
80006f7a:	8f 2c       	st.w	r7[0x8],r12
80006f7c:	8f 3c       	st.w	r7[0xc],r12
80006f7e:	a1 a8       	sbr	r8,0x0
80006f80:	0a 9c       	mov	r12,r5
80006f82:	8f 18       	st.w	r7[0x4],r8
80006f84:	c0 d8       	rjmp	80006f9e <_malloc_r+0x26e>
80006f86:	6c 39       	ld.w	r9,r6[0xc]
80006f88:	58 08       	cp.w	r8,0
80006f8a:	c0 f5       	brlt	80006fa8 <_malloc_r+0x278>
80006f8c:	ec 0a 00 0a 	add	r10,r6,r10
80006f90:	74 18       	ld.w	r8,r10[0x4]
80006f92:	a1 a8       	sbr	r8,0x0
80006f94:	0a 9c       	mov	r12,r5
80006f96:	95 18       	st.w	r10[0x4],r8
80006f98:	6c 28       	ld.w	r8,r6[0x8]
80006f9a:	93 28       	st.w	r9[0x8],r8
80006f9c:	91 39       	st.w	r8[0xc],r9
80006f9e:	fe b0 f4 4d 	rcall	80005838 <__malloc_unlock>
80006fa2:	ec cc ff f8 	sub	r12,r6,-8
80006fa6:	d8 32       	popm	r0-r7,pc
80006fa8:	12 96       	mov	r6,r9
80006faa:	02 36       	cp.w	r6,r1
80006fac:	cd 21       	brne	80006f50 <_malloc_r+0x220>
80006fae:	2f f2       	sub	r2,-1
80006fb0:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
80006fb4:	c0 30       	breq	80006fba <_malloc_r+0x28a>
80006fb6:	2f 81       	sub	r1,-8
80006fb8:	cc ab       	rjmp	80006f4c <_malloc_r+0x21c>
80006fba:	1c 98       	mov	r8,lr
80006fbc:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
80006fc0:	c0 81       	brne	80006fd0 <_malloc_r+0x2a0>
80006fc2:	68 19       	ld.w	r9,r4[0x4]
80006fc4:	f6 08 11 ff 	rsub	r8,r11,-1
80006fc8:	f3 e8 00 08 	and	r8,r9,r8
80006fcc:	89 18       	st.w	r4[0x4],r8
80006fce:	c0 78       	rjmp	80006fdc <_malloc_r+0x2ac>
80006fd0:	f0 c9 00 08 	sub	r9,r8,8
80006fd4:	20 13       	sub	r3,1
80006fd6:	70 08       	ld.w	r8,r8[0x0]
80006fd8:	12 38       	cp.w	r8,r9
80006fda:	cf 10       	breq	80006fbc <_malloc_r+0x28c>
80006fdc:	a1 7b       	lsl	r11,0x1
80006fde:	68 18       	ld.w	r8,r4[0x4]
80006fe0:	10 3b       	cp.w	r11,r8
80006fe2:	e0 8b 00 0d 	brhi	80006ffc <_malloc_r+0x2cc>
80006fe6:	58 0b       	cp.w	r11,0
80006fe8:	c0 a0       	breq	80006ffc <_malloc_r+0x2cc>
80006fea:	04 93       	mov	r3,r2
80006fec:	c0 38       	rjmp	80006ff2 <_malloc_r+0x2c2>
80006fee:	2f c3       	sub	r3,-4
80006ff0:	a1 7b       	lsl	r11,0x1
80006ff2:	f7 e8 00 09 	and	r9,r11,r8
80006ff6:	ca 71       	brne	80006f44 <_malloc_r+0x214>
80006ff8:	cf bb       	rjmp	80006fee <_malloc_r+0x2be>
80006ffa:	d7 03       	nop
80006ffc:	68 23       	ld.w	r3,r4[0x8]
80006ffe:	66 12       	ld.w	r2,r3[0x4]
80007000:	e0 12 ff fc 	andl	r2,0xfffc
80007004:	0e 32       	cp.w	r2,r7
80007006:	5f 39       	srlo	r9
80007008:	e4 07 01 08 	sub	r8,r2,r7
8000700c:	58 f8       	cp.w	r8,15
8000700e:	5f aa       	srle	r10
80007010:	f5 e9 10 09 	or	r9,r10,r9
80007014:	e0 80 00 9a 	breq	80007148 <_malloc_r+0x418>
80007018:	e0 68 0d 54 	mov	r8,3412
8000701c:	70 01       	ld.w	r1,r8[0x0]
8000701e:	e0 68 09 48 	mov	r8,2376
80007022:	2f 01       	sub	r1,-16
80007024:	70 08       	ld.w	r8,r8[0x0]
80007026:	0e 01       	add	r1,r7
80007028:	5b f8       	cp.w	r8,-1
8000702a:	c0 40       	breq	80007032 <_malloc_r+0x302>
8000702c:	28 11       	sub	r1,-127
8000702e:	e0 11 ff 80 	andl	r1,0xff80
80007032:	02 9b       	mov	r11,r1
80007034:	0a 9c       	mov	r12,r5
80007036:	e0 a0 02 b7 	rcall	800075a4 <_sbrk_r>
8000703a:	18 96       	mov	r6,r12
8000703c:	5b fc       	cp.w	r12,-1
8000703e:	c7 50       	breq	80007128 <_malloc_r+0x3f8>
80007040:	e6 02 00 08 	add	r8,r3,r2
80007044:	10 3c       	cp.w	r12,r8
80007046:	c0 32       	brcc	8000704c <_malloc_r+0x31c>
80007048:	08 33       	cp.w	r3,r4
8000704a:	c6 f1       	brne	80007128 <_malloc_r+0x3f8>
8000704c:	e0 6a 0d 58 	mov	r10,3416
80007050:	74 09       	ld.w	r9,r10[0x0]
80007052:	e2 09 00 09 	add	r9,r1,r9
80007056:	95 09       	st.w	r10[0x0],r9
80007058:	10 36       	cp.w	r6,r8
8000705a:	c0 a1       	brne	8000706e <_malloc_r+0x33e>
8000705c:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
80007060:	c0 71       	brne	8000706e <_malloc_r+0x33e>
80007062:	e2 02 00 02 	add	r2,r1,r2
80007066:	68 28       	ld.w	r8,r4[0x8]
80007068:	a1 a2       	sbr	r2,0x0
8000706a:	91 12       	st.w	r8[0x4],r2
8000706c:	c4 f8       	rjmp	8000710a <_malloc_r+0x3da>
8000706e:	e0 6a 09 48 	mov	r10,2376
80007072:	74 0b       	ld.w	r11,r10[0x0]
80007074:	5b fb       	cp.w	r11,-1
80007076:	c0 31       	brne	8000707c <_malloc_r+0x34c>
80007078:	95 06       	st.w	r10[0x0],r6
8000707a:	c0 78       	rjmp	80007088 <_malloc_r+0x358>
8000707c:	ec 09 00 09 	add	r9,r6,r9
80007080:	e0 6a 0d 58 	mov	r10,3416
80007084:	10 19       	sub	r9,r8
80007086:	95 09       	st.w	r10[0x0],r9
80007088:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
8000708c:	f0 09 11 08 	rsub	r9,r8,8
80007090:	58 08       	cp.w	r8,0
80007092:	f2 08 17 10 	movne	r8,r9
80007096:	ed d8 e1 06 	addne	r6,r6,r8
8000709a:	28 08       	sub	r8,-128
8000709c:	ec 01 00 01 	add	r1,r6,r1
800070a0:	0a 9c       	mov	r12,r5
800070a2:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
800070a6:	f0 01 01 01 	sub	r1,r8,r1
800070aa:	02 9b       	mov	r11,r1
800070ac:	e0 a0 02 7c 	rcall	800075a4 <_sbrk_r>
800070b0:	e0 68 0d 58 	mov	r8,3416
800070b4:	5b fc       	cp.w	r12,-1
800070b6:	ec 0c 17 00 	moveq	r12,r6
800070ba:	f9 b1 00 00 	moveq	r1,0
800070be:	70 09       	ld.w	r9,r8[0x0]
800070c0:	0c 1c       	sub	r12,r6
800070c2:	89 26       	st.w	r4[0x8],r6
800070c4:	02 0c       	add	r12,r1
800070c6:	12 01       	add	r1,r9
800070c8:	a1 ac       	sbr	r12,0x0
800070ca:	91 01       	st.w	r8[0x0],r1
800070cc:	8d 1c       	st.w	r6[0x4],r12
800070ce:	08 33       	cp.w	r3,r4
800070d0:	c1 d0       	breq	8000710a <_malloc_r+0x3da>
800070d2:	58 f2       	cp.w	r2,15
800070d4:	e0 8b 00 05 	brhi	800070de <_malloc_r+0x3ae>
800070d8:	30 18       	mov	r8,1
800070da:	8d 18       	st.w	r6[0x4],r8
800070dc:	c2 68       	rjmp	80007128 <_malloc_r+0x3f8>
800070de:	30 59       	mov	r9,5
800070e0:	20 c2       	sub	r2,12
800070e2:	e0 12 ff f8 	andl	r2,0xfff8
800070e6:	e6 02 00 08 	add	r8,r3,r2
800070ea:	91 29       	st.w	r8[0x8],r9
800070ec:	91 19       	st.w	r8[0x4],r9
800070ee:	66 18       	ld.w	r8,r3[0x4]
800070f0:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800070f4:	e5 e8 10 08 	or	r8,r2,r8
800070f8:	87 18       	st.w	r3[0x4],r8
800070fa:	58 f2       	cp.w	r2,15
800070fc:	e0 88 00 07 	brls	8000710a <_malloc_r+0x3da>
80007100:	e6 cb ff f8 	sub	r11,r3,-8
80007104:	0a 9c       	mov	r12,r5
80007106:	e0 a0 1c ab 	rcall	8000aa5c <_free_r>
8000710a:	e0 69 0d 50 	mov	r9,3408
8000710e:	72 0a       	ld.w	r10,r9[0x0]
80007110:	e0 68 0d 58 	mov	r8,3416
80007114:	70 08       	ld.w	r8,r8[0x0]
80007116:	14 38       	cp.w	r8,r10
80007118:	f3 f8 ba 00 	st.whi	r9[0x0],r8
8000711c:	e0 69 0d 4c 	mov	r9,3404
80007120:	72 0a       	ld.w	r10,r9[0x0]
80007122:	14 38       	cp.w	r8,r10
80007124:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80007128:	68 28       	ld.w	r8,r4[0x8]
8000712a:	70 18       	ld.w	r8,r8[0x4]
8000712c:	e0 18 ff fc 	andl	r8,0xfffc
80007130:	0e 38       	cp.w	r8,r7
80007132:	5f 39       	srlo	r9
80007134:	0e 18       	sub	r8,r7
80007136:	58 f8       	cp.w	r8,15
80007138:	5f aa       	srle	r10
8000713a:	f5 e9 10 09 	or	r9,r10,r9
8000713e:	c0 50       	breq	80007148 <_malloc_r+0x418>
80007140:	0a 9c       	mov	r12,r5
80007142:	fe b0 f3 7b 	rcall	80005838 <__malloc_unlock>
80007146:	d8 3a       	popm	r0-r7,pc,r12=0
80007148:	68 26       	ld.w	r6,r4[0x8]
8000714a:	a1 a8       	sbr	r8,0x0
8000714c:	0e 99       	mov	r9,r7
8000714e:	a1 a9       	sbr	r9,0x0
80007150:	8d 19       	st.w	r6[0x4],r9
80007152:	ec 07 00 07 	add	r7,r6,r7
80007156:	0a 9c       	mov	r12,r5
80007158:	89 27       	st.w	r4[0x8],r7
8000715a:	8f 18       	st.w	r7[0x4],r8
8000715c:	fe b0 f3 6e 	rcall	80005838 <__malloc_unlock>
80007160:	ec cc ff f8 	sub	r12,r6,-8
80007164:	d8 32       	popm	r0-r7,pc
80007166:	d7 03       	nop

80007168 <memcmp>:
80007168:	d4 01       	pushm	lr
8000716a:	30 08       	mov	r8,0
8000716c:	c0 d8       	rjmp	80007186 <memcmp+0x1e>
8000716e:	f8 08 07 0e 	ld.ub	lr,r12[r8]
80007172:	f6 08 07 09 	ld.ub	r9,r11[r8]
80007176:	20 1a       	sub	r10,1
80007178:	2f f8       	sub	r8,-1
8000717a:	f2 0e 18 00 	cp.b	lr,r9
8000717e:	c0 40       	breq	80007186 <memcmp+0x1e>
80007180:	fc 09 01 0c 	sub	r12,lr,r9
80007184:	d8 02       	popm	pc
80007186:	58 0a       	cp.w	r10,0
80007188:	cf 31       	brne	8000716e <memcmp+0x6>
8000718a:	14 9c       	mov	r12,r10
8000718c:	d8 02       	popm	pc

8000718e <memcpy>:
8000718e:	58 8a       	cp.w	r10,8
80007190:	c2 f5       	brlt	800071ee <memcpy+0x60>
80007192:	f9 eb 10 09 	or	r9,r12,r11
80007196:	e2 19 00 03 	andl	r9,0x3,COH
8000719a:	e0 81 00 97 	brne	800072c8 <memcpy+0x13a>
8000719e:	e0 4a 00 20 	cp.w	r10,32
800071a2:	c3 b4       	brge	80007218 <memcpy+0x8a>
800071a4:	f4 08 14 02 	asr	r8,r10,0x2
800071a8:	f0 09 11 08 	rsub	r9,r8,8
800071ac:	fe 09 00 2f 	add	pc,pc,r9<<0x2
800071b0:	76 69       	ld.w	r9,r11[0x18]
800071b2:	99 69       	st.w	r12[0x18],r9
800071b4:	76 59       	ld.w	r9,r11[0x14]
800071b6:	99 59       	st.w	r12[0x14],r9
800071b8:	76 49       	ld.w	r9,r11[0x10]
800071ba:	99 49       	st.w	r12[0x10],r9
800071bc:	76 39       	ld.w	r9,r11[0xc]
800071be:	99 39       	st.w	r12[0xc],r9
800071c0:	76 29       	ld.w	r9,r11[0x8]
800071c2:	99 29       	st.w	r12[0x8],r9
800071c4:	76 19       	ld.w	r9,r11[0x4]
800071c6:	99 19       	st.w	r12[0x4],r9
800071c8:	76 09       	ld.w	r9,r11[0x0]
800071ca:	99 09       	st.w	r12[0x0],r9
800071cc:	f6 08 00 2b 	add	r11,r11,r8<<0x2
800071d0:	f8 08 00 28 	add	r8,r12,r8<<0x2
800071d4:	e0 1a 00 03 	andl	r10,0x3
800071d8:	f4 0a 11 04 	rsub	r10,r10,4
800071dc:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
800071e0:	17 a9       	ld.ub	r9,r11[0x2]
800071e2:	b0 a9       	st.b	r8[0x2],r9
800071e4:	17 99       	ld.ub	r9,r11[0x1]
800071e6:	b0 99       	st.b	r8[0x1],r9
800071e8:	17 89       	ld.ub	r9,r11[0x0]
800071ea:	b0 89       	st.b	r8[0x0],r9
800071ec:	5e fc       	retal	r12
800071ee:	f4 0a 11 09 	rsub	r10,r10,9
800071f2:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
800071f6:	17 f9       	ld.ub	r9,r11[0x7]
800071f8:	b8 f9       	st.b	r12[0x7],r9
800071fa:	17 e9       	ld.ub	r9,r11[0x6]
800071fc:	b8 e9       	st.b	r12[0x6],r9
800071fe:	17 d9       	ld.ub	r9,r11[0x5]
80007200:	b8 d9       	st.b	r12[0x5],r9
80007202:	17 c9       	ld.ub	r9,r11[0x4]
80007204:	b8 c9       	st.b	r12[0x4],r9
80007206:	17 b9       	ld.ub	r9,r11[0x3]
80007208:	b8 b9       	st.b	r12[0x3],r9
8000720a:	17 a9       	ld.ub	r9,r11[0x2]
8000720c:	b8 a9       	st.b	r12[0x2],r9
8000720e:	17 99       	ld.ub	r9,r11[0x1]
80007210:	b8 99       	st.b	r12[0x1],r9
80007212:	17 89       	ld.ub	r9,r11[0x0]
80007214:	b8 89       	st.b	r12[0x0],r9
80007216:	5e fc       	retal	r12
80007218:	eb cd 40 c0 	pushm	r6-r7,lr
8000721c:	18 99       	mov	r9,r12
8000721e:	22 0a       	sub	r10,32
80007220:	b7 07       	ld.d	r6,r11++
80007222:	b3 26       	st.d	r9++,r6
80007224:	b7 07       	ld.d	r6,r11++
80007226:	b3 26       	st.d	r9++,r6
80007228:	b7 07       	ld.d	r6,r11++
8000722a:	b3 26       	st.d	r9++,r6
8000722c:	b7 07       	ld.d	r6,r11++
8000722e:	b3 26       	st.d	r9++,r6
80007230:	22 0a       	sub	r10,32
80007232:	cf 74       	brge	80007220 <memcpy+0x92>
80007234:	2f 0a       	sub	r10,-16
80007236:	c0 65       	brlt	80007242 <memcpy+0xb4>
80007238:	b7 07       	ld.d	r6,r11++
8000723a:	b3 26       	st.d	r9++,r6
8000723c:	b7 07       	ld.d	r6,r11++
8000723e:	b3 26       	st.d	r9++,r6
80007240:	21 0a       	sub	r10,16
80007242:	5c 3a       	neg	r10
80007244:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
80007248:	d7 03       	nop
8000724a:	d7 03       	nop
8000724c:	f7 36 00 0e 	ld.ub	r6,r11[14]
80007250:	f3 66 00 0e 	st.b	r9[14],r6
80007254:	f7 36 00 0d 	ld.ub	r6,r11[13]
80007258:	f3 66 00 0d 	st.b	r9[13],r6
8000725c:	f7 36 00 0c 	ld.ub	r6,r11[12]
80007260:	f3 66 00 0c 	st.b	r9[12],r6
80007264:	f7 36 00 0b 	ld.ub	r6,r11[11]
80007268:	f3 66 00 0b 	st.b	r9[11],r6
8000726c:	f7 36 00 0a 	ld.ub	r6,r11[10]
80007270:	f3 66 00 0a 	st.b	r9[10],r6
80007274:	f7 36 00 09 	ld.ub	r6,r11[9]
80007278:	f3 66 00 09 	st.b	r9[9],r6
8000727c:	f7 36 00 08 	ld.ub	r6,r11[8]
80007280:	f3 66 00 08 	st.b	r9[8],r6
80007284:	f7 36 00 07 	ld.ub	r6,r11[7]
80007288:	f3 66 00 07 	st.b	r9[7],r6
8000728c:	f7 36 00 06 	ld.ub	r6,r11[6]
80007290:	f3 66 00 06 	st.b	r9[6],r6
80007294:	f7 36 00 05 	ld.ub	r6,r11[5]
80007298:	f3 66 00 05 	st.b	r9[5],r6
8000729c:	f7 36 00 04 	ld.ub	r6,r11[4]
800072a0:	f3 66 00 04 	st.b	r9[4],r6
800072a4:	f7 36 00 03 	ld.ub	r6,r11[3]
800072a8:	f3 66 00 03 	st.b	r9[3],r6
800072ac:	f7 36 00 02 	ld.ub	r6,r11[2]
800072b0:	f3 66 00 02 	st.b	r9[2],r6
800072b4:	f7 36 00 01 	ld.ub	r6,r11[1]
800072b8:	f3 66 00 01 	st.b	r9[1],r6
800072bc:	f7 36 00 00 	ld.ub	r6,r11[0]
800072c0:	f3 66 00 00 	st.b	r9[0],r6
800072c4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800072c8:	20 1a       	sub	r10,1
800072ca:	f6 0a 07 09 	ld.ub	r9,r11[r10]
800072ce:	f8 0a 0b 09 	st.b	r12[r10],r9
800072d2:	cf b1       	brne	800072c8 <memcpy+0x13a>
800072d4:	5e fc       	retal	r12

800072d6 <memset>:
800072d6:	18 98       	mov	r8,r12
800072d8:	c0 38       	rjmp	800072de <memset+0x8>
800072da:	10 cb       	st.b	r8++,r11
800072dc:	20 1a       	sub	r10,1
800072de:	58 0a       	cp.w	r10,0
800072e0:	cf d1       	brne	800072da <memset+0x4>
800072e2:	5e fc       	retal	r12

800072e4 <_realloc_r>:
800072e4:	d4 31       	pushm	r0-r7,lr
800072e6:	20 1d       	sub	sp,4
800072e8:	16 94       	mov	r4,r11
800072ea:	18 92       	mov	r2,r12
800072ec:	14 9b       	mov	r11,r10
800072ee:	58 04       	cp.w	r4,0
800072f0:	c0 51       	brne	800072fa <_realloc_r+0x16>
800072f2:	fe b0 fd 1f 	rcall	80006d30 <_malloc_r>
800072f6:	18 95       	mov	r5,r12
800072f8:	c5 39       	rjmp	8000759e <_realloc_r+0x2ba>
800072fa:	50 0a       	stdsp	sp[0x0],r10
800072fc:	fe b0 f2 98 	rcall	8000582c <__malloc_lock>
80007300:	40 0b       	lddsp	r11,sp[0x0]
80007302:	f6 c8 ff f5 	sub	r8,r11,-11
80007306:	e8 c1 00 08 	sub	r1,r4,8
8000730a:	10 96       	mov	r6,r8
8000730c:	62 1c       	ld.w	r12,r1[0x4]
8000730e:	e0 16 ff f8 	andl	r6,0xfff8
80007312:	59 68       	cp.w	r8,22
80007314:	f9 b6 08 10 	movls	r6,16
80007318:	16 36       	cp.w	r6,r11
8000731a:	5f 38       	srlo	r8
8000731c:	f1 e6 13 f8 	or	r8,r8,r6>>0x1f
80007320:	c0 50       	breq	8000732a <_realloc_r+0x46>
80007322:	30 c8       	mov	r8,12
80007324:	30 05       	mov	r5,0
80007326:	85 38       	st.w	r2[0xc],r8
80007328:	c3 b9       	rjmp	8000759e <_realloc_r+0x2ba>
8000732a:	18 90       	mov	r0,r12
8000732c:	e0 10 ff fc 	andl	r0,0xfffc
80007330:	0c 30       	cp.w	r0,r6
80007332:	e0 84 01 0b 	brge	80007548 <_realloc_r+0x264>
80007336:	e0 68 05 3c 	mov	r8,1340
8000733a:	e2 00 00 09 	add	r9,r1,r0
8000733e:	70 25       	ld.w	r5,r8[0x8]
80007340:	0a 39       	cp.w	r9,r5
80007342:	c0 90       	breq	80007354 <_realloc_r+0x70>
80007344:	72 1a       	ld.w	r10,r9[0x4]
80007346:	a1 ca       	cbr	r10,0x0
80007348:	f2 0a 00 0a 	add	r10,r9,r10
8000734c:	74 1a       	ld.w	r10,r10[0x4]
8000734e:	ed ba 00 00 	bld	r10,0x0
80007352:	c2 20       	breq	80007396 <_realloc_r+0xb2>
80007354:	72 1a       	ld.w	r10,r9[0x4]
80007356:	e0 1a ff fc 	andl	r10,0xfffc
8000735a:	f4 00 00 03 	add	r3,r10,r0
8000735e:	0a 39       	cp.w	r9,r5
80007360:	c1 31       	brne	80007386 <_realloc_r+0xa2>
80007362:	ec c7 ff f0 	sub	r7,r6,-16
80007366:	0e 33       	cp.w	r3,r7
80007368:	c1 95       	brlt	8000739a <_realloc_r+0xb6>
8000736a:	e2 06 00 09 	add	r9,r1,r6
8000736e:	0c 13       	sub	r3,r6
80007370:	a1 a3       	sbr	r3,0x0
80007372:	93 13       	st.w	r9[0x4],r3
80007374:	91 29       	st.w	r8[0x8],r9
80007376:	04 9c       	mov	r12,r2
80007378:	62 18       	ld.w	r8,r1[0x4]
8000737a:	08 95       	mov	r5,r4
8000737c:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007380:	10 46       	or	r6,r8
80007382:	83 16       	st.w	r1[0x4],r6
80007384:	c0 b9       	rjmp	8000759a <_realloc_r+0x2b6>
80007386:	0c 33       	cp.w	r3,r6
80007388:	c0 95       	brlt	8000739a <_realloc_r+0xb6>
8000738a:	72 28       	ld.w	r8,r9[0x8]
8000738c:	02 97       	mov	r7,r1
8000738e:	72 39       	ld.w	r9,r9[0xc]
80007390:	93 28       	st.w	r9[0x8],r8
80007392:	91 39       	st.w	r8[0xc],r9
80007394:	cd c8       	rjmp	8000754c <_realloc_r+0x268>
80007396:	30 0a       	mov	r10,0
80007398:	14 99       	mov	r9,r10
8000739a:	ed bc 00 00 	bld	r12,0x0
8000739e:	e0 80 00 95 	breq	800074c8 <_realloc_r+0x1e4>
800073a2:	62 07       	ld.w	r7,r1[0x0]
800073a4:	e2 07 01 07 	sub	r7,r1,r7
800073a8:	6e 1c       	ld.w	r12,r7[0x4]
800073aa:	e0 1c ff fc 	andl	r12,0xfffc
800073ae:	58 09       	cp.w	r9,0
800073b0:	c5 60       	breq	8000745c <_realloc_r+0x178>
800073b2:	f8 00 00 03 	add	r3,r12,r0
800073b6:	0a 39       	cp.w	r9,r5
800073b8:	c4 81       	brne	80007448 <_realloc_r+0x164>
800073ba:	14 03       	add	r3,r10
800073bc:	ec c9 ff f0 	sub	r9,r6,-16
800073c0:	12 33       	cp.w	r3,r9
800073c2:	c4 d5       	brlt	8000745c <_realloc_r+0x178>
800073c4:	6e 3a       	ld.w	r10,r7[0xc]
800073c6:	6e 29       	ld.w	r9,r7[0x8]
800073c8:	95 29       	st.w	r10[0x8],r9
800073ca:	93 3a       	st.w	r9[0xc],r10
800073cc:	ee c5 ff f8 	sub	r5,r7,-8
800073d0:	e0 ca 00 04 	sub	r10,r0,4
800073d4:	e0 4a 00 24 	cp.w	r10,36
800073d8:	e0 8b 00 25 	brhi	80007422 <_realloc_r+0x13e>
800073dc:	0a 99       	mov	r9,r5
800073de:	59 3a       	cp.w	r10,19
800073e0:	e0 88 00 1a 	brls	80007414 <_realloc_r+0x130>
800073e4:	09 09       	ld.w	r9,r4++
800073e6:	8b 09       	st.w	r5[0x0],r9
800073e8:	09 09       	ld.w	r9,r4++
800073ea:	8f 39       	st.w	r7[0xc],r9
800073ec:	ee c9 ff f0 	sub	r9,r7,-16
800073f0:	59 ba       	cp.w	r10,27
800073f2:	e0 88 00 11 	brls	80007414 <_realloc_r+0x130>
800073f6:	09 0b       	ld.w	r11,r4++
800073f8:	93 0b       	st.w	r9[0x0],r11
800073fa:	09 09       	ld.w	r9,r4++
800073fc:	8f 59       	st.w	r7[0x14],r9
800073fe:	ee c9 ff e8 	sub	r9,r7,-24
80007402:	e0 4a 00 24 	cp.w	r10,36
80007406:	c0 71       	brne	80007414 <_realloc_r+0x130>
80007408:	09 0a       	ld.w	r10,r4++
8000740a:	93 0a       	st.w	r9[0x0],r10
8000740c:	ee c9 ff e0 	sub	r9,r7,-32
80007410:	09 0a       	ld.w	r10,r4++
80007412:	8f 7a       	st.w	r7[0x1c],r10
80007414:	09 0a       	ld.w	r10,r4++
80007416:	12 aa       	st.w	r9++,r10
80007418:	68 0a       	ld.w	r10,r4[0x0]
8000741a:	93 0a       	st.w	r9[0x0],r10
8000741c:	68 1a       	ld.w	r10,r4[0x4]
8000741e:	93 1a       	st.w	r9[0x4],r10
80007420:	c0 78       	rjmp	8000742e <_realloc_r+0x14a>
80007422:	50 08       	stdsp	sp[0x0],r8
80007424:	08 9b       	mov	r11,r4
80007426:	0a 9c       	mov	r12,r5
80007428:	e0 a0 1d bd 	rcall	8000afa2 <memmove>
8000742c:	40 08       	lddsp	r8,sp[0x0]
8000742e:	ee 06 00 09 	add	r9,r7,r6
80007432:	0c 13       	sub	r3,r6
80007434:	a1 a3       	sbr	r3,0x0
80007436:	93 13       	st.w	r9[0x4],r3
80007438:	91 29       	st.w	r8[0x8],r9
8000743a:	04 9c       	mov	r12,r2
8000743c:	6e 18       	ld.w	r8,r7[0x4]
8000743e:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007442:	10 46       	or	r6,r8
80007444:	8f 16       	st.w	r7[0x4],r6
80007446:	ca a8       	rjmp	8000759a <_realloc_r+0x2b6>
80007448:	14 03       	add	r3,r10
8000744a:	0c 33       	cp.w	r3,r6
8000744c:	c0 85       	brlt	8000745c <_realloc_r+0x178>
8000744e:	72 28       	ld.w	r8,r9[0x8]
80007450:	72 39       	ld.w	r9,r9[0xc]
80007452:	93 28       	st.w	r9[0x8],r8
80007454:	91 39       	st.w	r8[0xc],r9
80007456:	6e 28       	ld.w	r8,r7[0x8]
80007458:	6e 39       	ld.w	r9,r7[0xc]
8000745a:	c0 78       	rjmp	80007468 <_realloc_r+0x184>
8000745c:	f8 00 00 03 	add	r3,r12,r0
80007460:	0c 33       	cp.w	r3,r6
80007462:	c3 35       	brlt	800074c8 <_realloc_r+0x1e4>
80007464:	6e 39       	ld.w	r9,r7[0xc]
80007466:	6e 28       	ld.w	r8,r7[0x8]
80007468:	93 28       	st.w	r9[0x8],r8
8000746a:	91 39       	st.w	r8[0xc],r9
8000746c:	e0 ca 00 04 	sub	r10,r0,4
80007470:	ee cc ff f8 	sub	r12,r7,-8
80007474:	e0 4a 00 24 	cp.w	r10,36
80007478:	e0 8b 00 24 	brhi	800074c0 <_realloc_r+0x1dc>
8000747c:	59 3a       	cp.w	r10,19
8000747e:	e0 88 00 1a 	brls	800074b2 <_realloc_r+0x1ce>
80007482:	09 08       	ld.w	r8,r4++
80007484:	99 08       	st.w	r12[0x0],r8
80007486:	09 08       	ld.w	r8,r4++
80007488:	8f 38       	st.w	r7[0xc],r8
8000748a:	ee cc ff f0 	sub	r12,r7,-16
8000748e:	59 ba       	cp.w	r10,27
80007490:	e0 88 00 11 	brls	800074b2 <_realloc_r+0x1ce>
80007494:	09 08       	ld.w	r8,r4++
80007496:	99 08       	st.w	r12[0x0],r8
80007498:	09 08       	ld.w	r8,r4++
8000749a:	8f 58       	st.w	r7[0x14],r8
8000749c:	ee cc ff e8 	sub	r12,r7,-24
800074a0:	e0 4a 00 24 	cp.w	r10,36
800074a4:	c0 71       	brne	800074b2 <_realloc_r+0x1ce>
800074a6:	09 08       	ld.w	r8,r4++
800074a8:	99 08       	st.w	r12[0x0],r8
800074aa:	ee cc ff e0 	sub	r12,r7,-32
800074ae:	09 08       	ld.w	r8,r4++
800074b0:	8f 78       	st.w	r7[0x1c],r8
800074b2:	09 08       	ld.w	r8,r4++
800074b4:	18 a8       	st.w	r12++,r8
800074b6:	68 08       	ld.w	r8,r4[0x0]
800074b8:	99 08       	st.w	r12[0x0],r8
800074ba:	68 18       	ld.w	r8,r4[0x4]
800074bc:	99 18       	st.w	r12[0x4],r8
800074be:	c4 78       	rjmp	8000754c <_realloc_r+0x268>
800074c0:	08 9b       	mov	r11,r4
800074c2:	e0 a0 1d 70 	rcall	8000afa2 <memmove>
800074c6:	c4 38       	rjmp	8000754c <_realloc_r+0x268>
800074c8:	04 9c       	mov	r12,r2
800074ca:	fe b0 fc 33 	rcall	80006d30 <_malloc_r>
800074ce:	18 95       	mov	r5,r12
800074d0:	c3 a0       	breq	80007544 <_realloc_r+0x260>
800074d2:	62 18       	ld.w	r8,r1[0x4]
800074d4:	f8 c9 00 08 	sub	r9,r12,8
800074d8:	a1 c8       	cbr	r8,0x0
800074da:	e2 08 00 08 	add	r8,r1,r8
800074de:	10 39       	cp.w	r9,r8
800074e0:	c0 71       	brne	800074ee <_realloc_r+0x20a>
800074e2:	72 13       	ld.w	r3,r9[0x4]
800074e4:	02 97       	mov	r7,r1
800074e6:	e0 13 ff fc 	andl	r3,0xfffc
800074ea:	00 03       	add	r3,r0
800074ec:	c3 08       	rjmp	8000754c <_realloc_r+0x268>
800074ee:	e0 ca 00 04 	sub	r10,r0,4
800074f2:	e0 4a 00 24 	cp.w	r10,36
800074f6:	e0 8b 00 20 	brhi	80007536 <_realloc_r+0x252>
800074fa:	08 99       	mov	r9,r4
800074fc:	18 98       	mov	r8,r12
800074fe:	59 3a       	cp.w	r10,19
80007500:	e0 88 00 14 	brls	80007528 <_realloc_r+0x244>
80007504:	13 0b       	ld.w	r11,r9++
80007506:	10 ab       	st.w	r8++,r11
80007508:	13 0b       	ld.w	r11,r9++
8000750a:	10 ab       	st.w	r8++,r11
8000750c:	59 ba       	cp.w	r10,27
8000750e:	e0 88 00 0d 	brls	80007528 <_realloc_r+0x244>
80007512:	13 0b       	ld.w	r11,r9++
80007514:	10 ab       	st.w	r8++,r11
80007516:	13 0b       	ld.w	r11,r9++
80007518:	10 ab       	st.w	r8++,r11
8000751a:	e0 4a 00 24 	cp.w	r10,36
8000751e:	c0 51       	brne	80007528 <_realloc_r+0x244>
80007520:	13 0a       	ld.w	r10,r9++
80007522:	10 aa       	st.w	r8++,r10
80007524:	13 0a       	ld.w	r10,r9++
80007526:	10 aa       	st.w	r8++,r10
80007528:	13 0a       	ld.w	r10,r9++
8000752a:	10 aa       	st.w	r8++,r10
8000752c:	72 0a       	ld.w	r10,r9[0x0]
8000752e:	91 0a       	st.w	r8[0x0],r10
80007530:	72 19       	ld.w	r9,r9[0x4]
80007532:	91 19       	st.w	r8[0x4],r9
80007534:	c0 48       	rjmp	8000753c <_realloc_r+0x258>
80007536:	08 9b       	mov	r11,r4
80007538:	e0 a0 1d 35 	rcall	8000afa2 <memmove>
8000753c:	08 9b       	mov	r11,r4
8000753e:	04 9c       	mov	r12,r2
80007540:	e0 a0 1a 8e 	rcall	8000aa5c <_free_r>
80007544:	04 9c       	mov	r12,r2
80007546:	c2 a8       	rjmp	8000759a <_realloc_r+0x2b6>
80007548:	00 93       	mov	r3,r0
8000754a:	02 97       	mov	r7,r1
8000754c:	e6 06 01 09 	sub	r9,r3,r6
80007550:	6e 18       	ld.w	r8,r7[0x4]
80007552:	58 f9       	cp.w	r9,15
80007554:	e0 88 00 16 	brls	80007580 <_realloc_r+0x29c>
80007558:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000755c:	ed e8 10 08 	or	r8,r6,r8
80007560:	8f 18       	st.w	r7[0x4],r8
80007562:	12 98       	mov	r8,r9
80007564:	a1 a8       	sbr	r8,0x0
80007566:	ee 06 00 0b 	add	r11,r7,r6
8000756a:	f6 09 00 09 	add	r9,r11,r9
8000756e:	97 18       	st.w	r11[0x4],r8
80007570:	72 18       	ld.w	r8,r9[0x4]
80007572:	a1 a8       	sbr	r8,0x0
80007574:	2f 8b       	sub	r11,-8
80007576:	93 18       	st.w	r9[0x4],r8
80007578:	04 9c       	mov	r12,r2
8000757a:	e0 a0 1a 71 	rcall	8000aa5c <_free_r>
8000757e:	c0 b8       	rjmp	80007594 <_realloc_r+0x2b0>
80007580:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007584:	e7 e8 10 08 	or	r8,r3,r8
80007588:	8f 18       	st.w	r7[0x4],r8
8000758a:	ee 03 00 03 	add	r3,r7,r3
8000758e:	66 18       	ld.w	r8,r3[0x4]
80007590:	a1 a8       	sbr	r8,0x0
80007592:	87 18       	st.w	r3[0x4],r8
80007594:	04 9c       	mov	r12,r2
80007596:	ee c5 ff f8 	sub	r5,r7,-8
8000759a:	fe b0 f1 4f 	rcall	80005838 <__malloc_unlock>
8000759e:	0a 9c       	mov	r12,r5
800075a0:	2f fd       	sub	sp,-4
800075a2:	d8 32       	popm	r0-r7,pc

800075a4 <_sbrk_r>:
800075a4:	d4 21       	pushm	r4-r7,lr
800075a6:	30 08       	mov	r8,0
800075a8:	18 97       	mov	r7,r12
800075aa:	e0 66 52 e0 	mov	r6,21216
800075ae:	16 9c       	mov	r12,r11
800075b0:	8d 08       	st.w	r6[0x0],r8
800075b2:	c9 9c       	rcall	800076e4 <_sbrk>
800075b4:	5b fc       	cp.w	r12,-1
800075b6:	c0 51       	brne	800075c0 <_sbrk_r+0x1c>
800075b8:	6c 08       	ld.w	r8,r6[0x0]
800075ba:	58 08       	cp.w	r8,0
800075bc:	ef f8 1a 03 	st.wne	r7[0xc],r8
800075c0:	d8 22       	popm	r4-r7,pc
800075c2:	d7 03       	nop

800075c4 <sprintf>:
800075c4:	d4 01       	pushm	lr
800075c6:	21 7d       	sub	sp,92
800075c8:	e0 68 ff ff 	mov	r8,65535
800075cc:	ea 18 7f ff 	orh	r8,0x7fff
800075d0:	50 58       	stdsp	sp[0x14],r8
800075d2:	50 28       	stdsp	sp[0x8],r8
800075d4:	e0 68 02 08 	mov	r8,520
800075d8:	ba 68       	st.h	sp[0xc],r8
800075da:	3f f8       	mov	r8,-1
800075dc:	ba 78       	st.h	sp[0xe],r8
800075de:	e0 68 0a 3c 	mov	r8,2620
800075e2:	50 4c       	stdsp	sp[0x10],r12
800075e4:	16 9a       	mov	r10,r11
800075e6:	50 0c       	stdsp	sp[0x0],r12
800075e8:	fa c9 ff a0 	sub	r9,sp,-96
800075ec:	70 0c       	ld.w	r12,r8[0x0]
800075ee:	1a 9b       	mov	r11,sp
800075f0:	e0 a0 02 34 	rcall	80007a58 <_vfprintf_r>
800075f4:	30 09       	mov	r9,0
800075f6:	40 08       	lddsp	r8,sp[0x0]
800075f8:	b0 89       	st.b	r8[0x0],r9
800075fa:	2e 9d       	sub	sp,-92
800075fc:	d8 02       	popm	pc
800075fe:	d7 03       	nop

80007600 <strcpy>:
80007600:	30 08       	mov	r8,0
80007602:	f6 08 07 09 	ld.ub	r9,r11[r8]
80007606:	f8 08 0b 09 	st.b	r12[r8],r9
8000760a:	2f f8       	sub	r8,-1
8000760c:	58 09       	cp.w	r9,0
8000760e:	cf a1       	brne	80007602 <strcpy+0x2>
80007610:	5e fc       	retal	r12

80007612 <strlen>:
80007612:	30 09       	mov	r9,0
80007614:	18 98       	mov	r8,r12
80007616:	c0 28       	rjmp	8000761a <strlen+0x8>
80007618:	2f f8       	sub	r8,-1
8000761a:	11 8a       	ld.ub	r10,r8[0x0]
8000761c:	f2 0a 18 00 	cp.b	r10,r9
80007620:	cf c1       	brne	80007618 <strlen+0x6>
80007622:	f0 0c 01 0c 	sub	r12,r8,r12
80007626:	5e fc       	retal	r12

80007628 <strncpy>:
80007628:	30 08       	mov	r8,0
8000762a:	10 3a       	cp.w	r10,r8
8000762c:	5e 0c       	reteq	r12
8000762e:	f6 08 07 09 	ld.ub	r9,r11[r8]
80007632:	f8 08 0b 09 	st.b	r12[r8],r9
80007636:	2f f8       	sub	r8,-1
80007638:	58 09       	cp.w	r9,0
8000763a:	cf 81       	brne	8000762a <strncpy+0x2>
8000763c:	10 3a       	cp.w	r10,r8
8000763e:	5e 0c       	reteq	r12
80007640:	f8 08 0b 09 	st.b	r12[r8],r9
80007644:	2f f8       	sub	r8,-1
80007646:	cf bb       	rjmp	8000763c <strncpy+0x14>

80007648 <_close>:
80007648:	30 28       	mov	r8,2
8000764a:	d6 73       	breakpoint
8000764c:	3f fc       	mov	r12,-1
8000764e:	35 8b       	mov	r11,88
80007650:	58 0c       	cp.w	r12,0
80007652:	5e 4c       	retge	r12
80007654:	e0 6a 52 e0 	mov	r10,21216
80007658:	95 0b       	st.w	r10[0x0],r11
8000765a:	5e fc       	retal	r12

8000765c <_lseek>:
8000765c:	30 58       	mov	r8,5
8000765e:	d6 73       	breakpoint
80007660:	3f fc       	mov	r12,-1
80007662:	35 8b       	mov	r11,88
80007664:	58 0c       	cp.w	r12,0
80007666:	5e 4c       	retge	r12
80007668:	e0 6a 52 e0 	mov	r10,21216
8000766c:	95 0b       	st.w	r10[0x0],r11
8000766e:	5e fc       	retal	r12

80007670 <isatty>:
80007670:	30 b8       	mov	r8,11
80007672:	d6 73       	breakpoint
80007674:	3f fc       	mov	r12,-1
80007676:	35 8b       	mov	r11,88
80007678:	58 0c       	cp.w	r12,0
8000767a:	5e 4c       	retge	r12
8000767c:	e0 6a 52 e0 	mov	r10,21216
80007680:	95 0b       	st.w	r10[0x0],r11
80007682:	5e fc       	retal	r12

80007684 <_fstat_host>:
80007684:	30 98       	mov	r8,9
80007686:	d6 73       	breakpoint
80007688:	3f fc       	mov	r12,-1
8000768a:	35 8b       	mov	r11,88
8000768c:	58 0c       	cp.w	r12,0
8000768e:	5e 4c       	retge	r12
80007690:	e0 6a 52 e0 	mov	r10,21216
80007694:	95 0b       	st.w	r10[0x0],r11
80007696:	5e fc       	retal	r12

80007698 <_fstat>:
80007698:	d4 21       	pushm	r4-r7,lr
8000769a:	21 0d       	sub	sp,64
8000769c:	16 97       	mov	r7,r11
8000769e:	1a 9b       	mov	r11,sp
800076a0:	cf 2f       	rcall	80007684 <_fstat_host>
800076a2:	c0 34       	brge	800076a8 <_fstat+0x10>
800076a4:	3f fc       	mov	r12,-1
800076a6:	c1 c8       	rjmp	800076de <_fstat+0x46>
800076a8:	40 08       	lddsp	r8,sp[0x0]
800076aa:	ae 08       	st.h	r7[0x0],r8
800076ac:	40 18       	lddsp	r8,sp[0x4]
800076ae:	ae 18       	st.h	r7[0x2],r8
800076b0:	40 28       	lddsp	r8,sp[0x8]
800076b2:	8f 18       	st.w	r7[0x4],r8
800076b4:	40 38       	lddsp	r8,sp[0xc]
800076b6:	ae 48       	st.h	r7[0x8],r8
800076b8:	40 48       	lddsp	r8,sp[0x10]
800076ba:	ae 58       	st.h	r7[0xa],r8
800076bc:	40 58       	lddsp	r8,sp[0x14]
800076be:	ae 68       	st.h	r7[0xc],r8
800076c0:	40 68       	lddsp	r8,sp[0x18]
800076c2:	ae 78       	st.h	r7[0xe],r8
800076c4:	40 88       	lddsp	r8,sp[0x20]
800076c6:	8f 48       	st.w	r7[0x10],r8
800076c8:	40 a8       	lddsp	r8,sp[0x28]
800076ca:	8f b8       	st.w	r7[0x2c],r8
800076cc:	40 c8       	lddsp	r8,sp[0x30]
800076ce:	8f c8       	st.w	r7[0x30],r8
800076d0:	40 d8       	lddsp	r8,sp[0x34]
800076d2:	8f 58       	st.w	r7[0x14],r8
800076d4:	40 e8       	lddsp	r8,sp[0x38]
800076d6:	30 0c       	mov	r12,0
800076d8:	8f 78       	st.w	r7[0x1c],r8
800076da:	40 f8       	lddsp	r8,sp[0x3c]
800076dc:	8f 98       	st.w	r7[0x24],r8
800076de:	2f 0d       	sub	sp,-64
800076e0:	d8 22       	popm	r4-r7,pc
800076e2:	d7 03       	nop

800076e4 <_sbrk>:
800076e4:	d4 01       	pushm	lr
800076e6:	e0 68 0d 80 	mov	r8,3456
800076ea:	70 09       	ld.w	r9,r8[0x0]
800076ec:	58 09       	cp.w	r9,0
800076ee:	c0 41       	brne	800076f6 <_sbrk+0x12>
800076f0:	e0 69 52 e8 	mov	r9,21224
800076f4:	91 09       	st.w	r8[0x0],r9
800076f6:	e0 69 0d 80 	mov	r9,3456
800076fa:	e0 7a 70 00 	mov	r10,94208
800076fe:	72 08       	ld.w	r8,r9[0x0]
80007700:	f0 0c 00 0c 	add	r12,r8,r12
80007704:	14 3c       	cp.w	r12,r10
80007706:	e0 8b 00 04 	brhi	8000770e <_sbrk+0x2a>
8000770a:	93 0c       	st.w	r9[0x0],r12
8000770c:	c0 68       	rjmp	80007718 <_sbrk+0x34>
8000770e:	e0 a0 18 2b 	rcall	8000a764 <__errno>
80007712:	30 c8       	mov	r8,12
80007714:	99 08       	st.w	r12[0x0],r8
80007716:	3f f8       	mov	r8,-1
80007718:	10 9c       	mov	r12,r8
8000771a:	d8 02       	popm	pc

8000771c <get_arg>:
8000771c:	d4 31       	pushm	r0-r7,lr
8000771e:	20 8d       	sub	sp,32
80007720:	fa c4 ff bc 	sub	r4,sp,-68
80007724:	50 4b       	stdsp	sp[0x10],r11
80007726:	68 2e       	ld.w	lr,r4[0x8]
80007728:	50 58       	stdsp	sp[0x14],r8
8000772a:	12 96       	mov	r6,r9
8000772c:	7c 0b       	ld.w	r11,lr[0x0]
8000772e:	70 05       	ld.w	r5,r8[0x0]
80007730:	50 6e       	stdsp	sp[0x18],lr
80007732:	58 0b       	cp.w	r11,0
80007734:	f4 0b 17 00 	moveq	r11,r10
80007738:	68 03       	ld.w	r3,r4[0x0]
8000773a:	68 11       	ld.w	r1,r4[0x4]
8000773c:	40 49       	lddsp	r9,sp[0x10]
8000773e:	30 08       	mov	r8,0
80007740:	c2 e9       	rjmp	8000799c <get_arg+0x280>
80007742:	2f fb       	sub	r11,-1
80007744:	32 5c       	mov	r12,37
80007746:	17 8a       	ld.ub	r10,r11[0x0]
80007748:	f8 0a 18 00 	cp.b	r10,r12
8000774c:	5f 1e       	srne	lr
8000774e:	f0 0a 18 00 	cp.b	r10,r8
80007752:	5f 1c       	srne	r12
80007754:	fd ec 00 0c 	and	r12,lr,r12
80007758:	f0 0c 18 00 	cp.b	r12,r8
8000775c:	cf 31       	brne	80007742 <get_arg+0x26>
8000775e:	58 0a       	cp.w	r10,0
80007760:	e0 80 01 2b 	breq	800079b6 <get_arg+0x29a>
80007764:	30 0c       	mov	r12,0
80007766:	3f fa       	mov	r10,-1
80007768:	18 90       	mov	r0,r12
8000776a:	50 3a       	stdsp	sp[0xc],r10
8000776c:	18 94       	mov	r4,r12
8000776e:	18 92       	mov	r2,r12
80007770:	f8 0c 00 3c 	add	r12,r12,r12<<0x3
80007774:	16 97       	mov	r7,r11
80007776:	50 7c       	stdsp	sp[0x1c],r12
80007778:	4c ec       	lddpc	r12,800078b0 <get_arg+0x194>
8000777a:	0f 3a       	ld.ub	r10,r7++
8000777c:	f8 0a 07 0e 	ld.ub	lr,r12[r10]
80007780:	40 7c       	lddsp	r12,sp[0x1c]
80007782:	1c 0c       	add	r12,lr
80007784:	4c ce       	lddpc	lr,800078b4 <get_arg+0x198>
80007786:	fc 0c 07 0e 	ld.ub	lr,lr[r12]
8000778a:	20 1e       	sub	lr,1
8000778c:	50 0e       	stdsp	sp[0x0],lr
8000778e:	4c be       	lddpc	lr,800078b8 <get_arg+0x19c>
80007790:	fc 0c 07 0c 	ld.ub	r12,lr[r12]
80007794:	50 7c       	stdsp	sp[0x1c],r12
80007796:	40 0c       	lddsp	r12,sp[0x0]
80007798:	58 7c       	cp.w	r12,7
8000779a:	e0 8b 00 fa 	brhi	8000798e <get_arg+0x272>
8000779e:	4c 8e       	lddpc	lr,800078bc <get_arg+0x1a0>
800077a0:	fc 0c 03 2f 	ld.w	pc,lr[r12<<0x2]
800077a4:	36 8b       	mov	r11,104
800077a6:	f6 0a 18 00 	cp.b	r10,r11
800077aa:	e0 80 00 f2 	breq	8000798e <get_arg+0x272>
800077ae:	37 1b       	mov	r11,113
800077b0:	f6 0a 18 00 	cp.b	r10,r11
800077b4:	c0 70       	breq	800077c2 <get_arg+0xa6>
800077b6:	34 cb       	mov	r11,76
800077b8:	f6 0a 18 00 	cp.b	r10,r11
800077bc:	c0 51       	brne	800077c6 <get_arg+0xaa>
800077be:	a3 b4       	sbr	r4,0x3
800077c0:	ce 78       	rjmp	8000798e <get_arg+0x272>
800077c2:	a5 b4       	sbr	r4,0x5
800077c4:	ce 58       	rjmp	8000798e <get_arg+0x272>
800077c6:	08 9a       	mov	r10,r4
800077c8:	0e 9b       	mov	r11,r7
800077ca:	a5 aa       	sbr	r10,0x4
800077cc:	17 3c       	ld.ub	r12,r11++
800077ce:	a5 b4       	sbr	r4,0x5
800077d0:	36 ce       	mov	lr,108
800077d2:	fc 0c 18 00 	cp.b	r12,lr
800077d6:	e0 80 00 dd 	breq	80007990 <get_arg+0x274>
800077da:	14 94       	mov	r4,r10
800077dc:	cd 98       	rjmp	8000798e <get_arg+0x272>
800077de:	eb d5 c0 05 	bfextu	r5,r5,0x0,0x5
800077e2:	36 7c       	mov	r12,103
800077e4:	f8 0a 18 00 	cp.b	r10,r12
800077e8:	e0 8b 00 27 	brhi	80007836 <get_arg+0x11a>
800077ec:	36 5b       	mov	r11,101
800077ee:	f6 0a 18 00 	cp.b	r10,r11
800077f2:	c4 82       	brcc	80007882 <get_arg+0x166>
800077f4:	34 fb       	mov	r11,79
800077f6:	f6 0a 18 00 	cp.b	r10,r11
800077fa:	c4 80       	breq	8000788a <get_arg+0x16e>
800077fc:	e0 8b 00 0c 	brhi	80007814 <get_arg+0xf8>
80007800:	34 5b       	mov	r11,69
80007802:	f6 0a 18 00 	cp.b	r10,r11
80007806:	c3 e0       	breq	80007882 <get_arg+0x166>
80007808:	34 7b       	mov	r11,71
8000780a:	f6 0a 18 00 	cp.b	r10,r11
8000780e:	c3 a0       	breq	80007882 <get_arg+0x166>
80007810:	34 4b       	mov	r11,68
80007812:	c0 88       	rjmp	80007822 <get_arg+0x106>
80007814:	35 8b       	mov	r11,88
80007816:	f6 0a 18 00 	cp.b	r10,r11
8000781a:	c2 c0       	breq	80007872 <get_arg+0x156>
8000781c:	e0 8b 00 07 	brhi	8000782a <get_arg+0x10e>
80007820:	35 5b       	mov	r11,85
80007822:	f6 0a 18 00 	cp.b	r10,r11
80007826:	c3 51       	brne	80007890 <get_arg+0x174>
80007828:	c3 18       	rjmp	8000788a <get_arg+0x16e>
8000782a:	36 3b       	mov	r11,99
8000782c:	f6 0a 18 00 	cp.b	r10,r11
80007830:	c2 f0       	breq	8000788e <get_arg+0x172>
80007832:	36 4b       	mov	r11,100
80007834:	c0 e8       	rjmp	80007850 <get_arg+0x134>
80007836:	37 0b       	mov	r11,112
80007838:	f6 0a 18 00 	cp.b	r10,r11
8000783c:	c2 50       	breq	80007886 <get_arg+0x16a>
8000783e:	e0 8b 00 0d 	brhi	80007858 <get_arg+0x13c>
80007842:	36 eb       	mov	r11,110
80007844:	f6 0a 18 00 	cp.b	r10,r11
80007848:	c1 f0       	breq	80007886 <get_arg+0x16a>
8000784a:	e0 8b 00 14 	brhi	80007872 <get_arg+0x156>
8000784e:	36 9b       	mov	r11,105
80007850:	f6 0a 18 00 	cp.b	r10,r11
80007854:	c1 e1       	brne	80007890 <get_arg+0x174>
80007856:	c0 e8       	rjmp	80007872 <get_arg+0x156>
80007858:	37 5b       	mov	r11,117
8000785a:	f6 0a 18 00 	cp.b	r10,r11
8000785e:	c0 a0       	breq	80007872 <get_arg+0x156>
80007860:	37 8b       	mov	r11,120
80007862:	f6 0a 18 00 	cp.b	r10,r11
80007866:	c0 60       	breq	80007872 <get_arg+0x156>
80007868:	37 3b       	mov	r11,115
8000786a:	f6 0a 18 00 	cp.b	r10,r11
8000786e:	c1 11       	brne	80007890 <get_arg+0x174>
80007870:	c0 b8       	rjmp	80007886 <get_arg+0x16a>
80007872:	ed b4 00 04 	bld	r4,0x4
80007876:	c0 a0       	breq	8000788a <get_arg+0x16e>
80007878:	ed b4 00 05 	bld	r4,0x5
8000787c:	c0 91       	brne	8000788e <get_arg+0x172>
8000787e:	30 20       	mov	r0,2
80007880:	c0 88       	rjmp	80007890 <get_arg+0x174>
80007882:	30 40       	mov	r0,4
80007884:	c0 68       	rjmp	80007890 <get_arg+0x174>
80007886:	30 30       	mov	r0,3
80007888:	c0 48       	rjmp	80007890 <get_arg+0x174>
8000788a:	30 10       	mov	r0,1
8000788c:	c0 28       	rjmp	80007890 <get_arg+0x174>
8000788e:	30 00       	mov	r0,0
80007890:	40 3b       	lddsp	r11,sp[0xc]
80007892:	5b fb       	cp.w	r11,-1
80007894:	c0 40       	breq	8000789c <get_arg+0x180>
80007896:	e2 0b 09 20 	st.w	r1[r11<<0x2],r0
8000789a:	c7 a8       	rjmp	8000798e <get_arg+0x272>
8000789c:	58 60       	cp.w	r0,6
8000789e:	e0 8b 00 78 	brhi	8000798e <get_arg+0x272>
800078a2:	6c 0a       	ld.w	r10,r6[0x0]
800078a4:	ea cc ff ff 	sub	r12,r5,-1
800078a8:	48 6e       	lddpc	lr,800078c0 <get_arg+0x1a4>
800078aa:	fc 00 03 2f 	ld.w	pc,lr[r0<<0x2]
800078ae:	d7 03       	nop
800078b0:	80 01       	ld.sh	r1,r0[0x0]
800078b2:	5d d0       	*unknown*
800078b4:	80 01       	ld.sh	r1,r0[0x0]
800078b6:	5d 08       	ror	r8
800078b8:	80 01       	ld.sh	r1,r0[0x0]
800078ba:	5c 9c       	brev	r12
800078bc:	80 01       	ld.sh	r1,r0[0x0]
800078be:	5a fc       	cp.w	r12,-17
800078c0:	80 01       	ld.sh	r1,r0[0x0]
800078c2:	5b 1c       	cp.w	r12,-15
800078c4:	f4 cb ff f8 	sub	r11,r10,-8
800078c8:	8d 0b       	st.w	r6[0x0],r11
800078ca:	f4 ea 00 00 	ld.d	r10,r10[0]
800078ce:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
800078d2:	c0 f8       	rjmp	800078f0 <get_arg+0x1d4>
800078d4:	f4 cb ff fc 	sub	r11,r10,-4
800078d8:	8d 0b       	st.w	r6[0x0],r11
800078da:	74 0a       	ld.w	r10,r10[0x0]
800078dc:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
800078e0:	c0 88       	rjmp	800078f0 <get_arg+0x1d4>
800078e2:	f4 cb ff f8 	sub	r11,r10,-8
800078e6:	8d 0b       	st.w	r6[0x0],r11
800078e8:	f4 ea 00 00 	ld.d	r10,r10[0]
800078ec:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
800078f0:	0e 9b       	mov	r11,r7
800078f2:	18 95       	mov	r5,r12
800078f4:	c4 e8       	rjmp	80007990 <get_arg+0x274>
800078f6:	62 0a       	ld.w	r10,r1[0x0]
800078f8:	5b fa       	cp.w	r10,-1
800078fa:	c0 b1       	brne	80007910 <get_arg+0x1f4>
800078fc:	50 19       	stdsp	sp[0x4],r9
800078fe:	50 28       	stdsp	sp[0x8],r8
80007900:	e0 6a 00 80 	mov	r10,128
80007904:	30 0b       	mov	r11,0
80007906:	02 9c       	mov	r12,r1
80007908:	fe b0 fc e7 	rcall	800072d6 <memset>
8000790c:	40 28       	lddsp	r8,sp[0x8]
8000790e:	40 19       	lddsp	r9,sp[0x4]
80007910:	e4 cc 00 01 	sub	r12,r2,1
80007914:	0e 9b       	mov	r11,r7
80007916:	50 3c       	stdsp	sp[0xc],r12
80007918:	f2 0c 0c 49 	max	r9,r9,r12
8000791c:	c3 a8       	rjmp	80007990 <get_arg+0x274>
8000791e:	62 0a       	ld.w	r10,r1[0x0]
80007920:	5b fa       	cp.w	r10,-1
80007922:	c0 b1       	brne	80007938 <get_arg+0x21c>
80007924:	50 19       	stdsp	sp[0x4],r9
80007926:	50 28       	stdsp	sp[0x8],r8
80007928:	e0 6a 00 80 	mov	r10,128
8000792c:	30 0b       	mov	r11,0
8000792e:	02 9c       	mov	r12,r1
80007930:	fe b0 fc d3 	rcall	800072d6 <memset>
80007934:	40 28       	lddsp	r8,sp[0x8]
80007936:	40 19       	lddsp	r9,sp[0x4]
80007938:	20 12       	sub	r2,1
8000793a:	30 0a       	mov	r10,0
8000793c:	0e 9b       	mov	r11,r7
8000793e:	e2 02 09 2a 	st.w	r1[r2<<0x2],r10
80007942:	f2 02 0c 49 	max	r9,r9,r2
80007946:	c2 58       	rjmp	80007990 <get_arg+0x274>
80007948:	16 97       	mov	r7,r11
8000794a:	6c 0a       	ld.w	r10,r6[0x0]
8000794c:	f4 cb ff fc 	sub	r11,r10,-4
80007950:	8d 0b       	st.w	r6[0x0],r11
80007952:	74 0a       	ld.w	r10,r10[0x0]
80007954:	0e 9b       	mov	r11,r7
80007956:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
8000795a:	2f f5       	sub	r5,-1
8000795c:	c1 a8       	rjmp	80007990 <get_arg+0x274>
8000795e:	f4 c2 00 30 	sub	r2,r10,48
80007962:	c0 68       	rjmp	8000796e <get_arg+0x252>
80007964:	e4 02 00 22 	add	r2,r2,r2<<0x2
80007968:	2f f7       	sub	r7,-1
8000796a:	f4 02 00 12 	add	r2,r10,r2<<0x1
8000796e:	0f 8a       	ld.ub	r10,r7[0x0]
80007970:	58 0a       	cp.w	r10,0
80007972:	c0 e0       	breq	8000798e <get_arg+0x272>
80007974:	23 0a       	sub	r10,48
80007976:	58 9a       	cp.w	r10,9
80007978:	fe 98 ff f6 	brls	80007964 <get_arg+0x248>
8000797c:	c0 98       	rjmp	8000798e <get_arg+0x272>
8000797e:	2f f7       	sub	r7,-1
80007980:	0f 8a       	ld.ub	r10,r7[0x0]
80007982:	58 0a       	cp.w	r10,0
80007984:	c0 50       	breq	8000798e <get_arg+0x272>
80007986:	23 0a       	sub	r10,48
80007988:	58 9a       	cp.w	r10,9
8000798a:	fe 98 ff fa 	brls	8000797e <get_arg+0x262>
8000798e:	0e 9b       	mov	r11,r7
80007990:	40 7c       	lddsp	r12,sp[0x1c]
80007992:	30 ba       	mov	r10,11
80007994:	f4 0c 18 00 	cp.b	r12,r10
80007998:	fe 91 fe ec 	brne	80007770 <get_arg+0x54>
8000799c:	40 42       	lddsp	r2,sp[0x10]
8000799e:	17 8c       	ld.ub	r12,r11[0x0]
800079a0:	0a 32       	cp.w	r2,r5
800079a2:	5f 4a       	srge	r10
800079a4:	f0 0c 18 00 	cp.b	r12,r8
800079a8:	5f 1c       	srne	r12
800079aa:	f9 ea 00 0a 	and	r10,r12,r10
800079ae:	f0 0a 18 00 	cp.b	r10,r8
800079b2:	fe 91 fe c9 	brne	80007744 <get_arg+0x28>
800079b6:	30 08       	mov	r8,0
800079b8:	40 4e       	lddsp	lr,sp[0x10]
800079ba:	17 8a       	ld.ub	r10,r11[0x0]
800079bc:	e2 05 00 21 	add	r1,r1,r5<<0x2
800079c0:	f0 0a 18 00 	cp.b	r10,r8
800079c4:	fc 09 17 10 	movne	r9,lr
800079c8:	e6 05 00 38 	add	r8,r3,r5<<0x3
800079cc:	06 9e       	mov	lr,r3
800079ce:	c2 a8       	rjmp	80007a22 <get_arg+0x306>
800079d0:	62 0a       	ld.w	r10,r1[0x0]
800079d2:	58 3a       	cp.w	r10,3
800079d4:	c1 e0       	breq	80007a10 <get_arg+0x2f4>
800079d6:	e0 89 00 07 	brgt	800079e4 <get_arg+0x2c8>
800079da:	58 1a       	cp.w	r10,1
800079dc:	c1 a0       	breq	80007a10 <get_arg+0x2f4>
800079de:	58 2a       	cp.w	r10,2
800079e0:	c1 81       	brne	80007a10 <get_arg+0x2f4>
800079e2:	c0 58       	rjmp	800079ec <get_arg+0x2d0>
800079e4:	58 5a       	cp.w	r10,5
800079e6:	c0 c0       	breq	800079fe <get_arg+0x2e2>
800079e8:	c0 b5       	brlt	800079fe <get_arg+0x2e2>
800079ea:	c1 38       	rjmp	80007a10 <get_arg+0x2f4>
800079ec:	6c 0a       	ld.w	r10,r6[0x0]
800079ee:	f4 cc ff f8 	sub	r12,r10,-8
800079f2:	8d 0c       	st.w	r6[0x0],r12
800079f4:	f4 e2 00 00 	ld.d	r2,r10[0]
800079f8:	f0 e3 00 00 	st.d	r8[0],r2
800079fc:	c1 08       	rjmp	80007a1c <get_arg+0x300>
800079fe:	6c 0a       	ld.w	r10,r6[0x0]
80007a00:	f4 cc ff f8 	sub	r12,r10,-8
80007a04:	8d 0c       	st.w	r6[0x0],r12
80007a06:	f4 e2 00 00 	ld.d	r2,r10[0]
80007a0a:	f0 e3 00 00 	st.d	r8[0],r2
80007a0e:	c0 78       	rjmp	80007a1c <get_arg+0x300>
80007a10:	6c 0a       	ld.w	r10,r6[0x0]
80007a12:	f4 cc ff fc 	sub	r12,r10,-4
80007a16:	8d 0c       	st.w	r6[0x0],r12
80007a18:	74 0a       	ld.w	r10,r10[0x0]
80007a1a:	91 0a       	st.w	r8[0x0],r10
80007a1c:	2f f5       	sub	r5,-1
80007a1e:	2f 88       	sub	r8,-8
80007a20:	2f c1       	sub	r1,-4
80007a22:	12 35       	cp.w	r5,r9
80007a24:	fe 9a ff d6 	brle	800079d0 <get_arg+0x2b4>
80007a28:	1c 93       	mov	r3,lr
80007a2a:	40 52       	lddsp	r2,sp[0x14]
80007a2c:	40 6e       	lddsp	lr,sp[0x18]
80007a2e:	85 05       	st.w	r2[0x0],r5
80007a30:	9d 0b       	st.w	lr[0x0],r11
80007a32:	40 4b       	lddsp	r11,sp[0x10]
80007a34:	e6 0b 00 3c 	add	r12,r3,r11<<0x3
80007a38:	2f 8d       	sub	sp,-32
80007a3a:	d8 32       	popm	r0-r7,pc

80007a3c <__sprint_r>:
80007a3c:	d4 21       	pushm	r4-r7,lr
80007a3e:	14 97       	mov	r7,r10
80007a40:	74 28       	ld.w	r8,r10[0x8]
80007a42:	58 08       	cp.w	r8,0
80007a44:	c0 41       	brne	80007a4c <__sprint_r+0x10>
80007a46:	95 18       	st.w	r10[0x4],r8
80007a48:	10 9c       	mov	r12,r8
80007a4a:	d8 22       	popm	r4-r7,pc
80007a4c:	e0 a0 18 ce 	rcall	8000abe8 <__sfvwrite_r>
80007a50:	30 08       	mov	r8,0
80007a52:	8f 18       	st.w	r7[0x4],r8
80007a54:	8f 28       	st.w	r7[0x8],r8
80007a56:	d8 22       	popm	r4-r7,pc

80007a58 <_vfprintf_r>:
80007a58:	d4 31       	pushm	r0-r7,lr
80007a5a:	fa cd 06 bc 	sub	sp,sp,1724
80007a5e:	51 09       	stdsp	sp[0x40],r9
80007a60:	16 91       	mov	r1,r11
80007a62:	14 97       	mov	r7,r10
80007a64:	18 95       	mov	r5,r12
80007a66:	e0 a0 1a 31 	rcall	8000aec8 <_localeconv_r>
80007a6a:	78 0c       	ld.w	r12,r12[0x0]
80007a6c:	50 cc       	stdsp	sp[0x30],r12
80007a6e:	58 05       	cp.w	r5,0
80007a70:	c0 70       	breq	80007a7e <_vfprintf_r+0x26>
80007a72:	6a 68       	ld.w	r8,r5[0x18]
80007a74:	58 08       	cp.w	r8,0
80007a76:	c0 41       	brne	80007a7e <_vfprintf_r+0x26>
80007a78:	0a 9c       	mov	r12,r5
80007a7a:	e0 a0 17 57 	rcall	8000a928 <__sinit>
80007a7e:	4d 08       	lddpc	r8,80007bbc <_vfprintf_r+0x164>
80007a80:	10 31       	cp.w	r1,r8
80007a82:	c0 31       	brne	80007a88 <_vfprintf_r+0x30>
80007a84:	6a 01       	ld.w	r1,r5[0x0]
80007a86:	c0 a8       	rjmp	80007a9a <_vfprintf_r+0x42>
80007a88:	4c e8       	lddpc	r8,80007bc0 <_vfprintf_r+0x168>
80007a8a:	10 31       	cp.w	r1,r8
80007a8c:	c0 31       	brne	80007a92 <_vfprintf_r+0x3a>
80007a8e:	6a 11       	ld.w	r1,r5[0x4]
80007a90:	c0 58       	rjmp	80007a9a <_vfprintf_r+0x42>
80007a92:	4c d8       	lddpc	r8,80007bc4 <_vfprintf_r+0x16c>
80007a94:	10 31       	cp.w	r1,r8
80007a96:	eb f1 00 02 	ld.weq	r1,r5[0x8]
80007a9a:	82 68       	ld.sh	r8,r1[0xc]
80007a9c:	ed b8 00 03 	bld	r8,0x3
80007aa0:	c0 41       	brne	80007aa8 <_vfprintf_r+0x50>
80007aa2:	62 48       	ld.w	r8,r1[0x10]
80007aa4:	58 08       	cp.w	r8,0
80007aa6:	c0 71       	brne	80007ab4 <_vfprintf_r+0x5c>
80007aa8:	02 9b       	mov	r11,r1
80007aaa:	0a 9c       	mov	r12,r5
80007aac:	e0 a0 0f 6c 	rcall	80009984 <__swsetup_r>
80007ab0:	e0 81 0f 63 	brne	80009976 <_vfprintf_r+0x1f1e>
80007ab4:	82 68       	ld.sh	r8,r1[0xc]
80007ab6:	10 99       	mov	r9,r8
80007ab8:	e2 19 00 1a 	andl	r9,0x1a,COH
80007abc:	58 a9       	cp.w	r9,10
80007abe:	c3 c1       	brne	80007b36 <_vfprintf_r+0xde>
80007ac0:	82 79       	ld.sh	r9,r1[0xe]
80007ac2:	30 0a       	mov	r10,0
80007ac4:	f4 09 19 00 	cp.h	r9,r10
80007ac8:	c3 75       	brlt	80007b36 <_vfprintf_r+0xde>
80007aca:	a1 d8       	cbr	r8,0x1
80007acc:	fb 58 05 d0 	st.h	sp[1488],r8
80007ad0:	62 88       	ld.w	r8,r1[0x20]
80007ad2:	fb 48 05 e4 	st.w	sp[1508],r8
80007ad6:	62 a8       	ld.w	r8,r1[0x28]
80007ad8:	fb 48 05 ec 	st.w	sp[1516],r8
80007adc:	fa c8 ff bc 	sub	r8,sp,-68
80007ae0:	fb 48 05 d4 	st.w	sp[1492],r8
80007ae4:	fb 48 05 c4 	st.w	sp[1476],r8
80007ae8:	e0 68 04 00 	mov	r8,1024
80007aec:	fb 48 05 d8 	st.w	sp[1496],r8
80007af0:	fb 48 05 cc 	st.w	sp[1484],r8
80007af4:	30 08       	mov	r8,0
80007af6:	fb 59 05 d2 	st.h	sp[1490],r9
80007afa:	0e 9a       	mov	r10,r7
80007afc:	41 09       	lddsp	r9,sp[0x40]
80007afe:	fa c7 fa 3c 	sub	r7,sp,-1476
80007b02:	fb 48 05 dc 	st.w	sp[1500],r8
80007b06:	0a 9c       	mov	r12,r5
80007b08:	0e 9b       	mov	r11,r7
80007b0a:	ca 7f       	rcall	80007a58 <_vfprintf_r>
80007b0c:	50 bc       	stdsp	sp[0x2c],r12
80007b0e:	c0 95       	brlt	80007b20 <_vfprintf_r+0xc8>
80007b10:	0e 9b       	mov	r11,r7
80007b12:	0a 9c       	mov	r12,r5
80007b14:	e0 a0 16 2e 	rcall	8000a770 <_fflush_r>
80007b18:	40 be       	lddsp	lr,sp[0x2c]
80007b1a:	f9 be 01 ff 	movne	lr,-1
80007b1e:	50 be       	stdsp	sp[0x2c],lr
80007b20:	fb 08 05 d0 	ld.sh	r8,sp[1488]
80007b24:	ed b8 00 06 	bld	r8,0x6
80007b28:	e0 81 0f 29 	brne	8000997a <_vfprintf_r+0x1f22>
80007b2c:	82 68       	ld.sh	r8,r1[0xc]
80007b2e:	a7 a8       	sbr	r8,0x6
80007b30:	a2 68       	st.h	r1[0xc],r8
80007b32:	e0 8f 0f 24 	bral	8000997a <_vfprintf_r+0x1f22>
80007b36:	30 08       	mov	r8,0
80007b38:	fb 48 06 b4 	st.w	sp[1716],r8
80007b3c:	fb 48 06 90 	st.w	sp[1680],r8
80007b40:	fb 48 06 8c 	st.w	sp[1676],r8
80007b44:	fb 48 06 b0 	st.w	sp[1712],r8
80007b48:	30 08       	mov	r8,0
80007b4a:	30 09       	mov	r9,0
80007b4c:	50 a7       	stdsp	sp[0x28],r7
80007b4e:	50 78       	stdsp	sp[0x1c],r8
80007b50:	fa c3 f9 e0 	sub	r3,sp,-1568
80007b54:	3f f8       	mov	r8,-1
80007b56:	50 59       	stdsp	sp[0x14],r9
80007b58:	fb 43 06 88 	st.w	sp[1672],r3
80007b5c:	fb 48 05 44 	st.w	sp[1348],r8
80007b60:	12 9c       	mov	r12,r9
80007b62:	50 69       	stdsp	sp[0x18],r9
80007b64:	50 d9       	stdsp	sp[0x34],r9
80007b66:	50 e9       	stdsp	sp[0x38],r9
80007b68:	50 b9       	stdsp	sp[0x2c],r9
80007b6a:	12 97       	mov	r7,r9
80007b6c:	0a 94       	mov	r4,r5
80007b6e:	40 a2       	lddsp	r2,sp[0x28]
80007b70:	32 5a       	mov	r10,37
80007b72:	30 08       	mov	r8,0
80007b74:	c0 28       	rjmp	80007b78 <_vfprintf_r+0x120>
80007b76:	2f f2       	sub	r2,-1
80007b78:	05 89       	ld.ub	r9,r2[0x0]
80007b7a:	f0 09 18 00 	cp.b	r9,r8
80007b7e:	5f 1b       	srne	r11
80007b80:	f4 09 18 00 	cp.b	r9,r10
80007b84:	5f 19       	srne	r9
80007b86:	f3 eb 00 0b 	and	r11,r9,r11
80007b8a:	f0 0b 18 00 	cp.b	r11,r8
80007b8e:	cf 41       	brne	80007b76 <_vfprintf_r+0x11e>
80007b90:	40 ab       	lddsp	r11,sp[0x28]
80007b92:	e4 0b 01 06 	sub	r6,r2,r11
80007b96:	c2 50       	breq	80007be0 <_vfprintf_r+0x188>
80007b98:	fa f8 06 90 	ld.w	r8,sp[1680]
80007b9c:	0c 08       	add	r8,r6
80007b9e:	87 0b       	st.w	r3[0x0],r11
80007ba0:	fb 48 06 90 	st.w	sp[1680],r8
80007ba4:	87 16       	st.w	r3[0x4],r6
80007ba6:	fa f8 06 8c 	ld.w	r8,sp[1676]
80007baa:	2f f8       	sub	r8,-1
80007bac:	fb 48 06 8c 	st.w	sp[1676],r8
80007bb0:	58 78       	cp.w	r8,7
80007bb2:	e0 89 00 0b 	brgt	80007bc8 <_vfprintf_r+0x170>
80007bb6:	2f 83       	sub	r3,-8
80007bb8:	c1 18       	rjmp	80007bda <_vfprintf_r+0x182>
80007bba:	d7 03       	nop
80007bbc:	80 01       	ld.sh	r1,r0[0x0]
80007bbe:	5e e0       	retqs	r0
80007bc0:	80 01       	ld.sh	r1,r0[0x0]
80007bc2:	5f 00       	sreq	r0
80007bc4:	80 01       	ld.sh	r1,r0[0x0]
80007bc6:	5f 20       	srhs	r0
80007bc8:	fa ca f9 78 	sub	r10,sp,-1672
80007bcc:	02 9b       	mov	r11,r1
80007bce:	08 9c       	mov	r12,r4
80007bd0:	c3 6f       	rcall	80007a3c <__sprint_r>
80007bd2:	e0 81 0e ce 	brne	8000996e <_vfprintf_r+0x1f16>
80007bd6:	fa c3 f9 e0 	sub	r3,sp,-1568
80007bda:	40 ba       	lddsp	r10,sp[0x2c]
80007bdc:	0c 0a       	add	r10,r6
80007bde:	50 ba       	stdsp	sp[0x2c],r10
80007be0:	05 89       	ld.ub	r9,r2[0x0]
80007be2:	30 08       	mov	r8,0
80007be4:	f0 09 18 00 	cp.b	r9,r8
80007be8:	e0 80 0e b2 	breq	8000994c <_vfprintf_r+0x1ef4>
80007bec:	30 09       	mov	r9,0
80007bee:	fb 68 06 bb 	st.b	sp[1723],r8
80007bf2:	0e 96       	mov	r6,r7
80007bf4:	e4 c8 ff ff 	sub	r8,r2,-1
80007bf8:	3f fe       	mov	lr,-1
80007bfa:	50 93       	stdsp	sp[0x24],r3
80007bfc:	50 41       	stdsp	sp[0x10],r1
80007bfe:	0e 93       	mov	r3,r7
80007c00:	04 91       	mov	r1,r2
80007c02:	50 89       	stdsp	sp[0x20],r9
80007c04:	50 a8       	stdsp	sp[0x28],r8
80007c06:	50 2e       	stdsp	sp[0x8],lr
80007c08:	50 39       	stdsp	sp[0xc],r9
80007c0a:	12 95       	mov	r5,r9
80007c0c:	12 90       	mov	r0,r9
80007c0e:	10 97       	mov	r7,r8
80007c10:	08 92       	mov	r2,r4
80007c12:	c0 78       	rjmp	80007c20 <_vfprintf_r+0x1c8>
80007c14:	3f fc       	mov	r12,-1
80007c16:	08 97       	mov	r7,r4
80007c18:	50 2c       	stdsp	sp[0x8],r12
80007c1a:	c0 38       	rjmp	80007c20 <_vfprintf_r+0x1c8>
80007c1c:	30 0b       	mov	r11,0
80007c1e:	50 3b       	stdsp	sp[0xc],r11
80007c20:	0f 38       	ld.ub	r8,r7++
80007c22:	c0 28       	rjmp	80007c26 <_vfprintf_r+0x1ce>
80007c24:	12 90       	mov	r0,r9
80007c26:	f0 c9 00 20 	sub	r9,r8,32
80007c2a:	e0 49 00 58 	cp.w	r9,88
80007c2e:	e0 8b 0a 36 	brhi	8000909a <_vfprintf_r+0x1642>
80007c32:	4d 9a       	lddpc	r10,80007d94 <_vfprintf_r+0x33c>
80007c34:	f4 09 03 2f 	ld.w	pc,r10[r9<<0x2]
80007c38:	50 a7       	stdsp	sp[0x28],r7
80007c3a:	50 80       	stdsp	sp[0x20],r0
80007c3c:	0c 97       	mov	r7,r6
80007c3e:	04 94       	mov	r4,r2
80007c40:	06 96       	mov	r6,r3
80007c42:	02 92       	mov	r2,r1
80007c44:	4d 59       	lddpc	r9,80007d98 <_vfprintf_r+0x340>
80007c46:	40 93       	lddsp	r3,sp[0x24]
80007c48:	10 90       	mov	r0,r8
80007c4a:	40 41       	lddsp	r1,sp[0x10]
80007c4c:	50 d9       	stdsp	sp[0x34],r9
80007c4e:	e0 8f 08 95 	bral	80008d78 <_vfprintf_r+0x1320>
80007c52:	30 08       	mov	r8,0
80007c54:	fb 39 06 bb 	ld.ub	r9,sp[1723]
80007c58:	f0 09 18 00 	cp.b	r9,r8
80007c5c:	ce 21       	brne	80007c20 <_vfprintf_r+0x1c8>
80007c5e:	32 08       	mov	r8,32
80007c60:	c6 e8       	rjmp	80007d3c <_vfprintf_r+0x2e4>
80007c62:	a1 a5       	sbr	r5,0x0
80007c64:	cd eb       	rjmp	80007c20 <_vfprintf_r+0x1c8>
80007c66:	0f 89       	ld.ub	r9,r7[0x0]
80007c68:	f2 c8 00 30 	sub	r8,r9,48
80007c6c:	58 98       	cp.w	r8,9
80007c6e:	e0 8b 00 1d 	brhi	80007ca8 <_vfprintf_r+0x250>
80007c72:	ee c8 ff ff 	sub	r8,r7,-1
80007c76:	30 0b       	mov	r11,0
80007c78:	23 09       	sub	r9,48
80007c7a:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
80007c7e:	f2 0b 00 1b 	add	r11,r9,r11<<0x1
80007c82:	11 39       	ld.ub	r9,r8++
80007c84:	f2 ca 00 30 	sub	r10,r9,48
80007c88:	58 9a       	cp.w	r10,9
80007c8a:	fe 98 ff f7 	brls	80007c78 <_vfprintf_r+0x220>
80007c8e:	e0 49 00 24 	cp.w	r9,36
80007c92:	cc 51       	brne	80007c1c <_vfprintf_r+0x1c4>
80007c94:	e0 4b 00 20 	cp.w	r11,32
80007c98:	e0 89 0e 6a 	brgt	8000996c <_vfprintf_r+0x1f14>
80007c9c:	20 1b       	sub	r11,1
80007c9e:	fa f9 06 b4 	ld.w	r9,sp[1716]
80007ca2:	12 3b       	cp.w	r11,r9
80007ca4:	c0 95       	brlt	80007cb6 <_vfprintf_r+0x25e>
80007ca6:	c1 08       	rjmp	80007cc6 <_vfprintf_r+0x26e>
80007ca8:	fa f9 06 b4 	ld.w	r9,sp[1716]
80007cac:	ec ca ff ff 	sub	r10,r6,-1
80007cb0:	12 36       	cp.w	r6,r9
80007cb2:	c1 f5       	brlt	80007cf0 <_vfprintf_r+0x298>
80007cb4:	c2 68       	rjmp	80007d00 <_vfprintf_r+0x2a8>
80007cb6:	fa ce f9 44 	sub	lr,sp,-1724
80007cba:	10 97       	mov	r7,r8
80007cbc:	fc 0b 00 3b 	add	r11,lr,r11<<0x3
80007cc0:	f6 f0 fd 88 	ld.w	r0,r11[-632]
80007cc4:	c3 58       	rjmp	80007d2e <_vfprintf_r+0x2d6>
80007cc6:	10 97       	mov	r7,r8
80007cc8:	fa c8 f9 50 	sub	r8,sp,-1712
80007ccc:	1a d8       	st.w	--sp,r8
80007cce:	fa c8 fa b8 	sub	r8,sp,-1352
80007cd2:	1a d8       	st.w	--sp,r8
80007cd4:	fa c8 fb b4 	sub	r8,sp,-1100
80007cd8:	02 9a       	mov	r10,r1
80007cda:	1a d8       	st.w	--sp,r8
80007cdc:	04 9c       	mov	r12,r2
80007cde:	fa c8 f9 40 	sub	r8,sp,-1728
80007ce2:	fa c9 ff b4 	sub	r9,sp,-76
80007ce6:	fe b0 fd 1b 	rcall	8000771c <get_arg>
80007cea:	2f dd       	sub	sp,-12
80007cec:	78 00       	ld.w	r0,r12[0x0]
80007cee:	c2 08       	rjmp	80007d2e <_vfprintf_r+0x2d6>
80007cf0:	fa cc f9 44 	sub	r12,sp,-1724
80007cf4:	14 96       	mov	r6,r10
80007cf6:	f8 03 00 38 	add	r8,r12,r3<<0x3
80007cfa:	f0 f0 fd 88 	ld.w	r0,r8[-632]
80007cfe:	c1 88       	rjmp	80007d2e <_vfprintf_r+0x2d6>
80007d00:	41 08       	lddsp	r8,sp[0x40]
80007d02:	59 f9       	cp.w	r9,31
80007d04:	e0 89 00 11 	brgt	80007d26 <_vfprintf_r+0x2ce>
80007d08:	f0 cb ff fc 	sub	r11,r8,-4
80007d0c:	51 0b       	stdsp	sp[0x40],r11
80007d0e:	70 00       	ld.w	r0,r8[0x0]
80007d10:	fa cb f9 44 	sub	r11,sp,-1724
80007d14:	f6 09 00 38 	add	r8,r11,r9<<0x3
80007d18:	f1 40 fd 88 	st.w	r8[-632],r0
80007d1c:	2f f9       	sub	r9,-1
80007d1e:	14 96       	mov	r6,r10
80007d20:	fb 49 06 b4 	st.w	sp[1716],r9
80007d24:	c0 58       	rjmp	80007d2e <_vfprintf_r+0x2d6>
80007d26:	70 00       	ld.w	r0,r8[0x0]
80007d28:	14 96       	mov	r6,r10
80007d2a:	2f c8       	sub	r8,-4
80007d2c:	51 08       	stdsp	sp[0x40],r8
80007d2e:	58 00       	cp.w	r0,0
80007d30:	fe 94 ff 78 	brge	80007c20 <_vfprintf_r+0x1c8>
80007d34:	5c 30       	neg	r0
80007d36:	a3 a5       	sbr	r5,0x2
80007d38:	c7 4b       	rjmp	80007c20 <_vfprintf_r+0x1c8>
80007d3a:	32 b8       	mov	r8,43
80007d3c:	fb 68 06 bb 	st.b	sp[1723],r8
80007d40:	c7 0b       	rjmp	80007c20 <_vfprintf_r+0x1c8>
80007d42:	0f 38       	ld.ub	r8,r7++
80007d44:	e0 48 00 2a 	cp.w	r8,42
80007d48:	c0 30       	breq	80007d4e <_vfprintf_r+0x2f6>
80007d4a:	30 09       	mov	r9,0
80007d4c:	c7 d8       	rjmp	80007e46 <_vfprintf_r+0x3ee>
80007d4e:	0f 88       	ld.ub	r8,r7[0x0]
80007d50:	f0 c9 00 30 	sub	r9,r8,48
80007d54:	58 99       	cp.w	r9,9
80007d56:	e0 8b 00 23 	brhi	80007d9c <_vfprintf_r+0x344>
80007d5a:	ee c4 ff ff 	sub	r4,r7,-1
80007d5e:	30 0b       	mov	r11,0
80007d60:	23 08       	sub	r8,48
80007d62:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
80007d66:	f0 0b 00 1b 	add	r11,r8,r11<<0x1
80007d6a:	09 38       	ld.ub	r8,r4++
80007d6c:	f0 c9 00 30 	sub	r9,r8,48
80007d70:	58 99       	cp.w	r9,9
80007d72:	fe 98 ff f7 	brls	80007d60 <_vfprintf_r+0x308>
80007d76:	e0 48 00 24 	cp.w	r8,36
80007d7a:	fe 91 ff 51 	brne	80007c1c <_vfprintf_r+0x1c4>
80007d7e:	e0 4b 00 20 	cp.w	r11,32
80007d82:	e0 89 0d f5 	brgt	8000996c <_vfprintf_r+0x1f14>
80007d86:	20 1b       	sub	r11,1
80007d88:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007d8c:	10 3b       	cp.w	r11,r8
80007d8e:	c0 e5       	brlt	80007daa <_vfprintf_r+0x352>
80007d90:	c1 58       	rjmp	80007dba <_vfprintf_r+0x362>
80007d92:	d7 03       	nop
80007d94:	80 01       	ld.sh	r1,r0[0x0]
80007d96:	5b 38       	cp.w	r8,-13
80007d98:	80 01       	ld.sh	r1,r0[0x0]
80007d9a:	5d 74       	*unknown*
80007d9c:	fa fa 06 b4 	ld.w	r10,sp[1716]
80007da0:	ec c9 ff ff 	sub	r9,r6,-1
80007da4:	14 36       	cp.w	r6,r10
80007da6:	c1 f5       	brlt	80007de4 <_vfprintf_r+0x38c>
80007da8:	c2 88       	rjmp	80007df8 <_vfprintf_r+0x3a0>
80007daa:	fa ca f9 44 	sub	r10,sp,-1724
80007dae:	f4 0b 00 3b 	add	r11,r10,r11<<0x3
80007db2:	f6 fb fd 88 	ld.w	r11,r11[-632]
80007db6:	50 2b       	stdsp	sp[0x8],r11
80007db8:	c3 c8       	rjmp	80007e30 <_vfprintf_r+0x3d8>
80007dba:	fa c8 f9 50 	sub	r8,sp,-1712
80007dbe:	1a d8       	st.w	--sp,r8
80007dc0:	fa c8 fa b8 	sub	r8,sp,-1352
80007dc4:	1a d8       	st.w	--sp,r8
80007dc6:	fa c8 fb b4 	sub	r8,sp,-1100
80007dca:	02 9a       	mov	r10,r1
80007dcc:	1a d8       	st.w	--sp,r8
80007dce:	04 9c       	mov	r12,r2
80007dd0:	fa c8 f9 40 	sub	r8,sp,-1728
80007dd4:	fa c9 ff b4 	sub	r9,sp,-76
80007dd8:	fe b0 fc a2 	rcall	8000771c <get_arg>
80007ddc:	2f dd       	sub	sp,-12
80007dde:	78 0c       	ld.w	r12,r12[0x0]
80007de0:	50 2c       	stdsp	sp[0x8],r12
80007de2:	c2 78       	rjmp	80007e30 <_vfprintf_r+0x3d8>
80007de4:	12 96       	mov	r6,r9
80007de6:	0e 94       	mov	r4,r7
80007de8:	fa c9 f9 44 	sub	r9,sp,-1724
80007dec:	f2 03 00 38 	add	r8,r9,r3<<0x3
80007df0:	f0 f8 fd 88 	ld.w	r8,r8[-632]
80007df4:	50 28       	stdsp	sp[0x8],r8
80007df6:	c1 d8       	rjmp	80007e30 <_vfprintf_r+0x3d8>
80007df8:	41 08       	lddsp	r8,sp[0x40]
80007dfa:	59 fa       	cp.w	r10,31
80007dfc:	e0 89 00 14 	brgt	80007e24 <_vfprintf_r+0x3cc>
80007e00:	f0 cb ff fc 	sub	r11,r8,-4
80007e04:	70 08       	ld.w	r8,r8[0x0]
80007e06:	51 0b       	stdsp	sp[0x40],r11
80007e08:	50 28       	stdsp	sp[0x8],r8
80007e0a:	fa c6 f9 44 	sub	r6,sp,-1724
80007e0e:	40 2e       	lddsp	lr,sp[0x8]
80007e10:	ec 0a 00 38 	add	r8,r6,r10<<0x3
80007e14:	f1 4e fd 88 	st.w	r8[-632],lr
80007e18:	2f fa       	sub	r10,-1
80007e1a:	0e 94       	mov	r4,r7
80007e1c:	fb 4a 06 b4 	st.w	sp[1716],r10
80007e20:	12 96       	mov	r6,r9
80007e22:	c0 78       	rjmp	80007e30 <_vfprintf_r+0x3d8>
80007e24:	70 0c       	ld.w	r12,r8[0x0]
80007e26:	0e 94       	mov	r4,r7
80007e28:	2f c8       	sub	r8,-4
80007e2a:	50 2c       	stdsp	sp[0x8],r12
80007e2c:	12 96       	mov	r6,r9
80007e2e:	51 08       	stdsp	sp[0x40],r8
80007e30:	40 2b       	lddsp	r11,sp[0x8]
80007e32:	58 0b       	cp.w	r11,0
80007e34:	fe 95 fe f0 	brlt	80007c14 <_vfprintf_r+0x1bc>
80007e38:	08 97       	mov	r7,r4
80007e3a:	cf 3a       	rjmp	80007c20 <_vfprintf_r+0x1c8>
80007e3c:	f2 09 00 29 	add	r9,r9,r9<<0x2
80007e40:	0f 38       	ld.ub	r8,r7++
80007e42:	f4 09 00 19 	add	r9,r10,r9<<0x1
80007e46:	f0 ca 00 30 	sub	r10,r8,48
80007e4a:	58 9a       	cp.w	r10,9
80007e4c:	fe 98 ff f8 	brls	80007e3c <_vfprintf_r+0x3e4>
80007e50:	3f fa       	mov	r10,-1
80007e52:	f2 0a 0c 49 	max	r9,r9,r10
80007e56:	50 29       	stdsp	sp[0x8],r9
80007e58:	ce 7a       	rjmp	80007c26 <_vfprintf_r+0x1ce>
80007e5a:	a7 b5       	sbr	r5,0x7
80007e5c:	ce 2a       	rjmp	80007c20 <_vfprintf_r+0x1c8>
80007e5e:	30 09       	mov	r9,0
80007e60:	23 08       	sub	r8,48
80007e62:	f2 09 00 29 	add	r9,r9,r9<<0x2
80007e66:	f0 09 00 19 	add	r9,r8,r9<<0x1
80007e6a:	0f 38       	ld.ub	r8,r7++
80007e6c:	f0 ca 00 30 	sub	r10,r8,48
80007e70:	58 9a       	cp.w	r10,9
80007e72:	fe 98 ff f7 	brls	80007e60 <_vfprintf_r+0x408>
80007e76:	e0 48 00 24 	cp.w	r8,36
80007e7a:	fe 91 fe d5 	brne	80007c24 <_vfprintf_r+0x1cc>
80007e7e:	e0 49 00 20 	cp.w	r9,32
80007e82:	e0 89 0d 75 	brgt	8000996c <_vfprintf_r+0x1f14>
80007e86:	f2 c3 00 01 	sub	r3,r9,1
80007e8a:	30 19       	mov	r9,1
80007e8c:	50 39       	stdsp	sp[0xc],r9
80007e8e:	cc 9a       	rjmp	80007c20 <_vfprintf_r+0x1c8>
80007e90:	a3 b5       	sbr	r5,0x3
80007e92:	cc 7a       	rjmp	80007c20 <_vfprintf_r+0x1c8>
80007e94:	a7 a5       	sbr	r5,0x6
80007e96:	cc 5a       	rjmp	80007c20 <_vfprintf_r+0x1c8>
80007e98:	0a 98       	mov	r8,r5
80007e9a:	a5 b5       	sbr	r5,0x5
80007e9c:	a5 a8       	sbr	r8,0x4
80007e9e:	0f 89       	ld.ub	r9,r7[0x0]
80007ea0:	36 ce       	mov	lr,108
80007ea2:	fc 09 18 00 	cp.b	r9,lr
80007ea6:	f7 b7 00 ff 	subeq	r7,-1
80007eaa:	f0 05 17 10 	movne	r5,r8
80007eae:	cb 9a       	rjmp	80007c20 <_vfprintf_r+0x1c8>
80007eb0:	a5 b5       	sbr	r5,0x5
80007eb2:	cb 7a       	rjmp	80007c20 <_vfprintf_r+0x1c8>
80007eb4:	50 a7       	stdsp	sp[0x28],r7
80007eb6:	50 80       	stdsp	sp[0x20],r0
80007eb8:	0c 97       	mov	r7,r6
80007eba:	10 90       	mov	r0,r8
80007ebc:	06 96       	mov	r6,r3
80007ebe:	04 94       	mov	r4,r2
80007ec0:	40 93       	lddsp	r3,sp[0x24]
80007ec2:	02 92       	mov	r2,r1
80007ec4:	0e 99       	mov	r9,r7
80007ec6:	40 41       	lddsp	r1,sp[0x10]
80007ec8:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007ecc:	40 3c       	lddsp	r12,sp[0xc]
80007ece:	58 0c       	cp.w	r12,0
80007ed0:	c1 d0       	breq	80007f0a <_vfprintf_r+0x4b2>
80007ed2:	10 36       	cp.w	r6,r8
80007ed4:	c0 64       	brge	80007ee0 <_vfprintf_r+0x488>
80007ed6:	fa cb f9 44 	sub	r11,sp,-1724
80007eda:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007ede:	c1 d8       	rjmp	80007f18 <_vfprintf_r+0x4c0>
80007ee0:	fa c8 f9 50 	sub	r8,sp,-1712
80007ee4:	1a d8       	st.w	--sp,r8
80007ee6:	fa c8 fa b8 	sub	r8,sp,-1352
80007eea:	1a d8       	st.w	--sp,r8
80007eec:	fa c8 fb b4 	sub	r8,sp,-1100
80007ef0:	1a d8       	st.w	--sp,r8
80007ef2:	fa c8 f9 40 	sub	r8,sp,-1728
80007ef6:	fa c9 ff b4 	sub	r9,sp,-76
80007efa:	04 9a       	mov	r10,r2
80007efc:	0c 9b       	mov	r11,r6
80007efe:	08 9c       	mov	r12,r4
80007f00:	fe b0 fc 0e 	rcall	8000771c <get_arg>
80007f04:	2f dd       	sub	sp,-12
80007f06:	19 b8       	ld.ub	r8,r12[0x3]
80007f08:	c2 28       	rjmp	80007f4c <_vfprintf_r+0x4f4>
80007f0a:	2f f7       	sub	r7,-1
80007f0c:	10 39       	cp.w	r9,r8
80007f0e:	c0 84       	brge	80007f1e <_vfprintf_r+0x4c6>
80007f10:	fa ca f9 44 	sub	r10,sp,-1724
80007f14:	f4 06 00 36 	add	r6,r10,r6<<0x3
80007f18:	ed 38 fd 8b 	ld.ub	r8,r6[-629]
80007f1c:	c1 88       	rjmp	80007f4c <_vfprintf_r+0x4f4>
80007f1e:	41 09       	lddsp	r9,sp[0x40]
80007f20:	59 f8       	cp.w	r8,31
80007f22:	e0 89 00 12 	brgt	80007f46 <_vfprintf_r+0x4ee>
80007f26:	f2 ca ff fc 	sub	r10,r9,-4
80007f2a:	51 0a       	stdsp	sp[0x40],r10
80007f2c:	72 09       	ld.w	r9,r9[0x0]
80007f2e:	fa c6 f9 44 	sub	r6,sp,-1724
80007f32:	ec 08 00 3a 	add	r10,r6,r8<<0x3
80007f36:	2f f8       	sub	r8,-1
80007f38:	f5 49 fd 88 	st.w	r10[-632],r9
80007f3c:	fb 48 06 b4 	st.w	sp[1716],r8
80007f40:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
80007f44:	c0 48       	rjmp	80007f4c <_vfprintf_r+0x4f4>
80007f46:	13 b8       	ld.ub	r8,r9[0x3]
80007f48:	2f c9       	sub	r9,-4
80007f4a:	51 09       	stdsp	sp[0x40],r9
80007f4c:	fb 68 06 60 	st.b	sp[1632],r8
80007f50:	30 0e       	mov	lr,0
80007f52:	30 08       	mov	r8,0
80007f54:	30 12       	mov	r2,1
80007f56:	fb 68 06 bb 	st.b	sp[1723],r8
80007f5a:	50 2e       	stdsp	sp[0x8],lr
80007f5c:	e0 8f 08 b1 	bral	800090be <_vfprintf_r+0x1666>
80007f60:	50 a7       	stdsp	sp[0x28],r7
80007f62:	50 80       	stdsp	sp[0x20],r0
80007f64:	0c 97       	mov	r7,r6
80007f66:	04 94       	mov	r4,r2
80007f68:	06 96       	mov	r6,r3
80007f6a:	02 92       	mov	r2,r1
80007f6c:	40 93       	lddsp	r3,sp[0x24]
80007f6e:	10 90       	mov	r0,r8
80007f70:	40 41       	lddsp	r1,sp[0x10]
80007f72:	a5 a5       	sbr	r5,0x4
80007f74:	c0 a8       	rjmp	80007f88 <_vfprintf_r+0x530>
80007f76:	50 a7       	stdsp	sp[0x28],r7
80007f78:	50 80       	stdsp	sp[0x20],r0
80007f7a:	0c 97       	mov	r7,r6
80007f7c:	04 94       	mov	r4,r2
80007f7e:	06 96       	mov	r6,r3
80007f80:	02 92       	mov	r2,r1
80007f82:	40 93       	lddsp	r3,sp[0x24]
80007f84:	10 90       	mov	r0,r8
80007f86:	40 41       	lddsp	r1,sp[0x10]
80007f88:	ed b5 00 05 	bld	r5,0x5
80007f8c:	c5 11       	brne	8000802e <_vfprintf_r+0x5d6>
80007f8e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007f92:	40 3c       	lddsp	r12,sp[0xc]
80007f94:	58 0c       	cp.w	r12,0
80007f96:	c1 e0       	breq	80007fd2 <_vfprintf_r+0x57a>
80007f98:	10 36       	cp.w	r6,r8
80007f9a:	c0 64       	brge	80007fa6 <_vfprintf_r+0x54e>
80007f9c:	fa cb f9 44 	sub	r11,sp,-1724
80007fa0:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007fa4:	c2 08       	rjmp	80007fe4 <_vfprintf_r+0x58c>
80007fa6:	fa c8 f9 50 	sub	r8,sp,-1712
80007faa:	1a d8       	st.w	--sp,r8
80007fac:	fa c8 fa b8 	sub	r8,sp,-1352
80007fb0:	0c 9b       	mov	r11,r6
80007fb2:	1a d8       	st.w	--sp,r8
80007fb4:	fa c8 fb b4 	sub	r8,sp,-1100
80007fb8:	1a d8       	st.w	--sp,r8
80007fba:	fa c9 ff b4 	sub	r9,sp,-76
80007fbe:	fa c8 f9 40 	sub	r8,sp,-1728
80007fc2:	04 9a       	mov	r10,r2
80007fc4:	08 9c       	mov	r12,r4
80007fc6:	fe b0 fb ab 	rcall	8000771c <get_arg>
80007fca:	2f dd       	sub	sp,-12
80007fcc:	78 1b       	ld.w	r11,r12[0x4]
80007fce:	78 09       	ld.w	r9,r12[0x0]
80007fd0:	c2 b8       	rjmp	80008026 <_vfprintf_r+0x5ce>
80007fd2:	ee ca ff ff 	sub	r10,r7,-1
80007fd6:	10 37       	cp.w	r7,r8
80007fd8:	c0 b4       	brge	80007fee <_vfprintf_r+0x596>
80007fda:	fa c9 f9 44 	sub	r9,sp,-1724
80007fde:	14 97       	mov	r7,r10
80007fe0:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007fe4:	ec fb fd 8c 	ld.w	r11,r6[-628]
80007fe8:	ec f9 fd 88 	ld.w	r9,r6[-632]
80007fec:	c1 d8       	rjmp	80008026 <_vfprintf_r+0x5ce>
80007fee:	41 09       	lddsp	r9,sp[0x40]
80007ff0:	59 f8       	cp.w	r8,31
80007ff2:	e0 89 00 14 	brgt	8000801a <_vfprintf_r+0x5c2>
80007ff6:	f2 cb ff f8 	sub	r11,r9,-8
80007ffa:	51 0b       	stdsp	sp[0x40],r11
80007ffc:	fa c6 f9 44 	sub	r6,sp,-1724
80008000:	72 1b       	ld.w	r11,r9[0x4]
80008002:	ec 08 00 3c 	add	r12,r6,r8<<0x3
80008006:	72 09       	ld.w	r9,r9[0x0]
80008008:	f9 4b fd 8c 	st.w	r12[-628],r11
8000800c:	f9 49 fd 88 	st.w	r12[-632],r9
80008010:	2f f8       	sub	r8,-1
80008012:	14 97       	mov	r7,r10
80008014:	fb 48 06 b4 	st.w	sp[1716],r8
80008018:	c0 78       	rjmp	80008026 <_vfprintf_r+0x5ce>
8000801a:	f2 c8 ff f8 	sub	r8,r9,-8
8000801e:	72 1b       	ld.w	r11,r9[0x4]
80008020:	14 97       	mov	r7,r10
80008022:	51 08       	stdsp	sp[0x40],r8
80008024:	72 09       	ld.w	r9,r9[0x0]
80008026:	16 98       	mov	r8,r11
80008028:	fa e9 00 00 	st.d	sp[0],r8
8000802c:	ca e8       	rjmp	80008188 <_vfprintf_r+0x730>
8000802e:	ed b5 00 04 	bld	r5,0x4
80008032:	c1 71       	brne	80008060 <_vfprintf_r+0x608>
80008034:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008038:	40 3e       	lddsp	lr,sp[0xc]
8000803a:	58 0e       	cp.w	lr,0
8000803c:	c0 80       	breq	8000804c <_vfprintf_r+0x5f4>
8000803e:	10 36       	cp.w	r6,r8
80008040:	c6 94       	brge	80008112 <_vfprintf_r+0x6ba>
80008042:	fa cc f9 44 	sub	r12,sp,-1724
80008046:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000804a:	c8 28       	rjmp	8000814e <_vfprintf_r+0x6f6>
8000804c:	ee ca ff ff 	sub	r10,r7,-1
80008050:	10 37       	cp.w	r7,r8
80008052:	e0 84 00 81 	brge	80008154 <_vfprintf_r+0x6fc>
80008056:	fa cb f9 44 	sub	r11,sp,-1724
8000805a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000805e:	c7 78       	rjmp	8000814c <_vfprintf_r+0x6f4>
80008060:	ed b5 00 06 	bld	r5,0x6
80008064:	c4 b1       	brne	800080fa <_vfprintf_r+0x6a2>
80008066:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000806a:	40 3c       	lddsp	r12,sp[0xc]
8000806c:	58 0c       	cp.w	r12,0
8000806e:	c1 d0       	breq	800080a8 <_vfprintf_r+0x650>
80008070:	10 36       	cp.w	r6,r8
80008072:	c0 64       	brge	8000807e <_vfprintf_r+0x626>
80008074:	fa cb f9 44 	sub	r11,sp,-1724
80008078:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000807c:	c1 f8       	rjmp	800080ba <_vfprintf_r+0x662>
8000807e:	fa c8 f9 50 	sub	r8,sp,-1712
80008082:	1a d8       	st.w	--sp,r8
80008084:	fa c8 fa b8 	sub	r8,sp,-1352
80008088:	1a d8       	st.w	--sp,r8
8000808a:	fa c8 fb b4 	sub	r8,sp,-1100
8000808e:	1a d8       	st.w	--sp,r8
80008090:	fa c8 f9 40 	sub	r8,sp,-1728
80008094:	fa c9 ff b4 	sub	r9,sp,-76
80008098:	04 9a       	mov	r10,r2
8000809a:	0c 9b       	mov	r11,r6
8000809c:	08 9c       	mov	r12,r4
8000809e:	fe b0 fb 3f 	rcall	8000771c <get_arg>
800080a2:	2f dd       	sub	sp,-12
800080a4:	98 18       	ld.sh	r8,r12[0x2]
800080a6:	c2 68       	rjmp	800080f2 <_vfprintf_r+0x69a>
800080a8:	ee ca ff ff 	sub	r10,r7,-1
800080ac:	10 37       	cp.w	r7,r8
800080ae:	c0 94       	brge	800080c0 <_vfprintf_r+0x668>
800080b0:	fa c9 f9 44 	sub	r9,sp,-1724
800080b4:	14 97       	mov	r7,r10
800080b6:	f2 06 00 36 	add	r6,r9,r6<<0x3
800080ba:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
800080be:	c1 a8       	rjmp	800080f2 <_vfprintf_r+0x69a>
800080c0:	41 09       	lddsp	r9,sp[0x40]
800080c2:	59 f8       	cp.w	r8,31
800080c4:	e0 89 00 13 	brgt	800080ea <_vfprintf_r+0x692>
800080c8:	f2 cb ff fc 	sub	r11,r9,-4
800080cc:	51 0b       	stdsp	sp[0x40],r11
800080ce:	72 09       	ld.w	r9,r9[0x0]
800080d0:	fa c6 f9 44 	sub	r6,sp,-1724
800080d4:	ec 08 00 3b 	add	r11,r6,r8<<0x3
800080d8:	2f f8       	sub	r8,-1
800080da:	f7 49 fd 88 	st.w	r11[-632],r9
800080de:	fb 48 06 b4 	st.w	sp[1716],r8
800080e2:	14 97       	mov	r7,r10
800080e4:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
800080e8:	c0 58       	rjmp	800080f2 <_vfprintf_r+0x69a>
800080ea:	92 18       	ld.sh	r8,r9[0x2]
800080ec:	14 97       	mov	r7,r10
800080ee:	2f c9       	sub	r9,-4
800080f0:	51 09       	stdsp	sp[0x40],r9
800080f2:	50 18       	stdsp	sp[0x4],r8
800080f4:	bf 58       	asr	r8,0x1f
800080f6:	50 08       	stdsp	sp[0x0],r8
800080f8:	c4 88       	rjmp	80008188 <_vfprintf_r+0x730>
800080fa:	fa f8 06 b4 	ld.w	r8,sp[1716]
800080fe:	40 3c       	lddsp	r12,sp[0xc]
80008100:	58 0c       	cp.w	r12,0
80008102:	c1 d0       	breq	8000813c <_vfprintf_r+0x6e4>
80008104:	10 36       	cp.w	r6,r8
80008106:	c0 64       	brge	80008112 <_vfprintf_r+0x6ba>
80008108:	fa cb f9 44 	sub	r11,sp,-1724
8000810c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008110:	c1 f8       	rjmp	8000814e <_vfprintf_r+0x6f6>
80008112:	fa c8 f9 50 	sub	r8,sp,-1712
80008116:	1a d8       	st.w	--sp,r8
80008118:	fa c8 fa b8 	sub	r8,sp,-1352
8000811c:	0c 9b       	mov	r11,r6
8000811e:	1a d8       	st.w	--sp,r8
80008120:	fa c8 fb b4 	sub	r8,sp,-1100
80008124:	04 9a       	mov	r10,r2
80008126:	1a d8       	st.w	--sp,r8
80008128:	08 9c       	mov	r12,r4
8000812a:	fa c8 f9 40 	sub	r8,sp,-1728
8000812e:	fa c9 ff b4 	sub	r9,sp,-76
80008132:	fe b0 fa f5 	rcall	8000771c <get_arg>
80008136:	2f dd       	sub	sp,-12
80008138:	78 0b       	ld.w	r11,r12[0x0]
8000813a:	c2 48       	rjmp	80008182 <_vfprintf_r+0x72a>
8000813c:	ee ca ff ff 	sub	r10,r7,-1
80008140:	10 37       	cp.w	r7,r8
80008142:	c0 94       	brge	80008154 <_vfprintf_r+0x6fc>
80008144:	fa c9 f9 44 	sub	r9,sp,-1724
80008148:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000814c:	14 97       	mov	r7,r10
8000814e:	ec fb fd 88 	ld.w	r11,r6[-632]
80008152:	c1 88       	rjmp	80008182 <_vfprintf_r+0x72a>
80008154:	41 09       	lddsp	r9,sp[0x40]
80008156:	59 f8       	cp.w	r8,31
80008158:	e0 89 00 11 	brgt	8000817a <_vfprintf_r+0x722>
8000815c:	f2 cb ff fc 	sub	r11,r9,-4
80008160:	51 0b       	stdsp	sp[0x40],r11
80008162:	fa c6 f9 44 	sub	r6,sp,-1724
80008166:	72 0b       	ld.w	r11,r9[0x0]
80008168:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000816c:	f3 4b fd 88 	st.w	r9[-632],r11
80008170:	2f f8       	sub	r8,-1
80008172:	14 97       	mov	r7,r10
80008174:	fb 48 06 b4 	st.w	sp[1716],r8
80008178:	c0 58       	rjmp	80008182 <_vfprintf_r+0x72a>
8000817a:	72 0b       	ld.w	r11,r9[0x0]
8000817c:	14 97       	mov	r7,r10
8000817e:	2f c9       	sub	r9,-4
80008180:	51 09       	stdsp	sp[0x40],r9
80008182:	50 1b       	stdsp	sp[0x4],r11
80008184:	bf 5b       	asr	r11,0x1f
80008186:	50 0b       	stdsp	sp[0x0],r11
80008188:	fa ea 00 00 	ld.d	r10,sp[0]
8000818c:	58 0a       	cp.w	r10,0
8000818e:	5c 2b       	cpc	r11
80008190:	c0 e4       	brge	800081ac <_vfprintf_r+0x754>
80008192:	30 08       	mov	r8,0
80008194:	fa ea 00 00 	ld.d	r10,sp[0]
80008198:	30 09       	mov	r9,0
8000819a:	f0 0a 01 0a 	sub	r10,r8,r10
8000819e:	f2 0b 01 4b 	sbc	r11,r9,r11
800081a2:	32 d8       	mov	r8,45
800081a4:	fa eb 00 00 	st.d	sp[0],r10
800081a8:	fb 68 06 bb 	st.b	sp[1723],r8
800081ac:	30 18       	mov	r8,1
800081ae:	e0 8f 06 fe 	bral	80008faa <_vfprintf_r+0x1552>
800081b2:	50 a7       	stdsp	sp[0x28],r7
800081b4:	50 80       	stdsp	sp[0x20],r0
800081b6:	0c 97       	mov	r7,r6
800081b8:	04 94       	mov	r4,r2
800081ba:	06 96       	mov	r6,r3
800081bc:	02 92       	mov	r2,r1
800081be:	40 93       	lddsp	r3,sp[0x24]
800081c0:	10 90       	mov	r0,r8
800081c2:	40 41       	lddsp	r1,sp[0x10]
800081c4:	0e 99       	mov	r9,r7
800081c6:	ed b5 00 03 	bld	r5,0x3
800081ca:	c4 11       	brne	8000824c <_vfprintf_r+0x7f4>
800081cc:	fa f8 06 b4 	ld.w	r8,sp[1716]
800081d0:	40 3a       	lddsp	r10,sp[0xc]
800081d2:	58 0a       	cp.w	r10,0
800081d4:	c1 90       	breq	80008206 <_vfprintf_r+0x7ae>
800081d6:	10 36       	cp.w	r6,r8
800081d8:	c6 45       	brlt	800082a0 <_vfprintf_r+0x848>
800081da:	fa c8 f9 50 	sub	r8,sp,-1712
800081de:	1a d8       	st.w	--sp,r8
800081e0:	fa c8 fa b8 	sub	r8,sp,-1352
800081e4:	1a d8       	st.w	--sp,r8
800081e6:	fa c8 fb b4 	sub	r8,sp,-1100
800081ea:	0c 9b       	mov	r11,r6
800081ec:	1a d8       	st.w	--sp,r8
800081ee:	04 9a       	mov	r10,r2
800081f0:	fa c8 f9 40 	sub	r8,sp,-1728
800081f4:	fa c9 ff b4 	sub	r9,sp,-76
800081f8:	08 9c       	mov	r12,r4
800081fa:	fe b0 fa 91 	rcall	8000771c <get_arg>
800081fe:	2f dd       	sub	sp,-12
80008200:	78 16       	ld.w	r6,r12[0x4]
80008202:	50 76       	stdsp	sp[0x1c],r6
80008204:	c4 88       	rjmp	80008294 <_vfprintf_r+0x83c>
80008206:	2f f7       	sub	r7,-1
80008208:	10 39       	cp.w	r9,r8
8000820a:	c0 c4       	brge	80008222 <_vfprintf_r+0x7ca>
8000820c:	fa ce f9 44 	sub	lr,sp,-1724
80008210:	fc 06 00 36 	add	r6,lr,r6<<0x3
80008214:	ec fc fd 8c 	ld.w	r12,r6[-628]
80008218:	50 7c       	stdsp	sp[0x1c],r12
8000821a:	ec f6 fd 88 	ld.w	r6,r6[-632]
8000821e:	50 56       	stdsp	sp[0x14],r6
80008220:	c6 68       	rjmp	800082ec <_vfprintf_r+0x894>
80008222:	41 09       	lddsp	r9,sp[0x40]
80008224:	59 f8       	cp.w	r8,31
80008226:	e0 89 00 10 	brgt	80008246 <_vfprintf_r+0x7ee>
8000822a:	f2 ca ff f8 	sub	r10,r9,-8
8000822e:	72 1b       	ld.w	r11,r9[0x4]
80008230:	51 0a       	stdsp	sp[0x40],r10
80008232:	72 09       	ld.w	r9,r9[0x0]
80008234:	fa ca f9 44 	sub	r10,sp,-1724
80008238:	50 7b       	stdsp	sp[0x1c],r11
8000823a:	50 59       	stdsp	sp[0x14],r9
8000823c:	f4 08 00 39 	add	r9,r10,r8<<0x3
80008240:	40 5b       	lddsp	r11,sp[0x14]
80008242:	40 7a       	lddsp	r10,sp[0x1c]
80008244:	c4 78       	rjmp	800082d2 <_vfprintf_r+0x87a>
80008246:	72 18       	ld.w	r8,r9[0x4]
80008248:	50 78       	stdsp	sp[0x1c],r8
8000824a:	c4 c8       	rjmp	800082e2 <_vfprintf_r+0x88a>
8000824c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008250:	40 3e       	lddsp	lr,sp[0xc]
80008252:	58 0e       	cp.w	lr,0
80008254:	c2 30       	breq	8000829a <_vfprintf_r+0x842>
80008256:	10 36       	cp.w	r6,r8
80008258:	c0 94       	brge	8000826a <_vfprintf_r+0x812>
8000825a:	fa cc f9 44 	sub	r12,sp,-1724
8000825e:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008262:	ec fb fd 8c 	ld.w	r11,r6[-628]
80008266:	50 7b       	stdsp	sp[0x1c],r11
80008268:	cd 9b       	rjmp	8000821a <_vfprintf_r+0x7c2>
8000826a:	fa c8 f9 50 	sub	r8,sp,-1712
8000826e:	1a d8       	st.w	--sp,r8
80008270:	fa c8 fa b8 	sub	r8,sp,-1352
80008274:	04 9a       	mov	r10,r2
80008276:	1a d8       	st.w	--sp,r8
80008278:	fa c8 fb b4 	sub	r8,sp,-1100
8000827c:	0c 9b       	mov	r11,r6
8000827e:	1a d8       	st.w	--sp,r8
80008280:	08 9c       	mov	r12,r4
80008282:	fa c8 f9 40 	sub	r8,sp,-1728
80008286:	fa c9 ff b4 	sub	r9,sp,-76
8000828a:	fe b0 fa 49 	rcall	8000771c <get_arg>
8000828e:	2f dd       	sub	sp,-12
80008290:	78 1a       	ld.w	r10,r12[0x4]
80008292:	50 7a       	stdsp	sp[0x1c],r10
80008294:	78 0c       	ld.w	r12,r12[0x0]
80008296:	50 5c       	stdsp	sp[0x14],r12
80008298:	c2 a8       	rjmp	800082ec <_vfprintf_r+0x894>
8000829a:	2f f7       	sub	r7,-1
8000829c:	10 39       	cp.w	r9,r8
8000829e:	c0 94       	brge	800082b0 <_vfprintf_r+0x858>
800082a0:	fa c9 f9 44 	sub	r9,sp,-1724
800082a4:	f2 06 00 36 	add	r6,r9,r6<<0x3
800082a8:	ec f8 fd 8c 	ld.w	r8,r6[-628]
800082ac:	50 78       	stdsp	sp[0x1c],r8
800082ae:	cb 6b       	rjmp	8000821a <_vfprintf_r+0x7c2>
800082b0:	41 09       	lddsp	r9,sp[0x40]
800082b2:	59 f8       	cp.w	r8,31
800082b4:	e0 89 00 15 	brgt	800082de <_vfprintf_r+0x886>
800082b8:	f2 ca ff f8 	sub	r10,r9,-8
800082bc:	72 16       	ld.w	r6,r9[0x4]
800082be:	72 09       	ld.w	r9,r9[0x0]
800082c0:	51 0a       	stdsp	sp[0x40],r10
800082c2:	50 59       	stdsp	sp[0x14],r9
800082c4:	fa ce f9 44 	sub	lr,sp,-1724
800082c8:	50 76       	stdsp	sp[0x1c],r6
800082ca:	fc 08 00 39 	add	r9,lr,r8<<0x3
800082ce:	40 5b       	lddsp	r11,sp[0x14]
800082d0:	0c 9a       	mov	r10,r6
800082d2:	f2 eb fd 88 	st.d	r9[-632],r10
800082d6:	2f f8       	sub	r8,-1
800082d8:	fb 48 06 b4 	st.w	sp[1716],r8
800082dc:	c0 88       	rjmp	800082ec <_vfprintf_r+0x894>
800082de:	72 1c       	ld.w	r12,r9[0x4]
800082e0:	50 7c       	stdsp	sp[0x1c],r12
800082e2:	f2 c8 ff f8 	sub	r8,r9,-8
800082e6:	51 08       	stdsp	sp[0x40],r8
800082e8:	72 09       	ld.w	r9,r9[0x0]
800082ea:	50 59       	stdsp	sp[0x14],r9
800082ec:	40 5b       	lddsp	r11,sp[0x14]
800082ee:	40 7a       	lddsp	r10,sp[0x1c]
800082f0:	e0 a0 19 64 	rcall	8000b5b8 <__isinfd>
800082f4:	18 96       	mov	r6,r12
800082f6:	c1 50       	breq	80008320 <_vfprintf_r+0x8c8>
800082f8:	30 08       	mov	r8,0
800082fa:	30 09       	mov	r9,0
800082fc:	40 5b       	lddsp	r11,sp[0x14]
800082fe:	40 7a       	lddsp	r10,sp[0x1c]
80008300:	e0 a0 1d ba 	rcall	8000be74 <__avr32_f64_cmp_lt>
80008304:	c0 40       	breq	8000830c <_vfprintf_r+0x8b4>
80008306:	32 d8       	mov	r8,45
80008308:	fb 68 06 bb 	st.b	sp[1723],r8
8000830c:	4d 18       	lddpc	r8,80008450 <_vfprintf_r+0x9f8>
8000830e:	4d 26       	lddpc	r6,80008454 <_vfprintf_r+0x9fc>
80008310:	a7 d5       	cbr	r5,0x7
80008312:	e0 40 00 47 	cp.w	r0,71
80008316:	f0 06 17 a0 	movle	r6,r8
8000831a:	30 32       	mov	r2,3
8000831c:	e0 8f 06 d4 	bral	800090c4 <_vfprintf_r+0x166c>
80008320:	40 5b       	lddsp	r11,sp[0x14]
80008322:	40 7a       	lddsp	r10,sp[0x1c]
80008324:	e0 a0 19 5f 	rcall	8000b5e2 <__isnand>
80008328:	c0 c0       	breq	80008340 <_vfprintf_r+0x8e8>
8000832a:	50 26       	stdsp	sp[0x8],r6
8000832c:	4c b8       	lddpc	r8,80008458 <_vfprintf_r+0xa00>
8000832e:	4c c6       	lddpc	r6,8000845c <_vfprintf_r+0xa04>
80008330:	a7 d5       	cbr	r5,0x7
80008332:	e0 40 00 47 	cp.w	r0,71
80008336:	f0 06 17 a0 	movle	r6,r8
8000833a:	30 32       	mov	r2,3
8000833c:	e0 8f 06 ca 	bral	800090d0 <_vfprintf_r+0x1678>
80008340:	40 2a       	lddsp	r10,sp[0x8]
80008342:	5b fa       	cp.w	r10,-1
80008344:	c0 41       	brne	8000834c <_vfprintf_r+0x8f4>
80008346:	30 69       	mov	r9,6
80008348:	50 29       	stdsp	sp[0x8],r9
8000834a:	c1 18       	rjmp	8000836c <_vfprintf_r+0x914>
8000834c:	e0 40 00 47 	cp.w	r0,71
80008350:	5f 09       	sreq	r9
80008352:	e0 40 00 67 	cp.w	r0,103
80008356:	5f 08       	sreq	r8
80008358:	f3 e8 10 08 	or	r8,r9,r8
8000835c:	f8 08 18 00 	cp.b	r8,r12
80008360:	c0 60       	breq	8000836c <_vfprintf_r+0x914>
80008362:	40 28       	lddsp	r8,sp[0x8]
80008364:	58 08       	cp.w	r8,0
80008366:	f9 b8 00 01 	moveq	r8,1
8000836a:	50 28       	stdsp	sp[0x8],r8
8000836c:	40 78       	lddsp	r8,sp[0x1c]
8000836e:	40 59       	lddsp	r9,sp[0x14]
80008370:	fa e9 06 94 	st.d	sp[1684],r8
80008374:	a9 a5       	sbr	r5,0x8
80008376:	fa f8 06 94 	ld.w	r8,sp[1684]
8000837a:	58 08       	cp.w	r8,0
8000837c:	c0 65       	brlt	80008388 <_vfprintf_r+0x930>
8000837e:	40 5e       	lddsp	lr,sp[0x14]
80008380:	30 0c       	mov	r12,0
80008382:	50 6e       	stdsp	sp[0x18],lr
80008384:	50 9c       	stdsp	sp[0x24],r12
80008386:	c0 78       	rjmp	80008394 <_vfprintf_r+0x93c>
80008388:	40 5b       	lddsp	r11,sp[0x14]
8000838a:	32 da       	mov	r10,45
8000838c:	ee 1b 80 00 	eorh	r11,0x8000
80008390:	50 9a       	stdsp	sp[0x24],r10
80008392:	50 6b       	stdsp	sp[0x18],r11
80008394:	e0 40 00 46 	cp.w	r0,70
80008398:	5f 09       	sreq	r9
8000839a:	e0 40 00 66 	cp.w	r0,102
8000839e:	5f 08       	sreq	r8
800083a0:	f3 e8 10 08 	or	r8,r9,r8
800083a4:	50 48       	stdsp	sp[0x10],r8
800083a6:	c0 40       	breq	800083ae <_vfprintf_r+0x956>
800083a8:	40 22       	lddsp	r2,sp[0x8]
800083aa:	30 39       	mov	r9,3
800083ac:	c1 08       	rjmp	800083cc <_vfprintf_r+0x974>
800083ae:	e0 40 00 45 	cp.w	r0,69
800083b2:	5f 09       	sreq	r9
800083b4:	e0 40 00 65 	cp.w	r0,101
800083b8:	5f 08       	sreq	r8
800083ba:	40 22       	lddsp	r2,sp[0x8]
800083bc:	10 49       	or	r9,r8
800083be:	2f f2       	sub	r2,-1
800083c0:	40 46       	lddsp	r6,sp[0x10]
800083c2:	ec 09 18 00 	cp.b	r9,r6
800083c6:	fb f2 00 02 	ld.weq	r2,sp[0x8]
800083ca:	30 29       	mov	r9,2
800083cc:	fa c8 f9 5c 	sub	r8,sp,-1700
800083d0:	1a d8       	st.w	--sp,r8
800083d2:	fa c8 f9 54 	sub	r8,sp,-1708
800083d6:	1a d8       	st.w	--sp,r8
800083d8:	fa c8 f9 4c 	sub	r8,sp,-1716
800083dc:	08 9c       	mov	r12,r4
800083de:	1a d8       	st.w	--sp,r8
800083e0:	04 98       	mov	r8,r2
800083e2:	40 9b       	lddsp	r11,sp[0x24]
800083e4:	40 aa       	lddsp	r10,sp[0x28]
800083e6:	e0 a0 0b cf 	rcall	80009b84 <_dtoa_r>
800083ea:	e0 40 00 47 	cp.w	r0,71
800083ee:	5f 19       	srne	r9
800083f0:	e0 40 00 67 	cp.w	r0,103
800083f4:	5f 18       	srne	r8
800083f6:	18 96       	mov	r6,r12
800083f8:	2f dd       	sub	sp,-12
800083fa:	f3 e8 00 08 	and	r8,r9,r8
800083fe:	c0 41       	brne	80008406 <_vfprintf_r+0x9ae>
80008400:	ed b5 00 00 	bld	r5,0x0
80008404:	c3 81       	brne	80008474 <_vfprintf_r+0xa1c>
80008406:	ec 02 00 0e 	add	lr,r6,r2
8000840a:	50 3e       	stdsp	sp[0xc],lr
8000840c:	40 4c       	lddsp	r12,sp[0x10]
8000840e:	58 0c       	cp.w	r12,0
80008410:	c1 50       	breq	8000843a <_vfprintf_r+0x9e2>
80008412:	0d 89       	ld.ub	r9,r6[0x0]
80008414:	33 08       	mov	r8,48
80008416:	f0 09 18 00 	cp.b	r9,r8
8000841a:	c0 b1       	brne	80008430 <_vfprintf_r+0x9d8>
8000841c:	30 08       	mov	r8,0
8000841e:	30 09       	mov	r9,0
80008420:	40 6b       	lddsp	r11,sp[0x18]
80008422:	40 7a       	lddsp	r10,sp[0x1c]
80008424:	e0 a0 1c e1 	rcall	8000bde6 <__avr32_f64_cmp_eq>
80008428:	fb b2 00 01 	rsubeq	r2,1
8000842c:	fb f2 0b ab 	st.weq	sp[0x6ac],r2
80008430:	40 3b       	lddsp	r11,sp[0xc]
80008432:	fa f8 06 ac 	ld.w	r8,sp[1708]
80008436:	10 0b       	add	r11,r8
80008438:	50 3b       	stdsp	sp[0xc],r11
8000843a:	40 6b       	lddsp	r11,sp[0x18]
8000843c:	30 08       	mov	r8,0
8000843e:	30 09       	mov	r9,0
80008440:	40 7a       	lddsp	r10,sp[0x1c]
80008442:	e0 a0 1c d2 	rcall	8000bde6 <__avr32_f64_cmp_eq>
80008446:	c1 10       	breq	80008468 <_vfprintf_r+0xa10>
80008448:	40 3a       	lddsp	r10,sp[0xc]
8000844a:	fb 4a 06 a4 	st.w	sp[1700],r10
8000844e:	c0 d8       	rjmp	80008468 <_vfprintf_r+0xa10>
80008450:	80 01       	ld.sh	r1,r0[0x0]
80008452:	5d 88       	*unknown*
80008454:	80 01       	ld.sh	r1,r0[0x0]
80008456:	5d 8c       	*unknown*
80008458:	80 01       	ld.sh	r1,r0[0x0]
8000845a:	5d 90       	*unknown*
8000845c:	80 01       	ld.sh	r1,r0[0x0]
8000845e:	5d 94       	*unknown*
80008460:	10 c9       	st.b	r8++,r9
80008462:	fb 48 06 a4 	st.w	sp[1700],r8
80008466:	c0 28       	rjmp	8000846a <_vfprintf_r+0xa12>
80008468:	33 09       	mov	r9,48
8000846a:	fa f8 06 a4 	ld.w	r8,sp[1700]
8000846e:	40 3e       	lddsp	lr,sp[0xc]
80008470:	1c 38       	cp.w	r8,lr
80008472:	cf 73       	brcs	80008460 <_vfprintf_r+0xa08>
80008474:	e0 40 00 47 	cp.w	r0,71
80008478:	5f 09       	sreq	r9
8000847a:	e0 40 00 67 	cp.w	r0,103
8000847e:	5f 08       	sreq	r8
80008480:	f3 e8 10 08 	or	r8,r9,r8
80008484:	fa f9 06 a4 	ld.w	r9,sp[1700]
80008488:	0c 19       	sub	r9,r6
8000848a:	50 69       	stdsp	sp[0x18],r9
8000848c:	58 08       	cp.w	r8,0
8000848e:	c0 b0       	breq	800084a4 <_vfprintf_r+0xa4c>
80008490:	fa f8 06 ac 	ld.w	r8,sp[1708]
80008494:	5b d8       	cp.w	r8,-3
80008496:	c0 55       	brlt	800084a0 <_vfprintf_r+0xa48>
80008498:	40 2c       	lddsp	r12,sp[0x8]
8000849a:	18 38       	cp.w	r8,r12
8000849c:	e0 8a 00 6a 	brle	80008570 <_vfprintf_r+0xb18>
800084a0:	20 20       	sub	r0,2
800084a2:	c0 58       	rjmp	800084ac <_vfprintf_r+0xa54>
800084a4:	e0 40 00 65 	cp.w	r0,101
800084a8:	e0 89 00 46 	brgt	80008534 <_vfprintf_r+0xadc>
800084ac:	fa fb 06 ac 	ld.w	r11,sp[1708]
800084b0:	fb 60 06 9c 	st.b	sp[1692],r0
800084b4:	20 1b       	sub	r11,1
800084b6:	fb 4b 06 ac 	st.w	sp[1708],r11
800084ba:	c0 47       	brpl	800084c2 <_vfprintf_r+0xa6a>
800084bc:	5c 3b       	neg	r11
800084be:	32 d8       	mov	r8,45
800084c0:	c0 28       	rjmp	800084c4 <_vfprintf_r+0xa6c>
800084c2:	32 b8       	mov	r8,43
800084c4:	fb 68 06 9d 	st.b	sp[1693],r8
800084c8:	58 9b       	cp.w	r11,9
800084ca:	e0 8a 00 1d 	brle	80008504 <_vfprintf_r+0xaac>
800084ce:	fa c9 fa 35 	sub	r9,sp,-1483
800084d2:	30 aa       	mov	r10,10
800084d4:	12 98       	mov	r8,r9
800084d6:	0e 9c       	mov	r12,r7
800084d8:	0c 92       	mov	r2,r6
800084da:	f6 0a 0c 06 	divs	r6,r11,r10
800084de:	0e 9b       	mov	r11,r7
800084e0:	2d 0b       	sub	r11,-48
800084e2:	10 fb       	st.b	--r8,r11
800084e4:	0c 9b       	mov	r11,r6
800084e6:	58 96       	cp.w	r6,9
800084e8:	fe 99 ff f9 	brgt	800084da <_vfprintf_r+0xa82>
800084ec:	2d 0b       	sub	r11,-48
800084ee:	18 97       	mov	r7,r12
800084f0:	04 96       	mov	r6,r2
800084f2:	10 fb       	st.b	--r8,r11
800084f4:	fa ca f9 62 	sub	r10,sp,-1694
800084f8:	c0 38       	rjmp	800084fe <_vfprintf_r+0xaa6>
800084fa:	11 3b       	ld.ub	r11,r8++
800084fc:	14 cb       	st.b	r10++,r11
800084fe:	12 38       	cp.w	r8,r9
80008500:	cf d3       	brcs	800084fa <_vfprintf_r+0xaa2>
80008502:	c0 98       	rjmp	80008514 <_vfprintf_r+0xabc>
80008504:	2d 0b       	sub	r11,-48
80008506:	33 08       	mov	r8,48
80008508:	fb 6b 06 9f 	st.b	sp[1695],r11
8000850c:	fb 68 06 9e 	st.b	sp[1694],r8
80008510:	fa ca f9 60 	sub	r10,sp,-1696
80008514:	fa c8 f9 64 	sub	r8,sp,-1692
80008518:	f4 08 01 08 	sub	r8,r10,r8
8000851c:	50 e8       	stdsp	sp[0x38],r8
8000851e:	10 92       	mov	r2,r8
80008520:	40 6b       	lddsp	r11,sp[0x18]
80008522:	16 02       	add	r2,r11
80008524:	58 1b       	cp.w	r11,1
80008526:	e0 89 00 05 	brgt	80008530 <_vfprintf_r+0xad8>
8000852a:	ed b5 00 00 	bld	r5,0x0
8000852e:	c3 51       	brne	80008598 <_vfprintf_r+0xb40>
80008530:	2f f2       	sub	r2,-1
80008532:	c3 38       	rjmp	80008598 <_vfprintf_r+0xb40>
80008534:	e0 40 00 66 	cp.w	r0,102
80008538:	c1 c1       	brne	80008570 <_vfprintf_r+0xb18>
8000853a:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000853e:	58 02       	cp.w	r2,0
80008540:	e0 8a 00 0c 	brle	80008558 <_vfprintf_r+0xb00>
80008544:	40 2a       	lddsp	r10,sp[0x8]
80008546:	58 0a       	cp.w	r10,0
80008548:	c0 41       	brne	80008550 <_vfprintf_r+0xaf8>
8000854a:	ed b5 00 00 	bld	r5,0x0
8000854e:	c2 51       	brne	80008598 <_vfprintf_r+0xb40>
80008550:	2f f2       	sub	r2,-1
80008552:	40 29       	lddsp	r9,sp[0x8]
80008554:	12 02       	add	r2,r9
80008556:	c0 b8       	rjmp	8000856c <_vfprintf_r+0xb14>
80008558:	40 28       	lddsp	r8,sp[0x8]
8000855a:	58 08       	cp.w	r8,0
8000855c:	c0 61       	brne	80008568 <_vfprintf_r+0xb10>
8000855e:	ed b5 00 00 	bld	r5,0x0
80008562:	c0 30       	breq	80008568 <_vfprintf_r+0xb10>
80008564:	30 12       	mov	r2,1
80008566:	c1 98       	rjmp	80008598 <_vfprintf_r+0xb40>
80008568:	40 22       	lddsp	r2,sp[0x8]
8000856a:	2f e2       	sub	r2,-2
8000856c:	36 60       	mov	r0,102
8000856e:	c1 58       	rjmp	80008598 <_vfprintf_r+0xb40>
80008570:	fa f2 06 ac 	ld.w	r2,sp[1708]
80008574:	40 6e       	lddsp	lr,sp[0x18]
80008576:	1c 32       	cp.w	r2,lr
80008578:	c0 65       	brlt	80008584 <_vfprintf_r+0xb2c>
8000857a:	ed b5 00 00 	bld	r5,0x0
8000857e:	f7 b2 00 ff 	subeq	r2,-1
80008582:	c0 a8       	rjmp	80008596 <_vfprintf_r+0xb3e>
80008584:	e4 08 11 02 	rsub	r8,r2,2
80008588:	40 6c       	lddsp	r12,sp[0x18]
8000858a:	58 02       	cp.w	r2,0
8000858c:	f0 02 17 a0 	movle	r2,r8
80008590:	f9 b2 09 01 	movgt	r2,1
80008594:	18 02       	add	r2,r12
80008596:	36 70       	mov	r0,103
80008598:	40 9b       	lddsp	r11,sp[0x24]
8000859a:	58 0b       	cp.w	r11,0
8000859c:	e0 80 05 94 	breq	800090c4 <_vfprintf_r+0x166c>
800085a0:	32 d8       	mov	r8,45
800085a2:	fb 68 06 bb 	st.b	sp[1723],r8
800085a6:	e0 8f 05 93 	bral	800090cc <_vfprintf_r+0x1674>
800085aa:	50 a7       	stdsp	sp[0x28],r7
800085ac:	04 94       	mov	r4,r2
800085ae:	0c 97       	mov	r7,r6
800085b0:	02 92       	mov	r2,r1
800085b2:	06 96       	mov	r6,r3
800085b4:	40 41       	lddsp	r1,sp[0x10]
800085b6:	40 93       	lddsp	r3,sp[0x24]
800085b8:	0e 99       	mov	r9,r7
800085ba:	ed b5 00 05 	bld	r5,0x5
800085be:	c4 81       	brne	8000864e <_vfprintf_r+0xbf6>
800085c0:	fa f8 06 b4 	ld.w	r8,sp[1716]
800085c4:	40 3e       	lddsp	lr,sp[0xc]
800085c6:	58 0e       	cp.w	lr,0
800085c8:	c1 d0       	breq	80008602 <_vfprintf_r+0xbaa>
800085ca:	10 36       	cp.w	r6,r8
800085cc:	c0 64       	brge	800085d8 <_vfprintf_r+0xb80>
800085ce:	fa cc f9 44 	sub	r12,sp,-1724
800085d2:	f8 06 00 36 	add	r6,r12,r6<<0x3
800085d6:	c1 d8       	rjmp	80008610 <_vfprintf_r+0xbb8>
800085d8:	fa c8 f9 50 	sub	r8,sp,-1712
800085dc:	1a d8       	st.w	--sp,r8
800085de:	fa c8 fa b8 	sub	r8,sp,-1352
800085e2:	04 9a       	mov	r10,r2
800085e4:	1a d8       	st.w	--sp,r8
800085e6:	fa c8 fb b4 	sub	r8,sp,-1100
800085ea:	0c 9b       	mov	r11,r6
800085ec:	1a d8       	st.w	--sp,r8
800085ee:	08 9c       	mov	r12,r4
800085f0:	fa c8 f9 40 	sub	r8,sp,-1728
800085f4:	fa c9 ff b4 	sub	r9,sp,-76
800085f8:	fe b0 f8 92 	rcall	8000771c <get_arg>
800085fc:	2f dd       	sub	sp,-12
800085fe:	78 0a       	ld.w	r10,r12[0x0]
80008600:	c2 08       	rjmp	80008640 <_vfprintf_r+0xbe8>
80008602:	2f f7       	sub	r7,-1
80008604:	10 39       	cp.w	r9,r8
80008606:	c0 84       	brge	80008616 <_vfprintf_r+0xbbe>
80008608:	fa cb f9 44 	sub	r11,sp,-1724
8000860c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008610:	ec fa fd 88 	ld.w	r10,r6[-632]
80008614:	c1 68       	rjmp	80008640 <_vfprintf_r+0xbe8>
80008616:	41 09       	lddsp	r9,sp[0x40]
80008618:	59 f8       	cp.w	r8,31
8000861a:	e0 89 00 10 	brgt	8000863a <_vfprintf_r+0xbe2>
8000861e:	f2 ca ff fc 	sub	r10,r9,-4
80008622:	51 0a       	stdsp	sp[0x40],r10
80008624:	fa c6 f9 44 	sub	r6,sp,-1724
80008628:	72 0a       	ld.w	r10,r9[0x0]
8000862a:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000862e:	f3 4a fd 88 	st.w	r9[-632],r10
80008632:	2f f8       	sub	r8,-1
80008634:	fb 48 06 b4 	st.w	sp[1716],r8
80008638:	c0 48       	rjmp	80008640 <_vfprintf_r+0xbe8>
8000863a:	72 0a       	ld.w	r10,r9[0x0]
8000863c:	2f c9       	sub	r9,-4
8000863e:	51 09       	stdsp	sp[0x40],r9
80008640:	40 be       	lddsp	lr,sp[0x2c]
80008642:	1c 98       	mov	r8,lr
80008644:	95 1e       	st.w	r10[0x4],lr
80008646:	bf 58       	asr	r8,0x1f
80008648:	95 08       	st.w	r10[0x0],r8
8000864a:	fe 9f fa 92 	bral	80007b6e <_vfprintf_r+0x116>
8000864e:	ed b5 00 04 	bld	r5,0x4
80008652:	c4 80       	breq	800086e2 <_vfprintf_r+0xc8a>
80008654:	e2 15 00 40 	andl	r5,0x40,COH
80008658:	c4 50       	breq	800086e2 <_vfprintf_r+0xc8a>
8000865a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000865e:	40 3c       	lddsp	r12,sp[0xc]
80008660:	58 0c       	cp.w	r12,0
80008662:	c1 d0       	breq	8000869c <_vfprintf_r+0xc44>
80008664:	10 36       	cp.w	r6,r8
80008666:	c0 64       	brge	80008672 <_vfprintf_r+0xc1a>
80008668:	fa cb f9 44 	sub	r11,sp,-1724
8000866c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008670:	c1 d8       	rjmp	800086aa <_vfprintf_r+0xc52>
80008672:	fa c8 f9 50 	sub	r8,sp,-1712
80008676:	1a d8       	st.w	--sp,r8
80008678:	fa c8 fa b8 	sub	r8,sp,-1352
8000867c:	04 9a       	mov	r10,r2
8000867e:	1a d8       	st.w	--sp,r8
80008680:	fa c8 fb b4 	sub	r8,sp,-1100
80008684:	0c 9b       	mov	r11,r6
80008686:	1a d8       	st.w	--sp,r8
80008688:	08 9c       	mov	r12,r4
8000868a:	fa c8 f9 40 	sub	r8,sp,-1728
8000868e:	fa c9 ff b4 	sub	r9,sp,-76
80008692:	fe b0 f8 45 	rcall	8000771c <get_arg>
80008696:	2f dd       	sub	sp,-12
80008698:	78 0a       	ld.w	r10,r12[0x0]
8000869a:	c2 08       	rjmp	800086da <_vfprintf_r+0xc82>
8000869c:	2f f7       	sub	r7,-1
8000869e:	10 39       	cp.w	r9,r8
800086a0:	c0 84       	brge	800086b0 <_vfprintf_r+0xc58>
800086a2:	fa ca f9 44 	sub	r10,sp,-1724
800086a6:	f4 06 00 36 	add	r6,r10,r6<<0x3
800086aa:	ec fa fd 88 	ld.w	r10,r6[-632]
800086ae:	c1 68       	rjmp	800086da <_vfprintf_r+0xc82>
800086b0:	41 09       	lddsp	r9,sp[0x40]
800086b2:	59 f8       	cp.w	r8,31
800086b4:	e0 89 00 10 	brgt	800086d4 <_vfprintf_r+0xc7c>
800086b8:	f2 ca ff fc 	sub	r10,r9,-4
800086bc:	51 0a       	stdsp	sp[0x40],r10
800086be:	fa c6 f9 44 	sub	r6,sp,-1724
800086c2:	72 0a       	ld.w	r10,r9[0x0]
800086c4:	ec 08 00 39 	add	r9,r6,r8<<0x3
800086c8:	f3 4a fd 88 	st.w	r9[-632],r10
800086cc:	2f f8       	sub	r8,-1
800086ce:	fb 48 06 b4 	st.w	sp[1716],r8
800086d2:	c0 48       	rjmp	800086da <_vfprintf_r+0xc82>
800086d4:	72 0a       	ld.w	r10,r9[0x0]
800086d6:	2f c9       	sub	r9,-4
800086d8:	51 09       	stdsp	sp[0x40],r9
800086da:	40 be       	lddsp	lr,sp[0x2c]
800086dc:	b4 0e       	st.h	r10[0x0],lr
800086de:	fe 9f fa 48 	bral	80007b6e <_vfprintf_r+0x116>
800086e2:	fa f8 06 b4 	ld.w	r8,sp[1716]
800086e6:	40 3c       	lddsp	r12,sp[0xc]
800086e8:	58 0c       	cp.w	r12,0
800086ea:	c1 d0       	breq	80008724 <_vfprintf_r+0xccc>
800086ec:	10 36       	cp.w	r6,r8
800086ee:	c0 64       	brge	800086fa <_vfprintf_r+0xca2>
800086f0:	fa cb f9 44 	sub	r11,sp,-1724
800086f4:	f6 06 00 36 	add	r6,r11,r6<<0x3
800086f8:	c1 d8       	rjmp	80008732 <_vfprintf_r+0xcda>
800086fa:	fa c8 f9 50 	sub	r8,sp,-1712
800086fe:	1a d8       	st.w	--sp,r8
80008700:	fa c8 fa b8 	sub	r8,sp,-1352
80008704:	04 9a       	mov	r10,r2
80008706:	1a d8       	st.w	--sp,r8
80008708:	fa c8 fb b4 	sub	r8,sp,-1100
8000870c:	0c 9b       	mov	r11,r6
8000870e:	1a d8       	st.w	--sp,r8
80008710:	08 9c       	mov	r12,r4
80008712:	fa c8 f9 40 	sub	r8,sp,-1728
80008716:	fa c9 ff b4 	sub	r9,sp,-76
8000871a:	fe b0 f8 01 	rcall	8000771c <get_arg>
8000871e:	2f dd       	sub	sp,-12
80008720:	78 0a       	ld.w	r10,r12[0x0]
80008722:	c2 08       	rjmp	80008762 <_vfprintf_r+0xd0a>
80008724:	2f f7       	sub	r7,-1
80008726:	10 39       	cp.w	r9,r8
80008728:	c0 84       	brge	80008738 <_vfprintf_r+0xce0>
8000872a:	fa ca f9 44 	sub	r10,sp,-1724
8000872e:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008732:	ec fa fd 88 	ld.w	r10,r6[-632]
80008736:	c1 68       	rjmp	80008762 <_vfprintf_r+0xd0a>
80008738:	41 09       	lddsp	r9,sp[0x40]
8000873a:	59 f8       	cp.w	r8,31
8000873c:	e0 89 00 10 	brgt	8000875c <_vfprintf_r+0xd04>
80008740:	f2 ca ff fc 	sub	r10,r9,-4
80008744:	51 0a       	stdsp	sp[0x40],r10
80008746:	fa c6 f9 44 	sub	r6,sp,-1724
8000874a:	72 0a       	ld.w	r10,r9[0x0]
8000874c:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008750:	f3 4a fd 88 	st.w	r9[-632],r10
80008754:	2f f8       	sub	r8,-1
80008756:	fb 48 06 b4 	st.w	sp[1716],r8
8000875a:	c0 48       	rjmp	80008762 <_vfprintf_r+0xd0a>
8000875c:	72 0a       	ld.w	r10,r9[0x0]
8000875e:	2f c9       	sub	r9,-4
80008760:	51 09       	stdsp	sp[0x40],r9
80008762:	40 be       	lddsp	lr,sp[0x2c]
80008764:	95 0e       	st.w	r10[0x0],lr
80008766:	fe 9f fa 04 	bral	80007b6e <_vfprintf_r+0x116>
8000876a:	50 a7       	stdsp	sp[0x28],r7
8000876c:	50 80       	stdsp	sp[0x20],r0
8000876e:	0c 97       	mov	r7,r6
80008770:	04 94       	mov	r4,r2
80008772:	06 96       	mov	r6,r3
80008774:	02 92       	mov	r2,r1
80008776:	40 93       	lddsp	r3,sp[0x24]
80008778:	10 90       	mov	r0,r8
8000877a:	40 41       	lddsp	r1,sp[0x10]
8000877c:	a5 a5       	sbr	r5,0x4
8000877e:	c0 a8       	rjmp	80008792 <_vfprintf_r+0xd3a>
80008780:	50 a7       	stdsp	sp[0x28],r7
80008782:	50 80       	stdsp	sp[0x20],r0
80008784:	0c 97       	mov	r7,r6
80008786:	04 94       	mov	r4,r2
80008788:	06 96       	mov	r6,r3
8000878a:	02 92       	mov	r2,r1
8000878c:	40 93       	lddsp	r3,sp[0x24]
8000878e:	10 90       	mov	r0,r8
80008790:	40 41       	lddsp	r1,sp[0x10]
80008792:	ed b5 00 05 	bld	r5,0x5
80008796:	c5 d1       	brne	80008850 <_vfprintf_r+0xdf8>
80008798:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000879c:	40 3c       	lddsp	r12,sp[0xc]
8000879e:	58 0c       	cp.w	r12,0
800087a0:	c2 60       	breq	800087ec <_vfprintf_r+0xd94>
800087a2:	10 36       	cp.w	r6,r8
800087a4:	c0 a4       	brge	800087b8 <_vfprintf_r+0xd60>
800087a6:	fa cb f9 44 	sub	r11,sp,-1724
800087aa:	f6 06 00 36 	add	r6,r11,r6<<0x3
800087ae:	ec e8 fd 88 	ld.d	r8,r6[-632]
800087b2:	fa e9 00 00 	st.d	sp[0],r8
800087b6:	c1 88       	rjmp	800087e6 <_vfprintf_r+0xd8e>
800087b8:	fa c8 f9 50 	sub	r8,sp,-1712
800087bc:	1a d8       	st.w	--sp,r8
800087be:	fa c8 fa b8 	sub	r8,sp,-1352
800087c2:	04 9a       	mov	r10,r2
800087c4:	1a d8       	st.w	--sp,r8
800087c6:	0c 9b       	mov	r11,r6
800087c8:	fa c8 fb b4 	sub	r8,sp,-1100
800087cc:	08 9c       	mov	r12,r4
800087ce:	1a d8       	st.w	--sp,r8
800087d0:	fa c8 f9 40 	sub	r8,sp,-1728
800087d4:	fa c9 ff b4 	sub	r9,sp,-76
800087d8:	fe b0 f7 a2 	rcall	8000771c <get_arg>
800087dc:	2f dd       	sub	sp,-12
800087de:	f8 ea 00 00 	ld.d	r10,r12[0]
800087e2:	fa eb 00 00 	st.d	sp[0],r10
800087e6:	30 08       	mov	r8,0
800087e8:	e0 8f 03 de 	bral	80008fa4 <_vfprintf_r+0x154c>
800087ec:	ee ca ff ff 	sub	r10,r7,-1
800087f0:	10 37       	cp.w	r7,r8
800087f2:	c0 b4       	brge	80008808 <_vfprintf_r+0xdb0>
800087f4:	fa c9 f9 44 	sub	r9,sp,-1724
800087f8:	14 97       	mov	r7,r10
800087fa:	f2 06 00 36 	add	r6,r9,r6<<0x3
800087fe:	ec ea fd 88 	ld.d	r10,r6[-632]
80008802:	fa eb 00 00 	st.d	sp[0],r10
80008806:	c1 88       	rjmp	80008836 <_vfprintf_r+0xdde>
80008808:	41 09       	lddsp	r9,sp[0x40]
8000880a:	59 f8       	cp.w	r8,31
8000880c:	e0 89 00 18 	brgt	8000883c <_vfprintf_r+0xde4>
80008810:	f2 e6 00 00 	ld.d	r6,r9[0]
80008814:	f2 cb ff f8 	sub	r11,r9,-8
80008818:	fa e7 00 00 	st.d	sp[0],r6
8000881c:	51 0b       	stdsp	sp[0x40],r11
8000881e:	fa c6 f9 44 	sub	r6,sp,-1724
80008822:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008826:	fa e6 00 00 	ld.d	r6,sp[0]
8000882a:	f2 e7 fd 88 	st.d	r9[-632],r6
8000882e:	2f f8       	sub	r8,-1
80008830:	14 97       	mov	r7,r10
80008832:	fb 48 06 b4 	st.w	sp[1716],r8
80008836:	40 38       	lddsp	r8,sp[0xc]
80008838:	e0 8f 03 b6 	bral	80008fa4 <_vfprintf_r+0x154c>
8000883c:	f2 e6 00 00 	ld.d	r6,r9[0]
80008840:	40 38       	lddsp	r8,sp[0xc]
80008842:	fa e7 00 00 	st.d	sp[0],r6
80008846:	2f 89       	sub	r9,-8
80008848:	14 97       	mov	r7,r10
8000884a:	51 09       	stdsp	sp[0x40],r9
8000884c:	e0 8f 03 ac 	bral	80008fa4 <_vfprintf_r+0x154c>
80008850:	ed b5 00 04 	bld	r5,0x4
80008854:	c1 61       	brne	80008880 <_vfprintf_r+0xe28>
80008856:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000885a:	40 3e       	lddsp	lr,sp[0xc]
8000885c:	58 0e       	cp.w	lr,0
8000885e:	c0 80       	breq	8000886e <_vfprintf_r+0xe16>
80008860:	10 36       	cp.w	r6,r8
80008862:	c6 74       	brge	80008930 <_vfprintf_r+0xed8>
80008864:	fa cc f9 44 	sub	r12,sp,-1724
80008868:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000886c:	c8 08       	rjmp	8000896c <_vfprintf_r+0xf14>
8000886e:	ee ca ff ff 	sub	r10,r7,-1
80008872:	10 37       	cp.w	r7,r8
80008874:	c7 f4       	brge	80008972 <_vfprintf_r+0xf1a>
80008876:	fa cb f9 44 	sub	r11,sp,-1724
8000887a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000887e:	c7 68       	rjmp	8000896a <_vfprintf_r+0xf12>
80008880:	ed b5 00 06 	bld	r5,0x6
80008884:	c4 a1       	brne	80008918 <_vfprintf_r+0xec0>
80008886:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000888a:	40 3c       	lddsp	r12,sp[0xc]
8000888c:	58 0c       	cp.w	r12,0
8000888e:	c1 d0       	breq	800088c8 <_vfprintf_r+0xe70>
80008890:	10 36       	cp.w	r6,r8
80008892:	c0 64       	brge	8000889e <_vfprintf_r+0xe46>
80008894:	fa cb f9 44 	sub	r11,sp,-1724
80008898:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000889c:	c1 f8       	rjmp	800088da <_vfprintf_r+0xe82>
8000889e:	fa c8 f9 50 	sub	r8,sp,-1712
800088a2:	1a d8       	st.w	--sp,r8
800088a4:	fa c8 fa b8 	sub	r8,sp,-1352
800088a8:	1a d8       	st.w	--sp,r8
800088aa:	fa c8 fb b4 	sub	r8,sp,-1100
800088ae:	1a d8       	st.w	--sp,r8
800088b0:	fa c8 f9 40 	sub	r8,sp,-1728
800088b4:	fa c9 ff b4 	sub	r9,sp,-76
800088b8:	04 9a       	mov	r10,r2
800088ba:	0c 9b       	mov	r11,r6
800088bc:	08 9c       	mov	r12,r4
800088be:	fe b0 f7 2f 	rcall	8000771c <get_arg>
800088c2:	2f dd       	sub	sp,-12
800088c4:	98 18       	ld.sh	r8,r12[0x2]
800088c6:	c2 68       	rjmp	80008912 <_vfprintf_r+0xeba>
800088c8:	ee ca ff ff 	sub	r10,r7,-1
800088cc:	10 37       	cp.w	r7,r8
800088ce:	c0 94       	brge	800088e0 <_vfprintf_r+0xe88>
800088d0:	fa c9 f9 44 	sub	r9,sp,-1724
800088d4:	14 97       	mov	r7,r10
800088d6:	f2 06 00 36 	add	r6,r9,r6<<0x3
800088da:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
800088de:	c1 a8       	rjmp	80008912 <_vfprintf_r+0xeba>
800088e0:	41 09       	lddsp	r9,sp[0x40]
800088e2:	59 f8       	cp.w	r8,31
800088e4:	e0 89 00 13 	brgt	8000890a <_vfprintf_r+0xeb2>
800088e8:	f2 cb ff fc 	sub	r11,r9,-4
800088ec:	51 0b       	stdsp	sp[0x40],r11
800088ee:	72 09       	ld.w	r9,r9[0x0]
800088f0:	fa c6 f9 44 	sub	r6,sp,-1724
800088f4:	ec 08 00 3b 	add	r11,r6,r8<<0x3
800088f8:	2f f8       	sub	r8,-1
800088fa:	f7 49 fd 88 	st.w	r11[-632],r9
800088fe:	fb 48 06 b4 	st.w	sp[1716],r8
80008902:	14 97       	mov	r7,r10
80008904:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008908:	c0 58       	rjmp	80008912 <_vfprintf_r+0xeba>
8000890a:	92 18       	ld.sh	r8,r9[0x2]
8000890c:	14 97       	mov	r7,r10
8000890e:	2f c9       	sub	r9,-4
80008910:	51 09       	stdsp	sp[0x40],r9
80008912:	5c 78       	castu.h	r8
80008914:	50 18       	stdsp	sp[0x4],r8
80008916:	c4 68       	rjmp	800089a2 <_vfprintf_r+0xf4a>
80008918:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000891c:	40 3c       	lddsp	r12,sp[0xc]
8000891e:	58 0c       	cp.w	r12,0
80008920:	c1 d0       	breq	8000895a <_vfprintf_r+0xf02>
80008922:	10 36       	cp.w	r6,r8
80008924:	c0 64       	brge	80008930 <_vfprintf_r+0xed8>
80008926:	fa cb f9 44 	sub	r11,sp,-1724
8000892a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000892e:	c1 f8       	rjmp	8000896c <_vfprintf_r+0xf14>
80008930:	fa c8 f9 50 	sub	r8,sp,-1712
80008934:	1a d8       	st.w	--sp,r8
80008936:	fa c8 fa b8 	sub	r8,sp,-1352
8000893a:	0c 9b       	mov	r11,r6
8000893c:	1a d8       	st.w	--sp,r8
8000893e:	fa c8 fb b4 	sub	r8,sp,-1100
80008942:	04 9a       	mov	r10,r2
80008944:	1a d8       	st.w	--sp,r8
80008946:	08 9c       	mov	r12,r4
80008948:	fa c8 f9 40 	sub	r8,sp,-1728
8000894c:	fa c9 ff b4 	sub	r9,sp,-76
80008950:	fe b0 f6 e6 	rcall	8000771c <get_arg>
80008954:	2f dd       	sub	sp,-12
80008956:	78 0b       	ld.w	r11,r12[0x0]
80008958:	c2 48       	rjmp	800089a0 <_vfprintf_r+0xf48>
8000895a:	ee ca ff ff 	sub	r10,r7,-1
8000895e:	10 37       	cp.w	r7,r8
80008960:	c0 94       	brge	80008972 <_vfprintf_r+0xf1a>
80008962:	fa c9 f9 44 	sub	r9,sp,-1724
80008966:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000896a:	14 97       	mov	r7,r10
8000896c:	ec fb fd 88 	ld.w	r11,r6[-632]
80008970:	c1 88       	rjmp	800089a0 <_vfprintf_r+0xf48>
80008972:	41 09       	lddsp	r9,sp[0x40]
80008974:	59 f8       	cp.w	r8,31
80008976:	e0 89 00 11 	brgt	80008998 <_vfprintf_r+0xf40>
8000897a:	f2 cb ff fc 	sub	r11,r9,-4
8000897e:	51 0b       	stdsp	sp[0x40],r11
80008980:	fa c6 f9 44 	sub	r6,sp,-1724
80008984:	72 0b       	ld.w	r11,r9[0x0]
80008986:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000898a:	f3 4b fd 88 	st.w	r9[-632],r11
8000898e:	2f f8       	sub	r8,-1
80008990:	14 97       	mov	r7,r10
80008992:	fb 48 06 b4 	st.w	sp[1716],r8
80008996:	c0 58       	rjmp	800089a0 <_vfprintf_r+0xf48>
80008998:	72 0b       	ld.w	r11,r9[0x0]
8000899a:	14 97       	mov	r7,r10
8000899c:	2f c9       	sub	r9,-4
8000899e:	51 09       	stdsp	sp[0x40],r9
800089a0:	50 1b       	stdsp	sp[0x4],r11
800089a2:	30 0e       	mov	lr,0
800089a4:	50 0e       	stdsp	sp[0x0],lr
800089a6:	1c 98       	mov	r8,lr
800089a8:	e0 8f 02 fe 	bral	80008fa4 <_vfprintf_r+0x154c>
800089ac:	50 a7       	stdsp	sp[0x28],r7
800089ae:	50 80       	stdsp	sp[0x20],r0
800089b0:	0c 97       	mov	r7,r6
800089b2:	04 94       	mov	r4,r2
800089b4:	06 96       	mov	r6,r3
800089b6:	02 92       	mov	r2,r1
800089b8:	40 93       	lddsp	r3,sp[0x24]
800089ba:	40 41       	lddsp	r1,sp[0x10]
800089bc:	0e 99       	mov	r9,r7
800089be:	fa f8 06 b4 	ld.w	r8,sp[1716]
800089c2:	40 3c       	lddsp	r12,sp[0xc]
800089c4:	58 0c       	cp.w	r12,0
800089c6:	c1 d0       	breq	80008a00 <_vfprintf_r+0xfa8>
800089c8:	10 36       	cp.w	r6,r8
800089ca:	c0 64       	brge	800089d6 <_vfprintf_r+0xf7e>
800089cc:	fa cb f9 44 	sub	r11,sp,-1724
800089d0:	f6 06 00 36 	add	r6,r11,r6<<0x3
800089d4:	c1 d8       	rjmp	80008a0e <_vfprintf_r+0xfb6>
800089d6:	fa c8 f9 50 	sub	r8,sp,-1712
800089da:	1a d8       	st.w	--sp,r8
800089dc:	fa c8 fa b8 	sub	r8,sp,-1352
800089e0:	1a d8       	st.w	--sp,r8
800089e2:	fa c8 fb b4 	sub	r8,sp,-1100
800089e6:	1a d8       	st.w	--sp,r8
800089e8:	fa c9 ff b4 	sub	r9,sp,-76
800089ec:	fa c8 f9 40 	sub	r8,sp,-1728
800089f0:	04 9a       	mov	r10,r2
800089f2:	0c 9b       	mov	r11,r6
800089f4:	08 9c       	mov	r12,r4
800089f6:	fe b0 f6 93 	rcall	8000771c <get_arg>
800089fa:	2f dd       	sub	sp,-12
800089fc:	78 09       	ld.w	r9,r12[0x0]
800089fe:	c2 18       	rjmp	80008a40 <_vfprintf_r+0xfe8>
80008a00:	2f f7       	sub	r7,-1
80008a02:	10 39       	cp.w	r9,r8
80008a04:	c0 84       	brge	80008a14 <_vfprintf_r+0xfbc>
80008a06:	fa ca f9 44 	sub	r10,sp,-1724
80008a0a:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008a0e:	ec f9 fd 88 	ld.w	r9,r6[-632]
80008a12:	c1 78       	rjmp	80008a40 <_vfprintf_r+0xfe8>
80008a14:	41 09       	lddsp	r9,sp[0x40]
80008a16:	59 f8       	cp.w	r8,31
80008a18:	e0 89 00 10 	brgt	80008a38 <_vfprintf_r+0xfe0>
80008a1c:	f2 ca ff fc 	sub	r10,r9,-4
80008a20:	51 0a       	stdsp	sp[0x40],r10
80008a22:	fa c6 f9 44 	sub	r6,sp,-1724
80008a26:	72 09       	ld.w	r9,r9[0x0]
80008a28:	ec 08 00 3a 	add	r10,r6,r8<<0x3
80008a2c:	f5 49 fd 88 	st.w	r10[-632],r9
80008a30:	2f f8       	sub	r8,-1
80008a32:	fb 48 06 b4 	st.w	sp[1716],r8
80008a36:	c0 58       	rjmp	80008a40 <_vfprintf_r+0xfe8>
80008a38:	f2 c8 ff fc 	sub	r8,r9,-4
80008a3c:	51 08       	stdsp	sp[0x40],r8
80008a3e:	72 09       	ld.w	r9,r9[0x0]
80008a40:	33 08       	mov	r8,48
80008a42:	fb 68 06 b8 	st.b	sp[1720],r8
80008a46:	37 88       	mov	r8,120
80008a48:	30 0e       	mov	lr,0
80008a4a:	fb 68 06 b9 	st.b	sp[1721],r8
80008a4e:	4c ac       	lddpc	r12,80008b74 <_vfprintf_r+0x111c>
80008a50:	50 19       	stdsp	sp[0x4],r9
80008a52:	a1 b5       	sbr	r5,0x1
80008a54:	50 0e       	stdsp	sp[0x0],lr
80008a56:	50 dc       	stdsp	sp[0x34],r12
80008a58:	30 28       	mov	r8,2
80008a5a:	37 80       	mov	r0,120
80008a5c:	e0 8f 02 a4 	bral	80008fa4 <_vfprintf_r+0x154c>
80008a60:	50 a7       	stdsp	sp[0x28],r7
80008a62:	50 80       	stdsp	sp[0x20],r0
80008a64:	10 90       	mov	r0,r8
80008a66:	30 08       	mov	r8,0
80008a68:	fb 68 06 bb 	st.b	sp[1723],r8
80008a6c:	0c 97       	mov	r7,r6
80008a6e:	04 94       	mov	r4,r2
80008a70:	06 96       	mov	r6,r3
80008a72:	02 92       	mov	r2,r1
80008a74:	40 93       	lddsp	r3,sp[0x24]
80008a76:	40 41       	lddsp	r1,sp[0x10]
80008a78:	0e 99       	mov	r9,r7
80008a7a:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008a7e:	40 3b       	lddsp	r11,sp[0xc]
80008a80:	58 0b       	cp.w	r11,0
80008a82:	c1 d0       	breq	80008abc <_vfprintf_r+0x1064>
80008a84:	10 36       	cp.w	r6,r8
80008a86:	c0 64       	brge	80008a92 <_vfprintf_r+0x103a>
80008a88:	fa ca f9 44 	sub	r10,sp,-1724
80008a8c:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008a90:	c1 d8       	rjmp	80008aca <_vfprintf_r+0x1072>
80008a92:	fa c8 f9 50 	sub	r8,sp,-1712
80008a96:	1a d8       	st.w	--sp,r8
80008a98:	fa c8 fa b8 	sub	r8,sp,-1352
80008a9c:	1a d8       	st.w	--sp,r8
80008a9e:	fa c8 fb b4 	sub	r8,sp,-1100
80008aa2:	0c 9b       	mov	r11,r6
80008aa4:	1a d8       	st.w	--sp,r8
80008aa6:	04 9a       	mov	r10,r2
80008aa8:	fa c8 f9 40 	sub	r8,sp,-1728
80008aac:	fa c9 ff b4 	sub	r9,sp,-76
80008ab0:	08 9c       	mov	r12,r4
80008ab2:	fe b0 f6 35 	rcall	8000771c <get_arg>
80008ab6:	2f dd       	sub	sp,-12
80008ab8:	78 06       	ld.w	r6,r12[0x0]
80008aba:	c2 08       	rjmp	80008afa <_vfprintf_r+0x10a2>
80008abc:	2f f7       	sub	r7,-1
80008abe:	10 39       	cp.w	r9,r8
80008ac0:	c0 84       	brge	80008ad0 <_vfprintf_r+0x1078>
80008ac2:	fa c9 f9 44 	sub	r9,sp,-1724
80008ac6:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008aca:	ec f6 fd 88 	ld.w	r6,r6[-632]
80008ace:	c1 68       	rjmp	80008afa <_vfprintf_r+0x10a2>
80008ad0:	41 09       	lddsp	r9,sp[0x40]
80008ad2:	59 f8       	cp.w	r8,31
80008ad4:	e0 89 00 10 	brgt	80008af4 <_vfprintf_r+0x109c>
80008ad8:	f2 ca ff fc 	sub	r10,r9,-4
80008adc:	51 0a       	stdsp	sp[0x40],r10
80008ade:	72 06       	ld.w	r6,r9[0x0]
80008ae0:	fa ce f9 44 	sub	lr,sp,-1724
80008ae4:	fc 08 00 39 	add	r9,lr,r8<<0x3
80008ae8:	f3 46 fd 88 	st.w	r9[-632],r6
80008aec:	2f f8       	sub	r8,-1
80008aee:	fb 48 06 b4 	st.w	sp[1716],r8
80008af2:	c0 48       	rjmp	80008afa <_vfprintf_r+0x10a2>
80008af4:	72 06       	ld.w	r6,r9[0x0]
80008af6:	2f c9       	sub	r9,-4
80008af8:	51 09       	stdsp	sp[0x40],r9
80008afa:	40 2c       	lddsp	r12,sp[0x8]
80008afc:	58 0c       	cp.w	r12,0
80008afe:	c1 05       	brlt	80008b1e <_vfprintf_r+0x10c6>
80008b00:	18 9a       	mov	r10,r12
80008b02:	30 0b       	mov	r11,0
80008b04:	0c 9c       	mov	r12,r6
80008b06:	e0 a0 12 43 	rcall	8000af8c <memchr>
80008b0a:	e0 80 02 e0 	breq	800090ca <_vfprintf_r+0x1672>
80008b0e:	f8 06 01 02 	sub	r2,r12,r6
80008b12:	40 2b       	lddsp	r11,sp[0x8]
80008b14:	16 32       	cp.w	r2,r11
80008b16:	e0 89 02 da 	brgt	800090ca <_vfprintf_r+0x1672>
80008b1a:	e0 8f 02 d5 	bral	800090c4 <_vfprintf_r+0x166c>
80008b1e:	30 0a       	mov	r10,0
80008b20:	0c 9c       	mov	r12,r6
80008b22:	50 2a       	stdsp	sp[0x8],r10
80008b24:	fe b0 f5 77 	rcall	80007612 <strlen>
80008b28:	18 92       	mov	r2,r12
80008b2a:	e0 8f 02 d3 	bral	800090d0 <_vfprintf_r+0x1678>
80008b2e:	50 a7       	stdsp	sp[0x28],r7
80008b30:	50 80       	stdsp	sp[0x20],r0
80008b32:	0c 97       	mov	r7,r6
80008b34:	04 94       	mov	r4,r2
80008b36:	06 96       	mov	r6,r3
80008b38:	02 92       	mov	r2,r1
80008b3a:	40 93       	lddsp	r3,sp[0x24]
80008b3c:	10 90       	mov	r0,r8
80008b3e:	40 41       	lddsp	r1,sp[0x10]
80008b40:	a5 a5       	sbr	r5,0x4
80008b42:	c0 a8       	rjmp	80008b56 <_vfprintf_r+0x10fe>
80008b44:	50 a7       	stdsp	sp[0x28],r7
80008b46:	50 80       	stdsp	sp[0x20],r0
80008b48:	0c 97       	mov	r7,r6
80008b4a:	04 94       	mov	r4,r2
80008b4c:	06 96       	mov	r6,r3
80008b4e:	02 92       	mov	r2,r1
80008b50:	40 93       	lddsp	r3,sp[0x24]
80008b52:	10 90       	mov	r0,r8
80008b54:	40 41       	lddsp	r1,sp[0x10]
80008b56:	ed b5 00 05 	bld	r5,0x5
80008b5a:	c5 71       	brne	80008c08 <_vfprintf_r+0x11b0>
80008b5c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008b60:	40 39       	lddsp	r9,sp[0xc]
80008b62:	58 09       	cp.w	r9,0
80008b64:	c2 20       	breq	80008ba8 <_vfprintf_r+0x1150>
80008b66:	10 36       	cp.w	r6,r8
80008b68:	c0 84       	brge	80008b78 <_vfprintf_r+0x1120>
80008b6a:	fa c8 f9 44 	sub	r8,sp,-1724
80008b6e:	f0 06 00 36 	add	r6,r8,r6<<0x3
80008b72:	c2 48       	rjmp	80008bba <_vfprintf_r+0x1162>
80008b74:	80 01       	ld.sh	r1,r0[0x0]
80008b76:	5d 98       	*unknown*
80008b78:	fa c8 f9 50 	sub	r8,sp,-1712
80008b7c:	1a d8       	st.w	--sp,r8
80008b7e:	fa c8 fa b8 	sub	r8,sp,-1352
80008b82:	1a d8       	st.w	--sp,r8
80008b84:	fa c8 fb b4 	sub	r8,sp,-1100
80008b88:	1a d8       	st.w	--sp,r8
80008b8a:	fa c8 f9 40 	sub	r8,sp,-1728
80008b8e:	fa c9 ff b4 	sub	r9,sp,-76
80008b92:	04 9a       	mov	r10,r2
80008b94:	0c 9b       	mov	r11,r6
80008b96:	08 9c       	mov	r12,r4
80008b98:	fe b0 f5 c2 	rcall	8000771c <get_arg>
80008b9c:	2f dd       	sub	sp,-12
80008b9e:	f8 e8 00 00 	ld.d	r8,r12[0]
80008ba2:	fa e9 00 00 	st.d	sp[0],r8
80008ba6:	c2 e8       	rjmp	80008c02 <_vfprintf_r+0x11aa>
80008ba8:	ee ca ff ff 	sub	r10,r7,-1
80008bac:	10 37       	cp.w	r7,r8
80008bae:	c0 b4       	brge	80008bc4 <_vfprintf_r+0x116c>
80008bb0:	fa c8 f9 44 	sub	r8,sp,-1724
80008bb4:	14 97       	mov	r7,r10
80008bb6:	f0 06 00 36 	add	r6,r8,r6<<0x3
80008bba:	ec ea fd 88 	ld.d	r10,r6[-632]
80008bbe:	fa eb 00 00 	st.d	sp[0],r10
80008bc2:	c2 08       	rjmp	80008c02 <_vfprintf_r+0x11aa>
80008bc4:	41 09       	lddsp	r9,sp[0x40]
80008bc6:	59 f8       	cp.w	r8,31
80008bc8:	e0 89 00 16 	brgt	80008bf4 <_vfprintf_r+0x119c>
80008bcc:	f2 e6 00 00 	ld.d	r6,r9[0]
80008bd0:	f2 cb ff f8 	sub	r11,r9,-8
80008bd4:	fa e7 00 00 	st.d	sp[0],r6
80008bd8:	51 0b       	stdsp	sp[0x40],r11
80008bda:	fa c6 f9 44 	sub	r6,sp,-1724
80008bde:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008be2:	fa e6 00 00 	ld.d	r6,sp[0]
80008be6:	f2 e7 fd 88 	st.d	r9[-632],r6
80008bea:	2f f8       	sub	r8,-1
80008bec:	14 97       	mov	r7,r10
80008bee:	fb 48 06 b4 	st.w	sp[1716],r8
80008bf2:	c0 88       	rjmp	80008c02 <_vfprintf_r+0x11aa>
80008bf4:	f2 e6 00 00 	ld.d	r6,r9[0]
80008bf8:	2f 89       	sub	r9,-8
80008bfa:	fa e7 00 00 	st.d	sp[0],r6
80008bfe:	51 09       	stdsp	sp[0x40],r9
80008c00:	14 97       	mov	r7,r10
80008c02:	30 18       	mov	r8,1
80008c04:	e0 8f 01 d0 	bral	80008fa4 <_vfprintf_r+0x154c>
80008c08:	ed b5 00 04 	bld	r5,0x4
80008c0c:	c1 61       	brne	80008c38 <_vfprintf_r+0x11e0>
80008c0e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008c12:	40 3e       	lddsp	lr,sp[0xc]
80008c14:	58 0e       	cp.w	lr,0
80008c16:	c0 80       	breq	80008c26 <_vfprintf_r+0x11ce>
80008c18:	10 36       	cp.w	r6,r8
80008c1a:	c6 74       	brge	80008ce8 <_vfprintf_r+0x1290>
80008c1c:	fa cc f9 44 	sub	r12,sp,-1724
80008c20:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008c24:	c8 08       	rjmp	80008d24 <_vfprintf_r+0x12cc>
80008c26:	ee ca ff ff 	sub	r10,r7,-1
80008c2a:	10 37       	cp.w	r7,r8
80008c2c:	c7 f4       	brge	80008d2a <_vfprintf_r+0x12d2>
80008c2e:	fa cb f9 44 	sub	r11,sp,-1724
80008c32:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008c36:	c7 68       	rjmp	80008d22 <_vfprintf_r+0x12ca>
80008c38:	ed b5 00 06 	bld	r5,0x6
80008c3c:	c4 a1       	brne	80008cd0 <_vfprintf_r+0x1278>
80008c3e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008c42:	40 3c       	lddsp	r12,sp[0xc]
80008c44:	58 0c       	cp.w	r12,0
80008c46:	c1 d0       	breq	80008c80 <_vfprintf_r+0x1228>
80008c48:	10 36       	cp.w	r6,r8
80008c4a:	c0 64       	brge	80008c56 <_vfprintf_r+0x11fe>
80008c4c:	fa cb f9 44 	sub	r11,sp,-1724
80008c50:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008c54:	c1 f8       	rjmp	80008c92 <_vfprintf_r+0x123a>
80008c56:	fa c8 f9 50 	sub	r8,sp,-1712
80008c5a:	1a d8       	st.w	--sp,r8
80008c5c:	fa c8 fa b8 	sub	r8,sp,-1352
80008c60:	1a d8       	st.w	--sp,r8
80008c62:	fa c8 fb b4 	sub	r8,sp,-1100
80008c66:	1a d8       	st.w	--sp,r8
80008c68:	fa c8 f9 40 	sub	r8,sp,-1728
80008c6c:	fa c9 ff b4 	sub	r9,sp,-76
80008c70:	04 9a       	mov	r10,r2
80008c72:	0c 9b       	mov	r11,r6
80008c74:	08 9c       	mov	r12,r4
80008c76:	fe b0 f5 53 	rcall	8000771c <get_arg>
80008c7a:	2f dd       	sub	sp,-12
80008c7c:	98 18       	ld.sh	r8,r12[0x2]
80008c7e:	c2 68       	rjmp	80008cca <_vfprintf_r+0x1272>
80008c80:	ee ca ff ff 	sub	r10,r7,-1
80008c84:	10 37       	cp.w	r7,r8
80008c86:	c0 94       	brge	80008c98 <_vfprintf_r+0x1240>
80008c88:	fa c9 f9 44 	sub	r9,sp,-1724
80008c8c:	14 97       	mov	r7,r10
80008c8e:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008c92:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80008c96:	c1 a8       	rjmp	80008cca <_vfprintf_r+0x1272>
80008c98:	41 09       	lddsp	r9,sp[0x40]
80008c9a:	59 f8       	cp.w	r8,31
80008c9c:	e0 89 00 13 	brgt	80008cc2 <_vfprintf_r+0x126a>
80008ca0:	f2 cb ff fc 	sub	r11,r9,-4
80008ca4:	51 0b       	stdsp	sp[0x40],r11
80008ca6:	72 09       	ld.w	r9,r9[0x0]
80008ca8:	fa c6 f9 44 	sub	r6,sp,-1724
80008cac:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008cb0:	2f f8       	sub	r8,-1
80008cb2:	f7 49 fd 88 	st.w	r11[-632],r9
80008cb6:	fb 48 06 b4 	st.w	sp[1716],r8
80008cba:	14 97       	mov	r7,r10
80008cbc:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008cc0:	c0 58       	rjmp	80008cca <_vfprintf_r+0x1272>
80008cc2:	92 18       	ld.sh	r8,r9[0x2]
80008cc4:	14 97       	mov	r7,r10
80008cc6:	2f c9       	sub	r9,-4
80008cc8:	51 09       	stdsp	sp[0x40],r9
80008cca:	5c 78       	castu.h	r8
80008ccc:	50 18       	stdsp	sp[0x4],r8
80008cce:	c4 68       	rjmp	80008d5a <_vfprintf_r+0x1302>
80008cd0:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008cd4:	40 3c       	lddsp	r12,sp[0xc]
80008cd6:	58 0c       	cp.w	r12,0
80008cd8:	c1 d0       	breq	80008d12 <_vfprintf_r+0x12ba>
80008cda:	10 36       	cp.w	r6,r8
80008cdc:	c0 64       	brge	80008ce8 <_vfprintf_r+0x1290>
80008cde:	fa cb f9 44 	sub	r11,sp,-1724
80008ce2:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008ce6:	c1 f8       	rjmp	80008d24 <_vfprintf_r+0x12cc>
80008ce8:	fa c8 f9 50 	sub	r8,sp,-1712
80008cec:	1a d8       	st.w	--sp,r8
80008cee:	fa c8 fa b8 	sub	r8,sp,-1352
80008cf2:	0c 9b       	mov	r11,r6
80008cf4:	1a d8       	st.w	--sp,r8
80008cf6:	fa c8 fb b4 	sub	r8,sp,-1100
80008cfa:	04 9a       	mov	r10,r2
80008cfc:	1a d8       	st.w	--sp,r8
80008cfe:	08 9c       	mov	r12,r4
80008d00:	fa c8 f9 40 	sub	r8,sp,-1728
80008d04:	fa c9 ff b4 	sub	r9,sp,-76
80008d08:	fe b0 f5 0a 	rcall	8000771c <get_arg>
80008d0c:	2f dd       	sub	sp,-12
80008d0e:	78 0b       	ld.w	r11,r12[0x0]
80008d10:	c2 48       	rjmp	80008d58 <_vfprintf_r+0x1300>
80008d12:	ee ca ff ff 	sub	r10,r7,-1
80008d16:	10 37       	cp.w	r7,r8
80008d18:	c0 94       	brge	80008d2a <_vfprintf_r+0x12d2>
80008d1a:	fa c9 f9 44 	sub	r9,sp,-1724
80008d1e:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008d22:	14 97       	mov	r7,r10
80008d24:	ec fb fd 88 	ld.w	r11,r6[-632]
80008d28:	c1 88       	rjmp	80008d58 <_vfprintf_r+0x1300>
80008d2a:	41 09       	lddsp	r9,sp[0x40]
80008d2c:	59 f8       	cp.w	r8,31
80008d2e:	e0 89 00 11 	brgt	80008d50 <_vfprintf_r+0x12f8>
80008d32:	f2 cb ff fc 	sub	r11,r9,-4
80008d36:	51 0b       	stdsp	sp[0x40],r11
80008d38:	fa c6 f9 44 	sub	r6,sp,-1724
80008d3c:	72 0b       	ld.w	r11,r9[0x0]
80008d3e:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008d42:	f3 4b fd 88 	st.w	r9[-632],r11
80008d46:	2f f8       	sub	r8,-1
80008d48:	14 97       	mov	r7,r10
80008d4a:	fb 48 06 b4 	st.w	sp[1716],r8
80008d4e:	c0 58       	rjmp	80008d58 <_vfprintf_r+0x1300>
80008d50:	72 0b       	ld.w	r11,r9[0x0]
80008d52:	14 97       	mov	r7,r10
80008d54:	2f c9       	sub	r9,-4
80008d56:	51 09       	stdsp	sp[0x40],r9
80008d58:	50 1b       	stdsp	sp[0x4],r11
80008d5a:	30 0e       	mov	lr,0
80008d5c:	30 18       	mov	r8,1
80008d5e:	50 0e       	stdsp	sp[0x0],lr
80008d60:	c2 29       	rjmp	80008fa4 <_vfprintf_r+0x154c>
80008d62:	50 a7       	stdsp	sp[0x28],r7
80008d64:	50 80       	stdsp	sp[0x20],r0
80008d66:	0c 97       	mov	r7,r6
80008d68:	04 94       	mov	r4,r2
80008d6a:	06 96       	mov	r6,r3
80008d6c:	02 92       	mov	r2,r1
80008d6e:	4d 3c       	lddpc	r12,80008eb8 <_vfprintf_r+0x1460>
80008d70:	40 93       	lddsp	r3,sp[0x24]
80008d72:	10 90       	mov	r0,r8
80008d74:	40 41       	lddsp	r1,sp[0x10]
80008d76:	50 dc       	stdsp	sp[0x34],r12
80008d78:	ed b5 00 05 	bld	r5,0x5
80008d7c:	c5 51       	brne	80008e26 <_vfprintf_r+0x13ce>
80008d7e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008d82:	40 3b       	lddsp	r11,sp[0xc]
80008d84:	58 0b       	cp.w	r11,0
80008d86:	c2 20       	breq	80008dca <_vfprintf_r+0x1372>
80008d88:	10 36       	cp.w	r6,r8
80008d8a:	c0 a4       	brge	80008d9e <_vfprintf_r+0x1346>
80008d8c:	fa ca f9 44 	sub	r10,sp,-1724
80008d90:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008d94:	ec e8 fd 88 	ld.d	r8,r6[-632]
80008d98:	fa e9 00 00 	st.d	sp[0],r8
80008d9c:	cf 38       	rjmp	80008f82 <_vfprintf_r+0x152a>
80008d9e:	fa c8 f9 50 	sub	r8,sp,-1712
80008da2:	1a d8       	st.w	--sp,r8
80008da4:	fa c8 fa b8 	sub	r8,sp,-1352
80008da8:	04 9a       	mov	r10,r2
80008daa:	1a d8       	st.w	--sp,r8
80008dac:	0c 9b       	mov	r11,r6
80008dae:	fa c8 fb b4 	sub	r8,sp,-1100
80008db2:	08 9c       	mov	r12,r4
80008db4:	1a d8       	st.w	--sp,r8
80008db6:	fa c8 f9 40 	sub	r8,sp,-1728
80008dba:	fa c9 ff b4 	sub	r9,sp,-76
80008dbe:	fe b0 f4 af 	rcall	8000771c <get_arg>
80008dc2:	2f dd       	sub	sp,-12
80008dc4:	f8 ea 00 00 	ld.d	r10,r12[0]
80008dc8:	c0 c8       	rjmp	80008de0 <_vfprintf_r+0x1388>
80008dca:	ee ca ff ff 	sub	r10,r7,-1
80008dce:	10 37       	cp.w	r7,r8
80008dd0:	c0 b4       	brge	80008de6 <_vfprintf_r+0x138e>
80008dd2:	fa c9 f9 44 	sub	r9,sp,-1724
80008dd6:	14 97       	mov	r7,r10
80008dd8:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008ddc:	ec ea fd 88 	ld.d	r10,r6[-632]
80008de0:	fa eb 00 00 	st.d	sp[0],r10
80008de4:	cc f8       	rjmp	80008f82 <_vfprintf_r+0x152a>
80008de6:	41 09       	lddsp	r9,sp[0x40]
80008de8:	59 f8       	cp.w	r8,31
80008dea:	e0 89 00 16 	brgt	80008e16 <_vfprintf_r+0x13be>
80008dee:	f2 e6 00 00 	ld.d	r6,r9[0]
80008df2:	f2 cb ff f8 	sub	r11,r9,-8
80008df6:	fa e7 00 00 	st.d	sp[0],r6
80008dfa:	51 0b       	stdsp	sp[0x40],r11
80008dfc:	fa c6 f9 44 	sub	r6,sp,-1724
80008e00:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008e04:	fa e6 00 00 	ld.d	r6,sp[0]
80008e08:	f2 e7 fd 88 	st.d	r9[-632],r6
80008e0c:	2f f8       	sub	r8,-1
80008e0e:	14 97       	mov	r7,r10
80008e10:	fb 48 06 b4 	st.w	sp[1716],r8
80008e14:	cb 78       	rjmp	80008f82 <_vfprintf_r+0x152a>
80008e16:	f2 e6 00 00 	ld.d	r6,r9[0]
80008e1a:	2f 89       	sub	r9,-8
80008e1c:	fa e7 00 00 	st.d	sp[0],r6
80008e20:	51 09       	stdsp	sp[0x40],r9
80008e22:	14 97       	mov	r7,r10
80008e24:	ca f8       	rjmp	80008f82 <_vfprintf_r+0x152a>
80008e26:	ed b5 00 04 	bld	r5,0x4
80008e2a:	c1 71       	brne	80008e58 <_vfprintf_r+0x1400>
80008e2c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008e30:	40 3e       	lddsp	lr,sp[0xc]
80008e32:	58 0e       	cp.w	lr,0
80008e34:	c0 80       	breq	80008e44 <_vfprintf_r+0x13ec>
80008e36:	10 36       	cp.w	r6,r8
80008e38:	c6 a4       	brge	80008f0c <_vfprintf_r+0x14b4>
80008e3a:	fa cc f9 44 	sub	r12,sp,-1724
80008e3e:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008e42:	c8 38       	rjmp	80008f48 <_vfprintf_r+0x14f0>
80008e44:	ee ca ff ff 	sub	r10,r7,-1
80008e48:	10 37       	cp.w	r7,r8
80008e4a:	e0 84 00 82 	brge	80008f4e <_vfprintf_r+0x14f6>
80008e4e:	fa cb f9 44 	sub	r11,sp,-1724
80008e52:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008e56:	c7 88       	rjmp	80008f46 <_vfprintf_r+0x14ee>
80008e58:	ed b5 00 06 	bld	r5,0x6
80008e5c:	c4 c1       	brne	80008ef4 <_vfprintf_r+0x149c>
80008e5e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008e62:	40 3c       	lddsp	r12,sp[0xc]
80008e64:	58 0c       	cp.w	r12,0
80008e66:	c1 d0       	breq	80008ea0 <_vfprintf_r+0x1448>
80008e68:	10 36       	cp.w	r6,r8
80008e6a:	c0 64       	brge	80008e76 <_vfprintf_r+0x141e>
80008e6c:	fa cb f9 44 	sub	r11,sp,-1724
80008e70:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008e74:	c1 f8       	rjmp	80008eb2 <_vfprintf_r+0x145a>
80008e76:	fa c8 f9 50 	sub	r8,sp,-1712
80008e7a:	1a d8       	st.w	--sp,r8
80008e7c:	fa c8 fa b8 	sub	r8,sp,-1352
80008e80:	1a d8       	st.w	--sp,r8
80008e82:	fa c8 fb b4 	sub	r8,sp,-1100
80008e86:	1a d8       	st.w	--sp,r8
80008e88:	fa c8 f9 40 	sub	r8,sp,-1728
80008e8c:	fa c9 ff b4 	sub	r9,sp,-76
80008e90:	04 9a       	mov	r10,r2
80008e92:	0c 9b       	mov	r11,r6
80008e94:	08 9c       	mov	r12,r4
80008e96:	fe b0 f4 43 	rcall	8000771c <get_arg>
80008e9a:	2f dd       	sub	sp,-12
80008e9c:	98 18       	ld.sh	r8,r12[0x2]
80008e9e:	c2 88       	rjmp	80008eee <_vfprintf_r+0x1496>
80008ea0:	ee ca ff ff 	sub	r10,r7,-1
80008ea4:	10 37       	cp.w	r7,r8
80008ea6:	c0 b4       	brge	80008ebc <_vfprintf_r+0x1464>
80008ea8:	fa c9 f9 44 	sub	r9,sp,-1724
80008eac:	14 97       	mov	r7,r10
80008eae:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008eb2:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80008eb6:	c1 c8       	rjmp	80008eee <_vfprintf_r+0x1496>
80008eb8:	80 01       	ld.sh	r1,r0[0x0]
80008eba:	5d 98       	*unknown*
80008ebc:	41 09       	lddsp	r9,sp[0x40]
80008ebe:	59 f8       	cp.w	r8,31
80008ec0:	e0 89 00 13 	brgt	80008ee6 <_vfprintf_r+0x148e>
80008ec4:	f2 cb ff fc 	sub	r11,r9,-4
80008ec8:	51 0b       	stdsp	sp[0x40],r11
80008eca:	72 09       	ld.w	r9,r9[0x0]
80008ecc:	fa c6 f9 44 	sub	r6,sp,-1724
80008ed0:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008ed4:	2f f8       	sub	r8,-1
80008ed6:	f7 49 fd 88 	st.w	r11[-632],r9
80008eda:	fb 48 06 b4 	st.w	sp[1716],r8
80008ede:	14 97       	mov	r7,r10
80008ee0:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008ee4:	c0 58       	rjmp	80008eee <_vfprintf_r+0x1496>
80008ee6:	92 18       	ld.sh	r8,r9[0x2]
80008ee8:	14 97       	mov	r7,r10
80008eea:	2f c9       	sub	r9,-4
80008eec:	51 09       	stdsp	sp[0x40],r9
80008eee:	5c 78       	castu.h	r8
80008ef0:	50 18       	stdsp	sp[0x4],r8
80008ef2:	c4 68       	rjmp	80008f7e <_vfprintf_r+0x1526>
80008ef4:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008ef8:	40 3c       	lddsp	r12,sp[0xc]
80008efa:	58 0c       	cp.w	r12,0
80008efc:	c1 d0       	breq	80008f36 <_vfprintf_r+0x14de>
80008efe:	10 36       	cp.w	r6,r8
80008f00:	c0 64       	brge	80008f0c <_vfprintf_r+0x14b4>
80008f02:	fa cb f9 44 	sub	r11,sp,-1724
80008f06:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008f0a:	c1 f8       	rjmp	80008f48 <_vfprintf_r+0x14f0>
80008f0c:	fa c8 f9 50 	sub	r8,sp,-1712
80008f10:	1a d8       	st.w	--sp,r8
80008f12:	fa c8 fa b8 	sub	r8,sp,-1352
80008f16:	0c 9b       	mov	r11,r6
80008f18:	1a d8       	st.w	--sp,r8
80008f1a:	fa c8 fb b4 	sub	r8,sp,-1100
80008f1e:	04 9a       	mov	r10,r2
80008f20:	1a d8       	st.w	--sp,r8
80008f22:	08 9c       	mov	r12,r4
80008f24:	fa c8 f9 40 	sub	r8,sp,-1728
80008f28:	fa c9 ff b4 	sub	r9,sp,-76
80008f2c:	fe b0 f3 f8 	rcall	8000771c <get_arg>
80008f30:	2f dd       	sub	sp,-12
80008f32:	78 0b       	ld.w	r11,r12[0x0]
80008f34:	c2 48       	rjmp	80008f7c <_vfprintf_r+0x1524>
80008f36:	ee ca ff ff 	sub	r10,r7,-1
80008f3a:	10 37       	cp.w	r7,r8
80008f3c:	c0 94       	brge	80008f4e <_vfprintf_r+0x14f6>
80008f3e:	fa c9 f9 44 	sub	r9,sp,-1724
80008f42:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008f46:	14 97       	mov	r7,r10
80008f48:	ec fb fd 88 	ld.w	r11,r6[-632]
80008f4c:	c1 88       	rjmp	80008f7c <_vfprintf_r+0x1524>
80008f4e:	41 09       	lddsp	r9,sp[0x40]
80008f50:	59 f8       	cp.w	r8,31
80008f52:	e0 89 00 11 	brgt	80008f74 <_vfprintf_r+0x151c>
80008f56:	f2 cb ff fc 	sub	r11,r9,-4
80008f5a:	51 0b       	stdsp	sp[0x40],r11
80008f5c:	fa c6 f9 44 	sub	r6,sp,-1724
80008f60:	72 0b       	ld.w	r11,r9[0x0]
80008f62:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008f66:	f3 4b fd 88 	st.w	r9[-632],r11
80008f6a:	2f f8       	sub	r8,-1
80008f6c:	14 97       	mov	r7,r10
80008f6e:	fb 48 06 b4 	st.w	sp[1716],r8
80008f72:	c0 58       	rjmp	80008f7c <_vfprintf_r+0x1524>
80008f74:	72 0b       	ld.w	r11,r9[0x0]
80008f76:	14 97       	mov	r7,r10
80008f78:	2f c9       	sub	r9,-4
80008f7a:	51 09       	stdsp	sp[0x40],r9
80008f7c:	50 1b       	stdsp	sp[0x4],r11
80008f7e:	30 0e       	mov	lr,0
80008f80:	50 0e       	stdsp	sp[0x0],lr
80008f82:	40 08       	lddsp	r8,sp[0x0]
80008f84:	40 1c       	lddsp	r12,sp[0x4]
80008f86:	18 48       	or	r8,r12
80008f88:	5f 19       	srne	r9
80008f8a:	0a 98       	mov	r8,r5
80008f8c:	eb e9 00 09 	and	r9,r5,r9
80008f90:	a1 b8       	sbr	r8,0x1
80008f92:	58 09       	cp.w	r9,0
80008f94:	c0 70       	breq	80008fa2 <_vfprintf_r+0x154a>
80008f96:	10 95       	mov	r5,r8
80008f98:	fb 60 06 b9 	st.b	sp[1721],r0
80008f9c:	33 08       	mov	r8,48
80008f9e:	fb 68 06 b8 	st.b	sp[1720],r8
80008fa2:	30 28       	mov	r8,2
80008fa4:	30 09       	mov	r9,0
80008fa6:	fb 69 06 bb 	st.b	sp[1723],r9
80008faa:	0a 99       	mov	r9,r5
80008fac:	a7 d9       	cbr	r9,0x7
80008fae:	40 2b       	lddsp	r11,sp[0x8]
80008fb0:	40 16       	lddsp	r6,sp[0x4]
80008fb2:	58 0b       	cp.w	r11,0
80008fb4:	5f 1a       	srne	r10
80008fb6:	f2 05 17 40 	movge	r5,r9
80008fba:	fa c2 f9 78 	sub	r2,sp,-1672
80008fbe:	40 09       	lddsp	r9,sp[0x0]
80008fc0:	0c 49       	or	r9,r6
80008fc2:	5f 19       	srne	r9
80008fc4:	f5 e9 10 09 	or	r9,r10,r9
80008fc8:	c5 c0       	breq	80009080 <_vfprintf_r+0x1628>
80008fca:	30 19       	mov	r9,1
80008fcc:	f2 08 18 00 	cp.b	r8,r9
80008fd0:	c0 60       	breq	80008fdc <_vfprintf_r+0x1584>
80008fd2:	30 29       	mov	r9,2
80008fd4:	f2 08 18 00 	cp.b	r8,r9
80008fd8:	c0 41       	brne	80008fe0 <_vfprintf_r+0x1588>
80008fda:	c3 c8       	rjmp	80009052 <_vfprintf_r+0x15fa>
80008fdc:	04 96       	mov	r6,r2
80008fde:	c3 08       	rjmp	8000903e <_vfprintf_r+0x15e6>
80008fe0:	04 96       	mov	r6,r2
80008fe2:	fa e8 00 00 	ld.d	r8,sp[0]
80008fe6:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
80008fea:	2d 0a       	sub	r10,-48
80008fec:	0c fa       	st.b	--r6,r10
80008fee:	f0 0b 16 03 	lsr	r11,r8,0x3
80008ff2:	f2 0c 16 03 	lsr	r12,r9,0x3
80008ff6:	f7 e9 11 db 	or	r11,r11,r9<<0x1d
80008ffa:	18 99       	mov	r9,r12
80008ffc:	16 98       	mov	r8,r11
80008ffe:	58 08       	cp.w	r8,0
80009000:	5c 29       	cpc	r9
80009002:	cf 21       	brne	80008fe6 <_vfprintf_r+0x158e>
80009004:	fa e9 00 00 	st.d	sp[0],r8
80009008:	ed b5 00 00 	bld	r5,0x0
8000900c:	c4 51       	brne	80009096 <_vfprintf_r+0x163e>
8000900e:	33 09       	mov	r9,48
80009010:	f2 0a 18 00 	cp.b	r10,r9
80009014:	c4 10       	breq	80009096 <_vfprintf_r+0x163e>
80009016:	0c f9       	st.b	--r6,r9
80009018:	c3 f8       	rjmp	80009096 <_vfprintf_r+0x163e>
8000901a:	fa ea 00 00 	ld.d	r10,sp[0]
8000901e:	30 a8       	mov	r8,10
80009020:	30 09       	mov	r9,0
80009022:	e0 a0 1a 1b 	rcall	8000c458 <__avr32_umod64>
80009026:	30 a8       	mov	r8,10
80009028:	2d 0a       	sub	r10,-48
8000902a:	30 09       	mov	r9,0
8000902c:	ac 8a       	st.b	r6[0x0],r10
8000902e:	fa ea 00 00 	ld.d	r10,sp[0]
80009032:	e0 a0 18 e1 	rcall	8000c1f4 <__avr32_udiv64>
80009036:	16 99       	mov	r9,r11
80009038:	14 98       	mov	r8,r10
8000903a:	fa e9 00 00 	st.d	sp[0],r8
8000903e:	20 16       	sub	r6,1
80009040:	fa ea 00 00 	ld.d	r10,sp[0]
80009044:	58 9a       	cp.w	r10,9
80009046:	5c 2b       	cpc	r11
80009048:	fe 9b ff e9 	brhi	8000901a <_vfprintf_r+0x15c2>
8000904c:	1b f8       	ld.ub	r8,sp[0x7]
8000904e:	2d 08       	sub	r8,-48
80009050:	c2 08       	rjmp	80009090 <_vfprintf_r+0x1638>
80009052:	04 96       	mov	r6,r2
80009054:	fa e8 00 00 	ld.d	r8,sp[0]
80009058:	f5 d8 c0 04 	bfextu	r10,r8,0x0,0x4
8000905c:	40 de       	lddsp	lr,sp[0x34]
8000905e:	fc 0a 07 0a 	ld.ub	r10,lr[r10]
80009062:	0c fa       	st.b	--r6,r10
80009064:	f2 0b 16 04 	lsr	r11,r9,0x4
80009068:	f0 0a 16 04 	lsr	r10,r8,0x4
8000906c:	f5 e9 11 ca 	or	r10,r10,r9<<0x1c
80009070:	16 99       	mov	r9,r11
80009072:	14 98       	mov	r8,r10
80009074:	58 08       	cp.w	r8,0
80009076:	5c 29       	cpc	r9
80009078:	cf 01       	brne	80009058 <_vfprintf_r+0x1600>
8000907a:	fa e9 00 00 	st.d	sp[0],r8
8000907e:	c0 c8       	rjmp	80009096 <_vfprintf_r+0x163e>
80009080:	58 08       	cp.w	r8,0
80009082:	c0 91       	brne	80009094 <_vfprintf_r+0x163c>
80009084:	ed b5 00 00 	bld	r5,0x0
80009088:	c0 61       	brne	80009094 <_vfprintf_r+0x163c>
8000908a:	fa c6 f9 79 	sub	r6,sp,-1671
8000908e:	33 08       	mov	r8,48
80009090:	ac 88       	st.b	r6[0x0],r8
80009092:	c0 28       	rjmp	80009096 <_vfprintf_r+0x163e>
80009094:	04 96       	mov	r6,r2
80009096:	0c 12       	sub	r2,r6
80009098:	c1 c8       	rjmp	800090d0 <_vfprintf_r+0x1678>
8000909a:	50 a7       	stdsp	sp[0x28],r7
8000909c:	50 80       	stdsp	sp[0x20],r0
8000909e:	40 93       	lddsp	r3,sp[0x24]
800090a0:	0c 97       	mov	r7,r6
800090a2:	10 90       	mov	r0,r8
800090a4:	04 94       	mov	r4,r2
800090a6:	40 41       	lddsp	r1,sp[0x10]
800090a8:	58 08       	cp.w	r8,0
800090aa:	e0 80 04 51 	breq	8000994c <_vfprintf_r+0x1ef4>
800090ae:	fb 68 06 60 	st.b	sp[1632],r8
800090b2:	30 0c       	mov	r12,0
800090b4:	30 08       	mov	r8,0
800090b6:	30 12       	mov	r2,1
800090b8:	fb 68 06 bb 	st.b	sp[1723],r8
800090bc:	50 2c       	stdsp	sp[0x8],r12
800090be:	fa c6 f9 a0 	sub	r6,sp,-1632
800090c2:	c0 78       	rjmp	800090d0 <_vfprintf_r+0x1678>
800090c4:	30 0b       	mov	r11,0
800090c6:	50 2b       	stdsp	sp[0x8],r11
800090c8:	c0 48       	rjmp	800090d0 <_vfprintf_r+0x1678>
800090ca:	40 22       	lddsp	r2,sp[0x8]
800090cc:	30 0a       	mov	r10,0
800090ce:	50 2a       	stdsp	sp[0x8],r10
800090d0:	40 29       	lddsp	r9,sp[0x8]
800090d2:	e4 09 0c 49 	max	r9,r2,r9
800090d6:	fb 38 06 bb 	ld.ub	r8,sp[1723]
800090da:	50 39       	stdsp	sp[0xc],r9
800090dc:	0a 9e       	mov	lr,r5
800090de:	30 09       	mov	r9,0
800090e0:	e2 1e 00 02 	andl	lr,0x2,COH
800090e4:	f2 08 18 00 	cp.b	r8,r9
800090e8:	fb f8 10 03 	ld.wne	r8,sp[0xc]
800090ec:	f7 b8 01 ff 	subne	r8,-1
800090f0:	fb f8 1a 03 	st.wne	sp[0xc],r8
800090f4:	0a 9b       	mov	r11,r5
800090f6:	58 0e       	cp.w	lr,0
800090f8:	fb fc 10 03 	ld.wne	r12,sp[0xc]
800090fc:	f7 bc 01 fe 	subne	r12,-2
80009100:	fb fc 1a 03 	st.wne	sp[0xc],r12
80009104:	e2 1b 00 84 	andl	r11,0x84,COH
80009108:	50 fe       	stdsp	sp[0x3c],lr
8000910a:	50 9b       	stdsp	sp[0x24],r11
8000910c:	c4 51       	brne	80009196 <_vfprintf_r+0x173e>
8000910e:	40 8a       	lddsp	r10,sp[0x20]
80009110:	40 39       	lddsp	r9,sp[0xc]
80009112:	12 1a       	sub	r10,r9
80009114:	50 4a       	stdsp	sp[0x10],r10
80009116:	58 0a       	cp.w	r10,0
80009118:	e0 89 00 1f 	brgt	80009156 <_vfprintf_r+0x16fe>
8000911c:	c3 d8       	rjmp	80009196 <_vfprintf_r+0x173e>
8000911e:	2f 09       	sub	r9,-16
80009120:	2f f8       	sub	r8,-1
80009122:	4c ee       	lddpc	lr,80009258 <_vfprintf_r+0x1800>
80009124:	31 0c       	mov	r12,16
80009126:	fb 49 06 90 	st.w	sp[1680],r9
8000912a:	87 0e       	st.w	r3[0x0],lr
8000912c:	87 1c       	st.w	r3[0x4],r12
8000912e:	fb 48 06 8c 	st.w	sp[1676],r8
80009132:	58 78       	cp.w	r8,7
80009134:	e0 89 00 04 	brgt	8000913c <_vfprintf_r+0x16e4>
80009138:	2f 83       	sub	r3,-8
8000913a:	c0 b8       	rjmp	80009150 <_vfprintf_r+0x16f8>
8000913c:	fa ca f9 78 	sub	r10,sp,-1672
80009140:	02 9b       	mov	r11,r1
80009142:	08 9c       	mov	r12,r4
80009144:	fe b0 f4 7c 	rcall	80007a3c <__sprint_r>
80009148:	e0 81 04 13 	brne	8000996e <_vfprintf_r+0x1f16>
8000914c:	fa c3 f9 e0 	sub	r3,sp,-1568
80009150:	40 4b       	lddsp	r11,sp[0x10]
80009152:	21 0b       	sub	r11,16
80009154:	50 4b       	stdsp	sp[0x10],r11
80009156:	fa f9 06 90 	ld.w	r9,sp[1680]
8000915a:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000915e:	4b fa       	lddpc	r10,80009258 <_vfprintf_r+0x1800>
80009160:	40 4e       	lddsp	lr,sp[0x10]
80009162:	59 0e       	cp.w	lr,16
80009164:	fe 99 ff dd 	brgt	8000911e <_vfprintf_r+0x16c6>
80009168:	1c 09       	add	r9,lr
8000916a:	2f f8       	sub	r8,-1
8000916c:	87 0a       	st.w	r3[0x0],r10
8000916e:	fb 49 06 90 	st.w	sp[1680],r9
80009172:	87 1e       	st.w	r3[0x4],lr
80009174:	fb 48 06 8c 	st.w	sp[1676],r8
80009178:	58 78       	cp.w	r8,7
8000917a:	e0 89 00 04 	brgt	80009182 <_vfprintf_r+0x172a>
8000917e:	2f 83       	sub	r3,-8
80009180:	c0 b8       	rjmp	80009196 <_vfprintf_r+0x173e>
80009182:	fa ca f9 78 	sub	r10,sp,-1672
80009186:	02 9b       	mov	r11,r1
80009188:	08 9c       	mov	r12,r4
8000918a:	fe b0 f4 59 	rcall	80007a3c <__sprint_r>
8000918e:	e0 81 03 f0 	brne	8000996e <_vfprintf_r+0x1f16>
80009192:	fa c3 f9 e0 	sub	r3,sp,-1568
80009196:	30 09       	mov	r9,0
80009198:	fb 38 06 bb 	ld.ub	r8,sp[1723]
8000919c:	f2 08 18 00 	cp.b	r8,r9
800091a0:	c1 f0       	breq	800091de <_vfprintf_r+0x1786>
800091a2:	fa f8 06 90 	ld.w	r8,sp[1680]
800091a6:	fa c9 f9 45 	sub	r9,sp,-1723
800091aa:	2f f8       	sub	r8,-1
800091ac:	87 09       	st.w	r3[0x0],r9
800091ae:	fb 48 06 90 	st.w	sp[1680],r8
800091b2:	30 19       	mov	r9,1
800091b4:	fa f8 06 8c 	ld.w	r8,sp[1676]
800091b8:	87 19       	st.w	r3[0x4],r9
800091ba:	2f f8       	sub	r8,-1
800091bc:	fb 48 06 8c 	st.w	sp[1676],r8
800091c0:	58 78       	cp.w	r8,7
800091c2:	e0 89 00 04 	brgt	800091ca <_vfprintf_r+0x1772>
800091c6:	2f 83       	sub	r3,-8
800091c8:	c0 b8       	rjmp	800091de <_vfprintf_r+0x1786>
800091ca:	fa ca f9 78 	sub	r10,sp,-1672
800091ce:	02 9b       	mov	r11,r1
800091d0:	08 9c       	mov	r12,r4
800091d2:	fe b0 f4 35 	rcall	80007a3c <__sprint_r>
800091d6:	e0 81 03 cc 	brne	8000996e <_vfprintf_r+0x1f16>
800091da:	fa c3 f9 e0 	sub	r3,sp,-1568
800091de:	40 fc       	lddsp	r12,sp[0x3c]
800091e0:	58 0c       	cp.w	r12,0
800091e2:	c1 f0       	breq	80009220 <_vfprintf_r+0x17c8>
800091e4:	fa f8 06 90 	ld.w	r8,sp[1680]
800091e8:	fa c9 f9 48 	sub	r9,sp,-1720
800091ec:	2f e8       	sub	r8,-2
800091ee:	87 09       	st.w	r3[0x0],r9
800091f0:	fb 48 06 90 	st.w	sp[1680],r8
800091f4:	30 29       	mov	r9,2
800091f6:	fa f8 06 8c 	ld.w	r8,sp[1676]
800091fa:	87 19       	st.w	r3[0x4],r9
800091fc:	2f f8       	sub	r8,-1
800091fe:	fb 48 06 8c 	st.w	sp[1676],r8
80009202:	58 78       	cp.w	r8,7
80009204:	e0 89 00 04 	brgt	8000920c <_vfprintf_r+0x17b4>
80009208:	2f 83       	sub	r3,-8
8000920a:	c0 b8       	rjmp	80009220 <_vfprintf_r+0x17c8>
8000920c:	fa ca f9 78 	sub	r10,sp,-1672
80009210:	02 9b       	mov	r11,r1
80009212:	08 9c       	mov	r12,r4
80009214:	fe b0 f4 14 	rcall	80007a3c <__sprint_r>
80009218:	e0 81 03 ab 	brne	8000996e <_vfprintf_r+0x1f16>
8000921c:	fa c3 f9 e0 	sub	r3,sp,-1568
80009220:	40 9b       	lddsp	r11,sp[0x24]
80009222:	e0 4b 00 80 	cp.w	r11,128
80009226:	c4 a1       	brne	800092ba <_vfprintf_r+0x1862>
80009228:	40 8a       	lddsp	r10,sp[0x20]
8000922a:	40 39       	lddsp	r9,sp[0xc]
8000922c:	12 1a       	sub	r10,r9
8000922e:	50 4a       	stdsp	sp[0x10],r10
80009230:	58 0a       	cp.w	r10,0
80009232:	e0 89 00 24 	brgt	8000927a <_vfprintf_r+0x1822>
80009236:	c4 28       	rjmp	800092ba <_vfprintf_r+0x1862>
80009238:	2f 09       	sub	r9,-16
8000923a:	2f f8       	sub	r8,-1
8000923c:	48 8e       	lddpc	lr,8000925c <_vfprintf_r+0x1804>
8000923e:	31 0c       	mov	r12,16
80009240:	fb 49 06 90 	st.w	sp[1680],r9
80009244:	87 0e       	st.w	r3[0x0],lr
80009246:	87 1c       	st.w	r3[0x4],r12
80009248:	fb 48 06 8c 	st.w	sp[1676],r8
8000924c:	58 78       	cp.w	r8,7
8000924e:	e0 89 00 09 	brgt	80009260 <_vfprintf_r+0x1808>
80009252:	2f 83       	sub	r3,-8
80009254:	c1 08       	rjmp	80009274 <_vfprintf_r+0x181c>
80009256:	d7 03       	nop
80009258:	80 01       	ld.sh	r1,r0[0x0]
8000925a:	5d b0       	*unknown*
8000925c:	80 01       	ld.sh	r1,r0[0x0]
8000925e:	5d c0       	*unknown*
80009260:	fa ca f9 78 	sub	r10,sp,-1672
80009264:	02 9b       	mov	r11,r1
80009266:	08 9c       	mov	r12,r4
80009268:	fe b0 f3 ea 	rcall	80007a3c <__sprint_r>
8000926c:	e0 81 03 81 	brne	8000996e <_vfprintf_r+0x1f16>
80009270:	fa c3 f9 e0 	sub	r3,sp,-1568
80009274:	40 4b       	lddsp	r11,sp[0x10]
80009276:	21 0b       	sub	r11,16
80009278:	50 4b       	stdsp	sp[0x10],r11
8000927a:	fa f9 06 90 	ld.w	r9,sp[1680]
8000927e:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009282:	4c 6a       	lddpc	r10,80009398 <_vfprintf_r+0x1940>
80009284:	40 4e       	lddsp	lr,sp[0x10]
80009286:	59 0e       	cp.w	lr,16
80009288:	fe 99 ff d8 	brgt	80009238 <_vfprintf_r+0x17e0>
8000928c:	1c 09       	add	r9,lr
8000928e:	2f f8       	sub	r8,-1
80009290:	87 0a       	st.w	r3[0x0],r10
80009292:	fb 49 06 90 	st.w	sp[1680],r9
80009296:	87 1e       	st.w	r3[0x4],lr
80009298:	fb 48 06 8c 	st.w	sp[1676],r8
8000929c:	58 78       	cp.w	r8,7
8000929e:	e0 89 00 04 	brgt	800092a6 <_vfprintf_r+0x184e>
800092a2:	2f 83       	sub	r3,-8
800092a4:	c0 b8       	rjmp	800092ba <_vfprintf_r+0x1862>
800092a6:	fa ca f9 78 	sub	r10,sp,-1672
800092aa:	02 9b       	mov	r11,r1
800092ac:	08 9c       	mov	r12,r4
800092ae:	fe b0 f3 c7 	rcall	80007a3c <__sprint_r>
800092b2:	e0 81 03 5e 	brne	8000996e <_vfprintf_r+0x1f16>
800092b6:	fa c3 f9 e0 	sub	r3,sp,-1568
800092ba:	40 2c       	lddsp	r12,sp[0x8]
800092bc:	04 1c       	sub	r12,r2
800092be:	50 2c       	stdsp	sp[0x8],r12
800092c0:	58 0c       	cp.w	r12,0
800092c2:	e0 89 00 1f 	brgt	80009300 <_vfprintf_r+0x18a8>
800092c6:	c3 d8       	rjmp	80009340 <_vfprintf_r+0x18e8>
800092c8:	2f 09       	sub	r9,-16
800092ca:	2f f8       	sub	r8,-1
800092cc:	4b 3b       	lddpc	r11,80009398 <_vfprintf_r+0x1940>
800092ce:	31 0a       	mov	r10,16
800092d0:	fb 49 06 90 	st.w	sp[1680],r9
800092d4:	87 0b       	st.w	r3[0x0],r11
800092d6:	87 1a       	st.w	r3[0x4],r10
800092d8:	fb 48 06 8c 	st.w	sp[1676],r8
800092dc:	58 78       	cp.w	r8,7
800092de:	e0 89 00 04 	brgt	800092e6 <_vfprintf_r+0x188e>
800092e2:	2f 83       	sub	r3,-8
800092e4:	c0 b8       	rjmp	800092fa <_vfprintf_r+0x18a2>
800092e6:	fa ca f9 78 	sub	r10,sp,-1672
800092ea:	02 9b       	mov	r11,r1
800092ec:	08 9c       	mov	r12,r4
800092ee:	fe b0 f3 a7 	rcall	80007a3c <__sprint_r>
800092f2:	e0 81 03 3e 	brne	8000996e <_vfprintf_r+0x1f16>
800092f6:	fa c3 f9 e0 	sub	r3,sp,-1568
800092fa:	40 29       	lddsp	r9,sp[0x8]
800092fc:	21 09       	sub	r9,16
800092fe:	50 29       	stdsp	sp[0x8],r9
80009300:	fa f9 06 90 	ld.w	r9,sp[1680]
80009304:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009308:	4a 4a       	lddpc	r10,80009398 <_vfprintf_r+0x1940>
8000930a:	40 2e       	lddsp	lr,sp[0x8]
8000930c:	59 0e       	cp.w	lr,16
8000930e:	fe 99 ff dd 	brgt	800092c8 <_vfprintf_r+0x1870>
80009312:	1c 09       	add	r9,lr
80009314:	2f f8       	sub	r8,-1
80009316:	87 0a       	st.w	r3[0x0],r10
80009318:	fb 49 06 90 	st.w	sp[1680],r9
8000931c:	87 1e       	st.w	r3[0x4],lr
8000931e:	fb 48 06 8c 	st.w	sp[1676],r8
80009322:	58 78       	cp.w	r8,7
80009324:	e0 89 00 04 	brgt	8000932c <_vfprintf_r+0x18d4>
80009328:	2f 83       	sub	r3,-8
8000932a:	c0 b8       	rjmp	80009340 <_vfprintf_r+0x18e8>
8000932c:	fa ca f9 78 	sub	r10,sp,-1672
80009330:	02 9b       	mov	r11,r1
80009332:	08 9c       	mov	r12,r4
80009334:	fe b0 f3 84 	rcall	80007a3c <__sprint_r>
80009338:	e0 81 03 1b 	brne	8000996e <_vfprintf_r+0x1f16>
8000933c:	fa c3 f9 e0 	sub	r3,sp,-1568
80009340:	ed b5 00 08 	bld	r5,0x8
80009344:	c0 b0       	breq	8000935a <_vfprintf_r+0x1902>
80009346:	fa f8 06 90 	ld.w	r8,sp[1680]
8000934a:	87 12       	st.w	r3[0x4],r2
8000934c:	87 06       	st.w	r3[0x0],r6
8000934e:	f0 02 00 02 	add	r2,r8,r2
80009352:	fb 42 06 90 	st.w	sp[1680],r2
80009356:	e0 8f 01 d5 	bral	80009700 <_vfprintf_r+0x1ca8>
8000935a:	e0 40 00 65 	cp.w	r0,101
8000935e:	e0 8a 01 d7 	brle	8000970c <_vfprintf_r+0x1cb4>
80009362:	30 08       	mov	r8,0
80009364:	30 09       	mov	r9,0
80009366:	40 5b       	lddsp	r11,sp[0x14]
80009368:	40 7a       	lddsp	r10,sp[0x1c]
8000936a:	e0 a0 15 3e 	rcall	8000bde6 <__avr32_f64_cmp_eq>
8000936e:	c7 a0       	breq	80009462 <_vfprintf_r+0x1a0a>
80009370:	fa f8 06 90 	ld.w	r8,sp[1680]
80009374:	48 a9       	lddpc	r9,8000939c <_vfprintf_r+0x1944>
80009376:	2f f8       	sub	r8,-1
80009378:	87 09       	st.w	r3[0x0],r9
8000937a:	fb 48 06 90 	st.w	sp[1680],r8
8000937e:	30 19       	mov	r9,1
80009380:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009384:	87 19       	st.w	r3[0x4],r9
80009386:	2f f8       	sub	r8,-1
80009388:	fb 48 06 8c 	st.w	sp[1676],r8
8000938c:	58 78       	cp.w	r8,7
8000938e:	e0 89 00 09 	brgt	800093a0 <_vfprintf_r+0x1948>
80009392:	2f 83       	sub	r3,-8
80009394:	c1 08       	rjmp	800093b4 <_vfprintf_r+0x195c>
80009396:	d7 03       	nop
80009398:	80 01       	ld.sh	r1,r0[0x0]
8000939a:	5d c0       	*unknown*
8000939c:	80 01       	ld.sh	r1,r0[0x0]
8000939e:	5d ac       	*unknown*
800093a0:	fa ca f9 78 	sub	r10,sp,-1672
800093a4:	02 9b       	mov	r11,r1
800093a6:	08 9c       	mov	r12,r4
800093a8:	fe b0 f3 4a 	rcall	80007a3c <__sprint_r>
800093ac:	e0 81 02 e1 	brne	8000996e <_vfprintf_r+0x1f16>
800093b0:	fa c3 f9 e0 	sub	r3,sp,-1568
800093b4:	fa f8 06 ac 	ld.w	r8,sp[1708]
800093b8:	40 6c       	lddsp	r12,sp[0x18]
800093ba:	18 38       	cp.w	r8,r12
800093bc:	c0 55       	brlt	800093c6 <_vfprintf_r+0x196e>
800093be:	ed b5 00 00 	bld	r5,0x0
800093c2:	e0 81 02 69 	brne	80009894 <_vfprintf_r+0x1e3c>
800093c6:	fa f8 06 90 	ld.w	r8,sp[1680]
800093ca:	2f f8       	sub	r8,-1
800093cc:	40 cb       	lddsp	r11,sp[0x30]
800093ce:	fb 48 06 90 	st.w	sp[1680],r8
800093d2:	30 19       	mov	r9,1
800093d4:	fa f8 06 8c 	ld.w	r8,sp[1676]
800093d8:	87 0b       	st.w	r3[0x0],r11
800093da:	2f f8       	sub	r8,-1
800093dc:	87 19       	st.w	r3[0x4],r9
800093de:	fb 48 06 8c 	st.w	sp[1676],r8
800093e2:	58 78       	cp.w	r8,7
800093e4:	e0 89 00 04 	brgt	800093ec <_vfprintf_r+0x1994>
800093e8:	2f 83       	sub	r3,-8
800093ea:	c0 b8       	rjmp	80009400 <_vfprintf_r+0x19a8>
800093ec:	fa ca f9 78 	sub	r10,sp,-1672
800093f0:	02 9b       	mov	r11,r1
800093f2:	08 9c       	mov	r12,r4
800093f4:	fe b0 f3 24 	rcall	80007a3c <__sprint_r>
800093f8:	e0 81 02 bb 	brne	8000996e <_vfprintf_r+0x1f16>
800093fc:	fa c3 f9 e0 	sub	r3,sp,-1568
80009400:	40 66       	lddsp	r6,sp[0x18]
80009402:	20 16       	sub	r6,1
80009404:	58 06       	cp.w	r6,0
80009406:	e0 89 00 1d 	brgt	80009440 <_vfprintf_r+0x19e8>
8000940a:	e0 8f 02 45 	bral	80009894 <_vfprintf_r+0x1e3c>
8000940e:	2f 09       	sub	r9,-16
80009410:	2f f8       	sub	r8,-1
80009412:	fb 49 06 90 	st.w	sp[1680],r9
80009416:	87 02       	st.w	r3[0x0],r2
80009418:	87 10       	st.w	r3[0x4],r0
8000941a:	fb 48 06 8c 	st.w	sp[1676],r8
8000941e:	58 78       	cp.w	r8,7
80009420:	e0 89 00 04 	brgt	80009428 <_vfprintf_r+0x19d0>
80009424:	2f 83       	sub	r3,-8
80009426:	c0 b8       	rjmp	8000943c <_vfprintf_r+0x19e4>
80009428:	fa ca f9 78 	sub	r10,sp,-1672
8000942c:	02 9b       	mov	r11,r1
8000942e:	08 9c       	mov	r12,r4
80009430:	fe b0 f3 06 	rcall	80007a3c <__sprint_r>
80009434:	e0 81 02 9d 	brne	8000996e <_vfprintf_r+0x1f16>
80009438:	fa c3 f9 e0 	sub	r3,sp,-1568
8000943c:	21 06       	sub	r6,16
8000943e:	c0 38       	rjmp	80009444 <_vfprintf_r+0x19ec>
80009440:	4d 22       	lddpc	r2,80009588 <_vfprintf_r+0x1b30>
80009442:	31 00       	mov	r0,16
80009444:	fa f9 06 90 	ld.w	r9,sp[1680]
80009448:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000944c:	4c fa       	lddpc	r10,80009588 <_vfprintf_r+0x1b30>
8000944e:	59 06       	cp.w	r6,16
80009450:	fe 99 ff df 	brgt	8000940e <_vfprintf_r+0x19b6>
80009454:	0c 09       	add	r9,r6
80009456:	87 0a       	st.w	r3[0x0],r10
80009458:	fb 49 06 90 	st.w	sp[1680],r9
8000945c:	2f f8       	sub	r8,-1
8000945e:	87 16       	st.w	r3[0x4],r6
80009460:	c5 39       	rjmp	80009706 <_vfprintf_r+0x1cae>
80009462:	fa fa 06 ac 	ld.w	r10,sp[1708]
80009466:	58 0a       	cp.w	r10,0
80009468:	e0 89 00 94 	brgt	80009590 <_vfprintf_r+0x1b38>
8000946c:	fa f8 06 90 	ld.w	r8,sp[1680]
80009470:	4c 79       	lddpc	r9,8000958c <_vfprintf_r+0x1b34>
80009472:	2f f8       	sub	r8,-1
80009474:	87 09       	st.w	r3[0x0],r9
80009476:	fb 48 06 90 	st.w	sp[1680],r8
8000947a:	30 19       	mov	r9,1
8000947c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009480:	87 19       	st.w	r3[0x4],r9
80009482:	2f f8       	sub	r8,-1
80009484:	fb 48 06 8c 	st.w	sp[1676],r8
80009488:	58 78       	cp.w	r8,7
8000948a:	e0 89 00 04 	brgt	80009492 <_vfprintf_r+0x1a3a>
8000948e:	2f 83       	sub	r3,-8
80009490:	c0 b8       	rjmp	800094a6 <_vfprintf_r+0x1a4e>
80009492:	fa ca f9 78 	sub	r10,sp,-1672
80009496:	02 9b       	mov	r11,r1
80009498:	08 9c       	mov	r12,r4
8000949a:	fe b0 f2 d1 	rcall	80007a3c <__sprint_r>
8000949e:	e0 81 02 68 	brne	8000996e <_vfprintf_r+0x1f16>
800094a2:	fa c3 f9 e0 	sub	r3,sp,-1568
800094a6:	fa f8 06 ac 	ld.w	r8,sp[1708]
800094aa:	58 08       	cp.w	r8,0
800094ac:	c0 81       	brne	800094bc <_vfprintf_r+0x1a64>
800094ae:	40 6a       	lddsp	r10,sp[0x18]
800094b0:	58 0a       	cp.w	r10,0
800094b2:	c0 51       	brne	800094bc <_vfprintf_r+0x1a64>
800094b4:	ed b5 00 00 	bld	r5,0x0
800094b8:	e0 81 01 ee 	brne	80009894 <_vfprintf_r+0x1e3c>
800094bc:	40 c9       	lddsp	r9,sp[0x30]
800094be:	fa f8 06 90 	ld.w	r8,sp[1680]
800094c2:	2f f8       	sub	r8,-1
800094c4:	87 09       	st.w	r3[0x0],r9
800094c6:	fb 48 06 90 	st.w	sp[1680],r8
800094ca:	30 19       	mov	r9,1
800094cc:	fa f8 06 8c 	ld.w	r8,sp[1676]
800094d0:	87 19       	st.w	r3[0x4],r9
800094d2:	2f f8       	sub	r8,-1
800094d4:	fb 48 06 8c 	st.w	sp[1676],r8
800094d8:	58 78       	cp.w	r8,7
800094da:	e0 89 00 04 	brgt	800094e2 <_vfprintf_r+0x1a8a>
800094de:	2f 83       	sub	r3,-8
800094e0:	c0 b8       	rjmp	800094f6 <_vfprintf_r+0x1a9e>
800094e2:	fa ca f9 78 	sub	r10,sp,-1672
800094e6:	02 9b       	mov	r11,r1
800094e8:	08 9c       	mov	r12,r4
800094ea:	fe b0 f2 a9 	rcall	80007a3c <__sprint_r>
800094ee:	e0 81 02 40 	brne	8000996e <_vfprintf_r+0x1f16>
800094f2:	fa c3 f9 e0 	sub	r3,sp,-1568
800094f6:	fa f2 06 ac 	ld.w	r2,sp[1708]
800094fa:	5c 32       	neg	r2
800094fc:	58 02       	cp.w	r2,0
800094fe:	e0 89 00 1d 	brgt	80009538 <_vfprintf_r+0x1ae0>
80009502:	c3 b8       	rjmp	80009578 <_vfprintf_r+0x1b20>
80009504:	2f 09       	sub	r9,-16
80009506:	2f f8       	sub	r8,-1
80009508:	31 0e       	mov	lr,16
8000950a:	fb 49 06 90 	st.w	sp[1680],r9
8000950e:	87 00       	st.w	r3[0x0],r0
80009510:	87 1e       	st.w	r3[0x4],lr
80009512:	fb 48 06 8c 	st.w	sp[1676],r8
80009516:	58 78       	cp.w	r8,7
80009518:	e0 89 00 04 	brgt	80009520 <_vfprintf_r+0x1ac8>
8000951c:	2f 83       	sub	r3,-8
8000951e:	c0 b8       	rjmp	80009534 <_vfprintf_r+0x1adc>
80009520:	fa ca f9 78 	sub	r10,sp,-1672
80009524:	02 9b       	mov	r11,r1
80009526:	08 9c       	mov	r12,r4
80009528:	fe b0 f2 8a 	rcall	80007a3c <__sprint_r>
8000952c:	e0 81 02 21 	brne	8000996e <_vfprintf_r+0x1f16>
80009530:	fa c3 f9 e0 	sub	r3,sp,-1568
80009534:	21 02       	sub	r2,16
80009536:	c0 28       	rjmp	8000953a <_vfprintf_r+0x1ae2>
80009538:	49 40       	lddpc	r0,80009588 <_vfprintf_r+0x1b30>
8000953a:	fa f9 06 90 	ld.w	r9,sp[1680]
8000953e:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009542:	49 2a       	lddpc	r10,80009588 <_vfprintf_r+0x1b30>
80009544:	59 02       	cp.w	r2,16
80009546:	fe 99 ff df 	brgt	80009504 <_vfprintf_r+0x1aac>
8000954a:	04 09       	add	r9,r2
8000954c:	2f f8       	sub	r8,-1
8000954e:	87 0a       	st.w	r3[0x0],r10
80009550:	fb 49 06 90 	st.w	sp[1680],r9
80009554:	87 12       	st.w	r3[0x4],r2
80009556:	fb 48 06 8c 	st.w	sp[1676],r8
8000955a:	58 78       	cp.w	r8,7
8000955c:	e0 89 00 04 	brgt	80009564 <_vfprintf_r+0x1b0c>
80009560:	2f 83       	sub	r3,-8
80009562:	c0 b8       	rjmp	80009578 <_vfprintf_r+0x1b20>
80009564:	fa ca f9 78 	sub	r10,sp,-1672
80009568:	02 9b       	mov	r11,r1
8000956a:	08 9c       	mov	r12,r4
8000956c:	fe b0 f2 68 	rcall	80007a3c <__sprint_r>
80009570:	e0 81 01 ff 	brne	8000996e <_vfprintf_r+0x1f16>
80009574:	fa c3 f9 e0 	sub	r3,sp,-1568
80009578:	40 6c       	lddsp	r12,sp[0x18]
8000957a:	fa f8 06 90 	ld.w	r8,sp[1680]
8000957e:	87 06       	st.w	r3[0x0],r6
80009580:	87 1c       	st.w	r3[0x4],r12
80009582:	18 08       	add	r8,r12
80009584:	cb c8       	rjmp	800096fc <_vfprintf_r+0x1ca4>
80009586:	d7 03       	nop
80009588:	80 01       	ld.sh	r1,r0[0x0]
8000958a:	5d c0       	*unknown*
8000958c:	80 01       	ld.sh	r1,r0[0x0]
8000958e:	5d ac       	*unknown*
80009590:	fa f9 06 90 	ld.w	r9,sp[1680]
80009594:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009598:	40 6b       	lddsp	r11,sp[0x18]
8000959a:	16 3a       	cp.w	r10,r11
8000959c:	c6 d5       	brlt	80009676 <_vfprintf_r+0x1c1e>
8000959e:	16 09       	add	r9,r11
800095a0:	2f f8       	sub	r8,-1
800095a2:	87 06       	st.w	r3[0x0],r6
800095a4:	fb 49 06 90 	st.w	sp[1680],r9
800095a8:	87 1b       	st.w	r3[0x4],r11
800095aa:	fb 48 06 8c 	st.w	sp[1676],r8
800095ae:	58 78       	cp.w	r8,7
800095b0:	e0 89 00 04 	brgt	800095b8 <_vfprintf_r+0x1b60>
800095b4:	2f 83       	sub	r3,-8
800095b6:	c0 b8       	rjmp	800095cc <_vfprintf_r+0x1b74>
800095b8:	fa ca f9 78 	sub	r10,sp,-1672
800095bc:	02 9b       	mov	r11,r1
800095be:	08 9c       	mov	r12,r4
800095c0:	fe b0 f2 3e 	rcall	80007a3c <__sprint_r>
800095c4:	e0 81 01 d5 	brne	8000996e <_vfprintf_r+0x1f16>
800095c8:	fa c3 f9 e0 	sub	r3,sp,-1568
800095cc:	fa f6 06 ac 	ld.w	r6,sp[1708]
800095d0:	40 6a       	lddsp	r10,sp[0x18]
800095d2:	14 16       	sub	r6,r10
800095d4:	58 06       	cp.w	r6,0
800095d6:	e0 89 00 1c 	brgt	8000960e <_vfprintf_r+0x1bb6>
800095da:	c3 b8       	rjmp	80009650 <_vfprintf_r+0x1bf8>
800095dc:	2f 09       	sub	r9,-16
800095de:	2f f8       	sub	r8,-1
800095e0:	fb 49 06 90 	st.w	sp[1680],r9
800095e4:	87 02       	st.w	r3[0x0],r2
800095e6:	87 10       	st.w	r3[0x4],r0
800095e8:	fb 48 06 8c 	st.w	sp[1676],r8
800095ec:	58 78       	cp.w	r8,7
800095ee:	e0 89 00 04 	brgt	800095f6 <_vfprintf_r+0x1b9e>
800095f2:	2f 83       	sub	r3,-8
800095f4:	c0 b8       	rjmp	8000960a <_vfprintf_r+0x1bb2>
800095f6:	fa ca f9 78 	sub	r10,sp,-1672
800095fa:	02 9b       	mov	r11,r1
800095fc:	08 9c       	mov	r12,r4
800095fe:	fe b0 f2 1f 	rcall	80007a3c <__sprint_r>
80009602:	e0 81 01 b6 	brne	8000996e <_vfprintf_r+0x1f16>
80009606:	fa c3 f9 e0 	sub	r3,sp,-1568
8000960a:	21 06       	sub	r6,16
8000960c:	c0 38       	rjmp	80009612 <_vfprintf_r+0x1bba>
8000960e:	4d c2       	lddpc	r2,8000977c <_vfprintf_r+0x1d24>
80009610:	31 00       	mov	r0,16
80009612:	fa f9 06 90 	ld.w	r9,sp[1680]
80009616:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000961a:	4d 9a       	lddpc	r10,8000977c <_vfprintf_r+0x1d24>
8000961c:	59 06       	cp.w	r6,16
8000961e:	fe 99 ff df 	brgt	800095dc <_vfprintf_r+0x1b84>
80009622:	0c 09       	add	r9,r6
80009624:	2f f8       	sub	r8,-1
80009626:	87 0a       	st.w	r3[0x0],r10
80009628:	fb 49 06 90 	st.w	sp[1680],r9
8000962c:	87 16       	st.w	r3[0x4],r6
8000962e:	fb 48 06 8c 	st.w	sp[1676],r8
80009632:	58 78       	cp.w	r8,7
80009634:	e0 89 00 04 	brgt	8000963c <_vfprintf_r+0x1be4>
80009638:	2f 83       	sub	r3,-8
8000963a:	c0 b8       	rjmp	80009650 <_vfprintf_r+0x1bf8>
8000963c:	fa ca f9 78 	sub	r10,sp,-1672
80009640:	02 9b       	mov	r11,r1
80009642:	08 9c       	mov	r12,r4
80009644:	fe b0 f1 fc 	rcall	80007a3c <__sprint_r>
80009648:	e0 81 01 93 	brne	8000996e <_vfprintf_r+0x1f16>
8000964c:	fa c3 f9 e0 	sub	r3,sp,-1568
80009650:	ed b5 00 00 	bld	r5,0x0
80009654:	e0 81 01 20 	brne	80009894 <_vfprintf_r+0x1e3c>
80009658:	40 c9       	lddsp	r9,sp[0x30]
8000965a:	fa f8 06 90 	ld.w	r8,sp[1680]
8000965e:	2f f8       	sub	r8,-1
80009660:	87 09       	st.w	r3[0x0],r9
80009662:	fb 48 06 90 	st.w	sp[1680],r8
80009666:	30 19       	mov	r9,1
80009668:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000966c:	87 19       	st.w	r3[0x4],r9
8000966e:	2f f8       	sub	r8,-1
80009670:	fb 48 06 8c 	st.w	sp[1676],r8
80009674:	c0 29       	rjmp	80009878 <_vfprintf_r+0x1e20>
80009676:	14 09       	add	r9,r10
80009678:	2f f8       	sub	r8,-1
8000967a:	fb 49 06 90 	st.w	sp[1680],r9
8000967e:	87 06       	st.w	r3[0x0],r6
80009680:	87 1a       	st.w	r3[0x4],r10
80009682:	fb 48 06 8c 	st.w	sp[1676],r8
80009686:	58 78       	cp.w	r8,7
80009688:	e0 89 00 04 	brgt	80009690 <_vfprintf_r+0x1c38>
8000968c:	2f 83       	sub	r3,-8
8000968e:	c0 b8       	rjmp	800096a4 <_vfprintf_r+0x1c4c>
80009690:	fa ca f9 78 	sub	r10,sp,-1672
80009694:	02 9b       	mov	r11,r1
80009696:	08 9c       	mov	r12,r4
80009698:	fe b0 f1 d2 	rcall	80007a3c <__sprint_r>
8000969c:	e0 81 01 69 	brne	8000996e <_vfprintf_r+0x1f16>
800096a0:	fa c3 f9 e0 	sub	r3,sp,-1568
800096a4:	40 c8       	lddsp	r8,sp[0x30]
800096a6:	87 08       	st.w	r3[0x0],r8
800096a8:	fa f8 06 90 	ld.w	r8,sp[1680]
800096ac:	2f f8       	sub	r8,-1
800096ae:	30 19       	mov	r9,1
800096b0:	fb 48 06 90 	st.w	sp[1680],r8
800096b4:	87 19       	st.w	r3[0x4],r9
800096b6:	fa f8 06 8c 	ld.w	r8,sp[1676]
800096ba:	2f f8       	sub	r8,-1
800096bc:	fb 48 06 8c 	st.w	sp[1676],r8
800096c0:	fa f2 06 ac 	ld.w	r2,sp[1708]
800096c4:	58 78       	cp.w	r8,7
800096c6:	e0 89 00 04 	brgt	800096ce <_vfprintf_r+0x1c76>
800096ca:	2f 83       	sub	r3,-8
800096cc:	c0 b8       	rjmp	800096e2 <_vfprintf_r+0x1c8a>
800096ce:	fa ca f9 78 	sub	r10,sp,-1672
800096d2:	02 9b       	mov	r11,r1
800096d4:	08 9c       	mov	r12,r4
800096d6:	fe b0 f1 b3 	rcall	80007a3c <__sprint_r>
800096da:	e0 81 01 4a 	brne	8000996e <_vfprintf_r+0x1f16>
800096de:	fa c3 f9 e0 	sub	r3,sp,-1568
800096e2:	04 06       	add	r6,r2
800096e4:	fa f8 06 ac 	ld.w	r8,sp[1708]
800096e8:	87 06       	st.w	r3[0x0],r6
800096ea:	fa f9 06 90 	ld.w	r9,sp[1680]
800096ee:	40 66       	lddsp	r6,sp[0x18]
800096f0:	40 6e       	lddsp	lr,sp[0x18]
800096f2:	10 16       	sub	r6,r8
800096f4:	f2 08 01 08 	sub	r8,r9,r8
800096f8:	87 16       	st.w	r3[0x4],r6
800096fa:	1c 08       	add	r8,lr
800096fc:	fb 48 06 90 	st.w	sp[1680],r8
80009700:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009704:	2f f8       	sub	r8,-1
80009706:	fb 48 06 8c 	st.w	sp[1676],r8
8000970a:	cb 78       	rjmp	80009878 <_vfprintf_r+0x1e20>
8000970c:	40 6c       	lddsp	r12,sp[0x18]
8000970e:	58 1c       	cp.w	r12,1
80009710:	e0 89 00 06 	brgt	8000971c <_vfprintf_r+0x1cc4>
80009714:	ed b5 00 00 	bld	r5,0x0
80009718:	e0 81 00 85 	brne	80009822 <_vfprintf_r+0x1dca>
8000971c:	fa f8 06 90 	ld.w	r8,sp[1680]
80009720:	2f f8       	sub	r8,-1
80009722:	30 19       	mov	r9,1
80009724:	fb 48 06 90 	st.w	sp[1680],r8
80009728:	87 06       	st.w	r3[0x0],r6
8000972a:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000972e:	87 19       	st.w	r3[0x4],r9
80009730:	2f f8       	sub	r8,-1
80009732:	fb 48 06 8c 	st.w	sp[1676],r8
80009736:	58 78       	cp.w	r8,7
80009738:	e0 89 00 04 	brgt	80009740 <_vfprintf_r+0x1ce8>
8000973c:	2f 83       	sub	r3,-8
8000973e:	c0 b8       	rjmp	80009754 <_vfprintf_r+0x1cfc>
80009740:	fa ca f9 78 	sub	r10,sp,-1672
80009744:	02 9b       	mov	r11,r1
80009746:	08 9c       	mov	r12,r4
80009748:	fe b0 f1 7a 	rcall	80007a3c <__sprint_r>
8000974c:	e0 81 01 11 	brne	8000996e <_vfprintf_r+0x1f16>
80009750:	fa c3 f9 e0 	sub	r3,sp,-1568
80009754:	fa f8 06 90 	ld.w	r8,sp[1680]
80009758:	2f f8       	sub	r8,-1
8000975a:	40 cb       	lddsp	r11,sp[0x30]
8000975c:	fb 48 06 90 	st.w	sp[1680],r8
80009760:	30 19       	mov	r9,1
80009762:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009766:	87 0b       	st.w	r3[0x0],r11
80009768:	2f f8       	sub	r8,-1
8000976a:	87 19       	st.w	r3[0x4],r9
8000976c:	fb 48 06 8c 	st.w	sp[1676],r8
80009770:	58 78       	cp.w	r8,7
80009772:	e0 89 00 07 	brgt	80009780 <_vfprintf_r+0x1d28>
80009776:	2f 83       	sub	r3,-8
80009778:	c0 e8       	rjmp	80009794 <_vfprintf_r+0x1d3c>
8000977a:	d7 03       	nop
8000977c:	80 01       	ld.sh	r1,r0[0x0]
8000977e:	5d c0       	*unknown*
80009780:	fa ca f9 78 	sub	r10,sp,-1672
80009784:	02 9b       	mov	r11,r1
80009786:	08 9c       	mov	r12,r4
80009788:	fe b0 f1 5a 	rcall	80007a3c <__sprint_r>
8000978c:	e0 81 00 f1 	brne	8000996e <_vfprintf_r+0x1f16>
80009790:	fa c3 f9 e0 	sub	r3,sp,-1568
80009794:	30 08       	mov	r8,0
80009796:	30 09       	mov	r9,0
80009798:	40 5b       	lddsp	r11,sp[0x14]
8000979a:	40 7a       	lddsp	r10,sp[0x1c]
8000979c:	e0 a0 13 25 	rcall	8000bde6 <__avr32_f64_cmp_eq>
800097a0:	40 68       	lddsp	r8,sp[0x18]
800097a2:	20 18       	sub	r8,1
800097a4:	58 0c       	cp.w	r12,0
800097a6:	c0 d1       	brne	800097c0 <_vfprintf_r+0x1d68>
800097a8:	2f f6       	sub	r6,-1
800097aa:	87 18       	st.w	r3[0x4],r8
800097ac:	87 06       	st.w	r3[0x0],r6
800097ae:	fa f6 06 90 	ld.w	r6,sp[1680]
800097b2:	10 06       	add	r6,r8
800097b4:	fa f8 06 8c 	ld.w	r8,sp[1676]
800097b8:	fb 46 06 90 	st.w	sp[1680],r6
800097bc:	2f f8       	sub	r8,-1
800097be:	c2 f8       	rjmp	8000981c <_vfprintf_r+0x1dc4>
800097c0:	10 96       	mov	r6,r8
800097c2:	58 08       	cp.w	r8,0
800097c4:	e0 89 00 1c 	brgt	800097fc <_vfprintf_r+0x1da4>
800097c8:	c4 98       	rjmp	8000985a <_vfprintf_r+0x1e02>
800097ca:	2f 09       	sub	r9,-16
800097cc:	2f f8       	sub	r8,-1
800097ce:	fb 49 06 90 	st.w	sp[1680],r9
800097d2:	87 02       	st.w	r3[0x0],r2
800097d4:	87 10       	st.w	r3[0x4],r0
800097d6:	fb 48 06 8c 	st.w	sp[1676],r8
800097da:	58 78       	cp.w	r8,7
800097dc:	e0 89 00 04 	brgt	800097e4 <_vfprintf_r+0x1d8c>
800097e0:	2f 83       	sub	r3,-8
800097e2:	c0 b8       	rjmp	800097f8 <_vfprintf_r+0x1da0>
800097e4:	fa ca f9 78 	sub	r10,sp,-1672
800097e8:	02 9b       	mov	r11,r1
800097ea:	08 9c       	mov	r12,r4
800097ec:	fe b0 f1 28 	rcall	80007a3c <__sprint_r>
800097f0:	e0 81 00 bf 	brne	8000996e <_vfprintf_r+0x1f16>
800097f4:	fa c3 f9 e0 	sub	r3,sp,-1568
800097f8:	21 06       	sub	r6,16
800097fa:	c0 38       	rjmp	80009800 <_vfprintf_r+0x1da8>
800097fc:	4d 22       	lddpc	r2,80009944 <_vfprintf_r+0x1eec>
800097fe:	31 00       	mov	r0,16
80009800:	fa f9 06 90 	ld.w	r9,sp[1680]
80009804:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009808:	4c fa       	lddpc	r10,80009944 <_vfprintf_r+0x1eec>
8000980a:	59 06       	cp.w	r6,16
8000980c:	fe 99 ff df 	brgt	800097ca <_vfprintf_r+0x1d72>
80009810:	0c 09       	add	r9,r6
80009812:	87 0a       	st.w	r3[0x0],r10
80009814:	fb 49 06 90 	st.w	sp[1680],r9
80009818:	2f f8       	sub	r8,-1
8000981a:	87 16       	st.w	r3[0x4],r6
8000981c:	fb 48 06 8c 	st.w	sp[1676],r8
80009820:	c0 e8       	rjmp	8000983c <_vfprintf_r+0x1de4>
80009822:	fa f8 06 90 	ld.w	r8,sp[1680]
80009826:	2f f8       	sub	r8,-1
80009828:	30 19       	mov	r9,1
8000982a:	fb 48 06 90 	st.w	sp[1680],r8
8000982e:	87 06       	st.w	r3[0x0],r6
80009830:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009834:	87 19       	st.w	r3[0x4],r9
80009836:	2f f8       	sub	r8,-1
80009838:	fb 48 06 8c 	st.w	sp[1676],r8
8000983c:	58 78       	cp.w	r8,7
8000983e:	e0 89 00 04 	brgt	80009846 <_vfprintf_r+0x1dee>
80009842:	2f 83       	sub	r3,-8
80009844:	c0 b8       	rjmp	8000985a <_vfprintf_r+0x1e02>
80009846:	fa ca f9 78 	sub	r10,sp,-1672
8000984a:	02 9b       	mov	r11,r1
8000984c:	08 9c       	mov	r12,r4
8000984e:	fe b0 f0 f7 	rcall	80007a3c <__sprint_r>
80009852:	e0 81 00 8e 	brne	8000996e <_vfprintf_r+0x1f16>
80009856:	fa c3 f9 e0 	sub	r3,sp,-1568
8000985a:	40 ea       	lddsp	r10,sp[0x38]
8000985c:	fa f8 06 90 	ld.w	r8,sp[1680]
80009860:	14 08       	add	r8,r10
80009862:	fa c9 f9 64 	sub	r9,sp,-1692
80009866:	fb 48 06 90 	st.w	sp[1680],r8
8000986a:	87 1a       	st.w	r3[0x4],r10
8000986c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009870:	87 09       	st.w	r3[0x0],r9
80009872:	2f f8       	sub	r8,-1
80009874:	fb 48 06 8c 	st.w	sp[1676],r8
80009878:	58 78       	cp.w	r8,7
8000987a:	e0 89 00 04 	brgt	80009882 <_vfprintf_r+0x1e2a>
8000987e:	2f 83       	sub	r3,-8
80009880:	c0 a8       	rjmp	80009894 <_vfprintf_r+0x1e3c>
80009882:	fa ca f9 78 	sub	r10,sp,-1672
80009886:	02 9b       	mov	r11,r1
80009888:	08 9c       	mov	r12,r4
8000988a:	fe b0 f0 d9 	rcall	80007a3c <__sprint_r>
8000988e:	c7 01       	brne	8000996e <_vfprintf_r+0x1f16>
80009890:	fa c3 f9 e0 	sub	r3,sp,-1568
80009894:	e2 15 00 04 	andl	r5,0x4,COH
80009898:	c3 d0       	breq	80009912 <_vfprintf_r+0x1eba>
8000989a:	40 86       	lddsp	r6,sp[0x20]
8000989c:	40 39       	lddsp	r9,sp[0xc]
8000989e:	12 16       	sub	r6,r9
800098a0:	58 06       	cp.w	r6,0
800098a2:	e0 89 00 1a 	brgt	800098d6 <_vfprintf_r+0x1e7e>
800098a6:	c3 68       	rjmp	80009912 <_vfprintf_r+0x1eba>
800098a8:	2f 09       	sub	r9,-16
800098aa:	2f f8       	sub	r8,-1
800098ac:	fb 49 06 90 	st.w	sp[1680],r9
800098b0:	87 05       	st.w	r3[0x0],r5
800098b2:	87 12       	st.w	r3[0x4],r2
800098b4:	fb 48 06 8c 	st.w	sp[1676],r8
800098b8:	58 78       	cp.w	r8,7
800098ba:	e0 89 00 04 	brgt	800098c2 <_vfprintf_r+0x1e6a>
800098be:	2f 83       	sub	r3,-8
800098c0:	c0 98       	rjmp	800098d2 <_vfprintf_r+0x1e7a>
800098c2:	00 9a       	mov	r10,r0
800098c4:	02 9b       	mov	r11,r1
800098c6:	08 9c       	mov	r12,r4
800098c8:	fe b0 f0 ba 	rcall	80007a3c <__sprint_r>
800098cc:	c5 11       	brne	8000996e <_vfprintf_r+0x1f16>
800098ce:	fa c3 f9 e0 	sub	r3,sp,-1568
800098d2:	21 06       	sub	r6,16
800098d4:	c0 58       	rjmp	800098de <_vfprintf_r+0x1e86>
800098d6:	49 d5       	lddpc	r5,80009948 <_vfprintf_r+0x1ef0>
800098d8:	31 02       	mov	r2,16
800098da:	fa c0 f9 78 	sub	r0,sp,-1672
800098de:	fa f9 06 90 	ld.w	r9,sp[1680]
800098e2:	fa f8 06 8c 	ld.w	r8,sp[1676]
800098e6:	49 9a       	lddpc	r10,80009948 <_vfprintf_r+0x1ef0>
800098e8:	59 06       	cp.w	r6,16
800098ea:	fe 99 ff df 	brgt	800098a8 <_vfprintf_r+0x1e50>
800098ee:	0c 09       	add	r9,r6
800098f0:	2f f8       	sub	r8,-1
800098f2:	87 0a       	st.w	r3[0x0],r10
800098f4:	87 16       	st.w	r3[0x4],r6
800098f6:	fb 49 06 90 	st.w	sp[1680],r9
800098fa:	fb 48 06 8c 	st.w	sp[1676],r8
800098fe:	58 78       	cp.w	r8,7
80009900:	e0 8a 00 09 	brle	80009912 <_vfprintf_r+0x1eba>
80009904:	fa ca f9 78 	sub	r10,sp,-1672
80009908:	02 9b       	mov	r11,r1
8000990a:	08 9c       	mov	r12,r4
8000990c:	fe b0 f0 98 	rcall	80007a3c <__sprint_r>
80009910:	c2 f1       	brne	8000996e <_vfprintf_r+0x1f16>
80009912:	40 bc       	lddsp	r12,sp[0x2c]
80009914:	40 36       	lddsp	r6,sp[0xc]
80009916:	40 8e       	lddsp	lr,sp[0x20]
80009918:	ec 0e 0c 48 	max	r8,r6,lr
8000991c:	10 0c       	add	r12,r8
8000991e:	50 bc       	stdsp	sp[0x2c],r12
80009920:	fa f8 06 90 	ld.w	r8,sp[1680]
80009924:	58 08       	cp.w	r8,0
80009926:	c0 80       	breq	80009936 <_vfprintf_r+0x1ede>
80009928:	fa ca f9 78 	sub	r10,sp,-1672
8000992c:	02 9b       	mov	r11,r1
8000992e:	08 9c       	mov	r12,r4
80009930:	fe b0 f0 86 	rcall	80007a3c <__sprint_r>
80009934:	c1 d1       	brne	8000996e <_vfprintf_r+0x1f16>
80009936:	30 0b       	mov	r11,0
80009938:	fa c3 f9 e0 	sub	r3,sp,-1568
8000993c:	fb 4b 06 8c 	st.w	sp[1676],r11
80009940:	fe 9f f1 17 	bral	80007b6e <_vfprintf_r+0x116>
80009944:	80 01       	ld.sh	r1,r0[0x0]
80009946:	5d c0       	*unknown*
80009948:	80 01       	ld.sh	r1,r0[0x0]
8000994a:	5d b0       	*unknown*
8000994c:	08 95       	mov	r5,r4
8000994e:	fa f8 06 90 	ld.w	r8,sp[1680]
80009952:	58 08       	cp.w	r8,0
80009954:	c0 80       	breq	80009964 <_vfprintf_r+0x1f0c>
80009956:	08 9c       	mov	r12,r4
80009958:	fa ca f9 78 	sub	r10,sp,-1672
8000995c:	02 9b       	mov	r11,r1
8000995e:	fe b0 f0 6f 	rcall	80007a3c <__sprint_r>
80009962:	c0 61       	brne	8000996e <_vfprintf_r+0x1f16>
80009964:	30 08       	mov	r8,0
80009966:	fb 48 06 8c 	st.w	sp[1676],r8
8000996a:	c0 28       	rjmp	8000996e <_vfprintf_r+0x1f16>
8000996c:	40 41       	lddsp	r1,sp[0x10]
8000996e:	82 68       	ld.sh	r8,r1[0xc]
80009970:	ed b8 00 06 	bld	r8,0x6
80009974:	c0 31       	brne	8000997a <_vfprintf_r+0x1f22>
80009976:	3f fa       	mov	r10,-1
80009978:	50 ba       	stdsp	sp[0x2c],r10
8000997a:	40 bc       	lddsp	r12,sp[0x2c]
8000997c:	fe 3d f9 44 	sub	sp,-1724
80009980:	d8 32       	popm	r0-r7,pc
80009982:	d7 03       	nop

80009984 <__swsetup_r>:
80009984:	d4 21       	pushm	r4-r7,lr
80009986:	e0 68 0a 3c 	mov	r8,2620
8000998a:	18 96       	mov	r6,r12
8000998c:	16 97       	mov	r7,r11
8000998e:	70 0c       	ld.w	r12,r8[0x0]
80009990:	58 0c       	cp.w	r12,0
80009992:	c0 60       	breq	8000999e <__swsetup_r+0x1a>
80009994:	78 68       	ld.w	r8,r12[0x18]
80009996:	58 08       	cp.w	r8,0
80009998:	c0 31       	brne	8000999e <__swsetup_r+0x1a>
8000999a:	e0 a0 07 c7 	rcall	8000a928 <__sinit>
8000999e:	4a f8       	lddpc	r8,80009a58 <__swsetup_r+0xd4>
800099a0:	10 37       	cp.w	r7,r8
800099a2:	c0 61       	brne	800099ae <__swsetup_r+0x2a>
800099a4:	e0 68 0a 3c 	mov	r8,2620
800099a8:	70 08       	ld.w	r8,r8[0x0]
800099aa:	70 07       	ld.w	r7,r8[0x0]
800099ac:	c1 08       	rjmp	800099cc <__swsetup_r+0x48>
800099ae:	4a c8       	lddpc	r8,80009a5c <__swsetup_r+0xd8>
800099b0:	10 37       	cp.w	r7,r8
800099b2:	c0 61       	brne	800099be <__swsetup_r+0x3a>
800099b4:	e0 68 0a 3c 	mov	r8,2620
800099b8:	70 08       	ld.w	r8,r8[0x0]
800099ba:	70 17       	ld.w	r7,r8[0x4]
800099bc:	c0 88       	rjmp	800099cc <__swsetup_r+0x48>
800099be:	4a 98       	lddpc	r8,80009a60 <__swsetup_r+0xdc>
800099c0:	10 37       	cp.w	r7,r8
800099c2:	c0 51       	brne	800099cc <__swsetup_r+0x48>
800099c4:	e0 68 0a 3c 	mov	r8,2620
800099c8:	70 08       	ld.w	r8,r8[0x0]
800099ca:	70 27       	ld.w	r7,r8[0x8]
800099cc:	8e 68       	ld.sh	r8,r7[0xc]
800099ce:	ed b8 00 03 	bld	r8,0x3
800099d2:	c1 e0       	breq	80009a0e <__swsetup_r+0x8a>
800099d4:	ed b8 00 04 	bld	r8,0x4
800099d8:	c3 e1       	brne	80009a54 <__swsetup_r+0xd0>
800099da:	ed b8 00 02 	bld	r8,0x2
800099de:	c1 51       	brne	80009a08 <__swsetup_r+0x84>
800099e0:	6e db       	ld.w	r11,r7[0x34]
800099e2:	58 0b       	cp.w	r11,0
800099e4:	c0 a0       	breq	800099f8 <__swsetup_r+0x74>
800099e6:	ee c8 ff bc 	sub	r8,r7,-68
800099ea:	10 3b       	cp.w	r11,r8
800099ec:	c0 40       	breq	800099f4 <__swsetup_r+0x70>
800099ee:	0c 9c       	mov	r12,r6
800099f0:	e0 a0 08 36 	rcall	8000aa5c <_free_r>
800099f4:	30 08       	mov	r8,0
800099f6:	8f d8       	st.w	r7[0x34],r8
800099f8:	8e 68       	ld.sh	r8,r7[0xc]
800099fa:	e0 18 ff db 	andl	r8,0xffdb
800099fe:	ae 68       	st.h	r7[0xc],r8
80009a00:	30 08       	mov	r8,0
80009a02:	8f 18       	st.w	r7[0x4],r8
80009a04:	6e 48       	ld.w	r8,r7[0x10]
80009a06:	8f 08       	st.w	r7[0x0],r8
80009a08:	8e 68       	ld.sh	r8,r7[0xc]
80009a0a:	a3 b8       	sbr	r8,0x3
80009a0c:	ae 68       	st.h	r7[0xc],r8
80009a0e:	6e 48       	ld.w	r8,r7[0x10]
80009a10:	58 08       	cp.w	r8,0
80009a12:	c0 b1       	brne	80009a28 <__swsetup_r+0xa4>
80009a14:	8e 68       	ld.sh	r8,r7[0xc]
80009a16:	e2 18 02 80 	andl	r8,0x280,COH
80009a1a:	e0 48 02 00 	cp.w	r8,512
80009a1e:	c0 50       	breq	80009a28 <__swsetup_r+0xa4>
80009a20:	0c 9c       	mov	r12,r6
80009a22:	0e 9b       	mov	r11,r7
80009a24:	e0 a0 0a 56 	rcall	8000aed0 <__smakebuf_r>
80009a28:	8e 69       	ld.sh	r9,r7[0xc]
80009a2a:	f1 d9 c0 01 	bfextu	r8,r9,0x0,0x1
80009a2e:	c0 70       	breq	80009a3c <__swsetup_r+0xb8>
80009a30:	30 08       	mov	r8,0
80009a32:	8f 28       	st.w	r7[0x8],r8
80009a34:	6e 58       	ld.w	r8,r7[0x14]
80009a36:	5c 38       	neg	r8
80009a38:	8f 68       	st.w	r7[0x18],r8
80009a3a:	c0 68       	rjmp	80009a46 <__swsetup_r+0xc2>
80009a3c:	ed b9 00 01 	bld	r9,0x1
80009a40:	ef f8 10 05 	ld.wne	r8,r7[0x14]
80009a44:	8f 28       	st.w	r7[0x8],r8
80009a46:	6e 48       	ld.w	r8,r7[0x10]
80009a48:	58 08       	cp.w	r8,0
80009a4a:	c0 61       	brne	80009a56 <__swsetup_r+0xd2>
80009a4c:	8e 68       	ld.sh	r8,r7[0xc]
80009a4e:	ed b8 00 07 	bld	r8,0x7
80009a52:	c0 21       	brne	80009a56 <__swsetup_r+0xd2>
80009a54:	dc 2a       	popm	r4-r7,pc,r12=-1
80009a56:	d8 2a       	popm	r4-r7,pc,r12=0
80009a58:	80 01       	ld.sh	r1,r0[0x0]
80009a5a:	5e e0       	retqs	r0
80009a5c:	80 01       	ld.sh	r1,r0[0x0]
80009a5e:	5f 00       	sreq	r0
80009a60:	80 01       	ld.sh	r1,r0[0x0]
80009a62:	5f 20       	srhs	r0

80009a64 <quorem>:
80009a64:	d4 31       	pushm	r0-r7,lr
80009a66:	20 2d       	sub	sp,8
80009a68:	18 97       	mov	r7,r12
80009a6a:	78 48       	ld.w	r8,r12[0x10]
80009a6c:	76 46       	ld.w	r6,r11[0x10]
80009a6e:	0c 38       	cp.w	r8,r6
80009a70:	c0 34       	brge	80009a76 <quorem+0x12>
80009a72:	30 0c       	mov	r12,0
80009a74:	c8 58       	rjmp	80009b7e <quorem+0x11a>
80009a76:	ec c2 ff fc 	sub	r2,r6,-4
80009a7a:	f6 c3 ff ec 	sub	r3,r11,-20
80009a7e:	f6 02 03 29 	ld.w	r9,r11[r2<<0x2]
80009a82:	f8 02 03 2c 	ld.w	r12,r12[r2<<0x2]
80009a86:	2f f9       	sub	r9,-1
80009a88:	20 16       	sub	r6,1
80009a8a:	f8 09 0d 08 	divu	r8,r12,r9
80009a8e:	f6 02 00 22 	add	r2,r11,r2<<0x2
80009a92:	ee c4 ff ec 	sub	r4,r7,-20
80009a96:	10 95       	mov	r5,r8
80009a98:	58 08       	cp.w	r8,0
80009a9a:	c4 10       	breq	80009b1c <quorem+0xb8>
80009a9c:	30 09       	mov	r9,0
80009a9e:	06 9a       	mov	r10,r3
80009aa0:	08 98       	mov	r8,r4
80009aa2:	12 91       	mov	r1,r9
80009aa4:	50 0b       	stdsp	sp[0x0],r11
80009aa6:	70 0e       	ld.w	lr,r8[0x0]
80009aa8:	b1 8e       	lsr	lr,0x10
80009aaa:	50 1e       	stdsp	sp[0x4],lr
80009aac:	15 0e       	ld.w	lr,r10++
80009aae:	fc 00 16 10 	lsr	r0,lr,0x10
80009ab2:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
80009ab6:	ea 0e 03 41 	mac	r1,r5,lr
80009aba:	fd d1 c0 10 	bfextu	lr,r1,0x0,0x10
80009abe:	b1 81       	lsr	r1,0x10
80009ac0:	40 1b       	lddsp	r11,sp[0x4]
80009ac2:	ea 00 02 40 	mul	r0,r5,r0
80009ac6:	e2 00 00 00 	add	r0,r1,r0
80009aca:	e3 d0 c0 10 	bfextu	r1,r0,0x0,0x10
80009ace:	02 1b       	sub	r11,r1
80009ad0:	50 1b       	stdsp	sp[0x4],r11
80009ad2:	70 0b       	ld.w	r11,r8[0x0]
80009ad4:	e3 db c0 10 	bfextu	r1,r11,0x0,0x10
80009ad8:	02 09       	add	r9,r1
80009ada:	f2 0e 01 0e 	sub	lr,r9,lr
80009ade:	b0 1e       	st.h	r8[0x2],lr
80009ae0:	fc 09 14 10 	asr	r9,lr,0x10
80009ae4:	40 1e       	lddsp	lr,sp[0x4]
80009ae6:	fc 09 00 09 	add	r9,lr,r9
80009aea:	b0 09       	st.h	r8[0x0],r9
80009aec:	e0 01 16 10 	lsr	r1,r0,0x10
80009af0:	2f c8       	sub	r8,-4
80009af2:	b1 49       	asr	r9,0x10
80009af4:	04 3a       	cp.w	r10,r2
80009af6:	fe 98 ff d8 	brls	80009aa6 <quorem+0x42>
80009afa:	40 0b       	lddsp	r11,sp[0x0]
80009afc:	58 0c       	cp.w	r12,0
80009afe:	c0 f1       	brne	80009b1c <quorem+0xb8>
80009b00:	ec c8 ff fb 	sub	r8,r6,-5
80009b04:	ee 08 00 28 	add	r8,r7,r8<<0x2
80009b08:	c0 28       	rjmp	80009b0c <quorem+0xa8>
80009b0a:	20 16       	sub	r6,1
80009b0c:	20 48       	sub	r8,4
80009b0e:	08 38       	cp.w	r8,r4
80009b10:	e0 88 00 05 	brls	80009b1a <quorem+0xb6>
80009b14:	70 09       	ld.w	r9,r8[0x0]
80009b16:	58 09       	cp.w	r9,0
80009b18:	cf 90       	breq	80009b0a <quorem+0xa6>
80009b1a:	8f 46       	st.w	r7[0x10],r6
80009b1c:	0e 9c       	mov	r12,r7
80009b1e:	e0 a0 0a d8 	rcall	8000b0ce <__mcmp>
80009b22:	c2 d5       	brlt	80009b7c <quorem+0x118>
80009b24:	2f f5       	sub	r5,-1
80009b26:	08 98       	mov	r8,r4
80009b28:	30 09       	mov	r9,0
80009b2a:	07 0b       	ld.w	r11,r3++
80009b2c:	f6 0a 16 10 	lsr	r10,r11,0x10
80009b30:	70 0c       	ld.w	r12,r8[0x0]
80009b32:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
80009b36:	f8 0e 16 10 	lsr	lr,r12,0x10
80009b3a:	14 1e       	sub	lr,r10
80009b3c:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
80009b40:	16 1a       	sub	r10,r11
80009b42:	12 0a       	add	r10,r9
80009b44:	b0 1a       	st.h	r8[0x2],r10
80009b46:	b1 4a       	asr	r10,0x10
80009b48:	fc 0a 00 09 	add	r9,lr,r10
80009b4c:	b0 09       	st.h	r8[0x0],r9
80009b4e:	2f c8       	sub	r8,-4
80009b50:	b1 49       	asr	r9,0x10
80009b52:	04 33       	cp.w	r3,r2
80009b54:	fe 98 ff eb 	brls	80009b2a <quorem+0xc6>
80009b58:	ec c8 ff fb 	sub	r8,r6,-5
80009b5c:	ee 08 03 29 	ld.w	r9,r7[r8<<0x2]
80009b60:	58 09       	cp.w	r9,0
80009b62:	c0 d1       	brne	80009b7c <quorem+0x118>
80009b64:	ee 08 00 28 	add	r8,r7,r8<<0x2
80009b68:	c0 28       	rjmp	80009b6c <quorem+0x108>
80009b6a:	20 16       	sub	r6,1
80009b6c:	20 48       	sub	r8,4
80009b6e:	08 38       	cp.w	r8,r4
80009b70:	e0 88 00 05 	brls	80009b7a <quorem+0x116>
80009b74:	70 09       	ld.w	r9,r8[0x0]
80009b76:	58 09       	cp.w	r9,0
80009b78:	cf 90       	breq	80009b6a <quorem+0x106>
80009b7a:	8f 46       	st.w	r7[0x10],r6
80009b7c:	0a 9c       	mov	r12,r5
80009b7e:	2f ed       	sub	sp,-8
80009b80:	d8 32       	popm	r0-r7,pc
80009b82:	d7 03       	nop

80009b84 <_dtoa_r>:
80009b84:	d4 31       	pushm	r0-r7,lr
80009b86:	21 ad       	sub	sp,104
80009b88:	fa c4 ff 74 	sub	r4,sp,-140
80009b8c:	18 97       	mov	r7,r12
80009b8e:	16 95       	mov	r5,r11
80009b90:	68 2c       	ld.w	r12,r4[0x8]
80009b92:	50 c9       	stdsp	sp[0x30],r9
80009b94:	68 16       	ld.w	r6,r4[0x4]
80009b96:	68 09       	ld.w	r9,r4[0x0]
80009b98:	50 e8       	stdsp	sp[0x38],r8
80009b9a:	14 94       	mov	r4,r10
80009b9c:	51 2c       	stdsp	sp[0x48],r12
80009b9e:	fa e5 00 08 	st.d	sp[8],r4
80009ba2:	51 59       	stdsp	sp[0x54],r9
80009ba4:	6e 95       	ld.w	r5,r7[0x24]
80009ba6:	58 05       	cp.w	r5,0
80009ba8:	c0 91       	brne	80009bba <_dtoa_r+0x36>
80009baa:	31 0c       	mov	r12,16
80009bac:	fe b0 e8 ba 	rcall	80006d20 <malloc>
80009bb0:	99 35       	st.w	r12[0xc],r5
80009bb2:	8f 9c       	st.w	r7[0x24],r12
80009bb4:	99 15       	st.w	r12[0x4],r5
80009bb6:	99 25       	st.w	r12[0x8],r5
80009bb8:	99 05       	st.w	r12[0x0],r5
80009bba:	6e 99       	ld.w	r9,r7[0x24]
80009bbc:	72 08       	ld.w	r8,r9[0x0]
80009bbe:	58 08       	cp.w	r8,0
80009bc0:	c0 f0       	breq	80009bde <_dtoa_r+0x5a>
80009bc2:	72 1a       	ld.w	r10,r9[0x4]
80009bc4:	91 1a       	st.w	r8[0x4],r10
80009bc6:	30 1a       	mov	r10,1
80009bc8:	72 19       	ld.w	r9,r9[0x4]
80009bca:	f4 09 09 49 	lsl	r9,r10,r9
80009bce:	10 9b       	mov	r11,r8
80009bd0:	91 29       	st.w	r8[0x8],r9
80009bd2:	0e 9c       	mov	r12,r7
80009bd4:	e0 a0 0a 96 	rcall	8000b100 <_Bfree>
80009bd8:	6e 98       	ld.w	r8,r7[0x24]
80009bda:	30 09       	mov	r9,0
80009bdc:	91 09       	st.w	r8[0x0],r9
80009bde:	40 28       	lddsp	r8,sp[0x8]
80009be0:	10 94       	mov	r4,r8
80009be2:	58 08       	cp.w	r8,0
80009be4:	c0 64       	brge	80009bf0 <_dtoa_r+0x6c>
80009be6:	f1 d8 c0 1f 	bfextu	r8,r8,0x0,0x1f
80009bea:	50 28       	stdsp	sp[0x8],r8
80009bec:	30 18       	mov	r8,1
80009bee:	c0 28       	rjmp	80009bf2 <_dtoa_r+0x6e>
80009bf0:	30 08       	mov	r8,0
80009bf2:	8d 08       	st.w	r6[0x0],r8
80009bf4:	fc 1c 7f f0 	movh	r12,0x7ff0
80009bf8:	40 26       	lddsp	r6,sp[0x8]
80009bfa:	0c 98       	mov	r8,r6
80009bfc:	e6 18 7f f0 	andh	r8,0x7ff0,COH
80009c00:	18 38       	cp.w	r8,r12
80009c02:	c1 e1       	brne	80009c3e <_dtoa_r+0xba>
80009c04:	e0 68 27 0f 	mov	r8,9999
80009c08:	41 5b       	lddsp	r11,sp[0x54]
80009c0a:	97 08       	st.w	r11[0x0],r8
80009c0c:	40 3a       	lddsp	r10,sp[0xc]
80009c0e:	58 0a       	cp.w	r10,0
80009c10:	c0 61       	brne	80009c1c <_dtoa_r+0x98>
80009c12:	ed d6 c0 14 	bfextu	r6,r6,0x0,0x14
80009c16:	c0 31       	brne	80009c1c <_dtoa_r+0x98>
80009c18:	4a cc       	lddpc	r12,80009cc8 <_dtoa_r+0x144>
80009c1a:	c0 28       	rjmp	80009c1e <_dtoa_r+0x9a>
80009c1c:	4a cc       	lddpc	r12,80009ccc <_dtoa_r+0x148>
80009c1e:	41 29       	lddsp	r9,sp[0x48]
80009c20:	58 09       	cp.w	r9,0
80009c22:	e0 80 05 9e 	breq	8000a75e <_dtoa_r+0xbda>
80009c26:	f8 c8 ff fd 	sub	r8,r12,-3
80009c2a:	f8 c9 ff f8 	sub	r9,r12,-8
80009c2e:	11 8b       	ld.ub	r11,r8[0x0]
80009c30:	30 0a       	mov	r10,0
80009c32:	41 25       	lddsp	r5,sp[0x48]
80009c34:	f4 0b 18 00 	cp.b	r11,r10
80009c38:	f2 08 17 10 	movne	r8,r9
80009c3c:	c1 58       	rjmp	80009c66 <_dtoa_r+0xe2>
80009c3e:	fa ea 00 08 	ld.d	r10,sp[8]
80009c42:	30 08       	mov	r8,0
80009c44:	fa eb 00 3c 	st.d	sp[60],r10
80009c48:	30 09       	mov	r9,0
80009c4a:	e0 a0 10 ce 	rcall	8000bde6 <__avr32_f64_cmp_eq>
80009c4e:	c0 f0       	breq	80009c6c <_dtoa_r+0xe8>
80009c50:	30 18       	mov	r8,1
80009c52:	41 5a       	lddsp	r10,sp[0x54]
80009c54:	95 08       	st.w	r10[0x0],r8
80009c56:	49 fc       	lddpc	r12,80009cd0 <_dtoa_r+0x14c>
80009c58:	41 29       	lddsp	r9,sp[0x48]
80009c5a:	f8 08 00 08 	add	r8,r12,r8
80009c5e:	58 09       	cp.w	r9,0
80009c60:	e0 80 05 7f 	breq	8000a75e <_dtoa_r+0xbda>
80009c64:	12 95       	mov	r5,r9
80009c66:	8b 08       	st.w	r5[0x0],r8
80009c68:	e0 8f 05 7b 	bral	8000a75e <_dtoa_r+0xbda>
80009c6c:	fa c8 ff 9c 	sub	r8,sp,-100
80009c70:	fa c9 ff a0 	sub	r9,sp,-96
80009c74:	fa ea 00 3c 	ld.d	r10,sp[60]
80009c78:	0e 9c       	mov	r12,r7
80009c7a:	eb d6 c2 8b 	bfextu	r5,r6,0x14,0xb
80009c7e:	e0 a0 0a 93 	rcall	8000b1a4 <__d2b>
80009c82:	18 93       	mov	r3,r12
80009c84:	58 05       	cp.w	r5,0
80009c86:	c0 d0       	breq	80009ca0 <_dtoa_r+0x11c>
80009c88:	fa ea 00 3c 	ld.d	r10,sp[60]
80009c8c:	30 04       	mov	r4,0
80009c8e:	f1 db c0 14 	bfextu	r8,r11,0x0,0x14
80009c92:	ea c5 03 ff 	sub	r5,r5,1023
80009c96:	10 9b       	mov	r11,r8
80009c98:	51 74       	stdsp	sp[0x5c],r4
80009c9a:	ea 1b 3f f0 	orh	r11,0x3ff0
80009c9e:	c2 a8       	rjmp	80009cf2 <_dtoa_r+0x16e>
80009ca0:	41 88       	lddsp	r8,sp[0x60]
80009ca2:	41 9c       	lddsp	r12,sp[0x64]
80009ca4:	10 0c       	add	r12,r8
80009ca6:	f8 c5 fb ce 	sub	r5,r12,-1074
80009caa:	e0 45 00 20 	cp.w	r5,32
80009cae:	e0 8a 00 13 	brle	80009cd4 <_dtoa_r+0x150>
80009cb2:	f8 cc fb ee 	sub	r12,r12,-1042
80009cb6:	40 3b       	lddsp	r11,sp[0xc]
80009cb8:	ea 08 11 40 	rsub	r8,r5,64
80009cbc:	f6 0c 0a 4c 	lsr	r12,r11,r12
80009cc0:	ec 08 09 46 	lsl	r6,r6,r8
80009cc4:	0c 4c       	or	r12,r6
80009cc6:	c0 c8       	rjmp	80009cde <_dtoa_r+0x15a>
80009cc8:	80 01       	ld.sh	r1,r0[0x0]
80009cca:	5e d0       	retvc	r0
80009ccc:	80 01       	ld.sh	r1,r0[0x0]
80009cce:	5e dc       	retvc	r12
80009cd0:	80 01       	ld.sh	r1,r0[0x0]
80009cd2:	5d ac       	*unknown*
80009cd4:	ea 0c 11 20 	rsub	r12,r5,32
80009cd8:	40 3a       	lddsp	r10,sp[0xc]
80009cda:	f4 0c 09 4c 	lsl	r12,r10,r12
80009cde:	e0 a0 10 10 	rcall	8000bcfe <__avr32_u32_to_f64>
80009ce2:	fc 18 fe 10 	movh	r8,0xfe10
80009ce6:	30 19       	mov	r9,1
80009ce8:	ea c5 04 33 	sub	r5,r5,1075
80009cec:	f0 0b 00 0b 	add	r11,r8,r11
80009cf0:	51 79       	stdsp	sp[0x5c],r9
80009cf2:	30 08       	mov	r8,0
80009cf4:	fc 19 3f f8 	movh	r9,0x3ff8
80009cf8:	e0 a0 0e 98 	rcall	8000ba28 <__avr32_f64_sub>
80009cfc:	e0 68 43 61 	mov	r8,17249
80009d00:	ea 18 63 6f 	orh	r8,0x636f
80009d04:	e0 69 87 a7 	mov	r9,34727
80009d08:	ea 19 3f d2 	orh	r9,0x3fd2
80009d0c:	e0 a0 0d a2 	rcall	8000b850 <__avr32_f64_mul>
80009d10:	e0 68 c8 b3 	mov	r8,51379
80009d14:	ea 18 8b 60 	orh	r8,0x8b60
80009d18:	e0 69 8a 28 	mov	r9,35368
80009d1c:	ea 19 3f c6 	orh	r9,0x3fc6
80009d20:	e0 a0 0f 52 	rcall	8000bbc4 <__avr32_f64_add>
80009d24:	0a 9c       	mov	r12,r5
80009d26:	14 90       	mov	r0,r10
80009d28:	16 91       	mov	r1,r11
80009d2a:	e0 a0 0f ee 	rcall	8000bd06 <__avr32_s32_to_f64>
80009d2e:	e0 68 79 fb 	mov	r8,31227
80009d32:	ea 18 50 9f 	orh	r8,0x509f
80009d36:	e0 69 44 13 	mov	r9,17427
80009d3a:	ea 19 3f d3 	orh	r9,0x3fd3
80009d3e:	e0 a0 0d 89 	rcall	8000b850 <__avr32_f64_mul>
80009d42:	14 98       	mov	r8,r10
80009d44:	16 99       	mov	r9,r11
80009d46:	00 9a       	mov	r10,r0
80009d48:	02 9b       	mov	r11,r1
80009d4a:	e0 a0 0f 3d 	rcall	8000bbc4 <__avr32_f64_add>
80009d4e:	14 90       	mov	r0,r10
80009d50:	16 91       	mov	r1,r11
80009d52:	e0 a0 0f c3 	rcall	8000bcd8 <__avr32_f64_to_s32>
80009d56:	30 08       	mov	r8,0
80009d58:	18 96       	mov	r6,r12
80009d5a:	30 09       	mov	r9,0
80009d5c:	00 9a       	mov	r10,r0
80009d5e:	02 9b       	mov	r11,r1
80009d60:	e0 a0 10 8a 	rcall	8000be74 <__avr32_f64_cmp_lt>
80009d64:	c0 c0       	breq	80009d7c <_dtoa_r+0x1f8>
80009d66:	0c 9c       	mov	r12,r6
80009d68:	e0 a0 0f cf 	rcall	8000bd06 <__avr32_s32_to_f64>
80009d6c:	14 98       	mov	r8,r10
80009d6e:	16 99       	mov	r9,r11
80009d70:	00 9a       	mov	r10,r0
80009d72:	02 9b       	mov	r11,r1
80009d74:	e0 a0 10 39 	rcall	8000bde6 <__avr32_f64_cmp_eq>
80009d78:	f7 b6 00 01 	subeq	r6,1
80009d7c:	59 66       	cp.w	r6,22
80009d7e:	e0 88 00 05 	brls	80009d88 <_dtoa_r+0x204>
80009d82:	30 18       	mov	r8,1
80009d84:	51 48       	stdsp	sp[0x50],r8
80009d86:	c1 28       	rjmp	80009daa <_dtoa_r+0x226>
80009d88:	4c 08       	lddpc	r8,80009e88 <_dtoa_r+0x304>
80009d8a:	fa ea 00 3c 	ld.d	r10,sp[60]
80009d8e:	f0 06 02 38 	ld.d	r8,r8[r6<<0x3]
80009d92:	e0 a0 10 71 	rcall	8000be74 <__avr32_f64_cmp_lt>
80009d96:	f9 b4 00 00 	moveq	r4,0
80009d9a:	fb f4 0a 14 	st.weq	sp[0x50],r4
80009d9e:	f7 b6 01 01 	subne	r6,1
80009da2:	f9 bc 01 00 	movne	r12,0
80009da6:	fb fc 1a 14 	st.wne	sp[0x50],r12
80009daa:	41 90       	lddsp	r0,sp[0x64]
80009dac:	20 10       	sub	r0,1
80009dae:	0a 10       	sub	r0,r5
80009db0:	c0 46       	brmi	80009db8 <_dtoa_r+0x234>
80009db2:	50 40       	stdsp	sp[0x10],r0
80009db4:	30 00       	mov	r0,0
80009db6:	c0 48       	rjmp	80009dbe <_dtoa_r+0x23a>
80009db8:	30 0b       	mov	r11,0
80009dba:	5c 30       	neg	r0
80009dbc:	50 4b       	stdsp	sp[0x10],r11
80009dbe:	ec 02 11 00 	rsub	r2,r6,0
80009dc2:	58 06       	cp.w	r6,0
80009dc4:	fb fa 40 04 	ld.wge	r10,sp[0x10]
80009dc8:	f5 d6 e4 0a 	addge	r10,r10,r6
80009dcc:	fb fa 4a 04 	st.wge	sp[0x10],r10
80009dd0:	fb f6 4a 11 	st.wge	sp[0x44],r6
80009dd4:	f9 b2 04 00 	movge	r2,0
80009dd8:	e1 d6 e5 10 	sublt	r0,r0,r6
80009ddc:	f9 b9 05 00 	movlt	r9,0
80009de0:	fb f9 5a 11 	st.wlt	sp[0x44],r9
80009de4:	40 c8       	lddsp	r8,sp[0x30]
80009de6:	58 98       	cp.w	r8,9
80009de8:	e0 8b 00 20 	brhi	80009e28 <_dtoa_r+0x2a4>
80009dec:	58 58       	cp.w	r8,5
80009dee:	f9 b4 0a 01 	movle	r4,1
80009df2:	fb f5 90 0c 	ld.wgt	r5,sp[0x30]
80009df6:	f7 b5 09 04 	subgt	r5,4
80009dfa:	fb f5 9a 0c 	st.wgt	sp[0x30],r5
80009dfe:	f9 b4 09 00 	movgt	r4,0
80009e02:	40 cc       	lddsp	r12,sp[0x30]
80009e04:	58 3c       	cp.w	r12,3
80009e06:	c2 d0       	breq	80009e60 <_dtoa_r+0x2dc>
80009e08:	e0 89 00 05 	brgt	80009e12 <_dtoa_r+0x28e>
80009e0c:	58 2c       	cp.w	r12,2
80009e0e:	c1 01       	brne	80009e2e <_dtoa_r+0x2aa>
80009e10:	c1 88       	rjmp	80009e40 <_dtoa_r+0x2bc>
80009e12:	40 cb       	lddsp	r11,sp[0x30]
80009e14:	58 4b       	cp.w	r11,4
80009e16:	c0 60       	breq	80009e22 <_dtoa_r+0x29e>
80009e18:	58 5b       	cp.w	r11,5
80009e1a:	c0 a1       	brne	80009e2e <_dtoa_r+0x2aa>
80009e1c:	30 1a       	mov	r10,1
80009e1e:	50 da       	stdsp	sp[0x34],r10
80009e20:	c2 28       	rjmp	80009e64 <_dtoa_r+0x2e0>
80009e22:	30 19       	mov	r9,1
80009e24:	50 d9       	stdsp	sp[0x34],r9
80009e26:	c0 f8       	rjmp	80009e44 <_dtoa_r+0x2c0>
80009e28:	30 08       	mov	r8,0
80009e2a:	30 14       	mov	r4,1
80009e2c:	50 c8       	stdsp	sp[0x30],r8
80009e2e:	3f f5       	mov	r5,-1
80009e30:	30 1c       	mov	r12,1
80009e32:	30 0b       	mov	r11,0
80009e34:	50 95       	stdsp	sp[0x24],r5
80009e36:	50 dc       	stdsp	sp[0x34],r12
80009e38:	0a 91       	mov	r1,r5
80009e3a:	31 28       	mov	r8,18
80009e3c:	50 eb       	stdsp	sp[0x38],r11
80009e3e:	c2 08       	rjmp	80009e7e <_dtoa_r+0x2fa>
80009e40:	30 0a       	mov	r10,0
80009e42:	50 da       	stdsp	sp[0x34],r10
80009e44:	40 e9       	lddsp	r9,sp[0x38]
80009e46:	58 09       	cp.w	r9,0
80009e48:	e0 89 00 07 	brgt	80009e56 <_dtoa_r+0x2d2>
80009e4c:	30 18       	mov	r8,1
80009e4e:	50 98       	stdsp	sp[0x24],r8
80009e50:	10 91       	mov	r1,r8
80009e52:	50 e8       	stdsp	sp[0x38],r8
80009e54:	c1 58       	rjmp	80009e7e <_dtoa_r+0x2fa>
80009e56:	40 e5       	lddsp	r5,sp[0x38]
80009e58:	50 95       	stdsp	sp[0x24],r5
80009e5a:	0a 91       	mov	r1,r5
80009e5c:	0a 98       	mov	r8,r5
80009e5e:	c1 08       	rjmp	80009e7e <_dtoa_r+0x2fa>
80009e60:	30 0c       	mov	r12,0
80009e62:	50 dc       	stdsp	sp[0x34],r12
80009e64:	40 eb       	lddsp	r11,sp[0x38]
80009e66:	ec 0b 00 0b 	add	r11,r6,r11
80009e6a:	50 9b       	stdsp	sp[0x24],r11
80009e6c:	16 98       	mov	r8,r11
80009e6e:	2f f8       	sub	r8,-1
80009e70:	58 08       	cp.w	r8,0
80009e72:	e0 89 00 05 	brgt	80009e7c <_dtoa_r+0x2f8>
80009e76:	10 91       	mov	r1,r8
80009e78:	30 18       	mov	r8,1
80009e7a:	c0 28       	rjmp	80009e7e <_dtoa_r+0x2fa>
80009e7c:	10 91       	mov	r1,r8
80009e7e:	30 09       	mov	r9,0
80009e80:	6e 9a       	ld.w	r10,r7[0x24]
80009e82:	95 19       	st.w	r10[0x4],r9
80009e84:	30 49       	mov	r9,4
80009e86:	c0 78       	rjmp	80009e94 <_dtoa_r+0x310>
80009e88:	80 01       	ld.sh	r1,r0[0x0]
80009e8a:	5f 90       	srgt	r0
80009e8c:	6a 1a       	ld.w	r10,r5[0x4]
80009e8e:	a1 79       	lsl	r9,0x1
80009e90:	2f fa       	sub	r10,-1
80009e92:	8b 1a       	st.w	r5[0x4],r10
80009e94:	6e 95       	ld.w	r5,r7[0x24]
80009e96:	f2 ca ff ec 	sub	r10,r9,-20
80009e9a:	10 3a       	cp.w	r10,r8
80009e9c:	fe 98 ff f8 	brls	80009e8c <_dtoa_r+0x308>
80009ea0:	6a 1b       	ld.w	r11,r5[0x4]
80009ea2:	0e 9c       	mov	r12,r7
80009ea4:	e0 a0 09 48 	rcall	8000b134 <_Balloc>
80009ea8:	58 e1       	cp.w	r1,14
80009eaa:	5f 88       	srls	r8
80009eac:	8b 0c       	st.w	r5[0x0],r12
80009eae:	f1 e4 00 04 	and	r4,r8,r4
80009eb2:	6e 98       	ld.w	r8,r7[0x24]
80009eb4:	70 08       	ld.w	r8,r8[0x0]
80009eb6:	50 88       	stdsp	sp[0x20],r8
80009eb8:	e0 80 01 82 	breq	8000a1bc <_dtoa_r+0x638>
80009ebc:	58 06       	cp.w	r6,0
80009ebe:	e0 8a 00 40 	brle	80009f3e <_dtoa_r+0x3ba>
80009ec2:	f3 d6 c0 04 	bfextu	r9,r6,0x0,0x4
80009ec6:	4c b8       	lddpc	r8,80009ff0 <_dtoa_r+0x46c>
80009ec8:	f0 09 02 34 	ld.d	r4,r8[r9<<0x3]
80009ecc:	fa e5 00 18 	st.d	sp[24],r4
80009ed0:	ec 04 14 04 	asr	r4,r6,0x4
80009ed4:	ed b4 00 04 	bld	r4,0x4
80009ed8:	c0 30       	breq	80009ede <_dtoa_r+0x35a>
80009eda:	30 25       	mov	r5,2
80009edc:	c0 f8       	rjmp	80009efa <_dtoa_r+0x376>
80009ede:	4c 68       	lddpc	r8,80009ff4 <_dtoa_r+0x470>
80009ee0:	f0 e8 00 20 	ld.d	r8,r8[32]
80009ee4:	fa ea 00 3c 	ld.d	r10,sp[60]
80009ee8:	e9 d4 c0 04 	bfextu	r4,r4,0x0,0x4
80009eec:	e0 a0 0f f8 	rcall	8000bedc <__avr32_f64_div>
80009ef0:	30 35       	mov	r5,3
80009ef2:	14 98       	mov	r8,r10
80009ef4:	16 99       	mov	r9,r11
80009ef6:	fa e9 00 08 	st.d	sp[8],r8
80009efa:	4b fc       	lddpc	r12,80009ff4 <_dtoa_r+0x470>
80009efc:	50 a3       	stdsp	sp[0x28],r3
80009efe:	0c 93       	mov	r3,r6
80009f00:	18 96       	mov	r6,r12
80009f02:	c0 f8       	rjmp	80009f20 <_dtoa_r+0x39c>
80009f04:	fa ea 00 18 	ld.d	r10,sp[24]
80009f08:	ed b4 00 00 	bld	r4,0x0
80009f0c:	c0 81       	brne	80009f1c <_dtoa_r+0x398>
80009f0e:	ec e8 00 00 	ld.d	r8,r6[0]
80009f12:	2f f5       	sub	r5,-1
80009f14:	e0 a0 0c 9e 	rcall	8000b850 <__avr32_f64_mul>
80009f18:	fa eb 00 18 	st.d	sp[24],r10
80009f1c:	a1 54       	asr	r4,0x1
80009f1e:	2f 86       	sub	r6,-8
80009f20:	58 04       	cp.w	r4,0
80009f22:	cf 11       	brne	80009f04 <_dtoa_r+0x380>
80009f24:	fa e8 00 18 	ld.d	r8,sp[24]
80009f28:	fa ea 00 08 	ld.d	r10,sp[8]
80009f2c:	06 96       	mov	r6,r3
80009f2e:	e0 a0 0f d7 	rcall	8000bedc <__avr32_f64_div>
80009f32:	40 a3       	lddsp	r3,sp[0x28]
80009f34:	14 98       	mov	r8,r10
80009f36:	16 99       	mov	r9,r11
80009f38:	fa e9 00 08 	st.d	sp[8],r8
80009f3c:	c2 d8       	rjmp	80009f96 <_dtoa_r+0x412>
80009f3e:	ec 08 11 00 	rsub	r8,r6,0
80009f42:	c0 31       	brne	80009f48 <_dtoa_r+0x3c4>
80009f44:	30 25       	mov	r5,2
80009f46:	c2 88       	rjmp	80009f96 <_dtoa_r+0x412>
80009f48:	4a bc       	lddpc	r12,80009ff4 <_dtoa_r+0x470>
80009f4a:	f0 04 14 04 	asr	r4,r8,0x4
80009f4e:	50 1c       	stdsp	sp[0x4],r12
80009f50:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
80009f54:	4a 79       	lddpc	r9,80009ff0 <_dtoa_r+0x46c>
80009f56:	fa ea 00 3c 	ld.d	r10,sp[60]
80009f5a:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
80009f5e:	e0 a0 0c 79 	rcall	8000b850 <__avr32_f64_mul>
80009f62:	40 1c       	lddsp	r12,sp[0x4]
80009f64:	50 63       	stdsp	sp[0x18],r3
80009f66:	30 25       	mov	r5,2
80009f68:	0c 93       	mov	r3,r6
80009f6a:	fa eb 00 08 	st.d	sp[8],r10
80009f6e:	18 96       	mov	r6,r12
80009f70:	c0 f8       	rjmp	80009f8e <_dtoa_r+0x40a>
80009f72:	fa ea 00 08 	ld.d	r10,sp[8]
80009f76:	ed b4 00 00 	bld	r4,0x0
80009f7a:	c0 81       	brne	80009f8a <_dtoa_r+0x406>
80009f7c:	ec e8 00 00 	ld.d	r8,r6[0]
80009f80:	2f f5       	sub	r5,-1
80009f82:	e0 a0 0c 67 	rcall	8000b850 <__avr32_f64_mul>
80009f86:	fa eb 00 08 	st.d	sp[8],r10
80009f8a:	a1 54       	asr	r4,0x1
80009f8c:	2f 86       	sub	r6,-8
80009f8e:	58 04       	cp.w	r4,0
80009f90:	cf 11       	brne	80009f72 <_dtoa_r+0x3ee>
80009f92:	06 96       	mov	r6,r3
80009f94:	40 63       	lddsp	r3,sp[0x18]
80009f96:	41 4a       	lddsp	r10,sp[0x50]
80009f98:	58 0a       	cp.w	r10,0
80009f9a:	c2 f0       	breq	80009ff8 <_dtoa_r+0x474>
80009f9c:	fa e8 00 08 	ld.d	r8,sp[8]
80009fa0:	58 01       	cp.w	r1,0
80009fa2:	5f 94       	srgt	r4
80009fa4:	fa e9 00 18 	st.d	sp[24],r8
80009fa8:	30 08       	mov	r8,0
80009faa:	fc 19 3f f0 	movh	r9,0x3ff0
80009fae:	fa ea 00 18 	ld.d	r10,sp[24]
80009fb2:	e0 a0 0f 61 	rcall	8000be74 <__avr32_f64_cmp_lt>
80009fb6:	f9 bc 00 00 	moveq	r12,0
80009fba:	f9 bc 01 01 	movne	r12,1
80009fbe:	e9 ec 00 0c 	and	r12,r4,r12
80009fc2:	c1 b0       	breq	80009ff8 <_dtoa_r+0x474>
80009fc4:	40 98       	lddsp	r8,sp[0x24]
80009fc6:	58 08       	cp.w	r8,0
80009fc8:	e0 8a 00 f6 	brle	8000a1b4 <_dtoa_r+0x630>
80009fcc:	30 08       	mov	r8,0
80009fce:	fc 19 40 24 	movh	r9,0x4024
80009fd2:	ec c4 00 01 	sub	r4,r6,1
80009fd6:	fa ea 00 18 	ld.d	r10,sp[24]
80009fda:	2f f5       	sub	r5,-1
80009fdc:	50 64       	stdsp	sp[0x18],r4
80009fde:	e0 a0 0c 39 	rcall	8000b850 <__avr32_f64_mul>
80009fe2:	40 94       	lddsp	r4,sp[0x24]
80009fe4:	14 98       	mov	r8,r10
80009fe6:	16 99       	mov	r9,r11
80009fe8:	fa e9 00 08 	st.d	sp[8],r8
80009fec:	c0 88       	rjmp	80009ffc <_dtoa_r+0x478>
80009fee:	d7 03       	nop
80009ff0:	80 01       	ld.sh	r1,r0[0x0]
80009ff2:	5f 90       	srgt	r0
80009ff4:	80 01       	ld.sh	r1,r0[0x0]
80009ff6:	60 58       	ld.w	r8,r0[0x14]
80009ff8:	50 66       	stdsp	sp[0x18],r6
80009ffa:	02 94       	mov	r4,r1
80009ffc:	0a 9c       	mov	r12,r5
80009ffe:	e0 a0 0e 84 	rcall	8000bd06 <__avr32_s32_to_f64>
8000a002:	fa e8 00 08 	ld.d	r8,sp[8]
8000a006:	e0 a0 0c 25 	rcall	8000b850 <__avr32_f64_mul>
8000a00a:	30 08       	mov	r8,0
8000a00c:	fc 19 40 1c 	movh	r9,0x401c
8000a010:	e0 a0 0d da 	rcall	8000bbc4 <__avr32_f64_add>
8000a014:	14 98       	mov	r8,r10
8000a016:	16 99       	mov	r9,r11
8000a018:	fa e9 00 28 	st.d	sp[40],r8
8000a01c:	fc 18 fc c0 	movh	r8,0xfcc0
8000a020:	40 a5       	lddsp	r5,sp[0x28]
8000a022:	10 05       	add	r5,r8
8000a024:	50 a5       	stdsp	sp[0x28],r5
8000a026:	58 04       	cp.w	r4,0
8000a028:	c2 11       	brne	8000a06a <_dtoa_r+0x4e6>
8000a02a:	fa ea 00 08 	ld.d	r10,sp[8]
8000a02e:	30 08       	mov	r8,0
8000a030:	fc 19 40 14 	movh	r9,0x4014
8000a034:	e0 a0 0c fa 	rcall	8000ba28 <__avr32_f64_sub>
8000a038:	40 bc       	lddsp	r12,sp[0x2c]
8000a03a:	fa eb 00 08 	st.d	sp[8],r10
8000a03e:	14 98       	mov	r8,r10
8000a040:	16 99       	mov	r9,r11
8000a042:	18 9a       	mov	r10,r12
8000a044:	0a 9b       	mov	r11,r5
8000a046:	e0 a0 0f 17 	rcall	8000be74 <__avr32_f64_cmp_lt>
8000a04a:	e0 81 02 54 	brne	8000a4f2 <_dtoa_r+0x96e>
8000a04e:	0a 98       	mov	r8,r5
8000a050:	40 b9       	lddsp	r9,sp[0x2c]
8000a052:	ee 18 80 00 	eorh	r8,0x8000
8000a056:	fa ea 00 08 	ld.d	r10,sp[8]
8000a05a:	10 95       	mov	r5,r8
8000a05c:	12 98       	mov	r8,r9
8000a05e:	0a 99       	mov	r9,r5
8000a060:	e0 a0 0f 0a 	rcall	8000be74 <__avr32_f64_cmp_lt>
8000a064:	e0 81 02 3e 	brne	8000a4e0 <_dtoa_r+0x95c>
8000a068:	ca 68       	rjmp	8000a1b4 <_dtoa_r+0x630>
8000a06a:	4c e9       	lddpc	r9,8000a1a0 <_dtoa_r+0x61c>
8000a06c:	e8 c8 00 01 	sub	r8,r4,1
8000a070:	40 d5       	lddsp	r5,sp[0x34]
8000a072:	58 05       	cp.w	r5,0
8000a074:	c4 f0       	breq	8000a112 <_dtoa_r+0x58e>
8000a076:	30 0c       	mov	r12,0
8000a078:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000a07c:	51 3c       	stdsp	sp[0x4c],r12
8000a07e:	30 0a       	mov	r10,0
8000a080:	fc 1b 3f e0 	movh	r11,0x3fe0
8000a084:	e0 a0 0f 2c 	rcall	8000bedc <__avr32_f64_div>
8000a088:	fa e8 00 28 	ld.d	r8,sp[40]
8000a08c:	40 85       	lddsp	r5,sp[0x20]
8000a08e:	e0 a0 0c cd 	rcall	8000ba28 <__avr32_f64_sub>
8000a092:	fa eb 00 28 	st.d	sp[40],r10
8000a096:	fa ea 00 08 	ld.d	r10,sp[8]
8000a09a:	e0 a0 0e 1f 	rcall	8000bcd8 <__avr32_f64_to_s32>
8000a09e:	51 6c       	stdsp	sp[0x58],r12
8000a0a0:	e0 a0 0e 33 	rcall	8000bd06 <__avr32_s32_to_f64>
8000a0a4:	14 98       	mov	r8,r10
8000a0a6:	16 99       	mov	r9,r11
8000a0a8:	fa ea 00 08 	ld.d	r10,sp[8]
8000a0ac:	e0 a0 0c be 	rcall	8000ba28 <__avr32_f64_sub>
8000a0b0:	fa eb 00 08 	st.d	sp[8],r10
8000a0b4:	41 68       	lddsp	r8,sp[0x58]
8000a0b6:	2d 08       	sub	r8,-48
8000a0b8:	0a c8       	st.b	r5++,r8
8000a0ba:	41 39       	lddsp	r9,sp[0x4c]
8000a0bc:	2f f9       	sub	r9,-1
8000a0be:	51 39       	stdsp	sp[0x4c],r9
8000a0c0:	fa e8 00 28 	ld.d	r8,sp[40]
8000a0c4:	e0 a0 0e d8 	rcall	8000be74 <__avr32_f64_cmp_lt>
8000a0c8:	e0 81 03 3a 	brne	8000a73c <_dtoa_r+0xbb8>
8000a0cc:	fa e8 00 08 	ld.d	r8,sp[8]
8000a0d0:	30 0a       	mov	r10,0
8000a0d2:	fc 1b 3f f0 	movh	r11,0x3ff0
8000a0d6:	e0 a0 0c a9 	rcall	8000ba28 <__avr32_f64_sub>
8000a0da:	fa e8 00 28 	ld.d	r8,sp[40]
8000a0de:	e0 a0 0e cb 	rcall	8000be74 <__avr32_f64_cmp_lt>
8000a0e2:	fa ea 00 28 	ld.d	r10,sp[40]
8000a0e6:	30 08       	mov	r8,0
8000a0e8:	fc 19 40 24 	movh	r9,0x4024
8000a0ec:	e0 81 00 da 	brne	8000a2a0 <_dtoa_r+0x71c>
8000a0f0:	41 3c       	lddsp	r12,sp[0x4c]
8000a0f2:	08 3c       	cp.w	r12,r4
8000a0f4:	c6 04       	brge	8000a1b4 <_dtoa_r+0x630>
8000a0f6:	e0 a0 0b ad 	rcall	8000b850 <__avr32_f64_mul>
8000a0fa:	30 08       	mov	r8,0
8000a0fc:	fa eb 00 28 	st.d	sp[40],r10
8000a100:	fc 19 40 24 	movh	r9,0x4024
8000a104:	fa ea 00 08 	ld.d	r10,sp[8]
8000a108:	e0 a0 0b a4 	rcall	8000b850 <__avr32_f64_mul>
8000a10c:	fa eb 00 08 	st.d	sp[8],r10
8000a110:	cc 3b       	rjmp	8000a096 <_dtoa_r+0x512>
8000a112:	40 85       	lddsp	r5,sp[0x20]
8000a114:	08 05       	add	r5,r4
8000a116:	f2 08 02 3a 	ld.d	r10,r9[r8<<0x3]
8000a11a:	51 35       	stdsp	sp[0x4c],r5
8000a11c:	fa e8 00 28 	ld.d	r8,sp[40]
8000a120:	40 85       	lddsp	r5,sp[0x20]
8000a122:	e0 a0 0b 97 	rcall	8000b850 <__avr32_f64_mul>
8000a126:	fa eb 00 28 	st.d	sp[40],r10
8000a12a:	fa ea 00 08 	ld.d	r10,sp[8]
8000a12e:	e0 a0 0d d5 	rcall	8000bcd8 <__avr32_f64_to_s32>
8000a132:	51 6c       	stdsp	sp[0x58],r12
8000a134:	e0 a0 0d e9 	rcall	8000bd06 <__avr32_s32_to_f64>
8000a138:	14 98       	mov	r8,r10
8000a13a:	16 99       	mov	r9,r11
8000a13c:	fa ea 00 08 	ld.d	r10,sp[8]
8000a140:	e0 a0 0c 74 	rcall	8000ba28 <__avr32_f64_sub>
8000a144:	fa eb 00 08 	st.d	sp[8],r10
8000a148:	41 68       	lddsp	r8,sp[0x58]
8000a14a:	2d 08       	sub	r8,-48
8000a14c:	0a c8       	st.b	r5++,r8
8000a14e:	41 3c       	lddsp	r12,sp[0x4c]
8000a150:	18 35       	cp.w	r5,r12
8000a152:	c2 91       	brne	8000a1a4 <_dtoa_r+0x620>
8000a154:	30 08       	mov	r8,0
8000a156:	fc 19 3f e0 	movh	r9,0x3fe0
8000a15a:	fa ea 00 28 	ld.d	r10,sp[40]
8000a15e:	e0 a0 0d 33 	rcall	8000bbc4 <__avr32_f64_add>
8000a162:	40 85       	lddsp	r5,sp[0x20]
8000a164:	fa e8 00 08 	ld.d	r8,sp[8]
8000a168:	08 05       	add	r5,r4
8000a16a:	e0 a0 0e 85 	rcall	8000be74 <__avr32_f64_cmp_lt>
8000a16e:	e0 81 00 99 	brne	8000a2a0 <_dtoa_r+0x71c>
8000a172:	fa e8 00 28 	ld.d	r8,sp[40]
8000a176:	30 0a       	mov	r10,0
8000a178:	fc 1b 3f e0 	movh	r11,0x3fe0
8000a17c:	e0 a0 0c 56 	rcall	8000ba28 <__avr32_f64_sub>
8000a180:	14 98       	mov	r8,r10
8000a182:	16 99       	mov	r9,r11
8000a184:	fa ea 00 08 	ld.d	r10,sp[8]
8000a188:	e0 a0 0e 76 	rcall	8000be74 <__avr32_f64_cmp_lt>
8000a18c:	c1 40       	breq	8000a1b4 <_dtoa_r+0x630>
8000a18e:	33 09       	mov	r9,48
8000a190:	0a 98       	mov	r8,r5
8000a192:	11 7a       	ld.ub	r10,--r8
8000a194:	f2 0a 18 00 	cp.b	r10,r9
8000a198:	e0 81 02 d2 	brne	8000a73c <_dtoa_r+0xbb8>
8000a19c:	10 95       	mov	r5,r8
8000a19e:	cf 9b       	rjmp	8000a190 <_dtoa_r+0x60c>
8000a1a0:	80 01       	ld.sh	r1,r0[0x0]
8000a1a2:	5f 90       	srgt	r0
8000a1a4:	30 08       	mov	r8,0
8000a1a6:	fc 19 40 24 	movh	r9,0x4024
8000a1aa:	e0 a0 0b 53 	rcall	8000b850 <__avr32_f64_mul>
8000a1ae:	fa eb 00 08 	st.d	sp[8],r10
8000a1b2:	cb cb       	rjmp	8000a12a <_dtoa_r+0x5a6>
8000a1b4:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a1b8:	fa eb 00 08 	st.d	sp[8],r10
8000a1bc:	58 e6       	cp.w	r6,14
8000a1be:	5f ab       	srle	r11
8000a1c0:	41 8a       	lddsp	r10,sp[0x60]
8000a1c2:	30 08       	mov	r8,0
8000a1c4:	f4 09 11 ff 	rsub	r9,r10,-1
8000a1c8:	f7 e9 03 f9 	and	r9,r11,r9>>0x1f
8000a1cc:	f0 09 18 00 	cp.b	r9,r8
8000a1d0:	e0 80 00 81 	breq	8000a2d2 <_dtoa_r+0x74e>
8000a1d4:	40 ea       	lddsp	r10,sp[0x38]
8000a1d6:	58 01       	cp.w	r1,0
8000a1d8:	5f a9       	srle	r9
8000a1da:	f3 ea 03 f9 	and	r9,r9,r10>>0x1f
8000a1de:	4c 9a       	lddpc	r10,8000a300 <_dtoa_r+0x77c>
8000a1e0:	f4 06 02 34 	ld.d	r4,r10[r6<<0x3]
8000a1e4:	fa e5 00 10 	st.d	sp[16],r4
8000a1e8:	f0 09 18 00 	cp.b	r9,r8
8000a1ec:	c1 40       	breq	8000a214 <_dtoa_r+0x690>
8000a1ee:	58 01       	cp.w	r1,0
8000a1f0:	e0 81 01 78 	brne	8000a4e0 <_dtoa_r+0x95c>
8000a1f4:	30 08       	mov	r8,0
8000a1f6:	fc 19 40 14 	movh	r9,0x4014
8000a1fa:	08 9a       	mov	r10,r4
8000a1fc:	0a 9b       	mov	r11,r5
8000a1fe:	e0 a0 0b 29 	rcall	8000b850 <__avr32_f64_mul>
8000a202:	fa e8 00 08 	ld.d	r8,sp[8]
8000a206:	e0 a0 0e 03 	rcall	8000be0c <__avr32_f64_cmp_ge>
8000a20a:	e0 81 01 6b 	brne	8000a4e0 <_dtoa_r+0x95c>
8000a20e:	02 92       	mov	r2,r1
8000a210:	e0 8f 01 73 	bral	8000a4f6 <_dtoa_r+0x972>
8000a214:	40 85       	lddsp	r5,sp[0x20]
8000a216:	30 14       	mov	r4,1
8000a218:	fa e8 00 10 	ld.d	r8,sp[16]
8000a21c:	fa ea 00 08 	ld.d	r10,sp[8]
8000a220:	e0 a0 0e 5e 	rcall	8000bedc <__avr32_f64_div>
8000a224:	e0 a0 0d 5a 	rcall	8000bcd8 <__avr32_f64_to_s32>
8000a228:	18 92       	mov	r2,r12
8000a22a:	e0 a0 0d 6e 	rcall	8000bd06 <__avr32_s32_to_f64>
8000a22e:	fa e8 00 10 	ld.d	r8,sp[16]
8000a232:	e0 a0 0b 0f 	rcall	8000b850 <__avr32_f64_mul>
8000a236:	14 98       	mov	r8,r10
8000a238:	16 99       	mov	r9,r11
8000a23a:	fa ea 00 08 	ld.d	r10,sp[8]
8000a23e:	e0 a0 0b f5 	rcall	8000ba28 <__avr32_f64_sub>
8000a242:	fa eb 00 08 	st.d	sp[8],r10
8000a246:	e4 c8 ff d0 	sub	r8,r2,-48
8000a24a:	0a c8       	st.b	r5++,r8
8000a24c:	fc 19 40 24 	movh	r9,0x4024
8000a250:	30 08       	mov	r8,0
8000a252:	02 34       	cp.w	r4,r1
8000a254:	c3 31       	brne	8000a2ba <_dtoa_r+0x736>
8000a256:	fa e8 00 08 	ld.d	r8,sp[8]
8000a25a:	e0 a0 0c b5 	rcall	8000bbc4 <__avr32_f64_add>
8000a25e:	16 91       	mov	r1,r11
8000a260:	14 90       	mov	r0,r10
8000a262:	14 98       	mov	r8,r10
8000a264:	02 99       	mov	r9,r1
8000a266:	fa ea 00 10 	ld.d	r10,sp[16]
8000a26a:	e0 a0 0e 05 	rcall	8000be74 <__avr32_f64_cmp_lt>
8000a26e:	c1 a1       	brne	8000a2a2 <_dtoa_r+0x71e>
8000a270:	fa e8 00 10 	ld.d	r8,sp[16]
8000a274:	00 9a       	mov	r10,r0
8000a276:	02 9b       	mov	r11,r1
8000a278:	e0 a0 0d b7 	rcall	8000bde6 <__avr32_f64_cmp_eq>
8000a27c:	e0 80 02 5f 	breq	8000a73a <_dtoa_r+0xbb6>
8000a280:	e5 d2 c0 01 	bfextu	r2,r2,0x0,0x1
8000a284:	c0 f1       	brne	8000a2a2 <_dtoa_r+0x71e>
8000a286:	e0 8f 02 5a 	bral	8000a73a <_dtoa_r+0xbb6>
8000a28a:	40 8a       	lddsp	r10,sp[0x20]
8000a28c:	14 38       	cp.w	r8,r10
8000a28e:	c0 30       	breq	8000a294 <_dtoa_r+0x710>
8000a290:	10 95       	mov	r5,r8
8000a292:	c0 98       	rjmp	8000a2a4 <_dtoa_r+0x720>
8000a294:	33 08       	mov	r8,48
8000a296:	40 89       	lddsp	r9,sp[0x20]
8000a298:	2f f6       	sub	r6,-1
8000a29a:	b2 88       	st.b	r9[0x0],r8
8000a29c:	40 88       	lddsp	r8,sp[0x20]
8000a29e:	c0 88       	rjmp	8000a2ae <_dtoa_r+0x72a>
8000a2a0:	40 66       	lddsp	r6,sp[0x18]
8000a2a2:	33 99       	mov	r9,57
8000a2a4:	0a 98       	mov	r8,r5
8000a2a6:	11 7a       	ld.ub	r10,--r8
8000a2a8:	f2 0a 18 00 	cp.b	r10,r9
8000a2ac:	ce f0       	breq	8000a28a <_dtoa_r+0x706>
8000a2ae:	50 66       	stdsp	sp[0x18],r6
8000a2b0:	11 89       	ld.ub	r9,r8[0x0]
8000a2b2:	2f f9       	sub	r9,-1
8000a2b4:	b0 89       	st.b	r8[0x0],r9
8000a2b6:	e0 8f 02 43 	bral	8000a73c <_dtoa_r+0xbb8>
8000a2ba:	e0 a0 0a cb 	rcall	8000b850 <__avr32_f64_mul>
8000a2be:	2f f4       	sub	r4,-1
8000a2c0:	fa eb 00 08 	st.d	sp[8],r10
8000a2c4:	30 08       	mov	r8,0
8000a2c6:	30 09       	mov	r9,0
8000a2c8:	e0 a0 0d 8f 	rcall	8000bde6 <__avr32_f64_cmp_eq>
8000a2cc:	ca 60       	breq	8000a218 <_dtoa_r+0x694>
8000a2ce:	e0 8f 02 36 	bral	8000a73a <_dtoa_r+0xbb6>
8000a2d2:	40 d8       	lddsp	r8,sp[0x34]
8000a2d4:	58 08       	cp.w	r8,0
8000a2d6:	c0 51       	brne	8000a2e0 <_dtoa_r+0x75c>
8000a2d8:	04 98       	mov	r8,r2
8000a2da:	00 95       	mov	r5,r0
8000a2dc:	40 d4       	lddsp	r4,sp[0x34]
8000a2de:	c3 88       	rjmp	8000a34e <_dtoa_r+0x7ca>
8000a2e0:	40 c5       	lddsp	r5,sp[0x30]
8000a2e2:	58 15       	cp.w	r5,1
8000a2e4:	e0 89 00 10 	brgt	8000a304 <_dtoa_r+0x780>
8000a2e8:	41 74       	lddsp	r4,sp[0x5c]
8000a2ea:	58 04       	cp.w	r4,0
8000a2ec:	c0 40       	breq	8000a2f4 <_dtoa_r+0x770>
8000a2ee:	f4 c9 fb cd 	sub	r9,r10,-1075
8000a2f2:	c0 48       	rjmp	8000a2fa <_dtoa_r+0x776>
8000a2f4:	41 99       	lddsp	r9,sp[0x64]
8000a2f6:	f2 09 11 36 	rsub	r9,r9,54
8000a2fa:	04 98       	mov	r8,r2
8000a2fc:	00 95       	mov	r5,r0
8000a2fe:	c1 d8       	rjmp	8000a338 <_dtoa_r+0x7b4>
8000a300:	80 01       	ld.sh	r1,r0[0x0]
8000a302:	5f 90       	srgt	r0
8000a304:	e2 c8 00 01 	sub	r8,r1,1
8000a308:	58 01       	cp.w	r1,0
8000a30a:	e0 05 17 40 	movge	r5,r0
8000a30e:	e2 09 17 40 	movge	r9,r1
8000a312:	e1 d1 e5 15 	sublt	r5,r0,r1
8000a316:	f9 b9 05 00 	movlt	r9,0
8000a31a:	10 32       	cp.w	r2,r8
8000a31c:	e5 d8 e4 18 	subge	r8,r2,r8
8000a320:	f1 d2 e5 18 	sublt	r8,r8,r2
8000a324:	e5 d8 e5 02 	addlt	r2,r2,r8
8000a328:	fb fc 50 11 	ld.wlt	r12,sp[0x44]
8000a32c:	f9 d8 e5 0c 	addlt	r12,r12,r8
8000a330:	fb fc 5a 11 	st.wlt	sp[0x44],r12
8000a334:	f9 b8 05 00 	movlt	r8,0
8000a338:	40 4b       	lddsp	r11,sp[0x10]
8000a33a:	12 0b       	add	r11,r9
8000a33c:	50 08       	stdsp	sp[0x0],r8
8000a33e:	50 4b       	stdsp	sp[0x10],r11
8000a340:	12 00       	add	r0,r9
8000a342:	30 1b       	mov	r11,1
8000a344:	0e 9c       	mov	r12,r7
8000a346:	e0 a0 08 ab 	rcall	8000b49c <__i2b>
8000a34a:	40 08       	lddsp	r8,sp[0x0]
8000a34c:	18 94       	mov	r4,r12
8000a34e:	40 4a       	lddsp	r10,sp[0x10]
8000a350:	58 05       	cp.w	r5,0
8000a352:	5f 99       	srgt	r9
8000a354:	58 0a       	cp.w	r10,0
8000a356:	5f 9a       	srgt	r10
8000a358:	f5 e9 00 09 	and	r9,r10,r9
8000a35c:	c0 80       	breq	8000a36c <_dtoa_r+0x7e8>
8000a35e:	40 4c       	lddsp	r12,sp[0x10]
8000a360:	f8 05 0d 49 	min	r9,r12,r5
8000a364:	12 1c       	sub	r12,r9
8000a366:	12 10       	sub	r0,r9
8000a368:	50 4c       	stdsp	sp[0x10],r12
8000a36a:	12 15       	sub	r5,r9
8000a36c:	58 02       	cp.w	r2,0
8000a36e:	e0 8a 00 27 	brle	8000a3bc <_dtoa_r+0x838>
8000a372:	40 db       	lddsp	r11,sp[0x34]
8000a374:	58 0b       	cp.w	r11,0
8000a376:	c1 d0       	breq	8000a3b0 <_dtoa_r+0x82c>
8000a378:	58 08       	cp.w	r8,0
8000a37a:	e0 8a 00 17 	brle	8000a3a8 <_dtoa_r+0x824>
8000a37e:	10 9a       	mov	r10,r8
8000a380:	50 08       	stdsp	sp[0x0],r8
8000a382:	08 9b       	mov	r11,r4
8000a384:	0e 9c       	mov	r12,r7
8000a386:	e0 a0 08 d1 	rcall	8000b528 <__pow5mult>
8000a38a:	06 9a       	mov	r10,r3
8000a38c:	18 9b       	mov	r11,r12
8000a38e:	18 94       	mov	r4,r12
8000a390:	0e 9c       	mov	r12,r7
8000a392:	e0 a0 08 05 	rcall	8000b39c <__multiply>
8000a396:	18 99       	mov	r9,r12
8000a398:	06 9b       	mov	r11,r3
8000a39a:	50 19       	stdsp	sp[0x4],r9
8000a39c:	0e 9c       	mov	r12,r7
8000a39e:	e0 a0 06 b1 	rcall	8000b100 <_Bfree>
8000a3a2:	40 19       	lddsp	r9,sp[0x4]
8000a3a4:	40 08       	lddsp	r8,sp[0x0]
8000a3a6:	12 93       	mov	r3,r9
8000a3a8:	e4 08 01 0a 	sub	r10,r2,r8
8000a3ac:	c0 80       	breq	8000a3bc <_dtoa_r+0x838>
8000a3ae:	c0 28       	rjmp	8000a3b2 <_dtoa_r+0x82e>
8000a3b0:	04 9a       	mov	r10,r2
8000a3b2:	06 9b       	mov	r11,r3
8000a3b4:	0e 9c       	mov	r12,r7
8000a3b6:	e0 a0 08 b9 	rcall	8000b528 <__pow5mult>
8000a3ba:	18 93       	mov	r3,r12
8000a3bc:	30 1b       	mov	r11,1
8000a3be:	0e 9c       	mov	r12,r7
8000a3c0:	e0 a0 08 6e 	rcall	8000b49c <__i2b>
8000a3c4:	41 1a       	lddsp	r10,sp[0x44]
8000a3c6:	18 92       	mov	r2,r12
8000a3c8:	58 0a       	cp.w	r10,0
8000a3ca:	e0 8a 00 07 	brle	8000a3d8 <_dtoa_r+0x854>
8000a3ce:	18 9b       	mov	r11,r12
8000a3d0:	0e 9c       	mov	r12,r7
8000a3d2:	e0 a0 08 ab 	rcall	8000b528 <__pow5mult>
8000a3d6:	18 92       	mov	r2,r12
8000a3d8:	40 c9       	lddsp	r9,sp[0x30]
8000a3da:	58 19       	cp.w	r9,1
8000a3dc:	e0 89 00 14 	brgt	8000a404 <_dtoa_r+0x880>
8000a3e0:	40 38       	lddsp	r8,sp[0xc]
8000a3e2:	58 08       	cp.w	r8,0
8000a3e4:	c1 01       	brne	8000a404 <_dtoa_r+0x880>
8000a3e6:	40 29       	lddsp	r9,sp[0x8]
8000a3e8:	f1 d9 c0 14 	bfextu	r8,r9,0x0,0x14
8000a3ec:	c0 c1       	brne	8000a404 <_dtoa_r+0x880>
8000a3ee:	12 98       	mov	r8,r9
8000a3f0:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000a3f4:	c0 80       	breq	8000a404 <_dtoa_r+0x880>
8000a3f6:	40 4c       	lddsp	r12,sp[0x10]
8000a3f8:	30 1b       	mov	r11,1
8000a3fa:	2f fc       	sub	r12,-1
8000a3fc:	2f f0       	sub	r0,-1
8000a3fe:	50 4c       	stdsp	sp[0x10],r12
8000a400:	50 6b       	stdsp	sp[0x18],r11
8000a402:	c0 38       	rjmp	8000a408 <_dtoa_r+0x884>
8000a404:	30 0a       	mov	r10,0
8000a406:	50 6a       	stdsp	sp[0x18],r10
8000a408:	41 19       	lddsp	r9,sp[0x44]
8000a40a:	58 09       	cp.w	r9,0
8000a40c:	c0 31       	brne	8000a412 <_dtoa_r+0x88e>
8000a40e:	30 1c       	mov	r12,1
8000a410:	c0 98       	rjmp	8000a422 <_dtoa_r+0x89e>
8000a412:	64 48       	ld.w	r8,r2[0x10]
8000a414:	2f c8       	sub	r8,-4
8000a416:	e4 08 03 2c 	ld.w	r12,r2[r8<<0x2]
8000a41a:	e0 a0 05 e3 	rcall	8000afe0 <__hi0bits>
8000a41e:	f8 0c 11 20 	rsub	r12,r12,32
8000a422:	40 4b       	lddsp	r11,sp[0x10]
8000a424:	f8 0b 00 08 	add	r8,r12,r11
8000a428:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000a42c:	c0 c0       	breq	8000a444 <_dtoa_r+0x8c0>
8000a42e:	f0 08 11 20 	rsub	r8,r8,32
8000a432:	58 48       	cp.w	r8,4
8000a434:	e0 8a 00 06 	brle	8000a440 <_dtoa_r+0x8bc>
8000a438:	20 48       	sub	r8,4
8000a43a:	10 0b       	add	r11,r8
8000a43c:	50 4b       	stdsp	sp[0x10],r11
8000a43e:	c0 78       	rjmp	8000a44c <_dtoa_r+0x8c8>
8000a440:	58 48       	cp.w	r8,4
8000a442:	c0 70       	breq	8000a450 <_dtoa_r+0x8cc>
8000a444:	40 4a       	lddsp	r10,sp[0x10]
8000a446:	2e 48       	sub	r8,-28
8000a448:	10 0a       	add	r10,r8
8000a44a:	50 4a       	stdsp	sp[0x10],r10
8000a44c:	10 00       	add	r0,r8
8000a44e:	10 05       	add	r5,r8
8000a450:	58 00       	cp.w	r0,0
8000a452:	e0 8a 00 08 	brle	8000a462 <_dtoa_r+0x8de>
8000a456:	06 9b       	mov	r11,r3
8000a458:	00 9a       	mov	r10,r0
8000a45a:	0e 9c       	mov	r12,r7
8000a45c:	e0 a0 07 5c 	rcall	8000b314 <__lshift>
8000a460:	18 93       	mov	r3,r12
8000a462:	40 49       	lddsp	r9,sp[0x10]
8000a464:	58 09       	cp.w	r9,0
8000a466:	e0 8a 00 08 	brle	8000a476 <_dtoa_r+0x8f2>
8000a46a:	04 9b       	mov	r11,r2
8000a46c:	12 9a       	mov	r10,r9
8000a46e:	0e 9c       	mov	r12,r7
8000a470:	e0 a0 07 52 	rcall	8000b314 <__lshift>
8000a474:	18 92       	mov	r2,r12
8000a476:	41 48       	lddsp	r8,sp[0x50]
8000a478:	58 08       	cp.w	r8,0
8000a47a:	c1 b0       	breq	8000a4b0 <_dtoa_r+0x92c>
8000a47c:	04 9b       	mov	r11,r2
8000a47e:	06 9c       	mov	r12,r3
8000a480:	e0 a0 06 27 	rcall	8000b0ce <__mcmp>
8000a484:	c1 64       	brge	8000a4b0 <_dtoa_r+0x92c>
8000a486:	06 9b       	mov	r11,r3
8000a488:	30 09       	mov	r9,0
8000a48a:	30 aa       	mov	r10,10
8000a48c:	0e 9c       	mov	r12,r7
8000a48e:	e0 a0 08 0f 	rcall	8000b4ac <__multadd>
8000a492:	20 16       	sub	r6,1
8000a494:	18 93       	mov	r3,r12
8000a496:	40 dc       	lddsp	r12,sp[0x34]
8000a498:	58 0c       	cp.w	r12,0
8000a49a:	c0 31       	brne	8000a4a0 <_dtoa_r+0x91c>
8000a49c:	40 91       	lddsp	r1,sp[0x24]
8000a49e:	c0 98       	rjmp	8000a4b0 <_dtoa_r+0x92c>
8000a4a0:	08 9b       	mov	r11,r4
8000a4a2:	40 91       	lddsp	r1,sp[0x24]
8000a4a4:	30 09       	mov	r9,0
8000a4a6:	30 aa       	mov	r10,10
8000a4a8:	0e 9c       	mov	r12,r7
8000a4aa:	e0 a0 08 01 	rcall	8000b4ac <__multadd>
8000a4ae:	18 94       	mov	r4,r12
8000a4b0:	58 01       	cp.w	r1,0
8000a4b2:	5f a9       	srle	r9
8000a4b4:	40 cb       	lddsp	r11,sp[0x30]
8000a4b6:	58 2b       	cp.w	r11,2
8000a4b8:	5f 98       	srgt	r8
8000a4ba:	f3 e8 00 08 	and	r8,r9,r8
8000a4be:	c2 50       	breq	8000a508 <_dtoa_r+0x984>
8000a4c0:	58 01       	cp.w	r1,0
8000a4c2:	c1 11       	brne	8000a4e4 <_dtoa_r+0x960>
8000a4c4:	04 9b       	mov	r11,r2
8000a4c6:	02 99       	mov	r9,r1
8000a4c8:	30 5a       	mov	r10,5
8000a4ca:	0e 9c       	mov	r12,r7
8000a4cc:	e0 a0 07 f0 	rcall	8000b4ac <__multadd>
8000a4d0:	18 92       	mov	r2,r12
8000a4d2:	18 9b       	mov	r11,r12
8000a4d4:	06 9c       	mov	r12,r3
8000a4d6:	e0 a0 05 fc 	rcall	8000b0ce <__mcmp>
8000a4da:	e0 89 00 0f 	brgt	8000a4f8 <_dtoa_r+0x974>
8000a4de:	c0 38       	rjmp	8000a4e4 <_dtoa_r+0x960>
8000a4e0:	30 02       	mov	r2,0
8000a4e2:	04 94       	mov	r4,r2
8000a4e4:	40 ea       	lddsp	r10,sp[0x38]
8000a4e6:	30 09       	mov	r9,0
8000a4e8:	5c da       	com	r10
8000a4ea:	40 85       	lddsp	r5,sp[0x20]
8000a4ec:	50 6a       	stdsp	sp[0x18],r10
8000a4ee:	50 49       	stdsp	sp[0x10],r9
8000a4f0:	c0 f9       	rjmp	8000a70e <_dtoa_r+0xb8a>
8000a4f2:	08 92       	mov	r2,r4
8000a4f4:	40 66       	lddsp	r6,sp[0x18]
8000a4f6:	04 94       	mov	r4,r2
8000a4f8:	2f f6       	sub	r6,-1
8000a4fa:	50 66       	stdsp	sp[0x18],r6
8000a4fc:	33 18       	mov	r8,49
8000a4fe:	40 85       	lddsp	r5,sp[0x20]
8000a500:	0a c8       	st.b	r5++,r8
8000a502:	30 08       	mov	r8,0
8000a504:	50 48       	stdsp	sp[0x10],r8
8000a506:	c0 49       	rjmp	8000a70e <_dtoa_r+0xb8a>
8000a508:	40 dc       	lddsp	r12,sp[0x34]
8000a50a:	58 0c       	cp.w	r12,0
8000a50c:	e0 80 00 b5 	breq	8000a676 <_dtoa_r+0xaf2>
8000a510:	58 05       	cp.w	r5,0
8000a512:	e0 8a 00 08 	brle	8000a522 <_dtoa_r+0x99e>
8000a516:	08 9b       	mov	r11,r4
8000a518:	0a 9a       	mov	r10,r5
8000a51a:	0e 9c       	mov	r12,r7
8000a51c:	e0 a0 06 fc 	rcall	8000b314 <__lshift>
8000a520:	18 94       	mov	r4,r12
8000a522:	40 6b       	lddsp	r11,sp[0x18]
8000a524:	58 0b       	cp.w	r11,0
8000a526:	c0 31       	brne	8000a52c <_dtoa_r+0x9a8>
8000a528:	08 9c       	mov	r12,r4
8000a52a:	c1 38       	rjmp	8000a550 <_dtoa_r+0x9cc>
8000a52c:	68 1b       	ld.w	r11,r4[0x4]
8000a52e:	0e 9c       	mov	r12,r7
8000a530:	e0 a0 06 02 	rcall	8000b134 <_Balloc>
8000a534:	68 4a       	ld.w	r10,r4[0x10]
8000a536:	18 95       	mov	r5,r12
8000a538:	e8 cb ff f4 	sub	r11,r4,-12
8000a53c:	2f ea       	sub	r10,-2
8000a53e:	2f 4c       	sub	r12,-12
8000a540:	a3 6a       	lsl	r10,0x2
8000a542:	fe b0 e6 26 	rcall	8000718e <memcpy>
8000a546:	0a 9b       	mov	r11,r5
8000a548:	30 1a       	mov	r10,1
8000a54a:	0e 9c       	mov	r12,r7
8000a54c:	e0 a0 06 e4 	rcall	8000b314 <__lshift>
8000a550:	50 44       	stdsp	sp[0x10],r4
8000a552:	40 3a       	lddsp	r10,sp[0xc]
8000a554:	30 19       	mov	r9,1
8000a556:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
8000a55a:	18 94       	mov	r4,r12
8000a55c:	50 da       	stdsp	sp[0x34],r10
8000a55e:	40 85       	lddsp	r5,sp[0x20]
8000a560:	50 99       	stdsp	sp[0x24],r9
8000a562:	50 26       	stdsp	sp[0x8],r6
8000a564:	50 e1       	stdsp	sp[0x38],r1
8000a566:	04 9b       	mov	r11,r2
8000a568:	06 9c       	mov	r12,r3
8000a56a:	fe b0 fa 7d 	rcall	80009a64 <quorem>
8000a56e:	40 4b       	lddsp	r11,sp[0x10]
8000a570:	f8 c0 ff d0 	sub	r0,r12,-48
8000a574:	06 9c       	mov	r12,r3
8000a576:	e0 a0 05 ac 	rcall	8000b0ce <__mcmp>
8000a57a:	08 9a       	mov	r10,r4
8000a57c:	50 6c       	stdsp	sp[0x18],r12
8000a57e:	04 9b       	mov	r11,r2
8000a580:	0e 9c       	mov	r12,r7
8000a582:	e0 a0 06 61 	rcall	8000b244 <__mdiff>
8000a586:	18 91       	mov	r1,r12
8000a588:	78 38       	ld.w	r8,r12[0xc]
8000a58a:	58 08       	cp.w	r8,0
8000a58c:	c0 30       	breq	8000a592 <_dtoa_r+0xa0e>
8000a58e:	30 16       	mov	r6,1
8000a590:	c0 68       	rjmp	8000a59c <_dtoa_r+0xa18>
8000a592:	18 9b       	mov	r11,r12
8000a594:	06 9c       	mov	r12,r3
8000a596:	e0 a0 05 9c 	rcall	8000b0ce <__mcmp>
8000a59a:	18 96       	mov	r6,r12
8000a59c:	0e 9c       	mov	r12,r7
8000a59e:	02 9b       	mov	r11,r1
8000a5a0:	e0 a0 05 b0 	rcall	8000b100 <_Bfree>
8000a5a4:	40 cc       	lddsp	r12,sp[0x30]
8000a5a6:	ed ec 10 08 	or	r8,r6,r12
8000a5aa:	c0 d1       	brne	8000a5c4 <_dtoa_r+0xa40>
8000a5ac:	40 db       	lddsp	r11,sp[0x34]
8000a5ae:	58 0b       	cp.w	r11,0
8000a5b0:	c0 a1       	brne	8000a5c4 <_dtoa_r+0xa40>
8000a5b2:	40 26       	lddsp	r6,sp[0x8]
8000a5b4:	e0 40 00 39 	cp.w	r0,57
8000a5b8:	c3 00       	breq	8000a618 <_dtoa_r+0xa94>
8000a5ba:	40 6a       	lddsp	r10,sp[0x18]
8000a5bc:	58 0a       	cp.w	r10,0
8000a5be:	e0 89 00 24 	brgt	8000a606 <_dtoa_r+0xa82>
8000a5c2:	c2 f8       	rjmp	8000a620 <_dtoa_r+0xa9c>
8000a5c4:	40 69       	lddsp	r9,sp[0x18]
8000a5c6:	58 09       	cp.w	r9,0
8000a5c8:	c0 85       	brlt	8000a5d8 <_dtoa_r+0xa54>
8000a5ca:	12 98       	mov	r8,r9
8000a5cc:	40 cc       	lddsp	r12,sp[0x30]
8000a5ce:	18 48       	or	r8,r12
8000a5d0:	c1 d1       	brne	8000a60a <_dtoa_r+0xa86>
8000a5d2:	40 db       	lddsp	r11,sp[0x34]
8000a5d4:	58 0b       	cp.w	r11,0
8000a5d6:	c1 a1       	brne	8000a60a <_dtoa_r+0xa86>
8000a5d8:	0c 99       	mov	r9,r6
8000a5da:	40 26       	lddsp	r6,sp[0x8]
8000a5dc:	58 09       	cp.w	r9,0
8000a5de:	e0 8a 00 21 	brle	8000a620 <_dtoa_r+0xa9c>
8000a5e2:	06 9b       	mov	r11,r3
8000a5e4:	30 1a       	mov	r10,1
8000a5e6:	0e 9c       	mov	r12,r7
8000a5e8:	e0 a0 06 96 	rcall	8000b314 <__lshift>
8000a5ec:	04 9b       	mov	r11,r2
8000a5ee:	18 93       	mov	r3,r12
8000a5f0:	e0 a0 05 6f 	rcall	8000b0ce <__mcmp>
8000a5f4:	e0 89 00 06 	brgt	8000a600 <_dtoa_r+0xa7c>
8000a5f8:	c1 41       	brne	8000a620 <_dtoa_r+0xa9c>
8000a5fa:	ed b0 00 00 	bld	r0,0x0
8000a5fe:	c1 11       	brne	8000a620 <_dtoa_r+0xa9c>
8000a600:	e0 40 00 39 	cp.w	r0,57
8000a604:	c0 a0       	breq	8000a618 <_dtoa_r+0xa94>
8000a606:	2f f0       	sub	r0,-1
8000a608:	c0 c8       	rjmp	8000a620 <_dtoa_r+0xa9c>
8000a60a:	58 06       	cp.w	r6,0
8000a60c:	e0 8a 00 0c 	brle	8000a624 <_dtoa_r+0xaa0>
8000a610:	40 26       	lddsp	r6,sp[0x8]
8000a612:	e0 40 00 39 	cp.w	r0,57
8000a616:	c0 41       	brne	8000a61e <_dtoa_r+0xa9a>
8000a618:	33 98       	mov	r8,57
8000a61a:	0a c8       	st.b	r5++,r8
8000a61c:	c6 78       	rjmp	8000a6ea <_dtoa_r+0xb66>
8000a61e:	2f f0       	sub	r0,-1
8000a620:	0a c0       	st.b	r5++,r0
8000a622:	c7 58       	rjmp	8000a70c <_dtoa_r+0xb88>
8000a624:	0a c0       	st.b	r5++,r0
8000a626:	40 9a       	lddsp	r10,sp[0x24]
8000a628:	40 e9       	lddsp	r9,sp[0x38]
8000a62a:	12 3a       	cp.w	r10,r9
8000a62c:	c4 30       	breq	8000a6b2 <_dtoa_r+0xb2e>
8000a62e:	06 9b       	mov	r11,r3
8000a630:	30 09       	mov	r9,0
8000a632:	30 aa       	mov	r10,10
8000a634:	0e 9c       	mov	r12,r7
8000a636:	e0 a0 07 3b 	rcall	8000b4ac <__multadd>
8000a63a:	40 48       	lddsp	r8,sp[0x10]
8000a63c:	18 93       	mov	r3,r12
8000a63e:	08 38       	cp.w	r8,r4
8000a640:	c0 91       	brne	8000a652 <_dtoa_r+0xace>
8000a642:	10 9b       	mov	r11,r8
8000a644:	30 09       	mov	r9,0
8000a646:	30 aa       	mov	r10,10
8000a648:	0e 9c       	mov	r12,r7
8000a64a:	e0 a0 07 31 	rcall	8000b4ac <__multadd>
8000a64e:	50 4c       	stdsp	sp[0x10],r12
8000a650:	c0 e8       	rjmp	8000a66c <_dtoa_r+0xae8>
8000a652:	40 4b       	lddsp	r11,sp[0x10]
8000a654:	30 09       	mov	r9,0
8000a656:	30 aa       	mov	r10,10
8000a658:	0e 9c       	mov	r12,r7
8000a65a:	e0 a0 07 29 	rcall	8000b4ac <__multadd>
8000a65e:	08 9b       	mov	r11,r4
8000a660:	50 4c       	stdsp	sp[0x10],r12
8000a662:	30 09       	mov	r9,0
8000a664:	30 aa       	mov	r10,10
8000a666:	0e 9c       	mov	r12,r7
8000a668:	e0 a0 07 22 	rcall	8000b4ac <__multadd>
8000a66c:	18 94       	mov	r4,r12
8000a66e:	40 9c       	lddsp	r12,sp[0x24]
8000a670:	2f fc       	sub	r12,-1
8000a672:	50 9c       	stdsp	sp[0x24],r12
8000a674:	c7 9b       	rjmp	8000a566 <_dtoa_r+0x9e2>
8000a676:	30 18       	mov	r8,1
8000a678:	06 90       	mov	r0,r3
8000a67a:	40 85       	lddsp	r5,sp[0x20]
8000a67c:	08 93       	mov	r3,r4
8000a67e:	0c 94       	mov	r4,r6
8000a680:	10 96       	mov	r6,r8
8000a682:	04 9b       	mov	r11,r2
8000a684:	00 9c       	mov	r12,r0
8000a686:	fe b0 f9 ef 	rcall	80009a64 <quorem>
8000a68a:	2d 0c       	sub	r12,-48
8000a68c:	0a cc       	st.b	r5++,r12
8000a68e:	02 36       	cp.w	r6,r1
8000a690:	c0 a4       	brge	8000a6a4 <_dtoa_r+0xb20>
8000a692:	00 9b       	mov	r11,r0
8000a694:	30 09       	mov	r9,0
8000a696:	30 aa       	mov	r10,10
8000a698:	0e 9c       	mov	r12,r7
8000a69a:	2f f6       	sub	r6,-1
8000a69c:	e0 a0 07 08 	rcall	8000b4ac <__multadd>
8000a6a0:	18 90       	mov	r0,r12
8000a6a2:	cf 0b       	rjmp	8000a682 <_dtoa_r+0xafe>
8000a6a4:	08 96       	mov	r6,r4
8000a6a6:	30 0b       	mov	r11,0
8000a6a8:	06 94       	mov	r4,r3
8000a6aa:	50 4b       	stdsp	sp[0x10],r11
8000a6ac:	00 93       	mov	r3,r0
8000a6ae:	18 90       	mov	r0,r12
8000a6b0:	c0 28       	rjmp	8000a6b4 <_dtoa_r+0xb30>
8000a6b2:	40 26       	lddsp	r6,sp[0x8]
8000a6b4:	06 9b       	mov	r11,r3
8000a6b6:	30 1a       	mov	r10,1
8000a6b8:	0e 9c       	mov	r12,r7
8000a6ba:	e0 a0 06 2d 	rcall	8000b314 <__lshift>
8000a6be:	04 9b       	mov	r11,r2
8000a6c0:	18 93       	mov	r3,r12
8000a6c2:	e0 a0 05 06 	rcall	8000b0ce <__mcmp>
8000a6c6:	e0 89 00 12 	brgt	8000a6ea <_dtoa_r+0xb66>
8000a6ca:	c1 b1       	brne	8000a700 <_dtoa_r+0xb7c>
8000a6cc:	e1 d0 c0 01 	bfextu	r0,r0,0x0,0x1
8000a6d0:	c0 d1       	brne	8000a6ea <_dtoa_r+0xb66>
8000a6d2:	c1 78       	rjmp	8000a700 <_dtoa_r+0xb7c>
8000a6d4:	40 89       	lddsp	r9,sp[0x20]
8000a6d6:	12 38       	cp.w	r8,r9
8000a6d8:	c0 30       	breq	8000a6de <_dtoa_r+0xb5a>
8000a6da:	10 95       	mov	r5,r8
8000a6dc:	c0 88       	rjmp	8000a6ec <_dtoa_r+0xb68>
8000a6de:	2f f6       	sub	r6,-1
8000a6e0:	50 66       	stdsp	sp[0x18],r6
8000a6e2:	33 18       	mov	r8,49
8000a6e4:	40 8c       	lddsp	r12,sp[0x20]
8000a6e6:	b8 88       	st.b	r12[0x0],r8
8000a6e8:	c1 38       	rjmp	8000a70e <_dtoa_r+0xb8a>
8000a6ea:	33 9a       	mov	r10,57
8000a6ec:	0a 98       	mov	r8,r5
8000a6ee:	11 79       	ld.ub	r9,--r8
8000a6f0:	f4 09 18 00 	cp.b	r9,r10
8000a6f4:	cf 00       	breq	8000a6d4 <_dtoa_r+0xb50>
8000a6f6:	2f f9       	sub	r9,-1
8000a6f8:	b0 89       	st.b	r8[0x0],r9
8000a6fa:	c0 98       	rjmp	8000a70c <_dtoa_r+0xb88>
8000a6fc:	10 95       	mov	r5,r8
8000a6fe:	c0 28       	rjmp	8000a702 <_dtoa_r+0xb7e>
8000a700:	33 09       	mov	r9,48
8000a702:	0a 98       	mov	r8,r5
8000a704:	11 7a       	ld.ub	r10,--r8
8000a706:	f2 0a 18 00 	cp.b	r10,r9
8000a70a:	cf 90       	breq	8000a6fc <_dtoa_r+0xb78>
8000a70c:	50 66       	stdsp	sp[0x18],r6
8000a70e:	04 9b       	mov	r11,r2
8000a710:	0e 9c       	mov	r12,r7
8000a712:	e0 a0 04 f7 	rcall	8000b100 <_Bfree>
8000a716:	58 04       	cp.w	r4,0
8000a718:	c1 20       	breq	8000a73c <_dtoa_r+0xbb8>
8000a71a:	40 4b       	lddsp	r11,sp[0x10]
8000a71c:	08 3b       	cp.w	r11,r4
8000a71e:	5f 19       	srne	r9
8000a720:	58 0b       	cp.w	r11,0
8000a722:	5f 18       	srne	r8
8000a724:	f3 e8 00 08 	and	r8,r9,r8
8000a728:	c0 40       	breq	8000a730 <_dtoa_r+0xbac>
8000a72a:	0e 9c       	mov	r12,r7
8000a72c:	e0 a0 04 ea 	rcall	8000b100 <_Bfree>
8000a730:	08 9b       	mov	r11,r4
8000a732:	0e 9c       	mov	r12,r7
8000a734:	e0 a0 04 e6 	rcall	8000b100 <_Bfree>
8000a738:	c0 28       	rjmp	8000a73c <_dtoa_r+0xbb8>
8000a73a:	50 66       	stdsp	sp[0x18],r6
8000a73c:	0e 9c       	mov	r12,r7
8000a73e:	06 9b       	mov	r11,r3
8000a740:	e0 a0 04 e0 	rcall	8000b100 <_Bfree>
8000a744:	30 08       	mov	r8,0
8000a746:	aa 88       	st.b	r5[0x0],r8
8000a748:	40 68       	lddsp	r8,sp[0x18]
8000a74a:	41 5a       	lddsp	r10,sp[0x54]
8000a74c:	2f f8       	sub	r8,-1
8000a74e:	41 29       	lddsp	r9,sp[0x48]
8000a750:	95 08       	st.w	r10[0x0],r8
8000a752:	40 8c       	lddsp	r12,sp[0x20]
8000a754:	58 09       	cp.w	r9,0
8000a756:	fb f8 10 12 	ld.wne	r8,sp[0x48]
8000a75a:	f1 f5 1a 00 	st.wne	r8[0x0],r5
8000a75e:	2e 6d       	sub	sp,-104
8000a760:	d8 32       	popm	r0-r7,pc
8000a762:	d7 03       	nop

8000a764 <__errno>:
8000a764:	e0 68 0a 3c 	mov	r8,2620
8000a768:	70 0c       	ld.w	r12,r8[0x0]
8000a76a:	2f 4c       	sub	r12,-12
8000a76c:	5e fc       	retal	r12
8000a76e:	d7 03       	nop

8000a770 <_fflush_r>:
8000a770:	d4 21       	pushm	r4-r7,lr
8000a772:	16 97       	mov	r7,r11
8000a774:	18 96       	mov	r6,r12
8000a776:	76 48       	ld.w	r8,r11[0x10]
8000a778:	58 08       	cp.w	r8,0
8000a77a:	c7 c0       	breq	8000a872 <_fflush_r+0x102>
8000a77c:	58 0c       	cp.w	r12,0
8000a77e:	c0 50       	breq	8000a788 <_fflush_r+0x18>
8000a780:	78 68       	ld.w	r8,r12[0x18]
8000a782:	58 08       	cp.w	r8,0
8000a784:	c0 21       	brne	8000a788 <_fflush_r+0x18>
8000a786:	cd 1c       	rcall	8000a928 <__sinit>
8000a788:	4b b8       	lddpc	r8,8000a874 <_fflush_r+0x104>
8000a78a:	10 37       	cp.w	r7,r8
8000a78c:	c0 31       	brne	8000a792 <_fflush_r+0x22>
8000a78e:	6c 07       	ld.w	r7,r6[0x0]
8000a790:	c0 a8       	rjmp	8000a7a4 <_fflush_r+0x34>
8000a792:	4b a8       	lddpc	r8,8000a878 <_fflush_r+0x108>
8000a794:	10 37       	cp.w	r7,r8
8000a796:	c0 31       	brne	8000a79c <_fflush_r+0x2c>
8000a798:	6c 17       	ld.w	r7,r6[0x4]
8000a79a:	c0 58       	rjmp	8000a7a4 <_fflush_r+0x34>
8000a79c:	4b 88       	lddpc	r8,8000a87c <_fflush_r+0x10c>
8000a79e:	10 37       	cp.w	r7,r8
8000a7a0:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000a7a4:	8e 6a       	ld.sh	r10,r7[0xc]
8000a7a6:	14 98       	mov	r8,r10
8000a7a8:	ed ba 00 03 	bld	r10,0x3
8000a7ac:	c4 20       	breq	8000a830 <_fflush_r+0xc0>
8000a7ae:	ab ba       	sbr	r10,0xb
8000a7b0:	ae 6a       	st.h	r7[0xc],r10
8000a7b2:	6e 18       	ld.w	r8,r7[0x4]
8000a7b4:	58 08       	cp.w	r8,0
8000a7b6:	e0 89 00 06 	brgt	8000a7c2 <_fflush_r+0x52>
8000a7ba:	6f 08       	ld.w	r8,r7[0x40]
8000a7bc:	58 08       	cp.w	r8,0
8000a7be:	e0 8a 00 5a 	brle	8000a872 <_fflush_r+0x102>
8000a7c2:	6e b8       	ld.w	r8,r7[0x2c]
8000a7c4:	58 08       	cp.w	r8,0
8000a7c6:	c5 60       	breq	8000a872 <_fflush_r+0x102>
8000a7c8:	e2 1a 10 00 	andl	r10,0x1000,COH
8000a7cc:	c0 30       	breq	8000a7d2 <_fflush_r+0x62>
8000a7ce:	6f 55       	ld.w	r5,r7[0x54]
8000a7d0:	c0 f8       	rjmp	8000a7ee <_fflush_r+0x7e>
8000a7d2:	30 19       	mov	r9,1
8000a7d4:	6e 8b       	ld.w	r11,r7[0x20]
8000a7d6:	0c 9c       	mov	r12,r6
8000a7d8:	5d 18       	icall	r8
8000a7da:	18 95       	mov	r5,r12
8000a7dc:	5b fc       	cp.w	r12,-1
8000a7de:	c0 81       	brne	8000a7ee <_fflush_r+0x7e>
8000a7e0:	6c 38       	ld.w	r8,r6[0xc]
8000a7e2:	59 d8       	cp.w	r8,29
8000a7e4:	c4 70       	breq	8000a872 <_fflush_r+0x102>
8000a7e6:	8e 68       	ld.sh	r8,r7[0xc]
8000a7e8:	a7 a8       	sbr	r8,0x6
8000a7ea:	ae 68       	st.h	r7[0xc],r8
8000a7ec:	d8 22       	popm	r4-r7,pc
8000a7ee:	8e 68       	ld.sh	r8,r7[0xc]
8000a7f0:	ed b8 00 02 	bld	r8,0x2
8000a7f4:	c0 91       	brne	8000a806 <_fflush_r+0x96>
8000a7f6:	6e 18       	ld.w	r8,r7[0x4]
8000a7f8:	10 15       	sub	r5,r8
8000a7fa:	6e d8       	ld.w	r8,r7[0x34]
8000a7fc:	58 08       	cp.w	r8,0
8000a7fe:	ef f8 10 10 	ld.wne	r8,r7[0x40]
8000a802:	eb d8 e1 15 	subne	r5,r5,r8
8000a806:	6e b8       	ld.w	r8,r7[0x2c]
8000a808:	0c 9c       	mov	r12,r6
8000a80a:	30 09       	mov	r9,0
8000a80c:	0a 9a       	mov	r10,r5
8000a80e:	6e 8b       	ld.w	r11,r7[0x20]
8000a810:	5d 18       	icall	r8
8000a812:	8e 68       	ld.sh	r8,r7[0xc]
8000a814:	0a 3c       	cp.w	r12,r5
8000a816:	c2 61       	brne	8000a862 <_fflush_r+0xf2>
8000a818:	ab d8       	cbr	r8,0xb
8000a81a:	30 0c       	mov	r12,0
8000a81c:	6e 49       	ld.w	r9,r7[0x10]
8000a81e:	ae 68       	st.h	r7[0xc],r8
8000a820:	8f 1c       	st.w	r7[0x4],r12
8000a822:	8f 09       	st.w	r7[0x0],r9
8000a824:	ed b8 00 0c 	bld	r8,0xc
8000a828:	c2 51       	brne	8000a872 <_fflush_r+0x102>
8000a82a:	ef 45 00 54 	st.w	r7[84],r5
8000a82e:	d8 22       	popm	r4-r7,pc
8000a830:	6e 45       	ld.w	r5,r7[0x10]
8000a832:	58 05       	cp.w	r5,0
8000a834:	c1 f0       	breq	8000a872 <_fflush_r+0x102>
8000a836:	6e 04       	ld.w	r4,r7[0x0]
8000a838:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
8000a83c:	8f 05       	st.w	r7[0x0],r5
8000a83e:	f9 b8 01 00 	movne	r8,0
8000a842:	ef f8 00 05 	ld.weq	r8,r7[0x14]
8000a846:	0a 14       	sub	r4,r5
8000a848:	8f 28       	st.w	r7[0x8],r8
8000a84a:	c1 18       	rjmp	8000a86c <_fflush_r+0xfc>
8000a84c:	08 99       	mov	r9,r4
8000a84e:	0a 9a       	mov	r10,r5
8000a850:	6e a8       	ld.w	r8,r7[0x28]
8000a852:	6e 8b       	ld.w	r11,r7[0x20]
8000a854:	0c 9c       	mov	r12,r6
8000a856:	5d 18       	icall	r8
8000a858:	18 14       	sub	r4,r12
8000a85a:	58 0c       	cp.w	r12,0
8000a85c:	e0 89 00 07 	brgt	8000a86a <_fflush_r+0xfa>
8000a860:	8e 68       	ld.sh	r8,r7[0xc]
8000a862:	a7 a8       	sbr	r8,0x6
8000a864:	3f fc       	mov	r12,-1
8000a866:	ae 68       	st.h	r7[0xc],r8
8000a868:	d8 22       	popm	r4-r7,pc
8000a86a:	18 05       	add	r5,r12
8000a86c:	58 04       	cp.w	r4,0
8000a86e:	fe 99 ff ef 	brgt	8000a84c <_fflush_r+0xdc>
8000a872:	d8 2a       	popm	r4-r7,pc,r12=0
8000a874:	80 01       	ld.sh	r1,r0[0x0]
8000a876:	5e e0       	retqs	r0
8000a878:	80 01       	ld.sh	r1,r0[0x0]
8000a87a:	5f 00       	sreq	r0
8000a87c:	80 01       	ld.sh	r1,r0[0x0]
8000a87e:	5f 20       	srhs	r0

8000a880 <__sfp_lock_acquire>:
8000a880:	5e fc       	retal	r12

8000a882 <__sfp_lock_release>:
8000a882:	5e fc       	retal	r12

8000a884 <_cleanup_r>:
8000a884:	d4 01       	pushm	lr
8000a886:	fe cb f0 ba 	sub	r11,pc,-3910
8000a88a:	e0 a0 02 f9 	rcall	8000ae7c <_fwalk>
8000a88e:	d8 02       	popm	pc

8000a890 <__sfmoreglue>:
8000a890:	d4 21       	pushm	r4-r7,lr
8000a892:	16 95       	mov	r5,r11
8000a894:	f6 06 10 5c 	mul	r6,r11,92
8000a898:	ec cb ff f4 	sub	r11,r6,-12
8000a89c:	fe b0 e2 4a 	rcall	80006d30 <_malloc_r>
8000a8a0:	18 97       	mov	r7,r12
8000a8a2:	c0 90       	breq	8000a8b4 <__sfmoreglue+0x24>
8000a8a4:	99 15       	st.w	r12[0x4],r5
8000a8a6:	30 0b       	mov	r11,0
8000a8a8:	2f 4c       	sub	r12,-12
8000a8aa:	0c 9a       	mov	r10,r6
8000a8ac:	8f 2c       	st.w	r7[0x8],r12
8000a8ae:	8f 0b       	st.w	r7[0x0],r11
8000a8b0:	fe b0 e5 13 	rcall	800072d6 <memset>
8000a8b4:	0e 9c       	mov	r12,r7
8000a8b6:	d8 22       	popm	r4-r7,pc

8000a8b8 <__sfp>:
8000a8b8:	d4 21       	pushm	r4-r7,lr
8000a8ba:	49 b8       	lddpc	r8,8000a924 <__sfp+0x6c>
8000a8bc:	18 96       	mov	r6,r12
8000a8be:	70 07       	ld.w	r7,r8[0x0]
8000a8c0:	6e 68       	ld.w	r8,r7[0x18]
8000a8c2:	58 08       	cp.w	r8,0
8000a8c4:	c0 31       	brne	8000a8ca <__sfp+0x12>
8000a8c6:	0e 9c       	mov	r12,r7
8000a8c8:	c3 0c       	rcall	8000a928 <__sinit>
8000a8ca:	ee c7 ff 28 	sub	r7,r7,-216
8000a8ce:	30 05       	mov	r5,0
8000a8d0:	6e 2c       	ld.w	r12,r7[0x8]
8000a8d2:	6e 18       	ld.w	r8,r7[0x4]
8000a8d4:	c0 68       	rjmp	8000a8e0 <__sfp+0x28>
8000a8d6:	98 69       	ld.sh	r9,r12[0xc]
8000a8d8:	ea 09 19 00 	cp.h	r9,r5
8000a8dc:	c1 10       	breq	8000a8fe <__sfp+0x46>
8000a8de:	2a 4c       	sub	r12,-92
8000a8e0:	20 18       	sub	r8,1
8000a8e2:	cf a7       	brpl	8000a8d6 <__sfp+0x1e>
8000a8e4:	6e 08       	ld.w	r8,r7[0x0]
8000a8e6:	58 08       	cp.w	r8,0
8000a8e8:	c0 61       	brne	8000a8f4 <__sfp+0x3c>
8000a8ea:	30 4b       	mov	r11,4
8000a8ec:	0c 9c       	mov	r12,r6
8000a8ee:	cd 1f       	rcall	8000a890 <__sfmoreglue>
8000a8f0:	8f 0c       	st.w	r7[0x0],r12
8000a8f2:	c0 30       	breq	8000a8f8 <__sfp+0x40>
8000a8f4:	6e 07       	ld.w	r7,r7[0x0]
8000a8f6:	ce db       	rjmp	8000a8d0 <__sfp+0x18>
8000a8f8:	30 c8       	mov	r8,12
8000a8fa:	8d 38       	st.w	r6[0xc],r8
8000a8fc:	d8 22       	popm	r4-r7,pc
8000a8fe:	30 08       	mov	r8,0
8000a900:	f9 48 00 4c 	st.w	r12[76],r8
8000a904:	99 08       	st.w	r12[0x0],r8
8000a906:	99 28       	st.w	r12[0x8],r8
8000a908:	99 18       	st.w	r12[0x4],r8
8000a90a:	99 48       	st.w	r12[0x10],r8
8000a90c:	99 58       	st.w	r12[0x14],r8
8000a90e:	99 68       	st.w	r12[0x18],r8
8000a910:	99 d8       	st.w	r12[0x34],r8
8000a912:	99 e8       	st.w	r12[0x38],r8
8000a914:	f9 48 00 48 	st.w	r12[72],r8
8000a918:	3f f8       	mov	r8,-1
8000a91a:	b8 78       	st.h	r12[0xe],r8
8000a91c:	30 18       	mov	r8,1
8000a91e:	b8 68       	st.h	r12[0xc],r8
8000a920:	d8 22       	popm	r4-r7,pc
8000a922:	d7 03       	nop
8000a924:	80 01       	ld.sh	r1,r0[0x0]
8000a926:	5f 44       	srge	r4

8000a928 <__sinit>:
8000a928:	d4 21       	pushm	r4-r7,lr
8000a92a:	18 96       	mov	r6,r12
8000a92c:	78 67       	ld.w	r7,r12[0x18]
8000a92e:	58 07       	cp.w	r7,0
8000a930:	c4 91       	brne	8000a9c2 <__sinit+0x9a>
8000a932:	fe c8 00 ae 	sub	r8,pc,174
8000a936:	30 15       	mov	r5,1
8000a938:	99 a8       	st.w	r12[0x28],r8
8000a93a:	f9 47 00 d8 	st.w	r12[216],r7
8000a93e:	f9 47 00 dc 	st.w	r12[220],r7
8000a942:	f9 47 00 e0 	st.w	r12[224],r7
8000a946:	99 65       	st.w	r12[0x18],r5
8000a948:	cb 8f       	rcall	8000a8b8 <__sfp>
8000a94a:	8d 0c       	st.w	r6[0x0],r12
8000a94c:	0c 9c       	mov	r12,r6
8000a94e:	cb 5f       	rcall	8000a8b8 <__sfp>
8000a950:	8d 1c       	st.w	r6[0x4],r12
8000a952:	0c 9c       	mov	r12,r6
8000a954:	cb 2f       	rcall	8000a8b8 <__sfp>
8000a956:	6c 09       	ld.w	r9,r6[0x0]
8000a958:	30 48       	mov	r8,4
8000a95a:	93 07       	st.w	r9[0x0],r7
8000a95c:	b2 68       	st.h	r9[0xc],r8
8000a95e:	93 17       	st.w	r9[0x4],r7
8000a960:	93 27       	st.w	r9[0x8],r7
8000a962:	6c 18       	ld.w	r8,r6[0x4]
8000a964:	b2 77       	st.h	r9[0xe],r7
8000a966:	93 47       	st.w	r9[0x10],r7
8000a968:	93 57       	st.w	r9[0x14],r7
8000a96a:	93 67       	st.w	r9[0x18],r7
8000a96c:	93 89       	st.w	r9[0x20],r9
8000a96e:	91 07       	st.w	r8[0x0],r7
8000a970:	91 17       	st.w	r8[0x4],r7
8000a972:	91 27       	st.w	r8[0x8],r7
8000a974:	fe ce f3 20 	sub	lr,pc,-3296
8000a978:	fe cb f3 50 	sub	r11,pc,-3248
8000a97c:	93 9e       	st.w	r9[0x24],lr
8000a97e:	93 ab       	st.w	r9[0x28],r11
8000a980:	fe ca f3 78 	sub	r10,pc,-3208
8000a984:	fe c4 f3 84 	sub	r4,pc,-3196
8000a988:	93 ba       	st.w	r9[0x2c],r10
8000a98a:	93 c4       	st.w	r9[0x30],r4
8000a98c:	30 99       	mov	r9,9
8000a98e:	b0 69       	st.h	r8[0xc],r9
8000a990:	b0 75       	st.h	r8[0xe],r5
8000a992:	91 c4       	st.w	r8[0x30],r4
8000a994:	91 47       	st.w	r8[0x10],r7
8000a996:	91 57       	st.w	r8[0x14],r7
8000a998:	91 67       	st.w	r8[0x18],r7
8000a99a:	91 88       	st.w	r8[0x20],r8
8000a99c:	91 9e       	st.w	r8[0x24],lr
8000a99e:	91 ab       	st.w	r8[0x28],r11
8000a9a0:	91 ba       	st.w	r8[0x2c],r10
8000a9a2:	8d 2c       	st.w	r6[0x8],r12
8000a9a4:	31 28       	mov	r8,18
8000a9a6:	99 07       	st.w	r12[0x0],r7
8000a9a8:	b8 68       	st.h	r12[0xc],r8
8000a9aa:	99 17       	st.w	r12[0x4],r7
8000a9ac:	99 27       	st.w	r12[0x8],r7
8000a9ae:	30 28       	mov	r8,2
8000a9b0:	b8 78       	st.h	r12[0xe],r8
8000a9b2:	99 c4       	st.w	r12[0x30],r4
8000a9b4:	99 67       	st.w	r12[0x18],r7
8000a9b6:	99 9e       	st.w	r12[0x24],lr
8000a9b8:	99 ab       	st.w	r12[0x28],r11
8000a9ba:	99 ba       	st.w	r12[0x2c],r10
8000a9bc:	99 47       	st.w	r12[0x10],r7
8000a9be:	99 57       	st.w	r12[0x14],r7
8000a9c0:	99 8c       	st.w	r12[0x20],r12
8000a9c2:	d8 22       	popm	r4-r7,pc

8000a9c4 <_malloc_trim_r>:
8000a9c4:	d4 21       	pushm	r4-r7,lr
8000a9c6:	16 95       	mov	r5,r11
8000a9c8:	18 97       	mov	r7,r12
8000a9ca:	fe b0 d7 31 	rcall	8000582c <__malloc_lock>
8000a9ce:	e0 64 05 3c 	mov	r4,1340
8000a9d2:	68 28       	ld.w	r8,r4[0x8]
8000a9d4:	70 16       	ld.w	r6,r8[0x4]
8000a9d6:	e0 16 ff fc 	andl	r6,0xfffc
8000a9da:	ec c8 ff 91 	sub	r8,r6,-111
8000a9de:	f0 05 01 05 	sub	r5,r8,r5
8000a9e2:	e0 15 ff 80 	andl	r5,0xff80
8000a9e6:	ea c5 00 80 	sub	r5,r5,128
8000a9ea:	e0 45 00 7f 	cp.w	r5,127
8000a9ee:	e0 8a 00 25 	brle	8000aa38 <_malloc_trim_r+0x74>
8000a9f2:	30 0b       	mov	r11,0
8000a9f4:	0e 9c       	mov	r12,r7
8000a9f6:	fe b0 e5 d7 	rcall	800075a4 <_sbrk_r>
8000a9fa:	68 28       	ld.w	r8,r4[0x8]
8000a9fc:	0c 08       	add	r8,r6
8000a9fe:	10 3c       	cp.w	r12,r8
8000aa00:	c1 c1       	brne	8000aa38 <_malloc_trim_r+0x74>
8000aa02:	ea 0b 11 00 	rsub	r11,r5,0
8000aa06:	0e 9c       	mov	r12,r7
8000aa08:	fe b0 e5 ce 	rcall	800075a4 <_sbrk_r>
8000aa0c:	5b fc       	cp.w	r12,-1
8000aa0e:	c1 91       	brne	8000aa40 <_malloc_trim_r+0x7c>
8000aa10:	30 0b       	mov	r11,0
8000aa12:	0e 9c       	mov	r12,r7
8000aa14:	fe b0 e5 c8 	rcall	800075a4 <_sbrk_r>
8000aa18:	68 28       	ld.w	r8,r4[0x8]
8000aa1a:	f8 08 01 09 	sub	r9,r12,r8
8000aa1e:	58 f9       	cp.w	r9,15
8000aa20:	e0 8a 00 0c 	brle	8000aa38 <_malloc_trim_r+0x74>
8000aa24:	a1 a9       	sbr	r9,0x0
8000aa26:	91 19       	st.w	r8[0x4],r9
8000aa28:	e0 68 09 48 	mov	r8,2376
8000aa2c:	70 09       	ld.w	r9,r8[0x0]
8000aa2e:	e0 68 0d 58 	mov	r8,3416
8000aa32:	f8 09 01 09 	sub	r9,r12,r9
8000aa36:	91 09       	st.w	r8[0x0],r9
8000aa38:	0e 9c       	mov	r12,r7
8000aa3a:	fe b0 d6 ff 	rcall	80005838 <__malloc_unlock>
8000aa3e:	d8 2a       	popm	r4-r7,pc,r12=0
8000aa40:	68 28       	ld.w	r8,r4[0x8]
8000aa42:	0a 16       	sub	r6,r5
8000aa44:	a1 a6       	sbr	r6,0x0
8000aa46:	91 16       	st.w	r8[0x4],r6
8000aa48:	e0 68 0d 58 	mov	r8,3416
8000aa4c:	70 09       	ld.w	r9,r8[0x0]
8000aa4e:	0a 19       	sub	r9,r5
8000aa50:	0e 9c       	mov	r12,r7
8000aa52:	91 09       	st.w	r8[0x0],r9
8000aa54:	fe b0 d6 f2 	rcall	80005838 <__malloc_unlock>
8000aa58:	da 2a       	popm	r4-r7,pc,r12=1
8000aa5a:	d7 03       	nop

8000aa5c <_free_r>:
8000aa5c:	d4 21       	pushm	r4-r7,lr
8000aa5e:	16 96       	mov	r6,r11
8000aa60:	18 97       	mov	r7,r12
8000aa62:	58 0b       	cp.w	r11,0
8000aa64:	e0 80 00 c0 	breq	8000abe4 <_free_r+0x188>
8000aa68:	fe b0 d6 e2 	rcall	8000582c <__malloc_lock>
8000aa6c:	20 86       	sub	r6,8
8000aa6e:	e0 6a 05 3c 	mov	r10,1340
8000aa72:	6c 18       	ld.w	r8,r6[0x4]
8000aa74:	74 2e       	ld.w	lr,r10[0x8]
8000aa76:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
8000aa7a:	a1 c8       	cbr	r8,0x0
8000aa7c:	ec 08 00 09 	add	r9,r6,r8
8000aa80:	72 1b       	ld.w	r11,r9[0x4]
8000aa82:	e0 1b ff fc 	andl	r11,0xfffc
8000aa86:	1c 39       	cp.w	r9,lr
8000aa88:	c1 e1       	brne	8000aac4 <_free_r+0x68>
8000aa8a:	f6 08 00 08 	add	r8,r11,r8
8000aa8e:	58 0c       	cp.w	r12,0
8000aa90:	c0 81       	brne	8000aaa0 <_free_r+0x44>
8000aa92:	6c 09       	ld.w	r9,r6[0x0]
8000aa94:	12 16       	sub	r6,r9
8000aa96:	12 08       	add	r8,r9
8000aa98:	6c 3b       	ld.w	r11,r6[0xc]
8000aa9a:	6c 29       	ld.w	r9,r6[0x8]
8000aa9c:	97 29       	st.w	r11[0x8],r9
8000aa9e:	93 3b       	st.w	r9[0xc],r11
8000aaa0:	10 99       	mov	r9,r8
8000aaa2:	95 26       	st.w	r10[0x8],r6
8000aaa4:	a1 a9       	sbr	r9,0x0
8000aaa6:	8d 19       	st.w	r6[0x4],r9
8000aaa8:	e0 69 09 44 	mov	r9,2372
8000aaac:	72 09       	ld.w	r9,r9[0x0]
8000aaae:	12 38       	cp.w	r8,r9
8000aab0:	c0 63       	brcs	8000aabc <_free_r+0x60>
8000aab2:	e0 68 0d 54 	mov	r8,3412
8000aab6:	0e 9c       	mov	r12,r7
8000aab8:	70 0b       	ld.w	r11,r8[0x0]
8000aaba:	c8 5f       	rcall	8000a9c4 <_malloc_trim_r>
8000aabc:	0e 9c       	mov	r12,r7
8000aabe:	fe b0 d6 bd 	rcall	80005838 <__malloc_unlock>
8000aac2:	d8 22       	popm	r4-r7,pc
8000aac4:	93 1b       	st.w	r9[0x4],r11
8000aac6:	58 0c       	cp.w	r12,0
8000aac8:	c0 30       	breq	8000aace <_free_r+0x72>
8000aaca:	30 0c       	mov	r12,0
8000aacc:	c1 08       	rjmp	8000aaec <_free_r+0x90>
8000aace:	6c 0e       	ld.w	lr,r6[0x0]
8000aad0:	f4 c5 ff f8 	sub	r5,r10,-8
8000aad4:	1c 16       	sub	r6,lr
8000aad6:	1c 08       	add	r8,lr
8000aad8:	6c 2e       	ld.w	lr,r6[0x8]
8000aada:	0a 3e       	cp.w	lr,r5
8000aadc:	f9 bc 00 01 	moveq	r12,1
8000aae0:	ed f5 10 03 	ld.wne	r5,r6[0xc]
8000aae4:	eb fe 1a 02 	st.wne	r5[0x8],lr
8000aae8:	fd f5 1a 03 	st.wne	lr[0xc],r5
8000aaec:	f2 0b 00 0e 	add	lr,r9,r11
8000aaf0:	7c 1e       	ld.w	lr,lr[0x4]
8000aaf2:	ed be 00 00 	bld	lr,0x0
8000aaf6:	c1 40       	breq	8000ab1e <_free_r+0xc2>
8000aaf8:	16 08       	add	r8,r11
8000aafa:	58 0c       	cp.w	r12,0
8000aafc:	c0 d1       	brne	8000ab16 <_free_r+0xba>
8000aafe:	e0 6e 05 3c 	mov	lr,1340
8000ab02:	72 2b       	ld.w	r11,r9[0x8]
8000ab04:	2f 8e       	sub	lr,-8
8000ab06:	1c 3b       	cp.w	r11,lr
8000ab08:	c0 71       	brne	8000ab16 <_free_r+0xba>
8000ab0a:	97 36       	st.w	r11[0xc],r6
8000ab0c:	97 26       	st.w	r11[0x8],r6
8000ab0e:	8d 2b       	st.w	r6[0x8],r11
8000ab10:	8d 3b       	st.w	r6[0xc],r11
8000ab12:	30 1c       	mov	r12,1
8000ab14:	c0 58       	rjmp	8000ab1e <_free_r+0xc2>
8000ab16:	72 2b       	ld.w	r11,r9[0x8]
8000ab18:	72 39       	ld.w	r9,r9[0xc]
8000ab1a:	93 2b       	st.w	r9[0x8],r11
8000ab1c:	97 39       	st.w	r11[0xc],r9
8000ab1e:	10 99       	mov	r9,r8
8000ab20:	ec 08 09 08 	st.w	r6[r8],r8
8000ab24:	a1 a9       	sbr	r9,0x0
8000ab26:	8d 19       	st.w	r6[0x4],r9
8000ab28:	58 0c       	cp.w	r12,0
8000ab2a:	c5 a1       	brne	8000abde <_free_r+0x182>
8000ab2c:	e0 48 01 ff 	cp.w	r8,511
8000ab30:	e0 8b 00 13 	brhi	8000ab56 <_free_r+0xfa>
8000ab34:	a3 98       	lsr	r8,0x3
8000ab36:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000ab3a:	72 2b       	ld.w	r11,r9[0x8]
8000ab3c:	8d 39       	st.w	r6[0xc],r9
8000ab3e:	8d 2b       	st.w	r6[0x8],r11
8000ab40:	97 36       	st.w	r11[0xc],r6
8000ab42:	93 26       	st.w	r9[0x8],r6
8000ab44:	a3 48       	asr	r8,0x2
8000ab46:	74 19       	ld.w	r9,r10[0x4]
8000ab48:	30 1b       	mov	r11,1
8000ab4a:	f6 08 09 48 	lsl	r8,r11,r8
8000ab4e:	f3 e8 10 08 	or	r8,r9,r8
8000ab52:	95 18       	st.w	r10[0x4],r8
8000ab54:	c4 58       	rjmp	8000abde <_free_r+0x182>
8000ab56:	f0 0b 16 09 	lsr	r11,r8,0x9
8000ab5a:	58 4b       	cp.w	r11,4
8000ab5c:	e0 8b 00 06 	brhi	8000ab68 <_free_r+0x10c>
8000ab60:	f0 0b 16 06 	lsr	r11,r8,0x6
8000ab64:	2c 8b       	sub	r11,-56
8000ab66:	c2 08       	rjmp	8000aba6 <_free_r+0x14a>
8000ab68:	59 4b       	cp.w	r11,20
8000ab6a:	e0 8b 00 04 	brhi	8000ab72 <_free_r+0x116>
8000ab6e:	2a 5b       	sub	r11,-91
8000ab70:	c1 b8       	rjmp	8000aba6 <_free_r+0x14a>
8000ab72:	e0 4b 00 54 	cp.w	r11,84
8000ab76:	e0 8b 00 06 	brhi	8000ab82 <_free_r+0x126>
8000ab7a:	f0 0b 16 0c 	lsr	r11,r8,0xc
8000ab7e:	29 2b       	sub	r11,-110
8000ab80:	c1 38       	rjmp	8000aba6 <_free_r+0x14a>
8000ab82:	e0 4b 01 54 	cp.w	r11,340
8000ab86:	e0 8b 00 06 	brhi	8000ab92 <_free_r+0x136>
8000ab8a:	f0 0b 16 0f 	lsr	r11,r8,0xf
8000ab8e:	28 9b       	sub	r11,-119
8000ab90:	c0 b8       	rjmp	8000aba6 <_free_r+0x14a>
8000ab92:	e0 4b 05 54 	cp.w	r11,1364
8000ab96:	e0 88 00 05 	brls	8000aba0 <_free_r+0x144>
8000ab9a:	37 eb       	mov	r11,126
8000ab9c:	c0 58       	rjmp	8000aba6 <_free_r+0x14a>
8000ab9e:	d7 03       	nop
8000aba0:	f0 0b 16 12 	lsr	r11,r8,0x12
8000aba4:	28 4b       	sub	r11,-124
8000aba6:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
8000abaa:	78 29       	ld.w	r9,r12[0x8]
8000abac:	18 39       	cp.w	r9,r12
8000abae:	c0 e1       	brne	8000abca <_free_r+0x16e>
8000abb0:	74 18       	ld.w	r8,r10[0x4]
8000abb2:	a3 4b       	asr	r11,0x2
8000abb4:	30 1c       	mov	r12,1
8000abb6:	f8 0b 09 4b 	lsl	r11,r12,r11
8000abba:	f1 eb 10 0b 	or	r11,r8,r11
8000abbe:	12 98       	mov	r8,r9
8000abc0:	95 1b       	st.w	r10[0x4],r11
8000abc2:	c0 a8       	rjmp	8000abd6 <_free_r+0x17a>
8000abc4:	72 29       	ld.w	r9,r9[0x8]
8000abc6:	18 39       	cp.w	r9,r12
8000abc8:	c0 60       	breq	8000abd4 <_free_r+0x178>
8000abca:	72 1a       	ld.w	r10,r9[0x4]
8000abcc:	e0 1a ff fc 	andl	r10,0xfffc
8000abd0:	14 38       	cp.w	r8,r10
8000abd2:	cf 93       	brcs	8000abc4 <_free_r+0x168>
8000abd4:	72 38       	ld.w	r8,r9[0xc]
8000abd6:	8d 38       	st.w	r6[0xc],r8
8000abd8:	8d 29       	st.w	r6[0x8],r9
8000abda:	93 36       	st.w	r9[0xc],r6
8000abdc:	91 26       	st.w	r8[0x8],r6
8000abde:	0e 9c       	mov	r12,r7
8000abe0:	fe b0 d6 2c 	rcall	80005838 <__malloc_unlock>
8000abe4:	d8 22       	popm	r4-r7,pc
8000abe6:	d7 03       	nop

8000abe8 <__sfvwrite_r>:
8000abe8:	d4 31       	pushm	r0-r7,lr
8000abea:	20 3d       	sub	sp,12
8000abec:	14 94       	mov	r4,r10
8000abee:	18 95       	mov	r5,r12
8000abf0:	16 97       	mov	r7,r11
8000abf2:	74 28       	ld.w	r8,r10[0x8]
8000abf4:	58 08       	cp.w	r8,0
8000abf6:	e0 80 01 40 	breq	8000ae76 <__sfvwrite_r+0x28e>
8000abfa:	96 68       	ld.sh	r8,r11[0xc]
8000abfc:	ed b8 00 03 	bld	r8,0x3
8000ac00:	c0 41       	brne	8000ac08 <__sfvwrite_r+0x20>
8000ac02:	76 48       	ld.w	r8,r11[0x10]
8000ac04:	58 08       	cp.w	r8,0
8000ac06:	c0 c1       	brne	8000ac1e <__sfvwrite_r+0x36>
8000ac08:	0e 9b       	mov	r11,r7
8000ac0a:	0a 9c       	mov	r12,r5
8000ac0c:	fe b0 f6 bc 	rcall	80009984 <__swsetup_r>
8000ac10:	c0 70       	breq	8000ac1e <__sfvwrite_r+0x36>
8000ac12:	8e 68       	ld.sh	r8,r7[0xc]
8000ac14:	a7 a8       	sbr	r8,0x6
8000ac16:	ae 68       	st.h	r7[0xc],r8
8000ac18:	30 98       	mov	r8,9
8000ac1a:	8b 38       	st.w	r5[0xc],r8
8000ac1c:	c2 b9       	rjmp	8000ae72 <__sfvwrite_r+0x28a>
8000ac1e:	8e 63       	ld.sh	r3,r7[0xc]
8000ac20:	68 00       	ld.w	r0,r4[0x0]
8000ac22:	06 96       	mov	r6,r3
8000ac24:	e2 16 00 02 	andl	r6,0x2,COH
8000ac28:	c2 10       	breq	8000ac6a <__sfvwrite_r+0x82>
8000ac2a:	30 03       	mov	r3,0
8000ac2c:	e0 62 04 00 	mov	r2,1024
8000ac30:	06 96       	mov	r6,r3
8000ac32:	c0 48       	rjmp	8000ac3a <__sfvwrite_r+0x52>
8000ac34:	60 03       	ld.w	r3,r0[0x0]
8000ac36:	60 16       	ld.w	r6,r0[0x4]
8000ac38:	2f 80       	sub	r0,-8
8000ac3a:	58 06       	cp.w	r6,0
8000ac3c:	cf c0       	breq	8000ac34 <__sfvwrite_r+0x4c>
8000ac3e:	e0 46 04 00 	cp.w	r6,1024
8000ac42:	ec 09 17 80 	movls	r9,r6
8000ac46:	e4 09 17 b0 	movhi	r9,r2
8000ac4a:	06 9a       	mov	r10,r3
8000ac4c:	6e a8       	ld.w	r8,r7[0x28]
8000ac4e:	6e 8b       	ld.w	r11,r7[0x20]
8000ac50:	0a 9c       	mov	r12,r5
8000ac52:	5d 18       	icall	r8
8000ac54:	18 16       	sub	r6,r12
8000ac56:	58 0c       	cp.w	r12,0
8000ac58:	e0 8a 01 0a 	brle	8000ae6c <__sfvwrite_r+0x284>
8000ac5c:	68 28       	ld.w	r8,r4[0x8]
8000ac5e:	18 18       	sub	r8,r12
8000ac60:	89 28       	st.w	r4[0x8],r8
8000ac62:	e0 80 01 0a 	breq	8000ae76 <__sfvwrite_r+0x28e>
8000ac66:	18 03       	add	r3,r12
8000ac68:	ce 9b       	rjmp	8000ac3a <__sfvwrite_r+0x52>
8000ac6a:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
8000ac6e:	c0 70       	breq	8000ac7c <__sfvwrite_r+0x94>
8000ac70:	50 06       	stdsp	sp[0x0],r6
8000ac72:	0c 93       	mov	r3,r6
8000ac74:	0c 91       	mov	r1,r6
8000ac76:	50 15       	stdsp	sp[0x4],r5
8000ac78:	08 92       	mov	r2,r4
8000ac7a:	c9 c8       	rjmp	8000adb2 <__sfvwrite_r+0x1ca>
8000ac7c:	06 96       	mov	r6,r3
8000ac7e:	08 91       	mov	r1,r4
8000ac80:	c0 48       	rjmp	8000ac88 <__sfvwrite_r+0xa0>
8000ac82:	60 03       	ld.w	r3,r0[0x0]
8000ac84:	60 16       	ld.w	r6,r0[0x4]
8000ac86:	2f 80       	sub	r0,-8
8000ac88:	58 06       	cp.w	r6,0
8000ac8a:	cf c0       	breq	8000ac82 <__sfvwrite_r+0x9a>
8000ac8c:	8e 68       	ld.sh	r8,r7[0xc]
8000ac8e:	6e 24       	ld.w	r4,r7[0x8]
8000ac90:	10 99       	mov	r9,r8
8000ac92:	e2 19 02 00 	andl	r9,0x200,COH
8000ac96:	c5 50       	breq	8000ad40 <__sfvwrite_r+0x158>
8000ac98:	08 36       	cp.w	r6,r4
8000ac9a:	c4 43       	brcs	8000ad22 <__sfvwrite_r+0x13a>
8000ac9c:	10 99       	mov	r9,r8
8000ac9e:	e2 19 04 80 	andl	r9,0x480,COH
8000aca2:	c4 00       	breq	8000ad22 <__sfvwrite_r+0x13a>
8000aca4:	6e 4b       	ld.w	r11,r7[0x10]
8000aca6:	6e 09       	ld.w	r9,r7[0x0]
8000aca8:	16 19       	sub	r9,r11
8000acaa:	50 09       	stdsp	sp[0x0],r9
8000acac:	6e 59       	ld.w	r9,r7[0x14]
8000acae:	10 9c       	mov	r12,r8
8000acb0:	f2 09 00 1a 	add	r10,r9,r9<<0x1
8000acb4:	30 28       	mov	r8,2
8000acb6:	f4 08 0c 08 	divs	r8,r10,r8
8000acba:	fa e9 00 04 	st.d	sp[4],r8
8000acbe:	10 94       	mov	r4,r8
8000acc0:	40 09       	lddsp	r9,sp[0x0]
8000acc2:	e2 1c 04 00 	andl	r12,0x400,COH
8000acc6:	2f f9       	sub	r9,-1
8000acc8:	0c 09       	add	r9,r6
8000acca:	12 38       	cp.w	r8,r9
8000accc:	f2 04 17 30 	movlo	r4,r9
8000acd0:	58 0c       	cp.w	r12,0
8000acd2:	c1 10       	breq	8000acf4 <__sfvwrite_r+0x10c>
8000acd4:	08 9b       	mov	r11,r4
8000acd6:	0a 9c       	mov	r12,r5
8000acd8:	fe b0 e0 2c 	rcall	80006d30 <_malloc_r>
8000acdc:	18 92       	mov	r2,r12
8000acde:	c1 40       	breq	8000ad06 <__sfvwrite_r+0x11e>
8000ace0:	40 0a       	lddsp	r10,sp[0x0]
8000ace2:	6e 4b       	ld.w	r11,r7[0x10]
8000ace4:	fe b0 e2 55 	rcall	8000718e <memcpy>
8000ace8:	8e 68       	ld.sh	r8,r7[0xc]
8000acea:	e0 18 fb 7f 	andl	r8,0xfb7f
8000acee:	a7 b8       	sbr	r8,0x7
8000acf0:	ae 68       	st.h	r7[0xc],r8
8000acf2:	c0 d8       	rjmp	8000ad0c <__sfvwrite_r+0x124>
8000acf4:	08 9a       	mov	r10,r4
8000acf6:	0a 9c       	mov	r12,r5
8000acf8:	fe b0 e2 f6 	rcall	800072e4 <_realloc_r>
8000acfc:	18 92       	mov	r2,r12
8000acfe:	c0 71       	brne	8000ad0c <__sfvwrite_r+0x124>
8000ad00:	6e 4b       	ld.w	r11,r7[0x10]
8000ad02:	0a 9c       	mov	r12,r5
8000ad04:	ca ce       	rcall	8000aa5c <_free_r>
8000ad06:	30 c8       	mov	r8,12
8000ad08:	8b 38       	st.w	r5[0xc],r8
8000ad0a:	cb 18       	rjmp	8000ae6c <__sfvwrite_r+0x284>
8000ad0c:	40 0a       	lddsp	r10,sp[0x0]
8000ad0e:	40 09       	lddsp	r9,sp[0x0]
8000ad10:	e8 0a 01 0a 	sub	r10,r4,r10
8000ad14:	e4 09 00 08 	add	r8,r2,r9
8000ad18:	8f 54       	st.w	r7[0x14],r4
8000ad1a:	8f 2a       	st.w	r7[0x8],r10
8000ad1c:	8f 08       	st.w	r7[0x0],r8
8000ad1e:	8f 42       	st.w	r7[0x10],r2
8000ad20:	0c 94       	mov	r4,r6
8000ad22:	08 36       	cp.w	r6,r4
8000ad24:	ec 04 17 30 	movlo	r4,r6
8000ad28:	06 9b       	mov	r11,r3
8000ad2a:	08 9a       	mov	r10,r4
8000ad2c:	6e 0c       	ld.w	r12,r7[0x0]
8000ad2e:	c3 ad       	rcall	8000afa2 <memmove>
8000ad30:	6e 08       	ld.w	r8,r7[0x0]
8000ad32:	08 08       	add	r8,r4
8000ad34:	8f 08       	st.w	r7[0x0],r8
8000ad36:	6e 28       	ld.w	r8,r7[0x8]
8000ad38:	08 18       	sub	r8,r4
8000ad3a:	0c 94       	mov	r4,r6
8000ad3c:	8f 28       	st.w	r7[0x8],r8
8000ad3e:	c2 e8       	rjmp	8000ad9a <__sfvwrite_r+0x1b2>
8000ad40:	08 36       	cp.w	r6,r4
8000ad42:	5f ba       	srhi	r10
8000ad44:	6e 0c       	ld.w	r12,r7[0x0]
8000ad46:	6e 48       	ld.w	r8,r7[0x10]
8000ad48:	10 3c       	cp.w	r12,r8
8000ad4a:	5f b8       	srhi	r8
8000ad4c:	f5 e8 00 08 	and	r8,r10,r8
8000ad50:	f2 08 18 00 	cp.b	r8,r9
8000ad54:	c0 d0       	breq	8000ad6e <__sfvwrite_r+0x186>
8000ad56:	06 9b       	mov	r11,r3
8000ad58:	08 9a       	mov	r10,r4
8000ad5a:	c2 4d       	rcall	8000afa2 <memmove>
8000ad5c:	6e 08       	ld.w	r8,r7[0x0]
8000ad5e:	08 08       	add	r8,r4
8000ad60:	0e 9b       	mov	r11,r7
8000ad62:	8f 08       	st.w	r7[0x0],r8
8000ad64:	0a 9c       	mov	r12,r5
8000ad66:	fe b0 fd 05 	rcall	8000a770 <_fflush_r>
8000ad6a:	c1 80       	breq	8000ad9a <__sfvwrite_r+0x1b2>
8000ad6c:	c8 08       	rjmp	8000ae6c <__sfvwrite_r+0x284>
8000ad6e:	6e 59       	ld.w	r9,r7[0x14]
8000ad70:	12 36       	cp.w	r6,r9
8000ad72:	c0 a3       	brcs	8000ad86 <__sfvwrite_r+0x19e>
8000ad74:	6e a8       	ld.w	r8,r7[0x28]
8000ad76:	06 9a       	mov	r10,r3
8000ad78:	6e 8b       	ld.w	r11,r7[0x20]
8000ad7a:	0a 9c       	mov	r12,r5
8000ad7c:	5d 18       	icall	r8
8000ad7e:	18 94       	mov	r4,r12
8000ad80:	e0 89 00 0d 	brgt	8000ad9a <__sfvwrite_r+0x1b2>
8000ad84:	c7 48       	rjmp	8000ae6c <__sfvwrite_r+0x284>
8000ad86:	0c 9a       	mov	r10,r6
8000ad88:	06 9b       	mov	r11,r3
8000ad8a:	c0 cd       	rcall	8000afa2 <memmove>
8000ad8c:	6e 08       	ld.w	r8,r7[0x0]
8000ad8e:	0c 08       	add	r8,r6
8000ad90:	0c 94       	mov	r4,r6
8000ad92:	8f 08       	st.w	r7[0x0],r8
8000ad94:	6e 28       	ld.w	r8,r7[0x8]
8000ad96:	0c 18       	sub	r8,r6
8000ad98:	8f 28       	st.w	r7[0x8],r8
8000ad9a:	62 28       	ld.w	r8,r1[0x8]
8000ad9c:	08 18       	sub	r8,r4
8000ad9e:	83 28       	st.w	r1[0x8],r8
8000ada0:	c6 b0       	breq	8000ae76 <__sfvwrite_r+0x28e>
8000ada2:	08 16       	sub	r6,r4
8000ada4:	08 03       	add	r3,r4
8000ada6:	c7 1b       	rjmp	8000ac88 <__sfvwrite_r+0xa0>
8000ada8:	60 03       	ld.w	r3,r0[0x0]
8000adaa:	60 11       	ld.w	r1,r0[0x4]
8000adac:	30 08       	mov	r8,0
8000adae:	2f 80       	sub	r0,-8
8000adb0:	50 08       	stdsp	sp[0x0],r8
8000adb2:	58 01       	cp.w	r1,0
8000adb4:	cf a0       	breq	8000ada8 <__sfvwrite_r+0x1c0>
8000adb6:	40 0a       	lddsp	r10,sp[0x0]
8000adb8:	58 0a       	cp.w	r10,0
8000adba:	c1 41       	brne	8000ade2 <__sfvwrite_r+0x1fa>
8000adbc:	e2 c6 ff ff 	sub	r6,r1,-1
8000adc0:	02 9a       	mov	r10,r1
8000adc2:	30 ab       	mov	r11,10
8000adc4:	06 9c       	mov	r12,r3
8000adc6:	ce 3c       	rcall	8000af8c <memchr>
8000adc8:	f8 c8 ff ff 	sub	r8,r12,-1
8000adcc:	58 0c       	cp.w	r12,0
8000adce:	f1 d3 e1 16 	subne	r6,r8,r3
8000add2:	f9 b9 01 01 	movne	r9,1
8000add6:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000adda:	f9 b8 00 01 	moveq	r8,1
8000adde:	fb f8 0a 00 	st.weq	sp[0x0],r8
8000ade2:	02 36       	cp.w	r6,r1
8000ade4:	ec 04 17 80 	movls	r4,r6
8000ade8:	e2 04 17 b0 	movhi	r4,r1
8000adec:	6e 59       	ld.w	r9,r7[0x14]
8000adee:	6e 25       	ld.w	r5,r7[0x8]
8000adf0:	f2 05 00 05 	add	r5,r9,r5
8000adf4:	0a 34       	cp.w	r4,r5
8000adf6:	5f 9a       	srgt	r10
8000adf8:	6e 0c       	ld.w	r12,r7[0x0]
8000adfa:	6e 48       	ld.w	r8,r7[0x10]
8000adfc:	10 3c       	cp.w	r12,r8
8000adfe:	5f b8       	srhi	r8
8000ae00:	f5 e8 00 08 	and	r8,r10,r8
8000ae04:	30 0a       	mov	r10,0
8000ae06:	f4 08 18 00 	cp.b	r8,r10
8000ae0a:	c0 d0       	breq	8000ae24 <__sfvwrite_r+0x23c>
8000ae0c:	06 9b       	mov	r11,r3
8000ae0e:	0a 9a       	mov	r10,r5
8000ae10:	cc 9c       	rcall	8000afa2 <memmove>
8000ae12:	6e 08       	ld.w	r8,r7[0x0]
8000ae14:	0a 08       	add	r8,r5
8000ae16:	0e 9b       	mov	r11,r7
8000ae18:	8f 08       	st.w	r7[0x0],r8
8000ae1a:	40 1c       	lddsp	r12,sp[0x4]
8000ae1c:	fe b0 fc aa 	rcall	8000a770 <_fflush_r>
8000ae20:	c1 70       	breq	8000ae4e <__sfvwrite_r+0x266>
8000ae22:	c2 58       	rjmp	8000ae6c <__sfvwrite_r+0x284>
8000ae24:	12 34       	cp.w	r4,r9
8000ae26:	c0 a5       	brlt	8000ae3a <__sfvwrite_r+0x252>
8000ae28:	6e a8       	ld.w	r8,r7[0x28]
8000ae2a:	06 9a       	mov	r10,r3
8000ae2c:	6e 8b       	ld.w	r11,r7[0x20]
8000ae2e:	40 1c       	lddsp	r12,sp[0x4]
8000ae30:	5d 18       	icall	r8
8000ae32:	18 95       	mov	r5,r12
8000ae34:	e0 89 00 0d 	brgt	8000ae4e <__sfvwrite_r+0x266>
8000ae38:	c1 a8       	rjmp	8000ae6c <__sfvwrite_r+0x284>
8000ae3a:	08 9a       	mov	r10,r4
8000ae3c:	06 9b       	mov	r11,r3
8000ae3e:	cb 2c       	rcall	8000afa2 <memmove>
8000ae40:	6e 08       	ld.w	r8,r7[0x0]
8000ae42:	08 08       	add	r8,r4
8000ae44:	08 95       	mov	r5,r4
8000ae46:	8f 08       	st.w	r7[0x0],r8
8000ae48:	6e 28       	ld.w	r8,r7[0x8]
8000ae4a:	08 18       	sub	r8,r4
8000ae4c:	8f 28       	st.w	r7[0x8],r8
8000ae4e:	0a 16       	sub	r6,r5
8000ae50:	c0 71       	brne	8000ae5e <__sfvwrite_r+0x276>
8000ae52:	0e 9b       	mov	r11,r7
8000ae54:	40 1c       	lddsp	r12,sp[0x4]
8000ae56:	fe b0 fc 8d 	rcall	8000a770 <_fflush_r>
8000ae5a:	c0 91       	brne	8000ae6c <__sfvwrite_r+0x284>
8000ae5c:	50 06       	stdsp	sp[0x0],r6
8000ae5e:	64 28       	ld.w	r8,r2[0x8]
8000ae60:	0a 18       	sub	r8,r5
8000ae62:	85 28       	st.w	r2[0x8],r8
8000ae64:	c0 90       	breq	8000ae76 <__sfvwrite_r+0x28e>
8000ae66:	0a 11       	sub	r1,r5
8000ae68:	0a 03       	add	r3,r5
8000ae6a:	ca 4b       	rjmp	8000adb2 <__sfvwrite_r+0x1ca>
8000ae6c:	8e 68       	ld.sh	r8,r7[0xc]
8000ae6e:	a7 a8       	sbr	r8,0x6
8000ae70:	ae 68       	st.h	r7[0xc],r8
8000ae72:	3f fc       	mov	r12,-1
8000ae74:	c0 28       	rjmp	8000ae78 <__sfvwrite_r+0x290>
8000ae76:	30 0c       	mov	r12,0
8000ae78:	2f dd       	sub	sp,-12
8000ae7a:	d8 32       	popm	r0-r7,pc

8000ae7c <_fwalk>:
8000ae7c:	d4 31       	pushm	r0-r7,lr
8000ae7e:	30 05       	mov	r5,0
8000ae80:	16 91       	mov	r1,r11
8000ae82:	f8 c7 ff 28 	sub	r7,r12,-216
8000ae86:	0a 92       	mov	r2,r5
8000ae88:	fe b0 fc fc 	rcall	8000a880 <__sfp_lock_acquire>
8000ae8c:	3f f3       	mov	r3,-1
8000ae8e:	c1 68       	rjmp	8000aeba <_fwalk+0x3e>
8000ae90:	6e 26       	ld.w	r6,r7[0x8]
8000ae92:	6e 14       	ld.w	r4,r7[0x4]
8000ae94:	2f 46       	sub	r6,-12
8000ae96:	c0 c8       	rjmp	8000aeae <_fwalk+0x32>
8000ae98:	8c 08       	ld.sh	r8,r6[0x0]
8000ae9a:	e4 08 19 00 	cp.h	r8,r2
8000ae9e:	c0 70       	breq	8000aeac <_fwalk+0x30>
8000aea0:	8c 18       	ld.sh	r8,r6[0x2]
8000aea2:	e6 08 19 00 	cp.h	r8,r3
8000aea6:	c0 30       	breq	8000aeac <_fwalk+0x30>
8000aea8:	5d 11       	icall	r1
8000aeaa:	18 45       	or	r5,r12
8000aeac:	2a 46       	sub	r6,-92
8000aeae:	20 14       	sub	r4,1
8000aeb0:	ec cc 00 0c 	sub	r12,r6,12
8000aeb4:	58 04       	cp.w	r4,0
8000aeb6:	cf 14       	brge	8000ae98 <_fwalk+0x1c>
8000aeb8:	6e 07       	ld.w	r7,r7[0x0]
8000aeba:	58 07       	cp.w	r7,0
8000aebc:	ce a1       	brne	8000ae90 <_fwalk+0x14>
8000aebe:	fe b0 fc e2 	rcall	8000a882 <__sfp_lock_release>
8000aec2:	0a 9c       	mov	r12,r5
8000aec4:	d8 32       	popm	r0-r7,pc
8000aec6:	d7 03       	nop

8000aec8 <_localeconv_r>:
8000aec8:	48 1c       	lddpc	r12,8000aecc <_localeconv_r+0x4>
8000aeca:	5e fc       	retal	r12
8000aecc:	80 01       	ld.sh	r1,r0[0x0]
8000aece:	5f 48       	srge	r8

8000aed0 <__smakebuf_r>:
8000aed0:	d4 21       	pushm	r4-r7,lr
8000aed2:	20 fd       	sub	sp,60
8000aed4:	96 68       	ld.sh	r8,r11[0xc]
8000aed6:	16 97       	mov	r7,r11
8000aed8:	18 96       	mov	r6,r12
8000aeda:	e2 18 00 02 	andl	r8,0x2,COH
8000aede:	c3 d1       	brne	8000af58 <__smakebuf_r+0x88>
8000aee0:	96 7b       	ld.sh	r11,r11[0xe]
8000aee2:	f0 0b 19 00 	cp.h	r11,r8
8000aee6:	c0 55       	brlt	8000aef0 <__smakebuf_r+0x20>
8000aee8:	1a 9a       	mov	r10,sp
8000aeea:	e0 a0 04 79 	rcall	8000b7dc <_fstat_r>
8000aeee:	c0 f4       	brge	8000af0c <__smakebuf_r+0x3c>
8000aef0:	8e 65       	ld.sh	r5,r7[0xc]
8000aef2:	0a 98       	mov	r8,r5
8000aef4:	ab b8       	sbr	r8,0xb
8000aef6:	e2 15 00 80 	andl	r5,0x80,COH
8000aefa:	ae 68       	st.h	r7[0xc],r8
8000aefc:	30 04       	mov	r4,0
8000aefe:	e0 68 04 00 	mov	r8,1024
8000af02:	f9 b5 01 40 	movne	r5,64
8000af06:	f0 05 17 00 	moveq	r5,r8
8000af0a:	c1 c8       	rjmp	8000af42 <__smakebuf_r+0x72>
8000af0c:	40 18       	lddsp	r8,sp[0x4]
8000af0e:	e2 18 f0 00 	andl	r8,0xf000,COH
8000af12:	e0 48 20 00 	cp.w	r8,8192
8000af16:	5f 04       	sreq	r4
8000af18:	e0 48 80 00 	cp.w	r8,32768
8000af1c:	c0 e1       	brne	8000af38 <__smakebuf_r+0x68>
8000af1e:	6e b9       	ld.w	r9,r7[0x2c]
8000af20:	fe c8 f9 18 	sub	r8,pc,-1768
8000af24:	10 39       	cp.w	r9,r8
8000af26:	c0 91       	brne	8000af38 <__smakebuf_r+0x68>
8000af28:	8e 68       	ld.sh	r8,r7[0xc]
8000af2a:	e0 65 04 00 	mov	r5,1024
8000af2e:	ab a8       	sbr	r8,0xa
8000af30:	ef 45 00 50 	st.w	r7[80],r5
8000af34:	ae 68       	st.h	r7[0xc],r8
8000af36:	c0 68       	rjmp	8000af42 <__smakebuf_r+0x72>
8000af38:	8e 68       	ld.sh	r8,r7[0xc]
8000af3a:	e0 65 04 00 	mov	r5,1024
8000af3e:	ab b8       	sbr	r8,0xb
8000af40:	ae 68       	st.h	r7[0xc],r8
8000af42:	0a 9b       	mov	r11,r5
8000af44:	0c 9c       	mov	r12,r6
8000af46:	fe b0 de f5 	rcall	80006d30 <_malloc_r>
8000af4a:	8e 68       	ld.sh	r8,r7[0xc]
8000af4c:	c0 d1       	brne	8000af66 <__smakebuf_r+0x96>
8000af4e:	ed b8 00 09 	bld	r8,0x9
8000af52:	c1 b0       	breq	8000af88 <__smakebuf_r+0xb8>
8000af54:	a1 b8       	sbr	r8,0x1
8000af56:	ae 68       	st.h	r7[0xc],r8
8000af58:	ee c8 ff b9 	sub	r8,r7,-71
8000af5c:	8f 48       	st.w	r7[0x10],r8
8000af5e:	8f 08       	st.w	r7[0x0],r8
8000af60:	30 18       	mov	r8,1
8000af62:	8f 58       	st.w	r7[0x14],r8
8000af64:	c1 28       	rjmp	8000af88 <__smakebuf_r+0xb8>
8000af66:	a7 b8       	sbr	r8,0x7
8000af68:	8f 4c       	st.w	r7[0x10],r12
8000af6a:	ae 68       	st.h	r7[0xc],r8
8000af6c:	8f 55       	st.w	r7[0x14],r5
8000af6e:	fe c8 06 ea 	sub	r8,pc,1770
8000af72:	8f 0c       	st.w	r7[0x0],r12
8000af74:	8d a8       	st.w	r6[0x28],r8
8000af76:	58 04       	cp.w	r4,0
8000af78:	c0 80       	breq	8000af88 <__smakebuf_r+0xb8>
8000af7a:	8e 7c       	ld.sh	r12,r7[0xe]
8000af7c:	fe b0 e3 7a 	rcall	80007670 <isatty>
8000af80:	c0 40       	breq	8000af88 <__smakebuf_r+0xb8>
8000af82:	8e 68       	ld.sh	r8,r7[0xc]
8000af84:	a1 a8       	sbr	r8,0x0
8000af86:	ae 68       	st.h	r7[0xc],r8
8000af88:	2f 1d       	sub	sp,-60
8000af8a:	d8 22       	popm	r4-r7,pc

8000af8c <memchr>:
8000af8c:	f7 db c0 08 	bfextu	r11,r11,0x0,0x8
8000af90:	c0 68       	rjmp	8000af9c <memchr+0x10>
8000af92:	20 1a       	sub	r10,1
8000af94:	19 88       	ld.ub	r8,r12[0x0]
8000af96:	16 38       	cp.w	r8,r11
8000af98:	5e 0c       	reteq	r12
8000af9a:	2f fc       	sub	r12,-1
8000af9c:	58 0a       	cp.w	r10,0
8000af9e:	cf a1       	brne	8000af92 <memchr+0x6>
8000afa0:	5e fa       	retal	r10

8000afa2 <memmove>:
8000afa2:	d4 01       	pushm	lr
8000afa4:	18 3b       	cp.w	r11,r12
8000afa6:	c1 92       	brcc	8000afd8 <memmove+0x36>
8000afa8:	f6 0a 00 09 	add	r9,r11,r10
8000afac:	12 3c       	cp.w	r12,r9
8000afae:	c1 52       	brcc	8000afd8 <memmove+0x36>
8000afb0:	f8 0a 00 0b 	add	r11,r12,r10
8000afb4:	30 08       	mov	r8,0
8000afb6:	c0 68       	rjmp	8000afc2 <memmove+0x20>
8000afb8:	f2 08 07 0e 	ld.ub	lr,r9[r8]
8000afbc:	20 1a       	sub	r10,1
8000afbe:	f6 08 0b 0e 	st.b	r11[r8],lr
8000afc2:	20 18       	sub	r8,1
8000afc4:	58 0a       	cp.w	r10,0
8000afc6:	cf 91       	brne	8000afb8 <memmove+0x16>
8000afc8:	d8 02       	popm	pc
8000afca:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000afce:	20 1a       	sub	r10,1
8000afd0:	f8 08 0b 09 	st.b	r12[r8],r9
8000afd4:	2f f8       	sub	r8,-1
8000afd6:	c0 28       	rjmp	8000afda <memmove+0x38>
8000afd8:	30 08       	mov	r8,0
8000afda:	58 0a       	cp.w	r10,0
8000afdc:	cf 71       	brne	8000afca <memmove+0x28>
8000afde:	d8 02       	popm	pc

8000afe0 <__hi0bits>:
8000afe0:	18 98       	mov	r8,r12
8000afe2:	e0 1c 00 00 	andl	r12,0x0
8000afe6:	f0 09 15 10 	lsl	r9,r8,0x10
8000afea:	58 0c       	cp.w	r12,0
8000afec:	f2 08 17 00 	moveq	r8,r9
8000aff0:	f9 bc 00 10 	moveq	r12,16
8000aff4:	f9 bc 01 00 	movne	r12,0
8000aff8:	10 9a       	mov	r10,r8
8000affa:	f0 09 15 08 	lsl	r9,r8,0x8
8000affe:	e6 1a ff 00 	andh	r10,0xff00,COH
8000b002:	f7 bc 00 f8 	subeq	r12,-8
8000b006:	f2 08 17 00 	moveq	r8,r9
8000b00a:	10 9a       	mov	r10,r8
8000b00c:	f0 09 15 04 	lsl	r9,r8,0x4
8000b010:	e6 1a f0 00 	andh	r10,0xf000,COH
8000b014:	f7 bc 00 fc 	subeq	r12,-4
8000b018:	f2 08 17 00 	moveq	r8,r9
8000b01c:	10 9a       	mov	r10,r8
8000b01e:	f0 09 15 02 	lsl	r9,r8,0x2
8000b022:	e6 1a c0 00 	andh	r10,0xc000,COH
8000b026:	f7 bc 00 fe 	subeq	r12,-2
8000b02a:	f2 08 17 00 	moveq	r8,r9
8000b02e:	58 08       	cp.w	r8,0
8000b030:	5e 5c       	retlt	r12
8000b032:	ed b8 00 1e 	bld	r8,0x1e
8000b036:	f9 bc 01 20 	movne	r12,32
8000b03a:	f7 bc 00 ff 	subeq	r12,-1
8000b03e:	5e fc       	retal	r12

8000b040 <__lo0bits>:
8000b040:	18 99       	mov	r9,r12
8000b042:	78 08       	ld.w	r8,r12[0x0]
8000b044:	f9 d8 c0 03 	bfextu	r12,r8,0x0,0x3
8000b048:	c1 50       	breq	8000b072 <__lo0bits+0x32>
8000b04a:	ed b8 00 00 	bld	r8,0x0
8000b04e:	c0 21       	brne	8000b052 <__lo0bits+0x12>
8000b050:	5e fd       	retal	0
8000b052:	10 9b       	mov	r11,r8
8000b054:	f0 0a 16 01 	lsr	r10,r8,0x1
8000b058:	e2 1b 00 02 	andl	r11,0x2,COH
8000b05c:	a3 88       	lsr	r8,0x2
8000b05e:	58 0b       	cp.w	r11,0
8000b060:	f3 fa 1a 00 	st.wne	r9[0x0],r10
8000b064:	f9 bc 01 01 	movne	r12,1
8000b068:	f3 f8 0a 00 	st.weq	r9[0x0],r8
8000b06c:	f9 bc 00 02 	moveq	r12,2
8000b070:	5e fc       	retal	r12
8000b072:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8000b076:	f0 0b 16 10 	lsr	r11,r8,0x10
8000b07a:	58 0a       	cp.w	r10,0
8000b07c:	f6 08 17 00 	moveq	r8,r11
8000b080:	f9 bc 00 10 	moveq	r12,16
8000b084:	f7 d8 c0 08 	bfextu	r11,r8,0x0,0x8
8000b088:	f0 0a 16 08 	lsr	r10,r8,0x8
8000b08c:	58 0b       	cp.w	r11,0
8000b08e:	f7 bc 00 f8 	subeq	r12,-8
8000b092:	f4 08 17 00 	moveq	r8,r10
8000b096:	f7 d8 c0 04 	bfextu	r11,r8,0x0,0x4
8000b09a:	f0 0a 16 04 	lsr	r10,r8,0x4
8000b09e:	58 0b       	cp.w	r11,0
8000b0a0:	f7 bc 00 fc 	subeq	r12,-4
8000b0a4:	f4 08 17 00 	moveq	r8,r10
8000b0a8:	f7 d8 c0 02 	bfextu	r11,r8,0x0,0x2
8000b0ac:	f0 0a 16 02 	lsr	r10,r8,0x2
8000b0b0:	58 0b       	cp.w	r11,0
8000b0b2:	f7 bc 00 fe 	subeq	r12,-2
8000b0b6:	f4 08 17 00 	moveq	r8,r10
8000b0ba:	ed b8 00 00 	bld	r8,0x0
8000b0be:	c0 60       	breq	8000b0ca <__lo0bits+0x8a>
8000b0c0:	a1 98       	lsr	r8,0x1
8000b0c2:	c0 31       	brne	8000b0c8 <__lo0bits+0x88>
8000b0c4:	32 0c       	mov	r12,32
8000b0c6:	5e fc       	retal	r12
8000b0c8:	2f fc       	sub	r12,-1
8000b0ca:	93 08       	st.w	r9[0x0],r8
8000b0cc:	5e fc       	retal	r12

8000b0ce <__mcmp>:
8000b0ce:	d4 01       	pushm	lr
8000b0d0:	18 98       	mov	r8,r12
8000b0d2:	76 49       	ld.w	r9,r11[0x10]
8000b0d4:	78 4c       	ld.w	r12,r12[0x10]
8000b0d6:	12 1c       	sub	r12,r9
8000b0d8:	c1 31       	brne	8000b0fe <__mcmp+0x30>
8000b0da:	2f b9       	sub	r9,-5
8000b0dc:	a3 69       	lsl	r9,0x2
8000b0de:	12 0b       	add	r11,r9
8000b0e0:	f0 09 00 09 	add	r9,r8,r9
8000b0e4:	2e c8       	sub	r8,-20
8000b0e6:	13 4e       	ld.w	lr,--r9
8000b0e8:	17 4a       	ld.w	r10,--r11
8000b0ea:	14 3e       	cp.w	lr,r10
8000b0ec:	c0 60       	breq	8000b0f8 <__mcmp+0x2a>
8000b0ee:	f9 bc 03 ff 	movlo	r12,-1
8000b0f2:	f9 bc 02 01 	movhs	r12,1
8000b0f6:	d8 02       	popm	pc
8000b0f8:	10 39       	cp.w	r9,r8
8000b0fa:	fe 9b ff f6 	brhi	8000b0e6 <__mcmp+0x18>
8000b0fe:	d8 02       	popm	pc

8000b100 <_Bfree>:
8000b100:	d4 21       	pushm	r4-r7,lr
8000b102:	18 97       	mov	r7,r12
8000b104:	16 95       	mov	r5,r11
8000b106:	78 96       	ld.w	r6,r12[0x24]
8000b108:	58 06       	cp.w	r6,0
8000b10a:	c0 91       	brne	8000b11c <_Bfree+0x1c>
8000b10c:	31 0c       	mov	r12,16
8000b10e:	fe b0 de 09 	rcall	80006d20 <malloc>
8000b112:	99 36       	st.w	r12[0xc],r6
8000b114:	8f 9c       	st.w	r7[0x24],r12
8000b116:	99 16       	st.w	r12[0x4],r6
8000b118:	99 26       	st.w	r12[0x8],r6
8000b11a:	99 06       	st.w	r12[0x0],r6
8000b11c:	58 05       	cp.w	r5,0
8000b11e:	c0 90       	breq	8000b130 <_Bfree+0x30>
8000b120:	6a 19       	ld.w	r9,r5[0x4]
8000b122:	6e 98       	ld.w	r8,r7[0x24]
8000b124:	70 38       	ld.w	r8,r8[0xc]
8000b126:	f0 09 03 2a 	ld.w	r10,r8[r9<<0x2]
8000b12a:	8b 0a       	st.w	r5[0x0],r10
8000b12c:	f0 09 09 25 	st.w	r8[r9<<0x2],r5
8000b130:	d8 22       	popm	r4-r7,pc
8000b132:	d7 03       	nop

8000b134 <_Balloc>:
8000b134:	d4 21       	pushm	r4-r7,lr
8000b136:	18 97       	mov	r7,r12
8000b138:	16 96       	mov	r6,r11
8000b13a:	78 95       	ld.w	r5,r12[0x24]
8000b13c:	58 05       	cp.w	r5,0
8000b13e:	c0 91       	brne	8000b150 <_Balloc+0x1c>
8000b140:	31 0c       	mov	r12,16
8000b142:	fe b0 dd ef 	rcall	80006d20 <malloc>
8000b146:	99 35       	st.w	r12[0xc],r5
8000b148:	8f 9c       	st.w	r7[0x24],r12
8000b14a:	99 15       	st.w	r12[0x4],r5
8000b14c:	99 25       	st.w	r12[0x8],r5
8000b14e:	99 05       	st.w	r12[0x0],r5
8000b150:	6e 95       	ld.w	r5,r7[0x24]
8000b152:	6a 38       	ld.w	r8,r5[0xc]
8000b154:	58 08       	cp.w	r8,0
8000b156:	c0 b1       	brne	8000b16c <_Balloc+0x38>
8000b158:	31 0a       	mov	r10,16
8000b15a:	30 4b       	mov	r11,4
8000b15c:	0e 9c       	mov	r12,r7
8000b15e:	e0 a0 02 9d 	rcall	8000b698 <_calloc_r>
8000b162:	8b 3c       	st.w	r5[0xc],r12
8000b164:	6e 98       	ld.w	r8,r7[0x24]
8000b166:	70 3c       	ld.w	r12,r8[0xc]
8000b168:	58 0c       	cp.w	r12,0
8000b16a:	c1 b0       	breq	8000b1a0 <_Balloc+0x6c>
8000b16c:	6e 98       	ld.w	r8,r7[0x24]
8000b16e:	70 38       	ld.w	r8,r8[0xc]
8000b170:	f0 06 00 28 	add	r8,r8,r6<<0x2
8000b174:	70 0c       	ld.w	r12,r8[0x0]
8000b176:	58 0c       	cp.w	r12,0
8000b178:	c0 40       	breq	8000b180 <_Balloc+0x4c>
8000b17a:	78 09       	ld.w	r9,r12[0x0]
8000b17c:	91 09       	st.w	r8[0x0],r9
8000b17e:	c0 e8       	rjmp	8000b19a <_Balloc+0x66>
8000b180:	0e 9c       	mov	r12,r7
8000b182:	30 17       	mov	r7,1
8000b184:	0e 9b       	mov	r11,r7
8000b186:	ee 06 09 47 	lsl	r7,r7,r6
8000b18a:	ee ca ff fb 	sub	r10,r7,-5
8000b18e:	a3 6a       	lsl	r10,0x2
8000b190:	e0 a0 02 84 	rcall	8000b698 <_calloc_r>
8000b194:	c0 60       	breq	8000b1a0 <_Balloc+0x6c>
8000b196:	99 16       	st.w	r12[0x4],r6
8000b198:	99 27       	st.w	r12[0x8],r7
8000b19a:	30 08       	mov	r8,0
8000b19c:	99 38       	st.w	r12[0xc],r8
8000b19e:	99 48       	st.w	r12[0x10],r8
8000b1a0:	d8 22       	popm	r4-r7,pc
8000b1a2:	d7 03       	nop

8000b1a4 <__d2b>:
8000b1a4:	d4 31       	pushm	r0-r7,lr
8000b1a6:	20 2d       	sub	sp,8
8000b1a8:	16 93       	mov	r3,r11
8000b1aa:	12 96       	mov	r6,r9
8000b1ac:	10 95       	mov	r5,r8
8000b1ae:	14 92       	mov	r2,r10
8000b1b0:	30 1b       	mov	r11,1
8000b1b2:	cc 1f       	rcall	8000b134 <_Balloc>
8000b1b4:	f3 d3 c0 14 	bfextu	r9,r3,0x0,0x14
8000b1b8:	50 09       	stdsp	sp[0x0],r9
8000b1ba:	f1 d3 c0 1f 	bfextu	r8,r3,0x0,0x1f
8000b1be:	b5 a9       	sbr	r9,0x14
8000b1c0:	f0 01 16 14 	lsr	r1,r8,0x14
8000b1c4:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000b1c8:	18 94       	mov	r4,r12
8000b1ca:	58 02       	cp.w	r2,0
8000b1cc:	c1 d0       	breq	8000b206 <__d2b+0x62>
8000b1ce:	fa cc ff f8 	sub	r12,sp,-8
8000b1d2:	18 d2       	st.w	--r12,r2
8000b1d4:	c3 6f       	rcall	8000b040 <__lo0bits>
8000b1d6:	40 18       	lddsp	r8,sp[0x4]
8000b1d8:	c0 d0       	breq	8000b1f2 <__d2b+0x4e>
8000b1da:	40 09       	lddsp	r9,sp[0x0]
8000b1dc:	f8 0a 11 20 	rsub	r10,r12,32
8000b1e0:	f2 0a 09 4a 	lsl	r10,r9,r10
8000b1e4:	f5 e8 10 08 	or	r8,r10,r8
8000b1e8:	89 58       	st.w	r4[0x14],r8
8000b1ea:	f2 0c 0a 49 	lsr	r9,r9,r12
8000b1ee:	50 09       	stdsp	sp[0x0],r9
8000b1f0:	c0 28       	rjmp	8000b1f4 <__d2b+0x50>
8000b1f2:	89 58       	st.w	r4[0x14],r8
8000b1f4:	40 08       	lddsp	r8,sp[0x0]
8000b1f6:	58 08       	cp.w	r8,0
8000b1f8:	f9 b3 01 02 	movne	r3,2
8000b1fc:	f9 b3 00 01 	moveq	r3,1
8000b200:	89 68       	st.w	r4[0x18],r8
8000b202:	89 43       	st.w	r4[0x10],r3
8000b204:	c0 88       	rjmp	8000b214 <__d2b+0x70>
8000b206:	1a 9c       	mov	r12,sp
8000b208:	c1 cf       	rcall	8000b040 <__lo0bits>
8000b20a:	30 13       	mov	r3,1
8000b20c:	40 08       	lddsp	r8,sp[0x0]
8000b20e:	2e 0c       	sub	r12,-32
8000b210:	89 43       	st.w	r4[0x10],r3
8000b212:	89 58       	st.w	r4[0x14],r8
8000b214:	58 01       	cp.w	r1,0
8000b216:	c0 90       	breq	8000b228 <__d2b+0x84>
8000b218:	e2 c1 04 33 	sub	r1,r1,1075
8000b21c:	18 01       	add	r1,r12
8000b21e:	8d 01       	st.w	r6[0x0],r1
8000b220:	f8 0c 11 35 	rsub	r12,r12,53
8000b224:	8b 0c       	st.w	r5[0x0],r12
8000b226:	c0 c8       	rjmp	8000b23e <__d2b+0x9a>
8000b228:	e6 c8 ff fc 	sub	r8,r3,-4
8000b22c:	f8 cc 04 32 	sub	r12,r12,1074
8000b230:	a5 73       	lsl	r3,0x5
8000b232:	8d 0c       	st.w	r6[0x0],r12
8000b234:	e8 08 03 2c 	ld.w	r12,r4[r8<<0x2]
8000b238:	cd 4e       	rcall	8000afe0 <__hi0bits>
8000b23a:	18 13       	sub	r3,r12
8000b23c:	8b 03       	st.w	r5[0x0],r3
8000b23e:	08 9c       	mov	r12,r4
8000b240:	2f ed       	sub	sp,-8
8000b242:	d8 32       	popm	r0-r7,pc

8000b244 <__mdiff>:
8000b244:	d4 31       	pushm	r0-r7,lr
8000b246:	74 48       	ld.w	r8,r10[0x10]
8000b248:	76 45       	ld.w	r5,r11[0x10]
8000b24a:	16 97       	mov	r7,r11
8000b24c:	14 96       	mov	r6,r10
8000b24e:	10 15       	sub	r5,r8
8000b250:	c1 31       	brne	8000b276 <__mdiff+0x32>
8000b252:	2f b8       	sub	r8,-5
8000b254:	ee ce ff ec 	sub	lr,r7,-20
8000b258:	a3 68       	lsl	r8,0x2
8000b25a:	f4 08 00 0b 	add	r11,r10,r8
8000b25e:	ee 08 00 08 	add	r8,r7,r8
8000b262:	11 4a       	ld.w	r10,--r8
8000b264:	17 49       	ld.w	r9,--r11
8000b266:	12 3a       	cp.w	r10,r9
8000b268:	c0 30       	breq	8000b26e <__mdiff+0x2a>
8000b26a:	c0 e2       	brcc	8000b286 <__mdiff+0x42>
8000b26c:	c0 78       	rjmp	8000b27a <__mdiff+0x36>
8000b26e:	1c 38       	cp.w	r8,lr
8000b270:	fe 9b ff f9 	brhi	8000b262 <__mdiff+0x1e>
8000b274:	c4 98       	rjmp	8000b306 <__mdiff+0xc2>
8000b276:	58 05       	cp.w	r5,0
8000b278:	c0 64       	brge	8000b284 <__mdiff+0x40>
8000b27a:	0e 98       	mov	r8,r7
8000b27c:	30 15       	mov	r5,1
8000b27e:	0c 97       	mov	r7,r6
8000b280:	10 96       	mov	r6,r8
8000b282:	c0 28       	rjmp	8000b286 <__mdiff+0x42>
8000b284:	30 05       	mov	r5,0
8000b286:	6e 1b       	ld.w	r11,r7[0x4]
8000b288:	c5 6f       	rcall	8000b134 <_Balloc>
8000b28a:	6e 49       	ld.w	r9,r7[0x10]
8000b28c:	6c 44       	ld.w	r4,r6[0x10]
8000b28e:	99 35       	st.w	r12[0xc],r5
8000b290:	2f b4       	sub	r4,-5
8000b292:	f2 c5 ff fb 	sub	r5,r9,-5
8000b296:	ec 04 00 24 	add	r4,r6,r4<<0x2
8000b29a:	ee 05 00 25 	add	r5,r7,r5<<0x2
8000b29e:	2e c6       	sub	r6,-20
8000b2a0:	2e c7       	sub	r7,-20
8000b2a2:	f8 c8 ff ec 	sub	r8,r12,-20
8000b2a6:	30 0a       	mov	r10,0
8000b2a8:	0f 0e       	ld.w	lr,r7++
8000b2aa:	0d 0b       	ld.w	r11,r6++
8000b2ac:	fc 02 16 10 	lsr	r2,lr,0x10
8000b2b0:	f6 03 16 10 	lsr	r3,r11,0x10
8000b2b4:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000b2b8:	e4 03 01 03 	sub	r3,r2,r3
8000b2bc:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b2c0:	fc 0b 01 0b 	sub	r11,lr,r11
8000b2c4:	f6 0a 00 0a 	add	r10,r11,r10
8000b2c8:	b0 1a       	st.h	r8[0x2],r10
8000b2ca:	b1 4a       	asr	r10,0x10
8000b2cc:	e6 0a 00 0a 	add	r10,r3,r10
8000b2d0:	b0 0a       	st.h	r8[0x0],r10
8000b2d2:	2f c8       	sub	r8,-4
8000b2d4:	b1 4a       	asr	r10,0x10
8000b2d6:	08 36       	cp.w	r6,r4
8000b2d8:	ce 83       	brcs	8000b2a8 <__mdiff+0x64>
8000b2da:	c0 d8       	rjmp	8000b2f4 <__mdiff+0xb0>
8000b2dc:	0f 0b       	ld.w	r11,r7++
8000b2de:	f6 0e 16 10 	lsr	lr,r11,0x10
8000b2e2:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b2e6:	16 0a       	add	r10,r11
8000b2e8:	b0 1a       	st.h	r8[0x2],r10
8000b2ea:	b1 4a       	asr	r10,0x10
8000b2ec:	1c 0a       	add	r10,lr
8000b2ee:	b0 0a       	st.h	r8[0x0],r10
8000b2f0:	2f c8       	sub	r8,-4
8000b2f2:	b1 4a       	asr	r10,0x10
8000b2f4:	0a 37       	cp.w	r7,r5
8000b2f6:	cf 33       	brcs	8000b2dc <__mdiff+0x98>
8000b2f8:	c0 28       	rjmp	8000b2fc <__mdiff+0xb8>
8000b2fa:	20 19       	sub	r9,1
8000b2fc:	11 4a       	ld.w	r10,--r8
8000b2fe:	58 0a       	cp.w	r10,0
8000b300:	cf d0       	breq	8000b2fa <__mdiff+0xb6>
8000b302:	99 49       	st.w	r12[0x10],r9
8000b304:	d8 32       	popm	r0-r7,pc
8000b306:	30 0b       	mov	r11,0
8000b308:	c1 6f       	rcall	8000b134 <_Balloc>
8000b30a:	30 18       	mov	r8,1
8000b30c:	99 48       	st.w	r12[0x10],r8
8000b30e:	30 08       	mov	r8,0
8000b310:	99 58       	st.w	r12[0x14],r8
8000b312:	d8 32       	popm	r0-r7,pc

8000b314 <__lshift>:
8000b314:	d4 31       	pushm	r0-r7,lr
8000b316:	16 97       	mov	r7,r11
8000b318:	76 46       	ld.w	r6,r11[0x10]
8000b31a:	f4 02 14 05 	asr	r2,r10,0x5
8000b31e:	2f f6       	sub	r6,-1
8000b320:	14 93       	mov	r3,r10
8000b322:	18 94       	mov	r4,r12
8000b324:	04 06       	add	r6,r2
8000b326:	76 1b       	ld.w	r11,r11[0x4]
8000b328:	6e 28       	ld.w	r8,r7[0x8]
8000b32a:	c0 38       	rjmp	8000b330 <__lshift+0x1c>
8000b32c:	2f fb       	sub	r11,-1
8000b32e:	a1 78       	lsl	r8,0x1
8000b330:	10 36       	cp.w	r6,r8
8000b332:	fe 99 ff fd 	brgt	8000b32c <__lshift+0x18>
8000b336:	08 9c       	mov	r12,r4
8000b338:	cf ee       	rcall	8000b134 <_Balloc>
8000b33a:	30 09       	mov	r9,0
8000b33c:	18 95       	mov	r5,r12
8000b33e:	f8 c8 ff ec 	sub	r8,r12,-20
8000b342:	12 9a       	mov	r10,r9
8000b344:	c0 38       	rjmp	8000b34a <__lshift+0x36>
8000b346:	10 aa       	st.w	r8++,r10
8000b348:	2f f9       	sub	r9,-1
8000b34a:	04 39       	cp.w	r9,r2
8000b34c:	cf d5       	brlt	8000b346 <__lshift+0x32>
8000b34e:	6e 4b       	ld.w	r11,r7[0x10]
8000b350:	e7 d3 c0 05 	bfextu	r3,r3,0x0,0x5
8000b354:	2f bb       	sub	r11,-5
8000b356:	ee c9 ff ec 	sub	r9,r7,-20
8000b35a:	ee 0b 00 2b 	add	r11,r7,r11<<0x2
8000b35e:	58 03       	cp.w	r3,0
8000b360:	c1 30       	breq	8000b386 <__lshift+0x72>
8000b362:	e6 0c 11 20 	rsub	r12,r3,32
8000b366:	30 0a       	mov	r10,0
8000b368:	72 02       	ld.w	r2,r9[0x0]
8000b36a:	e4 03 09 42 	lsl	r2,r2,r3
8000b36e:	04 4a       	or	r10,r2
8000b370:	10 aa       	st.w	r8++,r10
8000b372:	13 0a       	ld.w	r10,r9++
8000b374:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000b378:	16 39       	cp.w	r9,r11
8000b37a:	cf 73       	brcs	8000b368 <__lshift+0x54>
8000b37c:	91 0a       	st.w	r8[0x0],r10
8000b37e:	58 0a       	cp.w	r10,0
8000b380:	c0 70       	breq	8000b38e <__lshift+0x7a>
8000b382:	2f f6       	sub	r6,-1
8000b384:	c0 58       	rjmp	8000b38e <__lshift+0x7a>
8000b386:	13 0a       	ld.w	r10,r9++
8000b388:	10 aa       	st.w	r8++,r10
8000b38a:	16 39       	cp.w	r9,r11
8000b38c:	cf d3       	brcs	8000b386 <__lshift+0x72>
8000b38e:	08 9c       	mov	r12,r4
8000b390:	20 16       	sub	r6,1
8000b392:	0e 9b       	mov	r11,r7
8000b394:	8b 46       	st.w	r5[0x10],r6
8000b396:	cb 5e       	rcall	8000b100 <_Bfree>
8000b398:	0a 9c       	mov	r12,r5
8000b39a:	d8 32       	popm	r0-r7,pc

8000b39c <__multiply>:
8000b39c:	d4 31       	pushm	r0-r7,lr
8000b39e:	20 2d       	sub	sp,8
8000b3a0:	76 49       	ld.w	r9,r11[0x10]
8000b3a2:	74 48       	ld.w	r8,r10[0x10]
8000b3a4:	16 96       	mov	r6,r11
8000b3a6:	14 95       	mov	r5,r10
8000b3a8:	10 39       	cp.w	r9,r8
8000b3aa:	ec 08 17 50 	movlt	r8,r6
8000b3ae:	ea 06 17 50 	movlt	r6,r5
8000b3b2:	f0 05 17 50 	movlt	r5,r8
8000b3b6:	6c 28       	ld.w	r8,r6[0x8]
8000b3b8:	76 43       	ld.w	r3,r11[0x10]
8000b3ba:	74 42       	ld.w	r2,r10[0x10]
8000b3bc:	76 1b       	ld.w	r11,r11[0x4]
8000b3be:	e4 03 00 07 	add	r7,r2,r3
8000b3c2:	10 37       	cp.w	r7,r8
8000b3c4:	f7 bb 09 ff 	subgt	r11,-1
8000b3c8:	cb 6e       	rcall	8000b134 <_Balloc>
8000b3ca:	ee c4 ff fb 	sub	r4,r7,-5
8000b3ce:	f8 c9 ff ec 	sub	r9,r12,-20
8000b3d2:	f8 04 00 24 	add	r4,r12,r4<<0x2
8000b3d6:	30 0a       	mov	r10,0
8000b3d8:	12 98       	mov	r8,r9
8000b3da:	c0 28       	rjmp	8000b3de <__multiply+0x42>
8000b3dc:	10 aa       	st.w	r8++,r10
8000b3de:	08 38       	cp.w	r8,r4
8000b3e0:	cf e3       	brcs	8000b3dc <__multiply+0x40>
8000b3e2:	2f b3       	sub	r3,-5
8000b3e4:	2f b2       	sub	r2,-5
8000b3e6:	ec 03 00 23 	add	r3,r6,r3<<0x2
8000b3ea:	ea 02 00 22 	add	r2,r5,r2<<0x2
8000b3ee:	ec cb ff ec 	sub	r11,r6,-20
8000b3f2:	50 12       	stdsp	sp[0x4],r2
8000b3f4:	ea ca ff ec 	sub	r10,r5,-20
8000b3f8:	c4 48       	rjmp	8000b480 <__multiply+0xe4>
8000b3fa:	94 95       	ld.uh	r5,r10[0x2]
8000b3fc:	58 05       	cp.w	r5,0
8000b3fe:	c2 00       	breq	8000b43e <__multiply+0xa2>
8000b400:	12 98       	mov	r8,r9
8000b402:	16 96       	mov	r6,r11
8000b404:	30 0e       	mov	lr,0
8000b406:	50 09       	stdsp	sp[0x0],r9
8000b408:	0d 02       	ld.w	r2,r6++
8000b40a:	e4 00 16 10 	lsr	r0,r2,0x10
8000b40e:	70 01       	ld.w	r1,r8[0x0]
8000b410:	70 09       	ld.w	r9,r8[0x0]
8000b412:	b1 81       	lsr	r1,0x10
8000b414:	e5 d2 c0 10 	bfextu	r2,r2,0x0,0x10
8000b418:	e0 05 03 41 	mac	r1,r0,r5
8000b41c:	ab 32       	mul	r2,r5
8000b41e:	e1 d9 c0 10 	bfextu	r0,r9,0x0,0x10
8000b422:	00 02       	add	r2,r0
8000b424:	e4 0e 00 0e 	add	lr,r2,lr
8000b428:	b0 1e       	st.h	r8[0x2],lr
8000b42a:	b1 8e       	lsr	lr,0x10
8000b42c:	1c 01       	add	r1,lr
8000b42e:	b0 01       	st.h	r8[0x0],r1
8000b430:	e2 0e 16 10 	lsr	lr,r1,0x10
8000b434:	2f c8       	sub	r8,-4
8000b436:	06 36       	cp.w	r6,r3
8000b438:	ce 83       	brcs	8000b408 <__multiply+0x6c>
8000b43a:	40 09       	lddsp	r9,sp[0x0]
8000b43c:	91 0e       	st.w	r8[0x0],lr
8000b43e:	94 86       	ld.uh	r6,r10[0x0]
8000b440:	58 06       	cp.w	r6,0
8000b442:	c1 d0       	breq	8000b47c <__multiply+0xe0>
8000b444:	72 02       	ld.w	r2,r9[0x0]
8000b446:	12 98       	mov	r8,r9
8000b448:	16 9e       	mov	lr,r11
8000b44a:	30 05       	mov	r5,0
8000b44c:	b0 12       	st.h	r8[0x2],r2
8000b44e:	1d 01       	ld.w	r1,lr++
8000b450:	90 82       	ld.uh	r2,r8[0x0]
8000b452:	e1 d1 c0 10 	bfextu	r0,r1,0x0,0x10
8000b456:	ad 30       	mul	r0,r6
8000b458:	e0 02 00 02 	add	r2,r0,r2
8000b45c:	e4 05 00 05 	add	r5,r2,r5
8000b460:	b0 05       	st.h	r8[0x0],r5
8000b462:	b1 85       	lsr	r5,0x10
8000b464:	b1 81       	lsr	r1,0x10
8000b466:	2f c8       	sub	r8,-4
8000b468:	ad 31       	mul	r1,r6
8000b46a:	90 92       	ld.uh	r2,r8[0x2]
8000b46c:	e2 02 00 02 	add	r2,r1,r2
8000b470:	0a 02       	add	r2,r5
8000b472:	e4 05 16 10 	lsr	r5,r2,0x10
8000b476:	06 3e       	cp.w	lr,r3
8000b478:	ce a3       	brcs	8000b44c <__multiply+0xb0>
8000b47a:	91 02       	st.w	r8[0x0],r2
8000b47c:	2f ca       	sub	r10,-4
8000b47e:	2f c9       	sub	r9,-4
8000b480:	40 18       	lddsp	r8,sp[0x4]
8000b482:	10 3a       	cp.w	r10,r8
8000b484:	cb b3       	brcs	8000b3fa <__multiply+0x5e>
8000b486:	c0 28       	rjmp	8000b48a <__multiply+0xee>
8000b488:	20 17       	sub	r7,1
8000b48a:	58 07       	cp.w	r7,0
8000b48c:	e0 8a 00 05 	brle	8000b496 <__multiply+0xfa>
8000b490:	09 48       	ld.w	r8,--r4
8000b492:	58 08       	cp.w	r8,0
8000b494:	cf a0       	breq	8000b488 <__multiply+0xec>
8000b496:	99 47       	st.w	r12[0x10],r7
8000b498:	2f ed       	sub	sp,-8
8000b49a:	d8 32       	popm	r0-r7,pc

8000b49c <__i2b>:
8000b49c:	d4 21       	pushm	r4-r7,lr
8000b49e:	16 97       	mov	r7,r11
8000b4a0:	30 1b       	mov	r11,1
8000b4a2:	c4 9e       	rcall	8000b134 <_Balloc>
8000b4a4:	30 19       	mov	r9,1
8000b4a6:	99 57       	st.w	r12[0x14],r7
8000b4a8:	99 49       	st.w	r12[0x10],r9
8000b4aa:	d8 22       	popm	r4-r7,pc

8000b4ac <__multadd>:
8000b4ac:	d4 31       	pushm	r0-r7,lr
8000b4ae:	30 08       	mov	r8,0
8000b4b0:	12 95       	mov	r5,r9
8000b4b2:	16 97       	mov	r7,r11
8000b4b4:	18 96       	mov	r6,r12
8000b4b6:	76 44       	ld.w	r4,r11[0x10]
8000b4b8:	f6 c9 ff ec 	sub	r9,r11,-20
8000b4bc:	72 0b       	ld.w	r11,r9[0x0]
8000b4be:	f6 0c 16 10 	lsr	r12,r11,0x10
8000b4c2:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b4c6:	f4 0c 02 4c 	mul	r12,r10,r12
8000b4ca:	f4 0b 03 45 	mac	r5,r10,r11
8000b4ce:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
8000b4d2:	b1 85       	lsr	r5,0x10
8000b4d4:	18 05       	add	r5,r12
8000b4d6:	ea 0c 15 10 	lsl	r12,r5,0x10
8000b4da:	f8 0b 00 0b 	add	r11,r12,r11
8000b4de:	12 ab       	st.w	r9++,r11
8000b4e0:	2f f8       	sub	r8,-1
8000b4e2:	b1 85       	lsr	r5,0x10
8000b4e4:	08 38       	cp.w	r8,r4
8000b4e6:	ce b5       	brlt	8000b4bc <__multadd+0x10>
8000b4e8:	58 05       	cp.w	r5,0
8000b4ea:	c1 c0       	breq	8000b522 <__multadd+0x76>
8000b4ec:	6e 28       	ld.w	r8,r7[0x8]
8000b4ee:	10 34       	cp.w	r4,r8
8000b4f0:	c1 35       	brlt	8000b516 <__multadd+0x6a>
8000b4f2:	6e 1b       	ld.w	r11,r7[0x4]
8000b4f4:	0c 9c       	mov	r12,r6
8000b4f6:	2f fb       	sub	r11,-1
8000b4f8:	c1 ee       	rcall	8000b134 <_Balloc>
8000b4fa:	6e 4a       	ld.w	r10,r7[0x10]
8000b4fc:	ee cb ff f4 	sub	r11,r7,-12
8000b500:	18 93       	mov	r3,r12
8000b502:	2f ea       	sub	r10,-2
8000b504:	2f 4c       	sub	r12,-12
8000b506:	a3 6a       	lsl	r10,0x2
8000b508:	fe b0 de 43 	rcall	8000718e <memcpy>
8000b50c:	0e 9b       	mov	r11,r7
8000b50e:	0c 9c       	mov	r12,r6
8000b510:	fe b0 fd f8 	rcall	8000b100 <_Bfree>
8000b514:	06 97       	mov	r7,r3
8000b516:	e8 c8 ff ff 	sub	r8,r4,-1
8000b51a:	2f b4       	sub	r4,-5
8000b51c:	8f 48       	st.w	r7[0x10],r8
8000b51e:	ee 04 09 25 	st.w	r7[r4<<0x2],r5
8000b522:	0e 9c       	mov	r12,r7
8000b524:	d8 32       	popm	r0-r7,pc
8000b526:	d7 03       	nop

8000b528 <__pow5mult>:
8000b528:	d4 31       	pushm	r0-r7,lr
8000b52a:	14 96       	mov	r6,r10
8000b52c:	18 97       	mov	r7,r12
8000b52e:	16 94       	mov	r4,r11
8000b530:	f1 da c0 02 	bfextu	r8,r10,0x0,0x2
8000b534:	c0 80       	breq	8000b544 <__pow5mult+0x1c>
8000b536:	20 18       	sub	r8,1
8000b538:	49 f9       	lddpc	r9,8000b5b4 <__pow5mult+0x8c>
8000b53a:	f2 08 03 2a 	ld.w	r10,r9[r8<<0x2]
8000b53e:	30 09       	mov	r9,0
8000b540:	cb 6f       	rcall	8000b4ac <__multadd>
8000b542:	18 94       	mov	r4,r12
8000b544:	a3 46       	asr	r6,0x2
8000b546:	c3 40       	breq	8000b5ae <__pow5mult+0x86>
8000b548:	6e 95       	ld.w	r5,r7[0x24]
8000b54a:	58 05       	cp.w	r5,0
8000b54c:	c0 91       	brne	8000b55e <__pow5mult+0x36>
8000b54e:	31 0c       	mov	r12,16
8000b550:	fe b0 db e8 	rcall	80006d20 <malloc>
8000b554:	99 35       	st.w	r12[0xc],r5
8000b556:	8f 9c       	st.w	r7[0x24],r12
8000b558:	99 15       	st.w	r12[0x4],r5
8000b55a:	99 25       	st.w	r12[0x8],r5
8000b55c:	99 05       	st.w	r12[0x0],r5
8000b55e:	6e 93       	ld.w	r3,r7[0x24]
8000b560:	66 25       	ld.w	r5,r3[0x8]
8000b562:	58 05       	cp.w	r5,0
8000b564:	c0 c1       	brne	8000b57c <__pow5mult+0x54>
8000b566:	e0 6b 02 71 	mov	r11,625
8000b56a:	0e 9c       	mov	r12,r7
8000b56c:	c9 8f       	rcall	8000b49c <__i2b>
8000b56e:	87 2c       	st.w	r3[0x8],r12
8000b570:	30 08       	mov	r8,0
8000b572:	18 95       	mov	r5,r12
8000b574:	99 08       	st.w	r12[0x0],r8
8000b576:	c0 38       	rjmp	8000b57c <__pow5mult+0x54>
8000b578:	06 9c       	mov	r12,r3
8000b57a:	18 95       	mov	r5,r12
8000b57c:	ed b6 00 00 	bld	r6,0x0
8000b580:	c0 b1       	brne	8000b596 <__pow5mult+0x6e>
8000b582:	08 9b       	mov	r11,r4
8000b584:	0a 9a       	mov	r10,r5
8000b586:	0e 9c       	mov	r12,r7
8000b588:	c0 af       	rcall	8000b39c <__multiply>
8000b58a:	08 9b       	mov	r11,r4
8000b58c:	18 93       	mov	r3,r12
8000b58e:	0e 9c       	mov	r12,r7
8000b590:	06 94       	mov	r4,r3
8000b592:	fe b0 fd b7 	rcall	8000b100 <_Bfree>
8000b596:	a1 56       	asr	r6,0x1
8000b598:	c0 b0       	breq	8000b5ae <__pow5mult+0x86>
8000b59a:	6a 03       	ld.w	r3,r5[0x0]
8000b59c:	58 03       	cp.w	r3,0
8000b59e:	ce d1       	brne	8000b578 <__pow5mult+0x50>
8000b5a0:	0a 9a       	mov	r10,r5
8000b5a2:	0a 9b       	mov	r11,r5
8000b5a4:	0e 9c       	mov	r12,r7
8000b5a6:	cf be       	rcall	8000b39c <__multiply>
8000b5a8:	8b 0c       	st.w	r5[0x0],r12
8000b5aa:	99 03       	st.w	r12[0x0],r3
8000b5ac:	ce 7b       	rjmp	8000b57a <__pow5mult+0x52>
8000b5ae:	08 9c       	mov	r12,r4
8000b5b0:	d8 32       	popm	r0-r7,pc
8000b5b2:	d7 03       	nop
8000b5b4:	80 01       	ld.sh	r1,r0[0x0]
8000b5b6:	5f 84       	srls	r4

8000b5b8 <__isinfd>:
8000b5b8:	14 98       	mov	r8,r10
8000b5ba:	fc 19 7f f0 	movh	r9,0x7ff0
8000b5be:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000b5c2:	f0 0b 11 00 	rsub	r11,r8,0
8000b5c6:	f7 e8 10 08 	or	r8,r11,r8
8000b5ca:	f5 e8 13 f8 	or	r8,r10,r8>>0x1f
8000b5ce:	f2 08 01 08 	sub	r8,r9,r8
8000b5d2:	f0 0c 11 00 	rsub	r12,r8,0
8000b5d6:	f9 e8 10 08 	or	r8,r12,r8
8000b5da:	f0 0c 14 1f 	asr	r12,r8,0x1f
8000b5de:	2f fc       	sub	r12,-1
8000b5e0:	5e fc       	retal	r12

8000b5e2 <__isnand>:
8000b5e2:	14 98       	mov	r8,r10
8000b5e4:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000b5e8:	f0 0c 11 00 	rsub	r12,r8,0
8000b5ec:	10 4c       	or	r12,r8
8000b5ee:	fc 18 7f f0 	movh	r8,0x7ff0
8000b5f2:	f5 ec 13 fc 	or	r12,r10,r12>>0x1f
8000b5f6:	f0 0c 01 0c 	sub	r12,r8,r12
8000b5fa:	bf 9c       	lsr	r12,0x1f
8000b5fc:	5e fc       	retal	r12
8000b5fe:	d7 03       	nop

8000b600 <__sclose>:
8000b600:	d4 01       	pushm	lr
8000b602:	96 7b       	ld.sh	r11,r11[0xe]
8000b604:	c7 6c       	rcall	8000b6f0 <_close_r>
8000b606:	d8 02       	popm	pc

8000b608 <__sseek>:
8000b608:	d4 21       	pushm	r4-r7,lr
8000b60a:	16 97       	mov	r7,r11
8000b60c:	96 7b       	ld.sh	r11,r11[0xe]
8000b60e:	cf 9c       	rcall	8000b800 <_lseek_r>
8000b610:	8e 68       	ld.sh	r8,r7[0xc]
8000b612:	10 99       	mov	r9,r8
8000b614:	ad c8       	cbr	r8,0xc
8000b616:	ad a9       	sbr	r9,0xc
8000b618:	5b fc       	cp.w	r12,-1
8000b61a:	ef f8 0c 06 	st.heq	r7[0xc],r8
8000b61e:	ef f9 1c 06 	st.hne	r7[0xc],r9
8000b622:	ef fc 1a 15 	st.wne	r7[0x54],r12
8000b626:	d8 22       	popm	r4-r7,pc

8000b628 <__swrite>:
8000b628:	d4 21       	pushm	r4-r7,lr
8000b62a:	96 68       	ld.sh	r8,r11[0xc]
8000b62c:	16 97       	mov	r7,r11
8000b62e:	14 95       	mov	r5,r10
8000b630:	12 94       	mov	r4,r9
8000b632:	e2 18 01 00 	andl	r8,0x100,COH
8000b636:	18 96       	mov	r6,r12
8000b638:	c0 50       	breq	8000b642 <__swrite+0x1a>
8000b63a:	30 29       	mov	r9,2
8000b63c:	30 0a       	mov	r10,0
8000b63e:	96 7b       	ld.sh	r11,r11[0xe]
8000b640:	ce 0c       	rcall	8000b800 <_lseek_r>
8000b642:	8e 68       	ld.sh	r8,r7[0xc]
8000b644:	ad c8       	cbr	r8,0xc
8000b646:	08 99       	mov	r9,r4
8000b648:	0a 9a       	mov	r10,r5
8000b64a:	8e 7b       	ld.sh	r11,r7[0xe]
8000b64c:	0c 9c       	mov	r12,r6
8000b64e:	ae 68       	st.h	r7[0xc],r8
8000b650:	c1 0c       	rcall	8000b670 <_write_r>
8000b652:	d8 22       	popm	r4-r7,pc

8000b654 <__sread>:
8000b654:	d4 21       	pushm	r4-r7,lr
8000b656:	16 97       	mov	r7,r11
8000b658:	96 7b       	ld.sh	r11,r11[0xe]
8000b65a:	ce 7c       	rcall	8000b828 <_read_r>
8000b65c:	c0 65       	brlt	8000b668 <__sread+0x14>
8000b65e:	6f 58       	ld.w	r8,r7[0x54]
8000b660:	18 08       	add	r8,r12
8000b662:	ef 48 00 54 	st.w	r7[84],r8
8000b666:	d8 22       	popm	r4-r7,pc
8000b668:	8e 68       	ld.sh	r8,r7[0xc]
8000b66a:	ad c8       	cbr	r8,0xc
8000b66c:	ae 68       	st.h	r7[0xc],r8
8000b66e:	d8 22       	popm	r4-r7,pc

8000b670 <_write_r>:
8000b670:	d4 21       	pushm	r4-r7,lr
8000b672:	16 98       	mov	r8,r11
8000b674:	18 97       	mov	r7,r12
8000b676:	10 9c       	mov	r12,r8
8000b678:	30 08       	mov	r8,0
8000b67a:	14 9b       	mov	r11,r10
8000b67c:	e0 66 52 e0 	mov	r6,21216
8000b680:	12 9a       	mov	r10,r9
8000b682:	8d 08       	st.w	r6[0x0],r8
8000b684:	fe b0 d1 00 	rcall	80005884 <_write>
8000b688:	5b fc       	cp.w	r12,-1
8000b68a:	c0 51       	brne	8000b694 <_write_r+0x24>
8000b68c:	6c 08       	ld.w	r8,r6[0x0]
8000b68e:	58 08       	cp.w	r8,0
8000b690:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b694:	d8 22       	popm	r4-r7,pc
8000b696:	d7 03       	nop

8000b698 <_calloc_r>:
8000b698:	d4 21       	pushm	r4-r7,lr
8000b69a:	f4 0b 02 4b 	mul	r11,r10,r11
8000b69e:	fe b0 db 49 	rcall	80006d30 <_malloc_r>
8000b6a2:	18 97       	mov	r7,r12
8000b6a4:	c2 30       	breq	8000b6ea <_calloc_r+0x52>
8000b6a6:	f8 fa ff fc 	ld.w	r10,r12[-4]
8000b6aa:	e0 1a ff fc 	andl	r10,0xfffc
8000b6ae:	20 4a       	sub	r10,4
8000b6b0:	e0 4a 00 24 	cp.w	r10,36
8000b6b4:	e0 8b 00 18 	brhi	8000b6e4 <_calloc_r+0x4c>
8000b6b8:	18 98       	mov	r8,r12
8000b6ba:	59 3a       	cp.w	r10,19
8000b6bc:	e0 88 00 0f 	brls	8000b6da <_calloc_r+0x42>
8000b6c0:	30 09       	mov	r9,0
8000b6c2:	10 a9       	st.w	r8++,r9
8000b6c4:	10 a9       	st.w	r8++,r9
8000b6c6:	59 ba       	cp.w	r10,27
8000b6c8:	e0 88 00 09 	brls	8000b6da <_calloc_r+0x42>
8000b6cc:	10 a9       	st.w	r8++,r9
8000b6ce:	10 a9       	st.w	r8++,r9
8000b6d0:	e0 4a 00 24 	cp.w	r10,36
8000b6d4:	c0 31       	brne	8000b6da <_calloc_r+0x42>
8000b6d6:	10 a9       	st.w	r8++,r9
8000b6d8:	10 a9       	st.w	r8++,r9
8000b6da:	30 09       	mov	r9,0
8000b6dc:	10 a9       	st.w	r8++,r9
8000b6de:	91 19       	st.w	r8[0x4],r9
8000b6e0:	91 09       	st.w	r8[0x0],r9
8000b6e2:	c0 48       	rjmp	8000b6ea <_calloc_r+0x52>
8000b6e4:	30 0b       	mov	r11,0
8000b6e6:	fe b0 dd f8 	rcall	800072d6 <memset>
8000b6ea:	0e 9c       	mov	r12,r7
8000b6ec:	d8 22       	popm	r4-r7,pc
8000b6ee:	d7 03       	nop

8000b6f0 <_close_r>:
8000b6f0:	d4 21       	pushm	r4-r7,lr
8000b6f2:	30 08       	mov	r8,0
8000b6f4:	18 97       	mov	r7,r12
8000b6f6:	e0 66 52 e0 	mov	r6,21216
8000b6fa:	16 9c       	mov	r12,r11
8000b6fc:	8d 08       	st.w	r6[0x0],r8
8000b6fe:	fe b0 df a5 	rcall	80007648 <_close>
8000b702:	5b fc       	cp.w	r12,-1
8000b704:	c0 51       	brne	8000b70e <_close_r+0x1e>
8000b706:	6c 08       	ld.w	r8,r6[0x0]
8000b708:	58 08       	cp.w	r8,0
8000b70a:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b70e:	d8 22       	popm	r4-r7,pc

8000b710 <_fclose_r>:
8000b710:	d4 21       	pushm	r4-r7,lr
8000b712:	18 96       	mov	r6,r12
8000b714:	16 97       	mov	r7,r11
8000b716:	58 0b       	cp.w	r11,0
8000b718:	c0 31       	brne	8000b71e <_fclose_r+0xe>
8000b71a:	16 95       	mov	r5,r11
8000b71c:	c5 08       	rjmp	8000b7bc <_fclose_r+0xac>
8000b71e:	fe b0 f8 b1 	rcall	8000a880 <__sfp_lock_acquire>
8000b722:	58 06       	cp.w	r6,0
8000b724:	c0 70       	breq	8000b732 <_fclose_r+0x22>
8000b726:	6c 68       	ld.w	r8,r6[0x18]
8000b728:	58 08       	cp.w	r8,0
8000b72a:	c0 41       	brne	8000b732 <_fclose_r+0x22>
8000b72c:	0c 9c       	mov	r12,r6
8000b72e:	fe b0 f8 fd 	rcall	8000a928 <__sinit>
8000b732:	4a 48       	lddpc	r8,8000b7c0 <_fclose_r+0xb0>
8000b734:	10 37       	cp.w	r7,r8
8000b736:	c0 31       	brne	8000b73c <_fclose_r+0x2c>
8000b738:	6c 07       	ld.w	r7,r6[0x0]
8000b73a:	c0 a8       	rjmp	8000b74e <_fclose_r+0x3e>
8000b73c:	4a 28       	lddpc	r8,8000b7c4 <_fclose_r+0xb4>
8000b73e:	10 37       	cp.w	r7,r8
8000b740:	c0 31       	brne	8000b746 <_fclose_r+0x36>
8000b742:	6c 17       	ld.w	r7,r6[0x4]
8000b744:	c0 58       	rjmp	8000b74e <_fclose_r+0x3e>
8000b746:	4a 18       	lddpc	r8,8000b7c8 <_fclose_r+0xb8>
8000b748:	10 37       	cp.w	r7,r8
8000b74a:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000b74e:	8e 69       	ld.sh	r9,r7[0xc]
8000b750:	30 08       	mov	r8,0
8000b752:	f0 09 19 00 	cp.h	r9,r8
8000b756:	c0 51       	brne	8000b760 <_fclose_r+0x50>
8000b758:	fe b0 f8 95 	rcall	8000a882 <__sfp_lock_release>
8000b75c:	30 05       	mov	r5,0
8000b75e:	c2 f8       	rjmp	8000b7bc <_fclose_r+0xac>
8000b760:	0e 9b       	mov	r11,r7
8000b762:	0c 9c       	mov	r12,r6
8000b764:	fe b0 f8 06 	rcall	8000a770 <_fflush_r>
8000b768:	6e c8       	ld.w	r8,r7[0x30]
8000b76a:	18 95       	mov	r5,r12
8000b76c:	58 08       	cp.w	r8,0
8000b76e:	c0 60       	breq	8000b77a <_fclose_r+0x6a>
8000b770:	6e 8b       	ld.w	r11,r7[0x20]
8000b772:	0c 9c       	mov	r12,r6
8000b774:	5d 18       	icall	r8
8000b776:	f9 b5 05 ff 	movlt	r5,-1
8000b77a:	8e 68       	ld.sh	r8,r7[0xc]
8000b77c:	ed b8 00 07 	bld	r8,0x7
8000b780:	c0 51       	brne	8000b78a <_fclose_r+0x7a>
8000b782:	6e 4b       	ld.w	r11,r7[0x10]
8000b784:	0c 9c       	mov	r12,r6
8000b786:	fe b0 f9 6b 	rcall	8000aa5c <_free_r>
8000b78a:	6e db       	ld.w	r11,r7[0x34]
8000b78c:	58 0b       	cp.w	r11,0
8000b78e:	c0 a0       	breq	8000b7a2 <_fclose_r+0x92>
8000b790:	ee c8 ff bc 	sub	r8,r7,-68
8000b794:	10 3b       	cp.w	r11,r8
8000b796:	c0 40       	breq	8000b79e <_fclose_r+0x8e>
8000b798:	0c 9c       	mov	r12,r6
8000b79a:	fe b0 f9 61 	rcall	8000aa5c <_free_r>
8000b79e:	30 08       	mov	r8,0
8000b7a0:	8f d8       	st.w	r7[0x34],r8
8000b7a2:	6f 2b       	ld.w	r11,r7[0x48]
8000b7a4:	58 0b       	cp.w	r11,0
8000b7a6:	c0 70       	breq	8000b7b4 <_fclose_r+0xa4>
8000b7a8:	0c 9c       	mov	r12,r6
8000b7aa:	fe b0 f9 59 	rcall	8000aa5c <_free_r>
8000b7ae:	30 08       	mov	r8,0
8000b7b0:	ef 48 00 48 	st.w	r7[72],r8
8000b7b4:	30 08       	mov	r8,0
8000b7b6:	ae 68       	st.h	r7[0xc],r8
8000b7b8:	fe b0 f8 65 	rcall	8000a882 <__sfp_lock_release>
8000b7bc:	0a 9c       	mov	r12,r5
8000b7be:	d8 22       	popm	r4-r7,pc
8000b7c0:	80 01       	ld.sh	r1,r0[0x0]
8000b7c2:	5e e0       	retqs	r0
8000b7c4:	80 01       	ld.sh	r1,r0[0x0]
8000b7c6:	5f 00       	sreq	r0
8000b7c8:	80 01       	ld.sh	r1,r0[0x0]
8000b7ca:	5f 20       	srhs	r0

8000b7cc <fclose>:
8000b7cc:	d4 01       	pushm	lr
8000b7ce:	e0 68 0a 3c 	mov	r8,2620
8000b7d2:	18 9b       	mov	r11,r12
8000b7d4:	70 0c       	ld.w	r12,r8[0x0]
8000b7d6:	c9 df       	rcall	8000b710 <_fclose_r>
8000b7d8:	d8 02       	popm	pc
8000b7da:	d7 03       	nop

8000b7dc <_fstat_r>:
8000b7dc:	d4 21       	pushm	r4-r7,lr
8000b7de:	16 98       	mov	r8,r11
8000b7e0:	18 97       	mov	r7,r12
8000b7e2:	10 9c       	mov	r12,r8
8000b7e4:	30 08       	mov	r8,0
8000b7e6:	e0 66 52 e0 	mov	r6,21216
8000b7ea:	14 9b       	mov	r11,r10
8000b7ec:	8d 08       	st.w	r6[0x0],r8
8000b7ee:	fe b0 df 55 	rcall	80007698 <_fstat>
8000b7f2:	5b fc       	cp.w	r12,-1
8000b7f4:	c0 51       	brne	8000b7fe <_fstat_r+0x22>
8000b7f6:	6c 08       	ld.w	r8,r6[0x0]
8000b7f8:	58 08       	cp.w	r8,0
8000b7fa:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b7fe:	d8 22       	popm	r4-r7,pc

8000b800 <_lseek_r>:
8000b800:	d4 21       	pushm	r4-r7,lr
8000b802:	16 98       	mov	r8,r11
8000b804:	18 97       	mov	r7,r12
8000b806:	10 9c       	mov	r12,r8
8000b808:	30 08       	mov	r8,0
8000b80a:	14 9b       	mov	r11,r10
8000b80c:	e0 66 52 e0 	mov	r6,21216
8000b810:	12 9a       	mov	r10,r9
8000b812:	8d 08       	st.w	r6[0x0],r8
8000b814:	fe b0 df 24 	rcall	8000765c <_lseek>
8000b818:	5b fc       	cp.w	r12,-1
8000b81a:	c0 51       	brne	8000b824 <_lseek_r+0x24>
8000b81c:	6c 08       	ld.w	r8,r6[0x0]
8000b81e:	58 08       	cp.w	r8,0
8000b820:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b824:	d8 22       	popm	r4-r7,pc
8000b826:	d7 03       	nop

8000b828 <_read_r>:
8000b828:	d4 21       	pushm	r4-r7,lr
8000b82a:	16 98       	mov	r8,r11
8000b82c:	18 97       	mov	r7,r12
8000b82e:	10 9c       	mov	r12,r8
8000b830:	30 08       	mov	r8,0
8000b832:	14 9b       	mov	r11,r10
8000b834:	e0 66 52 e0 	mov	r6,21216
8000b838:	12 9a       	mov	r10,r9
8000b83a:	8d 08       	st.w	r6[0x0],r8
8000b83c:	fe b0 d0 04 	rcall	80005844 <_read>
8000b840:	5b fc       	cp.w	r12,-1
8000b842:	c0 51       	brne	8000b84c <_read_r+0x24>
8000b844:	6c 08       	ld.w	r8,r6[0x0]
8000b846:	58 08       	cp.w	r8,0
8000b848:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b84c:	d8 22       	popm	r4-r7,pc
8000b84e:	d7 03       	nop

8000b850 <__avr32_f64_mul>:
8000b850:	f5 eb 10 1c 	or	r12,r10,r11<<0x1
8000b854:	e0 80 00 dc 	breq	8000ba0c <__avr32_f64_mul_op1_zero>
8000b858:	d4 21       	pushm	r4-r7,lr
8000b85a:	f7 e9 20 0e 	eor	lr,r11,r9
8000b85e:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000b862:	30 15       	mov	r5,1
8000b864:	c4 30       	breq	8000b8ea <__avr32_f64_mul_op1_subnormal>
8000b866:	ab 6b       	lsl	r11,0xa
8000b868:	f7 ea 13 6b 	or	r11,r11,r10>>0x16
8000b86c:	ab 6a       	lsl	r10,0xa
8000b86e:	f7 d5 d3 c2 	bfins	r11,r5,0x1e,0x2
8000b872:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000b876:	c5 c0       	breq	8000b92e <__avr32_f64_mul_op2_subnormal>
8000b878:	a1 78       	lsl	r8,0x1
8000b87a:	5c f9       	rol	r9
8000b87c:	f3 d5 d2 ab 	bfins	r9,r5,0x15,0xb
8000b880:	e0 47 07 ff 	cp.w	r7,2047
8000b884:	c7 70       	breq	8000b972 <__avr32_f64_mul_op_nan_or_inf>
8000b886:	e0 46 07 ff 	cp.w	r6,2047
8000b88a:	c7 40       	breq	8000b972 <__avr32_f64_mul_op_nan_or_inf>
8000b88c:	ee 06 00 0c 	add	r12,r7,r6
8000b890:	e0 2c 03 fe 	sub	r12,1022
8000b894:	f6 08 06 44 	mulu.d	r4,r11,r8
8000b898:	f4 09 07 44 	macu.d	r4,r10,r9
8000b89c:	f4 08 06 46 	mulu.d	r6,r10,r8
8000b8a0:	f6 09 06 4a 	mulu.d	r10,r11,r9
8000b8a4:	08 07       	add	r7,r4
8000b8a6:	f4 05 00 4a 	adc	r10,r10,r5
8000b8aa:	5c 0b       	acr	r11
8000b8ac:	ed bb 00 14 	bld	r11,0x14
8000b8b0:	c0 50       	breq	8000b8ba <__avr32_f64_mul+0x6a>
8000b8b2:	a1 77       	lsl	r7,0x1
8000b8b4:	5c fa       	rol	r10
8000b8b6:	5c fb       	rol	r11
8000b8b8:	20 1c       	sub	r12,1
8000b8ba:	58 0c       	cp.w	r12,0
8000b8bc:	e0 8a 00 6f 	brle	8000b99a <__avr32_f64_mul_res_subnormal>
8000b8c0:	e0 4c 07 ff 	cp.w	r12,2047
8000b8c4:	e0 84 00 9c 	brge	8000b9fc <__avr32_f64_mul_res_inf>
8000b8c8:	f7 dc d2 8b 	bfins	r11,r12,0x14,0xb
8000b8cc:	ed ea 11 f6 	or	r6,r6,r10<<0x1f
8000b8d0:	ef e6 12 17 	or	r7,r7,r6>>0x1
8000b8d4:	ee 17 80 00 	eorh	r7,0x8000
8000b8d8:	f1 b7 04 20 	satu	r7,0x1
8000b8dc:	0e 0a       	add	r10,r7
8000b8de:	5c 0b       	acr	r11
8000b8e0:	ed be 00 1f 	bld	lr,0x1f
8000b8e4:	ef bb 00 1f 	bst	r11,0x1f
8000b8e8:	d8 22       	popm	r4-r7,pc

8000b8ea <__avr32_f64_mul_op1_subnormal>:
8000b8ea:	e4 1b 00 0f 	andh	r11,0xf
8000b8ee:	f4 0c 12 00 	clz	r12,r10
8000b8f2:	f6 06 12 00 	clz	r6,r11
8000b8f6:	f7 bc 03 e1 	sublo	r12,-31
8000b8fa:	f8 06 17 30 	movlo	r6,r12
8000b8fe:	f7 b6 02 01 	subhs	r6,1
8000b902:	e0 46 00 20 	cp.w	r6,32
8000b906:	c0 d4       	brge	8000b920 <__avr32_f64_mul_op1_subnormal+0x36>
8000b908:	ec 0c 11 20 	rsub	r12,r6,32
8000b90c:	f6 06 09 4b 	lsl	r11,r11,r6
8000b910:	f4 0c 0a 4c 	lsr	r12,r10,r12
8000b914:	18 4b       	or	r11,r12
8000b916:	f4 06 09 4a 	lsl	r10,r10,r6
8000b91a:	20 b6       	sub	r6,11
8000b91c:	0c 17       	sub	r7,r6
8000b91e:	ca ab       	rjmp	8000b872 <__avr32_f64_mul+0x22>
8000b920:	f4 06 09 4b 	lsl	r11,r10,r6
8000b924:	c6 40       	breq	8000b9ec <__avr32_f64_mul_res_zero>
8000b926:	30 0a       	mov	r10,0
8000b928:	20 b6       	sub	r6,11
8000b92a:	0c 17       	sub	r7,r6
8000b92c:	ca 3b       	rjmp	8000b872 <__avr32_f64_mul+0x22>

8000b92e <__avr32_f64_mul_op2_subnormal>:
8000b92e:	e4 19 00 0f 	andh	r9,0xf
8000b932:	f0 0c 12 00 	clz	r12,r8
8000b936:	f2 05 12 00 	clz	r5,r9
8000b93a:	f7 bc 03 ea 	sublo	r12,-22
8000b93e:	f8 05 17 30 	movlo	r5,r12
8000b942:	f7 b5 02 0a 	subhs	r5,10
8000b946:	e0 45 00 20 	cp.w	r5,32
8000b94a:	c0 d4       	brge	8000b964 <__avr32_f64_mul_op2_subnormal+0x36>
8000b94c:	ea 0c 11 20 	rsub	r12,r5,32
8000b950:	f2 05 09 49 	lsl	r9,r9,r5
8000b954:	f0 0c 0a 4c 	lsr	r12,r8,r12
8000b958:	18 49       	or	r9,r12
8000b95a:	f0 05 09 48 	lsl	r8,r8,r5
8000b95e:	20 25       	sub	r5,2
8000b960:	0a 16       	sub	r6,r5
8000b962:	c8 fb       	rjmp	8000b880 <__avr32_f64_mul+0x30>
8000b964:	f0 05 09 49 	lsl	r9,r8,r5
8000b968:	c4 20       	breq	8000b9ec <__avr32_f64_mul_res_zero>
8000b96a:	30 08       	mov	r8,0
8000b96c:	20 25       	sub	r5,2
8000b96e:	0a 16       	sub	r6,r5
8000b970:	c8 8b       	rjmp	8000b880 <__avr32_f64_mul+0x30>

8000b972 <__avr32_f64_mul_op_nan_or_inf>:
8000b972:	e4 19 00 0f 	andh	r9,0xf
8000b976:	e4 1b 00 0f 	andh	r11,0xf
8000b97a:	14 4b       	or	r11,r10
8000b97c:	10 49       	or	r9,r8
8000b97e:	e0 47 07 ff 	cp.w	r7,2047
8000b982:	c0 91       	brne	8000b994 <__avr32_f64_mul_op1_not_naninf>
8000b984:	58 0b       	cp.w	r11,0
8000b986:	c3 81       	brne	8000b9f6 <__avr32_f64_mul_res_nan>
8000b988:	e0 46 07 ff 	cp.w	r6,2047
8000b98c:	c3 81       	brne	8000b9fc <__avr32_f64_mul_res_inf>
8000b98e:	58 09       	cp.w	r9,0
8000b990:	c3 60       	breq	8000b9fc <__avr32_f64_mul_res_inf>
8000b992:	c3 28       	rjmp	8000b9f6 <__avr32_f64_mul_res_nan>

8000b994 <__avr32_f64_mul_op1_not_naninf>:
8000b994:	58 09       	cp.w	r9,0
8000b996:	c3 30       	breq	8000b9fc <__avr32_f64_mul_res_inf>
8000b998:	c2 f8       	rjmp	8000b9f6 <__avr32_f64_mul_res_nan>

8000b99a <__avr32_f64_mul_res_subnormal>:
8000b99a:	5c 3c       	neg	r12
8000b99c:	2f fc       	sub	r12,-1
8000b99e:	f1 bc 04 c0 	satu	r12,0x6
8000b9a2:	e0 4c 00 20 	cp.w	r12,32
8000b9a6:	c1 14       	brge	8000b9c8 <__avr32_f64_mul_res_subnormal+0x2e>
8000b9a8:	f8 08 11 20 	rsub	r8,r12,32
8000b9ac:	0e 46       	or	r6,r7
8000b9ae:	ee 0c 0a 47 	lsr	r7,r7,r12
8000b9b2:	f4 08 09 49 	lsl	r9,r10,r8
8000b9b6:	12 47       	or	r7,r9
8000b9b8:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000b9bc:	f6 08 09 49 	lsl	r9,r11,r8
8000b9c0:	12 4a       	or	r10,r9
8000b9c2:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000b9c6:	c8 3b       	rjmp	8000b8cc <__avr32_f64_mul+0x7c>
8000b9c8:	f8 08 11 20 	rsub	r8,r12,32
8000b9cc:	f9 b9 00 00 	moveq	r9,0
8000b9d0:	c0 30       	breq	8000b9d6 <__avr32_f64_mul_res_subnormal+0x3c>
8000b9d2:	f6 08 09 49 	lsl	r9,r11,r8
8000b9d6:	0e 46       	or	r6,r7
8000b9d8:	ed ea 10 16 	or	r6,r6,r10<<0x1
8000b9dc:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000b9e0:	f3 ea 10 07 	or	r7,r9,r10
8000b9e4:	f6 0c 0a 4a 	lsr	r10,r11,r12
8000b9e8:	30 0b       	mov	r11,0
8000b9ea:	c7 1b       	rjmp	8000b8cc <__avr32_f64_mul+0x7c>

8000b9ec <__avr32_f64_mul_res_zero>:
8000b9ec:	1c 9b       	mov	r11,lr
8000b9ee:	e6 1b 80 00 	andh	r11,0x8000,COH
8000b9f2:	30 0a       	mov	r10,0
8000b9f4:	d8 22       	popm	r4-r7,pc

8000b9f6 <__avr32_f64_mul_res_nan>:
8000b9f6:	3f fb       	mov	r11,-1
8000b9f8:	3f fa       	mov	r10,-1
8000b9fa:	d8 22       	popm	r4-r7,pc

8000b9fc <__avr32_f64_mul_res_inf>:
8000b9fc:	f0 6b 00 00 	mov	r11,-1048576
8000ba00:	ed be 00 1f 	bld	lr,0x1f
8000ba04:	ef bb 00 1f 	bst	r11,0x1f
8000ba08:	30 0a       	mov	r10,0
8000ba0a:	d8 22       	popm	r4-r7,pc

8000ba0c <__avr32_f64_mul_op1_zero>:
8000ba0c:	f7 e9 20 0b 	eor	r11,r11,r9
8000ba10:	e6 1b 80 00 	andh	r11,0x8000,COH
8000ba14:	f9 d9 c2 8b 	bfextu	r12,r9,0x14,0xb
8000ba18:	e0 4c 07 ff 	cp.w	r12,2047
8000ba1c:	5e 1c       	retne	r12
8000ba1e:	3f fa       	mov	r10,-1
8000ba20:	3f fb       	mov	r11,-1
8000ba22:	5e fc       	retal	r12

8000ba24 <__avr32_f64_sub_from_add>:
8000ba24:	ee 19 80 00 	eorh	r9,0x8000

8000ba28 <__avr32_f64_sub>:
8000ba28:	f7 e9 20 0c 	eor	r12,r11,r9
8000ba2c:	e0 86 00 ca 	brmi	8000bbc0 <__avr32_f64_add_from_sub>
8000ba30:	eb cd 40 e0 	pushm	r5-r7,lr
8000ba34:	16 9c       	mov	r12,r11
8000ba36:	e6 1c 80 00 	andh	r12,0x8000,COH
8000ba3a:	bf db       	cbr	r11,0x1f
8000ba3c:	bf d9       	cbr	r9,0x1f
8000ba3e:	10 3a       	cp.w	r10,r8
8000ba40:	f2 0b 13 00 	cpc	r11,r9
8000ba44:	c0 92       	brcc	8000ba56 <__avr32_f64_sub+0x2e>
8000ba46:	16 97       	mov	r7,r11
8000ba48:	12 9b       	mov	r11,r9
8000ba4a:	0e 99       	mov	r9,r7
8000ba4c:	14 97       	mov	r7,r10
8000ba4e:	10 9a       	mov	r10,r8
8000ba50:	0e 98       	mov	r8,r7
8000ba52:	ee 1c 80 00 	eorh	r12,0x8000
8000ba56:	f6 07 16 14 	lsr	r7,r11,0x14
8000ba5a:	ab 7b       	lsl	r11,0xb
8000ba5c:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000ba60:	ab 7a       	lsl	r10,0xb
8000ba62:	bf bb       	sbr	r11,0x1f
8000ba64:	f2 06 16 14 	lsr	r6,r9,0x14
8000ba68:	c4 40       	breq	8000baf0 <__avr32_f64_sub_opL_subnormal>
8000ba6a:	ab 79       	lsl	r9,0xb
8000ba6c:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000ba70:	ab 78       	lsl	r8,0xb
8000ba72:	bf b9       	sbr	r9,0x1f

8000ba74 <__avr32_f64_sub_opL_subnormal_done>:
8000ba74:	e0 47 07 ff 	cp.w	r7,2047
8000ba78:	c4 f0       	breq	8000bb16 <__avr32_f64_sub_opH_nan_or_inf>
8000ba7a:	0e 26       	rsub	r6,r7
8000ba7c:	c1 20       	breq	8000baa0 <__avr32_f64_sub_shift_done>
8000ba7e:	ec 05 11 20 	rsub	r5,r6,32
8000ba82:	e0 46 00 20 	cp.w	r6,32
8000ba86:	c7 c2       	brcc	8000bb7e <__avr32_f64_sub_longshift>
8000ba88:	f0 05 09 4e 	lsl	lr,r8,r5
8000ba8c:	f2 05 09 45 	lsl	r5,r9,r5
8000ba90:	f0 06 0a 48 	lsr	r8,r8,r6
8000ba94:	f2 06 0a 49 	lsr	r9,r9,r6
8000ba98:	0a 48       	or	r8,r5
8000ba9a:	58 0e       	cp.w	lr,0
8000ba9c:	5f 1e       	srne	lr
8000ba9e:	1c 48       	or	r8,lr

8000baa0 <__avr32_f64_sub_shift_done>:
8000baa0:	10 1a       	sub	r10,r8
8000baa2:	f6 09 01 4b 	sbc	r11,r11,r9
8000baa6:	f6 06 12 00 	clz	r6,r11
8000baaa:	c0 e0       	breq	8000bac6 <__avr32_f64_sub_longnormalize_done>
8000baac:	c7 83       	brcs	8000bb9c <__avr32_f64_sub_longnormalize>
8000baae:	ec 0e 11 20 	rsub	lr,r6,32
8000bab2:	f6 06 09 4b 	lsl	r11,r11,r6
8000bab6:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000baba:	1c 4b       	or	r11,lr
8000babc:	f4 06 09 4a 	lsl	r10,r10,r6
8000bac0:	0c 17       	sub	r7,r6
8000bac2:	e0 8a 00 39 	brle	8000bb34 <__avr32_f64_sub_subnormal_result>

8000bac6 <__avr32_f64_sub_longnormalize_done>:
8000bac6:	f4 09 15 15 	lsl	r9,r10,0x15
8000baca:	ab 9a       	lsr	r10,0xb
8000bacc:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000bad0:	ab 9b       	lsr	r11,0xb
8000bad2:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000bad6:	18 4b       	or	r11,r12

8000bad8 <__avr32_f64_sub_round>:
8000bad8:	fc 17 80 00 	movh	r7,0x8000
8000badc:	ed ba 00 00 	bld	r10,0x0
8000bae0:	f7 b7 01 ff 	subne	r7,-1
8000bae4:	0e 39       	cp.w	r9,r7
8000bae6:	5f 29       	srhs	r9
8000bae8:	12 0a       	add	r10,r9
8000baea:	5c 0b       	acr	r11
8000baec:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000baf0 <__avr32_f64_sub_opL_subnormal>:
8000baf0:	ab 79       	lsl	r9,0xb
8000baf2:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000baf6:	ab 78       	lsl	r8,0xb
8000baf8:	f3 e8 10 0e 	or	lr,r9,r8
8000bafc:	f9 b6 01 01 	movne	r6,1
8000bb00:	ee 0e 11 00 	rsub	lr,r7,0
8000bb04:	f9 b7 00 01 	moveq	r7,1
8000bb08:	ef bb 00 1f 	bst	r11,0x1f
8000bb0c:	f7 ea 10 0e 	or	lr,r11,r10
8000bb10:	f9 b7 00 00 	moveq	r7,0
8000bb14:	cb 0b       	rjmp	8000ba74 <__avr32_f64_sub_opL_subnormal_done>

8000bb16 <__avr32_f64_sub_opH_nan_or_inf>:
8000bb16:	bf db       	cbr	r11,0x1f
8000bb18:	f7 ea 10 0e 	or	lr,r11,r10
8000bb1c:	c0 81       	brne	8000bb2c <__avr32_f64_sub_return_nan>
8000bb1e:	e0 46 07 ff 	cp.w	r6,2047
8000bb22:	c0 50       	breq	8000bb2c <__avr32_f64_sub_return_nan>
8000bb24:	f9 e7 11 4b 	or	r11,r12,r7<<0x14
8000bb28:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bb2c <__avr32_f64_sub_return_nan>:
8000bb2c:	3f fa       	mov	r10,-1
8000bb2e:	3f fb       	mov	r11,-1
8000bb30:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bb34 <__avr32_f64_sub_subnormal_result>:
8000bb34:	5c 37       	neg	r7
8000bb36:	2f f7       	sub	r7,-1
8000bb38:	f1 b7 04 c0 	satu	r7,0x6
8000bb3c:	e0 47 00 20 	cp.w	r7,32
8000bb40:	c1 14       	brge	8000bb62 <__avr32_f64_sub_subnormal_result+0x2e>
8000bb42:	ee 08 11 20 	rsub	r8,r7,32
8000bb46:	f4 08 09 49 	lsl	r9,r10,r8
8000bb4a:	5f 16       	srne	r6
8000bb4c:	f4 07 0a 4a 	lsr	r10,r10,r7
8000bb50:	0c 4a       	or	r10,r6
8000bb52:	f6 08 09 49 	lsl	r9,r11,r8
8000bb56:	f5 e9 10 0a 	or	r10,r10,r9
8000bb5a:	f4 07 0a 4b 	lsr	r11,r10,r7
8000bb5e:	30 07       	mov	r7,0
8000bb60:	cb 3b       	rjmp	8000bac6 <__avr32_f64_sub_longnormalize_done>
8000bb62:	ee 08 11 40 	rsub	r8,r7,64
8000bb66:	f6 08 09 49 	lsl	r9,r11,r8
8000bb6a:	14 49       	or	r9,r10
8000bb6c:	5f 16       	srne	r6
8000bb6e:	f6 07 0a 4a 	lsr	r10,r11,r7
8000bb72:	0c 4a       	or	r10,r6
8000bb74:	30 0b       	mov	r11,0
8000bb76:	30 07       	mov	r7,0
8000bb78:	ca 7b       	rjmp	8000bac6 <__avr32_f64_sub_longnormalize_done>
8000bb7a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bb7e <__avr32_f64_sub_longshift>:
8000bb7e:	f1 b6 04 c0 	satu	r6,0x6
8000bb82:	f0 0e 17 00 	moveq	lr,r8
8000bb86:	c0 40       	breq	8000bb8e <__avr32_f64_sub_longshift+0x10>
8000bb88:	f2 05 09 4e 	lsl	lr,r9,r5
8000bb8c:	10 4e       	or	lr,r8
8000bb8e:	f2 06 0a 48 	lsr	r8,r9,r6
8000bb92:	30 09       	mov	r9,0
8000bb94:	58 0e       	cp.w	lr,0
8000bb96:	5f 1e       	srne	lr
8000bb98:	1c 48       	or	r8,lr
8000bb9a:	c8 3b       	rjmp	8000baa0 <__avr32_f64_sub_shift_done>

8000bb9c <__avr32_f64_sub_longnormalize>:
8000bb9c:	f4 06 12 00 	clz	r6,r10
8000bba0:	f9 b7 03 00 	movlo	r7,0
8000bba4:	f9 b6 03 00 	movlo	r6,0
8000bba8:	f9 bc 03 00 	movlo	r12,0
8000bbac:	f7 b6 02 e0 	subhs	r6,-32
8000bbb0:	f4 06 09 4b 	lsl	r11,r10,r6
8000bbb4:	30 0a       	mov	r10,0
8000bbb6:	0c 17       	sub	r7,r6
8000bbb8:	fe 9a ff be 	brle	8000bb34 <__avr32_f64_sub_subnormal_result>
8000bbbc:	c8 5b       	rjmp	8000bac6 <__avr32_f64_sub_longnormalize_done>
8000bbbe:	d7 03       	nop

8000bbc0 <__avr32_f64_add_from_sub>:
8000bbc0:	ee 19 80 00 	eorh	r9,0x8000

8000bbc4 <__avr32_f64_add>:
8000bbc4:	f7 e9 20 0c 	eor	r12,r11,r9
8000bbc8:	fe 96 ff 2e 	brmi	8000ba24 <__avr32_f64_sub_from_add>
8000bbcc:	eb cd 40 e0 	pushm	r5-r7,lr
8000bbd0:	16 9c       	mov	r12,r11
8000bbd2:	e6 1c 80 00 	andh	r12,0x8000,COH
8000bbd6:	bf db       	cbr	r11,0x1f
8000bbd8:	bf d9       	cbr	r9,0x1f
8000bbda:	12 3b       	cp.w	r11,r9
8000bbdc:	c0 72       	brcc	8000bbea <__avr32_f64_add+0x26>
8000bbde:	16 97       	mov	r7,r11
8000bbe0:	12 9b       	mov	r11,r9
8000bbe2:	0e 99       	mov	r9,r7
8000bbe4:	14 97       	mov	r7,r10
8000bbe6:	10 9a       	mov	r10,r8
8000bbe8:	0e 98       	mov	r8,r7
8000bbea:	30 0e       	mov	lr,0
8000bbec:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000bbf0:	f7 db c0 14 	bfextu	r11,r11,0x0,0x14
8000bbf4:	b5 ab       	sbr	r11,0x14
8000bbf6:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000bbfa:	c6 20       	breq	8000bcbe <__avr32_f64_add_op2_subnormal>
8000bbfc:	f3 d9 c0 14 	bfextu	r9,r9,0x0,0x14
8000bc00:	b5 a9       	sbr	r9,0x14
8000bc02:	e0 47 07 ff 	cp.w	r7,2047
8000bc06:	c2 80       	breq	8000bc56 <__avr32_f64_add_opH_nan_or_inf>
8000bc08:	0e 26       	rsub	r6,r7
8000bc0a:	c1 20       	breq	8000bc2e <__avr32_f64_add_shift_done>
8000bc0c:	e0 46 00 36 	cp.w	r6,54
8000bc10:	c1 52       	brcc	8000bc3a <__avr32_f64_add_res_of_done>
8000bc12:	ec 05 11 20 	rsub	r5,r6,32
8000bc16:	e0 46 00 20 	cp.w	r6,32
8000bc1a:	c3 52       	brcc	8000bc84 <__avr32_f64_add_longshift>
8000bc1c:	f0 05 09 4e 	lsl	lr,r8,r5
8000bc20:	f2 05 09 45 	lsl	r5,r9,r5
8000bc24:	f0 06 0a 48 	lsr	r8,r8,r6
8000bc28:	f2 06 0a 49 	lsr	r9,r9,r6
8000bc2c:	0a 48       	or	r8,r5

8000bc2e <__avr32_f64_add_shift_done>:
8000bc2e:	10 0a       	add	r10,r8
8000bc30:	f6 09 00 4b 	adc	r11,r11,r9
8000bc34:	ed bb 00 15 	bld	r11,0x15
8000bc38:	c3 40       	breq	8000bca0 <__avr32_f64_add_res_of>

8000bc3a <__avr32_f64_add_res_of_done>:
8000bc3a:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000bc3e:	18 4b       	or	r11,r12

8000bc40 <__avr32_f64_add_round>:
8000bc40:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
8000bc44:	18 4e       	or	lr,r12
8000bc46:	ee 1e 80 00 	eorh	lr,0x8000
8000bc4a:	f1 be 04 20 	satu	lr,0x1
8000bc4e:	1c 0a       	add	r10,lr
8000bc50:	5c 0b       	acr	r11
8000bc52:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bc56 <__avr32_f64_add_opH_nan_or_inf>:
8000bc56:	b5 cb       	cbr	r11,0x14
8000bc58:	f7 ea 10 0e 	or	lr,r11,r10
8000bc5c:	c1 01       	brne	8000bc7c <__avr32_f64_add_return_nan>
8000bc5e:	e0 46 07 ff 	cp.w	r6,2047
8000bc62:	c0 30       	breq	8000bc68 <__avr32_f64_add_opL_nan_or_inf>
8000bc64:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bc68 <__avr32_f64_add_opL_nan_or_inf>:
8000bc68:	b5 c9       	cbr	r9,0x14
8000bc6a:	f3 e8 10 0e 	or	lr,r9,r8
8000bc6e:	c0 71       	brne	8000bc7c <__avr32_f64_add_return_nan>
8000bc70:	30 0a       	mov	r10,0
8000bc72:	fc 1b 7f f0 	movh	r11,0x7ff0
8000bc76:	18 4b       	or	r11,r12
8000bc78:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bc7c <__avr32_f64_add_return_nan>:
8000bc7c:	3f fa       	mov	r10,-1
8000bc7e:	3f fb       	mov	r11,-1
8000bc80:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bc84 <__avr32_f64_add_longshift>:
8000bc84:	f1 b6 04 c0 	satu	r6,0x6
8000bc88:	f0 0e 17 00 	moveq	lr,r8
8000bc8c:	c0 60       	breq	8000bc98 <__avr32_f64_add_longshift+0x14>
8000bc8e:	f2 05 09 4e 	lsl	lr,r9,r5
8000bc92:	58 08       	cp.w	r8,0
8000bc94:	5f 18       	srne	r8
8000bc96:	10 4e       	or	lr,r8
8000bc98:	f2 06 0a 48 	lsr	r8,r9,r6
8000bc9c:	30 09       	mov	r9,0
8000bc9e:	cc 8b       	rjmp	8000bc2e <__avr32_f64_add_shift_done>

8000bca0 <__avr32_f64_add_res_of>:
8000bca0:	fd ee 10 1e 	or	lr,lr,lr<<0x1
8000bca4:	a1 9b       	lsr	r11,0x1
8000bca6:	5d 0a       	ror	r10
8000bca8:	5d 0e       	ror	lr
8000bcaa:	2f f7       	sub	r7,-1
8000bcac:	e0 47 07 ff 	cp.w	r7,2047
8000bcb0:	f9 ba 00 00 	moveq	r10,0
8000bcb4:	f9 bb 00 00 	moveq	r11,0
8000bcb8:	f9 be 00 00 	moveq	lr,0
8000bcbc:	cb fb       	rjmp	8000bc3a <__avr32_f64_add_res_of_done>

8000bcbe <__avr32_f64_add_op2_subnormal>:
8000bcbe:	30 16       	mov	r6,1
8000bcc0:	58 07       	cp.w	r7,0
8000bcc2:	ca 01       	brne	8000bc02 <__avr32_f64_add+0x3e>
8000bcc4:	b5 cb       	cbr	r11,0x14
8000bcc6:	10 0a       	add	r10,r8
8000bcc8:	f6 09 00 4b 	adc	r11,r11,r9
8000bccc:	18 4b       	or	r11,r12
8000bcce:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000bcd2:	d7 03       	nop

8000bcd4 <__avr32_f64_to_u32>:
8000bcd4:	58 0b       	cp.w	r11,0
8000bcd6:	5e 6d       	retmi	0

8000bcd8 <__avr32_f64_to_s32>:
8000bcd8:	f6 0c 15 01 	lsl	r12,r11,0x1
8000bcdc:	b5 9c       	lsr	r12,0x15
8000bcde:	e0 2c 03 ff 	sub	r12,1023
8000bce2:	5e 3d       	retlo	0
8000bce4:	f8 0c 11 1f 	rsub	r12,r12,31
8000bce8:	16 99       	mov	r9,r11
8000bcea:	ab 7b       	lsl	r11,0xb
8000bcec:	bf bb       	sbr	r11,0x1f
8000bcee:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000bcf2:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000bcf6:	a1 79       	lsl	r9,0x1
8000bcf8:	5e 2b       	reths	r11
8000bcfa:	5c 3b       	neg	r11
8000bcfc:	5e fb       	retal	r11

8000bcfe <__avr32_u32_to_f64>:
8000bcfe:	f8 cb 00 00 	sub	r11,r12,0
8000bd02:	30 0c       	mov	r12,0
8000bd04:	c0 38       	rjmp	8000bd0a <__avr32_s32_to_f64+0x4>

8000bd06 <__avr32_s32_to_f64>:
8000bd06:	18 9b       	mov	r11,r12
8000bd08:	5c 4b       	abs	r11
8000bd0a:	30 0a       	mov	r10,0
8000bd0c:	5e 0b       	reteq	r11
8000bd0e:	d4 01       	pushm	lr
8000bd10:	e0 69 04 1e 	mov	r9,1054
8000bd14:	f6 08 12 00 	clz	r8,r11
8000bd18:	c1 70       	breq	8000bd46 <__avr32_s32_to_f64+0x40>
8000bd1a:	c0 c3       	brcs	8000bd32 <__avr32_s32_to_f64+0x2c>
8000bd1c:	f0 0e 11 20 	rsub	lr,r8,32
8000bd20:	f6 08 09 4b 	lsl	r11,r11,r8
8000bd24:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000bd28:	1c 4b       	or	r11,lr
8000bd2a:	f4 08 09 4a 	lsl	r10,r10,r8
8000bd2e:	10 19       	sub	r9,r8
8000bd30:	c0 b8       	rjmp	8000bd46 <__avr32_s32_to_f64+0x40>
8000bd32:	f4 08 12 00 	clz	r8,r10
8000bd36:	f9 b8 03 00 	movlo	r8,0
8000bd3a:	f7 b8 02 e0 	subhs	r8,-32
8000bd3e:	f4 08 09 4b 	lsl	r11,r10,r8
8000bd42:	30 0a       	mov	r10,0
8000bd44:	10 19       	sub	r9,r8
8000bd46:	58 09       	cp.w	r9,0
8000bd48:	e0 89 00 30 	brgt	8000bda8 <__avr32_s32_to_f64+0xa2>
8000bd4c:	5c 39       	neg	r9
8000bd4e:	2f f9       	sub	r9,-1
8000bd50:	e0 49 00 36 	cp.w	r9,54
8000bd54:	c0 43       	brcs	8000bd5c <__avr32_s32_to_f64+0x56>
8000bd56:	30 0b       	mov	r11,0
8000bd58:	30 0a       	mov	r10,0
8000bd5a:	c2 68       	rjmp	8000bda6 <__avr32_s32_to_f64+0xa0>
8000bd5c:	2f 69       	sub	r9,-10
8000bd5e:	f2 08 11 20 	rsub	r8,r9,32
8000bd62:	e0 49 00 20 	cp.w	r9,32
8000bd66:	c0 b2       	brcc	8000bd7c <__avr32_s32_to_f64+0x76>
8000bd68:	f4 08 09 4e 	lsl	lr,r10,r8
8000bd6c:	f6 08 09 48 	lsl	r8,r11,r8
8000bd70:	f4 09 0a 4a 	lsr	r10,r10,r9
8000bd74:	f6 09 0a 4b 	lsr	r11,r11,r9
8000bd78:	10 4b       	or	r11,r8
8000bd7a:	c0 88       	rjmp	8000bd8a <__avr32_s32_to_f64+0x84>
8000bd7c:	f6 08 09 4e 	lsl	lr,r11,r8
8000bd80:	14 4e       	or	lr,r10
8000bd82:	16 9a       	mov	r10,r11
8000bd84:	30 0b       	mov	r11,0
8000bd86:	f4 09 0a 4a 	lsr	r10,r10,r9
8000bd8a:	ed ba 00 00 	bld	r10,0x0
8000bd8e:	c0 92       	brcc	8000bda0 <__avr32_s32_to_f64+0x9a>
8000bd90:	1c 7e       	tst	lr,lr
8000bd92:	c0 41       	brne	8000bd9a <__avr32_s32_to_f64+0x94>
8000bd94:	ed ba 00 01 	bld	r10,0x1
8000bd98:	c0 42       	brcc	8000bda0 <__avr32_s32_to_f64+0x9a>
8000bd9a:	2f fa       	sub	r10,-1
8000bd9c:	f7 bb 02 ff 	subhs	r11,-1
8000bda0:	5c fc       	rol	r12
8000bda2:	5d 0b       	ror	r11
8000bda4:	5d 0a       	ror	r10
8000bda6:	d8 02       	popm	pc
8000bda8:	e0 68 03 ff 	mov	r8,1023
8000bdac:	ed ba 00 0b 	bld	r10,0xb
8000bdb0:	f7 b8 00 ff 	subeq	r8,-1
8000bdb4:	10 0a       	add	r10,r8
8000bdb6:	5c 0b       	acr	r11
8000bdb8:	f7 b9 03 fe 	sublo	r9,-2
8000bdbc:	e0 49 07 ff 	cp.w	r9,2047
8000bdc0:	c0 55       	brlt	8000bdca <__avr32_s32_to_f64+0xc4>
8000bdc2:	30 0a       	mov	r10,0
8000bdc4:	fc 1b ff e0 	movh	r11,0xffe0
8000bdc8:	c0 c8       	rjmp	8000bde0 <__floatsidf_return_op1>
8000bdca:	ed bb 00 1f 	bld	r11,0x1f
8000bdce:	f7 b9 01 01 	subne	r9,1
8000bdd2:	ab 9a       	lsr	r10,0xb
8000bdd4:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000bdd8:	a1 7b       	lsl	r11,0x1
8000bdda:	ab 9b       	lsr	r11,0xb
8000bddc:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

8000bde0 <__floatsidf_return_op1>:
8000bde0:	a1 7c       	lsl	r12,0x1
8000bde2:	5d 0b       	ror	r11
8000bde4:	d8 02       	popm	pc

8000bde6 <__avr32_f64_cmp_eq>:
8000bde6:	10 3a       	cp.w	r10,r8
8000bde8:	f2 0b 13 00 	cpc	r11,r9
8000bdec:	c0 80       	breq	8000bdfc <__avr32_f64_cmp_eq+0x16>
8000bdee:	a1 7b       	lsl	r11,0x1
8000bdf0:	a1 79       	lsl	r9,0x1
8000bdf2:	14 4b       	or	r11,r10
8000bdf4:	12 4b       	or	r11,r9
8000bdf6:	10 4b       	or	r11,r8
8000bdf8:	5e 0f       	reteq	1
8000bdfa:	5e fd       	retal	0
8000bdfc:	a1 7b       	lsl	r11,0x1
8000bdfe:	fc 1c ff e0 	movh	r12,0xffe0
8000be02:	58 0a       	cp.w	r10,0
8000be04:	f8 0b 13 00 	cpc	r11,r12
8000be08:	5e 8f       	retls	1
8000be0a:	5e fd       	retal	0

8000be0c <__avr32_f64_cmp_ge>:
8000be0c:	1a de       	st.w	--sp,lr
8000be0e:	1a d7       	st.w	--sp,r7
8000be10:	a1 7b       	lsl	r11,0x1
8000be12:	5f 3c       	srlo	r12
8000be14:	a1 79       	lsl	r9,0x1
8000be16:	5f 37       	srlo	r7
8000be18:	5c fc       	rol	r12
8000be1a:	fc 1e ff e0 	movh	lr,0xffe0
8000be1e:	58 0a       	cp.w	r10,0
8000be20:	fc 0b 13 00 	cpc	r11,lr
8000be24:	e0 8b 00 1d 	brhi	8000be5e <__avr32_f64_cmp_ge+0x52>
8000be28:	58 08       	cp.w	r8,0
8000be2a:	fc 09 13 00 	cpc	r9,lr
8000be2e:	e0 8b 00 18 	brhi	8000be5e <__avr32_f64_cmp_ge+0x52>
8000be32:	58 0b       	cp.w	r11,0
8000be34:	f5 ba 00 00 	subfeq	r10,0
8000be38:	c1 50       	breq	8000be62 <__avr32_f64_cmp_ge+0x56>
8000be3a:	1b 07       	ld.w	r7,sp++
8000be3c:	1b 0e       	ld.w	lr,sp++
8000be3e:	58 3c       	cp.w	r12,3
8000be40:	c0 a0       	breq	8000be54 <__avr32_f64_cmp_ge+0x48>
8000be42:	58 1c       	cp.w	r12,1
8000be44:	c0 33       	brcs	8000be4a <__avr32_f64_cmp_ge+0x3e>
8000be46:	5e 0f       	reteq	1
8000be48:	5e 1d       	retne	0
8000be4a:	10 3a       	cp.w	r10,r8
8000be4c:	f2 0b 13 00 	cpc	r11,r9
8000be50:	5e 2f       	reths	1
8000be52:	5e 3d       	retlo	0
8000be54:	14 38       	cp.w	r8,r10
8000be56:	f6 09 13 00 	cpc	r9,r11
8000be5a:	5e 2f       	reths	1
8000be5c:	5e 3d       	retlo	0
8000be5e:	1b 07       	ld.w	r7,sp++
8000be60:	d8 0a       	popm	pc,r12=0
8000be62:	58 17       	cp.w	r7,1
8000be64:	5f 0c       	sreq	r12
8000be66:	58 09       	cp.w	r9,0
8000be68:	f5 b8 00 00 	subfeq	r8,0
8000be6c:	1b 07       	ld.w	r7,sp++
8000be6e:	1b 0e       	ld.w	lr,sp++
8000be70:	5e 0f       	reteq	1
8000be72:	5e fc       	retal	r12

8000be74 <__avr32_f64_cmp_lt>:
8000be74:	1a de       	st.w	--sp,lr
8000be76:	1a d7       	st.w	--sp,r7
8000be78:	a1 7b       	lsl	r11,0x1
8000be7a:	5f 3c       	srlo	r12
8000be7c:	a1 79       	lsl	r9,0x1
8000be7e:	5f 37       	srlo	r7
8000be80:	5c fc       	rol	r12
8000be82:	fc 1e ff e0 	movh	lr,0xffe0
8000be86:	58 0a       	cp.w	r10,0
8000be88:	fc 0b 13 00 	cpc	r11,lr
8000be8c:	e0 8b 00 1d 	brhi	8000bec6 <__avr32_f64_cmp_lt+0x52>
8000be90:	58 08       	cp.w	r8,0
8000be92:	fc 09 13 00 	cpc	r9,lr
8000be96:	e0 8b 00 18 	brhi	8000bec6 <__avr32_f64_cmp_lt+0x52>
8000be9a:	58 0b       	cp.w	r11,0
8000be9c:	f5 ba 00 00 	subfeq	r10,0
8000bea0:	c1 50       	breq	8000beca <__avr32_f64_cmp_lt+0x56>
8000bea2:	1b 07       	ld.w	r7,sp++
8000bea4:	1b 0e       	ld.w	lr,sp++
8000bea6:	58 3c       	cp.w	r12,3
8000bea8:	c0 a0       	breq	8000bebc <__avr32_f64_cmp_lt+0x48>
8000beaa:	58 1c       	cp.w	r12,1
8000beac:	c0 33       	brcs	8000beb2 <__avr32_f64_cmp_lt+0x3e>
8000beae:	5e 0d       	reteq	0
8000beb0:	5e 1f       	retne	1
8000beb2:	10 3a       	cp.w	r10,r8
8000beb4:	f2 0b 13 00 	cpc	r11,r9
8000beb8:	5e 2d       	reths	0
8000beba:	5e 3f       	retlo	1
8000bebc:	14 38       	cp.w	r8,r10
8000bebe:	f6 09 13 00 	cpc	r9,r11
8000bec2:	5e 2d       	reths	0
8000bec4:	5e 3f       	retlo	1
8000bec6:	1b 07       	ld.w	r7,sp++
8000bec8:	d8 0a       	popm	pc,r12=0
8000beca:	58 17       	cp.w	r7,1
8000becc:	5f 1c       	srne	r12
8000bece:	58 09       	cp.w	r9,0
8000bed0:	f5 b8 00 00 	subfeq	r8,0
8000bed4:	1b 07       	ld.w	r7,sp++
8000bed6:	1b 0e       	ld.w	lr,sp++
8000bed8:	5e 0d       	reteq	0
8000beda:	5e fc       	retal	r12

8000bedc <__avr32_f64_div>:
8000bedc:	eb cd 40 ff 	pushm	r0-r7,lr
8000bee0:	f7 e9 20 0e 	eor	lr,r11,r9
8000bee4:	f6 07 16 14 	lsr	r7,r11,0x14
8000bee8:	a9 7b       	lsl	r11,0x9
8000beea:	f7 ea 13 7b 	or	r11,r11,r10>>0x17
8000beee:	a9 7a       	lsl	r10,0x9
8000bef0:	bd bb       	sbr	r11,0x1d
8000bef2:	e4 1b 3f ff 	andh	r11,0x3fff
8000bef6:	ab d7       	cbr	r7,0xb
8000bef8:	e0 80 00 cc 	breq	8000c090 <__avr32_f64_div_round_subnormal+0x54>
8000befc:	e0 47 07 ff 	cp.w	r7,2047
8000bf00:	e0 84 00 b5 	brge	8000c06a <__avr32_f64_div_round_subnormal+0x2e>
8000bf04:	f2 06 16 14 	lsr	r6,r9,0x14
8000bf08:	a9 79       	lsl	r9,0x9
8000bf0a:	f3 e8 13 79 	or	r9,r9,r8>>0x17
8000bf0e:	a9 78       	lsl	r8,0x9
8000bf10:	bd b9       	sbr	r9,0x1d
8000bf12:	e4 19 3f ff 	andh	r9,0x3fff
8000bf16:	ab d6       	cbr	r6,0xb
8000bf18:	e0 80 00 e2 	breq	8000c0dc <__avr32_f64_div_round_subnormal+0xa0>
8000bf1c:	e0 46 07 ff 	cp.w	r6,2047
8000bf20:	e0 84 00 b2 	brge	8000c084 <__avr32_f64_div_round_subnormal+0x48>
8000bf24:	0c 17       	sub	r7,r6
8000bf26:	fe 37 fc 01 	sub	r7,-1023
8000bf2a:	fc 1c 80 00 	movh	r12,0x8000
8000bf2e:	f8 03 16 01 	lsr	r3,r12,0x1
8000bf32:	e9 d9 c3 62 	bfextu	r4,r9,0x1b,0x2
8000bf36:	5c d4       	com	r4
8000bf38:	e7 d4 d3 82 	bfins	r3,r4,0x1c,0x2
8000bf3c:	e6 09 06 44 	mulu.d	r4,r3,r9
8000bf40:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000bf44:	e6 05 06 44 	mulu.d	r4,r3,r5
8000bf48:	ea 03 15 02 	lsl	r3,r5,0x2
8000bf4c:	e6 09 06 44 	mulu.d	r4,r3,r9
8000bf50:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000bf54:	e6 05 06 44 	mulu.d	r4,r3,r5
8000bf58:	ea 03 15 02 	lsl	r3,r5,0x2
8000bf5c:	e6 09 06 44 	mulu.d	r4,r3,r9
8000bf60:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000bf64:	e6 05 06 44 	mulu.d	r4,r3,r5
8000bf68:	ea 03 15 02 	lsl	r3,r5,0x2
8000bf6c:	e6 08 06 40 	mulu.d	r0,r3,r8
8000bf70:	e4 09 07 40 	macu.d	r0,r2,r9
8000bf74:	e6 09 06 44 	mulu.d	r4,r3,r9
8000bf78:	02 04       	add	r4,r1
8000bf7a:	5c 05       	acr	r5
8000bf7c:	a3 65       	lsl	r5,0x2
8000bf7e:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000bf82:	a3 64       	lsl	r4,0x2
8000bf84:	5c 34       	neg	r4
8000bf86:	f8 05 01 45 	sbc	r5,r12,r5
8000bf8a:	e6 04 06 40 	mulu.d	r0,r3,r4
8000bf8e:	e4 05 07 40 	macu.d	r0,r2,r5
8000bf92:	e6 05 06 44 	mulu.d	r4,r3,r5
8000bf96:	02 04       	add	r4,r1
8000bf98:	5c 05       	acr	r5
8000bf9a:	ea 03 15 02 	lsl	r3,r5,0x2
8000bf9e:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000bfa2:	e8 02 15 02 	lsl	r2,r4,0x2
8000bfa6:	e6 08 06 40 	mulu.d	r0,r3,r8
8000bfaa:	e4 09 07 40 	macu.d	r0,r2,r9
8000bfae:	e6 09 06 44 	mulu.d	r4,r3,r9
8000bfb2:	02 04       	add	r4,r1
8000bfb4:	5c 05       	acr	r5
8000bfb6:	a3 65       	lsl	r5,0x2
8000bfb8:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000bfbc:	a3 64       	lsl	r4,0x2
8000bfbe:	5c 34       	neg	r4
8000bfc0:	f8 05 01 45 	sbc	r5,r12,r5
8000bfc4:	e6 04 06 40 	mulu.d	r0,r3,r4
8000bfc8:	e4 05 07 40 	macu.d	r0,r2,r5
8000bfcc:	e6 05 06 44 	mulu.d	r4,r3,r5
8000bfd0:	02 04       	add	r4,r1
8000bfd2:	5c 05       	acr	r5
8000bfd4:	ea 03 15 02 	lsl	r3,r5,0x2
8000bfd8:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000bfdc:	e8 02 15 02 	lsl	r2,r4,0x2
8000bfe0:	e6 0a 06 40 	mulu.d	r0,r3,r10
8000bfe4:	e4 0b 07 40 	macu.d	r0,r2,r11
8000bfe8:	e6 0b 06 42 	mulu.d	r2,r3,r11
8000bfec:	02 02       	add	r2,r1
8000bfee:	5c 03       	acr	r3
8000bff0:	ed b3 00 1c 	bld	r3,0x1c
8000bff4:	c0 90       	breq	8000c006 <__avr32_f64_div+0x12a>
8000bff6:	a1 72       	lsl	r2,0x1
8000bff8:	5c f3       	rol	r3
8000bffa:	20 17       	sub	r7,1
8000bffc:	a3 9a       	lsr	r10,0x3
8000bffe:	f5 eb 11 da 	or	r10,r10,r11<<0x1d
8000c002:	a3 9b       	lsr	r11,0x3
8000c004:	c0 58       	rjmp	8000c00e <__avr32_f64_div+0x132>
8000c006:	a5 8a       	lsr	r10,0x4
8000c008:	f5 eb 11 ca 	or	r10,r10,r11<<0x1c
8000c00c:	a5 8b       	lsr	r11,0x4
8000c00e:	58 07       	cp.w	r7,0
8000c010:	e0 8a 00 8b 	brle	8000c126 <__avr32_f64_div_res_subnormal>
8000c014:	e0 12 ff 00 	andl	r2,0xff00
8000c018:	e8 12 00 80 	orl	r2,0x80
8000c01c:	e6 08 06 40 	mulu.d	r0,r3,r8
8000c020:	e4 09 07 40 	macu.d	r0,r2,r9
8000c024:	e4 08 06 44 	mulu.d	r4,r2,r8
8000c028:	e6 09 06 48 	mulu.d	r8,r3,r9
8000c02c:	00 05       	add	r5,r0
8000c02e:	f0 01 00 48 	adc	r8,r8,r1
8000c032:	5c 09       	acr	r9
8000c034:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000c038:	58 04       	cp.w	r4,0
8000c03a:	5c 25       	cpc	r5

8000c03c <__avr32_f64_div_round_subnormal>:
8000c03c:	f4 08 13 00 	cpc	r8,r10
8000c040:	f6 09 13 00 	cpc	r9,r11
8000c044:	5f 36       	srlo	r6
8000c046:	f8 06 17 00 	moveq	r6,r12
8000c04a:	e4 0a 16 08 	lsr	r10,r2,0x8
8000c04e:	f5 e3 11 8a 	or	r10,r10,r3<<0x18
8000c052:	e6 0b 16 08 	lsr	r11,r3,0x8
8000c056:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000c05a:	ed be 00 1f 	bld	lr,0x1f
8000c05e:	ef bb 00 1f 	bst	r11,0x1f
8000c062:	0c 0a       	add	r10,r6
8000c064:	5c 0b       	acr	r11
8000c066:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c06a:	e4 1b 00 0f 	andh	r11,0xf
8000c06e:	14 4b       	or	r11,r10
8000c070:	e0 81 00 a7 	brne	8000c1be <__avr32_f64_div_res_subnormal+0x98>
8000c074:	f2 06 16 14 	lsr	r6,r9,0x14
8000c078:	ab d6       	cbr	r6,0xb
8000c07a:	e0 46 07 ff 	cp.w	r6,2047
8000c07e:	e0 81 00 a4 	brne	8000c1c6 <__avr32_f64_div_res_subnormal+0xa0>
8000c082:	c9 e8       	rjmp	8000c1be <__avr32_f64_div_res_subnormal+0x98>
8000c084:	e4 19 00 0f 	andh	r9,0xf
8000c088:	10 49       	or	r9,r8
8000c08a:	e0 81 00 9a 	brne	8000c1be <__avr32_f64_div_res_subnormal+0x98>
8000c08e:	c9 28       	rjmp	8000c1b2 <__avr32_f64_div_res_subnormal+0x8c>
8000c090:	a3 7b       	lsl	r11,0x3
8000c092:	f7 ea 13 db 	or	r11,r11,r10>>0x1d
8000c096:	a3 7a       	lsl	r10,0x3
8000c098:	f5 eb 10 04 	or	r4,r10,r11
8000c09c:	e0 80 00 a0 	breq	8000c1dc <__avr32_f64_div_op1_zero>
8000c0a0:	f6 04 12 00 	clz	r4,r11
8000c0a4:	c1 70       	breq	8000c0d2 <__avr32_f64_div_round_subnormal+0x96>
8000c0a6:	c0 c3       	brcs	8000c0be <__avr32_f64_div_round_subnormal+0x82>
8000c0a8:	e8 05 11 20 	rsub	r5,r4,32
8000c0ac:	f6 04 09 4b 	lsl	r11,r11,r4
8000c0b0:	f4 05 0a 45 	lsr	r5,r10,r5
8000c0b4:	0a 4b       	or	r11,r5
8000c0b6:	f4 04 09 4a 	lsl	r10,r10,r4
8000c0ba:	08 17       	sub	r7,r4
8000c0bc:	c0 b8       	rjmp	8000c0d2 <__avr32_f64_div_round_subnormal+0x96>
8000c0be:	f4 04 12 00 	clz	r4,r10
8000c0c2:	f9 b4 03 00 	movlo	r4,0
8000c0c6:	f7 b4 02 e0 	subhs	r4,-32
8000c0ca:	f4 04 09 4b 	lsl	r11,r10,r4
8000c0ce:	30 0a       	mov	r10,0
8000c0d0:	08 17       	sub	r7,r4
8000c0d2:	a3 8a       	lsr	r10,0x2
8000c0d4:	f5 eb 11 ea 	or	r10,r10,r11<<0x1e
8000c0d8:	a3 8b       	lsr	r11,0x2
8000c0da:	c1 1b       	rjmp	8000befc <__avr32_f64_div+0x20>
8000c0dc:	a3 79       	lsl	r9,0x3
8000c0de:	f3 e8 13 d9 	or	r9,r9,r8>>0x1d
8000c0e2:	a3 78       	lsl	r8,0x3
8000c0e4:	f3 e8 10 04 	or	r4,r9,r8
8000c0e8:	c6 f0       	breq	8000c1c6 <__avr32_f64_div_res_subnormal+0xa0>
8000c0ea:	f2 04 12 00 	clz	r4,r9
8000c0ee:	c1 70       	breq	8000c11c <__avr32_f64_div_round_subnormal+0xe0>
8000c0f0:	c0 c3       	brcs	8000c108 <__avr32_f64_div_round_subnormal+0xcc>
8000c0f2:	e8 05 11 20 	rsub	r5,r4,32
8000c0f6:	f2 04 09 49 	lsl	r9,r9,r4
8000c0fa:	f0 05 0a 45 	lsr	r5,r8,r5
8000c0fe:	0a 49       	or	r9,r5
8000c100:	f0 04 09 48 	lsl	r8,r8,r4
8000c104:	08 16       	sub	r6,r4
8000c106:	c0 b8       	rjmp	8000c11c <__avr32_f64_div_round_subnormal+0xe0>
8000c108:	f0 04 12 00 	clz	r4,r8
8000c10c:	f9 b4 03 00 	movlo	r4,0
8000c110:	f7 b4 02 e0 	subhs	r4,-32
8000c114:	f0 04 09 49 	lsl	r9,r8,r4
8000c118:	30 08       	mov	r8,0
8000c11a:	08 16       	sub	r6,r4
8000c11c:	a3 88       	lsr	r8,0x2
8000c11e:	f1 e9 11 e8 	or	r8,r8,r9<<0x1e
8000c122:	a3 89       	lsr	r9,0x2
8000c124:	cf ca       	rjmp	8000bf1c <__avr32_f64_div+0x40>

8000c126 <__avr32_f64_div_res_subnormal>:
8000c126:	5c 37       	neg	r7
8000c128:	2f f7       	sub	r7,-1
8000c12a:	f1 b7 04 c0 	satu	r7,0x6
8000c12e:	e0 47 00 20 	cp.w	r7,32
8000c132:	c1 54       	brge	8000c15c <__avr32_f64_div_res_subnormal+0x36>
8000c134:	ee 06 11 20 	rsub	r6,r7,32
8000c138:	e4 07 0a 42 	lsr	r2,r2,r7
8000c13c:	e6 06 09 4c 	lsl	r12,r3,r6
8000c140:	18 42       	or	r2,r12
8000c142:	e6 07 0a 43 	lsr	r3,r3,r7
8000c146:	f4 06 09 41 	lsl	r1,r10,r6
8000c14a:	f4 07 0a 4a 	lsr	r10,r10,r7
8000c14e:	f6 06 09 4c 	lsl	r12,r11,r6
8000c152:	18 4a       	or	r10,r12
8000c154:	f6 07 0a 4b 	lsr	r11,r11,r7
8000c158:	30 00       	mov	r0,0
8000c15a:	c1 58       	rjmp	8000c184 <__avr32_f64_div_res_subnormal+0x5e>
8000c15c:	ee 06 11 20 	rsub	r6,r7,32
8000c160:	f9 b0 00 00 	moveq	r0,0
8000c164:	f9 bc 00 00 	moveq	r12,0
8000c168:	c0 50       	breq	8000c172 <__avr32_f64_div_res_subnormal+0x4c>
8000c16a:	f4 06 09 40 	lsl	r0,r10,r6
8000c16e:	f6 06 09 4c 	lsl	r12,r11,r6
8000c172:	e6 07 0a 42 	lsr	r2,r3,r7
8000c176:	30 03       	mov	r3,0
8000c178:	f4 07 0a 41 	lsr	r1,r10,r7
8000c17c:	18 41       	or	r1,r12
8000c17e:	f6 07 0a 4a 	lsr	r10,r11,r7
8000c182:	30 0b       	mov	r11,0
8000c184:	e0 12 ff 00 	andl	r2,0xff00
8000c188:	e8 12 00 80 	orl	r2,0x80
8000c18c:	e6 08 06 46 	mulu.d	r6,r3,r8
8000c190:	e4 09 07 46 	macu.d	r6,r2,r9
8000c194:	e4 08 06 44 	mulu.d	r4,r2,r8
8000c198:	e6 09 06 48 	mulu.d	r8,r3,r9
8000c19c:	0c 05       	add	r5,r6
8000c19e:	f0 07 00 48 	adc	r8,r8,r7
8000c1a2:	5c 09       	acr	r9
8000c1a4:	30 07       	mov	r7,0
8000c1a6:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000c1aa:	00 34       	cp.w	r4,r0
8000c1ac:	e2 05 13 00 	cpc	r5,r1
8000c1b0:	c4 6b       	rjmp	8000c03c <__avr32_f64_div_round_subnormal>
8000c1b2:	1c 9b       	mov	r11,lr
8000c1b4:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c1b8:	30 0a       	mov	r10,0
8000c1ba:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c1be:	3f fb       	mov	r11,-1
8000c1c0:	30 0a       	mov	r10,0
8000c1c2:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c1c6:	f5 eb 10 04 	or	r4,r10,r11
8000c1ca:	c0 90       	breq	8000c1dc <__avr32_f64_div_op1_zero>
8000c1cc:	1c 9b       	mov	r11,lr
8000c1ce:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c1d2:	ea 1b 7f f0 	orh	r11,0x7ff0
8000c1d6:	30 0a       	mov	r10,0
8000c1d8:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc

8000c1dc <__avr32_f64_div_op1_zero>:
8000c1dc:	f1 e9 10 15 	or	r5,r8,r9<<0x1
8000c1e0:	ce f0       	breq	8000c1be <__avr32_f64_div_res_subnormal+0x98>
8000c1e2:	e9 d9 c2 8b 	bfextu	r4,r9,0x14,0xb
8000c1e6:	e0 44 07 ff 	cp.w	r4,2047
8000c1ea:	ce 41       	brne	8000c1b2 <__avr32_f64_div_res_subnormal+0x8c>
8000c1ec:	f1 e9 10 c5 	or	r5,r8,r9<<0xc
8000c1f0:	ce 10       	breq	8000c1b2 <__avr32_f64_div_res_subnormal+0x8c>
8000c1f2:	ce 6b       	rjmp	8000c1be <__avr32_f64_div_res_subnormal+0x98>

8000c1f4 <__avr32_udiv64>:
8000c1f4:	d4 31       	pushm	r0-r7,lr
8000c1f6:	1a 97       	mov	r7,sp
8000c1f8:	20 3d       	sub	sp,12
8000c1fa:	10 9c       	mov	r12,r8
8000c1fc:	12 9e       	mov	lr,r9
8000c1fe:	14 93       	mov	r3,r10
8000c200:	58 09       	cp.w	r9,0
8000c202:	e0 81 00 bd 	brne	8000c37c <__avr32_udiv64+0x188>
8000c206:	16 38       	cp.w	r8,r11
8000c208:	e0 88 00 40 	brls	8000c288 <__avr32_udiv64+0x94>
8000c20c:	f0 08 12 00 	clz	r8,r8
8000c210:	c0 d0       	breq	8000c22a <__avr32_udiv64+0x36>
8000c212:	f6 08 09 4b 	lsl	r11,r11,r8
8000c216:	f0 09 11 20 	rsub	r9,r8,32
8000c21a:	f8 08 09 4c 	lsl	r12,r12,r8
8000c21e:	f4 09 0a 49 	lsr	r9,r10,r9
8000c222:	f4 08 09 43 	lsl	r3,r10,r8
8000c226:	f3 eb 10 0b 	or	r11,r9,r11
8000c22a:	f8 0e 16 10 	lsr	lr,r12,0x10
8000c22e:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000c232:	f6 0e 0d 00 	divu	r0,r11,lr
8000c236:	e6 0b 16 10 	lsr	r11,r3,0x10
8000c23a:	00 99       	mov	r9,r0
8000c23c:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c240:	e0 0a 02 48 	mul	r8,r0,r10
8000c244:	10 3b       	cp.w	r11,r8
8000c246:	c0 a2       	brcc	8000c25a <__avr32_udiv64+0x66>
8000c248:	20 19       	sub	r9,1
8000c24a:	18 0b       	add	r11,r12
8000c24c:	18 3b       	cp.w	r11,r12
8000c24e:	c0 63       	brcs	8000c25a <__avr32_udiv64+0x66>
8000c250:	10 3b       	cp.w	r11,r8
8000c252:	f7 b9 03 01 	sublo	r9,1
8000c256:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c25a:	f6 08 01 01 	sub	r1,r11,r8
8000c25e:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000c262:	e2 0e 0d 00 	divu	r0,r1,lr
8000c266:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000c26a:	00 98       	mov	r8,r0
8000c26c:	e0 0a 02 4a 	mul	r10,r0,r10
8000c270:	14 33       	cp.w	r3,r10
8000c272:	c0 82       	brcc	8000c282 <__avr32_udiv64+0x8e>
8000c274:	20 18       	sub	r8,1
8000c276:	18 03       	add	r3,r12
8000c278:	18 33       	cp.w	r3,r12
8000c27a:	c0 43       	brcs	8000c282 <__avr32_udiv64+0x8e>
8000c27c:	14 33       	cp.w	r3,r10
8000c27e:	f7 b8 03 01 	sublo	r8,1
8000c282:	f1 e9 11 08 	or	r8,r8,r9<<0x10
8000c286:	cd f8       	rjmp	8000c444 <__avr32_udiv64+0x250>
8000c288:	58 08       	cp.w	r8,0
8000c28a:	c0 51       	brne	8000c294 <__avr32_udiv64+0xa0>
8000c28c:	30 19       	mov	r9,1
8000c28e:	f2 08 0d 08 	divu	r8,r9,r8
8000c292:	10 9c       	mov	r12,r8
8000c294:	f8 06 12 00 	clz	r6,r12
8000c298:	c0 41       	brne	8000c2a0 <__avr32_udiv64+0xac>
8000c29a:	18 1b       	sub	r11,r12
8000c29c:	30 19       	mov	r9,1
8000c29e:	c4 08       	rjmp	8000c31e <__avr32_udiv64+0x12a>
8000c2a0:	ec 01 11 20 	rsub	r1,r6,32
8000c2a4:	f4 01 0a 49 	lsr	r9,r10,r1
8000c2a8:	f8 06 09 4c 	lsl	r12,r12,r6
8000c2ac:	f6 06 09 48 	lsl	r8,r11,r6
8000c2b0:	f6 01 0a 41 	lsr	r1,r11,r1
8000c2b4:	f3 e8 10 08 	or	r8,r9,r8
8000c2b8:	f8 03 16 10 	lsr	r3,r12,0x10
8000c2bc:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000c2c0:	e2 03 0d 00 	divu	r0,r1,r3
8000c2c4:	f0 0b 16 10 	lsr	r11,r8,0x10
8000c2c8:	00 9e       	mov	lr,r0
8000c2ca:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c2ce:	e0 05 02 49 	mul	r9,r0,r5
8000c2d2:	12 3b       	cp.w	r11,r9
8000c2d4:	c0 a2       	brcc	8000c2e8 <__avr32_udiv64+0xf4>
8000c2d6:	20 1e       	sub	lr,1
8000c2d8:	18 0b       	add	r11,r12
8000c2da:	18 3b       	cp.w	r11,r12
8000c2dc:	c0 63       	brcs	8000c2e8 <__avr32_udiv64+0xf4>
8000c2de:	12 3b       	cp.w	r11,r9
8000c2e0:	f7 be 03 01 	sublo	lr,1
8000c2e4:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c2e8:	12 1b       	sub	r11,r9
8000c2ea:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
8000c2ee:	f6 03 0d 02 	divu	r2,r11,r3
8000c2f2:	f1 e3 11 08 	or	r8,r8,r3<<0x10
8000c2f6:	04 99       	mov	r9,r2
8000c2f8:	e4 05 02 4b 	mul	r11,r2,r5
8000c2fc:	16 38       	cp.w	r8,r11
8000c2fe:	c0 a2       	brcc	8000c312 <__avr32_udiv64+0x11e>
8000c300:	20 19       	sub	r9,1
8000c302:	18 08       	add	r8,r12
8000c304:	18 38       	cp.w	r8,r12
8000c306:	c0 63       	brcs	8000c312 <__avr32_udiv64+0x11e>
8000c308:	16 38       	cp.w	r8,r11
8000c30a:	f7 b9 03 01 	sublo	r9,1
8000c30e:	f1 dc e3 08 	addcs	r8,r8,r12
8000c312:	f4 06 09 43 	lsl	r3,r10,r6
8000c316:	f0 0b 01 0b 	sub	r11,r8,r11
8000c31a:	f3 ee 11 09 	or	r9,r9,lr<<0x10
8000c31e:	f8 06 16 10 	lsr	r6,r12,0x10
8000c322:	fd dc c0 10 	bfextu	lr,r12,0x0,0x10
8000c326:	f6 06 0d 00 	divu	r0,r11,r6
8000c32a:	e6 0b 16 10 	lsr	r11,r3,0x10
8000c32e:	00 9a       	mov	r10,r0
8000c330:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c334:	e0 0e 02 48 	mul	r8,r0,lr
8000c338:	10 3b       	cp.w	r11,r8
8000c33a:	c0 a2       	brcc	8000c34e <__avr32_udiv64+0x15a>
8000c33c:	20 1a       	sub	r10,1
8000c33e:	18 0b       	add	r11,r12
8000c340:	18 3b       	cp.w	r11,r12
8000c342:	c0 63       	brcs	8000c34e <__avr32_udiv64+0x15a>
8000c344:	10 3b       	cp.w	r11,r8
8000c346:	f7 ba 03 01 	sublo	r10,1
8000c34a:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c34e:	f6 08 01 01 	sub	r1,r11,r8
8000c352:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000c356:	e2 06 0d 00 	divu	r0,r1,r6
8000c35a:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000c35e:	00 98       	mov	r8,r0
8000c360:	e0 0e 02 4b 	mul	r11,r0,lr
8000c364:	16 33       	cp.w	r3,r11
8000c366:	c0 82       	brcc	8000c376 <__avr32_udiv64+0x182>
8000c368:	20 18       	sub	r8,1
8000c36a:	18 03       	add	r3,r12
8000c36c:	18 33       	cp.w	r3,r12
8000c36e:	c0 43       	brcs	8000c376 <__avr32_udiv64+0x182>
8000c370:	16 33       	cp.w	r3,r11
8000c372:	f7 b8 03 01 	sublo	r8,1
8000c376:	f1 ea 11 08 	or	r8,r8,r10<<0x10
8000c37a:	c6 98       	rjmp	8000c44c <__avr32_udiv64+0x258>
8000c37c:	16 39       	cp.w	r9,r11
8000c37e:	e0 8b 00 65 	brhi	8000c448 <__avr32_udiv64+0x254>
8000c382:	f2 09 12 00 	clz	r9,r9
8000c386:	c0 b1       	brne	8000c39c <__avr32_udiv64+0x1a8>
8000c388:	10 3a       	cp.w	r10,r8
8000c38a:	5f 2a       	srhs	r10
8000c38c:	1c 3b       	cp.w	r11,lr
8000c38e:	5f b8       	srhi	r8
8000c390:	10 4a       	or	r10,r8
8000c392:	f2 0a 18 00 	cp.b	r10,r9
8000c396:	c5 90       	breq	8000c448 <__avr32_udiv64+0x254>
8000c398:	30 18       	mov	r8,1
8000c39a:	c5 98       	rjmp	8000c44c <__avr32_udiv64+0x258>
8000c39c:	f0 09 09 46 	lsl	r6,r8,r9
8000c3a0:	f2 03 11 20 	rsub	r3,r9,32
8000c3a4:	fc 09 09 4e 	lsl	lr,lr,r9
8000c3a8:	f0 03 0a 48 	lsr	r8,r8,r3
8000c3ac:	f6 09 09 4c 	lsl	r12,r11,r9
8000c3b0:	f4 03 0a 42 	lsr	r2,r10,r3
8000c3b4:	ef 46 ff f4 	st.w	r7[-12],r6
8000c3b8:	f6 03 0a 43 	lsr	r3,r11,r3
8000c3bc:	18 42       	or	r2,r12
8000c3be:	f1 ee 10 0c 	or	r12,r8,lr
8000c3c2:	f8 01 16 10 	lsr	r1,r12,0x10
8000c3c6:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000c3ca:	e6 01 0d 04 	divu	r4,r3,r1
8000c3ce:	e4 03 16 10 	lsr	r3,r2,0x10
8000c3d2:	08 9e       	mov	lr,r4
8000c3d4:	e7 e5 11 03 	or	r3,r3,r5<<0x10
8000c3d8:	e8 06 02 48 	mul	r8,r4,r6
8000c3dc:	10 33       	cp.w	r3,r8
8000c3de:	c0 a2       	brcc	8000c3f2 <__avr32_udiv64+0x1fe>
8000c3e0:	20 1e       	sub	lr,1
8000c3e2:	18 03       	add	r3,r12
8000c3e4:	18 33       	cp.w	r3,r12
8000c3e6:	c0 63       	brcs	8000c3f2 <__avr32_udiv64+0x1fe>
8000c3e8:	10 33       	cp.w	r3,r8
8000c3ea:	f7 be 03 01 	sublo	lr,1
8000c3ee:	e7 dc e3 03 	addcs	r3,r3,r12
8000c3f2:	10 13       	sub	r3,r8
8000c3f4:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
8000c3f8:	e6 01 0d 00 	divu	r0,r3,r1
8000c3fc:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c400:	00 98       	mov	r8,r0
8000c402:	e0 06 02 46 	mul	r6,r0,r6
8000c406:	0c 3b       	cp.w	r11,r6
8000c408:	c0 a2       	brcc	8000c41c <__avr32_udiv64+0x228>
8000c40a:	20 18       	sub	r8,1
8000c40c:	18 0b       	add	r11,r12
8000c40e:	18 3b       	cp.w	r11,r12
8000c410:	c0 63       	brcs	8000c41c <__avr32_udiv64+0x228>
8000c412:	0c 3b       	cp.w	r11,r6
8000c414:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c418:	f7 b8 03 01 	sublo	r8,1
8000c41c:	f1 ee 11 08 	or	r8,r8,lr<<0x10
8000c420:	ee f4 ff f4 	ld.w	r4,r7[-12]
8000c424:	0c 1b       	sub	r11,r6
8000c426:	f0 04 06 42 	mulu.d	r2,r8,r4
8000c42a:	06 95       	mov	r5,r3
8000c42c:	16 35       	cp.w	r5,r11
8000c42e:	e0 8b 00 0a 	brhi	8000c442 <__avr32_udiv64+0x24e>
8000c432:	5f 0b       	sreq	r11
8000c434:	f4 09 09 49 	lsl	r9,r10,r9
8000c438:	12 32       	cp.w	r2,r9
8000c43a:	5f b9       	srhi	r9
8000c43c:	f7 e9 00 09 	and	r9,r11,r9
8000c440:	c0 60       	breq	8000c44c <__avr32_udiv64+0x258>
8000c442:	20 18       	sub	r8,1
8000c444:	30 09       	mov	r9,0
8000c446:	c0 38       	rjmp	8000c44c <__avr32_udiv64+0x258>
8000c448:	30 09       	mov	r9,0
8000c44a:	12 98       	mov	r8,r9
8000c44c:	10 9a       	mov	r10,r8
8000c44e:	12 93       	mov	r3,r9
8000c450:	10 92       	mov	r2,r8
8000c452:	12 9b       	mov	r11,r9
8000c454:	2f dd       	sub	sp,-12
8000c456:	d8 32       	popm	r0-r7,pc

8000c458 <__avr32_umod64>:
8000c458:	d4 31       	pushm	r0-r7,lr
8000c45a:	1a 97       	mov	r7,sp
8000c45c:	20 3d       	sub	sp,12
8000c45e:	10 9c       	mov	r12,r8
8000c460:	12 95       	mov	r5,r9
8000c462:	14 9e       	mov	lr,r10
8000c464:	16 91       	mov	r1,r11
8000c466:	16 96       	mov	r6,r11
8000c468:	58 09       	cp.w	r9,0
8000c46a:	e0 81 00 81 	brne	8000c56c <__avr32_umod64+0x114>
8000c46e:	16 38       	cp.w	r8,r11
8000c470:	e0 88 00 12 	brls	8000c494 <__avr32_umod64+0x3c>
8000c474:	f0 08 12 00 	clz	r8,r8
8000c478:	c4 e0       	breq	8000c514 <__avr32_umod64+0xbc>
8000c47a:	f6 08 09 46 	lsl	r6,r11,r8
8000c47e:	f8 08 09 4c 	lsl	r12,r12,r8
8000c482:	f0 0b 11 20 	rsub	r11,r8,32
8000c486:	f4 08 09 4e 	lsl	lr,r10,r8
8000c48a:	f4 0b 0a 4b 	lsr	r11,r10,r11
8000c48e:	f7 e6 10 06 	or	r6,r11,r6
8000c492:	c4 18       	rjmp	8000c514 <__avr32_umod64+0xbc>
8000c494:	58 08       	cp.w	r8,0
8000c496:	c0 51       	brne	8000c4a0 <__avr32_umod64+0x48>
8000c498:	30 19       	mov	r9,1
8000c49a:	f2 08 0d 08 	divu	r8,r9,r8
8000c49e:	10 9c       	mov	r12,r8
8000c4a0:	f8 08 12 00 	clz	r8,r12
8000c4a4:	c0 31       	brne	8000c4aa <__avr32_umod64+0x52>
8000c4a6:	18 16       	sub	r6,r12
8000c4a8:	c3 68       	rjmp	8000c514 <__avr32_umod64+0xbc>
8000c4aa:	f0 03 11 20 	rsub	r3,r8,32
8000c4ae:	f4 03 0a 4b 	lsr	r11,r10,r3
8000c4b2:	f8 08 09 4c 	lsl	r12,r12,r8
8000c4b6:	ec 08 09 49 	lsl	r9,r6,r8
8000c4ba:	ec 03 0a 43 	lsr	r3,r6,r3
8000c4be:	f7 e9 10 09 	or	r9,r11,r9
8000c4c2:	f8 05 16 10 	lsr	r5,r12,0x10
8000c4c6:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000c4ca:	e6 05 0d 02 	divu	r2,r3,r5
8000c4ce:	f2 0e 16 10 	lsr	lr,r9,0x10
8000c4d2:	ec 02 02 4b 	mul	r11,r6,r2
8000c4d6:	fd e3 11 0e 	or	lr,lr,r3<<0x10
8000c4da:	16 3e       	cp.w	lr,r11
8000c4dc:	c0 72       	brcc	8000c4ea <__avr32_umod64+0x92>
8000c4de:	18 0e       	add	lr,r12
8000c4e0:	18 3e       	cp.w	lr,r12
8000c4e2:	c0 43       	brcs	8000c4ea <__avr32_umod64+0x92>
8000c4e4:	16 3e       	cp.w	lr,r11
8000c4e6:	fd dc e3 0e 	addcs	lr,lr,r12
8000c4ea:	fc 0b 01 03 	sub	r3,lr,r11
8000c4ee:	f3 d9 c0 10 	bfextu	r9,r9,0x0,0x10
8000c4f2:	e6 05 0d 02 	divu	r2,r3,r5
8000c4f6:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000c4fa:	a5 36       	mul	r6,r2
8000c4fc:	0c 39       	cp.w	r9,r6
8000c4fe:	c0 72       	brcc	8000c50c <__avr32_umod64+0xb4>
8000c500:	18 09       	add	r9,r12
8000c502:	18 39       	cp.w	r9,r12
8000c504:	c0 43       	brcs	8000c50c <__avr32_umod64+0xb4>
8000c506:	0c 39       	cp.w	r9,r6
8000c508:	f3 dc e3 09 	addcs	r9,r9,r12
8000c50c:	f2 06 01 06 	sub	r6,r9,r6
8000c510:	f4 08 09 4e 	lsl	lr,r10,r8
8000c514:	f8 0a 16 10 	lsr	r10,r12,0x10
8000c518:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000c51c:	ec 0a 0d 02 	divu	r2,r6,r10
8000c520:	fc 09 16 10 	lsr	r9,lr,0x10
8000c524:	ea 02 02 4b 	mul	r11,r5,r2
8000c528:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000c52c:	16 39       	cp.w	r9,r11
8000c52e:	c0 72       	brcc	8000c53c <__avr32_umod64+0xe4>
8000c530:	18 09       	add	r9,r12
8000c532:	18 39       	cp.w	r9,r12
8000c534:	c0 43       	brcs	8000c53c <__avr32_umod64+0xe4>
8000c536:	16 39       	cp.w	r9,r11
8000c538:	f3 dc e3 09 	addcs	r9,r9,r12
8000c53c:	f2 0b 01 0b 	sub	r11,r9,r11
8000c540:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000c544:	f6 0a 0d 0a 	divu	r10,r11,r10
8000c548:	fd eb 11 0e 	or	lr,lr,r11<<0x10
8000c54c:	ea 0a 02 4a 	mul	r10,r5,r10
8000c550:	14 3e       	cp.w	lr,r10
8000c552:	c0 72       	brcc	8000c560 <__avr32_umod64+0x108>
8000c554:	18 0e       	add	lr,r12
8000c556:	18 3e       	cp.w	lr,r12
8000c558:	c0 43       	brcs	8000c560 <__avr32_umod64+0x108>
8000c55a:	14 3e       	cp.w	lr,r10
8000c55c:	fd dc e3 0e 	addcs	lr,lr,r12
8000c560:	fc 0a 01 0a 	sub	r10,lr,r10
8000c564:	30 0b       	mov	r11,0
8000c566:	f4 08 0a 4a 	lsr	r10,r10,r8
8000c56a:	c7 b8       	rjmp	8000c660 <__avr32_umod64+0x208>
8000c56c:	16 39       	cp.w	r9,r11
8000c56e:	e0 8b 00 79 	brhi	8000c660 <__avr32_umod64+0x208>
8000c572:	f2 09 12 00 	clz	r9,r9
8000c576:	c1 21       	brne	8000c59a <__avr32_umod64+0x142>
8000c578:	10 3a       	cp.w	r10,r8
8000c57a:	5f 2b       	srhs	r11
8000c57c:	0a 31       	cp.w	r1,r5
8000c57e:	5f ba       	srhi	r10
8000c580:	f7 ea 10 0a 	or	r10,r11,r10
8000c584:	f2 0a 18 00 	cp.b	r10,r9
8000c588:	c0 60       	breq	8000c594 <__avr32_umod64+0x13c>
8000c58a:	fc 08 01 0c 	sub	r12,lr,r8
8000c58e:	e2 05 01 46 	sbc	r6,r1,r5
8000c592:	18 9e       	mov	lr,r12
8000c594:	0c 9b       	mov	r11,r6
8000c596:	1c 9a       	mov	r10,lr
8000c598:	c6 48       	rjmp	8000c660 <__avr32_umod64+0x208>
8000c59a:	ea 09 09 4c 	lsl	r12,r5,r9
8000c59e:	f2 06 11 20 	rsub	r6,r9,32
8000c5a2:	f6 09 09 4b 	lsl	r11,r11,r9
8000c5a6:	f0 09 09 42 	lsl	r2,r8,r9
8000c5aa:	ef 46 ff f4 	st.w	r7[-12],r6
8000c5ae:	f0 06 0a 48 	lsr	r8,r8,r6
8000c5b2:	18 48       	or	r8,r12
8000c5b4:	e2 06 0a 4c 	lsr	r12,r1,r6
8000c5b8:	f4 09 09 43 	lsl	r3,r10,r9
8000c5bc:	fd d8 c0 10 	bfextu	lr,r8,0x0,0x10
8000c5c0:	f4 06 0a 4a 	lsr	r10,r10,r6
8000c5c4:	16 4a       	or	r10,r11
8000c5c6:	f0 0b 16 10 	lsr	r11,r8,0x10
8000c5ca:	f8 0b 0d 04 	divu	r4,r12,r11
8000c5ce:	f4 0c 16 10 	lsr	r12,r10,0x10
8000c5d2:	08 91       	mov	r1,r4
8000c5d4:	f9 e5 11 0c 	or	r12,r12,r5<<0x10
8000c5d8:	e8 0e 02 46 	mul	r6,r4,lr
8000c5dc:	0c 3c       	cp.w	r12,r6
8000c5de:	c0 a2       	brcc	8000c5f2 <__avr32_umod64+0x19a>
8000c5e0:	20 11       	sub	r1,1
8000c5e2:	10 0c       	add	r12,r8
8000c5e4:	10 3c       	cp.w	r12,r8
8000c5e6:	c0 63       	brcs	8000c5f2 <__avr32_umod64+0x19a>
8000c5e8:	0c 3c       	cp.w	r12,r6
8000c5ea:	f7 b1 03 01 	sublo	r1,1
8000c5ee:	f9 d8 e3 0c 	addcs	r12,r12,r8
8000c5f2:	0c 1c       	sub	r12,r6
8000c5f4:	f5 da c0 10 	bfextu	r10,r10,0x0,0x10
8000c5f8:	f8 0b 0d 04 	divu	r4,r12,r11
8000c5fc:	f5 e5 11 0b 	or	r11,r10,r5<<0x10
8000c600:	08 96       	mov	r6,r4
8000c602:	e8 0e 02 4e 	mul	lr,r4,lr
8000c606:	1c 3b       	cp.w	r11,lr
8000c608:	c0 a2       	brcc	8000c61c <__avr32_umod64+0x1c4>
8000c60a:	20 16       	sub	r6,1
8000c60c:	10 0b       	add	r11,r8
8000c60e:	10 3b       	cp.w	r11,r8
8000c610:	c0 63       	brcs	8000c61c <__avr32_umod64+0x1c4>
8000c612:	1c 3b       	cp.w	r11,lr
8000c614:	f7 b6 03 01 	sublo	r6,1
8000c618:	f7 d8 e3 0b 	addcs	r11,r11,r8
8000c61c:	ed e1 11 01 	or	r1,r6,r1<<0x10
8000c620:	1c 1b       	sub	r11,lr
8000c622:	e2 02 06 40 	mulu.d	r0,r1,r2
8000c626:	00 9e       	mov	lr,r0
8000c628:	02 9c       	mov	r12,r1
8000c62a:	16 3c       	cp.w	r12,r11
8000c62c:	e0 8b 00 08 	brhi	8000c63c <__avr32_umod64+0x1e4>
8000c630:	5f 06       	sreq	r6
8000c632:	06 30       	cp.w	r0,r3
8000c634:	5f ba       	srhi	r10
8000c636:	ed ea 00 0a 	and	r10,r6,r10
8000c63a:	c0 60       	breq	8000c646 <__avr32_umod64+0x1ee>
8000c63c:	fc 02 01 04 	sub	r4,lr,r2
8000c640:	f8 08 01 4c 	sbc	r12,r12,r8
8000c644:	08 9e       	mov	lr,r4
8000c646:	e6 0e 01 0a 	sub	r10,r3,lr
8000c64a:	f6 0c 01 4c 	sbc	r12,r11,r12
8000c64e:	ee f1 ff f4 	ld.w	r1,r7[-12]
8000c652:	f8 09 0a 4b 	lsr	r11,r12,r9
8000c656:	f4 09 0a 4a 	lsr	r10,r10,r9
8000c65a:	f8 01 09 4c 	lsl	r12,r12,r1
8000c65e:	18 4a       	or	r10,r12
8000c660:	2f dd       	sub	sp,-12
8000c662:	d8 32       	popm	r0-r7,pc

Disassembly of section .exception:

8000c800 <_evba>:
_evba:

        .org  0x000
        // Unrecoverable Exception.
_handle_Unrecoverable_Exception:
        rjmp $
8000c800:	c0 08       	rjmp	8000c800 <_evba>
	...

8000c804 <_handle_TLB_Multiple_Hit>:

        .org  0x004
        // TLB Multiple Hit: UNUSED IN AVR32UC.
_handle_TLB_Multiple_Hit:
        rjmp $
8000c804:	c0 08       	rjmp	8000c804 <_handle_TLB_Multiple_Hit>
	...

8000c808 <_handle_Bus_Error_Data_Fetch>:

        .org  0x008
        // Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
        rjmp $
8000c808:	c0 08       	rjmp	8000c808 <_handle_Bus_Error_Data_Fetch>
	...

8000c80c <_handle_Bus_Error_Instruction_Fetch>:

        .org  0x00C
         // Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
        rjmp $
8000c80c:	c0 08       	rjmp	8000c80c <_handle_Bus_Error_Instruction_Fetch>
	...

8000c810 <_handle_NMI>:

        .org  0x010
        // NMI.
_handle_NMI:
        rjmp $
8000c810:	c0 08       	rjmp	8000c810 <_handle_NMI>
	...

8000c814 <_handle_Instruction_Address>:

        .org  0x014
        // Instruction Address.
_handle_Instruction_Address:
        rjmp $
8000c814:	c0 08       	rjmp	8000c814 <_handle_Instruction_Address>
	...

8000c818 <_handle_ITLB_Protection>:

        .org  0x018
        // ITLB Protection.
_handle_ITLB_Protection:
        rjmp $
8000c818:	c0 08       	rjmp	8000c818 <_handle_ITLB_Protection>
	...

8000c81c <_handle_Breakpoint>:

        .org  0x01C
        // Breakpoint.
_handle_Breakpoint:
        rjmp $
8000c81c:	c0 08       	rjmp	8000c81c <_handle_Breakpoint>
	...

8000c820 <_handle_Illegal_Opcode>:

        .org  0x020
        // Illegal Opcode.
_handle_Illegal_Opcode:
        rjmp $
8000c820:	c0 08       	rjmp	8000c820 <_handle_Illegal_Opcode>
	...

8000c824 <_handle_Unimplemented_Instruction>:

        .org  0x024
        // Unimplemented Instruction.
_handle_Unimplemented_Instruction:
        rjmp $
8000c824:	c0 08       	rjmp	8000c824 <_handle_Unimplemented_Instruction>
	...

8000c828 <_handle_Privilege_Violation>:

        .org  0x028
        // Privilege Violation.
_handle_Privilege_Violation:
        rjmp $
8000c828:	c0 08       	rjmp	8000c828 <_handle_Privilege_Violation>
	...

8000c82c <_handle_Floating_Point>:

        .org  0x02C
        // Floating-Point: UNUSED IN AVR32UC.
_handle_Floating_Point:
        rjmp $
8000c82c:	c0 08       	rjmp	8000c82c <_handle_Floating_Point>
	...

8000c830 <_handle_Coprocessor_Absent>:

        .org  0x030
        // Coprocessor Absent: UNUSED IN AVR32UC.
_handle_Coprocessor_Absent:
        rjmp $
8000c830:	c0 08       	rjmp	8000c830 <_handle_Coprocessor_Absent>
	...

8000c834 <_handle_Data_Address_Read>:

        .org  0x034
        // Data Address (Read).
_handle_Data_Address_Read:
        rjmp $
8000c834:	c0 08       	rjmp	8000c834 <_handle_Data_Address_Read>
	...

8000c838 <_handle_Data_Address_Write>:

        .org  0x038
        // Data Address (Write).
_handle_Data_Address_Write:
        rjmp $
8000c838:	c0 08       	rjmp	8000c838 <_handle_Data_Address_Write>
	...

8000c83c <_handle_DTLB_Protection_Read>:

        .org  0x03C
        // DTLB Protection (Read).
_handle_DTLB_Protection_Read:
        rjmp $
8000c83c:	c0 08       	rjmp	8000c83c <_handle_DTLB_Protection_Read>
	...

8000c840 <_handle_DTLB_Protection_Write>:

        .org  0x040
        // DTLB Protection (Write).
_handle_DTLB_Protection_Write:
        rjmp $
8000c840:	c0 08       	rjmp	8000c840 <_handle_DTLB_Protection_Write>
	...

8000c844 <_handle_DTLB_Modified>:

        .org  0x044
        // DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
        rjmp $
8000c844:	c0 08       	rjmp	8000c844 <_handle_DTLB_Modified>
	...

8000c850 <_handle_ITLB_Miss>:

        .org  0x050
        // ITLB Miss: UNUSED IN AVR32UC.
_handle_ITLB_Miss:
        rjmp $
8000c850:	c0 08       	rjmp	8000c850 <_handle_ITLB_Miss>
	...

8000c860 <_handle_DTLB_Miss_Read>:

        .org  0x060
        // DTLB Miss (Read): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Read:
        rjmp $
8000c860:	c0 08       	rjmp	8000c860 <_handle_DTLB_Miss_Read>
	...

8000c870 <_handle_DTLB_Miss_Write>:

        .org  0x070
        // DTLB Miss (Write): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Write:
        rjmp $
8000c870:	c0 08       	rjmp	8000c870 <_handle_DTLB_Miss_Write>
	...

8000c900 <_handle_Supervisor_Call>:

        .org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
8000c900:	fe cf 72 1c 	sub	pc,pc,29212

8000c904 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
8000c904:	30 0c       	mov	r12,0
8000c906:	fe b0 c3 1f 	rcall	80004f44 <_get_interrupt_handler>
8000c90a:	58 0c       	cp.w	r12,0
8000c90c:	f8 0f 17 10 	movne	pc,r12
8000c910:	d6 03       	rete

8000c912 <_int1>:
8000c912:	30 1c       	mov	r12,1
8000c914:	fe b0 c3 18 	rcall	80004f44 <_get_interrupt_handler>
8000c918:	58 0c       	cp.w	r12,0
8000c91a:	f8 0f 17 10 	movne	pc,r12
8000c91e:	d6 03       	rete

8000c920 <_int2>:
8000c920:	30 2c       	mov	r12,2
8000c922:	fe b0 c3 11 	rcall	80004f44 <_get_interrupt_handler>
8000c926:	58 0c       	cp.w	r12,0
8000c928:	f8 0f 17 10 	movne	pc,r12
8000c92c:	d6 03       	rete

8000c92e <_int3>:
8000c92e:	30 3c       	mov	r12,3
8000c930:	fe b0 c3 0a 	rcall	80004f44 <_get_interrupt_handler>
8000c934:	58 0c       	cp.w	r12,0
8000c936:	f8 0f 17 10 	movne	pc,r12
8000c93a:	d6 03       	rete

8000c93c <ipr_val>:
8000c93c:	00 00 01 04 40 00 01 12 80 00 01 20 c0 00 01 2e     ....@...... ....
8000c94c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c95c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c96c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c97c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c98c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c99c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c9ac:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c9bc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c9cc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c9dc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c9ec:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c9fc:	d7 03 d7 03                                         ....
