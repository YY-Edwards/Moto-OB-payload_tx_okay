
moto_gob_prj.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002008  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80002008  80002008  00002408  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         0000a58c  80002008  80002008  00002408  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  8000c600  8000c600  0000ca00  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       00009b80  8000c800  8000c800  0000cc00  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .dalign       00000004  00000004  00000004  00000000  2**0
                  ALLOC
  6 .data         00000a2c  00000008  80016380  00016808  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .balign       00000004  00000a34  80016dac  00017234  2**0
                  ALLOC
  8 .bss          000036f0  00000a38  00000a38  00000000  2**2
                  ALLOC
  9 .heap         00012ed8  00004128  00004128  00000000  2**0
                  ALLOC
 10 .comment      00000030  00000000  00000000  00017234  2**0
                  CONTENTS, READONLY
 11 .debug_aranges 000011f8  00000000  00000000  00017268  2**3
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_pubnames 000025d0  00000000  00000000  00018460  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_info   00028ee8  00000000  00000000  0001aa30  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_abbrev 00006b03  00000000  00000000  00043918  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_line   0000c67f  00000000  00000000  0004a41b  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_frame  00002f8c  00000000  00000000  00056a9c  2**2
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_str    0000712a  00000000  00000000  00059a28  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_loc    0000d1ef  00000000  00000000  00060b52  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .stack        00001000  00017000  00017000  00000000  2**0
                  ALLOC
 20 .debug_ranges 000012d0  00000000  00000000  0006dd48  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_start>:

  .global _start
  .type _start, @function
_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80000000:	fe cf 93 dc 	sub	pc,pc,-27684

80000004 <_trampoline>:
80000004:	e0 8f 10 00 	bral	80002004 <program_start>
	...

80002004 <program_start>:
  rjmp    program_start

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002004:	fe cf b3 e0 	sub	pc,pc,-19488

Disassembly of section .text:

80002008 <DeviceManagement_brdcst_func>:
80002008:	19 a9       	ld.ub	r9,r12[0x2]
8000200a:	30 18       	mov	r8,1
		U8 temp = 0;
		temp  = xcmp->u8[1] << 8;
		temp |= xcmp->u8[2];
		//if (temp == theXNL_Ctrlr.XNL_DeviceLogicalAddress)
		{
			if (xcmp->u8[0] == 0x01)
8000200c:	f0 09 18 00 	cp.b	r9,r8
80002010:	c0 61       	brne	8000201c <DeviceManagement_brdcst_func+0x14>
			{
				bunchofrandomstatusflags |= 0x00000002;
80002012:	48 68       	lddpc	r8,80002028 <DeviceManagement_brdcst_func+0x20>
80002014:	70 09       	ld.w	r9,r8[0x0]
80002016:	a1 b9       	sbr	r9,0x1
80002018:	91 09       	st.w	r8[0x0],r9
8000201a:	5e fc       	retal	r12
			}
			else
			{
				bunchofrandomstatusflags &= 0xFFFFFFFD;
8000201c:	48 38       	lddpc	r8,80002028 <DeviceManagement_brdcst_func+0x20>
8000201e:	70 09       	ld.w	r9,r8[0x0]
80002020:	a1 d9       	cbr	r9,0x1
80002022:	91 09       	st.w	r8[0x0],r9
80002024:	5e fc       	retal	r12
80002026:	00 00       	add	r0,r0
80002028:	00 00       	add	r0,r0
8000202a:	0d b4       	ld.ub	r4,r6[0x3]

8000202c <mic_brdcst_func>:
	//log("\n\r Signal_type: %x \n\r " ,  ptr->Signaling_Type);
	//log("\n\r Mic_state: %x \n\r " ,  ptr->Mic_State);
	//log("\n\r Gain_offset: %x \n\r " ,  ptr->Gain_Offset);
			
	
}
8000202c:	5e fc       	retal	r12

8000202e <TransmitControl_brdcst_func>:
	//log("\n\r  State: %x \n\r ", ptr->State );
	//log("\n\r  State_change_reason: %x \n\r ", ptr->State_change_reason );
	//
	
	
}
8000202e:	5e fc       	retal	r12

80002030 <vApplicationIdleHook>:
}

void vApplicationIdleHook( void )
{
	/* This hook function does nothing but increment a counter. */
	ulIdleCycleCount++;
80002030:	48 38       	lddpc	r8,8000203c <vApplicationIdleHook+0xc>
80002032:	70 09       	ld.w	r9,r8[0x0]
80002034:	2f f9       	sub	r9,-1
80002036:	91 09       	st.w	r8[0x0],r9
	
}
80002038:	5e fc       	retal	r12
8000203a:	00 00       	add	r0,r0
8000203c:	00 00       	add	r0,r0
8000203e:	0a 50       	eor	r0,r5

80002040 <app_init>:
														
		
};

void app_init(void)
{	
80002040:	d4 01       	pushm	lr
	payload_init( app_payload_rx_proc , app_payload_tx_proc );	
80002042:	48 cb       	lddpc	r11,80002070 <app_init+0x30>
80002044:	48 cc       	lddpc	r12,80002074 <app_init+0x34>
80002046:	f0 1f 00 0d 	mcall	80002078 <app_init+0x38>
	xcmp_register_app_list(the_app_list);
8000204a:	48 dc       	lddpc	r12,8000207c <app_init+0x3c>
8000204c:	f0 1f 00 0d 	mcall	80002080 <app_init+0x40>
			
	static portBASE_TYPE res = 0;
	 res = xTaskCreate(
80002050:	30 09       	mov	r9,0
80002052:	1a d9       	st.w	--sp,r9
80002054:	1a d9       	st.w	--sp,r9
80002056:	1a d9       	st.w	--sp,r9
80002058:	30 18       	mov	r8,1
8000205a:	e0 6a 01 80 	mov	r10,384
8000205e:	48 ab       	lddpc	r11,80002084 <app_init+0x44>
80002060:	48 ac       	lddpc	r12,80002088 <app_init+0x48>
80002062:	f0 1f 00 0b 	mcall	8000208c <app_init+0x4c>
80002066:	48 b8       	lddpc	r8,80002090 <app_init+0x50>
80002068:	91 0c       	st.w	r8[0x0],r12
8000206a:	2f dd       	sub	sp,-12
	,  NULL
	,  1
	,  NULL );
	
	
}
8000206c:	d8 02       	popm	pc
8000206e:	00 00       	add	r0,r0
80002070:	80 00       	ld.sh	r0,r0[0x0]
80002072:	20 94       	sub	r4,9
80002074:	80 00       	ld.sh	r0,r0[0x0]
80002076:	28 40       	sub	r0,-124
80002078:	80 00       	ld.sh	r0,r0[0x0]
8000207a:	29 b4       	sub	r4,-101
8000207c:	00 00       	add	r0,r0
8000207e:	00 08       	add	r8,r0
80002080:	80 00       	ld.sh	r0,r0[0x0]
80002082:	43 64       	lddsp	r4,sp[0xd8]
80002084:	80 00       	ld.sh	r0,r0[0x0]
80002086:	c8 00       	breq	80001f86 <_trampoline+0x1f82>
80002088:	80 00       	ld.sh	r0,r0[0x0]
8000208a:	27 9c       	sub	r12,121
8000208c:	80 00       	ld.sh	r0,r0[0x0]
8000208e:	63 98       	ld.w	r8,r1[0x64]
80002090:	00 00       	add	r0,r0
80002092:	0a 3c       	cp.w	r12,r5

80002094 <app_payload_tx_proc>:

}


static void app_payload_tx_proc(void  * payload)
{
80002094:	d4 01       	pushm	lr
  log("R");
80002096:	48 3c       	lddpc	r12,800020a0 <app_payload_tx_proc+0xc>
80002098:	f0 1f 00 03 	mcall	800020a4 <app_payload_tx_proc+0x10>
  //
  //
  //set_payload_idle(payload);


}
8000209c:	d8 02       	popm	pc
8000209e:	00 00       	add	r0,r0
800020a0:	80 00       	ld.sh	r0,r0[0x0]
800020a2:	c8 08       	rjmp	800021a2 <SingleDetection_brdcst_func+0x3a>
800020a4:	80 00       	ld.sh	r0,r0[0x0]
800020a6:	67 5c       	ld.w	r12,r3[0x54]

800020a8 <FD_brdcst_func>:
	
	
}

void FD_brdcst_func(xcmp_fragment_t * xcmp)
{
800020a8:	d4 01       	pushm	lr
	
	
	log("\n\r Forward Data Broadcast \n\r");
800020aa:	48 3c       	lddpc	r12,800020b4 <FD_brdcst_func+0xc>
800020ac:	f0 1f 00 03 	mcall	800020b8 <FD_brdcst_func+0x10>
	
}
800020b0:	d8 02       	popm	pc
800020b2:	00 00       	add	r0,r0
800020b4:	80 00       	ld.sh	r0,r0[0x0]
800020b6:	c8 0c       	rcall	800021b6 <ButtonConfig_brdcst_func+0xe>
800020b8:	80 00       	ld.sh	r0,r0[0x0]
800020ba:	67 5c       	ld.w	r12,r3[0x54]

800020bc <FD_reply_func>:
	
	
}

void FD_reply_func(xcmp_fragment_t * xcmp)
{
800020bc:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Reply \n\r");
800020be:	48 3c       	lddpc	r12,800020c8 <FD_reply_func+0xc>
800020c0:	f0 1f 00 03 	mcall	800020cc <FD_reply_func+0x10>
	
	
}
800020c4:	d8 02       	popm	pc
800020c6:	00 00       	add	r0,r0
800020c8:	80 00       	ld.sh	r0,r0[0x0]
800020ca:	c8 2c       	rcall	800021ce <ButtonConfig_brdcst_func+0x26>
800020cc:	80 00       	ld.sh	r0,r0[0x0]
800020ce:	67 5c       	ld.w	r12,r3[0x54]

800020d0 <FD_request_func>:
}



void FD_request_func(xcmp_fragment_t * xcmp)
{
800020d0:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Request \n\r");
800020d2:	48 3c       	lddpc	r12,800020dc <FD_request_func+0xc>
800020d4:	f0 1f 00 03 	mcall	800020e0 <FD_request_func+0x10>
	
	
}
800020d8:	d8 02       	popm	pc
800020da:	00 00       	add	r0,r0
800020dc:	80 00       	ld.sh	r0,r0[0x0]
800020de:	c8 48       	rjmp	800021e6 <ButtonConfig_brdcst_func+0x3e>
800020e0:	80 00       	ld.sh	r0,r0[0x0]
800020e2:	67 5c       	ld.w	r12,r3[0x54]

800020e4 <EnOB_brdcst_func>:
	
	
}

void EnOB_brdcst_func(xcmp_fragment_t * xcmp)
{
800020e4:	d4 01       	pushm	lr
	
	
	log("\n\r En_OB Broadcast \n\r");
800020e6:	48 3c       	lddpc	r12,800020f0 <EnOB_brdcst_func+0xc>
800020e8:	f0 1f 00 03 	mcall	800020f4 <EnOB_brdcst_func+0x10>
}
800020ec:	d8 02       	popm	pc
800020ee:	00 00       	add	r0,r0
800020f0:	80 00       	ld.sh	r0,r0[0x0]
800020f2:	c8 64       	brge	80001ffe <_trampoline+0x1ffa>
800020f4:	80 00       	ld.sh	r0,r0[0x0]
800020f6:	67 5c       	ld.w	r12,r3[0x54]

800020f8 <EnOB_reply_func>:
}



void EnOB_reply_func(xcmp_fragment_t * xcmp)
{
800020f8:	eb cd 40 80 	pushm	r7,lr
800020fc:	18 97       	mov	r7,r12
		/*point to xcmp payload*/
	//En_OB_Control_reply_t *ptr = (En_OB_Control_reply_t* )xcmp->u8;
	//log("\n\r Xcmp_opcode: %x \n\r", xcmp->xcmp_opcode);
	
	if (xcmp->u8[0]== xcmp_Res_Success)
800020fe:	19 a9       	ld.ub	r9,r12[0x2]
80002100:	30 08       	mov	r8,0
80002102:	f0 09 18 00 	cp.b	r9,r8
80002106:	c1 91       	brne	80002138 <EnOB_reply_func+0x40>
	{
		if (xcmp->u8[1] == EN_OB_Enter)
80002108:	19 b8       	ld.ub	r8,r12[0x3]
8000210a:	30 19       	mov	r9,1
8000210c:	f2 08 18 00 	cp.b	r8,r9
80002110:	c0 61       	brne	8000211c <EnOB_reply_func+0x24>
		{
		
			log("\n\r En_OB_Enter OK \n\r");
80002112:	49 0c       	lddpc	r12,80002150 <EnOB_reply_func+0x58>
80002114:	f0 1f 00 10 	mcall	80002154 <EnOB_reply_func+0x5c>
80002118:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else if (xcmp->u8[1] == EN_OB_Exit )
8000211c:	58 08       	cp.w	r8,0
8000211e:	c0 61       	brne	8000212a <EnOB_reply_func+0x32>
		{
			log("\n\r En_OB_Exit OK \n\r");
80002120:	48 ec       	lddpc	r12,80002158 <EnOB_reply_func+0x60>
80002122:	f0 1f 00 0d 	mcall	80002154 <EnOB_reply_func+0x5c>
80002126:	e3 cd 80 80 	ldm	sp++,r7,pc
		}
		else
		{
			
			log("\n\r En_OB_Control: %x \n\r", xcmp->u8[1]);
8000212a:	1a d8       	st.w	--sp,r8
8000212c:	48 cc       	lddpc	r12,8000215c <EnOB_reply_func+0x64>
8000212e:	f0 1f 00 0a 	mcall	80002154 <EnOB_reply_func+0x5c>
80002132:	2f fd       	sub	sp,-4
80002134:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r En_OB_Control error \n\r");
80002138:	48 ac       	lddpc	r12,80002160 <EnOB_reply_func+0x68>
8000213a:	f0 1f 00 07 	mcall	80002154 <EnOB_reply_func+0x5c>
		log("\n\r En_OB_result: %x \n\r", xcmp->u8[0]);
8000213e:	0f a8       	ld.ub	r8,r7[0x2]
80002140:	1a d8       	st.w	--sp,r8
80002142:	48 9c       	lddpc	r12,80002164 <EnOB_reply_func+0x6c>
80002144:	f0 1f 00 04 	mcall	80002154 <EnOB_reply_func+0x5c>
80002148:	2f fd       	sub	sp,-4
8000214a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000214e:	00 00       	add	r0,r0
80002150:	80 00       	ld.sh	r0,r0[0x0]
80002152:	c8 7c       	rcall	80002260 <ButtonConfig_brdcst_func+0xb8>
80002154:	80 00       	ld.sh	r0,r0[0x0]
80002156:	67 5c       	ld.w	r12,r3[0x54]
80002158:	80 00       	ld.sh	r0,r0[0x0]
8000215a:	c8 94       	brge	8000206c <app_init+0x2c>
8000215c:	80 00       	ld.sh	r0,r0[0x0]
8000215e:	c8 a8       	rjmp	80002272 <ButtonConfig_brdcst_func+0xca>
80002160:	80 00       	ld.sh	r0,r0[0x0]
80002162:	c8 c0       	breq	8000207a <app_init+0x3a>
80002164:	80 00       	ld.sh	r0,r0[0x0]
80002166:	c8 dc       	rcall	80002280 <ButtonConfig_brdcst_func+0xd8>

80002168 <SingleDetection_brdcst_func>:
	
}


void SingleDetection_brdcst_func(xcmp_fragment_t * xcmp)
{
80002168:	eb cd 40 80 	pushm	r7,lr
8000216c:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == 0x11)
8000216e:	19 a9       	ld.ub	r9,r12[0x2]
80002170:	31 18       	mov	r8,17
80002172:	f0 09 18 00 	cp.b	r9,r8
80002176:	c0 61       	brne	80002182 <SingleDetection_brdcst_func+0x1a>
	{
		log("\n\r DMR_CSBK OK \n\r");
80002178:	48 8c       	lddpc	r12,80002198 <SingleDetection_brdcst_func+0x30>
8000217a:	f0 1f 00 09 	mcall	8000219c <SingleDetection_brdcst_func+0x34>
8000217e:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	//if(xcmp->u8[1] == 0x11)
	else
	{
		log("SIGBRCST error");
80002182:	48 8c       	lddpc	r12,800021a0 <SingleDetection_brdcst_func+0x38>
80002184:	f0 1f 00 06 	mcall	8000219c <SingleDetection_brdcst_func+0x34>
		log("\n\r Signal_type: %X \n\r", xcmp->u8[0] );
80002188:	0f a8       	ld.ub	r8,r7[0x2]
8000218a:	1a d8       	st.w	--sp,r8
8000218c:	48 6c       	lddpc	r12,800021a4 <SingleDetection_brdcst_func+0x3c>
8000218e:	f0 1f 00 04 	mcall	8000219c <SingleDetection_brdcst_func+0x34>
80002192:	2f fd       	sub	sp,-4
80002194:	e3 cd 80 80 	ldm	sp++,r7,pc
80002198:	80 00       	ld.sh	r0,r0[0x0]
8000219a:	c8 f4       	brge	800020b8 <FD_brdcst_func+0x10>
8000219c:	80 00       	ld.sh	r0,r0[0x0]
8000219e:	67 5c       	ld.w	r12,r3[0x54]
800021a0:	80 00       	ld.sh	r0,r0[0x0]
800021a2:	c9 08       	rjmp	800022c2 <Phyuserinput_brdcst_func+0x3e>
800021a4:	80 00       	ld.sh	r0,r0[0x0]
800021a6:	c9 18       	rjmp	800022c8 <Phyuserinput_brdcst_func+0x44>

800021a8 <ButtonConfig_brdcst_func>:
	
}


void ButtonConfig_brdcst_func(xcmp_fragment_t * xcmp)
{
800021a8:	d4 31       	pushm	r0-r7,lr
	U8 Num_Button =0;
	U8 i = 0 ;
	/*point to xcmp payload*/
	ButtonConfig_brdcst_t  *ptr = (ButtonConfig_brdcst_t* )xcmp->u8;
800021aa:	f8 c7 ff fe 	sub	r7,r12,-2
	
	Num_Button = ptr->NumOfButtons;
800021ae:	0f 95       	ld.ub	r5,r7[0x1]
	
	log("\n\r ButtonConfig_broadcast  \n\r"  );
800021b0:	4a bc       	lddpc	r12,8000225c <ButtonConfig_brdcst_func+0xb4>
800021b2:	f0 1f 00 2c 	mcall	80002260 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r Function: %X \n\r" , ptr->Function );
800021b6:	0f 88       	ld.ub	r8,r7[0x0]
800021b8:	1a d8       	st.w	--sp,r8
800021ba:	4a bc       	lddpc	r12,80002264 <ButtonConfig_brdcst_func+0xbc>
800021bc:	f0 1f 00 29 	mcall	80002260 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
800021c0:	1a d5       	st.w	--sp,r5
800021c2:	4a ac       	lddpc	r12,80002268 <ButtonConfig_brdcst_func+0xc0>
800021c4:	f0 1f 00 27 	mcall	80002260 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
800021c8:	0f a8       	ld.ub	r8,r7[0x2]
800021ca:	1a d8       	st.w	--sp,r8
800021cc:	4a 8c       	lddpc	r12,8000226c <ButtonConfig_brdcst_func+0xc4>
800021ce:	f0 1f 00 25 	mcall	80002260 <ButtonConfig_brdcst_func+0xb8>
	
	for (i; i<Num_Button; i++)
800021d2:	2f dd       	sub	sp,-12
800021d4:	58 05       	cp.w	r5,0
800021d6:	c4 10       	breq	80002258 <ButtonConfig_brdcst_func+0xb0>
800021d8:	30 06       	mov	r6,0
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
800021da:	4a 64       	lddpc	r4,80002270 <ButtonConfig_brdcst_func+0xc8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
800021dc:	4a 63       	lddpc	r3,80002274 <ButtonConfig_brdcst_func+0xcc>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
800021de:	4a 72       	lddpc	r2,80002278 <ButtonConfig_brdcst_func+0xd0>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
800021e0:	4a 71       	lddpc	r1,8000227c <ButtonConfig_brdcst_func+0xd4>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
800021e2:	4a 80       	lddpc	r0,80002280 <ButtonConfig_brdcst_func+0xd8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
800021e4:	0f b9       	ld.ub	r9,r7[0x3]
800021e6:	0f c8       	ld.ub	r8,r7[0x4]
800021e8:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800021ec:	1a d8       	st.w	--sp,r8
800021ee:	1a d6       	st.w	--sp,r6
800021f0:	08 9c       	mov	r12,r4
800021f2:	f0 1f 00 1c 	mcall	80002260 <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
800021f6:	0f d9       	ld.ub	r9,r7[0x5]
800021f8:	0f e8       	ld.ub	r8,r7[0x6]
800021fa:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800021fe:	1a d8       	st.w	--sp,r8
80002200:	1a d6       	st.w	--sp,r6
80002202:	06 9c       	mov	r12,r3
80002204:	f0 1f 00 17 	mcall	80002260 <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
80002208:	0f f9       	ld.ub	r9,r7[0x7]
8000220a:	ef 38 00 08 	ld.ub	r8,r7[8]
8000220e:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002212:	1a d8       	st.w	--sp,r8
80002214:	1a d6       	st.w	--sp,r6
80002216:	04 9c       	mov	r12,r2
80002218:	f0 1f 00 12 	mcall	80002260 <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
8000221c:	ef 39 00 09 	ld.ub	r9,r7[9]
80002220:	ef 38 00 0a 	ld.ub	r8,r7[10]
80002224:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002228:	1a d8       	st.w	--sp,r8
8000222a:	1a d6       	st.w	--sp,r6
8000222c:	02 9c       	mov	r12,r1
8000222e:	f0 1f 00 0d 	mcall	80002260 <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
80002232:	2f 8d       	sub	sp,-32
80002234:	ef 39 00 0b 	ld.ub	r9,r7[11]
80002238:	ef 38 00 0c 	ld.ub	r8,r7[12]
8000223c:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002240:	1a d8       	st.w	--sp,r8
80002242:	1a d6       	st.w	--sp,r6
80002244:	00 9c       	mov	r12,r0
80002246:	f0 1f 00 07 	mcall	80002260 <ButtonConfig_brdcst_func+0xb8>
8000224a:	2f f6       	sub	r6,-1
8000224c:	2f 67       	sub	r7,-10
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
8000224e:	2f ed       	sub	sp,-8
80002250:	ec 05 18 00 	cp.b	r5,r6
80002254:	fe 9b ff c8 	brhi	800021e4 <ButtonConfig_brdcst_func+0x3c>
80002258:	d8 32       	popm	r0-r7,pc
8000225a:	00 00       	add	r0,r0
8000225c:	80 00       	ld.sh	r0,r0[0x0]
8000225e:	c9 30       	breq	80002184 <SingleDetection_brdcst_func+0x1c>
80002260:	80 00       	ld.sh	r0,r0[0x0]
80002262:	67 5c       	ld.w	r12,r3[0x54]
80002264:	80 00       	ld.sh	r0,r0[0x0]
80002266:	c9 50       	breq	80002190 <SingleDetection_brdcst_func+0x28>
80002268:	80 00       	ld.sh	r0,r0[0x0]
8000226a:	c9 64       	brge	80002196 <SingleDetection_brdcst_func+0x2e>
8000226c:	80 00       	ld.sh	r0,r0[0x0]
8000226e:	c9 7c       	rcall	8000239c <DataSession_brdcst_func+0x5c>
80002270:	80 00       	ld.sh	r0,r0[0x0]
80002272:	c9 9c       	rcall	800023a4 <DataSession_brdcst_func+0x64>
80002274:	80 00       	ld.sh	r0,r0[0x0]
80002276:	c9 c4       	brge	800021ae <ButtonConfig_brdcst_func+0x6>
80002278:	80 00       	ld.sh	r0,r0[0x0]
8000227a:	c9 ec       	rcall	800023b6 <DataSession_brdcst_func+0x76>
8000227c:	80 00       	ld.sh	r0,r0[0x0]
8000227e:	ca 10       	breq	800021c0 <ButtonConfig_brdcst_func+0x18>
80002280:	80 00       	ld.sh	r0,r0[0x0]
80002282:	ca 38       	rjmp	800023c8 <DataSession_reply_func+0x4>

80002284 <Phyuserinput_brdcst_func>:
	
}


void Phyuserinput_brdcst_func(xcmp_fragment_t * xcmp)
{
80002284:	eb cd 40 fc 	pushm	r2-r7,lr
	U16 PUI_ID =0;
	U8 PUI_State =0;
	U8 PUI_State_Min_Value =0;
	U8 PUI_State_Max_Value =0;
	
	PUI_Source = xcmp->u8[0];
80002288:	19 a6       	ld.ub	r6,r12[0x2]
	PUI_Type = xcmp ->u8[1];
8000228a:	19 b5       	ld.ub	r5,r12[0x3]
	PUI_ID = ((xcmp->u8[2]<<8) | xcmp->u8[3]);
8000228c:	19 c7       	ld.ub	r7,r12[0x4]
8000228e:	19 d8       	ld.ub	r8,r12[0x5]
80002290:	f1 e7 10 87 	or	r7,r8,r7<<0x8
	PUI_State = xcmp->u8[4];
80002294:	19 e4       	ld.ub	r4,r12[0x6]
	PUI_State_Min_Value = xcmp->u8[5];
80002296:	19 f3       	ld.ub	r3,r12[0x7]
	PUI_State_Max_Value = xcmp->u8[6];
80002298:	f9 32 00 08 	ld.ub	r2,r12[8]
	
	log("\n\r PhysicalUserInput_broadcast  \n\r"  );
8000229c:	49 0c       	lddpc	r12,800022dc <Phyuserinput_brdcst_func+0x58>
8000229e:	f0 1f 00 11 	mcall	800022e0 <Phyuserinput_brdcst_func+0x5c>
	
	log("\n\r PUI_Source: %X \n\r" , PUI_Source);
800022a2:	1a d6       	st.w	--sp,r6
800022a4:	49 0c       	lddpc	r12,800022e4 <Phyuserinput_brdcst_func+0x60>
800022a6:	f0 1f 00 0f 	mcall	800022e0 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_Type: %X \n\r" , PUI_Type);
800022aa:	1a d5       	st.w	--sp,r5
800022ac:	48 fc       	lddpc	r12,800022e8 <Phyuserinput_brdcst_func+0x64>
800022ae:	f0 1f 00 0d 	mcall	800022e0 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_ID: %X \n\r" , PUI_ID);
800022b2:	5c 77       	castu.h	r7
800022b4:	1a d7       	st.w	--sp,r7
800022b6:	48 ec       	lddpc	r12,800022ec <Phyuserinput_brdcst_func+0x68>
800022b8:	f0 1f 00 0a 	mcall	800022e0 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_State: %X \n\r" , PUI_State);
800022bc:	1a d4       	st.w	--sp,r4
800022be:	48 dc       	lddpc	r12,800022f0 <Phyuserinput_brdcst_func+0x6c>
800022c0:	f0 1f 00 08 	mcall	800022e0 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_State_Min_Value: %X \n\r" , PUI_State_Min_Value);
800022c4:	1a d3       	st.w	--sp,r3
800022c6:	48 cc       	lddpc	r12,800022f4 <Phyuserinput_brdcst_func+0x70>
800022c8:	f0 1f 00 06 	mcall	800022e0 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_State_Max_Value: %X \n\r" , PUI_State_Max_Value);
800022cc:	1a d2       	st.w	--sp,r2
800022ce:	48 bc       	lddpc	r12,800022f8 <Phyuserinput_brdcst_func+0x74>
800022d0:	f0 1f 00 04 	mcall	800022e0 <Phyuserinput_brdcst_func+0x5c>
800022d4:	2f ad       	sub	sp,-24
	
	
	
	
	
}
800022d6:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800022da:	00 00       	add	r0,r0
800022dc:	80 00       	ld.sh	r0,r0[0x0]
800022de:	ca 5c       	rcall	80002428 <TransmitControl_reply_func+0xc>
800022e0:	80 00       	ld.sh	r0,r0[0x0]
800022e2:	67 5c       	ld.w	r12,r3[0x54]
800022e4:	80 00       	ld.sh	r0,r0[0x0]
800022e6:	ca 80       	breq	80002236 <ButtonConfig_brdcst_func+0x8e>
800022e8:	80 00       	ld.sh	r0,r0[0x0]
800022ea:	ca 98       	rjmp	8000243c <TransmitControl_reply_func+0x20>
800022ec:	80 00       	ld.sh	r0,r0[0x0]
800022ee:	ca ac       	rcall	80002442 <TransmitControl_reply_func+0x26>
800022f0:	80 00       	ld.sh	r0,r0[0x0]
800022f2:	ca c0       	breq	8000224a <ButtonConfig_brdcst_func+0xa2>
800022f4:	80 00       	ld.sh	r0,r0[0x0]
800022f6:	ca d4       	brge	80002250 <ButtonConfig_brdcst_func+0xa8>
800022f8:	80 00       	ld.sh	r0,r0[0x0]
800022fa:	ca f4       	brge	80002258 <ButtonConfig_brdcst_func+0xb0>

800022fc <ButtonConfig_reply_func>:
	}
	
}

void ButtonConfig_reply_func(xcmp_fragment_t * xcmp)
{
800022fc:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	ButtonConfig_reply_t *ptr = (ButtonConfig_reply_t* )(xcmp->u8);
80002300:	f8 c7 ff fe 	sub	r7,r12,-2
	if (ptr->Result == xcmp_Res_Success)
80002304:	0f 89       	ld.ub	r9,r7[0x0]
80002306:	30 08       	mov	r8,0
80002308:	f0 09 18 00 	cp.b	r9,r8
8000230c:	c0 c1       	brne	80002324 <ButtonConfig_reply_func+0x28>
	{
		log("\n\r Button_Config OK \n\r");
8000230e:	48 9c       	lddpc	r12,80002330 <ButtonConfig_reply_func+0x34>
80002310:	f0 1f 00 09 	mcall	80002334 <ButtonConfig_reply_func+0x38>
		
		log("\n\r Function: %X \n\r" , ptr->Function );
80002314:	0f 98       	ld.ub	r8,r7[0x1]
80002316:	1a d8       	st.w	--sp,r8
80002318:	48 8c       	lddpc	r12,80002338 <ButtonConfig_reply_func+0x3c>
8000231a:	f0 1f 00 07 	mcall	80002334 <ButtonConfig_reply_func+0x38>
8000231e:	2f fd       	sub	sp,-4
80002320:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r Button_Request error \n\r");
80002324:	48 6c       	lddpc	r12,8000233c <ButtonConfig_reply_func+0x40>
80002326:	f0 1f 00 04 	mcall	80002334 <ButtonConfig_reply_func+0x38>
8000232a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000232e:	00 00       	add	r0,r0
80002330:	80 00       	ld.sh	r0,r0[0x0]
80002332:	cb 14       	brge	80002294 <Phyuserinput_brdcst_func+0x10>
80002334:	80 00       	ld.sh	r0,r0[0x0]
80002336:	67 5c       	ld.w	r12,r3[0x54]
80002338:	80 00       	ld.sh	r0,r0[0x0]
8000233a:	c9 50       	breq	80002264 <ButtonConfig_brdcst_func+0xbc>
8000233c:	80 00       	ld.sh	r0,r0[0x0]
8000233e:	cb 2c       	rcall	800024a2 <AudioRoutingControl_brdcst_func+0xa>

80002340 <DataSession_brdcst_func>:
	}
	
}

void DataSession_brdcst_func(xcmp_fragment_t * xcmp)
{
80002340:	d4 21       	pushm	r4-r7,lr
	U8 Session_number = 0;
	U16 data_length = 0;
	U8 i = 0;
	/*point to xcmp payload*/
	DataSession_brdcst_t *ptr = (DataSession_brdcst_t* )xcmp->u8;
80002342:	f8 c6 ff fe 	sub	r6,r12,-2

	if (ptr->State == CSBK_DATA_RX_Suc)
80002346:	0d 88       	ld.ub	r8,r6[0x0]
80002348:	32 49       	mov	r9,36
8000234a:	f2 08 18 00 	cp.b	r8,r9
8000234e:	c2 91       	brne	800023a0 <DataSession_brdcst_func+0x60>
	{
		
		log("\n\r CSBK_RX OK \n\r");
80002350:	49 7c       	lddpc	r12,800023ac <DataSession_brdcst_func+0x6c>
80002352:	f0 1f 00 18 	mcall	800023b0 <DataSession_brdcst_func+0x70>
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
80002356:	0d a5       	ld.ub	r5,r6[0x2]
80002358:	0d b8       	ld.ub	r8,r6[0x3]
8000235a:	f1 e5 10 85 	or	r5,r8,r5<<0x8
8000235e:	5c 85       	casts.h	r5

		log("\n\r Session_ID: %x \n\r",Session_number );
80002360:	0d 98       	ld.ub	r8,r6[0x1]
80002362:	1a d8       	st.w	--sp,r8
80002364:	49 4c       	lddpc	r12,800023b4 <DataSession_brdcst_func+0x74>
80002366:	f0 1f 00 13 	mcall	800023b0 <DataSession_brdcst_func+0x70>
		log("\n\r paylaod_length: %d \n\r",data_length );
8000236a:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
8000236e:	1a d8       	st.w	--sp,r8
80002370:	49 2c       	lddpc	r12,800023b8 <DataSession_brdcst_func+0x78>
80002372:	f0 1f 00 10 	mcall	800023b0 <DataSession_brdcst_func+0x70>
		for(i=0; i<data_length; i++)
80002376:	2f ed       	sub	sp,-8
80002378:	58 05       	cp.w	r5,0
8000237a:	c1 80       	breq	800023aa <DataSession_brdcst_func+0x6a>
8000237c:	30 07       	mov	r7,0
		{
			
			//log("\n\r payload[%d]: %X \n\r", i, xcmp->u8[4+i]);
			log("\n\r payload[%d]: %X \n\r", i, ptr->DataPayload.DataPayload[i]);
8000237e:	49 04       	lddpc	r4,800023bc <DataSession_brdcst_func+0x7c>
80002380:	ec 07 00 08 	add	r8,r6,r7
80002384:	11 c8       	ld.ub	r8,r8[0x4]
80002386:	1a d8       	st.w	--sp,r8
80002388:	1a d7       	st.w	--sp,r7
8000238a:	08 9c       	mov	r12,r4
8000238c:	f0 1f 00 09 	mcall	800023b0 <DataSession_brdcst_func+0x70>
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);

		log("\n\r Session_ID: %x \n\r",Session_number );
		log("\n\r paylaod_length: %d \n\r",data_length );
		for(i=0; i<data_length; i++)
80002390:	2f f7       	sub	r7,-1
80002392:	5c 57       	castu.b	r7
80002394:	2f ed       	sub	sp,-8
80002396:	ee 05 19 00 	cp.h	r5,r7
8000239a:	fe 9b ff f3 	brhi	80002380 <DataSession_brdcst_func+0x40>
8000239e:	d8 22       	popm	r4-r7,pc
		
	}
	else
	{
		//log("\n\r State: 0x %X \n\r", xcmp->u8[0]);
		log("\n\r State: 0x %X \n\r", ptr->State);
800023a0:	1a d8       	st.w	--sp,r8
800023a2:	48 8c       	lddpc	r12,800023c0 <DataSession_brdcst_func+0x80>
800023a4:	f0 1f 00 03 	mcall	800023b0 <DataSession_brdcst_func+0x70>
800023a8:	2f fd       	sub	sp,-4
800023aa:	d8 22       	popm	r4-r7,pc
800023ac:	80 00       	ld.sh	r0,r0[0x0]
800023ae:	cb 48       	rjmp	80002516 <AudioRoutingControl_brdcst_func+0x7e>
800023b0:	80 00       	ld.sh	r0,r0[0x0]
800023b2:	67 5c       	ld.w	r12,r3[0x54]
800023b4:	80 00       	ld.sh	r0,r0[0x0]
800023b6:	cb 5c       	rcall	80002520 <Volume_brdcst_func+0x8>
800023b8:	80 00       	ld.sh	r0,r0[0x0]
800023ba:	cb 74       	brge	80002328 <ButtonConfig_reply_func+0x2c>
800023bc:	80 00       	ld.sh	r0,r0[0x0]
800023be:	cb 90       	breq	80002330 <ButtonConfig_reply_func+0x34>
800023c0:	80 00       	ld.sh	r0,r0[0x0]
800023c2:	cb a8       	rjmp	80002536 <Volume_brdcst_func+0x1e>

800023c4 <DataSession_reply_func>:
	
}


void DataSession_reply_func(xcmp_fragment_t * xcmp)
{
800023c4:	eb cd 40 80 	pushm	r7,lr
800023c8:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
800023ca:	19 a8       	ld.ub	r8,r12[0x2]
800023cc:	58 08       	cp.w	r8,0
800023ce:	c0 61       	brne	800023da <DataSession_reply_func+0x16>
	{
		log("\n\r DATArep OK \n\r");
800023d0:	48 dc       	lddpc	r12,80002404 <DataSession_reply_func+0x40>
800023d2:	f0 1f 00 0e 	mcall	80002408 <DataSession_reply_func+0x44>
800023d6:	e3 cd 80 80 	ldm	sp++,r7,pc
		//log("\n\r ID: 0x %X \n\r", xcmp->u8[2]);
		
	}
	else
	{
		log("\n\r Result:  %X \n\r", xcmp->u8[0]);
800023da:	1a d8       	st.w	--sp,r8
800023dc:	48 cc       	lddpc	r12,8000240c <DataSession_reply_func+0x48>
800023de:	f0 1f 00 0b 	mcall	80002408 <DataSession_reply_func+0x44>
		log("\n\r DATArep error \n\r");
800023e2:	48 cc       	lddpc	r12,80002410 <DataSession_reply_func+0x4c>
800023e4:	f0 1f 00 09 	mcall	80002408 <DataSession_reply_func+0x44>
		log("\n\r Func:  %X \n\r", xcmp->u8[1]);
800023e8:	0f b8       	ld.ub	r8,r7[0x3]
800023ea:	1a d8       	st.w	--sp,r8
800023ec:	48 ac       	lddpc	r12,80002414 <DataSession_reply_func+0x50>
800023ee:	f0 1f 00 07 	mcall	80002408 <DataSession_reply_func+0x44>
		log("\n\r ID:  %X \n\r", xcmp->u8[2]);
800023f2:	0f c8       	ld.ub	r8,r7[0x4]
800023f4:	1a d8       	st.w	--sp,r8
800023f6:	48 9c       	lddpc	r12,80002418 <DataSession_reply_func+0x54>
800023f8:	f0 1f 00 04 	mcall	80002408 <DataSession_reply_func+0x44>
800023fc:	2f dd       	sub	sp,-12
800023fe:	e3 cd 80 80 	ldm	sp++,r7,pc
80002402:	00 00       	add	r0,r0
80002404:	80 00       	ld.sh	r0,r0[0x0]
80002406:	cb bc       	rcall	8000257c <Volume_reply_func+0x30>
80002408:	80 00       	ld.sh	r0,r0[0x0]
8000240a:	67 5c       	ld.w	r12,r3[0x54]
8000240c:	80 00       	ld.sh	r0,r0[0x0]
8000240e:	cb d0       	breq	80002388 <DataSession_brdcst_func+0x48>
80002410:	80 00       	ld.sh	r0,r0[0x0]
80002412:	cb e4       	brge	8000238e <DataSession_brdcst_func+0x4e>
80002414:	80 00       	ld.sh	r0,r0[0x0]
80002416:	cb f8       	rjmp	80002594 <Volume_reply_func+0x48>
80002418:	80 00       	ld.sh	r0,r0[0x0]
8000241a:	cc 08       	rjmp	8000259a <Volume_reply_func+0x4e>

8000241c <TransmitControl_reply_func>:




void TransmitControl_reply_func(xcmp_fragment_t * xcmp)
{
8000241c:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	TransmitControl_reply_t *ptr = (TransmitControl_reply_t* )xcmp->u8;
80002420:	f8 c7 ff fe 	sub	r7,r12,-2
	
	if (ptr->Result == xcmp_Res_Success)
80002424:	0f 89       	ld.ub	r9,r7[0x0]
80002426:	30 08       	mov	r8,0
80002428:	f0 09 18 00 	cp.b	r9,r8
8000242c:	c2 21       	brne	80002470 <TransmitControl_reply_func+0x54>
	{
		
		log("\n\r  TransmitControl OK \n\r ");
8000242e:	49 4c       	lddpc	r12,8000247c <TransmitControl_reply_func+0x60>
80002430:	f0 1f 00 14 	mcall	80002480 <TransmitControl_reply_func+0x64>
		log("\n\r Function: %x \n\r", ptr->Function);
80002434:	0f 98       	ld.ub	r8,r7[0x1]
80002436:	1a d8       	st.w	--sp,r8
80002438:	49 3c       	lddpc	r12,80002484 <TransmitControl_reply_func+0x68>
8000243a:	f0 1f 00 12 	mcall	80002480 <TransmitControl_reply_func+0x64>
		log("\n\r Mode of Operation: %x \n\r", ptr->Mode_Of_Operation);
8000243e:	0f a8       	ld.ub	r8,r7[0x2]
80002440:	1a d8       	st.w	--sp,r8
80002442:	49 2c       	lddpc	r12,80002488 <TransmitControl_reply_func+0x6c>
80002444:	f0 1f 00 0f 	mcall	80002480 <TransmitControl_reply_func+0x64>
		log("\n\r State: %x \n\r", ptr->State);
80002448:	0f b8       	ld.ub	r8,r7[0x3]
8000244a:	1a d8       	st.w	--sp,r8
8000244c:	49 0c       	lddpc	r12,8000248c <TransmitControl_reply_func+0x70>
8000244e:	f0 1f 00 0d 	mcall	80002480 <TransmitControl_reply_func+0x64>
		
		if (ptr->Function == KEY_UP)
80002452:	0f 98       	ld.ub	r8,r7[0x1]
80002454:	2f dd       	sub	sp,-12
80002456:	30 19       	mov	r9,1
80002458:	f2 08 18 00 	cp.b	r8,r9
8000245c:	c0 d0       	breq	80002476 <TransmitControl_reply_func+0x5a>
		{
			//is_unmute = 1;
		}
		else if (ptr->Function ==DE_KEY)
8000245e:	30 29       	mov	r9,2
80002460:	f2 08 18 00 	cp.b	r8,r9
80002464:	c0 91       	brne	80002476 <TransmitControl_reply_func+0x5a>
		{
			is_unmute = 0;
80002466:	30 09       	mov	r9,0
80002468:	48 a8       	lddpc	r8,80002490 <TransmitControl_reply_func+0x74>
8000246a:	b0 89       	st.b	r8[0x0],r9
8000246c:	e3 cd 80 80 	ldm	sp++,r7,pc
		
		//Silent_flag = 1;
	}
	else
	{
		log("TransmitControl error");
80002470:	48 9c       	lddpc	r12,80002494 <TransmitControl_reply_func+0x78>
80002472:	f0 1f 00 04 	mcall	80002480 <TransmitControl_reply_func+0x64>
80002476:	e3 cd 80 80 	ldm	sp++,r7,pc
8000247a:	00 00       	add	r0,r0
8000247c:	80 00       	ld.sh	r0,r0[0x0]
8000247e:	cc 18       	rjmp	80002600 <spk_reply_func+0x10>
80002480:	80 00       	ld.sh	r0,r0[0x0]
80002482:	67 5c       	ld.w	r12,r3[0x54]
80002484:	80 00       	ld.sh	r0,r0[0x0]
80002486:	cc 34       	brge	8000240c <DataSession_reply_func+0x48>
80002488:	80 00       	ld.sh	r0,r0[0x0]
8000248a:	cc 48       	rjmp	80002612 <spk_reply_func+0x22>
8000248c:	80 00       	ld.sh	r0,r0[0x0]
8000248e:	cc 64       	brge	8000241a <DataSession_reply_func+0x56>
80002490:	00 00       	add	r0,r0
80002492:	0a 42       	or	r2,r5
80002494:	80 00       	ld.sh	r0,r0[0x0]
80002496:	cc 74       	brge	80002424 <TransmitControl_reply_func+0x8>

80002498 <AudioRoutingControl_brdcst_func>:
	}
}


void AudioRoutingControl_brdcst_func(xcmp_fragment_t * xcmp)
{
80002498:	eb cd 40 f8 	pushm	r3-r7,lr
8000249c:	18 96       	mov	r6,r12
	
	U16 num_routings = 0;
	U8 j = 0 ;
	
	num_routings = ((xcmp->u8[0]<< 8) | (xcmp->u8[1]) );
8000249e:	19 a5       	ld.ub	r5,r12[0x2]
800024a0:	19 b8       	ld.ub	r8,r12[0x3]
800024a2:	f1 e5 10 85 	or	r5,r8,r5<<0x8
800024a6:	5c 85       	casts.h	r5
	log("\n\r num_routings: %d \n\r", num_routings);
800024a8:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
800024ac:	1a d8       	st.w	--sp,r8
800024ae:	49 6c       	lddpc	r12,80002504 <AudioRoutingControl_brdcst_func+0x6c>
800024b0:	f0 1f 00 16 	mcall	80002508 <AudioRoutingControl_brdcst_func+0x70>
	
	for(j = 0; j< num_routings ; j++ )
800024b4:	2f fd       	sub	sp,-4
800024b6:	58 05       	cp.w	r5,0
800024b8:	c0 31       	brne	800024be <AudioRoutingControl_brdcst_func+0x26>
800024ba:	30 07       	mov	r7,0
800024bc:	c1 98       	rjmp	800024ee <AudioRoutingControl_brdcst_func+0x56>
800024be:	30 07       	mov	r7,0
	{
		
		
		log("\n\r Audio-Input: %x \n\r", xcmp->u8[2+j*2]);
800024c0:	49 34       	lddpc	r4,8000250c <AudioRoutingControl_brdcst_func+0x74>
		log("\n\r Audio-Output: %x \n\r", xcmp->u8[3+j*2]);
800024c2:	49 43       	lddpc	r3,80002510 <AudioRoutingControl_brdcst_func+0x78>
	
	for(j = 0; j< num_routings ; j++ )
	{
		
		
		log("\n\r Audio-Input: %x \n\r", xcmp->u8[2+j*2]);
800024c4:	ec 07 00 18 	add	r8,r6,r7<<0x1
800024c8:	11 c8       	ld.ub	r8,r8[0x4]
800024ca:	1a d8       	st.w	--sp,r8
800024cc:	08 9c       	mov	r12,r4
800024ce:	f0 1f 00 0f 	mcall	80002508 <AudioRoutingControl_brdcst_func+0x70>
		log("\n\r Audio-Output: %x \n\r", xcmp->u8[3+j*2]);
800024d2:	ec 07 00 18 	add	r8,r6,r7<<0x1
800024d6:	11 d8       	ld.ub	r8,r8[0x5]
800024d8:	1a d8       	st.w	--sp,r8
800024da:	06 9c       	mov	r12,r3
800024dc:	f0 1f 00 0b 	mcall	80002508 <AudioRoutingControl_brdcst_func+0x70>
	U8 j = 0 ;
	
	num_routings = ((xcmp->u8[0]<< 8) | (xcmp->u8[1]) );
	log("\n\r num_routings: %d \n\r", num_routings);
	
	for(j = 0; j< num_routings ; j++ )
800024e0:	2f f7       	sub	r7,-1
800024e2:	5c 57       	castu.b	r7
800024e4:	2f ed       	sub	sp,-8
800024e6:	ee 05 19 00 	cp.h	r5,r7
800024ea:	fe 9b ff ed 	brhi	800024c4 <AudioRoutingControl_brdcst_func+0x2c>
		log("\n\r Audio-Output: %x \n\r", xcmp->u8[3+j*2]);
		
		
	}
	
	log("\n\r Audio-Function: %x \n\r", xcmp->u8[3+j*2-1]);
800024ee:	ec 07 00 17 	add	r7,r6,r7<<0x1
800024f2:	0f c8       	ld.ub	r8,r7[0x4]
800024f4:	1a d8       	st.w	--sp,r8
800024f6:	48 8c       	lddpc	r12,80002514 <AudioRoutingControl_brdcst_func+0x7c>
800024f8:	f0 1f 00 04 	mcall	80002508 <AudioRoutingControl_brdcst_func+0x70>
800024fc:	2f fd       	sub	sp,-4
	
	
	
}
800024fe:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80002502:	00 00       	add	r0,r0
80002504:	80 00       	ld.sh	r0,r0[0x0]
80002506:	cc 8c       	rcall	80002696 <mic_reply_func+0x66>
80002508:	80 00       	ld.sh	r0,r0[0x0]
8000250a:	67 5c       	ld.w	r12,r3[0x54]
8000250c:	80 00       	ld.sh	r0,r0[0x0]
8000250e:	cc a4       	brge	800024a2 <AudioRoutingControl_brdcst_func+0xa>
80002510:	80 00       	ld.sh	r0,r0[0x0]
80002512:	cc bc       	rcall	800026a8 <mic_reply_func+0x78>
80002514:	80 00       	ld.sh	r0,r0[0x0]
80002516:	cc d4       	brge	800024b0 <AudioRoutingControl_brdcst_func+0x18>

80002518 <Volume_brdcst_func>:
	
	
}

void Volume_brdcst_func(xcmp_fragment_t * xcmp)
{
80002518:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	VolumeControl_brdcst_t *ptr = (VolumeControl_brdcst_t* )xcmp->u8;
8000251c:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
80002520:	0f 89       	ld.ub	r9,r7[0x0]
80002522:	0f 98       	ld.ub	r8,r7[0x1]
80002524:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002528:	1a d8       	st.w	--sp,r8
8000252a:	48 6c       	lddpc	r12,80002540 <Volume_brdcst_func+0x28>
8000252c:	f0 1f 00 06 	mcall	80002544 <Volume_brdcst_func+0x2c>
	
	log("\n\r Audio_Parameter: %x \n\r", ptr->Audio_Parameter);
80002530:	0f b8       	ld.ub	r8,r7[0x3]
80002532:	1a d8       	st.w	--sp,r8
80002534:	48 5c       	lddpc	r12,80002548 <Volume_brdcst_func+0x30>
80002536:	f0 1f 00 04 	mcall	80002544 <Volume_brdcst_func+0x2c>
8000253a:	2f ed       	sub	sp,-8
	
	
}
8000253c:	e3 cd 80 80 	ldm	sp++,r7,pc
80002540:	80 00       	ld.sh	r0,r0[0x0]
80002542:	cc f0       	breq	800024e0 <AudioRoutingControl_brdcst_func+0x48>
80002544:	80 00       	ld.sh	r0,r0[0x0]
80002546:	67 5c       	ld.w	r12,r3[0x54]
80002548:	80 00       	ld.sh	r0,r0[0x0]
8000254a:	cd 0c       	rcall	800026ea <dcm_brdcst_func+0x26>

8000254c <Volume_reply_func>:
	
}


void Volume_reply_func(xcmp_fragment_t * xcmp)
{
8000254c:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	VolumeControl_reply_t *ptr = (VolumeControl_reply_t* )xcmp->u8;
80002550:	f8 c7 ff fe 	sub	r7,r12,-2
	
		if (ptr->Result == xcmp_Res_Success)
80002554:	0f 89       	ld.ub	r9,r7[0x0]
80002556:	30 08       	mov	r8,0
80002558:	f0 09 18 00 	cp.b	r9,r8
8000255c:	c1 b1       	brne	80002592 <Volume_reply_func+0x46>
		{
			if (ptr->Function == Enable_IntelligentAudio)
8000255e:	0f b8       	ld.ub	r8,r7[0x3]
80002560:	31 09       	mov	r9,16
80002562:	f2 08 18 00 	cp.b	r8,r9
80002566:	c0 f1       	brne	80002584 <Volume_reply_func+0x38>
			{
				log("\n\r Enable_IA OK \n\r");
80002568:	48 dc       	lddpc	r12,8000259c <Volume_reply_func+0x50>
8000256a:	f0 1f 00 0e 	mcall	800025a0 <Volume_reply_func+0x54>
				log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
8000256e:	0f 99       	ld.ub	r9,r7[0x1]
80002570:	0f a8       	ld.ub	r8,r7[0x2]
80002572:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002576:	1a d8       	st.w	--sp,r8
80002578:	48 bc       	lddpc	r12,800025a4 <Volume_reply_func+0x58>
8000257a:	f0 1f 00 0a 	mcall	800025a0 <Volume_reply_func+0x54>
8000257e:	2f fd       	sub	sp,-4
80002580:	e3 cd 80 80 	ldm	sp++,r7,pc
	
			}
			else
			{
				
				log("\n\r VolumeControl: %x \n\r", ptr->Function);
80002584:	1a d8       	st.w	--sp,r8
80002586:	48 9c       	lddpc	r12,800025a8 <Volume_reply_func+0x5c>
80002588:	f0 1f 00 06 	mcall	800025a0 <Volume_reply_func+0x54>
8000258c:	2f fd       	sub	sp,-4
8000258e:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		
		else
		{
			log("\n\r Enable_IA error \n\r");
80002592:	48 7c       	lddpc	r12,800025ac <Volume_reply_func+0x60>
80002594:	f0 1f 00 03 	mcall	800025a0 <Volume_reply_func+0x54>
80002598:	e3 cd 80 80 	ldm	sp++,r7,pc
8000259c:	80 00       	ld.sh	r0,r0[0x0]
8000259e:	cd 28       	rjmp	80002742 <dcm_reply_func+0x36>
800025a0:	80 00       	ld.sh	r0,r0[0x0]
800025a2:	67 5c       	ld.w	r12,r3[0x54]
800025a4:	80 00       	ld.sh	r0,r0[0x0]
800025a6:	cc f0       	breq	80002544 <Volume_brdcst_func+0x2c>
800025a8:	80 00       	ld.sh	r0,r0[0x0]
800025aa:	cd 3c       	rcall	80002750 <dcm_reply_func+0x44>
800025ac:	80 00       	ld.sh	r0,r0[0x0]
800025ae:	cd 54       	brge	80002558 <Volume_reply_func+0xc>

800025b0 <spk_brdcst_func>:
		log("spk error");
	}
}

void spk_brdcst_func(xcmp_fragment_t * xcmp)
{
800025b0:	d4 01       	pushm	lr
	if (xcmp->u8[3] == xcmp_Res_Success)//0x0000:mute
800025b2:	19 d9       	ld.ub	r9,r12[0x5]
800025b4:	30 08       	mov	r8,0
800025b6:	f0 09 18 00 	cp.b	r9,r8
800025ba:	c0 91       	brne	800025cc <spk_brdcst_func+0x1c>
	{
		is_unmute =0;
800025bc:	48 89       	lddpc	r9,800025dc <spk_brdcst_func+0x2c>
800025be:	b2 88       	st.b	r9[0x0],r8
		Silent_flag = 0;
800025c0:	48 89       	lddpc	r9,800025e0 <spk_brdcst_func+0x30>
800025c2:	b2 88       	st.b	r9[0x0],r8
		log("spk_s_close ");
800025c4:	48 8c       	lddpc	r12,800025e4 <spk_brdcst_func+0x34>
800025c6:	f0 1f 00 09 	mcall	800025e8 <spk_brdcst_func+0x38>
800025ca:	d8 02       	popm	pc
		
		
	}
	else
	{
		Silent_flag = 1;
800025cc:	30 19       	mov	r9,1
800025ce:	48 58       	lddpc	r8,800025e0 <spk_brdcst_func+0x30>
800025d0:	b0 89       	st.b	r8[0x0],r9
		//is_unmute = 1;
		log("spk_s_open ");
800025d2:	48 7c       	lddpc	r12,800025ec <spk_brdcst_func+0x3c>
800025d4:	f0 1f 00 05 	mcall	800025e8 <spk_brdcst_func+0x38>
800025d8:	d8 02       	popm	pc
800025da:	00 00       	add	r0,r0
800025dc:	00 00       	add	r0,r0
800025de:	0a 42       	or	r2,r5
800025e0:	00 00       	add	r0,r0
800025e2:	0a 4c       	or	r12,r5
800025e4:	80 00       	ld.sh	r0,r0[0x0]
800025e6:	cd 6c       	rcall	80002792 <ToneControl_reply_func+0x1e>
800025e8:	80 00       	ld.sh	r0,r0[0x0]
800025ea:	67 5c       	ld.w	r12,r3[0x54]
800025ec:	80 00       	ld.sh	r0,r0[0x0]
800025ee:	cd 7c       	rcall	8000279c <app_cfg>

800025f0 <spk_reply_func>:
			
	
}

void spk_reply_func(xcmp_fragment_t * xcmp)
{
800025f0:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
800025f2:	19 a9       	ld.ub	r9,r12[0x2]
800025f4:	30 08       	mov	r8,0
800025f6:	f0 09 18 00 	cp.b	r9,r8
800025fa:	c0 f1       	brne	80002618 <spk_reply_func+0x28>
	{
		
		if(xcmp->u8[4])
800025fc:	19 e9       	ld.ub	r9,r12[0x6]
800025fe:	f0 09 18 00 	cp.b	r9,r8
80002602:	c0 40       	breq	8000260a <spk_reply_func+0x1a>
		{
			is_unmute = 1;
80002604:	30 19       	mov	r9,1
80002606:	48 78       	lddpc	r8,80002620 <spk_reply_func+0x30>
80002608:	b0 89       	st.b	r8[0x0],r9
			
			//Silent_flag = 1;
		}
		log("spk OK -st%2x", xcmp->u8[4] );
8000260a:	19 e8       	ld.ub	r8,r12[0x6]
8000260c:	1a d8       	st.w	--sp,r8
8000260e:	48 6c       	lddpc	r12,80002624 <spk_reply_func+0x34>
80002610:	f0 1f 00 06 	mcall	80002628 <spk_reply_func+0x38>
80002614:	2f fd       	sub	sp,-4
80002616:	d8 02       	popm	pc
		
	}
	else
	{
		log("spk error");
80002618:	48 5c       	lddpc	r12,8000262c <spk_reply_func+0x3c>
8000261a:	f0 1f 00 04 	mcall	80002628 <spk_reply_func+0x38>
8000261e:	d8 02       	popm	pc
80002620:	00 00       	add	r0,r0
80002622:	0a 42       	or	r2,r5
80002624:	80 00       	ld.sh	r0,r0[0x0]
80002626:	cd 88       	rjmp	800027d6 <app_cfg+0x3a>
80002628:	80 00       	ld.sh	r0,r0[0x0]
8000262a:	67 5c       	ld.w	r12,r3[0x54]
8000262c:	80 00       	ld.sh	r0,r0[0x0]
8000262e:	cd 98       	rjmp	800027e0 <app_cfg+0x44>

80002630 <mic_reply_func>:
	
	
}

void mic_reply_func(xcmp_fragment_t * xcmp)
{
80002630:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_reply_t *ptr = (MicControl_reply_t* )xcmp->u8;
80002634:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Mic_reply \n\r");
80002638:	49 ac       	lddpc	r12,800026a0 <mic_reply_func+0x70>
8000263a:	f0 1f 00 1b 	mcall	800026a4 <mic_reply_func+0x74>
	if (ptr->Result == 0x00)
8000263e:	0f 89       	ld.ub	r9,r7[0x0]
80002640:	30 08       	mov	r8,0
80002642:	f0 09 18 00 	cp.b	r9,r8
80002646:	c2 71       	brne	80002694 <mic_reply_func+0x64>
	{
		
		if (ptr->Function == Mic_Disable)
80002648:	0f 98       	ld.ub	r8,r7[0x1]
8000264a:	30 29       	mov	r9,2
8000264c:	f2 08 18 00 	cp.b	r8,r9
80002650:	c1 b1       	brne	80002686 <mic_reply_func+0x56>
		{
		
			log("\n\r Mic_close_ok \n\r " );
80002652:	49 6c       	lddpc	r12,800026a8 <mic_reply_func+0x78>
80002654:	f0 1f 00 14 	mcall	800026a4 <mic_reply_func+0x74>
			log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
80002658:	0f a8       	ld.ub	r8,r7[0x2]
8000265a:	1a d8       	st.w	--sp,r8
8000265c:	49 4c       	lddpc	r12,800026ac <mic_reply_func+0x7c>
8000265e:	f0 1f 00 12 	mcall	800026a4 <mic_reply_func+0x74>
			log("\n\r Signaling_type: %x \n\r " ,  ptr->Signaling_Type);
80002662:	0f b8       	ld.ub	r8,r7[0x3]
80002664:	1a d8       	st.w	--sp,r8
80002666:	49 3c       	lddpc	r12,800026b0 <mic_reply_func+0x80>
80002668:	f0 1f 00 0f 	mcall	800026a4 <mic_reply_func+0x74>
			log("\n\r Mic_state: %x \n\r " ,  ptr->Mic_State);
8000266c:	0f c8       	ld.ub	r8,r7[0x4]
8000266e:	1a d8       	st.w	--sp,r8
80002670:	49 1c       	lddpc	r12,800026b4 <mic_reply_func+0x84>
80002672:	f0 1f 00 0d 	mcall	800026a4 <mic_reply_func+0x74>
			log("\n\r Gain_offset: %x \n\r " ,  ptr->Gain_Offset);
80002676:	0f d8       	ld.ub	r8,r7[0x5]
80002678:	1a d8       	st.w	--sp,r8
8000267a:	49 0c       	lddpc	r12,800026b8 <mic_reply_func+0x88>
8000267c:	f0 1f 00 0a 	mcall	800026a4 <mic_reply_func+0x74>
80002680:	2f cd       	sub	sp,-16
80002682:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else
		{
			log("\n\r Mic_function: %x \n\r ", ptr->Function );
80002686:	1a d8       	st.w	--sp,r8
80002688:	48 dc       	lddpc	r12,800026bc <mic_reply_func+0x8c>
8000268a:	f0 1f 00 07 	mcall	800026a4 <mic_reply_func+0x74>
8000268e:	2f fd       	sub	sp,-4
80002690:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else 
	{
		
	
		log("\n\r Mic error \n\r");
80002694:	48 bc       	lddpc	r12,800026c0 <mic_reply_func+0x90>
80002696:	f0 1f 00 04 	mcall	800026a4 <mic_reply_func+0x74>
8000269a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000269e:	00 00       	add	r0,r0
800026a0:	80 00       	ld.sh	r0,r0[0x0]
800026a2:	cd a4       	brge	80002656 <mic_reply_func+0x26>
800026a4:	80 00       	ld.sh	r0,r0[0x0]
800026a6:	67 5c       	ld.w	r12,r3[0x54]
800026a8:	80 00       	ld.sh	r0,r0[0x0]
800026aa:	cd b4       	brge	80002660 <mic_reply_func+0x30>
800026ac:	80 00       	ld.sh	r0,r0[0x0]
800026ae:	cd c8       	rjmp	80002866 <app_payload_rx_proc+0x26>
800026b0:	80 00       	ld.sh	r0,r0[0x0]
800026b2:	cd dc       	rcall	8000286c <app_payload_rx_proc+0x2c>
800026b4:	80 00       	ld.sh	r0,r0[0x0]
800026b6:	cd f8       	rjmp	80002874 <app_payload_rx_proc+0x34>
800026b8:	80 00       	ld.sh	r0,r0[0x0]
800026ba:	ce 10       	breq	8000267c <mic_reply_func+0x4c>
800026bc:	80 00       	ld.sh	r0,r0[0x0]
800026be:	ce 28       	rjmp	80002882 <app_payload_rx_proc+0x42>
800026c0:	80 00       	ld.sh	r0,r0[0x0]
800026c2:	ce 40       	breq	8000268a <mic_reply_func+0x5a>

800026c4 <dcm_brdcst_func>:
	}
}


void dcm_brdcst_func(xcmp_fragment_t * xcmp)
{
800026c4:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	DeviceControlMode_brdcst_t *ptr = (DeviceControlMode_brdcst_t* )xcmp->u8;
800026c8:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Dcm_brdcst \n\r");		
800026cc:	48 bc       	lddpc	r12,800026f8 <dcm_brdcst_func+0x34>
800026ce:	f0 1f 00 0c 	mcall	800026fc <dcm_brdcst_func+0x38>
	log("\n\r Function: %x \n\r " ,  ptr->Function);
800026d2:	0f 88       	ld.ub	r8,r7[0x0]
800026d4:	1a d8       	st.w	--sp,r8
800026d6:	48 bc       	lddpc	r12,80002700 <dcm_brdcst_func+0x3c>
800026d8:	f0 1f 00 09 	mcall	800026fc <dcm_brdcst_func+0x38>
	log("\n\r ControlType: %x \n\r " ,  ptr->ControlType);
800026dc:	0f a8       	ld.ub	r8,r7[0x2]
800026de:	1a d8       	st.w	--sp,r8
800026e0:	48 9c       	lddpc	r12,80002704 <dcm_brdcst_func+0x40>
800026e2:	f0 1f 00 07 	mcall	800026fc <dcm_brdcst_func+0x38>
	log("\n\r ControlTypeSize: %x \n\r " ,  ptr->ControlTypeSize);
800026e6:	0f 98       	ld.ub	r8,r7[0x1]
800026e8:	1a d8       	st.w	--sp,r8
800026ea:	48 8c       	lddpc	r12,80002708 <dcm_brdcst_func+0x44>
800026ec:	f0 1f 00 04 	mcall	800026fc <dcm_brdcst_func+0x38>
800026f0:	2f dd       	sub	sp,-12
	
	
}
800026f2:	e3 cd 80 80 	ldm	sp++,r7,pc
800026f6:	00 00       	add	r0,r0
800026f8:	80 00       	ld.sh	r0,r0[0x0]
800026fa:	ce 50       	breq	800026c4 <dcm_brdcst_func>
800026fc:	80 00       	ld.sh	r0,r0[0x0]
800026fe:	67 5c       	ld.w	r12,r3[0x54]
80002700:	80 00       	ld.sh	r0,r0[0x0]
80002702:	ce 64       	brge	800026ce <dcm_brdcst_func+0xa>
80002704:	80 00       	ld.sh	r0,r0[0x0]
80002706:	ce 78       	rjmp	800028d4 <AudioRoutingControl_reply_func+0x44>
80002708:	80 00       	ld.sh	r0,r0[0x0]
8000270a:	ce 90       	breq	800026dc <dcm_brdcst_func+0x18>

8000270c <dcm_reply_func>:
		log("Tone error");
	}
}

void dcm_reply_func(xcmp_fragment_t * xcmp)
{
8000270c:	eb cd 40 80 	pushm	r7,lr
80002710:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
80002712:	19 a9       	ld.ub	r9,r12[0x2]
80002714:	30 08       	mov	r8,0
80002716:	f0 09 18 00 	cp.b	r9,r8
8000271a:	c1 b1       	brne	80002750 <dcm_reply_func+0x44>
	{
		if(xcmp->u8[1] == DCM_ENTER)
8000271c:	19 b8       	ld.ub	r8,r12[0x3]
8000271e:	30 19       	mov	r9,1
80002720:	f2 08 18 00 	cp.b	r8,r9
80002724:	c0 51       	brne	8000272e <dcm_reply_func+0x22>
		{
			log("\n\r Dcm-Enter OK \n\r");
80002726:	48 ec       	lddpc	r12,8000275c <dcm_reply_func+0x50>
80002728:	f0 1f 00 0e 	mcall	80002760 <dcm_reply_func+0x54>
8000272c:	c0 a8       	rjmp	80002740 <dcm_reply_func+0x34>
			
		}
		else if (xcmp->u8[1] == DCM_EXIT)
8000272e:	58 08       	cp.w	r8,0
80002730:	c0 51       	brne	8000273a <dcm_reply_func+0x2e>
		{
			log("\n\r Dcm-Exit OK \n\r");
80002732:	48 dc       	lddpc	r12,80002764 <dcm_reply_func+0x58>
80002734:	f0 1f 00 0b 	mcall	80002760 <dcm_reply_func+0x54>
80002738:	c0 48       	rjmp	80002740 <dcm_reply_func+0x34>
		}
		else
		{
			log("\n\r Dcm-Revoke \n\r");
8000273a:	48 cc       	lddpc	r12,80002768 <dcm_reply_func+0x5c>
8000273c:	f0 1f 00 09 	mcall	80002760 <dcm_reply_func+0x54>
		}
		
		log("dcm OK-mo%X", xcmp->u8[3]);
80002740:	0f d8       	ld.ub	r8,r7[0x5]
80002742:	1a d8       	st.w	--sp,r8
80002744:	48 ac       	lddpc	r12,8000276c <dcm_reply_func+0x60>
80002746:	f0 1f 00 07 	mcall	80002760 <dcm_reply_func+0x54>
8000274a:	2f fd       	sub	sp,-4
8000274c:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		log("dcm error");
80002750:	48 8c       	lddpc	r12,80002770 <dcm_reply_func+0x64>
80002752:	f0 1f 00 04 	mcall	80002760 <dcm_reply_func+0x54>
80002756:	e3 cd 80 80 	ldm	sp++,r7,pc
8000275a:	00 00       	add	r0,r0
8000275c:	80 00       	ld.sh	r0,r0[0x0]
8000275e:	ce ac       	rcall	80002932 <fl_write+0x22>
80002760:	80 00       	ld.sh	r0,r0[0x0]
80002762:	67 5c       	ld.w	r12,r3[0x54]
80002764:	80 00       	ld.sh	r0,r0[0x0]
80002766:	ce c0       	breq	8000273e <dcm_reply_func+0x32>
80002768:	80 00       	ld.sh	r0,r0[0x0]
8000276a:	ce d4       	brge	80002744 <dcm_reply_func+0x38>
8000276c:	80 00       	ld.sh	r0,r0[0x0]
8000276e:	ce e8       	rjmp	8000294a <fl_write+0x3a>
80002770:	80 00       	ld.sh	r0,r0[0x0]
80002772:	ce f4       	brge	80002750 <dcm_reply_func+0x44>

80002774 <ToneControl_reply_func>:
			}
		}
}

void ToneControl_reply_func(xcmp_fragment_t * xcmp)
{
80002774:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
80002776:	19 a9       	ld.ub	r9,r12[0x2]
80002778:	30 08       	mov	r8,0
8000277a:	f0 09 18 00 	cp.b	r9,r8
8000277e:	c0 51       	brne	80002788 <ToneControl_reply_func+0x14>
	{		
		log("Tone OK");
80002780:	48 4c       	lddpc	r12,80002790 <ToneControl_reply_func+0x1c>
80002782:	f0 1f 00 05 	mcall	80002794 <ToneControl_reply_func+0x20>
80002786:	d8 02       	popm	pc
		//fl_write("/test.txt", FILE_END, (void *)"send tone ok\r\n", sizeof("send tone ok\r\n") - 1);
	}
	else
	{
		log("Tone error");
80002788:	48 4c       	lddpc	r12,80002798 <ToneControl_reply_func+0x24>
8000278a:	f0 1f 00 03 	mcall	80002794 <ToneControl_reply_func+0x20>
8000278e:	d8 02       	popm	pc
80002790:	80 00       	ld.sh	r0,r0[0x0]
80002792:	cf 00       	breq	80002772 <dcm_reply_func+0x66>
80002794:	80 00       	ld.sh	r0,r0[0x0]
80002796:	67 5c       	ld.w	r12,r3[0x54]
80002798:	80 00       	ld.sh	r0,r0[0x0]
8000279a:	cf 08       	rjmp	8000297a <fl_write+0x6a>

8000279c <app_cfg>:

extern  char AudioData[];
extern U32 tc_tick;

static __app_Thread_(app_cfg)
{
8000279c:	d4 31       	pushm	r0-r7,lr
	static  U32 isAudioRouting = 0;
	static  portTickType xLastWakeTime;
	const portTickType xFrequency = 4000;//2s,2s x  2000hz = 4000
	U8 Burst_ID = 0;
	
	 xLastWakeTime = xTaskGetTickCount();
8000279e:	f0 1f 00 1d 	mcall	80002810 <app_cfg+0x74>
800027a2:	49 d8       	lddpc	r8,80002814 <app_cfg+0x78>
800027a4:	91 0c       	st.w	r8[0x0],r12
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003))//
800027a6:	49 d6       	lddpc	r6,80002818 <app_cfg+0x7c>
				{
					//xcmp_transmit_dekeycontrol();
					
				}
				
				if(isAudioRouting == 0)
800027a8:	49 d5       	lddpc	r5,8000281c <app_cfg+0x80>
				{
					isAudioRouting++;
				}

				//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
				log("\n\r un: %d \n\r", is_unmute);
800027aa:	49 e4       	lddpc	r4,80002820 <app_cfg+0x84>
800027ac:	49 e3       	lddpc	r3,80002824 <app_cfg+0x88>
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_mute_speaker();	
					//log("\n\r time: %d \n\r", tc_tick); 
					isAudioRouting = 3;
800027ae:	30 30       	mov	r0,3
					//xcmp_button_config();
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//log("\n\r time: %d \n\r", tc_tick);
					
					isAudioRouting = 2;
800027b0:	30 21       	mov	r1,2
					xcmp_enter_device_control_mode();//3
					//xcmp_unmute_speaker();
					//is_unmute = 1;
					//xcmp_function_mic();
					
					isAudioRouting = 1;
800027b2:	30 12       	mov	r2,1
			
		}
		//vTaskDelay(300*2 / portTICK_RATE_MS);//300ms
		//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
		
		vTaskDelayUntil( &xLastWakeTime, 2000*2 / portTICK_RATE_MS  );//2000ms
800027b4:	10 97       	mov	r7,r8
	
	 xLastWakeTime = xTaskGetTickCount();
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003))//
800027b6:	6c 08       	ld.w	r8,r6[0x0]
800027b8:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
800027bc:	58 38       	cp.w	r8,3
800027be:	c2 31       	brne	80002804 <app_cfg+0x68>
				{
					//xcmp_transmit_dekeycontrol();
					
				}
				
				if(isAudioRouting == 0)
800027c0:	6a 08       	ld.w	r8,r5[0x0]
800027c2:	58 08       	cp.w	r8,0
800027c4:	c0 51       	brne	800027ce <app_cfg+0x32>
				{
					//xcmp_data_session();
					//xcmp_audio_route_mic();
					//xcmp_button_config();
					//xcmp_audio_route_speaker();
					xcmp_enter_device_control_mode();//3
800027c6:	f0 1f 00 19 	mcall	80002828 <app_cfg+0x8c>
					//xcmp_unmute_speaker();
					//is_unmute = 1;
					//xcmp_function_mic();
					
					isAudioRouting = 1;
800027ca:	8b 02       	st.w	r5[0x0],r2
800027cc:	c1 68       	rjmp	800027f8 <app_cfg+0x5c>
				}
				else if(isAudioRouting == 1)
800027ce:	58 18       	cp.w	r8,1
800027d0:	c0 51       	brne	800027da <app_cfg+0x3e>
				{
					//xcmp_function_mic();
					//xcmp_data_session();
				   // xcmp_transmit_control();
					//xcmp_volume_control();
					xcmp_enter_enhanced_OB_mode();
800027d2:	f0 1f 00 17 	mcall	8000282c <app_cfg+0x90>
					//xcmp_button_config();
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//log("\n\r time: %d \n\r", tc_tick);
					
					isAudioRouting = 2;
800027d6:	8b 01       	st.w	r5[0x0],r1
800027d8:	c1 08       	rjmp	800027f8 <app_cfg+0x5c>
					//isAudioRouting++;
				}
				else if(isAudioRouting == 2)
800027da:	58 28       	cp.w	r8,2
800027dc:	c0 51       	brne	800027e6 <app_cfg+0x4a>
				{
					
					xcmp_exit_device_control_mode();
800027de:	f0 1f 00 15 	mcall	80002830 <app_cfg+0x94>
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_mute_speaker();	
					//log("\n\r time: %d \n\r", tc_tick); 
					isAudioRouting = 3;
800027e2:	8b 00       	st.w	r5[0x0],r0
800027e4:	c0 a8       	rjmp	800027f8 <app_cfg+0x5c>
					
				}
				else if(isAudioRouting == 3)
800027e6:	58 38       	cp.w	r8,3
800027e8:	c0 61       	brne	800027f4 <app_cfg+0x58>
				{
					xcmp_audio_route_AMBE();
800027ea:	f0 1f 00 13 	mcall	80002834 <app_cfg+0x98>
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_exit_enhanced_OB_mode();
					//xcmp_mute_speaker();
					//xcmp_enhanced_OB_mode();
					isAudioRouting = 4;
800027ee:	30 48       	mov	r8,4
800027f0:	8b 08       	st.w	r5[0x0],r8
800027f2:	c0 38       	rjmp	800027f8 <app_cfg+0x5c>
					
				}
				else
				{
					isAudioRouting++;
800027f4:	2f f8       	sub	r8,-1
800027f6:	8b 08       	st.w	r5[0x0],r8
				}

				//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
				log("\n\r un: %d \n\r", is_unmute);
800027f8:	07 88       	ld.ub	r8,r3[0x0]
800027fa:	1a d8       	st.w	--sp,r8
800027fc:	08 9c       	mov	r12,r4
800027fe:	f0 1f 00 0f 	mcall	80002838 <app_cfg+0x9c>
80002802:	2f fd       	sub	sp,-4
			
		}
		//vTaskDelay(300*2 / portTICK_RATE_MS);//300ms
		//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
		
		vTaskDelayUntil( &xLastWakeTime, 2000*2 / portTICK_RATE_MS  );//2000ms
80002804:	e0 6b 0f a0 	mov	r11,4000
80002808:	0e 9c       	mov	r12,r7
8000280a:	f0 1f 00 0d 	mcall	8000283c <app_cfg+0xa0>
	}
8000280e:	cd 4b       	rjmp	800027b6 <app_cfg+0x1a>
80002810:	80 00       	ld.sh	r0,r0[0x0]
80002812:	60 d0       	ld.w	r0,r0[0x34]
80002814:	00 00       	add	r0,r0
80002816:	0a 48       	or	r8,r5
80002818:	00 00       	add	r0,r0
8000281a:	0d b4       	ld.ub	r4,r6[0x3]
8000281c:	00 00       	add	r0,r0
8000281e:	0a 44       	or	r4,r5
80002820:	80 00       	ld.sh	r0,r0[0x0]
80002822:	cf 14       	brge	80002804 <app_cfg+0x68>
80002824:	00 00       	add	r0,r0
80002826:	0a 42       	or	r2,r5
80002828:	80 00       	ld.sh	r0,r0[0x0]
8000282a:	43 e8       	lddsp	r8,sp[0xf8]
8000282c:	80 00       	ld.sh	r0,r0[0x0]
8000282e:	44 60       	lddsp	r0,sp[0x118]
80002830:	80 00       	ld.sh	r0,r0[0x0]
80002832:	43 b8       	lddsp	r8,sp[0xec]
80002834:	80 00       	ld.sh	r0,r0[0x0]
80002836:	44 14       	lddsp	r4,sp[0x104]
80002838:	80 00       	ld.sh	r0,r0[0x0]
8000283a:	67 5c       	ld.w	r12,r3[0x54]
8000283c:	80 00       	ld.sh	r0,r0[0x0]
8000283e:	62 38       	ld.w	r8,r1[0xc]

80002840 <app_payload_rx_proc>:
}


static void app_payload_rx_proc(void  * payload)
{
80002840:	eb cd 40 80 	pushm	r7,lr
80002844:	18 97       	mov	r7,r12
	log("\n\r w: \n\r");
80002846:	48 cc       	lddpc	r12,80002874 <app_payload_rx_proc+0x34>
80002848:	f0 1f 00 0c 	mcall	80002878 <app_payload_rx_proc+0x38>
	if (AMBE_tx_flag)//mic
8000284c:	48 c8       	lddpc	r8,8000287c <app_payload_rx_proc+0x3c>
8000284e:	11 89       	ld.ub	r9,r8[0x0]
80002850:	30 08       	mov	r8,0
80002852:	f0 09 18 00 	cp.b	r9,r8
80002856:	c0 80       	breq	80002866 <app_payload_rx_proc+0x26>
	{
		fl_write("AMBEvo.bit", FILE_END, payload, MAX_PAYLOAD_BUFF_SIZE * 2);
80002858:	e0 69 02 00 	mov	r9,512
8000285c:	0e 9a       	mov	r10,r7
8000285e:	3f fb       	mov	r11,-1
80002860:	48 8c       	lddpc	r12,80002880 <app_payload_rx_proc+0x40>
80002862:	f0 1f 00 09 	mcall	80002884 <app_payload_rx_proc+0x44>
	{
		//fl_write("PCMvo.pcm", FILE_END, payload, MAX_PAYLOAD_BUFF_SIZE * 2);
	}
	
	//payload_fragment_t * ptr = (payload_fragment_t *)payload;
	set_payload_idle(payload);
80002866:	48 98       	lddpc	r8,80002888 <app_payload_rx_proc+0x48>
80002868:	70 0c       	ld.w	r12,r8[0x0]
8000286a:	0e 9b       	mov	r11,r7
8000286c:	f0 1f 00 08 	mcall	8000288c <app_payload_rx_proc+0x4c>

}
80002870:	e3 cd 80 80 	ldm	sp++,r7,pc
80002874:	80 00       	ld.sh	r0,r0[0x0]
80002876:	cf 24       	brge	8000285a <app_payload_rx_proc+0x1a>
80002878:	80 00       	ld.sh	r0,r0[0x0]
8000287a:	67 5c       	ld.w	r12,r3[0x54]
8000287c:	00 00       	add	r0,r0
8000287e:	0a 40       	or	r0,r5
80002880:	80 00       	ld.sh	r0,r0[0x0]
80002882:	cf 30       	breq	80002868 <app_payload_rx_proc+0x28>
80002884:	80 00       	ld.sh	r0,r0[0x0]
80002886:	29 10       	sub	r0,-111
80002888:	00 00       	add	r0,r0
8000288a:	0a 74       	tst	r4,r5
8000288c:	80 00       	ld.sh	r0,r0[0x0]
8000288e:	2a fc       	sub	r12,-81

80002890 <AudioRoutingControl_reply_func>:
	
}


void AudioRoutingControl_reply_func(xcmp_fragment_t * xcmp)
{
80002890:	eb cd 40 80 	pushm	r7,lr
80002894:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
80002896:	19 a9       	ld.ub	r9,r12[0x2]
80002898:	30 08       	mov	r8,0
8000289a:	f0 09 18 00 	cp.b	r9,r8
8000289e:	c0 81       	brne	800028ae <AudioRoutingControl_reply_func+0x1e>
	{
		log("AudioRouting OK");
800028a0:	48 9c       	lddpc	r12,800028c4 <AudioRoutingControl_reply_func+0x34>
800028a2:	f0 1f 00 0a 	mcall	800028c8 <AudioRoutingControl_reply_func+0x38>
		xcmp_IdleTestTone();//
800028a6:	f0 1f 00 0a 	mcall	800028cc <AudioRoutingControl_reply_func+0x3c>
800028aa:	e3 cd 80 80 	ldm	sp++,r7,pc
		//is_unmute = 1;
	}
	else
	{
		log("AudioRouting error");
800028ae:	48 9c       	lddpc	r12,800028d0 <AudioRoutingControl_reply_func+0x40>
800028b0:	f0 1f 00 06 	mcall	800028c8 <AudioRoutingControl_reply_func+0x38>
		log("\n\r AudioRouting result: %x \n\r", xcmp->u8[0]);
800028b4:	0f a8       	ld.ub	r8,r7[0x2]
800028b6:	1a d8       	st.w	--sp,r8
800028b8:	48 7c       	lddpc	r12,800028d4 <AudioRoutingControl_reply_func+0x44>
800028ba:	f0 1f 00 04 	mcall	800028c8 <AudioRoutingControl_reply_func+0x38>
800028be:	2f fd       	sub	sp,-4
800028c0:	e3 cd 80 80 	ldm	sp++,r7,pc
800028c4:	80 00       	ld.sh	r0,r0[0x0]
800028c6:	cf 3c       	rcall	80002aac <set_idle_store_isr+0x4>
800028c8:	80 00       	ld.sh	r0,r0[0x0]
800028ca:	67 5c       	ld.w	r12,r3[0x54]
800028cc:	80 00       	ld.sh	r0,r0[0x0]
800028ce:	45 30       	lddsp	r0,sp[0x14c]
800028d0:	80 00       	ld.sh	r0,r0[0x0]
800028d2:	cf 4c       	rcall	80002aba <set_idle_store_isr+0x12>
800028d4:	80 00       	ld.sh	r0,r0[0x0]
800028d6:	cf 60       	breq	800028c2 <AudioRoutingControl_reply_func+0x32>

800028d8 <DeviceInitializationStatus_brdcst_func>:
static void app_payload_tx_proc(void  * payload);

//app func--list

void DeviceInitializationStatus_brdcst_func(xcmp_fragment_t  * xcmp)
{
800028d8:	d4 01       	pushm	lr
	if (xcmp->u8[4] == 0x01)
800028da:	19 e8       	ld.ub	r8,r12[0x6]
800028dc:	30 19       	mov	r9,1
800028de:	f2 08 18 00 	cp.b	r8,r9
800028e2:	c0 61       	brne	800028ee <DeviceInitializationStatus_brdcst_func+0x16>
	{
		bunchofrandomstatusflags |= 0x01;  //Need do nothing else.
800028e4:	48 98       	lddpc	r8,80002908 <DeviceInitializationStatus_brdcst_func+0x30>
800028e6:	70 09       	ld.w	r9,r8[0x0]
800028e8:	a1 a9       	sbr	r9,0x0
800028ea:	91 09       	st.w	r8[0x0],r9
800028ec:	d8 02       	popm	pc
	}
	else if(xcmp->u8[4] != 0x02)
800028ee:	30 29       	mov	r9,2
800028f0:	f2 08 18 00 	cp.b	r8,r9
800028f4:	c0 80       	breq	80002904 <DeviceInitializationStatus_brdcst_func+0x2c>
	{
		bunchofrandomstatusflags  &= 0xFFFFFFFC; //Device Init no longer Complete.
800028f6:	48 58       	lddpc	r8,80002908 <DeviceInitializationStatus_brdcst_func+0x30>
800028f8:	70 09       	ld.w	r9,r8[0x0]
800028fa:	e0 19 ff fc 	andl	r9,0xfffc
800028fe:	91 09       	st.w	r8[0x0],r9
		xcmp_DeviceInitializationStatus_request();
80002900:	f0 1f 00 03 	mcall	8000290c <DeviceInitializationStatus_brdcst_func+0x34>
80002904:	d8 02       	popm	pc
80002906:	00 00       	add	r0,r0
80002908:	00 00       	add	r0,r0
8000290a:	0d b4       	ld.ub	r4,r6[0x3]
8000290c:	80 00       	ld.sh	r0,r0[0x0]
8000290e:	44 84       	lddsp	r4,sp[0x120]

80002910 <fl_write>:
	}
}


void fl_write(void * path, S32 offset, void * buffer, U32 length)
{
80002910:	eb cd 40 f8 	pushm	r3-r7,lr
80002914:	20 2d       	sub	sp,8
80002916:	18 95       	mov	r5,r12
80002918:	16 94       	mov	r4,r11
8000291a:	14 93       	mov	r3,r10
8000291c:	12 96       	mov	r6,r9
	
	fl_write_t * fl_write_ptr = pvPortMalloc(sizeof(fl_write_t));
8000291e:	34 cc       	mov	r12,76
80002920:	f0 1f 00 16 	mcall	80002978 <fl_write+0x68>
80002924:	18 97       	mov	r7,r12
	
	sprintf(fl_write_ptr->path, "%s", path);
80002926:	0a 9b       	mov	r11,r5
80002928:	f0 1f 00 15 	mcall	8000297c <fl_write+0x6c>
	fl_write_ptr->offset = offset;
8000292c:	ef 44 00 40 	st.w	r7[64],r4
	fl_write_ptr->length = length;	
80002930:	ef 46 00 44 	st.w	r7[68],r6
	
	fl_write_ptr->buffer = pvPortMalloc(length);
80002934:	0c 9c       	mov	r12,r6
80002936:	f0 1f 00 11 	mcall	80002978 <fl_write+0x68>
8000293a:	ef 4c 00 48 	st.w	r7[72],r12
	memcpy(fl_write_ptr->buffer, buffer, length);
8000293e:	0c 9a       	mov	r10,r6
80002940:	06 9b       	mov	r11,r3
80002942:	f0 1f 00 10 	mcall	80002980 <fl_write+0x70>
	
	fl_oper_t fl_oper;
	
	fl_oper.opcode = FL_WRITE;
80002946:	e0 68 40 00 	mov	r8,16384
8000294a:	ba 08       	st.h	sp[0x0],r8
	fl_oper.payload = fl_write_ptr;
8000294c:	50 17       	stdsp	sp[0x4],r7
	
	if(pdTRUE != xQueueSend( fl_oper_queue, &fl_oper, 0 ))
8000294e:	48 e8       	lddpc	r8,80002984 <fl_write+0x74>
80002950:	70 0c       	ld.w	r12,r8[0x0]
80002952:	30 09       	mov	r9,0
80002954:	12 9a       	mov	r10,r9
80002956:	1a 9b       	mov	r11,sp
80002958:	f0 1f 00 0c 	mcall	80002988 <fl_write+0x78>
8000295c:	58 1c       	cp.w	r12,1
8000295e:	c0 a0       	breq	80002972 <fl_write+0x62>
	{
		vPortFree(fl_write_ptr->buffer);
80002960:	6f 2c       	ld.w	r12,r7[0x48]
80002962:	f0 1f 00 0b 	mcall	8000298c <fl_write+0x7c>
		vPortFree(fl_write_ptr);
80002966:	0e 9c       	mov	r12,r7
80002968:	f0 1f 00 09 	mcall	8000298c <fl_write+0x7c>
		log("\n\r Wmm \n\r");//man...SPI_PBA
8000296c:	48 9c       	lddpc	r12,80002990 <fl_write+0x80>
8000296e:	f0 1f 00 0a 	mcall	80002994 <fl_write+0x84>
	}
	
}
80002972:	2f ed       	sub	sp,-8
80002974:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80002978:	80 00       	ld.sh	r0,r0[0x0]
8000297a:	58 18       	cp.w	r8,1
8000297c:	80 00       	ld.sh	r0,r0[0x0]
8000297e:	75 30       	ld.w	r0,r10[0x4c]
80002980:	80 00       	ld.sh	r0,r0[0x0]
80002982:	70 bc       	ld.w	r12,r8[0x2c]
80002984:	00 00       	add	r0,r0
80002986:	0a 54       	eor	r4,r5
80002988:	80 00       	ld.sh	r0,r0[0x0]
8000298a:	5b 6c       	cp.w	r12,-10
8000298c:	80 00       	ld.sh	r0,r0[0x0]
8000298e:	57 f0       	stdsp	sp[0x1fc],r0
80002990:	80 00       	ld.sh	r0,r0[0x0]
80002992:	cf 90       	breq	80002984 <fl_write+0x74>
80002994:	80 00       	ld.sh	r0,r0[0x0]
80002996:	67 5c       	ld.w	r12,r3[0x54]

80002998 <CalculateBurst>:
Calls:
Called By: phy_payload_rx
*/

volatile RxAMBEBurstType CalculateBurst(U8 vf_sn)
{
80002998:	20 1c       	sub	r12,1
8000299a:	5c 5c       	castu.b	r12
8000299c:	31 18       	mov	r8,17
8000299e:	f0 0c 18 00 	cp.b	r12,r8
800029a2:	e0 88 00 03 	brls	800029a8 <CalculateBurst+0x10>
800029a6:	5e fd       	retal	0
800029a8:	48 28       	lddpc	r8,800029b0 <CalculateBurst+0x18>
800029aa:	f0 0c 03 2c 	ld.w	r12,r8[r12<<0x2]
			Burst_ID = 0x00;
			return VOICE_WATING;
		
	}
	
}
800029ae:	5e fc       	retal	r12
800029b0:	80 00       	ld.sh	r0,r0[0x0]
800029b2:	cf f4       	brge	800029b0 <CalculateBurst+0x18>

800029b4 <payload_init>:
	Create the corresponding task;
Calls: xTaskCreate--freertos
Called By:app_init -- app.c
*/
void payload_init(void ( *payload_rx_func)(void * ), void ( *payload_tx_func)(void * ) )
{				
800029b4:	eb cd 40 80 	pushm	r7,lr
	payload_rx_exec = payload_rx_func;
800029b8:	48 f8       	lddpc	r8,800029f4 <payload_init+0x40>
800029ba:	91 0c       	st.w	r8[0x0],r12
	payload_tx_exec = payload_tx_func;
800029bc:	48 f8       	lddpc	r8,800029f8 <payload_init+0x44>
800029be:	91 0b       	st.w	r8[0x0],r11
	
	
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
800029c0:	30 07       	mov	r7,0
800029c2:	1a d7       	st.w	--sp,r7
800029c4:	1a d7       	st.w	--sp,r7
800029c6:	1a d7       	st.w	--sp,r7
800029c8:	30 28       	mov	r8,2
800029ca:	0e 99       	mov	r9,r7
800029cc:	e0 6a 04 00 	mov	r10,1024
800029d0:	48 bb       	lddpc	r11,800029fc <payload_init+0x48>
800029d2:	48 cc       	lddpc	r12,80002a00 <payload_init+0x4c>
800029d4:	f0 1f 00 0c 	mcall	80002a04 <payload_init+0x50>
	,  2
	,  NULL
	);
	
	/*this task is used to transmit  payload message*/
	xTaskCreate(
800029d8:	1a d7       	st.w	--sp,r7
800029da:	1a d7       	st.w	--sp,r7
800029dc:	1a d7       	st.w	--sp,r7
800029de:	30 28       	mov	r8,2
800029e0:	0e 99       	mov	r9,r7
800029e2:	e0 6a 04 00 	mov	r10,1024
800029e6:	48 9b       	lddpc	r11,80002a08 <payload_init+0x54>
800029e8:	48 9c       	lddpc	r12,80002a0c <payload_init+0x58>
800029ea:	f0 1f 00 07 	mcall	80002a04 <payload_init+0x50>
800029ee:	2f ad       	sub	sp,-24
	,  2
	,  NULL
	);
	
	
}
800029f0:	e3 cd 80 80 	ldm	sp++,r7,pc
800029f4:	00 00       	add	r0,r0
800029f6:	0a 58       	eor	r8,r5
800029f8:	00 00       	add	r0,r0
800029fa:	0a 5c       	eor	r12,r5
800029fc:	80 00       	ld.sh	r0,r0[0x0]
800029fe:	d5 ec       	*unknown*
80002a00:	80 00       	ld.sh	r0,r0[0x0]
80002a02:	2a 5c       	sub	r12,-91
80002a04:	80 00       	ld.sh	r0,r0[0x0]
80002a06:	63 98       	ld.w	r8,r1[0x64]
80002a08:	80 00       	ld.sh	r0,r0[0x0]
80002a0a:	d5 f8       	*unknown*
80002a0c:	80 00       	ld.sh	r0,r0[0x0]
80002a0e:	2a 10       	sub	r0,-95

80002a10 <payload_tx_process>:
Description: Transmit the payload
Calls:
Called By:task
*/
static void payload_tx_process(void * pvParameters)
{
80002a10:	eb cd 40 f8 	pushm	r3-r7,lr
80002a14:	20 1d       	sub	sp,4
	/*To store the elements in the queue*/
	U16  * payload_ptr;
	
	if(NULL == phy_payload_frame_tx)
80002a16:	48 e8       	lddpc	r8,80002a4c <payload_tx_process+0x3c>
80002a18:	70 08       	ld.w	r8,r8[0x0]
80002a1a:	58 08       	cp.w	r8,0
80002a1c:	c0 71       	brne	80002a2a <payload_tx_process+0x1a>
	{
		phy_payload_frame_tx = xQueueCreate(TX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
80002a1e:	30 4b       	mov	r11,4
80002a20:	30 5c       	mov	r12,5
80002a22:	f0 1f 00 0c 	mcall	80002a50 <payload_tx_process+0x40>
80002a26:	48 a8       	lddpc	r8,80002a4c <payload_tx_process+0x3c>
80002a28:	91 0c       	st.w	r8[0x0],r12
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_tx, &payload_ptr,portMAX_DELAY ))
80002a2a:	48 96       	lddpc	r6,80002a4c <payload_tx_process+0x3c>
80002a2c:	30 05       	mov	r5,0
80002a2e:	3f f4       	mov	r4,-1
		{
			payload_tx_exec(payload_ptr);//app_payload_tx_proc();
80002a30:	48 93       	lddpc	r3,80002a54 <payload_tx_process+0x44>
		phy_payload_frame_tx = xQueueCreate(TX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_tx, &payload_ptr,portMAX_DELAY ))
80002a32:	6c 0c       	ld.w	r12,r6[0x0]
80002a34:	0a 99       	mov	r9,r5
80002a36:	08 9a       	mov	r10,r4
80002a38:	1a 9b       	mov	r11,sp
80002a3a:	f0 1f 00 08 	mcall	80002a58 <payload_tx_process+0x48>
80002a3e:	58 1c       	cp.w	r12,1
80002a40:	cf 91       	brne	80002a32 <payload_tx_process+0x22>
		{
			payload_tx_exec(payload_ptr);//app_payload_tx_proc();
80002a42:	66 08       	ld.w	r8,r3[0x0]
80002a44:	40 0c       	lddsp	r12,sp[0x0]
80002a46:	5d 18       	icall	r8
80002a48:	cf 5b       	rjmp	80002a32 <payload_tx_process+0x22>
80002a4a:	00 00       	add	r0,r0
80002a4c:	00 00       	add	r0,r0
80002a4e:	0a b8       	st.h	r5++,r8
80002a50:	80 00       	ld.sh	r0,r0[0x0]
80002a52:	5c c4       	swap.bh	r4
80002a54:	00 00       	add	r0,r0
80002a56:	0a 5c       	eor	r12,r5
80002a58:	80 00       	ld.sh	r0,r0[0x0]
80002a5a:	59 60       	cp.w	r0,22

80002a5c <payload_rx_process>:
Description: Receive the payload
Calls:
Called By:task
*/
static void payload_rx_process(void * pvParameters)
{
80002a5c:	eb cd 40 f8 	pushm	r3-r7,lr
80002a60:	20 1d       	sub	sp,4
	/*To store the elements in the queue*/
	U16  * payload_ptr;
		
	if(NULL ==   phy_payload_frame_rx)
80002a62:	48 e8       	lddpc	r8,80002a98 <payload_rx_process+0x3c>
80002a64:	70 08       	ld.w	r8,r8[0x0]
80002a66:	58 08       	cp.w	r8,0
80002a68:	c0 71       	brne	80002a76 <payload_rx_process+0x1a>
	{
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
80002a6a:	30 4b       	mov	r11,4
80002a6c:	30 5c       	mov	r12,5
80002a6e:	f0 1f 00 0c 	mcall	80002a9c <payload_rx_process+0x40>
80002a72:	48 a8       	lddpc	r8,80002a98 <payload_rx_process+0x3c>
80002a74:	91 0c       	st.w	r8[0x0],r12
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_rx, &payload_ptr,portMAX_DELAY ))
80002a76:	48 96       	lddpc	r6,80002a98 <payload_rx_process+0x3c>
80002a78:	30 05       	mov	r5,0
80002a7a:	3f f4       	mov	r4,-1
		{			
			payload_rx_exec(payload_ptr);//app_payload_rx_proc();
80002a7c:	48 93       	lddpc	r3,80002aa0 <payload_rx_process+0x44>
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_rx, &payload_ptr,portMAX_DELAY ))
80002a7e:	6c 0c       	ld.w	r12,r6[0x0]
80002a80:	0a 99       	mov	r9,r5
80002a82:	08 9a       	mov	r10,r4
80002a84:	1a 9b       	mov	r11,sp
80002a86:	f0 1f 00 08 	mcall	80002aa4 <payload_rx_process+0x48>
80002a8a:	58 1c       	cp.w	r12,1
80002a8c:	cf 91       	brne	80002a7e <payload_rx_process+0x22>
		{			
			payload_rx_exec(payload_ptr);//app_payload_rx_proc();
80002a8e:	66 08       	ld.w	r8,r3[0x0]
80002a90:	40 0c       	lddsp	r12,sp[0x0]
80002a92:	5d 18       	icall	r8
80002a94:	cf 5b       	rjmp	80002a7e <payload_rx_process+0x22>
80002a96:	00 00       	add	r0,r0
80002a98:	00 00       	add	r0,r0
80002a9a:	0a e0       	st.h	--r5,r0
80002a9c:	80 00       	ld.sh	r0,r0[0x0]
80002a9e:	5c c4       	swap.bh	r4
80002aa0:	00 00       	add	r0,r0
80002aa2:	0a 58       	eor	r8,r5
80002aa4:	80 00       	ld.sh	r0,r0[0x0]
80002aa6:	59 60       	cp.w	r0,22

80002aa8 <set_idle_store_isr>:
{
	xQueueSend(store, &ptr, 0);
}

void set_idle_store_isr(xQueueHandle store, void * ptr)
{
80002aa8:	d4 01       	pushm	lr
80002aaa:	20 2d       	sub	sp,8
80002aac:	50 0b       	stdsp	sp[0x0],r11
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002aae:	30 09       	mov	r9,0
80002ab0:	fa ca ff f8 	sub	r10,sp,-8
80002ab4:	14 d9       	st.w	--r10,r9
	xQueueSendFromISR(store, &ptr, &xHigherPriorityTaskWoken);
80002ab6:	1a 9b       	mov	r11,sp
80002ab8:	f0 1f 00 02 	mcall	80002ac0 <set_idle_store_isr+0x18>
}
80002abc:	2f ed       	sub	sp,-8
80002abe:	d8 02       	popm	pc
80002ac0:	80 00       	ld.sh	r0,r0[0x0]
80002ac2:	5b 1c       	cp.w	r12,-15

80002ac4 <phy_rx>:
	xQueueSendFromISR -- freertos
Called By: phy_xnl_rx
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
80002ac4:	d4 01       	pushm	lr
80002ac6:	20 2d       	sub	sp,8
80002ac8:	50 0c       	stdsp	sp[0x0],r12
	//memcpy(xx, phy_ptr, sizeof(phy_fragment_t));
	//set_phy_idle_isr(&phy_ptr, &xHigherPriorityTaskWoken);
	
	Bool res = FALSE;
	
	if(NULL == phy_ptr)
80002aca:	58 0c       	cp.w	r12,0
80002acc:	c1 10       	breq	80002aee <phy_rx+0x2a>
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
    /*variables are used to store the push result in interrupt*/
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002ace:	30 08       	mov	r8,0
80002ad0:	50 18       	stdsp	sp[0x4],r8
	if(NULL == phy_ptr)
	{
		return;
	}
	
    U16 phy_ctrl = phy_ptr->xnl_fragment.phy_header.phy_control;
80002ad2:	98 88       	ld.uh	r8,r12[0x0]
80002ad4:	e2 18 f0 00 	andl	r8,0xf000,COH
80002ad8:	e0 48 40 00 	cp.w	r8,16384
80002adc:	c0 91       	brne	80002aee <phy_rx+0x2a>

    if (XCMPXNL_DATA == (phy_ctrl & 0xF000))
    {
        /*push the xnl packet to queue*/
        if( pdTRUE == xQueueSendFromISR(
80002ade:	48 68       	lddpc	r8,80002af4 <phy_rx+0x30>
80002ae0:	70 0c       	ld.w	r12,r8[0x0]
80002ae2:	30 09       	mov	r9,0
80002ae4:	fa ca ff fc 	sub	r10,sp,-4
80002ae8:	1a 9b       	mov	r11,sp
80002aea:	f0 1f 00 04 	mcall	80002af8 <phy_rx+0x34>
		}	

    }
		
 
}
80002aee:	2f ed       	sub	sp,-8
80002af0:	d8 02       	popm	pc
80002af2:	00 00       	add	r0,r0
80002af4:	00 00       	add	r0,r0
80002af6:	0a c0       	st.b	r5++,r0
80002af8:	80 00       	ld.sh	r0,r0[0x0]
80002afa:	5b 1c       	cp.w	r12,-15

80002afc <set_idle_store>:
	}
}


void set_idle_store(xQueueHandle store, void * ptr)
{
80002afc:	eb cd 40 80 	pushm	r7,lr
80002b00:	20 1d       	sub	sp,4
80002b02:	fa c7 ff fc 	sub	r7,sp,-4
80002b06:	0e db       	st.w	--r7,r11
	xQueueSend(store, &ptr, 0);
80002b08:	30 09       	mov	r9,0
80002b0a:	12 9a       	mov	r10,r9
80002b0c:	1a 9b       	mov	r11,sp
80002b0e:	f0 1f 00 03 	mcall	80002b18 <set_idle_store+0x1c>
}
80002b12:	2f fd       	sub	sp,-4
80002b14:	e3 cd 80 80 	ldm	sp++,r7,pc
80002b18:	80 00       	ld.sh	r0,r0[0x0]
80002b1a:	5b 6c       	cp.w	r12,-10

80002b1c <phy_tx>:
Calls:   
	xQueueSend -- freertos
Called By: xnl_tx -- xnl.c
*/
void phy_tx(phy_fragment_t * phy)
{	
80002b1c:	d4 01       	pushm	lr
80002b1e:	20 1d       	sub	sp,4
80002b20:	50 0c       	stdsp	sp[0x0],r12
	
	//phy_fragment_t * phy_ptr = malloc(sizeof(phy_fragment_t));
	//memcpy(phy_ptr, phy, sizeof(phy_fragment_t));
	//log("\n\r T_xcmp:%4x \n\r", phy->xnl_fragment.xnl_payload.xnl_content_data_msg.xcmp_opcode);
	//log("T_xnl-opcode:%4x", xnl->xnl_header.opcode);//log:R_xnl	
	if(XCMPXNL_DATA == (phy_ctrl & 0xF000))
80002b22:	98 88       	ld.uh	r8,r12[0x0]
80002b24:	e2 18 f0 00 	andl	r8,0xf000,COH
80002b28:	e0 48 40 00 	cp.w	r8,16384
80002b2c:	c0 d1       	brne	80002b46 <phy_tx+0x2a>
	{
		/*push the xnl packet to queue to send */
		if(NULL != phy_xnl_frame_tx)
80002b2e:	49 08       	lddpc	r8,80002b6c <phy_tx+0x50>
80002b30:	70 08       	ld.w	r8,r8[0x0]
80002b32:	58 08       	cp.w	r8,0
80002b34:	c1 a0       	breq	80002b68 <phy_tx+0x4c>
		{
			if( pdTRUE == xQueueSend(phy_xnl_frame_tx, &phy, 0))
80002b36:	48 e8       	lddpc	r8,80002b6c <phy_tx+0x50>
80002b38:	70 0c       	ld.w	r12,r8[0x0]
80002b3a:	30 09       	mov	r9,0
80002b3c:	12 9a       	mov	r10,r9
80002b3e:	1a 9b       	mov	r11,sp
80002b40:	f0 1f 00 0c 	mcall	80002b70 <phy_tx+0x54>
80002b44:	c1 28       	rjmp	80002b68 <phy_tx+0x4c>
		}
	}
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE		
	else if((SPEAKER_DATA == (phy_ctrl & 0xF000))
80002b46:	e0 48 10 00 	cp.w	r8,4096
80002b4a:	5f 0a       	sreq	r10
80002b4c:	e0 48 20 00 	cp.w	r8,8192
80002b50:	5f 09       	sreq	r9
80002b52:	f5 e9 10 09 	or	r9,r10,r9
80002b56:	c0 71       	brne	80002b64 <phy_tx+0x48>
80002b58:	e0 48 50 00 	cp.w	r8,20480
80002b5c:	c0 40       	breq	80002b64 <phy_tx+0x48>
80002b5e:	e0 48 60 00 	cp.w	r8,24576
80002b62:	c0 31       	brne	80002b68 <phy_tx+0x4c>
	    || (MIC_DATA  == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_RX == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_TX == (phy_ctrl & 0xF000))
	)
	{		
		if(NULL == phy_payload_frame_tx)
80002b64:	48 48       	lddpc	r8,80002b74 <phy_tx+0x58>
80002b66:	70 08       	ld.w	r8,r8[0x0]
	
	if(res != TRUE)
	{
		//vPortFree(phy_ptr);
	}
}
80002b68:	2f fd       	sub	sp,-4
80002b6a:	d8 02       	popm	pc
80002b6c:	00 00       	add	r0,r0
80002b6e:	0a d8       	st.w	--r5,r8
80002b70:	80 00       	ld.sh	r0,r0[0x0]
80002b72:	5b 6c       	cp.w	r12,-10
80002b74:	00 00       	add	r0,r0
80002b76:	0a b8       	st.h	r5++,r8

80002b78 <get_idle_store_isr>:
		return NULL;
	}
}

void * get_idle_store_isr(xQueueHandle store)
{
80002b78:	d4 01       	pushm	lr
80002b7a:	20 2d       	sub	sp,8
	void * ptr = NULL;
80002b7c:	30 08       	mov	r8,0
80002b7e:	50 18       	stdsp	sp[0x4],r8
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002b80:	50 08       	stdsp	sp[0x0],r8
	
	if(pdTRUE == xQueueReceiveFromISR(store, &ptr, &xHigherPriorityTaskWoken))
80002b82:	1a 9a       	mov	r10,sp
80002b84:	fa cb ff fc 	sub	r11,sp,-4
80002b88:	f0 1f 00 05 	mcall	80002b9c <get_idle_store_isr+0x24>
80002b8c:	58 1c       	cp.w	r12,1
80002b8e:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80002b92:	fb fc 00 01 	ld.weq	r12,sp[0x4]
	}
	else
	{
		return NULL;
	}
}
80002b96:	2f ed       	sub	sp,-8
80002b98:	d8 02       	popm	pc
80002b9a:	00 00       	add	r0,r0
80002b9c:	80 00       	ld.sh	r0,r0[0x0]
80002b9e:	58 70       	cp.w	r0,7

80002ba0 <phy_tx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_tx_func( void * ssc)
{
80002ba0:	eb cd 40 c0 	pushm	r6-r7,lr
80002ba4:	20 1d       	sub	sp,4
80002ba6:	18 97       	mov	r7,r12
    if(NULL != phy_xnl_frame_tx)
80002ba8:	fe f8 05 d8 	ld.w	r8,pc[1496]
80002bac:	70 08       	ld.w	r8,r8[0x0]
80002bae:	58 08       	cp.w	r8,0
80002bb0:	c7 40       	breq	80002c98 <phy_tx_func+0xf8>
    {
  	  	/*send ssc data in xnl frame*/
  	  	phy_xnl_tx(&(((ssc_fragment_t * )ssc)->xnl_channel));		
80002bb2:	18 96       	mov	r6,r12
Called By:phy_tx_func
*/
static void phy_xnl_tx(xnl_channel_t * xnl_tx_channel)
{
	/*variables are used to store the push result in interrupt*/
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002bb4:	30 08       	mov	r8,0
80002bb6:	50 08       	stdsp	sp[0x0],r8
	
	static S16 phy_tx_expexted_length = 0;
	static U8 phy_tx_index = 0;
	
	/*his is the code for handling any outgoing XNL Phy message*/
	switch(phy_tx_state)
80002bb8:	fe f8 05 cc 	ld.w	r8,pc[1484]
80002bbc:	70 08       	ld.w	r8,r8[0x0]
80002bbe:	58 18       	cp.w	r8,1
80002bc0:	c2 90       	breq	80002c12 <phy_tx_func+0x72>
80002bc2:	c0 43       	brcs	80002bca <phy_tx_func+0x2a>
80002bc4:	58 28       	cp.w	r8,2
80002bc6:	c6 91       	brne	80002c98 <phy_tx_func+0xf8>
80002bc8:	c6 18       	rjmp	80002c8a <phy_tx_func+0xea>
	{
		/*Waiting for the send xnl packet*/
		case WAITING_FOR_PHY_TX:			
			if( pdTRUE == xQueueReceiveFromISR(
80002bca:	fe f8 05 b6 	ld.w	r8,pc[1462]
80002bce:	70 0c       	ld.w	r12,r8[0x0]
80002bd0:	1a 9a       	mov	r10,sp
80002bd2:	fe fb 05 b6 	ld.w	r11,pc[1462]
80002bd6:	f0 1f 01 6e 	mcall	8000318c <phy_tx_func+0x5ec>
80002bda:	58 1c       	cp.w	r12,1
80002bdc:	c1 51       	brne	80002c06 <phy_tx_func+0x66>
				  phy_xnl_frame_tx
				, &phy_ptr
				, &xHigherPriorityTaskWoken 
			))
			{								
				phy_tx_expexted_length = 
80002bde:	fe f8 05 aa 	ld.w	r8,pc[1450]
80002be2:	70 08       	ld.w	r8,r8[0x0]
80002be4:	11 9a       	ld.ub	r10,r8[0x1]
80002be6:	fe f9 05 aa 	ld.w	r9,pc[1450]
80002bea:	b2 0a       	st.h	r9[0x0],r10
				*/
				xnl_tx_channel->dword = 
				                   phy_ptr->xnl_fragment.phy_header.phy_control;
				
				/*Transmit 0xABCD0000 | Type/Length.*/
				xnl_tx_channel->dword |= PHYHEADER32;
80002bec:	90 88       	ld.uh	r8,r8[0x0]
80002bee:	ea 18 ab cd 	orh	r8,0xabcd
80002bf2:	8f 18       	st.w	r7[0x4],r8
				
				phy_tx_index = 1;
80002bf4:	30 19       	mov	r9,1
80002bf6:	fe f8 05 9e 	ld.w	r8,pc[1438]
80002bfa:	b0 89       	st.b	r8[0x0],r9
				phy_tx_state = WRITE_NEXT_DWORD;	
80002bfc:	30 19       	mov	r9,1
80002bfe:	fe f8 05 86 	ld.w	r8,pc[1414]
80002c02:	91 09       	st.w	r8[0x0],r9
80002c04:	c4 a8       	rjmp	80002c98 <phy_tx_func+0xf8>
				/*The new transmission has started.*/
			}
			else
			{
				/*Nothing new to transmit, send an idle frame*/
				xnl_tx_channel->dword = XNL_IDLE;
80002c06:	e0 68 5a 5a 	mov	r8,23130
80002c0a:	ea 18 ab cd 	orh	r8,0xabcd
80002c0e:	8f 18       	st.w	r7[0x4],r8
80002c10:	c4 48       	rjmp	80002c98 <phy_tx_func+0xf8>
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80002c12:	fe f9 05 82 	ld.w	r9,pc[1410]
80002c16:	13 88       	ld.ub	r8,r9[0x0]
				xnl_tx_channel->dword = XNL_IDLE;
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
80002c18:	fe fa 05 70 	ld.w	r10,pc[1392]
80002c1c:	74 0a       	ld.w	r10,r10[0x0]
80002c1e:	f4 08 05 1a 	ld.uh	r10,r10[r8<<0x1]
80002c22:	b1 6a       	lsl	r10,0x10
80002c24:	99 1a       	st.w	r12[0x4],r10
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80002c26:	2f f8       	sub	r8,-1
80002c28:	5c 58       	castu.b	r8
80002c2a:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
80002c2c:	fe fa 05 64 	ld.w	r10,pc[1380]
80002c30:	94 09       	ld.sh	r9,r10[0x0]
80002c32:	20 29       	sub	r9,2
80002c34:	b4 09       	st.h	r10[0x0],r9
			
			/*have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80002c36:	30 0a       	mov	r10,0
80002c38:	f4 09 19 00 	cp.h	r9,r10
80002c3c:	e0 89 00 0b 	brgt	80002c52 <phy_tx_func+0xb2>
			{
				/*Must immediately send 0x00BA in Slot 4.*/
				xnl_tx_channel->dword |= PHYTERMRIGHT;
80002c40:	78 18       	ld.w	r8,r12[0x4]
80002c42:	e8 18 00 ba 	orl	r8,0xba
80002c46:	99 18       	st.w	r12[0x4],r8
				
				/*Go back to waiting.*/
				//vPortFree(phy_ptr);
				phy_tx_state = WAITING_FOR_PHY_TX;
80002c48:	30 09       	mov	r9,0
80002c4a:	fe f8 05 3a 	ld.w	r8,pc[1338]
80002c4e:	91 09       	st.w	r8[0x0],r9
80002c50:	c2 48       	rjmp	80002c98 <phy_tx_func+0xf8>
				break;
			}

			/*Have not broken. Transmit 2nd hWord.*/
			xnl_tx_channel->dword |=  phy_ptr->fragment_element[phy_tx_index++];
80002c52:	fe f9 05 36 	ld.w	r9,pc[1334]
80002c56:	72 09       	ld.w	r9,r9[0x0]
80002c58:	f2 08 05 19 	ld.uh	r9,r9[r8<<0x1]
80002c5c:	78 1a       	ld.w	r10,r12[0x4]
80002c5e:	f5 e9 10 09 	or	r9,r10,r9
80002c62:	99 19       	st.w	r12[0x4],r9
80002c64:	2f f8       	sub	r8,-1
80002c66:	fe f9 05 2e 	ld.w	r9,pc[1326]
80002c6a:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
80002c6c:	fe f9 05 24 	ld.w	r9,pc[1316]
80002c70:	92 08       	ld.sh	r8,r9[0x0]
80002c72:	20 28       	sub	r8,2
80002c74:	b2 08       	st.h	r9[0x0],r8
			
			/*Have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80002c76:	30 09       	mov	r9,0
80002c78:	f2 08 19 00 	cp.h	r8,r9
80002c7c:	e0 89 00 0e 	brgt	80002c98 <phy_tx_func+0xf8>
			{
				/*Must send 0x00BA0000 next interrupt in Slot 3&4*/
				phy_tx_state = SEND_TAILED;
80002c80:	30 29       	mov	r9,2
80002c82:	fe f8 05 02 	ld.w	r8,pc[1282]
80002c86:	91 09       	st.w	r8[0x0],r9
80002c88:	c0 88       	rjmp	80002c98 <phy_tx_func+0xf8>
			}
			break;

		case SEND_TAILED:
			/*send 0x00BA0000*/
			xnl_tx_channel->dword = PHYTERMLEFT;
80002c8a:	fc 18 00 ba 	movh	r8,0xba
80002c8e:	99 18       	st.w	r12[0x4],r8
			
			/*Go back to waiting.*/	
			//vPortFree(phy_ptr);		
			phy_tx_state = WAITING_FOR_PHY_TX;		
80002c90:	30 09       	mov	r9,0
80002c92:	fe f8 04 f2 	ld.w	r8,pc[1266]
80002c96:	91 09       	st.w	r8[0x0],r9
	
	//static U8 frame_5_end = 0;
	//static U16 pay[256];
	
	//Send-AMBE-data
	if ((AMBE_tx_flag == TRUE) || (AMBE_rx_flag == TRUE))
80002c98:	fe f8 05 00 	ld.w	r8,pc[1280]
80002c9c:	11 89       	ld.ub	r9,r8[0x0]
80002c9e:	30 18       	mov	r8,1
80002ca0:	f0 09 18 00 	cp.b	r9,r8
80002ca4:	c0 90       	breq	80002cb6 <phy_tx_func+0x116>
80002ca6:	fe f8 04 f6 	ld.w	r8,pc[1270]
80002caa:	11 89       	ld.ub	r9,r8[0x0]
80002cac:	30 18       	mov	r8,1
80002cae:	f0 09 18 00 	cp.b	r9,r8
80002cb2:	e0 81 00 ff 	brne	80002eb0 <phy_tx_func+0x310>
	{
		A_index = (A_index >=1456) ? 0 : A_index;
80002cb6:	fe f8 04 ea 	ld.w	r8,pc[1258]
80002cba:	70 08       	ld.w	r8,r8[0x0]
80002cbc:	e0 48 05 b0 	cp.w	r8,1456
80002cc0:	f9 b8 02 00 	movhs	r8,0
80002cc4:	fe f9 04 dc 	ld.w	r9,pc[1244]
80002cc8:	93 08       	st.w	r9[0x0],r8

	  //AMBE_flag
		switch(AMBEpayload_tx_state)
80002cca:	fe f9 04 da 	ld.w	r9,pc[1242]
80002cce:	72 09       	ld.w	r9,r9[0x0]
80002cd0:	58 29       	cp.w	r9,2
80002cd2:	e0 80 00 92 	breq	80002df6 <phy_tx_func+0x256>
80002cd6:	e0 8b 00 08 	brhi	80002ce6 <phy_tx_func+0x146>
80002cda:	58 09       	cp.w	r9,0
80002cdc:	c0 e0       	breq	80002cf8 <phy_tx_func+0x158>
80002cde:	58 19       	cp.w	r9,1
80002ce0:	e0 81 00 dc 	brne	80002e98 <phy_tx_func+0x2f8>
80002ce4:	c5 78       	rjmp	80002d92 <phy_tx_func+0x1f2>
80002ce6:	58 49       	cp.w	r9,4
80002ce8:	e0 80 00 b1 	breq	80002e4a <phy_tx_func+0x2aa>
80002cec:	e0 83 00 9c 	brlo	80002e24 <phy_tx_func+0x284>
80002cf0:	58 59       	cp.w	r9,5
80002cf2:	e0 81 00 d3 	brne	80002e98 <phy_tx_func+0x2f8>
80002cf6:	cc 48       	rjmp	80002e7e <phy_tx_func+0x2de>
		{
			case AMBE_IDLE:
		
				if ((m_RxBurstType == VOICE_WATING) || (m_RxBurstType == VOICETERMINATOR)  || (m_RxBurstType == VOICEHEADER))
80002cf8:	fe f8 04 b0 	ld.w	r8,pc[1200]
80002cfc:	70 08       	ld.w	r8,r8[0x0]
80002cfe:	58 08       	cp.w	r8,0
80002d00:	c0 b0       	breq	80002d16 <phy_tx_func+0x176>
80002d02:	fe f8 04 a6 	ld.w	r8,pc[1190]
80002d06:	70 08       	ld.w	r8,r8[0x0]
80002d08:	58 a8       	cp.w	r8,10
80002d0a:	c0 60       	breq	80002d16 <phy_tx_func+0x176>
80002d0c:	fe f8 04 9c 	ld.w	r8,pc[1180]
80002d10:	70 08       	ld.w	r8,r8[0x0]
80002d12:	58 18       	cp.w	r8,1
80002d14:	c0 a1       	brne	80002d28 <phy_tx_func+0x188>
				{
							
					payload_tx_channel->dword[0] = PAYLOADIDLE0;
80002d16:	e0 68 5a 5a 	mov	r8,23130
80002d1a:	ea 18 ab cd 	orh	r8,0xabcd
80002d1e:	8f 28       	st.w	r7[0x8],r8
					payload_tx_channel->dword[1] = PAYLOADIDLE1;
80002d20:	30 08       	mov	r8,0
80002d22:	8f 38       	st.w	r7[0xc],r8
80002d24:	e0 8f 02 2b 	bral	8000317a <phy_tx_func+0x5da>
			
				}
				else if((m_RxBurstType == UNSUREDATA))
80002d28:	fe f8 04 80 	ld.w	r8,pc[1152]
80002d2c:	70 08       	ld.w	r8,r8[0x0]
80002d2e:	58 38       	cp.w	r8,3
80002d30:	c0 91       	brne	80002d42 <phy_tx_func+0x1a2>
				{
					payload_tx_channel->dword[0] = AMBE_HT[0];
80002d32:	fe f8 04 7a 	ld.w	r8,pc[1146]
80002d36:	70 09       	ld.w	r9,r8[0x0]
80002d38:	8f 29       	st.w	r7[0x8],r9
					payload_tx_channel->dword[1] = AMBE_HT[1];
80002d3a:	70 18       	ld.w	r8,r8[0x4]
80002d3c:	8f 38       	st.w	r7[0xc],r8
80002d3e:	e0 8f 02 1e 	bral	8000317a <phy_tx_func+0x5da>
				else//
				{
					
					//Radio Internal Parameter + Vocoder Bits Stream Parameter + 1st 20ms AMBE bits of Voice Burst A 
					//assemble 3 items into 1 Command. Send it to Radio.
					if (m_RxBurstType == RADIOINTERNAL)//
80002d42:	fe f8 04 66 	ld.w	r8,pc[1126]
80002d46:	70 08       	ld.w	r8,r8[0x0]
80002d48:	58 28       	cp.w	r8,2
80002d4a:	c1 31       	brne	80002d70 <phy_tx_func+0x1d0>
					{
						//0xABCDCO14
						payload_tx_channel->dword[0] = DE_OB_PAYLOAD;//49bits
80002d4c:	e0 68 c0 14 	mov	r8,49172
80002d50:	ea 18 ab cd 	orh	r8,0xabcd
80002d54:	8f 28       	st.w	r7[0x8],r8
						//0x847F
						payload_tx_channel->word[2] = RIP_PAYLOAD;
80002d56:	fe 78 84 7f 	mov	r8,-31617
80002d5a:	ae 68       	st.h	r7[0xc],r8
						//0xxxxx
						payload_tx_channel->word[3] = Radio_Internal_Data[0];
80002d5c:	fe f8 04 54 	ld.w	r8,pc[1108]
80002d60:	90 08       	ld.sh	r8,r8[0x0]
80002d62:	ae 78       	st.h	r7[0xe],r8
						
						AMBEpayload_tx_state = AMBE_DE_FIRST;
80002d64:	30 39       	mov	r9,3
80002d66:	fe f8 04 3e 	ld.w	r8,pc[1086]
80002d6a:	91 09       	st.w	r8[0x0],r9
80002d6c:	e0 8f 02 07 	bral	8000317a <phy_tx_func+0x5da>
					
					else
					{
	
						//0xABCDCOOE
						payload_tx_channel->dword[0] = EN_OB_PAYLOAD;//49bits
80002d70:	e0 68 c0 0e 	mov	r8,49166
80002d74:	ea 18 ab cd 	orh	r8,0xabcd
80002d78:	8f 28       	st.w	r7[0x8],r8
						//0x8212
						payload_tx_channel->word[2] = VBSP_data[0];
80002d7a:	fe f8 04 3a 	ld.w	r8,pc[1082]
80002d7e:	90 09       	ld.sh	r9,r8[0x0]
80002d80:	ae 69       	st.h	r7[0xc],r9
						//0xF00x
						payload_tx_channel->word[3] = VBSP_data[1];
80002d82:	90 18       	ld.sh	r8,r8[0x2]
80002d84:	ae 78       	st.h	r7[0xe],r8
						
						AMBEpayload_tx_state = AMBE_EN_FIRST;
80002d86:	30 19       	mov	r9,1
80002d88:	fe f8 04 1c 	ld.w	r8,pc[1052]
80002d8c:	91 09       	st.w	r8[0x0],r9
80002d8e:	e0 8f 01 f6 	bral	8000317a <phy_tx_func+0x5da>
			
			case AMBE_EN_FIRST:
			
			
				//0x88F2
				payload_tx_channel->word[0] = ENCODER_PAYLOAD;//49bits
80002d92:	fe 78 88 f2 	mov	r8,-30478
80002d96:	ae 48       	st.h	r7[0x8],r8
				
				payload_tx_channel->word[1] = ((AMBE_AudioData[A_index]<<8) + AMBE_AudioData[A_index+1]) ;
80002d98:	fe f8 04 08 	ld.w	r8,pc[1032]
80002d9c:	70 0a       	ld.w	r10,r8[0x0]
80002d9e:	fe f9 04 1a 	ld.w	r9,pc[1050]
80002da2:	f2 0a 00 0b 	add	r11,r9,r10
80002da6:	17 9b       	ld.ub	r11,r11[0x1]
80002da8:	f2 0a 07 0a 	ld.ub	r10,r9[r10]
80002dac:	a9 6a       	lsl	r10,0x8
80002dae:	f6 0a 00 0a 	add	r10,r11,r10
80002db2:	ae 5a       	st.h	r7[0xa],r10
				A_index+=2;
80002db4:	70 0a       	ld.w	r10,r8[0x0]
80002db6:	2f ea       	sub	r10,-2
80002db8:	91 0a       	st.w	r8[0x0],r10
				
				payload_tx_channel->word[2] = ((AMBE_AudioData[A_index]<<8) + AMBE_AudioData[A_index+1]) ;
80002dba:	f2 0a 00 0b 	add	r11,r9,r10
80002dbe:	17 9b       	ld.ub	r11,r11[0x1]
80002dc0:	f2 0a 07 0a 	ld.ub	r10,r9[r10]
80002dc4:	a9 6a       	lsl	r10,0x8
80002dc6:	f6 0a 00 0a 	add	r10,r11,r10
80002dca:	ae 6a       	st.h	r7[0xc],r10
				A_index+=2;
80002dcc:	70 0a       	ld.w	r10,r8[0x0]
80002dce:	2f ea       	sub	r10,-2
80002dd0:	91 0a       	st.w	r8[0x0],r10
				
				payload_tx_channel->word[3] = ((AMBE_AudioData[A_index]<<8) + AMBE_AudioData[A_index+1]) ;
80002dd2:	f2 0a 00 0b 	add	r11,r9,r10
80002dd6:	17 9b       	ld.ub	r11,r11[0x1]
80002dd8:	f2 0a 07 09 	ld.ub	r9,r9[r10]
80002ddc:	a9 69       	lsl	r9,0x8
80002dde:	f6 09 00 09 	add	r9,r11,r9
80002de2:	ae 79       	st.h	r7[0xe],r9
				A_index+=2;
80002de4:	70 09       	ld.w	r9,r8[0x0]
80002de6:	2f e9       	sub	r9,-2
80002de8:	91 09       	st.w	r8[0x0],r9
				
				AMBEpayload_tx_state = AMBE_EN_LAST;
80002dea:	30 29       	mov	r9,2
80002dec:	fe f8 03 b8 	ld.w	r8,pc[952]
80002df0:	91 09       	st.w	r8[0x0],r9
80002df2:	e0 8f 01 c4 	bral	8000317a <phy_tx_func+0x5da>
						payload_tx_channel->word[0]	= ((Public_AMBEkey[3]) ^ (AMBEBurst_rawdata[3])) ;
					
					}
					
					***/
					payload_tx_channel->word[0] = ((AMBE_AudioData[A_index]<<8) + 0x00) ;//Pad_bits
80002df6:	fe f9 03 c2 	ld.w	r9,pc[962]
80002dfa:	f2 08 07 08 	ld.ub	r8,r9[r8]
80002dfe:	a9 68       	lsl	r8,0x8
80002e00:	ae 48       	st.h	r7[0x8],r8
					A_index+=1;
80002e02:	fe f8 03 9e 	ld.w	r8,pc[926]
80002e06:	70 09       	ld.w	r9,r8[0x0]
80002e08:	2f f9       	sub	r9,-1
80002e0a:	91 09       	st.w	r8[0x0],r9
					
					payload_tx_channel->word[1]	= 0x00BA ; 
80002e0c:	e0 68 00 ba 	mov	r8,186
80002e10:	ae 58       	st.h	r7[0xa],r8
					payload_tx_channel->word[2]	= 0x0000 ;
80002e12:	30 08       	mov	r8,0
80002e14:	ae 68       	st.h	r7[0xc],r8
					payload_tx_channel->word[3]	= 0x0000 ;
80002e16:	ae 78       	st.h	r7[0xe],r8
				
					AMBEpayload_tx_state = AMBE_IDLE;
80002e18:	30 09       	mov	r9,0
80002e1a:	fe f8 03 8a 	ld.w	r8,pc[906]
80002e1e:	91 09       	st.w	r8[0x0],r9
80002e20:	e0 8f 01 ad 	bral	8000317a <phy_tx_func+0x5da>
				break;
				
			case AMBE_DE_FIRST:
				
					//0xxxxx
					payload_tx_channel->word[0] = Radio_Internal_Data[1];
80002e24:	fe f8 03 8c 	ld.w	r8,pc[908]
80002e28:	90 18       	ld.sh	r8,r8[0x2]
80002e2a:	ae 48       	st.h	r7[0x8],r8
					//0x8212
					payload_tx_channel->word[1] = VBSP_data[0];
80002e2c:	fe f8 03 88 	ld.w	r8,pc[904]
80002e30:	90 09       	ld.sh	r9,r8[0x0]
80002e32:	ae 59       	st.h	r7[0xa],r9
					//0xF00x
					payload_tx_channel->word[2] = VBSP_data[1];
80002e34:	90 18       	ld.sh	r8,r8[0x2]
80002e36:	ae 68       	st.h	r7[0xc],r8
					//0x88F3
					payload_tx_channel->word[3] = DECODER_PAYLOAD;
80002e38:	fe 78 88 f3 	mov	r8,-30477
80002e3c:	ae 78       	st.h	r7[0xe],r8
		
					AMBEpayload_tx_state = AMBE_DE_SECOND;
80002e3e:	30 49       	mov	r9,4
80002e40:	fe f8 03 64 	ld.w	r8,pc[868]
80002e44:	91 09       	st.w	r8[0x0],r9
80002e46:	e0 8f 01 9a 	bral	8000317a <phy_tx_func+0x5da>
				}
		
		
		***/
			//......................
					AMBE_DecryptionKey[0] = AMBEBurst_rawdata[0];
80002e4a:	fe f8 03 72 	ld.w	r8,pc[882]
80002e4e:	90 0a       	ld.sh	r10,r8[0x0]
80002e50:	fe f9 03 70 	ld.w	r9,pc[880]
80002e54:	b2 0a       	st.h	r9[0x0],r10
					AMBE_DecryptionKey[1] = AMBEBurst_rawdata[1];
80002e56:	90 1a       	ld.sh	r10,r8[0x2]
80002e58:	b2 1a       	st.h	r9[0x2],r10
					AMBE_DecryptionKey[2] = AMBEBurst_rawdata[2];
80002e5a:	90 2a       	ld.sh	r10,r8[0x4]
80002e5c:	b2 2a       	st.h	r9[0x4],r10
					AMBE_DecryptionKey[3] = AMBEBurst_rawdata[3];
80002e5e:	90 3a       	ld.sh	r10,r8[0x6]
80002e60:	b2 3a       	st.h	r9[0x6],r10
					
					
					
					//0xxxxx
					payload_tx_channel->word[0] = AMBEBurst_rawdata[0];
80002e62:	90 09       	ld.sh	r9,r8[0x0]
80002e64:	ae 49       	st.h	r7[0x8],r9
					//0xxxxx
					payload_tx_channel->word[1] = AMBEBurst_rawdata[1];
80002e66:	90 19       	ld.sh	r9,r8[0x2]
80002e68:	ae 59       	st.h	r7[0xa],r9
					//0xxxxx
					payload_tx_channel->word[2] = AMBEBurst_rawdata[2];
80002e6a:	90 29       	ld.sh	r9,r8[0x4]
80002e6c:	ae 69       	st.h	r7[0xc],r9
					//0xxxxx
					payload_tx_channel->word[3] = AMBEBurst_rawdata[3];
80002e6e:	90 38       	ld.sh	r8,r8[0x6]
80002e70:	ae 78       	st.h	r7[0xe],r8
					
					AMBEpayload_tx_state = AMBE_DE_LAST;
80002e72:	30 59       	mov	r9,5
80002e74:	fe f8 03 30 	ld.w	r8,pc[816]
80002e78:	91 09       	st.w	r8[0x0],r9
80002e7a:	e0 8f 01 80 	bral	8000317a <phy_tx_func+0x5da>
				
				break;
				
			case AMBE_DE_LAST:
				
					payload_tx_channel->word[0]	= 0x00BA ;
80002e7e:	e0 68 00 ba 	mov	r8,186
80002e82:	ae 48       	st.h	r7[0x8],r8
					payload_tx_channel->word[1]	= 0x0000 ;
80002e84:	30 08       	mov	r8,0
80002e86:	ae 58       	st.h	r7[0xa],r8
					payload_tx_channel->word[2]	= 0x0000 ;
80002e88:	ae 68       	st.h	r7[0xc],r8
					payload_tx_channel->word[3]	= 0x0000 ;
80002e8a:	ae 78       	st.h	r7[0xe],r8
					
					AMBEpayload_tx_state = AMBE_IDLE;
80002e8c:	30 09       	mov	r9,0
80002e8e:	fe f8 03 16 	ld.w	r8,pc[790]
80002e92:	91 09       	st.w	r8[0x0],r9
80002e94:	e0 8f 01 73 	bral	8000317a <phy_tx_func+0x5da>
				
				
				
			default:
			
					payload_tx_channel->dword[0] = PAYLOADIDLE0;
80002e98:	e0 68 5a 5a 	mov	r8,23130
80002e9c:	ea 18 ab cd 	orh	r8,0xabcd
80002ea0:	8f 28       	st.w	r7[0x8],r8
					payload_tx_channel->dword[1] = PAYLOADIDLE1;
80002ea2:	30 08       	mov	r8,0
80002ea4:	8f 38       	st.w	r7[0xc],r8
					
					AMBEpayload_tx_state = AMBE_IDLE;
80002ea6:	fe f9 02 fe 	ld.w	r9,pc[766]
80002eaa:	93 08       	st.w	r9[0x0],r8
80002eac:	e0 8f 01 67 	bral	8000317a <phy_tx_func+0x5da>

#if 1
else//Send-PCM-data40bytes/2.5ms.
{
	
	index = (index >=30240) ? 0 : index;
80002eb0:	fe f8 03 14 	ld.w	r8,pc[788]
80002eb4:	70 08       	ld.w	r8,r8[0x0]
80002eb6:	e0 48 76 20 	cp.w	r8,30240
80002eba:	f9 b8 02 00 	movhs	r8,0
80002ebe:	fe f9 03 06 	ld.w	r9,pc[774]
80002ec2:	93 08       	st.w	r9[0x0],r8
	
	if(is_unmute == 1)counter++;
80002ec4:	fe f8 03 04 	ld.w	r8,pc[772]
80002ec8:	11 89       	ld.ub	r9,r8[0x0]
80002eca:	30 18       	mov	r8,1
80002ecc:	f0 09 18 00 	cp.b	r9,r8
80002ed0:	c0 61       	brne	80002edc <phy_tx_func+0x33c>
80002ed2:	fe f8 02 fa 	ld.w	r8,pc[762]
80002ed6:	70 09       	ld.w	r9,r8[0x0]
80002ed8:	2f f9       	sub	r9,-1
80002eda:	91 09       	st.w	r8[0x0],r9
	
	switch(payload_tx_state)
80002edc:	fe f8 02 f4 	ld.w	r8,pc[756]
80002ee0:	11 88       	ld.ub	r8,r8[0x0]
80002ee2:	30 19       	mov	r9,1
80002ee4:	f2 08 18 00 	cp.b	r8,r9
80002ee8:	c3 60       	breq	80002f54 <phy_tx_func+0x3b4>
80002eea:	c0 73       	brcs	80002ef8 <phy_tx_func+0x358>
80002eec:	30 29       	mov	r9,2
80002eee:	f2 08 18 00 	cp.b	r8,r9
80002ef2:	e0 81 01 41 	brne	80003174 <phy_tx_func+0x5d4>
80002ef6:	c7 f8       	rjmp	80002ff4 <phy_tx_func+0x454>
	{
		case 0:
		
			payload_tx_channel->dword[0] = PAYLOADIDLE0;
80002ef8:	e0 68 5a 5a 	mov	r8,23130
80002efc:	ea 18 ab cd 	orh	r8,0xabcd
80002f00:	8f 28       	st.w	r7[0x8],r8
			payload_tx_channel->dword[1] = PAYLOADIDLE1;
80002f02:	30 08       	mov	r8,0
80002f04:	8f 38       	st.w	r7[0xc],r8
		
			if(((counter % 20 )== 0) && (counter != 0) &&(is_unmute == 1))//20*125us = 2.5ms.
80002f06:	fe f8 02 c6 	ld.w	r8,pc[710]
80002f0a:	70 08       	ld.w	r8,r8[0x0]
80002f0c:	e0 6b cc cd 	mov	r11,52429
80002f10:	ea 1b cc cc 	orh	r11,0xcccc
80002f14:	f0 0b 06 4a 	mulu.d	r10,r8,r11
80002f18:	f6 09 16 04 	lsr	r9,r11,0x4
80002f1c:	f2 09 00 29 	add	r9,r9,r9<<0x2
80002f20:	f0 09 01 29 	sub	r9,r8,r9<<0x2
80002f24:	c1 21       	brne	80002f48 <phy_tx_func+0x3a8>
80002f26:	58 08       	cp.w	r8,0
80002f28:	c1 00       	breq	80002f48 <phy_tx_func+0x3a8>
80002f2a:	fe f8 02 9e 	ld.w	r8,pc[670]
80002f2e:	11 89       	ld.ub	r9,r8[0x0]
80002f30:	30 18       	mov	r8,1
80002f32:	f0 09 18 00 	cp.b	r9,r8
80002f36:	c0 91       	brne	80002f48 <phy_tx_func+0x3a8>
			{
				payload_tx_state = 1;
80002f38:	10 99       	mov	r9,r8
80002f3a:	fe f8 02 96 	ld.w	r8,pc[662]
80002f3e:	b0 89       	st.b	r8[0x0],r9
				//payload_tx_state = 0;
				frame_number = 0;
80002f40:	30 09       	mov	r9,0
80002f42:	fe f8 02 92 	ld.w	r8,pc[658]
80002f46:	b0 89       	st.b	r8[0x0],r9
	
			}
		
			send_num++;
80002f48:	fe f8 02 90 	ld.w	r8,pc[656]
80002f4c:	70 09       	ld.w	r9,r8[0x0]
80002f4e:	2f f9       	sub	r9,-1
80002f50:	91 09       	st.w	r8[0x0],r9
80002f52:	c1 49       	rjmp	8000317a <phy_tx_func+0x5da>
			break;
		
		case 1:
		
	
			payload_tx_channel->word[0] = 0xABCD; 
80002f54:	fe 78 ab cd 	mov	r8,-21555
80002f58:	ae 48       	st.h	r7[0x8],r8
		
			if(frame_number == 0)
80002f5a:	fe f8 02 7a 	ld.w	r8,pc[634]
80002f5e:	11 89       	ld.ub	r9,r8[0x0]
80002f60:	30 08       	mov	r8,0
80002f62:	f0 09 18 00 	cp.b	r9,r8
80002f66:	c1 b1       	brne	80002f9c <phy_tx_func+0x3fc>
			{
				if (Silent_flag == 1)
80002f68:	fe f8 02 74 	ld.w	r8,pc[628]
80002f6c:	11 89       	ld.ub	r9,r8[0x0]
80002f6e:	30 18       	mov	r8,1
80002f70:	f0 09 18 00 	cp.b	r9,r8
80002f74:	c0 91       	brne	80002f86 <phy_tx_func+0x3e6>
				{
					//44betes-4bytes= 40bytes
					expexted_length = 0x2C;//One Descriptor Indicator
80002f76:	32 c9       	mov	r9,44
80002f78:	fe f8 02 68 	ld.w	r8,pc[616]
80002f7c:	b0 09       	st.h	r8[0x0],r9
					payload_tx_channel->word[1] = 0x102C;//44betes-4bytes= 40bytes
80002f7e:	e0 68 10 2c 	mov	r8,4140
80002f82:	ae 58       	st.h	r7[0xa],r8
80002f84:	c0 88       	rjmp	80002f94 <phy_tx_func+0x3f4>
				}
				
				else
				{
					//first frame
					expexted_length = 0x2A;
80002f86:	32 a9       	mov	r9,42
80002f88:	fe f8 02 58 	ld.w	r8,pc[600]
80002f8c:	b0 09       	st.h	r8[0x0],r9
					payload_tx_channel->word[1] = 0x102A;//42-2= 40 bytes;	
80002f8e:	e0 68 10 2a 	mov	r8,4138
80002f92:	ae 58       	st.h	r7[0xa],r8
				}
				
					last_frame = TRUE;
80002f94:	30 19       	mov	r9,1
80002f96:	fe f8 02 4e 	ld.w	r8,pc[590]
80002f9a:	b0 89       	st.b	r8[0x0],r9
			//
			//
			//}
			//else//
			
			if (Silent_flag == 1)//
80002f9c:	fe f8 02 40 	ld.w	r8,pc[576]
80002fa0:	11 89       	ld.ub	r9,r8[0x0]
80002fa2:	30 18       	mov	r8,1
80002fa4:	f0 09 18 00 	cp.b	r9,r8
80002fa8:	c0 61       	brne	80002fb4 <phy_tx_func+0x414>
			{
			
				payload_tx_channel->word[2] = 0x0001;//Array Descriptor Length
80002faa:	30 18       	mov	r8,1
80002fac:	ae 68       	st.h	r7[0xc],r8
				payload_tx_channel->word[3] =  0x0004;//Silent Descriptor Indicator
80002fae:	30 48       	mov	r8,4
80002fb0:	ae 78       	st.h	r7[0xe],r8
80002fb2:	c1 48       	rjmp	80002fda <phy_tx_func+0x43a>

			}
			else
			{
			
				payload_tx_channel->word[2] = 0x0000;
80002fb4:	30 08       	mov	r8,0
80002fb6:	ae 68       	st.h	r7[0xc],r8
				payload_tx_channel->word[3] =  ((AudioData[index]<<8 )+ AudioData[index+1] );
80002fb8:	fe f8 02 0c 	ld.w	r8,pc[524]
80002fbc:	70 09       	ld.w	r9,r8[0x0]
80002fbe:	fe fa 02 2a 	ld.w	r10,pc[554]
80002fc2:	f4 09 00 0b 	add	r11,r10,r9
80002fc6:	17 9b       	ld.ub	r11,r11[0x1]
80002fc8:	f4 09 07 09 	ld.ub	r9,r10[r9]
80002fcc:	a9 69       	lsl	r9,0x8
80002fce:	f6 09 00 09 	add	r9,r11,r9
80002fd2:	ae 79       	st.h	r7[0xe],r9
				index+=2;
80002fd4:	70 09       	ld.w	r9,r8[0x0]
80002fd6:	2f e9       	sub	r9,-2
80002fd8:	91 09       	st.w	r8[0x0],r9
			
			}
		
			expexted_length -= 4;
80002fda:	fe f8 02 06 	ld.w	r8,pc[518]
80002fde:	90 09       	ld.sh	r9,r8[0x0]
80002fe0:	20 49       	sub	r9,4
80002fe2:	b0 09       	st.h	r8[0x0],r9
		
			//frame_number++;
			payload_tx_state = 2;
80002fe4:	30 29       	mov	r9,2
80002fe6:	4f b8       	lddpc	r8,800031d0 <phy_tx_func+0x630>
80002fe8:	b0 89       	st.b	r8[0x0],r9
		
			i = 0;
80002fea:	30 09       	mov	r9,0
80002fec:	fe f8 02 00 	ld.w	r8,pc[512]
80002ff0:	91 09       	st.w	r8[0x0],r9
80002ff2:	cc 48       	rjmp	8000317a <phy_tx_func+0x5da>
		
			break;
		
		case 2:
		
			if(expexted_length <= 0)
80002ff4:	4f b8       	lddpc	r8,800031e0 <phy_tx_func+0x640>
80002ff6:	90 09       	ld.sh	r9,r8[0x0]
80002ff8:	30 08       	mov	r8,0
80002ffa:	f0 09 19 00 	cp.h	r9,r8
80002ffe:	e0 89 00 12 	brgt	80003022 <phy_tx_func+0x482>
			{
				//last word 0x00BA
				payload_tx_state = last_frame ? 0 : 1;
80003002:	4f 98       	lddpc	r8,800031e4 <phy_tx_func+0x644>
80003004:	11 89       	ld.ub	r9,r8[0x0]
80003006:	30 08       	mov	r8,0
80003008:	f0 09 18 00 	cp.b	r9,r8
8000300c:	5f 09       	sreq	r9
8000300e:	4f 18       	lddpc	r8,800031d0 <phy_tx_func+0x630>
80003010:	b0 89       	st.b	r8[0x0],r9
				payload_tx_channel->word[0] = 0x00BA;
80003012:	e0 68 00 ba 	mov	r8,186
80003016:	ae 48       	st.h	r7[0x8],r8
				payload_tx_channel->word[1] = 0x0000;
80003018:	30 08       	mov	r8,0
8000301a:	ae 58       	st.h	r7[0xa],r8
				payload_tx_channel->word[2] = 0x0000;
8000301c:	ae 68       	st.h	r7[0xc],r8
				payload_tx_channel->word[3] = 0x0000;
8000301e:	ae 78       	st.h	r7[0xe],r8
80003020:	ca d8       	rjmp	8000317a <phy_tx_func+0x5da>
				break;
			}
		
			if(Silent_flag == 1)
80003022:	4e f8       	lddpc	r8,800031dc <phy_tx_func+0x63c>
80003024:	11 89       	ld.ub	r9,r8[0x0]
80003026:	30 18       	mov	r8,1
80003028:	f0 09 18 00 	cp.b	r9,r8
8000302c:	c0 41       	brne	80003034 <phy_tx_func+0x494>
			{
				payload_tx_channel->word[0] =  0x0000;
8000302e:	30 08       	mov	r8,0
80003030:	ae 48       	st.h	r7[0x8],r8
80003032:	c1 08       	rjmp	80003052 <phy_tx_func+0x4b2>
			}
			else
			{
				//payload_tx_channel->word[0] = AudioData[index++] + (AudioData[index++] << 8);
				payload_tx_channel->word[0] =  ((AudioData[index]<<8 )+ AudioData[index+1] );
80003034:	4e 48       	lddpc	r8,800031c4 <phy_tx_func+0x624>
80003036:	70 09       	ld.w	r9,r8[0x0]
80003038:	4e ca       	lddpc	r10,800031e8 <phy_tx_func+0x648>
8000303a:	f4 09 00 0b 	add	r11,r10,r9
8000303e:	17 9b       	ld.ub	r11,r11[0x1]
80003040:	f4 09 07 09 	ld.ub	r9,r10[r9]
80003044:	a9 69       	lsl	r9,0x8
80003046:	f6 09 00 09 	add	r9,r11,r9
8000304a:	ae 49       	st.h	r7[0x8],r9
				index+=2;
8000304c:	70 09       	ld.w	r9,r8[0x0]
8000304e:	2f e9       	sub	r9,-2
80003050:	91 09       	st.w	r8[0x0],r9
			
			}

			expexted_length -= 2;
80003052:	4e 49       	lddpc	r9,800031e0 <phy_tx_func+0x640>
80003054:	92 08       	ld.sh	r8,r9[0x0]
80003056:	20 28       	sub	r8,2
80003058:	b2 08       	st.h	r9[0x0],r8
			if(expexted_length <= 0)
8000305a:	30 09       	mov	r9,0
8000305c:	f2 08 19 00 	cp.h	r8,r9
80003060:	e0 89 00 11 	brgt	80003082 <phy_tx_func+0x4e2>
			{
				//last word 0x00BA
				payload_tx_state = last_frame ? 0 : 1;
80003064:	4e 08       	lddpc	r8,800031e4 <phy_tx_func+0x644>
80003066:	11 89       	ld.ub	r9,r8[0x0]
80003068:	30 08       	mov	r8,0
8000306a:	f0 09 18 00 	cp.b	r9,r8
8000306e:	5f 09       	sreq	r9
80003070:	4d 88       	lddpc	r8,800031d0 <phy_tx_func+0x630>
80003072:	b0 89       	st.b	r8[0x0],r9
				payload_tx_channel->word[1] = 0x00BA;
80003074:	e0 68 00 ba 	mov	r8,186
80003078:	ae 58       	st.h	r7[0xa],r8
				payload_tx_channel->word[2] = 0x0000;
8000307a:	30 08       	mov	r8,0
8000307c:	ae 68       	st.h	r7[0xc],r8
				payload_tx_channel->word[3] = 0x0000;
8000307e:	ae 78       	st.h	r7[0xe],r8
80003080:	c7 d8       	rjmp	8000317a <phy_tx_func+0x5da>
				break;
			}
		
			if(Silent_flag == 1)
80003082:	4d 78       	lddpc	r8,800031dc <phy_tx_func+0x63c>
80003084:	11 89       	ld.ub	r9,r8[0x0]
80003086:	30 18       	mov	r8,1
80003088:	f0 09 18 00 	cp.b	r9,r8
8000308c:	c0 41       	brne	80003094 <phy_tx_func+0x4f4>
			{
				payload_tx_channel->word[1] =  0x0000;
8000308e:	30 08       	mov	r8,0
80003090:	ae 58       	st.h	r7[0xa],r8
80003092:	c1 08       	rjmp	800030b2 <phy_tx_func+0x512>
			}
			else
			{
			
				payload_tx_channel->word[1] =  ((AudioData[index]<<8 )+ AudioData[index+1] );
80003094:	4c c8       	lddpc	r8,800031c4 <phy_tx_func+0x624>
80003096:	70 09       	ld.w	r9,r8[0x0]
80003098:	4d 4a       	lddpc	r10,800031e8 <phy_tx_func+0x648>
8000309a:	f4 09 00 0b 	add	r11,r10,r9
8000309e:	17 9b       	ld.ub	r11,r11[0x1]
800030a0:	f4 09 07 09 	ld.ub	r9,r10[r9]
800030a4:	a9 69       	lsl	r9,0x8
800030a6:	f6 09 00 09 	add	r9,r11,r9
800030aa:	ae 59       	st.h	r7[0xa],r9
				index+=2;
800030ac:	70 09       	ld.w	r9,r8[0x0]
800030ae:	2f e9       	sub	r9,-2
800030b0:	91 09       	st.w	r8[0x0],r9
			}
			//payload_tx_channel->word[1] =  ((AudioData[index]<<8 )+ AudioData[index+1] );
		
			expexted_length -= 2;
800030b2:	4c c9       	lddpc	r9,800031e0 <phy_tx_func+0x640>
800030b4:	92 08       	ld.sh	r8,r9[0x0]
800030b6:	20 28       	sub	r8,2
800030b8:	b2 08       	st.h	r9[0x0],r8
			if(expexted_length <= 0)
800030ba:	30 09       	mov	r9,0
800030bc:	f2 08 19 00 	cp.h	r8,r9
800030c0:	e0 89 00 10 	brgt	800030e0 <phy_tx_func+0x540>
			{
				//last word 0x00BA
				payload_tx_state = last_frame ? 0 : 1;
800030c4:	4c 88       	lddpc	r8,800031e4 <phy_tx_func+0x644>
800030c6:	11 89       	ld.ub	r9,r8[0x0]
800030c8:	30 08       	mov	r8,0
800030ca:	f0 09 18 00 	cp.b	r9,r8
800030ce:	5f 09       	sreq	r9
800030d0:	4c 08       	lddpc	r8,800031d0 <phy_tx_func+0x630>
800030d2:	b0 89       	st.b	r8[0x0],r9
				payload_tx_channel->word[2] = 0x00BA;
800030d4:	e0 68 00 ba 	mov	r8,186
800030d8:	ae 68       	st.h	r7[0xc],r8
				payload_tx_channel->word[3] = 0x0000;
800030da:	30 08       	mov	r8,0
800030dc:	ae 78       	st.h	r7[0xe],r8
800030de:	c4 e8       	rjmp	8000317a <phy_tx_func+0x5da>
				break;
			}
		
			if(Silent_flag == 1)
800030e0:	4b f8       	lddpc	r8,800031dc <phy_tx_func+0x63c>
800030e2:	11 89       	ld.ub	r9,r8[0x0]
800030e4:	30 18       	mov	r8,1
800030e6:	f0 09 18 00 	cp.b	r9,r8
800030ea:	c0 41       	brne	800030f2 <phy_tx_func+0x552>
			{
				payload_tx_channel->word[2] =  0x0000;
800030ec:	30 08       	mov	r8,0
800030ee:	ae 68       	st.h	r7[0xc],r8
800030f0:	c1 08       	rjmp	80003110 <phy_tx_func+0x570>
			}
			else
			{
			
				payload_tx_channel->word[2] =  ((AudioData[index]<<8 )+ AudioData[index+1] );
800030f2:	4b 58       	lddpc	r8,800031c4 <phy_tx_func+0x624>
800030f4:	70 09       	ld.w	r9,r8[0x0]
800030f6:	4b da       	lddpc	r10,800031e8 <phy_tx_func+0x648>
800030f8:	f4 09 00 0b 	add	r11,r10,r9
800030fc:	17 9b       	ld.ub	r11,r11[0x1]
800030fe:	f4 09 07 09 	ld.ub	r9,r10[r9]
80003102:	a9 69       	lsl	r9,0x8
80003104:	f6 09 00 09 	add	r9,r11,r9
80003108:	ae 69       	st.h	r7[0xc],r9
				index+=2;
8000310a:	70 09       	ld.w	r9,r8[0x0]
8000310c:	2f e9       	sub	r9,-2
8000310e:	91 09       	st.w	r8[0x0],r9
			}
			//payload_tx_channel->word[2] =  ((AudioData[index]<<8 )+ AudioData[index+1] );
		
			expexted_length -= 2;
80003110:	4b 49       	lddpc	r9,800031e0 <phy_tx_func+0x640>
80003112:	92 08       	ld.sh	r8,r9[0x0]
80003114:	20 28       	sub	r8,2
80003116:	b2 08       	st.h	r9[0x0],r8
			if(expexted_length <= 0)
80003118:	30 09       	mov	r9,0
8000311a:	f2 08 19 00 	cp.h	r8,r9
8000311e:	e0 89 00 0e 	brgt	8000313a <phy_tx_func+0x59a>
			{
				//last word 0x00BA
				payload_tx_state = last_frame ? 0 : 1;
80003122:	4b 18       	lddpc	r8,800031e4 <phy_tx_func+0x644>
80003124:	11 89       	ld.ub	r9,r8[0x0]
80003126:	30 08       	mov	r8,0
80003128:	f0 09 18 00 	cp.b	r9,r8
8000312c:	5f 09       	sreq	r9
8000312e:	4a 98       	lddpc	r8,800031d0 <phy_tx_func+0x630>
80003130:	b0 89       	st.b	r8[0x0],r9
				payload_tx_channel->word[3] = 0x00BA;
80003132:	e0 68 00 ba 	mov	r8,186
80003136:	ae 78       	st.h	r7[0xe],r8
80003138:	c2 18       	rjmp	8000317a <phy_tx_func+0x5da>
				break;
			}
		
			if(Silent_flag == 1)
8000313a:	4a 98       	lddpc	r8,800031dc <phy_tx_func+0x63c>
8000313c:	11 89       	ld.ub	r9,r8[0x0]
8000313e:	30 18       	mov	r8,1
80003140:	f0 09 18 00 	cp.b	r9,r8
80003144:	c0 41       	brne	8000314c <phy_tx_func+0x5ac>
			{
				payload_tx_channel->word[3] =  0x0000;
80003146:	30 08       	mov	r8,0
80003148:	ae 78       	st.h	r7[0xe],r8
8000314a:	c1 08       	rjmp	8000316a <phy_tx_func+0x5ca>
			}
			else
			{
			
				payload_tx_channel->word[3] =  ((AudioData[index]<<8 )+ AudioData[index+1] );
8000314c:	49 e8       	lddpc	r8,800031c4 <phy_tx_func+0x624>
8000314e:	70 09       	ld.w	r9,r8[0x0]
80003150:	4a 6a       	lddpc	r10,800031e8 <phy_tx_func+0x648>
80003152:	f4 09 00 0b 	add	r11,r10,r9
80003156:	17 9b       	ld.ub	r11,r11[0x1]
80003158:	f4 09 07 09 	ld.ub	r9,r10[r9]
8000315c:	a9 69       	lsl	r9,0x8
8000315e:	f6 09 00 09 	add	r9,r11,r9
80003162:	ae 79       	st.h	r7[0xe],r9
				index+=2;
80003164:	70 09       	ld.w	r9,r8[0x0]
80003166:	2f e9       	sub	r9,-2
80003168:	91 09       	st.w	r8[0x0],r9
			}
		
			//payload_tx_channel->word[3] =  ((AudioData[index]<<8 )+ AudioData[index+1] );
		
			expexted_length -= 2;
8000316a:	49 e8       	lddpc	r8,800031e0 <phy_tx_func+0x640>
8000316c:	90 09       	ld.sh	r9,r8[0x0]
8000316e:	20 29       	sub	r9,2
80003170:	b0 09       	st.h	r8[0x0],r9
80003172:	c0 48       	rjmp	8000317a <phy_tx_func+0x5da>
		
			break;
		
		default:
			payload_tx_state = 0;
80003174:	30 09       	mov	r9,0
80003176:	49 78       	lddpc	r8,800031d0 <phy_tx_func+0x630>
80003178:	b0 89       	st.b	r8[0x0],r9
	#else
	/*send idle frame*/	
	((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
	((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
	#endif /*end if*/
}
8000317a:	2f fd       	sub	sp,-4
8000317c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80003180:	00 00       	add	r0,r0
80003182:	0a d8       	st.w	--r5,r8
80003184:	00 00       	add	r0,r0
80003186:	0a a4       	st.w	r5++,r4
80003188:	00 00       	add	r0,r0
8000318a:	0a 7c       	tst	r12,r5
8000318c:	80 00       	ld.sh	r0,r0[0x0]
8000318e:	58 70       	cp.w	r0,7
80003190:	00 00       	add	r0,r0
80003192:	0a e4       	st.h	--r5,r4
80003194:	00 00       	add	r0,r0
80003196:	0a 81       	andn	r1,r5
80003198:	00 00       	add	r0,r0
8000319a:	0a 40       	or	r0,r5
8000319c:	00 00       	add	r0,r0
8000319e:	0a 38       	cp.w	r8,r5
800031a0:	00 00       	add	r0,r0
800031a2:	0a 70       	tst	r0,r5
800031a4:	00 00       	add	r0,r0
800031a6:	0a a8       	st.w	r5++,r8
800031a8:	00 00       	add	r0,r0
800031aa:	0a 6c       	and	r12,r5
800031ac:	00 00       	add	r0,r0
800031ae:	0a 8c       	andn	r12,r5
800031b0:	00 00       	add	r0,r0
800031b2:	0d c8       	ld.ub	r8,r6[0x4]
800031b4:	00 00       	add	r0,r0
800031b6:	0e c4       	st.b	r7++,r4
800031b8:	80 00       	ld.sh	r0,r0[0x0]
800031ba:	d0 3c       	*unknown*
800031bc:	00 00       	add	r0,r0
800031be:	0d c0       	ld.ub	r0,r6[0x4]
800031c0:	00 00       	add	r0,r0
800031c2:	0d cc       	ld.ub	r12,r6[0x4]
800031c4:	00 00       	add	r0,r0
800031c6:	0a 9c       	mov	r12,r5
800031c8:	00 00       	add	r0,r0
800031ca:	0a 42       	or	r2,r5
800031cc:	00 00       	add	r0,r0
800031ce:	0a 68       	and	r8,r5
800031d0:	00 00       	add	r0,r0
800031d2:	0a cd       	st.b	r5++,sp
800031d4:	00 00       	add	r0,r0
800031d6:	0a b0       	st.h	r5++,r0
800031d8:	00 00       	add	r0,r0
800031da:	0a a0       	st.w	r5++,r0
800031dc:	00 00       	add	r0,r0
800031de:	0a 4c       	or	r12,r5
800031e0:	00 00       	add	r0,r0
800031e2:	0a ce       	st.b	r5++,lr
800031e4:	00 00       	add	r0,r0
800031e6:	0a 80       	andn	r0,r5
800031e8:	80 00       	ld.sh	r0,r0[0x0]
800031ea:	d6 04       	*unknown*
800031ec:	00 00       	add	r0,r0
800031ee:	0a 78       	tst	r8,r5

800031f0 <get_idle_store>:
	}//End of RxMedia Phy Handler.
}
#endif /*end if*/

void * get_idle_store(xQueueHandle store)
{
800031f0:	d4 01       	pushm	lr
800031f2:	20 1d       	sub	sp,4
	void * ptr = NULL;
800031f4:	30 0a       	mov	r10,0
800031f6:	fa cb ff fc 	sub	r11,sp,-4
800031fa:	16 da       	st.w	--r11,r10

	if(pdTRUE == xQueueReceive(store, &ptr, 0))
800031fc:	14 99       	mov	r9,r10
800031fe:	1a 9b       	mov	r11,sp
80003200:	f0 1f 00 05 	mcall	80003214 <get_idle_store+0x24>
80003204:	58 1c       	cp.w	r12,1
80003206:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
8000320a:	fb fc 00 00 	ld.weq	r12,sp[0x0]
	}
	else
	{
		return NULL;
	}
}
8000320e:	2f fd       	sub	sp,-4
80003210:	d8 02       	popm	pc
80003212:	00 00       	add	r0,r0
80003214:	80 00       	ld.sh	r0,r0[0x0]
80003216:	59 60       	cp.w	r0,22

80003218 <phy_init>:
    register_rx_tx_func -- ssc.c
	xQueueCreate -- freertos
Called By: xnl_init -- xnl.c
*/
void phy_init( void )
{
80003218:	eb cd 40 e0 	pushm	r5-r7,lr
    /*initialize the SSC*/
    ssc_init();
8000321c:	f0 1f 00 21 	mcall	800032a0 <phy_init+0x88>

    /*register the func to send/receive ssc packet*/
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
80003220:	4a 1b       	lddpc	r11,800032a4 <phy_init+0x8c>
80003222:	4a 2c       	lddpc	r12,800032a8 <phy_init+0x90>
80003224:	f0 1f 00 22 	mcall	800032ac <phy_init+0x94>
	
	/*if enable send/receive payload(media), defined in physical.h*/	
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
80003228:	30 4b       	mov	r11,4
8000322a:	31 ec       	mov	r12,30
8000322c:	f0 1f 00 21 	mcall	800032b0 <phy_init+0x98>
80003230:	4a 18       	lddpc	r8,800032b4 <phy_init+0x9c>
80003232:	91 0c       	st.w	r8[0x0],r12
80003234:	30 07       	mov	r7,0
	phy_fragment_t * xnl_ptr = NULL;
	for(int i= 0; i < MAX_XNL_STORE; i++ )
	{
		set_xnl_idle(&xnl_store[i]);
80003236:	10 96       	mov	r6,r8
80003238:	4a 05       	lddpc	r5,800032b8 <phy_init+0xa0>
8000323a:	6c 0c       	ld.w	r12,r6[0x0]
8000323c:	ea 07 00 0b 	add	r11,r5,r7
80003240:	f0 1f 00 1f 	mcall	800032bc <phy_init+0xa4>
80003244:	ee c7 ff 00 	sub	r7,r7,-256
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
	
	/*if enable send/receive payload(media), defined in physical.h*/	
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
	phy_fragment_t * xnl_ptr = NULL;
	for(int i= 0; i < MAX_XNL_STORE; i++ )
80003248:	e0 47 1e 00 	cp.w	r7,7680
8000324c:	cf 71       	brne	8000323a <phy_init+0x22>
	{
		set_xnl_idle(&xnl_store[i]);
	}
		
    /*initialize the queue to send/receive xnl packet */	
    phy_xnl_frame_tx = xQueueCreate(TX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
8000324e:	30 4b       	mov	r11,4
80003250:	31 4c       	mov	r12,20
80003252:	f0 1f 00 18 	mcall	800032b0 <phy_init+0x98>
80003256:	49 b8       	lddpc	r8,800032c0 <phy_init+0xa8>
80003258:	91 0c       	st.w	r8[0x0],r12
    phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
8000325a:	30 4b       	mov	r11,4
8000325c:	30 ac       	mov	r12,10
8000325e:	f0 1f 00 15 	mcall	800032b0 <phy_init+0x98>
80003262:	49 98       	lddpc	r8,800032c4 <phy_init+0xac>
80003264:	91 0c       	st.w	r8[0x0],r12
	
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
80003266:	30 4b       	mov	r11,4
80003268:	30 ac       	mov	r12,10
8000326a:	f0 1f 00 12 	mcall	800032b0 <phy_init+0x98>
8000326e:	49 78       	lddpc	r8,800032c8 <phy_init+0xb0>
80003270:	91 0c       	st.w	r8[0x0],r12
80003272:	30 07       	mov	r7,0
	U8 * payload_ptr = NULL;
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
	{
		set_payload_idle(payload_store[i]);
80003274:	10 96       	mov	r6,r8
80003276:	49 65       	lddpc	r5,800032cc <phy_init+0xb4>
80003278:	6c 0c       	ld.w	r12,r6[0x0]
8000327a:	ea 07 00 0b 	add	r11,r5,r7
8000327e:	f0 1f 00 10 	mcall	800032bc <phy_init+0xa4>
80003282:	ee c7 fe 00 	sub	r7,r7,-512
    phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
	
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
	U8 * payload_ptr = NULL;
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
80003286:	e0 47 14 00 	cp.w	r7,5120
8000328a:	cf 71       	brne	80003278 <phy_init+0x60>
		set_payload_idle(payload_store[i]);
	}
		
	/*initialize the queue to send/receive xnl packet */
	phy_payload_frame_tx =
	xQueueCreate(TX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t));
8000328c:	e0 6b 01 00 	mov	r11,256
80003290:	30 5c       	mov	r12,5
80003292:	f0 1f 00 08 	mcall	800032b0 <phy_init+0x98>
	{
		set_payload_idle(payload_store[i]);
	}
		
	/*initialize the queue to send/receive xnl packet */
	phy_payload_frame_tx =
80003296:	48 f8       	lddpc	r8,800032d0 <phy_init+0xb8>
80003298:	91 0c       	st.w	r8[0x0],r12
		
	//phy_payload_frame_rx =
	//xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
	#endif /*end if*/
	
}
8000329a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000329e:	00 00       	add	r0,r0
800032a0:	80 00       	ld.sh	r0,r0[0x0]
800032a2:	42 fc       	lddsp	r12,sp[0xbc]
800032a4:	80 00       	ld.sh	r0,r0[0x0]
800032a6:	2b a0       	sub	r0,-70
800032a8:	80 00       	ld.sh	r0,r0[0x0]
800032aa:	33 34       	mov	r4,51
800032ac:	80 00       	ld.sh	r0,r0[0x0]
800032ae:	42 e8       	lddsp	r8,sp[0xb8]
800032b0:	80 00       	ld.sh	r0,r0[0x0]
800032b2:	5c c4       	swap.bh	r4
800032b4:	00 00       	add	r0,r0
800032b6:	0a 98       	mov	r8,r5
800032b8:	00 00       	add	r0,r0
800032ba:	22 c8       	sub	r8,44
800032bc:	80 00       	ld.sh	r0,r0[0x0]
800032be:	2a fc       	sub	r12,-81
800032c0:	00 00       	add	r0,r0
800032c2:	0a d8       	st.w	--r5,r8
800032c4:	00 00       	add	r0,r0
800032c6:	0a c0       	st.b	r5++,r0
800032c8:	00 00       	add	r0,r0
800032ca:	0a 74       	tst	r4,r5
800032cc:	00 00       	add	r0,r0
800032ce:	0e c8       	st.b	r7++,r8
800032d0:	00 00       	add	r0,r0
800032d2:	0a b8       	st.h	r5++,r8

800032d4 <payload_rx>:




static void payload_rx(void * payload)
{
800032d4:	d4 01       	pushm	lr
800032d6:	20 2d       	sub	sp,8
800032d8:	50 0c       	stdsp	sp[0x0],r12
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
800032da:	30 08       	mov	r8,0
800032dc:	50 18       	stdsp	sp[0x4],r8
	
	//set_payload_idle(payload);
	if(NULL == phy_payload_frame_rx)
800032de:	48 f8       	lddpc	r8,80003318 <payload_rx+0x44>
800032e0:	70 08       	ld.w	r8,r8[0x0]
800032e2:	58 08       	cp.w	r8,0
800032e4:	c0 71       	brne	800032f2 <payload_rx+0x1e>
	{
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));		
800032e6:	30 4b       	mov	r11,4
800032e8:	30 5c       	mov	r12,5
800032ea:	f0 1f 00 0d 	mcall	8000331c <payload_rx+0x48>
800032ee:	48 b8       	lddpc	r8,80003318 <payload_rx+0x44>
800032f0:	91 0c       	st.w	r8[0x0],r12
	}

	if(errQUEUE_FULL == xQueueSendFromISR(phy_payload_frame_rx, &payload, &xHigherPriorityTaskWoken))
800032f2:	48 a8       	lddpc	r8,80003318 <payload_rx+0x44>
800032f4:	70 0c       	ld.w	r12,r8[0x0]
800032f6:	30 09       	mov	r9,0
800032f8:	fa ca ff fc 	sub	r10,sp,-4
800032fc:	1a 9b       	mov	r11,sp
800032fe:	f0 1f 00 09 	mcall	80003320 <payload_rx+0x4c>
80003302:	c0 91       	brne	80003314 <payload_rx+0x40>
	//if(errQUEUE_FULL == xQueueSend(phy_payload_frame_rx, &payload, 0))
	{	//To payload_rx_process();	
		
		set_payload_idle_isr(payload);
80003304:	48 88       	lddpc	r8,80003324 <payload_rx+0x50>
80003306:	70 0c       	ld.w	r12,r8[0x0]
80003308:	40 0b       	lddsp	r11,sp[0x0]
8000330a:	f0 1f 00 08 	mcall	80003328 <payload_rx+0x54>
		logFromISR("mm");
8000330e:	48 8c       	lddpc	r12,8000332c <payload_rx+0x58>
80003310:	f0 1f 00 08 	mcall	80003330 <payload_rx+0x5c>
			
		}
		//set_payload_idle_isr(payload);
		//logFromISR("ss");
	}
}
80003314:	2f ed       	sub	sp,-8
80003316:	d8 02       	popm	pc
80003318:	00 00       	add	r0,r0
8000331a:	0a e0       	st.h	--r5,r0
8000331c:	80 00       	ld.sh	r0,r0[0x0]
8000331e:	5c c4       	swap.bh	r4
80003320:	80 00       	ld.sh	r0,r0[0x0]
80003322:	5b 1c       	cp.w	r12,-15
80003324:	00 00       	add	r0,r0
80003326:	0a 74       	tst	r4,r5
80003328:	80 00       	ld.sh	r0,r0[0x0]
8000332a:	2a a8       	sub	r8,-86
8000332c:	80 01       	ld.sh	r1,r0[0x0]
8000332e:	59 b4       	cp.w	r4,27
80003330:	80 00       	ld.sh	r0,r0[0x0]
80003332:	68 e8       	ld.w	r8,r4[0x38]

80003334 <phy_rx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_rx_func( void * ssc)
{    
80003334:	eb cd 40 e0 	pushm	r5-r7,lr
80003338:	18 97       	mov	r7,r12
		
	if(NULL != phy_xnl_frame_rx)
8000333a:	fe f8 0d ee 	ld.w	r8,pc[3566]
8000333e:	70 08       	ld.w	r8,r8[0x0]
80003340:	58 08       	cp.w	r8,0
80003342:	e0 80 01 05 	breq	8000354c <phy_rx_func+0x218>
	static U16 phy_check_sum = 0;

	static phy_rx_state_t  phy_rx_state = WAITING_FOR_HEADER;
	static U32 phy_rx_count = 0;

	U32 phy_dword = xnl_rx_channel->dword;	
80003346:	78 16       	ld.w	r6,r12[0x4]

	phy_rx_count++;
80003348:	fe f8 0d e4 	ld.w	r8,pc[3556]
8000334c:	70 09       	ld.w	r9,r8[0x0]
8000334e:	2f f9       	sub	r9,-1
80003350:	91 09       	st.w	r8[0x0],r9
	
	/*This is the code for parsing the incoming physical message.*/
	switch (phy_rx_state)
80003352:	fe f8 0d de 	ld.w	r8,pc[3550]
80003356:	70 08       	ld.w	r8,r8[0x0]
80003358:	58 18       	cp.w	r8,1
8000335a:	e0 80 00 84 	breq	80003462 <phy_rx_func+0x12e>
8000335e:	c0 73       	brcs	8000336c <phy_rx_func+0x38>
80003360:	58 28       	cp.w	r8,2
80003362:	c5 b0       	breq	80003418 <phy_rx_func+0xe4>
80003364:	58 38       	cp.w	r8,3
80003366:	e0 81 00 f3 	brne	8000354c <phy_rx_func+0x218>
8000336a:	cd 38       	rjmp	80003510 <phy_rx_func+0x1dc>

        /*Waiting for something. Most frequent visit.*/		
		case WAITING_FOR_HEADER:
		
			/*Ignore Idles.*/
			if (0xABCD5A5A == phy_dword)
8000336c:	e0 6a 5a 5a 	mov	r10,23130
80003370:	ea 1a ab cd 	orh	r10,0xabcd
80003374:	14 36       	cp.w	r6,r10
80003376:	e0 80 00 eb 	breq	8000354c <phy_rx_func+0x218>
			{
				break;
			}	

			/*Skip until Header.*/		
			if (0xABCD != (phy_dword >> 16))
8000337a:	ec 08 16 10 	lsr	r8,r6,0x10
8000337e:	e0 48 ab cd 	cp.w	r8,43981
80003382:	e0 81 00 e5 	brne	8000354c <phy_rx_func+0x218>
			{			
				break;
			}
		
			/*Length excluding CSUM.*/
			phy_rx_expexted_length = (phy_dword & 0x000000FF) - 2;
80003386:	eb d6 b0 10 	bfexts	r5,r6,0x0,0x10
8000338a:	f1 d5 c0 08 	bfextu	r8,r5,0x0,0x8
8000338e:	20 28       	sub	r8,2
80003390:	fe f9 0d a4 	ld.w	r9,pc[3492]
80003394:	b2 08       	st.h	r9[0x0],r8
			
			/*Discard degenerate message.*/
			if (phy_rx_expexted_length <= 0)
80003396:	30 09       	mov	r9,0
80003398:	f2 08 19 00 	cp.h	r8,r9
8000339c:	e0 8a 00 d8 	brle	8000354c <phy_rx_func+0x218>
			{
				break;
			}
		
			phy_rx_length = 0;
800033a0:	fe f8 0d 98 	ld.w	r8,pc[3480]
800033a4:	b0 09       	st.h	r8[0x0],r9
			
			//get_xnl_idle_isr(&phy_frame_ptr, &xHigherPriorityTaskWoken);
			phy_frame_ptr = get_xnl_idle_isr();
800033a6:	fe f8 0d 96 	ld.w	r8,pc[3478]
800033aa:	70 0c       	ld.w	r12,r8[0x0]
800033ac:	f0 1f 03 65 	mcall	80004140 <phy_rx_func+0xe0c>
800033b0:	fe f8 0d 94 	ld.w	r8,pc[3476]
800033b4:	91 0c       	st.w	r8[0x0],r12
			if(NULL == phy_frame_ptr)
800033b6:	58 0c       	cp.w	r12,0
800033b8:	e0 80 00 ca 	breq	8000354c <phy_rx_func+0x218>
			//
			//xQueueReceiveFromISR(phy_store_idle, &phy_frame_ptr, &xHigherPriorityTaskWoken);
			
			//phy_frame_ptr = pvPortMalloc(sizeof(phy_fragment_t));
					
			phy_frame_ptr->fragment_element[phy_rx_length++] = phy_dword;
800033bc:	fe f8 0d 7c 	ld.w	r8,pc[3452]
800033c0:	90 09       	ld.sh	r9,r8[0x0]
800033c2:	f8 09 0a 15 	st.h	r12[r9<<0x1],r5
800033c6:	2f f9       	sub	r9,-1
800033c8:	5c 89       	casts.h	r9
			
			/*time stamp*/
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
800033ca:	fe fa 0d 7a 	ld.w	r10,pc[3450]
800033ce:	74 0a       	ld.w	r10,r10[0x0]
800033d0:	fe fb 0d 5c 	ld.w	r11,pc[3420]
800033d4:	76 0b       	ld.w	r11,r11[0x0]
800033d6:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
800033da:	2f f9       	sub	r9,-1
800033dc:	b0 09       	st.h	r8[0x0],r9
													(phy_rx_count) & 0x0000FFFF;
			
			/*This switch tests the fragment type, and adjusts receiver state
			accordingly.*/
			/*Check frag type*/
			switch (phy_dword & 0x00000F00)
800033de:	e2 16 0f 00 	andl	r6,0xf00,COH
800033e2:	e0 46 01 00 	cp.w	r6,256
800033e6:	c0 c0       	breq	800033fe <phy_rx_func+0xca>
800033e8:	e0 8b 00 05 	brhi	800033f2 <phy_rx_func+0xbe>
800033ec:	58 06       	cp.w	r6,0
800033ee:	c0 80       	breq	800033fe <phy_rx_func+0xca>
800033f0:	c0 c8       	rjmp	80003408 <phy_rx_func+0xd4>
800033f2:	e0 46 02 00 	cp.w	r6,512
800033f6:	c0 40       	breq	800033fe <phy_rx_func+0xca>
800033f8:	e0 46 03 00 	cp.w	r6,768
800033fc:	c0 61       	brne	80003408 <phy_rx_func+0xd4>
			{
				case SINGLE_FRAGMENT:  //Only Fragment.
				case FIRST_FRAGMENT:   //First of Multi-fragment.
				case MIDDLE_FRAGMENT:  //Continuing Multi-fragment.
				case LAST_FRAGMENT:    //Last Multi-fragment.
					phy_rx_state = WAITING_CHECK_SUM;
800033fe:	30 29       	mov	r9,2
80003400:	fe f8 0d 30 	ld.w	r8,pc[3376]
80003404:	91 09       	st.w	r8[0x0],r9
80003406:	ca 38       	rjmp	8000354c <phy_rx_func+0x218>
				break;
				default:
					vPortFree(phy_frame_ptr);
80003408:	fe f6 0d 3c 	ld.w	r6,pc[3388]
8000340c:	6c 0c       	ld.w	r12,r6[0x0]
8000340e:	f0 1f 03 4f 	mcall	80004148 <phy_rx_func+0xe14>
					phy_frame_ptr = NULL;					
80003412:	30 08       	mov	r8,0
80003414:	8d 08       	st.w	r6[0x0],r8
80003416:	c9 b8       	rjmp	8000354c <phy_rx_func+0x218>
		
			/*Stores CSUM*/
			phy_check_sum  = (phy_dword & 0xFFFF0000) >> 16;
			
			/*sums in first hWord*/
			phy_check_sum += (phy_dword & 0x0000FFFF);		
80003418:	f5 d6 b0 10 	bfexts	r10,r6,0x0,0x10
8000341c:	b1 86       	lsr	r6,0x10
8000341e:	14 06       	add	r6,r10
80003420:	fe f8 0d 2c 	ld.w	r8,pc[3372]
80003424:	b0 06       	st.h	r8[0x0],r6
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
80003426:	fe f8 0d 12 	ld.w	r8,pc[3346]
8000342a:	90 09       	ld.sh	r9,r8[0x0]
8000342c:	fe fb 0d 18 	ld.w	r11,pc[3352]
80003430:	76 0b       	ld.w	r11,r11[0x0]
80003432:	f6 09 0a 1a 	st.h	r11[r9<<0x1],r10
80003436:	2f f9       	sub	r9,-1
80003438:	b0 09       	st.h	r8[0x0],r9
														 phy_dword & 0x0000FFFF;
					
			phy_rx_expexted_length -= 2;
8000343a:	fe f9 0c fa 	ld.w	r9,pc[3322]
8000343e:	92 08       	ld.sh	r8,r9[0x0]
80003440:	20 28       	sub	r8,2
80003442:	b2 08       	st.h	r9[0x0],r8
			
			/*Normal case for greater than one byte payloads.*/
			if (phy_rx_expexted_length > 0)
80003444:	30 09       	mov	r9,0
80003446:	f2 08 19 00 	cp.h	r8,r9
8000344a:	e0 8a 00 07 	brle	80003458 <phy_rx_func+0x124>
			{					  
				phy_rx_state = READING_FRAGMENT;
8000344e:	30 19       	mov	r9,1
80003450:	fe f8 0c e0 	ld.w	r8,pc[3296]
80003454:	91 09       	st.w	r8[0x0],r9
80003456:	c7 b8       	rjmp	8000354c <phy_rx_func+0x218>
	    		Note that all segments must align with a 32-bit boundary and
				beginning of each XCMP/XNL payload frame must start on slot 3
				Thus, segments of odd length must append a 0x0000 at the end
				(slot 4) to ensure alignment. [9.1.3]
				*/
				phy_rx_state = WAITING_LAST_TERM;
80003458:	30 39       	mov	r9,3
8000345a:	fe f8 0c d6 	ld.w	r8,pc[3286]
8000345e:	91 09       	st.w	r8[0x0],r9
80003460:	c7 68       	rjmp	8000354c <phy_rx_func+0x218>
			}			
		
			break;

		case READING_FRAGMENT:
			phy_check_sum += (phy_dword & 0xFFFF0000) >> 16;
80003462:	ec 0a 14 10 	asr	r10,r6,0x10
80003466:	fe f8 0c e6 	ld.w	r8,pc[3302]
8000346a:	90 09       	ld.sh	r9,r8[0x0]
8000346c:	14 09       	add	r9,r10
8000346e:	b0 09       	st.h	r8[0x0],r9
	
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
80003470:	fe f9 0c c8 	ld.w	r9,pc[3272]
80003474:	92 08       	ld.sh	r8,r9[0x0]
80003476:	fe fb 0c ce 	ld.w	r11,pc[3278]
8000347a:	76 0b       	ld.w	r11,r11[0x0]
8000347c:	f6 08 0a 1a 	st.h	r11[r8<<0x1],r10
80003480:	2f f8       	sub	r8,-1
80003482:	5c 88       	casts.h	r8
80003484:	b2 08       	st.h	r9[0x0],r8
												 (phy_dword & 0xFFFF0000) >> 16;
	
			phy_rx_expexted_length -= 2;
80003486:	fe fa 0c ae 	ld.w	r10,pc[3246]
8000348a:	94 09       	ld.sh	r9,r10[0x0]
8000348c:	20 29       	sub	r9,2
8000348e:	b4 09       	st.h	r10[0x0],r9
			if (phy_rx_expexted_length <= 0)
80003490:	30 0a       	mov	r10,0
80003492:	f4 09 19 00 	cp.h	r9,r10
80003496:	e0 89 00 1f 	brgt	800034d4 <phy_rx_func+0x1a0>
				Terminator should be in 2nd hWord.
				Shaoqun says useful bits not used. The packet will always end
				with $00BA. [9.1.2.8]	
				*/
				
				if ((0x000000BA == (phy_dword  & 0x0000FFFF)) 
8000349a:	ed d6 c0 10 	bfextu	r6,r6,0x0,0x10
8000349e:	e0 46 00 ba 	cp.w	r6,186
800034a2:	c0 d1       	brne	800034bc <phy_rx_func+0x188>
800034a4:	fe f8 0c a8 	ld.w	r8,pc[3240]
800034a8:	90 09       	ld.sh	r9,r8[0x0]
800034aa:	f4 09 19 00 	cp.h	r9,r10
800034ae:	c0 71       	brne	800034bc <phy_rx_func+0x188>
					&& (phy_check_sum == 0))
				{
					phy_rx(phy_frame_ptr);
800034b0:	fe f8 0c 94 	ld.w	r8,pc[3220]
800034b4:	70 0c       	ld.w	r12,r8[0x0]
800034b6:	f0 1f 03 27 	mcall	80004150 <phy_rx_func+0xe1c>
800034ba:	c0 88       	rjmp	800034ca <phy_rx_func+0x196>
				}
				else
				{
					vPortFree(phy_frame_ptr);
800034bc:	fe f6 0c 88 	ld.w	r6,pc[3208]
800034c0:	6c 0c       	ld.w	r12,r6[0x0]
800034c2:	f0 1f 03 22 	mcall	80004148 <phy_rx_func+0xe14>
					phy_frame_ptr = NULL;
800034c6:	30 08       	mov	r8,0
800034c8:	8d 08       	st.w	r6[0x0],r8
				}

				phy_rx_state = WAITING_FOR_HEADER;
800034ca:	30 09       	mov	r9,0
800034cc:	fe f8 0c 64 	ld.w	r8,pc[3172]
800034d0:	91 09       	st.w	r8[0x0],r9
800034d2:	c3 d8       	rjmp	8000354c <phy_rx_func+0x218>
				break;
			}
		
			/*Have not broken. 2nd hWord contains payload.*/
			phy_check_sum += (phy_dword & 0x0000FFFF);
800034d4:	5c 86       	casts.h	r6
800034d6:	fe f9 0c 76 	ld.w	r9,pc[3190]
800034da:	92 0a       	ld.sh	r10,r9[0x0]
800034dc:	0c 0a       	add	r10,r6
800034de:	b2 0a       	st.h	r9[0x0],r10
		
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
800034e0:	fe f9 0c 64 	ld.w	r9,pc[3172]
800034e4:	72 09       	ld.w	r9,r9[0x0]
800034e6:	f2 08 0a 16 	st.h	r9[r8<<0x1],r6
800034ea:	2f f8       	sub	r8,-1
800034ec:	fe f9 0c 4c 	ld.w	r9,pc[3148]
800034f0:	b2 08       	st.h	r9[0x0],r8
													   (phy_dword & 0x0000FFFF);
		
			phy_rx_expexted_length -= 2;
800034f2:	fe f9 0c 42 	ld.w	r9,pc[3138]
800034f6:	92 08       	ld.sh	r8,r9[0x0]
800034f8:	20 28       	sub	r8,2
800034fa:	b2 08       	st.h	r9[0x0],r8
			if (phy_rx_expexted_length <= 0)
800034fc:	30 09       	mov	r9,0
800034fe:	f2 08 19 00 	cp.h	r8,r9
80003502:	e0 89 00 25 	brgt	8000354c <phy_rx_func+0x218>
			{
				/*All read in. Next Word should be 0x00BA0000.*/
				phy_rx_state = WAITING_LAST_TERM;
80003506:	30 39       	mov	r9,3
80003508:	fe f8 0c 28 	ld.w	r8,pc[3112]
8000350c:	91 09       	st.w	r8[0x0],r9
8000350e:	c1 f8       	rjmp	8000354c <phy_rx_func+0x218>
			}/*else, next Word contains more payload.*/
			break;

		/*Expecting last terminator 0x00BA0000.*/	
		case WAITING_LAST_TERM:			
			if ((0x00BA0000 == (phy_dword  & 0x00FF0000)) /*Expected found.*/
80003510:	e6 16 00 ff 	andh	r6,0xff,COH
80003514:	fc 19 00 ba 	movh	r9,0xba
80003518:	12 36       	cp.w	r6,r9
8000351a:	c0 e1       	brne	80003536 <phy_rx_func+0x202>
8000351c:	fe f8 0c 30 	ld.w	r8,pc[3120]
80003520:	90 09       	ld.sh	r9,r8[0x0]
80003522:	30 08       	mov	r8,0
80003524:	f0 09 19 00 	cp.h	r9,r8
80003528:	c0 71       	brne	80003536 <phy_rx_func+0x202>
				&& (phy_check_sum == 0))/*Good checksum*/
			{
				phy_rx(phy_frame_ptr);
8000352a:	fe f8 0c 1a 	ld.w	r8,pc[3098]
8000352e:	70 0c       	ld.w	r12,r8[0x0]
80003530:	f0 1f 03 08 	mcall	80004150 <phy_rx_func+0xe1c>
80003534:	c0 88       	rjmp	80003544 <phy_rx_func+0x210>

			}
			else
			{
				vPortFree(phy_frame_ptr);
80003536:	fe f6 0c 0e 	ld.w	r6,pc[3086]
8000353a:	6c 0c       	ld.w	r12,r6[0x0]
8000353c:	f0 1f 03 03 	mcall	80004148 <phy_rx_func+0xe14>
				phy_frame_ptr = NULL;
80003540:	30 08       	mov	r8,0
80003542:	8d 08       	st.w	r6[0x0],r8
			}
				
			phy_rx_state = WAITING_FOR_HEADER;
80003544:	30 09       	mov	r9,0
80003546:	fe f8 0b ea 	ld.w	r8,pc[3050]
8000354a:	91 09       	st.w	r8[0x0],r9
			
	//payload_ptr_t *AMBE_payload_ptr;		
				
	
	
	if(is_first == FALSE)
8000354c:	fe f8 0c 08 	ld.w	r8,pc[3080]
80003550:	11 89       	ld.ub	r9,r8[0x0]
80003552:	30 08       	mov	r8,0
80003554:	f0 09 18 00 	cp.b	r9,r8
80003558:	c1 31       	brne	8000357e <phy_rx_func+0x24a>
	{
		payload_ptr = get_payload_idle_isr();
8000355a:	fe f6 0b fe 	ld.w	r6,pc[3070]
8000355e:	6c 0c       	ld.w	r12,r6[0x0]
80003560:	f0 1f 02 f8 	mcall	80004140 <phy_rx_func+0xe0c>
80003564:	fe f8 0b f8 	ld.w	r8,pc[3064]
80003568:	91 0c       	st.w	r8[0x0],r12
		AMBE_payload_ptr = get_payload_idle_isr();
8000356a:	6c 0c       	ld.w	r12,r6[0x0]
8000356c:	f0 1f 02 f5 	mcall	80004140 <phy_rx_func+0xe0c>
80003570:	fe f8 0b f0 	ld.w	r8,pc[3056]
80003574:	91 0c       	st.w	r8[0x0],r12
		is_first = TRUE;
80003576:	30 19       	mov	r9,1
80003578:	fe f8 0b dc 	ld.w	r8,pc[3036]
8000357c:	b0 89       	st.b	r8[0x0],r9
	}	
	
	//This is the RxMedia Phy Handler.
	switch (RxMediaState)
8000357e:	fe f8 0b e6 	ld.w	r8,pc[3046]
80003582:	70 08       	ld.w	r8,r8[0x0]
80003584:	58 28       	cp.w	r8,2
80003586:	e0 80 01 af 	breq	800038e4 <phy_rx_func+0x5b0>
8000358a:	e0 8b 00 06 	brhi	80003596 <phy_rx_func+0x262>
8000358e:	58 08       	cp.w	r8,0
80003590:	c0 b0       	breq	800035a6 <phy_rx_func+0x272>
80003592:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003596:	58 38       	cp.w	r8,3
80003598:	e0 80 05 82 	breq	8000409c <phy_rx_func+0xd68>
8000359c:	58 48       	cp.w	r8,4
8000359e:	e0 81 05 c3 	brne	80004124 <phy_rx_func+0xdf0>
800035a2:	e0 8f 02 62 	bral	80003a66 <phy_rx_func+0x732>
	{
		case WAITINGABAB:

			
			if (payload_rx_channel->dword[0] == 0xABCD5A5A)//Ignore Idles.
800035a6:	6e 28       	ld.w	r8,r7[0x8]
800035a8:	e0 6a 5a 5a 	mov	r10,23130
800035ac:	ea 1a ab cd 	orh	r10,0xabcd
800035b0:	14 38       	cp.w	r8,r10
800035b2:	c0 71       	brne	800035c0 <phy_rx_func+0x28c>
			{
				m_RxBurstType = VOICE_WATING;
800035b4:	30 09       	mov	r9,0
800035b6:	fe f8 0b b2 	ld.w	r8,pc[2994]
800035ba:	91 09       	st.w	r8[0x0],r9
800035bc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
				//Upon receiving the idle frame, the m Rx Burst Type into an idle state in order to transmit the synchronization wait
				 break; 
			}
            
			if ((payload_rx_channel->dword[0]  & 0xFFFF0000) != 0xABCD0000)break; //Skip until Header. 
800035c0:	10 99       	mov	r9,r8
800035c2:	e0 19 00 00 	andl	r9,0x0
800035c6:	fc 1a ab cd 	movh	r10,0xabcd
800035ca:	14 39       	cp.w	r9,r10
800035cc:	e0 81 05 ac 	brne	80004124 <phy_rx_func+0xdf0>
			}
			//logFromISR("\n\r P: %X \n\r", payload_rx_channel->word[1]);//
			
			#endif
			
			RxBytesWaiting = payload_rx_channel->dword[0] & 0x000000FF;
800035d0:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
800035d4:	fe f9 0b 98 	ld.w	r9,pc[2968]
800035d8:	93 08       	st.w	r9[0x0],r8
		
			if((NULL== payload_ptr) || (NULL== AMBE_payload_ptr))
800035da:	fe f8 0b 82 	ld.w	r8,pc[2946]
800035de:	70 08       	ld.w	r8,r8[0x0]
800035e0:	58 08       	cp.w	r8,0
800035e2:	c0 60       	breq	800035ee <phy_rx_func+0x2ba>
800035e4:	fe f8 0b 7c 	ld.w	r8,pc[2940]
800035e8:	70 08       	ld.w	r8,r8[0x0]
800035ea:	58 08       	cp.w	r8,0
800035ec:	c1 a1       	brne	80003620 <phy_rx_func+0x2ec>
			{
				payload_ptr = get_payload_idle_isr();
800035ee:	fe f6 0b 6a 	ld.w	r6,pc[2922]
800035f2:	6c 0c       	ld.w	r12,r6[0x0]
800035f4:	f0 1f 02 d3 	mcall	80004140 <phy_rx_func+0xe0c>
800035f8:	fe f5 0b 64 	ld.w	r5,pc[2916]
800035fc:	8b 0c       	st.w	r5[0x0],r12
				AMBE_payload_ptr = get_payload_idle_isr();
800035fe:	6c 0c       	ld.w	r12,r6[0x0]
80003600:	f0 1f 02 d0 	mcall	80004140 <phy_rx_func+0xe0c>
80003604:	fe f8 0b 5c 	ld.w	r8,pc[2908]
80003608:	91 0c       	st.w	r8[0x0],r12
				
				if((NULL== payload_ptr) || (NULL== AMBE_payload_ptr))
8000360a:	6a 08       	ld.w	r8,r5[0x0]
8000360c:	58 08       	cp.w	r8,0
8000360e:	c0 30       	breq	80003614 <phy_rx_func+0x2e0>
80003610:	58 0c       	cp.w	r12,0
80003612:	c0 71       	brne	80003620 <phy_rx_func+0x2ec>
				{
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//
80003614:	fe fc 0b 5c 	ld.w	r12,pc[2908]
80003618:	f0 1f 02 d7 	mcall	80004174 <phy_rx_func+0xe40>
8000361c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			}
			
		
			/****Note AMBE stream protocol frame structure and the PCM frame structure is different*****/
					
			if ((payload_rx_channel->dword[0] & 0x0000F000 ) == PAYLOAD_DATA_ENH )//PAYLOAD_DATA_ENH (0x0c))
80003620:	6e 28       	ld.w	r8,r7[0x8]
80003622:	e2 18 f0 00 	andl	r8,0xf000,COH
80003626:	e0 48 c0 00 	cp.w	r8,49152
8000362a:	e0 81 00 c7 	brne	800037b8 <phy_rx_func+0x484>
			{
											
				Item_ID = payload_rx_channel->byte[5];
8000362e:	ef 39 00 0d 	ld.ub	r9,r7[13]
80003632:	fe f8 0b 46 	ld.w	r8,pc[2886]
80003636:	b0 89       	st.b	r8[0x0],r9
				
				Item_Length = (payload_rx_channel->byte[4] & 0x7F);//7bits
80003638:	ef 3a 00 0c 	ld.ub	r10,r7[12]
8000363c:	f5 da c0 07 	bfextu	r10,r10,0x0,0x7
80003640:	fe f9 0b 3c 	ld.w	r9,pc[2876]
80003644:	93 0a       	st.w	r9[0x0],r10
								
				switch(Item_ID)
80003646:	11 88       	ld.ub	r8,r8[0x0]
80003648:	37 f9       	mov	r9,127
8000364a:	f2 08 18 00 	cp.b	r8,r9
8000364e:	c6 b0       	breq	80003724 <phy_rx_func+0x3f0>
80003650:	e0 8b 00 0c 	brhi	80003668 <phy_rx_func+0x334>
80003654:	31 29       	mov	r9,18
80003656:	f2 08 18 00 	cp.b	r8,r9
8000365a:	c4 20       	breq	800036de <phy_rx_func+0x3aa>
8000365c:	31 39       	mov	r9,19
8000365e:	f2 08 18 00 	cp.b	r8,r9
80003662:	e0 81 00 8b 	brne	80003778 <phy_rx_func+0x444>
80003666:	c5 98       	rjmp	80003718 <phy_rx_func+0x3e4>
80003668:	2f 08       	sub	r8,-16
8000366a:	30 19       	mov	r9,1
8000366c:	f2 08 18 00 	cp.b	r8,r9
80003670:	e0 8b 00 84 	brhi	80003778 <phy_rx_func+0x444>
					//The OB know the Call begin and discard the Voice Header
					//The OB know the Call end and discard the Voice  Terminator
					case Raw_Tx_Data_HT://0xF0
					case Raw_Rx_Data_HT://0xF1
					
							if ((payload_rx_channel->byte[6] & 0xF0 )== 0x10)//header
80003674:	ef 38 00 0e 	ld.ub	r8,r7[14]
80003678:	e2 18 00 f0 	andl	r8,0xf0,COH
8000367c:	59 08       	cp.w	r8,16
8000367e:	c0 71       	brne	8000368c <phy_rx_func+0x358>
							{
								m_RxBurstType = VOICEHEADER;
80003680:	30 19       	mov	r9,1
80003682:	fe f8 0a e6 	ld.w	r8,pc[2790]
80003686:	91 09       	st.w	r8[0x0],r9
80003688:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

							}
							else if ((payload_rx_channel->byte[6] & 0xF0) == 0x20)//Terminator
8000368c:	e0 48 00 20 	cp.w	r8,32
80003690:	c2 11       	brne	800036d2 <phy_rx_func+0x39e>
							{
								m_RxBurstType = VOICETERMINATOR;
80003692:	30 a9       	mov	r9,10
80003694:	fe f8 0a d4 	ld.w	r8,pc[2772]
80003698:	91 09       	st.w	r8[0x0],r9
								//AMBE-data and PCM-data is not the same. AMBE is compressed data,
								//if there was a missing portion, a clear voice is difficult to extract the data.
								//It must ensure that all the data received AMBE.
								
								//0
								memset((AMBE_payload_ptr+ (RxAMBE_IsFillingNext8 +1)), 0x00, (512-(RxAMBE_IsFillingNext8 + 1)));
8000369a:	fe f6 0a e6 	ld.w	r6,pc[2790]
8000369e:	6c 08       	ld.w	r8,r6[0x0]
800036a0:	f0 0a 11 ff 	rsub	r10,r8,-1
800036a4:	fe f7 0a bc 	ld.w	r7,pc[2748]
800036a8:	2f f8       	sub	r8,-1
800036aa:	6e 0c       	ld.w	r12,r7[0x0]
800036ac:	f4 ca fe 00 	sub	r10,r10,-512
800036b0:	30 0b       	mov	r11,0
800036b2:	10 0c       	add	r12,r8
800036b4:	f0 1f 02 b4 	mcall	80004184 <phy_rx_func+0xe50>
								
								RxAMBE_IsFillingNext8 = 0;
800036b8:	30 08       	mov	r8,0
800036ba:	8d 08       	st.w	r6[0x0],r8
								payload_rx(AMBE_payload_ptr);
800036bc:	6e 0c       	ld.w	r12,r7[0x0]
800036be:	f0 1f 02 b3 	mcall	80004188 <phy_rx_func+0xe54>
								AMBE_payload_ptr = get_payload_idle_isr();
800036c2:	fe f8 0a 96 	ld.w	r8,pc[2710]
800036c6:	70 0c       	ld.w	r12,r8[0x0]
800036c8:	f0 1f 02 9e 	mcall	80004140 <phy_rx_func+0xe0c>
800036cc:	8f 0c       	st.w	r7[0x0],r12
800036ce:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								//logFromISR("\n\r QQ1 \n\r");
								
							}
							else//error voice
							{
								m_RxBurstType = VOICE_WATING;
800036d2:	30 09       	mov	r9,0
800036d4:	fe f8 0a 94 	ld.w	r8,pc[2708]
800036d8:	91 09       	st.w	r8[0x0],r9
800036da:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;//WAITINGABAB.
					
		
					case Vocoder_Bit_Stream_Parameter://0x12
							
							if ((RxBytesWaiting -= 4) <= 0) break;
800036de:	fe f9 0a 8e 	ld.w	r9,pc[2702]
800036e2:	72 08       	ld.w	r8,r9[0x0]
800036e4:	20 48       	sub	r8,4
800036e6:	93 08       	st.w	r9[0x0],r8
800036e8:	e0 80 05 1e 	breq	80004124 <phy_rx_func+0xdf0>
					
							//Vocoder Bits Stream Parameter
							VF_SN = payload_rx_channel->byte[7];//This parameter is very important to the loop back Radio, as a reference.
800036ec:	ef 3c 00 0f 	ld.ub	r12,r7[15]
800036f0:	fe f8 0a 9c 	ld.w	r8,pc[2716]
800036f4:	b0 8c       	st.b	r8[0x0],r12
							
							VBSP_data[0] = payload_rx_channel->word[2];
800036f6:	8e 69       	ld.sh	r9,r7[0xc]
800036f8:	fe f8 0a 98 	ld.w	r8,pc[2712]
800036fc:	b0 09       	st.h	r8[0x0],r9
							VBSP_data[1] = payload_rx_channel->word[3];
800036fe:	8e 79       	ld.sh	r9,r7[0xe]
80003700:	b0 19       	st.h	r8[0x2],r9
							
							m_RxBurstType = CalculateBurst(VF_SN);
80003702:	f0 1f 02 a5 	mcall	80004194 <phy_rx_func+0xe60>
80003706:	fe f8 0a 62 	ld.w	r8,pc[2658]
8000370a:	91 0c       	st.w	r8[0x0],r12
							
							RxMediaState = READING_AMBE_MEDIA;//Jump
8000370c:	30 49       	mov	r9,4
8000370e:	fe f8 0a 56 	ld.w	r8,pc[2646]
80003712:	91 09       	st.w	r8[0x0],r9
80003714:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							
					//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
					// or discard it to reduce payload size.	
					//This shouldn't happen, but must check.	
					case Soft_Decision_Value://0x13
						m_RxBurstType = VOICE_WATING;
80003718:	30 09       	mov	r9,0
8000371a:	fe f8 0a 4e 	ld.w	r8,pc[2638]
8000371e:	91 09       	st.w	r8[0x0],r9
80003720:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;//WAITINGABAB.
							
								
					case Radio_Internal_Parameter://0x7F
							
							logFromISR("\n\r Item_Length:%d\n\r", Item_Length);
80003724:	fe f8 0a 58 	ld.w	r8,pc[2648]
80003728:	70 08       	ld.w	r8,r8[0x0]
8000372a:	1a d8       	st.w	--sp,r8
8000372c:	fe fc 0a 6c 	ld.w	r12,pc[2668]
80003730:	f0 1f 02 91 	mcall	80004174 <phy_rx_func+0xe40>
							
							if ((RxBytesWaiting -= 4) <= 0) break;
80003734:	fe f9 0a 38 	ld.w	r9,pc[2616]
80003738:	72 08       	ld.w	r8,r9[0x0]
8000373a:	20 48       	sub	r8,4
8000373c:	93 08       	st.w	r9[0x0],r8
8000373e:	2f fd       	sub	sp,-4
80003740:	58 08       	cp.w	r8,0
80003742:	e0 80 04 f1 	breq	80004124 <phy_rx_func+0xdf0>
							//Radio Internal Parameter
							Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[3];
80003746:	fe f8 0a 56 	ld.w	r8,pc[2646]
8000374a:	70 09       	ld.w	r9,r8[0x0]
8000374c:	8e 7b       	ld.sh	r11,r7[0xe]
8000374e:	fe fa 0a 52 	ld.w	r10,pc[2642]
80003752:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
							RxData_IsFillingNext16 += 1; 
80003756:	2f f9       	sub	r9,-1
80003758:	91 09       	st.w	r8[0x0],r9
							Item_Length -= 2 ;
8000375a:	fe f8 0a 22 	ld.w	r8,pc[2594]
8000375e:	70 09       	ld.w	r9,r8[0x0]
80003760:	20 29       	sub	r9,2
80003762:	91 09       	st.w	r8[0x0],r9
							//....................................................
							m_RxBurstType = RADIOINTERNAL;
80003764:	30 29       	mov	r9,2
80003766:	fe f8 0a 02 	ld.w	r8,pc[2562]
8000376a:	91 09       	st.w	r8[0x0],r9

							RxMediaState = READING_AMBE_AUX;//Jump
8000376c:	30 39       	mov	r9,3
8000376e:	fe f8 09 f6 	ld.w	r8,pc[2550]
80003772:	91 09       	st.w	r8[0x0],r9
80003774:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									
					default://0x03,0x04
						
						//((Item_ID == 0x04) || (Item_ID == 0x03) )//Unknown type data directly back hair
							//break;
							m_RxBurstType = UNSUREDATA;
80003778:	30 39       	mov	r9,3
8000377a:	fe f8 09 ee 	ld.w	r8,pc[2542]
8000377e:	91 09       	st.w	r8[0x0],r9
							AMBE_HT[0] = payload_rx_channel->dword[0];
80003780:	6e 29       	ld.w	r9,r7[0x8]
80003782:	fe f8 0a 22 	ld.w	r8,pc[2594]
80003786:	91 09       	st.w	r8[0x0],r9
							AMBE_HT[1] = payload_rx_channel->dword[1];
80003788:	6e 39       	ld.w	r9,r7[0xc]
8000378a:	91 19       	st.w	r8[0x4],r9
							
							if (RxBytesWaiting == 0x00000014)
8000378c:	fe f8 09 e0 	ld.w	r8,pc[2528]
80003790:	70 08       	ld.w	r8,r8[0x0]
80003792:	59 48       	cp.w	r8,20
80003794:	c0 61       	brne	800037a0 <phy_rx_func+0x46c>
							{
								RxBytesWaiting = 0x18;//24 Reassigned
80003796:	31 89       	mov	r9,24
80003798:	fe f8 09 d4 	ld.w	r8,pc[2516]
8000379c:	91 09       	st.w	r8[0x0],r9
8000379e:	c0 78       	rjmp	800037ac <phy_rx_func+0x478>
								//_flag =0;
								
							}
							if (RxBytesWaiting == 0x00000010)
800037a0:	59 08       	cp.w	r8,16
800037a2:	c0 51       	brne	800037ac <phy_rx_func+0x478>
							{
								RxBytesWaiting = 0x10;//16 Reassigned
800037a4:	31 09       	mov	r9,16
800037a6:	fe f8 09 c6 	ld.w	r8,pc[2502]
800037aa:	91 09       	st.w	r8[0x0],r9
								//_flag =1;
							}
					
							RxMediaState = READING_AMBE_MEDIA;//Jump
800037ac:	30 49       	mov	r9,4
800037ae:	fe f8 09 b6 	ld.w	r8,pc[2486]
800037b2:	91 09       	st.w	r8[0x0],r9
800037b4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
			else//PCM-media-data
			{	
				//logFromISR("\n\r RX:%x \n\r", payload_rx_channel->dword[0]);
				//SPEAKER_DATA or  //MIC_DATA
				if (((payload_rx_channel->dword[0] & 0x0000F000 ) != SPEAKER_DATA ) 
800037b8:	e0 48 10 00 	cp.w	r8,4096
800037bc:	5f 19       	srne	r9
800037be:	e0 48 20 00 	cp.w	r8,8192
800037c2:	5f 18       	srne	r8
800037c4:	f3 e8 00 08 	and	r8,r9,r8
800037c8:	e0 81 04 ae 	brne	80004124 <phy_rx_func+0xdf0>
					&& ((payload_rx_channel->dword[0] & 0x0000F000 ) != MIC_DATA ))break;
				
				AMBE_tx_flag = 0;
800037cc:	fe f9 09 dc 	ld.w	r9,pc[2524]
800037d0:	b2 88       	st.b	r9[0x0],r8
				AMBE_rx_flag = 0;
800037d2:	fe f9 09 da 	ld.w	r9,pc[2522]
800037d6:	b2 88       	st.b	r9[0x0],r8
				
				Item_ID = 0;//To make sure your save PCM data.
800037d8:	fe f9 09 a0 	ld.w	r9,pc[2464]
800037dc:	b2 88       	st.b	r9[0x0],r8
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
800037de:	6e 28       	ld.w	r8,r7[0x8]
800037e0:	e2 18 0f 00 	andl	r8,0xf00,COH
800037e4:	58 18       	cp.w	r8,1
800037e6:	e0 8b 00 4d 	brhi	80003880 <phy_rx_func+0x54c>
				
				if ((payload_rx_channel->dword[0]  & 0x00000F00) <= 1){  //Flag type must process Array Descriptor.
				//The first word of the media access payload must be the Array descriptor length. And the
				//unit of the length is in word (16-bit). The length field itself does not count into the length.
				//When there is no array descriptor, the length must be set to zero.[9.1.4.1]
				if ((RxBytesWaiting -= 4) <= 0) break;          //Nothing beyond this Phy buffer. Keep looking for Header
800037ea:	fe f9 09 82 	ld.w	r9,pc[2434]
800037ee:	72 08       	ld.w	r8,r9[0x0]
800037f0:	20 48       	sub	r8,4
800037f2:	93 08       	st.w	r9[0x0],r8
800037f4:	e0 80 04 98 	breq	80004124 <phy_rx_func+0xdf0>
				ArrayDiscLength = payload_rx_channel->word[2];
800037f8:	8e 68       	ld.sh	r8,r7[0xc]
800037fa:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
800037fe:	fe f9 09 b2 	ld.w	r9,pc[2482]
80003802:	93 0a       	st.w	r9[0x0],r10
				
				switch (ArrayDiscLength){
80003804:	30 09       	mov	r9,0
80003806:	f2 08 19 00 	cp.h	r8,r9
8000380a:	c0 70       	breq	80003818 <phy_rx_func+0x4e4>
8000380c:	30 19       	mov	r9,1
8000380e:	f2 08 19 00 	cp.h	r8,r9
80003812:	e0 81 04 89 	brne	80004124 <phy_rx_func+0xdf0>
80003816:	c2 68       	rjmp	80003862 <phy_rx_func+0x52e>
					case 0:          //The usual case. Remaining word in Phy buffer is Audio.
								
						payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
80003818:	fe f8 09 9c 	ld.w	r8,pc[2460]
8000381c:	70 0a       	ld.w	r10,r8[0x0]
8000381e:	fe f9 09 3e 	ld.w	r9,pc[2366]
80003822:	72 09       	ld.w	r9,r9[0x0]
80003824:	8e 7b       	ld.sh	r11,r7[0xe]
80003826:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
						RxMedia_IsFillingNext16 += 1;
8000382a:	70 09       	ld.w	r9,r8[0x0]
8000382c:	2f f9       	sub	r9,-1
8000382e:	91 09       	st.w	r8[0x0],r9
						if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003830:	e0 49 00 ff 	cp.w	r9,255
80003834:	e0 88 00 11 	brls	80003856 <phy_rx_func+0x522>
						{
							RxMedia_IsFillingNext16 = 0;	
80003838:	30 09       	mov	r9,0
8000383a:	91 09       	st.w	r8[0x0],r9
							payload_rx(payload_ptr);	
8000383c:	fe f7 09 20 	ld.w	r7,pc[2336]
80003840:	6e 0c       	ld.w	r12,r7[0x0]
80003842:	f0 1f 02 52 	mcall	80004188 <phy_rx_func+0xe54>
							payload_ptr = get_payload_idle_isr();
80003846:	fe f8 09 12 	ld.w	r8,pc[2322]
8000384a:	70 0c       	ld.w	r12,r8[0x0]
8000384c:	f0 1f 02 3d 	mcall	80004140 <phy_rx_func+0xe0c>
80003850:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == payload_ptr)
80003852:	e0 80 04 69 	breq	80004124 <phy_rx_func+0xdf0>
							{
								break;
							}				
						}
							RxMediaState = READINGMEDIA;
80003856:	30 29       	mov	r9,2
80003858:	fe f8 09 0c 	ld.w	r8,pc[2316]
8000385c:	91 09       	st.w	r8[0x0],r9
8000385e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003862:	8e 79       	ld.sh	r9,r7[0xe]
80003864:	30 38       	mov	r8,3
80003866:	f0 09 19 00 	cp.h	r9,r8
8000386a:	c0 51       	brne	80003874 <phy_rx_func+0x540>
				
					case 1: //The next usual case.
							//In general case, add code to process single word Array descriptor.
							if (payload_rx_channel->word[3] == 0x0003)//Stream Terminator
							{
								Terminator_Flag = 1;
8000386c:	30 19       	mov	r9,1
8000386e:	fe f8 09 4a 	ld.w	r8,pc[2378]
80003872:	b0 89       	st.b	r8[0x0],r9
							{
								//Terminator_Flag = 0;
							}
					
					
							RxMediaState = READINGMEDIA;
80003874:	30 29       	mov	r9,2
80003876:	fe f8 08 ee 	ld.w	r8,pc[2286]
8000387a:	91 09       	st.w	r8[0x0],r9
8000387c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
				break;
				}
		
				//Code gets here on Middle or last Fragment. No Array descriptor.
				if (RxBytesWaiting < 2) break;//This shouldn't happen, but must check.
80003880:	fe f8 08 ec 	ld.w	r8,pc[2284]
80003884:	70 08       	ld.w	r8,r8[0x0]
80003886:	58 18       	cp.w	r8,1
80003888:	e0 88 04 4e 	brls	80004124 <phy_rx_func+0xdf0>
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->dword[1] & 0x0000FFFF;
8000388c:	fe f8 09 28 	ld.w	r8,pc[2344]
80003890:	70 0a       	ld.w	r10,r8[0x0]
80003892:	fe f9 08 ca 	ld.w	r9,pc[2250]
80003896:	72 09       	ld.w	r9,r9[0x0]
80003898:	6e 3b       	ld.w	r11,r7[0xc]
8000389a:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
8000389e:	70 09       	ld.w	r9,r8[0x0]
800038a0:	2f f9       	sub	r9,-1
800038a2:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800038a4:	e0 49 00 ff 	cp.w	r9,255
800038a8:	e0 88 00 11 	brls	800038ca <phy_rx_func+0x596>
				{
					RxMedia_IsFillingNext16 = 0;
800038ac:	30 09       	mov	r9,0
800038ae:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);
800038b0:	fe f7 08 ac 	ld.w	r7,pc[2220]
800038b4:	6e 0c       	ld.w	r12,r7[0x0]
800038b6:	f0 1f 02 35 	mcall	80004188 <phy_rx_func+0xe54>
								payload_ptr = get_payload_idle_isr();
800038ba:	fe f8 08 9e 	ld.w	r8,pc[2206]
800038be:	70 0c       	ld.w	r12,r8[0x0]
800038c0:	f0 1f 02 20 	mcall	80004140 <phy_rx_func+0xe0c>
800038c4:	8f 0c       	st.w	r7[0x0],r12
													if(NULL == payload_ptr)
800038c6:	e0 80 04 2f 	breq	80004124 <phy_rx_func+0xdf0>
													{
														break;
													}
				}
				if ((RxBytesWaiting -= 2) <= 0) break;  //This shouldn't happen, but must check;
800038ca:	fe f9 08 a2 	ld.w	r9,pc[2210]
800038ce:	72 08       	ld.w	r8,r9[0x0]
800038d0:	20 28       	sub	r8,2
800038d2:	93 08       	st.w	r9[0x0],r8
800038d4:	e0 80 04 28 	breq	80004124 <phy_rx_func+0xdf0>
				RxMediaState = READINGMEDIA;
800038d8:	30 29       	mov	r9,2
800038da:	fe f8 08 8a 	ld.w	r8,pc[2186]
800038de:	91 09       	st.w	r8[0x0],r9
800038e0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
		case READINGMEDIA:
				
			/***PCM-media-data ****/
			{
				
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[0];
800038e4:	fe f8 08 d0 	ld.w	r8,pc[2256]
800038e8:	70 0a       	ld.w	r10,r8[0x0]
800038ea:	fe f9 08 72 	ld.w	r9,pc[2162]
800038ee:	72 09       	ld.w	r9,r9[0x0]
800038f0:	8e 4b       	ld.sh	r11,r7[0x8]
800038f2:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;	
800038f6:	70 09       	ld.w	r9,r8[0x0]
800038f8:	2f f9       	sub	r9,-1
800038fa:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800038fc:	e0 49 00 ff 	cp.w	r9,255
80003900:	e0 88 00 16 	brls	8000392c <phy_rx_func+0x5f8>
					{
							RxMedia_IsFillingNext16 = 0;
80003904:	30 09       	mov	r9,0
80003906:	91 09       	st.w	r8[0x0],r9
							payload_rx(payload_ptr);
80003908:	fe f6 08 54 	ld.w	r6,pc[2132]
8000390c:	6c 0c       	ld.w	r12,r6[0x0]
8000390e:	f0 1f 02 1f 	mcall	80004188 <phy_rx_func+0xe54>
							payload_ptr = get_payload_idle_isr();
80003912:	fe f8 08 46 	ld.w	r8,pc[2118]
80003916:	70 0c       	ld.w	r12,r8[0x0]
80003918:	f0 1f 02 0a 	mcall	80004140 <phy_rx_func+0xe0c>
8000391c:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == payload_ptr)
8000391e:	c0 71       	brne	8000392c <phy_rx_func+0x5f8>
							{
								RxMediaState = WAITINGABAB;
80003920:	30 09       	mov	r9,0
80003922:	fe f8 08 42 	ld.w	r8,pc[2114]
80003926:	91 09       	st.w	r8[0x0],r9
80003928:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
					}
				if ((RxBytesWaiting -= 2) <= 0)
8000392c:	fe f9 08 40 	ld.w	r9,pc[2112]
80003930:	72 08       	ld.w	r8,r9[0x0]
80003932:	20 28       	sub	r8,2
80003934:	93 08       	st.w	r9[0x0],r8
80003936:	c0 71       	brne	80003944 <phy_rx_func+0x610>
				{
					RxMediaState = WAITINGABAB;
80003938:	30 09       	mov	r9,0
8000393a:	fe f8 08 2a 	ld.w	r8,pc[2090]
8000393e:	91 09       	st.w	r8[0x0],r9
80003940:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[1];
80003944:	fe f8 08 70 	ld.w	r8,pc[2160]
80003948:	70 0a       	ld.w	r10,r8[0x0]
8000394a:	fe f9 08 12 	ld.w	r9,pc[2066]
8000394e:	72 09       	ld.w	r9,r9[0x0]
80003950:	8e 5b       	ld.sh	r11,r7[0xa]
80003952:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80003956:	70 09       	ld.w	r9,r8[0x0]
80003958:	2f f9       	sub	r9,-1
8000395a:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
8000395c:	e0 49 00 ff 	cp.w	r9,255
80003960:	e0 88 00 16 	brls	8000398c <phy_rx_func+0x658>
						{
							RxMedia_IsFillingNext16 = 0;
80003964:	30 09       	mov	r9,0
80003966:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);
80003968:	fe f6 07 f4 	ld.w	r6,pc[2036]
8000396c:	6c 0c       	ld.w	r12,r6[0x0]
8000396e:	f0 1f 02 07 	mcall	80004188 <phy_rx_func+0xe54>
								payload_ptr = get_payload_idle_isr();
80003972:	fe f8 07 e6 	ld.w	r8,pc[2022]
80003976:	70 0c       	ld.w	r12,r8[0x0]
80003978:	f0 1f 01 f2 	mcall	80004140 <phy_rx_func+0xe0c>
8000397c:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == payload_ptr)
8000397e:	c0 71       	brne	8000398c <phy_rx_func+0x658>
								{
									RxMediaState = WAITINGABAB;
80003980:	30 09       	mov	r9,0
80003982:	fe f8 07 e2 	ld.w	r8,pc[2018]
80003986:	91 09       	st.w	r8[0x0],r9
80003988:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
						}
				if ((RxBytesWaiting -= 2) <= 0){
8000398c:	fe f9 07 e0 	ld.w	r9,pc[2016]
80003990:	72 08       	ld.w	r8,r9[0x0]
80003992:	20 28       	sub	r8,2
80003994:	93 08       	st.w	r9[0x0],r8
80003996:	c0 71       	brne	800039a4 <phy_rx_func+0x670>
					RxMediaState = WAITINGABAB;
80003998:	30 09       	mov	r9,0
8000399a:	fe f8 07 ca 	ld.w	r8,pc[1994]
8000399e:	91 09       	st.w	r8[0x0],r9
800039a0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}

				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[2];
800039a4:	fe f8 08 10 	ld.w	r8,pc[2064]
800039a8:	70 0a       	ld.w	r10,r8[0x0]
800039aa:	fe f9 07 b2 	ld.w	r9,pc[1970]
800039ae:	72 09       	ld.w	r9,r9[0x0]
800039b0:	8e 6b       	ld.sh	r11,r7[0xc]
800039b2:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
800039b6:	70 09       	ld.w	r9,r8[0x0]
800039b8:	2f f9       	sub	r9,-1
800039ba:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800039bc:	e0 49 00 ff 	cp.w	r9,255
800039c0:	e0 88 00 16 	brls	800039ec <phy_rx_func+0x6b8>
						{
							RxMedia_IsFillingNext16 = 0;
800039c4:	30 09       	mov	r9,0
800039c6:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);
800039c8:	fe f6 07 94 	ld.w	r6,pc[1940]
800039cc:	6c 0c       	ld.w	r12,r6[0x0]
800039ce:	f0 1f 01 ef 	mcall	80004188 <phy_rx_func+0xe54>
									payload_ptr = get_payload_idle_isr();
800039d2:	fe f8 07 86 	ld.w	r8,pc[1926]
800039d6:	70 0c       	ld.w	r12,r8[0x0]
800039d8:	f0 1f 01 da 	mcall	80004140 <phy_rx_func+0xe0c>
800039dc:	8d 0c       	st.w	r6[0x0],r12
									if(NULL == payload_ptr)
800039de:	c0 71       	brne	800039ec <phy_rx_func+0x6b8>
									{
										RxMediaState = WAITINGABAB;
800039e0:	30 09       	mov	r9,0
800039e2:	fe f8 07 82 	ld.w	r8,pc[1922]
800039e6:	91 09       	st.w	r8[0x0],r9
800039e8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
						}
				if ((RxBytesWaiting -= 2) <= 0){
800039ec:	fe f9 07 80 	ld.w	r9,pc[1920]
800039f0:	72 08       	ld.w	r8,r9[0x0]
800039f2:	20 28       	sub	r8,2
800039f4:	93 08       	st.w	r9[0x0],r8
800039f6:	c0 71       	brne	80003a04 <phy_rx_func+0x6d0>
					RxMediaState = WAITINGABAB;
800039f8:	30 09       	mov	r9,0
800039fa:	fe f8 07 6a 	ld.w	r8,pc[1898]
800039fe:	91 09       	st.w	r8[0x0],r9
80003a00:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
80003a04:	fe f8 07 b0 	ld.w	r8,pc[1968]
80003a08:	70 0a       	ld.w	r10,r8[0x0]
80003a0a:	fe f9 07 52 	ld.w	r9,pc[1874]
80003a0e:	72 09       	ld.w	r9,r9[0x0]
80003a10:	8e 7b       	ld.sh	r11,r7[0xe]
80003a12:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80003a16:	70 09       	ld.w	r9,r8[0x0]
80003a18:	2f f9       	sub	r9,-1
80003a1a:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003a1c:	e0 49 00 ff 	cp.w	r9,255
80003a20:	e0 88 00 16 	brls	80003a4c <phy_rx_func+0x718>
						{
							RxMedia_IsFillingNext16 = 0;
80003a24:	30 09       	mov	r9,0
80003a26:	91 09       	st.w	r8[0x0],r9
							payload_rx(payload_ptr);
80003a28:	fe f7 07 34 	ld.w	r7,pc[1844]
80003a2c:	6e 0c       	ld.w	r12,r7[0x0]
80003a2e:	f0 1f 01 d7 	mcall	80004188 <phy_rx_func+0xe54>
							payload_ptr = get_payload_idle_isr();
80003a32:	fe f8 07 26 	ld.w	r8,pc[1830]
80003a36:	70 0c       	ld.w	r12,r8[0x0]
80003a38:	f0 1f 01 c2 	mcall	80004140 <phy_rx_func+0xe0c>
80003a3c:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == payload_ptr)
80003a3e:	c0 71       	brne	80003a4c <phy_rx_func+0x718>
							{
								RxMediaState = WAITINGABAB;
80003a40:	30 09       	mov	r9,0
80003a42:	fe f8 07 22 	ld.w	r8,pc[1826]
80003a46:	91 09       	st.w	r8[0x0],r9
80003a48:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
				if ((RxBytesWaiting -= 2) <= 0){
80003a4c:	fe f9 07 20 	ld.w	r9,pc[1824]
80003a50:	72 08       	ld.w	r8,r9[0x0]
80003a52:	20 28       	sub	r8,2
80003a54:	93 08       	st.w	r9[0x0],r8
80003a56:	e0 81 03 67 	brne	80004124 <phy_rx_func+0xdf0>
					RxMediaState = WAITINGABAB;
80003a5a:	30 09       	mov	r9,0
80003a5c:	fe f8 07 08 	ld.w	r8,pc[1800]
80003a60:	91 09       	st.w	r8[0x0],r9
80003a62:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

		case READING_AMBE_MEDIA:
		
			/****AMBE-media-data ****/
		
					if ((Item_ID == Vocoder_Bit_Stream_Parameter))//PAYLOAD_DATA_ENH (0x0c))
80003a66:	fe f8 07 12 	ld.w	r8,pc[1810]
80003a6a:	11 89       	ld.ub	r9,r8[0x0]
80003a6c:	31 28       	mov	r8,18
80003a6e:	f0 09 18 00 	cp.b	r9,r8
80003a72:	e0 81 01 4c 	brne	80003d0a <phy_rx_func+0x9d6>
					{
						Item_ID = payload_rx_channel->byte[1];
80003a76:	ef 39 00 09 	ld.ub	r9,r7[9]
80003a7a:	fe f8 06 fe 	ld.w	r8,pc[1790]
80003a7e:	b0 89       	st.b	r8[0x0],r9
						if (Item_ID == Post_Voice_Encoder_Data)//
80003a80:	11 89       	ld.ub	r9,r8[0x0]
80003a82:	3f 28       	mov	r8,-14
80003a84:	f0 09 18 00 	cp.b	r9,r8
80003a88:	e0 81 01 3b 	brne	80003cfe <phy_rx_func+0x9ca>
						{
							AMBE_tx_flag = 1;
80003a8c:	30 19       	mov	r9,1
80003a8e:	fe f8 07 1a 	ld.w	r8,pc[1818]
80003a92:	b0 89       	st.b	r8[0x0],r9
							
							RxBytesWaiting = ((payload_rx_channel->dword[0] & 0x7F000000) >>24);//Test calculations are correct; 8
80003a94:	6e 29       	ld.w	r9,r7[0x8]
80003a96:	f3 d9 c3 07 	bfextu	r9,r9,0x18,0x7
80003a9a:	fe f8 06 d2 	ld.w	r8,pc[1746]
80003a9e:	91 09       	st.w	r8[0x0],r9
							
							//For looping back to Radio
							AMBEBurst_rawdata[0] = payload_rx_channel->word[1];
80003aa0:	8e 59       	ld.sh	r9,r7[0xa]
80003aa2:	fe f8 07 1a 	ld.w	r8,pc[1818]
80003aa6:	b0 09       	st.h	r8[0x0],r9
							AMBEBurst_rawdata[1] = payload_rx_channel->word[2];
80003aa8:	8e 69       	ld.sh	r9,r7[0xc]
80003aaa:	b0 19       	st.h	r8[0x2],r9
							AMBEBurst_rawdata[2] = payload_rx_channel->word[3];
80003aac:	8e 79       	ld.sh	r9,r7[0xe]
80003aae:	b0 29       	st.h	r8[0x4],r9
							
							//To be tested. Also locally stored RAW-AMBER-DATA
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//1
80003ab0:	fe f8 06 d0 	ld.w	r8,pc[1744]
80003ab4:	fe f9 06 ac 	ld.w	r9,pc[1708]
80003ab8:	72 0a       	ld.w	r10,r9[0x0]
80003aba:	70 09       	ld.w	r9,r8[0x0]
80003abc:	ef 3b 00 0a 	ld.ub	r11,r7[10]
80003ac0:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003ac4:	70 09       	ld.w	r9,r8[0x0]
80003ac6:	2f f9       	sub	r9,-1
80003ac8:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003aca:	e0 49 01 ff 	cp.w	r9,511
80003ace:	e0 88 00 16 	brls	80003afa <phy_rx_func+0x7c6>
							{
								RxAMBE_IsFillingNext8 = 0;
80003ad2:	30 09       	mov	r9,0
80003ad4:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003ad6:	fe f6 06 8a 	ld.w	r6,pc[1674]
80003ada:	6c 0c       	ld.w	r12,r6[0x0]
80003adc:	f0 1f 01 ab 	mcall	80004188 <phy_rx_func+0xe54>
								AMBE_payload_ptr = get_payload_idle_isr();
80003ae0:	fe f8 06 78 	ld.w	r8,pc[1656]
80003ae4:	70 0c       	ld.w	r12,r8[0x0]
80003ae6:	f0 1f 01 97 	mcall	80004140 <phy_rx_func+0xe0c>
80003aea:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003aec:	c0 71       	brne	80003afa <phy_rx_func+0x7c6>
								{
									RxMediaState = WAITINGABAB;
80003aee:	30 09       	mov	r9,0
80003af0:	fe f8 06 74 	ld.w	r8,pc[1652]
80003af4:	91 09       	st.w	r8[0x0],r9
80003af6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003afa:	fe f9 06 72 	ld.w	r9,pc[1650]
80003afe:	72 08       	ld.w	r8,r9[0x0]
80003b00:	20 18       	sub	r8,1
80003b02:	93 08       	st.w	r9[0x0],r8
80003b04:	c0 71       	brne	80003b12 <phy_rx_func+0x7de>
								RxMediaState = WAITINGABAB;
80003b06:	30 09       	mov	r9,0
80003b08:	fe f8 06 5c 	ld.w	r8,pc[1628]
80003b0c:	91 09       	st.w	r8[0x0],r9
80003b0e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}			
							
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//2
80003b12:	fe f8 06 6e 	ld.w	r8,pc[1646]
80003b16:	fe f9 06 4a 	ld.w	r9,pc[1610]
80003b1a:	72 0a       	ld.w	r10,r9[0x0]
80003b1c:	70 09       	ld.w	r9,r8[0x0]
80003b1e:	ef 3b 00 0b 	ld.ub	r11,r7[11]
80003b22:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003b26:	70 09       	ld.w	r9,r8[0x0]
80003b28:	2f f9       	sub	r9,-1
80003b2a:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003b2c:	e0 49 01 ff 	cp.w	r9,511
80003b30:	e0 88 00 16 	brls	80003b5c <phy_rx_func+0x828>
							{
								RxAMBE_IsFillingNext8 = 0;
80003b34:	30 09       	mov	r9,0
80003b36:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003b38:	fe f6 06 28 	ld.w	r6,pc[1576]
80003b3c:	6c 0c       	ld.w	r12,r6[0x0]
80003b3e:	f0 1f 01 93 	mcall	80004188 <phy_rx_func+0xe54>
								AMBE_payload_ptr = get_payload_idle_isr();
80003b42:	fe f8 06 16 	ld.w	r8,pc[1558]
80003b46:	70 0c       	ld.w	r12,r8[0x0]
80003b48:	f0 1f 01 7e 	mcall	80004140 <phy_rx_func+0xe0c>
80003b4c:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003b4e:	c0 71       	brne	80003b5c <phy_rx_func+0x828>
								{
									RxMediaState = WAITINGABAB;
80003b50:	30 09       	mov	r9,0
80003b52:	fe f8 06 12 	ld.w	r8,pc[1554]
80003b56:	91 09       	st.w	r8[0x0],r9
80003b58:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003b5c:	fe f9 06 10 	ld.w	r9,pc[1552]
80003b60:	72 08       	ld.w	r8,r9[0x0]
80003b62:	20 18       	sub	r8,1
80003b64:	93 08       	st.w	r9[0x0],r8
80003b66:	c0 71       	brne	80003b74 <phy_rx_func+0x840>
								RxMediaState = WAITINGABAB;
80003b68:	30 09       	mov	r9,0
80003b6a:	fe f8 05 fa 	ld.w	r8,pc[1530]
80003b6e:	91 09       	st.w	r8[0x0],r9
80003b70:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}		
						
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//3
80003b74:	fe f8 06 0c 	ld.w	r8,pc[1548]
80003b78:	fe f9 05 e8 	ld.w	r9,pc[1512]
80003b7c:	72 0a       	ld.w	r10,r9[0x0]
80003b7e:	70 09       	ld.w	r9,r8[0x0]
80003b80:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80003b84:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003b88:	70 09       	ld.w	r9,r8[0x0]
80003b8a:	2f f9       	sub	r9,-1
80003b8c:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003b8e:	e0 49 01 ff 	cp.w	r9,511
80003b92:	e0 88 00 16 	brls	80003bbe <phy_rx_func+0x88a>
							{
								RxAMBE_IsFillingNext8 = 0;
80003b96:	30 09       	mov	r9,0
80003b98:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003b9a:	fe f6 05 c6 	ld.w	r6,pc[1478]
80003b9e:	6c 0c       	ld.w	r12,r6[0x0]
80003ba0:	f0 1f 01 7a 	mcall	80004188 <phy_rx_func+0xe54>
								AMBE_payload_ptr = get_payload_idle_isr();
80003ba4:	fe f8 05 b4 	ld.w	r8,pc[1460]
80003ba8:	70 0c       	ld.w	r12,r8[0x0]
80003baa:	f0 1f 01 66 	mcall	80004140 <phy_rx_func+0xe0c>
80003bae:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003bb0:	c0 71       	brne	80003bbe <phy_rx_func+0x88a>
								{
									RxMediaState = WAITINGABAB;
80003bb2:	30 09       	mov	r9,0
80003bb4:	fe f8 05 b0 	ld.w	r8,pc[1456]
80003bb8:	91 09       	st.w	r8[0x0],r9
80003bba:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003bbe:	fe f9 05 ae 	ld.w	r9,pc[1454]
80003bc2:	72 08       	ld.w	r8,r9[0x0]
80003bc4:	20 18       	sub	r8,1
80003bc6:	93 08       	st.w	r9[0x0],r8
80003bc8:	c0 71       	brne	80003bd6 <phy_rx_func+0x8a2>
								RxMediaState = WAITINGABAB;
80003bca:	30 09       	mov	r9,0
80003bcc:	fe f8 05 98 	ld.w	r8,pc[1432]
80003bd0:	91 09       	st.w	r8[0x0],r9
80003bd2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[5];//4
80003bd6:	fe f8 05 aa 	ld.w	r8,pc[1450]
80003bda:	fe f9 05 86 	ld.w	r9,pc[1414]
80003bde:	72 0a       	ld.w	r10,r9[0x0]
80003be0:	70 09       	ld.w	r9,r8[0x0]
80003be2:	ef 3b 00 0d 	ld.ub	r11,r7[13]
80003be6:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003bea:	70 09       	ld.w	r9,r8[0x0]
80003bec:	2f f9       	sub	r9,-1
80003bee:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003bf0:	e0 49 01 ff 	cp.w	r9,511
80003bf4:	e0 88 00 16 	brls	80003c20 <phy_rx_func+0x8ec>
							{
								RxAMBE_IsFillingNext8 = 0;
80003bf8:	30 09       	mov	r9,0
80003bfa:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003bfc:	fe f6 05 64 	ld.w	r6,pc[1380]
80003c00:	6c 0c       	ld.w	r12,r6[0x0]
80003c02:	f0 1f 01 62 	mcall	80004188 <phy_rx_func+0xe54>
								AMBE_payload_ptr = get_payload_idle_isr();
80003c06:	fe f8 05 52 	ld.w	r8,pc[1362]
80003c0a:	70 0c       	ld.w	r12,r8[0x0]
80003c0c:	f0 1f 01 4d 	mcall	80004140 <phy_rx_func+0xe0c>
80003c10:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003c12:	c0 71       	brne	80003c20 <phy_rx_func+0x8ec>
								{
									RxMediaState = WAITINGABAB;
80003c14:	30 09       	mov	r9,0
80003c16:	fe f8 05 4e 	ld.w	r8,pc[1358]
80003c1a:	91 09       	st.w	r8[0x0],r9
80003c1c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003c20:	fe f9 05 4c 	ld.w	r9,pc[1356]
80003c24:	72 08       	ld.w	r8,r9[0x0]
80003c26:	20 18       	sub	r8,1
80003c28:	93 08       	st.w	r9[0x0],r8
80003c2a:	c0 71       	brne	80003c38 <phy_rx_func+0x904>
								RxMediaState = WAITINGABAB;
80003c2c:	30 09       	mov	r9,0
80003c2e:	fe f8 05 36 	ld.w	r8,pc[1334]
80003c32:	91 09       	st.w	r8[0x0],r9
80003c34:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//5
80003c38:	fe f8 05 48 	ld.w	r8,pc[1352]
80003c3c:	fe f9 05 24 	ld.w	r9,pc[1316]
80003c40:	72 0a       	ld.w	r10,r9[0x0]
80003c42:	70 09       	ld.w	r9,r8[0x0]
80003c44:	ef 3b 00 0e 	ld.ub	r11,r7[14]
80003c48:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003c4c:	70 09       	ld.w	r9,r8[0x0]
80003c4e:	2f f9       	sub	r9,-1
80003c50:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003c52:	e0 49 01 ff 	cp.w	r9,511
80003c56:	e0 88 00 16 	brls	80003c82 <phy_rx_func+0x94e>
							{
								RxAMBE_IsFillingNext8 = 0;
80003c5a:	30 09       	mov	r9,0
80003c5c:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003c5e:	fe f6 05 02 	ld.w	r6,pc[1282]
80003c62:	6c 0c       	ld.w	r12,r6[0x0]
80003c64:	f0 1f 01 49 	mcall	80004188 <phy_rx_func+0xe54>
								AMBE_payload_ptr = get_payload_idle_isr();
80003c68:	fe f8 04 f0 	ld.w	r8,pc[1264]
80003c6c:	70 0c       	ld.w	r12,r8[0x0]
80003c6e:	f0 1f 01 35 	mcall	80004140 <phy_rx_func+0xe0c>
80003c72:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003c74:	c0 71       	brne	80003c82 <phy_rx_func+0x94e>
								{
									RxMediaState = WAITINGABAB;
80003c76:	30 09       	mov	r9,0
80003c78:	fe f8 04 ec 	ld.w	r8,pc[1260]
80003c7c:	91 09       	st.w	r8[0x0],r9
80003c7e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003c82:	fe f9 04 ea 	ld.w	r9,pc[1258]
80003c86:	72 08       	ld.w	r8,r9[0x0]
80003c88:	20 18       	sub	r8,1
80003c8a:	93 08       	st.w	r9[0x0],r8
80003c8c:	c0 71       	brne	80003c9a <phy_rx_func+0x966>
								RxMediaState = WAITINGABAB;
80003c8e:	30 09       	mov	r9,0
80003c90:	fe f8 04 d4 	ld.w	r8,pc[1236]
80003c94:	91 09       	st.w	r8[0x0],r9
80003c96:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//6
80003c9a:	fe f8 04 e6 	ld.w	r8,pc[1254]
80003c9e:	fe f9 04 c2 	ld.w	r9,pc[1218]
80003ca2:	72 0a       	ld.w	r10,r9[0x0]
80003ca4:	70 09       	ld.w	r9,r8[0x0]
80003ca6:	ef 3b 00 0f 	ld.ub	r11,r7[15]
80003caa:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003cae:	70 09       	ld.w	r9,r8[0x0]
80003cb0:	2f f9       	sub	r9,-1
80003cb2:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003cb4:	e0 49 01 ff 	cp.w	r9,511
80003cb8:	e0 88 00 16 	brls	80003ce4 <phy_rx_func+0x9b0>
							{
								RxAMBE_IsFillingNext8 = 0;
80003cbc:	30 09       	mov	r9,0
80003cbe:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003cc0:	fe f7 04 a0 	ld.w	r7,pc[1184]
80003cc4:	6e 0c       	ld.w	r12,r7[0x0]
80003cc6:	f0 1f 01 31 	mcall	80004188 <phy_rx_func+0xe54>
								AMBE_payload_ptr = get_payload_idle_isr();
80003cca:	fe f8 04 8e 	ld.w	r8,pc[1166]
80003cce:	70 0c       	ld.w	r12,r8[0x0]
80003cd0:	f0 1f 01 1c 	mcall	80004140 <phy_rx_func+0xe0c>
80003cd4:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003cd6:	c0 71       	brne	80003ce4 <phy_rx_func+0x9b0>
								{
									RxMediaState = WAITINGABAB;
80003cd8:	30 09       	mov	r9,0
80003cda:	fe f8 04 8a 	ld.w	r8,pc[1162]
80003cde:	91 09       	st.w	r8[0x0],r9
80003ce0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003ce4:	fe f9 04 88 	ld.w	r9,pc[1160]
80003ce8:	72 08       	ld.w	r8,r9[0x0]
80003cea:	20 18       	sub	r8,1
80003cec:	93 08       	st.w	r9[0x0],r8
80003cee:	e0 81 02 1b 	brne	80004124 <phy_rx_func+0xdf0>
								RxMediaState = WAITINGABAB;
80003cf2:	30 09       	mov	r9,0
80003cf4:	fe f8 04 70 	ld.w	r8,pc[1136]
80003cf8:	91 09       	st.w	r8[0x0],r9
80003cfa:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							//}
							
						}
						else//error
						{
							RxMediaState = WAITINGABAB;
80003cfe:	30 09       	mov	r9,0
80003d00:	fe f8 04 64 	ld.w	r8,pc[1124]
80003d04:	91 09       	st.w	r8[0x0],r9
80003d06:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
					}
					else if (Item_ID == Post_Voice_Encoder_Data)//(bit48~Pad-bits)
80003d0a:	fe f8 04 6e 	ld.w	r8,pc[1134]
80003d0e:	11 89       	ld.ub	r9,r8[0x0]
80003d10:	3f 28       	mov	r8,-14
80003d12:	f0 09 18 00 	cp.b	r9,r8
80003d16:	c4 31       	brne	80003d9c <phy_rx_func+0xa68>
					{
					
						AMBEBurst_rawdata[3] = payload_rx_channel->word[0];//(bit48~Pad-bits)
80003d18:	8e 49       	ld.sh	r9,r7[0x8]
80003d1a:	fe f8 04 a2 	ld.w	r8,pc[1186]
80003d1e:	b0 39       	st.h	r8[0x6],r9
						//AMBE_Per_Burst_Flag = 1;
						
						//MOTO.bitpad-bits
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//7
80003d20:	fe f8 04 60 	ld.w	r8,pc[1120]
80003d24:	fe f9 04 3c 	ld.w	r9,pc[1084]
80003d28:	72 0a       	ld.w	r10,r9[0x0]
80003d2a:	70 09       	ld.w	r9,r8[0x0]
80003d2c:	ef 3b 00 08 	ld.ub	r11,r7[8]
80003d30:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003d34:	70 09       	ld.w	r9,r8[0x0]
80003d36:	2f f9       	sub	r9,-1
80003d38:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003d3a:	e0 49 01 ff 	cp.w	r9,511
80003d3e:	e0 88 00 16 	brls	80003d6a <phy_rx_func+0xa36>
						{
							RxAMBE_IsFillingNext8 = 0;
80003d42:	30 09       	mov	r9,0
80003d44:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003d46:	fe f7 04 1a 	ld.w	r7,pc[1050]
80003d4a:	6e 0c       	ld.w	r12,r7[0x0]
80003d4c:	f0 1f 01 0f 	mcall	80004188 <phy_rx_func+0xe54>
							AMBE_payload_ptr = get_payload_idle_isr();
80003d50:	fe f8 04 08 	ld.w	r8,pc[1032]
80003d54:	70 0c       	ld.w	r12,r8[0x0]
80003d56:	f0 1f 00 fb 	mcall	80004140 <phy_rx_func+0xe0c>
80003d5a:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003d5c:	c0 71       	brne	80003d6a <phy_rx_func+0xa36>
							{
								RxMediaState = WAITINGABAB;
80003d5e:	30 09       	mov	r9,0
80003d60:	fe f8 04 04 	ld.w	r8,pc[1028]
80003d64:	91 09       	st.w	r8[0x0],r9
80003d66:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003d6a:	fe f9 04 02 	ld.w	r9,pc[1026]
80003d6e:	72 08       	ld.w	r8,r9[0x0]
80003d70:	20 18       	sub	r8,1
80003d72:	93 08       	st.w	r9[0x0],r8
80003d74:	c0 71       	brne	80003d82 <phy_rx_func+0xa4e>
							RxMediaState = WAITINGABAB;
80003d76:	30 09       	mov	r9,0
80003d78:	fe f8 03 ec 	ld.w	r8,pc[1004]
80003d7c:	91 09       	st.w	r8[0x0],r9
80003d7e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
						if ((RxBytesWaiting -= 1) <= 0){//AMBE Vocoder Bits Stream(bit59~63),
80003d82:	20 18       	sub	r8,1
80003d84:	fe f9 03 e8 	ld.w	r9,pc[1000]
80003d88:	93 08       	st.w	r9[0x0],r8
80003d8a:	58 08       	cp.w	r8,0
80003d8c:	e0 81 01 cc 	brne	80004124 <phy_rx_func+0xdf0>
							RxMediaState = WAITINGABAB;
80003d90:	30 09       	mov	r9,0
80003d92:	fe f8 03 d2 	ld.w	r8,pc[978]
80003d96:	91 09       	st.w	r8[0x0],r9
80003d98:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
								
					}
					else if (Item_ID == Pre_Voice_Decoder_Data)//bit0~bit63
80003d9c:	fe f8 03 dc 	ld.w	r8,pc[988]
80003da0:	11 89       	ld.ub	r9,r8[0x0]
80003da2:	3f 38       	mov	r8,-13
80003da4:	f0 09 18 00 	cp.b	r9,r8
80003da8:	e0 81 01 5a 	brne	8000405c <phy_rx_func+0xd28>
					{
						//
						//For looping back to Radio
						AMBEBurst_rawdata[0] = payload_rx_channel->word[0];
80003dac:	8e 49       	ld.sh	r9,r7[0x8]
80003dae:	fe f8 04 0e 	ld.w	r8,pc[1038]
80003db2:	b0 09       	st.h	r8[0x0],r9
						AMBEBurst_rawdata[1] = payload_rx_channel->word[1];
80003db4:	8e 59       	ld.sh	r9,r7[0xa]
80003db6:	b0 19       	st.h	r8[0x2],r9
						AMBEBurst_rawdata[2] = payload_rx_channel->word[2];
80003db8:	8e 69       	ld.sh	r9,r7[0xc]
80003dba:	b0 29       	st.h	r8[0x4],r9
						AMBEBurst_rawdata[3] = payload_rx_channel->word[3];
80003dbc:	8e 79       	ld.sh	r9,r7[0xe]
80003dbe:	b0 39       	st.h	r8[0x6],r9
						
						//To be tested. Also locally stored RAW-AMBER-DATA
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//1
80003dc0:	fe f8 03 c0 	ld.w	r8,pc[960]
80003dc4:	fe f9 03 9c 	ld.w	r9,pc[924]
80003dc8:	72 0a       	ld.w	r10,r9[0x0]
80003dca:	70 09       	ld.w	r9,r8[0x0]
80003dcc:	ef 3b 00 08 	ld.ub	r11,r7[8]
80003dd0:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003dd4:	70 09       	ld.w	r9,r8[0x0]
80003dd6:	2f f9       	sub	r9,-1
80003dd8:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003dda:	e0 49 01 ff 	cp.w	r9,511
80003dde:	e0 88 00 16 	brls	80003e0a <phy_rx_func+0xad6>
						{
							RxAMBE_IsFillingNext8 = 0;
80003de2:	30 09       	mov	r9,0
80003de4:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003de6:	fe f6 03 7a 	ld.w	r6,pc[890]
80003dea:	6c 0c       	ld.w	r12,r6[0x0]
80003dec:	f0 1f 00 e7 	mcall	80004188 <phy_rx_func+0xe54>
							AMBE_payload_ptr = get_payload_idle_isr();
80003df0:	fe f8 03 68 	ld.w	r8,pc[872]
80003df4:	70 0c       	ld.w	r12,r8[0x0]
80003df6:	f0 1f 00 d3 	mcall	80004140 <phy_rx_func+0xe0c>
80003dfa:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003dfc:	c0 71       	brne	80003e0a <phy_rx_func+0xad6>
							{
								RxMediaState = WAITINGABAB;
80003dfe:	30 09       	mov	r9,0
80003e00:	fe f8 03 64 	ld.w	r8,pc[868]
80003e04:	91 09       	st.w	r8[0x0],r9
80003e06:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003e0a:	fe f9 03 62 	ld.w	r9,pc[866]
80003e0e:	72 08       	ld.w	r8,r9[0x0]
80003e10:	20 18       	sub	r8,1
80003e12:	93 08       	st.w	r9[0x0],r8
80003e14:	c0 71       	brne	80003e22 <phy_rx_func+0xaee>
							RxMediaState = WAITINGABAB;
80003e16:	30 09       	mov	r9,0
80003e18:	fe f8 03 4c 	ld.w	r8,pc[844]
80003e1c:	91 09       	st.w	r8[0x0],r9
80003e1e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[1];//2
80003e22:	fe f8 03 5e 	ld.w	r8,pc[862]
80003e26:	fe f9 03 3a 	ld.w	r9,pc[826]
80003e2a:	72 0a       	ld.w	r10,r9[0x0]
80003e2c:	70 09       	ld.w	r9,r8[0x0]
80003e2e:	ef 3b 00 09 	ld.ub	r11,r7[9]
80003e32:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003e36:	70 09       	ld.w	r9,r8[0x0]
80003e38:	2f f9       	sub	r9,-1
80003e3a:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003e3c:	e0 49 01 ff 	cp.w	r9,511
80003e40:	e0 88 00 16 	brls	80003e6c <phy_rx_func+0xb38>
						{
							RxAMBE_IsFillingNext8 = 0;
80003e44:	30 09       	mov	r9,0
80003e46:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003e48:	fe f6 03 18 	ld.w	r6,pc[792]
80003e4c:	6c 0c       	ld.w	r12,r6[0x0]
80003e4e:	f0 1f 00 cf 	mcall	80004188 <phy_rx_func+0xe54>
							AMBE_payload_ptr = get_payload_idle_isr();
80003e52:	fe f8 03 06 	ld.w	r8,pc[774]
80003e56:	70 0c       	ld.w	r12,r8[0x0]
80003e58:	f0 1f 00 ba 	mcall	80004140 <phy_rx_func+0xe0c>
80003e5c:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003e5e:	c0 71       	brne	80003e6c <phy_rx_func+0xb38>
							{
								RxMediaState = WAITINGABAB;
80003e60:	30 09       	mov	r9,0
80003e62:	fe f8 03 02 	ld.w	r8,pc[770]
80003e66:	91 09       	st.w	r8[0x0],r9
80003e68:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003e6c:	fe f9 03 00 	ld.w	r9,pc[768]
80003e70:	72 08       	ld.w	r8,r9[0x0]
80003e72:	20 18       	sub	r8,1
80003e74:	93 08       	st.w	r9[0x0],r8
80003e76:	c0 71       	brne	80003e84 <phy_rx_func+0xb50>
							RxMediaState = WAITINGABAB;
80003e78:	30 09       	mov	r9,0
80003e7a:	fe f8 02 ea 	ld.w	r8,pc[746]
80003e7e:	91 09       	st.w	r8[0x0],r9
80003e80:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//3
80003e84:	fe f8 02 fc 	ld.w	r8,pc[764]
80003e88:	fe f9 02 d8 	ld.w	r9,pc[728]
80003e8c:	72 0a       	ld.w	r10,r9[0x0]
80003e8e:	70 09       	ld.w	r9,r8[0x0]
80003e90:	ef 3b 00 0a 	ld.ub	r11,r7[10]
80003e94:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003e98:	70 09       	ld.w	r9,r8[0x0]
80003e9a:	2f f9       	sub	r9,-1
80003e9c:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003e9e:	e0 49 01 ff 	cp.w	r9,511
80003ea2:	e0 88 00 16 	brls	80003ece <phy_rx_func+0xb9a>
						{
							RxAMBE_IsFillingNext8 = 0;
80003ea6:	30 09       	mov	r9,0
80003ea8:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003eaa:	fe f6 02 b6 	ld.w	r6,pc[694]
80003eae:	6c 0c       	ld.w	r12,r6[0x0]
80003eb0:	f0 1f 00 b6 	mcall	80004188 <phy_rx_func+0xe54>
							AMBE_payload_ptr = get_payload_idle_isr();
80003eb4:	fe f8 02 a4 	ld.w	r8,pc[676]
80003eb8:	70 0c       	ld.w	r12,r8[0x0]
80003eba:	f0 1f 00 a2 	mcall	80004140 <phy_rx_func+0xe0c>
80003ebe:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003ec0:	c0 71       	brne	80003ece <phy_rx_func+0xb9a>
							{
								RxMediaState = WAITINGABAB;
80003ec2:	30 09       	mov	r9,0
80003ec4:	fe f8 02 a0 	ld.w	r8,pc[672]
80003ec8:	91 09       	st.w	r8[0x0],r9
80003eca:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003ece:	fe f9 02 9e 	ld.w	r9,pc[670]
80003ed2:	72 08       	ld.w	r8,r9[0x0]
80003ed4:	20 18       	sub	r8,1
80003ed6:	93 08       	st.w	r9[0x0],r8
80003ed8:	c0 71       	brne	80003ee6 <phy_rx_func+0xbb2>
							RxMediaState = WAITINGABAB;
80003eda:	30 09       	mov	r9,0
80003edc:	fe f8 02 88 	ld.w	r8,pc[648]
80003ee0:	91 09       	st.w	r8[0x0],r9
80003ee2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//4
80003ee6:	fe f8 02 9a 	ld.w	r8,pc[666]
80003eea:	fe f9 02 76 	ld.w	r9,pc[630]
80003eee:	72 0a       	ld.w	r10,r9[0x0]
80003ef0:	70 09       	ld.w	r9,r8[0x0]
80003ef2:	ef 3b 00 0b 	ld.ub	r11,r7[11]
80003ef6:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003efa:	70 09       	ld.w	r9,r8[0x0]
80003efc:	2f f9       	sub	r9,-1
80003efe:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003f00:	e0 49 01 ff 	cp.w	r9,511
80003f04:	e0 88 00 16 	brls	80003f30 <phy_rx_func+0xbfc>
						{
							RxAMBE_IsFillingNext8 = 0;
80003f08:	30 09       	mov	r9,0
80003f0a:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003f0c:	fe f6 02 54 	ld.w	r6,pc[596]
80003f10:	6c 0c       	ld.w	r12,r6[0x0]
80003f12:	f0 1f 00 9e 	mcall	80004188 <phy_rx_func+0xe54>
							AMBE_payload_ptr = get_payload_idle_isr();
80003f16:	fe f8 02 42 	ld.w	r8,pc[578]
80003f1a:	70 0c       	ld.w	r12,r8[0x0]
80003f1c:	f0 1f 00 89 	mcall	80004140 <phy_rx_func+0xe0c>
80003f20:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003f22:	c0 71       	brne	80003f30 <phy_rx_func+0xbfc>
							{
								RxMediaState = WAITINGABAB;
80003f24:	30 09       	mov	r9,0
80003f26:	fe f8 02 3e 	ld.w	r8,pc[574]
80003f2a:	91 09       	st.w	r8[0x0],r9
80003f2c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003f30:	fe f9 02 3c 	ld.w	r9,pc[572]
80003f34:	72 08       	ld.w	r8,r9[0x0]
80003f36:	20 18       	sub	r8,1
80003f38:	93 08       	st.w	r9[0x0],r8
80003f3a:	c0 71       	brne	80003f48 <phy_rx_func+0xc14>
							RxMediaState = WAITINGABAB;
80003f3c:	30 09       	mov	r9,0
80003f3e:	fe f8 02 26 	ld.w	r8,pc[550]
80003f42:	91 09       	st.w	r8[0x0],r9
80003f44:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//5
80003f48:	fe f8 02 38 	ld.w	r8,pc[568]
80003f4c:	fe f9 02 14 	ld.w	r9,pc[532]
80003f50:	72 0a       	ld.w	r10,r9[0x0]
80003f52:	70 09       	ld.w	r9,r8[0x0]
80003f54:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80003f58:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003f5c:	70 09       	ld.w	r9,r8[0x0]
80003f5e:	2f f9       	sub	r9,-1
80003f60:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003f62:	e0 49 01 ff 	cp.w	r9,511
80003f66:	e0 88 00 13 	brls	80003f8c <phy_rx_func+0xc58>
						{
							RxAMBE_IsFillingNext8 = 0;
80003f6a:	30 09       	mov	r9,0
80003f6c:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003f6e:	4f d6       	lddpc	r6,80004160 <phy_rx_func+0xe2c>
80003f70:	6c 0c       	ld.w	r12,r6[0x0]
80003f72:	f0 1f 00 86 	mcall	80004188 <phy_rx_func+0xe54>
							AMBE_payload_ptr = get_payload_idle_isr();
80003f76:	4f 98       	lddpc	r8,80004158 <phy_rx_func+0xe24>
80003f78:	70 0c       	ld.w	r12,r8[0x0]
80003f7a:	f0 1f 00 72 	mcall	80004140 <phy_rx_func+0xe0c>
80003f7e:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003f80:	c0 61       	brne	80003f8c <phy_rx_func+0xc58>
							{
								RxMediaState = WAITINGABAB;
80003f82:	30 09       	mov	r9,0
80003f84:	4f 88       	lddpc	r8,80004164 <phy_rx_func+0xe30>
80003f86:	91 09       	st.w	r8[0x0],r9
80003f88:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003f8c:	4f 89       	lddpc	r9,8000416c <phy_rx_func+0xe38>
80003f8e:	72 08       	ld.w	r8,r9[0x0]
80003f90:	20 18       	sub	r8,1
80003f92:	93 08       	st.w	r9[0x0],r8
80003f94:	c0 61       	brne	80003fa0 <phy_rx_func+0xc6c>
							RxMediaState = WAITINGABAB;
80003f96:	30 09       	mov	r9,0
80003f98:	4f 38       	lddpc	r8,80004164 <phy_rx_func+0xe30>
80003f9a:	91 09       	st.w	r8[0x0],r9
80003f9c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[5];//6
80003fa0:	4f 88       	lddpc	r8,80004180 <phy_rx_func+0xe4c>
80003fa2:	4f 09       	lddpc	r9,80004160 <phy_rx_func+0xe2c>
80003fa4:	72 0a       	ld.w	r10,r9[0x0]
80003fa6:	70 09       	ld.w	r9,r8[0x0]
80003fa8:	ef 3b 00 0d 	ld.ub	r11,r7[13]
80003fac:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003fb0:	70 09       	ld.w	r9,r8[0x0]
80003fb2:	2f f9       	sub	r9,-1
80003fb4:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003fb6:	e0 49 01 ff 	cp.w	r9,511
80003fba:	e0 88 00 13 	brls	80003fe0 <phy_rx_func+0xcac>
						{
							RxAMBE_IsFillingNext8 = 0;
80003fbe:	30 09       	mov	r9,0
80003fc0:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003fc2:	4e 86       	lddpc	r6,80004160 <phy_rx_func+0xe2c>
80003fc4:	6c 0c       	ld.w	r12,r6[0x0]
80003fc6:	f0 1f 00 71 	mcall	80004188 <phy_rx_func+0xe54>
							AMBE_payload_ptr = get_payload_idle_isr();
80003fca:	4e 48       	lddpc	r8,80004158 <phy_rx_func+0xe24>
80003fcc:	70 0c       	ld.w	r12,r8[0x0]
80003fce:	f0 1f 00 5d 	mcall	80004140 <phy_rx_func+0xe0c>
80003fd2:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003fd4:	c0 61       	brne	80003fe0 <phy_rx_func+0xcac>
							{
								RxMediaState = WAITINGABAB;
80003fd6:	30 09       	mov	r9,0
80003fd8:	4e 38       	lddpc	r8,80004164 <phy_rx_func+0xe30>
80003fda:	91 09       	st.w	r8[0x0],r9
80003fdc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003fe0:	4e 39       	lddpc	r9,8000416c <phy_rx_func+0xe38>
80003fe2:	72 08       	ld.w	r8,r9[0x0]
80003fe4:	20 18       	sub	r8,1
80003fe6:	93 08       	st.w	r9[0x0],r8
80003fe8:	c0 61       	brne	80003ff4 <phy_rx_func+0xcc0>
							RxMediaState = WAITINGABAB;
80003fea:	30 09       	mov	r9,0
80003fec:	4d e8       	lddpc	r8,80004164 <phy_rx_func+0xe30>
80003fee:	91 09       	st.w	r8[0x0],r9
80003ff0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//7
80003ff4:	4e 38       	lddpc	r8,80004180 <phy_rx_func+0xe4c>
80003ff6:	4d b9       	lddpc	r9,80004160 <phy_rx_func+0xe2c>
80003ff8:	72 0a       	ld.w	r10,r9[0x0]
80003ffa:	70 09       	ld.w	r9,r8[0x0]
80003ffc:	ef 3b 00 0e 	ld.ub	r11,r7[14]
80004000:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80004004:	70 09       	ld.w	r9,r8[0x0]
80004006:	2f f9       	sub	r9,-1
80004008:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000400a:	e0 49 01 ff 	cp.w	r9,511
8000400e:	e0 88 00 13 	brls	80004034 <phy_rx_func+0xd00>
						{
							RxAMBE_IsFillingNext8 = 0;
80004012:	30 09       	mov	r9,0
80004014:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80004016:	4d 37       	lddpc	r7,80004160 <phy_rx_func+0xe2c>
80004018:	6e 0c       	ld.w	r12,r7[0x0]
8000401a:	f0 1f 00 5c 	mcall	80004188 <phy_rx_func+0xe54>
							AMBE_payload_ptr = get_payload_idle_isr();
8000401e:	4c f8       	lddpc	r8,80004158 <phy_rx_func+0xe24>
80004020:	70 0c       	ld.w	r12,r8[0x0]
80004022:	f0 1f 00 48 	mcall	80004140 <phy_rx_func+0xe0c>
80004026:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
80004028:	c0 61       	brne	80004034 <phy_rx_func+0xd00>
							{
								RxMediaState = WAITINGABAB;
8000402a:	30 09       	mov	r9,0
8000402c:	4c e8       	lddpc	r8,80004164 <phy_rx_func+0xe30>
8000402e:	91 09       	st.w	r8[0x0],r9
80004030:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80004034:	4c e9       	lddpc	r9,8000416c <phy_rx_func+0xe38>
80004036:	72 08       	ld.w	r8,r9[0x0]
80004038:	20 18       	sub	r8,1
8000403a:	93 08       	st.w	r9[0x0],r8
8000403c:	c0 61       	brne	80004048 <phy_rx_func+0xd14>
							RxMediaState = WAITINGABAB;
8000403e:	30 09       	mov	r9,0
80004040:	4c 98       	lddpc	r8,80004164 <phy_rx_func+0xe30>
80004042:	91 09       	st.w	r8[0x0],r9
80004044:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						//AMBE Vocoder Bits Stream(bit59~63),
						if ((RxBytesWaiting -= 1) <= 0){
80004048:	20 18       	sub	r8,1
8000404a:	4c 99       	lddpc	r9,8000416c <phy_rx_func+0xe38>
8000404c:	93 08       	st.w	r9[0x0],r8
8000404e:	58 08       	cp.w	r8,0
80004050:	c6 a1       	brne	80004124 <phy_rx_func+0xdf0>
							
							//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
							//or discard it to reduce payload size.
							
							RxMediaState = WAITINGABAB;
80004052:	30 09       	mov	r9,0
80004054:	4c 48       	lddpc	r8,80004164 <phy_rx_func+0xe30>
80004056:	91 09       	st.w	r8[0x0],r9
80004058:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
					}
					else if ((Item_ID == 0x04)  ||  (Item_ID == 0x03))//Unknown type data directly back hair
8000405c:	4c 78       	lddpc	r8,80004178 <phy_rx_func+0xe44>
8000405e:	11 89       	ld.ub	r9,r8[0x0]
80004060:	30 48       	mov	r8,4
80004062:	f0 09 18 00 	cp.b	r9,r8
80004066:	c0 70       	breq	80004074 <phy_rx_func+0xd40>
80004068:	4c 48       	lddpc	r8,80004178 <phy_rx_func+0xe44>
8000406a:	11 89       	ld.ub	r9,r8[0x0]
8000406c:	30 38       	mov	r8,3
8000406e:	f0 09 18 00 	cp.b	r9,r8
80004072:	c1 01       	brne	80004092 <phy_rx_func+0xd5e>
					{
						AMBE_HT[0] = payload_rx_channel->dword[0];
80004074:	6e 29       	ld.w	r9,r7[0x8]
80004076:	4c c8       	lddpc	r8,800041a4 <phy_rx_func+0xe70>
80004078:	91 09       	st.w	r8[0x0],r9
						AMBE_HT[1] = payload_rx_channel->dword[1];				
8000407a:	6e 39       	ld.w	r9,r7[0xc]
8000407c:	91 19       	st.w	r8[0x4],r9
						
						if ((RxBytesWaiting -= 8) <= 0)//Consider two cases 0xABCDC014 and 0xABCDC010
8000407e:	4b c9       	lddpc	r9,8000416c <phy_rx_func+0xe38>
80004080:	72 08       	ld.w	r8,r9[0x0]
80004082:	20 88       	sub	r8,8
80004084:	93 08       	st.w	r9[0x0],r8
80004086:	c4 f1       	brne	80004124 <phy_rx_func+0xdf0>
						{
					
							RxBytesWaiting = 0;
80004088:	93 08       	st.w	r9[0x0],r8
							RxMediaState = WAITINGABAB;
8000408a:	4b 79       	lddpc	r9,80004164 <phy_rx_func+0xe30>
8000408c:	93 08       	st.w	r9[0x0],r8
8000408e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					
					else
					{
						
						RxMediaState  = WAITINGABAB;
80004092:	30 09       	mov	r9,0
80004094:	4b 48       	lddpc	r8,80004164 <phy_rx_func+0xe30>
80004096:	91 09       	st.w	r8[0x0],r9
80004098:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
			break;//End of READING_AMBE_MEDIA.

        case READING_AMBE_AUX:
			
				Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[0];
8000409c:	4c 08       	lddpc	r8,8000419c <phy_rx_func+0xe68>
8000409e:	70 09       	ld.w	r9,r8[0x0]
800040a0:	8e 4b       	ld.sh	r11,r7[0x8]
800040a2:	4c 0a       	lddpc	r10,800041a0 <phy_rx_func+0xe6c>
800040a4:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
				RxData_IsFillingNext16 += 1;
800040a8:	2f f9       	sub	r9,-1
800040aa:	91 09       	st.w	r8[0x0],r9
			
				if ((Item_Length -= 2) <= 0)
800040ac:	4b 48       	lddpc	r8,8000417c <phy_rx_func+0xe48>
800040ae:	70 09       	ld.w	r9,r8[0x0]
800040b0:	20 29       	sub	r9,2
800040b2:	91 09       	st.w	r8[0x0],r9
800040b4:	70 08       	ld.w	r8,r8[0x0]
800040b6:	58 08       	cp.w	r8,0
800040b8:	c3 01       	brne	80004118 <phy_rx_func+0xde4>
				{
					RxData_IsFillingNext16 = 0;
800040ba:	30 09       	mov	r9,0
800040bc:	4b 88       	lddpc	r8,8000419c <phy_rx_func+0xe68>
800040be:	91 09       	st.w	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
800040c0:	8e 59       	ld.sh	r9,r7[0xa]
800040c2:	fe 78 82 12 	mov	r8,-32238
800040c6:	f0 09 19 00 	cp.h	r9,r8
800040ca:	c2 21       	brne	8000410e <phy_rx_func+0xdda>
				
					if (payload_rx_channel->word[1] == 0x8212 )
					{
						//Item_ID = Vocoder_Bit_Stream_Parameter;
						//Vocoder Bits Stream Parameter
						VF_SN = payload_rx_channel->byte[5];//This parameter is very important to the loop back Radio, as a reference.
800040cc:	ef 3c 00 0d 	ld.ub	r12,r7[13]
800040d0:	4a f8       	lddpc	r8,8000418c <phy_rx_func+0xe58>
800040d2:	b0 8c       	st.b	r8[0x0],r12
							
						VBSP_data[0] = payload_rx_channel->word[1];
800040d4:	8e 59       	ld.sh	r9,r7[0xa]
800040d6:	4a f8       	lddpc	r8,80004190 <phy_rx_func+0xe5c>
800040d8:	b0 09       	st.h	r8[0x0],r9
						VBSP_data[1] = payload_rx_channel->word[2];
800040da:	8e 69       	ld.sh	r9,r7[0xc]
800040dc:	b0 19       	st.h	r8[0x2],r9
							
						m_RxBurstType = CalculateBurst(VF_SN);
800040de:	f0 1f 00 2e 	mcall	80004194 <phy_rx_func+0xe60>
800040e2:	4a 28       	lddpc	r8,80004168 <phy_rx_func+0xe34>
800040e4:	91 0c       	st.w	r8[0x0],r12
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
800040e6:	ef 39 00 0f 	ld.ub	r9,r7[15]
800040ea:	3f 38       	mov	r8,-13
800040ec:	f0 09 18 00 	cp.b	r9,r8
800040f0:	c0 a1       	brne	80004104 <phy_rx_func+0xdd0>
							
						m_RxBurstType = CalculateBurst(VF_SN);
						
						if (payload_rx_channel->byte[7] == Pre_Voice_Decoder_Data)//0xF3
						{
							Item_ID = Pre_Voice_Decoder_Data;
800040f2:	10 99       	mov	r9,r8
800040f4:	4a 18       	lddpc	r8,80004178 <phy_rx_func+0xe44>
800040f6:	b0 89       	st.b	r8[0x0],r9
							RxBytesWaiting = ((payload_rx_channel->dword[1] & 0x00007F00) >>24);//Test calculations are correct; 8
800040f8:	30 09       	mov	r9,0
800040fa:	49 d8       	lddpc	r8,8000416c <phy_rx_func+0xe38>
800040fc:	91 09       	st.w	r8[0x0],r9
							AMBE_rx_flag = 1;//AMBE
800040fe:	30 19       	mov	r9,1
80004100:	4a b8       	lddpc	r8,800041ac <phy_rx_func+0xe78>
80004102:	b0 89       	st.b	r8[0x0],r9
						}
							
						RxMediaState = READING_AMBE_MEDIA;//Jump
80004104:	30 49       	mov	r9,4
80004106:	49 88       	lddpc	r8,80004164 <phy_rx_func+0xe30>
80004108:	91 09       	st.w	r8[0x0],r9
8000410a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					else
					{
						RxMediaState = WAITINGABAB;//Jump
8000410e:	30 09       	mov	r9,0
80004110:	49 58       	lddpc	r8,80004164 <phy_rx_func+0xe30>
80004112:	91 09       	st.w	r8[0x0],r9
80004114:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}

				}
				else
				{//
					logFromISR("\n\r Radio Internal parameter length error \n\r");
80004118:	4a ac       	lddpc	r12,800041c0 <phy_rx_func+0xe8c>
8000411a:	f0 1f 00 17 	mcall	80004174 <phy_rx_func+0xe40>
					RxMediaState = WAITINGABAB;//Jump
8000411e:	30 09       	mov	r9,0
80004120:	49 18       	lddpc	r8,80004164 <phy_rx_func+0xe30>
80004122:	91 09       	st.w	r8[0x0],r9
80004124:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80004128:	00 00       	add	r0,r0
8000412a:	0a c0       	st.b	r5++,r0
8000412c:	00 00       	add	r0,r0
8000412e:	0a b4       	st.h	r5++,r4
80004130:	00 00       	add	r0,r0
80004132:	0a 84       	andn	r4,r5
80004134:	00 00       	add	r0,r0
80004136:	0a 60       	and	r0,r5
80004138:	00 00       	add	r0,r0
8000413a:	0a e6       	st.h	--r5,r6
8000413c:	00 00       	add	r0,r0
8000413e:	0a 98       	mov	r8,r5
80004140:	80 00       	ld.sh	r0,r0[0x0]
80004142:	2b 78       	sub	r8,-73
80004144:	00 00       	add	r0,r0
80004146:	0a ac       	st.w	r5++,r12
80004148:	80 00       	ld.sh	r0,r0[0x0]
8000414a:	57 f0       	stdsp	sp[0x1fc],r0
8000414c:	00 00       	add	r0,r0
8000414e:	0a dc       	st.w	--r5,r12
80004150:	80 00       	ld.sh	r0,r0[0x0]
80004152:	2a c4       	sub	r4,-84
80004154:	00 00       	add	r0,r0
80004156:	0a 94       	mov	r4,r5
80004158:	00 00       	add	r0,r0
8000415a:	0a 74       	tst	r4,r5
8000415c:	00 00       	add	r0,r0
8000415e:	0a bc       	st.h	r5++,r12
80004160:	00 00       	add	r0,r0
80004162:	0a ec       	st.h	--r5,r12
80004164:	00 00       	add	r0,r0
80004166:	0a 64       	and	r4,r5
80004168:	00 00       	add	r0,r0
8000416a:	0a 6c       	and	r12,r5
8000416c:	00 00       	add	r0,r0
8000416e:	0a d4       	st.w	--r5,r4
80004170:	80 01       	ld.sh	r1,r0[0x0]
80004172:	59 b8       	cp.w	r8,27
80004174:	80 00       	ld.sh	r0,r0[0x0]
80004176:	68 e8       	ld.w	r8,r4[0x38]
80004178:	00 00       	add	r0,r0
8000417a:	0a cc       	st.b	r5++,r12
8000417c:	00 00       	add	r0,r0
8000417e:	0a 88       	andn	r8,r5
80004180:	00 00       	add	r0,r0
80004182:	0a c4       	st.b	r5++,r4
80004184:	80 00       	ld.sh	r0,r0[0x0]
80004186:	72 04       	ld.w	r4,r9[0x0]
80004188:	80 00       	ld.sh	r0,r0[0x0]
8000418a:	32 d4       	mov	r4,45
8000418c:	00 00       	add	r0,r0
8000418e:	0a 41       	or	r1,r5
80004190:	00 00       	add	r0,r0
80004192:	0e c4       	st.b	r7++,r4
80004194:	80 00       	ld.sh	r0,r0[0x0]
80004196:	29 98       	sub	r8,-103
80004198:	80 01       	ld.sh	r1,r0[0x0]
8000419a:	59 d0       	cp.w	r0,29
8000419c:	00 00       	add	r0,r0
8000419e:	0a d0       	st.w	--r5,r0
800041a0:	00 00       	add	r0,r0
800041a2:	0d c8       	ld.ub	r8,r6[0x4]
800041a4:	00 00       	add	r0,r0
800041a6:	0a 8c       	andn	r12,r5
800041a8:	00 00       	add	r0,r0
800041aa:	0a 40       	or	r0,r5
800041ac:	00 00       	add	r0,r0
800041ae:	0a 38       	cp.w	r8,r5
800041b0:	00 00       	add	r0,r0
800041b2:	0a e8       	st.h	--r5,r8
800041b4:	00 00       	add	r0,r0
800041b6:	0a c8       	st.b	r5++,r8
800041b8:	00 00       	add	r0,r0
800041ba:	0a 4d       	or	sp,r5
800041bc:	00 00       	add	r0,r0
800041be:	0d c0       	ld.ub	r0,r6[0x4]
800041c0:	80 01       	ld.sh	r1,r0[0x0]
800041c2:	59 e4       	cp.w	r4,30

800041c4 <pdca_int_handler>:
    void (*phy_rx_exec)(void *)--callback function for receive SSC data 
Called By: interrupt
*/
__attribute__((__interrupt__))
static void pdca_int_handler(void)
{
800041c4:	d4 01       	pushm	lr
    
	//intStartCount = Get_system_register(AVR32_COUNT);
	
	/*Toggle Index*/
    BufferIndex ^= 0x01;
800041c6:	49 88       	lddpc	r8,80004224 <pdca_int_handler+0x60>
800041c8:	11 89       	ld.ub	r9,r8[0x0]
800041ca:	ec 19 00 01 	eorl	r9,0x1
800041ce:	b0 89       	st.b	r8[0x0],r9
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);
800041d0:	11 89       	ld.ub	r9,r8[0x0]
800041d2:	a5 69       	lsl	r9,0x4
800041d4:	2f c9       	sub	r9,-4
800041d6:	49 5a       	lddpc	r10,80004228 <pdca_int_handler+0x64>
800041d8:	14 09       	add	r9,r10
	
	/*Toggle Index*/
    BufferIndex ^= 0x01;
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
800041da:	fe 7a 00 40 	mov	r10,-65472
800041de:	95 39       	st.w	r10[0xc],r9
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
800041e0:	30 39       	mov	r9,3
800041e2:	95 49       	st.w	r10[0x10],r9

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);
800041e4:	11 8a       	ld.ub	r10,r8[0x0]
800041e6:	a5 6a       	lsl	r10,0x4
800041e8:	2f ca       	sub	r10,-4
800041ea:	49 18       	lddpc	r8,8000422c <pdca_int_handler+0x68>
800041ec:	10 0a       	add	r10,r8
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
800041ee:	fe 78 00 00 	mov	r8,-65536
800041f2:	91 3a       	st.w	r8[0xc],r10
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
800041f4:	91 49       	st.w	r8[0x10],r9
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr;
800041f6:	70 b8       	ld.w	r8,r8[0x2c]
	
	/*receive SSC data*/
    if(phy_rx_exec != NULL)phy_rx_exec((void *)&RxBuffer[BufferIndex]);
800041f8:	48 e8       	lddpc	r8,80004230 <pdca_int_handler+0x6c>
800041fa:	70 08       	ld.w	r8,r8[0x0]
800041fc:	58 08       	cp.w	r8,0
800041fe:	c0 70       	breq	8000420c <pdca_int_handler+0x48>
80004200:	48 99       	lddpc	r9,80004224 <pdca_int_handler+0x60>
80004202:	13 89       	ld.ub	r9,r9[0x0]
80004204:	a5 69       	lsl	r9,0x4
80004206:	48 ac       	lddpc	r12,8000422c <pdca_int_handler+0x68>
80004208:	12 0c       	add	r12,r9
8000420a:	5d 18       	icall	r8

    /*transmit SSC data*/

	if(phy_tx_exec != NULL)phy_tx_exec((void *)&TxBuffer[BufferIndex]);//phy_tx_func, phy_rx_func
8000420c:	48 a8       	lddpc	r8,80004234 <pdca_int_handler+0x70>
8000420e:	70 08       	ld.w	r8,r8[0x0]
80004210:	58 08       	cp.w	r8,0
80004212:	c0 70       	breq	80004220 <pdca_int_handler+0x5c>
80004214:	48 49       	lddpc	r9,80004224 <pdca_int_handler+0x60>
80004216:	13 89       	ld.ub	r9,r9[0x0]
80004218:	a5 69       	lsl	r9,0x4
8000421a:	48 4c       	lddpc	r12,80004228 <pdca_int_handler+0x64>
8000421c:	12 0c       	add	r12,r9
8000421e:	5d 18       	icall	r8

	
	//intDuration = Get_system_register(AVR32_COUNT) - intStartCount;
	
	
}/*End of pdca_int_handler.*/
80004220:	d4 02       	popm	lr
80004222:	d6 03       	rete
80004224:	00 00       	add	r0,r0
80004226:	40 cc       	lddsp	r12,sp[0x30]
80004228:	00 00       	add	r0,r0
8000422a:	40 f4       	lddsp	r4,sp[0x3c]
8000422c:	00 00       	add	r0,r0
8000422e:	40 d4       	lddsp	r4,sp[0x34]
80004230:	00 00       	add	r0,r0
80004232:	0a f0       	st.b	--r5,r0
80004234:	00 00       	add	r0,r0
80004236:	0a f4       	st.b	--r5,r4

80004238 <local_start_SSC>:
void local_start_SSC(void)
{
    /*Assign GPIO to SSC.
    gpio_enable_module
    gpio_enable_module_pin*/
    AVR32_GPIO.port[1].pmr0c = 0x00000DC0;
80004238:	fe 78 10 00 	mov	r8,-61440
8000423c:	e0 69 0d c0 	mov	r9,3520
80004240:	f1 49 01 18 	st.w	r8[280],r9
    AVR32_GPIO.port[1].pmr1c = 0x00000DC0;
80004244:	f1 49 01 28 	st.w	r8[296],r9
    AVR32_GPIO.port[1].gperc = 0x00000DC0;
80004248:	f1 49 01 08 	st.w	r8[264],r9

    /*Software reset SSC*/
    (&AVR32_SSC)->cr = AVR32_SSC_CR_SWRST_MASK;
8000424c:	fe 78 34 00 	mov	r8,-52224
80004250:	e0 69 80 00 	mov	r9,32768
80004254:	91 09       	st.w	r8[0x0],r9
    (&AVR32_SSC)->cmr 
80004256:	30 09       	mov	r9,0
80004258:	91 19       	st.w	r8[0x4],r9
                     = AVR32_SSC_CMR_DIV_NOT_ACTIVE << AVR32_SSC_CMR_DIV_OFFSET;

    /*For Slave*/
    (&AVR32_SSC)->tcmr =
8000425a:	e0 69 04 21 	mov	r9,1057
8000425e:	ea 19 3f 20 	orh	r9,0x3f20
80004262:	91 69       	st.w	r8[0x18],r9
	    | 32 << AVR32_SSC_TCMR_STTDLY_OFFSET
	    | 63 << AVR32_SSC_TCMR_PERIOD_OFFSET;


    /*For Slave*/
    (&AVR32_SSC)->tfmr = 31 << AVR32_SSC_TFMR_DATLEN_OFFSET 
80004264:	e0 69 02 9f 	mov	r9,671
80004268:	ea 19 01 00 	orh	r9,0x100
8000426c:	91 79       	st.w	r8[0x1c],r9
	    | 0 << AVR32_SSC_TFMR_FSDEN_OFFSET
	    | 1 << AVR32_SSC_TFMR_FSEDGE_OFFSET;

	/*For Slave*/

	(&AVR32_SSC)->rcmr = AVR32_SSC_RCMR_CKS_RK_PIN << AVR32_SSC_RCMR_CKS_OFFSET
8000426e:	e0 6a 04 02 	mov	r10,1026
80004272:	ea 1a 3f 20 	orh	r10,0x3f20
80004276:	91 4a       	st.w	r8[0x10],r10
	    | 0 << AVR32_SSC_RCMR_STOP_OFFSET
	    | 32 << AVR32_SSC_RCMR_STTDLY_OFFSET
	    | 63 << AVR32_SSC_RCMR_PERIOD_OFFSET;

	/*For Slave*/
	(&AVR32_SSC)->rfmr = 31 << AVR32_SSC_RFMR_DATLEN_OFFSET
80004278:	91 59       	st.w	r8[0x14],r9
	    | 1 << AVR32_SSC_RFMR_MSBF_OFFSET
	    | 2 << AVR32_SSC_RFMR_DATNB_OFFSET
	    | 0 << AVR32_SSC_RFMR_FSLEN_OFFSET
	    | AVR32_SSC_RFMR_FSOS_INPUT_ONLY << AVR32_SSC_RFMR_FSOS_OFFSET
	    | 1 << AVR32_SSC_RFMR_FSEDGE_OFFSET;
}/*End of local_start_SSC.*/
8000427a:	5e fc       	retal	r12

8000427c <local_start_PDC>:
Function: local_start_PDC
Description: none
Called By: void ssc_init(void) -- ssc.c
*/
void local_start_PDC(void)
{
8000427c:	d4 01       	pushm	lr
    /*Toggle Index*/	
    BufferIndex = 1;
8000427e:	30 19       	mov	r9,1
80004280:	49 78       	lddpc	r8,800042dc <local_start_PDC+0x60>
80004282:	b0 89       	st.b	r8[0x0],r9
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
80004284:	fe 78 00 00 	mov	r8,-65536
80004288:	30 7b       	mov	r11,7
8000428a:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
8000428c:	70 b9       	ld.w	r9,r8[0x2c]
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
8000428e:	49 59       	lddpc	r9,800042e0 <local_start_PDC+0x64>
80004290:	f2 ca ff fc 	sub	r10,r9,-4
    BufferIndex = 1;
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
80004294:	91 0a       	st.w	r8[0x0],r10
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
80004296:	30 3a       	mov	r10,3
80004298:	91 2a       	st.w	r8[0x8],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
8000429a:	30 1c       	mov	r12,1
8000429c:	91 1c       	st.w	r8[0x4],r12
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
8000429e:	2e c9       	sub	r9,-20
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
800042a0:	91 39       	st.w	r8[0xc],r9
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
800042a2:	91 4a       	st.w	r8[0x10],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mr = AVR32_PDCA_WORD;
800042a4:	30 2c       	mov	r12,2
800042a6:	91 6c       	st.w	r8[0x18],r12

	TxBuffer[0].xnl_channel.dword = XNL_IDLE;
800042a8:	48 f9       	lddpc	r9,800042e4 <local_start_PDC+0x68>
800042aa:	e0 68 5a 5a 	mov	r8,23130
800042ae:	ea 18 ab cd 	orh	r8,0xabcd
800042b2:	93 18       	st.w	r9[0x4],r8
	TxBuffer[0].payload_channel.dword[0] = PAYLOADIDLE0;
800042b4:	93 28       	st.w	r9[0x8],r8
	TxBuffer[0].payload_channel.dword[1] = PAYLOADIDLE1;
800042b6:	30 0e       	mov	lr,0
800042b8:	93 3e       	st.w	r9[0xc],lr
	TxBuffer[1].xnl_channel.dword = XNL_IDLE;
800042ba:	93 58       	st.w	r9[0x14],r8
	TxBuffer[1].payload_channel.dword[0] = PAYLOADIDLE0;
800042bc:	93 68       	st.w	r9[0x18],r8
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;
800042be:	93 7e       	st.w	r9[0x1c],lr

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
800042c0:	fe 78 00 40 	mov	r8,-65472
800042c4:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
800042c6:	70 be       	ld.w	lr,r8[0x2c]
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
800042c8:	f2 ce ff fc 	sub	lr,r9,-4
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
800042cc:	91 0e       	st.w	r8[0x0],lr
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
800042ce:	91 2a       	st.w	r8[0x8],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
800042d0:	91 1b       	st.w	r8[0x4],r11
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
800042d2:	2e c9       	sub	r9,-20
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
800042d4:	91 39       	st.w	r8[0xc],r9
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
800042d6:	91 4a       	st.w	r8[0x10],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mr = AVR32_PDCA_WORD;
800042d8:	91 6c       	st.w	r8[0x18],r12
}/*End of local_start_PDC.*/
800042da:	d8 02       	popm	pc
800042dc:	00 00       	add	r0,r0
800042de:	40 cc       	lddsp	r12,sp[0x30]
800042e0:	00 00       	add	r0,r0
800042e2:	40 d4       	lddsp	r4,sp[0x34]
800042e4:	00 00       	add	r0,r0
800042e6:	40 f4       	lddsp	r4,sp[0x3c]

800042e8 <register_rx_tx_func>:
Description: register the rx function(callback function)
Called By: phy_init -- physical.c
*/
void register_rx_tx_func(void (*rx_exec)(void *),  void ( *tx_exec)(void *))
{
	 phy_rx_exec = rx_exec;
800042e8:	48 38       	lddpc	r8,800042f4 <register_rx_tx_func+0xc>
800042ea:	91 0c       	st.w	r8[0x0],r12
	 phy_tx_exec = tx_exec;//phy_tx_func, phy_rx_func
800042ec:	48 38       	lddpc	r8,800042f8 <register_rx_tx_func+0x10>
800042ee:	91 0b       	st.w	r8[0x0],r11
	 
}/*End of register_tx_rx_func.*/
800042f0:	5e fc       	retal	r12
800042f2:	00 00       	add	r0,r0
800042f4:	00 00       	add	r0,r0
800042f6:	0a f0       	st.b	--r5,r0
800042f8:	00 00       	add	r0,r0
800042fa:	0a f4       	st.b	--r5,r4

800042fc <ssc_init>:
    local_start_SSC -- ssc.c
    local_start_PDC -- ssc.c
Called By: phy_init -- physical.c
*/
void ssc_init(void)
{		
800042fc:	d4 01       	pushm	lr
    /*Set up PB03 to watch FS.*/
    AVR32_GPIO.port[1].oderc = 0x00000002;
800042fe:	fe 78 10 00 	mov	r8,-61440
80004302:	30 29       	mov	r9,2
80004304:	f1 49 01 48 	st.w	r8[328],r9
    AVR32_GPIO.port[1].gpers = 0x00000002;
80004308:	f1 49 01 04 	st.w	r8[260],r9

    /*Waits for radio to start making FSYNC.*/
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
8000430c:	10 99       	mov	r9,r8
8000430e:	f2 f8 01 60 	ld.w	r8,r9[352]
80004312:	e2 18 00 02 	andl	r8,0x2,COH
80004316:	cf c0       	breq	8000430e <ssc_init+0x12>
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
80004318:	fe 79 10 00 	mov	r9,-61440
8000431c:	f2 f8 01 60 	ld.w	r8,r9[352]
80004320:	e2 18 00 02 	andl	r8,0x2,COH
80004324:	cf c1       	brne	8000431c <ssc_init+0x20>
				
    INTC_register_interrupt (
80004326:	30 3a       	mov	r10,3
80004328:	36 0b       	mov	r11,96
8000432a:	48 bc       	lddpc	r12,80004354 <ssc_init+0x58>
8000432c:	f0 1f 00 0b 	mcall	80004358 <ssc_init+0x5c>
        , AVR32_PDCA_IRQ_0
        , AVR32_INTC_INT3
    );
				
    /*config the SSC*/
    local_start_SSC();
80004330:	f0 1f 00 0b 	mcall	8000435c <ssc_init+0x60>

    /*config the PDCA*/
    local_start_PDC();
80004334:	f0 1f 00 0b 	mcall	80004360 <ssc_init+0x64>
		
    /*Start the SSC Physical Layer.*/

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80004338:	fe 79 00 00 	mov	r9,-65536
8000433c:	30 18       	mov	r8,1
8000433e:	93 58       	st.w	r9[0x14],r8
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80004340:	fe 7a 00 40 	mov	r10,-65472
80004344:	95 58       	st.w	r10[0x14],r8
    (&AVR32_SSC)->cr = AVR32_SSC_CR_RXEN_MASK | AVR32_SSC_CR_TXEN_MASK;
80004346:	e0 6b 01 01 	mov	r11,257
8000434a:	fe 7a 34 00 	mov	r10,-52224
8000434e:	95 0b       	st.w	r10[0x0],r11
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->ier = 
80004350:	93 88       	st.w	r9[0x20],r8
                                                            AVR32_PDCA_RCZ_MASK;
}/*End of ssc_init.*/
80004352:	d8 02       	popm	pc
80004354:	80 00       	ld.sh	r0,r0[0x0]
80004356:	41 c4       	lddsp	r4,sp[0x70]
80004358:	80 00       	ld.sh	r0,r0[0x0]
8000435a:	4e 28       	lddpc	r8,800044e0 <xcmp_opcode_not_supported+0x1c>
8000435c:	80 00       	ld.sh	r0,r0[0x0]
8000435e:	42 38       	lddsp	r8,sp[0x8c]
80004360:	80 00       	ld.sh	r0,r0[0x0]
80004362:	42 7c       	lddsp	r12,sp[0x9c]

80004364 <xcmp_register_app_list>:
Calls: 
Called By: app_init -- app.c
*/
void xcmp_register_app_list(void * list)
{
	app_list = (app_exec_t *)list;
80004364:	48 28       	lddpc	r8,8000436c <xcmp_register_app_list+0x8>
80004366:	91 0c       	st.w	r8[0x0],r12
}
80004368:	5e fc       	retal	r12
8000436a:	00 00       	add	r0,r0
8000436c:	00 00       	add	r0,r0
8000436e:	41 14       	lddsp	r4,sp[0x44]

80004370 <xcmp_tx>:
Calls:   
	xnl_tx -- xnl.c
Called By: ...
*/
static void xcmp_tx( xcmp_fragment_t * xcmp, U8 payload_len)
{
80004370:	eb cd 40 80 	pushm	r7,lr
80004374:	fa cd 01 00 	sub	sp,sp,256
80004378:	16 97       	mov	r7,r11
	Length :xnl length + checksum
	= checksum + xnl header + xcmp opcode + xcmp payload
	= 0x02 + 0x0C + 0x02 + xcmp payload
	= 0x10 + xcmp payload
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | ( 0x10 + payload_len);
8000437a:	16 98       	mov	r8,r11
8000437c:	2f 08       	sub	r8,-16
8000437e:	af a8       	sbr	r8,0xe
80004380:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE; 
80004382:	3f f8       	mov	r8,-1
80004384:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG;
80004386:	30 b9       	mov	r9,11
80004388:	ba 29       	st.h	sp[0x4],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;	
8000438a:	ba 38       	st.h	sp[0x6],r8
	xnl_frame.xnl_header.destination = DEFAULT_VALUE;
8000438c:	ba 48       	st.h	sp[0x8],r8
	xnl_frame.xnl_header.source = DEFAULT_VALUE;	
8000438e:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80004390:	ba 68       	st.h	sp[0xc],r8
	
	/*insert xcmp frame data*/
	memcpy(&xnl_frame.xnl_payload.xnl_content_data_msg, xcmp, payload_len + 2);
80004392:	f6 ca ff fe 	sub	r10,r11,-2
80004396:	18 9b       	mov	r11,r12
80004398:	fa cc ff f0 	sub	r12,sp,-16
8000439c:	f0 1f 00 05 	mcall	800043b0 <xcmp_tx+0x40>
	xnl_frame.xnl_header.payload_length = payload_len + 2;	
800043a0:	2f e7       	sub	r7,-2
800043a2:	ba 77       	st.h	sp[0xe],r7
	
	/* send xnl frame*/	
	xnl_tx(&xnl_frame);
800043a4:	1a 9c       	mov	r12,sp
800043a6:	f0 1f 00 04 	mcall	800043b4 <xcmp_tx+0x44>
}
800043aa:	2c 0d       	sub	sp,-256
800043ac:	e3 cd 80 80 	ldm	sp++,r7,pc
800043b0:	80 00       	ld.sh	r0,r0[0x0]
800043b2:	70 bc       	ld.w	r12,r8[0x2c]
800043b4:	80 00       	ld.sh	r0,r0[0x0]
800043b6:	48 8c       	lddpc	r12,800043d4 <xcmp_exit_device_control_mode+0x1c>

800043b8 <xcmp_exit_device_control_mode>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_exit_device_control_mode(void)
{
800043b8:	d4 01       	pushm	lr
800043ba:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DEVICE_CONTROL_MODE;
800043be:	e0 68 04 21 	mov	r8,1057
800043c2:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceControlMode_req_t * ptr = (DeviceControlMode_req_t *)xcmp_farme.u8;
800043c4:	fa c8 ff fc 	sub	r8,sp,-4
	
	ptr->Function = DCM_EXIT;
800043c8:	30 09       	mov	r9,0
800043ca:	b0 89       	st.b	r8[0x0],r9
	ptr->ControlTypeSize = 1;
800043cc:	30 19       	mov	r9,1
800043ce:	b0 99       	st.b	r8[0x1],r9
	ptr->ControlType = 0x03;//DCM_SPEAKER_CTRL;
800043d0:	30 39       	mov	r9,3
800043d2:	b0 a9       	st.b	r8[0x2],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(DeviceControlMode_req_t));
800043d4:	30 3b       	mov	r11,3
800043d6:	fa cc ff fe 	sub	r12,sp,-2
800043da:	f0 1f 00 03 	mcall	800043e4 <xcmp_exit_device_control_mode+0x2c>
}
800043de:	2c dd       	sub	sp,-204
800043e0:	d8 02       	popm	pc
800043e2:	00 00       	add	r0,r0
800043e4:	80 00       	ld.sh	r0,r0[0x0]
800043e6:	43 70       	lddsp	r0,sp[0xdc]

800043e8 <xcmp_enter_device_control_mode>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_enter_device_control_mode(void)
{
800043e8:	d4 01       	pushm	lr
800043ea:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DEVICE_CONTROL_MODE;
800043ee:	e0 68 04 21 	mov	r8,1057
800043f2:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceControlMode_req_t * ptr = (DeviceControlMode_req_t *)xcmp_farme.u8;
800043f4:	fa c8 ff fc 	sub	r8,sp,-4
	
	ptr->Function = DCM_ENTER;
800043f8:	30 19       	mov	r9,1
800043fa:	b0 89       	st.b	r8[0x0],r9
	ptr->ControlTypeSize = 1;
800043fc:	b0 99       	st.b	r8[0x1],r9
	ptr->ControlType = 0x03;// 0xEB;//user-input
800043fe:	30 39       	mov	r9,3
80004400:	b0 a9       	st.b	r8[0x2],r9
	//ptr->ControlType = DCM_SPEAKER_CTRL;
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(DeviceControlMode_req_t));
80004402:	30 3b       	mov	r11,3
80004404:	fa cc ff fe 	sub	r12,sp,-2
80004408:	f0 1f 00 02 	mcall	80004410 <xcmp_enter_device_control_mode+0x28>
}
8000440c:	2c dd       	sub	sp,-204
8000440e:	d8 02       	popm	pc
80004410:	80 00       	ld.sh	r0,r0[0x0]
80004412:	43 70       	lddsp	r0,sp[0xdc]

80004414 <xcmp_audio_route_AMBE>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_audio_route_AMBE(void)
{
80004414:	d4 01       	pushm	lr
80004416:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | AUDIO_ROUTING_CONTROL;
8000441a:	e0 68 04 14 	mov	r8,1044
8000441e:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	AudioRoutingControl_req_t * ptr = (AudioRoutingControl_req_t *)xcmp_farme.u8;
80004420:	fa c8 ff fc 	sub	r8,sp,-4
	
	ptr->Function = Routing_Func_Update_Source;
80004424:	30 19       	mov	r9,1
80004426:	b0 89       	st.b	r8[0x0],r9
	
	
	unsigned short NumberofRoutings = 4;//2;
	ptr->NumberofRoutings[0] = (NumberofRoutings >> 8) & 0xFF;
80004428:	30 09       	mov	r9,0
8000442a:	b0 99       	st.b	r8[0x1],r9
	ptr->NumberofRoutings[1] =  NumberofRoutings & 0xFF;
8000442c:	30 49       	mov	r9,4
8000442e:	b0 a9       	st.b	r8[0x2],r9
	
	//ptr->RoutingData[0].audioInput = IN_Microphone;//Post_AMBE_Encoder;//IN_Pre_Speaker_Audio_Data;//IN_Microphone;//IN_Option_Board;
	//ptr->RoutingData[0].audioOutput = OUT_Option_Board;//Post_AMBE_Encoder;//OUT_Microphone_Data;//
	//
	ptr->RoutingData[0].audioInput = Post_AMBE_Encoder;//IN_Option_Board;
80004430:	30 fa       	mov	r10,15
80004432:	b0 ba       	st.b	r8[0x3],r10
	ptr->RoutingData[0].audioOutput = OUT_Option_Board;// OUT_Speaker;
80004434:	30 c9       	mov	r9,12
80004436:	b0 c9       	st.b	r8[0x4],r9
	ptr->RoutingData[1].audioInput = IN_Option_Board;//IN_Option_Board;
80004438:	b0 d9       	st.b	r8[0x5],r9
	ptr->RoutingData[1].audioOutput = Post_AMBE_Encoder;// OUT_Speaker;
8000443a:	b0 ea       	st.b	r8[0x6],r10

	
	ptr->RoutingData[2].audioInput = Tx_Voice_Header;//IN_Option_Board;
8000443c:	31 1a       	mov	r10,17
8000443e:	b0 fa       	st.b	r8[0x7],r10
	ptr->RoutingData[2].audioOutput = OUT_Option_Board;// OUT_Speaker;
80004440:	f1 69 00 08 	st.b	r8[8],r9
	//ptr->RoutingData[3].audioInput = IN_Option_Board;//IN_Option_Board;
	//ptr->RoutingData[3].audioOutput = Tx_Voice_Header;// OUT_Speaker;
	
	ptr->RoutingData[3].audioInput = Tx_Voice_Terminator;//IN_Option_Board;
80004444:	31 3a       	mov	r10,19
80004446:	f1 6a 00 09 	st.b	r8[9],r10
	ptr->RoutingData[3].audioOutput = OUT_Option_Board;// OUT_Speaker;
8000444a:	f1 69 00 0a 	st.b	r8[10],r9
	
	//ptr->RoutingData[1].audioInput = IN_Option_Board;
	//ptr->RoutingData[1].audioOutput = OUT_Microphone_Data;//OUT_Speaker;//
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(AudioRoutingControl_req_t) - (MAX_ROUTING_CTR - NumberofRoutings) * sizeof(RoutingData_t));
8000444e:	30 bb       	mov	r11,11
80004450:	fa cc ff fe 	sub	r12,sp,-2
80004454:	f0 1f 00 02 	mcall	8000445c <xcmp_audio_route_AMBE+0x48>
}
80004458:	2c dd       	sub	sp,-204
8000445a:	d8 02       	popm	pc
8000445c:	80 00       	ld.sh	r0,r0[0x0]
8000445e:	43 70       	lddsp	r0,sp[0xdc]

80004460 <xcmp_enter_enhanced_OB_mode>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_enter_enhanced_OB_mode(void)
{
80004460:	d4 01       	pushm	lr
80004462:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | EN_OB_CONTROL;
80004466:	e0 68 04 65 	mov	r8,1125
8000446a:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	En_OB_Control_req_t * ptr = (En_OB_Control_req_t *)xcmp_farme.u8;
	
	ptr->Function = EN_OB_Enter;
8000446c:	fa cc ff fe 	sub	r12,sp,-2
80004470:	30 18       	mov	r8,1
80004472:	b8 a8       	st.b	r12[0x2],r8
		
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(En_OB_Control_req_t));
80004474:	30 1b       	mov	r11,1
80004476:	f0 1f 00 03 	mcall	80004480 <xcmp_enter_enhanced_OB_mode+0x20>
}
8000447a:	2c dd       	sub	sp,-204
8000447c:	d8 02       	popm	pc
8000447e:	00 00       	add	r0,r0
80004480:	80 00       	ld.sh	r0,r0[0x0]
80004482:	43 70       	lddsp	r0,sp[0xdc]

80004484 <xcmp_DeviceInitializationStatus_request>:
Description: send device initialization status request
Calls: xcmp_tx
Called By:...
*/
void xcmp_DeviceInitializationStatus_request(void)
{
80004484:	d4 01       	pushm	lr
80004486:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
		
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_BRDCAST | DEVICE_INITIALIZATION_STATUS;
8000448a:	fe 78 b4 00 	mov	r8,-19456
8000448e:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceInitializationStatus_brdcst_t * ptr 
						 = (DeviceInitializationStatus_brdcst_t *)xcmp_farme.u8;
80004490:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*xcmp version 8.1.0.5*///
	ptr->XCMPVersion[0] = 0x08;
80004494:	30 89       	mov	r9,8
80004496:	b0 89       	st.b	r8[0x0],r9
	ptr->XCMPVersion[1] = 0x01;
80004498:	30 19       	mov	r9,1
8000449a:	b0 99       	st.b	r8[0x1],r9
	ptr->XCMPVersion[2] = 0x00;
8000449c:	30 09       	mov	r9,0
8000449e:	b0 a9       	st.b	r8[0x2],r9
	ptr->XCMPVersion[3] = 0x05;
800044a0:	30 5a       	mov	r10,5
800044a2:	b0 ba       	st.b	r8[0x3],r10
	/*
	0x00:
	This is the message that the device sends at power up or after a reset. It 
	will give the initial status and capabilities for the device.
	*/
	ptr->DeviceInitType = 0x00;
800044a4:	b0 c9       	st.b	r8[0x4],r9
	types of devices may provide a set of services to the radio system, but do 
	not have the ability to be the master.
	
	0x07:OptionBoard,3rd party Option Board-based application.
	*/
	ptr->DeviceStatusInfo.DeviceType = 0x07;
800044a6:	30 7a       	mov	r10,7
800044a8:	b0 da       	st.b	r8[0x5],r10
	
	/*Power Up Success, Device has powered up with no errors*/
	ptr->DeviceStatusInfo.DeviceStatus[0] = 0x00;
800044aa:	b0 e9       	st.b	r8[0x6],r9
	ptr->DeviceStatusInfo.DeviceStatus[1] = 0x00;
800044ac:	b0 f9       	st.b	r8[0x7],r9
	
	/*
	This number is the size of the Device Descriptor data structure with a 
	maximum size not exceeding 255 bytes.
	*/
	ptr->DeviceStatusInfo.DeviceDescriptorSize = 0x00;
800044ae:	f1 69 00 08 	st.b	r8[8],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme
800044b2:	30 9b       	mov	r11,9
800044b4:	fa cc ff fe 	sub	r12,sp,-2
800044b8:	f0 1f 00 02 	mcall	800044c0 <xcmp_DeviceInitializationStatus_request+0x3c>
		, sizeof(DeviceInitializationStatus_brdcst_t) - MAX_DEVICE_DESC_SIZE);
}
800044bc:	2c dd       	sub	sp,-204
800044be:	d8 02       	popm	pc
800044c0:	80 00       	ld.sh	r0,r0[0x0]
800044c2:	43 70       	lddsp	r0,sp[0xdc]

800044c4 <xcmp_opcode_not_supported>:
Description: register the app list
Calls: xcmp_tx
Called By:...
*/
void xcmp_opcode_not_supported( void )
{
800044c4:	d4 01       	pushm	lr
800044c6:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REPLY;
800044ca:	fe 78 80 00 	mov	r8,-32768
800044ce:	ba 18       	st.h	sp[0x2],r8
	
	/*The radio does not support this opcode.*/
	xcmp_farme.u8[0] = xcmp_Res_Opcode_Not_Supported;
800044d0:	30 38       	mov	r8,3
800044d2:	ba c8       	st.b	sp[0x4],r8
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, 1);
800044d4:	30 1b       	mov	r11,1
800044d6:	fa cc ff fe 	sub	r12,sp,-2
800044da:	f0 1f 00 03 	mcall	800044e4 <xcmp_opcode_not_supported+0x20>
}
800044de:	2c dd       	sub	sp,-204
800044e0:	d8 02       	popm	pc
800044e2:	00 00       	add	r0,r0
800044e4:	80 00       	ld.sh	r0,r0[0x0]
800044e6:	43 70       	lddsp	r0,sp[0xdc]

800044e8 <xcmp_exec_func>:
Description: Perform XCMP corresponding functions
Calls:   
Called By: xcmp_rx_process--task
*/
static void xcmp_exec_func(app_exec_t * exec, xcmp_fragment_t * xcmp)
{
800044e8:	d4 01       	pushm	lr
	/*The message types*/
	switch(xcmp->xcmp_opcode & 0xF000)
800044ea:	96 88       	ld.uh	r8,r11[0x0]
800044ec:	e2 18 f0 00 	andl	r8,0xf000,COH
800044f0:	e0 48 80 00 	cp.w	r8,32768
800044f4:	c0 f0       	breq	80004512 <xcmp_exec_func+0x2a>
800044f6:	e0 48 b0 00 	cp.w	r8,45056
800044fa:	c1 20       	breq	8000451e <xcmp_exec_func+0x36>
800044fc:	58 08       	cp.w	r8,0
800044fe:	c1 51       	brne	80004528 <xcmp_exec_func+0x40>
	{
		case XCMP_REQUEST:
			if(NULL != exec->xcmp_rx_req)
80004500:	78 08       	ld.w	r8,r12[0x0]
80004502:	58 08       	cp.w	r8,0
80004504:	c0 40       	breq	8000450c <xcmp_exec_func+0x24>
			{
				exec->xcmp_rx_req(xcmp);
80004506:	16 9c       	mov	r12,r11
80004508:	5d 18       	icall	r8
8000450a:	d8 02       	popm	pc
			}
			else 
			{
				/*No function to register the request message*/
				/*send not supported opcode to raido */
				xcmp_opcode_not_supported();
8000450c:	f0 1f 00 08 	mcall	8000452c <xcmp_exec_func+0x44>
80004510:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_REPLY:		
			if(NULL != exec->xcmp_rx_reply)
80004512:	78 18       	ld.w	r8,r12[0x4]
80004514:	58 08       	cp.w	r8,0
80004516:	c0 90       	breq	80004528 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_reply(xcmp);
80004518:	16 9c       	mov	r12,r11
8000451a:	5d 18       	icall	r8
8000451c:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_BRDCAST:	
			if(NULL != exec->xcmp_rx_brdcst)
8000451e:	78 28       	ld.w	r8,r12[0x8]
80004520:	58 08       	cp.w	r8,0
80004522:	c0 30       	breq	80004528 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_brdcst(xcmp);
80004524:	16 9c       	mov	r12,r11
80004526:	5d 18       	icall	r8
80004528:	d8 02       	popm	pc
8000452a:	00 00       	add	r0,r0
8000452c:	80 00       	ld.sh	r0,r0[0x0]
8000452e:	44 c4       	lddsp	r4,sp[0x130]

80004530 <xcmp_IdleTestTone>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_IdleTestTone(void)
{
80004530:	d4 01       	pushm	lr
80004532:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | TONE_CONTROL;
80004536:	e0 68 04 09 	mov	r8,1033
8000453a:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	ToneControl_req_t * ptr = (ToneControl_req_t *)xcmp_farme.u8;
8000453c:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*Starts the specific tone*/	
	ptr->Function = Tone_Start;
80004540:	30 19       	mov	r9,1
80004542:	b0 89       	st.b	r8[0x0],r9
	
	/*This tone shall be sounded when radio landed on a priority channel*/
	ptr->ToneIdentifier[0] = (Priority_Beep >> 8) & 0xFF;
80004544:	30 09       	mov	r9,0
80004546:	b0 99       	st.b	r8[0x1],r9
	ptr->ToneIdentifier[1] = Priority_Beep & 0xFF;
80004548:	30 ca       	mov	r10,12
8000454a:	b0 aa       	st.b	r8[0x2],r10
	
	/*
	The alert tone is played according to any rules for alert tones, given the 
	current volume setting. Settings for this field are 8 to 255 (0x08 ?0xFF).
	*/
	ptr->ToneVolumeControl = Current_Volume;
8000454c:	b0 b9       	st.b	r8[0x3],r9
	
	/*clear reserved*/
	memset(ptr->Reserved, 0, 8);
8000454e:	fb 69 00 08 	st.b	sp[8],r9
80004552:	fa c8 ff f7 	sub	r8,sp,-9
80004556:	b0 89       	st.b	r8[0x0],r9
80004558:	fa c8 ff f6 	sub	r8,sp,-10
8000455c:	b0 89       	st.b	r8[0x0],r9
8000455e:	fa c8 ff f5 	sub	r8,sp,-11
80004562:	b0 89       	st.b	r8[0x0],r9
80004564:	fa c8 ff f4 	sub	r8,sp,-12
80004568:	b0 89       	st.b	r8[0x0],r9
8000456a:	fa c8 ff f3 	sub	r8,sp,-13
8000456e:	b0 89       	st.b	r8[0x0],r9
80004570:	fa c8 ff f2 	sub	r8,sp,-14
80004574:	b0 89       	st.b	r8[0x0],r9
80004576:	fa c8 ff f1 	sub	r8,sp,-15
8000457a:	b0 89       	st.b	r8[0x0],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(ToneControl_req_t));
8000457c:	30 cb       	mov	r11,12
8000457e:	fa cc ff fe 	sub	r12,sp,-2
80004582:	f0 1f 00 03 	mcall	8000458c <xcmp_IdleTestTone+0x5c>
}
80004586:	2c dd       	sub	sp,-204
80004588:	d8 02       	popm	pc
8000458a:	00 00       	add	r0,r0
8000458c:	80 00       	ld.sh	r0,r0[0x0]
8000458e:	43 70       	lddsp	r0,sp[0xdc]

80004590 <xcmp_init>:
	xQueueCreate -- freertos
	xTaskCreate -- freertos
Called By: main -- main.c
*/
void xcmp_init(void)
{
80004590:	d4 01       	pushm	lr
	/*initialize the xnl*/
	xnl_init();
80004592:	f0 1f 00 0d 	mcall	800045c4 <xcmp_init+0x34>
	
	/*register the xcmp function(callback function)*/
	xnl_register_xcmp_func( xcmp_rx );
80004596:	48 dc       	lddpc	r12,800045c8 <xcmp_init+0x38>
80004598:	f0 1f 00 0d 	mcall	800045cc <xcmp_init+0x3c>
	
	/*initialize the queue*/
	//xcmp_frame_rx = xQueueCreate(10, sizeof(xcmp_fragment_t *));
	
	xcmp_frame_rx = xQueueCreate(20, sizeof(xcmp_fragment_t *));
8000459c:	30 4b       	mov	r11,4
8000459e:	31 4c       	mov	r12,20
800045a0:	f0 1f 00 0c 	mcall	800045d0 <xcmp_init+0x40>
800045a4:	48 c8       	lddpc	r8,800045d4 <xcmp_init+0x44>
800045a6:	91 0c       	st.w	r8[0x0],r12
	/*create task*/	
	/*this task is used to execute xcmp message*/
	xTaskCreate(
800045a8:	30 09       	mov	r9,0
800045aa:	1a d9       	st.w	--sp,r9
800045ac:	1a d9       	st.w	--sp,r9
800045ae:	1a d9       	st.w	--sp,r9
800045b0:	30 38       	mov	r8,3
800045b2:	e0 6a 01 80 	mov	r10,384
800045b6:	48 9b       	lddpc	r11,800045d8 <xcmp_init+0x48>
800045b8:	48 9c       	lddpc	r12,800045dc <xcmp_init+0x4c>
800045ba:	f0 1f 00 0a 	mcall	800045e0 <xcmp_init+0x50>
800045be:	2f dd       	sub	sp,-12
	,  384
	,  NULL
	,  tskXCMP_PRIORITY
	,  NULL
	);
}
800045c0:	d8 02       	popm	pc
800045c2:	00 00       	add	r0,r0
800045c4:	80 00       	ld.sh	r0,r0[0x0]
800045c6:	49 70       	lddpc	r0,80004620 <xcmp_rx_process+0x3c>
800045c8:	80 00       	ld.sh	r0,r0[0x0]
800045ca:	46 e0       	lddsp	r0,sp[0x1b8]
800045cc:	80 00       	ld.sh	r0,r0[0x0]
800045ce:	47 2c       	lddsp	r12,sp[0x1c8]
800045d0:	80 00       	ld.sh	r0,r0[0x0]
800045d2:	5c c4       	swap.bh	r4
800045d4:	00 00       	add	r0,r0
800045d6:	0b 04       	ld.w	r4,r5++
800045d8:	80 01       	ld.sh	r1,r0[0x0]
800045da:	5a 10       	cp.w	r0,-31
800045dc:	80 00       	ld.sh	r0,r0[0x0]
800045de:	45 e4       	lddsp	r4,sp[0x178]
800045e0:	80 00       	ld.sh	r0,r0[0x0]
800045e2:	63 98       	ld.w	r8,r1[0x64]

800045e4 <xcmp_rx_process>:
Calls: xQueueReceive -- freerots
	xcmp_exec_func
Called By: task
*/
static void xcmp_rx_process(void * pvParameters)
{
800045e4:	d4 31       	pushm	r0-r7,lr
800045e6:	20 1d       	sub	sp,4
	xcmp_fragment_t xcmp;
	xcmp_fragment_t * ptr;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//10ms
800045e8:	4b 16       	lddpc	r6,800046ac <xcmp_rx_process+0xc8>
800045ea:	30 05       	mov	r5,0
800045ec:	31 44       	mov	r4,20
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
800045ee:	4b 13       	lddpc	r3,800046b0 <xcmp_rx_process+0xcc>
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
					break;
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
800045f0:	4b 12       	lddpc	r2,800046b4 <xcmp_rx_process+0xd0>
						, ptr);
					break;
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
800045f2:	4b 21       	lddpc	r1,800046b8 <xcmp_rx_process+0xd4>
					break;
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
800045f4:	4b 20       	lddpc	r0,800046bc <xcmp_rx_process+0xd8>
	xcmp_fragment_t xcmp;
	xcmp_fragment_t * ptr;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//10ms
800045f6:	6c 0c       	ld.w	r12,r6[0x0]
800045f8:	0a 99       	mov	r9,r5
800045fa:	08 9a       	mov	r10,r4
800045fc:	1a 9b       	mov	r11,sp
800045fe:	f0 1f 00 31 	mcall	800046c0 <xcmp_rx_process+0xdc>
80004602:	58 1c       	cp.w	r12,1
80004604:	cf 91       	brne	800045f6 <xcmp_rx_process+0x12>
		{									
			if(NULL == ptr)
80004606:	40 0b       	lddsp	r11,sp[0x0]
80004608:	58 0b       	cp.w	r11,0
8000460a:	cf 60       	breq	800045f6 <xcmp_rx_process+0x12>
				continue;
			}
			
			//log("\n\r R_xcmp : %4x \n\r",ptr->xcmp_opcode);//log:R_xcmp	
						
			switch(ptr->xcmp_opcode & 0x0FFF)
8000460c:	96 0a       	ld.sh	r10,r11[0x0]
8000460e:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
80004612:	f1 d9 c0 0c 	bfextu	r8,r9,0x0,0xc
80004616:	59 c8       	cp.w	r8,28
80004618:	c1 e0       	breq	80004654 <xcmp_rx_process+0x70>
8000461a:	e0 89 00 07 	brgt	80004628 <xcmp_rx_process+0x44>
8000461e:	58 e8       	cp.w	r8,14
80004620:	c0 e0       	breq	8000463c <xcmp_rx_process+0x58>
80004622:	58 f8       	cp.w	r8,15
80004624:	c2 41       	brne	8000466c <xcmp_rx_process+0x88>
80004626:	c0 f8       	rjmp	80004644 <xcmp_rx_process+0x60>
80004628:	e0 48 01 09 	cp.w	r8,265
8000462c:	c1 80       	breq	8000465c <xcmp_rx_process+0x78>
8000462e:	e0 48 01 0a 	cp.w	r8,266
80004632:	c1 90       	breq	80004664 <xcmp_rx_process+0x80>
80004634:	e0 48 00 2c 	cp.w	r8,44
80004638:	c1 a1       	brne	8000466c <xcmp_rx_process+0x88>
8000463a:	c0 98       	rjmp	8000464c <xcmp_rx_process+0x68>
			{
				case RADIO_STATUS:				
					xcmp_exec_func(&radio_status, ptr);
8000463c:	4a 2c       	lddpc	r12,800046c4 <xcmp_rx_process+0xe0>
8000463e:	f0 1f 00 23 	mcall	800046c8 <xcmp_rx_process+0xe4>
					break;
80004642:	c2 f8       	rjmp	800046a0 <xcmp_rx_process+0xbc>
					
				case VERSION_INFORMATION:
					xcmp_exec_func(&version_information, ptr);
80004644:	4a 2c       	lddpc	r12,800046cc <xcmp_rx_process+0xe8>
80004646:	f0 1f 00 21 	mcall	800046c8 <xcmp_rx_process+0xe4>
					break;
8000464a:	c2 b8       	rjmp	800046a0 <xcmp_rx_process+0xbc>
					
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
8000464c:	4a 1c       	lddpc	r12,800046d0 <xcmp_rx_process+0xec>
8000464e:	f0 1f 00 1f 	mcall	800046c8 <xcmp_rx_process+0xe4>
					break;
80004652:	c2 78       	rjmp	800046a0 <xcmp_rx_process+0xbc>
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
80004654:	04 9c       	mov	r12,r2
80004656:	f0 1f 00 1d 	mcall	800046c8 <xcmp_rx_process+0xe4>
						, ptr);
					break;
8000465a:	c2 38       	rjmp	800046a0 <xcmp_rx_process+0xbc>
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
8000465c:	02 9c       	mov	r12,r1
8000465e:	f0 1f 00 1b 	mcall	800046c8 <xcmp_rx_process+0xe4>
					break;
80004662:	c1 f8       	rjmp	800046a0 <xcmp_rx_process+0xbc>
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
80004664:	00 9c       	mov	r12,r0
80004666:	f0 1f 00 19 	mcall	800046c8 <xcmp_rx_process+0xe4>
					break;
8000466a:	c1 b8       	rjmp	800046a0 <xcmp_rx_process+0xbc>
					
				default:
				
					/*the xcmp message not in order list*/
					/*over the length of the list*/
					if((0x0400 != (ptr->xcmp_opcode & 0x0400)) 
8000466c:	12 98       	mov	r8,r9
8000466e:	e2 18 04 00 	andl	r8,0x400,COH
80004672:	c0 70       	breq	80004680 <xcmp_rx_process+0x9c>
80004674:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
80004678:	e0 48 00 68 	cp.w	r8,104
8000467c:	e0 8a 00 08 	brle	8000468c <xcmp_rx_process+0xa8>
						|| (MAX_APP_FUNC <= (ptr->xcmp_opcode & 0x00FF))
					)
					{
						/*xcmp request*/
						if( XCMP_REQUEST == (ptr->xcmp_opcode & 0xF000))
80004680:	e2 19 f0 00 	andl	r9,0xf000,COH
80004684:	c0 e1       	brne	800046a0 <xcmp_rx_process+0xbc>
						{
							/*send not supported opcode to raido */
							xcmp_opcode_not_supported();
80004686:	f0 1f 00 14 	mcall	800046d4 <xcmp_rx_process+0xf0>
8000468a:	c0 b8       	rjmp	800046a0 <xcmp_rx_process+0xbc>
						}
					}
					else
					{					
						xcmp_exec_func( &app_list[ptr->xcmp_opcode & 0x00FF]
8000468c:	f9 da c0 08 	bfextu	r12,r10,0x0,0x8
80004690:	f8 0c 00 1c 	add	r12,r12,r12<<0x1
80004694:	49 19       	lddpc	r9,800046d8 <xcmp_rx_process+0xf4>
80004696:	72 08       	ld.w	r8,r9[0x0]
80004698:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
8000469c:	f0 1f 00 0b 	mcall	800046c8 <xcmp_rx_process+0xe4>
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
800046a0:	66 0c       	ld.w	r12,r3[0x0]
800046a2:	40 0b       	lddsp	r11,sp[0x0]
800046a4:	f0 1f 00 0e 	mcall	800046dc <xcmp_rx_process+0xf8>
800046a8:	ca 7b       	rjmp	800045f6 <xcmp_rx_process+0x12>
800046aa:	00 00       	add	r0,r0
800046ac:	00 00       	add	r0,r0
800046ae:	0b 04       	ld.w	r4,r5++
800046b0:	00 00       	add	r0,r0
800046b2:	0a 98       	mov	r8,r5
800046b4:	00 00       	add	r0,r0
800046b6:	0b 14       	ld.sh	r4,r5++
800046b8:	00 00       	add	r0,r0
800046ba:	0b 08       	ld.w	r8,r5++
800046bc:	00 00       	add	r0,r0
800046be:	0b 20       	ld.uh	r0,r5++
800046c0:	80 00       	ld.sh	r0,r0[0x0]
800046c2:	59 60       	cp.w	r0,22
800046c4:	00 00       	add	r0,r0
800046c6:	0b 38       	ld.ub	r8,r5++
800046c8:	80 00       	ld.sh	r0,r0[0x0]
800046ca:	44 e8       	lddsp	r8,sp[0x138]
800046cc:	00 00       	add	r0,r0
800046ce:	0a f8       	st.b	--r5,r8
800046d0:	00 00       	add	r0,r0
800046d2:	0b 2c       	ld.uh	r12,r5++
800046d4:	80 00       	ld.sh	r0,r0[0x0]
800046d6:	44 c4       	lddsp	r4,sp[0x130]
800046d8:	00 00       	add	r0,r0
800046da:	41 14       	lddsp	r4,sp[0x44]
800046dc:	80 00       	ld.sh	r0,r0[0x0]
800046de:	2a fc       	sub	r12,-81

800046e0 <xcmp_rx>:
Calls:   
	xQueueSend -- xnl.c
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
800046e0:	eb cd 40 90 	pushm	r4,r7,lr
800046e4:	20 1d       	sub	sp,4
800046e6:	fa c4 ff f0 	sub	r4,sp,-16
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
800046ea:	48 c8       	lddpc	r8,80004718 <xcmp_rx+0x38>
800046ec:	70 0c       	ld.w	r12,r8[0x0]
800046ee:	f0 1f 00 0c 	mcall	8000471c <xcmp_rx+0x3c>
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
800046f2:	c1 00       	breq	80004712 <xcmp_rx+0x32>
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
800046f4:	fa c7 ff fc 	sub	r7,sp,-4
800046f8:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
	{
		memcpy(xcmp_ptr, &xcmp, sizeof(xcmp_fragment_t));				
800046fa:	e0 6a 00 ca 	mov	r10,202
800046fe:	08 9b       	mov	r11,r4
80004700:	f0 1f 00 08 	mcall	80004720 <xcmp_rx+0x40>
		xQueueSend(xcmp_frame_rx, &xcmp_ptr, 0);	
80004704:	48 88       	lddpc	r8,80004724 <xcmp_rx+0x44>
80004706:	70 0c       	ld.w	r12,r8[0x0]
80004708:	30 09       	mov	r9,0
8000470a:	12 9a       	mov	r10,r9
8000470c:	1a 9b       	mov	r11,sp
8000470e:	f0 1f 00 07 	mcall	80004728 <xcmp_rx+0x48>
	}	
}
80004712:	2f fd       	sub	sp,-4
80004714:	e3 cd 80 90 	ldm	sp++,r4,r7,pc
80004718:	00 00       	add	r0,r0
8000471a:	0a 98       	mov	r8,r5
8000471c:	80 00       	ld.sh	r0,r0[0x0]
8000471e:	31 f0       	mov	r0,31
80004720:	80 00       	ld.sh	r0,r0[0x0]
80004722:	70 bc       	ld.w	r12,r8[0x2c]
80004724:	00 00       	add	r0,r0
80004726:	0b 04       	ld.w	r4,r5++
80004728:	80 00       	ld.sh	r0,r0[0x0]
8000472a:	5b 6c       	cp.w	r12,-10

8000472c <xnl_register_xcmp_func>:
Function: xnl_register_xcmp_func
Description: register the xcmp function(callback function)
*/
void xnl_register_xcmp_func( void ( *func)(xnl_content_data_msg_t))
{
	 xcmp_exec = func;
8000472c:	48 28       	lddpc	r8,80004734 <xnl_register_xcmp_func+0x8>
8000472e:	91 0c       	st.w	r8[0x0],r12
}
80004730:	5e fc       	retal	r12
80004732:	00 00       	add	r0,r0
80004734:	00 00       	add	r0,r0
80004736:	0b 68       	ld.uh	r8,--r5

80004738 <xnl_get_msg_ack_func>:
Description: process while receive msg ack.
Calls:xSemaphoreGive--freertos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
80004738:	d4 01       	pushm	lr
	
	DestinationAddress = xnl->xnl_header.destination;
	/*No timeout*/		
	 //One relationship is controlled by a state machine, only the current MSG received the ACK, 
	//then the program will clear the current MSG sending address and out of standby and will jump to the sending state.
	if (DestinationAddress == xnl_information.device_address )
8000473a:	48 88       	lddpc	r8,80004758 <xnl_get_msg_ack_func+0x20>
8000473c:	90 28       	ld.sh	r8,r8[0x4]
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
	U16 DestinationAddress;
	U16 TransactionID;
	
	DestinationAddress = xnl->xnl_header.destination;
8000473e:	98 49       	ld.sh	r9,r12[0x8]
80004740:	f0 09 19 00 	cp.h	r9,r8
80004744:	c0 81       	brne	80004754 <xnl_get_msg_ack_func+0x1c>
	if (DestinationAddress == xnl_information.device_address )
	{
		//The ack is for me.
		
		TransactionID = xnl->xnl_header.transaction_id;
		xSemaphoreGive(xnl_timeout_semphr);	
80004746:	48 68       	lddpc	r8,8000475c <xnl_get_msg_ack_func+0x24>
80004748:	70 0c       	ld.w	r12,r8[0x0]
8000474a:	30 09       	mov	r9,0
8000474c:	12 9a       	mov	r10,r9
8000474e:	12 9b       	mov	r11,r9
80004750:	f0 1f 00 04 	mcall	80004760 <xnl_get_msg_ack_func+0x28>
80004754:	d8 02       	popm	pc
80004756:	00 00       	add	r0,r0
80004758:	00 00       	add	r0,r0
8000475a:	0b 48       	ld.w	r8,--r5
8000475c:	00 00       	add	r0,r0
8000475e:	0b 44       	ld.w	r4,--r5
80004760:	80 00       	ld.sh	r0,r0[0x0]
80004762:	5b 6c       	cp.w	r12,-10

80004764 <xnl_tx_process>:
	xSemaphoreTake--freertos 
	phy_tx -- physical.c
Called By: task
*/
static void xnl_tx_process(void * pvParameters)
{
80004764:	d4 31       	pushm	r0-r7,lr
	static  xnl_fragment_t * ptr;//
	
	
	for(;;)
	{		
		switch(xnl_tx_state)
80004766:	4a 86       	lddpc	r6,80004804 <xnl_tx_process+0xa0>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
80004768:	4a 82       	lddpc	r2,80004808 <xnl_tx_process+0xa4>
8000476a:	4a 94       	lddpc	r4,8000480c <xnl_tx_process+0xa8>
8000476c:	30 07       	mov	r7,0
8000476e:	3f f1       	mov	r1,-1
					if(NULL == ptr)
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
80004770:	30 00       	mov	r0,0
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;
80004772:	4a 85       	lddpc	r5,80004810 <xnl_tx_process+0xac>
					
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
80004774:	4a 83       	lddpc	r3,80004814 <xnl_tx_process+0xb0>
	static  xnl_fragment_t * ptr;//
	
	
	for(;;)
	{		
		switch(xnl_tx_state)
80004776:	6c 08       	ld.w	r8,r6[0x0]
80004778:	58 08       	cp.w	r8,0
8000477a:	c0 40       	breq	80004782 <xnl_tx_process+0x1e>
8000477c:	58 18       	cp.w	r8,1
8000477e:	cf d1       	brne	80004778 <xnl_tx_process+0x14>
80004780:	c2 08       	rjmp	800047c0 <xnl_tx_process+0x5c>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
80004782:	64 0c       	ld.w	r12,r2[0x0]
80004784:	0e 99       	mov	r9,r7
80004786:	02 9a       	mov	r10,r1
80004788:	08 9b       	mov	r11,r4
8000478a:	f0 1f 00 24 	mcall	80004818 <xnl_tx_process+0xb4>
8000478e:	58 1c       	cp.w	r12,1
80004790:	cf 31       	brne	80004776 <xnl_tx_process+0x12>
					, portMAX_DELAY ))
				{				
					if(NULL == ptr)
80004792:	68 0c       	ld.w	r12,r4[0x0]
80004794:	58 0c       	cp.w	r12,0
80004796:	cf 00       	breq	80004776 <xnl_tx_process+0x12>
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
80004798:	98 28       	ld.sh	r8,r12[0x4]
8000479a:	e0 08 19 00 	cp.h	r8,r0
8000479e:	c0 41       	brne	800047a6 <xnl_tx_process+0x42>
					{
						/*invalid XNL opcode*/
						vPortFree(ptr);
800047a0:	f0 1f 00 1f 	mcall	8000481c <xnl_tx_process+0xb8>
						break;
800047a4:	ce 9b       	rjmp	80004776 <xnl_tx_process+0x12>
					}
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
800047a6:	f0 1f 00 1f 	mcall	80004820 <xnl_tx_process+0xbc>
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;
800047aa:	30 18       	mov	r8,1
800047ac:	8b 08       	st.w	r5[0x0],r8
					
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
800047ae:	66 0c       	ld.w	r12,r3[0x0]
800047b0:	0e 99       	mov	r9,r7
800047b2:	0e 9a       	mov	r10,r7
800047b4:	0e 9b       	mov	r11,r7
800047b6:	f0 1f 00 19 	mcall	80004818 <xnl_tx_process+0xb4>
					xnl_tx_state = WAITING_FOR_REPLY;
800047ba:	30 18       	mov	r8,1
800047bc:	8d 08       	st.w	r6[0x0],r8
800047be:	cd cb       	rjmp	80004776 <xnl_tx_process+0x12>
				}
				break;
			
			/*wait XNL reply*/			
			case WAITING_FOR_REPLY://ACKdata/control
				if(pdTRUE == xSemaphoreTake( xnl_timeout_semphr
800047c0:	66 0c       	ld.w	r12,r3[0x0]
800047c2:	0e 99       	mov	r9,r7
800047c4:	36 4a       	mov	r10,100
800047c6:	0e 9b       	mov	r11,r7
800047c8:	f0 1f 00 14 	mcall	80004818 <xnl_tx_process+0xb4>
800047cc:	58 1c       	cp.w	r12,1
800047ce:	c0 81       	brne	800047de <xnl_tx_process+0x7a>
					, ( portTickType )50*2/ portTICK_RATE_MS))//ADK500ms,freertos
				{
					/*No timeout*/
					//vPortFree(ptr);	
					set_xnl_idle(ptr);			
800047d0:	49 58       	lddpc	r8,80004824 <xnl_tx_process+0xc0>
800047d2:	70 0c       	ld.w	r12,r8[0x0]
800047d4:	68 0b       	ld.w	r11,r4[0x0]
800047d6:	f0 1f 00 15 	mcall	80004828 <xnl_tx_process+0xc4>
					xnl_tx_state = WAITING_FOR_TX;
800047da:	8d 07       	st.w	r6[0x0],r7
800047dc:	cc db       	rjmp	80004776 <xnl_tx_process+0x12>
				}
				else
				{
					/*time out*/
					if(xnl_send_times <= MIN_RESEND_TIMES)
800047de:	6a 08       	ld.w	r8,r5[0x0]
800047e0:	58 38       	cp.w	r8,3
800047e2:	e0 89 00 09 	brgt	800047f4 <xnl_tx_process+0x90>
					{
						/*If times smaller than A supermarket, then resend the 
						instructions*/
						phy_tx((phy_fragment_t *)ptr);
800047e6:	68 0c       	ld.w	r12,r4[0x0]
800047e8:	f0 1f 00 0e 	mcall	80004820 <xnl_tx_process+0xbc>
						xnl_send_times++;
800047ec:	6a 08       	ld.w	r8,r5[0x0]
800047ee:	2f f8       	sub	r8,-1
800047f0:	8b 08       	st.w	r5[0x0],r8
800047f2:	cc 2b       	rjmp	80004776 <xnl_tx_process+0x12>
					}
					else
					{
						//can not send data, disconnected						
						//vPortFree(ptr);	
						set_xnl_idle(ptr);									
800047f4:	48 c8       	lddpc	r8,80004824 <xnl_tx_process+0xc0>
800047f6:	70 0c       	ld.w	r12,r8[0x0]
800047f8:	68 0b       	ld.w	r11,r4[0x0]
800047fa:	f0 1f 00 0c 	mcall	80004828 <xnl_tx_process+0xc4>
						xnl_tx_state = WAITING_FOR_TX;
800047fe:	8d 07       	st.w	r6[0x0],r7
80004800:	cb bb       	rjmp	80004776 <xnl_tx_process+0x12>
80004802:	00 00       	add	r0,r0
80004804:	00 00       	add	r0,r0
80004806:	0b 64       	ld.uh	r4,--r5
80004808:	00 00       	add	r0,r0
8000480a:	0b 58       	ld.sh	r8,--r5
8000480c:	00 00       	add	r0,r0
8000480e:	0b 5c       	ld.sh	r12,--r5
80004810:	00 00       	add	r0,r0
80004812:	0b 54       	ld.sh	r4,--r5
80004814:	00 00       	add	r0,r0
80004816:	0b 44       	ld.w	r4,--r5
80004818:	80 00       	ld.sh	r0,r0[0x0]
8000481a:	59 60       	cp.w	r0,22
8000481c:	80 00       	ld.sh	r0,r0[0x0]
8000481e:	57 f0       	stdsp	sp[0x1fc],r0
80004820:	80 00       	ld.sh	r0,r0[0x0]
80004822:	2b 1c       	sub	r12,-79
80004824:	00 00       	add	r0,r0
80004826:	0a 98       	mov	r8,r5
80004828:	80 00       	ld.sh	r0,r0[0x0]
8000482a:	2a fc       	sub	r12,-81

8000482c <xnl_rx_process>:
Description: Receive the XNL
Calls: 
Called By:task
*/
static void xnl_rx_process(void * pvParameters)
{
8000482c:	eb cd 40 fe 	pushm	r1-r7,lr
80004830:	20 1d       	sub	sp,4
	/*To ptr the elements in the queue*/
	xnl_fragment_t * xnl_ptr;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
80004832:	49 26       	lddpc	r6,80004878 <xnl_rx_process+0x4c>
80004834:	30 05       	mov	r5,0
80004836:	3f f4       	mov	r4,-1
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
80004838:	30 c3       	mov	r3,12
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
8000483a:	49 11       	lddpc	r1,8000487c <xnl_rx_process+0x50>
	if(xnl->xnl_header.opcode > 0x0C)	
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
8000483c:	49 12       	lddpc	r2,80004880 <xnl_rx_process+0x54>
	/*To ptr the elements in the queue*/
	xnl_fragment_t * xnl_ptr;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
8000483e:	6c 0c       	ld.w	r12,r6[0x0]
80004840:	0a 99       	mov	r9,r5
80004842:	08 9a       	mov	r10,r4
80004844:	1a 9b       	mov	r11,sp
80004846:	f0 1f 00 10 	mcall	80004884 <xnl_rx_process+0x58>
8000484a:	58 1c       	cp.w	r12,1
8000484c:	cf 91       	brne	8000483e <xnl_rx_process+0x12>
		, portMAX_DELAY ))
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
8000484e:	40 0c       	lddsp	r12,sp[0x0]
80004850:	58 0c       	cp.w	r12,0
80004852:	cf 60       	breq	8000483e <xnl_rx_process+0x12>
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
80004854:	98 28       	ld.sh	r8,r12[0x4]
80004856:	e6 08 19 00 	cp.h	r8,r3
8000485a:	e0 8b 00 0a 	brhi	8000486e <xnl_rx_process+0x42>
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
8000485e:	5c 78       	castu.h	r8
80004860:	e4 08 03 29 	ld.w	r9,r2[r8<<0x2]
80004864:	58 09       	cp.w	r9,0
80004866:	c0 40       	breq	8000486e <xnl_rx_process+0x42>
	{
		//log("\n\r R_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:R_xnl
		/*execute the function in list*/
		xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec(xnl);
80004868:	e4 08 03 28 	ld.w	r8,r2[r8<<0x2]
8000486c:	5d 18       	icall	r8
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
8000486e:	62 0c       	ld.w	r12,r1[0x0]
80004870:	40 0b       	lddsp	r11,sp[0x0]
80004872:	f0 1f 00 06 	mcall	80004888 <xnl_rx_process+0x5c>
80004876:	ce 4b       	rjmp	8000483e <xnl_rx_process+0x12>
80004878:	00 00       	add	r0,r0
8000487a:	0a c0       	st.b	r5++,r0
8000487c:	00 00       	add	r0,r0
8000487e:	0a 98       	mov	r8,r5
80004880:	00 00       	add	r0,r0
80004882:	04 f4       	st.b	--r2,r4
80004884:	80 00       	ld.sh	r0,r0[0x0]
80004886:	59 60       	cp.w	r0,22
80004888:	80 00       	ld.sh	r0,r0[0x0]
8000488a:	2a fc       	sub	r12,-81

8000488c <xnl_tx>:
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
{
8000488c:	eb cd 40 c0 	pushm	r6-r7,lr
80004890:	20 1d       	sub	sp,4
80004892:	18 96       	mov	r6,r12
	message that is sent. The same value should be used for all retries.
	*/
	static U8 flags = 0;
	
	/*If the value is DEFAULT_VALUE, the value will be modified*/
	if(DEFAULT_VALUE == xnl->xnl_header.flags)
80004894:	98 39       	ld.sh	r9,r12[0x6]
80004896:	3f f8       	mov	r8,-1
80004898:	f0 09 19 00 	cp.h	r9,r8
8000489c:	c0 a1       	brne	800048b0 <xnl_tx+0x24>
	{
		xnl->xnl_header.flags =  0x0100 | ((++flags) & 0x07);
8000489e:	4a e9       	lddpc	r9,80004954 <xnl_tx+0xc8>
800048a0:	13 88       	ld.ub	r8,r9[0x0]
800048a2:	2f f8       	sub	r8,-1
800048a4:	5c 58       	castu.b	r8
800048a6:	b2 88       	st.b	r9[0x0],r8
800048a8:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
800048ac:	a9 a8       	sbr	r8,0x8
800048ae:	b8 38       	st.h	r12[0x6],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.destination)
800048b0:	8c 49       	ld.sh	r9,r6[0x8]
800048b2:	3f f8       	mov	r8,-1
800048b4:	f0 09 19 00 	cp.h	r9,r8
800048b8:	c0 41       	brne	800048c0 <xnl_tx+0x34>
	{		
		/*Use actual Master address.*/
		xnl->xnl_header.destination = xnl_information.master_address;
800048ba:	4a 88       	lddpc	r8,80004958 <xnl_tx+0xcc>
800048bc:	90 18       	ld.sh	r8,r8[0x2]
800048be:	ac 48       	st.h	r6[0x8],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.source)
800048c0:	8c 59       	ld.sh	r9,r6[0xa]
800048c2:	3f f8       	mov	r8,-1
800048c4:	f0 09 19 00 	cp.h	r9,r8
800048c8:	c0 41       	brne	800048d0 <xnl_tx+0x44>
	{
		/*Use Temporary address.*/	
		xnl->xnl_header.source = xnl_information.device_address;
800048ca:	4a 48       	lddpc	r8,80004958 <xnl_tx+0xcc>
800048cc:	90 28       	ld.sh	r8,r8[0x4]
800048ce:	ac 58       	st.h	r6[0xa],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
800048d0:	8c 69       	ld.sh	r9,r6[0xc]
800048d2:	3f f8       	mov	r8,-1
800048d4:	f0 09 19 00 	cp.h	r9,r8
800048d8:	c0 e1       	brne	800048f4 <xnl_tx+0x68>
	{		
		xnl->xnl_header.transaction_id = 
		  ((++xnl_information.transaction_id) & 0xFF) 
800048da:	4a 08       	lddpc	r8,80004958 <xnl_tx+0xcc>
800048dc:	90 49       	ld.sh	r9,r8[0x8]
800048de:	2f f9       	sub	r9,-1
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
800048e0:	b0 49       	st.h	r8[0x8],r9
		  ((++xnl_information.transaction_id) & 0xFF) 
800048e2:	90 4a       	ld.sh	r10,r8[0x8]
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
800048e4:	90 49       	ld.sh	r9,r8[0x8]
800048e6:	e0 19 ff 00 	andl	r9,0xff00
800048ea:	f1 da c0 08 	bfextu	r8,r10,0x0,0x8
800048ee:	f3 e8 10 08 	or	r8,r9,r8
800048f2:	ac 68       	st.h	r6[0xc],r8
	U16  sumScratch;
	U32  indextohWord;
	S32  hWordswithinFrag;
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
800048f4:	0d 98       	ld.ub	r8,r6[0x1]
800048f6:	20 28       	sub	r8,2
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
800048f8:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
800048fc:	10 0c       	add	r12,r8
800048fe:	a1 5c       	asr	r12,0x1
	indextohWord = 2;
	while (hWordswithinFrag > 0)
80004900:	58 0c       	cp.w	r12,0
80004902:	e0 89 00 04 	brgt	8000490a <xnl_tx+0x7e>
80004906:	30 09       	mov	r9,0
80004908:	c0 d8       	rjmp	80004922 <xnl_tx+0x96>
8000490a:	ec ca ff fc 	sub	r10,r6,-4
Parameters: xnl_fragment_t * 
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
8000490e:	2f ec       	sub	r12,-2
80004910:	30 09       	mov	r9,0
80004912:	30 28       	mov	r8,2
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
	{
		sumScratch += *((U16*)xnl + indextohWord);
80004914:	15 1b       	ld.sh	r11,r10++
80004916:	f6 09 00 09 	add	r9,r11,r9
8000491a:	5c 89       	casts.h	r9
		indextohWord     += 1;
8000491c:	2f f8       	sub	r8,-1
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
8000491e:	18 38       	cp.w	r8,r12
80004920:	cf a1       	brne	80004914 <xnl_tx+0x88>
		  ((++xnl_information.transaction_id) & 0xFF) 
		| (xnl_information.transaction_id & 0xFF00);
	}
	
	/*count check sum */
	xnl->phy_header.check_sum = check_sum( xnl );
80004922:	5c 39       	neg	r9
80004924:	ac 19       	st.h	r6[0x2],r9
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
80004926:	48 e8       	lddpc	r8,8000495c <xnl_tx+0xd0>
80004928:	70 0c       	ld.w	r12,r8[0x0]
8000492a:	f0 1f 00 0e 	mcall	80004960 <xnl_tx+0xd4>
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
8000492e:	c1 00       	breq	8000494e <xnl_tx+0xc2>
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
80004930:	fa c7 ff fc 	sub	r7,sp,-4
80004934:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
	{
		memcpy(ptr, xnl, sizeof(xnl_fragment_t));
80004936:	e0 6a 01 00 	mov	r10,256
8000493a:	0c 9b       	mov	r11,r6
8000493c:	f0 1f 00 0a 	mcall	80004964 <xnl_tx+0xd8>
	
		/*push to queue and send*/
		
		//log("ptr -%8x", ptr);
		
		xQueueSend(xnl_frame_tx, &ptr, 0);
80004940:	48 a8       	lddpc	r8,80004968 <xnl_tx+0xdc>
80004942:	70 0c       	ld.w	r12,r8[0x0]
80004944:	30 09       	mov	r9,0
80004946:	12 9a       	mov	r10,r9
80004948:	1a 9b       	mov	r11,sp
8000494a:	f0 1f 00 09 	mcall	8000496c <xnl_tx+0xe0>
		//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
		
		//vPortFree(ptr);
	}
}
8000494e:	2f fd       	sub	sp,-4
80004950:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004954:	00 00       	add	r0,r0
80004956:	0b 60       	ld.uh	r0,--r5
80004958:	00 00       	add	r0,r0
8000495a:	0b 48       	ld.w	r8,--r5
8000495c:	00 00       	add	r0,r0
8000495e:	0a 98       	mov	r8,r5
80004960:	80 00       	ld.sh	r0,r0[0x0]
80004962:	31 f0       	mov	r0,31
80004964:	80 00       	ld.sh	r0,r0[0x0]
80004966:	70 bc       	ld.w	r12,r8[0x2c]
80004968:	00 00       	add	r0,r0
8000496a:	0b 58       	ld.sh	r8,--r5
8000496c:	80 00       	ld.sh	r0,r0[0x0]
8000496e:	5b 6c       	cp.w	r12,-10

80004970 <xnl_init>:
	xTaskCreate--freertos
	xnl_send_device_master_query
Called By:xcmp_init -- xcmp.c
*/
void xnl_init(void)
{
80004970:	eb cd 40 80 	pushm	r7,lr
80004974:	fa cd 01 00 	sub	sp,sp,256
	/*initialize the physical layer*/
	phy_init();
80004978:	f0 1f 00 27 	mcall	80004a14 <xnl_init+0xa4>
	
	xnl_information.is_connected = FALSE;
8000497c:	30 09       	mov	r9,0
8000497e:	4a 78       	lddpc	r8,80004a18 <xnl_init+0xa8>
80004980:	b0 89       	st.b	r8[0x0],r9

	/*initialize the semaphore and queue*/
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
80004982:	30 0b       	mov	r11,0
80004984:	30 1c       	mov	r12,1
80004986:	f0 1f 00 26 	mcall	80004a1c <xnl_init+0xac>
8000498a:	4a 68       	lddpc	r8,80004a20 <xnl_init+0xb0>
8000498c:	91 0c       	st.w	r8[0x0],r12
8000498e:	70 08       	ld.w	r8,r8[0x0]
80004990:	58 08       	cp.w	r8,0
80004992:	c0 80       	breq	800049a2 <xnl_init+0x32>
80004994:	4a 38       	lddpc	r8,80004a20 <xnl_init+0xb0>
80004996:	70 0c       	ld.w	r12,r8[0x0]
80004998:	30 09       	mov	r9,0
8000499a:	12 9a       	mov	r10,r9
8000499c:	12 9b       	mov	r11,r9
8000499e:	f0 1f 00 22 	mcall	80004a24 <xnl_init+0xb4>
	//xnl_frame_tx = xQueueCreate(10, sizeof(xnl_fragment_t *)); 
	
	xnl_frame_tx = xQueueCreate(20, sizeof(xnl_fragment_t *)); //xnl_frame_tx
800049a2:	30 4b       	mov	r11,4
800049a4:	31 4c       	mov	r12,20
800049a6:	f0 1f 00 1e 	mcall	80004a1c <xnl_init+0xac>
800049aa:	4a 08       	lddpc	r8,80004a28 <xnl_init+0xb8>
800049ac:	91 0c       	st.w	r8[0x0],r12
		
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
800049ae:	30 07       	mov	r7,0
800049b0:	1a d7       	st.w	--sp,r7
800049b2:	1a d7       	st.w	--sp,r7
800049b4:	1a d7       	st.w	--sp,r7
800049b6:	30 38       	mov	r8,3
800049b8:	0e 99       	mov	r9,r7
800049ba:	e0 6a 02 00 	mov	r10,512
800049be:	49 cb       	lddpc	r11,80004a2c <xnl_init+0xbc>
800049c0:	49 cc       	lddpc	r12,80004a30 <xnl_init+0xc0>
800049c2:	f0 1f 00 1d 	mcall	80004a34 <xnl_init+0xc4>
	,  tskXNL_PRIORITY //+ 1
	,  NULL
	);
	
	/*this task is used to send xnl message*/
	xTaskCreate(
800049c6:	1a d7       	st.w	--sp,r7
800049c8:	1a d7       	st.w	--sp,r7
800049ca:	1a d7       	st.w	--sp,r7
800049cc:	30 38       	mov	r8,3
800049ce:	0e 99       	mov	r9,r7
800049d0:	e0 6a 03 20 	mov	r10,800
800049d4:	49 9b       	lddpc	r11,80004a38 <xnl_init+0xc8>
800049d6:	49 ac       	lddpc	r12,80004a3c <xnl_init+0xcc>
800049d8:	f0 1f 00 17 	mcall	80004a34 <xnl_init+0xc4>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
800049dc:	e0 68 40 0e 	mov	r8,16398
800049e0:	fb 58 00 18 	st.h	sp[24],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
800049e4:	3f f8       	mov	r8,-1
800049e6:	fb 58 00 1a 	st.h	sp[26],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_MASTER_QUERY;
800049ea:	30 38       	mov	r8,3
800049ec:	fb 58 00 1c 	st.h	sp[28],r8
	
	/*The initial value*/
	xnl_frame.xnl_header.flags = 0;
800049f0:	fb 57 00 1e 	st.h	sp[30],r7
	
	/*XNL address of the master device, if known;otherwise 0x0000*/
	xnl_frame.xnl_header.destination = 0;
800049f4:	fb 57 00 20 	st.h	sp[32],r7
	
	/*XNL address, if assigned; otherwise 0x0000*/
	xnl_frame.xnl_header.source = 0;
800049f8:	fb 57 00 22 	st.h	sp[34],r7
	
	/*No transaction ID required for this message*/
	xnl_frame.xnl_header.transaction_id = 0;
800049fc:	fb 57 00 24 	st.h	sp[36],r7
	
	/*This message contains no payload*/
	xnl_frame.xnl_header.payload_length = 0;
80004a00:	fb 57 00 26 	st.h	sp[38],r7

	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004a04:	fa cc ff e8 	sub	r12,sp,-24
80004a08:	f0 1f 00 0e 	mcall	80004a40 <xnl_init+0xd0>
80004a0c:	2f ad       	sub	sp,-24
	,  NULL
	);
	
	/*send device_master_query to connect radio*/	
	xnl_send_device_master_query();
}
80004a0e:	2c 0d       	sub	sp,-256
80004a10:	e3 cd 80 80 	ldm	sp++,r7,pc
80004a14:	80 00       	ld.sh	r0,r0[0x0]
80004a16:	32 18       	mov	r8,33
80004a18:	00 00       	add	r0,r0
80004a1a:	0b 48       	ld.w	r8,--r5
80004a1c:	80 00       	ld.sh	r0,r0[0x0]
80004a1e:	5c c4       	swap.bh	r4
80004a20:	00 00       	add	r0,r0
80004a22:	0b 44       	ld.w	r4,--r5
80004a24:	80 00       	ld.sh	r0,r0[0x0]
80004a26:	5b 6c       	cp.w	r12,-10
80004a28:	00 00       	add	r0,r0
80004a2a:	0b 58       	ld.sh	r8,--r5
80004a2c:	80 01       	ld.sh	r1,r0[0x0]
80004a2e:	5a 18       	cp.w	r8,-31
80004a30:	80 00       	ld.sh	r0,r0[0x0]
80004a32:	48 2c       	lddpc	r12,80004a38 <xnl_init+0xc8>
80004a34:	80 00       	ld.sh	r0,r0[0x0]
80004a36:	63 98       	ld.w	r8,r1[0x64]
80004a38:	80 00       	ld.sh	r0,r0[0x0]
80004a3a:	c8 00       	breq	8000493a <xnl_tx+0xae>
80004a3c:	80 00       	ld.sh	r0,r0[0x0]
80004a3e:	47 64       	lddsp	r4,sp[0x1d8]
80004a40:	80 00       	ld.sh	r0,r0[0x0]
80004a42:	48 8c       	lddpc	r12,80004a60 <xnl_data_msg_func+0x1c>

80004a44 <xnl_data_msg_func>:
Description: process while receive data message.
Calls:xnl_send_msg_ack, xcmp_exec(function in xcmp)
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_data_msg_func(xnl_fragment_t * xnl)
{
80004a44:	eb cd 40 80 	pushm	r7,lr
80004a48:	fa cd 01 00 	sub	sp,sp,256
80004a4c:	18 97       	mov	r7,r12
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80004a4e:	e0 68 40 0e 	mov	r8,16398
80004a52:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004a54:	3f f8       	mov	r8,-1
80004a56:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG_ACK;
80004a58:	30 c8       	mov	r8,12
80004a5a:	ba 28       	st.h	sp[0x4],r8
	
	/*Turn around Flags.*/	
	xnl_frame.xnl_header.flags = hdr->flags;
80004a5c:	98 38       	ld.sh	r8,r12[0x6]
80004a5e:	ba 38       	st.h	sp[0x6],r8
	
	/*ACK Destination Address is Source of XNL_Message.*/
	xnl_frame.xnl_header.destination = hdr->source;
80004a60:	98 58       	ld.sh	r8,r12[0xa]
80004a62:	ba 48       	st.h	sp[0x8],r8
	
	/*ACK Source Address is my address.*/
	xnl_frame.xnl_header.source = hdr->destination;
80004a64:	98 48       	ld.sh	r8,r12[0x8]
80004a66:	ba 58       	st.h	sp[0xa],r8
	
	/*Turn around Transaction ID.*/
	xnl_frame.xnl_header.transaction_id = hdr->transaction_id;
80004a68:	98 68       	ld.sh	r8,r12[0xc]
80004a6a:	ba 68       	st.h	sp[0xc],r8
	xnl_frame.xnl_header.payload_length = 0;
80004a6c:	30 08       	mov	r8,0
80004a6e:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004a70:	1a 9c       	mov	r12,sp
80004a72:	f0 1f 00 0a 	mcall	80004a98 <xnl_data_msg_func+0x54>
	transmitter, but possibly is waiting in Queue with immediate timeout.
	 */
	xnl_send_msg_ack(&xnl->xnl_header);
	
	/*exec xcmp function*/
	xcmp_exec(xnl->xnl_payload.xnl_content_data_msg);//xcmp_rx
80004a76:	fa cd 00 cc 	sub	sp,sp,204
80004a7a:	e0 6a 00 ca 	mov	r10,202
80004a7e:	ee cb ff f0 	sub	r11,r7,-16
80004a82:	1a 9c       	mov	r12,sp
80004a84:	f0 1f 00 06 	mcall	80004a9c <xnl_data_msg_func+0x58>
80004a88:	48 68       	lddpc	r8,80004aa0 <xnl_data_msg_func+0x5c>
80004a8a:	70 08       	ld.w	r8,r8[0x0]
80004a8c:	5d 18       	icall	r8
80004a8e:	fa cd ff 34 	sub	sp,sp,-204
}
80004a92:	2c 0d       	sub	sp,-256
80004a94:	e3 cd 80 80 	ldm	sp++,r7,pc
80004a98:	80 00       	ld.sh	r0,r0[0x0]
80004a9a:	48 8c       	lddpc	r12,80004ab8 <xnl_device_auth_reply_func+0x14>
80004a9c:	80 00       	ld.sh	r0,r0[0x0]
80004a9e:	70 bc       	ld.w	r12,r8[0x2c]
80004aa0:	00 00       	add	r0,r0
80004aa2:	0b 68       	ld.uh	r8,--r5

80004aa4 <xnl_device_auth_reply_func>:
Description: process while receive device auth reply.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_auth_reply_func(xnl_fragment_t * xnl)
{
80004aa4:	d4 21       	pushm	r4-r7,lr
80004aa6:	fa cd 01 00 	sub	sp,sp,256
80004aaa:	18 97       	mov	r7,r12
	the receiving device and will be used to authenticate the connection 
	request. 5.4.4
	*/
	//log("R_xnl-opcode:%4x", xnl->xnl_header.opcode);
	
	if(xnl_information.is_connected)
80004aac:	4c 28       	lddpc	r8,80004bb4 <xnl_device_auth_reply_func+0x110>
80004aae:	11 88       	ld.ub	r8,r8[0x0]
80004ab0:	58 08       	cp.w	r8,0
80004ab2:	e0 81 00 7f 	brne	80004bb0 <xnl_device_auth_reply_func+0x10c>
	{
		return;		
	}
	
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);
80004ab6:	4c 18       	lddpc	r8,80004bb8 <xnl_device_auth_reply_func+0x114>
80004ab8:	70 0c       	ld.w	r12,r8[0x0]
80004aba:	30 09       	mov	r9,0
80004abc:	12 9a       	mov	r10,r9
80004abe:	12 9b       	mov	r11,r9
80004ac0:	f0 1f 00 3f 	mcall	80004bbc <xnl_device_auth_reply_func+0x118>

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
80004ac4:	ef 09 00 10 	ld.sh	r9,r7[16]
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
80004ac8:	4b b8       	lddpc	r8,80004bb4 <xnl_device_auth_reply_func+0x110>
80004aca:	b0 29       	st.h	r8[0x4],r9
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
	
	/*Get Array of values to be encrypted into an aligned 2X32bits.*/
	v_vector[0] =
80004acc:	ef 39 00 12 	ld.ub	r9,r7[18]
80004ad0:	ef 38 00 13 	ld.ub	r8,r7[19]
80004ad4:	b1 68       	lsl	r8,0x10
80004ad6:	f1 e9 11 89 	or	r9,r8,r9<<0x18
80004ada:	ef 38 00 15 	ld.ub	r8,r7[21]
80004ade:	f3 e8 10 08 	or	r8,r9,r8
80004ae2:	ef 39 00 14 	ld.ub	r9,r7[20]
80004ae6:	f1 e9 10 89 	or	r9,r8,r9<<0x8
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[2])<<8	  
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[3]);
	
	v_vector[1] =
80004aea:	ef 3a 00 16 	ld.ub	r10,r7[22]
80004aee:	ef 38 00 17 	ld.ub	r8,r7[23]
80004af2:	b1 68       	lsl	r8,0x10
80004af4:	f1 ea 11 8a 	or	r10,r8,r10<<0x18
80004af8:	ef 38 00 19 	ld.ub	r8,r7[25]
80004afc:	f5 e8 10 08 	or	r8,r10,r8
80004b00:	ef 3a 00 18 	ld.ub	r10,r7[24]
80004b04:	f1 ea 10 88 	or	r8,r8,r10<<0x8
80004b08:	30 0a       	mov	r10,0
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
80004b0a:	e0 64 79 b9 	mov	r4,31161
80004b0e:	ea 14 9e 37 	orh	r4,0x9e37
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
80004b12:	e0 65 45 07 	mov	r5,17671
80004b16:	ea 15 8a bd 	orh	r5,0x8abd
80004b1a:	e0 66 f9 3d 	mov	r6,63805
80004b1e:	ea 16 99 68 	orh	r6,0x9968
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
80004b22:	e0 6e b8 cf 	mov	lr,47311
80004b26:	ea 1e 36 83 	orh	lr,0x3683
80004b2a:	e0 67 aa 1c 	mov	r7,43548
80004b2e:	ea 17 9c 36 	orh	r7,0x9c36
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
80004b32:	08 0a       	add	r10,r4
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
80004b34:	f4 08 00 0c 	add	r12,r10,r8
80004b38:	f0 0b 15 04 	lsl	r11,r8,0x4
80004b3c:	0a 0b       	add	r11,r5
80004b3e:	f9 eb 20 0b 	eor	r11,r12,r11
80004b42:	f0 0c 16 05 	lsr	r12,r8,0x5
80004b46:	0c 0c       	add	r12,r6
80004b48:	18 5b       	eor	r11,r12
80004b4a:	16 09       	add	r9,r11
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
80004b4c:	f2 0c 15 04 	lsl	r12,r9,0x4
80004b50:	1c 0c       	add	r12,lr
80004b52:	f2 0b 16 05 	lsr	r11,r9,0x5
80004b56:	0e 0b       	add	r11,r7
80004b58:	f9 eb 20 0b 	eor	r11,r12,r11
80004b5c:	f2 0a 00 0c 	add	r12,r9,r10
80004b60:	18 5b       	eor	r11,r12
80004b62:	16 08       	add	r8,r11
{
	register U32 y=v[0], z=v[1], sum=0;
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
80004b64:	e0 6b 37 20 	mov	r11,14112
80004b68:	ea 1b c6 ef 	orh	r11,0xc6ef
80004b6c:	16 3a       	cp.w	r10,r11
80004b6e:	ce 21       	brne	80004b32 <xnl_device_auth_reply_func+0x8e>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :24 + 2(xnl length(24) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 24 + 2;
80004b70:	e0 6a 40 1a 	mov	r10,16410
80004b74:	ba 0a       	st.h	sp[0x0],r10
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004b76:	3f fa       	mov	r10,-1
80004b78:	ba 1a       	st.h	sp[0x2],r10
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_CONN_REQUEST;
80004b7a:	30 6b       	mov	r11,6
80004b7c:	ba 2b       	st.h	sp[0x4],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
80004b7e:	ba 3a       	st.h	sp[0x6],r10
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
80004b80:	48 db       	lddpc	r11,80004bb4 <xnl_device_auth_reply_func+0x110>
80004b82:	96 1c       	ld.sh	r12,r11[0x2]
80004b84:	ba 4c       	st.h	sp[0x8],r12
	message here, and all will receive the same DEVICE_CONN_REPLY. Not real 
	sure what's going to happen with multiple conrol heads, etc. One suspects 
	the Rocket Scientists will eventually figure this out, and demand a 
	transaction ID based on Device Type in the XNL_DEVICE_AUTH_KEY_REQUEST.
	*/
	xnl_frame.xnl_header.source = xnl_information.device_address;
80004b86:	96 2b       	ld.sh	r11,r11[0x4]
80004b88:	ba 5b       	st.h	sp[0xa],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80004b8a:	ba 6a       	st.h	sp[0xc],r10
	
    /*his message contains 12 payload bytes*/	
	xnl_frame.xnl_header.payload_length = 0x000C;
80004b8c:	30 ca       	mov	r10,12
80004b8e:	ba 7a       	st.h	sp[0xe],r10
	
	/*No Preferred XNL Address*/
	xnl_frame.xnl_payload.xnl_content_device_conn_req.preferred_xnl_address = 
80004b90:	30 0a       	mov	r10,0
80004b92:	fb 5a 00 10 	st.h	sp[16],r10
	XCMP/XNL Development Specification Section 4.5.3.2.1.
	Same as in MOTOTRBO?XCMP/XNL Development Specification?
	evice_type--Option Board(0x07)
	authentication_index--Option Board(0x02)
	*/	
	xnl_frame.xnl_payload.xnl_content_device_conn_req.device_type = 0x07;
80004b96:	30 7a       	mov	r10,7
80004b98:	fb 6a 00 12 	st.b	sp[18],r10
	xnl_frame.xnl_payload.xnl_content_device_conn_req.authentication_index =
80004b9c:	30 2a       	mov	r10,2
80004b9e:	fb 6a 00 13 	st.b	sp[19],r10
	                                                                       0x02;
		
	//We know encrypted array happens to be aligned to 32-bit boundary.
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
80004ba2:	fa ca ff ec 	sub	r10,sp,-20
80004ba6:	95 09       	st.w	r10[0x0],r9
	                         .encrypted_authentication_value[0])) = w_vector[0];
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
80004ba8:	95 18       	st.w	r10[0x4],r8
	                         .encrypted_authentication_value[4])) = w_vector[1];
	
	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004baa:	1a 9c       	mov	r12,sp
80004bac:	f0 1f 00 05 	mcall	80004bc0 <xnl_device_auth_reply_func+0x11c>
}
80004bb0:	2c 0d       	sub	sp,-256
80004bb2:	d8 22       	popm	r4-r7,pc
80004bb4:	00 00       	add	r0,r0
80004bb6:	0b 48       	ld.w	r8,--r5
80004bb8:	00 00       	add	r0,r0
80004bba:	0b 44       	ld.w	r4,--r5
80004bbc:	80 00       	ld.sh	r0,r0[0x0]
80004bbe:	5b 6c       	cp.w	r12,-10
80004bc0:	80 00       	ld.sh	r0,r0[0x0]
80004bc2:	48 8c       	lddpc	r12,80004be0 <xnl_master_status_brdcst_func+0x1c>

80004bc4 <xnl_master_status_brdcst_func>:
Description: process while receive master status boardcast.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_master_status_brdcst_func(xnl_fragment_t * xnl)
{	
80004bc4:	eb cd 40 80 	pushm	r7,lr
80004bc8:	fa cd 01 00 	sub	sp,sp,256
80004bcc:	18 97       	mov	r7,r12
	not an XNL_DATA_MSG has been sent out. This will indicate to a connecting 
	device that it has missed messages. The XNL header will contain the 
	master?XNL address. 5.4.1
	*/
	
	if(xnl_information.is_connected)
80004bce:	49 28       	lddpc	r8,80004c14 <xnl_master_status_brdcst_func+0x50>
80004bd0:	11 88       	ld.ub	r8,r8[0x0]
80004bd2:	58 08       	cp.w	r8,0
80004bd4:	c1 c1       	brne	80004c0c <xnl_master_status_brdcst_func+0x48>
	{
		return;	
	}
		
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);	
80004bd6:	49 18       	lddpc	r8,80004c18 <xnl_master_status_brdcst_func+0x54>
80004bd8:	70 0c       	ld.w	r12,r8[0x0]
80004bda:	30 09       	mov	r9,0
80004bdc:	12 9a       	mov	r10,r9
80004bde:	12 9b       	mov	r11,r9
80004be0:	f0 1f 00 0f 	mcall	80004c1c <xnl_master_status_brdcst_func+0x58>

	//log("xnl-ma:%4x", xnl->xnl_header.source);
	/*get the master adderss from this message*/	
	xnl_information.master_address = xnl->xnl_header.source;	
80004be4:	8e 58       	ld.sh	r8,r7[0xa]
80004be6:	48 c9       	lddpc	r9,80004c14 <xnl_master_status_brdcst_func+0x50>
80004be8:	b2 18       	st.h	r9[0x2],r8
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80004bea:	e0 68 40 0e 	mov	r8,16398
80004bee:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004bf0:	3f f8       	mov	r8,-1
80004bf2:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_AUTH_KEY_REQUEST;
80004bf4:	30 4a       	mov	r10,4
80004bf6:	ba 2a       	st.h	sp[0x4],r10
		
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/	
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
80004bf8:	ba 38       	st.h	sp[0x6],r8
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
80004bfa:	92 19       	ld.sh	r9,r9[0x2]
80004bfc:	ba 49       	st.h	sp[0x8],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.source = DEFAULT_VALUE;
80004bfe:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80004c00:	ba 68       	st.h	sp[0xc],r8
		
	xnl_frame.xnl_header.payload_length = 0;
80004c02:	30 08       	mov	r8,0
80004c04:	ba 78       	st.h	sp[0xe],r8
	
	/*send XNL message*/	
	xnl_tx(&xnl_frame);
80004c06:	1a 9c       	mov	r12,sp
80004c08:	f0 1f 00 06 	mcall	80004c20 <xnl_master_status_brdcst_func+0x5c>
}
80004c0c:	2c 0d       	sub	sp,-256
80004c0e:	e3 cd 80 80 	ldm	sp++,r7,pc
80004c12:	00 00       	add	r0,r0
80004c14:	00 00       	add	r0,r0
80004c16:	0b 48       	ld.w	r8,--r5
80004c18:	00 00       	add	r0,r0
80004c1a:	0b 44       	ld.w	r4,--r5
80004c1c:	80 00       	ld.sh	r0,r0[0x0]
80004c1e:	5b 6c       	cp.w	r12,-10
80004c20:	80 00       	ld.sh	r0,r0[0x0]
80004c22:	48 8c       	lddpc	r12,80004c40 <xnl_device_conn_reply_func+0x1c>

80004c24 <xnl_device_conn_reply_func>:
Description: process while receive device conn reply.
Calls:xSemaphoreGive--freestos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_conn_reply_func(xnl_fragment_t * xnl)
{
80004c24:	eb cd 40 80 	pushm	r7,lr
80004c28:	18 97       	mov	r7,r12
	transaction ID and an 8-byte encrypted value that the device can use to 
	authenticate the master. XCMP/XNL Development Guide 5.4.6
	*/
	
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);
80004c2a:	49 38       	lddpc	r8,80004c74 <xnl_device_conn_reply_func+0x50>
80004c2c:	70 0c       	ld.w	r12,r8[0x0]
80004c2e:	30 09       	mov	r9,0
80004c30:	12 9a       	mov	r10,r9
80004c32:	12 9b       	mov	r11,r9
80004c34:	f0 1f 00 11 	mcall	80004c78 <xnl_device_conn_reply_func+0x54>

	/*Test result code*/
	if((xnl->xnl_payload.xnl_content_device_conn_reply.result_base & 0x0000FF00)
80004c38:	ef 18 00 10 	ld.uh	r8,r7[16]
80004c3c:	10 99       	mov	r9,r8
80004c3e:	e2 19 ff 00 	andl	r9,0xff00,COH
80004c42:	e0 49 01 00 	cp.w	r9,256
80004c46:	c0 60       	breq	80004c52 <xnl_device_conn_reply_func+0x2e>
		/*
		Rejected. The device must retry the authentication process at this 
		point by sending out a new AUTH_KEY_REQUEST message. XCMP/XNL 
		Development Guide Section 5.2.3
		*/
		xnl_master_status_brdcst_func(xnl);			
80004c48:	0e 9c       	mov	r12,r7
80004c4a:	f0 1f 00 0d 	mcall	80004c7c <xnl_device_conn_reply_func+0x58>
80004c4e:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/*connection accepted*/		
		/*Record Transaction ID Base*/
		xnl_information.transaction_id =  
80004c52:	a9 68       	lsl	r8,0x8
80004c54:	48 b9       	lddpc	r9,80004c80 <xnl_device_conn_reply_func+0x5c>
80004c56:	b2 48       	st.h	r9[0x8],r8
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
80004c58:	ef 08 00 14 	ld.sh	r8,r7[20]
		xnl_information.transaction_id =  
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
80004c5c:	b2 38       	st.h	r9[0x6],r8
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
80004c5e:	ef 08 00 12 	ld.sh	r8,r7[18]
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
80004c62:	b2 28       	st.h	r9[0x4],r8
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
		
		/*connect finish*/
		xnl_information.is_connected = TRUE;
80004c64:	30 18       	mov	r8,1
80004c66:	b2 88       	st.b	r9[0x0],r8
		
		log("connected finish");
80004c68:	48 7c       	lddpc	r12,80004c84 <xnl_device_conn_reply_func+0x60>
80004c6a:	f0 1f 00 08 	mcall	80004c88 <xnl_device_conn_reply_func+0x64>
80004c6e:	e3 cd 80 80 	ldm	sp++,r7,pc
80004c72:	00 00       	add	r0,r0
80004c74:	00 00       	add	r0,r0
80004c76:	0b 44       	ld.w	r4,--r5
80004c78:	80 00       	ld.sh	r0,r0[0x0]
80004c7a:	5b 6c       	cp.w	r12,-10
80004c7c:	80 00       	ld.sh	r0,r0[0x0]
80004c7e:	4b c4       	lddpc	r4,80004d6c <local_start_timer+0x4>
80004c80:	00 00       	add	r0,r0
80004c82:	0b 48       	ld.w	r8,--r5
80004c84:	80 01       	ld.sh	r1,r0[0x0]
80004c86:	5a 20       	cp.w	r0,-30
80004c88:	80 00       	ld.sh	r0,r0[0x0]
80004c8a:	67 5c       	ld.w	r12,r3[0x54]

80004c8c <local_start_pll0>:
	//pm_switch_to_osc0(pm, 12000000, 3);
	//    pm_enable_osc0_crystal(pm, 12000000);
	//         pm_set_osc0_mode(pm,AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);  0x00000007
	//    pm_enable_clk0(pm, 3);
	//         pm_enable_clk0_no_wait(pm, 3);
	(&AVR32_PM)->oscctrl0 = 0x00000307;
80004c8c:	fe 78 0c 00 	mov	r8,-62464
80004c90:	e0 69 03 07 	mov	r9,775
80004c94:	91 a9       	st.w	r8[0x28],r9
	(&AVR32_PM)->mcctrl   = 0x00000004;
80004c96:	30 49       	mov	r9,4
80004c98:	91 09       	st.w	r8[0x0],r9
	//         pm_wait_for_clk0_ready(pm);
	while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
80004c9a:	71 59       	ld.w	r9,r8[0x54]
80004c9c:	e2 19 00 80 	andl	r9,0x80,COH
80004ca0:	cf d0       	breq	80004c9a <local_start_pll0+0xe>
	//    pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);
	(&AVR32_PM)->mcctrl   = 0x00000005;
80004ca2:	fe 78 0c 00 	mov	r8,-62464
80004ca6:	30 59       	mov	r9,5
80004ca8:	91 09       	st.w	r8[0x0],r9
	//pm_pll_set_option(pm, 0, //PLL number 0
	//                        1, //freq Set to 1 for VCO frequency range 80-180MHz
	//                        1, //div2 Divide the PLL output frequency by 2
	//                        0);//0 to enable the Wide-Bandith Mode
	//pm_pll_enable(pm,0);
	(&AVR32_PM)->pll[0] = 0x1007010D;
80004caa:	e0 69 01 0d 	mov	r9,269
80004cae:	ea 19 10 07 	orh	r9,0x1007
80004cb2:	91 89       	st.w	r8[0x20],r9


	//pm_wait_for_pll0_locked(pm);
	while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_LOCK0_MASK));
80004cb4:	71 59       	ld.w	r9,r8[0x54]
80004cb6:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
80004cba:	cf d0       	breq	80004cb4 <local_start_pll0+0x28>
	//             0,  //Bus A select = 0 (PBA clock = 48MHz/2 = 24MHz).
	//             0,  //B clock divisor enable = 0
	//             0,  //Bus B select = 0
	//             0,  //HS Bus clock divisor enable = 0
	//             0); //HS Bus select = 0
	(&AVR32_PM)->cksel = 0x00800000;
80004cbc:	fe 78 0c 00 	mov	r8,-62464
80004cc0:	fc 19 00 80 	movh	r9,0x80
80004cc4:	91 19       	st.w	r8[0x4],r9

	//flashc_set_wait_state(1);
	AVR32_FLASHC.fcr = 0x00000040;
80004cc6:	34 0a       	mov	r10,64
80004cc8:	fe 69 14 00 	mov	r9,-125952
80004ccc:	93 0a       	st.w	r9[0x0],r10

	//pm_switch_to_clock(pm, AVR32_PM_MCSEL_PLL0);
	(&AVR32_PM)->mcctrl   = 0x00000006;
80004cce:	30 69       	mov	r9,6
80004cd0:	91 09       	st.w	r8[0x0],r9


	AVR32_HMATRIX.mcfg[AVR32_HMATRIX_MASTER_CPU_INSTRUCTION] = 0x1;
80004cd2:	30 19       	mov	r9,1
80004cd4:	fe 68 10 00 	mov	r8,-126976
80004cd8:	91 19       	st.w	r8[0x4],r9
}
80004cda:	5e fc       	retal	r12

80004cdc <rtc_init>:
    PCF8563_init
Called By: ..
Return:rtc_err_t
*/
rtc_err_t rtc_init(void)
{
80004cdc:	eb cd 40 c0 	pushm	r6-r7,lr
80004ce0:	20 3d       	sub	sp,12
	/* Create the mutex semaphore to guard a shared RTC(TWI).*/	
	rtc_mutex = xSemaphoreCreateMutex();
80004ce2:	f0 1f 00 1a 	mcall	80004d48 <rtc_init+0x6c>
80004ce6:	49 a8       	lddpc	r8,80004d4c <rtc_init+0x70>
80004ce8:	91 0c       	st.w	r8[0x0],r12
	
	if(NULL != rtc_mutex)
80004cea:	70 08       	ld.w	r8,r8[0x0]
80004cec:	58 08       	cp.w	r8,0
80004cee:	c0 31       	brne	80004cf4 <rtc_init+0x18>
80004cf0:	30 3c       	mov	r12,3
80004cf2:	c2 78       	rjmp	80004d40 <rtc_init+0x64>
	{
		/*See if we can obtain the semaphore. If the semaphore is not available wait aways to see if it becomes free*/
		xSemaphoreTake( rtc_mutex, portMAX_DELAY);
80004cf4:	49 66       	lddpc	r6,80004d4c <rtc_init+0x70>
80004cf6:	6c 0c       	ld.w	r12,r6[0x0]
80004cf8:	30 09       	mov	r9,0
80004cfa:	3f fa       	mov	r10,-1
80004cfc:	12 9b       	mov	r11,r9
80004cfe:	f0 1f 00 15 	mcall	80004d50 <rtc_init+0x74>
	
	/*twi_package_t packet, packet_received*/
	static int status;

	/*TWI gpio pins configuration*/	
	gpio_enable_module(TWI_GPIO_MAP, sizeof(TWI_GPIO_MAP) / sizeof(TWI_GPIO_MAP[0]));
80004d02:	30 2b       	mov	r11,2
80004d04:	49 4c       	lddpc	r12,80004d54 <rtc_init+0x78>
80004d06:	f0 1f 00 15 	mcall	80004d58 <rtc_init+0x7c>
	
	/* options settings*/
	opt.pba_hz = RTC_PBACLK_FREQ_HZ;//FOSC0;24Mhz
80004d0a:	e0 68 36 00 	mov	r8,13824
80004d0e:	ea 18 01 6e 	orh	r8,0x16e
80004d12:	50 08       	stdsp	sp[0x0],r8
	opt.speed  = TWI_SPEED;//200Khz
80004d14:	e2 78 0d 40 	mov	r8,200000
80004d18:	50 18       	stdsp	sp[0x4],r8
	opt.chip   = PCF8563_ADDRESS;
80004d1a:	35 18       	mov	r8,81
80004d1c:	fb 68 00 08 	st.b	sp[8],r8

	/*initialize TWI driver with options*/
	status = twi_master_init(&AVR32_TWI, &opt);
80004d20:	1a 9b       	mov	r11,sp
80004d22:	fe 7c 2c 00 	mov	r12,-54272
80004d26:	f0 1f 00 0e 	mcall	80004d5c <rtc_init+0x80>
80004d2a:	48 e7       	lddpc	r7,80004d60 <rtc_init+0x84>
80004d2c:	8f 0c       	st.w	r7[0x0],r12
	
	/*finished accessing the shared resource.Release the semaphore.*/
	xSemaphoreGive(rtc_mutex);		
80004d2e:	6c 0c       	ld.w	r12,r6[0x0]
80004d30:	30 09       	mov	r9,0
80004d32:	12 9a       	mov	r10,r9
80004d34:	12 9b       	mov	r11,r9
80004d36:	f0 1f 00 0c 	mcall	80004d64 <rtc_init+0x88>
80004d3a:	6e 08       	ld.w	r8,r7[0x0]
80004d3c:	58 08       	cp.w	r8,0
80004d3e:	5f 1c       	srne	r12
	{
		return rtc_success;
	}
		
	return rtc_init_err;
}
80004d40:	2f dd       	sub	sp,-12
80004d42:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004d46:	00 00       	add	r0,r0
80004d48:	80 00       	ld.sh	r0,r0[0x0]
80004d4a:	5c 6c       	casts.b	r12
80004d4c:	00 00       	add	r0,r0
80004d4e:	0b 70       	ld.ub	r0,--r5
80004d50:	80 00       	ld.sh	r0,r0[0x0]
80004d52:	59 60       	cp.w	r0,22
80004d54:	80 01       	ld.sh	r1,r0[0x0]
80004d56:	5a 34       	cp.w	r4,-29
80004d58:	80 00       	ld.sh	r0,r0[0x0]
80004d5a:	6b f4       	ld.w	r4,r5[0x7c]
80004d5c:	80 00       	ld.sh	r0,r0[0x0]
80004d5e:	51 ec       	stdsp	sp[0x78],r12
80004d60:	00 00       	add	r0,r0
80004d62:	0b 6c       	ld.uh	r12,--r5
80004d64:	80 00       	ld.sh	r0,r0[0x0]
80004d66:	5b 6c       	cp.w	r12,-10

80004d68 <local_start_timer>:
//	MAKO_RX					AVR32_SSC_RX_DATA_0_PIN				[39 PortB Pin  7 00000080 Func 0]
//
void local_start_timer(void)
{
	//Route CLK to Timer
	AVR32_GPIO.port[0].pmr0s = 0x00100000;
80004d68:	fe 78 10 00 	mov	r8,-61440
80004d6c:	fc 19 00 10 	movh	r9,0x10
80004d70:	91 59       	st.w	r8[0x14],r9
	AVR32_GPIO.port[0].pmr1c = 0x00100000;
80004d72:	91 a9       	st.w	r8[0x28],r9
	AVR32_GPIO.port[0].gperc = 0x00100000;
80004d74:	91 29       	st.w	r8[0x8],r9
	//Route FS and Tri-State to Timer.
	AVR32_GPIO.port[1].pmr0c = 0x00000003;
80004d76:	30 39       	mov	r9,3
80004d78:	f1 49 01 18 	st.w	r8[280],r9
	AVR32_GPIO.port[1].pmr1c = 0x00000003;
80004d7c:	f1 49 01 28 	st.w	r8[296],r9
	AVR32_GPIO.port[1].gperc = 0x00000003;
80004d80:	f1 49 01 08 	st.w	r8[264],r9

	(&AVR32_TC)->bmr = 4;
80004d84:	fe 78 38 00 	mov	r8,-51200
80004d88:	30 49       	mov	r9,4
80004d8a:	f1 49 00 c4 	st.w	r8[196],r9
	(&AVR32_TC)->channel[0].cmr =
80004d8e:	e0 69 91 0d 	mov	r9,37133
80004d92:	ea 19 00 52 	orh	r9,0x52
80004d96:	91 19       	st.w	r8[0x4],r9
	1                          << AVR32_TC_CLKI_OFFSET     |
	AVR32_TC_TCCLKS_XC0        << AVR32_TC_TCCLKS_OFFSET;



	(&AVR32_TC)->channel[0].ra = 32;
80004d98:	32 09       	mov	r9,32
80004d9a:	91 59       	st.w	r8[0x14],r9
	(&AVR32_TC)->channel[0].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
80004d9c:	30 59       	mov	r9,5
80004d9e:	91 09       	st.w	r8[0x0],r9
}
80004da0:	5e fc       	retal	r12
80004da2:	d7 03       	nop

80004da4 <tc_init>:
 * - fPBA/8 is used as clock source for TC
 * - Enables RC compare match interrupt
 * \param tc Base address of the TC module
 */
void tc_init()
{
80004da4:	d4 01       	pushm	lr

	volatile avr32_tc_t * tc = EXAMPLE_TC;
	
	INTC_register_interrupt(&_tc_interrupt, AVR32_TC_IRQ1, AVR32_INTC_INT2);
80004da6:	30 2a       	mov	r10,2
80004da8:	e0 6b 01 c1 	mov	r11,449
80004dac:	48 ec       	lddpc	r12,80004de4 <tc_init+0x40>
80004dae:	f0 1f 00 0f 	mcall	80004de8 <tc_init+0x44>
		.cpas  = 0,
		.lovrs = 0,
		.covfs = 0
	};
	// Initialize the timer/counter.
	tc_init_waveform(tc, &waveform_opt);
80004db2:	48 fb       	lddpc	r11,80004dec <tc_init+0x48>
80004db4:	fe 7c 38 00 	mov	r12,-51200
80004db8:	f0 1f 00 0e 	mcall	80004df0 <tc_init+0x4c>
	 * We want: (1 / (fPBA / 8)) * RC = 10 ms, hence RC = (fPBA / 8) / 100
	 * to get an interrupt every 10 ms.
	 */
	//tc_write_rc(tc, EXAMPLE_TC_CHANNEL, (sysclk_get_pba_hz() / 8 / 100));
	
	tc_write_rc(tc, EXAMPLE_TC_CHANNEL, ((FOSC0*2) / 8 / 100));
80004dbc:	e0 6a 75 30 	mov	r10,30000
80004dc0:	30 1b       	mov	r11,1
80004dc2:	fe 7c 38 00 	mov	r12,-51200
80004dc6:	f0 1f 00 0c 	mcall	80004df4 <tc_init+0x50>
	
	//tc_write_rc(tc, EXAMPLE_TC_CHANNEL, (FOSC0 / 8 / 100000));
	
	
	// configure the timer interrupt
	tc_configure_interrupts(tc, EXAMPLE_TC_CHANNEL, &tc_interrupt);
80004dca:	48 ca       	lddpc	r10,80004df8 <tc_init+0x54>
80004dcc:	30 1b       	mov	r11,1
80004dce:	fe 7c 38 00 	mov	r12,-51200
80004dd2:	f0 1f 00 0b 	mcall	80004dfc <tc_init+0x58>
	// Start the timer/counter.
	tc_start(tc, EXAMPLE_TC_CHANNEL);
80004dd6:	30 1b       	mov	r11,1
80004dd8:	fe 7c 38 00 	mov	r12,-51200
80004ddc:	f0 1f 00 09 	mcall	80004e00 <tc_init+0x5c>
80004de0:	d8 02       	popm	pc
80004de2:	00 00       	add	r0,r0
80004de4:	80 00       	ld.sh	r0,r0[0x0]
80004de6:	4e 04       	lddpc	r4,80004f64 <tc_init_waveform+0x30>
80004de8:	80 00       	ld.sh	r0,r0[0x0]
80004dea:	4e 28       	lddpc	r8,80004f70 <tc_init_waveform+0x3c>
80004dec:	80 01       	ld.sh	r1,r0[0x0]
80004dee:	5a 48       	cp.w	r8,-28
80004df0:	80 00       	ld.sh	r0,r0[0x0]
80004df2:	4f 34       	lddpc	r4,80004fbc <tc_init_waveform+0x88>
80004df4:	80 00       	ld.sh	r0,r0[0x0]
80004df6:	4f f4       	lddpc	r4,80004ff0 <tc_read_sr+0xe>
80004df8:	80 01       	ld.sh	r1,r0[0x0]
80004dfa:	5a 44       	cp.w	r4,-28
80004dfc:	80 00       	ld.sh	r0,r0[0x0]
80004dfe:	50 28       	stdsp	sp[0x8],r8
80004e00:	80 00       	ld.sh	r0,r0[0x0]
80004e02:	4f d0       	lddpc	r0,80004ff4 <tc_write_rc>

80004e04 <_tc_interrupt>:
volatile U32 tc_tick = 0;

//brief Default interrupt handler.
__attribute__((__interrupt__))
static void _tc_interrupt(void)
 {
80004e04:	d4 01       	pushm	lr
	// Increment the 10ms seconds counter
	tc_tick++;
80004e06:	48 68       	lddpc	r8,80004e1c <_tc_interrupt+0x18>
80004e08:	70 09       	ld.w	r9,r8[0x0]
80004e0a:	2f f9       	sub	r9,-1
80004e0c:	91 09       	st.w	r8[0x0],r9
	/*
	 * TODO: Place a breakpoint here and watch the update of tc_tick variable
	 * in the Watch Window.
	 */
	// Clear the interrupt flag. This is a side effect of reading the TC SR.
	tc_read_sr(EXAMPLE_TC, EXAMPLE_TC_CHANNEL);
80004e0e:	30 1b       	mov	r11,1
80004e10:	fe 7c 38 00 	mov	r12,-51200
80004e14:	f0 1f 00 03 	mcall	80004e20 <_tc_interrupt+0x1c>
	
}
80004e18:	d4 02       	popm	lr
80004e1a:	d6 03       	rete
80004e1c:	00 00       	add	r0,r0
80004e1e:	0b 74       	ld.ub	r4,--r5
80004e20:	80 00       	ld.sh	r0,r0[0x0]
80004e22:	4f e2       	lddpc	r2,80005018 <tc_write_rc+0x24>

80004e24 <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
80004e24:	c0 08       	rjmp	80004e24 <_unhandled_interrupt>
80004e26:	d7 03       	nop

80004e28 <INTC_register_interrupt>:
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
80004e28:	f6 08 16 05 	lsr	r8,r11,0x5

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
80004e2c:	49 99       	lddpc	r9,80004e90 <INTC_register_interrupt+0x68>
80004e2e:	f2 08 00 39 	add	r9,r9,r8<<0x3
80004e32:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
80004e36:	72 19       	ld.w	r9,r9[0x4]
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
80004e38:	f2 0b 09 2c 	st.w	r9[r11<<0x2],r12
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
80004e3c:	58 0a       	cp.w	r10,0
80004e3e:	c0 91       	brne	80004e50 <INTC_register_interrupt+0x28>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80004e40:	49 59       	lddpc	r9,80004e94 <INTC_register_interrupt+0x6c>
80004e42:	49 6a       	lddpc	r10,80004e98 <INTC_register_interrupt+0x70>
80004e44:	12 1a       	sub	r10,r9
80004e46:	fe 79 08 00 	mov	r9,-63488
80004e4a:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80004e4e:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT1) {
80004e50:	58 1a       	cp.w	r10,1
80004e52:	c0 a1       	brne	80004e66 <INTC_register_interrupt+0x3e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
80004e54:	49 09       	lddpc	r9,80004e94 <INTC_register_interrupt+0x6c>
80004e56:	49 2a       	lddpc	r10,80004e9c <INTC_register_interrupt+0x74>
80004e58:	12 1a       	sub	r10,r9
80004e5a:	bf aa       	sbr	r10,0x1e
80004e5c:	fe 79 08 00 	mov	r9,-63488
80004e60:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80004e64:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT2) {
80004e66:	58 2a       	cp.w	r10,2
80004e68:	c0 a1       	brne	80004e7c <INTC_register_interrupt+0x54>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
80004e6a:	48 b9       	lddpc	r9,80004e94 <INTC_register_interrupt+0x6c>
80004e6c:	48 da       	lddpc	r10,80004ea0 <INTC_register_interrupt+0x78>
80004e6e:	12 1a       	sub	r10,r9
80004e70:	bf ba       	sbr	r10,0x1f
80004e72:	fe 79 08 00 	mov	r9,-63488
80004e76:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80004e7a:	5e fc       	retal	r12
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
80004e7c:	48 69       	lddpc	r9,80004e94 <INTC_register_interrupt+0x6c>
80004e7e:	48 aa       	lddpc	r10,80004ea4 <INTC_register_interrupt+0x7c>
80004e80:	12 1a       	sub	r10,r9
80004e82:	ea 1a c0 00 	orh	r10,0xc000
80004e86:	fe 79 08 00 	mov	r9,-63488
80004e8a:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80004e8e:	5e fc       	retal	r12
80004e90:	80 01       	ld.sh	r1,r0[0x0]
80004e92:	5a 50       	cp.w	r0,-27
80004e94:	80 00       	ld.sh	r0,r0[0x0]
80004e96:	c6 00       	breq	80004f56 <tc_init_waveform+0x22>
80004e98:	80 00       	ld.sh	r0,r0[0x0]
80004e9a:	c7 04       	brge	80004f7a <tc_init_waveform+0x46>
80004e9c:	80 00       	ld.sh	r0,r0[0x0]
80004e9e:	c7 12       	brcc	80004f80 <tc_init_waveform+0x4c>
80004ea0:	80 00       	ld.sh	r0,r0[0x0]
80004ea2:	c7 20       	breq	80004f86 <tc_init_waveform+0x52>
80004ea4:	80 00       	ld.sh	r0,r0[0x0]
80004ea6:	c7 2e       	rcall	80004b8a <xnl_device_auth_reply_func+0xe6>

80004ea8 <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
80004ea8:	d4 21       	pushm	r4-r7,lr
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
80004eaa:	49 18       	lddpc	r8,80004eec <INTC_init_interrupts+0x44>
80004eac:	e3 b8 00 01 	mtsr	0x4,r8
80004eb0:	49 0e       	lddpc	lr,80004ef0 <INTC_init_interrupts+0x48>
80004eb2:	30 07       	mov	r7,0
80004eb4:	0e 94       	mov	r4,r7
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80004eb6:	49 0c       	lddpc	r12,80004ef4 <INTC_init_interrupts+0x4c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80004eb8:	49 05       	lddpc	r5,80004ef8 <INTC_init_interrupts+0x50>
80004eba:	10 15       	sub	r5,r8
80004ebc:	fe 76 08 00 	mov	r6,-63488
80004ec0:	c1 08       	rjmp	80004ee0 <INTC_init_interrupts+0x38>
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
80004ec2:	08 98       	mov	r8,r4
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
80004ec4:	7c 1b       	ld.w	r11,lr[0x4]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80004ec6:	7c 0a       	ld.w	r10,lr[0x0]
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80004ec8:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
80004ecc:	2f f8       	sub	r8,-1

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80004ece:	10 3a       	cp.w	r10,r8
80004ed0:	fe 9b ff fc 	brhi	80004ec8 <INTC_init_interrupts+0x20>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80004ed4:	ec 07 09 25 	st.w	r6[r7<<0x2],r5
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
80004ed8:	2f f7       	sub	r7,-1
80004eda:	2f 8e       	sub	lr,-8
80004edc:	59 37       	cp.w	r7,19
80004ede:	c0 50       	breq	80004ee8 <INTC_init_interrupts+0x40>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80004ee0:	7c 08       	ld.w	r8,lr[0x0]
80004ee2:	58 08       	cp.w	r8,0
80004ee4:	ce f1       	brne	80004ec2 <INTC_init_interrupts+0x1a>
80004ee6:	cf 7b       	rjmp	80004ed4 <INTC_init_interrupts+0x2c>
80004ee8:	d8 22       	popm	r4-r7,pc
80004eea:	00 00       	add	r0,r0
80004eec:	80 00       	ld.sh	r0,r0[0x0]
80004eee:	c6 00       	breq	80004fae <tc_init_waveform+0x7a>
80004ef0:	80 01       	ld.sh	r1,r0[0x0]
80004ef2:	5a 50       	cp.w	r0,-27
80004ef4:	80 00       	ld.sh	r0,r0[0x0]
80004ef6:	4e 24       	lddpc	r4,8000507c <tc_configure_interrupts+0x54>
80004ef8:	80 00       	ld.sh	r0,r0[0x0]
80004efa:	c7 04       	brge	80004fda <tc_start+0xa>

80004efc <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
80004efc:	fe 78 08 00 	mov	r8,-63488
80004f00:	e0 69 00 83 	mov	r9,131
80004f04:	f2 0c 01 0c 	sub	r12,r9,r12
80004f08:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
80004f0c:	f2 ca ff c0 	sub	r10,r9,-64
80004f10:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	
	return (int_req)
80004f14:	58 08       	cp.w	r8,0
80004f16:	c0 21       	brne	80004f1a <_get_interrupt_handler+0x1e>
80004f18:	5e fd       	retal	0
		? _int_handler_table[int_grp]._int_line_handler_table[32
80004f1a:	f0 08 12 00 	clz	r8,r8
80004f1e:	48 5a       	lddpc	r10,80004f30 <_get_interrupt_handler+0x34>
80004f20:	f4 09 00 39 	add	r9,r10,r9<<0x3
80004f24:	f0 08 11 1f 	rsub	r8,r8,31
80004f28:	72 19       	ld.w	r9,r9[0x4]
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	
	return (int_req)
80004f2a:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
80004f2e:	5e fc       	retal	r12
80004f30:	80 01       	ld.sh	r1,r0[0x0]
80004f32:	5a 50       	cp.w	r0,-27

80004f34 <tc_init_waveform>:


int tc_init_waveform(volatile avr32_tc_t *tc, const tc_waveform_opt_t *opt)
{
  // Check for valid input.
  if (opt->channel >= TC_NUMBER_OF_CHANNELS)
80004f34:	76 09       	ld.w	r9,r11[0x0]
80004f36:	58 29       	cp.w	r9,2
80004f38:	e0 88 00 03 	brls	80004f3e <tc_init_waveform+0xa>
80004f3c:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  // GENERATE SIGNALS: Waveform operating mode.
  tc->channel[opt->channel].cmr = opt->bswtrg << AVR32_TC_BSWTRG_OFFSET |
80004f3e:	76 18       	ld.w	r8,r11[0x4]
80004f40:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
80004f44:	af ba       	sbr	r10,0xf
80004f46:	10 9b       	mov	r11,r8
80004f48:	e6 1b c0 00 	andh	r11,0xc000,COH
80004f4c:	16 4a       	or	r10,r11
80004f4e:	10 9b       	mov	r11,r8
80004f50:	e6 1b 30 00 	andh	r11,0x3000,COH
80004f54:	16 4a       	or	r10,r11
80004f56:	10 9b       	mov	r11,r8
80004f58:	e6 1b 0c 00 	andh	r11,0xc00,COH
80004f5c:	16 4a       	or	r10,r11
80004f5e:	10 9b       	mov	r11,r8
80004f60:	e6 1b 03 00 	andh	r11,0x300,COH
80004f64:	16 4a       	or	r10,r11
80004f66:	10 9b       	mov	r11,r8
80004f68:	e6 1b 00 c0 	andh	r11,0xc0,COH
80004f6c:	16 4a       	or	r10,r11
80004f6e:	10 9b       	mov	r11,r8
80004f70:	e6 1b 00 30 	andh	r11,0x30,COH
80004f74:	16 4a       	or	r10,r11
80004f76:	10 9b       	mov	r11,r8
80004f78:	e6 1b 00 0c 	andh	r11,0xc,COH
80004f7c:	16 4a       	or	r10,r11
80004f7e:	10 9b       	mov	r11,r8
80004f80:	e6 1b 00 03 	andh	r11,0x3,COH
80004f84:	16 4a       	or	r10,r11
80004f86:	10 9b       	mov	r11,r8
80004f88:	e2 1b 60 00 	andl	r11,0x6000,COH
80004f8c:	16 4a       	or	r10,r11
80004f8e:	f7 d8 c1 81 	bfextu	r11,r8,0xc,0x1
80004f92:	f5 eb 10 ca 	or	r10,r10,r11<<0xc
80004f96:	10 9b       	mov	r11,r8
80004f98:	e2 1b 0c 00 	andl	r11,0xc00,COH
80004f9c:	16 4a       	or	r10,r11
80004f9e:	10 9b       	mov	r11,r8
80004fa0:	e2 1b 03 00 	andl	r11,0x300,COH
80004fa4:	16 4a       	or	r10,r11
80004fa6:	f7 d8 c0 e1 	bfextu	r11,r8,0x7,0x1
80004faa:	f5 eb 10 7a 	or	r10,r10,r11<<0x7
80004fae:	f7 d8 c0 c1 	bfextu	r11,r8,0x6,0x1
80004fb2:	f5 eb 10 6a 	or	r10,r10,r11<<0x6
80004fb6:	10 9b       	mov	r11,r8
80004fb8:	e2 1b 00 30 	andl	r11,0x30,COH
80004fbc:	16 4a       	or	r10,r11
80004fbe:	f1 d8 c0 61 	bfextu	r8,r8,0x3,0x1
80004fc2:	f5 e8 10 38 	or	r8,r10,r8<<0x3
80004fc6:	a5 69       	lsl	r9,0x4
80004fc8:	2f f9       	sub	r9,-1
80004fca:	f8 09 09 28 	st.w	r12[r9<<0x2],r8
80004fce:	5e fd       	retal	0

80004fd0 <tc_start>:


int tc_start(volatile avr32_tc_t *tc, unsigned int channel)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80004fd0:	58 2b       	cp.w	r11,2
80004fd2:	e0 88 00 03 	brls	80004fd8 <tc_start+0x8>
80004fd6:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  // Enable, reset and start the selected timer/counter channel.
  tc->channel[channel].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
80004fd8:	a7 6b       	lsl	r11,0x6
80004fda:	16 0c       	add	r12,r11
80004fdc:	30 58       	mov	r8,5
80004fde:	99 08       	st.w	r12[0x0],r8
80004fe0:	5e fd       	retal	0

80004fe2 <tc_read_sr>:


int tc_read_sr(volatile avr32_tc_t *tc, unsigned int channel)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80004fe2:	58 2b       	cp.w	r11,2
80004fe4:	e0 88 00 03 	brls	80004fea <tc_read_sr+0x8>
80004fe8:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  return tc->channel[channel].sr;
80004fea:	a7 6b       	lsl	r11,0x6
80004fec:	2e 0b       	sub	r11,-32
80004fee:	16 0c       	add	r12,r11
80004ff0:	78 0c       	ld.w	r12,r12[0x0]
}
80004ff2:	5e fc       	retal	r12

80004ff4 <tc_write_rc>:


int tc_write_rc(volatile avr32_tc_t *tc, unsigned int channel, unsigned short value)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80004ff4:	58 2b       	cp.w	r11,2
80004ff6:	e0 88 00 03 	brls	80004ffc <tc_write_rc+0x8>
80004ffa:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  // This function is only available in WAVEFORM mode.
  if (Tst_bits(tc->channel[channel].cmr, AVR32_TC_WAVE_MASK))
80004ffc:	f6 08 15 04 	lsl	r8,r11,0x4
80005000:	2f f8       	sub	r8,-1
80005002:	f8 08 03 28 	ld.w	r8,r12[r8<<0x2]
80005006:	e2 18 80 00 	andl	r8,0x8000,COH
8000500a:	c0 c0       	breq	80005022 <tc_write_rc+0x2e>
    Wr_bitfield(tc->channel[channel].rc, AVR32_TC_RC_MASK, value);
8000500c:	a7 6b       	lsl	r11,0x6
8000500e:	16 0c       	add	r12,r11
80005010:	2e 4c       	sub	r12,-28
80005012:	78 08       	ld.w	r8,r12[0x0]
80005014:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
80005018:	e0 18 00 00 	andl	r8,0x0
8000501c:	f3 e8 10 08 	or	r8,r9,r8
80005020:	99 08       	st.w	r12[0x0],r8

  return value;
80005022:	f9 da c0 10 	bfextu	r12,r10,0x0,0x10
}
80005026:	5e fc       	retal	r12

80005028 <tc_configure_interrupts>:
  return tc->channel[channel].imr;
}


int tc_configure_interrupts(volatile avr32_tc_t *tc, unsigned int channel, const tc_interrupt_t *bitfield)
{
80005028:	eb cd 40 fc 	pushm	r2-r7,lr
  bool global_interrupt_enabled = Is_global_interrupt_enabled();
8000502c:	e1 b9 00 00 	mfsr	r9,0x0

  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80005030:	58 2b       	cp.w	r11,2
80005032:	e0 88 00 04 	brls	8000503a <tc_configure_interrupts+0x12>
80005036:	e3 cf c0 fc 	ldm	sp++,r2-r7,pc,r12=-1
	return flags;
}

static inline bool cpu_irq_is_enabled_flags(irqflags_t flags)
{
	return !(flags & AVR32_SR_GM_MASK);
8000503a:	ee 19 00 01 	eorh	r9,0x1
8000503e:	f3 d9 c2 01 	bfextu	r9,r9,0x10,0x1
    return TC_INVALID_ARGUMENT;

  // Enable the appropriate interrupts.
  tc->channel[channel].ier = bitfield->etrgs << AVR32_TC_ETRGS_OFFSET |
80005042:	74 08       	ld.w	r8,r10[0x0]
80005044:	ef d8 c0 e1 	bfextu	r7,r8,0x7,0x1
80005048:	fd d8 c0 c1 	bfextu	lr,r8,0x6,0x1
8000504c:	a7 6e       	lsl	lr,0x6
8000504e:	fd e7 10 7e 	or	lr,lr,r7<<0x7
80005052:	ef d8 c0 01 	bfextu	r7,r8,0x0,0x1
80005056:	0e 4e       	or	lr,r7
80005058:	ef d8 c0 a1 	bfextu	r7,r8,0x5,0x1
8000505c:	fd e7 10 5e 	or	lr,lr,r7<<0x5
80005060:	ef d8 c0 81 	bfextu	r7,r8,0x4,0x1
80005064:	fd e7 10 4e 	or	lr,lr,r7<<0x4
80005068:	ef d8 c0 61 	bfextu	r7,r8,0x3,0x1
8000506c:	fd e7 10 3e 	or	lr,lr,r7<<0x3
80005070:	ef d8 c0 41 	bfextu	r7,r8,0x2,0x1
80005074:	fd e7 10 2e 	or	lr,lr,r7<<0x2
80005078:	f1 d8 c0 21 	bfextu	r8,r8,0x1,0x1
8000507c:	fd e8 10 18 	or	r8,lr,r8<<0x1
80005080:	f6 0e 15 06 	lsl	lr,r11,0x6
80005084:	f8 0e 00 0e 	add	lr,r12,lr
80005088:	2d ce       	sub	lr,-36
8000508a:	9d 08       	st.w	lr[0x0],r8
                             bitfield->cpas << AVR32_TC_CPAS_OFFSET |
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;

  // Disable the appropriate interrupts.
  if (global_interrupt_enabled) Disable_global_interrupt();
8000508c:	58 09       	cp.w	r9,0
8000508e:	c0 20       	breq	80005092 <tc_configure_interrupts+0x6a>
80005090:	d3 03       	ssrf	0x10
  tc->channel[channel].idr = (~bitfield->etrgs & 1) << AVR32_TC_ETRGS_OFFSET |
80005092:	74 08       	ld.w	r8,r10[0x0]
80005094:	f1 d8 c0 e1 	bfextu	r8,r8,0x7,0x1
80005098:	e0 65 00 80 	mov	r5,128
8000509c:	f9 b5 01 00 	movne	r5,0
                             (~bitfield->ldrbs & 1) << AVR32_TC_LDRBS_OFFSET |
800050a0:	74 08       	ld.w	r8,r10[0x0]
800050a2:	f1 d8 c0 c1 	bfextu	r8,r8,0x6,0x1
800050a6:	f9 b4 00 40 	moveq	r4,64
800050aa:	f9 b4 01 00 	movne	r4,0
                             (~bitfield->ldras & 1) << AVR32_TC_LDRAS_OFFSET |
800050ae:	74 08       	ld.w	r8,r10[0x0]
800050b0:	f1 d8 c0 a1 	bfextu	r8,r8,0x5,0x1
800050b4:	f9 b3 00 20 	moveq	r3,32
800050b8:	f9 b3 01 00 	movne	r3,0
                             (~bitfield->cpcs & 1) << AVR32_TC_CPCS_OFFSET |
800050bc:	74 08       	ld.w	r8,r10[0x0]
800050be:	f1 d8 c0 81 	bfextu	r8,r8,0x4,0x1
800050c2:	f9 b2 00 10 	moveq	r2,16
800050c6:	f9 b2 01 00 	movne	r2,0
                             (~bitfield->cpbs & 1) << AVR32_TC_CPBS_OFFSET |
800050ca:	74 08       	ld.w	r8,r10[0x0]
800050cc:	f1 d8 c0 61 	bfextu	r8,r8,0x3,0x1
800050d0:	f9 b6 00 08 	moveq	r6,8
800050d4:	f9 b6 01 00 	movne	r6,0
                             (~bitfield->cpas & 1) << AVR32_TC_CPAS_OFFSET |
800050d8:	74 08       	ld.w	r8,r10[0x0]
800050da:	f1 d8 c0 41 	bfextu	r8,r8,0x2,0x1
800050de:	f9 b7 00 04 	moveq	r7,4
800050e2:	f9 b7 01 00 	movne	r7,0
                             (~bitfield->lovrs & 1) << AVR32_TC_LOVRS_OFFSET |
800050e6:	74 08       	ld.w	r8,r10[0x0]
800050e8:	f1 d8 c0 21 	bfextu	r8,r8,0x1,0x1
800050ec:	f9 be 00 02 	moveq	lr,2
800050f0:	f9 be 01 00 	movne	lr,0
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;

  // Disable the appropriate interrupts.
  if (global_interrupt_enabled) Disable_global_interrupt();
  tc->channel[channel].idr = (~bitfield->etrgs & 1) << AVR32_TC_ETRGS_OFFSET |
800050f4:	74 08       	ld.w	r8,r10[0x0]
800050f6:	ec 18 00 01 	eorl	r8,0x1
800050fa:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800050fe:	eb e8 10 08 	or	r8,r5,r8
80005102:	08 48       	or	r8,r4
80005104:	06 48       	or	r8,r3
80005106:	04 48       	or	r8,r2
80005108:	0c 48       	or	r8,r6
8000510a:	0e 48       	or	r8,r7
8000510c:	1c 48       	or	r8,lr
8000510e:	f6 0a 15 06 	lsl	r10,r11,0x6
80005112:	f8 0a 00 0a 	add	r10,r12,r10
80005116:	2d 8a       	sub	r10,-40
80005118:	95 08       	st.w	r10[0x0],r8
                             (~bitfield->cpcs & 1) << AVR32_TC_CPCS_OFFSET |
                             (~bitfield->cpbs & 1) << AVR32_TC_CPBS_OFFSET |
                             (~bitfield->cpas & 1) << AVR32_TC_CPAS_OFFSET |
                             (~bitfield->lovrs & 1) << AVR32_TC_LOVRS_OFFSET |
                             (~bitfield->covfs & 1) << AVR32_TC_COVFS_OFFSET;
  tc->channel[channel].sr;
8000511a:	a7 6b       	lsl	r11,0x6
8000511c:	2e 0b       	sub	r11,-32
8000511e:	16 0c       	add	r12,r11
80005120:	78 08       	ld.w	r8,r12[0x0]
  if (global_interrupt_enabled) Enable_global_interrupt();
80005122:	58 09       	cp.w	r9,0
80005124:	c0 31       	brne	8000512a <tc_configure_interrupts+0x102>
80005126:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0
8000512a:	d5 03       	csrf	0x10
8000512c:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0

80005130 <twi_master_interrupt_handler>:
/*! \brief TWI interrupt handler.
 */
ISR(twi_master_interrupt_handler, CONF_TWI_IRQ_GROUP, CONF_TWI_IRQ_LEVEL)
{
	// get masked status register value
	int status = twi_inst->sr & twi_it_mask;
80005130:	4a 78       	lddpc	r8,800051cc <twi_master_interrupt_handler+0x9c>
80005132:	70 08       	ld.w	r8,r8[0x0]
80005134:	70 89       	ld.w	r9,r8[0x20]
80005136:	4a 7a       	lddpc	r10,800051d0 <twi_master_interrupt_handler+0xa0>
80005138:	74 0a       	ld.w	r10,r10[0x0]
8000513a:	f5 e9 00 09 	and	r9,r10,r9

	// this is a NACK
	if (status & AVR32_TWI_SR_NACK_MASK) {
8000513e:	12 9a       	mov	r10,r9
80005140:	e2 1a 01 00 	andl	r10,0x100,COH
80005144:	c3 91       	brne	800051b6 <twi_master_interrupt_handler+0x86>
		goto nack;
	}
	// this is a RXRDY
	else if (status & AVR32_TWI_SR_RXRDY_MASK) {
80005146:	12 9a       	mov	r10,r9
80005148:	e2 1a 00 02 	andl	r10,0x2,COH
8000514c:	c1 70       	breq	8000517a <twi_master_interrupt_handler+0x4a>
		// get data from Receive Holding Register
		*twi_rx_data = twi_inst->rhr;
8000514e:	4a 29       	lddpc	r9,800051d4 <twi_master_interrupt_handler+0xa4>
80005150:	72 0a       	ld.w	r10,r9[0x0]
80005152:	70 cb       	ld.w	r11,r8[0x30]
80005154:	b4 8b       	st.b	r10[0x0],r11
		twi_rx_data++;
80005156:	72 0a       	ld.w	r10,r9[0x0]
80005158:	2f fa       	sub	r10,-1
8000515a:	93 0a       	st.w	r9[0x0],r10
		// last byte to receive
		if (--twi_rx_nb_bytes == 1) {
8000515c:	49 f9       	lddpc	r9,800051d8 <twi_master_interrupt_handler+0xa8>
8000515e:	72 0a       	ld.w	r10,r9[0x0]
80005160:	20 1a       	sub	r10,1
80005162:	93 0a       	st.w	r9[0x0],r10
80005164:	72 09       	ld.w	r9,r9[0x0]
			// set stop bit
			twi_inst->cr = AVR32_TWI_STOP_MASK;
80005166:	58 19       	cp.w	r9,1
80005168:	f9 b9 00 02 	moveq	r9,2
8000516c:	f1 f9 0a 00 	st.weq	r8[0x0],r9
		}
		// receive complete
		if (twi_rx_nb_bytes == 0) {
80005170:	49 a9       	lddpc	r9,800051d8 <twi_master_interrupt_handler+0xa8>
80005172:	72 09       	ld.w	r9,r9[0x0]
80005174:	58 09       	cp.w	r9,0
80005176:	c2 30       	breq	800051bc <twi_master_interrupt_handler+0x8c>
80005178:	d6 03       	rete
			// finish the receive operation
			goto complete;
		}
	}
	// this is a TXRDY
	else if (status & AVR32_TWI_SR_TXRDY_MASK) {
8000517a:	12 9a       	mov	r10,r9
8000517c:	e2 1a 00 04 	andl	r10,0x4,COH
80005180:	c1 70       	breq	800051ae <twi_master_interrupt_handler+0x7e>
		// decrease transmitted bytes number
		twi_tx_nb_bytes--;
80005182:	49 79       	lddpc	r9,800051dc <twi_master_interrupt_handler+0xac>
80005184:	72 0a       	ld.w	r10,r9[0x0]
80005186:	20 1a       	sub	r10,1
80005188:	93 0a       	st.w	r9[0x0],r10
		// no more bytes to transmit
		if (twi_tx_nb_bytes <= 0) {
8000518a:	72 09       	ld.w	r9,r9[0x0]
8000518c:	58 09       	cp.w	r9,0
8000518e:	e0 89 00 0a 	brgt	800051a2 <twi_master_interrupt_handler+0x72>
			// enable TXCOMP IT and unmask all others IT
			twi_it_mask = AVR32_TWI_IER_TXCOMP_MASK;
80005192:	49 09       	lddpc	r9,800051d0 <twi_master_interrupt_handler+0xa0>
80005194:	30 1a       	mov	r10,1
80005196:	93 0a       	st.w	r9[0x0],r10
			twi_inst->idr = ~0UL;
80005198:	3f fa       	mov	r10,-1
8000519a:	91 aa       	st.w	r8[0x28],r10
			twi_inst->ier = twi_it_mask;
8000519c:	72 09       	ld.w	r9,r9[0x0]
8000519e:	91 99       	st.w	r8[0x24],r9
800051a0:	d6 03       	rete
		} else {
			// put the byte in the Transmit Holding Register
			twi_inst->thr = *twi_tx_data++;
800051a2:	49 0a       	lddpc	r10,800051e0 <twi_master_interrupt_handler+0xb0>
800051a4:	74 09       	ld.w	r9,r10[0x0]
800051a6:	13 3b       	ld.ub	r11,r9++
800051a8:	91 db       	st.w	r8[0x34],r11
800051aa:	95 09       	st.w	r10[0x0],r9
800051ac:	d6 03       	rete
		}
	}
	// this is a TXCOMP
	else if (status & AVR32_TWI_SR_TXCOMP_MASK) {
800051ae:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
800051b2:	c0 51       	brne	800051bc <twi_master_interrupt_handler+0x8c>
800051b4:	d6 03       	rete
	}

	return;

nack:
	twi_nack = true;
800051b6:	30 1a       	mov	r10,1
800051b8:	48 b9       	lddpc	r9,800051e4 <twi_master_interrupt_handler+0xb4>
800051ba:	b2 8a       	st.b	r9[0x0],r10

complete:
	// disable all interrupts
	twi_inst->idr = ~0UL;
800051bc:	3f f9       	mov	r9,-1
800051be:	91 a9       	st.w	r8[0x28],r9
	twi_inst->sr;
800051c0:	70 88       	ld.w	r8,r8[0x20]
	twi_busy = false;
800051c2:	30 09       	mov	r9,0
800051c4:	48 98       	lddpc	r8,800051e8 <twi_master_interrupt_handler+0xb8>
800051c6:	b0 89       	st.b	r8[0x0],r9
800051c8:	d6 03       	rete
800051ca:	00 00       	add	r0,r0
800051cc:	00 00       	add	r0,r0
800051ce:	0c 2c       	rsub	r12,r6
800051d0:	00 00       	add	r0,r0
800051d2:	0c 28       	rsub	r8,r6
800051d4:	00 00       	add	r0,r0
800051d6:	0c 38       	cp.w	r8,r6
800051d8:	00 00       	add	r0,r0
800051da:	0c 34       	cp.w	r4,r6
800051dc:	00 00       	add	r0,r0
800051de:	0c 24       	rsub	r4,r6
800051e0:	00 00       	add	r0,r0
800051e2:	0c 30       	cp.w	r0,r6
800051e4:	00 00       	add	r0,r0
800051e6:	0c 21       	rsub	r1,r6
800051e8:	00 00       	add	r0,r0
800051ea:	0c 20       	rsub	r0,r6

800051ec <twi_master_init>:
	return TWI_SUCCESS;
}


int twi_master_init(volatile avr32_twi_t *twi, const twi_options_t *opt)
{
800051ec:	eb cd 40 e0 	pushm	r5-r7,lr
800051f0:	18 97       	mov	r7,r12
800051f2:	16 95       	mov	r5,r11
	irqflags_t flags = sysreg_read(AVR32_SR);
800051f4:	e1 b8 00 00 	mfsr	r8,0x0
	int status = TWI_SUCCESS;

	// Set pointer to TWIM instance for IT
	twi_inst = twi;
800051f8:	49 f9       	lddpc	r9,80005274 <twi_master_init+0x88>
800051fa:	93 0c       	st.w	r9[0x0],r12

	// Disable TWI interrupts
	cpu_irq_disable();
800051fc:	d3 03       	ssrf	0x10
	twi->idr = ~0UL;
800051fe:	3f f9       	mov	r9,-1
80005200:	99 a9       	st.w	r12[0x28],r9
	twi->sr;
80005202:	78 89       	ld.w	r9,r12[0x20]

	// Reset TWI
	twi->cr = AVR32_TWI_CR_SWRST_MASK;
80005204:	e0 69 00 80 	mov	r9,128
80005208:	99 09       	st.w	r12[0x0],r9
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
8000520a:	e6 18 00 01 	andh	r8,0x1,COH
8000520e:	c0 21       	brne	80005212 <twi_master_init+0x26>
      cpu_irq_enable();
80005210:	d5 03       	csrf	0x10
	cpu_irq_restore(flags);

	// Dummy read in SR
	twi->sr;
80005212:	6e 88       	ld.w	r8,r7[0x20]

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80005214:	e1 b6 00 00 	mfsr	r6,0x0
	cpu_irq_disable();
80005218:	d3 03       	ssrf	0x10
	
	// register Register twim_master_interrupt_handler interrupt
	// on level CONF_TWI_IRQ_LEVEL
	flags = cpu_irq_save();

	irq_register_handler(&twi_master_interrupt_handler, CONF_TWI_IRQ_LINE, CONF_TWI_IRQ_LEVEL);
8000521a:	30 3a       	mov	r10,3
8000521c:	e0 6b 01 60 	mov	r11,352
80005220:	49 6c       	lddpc	r12,80005278 <twi_master_init+0x8c>
80005222:	f0 1f 00 17 	mcall	8000527c <twi_master_init+0x90>
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80005226:	e6 16 00 01 	andh	r6,0x1,COH
8000522a:	c0 21       	brne	8000522e <twi_master_init+0x42>
      cpu_irq_enable();
8000522c:	d5 03       	csrf	0x10
		unsigned long pba_hz)
{
	unsigned int ckdiv = 0;
	unsigned int c_lh_div;

	c_lh_div = pba_hz / (speed * 2) - 4;
8000522e:	6a 19       	ld.w	r9,r5[0x4]
80005230:	a1 79       	lsl	r9,0x1
80005232:	6a 08       	ld.w	r8,r5[0x0]
80005234:	f0 09 0d 08 	divu	r8,r8,r9
80005238:	20 48       	sub	r8,4

	// cldiv must fit in 8 bits, ckdiv must fit in 3 bits
	while ((c_lh_div > 0xFF) && (ckdiv < 0x7)) {
8000523a:	e0 48 00 ff 	cp.w	r8,255
8000523e:	e0 8b 00 04 	brhi	80005246 <twi_master_init+0x5a>
80005242:	30 09       	mov	r9,0
80005244:	c0 f8       	rjmp	80005262 <twi_master_init+0x76>
80005246:	30 09       	mov	r9,0
80005248:	30 0c       	mov	r12,0
		// increase clock divider
		ckdiv++;
8000524a:	2f f9       	sub	r9,-1

		// divide cldiv value
		c_lh_div /= 2;
8000524c:	a1 98       	lsr	r8,0x1
	unsigned int c_lh_div;

	c_lh_div = pba_hz / (speed * 2) - 4;

	// cldiv must fit in 8 bits, ckdiv must fit in 3 bits
	while ((c_lh_div > 0xFF) && (ckdiv < 0x7)) {
8000524e:	e0 48 00 ff 	cp.w	r8,255
80005252:	5f bb       	srhi	r11
80005254:	58 69       	cp.w	r9,6
80005256:	5f 8a       	srls	r10
80005258:	f7 ea 00 0a 	and	r10,r11,r10
8000525c:	f8 0a 18 00 	cp.b	r10,r12
80005260:	cf 51       	brne	8000524a <twi_master_init+0x5e>
		// divide cldiv value
		c_lh_div /= 2;
	}

	// set clock waveform generator register
	twi->cwgr = ((c_lh_div << AVR32_TWI_CWGR_CLDIV_OFFSET) |
80005262:	b1 69       	lsl	r9,0x10
80005264:	f3 e8 10 89 	or	r9,r9,r8<<0x8
80005268:	f3 e8 10 08 	or	r8,r9,r8
8000526c:	8f 48       	st.w	r7[0x10],r8

	//Probe the component
	//status = twi_probe(twi, opt->chip);

	return status;
}
8000526e:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
80005272:	00 00       	add	r0,r0
80005274:	00 00       	add	r0,r0
80005276:	0c 2c       	rsub	r12,r6
80005278:	80 00       	ld.sh	r0,r0[0x0]
8000527a:	51 30       	stdsp	sp[0x4c],r0
8000527c:	80 00       	ld.sh	r0,r0[0x0]
8000527e:	4e 28       	lddpc	r8,80005404 <usart_init_rs232+0x48>

80005280 <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
80005280:	d4 01       	pushm	lr
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
80005282:	f6 08 15 04 	lsl	r8,r11,0x4
80005286:	14 38       	cp.w	r8,r10
80005288:	f9 b8 08 10 	movls	r8,16
8000528c:	f9 b8 0b 08 	movhi	r8,8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
80005290:	f0 0b 02 4b 	mul	r11,r8,r11
80005294:	f6 09 16 01 	lsr	r9,r11,0x1
80005298:	f2 0a 00 3a 	add	r10,r9,r10<<0x3
8000529c:	f4 0b 0d 0a 	divu	r10,r10,r11
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
800052a0:	f4 09 16 03 	lsr	r9,r10,0x3
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
800052a4:	f2 cb 00 01 	sub	r11,r9,1
800052a8:	e0 4b ff fe 	cp.w	r11,65534
800052ac:	e0 88 00 03 	brls	800052b2 <usart_set_async_baudrate+0x32>
800052b0:	da 0a       	popm	pc,r12=1
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
800052b2:	78 1b       	ld.w	r11,r12[0x4]
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
800052b4:	e8 6e 00 00 	mov	lr,524288
800052b8:	59 08       	cp.w	r8,16
800052ba:	fc 08 17 10 	movne	r8,lr
800052be:	f9 b8 00 00 	moveq	r8,0
800052c2:	e4 1b ff f7 	andh	r11,0xfff7
800052c6:	e0 1b fe cf 	andl	r11,0xfecf
800052ca:	16 48       	or	r8,r11
800052cc:	99 18       	st.w	r12[0x4],r8
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
800052ce:	f5 da c0 03 	bfextu	r10,r10,0x0,0x3
800052d2:	f3 ea 11 09 	or	r9,r9,r10<<0x10
800052d6:	99 89       	st.w	r12[0x20],r9
800052d8:	d8 0a       	popm	pc,r12=0

800052da <usart_write_char>:
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
800052da:	78 58       	ld.w	r8,r12[0x14]
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
  if (usart_tx_ready(usart))
800052dc:	e2 18 00 02 	andl	r8,0x2,COH
800052e0:	c0 31       	brne	800052e6 <usart_write_char+0xc>
800052e2:	30 2c       	mov	r12,2
800052e4:	5e fc       	retal	r12
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
800052e6:	f7 db c0 09 	bfextu	r11,r11,0x0,0x9
800052ea:	99 7b       	st.w	r12[0x1c],r11
800052ec:	5e fd       	retal	0
800052ee:	d7 03       	nop

800052f0 <usart_putchar>:
    return USART_TX_BUSY;
}


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
800052f0:	eb cd 40 e0 	pushm	r5-r7,lr
800052f4:	18 96       	mov	r6,r12
800052f6:	16 95       	mov	r5,r11
800052f8:	e0 67 27 0f 	mov	r7,9999
800052fc:	c0 68       	rjmp	80005308 <usart_putchar+0x18>
  int timeout = USART_DEFAULT_TIMEOUT;

  do
  {
    if (!timeout--) return USART_FAILURE;
800052fe:	58 07       	cp.w	r7,0
80005300:	c0 31       	brne	80005306 <usart_putchar+0x16>
80005302:	e3 cf c0 e0 	ldm	sp++,r5-r7,pc,r12=-1
80005306:	20 17       	sub	r7,1
  } while (usart_write_char(usart, c) != USART_SUCCESS);
80005308:	0a 9b       	mov	r11,r5
8000530a:	0c 9c       	mov	r12,r6
8000530c:	f0 1f 00 03 	mcall	80005318 <usart_putchar+0x28>
80005310:	cf 71       	brne	800052fe <usart_putchar+0xe>

  return USART_SUCCESS;
}
80005312:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80005316:	00 00       	add	r0,r0
80005318:	80 00       	ld.sh	r0,r0[0x0]
8000531a:	52 da       	stdsp	sp[0xb4],r10

8000531c <usart_read_char>:

int usart_read_char(volatile avr32_usart_t *usart, int *c)
{
  // Check for errors: frame, parity and overrun. In RS485 mode, a parity error
  // would mean that an address char has been received.
  if (usart->csr & (AVR32_USART_CSR_OVRE_MASK |
8000531c:	78 58       	ld.w	r8,r12[0x14]
8000531e:	e2 18 00 e0 	andl	r8,0xe0,COH
80005322:	c0 30       	breq	80005328 <usart_read_char+0xc>
80005324:	30 4c       	mov	r12,4
80005326:	5e fc       	retal	r12
 *
 * \return \c 1 if the USART Receive Holding Register is full, otherwise \c 0.
 */
__always_inline static int usart_test_hit(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_RXRDY_MASK) != 0;
80005328:	78 58       	ld.w	r8,r12[0x14]
                    AVR32_USART_CSR_FRAME_MASK |
                    AVR32_USART_CSR_PARE_MASK))
    return USART_RX_ERROR;

  // No error; if we really did receive a char, read it and return SUCCESS.
  if (usart_test_hit(usart))
8000532a:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000532e:	c0 31       	brne	80005334 <usart_read_char+0x18>
80005330:	30 3c       	mov	r12,3
80005332:	5e fc       	retal	r12
  {
    *c = (usart->rhr & AVR32_USART_RHR_RXCHR_MASK) >> AVR32_USART_RHR_RXCHR_OFFSET;
80005334:	78 68       	ld.w	r8,r12[0x18]
80005336:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
8000533a:	97 08       	st.w	r11[0x0],r8
8000533c:	5e fd       	retal	0
8000533e:	d7 03       	nop

80005340 <usart_getchar>:
    return USART_RX_EMPTY;
}


int usart_getchar(volatile avr32_usart_t *usart)
{
80005340:	eb cd 40 c0 	pushm	r6-r7,lr
80005344:	20 1d       	sub	sp,4
80005346:	18 96       	mov	r6,r12
  int c, ret;

  while ((ret = usart_read_char(usart, &c)) == USART_RX_EMPTY);
80005348:	1a 97       	mov	r7,sp
8000534a:	1a 9b       	mov	r11,sp
8000534c:	0c 9c       	mov	r12,r6
8000534e:	f0 1f 00 07 	mcall	80005368 <usart_getchar+0x28>
80005352:	58 3c       	cp.w	r12,3
80005354:	cf b0       	breq	8000534a <usart_getchar+0xa>

  if (ret == USART_RX_ERROR)
80005356:	58 4c       	cp.w	r12,4
80005358:	f9 bc 00 ff 	moveq	r12,-1
    return USART_FAILURE;

  return c;
8000535c:	fb fc 10 00 	ld.wne	r12,sp[0x0]
}
80005360:	2f fd       	sub	sp,-4
80005362:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005366:	00 00       	add	r0,r0
80005368:	80 00       	ld.sh	r0,r0[0x0]
8000536a:	53 1c       	stdsp	sp[0xc4],r12

8000536c <usart_write_line>:


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
8000536c:	eb cd 40 c0 	pushm	r6-r7,lr
80005370:	18 96       	mov	r6,r12
80005372:	16 97       	mov	r7,r11
  while (*string != '\0')
80005374:	17 8b       	ld.ub	r11,r11[0x0]
80005376:	58 0b       	cp.w	r11,0
80005378:	c0 80       	breq	80005388 <usart_write_line+0x1c>
    usart_putchar(usart, *string++);
8000537a:	2f f7       	sub	r7,-1
8000537c:	0c 9c       	mov	r12,r6
8000537e:	f0 1f 00 04 	mcall	8000538c <usart_write_line+0x20>
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
80005382:	0f 8b       	ld.ub	r11,r7[0x0]
80005384:	58 0b       	cp.w	r11,0
80005386:	cf a1       	brne	8000537a <usart_write_line+0xe>
80005388:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000538c:	80 00       	ld.sh	r0,r0[0x0]
8000538e:	52 f0       	stdsp	sp[0xbc],r0

80005390 <usart_reset>:
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
80005390:	e1 b8 00 00 	mfsr	r8,0x0

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
80005394:	e6 18 00 01 	andh	r8,0x1,COH
80005398:	c0 71       	brne	800053a6 <usart_reset+0x16>
8000539a:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
8000539c:	3f f8       	mov	r8,-1
8000539e:	99 38       	st.w	r12[0xc],r8
  usart->csr;
800053a0:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
800053a2:	d5 03       	csrf	0x10
800053a4:	c0 48       	rjmp	800053ac <usart_reset+0x1c>
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
  usart->idr = 0xFFFFFFFF;
800053a6:	3f f8       	mov	r8,-1
800053a8:	99 38       	st.w	r12[0xc],r8
  usart->csr;
800053aa:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
800053ac:	30 08       	mov	r8,0
800053ae:	99 18       	st.w	r12[0x4],r8
  usart->rtor = 0;
800053b0:	99 98       	st.w	r12[0x24],r8
  usart->ttgr = 0;
800053b2:	99 a8       	st.w	r12[0x28],r8

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
800053b4:	ea 68 61 0c 	mov	r8,680204
800053b8:	99 08       	st.w	r12[0x0],r8
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
800053ba:	5e fc       	retal	r12

800053bc <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
800053bc:	eb cd 40 e0 	pushm	r5-r7,lr
800053c0:	18 96       	mov	r6,r12
800053c2:	16 97       	mov	r7,r11
800053c4:	14 95       	mov	r5,r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
800053c6:	f0 1f 00 2f 	mcall	80005480 <usart_init_rs232+0xc4>

  // Check input values.
  if (!opt || // Null pointer.
800053ca:	58 07       	cp.w	r7,0
800053cc:	c5 80       	breq	8000547c <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
800053ce:	0f c8       	ld.ub	r8,r7[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
800053d0:	30 49       	mov	r9,4
800053d2:	f2 08 18 00 	cp.b	r8,r9
800053d6:	e0 88 00 53 	brls	8000547c <usart_init_rs232+0xc0>
800053da:	30 99       	mov	r9,9
800053dc:	f2 08 18 00 	cp.b	r8,r9
800053e0:	e0 8b 00 4e 	brhi	8000547c <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
800053e4:	0f d9       	ld.ub	r9,r7[0x5]
800053e6:	30 78       	mov	r8,7
800053e8:	f0 09 18 00 	cp.b	r9,r8
800053ec:	e0 8b 00 48 	brhi	8000547c <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
800053f0:	8e 39       	ld.sh	r9,r7[0x6]
800053f2:	e0 68 01 01 	mov	r8,257
800053f6:	f0 09 19 00 	cp.h	r9,r8
800053fa:	e0 8b 00 41 	brhi	8000547c <usart_init_rs232+0xc0>
      opt->channelmode > 3 ||
800053fe:	ef 39 00 08 	ld.ub	r9,r7[8]
80005402:	30 38       	mov	r8,3
80005404:	f0 09 18 00 	cp.b	r9,r8
80005408:	e0 8b 00 3a 	brhi	8000547c <usart_init_rs232+0xc0>
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
8000540c:	0a 9a       	mov	r10,r5
8000540e:	6e 0b       	ld.w	r11,r7[0x0]
80005410:	0c 9c       	mov	r12,r6
80005412:	f0 1f 00 1d 	mcall	80005484 <usart_init_rs232+0xc8>
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80005416:	58 1c       	cp.w	r12,1
80005418:	c3 20       	breq	8000547c <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;

  if (opt->charlength == 9)
8000541a:	0f c8       	ld.ub	r8,r7[0x4]
8000541c:	30 99       	mov	r9,9
8000541e:	f2 08 18 00 	cp.b	r8,r9
80005422:	c0 51       	brne	8000542c <usart_init_rs232+0x70>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
80005424:	6c 18       	ld.w	r8,r6[0x4]
80005426:	b1 b8       	sbr	r8,0x11
80005428:	8d 18       	st.w	r6[0x4],r8
8000542a:	c0 68       	rjmp	80005436 <usart_init_rs232+0x7a>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
8000542c:	6c 19       	ld.w	r9,r6[0x4]
8000542e:	20 58       	sub	r8,5
80005430:	f3 e8 10 68 	or	r8,r9,r8<<0x6
80005434:	8d 18       	st.w	r6[0x4],r8
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
80005436:	6c 19       	ld.w	r9,r6[0x4]
80005438:	ef 3a 00 08 	ld.ub	r10,r7[8]
8000543c:	0f d8       	ld.ub	r8,r7[0x5]
8000543e:	a9 78       	lsl	r8,0x9
80005440:	f1 ea 10 e8 	or	r8,r8,r10<<0xe
80005444:	12 48       	or	r8,r9
80005446:	8d 18       	st.w	r6[0x4],r8
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
80005448:	8e 38       	ld.sh	r8,r7[0x6]
8000544a:	30 29       	mov	r9,2
8000544c:	f2 08 19 00 	cp.h	r8,r9
80005450:	e0 88 00 09 	brls	80005462 <usart_init_rs232+0xa6>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
80005454:	6c 18       	ld.w	r8,r6[0x4]
80005456:	ad b8       	sbr	r8,0xd
80005458:	8d 18       	st.w	r6[0x4],r8
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
8000545a:	8e b8       	ld.uh	r8,r7[0x6]
8000545c:	20 28       	sub	r8,2
8000545e:	8d a8       	st.w	r6[0x28],r8
80005460:	c0 68       	rjmp	8000546c <usart_init_rs232+0xb0>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
80005462:	6c 19       	ld.w	r9,r6[0x4]
80005464:	5c 78       	castu.h	r8
80005466:	f3 e8 10 c8 	or	r8,r9,r8<<0xc
8000546a:	8d 18       	st.w	r6[0x4],r8

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
8000546c:	6c 18       	ld.w	r8,r6[0x4]
8000546e:	e0 18 ff f0 	andl	r8,0xfff0
80005472:	8d 18       	st.w	r6[0x4],r8
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
80005474:	35 08       	mov	r8,80
80005476:	8d 08       	st.w	r6[0x0],r8
80005478:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
8000547c:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
80005480:	80 00       	ld.sh	r0,r0[0x0]
80005482:	53 90       	stdsp	sp[0xe4],r0
80005484:	80 00       	ld.sh	r0,r0[0x0]
80005486:	52 80       	stdsp	sp[0xa0],r0

80005488 <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
80005488:	f8 c8 ff f8 	sub	r8,r12,-8
8000548c:	99 18       	st.w	r12[0x4],r8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
8000548e:	3f f9       	mov	r9,-1
80005490:	99 29       	st.w	r12[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
80005492:	99 38       	st.w	r12[0xc],r8
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
80005494:	99 48       	st.w	r12[0x10],r8

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
80005496:	30 08       	mov	r8,0
80005498:	99 08       	st.w	r12[0x0],r8
}
8000549a:	5e fc       	retal	r12

8000549c <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
8000549c:	30 08       	mov	r8,0
8000549e:	99 48       	st.w	r12[0x10],r8
}
800054a0:	5e fc       	retal	r12

800054a2 <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
800054a2:	78 18       	ld.w	r8,r12[0x4]

	pxNewListItem->pxNext = pxIndex->pxNext;
800054a4:	70 19       	ld.w	r9,r8[0x4]
800054a6:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
800054a8:	78 19       	ld.w	r9,r12[0x4]
800054aa:	97 29       	st.w	r11[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
800054ac:	70 19       	ld.w	r9,r8[0x4]
800054ae:	93 2b       	st.w	r9[0x8],r11
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
800054b0:	91 1b       	st.w	r8[0x4],r11
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
800054b2:	99 1b       	st.w	r12[0x4],r11

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
800054b4:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
800054b6:	78 08       	ld.w	r8,r12[0x0]
800054b8:	2f f8       	sub	r8,-1
800054ba:	99 08       	st.w	r12[0x0],r8
}
800054bc:	5e fc       	retal	r12

800054be <vListInsert>:
{
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
800054be:	76 0a       	ld.w	r10,r11[0x0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
800054c0:	5b fa       	cp.w	r10,-1
800054c2:	c0 31       	brne	800054c8 <vListInsert+0xa>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
800054c4:	78 48       	ld.w	r8,r12[0x10]
800054c6:	c0 c8       	rjmp	800054de <vListInsert+0x20>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
800054c8:	f8 c8 ff f8 	sub	r8,r12,-8
800054cc:	70 19       	ld.w	r9,r8[0x4]
800054ce:	72 09       	ld.w	r9,r9[0x0]
800054d0:	12 3a       	cp.w	r10,r9
800054d2:	c0 63       	brcs	800054de <vListInsert+0x20>
800054d4:	70 18       	ld.w	r8,r8[0x4]
800054d6:	70 19       	ld.w	r9,r8[0x4]
800054d8:	72 09       	ld.w	r9,r9[0x0]
800054da:	12 3a       	cp.w	r10,r9
800054dc:	cf c2       	brcc	800054d4 <vListInsert+0x16>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
800054de:	70 19       	ld.w	r9,r8[0x4]
800054e0:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
800054e2:	93 2b       	st.w	r9[0x8],r11
	pxNewListItem->pxPrevious = pxIterator;
800054e4:	97 28       	st.w	r11[0x8],r8
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
800054e6:	91 1b       	st.w	r8[0x4],r11

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
800054e8:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
800054ea:	78 08       	ld.w	r8,r12[0x0]
800054ec:	2f f8       	sub	r8,-1
800054ee:	99 08       	st.w	r12[0x0],r8
}
800054f0:	5e fc       	retal	r12

800054f2 <vListRemove>:

void vListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
800054f2:	78 18       	ld.w	r8,r12[0x4]
800054f4:	78 29       	ld.w	r9,r12[0x8]
800054f6:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
800054f8:	78 28       	ld.w	r8,r12[0x8]
800054fa:	78 19       	ld.w	r9,r12[0x4]
800054fc:	91 19       	st.w	r8[0x4],r9

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
800054fe:	78 48       	ld.w	r8,r12[0x10]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
80005500:	70 19       	ld.w	r9,r8[0x4]
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
80005502:	18 39       	cp.w	r9,r12
80005504:	f9 f9 00 02 	ld.weq	r9,r12[0x8]
80005508:	f1 f9 0a 01 	st.weq	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
8000550c:	30 09       	mov	r9,0
8000550e:	99 49       	st.w	r12[0x10],r9
	( pxList->uxNumberOfItems )--;
80005510:	70 09       	ld.w	r9,r8[0x0]
80005512:	20 19       	sub	r9,1
80005514:	91 09       	st.w	r8[0x0],r9
}
80005516:	5e fc       	retal	r12

80005518 <pxPortInitialiseStack>:
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x08080808;					/* R8 */
80005518:	e0 68 08 08 	mov	r8,2056
8000551c:	ea 18 08 08 	orh	r8,0x808
80005520:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x09090909;					/* R9 */
80005522:	e0 68 09 09 	mov	r8,2313
80005526:	ea 18 09 09 	orh	r8,0x909
8000552a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0A0A0A0A;					/* R10 */
8000552c:	e0 68 0a 0a 	mov	r8,2570
80005530:	ea 18 0a 0a 	orh	r8,0xa0a
80005534:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0B0B0B0B;					/* R11 */
80005536:	e0 68 0b 0b 	mov	r8,2827
8000553a:	ea 18 0b 0b 	orh	r8,0xb0b
8000553e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pvParameters;					/* R12 */
80005540:	18 da       	st.w	--r12,r10
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xDEADBEEF;					/* R14/LR */
80005542:	e0 68 be ef 	mov	r8,48879
80005546:	ea 18 de ad 	orh	r8,0xdead
8000554a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
8000554c:	18 db       	st.w	--r12,r11
	*pxTopOfStack-- = ( portSTACK_TYPE ) portINITIAL_SR;				/* SR */
8000554e:	fc 18 00 40 	movh	r8,0x40
80005552:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xFF0000FF;					/* R0 */
80005554:	e0 68 00 ff 	mov	r8,255
80005558:	ea 18 ff 00 	orh	r8,0xff00
8000555c:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x01010101;					/* R1 */
8000555e:	e0 68 01 01 	mov	r8,257
80005562:	ea 18 01 01 	orh	r8,0x101
80005566:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x02020202;					/* R2 */
80005568:	e0 68 02 02 	mov	r8,514
8000556c:	ea 18 02 02 	orh	r8,0x202
80005570:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x03030303;					/* R3 */
80005572:	e0 68 03 03 	mov	r8,771
80005576:	ea 18 03 03 	orh	r8,0x303
8000557a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x04040404;					/* R4 */
8000557c:	e0 68 04 04 	mov	r8,1028
80005580:	ea 18 04 04 	orh	r8,0x404
80005584:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x05050505;					/* R5 */
80005586:	e0 68 05 05 	mov	r8,1285
8000558a:	ea 18 05 05 	orh	r8,0x505
8000558e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x06060606;					/* R6 */
80005590:	e0 68 06 06 	mov	r8,1542
80005594:	ea 18 06 06 	orh	r8,0x606
80005598:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x07070707;					/* R7 */
8000559a:	e0 68 07 07 	mov	r8,1799
8000559e:	ea 18 07 07 	orh	r8,0x707
800055a2:	18 d8       	st.w	--r12,r8
	*pxTopOfStack = ( portSTACK_TYPE ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
800055a4:	30 08       	mov	r8,0
800055a6:	18 d8       	st.w	--r12,r8

	return pxTopOfStack;
}
800055a8:	5e fc       	retal	r12
800055aa:	d7 03       	nop

800055ac <vPortEnterCritical>:
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
800055ac:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
800055ae:	48 38       	lddpc	r8,800055b8 <vPortEnterCritical+0xc>
800055b0:	70 09       	ld.w	r9,r8[0x0]
800055b2:	2f f9       	sub	r9,-1
800055b4:	91 09       	st.w	r8[0x0],r9
}
800055b6:	5e fc       	retal	r12
800055b8:	00 00       	add	r0,r0
800055ba:	05 28       	ld.uh	r8,r2++

800055bc <xPortStartScheduler>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
800055bc:	d4 01       	pushm	lr
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
800055be:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
800055c0:	30 0a       	mov	r10,0
800055c2:	14 9b       	mov	r11,r10
800055c4:	49 2c       	lddpc	r12,8000560c <xPortStartScheduler+0x50>
800055c6:	f0 1f 00 13 	mcall	80005610 <xPortStartScheduler+0x54>
/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);//cause!!!
800055ca:	e0 68 5d c0 	mov	r8,24000
800055ce:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
800055d2:	30 08       	mov	r8,0
800055d4:	e3 b8 00 42 	mtsr	0x108,r8
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Start the first task. */
	portRESTORE_CONTEXT();
800055d8:	e0 68 0d 0c 	mov	r8,3340
800055dc:	ea 18 00 00 	orh	r8,0x0
800055e0:	70 00       	ld.w	r0,r8[0x0]
800055e2:	60 0d       	ld.w	sp,r0[0x0]
800055e4:	1b 00       	ld.w	r0,sp++
800055e6:	e0 68 05 28 	mov	r8,1320
800055ea:	ea 18 00 00 	orh	r8,0x0
800055ee:	91 00       	st.w	r8[0x0],r0
800055f0:	e3 cd 00 ff 	ldm	sp++,r0-r7
800055f4:	2f ed       	sub	sp,-8
800055f6:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
800055fa:	fa f0 ff e0 	ld.w	r0,sp[-32]
800055fe:	e3 b0 00 00 	mtsr	0x0,r0
80005602:	fa f0 ff dc 	ld.w	r0,sp[-36]
80005606:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
}
8000560a:	d8 0a       	popm	pc,r12=0
8000560c:	80 00       	ld.sh	r0,r0[0x0]
8000560e:	56 d8       	stdsp	sp[0x1b4],r8
80005610:	80 00       	ld.sh	r0,r0[0x0]
80005612:	4e 28       	lddpc	r8,80005798 <_read+0x24>

80005614 <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
80005614:	20 6d       	sub	sp,24
80005616:	eb cd 00 ff 	pushm	r0-r7
8000561a:	fa c7 ff c0 	sub	r7,sp,-64
8000561e:	ee f0 ff f8 	ld.w	r0,r7[-8]
80005622:	ef 40 ff e0 	st.w	r7[-32],r0
80005626:	ee f0 ff fc 	ld.w	r0,r7[-4]
8000562a:	ef 40 ff e4 	st.w	r7[-28],r0
8000562e:	eb c7 5f 00 	stm	--r7,r8-r12,lr
80005632:	e0 68 05 28 	mov	r8,1320
80005636:	ea 18 00 00 	orh	r8,0x0
8000563a:	70 00       	ld.w	r0,r8[0x0]
8000563c:	1a d0       	st.w	--sp,r0
8000563e:	f0 1f 00 1a 	mcall	800056a4 <LABEL_RET_SCALL_263+0x14>
80005642:	e0 68 0d 0c 	mov	r8,3340
80005646:	ea 18 00 00 	orh	r8,0x0
8000564a:	70 00       	ld.w	r0,r8[0x0]
8000564c:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
8000564e:	f0 1f 00 17 	mcall	800056a8 <LABEL_RET_SCALL_263+0x18>
	portRESTORE_CONTEXT_SCALL();
80005652:	e0 68 0d 0c 	mov	r8,3340
80005656:	ea 18 00 00 	orh	r8,0x0
8000565a:	70 00       	ld.w	r0,r8[0x0]
8000565c:	60 0d       	ld.w	sp,r0[0x0]
8000565e:	1b 00       	ld.w	r0,sp++
80005660:	e0 68 05 28 	mov	r8,1320
80005664:	ea 18 00 00 	orh	r8,0x0
80005668:	91 00       	st.w	r8[0x0],r0
8000566a:	fa c7 ff d8 	sub	r7,sp,-40
8000566e:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
80005672:	ee f0 ff e0 	ld.w	r0,r7[-32]
80005676:	e0 61 05 28 	mov	r1,1320
8000567a:	ea 11 00 00 	orh	r1,0x0
8000567e:	62 02       	ld.w	r2,r1[0x0]
80005680:	58 02       	cp.w	r2,0
80005682:	c0 70       	breq	80005690 <LABEL_RET_SCALL_263>
80005684:	e4 c2 00 01 	sub	r2,r2,1
80005688:	83 02       	st.w	r1[0x0],r2
8000568a:	58 02       	cp.w	r2,0
8000568c:	c0 21       	brne	80005690 <LABEL_RET_SCALL_263>
8000568e:	b1 c0       	cbr	r0,0x10

80005690 <LABEL_RET_SCALL_263>:
80005690:	ef 40 ff f8 	st.w	r7[-8],r0
80005694:	ee f0 ff e4 	ld.w	r0,r7[-28]
80005698:	ef 40 ff fc 	st.w	r7[-4],r0
8000569c:	e3 cd 00 ff 	ldm	sp++,r0-r7
800056a0:	2f ad       	sub	sp,-24
800056a2:	d6 13       	rets
800056a4:	80 00       	ld.sh	r0,r0[0x0]
800056a6:	55 ac       	stdsp	sp[0x168],r12
800056a8:	80 00       	ld.sh	r0,r0[0x0]
800056aa:	5d 48       	*unknown*

800056ac <prvClearCcInt>:
		Set_system_register(AVR32_COUNT, 0);
	}

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
800056ac:	e1 b8 00 43 	mfsr	r8,0x10c
800056b0:	e3 b8 00 43 	mtsr	0x10c,r8
	}
800056b4:	5e fc       	retal	r12
800056b6:	d7 03       	nop

800056b8 <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
800056b8:	48 78       	lddpc	r8,800056d4 <vPortExitCritical+0x1c>
800056ba:	70 08       	ld.w	r8,r8[0x0]
800056bc:	58 08       	cp.w	r8,0
800056be:	5e 0c       	reteq	r12
	{
		ulCriticalNesting--;
800056c0:	48 58       	lddpc	r8,800056d4 <vPortExitCritical+0x1c>
800056c2:	70 09       	ld.w	r9,r8[0x0]
800056c4:	20 19       	sub	r9,1
800056c6:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
800056c8:	70 08       	ld.w	r8,r8[0x0]
800056ca:	58 08       	cp.w	r8,0
800056cc:	5e 1c       	retne	r12
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
800056ce:	d5 03       	csrf	0x10
800056d0:	5e fc       	retal	r12
800056d2:	00 00       	add	r0,r0
800056d4:	00 00       	add	r0,r0
800056d6:	05 28       	ld.uh	r8,r2++

800056d8 <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
800056d8:	eb cd 00 ff 	pushm	r0-r7
800056dc:	e0 68 05 28 	mov	r8,1320
800056e0:	ea 18 00 00 	orh	r8,0x0
800056e4:	70 00       	ld.w	r0,r8[0x0]
800056e6:	1a d0       	st.w	--sp,r0
800056e8:	7a 90       	ld.w	r0,sp[0x24]
800056ea:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
800056ee:	58 10       	cp.w	r0,1
800056f0:	e0 8b 00 08 	brhi	80005700 <LABEL_INT_SKIP_SAVE_CONTEXT_237>
800056f4:	e0 68 0d 0c 	mov	r8,3340
800056f8:	ea 18 00 00 	orh	r8,0x0
800056fc:	70 00       	ld.w	r0,r8[0x0]
800056fe:	81 0d       	st.w	r0[0x0],sp

80005700 <LABEL_INT_SKIP_SAVE_CONTEXT_237>:
	#if( configTICK_USE_TC==1 )
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Clear the interrupt flag. */
		prvClearCcInt();
80005700:	f0 1f 00 12 	mcall	80005748 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
80005704:	f0 1f 00 12 	mcall	8000574c <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
		vTaskIncrementTick();
80005708:	f0 1f 00 12 	mcall	80005750 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x1c>
	portEXIT_CRITICAL();
8000570c:	f0 1f 00 12 	mcall	80005754 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
80005710:	7a 90       	ld.w	r0,sp[0x24]
80005712:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80005716:	58 10       	cp.w	r0,1
80005718:	e0 8b 00 0e 	brhi	80005734 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>
8000571c:	f0 1f 00 0c 	mcall	8000574c <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
80005720:	f0 1f 00 0e 	mcall	80005758 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x24>
80005724:	f0 1f 00 0c 	mcall	80005754 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>
80005728:	e0 68 0d 0c 	mov	r8,3340
8000572c:	ea 18 00 00 	orh	r8,0x0
80005730:	70 00       	ld.w	r0,r8[0x0]
80005732:	60 0d       	ld.w	sp,r0[0x0]

80005734 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>:
80005734:	1b 00       	ld.w	r0,sp++
80005736:	e0 68 05 28 	mov	r8,1320
8000573a:	ea 18 00 00 	orh	r8,0x0
8000573e:	91 00       	st.w	r8[0x0],r0
80005740:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005744:	d6 03       	rete
80005746:	00 00       	add	r0,r0
80005748:	80 00       	ld.sh	r0,r0[0x0]
8000574a:	56 ac       	stdsp	sp[0x1a8],r12
8000574c:	80 00       	ld.sh	r0,r0[0x0]
8000574e:	55 ac       	stdsp	sp[0x168],r12
80005750:	80 00       	ld.sh	r0,r0[0x0]
80005752:	5f 4c       	srge	r12
80005754:	80 00       	ld.sh	r0,r0[0x0]
80005756:	56 b8       	stdsp	sp[0x1ac],r8
80005758:	80 00       	ld.sh	r0,r0[0x0]
8000575a:	5d 48       	*unknown*

8000575c <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
8000575c:	d4 01       	pushm	lr
	vTaskSuspendAll();
8000575e:	f0 1f 00 02 	mcall	80005764 <__malloc_lock+0x8>
}
80005762:	d8 02       	popm	pc
80005764:	80 00       	ld.sh	r0,r0[0x0]
80005766:	5d 38       	musfr	r8

80005768 <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
80005768:	d4 01       	pushm	lr
	xTaskResumeAll();
8000576a:	f0 1f 00 02 	mcall	80005770 <__malloc_unlock+0x8>
}
8000576e:	d8 02       	popm	pc
80005770:	80 00       	ld.sh	r0,r0[0x0]
80005772:	60 f4       	ld.w	r4,r0[0x3c]

80005774 <_read>:
/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
{
80005774:	d4 21       	pushm	r4-r7,lr
80005776:	16 95       	mov	r5,r11
80005778:	14 96       	mov	r6,r10
  int nChars = 0;

  if (file != 0)
8000577a:	58 0c       	cp.w	r12,0
8000577c:	c0 30       	breq	80005782 <_read+0xe>
8000577e:	3f f7       	mov	r7,-1
80005780:	c1 48       	rjmp	800057a8 <_read+0x34>
    return -1;

  for (; len > 0; --len)
80005782:	58 0a       	cp.w	r10,0
80005784:	e0 89 00 04 	brgt	8000578c <_read+0x18>
80005788:	30 07       	mov	r7,0
8000578a:	c0 f8       	rjmp	800057a8 <_read+0x34>
8000578c:	30 07       	mov	r7,0
  {
    int c = usart_getchar(stdio_usart_base);
8000578e:	48 84       	lddpc	r4,800057ac <_read+0x38>
80005790:	68 0c       	ld.w	r12,r4[0x0]
80005792:	f0 1f 00 08 	mcall	800057b0 <_read+0x3c>
    if (c < 0)
80005796:	c0 95       	brlt	800057a8 <_read+0x34>
      break;

    *ptr++ = c;
80005798:	ea 07 0b 0c 	st.b	r5[r7],r12
    ++nChars;
8000579c:	2f f7       	sub	r7,-1

/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
8000579e:	ec 07 01 08 	sub	r8,r6,r7
  int nChars = 0;

  if (file != 0)
    return -1;

  for (; len > 0; --len)
800057a2:	58 08       	cp.w	r8,0
800057a4:	fe 99 ff f6 	brgt	80005790 <_read+0x1c>
    *ptr++ = c;
    ++nChars;
  }

  return nChars;
}
800057a8:	0e 9c       	mov	r12,r7
800057aa:	d8 22       	popm	r4-r7,pc
800057ac:	00 00       	add	r0,r0
800057ae:	41 18       	lddsp	r8,sp[0x44]
800057b0:	80 00       	ld.sh	r0,r0[0x0]
800057b2:	53 40       	stdsp	sp[0xd0],r0

800057b4 <_write>:
 * 1 and 2 is stdout and stderr which goes to usart
 * 3 is framebuffer
 */
int __attribute__((weak))
_write (int file, char * ptr, int len)
{
800057b4:	d4 21       	pushm	r4-r7,lr
800057b6:	16 95       	mov	r5,r11
800057b8:	14 96       	mov	r6,r10
  int nChars = 0;

  if ( (file != 1)
800057ba:	20 1c       	sub	r12,1
800057bc:	58 2c       	cp.w	r12,2
800057be:	e0 8b 00 12 	brhi	800057e2 <_write+0x2e>
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
800057c2:	58 0a       	cp.w	r10,0
800057c4:	c0 31       	brne	800057ca <_write+0x16>
800057c6:	30 07       	mov	r7,0
800057c8:	c0 e8       	rjmp	800057e4 <_write+0x30>
800057ca:	30 07       	mov	r7,0
  {
    if (usart_putchar(stdio_usart_base, *ptr++) < 0)
800057cc:	48 74       	lddpc	r4,800057e8 <_write+0x34>
800057ce:	68 0c       	ld.w	r12,r4[0x0]
800057d0:	ea 07 07 0b 	ld.ub	r11,r5[r7]
800057d4:	f0 1f 00 06 	mcall	800057ec <_write+0x38>
800057d8:	c0 55       	brlt	800057e2 <_write+0x2e>
    {
      return -1;
    }

    ++nChars;
800057da:	2f f7       	sub	r7,-1

  if ( (file != 1)
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
800057dc:	0e 36       	cp.w	r6,r7
800057de:	cf 81       	brne	800057ce <_write+0x1a>
800057e0:	c0 28       	rjmp	800057e4 <_write+0x30>
800057e2:	3f f7       	mov	r7,-1

    ++nChars;
  }

  return nChars;
}
800057e4:	0e 9c       	mov	r12,r7
800057e6:	d8 22       	popm	r4-r7,pc
800057e8:	00 00       	add	r0,r0
800057ea:	41 18       	lddsp	r8,sp[0x44]
800057ec:	80 00       	ld.sh	r0,r0[0x0]
800057ee:	52 f0       	stdsp	sp[0xbc],r0

800057f0 <vPortFree>:
	return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
800057f0:	eb cd 40 80 	pushm	r7,lr
800057f4:	18 97       	mov	r7,r12
	if( pv )
800057f6:	58 0c       	cp.w	r12,0
800057f8:	c0 80       	breq	80005808 <vPortFree+0x18>
	{
		vTaskSuspendAll();
800057fa:	f0 1f 00 05 	mcall	8000580c <vPortFree+0x1c>
		{
			free( pv );
800057fe:	0e 9c       	mov	r12,r7
80005800:	f0 1f 00 04 	mcall	80005810 <vPortFree+0x20>
		}
		xTaskResumeAll();
80005804:	f0 1f 00 04 	mcall	80005814 <vPortFree+0x24>
80005808:	e3 cd 80 80 	ldm	sp++,r7,pc
8000580c:	80 00       	ld.sh	r0,r0[0x0]
8000580e:	5d 38       	musfr	r8
80005810:	80 00       	ld.sh	r0,r0[0x0]
80005812:	6c 64       	ld.w	r4,r6[0x18]
80005814:	80 00       	ld.sh	r0,r0[0x0]
80005816:	60 f4       	ld.w	r4,r0[0x3c]

80005818 <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
80005818:	eb cd 40 80 	pushm	r7,lr
8000581c:	18 97       	mov	r7,r12
void *pvReturn;

	vTaskSuspendAll();
8000581e:	f0 1f 00 06 	mcall	80005834 <pvPortMalloc+0x1c>
	{
		pvReturn = malloc( xWantedSize );
80005822:	0e 9c       	mov	r12,r7
80005824:	f0 1f 00 05 	mcall	80005838 <pvPortMalloc+0x20>
80005828:	18 97       	mov	r7,r12
	}
	xTaskResumeAll();
8000582a:	f0 1f 00 05 	mcall	8000583c <pvPortMalloc+0x24>
		}
	}
	#endif

	return pvReturn;
}
8000582e:	0e 9c       	mov	r12,r7
80005830:	e3 cd 80 80 	ldm	sp++,r7,pc
80005834:	80 00       	ld.sh	r0,r0[0x0]
80005836:	5d 38       	musfr	r8
80005838:	80 00       	ld.sh	r0,r0[0x0]
8000583a:	6c 74       	ld.w	r4,r6[0x1c]
8000583c:	80 00       	ld.sh	r0,r0[0x0]
8000583e:	60 f4       	ld.w	r4,r0[0x3c]

80005840 <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
80005840:	d4 01       	pushm	lr
80005842:	16 98       	mov	r8,r11
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
80005844:	78 09       	ld.w	r9,r12[0x0]
80005846:	58 09       	cp.w	r9,0
80005848:	c1 10       	breq	8000586a <prvCopyDataFromQueue+0x2a>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
8000584a:	78 3a       	ld.w	r10,r12[0xc]
8000584c:	79 09       	ld.w	r9,r12[0x40]
8000584e:	f4 09 00 09 	add	r9,r10,r9
80005852:	99 39       	st.w	r12[0xc],r9
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
80005854:	78 1a       	ld.w	r10,r12[0x4]
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
80005856:	14 39       	cp.w	r9,r10
80005858:	f9 f9 20 00 	ld.wcc	r9,r12[0x0]
8000585c:	f9 f9 2a 03 	st.wcc	r12[0xc],r9
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
80005860:	79 0a       	ld.w	r10,r12[0x40]
80005862:	78 3b       	ld.w	r11,r12[0xc]
80005864:	10 9c       	mov	r12,r8
80005866:	f0 1f 00 02 	mcall	8000586c <prvCopyDataFromQueue+0x2c>
8000586a:	d8 02       	popm	pc
8000586c:	80 00       	ld.sh	r0,r0[0x0]
8000586e:	70 bc       	ld.w	r12,r8[0x2c]

80005870 <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
80005870:	eb cd 40 c0 	pushm	r6-r7,lr
80005874:	18 97       	mov	r7,r12
80005876:	14 96       	mov	r6,r10
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80005878:	78 e8       	ld.w	r8,r12[0x38]
8000587a:	58 08       	cp.w	r8,0
8000587c:	c0 31       	brne	80005882 <xQueueReceiveFromISR+0x12>
8000587e:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
80005882:	f0 1f 00 0e 	mcall	800058b8 <xQueueReceiveFromISR+0x48>
			--( pxQueue->uxMessagesWaiting );
80005886:	6e e8       	ld.w	r8,r7[0x38]
80005888:	20 18       	sub	r8,1
8000588a:	8f e8       	st.w	r7[0x38],r8

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
8000588c:	6f 18       	ld.w	r8,r7[0x44]
8000588e:	5b f8       	cp.w	r8,-1
80005890:	c0 d1       	brne	800058aa <xQueueReceiveFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005892:	6e 48       	ld.w	r8,r7[0x10]
80005894:	58 08       	cp.w	r8,0
80005896:	c0 f0       	breq	800058b4 <xQueueReceiveFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80005898:	ee cc ff f0 	sub	r12,r7,-16
8000589c:	f0 1f 00 08 	mcall	800058bc <xQueueReceiveFromISR+0x4c>
800058a0:	c0 a0       	breq	800058b4 <xQueueReceiveFromISR+0x44>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
800058a2:	30 1c       	mov	r12,1
800058a4:	8d 0c       	st.w	r6[0x0],r12
800058a6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
800058aa:	2f f8       	sub	r8,-1
800058ac:	ef 48 00 44 	st.w	r7[68],r8
800058b0:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
800058b4:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
800058b8:	80 00       	ld.sh	r0,r0[0x0]
800058ba:	58 40       	cp.w	r0,4
800058bc:	80 00       	ld.sh	r0,r0[0x0]
800058be:	5e d0       	retvc	r0

800058c0 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
800058c0:	eb cd 40 c0 	pushm	r6-r7,lr
800058c4:	18 97       	mov	r7,r12

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
800058c6:	f0 1f 00 23 	mcall	80005950 <prvUnlockQueue+0x90>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
800058ca:	6f 28       	ld.w	r8,r7[0x48]
800058cc:	58 08       	cp.w	r8,0
800058ce:	e0 8a 00 18 	brle	800058fe <prvUnlockQueue+0x3e>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800058d2:	6e 98       	ld.w	r8,r7[0x24]
800058d4:	58 08       	cp.w	r8,0
800058d6:	c1 40       	breq	800058fe <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
800058d8:	ee c6 ff dc 	sub	r6,r7,-36
800058dc:	c0 48       	rjmp	800058e4 <prvUnlockQueue+0x24>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800058de:	6e 98       	ld.w	r8,r7[0x24]
800058e0:	58 08       	cp.w	r8,0
800058e2:	c0 e0       	breq	800058fe <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
800058e4:	0c 9c       	mov	r12,r6
800058e6:	f0 1f 00 1c 	mcall	80005954 <prvUnlockQueue+0x94>
800058ea:	c0 30       	breq	800058f0 <prvUnlockQueue+0x30>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
800058ec:	f0 1f 00 1b 	mcall	80005958 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xTxLock );
800058f0:	6f 28       	ld.w	r8,r7[0x48]
800058f2:	20 18       	sub	r8,1
800058f4:	ef 48 00 48 	st.w	r7[72],r8
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
800058f8:	58 08       	cp.w	r8,0
800058fa:	fe 99 ff f2 	brgt	800058de <prvUnlockQueue+0x1e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
800058fe:	3f f8       	mov	r8,-1
80005900:	ef 48 00 48 	st.w	r7[72],r8
	}
	taskEXIT_CRITICAL();
80005904:	f0 1f 00 16 	mcall	8000595c <prvUnlockQueue+0x9c>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
80005908:	f0 1f 00 12 	mcall	80005950 <prvUnlockQueue+0x90>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
8000590c:	6f 18       	ld.w	r8,r7[0x44]
8000590e:	58 08       	cp.w	r8,0
80005910:	e0 8a 00 18 	brle	80005940 <prvUnlockQueue+0x80>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005914:	6e 48       	ld.w	r8,r7[0x10]
80005916:	58 08       	cp.w	r8,0
80005918:	c1 40       	breq	80005940 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
8000591a:	ee c6 ff f0 	sub	r6,r7,-16
8000591e:	c0 48       	rjmp	80005926 <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005920:	6e 48       	ld.w	r8,r7[0x10]
80005922:	58 08       	cp.w	r8,0
80005924:	c0 e0       	breq	80005940 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80005926:	0c 9c       	mov	r12,r6
80005928:	f0 1f 00 0b 	mcall	80005954 <prvUnlockQueue+0x94>
8000592c:	c0 30       	breq	80005932 <prvUnlockQueue+0x72>
				{
					vTaskMissedYield();
8000592e:	f0 1f 00 0b 	mcall	80005958 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xRxLock );
80005932:	6f 18       	ld.w	r8,r7[0x44]
80005934:	20 18       	sub	r8,1
80005936:	ef 48 00 44 	st.w	r7[68],r8
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
8000593a:	58 08       	cp.w	r8,0
8000593c:	fe 99 ff f2 	brgt	80005920 <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
80005940:	3f f8       	mov	r8,-1
80005942:	ef 48 00 44 	st.w	r7[68],r8
	}
	taskEXIT_CRITICAL();
80005946:	f0 1f 00 06 	mcall	8000595c <prvUnlockQueue+0x9c>
}
8000594a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000594e:	00 00       	add	r0,r0
80005950:	80 00       	ld.sh	r0,r0[0x0]
80005952:	55 ac       	stdsp	sp[0x168],r12
80005954:	80 00       	ld.sh	r0,r0[0x0]
80005956:	5e d0       	retvc	r0
80005958:	80 00       	ld.sh	r0,r0[0x0]
8000595a:	5d dc       	*unknown*
8000595c:	80 00       	ld.sh	r0,r0[0x0]
8000595e:	56 b8       	stdsp	sp[0x1ac],r8

80005960 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
80005960:	d4 31       	pushm	r0-r7,lr
80005962:	20 5d       	sub	sp,20
80005964:	18 97       	mov	r7,r12
80005966:	50 0b       	stdsp	sp[0x0],r11
80005968:	50 2a       	stdsp	sp[0x8],r10
8000596a:	50 19       	stdsp	sp[0x4],r9
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
8000596c:	f8 c2 ff dc 	sub	r2,r12,-36
80005970:	30 05       	mov	r5,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80005972:	fa c4 ff f4 	sub	r4,sp,-12
80005976:	30 10       	mov	r0,1

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80005978:	0a 91       	mov	r1,r5

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
8000597a:	fa c3 ff f8 	sub	r3,sp,-8
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
8000597e:	f0 1f 00 3e 	mcall	80005a74 <xQueueGenericReceive+0x114>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80005982:	6e e8       	ld.w	r8,r7[0x38]
80005984:	58 08       	cp.w	r8,0
80005986:	c2 a0       	breq	800059da <xQueueGenericReceive+0x7a>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
80005988:	6e 36       	ld.w	r6,r7[0xc]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
8000598a:	40 0b       	lddsp	r11,sp[0x0]
8000598c:	0e 9c       	mov	r12,r7
8000598e:	f0 1f 00 3b 	mcall	80005a78 <xQueueGenericReceive+0x118>

				if( xJustPeeking == pdFALSE )
80005992:	40 18       	lddsp	r8,sp[0x4]
80005994:	58 08       	cp.w	r8,0
80005996:	c1 51       	brne	800059c0 <xQueueGenericReceive+0x60>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
80005998:	6e e8       	ld.w	r8,r7[0x38]
8000599a:	20 18       	sub	r8,1
8000599c:	8f e8       	st.w	r7[0x38],r8

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
8000599e:	6e 08       	ld.w	r8,r7[0x0]
800059a0:	58 08       	cp.w	r8,0
800059a2:	c0 41       	brne	800059aa <xQueueGenericReceive+0x4a>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
800059a4:	f0 1f 00 36 	mcall	80005a7c <xQueueGenericReceive+0x11c>
800059a8:	8f 1c       	st.w	r7[0x4],r12
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
800059aa:	6e 48       	ld.w	r8,r7[0x10]
800059ac:	58 08       	cp.w	r8,0
800059ae:	c1 20       	breq	800059d2 <xQueueGenericReceive+0x72>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
800059b0:	ee cc ff f0 	sub	r12,r7,-16
800059b4:	f0 1f 00 33 	mcall	80005a80 <xQueueGenericReceive+0x120>
800059b8:	58 1c       	cp.w	r12,1
800059ba:	c0 c1       	brne	800059d2 <xQueueGenericReceive+0x72>
						{
							portYIELD_WITHIN_API();
800059bc:	d7 33       	scall
800059be:	c0 a8       	rjmp	800059d2 <xQueueGenericReceive+0x72>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
800059c0:	8f 36       	st.w	r7[0xc],r6

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800059c2:	6e 98       	ld.w	r8,r7[0x24]
800059c4:	58 08       	cp.w	r8,0
800059c6:	c0 60       	breq	800059d2 <xQueueGenericReceive+0x72>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
800059c8:	04 9c       	mov	r12,r2
800059ca:	f0 1f 00 2e 	mcall	80005a80 <xQueueGenericReceive+0x120>
800059ce:	c0 20       	breq	800059d2 <xQueueGenericReceive+0x72>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
800059d0:	d7 33       	scall
						}
					}

				}

				taskEXIT_CRITICAL();
800059d2:	f0 1f 00 2d 	mcall	80005a84 <xQueueGenericReceive+0x124>
800059d6:	30 1c       	mov	r12,1
				return pdPASS;
800059d8:	c4 c8       	rjmp	80005a70 <xQueueGenericReceive+0x110>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
800059da:	40 28       	lddsp	r8,sp[0x8]
800059dc:	58 08       	cp.w	r8,0
800059de:	c0 51       	brne	800059e8 <xQueueGenericReceive+0x88>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
800059e0:	f0 1f 00 29 	mcall	80005a84 <xQueueGenericReceive+0x124>
800059e4:	30 0c       	mov	r12,0
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
800059e6:	c4 58       	rjmp	80005a70 <xQueueGenericReceive+0x110>
				}
				else if( xEntryTimeSet == pdFALSE )
800059e8:	58 05       	cp.w	r5,0
800059ea:	c0 51       	brne	800059f4 <xQueueGenericReceive+0x94>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
800059ec:	08 9c       	mov	r12,r4
800059ee:	f0 1f 00 27 	mcall	80005a88 <xQueueGenericReceive+0x128>
800059f2:	00 95       	mov	r5,r0
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
800059f4:	f0 1f 00 24 	mcall	80005a84 <xQueueGenericReceive+0x124>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
800059f8:	f0 1f 00 25 	mcall	80005a8c <xQueueGenericReceive+0x12c>
		prvLockQueue( pxQueue );
800059fc:	f0 1f 00 1e 	mcall	80005a74 <xQueueGenericReceive+0x114>
80005a00:	6f 18       	ld.w	r8,r7[0x44]
80005a02:	5b f8       	cp.w	r8,-1
80005a04:	ef f1 0a 11 	st.weq	r7[0x44],r1
80005a08:	6f 28       	ld.w	r8,r7[0x48]
80005a0a:	5b f8       	cp.w	r8,-1
80005a0c:	ef f1 0a 12 	st.weq	r7[0x48],r1
80005a10:	f0 1f 00 1d 	mcall	80005a84 <xQueueGenericReceive+0x124>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80005a14:	06 9b       	mov	r11,r3
80005a16:	08 9c       	mov	r12,r4
80005a18:	f0 1f 00 1e 	mcall	80005a90 <xQueueGenericReceive+0x130>
80005a1c:	c2 41       	brne	80005a64 <xQueueGenericReceive+0x104>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80005a1e:	f0 1f 00 16 	mcall	80005a74 <xQueueGenericReceive+0x114>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
80005a22:	6e e6       	ld.w	r6,r7[0x38]
	taskEXIT_CRITICAL();
80005a24:	f0 1f 00 18 	mcall	80005a84 <xQueueGenericReceive+0x124>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
80005a28:	58 06       	cp.w	r6,0
80005a2a:	c1 71       	brne	80005a58 <xQueueGenericReceive+0xf8>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80005a2c:	6e 08       	ld.w	r8,r7[0x0]
80005a2e:	58 08       	cp.w	r8,0
80005a30:	c0 81       	brne	80005a40 <xQueueGenericReceive+0xe0>
					{
						portENTER_CRITICAL();
80005a32:	f0 1f 00 11 	mcall	80005a74 <xQueueGenericReceive+0x114>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
80005a36:	6e 1c       	ld.w	r12,r7[0x4]
80005a38:	f0 1f 00 17 	mcall	80005a94 <xQueueGenericReceive+0x134>
						}
						portEXIT_CRITICAL();
80005a3c:	f0 1f 00 12 	mcall	80005a84 <xQueueGenericReceive+0x124>
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80005a40:	40 2b       	lddsp	r11,sp[0x8]
80005a42:	04 9c       	mov	r12,r2
80005a44:	f0 1f 00 15 	mcall	80005a98 <xQueueGenericReceive+0x138>
				prvUnlockQueue( pxQueue );
80005a48:	0e 9c       	mov	r12,r7
80005a4a:	f0 1f 00 15 	mcall	80005a9c <xQueueGenericReceive+0x13c>
				if( !xTaskResumeAll() )
80005a4e:	f0 1f 00 15 	mcall	80005aa0 <xQueueGenericReceive+0x140>
80005a52:	c9 61       	brne	8000597e <xQueueGenericReceive+0x1e>
				{
					portYIELD_WITHIN_API();
80005a54:	d7 33       	scall
80005a56:	c9 4b       	rjmp	8000597e <xQueueGenericReceive+0x1e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80005a58:	0e 9c       	mov	r12,r7
80005a5a:	f0 1f 00 11 	mcall	80005a9c <xQueueGenericReceive+0x13c>
				( void ) xTaskResumeAll();
80005a5e:	f0 1f 00 11 	mcall	80005aa0 <xQueueGenericReceive+0x140>
80005a62:	c8 eb       	rjmp	8000597e <xQueueGenericReceive+0x1e>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
80005a64:	0e 9c       	mov	r12,r7
80005a66:	f0 1f 00 0e 	mcall	80005a9c <xQueueGenericReceive+0x13c>
			( void ) xTaskResumeAll();
80005a6a:	f0 1f 00 0e 	mcall	80005aa0 <xQueueGenericReceive+0x140>
80005a6e:	30 0c       	mov	r12,0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
80005a70:	2f bd       	sub	sp,-20
80005a72:	d8 32       	popm	r0-r7,pc
80005a74:	80 00       	ld.sh	r0,r0[0x0]
80005a76:	55 ac       	stdsp	sp[0x168],r12
80005a78:	80 00       	ld.sh	r0,r0[0x0]
80005a7a:	58 40       	cp.w	r0,4
80005a7c:	80 00       	ld.sh	r0,r0[0x0]
80005a7e:	5d e8       	*unknown*
80005a80:	80 00       	ld.sh	r0,r0[0x0]
80005a82:	5e d0       	retvc	r0
80005a84:	80 00       	ld.sh	r0,r0[0x0]
80005a86:	56 b8       	stdsp	sp[0x1ac],r8
80005a88:	80 00       	ld.sh	r0,r0[0x0]
80005a8a:	5d c4       	*unknown*
80005a8c:	80 00       	ld.sh	r0,r0[0x0]
80005a8e:	5d 38       	musfr	r8
80005a90:	80 00       	ld.sh	r0,r0[0x0]
80005a92:	60 60       	ld.w	r0,r0[0x18]
80005a94:	80 00       	ld.sh	r0,r0[0x0]
80005a96:	5e 4c       	retge	r12
80005a98:	80 00       	ld.sh	r0,r0[0x0]
80005a9a:	62 b8       	ld.w	r8,r1[0x2c]
80005a9c:	80 00       	ld.sh	r0,r0[0x0]
80005a9e:	58 c0       	cp.w	r0,12
80005aa0:	80 00       	ld.sh	r0,r0[0x0]
80005aa2:	60 f4       	ld.w	r4,r0[0x3c]

80005aa4 <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
80005aa4:	eb cd 40 80 	pushm	r7,lr
80005aa8:	18 97       	mov	r7,r12
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
80005aaa:	79 08       	ld.w	r8,r12[0x40]
80005aac:	58 08       	cp.w	r8,0
80005aae:	c0 a1       	brne	80005ac2 <prvCopyDataToQueue+0x1e>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80005ab0:	78 08       	ld.w	r8,r12[0x0]
80005ab2:	58 08       	cp.w	r8,0
80005ab4:	c2 b1       	brne	80005b0a <prvCopyDataToQueue+0x66>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
80005ab6:	78 1c       	ld.w	r12,r12[0x4]
80005ab8:	f0 1f 00 17 	mcall	80005b14 <prvCopyDataToQueue+0x70>
				pxQueue->pxMutexHolder = NULL;
80005abc:	30 08       	mov	r8,0
80005abe:	8f 18       	st.w	r7[0x4],r8
80005ac0:	c2 58       	rjmp	80005b0a <prvCopyDataToQueue+0x66>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
80005ac2:	58 0a       	cp.w	r10,0
80005ac4:	c1 01       	brne	80005ae4 <prvCopyDataToQueue+0x40>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80005ac6:	10 9a       	mov	r10,r8
80005ac8:	78 2c       	ld.w	r12,r12[0x8]
80005aca:	f0 1f 00 14 	mcall	80005b18 <prvCopyDataToQueue+0x74>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
80005ace:	6e 29       	ld.w	r9,r7[0x8]
80005ad0:	6f 08       	ld.w	r8,r7[0x40]
80005ad2:	f2 08 00 08 	add	r8,r9,r8
80005ad6:	8f 28       	st.w	r7[0x8],r8
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
80005ad8:	6e 19       	ld.w	r9,r7[0x4]
80005ada:	12 38       	cp.w	r8,r9
80005adc:	c1 73       	brcs	80005b0a <prvCopyDataToQueue+0x66>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
80005ade:	6e 08       	ld.w	r8,r7[0x0]
80005ae0:	8f 28       	st.w	r7[0x8],r8
80005ae2:	c1 48       	rjmp	80005b0a <prvCopyDataToQueue+0x66>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80005ae4:	10 9a       	mov	r10,r8
80005ae6:	78 3c       	ld.w	r12,r12[0xc]
80005ae8:	f0 1f 00 0c 	mcall	80005b18 <prvCopyDataToQueue+0x74>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
80005aec:	6f 08       	ld.w	r8,r7[0x40]
80005aee:	6e 39       	ld.w	r9,r7[0xc]
80005af0:	f2 08 01 08 	sub	r8,r9,r8
80005af4:	8f 38       	st.w	r7[0xc],r8
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
80005af6:	6e 09       	ld.w	r9,r7[0x0]
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
80005af8:	12 38       	cp.w	r8,r9
80005afa:	ef f8 30 10 	ld.wcs	r8,r7[0x40]
80005afe:	ef f9 30 01 	ld.wcs	r9,r7[0x4]
80005b02:	f3 d8 e3 19 	subcs	r9,r9,r8
80005b06:	ef f9 3a 03 	st.wcs	r7[0xc],r9
		}
	}

	++( pxQueue->uxMessagesWaiting );
80005b0a:	6e e8       	ld.w	r8,r7[0x38]
80005b0c:	2f f8       	sub	r8,-1
80005b0e:	8f e8       	st.w	r7[0x38],r8
}
80005b10:	e3 cd 80 80 	ldm	sp++,r7,pc
80005b14:	80 00       	ld.sh	r0,r0[0x0]
80005b16:	5d f4       	*unknown*
80005b18:	80 00       	ld.sh	r0,r0[0x0]
80005b1a:	70 bc       	ld.w	r12,r8[0x2c]

80005b1c <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
80005b1c:	eb cd 40 c0 	pushm	r6-r7,lr
80005b20:	18 97       	mov	r7,r12
80005b22:	14 96       	mov	r6,r10
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80005b24:	78 ec       	ld.w	r12,r12[0x38]
80005b26:	6e f8       	ld.w	r8,r7[0x3c]
80005b28:	10 3c       	cp.w	r12,r8
80005b2a:	c0 33       	brcs	80005b30 <xQueueGenericSendFromISR+0x14>
80005b2c:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80005b30:	12 9a       	mov	r10,r9
80005b32:	0e 9c       	mov	r12,r7
80005b34:	f0 1f 00 0c 	mcall	80005b64 <xQueueGenericSendFromISR+0x48>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
80005b38:	6f 28       	ld.w	r8,r7[0x48]
80005b3a:	5b f8       	cp.w	r8,-1
80005b3c:	c0 d1       	brne	80005b56 <xQueueGenericSendFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005b3e:	6e 98       	ld.w	r8,r7[0x24]
80005b40:	58 08       	cp.w	r8,0
80005b42:	c0 f0       	breq	80005b60 <xQueueGenericSendFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80005b44:	ee cc ff dc 	sub	r12,r7,-36
80005b48:	f0 1f 00 08 	mcall	80005b68 <xQueueGenericSendFromISR+0x4c>
80005b4c:	c0 a0       	breq	80005b60 <xQueueGenericSendFromISR+0x44>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
80005b4e:	30 1c       	mov	r12,1
80005b50:	8d 0c       	st.w	r6[0x0],r12
80005b52:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
80005b56:	2f f8       	sub	r8,-1
80005b58:	ef 48 00 48 	st.w	r7[72],r8
80005b5c:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80005b60:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80005b64:	80 00       	ld.sh	r0,r0[0x0]
80005b66:	5a a4       	cp.w	r4,-22
80005b68:	80 00       	ld.sh	r0,r0[0x0]
80005b6a:	5e d0       	retvc	r0

80005b6c <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
80005b6c:	d4 31       	pushm	r0-r7,lr
80005b6e:	20 5d       	sub	sp,20
80005b70:	18 97       	mov	r7,r12
80005b72:	50 0b       	stdsp	sp[0x0],r11
80005b74:	50 2a       	stdsp	sp[0x8],r10
80005b76:	50 19       	stdsp	sp[0x4],r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
80005b78:	f8 c0 ff f0 	sub	r0,r12,-16
80005b7c:	30 04       	mov	r4,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80005b7e:	fa c3 ff f4 	sub	r3,sp,-12

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80005b82:	08 91       	mov	r1,r4

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80005b84:	fa c2 ff f8 	sub	r2,sp,-8
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
80005b88:	f0 1f 00 2f 	mcall	80005c44 <xQueueGenericSend+0xd8>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80005b8c:	6e e9       	ld.w	r9,r7[0x38]
80005b8e:	6e f8       	ld.w	r8,r7[0x3c]
80005b90:	10 39       	cp.w	r9,r8
80005b92:	c1 42       	brcc	80005bba <xQueueGenericSend+0x4e>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80005b94:	40 1a       	lddsp	r10,sp[0x4]
80005b96:	40 0b       	lddsp	r11,sp[0x0]
80005b98:	0e 9c       	mov	r12,r7
80005b9a:	f0 1f 00 2c 	mcall	80005c48 <xQueueGenericSend+0xdc>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005b9e:	6e 98       	ld.w	r8,r7[0x24]
80005ba0:	58 08       	cp.w	r8,0
80005ba2:	c0 80       	breq	80005bb2 <xQueueGenericSend+0x46>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
80005ba4:	ee cc ff dc 	sub	r12,r7,-36
80005ba8:	f0 1f 00 29 	mcall	80005c4c <xQueueGenericSend+0xe0>
80005bac:	58 1c       	cp.w	r12,1
80005bae:	c0 21       	brne	80005bb2 <xQueueGenericSend+0x46>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
80005bb0:	d7 33       	scall
					}
				}

				taskEXIT_CRITICAL();
80005bb2:	f0 1f 00 28 	mcall	80005c50 <xQueueGenericSend+0xe4>
80005bb6:	30 1c       	mov	r12,1

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
80005bb8:	c4 38       	rjmp	80005c3e <xQueueGenericSend+0xd2>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
80005bba:	40 28       	lddsp	r8,sp[0x8]
80005bbc:	58 08       	cp.w	r8,0
80005bbe:	c0 51       	brne	80005bc8 <xQueueGenericSend+0x5c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80005bc0:	f0 1f 00 24 	mcall	80005c50 <xQueueGenericSend+0xe4>
80005bc4:	30 0c       	mov	r12,0

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
80005bc6:	c3 c8       	rjmp	80005c3e <xQueueGenericSend+0xd2>
				}
				else if( xEntryTimeSet == pdFALSE )
80005bc8:	58 04       	cp.w	r4,0
80005bca:	c0 51       	brne	80005bd4 <xQueueGenericSend+0x68>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80005bcc:	06 9c       	mov	r12,r3
80005bce:	f0 1f 00 22 	mcall	80005c54 <xQueueGenericSend+0xe8>
80005bd2:	30 14       	mov	r4,1
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80005bd4:	f0 1f 00 1f 	mcall	80005c50 <xQueueGenericSend+0xe4>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80005bd8:	f0 1f 00 20 	mcall	80005c58 <xQueueGenericSend+0xec>
		prvLockQueue( pxQueue );
80005bdc:	f0 1f 00 1a 	mcall	80005c44 <xQueueGenericSend+0xd8>
80005be0:	6f 18       	ld.w	r8,r7[0x44]
80005be2:	5b f8       	cp.w	r8,-1
80005be4:	ef f1 0a 11 	st.weq	r7[0x44],r1
80005be8:	6f 28       	ld.w	r8,r7[0x48]
80005bea:	5b f8       	cp.w	r8,-1
80005bec:	ef f1 0a 12 	st.weq	r7[0x48],r1
80005bf0:	f0 1f 00 18 	mcall	80005c50 <xQueueGenericSend+0xe4>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80005bf4:	04 9b       	mov	r11,r2
80005bf6:	06 9c       	mov	r12,r3
80005bf8:	f0 1f 00 19 	mcall	80005c5c <xQueueGenericSend+0xf0>
80005bfc:	c1 b1       	brne	80005c32 <xQueueGenericSend+0xc6>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80005bfe:	f0 1f 00 12 	mcall	80005c44 <xQueueGenericSend+0xd8>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
80005c02:	6e e5       	ld.w	r5,r7[0x38]
80005c04:	6e f6       	ld.w	r6,r7[0x3c]
	taskEXIT_CRITICAL();
80005c06:	f0 1f 00 13 	mcall	80005c50 <xQueueGenericSend+0xe4>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
80005c0a:	0c 35       	cp.w	r5,r6
80005c0c:	c0 d1       	brne	80005c26 <xQueueGenericSend+0xba>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
80005c0e:	40 2b       	lddsp	r11,sp[0x8]
80005c10:	00 9c       	mov	r12,r0
80005c12:	f0 1f 00 14 	mcall	80005c60 <xQueueGenericSend+0xf4>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
80005c16:	0e 9c       	mov	r12,r7
80005c18:	f0 1f 00 13 	mcall	80005c64 <xQueueGenericSend+0xf8>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
80005c1c:	f0 1f 00 13 	mcall	80005c68 <xQueueGenericSend+0xfc>
80005c20:	cb 41       	brne	80005b88 <xQueueGenericSend+0x1c>
				{
					portYIELD_WITHIN_API();
80005c22:	d7 33       	scall
80005c24:	cb 2b       	rjmp	80005b88 <xQueueGenericSend+0x1c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80005c26:	0e 9c       	mov	r12,r7
80005c28:	f0 1f 00 0f 	mcall	80005c64 <xQueueGenericSend+0xf8>
				( void ) xTaskResumeAll();
80005c2c:	f0 1f 00 0f 	mcall	80005c68 <xQueueGenericSend+0xfc>
80005c30:	ca cb       	rjmp	80005b88 <xQueueGenericSend+0x1c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
80005c32:	0e 9c       	mov	r12,r7
80005c34:	f0 1f 00 0c 	mcall	80005c64 <xQueueGenericSend+0xf8>
			( void ) xTaskResumeAll();
80005c38:	f0 1f 00 0c 	mcall	80005c68 <xQueueGenericSend+0xfc>
80005c3c:	30 0c       	mov	r12,0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
80005c3e:	2f bd       	sub	sp,-20
80005c40:	d8 32       	popm	r0-r7,pc
80005c42:	00 00       	add	r0,r0
80005c44:	80 00       	ld.sh	r0,r0[0x0]
80005c46:	55 ac       	stdsp	sp[0x168],r12
80005c48:	80 00       	ld.sh	r0,r0[0x0]
80005c4a:	5a a4       	cp.w	r4,-22
80005c4c:	80 00       	ld.sh	r0,r0[0x0]
80005c4e:	5e d0       	retvc	r0
80005c50:	80 00       	ld.sh	r0,r0[0x0]
80005c52:	56 b8       	stdsp	sp[0x1ac],r8
80005c54:	80 00       	ld.sh	r0,r0[0x0]
80005c56:	5d c4       	*unknown*
80005c58:	80 00       	ld.sh	r0,r0[0x0]
80005c5a:	5d 38       	musfr	r8
80005c5c:	80 00       	ld.sh	r0,r0[0x0]
80005c5e:	60 60       	ld.w	r0,r0[0x18]
80005c60:	80 00       	ld.sh	r0,r0[0x0]
80005c62:	62 b8       	ld.w	r8,r1[0x2c]
80005c64:	80 00       	ld.sh	r0,r0[0x0]
80005c66:	58 c0       	cp.w	r0,12
80005c68:	80 00       	ld.sh	r0,r0[0x0]
80005c6a:	60 f4       	ld.w	r4,r0[0x3c]

80005c6c <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	xQueueHandle xQueueCreateMutex( void )
	{
80005c6c:	eb cd 40 c0 	pushm	r6-r7,lr
	xQUEUE *pxNewQueue;

		/* Allocate the new queue structure. */
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
80005c70:	34 cc       	mov	r12,76
80005c72:	f0 1f 00 12 	mcall	80005cb8 <xQueueCreateMutex+0x4c>
80005c76:	18 97       	mov	r7,r12
		if( pxNewQueue != NULL )
80005c78:	c1 d0       	breq	80005cb2 <xQueueCreateMutex+0x46>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
80005c7a:	30 06       	mov	r6,0
80005c7c:	99 16       	st.w	r12[0x4],r6
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
80005c7e:	99 06       	st.w	r12[0x0],r6

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
80005c80:	99 26       	st.w	r12[0x8],r6
			pxNewQueue->pcReadFrom = NULL;
80005c82:	99 36       	st.w	r12[0xc],r6

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
80005c84:	99 e6       	st.w	r12[0x38],r6
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
80005c86:	30 18       	mov	r8,1
80005c88:	99 f8       	st.w	r12[0x3c],r8
			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
80005c8a:	f9 46 00 40 	st.w	r12[64],r6
			pxNewQueue->xRxLock = queueUNLOCKED;
80005c8e:	3f f8       	mov	r8,-1
80005c90:	f9 48 00 44 	st.w	r12[68],r8
			pxNewQueue->xTxLock = queueUNLOCKED;
80005c94:	f9 48 00 48 	st.w	r12[72],r8

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
80005c98:	2f 0c       	sub	r12,-16
80005c9a:	f0 1f 00 09 	mcall	80005cbc <xQueueCreateMutex+0x50>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
80005c9e:	ee cc ff dc 	sub	r12,r7,-36
80005ca2:	f0 1f 00 07 	mcall	80005cbc <xQueueCreateMutex+0x50>

			/* Start with the semaphore in the expected state. */
			xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
80005ca6:	0c 99       	mov	r9,r6
80005ca8:	0c 9a       	mov	r10,r6
80005caa:	0c 9b       	mov	r11,r6
80005cac:	0e 9c       	mov	r12,r7
80005cae:	f0 1f 00 05 	mcall	80005cc0 <xQueueCreateMutex+0x54>
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
80005cb2:	0e 9c       	mov	r12,r7
80005cb4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005cb8:	80 00       	ld.sh	r0,r0[0x0]
80005cba:	58 18       	cp.w	r8,1
80005cbc:	80 00       	ld.sh	r0,r0[0x0]
80005cbe:	54 88       	stdsp	sp[0x120],r8
80005cc0:	80 00       	ld.sh	r0,r0[0x0]
80005cc2:	5b 6c       	cp.w	r12,-10

80005cc4 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
80005cc4:	d4 21       	pushm	r4-r7,lr
80005cc6:	18 97       	mov	r7,r12
80005cc8:	16 96       	mov	r6,r11
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
80005cca:	58 0c       	cp.w	r12,0
80005ccc:	c2 f0       	breq	80005d2a <xQueueCreate+0x66>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
80005cce:	34 cc       	mov	r12,76
80005cd0:	f0 1f 00 17 	mcall	80005d2c <xQueueCreate+0x68>
80005cd4:	18 95       	mov	r5,r12
		if( pxNewQueue != NULL )
80005cd6:	c2 a0       	breq	80005d2a <xQueueCreate+0x66>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
80005cd8:	ec 07 02 44 	mul	r4,r6,r7

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
80005cdc:	e8 cc ff ff 	sub	r12,r4,-1
80005ce0:	f0 1f 00 13 	mcall	80005d2c <xQueueCreate+0x68>
80005ce4:	8b 0c       	st.w	r5[0x0],r12
			if( pxNewQueue->pcHead != NULL )
80005ce6:	c1 e0       	breq	80005d22 <xQueueCreate+0x5e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
80005ce8:	f8 04 00 04 	add	r4,r12,r4
80005cec:	8b 14       	st.w	r5[0x4],r4
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
80005cee:	30 08       	mov	r8,0
80005cf0:	8b e8       	st.w	r5[0x38],r8
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
80005cf2:	8b 2c       	st.w	r5[0x8],r12
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
80005cf4:	ee c8 00 01 	sub	r8,r7,1
80005cf8:	ad 38       	mul	r8,r6
80005cfa:	10 0c       	add	r12,r8
80005cfc:	8b 3c       	st.w	r5[0xc],r12
				pxNewQueue->uxLength = uxQueueLength;
80005cfe:	8b f7       	st.w	r5[0x3c],r7
				pxNewQueue->uxItemSize = uxItemSize;
80005d00:	eb 46 00 40 	st.w	r5[64],r6
				pxNewQueue->xRxLock = queueUNLOCKED;
80005d04:	3f f8       	mov	r8,-1
80005d06:	eb 48 00 44 	st.w	r5[68],r8
				pxNewQueue->xTxLock = queueUNLOCKED;
80005d0a:	eb 48 00 48 	st.w	r5[72],r8

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
80005d0e:	ea cc ff f0 	sub	r12,r5,-16
80005d12:	f0 1f 00 08 	mcall	80005d30 <xQueueCreate+0x6c>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
80005d16:	ea cc ff dc 	sub	r12,r5,-36
80005d1a:	f0 1f 00 06 	mcall	80005d30 <xQueueCreate+0x6c>
80005d1e:	0a 9c       	mov	r12,r5
80005d20:	d8 22       	popm	r4-r7,pc
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
80005d22:	0a 9c       	mov	r12,r5
80005d24:	f0 1f 00 04 	mcall	80005d34 <xQueueCreate+0x70>
80005d28:	d8 2a       	popm	r4-r7,pc,r12=0
80005d2a:	d8 2a       	popm	r4-r7,pc,r12=0
80005d2c:	80 00       	ld.sh	r0,r0[0x0]
80005d2e:	58 18       	cp.w	r8,1
80005d30:	80 00       	ld.sh	r0,r0[0x0]
80005d32:	54 88       	stdsp	sp[0x120],r8
80005d34:	80 00       	ld.sh	r0,r0[0x0]
80005d36:	57 f0       	stdsp	sp[0x1fc],r0

80005d38 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
80005d38:	48 38       	lddpc	r8,80005d44 <vTaskSuspendAll+0xc>
80005d3a:	70 09       	ld.w	r9,r8[0x0]
80005d3c:	2f f9       	sub	r9,-1
80005d3e:	91 09       	st.w	r8[0x0],r9
}
80005d40:	5e fc       	retal	r12
80005d42:	00 00       	add	r0,r0
80005d44:	00 00       	add	r0,r0
80005d46:	0d 3c       	ld.ub	r12,r6++

80005d48 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
80005d48:	49 a8       	lddpc	r8,80005db0 <vTaskSwitchContext+0x68>
80005d4a:	70 08       	ld.w	r8,r8[0x0]
80005d4c:	58 08       	cp.w	r8,0
80005d4e:	c0 b1       	brne	80005d64 <vTaskSwitchContext+0x1c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80005d50:	49 98       	lddpc	r8,80005db4 <vTaskSwitchContext+0x6c>
80005d52:	70 08       	ld.w	r8,r8[0x0]
80005d54:	f0 08 00 28 	add	r8,r8,r8<<0x2
80005d58:	49 89       	lddpc	r9,80005db8 <vTaskSwitchContext+0x70>
80005d5a:	f2 08 03 28 	ld.w	r8,r9[r8<<0x2]
80005d5e:	58 08       	cp.w	r8,0
80005d60:	c0 60       	breq	80005d6c <vTaskSwitchContext+0x24>
80005d62:	c1 18       	rjmp	80005d84 <vTaskSwitchContext+0x3c>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
80005d64:	30 19       	mov	r9,1
80005d66:	49 68       	lddpc	r8,80005dbc <vTaskSwitchContext+0x74>
80005d68:	91 09       	st.w	r8[0x0],r9
80005d6a:	5e fc       	retal	r12

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80005d6c:	49 28       	lddpc	r8,80005db4 <vTaskSwitchContext+0x6c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80005d6e:	49 3a       	lddpc	r10,80005db8 <vTaskSwitchContext+0x70>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80005d70:	70 09       	ld.w	r9,r8[0x0]
80005d72:	20 19       	sub	r9,1
80005d74:	91 09       	st.w	r8[0x0],r9

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80005d76:	70 09       	ld.w	r9,r8[0x0]
80005d78:	f2 09 00 29 	add	r9,r9,r9<<0x2
80005d7c:	f4 09 03 29 	ld.w	r9,r10[r9<<0x2]
80005d80:	58 09       	cp.w	r9,0
80005d82:	cf 70       	breq	80005d70 <vTaskSwitchContext+0x28>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
80005d84:	48 c8       	lddpc	r8,80005db4 <vTaskSwitchContext+0x6c>
80005d86:	70 08       	ld.w	r8,r8[0x0]
80005d88:	f0 08 00 28 	add	r8,r8,r8<<0x2
80005d8c:	48 b9       	lddpc	r9,80005db8 <vTaskSwitchContext+0x70>
80005d8e:	f2 08 00 28 	add	r8,r9,r8<<0x2
80005d92:	70 19       	ld.w	r9,r8[0x4]
80005d94:	72 19       	ld.w	r9,r9[0x4]
80005d96:	91 19       	st.w	r8[0x4],r9
80005d98:	f0 ca ff f8 	sub	r10,r8,-8
80005d9c:	14 39       	cp.w	r9,r10
80005d9e:	f3 f9 00 01 	ld.weq	r9,r9[0x4]
80005da2:	f1 f9 0a 01 	st.weq	r8[0x4],r9
80005da6:	70 18       	ld.w	r8,r8[0x4]
80005da8:	70 39       	ld.w	r9,r8[0xc]
80005daa:	48 68       	lddpc	r8,80005dc0 <vTaskSwitchContext+0x78>
80005dac:	91 09       	st.w	r8[0x0],r9
80005dae:	5e fc       	retal	r12
80005db0:	00 00       	add	r0,r0
80005db2:	0d 3c       	ld.ub	r12,r6++
80005db4:	00 00       	add	r0,r0
80005db6:	0d 74       	ld.ub	r4,--r6
80005db8:	00 00       	add	r0,r0
80005dba:	0c 58       	eor	r8,r6
80005dbc:	00 00       	add	r0,r0
80005dbe:	0d 5c       	ld.sh	r12,--r6
80005dc0:	00 00       	add	r0,r0
80005dc2:	0d 0c       	ld.w	r12,r6++

80005dc4 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
80005dc4:	48 48       	lddpc	r8,80005dd4 <vTaskSetTimeOutState+0x10>
80005dc6:	70 08       	ld.w	r8,r8[0x0]
80005dc8:	99 08       	st.w	r12[0x0],r8
	pxTimeOut->xTimeOnEntering = xTickCount;
80005dca:	48 48       	lddpc	r8,80005dd8 <vTaskSetTimeOutState+0x14>
80005dcc:	70 08       	ld.w	r8,r8[0x0]
80005dce:	99 18       	st.w	r12[0x4],r8
}
80005dd0:	5e fc       	retal	r12
80005dd2:	00 00       	add	r0,r0
80005dd4:	00 00       	add	r0,r0
80005dd6:	0c 50       	eor	r0,r6
80005dd8:	00 00       	add	r0,r0
80005dda:	0d 38       	ld.ub	r8,r6++

80005ddc <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
80005ddc:	30 19       	mov	r9,1
80005dde:	48 28       	lddpc	r8,80005de4 <vTaskMissedYield+0x8>
80005de0:	91 09       	st.w	r8[0x0],r9
}
80005de2:	5e fc       	retal	r12
80005de4:	00 00       	add	r0,r0
80005de6:	0d 5c       	ld.sh	r12,--r6

80005de8 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
80005de8:	48 28       	lddpc	r8,80005df0 <xTaskGetCurrentTaskHandle+0x8>
80005dea:	70 0c       	ld.w	r12,r8[0x0]

		return xReturn;
	}
80005dec:	5e fc       	retal	r12
80005dee:	00 00       	add	r0,r0
80005df0:	00 00       	add	r0,r0
80005df2:	0d 0c       	ld.w	r12,r6++

80005df4 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
80005df4:	eb cd 40 c0 	pushm	r6-r7,lr
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
80005df8:	58 0c       	cp.w	r12,0
80005dfa:	c1 f0       	breq	80005e38 <vTaskPriorityDisinherit+0x44>

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
80005dfc:	18 97       	mov	r7,r12

		if( pxMutexHolder != NULL )
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
80005dfe:	78 b9       	ld.w	r9,r12[0x2c]
80005e00:	79 18       	ld.w	r8,r12[0x44]
80005e02:	10 39       	cp.w	r9,r8
80005e04:	c1 a0       	breq	80005e38 <vTaskPriorityDisinherit+0x44>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
80005e06:	f8 c6 ff fc 	sub	r6,r12,-4
80005e0a:	0c 9c       	mov	r12,r6
80005e0c:	f0 1f 00 0c 	mcall	80005e3c <vTaskPriorityDisinherit+0x48>

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
80005e10:	6f 1c       	ld.w	r12,r7[0x44]
80005e12:	8f bc       	st.w	r7[0x2c],r12
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
80005e14:	f8 08 11 08 	rsub	r8,r12,8
80005e18:	8f 68       	st.w	r7[0x18],r8
				prvAddTaskToReadyQueue( pxTCB );
80005e1a:	48 a8       	lddpc	r8,80005e40 <vTaskPriorityDisinherit+0x4c>
80005e1c:	70 08       	ld.w	r8,r8[0x0]
80005e1e:	10 3c       	cp.w	r12,r8
80005e20:	e0 88 00 04 	brls	80005e28 <vTaskPriorityDisinherit+0x34>
80005e24:	48 78       	lddpc	r8,80005e40 <vTaskPriorityDisinherit+0x4c>
80005e26:	91 0c       	st.w	r8[0x0],r12
80005e28:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005e2c:	0c 9b       	mov	r11,r6
80005e2e:	48 68       	lddpc	r8,80005e44 <vTaskPriorityDisinherit+0x50>
80005e30:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80005e34:	f0 1f 00 05 	mcall	80005e48 <vTaskPriorityDisinherit+0x54>
80005e38:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005e3c:	80 00       	ld.sh	r0,r0[0x0]
80005e3e:	54 f2       	stdsp	sp[0x13c],r2
80005e40:	00 00       	add	r0,r0
80005e42:	0d 74       	ld.ub	r4,--r6
80005e44:	00 00       	add	r0,r0
80005e46:	0c 58       	eor	r8,r6
80005e48:	80 00       	ld.sh	r0,r0[0x0]
80005e4a:	54 a2       	stdsp	sp[0x128],r2

80005e4c <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
80005e4c:	eb cd 40 c0 	pushm	r6-r7,lr
80005e50:	18 97       	mov	r7,r12
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
80005e52:	49 b8       	lddpc	r8,80005ebc <vTaskPriorityInherit+0x70>
80005e54:	70 08       	ld.w	r8,r8[0x0]
80005e56:	78 b9       	ld.w	r9,r12[0x2c]
80005e58:	70 b8       	ld.w	r8,r8[0x2c]
80005e5a:	10 39       	cp.w	r9,r8
80005e5c:	c2 d2       	brcc	80005eb6 <vTaskPriorityInherit+0x6a>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
80005e5e:	49 88       	lddpc	r8,80005ebc <vTaskPriorityInherit+0x70>
80005e60:	70 08       	ld.w	r8,r8[0x0]
80005e62:	70 b8       	ld.w	r8,r8[0x2c]
80005e64:	f0 08 11 08 	rsub	r8,r8,8
80005e68:	99 68       	st.w	r12[0x18],r8

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
80005e6a:	f2 09 00 28 	add	r8,r9,r9<<0x2
80005e6e:	49 59       	lddpc	r9,80005ec0 <vTaskPriorityInherit+0x74>
80005e70:	f2 08 00 28 	add	r8,r9,r8<<0x2
80005e74:	78 59       	ld.w	r9,r12[0x14]
80005e76:	10 39       	cp.w	r9,r8
80005e78:	c1 b1       	brne	80005eae <vTaskPriorityInherit+0x62>
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
80005e7a:	f8 c6 ff fc 	sub	r6,r12,-4
80005e7e:	0c 9c       	mov	r12,r6
80005e80:	f0 1f 00 11 	mcall	80005ec4 <vTaskPriorityInherit+0x78>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
80005e84:	48 e8       	lddpc	r8,80005ebc <vTaskPriorityInherit+0x70>
80005e86:	70 08       	ld.w	r8,r8[0x0]
80005e88:	70 bc       	ld.w	r12,r8[0x2c]
80005e8a:	8f bc       	st.w	r7[0x2c],r12
				prvAddTaskToReadyQueue( pxTCB );
80005e8c:	48 f8       	lddpc	r8,80005ec8 <vTaskPriorityInherit+0x7c>
80005e8e:	70 08       	ld.w	r8,r8[0x0]
80005e90:	10 3c       	cp.w	r12,r8
80005e92:	e0 88 00 04 	brls	80005e9a <vTaskPriorityInherit+0x4e>
80005e96:	48 d8       	lddpc	r8,80005ec8 <vTaskPriorityInherit+0x7c>
80005e98:	91 0c       	st.w	r8[0x0],r12
80005e9a:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005e9e:	0c 9b       	mov	r11,r6
80005ea0:	48 88       	lddpc	r8,80005ec0 <vTaskPriorityInherit+0x74>
80005ea2:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80005ea6:	f0 1f 00 0a 	mcall	80005ecc <vTaskPriorityInherit+0x80>
80005eaa:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
80005eae:	48 48       	lddpc	r8,80005ebc <vTaskPriorityInherit+0x70>
80005eb0:	70 08       	ld.w	r8,r8[0x0]
80005eb2:	70 b8       	ld.w	r8,r8[0x2c]
80005eb4:	99 b8       	st.w	r12[0x2c],r8
80005eb6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005eba:	00 00       	add	r0,r0
80005ebc:	00 00       	add	r0,r0
80005ebe:	0d 0c       	ld.w	r12,r6++
80005ec0:	00 00       	add	r0,r0
80005ec2:	0c 58       	eor	r8,r6
80005ec4:	80 00       	ld.sh	r0,r0[0x0]
80005ec6:	54 f2       	stdsp	sp[0x13c],r2
80005ec8:	00 00       	add	r0,r0
80005eca:	0d 74       	ld.ub	r4,--r6
80005ecc:	80 00       	ld.sh	r0,r0[0x0]
80005ece:	54 a2       	stdsp	sp[0x128],r2

80005ed0 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
80005ed0:	eb cd 40 c0 	pushm	r6-r7,lr
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
80005ed4:	78 38       	ld.w	r8,r12[0xc]
80005ed6:	70 37       	ld.w	r7,r8[0xc]
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
80005ed8:	ee c6 ff e8 	sub	r6,r7,-24
80005edc:	0c 9c       	mov	r12,r6
80005ede:	f0 1f 00 15 	mcall	80005f30 <xTaskRemoveFromEventList+0x60>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80005ee2:	49 58       	lddpc	r8,80005f34 <xTaskRemoveFromEventList+0x64>
80005ee4:	70 08       	ld.w	r8,r8[0x0]
80005ee6:	58 08       	cp.w	r8,0
80005ee8:	c1 71       	brne	80005f16 <xTaskRemoveFromEventList+0x46>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
80005eea:	ee c6 ff fc 	sub	r6,r7,-4
80005eee:	0c 9c       	mov	r12,r6
80005ef0:	f0 1f 00 10 	mcall	80005f30 <xTaskRemoveFromEventList+0x60>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
80005ef4:	6e bc       	ld.w	r12,r7[0x2c]
80005ef6:	49 18       	lddpc	r8,80005f38 <xTaskRemoveFromEventList+0x68>
80005ef8:	70 08       	ld.w	r8,r8[0x0]
80005efa:	10 3c       	cp.w	r12,r8
80005efc:	e0 88 00 04 	brls	80005f04 <xTaskRemoveFromEventList+0x34>
80005f00:	48 e8       	lddpc	r8,80005f38 <xTaskRemoveFromEventList+0x68>
80005f02:	91 0c       	st.w	r8[0x0],r12
80005f04:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005f08:	0c 9b       	mov	r11,r6
80005f0a:	48 d8       	lddpc	r8,80005f3c <xTaskRemoveFromEventList+0x6c>
80005f0c:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80005f10:	f0 1f 00 0c 	mcall	80005f40 <xTaskRemoveFromEventList+0x70>
80005f14:	c0 58       	rjmp	80005f1e <xTaskRemoveFromEventList+0x4e>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
80005f16:	0c 9b       	mov	r11,r6
80005f18:	48 bc       	lddpc	r12,80005f44 <xTaskRemoveFromEventList+0x74>
80005f1a:	f0 1f 00 0a 	mcall	80005f40 <xTaskRemoveFromEventList+0x70>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
80005f1e:	48 b8       	lddpc	r8,80005f48 <xTaskRemoveFromEventList+0x78>
80005f20:	70 08       	ld.w	r8,r8[0x0]
80005f22:	6e b9       	ld.w	r9,r7[0x2c]
80005f24:	70 b8       	ld.w	r8,r8[0x2c]
80005f26:	10 39       	cp.w	r9,r8
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
80005f28:	5f 2c       	srhs	r12
80005f2a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005f2e:	00 00       	add	r0,r0
80005f30:	80 00       	ld.sh	r0,r0[0x0]
80005f32:	54 f2       	stdsp	sp[0x13c],r2
80005f34:	00 00       	add	r0,r0
80005f36:	0d 3c       	ld.ub	r12,r6++
80005f38:	00 00       	add	r0,r0
80005f3a:	0d 74       	ld.ub	r4,--r6
80005f3c:	00 00       	add	r0,r0
80005f3e:	0c 58       	eor	r8,r6
80005f40:	80 00       	ld.sh	r0,r0[0x0]
80005f42:	54 a2       	stdsp	sp[0x128],r2
80005f44:	00 00       	add	r0,r0
80005f46:	0d 10       	ld.sh	r0,r6++
80005f48:	00 00       	add	r0,r0
80005f4a:	0d 0c       	ld.w	r12,r6++

80005f4c <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
80005f4c:	eb cd 40 fc 	pushm	r2-r7,lr
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80005f50:	4b 98       	lddpc	r8,80006034 <vTaskIncrementTick+0xe8>
80005f52:	70 08       	ld.w	r8,r8[0x0]
80005f54:	58 08       	cp.w	r8,0
80005f56:	c6 91       	brne	80006028 <vTaskIncrementTick+0xdc>
	{
		++xTickCount;
80005f58:	4b 88       	lddpc	r8,80006038 <vTaskIncrementTick+0xec>
80005f5a:	70 09       	ld.w	r9,r8[0x0]
80005f5c:	2f f9       	sub	r9,-1
80005f5e:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
80005f60:	70 08       	ld.w	r8,r8[0x0]
80005f62:	58 08       	cp.w	r8,0
80005f64:	c1 a1       	brne	80005f98 <vTaskIncrementTick+0x4c>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
80005f66:	4b 68       	lddpc	r8,8000603c <vTaskIncrementTick+0xf0>
80005f68:	70 0a       	ld.w	r10,r8[0x0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
80005f6a:	4b 69       	lddpc	r9,80006040 <vTaskIncrementTick+0xf4>
80005f6c:	72 0b       	ld.w	r11,r9[0x0]
80005f6e:	91 0b       	st.w	r8[0x0],r11
			pxOverflowDelayedTaskList = pxTemp;
80005f70:	93 0a       	st.w	r9[0x0],r10
			xNumOfOverflows++;
80005f72:	4b 59       	lddpc	r9,80006044 <vTaskIncrementTick+0xf8>
80005f74:	72 0a       	ld.w	r10,r9[0x0]
80005f76:	2f fa       	sub	r10,-1
80005f78:	93 0a       	st.w	r9[0x0],r10

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
80005f7a:	70 08       	ld.w	r8,r8[0x0]
80005f7c:	70 08       	ld.w	r8,r8[0x0]
80005f7e:	58 08       	cp.w	r8,0
80005f80:	c0 51       	brne	80005f8a <vTaskIncrementTick+0x3e>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
80005f82:	3f f9       	mov	r9,-1
80005f84:	4b 18       	lddpc	r8,80006048 <vTaskIncrementTick+0xfc>
80005f86:	91 09       	st.w	r8[0x0],r9
80005f88:	c0 88       	rjmp	80005f98 <vTaskIncrementTick+0x4c>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
80005f8a:	4a d8       	lddpc	r8,8000603c <vTaskIncrementTick+0xf0>
80005f8c:	70 08       	ld.w	r8,r8[0x0]
80005f8e:	70 38       	ld.w	r8,r8[0xc]
80005f90:	70 38       	ld.w	r8,r8[0xc]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
80005f92:	70 19       	ld.w	r9,r8[0x4]
80005f94:	4a d8       	lddpc	r8,80006048 <vTaskIncrementTick+0xfc>
80005f96:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
80005f98:	4a 88       	lddpc	r8,80006038 <vTaskIncrementTick+0xec>
80005f9a:	70 09       	ld.w	r9,r8[0x0]
80005f9c:	4a b8       	lddpc	r8,80006048 <vTaskIncrementTick+0xfc>
80005f9e:	70 08       	ld.w	r8,r8[0x0]
80005fa0:	10 39       	cp.w	r9,r8
80005fa2:	c4 73       	brcs	80006030 <vTaskIncrementTick+0xe4>
80005fa4:	4a 68       	lddpc	r8,8000603c <vTaskIncrementTick+0xf0>
80005fa6:	70 08       	ld.w	r8,r8[0x0]
80005fa8:	70 08       	ld.w	r8,r8[0x0]
80005faa:	58 08       	cp.w	r8,0
80005fac:	c0 c0       	breq	80005fc4 <vTaskIncrementTick+0x78>
80005fae:	4a 48       	lddpc	r8,8000603c <vTaskIncrementTick+0xf0>
80005fb0:	70 08       	ld.w	r8,r8[0x0]
80005fb2:	70 38       	ld.w	r8,r8[0xc]
80005fb4:	70 37       	ld.w	r7,r8[0xc]
80005fb6:	6e 18       	ld.w	r8,r7[0x4]
80005fb8:	4a 09       	lddpc	r9,80006038 <vTaskIncrementTick+0xec>
80005fba:	72 09       	ld.w	r9,r9[0x0]
80005fbc:	12 38       	cp.w	r8,r9
80005fbe:	e0 88 00 14 	brls	80005fe6 <vTaskIncrementTick+0x9a>
80005fc2:	c0 e8       	rjmp	80005fde <vTaskIncrementTick+0x92>
80005fc4:	3f f9       	mov	r9,-1
80005fc6:	4a 18       	lddpc	r8,80006048 <vTaskIncrementTick+0xfc>
80005fc8:	91 09       	st.w	r8[0x0],r9
80005fca:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80005fce:	6a 08       	ld.w	r8,r5[0x0]
80005fd0:	70 38       	ld.w	r8,r8[0xc]
80005fd2:	70 37       	ld.w	r7,r8[0xc]
80005fd4:	6e 18       	ld.w	r8,r7[0x4]
80005fd6:	64 09       	ld.w	r9,r2[0x0]
80005fd8:	12 38       	cp.w	r8,r9
80005fda:	e0 88 00 0a 	brls	80005fee <vTaskIncrementTick+0xa2>
80005fde:	49 b9       	lddpc	r9,80006048 <vTaskIncrementTick+0xfc>
80005fe0:	93 08       	st.w	r9[0x0],r8
80005fe2:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80005fe6:	49 a4       	lddpc	r4,8000604c <vTaskIncrementTick+0x100>
80005fe8:	49 a3       	lddpc	r3,80006050 <vTaskIncrementTick+0x104>
80005fea:	49 55       	lddpc	r5,8000603c <vTaskIncrementTick+0xf0>
80005fec:	49 32       	lddpc	r2,80006038 <vTaskIncrementTick+0xec>
80005fee:	ee c6 ff fc 	sub	r6,r7,-4
80005ff2:	0c 9c       	mov	r12,r6
80005ff4:	f0 1f 00 18 	mcall	80006054 <vTaskIncrementTick+0x108>
80005ff8:	6e a8       	ld.w	r8,r7[0x28]
80005ffa:	58 08       	cp.w	r8,0
80005ffc:	c0 50       	breq	80006006 <vTaskIncrementTick+0xba>
80005ffe:	ee cc ff e8 	sub	r12,r7,-24
80006002:	f0 1f 00 15 	mcall	80006054 <vTaskIncrementTick+0x108>
80006006:	6e bc       	ld.w	r12,r7[0x2c]
80006008:	68 08       	ld.w	r8,r4[0x0]
8000600a:	10 3c       	cp.w	r12,r8
8000600c:	e9 fc ba 00 	st.whi	r4[0x0],r12
80006010:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006014:	0c 9b       	mov	r11,r6
80006016:	e6 0c 00 2c 	add	r12,r3,r12<<0x2
8000601a:	f0 1f 00 10 	mcall	80006058 <vTaskIncrementTick+0x10c>
8000601e:	6a 08       	ld.w	r8,r5[0x0]
80006020:	70 08       	ld.w	r8,r8[0x0]
80006022:	58 08       	cp.w	r8,0
80006024:	cd 51       	brne	80005fce <vTaskIncrementTick+0x82>
80006026:	cc fb       	rjmp	80005fc4 <vTaskIncrementTick+0x78>
	}
	else
	{
		++uxMissedTicks;
80006028:	48 d8       	lddpc	r8,8000605c <vTaskIncrementTick+0x110>
8000602a:	70 09       	ld.w	r9,r8[0x0]
8000602c:	2f f9       	sub	r9,-1
8000602e:	91 09       	st.w	r8[0x0],r9
80006030:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80006034:	00 00       	add	r0,r0
80006036:	0d 3c       	ld.ub	r12,r6++
80006038:	00 00       	add	r0,r0
8000603a:	0d 38       	ld.ub	r8,r6++
8000603c:	00 00       	add	r0,r0
8000603e:	0c 44       	or	r4,r6
80006040:	00 00       	add	r0,r0
80006042:	0c 54       	eor	r4,r6
80006044:	00 00       	add	r0,r0
80006046:	0c 50       	eor	r0,r6
80006048:	00 00       	add	r0,r0
8000604a:	05 2c       	ld.uh	r12,r2++
8000604c:	00 00       	add	r0,r0
8000604e:	0d 74       	ld.ub	r4,--r6
80006050:	00 00       	add	r0,r0
80006052:	0c 58       	eor	r8,r6
80006054:	80 00       	ld.sh	r0,r0[0x0]
80006056:	54 f2       	stdsp	sp[0x13c],r2
80006058:	80 00       	ld.sh	r0,r0[0x0]
8000605a:	54 a2       	stdsp	sp[0x128],r2
8000605c:	00 00       	add	r0,r0
8000605e:	0c 3c       	cp.w	r12,r6

80006060 <xTaskCheckForTimeOut>:
	pxTimeOut->xTimeOnEntering = xTickCount;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
80006060:	eb cd 40 c0 	pushm	r6-r7,lr
80006064:	18 97       	mov	r7,r12
80006066:	16 96       	mov	r6,r11
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
80006068:	f0 1f 00 15 	mcall	800060bc <xTaskCheckForTimeOut+0x5c>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
8000606c:	6c 08       	ld.w	r8,r6[0x0]
8000606e:	5b f8       	cp.w	r8,-1
80006070:	c0 31       	brne	80006076 <xTaskCheckForTimeOut+0x16>
80006072:	30 07       	mov	r7,0
80006074:	c1 f8       	rjmp	800060b2 <xTaskCheckForTimeOut+0x52>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
80006076:	49 39       	lddpc	r9,800060c0 <xTaskCheckForTimeOut+0x60>
80006078:	72 09       	ld.w	r9,r9[0x0]
8000607a:	6e 0a       	ld.w	r10,r7[0x0]
8000607c:	12 3a       	cp.w	r10,r9
8000607e:	c0 70       	breq	8000608c <xTaskCheckForTimeOut+0x2c>
80006080:	49 19       	lddpc	r9,800060c4 <xTaskCheckForTimeOut+0x64>
80006082:	72 09       	ld.w	r9,r9[0x0]
80006084:	6e 1a       	ld.w	r10,r7[0x4]
80006086:	12 3a       	cp.w	r10,r9
80006088:	e0 88 00 14 	brls	800060b0 <xTaskCheckForTimeOut+0x50>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
8000608c:	48 e9       	lddpc	r9,800060c4 <xTaskCheckForTimeOut+0x64>
8000608e:	72 0a       	ld.w	r10,r9[0x0]
80006090:	6e 19       	ld.w	r9,r7[0x4]
80006092:	12 1a       	sub	r10,r9
80006094:	14 38       	cp.w	r8,r10
80006096:	e0 88 00 0d 	brls	800060b0 <xTaskCheckForTimeOut+0x50>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
8000609a:	48 ba       	lddpc	r10,800060c4 <xTaskCheckForTimeOut+0x64>
8000609c:	74 0a       	ld.w	r10,r10[0x0]
8000609e:	14 19       	sub	r9,r10
800060a0:	f2 08 00 08 	add	r8,r9,r8
800060a4:	8d 08       	st.w	r6[0x0],r8
			vTaskSetTimeOutState( pxTimeOut );
800060a6:	0e 9c       	mov	r12,r7
800060a8:	f0 1f 00 08 	mcall	800060c8 <xTaskCheckForTimeOut+0x68>
800060ac:	30 07       	mov	r7,0
800060ae:	c0 28       	rjmp	800060b2 <xTaskCheckForTimeOut+0x52>
800060b0:	30 17       	mov	r7,1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
800060b2:	f0 1f 00 07 	mcall	800060cc <xTaskCheckForTimeOut+0x6c>

	return xReturn;
}
800060b6:	0e 9c       	mov	r12,r7
800060b8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800060bc:	80 00       	ld.sh	r0,r0[0x0]
800060be:	55 ac       	stdsp	sp[0x168],r12
800060c0:	00 00       	add	r0,r0
800060c2:	0c 50       	eor	r0,r6
800060c4:	00 00       	add	r0,r0
800060c6:	0d 38       	ld.ub	r8,r6++
800060c8:	80 00       	ld.sh	r0,r0[0x0]
800060ca:	5d c4       	*unknown*
800060cc:	80 00       	ld.sh	r0,r0[0x0]
800060ce:	56 b8       	stdsp	sp[0x1ac],r8

800060d0 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
800060d0:	eb cd 40 80 	pushm	r7,lr
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
800060d4:	f0 1f 00 05 	mcall	800060e8 <xTaskGetTickCount+0x18>
	{
		xTicks = xTickCount;
800060d8:	48 58       	lddpc	r8,800060ec <xTaskGetTickCount+0x1c>
800060da:	70 07       	ld.w	r7,r8[0x0]
	}
	taskEXIT_CRITICAL();
800060dc:	f0 1f 00 05 	mcall	800060f0 <xTaskGetTickCount+0x20>

	return xTicks;
}
800060e0:	0e 9c       	mov	r12,r7
800060e2:	e3 cd 80 80 	ldm	sp++,r7,pc
800060e6:	00 00       	add	r0,r0
800060e8:	80 00       	ld.sh	r0,r0[0x0]
800060ea:	55 ac       	stdsp	sp[0x168],r12
800060ec:	00 00       	add	r0,r0
800060ee:	0d 38       	ld.ub	r8,r6++
800060f0:	80 00       	ld.sh	r0,r0[0x0]
800060f2:	56 b8       	stdsp	sp[0x1ac],r8

800060f4 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
800060f4:	eb cd 40 fe 	pushm	r1-r7,lr
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
800060f8:	f0 1f 00 2c 	mcall	800061a8 <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;
800060fc:	4a c8       	lddpc	r8,800061ac <xTaskResumeAll+0xb8>
800060fe:	70 09       	ld.w	r9,r8[0x0]
80006100:	20 19       	sub	r9,1
80006102:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80006104:	70 08       	ld.w	r8,r8[0x0]
80006106:	58 08       	cp.w	r8,0
80006108:	c4 91       	brne	8000619a <xTaskResumeAll+0xa6>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
8000610a:	4a a8       	lddpc	r8,800061b0 <xTaskResumeAll+0xbc>
8000610c:	70 08       	ld.w	r8,r8[0x0]
8000610e:	58 08       	cp.w	r8,0
80006110:	c4 50       	breq	8000619a <xTaskResumeAll+0xa6>
80006112:	30 04       	mov	r4,0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80006114:	4a 85       	lddpc	r5,800061b4 <xTaskResumeAll+0xc0>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
80006116:	4a 93       	lddpc	r3,800061b8 <xTaskResumeAll+0xc4>
80006118:	4a 92       	lddpc	r2,800061bc <xTaskResumeAll+0xc8>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
8000611a:	4a a1       	lddpc	r1,800061c0 <xTaskResumeAll+0xcc>
8000611c:	c1 e8       	rjmp	80006158 <xTaskResumeAll+0x64>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
8000611e:	6a 38       	ld.w	r8,r5[0xc]
80006120:	70 37       	ld.w	r7,r8[0xc]
					vListRemove( &( pxTCB->xEventListItem ) );
80006122:	ee cc ff e8 	sub	r12,r7,-24
80006126:	f0 1f 00 28 	mcall	800061c4 <xTaskResumeAll+0xd0>
					vListRemove( &( pxTCB->xGenericListItem ) );
8000612a:	ee c6 ff fc 	sub	r6,r7,-4
8000612e:	0c 9c       	mov	r12,r6
80006130:	f0 1f 00 25 	mcall	800061c4 <xTaskResumeAll+0xd0>
					prvAddTaskToReadyQueue( pxTCB );
80006134:	6e bc       	ld.w	r12,r7[0x2c]
80006136:	66 08       	ld.w	r8,r3[0x0]
80006138:	10 3c       	cp.w	r12,r8
8000613a:	e7 fc ba 00 	st.whi	r3[0x0],r12
8000613e:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006142:	0c 9b       	mov	r11,r6
80006144:	e4 0c 00 2c 	add	r12,r2,r12<<0x2
80006148:	f0 1f 00 20 	mcall	800061c8 <xTaskResumeAll+0xd4>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
8000614c:	62 08       	ld.w	r8,r1[0x0]
8000614e:	6e b9       	ld.w	r9,r7[0x2c]
80006150:	70 b8       	ld.w	r8,r8[0x2c]
80006152:	10 39       	cp.w	r9,r8
80006154:	f9 b4 02 01 	movhs	r4,1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80006158:	6a 08       	ld.w	r8,r5[0x0]
8000615a:	58 08       	cp.w	r8,0
8000615c:	ce 11       	brne	8000611e <xTaskResumeAll+0x2a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
8000615e:	49 c8       	lddpc	r8,800061cc <xTaskResumeAll+0xd8>
80006160:	70 08       	ld.w	r8,r8[0x0]
80006162:	58 08       	cp.w	r8,0
80006164:	c0 f0       	breq	80006182 <xTaskResumeAll+0x8e>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80006166:	49 a8       	lddpc	r8,800061cc <xTaskResumeAll+0xd8>
80006168:	70 08       	ld.w	r8,r8[0x0]
8000616a:	58 08       	cp.w	r8,0
8000616c:	c1 10       	breq	8000618e <xTaskResumeAll+0x9a>
					{
						vTaskIncrementTick();
						--uxMissedTicks;
8000616e:	49 87       	lddpc	r7,800061cc <xTaskResumeAll+0xd8>
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
80006170:	f0 1f 00 18 	mcall	800061d0 <xTaskResumeAll+0xdc>
						--uxMissedTicks;
80006174:	6e 08       	ld.w	r8,r7[0x0]
80006176:	20 18       	sub	r8,1
80006178:	8f 08       	st.w	r7[0x0],r8
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
8000617a:	6e 08       	ld.w	r8,r7[0x0]
8000617c:	58 08       	cp.w	r8,0
8000617e:	cf 91       	brne	80006170 <xTaskResumeAll+0x7c>
80006180:	c0 78       	rjmp	8000618e <xTaskResumeAll+0x9a>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
80006182:	58 14       	cp.w	r4,1
80006184:	c0 50       	breq	8000618e <xTaskResumeAll+0x9a>
80006186:	49 48       	lddpc	r8,800061d4 <xTaskResumeAll+0xe0>
80006188:	70 08       	ld.w	r8,r8[0x0]
8000618a:	58 18       	cp.w	r8,1
8000618c:	c0 71       	brne	8000619a <xTaskResumeAll+0xa6>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
8000618e:	30 09       	mov	r9,0
80006190:	49 18       	lddpc	r8,800061d4 <xTaskResumeAll+0xe0>
80006192:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
80006194:	d7 33       	scall
80006196:	30 17       	mov	r7,1
80006198:	c0 28       	rjmp	8000619c <xTaskResumeAll+0xa8>
8000619a:	30 07       	mov	r7,0
				}
			}
		}
	}
	taskEXIT_CRITICAL();
8000619c:	f0 1f 00 0f 	mcall	800061d8 <xTaskResumeAll+0xe4>

	return xAlreadyYielded;
}
800061a0:	0e 9c       	mov	r12,r7
800061a2:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
800061a6:	00 00       	add	r0,r0
800061a8:	80 00       	ld.sh	r0,r0[0x0]
800061aa:	55 ac       	stdsp	sp[0x168],r12
800061ac:	00 00       	add	r0,r0
800061ae:	0d 3c       	ld.ub	r12,r6++
800061b0:	00 00       	add	r0,r0
800061b2:	0d 58       	ld.sh	r8,--r6
800061b4:	00 00       	add	r0,r0
800061b6:	0d 10       	ld.sh	r0,r6++
800061b8:	00 00       	add	r0,r0
800061ba:	0d 74       	ld.ub	r4,--r6
800061bc:	00 00       	add	r0,r0
800061be:	0c 58       	eor	r8,r6
800061c0:	00 00       	add	r0,r0
800061c2:	0d 0c       	ld.w	r12,r6++
800061c4:	80 00       	ld.sh	r0,r0[0x0]
800061c6:	54 f2       	stdsp	sp[0x13c],r2
800061c8:	80 00       	ld.sh	r0,r0[0x0]
800061ca:	54 a2       	stdsp	sp[0x128],r2
800061cc:	00 00       	add	r0,r0
800061ce:	0c 3c       	cp.w	r12,r6
800061d0:	80 00       	ld.sh	r0,r0[0x0]
800061d2:	5f 4c       	srge	r12
800061d4:	00 00       	add	r0,r0
800061d6:	0d 5c       	ld.sh	r12,--r6
800061d8:	80 00       	ld.sh	r0,r0[0x0]
800061da:	56 b8       	stdsp	sp[0x1ac],r8

800061dc <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
800061dc:	eb cd 40 80 	pushm	r7,lr
800061e0:	18 97       	mov	r7,r12
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
800061e2:	49 08       	lddpc	r8,80006220 <prvAddCurrentTaskToDelayedList+0x44>
800061e4:	70 08       	ld.w	r8,r8[0x0]
800061e6:	91 1c       	st.w	r8[0x4],r12

	if( xTimeToWake < xTickCount )
800061e8:	48 f8       	lddpc	r8,80006224 <prvAddCurrentTaskToDelayedList+0x48>
800061ea:	70 08       	ld.w	r8,r8[0x0]
800061ec:	10 3c       	cp.w	r12,r8
800061ee:	c0 a2       	brcc	80006202 <prvAddCurrentTaskToDelayedList+0x26>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800061f0:	48 c8       	lddpc	r8,80006220 <prvAddCurrentTaskToDelayedList+0x44>
800061f2:	70 0b       	ld.w	r11,r8[0x0]
800061f4:	48 d8       	lddpc	r8,80006228 <prvAddCurrentTaskToDelayedList+0x4c>
800061f6:	70 0c       	ld.w	r12,r8[0x0]
800061f8:	2f cb       	sub	r11,-4
800061fa:	f0 1f 00 0d 	mcall	8000622c <prvAddCurrentTaskToDelayedList+0x50>
800061fe:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006202:	48 88       	lddpc	r8,80006220 <prvAddCurrentTaskToDelayedList+0x44>
80006204:	70 0b       	ld.w	r11,r8[0x0]
80006206:	48 b8       	lddpc	r8,80006230 <prvAddCurrentTaskToDelayedList+0x54>
80006208:	70 0c       	ld.w	r12,r8[0x0]
8000620a:	2f cb       	sub	r11,-4
8000620c:	f0 1f 00 08 	mcall	8000622c <prvAddCurrentTaskToDelayedList+0x50>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
80006210:	48 98       	lddpc	r8,80006234 <prvAddCurrentTaskToDelayedList+0x58>
80006212:	70 08       	ld.w	r8,r8[0x0]
80006214:	10 37       	cp.w	r7,r8
80006216:	c0 32       	brcc	8000621c <prvAddCurrentTaskToDelayedList+0x40>
		{
			xNextTaskUnblockTime = xTimeToWake;
80006218:	48 78       	lddpc	r8,80006234 <prvAddCurrentTaskToDelayedList+0x58>
8000621a:	91 07       	st.w	r8[0x0],r7
8000621c:	e3 cd 80 80 	ldm	sp++,r7,pc
80006220:	00 00       	add	r0,r0
80006222:	0d 0c       	ld.w	r12,r6++
80006224:	00 00       	add	r0,r0
80006226:	0d 38       	ld.ub	r8,r6++
80006228:	00 00       	add	r0,r0
8000622a:	0c 54       	eor	r4,r6
8000622c:	80 00       	ld.sh	r0,r0[0x0]
8000622e:	54 be       	stdsp	sp[0x12c],lr
80006230:	00 00       	add	r0,r0
80006232:	0c 44       	or	r4,r6
80006234:	00 00       	add	r0,r0
80006236:	05 2c       	ld.uh	r12,r2++

80006238 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
80006238:	eb cd 40 c0 	pushm	r6-r7,lr
8000623c:	18 96       	mov	r6,r12
8000623e:	16 97       	mov	r7,r11
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0 ) );

		vTaskSuspendAll();
80006240:	f0 1f 00 18 	mcall	800062a0 <vTaskDelayUntil+0x68>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
80006244:	6c 08       	ld.w	r8,r6[0x0]
80006246:	10 07       	add	r7,r8

			if( xTickCount < *pxPreviousWakeTime )
80006248:	49 79       	lddpc	r9,800062a4 <vTaskDelayUntil+0x6c>
8000624a:	72 09       	ld.w	r9,r9[0x0]
8000624c:	12 38       	cp.w	r8,r9
8000624e:	e0 88 00 0c 	brls	80006266 <vTaskDelayUntil+0x2e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
80006252:	0e 38       	cp.w	r8,r7
80006254:	e0 88 00 22 	brls	80006298 <vTaskDelayUntil+0x60>
80006258:	49 38       	lddpc	r8,800062a4 <vTaskDelayUntil+0x6c>
8000625a:	70 08       	ld.w	r8,r8[0x0]
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
8000625c:	8d 07       	st.w	r6[0x0],r7

			if( xShouldDelay != pdFALSE )
8000625e:	10 37       	cp.w	r7,r8
80006260:	e0 88 00 14 	brls	80006288 <vTaskDelayUntil+0x50>
80006264:	c0 a8       	rjmp	80006278 <vTaskDelayUntil+0x40>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
80006266:	0e 38       	cp.w	r8,r7
80006268:	e0 8b 00 16 	brhi	80006294 <vTaskDelayUntil+0x5c>
8000626c:	48 e8       	lddpc	r8,800062a4 <vTaskDelayUntil+0x6c>
8000626e:	70 08       	ld.w	r8,r8[0x0]
80006270:	10 37       	cp.w	r7,r8
80006272:	e0 8b 00 11 	brhi	80006294 <vTaskDelayUntil+0x5c>
80006276:	c1 18       	rjmp	80006298 <vTaskDelayUntil+0x60>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006278:	48 c8       	lddpc	r8,800062a8 <vTaskDelayUntil+0x70>
8000627a:	70 0c       	ld.w	r12,r8[0x0]
8000627c:	2f cc       	sub	r12,-4
8000627e:	f0 1f 00 0c 	mcall	800062ac <vTaskDelayUntil+0x74>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
80006282:	0e 9c       	mov	r12,r7
80006284:	f0 1f 00 0b 	mcall	800062b0 <vTaskDelayUntil+0x78>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
80006288:	f0 1f 00 0b 	mcall	800062b4 <vTaskDelayUntil+0x7c>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
8000628c:	c0 81       	brne	8000629c <vTaskDelayUntil+0x64>
		{
			portYIELD_WITHIN_API();
8000628e:	d7 33       	scall
80006290:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80006294:	8d 07       	st.w	r6[0x0],r7
80006296:	cf 1b       	rjmp	80006278 <vTaskDelayUntil+0x40>
80006298:	8d 07       	st.w	r6[0x0],r7
8000629a:	cf 7b       	rjmp	80006288 <vTaskDelayUntil+0x50>
8000629c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800062a0:	80 00       	ld.sh	r0,r0[0x0]
800062a2:	5d 38       	musfr	r8
800062a4:	00 00       	add	r0,r0
800062a6:	0d 38       	ld.ub	r8,r6++
800062a8:	00 00       	add	r0,r0
800062aa:	0d 0c       	ld.w	r12,r6++
800062ac:	80 00       	ld.sh	r0,r0[0x0]
800062ae:	54 f2       	stdsp	sp[0x13c],r2
800062b0:	80 00       	ld.sh	r0,r0[0x0]
800062b2:	61 dc       	ld.w	r12,r0[0x74]
800062b4:	80 00       	ld.sh	r0,r0[0x0]
800062b6:	60 f4       	ld.w	r4,r0[0x3c]

800062b8 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
800062b8:	eb cd 40 c0 	pushm	r6-r7,lr
800062bc:	16 96       	mov	r6,r11
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
800062be:	48 e7       	lddpc	r7,800062f4 <vTaskPlaceOnEventList+0x3c>
800062c0:	6e 0b       	ld.w	r11,r7[0x0]
800062c2:	2e 8b       	sub	r11,-24
800062c4:	f0 1f 00 0d 	mcall	800062f8 <vTaskPlaceOnEventList+0x40>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800062c8:	6e 0c       	ld.w	r12,r7[0x0]
800062ca:	2f cc       	sub	r12,-4
800062cc:	f0 1f 00 0c 	mcall	800062fc <vTaskPlaceOnEventList+0x44>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
800062d0:	5b f6       	cp.w	r6,-1
800062d2:	c0 81       	brne	800062e2 <vTaskPlaceOnEventList+0x2a>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800062d4:	6e 0b       	ld.w	r11,r7[0x0]
800062d6:	2f cb       	sub	r11,-4
800062d8:	48 ac       	lddpc	r12,80006300 <vTaskPlaceOnEventList+0x48>
800062da:	f0 1f 00 0b 	mcall	80006304 <vTaskPlaceOnEventList+0x4c>
800062de:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
800062e2:	48 a8       	lddpc	r8,80006308 <vTaskPlaceOnEventList+0x50>
800062e4:	70 0c       	ld.w	r12,r8[0x0]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
800062e6:	ec 0c 00 0c 	add	r12,r6,r12
800062ea:	f0 1f 00 09 	mcall	8000630c <vTaskPlaceOnEventList+0x54>
800062ee:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800062f2:	00 00       	add	r0,r0
800062f4:	00 00       	add	r0,r0
800062f6:	0d 0c       	ld.w	r12,r6++
800062f8:	80 00       	ld.sh	r0,r0[0x0]
800062fa:	54 be       	stdsp	sp[0x12c],lr
800062fc:	80 00       	ld.sh	r0,r0[0x0]
800062fe:	54 f2       	stdsp	sp[0x13c],r2
80006300:	00 00       	add	r0,r0
80006302:	0d 60       	ld.uh	r0,--r6
80006304:	80 00       	ld.sh	r0,r0[0x0]
80006306:	54 a2       	stdsp	sp[0x128],r2
80006308:	00 00       	add	r0,r0
8000630a:	0d 38       	ld.ub	r8,r6++
8000630c:	80 00       	ld.sh	r0,r0[0x0]
8000630e:	61 dc       	ld.w	r12,r0[0x74]

80006310 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
80006310:	eb cd 40 f8 	pushm	r3-r7,lr
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80006314:	49 67       	lddpc	r7,8000636c <prvIdleTask+0x5c>
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80006316:	49 74       	lddpc	r4,80006370 <prvIdleTask+0x60>

				taskENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					--uxCurrentNumberOfTasks;
80006318:	49 73       	lddpc	r3,80006374 <prvIdleTask+0x64>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
8000631a:	49 85       	lddpc	r5,80006378 <prvIdleTask+0x68>
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
8000631c:	6e 08       	ld.w	r8,r7[0x0]
8000631e:	58 08       	cp.w	r8,0
80006320:	c1 e0       	breq	8000635c <prvIdleTask+0x4c>
		{
			vTaskSuspendAll();
80006322:	f0 1f 00 17 	mcall	8000637c <prvIdleTask+0x6c>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80006326:	68 06       	ld.w	r6,r4[0x0]
			xTaskResumeAll();
80006328:	f0 1f 00 16 	mcall	80006380 <prvIdleTask+0x70>

			if( xListIsEmpty == pdFALSE )
8000632c:	58 06       	cp.w	r6,0
8000632e:	c1 70       	breq	8000635c <prvIdleTask+0x4c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
80006330:	f0 1f 00 15 	mcall	80006384 <prvIdleTask+0x74>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
80006334:	68 38       	ld.w	r8,r4[0xc]
80006336:	70 36       	ld.w	r6,r8[0xc]
					vListRemove( &( pxTCB->xGenericListItem ) );
80006338:	ec cc ff fc 	sub	r12,r6,-4
8000633c:	f0 1f 00 13 	mcall	80006388 <prvIdleTask+0x78>
					--uxCurrentNumberOfTasks;
80006340:	66 08       	ld.w	r8,r3[0x0]
80006342:	20 18       	sub	r8,1
80006344:	87 08       	st.w	r3[0x0],r8
					--uxTasksDeleted;
80006346:	6e 08       	ld.w	r8,r7[0x0]
80006348:	20 18       	sub	r8,1
8000634a:	8f 08       	st.w	r7[0x0],r8
				}
				taskEXIT_CRITICAL();
8000634c:	f0 1f 00 10 	mcall	8000638c <prvIdleTask+0x7c>

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
80006350:	6c cc       	ld.w	r12,r6[0x30]
80006352:	f0 1f 00 10 	mcall	80006390 <prvIdleTask+0x80>
		vPortFree( pxTCB );
80006356:	0c 9c       	mov	r12,r6
80006358:	f0 1f 00 0e 	mcall	80006390 <prvIdleTask+0x80>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
8000635c:	6a 08       	ld.w	r8,r5[0x0]
8000635e:	58 18       	cp.w	r8,1
80006360:	e0 88 00 03 	brls	80006366 <prvIdleTask+0x56>
			{
				taskYIELD();
80006364:	d7 33       	scall
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
80006366:	f0 1f 00 0c 	mcall	80006394 <prvIdleTask+0x84>
		}
		#endif
	}
8000636a:	cd 9b       	rjmp	8000631c <prvIdleTask+0xc>
8000636c:	00 00       	add	r0,r0
8000636e:	0c 4c       	or	r12,r6
80006370:	00 00       	add	r0,r0
80006372:	0c f8       	st.b	--r6,r8
80006374:	00 00       	add	r0,r0
80006376:	0d 58       	ld.sh	r8,--r6
80006378:	00 00       	add	r0,r0
8000637a:	0c 58       	eor	r8,r6
8000637c:	80 00       	ld.sh	r0,r0[0x0]
8000637e:	5d 38       	musfr	r8
80006380:	80 00       	ld.sh	r0,r0[0x0]
80006382:	60 f4       	ld.w	r4,r0[0x3c]
80006384:	80 00       	ld.sh	r0,r0[0x0]
80006386:	55 ac       	stdsp	sp[0x168],r12
80006388:	80 00       	ld.sh	r0,r0[0x0]
8000638a:	54 f2       	stdsp	sp[0x13c],r2
8000638c:	80 00       	ld.sh	r0,r0[0x0]
8000638e:	56 b8       	stdsp	sp[0x1ac],r8
80006390:	80 00       	ld.sh	r0,r0[0x0]
80006392:	57 f0       	stdsp	sp[0x1fc],r0
80006394:	80 00       	ld.sh	r0,r0[0x0]
80006396:	20 30       	sub	r0,3

80006398 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
80006398:	d4 31       	pushm	r0-r7,lr
8000639a:	20 1d       	sub	sp,4
8000639c:	fa c4 ff d8 	sub	r4,sp,-40
800063a0:	50 0c       	stdsp	sp[0x0],r12
800063a2:	16 91       	mov	r1,r11
800063a4:	14 97       	mov	r7,r10
800063a6:	12 90       	mov	r0,r9
800063a8:	10 93       	mov	r3,r8
800063aa:	68 02       	ld.w	r2,r4[0x0]
800063ac:	68 16       	ld.w	r6,r4[0x4]
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
800063ae:	34 8c       	mov	r12,72
800063b0:	f0 1f 00 5c 	mcall	80006520 <xTaskGenericCreate+0x188>
800063b4:	18 95       	mov	r5,r12

	if( pxNewTCB != NULL )
800063b6:	c0 31       	brne	800063bc <xTaskGenericCreate+0x24>
800063b8:	3f fc       	mov	r12,-1
800063ba:	ca f8       	rjmp	80006518 <xTaskGenericCreate+0x180>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
800063bc:	58 06       	cp.w	r6,0
800063be:	e0 81 00 af 	brne	8000651c <xTaskGenericCreate+0x184>
800063c2:	0e 9c       	mov	r12,r7
800063c4:	5c 7c       	castu.h	r12
800063c6:	a3 6c       	lsl	r12,0x2
800063c8:	f0 1f 00 56 	mcall	80006520 <xTaskGenericCreate+0x188>
800063cc:	18 96       	mov	r6,r12
800063ce:	8b cc       	st.w	r5[0x30],r12

		if( pxNewTCB->pxStack == NULL )
800063d0:	c0 61       	brne	800063dc <xTaskGenericCreate+0x44>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
800063d2:	0a 9c       	mov	r12,r5
800063d4:	f0 1f 00 54 	mcall	80006524 <xTaskGenericCreate+0x18c>
800063d8:	3f fc       	mov	r12,-1
800063da:	c9 f8       	rjmp	80006518 <xTaskGenericCreate+0x180>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
800063dc:	5c 77       	castu.h	r7
800063de:	ee 0a 15 02 	lsl	r10,r7,0x2
800063e2:	e0 6b 00 a5 	mov	r11,165
800063e6:	0c 9c       	mov	r12,r6
800063e8:	f0 1f 00 50 	mcall	80006528 <xTaskGenericCreate+0x190>
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
800063ec:	ee c6 00 01 	sub	r6,r7,1
800063f0:	6a c8       	ld.w	r8,r5[0x30]
800063f2:	f0 06 00 26 	add	r6,r8,r6<<0x2
800063f6:	e0 16 ff fc 	andl	r6,0xfffc
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
800063fa:	31 0a       	mov	r10,16
800063fc:	02 9b       	mov	r11,r1
800063fe:	ea cc ff cc 	sub	r12,r5,-52
80006402:	f0 1f 00 4b 	mcall	8000652c <xTaskGenericCreate+0x194>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
80006406:	30 08       	mov	r8,0
80006408:	eb 68 00 43 	st.b	r5[67],r8
8000640c:	58 73       	cp.w	r3,7
8000640e:	e6 07 17 80 	movls	r7,r3
80006412:	f9 b7 0b 07 	movhi	r7,7
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
80006416:	8b b7       	st.w	r5[0x2c],r7
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
80006418:	eb 47 00 44 	st.w	r5[68],r7
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
8000641c:	ea c4 ff fc 	sub	r4,r5,-4
80006420:	08 9c       	mov	r12,r4
80006422:	f0 1f 00 44 	mcall	80006530 <xTaskGenericCreate+0x198>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
80006426:	ea cc ff e8 	sub	r12,r5,-24
8000642a:	f0 1f 00 42 	mcall	80006530 <xTaskGenericCreate+0x198>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
8000642e:	8b 45       	st.w	r5[0x10],r5

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
80006430:	ee 07 11 08 	rsub	r7,r7,8
80006434:	8b 67       	st.w	r5[0x18],r7
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
80006436:	8b 95       	st.w	r5[0x24],r5
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
80006438:	00 9a       	mov	r10,r0
8000643a:	40 0b       	lddsp	r11,sp[0x0]
8000643c:	0c 9c       	mov	r12,r6
8000643e:	f0 1f 00 3e 	mcall	80006534 <xTaskGenericCreate+0x19c>
80006442:	8b 0c       	st.w	r5[0x0],r12
		if( ( void * ) pxCreatedTask != NULL )
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
80006444:	58 02       	cp.w	r2,0
80006446:	e5 f5 1a 00 	st.wne	r2[0x0],r5
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
8000644a:	f0 1f 00 3c 	mcall	80006538 <xTaskGenericCreate+0x1a0>
		{
			uxCurrentNumberOfTasks++;
8000644e:	4b c8       	lddpc	r8,8000653c <xTaskGenericCreate+0x1a4>
80006450:	70 09       	ld.w	r9,r8[0x0]
80006452:	2f f9       	sub	r9,-1
80006454:	91 09       	st.w	r8[0x0],r9
			if( pxCurrentTCB == NULL )
80006456:	4b b8       	lddpc	r8,80006540 <xTaskGenericCreate+0x1a8>
80006458:	70 08       	ld.w	r8,r8[0x0]
8000645a:	58 08       	cp.w	r8,0
8000645c:	c2 61       	brne	800064a8 <xTaskGenericCreate+0x110>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
8000645e:	4b 98       	lddpc	r8,80006540 <xTaskGenericCreate+0x1a8>
80006460:	91 05       	st.w	r8[0x0],r5

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
80006462:	4b 78       	lddpc	r8,8000653c <xTaskGenericCreate+0x1a4>
80006464:	70 08       	ld.w	r8,r8[0x0]
80006466:	58 18       	cp.w	r8,1
80006468:	c2 b1       	brne	800064be <xTaskGenericCreate+0x126>
8000646a:	4b 77       	lddpc	r7,80006544 <xTaskGenericCreate+0x1ac>

/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
8000646c:	ee c6 ff 60 	sub	r6,r7,-160
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
80006470:	0e 9c       	mov	r12,r7
80006472:	f0 1f 00 36 	mcall	80006548 <xTaskGenericCreate+0x1b0>
80006476:	2e c7       	sub	r7,-20

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
80006478:	0c 37       	cp.w	r7,r6
8000647a:	cf b1       	brne	80006470 <xTaskGenericCreate+0xd8>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
8000647c:	4b 47       	lddpc	r7,8000654c <xTaskGenericCreate+0x1b4>
8000647e:	0e 9c       	mov	r12,r7
80006480:	f0 1f 00 32 	mcall	80006548 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
80006484:	4b 36       	lddpc	r6,80006550 <xTaskGenericCreate+0x1b8>
80006486:	0c 9c       	mov	r12,r6
80006488:	f0 1f 00 30 	mcall	80006548 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xPendingReadyList );
8000648c:	4b 2c       	lddpc	r12,80006554 <xTaskGenericCreate+0x1bc>
8000648e:	f0 1f 00 2f 	mcall	80006548 <xTaskGenericCreate+0x1b0>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
80006492:	4b 2c       	lddpc	r12,80006558 <xTaskGenericCreate+0x1c0>
80006494:	f0 1f 00 2d 	mcall	80006548 <xTaskGenericCreate+0x1b0>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
80006498:	4b 1c       	lddpc	r12,8000655c <xTaskGenericCreate+0x1c4>
8000649a:	f0 1f 00 2c 	mcall	80006548 <xTaskGenericCreate+0x1b0>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
8000649e:	4b 18       	lddpc	r8,80006560 <xTaskGenericCreate+0x1c8>
800064a0:	91 07       	st.w	r8[0x0],r7
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
800064a2:	4b 18       	lddpc	r8,80006564 <xTaskGenericCreate+0x1cc>
800064a4:	91 06       	st.w	r8[0x0],r6
800064a6:	c0 c8       	rjmp	800064be <xTaskGenericCreate+0x126>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
800064a8:	4b 08       	lddpc	r8,80006568 <xTaskGenericCreate+0x1d0>
800064aa:	70 08       	ld.w	r8,r8[0x0]
800064ac:	58 08       	cp.w	r8,0
800064ae:	c0 81       	brne	800064be <xTaskGenericCreate+0x126>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
800064b0:	4a 48       	lddpc	r8,80006540 <xTaskGenericCreate+0x1a8>
800064b2:	70 08       	ld.w	r8,r8[0x0]
800064b4:	70 b8       	ld.w	r8,r8[0x2c]
800064b6:	10 33       	cp.w	r3,r8
800064b8:	c0 33       	brcs	800064be <xTaskGenericCreate+0x126>
					{
						pxCurrentTCB = pxNewTCB;
800064ba:	4a 28       	lddpc	r8,80006540 <xTaskGenericCreate+0x1a8>
800064bc:	91 05       	st.w	r8[0x0],r5
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
800064be:	6a b8       	ld.w	r8,r5[0x2c]
800064c0:	4a b9       	lddpc	r9,8000656c <xTaskGenericCreate+0x1d4>
800064c2:	72 09       	ld.w	r9,r9[0x0]
800064c4:	12 38       	cp.w	r8,r9
800064c6:	e0 88 00 04 	brls	800064ce <xTaskGenericCreate+0x136>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
800064ca:	4a 99       	lddpc	r9,8000656c <xTaskGenericCreate+0x1d4>
800064cc:	93 08       	st.w	r9[0x0],r8
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
800064ce:	4a 98       	lddpc	r8,80006570 <xTaskGenericCreate+0x1d8>
800064d0:	70 09       	ld.w	r9,r8[0x0]
800064d2:	2f f9       	sub	r9,-1
800064d4:	91 09       	st.w	r8[0x0],r9

			prvAddTaskToReadyQueue( pxNewTCB );
800064d6:	6a b8       	ld.w	r8,r5[0x2c]
800064d8:	4a 79       	lddpc	r9,80006574 <xTaskGenericCreate+0x1dc>
800064da:	72 09       	ld.w	r9,r9[0x0]
800064dc:	12 38       	cp.w	r8,r9
800064de:	e0 88 00 04 	brls	800064e6 <xTaskGenericCreate+0x14e>
800064e2:	4a 59       	lddpc	r9,80006574 <xTaskGenericCreate+0x1dc>
800064e4:	93 08       	st.w	r9[0x0],r8
800064e6:	6a bc       	ld.w	r12,r5[0x2c]
800064e8:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800064ec:	08 9b       	mov	r11,r4
800064ee:	49 68       	lddpc	r8,80006544 <xTaskGenericCreate+0x1ac>
800064f0:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800064f4:	f0 1f 00 21 	mcall	80006578 <xTaskGenericCreate+0x1e0>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
800064f8:	f0 1f 00 21 	mcall	8000657c <xTaskGenericCreate+0x1e4>
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
800064fc:	49 b8       	lddpc	r8,80006568 <xTaskGenericCreate+0x1d0>
800064fe:	70 08       	ld.w	r8,r8[0x0]
80006500:	58 08       	cp.w	r8,0
80006502:	c0 a0       	breq	80006516 <xTaskGenericCreate+0x17e>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
80006504:	48 f8       	lddpc	r8,80006540 <xTaskGenericCreate+0x1a8>
80006506:	70 08       	ld.w	r8,r8[0x0]
80006508:	70 b8       	ld.w	r8,r8[0x2c]
8000650a:	10 33       	cp.w	r3,r8
8000650c:	e0 88 00 05 	brls	80006516 <xTaskGenericCreate+0x17e>
			{
				portYIELD_WITHIN_API();
80006510:	d7 33       	scall
80006512:	30 1c       	mov	r12,1
80006514:	c0 28       	rjmp	80006518 <xTaskGenericCreate+0x180>
80006516:	30 1c       	mov	r12,1
			}
		}
	}

	return xReturn;
}
80006518:	2f fd       	sub	sp,-4
8000651a:	d8 32       	popm	r0-r7,pc
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
8000651c:	99 c6       	st.w	r12[0x30],r6
8000651e:	c5 fb       	rjmp	800063dc <xTaskGenericCreate+0x44>
80006520:	80 00       	ld.sh	r0,r0[0x0]
80006522:	58 18       	cp.w	r8,1
80006524:	80 00       	ld.sh	r0,r0[0x0]
80006526:	57 f0       	stdsp	sp[0x1fc],r0
80006528:	80 00       	ld.sh	r0,r0[0x0]
8000652a:	72 04       	ld.w	r4,r9[0x0]
8000652c:	80 00       	ld.sh	r0,r0[0x0]
8000652e:	75 58       	ld.w	r8,r10[0x54]
80006530:	80 00       	ld.sh	r0,r0[0x0]
80006532:	54 9c       	stdsp	sp[0x124],r12
80006534:	80 00       	ld.sh	r0,r0[0x0]
80006536:	55 18       	stdsp	sp[0x144],r8
80006538:	80 00       	ld.sh	r0,r0[0x0]
8000653a:	55 ac       	stdsp	sp[0x168],r12
8000653c:	00 00       	add	r0,r0
8000653e:	0d 58       	ld.sh	r8,--r6
80006540:	00 00       	add	r0,r0
80006542:	0d 0c       	ld.w	r12,r6++
80006544:	00 00       	add	r0,r0
80006546:	0c 58       	eor	r8,r6
80006548:	80 00       	ld.sh	r0,r0[0x0]
8000654a:	54 88       	stdsp	sp[0x120],r8
8000654c:	00 00       	add	r0,r0
8000654e:	0d 24       	ld.uh	r4,r6++
80006550:	00 00       	add	r0,r0
80006552:	0d 40       	ld.w	r0,--r6
80006554:	00 00       	add	r0,r0
80006556:	0d 10       	ld.sh	r0,r6++
80006558:	00 00       	add	r0,r0
8000655a:	0c f8       	st.b	--r6,r8
8000655c:	00 00       	add	r0,r0
8000655e:	0d 60       	ld.uh	r0,--r6
80006560:	00 00       	add	r0,r0
80006562:	0c 44       	or	r4,r6
80006564:	00 00       	add	r0,r0
80006566:	0c 54       	eor	r4,r6
80006568:	00 00       	add	r0,r0
8000656a:	0c 48       	or	r8,r6
8000656c:	00 00       	add	r0,r0
8000656e:	0c 40       	or	r0,r6
80006570:	00 00       	add	r0,r0
80006572:	0d 54       	ld.sh	r4,--r6
80006574:	00 00       	add	r0,r0
80006576:	0d 74       	ld.ub	r4,--r6
80006578:	80 00       	ld.sh	r0,r0[0x0]
8000657a:	54 a2       	stdsp	sp[0x128],r2
8000657c:	80 00       	ld.sh	r0,r0[0x0]
8000657e:	56 b8       	stdsp	sp[0x1ac],r8

80006580 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
80006580:	d4 01       	pushm	lr
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
80006582:	30 09       	mov	r9,0
80006584:	1a d9       	st.w	--sp,r9
80006586:	1a d9       	st.w	--sp,r9
80006588:	1a d9       	st.w	--sp,r9
8000658a:	12 98       	mov	r8,r9
8000658c:	e0 6a 01 00 	mov	r10,256
80006590:	48 9b       	lddpc	r11,800065b4 <vTaskStartScheduler+0x34>
80006592:	48 ac       	lddpc	r12,800065b8 <vTaskStartScheduler+0x38>
80006594:	f0 1f 00 0a 	mcall	800065bc <vTaskStartScheduler+0x3c>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
80006598:	2f dd       	sub	sp,-12
8000659a:	58 1c       	cp.w	r12,1
8000659c:	c0 a1       	brne	800065b0 <vTaskStartScheduler+0x30>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
8000659e:	d3 03       	ssrf	0x10

		xSchedulerRunning = pdTRUE;
800065a0:	30 19       	mov	r9,1
800065a2:	48 88       	lddpc	r8,800065c0 <vTaskStartScheduler+0x40>
800065a4:	91 09       	st.w	r8[0x0],r9
		xTickCount = ( portTickType ) 0;
800065a6:	30 09       	mov	r9,0
800065a8:	48 78       	lddpc	r8,800065c4 <vTaskStartScheduler+0x44>
800065aa:	91 09       	st.w	r8[0x0],r9
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
800065ac:	f0 1f 00 07 	mcall	800065c8 <vTaskStartScheduler+0x48>
800065b0:	d8 02       	popm	pc
800065b2:	00 00       	add	r0,r0
800065b4:	80 01       	ld.sh	r1,r0[0x0]
800065b6:	5a e8       	cp.w	r8,-18
800065b8:	80 00       	ld.sh	r0,r0[0x0]
800065ba:	63 10       	ld.w	r0,r1[0x44]
800065bc:	80 00       	ld.sh	r0,r0[0x0]
800065be:	63 98       	ld.w	r8,r1[0x64]
800065c0:	00 00       	add	r0,r0
800065c2:	0c 48       	or	r8,r6
800065c4:	00 00       	add	r0,r0
800065c6:	0d 38       	ld.ub	r8,r6++
800065c8:	80 00       	ld.sh	r0,r0[0x0]
800065ca:	55 bc       	stdsp	sp[0x16c],r12

800065cc <PrintChar>:
	
static void task_log(void * pvParameters);

char *  PrintChar(char c, char * str)
{
	*str++ = c;
800065cc:	16 cc       	st.b	r11++,r12
	return str;
}
800065ce:	5e fb       	retal	r11

800065d0 <PrintHex>:
	
	return str;
}

char * PrintHex(int i,char len, char * str)
{
800065d0:	eb cd 40 c0 	pushm	r6-r7,lr
800065d4:	20 3d       	sub	sp,12
800065d6:	18 98       	mov	r8,r12
	char * p = str;
	char s[12];
	memset(s, 0 , 12);
800065d8:	30 06       	mov	r6,0
800065da:	30 07       	mov	r7,0
800065dc:	fa e7 00 00 	st.d	sp[0],r6
800065e0:	30 0c       	mov	r12,0
800065e2:	50 2c       	stdsp	sp[0x8],r12
	int cnt=0;
	
	if(i)
800065e4:	58 08       	cp.w	r8,0
800065e6:	c1 30       	breq	8000660c <PrintHex+0x3c>
800065e8:	18 99       	mov	r9,r12
	while(i)
	{
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
800065ea:	1a 9c       	mov	r12,sp
800065ec:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
800065f0:	58 9e       	cp.w	lr,9
800065f2:	e0 8a 00 04 	brle	800065fa <PrintHex+0x2a>
800065f6:	2c 9e       	sub	lr,-55
800065f8:	c0 48       	rjmp	80006600 <PrintHex+0x30>
800065fa:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
800065fe:	2d 0e       	sub	lr,-48
80006600:	f8 09 0b 0e 	st.b	r12[r9],lr
80006604:	2f f9       	sub	r9,-1
		i = (i >> 4 ) & 0x0FFFFFFF;
80006606:	a5 88       	lsr	r8,0x4
	char s[12];
	memset(s, 0 , 12);
	int cnt=0;
	
	if(i)
	while(i)
80006608:	cf 21       	brne	800065ec <PrintHex+0x1c>
8000660a:	c0 48       	rjmp	80006612 <PrintHex+0x42>
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
		i = (i >> 4 ) & 0x0FFFFFFF;
		//i >>= 4
	}
	else
	s[cnt++] = '0';
8000660c:	33 08       	mov	r8,48
8000660e:	ba 88       	st.b	sp[0x0],r8
80006610:	30 19       	mov	r9,1
	
	if(len - cnt > 0 )
80006612:	f6 09 01 08 	sub	r8,r11,r9
80006616:	58 08       	cp.w	r8,0
80006618:	e0 8a 00 13 	brle	8000663e <PrintHex+0x6e>
	{
		char num = len - cnt;
8000661c:	12 1b       	sub	r11,r9
8000661e:	f9 db c0 08 	bfextu	r12,r11,0x0,0x8
		for(int i = 0; i < num; i++)
80006622:	18 9e       	mov	lr,r12
80006624:	58 0c       	cp.w	r12,0
80006626:	e0 8a 00 0c 	brle	8000663e <PrintHex+0x6e>
8000662a:	1a 9b       	mov	r11,sp
8000662c:	12 0b       	add	r11,r9
8000662e:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80006630:	33 07       	mov	r7,48
80006632:	16 c7       	st.b	r11++,r7
	s[cnt++] = '0';
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80006634:	2f f8       	sub	r8,-1
80006636:	1c 38       	cp.w	r8,lr
80006638:	cf d5       	brlt	80006632 <PrintHex+0x62>
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
8000663a:	f8 09 00 09 	add	r9,r12,r9
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
8000663e:	f2 c8 ff ff 	sub	r8,r9,-1
	s[cnt++] = '0';
	
	while(cnt>0)
80006642:	f0 cb ff ff 	sub	r11,r8,-1
80006646:	58 0b       	cp.w	r11,0
80006648:	e0 8a 00 19 	brle	8000667a <PrintHex+0xaa>
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
8000664c:	fa cb ff f4 	sub	r11,sp,-12
80006650:	f6 09 00 09 	add	r9,r11,r9
80006654:	37 8b       	mov	r11,120
80006656:	f3 6b ff f4 	st.b	r9[-12],r11
	s[cnt++] = '0';
8000665a:	fa c9 ff f4 	sub	r9,sp,-12
8000665e:	10 09       	add	r9,r8
80006660:	33 0b       	mov	r11,48
80006662:	f3 6b ff f4 	st.b	r9[-12],r11
80006666:	fa 08 00 08 	add	r8,sp,r8
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
8000666a:	fa ce 00 01 	sub	lr,sp,1
8000666e:	14 99       	mov	r9,r10
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
	*p++ = s[--cnt];
80006670:	11 8b       	ld.ub	r11,r8[0x0]
80006672:	12 cb       	st.b	r9++,r11
80006674:	20 18       	sub	r8,1
	}
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
80006676:	1c 38       	cp.w	r8,lr
80006678:	cf c1       	brne	80006670 <PrintHex+0xa0>
	*p++ = s[--cnt];
		
	return str;
}
8000667a:	14 9c       	mov	r12,r10
8000667c:	2f dd       	sub	sp,-12
8000667e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

80006682 <PrintDec>:
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
{
80006682:	d4 21       	pushm	r4-r7,lr
80006684:	20 3d       	sub	sp,12
80006686:	18 98       	mov	r8,r12
	char * p = str;
	
	int sign = i>=0 ? 0 : 1;
	char s[10];
	memset(s, 0 , 10);
80006688:	30 06       	mov	r6,0
8000668a:	30 07       	mov	r7,0
8000668c:	fa e7 00 00 	st.d	sp[0],r6
80006690:	30 0c       	mov	r12,0
80006692:	ba 4c       	st.h	sp[0x8],r12
	int cnt=0;
	if(sign)
80006694:	58 08       	cp.w	r8,0
80006696:	c0 35       	brlt	8000669c <PrintDec+0x1a>
80006698:	14 97       	mov	r7,r10
8000669a:	c0 58       	rjmp	800066a4 <PrintDec+0x22>
	{
		*p++ = '-';
8000669c:	14 97       	mov	r7,r10
8000669e:	32 d9       	mov	r9,45
800066a0:	0e c9       	st.b	r7++,r9
		i = -i;
800066a2:	5c 38       	neg	r8
	}
	
	if(i == 0 )s[cnt++] = '0';
800066a4:	58 08       	cp.w	r8,0
800066a6:	c0 51       	brne	800066b0 <PrintDec+0x2e>
800066a8:	33 08       	mov	r8,48
800066aa:	ba 88       	st.b	sp[0x0],r8
800066ac:	30 1e       	mov	lr,1
800066ae:	c2 f8       	rjmp	8000670c <PrintDec+0x8a>
	
	int ten = i%10;
800066b0:	e0 65 66 67 	mov	r5,26215
800066b4:	ea 15 66 66 	orh	r5,0x6666
800066b8:	f0 05 04 44 	muls.d	r4,r8,r5
800066bc:	ea 0c 14 02 	asr	r12,r5,0x2
800066c0:	f0 09 14 1f 	asr	r9,r8,0x1f
800066c4:	f8 09 01 09 	sub	r9,r12,r9
800066c8:	f2 09 00 29 	add	r9,r9,r9<<0x2
800066cc:	f0 09 01 19 	sub	r9,r8,r9<<0x1
800066d0:	30 0e       	mov	lr,0
	while(i)
	{
		s[cnt] = ten+'0';
800066d2:	1a 9c       	mov	r12,sp
		cnt++;
		i /= 10;
800066d4:	e0 66 66 67 	mov	r6,26215
800066d8:	ea 16 66 66 	orh	r6,0x6666
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
	{
		s[cnt] = ten+'0';
800066dc:	2d 09       	sub	r9,-48
800066de:	f8 0e 0b 09 	st.b	r12[lr],r9
		cnt++;
800066e2:	2f fe       	sub	lr,-1
		i /= 10;
800066e4:	f0 06 04 44 	muls.d	r4,r8,r6
800066e8:	ea 09 14 02 	asr	r9,r5,0x2
800066ec:	bf 58       	asr	r8,0x1f
800066ee:	f2 08 01 08 	sub	r8,r9,r8
		ten = i%10;
800066f2:	f0 06 04 44 	muls.d	r4,r8,r6
800066f6:	ea 09 14 02 	asr	r9,r5,0x2
800066fa:	f0 05 14 1f 	asr	r5,r8,0x1f
800066fe:	0a 19       	sub	r9,r5
80006700:	f2 09 00 29 	add	r9,r9,r9<<0x2
80006704:	f0 09 01 19 	sub	r9,r8,r9<<0x1
	}
	
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
80006708:	58 08       	cp.w	r8,0
8000670a:	ce 91       	brne	800066dc <PrintDec+0x5a>
		cnt++;
		i /= 10;
		ten = i%10;
	}
	
	if(len - cnt > 0 )
8000670c:	f6 0e 01 08 	sub	r8,r11,lr
80006710:	58 08       	cp.w	r8,0
80006712:	e0 89 00 06 	brgt	8000671e <PrintDec+0x9c>
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80006716:	58 0e       	cp.w	lr,0
80006718:	e0 89 00 14 	brgt	80006740 <PrintDec+0xbe>
8000671c:	c1 d8       	rjmp	80006756 <PrintDec+0xd4>
		ten = i%10;
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
8000671e:	1c 1b       	sub	r11,lr
80006720:	5c 5b       	castu.b	r11
		for(int i = 0; i < num; i++)
80006722:	16 9c       	mov	r12,r11
80006724:	58 0b       	cp.w	r11,0
80006726:	fe 9a ff f8 	brle	80006716 <PrintDec+0x94>
8000672a:	1a 99       	mov	r9,sp
8000672c:	1c 09       	add	r9,lr
8000672e:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80006730:	33 06       	mov	r6,48
80006732:	12 c6       	st.b	r9++,r6
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80006734:	2f f8       	sub	r8,-1
80006736:	18 38       	cp.w	r8,r12
80006738:	cf d5       	brlt	80006732 <PrintDec+0xb0>
{
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
8000673a:	f6 0e 00 0e 	add	lr,r11,lr
8000673e:	ce cb       	rjmp	80006716 <PrintDec+0x94>
80006740:	fa c8 ff f4 	sub	r8,sp,-12
80006744:	1c 08       	add	r8,lr
80006746:	20 d8       	sub	r8,13
80006748:	fa cb 00 01 	sub	r11,sp,1
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
	*p++ = s[--cnt];
8000674c:	11 89       	ld.ub	r9,r8[0x0]
8000674e:	0e c9       	st.b	r7++,r9
80006750:	20 18       	sub	r8,1
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80006752:	16 38       	cp.w	r8,r11
80006754:	cf c1       	brne	8000674c <PrintDec+0xca>
	*p++ = s[--cnt];
	
	return str;
}
80006756:	14 9c       	mov	r12,r10
80006758:	2f dd       	sub	sp,-12
8000675a:	d8 22       	popm	r4-r7,pc

8000675c <log>:
	,  NULL );
	
}

int log(char * content, ...)
{
8000675c:	d4 31       	pushm	r0-r7,lr
8000675e:	fa cd 02 08 	sub	sp,sp,520
80006762:	18 97       	mov	r7,r12
	
	
	char logTmp[MAX_LOG_LINE_SIZE];
	memset(logTmp, '\0', MAX_LOG_LINE_SIZE);	
80006764:	e0 6a 01 00 	mov	r10,256
80006768:	30 0b       	mov	r11,0
8000676a:	fa cc fe f8 	sub	r12,sp,-264
8000676e:	f0 1f 00 4e 	mcall	800068a4 <log+0x148>
	,  tskLOG_PRIORITY
	,  NULL );
	
}

int log(char * content, ...)
80006772:	fa c4 fd d4 	sub	r4,sp,-556
80006776:	30 0a       	mov	r10,0
80006778:	50 0a       	stdsp	sp[0x0],r10
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
8000677a:	fa c3 ff fc 	sub	r3,sp,-4
8000677e:	e0 61 01 00 	mov	r1,256
80006782:	14 90       	mov	r0,r10
			
					if(*str == '%')
80006784:	32 52       	mov	r2,37
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
80006786:	fa c6 fe f8 	sub	r6,sp,-264
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
8000678a:	02 9a       	mov	r10,r1
8000678c:	00 9b       	mov	r11,r0
8000678e:	06 9c       	mov	r12,r3
80006790:	f0 1f 00 45 	mcall	800068a4 <log+0x148>
			
					if(*str == '%')
80006794:	0f 88       	ld.ub	r8,r7[0x0]
80006796:	e4 08 18 00 	cp.b	r8,r2
8000679a:	c5 71       	brne	80006848 <log+0xec>
					{
						static char lench = 0;
						lench =*(str + 1);
8000679c:	ee c8 ff ff 	sub	r8,r7,-1
800067a0:	11 89       	ld.ub	r9,r8[0x0]
800067a2:	4c 2a       	lddpc	r10,800068a8 <log+0x14c>
800067a4:	b4 89       	st.b	r10[0x0],r9
						if((lench >= '0') &&  (lench <= '9'))
800067a6:	23 09       	sub	r9,48
800067a8:	30 9a       	mov	r10,9
800067aa:	f4 09 18 00 	cp.b	r9,r10
800067ae:	ee 08 17 b0 	movhi	r8,r7
						{
							len = *(++str) - '0';
800067b2:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
800067b6:	f7 b9 08 30 	subls	r9,48
800067ba:	fb f9 8a 00 	st.wls	sp[0x0],r9
						}
						
						str++;
800067be:	f0 c7 ff ff 	sub	r7,r8,-1
						
						switch(*(str))
800067c2:	0f 88       	ld.ub	r8,r7[0x0]
800067c4:	22 58       	sub	r8,37
800067c6:	e0 48 00 53 	cp.w	r8,83
800067ca:	e0 8b 00 31 	brhi	8000682c <log+0xd0>
800067ce:	4b 89       	lddpc	r9,800068ac <log+0x150>
800067d0:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
						{
							case('i'):
							case('I'):
							case('d'):
							case('D'):
							x = va_arg(arg_ptr,int);
800067d4:	e8 c5 ff fc 	sub	r5,r4,-4
							strTmp = PrintDec(x, len, strTmp);
800067d8:	06 9a       	mov	r10,r3
800067da:	40 0b       	lddsp	r11,sp[0x0]
800067dc:	5c 5b       	castu.b	r11
800067de:	68 0c       	ld.w	r12,r4[0x0]
800067e0:	f0 1f 00 34 	mcall	800068b0 <log+0x154>
							break;
800067e4:	c2 98       	rjmp	80006836 <log+0xda>
							
							case('f')://
							case('F'):
							//f = va_arg(arg_ptr,int);
							//strTmp = PrintDec(x, len, strTmp);
							log("I need float.");
800067e6:	4b 4c       	lddpc	r12,800068b4 <log+0x158>
800067e8:	f0 1f 00 34 	mcall	800068b8 <log+0x15c>
800067ec:	08 95       	mov	r5,r4
800067ee:	06 9c       	mov	r12,r3
							break;
800067f0:	c2 38       	rjmp	80006836 <log+0xda>
							
							
							case('x'):
							case('X'):
							x = va_arg(arg_ptr,int);
800067f2:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintHex(x,len, strTmp);
800067f6:	06 9a       	mov	r10,r3
800067f8:	40 0b       	lddsp	r11,sp[0x0]
800067fa:	5c 5b       	castu.b	r11
800067fc:	68 0c       	ld.w	r12,r4[0x0]
800067fe:	f0 1f 00 30 	mcall	800068bc <log+0x160>
80006802:	06 9c       	mov	r12,r3
							break;
80006804:	c1 98       	rjmp	80006836 <log+0xda>
							
							case('c'):
							case('C'):
							y = va_arg(arg_ptr,int);
80006806:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintChar(y, strTmp);
8000680a:	06 9b       	mov	r11,r3
8000680c:	09 bc       	ld.ub	r12,r4[0x3]
8000680e:	f0 1f 00 2d 	mcall	800068c0 <log+0x164>
80006812:	06 9c       	mov	r12,r3
							break;
80006814:	c1 18       	rjmp	80006836 <log+0xda>
							
							case('s'):
							case('S'):
							strTmp = va_arg(arg_ptr,char*);
80006816:	e8 c5 ff fc 	sub	r5,r4,-4
8000681a:	68 0c       	ld.w	r12,r4[0x0]
							//PrintStr(s);
							break;
8000681c:	c0 d8       	rjmp	80006836 <log+0xda>
							
							case('%'):
							PrintChar('%', strTmp);
8000681e:	06 9b       	mov	r11,r3
80006820:	32 5c       	mov	r12,37
80006822:	f0 1f 00 28 	mcall	800068c0 <log+0x164>
80006826:	08 95       	mov	r5,r4
80006828:	06 9c       	mov	r12,r3
							//PrintChar('%');
							break;
8000682a:	c0 68       	rjmp	80006836 <log+0xda>
							
							default:
							log("I need relax.");
8000682c:	4a 6c       	lddpc	r12,800068c4 <log+0x168>
8000682e:	f0 1f 00 23 	mcall	800068b8 <log+0x15c>
80006832:	08 95       	mov	r5,r4
80006834:	06 9c       	mov	r12,r3
						}
						str++;
80006836:	2f f7       	sub	r7,-1
						
						length = sprintf(logTmp,"%s%s",logTmp,strTmp );
80006838:	1a dc       	st.w	--sp,r12
8000683a:	1a d6       	st.w	--sp,r6
8000683c:	4a 3b       	lddpc	r11,800068c8 <log+0x16c>
8000683e:	0c 9c       	mov	r12,r6
80006840:	f0 1f 00 23 	mcall	800068cc <log+0x170>
80006844:	2f ed       	sub	sp,-8
80006846:	c0 a8       	rjmp	8000685a <log+0xfe>
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
80006848:	2f f7       	sub	r7,-1
8000684a:	1a d8       	st.w	--sp,r8
8000684c:	1a d6       	st.w	--sp,r6
8000684e:	4a 1b       	lddpc	r11,800068d0 <log+0x174>
80006850:	0c 9c       	mov	r12,r6
80006852:	f0 1f 00 1f 	mcall	800068cc <log+0x170>
80006856:	08 95       	mov	r5,r4
80006858:	2f ed       	sub	sp,-8
			
			
			
	}while(*str != '\0');
8000685a:	0f 89       	ld.ub	r9,r7[0x0]
8000685c:	30 08       	mov	r8,0
8000685e:	f0 09 18 00 	cp.b	r9,r8
80006862:	c0 30       	breq	80006868 <log+0x10c>
80006864:	0a 94       	mov	r4,r5
80006866:	c9 2b       	rjmp	8000678a <log+0x2e>
		
		
				
	va_end(arg_ptr);
	//while(1)		
	length = sprintf(logTmp,"%s\r\n",logTmp);
80006868:	fa c7 fe f8 	sub	r7,sp,-264
8000686c:	1a d7       	st.w	--sp,r7
8000686e:	49 ab       	lddpc	r11,800068d4 <log+0x178>
80006870:	0e 9c       	mov	r12,r7
80006872:	f0 1f 00 17 	mcall	800068cc <log+0x170>
	
	char * p = pvPortMalloc(length+1);
80006876:	5c 5c       	castu.b	r12
80006878:	f8 c6 ff ff 	sub	r6,r12,-1
8000687c:	0c 9c       	mov	r12,r6
8000687e:	f0 1f 00 17 	mcall	800068d8 <log+0x17c>
80006882:	54 2c       	stdsp	sp[0x108],r12
	memcpy(p, logTmp, length+1);
80006884:	0c 9a       	mov	r10,r6
80006886:	0e 9b       	mov	r11,r7
80006888:	f0 1f 00 15 	mcall	800068dc <log+0x180>
	//
	//usart_write_line(EXAMPLE_USART, logTmp);
	xQueueSend( logQueue, &p, 5);
8000688c:	30 09       	mov	r9,0
8000688e:	30 5a       	mov	r10,5
80006890:	fa cb fe f8 	sub	r11,sp,-264
80006894:	49 38       	lddpc	r8,800068e0 <log+0x184>
80006896:	70 0c       	ld.w	r12,r8[0x0]
80006898:	f0 1f 00 13 	mcall	800068e4 <log+0x188>
8000689c:	2f fd       	sub	sp,-4
}
8000689e:	fe 3d fd f8 	sub	sp,-520
800068a2:	d8 32       	popm	r0-r7,pc
800068a4:	80 00       	ld.sh	r0,r0[0x0]
800068a6:	72 04       	ld.w	r4,r9[0x0]
800068a8:	00 00       	add	r0,r0
800068aa:	0d 78       	ld.ub	r8,--r6
800068ac:	80 01       	ld.sh	r1,r0[0x0]
800068ae:	5a f0       	cp.w	r0,-17
800068b0:	80 00       	ld.sh	r0,r0[0x0]
800068b2:	66 82       	ld.w	r2,r3[0x20]
800068b4:	80 01       	ld.sh	r1,r0[0x0]
800068b6:	5d 9c       	*unknown*
800068b8:	80 00       	ld.sh	r0,r0[0x0]
800068ba:	67 5c       	ld.w	r12,r3[0x54]
800068bc:	80 00       	ld.sh	r0,r0[0x0]
800068be:	65 d0       	ld.w	r0,r2[0x74]
800068c0:	80 00       	ld.sh	r0,r0[0x0]
800068c2:	65 cc       	ld.w	r12,r2[0x70]
800068c4:	80 01       	ld.sh	r1,r0[0x0]
800068c6:	5d ac       	*unknown*
800068c8:	80 01       	ld.sh	r1,r0[0x0]
800068ca:	5d bc       	*unknown*
800068cc:	80 00       	ld.sh	r0,r0[0x0]
800068ce:	74 f4       	ld.w	r4,r10[0x3c]
800068d0:	80 01       	ld.sh	r1,r0[0x0]
800068d2:	5d c4       	*unknown*
800068d4:	80 01       	ld.sh	r1,r0[0x0]
800068d6:	5d cc       	*unknown*
800068d8:	80 00       	ld.sh	r0,r0[0x0]
800068da:	58 18       	cp.w	r8,1
800068dc:	80 00       	ld.sh	r0,r0[0x0]
800068de:	70 bc       	ld.w	r12,r8[0x2c]
800068e0:	00 00       	add	r0,r0
800068e2:	41 1c       	lddsp	r12,sp[0x44]
800068e4:	80 00       	ld.sh	r0,r0[0x0]
800068e6:	5b 6c       	cp.w	r12,-10

800068e8 <logFromISR>:
	
	
int logFromISR(char * content, ...)
	{
800068e8:	d4 31       	pushm	r0-r7,lr
800068ea:	fa cd 02 0c 	sub	sp,sp,524
800068ee:	18 97       	mov	r7,r12
		
		
		char logTmp[MAX_LOG_LINE_SIZE];
		memset(logTmp, '\0', MAX_LOG_LINE_SIZE);
800068f0:	e0 6a 01 00 	mov	r10,256
800068f4:	30 0b       	mov	r11,0
800068f6:	fa cc fe f4 	sub	r12,sp,-268
800068fa:	f0 1f 00 4c 	mcall	80006a28 <logFromISR+0x140>
	//usart_write_line(EXAMPLE_USART, logTmp);
	xQueueSend( logQueue, &p, 5);
}
	
	
int logFromISR(char * content, ...)
800068fe:	fa c4 fd d0 	sub	r4,sp,-560
80006902:	30 0a       	mov	r10,0
80006904:	50 0a       	stdsp	sp[0x0],r10
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80006906:	fa c3 ff fc 	sub	r3,sp,-4
8000690a:	e0 61 01 00 	mov	r1,256
8000690e:	14 90       	mov	r0,r10
			
			if(*str == '%')
80006910:	32 52       	mov	r2,37
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
80006912:	fa c6 fe f4 	sub	r6,sp,-268
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80006916:	02 9a       	mov	r10,r1
80006918:	00 9b       	mov	r11,r0
8000691a:	06 9c       	mov	r12,r3
8000691c:	f0 1f 00 43 	mcall	80006a28 <logFromISR+0x140>
			
			if(*str == '%')
80006920:	0f 88       	ld.ub	r8,r7[0x0]
80006922:	e4 08 18 00 	cp.b	r8,r2
80006926:	c5 11       	brne	800069c8 <logFromISR+0xe0>
			{
				static char lench = 0;
				lench =*(str + 1);
80006928:	ee c8 ff ff 	sub	r8,r7,-1
8000692c:	11 89       	ld.ub	r9,r8[0x0]
8000692e:	4c 0a       	lddpc	r10,80006a2c <logFromISR+0x144>
80006930:	b4 89       	st.b	r10[0x0],r9
				if((lench >= '0') &&  (lench <= '9'))
80006932:	23 09       	sub	r9,48
80006934:	30 9a       	mov	r10,9
80006936:	f4 09 18 00 	cp.b	r9,r10
8000693a:	ee 08 17 b0 	movhi	r8,r7
				{
					len = *(++str) - '0';
8000693e:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
80006942:	f7 b9 08 30 	subls	r9,48
80006946:	fb f9 8a 00 	st.wls	sp[0x0],r9
				}
				
				str++;
8000694a:	f0 c7 ff ff 	sub	r7,r8,-1
				
				switch(*(str))
8000694e:	0f 88       	ld.ub	r8,r7[0x0]
80006950:	22 58       	sub	r8,37
80006952:	e0 48 00 53 	cp.w	r8,83
80006956:	e0 8b 00 2b 	brhi	800069ac <logFromISR+0xc4>
8000695a:	4b 69       	lddpc	r9,80006a30 <logFromISR+0x148>
8000695c:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
				{
					case('d'):
					case('D'):
					x = va_arg(arg_ptr,int);
80006960:	e8 c5 ff fc 	sub	r5,r4,-4
					strTmp = PrintDec(x, len, strTmp);
80006964:	06 9a       	mov	r10,r3
80006966:	40 0b       	lddsp	r11,sp[0x0]
80006968:	5c 5b       	castu.b	r11
8000696a:	68 0c       	ld.w	r12,r4[0x0]
8000696c:	f0 1f 00 32 	mcall	80006a34 <logFromISR+0x14c>
					break;
80006970:	c2 38       	rjmp	800069b6 <logFromISR+0xce>
					case('x'):
					case('X'):
					x = va_arg(arg_ptr,int);
80006972:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintHex(x,len, strTmp);
80006976:	06 9a       	mov	r10,r3
80006978:	40 0b       	lddsp	r11,sp[0x0]
8000697a:	5c 5b       	castu.b	r11
8000697c:	68 0c       	ld.w	r12,r4[0x0]
8000697e:	f0 1f 00 2f 	mcall	80006a38 <logFromISR+0x150>
80006982:	06 9c       	mov	r12,r3
					break;
80006984:	c1 98       	rjmp	800069b6 <logFromISR+0xce>
					case('c'):
					case('C'):
					y = va_arg(arg_ptr,int);
80006986:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintChar(y, strTmp);
8000698a:	06 9b       	mov	r11,r3
8000698c:	09 bc       	ld.ub	r12,r4[0x3]
8000698e:	f0 1f 00 2c 	mcall	80006a3c <logFromISR+0x154>
80006992:	06 9c       	mov	r12,r3
					break;
80006994:	c1 18       	rjmp	800069b6 <logFromISR+0xce>
					case('s'):
					case('S'):
					strTmp = va_arg(arg_ptr,char*);
80006996:	e8 c5 ff fc 	sub	r5,r4,-4
8000699a:	68 0c       	ld.w	r12,r4[0x0]
					//PrintStr(s);
					break;
8000699c:	c0 d8       	rjmp	800069b6 <logFromISR+0xce>
					case('%'):
					PrintChar('%', strTmp);
8000699e:	06 9b       	mov	r11,r3
800069a0:	32 5c       	mov	r12,37
800069a2:	f0 1f 00 27 	mcall	80006a3c <logFromISR+0x154>
800069a6:	08 95       	mov	r5,r4
800069a8:	06 9c       	mov	r12,r3
					//PrintChar('%');
					break;
800069aa:	c0 68       	rjmp	800069b6 <logFromISR+0xce>
					default:
					log("I need relax.");
800069ac:	4a 5c       	lddpc	r12,80006a40 <logFromISR+0x158>
800069ae:	f0 1f 00 26 	mcall	80006a44 <logFromISR+0x15c>
800069b2:	08 95       	mov	r5,r4
800069b4:	06 9c       	mov	r12,r3
				}
				str++;
800069b6:	2f f7       	sub	r7,-1
				
				length = sprintf(logTmp,"%s%s",logTmp,strTmp );
800069b8:	1a dc       	st.w	--sp,r12
800069ba:	1a d6       	st.w	--sp,r6
800069bc:	4a 3b       	lddpc	r11,80006a48 <logFromISR+0x160>
800069be:	0c 9c       	mov	r12,r6
800069c0:	f0 1f 00 23 	mcall	80006a4c <logFromISR+0x164>
800069c4:	2f ed       	sub	sp,-8
800069c6:	c0 a8       	rjmp	800069da <logFromISR+0xf2>
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
800069c8:	2f f7       	sub	r7,-1
800069ca:	1a d8       	st.w	--sp,r8
800069cc:	1a d6       	st.w	--sp,r6
800069ce:	4a 1b       	lddpc	r11,80006a50 <logFromISR+0x168>
800069d0:	0c 9c       	mov	r12,r6
800069d2:	f0 1f 00 1f 	mcall	80006a4c <logFromISR+0x164>
800069d6:	08 95       	mov	r5,r4
800069d8:	2f ed       	sub	sp,-8
			
			
			
		}while(*str != '\0');
800069da:	0f 89       	ld.ub	r9,r7[0x0]
800069dc:	30 08       	mov	r8,0
800069de:	f0 09 18 00 	cp.b	r9,r8
800069e2:	c0 30       	breq	800069e8 <logFromISR+0x100>
800069e4:	0a 94       	mov	r4,r5
800069e6:	c9 8b       	rjmp	80006916 <logFromISR+0x2e>
		
		
		
		va_end(arg_ptr);
		//while(1)
		length = sprintf(logTmp,"%s\r\n",logTmp);
800069e8:	fa c7 fe f4 	sub	r7,sp,-268
800069ec:	1a d7       	st.w	--sp,r7
800069ee:	49 ab       	lddpc	r11,80006a54 <logFromISR+0x16c>
800069f0:	0e 9c       	mov	r12,r7
800069f2:	f0 1f 00 17 	mcall	80006a4c <logFromISR+0x164>
		
		char * p = pvPortMalloc(length+1);
800069f6:	5c 5c       	castu.b	r12
800069f8:	f8 c6 ff ff 	sub	r6,r12,-1
800069fc:	0c 9c       	mov	r12,r6
800069fe:	f0 1f 00 17 	mcall	80006a58 <logFromISR+0x170>
80006a02:	54 3c       	stdsp	sp[0x10c],r12
		memcpy(p, logTmp, length+1);
80006a04:	0c 9a       	mov	r10,r6
80006a06:	0e 9b       	mov	r11,r7
80006a08:	f0 1f 00 15 	mcall	80006a5c <logFromISR+0x174>
		//
		portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80006a0c:	30 09       	mov	r9,0
80006a0e:	54 29       	stdsp	sp[0x108],r9
		
		//usart_write_line(EXAMPLE_USART, p);
		//vPortFree(p);
		xQueueSendFromISR( logQueue, &p, &xHigherPriorityTaskWoken );
80006a10:	fa ca fe f8 	sub	r10,sp,-264
80006a14:	fa cb fe f4 	sub	r11,sp,-268
80006a18:	49 28       	lddpc	r8,80006a60 <logFromISR+0x178>
80006a1a:	70 0c       	ld.w	r12,r8[0x0]
80006a1c:	f0 1f 00 12 	mcall	80006a64 <logFromISR+0x17c>
80006a20:	2f fd       	sub	sp,-4
		//if (xHigherPriorityTaskWoken == pdTRUE)
		//{
			////taskYIELD();
		//}
	}
80006a22:	fe 3d fd f4 	sub	sp,-524
80006a26:	d8 32       	popm	r0-r7,pc
80006a28:	80 00       	ld.sh	r0,r0[0x0]
80006a2a:	72 04       	ld.w	r4,r9[0x0]
80006a2c:	00 00       	add	r0,r0
80006a2e:	0d 79       	ld.ub	r9,--r6
80006a30:	80 01       	ld.sh	r1,r0[0x0]
80006a32:	5c 40       	abs	r0
80006a34:	80 00       	ld.sh	r0,r0[0x0]
80006a36:	66 82       	ld.w	r2,r3[0x20]
80006a38:	80 00       	ld.sh	r0,r0[0x0]
80006a3a:	65 d0       	ld.w	r0,r2[0x74]
80006a3c:	80 00       	ld.sh	r0,r0[0x0]
80006a3e:	65 cc       	ld.w	r12,r2[0x70]
80006a40:	80 01       	ld.sh	r1,r0[0x0]
80006a42:	5d ac       	*unknown*
80006a44:	80 00       	ld.sh	r0,r0[0x0]
80006a46:	67 5c       	ld.w	r12,r3[0x54]
80006a48:	80 01       	ld.sh	r1,r0[0x0]
80006a4a:	5d bc       	*unknown*
80006a4c:	80 00       	ld.sh	r0,r0[0x0]
80006a4e:	74 f4       	ld.w	r4,r10[0x3c]
80006a50:	80 01       	ld.sh	r1,r0[0x0]
80006a52:	5d c4       	*unknown*
80006a54:	80 01       	ld.sh	r1,r0[0x0]
80006a56:	5d cc       	*unknown*
80006a58:	80 00       	ld.sh	r0,r0[0x0]
80006a5a:	58 18       	cp.w	r8,1
80006a5c:	80 00       	ld.sh	r0,r0[0x0]
80006a5e:	70 bc       	ld.w	r12,r8[0x2c]
80006a60:	00 00       	add	r0,r0
80006a62:	41 1c       	lddsp	r12,sp[0x44]
80006a64:	80 00       	ld.sh	r0,r0[0x0]
80006a66:	5b 1c       	cp.w	r12,-15

80006a68 <log_init>:
		
	return str;
}

void log_init(void)
{
80006a68:	d4 01       	pushm	lr
		.stopbits     = USART_1_STOPBIT,
		.channelmode  = USART_NORMAL_CHMODE
	};

	// Assign GPIO to USART.
	gpio_enable_module(USART_GPIO_MAP,
80006a6a:	30 2b       	mov	r11,2
80006a6c:	49 0c       	lddpc	r12,80006aac <log_init+0x44>
80006a6e:	f0 1f 00 11 	mcall	80006ab0 <log_init+0x48>
	sizeof(USART_GPIO_MAP) / sizeof(USART_GPIO_MAP[0]));

	// Initialize USART in RS232 mode.
	usart_init_rs232(EXAMPLE_USART, &USART_OPTIONS, EXAMPLE_TARGET_PBACLK_FREQ_HZ);			
80006a72:	e0 6a 36 00 	mov	r10,13824
80006a76:	ea 1a 01 6e 	orh	r10,0x16e
80006a7a:	48 fb       	lddpc	r11,80006ab4 <log_init+0x4c>
80006a7c:	fe 7c 18 00 	mov	r12,-59392
80006a80:	f0 1f 00 0e 	mcall	80006ab8 <log_init+0x50>
			
	logQueue  = xQueueCreate(50, sizeof(char *));
80006a84:	30 4b       	mov	r11,4
80006a86:	33 2c       	mov	r12,50
80006a88:	f0 1f 00 0d 	mcall	80006abc <log_init+0x54>
80006a8c:	48 d8       	lddpc	r8,80006ac0 <log_init+0x58>
80006a8e:	91 0c       	st.w	r8[0x0],r12
	
	xTaskCreate(
80006a90:	30 09       	mov	r9,0
80006a92:	1a d9       	st.w	--sp,r9
80006a94:	1a d9       	st.w	--sp,r9
80006a96:	1a d9       	st.w	--sp,r9
80006a98:	30 28       	mov	r8,2
80006a9a:	e0 6a 01 80 	mov	r10,384
80006a9e:	48 ab       	lddpc	r11,80006ac4 <log_init+0x5c>
80006aa0:	48 ac       	lddpc	r12,80006ac8 <log_init+0x60>
80006aa2:	f0 1f 00 0b 	mcall	80006acc <log_init+0x64>
80006aa6:	2f dd       	sub	sp,-12
	,  384
	,  NULL
	,  tskLOG_PRIORITY
	,  NULL );
	
}
80006aa8:	d8 02       	popm	pc
80006aaa:	00 00       	add	r0,r0
80006aac:	80 01       	ld.sh	r1,r0[0x0]
80006aae:	5d d8       	*unknown*
80006ab0:	80 00       	ld.sh	r0,r0[0x0]
80006ab2:	6b f4       	ld.w	r4,r5[0x7c]
80006ab4:	80 01       	ld.sh	r1,r0[0x0]
80006ab6:	5d 90       	*unknown*
80006ab8:	80 00       	ld.sh	r0,r0[0x0]
80006aba:	53 bc       	stdsp	sp[0xec],r12
80006abc:	80 00       	ld.sh	r0,r0[0x0]
80006abe:	5c c4       	swap.bh	r4
80006ac0:	00 00       	add	r0,r0
80006ac2:	41 1c       	lddsp	r12,sp[0x44]
80006ac4:	80 01       	ld.sh	r1,r0[0x0]
80006ac6:	5d d4       	*unknown*
80006ac8:	80 00       	ld.sh	r0,r0[0x0]
80006aca:	6a d0       	ld.w	r0,r5[0x34]
80006acc:	80 00       	ld.sh	r0,r0[0x0]
80006ace:	63 98       	ld.w	r8,r1[0x64]

80006ad0 <task_log>:
			////taskYIELD();
		//}
	}
	
static void task_log(void * pvParameters)
{
80006ad0:	eb cd 40 f8 	pushm	r3-r7,lr
80006ad4:	20 1d       	sub	sp,4
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
80006ad6:	48 c7       	lddpc	r7,80006b04 <task_log+0x34>
80006ad8:	30 05       	mov	r5,0
80006ada:	3f f4       	mov	r4,-1
		{
			if( NULL != str)
			{
				usart_write_line(EXAMPLE_USART, str);
80006adc:	fe 73 18 00 	mov	r3,-59392
{
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
80006ae0:	0a 99       	mov	r9,r5
80006ae2:	08 9a       	mov	r10,r4
80006ae4:	1a 9b       	mov	r11,sp
80006ae6:	6e 0c       	ld.w	r12,r7[0x0]
80006ae8:	f0 1f 00 08 	mcall	80006b08 <task_log+0x38>
80006aec:	58 1c       	cp.w	r12,1
80006aee:	cf 91       	brne	80006ae0 <task_log+0x10>
		{
			if( NULL != str)
80006af0:	40 0b       	lddsp	r11,sp[0x0]
80006af2:	58 0b       	cp.w	r11,0
80006af4:	cf 60       	breq	80006ae0 <task_log+0x10>
			{
				usart_write_line(EXAMPLE_USART, str);
80006af6:	06 9c       	mov	r12,r3
80006af8:	f0 1f 00 05 	mcall	80006b0c <task_log+0x3c>
				vPortFree(str);
80006afc:	40 0c       	lddsp	r12,sp[0x0]
80006afe:	f0 1f 00 05 	mcall	80006b10 <task_log+0x40>
80006b02:	ce fb       	rjmp	80006ae0 <task_log+0x10>
80006b04:	00 00       	add	r0,r0
80006b06:	41 1c       	lddsp	r12,sp[0x44]
80006b08:	80 00       	ld.sh	r0,r0[0x0]
80006b0a:	59 60       	cp.w	r0,22
80006b0c:	80 00       	ld.sh	r0,r0[0x0]
80006b0e:	53 6c       	stdsp	sp[0xd8],r12
80006b10:	80 00       	ld.sh	r0,r0[0x0]
80006b12:	57 f0       	stdsp	sp[0x1fc],r0

80006b14 <main>:

#include "fs/fs.h"
#include "rtc/rtc.h"

int main(void)
{
80006b14:	d4 01       	pushm	lr
	//Force SSC_TX_DATA_ENABLE Disabled as soon as possible.
	AVR32_GPIO.port[1].ovrs  =  0x00000001;  //Value will be high.
80006b16:	fe 78 10 00 	mov	r8,-61440
80006b1a:	30 19       	mov	r9,1
80006b1c:	f1 49 01 54 	st.w	r8[340],r9
	AVR32_GPIO.port[1].oders =  0x00000001;  //Output Driver will be Enabled.
80006b20:	f1 49 01 44 	st.w	r8[324],r9
	AVR32_GPIO.port[1].gpers =  0x00000001;  //Enable as GPIO.
80006b24:	f1 49 01 04 	st.w	r8[260],r9
	
	Disable_global_interrupt();
80006b28:	d3 03       	ssrf	0x10
	local_start_pll0();
80006b2a:	f0 1f 00 13 	mcall	80006b74 <main+0x60>
		
	INTC_init_interrupts();
80006b2e:	f0 1f 00 13 	mcall	80006b78 <main+0x64>
	
	log_init();		
80006b32:	f0 1f 00 13 	mcall	80006b7c <main+0x68>
	log("----start debug----");	
80006b36:	49 3c       	lddpc	r12,80006b80 <main+0x6c>
80006b38:	f0 1f 00 13 	mcall	80006b84 <main+0x70>
		
	rtc_init();
80006b3c:	f0 1f 00 13 	mcall	80006b88 <main+0x74>
	
	//fs_init();//65795

	tc_init();	
80006b40:	f0 1f 00 13 	mcall	80006b8c <main+0x78>
			
	xcmp_init();
80006b44:	f0 1f 00 13 	mcall	80006b90 <main+0x7c>
	
	app_init();
80006b48:	f0 1f 00 13 	mcall	80006b94 <main+0x80>
		
	while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
80006b4c:	fe 79 10 00 	mov	r9,-61440
80006b50:	f2 f8 01 60 	ld.w	r8,r9[352]
80006b54:	e2 18 00 02 	andl	r8,0x2,COH
80006b58:	cf c0       	breq	80006b50 <main+0x3c>
	while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
80006b5a:	fe 79 10 00 	mov	r9,-61440
80006b5e:	f2 f8 01 60 	ld.w	r8,r9[352]
80006b62:	e2 18 00 02 	andl	r8,0x2,COH
80006b66:	cf c1       	brne	80006b5e <main+0x4a>
	local_start_timer();
80006b68:	f0 1f 00 0c 	mcall	80006b98 <main+0x84>
	
	Enable_global_interrupt();
80006b6c:	d5 03       	csrf	0x10
	
	vTaskStartScheduler();		
80006b6e:	f0 1f 00 0c 	mcall	80006b9c <main+0x88>
	return 0;
}
80006b72:	d8 0a       	popm	pc,r12=0
80006b74:	80 00       	ld.sh	r0,r0[0x0]
80006b76:	4c 8c       	lddpc	r12,80006c94 <_malloc_r+0x10>
80006b78:	80 00       	ld.sh	r0,r0[0x0]
80006b7a:	4e a8       	lddpc	r8,80006d20 <_malloc_r+0x9c>
80006b7c:	80 00       	ld.sh	r0,r0[0x0]
80006b7e:	6a 68       	ld.w	r8,r5[0x18]
80006b80:	80 01       	ld.sh	r1,r0[0x0]
80006b82:	5d e8       	*unknown*
80006b84:	80 00       	ld.sh	r0,r0[0x0]
80006b86:	67 5c       	ld.w	r12,r3[0x54]
80006b88:	80 00       	ld.sh	r0,r0[0x0]
80006b8a:	4c dc       	lddpc	r12,80006cbc <_malloc_r+0x38>
80006b8c:	80 00       	ld.sh	r0,r0[0x0]
80006b8e:	4d a4       	lddpc	r4,80006cf4 <_malloc_r+0x70>
80006b90:	80 00       	ld.sh	r0,r0[0x0]
80006b92:	45 90       	lddsp	r0,sp[0x164]
80006b94:	80 00       	ld.sh	r0,r0[0x0]
80006b96:	20 40       	sub	r0,4
80006b98:	80 00       	ld.sh	r0,r0[0x0]
80006b9a:	4d 68       	lddpc	r8,80006cf0 <_malloc_r+0x6c>
80006b9c:	80 00       	ld.sh	r0,r0[0x0]
80006b9e:	65 80       	ld.w	r0,r2[0x60]

80006ba0 <gpio_enable_module_pin>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80006ba0:	f8 08 16 05 	lsr	r8,r12,0x5
80006ba4:	a9 68       	lsl	r8,0x8
80006ba6:	e0 28 f0 00 	sub	r8,61440

	/* Enable the correct function. */
	switch (function) {
80006baa:	58 1b       	cp.w	r11,1
80006bac:	c0 d0       	breq	80006bc6 <gpio_enable_module_pin+0x26>
80006bae:	c0 63       	brcs	80006bba <gpio_enable_module_pin+0x1a>
80006bb0:	58 2b       	cp.w	r11,2
80006bb2:	c1 00       	breq	80006bd2 <gpio_enable_module_pin+0x32>
80006bb4:	58 3b       	cp.w	r11,3
80006bb6:	c1 40       	breq	80006bde <gpio_enable_module_pin+0x3e>
80006bb8:	5e ff       	retal	1
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80006bba:	30 19       	mov	r9,1
80006bbc:	f2 0c 09 49 	lsl	r9,r9,r12
80006bc0:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80006bc2:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80006bc4:	c1 28       	rjmp	80006be8 <gpio_enable_module_pin+0x48>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80006bc6:	30 19       	mov	r9,1
80006bc8:	f2 0c 09 49 	lsl	r9,r9,r12
80006bcc:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80006bce:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80006bd0:	c0 c8       	rjmp	80006be8 <gpio_enable_module_pin+0x48>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80006bd2:	30 19       	mov	r9,1
80006bd4:	f2 0c 09 49 	lsl	r9,r9,r12
80006bd8:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80006bda:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80006bdc:	c0 68       	rjmp	80006be8 <gpio_enable_module_pin+0x48>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80006bde:	30 19       	mov	r9,1
80006be0:	f2 0c 09 49 	lsl	r9,r9,r12
80006be4:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80006be6:	91 99       	st.w	r8[0x24],r9
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
80006be8:	30 19       	mov	r9,1
80006bea:	f2 0c 09 4c 	lsl	r12,r9,r12
80006bee:	91 2c       	st.w	r8[0x8],r12
80006bf0:	5e fd       	retal	0
80006bf2:	d7 03       	nop

80006bf4 <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
80006bf4:	d4 21       	pushm	r4-r7,lr
80006bf6:	18 97       	mov	r7,r12
80006bf8:	16 94       	mov	r4,r11
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80006bfa:	58 0b       	cp.w	r11,0
80006bfc:	c0 31       	brne	80006c02 <gpio_enable_module+0xe>
80006bfe:	30 05       	mov	r5,0
80006c00:	c0 d8       	rjmp	80006c1a <gpio_enable_module+0x26>
80006c02:	30 06       	mov	r6,0
80006c04:	0c 95       	mov	r5,r6
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
80006c06:	6e 1b       	ld.w	r11,r7[0x4]
80006c08:	6e 0c       	ld.w	r12,r7[0x0]
80006c0a:	f0 1f 00 06 	mcall	80006c20 <gpio_enable_module+0x2c>
80006c0e:	18 45       	or	r5,r12
		gpiomap++;
80006c10:	2f 87       	sub	r7,-8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80006c12:	2f f6       	sub	r6,-1
80006c14:	0c 34       	cp.w	r4,r6
80006c16:	fe 9b ff f8 	brhi	80006c06 <gpio_enable_module+0x12>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
}
80006c1a:	0a 9c       	mov	r12,r5
80006c1c:	d8 22       	popm	r4-r7,pc
80006c1e:	00 00       	add	r0,r0
80006c20:	80 00       	ld.sh	r0,r0[0x0]
80006c22:	6b a0       	ld.w	r0,r5[0x68]

80006c24 <_stext>:

  .global _stext
  .type _stext, @function
_stext:
  // Set initial stack pointer.
  lda.w   sp, _estack
80006c24:	e0 7d 80 00 	mov	sp,98304

  // Set up EVBA so interrupts can be enabled.
  lda.w   r0, _evba
  mtsr    AVR32_EVBA, r0
80006c28:	fe c0 a6 28 	sub	r0,pc,-23000

  // Enable the exception processing.
  csrf    AVR32_SR_EM_OFFSET
80006c2c:	e3 b0 00 01 	mtsr	0x4,r0

  // Load initialized data having a global lifetime from the data LMA.
  lda.w   r0, _data
  lda.w   r1, _edata
80006c30:	d5 53       	csrf	0x15
  cp      r0, r1
80006c32:	30 80       	mov	r0,8
  brhs    idata_load_loop_end
80006c34:	e0 61 0a 38 	mov	r1,2616
  lda.w   r2, _data_lma
idata_load_loop:
  ld.d    r4, r2++
80006c38:	02 30       	cp.w	r0,r1
  st.d    r0++, r4
80006c3a:	c0 62       	brcc	80006c46 <idata_load_loop_end>
  cp      r0, r1
80006c3c:	48 92       	lddpc	r2,80006c60 <udata_clear_loop_end+0x4>

80006c3e <idata_load_loop>:
  brlo    idata_load_loop
80006c3e:	a5 05       	ld.d	r4,r2++
idata_load_loop_end:

  // Clear uninitialized data having a global lifetime in the blank static storage section.
  lda.w   r0, __bss_start
80006c40:	a1 24       	st.d	r0++,r4
  lda.w   r1, _end
80006c42:	02 30       	cp.w	r0,r1
  cp      r0, r1
80006c44:	cf d3       	brcs	80006c3e <idata_load_loop>

80006c46 <idata_load_loop_end>:
  brhs    udata_clear_loop_end
80006c46:	e0 60 0a 38 	mov	r0,2616
  mov     r2, 0
  mov     r3, 0
80006c4a:	e0 61 41 28 	mov	r1,16680
udata_clear_loop:
  st.d    r0++, r2
  cp      r0, r1
80006c4e:	02 30       	cp.w	r0,r1
  brlo    udata_clear_loop
80006c50:	c0 62       	brcc	80006c5c <udata_clear_loop_end>
  // Safety: Set the default "return" @ to the exit routine address.
  lda.w   lr, exit
#endif

  // Start the show.
  lda.w   pc, main
80006c52:	30 02       	mov	r2,0
80006c54:	30 03       	mov	r3,0

80006c56 <udata_clear_loop>:
80006c56:	a1 22       	st.d	r0++,r2
80006c58:	02 30       	cp.w	r0,r1
80006c5a:	cf e3       	brcs	80006c56 <udata_clear_loop>

80006c5c <udata_clear_loop_end>:
80006c5c:	fe cf 01 48 	sub	pc,pc,328
80006c60:	80 01       	ld.sh	r1,r0[0x0]
80006c62:	63 80       	ld.w	r0,r1[0x60]

80006c64 <free>:
80006c64:	d4 01       	pushm	lr
80006c66:	e0 68 0a 30 	mov	r8,2608
80006c6a:	18 9b       	mov	r11,r12
80006c6c:	70 0c       	ld.w	r12,r8[0x0]
80006c6e:	e0 a0 1e 8f 	rcall	8000a98c <_free_r>
80006c72:	d8 02       	popm	pc

80006c74 <malloc>:
80006c74:	d4 01       	pushm	lr
80006c76:	e0 68 0a 30 	mov	r8,2608
80006c7a:	18 9b       	mov	r11,r12
80006c7c:	70 0c       	ld.w	r12,r8[0x0]
80006c7e:	c0 3c       	rcall	80006c84 <_malloc_r>
80006c80:	d8 02       	popm	pc
80006c82:	d7 03       	nop

80006c84 <_malloc_r>:
80006c84:	d4 31       	pushm	r0-r7,lr
80006c86:	f6 c8 ff f5 	sub	r8,r11,-11
80006c8a:	18 95       	mov	r5,r12
80006c8c:	10 97       	mov	r7,r8
80006c8e:	e0 17 ff f8 	andl	r7,0xfff8
80006c92:	59 68       	cp.w	r8,22
80006c94:	f9 b7 08 10 	movls	r7,16
80006c98:	16 37       	cp.w	r7,r11
80006c9a:	5f 38       	srlo	r8
80006c9c:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
80006ca0:	c0 50       	breq	80006caa <_malloc_r+0x26>
80006ca2:	30 c8       	mov	r8,12
80006ca4:	99 38       	st.w	r12[0xc],r8
80006ca6:	e0 8f 01 fa 	bral	8000709a <_malloc_r+0x416>
80006caa:	fe b0 f5 59 	rcall	8000575c <__malloc_lock>
80006cae:	e0 47 01 f7 	cp.w	r7,503
80006cb2:	e0 8b 00 1d 	brhi	80006cec <_malloc_r+0x68>
80006cb6:	ee 03 16 03 	lsr	r3,r7,0x3
80006cba:	e0 68 05 30 	mov	r8,1328
80006cbe:	f0 03 00 38 	add	r8,r8,r3<<0x3
80006cc2:	70 36       	ld.w	r6,r8[0xc]
80006cc4:	10 36       	cp.w	r6,r8
80006cc6:	c0 61       	brne	80006cd2 <_malloc_r+0x4e>
80006cc8:	ec c8 ff f8 	sub	r8,r6,-8
80006ccc:	70 36       	ld.w	r6,r8[0xc]
80006cce:	10 36       	cp.w	r6,r8
80006cd0:	c0 c0       	breq	80006ce8 <_malloc_r+0x64>
80006cd2:	6c 18       	ld.w	r8,r6[0x4]
80006cd4:	e0 18 ff fc 	andl	r8,0xfffc
80006cd8:	6c 3a       	ld.w	r10,r6[0xc]
80006cda:	ec 08 00 09 	add	r9,r6,r8
80006cde:	0a 9c       	mov	r12,r5
80006ce0:	6c 28       	ld.w	r8,r6[0x8]
80006ce2:	95 28       	st.w	r10[0x8],r8
80006ce4:	91 3a       	st.w	r8[0xc],r10
80006ce6:	c4 78       	rjmp	80006d74 <_malloc_r+0xf0>
80006ce8:	2f e3       	sub	r3,-2
80006cea:	c4 d8       	rjmp	80006d84 <_malloc_r+0x100>
80006cec:	ee 03 16 09 	lsr	r3,r7,0x9
80006cf0:	c0 41       	brne	80006cf8 <_malloc_r+0x74>
80006cf2:	ee 03 16 03 	lsr	r3,r7,0x3
80006cf6:	c2 68       	rjmp	80006d42 <_malloc_r+0xbe>
80006cf8:	58 43       	cp.w	r3,4
80006cfa:	e0 8b 00 06 	brhi	80006d06 <_malloc_r+0x82>
80006cfe:	ee 03 16 06 	lsr	r3,r7,0x6
80006d02:	2c 83       	sub	r3,-56
80006d04:	c1 f8       	rjmp	80006d42 <_malloc_r+0xbe>
80006d06:	59 43       	cp.w	r3,20
80006d08:	e0 8b 00 04 	brhi	80006d10 <_malloc_r+0x8c>
80006d0c:	2a 53       	sub	r3,-91
80006d0e:	c1 a8       	rjmp	80006d42 <_malloc_r+0xbe>
80006d10:	e0 43 00 54 	cp.w	r3,84
80006d14:	e0 8b 00 06 	brhi	80006d20 <_malloc_r+0x9c>
80006d18:	ee 03 16 0c 	lsr	r3,r7,0xc
80006d1c:	29 23       	sub	r3,-110
80006d1e:	c1 28       	rjmp	80006d42 <_malloc_r+0xbe>
80006d20:	e0 43 01 54 	cp.w	r3,340
80006d24:	e0 8b 00 06 	brhi	80006d30 <_malloc_r+0xac>
80006d28:	ee 03 16 0f 	lsr	r3,r7,0xf
80006d2c:	28 93       	sub	r3,-119
80006d2e:	c0 a8       	rjmp	80006d42 <_malloc_r+0xbe>
80006d30:	e0 43 05 54 	cp.w	r3,1364
80006d34:	e0 88 00 04 	brls	80006d3c <_malloc_r+0xb8>
80006d38:	37 e3       	mov	r3,126
80006d3a:	c0 48       	rjmp	80006d42 <_malloc_r+0xbe>
80006d3c:	ee 03 16 12 	lsr	r3,r7,0x12
80006d40:	28 43       	sub	r3,-124
80006d42:	e0 6a 05 30 	mov	r10,1328
80006d46:	f4 03 00 3a 	add	r10,r10,r3<<0x3
80006d4a:	74 36       	ld.w	r6,r10[0xc]
80006d4c:	c1 98       	rjmp	80006d7e <_malloc_r+0xfa>
80006d4e:	6c 19       	ld.w	r9,r6[0x4]
80006d50:	e0 19 ff fc 	andl	r9,0xfffc
80006d54:	f2 07 01 0b 	sub	r11,r9,r7
80006d58:	58 fb       	cp.w	r11,15
80006d5a:	e0 8a 00 04 	brle	80006d62 <_malloc_r+0xde>
80006d5e:	20 13       	sub	r3,1
80006d60:	c1 18       	rjmp	80006d82 <_malloc_r+0xfe>
80006d62:	6c 38       	ld.w	r8,r6[0xc]
80006d64:	58 0b       	cp.w	r11,0
80006d66:	c0 b5       	brlt	80006d7c <_malloc_r+0xf8>
80006d68:	6c 2a       	ld.w	r10,r6[0x8]
80006d6a:	ec 09 00 09 	add	r9,r6,r9
80006d6e:	0a 9c       	mov	r12,r5
80006d70:	91 2a       	st.w	r8[0x8],r10
80006d72:	95 38       	st.w	r10[0xc],r8
80006d74:	72 18       	ld.w	r8,r9[0x4]
80006d76:	a1 a8       	sbr	r8,0x0
80006d78:	93 18       	st.w	r9[0x4],r8
80006d7a:	cb c8       	rjmp	80006ef2 <_malloc_r+0x26e>
80006d7c:	10 96       	mov	r6,r8
80006d7e:	14 36       	cp.w	r6,r10
80006d80:	ce 71       	brne	80006d4e <_malloc_r+0xca>
80006d82:	2f f3       	sub	r3,-1
80006d84:	e0 6a 05 30 	mov	r10,1328
80006d88:	f4 cc ff f8 	sub	r12,r10,-8
80006d8c:	78 26       	ld.w	r6,r12[0x8]
80006d8e:	18 36       	cp.w	r6,r12
80006d90:	c6 c0       	breq	80006e68 <_malloc_r+0x1e4>
80006d92:	6c 19       	ld.w	r9,r6[0x4]
80006d94:	e0 19 ff fc 	andl	r9,0xfffc
80006d98:	f2 07 01 08 	sub	r8,r9,r7
80006d9c:	58 f8       	cp.w	r8,15
80006d9e:	e0 89 00 8f 	brgt	80006ebc <_malloc_r+0x238>
80006da2:	99 3c       	st.w	r12[0xc],r12
80006da4:	99 2c       	st.w	r12[0x8],r12
80006da6:	58 08       	cp.w	r8,0
80006da8:	c0 55       	brlt	80006db2 <_malloc_r+0x12e>
80006daa:	ec 09 00 09 	add	r9,r6,r9
80006dae:	0a 9c       	mov	r12,r5
80006db0:	ce 2b       	rjmp	80006d74 <_malloc_r+0xf0>
80006db2:	e0 49 01 ff 	cp.w	r9,511
80006db6:	e0 8b 00 13 	brhi	80006ddc <_malloc_r+0x158>
80006dba:	a3 99       	lsr	r9,0x3
80006dbc:	f4 09 00 38 	add	r8,r10,r9<<0x3
80006dc0:	70 2b       	ld.w	r11,r8[0x8]
80006dc2:	8d 38       	st.w	r6[0xc],r8
80006dc4:	8d 2b       	st.w	r6[0x8],r11
80006dc6:	97 36       	st.w	r11[0xc],r6
80006dc8:	91 26       	st.w	r8[0x8],r6
80006dca:	a3 49       	asr	r9,0x2
80006dcc:	74 18       	ld.w	r8,r10[0x4]
80006dce:	30 1b       	mov	r11,1
80006dd0:	f6 09 09 49 	lsl	r9,r11,r9
80006dd4:	f1 e9 10 09 	or	r9,r8,r9
80006dd8:	95 19       	st.w	r10[0x4],r9
80006dda:	c4 78       	rjmp	80006e68 <_malloc_r+0x1e4>
80006ddc:	f2 0a 16 09 	lsr	r10,r9,0x9
80006de0:	58 4a       	cp.w	r10,4
80006de2:	e0 8b 00 07 	brhi	80006df0 <_malloc_r+0x16c>
80006de6:	f2 0a 16 06 	lsr	r10,r9,0x6
80006dea:	2c 8a       	sub	r10,-56
80006dec:	c2 08       	rjmp	80006e2c <_malloc_r+0x1a8>
80006dee:	d7 03       	nop
80006df0:	59 4a       	cp.w	r10,20
80006df2:	e0 8b 00 04 	brhi	80006dfa <_malloc_r+0x176>
80006df6:	2a 5a       	sub	r10,-91
80006df8:	c1 a8       	rjmp	80006e2c <_malloc_r+0x1a8>
80006dfa:	e0 4a 00 54 	cp.w	r10,84
80006dfe:	e0 8b 00 06 	brhi	80006e0a <_malloc_r+0x186>
80006e02:	f2 0a 16 0c 	lsr	r10,r9,0xc
80006e06:	29 2a       	sub	r10,-110
80006e08:	c1 28       	rjmp	80006e2c <_malloc_r+0x1a8>
80006e0a:	e0 4a 01 54 	cp.w	r10,340
80006e0e:	e0 8b 00 06 	brhi	80006e1a <_malloc_r+0x196>
80006e12:	f2 0a 16 0f 	lsr	r10,r9,0xf
80006e16:	28 9a       	sub	r10,-119
80006e18:	c0 a8       	rjmp	80006e2c <_malloc_r+0x1a8>
80006e1a:	e0 4a 05 54 	cp.w	r10,1364
80006e1e:	e0 88 00 04 	brls	80006e26 <_malloc_r+0x1a2>
80006e22:	37 ea       	mov	r10,126
80006e24:	c0 48       	rjmp	80006e2c <_malloc_r+0x1a8>
80006e26:	f2 0a 16 12 	lsr	r10,r9,0x12
80006e2a:	28 4a       	sub	r10,-124
80006e2c:	e0 6b 05 30 	mov	r11,1328
80006e30:	f6 0a 00 34 	add	r4,r11,r10<<0x3
80006e34:	68 28       	ld.w	r8,r4[0x8]
80006e36:	08 38       	cp.w	r8,r4
80006e38:	c0 e1       	brne	80006e54 <_malloc_r+0x1d0>
80006e3a:	76 19       	ld.w	r9,r11[0x4]
80006e3c:	a3 4a       	asr	r10,0x2
80006e3e:	30 1e       	mov	lr,1
80006e40:	fc 0a 09 4a 	lsl	r10,lr,r10
80006e44:	f3 ea 10 0a 	or	r10,r9,r10
80006e48:	10 99       	mov	r9,r8
80006e4a:	97 1a       	st.w	r11[0x4],r10
80006e4c:	c0 a8       	rjmp	80006e60 <_malloc_r+0x1dc>
80006e4e:	70 28       	ld.w	r8,r8[0x8]
80006e50:	08 38       	cp.w	r8,r4
80006e52:	c0 60       	breq	80006e5e <_malloc_r+0x1da>
80006e54:	70 1a       	ld.w	r10,r8[0x4]
80006e56:	e0 1a ff fc 	andl	r10,0xfffc
80006e5a:	14 39       	cp.w	r9,r10
80006e5c:	cf 93       	brcs	80006e4e <_malloc_r+0x1ca>
80006e5e:	70 39       	ld.w	r9,r8[0xc]
80006e60:	8d 39       	st.w	r6[0xc],r9
80006e62:	8d 28       	st.w	r6[0x8],r8
80006e64:	91 36       	st.w	r8[0xc],r6
80006e66:	93 26       	st.w	r9[0x8],r6
80006e68:	e6 08 14 02 	asr	r8,r3,0x2
80006e6c:	30 1b       	mov	r11,1
80006e6e:	e0 64 05 30 	mov	r4,1328
80006e72:	f6 08 09 4b 	lsl	r11,r11,r8
80006e76:	68 18       	ld.w	r8,r4[0x4]
80006e78:	10 3b       	cp.w	r11,r8
80006e7a:	e0 8b 00 6b 	brhi	80006f50 <_malloc_r+0x2cc>
80006e7e:	f7 e8 00 09 	and	r9,r11,r8
80006e82:	c0 b1       	brne	80006e98 <_malloc_r+0x214>
80006e84:	e0 13 ff fc 	andl	r3,0xfffc
80006e88:	a1 7b       	lsl	r11,0x1
80006e8a:	2f c3       	sub	r3,-4
80006e8c:	c0 38       	rjmp	80006e92 <_malloc_r+0x20e>
80006e8e:	2f c3       	sub	r3,-4
80006e90:	a1 7b       	lsl	r11,0x1
80006e92:	f7 e8 00 09 	and	r9,r11,r8
80006e96:	cf c0       	breq	80006e8e <_malloc_r+0x20a>
80006e98:	e8 03 00 3e 	add	lr,r4,r3<<0x3
80006e9c:	06 92       	mov	r2,r3
80006e9e:	1c 91       	mov	r1,lr
80006ea0:	62 36       	ld.w	r6,r1[0xc]
80006ea2:	c2 e8       	rjmp	80006efe <_malloc_r+0x27a>
80006ea4:	6c 1a       	ld.w	r10,r6[0x4]
80006ea6:	e0 1a ff fc 	andl	r10,0xfffc
80006eaa:	f4 07 01 08 	sub	r8,r10,r7
80006eae:	58 f8       	cp.w	r8,15
80006eb0:	e0 8a 00 15 	brle	80006eda <_malloc_r+0x256>
80006eb4:	6c 3a       	ld.w	r10,r6[0xc]
80006eb6:	6c 29       	ld.w	r9,r6[0x8]
80006eb8:	95 29       	st.w	r10[0x8],r9
80006eba:	93 3a       	st.w	r9[0xc],r10
80006ebc:	0e 99       	mov	r9,r7
80006ebe:	ec 07 00 07 	add	r7,r6,r7
80006ec2:	a1 a9       	sbr	r9,0x0
80006ec4:	99 37       	st.w	r12[0xc],r7
80006ec6:	99 27       	st.w	r12[0x8],r7
80006ec8:	8d 19       	st.w	r6[0x4],r9
80006eca:	ee 08 09 08 	st.w	r7[r8],r8
80006ece:	8f 2c       	st.w	r7[0x8],r12
80006ed0:	8f 3c       	st.w	r7[0xc],r12
80006ed2:	a1 a8       	sbr	r8,0x0
80006ed4:	0a 9c       	mov	r12,r5
80006ed6:	8f 18       	st.w	r7[0x4],r8
80006ed8:	c0 d8       	rjmp	80006ef2 <_malloc_r+0x26e>
80006eda:	6c 39       	ld.w	r9,r6[0xc]
80006edc:	58 08       	cp.w	r8,0
80006ede:	c0 f5       	brlt	80006efc <_malloc_r+0x278>
80006ee0:	ec 0a 00 0a 	add	r10,r6,r10
80006ee4:	74 18       	ld.w	r8,r10[0x4]
80006ee6:	a1 a8       	sbr	r8,0x0
80006ee8:	0a 9c       	mov	r12,r5
80006eea:	95 18       	st.w	r10[0x4],r8
80006eec:	6c 28       	ld.w	r8,r6[0x8]
80006eee:	93 28       	st.w	r9[0x8],r8
80006ef0:	91 39       	st.w	r8[0xc],r9
80006ef2:	fe b0 f4 3b 	rcall	80005768 <__malloc_unlock>
80006ef6:	ec cc ff f8 	sub	r12,r6,-8
80006efa:	d8 32       	popm	r0-r7,pc
80006efc:	12 96       	mov	r6,r9
80006efe:	02 36       	cp.w	r6,r1
80006f00:	cd 21       	brne	80006ea4 <_malloc_r+0x220>
80006f02:	2f f2       	sub	r2,-1
80006f04:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
80006f08:	c0 30       	breq	80006f0e <_malloc_r+0x28a>
80006f0a:	2f 81       	sub	r1,-8
80006f0c:	cc ab       	rjmp	80006ea0 <_malloc_r+0x21c>
80006f0e:	1c 98       	mov	r8,lr
80006f10:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
80006f14:	c0 81       	brne	80006f24 <_malloc_r+0x2a0>
80006f16:	68 19       	ld.w	r9,r4[0x4]
80006f18:	f6 08 11 ff 	rsub	r8,r11,-1
80006f1c:	f3 e8 00 08 	and	r8,r9,r8
80006f20:	89 18       	st.w	r4[0x4],r8
80006f22:	c0 78       	rjmp	80006f30 <_malloc_r+0x2ac>
80006f24:	f0 c9 00 08 	sub	r9,r8,8
80006f28:	20 13       	sub	r3,1
80006f2a:	70 08       	ld.w	r8,r8[0x0]
80006f2c:	12 38       	cp.w	r8,r9
80006f2e:	cf 10       	breq	80006f10 <_malloc_r+0x28c>
80006f30:	a1 7b       	lsl	r11,0x1
80006f32:	68 18       	ld.w	r8,r4[0x4]
80006f34:	10 3b       	cp.w	r11,r8
80006f36:	e0 8b 00 0d 	brhi	80006f50 <_malloc_r+0x2cc>
80006f3a:	58 0b       	cp.w	r11,0
80006f3c:	c0 a0       	breq	80006f50 <_malloc_r+0x2cc>
80006f3e:	04 93       	mov	r3,r2
80006f40:	c0 38       	rjmp	80006f46 <_malloc_r+0x2c2>
80006f42:	2f c3       	sub	r3,-4
80006f44:	a1 7b       	lsl	r11,0x1
80006f46:	f7 e8 00 09 	and	r9,r11,r8
80006f4a:	ca 71       	brne	80006e98 <_malloc_r+0x214>
80006f4c:	cf bb       	rjmp	80006f42 <_malloc_r+0x2be>
80006f4e:	d7 03       	nop
80006f50:	68 23       	ld.w	r3,r4[0x8]
80006f52:	66 12       	ld.w	r2,r3[0x4]
80006f54:	e0 12 ff fc 	andl	r2,0xfffc
80006f58:	0e 32       	cp.w	r2,r7
80006f5a:	5f 39       	srlo	r9
80006f5c:	e4 07 01 08 	sub	r8,r2,r7
80006f60:	58 f8       	cp.w	r8,15
80006f62:	5f aa       	srle	r10
80006f64:	f5 e9 10 09 	or	r9,r10,r9
80006f68:	e0 80 00 9a 	breq	8000709c <_malloc_r+0x418>
80006f6c:	e0 68 0d 84 	mov	r8,3460
80006f70:	70 01       	ld.w	r1,r8[0x0]
80006f72:	e0 68 09 3c 	mov	r8,2364
80006f76:	2f 01       	sub	r1,-16
80006f78:	70 08       	ld.w	r8,r8[0x0]
80006f7a:	0e 01       	add	r1,r7
80006f7c:	5b f8       	cp.w	r8,-1
80006f7e:	c0 40       	breq	80006f86 <_malloc_r+0x302>
80006f80:	28 11       	sub	r1,-127
80006f82:	e0 11 ff 80 	andl	r1,0xff80
80006f86:	02 9b       	mov	r11,r1
80006f88:	0a 9c       	mov	r12,r5
80006f8a:	e0 a0 02 a5 	rcall	800074d4 <_sbrk_r>
80006f8e:	18 96       	mov	r6,r12
80006f90:	5b fc       	cp.w	r12,-1
80006f92:	c7 50       	breq	8000707c <_malloc_r+0x3f8>
80006f94:	e6 02 00 08 	add	r8,r3,r2
80006f98:	10 3c       	cp.w	r12,r8
80006f9a:	c0 32       	brcc	80006fa0 <_malloc_r+0x31c>
80006f9c:	08 33       	cp.w	r3,r4
80006f9e:	c6 f1       	brne	8000707c <_malloc_r+0x3f8>
80006fa0:	e0 6a 0d 88 	mov	r10,3464
80006fa4:	74 09       	ld.w	r9,r10[0x0]
80006fa6:	e2 09 00 09 	add	r9,r1,r9
80006faa:	95 09       	st.w	r10[0x0],r9
80006fac:	10 36       	cp.w	r6,r8
80006fae:	c0 a1       	brne	80006fc2 <_malloc_r+0x33e>
80006fb0:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
80006fb4:	c0 71       	brne	80006fc2 <_malloc_r+0x33e>
80006fb6:	e2 02 00 02 	add	r2,r1,r2
80006fba:	68 28       	ld.w	r8,r4[0x8]
80006fbc:	a1 a2       	sbr	r2,0x0
80006fbe:	91 12       	st.w	r8[0x4],r2
80006fc0:	c4 f8       	rjmp	8000705e <_malloc_r+0x3da>
80006fc2:	e0 6a 09 3c 	mov	r10,2364
80006fc6:	74 0b       	ld.w	r11,r10[0x0]
80006fc8:	5b fb       	cp.w	r11,-1
80006fca:	c0 31       	brne	80006fd0 <_malloc_r+0x34c>
80006fcc:	95 06       	st.w	r10[0x0],r6
80006fce:	c0 78       	rjmp	80006fdc <_malloc_r+0x358>
80006fd0:	ec 09 00 09 	add	r9,r6,r9
80006fd4:	e0 6a 0d 88 	mov	r10,3464
80006fd8:	10 19       	sub	r9,r8
80006fda:	95 09       	st.w	r10[0x0],r9
80006fdc:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
80006fe0:	f0 09 11 08 	rsub	r9,r8,8
80006fe4:	58 08       	cp.w	r8,0
80006fe6:	f2 08 17 10 	movne	r8,r9
80006fea:	ed d8 e1 06 	addne	r6,r6,r8
80006fee:	28 08       	sub	r8,-128
80006ff0:	ec 01 00 01 	add	r1,r6,r1
80006ff4:	0a 9c       	mov	r12,r5
80006ff6:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
80006ffa:	f0 01 01 01 	sub	r1,r8,r1
80006ffe:	02 9b       	mov	r11,r1
80007000:	e0 a0 02 6a 	rcall	800074d4 <_sbrk_r>
80007004:	e0 68 0d 88 	mov	r8,3464
80007008:	5b fc       	cp.w	r12,-1
8000700a:	ec 0c 17 00 	moveq	r12,r6
8000700e:	f9 b1 00 00 	moveq	r1,0
80007012:	70 09       	ld.w	r9,r8[0x0]
80007014:	0c 1c       	sub	r12,r6
80007016:	89 26       	st.w	r4[0x8],r6
80007018:	02 0c       	add	r12,r1
8000701a:	12 01       	add	r1,r9
8000701c:	a1 ac       	sbr	r12,0x0
8000701e:	91 01       	st.w	r8[0x0],r1
80007020:	8d 1c       	st.w	r6[0x4],r12
80007022:	08 33       	cp.w	r3,r4
80007024:	c1 d0       	breq	8000705e <_malloc_r+0x3da>
80007026:	58 f2       	cp.w	r2,15
80007028:	e0 8b 00 05 	brhi	80007032 <_malloc_r+0x3ae>
8000702c:	30 18       	mov	r8,1
8000702e:	8d 18       	st.w	r6[0x4],r8
80007030:	c2 68       	rjmp	8000707c <_malloc_r+0x3f8>
80007032:	30 59       	mov	r9,5
80007034:	20 c2       	sub	r2,12
80007036:	e0 12 ff f8 	andl	r2,0xfff8
8000703a:	e6 02 00 08 	add	r8,r3,r2
8000703e:	91 29       	st.w	r8[0x8],r9
80007040:	91 19       	st.w	r8[0x4],r9
80007042:	66 18       	ld.w	r8,r3[0x4]
80007044:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007048:	e5 e8 10 08 	or	r8,r2,r8
8000704c:	87 18       	st.w	r3[0x4],r8
8000704e:	58 f2       	cp.w	r2,15
80007050:	e0 88 00 07 	brls	8000705e <_malloc_r+0x3da>
80007054:	e6 cb ff f8 	sub	r11,r3,-8
80007058:	0a 9c       	mov	r12,r5
8000705a:	e0 a0 1c 99 	rcall	8000a98c <_free_r>
8000705e:	e0 69 0d 80 	mov	r9,3456
80007062:	72 0a       	ld.w	r10,r9[0x0]
80007064:	e0 68 0d 88 	mov	r8,3464
80007068:	70 08       	ld.w	r8,r8[0x0]
8000706a:	14 38       	cp.w	r8,r10
8000706c:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80007070:	e0 69 0d 7c 	mov	r9,3452
80007074:	72 0a       	ld.w	r10,r9[0x0]
80007076:	14 38       	cp.w	r8,r10
80007078:	f3 f8 ba 00 	st.whi	r9[0x0],r8
8000707c:	68 28       	ld.w	r8,r4[0x8]
8000707e:	70 18       	ld.w	r8,r8[0x4]
80007080:	e0 18 ff fc 	andl	r8,0xfffc
80007084:	0e 38       	cp.w	r8,r7
80007086:	5f 39       	srlo	r9
80007088:	0e 18       	sub	r8,r7
8000708a:	58 f8       	cp.w	r8,15
8000708c:	5f aa       	srle	r10
8000708e:	f5 e9 10 09 	or	r9,r10,r9
80007092:	c0 50       	breq	8000709c <_malloc_r+0x418>
80007094:	0a 9c       	mov	r12,r5
80007096:	fe b0 f3 69 	rcall	80005768 <__malloc_unlock>
8000709a:	d8 3a       	popm	r0-r7,pc,r12=0
8000709c:	68 26       	ld.w	r6,r4[0x8]
8000709e:	a1 a8       	sbr	r8,0x0
800070a0:	0e 99       	mov	r9,r7
800070a2:	a1 a9       	sbr	r9,0x0
800070a4:	8d 19       	st.w	r6[0x4],r9
800070a6:	ec 07 00 07 	add	r7,r6,r7
800070aa:	0a 9c       	mov	r12,r5
800070ac:	89 27       	st.w	r4[0x8],r7
800070ae:	8f 18       	st.w	r7[0x4],r8
800070b0:	fe b0 f3 5c 	rcall	80005768 <__malloc_unlock>
800070b4:	ec cc ff f8 	sub	r12,r6,-8
800070b8:	d8 32       	popm	r0-r7,pc
800070ba:	d7 03       	nop

800070bc <memcpy>:
800070bc:	58 8a       	cp.w	r10,8
800070be:	c2 f5       	brlt	8000711c <memcpy+0x60>
800070c0:	f9 eb 10 09 	or	r9,r12,r11
800070c4:	e2 19 00 03 	andl	r9,0x3,COH
800070c8:	e0 81 00 97 	brne	800071f6 <memcpy+0x13a>
800070cc:	e0 4a 00 20 	cp.w	r10,32
800070d0:	c3 b4       	brge	80007146 <memcpy+0x8a>
800070d2:	f4 08 14 02 	asr	r8,r10,0x2
800070d6:	f0 09 11 08 	rsub	r9,r8,8
800070da:	fe 09 00 2f 	add	pc,pc,r9<<0x2
800070de:	76 69       	ld.w	r9,r11[0x18]
800070e0:	99 69       	st.w	r12[0x18],r9
800070e2:	76 59       	ld.w	r9,r11[0x14]
800070e4:	99 59       	st.w	r12[0x14],r9
800070e6:	76 49       	ld.w	r9,r11[0x10]
800070e8:	99 49       	st.w	r12[0x10],r9
800070ea:	76 39       	ld.w	r9,r11[0xc]
800070ec:	99 39       	st.w	r12[0xc],r9
800070ee:	76 29       	ld.w	r9,r11[0x8]
800070f0:	99 29       	st.w	r12[0x8],r9
800070f2:	76 19       	ld.w	r9,r11[0x4]
800070f4:	99 19       	st.w	r12[0x4],r9
800070f6:	76 09       	ld.w	r9,r11[0x0]
800070f8:	99 09       	st.w	r12[0x0],r9
800070fa:	f6 08 00 2b 	add	r11,r11,r8<<0x2
800070fe:	f8 08 00 28 	add	r8,r12,r8<<0x2
80007102:	e0 1a 00 03 	andl	r10,0x3
80007106:	f4 0a 11 04 	rsub	r10,r10,4
8000710a:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
8000710e:	17 a9       	ld.ub	r9,r11[0x2]
80007110:	b0 a9       	st.b	r8[0x2],r9
80007112:	17 99       	ld.ub	r9,r11[0x1]
80007114:	b0 99       	st.b	r8[0x1],r9
80007116:	17 89       	ld.ub	r9,r11[0x0]
80007118:	b0 89       	st.b	r8[0x0],r9
8000711a:	5e fc       	retal	r12
8000711c:	f4 0a 11 09 	rsub	r10,r10,9
80007120:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80007124:	17 f9       	ld.ub	r9,r11[0x7]
80007126:	b8 f9       	st.b	r12[0x7],r9
80007128:	17 e9       	ld.ub	r9,r11[0x6]
8000712a:	b8 e9       	st.b	r12[0x6],r9
8000712c:	17 d9       	ld.ub	r9,r11[0x5]
8000712e:	b8 d9       	st.b	r12[0x5],r9
80007130:	17 c9       	ld.ub	r9,r11[0x4]
80007132:	b8 c9       	st.b	r12[0x4],r9
80007134:	17 b9       	ld.ub	r9,r11[0x3]
80007136:	b8 b9       	st.b	r12[0x3],r9
80007138:	17 a9       	ld.ub	r9,r11[0x2]
8000713a:	b8 a9       	st.b	r12[0x2],r9
8000713c:	17 99       	ld.ub	r9,r11[0x1]
8000713e:	b8 99       	st.b	r12[0x1],r9
80007140:	17 89       	ld.ub	r9,r11[0x0]
80007142:	b8 89       	st.b	r12[0x0],r9
80007144:	5e fc       	retal	r12
80007146:	eb cd 40 c0 	pushm	r6-r7,lr
8000714a:	18 99       	mov	r9,r12
8000714c:	22 0a       	sub	r10,32
8000714e:	b7 07       	ld.d	r6,r11++
80007150:	b3 26       	st.d	r9++,r6
80007152:	b7 07       	ld.d	r6,r11++
80007154:	b3 26       	st.d	r9++,r6
80007156:	b7 07       	ld.d	r6,r11++
80007158:	b3 26       	st.d	r9++,r6
8000715a:	b7 07       	ld.d	r6,r11++
8000715c:	b3 26       	st.d	r9++,r6
8000715e:	22 0a       	sub	r10,32
80007160:	cf 74       	brge	8000714e <memcpy+0x92>
80007162:	2f 0a       	sub	r10,-16
80007164:	c0 65       	brlt	80007170 <memcpy+0xb4>
80007166:	b7 07       	ld.d	r6,r11++
80007168:	b3 26       	st.d	r9++,r6
8000716a:	b7 07       	ld.d	r6,r11++
8000716c:	b3 26       	st.d	r9++,r6
8000716e:	21 0a       	sub	r10,16
80007170:	5c 3a       	neg	r10
80007172:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
80007176:	d7 03       	nop
80007178:	d7 03       	nop
8000717a:	f7 36 00 0e 	ld.ub	r6,r11[14]
8000717e:	f3 66 00 0e 	st.b	r9[14],r6
80007182:	f7 36 00 0d 	ld.ub	r6,r11[13]
80007186:	f3 66 00 0d 	st.b	r9[13],r6
8000718a:	f7 36 00 0c 	ld.ub	r6,r11[12]
8000718e:	f3 66 00 0c 	st.b	r9[12],r6
80007192:	f7 36 00 0b 	ld.ub	r6,r11[11]
80007196:	f3 66 00 0b 	st.b	r9[11],r6
8000719a:	f7 36 00 0a 	ld.ub	r6,r11[10]
8000719e:	f3 66 00 0a 	st.b	r9[10],r6
800071a2:	f7 36 00 09 	ld.ub	r6,r11[9]
800071a6:	f3 66 00 09 	st.b	r9[9],r6
800071aa:	f7 36 00 08 	ld.ub	r6,r11[8]
800071ae:	f3 66 00 08 	st.b	r9[8],r6
800071b2:	f7 36 00 07 	ld.ub	r6,r11[7]
800071b6:	f3 66 00 07 	st.b	r9[7],r6
800071ba:	f7 36 00 06 	ld.ub	r6,r11[6]
800071be:	f3 66 00 06 	st.b	r9[6],r6
800071c2:	f7 36 00 05 	ld.ub	r6,r11[5]
800071c6:	f3 66 00 05 	st.b	r9[5],r6
800071ca:	f7 36 00 04 	ld.ub	r6,r11[4]
800071ce:	f3 66 00 04 	st.b	r9[4],r6
800071d2:	f7 36 00 03 	ld.ub	r6,r11[3]
800071d6:	f3 66 00 03 	st.b	r9[3],r6
800071da:	f7 36 00 02 	ld.ub	r6,r11[2]
800071de:	f3 66 00 02 	st.b	r9[2],r6
800071e2:	f7 36 00 01 	ld.ub	r6,r11[1]
800071e6:	f3 66 00 01 	st.b	r9[1],r6
800071ea:	f7 36 00 00 	ld.ub	r6,r11[0]
800071ee:	f3 66 00 00 	st.b	r9[0],r6
800071f2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800071f6:	20 1a       	sub	r10,1
800071f8:	f6 0a 07 09 	ld.ub	r9,r11[r10]
800071fc:	f8 0a 0b 09 	st.b	r12[r10],r9
80007200:	cf b1       	brne	800071f6 <memcpy+0x13a>
80007202:	5e fc       	retal	r12

80007204 <memset>:
80007204:	18 98       	mov	r8,r12
80007206:	c0 38       	rjmp	8000720c <memset+0x8>
80007208:	10 cb       	st.b	r8++,r11
8000720a:	20 1a       	sub	r10,1
8000720c:	58 0a       	cp.w	r10,0
8000720e:	cf d1       	brne	80007208 <memset+0x4>
80007210:	5e fc       	retal	r12
80007212:	d7 03       	nop

80007214 <_realloc_r>:
80007214:	d4 31       	pushm	r0-r7,lr
80007216:	20 1d       	sub	sp,4
80007218:	16 94       	mov	r4,r11
8000721a:	18 92       	mov	r2,r12
8000721c:	14 9b       	mov	r11,r10
8000721e:	58 04       	cp.w	r4,0
80007220:	c0 51       	brne	8000722a <_realloc_r+0x16>
80007222:	fe b0 fd 31 	rcall	80006c84 <_malloc_r>
80007226:	18 95       	mov	r5,r12
80007228:	c5 39       	rjmp	800074ce <_realloc_r+0x2ba>
8000722a:	50 0a       	stdsp	sp[0x0],r10
8000722c:	fe b0 f2 98 	rcall	8000575c <__malloc_lock>
80007230:	40 0b       	lddsp	r11,sp[0x0]
80007232:	f6 c8 ff f5 	sub	r8,r11,-11
80007236:	e8 c1 00 08 	sub	r1,r4,8
8000723a:	10 96       	mov	r6,r8
8000723c:	62 1c       	ld.w	r12,r1[0x4]
8000723e:	e0 16 ff f8 	andl	r6,0xfff8
80007242:	59 68       	cp.w	r8,22
80007244:	f9 b6 08 10 	movls	r6,16
80007248:	16 36       	cp.w	r6,r11
8000724a:	5f 38       	srlo	r8
8000724c:	f1 e6 13 f8 	or	r8,r8,r6>>0x1f
80007250:	c0 50       	breq	8000725a <_realloc_r+0x46>
80007252:	30 c8       	mov	r8,12
80007254:	30 05       	mov	r5,0
80007256:	85 38       	st.w	r2[0xc],r8
80007258:	c3 b9       	rjmp	800074ce <_realloc_r+0x2ba>
8000725a:	18 90       	mov	r0,r12
8000725c:	e0 10 ff fc 	andl	r0,0xfffc
80007260:	0c 30       	cp.w	r0,r6
80007262:	e0 84 01 0b 	brge	80007478 <_realloc_r+0x264>
80007266:	e0 68 05 30 	mov	r8,1328
8000726a:	e2 00 00 09 	add	r9,r1,r0
8000726e:	70 25       	ld.w	r5,r8[0x8]
80007270:	0a 39       	cp.w	r9,r5
80007272:	c0 90       	breq	80007284 <_realloc_r+0x70>
80007274:	72 1a       	ld.w	r10,r9[0x4]
80007276:	a1 ca       	cbr	r10,0x0
80007278:	f2 0a 00 0a 	add	r10,r9,r10
8000727c:	74 1a       	ld.w	r10,r10[0x4]
8000727e:	ed ba 00 00 	bld	r10,0x0
80007282:	c2 20       	breq	800072c6 <_realloc_r+0xb2>
80007284:	72 1a       	ld.w	r10,r9[0x4]
80007286:	e0 1a ff fc 	andl	r10,0xfffc
8000728a:	f4 00 00 03 	add	r3,r10,r0
8000728e:	0a 39       	cp.w	r9,r5
80007290:	c1 31       	brne	800072b6 <_realloc_r+0xa2>
80007292:	ec c7 ff f0 	sub	r7,r6,-16
80007296:	0e 33       	cp.w	r3,r7
80007298:	c1 95       	brlt	800072ca <_realloc_r+0xb6>
8000729a:	e2 06 00 09 	add	r9,r1,r6
8000729e:	0c 13       	sub	r3,r6
800072a0:	a1 a3       	sbr	r3,0x0
800072a2:	93 13       	st.w	r9[0x4],r3
800072a4:	91 29       	st.w	r8[0x8],r9
800072a6:	04 9c       	mov	r12,r2
800072a8:	62 18       	ld.w	r8,r1[0x4]
800072aa:	08 95       	mov	r5,r4
800072ac:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800072b0:	10 46       	or	r6,r8
800072b2:	83 16       	st.w	r1[0x4],r6
800072b4:	c0 b9       	rjmp	800074ca <_realloc_r+0x2b6>
800072b6:	0c 33       	cp.w	r3,r6
800072b8:	c0 95       	brlt	800072ca <_realloc_r+0xb6>
800072ba:	72 28       	ld.w	r8,r9[0x8]
800072bc:	02 97       	mov	r7,r1
800072be:	72 39       	ld.w	r9,r9[0xc]
800072c0:	93 28       	st.w	r9[0x8],r8
800072c2:	91 39       	st.w	r8[0xc],r9
800072c4:	cd c8       	rjmp	8000747c <_realloc_r+0x268>
800072c6:	30 0a       	mov	r10,0
800072c8:	14 99       	mov	r9,r10
800072ca:	ed bc 00 00 	bld	r12,0x0
800072ce:	e0 80 00 95 	breq	800073f8 <_realloc_r+0x1e4>
800072d2:	62 07       	ld.w	r7,r1[0x0]
800072d4:	e2 07 01 07 	sub	r7,r1,r7
800072d8:	6e 1c       	ld.w	r12,r7[0x4]
800072da:	e0 1c ff fc 	andl	r12,0xfffc
800072de:	58 09       	cp.w	r9,0
800072e0:	c5 60       	breq	8000738c <_realloc_r+0x178>
800072e2:	f8 00 00 03 	add	r3,r12,r0
800072e6:	0a 39       	cp.w	r9,r5
800072e8:	c4 81       	brne	80007378 <_realloc_r+0x164>
800072ea:	14 03       	add	r3,r10
800072ec:	ec c9 ff f0 	sub	r9,r6,-16
800072f0:	12 33       	cp.w	r3,r9
800072f2:	c4 d5       	brlt	8000738c <_realloc_r+0x178>
800072f4:	6e 3a       	ld.w	r10,r7[0xc]
800072f6:	6e 29       	ld.w	r9,r7[0x8]
800072f8:	95 29       	st.w	r10[0x8],r9
800072fa:	93 3a       	st.w	r9[0xc],r10
800072fc:	ee c5 ff f8 	sub	r5,r7,-8
80007300:	e0 ca 00 04 	sub	r10,r0,4
80007304:	e0 4a 00 24 	cp.w	r10,36
80007308:	e0 8b 00 25 	brhi	80007352 <_realloc_r+0x13e>
8000730c:	0a 99       	mov	r9,r5
8000730e:	59 3a       	cp.w	r10,19
80007310:	e0 88 00 1a 	brls	80007344 <_realloc_r+0x130>
80007314:	09 09       	ld.w	r9,r4++
80007316:	8b 09       	st.w	r5[0x0],r9
80007318:	09 09       	ld.w	r9,r4++
8000731a:	8f 39       	st.w	r7[0xc],r9
8000731c:	ee c9 ff f0 	sub	r9,r7,-16
80007320:	59 ba       	cp.w	r10,27
80007322:	e0 88 00 11 	brls	80007344 <_realloc_r+0x130>
80007326:	09 0b       	ld.w	r11,r4++
80007328:	93 0b       	st.w	r9[0x0],r11
8000732a:	09 09       	ld.w	r9,r4++
8000732c:	8f 59       	st.w	r7[0x14],r9
8000732e:	ee c9 ff e8 	sub	r9,r7,-24
80007332:	e0 4a 00 24 	cp.w	r10,36
80007336:	c0 71       	brne	80007344 <_realloc_r+0x130>
80007338:	09 0a       	ld.w	r10,r4++
8000733a:	93 0a       	st.w	r9[0x0],r10
8000733c:	ee c9 ff e0 	sub	r9,r7,-32
80007340:	09 0a       	ld.w	r10,r4++
80007342:	8f 7a       	st.w	r7[0x1c],r10
80007344:	09 0a       	ld.w	r10,r4++
80007346:	12 aa       	st.w	r9++,r10
80007348:	68 0a       	ld.w	r10,r4[0x0]
8000734a:	93 0a       	st.w	r9[0x0],r10
8000734c:	68 1a       	ld.w	r10,r4[0x4]
8000734e:	93 1a       	st.w	r9[0x4],r10
80007350:	c0 78       	rjmp	8000735e <_realloc_r+0x14a>
80007352:	50 08       	stdsp	sp[0x0],r8
80007354:	08 9b       	mov	r11,r4
80007356:	0a 9c       	mov	r12,r5
80007358:	e0 a0 1d bd 	rcall	8000aed2 <memmove>
8000735c:	40 08       	lddsp	r8,sp[0x0]
8000735e:	ee 06 00 09 	add	r9,r7,r6
80007362:	0c 13       	sub	r3,r6
80007364:	a1 a3       	sbr	r3,0x0
80007366:	93 13       	st.w	r9[0x4],r3
80007368:	91 29       	st.w	r8[0x8],r9
8000736a:	04 9c       	mov	r12,r2
8000736c:	6e 18       	ld.w	r8,r7[0x4]
8000736e:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007372:	10 46       	or	r6,r8
80007374:	8f 16       	st.w	r7[0x4],r6
80007376:	ca a8       	rjmp	800074ca <_realloc_r+0x2b6>
80007378:	14 03       	add	r3,r10
8000737a:	0c 33       	cp.w	r3,r6
8000737c:	c0 85       	brlt	8000738c <_realloc_r+0x178>
8000737e:	72 28       	ld.w	r8,r9[0x8]
80007380:	72 39       	ld.w	r9,r9[0xc]
80007382:	93 28       	st.w	r9[0x8],r8
80007384:	91 39       	st.w	r8[0xc],r9
80007386:	6e 28       	ld.w	r8,r7[0x8]
80007388:	6e 39       	ld.w	r9,r7[0xc]
8000738a:	c0 78       	rjmp	80007398 <_realloc_r+0x184>
8000738c:	f8 00 00 03 	add	r3,r12,r0
80007390:	0c 33       	cp.w	r3,r6
80007392:	c3 35       	brlt	800073f8 <_realloc_r+0x1e4>
80007394:	6e 39       	ld.w	r9,r7[0xc]
80007396:	6e 28       	ld.w	r8,r7[0x8]
80007398:	93 28       	st.w	r9[0x8],r8
8000739a:	91 39       	st.w	r8[0xc],r9
8000739c:	e0 ca 00 04 	sub	r10,r0,4
800073a0:	ee cc ff f8 	sub	r12,r7,-8
800073a4:	e0 4a 00 24 	cp.w	r10,36
800073a8:	e0 8b 00 24 	brhi	800073f0 <_realloc_r+0x1dc>
800073ac:	59 3a       	cp.w	r10,19
800073ae:	e0 88 00 1a 	brls	800073e2 <_realloc_r+0x1ce>
800073b2:	09 08       	ld.w	r8,r4++
800073b4:	99 08       	st.w	r12[0x0],r8
800073b6:	09 08       	ld.w	r8,r4++
800073b8:	8f 38       	st.w	r7[0xc],r8
800073ba:	ee cc ff f0 	sub	r12,r7,-16
800073be:	59 ba       	cp.w	r10,27
800073c0:	e0 88 00 11 	brls	800073e2 <_realloc_r+0x1ce>
800073c4:	09 08       	ld.w	r8,r4++
800073c6:	99 08       	st.w	r12[0x0],r8
800073c8:	09 08       	ld.w	r8,r4++
800073ca:	8f 58       	st.w	r7[0x14],r8
800073cc:	ee cc ff e8 	sub	r12,r7,-24
800073d0:	e0 4a 00 24 	cp.w	r10,36
800073d4:	c0 71       	brne	800073e2 <_realloc_r+0x1ce>
800073d6:	09 08       	ld.w	r8,r4++
800073d8:	99 08       	st.w	r12[0x0],r8
800073da:	ee cc ff e0 	sub	r12,r7,-32
800073de:	09 08       	ld.w	r8,r4++
800073e0:	8f 78       	st.w	r7[0x1c],r8
800073e2:	09 08       	ld.w	r8,r4++
800073e4:	18 a8       	st.w	r12++,r8
800073e6:	68 08       	ld.w	r8,r4[0x0]
800073e8:	99 08       	st.w	r12[0x0],r8
800073ea:	68 18       	ld.w	r8,r4[0x4]
800073ec:	99 18       	st.w	r12[0x4],r8
800073ee:	c4 78       	rjmp	8000747c <_realloc_r+0x268>
800073f0:	08 9b       	mov	r11,r4
800073f2:	e0 a0 1d 70 	rcall	8000aed2 <memmove>
800073f6:	c4 38       	rjmp	8000747c <_realloc_r+0x268>
800073f8:	04 9c       	mov	r12,r2
800073fa:	fe b0 fc 45 	rcall	80006c84 <_malloc_r>
800073fe:	18 95       	mov	r5,r12
80007400:	c3 a0       	breq	80007474 <_realloc_r+0x260>
80007402:	62 18       	ld.w	r8,r1[0x4]
80007404:	f8 c9 00 08 	sub	r9,r12,8
80007408:	a1 c8       	cbr	r8,0x0
8000740a:	e2 08 00 08 	add	r8,r1,r8
8000740e:	10 39       	cp.w	r9,r8
80007410:	c0 71       	brne	8000741e <_realloc_r+0x20a>
80007412:	72 13       	ld.w	r3,r9[0x4]
80007414:	02 97       	mov	r7,r1
80007416:	e0 13 ff fc 	andl	r3,0xfffc
8000741a:	00 03       	add	r3,r0
8000741c:	c3 08       	rjmp	8000747c <_realloc_r+0x268>
8000741e:	e0 ca 00 04 	sub	r10,r0,4
80007422:	e0 4a 00 24 	cp.w	r10,36
80007426:	e0 8b 00 20 	brhi	80007466 <_realloc_r+0x252>
8000742a:	08 99       	mov	r9,r4
8000742c:	18 98       	mov	r8,r12
8000742e:	59 3a       	cp.w	r10,19
80007430:	e0 88 00 14 	brls	80007458 <_realloc_r+0x244>
80007434:	13 0b       	ld.w	r11,r9++
80007436:	10 ab       	st.w	r8++,r11
80007438:	13 0b       	ld.w	r11,r9++
8000743a:	10 ab       	st.w	r8++,r11
8000743c:	59 ba       	cp.w	r10,27
8000743e:	e0 88 00 0d 	brls	80007458 <_realloc_r+0x244>
80007442:	13 0b       	ld.w	r11,r9++
80007444:	10 ab       	st.w	r8++,r11
80007446:	13 0b       	ld.w	r11,r9++
80007448:	10 ab       	st.w	r8++,r11
8000744a:	e0 4a 00 24 	cp.w	r10,36
8000744e:	c0 51       	brne	80007458 <_realloc_r+0x244>
80007450:	13 0a       	ld.w	r10,r9++
80007452:	10 aa       	st.w	r8++,r10
80007454:	13 0a       	ld.w	r10,r9++
80007456:	10 aa       	st.w	r8++,r10
80007458:	13 0a       	ld.w	r10,r9++
8000745a:	10 aa       	st.w	r8++,r10
8000745c:	72 0a       	ld.w	r10,r9[0x0]
8000745e:	91 0a       	st.w	r8[0x0],r10
80007460:	72 19       	ld.w	r9,r9[0x4]
80007462:	91 19       	st.w	r8[0x4],r9
80007464:	c0 48       	rjmp	8000746c <_realloc_r+0x258>
80007466:	08 9b       	mov	r11,r4
80007468:	e0 a0 1d 35 	rcall	8000aed2 <memmove>
8000746c:	08 9b       	mov	r11,r4
8000746e:	04 9c       	mov	r12,r2
80007470:	e0 a0 1a 8e 	rcall	8000a98c <_free_r>
80007474:	04 9c       	mov	r12,r2
80007476:	c2 a8       	rjmp	800074ca <_realloc_r+0x2b6>
80007478:	00 93       	mov	r3,r0
8000747a:	02 97       	mov	r7,r1
8000747c:	e6 06 01 09 	sub	r9,r3,r6
80007480:	6e 18       	ld.w	r8,r7[0x4]
80007482:	58 f9       	cp.w	r9,15
80007484:	e0 88 00 16 	brls	800074b0 <_realloc_r+0x29c>
80007488:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000748c:	ed e8 10 08 	or	r8,r6,r8
80007490:	8f 18       	st.w	r7[0x4],r8
80007492:	12 98       	mov	r8,r9
80007494:	a1 a8       	sbr	r8,0x0
80007496:	ee 06 00 0b 	add	r11,r7,r6
8000749a:	f6 09 00 09 	add	r9,r11,r9
8000749e:	97 18       	st.w	r11[0x4],r8
800074a0:	72 18       	ld.w	r8,r9[0x4]
800074a2:	a1 a8       	sbr	r8,0x0
800074a4:	2f 8b       	sub	r11,-8
800074a6:	93 18       	st.w	r9[0x4],r8
800074a8:	04 9c       	mov	r12,r2
800074aa:	e0 a0 1a 71 	rcall	8000a98c <_free_r>
800074ae:	c0 b8       	rjmp	800074c4 <_realloc_r+0x2b0>
800074b0:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800074b4:	e7 e8 10 08 	or	r8,r3,r8
800074b8:	8f 18       	st.w	r7[0x4],r8
800074ba:	ee 03 00 03 	add	r3,r7,r3
800074be:	66 18       	ld.w	r8,r3[0x4]
800074c0:	a1 a8       	sbr	r8,0x0
800074c2:	87 18       	st.w	r3[0x4],r8
800074c4:	04 9c       	mov	r12,r2
800074c6:	ee c5 ff f8 	sub	r5,r7,-8
800074ca:	fe b0 f1 4f 	rcall	80005768 <__malloc_unlock>
800074ce:	0a 9c       	mov	r12,r5
800074d0:	2f fd       	sub	sp,-4
800074d2:	d8 32       	popm	r0-r7,pc

800074d4 <_sbrk_r>:
800074d4:	d4 21       	pushm	r4-r7,lr
800074d6:	30 08       	mov	r8,0
800074d8:	18 97       	mov	r7,r12
800074da:	e0 66 41 20 	mov	r6,16672
800074de:	16 9c       	mov	r12,r11
800074e0:	8d 08       	st.w	r6[0x0],r8
800074e2:	c9 9c       	rcall	80007614 <_sbrk>
800074e4:	5b fc       	cp.w	r12,-1
800074e6:	c0 51       	brne	800074f0 <_sbrk_r+0x1c>
800074e8:	6c 08       	ld.w	r8,r6[0x0]
800074ea:	58 08       	cp.w	r8,0
800074ec:	ef f8 1a 03 	st.wne	r7[0xc],r8
800074f0:	d8 22       	popm	r4-r7,pc
800074f2:	d7 03       	nop

800074f4 <sprintf>:
800074f4:	d4 01       	pushm	lr
800074f6:	21 7d       	sub	sp,92
800074f8:	e0 68 ff ff 	mov	r8,65535
800074fc:	ea 18 7f ff 	orh	r8,0x7fff
80007500:	50 58       	stdsp	sp[0x14],r8
80007502:	50 28       	stdsp	sp[0x8],r8
80007504:	e0 68 02 08 	mov	r8,520
80007508:	ba 68       	st.h	sp[0xc],r8
8000750a:	3f f8       	mov	r8,-1
8000750c:	ba 78       	st.h	sp[0xe],r8
8000750e:	e0 68 0a 30 	mov	r8,2608
80007512:	50 4c       	stdsp	sp[0x10],r12
80007514:	16 9a       	mov	r10,r11
80007516:	50 0c       	stdsp	sp[0x0],r12
80007518:	fa c9 ff a0 	sub	r9,sp,-96
8000751c:	70 0c       	ld.w	r12,r8[0x0]
8000751e:	1a 9b       	mov	r11,sp
80007520:	e0 a0 02 34 	rcall	80007988 <_vfprintf_r>
80007524:	30 09       	mov	r9,0
80007526:	40 08       	lddsp	r8,sp[0x0]
80007528:	b0 89       	st.b	r8[0x0],r9
8000752a:	2e 9d       	sub	sp,-92
8000752c:	d8 02       	popm	pc
8000752e:	d7 03       	nop

80007530 <strcpy>:
80007530:	30 08       	mov	r8,0
80007532:	f6 08 07 09 	ld.ub	r9,r11[r8]
80007536:	f8 08 0b 09 	st.b	r12[r8],r9
8000753a:	2f f8       	sub	r8,-1
8000753c:	58 09       	cp.w	r9,0
8000753e:	cf a1       	brne	80007532 <strcpy+0x2>
80007540:	5e fc       	retal	r12

80007542 <strlen>:
80007542:	30 09       	mov	r9,0
80007544:	18 98       	mov	r8,r12
80007546:	c0 28       	rjmp	8000754a <strlen+0x8>
80007548:	2f f8       	sub	r8,-1
8000754a:	11 8a       	ld.ub	r10,r8[0x0]
8000754c:	f2 0a 18 00 	cp.b	r10,r9
80007550:	cf c1       	brne	80007548 <strlen+0x6>
80007552:	f0 0c 01 0c 	sub	r12,r8,r12
80007556:	5e fc       	retal	r12

80007558 <strncpy>:
80007558:	30 08       	mov	r8,0
8000755a:	10 3a       	cp.w	r10,r8
8000755c:	5e 0c       	reteq	r12
8000755e:	f6 08 07 09 	ld.ub	r9,r11[r8]
80007562:	f8 08 0b 09 	st.b	r12[r8],r9
80007566:	2f f8       	sub	r8,-1
80007568:	58 09       	cp.w	r9,0
8000756a:	cf 81       	brne	8000755a <strncpy+0x2>
8000756c:	10 3a       	cp.w	r10,r8
8000756e:	5e 0c       	reteq	r12
80007570:	f8 08 0b 09 	st.b	r12[r8],r9
80007574:	2f f8       	sub	r8,-1
80007576:	cf bb       	rjmp	8000756c <strncpy+0x14>

80007578 <_close>:
80007578:	30 28       	mov	r8,2
8000757a:	d6 73       	breakpoint
8000757c:	3f fc       	mov	r12,-1
8000757e:	35 8b       	mov	r11,88
80007580:	58 0c       	cp.w	r12,0
80007582:	5e 4c       	retge	r12
80007584:	e0 6a 41 20 	mov	r10,16672
80007588:	95 0b       	st.w	r10[0x0],r11
8000758a:	5e fc       	retal	r12

8000758c <_lseek>:
8000758c:	30 58       	mov	r8,5
8000758e:	d6 73       	breakpoint
80007590:	3f fc       	mov	r12,-1
80007592:	35 8b       	mov	r11,88
80007594:	58 0c       	cp.w	r12,0
80007596:	5e 4c       	retge	r12
80007598:	e0 6a 41 20 	mov	r10,16672
8000759c:	95 0b       	st.w	r10[0x0],r11
8000759e:	5e fc       	retal	r12

800075a0 <isatty>:
800075a0:	30 b8       	mov	r8,11
800075a2:	d6 73       	breakpoint
800075a4:	3f fc       	mov	r12,-1
800075a6:	35 8b       	mov	r11,88
800075a8:	58 0c       	cp.w	r12,0
800075aa:	5e 4c       	retge	r12
800075ac:	e0 6a 41 20 	mov	r10,16672
800075b0:	95 0b       	st.w	r10[0x0],r11
800075b2:	5e fc       	retal	r12

800075b4 <_fstat_host>:
800075b4:	30 98       	mov	r8,9
800075b6:	d6 73       	breakpoint
800075b8:	3f fc       	mov	r12,-1
800075ba:	35 8b       	mov	r11,88
800075bc:	58 0c       	cp.w	r12,0
800075be:	5e 4c       	retge	r12
800075c0:	e0 6a 41 20 	mov	r10,16672
800075c4:	95 0b       	st.w	r10[0x0],r11
800075c6:	5e fc       	retal	r12

800075c8 <_fstat>:
800075c8:	d4 21       	pushm	r4-r7,lr
800075ca:	21 0d       	sub	sp,64
800075cc:	16 97       	mov	r7,r11
800075ce:	1a 9b       	mov	r11,sp
800075d0:	cf 2f       	rcall	800075b4 <_fstat_host>
800075d2:	c0 34       	brge	800075d8 <_fstat+0x10>
800075d4:	3f fc       	mov	r12,-1
800075d6:	c1 c8       	rjmp	8000760e <_fstat+0x46>
800075d8:	40 08       	lddsp	r8,sp[0x0]
800075da:	ae 08       	st.h	r7[0x0],r8
800075dc:	40 18       	lddsp	r8,sp[0x4]
800075de:	ae 18       	st.h	r7[0x2],r8
800075e0:	40 28       	lddsp	r8,sp[0x8]
800075e2:	8f 18       	st.w	r7[0x4],r8
800075e4:	40 38       	lddsp	r8,sp[0xc]
800075e6:	ae 48       	st.h	r7[0x8],r8
800075e8:	40 48       	lddsp	r8,sp[0x10]
800075ea:	ae 58       	st.h	r7[0xa],r8
800075ec:	40 58       	lddsp	r8,sp[0x14]
800075ee:	ae 68       	st.h	r7[0xc],r8
800075f0:	40 68       	lddsp	r8,sp[0x18]
800075f2:	ae 78       	st.h	r7[0xe],r8
800075f4:	40 88       	lddsp	r8,sp[0x20]
800075f6:	8f 48       	st.w	r7[0x10],r8
800075f8:	40 a8       	lddsp	r8,sp[0x28]
800075fa:	8f b8       	st.w	r7[0x2c],r8
800075fc:	40 c8       	lddsp	r8,sp[0x30]
800075fe:	8f c8       	st.w	r7[0x30],r8
80007600:	40 d8       	lddsp	r8,sp[0x34]
80007602:	8f 58       	st.w	r7[0x14],r8
80007604:	40 e8       	lddsp	r8,sp[0x38]
80007606:	30 0c       	mov	r12,0
80007608:	8f 78       	st.w	r7[0x1c],r8
8000760a:	40 f8       	lddsp	r8,sp[0x3c]
8000760c:	8f 98       	st.w	r7[0x24],r8
8000760e:	2f 0d       	sub	sp,-64
80007610:	d8 22       	popm	r4-r7,pc
80007612:	d7 03       	nop

80007614 <_sbrk>:
80007614:	d4 01       	pushm	lr
80007616:	e0 68 0d b0 	mov	r8,3504
8000761a:	70 09       	ld.w	r9,r8[0x0]
8000761c:	58 09       	cp.w	r9,0
8000761e:	c0 41       	brne	80007626 <_sbrk+0x12>
80007620:	e0 69 41 28 	mov	r9,16680
80007624:	91 09       	st.w	r8[0x0],r9
80007626:	e0 69 0d b0 	mov	r9,3504
8000762a:	e0 7a 70 00 	mov	r10,94208
8000762e:	72 08       	ld.w	r8,r9[0x0]
80007630:	f0 0c 00 0c 	add	r12,r8,r12
80007634:	14 3c       	cp.w	r12,r10
80007636:	e0 8b 00 04 	brhi	8000763e <_sbrk+0x2a>
8000763a:	93 0c       	st.w	r9[0x0],r12
8000763c:	c0 68       	rjmp	80007648 <_sbrk+0x34>
8000763e:	e0 a0 18 2b 	rcall	8000a694 <__errno>
80007642:	30 c8       	mov	r8,12
80007644:	99 08       	st.w	r12[0x0],r8
80007646:	3f f8       	mov	r8,-1
80007648:	10 9c       	mov	r12,r8
8000764a:	d8 02       	popm	pc

8000764c <get_arg>:
8000764c:	d4 31       	pushm	r0-r7,lr
8000764e:	20 8d       	sub	sp,32
80007650:	fa c4 ff bc 	sub	r4,sp,-68
80007654:	50 4b       	stdsp	sp[0x10],r11
80007656:	68 2e       	ld.w	lr,r4[0x8]
80007658:	50 58       	stdsp	sp[0x14],r8
8000765a:	12 96       	mov	r6,r9
8000765c:	7c 0b       	ld.w	r11,lr[0x0]
8000765e:	70 05       	ld.w	r5,r8[0x0]
80007660:	50 6e       	stdsp	sp[0x18],lr
80007662:	58 0b       	cp.w	r11,0
80007664:	f4 0b 17 00 	moveq	r11,r10
80007668:	68 03       	ld.w	r3,r4[0x0]
8000766a:	68 11       	ld.w	r1,r4[0x4]
8000766c:	40 49       	lddsp	r9,sp[0x10]
8000766e:	30 08       	mov	r8,0
80007670:	c2 e9       	rjmp	800078cc <get_arg+0x280>
80007672:	2f fb       	sub	r11,-1
80007674:	32 5c       	mov	r12,37
80007676:	17 8a       	ld.ub	r10,r11[0x0]
80007678:	f8 0a 18 00 	cp.b	r10,r12
8000767c:	5f 1e       	srne	lr
8000767e:	f0 0a 18 00 	cp.b	r10,r8
80007682:	5f 1c       	srne	r12
80007684:	fd ec 00 0c 	and	r12,lr,r12
80007688:	f0 0c 18 00 	cp.b	r12,r8
8000768c:	cf 31       	brne	80007672 <get_arg+0x26>
8000768e:	58 0a       	cp.w	r10,0
80007690:	e0 80 01 2b 	breq	800078e6 <get_arg+0x29a>
80007694:	30 0c       	mov	r12,0
80007696:	3f fa       	mov	r10,-1
80007698:	18 90       	mov	r0,r12
8000769a:	50 3a       	stdsp	sp[0xc],r10
8000769c:	18 94       	mov	r4,r12
8000769e:	18 92       	mov	r2,r12
800076a0:	f8 0c 00 3c 	add	r12,r12,r12<<0x3
800076a4:	16 97       	mov	r7,r11
800076a6:	50 7c       	stdsp	sp[0x1c],r12
800076a8:	4c ec       	lddpc	r12,800077e0 <get_arg+0x194>
800076aa:	0f 3a       	ld.ub	r10,r7++
800076ac:	f8 0a 07 0e 	ld.ub	lr,r12[r10]
800076b0:	40 7c       	lddsp	r12,sp[0x1c]
800076b2:	1c 0c       	add	r12,lr
800076b4:	4c ce       	lddpc	lr,800077e4 <get_arg+0x198>
800076b6:	fc 0c 07 0e 	ld.ub	lr,lr[r12]
800076ba:	20 1e       	sub	lr,1
800076bc:	50 0e       	stdsp	sp[0x0],lr
800076be:	4c be       	lddpc	lr,800077e8 <get_arg+0x19c>
800076c0:	fc 0c 07 0c 	ld.ub	r12,lr[r12]
800076c4:	50 7c       	stdsp	sp[0x1c],r12
800076c6:	40 0c       	lddsp	r12,sp[0x0]
800076c8:	58 7c       	cp.w	r12,7
800076ca:	e0 8b 00 fa 	brhi	800078be <get_arg+0x272>
800076ce:	4c 8e       	lddpc	lr,800077ec <get_arg+0x1a0>
800076d0:	fc 0c 03 2f 	ld.w	pc,lr[r12<<0x2]
800076d4:	36 8b       	mov	r11,104
800076d6:	f6 0a 18 00 	cp.b	r10,r11
800076da:	e0 80 00 f2 	breq	800078be <get_arg+0x272>
800076de:	37 1b       	mov	r11,113
800076e0:	f6 0a 18 00 	cp.b	r10,r11
800076e4:	c0 70       	breq	800076f2 <get_arg+0xa6>
800076e6:	34 cb       	mov	r11,76
800076e8:	f6 0a 18 00 	cp.b	r10,r11
800076ec:	c0 51       	brne	800076f6 <get_arg+0xaa>
800076ee:	a3 b4       	sbr	r4,0x3
800076f0:	ce 78       	rjmp	800078be <get_arg+0x272>
800076f2:	a5 b4       	sbr	r4,0x5
800076f4:	ce 58       	rjmp	800078be <get_arg+0x272>
800076f6:	08 9a       	mov	r10,r4
800076f8:	0e 9b       	mov	r11,r7
800076fa:	a5 aa       	sbr	r10,0x4
800076fc:	17 3c       	ld.ub	r12,r11++
800076fe:	a5 b4       	sbr	r4,0x5
80007700:	36 ce       	mov	lr,108
80007702:	fc 0c 18 00 	cp.b	r12,lr
80007706:	e0 80 00 dd 	breq	800078c0 <get_arg+0x274>
8000770a:	14 94       	mov	r4,r10
8000770c:	cd 98       	rjmp	800078be <get_arg+0x272>
8000770e:	eb d5 c0 05 	bfextu	r5,r5,0x0,0x5
80007712:	36 7c       	mov	r12,103
80007714:	f8 0a 18 00 	cp.b	r10,r12
80007718:	e0 8b 00 27 	brhi	80007766 <get_arg+0x11a>
8000771c:	36 5b       	mov	r11,101
8000771e:	f6 0a 18 00 	cp.b	r10,r11
80007722:	c4 82       	brcc	800077b2 <get_arg+0x166>
80007724:	34 fb       	mov	r11,79
80007726:	f6 0a 18 00 	cp.b	r10,r11
8000772a:	c4 80       	breq	800077ba <get_arg+0x16e>
8000772c:	e0 8b 00 0c 	brhi	80007744 <get_arg+0xf8>
80007730:	34 5b       	mov	r11,69
80007732:	f6 0a 18 00 	cp.b	r10,r11
80007736:	c3 e0       	breq	800077b2 <get_arg+0x166>
80007738:	34 7b       	mov	r11,71
8000773a:	f6 0a 18 00 	cp.b	r10,r11
8000773e:	c3 a0       	breq	800077b2 <get_arg+0x166>
80007740:	34 4b       	mov	r11,68
80007742:	c0 88       	rjmp	80007752 <get_arg+0x106>
80007744:	35 8b       	mov	r11,88
80007746:	f6 0a 18 00 	cp.b	r10,r11
8000774a:	c2 c0       	breq	800077a2 <get_arg+0x156>
8000774c:	e0 8b 00 07 	brhi	8000775a <get_arg+0x10e>
80007750:	35 5b       	mov	r11,85
80007752:	f6 0a 18 00 	cp.b	r10,r11
80007756:	c3 51       	brne	800077c0 <get_arg+0x174>
80007758:	c3 18       	rjmp	800077ba <get_arg+0x16e>
8000775a:	36 3b       	mov	r11,99
8000775c:	f6 0a 18 00 	cp.b	r10,r11
80007760:	c2 f0       	breq	800077be <get_arg+0x172>
80007762:	36 4b       	mov	r11,100
80007764:	c0 e8       	rjmp	80007780 <get_arg+0x134>
80007766:	37 0b       	mov	r11,112
80007768:	f6 0a 18 00 	cp.b	r10,r11
8000776c:	c2 50       	breq	800077b6 <get_arg+0x16a>
8000776e:	e0 8b 00 0d 	brhi	80007788 <get_arg+0x13c>
80007772:	36 eb       	mov	r11,110
80007774:	f6 0a 18 00 	cp.b	r10,r11
80007778:	c1 f0       	breq	800077b6 <get_arg+0x16a>
8000777a:	e0 8b 00 14 	brhi	800077a2 <get_arg+0x156>
8000777e:	36 9b       	mov	r11,105
80007780:	f6 0a 18 00 	cp.b	r10,r11
80007784:	c1 e1       	brne	800077c0 <get_arg+0x174>
80007786:	c0 e8       	rjmp	800077a2 <get_arg+0x156>
80007788:	37 5b       	mov	r11,117
8000778a:	f6 0a 18 00 	cp.b	r10,r11
8000778e:	c0 a0       	breq	800077a2 <get_arg+0x156>
80007790:	37 8b       	mov	r11,120
80007792:	f6 0a 18 00 	cp.b	r10,r11
80007796:	c0 60       	breq	800077a2 <get_arg+0x156>
80007798:	37 3b       	mov	r11,115
8000779a:	f6 0a 18 00 	cp.b	r10,r11
8000779e:	c1 11       	brne	800077c0 <get_arg+0x174>
800077a0:	c0 b8       	rjmp	800077b6 <get_arg+0x16a>
800077a2:	ed b4 00 04 	bld	r4,0x4
800077a6:	c0 a0       	breq	800077ba <get_arg+0x16e>
800077a8:	ed b4 00 05 	bld	r4,0x5
800077ac:	c0 91       	brne	800077be <get_arg+0x172>
800077ae:	30 20       	mov	r0,2
800077b0:	c0 88       	rjmp	800077c0 <get_arg+0x174>
800077b2:	30 40       	mov	r0,4
800077b4:	c0 68       	rjmp	800077c0 <get_arg+0x174>
800077b6:	30 30       	mov	r0,3
800077b8:	c0 48       	rjmp	800077c0 <get_arg+0x174>
800077ba:	30 10       	mov	r0,1
800077bc:	c0 28       	rjmp	800077c0 <get_arg+0x174>
800077be:	30 00       	mov	r0,0
800077c0:	40 3b       	lddsp	r11,sp[0xc]
800077c2:	5b fb       	cp.w	r11,-1
800077c4:	c0 40       	breq	800077cc <get_arg+0x180>
800077c6:	e2 0b 09 20 	st.w	r1[r11<<0x2],r0
800077ca:	c7 a8       	rjmp	800078be <get_arg+0x272>
800077cc:	58 60       	cp.w	r0,6
800077ce:	e0 8b 00 78 	brhi	800078be <get_arg+0x272>
800077d2:	6c 0a       	ld.w	r10,r6[0x0]
800077d4:	ea cc ff ff 	sub	r12,r5,-1
800077d8:	48 6e       	lddpc	lr,800077f0 <get_arg+0x1a4>
800077da:	fc 00 03 2f 	ld.w	pc,lr[r0<<0x2]
800077de:	d7 03       	nop
800077e0:	80 01       	ld.sh	r1,r0[0x0]
800077e2:	60 d0       	ld.w	r0,r0[0x34]
800077e4:	80 01       	ld.sh	r1,r0[0x0]
800077e6:	60 08       	ld.w	r8,r0[0x0]
800077e8:	80 01       	ld.sh	r1,r0[0x0]
800077ea:	5f 9c       	srgt	r12
800077ec:	80 01       	ld.sh	r1,r0[0x0]
800077ee:	5d fc       	*unknown*
800077f0:	80 01       	ld.sh	r1,r0[0x0]
800077f2:	5e 1c       	retne	r12
800077f4:	f4 cb ff f8 	sub	r11,r10,-8
800077f8:	8d 0b       	st.w	r6[0x0],r11
800077fa:	f4 ea 00 00 	ld.d	r10,r10[0]
800077fe:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80007802:	c0 f8       	rjmp	80007820 <get_arg+0x1d4>
80007804:	f4 cb ff fc 	sub	r11,r10,-4
80007808:	8d 0b       	st.w	r6[0x0],r11
8000780a:	74 0a       	ld.w	r10,r10[0x0]
8000780c:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80007810:	c0 88       	rjmp	80007820 <get_arg+0x1d4>
80007812:	f4 cb ff f8 	sub	r11,r10,-8
80007816:	8d 0b       	st.w	r6[0x0],r11
80007818:	f4 ea 00 00 	ld.d	r10,r10[0]
8000781c:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80007820:	0e 9b       	mov	r11,r7
80007822:	18 95       	mov	r5,r12
80007824:	c4 e8       	rjmp	800078c0 <get_arg+0x274>
80007826:	62 0a       	ld.w	r10,r1[0x0]
80007828:	5b fa       	cp.w	r10,-1
8000782a:	c0 b1       	brne	80007840 <get_arg+0x1f4>
8000782c:	50 19       	stdsp	sp[0x4],r9
8000782e:	50 28       	stdsp	sp[0x8],r8
80007830:	e0 6a 00 80 	mov	r10,128
80007834:	30 0b       	mov	r11,0
80007836:	02 9c       	mov	r12,r1
80007838:	fe b0 fc e6 	rcall	80007204 <memset>
8000783c:	40 28       	lddsp	r8,sp[0x8]
8000783e:	40 19       	lddsp	r9,sp[0x4]
80007840:	e4 cc 00 01 	sub	r12,r2,1
80007844:	0e 9b       	mov	r11,r7
80007846:	50 3c       	stdsp	sp[0xc],r12
80007848:	f2 0c 0c 49 	max	r9,r9,r12
8000784c:	c3 a8       	rjmp	800078c0 <get_arg+0x274>
8000784e:	62 0a       	ld.w	r10,r1[0x0]
80007850:	5b fa       	cp.w	r10,-1
80007852:	c0 b1       	brne	80007868 <get_arg+0x21c>
80007854:	50 19       	stdsp	sp[0x4],r9
80007856:	50 28       	stdsp	sp[0x8],r8
80007858:	e0 6a 00 80 	mov	r10,128
8000785c:	30 0b       	mov	r11,0
8000785e:	02 9c       	mov	r12,r1
80007860:	fe b0 fc d2 	rcall	80007204 <memset>
80007864:	40 28       	lddsp	r8,sp[0x8]
80007866:	40 19       	lddsp	r9,sp[0x4]
80007868:	20 12       	sub	r2,1
8000786a:	30 0a       	mov	r10,0
8000786c:	0e 9b       	mov	r11,r7
8000786e:	e2 02 09 2a 	st.w	r1[r2<<0x2],r10
80007872:	f2 02 0c 49 	max	r9,r9,r2
80007876:	c2 58       	rjmp	800078c0 <get_arg+0x274>
80007878:	16 97       	mov	r7,r11
8000787a:	6c 0a       	ld.w	r10,r6[0x0]
8000787c:	f4 cb ff fc 	sub	r11,r10,-4
80007880:	8d 0b       	st.w	r6[0x0],r11
80007882:	74 0a       	ld.w	r10,r10[0x0]
80007884:	0e 9b       	mov	r11,r7
80007886:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
8000788a:	2f f5       	sub	r5,-1
8000788c:	c1 a8       	rjmp	800078c0 <get_arg+0x274>
8000788e:	f4 c2 00 30 	sub	r2,r10,48
80007892:	c0 68       	rjmp	8000789e <get_arg+0x252>
80007894:	e4 02 00 22 	add	r2,r2,r2<<0x2
80007898:	2f f7       	sub	r7,-1
8000789a:	f4 02 00 12 	add	r2,r10,r2<<0x1
8000789e:	0f 8a       	ld.ub	r10,r7[0x0]
800078a0:	58 0a       	cp.w	r10,0
800078a2:	c0 e0       	breq	800078be <get_arg+0x272>
800078a4:	23 0a       	sub	r10,48
800078a6:	58 9a       	cp.w	r10,9
800078a8:	fe 98 ff f6 	brls	80007894 <get_arg+0x248>
800078ac:	c0 98       	rjmp	800078be <get_arg+0x272>
800078ae:	2f f7       	sub	r7,-1
800078b0:	0f 8a       	ld.ub	r10,r7[0x0]
800078b2:	58 0a       	cp.w	r10,0
800078b4:	c0 50       	breq	800078be <get_arg+0x272>
800078b6:	23 0a       	sub	r10,48
800078b8:	58 9a       	cp.w	r10,9
800078ba:	fe 98 ff fa 	brls	800078ae <get_arg+0x262>
800078be:	0e 9b       	mov	r11,r7
800078c0:	40 7c       	lddsp	r12,sp[0x1c]
800078c2:	30 ba       	mov	r10,11
800078c4:	f4 0c 18 00 	cp.b	r12,r10
800078c8:	fe 91 fe ec 	brne	800076a0 <get_arg+0x54>
800078cc:	40 42       	lddsp	r2,sp[0x10]
800078ce:	17 8c       	ld.ub	r12,r11[0x0]
800078d0:	0a 32       	cp.w	r2,r5
800078d2:	5f 4a       	srge	r10
800078d4:	f0 0c 18 00 	cp.b	r12,r8
800078d8:	5f 1c       	srne	r12
800078da:	f9 ea 00 0a 	and	r10,r12,r10
800078de:	f0 0a 18 00 	cp.b	r10,r8
800078e2:	fe 91 fe c9 	brne	80007674 <get_arg+0x28>
800078e6:	30 08       	mov	r8,0
800078e8:	40 4e       	lddsp	lr,sp[0x10]
800078ea:	17 8a       	ld.ub	r10,r11[0x0]
800078ec:	e2 05 00 21 	add	r1,r1,r5<<0x2
800078f0:	f0 0a 18 00 	cp.b	r10,r8
800078f4:	fc 09 17 10 	movne	r9,lr
800078f8:	e6 05 00 38 	add	r8,r3,r5<<0x3
800078fc:	06 9e       	mov	lr,r3
800078fe:	c2 a8       	rjmp	80007952 <get_arg+0x306>
80007900:	62 0a       	ld.w	r10,r1[0x0]
80007902:	58 3a       	cp.w	r10,3
80007904:	c1 e0       	breq	80007940 <get_arg+0x2f4>
80007906:	e0 89 00 07 	brgt	80007914 <get_arg+0x2c8>
8000790a:	58 1a       	cp.w	r10,1
8000790c:	c1 a0       	breq	80007940 <get_arg+0x2f4>
8000790e:	58 2a       	cp.w	r10,2
80007910:	c1 81       	brne	80007940 <get_arg+0x2f4>
80007912:	c0 58       	rjmp	8000791c <get_arg+0x2d0>
80007914:	58 5a       	cp.w	r10,5
80007916:	c0 c0       	breq	8000792e <get_arg+0x2e2>
80007918:	c0 b5       	brlt	8000792e <get_arg+0x2e2>
8000791a:	c1 38       	rjmp	80007940 <get_arg+0x2f4>
8000791c:	6c 0a       	ld.w	r10,r6[0x0]
8000791e:	f4 cc ff f8 	sub	r12,r10,-8
80007922:	8d 0c       	st.w	r6[0x0],r12
80007924:	f4 e2 00 00 	ld.d	r2,r10[0]
80007928:	f0 e3 00 00 	st.d	r8[0],r2
8000792c:	c1 08       	rjmp	8000794c <get_arg+0x300>
8000792e:	6c 0a       	ld.w	r10,r6[0x0]
80007930:	f4 cc ff f8 	sub	r12,r10,-8
80007934:	8d 0c       	st.w	r6[0x0],r12
80007936:	f4 e2 00 00 	ld.d	r2,r10[0]
8000793a:	f0 e3 00 00 	st.d	r8[0],r2
8000793e:	c0 78       	rjmp	8000794c <get_arg+0x300>
80007940:	6c 0a       	ld.w	r10,r6[0x0]
80007942:	f4 cc ff fc 	sub	r12,r10,-4
80007946:	8d 0c       	st.w	r6[0x0],r12
80007948:	74 0a       	ld.w	r10,r10[0x0]
8000794a:	91 0a       	st.w	r8[0x0],r10
8000794c:	2f f5       	sub	r5,-1
8000794e:	2f 88       	sub	r8,-8
80007950:	2f c1       	sub	r1,-4
80007952:	12 35       	cp.w	r5,r9
80007954:	fe 9a ff d6 	brle	80007900 <get_arg+0x2b4>
80007958:	1c 93       	mov	r3,lr
8000795a:	40 52       	lddsp	r2,sp[0x14]
8000795c:	40 6e       	lddsp	lr,sp[0x18]
8000795e:	85 05       	st.w	r2[0x0],r5
80007960:	9d 0b       	st.w	lr[0x0],r11
80007962:	40 4b       	lddsp	r11,sp[0x10]
80007964:	e6 0b 00 3c 	add	r12,r3,r11<<0x3
80007968:	2f 8d       	sub	sp,-32
8000796a:	d8 32       	popm	r0-r7,pc

8000796c <__sprint_r>:
8000796c:	d4 21       	pushm	r4-r7,lr
8000796e:	14 97       	mov	r7,r10
80007970:	74 28       	ld.w	r8,r10[0x8]
80007972:	58 08       	cp.w	r8,0
80007974:	c0 41       	brne	8000797c <__sprint_r+0x10>
80007976:	95 18       	st.w	r10[0x4],r8
80007978:	10 9c       	mov	r12,r8
8000797a:	d8 22       	popm	r4-r7,pc
8000797c:	e0 a0 18 ce 	rcall	8000ab18 <__sfvwrite_r>
80007980:	30 08       	mov	r8,0
80007982:	8f 18       	st.w	r7[0x4],r8
80007984:	8f 28       	st.w	r7[0x8],r8
80007986:	d8 22       	popm	r4-r7,pc

80007988 <_vfprintf_r>:
80007988:	d4 31       	pushm	r0-r7,lr
8000798a:	fa cd 06 bc 	sub	sp,sp,1724
8000798e:	51 09       	stdsp	sp[0x40],r9
80007990:	16 91       	mov	r1,r11
80007992:	14 97       	mov	r7,r10
80007994:	18 95       	mov	r5,r12
80007996:	e0 a0 1a 31 	rcall	8000adf8 <_localeconv_r>
8000799a:	78 0c       	ld.w	r12,r12[0x0]
8000799c:	50 cc       	stdsp	sp[0x30],r12
8000799e:	58 05       	cp.w	r5,0
800079a0:	c0 70       	breq	800079ae <_vfprintf_r+0x26>
800079a2:	6a 68       	ld.w	r8,r5[0x18]
800079a4:	58 08       	cp.w	r8,0
800079a6:	c0 41       	brne	800079ae <_vfprintf_r+0x26>
800079a8:	0a 9c       	mov	r12,r5
800079aa:	e0 a0 17 57 	rcall	8000a858 <__sinit>
800079ae:	4d 08       	lddpc	r8,80007aec <_vfprintf_r+0x164>
800079b0:	10 31       	cp.w	r1,r8
800079b2:	c0 31       	brne	800079b8 <_vfprintf_r+0x30>
800079b4:	6a 01       	ld.w	r1,r5[0x0]
800079b6:	c0 a8       	rjmp	800079ca <_vfprintf_r+0x42>
800079b8:	4c e8       	lddpc	r8,80007af0 <_vfprintf_r+0x168>
800079ba:	10 31       	cp.w	r1,r8
800079bc:	c0 31       	brne	800079c2 <_vfprintf_r+0x3a>
800079be:	6a 11       	ld.w	r1,r5[0x4]
800079c0:	c0 58       	rjmp	800079ca <_vfprintf_r+0x42>
800079c2:	4c d8       	lddpc	r8,80007af4 <_vfprintf_r+0x16c>
800079c4:	10 31       	cp.w	r1,r8
800079c6:	eb f1 00 02 	ld.weq	r1,r5[0x8]
800079ca:	82 68       	ld.sh	r8,r1[0xc]
800079cc:	ed b8 00 03 	bld	r8,0x3
800079d0:	c0 41       	brne	800079d8 <_vfprintf_r+0x50>
800079d2:	62 48       	ld.w	r8,r1[0x10]
800079d4:	58 08       	cp.w	r8,0
800079d6:	c0 71       	brne	800079e4 <_vfprintf_r+0x5c>
800079d8:	02 9b       	mov	r11,r1
800079da:	0a 9c       	mov	r12,r5
800079dc:	e0 a0 0f 6c 	rcall	800098b4 <__swsetup_r>
800079e0:	e0 81 0f 63 	brne	800098a6 <_vfprintf_r+0x1f1e>
800079e4:	82 68       	ld.sh	r8,r1[0xc]
800079e6:	10 99       	mov	r9,r8
800079e8:	e2 19 00 1a 	andl	r9,0x1a,COH
800079ec:	58 a9       	cp.w	r9,10
800079ee:	c3 c1       	brne	80007a66 <_vfprintf_r+0xde>
800079f0:	82 79       	ld.sh	r9,r1[0xe]
800079f2:	30 0a       	mov	r10,0
800079f4:	f4 09 19 00 	cp.h	r9,r10
800079f8:	c3 75       	brlt	80007a66 <_vfprintf_r+0xde>
800079fa:	a1 d8       	cbr	r8,0x1
800079fc:	fb 58 05 d0 	st.h	sp[1488],r8
80007a00:	62 88       	ld.w	r8,r1[0x20]
80007a02:	fb 48 05 e4 	st.w	sp[1508],r8
80007a06:	62 a8       	ld.w	r8,r1[0x28]
80007a08:	fb 48 05 ec 	st.w	sp[1516],r8
80007a0c:	fa c8 ff bc 	sub	r8,sp,-68
80007a10:	fb 48 05 d4 	st.w	sp[1492],r8
80007a14:	fb 48 05 c4 	st.w	sp[1476],r8
80007a18:	e0 68 04 00 	mov	r8,1024
80007a1c:	fb 48 05 d8 	st.w	sp[1496],r8
80007a20:	fb 48 05 cc 	st.w	sp[1484],r8
80007a24:	30 08       	mov	r8,0
80007a26:	fb 59 05 d2 	st.h	sp[1490],r9
80007a2a:	0e 9a       	mov	r10,r7
80007a2c:	41 09       	lddsp	r9,sp[0x40]
80007a2e:	fa c7 fa 3c 	sub	r7,sp,-1476
80007a32:	fb 48 05 dc 	st.w	sp[1500],r8
80007a36:	0a 9c       	mov	r12,r5
80007a38:	0e 9b       	mov	r11,r7
80007a3a:	ca 7f       	rcall	80007988 <_vfprintf_r>
80007a3c:	50 bc       	stdsp	sp[0x2c],r12
80007a3e:	c0 95       	brlt	80007a50 <_vfprintf_r+0xc8>
80007a40:	0e 9b       	mov	r11,r7
80007a42:	0a 9c       	mov	r12,r5
80007a44:	e0 a0 16 2e 	rcall	8000a6a0 <_fflush_r>
80007a48:	40 be       	lddsp	lr,sp[0x2c]
80007a4a:	f9 be 01 ff 	movne	lr,-1
80007a4e:	50 be       	stdsp	sp[0x2c],lr
80007a50:	fb 08 05 d0 	ld.sh	r8,sp[1488]
80007a54:	ed b8 00 06 	bld	r8,0x6
80007a58:	e0 81 0f 29 	brne	800098aa <_vfprintf_r+0x1f22>
80007a5c:	82 68       	ld.sh	r8,r1[0xc]
80007a5e:	a7 a8       	sbr	r8,0x6
80007a60:	a2 68       	st.h	r1[0xc],r8
80007a62:	e0 8f 0f 24 	bral	800098aa <_vfprintf_r+0x1f22>
80007a66:	30 08       	mov	r8,0
80007a68:	fb 48 06 b4 	st.w	sp[1716],r8
80007a6c:	fb 48 06 90 	st.w	sp[1680],r8
80007a70:	fb 48 06 8c 	st.w	sp[1676],r8
80007a74:	fb 48 06 b0 	st.w	sp[1712],r8
80007a78:	30 08       	mov	r8,0
80007a7a:	30 09       	mov	r9,0
80007a7c:	50 a7       	stdsp	sp[0x28],r7
80007a7e:	50 78       	stdsp	sp[0x1c],r8
80007a80:	fa c3 f9 e0 	sub	r3,sp,-1568
80007a84:	3f f8       	mov	r8,-1
80007a86:	50 59       	stdsp	sp[0x14],r9
80007a88:	fb 43 06 88 	st.w	sp[1672],r3
80007a8c:	fb 48 05 44 	st.w	sp[1348],r8
80007a90:	12 9c       	mov	r12,r9
80007a92:	50 69       	stdsp	sp[0x18],r9
80007a94:	50 d9       	stdsp	sp[0x34],r9
80007a96:	50 e9       	stdsp	sp[0x38],r9
80007a98:	50 b9       	stdsp	sp[0x2c],r9
80007a9a:	12 97       	mov	r7,r9
80007a9c:	0a 94       	mov	r4,r5
80007a9e:	40 a2       	lddsp	r2,sp[0x28]
80007aa0:	32 5a       	mov	r10,37
80007aa2:	30 08       	mov	r8,0
80007aa4:	c0 28       	rjmp	80007aa8 <_vfprintf_r+0x120>
80007aa6:	2f f2       	sub	r2,-1
80007aa8:	05 89       	ld.ub	r9,r2[0x0]
80007aaa:	f0 09 18 00 	cp.b	r9,r8
80007aae:	5f 1b       	srne	r11
80007ab0:	f4 09 18 00 	cp.b	r9,r10
80007ab4:	5f 19       	srne	r9
80007ab6:	f3 eb 00 0b 	and	r11,r9,r11
80007aba:	f0 0b 18 00 	cp.b	r11,r8
80007abe:	cf 41       	brne	80007aa6 <_vfprintf_r+0x11e>
80007ac0:	40 ab       	lddsp	r11,sp[0x28]
80007ac2:	e4 0b 01 06 	sub	r6,r2,r11
80007ac6:	c2 50       	breq	80007b10 <_vfprintf_r+0x188>
80007ac8:	fa f8 06 90 	ld.w	r8,sp[1680]
80007acc:	0c 08       	add	r8,r6
80007ace:	87 0b       	st.w	r3[0x0],r11
80007ad0:	fb 48 06 90 	st.w	sp[1680],r8
80007ad4:	87 16       	st.w	r3[0x4],r6
80007ad6:	fa f8 06 8c 	ld.w	r8,sp[1676]
80007ada:	2f f8       	sub	r8,-1
80007adc:	fb 48 06 8c 	st.w	sp[1676],r8
80007ae0:	58 78       	cp.w	r8,7
80007ae2:	e0 89 00 0b 	brgt	80007af8 <_vfprintf_r+0x170>
80007ae6:	2f 83       	sub	r3,-8
80007ae8:	c1 18       	rjmp	80007b0a <_vfprintf_r+0x182>
80007aea:	d7 03       	nop
80007aec:	80 01       	ld.sh	r1,r0[0x0]
80007aee:	61 e0       	ld.w	r0,r0[0x78]
80007af0:	80 01       	ld.sh	r1,r0[0x0]
80007af2:	62 00       	ld.w	r0,r1[0x0]
80007af4:	80 01       	ld.sh	r1,r0[0x0]
80007af6:	62 20       	ld.w	r0,r1[0x8]
80007af8:	fa ca f9 78 	sub	r10,sp,-1672
80007afc:	02 9b       	mov	r11,r1
80007afe:	08 9c       	mov	r12,r4
80007b00:	c3 6f       	rcall	8000796c <__sprint_r>
80007b02:	e0 81 0e ce 	brne	8000989e <_vfprintf_r+0x1f16>
80007b06:	fa c3 f9 e0 	sub	r3,sp,-1568
80007b0a:	40 ba       	lddsp	r10,sp[0x2c]
80007b0c:	0c 0a       	add	r10,r6
80007b0e:	50 ba       	stdsp	sp[0x2c],r10
80007b10:	05 89       	ld.ub	r9,r2[0x0]
80007b12:	30 08       	mov	r8,0
80007b14:	f0 09 18 00 	cp.b	r9,r8
80007b18:	e0 80 0e b2 	breq	8000987c <_vfprintf_r+0x1ef4>
80007b1c:	30 09       	mov	r9,0
80007b1e:	fb 68 06 bb 	st.b	sp[1723],r8
80007b22:	0e 96       	mov	r6,r7
80007b24:	e4 c8 ff ff 	sub	r8,r2,-1
80007b28:	3f fe       	mov	lr,-1
80007b2a:	50 93       	stdsp	sp[0x24],r3
80007b2c:	50 41       	stdsp	sp[0x10],r1
80007b2e:	0e 93       	mov	r3,r7
80007b30:	04 91       	mov	r1,r2
80007b32:	50 89       	stdsp	sp[0x20],r9
80007b34:	50 a8       	stdsp	sp[0x28],r8
80007b36:	50 2e       	stdsp	sp[0x8],lr
80007b38:	50 39       	stdsp	sp[0xc],r9
80007b3a:	12 95       	mov	r5,r9
80007b3c:	12 90       	mov	r0,r9
80007b3e:	10 97       	mov	r7,r8
80007b40:	08 92       	mov	r2,r4
80007b42:	c0 78       	rjmp	80007b50 <_vfprintf_r+0x1c8>
80007b44:	3f fc       	mov	r12,-1
80007b46:	08 97       	mov	r7,r4
80007b48:	50 2c       	stdsp	sp[0x8],r12
80007b4a:	c0 38       	rjmp	80007b50 <_vfprintf_r+0x1c8>
80007b4c:	30 0b       	mov	r11,0
80007b4e:	50 3b       	stdsp	sp[0xc],r11
80007b50:	0f 38       	ld.ub	r8,r7++
80007b52:	c0 28       	rjmp	80007b56 <_vfprintf_r+0x1ce>
80007b54:	12 90       	mov	r0,r9
80007b56:	f0 c9 00 20 	sub	r9,r8,32
80007b5a:	e0 49 00 58 	cp.w	r9,88
80007b5e:	e0 8b 0a 36 	brhi	80008fca <_vfprintf_r+0x1642>
80007b62:	4d 9a       	lddpc	r10,80007cc4 <_vfprintf_r+0x33c>
80007b64:	f4 09 03 2f 	ld.w	pc,r10[r9<<0x2]
80007b68:	50 a7       	stdsp	sp[0x28],r7
80007b6a:	50 80       	stdsp	sp[0x20],r0
80007b6c:	0c 97       	mov	r7,r6
80007b6e:	04 94       	mov	r4,r2
80007b70:	06 96       	mov	r6,r3
80007b72:	02 92       	mov	r2,r1
80007b74:	4d 59       	lddpc	r9,80007cc8 <_vfprintf_r+0x340>
80007b76:	40 93       	lddsp	r3,sp[0x24]
80007b78:	10 90       	mov	r0,r8
80007b7a:	40 41       	lddsp	r1,sp[0x10]
80007b7c:	50 d9       	stdsp	sp[0x34],r9
80007b7e:	e0 8f 08 95 	bral	80008ca8 <_vfprintf_r+0x1320>
80007b82:	30 08       	mov	r8,0
80007b84:	fb 39 06 bb 	ld.ub	r9,sp[1723]
80007b88:	f0 09 18 00 	cp.b	r9,r8
80007b8c:	ce 21       	brne	80007b50 <_vfprintf_r+0x1c8>
80007b8e:	32 08       	mov	r8,32
80007b90:	c6 e8       	rjmp	80007c6c <_vfprintf_r+0x2e4>
80007b92:	a1 a5       	sbr	r5,0x0
80007b94:	cd eb       	rjmp	80007b50 <_vfprintf_r+0x1c8>
80007b96:	0f 89       	ld.ub	r9,r7[0x0]
80007b98:	f2 c8 00 30 	sub	r8,r9,48
80007b9c:	58 98       	cp.w	r8,9
80007b9e:	e0 8b 00 1d 	brhi	80007bd8 <_vfprintf_r+0x250>
80007ba2:	ee c8 ff ff 	sub	r8,r7,-1
80007ba6:	30 0b       	mov	r11,0
80007ba8:	23 09       	sub	r9,48
80007baa:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
80007bae:	f2 0b 00 1b 	add	r11,r9,r11<<0x1
80007bb2:	11 39       	ld.ub	r9,r8++
80007bb4:	f2 ca 00 30 	sub	r10,r9,48
80007bb8:	58 9a       	cp.w	r10,9
80007bba:	fe 98 ff f7 	brls	80007ba8 <_vfprintf_r+0x220>
80007bbe:	e0 49 00 24 	cp.w	r9,36
80007bc2:	cc 51       	brne	80007b4c <_vfprintf_r+0x1c4>
80007bc4:	e0 4b 00 20 	cp.w	r11,32
80007bc8:	e0 89 0e 6a 	brgt	8000989c <_vfprintf_r+0x1f14>
80007bcc:	20 1b       	sub	r11,1
80007bce:	fa f9 06 b4 	ld.w	r9,sp[1716]
80007bd2:	12 3b       	cp.w	r11,r9
80007bd4:	c0 95       	brlt	80007be6 <_vfprintf_r+0x25e>
80007bd6:	c1 08       	rjmp	80007bf6 <_vfprintf_r+0x26e>
80007bd8:	fa f9 06 b4 	ld.w	r9,sp[1716]
80007bdc:	ec ca ff ff 	sub	r10,r6,-1
80007be0:	12 36       	cp.w	r6,r9
80007be2:	c1 f5       	brlt	80007c20 <_vfprintf_r+0x298>
80007be4:	c2 68       	rjmp	80007c30 <_vfprintf_r+0x2a8>
80007be6:	fa ce f9 44 	sub	lr,sp,-1724
80007bea:	10 97       	mov	r7,r8
80007bec:	fc 0b 00 3b 	add	r11,lr,r11<<0x3
80007bf0:	f6 f0 fd 88 	ld.w	r0,r11[-632]
80007bf4:	c3 58       	rjmp	80007c5e <_vfprintf_r+0x2d6>
80007bf6:	10 97       	mov	r7,r8
80007bf8:	fa c8 f9 50 	sub	r8,sp,-1712
80007bfc:	1a d8       	st.w	--sp,r8
80007bfe:	fa c8 fa b8 	sub	r8,sp,-1352
80007c02:	1a d8       	st.w	--sp,r8
80007c04:	fa c8 fb b4 	sub	r8,sp,-1100
80007c08:	02 9a       	mov	r10,r1
80007c0a:	1a d8       	st.w	--sp,r8
80007c0c:	04 9c       	mov	r12,r2
80007c0e:	fa c8 f9 40 	sub	r8,sp,-1728
80007c12:	fa c9 ff b4 	sub	r9,sp,-76
80007c16:	fe b0 fd 1b 	rcall	8000764c <get_arg>
80007c1a:	2f dd       	sub	sp,-12
80007c1c:	78 00       	ld.w	r0,r12[0x0]
80007c1e:	c2 08       	rjmp	80007c5e <_vfprintf_r+0x2d6>
80007c20:	fa cc f9 44 	sub	r12,sp,-1724
80007c24:	14 96       	mov	r6,r10
80007c26:	f8 03 00 38 	add	r8,r12,r3<<0x3
80007c2a:	f0 f0 fd 88 	ld.w	r0,r8[-632]
80007c2e:	c1 88       	rjmp	80007c5e <_vfprintf_r+0x2d6>
80007c30:	41 08       	lddsp	r8,sp[0x40]
80007c32:	59 f9       	cp.w	r9,31
80007c34:	e0 89 00 11 	brgt	80007c56 <_vfprintf_r+0x2ce>
80007c38:	f0 cb ff fc 	sub	r11,r8,-4
80007c3c:	51 0b       	stdsp	sp[0x40],r11
80007c3e:	70 00       	ld.w	r0,r8[0x0]
80007c40:	fa cb f9 44 	sub	r11,sp,-1724
80007c44:	f6 09 00 38 	add	r8,r11,r9<<0x3
80007c48:	f1 40 fd 88 	st.w	r8[-632],r0
80007c4c:	2f f9       	sub	r9,-1
80007c4e:	14 96       	mov	r6,r10
80007c50:	fb 49 06 b4 	st.w	sp[1716],r9
80007c54:	c0 58       	rjmp	80007c5e <_vfprintf_r+0x2d6>
80007c56:	70 00       	ld.w	r0,r8[0x0]
80007c58:	14 96       	mov	r6,r10
80007c5a:	2f c8       	sub	r8,-4
80007c5c:	51 08       	stdsp	sp[0x40],r8
80007c5e:	58 00       	cp.w	r0,0
80007c60:	fe 94 ff 78 	brge	80007b50 <_vfprintf_r+0x1c8>
80007c64:	5c 30       	neg	r0
80007c66:	a3 a5       	sbr	r5,0x2
80007c68:	c7 4b       	rjmp	80007b50 <_vfprintf_r+0x1c8>
80007c6a:	32 b8       	mov	r8,43
80007c6c:	fb 68 06 bb 	st.b	sp[1723],r8
80007c70:	c7 0b       	rjmp	80007b50 <_vfprintf_r+0x1c8>
80007c72:	0f 38       	ld.ub	r8,r7++
80007c74:	e0 48 00 2a 	cp.w	r8,42
80007c78:	c0 30       	breq	80007c7e <_vfprintf_r+0x2f6>
80007c7a:	30 09       	mov	r9,0
80007c7c:	c7 d8       	rjmp	80007d76 <_vfprintf_r+0x3ee>
80007c7e:	0f 88       	ld.ub	r8,r7[0x0]
80007c80:	f0 c9 00 30 	sub	r9,r8,48
80007c84:	58 99       	cp.w	r9,9
80007c86:	e0 8b 00 23 	brhi	80007ccc <_vfprintf_r+0x344>
80007c8a:	ee c4 ff ff 	sub	r4,r7,-1
80007c8e:	30 0b       	mov	r11,0
80007c90:	23 08       	sub	r8,48
80007c92:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
80007c96:	f0 0b 00 1b 	add	r11,r8,r11<<0x1
80007c9a:	09 38       	ld.ub	r8,r4++
80007c9c:	f0 c9 00 30 	sub	r9,r8,48
80007ca0:	58 99       	cp.w	r9,9
80007ca2:	fe 98 ff f7 	brls	80007c90 <_vfprintf_r+0x308>
80007ca6:	e0 48 00 24 	cp.w	r8,36
80007caa:	fe 91 ff 51 	brne	80007b4c <_vfprintf_r+0x1c4>
80007cae:	e0 4b 00 20 	cp.w	r11,32
80007cb2:	e0 89 0d f5 	brgt	8000989c <_vfprintf_r+0x1f14>
80007cb6:	20 1b       	sub	r11,1
80007cb8:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007cbc:	10 3b       	cp.w	r11,r8
80007cbe:	c0 e5       	brlt	80007cda <_vfprintf_r+0x352>
80007cc0:	c1 58       	rjmp	80007cea <_vfprintf_r+0x362>
80007cc2:	d7 03       	nop
80007cc4:	80 01       	ld.sh	r1,r0[0x0]
80007cc6:	5e 38       	retlo	r8
80007cc8:	80 01       	ld.sh	r1,r0[0x0]
80007cca:	60 74       	ld.w	r4,r0[0x1c]
80007ccc:	fa fa 06 b4 	ld.w	r10,sp[1716]
80007cd0:	ec c9 ff ff 	sub	r9,r6,-1
80007cd4:	14 36       	cp.w	r6,r10
80007cd6:	c1 f5       	brlt	80007d14 <_vfprintf_r+0x38c>
80007cd8:	c2 88       	rjmp	80007d28 <_vfprintf_r+0x3a0>
80007cda:	fa ca f9 44 	sub	r10,sp,-1724
80007cde:	f4 0b 00 3b 	add	r11,r10,r11<<0x3
80007ce2:	f6 fb fd 88 	ld.w	r11,r11[-632]
80007ce6:	50 2b       	stdsp	sp[0x8],r11
80007ce8:	c3 c8       	rjmp	80007d60 <_vfprintf_r+0x3d8>
80007cea:	fa c8 f9 50 	sub	r8,sp,-1712
80007cee:	1a d8       	st.w	--sp,r8
80007cf0:	fa c8 fa b8 	sub	r8,sp,-1352
80007cf4:	1a d8       	st.w	--sp,r8
80007cf6:	fa c8 fb b4 	sub	r8,sp,-1100
80007cfa:	02 9a       	mov	r10,r1
80007cfc:	1a d8       	st.w	--sp,r8
80007cfe:	04 9c       	mov	r12,r2
80007d00:	fa c8 f9 40 	sub	r8,sp,-1728
80007d04:	fa c9 ff b4 	sub	r9,sp,-76
80007d08:	fe b0 fc a2 	rcall	8000764c <get_arg>
80007d0c:	2f dd       	sub	sp,-12
80007d0e:	78 0c       	ld.w	r12,r12[0x0]
80007d10:	50 2c       	stdsp	sp[0x8],r12
80007d12:	c2 78       	rjmp	80007d60 <_vfprintf_r+0x3d8>
80007d14:	12 96       	mov	r6,r9
80007d16:	0e 94       	mov	r4,r7
80007d18:	fa c9 f9 44 	sub	r9,sp,-1724
80007d1c:	f2 03 00 38 	add	r8,r9,r3<<0x3
80007d20:	f0 f8 fd 88 	ld.w	r8,r8[-632]
80007d24:	50 28       	stdsp	sp[0x8],r8
80007d26:	c1 d8       	rjmp	80007d60 <_vfprintf_r+0x3d8>
80007d28:	41 08       	lddsp	r8,sp[0x40]
80007d2a:	59 fa       	cp.w	r10,31
80007d2c:	e0 89 00 14 	brgt	80007d54 <_vfprintf_r+0x3cc>
80007d30:	f0 cb ff fc 	sub	r11,r8,-4
80007d34:	70 08       	ld.w	r8,r8[0x0]
80007d36:	51 0b       	stdsp	sp[0x40],r11
80007d38:	50 28       	stdsp	sp[0x8],r8
80007d3a:	fa c6 f9 44 	sub	r6,sp,-1724
80007d3e:	40 2e       	lddsp	lr,sp[0x8]
80007d40:	ec 0a 00 38 	add	r8,r6,r10<<0x3
80007d44:	f1 4e fd 88 	st.w	r8[-632],lr
80007d48:	2f fa       	sub	r10,-1
80007d4a:	0e 94       	mov	r4,r7
80007d4c:	fb 4a 06 b4 	st.w	sp[1716],r10
80007d50:	12 96       	mov	r6,r9
80007d52:	c0 78       	rjmp	80007d60 <_vfprintf_r+0x3d8>
80007d54:	70 0c       	ld.w	r12,r8[0x0]
80007d56:	0e 94       	mov	r4,r7
80007d58:	2f c8       	sub	r8,-4
80007d5a:	50 2c       	stdsp	sp[0x8],r12
80007d5c:	12 96       	mov	r6,r9
80007d5e:	51 08       	stdsp	sp[0x40],r8
80007d60:	40 2b       	lddsp	r11,sp[0x8]
80007d62:	58 0b       	cp.w	r11,0
80007d64:	fe 95 fe f0 	brlt	80007b44 <_vfprintf_r+0x1bc>
80007d68:	08 97       	mov	r7,r4
80007d6a:	cf 3a       	rjmp	80007b50 <_vfprintf_r+0x1c8>
80007d6c:	f2 09 00 29 	add	r9,r9,r9<<0x2
80007d70:	0f 38       	ld.ub	r8,r7++
80007d72:	f4 09 00 19 	add	r9,r10,r9<<0x1
80007d76:	f0 ca 00 30 	sub	r10,r8,48
80007d7a:	58 9a       	cp.w	r10,9
80007d7c:	fe 98 ff f8 	brls	80007d6c <_vfprintf_r+0x3e4>
80007d80:	3f fa       	mov	r10,-1
80007d82:	f2 0a 0c 49 	max	r9,r9,r10
80007d86:	50 29       	stdsp	sp[0x8],r9
80007d88:	ce 7a       	rjmp	80007b56 <_vfprintf_r+0x1ce>
80007d8a:	a7 b5       	sbr	r5,0x7
80007d8c:	ce 2a       	rjmp	80007b50 <_vfprintf_r+0x1c8>
80007d8e:	30 09       	mov	r9,0
80007d90:	23 08       	sub	r8,48
80007d92:	f2 09 00 29 	add	r9,r9,r9<<0x2
80007d96:	f0 09 00 19 	add	r9,r8,r9<<0x1
80007d9a:	0f 38       	ld.ub	r8,r7++
80007d9c:	f0 ca 00 30 	sub	r10,r8,48
80007da0:	58 9a       	cp.w	r10,9
80007da2:	fe 98 ff f7 	brls	80007d90 <_vfprintf_r+0x408>
80007da6:	e0 48 00 24 	cp.w	r8,36
80007daa:	fe 91 fe d5 	brne	80007b54 <_vfprintf_r+0x1cc>
80007dae:	e0 49 00 20 	cp.w	r9,32
80007db2:	e0 89 0d 75 	brgt	8000989c <_vfprintf_r+0x1f14>
80007db6:	f2 c3 00 01 	sub	r3,r9,1
80007dba:	30 19       	mov	r9,1
80007dbc:	50 39       	stdsp	sp[0xc],r9
80007dbe:	cc 9a       	rjmp	80007b50 <_vfprintf_r+0x1c8>
80007dc0:	a3 b5       	sbr	r5,0x3
80007dc2:	cc 7a       	rjmp	80007b50 <_vfprintf_r+0x1c8>
80007dc4:	a7 a5       	sbr	r5,0x6
80007dc6:	cc 5a       	rjmp	80007b50 <_vfprintf_r+0x1c8>
80007dc8:	0a 98       	mov	r8,r5
80007dca:	a5 b5       	sbr	r5,0x5
80007dcc:	a5 a8       	sbr	r8,0x4
80007dce:	0f 89       	ld.ub	r9,r7[0x0]
80007dd0:	36 ce       	mov	lr,108
80007dd2:	fc 09 18 00 	cp.b	r9,lr
80007dd6:	f7 b7 00 ff 	subeq	r7,-1
80007dda:	f0 05 17 10 	movne	r5,r8
80007dde:	cb 9a       	rjmp	80007b50 <_vfprintf_r+0x1c8>
80007de0:	a5 b5       	sbr	r5,0x5
80007de2:	cb 7a       	rjmp	80007b50 <_vfprintf_r+0x1c8>
80007de4:	50 a7       	stdsp	sp[0x28],r7
80007de6:	50 80       	stdsp	sp[0x20],r0
80007de8:	0c 97       	mov	r7,r6
80007dea:	10 90       	mov	r0,r8
80007dec:	06 96       	mov	r6,r3
80007dee:	04 94       	mov	r4,r2
80007df0:	40 93       	lddsp	r3,sp[0x24]
80007df2:	02 92       	mov	r2,r1
80007df4:	0e 99       	mov	r9,r7
80007df6:	40 41       	lddsp	r1,sp[0x10]
80007df8:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007dfc:	40 3c       	lddsp	r12,sp[0xc]
80007dfe:	58 0c       	cp.w	r12,0
80007e00:	c1 d0       	breq	80007e3a <_vfprintf_r+0x4b2>
80007e02:	10 36       	cp.w	r6,r8
80007e04:	c0 64       	brge	80007e10 <_vfprintf_r+0x488>
80007e06:	fa cb f9 44 	sub	r11,sp,-1724
80007e0a:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007e0e:	c1 d8       	rjmp	80007e48 <_vfprintf_r+0x4c0>
80007e10:	fa c8 f9 50 	sub	r8,sp,-1712
80007e14:	1a d8       	st.w	--sp,r8
80007e16:	fa c8 fa b8 	sub	r8,sp,-1352
80007e1a:	1a d8       	st.w	--sp,r8
80007e1c:	fa c8 fb b4 	sub	r8,sp,-1100
80007e20:	1a d8       	st.w	--sp,r8
80007e22:	fa c8 f9 40 	sub	r8,sp,-1728
80007e26:	fa c9 ff b4 	sub	r9,sp,-76
80007e2a:	04 9a       	mov	r10,r2
80007e2c:	0c 9b       	mov	r11,r6
80007e2e:	08 9c       	mov	r12,r4
80007e30:	fe b0 fc 0e 	rcall	8000764c <get_arg>
80007e34:	2f dd       	sub	sp,-12
80007e36:	19 b8       	ld.ub	r8,r12[0x3]
80007e38:	c2 28       	rjmp	80007e7c <_vfprintf_r+0x4f4>
80007e3a:	2f f7       	sub	r7,-1
80007e3c:	10 39       	cp.w	r9,r8
80007e3e:	c0 84       	brge	80007e4e <_vfprintf_r+0x4c6>
80007e40:	fa ca f9 44 	sub	r10,sp,-1724
80007e44:	f4 06 00 36 	add	r6,r10,r6<<0x3
80007e48:	ed 38 fd 8b 	ld.ub	r8,r6[-629]
80007e4c:	c1 88       	rjmp	80007e7c <_vfprintf_r+0x4f4>
80007e4e:	41 09       	lddsp	r9,sp[0x40]
80007e50:	59 f8       	cp.w	r8,31
80007e52:	e0 89 00 12 	brgt	80007e76 <_vfprintf_r+0x4ee>
80007e56:	f2 ca ff fc 	sub	r10,r9,-4
80007e5a:	51 0a       	stdsp	sp[0x40],r10
80007e5c:	72 09       	ld.w	r9,r9[0x0]
80007e5e:	fa c6 f9 44 	sub	r6,sp,-1724
80007e62:	ec 08 00 3a 	add	r10,r6,r8<<0x3
80007e66:	2f f8       	sub	r8,-1
80007e68:	f5 49 fd 88 	st.w	r10[-632],r9
80007e6c:	fb 48 06 b4 	st.w	sp[1716],r8
80007e70:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
80007e74:	c0 48       	rjmp	80007e7c <_vfprintf_r+0x4f4>
80007e76:	13 b8       	ld.ub	r8,r9[0x3]
80007e78:	2f c9       	sub	r9,-4
80007e7a:	51 09       	stdsp	sp[0x40],r9
80007e7c:	fb 68 06 60 	st.b	sp[1632],r8
80007e80:	30 0e       	mov	lr,0
80007e82:	30 08       	mov	r8,0
80007e84:	30 12       	mov	r2,1
80007e86:	fb 68 06 bb 	st.b	sp[1723],r8
80007e8a:	50 2e       	stdsp	sp[0x8],lr
80007e8c:	e0 8f 08 b1 	bral	80008fee <_vfprintf_r+0x1666>
80007e90:	50 a7       	stdsp	sp[0x28],r7
80007e92:	50 80       	stdsp	sp[0x20],r0
80007e94:	0c 97       	mov	r7,r6
80007e96:	04 94       	mov	r4,r2
80007e98:	06 96       	mov	r6,r3
80007e9a:	02 92       	mov	r2,r1
80007e9c:	40 93       	lddsp	r3,sp[0x24]
80007e9e:	10 90       	mov	r0,r8
80007ea0:	40 41       	lddsp	r1,sp[0x10]
80007ea2:	a5 a5       	sbr	r5,0x4
80007ea4:	c0 a8       	rjmp	80007eb8 <_vfprintf_r+0x530>
80007ea6:	50 a7       	stdsp	sp[0x28],r7
80007ea8:	50 80       	stdsp	sp[0x20],r0
80007eaa:	0c 97       	mov	r7,r6
80007eac:	04 94       	mov	r4,r2
80007eae:	06 96       	mov	r6,r3
80007eb0:	02 92       	mov	r2,r1
80007eb2:	40 93       	lddsp	r3,sp[0x24]
80007eb4:	10 90       	mov	r0,r8
80007eb6:	40 41       	lddsp	r1,sp[0x10]
80007eb8:	ed b5 00 05 	bld	r5,0x5
80007ebc:	c5 11       	brne	80007f5e <_vfprintf_r+0x5d6>
80007ebe:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007ec2:	40 3c       	lddsp	r12,sp[0xc]
80007ec4:	58 0c       	cp.w	r12,0
80007ec6:	c1 e0       	breq	80007f02 <_vfprintf_r+0x57a>
80007ec8:	10 36       	cp.w	r6,r8
80007eca:	c0 64       	brge	80007ed6 <_vfprintf_r+0x54e>
80007ecc:	fa cb f9 44 	sub	r11,sp,-1724
80007ed0:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007ed4:	c2 08       	rjmp	80007f14 <_vfprintf_r+0x58c>
80007ed6:	fa c8 f9 50 	sub	r8,sp,-1712
80007eda:	1a d8       	st.w	--sp,r8
80007edc:	fa c8 fa b8 	sub	r8,sp,-1352
80007ee0:	0c 9b       	mov	r11,r6
80007ee2:	1a d8       	st.w	--sp,r8
80007ee4:	fa c8 fb b4 	sub	r8,sp,-1100
80007ee8:	1a d8       	st.w	--sp,r8
80007eea:	fa c9 ff b4 	sub	r9,sp,-76
80007eee:	fa c8 f9 40 	sub	r8,sp,-1728
80007ef2:	04 9a       	mov	r10,r2
80007ef4:	08 9c       	mov	r12,r4
80007ef6:	fe b0 fb ab 	rcall	8000764c <get_arg>
80007efa:	2f dd       	sub	sp,-12
80007efc:	78 1b       	ld.w	r11,r12[0x4]
80007efe:	78 09       	ld.w	r9,r12[0x0]
80007f00:	c2 b8       	rjmp	80007f56 <_vfprintf_r+0x5ce>
80007f02:	ee ca ff ff 	sub	r10,r7,-1
80007f06:	10 37       	cp.w	r7,r8
80007f08:	c0 b4       	brge	80007f1e <_vfprintf_r+0x596>
80007f0a:	fa c9 f9 44 	sub	r9,sp,-1724
80007f0e:	14 97       	mov	r7,r10
80007f10:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007f14:	ec fb fd 8c 	ld.w	r11,r6[-628]
80007f18:	ec f9 fd 88 	ld.w	r9,r6[-632]
80007f1c:	c1 d8       	rjmp	80007f56 <_vfprintf_r+0x5ce>
80007f1e:	41 09       	lddsp	r9,sp[0x40]
80007f20:	59 f8       	cp.w	r8,31
80007f22:	e0 89 00 14 	brgt	80007f4a <_vfprintf_r+0x5c2>
80007f26:	f2 cb ff f8 	sub	r11,r9,-8
80007f2a:	51 0b       	stdsp	sp[0x40],r11
80007f2c:	fa c6 f9 44 	sub	r6,sp,-1724
80007f30:	72 1b       	ld.w	r11,r9[0x4]
80007f32:	ec 08 00 3c 	add	r12,r6,r8<<0x3
80007f36:	72 09       	ld.w	r9,r9[0x0]
80007f38:	f9 4b fd 8c 	st.w	r12[-628],r11
80007f3c:	f9 49 fd 88 	st.w	r12[-632],r9
80007f40:	2f f8       	sub	r8,-1
80007f42:	14 97       	mov	r7,r10
80007f44:	fb 48 06 b4 	st.w	sp[1716],r8
80007f48:	c0 78       	rjmp	80007f56 <_vfprintf_r+0x5ce>
80007f4a:	f2 c8 ff f8 	sub	r8,r9,-8
80007f4e:	72 1b       	ld.w	r11,r9[0x4]
80007f50:	14 97       	mov	r7,r10
80007f52:	51 08       	stdsp	sp[0x40],r8
80007f54:	72 09       	ld.w	r9,r9[0x0]
80007f56:	16 98       	mov	r8,r11
80007f58:	fa e9 00 00 	st.d	sp[0],r8
80007f5c:	ca e8       	rjmp	800080b8 <_vfprintf_r+0x730>
80007f5e:	ed b5 00 04 	bld	r5,0x4
80007f62:	c1 71       	brne	80007f90 <_vfprintf_r+0x608>
80007f64:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007f68:	40 3e       	lddsp	lr,sp[0xc]
80007f6a:	58 0e       	cp.w	lr,0
80007f6c:	c0 80       	breq	80007f7c <_vfprintf_r+0x5f4>
80007f6e:	10 36       	cp.w	r6,r8
80007f70:	c6 94       	brge	80008042 <_vfprintf_r+0x6ba>
80007f72:	fa cc f9 44 	sub	r12,sp,-1724
80007f76:	f8 06 00 36 	add	r6,r12,r6<<0x3
80007f7a:	c8 28       	rjmp	8000807e <_vfprintf_r+0x6f6>
80007f7c:	ee ca ff ff 	sub	r10,r7,-1
80007f80:	10 37       	cp.w	r7,r8
80007f82:	e0 84 00 81 	brge	80008084 <_vfprintf_r+0x6fc>
80007f86:	fa cb f9 44 	sub	r11,sp,-1724
80007f8a:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007f8e:	c7 78       	rjmp	8000807c <_vfprintf_r+0x6f4>
80007f90:	ed b5 00 06 	bld	r5,0x6
80007f94:	c4 b1       	brne	8000802a <_vfprintf_r+0x6a2>
80007f96:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007f9a:	40 3c       	lddsp	r12,sp[0xc]
80007f9c:	58 0c       	cp.w	r12,0
80007f9e:	c1 d0       	breq	80007fd8 <_vfprintf_r+0x650>
80007fa0:	10 36       	cp.w	r6,r8
80007fa2:	c0 64       	brge	80007fae <_vfprintf_r+0x626>
80007fa4:	fa cb f9 44 	sub	r11,sp,-1724
80007fa8:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007fac:	c1 f8       	rjmp	80007fea <_vfprintf_r+0x662>
80007fae:	fa c8 f9 50 	sub	r8,sp,-1712
80007fb2:	1a d8       	st.w	--sp,r8
80007fb4:	fa c8 fa b8 	sub	r8,sp,-1352
80007fb8:	1a d8       	st.w	--sp,r8
80007fba:	fa c8 fb b4 	sub	r8,sp,-1100
80007fbe:	1a d8       	st.w	--sp,r8
80007fc0:	fa c8 f9 40 	sub	r8,sp,-1728
80007fc4:	fa c9 ff b4 	sub	r9,sp,-76
80007fc8:	04 9a       	mov	r10,r2
80007fca:	0c 9b       	mov	r11,r6
80007fcc:	08 9c       	mov	r12,r4
80007fce:	fe b0 fb 3f 	rcall	8000764c <get_arg>
80007fd2:	2f dd       	sub	sp,-12
80007fd4:	98 18       	ld.sh	r8,r12[0x2]
80007fd6:	c2 68       	rjmp	80008022 <_vfprintf_r+0x69a>
80007fd8:	ee ca ff ff 	sub	r10,r7,-1
80007fdc:	10 37       	cp.w	r7,r8
80007fde:	c0 94       	brge	80007ff0 <_vfprintf_r+0x668>
80007fe0:	fa c9 f9 44 	sub	r9,sp,-1724
80007fe4:	14 97       	mov	r7,r10
80007fe6:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007fea:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80007fee:	c1 a8       	rjmp	80008022 <_vfprintf_r+0x69a>
80007ff0:	41 09       	lddsp	r9,sp[0x40]
80007ff2:	59 f8       	cp.w	r8,31
80007ff4:	e0 89 00 13 	brgt	8000801a <_vfprintf_r+0x692>
80007ff8:	f2 cb ff fc 	sub	r11,r9,-4
80007ffc:	51 0b       	stdsp	sp[0x40],r11
80007ffe:	72 09       	ld.w	r9,r9[0x0]
80008000:	fa c6 f9 44 	sub	r6,sp,-1724
80008004:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008008:	2f f8       	sub	r8,-1
8000800a:	f7 49 fd 88 	st.w	r11[-632],r9
8000800e:	fb 48 06 b4 	st.w	sp[1716],r8
80008012:	14 97       	mov	r7,r10
80008014:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008018:	c0 58       	rjmp	80008022 <_vfprintf_r+0x69a>
8000801a:	92 18       	ld.sh	r8,r9[0x2]
8000801c:	14 97       	mov	r7,r10
8000801e:	2f c9       	sub	r9,-4
80008020:	51 09       	stdsp	sp[0x40],r9
80008022:	50 18       	stdsp	sp[0x4],r8
80008024:	bf 58       	asr	r8,0x1f
80008026:	50 08       	stdsp	sp[0x0],r8
80008028:	c4 88       	rjmp	800080b8 <_vfprintf_r+0x730>
8000802a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000802e:	40 3c       	lddsp	r12,sp[0xc]
80008030:	58 0c       	cp.w	r12,0
80008032:	c1 d0       	breq	8000806c <_vfprintf_r+0x6e4>
80008034:	10 36       	cp.w	r6,r8
80008036:	c0 64       	brge	80008042 <_vfprintf_r+0x6ba>
80008038:	fa cb f9 44 	sub	r11,sp,-1724
8000803c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008040:	c1 f8       	rjmp	8000807e <_vfprintf_r+0x6f6>
80008042:	fa c8 f9 50 	sub	r8,sp,-1712
80008046:	1a d8       	st.w	--sp,r8
80008048:	fa c8 fa b8 	sub	r8,sp,-1352
8000804c:	0c 9b       	mov	r11,r6
8000804e:	1a d8       	st.w	--sp,r8
80008050:	fa c8 fb b4 	sub	r8,sp,-1100
80008054:	04 9a       	mov	r10,r2
80008056:	1a d8       	st.w	--sp,r8
80008058:	08 9c       	mov	r12,r4
8000805a:	fa c8 f9 40 	sub	r8,sp,-1728
8000805e:	fa c9 ff b4 	sub	r9,sp,-76
80008062:	fe b0 fa f5 	rcall	8000764c <get_arg>
80008066:	2f dd       	sub	sp,-12
80008068:	78 0b       	ld.w	r11,r12[0x0]
8000806a:	c2 48       	rjmp	800080b2 <_vfprintf_r+0x72a>
8000806c:	ee ca ff ff 	sub	r10,r7,-1
80008070:	10 37       	cp.w	r7,r8
80008072:	c0 94       	brge	80008084 <_vfprintf_r+0x6fc>
80008074:	fa c9 f9 44 	sub	r9,sp,-1724
80008078:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000807c:	14 97       	mov	r7,r10
8000807e:	ec fb fd 88 	ld.w	r11,r6[-632]
80008082:	c1 88       	rjmp	800080b2 <_vfprintf_r+0x72a>
80008084:	41 09       	lddsp	r9,sp[0x40]
80008086:	59 f8       	cp.w	r8,31
80008088:	e0 89 00 11 	brgt	800080aa <_vfprintf_r+0x722>
8000808c:	f2 cb ff fc 	sub	r11,r9,-4
80008090:	51 0b       	stdsp	sp[0x40],r11
80008092:	fa c6 f9 44 	sub	r6,sp,-1724
80008096:	72 0b       	ld.w	r11,r9[0x0]
80008098:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000809c:	f3 4b fd 88 	st.w	r9[-632],r11
800080a0:	2f f8       	sub	r8,-1
800080a2:	14 97       	mov	r7,r10
800080a4:	fb 48 06 b4 	st.w	sp[1716],r8
800080a8:	c0 58       	rjmp	800080b2 <_vfprintf_r+0x72a>
800080aa:	72 0b       	ld.w	r11,r9[0x0]
800080ac:	14 97       	mov	r7,r10
800080ae:	2f c9       	sub	r9,-4
800080b0:	51 09       	stdsp	sp[0x40],r9
800080b2:	50 1b       	stdsp	sp[0x4],r11
800080b4:	bf 5b       	asr	r11,0x1f
800080b6:	50 0b       	stdsp	sp[0x0],r11
800080b8:	fa ea 00 00 	ld.d	r10,sp[0]
800080bc:	58 0a       	cp.w	r10,0
800080be:	5c 2b       	cpc	r11
800080c0:	c0 e4       	brge	800080dc <_vfprintf_r+0x754>
800080c2:	30 08       	mov	r8,0
800080c4:	fa ea 00 00 	ld.d	r10,sp[0]
800080c8:	30 09       	mov	r9,0
800080ca:	f0 0a 01 0a 	sub	r10,r8,r10
800080ce:	f2 0b 01 4b 	sbc	r11,r9,r11
800080d2:	32 d8       	mov	r8,45
800080d4:	fa eb 00 00 	st.d	sp[0],r10
800080d8:	fb 68 06 bb 	st.b	sp[1723],r8
800080dc:	30 18       	mov	r8,1
800080de:	e0 8f 06 fe 	bral	80008eda <_vfprintf_r+0x1552>
800080e2:	50 a7       	stdsp	sp[0x28],r7
800080e4:	50 80       	stdsp	sp[0x20],r0
800080e6:	0c 97       	mov	r7,r6
800080e8:	04 94       	mov	r4,r2
800080ea:	06 96       	mov	r6,r3
800080ec:	02 92       	mov	r2,r1
800080ee:	40 93       	lddsp	r3,sp[0x24]
800080f0:	10 90       	mov	r0,r8
800080f2:	40 41       	lddsp	r1,sp[0x10]
800080f4:	0e 99       	mov	r9,r7
800080f6:	ed b5 00 03 	bld	r5,0x3
800080fa:	c4 11       	brne	8000817c <_vfprintf_r+0x7f4>
800080fc:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008100:	40 3a       	lddsp	r10,sp[0xc]
80008102:	58 0a       	cp.w	r10,0
80008104:	c1 90       	breq	80008136 <_vfprintf_r+0x7ae>
80008106:	10 36       	cp.w	r6,r8
80008108:	c6 45       	brlt	800081d0 <_vfprintf_r+0x848>
8000810a:	fa c8 f9 50 	sub	r8,sp,-1712
8000810e:	1a d8       	st.w	--sp,r8
80008110:	fa c8 fa b8 	sub	r8,sp,-1352
80008114:	1a d8       	st.w	--sp,r8
80008116:	fa c8 fb b4 	sub	r8,sp,-1100
8000811a:	0c 9b       	mov	r11,r6
8000811c:	1a d8       	st.w	--sp,r8
8000811e:	04 9a       	mov	r10,r2
80008120:	fa c8 f9 40 	sub	r8,sp,-1728
80008124:	fa c9 ff b4 	sub	r9,sp,-76
80008128:	08 9c       	mov	r12,r4
8000812a:	fe b0 fa 91 	rcall	8000764c <get_arg>
8000812e:	2f dd       	sub	sp,-12
80008130:	78 16       	ld.w	r6,r12[0x4]
80008132:	50 76       	stdsp	sp[0x1c],r6
80008134:	c4 88       	rjmp	800081c4 <_vfprintf_r+0x83c>
80008136:	2f f7       	sub	r7,-1
80008138:	10 39       	cp.w	r9,r8
8000813a:	c0 c4       	brge	80008152 <_vfprintf_r+0x7ca>
8000813c:	fa ce f9 44 	sub	lr,sp,-1724
80008140:	fc 06 00 36 	add	r6,lr,r6<<0x3
80008144:	ec fc fd 8c 	ld.w	r12,r6[-628]
80008148:	50 7c       	stdsp	sp[0x1c],r12
8000814a:	ec f6 fd 88 	ld.w	r6,r6[-632]
8000814e:	50 56       	stdsp	sp[0x14],r6
80008150:	c6 68       	rjmp	8000821c <_vfprintf_r+0x894>
80008152:	41 09       	lddsp	r9,sp[0x40]
80008154:	59 f8       	cp.w	r8,31
80008156:	e0 89 00 10 	brgt	80008176 <_vfprintf_r+0x7ee>
8000815a:	f2 ca ff f8 	sub	r10,r9,-8
8000815e:	72 1b       	ld.w	r11,r9[0x4]
80008160:	51 0a       	stdsp	sp[0x40],r10
80008162:	72 09       	ld.w	r9,r9[0x0]
80008164:	fa ca f9 44 	sub	r10,sp,-1724
80008168:	50 7b       	stdsp	sp[0x1c],r11
8000816a:	50 59       	stdsp	sp[0x14],r9
8000816c:	f4 08 00 39 	add	r9,r10,r8<<0x3
80008170:	40 5b       	lddsp	r11,sp[0x14]
80008172:	40 7a       	lddsp	r10,sp[0x1c]
80008174:	c4 78       	rjmp	80008202 <_vfprintf_r+0x87a>
80008176:	72 18       	ld.w	r8,r9[0x4]
80008178:	50 78       	stdsp	sp[0x1c],r8
8000817a:	c4 c8       	rjmp	80008212 <_vfprintf_r+0x88a>
8000817c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008180:	40 3e       	lddsp	lr,sp[0xc]
80008182:	58 0e       	cp.w	lr,0
80008184:	c2 30       	breq	800081ca <_vfprintf_r+0x842>
80008186:	10 36       	cp.w	r6,r8
80008188:	c0 94       	brge	8000819a <_vfprintf_r+0x812>
8000818a:	fa cc f9 44 	sub	r12,sp,-1724
8000818e:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008192:	ec fb fd 8c 	ld.w	r11,r6[-628]
80008196:	50 7b       	stdsp	sp[0x1c],r11
80008198:	cd 9b       	rjmp	8000814a <_vfprintf_r+0x7c2>
8000819a:	fa c8 f9 50 	sub	r8,sp,-1712
8000819e:	1a d8       	st.w	--sp,r8
800081a0:	fa c8 fa b8 	sub	r8,sp,-1352
800081a4:	04 9a       	mov	r10,r2
800081a6:	1a d8       	st.w	--sp,r8
800081a8:	fa c8 fb b4 	sub	r8,sp,-1100
800081ac:	0c 9b       	mov	r11,r6
800081ae:	1a d8       	st.w	--sp,r8
800081b0:	08 9c       	mov	r12,r4
800081b2:	fa c8 f9 40 	sub	r8,sp,-1728
800081b6:	fa c9 ff b4 	sub	r9,sp,-76
800081ba:	fe b0 fa 49 	rcall	8000764c <get_arg>
800081be:	2f dd       	sub	sp,-12
800081c0:	78 1a       	ld.w	r10,r12[0x4]
800081c2:	50 7a       	stdsp	sp[0x1c],r10
800081c4:	78 0c       	ld.w	r12,r12[0x0]
800081c6:	50 5c       	stdsp	sp[0x14],r12
800081c8:	c2 a8       	rjmp	8000821c <_vfprintf_r+0x894>
800081ca:	2f f7       	sub	r7,-1
800081cc:	10 39       	cp.w	r9,r8
800081ce:	c0 94       	brge	800081e0 <_vfprintf_r+0x858>
800081d0:	fa c9 f9 44 	sub	r9,sp,-1724
800081d4:	f2 06 00 36 	add	r6,r9,r6<<0x3
800081d8:	ec f8 fd 8c 	ld.w	r8,r6[-628]
800081dc:	50 78       	stdsp	sp[0x1c],r8
800081de:	cb 6b       	rjmp	8000814a <_vfprintf_r+0x7c2>
800081e0:	41 09       	lddsp	r9,sp[0x40]
800081e2:	59 f8       	cp.w	r8,31
800081e4:	e0 89 00 15 	brgt	8000820e <_vfprintf_r+0x886>
800081e8:	f2 ca ff f8 	sub	r10,r9,-8
800081ec:	72 16       	ld.w	r6,r9[0x4]
800081ee:	72 09       	ld.w	r9,r9[0x0]
800081f0:	51 0a       	stdsp	sp[0x40],r10
800081f2:	50 59       	stdsp	sp[0x14],r9
800081f4:	fa ce f9 44 	sub	lr,sp,-1724
800081f8:	50 76       	stdsp	sp[0x1c],r6
800081fa:	fc 08 00 39 	add	r9,lr,r8<<0x3
800081fe:	40 5b       	lddsp	r11,sp[0x14]
80008200:	0c 9a       	mov	r10,r6
80008202:	f2 eb fd 88 	st.d	r9[-632],r10
80008206:	2f f8       	sub	r8,-1
80008208:	fb 48 06 b4 	st.w	sp[1716],r8
8000820c:	c0 88       	rjmp	8000821c <_vfprintf_r+0x894>
8000820e:	72 1c       	ld.w	r12,r9[0x4]
80008210:	50 7c       	stdsp	sp[0x1c],r12
80008212:	f2 c8 ff f8 	sub	r8,r9,-8
80008216:	51 08       	stdsp	sp[0x40],r8
80008218:	72 09       	ld.w	r9,r9[0x0]
8000821a:	50 59       	stdsp	sp[0x14],r9
8000821c:	40 5b       	lddsp	r11,sp[0x14]
8000821e:	40 7a       	lddsp	r10,sp[0x1c]
80008220:	e0 a0 19 64 	rcall	8000b4e8 <__isinfd>
80008224:	18 96       	mov	r6,r12
80008226:	c1 50       	breq	80008250 <_vfprintf_r+0x8c8>
80008228:	30 08       	mov	r8,0
8000822a:	30 09       	mov	r9,0
8000822c:	40 5b       	lddsp	r11,sp[0x14]
8000822e:	40 7a       	lddsp	r10,sp[0x1c]
80008230:	e0 a0 1d ba 	rcall	8000bda4 <__avr32_f64_cmp_lt>
80008234:	c0 40       	breq	8000823c <_vfprintf_r+0x8b4>
80008236:	32 d8       	mov	r8,45
80008238:	fb 68 06 bb 	st.b	sp[1723],r8
8000823c:	4d 18       	lddpc	r8,80008380 <_vfprintf_r+0x9f8>
8000823e:	4d 26       	lddpc	r6,80008384 <_vfprintf_r+0x9fc>
80008240:	a7 d5       	cbr	r5,0x7
80008242:	e0 40 00 47 	cp.w	r0,71
80008246:	f0 06 17 a0 	movle	r6,r8
8000824a:	30 32       	mov	r2,3
8000824c:	e0 8f 06 d4 	bral	80008ff4 <_vfprintf_r+0x166c>
80008250:	40 5b       	lddsp	r11,sp[0x14]
80008252:	40 7a       	lddsp	r10,sp[0x1c]
80008254:	e0 a0 19 5f 	rcall	8000b512 <__isnand>
80008258:	c0 c0       	breq	80008270 <_vfprintf_r+0x8e8>
8000825a:	50 26       	stdsp	sp[0x8],r6
8000825c:	4c b8       	lddpc	r8,80008388 <_vfprintf_r+0xa00>
8000825e:	4c c6       	lddpc	r6,8000838c <_vfprintf_r+0xa04>
80008260:	a7 d5       	cbr	r5,0x7
80008262:	e0 40 00 47 	cp.w	r0,71
80008266:	f0 06 17 a0 	movle	r6,r8
8000826a:	30 32       	mov	r2,3
8000826c:	e0 8f 06 ca 	bral	80009000 <_vfprintf_r+0x1678>
80008270:	40 2a       	lddsp	r10,sp[0x8]
80008272:	5b fa       	cp.w	r10,-1
80008274:	c0 41       	brne	8000827c <_vfprintf_r+0x8f4>
80008276:	30 69       	mov	r9,6
80008278:	50 29       	stdsp	sp[0x8],r9
8000827a:	c1 18       	rjmp	8000829c <_vfprintf_r+0x914>
8000827c:	e0 40 00 47 	cp.w	r0,71
80008280:	5f 09       	sreq	r9
80008282:	e0 40 00 67 	cp.w	r0,103
80008286:	5f 08       	sreq	r8
80008288:	f3 e8 10 08 	or	r8,r9,r8
8000828c:	f8 08 18 00 	cp.b	r8,r12
80008290:	c0 60       	breq	8000829c <_vfprintf_r+0x914>
80008292:	40 28       	lddsp	r8,sp[0x8]
80008294:	58 08       	cp.w	r8,0
80008296:	f9 b8 00 01 	moveq	r8,1
8000829a:	50 28       	stdsp	sp[0x8],r8
8000829c:	40 78       	lddsp	r8,sp[0x1c]
8000829e:	40 59       	lddsp	r9,sp[0x14]
800082a0:	fa e9 06 94 	st.d	sp[1684],r8
800082a4:	a9 a5       	sbr	r5,0x8
800082a6:	fa f8 06 94 	ld.w	r8,sp[1684]
800082aa:	58 08       	cp.w	r8,0
800082ac:	c0 65       	brlt	800082b8 <_vfprintf_r+0x930>
800082ae:	40 5e       	lddsp	lr,sp[0x14]
800082b0:	30 0c       	mov	r12,0
800082b2:	50 6e       	stdsp	sp[0x18],lr
800082b4:	50 9c       	stdsp	sp[0x24],r12
800082b6:	c0 78       	rjmp	800082c4 <_vfprintf_r+0x93c>
800082b8:	40 5b       	lddsp	r11,sp[0x14]
800082ba:	32 da       	mov	r10,45
800082bc:	ee 1b 80 00 	eorh	r11,0x8000
800082c0:	50 9a       	stdsp	sp[0x24],r10
800082c2:	50 6b       	stdsp	sp[0x18],r11
800082c4:	e0 40 00 46 	cp.w	r0,70
800082c8:	5f 09       	sreq	r9
800082ca:	e0 40 00 66 	cp.w	r0,102
800082ce:	5f 08       	sreq	r8
800082d0:	f3 e8 10 08 	or	r8,r9,r8
800082d4:	50 48       	stdsp	sp[0x10],r8
800082d6:	c0 40       	breq	800082de <_vfprintf_r+0x956>
800082d8:	40 22       	lddsp	r2,sp[0x8]
800082da:	30 39       	mov	r9,3
800082dc:	c1 08       	rjmp	800082fc <_vfprintf_r+0x974>
800082de:	e0 40 00 45 	cp.w	r0,69
800082e2:	5f 09       	sreq	r9
800082e4:	e0 40 00 65 	cp.w	r0,101
800082e8:	5f 08       	sreq	r8
800082ea:	40 22       	lddsp	r2,sp[0x8]
800082ec:	10 49       	or	r9,r8
800082ee:	2f f2       	sub	r2,-1
800082f0:	40 46       	lddsp	r6,sp[0x10]
800082f2:	ec 09 18 00 	cp.b	r9,r6
800082f6:	fb f2 00 02 	ld.weq	r2,sp[0x8]
800082fa:	30 29       	mov	r9,2
800082fc:	fa c8 f9 5c 	sub	r8,sp,-1700
80008300:	1a d8       	st.w	--sp,r8
80008302:	fa c8 f9 54 	sub	r8,sp,-1708
80008306:	1a d8       	st.w	--sp,r8
80008308:	fa c8 f9 4c 	sub	r8,sp,-1716
8000830c:	08 9c       	mov	r12,r4
8000830e:	1a d8       	st.w	--sp,r8
80008310:	04 98       	mov	r8,r2
80008312:	40 9b       	lddsp	r11,sp[0x24]
80008314:	40 aa       	lddsp	r10,sp[0x28]
80008316:	e0 a0 0b cf 	rcall	80009ab4 <_dtoa_r>
8000831a:	e0 40 00 47 	cp.w	r0,71
8000831e:	5f 19       	srne	r9
80008320:	e0 40 00 67 	cp.w	r0,103
80008324:	5f 18       	srne	r8
80008326:	18 96       	mov	r6,r12
80008328:	2f dd       	sub	sp,-12
8000832a:	f3 e8 00 08 	and	r8,r9,r8
8000832e:	c0 41       	brne	80008336 <_vfprintf_r+0x9ae>
80008330:	ed b5 00 00 	bld	r5,0x0
80008334:	c3 81       	brne	800083a4 <_vfprintf_r+0xa1c>
80008336:	ec 02 00 0e 	add	lr,r6,r2
8000833a:	50 3e       	stdsp	sp[0xc],lr
8000833c:	40 4c       	lddsp	r12,sp[0x10]
8000833e:	58 0c       	cp.w	r12,0
80008340:	c1 50       	breq	8000836a <_vfprintf_r+0x9e2>
80008342:	0d 89       	ld.ub	r9,r6[0x0]
80008344:	33 08       	mov	r8,48
80008346:	f0 09 18 00 	cp.b	r9,r8
8000834a:	c0 b1       	brne	80008360 <_vfprintf_r+0x9d8>
8000834c:	30 08       	mov	r8,0
8000834e:	30 09       	mov	r9,0
80008350:	40 6b       	lddsp	r11,sp[0x18]
80008352:	40 7a       	lddsp	r10,sp[0x1c]
80008354:	e0 a0 1c e1 	rcall	8000bd16 <__avr32_f64_cmp_eq>
80008358:	fb b2 00 01 	rsubeq	r2,1
8000835c:	fb f2 0b ab 	st.weq	sp[0x6ac],r2
80008360:	40 3b       	lddsp	r11,sp[0xc]
80008362:	fa f8 06 ac 	ld.w	r8,sp[1708]
80008366:	10 0b       	add	r11,r8
80008368:	50 3b       	stdsp	sp[0xc],r11
8000836a:	40 6b       	lddsp	r11,sp[0x18]
8000836c:	30 08       	mov	r8,0
8000836e:	30 09       	mov	r9,0
80008370:	40 7a       	lddsp	r10,sp[0x1c]
80008372:	e0 a0 1c d2 	rcall	8000bd16 <__avr32_f64_cmp_eq>
80008376:	c1 10       	breq	80008398 <_vfprintf_r+0xa10>
80008378:	40 3a       	lddsp	r10,sp[0xc]
8000837a:	fb 4a 06 a4 	st.w	sp[1700],r10
8000837e:	c0 d8       	rjmp	80008398 <_vfprintf_r+0xa10>
80008380:	80 01       	ld.sh	r1,r0[0x0]
80008382:	60 88       	ld.w	r8,r0[0x20]
80008384:	80 01       	ld.sh	r1,r0[0x0]
80008386:	60 8c       	ld.w	r12,r0[0x20]
80008388:	80 01       	ld.sh	r1,r0[0x0]
8000838a:	60 90       	ld.w	r0,r0[0x24]
8000838c:	80 01       	ld.sh	r1,r0[0x0]
8000838e:	60 94       	ld.w	r4,r0[0x24]
80008390:	10 c9       	st.b	r8++,r9
80008392:	fb 48 06 a4 	st.w	sp[1700],r8
80008396:	c0 28       	rjmp	8000839a <_vfprintf_r+0xa12>
80008398:	33 09       	mov	r9,48
8000839a:	fa f8 06 a4 	ld.w	r8,sp[1700]
8000839e:	40 3e       	lddsp	lr,sp[0xc]
800083a0:	1c 38       	cp.w	r8,lr
800083a2:	cf 73       	brcs	80008390 <_vfprintf_r+0xa08>
800083a4:	e0 40 00 47 	cp.w	r0,71
800083a8:	5f 09       	sreq	r9
800083aa:	e0 40 00 67 	cp.w	r0,103
800083ae:	5f 08       	sreq	r8
800083b0:	f3 e8 10 08 	or	r8,r9,r8
800083b4:	fa f9 06 a4 	ld.w	r9,sp[1700]
800083b8:	0c 19       	sub	r9,r6
800083ba:	50 69       	stdsp	sp[0x18],r9
800083bc:	58 08       	cp.w	r8,0
800083be:	c0 b0       	breq	800083d4 <_vfprintf_r+0xa4c>
800083c0:	fa f8 06 ac 	ld.w	r8,sp[1708]
800083c4:	5b d8       	cp.w	r8,-3
800083c6:	c0 55       	brlt	800083d0 <_vfprintf_r+0xa48>
800083c8:	40 2c       	lddsp	r12,sp[0x8]
800083ca:	18 38       	cp.w	r8,r12
800083cc:	e0 8a 00 6a 	brle	800084a0 <_vfprintf_r+0xb18>
800083d0:	20 20       	sub	r0,2
800083d2:	c0 58       	rjmp	800083dc <_vfprintf_r+0xa54>
800083d4:	e0 40 00 65 	cp.w	r0,101
800083d8:	e0 89 00 46 	brgt	80008464 <_vfprintf_r+0xadc>
800083dc:	fa fb 06 ac 	ld.w	r11,sp[1708]
800083e0:	fb 60 06 9c 	st.b	sp[1692],r0
800083e4:	20 1b       	sub	r11,1
800083e6:	fb 4b 06 ac 	st.w	sp[1708],r11
800083ea:	c0 47       	brpl	800083f2 <_vfprintf_r+0xa6a>
800083ec:	5c 3b       	neg	r11
800083ee:	32 d8       	mov	r8,45
800083f0:	c0 28       	rjmp	800083f4 <_vfprintf_r+0xa6c>
800083f2:	32 b8       	mov	r8,43
800083f4:	fb 68 06 9d 	st.b	sp[1693],r8
800083f8:	58 9b       	cp.w	r11,9
800083fa:	e0 8a 00 1d 	brle	80008434 <_vfprintf_r+0xaac>
800083fe:	fa c9 fa 35 	sub	r9,sp,-1483
80008402:	30 aa       	mov	r10,10
80008404:	12 98       	mov	r8,r9
80008406:	0e 9c       	mov	r12,r7
80008408:	0c 92       	mov	r2,r6
8000840a:	f6 0a 0c 06 	divs	r6,r11,r10
8000840e:	0e 9b       	mov	r11,r7
80008410:	2d 0b       	sub	r11,-48
80008412:	10 fb       	st.b	--r8,r11
80008414:	0c 9b       	mov	r11,r6
80008416:	58 96       	cp.w	r6,9
80008418:	fe 99 ff f9 	brgt	8000840a <_vfprintf_r+0xa82>
8000841c:	2d 0b       	sub	r11,-48
8000841e:	18 97       	mov	r7,r12
80008420:	04 96       	mov	r6,r2
80008422:	10 fb       	st.b	--r8,r11
80008424:	fa ca f9 62 	sub	r10,sp,-1694
80008428:	c0 38       	rjmp	8000842e <_vfprintf_r+0xaa6>
8000842a:	11 3b       	ld.ub	r11,r8++
8000842c:	14 cb       	st.b	r10++,r11
8000842e:	12 38       	cp.w	r8,r9
80008430:	cf d3       	brcs	8000842a <_vfprintf_r+0xaa2>
80008432:	c0 98       	rjmp	80008444 <_vfprintf_r+0xabc>
80008434:	2d 0b       	sub	r11,-48
80008436:	33 08       	mov	r8,48
80008438:	fb 6b 06 9f 	st.b	sp[1695],r11
8000843c:	fb 68 06 9e 	st.b	sp[1694],r8
80008440:	fa ca f9 60 	sub	r10,sp,-1696
80008444:	fa c8 f9 64 	sub	r8,sp,-1692
80008448:	f4 08 01 08 	sub	r8,r10,r8
8000844c:	50 e8       	stdsp	sp[0x38],r8
8000844e:	10 92       	mov	r2,r8
80008450:	40 6b       	lddsp	r11,sp[0x18]
80008452:	16 02       	add	r2,r11
80008454:	58 1b       	cp.w	r11,1
80008456:	e0 89 00 05 	brgt	80008460 <_vfprintf_r+0xad8>
8000845a:	ed b5 00 00 	bld	r5,0x0
8000845e:	c3 51       	brne	800084c8 <_vfprintf_r+0xb40>
80008460:	2f f2       	sub	r2,-1
80008462:	c3 38       	rjmp	800084c8 <_vfprintf_r+0xb40>
80008464:	e0 40 00 66 	cp.w	r0,102
80008468:	c1 c1       	brne	800084a0 <_vfprintf_r+0xb18>
8000846a:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000846e:	58 02       	cp.w	r2,0
80008470:	e0 8a 00 0c 	brle	80008488 <_vfprintf_r+0xb00>
80008474:	40 2a       	lddsp	r10,sp[0x8]
80008476:	58 0a       	cp.w	r10,0
80008478:	c0 41       	brne	80008480 <_vfprintf_r+0xaf8>
8000847a:	ed b5 00 00 	bld	r5,0x0
8000847e:	c2 51       	brne	800084c8 <_vfprintf_r+0xb40>
80008480:	2f f2       	sub	r2,-1
80008482:	40 29       	lddsp	r9,sp[0x8]
80008484:	12 02       	add	r2,r9
80008486:	c0 b8       	rjmp	8000849c <_vfprintf_r+0xb14>
80008488:	40 28       	lddsp	r8,sp[0x8]
8000848a:	58 08       	cp.w	r8,0
8000848c:	c0 61       	brne	80008498 <_vfprintf_r+0xb10>
8000848e:	ed b5 00 00 	bld	r5,0x0
80008492:	c0 30       	breq	80008498 <_vfprintf_r+0xb10>
80008494:	30 12       	mov	r2,1
80008496:	c1 98       	rjmp	800084c8 <_vfprintf_r+0xb40>
80008498:	40 22       	lddsp	r2,sp[0x8]
8000849a:	2f e2       	sub	r2,-2
8000849c:	36 60       	mov	r0,102
8000849e:	c1 58       	rjmp	800084c8 <_vfprintf_r+0xb40>
800084a0:	fa f2 06 ac 	ld.w	r2,sp[1708]
800084a4:	40 6e       	lddsp	lr,sp[0x18]
800084a6:	1c 32       	cp.w	r2,lr
800084a8:	c0 65       	brlt	800084b4 <_vfprintf_r+0xb2c>
800084aa:	ed b5 00 00 	bld	r5,0x0
800084ae:	f7 b2 00 ff 	subeq	r2,-1
800084b2:	c0 a8       	rjmp	800084c6 <_vfprintf_r+0xb3e>
800084b4:	e4 08 11 02 	rsub	r8,r2,2
800084b8:	40 6c       	lddsp	r12,sp[0x18]
800084ba:	58 02       	cp.w	r2,0
800084bc:	f0 02 17 a0 	movle	r2,r8
800084c0:	f9 b2 09 01 	movgt	r2,1
800084c4:	18 02       	add	r2,r12
800084c6:	36 70       	mov	r0,103
800084c8:	40 9b       	lddsp	r11,sp[0x24]
800084ca:	58 0b       	cp.w	r11,0
800084cc:	e0 80 05 94 	breq	80008ff4 <_vfprintf_r+0x166c>
800084d0:	32 d8       	mov	r8,45
800084d2:	fb 68 06 bb 	st.b	sp[1723],r8
800084d6:	e0 8f 05 93 	bral	80008ffc <_vfprintf_r+0x1674>
800084da:	50 a7       	stdsp	sp[0x28],r7
800084dc:	04 94       	mov	r4,r2
800084de:	0c 97       	mov	r7,r6
800084e0:	02 92       	mov	r2,r1
800084e2:	06 96       	mov	r6,r3
800084e4:	40 41       	lddsp	r1,sp[0x10]
800084e6:	40 93       	lddsp	r3,sp[0x24]
800084e8:	0e 99       	mov	r9,r7
800084ea:	ed b5 00 05 	bld	r5,0x5
800084ee:	c4 81       	brne	8000857e <_vfprintf_r+0xbf6>
800084f0:	fa f8 06 b4 	ld.w	r8,sp[1716]
800084f4:	40 3e       	lddsp	lr,sp[0xc]
800084f6:	58 0e       	cp.w	lr,0
800084f8:	c1 d0       	breq	80008532 <_vfprintf_r+0xbaa>
800084fa:	10 36       	cp.w	r6,r8
800084fc:	c0 64       	brge	80008508 <_vfprintf_r+0xb80>
800084fe:	fa cc f9 44 	sub	r12,sp,-1724
80008502:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008506:	c1 d8       	rjmp	80008540 <_vfprintf_r+0xbb8>
80008508:	fa c8 f9 50 	sub	r8,sp,-1712
8000850c:	1a d8       	st.w	--sp,r8
8000850e:	fa c8 fa b8 	sub	r8,sp,-1352
80008512:	04 9a       	mov	r10,r2
80008514:	1a d8       	st.w	--sp,r8
80008516:	fa c8 fb b4 	sub	r8,sp,-1100
8000851a:	0c 9b       	mov	r11,r6
8000851c:	1a d8       	st.w	--sp,r8
8000851e:	08 9c       	mov	r12,r4
80008520:	fa c8 f9 40 	sub	r8,sp,-1728
80008524:	fa c9 ff b4 	sub	r9,sp,-76
80008528:	fe b0 f8 92 	rcall	8000764c <get_arg>
8000852c:	2f dd       	sub	sp,-12
8000852e:	78 0a       	ld.w	r10,r12[0x0]
80008530:	c2 08       	rjmp	80008570 <_vfprintf_r+0xbe8>
80008532:	2f f7       	sub	r7,-1
80008534:	10 39       	cp.w	r9,r8
80008536:	c0 84       	brge	80008546 <_vfprintf_r+0xbbe>
80008538:	fa cb f9 44 	sub	r11,sp,-1724
8000853c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008540:	ec fa fd 88 	ld.w	r10,r6[-632]
80008544:	c1 68       	rjmp	80008570 <_vfprintf_r+0xbe8>
80008546:	41 09       	lddsp	r9,sp[0x40]
80008548:	59 f8       	cp.w	r8,31
8000854a:	e0 89 00 10 	brgt	8000856a <_vfprintf_r+0xbe2>
8000854e:	f2 ca ff fc 	sub	r10,r9,-4
80008552:	51 0a       	stdsp	sp[0x40],r10
80008554:	fa c6 f9 44 	sub	r6,sp,-1724
80008558:	72 0a       	ld.w	r10,r9[0x0]
8000855a:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000855e:	f3 4a fd 88 	st.w	r9[-632],r10
80008562:	2f f8       	sub	r8,-1
80008564:	fb 48 06 b4 	st.w	sp[1716],r8
80008568:	c0 48       	rjmp	80008570 <_vfprintf_r+0xbe8>
8000856a:	72 0a       	ld.w	r10,r9[0x0]
8000856c:	2f c9       	sub	r9,-4
8000856e:	51 09       	stdsp	sp[0x40],r9
80008570:	40 be       	lddsp	lr,sp[0x2c]
80008572:	1c 98       	mov	r8,lr
80008574:	95 1e       	st.w	r10[0x4],lr
80008576:	bf 58       	asr	r8,0x1f
80008578:	95 08       	st.w	r10[0x0],r8
8000857a:	fe 9f fa 92 	bral	80007a9e <_vfprintf_r+0x116>
8000857e:	ed b5 00 04 	bld	r5,0x4
80008582:	c4 80       	breq	80008612 <_vfprintf_r+0xc8a>
80008584:	e2 15 00 40 	andl	r5,0x40,COH
80008588:	c4 50       	breq	80008612 <_vfprintf_r+0xc8a>
8000858a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000858e:	40 3c       	lddsp	r12,sp[0xc]
80008590:	58 0c       	cp.w	r12,0
80008592:	c1 d0       	breq	800085cc <_vfprintf_r+0xc44>
80008594:	10 36       	cp.w	r6,r8
80008596:	c0 64       	brge	800085a2 <_vfprintf_r+0xc1a>
80008598:	fa cb f9 44 	sub	r11,sp,-1724
8000859c:	f6 06 00 36 	add	r6,r11,r6<<0x3
800085a0:	c1 d8       	rjmp	800085da <_vfprintf_r+0xc52>
800085a2:	fa c8 f9 50 	sub	r8,sp,-1712
800085a6:	1a d8       	st.w	--sp,r8
800085a8:	fa c8 fa b8 	sub	r8,sp,-1352
800085ac:	04 9a       	mov	r10,r2
800085ae:	1a d8       	st.w	--sp,r8
800085b0:	fa c8 fb b4 	sub	r8,sp,-1100
800085b4:	0c 9b       	mov	r11,r6
800085b6:	1a d8       	st.w	--sp,r8
800085b8:	08 9c       	mov	r12,r4
800085ba:	fa c8 f9 40 	sub	r8,sp,-1728
800085be:	fa c9 ff b4 	sub	r9,sp,-76
800085c2:	fe b0 f8 45 	rcall	8000764c <get_arg>
800085c6:	2f dd       	sub	sp,-12
800085c8:	78 0a       	ld.w	r10,r12[0x0]
800085ca:	c2 08       	rjmp	8000860a <_vfprintf_r+0xc82>
800085cc:	2f f7       	sub	r7,-1
800085ce:	10 39       	cp.w	r9,r8
800085d0:	c0 84       	brge	800085e0 <_vfprintf_r+0xc58>
800085d2:	fa ca f9 44 	sub	r10,sp,-1724
800085d6:	f4 06 00 36 	add	r6,r10,r6<<0x3
800085da:	ec fa fd 88 	ld.w	r10,r6[-632]
800085de:	c1 68       	rjmp	8000860a <_vfprintf_r+0xc82>
800085e0:	41 09       	lddsp	r9,sp[0x40]
800085e2:	59 f8       	cp.w	r8,31
800085e4:	e0 89 00 10 	brgt	80008604 <_vfprintf_r+0xc7c>
800085e8:	f2 ca ff fc 	sub	r10,r9,-4
800085ec:	51 0a       	stdsp	sp[0x40],r10
800085ee:	fa c6 f9 44 	sub	r6,sp,-1724
800085f2:	72 0a       	ld.w	r10,r9[0x0]
800085f4:	ec 08 00 39 	add	r9,r6,r8<<0x3
800085f8:	f3 4a fd 88 	st.w	r9[-632],r10
800085fc:	2f f8       	sub	r8,-1
800085fe:	fb 48 06 b4 	st.w	sp[1716],r8
80008602:	c0 48       	rjmp	8000860a <_vfprintf_r+0xc82>
80008604:	72 0a       	ld.w	r10,r9[0x0]
80008606:	2f c9       	sub	r9,-4
80008608:	51 09       	stdsp	sp[0x40],r9
8000860a:	40 be       	lddsp	lr,sp[0x2c]
8000860c:	b4 0e       	st.h	r10[0x0],lr
8000860e:	fe 9f fa 48 	bral	80007a9e <_vfprintf_r+0x116>
80008612:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008616:	40 3c       	lddsp	r12,sp[0xc]
80008618:	58 0c       	cp.w	r12,0
8000861a:	c1 d0       	breq	80008654 <_vfprintf_r+0xccc>
8000861c:	10 36       	cp.w	r6,r8
8000861e:	c0 64       	brge	8000862a <_vfprintf_r+0xca2>
80008620:	fa cb f9 44 	sub	r11,sp,-1724
80008624:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008628:	c1 d8       	rjmp	80008662 <_vfprintf_r+0xcda>
8000862a:	fa c8 f9 50 	sub	r8,sp,-1712
8000862e:	1a d8       	st.w	--sp,r8
80008630:	fa c8 fa b8 	sub	r8,sp,-1352
80008634:	04 9a       	mov	r10,r2
80008636:	1a d8       	st.w	--sp,r8
80008638:	fa c8 fb b4 	sub	r8,sp,-1100
8000863c:	0c 9b       	mov	r11,r6
8000863e:	1a d8       	st.w	--sp,r8
80008640:	08 9c       	mov	r12,r4
80008642:	fa c8 f9 40 	sub	r8,sp,-1728
80008646:	fa c9 ff b4 	sub	r9,sp,-76
8000864a:	fe b0 f8 01 	rcall	8000764c <get_arg>
8000864e:	2f dd       	sub	sp,-12
80008650:	78 0a       	ld.w	r10,r12[0x0]
80008652:	c2 08       	rjmp	80008692 <_vfprintf_r+0xd0a>
80008654:	2f f7       	sub	r7,-1
80008656:	10 39       	cp.w	r9,r8
80008658:	c0 84       	brge	80008668 <_vfprintf_r+0xce0>
8000865a:	fa ca f9 44 	sub	r10,sp,-1724
8000865e:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008662:	ec fa fd 88 	ld.w	r10,r6[-632]
80008666:	c1 68       	rjmp	80008692 <_vfprintf_r+0xd0a>
80008668:	41 09       	lddsp	r9,sp[0x40]
8000866a:	59 f8       	cp.w	r8,31
8000866c:	e0 89 00 10 	brgt	8000868c <_vfprintf_r+0xd04>
80008670:	f2 ca ff fc 	sub	r10,r9,-4
80008674:	51 0a       	stdsp	sp[0x40],r10
80008676:	fa c6 f9 44 	sub	r6,sp,-1724
8000867a:	72 0a       	ld.w	r10,r9[0x0]
8000867c:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008680:	f3 4a fd 88 	st.w	r9[-632],r10
80008684:	2f f8       	sub	r8,-1
80008686:	fb 48 06 b4 	st.w	sp[1716],r8
8000868a:	c0 48       	rjmp	80008692 <_vfprintf_r+0xd0a>
8000868c:	72 0a       	ld.w	r10,r9[0x0]
8000868e:	2f c9       	sub	r9,-4
80008690:	51 09       	stdsp	sp[0x40],r9
80008692:	40 be       	lddsp	lr,sp[0x2c]
80008694:	95 0e       	st.w	r10[0x0],lr
80008696:	fe 9f fa 04 	bral	80007a9e <_vfprintf_r+0x116>
8000869a:	50 a7       	stdsp	sp[0x28],r7
8000869c:	50 80       	stdsp	sp[0x20],r0
8000869e:	0c 97       	mov	r7,r6
800086a0:	04 94       	mov	r4,r2
800086a2:	06 96       	mov	r6,r3
800086a4:	02 92       	mov	r2,r1
800086a6:	40 93       	lddsp	r3,sp[0x24]
800086a8:	10 90       	mov	r0,r8
800086aa:	40 41       	lddsp	r1,sp[0x10]
800086ac:	a5 a5       	sbr	r5,0x4
800086ae:	c0 a8       	rjmp	800086c2 <_vfprintf_r+0xd3a>
800086b0:	50 a7       	stdsp	sp[0x28],r7
800086b2:	50 80       	stdsp	sp[0x20],r0
800086b4:	0c 97       	mov	r7,r6
800086b6:	04 94       	mov	r4,r2
800086b8:	06 96       	mov	r6,r3
800086ba:	02 92       	mov	r2,r1
800086bc:	40 93       	lddsp	r3,sp[0x24]
800086be:	10 90       	mov	r0,r8
800086c0:	40 41       	lddsp	r1,sp[0x10]
800086c2:	ed b5 00 05 	bld	r5,0x5
800086c6:	c5 d1       	brne	80008780 <_vfprintf_r+0xdf8>
800086c8:	fa f8 06 b4 	ld.w	r8,sp[1716]
800086cc:	40 3c       	lddsp	r12,sp[0xc]
800086ce:	58 0c       	cp.w	r12,0
800086d0:	c2 60       	breq	8000871c <_vfprintf_r+0xd94>
800086d2:	10 36       	cp.w	r6,r8
800086d4:	c0 a4       	brge	800086e8 <_vfprintf_r+0xd60>
800086d6:	fa cb f9 44 	sub	r11,sp,-1724
800086da:	f6 06 00 36 	add	r6,r11,r6<<0x3
800086de:	ec e8 fd 88 	ld.d	r8,r6[-632]
800086e2:	fa e9 00 00 	st.d	sp[0],r8
800086e6:	c1 88       	rjmp	80008716 <_vfprintf_r+0xd8e>
800086e8:	fa c8 f9 50 	sub	r8,sp,-1712
800086ec:	1a d8       	st.w	--sp,r8
800086ee:	fa c8 fa b8 	sub	r8,sp,-1352
800086f2:	04 9a       	mov	r10,r2
800086f4:	1a d8       	st.w	--sp,r8
800086f6:	0c 9b       	mov	r11,r6
800086f8:	fa c8 fb b4 	sub	r8,sp,-1100
800086fc:	08 9c       	mov	r12,r4
800086fe:	1a d8       	st.w	--sp,r8
80008700:	fa c8 f9 40 	sub	r8,sp,-1728
80008704:	fa c9 ff b4 	sub	r9,sp,-76
80008708:	fe b0 f7 a2 	rcall	8000764c <get_arg>
8000870c:	2f dd       	sub	sp,-12
8000870e:	f8 ea 00 00 	ld.d	r10,r12[0]
80008712:	fa eb 00 00 	st.d	sp[0],r10
80008716:	30 08       	mov	r8,0
80008718:	e0 8f 03 de 	bral	80008ed4 <_vfprintf_r+0x154c>
8000871c:	ee ca ff ff 	sub	r10,r7,-1
80008720:	10 37       	cp.w	r7,r8
80008722:	c0 b4       	brge	80008738 <_vfprintf_r+0xdb0>
80008724:	fa c9 f9 44 	sub	r9,sp,-1724
80008728:	14 97       	mov	r7,r10
8000872a:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000872e:	ec ea fd 88 	ld.d	r10,r6[-632]
80008732:	fa eb 00 00 	st.d	sp[0],r10
80008736:	c1 88       	rjmp	80008766 <_vfprintf_r+0xdde>
80008738:	41 09       	lddsp	r9,sp[0x40]
8000873a:	59 f8       	cp.w	r8,31
8000873c:	e0 89 00 18 	brgt	8000876c <_vfprintf_r+0xde4>
80008740:	f2 e6 00 00 	ld.d	r6,r9[0]
80008744:	f2 cb ff f8 	sub	r11,r9,-8
80008748:	fa e7 00 00 	st.d	sp[0],r6
8000874c:	51 0b       	stdsp	sp[0x40],r11
8000874e:	fa c6 f9 44 	sub	r6,sp,-1724
80008752:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008756:	fa e6 00 00 	ld.d	r6,sp[0]
8000875a:	f2 e7 fd 88 	st.d	r9[-632],r6
8000875e:	2f f8       	sub	r8,-1
80008760:	14 97       	mov	r7,r10
80008762:	fb 48 06 b4 	st.w	sp[1716],r8
80008766:	40 38       	lddsp	r8,sp[0xc]
80008768:	e0 8f 03 b6 	bral	80008ed4 <_vfprintf_r+0x154c>
8000876c:	f2 e6 00 00 	ld.d	r6,r9[0]
80008770:	40 38       	lddsp	r8,sp[0xc]
80008772:	fa e7 00 00 	st.d	sp[0],r6
80008776:	2f 89       	sub	r9,-8
80008778:	14 97       	mov	r7,r10
8000877a:	51 09       	stdsp	sp[0x40],r9
8000877c:	e0 8f 03 ac 	bral	80008ed4 <_vfprintf_r+0x154c>
80008780:	ed b5 00 04 	bld	r5,0x4
80008784:	c1 61       	brne	800087b0 <_vfprintf_r+0xe28>
80008786:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000878a:	40 3e       	lddsp	lr,sp[0xc]
8000878c:	58 0e       	cp.w	lr,0
8000878e:	c0 80       	breq	8000879e <_vfprintf_r+0xe16>
80008790:	10 36       	cp.w	r6,r8
80008792:	c6 74       	brge	80008860 <_vfprintf_r+0xed8>
80008794:	fa cc f9 44 	sub	r12,sp,-1724
80008798:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000879c:	c8 08       	rjmp	8000889c <_vfprintf_r+0xf14>
8000879e:	ee ca ff ff 	sub	r10,r7,-1
800087a2:	10 37       	cp.w	r7,r8
800087a4:	c7 f4       	brge	800088a2 <_vfprintf_r+0xf1a>
800087a6:	fa cb f9 44 	sub	r11,sp,-1724
800087aa:	f6 06 00 36 	add	r6,r11,r6<<0x3
800087ae:	c7 68       	rjmp	8000889a <_vfprintf_r+0xf12>
800087b0:	ed b5 00 06 	bld	r5,0x6
800087b4:	c4 a1       	brne	80008848 <_vfprintf_r+0xec0>
800087b6:	fa f8 06 b4 	ld.w	r8,sp[1716]
800087ba:	40 3c       	lddsp	r12,sp[0xc]
800087bc:	58 0c       	cp.w	r12,0
800087be:	c1 d0       	breq	800087f8 <_vfprintf_r+0xe70>
800087c0:	10 36       	cp.w	r6,r8
800087c2:	c0 64       	brge	800087ce <_vfprintf_r+0xe46>
800087c4:	fa cb f9 44 	sub	r11,sp,-1724
800087c8:	f6 06 00 36 	add	r6,r11,r6<<0x3
800087cc:	c1 f8       	rjmp	8000880a <_vfprintf_r+0xe82>
800087ce:	fa c8 f9 50 	sub	r8,sp,-1712
800087d2:	1a d8       	st.w	--sp,r8
800087d4:	fa c8 fa b8 	sub	r8,sp,-1352
800087d8:	1a d8       	st.w	--sp,r8
800087da:	fa c8 fb b4 	sub	r8,sp,-1100
800087de:	1a d8       	st.w	--sp,r8
800087e0:	fa c8 f9 40 	sub	r8,sp,-1728
800087e4:	fa c9 ff b4 	sub	r9,sp,-76
800087e8:	04 9a       	mov	r10,r2
800087ea:	0c 9b       	mov	r11,r6
800087ec:	08 9c       	mov	r12,r4
800087ee:	fe b0 f7 2f 	rcall	8000764c <get_arg>
800087f2:	2f dd       	sub	sp,-12
800087f4:	98 18       	ld.sh	r8,r12[0x2]
800087f6:	c2 68       	rjmp	80008842 <_vfprintf_r+0xeba>
800087f8:	ee ca ff ff 	sub	r10,r7,-1
800087fc:	10 37       	cp.w	r7,r8
800087fe:	c0 94       	brge	80008810 <_vfprintf_r+0xe88>
80008800:	fa c9 f9 44 	sub	r9,sp,-1724
80008804:	14 97       	mov	r7,r10
80008806:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000880a:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000880e:	c1 a8       	rjmp	80008842 <_vfprintf_r+0xeba>
80008810:	41 09       	lddsp	r9,sp[0x40]
80008812:	59 f8       	cp.w	r8,31
80008814:	e0 89 00 13 	brgt	8000883a <_vfprintf_r+0xeb2>
80008818:	f2 cb ff fc 	sub	r11,r9,-4
8000881c:	51 0b       	stdsp	sp[0x40],r11
8000881e:	72 09       	ld.w	r9,r9[0x0]
80008820:	fa c6 f9 44 	sub	r6,sp,-1724
80008824:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008828:	2f f8       	sub	r8,-1
8000882a:	f7 49 fd 88 	st.w	r11[-632],r9
8000882e:	fb 48 06 b4 	st.w	sp[1716],r8
80008832:	14 97       	mov	r7,r10
80008834:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008838:	c0 58       	rjmp	80008842 <_vfprintf_r+0xeba>
8000883a:	92 18       	ld.sh	r8,r9[0x2]
8000883c:	14 97       	mov	r7,r10
8000883e:	2f c9       	sub	r9,-4
80008840:	51 09       	stdsp	sp[0x40],r9
80008842:	5c 78       	castu.h	r8
80008844:	50 18       	stdsp	sp[0x4],r8
80008846:	c4 68       	rjmp	800088d2 <_vfprintf_r+0xf4a>
80008848:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000884c:	40 3c       	lddsp	r12,sp[0xc]
8000884e:	58 0c       	cp.w	r12,0
80008850:	c1 d0       	breq	8000888a <_vfprintf_r+0xf02>
80008852:	10 36       	cp.w	r6,r8
80008854:	c0 64       	brge	80008860 <_vfprintf_r+0xed8>
80008856:	fa cb f9 44 	sub	r11,sp,-1724
8000885a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000885e:	c1 f8       	rjmp	8000889c <_vfprintf_r+0xf14>
80008860:	fa c8 f9 50 	sub	r8,sp,-1712
80008864:	1a d8       	st.w	--sp,r8
80008866:	fa c8 fa b8 	sub	r8,sp,-1352
8000886a:	0c 9b       	mov	r11,r6
8000886c:	1a d8       	st.w	--sp,r8
8000886e:	fa c8 fb b4 	sub	r8,sp,-1100
80008872:	04 9a       	mov	r10,r2
80008874:	1a d8       	st.w	--sp,r8
80008876:	08 9c       	mov	r12,r4
80008878:	fa c8 f9 40 	sub	r8,sp,-1728
8000887c:	fa c9 ff b4 	sub	r9,sp,-76
80008880:	fe b0 f6 e6 	rcall	8000764c <get_arg>
80008884:	2f dd       	sub	sp,-12
80008886:	78 0b       	ld.w	r11,r12[0x0]
80008888:	c2 48       	rjmp	800088d0 <_vfprintf_r+0xf48>
8000888a:	ee ca ff ff 	sub	r10,r7,-1
8000888e:	10 37       	cp.w	r7,r8
80008890:	c0 94       	brge	800088a2 <_vfprintf_r+0xf1a>
80008892:	fa c9 f9 44 	sub	r9,sp,-1724
80008896:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000889a:	14 97       	mov	r7,r10
8000889c:	ec fb fd 88 	ld.w	r11,r6[-632]
800088a0:	c1 88       	rjmp	800088d0 <_vfprintf_r+0xf48>
800088a2:	41 09       	lddsp	r9,sp[0x40]
800088a4:	59 f8       	cp.w	r8,31
800088a6:	e0 89 00 11 	brgt	800088c8 <_vfprintf_r+0xf40>
800088aa:	f2 cb ff fc 	sub	r11,r9,-4
800088ae:	51 0b       	stdsp	sp[0x40],r11
800088b0:	fa c6 f9 44 	sub	r6,sp,-1724
800088b4:	72 0b       	ld.w	r11,r9[0x0]
800088b6:	ec 08 00 39 	add	r9,r6,r8<<0x3
800088ba:	f3 4b fd 88 	st.w	r9[-632],r11
800088be:	2f f8       	sub	r8,-1
800088c0:	14 97       	mov	r7,r10
800088c2:	fb 48 06 b4 	st.w	sp[1716],r8
800088c6:	c0 58       	rjmp	800088d0 <_vfprintf_r+0xf48>
800088c8:	72 0b       	ld.w	r11,r9[0x0]
800088ca:	14 97       	mov	r7,r10
800088cc:	2f c9       	sub	r9,-4
800088ce:	51 09       	stdsp	sp[0x40],r9
800088d0:	50 1b       	stdsp	sp[0x4],r11
800088d2:	30 0e       	mov	lr,0
800088d4:	50 0e       	stdsp	sp[0x0],lr
800088d6:	1c 98       	mov	r8,lr
800088d8:	e0 8f 02 fe 	bral	80008ed4 <_vfprintf_r+0x154c>
800088dc:	50 a7       	stdsp	sp[0x28],r7
800088de:	50 80       	stdsp	sp[0x20],r0
800088e0:	0c 97       	mov	r7,r6
800088e2:	04 94       	mov	r4,r2
800088e4:	06 96       	mov	r6,r3
800088e6:	02 92       	mov	r2,r1
800088e8:	40 93       	lddsp	r3,sp[0x24]
800088ea:	40 41       	lddsp	r1,sp[0x10]
800088ec:	0e 99       	mov	r9,r7
800088ee:	fa f8 06 b4 	ld.w	r8,sp[1716]
800088f2:	40 3c       	lddsp	r12,sp[0xc]
800088f4:	58 0c       	cp.w	r12,0
800088f6:	c1 d0       	breq	80008930 <_vfprintf_r+0xfa8>
800088f8:	10 36       	cp.w	r6,r8
800088fa:	c0 64       	brge	80008906 <_vfprintf_r+0xf7e>
800088fc:	fa cb f9 44 	sub	r11,sp,-1724
80008900:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008904:	c1 d8       	rjmp	8000893e <_vfprintf_r+0xfb6>
80008906:	fa c8 f9 50 	sub	r8,sp,-1712
8000890a:	1a d8       	st.w	--sp,r8
8000890c:	fa c8 fa b8 	sub	r8,sp,-1352
80008910:	1a d8       	st.w	--sp,r8
80008912:	fa c8 fb b4 	sub	r8,sp,-1100
80008916:	1a d8       	st.w	--sp,r8
80008918:	fa c9 ff b4 	sub	r9,sp,-76
8000891c:	fa c8 f9 40 	sub	r8,sp,-1728
80008920:	04 9a       	mov	r10,r2
80008922:	0c 9b       	mov	r11,r6
80008924:	08 9c       	mov	r12,r4
80008926:	fe b0 f6 93 	rcall	8000764c <get_arg>
8000892a:	2f dd       	sub	sp,-12
8000892c:	78 09       	ld.w	r9,r12[0x0]
8000892e:	c2 18       	rjmp	80008970 <_vfprintf_r+0xfe8>
80008930:	2f f7       	sub	r7,-1
80008932:	10 39       	cp.w	r9,r8
80008934:	c0 84       	brge	80008944 <_vfprintf_r+0xfbc>
80008936:	fa ca f9 44 	sub	r10,sp,-1724
8000893a:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000893e:	ec f9 fd 88 	ld.w	r9,r6[-632]
80008942:	c1 78       	rjmp	80008970 <_vfprintf_r+0xfe8>
80008944:	41 09       	lddsp	r9,sp[0x40]
80008946:	59 f8       	cp.w	r8,31
80008948:	e0 89 00 10 	brgt	80008968 <_vfprintf_r+0xfe0>
8000894c:	f2 ca ff fc 	sub	r10,r9,-4
80008950:	51 0a       	stdsp	sp[0x40],r10
80008952:	fa c6 f9 44 	sub	r6,sp,-1724
80008956:	72 09       	ld.w	r9,r9[0x0]
80008958:	ec 08 00 3a 	add	r10,r6,r8<<0x3
8000895c:	f5 49 fd 88 	st.w	r10[-632],r9
80008960:	2f f8       	sub	r8,-1
80008962:	fb 48 06 b4 	st.w	sp[1716],r8
80008966:	c0 58       	rjmp	80008970 <_vfprintf_r+0xfe8>
80008968:	f2 c8 ff fc 	sub	r8,r9,-4
8000896c:	51 08       	stdsp	sp[0x40],r8
8000896e:	72 09       	ld.w	r9,r9[0x0]
80008970:	33 08       	mov	r8,48
80008972:	fb 68 06 b8 	st.b	sp[1720],r8
80008976:	37 88       	mov	r8,120
80008978:	30 0e       	mov	lr,0
8000897a:	fb 68 06 b9 	st.b	sp[1721],r8
8000897e:	4c ac       	lddpc	r12,80008aa4 <_vfprintf_r+0x111c>
80008980:	50 19       	stdsp	sp[0x4],r9
80008982:	a1 b5       	sbr	r5,0x1
80008984:	50 0e       	stdsp	sp[0x0],lr
80008986:	50 dc       	stdsp	sp[0x34],r12
80008988:	30 28       	mov	r8,2
8000898a:	37 80       	mov	r0,120
8000898c:	e0 8f 02 a4 	bral	80008ed4 <_vfprintf_r+0x154c>
80008990:	50 a7       	stdsp	sp[0x28],r7
80008992:	50 80       	stdsp	sp[0x20],r0
80008994:	10 90       	mov	r0,r8
80008996:	30 08       	mov	r8,0
80008998:	fb 68 06 bb 	st.b	sp[1723],r8
8000899c:	0c 97       	mov	r7,r6
8000899e:	04 94       	mov	r4,r2
800089a0:	06 96       	mov	r6,r3
800089a2:	02 92       	mov	r2,r1
800089a4:	40 93       	lddsp	r3,sp[0x24]
800089a6:	40 41       	lddsp	r1,sp[0x10]
800089a8:	0e 99       	mov	r9,r7
800089aa:	fa f8 06 b4 	ld.w	r8,sp[1716]
800089ae:	40 3b       	lddsp	r11,sp[0xc]
800089b0:	58 0b       	cp.w	r11,0
800089b2:	c1 d0       	breq	800089ec <_vfprintf_r+0x1064>
800089b4:	10 36       	cp.w	r6,r8
800089b6:	c0 64       	brge	800089c2 <_vfprintf_r+0x103a>
800089b8:	fa ca f9 44 	sub	r10,sp,-1724
800089bc:	f4 06 00 36 	add	r6,r10,r6<<0x3
800089c0:	c1 d8       	rjmp	800089fa <_vfprintf_r+0x1072>
800089c2:	fa c8 f9 50 	sub	r8,sp,-1712
800089c6:	1a d8       	st.w	--sp,r8
800089c8:	fa c8 fa b8 	sub	r8,sp,-1352
800089cc:	1a d8       	st.w	--sp,r8
800089ce:	fa c8 fb b4 	sub	r8,sp,-1100
800089d2:	0c 9b       	mov	r11,r6
800089d4:	1a d8       	st.w	--sp,r8
800089d6:	04 9a       	mov	r10,r2
800089d8:	fa c8 f9 40 	sub	r8,sp,-1728
800089dc:	fa c9 ff b4 	sub	r9,sp,-76
800089e0:	08 9c       	mov	r12,r4
800089e2:	fe b0 f6 35 	rcall	8000764c <get_arg>
800089e6:	2f dd       	sub	sp,-12
800089e8:	78 06       	ld.w	r6,r12[0x0]
800089ea:	c2 08       	rjmp	80008a2a <_vfprintf_r+0x10a2>
800089ec:	2f f7       	sub	r7,-1
800089ee:	10 39       	cp.w	r9,r8
800089f0:	c0 84       	brge	80008a00 <_vfprintf_r+0x1078>
800089f2:	fa c9 f9 44 	sub	r9,sp,-1724
800089f6:	f2 06 00 36 	add	r6,r9,r6<<0x3
800089fa:	ec f6 fd 88 	ld.w	r6,r6[-632]
800089fe:	c1 68       	rjmp	80008a2a <_vfprintf_r+0x10a2>
80008a00:	41 09       	lddsp	r9,sp[0x40]
80008a02:	59 f8       	cp.w	r8,31
80008a04:	e0 89 00 10 	brgt	80008a24 <_vfprintf_r+0x109c>
80008a08:	f2 ca ff fc 	sub	r10,r9,-4
80008a0c:	51 0a       	stdsp	sp[0x40],r10
80008a0e:	72 06       	ld.w	r6,r9[0x0]
80008a10:	fa ce f9 44 	sub	lr,sp,-1724
80008a14:	fc 08 00 39 	add	r9,lr,r8<<0x3
80008a18:	f3 46 fd 88 	st.w	r9[-632],r6
80008a1c:	2f f8       	sub	r8,-1
80008a1e:	fb 48 06 b4 	st.w	sp[1716],r8
80008a22:	c0 48       	rjmp	80008a2a <_vfprintf_r+0x10a2>
80008a24:	72 06       	ld.w	r6,r9[0x0]
80008a26:	2f c9       	sub	r9,-4
80008a28:	51 09       	stdsp	sp[0x40],r9
80008a2a:	40 2c       	lddsp	r12,sp[0x8]
80008a2c:	58 0c       	cp.w	r12,0
80008a2e:	c1 05       	brlt	80008a4e <_vfprintf_r+0x10c6>
80008a30:	18 9a       	mov	r10,r12
80008a32:	30 0b       	mov	r11,0
80008a34:	0c 9c       	mov	r12,r6
80008a36:	e0 a0 12 43 	rcall	8000aebc <memchr>
80008a3a:	e0 80 02 e0 	breq	80008ffa <_vfprintf_r+0x1672>
80008a3e:	f8 06 01 02 	sub	r2,r12,r6
80008a42:	40 2b       	lddsp	r11,sp[0x8]
80008a44:	16 32       	cp.w	r2,r11
80008a46:	e0 89 02 da 	brgt	80008ffa <_vfprintf_r+0x1672>
80008a4a:	e0 8f 02 d5 	bral	80008ff4 <_vfprintf_r+0x166c>
80008a4e:	30 0a       	mov	r10,0
80008a50:	0c 9c       	mov	r12,r6
80008a52:	50 2a       	stdsp	sp[0x8],r10
80008a54:	fe b0 f5 77 	rcall	80007542 <strlen>
80008a58:	18 92       	mov	r2,r12
80008a5a:	e0 8f 02 d3 	bral	80009000 <_vfprintf_r+0x1678>
80008a5e:	50 a7       	stdsp	sp[0x28],r7
80008a60:	50 80       	stdsp	sp[0x20],r0
80008a62:	0c 97       	mov	r7,r6
80008a64:	04 94       	mov	r4,r2
80008a66:	06 96       	mov	r6,r3
80008a68:	02 92       	mov	r2,r1
80008a6a:	40 93       	lddsp	r3,sp[0x24]
80008a6c:	10 90       	mov	r0,r8
80008a6e:	40 41       	lddsp	r1,sp[0x10]
80008a70:	a5 a5       	sbr	r5,0x4
80008a72:	c0 a8       	rjmp	80008a86 <_vfprintf_r+0x10fe>
80008a74:	50 a7       	stdsp	sp[0x28],r7
80008a76:	50 80       	stdsp	sp[0x20],r0
80008a78:	0c 97       	mov	r7,r6
80008a7a:	04 94       	mov	r4,r2
80008a7c:	06 96       	mov	r6,r3
80008a7e:	02 92       	mov	r2,r1
80008a80:	40 93       	lddsp	r3,sp[0x24]
80008a82:	10 90       	mov	r0,r8
80008a84:	40 41       	lddsp	r1,sp[0x10]
80008a86:	ed b5 00 05 	bld	r5,0x5
80008a8a:	c5 71       	brne	80008b38 <_vfprintf_r+0x11b0>
80008a8c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008a90:	40 39       	lddsp	r9,sp[0xc]
80008a92:	58 09       	cp.w	r9,0
80008a94:	c2 20       	breq	80008ad8 <_vfprintf_r+0x1150>
80008a96:	10 36       	cp.w	r6,r8
80008a98:	c0 84       	brge	80008aa8 <_vfprintf_r+0x1120>
80008a9a:	fa c8 f9 44 	sub	r8,sp,-1724
80008a9e:	f0 06 00 36 	add	r6,r8,r6<<0x3
80008aa2:	c2 48       	rjmp	80008aea <_vfprintf_r+0x1162>
80008aa4:	80 01       	ld.sh	r1,r0[0x0]
80008aa6:	60 98       	ld.w	r8,r0[0x24]
80008aa8:	fa c8 f9 50 	sub	r8,sp,-1712
80008aac:	1a d8       	st.w	--sp,r8
80008aae:	fa c8 fa b8 	sub	r8,sp,-1352
80008ab2:	1a d8       	st.w	--sp,r8
80008ab4:	fa c8 fb b4 	sub	r8,sp,-1100
80008ab8:	1a d8       	st.w	--sp,r8
80008aba:	fa c8 f9 40 	sub	r8,sp,-1728
80008abe:	fa c9 ff b4 	sub	r9,sp,-76
80008ac2:	04 9a       	mov	r10,r2
80008ac4:	0c 9b       	mov	r11,r6
80008ac6:	08 9c       	mov	r12,r4
80008ac8:	fe b0 f5 c2 	rcall	8000764c <get_arg>
80008acc:	2f dd       	sub	sp,-12
80008ace:	f8 e8 00 00 	ld.d	r8,r12[0]
80008ad2:	fa e9 00 00 	st.d	sp[0],r8
80008ad6:	c2 e8       	rjmp	80008b32 <_vfprintf_r+0x11aa>
80008ad8:	ee ca ff ff 	sub	r10,r7,-1
80008adc:	10 37       	cp.w	r7,r8
80008ade:	c0 b4       	brge	80008af4 <_vfprintf_r+0x116c>
80008ae0:	fa c8 f9 44 	sub	r8,sp,-1724
80008ae4:	14 97       	mov	r7,r10
80008ae6:	f0 06 00 36 	add	r6,r8,r6<<0x3
80008aea:	ec ea fd 88 	ld.d	r10,r6[-632]
80008aee:	fa eb 00 00 	st.d	sp[0],r10
80008af2:	c2 08       	rjmp	80008b32 <_vfprintf_r+0x11aa>
80008af4:	41 09       	lddsp	r9,sp[0x40]
80008af6:	59 f8       	cp.w	r8,31
80008af8:	e0 89 00 16 	brgt	80008b24 <_vfprintf_r+0x119c>
80008afc:	f2 e6 00 00 	ld.d	r6,r9[0]
80008b00:	f2 cb ff f8 	sub	r11,r9,-8
80008b04:	fa e7 00 00 	st.d	sp[0],r6
80008b08:	51 0b       	stdsp	sp[0x40],r11
80008b0a:	fa c6 f9 44 	sub	r6,sp,-1724
80008b0e:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008b12:	fa e6 00 00 	ld.d	r6,sp[0]
80008b16:	f2 e7 fd 88 	st.d	r9[-632],r6
80008b1a:	2f f8       	sub	r8,-1
80008b1c:	14 97       	mov	r7,r10
80008b1e:	fb 48 06 b4 	st.w	sp[1716],r8
80008b22:	c0 88       	rjmp	80008b32 <_vfprintf_r+0x11aa>
80008b24:	f2 e6 00 00 	ld.d	r6,r9[0]
80008b28:	2f 89       	sub	r9,-8
80008b2a:	fa e7 00 00 	st.d	sp[0],r6
80008b2e:	51 09       	stdsp	sp[0x40],r9
80008b30:	14 97       	mov	r7,r10
80008b32:	30 18       	mov	r8,1
80008b34:	e0 8f 01 d0 	bral	80008ed4 <_vfprintf_r+0x154c>
80008b38:	ed b5 00 04 	bld	r5,0x4
80008b3c:	c1 61       	brne	80008b68 <_vfprintf_r+0x11e0>
80008b3e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008b42:	40 3e       	lddsp	lr,sp[0xc]
80008b44:	58 0e       	cp.w	lr,0
80008b46:	c0 80       	breq	80008b56 <_vfprintf_r+0x11ce>
80008b48:	10 36       	cp.w	r6,r8
80008b4a:	c6 74       	brge	80008c18 <_vfprintf_r+0x1290>
80008b4c:	fa cc f9 44 	sub	r12,sp,-1724
80008b50:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008b54:	c8 08       	rjmp	80008c54 <_vfprintf_r+0x12cc>
80008b56:	ee ca ff ff 	sub	r10,r7,-1
80008b5a:	10 37       	cp.w	r7,r8
80008b5c:	c7 f4       	brge	80008c5a <_vfprintf_r+0x12d2>
80008b5e:	fa cb f9 44 	sub	r11,sp,-1724
80008b62:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008b66:	c7 68       	rjmp	80008c52 <_vfprintf_r+0x12ca>
80008b68:	ed b5 00 06 	bld	r5,0x6
80008b6c:	c4 a1       	brne	80008c00 <_vfprintf_r+0x1278>
80008b6e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008b72:	40 3c       	lddsp	r12,sp[0xc]
80008b74:	58 0c       	cp.w	r12,0
80008b76:	c1 d0       	breq	80008bb0 <_vfprintf_r+0x1228>
80008b78:	10 36       	cp.w	r6,r8
80008b7a:	c0 64       	brge	80008b86 <_vfprintf_r+0x11fe>
80008b7c:	fa cb f9 44 	sub	r11,sp,-1724
80008b80:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008b84:	c1 f8       	rjmp	80008bc2 <_vfprintf_r+0x123a>
80008b86:	fa c8 f9 50 	sub	r8,sp,-1712
80008b8a:	1a d8       	st.w	--sp,r8
80008b8c:	fa c8 fa b8 	sub	r8,sp,-1352
80008b90:	1a d8       	st.w	--sp,r8
80008b92:	fa c8 fb b4 	sub	r8,sp,-1100
80008b96:	1a d8       	st.w	--sp,r8
80008b98:	fa c8 f9 40 	sub	r8,sp,-1728
80008b9c:	fa c9 ff b4 	sub	r9,sp,-76
80008ba0:	04 9a       	mov	r10,r2
80008ba2:	0c 9b       	mov	r11,r6
80008ba4:	08 9c       	mov	r12,r4
80008ba6:	fe b0 f5 53 	rcall	8000764c <get_arg>
80008baa:	2f dd       	sub	sp,-12
80008bac:	98 18       	ld.sh	r8,r12[0x2]
80008bae:	c2 68       	rjmp	80008bfa <_vfprintf_r+0x1272>
80008bb0:	ee ca ff ff 	sub	r10,r7,-1
80008bb4:	10 37       	cp.w	r7,r8
80008bb6:	c0 94       	brge	80008bc8 <_vfprintf_r+0x1240>
80008bb8:	fa c9 f9 44 	sub	r9,sp,-1724
80008bbc:	14 97       	mov	r7,r10
80008bbe:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008bc2:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80008bc6:	c1 a8       	rjmp	80008bfa <_vfprintf_r+0x1272>
80008bc8:	41 09       	lddsp	r9,sp[0x40]
80008bca:	59 f8       	cp.w	r8,31
80008bcc:	e0 89 00 13 	brgt	80008bf2 <_vfprintf_r+0x126a>
80008bd0:	f2 cb ff fc 	sub	r11,r9,-4
80008bd4:	51 0b       	stdsp	sp[0x40],r11
80008bd6:	72 09       	ld.w	r9,r9[0x0]
80008bd8:	fa c6 f9 44 	sub	r6,sp,-1724
80008bdc:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008be0:	2f f8       	sub	r8,-1
80008be2:	f7 49 fd 88 	st.w	r11[-632],r9
80008be6:	fb 48 06 b4 	st.w	sp[1716],r8
80008bea:	14 97       	mov	r7,r10
80008bec:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008bf0:	c0 58       	rjmp	80008bfa <_vfprintf_r+0x1272>
80008bf2:	92 18       	ld.sh	r8,r9[0x2]
80008bf4:	14 97       	mov	r7,r10
80008bf6:	2f c9       	sub	r9,-4
80008bf8:	51 09       	stdsp	sp[0x40],r9
80008bfa:	5c 78       	castu.h	r8
80008bfc:	50 18       	stdsp	sp[0x4],r8
80008bfe:	c4 68       	rjmp	80008c8a <_vfprintf_r+0x1302>
80008c00:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008c04:	40 3c       	lddsp	r12,sp[0xc]
80008c06:	58 0c       	cp.w	r12,0
80008c08:	c1 d0       	breq	80008c42 <_vfprintf_r+0x12ba>
80008c0a:	10 36       	cp.w	r6,r8
80008c0c:	c0 64       	brge	80008c18 <_vfprintf_r+0x1290>
80008c0e:	fa cb f9 44 	sub	r11,sp,-1724
80008c12:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008c16:	c1 f8       	rjmp	80008c54 <_vfprintf_r+0x12cc>
80008c18:	fa c8 f9 50 	sub	r8,sp,-1712
80008c1c:	1a d8       	st.w	--sp,r8
80008c1e:	fa c8 fa b8 	sub	r8,sp,-1352
80008c22:	0c 9b       	mov	r11,r6
80008c24:	1a d8       	st.w	--sp,r8
80008c26:	fa c8 fb b4 	sub	r8,sp,-1100
80008c2a:	04 9a       	mov	r10,r2
80008c2c:	1a d8       	st.w	--sp,r8
80008c2e:	08 9c       	mov	r12,r4
80008c30:	fa c8 f9 40 	sub	r8,sp,-1728
80008c34:	fa c9 ff b4 	sub	r9,sp,-76
80008c38:	fe b0 f5 0a 	rcall	8000764c <get_arg>
80008c3c:	2f dd       	sub	sp,-12
80008c3e:	78 0b       	ld.w	r11,r12[0x0]
80008c40:	c2 48       	rjmp	80008c88 <_vfprintf_r+0x1300>
80008c42:	ee ca ff ff 	sub	r10,r7,-1
80008c46:	10 37       	cp.w	r7,r8
80008c48:	c0 94       	brge	80008c5a <_vfprintf_r+0x12d2>
80008c4a:	fa c9 f9 44 	sub	r9,sp,-1724
80008c4e:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008c52:	14 97       	mov	r7,r10
80008c54:	ec fb fd 88 	ld.w	r11,r6[-632]
80008c58:	c1 88       	rjmp	80008c88 <_vfprintf_r+0x1300>
80008c5a:	41 09       	lddsp	r9,sp[0x40]
80008c5c:	59 f8       	cp.w	r8,31
80008c5e:	e0 89 00 11 	brgt	80008c80 <_vfprintf_r+0x12f8>
80008c62:	f2 cb ff fc 	sub	r11,r9,-4
80008c66:	51 0b       	stdsp	sp[0x40],r11
80008c68:	fa c6 f9 44 	sub	r6,sp,-1724
80008c6c:	72 0b       	ld.w	r11,r9[0x0]
80008c6e:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008c72:	f3 4b fd 88 	st.w	r9[-632],r11
80008c76:	2f f8       	sub	r8,-1
80008c78:	14 97       	mov	r7,r10
80008c7a:	fb 48 06 b4 	st.w	sp[1716],r8
80008c7e:	c0 58       	rjmp	80008c88 <_vfprintf_r+0x1300>
80008c80:	72 0b       	ld.w	r11,r9[0x0]
80008c82:	14 97       	mov	r7,r10
80008c84:	2f c9       	sub	r9,-4
80008c86:	51 09       	stdsp	sp[0x40],r9
80008c88:	50 1b       	stdsp	sp[0x4],r11
80008c8a:	30 0e       	mov	lr,0
80008c8c:	30 18       	mov	r8,1
80008c8e:	50 0e       	stdsp	sp[0x0],lr
80008c90:	c2 29       	rjmp	80008ed4 <_vfprintf_r+0x154c>
80008c92:	50 a7       	stdsp	sp[0x28],r7
80008c94:	50 80       	stdsp	sp[0x20],r0
80008c96:	0c 97       	mov	r7,r6
80008c98:	04 94       	mov	r4,r2
80008c9a:	06 96       	mov	r6,r3
80008c9c:	02 92       	mov	r2,r1
80008c9e:	4d 3c       	lddpc	r12,80008de8 <_vfprintf_r+0x1460>
80008ca0:	40 93       	lddsp	r3,sp[0x24]
80008ca2:	10 90       	mov	r0,r8
80008ca4:	40 41       	lddsp	r1,sp[0x10]
80008ca6:	50 dc       	stdsp	sp[0x34],r12
80008ca8:	ed b5 00 05 	bld	r5,0x5
80008cac:	c5 51       	brne	80008d56 <_vfprintf_r+0x13ce>
80008cae:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008cb2:	40 3b       	lddsp	r11,sp[0xc]
80008cb4:	58 0b       	cp.w	r11,0
80008cb6:	c2 20       	breq	80008cfa <_vfprintf_r+0x1372>
80008cb8:	10 36       	cp.w	r6,r8
80008cba:	c0 a4       	brge	80008cce <_vfprintf_r+0x1346>
80008cbc:	fa ca f9 44 	sub	r10,sp,-1724
80008cc0:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008cc4:	ec e8 fd 88 	ld.d	r8,r6[-632]
80008cc8:	fa e9 00 00 	st.d	sp[0],r8
80008ccc:	cf 38       	rjmp	80008eb2 <_vfprintf_r+0x152a>
80008cce:	fa c8 f9 50 	sub	r8,sp,-1712
80008cd2:	1a d8       	st.w	--sp,r8
80008cd4:	fa c8 fa b8 	sub	r8,sp,-1352
80008cd8:	04 9a       	mov	r10,r2
80008cda:	1a d8       	st.w	--sp,r8
80008cdc:	0c 9b       	mov	r11,r6
80008cde:	fa c8 fb b4 	sub	r8,sp,-1100
80008ce2:	08 9c       	mov	r12,r4
80008ce4:	1a d8       	st.w	--sp,r8
80008ce6:	fa c8 f9 40 	sub	r8,sp,-1728
80008cea:	fa c9 ff b4 	sub	r9,sp,-76
80008cee:	fe b0 f4 af 	rcall	8000764c <get_arg>
80008cf2:	2f dd       	sub	sp,-12
80008cf4:	f8 ea 00 00 	ld.d	r10,r12[0]
80008cf8:	c0 c8       	rjmp	80008d10 <_vfprintf_r+0x1388>
80008cfa:	ee ca ff ff 	sub	r10,r7,-1
80008cfe:	10 37       	cp.w	r7,r8
80008d00:	c0 b4       	brge	80008d16 <_vfprintf_r+0x138e>
80008d02:	fa c9 f9 44 	sub	r9,sp,-1724
80008d06:	14 97       	mov	r7,r10
80008d08:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008d0c:	ec ea fd 88 	ld.d	r10,r6[-632]
80008d10:	fa eb 00 00 	st.d	sp[0],r10
80008d14:	cc f8       	rjmp	80008eb2 <_vfprintf_r+0x152a>
80008d16:	41 09       	lddsp	r9,sp[0x40]
80008d18:	59 f8       	cp.w	r8,31
80008d1a:	e0 89 00 16 	brgt	80008d46 <_vfprintf_r+0x13be>
80008d1e:	f2 e6 00 00 	ld.d	r6,r9[0]
80008d22:	f2 cb ff f8 	sub	r11,r9,-8
80008d26:	fa e7 00 00 	st.d	sp[0],r6
80008d2a:	51 0b       	stdsp	sp[0x40],r11
80008d2c:	fa c6 f9 44 	sub	r6,sp,-1724
80008d30:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008d34:	fa e6 00 00 	ld.d	r6,sp[0]
80008d38:	f2 e7 fd 88 	st.d	r9[-632],r6
80008d3c:	2f f8       	sub	r8,-1
80008d3e:	14 97       	mov	r7,r10
80008d40:	fb 48 06 b4 	st.w	sp[1716],r8
80008d44:	cb 78       	rjmp	80008eb2 <_vfprintf_r+0x152a>
80008d46:	f2 e6 00 00 	ld.d	r6,r9[0]
80008d4a:	2f 89       	sub	r9,-8
80008d4c:	fa e7 00 00 	st.d	sp[0],r6
80008d50:	51 09       	stdsp	sp[0x40],r9
80008d52:	14 97       	mov	r7,r10
80008d54:	ca f8       	rjmp	80008eb2 <_vfprintf_r+0x152a>
80008d56:	ed b5 00 04 	bld	r5,0x4
80008d5a:	c1 71       	brne	80008d88 <_vfprintf_r+0x1400>
80008d5c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008d60:	40 3e       	lddsp	lr,sp[0xc]
80008d62:	58 0e       	cp.w	lr,0
80008d64:	c0 80       	breq	80008d74 <_vfprintf_r+0x13ec>
80008d66:	10 36       	cp.w	r6,r8
80008d68:	c6 a4       	brge	80008e3c <_vfprintf_r+0x14b4>
80008d6a:	fa cc f9 44 	sub	r12,sp,-1724
80008d6e:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008d72:	c8 38       	rjmp	80008e78 <_vfprintf_r+0x14f0>
80008d74:	ee ca ff ff 	sub	r10,r7,-1
80008d78:	10 37       	cp.w	r7,r8
80008d7a:	e0 84 00 82 	brge	80008e7e <_vfprintf_r+0x14f6>
80008d7e:	fa cb f9 44 	sub	r11,sp,-1724
80008d82:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008d86:	c7 88       	rjmp	80008e76 <_vfprintf_r+0x14ee>
80008d88:	ed b5 00 06 	bld	r5,0x6
80008d8c:	c4 c1       	brne	80008e24 <_vfprintf_r+0x149c>
80008d8e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008d92:	40 3c       	lddsp	r12,sp[0xc]
80008d94:	58 0c       	cp.w	r12,0
80008d96:	c1 d0       	breq	80008dd0 <_vfprintf_r+0x1448>
80008d98:	10 36       	cp.w	r6,r8
80008d9a:	c0 64       	brge	80008da6 <_vfprintf_r+0x141e>
80008d9c:	fa cb f9 44 	sub	r11,sp,-1724
80008da0:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008da4:	c1 f8       	rjmp	80008de2 <_vfprintf_r+0x145a>
80008da6:	fa c8 f9 50 	sub	r8,sp,-1712
80008daa:	1a d8       	st.w	--sp,r8
80008dac:	fa c8 fa b8 	sub	r8,sp,-1352
80008db0:	1a d8       	st.w	--sp,r8
80008db2:	fa c8 fb b4 	sub	r8,sp,-1100
80008db6:	1a d8       	st.w	--sp,r8
80008db8:	fa c8 f9 40 	sub	r8,sp,-1728
80008dbc:	fa c9 ff b4 	sub	r9,sp,-76
80008dc0:	04 9a       	mov	r10,r2
80008dc2:	0c 9b       	mov	r11,r6
80008dc4:	08 9c       	mov	r12,r4
80008dc6:	fe b0 f4 43 	rcall	8000764c <get_arg>
80008dca:	2f dd       	sub	sp,-12
80008dcc:	98 18       	ld.sh	r8,r12[0x2]
80008dce:	c2 88       	rjmp	80008e1e <_vfprintf_r+0x1496>
80008dd0:	ee ca ff ff 	sub	r10,r7,-1
80008dd4:	10 37       	cp.w	r7,r8
80008dd6:	c0 b4       	brge	80008dec <_vfprintf_r+0x1464>
80008dd8:	fa c9 f9 44 	sub	r9,sp,-1724
80008ddc:	14 97       	mov	r7,r10
80008dde:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008de2:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80008de6:	c1 c8       	rjmp	80008e1e <_vfprintf_r+0x1496>
80008de8:	80 01       	ld.sh	r1,r0[0x0]
80008dea:	60 98       	ld.w	r8,r0[0x24]
80008dec:	41 09       	lddsp	r9,sp[0x40]
80008dee:	59 f8       	cp.w	r8,31
80008df0:	e0 89 00 13 	brgt	80008e16 <_vfprintf_r+0x148e>
80008df4:	f2 cb ff fc 	sub	r11,r9,-4
80008df8:	51 0b       	stdsp	sp[0x40],r11
80008dfa:	72 09       	ld.w	r9,r9[0x0]
80008dfc:	fa c6 f9 44 	sub	r6,sp,-1724
80008e00:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008e04:	2f f8       	sub	r8,-1
80008e06:	f7 49 fd 88 	st.w	r11[-632],r9
80008e0a:	fb 48 06 b4 	st.w	sp[1716],r8
80008e0e:	14 97       	mov	r7,r10
80008e10:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008e14:	c0 58       	rjmp	80008e1e <_vfprintf_r+0x1496>
80008e16:	92 18       	ld.sh	r8,r9[0x2]
80008e18:	14 97       	mov	r7,r10
80008e1a:	2f c9       	sub	r9,-4
80008e1c:	51 09       	stdsp	sp[0x40],r9
80008e1e:	5c 78       	castu.h	r8
80008e20:	50 18       	stdsp	sp[0x4],r8
80008e22:	c4 68       	rjmp	80008eae <_vfprintf_r+0x1526>
80008e24:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008e28:	40 3c       	lddsp	r12,sp[0xc]
80008e2a:	58 0c       	cp.w	r12,0
80008e2c:	c1 d0       	breq	80008e66 <_vfprintf_r+0x14de>
80008e2e:	10 36       	cp.w	r6,r8
80008e30:	c0 64       	brge	80008e3c <_vfprintf_r+0x14b4>
80008e32:	fa cb f9 44 	sub	r11,sp,-1724
80008e36:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008e3a:	c1 f8       	rjmp	80008e78 <_vfprintf_r+0x14f0>
80008e3c:	fa c8 f9 50 	sub	r8,sp,-1712
80008e40:	1a d8       	st.w	--sp,r8
80008e42:	fa c8 fa b8 	sub	r8,sp,-1352
80008e46:	0c 9b       	mov	r11,r6
80008e48:	1a d8       	st.w	--sp,r8
80008e4a:	fa c8 fb b4 	sub	r8,sp,-1100
80008e4e:	04 9a       	mov	r10,r2
80008e50:	1a d8       	st.w	--sp,r8
80008e52:	08 9c       	mov	r12,r4
80008e54:	fa c8 f9 40 	sub	r8,sp,-1728
80008e58:	fa c9 ff b4 	sub	r9,sp,-76
80008e5c:	fe b0 f3 f8 	rcall	8000764c <get_arg>
80008e60:	2f dd       	sub	sp,-12
80008e62:	78 0b       	ld.w	r11,r12[0x0]
80008e64:	c2 48       	rjmp	80008eac <_vfprintf_r+0x1524>
80008e66:	ee ca ff ff 	sub	r10,r7,-1
80008e6a:	10 37       	cp.w	r7,r8
80008e6c:	c0 94       	brge	80008e7e <_vfprintf_r+0x14f6>
80008e6e:	fa c9 f9 44 	sub	r9,sp,-1724
80008e72:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008e76:	14 97       	mov	r7,r10
80008e78:	ec fb fd 88 	ld.w	r11,r6[-632]
80008e7c:	c1 88       	rjmp	80008eac <_vfprintf_r+0x1524>
80008e7e:	41 09       	lddsp	r9,sp[0x40]
80008e80:	59 f8       	cp.w	r8,31
80008e82:	e0 89 00 11 	brgt	80008ea4 <_vfprintf_r+0x151c>
80008e86:	f2 cb ff fc 	sub	r11,r9,-4
80008e8a:	51 0b       	stdsp	sp[0x40],r11
80008e8c:	fa c6 f9 44 	sub	r6,sp,-1724
80008e90:	72 0b       	ld.w	r11,r9[0x0]
80008e92:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008e96:	f3 4b fd 88 	st.w	r9[-632],r11
80008e9a:	2f f8       	sub	r8,-1
80008e9c:	14 97       	mov	r7,r10
80008e9e:	fb 48 06 b4 	st.w	sp[1716],r8
80008ea2:	c0 58       	rjmp	80008eac <_vfprintf_r+0x1524>
80008ea4:	72 0b       	ld.w	r11,r9[0x0]
80008ea6:	14 97       	mov	r7,r10
80008ea8:	2f c9       	sub	r9,-4
80008eaa:	51 09       	stdsp	sp[0x40],r9
80008eac:	50 1b       	stdsp	sp[0x4],r11
80008eae:	30 0e       	mov	lr,0
80008eb0:	50 0e       	stdsp	sp[0x0],lr
80008eb2:	40 08       	lddsp	r8,sp[0x0]
80008eb4:	40 1c       	lddsp	r12,sp[0x4]
80008eb6:	18 48       	or	r8,r12
80008eb8:	5f 19       	srne	r9
80008eba:	0a 98       	mov	r8,r5
80008ebc:	eb e9 00 09 	and	r9,r5,r9
80008ec0:	a1 b8       	sbr	r8,0x1
80008ec2:	58 09       	cp.w	r9,0
80008ec4:	c0 70       	breq	80008ed2 <_vfprintf_r+0x154a>
80008ec6:	10 95       	mov	r5,r8
80008ec8:	fb 60 06 b9 	st.b	sp[1721],r0
80008ecc:	33 08       	mov	r8,48
80008ece:	fb 68 06 b8 	st.b	sp[1720],r8
80008ed2:	30 28       	mov	r8,2
80008ed4:	30 09       	mov	r9,0
80008ed6:	fb 69 06 bb 	st.b	sp[1723],r9
80008eda:	0a 99       	mov	r9,r5
80008edc:	a7 d9       	cbr	r9,0x7
80008ede:	40 2b       	lddsp	r11,sp[0x8]
80008ee0:	40 16       	lddsp	r6,sp[0x4]
80008ee2:	58 0b       	cp.w	r11,0
80008ee4:	5f 1a       	srne	r10
80008ee6:	f2 05 17 40 	movge	r5,r9
80008eea:	fa c2 f9 78 	sub	r2,sp,-1672
80008eee:	40 09       	lddsp	r9,sp[0x0]
80008ef0:	0c 49       	or	r9,r6
80008ef2:	5f 19       	srne	r9
80008ef4:	f5 e9 10 09 	or	r9,r10,r9
80008ef8:	c5 c0       	breq	80008fb0 <_vfprintf_r+0x1628>
80008efa:	30 19       	mov	r9,1
80008efc:	f2 08 18 00 	cp.b	r8,r9
80008f00:	c0 60       	breq	80008f0c <_vfprintf_r+0x1584>
80008f02:	30 29       	mov	r9,2
80008f04:	f2 08 18 00 	cp.b	r8,r9
80008f08:	c0 41       	brne	80008f10 <_vfprintf_r+0x1588>
80008f0a:	c3 c8       	rjmp	80008f82 <_vfprintf_r+0x15fa>
80008f0c:	04 96       	mov	r6,r2
80008f0e:	c3 08       	rjmp	80008f6e <_vfprintf_r+0x15e6>
80008f10:	04 96       	mov	r6,r2
80008f12:	fa e8 00 00 	ld.d	r8,sp[0]
80008f16:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
80008f1a:	2d 0a       	sub	r10,-48
80008f1c:	0c fa       	st.b	--r6,r10
80008f1e:	f0 0b 16 03 	lsr	r11,r8,0x3
80008f22:	f2 0c 16 03 	lsr	r12,r9,0x3
80008f26:	f7 e9 11 db 	or	r11,r11,r9<<0x1d
80008f2a:	18 99       	mov	r9,r12
80008f2c:	16 98       	mov	r8,r11
80008f2e:	58 08       	cp.w	r8,0
80008f30:	5c 29       	cpc	r9
80008f32:	cf 21       	brne	80008f16 <_vfprintf_r+0x158e>
80008f34:	fa e9 00 00 	st.d	sp[0],r8
80008f38:	ed b5 00 00 	bld	r5,0x0
80008f3c:	c4 51       	brne	80008fc6 <_vfprintf_r+0x163e>
80008f3e:	33 09       	mov	r9,48
80008f40:	f2 0a 18 00 	cp.b	r10,r9
80008f44:	c4 10       	breq	80008fc6 <_vfprintf_r+0x163e>
80008f46:	0c f9       	st.b	--r6,r9
80008f48:	c3 f8       	rjmp	80008fc6 <_vfprintf_r+0x163e>
80008f4a:	fa ea 00 00 	ld.d	r10,sp[0]
80008f4e:	30 a8       	mov	r8,10
80008f50:	30 09       	mov	r9,0
80008f52:	e0 a0 1a 1b 	rcall	8000c388 <__avr32_umod64>
80008f56:	30 a8       	mov	r8,10
80008f58:	2d 0a       	sub	r10,-48
80008f5a:	30 09       	mov	r9,0
80008f5c:	ac 8a       	st.b	r6[0x0],r10
80008f5e:	fa ea 00 00 	ld.d	r10,sp[0]
80008f62:	e0 a0 18 e1 	rcall	8000c124 <__avr32_udiv64>
80008f66:	16 99       	mov	r9,r11
80008f68:	14 98       	mov	r8,r10
80008f6a:	fa e9 00 00 	st.d	sp[0],r8
80008f6e:	20 16       	sub	r6,1
80008f70:	fa ea 00 00 	ld.d	r10,sp[0]
80008f74:	58 9a       	cp.w	r10,9
80008f76:	5c 2b       	cpc	r11
80008f78:	fe 9b ff e9 	brhi	80008f4a <_vfprintf_r+0x15c2>
80008f7c:	1b f8       	ld.ub	r8,sp[0x7]
80008f7e:	2d 08       	sub	r8,-48
80008f80:	c2 08       	rjmp	80008fc0 <_vfprintf_r+0x1638>
80008f82:	04 96       	mov	r6,r2
80008f84:	fa e8 00 00 	ld.d	r8,sp[0]
80008f88:	f5 d8 c0 04 	bfextu	r10,r8,0x0,0x4
80008f8c:	40 de       	lddsp	lr,sp[0x34]
80008f8e:	fc 0a 07 0a 	ld.ub	r10,lr[r10]
80008f92:	0c fa       	st.b	--r6,r10
80008f94:	f2 0b 16 04 	lsr	r11,r9,0x4
80008f98:	f0 0a 16 04 	lsr	r10,r8,0x4
80008f9c:	f5 e9 11 ca 	or	r10,r10,r9<<0x1c
80008fa0:	16 99       	mov	r9,r11
80008fa2:	14 98       	mov	r8,r10
80008fa4:	58 08       	cp.w	r8,0
80008fa6:	5c 29       	cpc	r9
80008fa8:	cf 01       	brne	80008f88 <_vfprintf_r+0x1600>
80008faa:	fa e9 00 00 	st.d	sp[0],r8
80008fae:	c0 c8       	rjmp	80008fc6 <_vfprintf_r+0x163e>
80008fb0:	58 08       	cp.w	r8,0
80008fb2:	c0 91       	brne	80008fc4 <_vfprintf_r+0x163c>
80008fb4:	ed b5 00 00 	bld	r5,0x0
80008fb8:	c0 61       	brne	80008fc4 <_vfprintf_r+0x163c>
80008fba:	fa c6 f9 79 	sub	r6,sp,-1671
80008fbe:	33 08       	mov	r8,48
80008fc0:	ac 88       	st.b	r6[0x0],r8
80008fc2:	c0 28       	rjmp	80008fc6 <_vfprintf_r+0x163e>
80008fc4:	04 96       	mov	r6,r2
80008fc6:	0c 12       	sub	r2,r6
80008fc8:	c1 c8       	rjmp	80009000 <_vfprintf_r+0x1678>
80008fca:	50 a7       	stdsp	sp[0x28],r7
80008fcc:	50 80       	stdsp	sp[0x20],r0
80008fce:	40 93       	lddsp	r3,sp[0x24]
80008fd0:	0c 97       	mov	r7,r6
80008fd2:	10 90       	mov	r0,r8
80008fd4:	04 94       	mov	r4,r2
80008fd6:	40 41       	lddsp	r1,sp[0x10]
80008fd8:	58 08       	cp.w	r8,0
80008fda:	e0 80 04 51 	breq	8000987c <_vfprintf_r+0x1ef4>
80008fde:	fb 68 06 60 	st.b	sp[1632],r8
80008fe2:	30 0c       	mov	r12,0
80008fe4:	30 08       	mov	r8,0
80008fe6:	30 12       	mov	r2,1
80008fe8:	fb 68 06 bb 	st.b	sp[1723],r8
80008fec:	50 2c       	stdsp	sp[0x8],r12
80008fee:	fa c6 f9 a0 	sub	r6,sp,-1632
80008ff2:	c0 78       	rjmp	80009000 <_vfprintf_r+0x1678>
80008ff4:	30 0b       	mov	r11,0
80008ff6:	50 2b       	stdsp	sp[0x8],r11
80008ff8:	c0 48       	rjmp	80009000 <_vfprintf_r+0x1678>
80008ffa:	40 22       	lddsp	r2,sp[0x8]
80008ffc:	30 0a       	mov	r10,0
80008ffe:	50 2a       	stdsp	sp[0x8],r10
80009000:	40 29       	lddsp	r9,sp[0x8]
80009002:	e4 09 0c 49 	max	r9,r2,r9
80009006:	fb 38 06 bb 	ld.ub	r8,sp[1723]
8000900a:	50 39       	stdsp	sp[0xc],r9
8000900c:	0a 9e       	mov	lr,r5
8000900e:	30 09       	mov	r9,0
80009010:	e2 1e 00 02 	andl	lr,0x2,COH
80009014:	f2 08 18 00 	cp.b	r8,r9
80009018:	fb f8 10 03 	ld.wne	r8,sp[0xc]
8000901c:	f7 b8 01 ff 	subne	r8,-1
80009020:	fb f8 1a 03 	st.wne	sp[0xc],r8
80009024:	0a 9b       	mov	r11,r5
80009026:	58 0e       	cp.w	lr,0
80009028:	fb fc 10 03 	ld.wne	r12,sp[0xc]
8000902c:	f7 bc 01 fe 	subne	r12,-2
80009030:	fb fc 1a 03 	st.wne	sp[0xc],r12
80009034:	e2 1b 00 84 	andl	r11,0x84,COH
80009038:	50 fe       	stdsp	sp[0x3c],lr
8000903a:	50 9b       	stdsp	sp[0x24],r11
8000903c:	c4 51       	brne	800090c6 <_vfprintf_r+0x173e>
8000903e:	40 8a       	lddsp	r10,sp[0x20]
80009040:	40 39       	lddsp	r9,sp[0xc]
80009042:	12 1a       	sub	r10,r9
80009044:	50 4a       	stdsp	sp[0x10],r10
80009046:	58 0a       	cp.w	r10,0
80009048:	e0 89 00 1f 	brgt	80009086 <_vfprintf_r+0x16fe>
8000904c:	c3 d8       	rjmp	800090c6 <_vfprintf_r+0x173e>
8000904e:	2f 09       	sub	r9,-16
80009050:	2f f8       	sub	r8,-1
80009052:	4c ee       	lddpc	lr,80009188 <_vfprintf_r+0x1800>
80009054:	31 0c       	mov	r12,16
80009056:	fb 49 06 90 	st.w	sp[1680],r9
8000905a:	87 0e       	st.w	r3[0x0],lr
8000905c:	87 1c       	st.w	r3[0x4],r12
8000905e:	fb 48 06 8c 	st.w	sp[1676],r8
80009062:	58 78       	cp.w	r8,7
80009064:	e0 89 00 04 	brgt	8000906c <_vfprintf_r+0x16e4>
80009068:	2f 83       	sub	r3,-8
8000906a:	c0 b8       	rjmp	80009080 <_vfprintf_r+0x16f8>
8000906c:	fa ca f9 78 	sub	r10,sp,-1672
80009070:	02 9b       	mov	r11,r1
80009072:	08 9c       	mov	r12,r4
80009074:	fe b0 f4 7c 	rcall	8000796c <__sprint_r>
80009078:	e0 81 04 13 	brne	8000989e <_vfprintf_r+0x1f16>
8000907c:	fa c3 f9 e0 	sub	r3,sp,-1568
80009080:	40 4b       	lddsp	r11,sp[0x10]
80009082:	21 0b       	sub	r11,16
80009084:	50 4b       	stdsp	sp[0x10],r11
80009086:	fa f9 06 90 	ld.w	r9,sp[1680]
8000908a:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000908e:	4b fa       	lddpc	r10,80009188 <_vfprintf_r+0x1800>
80009090:	40 4e       	lddsp	lr,sp[0x10]
80009092:	59 0e       	cp.w	lr,16
80009094:	fe 99 ff dd 	brgt	8000904e <_vfprintf_r+0x16c6>
80009098:	1c 09       	add	r9,lr
8000909a:	2f f8       	sub	r8,-1
8000909c:	87 0a       	st.w	r3[0x0],r10
8000909e:	fb 49 06 90 	st.w	sp[1680],r9
800090a2:	87 1e       	st.w	r3[0x4],lr
800090a4:	fb 48 06 8c 	st.w	sp[1676],r8
800090a8:	58 78       	cp.w	r8,7
800090aa:	e0 89 00 04 	brgt	800090b2 <_vfprintf_r+0x172a>
800090ae:	2f 83       	sub	r3,-8
800090b0:	c0 b8       	rjmp	800090c6 <_vfprintf_r+0x173e>
800090b2:	fa ca f9 78 	sub	r10,sp,-1672
800090b6:	02 9b       	mov	r11,r1
800090b8:	08 9c       	mov	r12,r4
800090ba:	fe b0 f4 59 	rcall	8000796c <__sprint_r>
800090be:	e0 81 03 f0 	brne	8000989e <_vfprintf_r+0x1f16>
800090c2:	fa c3 f9 e0 	sub	r3,sp,-1568
800090c6:	30 09       	mov	r9,0
800090c8:	fb 38 06 bb 	ld.ub	r8,sp[1723]
800090cc:	f2 08 18 00 	cp.b	r8,r9
800090d0:	c1 f0       	breq	8000910e <_vfprintf_r+0x1786>
800090d2:	fa f8 06 90 	ld.w	r8,sp[1680]
800090d6:	fa c9 f9 45 	sub	r9,sp,-1723
800090da:	2f f8       	sub	r8,-1
800090dc:	87 09       	st.w	r3[0x0],r9
800090de:	fb 48 06 90 	st.w	sp[1680],r8
800090e2:	30 19       	mov	r9,1
800090e4:	fa f8 06 8c 	ld.w	r8,sp[1676]
800090e8:	87 19       	st.w	r3[0x4],r9
800090ea:	2f f8       	sub	r8,-1
800090ec:	fb 48 06 8c 	st.w	sp[1676],r8
800090f0:	58 78       	cp.w	r8,7
800090f2:	e0 89 00 04 	brgt	800090fa <_vfprintf_r+0x1772>
800090f6:	2f 83       	sub	r3,-8
800090f8:	c0 b8       	rjmp	8000910e <_vfprintf_r+0x1786>
800090fa:	fa ca f9 78 	sub	r10,sp,-1672
800090fe:	02 9b       	mov	r11,r1
80009100:	08 9c       	mov	r12,r4
80009102:	fe b0 f4 35 	rcall	8000796c <__sprint_r>
80009106:	e0 81 03 cc 	brne	8000989e <_vfprintf_r+0x1f16>
8000910a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000910e:	40 fc       	lddsp	r12,sp[0x3c]
80009110:	58 0c       	cp.w	r12,0
80009112:	c1 f0       	breq	80009150 <_vfprintf_r+0x17c8>
80009114:	fa f8 06 90 	ld.w	r8,sp[1680]
80009118:	fa c9 f9 48 	sub	r9,sp,-1720
8000911c:	2f e8       	sub	r8,-2
8000911e:	87 09       	st.w	r3[0x0],r9
80009120:	fb 48 06 90 	st.w	sp[1680],r8
80009124:	30 29       	mov	r9,2
80009126:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000912a:	87 19       	st.w	r3[0x4],r9
8000912c:	2f f8       	sub	r8,-1
8000912e:	fb 48 06 8c 	st.w	sp[1676],r8
80009132:	58 78       	cp.w	r8,7
80009134:	e0 89 00 04 	brgt	8000913c <_vfprintf_r+0x17b4>
80009138:	2f 83       	sub	r3,-8
8000913a:	c0 b8       	rjmp	80009150 <_vfprintf_r+0x17c8>
8000913c:	fa ca f9 78 	sub	r10,sp,-1672
80009140:	02 9b       	mov	r11,r1
80009142:	08 9c       	mov	r12,r4
80009144:	fe b0 f4 14 	rcall	8000796c <__sprint_r>
80009148:	e0 81 03 ab 	brne	8000989e <_vfprintf_r+0x1f16>
8000914c:	fa c3 f9 e0 	sub	r3,sp,-1568
80009150:	40 9b       	lddsp	r11,sp[0x24]
80009152:	e0 4b 00 80 	cp.w	r11,128
80009156:	c4 a1       	brne	800091ea <_vfprintf_r+0x1862>
80009158:	40 8a       	lddsp	r10,sp[0x20]
8000915a:	40 39       	lddsp	r9,sp[0xc]
8000915c:	12 1a       	sub	r10,r9
8000915e:	50 4a       	stdsp	sp[0x10],r10
80009160:	58 0a       	cp.w	r10,0
80009162:	e0 89 00 24 	brgt	800091aa <_vfprintf_r+0x1822>
80009166:	c4 28       	rjmp	800091ea <_vfprintf_r+0x1862>
80009168:	2f 09       	sub	r9,-16
8000916a:	2f f8       	sub	r8,-1
8000916c:	48 8e       	lddpc	lr,8000918c <_vfprintf_r+0x1804>
8000916e:	31 0c       	mov	r12,16
80009170:	fb 49 06 90 	st.w	sp[1680],r9
80009174:	87 0e       	st.w	r3[0x0],lr
80009176:	87 1c       	st.w	r3[0x4],r12
80009178:	fb 48 06 8c 	st.w	sp[1676],r8
8000917c:	58 78       	cp.w	r8,7
8000917e:	e0 89 00 09 	brgt	80009190 <_vfprintf_r+0x1808>
80009182:	2f 83       	sub	r3,-8
80009184:	c1 08       	rjmp	800091a4 <_vfprintf_r+0x181c>
80009186:	d7 03       	nop
80009188:	80 01       	ld.sh	r1,r0[0x0]
8000918a:	60 b0       	ld.w	r0,r0[0x2c]
8000918c:	80 01       	ld.sh	r1,r0[0x0]
8000918e:	60 c0       	ld.w	r0,r0[0x30]
80009190:	fa ca f9 78 	sub	r10,sp,-1672
80009194:	02 9b       	mov	r11,r1
80009196:	08 9c       	mov	r12,r4
80009198:	fe b0 f3 ea 	rcall	8000796c <__sprint_r>
8000919c:	e0 81 03 81 	brne	8000989e <_vfprintf_r+0x1f16>
800091a0:	fa c3 f9 e0 	sub	r3,sp,-1568
800091a4:	40 4b       	lddsp	r11,sp[0x10]
800091a6:	21 0b       	sub	r11,16
800091a8:	50 4b       	stdsp	sp[0x10],r11
800091aa:	fa f9 06 90 	ld.w	r9,sp[1680]
800091ae:	fa f8 06 8c 	ld.w	r8,sp[1676]
800091b2:	4c 6a       	lddpc	r10,800092c8 <_vfprintf_r+0x1940>
800091b4:	40 4e       	lddsp	lr,sp[0x10]
800091b6:	59 0e       	cp.w	lr,16
800091b8:	fe 99 ff d8 	brgt	80009168 <_vfprintf_r+0x17e0>
800091bc:	1c 09       	add	r9,lr
800091be:	2f f8       	sub	r8,-1
800091c0:	87 0a       	st.w	r3[0x0],r10
800091c2:	fb 49 06 90 	st.w	sp[1680],r9
800091c6:	87 1e       	st.w	r3[0x4],lr
800091c8:	fb 48 06 8c 	st.w	sp[1676],r8
800091cc:	58 78       	cp.w	r8,7
800091ce:	e0 89 00 04 	brgt	800091d6 <_vfprintf_r+0x184e>
800091d2:	2f 83       	sub	r3,-8
800091d4:	c0 b8       	rjmp	800091ea <_vfprintf_r+0x1862>
800091d6:	fa ca f9 78 	sub	r10,sp,-1672
800091da:	02 9b       	mov	r11,r1
800091dc:	08 9c       	mov	r12,r4
800091de:	fe b0 f3 c7 	rcall	8000796c <__sprint_r>
800091e2:	e0 81 03 5e 	brne	8000989e <_vfprintf_r+0x1f16>
800091e6:	fa c3 f9 e0 	sub	r3,sp,-1568
800091ea:	40 2c       	lddsp	r12,sp[0x8]
800091ec:	04 1c       	sub	r12,r2
800091ee:	50 2c       	stdsp	sp[0x8],r12
800091f0:	58 0c       	cp.w	r12,0
800091f2:	e0 89 00 1f 	brgt	80009230 <_vfprintf_r+0x18a8>
800091f6:	c3 d8       	rjmp	80009270 <_vfprintf_r+0x18e8>
800091f8:	2f 09       	sub	r9,-16
800091fa:	2f f8       	sub	r8,-1
800091fc:	4b 3b       	lddpc	r11,800092c8 <_vfprintf_r+0x1940>
800091fe:	31 0a       	mov	r10,16
80009200:	fb 49 06 90 	st.w	sp[1680],r9
80009204:	87 0b       	st.w	r3[0x0],r11
80009206:	87 1a       	st.w	r3[0x4],r10
80009208:	fb 48 06 8c 	st.w	sp[1676],r8
8000920c:	58 78       	cp.w	r8,7
8000920e:	e0 89 00 04 	brgt	80009216 <_vfprintf_r+0x188e>
80009212:	2f 83       	sub	r3,-8
80009214:	c0 b8       	rjmp	8000922a <_vfprintf_r+0x18a2>
80009216:	fa ca f9 78 	sub	r10,sp,-1672
8000921a:	02 9b       	mov	r11,r1
8000921c:	08 9c       	mov	r12,r4
8000921e:	fe b0 f3 a7 	rcall	8000796c <__sprint_r>
80009222:	e0 81 03 3e 	brne	8000989e <_vfprintf_r+0x1f16>
80009226:	fa c3 f9 e0 	sub	r3,sp,-1568
8000922a:	40 29       	lddsp	r9,sp[0x8]
8000922c:	21 09       	sub	r9,16
8000922e:	50 29       	stdsp	sp[0x8],r9
80009230:	fa f9 06 90 	ld.w	r9,sp[1680]
80009234:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009238:	4a 4a       	lddpc	r10,800092c8 <_vfprintf_r+0x1940>
8000923a:	40 2e       	lddsp	lr,sp[0x8]
8000923c:	59 0e       	cp.w	lr,16
8000923e:	fe 99 ff dd 	brgt	800091f8 <_vfprintf_r+0x1870>
80009242:	1c 09       	add	r9,lr
80009244:	2f f8       	sub	r8,-1
80009246:	87 0a       	st.w	r3[0x0],r10
80009248:	fb 49 06 90 	st.w	sp[1680],r9
8000924c:	87 1e       	st.w	r3[0x4],lr
8000924e:	fb 48 06 8c 	st.w	sp[1676],r8
80009252:	58 78       	cp.w	r8,7
80009254:	e0 89 00 04 	brgt	8000925c <_vfprintf_r+0x18d4>
80009258:	2f 83       	sub	r3,-8
8000925a:	c0 b8       	rjmp	80009270 <_vfprintf_r+0x18e8>
8000925c:	fa ca f9 78 	sub	r10,sp,-1672
80009260:	02 9b       	mov	r11,r1
80009262:	08 9c       	mov	r12,r4
80009264:	fe b0 f3 84 	rcall	8000796c <__sprint_r>
80009268:	e0 81 03 1b 	brne	8000989e <_vfprintf_r+0x1f16>
8000926c:	fa c3 f9 e0 	sub	r3,sp,-1568
80009270:	ed b5 00 08 	bld	r5,0x8
80009274:	c0 b0       	breq	8000928a <_vfprintf_r+0x1902>
80009276:	fa f8 06 90 	ld.w	r8,sp[1680]
8000927a:	87 12       	st.w	r3[0x4],r2
8000927c:	87 06       	st.w	r3[0x0],r6
8000927e:	f0 02 00 02 	add	r2,r8,r2
80009282:	fb 42 06 90 	st.w	sp[1680],r2
80009286:	e0 8f 01 d5 	bral	80009630 <_vfprintf_r+0x1ca8>
8000928a:	e0 40 00 65 	cp.w	r0,101
8000928e:	e0 8a 01 d7 	brle	8000963c <_vfprintf_r+0x1cb4>
80009292:	30 08       	mov	r8,0
80009294:	30 09       	mov	r9,0
80009296:	40 5b       	lddsp	r11,sp[0x14]
80009298:	40 7a       	lddsp	r10,sp[0x1c]
8000929a:	e0 a0 15 3e 	rcall	8000bd16 <__avr32_f64_cmp_eq>
8000929e:	c7 a0       	breq	80009392 <_vfprintf_r+0x1a0a>
800092a0:	fa f8 06 90 	ld.w	r8,sp[1680]
800092a4:	48 a9       	lddpc	r9,800092cc <_vfprintf_r+0x1944>
800092a6:	2f f8       	sub	r8,-1
800092a8:	87 09       	st.w	r3[0x0],r9
800092aa:	fb 48 06 90 	st.w	sp[1680],r8
800092ae:	30 19       	mov	r9,1
800092b0:	fa f8 06 8c 	ld.w	r8,sp[1676]
800092b4:	87 19       	st.w	r3[0x4],r9
800092b6:	2f f8       	sub	r8,-1
800092b8:	fb 48 06 8c 	st.w	sp[1676],r8
800092bc:	58 78       	cp.w	r8,7
800092be:	e0 89 00 09 	brgt	800092d0 <_vfprintf_r+0x1948>
800092c2:	2f 83       	sub	r3,-8
800092c4:	c1 08       	rjmp	800092e4 <_vfprintf_r+0x195c>
800092c6:	d7 03       	nop
800092c8:	80 01       	ld.sh	r1,r0[0x0]
800092ca:	60 c0       	ld.w	r0,r0[0x30]
800092cc:	80 01       	ld.sh	r1,r0[0x0]
800092ce:	60 ac       	ld.w	r12,r0[0x28]
800092d0:	fa ca f9 78 	sub	r10,sp,-1672
800092d4:	02 9b       	mov	r11,r1
800092d6:	08 9c       	mov	r12,r4
800092d8:	fe b0 f3 4a 	rcall	8000796c <__sprint_r>
800092dc:	e0 81 02 e1 	brne	8000989e <_vfprintf_r+0x1f16>
800092e0:	fa c3 f9 e0 	sub	r3,sp,-1568
800092e4:	fa f8 06 ac 	ld.w	r8,sp[1708]
800092e8:	40 6c       	lddsp	r12,sp[0x18]
800092ea:	18 38       	cp.w	r8,r12
800092ec:	c0 55       	brlt	800092f6 <_vfprintf_r+0x196e>
800092ee:	ed b5 00 00 	bld	r5,0x0
800092f2:	e0 81 02 69 	brne	800097c4 <_vfprintf_r+0x1e3c>
800092f6:	fa f8 06 90 	ld.w	r8,sp[1680]
800092fa:	2f f8       	sub	r8,-1
800092fc:	40 cb       	lddsp	r11,sp[0x30]
800092fe:	fb 48 06 90 	st.w	sp[1680],r8
80009302:	30 19       	mov	r9,1
80009304:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009308:	87 0b       	st.w	r3[0x0],r11
8000930a:	2f f8       	sub	r8,-1
8000930c:	87 19       	st.w	r3[0x4],r9
8000930e:	fb 48 06 8c 	st.w	sp[1676],r8
80009312:	58 78       	cp.w	r8,7
80009314:	e0 89 00 04 	brgt	8000931c <_vfprintf_r+0x1994>
80009318:	2f 83       	sub	r3,-8
8000931a:	c0 b8       	rjmp	80009330 <_vfprintf_r+0x19a8>
8000931c:	fa ca f9 78 	sub	r10,sp,-1672
80009320:	02 9b       	mov	r11,r1
80009322:	08 9c       	mov	r12,r4
80009324:	fe b0 f3 24 	rcall	8000796c <__sprint_r>
80009328:	e0 81 02 bb 	brne	8000989e <_vfprintf_r+0x1f16>
8000932c:	fa c3 f9 e0 	sub	r3,sp,-1568
80009330:	40 66       	lddsp	r6,sp[0x18]
80009332:	20 16       	sub	r6,1
80009334:	58 06       	cp.w	r6,0
80009336:	e0 89 00 1d 	brgt	80009370 <_vfprintf_r+0x19e8>
8000933a:	e0 8f 02 45 	bral	800097c4 <_vfprintf_r+0x1e3c>
8000933e:	2f 09       	sub	r9,-16
80009340:	2f f8       	sub	r8,-1
80009342:	fb 49 06 90 	st.w	sp[1680],r9
80009346:	87 02       	st.w	r3[0x0],r2
80009348:	87 10       	st.w	r3[0x4],r0
8000934a:	fb 48 06 8c 	st.w	sp[1676],r8
8000934e:	58 78       	cp.w	r8,7
80009350:	e0 89 00 04 	brgt	80009358 <_vfprintf_r+0x19d0>
80009354:	2f 83       	sub	r3,-8
80009356:	c0 b8       	rjmp	8000936c <_vfprintf_r+0x19e4>
80009358:	fa ca f9 78 	sub	r10,sp,-1672
8000935c:	02 9b       	mov	r11,r1
8000935e:	08 9c       	mov	r12,r4
80009360:	fe b0 f3 06 	rcall	8000796c <__sprint_r>
80009364:	e0 81 02 9d 	brne	8000989e <_vfprintf_r+0x1f16>
80009368:	fa c3 f9 e0 	sub	r3,sp,-1568
8000936c:	21 06       	sub	r6,16
8000936e:	c0 38       	rjmp	80009374 <_vfprintf_r+0x19ec>
80009370:	4d 22       	lddpc	r2,800094b8 <_vfprintf_r+0x1b30>
80009372:	31 00       	mov	r0,16
80009374:	fa f9 06 90 	ld.w	r9,sp[1680]
80009378:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000937c:	4c fa       	lddpc	r10,800094b8 <_vfprintf_r+0x1b30>
8000937e:	59 06       	cp.w	r6,16
80009380:	fe 99 ff df 	brgt	8000933e <_vfprintf_r+0x19b6>
80009384:	0c 09       	add	r9,r6
80009386:	87 0a       	st.w	r3[0x0],r10
80009388:	fb 49 06 90 	st.w	sp[1680],r9
8000938c:	2f f8       	sub	r8,-1
8000938e:	87 16       	st.w	r3[0x4],r6
80009390:	c5 39       	rjmp	80009636 <_vfprintf_r+0x1cae>
80009392:	fa fa 06 ac 	ld.w	r10,sp[1708]
80009396:	58 0a       	cp.w	r10,0
80009398:	e0 89 00 94 	brgt	800094c0 <_vfprintf_r+0x1b38>
8000939c:	fa f8 06 90 	ld.w	r8,sp[1680]
800093a0:	4c 79       	lddpc	r9,800094bc <_vfprintf_r+0x1b34>
800093a2:	2f f8       	sub	r8,-1
800093a4:	87 09       	st.w	r3[0x0],r9
800093a6:	fb 48 06 90 	st.w	sp[1680],r8
800093aa:	30 19       	mov	r9,1
800093ac:	fa f8 06 8c 	ld.w	r8,sp[1676]
800093b0:	87 19       	st.w	r3[0x4],r9
800093b2:	2f f8       	sub	r8,-1
800093b4:	fb 48 06 8c 	st.w	sp[1676],r8
800093b8:	58 78       	cp.w	r8,7
800093ba:	e0 89 00 04 	brgt	800093c2 <_vfprintf_r+0x1a3a>
800093be:	2f 83       	sub	r3,-8
800093c0:	c0 b8       	rjmp	800093d6 <_vfprintf_r+0x1a4e>
800093c2:	fa ca f9 78 	sub	r10,sp,-1672
800093c6:	02 9b       	mov	r11,r1
800093c8:	08 9c       	mov	r12,r4
800093ca:	fe b0 f2 d1 	rcall	8000796c <__sprint_r>
800093ce:	e0 81 02 68 	brne	8000989e <_vfprintf_r+0x1f16>
800093d2:	fa c3 f9 e0 	sub	r3,sp,-1568
800093d6:	fa f8 06 ac 	ld.w	r8,sp[1708]
800093da:	58 08       	cp.w	r8,0
800093dc:	c0 81       	brne	800093ec <_vfprintf_r+0x1a64>
800093de:	40 6a       	lddsp	r10,sp[0x18]
800093e0:	58 0a       	cp.w	r10,0
800093e2:	c0 51       	brne	800093ec <_vfprintf_r+0x1a64>
800093e4:	ed b5 00 00 	bld	r5,0x0
800093e8:	e0 81 01 ee 	brne	800097c4 <_vfprintf_r+0x1e3c>
800093ec:	40 c9       	lddsp	r9,sp[0x30]
800093ee:	fa f8 06 90 	ld.w	r8,sp[1680]
800093f2:	2f f8       	sub	r8,-1
800093f4:	87 09       	st.w	r3[0x0],r9
800093f6:	fb 48 06 90 	st.w	sp[1680],r8
800093fa:	30 19       	mov	r9,1
800093fc:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009400:	87 19       	st.w	r3[0x4],r9
80009402:	2f f8       	sub	r8,-1
80009404:	fb 48 06 8c 	st.w	sp[1676],r8
80009408:	58 78       	cp.w	r8,7
8000940a:	e0 89 00 04 	brgt	80009412 <_vfprintf_r+0x1a8a>
8000940e:	2f 83       	sub	r3,-8
80009410:	c0 b8       	rjmp	80009426 <_vfprintf_r+0x1a9e>
80009412:	fa ca f9 78 	sub	r10,sp,-1672
80009416:	02 9b       	mov	r11,r1
80009418:	08 9c       	mov	r12,r4
8000941a:	fe b0 f2 a9 	rcall	8000796c <__sprint_r>
8000941e:	e0 81 02 40 	brne	8000989e <_vfprintf_r+0x1f16>
80009422:	fa c3 f9 e0 	sub	r3,sp,-1568
80009426:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000942a:	5c 32       	neg	r2
8000942c:	58 02       	cp.w	r2,0
8000942e:	e0 89 00 1d 	brgt	80009468 <_vfprintf_r+0x1ae0>
80009432:	c3 b8       	rjmp	800094a8 <_vfprintf_r+0x1b20>
80009434:	2f 09       	sub	r9,-16
80009436:	2f f8       	sub	r8,-1
80009438:	31 0e       	mov	lr,16
8000943a:	fb 49 06 90 	st.w	sp[1680],r9
8000943e:	87 00       	st.w	r3[0x0],r0
80009440:	87 1e       	st.w	r3[0x4],lr
80009442:	fb 48 06 8c 	st.w	sp[1676],r8
80009446:	58 78       	cp.w	r8,7
80009448:	e0 89 00 04 	brgt	80009450 <_vfprintf_r+0x1ac8>
8000944c:	2f 83       	sub	r3,-8
8000944e:	c0 b8       	rjmp	80009464 <_vfprintf_r+0x1adc>
80009450:	fa ca f9 78 	sub	r10,sp,-1672
80009454:	02 9b       	mov	r11,r1
80009456:	08 9c       	mov	r12,r4
80009458:	fe b0 f2 8a 	rcall	8000796c <__sprint_r>
8000945c:	e0 81 02 21 	brne	8000989e <_vfprintf_r+0x1f16>
80009460:	fa c3 f9 e0 	sub	r3,sp,-1568
80009464:	21 02       	sub	r2,16
80009466:	c0 28       	rjmp	8000946a <_vfprintf_r+0x1ae2>
80009468:	49 40       	lddpc	r0,800094b8 <_vfprintf_r+0x1b30>
8000946a:	fa f9 06 90 	ld.w	r9,sp[1680]
8000946e:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009472:	49 2a       	lddpc	r10,800094b8 <_vfprintf_r+0x1b30>
80009474:	59 02       	cp.w	r2,16
80009476:	fe 99 ff df 	brgt	80009434 <_vfprintf_r+0x1aac>
8000947a:	04 09       	add	r9,r2
8000947c:	2f f8       	sub	r8,-1
8000947e:	87 0a       	st.w	r3[0x0],r10
80009480:	fb 49 06 90 	st.w	sp[1680],r9
80009484:	87 12       	st.w	r3[0x4],r2
80009486:	fb 48 06 8c 	st.w	sp[1676],r8
8000948a:	58 78       	cp.w	r8,7
8000948c:	e0 89 00 04 	brgt	80009494 <_vfprintf_r+0x1b0c>
80009490:	2f 83       	sub	r3,-8
80009492:	c0 b8       	rjmp	800094a8 <_vfprintf_r+0x1b20>
80009494:	fa ca f9 78 	sub	r10,sp,-1672
80009498:	02 9b       	mov	r11,r1
8000949a:	08 9c       	mov	r12,r4
8000949c:	fe b0 f2 68 	rcall	8000796c <__sprint_r>
800094a0:	e0 81 01 ff 	brne	8000989e <_vfprintf_r+0x1f16>
800094a4:	fa c3 f9 e0 	sub	r3,sp,-1568
800094a8:	40 6c       	lddsp	r12,sp[0x18]
800094aa:	fa f8 06 90 	ld.w	r8,sp[1680]
800094ae:	87 06       	st.w	r3[0x0],r6
800094b0:	87 1c       	st.w	r3[0x4],r12
800094b2:	18 08       	add	r8,r12
800094b4:	cb c8       	rjmp	8000962c <_vfprintf_r+0x1ca4>
800094b6:	d7 03       	nop
800094b8:	80 01       	ld.sh	r1,r0[0x0]
800094ba:	60 c0       	ld.w	r0,r0[0x30]
800094bc:	80 01       	ld.sh	r1,r0[0x0]
800094be:	60 ac       	ld.w	r12,r0[0x28]
800094c0:	fa f9 06 90 	ld.w	r9,sp[1680]
800094c4:	fa f8 06 8c 	ld.w	r8,sp[1676]
800094c8:	40 6b       	lddsp	r11,sp[0x18]
800094ca:	16 3a       	cp.w	r10,r11
800094cc:	c6 d5       	brlt	800095a6 <_vfprintf_r+0x1c1e>
800094ce:	16 09       	add	r9,r11
800094d0:	2f f8       	sub	r8,-1
800094d2:	87 06       	st.w	r3[0x0],r6
800094d4:	fb 49 06 90 	st.w	sp[1680],r9
800094d8:	87 1b       	st.w	r3[0x4],r11
800094da:	fb 48 06 8c 	st.w	sp[1676],r8
800094de:	58 78       	cp.w	r8,7
800094e0:	e0 89 00 04 	brgt	800094e8 <_vfprintf_r+0x1b60>
800094e4:	2f 83       	sub	r3,-8
800094e6:	c0 b8       	rjmp	800094fc <_vfprintf_r+0x1b74>
800094e8:	fa ca f9 78 	sub	r10,sp,-1672
800094ec:	02 9b       	mov	r11,r1
800094ee:	08 9c       	mov	r12,r4
800094f0:	fe b0 f2 3e 	rcall	8000796c <__sprint_r>
800094f4:	e0 81 01 d5 	brne	8000989e <_vfprintf_r+0x1f16>
800094f8:	fa c3 f9 e0 	sub	r3,sp,-1568
800094fc:	fa f6 06 ac 	ld.w	r6,sp[1708]
80009500:	40 6a       	lddsp	r10,sp[0x18]
80009502:	14 16       	sub	r6,r10
80009504:	58 06       	cp.w	r6,0
80009506:	e0 89 00 1c 	brgt	8000953e <_vfprintf_r+0x1bb6>
8000950a:	c3 b8       	rjmp	80009580 <_vfprintf_r+0x1bf8>
8000950c:	2f 09       	sub	r9,-16
8000950e:	2f f8       	sub	r8,-1
80009510:	fb 49 06 90 	st.w	sp[1680],r9
80009514:	87 02       	st.w	r3[0x0],r2
80009516:	87 10       	st.w	r3[0x4],r0
80009518:	fb 48 06 8c 	st.w	sp[1676],r8
8000951c:	58 78       	cp.w	r8,7
8000951e:	e0 89 00 04 	brgt	80009526 <_vfprintf_r+0x1b9e>
80009522:	2f 83       	sub	r3,-8
80009524:	c0 b8       	rjmp	8000953a <_vfprintf_r+0x1bb2>
80009526:	fa ca f9 78 	sub	r10,sp,-1672
8000952a:	02 9b       	mov	r11,r1
8000952c:	08 9c       	mov	r12,r4
8000952e:	fe b0 f2 1f 	rcall	8000796c <__sprint_r>
80009532:	e0 81 01 b6 	brne	8000989e <_vfprintf_r+0x1f16>
80009536:	fa c3 f9 e0 	sub	r3,sp,-1568
8000953a:	21 06       	sub	r6,16
8000953c:	c0 38       	rjmp	80009542 <_vfprintf_r+0x1bba>
8000953e:	4d c2       	lddpc	r2,800096ac <_vfprintf_r+0x1d24>
80009540:	31 00       	mov	r0,16
80009542:	fa f9 06 90 	ld.w	r9,sp[1680]
80009546:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000954a:	4d 9a       	lddpc	r10,800096ac <_vfprintf_r+0x1d24>
8000954c:	59 06       	cp.w	r6,16
8000954e:	fe 99 ff df 	brgt	8000950c <_vfprintf_r+0x1b84>
80009552:	0c 09       	add	r9,r6
80009554:	2f f8       	sub	r8,-1
80009556:	87 0a       	st.w	r3[0x0],r10
80009558:	fb 49 06 90 	st.w	sp[1680],r9
8000955c:	87 16       	st.w	r3[0x4],r6
8000955e:	fb 48 06 8c 	st.w	sp[1676],r8
80009562:	58 78       	cp.w	r8,7
80009564:	e0 89 00 04 	brgt	8000956c <_vfprintf_r+0x1be4>
80009568:	2f 83       	sub	r3,-8
8000956a:	c0 b8       	rjmp	80009580 <_vfprintf_r+0x1bf8>
8000956c:	fa ca f9 78 	sub	r10,sp,-1672
80009570:	02 9b       	mov	r11,r1
80009572:	08 9c       	mov	r12,r4
80009574:	fe b0 f1 fc 	rcall	8000796c <__sprint_r>
80009578:	e0 81 01 93 	brne	8000989e <_vfprintf_r+0x1f16>
8000957c:	fa c3 f9 e0 	sub	r3,sp,-1568
80009580:	ed b5 00 00 	bld	r5,0x0
80009584:	e0 81 01 20 	brne	800097c4 <_vfprintf_r+0x1e3c>
80009588:	40 c9       	lddsp	r9,sp[0x30]
8000958a:	fa f8 06 90 	ld.w	r8,sp[1680]
8000958e:	2f f8       	sub	r8,-1
80009590:	87 09       	st.w	r3[0x0],r9
80009592:	fb 48 06 90 	st.w	sp[1680],r8
80009596:	30 19       	mov	r9,1
80009598:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000959c:	87 19       	st.w	r3[0x4],r9
8000959e:	2f f8       	sub	r8,-1
800095a0:	fb 48 06 8c 	st.w	sp[1676],r8
800095a4:	c0 29       	rjmp	800097a8 <_vfprintf_r+0x1e20>
800095a6:	14 09       	add	r9,r10
800095a8:	2f f8       	sub	r8,-1
800095aa:	fb 49 06 90 	st.w	sp[1680],r9
800095ae:	87 06       	st.w	r3[0x0],r6
800095b0:	87 1a       	st.w	r3[0x4],r10
800095b2:	fb 48 06 8c 	st.w	sp[1676],r8
800095b6:	58 78       	cp.w	r8,7
800095b8:	e0 89 00 04 	brgt	800095c0 <_vfprintf_r+0x1c38>
800095bc:	2f 83       	sub	r3,-8
800095be:	c0 b8       	rjmp	800095d4 <_vfprintf_r+0x1c4c>
800095c0:	fa ca f9 78 	sub	r10,sp,-1672
800095c4:	02 9b       	mov	r11,r1
800095c6:	08 9c       	mov	r12,r4
800095c8:	fe b0 f1 d2 	rcall	8000796c <__sprint_r>
800095cc:	e0 81 01 69 	brne	8000989e <_vfprintf_r+0x1f16>
800095d0:	fa c3 f9 e0 	sub	r3,sp,-1568
800095d4:	40 c8       	lddsp	r8,sp[0x30]
800095d6:	87 08       	st.w	r3[0x0],r8
800095d8:	fa f8 06 90 	ld.w	r8,sp[1680]
800095dc:	2f f8       	sub	r8,-1
800095de:	30 19       	mov	r9,1
800095e0:	fb 48 06 90 	st.w	sp[1680],r8
800095e4:	87 19       	st.w	r3[0x4],r9
800095e6:	fa f8 06 8c 	ld.w	r8,sp[1676]
800095ea:	2f f8       	sub	r8,-1
800095ec:	fb 48 06 8c 	st.w	sp[1676],r8
800095f0:	fa f2 06 ac 	ld.w	r2,sp[1708]
800095f4:	58 78       	cp.w	r8,7
800095f6:	e0 89 00 04 	brgt	800095fe <_vfprintf_r+0x1c76>
800095fa:	2f 83       	sub	r3,-8
800095fc:	c0 b8       	rjmp	80009612 <_vfprintf_r+0x1c8a>
800095fe:	fa ca f9 78 	sub	r10,sp,-1672
80009602:	02 9b       	mov	r11,r1
80009604:	08 9c       	mov	r12,r4
80009606:	fe b0 f1 b3 	rcall	8000796c <__sprint_r>
8000960a:	e0 81 01 4a 	brne	8000989e <_vfprintf_r+0x1f16>
8000960e:	fa c3 f9 e0 	sub	r3,sp,-1568
80009612:	04 06       	add	r6,r2
80009614:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009618:	87 06       	st.w	r3[0x0],r6
8000961a:	fa f9 06 90 	ld.w	r9,sp[1680]
8000961e:	40 66       	lddsp	r6,sp[0x18]
80009620:	40 6e       	lddsp	lr,sp[0x18]
80009622:	10 16       	sub	r6,r8
80009624:	f2 08 01 08 	sub	r8,r9,r8
80009628:	87 16       	st.w	r3[0x4],r6
8000962a:	1c 08       	add	r8,lr
8000962c:	fb 48 06 90 	st.w	sp[1680],r8
80009630:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009634:	2f f8       	sub	r8,-1
80009636:	fb 48 06 8c 	st.w	sp[1676],r8
8000963a:	cb 78       	rjmp	800097a8 <_vfprintf_r+0x1e20>
8000963c:	40 6c       	lddsp	r12,sp[0x18]
8000963e:	58 1c       	cp.w	r12,1
80009640:	e0 89 00 06 	brgt	8000964c <_vfprintf_r+0x1cc4>
80009644:	ed b5 00 00 	bld	r5,0x0
80009648:	e0 81 00 85 	brne	80009752 <_vfprintf_r+0x1dca>
8000964c:	fa f8 06 90 	ld.w	r8,sp[1680]
80009650:	2f f8       	sub	r8,-1
80009652:	30 19       	mov	r9,1
80009654:	fb 48 06 90 	st.w	sp[1680],r8
80009658:	87 06       	st.w	r3[0x0],r6
8000965a:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000965e:	87 19       	st.w	r3[0x4],r9
80009660:	2f f8       	sub	r8,-1
80009662:	fb 48 06 8c 	st.w	sp[1676],r8
80009666:	58 78       	cp.w	r8,7
80009668:	e0 89 00 04 	brgt	80009670 <_vfprintf_r+0x1ce8>
8000966c:	2f 83       	sub	r3,-8
8000966e:	c0 b8       	rjmp	80009684 <_vfprintf_r+0x1cfc>
80009670:	fa ca f9 78 	sub	r10,sp,-1672
80009674:	02 9b       	mov	r11,r1
80009676:	08 9c       	mov	r12,r4
80009678:	fe b0 f1 7a 	rcall	8000796c <__sprint_r>
8000967c:	e0 81 01 11 	brne	8000989e <_vfprintf_r+0x1f16>
80009680:	fa c3 f9 e0 	sub	r3,sp,-1568
80009684:	fa f8 06 90 	ld.w	r8,sp[1680]
80009688:	2f f8       	sub	r8,-1
8000968a:	40 cb       	lddsp	r11,sp[0x30]
8000968c:	fb 48 06 90 	st.w	sp[1680],r8
80009690:	30 19       	mov	r9,1
80009692:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009696:	87 0b       	st.w	r3[0x0],r11
80009698:	2f f8       	sub	r8,-1
8000969a:	87 19       	st.w	r3[0x4],r9
8000969c:	fb 48 06 8c 	st.w	sp[1676],r8
800096a0:	58 78       	cp.w	r8,7
800096a2:	e0 89 00 07 	brgt	800096b0 <_vfprintf_r+0x1d28>
800096a6:	2f 83       	sub	r3,-8
800096a8:	c0 e8       	rjmp	800096c4 <_vfprintf_r+0x1d3c>
800096aa:	d7 03       	nop
800096ac:	80 01       	ld.sh	r1,r0[0x0]
800096ae:	60 c0       	ld.w	r0,r0[0x30]
800096b0:	fa ca f9 78 	sub	r10,sp,-1672
800096b4:	02 9b       	mov	r11,r1
800096b6:	08 9c       	mov	r12,r4
800096b8:	fe b0 f1 5a 	rcall	8000796c <__sprint_r>
800096bc:	e0 81 00 f1 	brne	8000989e <_vfprintf_r+0x1f16>
800096c0:	fa c3 f9 e0 	sub	r3,sp,-1568
800096c4:	30 08       	mov	r8,0
800096c6:	30 09       	mov	r9,0
800096c8:	40 5b       	lddsp	r11,sp[0x14]
800096ca:	40 7a       	lddsp	r10,sp[0x1c]
800096cc:	e0 a0 13 25 	rcall	8000bd16 <__avr32_f64_cmp_eq>
800096d0:	40 68       	lddsp	r8,sp[0x18]
800096d2:	20 18       	sub	r8,1
800096d4:	58 0c       	cp.w	r12,0
800096d6:	c0 d1       	brne	800096f0 <_vfprintf_r+0x1d68>
800096d8:	2f f6       	sub	r6,-1
800096da:	87 18       	st.w	r3[0x4],r8
800096dc:	87 06       	st.w	r3[0x0],r6
800096de:	fa f6 06 90 	ld.w	r6,sp[1680]
800096e2:	10 06       	add	r6,r8
800096e4:	fa f8 06 8c 	ld.w	r8,sp[1676]
800096e8:	fb 46 06 90 	st.w	sp[1680],r6
800096ec:	2f f8       	sub	r8,-1
800096ee:	c2 f8       	rjmp	8000974c <_vfprintf_r+0x1dc4>
800096f0:	10 96       	mov	r6,r8
800096f2:	58 08       	cp.w	r8,0
800096f4:	e0 89 00 1c 	brgt	8000972c <_vfprintf_r+0x1da4>
800096f8:	c4 98       	rjmp	8000978a <_vfprintf_r+0x1e02>
800096fa:	2f 09       	sub	r9,-16
800096fc:	2f f8       	sub	r8,-1
800096fe:	fb 49 06 90 	st.w	sp[1680],r9
80009702:	87 02       	st.w	r3[0x0],r2
80009704:	87 10       	st.w	r3[0x4],r0
80009706:	fb 48 06 8c 	st.w	sp[1676],r8
8000970a:	58 78       	cp.w	r8,7
8000970c:	e0 89 00 04 	brgt	80009714 <_vfprintf_r+0x1d8c>
80009710:	2f 83       	sub	r3,-8
80009712:	c0 b8       	rjmp	80009728 <_vfprintf_r+0x1da0>
80009714:	fa ca f9 78 	sub	r10,sp,-1672
80009718:	02 9b       	mov	r11,r1
8000971a:	08 9c       	mov	r12,r4
8000971c:	fe b0 f1 28 	rcall	8000796c <__sprint_r>
80009720:	e0 81 00 bf 	brne	8000989e <_vfprintf_r+0x1f16>
80009724:	fa c3 f9 e0 	sub	r3,sp,-1568
80009728:	21 06       	sub	r6,16
8000972a:	c0 38       	rjmp	80009730 <_vfprintf_r+0x1da8>
8000972c:	4d 22       	lddpc	r2,80009874 <_vfprintf_r+0x1eec>
8000972e:	31 00       	mov	r0,16
80009730:	fa f9 06 90 	ld.w	r9,sp[1680]
80009734:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009738:	4c fa       	lddpc	r10,80009874 <_vfprintf_r+0x1eec>
8000973a:	59 06       	cp.w	r6,16
8000973c:	fe 99 ff df 	brgt	800096fa <_vfprintf_r+0x1d72>
80009740:	0c 09       	add	r9,r6
80009742:	87 0a       	st.w	r3[0x0],r10
80009744:	fb 49 06 90 	st.w	sp[1680],r9
80009748:	2f f8       	sub	r8,-1
8000974a:	87 16       	st.w	r3[0x4],r6
8000974c:	fb 48 06 8c 	st.w	sp[1676],r8
80009750:	c0 e8       	rjmp	8000976c <_vfprintf_r+0x1de4>
80009752:	fa f8 06 90 	ld.w	r8,sp[1680]
80009756:	2f f8       	sub	r8,-1
80009758:	30 19       	mov	r9,1
8000975a:	fb 48 06 90 	st.w	sp[1680],r8
8000975e:	87 06       	st.w	r3[0x0],r6
80009760:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009764:	87 19       	st.w	r3[0x4],r9
80009766:	2f f8       	sub	r8,-1
80009768:	fb 48 06 8c 	st.w	sp[1676],r8
8000976c:	58 78       	cp.w	r8,7
8000976e:	e0 89 00 04 	brgt	80009776 <_vfprintf_r+0x1dee>
80009772:	2f 83       	sub	r3,-8
80009774:	c0 b8       	rjmp	8000978a <_vfprintf_r+0x1e02>
80009776:	fa ca f9 78 	sub	r10,sp,-1672
8000977a:	02 9b       	mov	r11,r1
8000977c:	08 9c       	mov	r12,r4
8000977e:	fe b0 f0 f7 	rcall	8000796c <__sprint_r>
80009782:	e0 81 00 8e 	brne	8000989e <_vfprintf_r+0x1f16>
80009786:	fa c3 f9 e0 	sub	r3,sp,-1568
8000978a:	40 ea       	lddsp	r10,sp[0x38]
8000978c:	fa f8 06 90 	ld.w	r8,sp[1680]
80009790:	14 08       	add	r8,r10
80009792:	fa c9 f9 64 	sub	r9,sp,-1692
80009796:	fb 48 06 90 	st.w	sp[1680],r8
8000979a:	87 1a       	st.w	r3[0x4],r10
8000979c:	fa f8 06 8c 	ld.w	r8,sp[1676]
800097a0:	87 09       	st.w	r3[0x0],r9
800097a2:	2f f8       	sub	r8,-1
800097a4:	fb 48 06 8c 	st.w	sp[1676],r8
800097a8:	58 78       	cp.w	r8,7
800097aa:	e0 89 00 04 	brgt	800097b2 <_vfprintf_r+0x1e2a>
800097ae:	2f 83       	sub	r3,-8
800097b0:	c0 a8       	rjmp	800097c4 <_vfprintf_r+0x1e3c>
800097b2:	fa ca f9 78 	sub	r10,sp,-1672
800097b6:	02 9b       	mov	r11,r1
800097b8:	08 9c       	mov	r12,r4
800097ba:	fe b0 f0 d9 	rcall	8000796c <__sprint_r>
800097be:	c7 01       	brne	8000989e <_vfprintf_r+0x1f16>
800097c0:	fa c3 f9 e0 	sub	r3,sp,-1568
800097c4:	e2 15 00 04 	andl	r5,0x4,COH
800097c8:	c3 d0       	breq	80009842 <_vfprintf_r+0x1eba>
800097ca:	40 86       	lddsp	r6,sp[0x20]
800097cc:	40 39       	lddsp	r9,sp[0xc]
800097ce:	12 16       	sub	r6,r9
800097d0:	58 06       	cp.w	r6,0
800097d2:	e0 89 00 1a 	brgt	80009806 <_vfprintf_r+0x1e7e>
800097d6:	c3 68       	rjmp	80009842 <_vfprintf_r+0x1eba>
800097d8:	2f 09       	sub	r9,-16
800097da:	2f f8       	sub	r8,-1
800097dc:	fb 49 06 90 	st.w	sp[1680],r9
800097e0:	87 05       	st.w	r3[0x0],r5
800097e2:	87 12       	st.w	r3[0x4],r2
800097e4:	fb 48 06 8c 	st.w	sp[1676],r8
800097e8:	58 78       	cp.w	r8,7
800097ea:	e0 89 00 04 	brgt	800097f2 <_vfprintf_r+0x1e6a>
800097ee:	2f 83       	sub	r3,-8
800097f0:	c0 98       	rjmp	80009802 <_vfprintf_r+0x1e7a>
800097f2:	00 9a       	mov	r10,r0
800097f4:	02 9b       	mov	r11,r1
800097f6:	08 9c       	mov	r12,r4
800097f8:	fe b0 f0 ba 	rcall	8000796c <__sprint_r>
800097fc:	c5 11       	brne	8000989e <_vfprintf_r+0x1f16>
800097fe:	fa c3 f9 e0 	sub	r3,sp,-1568
80009802:	21 06       	sub	r6,16
80009804:	c0 58       	rjmp	8000980e <_vfprintf_r+0x1e86>
80009806:	49 d5       	lddpc	r5,80009878 <_vfprintf_r+0x1ef0>
80009808:	31 02       	mov	r2,16
8000980a:	fa c0 f9 78 	sub	r0,sp,-1672
8000980e:	fa f9 06 90 	ld.w	r9,sp[1680]
80009812:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009816:	49 9a       	lddpc	r10,80009878 <_vfprintf_r+0x1ef0>
80009818:	59 06       	cp.w	r6,16
8000981a:	fe 99 ff df 	brgt	800097d8 <_vfprintf_r+0x1e50>
8000981e:	0c 09       	add	r9,r6
80009820:	2f f8       	sub	r8,-1
80009822:	87 0a       	st.w	r3[0x0],r10
80009824:	87 16       	st.w	r3[0x4],r6
80009826:	fb 49 06 90 	st.w	sp[1680],r9
8000982a:	fb 48 06 8c 	st.w	sp[1676],r8
8000982e:	58 78       	cp.w	r8,7
80009830:	e0 8a 00 09 	brle	80009842 <_vfprintf_r+0x1eba>
80009834:	fa ca f9 78 	sub	r10,sp,-1672
80009838:	02 9b       	mov	r11,r1
8000983a:	08 9c       	mov	r12,r4
8000983c:	fe b0 f0 98 	rcall	8000796c <__sprint_r>
80009840:	c2 f1       	brne	8000989e <_vfprintf_r+0x1f16>
80009842:	40 bc       	lddsp	r12,sp[0x2c]
80009844:	40 36       	lddsp	r6,sp[0xc]
80009846:	40 8e       	lddsp	lr,sp[0x20]
80009848:	ec 0e 0c 48 	max	r8,r6,lr
8000984c:	10 0c       	add	r12,r8
8000984e:	50 bc       	stdsp	sp[0x2c],r12
80009850:	fa f8 06 90 	ld.w	r8,sp[1680]
80009854:	58 08       	cp.w	r8,0
80009856:	c0 80       	breq	80009866 <_vfprintf_r+0x1ede>
80009858:	fa ca f9 78 	sub	r10,sp,-1672
8000985c:	02 9b       	mov	r11,r1
8000985e:	08 9c       	mov	r12,r4
80009860:	fe b0 f0 86 	rcall	8000796c <__sprint_r>
80009864:	c1 d1       	brne	8000989e <_vfprintf_r+0x1f16>
80009866:	30 0b       	mov	r11,0
80009868:	fa c3 f9 e0 	sub	r3,sp,-1568
8000986c:	fb 4b 06 8c 	st.w	sp[1676],r11
80009870:	fe 9f f1 17 	bral	80007a9e <_vfprintf_r+0x116>
80009874:	80 01       	ld.sh	r1,r0[0x0]
80009876:	60 c0       	ld.w	r0,r0[0x30]
80009878:	80 01       	ld.sh	r1,r0[0x0]
8000987a:	60 b0       	ld.w	r0,r0[0x2c]
8000987c:	08 95       	mov	r5,r4
8000987e:	fa f8 06 90 	ld.w	r8,sp[1680]
80009882:	58 08       	cp.w	r8,0
80009884:	c0 80       	breq	80009894 <_vfprintf_r+0x1f0c>
80009886:	08 9c       	mov	r12,r4
80009888:	fa ca f9 78 	sub	r10,sp,-1672
8000988c:	02 9b       	mov	r11,r1
8000988e:	fe b0 f0 6f 	rcall	8000796c <__sprint_r>
80009892:	c0 61       	brne	8000989e <_vfprintf_r+0x1f16>
80009894:	30 08       	mov	r8,0
80009896:	fb 48 06 8c 	st.w	sp[1676],r8
8000989a:	c0 28       	rjmp	8000989e <_vfprintf_r+0x1f16>
8000989c:	40 41       	lddsp	r1,sp[0x10]
8000989e:	82 68       	ld.sh	r8,r1[0xc]
800098a0:	ed b8 00 06 	bld	r8,0x6
800098a4:	c0 31       	brne	800098aa <_vfprintf_r+0x1f22>
800098a6:	3f fa       	mov	r10,-1
800098a8:	50 ba       	stdsp	sp[0x2c],r10
800098aa:	40 bc       	lddsp	r12,sp[0x2c]
800098ac:	fe 3d f9 44 	sub	sp,-1724
800098b0:	d8 32       	popm	r0-r7,pc
800098b2:	d7 03       	nop

800098b4 <__swsetup_r>:
800098b4:	d4 21       	pushm	r4-r7,lr
800098b6:	e0 68 0a 30 	mov	r8,2608
800098ba:	18 96       	mov	r6,r12
800098bc:	16 97       	mov	r7,r11
800098be:	70 0c       	ld.w	r12,r8[0x0]
800098c0:	58 0c       	cp.w	r12,0
800098c2:	c0 60       	breq	800098ce <__swsetup_r+0x1a>
800098c4:	78 68       	ld.w	r8,r12[0x18]
800098c6:	58 08       	cp.w	r8,0
800098c8:	c0 31       	brne	800098ce <__swsetup_r+0x1a>
800098ca:	e0 a0 07 c7 	rcall	8000a858 <__sinit>
800098ce:	4a f8       	lddpc	r8,80009988 <__swsetup_r+0xd4>
800098d0:	10 37       	cp.w	r7,r8
800098d2:	c0 61       	brne	800098de <__swsetup_r+0x2a>
800098d4:	e0 68 0a 30 	mov	r8,2608
800098d8:	70 08       	ld.w	r8,r8[0x0]
800098da:	70 07       	ld.w	r7,r8[0x0]
800098dc:	c1 08       	rjmp	800098fc <__swsetup_r+0x48>
800098de:	4a c8       	lddpc	r8,8000998c <__swsetup_r+0xd8>
800098e0:	10 37       	cp.w	r7,r8
800098e2:	c0 61       	brne	800098ee <__swsetup_r+0x3a>
800098e4:	e0 68 0a 30 	mov	r8,2608
800098e8:	70 08       	ld.w	r8,r8[0x0]
800098ea:	70 17       	ld.w	r7,r8[0x4]
800098ec:	c0 88       	rjmp	800098fc <__swsetup_r+0x48>
800098ee:	4a 98       	lddpc	r8,80009990 <__swsetup_r+0xdc>
800098f0:	10 37       	cp.w	r7,r8
800098f2:	c0 51       	brne	800098fc <__swsetup_r+0x48>
800098f4:	e0 68 0a 30 	mov	r8,2608
800098f8:	70 08       	ld.w	r8,r8[0x0]
800098fa:	70 27       	ld.w	r7,r8[0x8]
800098fc:	8e 68       	ld.sh	r8,r7[0xc]
800098fe:	ed b8 00 03 	bld	r8,0x3
80009902:	c1 e0       	breq	8000993e <__swsetup_r+0x8a>
80009904:	ed b8 00 04 	bld	r8,0x4
80009908:	c3 e1       	brne	80009984 <__swsetup_r+0xd0>
8000990a:	ed b8 00 02 	bld	r8,0x2
8000990e:	c1 51       	brne	80009938 <__swsetup_r+0x84>
80009910:	6e db       	ld.w	r11,r7[0x34]
80009912:	58 0b       	cp.w	r11,0
80009914:	c0 a0       	breq	80009928 <__swsetup_r+0x74>
80009916:	ee c8 ff bc 	sub	r8,r7,-68
8000991a:	10 3b       	cp.w	r11,r8
8000991c:	c0 40       	breq	80009924 <__swsetup_r+0x70>
8000991e:	0c 9c       	mov	r12,r6
80009920:	e0 a0 08 36 	rcall	8000a98c <_free_r>
80009924:	30 08       	mov	r8,0
80009926:	8f d8       	st.w	r7[0x34],r8
80009928:	8e 68       	ld.sh	r8,r7[0xc]
8000992a:	e0 18 ff db 	andl	r8,0xffdb
8000992e:	ae 68       	st.h	r7[0xc],r8
80009930:	30 08       	mov	r8,0
80009932:	8f 18       	st.w	r7[0x4],r8
80009934:	6e 48       	ld.w	r8,r7[0x10]
80009936:	8f 08       	st.w	r7[0x0],r8
80009938:	8e 68       	ld.sh	r8,r7[0xc]
8000993a:	a3 b8       	sbr	r8,0x3
8000993c:	ae 68       	st.h	r7[0xc],r8
8000993e:	6e 48       	ld.w	r8,r7[0x10]
80009940:	58 08       	cp.w	r8,0
80009942:	c0 b1       	brne	80009958 <__swsetup_r+0xa4>
80009944:	8e 68       	ld.sh	r8,r7[0xc]
80009946:	e2 18 02 80 	andl	r8,0x280,COH
8000994a:	e0 48 02 00 	cp.w	r8,512
8000994e:	c0 50       	breq	80009958 <__swsetup_r+0xa4>
80009950:	0c 9c       	mov	r12,r6
80009952:	0e 9b       	mov	r11,r7
80009954:	e0 a0 0a 56 	rcall	8000ae00 <__smakebuf_r>
80009958:	8e 69       	ld.sh	r9,r7[0xc]
8000995a:	f1 d9 c0 01 	bfextu	r8,r9,0x0,0x1
8000995e:	c0 70       	breq	8000996c <__swsetup_r+0xb8>
80009960:	30 08       	mov	r8,0
80009962:	8f 28       	st.w	r7[0x8],r8
80009964:	6e 58       	ld.w	r8,r7[0x14]
80009966:	5c 38       	neg	r8
80009968:	8f 68       	st.w	r7[0x18],r8
8000996a:	c0 68       	rjmp	80009976 <__swsetup_r+0xc2>
8000996c:	ed b9 00 01 	bld	r9,0x1
80009970:	ef f8 10 05 	ld.wne	r8,r7[0x14]
80009974:	8f 28       	st.w	r7[0x8],r8
80009976:	6e 48       	ld.w	r8,r7[0x10]
80009978:	58 08       	cp.w	r8,0
8000997a:	c0 61       	brne	80009986 <__swsetup_r+0xd2>
8000997c:	8e 68       	ld.sh	r8,r7[0xc]
8000997e:	ed b8 00 07 	bld	r8,0x7
80009982:	c0 21       	brne	80009986 <__swsetup_r+0xd2>
80009984:	dc 2a       	popm	r4-r7,pc,r12=-1
80009986:	d8 2a       	popm	r4-r7,pc,r12=0
80009988:	80 01       	ld.sh	r1,r0[0x0]
8000998a:	61 e0       	ld.w	r0,r0[0x78]
8000998c:	80 01       	ld.sh	r1,r0[0x0]
8000998e:	62 00       	ld.w	r0,r1[0x0]
80009990:	80 01       	ld.sh	r1,r0[0x0]
80009992:	62 20       	ld.w	r0,r1[0x8]

80009994 <quorem>:
80009994:	d4 31       	pushm	r0-r7,lr
80009996:	20 2d       	sub	sp,8
80009998:	18 97       	mov	r7,r12
8000999a:	78 48       	ld.w	r8,r12[0x10]
8000999c:	76 46       	ld.w	r6,r11[0x10]
8000999e:	0c 38       	cp.w	r8,r6
800099a0:	c0 34       	brge	800099a6 <quorem+0x12>
800099a2:	30 0c       	mov	r12,0
800099a4:	c8 58       	rjmp	80009aae <quorem+0x11a>
800099a6:	ec c2 ff fc 	sub	r2,r6,-4
800099aa:	f6 c3 ff ec 	sub	r3,r11,-20
800099ae:	f6 02 03 29 	ld.w	r9,r11[r2<<0x2]
800099b2:	f8 02 03 2c 	ld.w	r12,r12[r2<<0x2]
800099b6:	2f f9       	sub	r9,-1
800099b8:	20 16       	sub	r6,1
800099ba:	f8 09 0d 08 	divu	r8,r12,r9
800099be:	f6 02 00 22 	add	r2,r11,r2<<0x2
800099c2:	ee c4 ff ec 	sub	r4,r7,-20
800099c6:	10 95       	mov	r5,r8
800099c8:	58 08       	cp.w	r8,0
800099ca:	c4 10       	breq	80009a4c <quorem+0xb8>
800099cc:	30 09       	mov	r9,0
800099ce:	06 9a       	mov	r10,r3
800099d0:	08 98       	mov	r8,r4
800099d2:	12 91       	mov	r1,r9
800099d4:	50 0b       	stdsp	sp[0x0],r11
800099d6:	70 0e       	ld.w	lr,r8[0x0]
800099d8:	b1 8e       	lsr	lr,0x10
800099da:	50 1e       	stdsp	sp[0x4],lr
800099dc:	15 0e       	ld.w	lr,r10++
800099de:	fc 00 16 10 	lsr	r0,lr,0x10
800099e2:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
800099e6:	ea 0e 03 41 	mac	r1,r5,lr
800099ea:	fd d1 c0 10 	bfextu	lr,r1,0x0,0x10
800099ee:	b1 81       	lsr	r1,0x10
800099f0:	40 1b       	lddsp	r11,sp[0x4]
800099f2:	ea 00 02 40 	mul	r0,r5,r0
800099f6:	e2 00 00 00 	add	r0,r1,r0
800099fa:	e3 d0 c0 10 	bfextu	r1,r0,0x0,0x10
800099fe:	02 1b       	sub	r11,r1
80009a00:	50 1b       	stdsp	sp[0x4],r11
80009a02:	70 0b       	ld.w	r11,r8[0x0]
80009a04:	e3 db c0 10 	bfextu	r1,r11,0x0,0x10
80009a08:	02 09       	add	r9,r1
80009a0a:	f2 0e 01 0e 	sub	lr,r9,lr
80009a0e:	b0 1e       	st.h	r8[0x2],lr
80009a10:	fc 09 14 10 	asr	r9,lr,0x10
80009a14:	40 1e       	lddsp	lr,sp[0x4]
80009a16:	fc 09 00 09 	add	r9,lr,r9
80009a1a:	b0 09       	st.h	r8[0x0],r9
80009a1c:	e0 01 16 10 	lsr	r1,r0,0x10
80009a20:	2f c8       	sub	r8,-4
80009a22:	b1 49       	asr	r9,0x10
80009a24:	04 3a       	cp.w	r10,r2
80009a26:	fe 98 ff d8 	brls	800099d6 <quorem+0x42>
80009a2a:	40 0b       	lddsp	r11,sp[0x0]
80009a2c:	58 0c       	cp.w	r12,0
80009a2e:	c0 f1       	brne	80009a4c <quorem+0xb8>
80009a30:	ec c8 ff fb 	sub	r8,r6,-5
80009a34:	ee 08 00 28 	add	r8,r7,r8<<0x2
80009a38:	c0 28       	rjmp	80009a3c <quorem+0xa8>
80009a3a:	20 16       	sub	r6,1
80009a3c:	20 48       	sub	r8,4
80009a3e:	08 38       	cp.w	r8,r4
80009a40:	e0 88 00 05 	brls	80009a4a <quorem+0xb6>
80009a44:	70 09       	ld.w	r9,r8[0x0]
80009a46:	58 09       	cp.w	r9,0
80009a48:	cf 90       	breq	80009a3a <quorem+0xa6>
80009a4a:	8f 46       	st.w	r7[0x10],r6
80009a4c:	0e 9c       	mov	r12,r7
80009a4e:	e0 a0 0a d8 	rcall	8000affe <__mcmp>
80009a52:	c2 d5       	brlt	80009aac <quorem+0x118>
80009a54:	2f f5       	sub	r5,-1
80009a56:	08 98       	mov	r8,r4
80009a58:	30 09       	mov	r9,0
80009a5a:	07 0b       	ld.w	r11,r3++
80009a5c:	f6 0a 16 10 	lsr	r10,r11,0x10
80009a60:	70 0c       	ld.w	r12,r8[0x0]
80009a62:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
80009a66:	f8 0e 16 10 	lsr	lr,r12,0x10
80009a6a:	14 1e       	sub	lr,r10
80009a6c:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
80009a70:	16 1a       	sub	r10,r11
80009a72:	12 0a       	add	r10,r9
80009a74:	b0 1a       	st.h	r8[0x2],r10
80009a76:	b1 4a       	asr	r10,0x10
80009a78:	fc 0a 00 09 	add	r9,lr,r10
80009a7c:	b0 09       	st.h	r8[0x0],r9
80009a7e:	2f c8       	sub	r8,-4
80009a80:	b1 49       	asr	r9,0x10
80009a82:	04 33       	cp.w	r3,r2
80009a84:	fe 98 ff eb 	brls	80009a5a <quorem+0xc6>
80009a88:	ec c8 ff fb 	sub	r8,r6,-5
80009a8c:	ee 08 03 29 	ld.w	r9,r7[r8<<0x2]
80009a90:	58 09       	cp.w	r9,0
80009a92:	c0 d1       	brne	80009aac <quorem+0x118>
80009a94:	ee 08 00 28 	add	r8,r7,r8<<0x2
80009a98:	c0 28       	rjmp	80009a9c <quorem+0x108>
80009a9a:	20 16       	sub	r6,1
80009a9c:	20 48       	sub	r8,4
80009a9e:	08 38       	cp.w	r8,r4
80009aa0:	e0 88 00 05 	brls	80009aaa <quorem+0x116>
80009aa4:	70 09       	ld.w	r9,r8[0x0]
80009aa6:	58 09       	cp.w	r9,0
80009aa8:	cf 90       	breq	80009a9a <quorem+0x106>
80009aaa:	8f 46       	st.w	r7[0x10],r6
80009aac:	0a 9c       	mov	r12,r5
80009aae:	2f ed       	sub	sp,-8
80009ab0:	d8 32       	popm	r0-r7,pc
80009ab2:	d7 03       	nop

80009ab4 <_dtoa_r>:
80009ab4:	d4 31       	pushm	r0-r7,lr
80009ab6:	21 ad       	sub	sp,104
80009ab8:	fa c4 ff 74 	sub	r4,sp,-140
80009abc:	18 97       	mov	r7,r12
80009abe:	16 95       	mov	r5,r11
80009ac0:	68 2c       	ld.w	r12,r4[0x8]
80009ac2:	50 c9       	stdsp	sp[0x30],r9
80009ac4:	68 16       	ld.w	r6,r4[0x4]
80009ac6:	68 09       	ld.w	r9,r4[0x0]
80009ac8:	50 e8       	stdsp	sp[0x38],r8
80009aca:	14 94       	mov	r4,r10
80009acc:	51 2c       	stdsp	sp[0x48],r12
80009ace:	fa e5 00 08 	st.d	sp[8],r4
80009ad2:	51 59       	stdsp	sp[0x54],r9
80009ad4:	6e 95       	ld.w	r5,r7[0x24]
80009ad6:	58 05       	cp.w	r5,0
80009ad8:	c0 91       	brne	80009aea <_dtoa_r+0x36>
80009ada:	31 0c       	mov	r12,16
80009adc:	fe b0 e8 cc 	rcall	80006c74 <malloc>
80009ae0:	99 35       	st.w	r12[0xc],r5
80009ae2:	8f 9c       	st.w	r7[0x24],r12
80009ae4:	99 15       	st.w	r12[0x4],r5
80009ae6:	99 25       	st.w	r12[0x8],r5
80009ae8:	99 05       	st.w	r12[0x0],r5
80009aea:	6e 99       	ld.w	r9,r7[0x24]
80009aec:	72 08       	ld.w	r8,r9[0x0]
80009aee:	58 08       	cp.w	r8,0
80009af0:	c0 f0       	breq	80009b0e <_dtoa_r+0x5a>
80009af2:	72 1a       	ld.w	r10,r9[0x4]
80009af4:	91 1a       	st.w	r8[0x4],r10
80009af6:	30 1a       	mov	r10,1
80009af8:	72 19       	ld.w	r9,r9[0x4]
80009afa:	f4 09 09 49 	lsl	r9,r10,r9
80009afe:	10 9b       	mov	r11,r8
80009b00:	91 29       	st.w	r8[0x8],r9
80009b02:	0e 9c       	mov	r12,r7
80009b04:	e0 a0 0a 96 	rcall	8000b030 <_Bfree>
80009b08:	6e 98       	ld.w	r8,r7[0x24]
80009b0a:	30 09       	mov	r9,0
80009b0c:	91 09       	st.w	r8[0x0],r9
80009b0e:	40 28       	lddsp	r8,sp[0x8]
80009b10:	10 94       	mov	r4,r8
80009b12:	58 08       	cp.w	r8,0
80009b14:	c0 64       	brge	80009b20 <_dtoa_r+0x6c>
80009b16:	f1 d8 c0 1f 	bfextu	r8,r8,0x0,0x1f
80009b1a:	50 28       	stdsp	sp[0x8],r8
80009b1c:	30 18       	mov	r8,1
80009b1e:	c0 28       	rjmp	80009b22 <_dtoa_r+0x6e>
80009b20:	30 08       	mov	r8,0
80009b22:	8d 08       	st.w	r6[0x0],r8
80009b24:	fc 1c 7f f0 	movh	r12,0x7ff0
80009b28:	40 26       	lddsp	r6,sp[0x8]
80009b2a:	0c 98       	mov	r8,r6
80009b2c:	e6 18 7f f0 	andh	r8,0x7ff0,COH
80009b30:	18 38       	cp.w	r8,r12
80009b32:	c1 e1       	brne	80009b6e <_dtoa_r+0xba>
80009b34:	e0 68 27 0f 	mov	r8,9999
80009b38:	41 5b       	lddsp	r11,sp[0x54]
80009b3a:	97 08       	st.w	r11[0x0],r8
80009b3c:	40 3a       	lddsp	r10,sp[0xc]
80009b3e:	58 0a       	cp.w	r10,0
80009b40:	c0 61       	brne	80009b4c <_dtoa_r+0x98>
80009b42:	ed d6 c0 14 	bfextu	r6,r6,0x0,0x14
80009b46:	c0 31       	brne	80009b4c <_dtoa_r+0x98>
80009b48:	4a cc       	lddpc	r12,80009bf8 <_dtoa_r+0x144>
80009b4a:	c0 28       	rjmp	80009b4e <_dtoa_r+0x9a>
80009b4c:	4a cc       	lddpc	r12,80009bfc <_dtoa_r+0x148>
80009b4e:	41 29       	lddsp	r9,sp[0x48]
80009b50:	58 09       	cp.w	r9,0
80009b52:	e0 80 05 9e 	breq	8000a68e <_dtoa_r+0xbda>
80009b56:	f8 c8 ff fd 	sub	r8,r12,-3
80009b5a:	f8 c9 ff f8 	sub	r9,r12,-8
80009b5e:	11 8b       	ld.ub	r11,r8[0x0]
80009b60:	30 0a       	mov	r10,0
80009b62:	41 25       	lddsp	r5,sp[0x48]
80009b64:	f4 0b 18 00 	cp.b	r11,r10
80009b68:	f2 08 17 10 	movne	r8,r9
80009b6c:	c1 58       	rjmp	80009b96 <_dtoa_r+0xe2>
80009b6e:	fa ea 00 08 	ld.d	r10,sp[8]
80009b72:	30 08       	mov	r8,0
80009b74:	fa eb 00 3c 	st.d	sp[60],r10
80009b78:	30 09       	mov	r9,0
80009b7a:	e0 a0 10 ce 	rcall	8000bd16 <__avr32_f64_cmp_eq>
80009b7e:	c0 f0       	breq	80009b9c <_dtoa_r+0xe8>
80009b80:	30 18       	mov	r8,1
80009b82:	41 5a       	lddsp	r10,sp[0x54]
80009b84:	95 08       	st.w	r10[0x0],r8
80009b86:	49 fc       	lddpc	r12,80009c00 <_dtoa_r+0x14c>
80009b88:	41 29       	lddsp	r9,sp[0x48]
80009b8a:	f8 08 00 08 	add	r8,r12,r8
80009b8e:	58 09       	cp.w	r9,0
80009b90:	e0 80 05 7f 	breq	8000a68e <_dtoa_r+0xbda>
80009b94:	12 95       	mov	r5,r9
80009b96:	8b 08       	st.w	r5[0x0],r8
80009b98:	e0 8f 05 7b 	bral	8000a68e <_dtoa_r+0xbda>
80009b9c:	fa c8 ff 9c 	sub	r8,sp,-100
80009ba0:	fa c9 ff a0 	sub	r9,sp,-96
80009ba4:	fa ea 00 3c 	ld.d	r10,sp[60]
80009ba8:	0e 9c       	mov	r12,r7
80009baa:	eb d6 c2 8b 	bfextu	r5,r6,0x14,0xb
80009bae:	e0 a0 0a 93 	rcall	8000b0d4 <__d2b>
80009bb2:	18 93       	mov	r3,r12
80009bb4:	58 05       	cp.w	r5,0
80009bb6:	c0 d0       	breq	80009bd0 <_dtoa_r+0x11c>
80009bb8:	fa ea 00 3c 	ld.d	r10,sp[60]
80009bbc:	30 04       	mov	r4,0
80009bbe:	f1 db c0 14 	bfextu	r8,r11,0x0,0x14
80009bc2:	ea c5 03 ff 	sub	r5,r5,1023
80009bc6:	10 9b       	mov	r11,r8
80009bc8:	51 74       	stdsp	sp[0x5c],r4
80009bca:	ea 1b 3f f0 	orh	r11,0x3ff0
80009bce:	c2 a8       	rjmp	80009c22 <_dtoa_r+0x16e>
80009bd0:	41 88       	lddsp	r8,sp[0x60]
80009bd2:	41 9c       	lddsp	r12,sp[0x64]
80009bd4:	10 0c       	add	r12,r8
80009bd6:	f8 c5 fb ce 	sub	r5,r12,-1074
80009bda:	e0 45 00 20 	cp.w	r5,32
80009bde:	e0 8a 00 13 	brle	80009c04 <_dtoa_r+0x150>
80009be2:	f8 cc fb ee 	sub	r12,r12,-1042
80009be6:	40 3b       	lddsp	r11,sp[0xc]
80009be8:	ea 08 11 40 	rsub	r8,r5,64
80009bec:	f6 0c 0a 4c 	lsr	r12,r11,r12
80009bf0:	ec 08 09 46 	lsl	r6,r6,r8
80009bf4:	0c 4c       	or	r12,r6
80009bf6:	c0 c8       	rjmp	80009c0e <_dtoa_r+0x15a>
80009bf8:	80 01       	ld.sh	r1,r0[0x0]
80009bfa:	61 d0       	ld.w	r0,r0[0x74]
80009bfc:	80 01       	ld.sh	r1,r0[0x0]
80009bfe:	61 dc       	ld.w	r12,r0[0x74]
80009c00:	80 01       	ld.sh	r1,r0[0x0]
80009c02:	60 ac       	ld.w	r12,r0[0x28]
80009c04:	ea 0c 11 20 	rsub	r12,r5,32
80009c08:	40 3a       	lddsp	r10,sp[0xc]
80009c0a:	f4 0c 09 4c 	lsl	r12,r10,r12
80009c0e:	e0 a0 10 10 	rcall	8000bc2e <__avr32_u32_to_f64>
80009c12:	fc 18 fe 10 	movh	r8,0xfe10
80009c16:	30 19       	mov	r9,1
80009c18:	ea c5 04 33 	sub	r5,r5,1075
80009c1c:	f0 0b 00 0b 	add	r11,r8,r11
80009c20:	51 79       	stdsp	sp[0x5c],r9
80009c22:	30 08       	mov	r8,0
80009c24:	fc 19 3f f8 	movh	r9,0x3ff8
80009c28:	e0 a0 0e 98 	rcall	8000b958 <__avr32_f64_sub>
80009c2c:	e0 68 43 61 	mov	r8,17249
80009c30:	ea 18 63 6f 	orh	r8,0x636f
80009c34:	e0 69 87 a7 	mov	r9,34727
80009c38:	ea 19 3f d2 	orh	r9,0x3fd2
80009c3c:	e0 a0 0d a2 	rcall	8000b780 <__avr32_f64_mul>
80009c40:	e0 68 c8 b3 	mov	r8,51379
80009c44:	ea 18 8b 60 	orh	r8,0x8b60
80009c48:	e0 69 8a 28 	mov	r9,35368
80009c4c:	ea 19 3f c6 	orh	r9,0x3fc6
80009c50:	e0 a0 0f 52 	rcall	8000baf4 <__avr32_f64_add>
80009c54:	0a 9c       	mov	r12,r5
80009c56:	14 90       	mov	r0,r10
80009c58:	16 91       	mov	r1,r11
80009c5a:	e0 a0 0f ee 	rcall	8000bc36 <__avr32_s32_to_f64>
80009c5e:	e0 68 79 fb 	mov	r8,31227
80009c62:	ea 18 50 9f 	orh	r8,0x509f
80009c66:	e0 69 44 13 	mov	r9,17427
80009c6a:	ea 19 3f d3 	orh	r9,0x3fd3
80009c6e:	e0 a0 0d 89 	rcall	8000b780 <__avr32_f64_mul>
80009c72:	14 98       	mov	r8,r10
80009c74:	16 99       	mov	r9,r11
80009c76:	00 9a       	mov	r10,r0
80009c78:	02 9b       	mov	r11,r1
80009c7a:	e0 a0 0f 3d 	rcall	8000baf4 <__avr32_f64_add>
80009c7e:	14 90       	mov	r0,r10
80009c80:	16 91       	mov	r1,r11
80009c82:	e0 a0 0f c3 	rcall	8000bc08 <__avr32_f64_to_s32>
80009c86:	30 08       	mov	r8,0
80009c88:	18 96       	mov	r6,r12
80009c8a:	30 09       	mov	r9,0
80009c8c:	00 9a       	mov	r10,r0
80009c8e:	02 9b       	mov	r11,r1
80009c90:	e0 a0 10 8a 	rcall	8000bda4 <__avr32_f64_cmp_lt>
80009c94:	c0 c0       	breq	80009cac <_dtoa_r+0x1f8>
80009c96:	0c 9c       	mov	r12,r6
80009c98:	e0 a0 0f cf 	rcall	8000bc36 <__avr32_s32_to_f64>
80009c9c:	14 98       	mov	r8,r10
80009c9e:	16 99       	mov	r9,r11
80009ca0:	00 9a       	mov	r10,r0
80009ca2:	02 9b       	mov	r11,r1
80009ca4:	e0 a0 10 39 	rcall	8000bd16 <__avr32_f64_cmp_eq>
80009ca8:	f7 b6 00 01 	subeq	r6,1
80009cac:	59 66       	cp.w	r6,22
80009cae:	e0 88 00 05 	brls	80009cb8 <_dtoa_r+0x204>
80009cb2:	30 18       	mov	r8,1
80009cb4:	51 48       	stdsp	sp[0x50],r8
80009cb6:	c1 28       	rjmp	80009cda <_dtoa_r+0x226>
80009cb8:	4c 08       	lddpc	r8,80009db8 <_dtoa_r+0x304>
80009cba:	fa ea 00 3c 	ld.d	r10,sp[60]
80009cbe:	f0 06 02 38 	ld.d	r8,r8[r6<<0x3]
80009cc2:	e0 a0 10 71 	rcall	8000bda4 <__avr32_f64_cmp_lt>
80009cc6:	f9 b4 00 00 	moveq	r4,0
80009cca:	fb f4 0a 14 	st.weq	sp[0x50],r4
80009cce:	f7 b6 01 01 	subne	r6,1
80009cd2:	f9 bc 01 00 	movne	r12,0
80009cd6:	fb fc 1a 14 	st.wne	sp[0x50],r12
80009cda:	41 90       	lddsp	r0,sp[0x64]
80009cdc:	20 10       	sub	r0,1
80009cde:	0a 10       	sub	r0,r5
80009ce0:	c0 46       	brmi	80009ce8 <_dtoa_r+0x234>
80009ce2:	50 40       	stdsp	sp[0x10],r0
80009ce4:	30 00       	mov	r0,0
80009ce6:	c0 48       	rjmp	80009cee <_dtoa_r+0x23a>
80009ce8:	30 0b       	mov	r11,0
80009cea:	5c 30       	neg	r0
80009cec:	50 4b       	stdsp	sp[0x10],r11
80009cee:	ec 02 11 00 	rsub	r2,r6,0
80009cf2:	58 06       	cp.w	r6,0
80009cf4:	fb fa 40 04 	ld.wge	r10,sp[0x10]
80009cf8:	f5 d6 e4 0a 	addge	r10,r10,r6
80009cfc:	fb fa 4a 04 	st.wge	sp[0x10],r10
80009d00:	fb f6 4a 11 	st.wge	sp[0x44],r6
80009d04:	f9 b2 04 00 	movge	r2,0
80009d08:	e1 d6 e5 10 	sublt	r0,r0,r6
80009d0c:	f9 b9 05 00 	movlt	r9,0
80009d10:	fb f9 5a 11 	st.wlt	sp[0x44],r9
80009d14:	40 c8       	lddsp	r8,sp[0x30]
80009d16:	58 98       	cp.w	r8,9
80009d18:	e0 8b 00 20 	brhi	80009d58 <_dtoa_r+0x2a4>
80009d1c:	58 58       	cp.w	r8,5
80009d1e:	f9 b4 0a 01 	movle	r4,1
80009d22:	fb f5 90 0c 	ld.wgt	r5,sp[0x30]
80009d26:	f7 b5 09 04 	subgt	r5,4
80009d2a:	fb f5 9a 0c 	st.wgt	sp[0x30],r5
80009d2e:	f9 b4 09 00 	movgt	r4,0
80009d32:	40 cc       	lddsp	r12,sp[0x30]
80009d34:	58 3c       	cp.w	r12,3
80009d36:	c2 d0       	breq	80009d90 <_dtoa_r+0x2dc>
80009d38:	e0 89 00 05 	brgt	80009d42 <_dtoa_r+0x28e>
80009d3c:	58 2c       	cp.w	r12,2
80009d3e:	c1 01       	brne	80009d5e <_dtoa_r+0x2aa>
80009d40:	c1 88       	rjmp	80009d70 <_dtoa_r+0x2bc>
80009d42:	40 cb       	lddsp	r11,sp[0x30]
80009d44:	58 4b       	cp.w	r11,4
80009d46:	c0 60       	breq	80009d52 <_dtoa_r+0x29e>
80009d48:	58 5b       	cp.w	r11,5
80009d4a:	c0 a1       	brne	80009d5e <_dtoa_r+0x2aa>
80009d4c:	30 1a       	mov	r10,1
80009d4e:	50 da       	stdsp	sp[0x34],r10
80009d50:	c2 28       	rjmp	80009d94 <_dtoa_r+0x2e0>
80009d52:	30 19       	mov	r9,1
80009d54:	50 d9       	stdsp	sp[0x34],r9
80009d56:	c0 f8       	rjmp	80009d74 <_dtoa_r+0x2c0>
80009d58:	30 08       	mov	r8,0
80009d5a:	30 14       	mov	r4,1
80009d5c:	50 c8       	stdsp	sp[0x30],r8
80009d5e:	3f f5       	mov	r5,-1
80009d60:	30 1c       	mov	r12,1
80009d62:	30 0b       	mov	r11,0
80009d64:	50 95       	stdsp	sp[0x24],r5
80009d66:	50 dc       	stdsp	sp[0x34],r12
80009d68:	0a 91       	mov	r1,r5
80009d6a:	31 28       	mov	r8,18
80009d6c:	50 eb       	stdsp	sp[0x38],r11
80009d6e:	c2 08       	rjmp	80009dae <_dtoa_r+0x2fa>
80009d70:	30 0a       	mov	r10,0
80009d72:	50 da       	stdsp	sp[0x34],r10
80009d74:	40 e9       	lddsp	r9,sp[0x38]
80009d76:	58 09       	cp.w	r9,0
80009d78:	e0 89 00 07 	brgt	80009d86 <_dtoa_r+0x2d2>
80009d7c:	30 18       	mov	r8,1
80009d7e:	50 98       	stdsp	sp[0x24],r8
80009d80:	10 91       	mov	r1,r8
80009d82:	50 e8       	stdsp	sp[0x38],r8
80009d84:	c1 58       	rjmp	80009dae <_dtoa_r+0x2fa>
80009d86:	40 e5       	lddsp	r5,sp[0x38]
80009d88:	50 95       	stdsp	sp[0x24],r5
80009d8a:	0a 91       	mov	r1,r5
80009d8c:	0a 98       	mov	r8,r5
80009d8e:	c1 08       	rjmp	80009dae <_dtoa_r+0x2fa>
80009d90:	30 0c       	mov	r12,0
80009d92:	50 dc       	stdsp	sp[0x34],r12
80009d94:	40 eb       	lddsp	r11,sp[0x38]
80009d96:	ec 0b 00 0b 	add	r11,r6,r11
80009d9a:	50 9b       	stdsp	sp[0x24],r11
80009d9c:	16 98       	mov	r8,r11
80009d9e:	2f f8       	sub	r8,-1
80009da0:	58 08       	cp.w	r8,0
80009da2:	e0 89 00 05 	brgt	80009dac <_dtoa_r+0x2f8>
80009da6:	10 91       	mov	r1,r8
80009da8:	30 18       	mov	r8,1
80009daa:	c0 28       	rjmp	80009dae <_dtoa_r+0x2fa>
80009dac:	10 91       	mov	r1,r8
80009dae:	30 09       	mov	r9,0
80009db0:	6e 9a       	ld.w	r10,r7[0x24]
80009db2:	95 19       	st.w	r10[0x4],r9
80009db4:	30 49       	mov	r9,4
80009db6:	c0 78       	rjmp	80009dc4 <_dtoa_r+0x310>
80009db8:	80 01       	ld.sh	r1,r0[0x0]
80009dba:	62 90       	ld.w	r0,r1[0x24]
80009dbc:	6a 1a       	ld.w	r10,r5[0x4]
80009dbe:	a1 79       	lsl	r9,0x1
80009dc0:	2f fa       	sub	r10,-1
80009dc2:	8b 1a       	st.w	r5[0x4],r10
80009dc4:	6e 95       	ld.w	r5,r7[0x24]
80009dc6:	f2 ca ff ec 	sub	r10,r9,-20
80009dca:	10 3a       	cp.w	r10,r8
80009dcc:	fe 98 ff f8 	brls	80009dbc <_dtoa_r+0x308>
80009dd0:	6a 1b       	ld.w	r11,r5[0x4]
80009dd2:	0e 9c       	mov	r12,r7
80009dd4:	e0 a0 09 48 	rcall	8000b064 <_Balloc>
80009dd8:	58 e1       	cp.w	r1,14
80009dda:	5f 88       	srls	r8
80009ddc:	8b 0c       	st.w	r5[0x0],r12
80009dde:	f1 e4 00 04 	and	r4,r8,r4
80009de2:	6e 98       	ld.w	r8,r7[0x24]
80009de4:	70 08       	ld.w	r8,r8[0x0]
80009de6:	50 88       	stdsp	sp[0x20],r8
80009de8:	e0 80 01 82 	breq	8000a0ec <_dtoa_r+0x638>
80009dec:	58 06       	cp.w	r6,0
80009dee:	e0 8a 00 40 	brle	80009e6e <_dtoa_r+0x3ba>
80009df2:	f3 d6 c0 04 	bfextu	r9,r6,0x0,0x4
80009df6:	4c b8       	lddpc	r8,80009f20 <_dtoa_r+0x46c>
80009df8:	f0 09 02 34 	ld.d	r4,r8[r9<<0x3]
80009dfc:	fa e5 00 18 	st.d	sp[24],r4
80009e00:	ec 04 14 04 	asr	r4,r6,0x4
80009e04:	ed b4 00 04 	bld	r4,0x4
80009e08:	c0 30       	breq	80009e0e <_dtoa_r+0x35a>
80009e0a:	30 25       	mov	r5,2
80009e0c:	c0 f8       	rjmp	80009e2a <_dtoa_r+0x376>
80009e0e:	4c 68       	lddpc	r8,80009f24 <_dtoa_r+0x470>
80009e10:	f0 e8 00 20 	ld.d	r8,r8[32]
80009e14:	fa ea 00 3c 	ld.d	r10,sp[60]
80009e18:	e9 d4 c0 04 	bfextu	r4,r4,0x0,0x4
80009e1c:	e0 a0 0f f8 	rcall	8000be0c <__avr32_f64_div>
80009e20:	30 35       	mov	r5,3
80009e22:	14 98       	mov	r8,r10
80009e24:	16 99       	mov	r9,r11
80009e26:	fa e9 00 08 	st.d	sp[8],r8
80009e2a:	4b fc       	lddpc	r12,80009f24 <_dtoa_r+0x470>
80009e2c:	50 a3       	stdsp	sp[0x28],r3
80009e2e:	0c 93       	mov	r3,r6
80009e30:	18 96       	mov	r6,r12
80009e32:	c0 f8       	rjmp	80009e50 <_dtoa_r+0x39c>
80009e34:	fa ea 00 18 	ld.d	r10,sp[24]
80009e38:	ed b4 00 00 	bld	r4,0x0
80009e3c:	c0 81       	brne	80009e4c <_dtoa_r+0x398>
80009e3e:	ec e8 00 00 	ld.d	r8,r6[0]
80009e42:	2f f5       	sub	r5,-1
80009e44:	e0 a0 0c 9e 	rcall	8000b780 <__avr32_f64_mul>
80009e48:	fa eb 00 18 	st.d	sp[24],r10
80009e4c:	a1 54       	asr	r4,0x1
80009e4e:	2f 86       	sub	r6,-8
80009e50:	58 04       	cp.w	r4,0
80009e52:	cf 11       	brne	80009e34 <_dtoa_r+0x380>
80009e54:	fa e8 00 18 	ld.d	r8,sp[24]
80009e58:	fa ea 00 08 	ld.d	r10,sp[8]
80009e5c:	06 96       	mov	r6,r3
80009e5e:	e0 a0 0f d7 	rcall	8000be0c <__avr32_f64_div>
80009e62:	40 a3       	lddsp	r3,sp[0x28]
80009e64:	14 98       	mov	r8,r10
80009e66:	16 99       	mov	r9,r11
80009e68:	fa e9 00 08 	st.d	sp[8],r8
80009e6c:	c2 d8       	rjmp	80009ec6 <_dtoa_r+0x412>
80009e6e:	ec 08 11 00 	rsub	r8,r6,0
80009e72:	c0 31       	brne	80009e78 <_dtoa_r+0x3c4>
80009e74:	30 25       	mov	r5,2
80009e76:	c2 88       	rjmp	80009ec6 <_dtoa_r+0x412>
80009e78:	4a bc       	lddpc	r12,80009f24 <_dtoa_r+0x470>
80009e7a:	f0 04 14 04 	asr	r4,r8,0x4
80009e7e:	50 1c       	stdsp	sp[0x4],r12
80009e80:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
80009e84:	4a 79       	lddpc	r9,80009f20 <_dtoa_r+0x46c>
80009e86:	fa ea 00 3c 	ld.d	r10,sp[60]
80009e8a:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
80009e8e:	e0 a0 0c 79 	rcall	8000b780 <__avr32_f64_mul>
80009e92:	40 1c       	lddsp	r12,sp[0x4]
80009e94:	50 63       	stdsp	sp[0x18],r3
80009e96:	30 25       	mov	r5,2
80009e98:	0c 93       	mov	r3,r6
80009e9a:	fa eb 00 08 	st.d	sp[8],r10
80009e9e:	18 96       	mov	r6,r12
80009ea0:	c0 f8       	rjmp	80009ebe <_dtoa_r+0x40a>
80009ea2:	fa ea 00 08 	ld.d	r10,sp[8]
80009ea6:	ed b4 00 00 	bld	r4,0x0
80009eaa:	c0 81       	brne	80009eba <_dtoa_r+0x406>
80009eac:	ec e8 00 00 	ld.d	r8,r6[0]
80009eb0:	2f f5       	sub	r5,-1
80009eb2:	e0 a0 0c 67 	rcall	8000b780 <__avr32_f64_mul>
80009eb6:	fa eb 00 08 	st.d	sp[8],r10
80009eba:	a1 54       	asr	r4,0x1
80009ebc:	2f 86       	sub	r6,-8
80009ebe:	58 04       	cp.w	r4,0
80009ec0:	cf 11       	brne	80009ea2 <_dtoa_r+0x3ee>
80009ec2:	06 96       	mov	r6,r3
80009ec4:	40 63       	lddsp	r3,sp[0x18]
80009ec6:	41 4a       	lddsp	r10,sp[0x50]
80009ec8:	58 0a       	cp.w	r10,0
80009eca:	c2 f0       	breq	80009f28 <_dtoa_r+0x474>
80009ecc:	fa e8 00 08 	ld.d	r8,sp[8]
80009ed0:	58 01       	cp.w	r1,0
80009ed2:	5f 94       	srgt	r4
80009ed4:	fa e9 00 18 	st.d	sp[24],r8
80009ed8:	30 08       	mov	r8,0
80009eda:	fc 19 3f f0 	movh	r9,0x3ff0
80009ede:	fa ea 00 18 	ld.d	r10,sp[24]
80009ee2:	e0 a0 0f 61 	rcall	8000bda4 <__avr32_f64_cmp_lt>
80009ee6:	f9 bc 00 00 	moveq	r12,0
80009eea:	f9 bc 01 01 	movne	r12,1
80009eee:	e9 ec 00 0c 	and	r12,r4,r12
80009ef2:	c1 b0       	breq	80009f28 <_dtoa_r+0x474>
80009ef4:	40 98       	lddsp	r8,sp[0x24]
80009ef6:	58 08       	cp.w	r8,0
80009ef8:	e0 8a 00 f6 	brle	8000a0e4 <_dtoa_r+0x630>
80009efc:	30 08       	mov	r8,0
80009efe:	fc 19 40 24 	movh	r9,0x4024
80009f02:	ec c4 00 01 	sub	r4,r6,1
80009f06:	fa ea 00 18 	ld.d	r10,sp[24]
80009f0a:	2f f5       	sub	r5,-1
80009f0c:	50 64       	stdsp	sp[0x18],r4
80009f0e:	e0 a0 0c 39 	rcall	8000b780 <__avr32_f64_mul>
80009f12:	40 94       	lddsp	r4,sp[0x24]
80009f14:	14 98       	mov	r8,r10
80009f16:	16 99       	mov	r9,r11
80009f18:	fa e9 00 08 	st.d	sp[8],r8
80009f1c:	c0 88       	rjmp	80009f2c <_dtoa_r+0x478>
80009f1e:	d7 03       	nop
80009f20:	80 01       	ld.sh	r1,r0[0x0]
80009f22:	62 90       	ld.w	r0,r1[0x24]
80009f24:	80 01       	ld.sh	r1,r0[0x0]
80009f26:	63 58       	ld.w	r8,r1[0x54]
80009f28:	50 66       	stdsp	sp[0x18],r6
80009f2a:	02 94       	mov	r4,r1
80009f2c:	0a 9c       	mov	r12,r5
80009f2e:	e0 a0 0e 84 	rcall	8000bc36 <__avr32_s32_to_f64>
80009f32:	fa e8 00 08 	ld.d	r8,sp[8]
80009f36:	e0 a0 0c 25 	rcall	8000b780 <__avr32_f64_mul>
80009f3a:	30 08       	mov	r8,0
80009f3c:	fc 19 40 1c 	movh	r9,0x401c
80009f40:	e0 a0 0d da 	rcall	8000baf4 <__avr32_f64_add>
80009f44:	14 98       	mov	r8,r10
80009f46:	16 99       	mov	r9,r11
80009f48:	fa e9 00 28 	st.d	sp[40],r8
80009f4c:	fc 18 fc c0 	movh	r8,0xfcc0
80009f50:	40 a5       	lddsp	r5,sp[0x28]
80009f52:	10 05       	add	r5,r8
80009f54:	50 a5       	stdsp	sp[0x28],r5
80009f56:	58 04       	cp.w	r4,0
80009f58:	c2 11       	brne	80009f9a <_dtoa_r+0x4e6>
80009f5a:	fa ea 00 08 	ld.d	r10,sp[8]
80009f5e:	30 08       	mov	r8,0
80009f60:	fc 19 40 14 	movh	r9,0x4014
80009f64:	e0 a0 0c fa 	rcall	8000b958 <__avr32_f64_sub>
80009f68:	40 bc       	lddsp	r12,sp[0x2c]
80009f6a:	fa eb 00 08 	st.d	sp[8],r10
80009f6e:	14 98       	mov	r8,r10
80009f70:	16 99       	mov	r9,r11
80009f72:	18 9a       	mov	r10,r12
80009f74:	0a 9b       	mov	r11,r5
80009f76:	e0 a0 0f 17 	rcall	8000bda4 <__avr32_f64_cmp_lt>
80009f7a:	e0 81 02 54 	brne	8000a422 <_dtoa_r+0x96e>
80009f7e:	0a 98       	mov	r8,r5
80009f80:	40 b9       	lddsp	r9,sp[0x2c]
80009f82:	ee 18 80 00 	eorh	r8,0x8000
80009f86:	fa ea 00 08 	ld.d	r10,sp[8]
80009f8a:	10 95       	mov	r5,r8
80009f8c:	12 98       	mov	r8,r9
80009f8e:	0a 99       	mov	r9,r5
80009f90:	e0 a0 0f 0a 	rcall	8000bda4 <__avr32_f64_cmp_lt>
80009f94:	e0 81 02 3e 	brne	8000a410 <_dtoa_r+0x95c>
80009f98:	ca 68       	rjmp	8000a0e4 <_dtoa_r+0x630>
80009f9a:	4c e9       	lddpc	r9,8000a0d0 <_dtoa_r+0x61c>
80009f9c:	e8 c8 00 01 	sub	r8,r4,1
80009fa0:	40 d5       	lddsp	r5,sp[0x34]
80009fa2:	58 05       	cp.w	r5,0
80009fa4:	c4 f0       	breq	8000a042 <_dtoa_r+0x58e>
80009fa6:	30 0c       	mov	r12,0
80009fa8:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
80009fac:	51 3c       	stdsp	sp[0x4c],r12
80009fae:	30 0a       	mov	r10,0
80009fb0:	fc 1b 3f e0 	movh	r11,0x3fe0
80009fb4:	e0 a0 0f 2c 	rcall	8000be0c <__avr32_f64_div>
80009fb8:	fa e8 00 28 	ld.d	r8,sp[40]
80009fbc:	40 85       	lddsp	r5,sp[0x20]
80009fbe:	e0 a0 0c cd 	rcall	8000b958 <__avr32_f64_sub>
80009fc2:	fa eb 00 28 	st.d	sp[40],r10
80009fc6:	fa ea 00 08 	ld.d	r10,sp[8]
80009fca:	e0 a0 0e 1f 	rcall	8000bc08 <__avr32_f64_to_s32>
80009fce:	51 6c       	stdsp	sp[0x58],r12
80009fd0:	e0 a0 0e 33 	rcall	8000bc36 <__avr32_s32_to_f64>
80009fd4:	14 98       	mov	r8,r10
80009fd6:	16 99       	mov	r9,r11
80009fd8:	fa ea 00 08 	ld.d	r10,sp[8]
80009fdc:	e0 a0 0c be 	rcall	8000b958 <__avr32_f64_sub>
80009fe0:	fa eb 00 08 	st.d	sp[8],r10
80009fe4:	41 68       	lddsp	r8,sp[0x58]
80009fe6:	2d 08       	sub	r8,-48
80009fe8:	0a c8       	st.b	r5++,r8
80009fea:	41 39       	lddsp	r9,sp[0x4c]
80009fec:	2f f9       	sub	r9,-1
80009fee:	51 39       	stdsp	sp[0x4c],r9
80009ff0:	fa e8 00 28 	ld.d	r8,sp[40]
80009ff4:	e0 a0 0e d8 	rcall	8000bda4 <__avr32_f64_cmp_lt>
80009ff8:	e0 81 03 3a 	brne	8000a66c <_dtoa_r+0xbb8>
80009ffc:	fa e8 00 08 	ld.d	r8,sp[8]
8000a000:	30 0a       	mov	r10,0
8000a002:	fc 1b 3f f0 	movh	r11,0x3ff0
8000a006:	e0 a0 0c a9 	rcall	8000b958 <__avr32_f64_sub>
8000a00a:	fa e8 00 28 	ld.d	r8,sp[40]
8000a00e:	e0 a0 0e cb 	rcall	8000bda4 <__avr32_f64_cmp_lt>
8000a012:	fa ea 00 28 	ld.d	r10,sp[40]
8000a016:	30 08       	mov	r8,0
8000a018:	fc 19 40 24 	movh	r9,0x4024
8000a01c:	e0 81 00 da 	brne	8000a1d0 <_dtoa_r+0x71c>
8000a020:	41 3c       	lddsp	r12,sp[0x4c]
8000a022:	08 3c       	cp.w	r12,r4
8000a024:	c6 04       	brge	8000a0e4 <_dtoa_r+0x630>
8000a026:	e0 a0 0b ad 	rcall	8000b780 <__avr32_f64_mul>
8000a02a:	30 08       	mov	r8,0
8000a02c:	fa eb 00 28 	st.d	sp[40],r10
8000a030:	fc 19 40 24 	movh	r9,0x4024
8000a034:	fa ea 00 08 	ld.d	r10,sp[8]
8000a038:	e0 a0 0b a4 	rcall	8000b780 <__avr32_f64_mul>
8000a03c:	fa eb 00 08 	st.d	sp[8],r10
8000a040:	cc 3b       	rjmp	80009fc6 <_dtoa_r+0x512>
8000a042:	40 85       	lddsp	r5,sp[0x20]
8000a044:	08 05       	add	r5,r4
8000a046:	f2 08 02 3a 	ld.d	r10,r9[r8<<0x3]
8000a04a:	51 35       	stdsp	sp[0x4c],r5
8000a04c:	fa e8 00 28 	ld.d	r8,sp[40]
8000a050:	40 85       	lddsp	r5,sp[0x20]
8000a052:	e0 a0 0b 97 	rcall	8000b780 <__avr32_f64_mul>
8000a056:	fa eb 00 28 	st.d	sp[40],r10
8000a05a:	fa ea 00 08 	ld.d	r10,sp[8]
8000a05e:	e0 a0 0d d5 	rcall	8000bc08 <__avr32_f64_to_s32>
8000a062:	51 6c       	stdsp	sp[0x58],r12
8000a064:	e0 a0 0d e9 	rcall	8000bc36 <__avr32_s32_to_f64>
8000a068:	14 98       	mov	r8,r10
8000a06a:	16 99       	mov	r9,r11
8000a06c:	fa ea 00 08 	ld.d	r10,sp[8]
8000a070:	e0 a0 0c 74 	rcall	8000b958 <__avr32_f64_sub>
8000a074:	fa eb 00 08 	st.d	sp[8],r10
8000a078:	41 68       	lddsp	r8,sp[0x58]
8000a07a:	2d 08       	sub	r8,-48
8000a07c:	0a c8       	st.b	r5++,r8
8000a07e:	41 3c       	lddsp	r12,sp[0x4c]
8000a080:	18 35       	cp.w	r5,r12
8000a082:	c2 91       	brne	8000a0d4 <_dtoa_r+0x620>
8000a084:	30 08       	mov	r8,0
8000a086:	fc 19 3f e0 	movh	r9,0x3fe0
8000a08a:	fa ea 00 28 	ld.d	r10,sp[40]
8000a08e:	e0 a0 0d 33 	rcall	8000baf4 <__avr32_f64_add>
8000a092:	40 85       	lddsp	r5,sp[0x20]
8000a094:	fa e8 00 08 	ld.d	r8,sp[8]
8000a098:	08 05       	add	r5,r4
8000a09a:	e0 a0 0e 85 	rcall	8000bda4 <__avr32_f64_cmp_lt>
8000a09e:	e0 81 00 99 	brne	8000a1d0 <_dtoa_r+0x71c>
8000a0a2:	fa e8 00 28 	ld.d	r8,sp[40]
8000a0a6:	30 0a       	mov	r10,0
8000a0a8:	fc 1b 3f e0 	movh	r11,0x3fe0
8000a0ac:	e0 a0 0c 56 	rcall	8000b958 <__avr32_f64_sub>
8000a0b0:	14 98       	mov	r8,r10
8000a0b2:	16 99       	mov	r9,r11
8000a0b4:	fa ea 00 08 	ld.d	r10,sp[8]
8000a0b8:	e0 a0 0e 76 	rcall	8000bda4 <__avr32_f64_cmp_lt>
8000a0bc:	c1 40       	breq	8000a0e4 <_dtoa_r+0x630>
8000a0be:	33 09       	mov	r9,48
8000a0c0:	0a 98       	mov	r8,r5
8000a0c2:	11 7a       	ld.ub	r10,--r8
8000a0c4:	f2 0a 18 00 	cp.b	r10,r9
8000a0c8:	e0 81 02 d2 	brne	8000a66c <_dtoa_r+0xbb8>
8000a0cc:	10 95       	mov	r5,r8
8000a0ce:	cf 9b       	rjmp	8000a0c0 <_dtoa_r+0x60c>
8000a0d0:	80 01       	ld.sh	r1,r0[0x0]
8000a0d2:	62 90       	ld.w	r0,r1[0x24]
8000a0d4:	30 08       	mov	r8,0
8000a0d6:	fc 19 40 24 	movh	r9,0x4024
8000a0da:	e0 a0 0b 53 	rcall	8000b780 <__avr32_f64_mul>
8000a0de:	fa eb 00 08 	st.d	sp[8],r10
8000a0e2:	cb cb       	rjmp	8000a05a <_dtoa_r+0x5a6>
8000a0e4:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a0e8:	fa eb 00 08 	st.d	sp[8],r10
8000a0ec:	58 e6       	cp.w	r6,14
8000a0ee:	5f ab       	srle	r11
8000a0f0:	41 8a       	lddsp	r10,sp[0x60]
8000a0f2:	30 08       	mov	r8,0
8000a0f4:	f4 09 11 ff 	rsub	r9,r10,-1
8000a0f8:	f7 e9 03 f9 	and	r9,r11,r9>>0x1f
8000a0fc:	f0 09 18 00 	cp.b	r9,r8
8000a100:	e0 80 00 81 	breq	8000a202 <_dtoa_r+0x74e>
8000a104:	40 ea       	lddsp	r10,sp[0x38]
8000a106:	58 01       	cp.w	r1,0
8000a108:	5f a9       	srle	r9
8000a10a:	f3 ea 03 f9 	and	r9,r9,r10>>0x1f
8000a10e:	4c 9a       	lddpc	r10,8000a230 <_dtoa_r+0x77c>
8000a110:	f4 06 02 34 	ld.d	r4,r10[r6<<0x3]
8000a114:	fa e5 00 10 	st.d	sp[16],r4
8000a118:	f0 09 18 00 	cp.b	r9,r8
8000a11c:	c1 40       	breq	8000a144 <_dtoa_r+0x690>
8000a11e:	58 01       	cp.w	r1,0
8000a120:	e0 81 01 78 	brne	8000a410 <_dtoa_r+0x95c>
8000a124:	30 08       	mov	r8,0
8000a126:	fc 19 40 14 	movh	r9,0x4014
8000a12a:	08 9a       	mov	r10,r4
8000a12c:	0a 9b       	mov	r11,r5
8000a12e:	e0 a0 0b 29 	rcall	8000b780 <__avr32_f64_mul>
8000a132:	fa e8 00 08 	ld.d	r8,sp[8]
8000a136:	e0 a0 0e 03 	rcall	8000bd3c <__avr32_f64_cmp_ge>
8000a13a:	e0 81 01 6b 	brne	8000a410 <_dtoa_r+0x95c>
8000a13e:	02 92       	mov	r2,r1
8000a140:	e0 8f 01 73 	bral	8000a426 <_dtoa_r+0x972>
8000a144:	40 85       	lddsp	r5,sp[0x20]
8000a146:	30 14       	mov	r4,1
8000a148:	fa e8 00 10 	ld.d	r8,sp[16]
8000a14c:	fa ea 00 08 	ld.d	r10,sp[8]
8000a150:	e0 a0 0e 5e 	rcall	8000be0c <__avr32_f64_div>
8000a154:	e0 a0 0d 5a 	rcall	8000bc08 <__avr32_f64_to_s32>
8000a158:	18 92       	mov	r2,r12
8000a15a:	e0 a0 0d 6e 	rcall	8000bc36 <__avr32_s32_to_f64>
8000a15e:	fa e8 00 10 	ld.d	r8,sp[16]
8000a162:	e0 a0 0b 0f 	rcall	8000b780 <__avr32_f64_mul>
8000a166:	14 98       	mov	r8,r10
8000a168:	16 99       	mov	r9,r11
8000a16a:	fa ea 00 08 	ld.d	r10,sp[8]
8000a16e:	e0 a0 0b f5 	rcall	8000b958 <__avr32_f64_sub>
8000a172:	fa eb 00 08 	st.d	sp[8],r10
8000a176:	e4 c8 ff d0 	sub	r8,r2,-48
8000a17a:	0a c8       	st.b	r5++,r8
8000a17c:	fc 19 40 24 	movh	r9,0x4024
8000a180:	30 08       	mov	r8,0
8000a182:	02 34       	cp.w	r4,r1
8000a184:	c3 31       	brne	8000a1ea <_dtoa_r+0x736>
8000a186:	fa e8 00 08 	ld.d	r8,sp[8]
8000a18a:	e0 a0 0c b5 	rcall	8000baf4 <__avr32_f64_add>
8000a18e:	16 91       	mov	r1,r11
8000a190:	14 90       	mov	r0,r10
8000a192:	14 98       	mov	r8,r10
8000a194:	02 99       	mov	r9,r1
8000a196:	fa ea 00 10 	ld.d	r10,sp[16]
8000a19a:	e0 a0 0e 05 	rcall	8000bda4 <__avr32_f64_cmp_lt>
8000a19e:	c1 a1       	brne	8000a1d2 <_dtoa_r+0x71e>
8000a1a0:	fa e8 00 10 	ld.d	r8,sp[16]
8000a1a4:	00 9a       	mov	r10,r0
8000a1a6:	02 9b       	mov	r11,r1
8000a1a8:	e0 a0 0d b7 	rcall	8000bd16 <__avr32_f64_cmp_eq>
8000a1ac:	e0 80 02 5f 	breq	8000a66a <_dtoa_r+0xbb6>
8000a1b0:	e5 d2 c0 01 	bfextu	r2,r2,0x0,0x1
8000a1b4:	c0 f1       	brne	8000a1d2 <_dtoa_r+0x71e>
8000a1b6:	e0 8f 02 5a 	bral	8000a66a <_dtoa_r+0xbb6>
8000a1ba:	40 8a       	lddsp	r10,sp[0x20]
8000a1bc:	14 38       	cp.w	r8,r10
8000a1be:	c0 30       	breq	8000a1c4 <_dtoa_r+0x710>
8000a1c0:	10 95       	mov	r5,r8
8000a1c2:	c0 98       	rjmp	8000a1d4 <_dtoa_r+0x720>
8000a1c4:	33 08       	mov	r8,48
8000a1c6:	40 89       	lddsp	r9,sp[0x20]
8000a1c8:	2f f6       	sub	r6,-1
8000a1ca:	b2 88       	st.b	r9[0x0],r8
8000a1cc:	40 88       	lddsp	r8,sp[0x20]
8000a1ce:	c0 88       	rjmp	8000a1de <_dtoa_r+0x72a>
8000a1d0:	40 66       	lddsp	r6,sp[0x18]
8000a1d2:	33 99       	mov	r9,57
8000a1d4:	0a 98       	mov	r8,r5
8000a1d6:	11 7a       	ld.ub	r10,--r8
8000a1d8:	f2 0a 18 00 	cp.b	r10,r9
8000a1dc:	ce f0       	breq	8000a1ba <_dtoa_r+0x706>
8000a1de:	50 66       	stdsp	sp[0x18],r6
8000a1e0:	11 89       	ld.ub	r9,r8[0x0]
8000a1e2:	2f f9       	sub	r9,-1
8000a1e4:	b0 89       	st.b	r8[0x0],r9
8000a1e6:	e0 8f 02 43 	bral	8000a66c <_dtoa_r+0xbb8>
8000a1ea:	e0 a0 0a cb 	rcall	8000b780 <__avr32_f64_mul>
8000a1ee:	2f f4       	sub	r4,-1
8000a1f0:	fa eb 00 08 	st.d	sp[8],r10
8000a1f4:	30 08       	mov	r8,0
8000a1f6:	30 09       	mov	r9,0
8000a1f8:	e0 a0 0d 8f 	rcall	8000bd16 <__avr32_f64_cmp_eq>
8000a1fc:	ca 60       	breq	8000a148 <_dtoa_r+0x694>
8000a1fe:	e0 8f 02 36 	bral	8000a66a <_dtoa_r+0xbb6>
8000a202:	40 d8       	lddsp	r8,sp[0x34]
8000a204:	58 08       	cp.w	r8,0
8000a206:	c0 51       	brne	8000a210 <_dtoa_r+0x75c>
8000a208:	04 98       	mov	r8,r2
8000a20a:	00 95       	mov	r5,r0
8000a20c:	40 d4       	lddsp	r4,sp[0x34]
8000a20e:	c3 88       	rjmp	8000a27e <_dtoa_r+0x7ca>
8000a210:	40 c5       	lddsp	r5,sp[0x30]
8000a212:	58 15       	cp.w	r5,1
8000a214:	e0 89 00 10 	brgt	8000a234 <_dtoa_r+0x780>
8000a218:	41 74       	lddsp	r4,sp[0x5c]
8000a21a:	58 04       	cp.w	r4,0
8000a21c:	c0 40       	breq	8000a224 <_dtoa_r+0x770>
8000a21e:	f4 c9 fb cd 	sub	r9,r10,-1075
8000a222:	c0 48       	rjmp	8000a22a <_dtoa_r+0x776>
8000a224:	41 99       	lddsp	r9,sp[0x64]
8000a226:	f2 09 11 36 	rsub	r9,r9,54
8000a22a:	04 98       	mov	r8,r2
8000a22c:	00 95       	mov	r5,r0
8000a22e:	c1 d8       	rjmp	8000a268 <_dtoa_r+0x7b4>
8000a230:	80 01       	ld.sh	r1,r0[0x0]
8000a232:	62 90       	ld.w	r0,r1[0x24]
8000a234:	e2 c8 00 01 	sub	r8,r1,1
8000a238:	58 01       	cp.w	r1,0
8000a23a:	e0 05 17 40 	movge	r5,r0
8000a23e:	e2 09 17 40 	movge	r9,r1
8000a242:	e1 d1 e5 15 	sublt	r5,r0,r1
8000a246:	f9 b9 05 00 	movlt	r9,0
8000a24a:	10 32       	cp.w	r2,r8
8000a24c:	e5 d8 e4 18 	subge	r8,r2,r8
8000a250:	f1 d2 e5 18 	sublt	r8,r8,r2
8000a254:	e5 d8 e5 02 	addlt	r2,r2,r8
8000a258:	fb fc 50 11 	ld.wlt	r12,sp[0x44]
8000a25c:	f9 d8 e5 0c 	addlt	r12,r12,r8
8000a260:	fb fc 5a 11 	st.wlt	sp[0x44],r12
8000a264:	f9 b8 05 00 	movlt	r8,0
8000a268:	40 4b       	lddsp	r11,sp[0x10]
8000a26a:	12 0b       	add	r11,r9
8000a26c:	50 08       	stdsp	sp[0x0],r8
8000a26e:	50 4b       	stdsp	sp[0x10],r11
8000a270:	12 00       	add	r0,r9
8000a272:	30 1b       	mov	r11,1
8000a274:	0e 9c       	mov	r12,r7
8000a276:	e0 a0 08 ab 	rcall	8000b3cc <__i2b>
8000a27a:	40 08       	lddsp	r8,sp[0x0]
8000a27c:	18 94       	mov	r4,r12
8000a27e:	40 4a       	lddsp	r10,sp[0x10]
8000a280:	58 05       	cp.w	r5,0
8000a282:	5f 99       	srgt	r9
8000a284:	58 0a       	cp.w	r10,0
8000a286:	5f 9a       	srgt	r10
8000a288:	f5 e9 00 09 	and	r9,r10,r9
8000a28c:	c0 80       	breq	8000a29c <_dtoa_r+0x7e8>
8000a28e:	40 4c       	lddsp	r12,sp[0x10]
8000a290:	f8 05 0d 49 	min	r9,r12,r5
8000a294:	12 1c       	sub	r12,r9
8000a296:	12 10       	sub	r0,r9
8000a298:	50 4c       	stdsp	sp[0x10],r12
8000a29a:	12 15       	sub	r5,r9
8000a29c:	58 02       	cp.w	r2,0
8000a29e:	e0 8a 00 27 	brle	8000a2ec <_dtoa_r+0x838>
8000a2a2:	40 db       	lddsp	r11,sp[0x34]
8000a2a4:	58 0b       	cp.w	r11,0
8000a2a6:	c1 d0       	breq	8000a2e0 <_dtoa_r+0x82c>
8000a2a8:	58 08       	cp.w	r8,0
8000a2aa:	e0 8a 00 17 	brle	8000a2d8 <_dtoa_r+0x824>
8000a2ae:	10 9a       	mov	r10,r8
8000a2b0:	50 08       	stdsp	sp[0x0],r8
8000a2b2:	08 9b       	mov	r11,r4
8000a2b4:	0e 9c       	mov	r12,r7
8000a2b6:	e0 a0 08 d1 	rcall	8000b458 <__pow5mult>
8000a2ba:	06 9a       	mov	r10,r3
8000a2bc:	18 9b       	mov	r11,r12
8000a2be:	18 94       	mov	r4,r12
8000a2c0:	0e 9c       	mov	r12,r7
8000a2c2:	e0 a0 08 05 	rcall	8000b2cc <__multiply>
8000a2c6:	18 99       	mov	r9,r12
8000a2c8:	06 9b       	mov	r11,r3
8000a2ca:	50 19       	stdsp	sp[0x4],r9
8000a2cc:	0e 9c       	mov	r12,r7
8000a2ce:	e0 a0 06 b1 	rcall	8000b030 <_Bfree>
8000a2d2:	40 19       	lddsp	r9,sp[0x4]
8000a2d4:	40 08       	lddsp	r8,sp[0x0]
8000a2d6:	12 93       	mov	r3,r9
8000a2d8:	e4 08 01 0a 	sub	r10,r2,r8
8000a2dc:	c0 80       	breq	8000a2ec <_dtoa_r+0x838>
8000a2de:	c0 28       	rjmp	8000a2e2 <_dtoa_r+0x82e>
8000a2e0:	04 9a       	mov	r10,r2
8000a2e2:	06 9b       	mov	r11,r3
8000a2e4:	0e 9c       	mov	r12,r7
8000a2e6:	e0 a0 08 b9 	rcall	8000b458 <__pow5mult>
8000a2ea:	18 93       	mov	r3,r12
8000a2ec:	30 1b       	mov	r11,1
8000a2ee:	0e 9c       	mov	r12,r7
8000a2f0:	e0 a0 08 6e 	rcall	8000b3cc <__i2b>
8000a2f4:	41 1a       	lddsp	r10,sp[0x44]
8000a2f6:	18 92       	mov	r2,r12
8000a2f8:	58 0a       	cp.w	r10,0
8000a2fa:	e0 8a 00 07 	brle	8000a308 <_dtoa_r+0x854>
8000a2fe:	18 9b       	mov	r11,r12
8000a300:	0e 9c       	mov	r12,r7
8000a302:	e0 a0 08 ab 	rcall	8000b458 <__pow5mult>
8000a306:	18 92       	mov	r2,r12
8000a308:	40 c9       	lddsp	r9,sp[0x30]
8000a30a:	58 19       	cp.w	r9,1
8000a30c:	e0 89 00 14 	brgt	8000a334 <_dtoa_r+0x880>
8000a310:	40 38       	lddsp	r8,sp[0xc]
8000a312:	58 08       	cp.w	r8,0
8000a314:	c1 01       	brne	8000a334 <_dtoa_r+0x880>
8000a316:	40 29       	lddsp	r9,sp[0x8]
8000a318:	f1 d9 c0 14 	bfextu	r8,r9,0x0,0x14
8000a31c:	c0 c1       	brne	8000a334 <_dtoa_r+0x880>
8000a31e:	12 98       	mov	r8,r9
8000a320:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000a324:	c0 80       	breq	8000a334 <_dtoa_r+0x880>
8000a326:	40 4c       	lddsp	r12,sp[0x10]
8000a328:	30 1b       	mov	r11,1
8000a32a:	2f fc       	sub	r12,-1
8000a32c:	2f f0       	sub	r0,-1
8000a32e:	50 4c       	stdsp	sp[0x10],r12
8000a330:	50 6b       	stdsp	sp[0x18],r11
8000a332:	c0 38       	rjmp	8000a338 <_dtoa_r+0x884>
8000a334:	30 0a       	mov	r10,0
8000a336:	50 6a       	stdsp	sp[0x18],r10
8000a338:	41 19       	lddsp	r9,sp[0x44]
8000a33a:	58 09       	cp.w	r9,0
8000a33c:	c0 31       	brne	8000a342 <_dtoa_r+0x88e>
8000a33e:	30 1c       	mov	r12,1
8000a340:	c0 98       	rjmp	8000a352 <_dtoa_r+0x89e>
8000a342:	64 48       	ld.w	r8,r2[0x10]
8000a344:	2f c8       	sub	r8,-4
8000a346:	e4 08 03 2c 	ld.w	r12,r2[r8<<0x2]
8000a34a:	e0 a0 05 e3 	rcall	8000af10 <__hi0bits>
8000a34e:	f8 0c 11 20 	rsub	r12,r12,32
8000a352:	40 4b       	lddsp	r11,sp[0x10]
8000a354:	f8 0b 00 08 	add	r8,r12,r11
8000a358:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000a35c:	c0 c0       	breq	8000a374 <_dtoa_r+0x8c0>
8000a35e:	f0 08 11 20 	rsub	r8,r8,32
8000a362:	58 48       	cp.w	r8,4
8000a364:	e0 8a 00 06 	brle	8000a370 <_dtoa_r+0x8bc>
8000a368:	20 48       	sub	r8,4
8000a36a:	10 0b       	add	r11,r8
8000a36c:	50 4b       	stdsp	sp[0x10],r11
8000a36e:	c0 78       	rjmp	8000a37c <_dtoa_r+0x8c8>
8000a370:	58 48       	cp.w	r8,4
8000a372:	c0 70       	breq	8000a380 <_dtoa_r+0x8cc>
8000a374:	40 4a       	lddsp	r10,sp[0x10]
8000a376:	2e 48       	sub	r8,-28
8000a378:	10 0a       	add	r10,r8
8000a37a:	50 4a       	stdsp	sp[0x10],r10
8000a37c:	10 00       	add	r0,r8
8000a37e:	10 05       	add	r5,r8
8000a380:	58 00       	cp.w	r0,0
8000a382:	e0 8a 00 08 	brle	8000a392 <_dtoa_r+0x8de>
8000a386:	06 9b       	mov	r11,r3
8000a388:	00 9a       	mov	r10,r0
8000a38a:	0e 9c       	mov	r12,r7
8000a38c:	e0 a0 07 5c 	rcall	8000b244 <__lshift>
8000a390:	18 93       	mov	r3,r12
8000a392:	40 49       	lddsp	r9,sp[0x10]
8000a394:	58 09       	cp.w	r9,0
8000a396:	e0 8a 00 08 	brle	8000a3a6 <_dtoa_r+0x8f2>
8000a39a:	04 9b       	mov	r11,r2
8000a39c:	12 9a       	mov	r10,r9
8000a39e:	0e 9c       	mov	r12,r7
8000a3a0:	e0 a0 07 52 	rcall	8000b244 <__lshift>
8000a3a4:	18 92       	mov	r2,r12
8000a3a6:	41 48       	lddsp	r8,sp[0x50]
8000a3a8:	58 08       	cp.w	r8,0
8000a3aa:	c1 b0       	breq	8000a3e0 <_dtoa_r+0x92c>
8000a3ac:	04 9b       	mov	r11,r2
8000a3ae:	06 9c       	mov	r12,r3
8000a3b0:	e0 a0 06 27 	rcall	8000affe <__mcmp>
8000a3b4:	c1 64       	brge	8000a3e0 <_dtoa_r+0x92c>
8000a3b6:	06 9b       	mov	r11,r3
8000a3b8:	30 09       	mov	r9,0
8000a3ba:	30 aa       	mov	r10,10
8000a3bc:	0e 9c       	mov	r12,r7
8000a3be:	e0 a0 08 0f 	rcall	8000b3dc <__multadd>
8000a3c2:	20 16       	sub	r6,1
8000a3c4:	18 93       	mov	r3,r12
8000a3c6:	40 dc       	lddsp	r12,sp[0x34]
8000a3c8:	58 0c       	cp.w	r12,0
8000a3ca:	c0 31       	brne	8000a3d0 <_dtoa_r+0x91c>
8000a3cc:	40 91       	lddsp	r1,sp[0x24]
8000a3ce:	c0 98       	rjmp	8000a3e0 <_dtoa_r+0x92c>
8000a3d0:	08 9b       	mov	r11,r4
8000a3d2:	40 91       	lddsp	r1,sp[0x24]
8000a3d4:	30 09       	mov	r9,0
8000a3d6:	30 aa       	mov	r10,10
8000a3d8:	0e 9c       	mov	r12,r7
8000a3da:	e0 a0 08 01 	rcall	8000b3dc <__multadd>
8000a3de:	18 94       	mov	r4,r12
8000a3e0:	58 01       	cp.w	r1,0
8000a3e2:	5f a9       	srle	r9
8000a3e4:	40 cb       	lddsp	r11,sp[0x30]
8000a3e6:	58 2b       	cp.w	r11,2
8000a3e8:	5f 98       	srgt	r8
8000a3ea:	f3 e8 00 08 	and	r8,r9,r8
8000a3ee:	c2 50       	breq	8000a438 <_dtoa_r+0x984>
8000a3f0:	58 01       	cp.w	r1,0
8000a3f2:	c1 11       	brne	8000a414 <_dtoa_r+0x960>
8000a3f4:	04 9b       	mov	r11,r2
8000a3f6:	02 99       	mov	r9,r1
8000a3f8:	30 5a       	mov	r10,5
8000a3fa:	0e 9c       	mov	r12,r7
8000a3fc:	e0 a0 07 f0 	rcall	8000b3dc <__multadd>
8000a400:	18 92       	mov	r2,r12
8000a402:	18 9b       	mov	r11,r12
8000a404:	06 9c       	mov	r12,r3
8000a406:	e0 a0 05 fc 	rcall	8000affe <__mcmp>
8000a40a:	e0 89 00 0f 	brgt	8000a428 <_dtoa_r+0x974>
8000a40e:	c0 38       	rjmp	8000a414 <_dtoa_r+0x960>
8000a410:	30 02       	mov	r2,0
8000a412:	04 94       	mov	r4,r2
8000a414:	40 ea       	lddsp	r10,sp[0x38]
8000a416:	30 09       	mov	r9,0
8000a418:	5c da       	com	r10
8000a41a:	40 85       	lddsp	r5,sp[0x20]
8000a41c:	50 6a       	stdsp	sp[0x18],r10
8000a41e:	50 49       	stdsp	sp[0x10],r9
8000a420:	c0 f9       	rjmp	8000a63e <_dtoa_r+0xb8a>
8000a422:	08 92       	mov	r2,r4
8000a424:	40 66       	lddsp	r6,sp[0x18]
8000a426:	04 94       	mov	r4,r2
8000a428:	2f f6       	sub	r6,-1
8000a42a:	50 66       	stdsp	sp[0x18],r6
8000a42c:	33 18       	mov	r8,49
8000a42e:	40 85       	lddsp	r5,sp[0x20]
8000a430:	0a c8       	st.b	r5++,r8
8000a432:	30 08       	mov	r8,0
8000a434:	50 48       	stdsp	sp[0x10],r8
8000a436:	c0 49       	rjmp	8000a63e <_dtoa_r+0xb8a>
8000a438:	40 dc       	lddsp	r12,sp[0x34]
8000a43a:	58 0c       	cp.w	r12,0
8000a43c:	e0 80 00 b5 	breq	8000a5a6 <_dtoa_r+0xaf2>
8000a440:	58 05       	cp.w	r5,0
8000a442:	e0 8a 00 08 	brle	8000a452 <_dtoa_r+0x99e>
8000a446:	08 9b       	mov	r11,r4
8000a448:	0a 9a       	mov	r10,r5
8000a44a:	0e 9c       	mov	r12,r7
8000a44c:	e0 a0 06 fc 	rcall	8000b244 <__lshift>
8000a450:	18 94       	mov	r4,r12
8000a452:	40 6b       	lddsp	r11,sp[0x18]
8000a454:	58 0b       	cp.w	r11,0
8000a456:	c0 31       	brne	8000a45c <_dtoa_r+0x9a8>
8000a458:	08 9c       	mov	r12,r4
8000a45a:	c1 38       	rjmp	8000a480 <_dtoa_r+0x9cc>
8000a45c:	68 1b       	ld.w	r11,r4[0x4]
8000a45e:	0e 9c       	mov	r12,r7
8000a460:	e0 a0 06 02 	rcall	8000b064 <_Balloc>
8000a464:	68 4a       	ld.w	r10,r4[0x10]
8000a466:	18 95       	mov	r5,r12
8000a468:	e8 cb ff f4 	sub	r11,r4,-12
8000a46c:	2f ea       	sub	r10,-2
8000a46e:	2f 4c       	sub	r12,-12
8000a470:	a3 6a       	lsl	r10,0x2
8000a472:	fe b0 e6 25 	rcall	800070bc <memcpy>
8000a476:	0a 9b       	mov	r11,r5
8000a478:	30 1a       	mov	r10,1
8000a47a:	0e 9c       	mov	r12,r7
8000a47c:	e0 a0 06 e4 	rcall	8000b244 <__lshift>
8000a480:	50 44       	stdsp	sp[0x10],r4
8000a482:	40 3a       	lddsp	r10,sp[0xc]
8000a484:	30 19       	mov	r9,1
8000a486:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
8000a48a:	18 94       	mov	r4,r12
8000a48c:	50 da       	stdsp	sp[0x34],r10
8000a48e:	40 85       	lddsp	r5,sp[0x20]
8000a490:	50 99       	stdsp	sp[0x24],r9
8000a492:	50 26       	stdsp	sp[0x8],r6
8000a494:	50 e1       	stdsp	sp[0x38],r1
8000a496:	04 9b       	mov	r11,r2
8000a498:	06 9c       	mov	r12,r3
8000a49a:	fe b0 fa 7d 	rcall	80009994 <quorem>
8000a49e:	40 4b       	lddsp	r11,sp[0x10]
8000a4a0:	f8 c0 ff d0 	sub	r0,r12,-48
8000a4a4:	06 9c       	mov	r12,r3
8000a4a6:	e0 a0 05 ac 	rcall	8000affe <__mcmp>
8000a4aa:	08 9a       	mov	r10,r4
8000a4ac:	50 6c       	stdsp	sp[0x18],r12
8000a4ae:	04 9b       	mov	r11,r2
8000a4b0:	0e 9c       	mov	r12,r7
8000a4b2:	e0 a0 06 61 	rcall	8000b174 <__mdiff>
8000a4b6:	18 91       	mov	r1,r12
8000a4b8:	78 38       	ld.w	r8,r12[0xc]
8000a4ba:	58 08       	cp.w	r8,0
8000a4bc:	c0 30       	breq	8000a4c2 <_dtoa_r+0xa0e>
8000a4be:	30 16       	mov	r6,1
8000a4c0:	c0 68       	rjmp	8000a4cc <_dtoa_r+0xa18>
8000a4c2:	18 9b       	mov	r11,r12
8000a4c4:	06 9c       	mov	r12,r3
8000a4c6:	e0 a0 05 9c 	rcall	8000affe <__mcmp>
8000a4ca:	18 96       	mov	r6,r12
8000a4cc:	0e 9c       	mov	r12,r7
8000a4ce:	02 9b       	mov	r11,r1
8000a4d0:	e0 a0 05 b0 	rcall	8000b030 <_Bfree>
8000a4d4:	40 cc       	lddsp	r12,sp[0x30]
8000a4d6:	ed ec 10 08 	or	r8,r6,r12
8000a4da:	c0 d1       	brne	8000a4f4 <_dtoa_r+0xa40>
8000a4dc:	40 db       	lddsp	r11,sp[0x34]
8000a4de:	58 0b       	cp.w	r11,0
8000a4e0:	c0 a1       	brne	8000a4f4 <_dtoa_r+0xa40>
8000a4e2:	40 26       	lddsp	r6,sp[0x8]
8000a4e4:	e0 40 00 39 	cp.w	r0,57
8000a4e8:	c3 00       	breq	8000a548 <_dtoa_r+0xa94>
8000a4ea:	40 6a       	lddsp	r10,sp[0x18]
8000a4ec:	58 0a       	cp.w	r10,0
8000a4ee:	e0 89 00 24 	brgt	8000a536 <_dtoa_r+0xa82>
8000a4f2:	c2 f8       	rjmp	8000a550 <_dtoa_r+0xa9c>
8000a4f4:	40 69       	lddsp	r9,sp[0x18]
8000a4f6:	58 09       	cp.w	r9,0
8000a4f8:	c0 85       	brlt	8000a508 <_dtoa_r+0xa54>
8000a4fa:	12 98       	mov	r8,r9
8000a4fc:	40 cc       	lddsp	r12,sp[0x30]
8000a4fe:	18 48       	or	r8,r12
8000a500:	c1 d1       	brne	8000a53a <_dtoa_r+0xa86>
8000a502:	40 db       	lddsp	r11,sp[0x34]
8000a504:	58 0b       	cp.w	r11,0
8000a506:	c1 a1       	brne	8000a53a <_dtoa_r+0xa86>
8000a508:	0c 99       	mov	r9,r6
8000a50a:	40 26       	lddsp	r6,sp[0x8]
8000a50c:	58 09       	cp.w	r9,0
8000a50e:	e0 8a 00 21 	brle	8000a550 <_dtoa_r+0xa9c>
8000a512:	06 9b       	mov	r11,r3
8000a514:	30 1a       	mov	r10,1
8000a516:	0e 9c       	mov	r12,r7
8000a518:	e0 a0 06 96 	rcall	8000b244 <__lshift>
8000a51c:	04 9b       	mov	r11,r2
8000a51e:	18 93       	mov	r3,r12
8000a520:	e0 a0 05 6f 	rcall	8000affe <__mcmp>
8000a524:	e0 89 00 06 	brgt	8000a530 <_dtoa_r+0xa7c>
8000a528:	c1 41       	brne	8000a550 <_dtoa_r+0xa9c>
8000a52a:	ed b0 00 00 	bld	r0,0x0
8000a52e:	c1 11       	brne	8000a550 <_dtoa_r+0xa9c>
8000a530:	e0 40 00 39 	cp.w	r0,57
8000a534:	c0 a0       	breq	8000a548 <_dtoa_r+0xa94>
8000a536:	2f f0       	sub	r0,-1
8000a538:	c0 c8       	rjmp	8000a550 <_dtoa_r+0xa9c>
8000a53a:	58 06       	cp.w	r6,0
8000a53c:	e0 8a 00 0c 	brle	8000a554 <_dtoa_r+0xaa0>
8000a540:	40 26       	lddsp	r6,sp[0x8]
8000a542:	e0 40 00 39 	cp.w	r0,57
8000a546:	c0 41       	brne	8000a54e <_dtoa_r+0xa9a>
8000a548:	33 98       	mov	r8,57
8000a54a:	0a c8       	st.b	r5++,r8
8000a54c:	c6 78       	rjmp	8000a61a <_dtoa_r+0xb66>
8000a54e:	2f f0       	sub	r0,-1
8000a550:	0a c0       	st.b	r5++,r0
8000a552:	c7 58       	rjmp	8000a63c <_dtoa_r+0xb88>
8000a554:	0a c0       	st.b	r5++,r0
8000a556:	40 9a       	lddsp	r10,sp[0x24]
8000a558:	40 e9       	lddsp	r9,sp[0x38]
8000a55a:	12 3a       	cp.w	r10,r9
8000a55c:	c4 30       	breq	8000a5e2 <_dtoa_r+0xb2e>
8000a55e:	06 9b       	mov	r11,r3
8000a560:	30 09       	mov	r9,0
8000a562:	30 aa       	mov	r10,10
8000a564:	0e 9c       	mov	r12,r7
8000a566:	e0 a0 07 3b 	rcall	8000b3dc <__multadd>
8000a56a:	40 48       	lddsp	r8,sp[0x10]
8000a56c:	18 93       	mov	r3,r12
8000a56e:	08 38       	cp.w	r8,r4
8000a570:	c0 91       	brne	8000a582 <_dtoa_r+0xace>
8000a572:	10 9b       	mov	r11,r8
8000a574:	30 09       	mov	r9,0
8000a576:	30 aa       	mov	r10,10
8000a578:	0e 9c       	mov	r12,r7
8000a57a:	e0 a0 07 31 	rcall	8000b3dc <__multadd>
8000a57e:	50 4c       	stdsp	sp[0x10],r12
8000a580:	c0 e8       	rjmp	8000a59c <_dtoa_r+0xae8>
8000a582:	40 4b       	lddsp	r11,sp[0x10]
8000a584:	30 09       	mov	r9,0
8000a586:	30 aa       	mov	r10,10
8000a588:	0e 9c       	mov	r12,r7
8000a58a:	e0 a0 07 29 	rcall	8000b3dc <__multadd>
8000a58e:	08 9b       	mov	r11,r4
8000a590:	50 4c       	stdsp	sp[0x10],r12
8000a592:	30 09       	mov	r9,0
8000a594:	30 aa       	mov	r10,10
8000a596:	0e 9c       	mov	r12,r7
8000a598:	e0 a0 07 22 	rcall	8000b3dc <__multadd>
8000a59c:	18 94       	mov	r4,r12
8000a59e:	40 9c       	lddsp	r12,sp[0x24]
8000a5a0:	2f fc       	sub	r12,-1
8000a5a2:	50 9c       	stdsp	sp[0x24],r12
8000a5a4:	c7 9b       	rjmp	8000a496 <_dtoa_r+0x9e2>
8000a5a6:	30 18       	mov	r8,1
8000a5a8:	06 90       	mov	r0,r3
8000a5aa:	40 85       	lddsp	r5,sp[0x20]
8000a5ac:	08 93       	mov	r3,r4
8000a5ae:	0c 94       	mov	r4,r6
8000a5b0:	10 96       	mov	r6,r8
8000a5b2:	04 9b       	mov	r11,r2
8000a5b4:	00 9c       	mov	r12,r0
8000a5b6:	fe b0 f9 ef 	rcall	80009994 <quorem>
8000a5ba:	2d 0c       	sub	r12,-48
8000a5bc:	0a cc       	st.b	r5++,r12
8000a5be:	02 36       	cp.w	r6,r1
8000a5c0:	c0 a4       	brge	8000a5d4 <_dtoa_r+0xb20>
8000a5c2:	00 9b       	mov	r11,r0
8000a5c4:	30 09       	mov	r9,0
8000a5c6:	30 aa       	mov	r10,10
8000a5c8:	0e 9c       	mov	r12,r7
8000a5ca:	2f f6       	sub	r6,-1
8000a5cc:	e0 a0 07 08 	rcall	8000b3dc <__multadd>
8000a5d0:	18 90       	mov	r0,r12
8000a5d2:	cf 0b       	rjmp	8000a5b2 <_dtoa_r+0xafe>
8000a5d4:	08 96       	mov	r6,r4
8000a5d6:	30 0b       	mov	r11,0
8000a5d8:	06 94       	mov	r4,r3
8000a5da:	50 4b       	stdsp	sp[0x10],r11
8000a5dc:	00 93       	mov	r3,r0
8000a5de:	18 90       	mov	r0,r12
8000a5e0:	c0 28       	rjmp	8000a5e4 <_dtoa_r+0xb30>
8000a5e2:	40 26       	lddsp	r6,sp[0x8]
8000a5e4:	06 9b       	mov	r11,r3
8000a5e6:	30 1a       	mov	r10,1
8000a5e8:	0e 9c       	mov	r12,r7
8000a5ea:	e0 a0 06 2d 	rcall	8000b244 <__lshift>
8000a5ee:	04 9b       	mov	r11,r2
8000a5f0:	18 93       	mov	r3,r12
8000a5f2:	e0 a0 05 06 	rcall	8000affe <__mcmp>
8000a5f6:	e0 89 00 12 	brgt	8000a61a <_dtoa_r+0xb66>
8000a5fa:	c1 b1       	brne	8000a630 <_dtoa_r+0xb7c>
8000a5fc:	e1 d0 c0 01 	bfextu	r0,r0,0x0,0x1
8000a600:	c0 d1       	brne	8000a61a <_dtoa_r+0xb66>
8000a602:	c1 78       	rjmp	8000a630 <_dtoa_r+0xb7c>
8000a604:	40 89       	lddsp	r9,sp[0x20]
8000a606:	12 38       	cp.w	r8,r9
8000a608:	c0 30       	breq	8000a60e <_dtoa_r+0xb5a>
8000a60a:	10 95       	mov	r5,r8
8000a60c:	c0 88       	rjmp	8000a61c <_dtoa_r+0xb68>
8000a60e:	2f f6       	sub	r6,-1
8000a610:	50 66       	stdsp	sp[0x18],r6
8000a612:	33 18       	mov	r8,49
8000a614:	40 8c       	lddsp	r12,sp[0x20]
8000a616:	b8 88       	st.b	r12[0x0],r8
8000a618:	c1 38       	rjmp	8000a63e <_dtoa_r+0xb8a>
8000a61a:	33 9a       	mov	r10,57
8000a61c:	0a 98       	mov	r8,r5
8000a61e:	11 79       	ld.ub	r9,--r8
8000a620:	f4 09 18 00 	cp.b	r9,r10
8000a624:	cf 00       	breq	8000a604 <_dtoa_r+0xb50>
8000a626:	2f f9       	sub	r9,-1
8000a628:	b0 89       	st.b	r8[0x0],r9
8000a62a:	c0 98       	rjmp	8000a63c <_dtoa_r+0xb88>
8000a62c:	10 95       	mov	r5,r8
8000a62e:	c0 28       	rjmp	8000a632 <_dtoa_r+0xb7e>
8000a630:	33 09       	mov	r9,48
8000a632:	0a 98       	mov	r8,r5
8000a634:	11 7a       	ld.ub	r10,--r8
8000a636:	f2 0a 18 00 	cp.b	r10,r9
8000a63a:	cf 90       	breq	8000a62c <_dtoa_r+0xb78>
8000a63c:	50 66       	stdsp	sp[0x18],r6
8000a63e:	04 9b       	mov	r11,r2
8000a640:	0e 9c       	mov	r12,r7
8000a642:	e0 a0 04 f7 	rcall	8000b030 <_Bfree>
8000a646:	58 04       	cp.w	r4,0
8000a648:	c1 20       	breq	8000a66c <_dtoa_r+0xbb8>
8000a64a:	40 4b       	lddsp	r11,sp[0x10]
8000a64c:	08 3b       	cp.w	r11,r4
8000a64e:	5f 19       	srne	r9
8000a650:	58 0b       	cp.w	r11,0
8000a652:	5f 18       	srne	r8
8000a654:	f3 e8 00 08 	and	r8,r9,r8
8000a658:	c0 40       	breq	8000a660 <_dtoa_r+0xbac>
8000a65a:	0e 9c       	mov	r12,r7
8000a65c:	e0 a0 04 ea 	rcall	8000b030 <_Bfree>
8000a660:	08 9b       	mov	r11,r4
8000a662:	0e 9c       	mov	r12,r7
8000a664:	e0 a0 04 e6 	rcall	8000b030 <_Bfree>
8000a668:	c0 28       	rjmp	8000a66c <_dtoa_r+0xbb8>
8000a66a:	50 66       	stdsp	sp[0x18],r6
8000a66c:	0e 9c       	mov	r12,r7
8000a66e:	06 9b       	mov	r11,r3
8000a670:	e0 a0 04 e0 	rcall	8000b030 <_Bfree>
8000a674:	30 08       	mov	r8,0
8000a676:	aa 88       	st.b	r5[0x0],r8
8000a678:	40 68       	lddsp	r8,sp[0x18]
8000a67a:	41 5a       	lddsp	r10,sp[0x54]
8000a67c:	2f f8       	sub	r8,-1
8000a67e:	41 29       	lddsp	r9,sp[0x48]
8000a680:	95 08       	st.w	r10[0x0],r8
8000a682:	40 8c       	lddsp	r12,sp[0x20]
8000a684:	58 09       	cp.w	r9,0
8000a686:	fb f8 10 12 	ld.wne	r8,sp[0x48]
8000a68a:	f1 f5 1a 00 	st.wne	r8[0x0],r5
8000a68e:	2e 6d       	sub	sp,-104
8000a690:	d8 32       	popm	r0-r7,pc
8000a692:	d7 03       	nop

8000a694 <__errno>:
8000a694:	e0 68 0a 30 	mov	r8,2608
8000a698:	70 0c       	ld.w	r12,r8[0x0]
8000a69a:	2f 4c       	sub	r12,-12
8000a69c:	5e fc       	retal	r12
8000a69e:	d7 03       	nop

8000a6a0 <_fflush_r>:
8000a6a0:	d4 21       	pushm	r4-r7,lr
8000a6a2:	16 97       	mov	r7,r11
8000a6a4:	18 96       	mov	r6,r12
8000a6a6:	76 48       	ld.w	r8,r11[0x10]
8000a6a8:	58 08       	cp.w	r8,0
8000a6aa:	c7 c0       	breq	8000a7a2 <_fflush_r+0x102>
8000a6ac:	58 0c       	cp.w	r12,0
8000a6ae:	c0 50       	breq	8000a6b8 <_fflush_r+0x18>
8000a6b0:	78 68       	ld.w	r8,r12[0x18]
8000a6b2:	58 08       	cp.w	r8,0
8000a6b4:	c0 21       	brne	8000a6b8 <_fflush_r+0x18>
8000a6b6:	cd 1c       	rcall	8000a858 <__sinit>
8000a6b8:	4b b8       	lddpc	r8,8000a7a4 <_fflush_r+0x104>
8000a6ba:	10 37       	cp.w	r7,r8
8000a6bc:	c0 31       	brne	8000a6c2 <_fflush_r+0x22>
8000a6be:	6c 07       	ld.w	r7,r6[0x0]
8000a6c0:	c0 a8       	rjmp	8000a6d4 <_fflush_r+0x34>
8000a6c2:	4b a8       	lddpc	r8,8000a7a8 <_fflush_r+0x108>
8000a6c4:	10 37       	cp.w	r7,r8
8000a6c6:	c0 31       	brne	8000a6cc <_fflush_r+0x2c>
8000a6c8:	6c 17       	ld.w	r7,r6[0x4]
8000a6ca:	c0 58       	rjmp	8000a6d4 <_fflush_r+0x34>
8000a6cc:	4b 88       	lddpc	r8,8000a7ac <_fflush_r+0x10c>
8000a6ce:	10 37       	cp.w	r7,r8
8000a6d0:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000a6d4:	8e 6a       	ld.sh	r10,r7[0xc]
8000a6d6:	14 98       	mov	r8,r10
8000a6d8:	ed ba 00 03 	bld	r10,0x3
8000a6dc:	c4 20       	breq	8000a760 <_fflush_r+0xc0>
8000a6de:	ab ba       	sbr	r10,0xb
8000a6e0:	ae 6a       	st.h	r7[0xc],r10
8000a6e2:	6e 18       	ld.w	r8,r7[0x4]
8000a6e4:	58 08       	cp.w	r8,0
8000a6e6:	e0 89 00 06 	brgt	8000a6f2 <_fflush_r+0x52>
8000a6ea:	6f 08       	ld.w	r8,r7[0x40]
8000a6ec:	58 08       	cp.w	r8,0
8000a6ee:	e0 8a 00 5a 	brle	8000a7a2 <_fflush_r+0x102>
8000a6f2:	6e b8       	ld.w	r8,r7[0x2c]
8000a6f4:	58 08       	cp.w	r8,0
8000a6f6:	c5 60       	breq	8000a7a2 <_fflush_r+0x102>
8000a6f8:	e2 1a 10 00 	andl	r10,0x1000,COH
8000a6fc:	c0 30       	breq	8000a702 <_fflush_r+0x62>
8000a6fe:	6f 55       	ld.w	r5,r7[0x54]
8000a700:	c0 f8       	rjmp	8000a71e <_fflush_r+0x7e>
8000a702:	30 19       	mov	r9,1
8000a704:	6e 8b       	ld.w	r11,r7[0x20]
8000a706:	0c 9c       	mov	r12,r6
8000a708:	5d 18       	icall	r8
8000a70a:	18 95       	mov	r5,r12
8000a70c:	5b fc       	cp.w	r12,-1
8000a70e:	c0 81       	brne	8000a71e <_fflush_r+0x7e>
8000a710:	6c 38       	ld.w	r8,r6[0xc]
8000a712:	59 d8       	cp.w	r8,29
8000a714:	c4 70       	breq	8000a7a2 <_fflush_r+0x102>
8000a716:	8e 68       	ld.sh	r8,r7[0xc]
8000a718:	a7 a8       	sbr	r8,0x6
8000a71a:	ae 68       	st.h	r7[0xc],r8
8000a71c:	d8 22       	popm	r4-r7,pc
8000a71e:	8e 68       	ld.sh	r8,r7[0xc]
8000a720:	ed b8 00 02 	bld	r8,0x2
8000a724:	c0 91       	brne	8000a736 <_fflush_r+0x96>
8000a726:	6e 18       	ld.w	r8,r7[0x4]
8000a728:	10 15       	sub	r5,r8
8000a72a:	6e d8       	ld.w	r8,r7[0x34]
8000a72c:	58 08       	cp.w	r8,0
8000a72e:	ef f8 10 10 	ld.wne	r8,r7[0x40]
8000a732:	eb d8 e1 15 	subne	r5,r5,r8
8000a736:	6e b8       	ld.w	r8,r7[0x2c]
8000a738:	0c 9c       	mov	r12,r6
8000a73a:	30 09       	mov	r9,0
8000a73c:	0a 9a       	mov	r10,r5
8000a73e:	6e 8b       	ld.w	r11,r7[0x20]
8000a740:	5d 18       	icall	r8
8000a742:	8e 68       	ld.sh	r8,r7[0xc]
8000a744:	0a 3c       	cp.w	r12,r5
8000a746:	c2 61       	brne	8000a792 <_fflush_r+0xf2>
8000a748:	ab d8       	cbr	r8,0xb
8000a74a:	30 0c       	mov	r12,0
8000a74c:	6e 49       	ld.w	r9,r7[0x10]
8000a74e:	ae 68       	st.h	r7[0xc],r8
8000a750:	8f 1c       	st.w	r7[0x4],r12
8000a752:	8f 09       	st.w	r7[0x0],r9
8000a754:	ed b8 00 0c 	bld	r8,0xc
8000a758:	c2 51       	brne	8000a7a2 <_fflush_r+0x102>
8000a75a:	ef 45 00 54 	st.w	r7[84],r5
8000a75e:	d8 22       	popm	r4-r7,pc
8000a760:	6e 45       	ld.w	r5,r7[0x10]
8000a762:	58 05       	cp.w	r5,0
8000a764:	c1 f0       	breq	8000a7a2 <_fflush_r+0x102>
8000a766:	6e 04       	ld.w	r4,r7[0x0]
8000a768:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
8000a76c:	8f 05       	st.w	r7[0x0],r5
8000a76e:	f9 b8 01 00 	movne	r8,0
8000a772:	ef f8 00 05 	ld.weq	r8,r7[0x14]
8000a776:	0a 14       	sub	r4,r5
8000a778:	8f 28       	st.w	r7[0x8],r8
8000a77a:	c1 18       	rjmp	8000a79c <_fflush_r+0xfc>
8000a77c:	08 99       	mov	r9,r4
8000a77e:	0a 9a       	mov	r10,r5
8000a780:	6e a8       	ld.w	r8,r7[0x28]
8000a782:	6e 8b       	ld.w	r11,r7[0x20]
8000a784:	0c 9c       	mov	r12,r6
8000a786:	5d 18       	icall	r8
8000a788:	18 14       	sub	r4,r12
8000a78a:	58 0c       	cp.w	r12,0
8000a78c:	e0 89 00 07 	brgt	8000a79a <_fflush_r+0xfa>
8000a790:	8e 68       	ld.sh	r8,r7[0xc]
8000a792:	a7 a8       	sbr	r8,0x6
8000a794:	3f fc       	mov	r12,-1
8000a796:	ae 68       	st.h	r7[0xc],r8
8000a798:	d8 22       	popm	r4-r7,pc
8000a79a:	18 05       	add	r5,r12
8000a79c:	58 04       	cp.w	r4,0
8000a79e:	fe 99 ff ef 	brgt	8000a77c <_fflush_r+0xdc>
8000a7a2:	d8 2a       	popm	r4-r7,pc,r12=0
8000a7a4:	80 01       	ld.sh	r1,r0[0x0]
8000a7a6:	61 e0       	ld.w	r0,r0[0x78]
8000a7a8:	80 01       	ld.sh	r1,r0[0x0]
8000a7aa:	62 00       	ld.w	r0,r1[0x0]
8000a7ac:	80 01       	ld.sh	r1,r0[0x0]
8000a7ae:	62 20       	ld.w	r0,r1[0x8]

8000a7b0 <__sfp_lock_acquire>:
8000a7b0:	5e fc       	retal	r12

8000a7b2 <__sfp_lock_release>:
8000a7b2:	5e fc       	retal	r12

8000a7b4 <_cleanup_r>:
8000a7b4:	d4 01       	pushm	lr
8000a7b6:	fe cb f0 ba 	sub	r11,pc,-3910
8000a7ba:	e0 a0 02 f9 	rcall	8000adac <_fwalk>
8000a7be:	d8 02       	popm	pc

8000a7c0 <__sfmoreglue>:
8000a7c0:	d4 21       	pushm	r4-r7,lr
8000a7c2:	16 95       	mov	r5,r11
8000a7c4:	f6 06 10 5c 	mul	r6,r11,92
8000a7c8:	ec cb ff f4 	sub	r11,r6,-12
8000a7cc:	fe b0 e2 5c 	rcall	80006c84 <_malloc_r>
8000a7d0:	18 97       	mov	r7,r12
8000a7d2:	c0 90       	breq	8000a7e4 <__sfmoreglue+0x24>
8000a7d4:	99 15       	st.w	r12[0x4],r5
8000a7d6:	30 0b       	mov	r11,0
8000a7d8:	2f 4c       	sub	r12,-12
8000a7da:	0c 9a       	mov	r10,r6
8000a7dc:	8f 2c       	st.w	r7[0x8],r12
8000a7de:	8f 0b       	st.w	r7[0x0],r11
8000a7e0:	fe b0 e5 12 	rcall	80007204 <memset>
8000a7e4:	0e 9c       	mov	r12,r7
8000a7e6:	d8 22       	popm	r4-r7,pc

8000a7e8 <__sfp>:
8000a7e8:	d4 21       	pushm	r4-r7,lr
8000a7ea:	49 b8       	lddpc	r8,8000a854 <__sfp+0x6c>
8000a7ec:	18 96       	mov	r6,r12
8000a7ee:	70 07       	ld.w	r7,r8[0x0]
8000a7f0:	6e 68       	ld.w	r8,r7[0x18]
8000a7f2:	58 08       	cp.w	r8,0
8000a7f4:	c0 31       	brne	8000a7fa <__sfp+0x12>
8000a7f6:	0e 9c       	mov	r12,r7
8000a7f8:	c3 0c       	rcall	8000a858 <__sinit>
8000a7fa:	ee c7 ff 28 	sub	r7,r7,-216
8000a7fe:	30 05       	mov	r5,0
8000a800:	6e 2c       	ld.w	r12,r7[0x8]
8000a802:	6e 18       	ld.w	r8,r7[0x4]
8000a804:	c0 68       	rjmp	8000a810 <__sfp+0x28>
8000a806:	98 69       	ld.sh	r9,r12[0xc]
8000a808:	ea 09 19 00 	cp.h	r9,r5
8000a80c:	c1 10       	breq	8000a82e <__sfp+0x46>
8000a80e:	2a 4c       	sub	r12,-92
8000a810:	20 18       	sub	r8,1
8000a812:	cf a7       	brpl	8000a806 <__sfp+0x1e>
8000a814:	6e 08       	ld.w	r8,r7[0x0]
8000a816:	58 08       	cp.w	r8,0
8000a818:	c0 61       	brne	8000a824 <__sfp+0x3c>
8000a81a:	30 4b       	mov	r11,4
8000a81c:	0c 9c       	mov	r12,r6
8000a81e:	cd 1f       	rcall	8000a7c0 <__sfmoreglue>
8000a820:	8f 0c       	st.w	r7[0x0],r12
8000a822:	c0 30       	breq	8000a828 <__sfp+0x40>
8000a824:	6e 07       	ld.w	r7,r7[0x0]
8000a826:	ce db       	rjmp	8000a800 <__sfp+0x18>
8000a828:	30 c8       	mov	r8,12
8000a82a:	8d 38       	st.w	r6[0xc],r8
8000a82c:	d8 22       	popm	r4-r7,pc
8000a82e:	30 08       	mov	r8,0
8000a830:	f9 48 00 4c 	st.w	r12[76],r8
8000a834:	99 08       	st.w	r12[0x0],r8
8000a836:	99 28       	st.w	r12[0x8],r8
8000a838:	99 18       	st.w	r12[0x4],r8
8000a83a:	99 48       	st.w	r12[0x10],r8
8000a83c:	99 58       	st.w	r12[0x14],r8
8000a83e:	99 68       	st.w	r12[0x18],r8
8000a840:	99 d8       	st.w	r12[0x34],r8
8000a842:	99 e8       	st.w	r12[0x38],r8
8000a844:	f9 48 00 48 	st.w	r12[72],r8
8000a848:	3f f8       	mov	r8,-1
8000a84a:	b8 78       	st.h	r12[0xe],r8
8000a84c:	30 18       	mov	r8,1
8000a84e:	b8 68       	st.h	r12[0xc],r8
8000a850:	d8 22       	popm	r4-r7,pc
8000a852:	d7 03       	nop
8000a854:	80 01       	ld.sh	r1,r0[0x0]
8000a856:	62 44       	ld.w	r4,r1[0x10]

8000a858 <__sinit>:
8000a858:	d4 21       	pushm	r4-r7,lr
8000a85a:	18 96       	mov	r6,r12
8000a85c:	78 67       	ld.w	r7,r12[0x18]
8000a85e:	58 07       	cp.w	r7,0
8000a860:	c4 91       	brne	8000a8f2 <__sinit+0x9a>
8000a862:	fe c8 00 ae 	sub	r8,pc,174
8000a866:	30 15       	mov	r5,1
8000a868:	99 a8       	st.w	r12[0x28],r8
8000a86a:	f9 47 00 d8 	st.w	r12[216],r7
8000a86e:	f9 47 00 dc 	st.w	r12[220],r7
8000a872:	f9 47 00 e0 	st.w	r12[224],r7
8000a876:	99 65       	st.w	r12[0x18],r5
8000a878:	cb 8f       	rcall	8000a7e8 <__sfp>
8000a87a:	8d 0c       	st.w	r6[0x0],r12
8000a87c:	0c 9c       	mov	r12,r6
8000a87e:	cb 5f       	rcall	8000a7e8 <__sfp>
8000a880:	8d 1c       	st.w	r6[0x4],r12
8000a882:	0c 9c       	mov	r12,r6
8000a884:	cb 2f       	rcall	8000a7e8 <__sfp>
8000a886:	6c 09       	ld.w	r9,r6[0x0]
8000a888:	30 48       	mov	r8,4
8000a88a:	93 07       	st.w	r9[0x0],r7
8000a88c:	b2 68       	st.h	r9[0xc],r8
8000a88e:	93 17       	st.w	r9[0x4],r7
8000a890:	93 27       	st.w	r9[0x8],r7
8000a892:	6c 18       	ld.w	r8,r6[0x4]
8000a894:	b2 77       	st.h	r9[0xe],r7
8000a896:	93 47       	st.w	r9[0x10],r7
8000a898:	93 57       	st.w	r9[0x14],r7
8000a89a:	93 67       	st.w	r9[0x18],r7
8000a89c:	93 89       	st.w	r9[0x20],r9
8000a89e:	91 07       	st.w	r8[0x0],r7
8000a8a0:	91 17       	st.w	r8[0x4],r7
8000a8a2:	91 27       	st.w	r8[0x8],r7
8000a8a4:	fe ce f3 20 	sub	lr,pc,-3296
8000a8a8:	fe cb f3 50 	sub	r11,pc,-3248
8000a8ac:	93 9e       	st.w	r9[0x24],lr
8000a8ae:	93 ab       	st.w	r9[0x28],r11
8000a8b0:	fe ca f3 78 	sub	r10,pc,-3208
8000a8b4:	fe c4 f3 84 	sub	r4,pc,-3196
8000a8b8:	93 ba       	st.w	r9[0x2c],r10
8000a8ba:	93 c4       	st.w	r9[0x30],r4
8000a8bc:	30 99       	mov	r9,9
8000a8be:	b0 69       	st.h	r8[0xc],r9
8000a8c0:	b0 75       	st.h	r8[0xe],r5
8000a8c2:	91 c4       	st.w	r8[0x30],r4
8000a8c4:	91 47       	st.w	r8[0x10],r7
8000a8c6:	91 57       	st.w	r8[0x14],r7
8000a8c8:	91 67       	st.w	r8[0x18],r7
8000a8ca:	91 88       	st.w	r8[0x20],r8
8000a8cc:	91 9e       	st.w	r8[0x24],lr
8000a8ce:	91 ab       	st.w	r8[0x28],r11
8000a8d0:	91 ba       	st.w	r8[0x2c],r10
8000a8d2:	8d 2c       	st.w	r6[0x8],r12
8000a8d4:	31 28       	mov	r8,18
8000a8d6:	99 07       	st.w	r12[0x0],r7
8000a8d8:	b8 68       	st.h	r12[0xc],r8
8000a8da:	99 17       	st.w	r12[0x4],r7
8000a8dc:	99 27       	st.w	r12[0x8],r7
8000a8de:	30 28       	mov	r8,2
8000a8e0:	b8 78       	st.h	r12[0xe],r8
8000a8e2:	99 c4       	st.w	r12[0x30],r4
8000a8e4:	99 67       	st.w	r12[0x18],r7
8000a8e6:	99 9e       	st.w	r12[0x24],lr
8000a8e8:	99 ab       	st.w	r12[0x28],r11
8000a8ea:	99 ba       	st.w	r12[0x2c],r10
8000a8ec:	99 47       	st.w	r12[0x10],r7
8000a8ee:	99 57       	st.w	r12[0x14],r7
8000a8f0:	99 8c       	st.w	r12[0x20],r12
8000a8f2:	d8 22       	popm	r4-r7,pc

8000a8f4 <_malloc_trim_r>:
8000a8f4:	d4 21       	pushm	r4-r7,lr
8000a8f6:	16 95       	mov	r5,r11
8000a8f8:	18 97       	mov	r7,r12
8000a8fa:	fe b0 d7 31 	rcall	8000575c <__malloc_lock>
8000a8fe:	e0 64 05 30 	mov	r4,1328
8000a902:	68 28       	ld.w	r8,r4[0x8]
8000a904:	70 16       	ld.w	r6,r8[0x4]
8000a906:	e0 16 ff fc 	andl	r6,0xfffc
8000a90a:	ec c8 ff 91 	sub	r8,r6,-111
8000a90e:	f0 05 01 05 	sub	r5,r8,r5
8000a912:	e0 15 ff 80 	andl	r5,0xff80
8000a916:	ea c5 00 80 	sub	r5,r5,128
8000a91a:	e0 45 00 7f 	cp.w	r5,127
8000a91e:	e0 8a 00 25 	brle	8000a968 <_malloc_trim_r+0x74>
8000a922:	30 0b       	mov	r11,0
8000a924:	0e 9c       	mov	r12,r7
8000a926:	fe b0 e5 d7 	rcall	800074d4 <_sbrk_r>
8000a92a:	68 28       	ld.w	r8,r4[0x8]
8000a92c:	0c 08       	add	r8,r6
8000a92e:	10 3c       	cp.w	r12,r8
8000a930:	c1 c1       	brne	8000a968 <_malloc_trim_r+0x74>
8000a932:	ea 0b 11 00 	rsub	r11,r5,0
8000a936:	0e 9c       	mov	r12,r7
8000a938:	fe b0 e5 ce 	rcall	800074d4 <_sbrk_r>
8000a93c:	5b fc       	cp.w	r12,-1
8000a93e:	c1 91       	brne	8000a970 <_malloc_trim_r+0x7c>
8000a940:	30 0b       	mov	r11,0
8000a942:	0e 9c       	mov	r12,r7
8000a944:	fe b0 e5 c8 	rcall	800074d4 <_sbrk_r>
8000a948:	68 28       	ld.w	r8,r4[0x8]
8000a94a:	f8 08 01 09 	sub	r9,r12,r8
8000a94e:	58 f9       	cp.w	r9,15
8000a950:	e0 8a 00 0c 	brle	8000a968 <_malloc_trim_r+0x74>
8000a954:	a1 a9       	sbr	r9,0x0
8000a956:	91 19       	st.w	r8[0x4],r9
8000a958:	e0 68 09 3c 	mov	r8,2364
8000a95c:	70 09       	ld.w	r9,r8[0x0]
8000a95e:	e0 68 0d 88 	mov	r8,3464
8000a962:	f8 09 01 09 	sub	r9,r12,r9
8000a966:	91 09       	st.w	r8[0x0],r9
8000a968:	0e 9c       	mov	r12,r7
8000a96a:	fe b0 d6 ff 	rcall	80005768 <__malloc_unlock>
8000a96e:	d8 2a       	popm	r4-r7,pc,r12=0
8000a970:	68 28       	ld.w	r8,r4[0x8]
8000a972:	0a 16       	sub	r6,r5
8000a974:	a1 a6       	sbr	r6,0x0
8000a976:	91 16       	st.w	r8[0x4],r6
8000a978:	e0 68 0d 88 	mov	r8,3464
8000a97c:	70 09       	ld.w	r9,r8[0x0]
8000a97e:	0a 19       	sub	r9,r5
8000a980:	0e 9c       	mov	r12,r7
8000a982:	91 09       	st.w	r8[0x0],r9
8000a984:	fe b0 d6 f2 	rcall	80005768 <__malloc_unlock>
8000a988:	da 2a       	popm	r4-r7,pc,r12=1
8000a98a:	d7 03       	nop

8000a98c <_free_r>:
8000a98c:	d4 21       	pushm	r4-r7,lr
8000a98e:	16 96       	mov	r6,r11
8000a990:	18 97       	mov	r7,r12
8000a992:	58 0b       	cp.w	r11,0
8000a994:	e0 80 00 c0 	breq	8000ab14 <_free_r+0x188>
8000a998:	fe b0 d6 e2 	rcall	8000575c <__malloc_lock>
8000a99c:	20 86       	sub	r6,8
8000a99e:	e0 6a 05 30 	mov	r10,1328
8000a9a2:	6c 18       	ld.w	r8,r6[0x4]
8000a9a4:	74 2e       	ld.w	lr,r10[0x8]
8000a9a6:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
8000a9aa:	a1 c8       	cbr	r8,0x0
8000a9ac:	ec 08 00 09 	add	r9,r6,r8
8000a9b0:	72 1b       	ld.w	r11,r9[0x4]
8000a9b2:	e0 1b ff fc 	andl	r11,0xfffc
8000a9b6:	1c 39       	cp.w	r9,lr
8000a9b8:	c1 e1       	brne	8000a9f4 <_free_r+0x68>
8000a9ba:	f6 08 00 08 	add	r8,r11,r8
8000a9be:	58 0c       	cp.w	r12,0
8000a9c0:	c0 81       	brne	8000a9d0 <_free_r+0x44>
8000a9c2:	6c 09       	ld.w	r9,r6[0x0]
8000a9c4:	12 16       	sub	r6,r9
8000a9c6:	12 08       	add	r8,r9
8000a9c8:	6c 3b       	ld.w	r11,r6[0xc]
8000a9ca:	6c 29       	ld.w	r9,r6[0x8]
8000a9cc:	97 29       	st.w	r11[0x8],r9
8000a9ce:	93 3b       	st.w	r9[0xc],r11
8000a9d0:	10 99       	mov	r9,r8
8000a9d2:	95 26       	st.w	r10[0x8],r6
8000a9d4:	a1 a9       	sbr	r9,0x0
8000a9d6:	8d 19       	st.w	r6[0x4],r9
8000a9d8:	e0 69 09 38 	mov	r9,2360
8000a9dc:	72 09       	ld.w	r9,r9[0x0]
8000a9de:	12 38       	cp.w	r8,r9
8000a9e0:	c0 63       	brcs	8000a9ec <_free_r+0x60>
8000a9e2:	e0 68 0d 84 	mov	r8,3460
8000a9e6:	0e 9c       	mov	r12,r7
8000a9e8:	70 0b       	ld.w	r11,r8[0x0]
8000a9ea:	c8 5f       	rcall	8000a8f4 <_malloc_trim_r>
8000a9ec:	0e 9c       	mov	r12,r7
8000a9ee:	fe b0 d6 bd 	rcall	80005768 <__malloc_unlock>
8000a9f2:	d8 22       	popm	r4-r7,pc
8000a9f4:	93 1b       	st.w	r9[0x4],r11
8000a9f6:	58 0c       	cp.w	r12,0
8000a9f8:	c0 30       	breq	8000a9fe <_free_r+0x72>
8000a9fa:	30 0c       	mov	r12,0
8000a9fc:	c1 08       	rjmp	8000aa1c <_free_r+0x90>
8000a9fe:	6c 0e       	ld.w	lr,r6[0x0]
8000aa00:	f4 c5 ff f8 	sub	r5,r10,-8
8000aa04:	1c 16       	sub	r6,lr
8000aa06:	1c 08       	add	r8,lr
8000aa08:	6c 2e       	ld.w	lr,r6[0x8]
8000aa0a:	0a 3e       	cp.w	lr,r5
8000aa0c:	f9 bc 00 01 	moveq	r12,1
8000aa10:	ed f5 10 03 	ld.wne	r5,r6[0xc]
8000aa14:	eb fe 1a 02 	st.wne	r5[0x8],lr
8000aa18:	fd f5 1a 03 	st.wne	lr[0xc],r5
8000aa1c:	f2 0b 00 0e 	add	lr,r9,r11
8000aa20:	7c 1e       	ld.w	lr,lr[0x4]
8000aa22:	ed be 00 00 	bld	lr,0x0
8000aa26:	c1 40       	breq	8000aa4e <_free_r+0xc2>
8000aa28:	16 08       	add	r8,r11
8000aa2a:	58 0c       	cp.w	r12,0
8000aa2c:	c0 d1       	brne	8000aa46 <_free_r+0xba>
8000aa2e:	e0 6e 05 30 	mov	lr,1328
8000aa32:	72 2b       	ld.w	r11,r9[0x8]
8000aa34:	2f 8e       	sub	lr,-8
8000aa36:	1c 3b       	cp.w	r11,lr
8000aa38:	c0 71       	brne	8000aa46 <_free_r+0xba>
8000aa3a:	97 36       	st.w	r11[0xc],r6
8000aa3c:	97 26       	st.w	r11[0x8],r6
8000aa3e:	8d 2b       	st.w	r6[0x8],r11
8000aa40:	8d 3b       	st.w	r6[0xc],r11
8000aa42:	30 1c       	mov	r12,1
8000aa44:	c0 58       	rjmp	8000aa4e <_free_r+0xc2>
8000aa46:	72 2b       	ld.w	r11,r9[0x8]
8000aa48:	72 39       	ld.w	r9,r9[0xc]
8000aa4a:	93 2b       	st.w	r9[0x8],r11
8000aa4c:	97 39       	st.w	r11[0xc],r9
8000aa4e:	10 99       	mov	r9,r8
8000aa50:	ec 08 09 08 	st.w	r6[r8],r8
8000aa54:	a1 a9       	sbr	r9,0x0
8000aa56:	8d 19       	st.w	r6[0x4],r9
8000aa58:	58 0c       	cp.w	r12,0
8000aa5a:	c5 a1       	brne	8000ab0e <_free_r+0x182>
8000aa5c:	e0 48 01 ff 	cp.w	r8,511
8000aa60:	e0 8b 00 13 	brhi	8000aa86 <_free_r+0xfa>
8000aa64:	a3 98       	lsr	r8,0x3
8000aa66:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000aa6a:	72 2b       	ld.w	r11,r9[0x8]
8000aa6c:	8d 39       	st.w	r6[0xc],r9
8000aa6e:	8d 2b       	st.w	r6[0x8],r11
8000aa70:	97 36       	st.w	r11[0xc],r6
8000aa72:	93 26       	st.w	r9[0x8],r6
8000aa74:	a3 48       	asr	r8,0x2
8000aa76:	74 19       	ld.w	r9,r10[0x4]
8000aa78:	30 1b       	mov	r11,1
8000aa7a:	f6 08 09 48 	lsl	r8,r11,r8
8000aa7e:	f3 e8 10 08 	or	r8,r9,r8
8000aa82:	95 18       	st.w	r10[0x4],r8
8000aa84:	c4 58       	rjmp	8000ab0e <_free_r+0x182>
8000aa86:	f0 0b 16 09 	lsr	r11,r8,0x9
8000aa8a:	58 4b       	cp.w	r11,4
8000aa8c:	e0 8b 00 06 	brhi	8000aa98 <_free_r+0x10c>
8000aa90:	f0 0b 16 06 	lsr	r11,r8,0x6
8000aa94:	2c 8b       	sub	r11,-56
8000aa96:	c2 08       	rjmp	8000aad6 <_free_r+0x14a>
8000aa98:	59 4b       	cp.w	r11,20
8000aa9a:	e0 8b 00 04 	brhi	8000aaa2 <_free_r+0x116>
8000aa9e:	2a 5b       	sub	r11,-91
8000aaa0:	c1 b8       	rjmp	8000aad6 <_free_r+0x14a>
8000aaa2:	e0 4b 00 54 	cp.w	r11,84
8000aaa6:	e0 8b 00 06 	brhi	8000aab2 <_free_r+0x126>
8000aaaa:	f0 0b 16 0c 	lsr	r11,r8,0xc
8000aaae:	29 2b       	sub	r11,-110
8000aab0:	c1 38       	rjmp	8000aad6 <_free_r+0x14a>
8000aab2:	e0 4b 01 54 	cp.w	r11,340
8000aab6:	e0 8b 00 06 	brhi	8000aac2 <_free_r+0x136>
8000aaba:	f0 0b 16 0f 	lsr	r11,r8,0xf
8000aabe:	28 9b       	sub	r11,-119
8000aac0:	c0 b8       	rjmp	8000aad6 <_free_r+0x14a>
8000aac2:	e0 4b 05 54 	cp.w	r11,1364
8000aac6:	e0 88 00 05 	brls	8000aad0 <_free_r+0x144>
8000aaca:	37 eb       	mov	r11,126
8000aacc:	c0 58       	rjmp	8000aad6 <_free_r+0x14a>
8000aace:	d7 03       	nop
8000aad0:	f0 0b 16 12 	lsr	r11,r8,0x12
8000aad4:	28 4b       	sub	r11,-124
8000aad6:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
8000aada:	78 29       	ld.w	r9,r12[0x8]
8000aadc:	18 39       	cp.w	r9,r12
8000aade:	c0 e1       	brne	8000aafa <_free_r+0x16e>
8000aae0:	74 18       	ld.w	r8,r10[0x4]
8000aae2:	a3 4b       	asr	r11,0x2
8000aae4:	30 1c       	mov	r12,1
8000aae6:	f8 0b 09 4b 	lsl	r11,r12,r11
8000aaea:	f1 eb 10 0b 	or	r11,r8,r11
8000aaee:	12 98       	mov	r8,r9
8000aaf0:	95 1b       	st.w	r10[0x4],r11
8000aaf2:	c0 a8       	rjmp	8000ab06 <_free_r+0x17a>
8000aaf4:	72 29       	ld.w	r9,r9[0x8]
8000aaf6:	18 39       	cp.w	r9,r12
8000aaf8:	c0 60       	breq	8000ab04 <_free_r+0x178>
8000aafa:	72 1a       	ld.w	r10,r9[0x4]
8000aafc:	e0 1a ff fc 	andl	r10,0xfffc
8000ab00:	14 38       	cp.w	r8,r10
8000ab02:	cf 93       	brcs	8000aaf4 <_free_r+0x168>
8000ab04:	72 38       	ld.w	r8,r9[0xc]
8000ab06:	8d 38       	st.w	r6[0xc],r8
8000ab08:	8d 29       	st.w	r6[0x8],r9
8000ab0a:	93 36       	st.w	r9[0xc],r6
8000ab0c:	91 26       	st.w	r8[0x8],r6
8000ab0e:	0e 9c       	mov	r12,r7
8000ab10:	fe b0 d6 2c 	rcall	80005768 <__malloc_unlock>
8000ab14:	d8 22       	popm	r4-r7,pc
8000ab16:	d7 03       	nop

8000ab18 <__sfvwrite_r>:
8000ab18:	d4 31       	pushm	r0-r7,lr
8000ab1a:	20 3d       	sub	sp,12
8000ab1c:	14 94       	mov	r4,r10
8000ab1e:	18 95       	mov	r5,r12
8000ab20:	16 97       	mov	r7,r11
8000ab22:	74 28       	ld.w	r8,r10[0x8]
8000ab24:	58 08       	cp.w	r8,0
8000ab26:	e0 80 01 40 	breq	8000ada6 <__sfvwrite_r+0x28e>
8000ab2a:	96 68       	ld.sh	r8,r11[0xc]
8000ab2c:	ed b8 00 03 	bld	r8,0x3
8000ab30:	c0 41       	brne	8000ab38 <__sfvwrite_r+0x20>
8000ab32:	76 48       	ld.w	r8,r11[0x10]
8000ab34:	58 08       	cp.w	r8,0
8000ab36:	c0 c1       	brne	8000ab4e <__sfvwrite_r+0x36>
8000ab38:	0e 9b       	mov	r11,r7
8000ab3a:	0a 9c       	mov	r12,r5
8000ab3c:	fe b0 f6 bc 	rcall	800098b4 <__swsetup_r>
8000ab40:	c0 70       	breq	8000ab4e <__sfvwrite_r+0x36>
8000ab42:	8e 68       	ld.sh	r8,r7[0xc]
8000ab44:	a7 a8       	sbr	r8,0x6
8000ab46:	ae 68       	st.h	r7[0xc],r8
8000ab48:	30 98       	mov	r8,9
8000ab4a:	8b 38       	st.w	r5[0xc],r8
8000ab4c:	c2 b9       	rjmp	8000ada2 <__sfvwrite_r+0x28a>
8000ab4e:	8e 63       	ld.sh	r3,r7[0xc]
8000ab50:	68 00       	ld.w	r0,r4[0x0]
8000ab52:	06 96       	mov	r6,r3
8000ab54:	e2 16 00 02 	andl	r6,0x2,COH
8000ab58:	c2 10       	breq	8000ab9a <__sfvwrite_r+0x82>
8000ab5a:	30 03       	mov	r3,0
8000ab5c:	e0 62 04 00 	mov	r2,1024
8000ab60:	06 96       	mov	r6,r3
8000ab62:	c0 48       	rjmp	8000ab6a <__sfvwrite_r+0x52>
8000ab64:	60 03       	ld.w	r3,r0[0x0]
8000ab66:	60 16       	ld.w	r6,r0[0x4]
8000ab68:	2f 80       	sub	r0,-8
8000ab6a:	58 06       	cp.w	r6,0
8000ab6c:	cf c0       	breq	8000ab64 <__sfvwrite_r+0x4c>
8000ab6e:	e0 46 04 00 	cp.w	r6,1024
8000ab72:	ec 09 17 80 	movls	r9,r6
8000ab76:	e4 09 17 b0 	movhi	r9,r2
8000ab7a:	06 9a       	mov	r10,r3
8000ab7c:	6e a8       	ld.w	r8,r7[0x28]
8000ab7e:	6e 8b       	ld.w	r11,r7[0x20]
8000ab80:	0a 9c       	mov	r12,r5
8000ab82:	5d 18       	icall	r8
8000ab84:	18 16       	sub	r6,r12
8000ab86:	58 0c       	cp.w	r12,0
8000ab88:	e0 8a 01 0a 	brle	8000ad9c <__sfvwrite_r+0x284>
8000ab8c:	68 28       	ld.w	r8,r4[0x8]
8000ab8e:	18 18       	sub	r8,r12
8000ab90:	89 28       	st.w	r4[0x8],r8
8000ab92:	e0 80 01 0a 	breq	8000ada6 <__sfvwrite_r+0x28e>
8000ab96:	18 03       	add	r3,r12
8000ab98:	ce 9b       	rjmp	8000ab6a <__sfvwrite_r+0x52>
8000ab9a:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
8000ab9e:	c0 70       	breq	8000abac <__sfvwrite_r+0x94>
8000aba0:	50 06       	stdsp	sp[0x0],r6
8000aba2:	0c 93       	mov	r3,r6
8000aba4:	0c 91       	mov	r1,r6
8000aba6:	50 15       	stdsp	sp[0x4],r5
8000aba8:	08 92       	mov	r2,r4
8000abaa:	c9 c8       	rjmp	8000ace2 <__sfvwrite_r+0x1ca>
8000abac:	06 96       	mov	r6,r3
8000abae:	08 91       	mov	r1,r4
8000abb0:	c0 48       	rjmp	8000abb8 <__sfvwrite_r+0xa0>
8000abb2:	60 03       	ld.w	r3,r0[0x0]
8000abb4:	60 16       	ld.w	r6,r0[0x4]
8000abb6:	2f 80       	sub	r0,-8
8000abb8:	58 06       	cp.w	r6,0
8000abba:	cf c0       	breq	8000abb2 <__sfvwrite_r+0x9a>
8000abbc:	8e 68       	ld.sh	r8,r7[0xc]
8000abbe:	6e 24       	ld.w	r4,r7[0x8]
8000abc0:	10 99       	mov	r9,r8
8000abc2:	e2 19 02 00 	andl	r9,0x200,COH
8000abc6:	c5 50       	breq	8000ac70 <__sfvwrite_r+0x158>
8000abc8:	08 36       	cp.w	r6,r4
8000abca:	c4 43       	brcs	8000ac52 <__sfvwrite_r+0x13a>
8000abcc:	10 99       	mov	r9,r8
8000abce:	e2 19 04 80 	andl	r9,0x480,COH
8000abd2:	c4 00       	breq	8000ac52 <__sfvwrite_r+0x13a>
8000abd4:	6e 4b       	ld.w	r11,r7[0x10]
8000abd6:	6e 09       	ld.w	r9,r7[0x0]
8000abd8:	16 19       	sub	r9,r11
8000abda:	50 09       	stdsp	sp[0x0],r9
8000abdc:	6e 59       	ld.w	r9,r7[0x14]
8000abde:	10 9c       	mov	r12,r8
8000abe0:	f2 09 00 1a 	add	r10,r9,r9<<0x1
8000abe4:	30 28       	mov	r8,2
8000abe6:	f4 08 0c 08 	divs	r8,r10,r8
8000abea:	fa e9 00 04 	st.d	sp[4],r8
8000abee:	10 94       	mov	r4,r8
8000abf0:	40 09       	lddsp	r9,sp[0x0]
8000abf2:	e2 1c 04 00 	andl	r12,0x400,COH
8000abf6:	2f f9       	sub	r9,-1
8000abf8:	0c 09       	add	r9,r6
8000abfa:	12 38       	cp.w	r8,r9
8000abfc:	f2 04 17 30 	movlo	r4,r9
8000ac00:	58 0c       	cp.w	r12,0
8000ac02:	c1 10       	breq	8000ac24 <__sfvwrite_r+0x10c>
8000ac04:	08 9b       	mov	r11,r4
8000ac06:	0a 9c       	mov	r12,r5
8000ac08:	fe b0 e0 3e 	rcall	80006c84 <_malloc_r>
8000ac0c:	18 92       	mov	r2,r12
8000ac0e:	c1 40       	breq	8000ac36 <__sfvwrite_r+0x11e>
8000ac10:	40 0a       	lddsp	r10,sp[0x0]
8000ac12:	6e 4b       	ld.w	r11,r7[0x10]
8000ac14:	fe b0 e2 54 	rcall	800070bc <memcpy>
8000ac18:	8e 68       	ld.sh	r8,r7[0xc]
8000ac1a:	e0 18 fb 7f 	andl	r8,0xfb7f
8000ac1e:	a7 b8       	sbr	r8,0x7
8000ac20:	ae 68       	st.h	r7[0xc],r8
8000ac22:	c0 d8       	rjmp	8000ac3c <__sfvwrite_r+0x124>
8000ac24:	08 9a       	mov	r10,r4
8000ac26:	0a 9c       	mov	r12,r5
8000ac28:	fe b0 e2 f6 	rcall	80007214 <_realloc_r>
8000ac2c:	18 92       	mov	r2,r12
8000ac2e:	c0 71       	brne	8000ac3c <__sfvwrite_r+0x124>
8000ac30:	6e 4b       	ld.w	r11,r7[0x10]
8000ac32:	0a 9c       	mov	r12,r5
8000ac34:	ca ce       	rcall	8000a98c <_free_r>
8000ac36:	30 c8       	mov	r8,12
8000ac38:	8b 38       	st.w	r5[0xc],r8
8000ac3a:	cb 18       	rjmp	8000ad9c <__sfvwrite_r+0x284>
8000ac3c:	40 0a       	lddsp	r10,sp[0x0]
8000ac3e:	40 09       	lddsp	r9,sp[0x0]
8000ac40:	e8 0a 01 0a 	sub	r10,r4,r10
8000ac44:	e4 09 00 08 	add	r8,r2,r9
8000ac48:	8f 54       	st.w	r7[0x14],r4
8000ac4a:	8f 2a       	st.w	r7[0x8],r10
8000ac4c:	8f 08       	st.w	r7[0x0],r8
8000ac4e:	8f 42       	st.w	r7[0x10],r2
8000ac50:	0c 94       	mov	r4,r6
8000ac52:	08 36       	cp.w	r6,r4
8000ac54:	ec 04 17 30 	movlo	r4,r6
8000ac58:	06 9b       	mov	r11,r3
8000ac5a:	08 9a       	mov	r10,r4
8000ac5c:	6e 0c       	ld.w	r12,r7[0x0]
8000ac5e:	c3 ad       	rcall	8000aed2 <memmove>
8000ac60:	6e 08       	ld.w	r8,r7[0x0]
8000ac62:	08 08       	add	r8,r4
8000ac64:	8f 08       	st.w	r7[0x0],r8
8000ac66:	6e 28       	ld.w	r8,r7[0x8]
8000ac68:	08 18       	sub	r8,r4
8000ac6a:	0c 94       	mov	r4,r6
8000ac6c:	8f 28       	st.w	r7[0x8],r8
8000ac6e:	c2 e8       	rjmp	8000acca <__sfvwrite_r+0x1b2>
8000ac70:	08 36       	cp.w	r6,r4
8000ac72:	5f ba       	srhi	r10
8000ac74:	6e 0c       	ld.w	r12,r7[0x0]
8000ac76:	6e 48       	ld.w	r8,r7[0x10]
8000ac78:	10 3c       	cp.w	r12,r8
8000ac7a:	5f b8       	srhi	r8
8000ac7c:	f5 e8 00 08 	and	r8,r10,r8
8000ac80:	f2 08 18 00 	cp.b	r8,r9
8000ac84:	c0 d0       	breq	8000ac9e <__sfvwrite_r+0x186>
8000ac86:	06 9b       	mov	r11,r3
8000ac88:	08 9a       	mov	r10,r4
8000ac8a:	c2 4d       	rcall	8000aed2 <memmove>
8000ac8c:	6e 08       	ld.w	r8,r7[0x0]
8000ac8e:	08 08       	add	r8,r4
8000ac90:	0e 9b       	mov	r11,r7
8000ac92:	8f 08       	st.w	r7[0x0],r8
8000ac94:	0a 9c       	mov	r12,r5
8000ac96:	fe b0 fd 05 	rcall	8000a6a0 <_fflush_r>
8000ac9a:	c1 80       	breq	8000acca <__sfvwrite_r+0x1b2>
8000ac9c:	c8 08       	rjmp	8000ad9c <__sfvwrite_r+0x284>
8000ac9e:	6e 59       	ld.w	r9,r7[0x14]
8000aca0:	12 36       	cp.w	r6,r9
8000aca2:	c0 a3       	brcs	8000acb6 <__sfvwrite_r+0x19e>
8000aca4:	6e a8       	ld.w	r8,r7[0x28]
8000aca6:	06 9a       	mov	r10,r3
8000aca8:	6e 8b       	ld.w	r11,r7[0x20]
8000acaa:	0a 9c       	mov	r12,r5
8000acac:	5d 18       	icall	r8
8000acae:	18 94       	mov	r4,r12
8000acb0:	e0 89 00 0d 	brgt	8000acca <__sfvwrite_r+0x1b2>
8000acb4:	c7 48       	rjmp	8000ad9c <__sfvwrite_r+0x284>
8000acb6:	0c 9a       	mov	r10,r6
8000acb8:	06 9b       	mov	r11,r3
8000acba:	c0 cd       	rcall	8000aed2 <memmove>
8000acbc:	6e 08       	ld.w	r8,r7[0x0]
8000acbe:	0c 08       	add	r8,r6
8000acc0:	0c 94       	mov	r4,r6
8000acc2:	8f 08       	st.w	r7[0x0],r8
8000acc4:	6e 28       	ld.w	r8,r7[0x8]
8000acc6:	0c 18       	sub	r8,r6
8000acc8:	8f 28       	st.w	r7[0x8],r8
8000acca:	62 28       	ld.w	r8,r1[0x8]
8000accc:	08 18       	sub	r8,r4
8000acce:	83 28       	st.w	r1[0x8],r8
8000acd0:	c6 b0       	breq	8000ada6 <__sfvwrite_r+0x28e>
8000acd2:	08 16       	sub	r6,r4
8000acd4:	08 03       	add	r3,r4
8000acd6:	c7 1b       	rjmp	8000abb8 <__sfvwrite_r+0xa0>
8000acd8:	60 03       	ld.w	r3,r0[0x0]
8000acda:	60 11       	ld.w	r1,r0[0x4]
8000acdc:	30 08       	mov	r8,0
8000acde:	2f 80       	sub	r0,-8
8000ace0:	50 08       	stdsp	sp[0x0],r8
8000ace2:	58 01       	cp.w	r1,0
8000ace4:	cf a0       	breq	8000acd8 <__sfvwrite_r+0x1c0>
8000ace6:	40 0a       	lddsp	r10,sp[0x0]
8000ace8:	58 0a       	cp.w	r10,0
8000acea:	c1 41       	brne	8000ad12 <__sfvwrite_r+0x1fa>
8000acec:	e2 c6 ff ff 	sub	r6,r1,-1
8000acf0:	02 9a       	mov	r10,r1
8000acf2:	30 ab       	mov	r11,10
8000acf4:	06 9c       	mov	r12,r3
8000acf6:	ce 3c       	rcall	8000aebc <memchr>
8000acf8:	f8 c8 ff ff 	sub	r8,r12,-1
8000acfc:	58 0c       	cp.w	r12,0
8000acfe:	f1 d3 e1 16 	subne	r6,r8,r3
8000ad02:	f9 b9 01 01 	movne	r9,1
8000ad06:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000ad0a:	f9 b8 00 01 	moveq	r8,1
8000ad0e:	fb f8 0a 00 	st.weq	sp[0x0],r8
8000ad12:	02 36       	cp.w	r6,r1
8000ad14:	ec 04 17 80 	movls	r4,r6
8000ad18:	e2 04 17 b0 	movhi	r4,r1
8000ad1c:	6e 59       	ld.w	r9,r7[0x14]
8000ad1e:	6e 25       	ld.w	r5,r7[0x8]
8000ad20:	f2 05 00 05 	add	r5,r9,r5
8000ad24:	0a 34       	cp.w	r4,r5
8000ad26:	5f 9a       	srgt	r10
8000ad28:	6e 0c       	ld.w	r12,r7[0x0]
8000ad2a:	6e 48       	ld.w	r8,r7[0x10]
8000ad2c:	10 3c       	cp.w	r12,r8
8000ad2e:	5f b8       	srhi	r8
8000ad30:	f5 e8 00 08 	and	r8,r10,r8
8000ad34:	30 0a       	mov	r10,0
8000ad36:	f4 08 18 00 	cp.b	r8,r10
8000ad3a:	c0 d0       	breq	8000ad54 <__sfvwrite_r+0x23c>
8000ad3c:	06 9b       	mov	r11,r3
8000ad3e:	0a 9a       	mov	r10,r5
8000ad40:	cc 9c       	rcall	8000aed2 <memmove>
8000ad42:	6e 08       	ld.w	r8,r7[0x0]
8000ad44:	0a 08       	add	r8,r5
8000ad46:	0e 9b       	mov	r11,r7
8000ad48:	8f 08       	st.w	r7[0x0],r8
8000ad4a:	40 1c       	lddsp	r12,sp[0x4]
8000ad4c:	fe b0 fc aa 	rcall	8000a6a0 <_fflush_r>
8000ad50:	c1 70       	breq	8000ad7e <__sfvwrite_r+0x266>
8000ad52:	c2 58       	rjmp	8000ad9c <__sfvwrite_r+0x284>
8000ad54:	12 34       	cp.w	r4,r9
8000ad56:	c0 a5       	brlt	8000ad6a <__sfvwrite_r+0x252>
8000ad58:	6e a8       	ld.w	r8,r7[0x28]
8000ad5a:	06 9a       	mov	r10,r3
8000ad5c:	6e 8b       	ld.w	r11,r7[0x20]
8000ad5e:	40 1c       	lddsp	r12,sp[0x4]
8000ad60:	5d 18       	icall	r8
8000ad62:	18 95       	mov	r5,r12
8000ad64:	e0 89 00 0d 	brgt	8000ad7e <__sfvwrite_r+0x266>
8000ad68:	c1 a8       	rjmp	8000ad9c <__sfvwrite_r+0x284>
8000ad6a:	08 9a       	mov	r10,r4
8000ad6c:	06 9b       	mov	r11,r3
8000ad6e:	cb 2c       	rcall	8000aed2 <memmove>
8000ad70:	6e 08       	ld.w	r8,r7[0x0]
8000ad72:	08 08       	add	r8,r4
8000ad74:	08 95       	mov	r5,r4
8000ad76:	8f 08       	st.w	r7[0x0],r8
8000ad78:	6e 28       	ld.w	r8,r7[0x8]
8000ad7a:	08 18       	sub	r8,r4
8000ad7c:	8f 28       	st.w	r7[0x8],r8
8000ad7e:	0a 16       	sub	r6,r5
8000ad80:	c0 71       	brne	8000ad8e <__sfvwrite_r+0x276>
8000ad82:	0e 9b       	mov	r11,r7
8000ad84:	40 1c       	lddsp	r12,sp[0x4]
8000ad86:	fe b0 fc 8d 	rcall	8000a6a0 <_fflush_r>
8000ad8a:	c0 91       	brne	8000ad9c <__sfvwrite_r+0x284>
8000ad8c:	50 06       	stdsp	sp[0x0],r6
8000ad8e:	64 28       	ld.w	r8,r2[0x8]
8000ad90:	0a 18       	sub	r8,r5
8000ad92:	85 28       	st.w	r2[0x8],r8
8000ad94:	c0 90       	breq	8000ada6 <__sfvwrite_r+0x28e>
8000ad96:	0a 11       	sub	r1,r5
8000ad98:	0a 03       	add	r3,r5
8000ad9a:	ca 4b       	rjmp	8000ace2 <__sfvwrite_r+0x1ca>
8000ad9c:	8e 68       	ld.sh	r8,r7[0xc]
8000ad9e:	a7 a8       	sbr	r8,0x6
8000ada0:	ae 68       	st.h	r7[0xc],r8
8000ada2:	3f fc       	mov	r12,-1
8000ada4:	c0 28       	rjmp	8000ada8 <__sfvwrite_r+0x290>
8000ada6:	30 0c       	mov	r12,0
8000ada8:	2f dd       	sub	sp,-12
8000adaa:	d8 32       	popm	r0-r7,pc

8000adac <_fwalk>:
8000adac:	d4 31       	pushm	r0-r7,lr
8000adae:	30 05       	mov	r5,0
8000adb0:	16 91       	mov	r1,r11
8000adb2:	f8 c7 ff 28 	sub	r7,r12,-216
8000adb6:	0a 92       	mov	r2,r5
8000adb8:	fe b0 fc fc 	rcall	8000a7b0 <__sfp_lock_acquire>
8000adbc:	3f f3       	mov	r3,-1
8000adbe:	c1 68       	rjmp	8000adea <_fwalk+0x3e>
8000adc0:	6e 26       	ld.w	r6,r7[0x8]
8000adc2:	6e 14       	ld.w	r4,r7[0x4]
8000adc4:	2f 46       	sub	r6,-12
8000adc6:	c0 c8       	rjmp	8000adde <_fwalk+0x32>
8000adc8:	8c 08       	ld.sh	r8,r6[0x0]
8000adca:	e4 08 19 00 	cp.h	r8,r2
8000adce:	c0 70       	breq	8000addc <_fwalk+0x30>
8000add0:	8c 18       	ld.sh	r8,r6[0x2]
8000add2:	e6 08 19 00 	cp.h	r8,r3
8000add6:	c0 30       	breq	8000addc <_fwalk+0x30>
8000add8:	5d 11       	icall	r1
8000adda:	18 45       	or	r5,r12
8000addc:	2a 46       	sub	r6,-92
8000adde:	20 14       	sub	r4,1
8000ade0:	ec cc 00 0c 	sub	r12,r6,12
8000ade4:	58 04       	cp.w	r4,0
8000ade6:	cf 14       	brge	8000adc8 <_fwalk+0x1c>
8000ade8:	6e 07       	ld.w	r7,r7[0x0]
8000adea:	58 07       	cp.w	r7,0
8000adec:	ce a1       	brne	8000adc0 <_fwalk+0x14>
8000adee:	fe b0 fc e2 	rcall	8000a7b2 <__sfp_lock_release>
8000adf2:	0a 9c       	mov	r12,r5
8000adf4:	d8 32       	popm	r0-r7,pc
8000adf6:	d7 03       	nop

8000adf8 <_localeconv_r>:
8000adf8:	48 1c       	lddpc	r12,8000adfc <_localeconv_r+0x4>
8000adfa:	5e fc       	retal	r12
8000adfc:	80 01       	ld.sh	r1,r0[0x0]
8000adfe:	62 48       	ld.w	r8,r1[0x10]

8000ae00 <__smakebuf_r>:
8000ae00:	d4 21       	pushm	r4-r7,lr
8000ae02:	20 fd       	sub	sp,60
8000ae04:	96 68       	ld.sh	r8,r11[0xc]
8000ae06:	16 97       	mov	r7,r11
8000ae08:	18 96       	mov	r6,r12
8000ae0a:	e2 18 00 02 	andl	r8,0x2,COH
8000ae0e:	c3 d1       	brne	8000ae88 <__smakebuf_r+0x88>
8000ae10:	96 7b       	ld.sh	r11,r11[0xe]
8000ae12:	f0 0b 19 00 	cp.h	r11,r8
8000ae16:	c0 55       	brlt	8000ae20 <__smakebuf_r+0x20>
8000ae18:	1a 9a       	mov	r10,sp
8000ae1a:	e0 a0 04 79 	rcall	8000b70c <_fstat_r>
8000ae1e:	c0 f4       	brge	8000ae3c <__smakebuf_r+0x3c>
8000ae20:	8e 65       	ld.sh	r5,r7[0xc]
8000ae22:	0a 98       	mov	r8,r5
8000ae24:	ab b8       	sbr	r8,0xb
8000ae26:	e2 15 00 80 	andl	r5,0x80,COH
8000ae2a:	ae 68       	st.h	r7[0xc],r8
8000ae2c:	30 04       	mov	r4,0
8000ae2e:	e0 68 04 00 	mov	r8,1024
8000ae32:	f9 b5 01 40 	movne	r5,64
8000ae36:	f0 05 17 00 	moveq	r5,r8
8000ae3a:	c1 c8       	rjmp	8000ae72 <__smakebuf_r+0x72>
8000ae3c:	40 18       	lddsp	r8,sp[0x4]
8000ae3e:	e2 18 f0 00 	andl	r8,0xf000,COH
8000ae42:	e0 48 20 00 	cp.w	r8,8192
8000ae46:	5f 04       	sreq	r4
8000ae48:	e0 48 80 00 	cp.w	r8,32768
8000ae4c:	c0 e1       	brne	8000ae68 <__smakebuf_r+0x68>
8000ae4e:	6e b9       	ld.w	r9,r7[0x2c]
8000ae50:	fe c8 f9 18 	sub	r8,pc,-1768
8000ae54:	10 39       	cp.w	r9,r8
8000ae56:	c0 91       	brne	8000ae68 <__smakebuf_r+0x68>
8000ae58:	8e 68       	ld.sh	r8,r7[0xc]
8000ae5a:	e0 65 04 00 	mov	r5,1024
8000ae5e:	ab a8       	sbr	r8,0xa
8000ae60:	ef 45 00 50 	st.w	r7[80],r5
8000ae64:	ae 68       	st.h	r7[0xc],r8
8000ae66:	c0 68       	rjmp	8000ae72 <__smakebuf_r+0x72>
8000ae68:	8e 68       	ld.sh	r8,r7[0xc]
8000ae6a:	e0 65 04 00 	mov	r5,1024
8000ae6e:	ab b8       	sbr	r8,0xb
8000ae70:	ae 68       	st.h	r7[0xc],r8
8000ae72:	0a 9b       	mov	r11,r5
8000ae74:	0c 9c       	mov	r12,r6
8000ae76:	fe b0 df 07 	rcall	80006c84 <_malloc_r>
8000ae7a:	8e 68       	ld.sh	r8,r7[0xc]
8000ae7c:	c0 d1       	brne	8000ae96 <__smakebuf_r+0x96>
8000ae7e:	ed b8 00 09 	bld	r8,0x9
8000ae82:	c1 b0       	breq	8000aeb8 <__smakebuf_r+0xb8>
8000ae84:	a1 b8       	sbr	r8,0x1
8000ae86:	ae 68       	st.h	r7[0xc],r8
8000ae88:	ee c8 ff b9 	sub	r8,r7,-71
8000ae8c:	8f 48       	st.w	r7[0x10],r8
8000ae8e:	8f 08       	st.w	r7[0x0],r8
8000ae90:	30 18       	mov	r8,1
8000ae92:	8f 58       	st.w	r7[0x14],r8
8000ae94:	c1 28       	rjmp	8000aeb8 <__smakebuf_r+0xb8>
8000ae96:	a7 b8       	sbr	r8,0x7
8000ae98:	8f 4c       	st.w	r7[0x10],r12
8000ae9a:	ae 68       	st.h	r7[0xc],r8
8000ae9c:	8f 55       	st.w	r7[0x14],r5
8000ae9e:	fe c8 06 ea 	sub	r8,pc,1770
8000aea2:	8f 0c       	st.w	r7[0x0],r12
8000aea4:	8d a8       	st.w	r6[0x28],r8
8000aea6:	58 04       	cp.w	r4,0
8000aea8:	c0 80       	breq	8000aeb8 <__smakebuf_r+0xb8>
8000aeaa:	8e 7c       	ld.sh	r12,r7[0xe]
8000aeac:	fe b0 e3 7a 	rcall	800075a0 <isatty>
8000aeb0:	c0 40       	breq	8000aeb8 <__smakebuf_r+0xb8>
8000aeb2:	8e 68       	ld.sh	r8,r7[0xc]
8000aeb4:	a1 a8       	sbr	r8,0x0
8000aeb6:	ae 68       	st.h	r7[0xc],r8
8000aeb8:	2f 1d       	sub	sp,-60
8000aeba:	d8 22       	popm	r4-r7,pc

8000aebc <memchr>:
8000aebc:	f7 db c0 08 	bfextu	r11,r11,0x0,0x8
8000aec0:	c0 68       	rjmp	8000aecc <memchr+0x10>
8000aec2:	20 1a       	sub	r10,1
8000aec4:	19 88       	ld.ub	r8,r12[0x0]
8000aec6:	16 38       	cp.w	r8,r11
8000aec8:	5e 0c       	reteq	r12
8000aeca:	2f fc       	sub	r12,-1
8000aecc:	58 0a       	cp.w	r10,0
8000aece:	cf a1       	brne	8000aec2 <memchr+0x6>
8000aed0:	5e fa       	retal	r10

8000aed2 <memmove>:
8000aed2:	d4 01       	pushm	lr
8000aed4:	18 3b       	cp.w	r11,r12
8000aed6:	c1 92       	brcc	8000af08 <memmove+0x36>
8000aed8:	f6 0a 00 09 	add	r9,r11,r10
8000aedc:	12 3c       	cp.w	r12,r9
8000aede:	c1 52       	brcc	8000af08 <memmove+0x36>
8000aee0:	f8 0a 00 0b 	add	r11,r12,r10
8000aee4:	30 08       	mov	r8,0
8000aee6:	c0 68       	rjmp	8000aef2 <memmove+0x20>
8000aee8:	f2 08 07 0e 	ld.ub	lr,r9[r8]
8000aeec:	20 1a       	sub	r10,1
8000aeee:	f6 08 0b 0e 	st.b	r11[r8],lr
8000aef2:	20 18       	sub	r8,1
8000aef4:	58 0a       	cp.w	r10,0
8000aef6:	cf 91       	brne	8000aee8 <memmove+0x16>
8000aef8:	d8 02       	popm	pc
8000aefa:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000aefe:	20 1a       	sub	r10,1
8000af00:	f8 08 0b 09 	st.b	r12[r8],r9
8000af04:	2f f8       	sub	r8,-1
8000af06:	c0 28       	rjmp	8000af0a <memmove+0x38>
8000af08:	30 08       	mov	r8,0
8000af0a:	58 0a       	cp.w	r10,0
8000af0c:	cf 71       	brne	8000aefa <memmove+0x28>
8000af0e:	d8 02       	popm	pc

8000af10 <__hi0bits>:
8000af10:	18 98       	mov	r8,r12
8000af12:	e0 1c 00 00 	andl	r12,0x0
8000af16:	f0 09 15 10 	lsl	r9,r8,0x10
8000af1a:	58 0c       	cp.w	r12,0
8000af1c:	f2 08 17 00 	moveq	r8,r9
8000af20:	f9 bc 00 10 	moveq	r12,16
8000af24:	f9 bc 01 00 	movne	r12,0
8000af28:	10 9a       	mov	r10,r8
8000af2a:	f0 09 15 08 	lsl	r9,r8,0x8
8000af2e:	e6 1a ff 00 	andh	r10,0xff00,COH
8000af32:	f7 bc 00 f8 	subeq	r12,-8
8000af36:	f2 08 17 00 	moveq	r8,r9
8000af3a:	10 9a       	mov	r10,r8
8000af3c:	f0 09 15 04 	lsl	r9,r8,0x4
8000af40:	e6 1a f0 00 	andh	r10,0xf000,COH
8000af44:	f7 bc 00 fc 	subeq	r12,-4
8000af48:	f2 08 17 00 	moveq	r8,r9
8000af4c:	10 9a       	mov	r10,r8
8000af4e:	f0 09 15 02 	lsl	r9,r8,0x2
8000af52:	e6 1a c0 00 	andh	r10,0xc000,COH
8000af56:	f7 bc 00 fe 	subeq	r12,-2
8000af5a:	f2 08 17 00 	moveq	r8,r9
8000af5e:	58 08       	cp.w	r8,0
8000af60:	5e 5c       	retlt	r12
8000af62:	ed b8 00 1e 	bld	r8,0x1e
8000af66:	f9 bc 01 20 	movne	r12,32
8000af6a:	f7 bc 00 ff 	subeq	r12,-1
8000af6e:	5e fc       	retal	r12

8000af70 <__lo0bits>:
8000af70:	18 99       	mov	r9,r12
8000af72:	78 08       	ld.w	r8,r12[0x0]
8000af74:	f9 d8 c0 03 	bfextu	r12,r8,0x0,0x3
8000af78:	c1 50       	breq	8000afa2 <__lo0bits+0x32>
8000af7a:	ed b8 00 00 	bld	r8,0x0
8000af7e:	c0 21       	brne	8000af82 <__lo0bits+0x12>
8000af80:	5e fd       	retal	0
8000af82:	10 9b       	mov	r11,r8
8000af84:	f0 0a 16 01 	lsr	r10,r8,0x1
8000af88:	e2 1b 00 02 	andl	r11,0x2,COH
8000af8c:	a3 88       	lsr	r8,0x2
8000af8e:	58 0b       	cp.w	r11,0
8000af90:	f3 fa 1a 00 	st.wne	r9[0x0],r10
8000af94:	f9 bc 01 01 	movne	r12,1
8000af98:	f3 f8 0a 00 	st.weq	r9[0x0],r8
8000af9c:	f9 bc 00 02 	moveq	r12,2
8000afa0:	5e fc       	retal	r12
8000afa2:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8000afa6:	f0 0b 16 10 	lsr	r11,r8,0x10
8000afaa:	58 0a       	cp.w	r10,0
8000afac:	f6 08 17 00 	moveq	r8,r11
8000afb0:	f9 bc 00 10 	moveq	r12,16
8000afb4:	f7 d8 c0 08 	bfextu	r11,r8,0x0,0x8
8000afb8:	f0 0a 16 08 	lsr	r10,r8,0x8
8000afbc:	58 0b       	cp.w	r11,0
8000afbe:	f7 bc 00 f8 	subeq	r12,-8
8000afc2:	f4 08 17 00 	moveq	r8,r10
8000afc6:	f7 d8 c0 04 	bfextu	r11,r8,0x0,0x4
8000afca:	f0 0a 16 04 	lsr	r10,r8,0x4
8000afce:	58 0b       	cp.w	r11,0
8000afd0:	f7 bc 00 fc 	subeq	r12,-4
8000afd4:	f4 08 17 00 	moveq	r8,r10
8000afd8:	f7 d8 c0 02 	bfextu	r11,r8,0x0,0x2
8000afdc:	f0 0a 16 02 	lsr	r10,r8,0x2
8000afe0:	58 0b       	cp.w	r11,0
8000afe2:	f7 bc 00 fe 	subeq	r12,-2
8000afe6:	f4 08 17 00 	moveq	r8,r10
8000afea:	ed b8 00 00 	bld	r8,0x0
8000afee:	c0 60       	breq	8000affa <__lo0bits+0x8a>
8000aff0:	a1 98       	lsr	r8,0x1
8000aff2:	c0 31       	brne	8000aff8 <__lo0bits+0x88>
8000aff4:	32 0c       	mov	r12,32
8000aff6:	5e fc       	retal	r12
8000aff8:	2f fc       	sub	r12,-1
8000affa:	93 08       	st.w	r9[0x0],r8
8000affc:	5e fc       	retal	r12

8000affe <__mcmp>:
8000affe:	d4 01       	pushm	lr
8000b000:	18 98       	mov	r8,r12
8000b002:	76 49       	ld.w	r9,r11[0x10]
8000b004:	78 4c       	ld.w	r12,r12[0x10]
8000b006:	12 1c       	sub	r12,r9
8000b008:	c1 31       	brne	8000b02e <__mcmp+0x30>
8000b00a:	2f b9       	sub	r9,-5
8000b00c:	a3 69       	lsl	r9,0x2
8000b00e:	12 0b       	add	r11,r9
8000b010:	f0 09 00 09 	add	r9,r8,r9
8000b014:	2e c8       	sub	r8,-20
8000b016:	13 4e       	ld.w	lr,--r9
8000b018:	17 4a       	ld.w	r10,--r11
8000b01a:	14 3e       	cp.w	lr,r10
8000b01c:	c0 60       	breq	8000b028 <__mcmp+0x2a>
8000b01e:	f9 bc 03 ff 	movlo	r12,-1
8000b022:	f9 bc 02 01 	movhs	r12,1
8000b026:	d8 02       	popm	pc
8000b028:	10 39       	cp.w	r9,r8
8000b02a:	fe 9b ff f6 	brhi	8000b016 <__mcmp+0x18>
8000b02e:	d8 02       	popm	pc

8000b030 <_Bfree>:
8000b030:	d4 21       	pushm	r4-r7,lr
8000b032:	18 97       	mov	r7,r12
8000b034:	16 95       	mov	r5,r11
8000b036:	78 96       	ld.w	r6,r12[0x24]
8000b038:	58 06       	cp.w	r6,0
8000b03a:	c0 91       	brne	8000b04c <_Bfree+0x1c>
8000b03c:	31 0c       	mov	r12,16
8000b03e:	fe b0 de 1b 	rcall	80006c74 <malloc>
8000b042:	99 36       	st.w	r12[0xc],r6
8000b044:	8f 9c       	st.w	r7[0x24],r12
8000b046:	99 16       	st.w	r12[0x4],r6
8000b048:	99 26       	st.w	r12[0x8],r6
8000b04a:	99 06       	st.w	r12[0x0],r6
8000b04c:	58 05       	cp.w	r5,0
8000b04e:	c0 90       	breq	8000b060 <_Bfree+0x30>
8000b050:	6a 19       	ld.w	r9,r5[0x4]
8000b052:	6e 98       	ld.w	r8,r7[0x24]
8000b054:	70 38       	ld.w	r8,r8[0xc]
8000b056:	f0 09 03 2a 	ld.w	r10,r8[r9<<0x2]
8000b05a:	8b 0a       	st.w	r5[0x0],r10
8000b05c:	f0 09 09 25 	st.w	r8[r9<<0x2],r5
8000b060:	d8 22       	popm	r4-r7,pc
8000b062:	d7 03       	nop

8000b064 <_Balloc>:
8000b064:	d4 21       	pushm	r4-r7,lr
8000b066:	18 97       	mov	r7,r12
8000b068:	16 96       	mov	r6,r11
8000b06a:	78 95       	ld.w	r5,r12[0x24]
8000b06c:	58 05       	cp.w	r5,0
8000b06e:	c0 91       	brne	8000b080 <_Balloc+0x1c>
8000b070:	31 0c       	mov	r12,16
8000b072:	fe b0 de 01 	rcall	80006c74 <malloc>
8000b076:	99 35       	st.w	r12[0xc],r5
8000b078:	8f 9c       	st.w	r7[0x24],r12
8000b07a:	99 15       	st.w	r12[0x4],r5
8000b07c:	99 25       	st.w	r12[0x8],r5
8000b07e:	99 05       	st.w	r12[0x0],r5
8000b080:	6e 95       	ld.w	r5,r7[0x24]
8000b082:	6a 38       	ld.w	r8,r5[0xc]
8000b084:	58 08       	cp.w	r8,0
8000b086:	c0 b1       	brne	8000b09c <_Balloc+0x38>
8000b088:	31 0a       	mov	r10,16
8000b08a:	30 4b       	mov	r11,4
8000b08c:	0e 9c       	mov	r12,r7
8000b08e:	e0 a0 02 9d 	rcall	8000b5c8 <_calloc_r>
8000b092:	8b 3c       	st.w	r5[0xc],r12
8000b094:	6e 98       	ld.w	r8,r7[0x24]
8000b096:	70 3c       	ld.w	r12,r8[0xc]
8000b098:	58 0c       	cp.w	r12,0
8000b09a:	c1 b0       	breq	8000b0d0 <_Balloc+0x6c>
8000b09c:	6e 98       	ld.w	r8,r7[0x24]
8000b09e:	70 38       	ld.w	r8,r8[0xc]
8000b0a0:	f0 06 00 28 	add	r8,r8,r6<<0x2
8000b0a4:	70 0c       	ld.w	r12,r8[0x0]
8000b0a6:	58 0c       	cp.w	r12,0
8000b0a8:	c0 40       	breq	8000b0b0 <_Balloc+0x4c>
8000b0aa:	78 09       	ld.w	r9,r12[0x0]
8000b0ac:	91 09       	st.w	r8[0x0],r9
8000b0ae:	c0 e8       	rjmp	8000b0ca <_Balloc+0x66>
8000b0b0:	0e 9c       	mov	r12,r7
8000b0b2:	30 17       	mov	r7,1
8000b0b4:	0e 9b       	mov	r11,r7
8000b0b6:	ee 06 09 47 	lsl	r7,r7,r6
8000b0ba:	ee ca ff fb 	sub	r10,r7,-5
8000b0be:	a3 6a       	lsl	r10,0x2
8000b0c0:	e0 a0 02 84 	rcall	8000b5c8 <_calloc_r>
8000b0c4:	c0 60       	breq	8000b0d0 <_Balloc+0x6c>
8000b0c6:	99 16       	st.w	r12[0x4],r6
8000b0c8:	99 27       	st.w	r12[0x8],r7
8000b0ca:	30 08       	mov	r8,0
8000b0cc:	99 38       	st.w	r12[0xc],r8
8000b0ce:	99 48       	st.w	r12[0x10],r8
8000b0d0:	d8 22       	popm	r4-r7,pc
8000b0d2:	d7 03       	nop

8000b0d4 <__d2b>:
8000b0d4:	d4 31       	pushm	r0-r7,lr
8000b0d6:	20 2d       	sub	sp,8
8000b0d8:	16 93       	mov	r3,r11
8000b0da:	12 96       	mov	r6,r9
8000b0dc:	10 95       	mov	r5,r8
8000b0de:	14 92       	mov	r2,r10
8000b0e0:	30 1b       	mov	r11,1
8000b0e2:	cc 1f       	rcall	8000b064 <_Balloc>
8000b0e4:	f3 d3 c0 14 	bfextu	r9,r3,0x0,0x14
8000b0e8:	50 09       	stdsp	sp[0x0],r9
8000b0ea:	f1 d3 c0 1f 	bfextu	r8,r3,0x0,0x1f
8000b0ee:	b5 a9       	sbr	r9,0x14
8000b0f0:	f0 01 16 14 	lsr	r1,r8,0x14
8000b0f4:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000b0f8:	18 94       	mov	r4,r12
8000b0fa:	58 02       	cp.w	r2,0
8000b0fc:	c1 d0       	breq	8000b136 <__d2b+0x62>
8000b0fe:	fa cc ff f8 	sub	r12,sp,-8
8000b102:	18 d2       	st.w	--r12,r2
8000b104:	c3 6f       	rcall	8000af70 <__lo0bits>
8000b106:	40 18       	lddsp	r8,sp[0x4]
8000b108:	c0 d0       	breq	8000b122 <__d2b+0x4e>
8000b10a:	40 09       	lddsp	r9,sp[0x0]
8000b10c:	f8 0a 11 20 	rsub	r10,r12,32
8000b110:	f2 0a 09 4a 	lsl	r10,r9,r10
8000b114:	f5 e8 10 08 	or	r8,r10,r8
8000b118:	89 58       	st.w	r4[0x14],r8
8000b11a:	f2 0c 0a 49 	lsr	r9,r9,r12
8000b11e:	50 09       	stdsp	sp[0x0],r9
8000b120:	c0 28       	rjmp	8000b124 <__d2b+0x50>
8000b122:	89 58       	st.w	r4[0x14],r8
8000b124:	40 08       	lddsp	r8,sp[0x0]
8000b126:	58 08       	cp.w	r8,0
8000b128:	f9 b3 01 02 	movne	r3,2
8000b12c:	f9 b3 00 01 	moveq	r3,1
8000b130:	89 68       	st.w	r4[0x18],r8
8000b132:	89 43       	st.w	r4[0x10],r3
8000b134:	c0 88       	rjmp	8000b144 <__d2b+0x70>
8000b136:	1a 9c       	mov	r12,sp
8000b138:	c1 cf       	rcall	8000af70 <__lo0bits>
8000b13a:	30 13       	mov	r3,1
8000b13c:	40 08       	lddsp	r8,sp[0x0]
8000b13e:	2e 0c       	sub	r12,-32
8000b140:	89 43       	st.w	r4[0x10],r3
8000b142:	89 58       	st.w	r4[0x14],r8
8000b144:	58 01       	cp.w	r1,0
8000b146:	c0 90       	breq	8000b158 <__d2b+0x84>
8000b148:	e2 c1 04 33 	sub	r1,r1,1075
8000b14c:	18 01       	add	r1,r12
8000b14e:	8d 01       	st.w	r6[0x0],r1
8000b150:	f8 0c 11 35 	rsub	r12,r12,53
8000b154:	8b 0c       	st.w	r5[0x0],r12
8000b156:	c0 c8       	rjmp	8000b16e <__d2b+0x9a>
8000b158:	e6 c8 ff fc 	sub	r8,r3,-4
8000b15c:	f8 cc 04 32 	sub	r12,r12,1074
8000b160:	a5 73       	lsl	r3,0x5
8000b162:	8d 0c       	st.w	r6[0x0],r12
8000b164:	e8 08 03 2c 	ld.w	r12,r4[r8<<0x2]
8000b168:	cd 4e       	rcall	8000af10 <__hi0bits>
8000b16a:	18 13       	sub	r3,r12
8000b16c:	8b 03       	st.w	r5[0x0],r3
8000b16e:	08 9c       	mov	r12,r4
8000b170:	2f ed       	sub	sp,-8
8000b172:	d8 32       	popm	r0-r7,pc

8000b174 <__mdiff>:
8000b174:	d4 31       	pushm	r0-r7,lr
8000b176:	74 48       	ld.w	r8,r10[0x10]
8000b178:	76 45       	ld.w	r5,r11[0x10]
8000b17a:	16 97       	mov	r7,r11
8000b17c:	14 96       	mov	r6,r10
8000b17e:	10 15       	sub	r5,r8
8000b180:	c1 31       	brne	8000b1a6 <__mdiff+0x32>
8000b182:	2f b8       	sub	r8,-5
8000b184:	ee ce ff ec 	sub	lr,r7,-20
8000b188:	a3 68       	lsl	r8,0x2
8000b18a:	f4 08 00 0b 	add	r11,r10,r8
8000b18e:	ee 08 00 08 	add	r8,r7,r8
8000b192:	11 4a       	ld.w	r10,--r8
8000b194:	17 49       	ld.w	r9,--r11
8000b196:	12 3a       	cp.w	r10,r9
8000b198:	c0 30       	breq	8000b19e <__mdiff+0x2a>
8000b19a:	c0 e2       	brcc	8000b1b6 <__mdiff+0x42>
8000b19c:	c0 78       	rjmp	8000b1aa <__mdiff+0x36>
8000b19e:	1c 38       	cp.w	r8,lr
8000b1a0:	fe 9b ff f9 	brhi	8000b192 <__mdiff+0x1e>
8000b1a4:	c4 98       	rjmp	8000b236 <__mdiff+0xc2>
8000b1a6:	58 05       	cp.w	r5,0
8000b1a8:	c0 64       	brge	8000b1b4 <__mdiff+0x40>
8000b1aa:	0e 98       	mov	r8,r7
8000b1ac:	30 15       	mov	r5,1
8000b1ae:	0c 97       	mov	r7,r6
8000b1b0:	10 96       	mov	r6,r8
8000b1b2:	c0 28       	rjmp	8000b1b6 <__mdiff+0x42>
8000b1b4:	30 05       	mov	r5,0
8000b1b6:	6e 1b       	ld.w	r11,r7[0x4]
8000b1b8:	c5 6f       	rcall	8000b064 <_Balloc>
8000b1ba:	6e 49       	ld.w	r9,r7[0x10]
8000b1bc:	6c 44       	ld.w	r4,r6[0x10]
8000b1be:	99 35       	st.w	r12[0xc],r5
8000b1c0:	2f b4       	sub	r4,-5
8000b1c2:	f2 c5 ff fb 	sub	r5,r9,-5
8000b1c6:	ec 04 00 24 	add	r4,r6,r4<<0x2
8000b1ca:	ee 05 00 25 	add	r5,r7,r5<<0x2
8000b1ce:	2e c6       	sub	r6,-20
8000b1d0:	2e c7       	sub	r7,-20
8000b1d2:	f8 c8 ff ec 	sub	r8,r12,-20
8000b1d6:	30 0a       	mov	r10,0
8000b1d8:	0f 0e       	ld.w	lr,r7++
8000b1da:	0d 0b       	ld.w	r11,r6++
8000b1dc:	fc 02 16 10 	lsr	r2,lr,0x10
8000b1e0:	f6 03 16 10 	lsr	r3,r11,0x10
8000b1e4:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000b1e8:	e4 03 01 03 	sub	r3,r2,r3
8000b1ec:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b1f0:	fc 0b 01 0b 	sub	r11,lr,r11
8000b1f4:	f6 0a 00 0a 	add	r10,r11,r10
8000b1f8:	b0 1a       	st.h	r8[0x2],r10
8000b1fa:	b1 4a       	asr	r10,0x10
8000b1fc:	e6 0a 00 0a 	add	r10,r3,r10
8000b200:	b0 0a       	st.h	r8[0x0],r10
8000b202:	2f c8       	sub	r8,-4
8000b204:	b1 4a       	asr	r10,0x10
8000b206:	08 36       	cp.w	r6,r4
8000b208:	ce 83       	brcs	8000b1d8 <__mdiff+0x64>
8000b20a:	c0 d8       	rjmp	8000b224 <__mdiff+0xb0>
8000b20c:	0f 0b       	ld.w	r11,r7++
8000b20e:	f6 0e 16 10 	lsr	lr,r11,0x10
8000b212:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b216:	16 0a       	add	r10,r11
8000b218:	b0 1a       	st.h	r8[0x2],r10
8000b21a:	b1 4a       	asr	r10,0x10
8000b21c:	1c 0a       	add	r10,lr
8000b21e:	b0 0a       	st.h	r8[0x0],r10
8000b220:	2f c8       	sub	r8,-4
8000b222:	b1 4a       	asr	r10,0x10
8000b224:	0a 37       	cp.w	r7,r5
8000b226:	cf 33       	brcs	8000b20c <__mdiff+0x98>
8000b228:	c0 28       	rjmp	8000b22c <__mdiff+0xb8>
8000b22a:	20 19       	sub	r9,1
8000b22c:	11 4a       	ld.w	r10,--r8
8000b22e:	58 0a       	cp.w	r10,0
8000b230:	cf d0       	breq	8000b22a <__mdiff+0xb6>
8000b232:	99 49       	st.w	r12[0x10],r9
8000b234:	d8 32       	popm	r0-r7,pc
8000b236:	30 0b       	mov	r11,0
8000b238:	c1 6f       	rcall	8000b064 <_Balloc>
8000b23a:	30 18       	mov	r8,1
8000b23c:	99 48       	st.w	r12[0x10],r8
8000b23e:	30 08       	mov	r8,0
8000b240:	99 58       	st.w	r12[0x14],r8
8000b242:	d8 32       	popm	r0-r7,pc

8000b244 <__lshift>:
8000b244:	d4 31       	pushm	r0-r7,lr
8000b246:	16 97       	mov	r7,r11
8000b248:	76 46       	ld.w	r6,r11[0x10]
8000b24a:	f4 02 14 05 	asr	r2,r10,0x5
8000b24e:	2f f6       	sub	r6,-1
8000b250:	14 93       	mov	r3,r10
8000b252:	18 94       	mov	r4,r12
8000b254:	04 06       	add	r6,r2
8000b256:	76 1b       	ld.w	r11,r11[0x4]
8000b258:	6e 28       	ld.w	r8,r7[0x8]
8000b25a:	c0 38       	rjmp	8000b260 <__lshift+0x1c>
8000b25c:	2f fb       	sub	r11,-1
8000b25e:	a1 78       	lsl	r8,0x1
8000b260:	10 36       	cp.w	r6,r8
8000b262:	fe 99 ff fd 	brgt	8000b25c <__lshift+0x18>
8000b266:	08 9c       	mov	r12,r4
8000b268:	cf ee       	rcall	8000b064 <_Balloc>
8000b26a:	30 09       	mov	r9,0
8000b26c:	18 95       	mov	r5,r12
8000b26e:	f8 c8 ff ec 	sub	r8,r12,-20
8000b272:	12 9a       	mov	r10,r9
8000b274:	c0 38       	rjmp	8000b27a <__lshift+0x36>
8000b276:	10 aa       	st.w	r8++,r10
8000b278:	2f f9       	sub	r9,-1
8000b27a:	04 39       	cp.w	r9,r2
8000b27c:	cf d5       	brlt	8000b276 <__lshift+0x32>
8000b27e:	6e 4b       	ld.w	r11,r7[0x10]
8000b280:	e7 d3 c0 05 	bfextu	r3,r3,0x0,0x5
8000b284:	2f bb       	sub	r11,-5
8000b286:	ee c9 ff ec 	sub	r9,r7,-20
8000b28a:	ee 0b 00 2b 	add	r11,r7,r11<<0x2
8000b28e:	58 03       	cp.w	r3,0
8000b290:	c1 30       	breq	8000b2b6 <__lshift+0x72>
8000b292:	e6 0c 11 20 	rsub	r12,r3,32
8000b296:	30 0a       	mov	r10,0
8000b298:	72 02       	ld.w	r2,r9[0x0]
8000b29a:	e4 03 09 42 	lsl	r2,r2,r3
8000b29e:	04 4a       	or	r10,r2
8000b2a0:	10 aa       	st.w	r8++,r10
8000b2a2:	13 0a       	ld.w	r10,r9++
8000b2a4:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000b2a8:	16 39       	cp.w	r9,r11
8000b2aa:	cf 73       	brcs	8000b298 <__lshift+0x54>
8000b2ac:	91 0a       	st.w	r8[0x0],r10
8000b2ae:	58 0a       	cp.w	r10,0
8000b2b0:	c0 70       	breq	8000b2be <__lshift+0x7a>
8000b2b2:	2f f6       	sub	r6,-1
8000b2b4:	c0 58       	rjmp	8000b2be <__lshift+0x7a>
8000b2b6:	13 0a       	ld.w	r10,r9++
8000b2b8:	10 aa       	st.w	r8++,r10
8000b2ba:	16 39       	cp.w	r9,r11
8000b2bc:	cf d3       	brcs	8000b2b6 <__lshift+0x72>
8000b2be:	08 9c       	mov	r12,r4
8000b2c0:	20 16       	sub	r6,1
8000b2c2:	0e 9b       	mov	r11,r7
8000b2c4:	8b 46       	st.w	r5[0x10],r6
8000b2c6:	cb 5e       	rcall	8000b030 <_Bfree>
8000b2c8:	0a 9c       	mov	r12,r5
8000b2ca:	d8 32       	popm	r0-r7,pc

8000b2cc <__multiply>:
8000b2cc:	d4 31       	pushm	r0-r7,lr
8000b2ce:	20 2d       	sub	sp,8
8000b2d0:	76 49       	ld.w	r9,r11[0x10]
8000b2d2:	74 48       	ld.w	r8,r10[0x10]
8000b2d4:	16 96       	mov	r6,r11
8000b2d6:	14 95       	mov	r5,r10
8000b2d8:	10 39       	cp.w	r9,r8
8000b2da:	ec 08 17 50 	movlt	r8,r6
8000b2de:	ea 06 17 50 	movlt	r6,r5
8000b2e2:	f0 05 17 50 	movlt	r5,r8
8000b2e6:	6c 28       	ld.w	r8,r6[0x8]
8000b2e8:	76 43       	ld.w	r3,r11[0x10]
8000b2ea:	74 42       	ld.w	r2,r10[0x10]
8000b2ec:	76 1b       	ld.w	r11,r11[0x4]
8000b2ee:	e4 03 00 07 	add	r7,r2,r3
8000b2f2:	10 37       	cp.w	r7,r8
8000b2f4:	f7 bb 09 ff 	subgt	r11,-1
8000b2f8:	cb 6e       	rcall	8000b064 <_Balloc>
8000b2fa:	ee c4 ff fb 	sub	r4,r7,-5
8000b2fe:	f8 c9 ff ec 	sub	r9,r12,-20
8000b302:	f8 04 00 24 	add	r4,r12,r4<<0x2
8000b306:	30 0a       	mov	r10,0
8000b308:	12 98       	mov	r8,r9
8000b30a:	c0 28       	rjmp	8000b30e <__multiply+0x42>
8000b30c:	10 aa       	st.w	r8++,r10
8000b30e:	08 38       	cp.w	r8,r4
8000b310:	cf e3       	brcs	8000b30c <__multiply+0x40>
8000b312:	2f b3       	sub	r3,-5
8000b314:	2f b2       	sub	r2,-5
8000b316:	ec 03 00 23 	add	r3,r6,r3<<0x2
8000b31a:	ea 02 00 22 	add	r2,r5,r2<<0x2
8000b31e:	ec cb ff ec 	sub	r11,r6,-20
8000b322:	50 12       	stdsp	sp[0x4],r2
8000b324:	ea ca ff ec 	sub	r10,r5,-20
8000b328:	c4 48       	rjmp	8000b3b0 <__multiply+0xe4>
8000b32a:	94 95       	ld.uh	r5,r10[0x2]
8000b32c:	58 05       	cp.w	r5,0
8000b32e:	c2 00       	breq	8000b36e <__multiply+0xa2>
8000b330:	12 98       	mov	r8,r9
8000b332:	16 96       	mov	r6,r11
8000b334:	30 0e       	mov	lr,0
8000b336:	50 09       	stdsp	sp[0x0],r9
8000b338:	0d 02       	ld.w	r2,r6++
8000b33a:	e4 00 16 10 	lsr	r0,r2,0x10
8000b33e:	70 01       	ld.w	r1,r8[0x0]
8000b340:	70 09       	ld.w	r9,r8[0x0]
8000b342:	b1 81       	lsr	r1,0x10
8000b344:	e5 d2 c0 10 	bfextu	r2,r2,0x0,0x10
8000b348:	e0 05 03 41 	mac	r1,r0,r5
8000b34c:	ab 32       	mul	r2,r5
8000b34e:	e1 d9 c0 10 	bfextu	r0,r9,0x0,0x10
8000b352:	00 02       	add	r2,r0
8000b354:	e4 0e 00 0e 	add	lr,r2,lr
8000b358:	b0 1e       	st.h	r8[0x2],lr
8000b35a:	b1 8e       	lsr	lr,0x10
8000b35c:	1c 01       	add	r1,lr
8000b35e:	b0 01       	st.h	r8[0x0],r1
8000b360:	e2 0e 16 10 	lsr	lr,r1,0x10
8000b364:	2f c8       	sub	r8,-4
8000b366:	06 36       	cp.w	r6,r3
8000b368:	ce 83       	brcs	8000b338 <__multiply+0x6c>
8000b36a:	40 09       	lddsp	r9,sp[0x0]
8000b36c:	91 0e       	st.w	r8[0x0],lr
8000b36e:	94 86       	ld.uh	r6,r10[0x0]
8000b370:	58 06       	cp.w	r6,0
8000b372:	c1 d0       	breq	8000b3ac <__multiply+0xe0>
8000b374:	72 02       	ld.w	r2,r9[0x0]
8000b376:	12 98       	mov	r8,r9
8000b378:	16 9e       	mov	lr,r11
8000b37a:	30 05       	mov	r5,0
8000b37c:	b0 12       	st.h	r8[0x2],r2
8000b37e:	1d 01       	ld.w	r1,lr++
8000b380:	90 82       	ld.uh	r2,r8[0x0]
8000b382:	e1 d1 c0 10 	bfextu	r0,r1,0x0,0x10
8000b386:	ad 30       	mul	r0,r6
8000b388:	e0 02 00 02 	add	r2,r0,r2
8000b38c:	e4 05 00 05 	add	r5,r2,r5
8000b390:	b0 05       	st.h	r8[0x0],r5
8000b392:	b1 85       	lsr	r5,0x10
8000b394:	b1 81       	lsr	r1,0x10
8000b396:	2f c8       	sub	r8,-4
8000b398:	ad 31       	mul	r1,r6
8000b39a:	90 92       	ld.uh	r2,r8[0x2]
8000b39c:	e2 02 00 02 	add	r2,r1,r2
8000b3a0:	0a 02       	add	r2,r5
8000b3a2:	e4 05 16 10 	lsr	r5,r2,0x10
8000b3a6:	06 3e       	cp.w	lr,r3
8000b3a8:	ce a3       	brcs	8000b37c <__multiply+0xb0>
8000b3aa:	91 02       	st.w	r8[0x0],r2
8000b3ac:	2f ca       	sub	r10,-4
8000b3ae:	2f c9       	sub	r9,-4
8000b3b0:	40 18       	lddsp	r8,sp[0x4]
8000b3b2:	10 3a       	cp.w	r10,r8
8000b3b4:	cb b3       	brcs	8000b32a <__multiply+0x5e>
8000b3b6:	c0 28       	rjmp	8000b3ba <__multiply+0xee>
8000b3b8:	20 17       	sub	r7,1
8000b3ba:	58 07       	cp.w	r7,0
8000b3bc:	e0 8a 00 05 	brle	8000b3c6 <__multiply+0xfa>
8000b3c0:	09 48       	ld.w	r8,--r4
8000b3c2:	58 08       	cp.w	r8,0
8000b3c4:	cf a0       	breq	8000b3b8 <__multiply+0xec>
8000b3c6:	99 47       	st.w	r12[0x10],r7
8000b3c8:	2f ed       	sub	sp,-8
8000b3ca:	d8 32       	popm	r0-r7,pc

8000b3cc <__i2b>:
8000b3cc:	d4 21       	pushm	r4-r7,lr
8000b3ce:	16 97       	mov	r7,r11
8000b3d0:	30 1b       	mov	r11,1
8000b3d2:	c4 9e       	rcall	8000b064 <_Balloc>
8000b3d4:	30 19       	mov	r9,1
8000b3d6:	99 57       	st.w	r12[0x14],r7
8000b3d8:	99 49       	st.w	r12[0x10],r9
8000b3da:	d8 22       	popm	r4-r7,pc

8000b3dc <__multadd>:
8000b3dc:	d4 31       	pushm	r0-r7,lr
8000b3de:	30 08       	mov	r8,0
8000b3e0:	12 95       	mov	r5,r9
8000b3e2:	16 97       	mov	r7,r11
8000b3e4:	18 96       	mov	r6,r12
8000b3e6:	76 44       	ld.w	r4,r11[0x10]
8000b3e8:	f6 c9 ff ec 	sub	r9,r11,-20
8000b3ec:	72 0b       	ld.w	r11,r9[0x0]
8000b3ee:	f6 0c 16 10 	lsr	r12,r11,0x10
8000b3f2:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b3f6:	f4 0c 02 4c 	mul	r12,r10,r12
8000b3fa:	f4 0b 03 45 	mac	r5,r10,r11
8000b3fe:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
8000b402:	b1 85       	lsr	r5,0x10
8000b404:	18 05       	add	r5,r12
8000b406:	ea 0c 15 10 	lsl	r12,r5,0x10
8000b40a:	f8 0b 00 0b 	add	r11,r12,r11
8000b40e:	12 ab       	st.w	r9++,r11
8000b410:	2f f8       	sub	r8,-1
8000b412:	b1 85       	lsr	r5,0x10
8000b414:	08 38       	cp.w	r8,r4
8000b416:	ce b5       	brlt	8000b3ec <__multadd+0x10>
8000b418:	58 05       	cp.w	r5,0
8000b41a:	c1 c0       	breq	8000b452 <__multadd+0x76>
8000b41c:	6e 28       	ld.w	r8,r7[0x8]
8000b41e:	10 34       	cp.w	r4,r8
8000b420:	c1 35       	brlt	8000b446 <__multadd+0x6a>
8000b422:	6e 1b       	ld.w	r11,r7[0x4]
8000b424:	0c 9c       	mov	r12,r6
8000b426:	2f fb       	sub	r11,-1
8000b428:	c1 ee       	rcall	8000b064 <_Balloc>
8000b42a:	6e 4a       	ld.w	r10,r7[0x10]
8000b42c:	ee cb ff f4 	sub	r11,r7,-12
8000b430:	18 93       	mov	r3,r12
8000b432:	2f ea       	sub	r10,-2
8000b434:	2f 4c       	sub	r12,-12
8000b436:	a3 6a       	lsl	r10,0x2
8000b438:	fe b0 de 42 	rcall	800070bc <memcpy>
8000b43c:	0e 9b       	mov	r11,r7
8000b43e:	0c 9c       	mov	r12,r6
8000b440:	fe b0 fd f8 	rcall	8000b030 <_Bfree>
8000b444:	06 97       	mov	r7,r3
8000b446:	e8 c8 ff ff 	sub	r8,r4,-1
8000b44a:	2f b4       	sub	r4,-5
8000b44c:	8f 48       	st.w	r7[0x10],r8
8000b44e:	ee 04 09 25 	st.w	r7[r4<<0x2],r5
8000b452:	0e 9c       	mov	r12,r7
8000b454:	d8 32       	popm	r0-r7,pc
8000b456:	d7 03       	nop

8000b458 <__pow5mult>:
8000b458:	d4 31       	pushm	r0-r7,lr
8000b45a:	14 96       	mov	r6,r10
8000b45c:	18 97       	mov	r7,r12
8000b45e:	16 94       	mov	r4,r11
8000b460:	f1 da c0 02 	bfextu	r8,r10,0x0,0x2
8000b464:	c0 80       	breq	8000b474 <__pow5mult+0x1c>
8000b466:	20 18       	sub	r8,1
8000b468:	49 f9       	lddpc	r9,8000b4e4 <__pow5mult+0x8c>
8000b46a:	f2 08 03 2a 	ld.w	r10,r9[r8<<0x2]
8000b46e:	30 09       	mov	r9,0
8000b470:	cb 6f       	rcall	8000b3dc <__multadd>
8000b472:	18 94       	mov	r4,r12
8000b474:	a3 46       	asr	r6,0x2
8000b476:	c3 40       	breq	8000b4de <__pow5mult+0x86>
8000b478:	6e 95       	ld.w	r5,r7[0x24]
8000b47a:	58 05       	cp.w	r5,0
8000b47c:	c0 91       	brne	8000b48e <__pow5mult+0x36>
8000b47e:	31 0c       	mov	r12,16
8000b480:	fe b0 db fa 	rcall	80006c74 <malloc>
8000b484:	99 35       	st.w	r12[0xc],r5
8000b486:	8f 9c       	st.w	r7[0x24],r12
8000b488:	99 15       	st.w	r12[0x4],r5
8000b48a:	99 25       	st.w	r12[0x8],r5
8000b48c:	99 05       	st.w	r12[0x0],r5
8000b48e:	6e 93       	ld.w	r3,r7[0x24]
8000b490:	66 25       	ld.w	r5,r3[0x8]
8000b492:	58 05       	cp.w	r5,0
8000b494:	c0 c1       	brne	8000b4ac <__pow5mult+0x54>
8000b496:	e0 6b 02 71 	mov	r11,625
8000b49a:	0e 9c       	mov	r12,r7
8000b49c:	c9 8f       	rcall	8000b3cc <__i2b>
8000b49e:	87 2c       	st.w	r3[0x8],r12
8000b4a0:	30 08       	mov	r8,0
8000b4a2:	18 95       	mov	r5,r12
8000b4a4:	99 08       	st.w	r12[0x0],r8
8000b4a6:	c0 38       	rjmp	8000b4ac <__pow5mult+0x54>
8000b4a8:	06 9c       	mov	r12,r3
8000b4aa:	18 95       	mov	r5,r12
8000b4ac:	ed b6 00 00 	bld	r6,0x0
8000b4b0:	c0 b1       	brne	8000b4c6 <__pow5mult+0x6e>
8000b4b2:	08 9b       	mov	r11,r4
8000b4b4:	0a 9a       	mov	r10,r5
8000b4b6:	0e 9c       	mov	r12,r7
8000b4b8:	c0 af       	rcall	8000b2cc <__multiply>
8000b4ba:	08 9b       	mov	r11,r4
8000b4bc:	18 93       	mov	r3,r12
8000b4be:	0e 9c       	mov	r12,r7
8000b4c0:	06 94       	mov	r4,r3
8000b4c2:	fe b0 fd b7 	rcall	8000b030 <_Bfree>
8000b4c6:	a1 56       	asr	r6,0x1
8000b4c8:	c0 b0       	breq	8000b4de <__pow5mult+0x86>
8000b4ca:	6a 03       	ld.w	r3,r5[0x0]
8000b4cc:	58 03       	cp.w	r3,0
8000b4ce:	ce d1       	brne	8000b4a8 <__pow5mult+0x50>
8000b4d0:	0a 9a       	mov	r10,r5
8000b4d2:	0a 9b       	mov	r11,r5
8000b4d4:	0e 9c       	mov	r12,r7
8000b4d6:	cf be       	rcall	8000b2cc <__multiply>
8000b4d8:	8b 0c       	st.w	r5[0x0],r12
8000b4da:	99 03       	st.w	r12[0x0],r3
8000b4dc:	ce 7b       	rjmp	8000b4aa <__pow5mult+0x52>
8000b4de:	08 9c       	mov	r12,r4
8000b4e0:	d8 32       	popm	r0-r7,pc
8000b4e2:	d7 03       	nop
8000b4e4:	80 01       	ld.sh	r1,r0[0x0]
8000b4e6:	62 84       	ld.w	r4,r1[0x20]

8000b4e8 <__isinfd>:
8000b4e8:	14 98       	mov	r8,r10
8000b4ea:	fc 19 7f f0 	movh	r9,0x7ff0
8000b4ee:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000b4f2:	f0 0b 11 00 	rsub	r11,r8,0
8000b4f6:	f7 e8 10 08 	or	r8,r11,r8
8000b4fa:	f5 e8 13 f8 	or	r8,r10,r8>>0x1f
8000b4fe:	f2 08 01 08 	sub	r8,r9,r8
8000b502:	f0 0c 11 00 	rsub	r12,r8,0
8000b506:	f9 e8 10 08 	or	r8,r12,r8
8000b50a:	f0 0c 14 1f 	asr	r12,r8,0x1f
8000b50e:	2f fc       	sub	r12,-1
8000b510:	5e fc       	retal	r12

8000b512 <__isnand>:
8000b512:	14 98       	mov	r8,r10
8000b514:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000b518:	f0 0c 11 00 	rsub	r12,r8,0
8000b51c:	10 4c       	or	r12,r8
8000b51e:	fc 18 7f f0 	movh	r8,0x7ff0
8000b522:	f5 ec 13 fc 	or	r12,r10,r12>>0x1f
8000b526:	f0 0c 01 0c 	sub	r12,r8,r12
8000b52a:	bf 9c       	lsr	r12,0x1f
8000b52c:	5e fc       	retal	r12
8000b52e:	d7 03       	nop

8000b530 <__sclose>:
8000b530:	d4 01       	pushm	lr
8000b532:	96 7b       	ld.sh	r11,r11[0xe]
8000b534:	c7 6c       	rcall	8000b620 <_close_r>
8000b536:	d8 02       	popm	pc

8000b538 <__sseek>:
8000b538:	d4 21       	pushm	r4-r7,lr
8000b53a:	16 97       	mov	r7,r11
8000b53c:	96 7b       	ld.sh	r11,r11[0xe]
8000b53e:	cf 9c       	rcall	8000b730 <_lseek_r>
8000b540:	8e 68       	ld.sh	r8,r7[0xc]
8000b542:	10 99       	mov	r9,r8
8000b544:	ad c8       	cbr	r8,0xc
8000b546:	ad a9       	sbr	r9,0xc
8000b548:	5b fc       	cp.w	r12,-1
8000b54a:	ef f8 0c 06 	st.heq	r7[0xc],r8
8000b54e:	ef f9 1c 06 	st.hne	r7[0xc],r9
8000b552:	ef fc 1a 15 	st.wne	r7[0x54],r12
8000b556:	d8 22       	popm	r4-r7,pc

8000b558 <__swrite>:
8000b558:	d4 21       	pushm	r4-r7,lr
8000b55a:	96 68       	ld.sh	r8,r11[0xc]
8000b55c:	16 97       	mov	r7,r11
8000b55e:	14 95       	mov	r5,r10
8000b560:	12 94       	mov	r4,r9
8000b562:	e2 18 01 00 	andl	r8,0x100,COH
8000b566:	18 96       	mov	r6,r12
8000b568:	c0 50       	breq	8000b572 <__swrite+0x1a>
8000b56a:	30 29       	mov	r9,2
8000b56c:	30 0a       	mov	r10,0
8000b56e:	96 7b       	ld.sh	r11,r11[0xe]
8000b570:	ce 0c       	rcall	8000b730 <_lseek_r>
8000b572:	8e 68       	ld.sh	r8,r7[0xc]
8000b574:	ad c8       	cbr	r8,0xc
8000b576:	08 99       	mov	r9,r4
8000b578:	0a 9a       	mov	r10,r5
8000b57a:	8e 7b       	ld.sh	r11,r7[0xe]
8000b57c:	0c 9c       	mov	r12,r6
8000b57e:	ae 68       	st.h	r7[0xc],r8
8000b580:	c1 0c       	rcall	8000b5a0 <_write_r>
8000b582:	d8 22       	popm	r4-r7,pc

8000b584 <__sread>:
8000b584:	d4 21       	pushm	r4-r7,lr
8000b586:	16 97       	mov	r7,r11
8000b588:	96 7b       	ld.sh	r11,r11[0xe]
8000b58a:	ce 7c       	rcall	8000b758 <_read_r>
8000b58c:	c0 65       	brlt	8000b598 <__sread+0x14>
8000b58e:	6f 58       	ld.w	r8,r7[0x54]
8000b590:	18 08       	add	r8,r12
8000b592:	ef 48 00 54 	st.w	r7[84],r8
8000b596:	d8 22       	popm	r4-r7,pc
8000b598:	8e 68       	ld.sh	r8,r7[0xc]
8000b59a:	ad c8       	cbr	r8,0xc
8000b59c:	ae 68       	st.h	r7[0xc],r8
8000b59e:	d8 22       	popm	r4-r7,pc

8000b5a0 <_write_r>:
8000b5a0:	d4 21       	pushm	r4-r7,lr
8000b5a2:	16 98       	mov	r8,r11
8000b5a4:	18 97       	mov	r7,r12
8000b5a6:	10 9c       	mov	r12,r8
8000b5a8:	30 08       	mov	r8,0
8000b5aa:	14 9b       	mov	r11,r10
8000b5ac:	e0 66 41 20 	mov	r6,16672
8000b5b0:	12 9a       	mov	r10,r9
8000b5b2:	8d 08       	st.w	r6[0x0],r8
8000b5b4:	fe b0 d1 00 	rcall	800057b4 <_write>
8000b5b8:	5b fc       	cp.w	r12,-1
8000b5ba:	c0 51       	brne	8000b5c4 <_write_r+0x24>
8000b5bc:	6c 08       	ld.w	r8,r6[0x0]
8000b5be:	58 08       	cp.w	r8,0
8000b5c0:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b5c4:	d8 22       	popm	r4-r7,pc
8000b5c6:	d7 03       	nop

8000b5c8 <_calloc_r>:
8000b5c8:	d4 21       	pushm	r4-r7,lr
8000b5ca:	f4 0b 02 4b 	mul	r11,r10,r11
8000b5ce:	fe b0 db 5b 	rcall	80006c84 <_malloc_r>
8000b5d2:	18 97       	mov	r7,r12
8000b5d4:	c2 30       	breq	8000b61a <_calloc_r+0x52>
8000b5d6:	f8 fa ff fc 	ld.w	r10,r12[-4]
8000b5da:	e0 1a ff fc 	andl	r10,0xfffc
8000b5de:	20 4a       	sub	r10,4
8000b5e0:	e0 4a 00 24 	cp.w	r10,36
8000b5e4:	e0 8b 00 18 	brhi	8000b614 <_calloc_r+0x4c>
8000b5e8:	18 98       	mov	r8,r12
8000b5ea:	59 3a       	cp.w	r10,19
8000b5ec:	e0 88 00 0f 	brls	8000b60a <_calloc_r+0x42>
8000b5f0:	30 09       	mov	r9,0
8000b5f2:	10 a9       	st.w	r8++,r9
8000b5f4:	10 a9       	st.w	r8++,r9
8000b5f6:	59 ba       	cp.w	r10,27
8000b5f8:	e0 88 00 09 	brls	8000b60a <_calloc_r+0x42>
8000b5fc:	10 a9       	st.w	r8++,r9
8000b5fe:	10 a9       	st.w	r8++,r9
8000b600:	e0 4a 00 24 	cp.w	r10,36
8000b604:	c0 31       	brne	8000b60a <_calloc_r+0x42>
8000b606:	10 a9       	st.w	r8++,r9
8000b608:	10 a9       	st.w	r8++,r9
8000b60a:	30 09       	mov	r9,0
8000b60c:	10 a9       	st.w	r8++,r9
8000b60e:	91 19       	st.w	r8[0x4],r9
8000b610:	91 09       	st.w	r8[0x0],r9
8000b612:	c0 48       	rjmp	8000b61a <_calloc_r+0x52>
8000b614:	30 0b       	mov	r11,0
8000b616:	fe b0 dd f7 	rcall	80007204 <memset>
8000b61a:	0e 9c       	mov	r12,r7
8000b61c:	d8 22       	popm	r4-r7,pc
8000b61e:	d7 03       	nop

8000b620 <_close_r>:
8000b620:	d4 21       	pushm	r4-r7,lr
8000b622:	30 08       	mov	r8,0
8000b624:	18 97       	mov	r7,r12
8000b626:	e0 66 41 20 	mov	r6,16672
8000b62a:	16 9c       	mov	r12,r11
8000b62c:	8d 08       	st.w	r6[0x0],r8
8000b62e:	fe b0 df a5 	rcall	80007578 <_close>
8000b632:	5b fc       	cp.w	r12,-1
8000b634:	c0 51       	brne	8000b63e <_close_r+0x1e>
8000b636:	6c 08       	ld.w	r8,r6[0x0]
8000b638:	58 08       	cp.w	r8,0
8000b63a:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b63e:	d8 22       	popm	r4-r7,pc

8000b640 <_fclose_r>:
8000b640:	d4 21       	pushm	r4-r7,lr
8000b642:	18 96       	mov	r6,r12
8000b644:	16 97       	mov	r7,r11
8000b646:	58 0b       	cp.w	r11,0
8000b648:	c0 31       	brne	8000b64e <_fclose_r+0xe>
8000b64a:	16 95       	mov	r5,r11
8000b64c:	c5 08       	rjmp	8000b6ec <_fclose_r+0xac>
8000b64e:	fe b0 f8 b1 	rcall	8000a7b0 <__sfp_lock_acquire>
8000b652:	58 06       	cp.w	r6,0
8000b654:	c0 70       	breq	8000b662 <_fclose_r+0x22>
8000b656:	6c 68       	ld.w	r8,r6[0x18]
8000b658:	58 08       	cp.w	r8,0
8000b65a:	c0 41       	brne	8000b662 <_fclose_r+0x22>
8000b65c:	0c 9c       	mov	r12,r6
8000b65e:	fe b0 f8 fd 	rcall	8000a858 <__sinit>
8000b662:	4a 48       	lddpc	r8,8000b6f0 <_fclose_r+0xb0>
8000b664:	10 37       	cp.w	r7,r8
8000b666:	c0 31       	brne	8000b66c <_fclose_r+0x2c>
8000b668:	6c 07       	ld.w	r7,r6[0x0]
8000b66a:	c0 a8       	rjmp	8000b67e <_fclose_r+0x3e>
8000b66c:	4a 28       	lddpc	r8,8000b6f4 <_fclose_r+0xb4>
8000b66e:	10 37       	cp.w	r7,r8
8000b670:	c0 31       	brne	8000b676 <_fclose_r+0x36>
8000b672:	6c 17       	ld.w	r7,r6[0x4]
8000b674:	c0 58       	rjmp	8000b67e <_fclose_r+0x3e>
8000b676:	4a 18       	lddpc	r8,8000b6f8 <_fclose_r+0xb8>
8000b678:	10 37       	cp.w	r7,r8
8000b67a:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000b67e:	8e 69       	ld.sh	r9,r7[0xc]
8000b680:	30 08       	mov	r8,0
8000b682:	f0 09 19 00 	cp.h	r9,r8
8000b686:	c0 51       	brne	8000b690 <_fclose_r+0x50>
8000b688:	fe b0 f8 95 	rcall	8000a7b2 <__sfp_lock_release>
8000b68c:	30 05       	mov	r5,0
8000b68e:	c2 f8       	rjmp	8000b6ec <_fclose_r+0xac>
8000b690:	0e 9b       	mov	r11,r7
8000b692:	0c 9c       	mov	r12,r6
8000b694:	fe b0 f8 06 	rcall	8000a6a0 <_fflush_r>
8000b698:	6e c8       	ld.w	r8,r7[0x30]
8000b69a:	18 95       	mov	r5,r12
8000b69c:	58 08       	cp.w	r8,0
8000b69e:	c0 60       	breq	8000b6aa <_fclose_r+0x6a>
8000b6a0:	6e 8b       	ld.w	r11,r7[0x20]
8000b6a2:	0c 9c       	mov	r12,r6
8000b6a4:	5d 18       	icall	r8
8000b6a6:	f9 b5 05 ff 	movlt	r5,-1
8000b6aa:	8e 68       	ld.sh	r8,r7[0xc]
8000b6ac:	ed b8 00 07 	bld	r8,0x7
8000b6b0:	c0 51       	brne	8000b6ba <_fclose_r+0x7a>
8000b6b2:	6e 4b       	ld.w	r11,r7[0x10]
8000b6b4:	0c 9c       	mov	r12,r6
8000b6b6:	fe b0 f9 6b 	rcall	8000a98c <_free_r>
8000b6ba:	6e db       	ld.w	r11,r7[0x34]
8000b6bc:	58 0b       	cp.w	r11,0
8000b6be:	c0 a0       	breq	8000b6d2 <_fclose_r+0x92>
8000b6c0:	ee c8 ff bc 	sub	r8,r7,-68
8000b6c4:	10 3b       	cp.w	r11,r8
8000b6c6:	c0 40       	breq	8000b6ce <_fclose_r+0x8e>
8000b6c8:	0c 9c       	mov	r12,r6
8000b6ca:	fe b0 f9 61 	rcall	8000a98c <_free_r>
8000b6ce:	30 08       	mov	r8,0
8000b6d0:	8f d8       	st.w	r7[0x34],r8
8000b6d2:	6f 2b       	ld.w	r11,r7[0x48]
8000b6d4:	58 0b       	cp.w	r11,0
8000b6d6:	c0 70       	breq	8000b6e4 <_fclose_r+0xa4>
8000b6d8:	0c 9c       	mov	r12,r6
8000b6da:	fe b0 f9 59 	rcall	8000a98c <_free_r>
8000b6de:	30 08       	mov	r8,0
8000b6e0:	ef 48 00 48 	st.w	r7[72],r8
8000b6e4:	30 08       	mov	r8,0
8000b6e6:	ae 68       	st.h	r7[0xc],r8
8000b6e8:	fe b0 f8 65 	rcall	8000a7b2 <__sfp_lock_release>
8000b6ec:	0a 9c       	mov	r12,r5
8000b6ee:	d8 22       	popm	r4-r7,pc
8000b6f0:	80 01       	ld.sh	r1,r0[0x0]
8000b6f2:	61 e0       	ld.w	r0,r0[0x78]
8000b6f4:	80 01       	ld.sh	r1,r0[0x0]
8000b6f6:	62 00       	ld.w	r0,r1[0x0]
8000b6f8:	80 01       	ld.sh	r1,r0[0x0]
8000b6fa:	62 20       	ld.w	r0,r1[0x8]

8000b6fc <fclose>:
8000b6fc:	d4 01       	pushm	lr
8000b6fe:	e0 68 0a 30 	mov	r8,2608
8000b702:	18 9b       	mov	r11,r12
8000b704:	70 0c       	ld.w	r12,r8[0x0]
8000b706:	c9 df       	rcall	8000b640 <_fclose_r>
8000b708:	d8 02       	popm	pc
8000b70a:	d7 03       	nop

8000b70c <_fstat_r>:
8000b70c:	d4 21       	pushm	r4-r7,lr
8000b70e:	16 98       	mov	r8,r11
8000b710:	18 97       	mov	r7,r12
8000b712:	10 9c       	mov	r12,r8
8000b714:	30 08       	mov	r8,0
8000b716:	e0 66 41 20 	mov	r6,16672
8000b71a:	14 9b       	mov	r11,r10
8000b71c:	8d 08       	st.w	r6[0x0],r8
8000b71e:	fe b0 df 55 	rcall	800075c8 <_fstat>
8000b722:	5b fc       	cp.w	r12,-1
8000b724:	c0 51       	brne	8000b72e <_fstat_r+0x22>
8000b726:	6c 08       	ld.w	r8,r6[0x0]
8000b728:	58 08       	cp.w	r8,0
8000b72a:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b72e:	d8 22       	popm	r4-r7,pc

8000b730 <_lseek_r>:
8000b730:	d4 21       	pushm	r4-r7,lr
8000b732:	16 98       	mov	r8,r11
8000b734:	18 97       	mov	r7,r12
8000b736:	10 9c       	mov	r12,r8
8000b738:	30 08       	mov	r8,0
8000b73a:	14 9b       	mov	r11,r10
8000b73c:	e0 66 41 20 	mov	r6,16672
8000b740:	12 9a       	mov	r10,r9
8000b742:	8d 08       	st.w	r6[0x0],r8
8000b744:	fe b0 df 24 	rcall	8000758c <_lseek>
8000b748:	5b fc       	cp.w	r12,-1
8000b74a:	c0 51       	brne	8000b754 <_lseek_r+0x24>
8000b74c:	6c 08       	ld.w	r8,r6[0x0]
8000b74e:	58 08       	cp.w	r8,0
8000b750:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b754:	d8 22       	popm	r4-r7,pc
8000b756:	d7 03       	nop

8000b758 <_read_r>:
8000b758:	d4 21       	pushm	r4-r7,lr
8000b75a:	16 98       	mov	r8,r11
8000b75c:	18 97       	mov	r7,r12
8000b75e:	10 9c       	mov	r12,r8
8000b760:	30 08       	mov	r8,0
8000b762:	14 9b       	mov	r11,r10
8000b764:	e0 66 41 20 	mov	r6,16672
8000b768:	12 9a       	mov	r10,r9
8000b76a:	8d 08       	st.w	r6[0x0],r8
8000b76c:	fe b0 d0 04 	rcall	80005774 <_read>
8000b770:	5b fc       	cp.w	r12,-1
8000b772:	c0 51       	brne	8000b77c <_read_r+0x24>
8000b774:	6c 08       	ld.w	r8,r6[0x0]
8000b776:	58 08       	cp.w	r8,0
8000b778:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b77c:	d8 22       	popm	r4-r7,pc
8000b77e:	d7 03       	nop

8000b780 <__avr32_f64_mul>:
8000b780:	f5 eb 10 1c 	or	r12,r10,r11<<0x1
8000b784:	e0 80 00 dc 	breq	8000b93c <__avr32_f64_mul_op1_zero>
8000b788:	d4 21       	pushm	r4-r7,lr
8000b78a:	f7 e9 20 0e 	eor	lr,r11,r9
8000b78e:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000b792:	30 15       	mov	r5,1
8000b794:	c4 30       	breq	8000b81a <__avr32_f64_mul_op1_subnormal>
8000b796:	ab 6b       	lsl	r11,0xa
8000b798:	f7 ea 13 6b 	or	r11,r11,r10>>0x16
8000b79c:	ab 6a       	lsl	r10,0xa
8000b79e:	f7 d5 d3 c2 	bfins	r11,r5,0x1e,0x2
8000b7a2:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000b7a6:	c5 c0       	breq	8000b85e <__avr32_f64_mul_op2_subnormal>
8000b7a8:	a1 78       	lsl	r8,0x1
8000b7aa:	5c f9       	rol	r9
8000b7ac:	f3 d5 d2 ab 	bfins	r9,r5,0x15,0xb
8000b7b0:	e0 47 07 ff 	cp.w	r7,2047
8000b7b4:	c7 70       	breq	8000b8a2 <__avr32_f64_mul_op_nan_or_inf>
8000b7b6:	e0 46 07 ff 	cp.w	r6,2047
8000b7ba:	c7 40       	breq	8000b8a2 <__avr32_f64_mul_op_nan_or_inf>
8000b7bc:	ee 06 00 0c 	add	r12,r7,r6
8000b7c0:	e0 2c 03 fe 	sub	r12,1022
8000b7c4:	f6 08 06 44 	mulu.d	r4,r11,r8
8000b7c8:	f4 09 07 44 	macu.d	r4,r10,r9
8000b7cc:	f4 08 06 46 	mulu.d	r6,r10,r8
8000b7d0:	f6 09 06 4a 	mulu.d	r10,r11,r9
8000b7d4:	08 07       	add	r7,r4
8000b7d6:	f4 05 00 4a 	adc	r10,r10,r5
8000b7da:	5c 0b       	acr	r11
8000b7dc:	ed bb 00 14 	bld	r11,0x14
8000b7e0:	c0 50       	breq	8000b7ea <__avr32_f64_mul+0x6a>
8000b7e2:	a1 77       	lsl	r7,0x1
8000b7e4:	5c fa       	rol	r10
8000b7e6:	5c fb       	rol	r11
8000b7e8:	20 1c       	sub	r12,1
8000b7ea:	58 0c       	cp.w	r12,0
8000b7ec:	e0 8a 00 6f 	brle	8000b8ca <__avr32_f64_mul_res_subnormal>
8000b7f0:	e0 4c 07 ff 	cp.w	r12,2047
8000b7f4:	e0 84 00 9c 	brge	8000b92c <__avr32_f64_mul_res_inf>
8000b7f8:	f7 dc d2 8b 	bfins	r11,r12,0x14,0xb
8000b7fc:	ed ea 11 f6 	or	r6,r6,r10<<0x1f
8000b800:	ef e6 12 17 	or	r7,r7,r6>>0x1
8000b804:	ee 17 80 00 	eorh	r7,0x8000
8000b808:	f1 b7 04 20 	satu	r7,0x1
8000b80c:	0e 0a       	add	r10,r7
8000b80e:	5c 0b       	acr	r11
8000b810:	ed be 00 1f 	bld	lr,0x1f
8000b814:	ef bb 00 1f 	bst	r11,0x1f
8000b818:	d8 22       	popm	r4-r7,pc

8000b81a <__avr32_f64_mul_op1_subnormal>:
8000b81a:	e4 1b 00 0f 	andh	r11,0xf
8000b81e:	f4 0c 12 00 	clz	r12,r10
8000b822:	f6 06 12 00 	clz	r6,r11
8000b826:	f7 bc 03 e1 	sublo	r12,-31
8000b82a:	f8 06 17 30 	movlo	r6,r12
8000b82e:	f7 b6 02 01 	subhs	r6,1
8000b832:	e0 46 00 20 	cp.w	r6,32
8000b836:	c0 d4       	brge	8000b850 <__avr32_f64_mul_op1_subnormal+0x36>
8000b838:	ec 0c 11 20 	rsub	r12,r6,32
8000b83c:	f6 06 09 4b 	lsl	r11,r11,r6
8000b840:	f4 0c 0a 4c 	lsr	r12,r10,r12
8000b844:	18 4b       	or	r11,r12
8000b846:	f4 06 09 4a 	lsl	r10,r10,r6
8000b84a:	20 b6       	sub	r6,11
8000b84c:	0c 17       	sub	r7,r6
8000b84e:	ca ab       	rjmp	8000b7a2 <__avr32_f64_mul+0x22>
8000b850:	f4 06 09 4b 	lsl	r11,r10,r6
8000b854:	c6 40       	breq	8000b91c <__avr32_f64_mul_res_zero>
8000b856:	30 0a       	mov	r10,0
8000b858:	20 b6       	sub	r6,11
8000b85a:	0c 17       	sub	r7,r6
8000b85c:	ca 3b       	rjmp	8000b7a2 <__avr32_f64_mul+0x22>

8000b85e <__avr32_f64_mul_op2_subnormal>:
8000b85e:	e4 19 00 0f 	andh	r9,0xf
8000b862:	f0 0c 12 00 	clz	r12,r8
8000b866:	f2 05 12 00 	clz	r5,r9
8000b86a:	f7 bc 03 ea 	sublo	r12,-22
8000b86e:	f8 05 17 30 	movlo	r5,r12
8000b872:	f7 b5 02 0a 	subhs	r5,10
8000b876:	e0 45 00 20 	cp.w	r5,32
8000b87a:	c0 d4       	brge	8000b894 <__avr32_f64_mul_op2_subnormal+0x36>
8000b87c:	ea 0c 11 20 	rsub	r12,r5,32
8000b880:	f2 05 09 49 	lsl	r9,r9,r5
8000b884:	f0 0c 0a 4c 	lsr	r12,r8,r12
8000b888:	18 49       	or	r9,r12
8000b88a:	f0 05 09 48 	lsl	r8,r8,r5
8000b88e:	20 25       	sub	r5,2
8000b890:	0a 16       	sub	r6,r5
8000b892:	c8 fb       	rjmp	8000b7b0 <__avr32_f64_mul+0x30>
8000b894:	f0 05 09 49 	lsl	r9,r8,r5
8000b898:	c4 20       	breq	8000b91c <__avr32_f64_mul_res_zero>
8000b89a:	30 08       	mov	r8,0
8000b89c:	20 25       	sub	r5,2
8000b89e:	0a 16       	sub	r6,r5
8000b8a0:	c8 8b       	rjmp	8000b7b0 <__avr32_f64_mul+0x30>

8000b8a2 <__avr32_f64_mul_op_nan_or_inf>:
8000b8a2:	e4 19 00 0f 	andh	r9,0xf
8000b8a6:	e4 1b 00 0f 	andh	r11,0xf
8000b8aa:	14 4b       	or	r11,r10
8000b8ac:	10 49       	or	r9,r8
8000b8ae:	e0 47 07 ff 	cp.w	r7,2047
8000b8b2:	c0 91       	brne	8000b8c4 <__avr32_f64_mul_op1_not_naninf>
8000b8b4:	58 0b       	cp.w	r11,0
8000b8b6:	c3 81       	brne	8000b926 <__avr32_f64_mul_res_nan>
8000b8b8:	e0 46 07 ff 	cp.w	r6,2047
8000b8bc:	c3 81       	brne	8000b92c <__avr32_f64_mul_res_inf>
8000b8be:	58 09       	cp.w	r9,0
8000b8c0:	c3 60       	breq	8000b92c <__avr32_f64_mul_res_inf>
8000b8c2:	c3 28       	rjmp	8000b926 <__avr32_f64_mul_res_nan>

8000b8c4 <__avr32_f64_mul_op1_not_naninf>:
8000b8c4:	58 09       	cp.w	r9,0
8000b8c6:	c3 30       	breq	8000b92c <__avr32_f64_mul_res_inf>
8000b8c8:	c2 f8       	rjmp	8000b926 <__avr32_f64_mul_res_nan>

8000b8ca <__avr32_f64_mul_res_subnormal>:
8000b8ca:	5c 3c       	neg	r12
8000b8cc:	2f fc       	sub	r12,-1
8000b8ce:	f1 bc 04 c0 	satu	r12,0x6
8000b8d2:	e0 4c 00 20 	cp.w	r12,32
8000b8d6:	c1 14       	brge	8000b8f8 <__avr32_f64_mul_res_subnormal+0x2e>
8000b8d8:	f8 08 11 20 	rsub	r8,r12,32
8000b8dc:	0e 46       	or	r6,r7
8000b8de:	ee 0c 0a 47 	lsr	r7,r7,r12
8000b8e2:	f4 08 09 49 	lsl	r9,r10,r8
8000b8e6:	12 47       	or	r7,r9
8000b8e8:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000b8ec:	f6 08 09 49 	lsl	r9,r11,r8
8000b8f0:	12 4a       	or	r10,r9
8000b8f2:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000b8f6:	c8 3b       	rjmp	8000b7fc <__avr32_f64_mul+0x7c>
8000b8f8:	f8 08 11 20 	rsub	r8,r12,32
8000b8fc:	f9 b9 00 00 	moveq	r9,0
8000b900:	c0 30       	breq	8000b906 <__avr32_f64_mul_res_subnormal+0x3c>
8000b902:	f6 08 09 49 	lsl	r9,r11,r8
8000b906:	0e 46       	or	r6,r7
8000b908:	ed ea 10 16 	or	r6,r6,r10<<0x1
8000b90c:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000b910:	f3 ea 10 07 	or	r7,r9,r10
8000b914:	f6 0c 0a 4a 	lsr	r10,r11,r12
8000b918:	30 0b       	mov	r11,0
8000b91a:	c7 1b       	rjmp	8000b7fc <__avr32_f64_mul+0x7c>

8000b91c <__avr32_f64_mul_res_zero>:
8000b91c:	1c 9b       	mov	r11,lr
8000b91e:	e6 1b 80 00 	andh	r11,0x8000,COH
8000b922:	30 0a       	mov	r10,0
8000b924:	d8 22       	popm	r4-r7,pc

8000b926 <__avr32_f64_mul_res_nan>:
8000b926:	3f fb       	mov	r11,-1
8000b928:	3f fa       	mov	r10,-1
8000b92a:	d8 22       	popm	r4-r7,pc

8000b92c <__avr32_f64_mul_res_inf>:
8000b92c:	f0 6b 00 00 	mov	r11,-1048576
8000b930:	ed be 00 1f 	bld	lr,0x1f
8000b934:	ef bb 00 1f 	bst	r11,0x1f
8000b938:	30 0a       	mov	r10,0
8000b93a:	d8 22       	popm	r4-r7,pc

8000b93c <__avr32_f64_mul_op1_zero>:
8000b93c:	f7 e9 20 0b 	eor	r11,r11,r9
8000b940:	e6 1b 80 00 	andh	r11,0x8000,COH
8000b944:	f9 d9 c2 8b 	bfextu	r12,r9,0x14,0xb
8000b948:	e0 4c 07 ff 	cp.w	r12,2047
8000b94c:	5e 1c       	retne	r12
8000b94e:	3f fa       	mov	r10,-1
8000b950:	3f fb       	mov	r11,-1
8000b952:	5e fc       	retal	r12

8000b954 <__avr32_f64_sub_from_add>:
8000b954:	ee 19 80 00 	eorh	r9,0x8000

8000b958 <__avr32_f64_sub>:
8000b958:	f7 e9 20 0c 	eor	r12,r11,r9
8000b95c:	e0 86 00 ca 	brmi	8000baf0 <__avr32_f64_add_from_sub>
8000b960:	eb cd 40 e0 	pushm	r5-r7,lr
8000b964:	16 9c       	mov	r12,r11
8000b966:	e6 1c 80 00 	andh	r12,0x8000,COH
8000b96a:	bf db       	cbr	r11,0x1f
8000b96c:	bf d9       	cbr	r9,0x1f
8000b96e:	10 3a       	cp.w	r10,r8
8000b970:	f2 0b 13 00 	cpc	r11,r9
8000b974:	c0 92       	brcc	8000b986 <__avr32_f64_sub+0x2e>
8000b976:	16 97       	mov	r7,r11
8000b978:	12 9b       	mov	r11,r9
8000b97a:	0e 99       	mov	r9,r7
8000b97c:	14 97       	mov	r7,r10
8000b97e:	10 9a       	mov	r10,r8
8000b980:	0e 98       	mov	r8,r7
8000b982:	ee 1c 80 00 	eorh	r12,0x8000
8000b986:	f6 07 16 14 	lsr	r7,r11,0x14
8000b98a:	ab 7b       	lsl	r11,0xb
8000b98c:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000b990:	ab 7a       	lsl	r10,0xb
8000b992:	bf bb       	sbr	r11,0x1f
8000b994:	f2 06 16 14 	lsr	r6,r9,0x14
8000b998:	c4 40       	breq	8000ba20 <__avr32_f64_sub_opL_subnormal>
8000b99a:	ab 79       	lsl	r9,0xb
8000b99c:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000b9a0:	ab 78       	lsl	r8,0xb
8000b9a2:	bf b9       	sbr	r9,0x1f

8000b9a4 <__avr32_f64_sub_opL_subnormal_done>:
8000b9a4:	e0 47 07 ff 	cp.w	r7,2047
8000b9a8:	c4 f0       	breq	8000ba46 <__avr32_f64_sub_opH_nan_or_inf>
8000b9aa:	0e 26       	rsub	r6,r7
8000b9ac:	c1 20       	breq	8000b9d0 <__avr32_f64_sub_shift_done>
8000b9ae:	ec 05 11 20 	rsub	r5,r6,32
8000b9b2:	e0 46 00 20 	cp.w	r6,32
8000b9b6:	c7 c2       	brcc	8000baae <__avr32_f64_sub_longshift>
8000b9b8:	f0 05 09 4e 	lsl	lr,r8,r5
8000b9bc:	f2 05 09 45 	lsl	r5,r9,r5
8000b9c0:	f0 06 0a 48 	lsr	r8,r8,r6
8000b9c4:	f2 06 0a 49 	lsr	r9,r9,r6
8000b9c8:	0a 48       	or	r8,r5
8000b9ca:	58 0e       	cp.w	lr,0
8000b9cc:	5f 1e       	srne	lr
8000b9ce:	1c 48       	or	r8,lr

8000b9d0 <__avr32_f64_sub_shift_done>:
8000b9d0:	10 1a       	sub	r10,r8
8000b9d2:	f6 09 01 4b 	sbc	r11,r11,r9
8000b9d6:	f6 06 12 00 	clz	r6,r11
8000b9da:	c0 e0       	breq	8000b9f6 <__avr32_f64_sub_longnormalize_done>
8000b9dc:	c7 83       	brcs	8000bacc <__avr32_f64_sub_longnormalize>
8000b9de:	ec 0e 11 20 	rsub	lr,r6,32
8000b9e2:	f6 06 09 4b 	lsl	r11,r11,r6
8000b9e6:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000b9ea:	1c 4b       	or	r11,lr
8000b9ec:	f4 06 09 4a 	lsl	r10,r10,r6
8000b9f0:	0c 17       	sub	r7,r6
8000b9f2:	e0 8a 00 39 	brle	8000ba64 <__avr32_f64_sub_subnormal_result>

8000b9f6 <__avr32_f64_sub_longnormalize_done>:
8000b9f6:	f4 09 15 15 	lsl	r9,r10,0x15
8000b9fa:	ab 9a       	lsr	r10,0xb
8000b9fc:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000ba00:	ab 9b       	lsr	r11,0xb
8000ba02:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000ba06:	18 4b       	or	r11,r12

8000ba08 <__avr32_f64_sub_round>:
8000ba08:	fc 17 80 00 	movh	r7,0x8000
8000ba0c:	ed ba 00 00 	bld	r10,0x0
8000ba10:	f7 b7 01 ff 	subne	r7,-1
8000ba14:	0e 39       	cp.w	r9,r7
8000ba16:	5f 29       	srhs	r9
8000ba18:	12 0a       	add	r10,r9
8000ba1a:	5c 0b       	acr	r11
8000ba1c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000ba20 <__avr32_f64_sub_opL_subnormal>:
8000ba20:	ab 79       	lsl	r9,0xb
8000ba22:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000ba26:	ab 78       	lsl	r8,0xb
8000ba28:	f3 e8 10 0e 	or	lr,r9,r8
8000ba2c:	f9 b6 01 01 	movne	r6,1
8000ba30:	ee 0e 11 00 	rsub	lr,r7,0
8000ba34:	f9 b7 00 01 	moveq	r7,1
8000ba38:	ef bb 00 1f 	bst	r11,0x1f
8000ba3c:	f7 ea 10 0e 	or	lr,r11,r10
8000ba40:	f9 b7 00 00 	moveq	r7,0
8000ba44:	cb 0b       	rjmp	8000b9a4 <__avr32_f64_sub_opL_subnormal_done>

8000ba46 <__avr32_f64_sub_opH_nan_or_inf>:
8000ba46:	bf db       	cbr	r11,0x1f
8000ba48:	f7 ea 10 0e 	or	lr,r11,r10
8000ba4c:	c0 81       	brne	8000ba5c <__avr32_f64_sub_return_nan>
8000ba4e:	e0 46 07 ff 	cp.w	r6,2047
8000ba52:	c0 50       	breq	8000ba5c <__avr32_f64_sub_return_nan>
8000ba54:	f9 e7 11 4b 	or	r11,r12,r7<<0x14
8000ba58:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000ba5c <__avr32_f64_sub_return_nan>:
8000ba5c:	3f fa       	mov	r10,-1
8000ba5e:	3f fb       	mov	r11,-1
8000ba60:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000ba64 <__avr32_f64_sub_subnormal_result>:
8000ba64:	5c 37       	neg	r7
8000ba66:	2f f7       	sub	r7,-1
8000ba68:	f1 b7 04 c0 	satu	r7,0x6
8000ba6c:	e0 47 00 20 	cp.w	r7,32
8000ba70:	c1 14       	brge	8000ba92 <__avr32_f64_sub_subnormal_result+0x2e>
8000ba72:	ee 08 11 20 	rsub	r8,r7,32
8000ba76:	f4 08 09 49 	lsl	r9,r10,r8
8000ba7a:	5f 16       	srne	r6
8000ba7c:	f4 07 0a 4a 	lsr	r10,r10,r7
8000ba80:	0c 4a       	or	r10,r6
8000ba82:	f6 08 09 49 	lsl	r9,r11,r8
8000ba86:	f5 e9 10 0a 	or	r10,r10,r9
8000ba8a:	f4 07 0a 4b 	lsr	r11,r10,r7
8000ba8e:	30 07       	mov	r7,0
8000ba90:	cb 3b       	rjmp	8000b9f6 <__avr32_f64_sub_longnormalize_done>
8000ba92:	ee 08 11 40 	rsub	r8,r7,64
8000ba96:	f6 08 09 49 	lsl	r9,r11,r8
8000ba9a:	14 49       	or	r9,r10
8000ba9c:	5f 16       	srne	r6
8000ba9e:	f6 07 0a 4a 	lsr	r10,r11,r7
8000baa2:	0c 4a       	or	r10,r6
8000baa4:	30 0b       	mov	r11,0
8000baa6:	30 07       	mov	r7,0
8000baa8:	ca 7b       	rjmp	8000b9f6 <__avr32_f64_sub_longnormalize_done>
8000baaa:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000baae <__avr32_f64_sub_longshift>:
8000baae:	f1 b6 04 c0 	satu	r6,0x6
8000bab2:	f0 0e 17 00 	moveq	lr,r8
8000bab6:	c0 40       	breq	8000babe <__avr32_f64_sub_longshift+0x10>
8000bab8:	f2 05 09 4e 	lsl	lr,r9,r5
8000babc:	10 4e       	or	lr,r8
8000babe:	f2 06 0a 48 	lsr	r8,r9,r6
8000bac2:	30 09       	mov	r9,0
8000bac4:	58 0e       	cp.w	lr,0
8000bac6:	5f 1e       	srne	lr
8000bac8:	1c 48       	or	r8,lr
8000baca:	c8 3b       	rjmp	8000b9d0 <__avr32_f64_sub_shift_done>

8000bacc <__avr32_f64_sub_longnormalize>:
8000bacc:	f4 06 12 00 	clz	r6,r10
8000bad0:	f9 b7 03 00 	movlo	r7,0
8000bad4:	f9 b6 03 00 	movlo	r6,0
8000bad8:	f9 bc 03 00 	movlo	r12,0
8000badc:	f7 b6 02 e0 	subhs	r6,-32
8000bae0:	f4 06 09 4b 	lsl	r11,r10,r6
8000bae4:	30 0a       	mov	r10,0
8000bae6:	0c 17       	sub	r7,r6
8000bae8:	fe 9a ff be 	brle	8000ba64 <__avr32_f64_sub_subnormal_result>
8000baec:	c8 5b       	rjmp	8000b9f6 <__avr32_f64_sub_longnormalize_done>
8000baee:	d7 03       	nop

8000baf0 <__avr32_f64_add_from_sub>:
8000baf0:	ee 19 80 00 	eorh	r9,0x8000

8000baf4 <__avr32_f64_add>:
8000baf4:	f7 e9 20 0c 	eor	r12,r11,r9
8000baf8:	fe 96 ff 2e 	brmi	8000b954 <__avr32_f64_sub_from_add>
8000bafc:	eb cd 40 e0 	pushm	r5-r7,lr
8000bb00:	16 9c       	mov	r12,r11
8000bb02:	e6 1c 80 00 	andh	r12,0x8000,COH
8000bb06:	bf db       	cbr	r11,0x1f
8000bb08:	bf d9       	cbr	r9,0x1f
8000bb0a:	12 3b       	cp.w	r11,r9
8000bb0c:	c0 72       	brcc	8000bb1a <__avr32_f64_add+0x26>
8000bb0e:	16 97       	mov	r7,r11
8000bb10:	12 9b       	mov	r11,r9
8000bb12:	0e 99       	mov	r9,r7
8000bb14:	14 97       	mov	r7,r10
8000bb16:	10 9a       	mov	r10,r8
8000bb18:	0e 98       	mov	r8,r7
8000bb1a:	30 0e       	mov	lr,0
8000bb1c:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000bb20:	f7 db c0 14 	bfextu	r11,r11,0x0,0x14
8000bb24:	b5 ab       	sbr	r11,0x14
8000bb26:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000bb2a:	c6 20       	breq	8000bbee <__avr32_f64_add_op2_subnormal>
8000bb2c:	f3 d9 c0 14 	bfextu	r9,r9,0x0,0x14
8000bb30:	b5 a9       	sbr	r9,0x14
8000bb32:	e0 47 07 ff 	cp.w	r7,2047
8000bb36:	c2 80       	breq	8000bb86 <__avr32_f64_add_opH_nan_or_inf>
8000bb38:	0e 26       	rsub	r6,r7
8000bb3a:	c1 20       	breq	8000bb5e <__avr32_f64_add_shift_done>
8000bb3c:	e0 46 00 36 	cp.w	r6,54
8000bb40:	c1 52       	brcc	8000bb6a <__avr32_f64_add_res_of_done>
8000bb42:	ec 05 11 20 	rsub	r5,r6,32
8000bb46:	e0 46 00 20 	cp.w	r6,32
8000bb4a:	c3 52       	brcc	8000bbb4 <__avr32_f64_add_longshift>
8000bb4c:	f0 05 09 4e 	lsl	lr,r8,r5
8000bb50:	f2 05 09 45 	lsl	r5,r9,r5
8000bb54:	f0 06 0a 48 	lsr	r8,r8,r6
8000bb58:	f2 06 0a 49 	lsr	r9,r9,r6
8000bb5c:	0a 48       	or	r8,r5

8000bb5e <__avr32_f64_add_shift_done>:
8000bb5e:	10 0a       	add	r10,r8
8000bb60:	f6 09 00 4b 	adc	r11,r11,r9
8000bb64:	ed bb 00 15 	bld	r11,0x15
8000bb68:	c3 40       	breq	8000bbd0 <__avr32_f64_add_res_of>

8000bb6a <__avr32_f64_add_res_of_done>:
8000bb6a:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000bb6e:	18 4b       	or	r11,r12

8000bb70 <__avr32_f64_add_round>:
8000bb70:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
8000bb74:	18 4e       	or	lr,r12
8000bb76:	ee 1e 80 00 	eorh	lr,0x8000
8000bb7a:	f1 be 04 20 	satu	lr,0x1
8000bb7e:	1c 0a       	add	r10,lr
8000bb80:	5c 0b       	acr	r11
8000bb82:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bb86 <__avr32_f64_add_opH_nan_or_inf>:
8000bb86:	b5 cb       	cbr	r11,0x14
8000bb88:	f7 ea 10 0e 	or	lr,r11,r10
8000bb8c:	c1 01       	brne	8000bbac <__avr32_f64_add_return_nan>
8000bb8e:	e0 46 07 ff 	cp.w	r6,2047
8000bb92:	c0 30       	breq	8000bb98 <__avr32_f64_add_opL_nan_or_inf>
8000bb94:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bb98 <__avr32_f64_add_opL_nan_or_inf>:
8000bb98:	b5 c9       	cbr	r9,0x14
8000bb9a:	f3 e8 10 0e 	or	lr,r9,r8
8000bb9e:	c0 71       	brne	8000bbac <__avr32_f64_add_return_nan>
8000bba0:	30 0a       	mov	r10,0
8000bba2:	fc 1b 7f f0 	movh	r11,0x7ff0
8000bba6:	18 4b       	or	r11,r12
8000bba8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bbac <__avr32_f64_add_return_nan>:
8000bbac:	3f fa       	mov	r10,-1
8000bbae:	3f fb       	mov	r11,-1
8000bbb0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bbb4 <__avr32_f64_add_longshift>:
8000bbb4:	f1 b6 04 c0 	satu	r6,0x6
8000bbb8:	f0 0e 17 00 	moveq	lr,r8
8000bbbc:	c0 60       	breq	8000bbc8 <__avr32_f64_add_longshift+0x14>
8000bbbe:	f2 05 09 4e 	lsl	lr,r9,r5
8000bbc2:	58 08       	cp.w	r8,0
8000bbc4:	5f 18       	srne	r8
8000bbc6:	10 4e       	or	lr,r8
8000bbc8:	f2 06 0a 48 	lsr	r8,r9,r6
8000bbcc:	30 09       	mov	r9,0
8000bbce:	cc 8b       	rjmp	8000bb5e <__avr32_f64_add_shift_done>

8000bbd0 <__avr32_f64_add_res_of>:
8000bbd0:	fd ee 10 1e 	or	lr,lr,lr<<0x1
8000bbd4:	a1 9b       	lsr	r11,0x1
8000bbd6:	5d 0a       	ror	r10
8000bbd8:	5d 0e       	ror	lr
8000bbda:	2f f7       	sub	r7,-1
8000bbdc:	e0 47 07 ff 	cp.w	r7,2047
8000bbe0:	f9 ba 00 00 	moveq	r10,0
8000bbe4:	f9 bb 00 00 	moveq	r11,0
8000bbe8:	f9 be 00 00 	moveq	lr,0
8000bbec:	cb fb       	rjmp	8000bb6a <__avr32_f64_add_res_of_done>

8000bbee <__avr32_f64_add_op2_subnormal>:
8000bbee:	30 16       	mov	r6,1
8000bbf0:	58 07       	cp.w	r7,0
8000bbf2:	ca 01       	brne	8000bb32 <__avr32_f64_add+0x3e>
8000bbf4:	b5 cb       	cbr	r11,0x14
8000bbf6:	10 0a       	add	r10,r8
8000bbf8:	f6 09 00 4b 	adc	r11,r11,r9
8000bbfc:	18 4b       	or	r11,r12
8000bbfe:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000bc02:	d7 03       	nop

8000bc04 <__avr32_f64_to_u32>:
8000bc04:	58 0b       	cp.w	r11,0
8000bc06:	5e 6d       	retmi	0

8000bc08 <__avr32_f64_to_s32>:
8000bc08:	f6 0c 15 01 	lsl	r12,r11,0x1
8000bc0c:	b5 9c       	lsr	r12,0x15
8000bc0e:	e0 2c 03 ff 	sub	r12,1023
8000bc12:	5e 3d       	retlo	0
8000bc14:	f8 0c 11 1f 	rsub	r12,r12,31
8000bc18:	16 99       	mov	r9,r11
8000bc1a:	ab 7b       	lsl	r11,0xb
8000bc1c:	bf bb       	sbr	r11,0x1f
8000bc1e:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000bc22:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000bc26:	a1 79       	lsl	r9,0x1
8000bc28:	5e 2b       	reths	r11
8000bc2a:	5c 3b       	neg	r11
8000bc2c:	5e fb       	retal	r11

8000bc2e <__avr32_u32_to_f64>:
8000bc2e:	f8 cb 00 00 	sub	r11,r12,0
8000bc32:	30 0c       	mov	r12,0
8000bc34:	c0 38       	rjmp	8000bc3a <__avr32_s32_to_f64+0x4>

8000bc36 <__avr32_s32_to_f64>:
8000bc36:	18 9b       	mov	r11,r12
8000bc38:	5c 4b       	abs	r11
8000bc3a:	30 0a       	mov	r10,0
8000bc3c:	5e 0b       	reteq	r11
8000bc3e:	d4 01       	pushm	lr
8000bc40:	e0 69 04 1e 	mov	r9,1054
8000bc44:	f6 08 12 00 	clz	r8,r11
8000bc48:	c1 70       	breq	8000bc76 <__avr32_s32_to_f64+0x40>
8000bc4a:	c0 c3       	brcs	8000bc62 <__avr32_s32_to_f64+0x2c>
8000bc4c:	f0 0e 11 20 	rsub	lr,r8,32
8000bc50:	f6 08 09 4b 	lsl	r11,r11,r8
8000bc54:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000bc58:	1c 4b       	or	r11,lr
8000bc5a:	f4 08 09 4a 	lsl	r10,r10,r8
8000bc5e:	10 19       	sub	r9,r8
8000bc60:	c0 b8       	rjmp	8000bc76 <__avr32_s32_to_f64+0x40>
8000bc62:	f4 08 12 00 	clz	r8,r10
8000bc66:	f9 b8 03 00 	movlo	r8,0
8000bc6a:	f7 b8 02 e0 	subhs	r8,-32
8000bc6e:	f4 08 09 4b 	lsl	r11,r10,r8
8000bc72:	30 0a       	mov	r10,0
8000bc74:	10 19       	sub	r9,r8
8000bc76:	58 09       	cp.w	r9,0
8000bc78:	e0 89 00 30 	brgt	8000bcd8 <__avr32_s32_to_f64+0xa2>
8000bc7c:	5c 39       	neg	r9
8000bc7e:	2f f9       	sub	r9,-1
8000bc80:	e0 49 00 36 	cp.w	r9,54
8000bc84:	c0 43       	brcs	8000bc8c <__avr32_s32_to_f64+0x56>
8000bc86:	30 0b       	mov	r11,0
8000bc88:	30 0a       	mov	r10,0
8000bc8a:	c2 68       	rjmp	8000bcd6 <__avr32_s32_to_f64+0xa0>
8000bc8c:	2f 69       	sub	r9,-10
8000bc8e:	f2 08 11 20 	rsub	r8,r9,32
8000bc92:	e0 49 00 20 	cp.w	r9,32
8000bc96:	c0 b2       	brcc	8000bcac <__avr32_s32_to_f64+0x76>
8000bc98:	f4 08 09 4e 	lsl	lr,r10,r8
8000bc9c:	f6 08 09 48 	lsl	r8,r11,r8
8000bca0:	f4 09 0a 4a 	lsr	r10,r10,r9
8000bca4:	f6 09 0a 4b 	lsr	r11,r11,r9
8000bca8:	10 4b       	or	r11,r8
8000bcaa:	c0 88       	rjmp	8000bcba <__avr32_s32_to_f64+0x84>
8000bcac:	f6 08 09 4e 	lsl	lr,r11,r8
8000bcb0:	14 4e       	or	lr,r10
8000bcb2:	16 9a       	mov	r10,r11
8000bcb4:	30 0b       	mov	r11,0
8000bcb6:	f4 09 0a 4a 	lsr	r10,r10,r9
8000bcba:	ed ba 00 00 	bld	r10,0x0
8000bcbe:	c0 92       	brcc	8000bcd0 <__avr32_s32_to_f64+0x9a>
8000bcc0:	1c 7e       	tst	lr,lr
8000bcc2:	c0 41       	brne	8000bcca <__avr32_s32_to_f64+0x94>
8000bcc4:	ed ba 00 01 	bld	r10,0x1
8000bcc8:	c0 42       	brcc	8000bcd0 <__avr32_s32_to_f64+0x9a>
8000bcca:	2f fa       	sub	r10,-1
8000bccc:	f7 bb 02 ff 	subhs	r11,-1
8000bcd0:	5c fc       	rol	r12
8000bcd2:	5d 0b       	ror	r11
8000bcd4:	5d 0a       	ror	r10
8000bcd6:	d8 02       	popm	pc
8000bcd8:	e0 68 03 ff 	mov	r8,1023
8000bcdc:	ed ba 00 0b 	bld	r10,0xb
8000bce0:	f7 b8 00 ff 	subeq	r8,-1
8000bce4:	10 0a       	add	r10,r8
8000bce6:	5c 0b       	acr	r11
8000bce8:	f7 b9 03 fe 	sublo	r9,-2
8000bcec:	e0 49 07 ff 	cp.w	r9,2047
8000bcf0:	c0 55       	brlt	8000bcfa <__avr32_s32_to_f64+0xc4>
8000bcf2:	30 0a       	mov	r10,0
8000bcf4:	fc 1b ff e0 	movh	r11,0xffe0
8000bcf8:	c0 c8       	rjmp	8000bd10 <__floatsidf_return_op1>
8000bcfa:	ed bb 00 1f 	bld	r11,0x1f
8000bcfe:	f7 b9 01 01 	subne	r9,1
8000bd02:	ab 9a       	lsr	r10,0xb
8000bd04:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000bd08:	a1 7b       	lsl	r11,0x1
8000bd0a:	ab 9b       	lsr	r11,0xb
8000bd0c:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

8000bd10 <__floatsidf_return_op1>:
8000bd10:	a1 7c       	lsl	r12,0x1
8000bd12:	5d 0b       	ror	r11
8000bd14:	d8 02       	popm	pc

8000bd16 <__avr32_f64_cmp_eq>:
8000bd16:	10 3a       	cp.w	r10,r8
8000bd18:	f2 0b 13 00 	cpc	r11,r9
8000bd1c:	c0 80       	breq	8000bd2c <__avr32_f64_cmp_eq+0x16>
8000bd1e:	a1 7b       	lsl	r11,0x1
8000bd20:	a1 79       	lsl	r9,0x1
8000bd22:	14 4b       	or	r11,r10
8000bd24:	12 4b       	or	r11,r9
8000bd26:	10 4b       	or	r11,r8
8000bd28:	5e 0f       	reteq	1
8000bd2a:	5e fd       	retal	0
8000bd2c:	a1 7b       	lsl	r11,0x1
8000bd2e:	fc 1c ff e0 	movh	r12,0xffe0
8000bd32:	58 0a       	cp.w	r10,0
8000bd34:	f8 0b 13 00 	cpc	r11,r12
8000bd38:	5e 8f       	retls	1
8000bd3a:	5e fd       	retal	0

8000bd3c <__avr32_f64_cmp_ge>:
8000bd3c:	1a de       	st.w	--sp,lr
8000bd3e:	1a d7       	st.w	--sp,r7
8000bd40:	a1 7b       	lsl	r11,0x1
8000bd42:	5f 3c       	srlo	r12
8000bd44:	a1 79       	lsl	r9,0x1
8000bd46:	5f 37       	srlo	r7
8000bd48:	5c fc       	rol	r12
8000bd4a:	fc 1e ff e0 	movh	lr,0xffe0
8000bd4e:	58 0a       	cp.w	r10,0
8000bd50:	fc 0b 13 00 	cpc	r11,lr
8000bd54:	e0 8b 00 1d 	brhi	8000bd8e <__avr32_f64_cmp_ge+0x52>
8000bd58:	58 08       	cp.w	r8,0
8000bd5a:	fc 09 13 00 	cpc	r9,lr
8000bd5e:	e0 8b 00 18 	brhi	8000bd8e <__avr32_f64_cmp_ge+0x52>
8000bd62:	58 0b       	cp.w	r11,0
8000bd64:	f5 ba 00 00 	subfeq	r10,0
8000bd68:	c1 50       	breq	8000bd92 <__avr32_f64_cmp_ge+0x56>
8000bd6a:	1b 07       	ld.w	r7,sp++
8000bd6c:	1b 0e       	ld.w	lr,sp++
8000bd6e:	58 3c       	cp.w	r12,3
8000bd70:	c0 a0       	breq	8000bd84 <__avr32_f64_cmp_ge+0x48>
8000bd72:	58 1c       	cp.w	r12,1
8000bd74:	c0 33       	brcs	8000bd7a <__avr32_f64_cmp_ge+0x3e>
8000bd76:	5e 0f       	reteq	1
8000bd78:	5e 1d       	retne	0
8000bd7a:	10 3a       	cp.w	r10,r8
8000bd7c:	f2 0b 13 00 	cpc	r11,r9
8000bd80:	5e 2f       	reths	1
8000bd82:	5e 3d       	retlo	0
8000bd84:	14 38       	cp.w	r8,r10
8000bd86:	f6 09 13 00 	cpc	r9,r11
8000bd8a:	5e 2f       	reths	1
8000bd8c:	5e 3d       	retlo	0
8000bd8e:	1b 07       	ld.w	r7,sp++
8000bd90:	d8 0a       	popm	pc,r12=0
8000bd92:	58 17       	cp.w	r7,1
8000bd94:	5f 0c       	sreq	r12
8000bd96:	58 09       	cp.w	r9,0
8000bd98:	f5 b8 00 00 	subfeq	r8,0
8000bd9c:	1b 07       	ld.w	r7,sp++
8000bd9e:	1b 0e       	ld.w	lr,sp++
8000bda0:	5e 0f       	reteq	1
8000bda2:	5e fc       	retal	r12

8000bda4 <__avr32_f64_cmp_lt>:
8000bda4:	1a de       	st.w	--sp,lr
8000bda6:	1a d7       	st.w	--sp,r7
8000bda8:	a1 7b       	lsl	r11,0x1
8000bdaa:	5f 3c       	srlo	r12
8000bdac:	a1 79       	lsl	r9,0x1
8000bdae:	5f 37       	srlo	r7
8000bdb0:	5c fc       	rol	r12
8000bdb2:	fc 1e ff e0 	movh	lr,0xffe0
8000bdb6:	58 0a       	cp.w	r10,0
8000bdb8:	fc 0b 13 00 	cpc	r11,lr
8000bdbc:	e0 8b 00 1d 	brhi	8000bdf6 <__avr32_f64_cmp_lt+0x52>
8000bdc0:	58 08       	cp.w	r8,0
8000bdc2:	fc 09 13 00 	cpc	r9,lr
8000bdc6:	e0 8b 00 18 	brhi	8000bdf6 <__avr32_f64_cmp_lt+0x52>
8000bdca:	58 0b       	cp.w	r11,0
8000bdcc:	f5 ba 00 00 	subfeq	r10,0
8000bdd0:	c1 50       	breq	8000bdfa <__avr32_f64_cmp_lt+0x56>
8000bdd2:	1b 07       	ld.w	r7,sp++
8000bdd4:	1b 0e       	ld.w	lr,sp++
8000bdd6:	58 3c       	cp.w	r12,3
8000bdd8:	c0 a0       	breq	8000bdec <__avr32_f64_cmp_lt+0x48>
8000bdda:	58 1c       	cp.w	r12,1
8000bddc:	c0 33       	brcs	8000bde2 <__avr32_f64_cmp_lt+0x3e>
8000bdde:	5e 0d       	reteq	0
8000bde0:	5e 1f       	retne	1
8000bde2:	10 3a       	cp.w	r10,r8
8000bde4:	f2 0b 13 00 	cpc	r11,r9
8000bde8:	5e 2d       	reths	0
8000bdea:	5e 3f       	retlo	1
8000bdec:	14 38       	cp.w	r8,r10
8000bdee:	f6 09 13 00 	cpc	r9,r11
8000bdf2:	5e 2d       	reths	0
8000bdf4:	5e 3f       	retlo	1
8000bdf6:	1b 07       	ld.w	r7,sp++
8000bdf8:	d8 0a       	popm	pc,r12=0
8000bdfa:	58 17       	cp.w	r7,1
8000bdfc:	5f 1c       	srne	r12
8000bdfe:	58 09       	cp.w	r9,0
8000be00:	f5 b8 00 00 	subfeq	r8,0
8000be04:	1b 07       	ld.w	r7,sp++
8000be06:	1b 0e       	ld.w	lr,sp++
8000be08:	5e 0d       	reteq	0
8000be0a:	5e fc       	retal	r12

8000be0c <__avr32_f64_div>:
8000be0c:	eb cd 40 ff 	pushm	r0-r7,lr
8000be10:	f7 e9 20 0e 	eor	lr,r11,r9
8000be14:	f6 07 16 14 	lsr	r7,r11,0x14
8000be18:	a9 7b       	lsl	r11,0x9
8000be1a:	f7 ea 13 7b 	or	r11,r11,r10>>0x17
8000be1e:	a9 7a       	lsl	r10,0x9
8000be20:	bd bb       	sbr	r11,0x1d
8000be22:	e4 1b 3f ff 	andh	r11,0x3fff
8000be26:	ab d7       	cbr	r7,0xb
8000be28:	e0 80 00 cc 	breq	8000bfc0 <__avr32_f64_div_round_subnormal+0x54>
8000be2c:	e0 47 07 ff 	cp.w	r7,2047
8000be30:	e0 84 00 b5 	brge	8000bf9a <__avr32_f64_div_round_subnormal+0x2e>
8000be34:	f2 06 16 14 	lsr	r6,r9,0x14
8000be38:	a9 79       	lsl	r9,0x9
8000be3a:	f3 e8 13 79 	or	r9,r9,r8>>0x17
8000be3e:	a9 78       	lsl	r8,0x9
8000be40:	bd b9       	sbr	r9,0x1d
8000be42:	e4 19 3f ff 	andh	r9,0x3fff
8000be46:	ab d6       	cbr	r6,0xb
8000be48:	e0 80 00 e2 	breq	8000c00c <__avr32_f64_div_round_subnormal+0xa0>
8000be4c:	e0 46 07 ff 	cp.w	r6,2047
8000be50:	e0 84 00 b2 	brge	8000bfb4 <__avr32_f64_div_round_subnormal+0x48>
8000be54:	0c 17       	sub	r7,r6
8000be56:	fe 37 fc 01 	sub	r7,-1023
8000be5a:	fc 1c 80 00 	movh	r12,0x8000
8000be5e:	f8 03 16 01 	lsr	r3,r12,0x1
8000be62:	e9 d9 c3 62 	bfextu	r4,r9,0x1b,0x2
8000be66:	5c d4       	com	r4
8000be68:	e7 d4 d3 82 	bfins	r3,r4,0x1c,0x2
8000be6c:	e6 09 06 44 	mulu.d	r4,r3,r9
8000be70:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000be74:	e6 05 06 44 	mulu.d	r4,r3,r5
8000be78:	ea 03 15 02 	lsl	r3,r5,0x2
8000be7c:	e6 09 06 44 	mulu.d	r4,r3,r9
8000be80:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000be84:	e6 05 06 44 	mulu.d	r4,r3,r5
8000be88:	ea 03 15 02 	lsl	r3,r5,0x2
8000be8c:	e6 09 06 44 	mulu.d	r4,r3,r9
8000be90:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000be94:	e6 05 06 44 	mulu.d	r4,r3,r5
8000be98:	ea 03 15 02 	lsl	r3,r5,0x2
8000be9c:	e6 08 06 40 	mulu.d	r0,r3,r8
8000bea0:	e4 09 07 40 	macu.d	r0,r2,r9
8000bea4:	e6 09 06 44 	mulu.d	r4,r3,r9
8000bea8:	02 04       	add	r4,r1
8000beaa:	5c 05       	acr	r5
8000beac:	a3 65       	lsl	r5,0x2
8000beae:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000beb2:	a3 64       	lsl	r4,0x2
8000beb4:	5c 34       	neg	r4
8000beb6:	f8 05 01 45 	sbc	r5,r12,r5
8000beba:	e6 04 06 40 	mulu.d	r0,r3,r4
8000bebe:	e4 05 07 40 	macu.d	r0,r2,r5
8000bec2:	e6 05 06 44 	mulu.d	r4,r3,r5
8000bec6:	02 04       	add	r4,r1
8000bec8:	5c 05       	acr	r5
8000beca:	ea 03 15 02 	lsl	r3,r5,0x2
8000bece:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000bed2:	e8 02 15 02 	lsl	r2,r4,0x2
8000bed6:	e6 08 06 40 	mulu.d	r0,r3,r8
8000beda:	e4 09 07 40 	macu.d	r0,r2,r9
8000bede:	e6 09 06 44 	mulu.d	r4,r3,r9
8000bee2:	02 04       	add	r4,r1
8000bee4:	5c 05       	acr	r5
8000bee6:	a3 65       	lsl	r5,0x2
8000bee8:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000beec:	a3 64       	lsl	r4,0x2
8000beee:	5c 34       	neg	r4
8000bef0:	f8 05 01 45 	sbc	r5,r12,r5
8000bef4:	e6 04 06 40 	mulu.d	r0,r3,r4
8000bef8:	e4 05 07 40 	macu.d	r0,r2,r5
8000befc:	e6 05 06 44 	mulu.d	r4,r3,r5
8000bf00:	02 04       	add	r4,r1
8000bf02:	5c 05       	acr	r5
8000bf04:	ea 03 15 02 	lsl	r3,r5,0x2
8000bf08:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000bf0c:	e8 02 15 02 	lsl	r2,r4,0x2
8000bf10:	e6 0a 06 40 	mulu.d	r0,r3,r10
8000bf14:	e4 0b 07 40 	macu.d	r0,r2,r11
8000bf18:	e6 0b 06 42 	mulu.d	r2,r3,r11
8000bf1c:	02 02       	add	r2,r1
8000bf1e:	5c 03       	acr	r3
8000bf20:	ed b3 00 1c 	bld	r3,0x1c
8000bf24:	c0 90       	breq	8000bf36 <__avr32_f64_div+0x12a>
8000bf26:	a1 72       	lsl	r2,0x1
8000bf28:	5c f3       	rol	r3
8000bf2a:	20 17       	sub	r7,1
8000bf2c:	a3 9a       	lsr	r10,0x3
8000bf2e:	f5 eb 11 da 	or	r10,r10,r11<<0x1d
8000bf32:	a3 9b       	lsr	r11,0x3
8000bf34:	c0 58       	rjmp	8000bf3e <__avr32_f64_div+0x132>
8000bf36:	a5 8a       	lsr	r10,0x4
8000bf38:	f5 eb 11 ca 	or	r10,r10,r11<<0x1c
8000bf3c:	a5 8b       	lsr	r11,0x4
8000bf3e:	58 07       	cp.w	r7,0
8000bf40:	e0 8a 00 8b 	brle	8000c056 <__avr32_f64_div_res_subnormal>
8000bf44:	e0 12 ff 00 	andl	r2,0xff00
8000bf48:	e8 12 00 80 	orl	r2,0x80
8000bf4c:	e6 08 06 40 	mulu.d	r0,r3,r8
8000bf50:	e4 09 07 40 	macu.d	r0,r2,r9
8000bf54:	e4 08 06 44 	mulu.d	r4,r2,r8
8000bf58:	e6 09 06 48 	mulu.d	r8,r3,r9
8000bf5c:	00 05       	add	r5,r0
8000bf5e:	f0 01 00 48 	adc	r8,r8,r1
8000bf62:	5c 09       	acr	r9
8000bf64:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000bf68:	58 04       	cp.w	r4,0
8000bf6a:	5c 25       	cpc	r5

8000bf6c <__avr32_f64_div_round_subnormal>:
8000bf6c:	f4 08 13 00 	cpc	r8,r10
8000bf70:	f6 09 13 00 	cpc	r9,r11
8000bf74:	5f 36       	srlo	r6
8000bf76:	f8 06 17 00 	moveq	r6,r12
8000bf7a:	e4 0a 16 08 	lsr	r10,r2,0x8
8000bf7e:	f5 e3 11 8a 	or	r10,r10,r3<<0x18
8000bf82:	e6 0b 16 08 	lsr	r11,r3,0x8
8000bf86:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000bf8a:	ed be 00 1f 	bld	lr,0x1f
8000bf8e:	ef bb 00 1f 	bst	r11,0x1f
8000bf92:	0c 0a       	add	r10,r6
8000bf94:	5c 0b       	acr	r11
8000bf96:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000bf9a:	e4 1b 00 0f 	andh	r11,0xf
8000bf9e:	14 4b       	or	r11,r10
8000bfa0:	e0 81 00 a7 	brne	8000c0ee <__avr32_f64_div_res_subnormal+0x98>
8000bfa4:	f2 06 16 14 	lsr	r6,r9,0x14
8000bfa8:	ab d6       	cbr	r6,0xb
8000bfaa:	e0 46 07 ff 	cp.w	r6,2047
8000bfae:	e0 81 00 a4 	brne	8000c0f6 <__avr32_f64_div_res_subnormal+0xa0>
8000bfb2:	c9 e8       	rjmp	8000c0ee <__avr32_f64_div_res_subnormal+0x98>
8000bfb4:	e4 19 00 0f 	andh	r9,0xf
8000bfb8:	10 49       	or	r9,r8
8000bfba:	e0 81 00 9a 	brne	8000c0ee <__avr32_f64_div_res_subnormal+0x98>
8000bfbe:	c9 28       	rjmp	8000c0e2 <__avr32_f64_div_res_subnormal+0x8c>
8000bfc0:	a3 7b       	lsl	r11,0x3
8000bfc2:	f7 ea 13 db 	or	r11,r11,r10>>0x1d
8000bfc6:	a3 7a       	lsl	r10,0x3
8000bfc8:	f5 eb 10 04 	or	r4,r10,r11
8000bfcc:	e0 80 00 a0 	breq	8000c10c <__avr32_f64_div_op1_zero>
8000bfd0:	f6 04 12 00 	clz	r4,r11
8000bfd4:	c1 70       	breq	8000c002 <__avr32_f64_div_round_subnormal+0x96>
8000bfd6:	c0 c3       	brcs	8000bfee <__avr32_f64_div_round_subnormal+0x82>
8000bfd8:	e8 05 11 20 	rsub	r5,r4,32
8000bfdc:	f6 04 09 4b 	lsl	r11,r11,r4
8000bfe0:	f4 05 0a 45 	lsr	r5,r10,r5
8000bfe4:	0a 4b       	or	r11,r5
8000bfe6:	f4 04 09 4a 	lsl	r10,r10,r4
8000bfea:	08 17       	sub	r7,r4
8000bfec:	c0 b8       	rjmp	8000c002 <__avr32_f64_div_round_subnormal+0x96>
8000bfee:	f4 04 12 00 	clz	r4,r10
8000bff2:	f9 b4 03 00 	movlo	r4,0
8000bff6:	f7 b4 02 e0 	subhs	r4,-32
8000bffa:	f4 04 09 4b 	lsl	r11,r10,r4
8000bffe:	30 0a       	mov	r10,0
8000c000:	08 17       	sub	r7,r4
8000c002:	a3 8a       	lsr	r10,0x2
8000c004:	f5 eb 11 ea 	or	r10,r10,r11<<0x1e
8000c008:	a3 8b       	lsr	r11,0x2
8000c00a:	c1 1b       	rjmp	8000be2c <__avr32_f64_div+0x20>
8000c00c:	a3 79       	lsl	r9,0x3
8000c00e:	f3 e8 13 d9 	or	r9,r9,r8>>0x1d
8000c012:	a3 78       	lsl	r8,0x3
8000c014:	f3 e8 10 04 	or	r4,r9,r8
8000c018:	c6 f0       	breq	8000c0f6 <__avr32_f64_div_res_subnormal+0xa0>
8000c01a:	f2 04 12 00 	clz	r4,r9
8000c01e:	c1 70       	breq	8000c04c <__avr32_f64_div_round_subnormal+0xe0>
8000c020:	c0 c3       	brcs	8000c038 <__avr32_f64_div_round_subnormal+0xcc>
8000c022:	e8 05 11 20 	rsub	r5,r4,32
8000c026:	f2 04 09 49 	lsl	r9,r9,r4
8000c02a:	f0 05 0a 45 	lsr	r5,r8,r5
8000c02e:	0a 49       	or	r9,r5
8000c030:	f0 04 09 48 	lsl	r8,r8,r4
8000c034:	08 16       	sub	r6,r4
8000c036:	c0 b8       	rjmp	8000c04c <__avr32_f64_div_round_subnormal+0xe0>
8000c038:	f0 04 12 00 	clz	r4,r8
8000c03c:	f9 b4 03 00 	movlo	r4,0
8000c040:	f7 b4 02 e0 	subhs	r4,-32
8000c044:	f0 04 09 49 	lsl	r9,r8,r4
8000c048:	30 08       	mov	r8,0
8000c04a:	08 16       	sub	r6,r4
8000c04c:	a3 88       	lsr	r8,0x2
8000c04e:	f1 e9 11 e8 	or	r8,r8,r9<<0x1e
8000c052:	a3 89       	lsr	r9,0x2
8000c054:	cf ca       	rjmp	8000be4c <__avr32_f64_div+0x40>

8000c056 <__avr32_f64_div_res_subnormal>:
8000c056:	5c 37       	neg	r7
8000c058:	2f f7       	sub	r7,-1
8000c05a:	f1 b7 04 c0 	satu	r7,0x6
8000c05e:	e0 47 00 20 	cp.w	r7,32
8000c062:	c1 54       	brge	8000c08c <__avr32_f64_div_res_subnormal+0x36>
8000c064:	ee 06 11 20 	rsub	r6,r7,32
8000c068:	e4 07 0a 42 	lsr	r2,r2,r7
8000c06c:	e6 06 09 4c 	lsl	r12,r3,r6
8000c070:	18 42       	or	r2,r12
8000c072:	e6 07 0a 43 	lsr	r3,r3,r7
8000c076:	f4 06 09 41 	lsl	r1,r10,r6
8000c07a:	f4 07 0a 4a 	lsr	r10,r10,r7
8000c07e:	f6 06 09 4c 	lsl	r12,r11,r6
8000c082:	18 4a       	or	r10,r12
8000c084:	f6 07 0a 4b 	lsr	r11,r11,r7
8000c088:	30 00       	mov	r0,0
8000c08a:	c1 58       	rjmp	8000c0b4 <__avr32_f64_div_res_subnormal+0x5e>
8000c08c:	ee 06 11 20 	rsub	r6,r7,32
8000c090:	f9 b0 00 00 	moveq	r0,0
8000c094:	f9 bc 00 00 	moveq	r12,0
8000c098:	c0 50       	breq	8000c0a2 <__avr32_f64_div_res_subnormal+0x4c>
8000c09a:	f4 06 09 40 	lsl	r0,r10,r6
8000c09e:	f6 06 09 4c 	lsl	r12,r11,r6
8000c0a2:	e6 07 0a 42 	lsr	r2,r3,r7
8000c0a6:	30 03       	mov	r3,0
8000c0a8:	f4 07 0a 41 	lsr	r1,r10,r7
8000c0ac:	18 41       	or	r1,r12
8000c0ae:	f6 07 0a 4a 	lsr	r10,r11,r7
8000c0b2:	30 0b       	mov	r11,0
8000c0b4:	e0 12 ff 00 	andl	r2,0xff00
8000c0b8:	e8 12 00 80 	orl	r2,0x80
8000c0bc:	e6 08 06 46 	mulu.d	r6,r3,r8
8000c0c0:	e4 09 07 46 	macu.d	r6,r2,r9
8000c0c4:	e4 08 06 44 	mulu.d	r4,r2,r8
8000c0c8:	e6 09 06 48 	mulu.d	r8,r3,r9
8000c0cc:	0c 05       	add	r5,r6
8000c0ce:	f0 07 00 48 	adc	r8,r8,r7
8000c0d2:	5c 09       	acr	r9
8000c0d4:	30 07       	mov	r7,0
8000c0d6:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000c0da:	00 34       	cp.w	r4,r0
8000c0dc:	e2 05 13 00 	cpc	r5,r1
8000c0e0:	c4 6b       	rjmp	8000bf6c <__avr32_f64_div_round_subnormal>
8000c0e2:	1c 9b       	mov	r11,lr
8000c0e4:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c0e8:	30 0a       	mov	r10,0
8000c0ea:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c0ee:	3f fb       	mov	r11,-1
8000c0f0:	30 0a       	mov	r10,0
8000c0f2:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c0f6:	f5 eb 10 04 	or	r4,r10,r11
8000c0fa:	c0 90       	breq	8000c10c <__avr32_f64_div_op1_zero>
8000c0fc:	1c 9b       	mov	r11,lr
8000c0fe:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c102:	ea 1b 7f f0 	orh	r11,0x7ff0
8000c106:	30 0a       	mov	r10,0
8000c108:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc

8000c10c <__avr32_f64_div_op1_zero>:
8000c10c:	f1 e9 10 15 	or	r5,r8,r9<<0x1
8000c110:	ce f0       	breq	8000c0ee <__avr32_f64_div_res_subnormal+0x98>
8000c112:	e9 d9 c2 8b 	bfextu	r4,r9,0x14,0xb
8000c116:	e0 44 07 ff 	cp.w	r4,2047
8000c11a:	ce 41       	brne	8000c0e2 <__avr32_f64_div_res_subnormal+0x8c>
8000c11c:	f1 e9 10 c5 	or	r5,r8,r9<<0xc
8000c120:	ce 10       	breq	8000c0e2 <__avr32_f64_div_res_subnormal+0x8c>
8000c122:	ce 6b       	rjmp	8000c0ee <__avr32_f64_div_res_subnormal+0x98>

8000c124 <__avr32_udiv64>:
8000c124:	d4 31       	pushm	r0-r7,lr
8000c126:	1a 97       	mov	r7,sp
8000c128:	20 3d       	sub	sp,12
8000c12a:	10 9c       	mov	r12,r8
8000c12c:	12 9e       	mov	lr,r9
8000c12e:	14 93       	mov	r3,r10
8000c130:	58 09       	cp.w	r9,0
8000c132:	e0 81 00 bd 	brne	8000c2ac <__avr32_udiv64+0x188>
8000c136:	16 38       	cp.w	r8,r11
8000c138:	e0 88 00 40 	brls	8000c1b8 <__avr32_udiv64+0x94>
8000c13c:	f0 08 12 00 	clz	r8,r8
8000c140:	c0 d0       	breq	8000c15a <__avr32_udiv64+0x36>
8000c142:	f6 08 09 4b 	lsl	r11,r11,r8
8000c146:	f0 09 11 20 	rsub	r9,r8,32
8000c14a:	f8 08 09 4c 	lsl	r12,r12,r8
8000c14e:	f4 09 0a 49 	lsr	r9,r10,r9
8000c152:	f4 08 09 43 	lsl	r3,r10,r8
8000c156:	f3 eb 10 0b 	or	r11,r9,r11
8000c15a:	f8 0e 16 10 	lsr	lr,r12,0x10
8000c15e:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000c162:	f6 0e 0d 00 	divu	r0,r11,lr
8000c166:	e6 0b 16 10 	lsr	r11,r3,0x10
8000c16a:	00 99       	mov	r9,r0
8000c16c:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c170:	e0 0a 02 48 	mul	r8,r0,r10
8000c174:	10 3b       	cp.w	r11,r8
8000c176:	c0 a2       	brcc	8000c18a <__avr32_udiv64+0x66>
8000c178:	20 19       	sub	r9,1
8000c17a:	18 0b       	add	r11,r12
8000c17c:	18 3b       	cp.w	r11,r12
8000c17e:	c0 63       	brcs	8000c18a <__avr32_udiv64+0x66>
8000c180:	10 3b       	cp.w	r11,r8
8000c182:	f7 b9 03 01 	sublo	r9,1
8000c186:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c18a:	f6 08 01 01 	sub	r1,r11,r8
8000c18e:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000c192:	e2 0e 0d 00 	divu	r0,r1,lr
8000c196:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000c19a:	00 98       	mov	r8,r0
8000c19c:	e0 0a 02 4a 	mul	r10,r0,r10
8000c1a0:	14 33       	cp.w	r3,r10
8000c1a2:	c0 82       	brcc	8000c1b2 <__avr32_udiv64+0x8e>
8000c1a4:	20 18       	sub	r8,1
8000c1a6:	18 03       	add	r3,r12
8000c1a8:	18 33       	cp.w	r3,r12
8000c1aa:	c0 43       	brcs	8000c1b2 <__avr32_udiv64+0x8e>
8000c1ac:	14 33       	cp.w	r3,r10
8000c1ae:	f7 b8 03 01 	sublo	r8,1
8000c1b2:	f1 e9 11 08 	or	r8,r8,r9<<0x10
8000c1b6:	cd f8       	rjmp	8000c374 <__avr32_udiv64+0x250>
8000c1b8:	58 08       	cp.w	r8,0
8000c1ba:	c0 51       	brne	8000c1c4 <__avr32_udiv64+0xa0>
8000c1bc:	30 19       	mov	r9,1
8000c1be:	f2 08 0d 08 	divu	r8,r9,r8
8000c1c2:	10 9c       	mov	r12,r8
8000c1c4:	f8 06 12 00 	clz	r6,r12
8000c1c8:	c0 41       	brne	8000c1d0 <__avr32_udiv64+0xac>
8000c1ca:	18 1b       	sub	r11,r12
8000c1cc:	30 19       	mov	r9,1
8000c1ce:	c4 08       	rjmp	8000c24e <__avr32_udiv64+0x12a>
8000c1d0:	ec 01 11 20 	rsub	r1,r6,32
8000c1d4:	f4 01 0a 49 	lsr	r9,r10,r1
8000c1d8:	f8 06 09 4c 	lsl	r12,r12,r6
8000c1dc:	f6 06 09 48 	lsl	r8,r11,r6
8000c1e0:	f6 01 0a 41 	lsr	r1,r11,r1
8000c1e4:	f3 e8 10 08 	or	r8,r9,r8
8000c1e8:	f8 03 16 10 	lsr	r3,r12,0x10
8000c1ec:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000c1f0:	e2 03 0d 00 	divu	r0,r1,r3
8000c1f4:	f0 0b 16 10 	lsr	r11,r8,0x10
8000c1f8:	00 9e       	mov	lr,r0
8000c1fa:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c1fe:	e0 05 02 49 	mul	r9,r0,r5
8000c202:	12 3b       	cp.w	r11,r9
8000c204:	c0 a2       	brcc	8000c218 <__avr32_udiv64+0xf4>
8000c206:	20 1e       	sub	lr,1
8000c208:	18 0b       	add	r11,r12
8000c20a:	18 3b       	cp.w	r11,r12
8000c20c:	c0 63       	brcs	8000c218 <__avr32_udiv64+0xf4>
8000c20e:	12 3b       	cp.w	r11,r9
8000c210:	f7 be 03 01 	sublo	lr,1
8000c214:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c218:	12 1b       	sub	r11,r9
8000c21a:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
8000c21e:	f6 03 0d 02 	divu	r2,r11,r3
8000c222:	f1 e3 11 08 	or	r8,r8,r3<<0x10
8000c226:	04 99       	mov	r9,r2
8000c228:	e4 05 02 4b 	mul	r11,r2,r5
8000c22c:	16 38       	cp.w	r8,r11
8000c22e:	c0 a2       	brcc	8000c242 <__avr32_udiv64+0x11e>
8000c230:	20 19       	sub	r9,1
8000c232:	18 08       	add	r8,r12
8000c234:	18 38       	cp.w	r8,r12
8000c236:	c0 63       	brcs	8000c242 <__avr32_udiv64+0x11e>
8000c238:	16 38       	cp.w	r8,r11
8000c23a:	f7 b9 03 01 	sublo	r9,1
8000c23e:	f1 dc e3 08 	addcs	r8,r8,r12
8000c242:	f4 06 09 43 	lsl	r3,r10,r6
8000c246:	f0 0b 01 0b 	sub	r11,r8,r11
8000c24a:	f3 ee 11 09 	or	r9,r9,lr<<0x10
8000c24e:	f8 06 16 10 	lsr	r6,r12,0x10
8000c252:	fd dc c0 10 	bfextu	lr,r12,0x0,0x10
8000c256:	f6 06 0d 00 	divu	r0,r11,r6
8000c25a:	e6 0b 16 10 	lsr	r11,r3,0x10
8000c25e:	00 9a       	mov	r10,r0
8000c260:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c264:	e0 0e 02 48 	mul	r8,r0,lr
8000c268:	10 3b       	cp.w	r11,r8
8000c26a:	c0 a2       	brcc	8000c27e <__avr32_udiv64+0x15a>
8000c26c:	20 1a       	sub	r10,1
8000c26e:	18 0b       	add	r11,r12
8000c270:	18 3b       	cp.w	r11,r12
8000c272:	c0 63       	brcs	8000c27e <__avr32_udiv64+0x15a>
8000c274:	10 3b       	cp.w	r11,r8
8000c276:	f7 ba 03 01 	sublo	r10,1
8000c27a:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c27e:	f6 08 01 01 	sub	r1,r11,r8
8000c282:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000c286:	e2 06 0d 00 	divu	r0,r1,r6
8000c28a:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000c28e:	00 98       	mov	r8,r0
8000c290:	e0 0e 02 4b 	mul	r11,r0,lr
8000c294:	16 33       	cp.w	r3,r11
8000c296:	c0 82       	brcc	8000c2a6 <__avr32_udiv64+0x182>
8000c298:	20 18       	sub	r8,1
8000c29a:	18 03       	add	r3,r12
8000c29c:	18 33       	cp.w	r3,r12
8000c29e:	c0 43       	brcs	8000c2a6 <__avr32_udiv64+0x182>
8000c2a0:	16 33       	cp.w	r3,r11
8000c2a2:	f7 b8 03 01 	sublo	r8,1
8000c2a6:	f1 ea 11 08 	or	r8,r8,r10<<0x10
8000c2aa:	c6 98       	rjmp	8000c37c <__avr32_udiv64+0x258>
8000c2ac:	16 39       	cp.w	r9,r11
8000c2ae:	e0 8b 00 65 	brhi	8000c378 <__avr32_udiv64+0x254>
8000c2b2:	f2 09 12 00 	clz	r9,r9
8000c2b6:	c0 b1       	brne	8000c2cc <__avr32_udiv64+0x1a8>
8000c2b8:	10 3a       	cp.w	r10,r8
8000c2ba:	5f 2a       	srhs	r10
8000c2bc:	1c 3b       	cp.w	r11,lr
8000c2be:	5f b8       	srhi	r8
8000c2c0:	10 4a       	or	r10,r8
8000c2c2:	f2 0a 18 00 	cp.b	r10,r9
8000c2c6:	c5 90       	breq	8000c378 <__avr32_udiv64+0x254>
8000c2c8:	30 18       	mov	r8,1
8000c2ca:	c5 98       	rjmp	8000c37c <__avr32_udiv64+0x258>
8000c2cc:	f0 09 09 46 	lsl	r6,r8,r9
8000c2d0:	f2 03 11 20 	rsub	r3,r9,32
8000c2d4:	fc 09 09 4e 	lsl	lr,lr,r9
8000c2d8:	f0 03 0a 48 	lsr	r8,r8,r3
8000c2dc:	f6 09 09 4c 	lsl	r12,r11,r9
8000c2e0:	f4 03 0a 42 	lsr	r2,r10,r3
8000c2e4:	ef 46 ff f4 	st.w	r7[-12],r6
8000c2e8:	f6 03 0a 43 	lsr	r3,r11,r3
8000c2ec:	18 42       	or	r2,r12
8000c2ee:	f1 ee 10 0c 	or	r12,r8,lr
8000c2f2:	f8 01 16 10 	lsr	r1,r12,0x10
8000c2f6:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000c2fa:	e6 01 0d 04 	divu	r4,r3,r1
8000c2fe:	e4 03 16 10 	lsr	r3,r2,0x10
8000c302:	08 9e       	mov	lr,r4
8000c304:	e7 e5 11 03 	or	r3,r3,r5<<0x10
8000c308:	e8 06 02 48 	mul	r8,r4,r6
8000c30c:	10 33       	cp.w	r3,r8
8000c30e:	c0 a2       	brcc	8000c322 <__avr32_udiv64+0x1fe>
8000c310:	20 1e       	sub	lr,1
8000c312:	18 03       	add	r3,r12
8000c314:	18 33       	cp.w	r3,r12
8000c316:	c0 63       	brcs	8000c322 <__avr32_udiv64+0x1fe>
8000c318:	10 33       	cp.w	r3,r8
8000c31a:	f7 be 03 01 	sublo	lr,1
8000c31e:	e7 dc e3 03 	addcs	r3,r3,r12
8000c322:	10 13       	sub	r3,r8
8000c324:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
8000c328:	e6 01 0d 00 	divu	r0,r3,r1
8000c32c:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c330:	00 98       	mov	r8,r0
8000c332:	e0 06 02 46 	mul	r6,r0,r6
8000c336:	0c 3b       	cp.w	r11,r6
8000c338:	c0 a2       	brcc	8000c34c <__avr32_udiv64+0x228>
8000c33a:	20 18       	sub	r8,1
8000c33c:	18 0b       	add	r11,r12
8000c33e:	18 3b       	cp.w	r11,r12
8000c340:	c0 63       	brcs	8000c34c <__avr32_udiv64+0x228>
8000c342:	0c 3b       	cp.w	r11,r6
8000c344:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c348:	f7 b8 03 01 	sublo	r8,1
8000c34c:	f1 ee 11 08 	or	r8,r8,lr<<0x10
8000c350:	ee f4 ff f4 	ld.w	r4,r7[-12]
8000c354:	0c 1b       	sub	r11,r6
8000c356:	f0 04 06 42 	mulu.d	r2,r8,r4
8000c35a:	06 95       	mov	r5,r3
8000c35c:	16 35       	cp.w	r5,r11
8000c35e:	e0 8b 00 0a 	brhi	8000c372 <__avr32_udiv64+0x24e>
8000c362:	5f 0b       	sreq	r11
8000c364:	f4 09 09 49 	lsl	r9,r10,r9
8000c368:	12 32       	cp.w	r2,r9
8000c36a:	5f b9       	srhi	r9
8000c36c:	f7 e9 00 09 	and	r9,r11,r9
8000c370:	c0 60       	breq	8000c37c <__avr32_udiv64+0x258>
8000c372:	20 18       	sub	r8,1
8000c374:	30 09       	mov	r9,0
8000c376:	c0 38       	rjmp	8000c37c <__avr32_udiv64+0x258>
8000c378:	30 09       	mov	r9,0
8000c37a:	12 98       	mov	r8,r9
8000c37c:	10 9a       	mov	r10,r8
8000c37e:	12 93       	mov	r3,r9
8000c380:	10 92       	mov	r2,r8
8000c382:	12 9b       	mov	r11,r9
8000c384:	2f dd       	sub	sp,-12
8000c386:	d8 32       	popm	r0-r7,pc

8000c388 <__avr32_umod64>:
8000c388:	d4 31       	pushm	r0-r7,lr
8000c38a:	1a 97       	mov	r7,sp
8000c38c:	20 3d       	sub	sp,12
8000c38e:	10 9c       	mov	r12,r8
8000c390:	12 95       	mov	r5,r9
8000c392:	14 9e       	mov	lr,r10
8000c394:	16 91       	mov	r1,r11
8000c396:	16 96       	mov	r6,r11
8000c398:	58 09       	cp.w	r9,0
8000c39a:	e0 81 00 81 	brne	8000c49c <__avr32_umod64+0x114>
8000c39e:	16 38       	cp.w	r8,r11
8000c3a0:	e0 88 00 12 	brls	8000c3c4 <__avr32_umod64+0x3c>
8000c3a4:	f0 08 12 00 	clz	r8,r8
8000c3a8:	c4 e0       	breq	8000c444 <__avr32_umod64+0xbc>
8000c3aa:	f6 08 09 46 	lsl	r6,r11,r8
8000c3ae:	f8 08 09 4c 	lsl	r12,r12,r8
8000c3b2:	f0 0b 11 20 	rsub	r11,r8,32
8000c3b6:	f4 08 09 4e 	lsl	lr,r10,r8
8000c3ba:	f4 0b 0a 4b 	lsr	r11,r10,r11
8000c3be:	f7 e6 10 06 	or	r6,r11,r6
8000c3c2:	c4 18       	rjmp	8000c444 <__avr32_umod64+0xbc>
8000c3c4:	58 08       	cp.w	r8,0
8000c3c6:	c0 51       	brne	8000c3d0 <__avr32_umod64+0x48>
8000c3c8:	30 19       	mov	r9,1
8000c3ca:	f2 08 0d 08 	divu	r8,r9,r8
8000c3ce:	10 9c       	mov	r12,r8
8000c3d0:	f8 08 12 00 	clz	r8,r12
8000c3d4:	c0 31       	brne	8000c3da <__avr32_umod64+0x52>
8000c3d6:	18 16       	sub	r6,r12
8000c3d8:	c3 68       	rjmp	8000c444 <__avr32_umod64+0xbc>
8000c3da:	f0 03 11 20 	rsub	r3,r8,32
8000c3de:	f4 03 0a 4b 	lsr	r11,r10,r3
8000c3e2:	f8 08 09 4c 	lsl	r12,r12,r8
8000c3e6:	ec 08 09 49 	lsl	r9,r6,r8
8000c3ea:	ec 03 0a 43 	lsr	r3,r6,r3
8000c3ee:	f7 e9 10 09 	or	r9,r11,r9
8000c3f2:	f8 05 16 10 	lsr	r5,r12,0x10
8000c3f6:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000c3fa:	e6 05 0d 02 	divu	r2,r3,r5
8000c3fe:	f2 0e 16 10 	lsr	lr,r9,0x10
8000c402:	ec 02 02 4b 	mul	r11,r6,r2
8000c406:	fd e3 11 0e 	or	lr,lr,r3<<0x10
8000c40a:	16 3e       	cp.w	lr,r11
8000c40c:	c0 72       	brcc	8000c41a <__avr32_umod64+0x92>
8000c40e:	18 0e       	add	lr,r12
8000c410:	18 3e       	cp.w	lr,r12
8000c412:	c0 43       	brcs	8000c41a <__avr32_umod64+0x92>
8000c414:	16 3e       	cp.w	lr,r11
8000c416:	fd dc e3 0e 	addcs	lr,lr,r12
8000c41a:	fc 0b 01 03 	sub	r3,lr,r11
8000c41e:	f3 d9 c0 10 	bfextu	r9,r9,0x0,0x10
8000c422:	e6 05 0d 02 	divu	r2,r3,r5
8000c426:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000c42a:	a5 36       	mul	r6,r2
8000c42c:	0c 39       	cp.w	r9,r6
8000c42e:	c0 72       	brcc	8000c43c <__avr32_umod64+0xb4>
8000c430:	18 09       	add	r9,r12
8000c432:	18 39       	cp.w	r9,r12
8000c434:	c0 43       	brcs	8000c43c <__avr32_umod64+0xb4>
8000c436:	0c 39       	cp.w	r9,r6
8000c438:	f3 dc e3 09 	addcs	r9,r9,r12
8000c43c:	f2 06 01 06 	sub	r6,r9,r6
8000c440:	f4 08 09 4e 	lsl	lr,r10,r8
8000c444:	f8 0a 16 10 	lsr	r10,r12,0x10
8000c448:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000c44c:	ec 0a 0d 02 	divu	r2,r6,r10
8000c450:	fc 09 16 10 	lsr	r9,lr,0x10
8000c454:	ea 02 02 4b 	mul	r11,r5,r2
8000c458:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000c45c:	16 39       	cp.w	r9,r11
8000c45e:	c0 72       	brcc	8000c46c <__avr32_umod64+0xe4>
8000c460:	18 09       	add	r9,r12
8000c462:	18 39       	cp.w	r9,r12
8000c464:	c0 43       	brcs	8000c46c <__avr32_umod64+0xe4>
8000c466:	16 39       	cp.w	r9,r11
8000c468:	f3 dc e3 09 	addcs	r9,r9,r12
8000c46c:	f2 0b 01 0b 	sub	r11,r9,r11
8000c470:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000c474:	f6 0a 0d 0a 	divu	r10,r11,r10
8000c478:	fd eb 11 0e 	or	lr,lr,r11<<0x10
8000c47c:	ea 0a 02 4a 	mul	r10,r5,r10
8000c480:	14 3e       	cp.w	lr,r10
8000c482:	c0 72       	brcc	8000c490 <__avr32_umod64+0x108>
8000c484:	18 0e       	add	lr,r12
8000c486:	18 3e       	cp.w	lr,r12
8000c488:	c0 43       	brcs	8000c490 <__avr32_umod64+0x108>
8000c48a:	14 3e       	cp.w	lr,r10
8000c48c:	fd dc e3 0e 	addcs	lr,lr,r12
8000c490:	fc 0a 01 0a 	sub	r10,lr,r10
8000c494:	30 0b       	mov	r11,0
8000c496:	f4 08 0a 4a 	lsr	r10,r10,r8
8000c49a:	c7 b8       	rjmp	8000c590 <__avr32_umod64+0x208>
8000c49c:	16 39       	cp.w	r9,r11
8000c49e:	e0 8b 00 79 	brhi	8000c590 <__avr32_umod64+0x208>
8000c4a2:	f2 09 12 00 	clz	r9,r9
8000c4a6:	c1 21       	brne	8000c4ca <__avr32_umod64+0x142>
8000c4a8:	10 3a       	cp.w	r10,r8
8000c4aa:	5f 2b       	srhs	r11
8000c4ac:	0a 31       	cp.w	r1,r5
8000c4ae:	5f ba       	srhi	r10
8000c4b0:	f7 ea 10 0a 	or	r10,r11,r10
8000c4b4:	f2 0a 18 00 	cp.b	r10,r9
8000c4b8:	c0 60       	breq	8000c4c4 <__avr32_umod64+0x13c>
8000c4ba:	fc 08 01 0c 	sub	r12,lr,r8
8000c4be:	e2 05 01 46 	sbc	r6,r1,r5
8000c4c2:	18 9e       	mov	lr,r12
8000c4c4:	0c 9b       	mov	r11,r6
8000c4c6:	1c 9a       	mov	r10,lr
8000c4c8:	c6 48       	rjmp	8000c590 <__avr32_umod64+0x208>
8000c4ca:	ea 09 09 4c 	lsl	r12,r5,r9
8000c4ce:	f2 06 11 20 	rsub	r6,r9,32
8000c4d2:	f6 09 09 4b 	lsl	r11,r11,r9
8000c4d6:	f0 09 09 42 	lsl	r2,r8,r9
8000c4da:	ef 46 ff f4 	st.w	r7[-12],r6
8000c4de:	f0 06 0a 48 	lsr	r8,r8,r6
8000c4e2:	18 48       	or	r8,r12
8000c4e4:	e2 06 0a 4c 	lsr	r12,r1,r6
8000c4e8:	f4 09 09 43 	lsl	r3,r10,r9
8000c4ec:	fd d8 c0 10 	bfextu	lr,r8,0x0,0x10
8000c4f0:	f4 06 0a 4a 	lsr	r10,r10,r6
8000c4f4:	16 4a       	or	r10,r11
8000c4f6:	f0 0b 16 10 	lsr	r11,r8,0x10
8000c4fa:	f8 0b 0d 04 	divu	r4,r12,r11
8000c4fe:	f4 0c 16 10 	lsr	r12,r10,0x10
8000c502:	08 91       	mov	r1,r4
8000c504:	f9 e5 11 0c 	or	r12,r12,r5<<0x10
8000c508:	e8 0e 02 46 	mul	r6,r4,lr
8000c50c:	0c 3c       	cp.w	r12,r6
8000c50e:	c0 a2       	brcc	8000c522 <__avr32_umod64+0x19a>
8000c510:	20 11       	sub	r1,1
8000c512:	10 0c       	add	r12,r8
8000c514:	10 3c       	cp.w	r12,r8
8000c516:	c0 63       	brcs	8000c522 <__avr32_umod64+0x19a>
8000c518:	0c 3c       	cp.w	r12,r6
8000c51a:	f7 b1 03 01 	sublo	r1,1
8000c51e:	f9 d8 e3 0c 	addcs	r12,r12,r8
8000c522:	0c 1c       	sub	r12,r6
8000c524:	f5 da c0 10 	bfextu	r10,r10,0x0,0x10
8000c528:	f8 0b 0d 04 	divu	r4,r12,r11
8000c52c:	f5 e5 11 0b 	or	r11,r10,r5<<0x10
8000c530:	08 96       	mov	r6,r4
8000c532:	e8 0e 02 4e 	mul	lr,r4,lr
8000c536:	1c 3b       	cp.w	r11,lr
8000c538:	c0 a2       	brcc	8000c54c <__avr32_umod64+0x1c4>
8000c53a:	20 16       	sub	r6,1
8000c53c:	10 0b       	add	r11,r8
8000c53e:	10 3b       	cp.w	r11,r8
8000c540:	c0 63       	brcs	8000c54c <__avr32_umod64+0x1c4>
8000c542:	1c 3b       	cp.w	r11,lr
8000c544:	f7 b6 03 01 	sublo	r6,1
8000c548:	f7 d8 e3 0b 	addcs	r11,r11,r8
8000c54c:	ed e1 11 01 	or	r1,r6,r1<<0x10
8000c550:	1c 1b       	sub	r11,lr
8000c552:	e2 02 06 40 	mulu.d	r0,r1,r2
8000c556:	00 9e       	mov	lr,r0
8000c558:	02 9c       	mov	r12,r1
8000c55a:	16 3c       	cp.w	r12,r11
8000c55c:	e0 8b 00 08 	brhi	8000c56c <__avr32_umod64+0x1e4>
8000c560:	5f 06       	sreq	r6
8000c562:	06 30       	cp.w	r0,r3
8000c564:	5f ba       	srhi	r10
8000c566:	ed ea 00 0a 	and	r10,r6,r10
8000c56a:	c0 60       	breq	8000c576 <__avr32_umod64+0x1ee>
8000c56c:	fc 02 01 04 	sub	r4,lr,r2
8000c570:	f8 08 01 4c 	sbc	r12,r12,r8
8000c574:	08 9e       	mov	lr,r4
8000c576:	e6 0e 01 0a 	sub	r10,r3,lr
8000c57a:	f6 0c 01 4c 	sbc	r12,r11,r12
8000c57e:	ee f1 ff f4 	ld.w	r1,r7[-12]
8000c582:	f8 09 0a 4b 	lsr	r11,r12,r9
8000c586:	f4 09 0a 4a 	lsr	r10,r10,r9
8000c58a:	f8 01 09 4c 	lsl	r12,r12,r1
8000c58e:	18 4a       	or	r10,r12
8000c590:	2f dd       	sub	sp,-12
8000c592:	d8 32       	popm	r0-r7,pc

Disassembly of section .exception:

8000c600 <_evba>:
_evba:

        .org  0x000
        // Unrecoverable Exception.
_handle_Unrecoverable_Exception:
        rjmp $
8000c600:	c0 08       	rjmp	8000c600 <_evba>
	...

8000c604 <_handle_TLB_Multiple_Hit>:

        .org  0x004
        // TLB Multiple Hit: UNUSED IN AVR32UC.
_handle_TLB_Multiple_Hit:
        rjmp $
8000c604:	c0 08       	rjmp	8000c604 <_handle_TLB_Multiple_Hit>
	...

8000c608 <_handle_Bus_Error_Data_Fetch>:

        .org  0x008
        // Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
        rjmp $
8000c608:	c0 08       	rjmp	8000c608 <_handle_Bus_Error_Data_Fetch>
	...

8000c60c <_handle_Bus_Error_Instruction_Fetch>:

        .org  0x00C
         // Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
        rjmp $
8000c60c:	c0 08       	rjmp	8000c60c <_handle_Bus_Error_Instruction_Fetch>
	...

8000c610 <_handle_NMI>:

        .org  0x010
        // NMI.
_handle_NMI:
        rjmp $
8000c610:	c0 08       	rjmp	8000c610 <_handle_NMI>
	...

8000c614 <_handle_Instruction_Address>:

        .org  0x014
        // Instruction Address.
_handle_Instruction_Address:
        rjmp $
8000c614:	c0 08       	rjmp	8000c614 <_handle_Instruction_Address>
	...

8000c618 <_handle_ITLB_Protection>:

        .org  0x018
        // ITLB Protection.
_handle_ITLB_Protection:
        rjmp $
8000c618:	c0 08       	rjmp	8000c618 <_handle_ITLB_Protection>
	...

8000c61c <_handle_Breakpoint>:

        .org  0x01C
        // Breakpoint.
_handle_Breakpoint:
        rjmp $
8000c61c:	c0 08       	rjmp	8000c61c <_handle_Breakpoint>
	...

8000c620 <_handle_Illegal_Opcode>:

        .org  0x020
        // Illegal Opcode.
_handle_Illegal_Opcode:
        rjmp $
8000c620:	c0 08       	rjmp	8000c620 <_handle_Illegal_Opcode>
	...

8000c624 <_handle_Unimplemented_Instruction>:

        .org  0x024
        // Unimplemented Instruction.
_handle_Unimplemented_Instruction:
        rjmp $
8000c624:	c0 08       	rjmp	8000c624 <_handle_Unimplemented_Instruction>
	...

8000c628 <_handle_Privilege_Violation>:

        .org  0x028
        // Privilege Violation.
_handle_Privilege_Violation:
        rjmp $
8000c628:	c0 08       	rjmp	8000c628 <_handle_Privilege_Violation>
	...

8000c62c <_handle_Floating_Point>:

        .org  0x02C
        // Floating-Point: UNUSED IN AVR32UC.
_handle_Floating_Point:
        rjmp $
8000c62c:	c0 08       	rjmp	8000c62c <_handle_Floating_Point>
	...

8000c630 <_handle_Coprocessor_Absent>:

        .org  0x030
        // Coprocessor Absent: UNUSED IN AVR32UC.
_handle_Coprocessor_Absent:
        rjmp $
8000c630:	c0 08       	rjmp	8000c630 <_handle_Coprocessor_Absent>
	...

8000c634 <_handle_Data_Address_Read>:

        .org  0x034
        // Data Address (Read).
_handle_Data_Address_Read:
        rjmp $
8000c634:	c0 08       	rjmp	8000c634 <_handle_Data_Address_Read>
	...

8000c638 <_handle_Data_Address_Write>:

        .org  0x038
        // Data Address (Write).
_handle_Data_Address_Write:
        rjmp $
8000c638:	c0 08       	rjmp	8000c638 <_handle_Data_Address_Write>
	...

8000c63c <_handle_DTLB_Protection_Read>:

        .org  0x03C
        // DTLB Protection (Read).
_handle_DTLB_Protection_Read:
        rjmp $
8000c63c:	c0 08       	rjmp	8000c63c <_handle_DTLB_Protection_Read>
	...

8000c640 <_handle_DTLB_Protection_Write>:

        .org  0x040
        // DTLB Protection (Write).
_handle_DTLB_Protection_Write:
        rjmp $
8000c640:	c0 08       	rjmp	8000c640 <_handle_DTLB_Protection_Write>
	...

8000c644 <_handle_DTLB_Modified>:

        .org  0x044
        // DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
        rjmp $
8000c644:	c0 08       	rjmp	8000c644 <_handle_DTLB_Modified>
	...

8000c650 <_handle_ITLB_Miss>:

        .org  0x050
        // ITLB Miss: UNUSED IN AVR32UC.
_handle_ITLB_Miss:
        rjmp $
8000c650:	c0 08       	rjmp	8000c650 <_handle_ITLB_Miss>
	...

8000c660 <_handle_DTLB_Miss_Read>:

        .org  0x060
        // DTLB Miss (Read): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Read:
        rjmp $
8000c660:	c0 08       	rjmp	8000c660 <_handle_DTLB_Miss_Read>
	...

8000c670 <_handle_DTLB_Miss_Write>:

        .org  0x070
        // DTLB Miss (Write): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Write:
        rjmp $
8000c670:	c0 08       	rjmp	8000c670 <_handle_DTLB_Miss_Write>
	...

8000c700 <_handle_Supervisor_Call>:

        .org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
8000c700:	fe cf 70 ec 	sub	pc,pc,28908

8000c704 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
8000c704:	30 0c       	mov	r12,0
8000c706:	fe b0 c3 fb 	rcall	80004efc <_get_interrupt_handler>
8000c70a:	58 0c       	cp.w	r12,0
8000c70c:	f8 0f 17 10 	movne	pc,r12
8000c710:	d6 03       	rete

8000c712 <_int1>:
8000c712:	30 1c       	mov	r12,1
8000c714:	fe b0 c3 f4 	rcall	80004efc <_get_interrupt_handler>
8000c718:	58 0c       	cp.w	r12,0
8000c71a:	f8 0f 17 10 	movne	pc,r12
8000c71e:	d6 03       	rete

8000c720 <_int2>:
8000c720:	30 2c       	mov	r12,2
8000c722:	fe b0 c3 ed 	rcall	80004efc <_get_interrupt_handler>
8000c726:	58 0c       	cp.w	r12,0
8000c728:	f8 0f 17 10 	movne	pc,r12
8000c72c:	d6 03       	rete

8000c72e <_int3>:
8000c72e:	30 3c       	mov	r12,3
8000c730:	fe b0 c3 e6 	rcall	80004efc <_get_interrupt_handler>
8000c734:	58 0c       	cp.w	r12,0
8000c736:	f8 0f 17 10 	movne	pc,r12
8000c73a:	d6 03       	rete

8000c73c <ipr_val>:
8000c73c:	00 00 01 04 40 00 01 12 80 00 01 20 c0 00 01 2e     ....@...... ....
8000c74c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c75c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c76c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c77c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c78c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c79c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c7ac:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c7bc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c7cc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c7dc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c7ec:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c7fc:	d7 03 d7 03                                         ....
